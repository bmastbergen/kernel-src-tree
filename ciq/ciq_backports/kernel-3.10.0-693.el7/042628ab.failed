HID: wacom: Discover device_type from HID descriptor for all devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Discover device_type from HID descriptor for all devices (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.18%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 042628abd59c9a034797bd3083f806fa17cda62d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/042628ab.failed

Currently, we assume a device_type of BTN_TOOL_PEN before scanning the
HID descriptor and then change the device_type if what we discover
proves that assumption wrong. This way of doing things makes it more
difficult to figure out if a device (particularly a HID_GENERIC device)
actually does tablet/touch input or is something completley different.

This patch leaves device_type at its initial value of 0 and then calls
'wacom_parse_hid' for every device (not just those that have touch).
As we map the usages, we can set the device_type as before. After we're
finished, we can then check if the value is still zero and do whatever
is most appropriate.

Detecting the pen can be a little tricky on most Wacom devices because
the descriptors describe opaque blobs. Fortunately, older Wacom tablets
have the HID_DG_DIGITIZER usage on the pen's application collection and
newer tablets seem to have a similar vendor-defined usage that we can
trigger on.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Reviewed-by: Ping Cheng <pingc@wacom.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 042628abd59c9a034797bd3083f806fa17cda62d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,157aa7aa1067..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -290,248 -165,144 +290,328 @@@ static void wacom_retrieve_report_data(
   * interfaces haven't supported pressure or distance, this is enough
   * information to override invalid values in the wacom_features table.
   *
 - * Intuos5 touch interface and 3rd gen Bamboo Touch do not contain useful
 - * data. We deal with them after returning from this function.
 + * 3rd gen Bamboo Touch no longer define a Digitizer-Finger Pysical
 + * Collection. Instead they define a Logical Collection with a single
 + * Logical Maximum for both X and Y.
 + *
 + * Intuos5 touch interface does not contain useful data. We deal with
 + * this after returning from this function.
   */
++<<<<<<< HEAD
 +static int wacom_parse_hid(struct usb_interface *intf,
 +			   struct hid_descriptor *hid_desc,
++=======
+ static void wacom_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_features *features = &wacom->wacom_wac.features;
+ 	bool finger = WACOM_FINGER_FIELD(field);
+ 	bool pen = WACOM_PEN_FIELD(field);
+ 
+ 	/*
+ 	* Requiring Stylus Usage will ignore boot mouse
+ 	* X/Y values and some cases of invalid Digitizer X/Y
+ 	* values commonly reported.
+ 	*/
+ 	if (pen)
+ 		features->device_type = BTN_TOOL_PEN;
+ 	else if (finger)
+ 		features->device_type = BTN_TOOL_FINGER;
+ 	else
+ 		return;
+ 
+ 	/*
+ 	 * Bamboo models do not support HID_DG_CONTACTMAX.
+ 	 * And, Bamboo Pen only descriptor contains touch.
+ 	 */
+ 	if (features->type != BAMBOO_PT) {
+ 		/* ISDv4 touch devices at least supports one touch point */
+ 		if (finger && !features->touch_max)
+ 			features->touch_max = 1;
+ 	}
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		features->x_max = field->logical_maximum;
+ 		if (finger) {
+ 			features->x_phy = field->physical_maximum;
+ 			if (features->type != BAMBOO_PT) {
+ 				features->unit = field->unit;
+ 				features->unitExpo = field->unit_exponent;
+ 			}
+ 		}
+ 		break;
+ 	case HID_GD_Y:
+ 		features->y_max = field->logical_maximum;
+ 		if (finger) {
+ 			features->y_phy = field->physical_maximum;
+ 			if (features->type != BAMBOO_PT) {
+ 				features->unit = field->unit;
+ 				features->unitExpo = field->unit_exponent;
+ 			}
+ 		}
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		if (pen)
+ 			features->pressure_max = field->logical_maximum;
+ 		break;
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		wacom_wac_usage_mapping(hdev, field, usage);
+ }
+ 
+ static void wacom_post_parse_hid(struct hid_device *hdev,
+ 				 struct wacom_features *features)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	if (features->type == HID_GENERIC) {
+ 		/* Any last-minute generic device setup */
+ 		if (features->touch_max > 1) {
+ 			input_mt_init_slots(wacom_wac->input, wacom_wac->features.touch_max,
+ 				    INPUT_MT_DIRECT);
+ 		}
+ 	}
+ }
+ 
+ static void wacom_parse_hid(struct hid_device *hdev,
++>>>>>>> 042628abd59c (HID: wacom: Discover device_type from HID descriptor for all devices)
  			   struct wacom_features *features)
  {
 -	struct hid_report_enum *rep_enum;
 -	struct hid_report *hreport;
 -	int i, j;
 -
 -	/* check features first */
 -	rep_enum = &hdev->report_enum[HID_FEATURE_REPORT];
 -	list_for_each_entry(hreport, &rep_enum->report_list, list) {
 -		for (i = 0; i < hreport->maxfield; i++) {
 -			/* Ignore if report count is out of bounds. */
 -			if (hreport->field[i]->report_count < 1)
 -				continue;
 -
 -			for (j = 0; j < hreport->field[i]->maxusage; j++) {
 -				wacom_feature_mapping(hdev, hreport->field[i],
 -						hreport->field[i]->usage + j);
 +	struct usb_device *dev = interface_to_usbdev(intf);
 +	char limit = 0;
 +	/* result has to be defined as int for some devices */
 +	int result = 0;
 +	int i = 0, usage = WCM_UNDEFINED, finger = 0, pen = 0;
 +	unsigned char *report;
 +
 +	report = kzalloc(hid_desc->wDescriptorLength, GFP_KERNEL);
 +	if (!report)
 +		return -ENOMEM;
 +
 +	/* retrive report descriptors */
 +	do {
 +		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 +			USB_REQ_GET_DESCRIPTOR,
 +			USB_RECIP_INTERFACE | USB_DIR_IN,
 +			HID_DEVICET_REPORT << 8,
 +			intf->altsetting[0].desc.bInterfaceNumber, /* interface */
 +			report,
 +			hid_desc->wDescriptorLength,
 +			5000); /* 5 secs */
 +	} while (result < 0 && limit++ < WAC_MSG_RETRIES);
 +
 +	/* No need to parse the Descriptor. It isn't an error though */
 +	if (result < 0)
 +		goto out;
 +
 +	for (i = 0; i < hid_desc->wDescriptorLength; i++) {
 +
 +		switch (report[i]) {
 +		case HID_USAGE_PAGE:
 +			switch (report[i + 1]) {
 +			case HID_USAGE_PAGE_DIGITIZER:
 +				usage = WCM_DIGITIZER;
 +				i++;
 +				break;
 +
 +			case HID_USAGE_PAGE_DESKTOP:
 +				usage = WCM_DESKTOP;
 +				i++;
 +				break;
  			}
 -		}
 -	}
 +			break;
  
 -	/* now check the input usages */
 -	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];
 -	list_for_each_entry(hreport, &rep_enum->report_list, list) {
 +		case HID_USAGE:
 +			switch (report[i + 1]) {
 +			case HID_USAGE_X:
 +				if (usage == WCM_DESKTOP) {
 +					if (finger) {
 +						features->device_type = BTN_TOOL_FINGER;
 +
 +						switch (features->type) {
 +						case TABLETPC2FG:
 +							features->pktlen = WACOM_PKGLEN_TPC2FG;
 +							break;
 +
 +						case MTSCREEN:
 +						case WACOM_24HDT:
 +							features->pktlen = WACOM_PKGLEN_MTOUCH;
 +							break;
 +
 +						case MTTPC:
 +							features->pktlen = WACOM_PKGLEN_MTTPC;
 +							break;
 +
 +						case BAMBOO_PT:
 +							features->pktlen = WACOM_PKGLEN_BBTOUCH;
 +							break;
 +
 +						default:
 +							features->pktlen = WACOM_PKGLEN_GRAPHIRE;
 +							break;
 +						}
 +
 +						switch (features->type) {
 +						case BAMBOO_PT:
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 5]);
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 8]);
 +							i += 15;
 +							break;
 +
 +						case WACOM_24HDT:
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 8]);
 +							features->unit = report[i - 1];
 +							features->unitExpo = report[i - 3];
 +							i += 12;
 +							break;
 +
 +						case WACOM_27QHDT:
 +							if (!features->x_max) {
 +								features->x_max =
 +									get_unaligned_le16(&report[i - 4]);
 +								features->x_phy =
 +									get_unaligned_le16(&report[i - 7]);
 +								features->unit = report[i - 13];
 +								features->unitExpo = report[i - 11];
 +							}
 +							i += 9;
 +							break;
 +
 +						default:
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 6]);
 +							features->unit = report[i + 9];
 +							features->unitExpo = report[i + 11];
 +							i += 12;
 +							break;
 +						}
 +					} else if (pen) {
 +						/* penabled only accepts exact bytes of data */
 +						if (features->type >= TABLETPC)
 +							features->pktlen = WACOM_PKGLEN_GRAPHIRE;
 +						features->device_type = BTN_TOOL_PEN;
 +						features->x_max =
 +							get_unaligned_le16(&report[i + 3]);
 +						i += 4;
 +					}
 +				}
 +				break;
  
 -		if (!hreport->maxfield)
 -			continue;
 +			case HID_USAGE_Y:
 +				if (usage == WCM_DESKTOP) {
 +					if (finger) {
 +						switch (features->type) {
 +						case TABLETPC2FG:
 +						case MTSCREEN:
 +						case MTTPC:
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 6]);
 +							i += 7;
 +							break;
 +
 +						case WACOM_24HDT:
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_phy =
 +								get_unaligned_le16(&report[i - 2]);
 +							i += 7;
 +							break;
 +
 +						case BAMBOO_PT:
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 6]);
 +							i += 12;
 +							break;
 +
 +						case WACOM_27QHDT:
 +							if (!features->y_max) {
 +								features->y_max =
 +									get_unaligned_le16(&report[i - 2]);
 +								features->y_phy =
 +									get_unaligned_le16(&report[i - 5]);
 +							}
 +							i += 2;
 +							break;
 +
 +						default:
 +							features->y_max =
 +								features->x_max;
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 3]);
 +							i += 4;
 +							break;
 +						}
 +					} else if (pen) {
 +						features->y_max =
 +							get_unaligned_le16(&report[i + 3]);
 +						i += 4;
 +					}
 +				}
 +				break;
  
 -		for (i = 0; i < hreport->maxfield; i++)
 -			for (j = 0; j < hreport->field[i]->maxusage; j++)
 -				wacom_usage_mapping(hdev, hreport->field[i],
 -						hreport->field[i]->usage + j);
 -	}
 +			case HID_USAGE_FINGER:
 +				finger = 1;
 +				i++;
 +				break;
  
 -	wacom_post_parse_hid(hdev, features);
 -}
 +			/*
 +			 * Requiring Stylus Usage will ignore boot mouse
 +			 * X/Y values and some cases of invalid Digitizer X/Y
 +			 * values commonly reported.
 +			 */
 +			case HID_USAGE_STYLUS:
 +				pen = 1;
 +				i++;
 +				break;
  
 -static int wacom_hid_set_device_mode(struct hid_device *hdev)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct hid_data *hid_data = &wacom->wacom_wac.hid_data;
 -	struct hid_report *r;
 -	struct hid_report_enum *re;
 +			case HID_USAGE_CONTACTMAX:
 +				/* leave touch_max as is if predefined */
 +				if (!features->touch_max)
 +					wacom_retrieve_report_data(intf, features);
 +				i++;
 +				break;
 +			}
 +			break;
  
 -	if (hid_data->inputmode < 0)
 -		return 0;
 +		case HID_COLLECTION_END:
 +			/* reset UsagePage and Finger */
 +			finger = usage = 0;
 +			break;
  
 -	re = &(hdev->report_enum[HID_FEATURE_REPORT]);
 -	r = re->report_id_hash[hid_data->inputmode];
 -	if (r) {
 -		r->field[0]->value[hid_data->inputmode_index] = 2;
 -		hid_hw_request(hdev, r, HID_REQ_SET_REPORT);
 +		case HID_COLLECTION:
 +			i++;
 +			switch (report[i]) {
 +			case HID_COLLECTION_LOGICAL:
 +				i += wacom_parse_logical_collection(&report[i],
 +								    features);
 +				break;
 +			}
 +			break;
 +		}
  	}
 -	return 0;
 +
 + out:
 +	result = 0;
 +	kfree(report);
 +	return result;
  }
  
 -static int wacom_set_device_mode(struct hid_device *hdev, int report_id,
 -		int length, int mode)
 +static int wacom_set_device_mode(struct usb_interface *intf, int report_id, int length, int mode)
  {
  	unsigned char *rep_data;
  	int error = -ENOMEM, limit = 0;
@@@ -585,15 -419,13 +665,14 @@@ static int wacom_query_tablet_data(stru
  	return 0;
  }
  
 -static void wacom_retrieve_hid_descriptor(struct hid_device *hdev,
 +static int wacom_retrieve_hid_descriptor(struct usb_interface *intf,
  					 struct wacom_features *features)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct usb_interface *intf = wacom->intf;
 +	int error = 0;
 +	struct usb_host_interface *interface = intf->cur_altsetting;
 +	struct hid_descriptor *hid_desc;
  
  	/* default features */
- 	features->device_type = BTN_TOOL_PEN;
  	features->x_fuzz = 4;
  	features->y_fuzz = 4;
  	features->pressure_fuzz = 0;
@@@ -614,31 -446,13 +693,35 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	/* only devices that support touch need to retrieve the info */
 +	if (features->type < BAMBOO_PT) {
 +		goto out;
 +	}
 +
 +	error = usb_get_extra_descriptor(interface, HID_DEVICET_HID, &hid_desc);
 +	if (error) {
 +		error = usb_get_extra_descriptor(&interface->endpoint[0],
 +						 HID_DEVICET_REPORT, &hid_desc);
 +		if (error) {
 +			dev_err(&intf->dev,
 +				"can not retrieve extra class descriptor\n");
 +			goto out;
 +		}
 +	}
 +	error = wacom_parse_hid(intf, hid_desc, features);
 +
 + out:
 +	return error;
++=======
+ 	wacom_parse_hid(hdev, features);
++>>>>>>> 042628abd59c (HID: wacom: Discover device_type from HID descriptor for all devices)
  }
  
 -struct wacom_hdev_data {
 +struct wacom_usbdev_data {
  	struct list_head list;
  	struct kref kref;
 -	struct hid_device *dev;
 +	struct usb_device *dev;
  	struct wacom_shared shared;
  };
  
@@@ -1334,81 -1498,79 +1417,94 @@@ static int wacom_probe(struct usb_inter
  	wacom->intf = intf;
  	mutex_init(&wacom->lock);
  	INIT_WORK(&wacom->work, wacom_wireless_work);
 +	usb_make_path(dev, wacom->phys, sizeof(wacom->phys));
 +	strlcat(wacom->phys, "/input0", sizeof(wacom->phys));
  
 -	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 -		error = wacom_allocate_inputs(wacom);
 -		if (error)
 -			goto fail_allocate_inputs;
 -	}
 +	endpoint = &intf->cur_altsetting->endpoint[0].desc;
 +
 +	/* set the default size in case we do not get them from hid */
 +	wacom_set_default_phy(features);
 +
 +	/* Retrieve the physical and logical size for touch devices */
++<<<<<<< HEAD
 +	error = wacom_retrieve_hid_descriptor(intf, features);
 +	if (error)
 +		goto fail3;
  
  	/*
 -	 * Bamboo Pad has a generic hid handling for the Pen, and we switch it
 -	 * into debug mode for the touch part.
 -	 * We ignore the other interfaces.
 +	 * Intuos5 has no useful data about its touch interface in its
 +	 * HID descriptor. If this is the touch interface (wMaxPacketSize
 +	 * of WACOM_PKGLEN_BBTOUCH3), override the table values.
  	 */
 -	if (features->type == BAMBOO_PAD) {
 -		if (features->pktlen == WACOM_PKGLEN_PENABLED) {
 -			features->type = HID_GENERIC;
 -		} else if ((features->pktlen != WACOM_PKGLEN_BPAD_TOUCH) &&
 -			   (features->pktlen != WACOM_PKGLEN_BPAD_TOUCH_USB)) {
 -			error = -ENODEV;
 -			goto fail_shared_data;
 +	if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
 +		if (endpoint->wMaxPacketSize == WACOM_PKGLEN_BBTOUCH3) {
 +			features->device_type = BTN_TOOL_FINGER;
 +			features->pktlen = WACOM_PKGLEN_BBTOUCH3;
 +
 +			features->x_max = 4096;
 +			features->y_max = 4096;
 +		} else {
 +			features->device_type = BTN_TOOL_PEN;
  		}
  	}
  
 -	/* set the default size in case we do not get them from hid */
 -	wacom_set_default_phy(features);
 +	wacom_setup_device_quirks(features);
  
 -	/* Retrieve the physical and logical size for touch devices */
 +	/* set unit to "100th of a mm" for devices not reported by HID */
 +	if (!features->unit) {
 +		features->unit = 0x11;
 +		features->unitExpo = 16 - 3;
 +	}
++=======
+ 	wacom_retrieve_hid_descriptor(hdev, features);
+ 	wacom_setup_device_quirks(wacom);
+ 
+ 	if (!features->device_type && features->type != WIRELESS) {
+ 		dev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",
+ 			 hdev->name, "Assuming pen");
+ 
+ 		features->device_type = BTN_TOOL_PEN;
+ 	}
+ 
++>>>>>>> 042628abd59c (HID: wacom: Discover device_type from HID descriptor for all devices)
  	wacom_calculate_res(features);
  
 -	wacom_update_name(wacom);
 +	strlcpy(wacom_wac->name, features->name, sizeof(wacom_wac->name));
  
 -	error = wacom_add_shared_data(hdev);
 -	if (error)
 -		goto fail_shared_data;
 +	if (features->quirks & WACOM_QUIRK_MULTI_INPUT) {
 +		struct usb_device *other_dev;
  
 -	if (!(features->quirks & WACOM_QUIRK_MONITOR) &&
 -	     (features->quirks & WACOM_QUIRK_BATTERY)) {
 -		error = wacom_initialize_battery(wacom);
 -		if (error)
 -			goto fail_battery;
 -	}
 +		/* Append the device type to the name */
 +		if (features->device_type != BTN_TOOL_FINGER)
 +			strlcat(wacom_wac->name, " Pen", WACOM_NAME_MAX);
 +		else if (features->touch_max)
 +			strlcat(wacom_wac->name, " Finger", WACOM_NAME_MAX);
 +		else
 +			strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
  
 -	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 -		error = wacom_register_inputs(wacom);
 +		other_dev = wacom_get_sibling(dev, features->oVid, features->oPid);
 +		if (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)
 +			other_dev = dev;
 +		error = wacom_add_shared_data(wacom_wac, other_dev);
  		if (error)
 -			goto fail_register_inputs;
 +			goto fail3;
  	}
  
 -	if (hdev->bus == BUS_BLUETOOTH) {
 -		error = device_create_file(&hdev->dev, &dev_attr_speed);
 -		if (error)
 -			hid_warn(hdev,
 -				 "can't create sysfs speed attribute err: %d\n",
 -				 error);
 -	}
 +	usb_fill_int_urb(wacom->irq, dev,
 +			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
 +			 wacom_wac->data, features->pktlen,
 +			 wacom_sys_irq, wacom, endpoint->bInterval);
 +	wacom->irq->transfer_dma = wacom->data_dma;
 +	wacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
  
 -	if (features->type == HID_GENERIC)
 -		connect_mask |= HID_CONNECT_DRIVER;
 +	error = wacom_initialize_leds(wacom);
 +	if (error)
 +		goto fail4;
  
 -	/* Regular HID work starts now */
 -	error = hid_hw_start(hdev, connect_mask);
 -	if (error) {
 -		hid_err(hdev, "hw start failed\n");
 -		goto fail_hw_start;
 +	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 +		error = wacom_register_input(wacom);
 +		if (error)
 +			goto fail5;
  	}
  
  	/* Note that if query fails it is not a hard failure */
diff --cc drivers/hid/wacom_wac.c
index bc916ccd4c20,a52fc2580b6b..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1483,11 -2173,34 +1483,42 @@@ void wacom_setup_device_quirks(struct w
  		features->y_max = 1023;
  	}
  
++<<<<<<< HEAD
 +	/* these device have multiple inputs */
 +	if (features->type >= WIRELESS ||
 +	    (features->type >= INTUOS5S && features->type <= INTUOSPL) ||
 +	    (features->oVid && features->oPid))
 +		features->quirks |= WACOM_QUIRK_MULTI_INPUT;
++=======
+ 	/*
+ 	 * Intuos5/Pro and Bamboo 3rd gen have no useful data about its
+ 	 * touch interface in its HID descriptor. If this is the touch
+ 	 * interface (PacketSize of WACOM_PKGLEN_BBTOUCH3), override the
+ 	 * tablet values.
+ 	 */
+ 	if ((features->type >= INTUOS5S && features->type <= INTUOSHT) ||
+ 		(features->type == BAMBOO_PT)) {
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			features->device_type = BTN_TOOL_FINGER;
+ 
+ 			features->x_max = 4096;
+ 			features->y_max = 4096;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Raw Wacom-mode pen and touch events both come from interface
+ 	 * 0, whose HID descriptor has an application usage of 0xFF0D
+ 	 * (i.e., WACOM_VENDORDEFINED_PEN). We route pen packets back
+ 	 * out through the HID_GENERIC device created for interface 1,
+ 	 * so rewrite this one to be of type BTN_TOOL_FINGER.
+ 	 */
+ 	if (features->type == BAMBOO_PAD)
+ 		features->device_type = BTN_TOOL_FINGER;
+ 
+ 	if (wacom->hdev->bus == BUS_BLUETOOTH)
+ 		features->quirks |= WACOM_QUIRK_BATTERY;
++>>>>>>> 042628abd59c (HID: wacom: Discover device_type from HID descriptor for all devices)
  
  	/* quirk for bamboo touch with 2 low res touches */
  	if (features->type == BAMBOO_PT &&
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,9a5ee623cb44..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -53,16 -52,37 +53,35 @@@
  #define WACOM_REPORT_TPC1FG		6
  #define WACOM_REPORT_TPC2FG		13
  #define WACOM_REPORT_TPCMT		13
 -#define WACOM_REPORT_TPCMT2		3
  #define WACOM_REPORT_TPCHID		15
 -#define WACOM_REPORT_CINTIQ		16
 -#define WACOM_REPORT_CINTIQPAD		17
  #define WACOM_REPORT_TPCST		16
 -#define WACOM_REPORT_DTUS		17
  #define WACOM_REPORT_TPC1FGE		18
  #define WACOM_REPORT_24HDT		1
 -#define WACOM_REPORT_WL			128
 -#define WACOM_REPORT_USB		192
 -#define WACOM_REPORT_BPAD_PEN		3
 -#define WACOM_REPORT_BPAD_TOUCH		16
  
  /* device quirks */
++<<<<<<< HEAD
 +#define WACOM_QUIRK_MULTI_INPUT		0x0001
 +#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0002
 +#define WACOM_QUIRK_NO_INPUT		0x0004
 +#define WACOM_QUIRK_MONITOR		0x0008
++=======
+ #define WACOM_QUIRK_BBTOUCH_LOWRES	0x0001
+ #define WACOM_QUIRK_NO_INPUT		0x0002
+ #define WACOM_QUIRK_MONITOR		0x0004
+ #define WACOM_QUIRK_BATTERY		0x0008
+ 
+ #define WACOM_VENDORDEFINED_PEN		0xff0d0001
+ 
+ #define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_PEN) || \
+ 				 ((f)->application == HID_DG_PEN) || \
+ 				 ((f)->application == HID_DG_DIGITIZER) || \
+ 				 ((f)->application == WACOM_VENDORDEFINED_PEN))
+ #define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
+ 				 ((f)->physical == HID_DG_FINGER) || \
+ 				 ((f)->application == HID_DG_TOUCHSCREEN))
++>>>>>>> 042628abd59c (HID: wacom: Discover device_type from HID descriptor for all devices)
  
  enum {
  	PENPARTNER = 0,
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
