x86/amd_nb: Make all exports EXPORT_SYMBOL_GPL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] amd_nb: Make all exports EXPORT_SYMBOL_GPL (Suravee Suthikulpanit) [1303712]
Rebuild_FUZZ: 95.45%
commit-author Yazen Ghannam <Yazen.Ghannam@amd.com>
commit de6bd0835ac148a0882528fe1fe5bcee709fe911
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/de6bd083.failed

Make all EXPORT_SYMBOL's into EXPORT_SYMBOL_GPL. While we're at it let's
fix some checkpatch warnings.

	Signed-off-by: Yazen Ghannam <Yazen.Ghannam@amd.com>
	Cc: linux-edac <linux-edac@vger.kernel.org>
	Cc: x86-ml <x86@kernel.org>
Link: http://lkml.kernel.org/r/1478812257-5424-3-git-send-email-Yazen.Ghannam@amd.com
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit de6bd0835ac148a0882528fe1fe5bcee709fe911)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/amd_nb.c
diff --cc arch/x86/kernel/amd_nb.c
index 15d1102b9e99,3c1cb4595595..000000000000
--- a/arch/x86/kernel/amd_nb.c
+++ b/arch/x86/kernel/amd_nb.c
@@@ -23,9 -23,10 +23,9 @@@ const struct pci_device_id amd_nb_misc_
  	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M30H_NB_F3) },
  	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F3) },
  	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },
 -	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },
  	{}
  };
- EXPORT_SYMBOL(amd_nb_misc_ids);
+ EXPORT_SYMBOL_GPL(amd_nb_misc_ids);
  
  static const struct pci_device_id amd_nb_link_ids[] = {
  	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_NB_F4) },
@@@ -42,8 -44,25 +42,30 @@@ const struct amd_nb_bus_dev_range amd_n
  	{ }
  };
  
++<<<<<<< HEAD
 +struct amd_northbridge_info amd_northbridges;
 +EXPORT_SYMBOL(amd_northbridges);
++=======
+ static struct amd_northbridge_info amd_northbridges;
+ 
+ u16 amd_nb_num(void)
+ {
+ 	return amd_northbridges.num;
+ }
+ EXPORT_SYMBOL_GPL(amd_nb_num);
+ 
+ bool amd_nb_has_feature(unsigned int feature)
+ {
+ 	return ((amd_northbridges.flags & feature) == feature);
+ }
+ EXPORT_SYMBOL_GPL(amd_nb_has_feature);
+ 
+ struct amd_northbridge *node_to_amd_nb(int node)
+ {
+ 	return (node < amd_northbridges.num) ? &amd_northbridges.nb[node] : NULL;
+ }
+ EXPORT_SYMBOL_GPL(node_to_amd_nb);
++>>>>>>> de6bd0835ac1 (x86/amd_nb: Make all exports EXPORT_SYMBOL_GPL)
  
  static struct pci_dev *next_northbridge(struct pci_dev *dev,
  					const struct pci_device_id *ids)
@@@ -69,10 -88,10 +91,10 @@@ int amd_cache_northbridges(void
  	while ((misc = next_northbridge(misc, amd_nb_misc_ids)) != NULL)
  		i++;
  
 -	if (!i)
 -		return -ENODEV;
 +	if (i == 0)
 +		return 0;
  
- 	nb = kzalloc(i * sizeof(struct amd_northbridge), GFP_KERNEL);
+ 	nb = kcalloc(i, sizeof(struct amd_northbridge), GFP_KERNEL);
  	if (!nb)
  		return -ENOMEM;
  
@@@ -248,13 -263,15 +270,15 @@@ void amd_flush_garts(void
  	if (!amd_nb_has_feature(AMD_NB_GART))
  		return;
  
- 	/* Avoid races between AGP and IOMMU. In theory it's not needed
- 	   but I'm not sure if the hardware won't lose flush requests
- 	   when another is pending. This whole thing is so expensive anyways
- 	   that it doesn't matter to serialize more. -AK */
+ 	/*
+ 	 * Avoid races between AGP and IOMMU. In theory it's not needed
+ 	 * but I'm not sure if the hardware won't lose flush requests
+ 	 * when another is pending. This whole thing is so expensive anyways
+ 	 * that it doesn't matter to serialize more. -AK
+ 	 */
  	spin_lock_irqsave(&gart_lock, flags);
  	flushed = 0;
 -	for (i = 0; i < amd_northbridges.num; i++) {
 +	for (i = 0; i < amd_nb_num(); i++) {
  		pci_write_config_dword(node_to_amd_nb(i)->misc, 0x9c,
  				       flush_words[i] | 1);
  		flushed++;
* Unmerged path arch/x86/kernel/amd_nb.c
