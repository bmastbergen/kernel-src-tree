net/mlx5: LAG demux flow table support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] mlx5: LAG demux flow table support (Don Dutile) [1385219 1385330 1417285]
Rebuild_FUZZ: 94.44%
commit-author Aviv Heller <avivh@mellanox.com>
commit aaff1bea16bb7f259a263c3ae4633d092e2da799
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/aaff1bea.failed

Add interfaces to allow the creation and destruction of a
LAG demux flow table.

It is a special flow table used during LAG for redirecting
non user-mode packets from PF0 to PF1 root ft, if a packet was
received on phys port two.

	Signed-off-by: Aviv Heller <avivh@mellanox.com>
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit aaff1bea16bb7f259a263c3ae4633d092e2da799)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
#	include/linux/mlx5/fs.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index 9255fb6f5d9d,7a0415e6d339..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@@ -57,6 -57,8 +57,11 @@@ int mlx5_cmd_update_root_ft(struct mlx5
  }
  
  int mlx5_cmd_create_flow_table(struct mlx5_core_dev *dev,
++<<<<<<< HEAD
++=======
+ 			       u16 vport,
+ 			       enum fs_flow_table_op_mod op_mod,
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  			       enum fs_flow_table_type type, unsigned int level,
  			       unsigned int log_size, struct mlx5_flow_table
  			       *next_ft, unsigned int *table_id)
@@@ -73,15 -73,28 +78,31 @@@
  	MLX5_SET(create_flow_table_in, in, table_type, type);
  	MLX5_SET(create_flow_table_in, in, level, level);
  	MLX5_SET(create_flow_table_in, in, log_size, log_size);
 -	if (vport) {
 -		MLX5_SET(create_flow_table_in, in, vport_number, vport);
 -		MLX5_SET(create_flow_table_in, in, other_vport, 1);
 -	}
  
++<<<<<<< HEAD
 +	memset(out, 0, sizeof(out));
 +	err = mlx5_cmd_exec_check_status(dev, in, sizeof(in), out,
 +					 sizeof(out));
 +
++=======
+ 	switch (op_mod) {
+ 	case FS_FT_OP_MOD_NORMAL:
+ 		if (next_ft) {
+ 			MLX5_SET(create_flow_table_in, in, table_miss_mode, 1);
+ 			MLX5_SET(create_flow_table_in, in, table_miss_id, next_ft->id);
+ 		}
+ 		break;
+ 
+ 	case FS_FT_OP_MOD_LAG_DEMUX:
+ 		MLX5_SET(create_flow_table_in, in, op_mod, 0x1);
+ 		if (next_ft)
+ 			MLX5_SET(create_flow_table_in, in, lag_master_next_table_id,
+ 				 next_ft->id);
+ 		break;
+ 	}
+ 
+ 	err = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  	if (!err)
  		*table_id = MLX5_GET(create_flow_table_out, out,
  				     table_id);
@@@ -120,17 -130,35 +141,44 @@@ int mlx5_cmd_modify_flow_table(struct m
  		 MLX5_CMD_OP_MODIFY_FLOW_TABLE);
  	MLX5_SET(modify_flow_table_in, in, table_type, ft->type);
  	MLX5_SET(modify_flow_table_in, in, table_id, ft->id);
++<<<<<<< HEAD
 +	MLX5_SET(modify_flow_table_in, in, modify_field_select,
 +		 MLX5_MODIFY_FLOW_TABLE_MISS_TABLE_ID);
 +	if (next_ft) {
 +		MLX5_SET(modify_flow_table_in, in, table_miss_mode, 1);
 +		MLX5_SET(modify_flow_table_in, in, table_miss_id, next_ft->id);
++=======
+ 
+ 	if (ft->op_mod == FS_FT_OP_MOD_LAG_DEMUX) {
+ 		MLX5_SET(modify_flow_table_in, in, modify_field_select,
+ 			 MLX5_MODIFY_FLOW_TABLE_LAG_NEXT_TABLE_ID);
+ 		if (next_ft) {
+ 			MLX5_SET(modify_flow_table_in, in,
+ 				 lag_master_next_table_id, next_ft->id);
+ 		} else {
+ 			MLX5_SET(modify_flow_table_in, in,
+ 				 lag_master_next_table_id, 0);
+ 		}
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  	} else {
- 		MLX5_SET(modify_flow_table_in, in, table_miss_mode, 0);
+ 		if (ft->vport) {
+ 			MLX5_SET(modify_flow_table_in, in, vport_number,
+ 				 ft->vport);
+ 			MLX5_SET(modify_flow_table_in, in, other_vport, 1);
+ 		}
+ 		MLX5_SET(modify_flow_table_in, in, modify_field_select,
+ 			 MLX5_MODIFY_FLOW_TABLE_MISS_TABLE_ID);
+ 		if (next_ft) {
+ 			MLX5_SET(modify_flow_table_in, in, table_miss_mode, 1);
+ 			MLX5_SET(modify_flow_table_in, in, table_miss_id,
+ 				 next_ft->id);
+ 		} else {
+ 			MLX5_SET(modify_flow_table_in, in, table_miss_mode, 0);
+ 		}
  	}
  
 -	return mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
 +	return mlx5_cmd_exec_check_status(dev, in, sizeof(in), out,
 +					  sizeof(out));
  }
  
  int mlx5_cmd_create_flow_group(struct mlx5_core_dev *dev,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
index ef9e0168938b,c5bc4686c832..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
@@@ -34,6 -34,8 +34,11 @@@
  #define _MLX5_FS_CMD_
  
  int mlx5_cmd_create_flow_table(struct mlx5_core_dev *dev,
++<<<<<<< HEAD
++=======
+ 			       u16 vport,
+ 			       enum fs_flow_table_op_mod op_mod,
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  			       enum fs_flow_table_type type, unsigned int level,
  			       unsigned int log_size, struct mlx5_flow_table
  			       *next_ft, unsigned int *table_id);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 3b6147aebe10,eabd73482c86..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -477,8 -476,9 +477,14 @@@ static struct mlx5_flow_group *alloc_fl
  	return fg;
  }
  
++<<<<<<< HEAD
 +static struct mlx5_flow_table *alloc_flow_table(int level, int max_fte,
 +						enum fs_flow_table_type table_type)
++=======
+ static struct mlx5_flow_table *alloc_flow_table(int level, u16 vport, int max_fte,
+ 						enum fs_flow_table_type table_type,
+ 						enum fs_flow_table_op_mod op_mod)
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  {
  	struct mlx5_flow_table *ft;
  
@@@ -488,7 -488,9 +494,8 @@@
  
  	ft->level = level;
  	ft->node.type = FS_TYPE_FLOW_TABLE;
+ 	ft->op_mod = op_mod;
  	ft->type = table_type;
 -	ft->vport = vport;
  	ft->max_fte = max_fte;
  	INIT_LIST_HEAD(&ft->fwd_rules);
  	mutex_init(&ft->lock);
@@@ -706,9 -711,24 +713,30 @@@ static int connect_flow_table(struct ml
  	return err;
  }
  
++<<<<<<< HEAD
 +struct mlx5_flow_table *mlx5_create_flow_table(struct mlx5_flow_namespace *ns,
 +					       int prio,
 +					       int max_fte)
++=======
+ static void list_add_flow_table(struct mlx5_flow_table *ft,
+ 				struct fs_prio *prio)
+ {
+ 	struct list_head *prev = &prio->node.children;
+ 	struct mlx5_flow_table *iter;
+ 
+ 	fs_for_each_ft(iter, prio) {
+ 		if (iter->level > ft->level)
+ 			break;
+ 		prev = &iter->node.list;
+ 	}
+ 	list_add(&ft->node.list, prev);
+ }
+ 
+ static struct mlx5_flow_table *__mlx5_create_flow_table(struct mlx5_flow_namespace *ns,
+ 							enum fs_flow_table_op_mod op_mod,
+ 							u16 vport, int prio,
+ 							int max_fte, u32 level)
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  {
  	struct mlx5_flow_table *next_ft = NULL;
  	struct mlx5_flow_table *ft;
@@@ -733,20 -753,25 +761,37 @@@
  		err = -ENOSPC;
  		goto unlock_root;
  	}
++<<<<<<< HEAD
 +
 +	ft = alloc_flow_table(find_next_free_level(fs_prio),
 +			      roundup_pow_of_two(max_fte),
 +			      root->table_type);
++=======
+ 	/* The level is related to the
+ 	 * priority level range.
+ 	 */
+ 	level += fs_prio->start_level;
+ 	ft = alloc_flow_table(level,
+ 			      vport,
+ 			      max_fte ? roundup_pow_of_two(max_fte) : 0,
+ 			      root->table_type,
+ 			      op_mod);
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  	if (!ft) {
  		err = -ENOMEM;
  		goto unlock_root;
  	}
  
  	tree_init_node(&ft->node, 1, del_flow_table);
- 	log_table_sz = ilog2(ft->max_fte);
+ 	log_table_sz = ft->max_fte ? ilog2(ft->max_fte) : 0;
  	next_ft = find_next_chained_ft(fs_prio);
++<<<<<<< HEAD
 +	err = mlx5_cmd_create_flow_table(root->dev, ft->type, ft->level,
 +					 log_table_sz, next_ft, &ft->id);
++=======
+ 	err = mlx5_cmd_create_flow_table(root->dev, ft->vport, ft->op_mod, ft->type,
+ 					 ft->level, log_table_sz, next_ft, &ft->id);
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  	if (err)
  		goto free_ft;
  
@@@ -769,6 -794,31 +814,34 @@@ unlock_root
  	return ERR_PTR(err);
  }
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_table *mlx5_create_flow_table(struct mlx5_flow_namespace *ns,
+ 					       int prio, int max_fte,
+ 					       u32 level)
+ {
+ 	return __mlx5_create_flow_table(ns, FS_FT_OP_MOD_NORMAL, 0, prio,
+ 					max_fte, level);
+ }
+ 
+ struct mlx5_flow_table *mlx5_create_vport_flow_table(struct mlx5_flow_namespace *ns,
+ 						     int prio, int max_fte,
+ 						     u32 level, u16 vport)
+ {
+ 	return __mlx5_create_flow_table(ns, FS_FT_OP_MOD_NORMAL, vport, prio,
+ 					max_fte, level);
+ }
+ 
+ struct mlx5_flow_table *mlx5_create_lag_demux_flow_table(
+ 					       struct mlx5_flow_namespace *ns,
+ 					       int prio, u32 level)
+ {
+ 	return __mlx5_create_flow_table(ns, FS_FT_OP_MOD_LAG_DEMUX, 0, prio, 0,
+ 					level);
+ }
+ EXPORT_SYMBOL(mlx5_create_lag_demux_flow_table);
+ 
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  struct mlx5_flow_table *mlx5_create_auto_grouped_flow_table(struct mlx5_flow_namespace *ns,
  							    int prio,
  							    int num_flow_table_entries,
diff --cc include/linux/mlx5/fs.h
index 3f3444d24756,7edfe0b8f1ec..000000000000
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@@ -88,7 -99,16 +88,20 @@@ mlx5_create_auto_grouped_flow_table(str
  struct mlx5_flow_table *
  mlx5_create_flow_table(struct mlx5_flow_namespace *ns,
  		       int prio,
++<<<<<<< HEAD
 +		       int num_flow_table_entries);
++=======
+ 		       int num_flow_table_entries,
+ 		       u32 level);
+ struct mlx5_flow_table *
+ mlx5_create_vport_flow_table(struct mlx5_flow_namespace *ns,
+ 			     int prio,
+ 			     int num_flow_table_entries,
+ 			     u32 level, u16 vport);
+ struct mlx5_flow_table *mlx5_create_lag_demux_flow_table(
+ 					       struct mlx5_flow_namespace *ns,
+ 					       int prio, u32 level);
++>>>>>>> aaff1bea16bb (net/mlx5: LAG demux flow table support)
  int mlx5_destroy_flow_table(struct mlx5_flow_table *ft);
  
  /* inbox should be set with the following values:
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index d607e564f454..f19c52d5bdf9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@ -49,6 +49,11 @@ enum fs_flow_table_type {
 	FS_FT_FDB	 = 0X4,
 };
 
+enum fs_flow_table_op_mod {
+	FS_FT_OP_MOD_NORMAL,
+	FS_FT_OP_MOD_LAG_DEMUX,
+};
+
 enum fs_fte_status {
 	FS_FTE_STATUS_EXISTING = 1UL << 0,
 };
@@ -82,6 +87,7 @@ struct mlx5_flow_table {
 	unsigned int			max_fte;
 	unsigned int			level;
 	enum fs_flow_table_type		type;
+	enum fs_flow_table_op_mod	op_mod;
 	struct {
 		bool			active;
 		unsigned int		required_groups;
* Unmerged path include/linux/mlx5/fs.h
