scsi: be2iscsi: Reinit SGL handle, CID tables after TPE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] be2iscsi: Reinit SGL handle, CID tables after TPE (Maurizio Lombardi) [1382263]
Rebuild_FUZZ: 94.23%
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit dd940972f36779577701f20965847e9b56b79a0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dd940972.failed

After TPE recovery, CID table needs to be repopulated as per CIDs in
WRBQ creation responses.

SGL handles table needs to be recreated for posting and its indices need
to be resetted.

This is achieved by calling beiscsi_cleanup_port when disabling and
beiscsi_init_port in enabling port.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit dd940972f36779577701f20965847e9b56b79a0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_main.c
diff --cc drivers/scsi/be2iscsi/be_main.c
index 0609f23cb310,d96f706893a6..000000000000
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@@ -4008,31 -3919,6 +4008,34 @@@ static void beiscsi_free_mem(struct bei
  	kfree(phba->phwi_ctrlr);
  }
  
++<<<<<<< HEAD
 +static int beiscsi_init_controller(struct beiscsi_hba *phba)
 +{
 +	int ret = -ENOMEM;
 +
 +	ret = beiscsi_get_memory(phba);
 +	if (ret < 0) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : beiscsi_dev_probe -"
 +			    "Failed in beiscsi_alloc_memory\n");
 +		return ret;
 +	}
 +
 +	ret = hwi_init_controller(phba);
 +	if (ret)
 +		goto free_init;
 +	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
 +		    "BM_%d : Return success from beiscsi_init_controller");
 +
 +	return 0;
 +
 +free_init:
 +	beiscsi_free_mem(phba);
 +	return ret;
 +}
 +
++=======
++>>>>>>> dd940972f367 (scsi: be2iscsi: Reinit SGL handle, CID tables after TPE)
  static int beiscsi_init_sgl_handle(struct beiscsi_hba *phba)
  {
  	struct be_mem_descriptor *mem_descr_sglh, *mem_descr_sg;
@@@ -4460,23 -4201,22 +4462,26 @@@ static int beiscsi_init_port(struct bei
  	ret = beiscsi_init_sgl_handle(phba);
  	if (ret < 0) {
  		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
- 			    "BM_%d : beiscsi_dev_probe - Failed in"
- 			    "beiscsi_init_sgl_handle\n");
- 		goto do_cleanup_ctrlr;
+ 			    "BM_%d : init sgl handles failed\n");
+ 		goto cleanup_port;
  	}
  
 -	ret = hba_setup_cid_tbls(phba);
 -	if (ret < 0) {
 +	if (hba_setup_cid_tbls(phba)) {
  		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
- 			    "BM_%d : Failed in hba_setup_cid_tbls\n");
+ 			    "BM_%d : setup CID table failed\n");
  		kfree(phba->io_sgl_hndl_base);
  		kfree(phba->eh_sgl_hndl_base);
- 		goto do_cleanup_ctrlr;
+ 		goto cleanup_port;
  	}
- 
  	return ret;
  
++<<<<<<< HEAD
 +do_cleanup_ctrlr:
 +	hwi_cleanup(phba);
++=======
+ cleanup_port:
+ 	hwi_cleanup_port(phba);
++>>>>>>> dd940972f367 (scsi: be2iscsi: Reinit SGL handle, CID tables after TPE)
  	return ret;
  }
  
@@@ -5395,37 -5334,180 +5400,163 @@@ static void be_check_boot_session(struc
  }
  
  /*
 - * beiscsi_enable_port()- Enables the disabled port.
 - * Only port resources freed in disable function are reallocated.
 - * This is called in HBA error handling path.
 - *
 - * @phba: Instance of driver private structure
 + * beiscsi_hw_health_check()- Check adapter health
 + * @work: work item to check HW health
   *
 + * Check if adapter in an unrecoverable state or not.
   **/
 -static int beiscsi_enable_port(struct beiscsi_hba *phba)
 +static void
 +beiscsi_hw_health_check(struct work_struct *work)
  {
 -	struct hwi_context_memory *phwi_context;
 -	struct hwi_controller *phwi_ctrlr;
 -	struct be_eq_obj *pbe_eq;
 -	int ret, i;
 +	struct beiscsi_hba *phba =
 +		container_of(work, struct beiscsi_hba,
 +			     beiscsi_hw_check_task.work);
  
 -	if (test_bit(BEISCSI_HBA_ONLINE, &phba->state)) {
 -		__beiscsi_log(phba, KERN_ERR,
 -			      "BM_%d : %s : port is online %lx\n",
 -			      __func__, phba->state);
 -		return 0;
 -	}
 +	be_eqd_update(phba);
  
++<<<<<<< HEAD
 +	if (phba->state & BE_ADAPTER_CHECK_BOOT) {
 +		if ((phba->get_boot > 0) && (!phba->boot_kset)) {
 +			phba->get_boot--;
 +			if (!(phba->get_boot % BE_GET_BOOT_TO))
 +				be_check_boot_session(phba);
 +		} else {
 +			phba->state &= ~BE_ADAPTER_CHECK_BOOT;
 +			phba->get_boot = 0;
++=======
+ 	ret = beiscsi_init_sliport(phba);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (enable_msix)
+ 		find_num_cpus(phba);
+ 	else
+ 		phba->num_cpus = 1;
+ 	if (enable_msix) {
+ 		beiscsi_msix_enable(phba);
+ 		if (!phba->msix_enabled)
+ 			phba->num_cpus = 1;
+ 	}
+ 
+ 	beiscsi_get_params(phba);
+ 	/* Re-enable UER. If different TPE occurs then it is recoverable. */
+ 	beiscsi_set_uer_feature(phba);
+ 
+ 	phba->shost->max_id = phba->params.cxns_per_ctrl;
+ 	phba->shost->can_queue = phba->params.ios_per_ctrl;
+ 	ret = beiscsi_init_port(phba);
+ 	if (ret < 0) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d : init port failed\n");
+ 		goto disable_msix;
+ 	}
+ 
+ 	for (i = 0; i < MAX_MCC_CMD; i++) {
+ 		init_waitqueue_head(&phba->ctrl.mcc_wait[i + 1]);
+ 		phba->ctrl.mcc_tag[i] = i + 1;
+ 		phba->ctrl.mcc_tag_status[i + 1] = 0;
+ 		phba->ctrl.mcc_tag_available++;
+ 	}
+ 
+ 	phwi_ctrlr = phba->phwi_ctrlr;
+ 	phwi_context = phwi_ctrlr->phwi_ctxt;
+ 	for (i = 0; i < phba->num_cpus; i++) {
+ 		pbe_eq = &phwi_context->be_eq[i];
+ 		irq_poll_init(&pbe_eq->iopoll, be_iopoll_budget, be_iopoll);
+ 	}
+ 
+ 	i = (phba->msix_enabled) ? i : 0;
+ 	/* Work item for MCC handling */
+ 	pbe_eq = &phwi_context->be_eq[i];
+ 	INIT_WORK(&pbe_eq->mcc_work, beiscsi_mcc_work);
+ 
+ 	ret = beiscsi_init_irqs(phba);
+ 	if (ret < 0) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d : setup IRQs failed %d\n", ret);
+ 		goto cleanup_port;
+ 	}
+ 	hwi_enable_intr(phba);
+ 	/* port operational: clear all error bits */
+ 	set_bit(BEISCSI_HBA_ONLINE, &phba->state);
+ 	__beiscsi_log(phba, KERN_INFO,
+ 		      "BM_%d : port online: 0x%lx\n", phba->state);
+ 
+ 	/* start hw_check timer and eqd_update work */
+ 	schedule_delayed_work(&phba->eqd_update,
+ 			      msecs_to_jiffies(BEISCSI_EQD_UPDATE_INTERVAL));
+ 
+ 	/**
+ 	 * Timer function gets modified for TPE detection.
+ 	 * Always reinit to do health check first.
+ 	 */
+ 	phba->hw_check.function = beiscsi_hw_health_check;
+ 	mod_timer(&phba->hw_check,
+ 		  jiffies + msecs_to_jiffies(BEISCSI_UE_DETECT_INTERVAL));
+ 	return 0;
+ 
+ cleanup_port:
+ 	for (i = 0; i < phba->num_cpus; i++) {
+ 		pbe_eq = &phwi_context->be_eq[i];
+ 		irq_poll_disable(&pbe_eq->iopoll);
+ 	}
+ 	hwi_cleanup_port(phba);
+ 
+ disable_msix:
+ 	if (phba->msix_enabled)
+ 		pci_disable_msix(phba->pcidev);
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * beiscsi_disable_port()- Disable port and cleanup driver resources.
+  * This is called in HBA error handling and driver removal.
+  * @phba: Instance Priv structure
+  * @unload: indicate driver is unloading
+  *
+  * Free the OS and HW resources held by the driver
+  **/
+ static void beiscsi_disable_port(struct beiscsi_hba *phba, int unload)
+ {
+ 	struct hwi_context_memory *phwi_context;
+ 	struct hwi_controller *phwi_ctrlr;
+ 	struct be_eq_obj *pbe_eq;
+ 	unsigned int i, msix_vec;
+ 
+ 	if (!test_and_clear_bit(BEISCSI_HBA_ONLINE, &phba->state))
+ 		return;
+ 
+ 	phwi_ctrlr = phba->phwi_ctrlr;
+ 	phwi_context = phwi_ctrlr->phwi_ctxt;
+ 	hwi_disable_intr(phba);
+ 	if (phba->msix_enabled) {
+ 		for (i = 0; i <= phba->num_cpus; i++) {
+ 			msix_vec = phba->msix_entries[i].vector;
+ 			free_irq(msix_vec, &phwi_context->be_eq[i]);
+ 			kfree(phba->msi_name[i]);
++>>>>>>> dd940972f367 (scsi: be2iscsi: Reinit SGL handle, CID tables after TPE)
  		}
 -	} else
 -		if (phba->pcidev->irq)
 -			free_irq(phba->pcidev->irq, phba);
 -	pci_disable_msix(phba->pcidev);
 -
 -	for (i = 0; i < phba->num_cpus; i++) {
 -		pbe_eq = &phwi_context->be_eq[i];
 -		irq_poll_disable(&pbe_eq->iopoll);
  	}
++<<<<<<< HEAD
 +
 +	beiscsi_ue_detect(phba);
 +
 +	schedule_delayed_work(&phba->beiscsi_hw_check_task,
 +			      msecs_to_jiffies(1000));
++=======
+ 	cancel_delayed_work_sync(&phba->eqd_update);
+ 	cancel_work_sync(&phba->boot_work);
+ 	/* WQ might be running cancel queued mcc_work if we are not exiting */
+ 	if (!unload && beiscsi_hba_in_error(phba)) {
+ 		pbe_eq = &phwi_context->be_eq[i];
+ 		cancel_work_sync(&pbe_eq->mcc_work);
+ 	}
+ 	hwi_cleanup_port(phba);
+ 	beiscsi_cleanup_port(phba);
++>>>>>>> dd940972f367 (scsi: be2iscsi: Reinit SGL handle, CID tables after TPE)
  }
  
 -static void beiscsi_sess_work(struct work_struct *work)
 -{
 -	struct beiscsi_hba *phba;
 -
 -	phba = container_of(work, struct beiscsi_hba, sess_work);
 -	/*
 -	 * This work gets scheduled only in case of HBA error.
 -	 * Old sessions are gone so need to be re-established.
 -	 * iscsi_session_failure needs process context hence this work.
 -	 */
 -	iscsi_host_for_each_session(phba->shost, beiscsi_session_fail);
 -}
 -
 -static void beiscsi_recover_port(struct work_struct *work)
 -{
 -	struct beiscsi_hba *phba;
 -
 -	phba = container_of(work, struct beiscsi_hba, recover_port.work);
 -	beiscsi_disable_port(phba, 0);
 -	beiscsi_enable_port(phba);
 -}
  
  static pci_ers_result_t beiscsi_eeh_err_detected(struct pci_dev *pdev,
  		pci_channel_state_t state)
@@@ -5793,6 -5824,48 +5931,51 @@@ disable_pci
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void beiscsi_remove(struct pci_dev *pcidev)
+ {
+ 	struct beiscsi_hba *phba = NULL;
+ 
+ 	phba = pci_get_drvdata(pcidev);
+ 	if (!phba) {
+ 		dev_err(&pcidev->dev, "beiscsi_remove called with no phba\n");
+ 		return;
+ 	}
+ 
+ 	/* first stop UE detection before unloading */
+ 	del_timer_sync(&phba->hw_check);
+ 	cancel_delayed_work_sync(&phba->recover_port);
+ 	cancel_work_sync(&phba->sess_work);
+ 
+ 	beiscsi_iface_destroy_default(phba);
+ 	iscsi_host_remove(phba->shost);
+ 	beiscsi_disable_port(phba, 1);
+ 
+ 	/* after cancelling boot_work */
+ 	iscsi_boot_destroy_kset(phba->boot_struct.boot_kset);
+ 
+ 	/* free all resources */
+ 	destroy_workqueue(phba->wq);
+ 	beiscsi_free_mem(phba);
+ 
+ 	/* ctrl uninit */
+ 	beiscsi_unmap_pci_function(phba);
+ 	pci_free_consistent(phba->pcidev,
+ 			    phba->ctrl.mbox_mem_alloced.size,
+ 			    phba->ctrl.mbox_mem_alloced.va,
+ 			    phba->ctrl.mbox_mem_alloced.dma);
+ 
+ 	pci_dev_put(phba->pcidev);
+ 	iscsi_host_free(phba->shost);
+ 	pci_disable_pcie_error_reporting(pcidev);
+ 	pci_set_drvdata(pcidev, NULL);
+ 	pci_release_regions(pcidev);
+ 	pci_disable_device(pcidev);
+ }
+ 
+ 
++>>>>>>> dd940972f367 (scsi: be2iscsi: Reinit SGL handle, CID tables after TPE)
  static struct pci_error_handlers beiscsi_eeh_handlers = {
  	.error_detected = beiscsi_eeh_err_detected,
  	.slot_reset = beiscsi_eeh_reset,
* Unmerged path drivers/scsi/be2iscsi/be_main.c
