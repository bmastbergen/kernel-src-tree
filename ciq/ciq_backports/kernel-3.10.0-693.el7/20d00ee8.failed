Revert "vfs: add lookup_hash() helper"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit 20d00ee829428ea6aab77fa3acca048a6f57d3bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/20d00ee8.failed

This reverts commit 3c9fe8cdff1b889a059a30d22f130372f2b3885f.

As Miklos points out in commit c1b2cc1a765a, the "lookup_hash()" helper
is now unused, and in fact, with the hash salting changes, since the
hash of a dentry name now depends on the directory dentry it is in, the
helper function isn't even really likely to be useful.

So rather than keep it around in case somebody else might end up finding
a use for it, let's just remove the helper and not trick people into
thinking it might be a useful thing.

For example, I had obviously completely missed how the helper didn't
follow the normal dentry hashing patterns, and how the hash salting
patch broke overlayfs.  Things would quietly build and look sane, but
not work.

	Suggested-by: Miklos Szeredi <mszeredi@redhat.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 20d00ee829428ea6aab77fa3acca048a6f57d3bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
#	include/linux/namei.h
diff --cc fs/namei.c
index 872e5e58c054,68a896c804b7..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -2133,56 -2388,14 +2133,59 @@@ int vfs_path_lookup(struct dentry *dent
  		    const char *name, unsigned int flags,
  		    struct path *path)
  {
 -	struct path root = {.mnt = mnt, .dentry = dentry};
 -	/* the first argument of filename_lookup() is ignored with root */
 -	return filename_lookup(AT_FDCWD, getname_kernel(name),
 -			       flags , path, &root);
 +	struct nameidata nd;
 +	int err;
 +	nd.root.dentry = dentry;
 +	nd.root.mnt = mnt;
 +	BUG_ON(flags & LOOKUP_PARENT);
 +	/* the first argument of do_path_lookup() is ignored with LOOKUP_ROOT */
 +	err = do_path_lookup(AT_FDCWD, name, flags | LOOKUP_ROOT, &nd);
 +	if (!err)
 +		*path = nd.path;
 +	return err;
 +}
 +
 +/*
 + * Restricted form of lookup. Doesn't follow links, single-component only,
 + * needs parent already locked. Doesn't follow mounts.
 + * SMP-safe.
 + */
 +static struct dentry *lookup_hash_locked(struct nameidata *nd)
 +{
 +	return __lookup_hash(&nd->last, nd->path.dentry, nd->flags);
  }
 -EXPORT_SYMBOL(vfs_path_lookup);
  
  /**
++<<<<<<< HEAD
 + * lookup_hash - lookup single pathname component on already hashed name
 + * @name:	name and hash to lookup
 + * @base:	base directory to lookup from
 + *
 + * The name must have been verified and hashed (see lookup_one_len()).  Using
 + * this after just full_name_hash() is unsafe.
 + *
 + * This function also doesn't check for search permission on base directory.
 + *
 + * Use lookup_one_len() instead, unless you really know what you are
 + * doing.
 + *
 + * Do not hold i_mutex; this helper takes i_mutex if necessary.
 + */
 +struct dentry *lookup_hash(struct qstr *name, struct dentry *base)
 +{
 +	struct dentry *ret;
 +
 +	mutex_lock(&base->d_inode->i_mutex);
 +	ret = __lookup_hash(name, base, 0);
 +	mutex_unlock(&base->d_inode->i_mutex);
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL(lookup_hash);
 +
 +/**
++=======
++>>>>>>> 20d00ee82942 (Revert "vfs: add lookup_hash() helper")
   * lookup_one_len - filesystem helper to lookup single pathname component
   * @name:	pathname component to lookup
   * @base:	base directory to lookup from
@@@ -2286,15 -2498,24 +2289,30 @@@ struct dentry *lookup_one_len_unlocked(
  	if (err)
  		return ERR_PTR(err);
  
++<<<<<<< HEAD
 +	/*
 +	 * __d_lookup() is used to try to get a quick answer and avoid the
 +	 * mutex.  A false-negative does no harm.
++=======
+ 	ret = lookup_dcache(&this, base, 0);
+ 	if (!ret)
+ 		ret = lookup_slow(&this, base, 0);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(lookup_one_len_unlocked);
+ 
+ #ifdef CONFIG_UNIX98_PTYS
+ int path_pts(struct path *path)
+ {
+ 	/* Find something mounted on "pts" in the same directory as
+ 	 * the input path.
++>>>>>>> 20d00ee82942 (Revert "vfs: add lookup_hash() helper")
  	 */
 -	struct dentry *child, *parent;
 -	struct qstr this;
 -	int ret;
 -
 -	ret = path_parent_directory(path);
 +	ret = __d_lookup(base, &this);
 +	if (ret && unlikely(ret->d_flags & DCACHE_OP_REVALIDATE)) {
 +		dput(ret);
 +		ret = NULL;
 +	}
  	if (ret)
  		return ret;
  
diff --cc include/linux/namei.h
index 2e42a91d6ae0,f29abda31e6d..000000000000
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@@ -74,9 -81,6 +74,12 @@@ extern int kern_path_mountpoint(int, co
  
  extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
  extern struct dentry *lookup_one_len_unlocked(const char *, struct dentry *, int);
++<<<<<<< HEAD
 +struct qstr;
 +extern struct dentry *lookup_hash(struct qstr *, struct dentry *);
 +
++=======
++>>>>>>> 20d00ee82942 (Revert "vfs: add lookup_hash() helper")
  
  extern int follow_down_one(struct path *);
  extern int follow_down(struct path *);
* Unmerged path fs/namei.c
* Unmerged path include/linux/namei.h
