ipv6: fix sparse warnings in privacy stable addresses generation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit ff40217e73fd137daae0113ed71b218128913037
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ff40217e.failed

Those warnings reported by sparse endianness check (via kbuild test robot)
are harmless, nevertheless fix them up and make the code a little bit
easier to read.

	Reported-by: kbuild test robot <fengguang.wu@intel.com>
Fixes: 622c81d57b392cc ("ipv6: generation of stable privacy addresses for link-local and autoconf")
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ff40217e73fd137daae0113ed71b218128913037)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 49e6c7d2081a,2660263e1131..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -2790,12 -2878,97 +2790,93 @@@ static void addrconf_add_linklocal(stru
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static bool ipv6_reserved_interfaceid(struct in6_addr address)
+ {
+ 	if ((address.s6_addr32[2] | address.s6_addr32[3]) == 0)
+ 		return true;
+ 
+ 	if (address.s6_addr32[2] == htonl(0x02005eff) &&
+ 	    ((address.s6_addr32[3] & htonl(0xfe000000)) == htonl(0xfe000000)))
+ 		return true;
+ 
+ 	if (address.s6_addr32[2] == htonl(0xfdffffff) &&
+ 	    ((address.s6_addr32[3] & htonl(0xffffff80)) == htonl(0xffffff80)))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static int ipv6_generate_stable_address(struct in6_addr *address,
+ 					u8 dad_count,
+ 					const struct inet6_dev *idev)
+ {
+ 	static DEFINE_SPINLOCK(lock);
+ 	static __u32 digest[SHA_DIGEST_WORDS];
+ 	static __u32 workspace[SHA_WORKSPACE_WORDS];
+ 
+ 	static union {
+ 		char __data[SHA_MESSAGE_BYTES];
+ 		struct {
+ 			struct in6_addr secret;
+ 			__be32 prefix[2];
+ 			unsigned char hwaddr[MAX_ADDR_LEN];
+ 			u8 dad_count;
+ 		} __packed;
+ 	} data;
+ 
+ 	struct in6_addr secret;
+ 	struct in6_addr temp;
+ 	struct net *net = dev_net(idev->dev);
+ 
+ 	BUILD_BUG_ON(sizeof(data.__data) != sizeof(data));
+ 
+ 	if (idev->cnf.stable_secret.initialized)
+ 		secret = idev->cnf.stable_secret.secret;
+ 	else if (net->ipv6.devconf_dflt->stable_secret.initialized)
+ 		secret = net->ipv6.devconf_dflt->stable_secret.secret;
+ 	else
+ 		return -1;
+ 
+ retry:
+ 	spin_lock_bh(&lock);
+ 
+ 	sha_init(digest);
+ 	memset(&data, 0, sizeof(data));
+ 	memset(workspace, 0, sizeof(workspace));
+ 	memcpy(data.hwaddr, idev->dev->perm_addr, idev->dev->addr_len);
+ 	data.prefix[0] = address->s6_addr32[0];
+ 	data.prefix[1] = address->s6_addr32[1];
+ 	data.secret = secret;
+ 	data.dad_count = dad_count;
+ 
+ 	sha_transform(digest, data.__data, workspace);
+ 
+ 	temp = *address;
+ 	temp.s6_addr32[2] = (__force __be32)digest[0];
+ 	temp.s6_addr32[3] = (__force __be32)digest[1];
+ 
+ 	spin_unlock_bh(&lock);
+ 
+ 	if (ipv6_reserved_interfaceid(temp)) {
+ 		dad_count++;
+ 		if (dad_count > dev_net(idev->dev)->ipv6.sysctl.idgen_retries)
+ 			return -1;
+ 		goto retry;
+ 	}
+ 
+ 	*address = temp;
+ 	return 0;
+ }
+ 
++>>>>>>> ff40217e73fd (ipv6: fix sparse warnings in privacy stable addresses generation)
  static void addrconf_addr_gen(struct inet6_dev *idev, bool prefix_route)
  {
 -	struct in6_addr addr;
 -
 -	ipv6_addr_set(&addr, htonl(0xFE800000), 0, 0, 0);
 +	if (idev->addr_gen_mode == IN6_ADDR_GEN_MODE_EUI64) {
 +		struct in6_addr addr;
  
 -	if (idev->addr_gen_mode == IN6_ADDR_GEN_MODE_STABLE_PRIVACY) {
 -		if (!ipv6_generate_stable_address(&addr, 0, idev))
 -			addrconf_add_linklocal(idev, &addr,
 -					       IFA_F_STABLE_PRIVACY);
 -		else if (prefix_route)
 -			addrconf_prefix_route(&addr, 64, idev->dev, 0, 0);
 -	} else if (idev->addr_gen_mode == IN6_ADDR_GEN_MODE_EUI64) {
 +		ipv6_addr_set(&addr,  htonl(0xFE800000), 0, 0, 0);
  		/* addrconf_add_linklocal also adds a prefix_route and we
  		 * only need to care about prefix routes if ipv6_generate_eui64
  		 * couldn't generate one.
* Unmerged path net/ipv6/addrconf.c
