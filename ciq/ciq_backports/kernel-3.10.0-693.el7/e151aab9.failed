net: bridge: rearrange flood vs unicast receive paths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] bridge: rearrange flood vs unicast receive paths (Ivan Vecera) [1352289]
Rebuild_FUZZ: 95.05%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit e151aab9b5b3fae96b0fcd6cbe3a7f952d6cb8f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e151aab9.failed

This patch removes one conditional from the unicast path by using the fact
that skb is NULL only when the packet is multicast or is local.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e151aab9b5b3fae96b0fcd6cbe3a7f952d6cb8f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_input.c
diff --cc net/bridge/br_input.c
index ddc6cbe6269c,c20c5be6fc22..000000000000
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@@ -59,15 -129,15 +59,20 @@@ static int br_pass_frame_up(struct sk_b
  }
  
  /* note: already called with rcu_read_lock */
 -int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 +int br_handle_frame_finish(struct sock *sk, struct sk_buff *skb)
  {
 -	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
  	const unsigned char *dest = eth_hdr(skb)->h_dest;
++<<<<<<< HEAD
 +	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
++=======
+ 	struct net_bridge_fdb_entry *dst = NULL;
+ 	bool mcast_hit = false, unicast = true;
+ 	struct net_bridge_mdb_entry *mdst;
++>>>>>>> e151aab9b5b3 (net: bridge: rearrange flood vs unicast receive paths)
  	struct net_bridge *br;
 +	struct net_bridge_fdb_entry *dst;
 +	struct net_bridge_mdb_entry *mdst;
  	struct sk_buff *skb2;
- 	bool unicast = true;
  	u16 vid = 0;
  
  	if (!p || p->state == BR_STATE_DISABLED)
@@@ -106,30 -177,29 +111,53 @@@
  		if ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&
  		    br_multicast_querier_exists(br, eth_hdr(skb))) {
  			if ((mdst && mdst->mglist) ||
- 			    br_multicast_is_router(br))
+ 			    br_multicast_is_router(br)) {
  				skb2 = skb;
++<<<<<<< HEAD
 +			br_multicast_forward(mdst, skb, skb2);
 +			skb = NULL;
 +			if (!skb2)
 +				goto out;
 +		} else
 +			skb2 = skb;
 +
 +		unicast = false;
 +		br->dev->stats.multicast++;
 +	} else if ((dst = __br_fdb_get(br, dest, vid)) &&
 +			dst->is_local) {
 +		skb2 = skb;
++=======
+ 				br->dev->stats.multicast++;
+ 			}
+ 			mcast_hit = true;
+ 		} else {
+ 			skb2 = skb;
+ 			br->dev->stats.multicast++;
+ 		}
+ 		unicast = false;
+ 	} else if ((dst = __br_fdb_get(br, dest, vid)) && dst->is_local) {
++>>>>>>> e151aab9b5b3 (net: bridge: rearrange flood vs unicast receive paths)
  		/* Do not forward the packet since it's local. */
- 		skb = NULL;
+ 		return br_pass_frame_up(skb);
  	}
  
++<<<<<<< HEAD
 +	if (skb) {
 +		if (dst) {
 +			dst->used = jiffies;
 +			br_forward(dst->dst, skb, skb2);
 +		} else
 +			br_flood_forward(br, skb, skb2, unicast);
++=======
+ 	if (dst) {
+ 		dst->used = jiffies;
+ 		br_forward(dst->dst, skb, skb2);
+ 	} else {
+ 		if (!mcast_hit)
+ 			br_flood_forward(br, skb, skb2, unicast);
+ 		else
+ 			br_multicast_forward(mdst, skb, skb2);
++>>>>>>> e151aab9b5b3 (net: bridge: rearrange flood vs unicast receive paths)
  	}
  
  	if (skb2)
* Unmerged path net/bridge/br_input.c
