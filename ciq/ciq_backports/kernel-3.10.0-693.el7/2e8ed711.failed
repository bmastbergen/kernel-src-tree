dm block manager: make block locking optional

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Joe Thornber <ejt@redhat.com>
commit 2e8ed71102ff8fe3919dd3a2d73ac4da72686efc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2e8ed711.failed

The block manager's locking is useful for catching cycles that may
result from certain btree metadata corruption.  But in general it serves
as a developer tool to catch bugs in code.  Unless you're finding that
DM thin provisioning is hanging due to infinite loops within the block
manager's access to btree nodes you can safely disable this feature.

	Signed-off-by: Joe Thornber <ejt@redhat.com>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de> # do/while(0) macro fix
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 2e8ed71102ff8fe3919dd3a2d73ac4da72686efc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/Kconfig
diff --cc drivers/md/Kconfig
index b74c2ec3b0a4,b7767da50c26..000000000000
--- a/drivers/md/Kconfig
+++ b/drivers/md/Kconfig
@@@ -222,9 -240,17 +222,22 @@@ config DM_BUFI
  	 as a cache, holding recently-read blocks in memory and performing
  	 delayed writes.
  
+ config DM_DEBUG_BLOCK_MANAGER_LOCKING
+        bool "Block manager locking"
+        depends on DM_BUFIO
+        ---help---
+ 	 Block manager locking can catch various metadata corruption issues.
+ 
+ 	 If unsure, say N.
+ 
  config DM_DEBUG_BLOCK_STACK_TRACING
++<<<<<<< HEAD
 +       boolean "Keep stack trace of persistent data block lock holders"
 +       depends on STACKTRACE_SUPPORT && DM_BUFIO
++=======
+        bool "Keep stack trace of persistent data block lock holders"
+        depends on STACKTRACE_SUPPORT && DM_DEBUG_BLOCK_MANAGER_LOCKING
++>>>>>>> 2e8ed71102ff (dm block manager: make block locking optional)
         select STACKTRACE
         ---help---
  	 Enable this for messages that may help debug problems with the
* Unmerged path drivers/md/Kconfig
diff --git a/drivers/md/persistent-data/dm-block-manager.c b/drivers/md/persistent-data/dm-block-manager.c
index 1e33dd51c21f..a6dde7cab458 100644
--- a/drivers/md/persistent-data/dm-block-manager.c
+++ b/drivers/md/persistent-data/dm-block-manager.c
@@ -18,6 +18,8 @@
 
 /*----------------------------------------------------------------*/
 
+#ifdef CONFIG_DM_DEBUG_BLOCK_MANAGER_LOCKING
+
 /*
  * This is a read/write semaphore with a couple of differences.
  *
@@ -302,6 +304,18 @@ static void report_recursive_bug(dm_block_t b, int r)
 		      (unsigned long long) b);
 }
 
+#else  /* !CONFIG_DM_DEBUG_BLOCK_MANAGER_LOCKING */
+
+#define bl_init(x) do { } while (0)
+#define bl_down_read(x) 0
+#define bl_down_read_nonblock(x) 0
+#define bl_up_read(x) do { } while (0)
+#define bl_down_write(x) 0
+#define bl_up_write(x) do { } while (0)
+#define report_recursive_bug(x, y) do { } while (0)
+
+#endif /* CONFIG_DM_DEBUG_BLOCK_MANAGER_LOCKING */
+
 /*----------------------------------------------------------------*/
 
 /*
@@ -330,8 +344,11 @@ EXPORT_SYMBOL_GPL(dm_block_data);
 
 struct buffer_aux {
 	struct dm_block_validator *validator;
-	struct block_lock lock;
 	int write_locked;
+
+#ifdef CONFIG_DM_DEBUG_BLOCK_MANAGER_LOCKING
+	struct block_lock lock;
+#endif
 };
 
 static void dm_block_manager_alloc_callback(struct dm_buffer *buf)
