x86/cpuid: Cleanup cpuid_regs definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] cpuid: Cleanup cpuid_regs definitions (Paul Lai) [1382116]
Rebuild_FUZZ: 94.87%
commit-author He Chen <he.chen@linux.intel.com>
commit 47f10a36003eaf493125a5e6687dd1ff775bfd8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/47f10a36.failed

cpuid_regs is defined multiple times as structure and enum. Rename the enum
and move all of it to processor.h so we don't end up with more instances.

Rename the misnomed register enumeration from CR_* to the obvious CPUID_*.

[ tglx: Rewrote changelog ]

	Signed-off-by: He Chen <he.chen@linux.intel.com>
	Reviewed-by: Borislav Petkov <bp@alien8.de>
	Cc: Luwei Kang <luwei.kang@intel.com>
	Cc: kvm@vger.kernel.org
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Piotr Luc <Piotr.Luc@intel.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
Link: http://lkml.kernel.org/r/1478856336-9388-2-git-send-email-he.chen@linux.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 47f10a36003eaf493125a5e6687dd1ff775bfd8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/scattered.c
diff --cc arch/x86/kernel/cpu/scattered.c
index 21e9c42c84be,dbb470e839f8..000000000000
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@@ -31,32 -24,14 +24,43 @@@ void init_scattered_cpuid_features(stru
  	const struct cpuid_bit *cb;
  
  	static const struct cpuid_bit cpuid_bits[] = {
++<<<<<<< HEAD
 +		{ X86_FEATURE_DTHERM,		CR_EAX, 0, 0x00000006, 0 },
 +		{ X86_FEATURE_IDA,		CR_EAX, 1, 0x00000006, 0 },
 +		{ X86_FEATURE_ARAT,		CR_EAX, 2, 0x00000006, 0 },
 +		{ X86_FEATURE_PLN,		CR_EAX, 4, 0x00000006, 0 },
 +		{ X86_FEATURE_PTS,		CR_EAX, 6, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP,		CR_EAX, 7, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP_NOITFY,	CR_EAX, 8, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP_ACT_WINDOW,	CR_EAX, 9, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP_EPP,		CR_EAX,10, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP_PKG_REQ,	CR_EAX,11, 0x00000006, 0 },
 +		{ X86_FEATURE_INTEL_PT,		CR_EBX,25, 0x00000007, 0 },
 +		{ X86_FEATURE_APERFMPERF,	CR_ECX, 0, 0x00000006, 0 },
 +		{ X86_FEATURE_EPB,		CR_ECX, 3, 0x00000006, 0 },
 +		{ X86_FEATURE_HW_PSTATE,	CR_EDX, 7, 0x80000007, 0 },
 +		{ X86_FEATURE_CPB,		CR_EDX, 9, 0x80000007, 0 },
 +		{ X86_FEATURE_PROC_FEEDBACK,	CR_EDX,11, 0x80000007, 0 },
 +		{ X86_FEATURE_NPT,		CR_EDX, 0, 0x8000000a, 0 },
 +		{ X86_FEATURE_LBRV,		CR_EDX, 1, 0x8000000a, 0 },
 +		{ X86_FEATURE_SVML,		CR_EDX, 2, 0x8000000a, 0 },
 +		{ X86_FEATURE_NRIPS,		CR_EDX, 3, 0x8000000a, 0 },
 +		{ X86_FEATURE_TSCRATEMSR,	CR_EDX, 4, 0x8000000a, 0 },
 +		{ X86_FEATURE_VMCBCLEAN,	CR_EDX, 5, 0x8000000a, 0 },
 +		{ X86_FEATURE_FLUSHBYASID,	CR_EDX, 6, 0x8000000a, 0 },
 +		{ X86_FEATURE_DECODEASSISTS,	CR_EDX, 7, 0x8000000a, 0 },
 +		{ X86_FEATURE_PAUSEFILTER,	CR_EDX,10, 0x8000000a, 0 },
 +		{ X86_FEATURE_PFTHRESHOLD,	CR_EDX,12, 0x8000000a, 0 },
++=======
+ 		{ X86_FEATURE_INTEL_PT,		CPUID_EBX, 25, 0x00000007, 0 },
+ 		{ X86_FEATURE_AVX512_4VNNIW,	CPUID_EDX,  2, 0x00000007, 0 },
+ 		{ X86_FEATURE_AVX512_4FMAPS,	CPUID_EDX,  3, 0x00000007, 0 },
+ 		{ X86_FEATURE_APERFMPERF,	CPUID_ECX,  0, 0x00000006, 0 },
+ 		{ X86_FEATURE_EPB,		CPUID_ECX,  3, 0x00000006, 0 },
+ 		{ X86_FEATURE_HW_PSTATE,	CPUID_EDX,  7, 0x80000007, 0 },
+ 		{ X86_FEATURE_CPB,		CPUID_EDX,  9, 0x80000007, 0 },
+ 		{ X86_FEATURE_PROC_FEEDBACK,	CPUID_EDX, 11, 0x80000007, 0 },
++>>>>>>> 47f10a36003e (x86/cpuid: Cleanup cpuid_regs definitions)
  		{ 0, 0, 0, 0, 0 }
  	};
  
diff --git a/arch/x86/events/intel/pt.c b/arch/x86/events/intel/pt.c
index 7be7dc2d9165..4475ccf28f29 100644
--- a/arch/x86/events/intel/pt.c
+++ b/arch/x86/events/intel/pt.c
@@ -36,13 +36,6 @@ static DEFINE_PER_CPU(struct pt, pt_ctx);
 
 static struct pt_pmu pt_pmu;
 
-enum cpuid_regs {
-	CR_EAX = 0,
-	CR_ECX,
-	CR_EDX,
-	CR_EBX
-};
-
 /*
  * Capabilities of Intel PT hardware, such as number of address bits or
  * supported output schemes, are cached and exported to userspace as "caps"
@@ -64,21 +57,21 @@ static struct pt_cap_desc {
 	u8		reg;
 	u32		mask;
 } pt_caps[] = {
-	PT_CAP(max_subleaf,		0, CR_EAX, 0xffffffff),
-	PT_CAP(cr3_filtering,		0, CR_EBX, BIT(0)),
-	PT_CAP(psb_cyc,			0, CR_EBX, BIT(1)),
-	PT_CAP(ip_filtering,		0, CR_EBX, BIT(2)),
-	PT_CAP(mtc,			0, CR_EBX, BIT(3)),
-	PT_CAP(ptwrite,			0, CR_EBX, BIT(4)),
-	PT_CAP(power_event_trace,	0, CR_EBX, BIT(5)),
-	PT_CAP(topa_output,		0, CR_ECX, BIT(0)),
-	PT_CAP(topa_multiple_entries,	0, CR_ECX, BIT(1)),
-	PT_CAP(single_range_output,	0, CR_ECX, BIT(2)),
-	PT_CAP(payloads_lip,		0, CR_ECX, BIT(31)),
-	PT_CAP(num_address_ranges,	1, CR_EAX, 0x3),
-	PT_CAP(mtc_periods,		1, CR_EAX, 0xffff0000),
-	PT_CAP(cycle_thresholds,	1, CR_EBX, 0xffff),
-	PT_CAP(psb_periods,		1, CR_EBX, 0xffff0000),
+	PT_CAP(max_subleaf,		0, CPUID_EAX, 0xffffffff),
+	PT_CAP(cr3_filtering,		0, CPUID_EBX, BIT(0)),
+	PT_CAP(psb_cyc,			0, CPUID_EBX, BIT(1)),
+	PT_CAP(ip_filtering,		0, CPUID_EBX, BIT(2)),
+	PT_CAP(mtc,			0, CPUID_EBX, BIT(3)),
+	PT_CAP(ptwrite,			0, CPUID_EBX, BIT(4)),
+	PT_CAP(power_event_trace,	0, CPUID_EBX, BIT(5)),
+	PT_CAP(topa_output,		0, CPUID_ECX, BIT(0)),
+	PT_CAP(topa_multiple_entries,	0, CPUID_ECX, BIT(1)),
+	PT_CAP(single_range_output,	0, CPUID_ECX, BIT(2)),
+	PT_CAP(payloads_lip,		0, CPUID_ECX, BIT(31)),
+	PT_CAP(num_address_ranges,	1, CPUID_EAX, 0x3),
+	PT_CAP(mtc_periods,		1, CPUID_EAX, 0xffff0000),
+	PT_CAP(cycle_thresholds,	1, CPUID_EBX, 0xffff),
+	PT_CAP(psb_periods,		1, CPUID_EBX, 0xffff0000),
 };
 
 static u32 pt_cap_get(enum pt_capabilities cap)
@@ -219,10 +212,10 @@ static int __init pt_pmu_hw_init(void)
 
 	for (i = 0; i < PT_CPUID_LEAVES; i++) {
 		cpuid_count(20, i,
-			    &pt_pmu.caps[CR_EAX + i*PT_CPUID_REGS_NUM],
-			    &pt_pmu.caps[CR_EBX + i*PT_CPUID_REGS_NUM],
-			    &pt_pmu.caps[CR_ECX + i*PT_CPUID_REGS_NUM],
-			    &pt_pmu.caps[CR_EDX + i*PT_CPUID_REGS_NUM]);
+			    &pt_pmu.caps[CPUID_EAX + i*PT_CPUID_REGS_NUM],
+			    &pt_pmu.caps[CPUID_EBX + i*PT_CPUID_REGS_NUM],
+			    &pt_pmu.caps[CPUID_ECX + i*PT_CPUID_REGS_NUM],
+			    &pt_pmu.caps[CPUID_EDX + i*PT_CPUID_REGS_NUM]);
 	}
 
 	ret = -ENOMEM;
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index b43e343ac07a..48ff8fc08590 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -140,6 +140,17 @@ struct cpuinfo_x86 {
 	u32			microcode;
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
 
+struct cpuid_regs {
+	u32 eax, ebx, ecx, edx;
+};
+
+enum cpuid_regs_idx {
+	CPUID_EAX = 0,
+	CPUID_EBX,
+	CPUID_ECX,
+	CPUID_EDX,
+};
+
 #define X86_VENDOR_INTEL	0
 #define X86_VENDOR_CYRIX	1
 #define X86_VENDOR_AMD		2
* Unmerged path arch/x86/kernel/cpu/scattered.c
diff --git a/arch/x86/kernel/cpuid.c b/arch/x86/kernel/cpuid.c
index 49e8a762f49d..5a1f4e464cea 100644
--- a/arch/x86/kernel/cpuid.c
+++ b/arch/x86/kernel/cpuid.c
@@ -46,10 +46,6 @@
 
 static struct class *cpuid_class;
 
-struct cpuid_regs {
-	u32 eax, ebx, ecx, edx;
-};
-
 static void cpuid_smp_cpuid(void *cmd_block)
 {
 	struct cpuid_regs *cmd = (struct cpuid_regs *)cmd_block;
