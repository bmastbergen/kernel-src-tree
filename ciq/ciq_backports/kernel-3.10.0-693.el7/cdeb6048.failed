x86/asm/irq: Stop relying on magic JMP behavior for early_idt_handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] asm/irq: Stop relying on magic JMP behavior for early_idt_handlers (Prarit Bhargava) [1422146]
Rebuild_FUZZ: 97.06%
commit-author Andy Lutomirski <luto@kernel.org>
commit cdeb6048940fa4bfb429e2f1cba0d28a11e20cd5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cdeb6048.failed

The early_idt_handlers asm code generates an array of entry
points spaced nine bytes apart.  It's not really clear from that
code or from the places that reference it what's going on, and
the code only works in the first place because GAS never
generates two-byte JMP instructions when jumping to global
labels.

Clean up the code to generate the correct array stride (member size)
explicitly. This should be considerably more robust against
screw-ups, as GAS will warn if a .fill directive has a negative
count.  Using '. =' to advance would have been even more robust
(it would generate an actual error if it tried to move
backwards), but it would pad with nulls, confusing anyone who
tries to disassemble the code.  The new scheme should be much
clearer to future readers.

While we're at it, improve the comments and rename the array and
common code.

Binutils may start relaxing jumps to non-weak labels.  If so,
this change will fix our build, and we may need to backport this
change.

Before, on x86_64:

  0000000000000000 <early_idt_handlers>:
     0:   6a 00                   pushq  $0x0
     2:   6a 00                   pushq  $0x0
     4:   e9 00 00 00 00          jmpq   9 <early_idt_handlers+0x9>
                          5: R_X86_64_PC32        early_idt_handler-0x4
  ...
    48:   66 90                   xchg   %ax,%ax
    4a:   6a 08                   pushq  $0x8
    4c:   e9 00 00 00 00          jmpq   51 <early_idt_handlers+0x51>
                          4d: R_X86_64_PC32       early_idt_handler-0x4
  ...
   117:   6a 00                   pushq  $0x0
   119:   6a 1f                   pushq  $0x1f
   11b:   e9 00 00 00 00          jmpq   120 <early_idt_handler>
                          11c: R_X86_64_PC32      early_idt_handler-0x4

After:

  0000000000000000 <early_idt_handler_array>:
     0:   6a 00                   pushq  $0x0
     2:   6a 00                   pushq  $0x0
     4:   e9 14 01 00 00          jmpq   11d <early_idt_handler_common>
  ...
    48:   6a 08                   pushq  $0x8
    4a:   e9 d1 00 00 00          jmpq   120 <early_idt_handler_common>
    4f:   cc                      int3
    50:   cc                      int3
  ...
   117:   6a 00                   pushq  $0x0
   119:   6a 1f                   pushq  $0x1f
   11b:   eb 03                   jmp    120 <early_idt_handler_common>
   11d:   cc                      int3
   11e:   cc                      int3
   11f:   cc                      int3

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Acked-by: H. Peter Anvin <hpa@linux.intel.com>
	Cc: Binutils <binutils@sourceware.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: H.J. Lu <hjl.tools@gmail.com>
	Cc: Jan Beulich <JBeulich@suse.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/ac027962af343b0c599cbfcf50b945ad2ef3d7a8.1432336324.git.luto@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit cdeb6048940fa4bfb429e2f1cba0d28a11e20cd5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/segment.h
diff --cc arch/x86/include/asm/segment.h
index 6f1c3a8a33ab,7d5a1929d76b..000000000000
--- a/arch/x86/include/asm/segment.h
+++ b/arch/x86/include/asm/segment.h
@@@ -184,38 -216,36 +184,55 @@@
  
  #endif
  
 +#define __KERNEL_CS	(GDT_ENTRY_KERNEL_CS*8)
 +#define __KERNEL_DS	(GDT_ENTRY_KERNEL_DS*8)
 +#define __USER_DS	(GDT_ENTRY_DEFAULT_USER_DS*8+3)
 +#define __USER_CS	(GDT_ENTRY_DEFAULT_USER_CS*8+3)
  #ifndef CONFIG_PARAVIRT
 -# define get_kernel_rpl()		0
 +#define get_kernel_rpl()  0
  #endif
  
 -#define IDT_ENTRIES			256
 -#define NUM_EXCEPTION_VECTORS		32
 +/* User mode is privilege level 3 */
 +#define USER_RPL		0x3
 +/* LDT segment has TI set, GDT has it cleared */
 +#define SEGMENT_LDT		0x4
 +#define SEGMENT_GDT		0x0
  
 -/* Bitmask of exception vectors which push an error code on the stack: */
 -#define EXCEPTION_ERRCODE_MASK		0x00027d00
 +/* Bottom two bits of selector give the ring privilege level */
 +#define SEGMENT_RPL_MASK	0x3
 +/* Bit 2 is table indicator (LDT/GDT) */
 +#define SEGMENT_TI_MASK		0x4
  
 -#define GDT_SIZE			(GDT_ENTRIES*8)
 -#define GDT_ENTRY_TLS_ENTRIES		3
 -#define TLS_SIZE			(GDT_ENTRY_TLS_ENTRIES* 8)
 +#define IDT_ENTRIES 256
 +#define NUM_EXCEPTION_VECTORS 32
 +/* Bitmask of exception vectors which push an error code on the stack */
 +#define EXCEPTION_ERRCODE_MASK  0x00027d00
 +#define GDT_SIZE (GDT_ENTRIES * 8)
 +#define GDT_ENTRY_TLS_ENTRIES 3
 +#define TLS_SIZE (GDT_ENTRY_TLS_ENTRIES * 8)
  
  #ifdef __KERNEL__
+ 
+ /*
+  * early_idt_handler_array is an array of entry points referenced in the
+  * early IDT.  For simplicity, it's a real array with one entry point
+  * every nine bytes.  That leaves room for an optional 'push $0' if the
+  * vector has no error code (two bytes), a 'push $vector_number' (two
+  * bytes), and a jump to the common entry code (up to five bytes).
+  */
+ #define EARLY_IDT_HANDLER_SIZE 9
+ 
  #ifndef __ASSEMBLY__
++<<<<<<< HEAD
 +extern const char early_idt_handlers[NUM_EXCEPTION_VECTORS][2+2+5];
 +#ifdef CONFIG_TRACING
 +#define trace_early_idt_handlers early_idt_handlers
++=======
+ 
+ extern const char early_idt_handler_array[NUM_EXCEPTION_VECTORS][EARLY_IDT_HANDLER_SIZE];
+ #ifdef CONFIG_TRACING
+ # define trace_early_idt_handler_array early_idt_handler_array
++>>>>>>> cdeb6048940f (x86/asm/irq: Stop relying on magic JMP behavior for early_idt_handlers)
  #endif
  
  /*
* Unmerged path arch/x86/include/asm/segment.h
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 0ffaa577cb5b..39ad3cdc4c78 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -162,7 +162,7 @@ void __init x86_64_start_kernel(char * real_mode_data)
 	clear_bss();
 
 	for (i = 0; i < NUM_EXCEPTION_VECTORS; i++)
-		set_intr_gate(i, early_idt_handlers[i]);
+		set_intr_gate(i, early_idt_handler_array[i]);
 	load_idt((const struct desc_ptr *)&idt_descr);
 
 	copy_bootdata(__va(real_mode_data));
diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S
index 6ccf14a5ec89..7592a9c4898b 100644
--- a/arch/x86/kernel/head_32.S
+++ b/arch/x86/kernel/head_32.S
@@ -497,21 +497,22 @@ check_x87:
 __INIT
 setup_once:
 	/*
-	 * Set up a idt with 256 entries pointing to ignore_int,
-	 * interrupt gates. It doesn't actually load idt - that needs
-	 * to be done on each CPU. Interrupts are enabled elsewhere,
-	 * when we can be relatively sure everything is ok.
+	 * Set up a idt with 256 interrupt gates that push zero if there
+	 * is no error code and then jump to early_idt_handler_common.
+	 * It doesn't actually load the idt - that needs to be done on
+	 * each CPU. Interrupts are enabled elsewhere, when we can be
+	 * relatively sure everything is ok.
 	 */
 
 	movl $idt_table,%edi
-	movl $early_idt_handlers,%eax
+	movl $early_idt_handler_array,%eax
 	movl $NUM_EXCEPTION_VECTORS,%ecx
 1:
 	movl %eax,(%edi)
 	movl %eax,4(%edi)
 	/* interrupt gate, dpl=0, present */
 	movl $(0x8E000000 + __KERNEL_CS),2(%edi)
-	addl $9,%eax
+	addl $EARLY_IDT_HANDLER_SIZE,%eax
 	addl $8,%edi
 	loop 1b
 
@@ -543,26 +544,28 @@ setup_once:
 	andl $0,setup_once_ref	/* Once is enough, thanks */
 	ret
 
-ENTRY(early_idt_handlers)
+ENTRY(early_idt_handler_array)
 	# 36(%esp) %eflags
 	# 32(%esp) %cs
 	# 28(%esp) %eip
 	# 24(%rsp) error code
 	i = 0
 	.rept NUM_EXCEPTION_VECTORS
-	.if (EXCEPTION_ERRCODE_MASK >> i) & 1
-	ASM_NOP2
-	.else
+	.ifeq (EXCEPTION_ERRCODE_MASK >> i) & 1
 	pushl $0		# Dummy error code, to make stack frame uniform
 	.endif
 	pushl $i		# 20(%esp) Vector number
-	jmp early_idt_handler
+	jmp early_idt_handler_common
 	i = i + 1
+	.fill early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc
 	.endr
-ENDPROC(early_idt_handlers)
+ENDPROC(early_idt_handler_array)
 	
-	/* This is global to keep gas from relaxing the jumps */
-ENTRY(early_idt_handler)
+early_idt_handler_common:
+	/*
+	 * The stack is the hardware frame, an error code or zero, and the
+	 * vector number.
+	 */
 	cld
 
 	cmpl $2,(%esp)		# X86_TRAP_NMI
@@ -622,7 +625,7 @@ ex_entry:
 is_nmi:
 	addl $8,%esp		/* drop vector number and error code */
 	iret
-ENDPROC(early_idt_handler)
+ENDPROC(early_idt_handler_common)
 
 /* This is the default interrupt "handler" :-) */
 	ALIGN
diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S
index d9643f283b17..491e531f107c 100644
--- a/arch/x86/kernel/head_64.S
+++ b/arch/x86/kernel/head_64.S
@@ -329,26 +329,28 @@ bad_address:
 	jmp bad_address
 
 	__INIT
-	.globl early_idt_handlers
-early_idt_handlers:
+ENTRY(early_idt_handler_array)
 	# 104(%rsp) %rflags
 	#  96(%rsp) %cs
 	#  88(%rsp) %rip
 	#  80(%rsp) error code
 	i = 0
 	.rept NUM_EXCEPTION_VECTORS
-	.if (EXCEPTION_ERRCODE_MASK >> i) & 1
-	ASM_NOP2
-	.else
+	.ifeq (EXCEPTION_ERRCODE_MASK >> i) & 1
 	pushq $0		# Dummy error code, to make stack frame uniform
 	.endif
 	pushq $i		# 72(%rsp) Vector number
-	jmp early_idt_handler
+	jmp early_idt_handler_common
 	i = i + 1
+	.fill early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc
 	.endr
+ENDPROC(early_idt_handler_array)
 
-/* This is global to keep gas from relaxing the jumps */
-ENTRY(early_idt_handler)
+early_idt_handler_common:
+	/*
+	 * The stack is the hardware frame, an error code or zero, and the
+	 * vector number.
+	 */
 	cld
 
 	cmpl $2,(%rsp)		# X86_TRAP_NMI
@@ -420,7 +422,7 @@ ENTRY(early_idt_handler)
 is_nmi:
 	addq $16,%rsp		# drop vector number and error code
 	INTERRUPT_RETURN
-ENDPROC(early_idt_handler)
+ENDPROC(early_idt_handler_common)
 
 	__INITDATA
 
