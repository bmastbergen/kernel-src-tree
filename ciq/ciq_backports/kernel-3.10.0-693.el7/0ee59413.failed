x86/panic: replace smp_send_stop() with kdump friendly version in panic path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
commit 0ee59413c967c35a6dd2dbdab605b4cd42025ee5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0ee59413.failed

Daniel Walker reported problems which happens when
crash_kexec_post_notifiers kernel option is enabled
(https://lkml.org/lkml/2015/6/24/44).

In that case, smp_send_stop() is called before entering kdump routines
which assume other CPUs are still online.  As the result, for x86, kdump
routines fail to save other CPUs' registers and disable virtualization
extensions.

To fix this problem, call a new kdump friendly function,
crash_smp_send_stop(), instead of the smp_send_stop() when
crash_kexec_post_notifiers is enabled.  crash_smp_send_stop() is a weak
function, and it just call smp_send_stop().  Architecture codes should
override it so that kdump can work appropriately.  This patch only
provides x86-specific version.

For Xen's PV kernel, just keep the current behavior.

NOTES:

- Right solution would be to place crash_smp_send_stop() before
  __crash_kexec() invocation in all cases and remove smp_send_stop(), but
  we can't do that until all architectures implement own
  crash_smp_send_stop()

- crash_smp_send_stop()-like work is still needed by
  machine_crash_shutdown() because crash_kexec() can be called without
  entering panic()

Fixes: f06e5153f4ae (kernel/panic.c: add "crash_kexec_post_notifiers" option)
Link: http://lkml.kernel.org/r/20160810080948.11028.15344.stgit@sysi4-13.yrl.intra.hitachi.co.jp
	Signed-off-by: Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
	Reported-by: Daniel Walker <dwalker@fifo99.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Vivek Goyal <vgoyal@redhat.com>
	Cc: Eric Biederman <ebiederm@xmission.com>
	Cc: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Daniel Walker <dwalker@fifo99.com>
	Cc: Xunlei Pang <xpang@redhat.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: David Vrabel <david.vrabel@citrix.com>
	Cc: Toshi Kani <toshi.kani@hpe.com>
	Cc: Ralf Baechle <ralf@linux-mips.org>
	Cc: David Daney <david.daney@cavium.com>
	Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
	Cc: "Steven J. Hill" <steven.hill@cavium.com>
	Cc: Corey Minyard <cminyard@mvista.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0ee59413c967c35a6dd2dbdab605b4cd42025ee5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/panic.c
diff --cc kernel/panic.c
index f3d560562c0c,e6480e20379e..000000000000
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@@ -156,14 -187,24 +182,28 @@@ void panic(const char *fmt, ...
  	 *
  	 * Bypass the panic_cpu check and call __crash_kexec directly.
  	 */
++<<<<<<< HEAD
 +	__crash_kexec(NULL);
- 
- 	/*
- 	 * Note smp_send_stop is the usual smp shutdown function, which
- 	 * unfortunately means it may not be hardened to work in a panic
- 	 * situation.
- 	 */
- 	smp_send_stop();
++=======
+ 	if (!_crash_kexec_post_notifiers) {
+ 		printk_nmi_flush_on_panic();
+ 		__crash_kexec(NULL);
++>>>>>>> 0ee59413c967 (x86/panic: replace smp_send_stop() with kdump friendly version in panic path)
+ 
+ 		/*
+ 		 * Note smp_send_stop is the usual smp shutdown function, which
+ 		 * unfortunately means it may not be hardened to work in a
+ 		 * panic situation.
+ 		 */
+ 		smp_send_stop();
+ 	} else {
+ 		/*
+ 		 * If we want to do crash dump after notifier calls and
+ 		 * kmsg_dump, we will need architecture dependent extra
+ 		 * works in addition to stopping other CPUs.
+ 		 */
+ 		crash_smp_send_stop();
+ 	}
  
  	/*
  	 * Run any panic handlers, including those that might need to
diff --git a/arch/x86/include/asm/kexec.h b/arch/x86/include/asm/kexec.h
index 91aca015fad1..f9f9dec3eb22 100644
--- a/arch/x86/include/asm/kexec.h
+++ b/arch/x86/include/asm/kexec.h
@@ -211,6 +211,7 @@ struct kexec_entry64_regs {
 
 typedef void crash_vmclear_fn(void);
 extern crash_vmclear_fn __rcu *crash_vmclear_loaded_vmcss;
+extern void kdump_nmi_shootdown_cpus(void);
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/x86/include/asm/smp.h b/arch/x86/include/asm/smp.h
index c6a624d1c2ca..4bd7cce9a48a 100644
--- a/arch/x86/include/asm/smp.h
+++ b/arch/x86/include/asm/smp.h
@@ -69,6 +69,7 @@ struct smp_ops {
 	void (*smp_cpus_done)(unsigned max_cpus);
 
 	void (*stop_other_cpus)(int wait);
+	void (*crash_stop_other_cpus)(void);
 	void (*smp_send_reschedule)(int cpu);
 
 	int (*cpu_up)(unsigned cpu, struct task_struct *tidle);
diff --git a/arch/x86/kernel/crash.c b/arch/x86/kernel/crash.c
index 265b1c866e3c..5de7d0752c08 100644
--- a/arch/x86/kernel/crash.c
+++ b/arch/x86/kernel/crash.c
@@ -136,7 +136,7 @@ static void kdump_nmi_callback(int cpu, struct pt_regs *regs)
 	disable_local_APIC();
 }
 
-static void kdump_nmi_shootdown_cpus(void)
+void kdump_nmi_shootdown_cpus(void)
 {
 	in_crash_kexec = 1;
 	nmi_shootdown_cpus(kdump_nmi_callback);
@@ -144,8 +144,24 @@ static void kdump_nmi_shootdown_cpus(void)
 	disable_local_APIC();
 }
 
+/* Override the weak function in kernel/panic.c */
+void crash_smp_send_stop(void)
+{
+	static int cpus_stopped;
+
+	if (cpus_stopped)
+		return;
+
+	if (smp_ops.crash_stop_other_cpus)
+		smp_ops.crash_stop_other_cpus();
+	else
+		smp_send_stop();
+
+	cpus_stopped = 1;
+}
+
 #else
-static void kdump_nmi_shootdown_cpus(void)
+void crash_smp_send_stop(void)
 {
 	/* There are no cpus to shootdown */
 }
@@ -164,7 +180,7 @@ void native_machine_crash_shutdown(struct pt_regs *regs)
 	/* The kernel is broken so disable interrupts */
 	local_irq_disable();
 
-	kdump_nmi_shootdown_cpus();
+	crash_smp_send_stop();
 
 	/*
 	 * VMCLEAR VMCSs loaded on this cpu if needed.
diff --git a/arch/x86/kernel/smp.c b/arch/x86/kernel/smp.c
index c13dd515a1b4..e4024d93c4aa 100644
--- a/arch/x86/kernel/smp.c
+++ b/arch/x86/kernel/smp.c
@@ -32,6 +32,8 @@
 #include <asm/nmi.h>
 #include <asm/mce.h>
 #include <asm/trace/irq_vectors.h>
+#include <asm/kexec.h>
+
 /*
  *	Some notes on x86 processor bugs affecting SMP operation:
  *
@@ -349,6 +351,9 @@ struct smp_ops smp_ops = {
 	.smp_cpus_done		= native_smp_cpus_done,
 
 	.stop_other_cpus	= native_stop_other_cpus,
+#if defined(CONFIG_KEXEC_CORE)
+	.crash_stop_other_cpus	= kdump_nmi_shootdown_cpus,
+#endif
 	.smp_send_reschedule	= native_smp_send_reschedule,
 
 	.cpu_up			= native_cpu_up,
* Unmerged path kernel/panic.c
