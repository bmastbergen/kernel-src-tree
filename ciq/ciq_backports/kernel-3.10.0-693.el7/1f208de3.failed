x86/boot: Clean up things used by decompressors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] boot: Clean up things used by decompressors (Baoquan He) [1290840]
Rebuild_FUZZ: 95.56%
commit-author Kees Cook <keescook@chromium.org>
commit 1f208de37d10bb9067f3b061d281363be0cd1805
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1f208de3.failed

This rearranges the pieces needed to include the decompressor code
in misc.c. It wasn't obvious why things were there, so a comment was
added and definitions consolidated.

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: H.J. Lu <hjl.tools@gmail.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Yinghai Lu <yinghai@kernel.org>
Link: http://lkml.kernel.org/r/1461185746-8017-4-git-send-email-keescook@chromium.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1f208de37d10bb9067f3b061d281363be0cd1805)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/misc.c
diff --cc arch/x86/boot/compressed/misc.c
index 136cb407d4ef,0381e250a785..000000000000
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@@ -12,96 -14,18 +12,98 @@@
  #include "misc.h"
  #include "../string.h"
  
 +/* WARNING!!
 + * This code is compiled with -fPIC and it is relocated dynamically
 + * at run time, but no relocation processing is performed.
 + * This means that it is not safe to place pointers in static structures.
 + */
 +
++<<<<<<< HEAD
  /*
 - * WARNING!!
 - * This code is compiled with -fPIC and it is relocated dynamically at
 - * run time, but no relocation processing is performed. This means that
 - * it is not safe to place pointers in static structures.
 + * Getting to provable safe in place decompression is hard.
 + * Worst case behaviours need to be analyzed.
 + * Background information:
 + *
 + * The file layout is:
 + *    magic[2]
 + *    method[1]
 + *    flags[1]
 + *    timestamp[4]
 + *    extraflags[1]
 + *    os[1]
 + *    compressed data blocks[N]
 + *    crc[4] orig_len[4]
 + *
 + * resulting in 18 bytes of non compressed data overhead.
 + *
 + * Files divided into blocks
 + * 1 bit (last block flag)
 + * 2 bits (block type)
 + *
 + * 1 block occurs every 32K -1 bytes or when there 50% compression
 + * has been achieved. The smallest block type encoding is always used.
 + *
 + * stored:
 + *    32 bits length in bytes.
 + *
 + * fixed:
 + *    magic fixed tree.
 + *    symbols.
 + *
 + * dynamic:
 + *    dynamic tree encoding.
 + *    symbols.
 + *
 + *
 + * The buffer for decompression in place is the length of the
 + * uncompressed data, plus a small amount extra to keep the algorithm safe.
 + * The compressed data is placed at the end of the buffer.  The output
 + * pointer is placed at the start of the buffer and the input pointer
 + * is placed where the compressed data starts.  Problems will occur
 + * when the output pointer overruns the input pointer.
 + *
 + * The output pointer can only overrun the input pointer if the input
 + * pointer is moving faster than the output pointer.  A condition only
 + * triggered by data whose compressed form is larger than the uncompressed
 + * form.
 + *
 + * The worst case at the block level is a growth of the compressed data
 + * of 5 bytes per 32767 bytes.
 + *
 + * The worst case internal to a compressed block is very hard to figure.
 + * The worst case can at least be boundined by having one bit that represents
 + * 32764 bytes and then all of the rest of the bytes representing the very
 + * very last byte.
 + *
 + * All of which is enough to compute an amount of extra data that is required
 + * to be safe.  To avoid problems at the block level allocating 5 extra bytes
 + * per 32767 bytes of data is sufficient.  To avoind problems internal to a
 + * block adding an extra 32767 bytes (the worst case uncompressed block size)
 + * is sufficient, to ensure that in the worst case the decompressed data for
 + * block will stop the byte before the compressed data for a block begins.
 + * To avoid problems with the compressed data's meta information an extra 18
 + * bytes are needed.  Leading to the formula:
 + *
 + * extra_bytes = (uncompressed_size >> 12) + 32768 + 18 + decompressor_size.
 + *
 + * Adding 8 bytes per 32K is a bit excessive but much easier to calculate.
 + * Adding 32768 instead of 32767 just makes for round numbers.
 + * Adding the decompressor_size is necessary as it musht live after all
 + * of the data as well.  Last I measured the decompressor is about 14K.
 + * 10K of actual data and 4K of bss.
 + *
   */
  
 +/*
 + * gzip declarations
 + */
++=======
+ /* Macros used by the included decompressor code below. */
++>>>>>>> 1f208de37d10 (x86/boot: Clean up things used by decompressors)
  #define STATIC		static
  
- #undef memcpy
- 
  /*
-  * Use a normal definition of memset() from string.c. There are already
+  * Use normal definitions of mem*() from string.c. There are already
   * included header files which expect a definition of memset() and by
   * the time we define memset macro, it is too late.
   */
* Unmerged path arch/x86/boot/compressed/misc.c
