qed*: Add and modify some prints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Yuval Mintz <Yuval.Mintz@qlogic.com>
commit 525ef5c07f187bf0918fdf3bbc76ad18ce1d1cf9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/525ef5c0.failed

This patch touches various prints in the driver - it reduces the
verbosity of some prints [which were previously logged by default]
while adding several new debug prints and modifying others.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 525ef5c07f187bf0918fdf3bbc76ad18ce1d1cf9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qede/qede_main.c
diff --cc drivers/net/ethernet/qlogic/qede/qede_main.c
index 41541a7ad888,5ce8a3c9ed6f..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_main.c
@@@ -258,9 -253,10 +258,10 @@@ int __init qede_init(void
  
  static void __exit qede_cleanup(void)
  {
- 	pr_notice("qede_cleanup called\n");
+ 	if (debug & QED_LOG_INFO_MASK)
+ 		pr_info("qede_cleanup called\n");
  
 -	unregister_netdevice_notifier(&qede_netdev_notifier);
 +	unregister_netdevice_notifier_rh(&qede_netdev_notifier);
  	pci_unregister_driver(&qede_pci_driver);
  	qed_put_eth_ops();
  }
@@@ -2122,75 -2118,75 +2123,127 @@@ int qede_set_features(struct net_devic
  	return 0;
  }
  
 -static void qede_udp_tunnel_add(struct net_device *dev,
 -				struct udp_tunnel_info *ti)
 +#ifdef CONFIG_QEDE_VXLAN
 +static void qede_add_vxlan_port(struct net_device *dev,
 +				sa_family_t sa_family, __be16 port)
  {
  	struct qede_dev *edev = netdev_priv(dev);
 -	u16 t_port = ntohs(ti->port);
 +	u16 t_port = ntohs(port);
  
++<<<<<<< HEAD
 +	if (edev->vxlan_dst_port)
++=======
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		if (edev->vxlan_dst_port)
+ 			return;
+ 
+ 		edev->vxlan_dst_port = t_port;
+ 
+ 		DP_VERBOSE(edev, QED_MSG_DEBUG, "Added vxlan port=%d\n",
+ 			   t_port);
+ 
+ 		set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (edev->geneve_dst_port)
+ 			return;
+ 
+ 		edev->geneve_dst_port = t_port;
+ 
+ 		DP_VERBOSE(edev, QED_MSG_DEBUG, "Added geneve port=%d\n",
+ 			   t_port);
+ 		set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
+ 		break;
+ 	default:
++>>>>>>> 525ef5c07f18 (qed*: Add and modify some prints)
  		return;
 -	}
  
 +	edev->vxlan_dst_port = t_port;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Added vxlan port=%d", t_port);
 +
 +	set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
  	schedule_delayed_work(&edev->sp_task, 0);
  }
  
 -static void qede_udp_tunnel_del(struct net_device *dev,
 -				struct udp_tunnel_info *ti)
 +static void qede_del_vxlan_port(struct net_device *dev,
 +				sa_family_t sa_family, __be16 port)
  {
  	struct qede_dev *edev = netdev_priv(dev);
 -	u16 t_port = ntohs(ti->port);
 +	u16 t_port = ntohs(port);
  
++<<<<<<< HEAD
 +	if (t_port != edev->vxlan_dst_port)
++=======
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		if (t_port != edev->vxlan_dst_port)
+ 			return;
+ 
+ 		edev->vxlan_dst_port = 0;
+ 
+ 		DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted vxlan port=%d\n",
+ 			   t_port);
+ 
+ 		set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (t_port != edev->geneve_dst_port)
+ 			return;
+ 
+ 		edev->geneve_dst_port = 0;
+ 
+ 		DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted geneve port=%d\n",
+ 			   t_port);
+ 		set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
+ 		break;
+ 	default:
++>>>>>>> 525ef5c07f18 (qed*: Add and modify some prints)
  		return;
 -	}
  
 +	edev->vxlan_dst_port = 0;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted vxlan port=%d", t_port);
 +
 +	set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
  	schedule_delayed_work(&edev->sp_task, 0);
  }
 +#endif
 +
 +#ifdef CONFIG_QEDE_GENEVE
 +static void qede_add_geneve_port(struct net_device *dev,
 +				 sa_family_t sa_family, __be16 port)
 +{
 +	struct qede_dev *edev = netdev_priv(dev);
 +	u16 t_port = ntohs(port);
 +
 +	if (edev->geneve_dst_port)
 +		return;
 +
 +	edev->geneve_dst_port = t_port;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Added geneve port=%d", t_port);
 +	set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
 +	schedule_delayed_work(&edev->sp_task, 0);
 +}
 +
 +static void qede_del_geneve_port(struct net_device *dev,
 +				 sa_family_t sa_family, __be16 port)
 +{
 +	struct qede_dev *edev = netdev_priv(dev);
 +	u16 t_port = ntohs(port);
 +
 +	if (t_port != edev->geneve_dst_port)
 +		return;
 +
 +	edev->geneve_dst_port = 0;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted geneve port=%d", t_port);
 +	set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
 +	schedule_delayed_work(&edev->sp_task, 0);
 +}
 +#endif
  
  static const struct net_device_ops qede_netdev_ops = {
  	.ndo_open = qede_open,
diff --git a/drivers/net/ethernet/qlogic/qed/qed_dev.c b/drivers/net/ethernet/qlogic/qed/qed_dev.c
index 1371ea07f876..8117ddff501b 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@ -1206,7 +1206,7 @@ static int qed_reg_assert(struct qed_hwfn *p_hwfn,
 	u32 assert_val = qed_rd(p_hwfn, p_ptt, reg);
 
 	if (assert_val != expected) {
-		DP_NOTICE(p_hwfn, "Value at address 0x%x != 0x%08x\n",
+		DP_NOTICE(p_hwfn, "Value at address 0x%08x != 0x%08x\n",
 			  reg, expected);
 		return -EINVAL;
 	}
@@ -1306,6 +1306,10 @@ static void get_function_id(struct qed_hwfn *p_hwfn)
 				      PXP_CONCRETE_FID_PFID);
 	p_hwfn->port_id = GET_FIELD(p_hwfn->hw_info.concrete_fid,
 				    PXP_CONCRETE_FID_PORT);
+
+	DP_VERBOSE(p_hwfn, NETIF_MSG_PROBE,
+		   "Read ME register: Concrete 0x%08x Opaque 0x%04x\n",
+		   p_hwfn->hw_info.concrete_fid, p_hwfn->hw_info.opaque_fid);
 }
 
 static void qed_hw_set_feat(struct qed_hwfn *p_hwfn)
@@ -1605,10 +1609,10 @@ static void qed_get_num_funcs(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
 
 	DP_VERBOSE(p_hwfn,
 		   NETIF_MSG_PROBE,
-		   "PF [rel_id %d, abs_id %d] within the %d enabled functions on the engine\n",
+		   "PF [rel_id %d, abs_id %d] occupies index %d within the %d enabled functions on the engine\n",
 		   p_hwfn->rel_pf_id,
 		   p_hwfn->abs_pf_id,
-		   p_hwfn->num_funcs_on_engine);
+		   p_hwfn->enabled_func_idx, p_hwfn->num_funcs_on_engine);
 }
 
 static int
diff --git a/drivers/net/ethernet/qlogic/qed/qed_int.c b/drivers/net/ethernet/qlogic/qed/qed_int.c
index a701b7640e7c..61ec973a06c7 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_int.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_int.c
@@ -2576,8 +2576,12 @@ static u16 qed_get_igu_sb_id(struct qed_hwfn *p_hwfn, u16 sb_id)
 	else
 		igu_sb_id = qed_vf_get_igu_sb_id(p_hwfn, sb_id);
 
-	DP_VERBOSE(p_hwfn, NETIF_MSG_INTR, "SB [%s] index is 0x%04x\n",
-		   (sb_id == QED_SP_SB_ID) ? "DSB" : "non-DSB", igu_sb_id);
+	if (sb_id == QED_SP_SB_ID)
+		DP_VERBOSE(p_hwfn, NETIF_MSG_INTR,
+			   "Slowpath SB index in IGU is 0x%04x\n", igu_sb_id);
+	else
+		DP_VERBOSE(p_hwfn, NETIF_MSG_INTR,
+			   "SB [%04x] <--> IGU SB [%04x]\n", sb_id, igu_sb_id);
 
 	return igu_sb_id;
 }
diff --git a/drivers/net/ethernet/qlogic/qed/qed_main.c b/drivers/net/ethernet/qlogic/qed/qed_main.c
index b788750ea451..c16af37d7293 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -51,8 +51,6 @@ MODULE_FIRMWARE(QED_FW_FILE_NAME);
 
 static int __init qed_init(void)
 {
-	pr_notice("qed_init called\n");
-
 	pr_info("%s", version);
 
 	return 0;
@@ -437,6 +435,11 @@ static int qed_set_int_mode(struct qed_dev *cdev, bool force_mode)
 	}
 
 out:
+	if (!rc)
+		DP_INFO(cdev, "Using %s interrupts\n",
+			int_params->out.int_mode == QED_INT_MODE_INTA ?
+			"INTa" : int_params->out.int_mode == QED_INT_MODE_MSI ?
+			"MSI" : "MSIX");
 	cdev->int_coalescing_mode = QED_COAL_MODE_ENABLE;
 
 	return rc;
@@ -512,19 +515,18 @@ static irqreturn_t qed_single_int(int irq, void *dev_instance)
 int qed_slowpath_irq_req(struct qed_hwfn *hwfn)
 {
 	struct qed_dev *cdev = hwfn->cdev;
+	u32 int_mode;
 	int rc = 0;
 	u8 id;
 
-	if (cdev->int_params.out.int_mode == QED_INT_MODE_MSIX) {
+	int_mode = cdev->int_params.out.int_mode;
+	if (int_mode == QED_INT_MODE_MSIX) {
 		id = hwfn->my_id;
 		snprintf(hwfn->name, NAME_SIZE, "sp-%d-%02x:%02x.%02x",
 			 id, cdev->pdev->bus->number,
 			 PCI_SLOT(cdev->pdev->devfn), hwfn->abs_pf_id);
 		rc = request_irq(cdev->int_params.msix_table[id].vector,
 				 qed_msix_sp_int, 0, hwfn->name, hwfn->sp_dpc);
-		if (!rc)
-			DP_VERBOSE(hwfn, (NETIF_MSG_INTR | QED_MSG_SP),
-				   "Requested slowpath MSI-X\n");
 	} else {
 		unsigned long flags = 0;
 
@@ -539,6 +541,13 @@ int qed_slowpath_irq_req(struct qed_hwfn *hwfn)
 				 flags, cdev->name, cdev);
 	}
 
+	if (rc)
+		DP_NOTICE(cdev, "request_irq failed, rc = %d\n", rc);
+	else
+		DP_VERBOSE(hwfn, (NETIF_MSG_INTR | QED_MSG_SP),
+			   "Requested slowpath %s\n",
+			   (int_mode == QED_INT_MODE_MSIX) ? "MSI-X" : "IRQ");
+
 	return rc;
 }
 
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.c b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 0a676db02c8a..88b448bb2949 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@ -317,7 +317,8 @@ static int qed_do_mcp_cmd(struct qed_hwfn *p_hwfn,
 		*o_mcp_param = DRV_MB_RD(p_hwfn, p_ptt, fw_mb_param);
 	} else {
 		/* FW BUG! */
-		DP_ERR(p_hwfn, "MFW failed to respond!\n");
+		DP_ERR(p_hwfn, "MFW failed to respond [cmd 0x%x param 0x%x]\n",
+		       cmd, param);
 		*o_mcp_resp = 0;
 		rc = -EAGAIN;
 	}
@@ -333,7 +334,7 @@ static int qed_mcp_cmd_and_union(struct qed_hwfn *p_hwfn,
 
 	/* MCP not initialized */
 	if (!qed_mcp_is_init(p_hwfn)) {
-		DP_NOTICE(p_hwfn, "MFW is not initialized !\n");
+		DP_NOTICE(p_hwfn, "MFW is not initialized!\n");
 		return -EBUSY;
 	}
 
@@ -935,7 +936,7 @@ int qed_mcp_get_media_type(struct qed_dev *cdev, u32 *p_media_type)
 		return -EINVAL;
 
 	if (!qed_mcp_is_init(p_hwfn)) {
-		DP_NOTICE(p_hwfn, "MFW is not initialized !\n");
+		DP_NOTICE(p_hwfn, "MFW is not initialized!\n");
 		return -EBUSY;
 	}
 
diff --git a/drivers/net/ethernet/qlogic/qed/qed_spq.c b/drivers/net/ethernet/qlogic/qed/qed_spq.c
index 5e68a33b2097..0265a32c8681 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_spq.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_spq.c
@@ -824,15 +824,22 @@ int qed_spq_completion(struct qed_hwfn *p_hwfn,
 
 	if (!found) {
 		DP_NOTICE(p_hwfn,
-			  "Failed to find an entry this EQE completes\n");
+			  "Failed to find an entry this EQE [echo %04x] completes\n",
+			  le16_to_cpu(echo));
 		return -EEXIST;
 	}
 
-	DP_VERBOSE(p_hwfn, QED_MSG_SPQ, "Complete: func %p cookie %p)\n",
+	DP_VERBOSE(p_hwfn, QED_MSG_SPQ,
+		   "Complete EQE [echo %04x]: func %p cookie %p)\n",
+		   le16_to_cpu(echo),
 		   p_ent->comp_cb.function, p_ent->comp_cb.cookie);
 	if (found->comp_cb.function)
 		found->comp_cb.function(p_hwfn, found->comp_cb.cookie, p_data,
 					fw_return_code);
+	else
+		DP_VERBOSE(p_hwfn,
+			   QED_MSG_SPQ,
+			   "Got a completion without a callback function\n");
 
 	if ((found->comp_mode != QED_SPQ_MODE_EBLOCK) ||
 	    (found->queue == &p_spq->unlimited_pending))
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_main.c
