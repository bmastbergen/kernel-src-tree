perf tools: Add time-based utility functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Ahern <dsa@cumulusnetworks.com>
commit fdf9dc4b34f5f40919370c4601eccfd0db726aa5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fdf9dc4b.failed

Add function to parse a user time string of the form <start>,<stop>
where start and stop are time in sec.nsec format. Both start and stop
times are optional.

Add function to determine if a sample time is within a given time
time window of interest.

	Signed-off-by: David Ahern <dsahern@gmail.com>
	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1480439746-42695-2-git-send-email-dsahern@gmail.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit fdf9dc4b34f5f40919370c4601eccfd0db726aa5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/Build
diff --cc tools/perf/util/Build
index 09bbe84a21c0,bdad82a9812d..000000000000
--- a/tools/perf/util/Build
+++ b/tools/perf/util/Build
@@@ -83,7 -85,12 +83,13 @@@ libperf-y += parse-regs-options.
  libperf-y += term.o
  libperf-y += help-unknown-cmd.o
  libperf-y += mem-events.o
++<<<<<<< HEAD
++=======
+ libperf-y += vsprintf.o
+ libperf-y += drv_configs.o
+ libperf-y += time-utils.o
++>>>>>>> fdf9dc4b34f5 (perf tools: Add time-based utility functions)
  
 -libperf-$(CONFIG_LIBBPF) += bpf-loader.o
 -libperf-$(CONFIG_BPF_PROLOGUE) += bpf-prologue.o
  libperf-$(CONFIG_LIBELF) += symbol-elf.o
  libperf-$(CONFIG_LIBELF) += probe-file.o
  libperf-$(CONFIG_LIBELF) += probe-event.o
* Unmerged path tools/perf/util/Build
diff --git a/tools/perf/util/time-utils.c b/tools/perf/util/time-utils.c
new file mode 100644
index 000000000000..0443b2afd0cf
--- /dev/null
+++ b/tools/perf/util/time-utils.c
@@ -0,0 +1,85 @@
+#include <string.h>
+#include <sys/time.h>
+#include <time.h>
+#include <errno.h>
+#include <inttypes.h>
+
+#include "perf.h"
+#include "debug.h"
+#include "time-utils.h"
+#include "util.h"
+
+static int parse_timestr_sec_nsec(struct perf_time_interval *ptime,
+				  char *start_str, char *end_str)
+{
+	if (start_str && (*start_str != '\0') &&
+	    (parse_nsec_time(start_str, &ptime->start) != 0)) {
+		return -1;
+	}
+
+	if (end_str && (*end_str != '\0') &&
+	    (parse_nsec_time(end_str, &ptime->end) != 0)) {
+		return -1;
+	}
+
+	return 0;
+}
+
+int perf_time__parse_str(struct perf_time_interval *ptime, const char *ostr)
+{
+	char *start_str, *end_str;
+	char *d, *str;
+	int rc = 0;
+
+	if (ostr == NULL || *ostr == '\0')
+		return 0;
+
+	/* copy original string because we need to modify it */
+	str = strdup(ostr);
+	if (str == NULL)
+		return -ENOMEM;
+
+	ptime->start = 0;
+	ptime->end = 0;
+
+	/* str has the format: <start>,<stop>
+	 * variations: <start>,
+	 *             ,<stop>
+	 *             ,
+	 */
+	start_str = str;
+	d = strchr(start_str, ',');
+	if (d) {
+		*d = '\0';
+		++d;
+	}
+	end_str = d;
+
+	rc = parse_timestr_sec_nsec(ptime, start_str, end_str);
+
+	free(str);
+
+	/* make sure end time is after start time if it was given */
+	if (rc == 0 && ptime->end && ptime->end < ptime->start)
+		return -EINVAL;
+
+	pr_debug("start time %" PRIu64 ", ", ptime->start);
+	pr_debug("end time %" PRIu64 "\n", ptime->end);
+
+	return rc;
+}
+
+bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp)
+{
+	/* if time is not set don't drop sample */
+	if (timestamp == 0)
+		return false;
+
+	/* otherwise compare sample time to time window */
+	if ((ptime->start && timestamp < ptime->start) ||
+	    (ptime->end && timestamp > ptime->end)) {
+		return true;
+	}
+
+	return false;
+}
diff --git a/tools/perf/util/time-utils.h b/tools/perf/util/time-utils.h
new file mode 100644
index 000000000000..8f3e0e370be8
--- /dev/null
+++ b/tools/perf/util/time-utils.h
@@ -0,0 +1,12 @@
+#ifndef _TIME_UTILS_H_
+#define _TIME_UTILS_H_
+
+struct perf_time_interval {
+	u64 start, end;
+};
+
+int perf_time__parse_str(struct perf_time_interval *ptime, const char *ostr);
+
+bool perf_time__skip_sample(struct perf_time_interval *ptime, u64 timestamp);
+
+#endif
