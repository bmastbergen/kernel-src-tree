ACPICA: Table Manager: Misc cleanup and renames, no functional change.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [acpi] acpica: table manager: Misc cleanup and renames, no functional change (Prarit Bhargava) [1425180]
Rebuild_FUZZ: 99.28%
commit-author Bob Moore <robert.moore@intel.com>
commit ed6f1d44dae8a4eec42a74acae95cc177ee2e1ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ed6f1d44.failed

Some various cleanups and renames.

	Signed-off-by: Bob Moore <robert.moore@intel.com>
	Signed-off-by: Lv Zheng <lv.zheng@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit ed6f1d44dae8a4eec42a74acae95cc177ee2e1ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpica/actables.h
#	drivers/acpi/acpica/exconfig.c
#	drivers/acpi/acpica/tbinstal.c
#	drivers/acpi/acpica/tbutils.c
#	drivers/acpi/acpica/tbxface.c
#	drivers/acpi/acpica/tbxfload.c
#	include/acpi/actbl.h
diff --cc drivers/acpi/acpica/actables.h
index 917315ec21dd,ade430c6004f..000000000000
--- a/drivers/acpi/acpica/actables.h
+++ b/drivers/acpi/acpica/actables.h
@@@ -70,15 -72,28 +70,35 @@@ acpi_tb_find_table(char *signature
   */
  acpi_status acpi_tb_resize_root_table_list(void);
  
 -acpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc);
 +acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc);
  
 -void acpi_tb_invalidate_table(struct acpi_table_desc *table_desc);
 +struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 +						 *table_header,
 +						 struct acpi_table_desc
 +						 *table_desc);
  
  acpi_status
++<<<<<<< HEAD
 +acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index);
++=======
+ acpi_tb_verify_table(struct acpi_table_desc *table_desc, char *signature);
+ 
+ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc);
+ 
+ acpi_status
+ acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
+ 		      struct acpi_table_header **table_ptr,
+ 		      u32 *table_length, u8 *table_flags);
+ 
+ void
+ acpi_tb_release_table(struct acpi_table_header *table,
+ 		      u32 table_length, u8 table_flags);
+ 
+ acpi_status
+ acpi_tb_install_standard_table(acpi_physical_address address,
+ 			       u8 flags,
+ 			       u8 reload, u8 override, u32 *table_index);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  
  acpi_status
  acpi_tb_store_table(acpi_physical_address address,
@@@ -122,8 -137,18 +142,23 @@@ void acpi_tb_check_dsdt_header(void)
  struct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index);
  
  void
++<<<<<<< HEAD
 +acpi_tb_install_table(acpi_physical_address address,
 +		      char *signature, u32 table_index);
++=======
+ acpi_tb_init_table_descriptor(struct acpi_table_desc *table_desc,
+ 			      acpi_physical_address address,
+ 			      u8 flags, struct acpi_table_header *table);
+ 
+ void
+ acpi_tb_install_table_with_override(u32 table_index,
+ 				    struct acpi_table_desc *new_table_desc,
+ 				    u8 override);
+ 
+ acpi_status
+ acpi_tb_install_fixed_table(acpi_physical_address address,
+ 			    char *signature, u32 table_index);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  
  acpi_status acpi_tb_parse_root_table(acpi_physical_address rsdp_address);
  
diff --cc drivers/acpi/acpica/exconfig.c
index 5bff332aa0f0,7d2949420db7..000000000000
--- a/drivers/acpi/acpica/exconfig.c
+++ b/drivers/acpi/acpica/exconfig.c
@@@ -484,22 -478,16 +484,33 @@@ acpi_ex_load_op(union acpi_operand_obje
  		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
  	}
  
 +	/* Validate table checksum (will not get validated in tb_add_table) */
 +
 +	status = acpi_tb_verify_checksum(table_desc.pointer, length);
 +	if (ACPI_FAILURE(status)) {
 +		ACPI_FREE(table_desc.pointer);
 +		return_ACPI_STATUS(status);
 +	}
 +
 +	/* Complete the table descriptor */
 +
 +	table_desc.length = length;
 +	table_desc.flags = ACPI_TABLE_ORIGIN_ALLOCATED;
 +
  	/* Install the new table into the local data structures */
  
++<<<<<<< HEAD
 +	status = acpi_tb_add_table(&table_desc, &table_index);
++=======
+ 	ACPI_INFO((AE_INFO, "Dynamic OEM Table Load:"));
+ 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+ 
+ 	status = acpi_tb_install_standard_table(ACPI_PTR_TO_PHYSADDR(table),
+ 						ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL,
+ 						TRUE, TRUE, &table_index);
+ 
+ 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  	if (ACPI_FAILURE(status)) {
  
  		/* Delete allocated table buffer */
diff --cc drivers/acpi/acpica/tbinstal.c
index 4024bfc5fa21,50a6f229633c..000000000000
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@@ -49,6 -49,173 +49,176 @@@
  #define _COMPONENT          ACPI_TABLES
  ACPI_MODULE_NAME("tbinstal")
  
++<<<<<<< HEAD
++=======
+ /* Local prototypes */
+ static acpi_status
+ acpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,
+ 			   acpi_physical_address address, u8 flags);
+ 
+ static void acpi_tb_release_temp_table(struct acpi_table_desc *table_desc);
+ 
+ static acpi_status acpi_tb_get_root_table_entry(u32 *table_index);
+ 
+ static u8
+ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc,
+ 			    u32 table_index);
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_acquire_table
+  *
+  * PARAMETERS:  table_desc          - Table descriptor
+  *              table_ptr           - Where table is returned
+  *              table_length        - Where table length is returned
+  *              table_flags         - Where table allocation flags are returned
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Acquire an ACPI table. It can be used for tables not
+  *              maintained in the acpi_gbl_root_table_list.
+  *
+  ******************************************************************************/
+ 
+ acpi_status
+ acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
+ 		      struct acpi_table_header **table_ptr,
+ 		      u32 *table_length, u8 *table_flags)
+ {
+ 	struct acpi_table_header *table = NULL;
+ 
+ 	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
+ 	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
+ 
+ 		table =
+ 		    acpi_os_map_memory(table_desc->address, table_desc->length);
+ 		break;
+ 
+ 	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+ 	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
+ 
+ 		table =
+ 		    ACPI_CAST_PTR(struct acpi_table_header,
+ 				  table_desc->address);
+ 		break;
+ 
+ 	default:
+ 
+ 		break;
+ 	}
+ 
+ 	/* Table is not valid yet */
+ 
+ 	if (!table) {
+ 		return (AE_NO_MEMORY);
+ 	}
+ 
+ 	/* Fill the return values */
+ 
+ 	*table_ptr = table;
+ 	*table_length = table_desc->length;
+ 	*table_flags = table_desc->flags;
+ 	return (AE_OK);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_release_table
+  *
+  * PARAMETERS:  table               - Pointer for the table
+  *              table_length        - Length for the table
+  *              table_flags         - Allocation flags for the table
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Release a table. The inverse of acpi_tb_acquire_table().
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_tb_release_table(struct acpi_table_header *table,
+ 		      u32 table_length, u8 table_flags)
+ {
+ 
+ 	switch (table_flags & ACPI_TABLE_ORIGIN_MASK) {
+ 	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
+ 
+ 		acpi_os_unmap_memory(table, table_length);
+ 		break;
+ 
+ 	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+ 	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
+ 	default:
+ 
+ 		break;
+ 	}
+ }
+ 
+ /******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_validate_table
+  *
+  * PARAMETERS:  table_desc          - Table descriptor
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: This function is called to validate the table, the returned
+  *              table descriptor is in "VALIDATED" state.
+  *
+  *****************************************************************************/
+ 
+ acpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc)
+ {
+ 	acpi_status status = AE_OK;
+ 
+ 	ACPI_FUNCTION_TRACE(tb_validate_table);
+ 
+ 	/* Validate the table if necessary */
+ 
+ 	if (!table_desc->pointer) {
+ 		status = acpi_tb_acquire_table(table_desc, &table_desc->pointer,
+ 					       &table_desc->length,
+ 					       &table_desc->flags);
+ 		if (!table_desc->pointer) {
+ 			status = AE_NO_MEMORY;
+ 		}
+ 	}
+ 
+ 	return_ACPI_STATUS(status);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_invalidate_table
+  *
+  * PARAMETERS:  table_desc          - Table descriptor
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Invalidate one internal ACPI table, this is the inverse of
+  *              acpi_tb_validate_table().
+  *
+  ******************************************************************************/
+ 
+ void acpi_tb_invalidate_table(struct acpi_table_desc *table_desc)
+ {
+ 
+ 	ACPI_FUNCTION_TRACE(tb_invalidate_table);
+ 
+ 	/* Table must be validated */
+ 
+ 	if (!table_desc->pointer) {
+ 		return_VOID;
+ 	}
+ 
+ 	acpi_tb_release_table(table_desc->pointer, table_desc->length,
+ 			      table_desc->flags);
+ 	table_desc->pointer = NULL;
+ 
+ 	return_VOID;
+ }
+ 
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  /******************************************************************************
   *
   * FUNCTION:    acpi_tb_verify_table
@@@ -112,148 -278,437 +282,505 @@@ acpi_status acpi_tb_verify_table(struc
  
  /*******************************************************************************
   *
++<<<<<<< HEAD
 + * FUNCTION:    acpi_tb_add_table
 + *
 + * PARAMETERS:  table_desc          - Table descriptor
++=======
+  * FUNCTION:    acpi_tb_init_table_descriptor
+  *
+  * PARAMETERS:  table_desc              - Table descriptor
+  *              address                 - Physical address of the table
+  *              flags                   - Allocation flags of the table
+  *              table                   - Pointer to the table
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Initialize a new table descriptor
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_tb_init_table_descriptor(struct acpi_table_desc *table_desc,
+ 			      acpi_physical_address address,
+ 			      u8 flags, struct acpi_table_header *table)
+ {
+ 
+ 	/*
+ 	 * Initialize the table descriptor. Set the pointer to NULL, since the
+ 	 * table is not fully mapped at this time.
+ 	 */
+ 	ACPI_MEMSET(table_desc, 0, sizeof(struct acpi_table_desc));
+ 	table_desc->address = address;
+ 	table_desc->length = table->length;
+ 	table_desc->flags = flags;
+ 	ACPI_MOVE_32_TO_32(table_desc->signature.ascii, table->signature);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_acquire_temp_table
+  *
+  * PARAMETERS:  table_desc          - Table descriptor to be acquired
+  *              address             - Address of the table
+  *              flags               - Allocation flags of the table
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: This function validates the table header to obtain the length
+  *              of a table and fills the table descriptor to make its state as
+  *              "INSTALLED". Such a table descriptor is only used for verified
+  *              installation.
+  *
+  ******************************************************************************/
+ 
+ static acpi_status
+ acpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,
+ 			   acpi_physical_address address, u8 flags)
+ {
+ 	struct acpi_table_header *table_header;
+ 
+ 	switch (flags & ACPI_TABLE_ORIGIN_MASK) {
+ 	case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
+ 
+ 		/* Get the length of the full table from the header */
+ 
+ 		table_header =
+ 		    acpi_os_map_memory(address,
+ 				       sizeof(struct acpi_table_header));
+ 		if (!table_header) {
+ 			return (AE_NO_MEMORY);
+ 		}
+ 
+ 		acpi_tb_init_table_descriptor(table_desc, address, flags,
+ 					      table_header);
+ 		acpi_os_unmap_memory(table_header,
+ 				     sizeof(struct acpi_table_header));
+ 		return (AE_OK);
+ 
+ 	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+ 	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
+ 
+ 		table_header = ACPI_CAST_PTR(struct acpi_table_header, address);
+ 		if (!table_header) {
+ 			return (AE_NO_MEMORY);
+ 		}
+ 
+ 		acpi_tb_init_table_descriptor(table_desc, address, flags,
+ 					      table_header);
+ 		return (AE_OK);
+ 
+ 	default:
+ 
+ 		break;
+ 	}
+ 
+ 	/* Table is not valid yet */
+ 
+ 	return (AE_NO_MEMORY);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_release_temp_table
+  *
+  * PARAMETERS:  table_desc          - Table descriptor to be released
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: The inverse of acpi_tb_acquire_temp_table().
+  *
+  ******************************************************************************/
+ 
+ static void acpi_tb_release_temp_table(struct acpi_table_desc *table_desc)
+ {
+ 
+ 	/*
+ 	 * Note that the .Address is maintained by the callers of
+ 	 * acpi_tb_acquire_temp_table(), thus do not invoke acpi_tb_uninstall_table()
+ 	 * where .Address will be freed.
+ 	 */
+ 	acpi_tb_invalidate_table(table_desc);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_install_table_with_override
+  *
+  * PARAMETERS:  table_index             - Index into root table array
+  *              new_table_desc          - New table descriptor to install
+  *              override                - Whether override should be performed
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Install an ACPI table into the global data structure. The
+  *              table override mechanism is called to allow the host
+  *              OS to replace any table before it is installed in the root
+  *              table array.
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_tb_install_table_with_override(u32 table_index,
+ 				    struct acpi_table_desc *new_table_desc,
+ 				    u8 override)
+ {
+ 
+ 	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * ACPI Table Override:
+ 	 *
+ 	 * Before we install the table, let the host OS override it with a new
+ 	 * one if desired. Any table within the RSDT/XSDT can be replaced,
+ 	 * including the DSDT which is pointed to by the FADT.
+ 	 */
+ 	if (override) {
+ 		acpi_tb_override_table(new_table_desc);
+ 	}
+ 
+ 	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.
+ 				      tables[table_index],
+ 				      new_table_desc->address,
+ 				      new_table_desc->flags,
+ 				      new_table_desc->pointer);
+ 
+ 	acpi_tb_print_table_header(new_table_desc->address,
+ 				   new_table_desc->pointer);
+ 
+ 	/* Set the global integer width (based upon revision of the DSDT) */
+ 
+ 	if (table_index == ACPI_TABLE_INDEX_DSDT) {
+ 		acpi_ut_set_integer_width(new_table_desc->pointer->revision);
+ 	}
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_install_fixed_table
+  *
+  * PARAMETERS:  address                 - Physical address of DSDT or FACS
+  *              signature               - Table signature, NULL if no need to
+  *                                        match
+  *              table_index             - Index into root table array
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Install a fixed ACPI table (DSDT/FACS) into the global data
+  *              structure.
+  *
+  ******************************************************************************/
+ 
+ acpi_status
+ acpi_tb_install_fixed_table(acpi_physical_address address,
+ 			    char *signature, u32 table_index)
+ {
+ 	struct acpi_table_desc new_table_desc;
+ 	acpi_status status;
+ 
+ 	ACPI_FUNCTION_TRACE(tb_install_fixed_table);
+ 
+ 	if (!address) {
+ 		ACPI_ERROR((AE_INFO,
+ 			    "Null physical address for ACPI table [%s]",
+ 			    signature));
+ 		return (AE_NO_MEMORY);
+ 	}
+ 
+ 	/* Fill a table descriptor for validation */
+ 
+ 	status = acpi_tb_acquire_temp_table(&new_table_desc, address,
+ 					    ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
+ 	if (ACPI_FAILURE(status)) {
+ 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
+ 			    ACPI_CAST_PTR(void, address)));
+ 		return_ACPI_STATUS(status);
+ 	}
+ 
+ 	/* Validate and verify a table before installation */
+ 
+ 	status = acpi_tb_verify_table(&new_table_desc, signature);
+ 	if (ACPI_FAILURE(status)) {
+ 		goto release_and_exit;
+ 	}
+ 
+ 	acpi_tb_install_table_with_override(table_index, &new_table_desc, TRUE);
+ 
+ release_and_exit:
+ 
+ 	/* Release the temporary table descriptor */
+ 
+ 	acpi_tb_release_temp_table(&new_table_desc);
+ 	return_ACPI_STATUS(status);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_is_equivalent_table
+  *
+  * PARAMETERS:  table_desc          - Table 1 descriptor to be compared
+  *              table_index         - Index of table 2 to be compared
+  *
+  * RETURN:      TRUE if 2 tables are equivalent
+  *
+  * DESCRIPTION: This function is called to compare a table with what have
+  *              already been installed in the root table list.
+  *
+  ******************************************************************************/
+ 
+ static u8
+ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
+ {
+ 	acpi_status status = AE_OK;
+ 	u8 is_equivalent;
+ 	struct acpi_table_header *table;
+ 	u32 table_length;
+ 	u8 table_flags;
+ 
+ 	status =
+ 	    acpi_tb_acquire_table(&acpi_gbl_root_table_list.tables[table_index],
+ 				  &table, &table_length, &table_flags);
+ 	if (ACPI_FAILURE(status)) {
+ 		return (FALSE);
+ 	}
+ 
+ 	/*
+ 	 * Check for a table match on the entire table length,
+ 	 * not just the header.
+ 	 */
+ 	is_equivalent = (u8)((table_desc->length != table_length ||
+ 			      ACPI_MEMCMP(table_desc->pointer, table,
+ 					  table_length)) ? FALSE : TRUE);
+ 
+ 	/* Release the acquired table */
+ 
+ 	acpi_tb_release_table(table, table_length, table_flags);
+ 	return (is_equivalent);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_install_standard_table
+  *
+  * PARAMETERS:  address             - Address of the table (might be a virtual
+  *                                    address depending on the table_flags)
+  *              flags               - Flags for the table
+  *              reload              - Whether reload should be performed
+  *              override            - Whether override should be performed
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
   *              table_index         - Where the table index is returned
   *
   * RETURN:      Status
   *
++<<<<<<< HEAD
 + * DESCRIPTION: This function is called to add an ACPI table. It is used to
 + *              dynamically load tables via the Load and load_table AML
 + *              operators.
++=======
+  * DESCRIPTION: This function is called to install an ACPI table that is
+  *              neither DSDT nor FACS (a "standard" table.)
+  *              When this function is called by "Load" or "LoadTable" opcodes,
+  *              or by acpi_load_table() API, the "Reload" parameter is set.
+  *              After sucessfully returning from this function, table is
+  *              "INSTALLED" but not "VALIDATED".
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
   *
   ******************************************************************************/
  
  acpi_status
++<<<<<<< HEAD
 +acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
++=======
+ acpi_tb_install_standard_table(acpi_physical_address address,
+ 			       u8 flags,
+ 			       u8 reload, u8 override, u32 *table_index)
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  {
  	u32 i;
  	acpi_status status = AE_OK;
 -	struct acpi_table_desc new_table_desc;
  
++<<<<<<< HEAD
 +	ACPI_FUNCTION_TRACE(tb_add_table);
 +
 +	if (!table_desc->pointer) {
 +		status = acpi_tb_verify_table(table_desc);
 +		if (ACPI_FAILURE(status) || !table_desc->pointer) {
 +			acpi_tb_invalidate_table(table_desc);
 +			return_ACPI_STATUS(status);
 +		}
++=======
+ 	ACPI_FUNCTION_TRACE(tb_install_standard_table);
+ 
+ 	/* Acquire a temporary table descriptor for validation */
+ 
+ 	status = acpi_tb_acquire_temp_table(&new_table_desc, address, flags);
+ 	if (ACPI_FAILURE(status)) {
+ 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
+ 			    ACPI_CAST_PTR(void, address)));
+ 		return_ACPI_STATUS(status);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  	}
  
  	/*
 -	 * Optionally do not load any SSDTs from the RSDT/XSDT. This can
 -	 * be useful for debugging ACPI problems on some machines.
 +	 * Validate the incoming table signature.
 +	 *
 +	 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
 +	 * 2) We added support for OEMx tables, signature "OEM".
 +	 * 3) Valid tables were encountered with a null signature, so we just
 +	 *    gave up on validating the signature, (05/2008).
 +	 * 4) We encountered non-AML tables such as the MADT, which caused
 +	 *    interpreter errors and kernel faults. So now, we once again allow
 +	 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
  	 */
++<<<<<<< HEAD
 +	if ((table_desc->pointer->signature[0] != 0x00) &&
 +	    (!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))
 +	    && (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {
 +		ACPI_BIOS_ERROR((AE_INFO,
 +				 "Table has invalid signature [%4.4s] (0x%8.8X), "
 +				 "must be SSDT or OEMx",
 +				 acpi_ut_valid_acpi_name(table_desc->pointer->
 +							 signature) ?
 +				 table_desc->pointer->signature : "????",
 +				 *(u32 *)table_desc->pointer->signature));
 +
 +		return_ACPI_STATUS(AE_BAD_SIGNATURE);
++=======
+ 	if (!reload &&
+ 	    acpi_gbl_disable_ssdt_table_install &&
+ 	    ACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {
+ 		ACPI_INFO((AE_INFO, "Ignoring installation of %4.4s at %p",
+ 			   new_table_desc.signature.ascii, ACPI_CAST_PTR(void,
+ 									 address)));
+ 		goto release_and_exit;
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  	}
  
 -	/* Validate and verify a table before installation */
 +	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
  
 -	status = acpi_tb_verify_table(&new_table_desc, NULL);
 -	if (ACPI_FAILURE(status)) {
 -		goto release_and_exit;
 -	}
 +	/* Check if table is already registered */
 +
 +	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
 +		if (!acpi_gbl_root_table_list.tables[i].pointer) {
 +			status =
 +			    acpi_tb_verify_table(&acpi_gbl_root_table_list.
 +						 tables[i]);
 +			if (ACPI_FAILURE(status)
 +			    || !acpi_gbl_root_table_list.tables[i].pointer) {
 +				continue;
 +			}
 +		}
  
 -	if (reload) {
  		/*
 -		 * Validate the incoming table signature.
 -		 *
 -		 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
 -		 * 2) We added support for OEMx tables, signature "OEM".
 -		 * 3) Valid tables were encountered with a null signature, so we just
 -		 *    gave up on validating the signature, (05/2008).
 -		 * 4) We encountered non-AML tables such as the MADT, which caused
 -		 *    interpreter errors and kernel faults. So now, we once again allow
 -		 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
 +		 * Check for a table match on the entire table length,
 +		 * not just the header.
  		 */
 -		if ((new_table_desc.signature.ascii[0] != 0x00) &&
 -		    (!ACPI_COMPARE_NAME
 -		     (&new_table_desc.signature, ACPI_SIG_SSDT))
 -		    && (ACPI_STRNCMP(new_table_desc.signature.ascii, "OEM", 3)))
 -		{
 -			ACPI_BIOS_ERROR((AE_INFO,
 -					 "Table has invalid signature [%4.4s] (0x%8.8X), "
 -					 "must be SSDT or OEMx",
 -					 acpi_ut_valid_acpi_name(new_table_desc.
 -								 signature.
 -								 ascii) ?
 -					 new_table_desc.signature.
 -					 ascii : "????",
 -					 new_table_desc.signature.integer));
 -
 -			status = AE_BAD_SIGNATURE;
 -			goto release_and_exit;
 +		if (table_desc->length !=
 +		    acpi_gbl_root_table_list.tables[i].length) {
 +			continue;
  		}
  
 -		/* Check if table is already registered */
 -
 -		for (i = 0; i < acpi_gbl_root_table_list.current_table_count;
 -		     ++i) {
 -			/*
 -			 * Check for a table match on the entire table length,
 -			 * not just the header.
 -			 */
 -			if (!acpi_tb_is_equivalent_table(&new_table_desc, i)) {
 -				continue;
 -			}
 -
 -			/*
 -			 * Note: the current mechanism does not unregister a table if it is
 -			 * dynamically unloaded. The related namespace entries are deleted,
 -			 * but the table remains in the root table list.
 -			 *
 -			 * The assumption here is that the number of different tables that
 -			 * will be loaded is actually small, and there is minimal overhead
 -			 * in just keeping the table in case it is needed again.
 -			 *
 -			 * If this assumption changes in the future (perhaps on large
 -			 * machines with many table load/unload operations), tables will
 -			 * need to be unregistered when they are unloaded, and slots in the
 -			 * root table list should be reused when empty.
 -			 */
 -			if (acpi_gbl_root_table_list.tables[i].
 -			    flags & ACPI_TABLE_IS_LOADED) {
 -
 -				/* Table is still loaded, this is an error */
 +		if (ACPI_MEMCMP(table_desc->pointer,
 +				acpi_gbl_root_table_list.tables[i].pointer,
 +				acpi_gbl_root_table_list.tables[i].length)) {
 +			continue;
 +		}
  
++<<<<<<< HEAD
 +		/*
 +		 * Note: the current mechanism does not unregister a table if it is
 +		 * dynamically unloaded. The related namespace entries are deleted,
 +		 * but the table remains in the root table list.
 +		 *
 +		 * The assumption here is that the number of different tables that
 +		 * will be loaded is actually small, and there is minimal overhead
 +		 * in just keeping the table in case it is needed again.
 +		 *
 +		 * If this assumption changes in the future (perhaps on large
 +		 * machines with many table load/unload operations), tables will
 +		 * need to be unregistered when they are unloaded, and slots in the
 +		 * root table list should be reused when empty.
 +		 */
 +		*table_index = i;
 +
 +		if (acpi_gbl_root_table_list.tables[i].
 +		    flags & ACPI_TABLE_IS_LOADED) {
 +
 +			/* Table is still loaded, this is an error */
 +
 +			status = AE_ALREADY_EXISTS;
 +			goto release;
 +		} else {
 +			/* Table was unloaded, allow it to be reloaded */
 +
 +			acpi_tb_delete_table(table_desc);
 +			table_desc->pointer =
 +			    acpi_gbl_root_table_list.tables[i].pointer;
 +			table_desc->address =
 +			    acpi_gbl_root_table_list.tables[i].address;
 +			status = AE_OK;
 +			goto print_header;
++=======
+ 				status = AE_ALREADY_EXISTS;
+ 				goto release_and_exit;
+ 			} else {
+ 				/*
+ 				 * Table was unloaded, allow it to be reloaded.
+ 				 * As we are going to return AE_OK to the caller, we should
+ 				 * take the responsibility of freeing the input descriptor.
+ 				 * Refill the input descriptor to ensure
+ 				 * acpi_tb_install_table_with_override() can be called again to
+ 				 * indicate the re-installation.
+ 				 */
+ 				acpi_tb_uninstall_table(&new_table_desc);
+ 				*table_index = i;
+ 				(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+ 				return_ACPI_STATUS(AE_OK);
+ 			}
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  		}
  	}
  
 +	/*
 +	 * ACPI Table Override:
 +	 * Allow the host to override dynamically loaded tables.
 +	 * NOTE: the table is fully mapped at this point, and the mapping will
 +	 * be deleted by tb_table_override if the table is actually overridden.
 +	 */
 +	(void)acpi_tb_table_override(table_desc->pointer, table_desc);
 +
  	/* Add the table to the global root table list */
  
++<<<<<<< HEAD
 +	status = acpi_tb_store_table(table_desc->address, table_desc->pointer,
 +				     table_desc->length, table_desc->flags,
 +				     table_index);
++=======
+ 	status = acpi_tb_get_root_table_entry(&i);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  	if (ACPI_FAILURE(status)) {
 -		goto release_and_exit;
 +		goto release;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	*table_index = i;
+ 	acpi_tb_install_table_with_override(i, &new_table_desc, override);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  
 -release_and_exit:
 +      print_header:
 +	acpi_tb_print_table_header(table_desc->address, table_desc->pointer);
  
++<<<<<<< HEAD
 +      release:
 +	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
++=======
+ 	/* Release the temporary table descriptor */
+ 
+ 	acpi_tb_release_temp_table(&new_table_desc);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  	return_ACPI_STATUS(status);
  }
  
@@@ -289,61 -736,63 +816,92 @@@ struct acpi_table_header *acpi_tb_table
  
  	/* (1) Attempt logical override (returns a logical address) */
  
++<<<<<<< HEAD
 +	status = acpi_os_table_override(table_header, &new_table);
 +	if (ACPI_SUCCESS(status) && new_table) {
 +		new_address = ACPI_PTR_TO_PHYSADDR(new_table);
 +		new_table_length = new_table->length;
 +		new_flags = ACPI_TABLE_ORIGIN_OVERRIDE;
++=======
+ 	status = acpi_os_table_override(old_table_desc->pointer, &table);
+ 	if (ACPI_SUCCESS(status) && table) {
+ 		acpi_tb_acquire_temp_table(&new_table_desc,
+ 					   ACPI_PTR_TO_PHYSADDR(table),
+ 					   ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  		override_type = "Logical";
  		goto finish_override;
  	}
  
  	/* (2) Attempt physical override (returns a physical address) */
  
++<<<<<<< HEAD
 +	status = acpi_os_physical_table_override(table_header,
 +						 &new_address,
 +						 &new_table_length);
 +	if (ACPI_SUCCESS(status) && new_address && new_table_length) {
 +
 +		/* Map the entire new table */
 +
 +		new_table = acpi_os_map_memory(new_address, new_table_length);
 +		if (!new_table) {
 +			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
 +					"%4.4s %p Attempted physical table override failed",
 +					table_header->signature,
 +					ACPI_CAST_PTR(void,
 +						      table_desc->address)));
 +			return (NULL);
 +		}
 +
++=======
+ 	status = acpi_os_physical_table_override(old_table_desc->pointer,
+ 						 &address, &length);
+ 	if (ACPI_SUCCESS(status) && address && length) {
+ 		acpi_tb_acquire_temp_table(&new_table_desc, address,
+ 					   ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  		override_type = "Physical";
 +		new_flags = ACPI_TABLE_ORIGIN_MAPPED;
  		goto finish_override;
  	}
  
 -	return;			/* There was no override */
 +	return (NULL);		/* There was no override */
  
 -finish_override:
 +      finish_override:
  
 -	/* Validate and verify a table before overriding */
 +	ACPI_INFO((AE_INFO,
 +		   "%4.4s %p %s table override, new table: %p",
 +		   table_header->signature,
 +		   ACPI_CAST_PTR(void, table_desc->address),
 +		   override_type, new_table));
  
 -	status = acpi_tb_verify_table(&new_table_desc, NULL);
 -	if (ACPI_FAILURE(status)) {
 -		return;
 -	}
 +	/* We can now unmap/delete the original table (if fully mapped) */
  
 -	ACPI_INFO((AE_INFO, "%4.4s " ACPI_PRINTF_UINT
 -		   " %s table override, new table: " ACPI_PRINTF_UINT,
 -		   old_table_desc->signature.ascii,
 -		   ACPI_FORMAT_TO_UINT(old_table_desc->address),
 -		   override_type, ACPI_FORMAT_TO_UINT(new_table_desc.address)));
 +	acpi_tb_delete_table(table_desc);
  
 -	/* We can now uninstall the original table */
 +	/* Setup descriptor for the new table */
  
 -	acpi_tb_uninstall_table(old_table_desc);
 +	table_desc->address = new_address;
 +	table_desc->pointer = new_table;
 +	table_desc->length = new_table_length;
 +	table_desc->flags = new_flags;
  
++<<<<<<< HEAD
 +	return (new_table);
++=======
+ 	/*
+ 	 * Replace the original table descriptor and keep its state as
+ 	 * "VALIDATED".
+ 	 */
+ 	acpi_tb_init_table_descriptor(old_table_desc, new_table_desc.address,
+ 				      new_table_desc.flags,
+ 				      new_table_desc.pointer);
+ 	acpi_tb_validate_table(old_table_desc);
+ 
+ 	/* Release the temporary table descriptor */
+ 
+ 	acpi_tb_release_temp_table(&new_table_desc);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  }
  
  /*******************************************************************************
@@@ -412,6 -861,37 +970,40 @@@ acpi_status acpi_tb_resize_root_table_l
  
  /*******************************************************************************
   *
++<<<<<<< HEAD
++=======
+  * FUNCTION:    acpi_tb_get_root_table_entry
+  *
+  * PARAMETERS:  table_index         - Where table index is returned
+  *
+  * RETURN:      Status and table index.
+  *
+  * DESCRIPTION: Allocate a new ACPI table entry to the global table list
+  *
+  ******************************************************************************/
+ 
+ static acpi_status acpi_tb_get_root_table_entry(u32 *table_index)
+ {
+ 	acpi_status status;
+ 
+ 	/* Ensure that there is room for the table in the Root Table List */
+ 
+ 	if (acpi_gbl_root_table_list.current_table_count >=
+ 	    acpi_gbl_root_table_list.max_table_count) {
+ 		status = acpi_tb_resize_root_table_list();
+ 		if (ACPI_FAILURE(status)) {
+ 			return (status);
+ 		}
+ 	}
+ 
+ 	*table_index = acpi_gbl_root_table_list.current_table_count;
+ 	acpi_gbl_root_table_list.current_table_count++;
+ 	return (AE_OK);
+ }
+ 
+ /*******************************************************************************
+  *
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
   * FUNCTION:    acpi_tb_store_table
   *
   * PARAMETERS:  address             - Table address
@@@ -431,34 -912,18 +1024,46 @@@ acpi_tb_store_table(acpi_physical_addre
  		    u32 length, u8 flags, u32 *table_index)
  {
  	acpi_status status;
 -	struct acpi_table_desc *table_desc;
 +	struct acpi_table_desc *new_table;
  
++<<<<<<< HEAD
 +	/* Ensure that there is room for the table in the Root Table List */
 +
 +	if (acpi_gbl_root_table_list.current_table_count >=
 +	    acpi_gbl_root_table_list.max_table_count) {
 +		status = acpi_tb_resize_root_table_list();
 +		if (ACPI_FAILURE(status)) {
 +			return (status);
 +		}
++=======
+ 	status = acpi_tb_get_root_table_entry(table_index);
+ 	if (ACPI_FAILURE(status)) {
+ 		return (status);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  	}
  
 +	new_table =
 +	    &acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.
 +					     current_table_count];
 +
  	/* Initialize added table */
  
++<<<<<<< HEAD
 +	new_table->address = address;
 +	new_table->pointer = table;
 +	new_table->length = length;
 +	new_table->owner_id = 0;
 +	new_table->flags = flags;
 +
 +	ACPI_MOVE_32_TO_32(&new_table->signature, table->signature);
 +
 +	*table_index = acpi_gbl_root_table_list.current_table_count;
 +	acpi_gbl_root_table_list.current_table_count++;
++=======
+ 	table_desc = &acpi_gbl_root_table_list.tables[*table_index];
+ 	acpi_tb_init_table_descriptor(table_desc, address, flags, table);
+ 	table_desc->pointer = table;
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  	return (AE_OK);
  }
  
@@@ -474,35 -939,26 +1079,45 @@@
   *
   ******************************************************************************/
  
 -void acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)
 +void acpi_tb_delete_table(struct acpi_table_desc *table_desc)
  {
  
 -	ACPI_FUNCTION_TRACE(tb_uninstall_table);
 -
 -	/* Table must be installed */
 +	/* Table must be mapped or allocated */
  
 -	if (!table_desc->address) {
 -		return_VOID;
 +	if (!table_desc->pointer) {
 +		return;
  	}
  
 -	acpi_tb_invalidate_table(table_desc);
 +	switch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {
 +	case ACPI_TABLE_ORIGIN_MAPPED:
  
++<<<<<<< HEAD
 +		acpi_os_unmap_memory(table_desc->pointer, table_desc->length);
 +		break;
 +
 +	case ACPI_TABLE_ORIGIN_ALLOCATED:
 +
 +		ACPI_FREE(table_desc->pointer);
 +		table_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);
 +		break;
 +
 +		/* Not mapped or allocated, there is nothing we can do */
 +
 +	default:
 +
 +		return;
 +	}
 +
 +	table_desc->pointer = NULL;
++=======
+ 	if ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==
+ 	    ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL) {
+ 		ACPI_FREE(ACPI_CAST_PTR(void, table_desc->address));
+ 	}
+ 
+ 	table_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);
+ 	return_VOID;
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  }
  
  /*******************************************************************************
diff --cc drivers/acpi/acpica/tbutils.c
index 61ffb069ecd5,6c31d77cece0..000000000000
--- a/drivers/acpi/acpica/tbutils.c
+++ b/drivers/acpi/acpica/tbutils.c
@@@ -236,10 -178,13 +236,20 @@@ struct acpi_table_header *acpi_tb_copy_
  	}
  
  	ACPI_MEMCPY(new_table, table_desc->pointer, table_desc->length);
++<<<<<<< HEAD
 +	acpi_tb_delete_table(table_desc);
 +	table_desc->address = ACPI_PTR_TO_PHYSADDR(new_table);
 +	table_desc->pointer = new_table;
 +	table_desc->flags = ACPI_TABLE_ORIGIN_ALLOCATED;
++=======
+ 	acpi_tb_uninstall_table(table_desc);
+ 
+ 	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.
+ 				      tables[ACPI_TABLE_INDEX_DSDT],
+ 				      ACPI_PTR_TO_PHYSADDR(new_table),
+ 				      ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL,
+ 				      new_table);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  
  	ACPI_INFO((AE_INFO,
  		   "Forced DSDT copy: length 0x%05X copied locally, original unmapped",
@@@ -564,12 -471,21 +574,28 @@@ acpi_tb_parse_root_table(acpi_physical_
  
  		/* Get the table physical address (32-bit for RSDT, 64-bit for XSDT) */
  
++<<<<<<< HEAD
 +		acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.
 +						current_table_count].address =
 +		    acpi_tb_get_root_table_entry(table_entry, table_entry_size);
++=======
+ 		status =
+ 		    acpi_tb_install_standard_table(acpi_tb_get_root_table_entry
+ 						   (table_entry,
+ 						    table_entry_size),
+ 						   ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL,
+ 						   FALSE, TRUE, &table_index);
+ 
+ 		if (ACPI_SUCCESS(status) &&
+ 		    ACPI_COMPARE_NAME(&acpi_gbl_root_table_list.
+ 				      tables[table_index].signature,
+ 				      ACPI_SIG_FADT)) {
+ 			acpi_tb_parse_fadt(table_index);
+ 		}
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  
  		table_entry += table_entry_size;
 +		acpi_gbl_root_table_list.current_table_count++;
  	}
  
  	/*
diff --cc drivers/acpi/acpica/tbxface.c
index ba6e31d96bc1,6482b0ded652..000000000000
--- a/drivers/acpi/acpica/tbxface.c
+++ b/drivers/acpi/acpica/tbxface.c
@@@ -229,7 -233,7 +229,11 @@@ acpi_get_table_header(char *signature
  		if (!acpi_gbl_root_table_list.tables[i].pointer) {
  			if ((acpi_gbl_root_table_list.tables[i].flags &
  			     ACPI_TABLE_ORIGIN_MASK) ==
++<<<<<<< HEAD
 +			    ACPI_TABLE_ORIGIN_MAPPED) {
++=======
+ 			    ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL) {
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  				header =
  				    acpi_os_map_memory(acpi_gbl_root_table_list.
  						       tables[i].address,
diff --cc drivers/acpi/acpica/tbxfload.c
index 2620dbe96cfa,ab5308b81aa8..000000000000
--- a/drivers/acpi/acpica/tbxfload.c
+++ b/drivers/acpi/acpica/tbxfload.c
@@@ -208,6 -195,45 +208,48 @@@ static acpi_status acpi_tb_load_namespa
  
  /*******************************************************************************
   *
++<<<<<<< HEAD
++=======
+  * FUNCTION:    acpi_install_table
+  *
+  * PARAMETERS:  address             - Address of the ACPI table to be installed.
+  *              physical            - Whether the address is a physical table
+  *                                    address or not
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Dynamically install an ACPI table.
+  *              Note: This function should only be invoked after
+  *                    acpi_initialize_tables() and before acpi_load_tables().
+  *
+  ******************************************************************************/
+ 
+ acpi_status __init
+ acpi_install_table(acpi_physical_address address, u8 physical)
+ {
+ 	acpi_status status;
+ 	u8 flags;
+ 	u32 table_index;
+ 
+ 	ACPI_FUNCTION_TRACE(acpi_install_table);
+ 
+ 	if (physical) {
+ 		flags = ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL;
+ 	} else {
+ 		flags = ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL;
+ 	}
+ 
+ 	status = acpi_tb_install_standard_table(address, flags,
+ 						FALSE, FALSE, &table_index);
+ 
+ 	return_ACPI_STATUS(status);
+ }
+ 
+ ACPI_EXPORT_SYMBOL_INIT(acpi_install_table)
+ 
+ /*******************************************************************************
+  *
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
   * FUNCTION:    acpi_load_table
   *
   * PARAMETERS:  table               - Pointer to a buffer containing the ACPI
@@@ -255,7 -271,24 +297,28 @@@ acpi_status acpi_load_table(struct acpi
  	/* Install the table and load it into the namespace */
  
  	ACPI_INFO((AE_INFO, "Host-directed Dynamic ACPI Table Load:"));
++<<<<<<< HEAD
 +	status = acpi_tb_add_table(&table_desc, &table_index);
++=======
+ 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+ 
+ 	status = acpi_tb_install_standard_table(ACPI_PTR_TO_PHYSADDR(table),
+ 						ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL,
+ 						TRUE, FALSE, &table_index);
+ 
+ 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+ 	if (ACPI_FAILURE(status)) {
+ 		goto unlock_and_exit;
+ 	}
+ 
+ 	/*
+ 	 * Note: Now table is "INSTALLED", it must be validated before
+ 	 * using.
+ 	 */
+ 	status =
+ 	    acpi_tb_validate_table(&acpi_gbl_root_table_list.
+ 				   tables[table_index]);
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  	if (ACPI_FAILURE(status)) {
  		goto unlock_and_exit;
  	}
diff --cc include/acpi/actbl.h
index 9b58a8f43771,1cc7ef13c01a..000000000000
--- a/include/acpi/actbl.h
+++ b/include/acpi/actbl.h
@@@ -347,12 -367,11 +347,20 @@@ struct acpi_table_desc 
  
  /* Masks for Flags field above */
  
++<<<<<<< HEAD
 +#define ACPI_TABLE_ORIGIN_UNKNOWN       (0)
 +#define ACPI_TABLE_ORIGIN_MAPPED        (1)
 +#define ACPI_TABLE_ORIGIN_ALLOCATED     (2)
 +#define ACPI_TABLE_ORIGIN_OVERRIDE      (4)
 +#define ACPI_TABLE_ORIGIN_MASK          (7)
 +#define ACPI_TABLE_IS_LOADED            (8)
++=======
+ #define ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL  (0)	/* Virtual address, external maintained */
+ #define ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL (1)	/* Physical address, internally mapped */
+ #define ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL  (2)	/* Virtual address, internallly allocated */
+ #define ACPI_TABLE_ORIGIN_MASK              (3)
+ #define ACPI_TABLE_IS_LOADED                (8)
++>>>>>>> ed6f1d44dae8 (ACPICA: Table Manager: Misc cleanup and renames, no functional change.)
  
  /*
   * Get the remaining ACPI tables
* Unmerged path drivers/acpi/acpica/actables.h
* Unmerged path drivers/acpi/acpica/exconfig.c
* Unmerged path drivers/acpi/acpica/tbinstal.c
* Unmerged path drivers/acpi/acpica/tbutils.c
* Unmerged path drivers/acpi/acpica/tbxface.c
* Unmerged path drivers/acpi/acpica/tbxfload.c
* Unmerged path include/acpi/actbl.h
