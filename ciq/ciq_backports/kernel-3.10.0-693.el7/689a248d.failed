net/mlx5: Cancel recovery work in remove flow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Cancel recovery work in remove flow (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 95.35%
commit-author Daniel Jurgens <danielj@mellanox.com>
commit 689a248df83b6032edc57e86267b4e5cc8d7174e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/689a248d.failed

If there is pending delayed work for health recovery it must be canceled
if the device is being unloaded.

Fixes: 05ac2c0b7438 ("net/mlx5: Fix race between PCI error handlers and health work")
	Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 689a248df83b6032edc57e86267b4e5cc8d7174e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index cf8587046281,0b49739eadd3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -1278,12 -1196,7 +1278,16 @@@ static int mlx5_unload_one(struct mlx5_
  {
  	int err = 0;
  
++<<<<<<< HEAD
 +	err = mlx5_sriov_cleanup(dev);
 +	if (err) {
 +		dev_warn(&dev->pdev->dev, "%s: sriov cleanup failed - abort\n",
 +			 __func__);
 +		return err;
 +	}
++=======
+ 	mlx5_drain_health_wq(dev);
++>>>>>>> 689a248df83b (net/mlx5: Cancel recovery work in remove flow)
  
  	mutex_lock(&dev->intf_state_mutex);
  	if (test_bit(MLX5_INTERFACE_STATE_DOWN, &dev->intf_state)) {
@@@ -1434,10 -1357,15 +1438,20 @@@ static pci_ers_result_t mlx5_pci_err_de
  	struct mlx5_priv *priv = &dev->priv;
  
  	dev_info(&pdev->dev, "%s was called\n", __func__);
 -
  	mlx5_enter_error_state(dev);
++<<<<<<< HEAD
 +	mlx5_unload_one(dev, priv);
 +	pci_save_state(pdev);
 +	mlx5_pci_disable_device(dev);
++=======
+ 	mlx5_unload_one(dev, priv, false);
+ 	/* In case of kernel call save the pci state */
+ 	if (state) {
+ 		pci_save_state(pdev);
+ 		mlx5_pci_disable_device(dev);
+ 	}
+ 
++>>>>>>> 689a248df83b (net/mlx5: Cancel recovery work in remove flow)
  	return state == pci_channel_io_perm_failure ?
  		PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_NEED_RESET;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
