md: perform async updates for metadata where possible.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [md] perform async updates for metadata where possible (Jes Sorensen) [1380016]
Rebuild_FUZZ: 95.15%
commit-author NeilBrown <neilb@suse.com>
commit 060b0689f5df7e87641c820a605c779149da33ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/060b0689.failed

When adding devices to, or removing device from, an array we need to
update the metadata.  However we don't need to do it synchronously as
data integrity doesn't depend on these changes being recorded
instantly.  So avoid the synchronous call to md_update_sb and just set
a flag so that the thread will do it.

This can reduce the number of updates performed when lots of devices
are being added or removed.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 060b0689f5df7e87641c820a605c779149da33ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index ba8c742c55f6,f389d8abe137..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -2556,11 -2593,18 +2556,25 @@@ state_store(struct md_rdev *rdev, cons
  			err = -EBUSY;
  		else {
  			struct mddev *mddev = rdev->mddev;
 +			md_kick_rdev_from_array(rdev);
 +			if (mddev->pers)
 +				md_update_sb(mddev, 1);
 +			md_new_event(mddev);
  			err = 0;
++<<<<<<< HEAD
++=======
+ 			if (mddev_is_clustered(mddev))
+ 				err = md_cluster_ops->remove_disk(mddev, rdev);
+ 
+ 			if (err == 0) {
+ 				md_kick_rdev_from_array(rdev);
+ 				if (mddev->pers) {
+ 					set_bit(MD_CHANGE_DEVS, &mddev->flags);
+ 					md_wakeup_thread(mddev->thread);
+ 				}
+ 				md_new_event(mddev);
+ 			}
++>>>>>>> 060b0689f5df (md: perform async updates for metadata where possible.)
  		}
  	} else if (cmd_match(buf, "writemostly")) {
  		set_bit(WriteMostly, &rdev->flags);
@@@ -6080,8 -6173,15 +6094,12 @@@ static int hot_remove_disk(struct mdde
  		goto busy;
  
  kick_rdev:
 -	if (mddev_is_clustered(mddev))
 -		md_cluster_ops->remove_disk(mddev, rdev);
 -
  	md_kick_rdev_from_array(rdev);
- 	md_update_sb(mddev, 1);
+ 	set_bit(MD_CHANGE_DEVS, &mddev->flags);
+ 	if (mddev->thread)
+ 		md_wakeup_thread(mddev->thread);
+ 	else
+ 		md_update_sb(mddev, 1);
  	md_new_event(mddev);
  
  	return 0;
@@@ -6149,8 -6246,9 +6167,14 @@@ static int hot_add_disk(struct mddev *m
  
  	rdev->raid_disk = -1;
  
++<<<<<<< HEAD
 +	md_update_sb(mddev, 1);
 +
++=======
+ 	set_bit(MD_CHANGE_DEVS, &mddev->flags);
+ 	if (!mddev->thread)
+ 		md_update_sb(mddev, 1);
++>>>>>>> 060b0689f5df (md: perform async updates for metadata where possible.)
  	/*
  	 * Kick recovery, maybe this spare has to be added to the
  	 * array immediately.
* Unmerged path drivers/md/md.c
