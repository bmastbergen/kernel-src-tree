net/sched: Add match-all classifier hw offloading.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: Add match-all classifier hw offloading. (Ivan Vecera) [1382040]
Rebuild_FUZZ: 95.83%
commit-author Yotam Gigi <yotamg@mellanox.com>
commit b87f7936a93246804cf70e7e2e0568799c948bb1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b87f7936.failed

Following the work that have been done on offloading classifiers like u32
and flower, now the match-all classifier hw offloading is possible. if
the interface supports tc offloading.

To control the offloading, two tc flags have been introduced: skip_sw and
skip_hw. Typical usage:

tc filter add dev eth25 parent ffff: 	\
	matchall skip_sw		\
	action mirred egress mirror	\
	dev eth27

	Signed-off-by: Yotam Gigi <yotamg@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b87f7936a93246804cf70e7e2e0568799c948bb1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	include/net/pkt_cls.h
#	include/uapi/linux/pkt_cls.h
#	net/sched/cls_matchall.c
diff --cc include/linux/netdevice.h
index 2f7ec2ad350a,076df5360ba5..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -798,6 -786,8 +798,11 @@@ typedef u16 (*select_queue_fallback_t)(
  enum {
  	TC_SETUP_MQPRIO,
  	TC_SETUP_CLSU32,
++<<<<<<< HEAD
++=======
+ 	TC_SETUP_CLSFLOWER,
+ 	TC_SETUP_MATCHALL,
++>>>>>>> b87f7936a932 (net/sched: Add match-all classifier hw offloading.)
  };
  
  struct tc_cls_u32_offload;
@@@ -807,6 -797,8 +812,11 @@@ struct tc_to_netdev 
  	union {
  		u8 tc;
  		struct tc_cls_u32_offload *cls_u32;
++<<<<<<< HEAD
++=======
+ 		struct tc_cls_flower_offload *cls_flower;
+ 		struct tc_cls_matchall_offload *cls_mall;
++>>>>>>> b87f7936a932 (net/sched: Add match-all classifier hw offloading.)
  	};
  };
  
diff --cc include/net/pkt_cls.h
index b606c03c3836,6f8d65342d3a..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -392,9 -392,65 +392,55 @@@ struct tc_cls_u32_offload 
  	};
  };
  
 -static inline bool tc_should_offload(const struct net_device *dev,
 -				     const struct tcf_proto *tp, u32 flags)
 +static inline bool tc_should_offload(struct net_device *dev)
  {
 -	const struct Qdisc *sch = tp->q;
 -	const struct Qdisc_class_ops *cops = sch->ops->cl_ops;
 -
 -	if (!(dev->features & NETIF_F_HW_TC))
 -		return false;
 -	if (flags & TCA_CLS_FLAGS_SKIP_HW)
 -		return false;
 -	if (!dev->netdev_ops->ndo_setup_tc)
 -		return false;
 -	if (cops && cops->tcf_cl_offload)
 -		return cops->tcf_cl_offload(tp->classid);
 -
 -	return true;
 +	return dev->netdev_ops->ndo_setup_tc;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool tc_skip_sw(u32 flags)
+ {
+ 	return (flags & TCA_CLS_FLAGS_SKIP_SW) ? true : false;
+ }
+ 
+ /* SKIP_HW and SKIP_SW are mutually exclusive flags. */
+ static inline bool tc_flags_valid(u32 flags)
+ {
+ 	if (flags & ~(TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW))
+ 		return false;
+ 
+ 	if (!(flags ^ (TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW)))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ enum tc_fl_command {
+ 	TC_CLSFLOWER_REPLACE,
+ 	TC_CLSFLOWER_DESTROY,
+ 	TC_CLSFLOWER_STATS,
+ };
+ 
+ struct tc_cls_flower_offload {
+ 	enum tc_fl_command command;
+ 	unsigned long cookie;
+ 	struct flow_dissector *dissector;
+ 	struct fl_flow_key *mask;
+ 	struct fl_flow_key *key;
+ 	struct tcf_exts *exts;
+ };
+ 
+ enum tc_matchall_command {
+ 	TC_CLSMATCHALL_REPLACE,
+ 	TC_CLSMATCHALL_DESTROY,
+ };
+ 
+ struct tc_cls_matchall_offload {
+ 	enum tc_matchall_command command;
+ 	struct tcf_exts *exts;
+ 	unsigned long cookie;
+ };
+ 
++>>>>>>> b87f7936a932 (net/sched: Add match-all classifier hw offloading.)
  #endif
diff --cc include/uapi/linux/pkt_cls.h
index 3abfe7f00823,d1c1ccaba787..000000000000
--- a/include/uapi/linux/pkt_cls.h
+++ b/include/uapi/linux/pkt_cls.h
@@@ -407,6 -401,50 +407,53 @@@ enum 
  
  #define TCA_BPF_MAX (__TCA_BPF_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ /* Flower classifier */
+ 
+ enum {
+ 	TCA_FLOWER_UNSPEC,
+ 	TCA_FLOWER_CLASSID,
+ 	TCA_FLOWER_INDEV,
+ 	TCA_FLOWER_ACT,
+ 	TCA_FLOWER_KEY_ETH_DST,		/* ETH_ALEN */
+ 	TCA_FLOWER_KEY_ETH_DST_MASK,	/* ETH_ALEN */
+ 	TCA_FLOWER_KEY_ETH_SRC,		/* ETH_ALEN */
+ 	TCA_FLOWER_KEY_ETH_SRC_MASK,	/* ETH_ALEN */
+ 	TCA_FLOWER_KEY_ETH_TYPE,	/* be16 */
+ 	TCA_FLOWER_KEY_IP_PROTO,	/* u8 */
+ 	TCA_FLOWER_KEY_IPV4_SRC,	/* be32 */
+ 	TCA_FLOWER_KEY_IPV4_SRC_MASK,	/* be32 */
+ 	TCA_FLOWER_KEY_IPV4_DST,	/* be32 */
+ 	TCA_FLOWER_KEY_IPV4_DST_MASK,	/* be32 */
+ 	TCA_FLOWER_KEY_IPV6_SRC,	/* struct in6_addr */
+ 	TCA_FLOWER_KEY_IPV6_SRC_MASK,	/* struct in6_addr */
+ 	TCA_FLOWER_KEY_IPV6_DST,	/* struct in6_addr */
+ 	TCA_FLOWER_KEY_IPV6_DST_MASK,	/* struct in6_addr */
+ 	TCA_FLOWER_KEY_TCP_SRC,		/* be16 */
+ 	TCA_FLOWER_KEY_TCP_DST,		/* be16 */
+ 	TCA_FLOWER_KEY_UDP_SRC,		/* be16 */
+ 	TCA_FLOWER_KEY_UDP_DST,		/* be16 */
+ 
+ 	TCA_FLOWER_FLAGS,
+ 	__TCA_FLOWER_MAX,
+ };
+ 
+ #define TCA_FLOWER_MAX (__TCA_FLOWER_MAX - 1)
+ 
+ /* Match-all classifier */
+ 
+ enum {
+ 	TCA_MATCHALL_UNSPEC,
+ 	TCA_MATCHALL_CLASSID,
+ 	TCA_MATCHALL_ACT,
+ 	TCA_MATCHALL_FLAGS,
+ 	__TCA_MATCHALL_MAX,
+ };
+ 
+ #define TCA_MATCHALL_MAX (__TCA_MATCHALL_MAX - 1)
+ 
++>>>>>>> b87f7936a932 (net/sched: Add match-all classifier hw offloading.)
  /* Extended Matches */
  
  struct tcf_ematch_tree_hdr {
* Unmerged path net/sched/cls_matchall.c
* Unmerged path include/linux/netdevice.h
* Unmerged path include/net/pkt_cls.h
* Unmerged path include/uapi/linux/pkt_cls.h
* Unmerged path net/sched/cls_matchall.c
