ACPI / hotplug / PCI: Make device_is_managed_by_native_pciehp() public

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lukas Wunner <lukas@wunner.de>
commit 437eb7bf7b28472f8b7689e166dc1dd691367121
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/437eb7bf.failed

We're about to add runtime PM of hotplug ports, but we need to restrict it
to ports that are handled natively by the OS:  If they're handled by the
firmware (which is the case for Thunderbolt on non-Macs), things would
break if the OS put the ports into D3hot behind the firmware's back.

To determine if a hotplug port is handled natively, one has to walk up from
the port to the root bridge and check the cached _OSC Control Field for the
value of the "PCI Express Native Hot Plug control" bit.  There's already a
function to do that, device_is_managed_by_native_pciehp(), but it's private
to drivers/pci/hotplug/acpiphp_glue.c and only compiled in if
CONFIG_HOTPLUG_PCI_ACPI is enabled.

Make it public and move it to drivers/pci/pci-acpi.c, so that it is
available in the more general CONFIG_ACPI case.

The function contains a check if the device in question is a hotplug port
and returns false if it's not.  The caller we're going to add doesn't need
this as it only calls the function if it actually *is* a hotplug port.
Move the check out of the function into the single existing caller.

Rename it to pciehp_is_native() and add some kerneldoc and polish.

No functional change intended.

	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Lukas Wunner <lukas@wunner.de>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 437eb7bf7b28472f8b7689e166dc1dd691367121)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-acpi.c
diff --cc drivers/pci/pci-acpi.c
index 6c6805d13f1f,ed3daa8e7658..000000000000
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@@ -380,6 -293,96 +380,99 @@@ int pci_get_hp_params(struct pci_dev *d
  }
  EXPORT_SYMBOL_GPL(pci_get_hp_params);
  
++<<<<<<< HEAD
++=======
+ /**
+  * pciehp_is_native - Check whether a hotplug port is handled by the OS
+  * @pdev: Hotplug port to check
+  *
+  * Walk up from @pdev to the host bridge, obtain its cached _OSC Control Field
+  * and return the value of the "PCI Express Native Hot Plug control" bit.
+  * On failure to obtain the _OSC Control Field return %false.
+  */
+ bool pciehp_is_native(struct pci_dev *pdev)
+ {
+ 	struct acpi_pci_root *root;
+ 	acpi_handle handle;
+ 
+ 	handle = acpi_find_root_bridge_handle(pdev);
+ 	if (!handle)
+ 		return false;
+ 
+ 	root = acpi_pci_find_root(handle);
+ 	if (!root)
+ 		return false;
+ 
+ 	return root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL;
+ }
+ 
+ /**
+  * pci_acpi_wake_bus - Root bus wakeup notification fork function.
+  * @work: Work item to handle.
+  */
+ static void pci_acpi_wake_bus(struct work_struct *work)
+ {
+ 	struct acpi_device *adev;
+ 	struct acpi_pci_root *root;
+ 
+ 	adev = container_of(work, struct acpi_device, wakeup.context.work);
+ 	root = acpi_driver_data(adev);
+ 	pci_pme_wakeup_bus(root->bus);
+ }
+ 
+ /**
+  * pci_acpi_wake_dev - PCI device wakeup notification work function.
+  * @handle: ACPI handle of a device the notification is for.
+  * @work: Work item to handle.
+  */
+ static void pci_acpi_wake_dev(struct work_struct *work)
+ {
+ 	struct acpi_device_wakeup_context *context;
+ 	struct pci_dev *pci_dev;
+ 
+ 	context = container_of(work, struct acpi_device_wakeup_context, work);
+ 	pci_dev = to_pci_dev(context->dev);
+ 
+ 	if (pci_dev->pme_poll)
+ 		pci_dev->pme_poll = false;
+ 
+ 	if (pci_dev->current_state == PCI_D3cold) {
+ 		pci_wakeup_event(pci_dev);
+ 		pm_runtime_resume(&pci_dev->dev);
+ 		return;
+ 	}
+ 
+ 	/* Clear PME Status if set. */
+ 	if (pci_dev->pme_support)
+ 		pci_check_pme_status(pci_dev);
+ 
+ 	pci_wakeup_event(pci_dev);
+ 	pm_runtime_resume(&pci_dev->dev);
+ 
+ 	pci_pme_wakeup_bus(pci_dev->subordinate);
+ }
+ 
+ /**
+  * pci_acpi_add_bus_pm_notifier - Register PM notifier for root PCI bus.
+  * @dev: PCI root bridge ACPI device.
+  */
+ acpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev)
+ {
+ 	return acpi_add_pm_notifier(dev, NULL, pci_acpi_wake_bus);
+ }
+ 
+ /**
+  * pci_acpi_add_pm_notifier - Register PM notifier for given PCI device.
+  * @dev: ACPI device to add the notifier for.
+  * @pci_dev: PCI device to check for the PME status if an event is signaled.
+  */
+ acpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,
+ 				     struct pci_dev *pci_dev)
+ {
+ 	return acpi_add_pm_notifier(dev, &pci_dev->dev, pci_acpi_wake_dev);
+ }
+ 
++>>>>>>> 437eb7bf7b28 (ACPI / hotplug / PCI: Make device_is_managed_by_native_pciehp() public)
  /*
   * _SxD returns the D-state with the highest power
   * (lowest D-state number) supported in the S-state "x".
diff --git a/drivers/pci/hotplug/acpiphp_glue.c b/drivers/pci/hotplug/acpiphp_glue.c
index 23ab05206147..02d5e64d0e37 100644
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@ -222,32 +222,6 @@ static void acpiphp_post_dock_fixup(struct acpi_device *adev)
 	acpiphp_let_context_go(context);
 }
 
-/* Check whether the PCI device is managed by native PCIe hotplug driver */
-static bool device_is_managed_by_native_pciehp(struct pci_dev *pdev)
-{
-	acpi_handle tmp;
-	struct acpi_pci_root *root;
-
-	/* Check whether the PCIe port supports native PCIe hotplug */
-	if (!pdev->is_hotplug_bridge)
-		return false;
-
-	/*
-	 * Check whether native PCIe hotplug has been enabled for
-	 * this PCIe hierarchy.
-	 */
-	tmp = acpi_find_root_bridge_handle(pdev);
-	if (!tmp)
-		return false;
-	root = acpi_pci_find_root(tmp);
-	if (!root)
-		return false;
-	if (!(root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL))
-		return false;
-
-	return true;
-}
-
 /**
  * acpiphp_add_context - Add ACPIPHP context to an ACPI device object.
  * @handle: ACPI handle of the object to add a context to.
@@ -331,7 +305,7 @@ static acpi_status acpiphp_add_context(acpi_handle handle, u32 lvl, void *data,
 	 * expose slots to user space in those cases.
 	 */
 	if ((acpi_pci_check_ejectable(pbus, handle) || is_dock_device(adev))
-	    && !(pdev && device_is_managed_by_native_pciehp(pdev))) {
+	    && !(pdev && pdev->is_hotplug_bridge && pciehp_is_native(pdev))) {
 		unsigned long long sun;
 		int retval;
 
* Unmerged path drivers/pci/pci-acpi.c
diff --git a/include/linux/pci_hotplug.h b/include/linux/pci_hotplug.h
index c702755d619b..94030dff6bf4 100644
--- a/include/linux/pci_hotplug.h
+++ b/include/linux/pci_hotplug.h
@@ -177,6 +177,7 @@ struct hotplug_params {
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
 int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp);
+bool pciehp_is_native(struct pci_dev *pdev);
 int acpi_get_hp_hw_control_from_firmware(struct pci_dev *dev, u32 flags);
 int acpi_pci_check_ejectable(struct pci_bus *pbus, acpi_handle handle);
 int acpi_pci_detect_ejectable(acpi_handle handle);
@@ -186,5 +187,6 @@ static inline int pci_get_hp_params(struct pci_dev *dev,
 {
 	return -ENODEV;
 }
+static inline bool pciehp_is_native(struct pci_dev *pdev) { return true; }
 #endif
 #endif
