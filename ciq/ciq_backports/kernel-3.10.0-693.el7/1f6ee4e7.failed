Drivers: hv: vmbus: On write cleanup the logic to interrupt the host

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hv] vmbus: On write cleanup the logic to interrupt the host (Vitaly Kuznetsov) [1406404 1418889]
Rebuild_FUZZ: 89.43%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 1f6ee4e7d83586c8b10bd4f2f4346353d04ce884
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1f6ee4e7.failed

Signal the host when we determine the host is to be signaled.
The currrent code determines the need to signal in the ringbuffer
code and actually issues the signal elsewhere. This can result
in the host viewing this interrupt as spurious since the host may also
poll the channel. Make the necessary adjustments.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 1f6ee4e7d83586c8b10bd4f2f4346353d04ce884)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/ring_buffer.c
diff --cc drivers/hv/ring_buffer.c
index d27dcebfaf0f,4af71306d0ff..000000000000
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@@ -64,73 -66,38 +64,88 @@@ u32 hv_end_read(struct hv_ring_buffer_i
   *	   once the ring buffer is empty, it will clear the
   *	   interrupt_mask and re-check to see if new data has
   *	   arrived.
+  *
+  * KYS: Oct. 30, 2016:
+  * It looks like Windows hosts have logic to deal with DOS attacks that
+  * can be triggered if it receives interrupts when it is not expecting
+  * the interrupt. The host expects interrupts only when the ring
+  * transitions from empty to non-empty (or full to non full on the guest
+  * to host ring).
+  * So, base the signaling decision solely on the ring state until the
+  * host logic is fixed.
   */
  
- static bool hv_need_to_signal(u32 old_write, struct hv_ring_buffer_info *rbi,
- 			      enum hv_signal_policy policy)
+ static void hv_signal_on_write(u32 old_write, struct vmbus_channel *channel,
+ 			       bool kick_q)
  {
++<<<<<<< HEAD
 +	mb();
++=======
+ 	struct hv_ring_buffer_info *rbi = &channel->outbound;
+ 
+ 	virt_mb();
++>>>>>>> 1f6ee4e7d835 (Drivers: hv: vmbus: On write cleanup the logic to interrupt the host)
  	if (READ_ONCE(rbi->ring_buffer->interrupt_mask))
- 		return false;
+ 		return;
  
  	/* check interrupt_mask before read_index */
 -	virt_rmb();
 +	rmb();
  	/*
  	 * This is the only case we need to signal when the
  	 * ring transitions from being empty to non-empty.
  	 */
  	if (old_write == READ_ONCE(rbi->ring_buffer->read_index))
- 		return true;
+ 		vmbus_setevent(channel);
  
- 	return false;
+ 	return;
  }
  
 +/*
 + * To optimize the flow management on the send-side,
 + * when the sender is blocked because of lack of
 + * sufficient space in the ring buffer, potential the
 + * consumer of the ring buffer can signal the producer.
 + * This is controlled by the following parameters:
 + *
 + * 1. pending_send_sz: This is the size in bytes that the
 + *    producer is trying to send.
 + * 2. The feature bit feat_pending_send_sz set to indicate if
 + *    the consumer of the ring will signal when the ring
 + *    state transitions from being full to a state where
 + *    there is room for the producer to send the pending packet.
 + */
 +
 +static bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)
 +{
 +	u32 cur_write_sz;
 +	u32 pending_sz;
 +
 +	/*
 +	 * Issue a full memory barrier before making the signaling decision.
 +	 * Here is the reason for having this barrier:
 +	 * If the reading of the pend_sz (in this function)
 +	 * were to be reordered and read before we commit the new read
 +	 * index (in the calling function)  we could
 +	 * have a problem. If the host were to set the pending_sz after we
 +	 * have sampled pending_sz and go to sleep before we commit the
 +	 * read index, we could miss sending the interrupt. Issue a full
 +	 * memory barrier to address this.
 +	 */
 +	mb();
 +
 +	pending_sz = READ_ONCE(rbi->ring_buffer->pending_send_sz);
 +	/* If the other end is not blocked on write don't bother. */
 +	if (pending_sz == 0)
 +		return false;
 +
 +	cur_write_sz = hv_get_bytes_to_write(rbi);
 +
 +	if (cur_write_sz >= pending_sz)
 +		return true;
 +
 +	return false;
 +}
 +
  /* Get the next write location for the specified ring buffer. */
  static inline u32
  hv_get_next_write_location(struct hv_ring_buffer_info *ring_info)
diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index 3d0a3a54c6b4..d4cc96e3a3cd 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -39,7 +39,7 @@
  * vmbus_setevent- Trigger an event notification on the specified
  * channel.
  */
-static void vmbus_setevent(struct vmbus_channel *channel)
+void vmbus_setevent(struct vmbus_channel *channel)
 {
 	struct hv_monitor_page *monitorpage;
 
@@ -65,6 +65,7 @@ static void vmbus_setevent(struct vmbus_channel *channel)
 		vmbus_set_event(channel);
 	}
 }
+EXPORT_SYMBOL_GPL(vmbus_setevent);
 
 /*
  * vmbus_open - Open the specified channel.
@@ -638,8 +639,6 @@ int vmbus_sendpacket_ctl(struct vmbus_channel *channel, void *buffer,
 	u32 packetlen_aligned = ALIGN(packetlen, sizeof(u64));
 	struct kvec bufferlist[3];
 	u64 aligned_data = 0;
-	int ret;
-	bool signal = false;
 	bool lock = channel->acquire_ring_lock;
 	int num_vecs = ((bufferlen != 0) ? 3 : 1);
 
@@ -659,41 +658,9 @@ int vmbus_sendpacket_ctl(struct vmbus_channel *channel, void *buffer,
 	bufferlist[2].iov_base = &aligned_data;
 	bufferlist[2].iov_len = (packetlen_aligned - packetlen);
 
-	ret = hv_ringbuffer_write(&channel->outbound, bufferlist, num_vecs,
-				  &signal, lock, channel->signal_policy);
-
-	/*
-	 * Signalling the host is conditional on many factors:
-	 * 1. The ring state changed from being empty to non-empty.
-	 *    This is tracked by the variable "signal".
-	 * 2. The variable kick_q tracks if more data will be placed
-	 *    on the ring. We will not signal if more data is
-	 *    to be placed.
-	 *
-	 * Based on the channel signal state, we will decide
-	 * which signaling policy will be applied.
-	 *
-	 * If we cannot write to the ring-buffer; signal the host
-	 * even if we may not have written anything. This is a rare
-	 * enough condition that it should not matter.
-	 * NOTE: in this case, the hvsock channel is an exception, because
-	 * it looks the host side's hvsock implementation has a throttling
-	 * mechanism which can hurt the performance otherwise.
-	 *
-	 * KYS: Oct. 30, 2016:
-	 * It looks like Windows hosts have logic to deal with DOS attacks that
-	 * can be triggered if it receives interrupts when it is not expecting
-	 * the interrupt. The host expects interrupts only when the ring
-	 * transitions from empty to non-empty (or full to non full on the guest
-	 * to host ring).
-	 * So, base the signaling decision solely on the ring state until the
-	 * host logic is fixed.
-	 */
-
-	if (((ret == 0) && signal))
-		vmbus_setevent(channel);
+	return hv_ringbuffer_write(channel, bufferlist, num_vecs,
+				   lock, kick_q);
 
-	return ret;
 }
 EXPORT_SYMBOL(vmbus_sendpacket_ctl);
 
@@ -734,7 +701,6 @@ int vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,
 				     u32 flags,
 				     bool kick_q)
 {
-	int ret;
 	int i;
 	struct vmbus_channel_packet_page_buffer desc;
 	u32 descsize;
@@ -742,7 +708,6 @@ int vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,
 	u32 packetlen_aligned;
 	struct kvec bufferlist[3];
 	u64 aligned_data = 0;
-	bool signal = false;
 	bool lock = channel->acquire_ring_lock;
 
 	if (pagecount > MAX_PAGE_BUFFER_COUNT)
@@ -780,38 +745,8 @@ int vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,
 	bufferlist[2].iov_base = &aligned_data;
 	bufferlist[2].iov_len = (packetlen_aligned - packetlen);
 
-	ret = hv_ringbuffer_write(&channel->outbound, bufferlist, 3,
-				  &signal, lock, channel->signal_policy);
-
-	/*
-	 * Signalling the host is conditional on many factors:
-	 * 1. The ring state changed from being empty to non-empty.
-	 *    This is tracked by the variable "signal".
-	 * 2. The variable kick_q tracks if more data will be placed
-	 *    on the ring. We will not signal if more data is
-	 *    to be placed.
-	 *
-	 * Based on the channel signal state, we will decide
-	 * which signaling policy will be applied.
-	 *
-	 * If we cannot write to the ring-buffer; signal the host
-	 * even if we may not have written anything. This is a rare
-	 * enough condition that it should not matter.
-	 *
-	 * KYS: Oct. 30, 2016:
-	 * It looks like Windows hosts have logic to deal with DOS attacks that
-	 * can be triggered if it receives interrupts when it is not expecting
-	 * the interrupt. The host expects interrupts only when the ring
-	 * transitions from empty to non-empty (or full to non full on the guest
-	 * to host ring).
-	 * So, base the signaling decision solely on the ring state until the
-	 * host logic is fixed.
-	 */
-
-	if (((ret == 0) && signal))
-		vmbus_setevent(channel);
-
-	return ret;
+	return hv_ringbuffer_write(channel, bufferlist, 3,
+				   lock, kick_q);
 }
 EXPORT_SYMBOL_GPL(vmbus_sendpacket_pagebuffer_ctl);
 
@@ -842,12 +777,10 @@ int vmbus_sendpacket_mpb_desc(struct vmbus_channel *channel,
 			      u32 desc_size,
 			      void *buffer, u32 bufferlen, u64 requestid)
 {
-	int ret;
 	u32 packetlen;
 	u32 packetlen_aligned;
 	struct kvec bufferlist[3];
 	u64 aligned_data = 0;
-	bool signal = false;
 	bool lock = channel->acquire_ring_lock;
 
 	packetlen = desc_size + bufferlen;
@@ -868,13 +801,8 @@ int vmbus_sendpacket_mpb_desc(struct vmbus_channel *channel,
 	bufferlist[2].iov_base = &aligned_data;
 	bufferlist[2].iov_len = (packetlen_aligned - packetlen);
 
-	ret = hv_ringbuffer_write(&channel->outbound, bufferlist, 3,
-				  &signal, lock, channel->signal_policy);
-
-	if (ret == 0 && signal)
-		vmbus_setevent(channel);
-
-	return ret;
+	return hv_ringbuffer_write(channel, bufferlist, 3,
+				   lock, true);
 }
 EXPORT_SYMBOL_GPL(vmbus_sendpacket_mpb_desc);
 
@@ -886,14 +814,12 @@ int vmbus_sendpacket_multipagebuffer(struct vmbus_channel *channel,
 				struct hv_multipage_buffer *multi_pagebuffer,
 				void *buffer, u32 bufferlen, u64 requestid)
 {
-	int ret;
 	struct vmbus_channel_packet_multipage_buffer desc;
 	u32 descsize;
 	u32 packetlen;
 	u32 packetlen_aligned;
 	struct kvec bufferlist[3];
 	u64 aligned_data = 0;
-	bool signal = false;
 	bool lock = channel->acquire_ring_lock;
 	u32 pfncount = NUM_PAGES_SPANNED(multi_pagebuffer->offset,
 					 multi_pagebuffer->len);
@@ -933,13 +859,8 @@ int vmbus_sendpacket_multipagebuffer(struct vmbus_channel *channel,
 	bufferlist[2].iov_base = &aligned_data;
 	bufferlist[2].iov_len = (packetlen_aligned - packetlen);
 
-	ret = hv_ringbuffer_write(&channel->outbound, bufferlist, 3,
-				  &signal, lock, channel->signal_policy);
-
-	if (ret == 0 && signal)
-		vmbus_setevent(channel);
-
-	return ret;
+	return hv_ringbuffer_write(channel, bufferlist, 3,
+				   lock, true);
 }
 EXPORT_SYMBOL_GPL(vmbus_sendpacket_multipagebuffer);
 
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index 93373f350590..04344784d854 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -619,10 +619,10 @@ int hv_ringbuffer_init(struct hv_ring_buffer_info *ring_info, void *buffer,
 
 void hv_ringbuffer_cleanup(struct hv_ring_buffer_info *ring_info);
 
-int hv_ringbuffer_write(struct hv_ring_buffer_info *ring_info,
+int hv_ringbuffer_write(struct vmbus_channel *channel,
 		    struct kvec *kv_list,
-		    u32 kv_count, bool *signal, bool lock,
-		    enum hv_signal_policy policy);
+		    u32 kv_count, bool lock,
+		    bool kick_q);
 
 int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info,
 		       void *buffer, u32 buflen, u32 *buffer_actual_len,
* Unmerged path drivers/hv/ring_buffer.c
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b44df892a232..9b701cca9ea1 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1427,6 +1427,7 @@ void hv_event_tasklet_enable(struct vmbus_channel *channel);
 
 void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
+void vmbus_setevent(struct vmbus_channel *channel);
 /*
  * Negotiated version with the Host.
  */
