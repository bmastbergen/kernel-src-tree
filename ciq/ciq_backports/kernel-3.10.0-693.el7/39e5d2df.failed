SUNRPC search xprt switch for sockaddr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andy Adamson <andros@netapp.com>
commit 39e5d2df959dd4aea81fa33d765d2a5cc67a0512
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/39e5d2df.failed

	Signed-off-by: Andy Adamson <andros@netapp.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 39e5d2df959dd4aea81fa33d765d2a5cc67a0512)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/clnt.h
#	net/sunrpc/clnt.c
diff --cc include/linux/sunrpc/clnt.h
index 9a7ddbaf116e,35cc539e2921..000000000000
--- a/include/linux/sunrpc/clnt.h
+++ b/include/linux/sunrpc/clnt.h
@@@ -196,7 -195,14 +196,15 @@@ int		rpc_clnt_add_xprt(struct rpc_clnt 
  				struct rpc_xprt *,
  				void *),
  			void *data);
 -void		rpc_cap_max_reconnect_timeout(struct rpc_clnt *clnt,
 -			unsigned long timeo);
  
  const char *rpc_proc_name(const struct rpc_task *task);
++<<<<<<< HEAD
++=======
+ 
+ void rpc_clnt_xprt_switch_put(struct rpc_clnt *);
+ void rpc_clnt_xprt_switch_add_xprt(struct rpc_clnt *, struct rpc_xprt *);
+ bool rpc_clnt_xprt_switch_has_addr(struct rpc_clnt *clnt,
+ 			const struct sockaddr *sap);
++>>>>>>> 39e5d2df959d (SUNRPC search xprt switch for sockaddr)
  #endif /* __KERNEL__ */
  #endif /* _LINUX_SUNRPC_CLNT_H */
diff --cc net/sunrpc/clnt.c
index cfcbe92be38e,8d68efd2026f..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -2635,6 -2674,55 +2635,58 @@@ out_put_switch
  }
  EXPORT_SYMBOL_GPL(rpc_clnt_add_xprt);
  
++<<<<<<< HEAD
++=======
+ static int
+ rpc_xprt_cap_max_reconnect_timeout(struct rpc_clnt *clnt,
+ 		struct rpc_xprt *xprt,
+ 		void *data)
+ {
+ 	unsigned long timeout = *((unsigned long *)data);
+ 
+ 	if (timeout < xprt->max_reconnect_timeout)
+ 		xprt->max_reconnect_timeout = timeout;
+ 	return 0;
+ }
+ 
+ void
+ rpc_cap_max_reconnect_timeout(struct rpc_clnt *clnt, unsigned long timeo)
+ {
+ 	rpc_clnt_iterate_for_each_xprt(clnt,
+ 			rpc_xprt_cap_max_reconnect_timeout,
+ 			&timeo);
+ }
+ EXPORT_SYMBOL_GPL(rpc_cap_max_reconnect_timeout);
+ 
+ void rpc_clnt_xprt_switch_put(struct rpc_clnt *clnt)
+ {
+ 	xprt_switch_put(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));
+ }
+ EXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_put);
+ 
+ void rpc_clnt_xprt_switch_add_xprt(struct rpc_clnt *clnt, struct rpc_xprt *xprt)
+ {
+ 	rpc_xprt_switch_add_xprt(rcu_dereference(clnt->cl_xpi.xpi_xpswitch),
+ 				 xprt);
+ }
+ EXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_add_xprt);
+ 
+ bool rpc_clnt_xprt_switch_has_addr(struct rpc_clnt *clnt,
+ 				   const struct sockaddr *sap)
+ {
+ 	struct rpc_xprt_switch *xps;
+ 	bool ret;
+ 
+ 	xps = rcu_dereference(clnt->cl_xpi.xpi_xpswitch);
+ 
+ 	rcu_read_lock();
+ 	ret = rpc_xprt_switch_has_addr(xps, sap);
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_has_addr);
+ 
++>>>>>>> 39e5d2df959d (SUNRPC search xprt switch for sockaddr)
  #if IS_ENABLED(CONFIG_SUNRPC_DEBUG)
  static void rpc_show_header(void)
  {
* Unmerged path include/linux/sunrpc/clnt.h
diff --git a/include/linux/sunrpc/xprtmultipath.h b/include/linux/sunrpc/xprtmultipath.h
index 5a9acffa41be..507418c1c69e 100644
--- a/include/linux/sunrpc/xprtmultipath.h
+++ b/include/linux/sunrpc/xprtmultipath.h
@@ -66,4 +66,6 @@ extern struct rpc_xprt *xprt_iter_xprt(struct rpc_xprt_iter *xpi);
 extern struct rpc_xprt *xprt_iter_get_xprt(struct rpc_xprt_iter *xpi);
 extern struct rpc_xprt *xprt_iter_get_next(struct rpc_xprt_iter *xpi);
 
+extern bool rpc_xprt_switch_has_addr(struct rpc_xprt_switch *xps,
+		const struct sockaddr *sap);
 #endif
* Unmerged path net/sunrpc/clnt.c
diff --git a/net/sunrpc/xprtmultipath.c b/net/sunrpc/xprtmultipath.c
index 66c9d63f4797..ae92a9e9ba52 100644
--- a/net/sunrpc/xprtmultipath.c
+++ b/net/sunrpc/xprtmultipath.c
@@ -15,6 +15,7 @@
 #include <asm/cmpxchg.h>
 #include <linux/spinlock.h>
 #include <linux/sunrpc/xprt.h>
+#include <linux/sunrpc/addr.h>
 #include <linux/sunrpc/xprtmultipath.h>
 
 typedef struct rpc_xprt *(*xprt_switch_find_xprt_t)(struct list_head *head,
@@ -49,7 +50,8 @@ void rpc_xprt_switch_add_xprt(struct rpc_xprt_switch *xps,
 	if (xprt == NULL)
 		return;
 	spin_lock(&xps->xps_lock);
-	if (xps->xps_net == xprt->xprt_net || xps->xps_net == NULL)
+	if ((xps->xps_net == xprt->xprt_net || xps->xps_net == NULL) &&
+	    !rpc_xprt_switch_has_addr(xps, (struct sockaddr *)&xprt->addr))
 		xprt_switch_add_xprt_locked(xps, xprt);
 	spin_unlock(&xps->xps_lock);
 }
@@ -232,6 +234,26 @@ struct rpc_xprt *xprt_iter_current_entry(struct rpc_xprt_iter *xpi)
 	return xprt_switch_find_current_entry(head, xpi->xpi_cursor);
 }
 
+bool rpc_xprt_switch_has_addr(struct rpc_xprt_switch *xps,
+			      const struct sockaddr *sap)
+{
+	struct list_head *head;
+	struct rpc_xprt *pos;
+
+	if (xps == NULL || sap == NULL)
+		return false;
+
+	head = &xps->xps_xprt_list;
+	list_for_each_entry_rcu(pos, head, xprt_switch) {
+		if (rpc_cmp_addr_port(sap, (struct sockaddr *)&pos->addr)) {
+			pr_info("RPC:   addr %s already in xprt switch\n",
+				pos->address_strings[RPC_DISPLAY_ADDR]);
+			return true;
+		}
+	}
+	return false;
+}
+
 static
 struct rpc_xprt *xprt_switch_find_next_entry(struct list_head *head,
 		const struct rpc_xprt *cur)
