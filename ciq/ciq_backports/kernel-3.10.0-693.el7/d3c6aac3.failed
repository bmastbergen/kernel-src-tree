mmc: delete is_first_req parameter from pre-request callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] delete is_first_req parameter from pre-request callback (Don Zickus) [1430497]
Rebuild_FUZZ: 95.65%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit d3c6aac3bdfe97b8b44db6a8aba59786cb9531dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d3c6aac3.failed

The void (*pre_req) callback in the struct mmc_host_ops vtable
is passing an argument "is_first_req" indicating whether this is
the first request or not.

None of the in-kernel users use this parameter: instead, since
they all just do variants of dma_map* they use the DMA cookie
to indicate whether a pre* callback has already been done for
a request when they decide how to handle it.

Delete the parameter from the callback and all users, as it is
just pointless cruft.

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit d3c6aac3bdfe97b8b44db6a8aba59786cb9531dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/jz4740_mmc.c
#	drivers/mmc/host/mtk-sd.c
diff --cc drivers/mmc/host/jz4740_mmc.c
index 2391c6b7a4bb,819ad32964fc..000000000000
--- a/drivers/mmc/host/jz4740_mmc.c
+++ b/drivers/mmc/host/jz4740_mmc.c
@@@ -136,8 -144,219 +136,209 @@@ struct jz4740_mmc_host 
  	struct timer_list timeout_timer;
  	struct sg_mapping_iter miter;
  	enum jz4740_mmc_state state;
 -
 -	/* DMA support */
 -	struct dma_chan *dma_rx;
 -	struct dma_chan *dma_tx;
 -	struct jz4740_mmc_host_next next_data;
 -	bool use_dma;
 -	int sg_len;
 -
 -/* The DMA trigger level is 8 words, that is to say, the DMA read
 - * trigger is when data words in MSC_RXFIFO is >= 8 and the DMA write
 - * trigger is when data words in MSC_TXFIFO is < 8.
 - */
 -#define JZ4740_MMC_FIFO_HALF_SIZE 8
  };
  
++<<<<<<< HEAD
++=======
+ /*----------------------------------------------------------------------------*/
+ /* DMA infrastructure */
+ 
+ static void jz4740_mmc_release_dma_channels(struct jz4740_mmc_host *host)
+ {
+ 	if (!host->use_dma)
+ 		return;
+ 
+ 	dma_release_channel(host->dma_tx);
+ 	dma_release_channel(host->dma_rx);
+ }
+ 
+ static int jz4740_mmc_acquire_dma_channels(struct jz4740_mmc_host *host)
+ {
+ 	dma_cap_mask_t mask;
+ 
+ 	dma_cap_zero(mask);
+ 	dma_cap_set(DMA_SLAVE, mask);
+ 
+ 	host->dma_tx = dma_request_channel(mask, NULL, host);
+ 	if (!host->dma_tx) {
+ 		dev_err(mmc_dev(host->mmc), "Failed to get dma_tx channel\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	host->dma_rx = dma_request_channel(mask, NULL, host);
+ 	if (!host->dma_rx) {
+ 		dev_err(mmc_dev(host->mmc), "Failed to get dma_rx channel\n");
+ 		goto free_master_write;
+ 	}
+ 
+ 	/* Initialize DMA pre request cookie */
+ 	host->next_data.cookie = 1;
+ 
+ 	return 0;
+ 
+ free_master_write:
+ 	dma_release_channel(host->dma_tx);
+ 	return -ENODEV;
+ }
+ 
+ static inline int jz4740_mmc_get_dma_dir(struct mmc_data *data)
+ {
+ 	return (data->flags & MMC_DATA_READ) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+ }
+ 
+ static inline struct dma_chan *jz4740_mmc_get_dma_chan(struct jz4740_mmc_host *host,
+ 						       struct mmc_data *data)
+ {
+ 	return (data->flags & MMC_DATA_READ) ? host->dma_rx : host->dma_tx;
+ }
+ 
+ static void jz4740_mmc_dma_unmap(struct jz4740_mmc_host *host,
+ 				 struct mmc_data *data)
+ {
+ 	struct dma_chan *chan = jz4740_mmc_get_dma_chan(host, data);
+ 	enum dma_data_direction dir = jz4740_mmc_get_dma_dir(data);
+ 
+ 	dma_unmap_sg(chan->device->dev, data->sg, data->sg_len, dir);
+ }
+ 
+ /* Prepares DMA data for current/next transfer, returns non-zero on failure */
+ static int jz4740_mmc_prepare_dma_data(struct jz4740_mmc_host *host,
+ 				       struct mmc_data *data,
+ 				       struct jz4740_mmc_host_next *next,
+ 				       struct dma_chan *chan)
+ {
+ 	struct jz4740_mmc_host_next *next_data = &host->next_data;
+ 	enum dma_data_direction dir = jz4740_mmc_get_dma_dir(data);
+ 	int sg_len;
+ 
+ 	if (!next && data->host_cookie &&
+ 	    data->host_cookie != host->next_data.cookie) {
+ 		dev_warn(mmc_dev(host->mmc),
+ 			 "[%s] invalid cookie: data->host_cookie %d host->next_data.cookie %d\n",
+ 			 __func__,
+ 			 data->host_cookie,
+ 			 host->next_data.cookie);
+ 		data->host_cookie = 0;
+ 	}
+ 
+ 	/* Check if next job is already prepared */
+ 	if (next || data->host_cookie != host->next_data.cookie) {
+ 		sg_len = dma_map_sg(chan->device->dev,
+ 				    data->sg,
+ 				    data->sg_len,
+ 				    dir);
+ 
+ 	} else {
+ 		sg_len = next_data->sg_len;
+ 		next_data->sg_len = 0;
+ 	}
+ 
+ 	if (sg_len <= 0) {
+ 		dev_err(mmc_dev(host->mmc),
+ 			"Failed to map scatterlist for DMA operation\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (next) {
+ 		next->sg_len = sg_len;
+ 		data->host_cookie = ++next->cookie < 0 ? 1 : next->cookie;
+ 	} else
+ 		host->sg_len = sg_len;
+ 
+ 	return 0;
+ }
+ 
+ static int jz4740_mmc_start_dma_transfer(struct jz4740_mmc_host *host,
+ 					 struct mmc_data *data)
+ {
+ 	int ret;
+ 	struct dma_chan *chan;
+ 	struct dma_async_tx_descriptor *desc;
+ 	struct dma_slave_config conf = {
+ 		.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,
+ 		.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,
+ 		.src_maxburst = JZ4740_MMC_FIFO_HALF_SIZE,
+ 		.dst_maxburst = JZ4740_MMC_FIFO_HALF_SIZE,
+ 	};
+ 
+ 	if (data->flags & MMC_DATA_WRITE) {
+ 		conf.direction = DMA_MEM_TO_DEV;
+ 		conf.dst_addr = host->mem_res->start + JZ_REG_MMC_TXFIFO;
+ 		conf.slave_id = JZ4740_DMA_TYPE_MMC_TRANSMIT;
+ 		chan = host->dma_tx;
+ 	} else {
+ 		conf.direction = DMA_DEV_TO_MEM;
+ 		conf.src_addr = host->mem_res->start + JZ_REG_MMC_RXFIFO;
+ 		conf.slave_id = JZ4740_DMA_TYPE_MMC_RECEIVE;
+ 		chan = host->dma_rx;
+ 	}
+ 
+ 	ret = jz4740_mmc_prepare_dma_data(host, data, NULL, chan);
+ 	if (ret)
+ 		return ret;
+ 
+ 	dmaengine_slave_config(chan, &conf);
+ 	desc = dmaengine_prep_slave_sg(chan,
+ 				       data->sg,
+ 				       host->sg_len,
+ 				       conf.direction,
+ 				       DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+ 	if (!desc) {
+ 		dev_err(mmc_dev(host->mmc),
+ 			"Failed to allocate DMA %s descriptor",
+ 			 conf.direction == DMA_MEM_TO_DEV ? "TX" : "RX");
+ 		goto dma_unmap;
+ 	}
+ 
+ 	dmaengine_submit(desc);
+ 	dma_async_issue_pending(chan);
+ 
+ 	return 0;
+ 
+ dma_unmap:
+ 	jz4740_mmc_dma_unmap(host, data);
+ 	return -ENOMEM;
+ }
+ 
+ static void jz4740_mmc_pre_request(struct mmc_host *mmc,
+ 				   struct mmc_request *mrq)
+ {
+ 	struct jz4740_mmc_host *host = mmc_priv(mmc);
+ 	struct mmc_data *data = mrq->data;
+ 	struct jz4740_mmc_host_next *next_data = &host->next_data;
+ 
+ 	BUG_ON(data->host_cookie);
+ 
+ 	if (host->use_dma) {
+ 		struct dma_chan *chan = jz4740_mmc_get_dma_chan(host, data);
+ 
+ 		if (jz4740_mmc_prepare_dma_data(host, data, next_data, chan))
+ 			data->host_cookie = 0;
+ 	}
+ }
+ 
+ static void jz4740_mmc_post_request(struct mmc_host *mmc,
+ 				    struct mmc_request *mrq,
+ 				    int err)
+ {
+ 	struct jz4740_mmc_host *host = mmc_priv(mmc);
+ 	struct mmc_data *data = mrq->data;
+ 
+ 	if (host->use_dma && data->host_cookie) {
+ 		jz4740_mmc_dma_unmap(host, data);
+ 		data->host_cookie = 0;
+ 	}
+ 
+ 	if (err) {
+ 		struct dma_chan *chan = jz4740_mmc_get_dma_chan(host, data);
+ 
+ 		dmaengine_terminate_all(chan);
+ 	}
+ }
+ 
+ /*----------------------------------------------------------------------------*/
+ 
++>>>>>>> d3c6aac3bdfe (mmc: delete is_first_req parameter from pre-request callback)
  static void jz4740_mmc_set_irq_enabled(struct jz4740_mmc_host *host,
  	unsigned int irq, bool enabled)
  {
* Unmerged path drivers/mmc/host/mtk-sd.c
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8a58585e3417..f54ee8d60ad2 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -610,18 +610,15 @@ EXPORT_SYMBOL(mmc_is_req_done);
  *	mmc_pre_req - Prepare for a new request
  *	@host: MMC host to prepare command
  *	@mrq: MMC request to prepare for
- *	@is_first_req: true if there is no previous started request
- *                     that may run in parellel to this call, otherwise false
  *
  *	mmc_pre_req() is called in prior to mmc_start_req() to let
  *	host prepare for the new request. Preparation of a request may be
  *	performed while another request is running on the host.
  */
-static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
-		 bool is_first_req)
+static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	if (host->ops->pre_req)
-		host->ops->pre_req(host, mrq, is_first_req);
+		host->ops->pre_req(host, mrq);
 }
 
 /**
@@ -666,7 +663,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 
 	/* Prepare a new request */
 	if (areq)
-		mmc_pre_req(host, areq->mrq, !host->areq);
+		mmc_pre_req(host, areq->mrq);
 
 	if (host->areq) {
 		status = mmc_wait_for_data_req_done(host, host->areq->mrq, areq);
@@ -695,7 +692,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 
 			/* prepare the request again */
 			if (areq)
-				mmc_pre_req(host, areq->mrq, !host->areq);
+				mmc_pre_req(host, areq->mrq);
 		}
 	}
 
diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index b0f46021389f..dd83e2bd002d 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -490,8 +490,7 @@ static int dw_mci_pre_dma_transfer(struct dw_mci *host,
 }
 
 static void dw_mci_pre_req(struct mmc_host *mmc,
-			   struct mmc_request *mrq,
-			   bool is_first_req)
+			   struct mmc_request *mrq)
 {
 	struct dw_mci_slot *slot = mmc_priv(mmc);
 	struct mmc_data *data = mrq->data;
* Unmerged path drivers/mmc/host/jz4740_mmc.c
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index f4f3038c1df0..140ef165d83c 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -577,8 +577,7 @@ static void mmci_get_next_data(struct mmci_host *host, struct mmc_data *data)
 	next->dma_chan = NULL;
 }
 
-static void mmci_pre_request(struct mmc_host *mmc, struct mmc_request *mrq,
-			     bool is_first_req)
+static void mmci_pre_request(struct mmc_host *mmc, struct mmc_request *mrq)
 {
 	struct mmci_host *host = mmc_priv(mmc);
 	struct mmc_data *data = mrq->data;
* Unmerged path drivers/mmc/host/mtk-sd.c
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index eccedc7d06a4..b69534be5528 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -1421,8 +1421,7 @@ static void omap_hsmmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
 	}
 }
 
-static void omap_hsmmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq,
-			       bool is_first_req)
+static void omap_hsmmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)
 {
 	struct omap_hsmmc_host *host = mmc_priv(mmc);
 
diff --git a/drivers/mmc/host/rtsx_pci_sdmmc.c b/drivers/mmc/host/rtsx_pci_sdmmc.c
index 3ccaa1415f33..ecb99a8d2fa2 100644
--- a/drivers/mmc/host/rtsx_pci_sdmmc.c
+++ b/drivers/mmc/host/rtsx_pci_sdmmc.c
@@ -190,8 +190,7 @@ static int sd_pre_dma_transfer(struct realtek_pci_sdmmc *host,
 	return using_cookie;
 }
 
-static void sdmmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq,
-		bool is_first_req)
+static void sdmmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)
 {
 	struct realtek_pci_sdmmc *host = mmc_priv(mmc);
 	struct mmc_data *data = mrq->data;
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 236982c75602..1966f1c20c16 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2175,8 +2175,7 @@ static void sdhci_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
 	data->host_cookie = COOKIE_UNMAPPED;
 }
 
-static void sdhci_pre_req(struct mmc_host *mmc, struct mmc_request *mrq,
-			       bool is_first_req)
+static void sdhci_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)
 {
 	struct sdhci_host *host = mmc_priv(mmc);
 
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 79227b5a0efb..077583dcff93 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -93,8 +93,7 @@ struct mmc_host_ops {
 	 */
 	void	(*post_req)(struct mmc_host *host, struct mmc_request *req,
 			    int err);
-	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req,
-			   bool is_first_req);
+	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 
 	/*
