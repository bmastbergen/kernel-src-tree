autofs4: use pr_xxx() macros directly for logging

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ian Kent <ikent@redhat.com>
commit 8a78d59304102d36a0cd9b4d81e8e48087ffafd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8a78d593.failed

Use the standard pr_xxx() log macros directly for log prints instead of
the AUTOFS_XXX() macros.

	Signed-off-by: Ian Kent <ikent@redhat.com>
	Cc: Joe Perches <joe@perches.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8a78d59304102d36a0cd9b4d81e8e48087ffafd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/autofs_i.h
#	fs/autofs4/dev-ioctl.c
#	fs/autofs4/expire.c
#	fs/autofs4/inode.c
#	fs/autofs4/root.c
#	fs/autofs4/waitq.c
diff --cc fs/autofs4/autofs_i.h
index 463026a80dfa,f0d268b97d19..000000000000
--- a/fs/autofs4/autofs_i.h
+++ b/fs/autofs4/autofs_i.h
@@@ -39,24 -35,19 +39,31 @@@
  
  /* #define DEBUG */
  
++<<<<<<< HEAD
 +#define DPRINTK(fmt, ...)				\
 +	pr_debug(KBUILD_MODNAME ":pid:%d:%s: " fmt "\n",\
 +		current->pid, __func__, ##__VA_ARGS__)
 +
 +#define AUTOFS_WARN(fmt, ...)				\
 +	pr_warn(KBUILD_MODNAME ":pid:%d:%s: " fmt "\n",	\
 +		current->pid, __func__, ##__VA_ARGS__)
 +
 +#define AUTOFS_ERROR(fmt, ...)				\
 +	pr_err(KBUILD_MODNAME ":pid:%d:%s: " fmt "\n",	\
 +		current->pid, __func__, ##__VA_ARGS__)
++=======
+ #ifdef pr_fmt
+ #undef pr_fmt
+ #endif
+ #define pr_fmt(fmt) KBUILD_MODNAME ":pid:%d:%s: " fmt, current->pid, __func__
 -
 -/*
 - * Unified info structure.  This is pointed to by both the dentry and
 - * inode structures.  Each file in the filesystem has an instance of this
 - * structure.  It holds a reference to the dentry, so dentries are never
 - * flushed while the file exists.  All name lookups are dealt with at the
 - * dentry level, although the filesystem can interfere in the validation
 - * process.  Readdir is implemented by traversing the dentry lists.
 - */
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
 +
 +/* Unified info structure.  This is pointed to by both the dentry and
 +   inode structures.  Each file in the filesystem has an instance of this
 +   structure.  It holds a reference to the dentry, so dentries are never
 +   flushed while the file exists.  All name lookups are dealt with at the
 +   dentry level, although the filesystem can interfere in the validation
 +   process.  Readdir is implemented by traversing the dentry lists. */
  struct autofs_info {
  	struct dentry	*dentry;
  	struct inode	*inode;
diff --cc fs/autofs4/dev-ioctl.c
index 9b97001098b9,c7fcc7438843..000000000000
--- a/fs/autofs4/dev-ioctl.c
+++ b/fs/autofs4/dev-ioctl.c
@@@ -72,13 -72,13 +72,23 @@@ static int check_dev_ioctl_version(int 
  {
  	int err = 0;
  
++<<<<<<< HEAD
 +	if ((AUTOFS_DEV_IOCTL_VERSION_MAJOR != param->ver_major) ||
 +	    (AUTOFS_DEV_IOCTL_VERSION_MINOR < param->ver_minor)) {
 +		AUTOFS_WARN("ioctl control interface version mismatch: "
 +		     "kernel(%u.%u), user(%u.%u), cmd(%d)",
 +		     AUTOFS_DEV_IOCTL_VERSION_MAJOR,
 +		     AUTOFS_DEV_IOCTL_VERSION_MINOR,
 +		     param->ver_major, param->ver_minor, cmd);
++=======
+ 	if ((param->ver_major != AUTOFS_DEV_IOCTL_VERSION_MAJOR) ||
+ 	    (param->ver_minor > AUTOFS_DEV_IOCTL_VERSION_MINOR)) {
+ 		pr_warn("ioctl control interface version mismatch: "
+ 			"kernel(%u.%u), user(%u.%u), cmd(%d)\n",
+ 			AUTOFS_DEV_IOCTL_VERSION_MAJOR,
+ 			AUTOFS_DEV_IOCTL_VERSION_MINOR,
+ 			param->ver_major, param->ver_minor, cmd);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		err = -EINVAL;
  	}
  
@@@ -129,24 -129,24 +139,39 @@@ static int validate_dev_ioctl(int cmd, 
  
  	err = check_dev_ioctl_version(cmd, param);
  	if (err) {
++<<<<<<< HEAD
 +		AUTOFS_WARN("invalid device control module version "
 +		     "supplied for cmd(0x%08x)", cmd);
++=======
+ 		pr_warn("invalid device control module version "
+ 			"supplied for cmd(0x%08x)\n", cmd);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		goto out;
  	}
  
  	if (param->size > sizeof(*param)) {
  		err = invalid_str(param->path, param->size - sizeof(*param));
  		if (err) {
++<<<<<<< HEAD
 +			AUTOFS_WARN(
 +			  "path string terminator missing for cmd(0x%08x)",
++=======
+ 			pr_warn(
+ 			  "path string terminator missing for cmd(0x%08x)\n",
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  			  cmd);
  			goto out;
  		}
  
  		err = check_name(param->path);
  		if (err) {
++<<<<<<< HEAD
 +			AUTOFS_WARN("invalid path supplied for cmd(0x%08x)",
 +				    cmd);
++=======
+ 			pr_warn("invalid path supplied for cmd(0x%08x)\n",
+ 				cmd);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  			goto out;
  		}
  	}
@@@ -370,7 -373,7 +395,11 @@@ static int autofs_dev_ioctl_setpipefd(s
  		new_pid = get_task_pid(current, PIDTYPE_PGID);
  
  		if (ns_of_pid(new_pid) != ns_of_pid(sbi->oz_pgrp)) {
++<<<<<<< HEAD
 +			AUTOFS_WARN("not allowed to change PID namespace");
++=======
+ 			pr_warn("not allowed to change PID namespace\n");
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  			err = -EINVAL;
  			goto out;
  		}
@@@ -655,7 -661,7 +684,11 @@@ static int _autofs_dev_ioctl(unsigned i
  
  	fn = lookup_dev_ioctl(cmd);
  	if (!fn) {
++<<<<<<< HEAD
 +		AUTOFS_WARN("unknown command 0x%08x", command);
++=======
+ 		pr_warn("unknown command 0x%08x\n", command);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		return -ENOTTY;
  	}
  
@@@ -753,7 -754,7 +786,11 @@@ int __init autofs_dev_ioctl_init(void
  
  	r = misc_register(&_autofs_dev_ioctl_misc);
  	if (r) {
++<<<<<<< HEAD
 +		AUTOFS_ERROR("misc_register failed for control device");
++=======
+ 		pr_err("misc_register failed for control device\n");
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		return r;
  	}
  
diff --cc fs/autofs4/expire.c
index 683a5b9ce22a,9510d8d2e9cd..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -41,8 -37,7 +41,12 @@@ static int autofs4_mount_busy(struct vf
  	struct path path = {.mnt = mnt, .dentry = dentry};
  	int status = 1;
  
++<<<<<<< HEAD
 +	DPRINTK("dentry %p %.*s",
 +		dentry, (int)dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("dentry %p %pd\n", dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	path_get(&path);
  
@@@ -66,7 -63,7 +70,11 @@@
  
  	status = 0;
  done:
++<<<<<<< HEAD
 +	DPRINTK("returning = %d", status);
++=======
+ 	pr_debug("returning = %d\n", status);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  	path_put(&path);
  	return status;
  }
@@@ -188,12 -185,11 +196,16 @@@ again
   * autofs submounts.
   */
  static int autofs4_direct_busy(struct vfsmount *mnt,
 -			       struct dentry *top,
 -			       unsigned long timeout,
 -			       int do_now)
 +				struct dentry *top,
 +				unsigned long timeout,
 +				int do_now)
  {
++<<<<<<< HEAD
 +	DPRINTK("top %p %.*s",
 +		top, (int) top->d_name.len, top->d_name.name);
++=======
+ 	pr_debug("top %p %pd\n", top, top);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	/* If it's busy update the expiry counters */
  	if (!may_umount_tree(mnt)) {
@@@ -221,8 -220,7 +233,12 @@@ static int autofs4_tree_busy(struct vfs
  	struct autofs_info *top_ino = autofs4_dentry_ino(top);
  	struct dentry *p;
  
++<<<<<<< HEAD
 +	DPRINTK("top %p %.*s",
 +		top, (int)top->d_name.len, top->d_name.name);
++=======
+ 	pr_debug("top %p %pd\n", top, top);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	/* Negative dentry - give up */
  	if (!simple_positive(top))
@@@ -230,8 -228,7 +246,12 @@@
  
  	p = NULL;
  	while ((p = get_next_positive_dentry(p, top))) {
++<<<<<<< HEAD
 +		DPRINTK("dentry %p %.*s",
 +			p, (int) p->d_name.len, p->d_name.name);
++=======
+ 		pr_debug("dentry %p %pd\n", p, p);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  		/*
  		 * Is someone visiting anywhere in the subtree ?
@@@ -277,13 -274,11 +297,21 @@@ static struct dentry *autofs4_check_lea
  {
  	struct dentry *p;
  
++<<<<<<< HEAD
 +	DPRINTK("parent %p %.*s",
 +		parent, (int)parent->d_name.len, parent->d_name.name);
 +
 +	p = NULL;
 +	while ((p = get_next_positive_dentry(p, parent))) {
 +		DPRINTK("dentry %p %.*s",
 +			p, (int) p->d_name.len, p->d_name.name);
++=======
+ 	pr_debug("parent %p %pd\n", parent, parent);
+ 
+ 	p = NULL;
+ 	while ((p = get_next_positive_dentry(p, parent))) {
+ 		pr_debug("dentry %p %pd\n", p, p);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  		if (d_mountpoint(p)) {
  			/* Can we umount this guy */
@@@ -368,8 -363,7 +396,12 @@@ static struct dentry *should_expire(str
  	 *	   offset (autofs-5.0+).
  	 */
  	if (d_mountpoint(dentry)) {
++<<<<<<< HEAD
 +		DPRINTK("checking mountpoint %p %.*s",
 +			dentry, (int)dentry->d_name.len, dentry->d_name.name);
++=======
+ 		pr_debug("checking mountpoint %p %pd\n", dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  		/* Can we umount this guy */
  		if (autofs4_mount_busy(mnt, dentry))
@@@ -381,9 -375,8 +413,14 @@@
  		return NULL;
  	}
  
++<<<<<<< HEAD
 +	if (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)) {
 +		DPRINTK("checking symlink %p %.*s",
 +			dentry, (int)dentry->d_name.len, dentry->d_name.name);
++=======
+ 	if (d_really_is_positive(dentry) && d_is_symlink(dentry)) {
+ 		pr_debug("checking symlink %p %pd\n", dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		/*
  		 * A symlink can't be "busy" in the usual sense so
  		 * just check last used for expire timeout.
@@@ -479,8 -473,7 +516,12 @@@ struct dentry *autofs4_expire_indirect(
  	return NULL;
  
  found:
++<<<<<<< HEAD
 +	DPRINTK("returning %p %.*s",
 +		expired, (int)expired->d_name.len, expired->d_name.name);
++=======
+ 	pr_debug("returning %p %pd\n", expired, expired);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  	ino->flags |= AUTOFS_INF_EXPIRING;
  	smp_mb();
  	ino->flags &= ~AUTOFS_INF_NO_RCU;
@@@ -512,13 -505,12 +553,21 @@@ int autofs4_expire_wait(struct dentry *
  	if (ino->flags & AUTOFS_INF_EXPIRING) {
  		spin_unlock(&sbi->fs_lock);
  
++<<<<<<< HEAD
 +		DPRINTK("waiting for expire %p name=%.*s",
 +			 dentry, dentry->d_name.len, dentry->d_name.name);
++=======
+ 		pr_debug("waiting for expire %p name=%pd\n", dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  		status = autofs4_wait(sbi, dentry, NFY_NONE);
  		wait_for_completion(&ino->expire_complete);
  
++<<<<<<< HEAD
 +		DPRINTK("expire done status=%d", status);
++=======
+ 		pr_debug("expire done status=%d\n", status);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  		if (d_unhashed(dentry))
  			return -EAGAIN;
diff --cc fs/autofs4/inode.c
index 396178847bf6,61b21051bd5a..000000000000
--- a/fs/autofs4/inode.c
+++ b/fs/autofs4/inode.c
@@@ -62,7 -60,7 +62,11 @@@ void autofs4_kill_sb(struct super_bloc
  		put_pid(sbi->oz_pgrp);
  	}
  
++<<<<<<< HEAD
 +	DPRINTK("shutting down");
++=======
+ 	pr_debug("shutting down\n");
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  	kill_litter_super(sb);
  	if (sbi)
  		kfree_rcu(sbi, rcu);
@@@ -222,7 -221,7 +226,11 @@@ int autofs4_fill_super(struct super_blo
  	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
  	if (!sbi)
  		return -ENOMEM;
++<<<<<<< HEAD
 +	DPRINTK("starting up, sbi = %p",sbi);
++=======
+ 	pr_debug("starting up, sbi = %p\n", sbi);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	s->s_fs_info = sbi;
  	sbi->magic = AUTOFS_SBI_MAGIC;
@@@ -271,14 -270,14 +279,22 @@@
  	if (parse_options(data, &pipefd, &root_inode->i_uid, &root_inode->i_gid,
  			  &pgrp, &pgrp_set, &sbi->type, &sbi->min_proto,
  			  &sbi->max_proto)) {
++<<<<<<< HEAD
 +		AUTOFS_ERROR("called with bogus options");
++=======
+ 		pr_err("called with bogus options\n");
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		goto fail_dput;
  	}
  
  	if (pgrp_set) {
  		sbi->oz_pgrp = find_get_pid(pgrp);
  		if (!sbi->oz_pgrp) {
++<<<<<<< HEAD
 +			AUTOFS_ERROR("could not find process group %d",
++=======
+ 			pr_err("could not find process group %d\n",
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  				pgrp);
  			goto fail_dput;
  		}
@@@ -295,10 -294,10 +311,17 @@@
  	/* Couldn't this be tested earlier? */
  	if (sbi->max_proto < AUTOFS_MIN_PROTO_VERSION ||
  	    sbi->min_proto > AUTOFS_MAX_PROTO_VERSION) {
++<<<<<<< HEAD
 +		AUTOFS_ERROR("kernel does not match daemon version "
 +			     "daemon (%d, %d) kernel (%d, %d)",
 +			sbi->min_proto, sbi->max_proto,
 +			AUTOFS_MIN_PROTO_VERSION, AUTOFS_MAX_PROTO_VERSION);
++=======
+ 		pr_err("kernel does not match daemon version "
+ 		       "daemon (%d, %d) kernel (%d, %d)\n",
+ 		       sbi->min_proto, sbi->max_proto,
+ 		       AUTOFS_MIN_PROTO_VERSION, AUTOFS_MAX_PROTO_VERSION);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		goto fail_dput;
  	}
  
@@@ -309,11 -308,11 +332,19 @@@
  		sbi->version = sbi->max_proto;
  	sbi->sub_version = AUTOFS_PROTO_SUBVERSION;
  
++<<<<<<< HEAD
 +	DPRINTK("pipe fd = %d, pgrp = %u", pipefd, pid_nr(sbi->oz_pgrp));
 +	pipe = fget(pipefd);
 +
 +	if (!pipe) {
 +		AUTOFS_ERROR("could not open pipe file descriptor");
++=======
+ 	pr_debug("pipe fd = %d, pgrp = %u\n", pipefd, pid_nr(sbi->oz_pgrp));
+ 	pipe = fget(pipefd);
+ 
+ 	if (!pipe) {
+ 		pr_err("could not open pipe file descriptor\n");
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		goto fail_dput;
  	}
  	ret = autofs_prepare_pipe(pipe);
@@@ -333,7 -332,7 +364,11 @@@
  	 * Failure ... clean up.
  	 */
  fail_fput:
++<<<<<<< HEAD
 +	AUTOFS_ERROR("pipe file descriptor does not contain proper ops");
++=======
+ 	pr_err("pipe file descriptor does not contain proper ops\n");
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  	fput(pipe);
  	/* fall through */
  fail_dput:
diff --cc fs/autofs4/root.c
index c8ae501dec34,9328b5861c7a..000000000000
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@@ -108,8 -108,7 +108,12 @@@ static int autofs4_dir_open(struct inod
  	struct dentry *dentry = file->f_path.dentry;
  	struct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);
  
++<<<<<<< HEAD
 +	DPRINTK("file=%p dentry=%p %.*s",
 +		file, dentry, dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("file=%p dentry=%p %pd\n", file, dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	if (autofs4_oz_mode(sbi))
  		goto out;
@@@ -139,7 -138,7 +143,11 @@@ static void autofs4_dentry_release(stru
  	struct autofs_info *ino = autofs4_dentry_ino(de);
  	struct autofs_sb_info *sbi = autofs4_sbi(de->d_sb);
  
++<<<<<<< HEAD
 +	DPRINTK("releasing %p", de);
++=======
+ 	pr_debug("releasing %p\n", de);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	if (!ino)
  		return;
@@@ -279,10 -278,9 +287,16 @@@ static int autofs4_mount_wait(struct de
  	if (ino->flags & AUTOFS_INF_PENDING) {
  		if (rcu_walk)
  			return -ECHILD;
++<<<<<<< HEAD
 +		DPRINTK("waiting for mount name=%.*s",
 +			dentry->d_name.len, dentry->d_name.name);
 +		status = autofs4_wait(sbi, dentry, NFY_MOUNT);
 +		DPRINTK("mount wait done status=%d", status);
++=======
+ 		pr_debug("waiting for mount name=%pd\n", dentry);
+ 		status = autofs4_wait(sbi, dentry, NFY_MOUNT);
+ 		pr_debug("mount wait done status=%d\n", status);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  	}
  	ino->last_used = jiffies;
  	return status;
@@@ -340,8 -340,7 +354,12 @@@ static struct vfsmount *autofs4_d_autom
  	struct autofs_info *ino = autofs4_dentry_ino(dentry);
  	int status;
  
++<<<<<<< HEAD
 +	DPRINTK("dentry=%p %.*s",
 +		dentry, dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("dentry=%p %pd\n", dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	/* The daemon never triggers a mount. */
  	if (autofs4_oz_mode(sbi))
@@@ -428,8 -427,7 +446,12 @@@ static int autofs4_d_manage(struct dent
  	struct autofs_info *ino = autofs4_dentry_ino(dentry);
  	int status;
  
++<<<<<<< HEAD
 +	DPRINTK("dentry=%p %.*s",
 +		dentry, dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("dentry=%p %pd\n", dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	/* The daemon never waits. */
  	if (autofs4_oz_mode(sbi)) {
@@@ -504,7 -504,7 +526,11 @@@ static struct dentry *autofs4_lookup(st
  	struct autofs_info *ino;
  	struct dentry *active;
  
++<<<<<<< HEAD
 +	DPRINTK("name = %.*s", dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("name = %pd\n", dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	/* File name too long to exist */
  	if (dentry->d_name.len > NAME_MAX)
@@@ -512,14 -512,14 +538,20 @@@
  
  	sbi = autofs4_sbi(dir->i_sb);
  
++<<<<<<< HEAD
 +	DPRINTK("pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d",
 +		current->pid, task_pgrp_nr(current), sbi->catatonic,
 +		autofs4_oz_mode(sbi));
++=======
+ 	pr_debug("pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\n",
+ 		 current->pid, task_pgrp_nr(current), sbi->catatonic,
+ 		 autofs4_oz_mode(sbi));
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	active = autofs4_lookup_active(dentry);
 -	if (active)
 +	if (active) {
  		return active;
 -	else {
 +	} else {
  		/*
  		 * A dentry that is not within the root can never trigger a
  		 * mount operation, unless the directory already exists, so we
@@@ -556,8 -559,7 +588,12 @@@ static int autofs4_dir_symlink(struct i
  	size_t size = strlen(symname);
  	char *cp;
  
++<<<<<<< HEAD
 +	DPRINTK("%s <- %.*s", symname,
 +		dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("%s <- %pd\n", symname, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	if (!autofs4_oz_mode(sbi))
  		return -EACCES;
@@@ -698,9 -698,8 +734,14 @@@ static int autofs4_dir_rmdir(struct ino
  	struct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);
  	struct autofs_info *ino = autofs4_dentry_ino(dentry);
  	struct autofs_info *p_ino;
++<<<<<<< HEAD
 +	
 +	DPRINTK("dentry %p, removing %.*s",
 +		dentry, dentry->d_name.len, dentry->d_name.name);
++=======
+ 
+ 	pr_debug("dentry %p, removing %pd\n", dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	if (!autofs4_oz_mode(sbi))
  		return -EACCES;
@@@ -742,8 -742,7 +783,12 @@@ static int autofs4_dir_mkdir(struct ino
  	if (!autofs4_oz_mode(sbi))
  		return -EACCES;
  
++<<<<<<< HEAD
 +	DPRINTK("dentry %p, creating %.*s",
 +		dentry, dentry->d_name.len, dentry->d_name.name);
++=======
+ 	pr_debug("dentry %p, creating %pd\n", dentry, dentry);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	BUG_ON(!ino);
  
@@@ -843,7 -844,7 +888,11 @@@ static inline int autofs4_ask_umount(st
  	if (may_umount(mnt))
  		status = 1;
  
++<<<<<<< HEAD
 +	DPRINTK("returning %d", status);
++=======
+ 	pr_debug("returning %d\n", status);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	status = put_user(status, p);
  
@@@ -871,8 -872,8 +920,13 @@@ static int autofs4_root_ioctl_unlocked(
  	struct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);
  	void __user *p = (void __user *)arg;
  
++<<<<<<< HEAD
 +	DPRINTK("cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u",
 +		cmd,arg,sbi,task_pgrp_nr(current));
++=======
+ 	pr_debug("cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\n",
+ 		 cmd, arg, sbi, task_pgrp_nr(current));
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	if (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||
  	     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)
diff --cc fs/autofs4/waitq.c
index 71b3baf9aaca,0146d911f468..000000000000
--- a/fs/autofs4/waitq.c
+++ b/fs/autofs4/waitq.c
@@@ -34,7 -31,7 +34,11 @@@ void autofs4_catatonic_mode(struct auto
  		return;
  	}
  
++<<<<<<< HEAD
 +	DPRINTK("entering catatonic mode");
++=======
+ 	pr_debug("entering catatonic mode\n");
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
  	sbi->catatonic = 1;
  	wq = sbi->queues;
@@@ -102,10 -101,11 +106,16 @@@ static void autofs4_notify_daemon(struc
  	struct file *pipe = NULL;
  	size_t pktsz;
  
++<<<<<<< HEAD
 +	DPRINTK("wait id = 0x%08lx, name = %.*s, type=%d",
 +		(unsigned long) wq->wait_queue_token, wq->name.len, wq->name.name, type);
++=======
+ 	pr_debug("wait id = 0x%08lx, name = %.*s, type=%d\n",
+ 		 (unsigned long) wq->wait_queue_token,
+ 		 wq->name.len, wq->name.name, type);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
 -	memset(&pkt, 0, sizeof(pkt)); /* For security reasons */
 +	memset(&pkt,0,sizeof pkt); /* For security reasons */
  
  	pkt.hdr.proto_version = sbi->version;
  	pkt.hdr.type = type;
@@@ -163,7 -164,7 +173,11 @@@
  		break;
  	}
  	default:
++<<<<<<< HEAD
 +		AUTOFS_WARN("bad type %d!", type);
++=======
+ 		pr_warn("bad type %d!\n", type);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		mutex_unlock(&sbi->wq_mutex);
  		return;
  	}
@@@ -450,17 -453,19 +464,29 @@@ int autofs4_wait(struct autofs_sb_info 
  					autofs_ptype_expire_indirect;
  		}
  
++<<<<<<< HEAD
 +		DPRINTK("new wait id = 0x%08lx, name = %.*s, nfy=%d",
 +			(unsigned long) wq->wait_queue_token, wq->name.len,
 +			wq->name.name, notify);
++=======
+ 		pr_debug("new wait id = 0x%08lx, name = %.*s, nfy=%d\n",
+ 			 (unsigned long) wq->wait_queue_token, wq->name.len,
+ 			 wq->name.name, notify);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  
 -		/*
 -		 * autofs4_notify_daemon() may block; it will unlock ->wq_mutex
 -		 */
 +		/* autofs4_notify_daemon() may block; it will unlock ->wq_mutex */
  		autofs4_notify_daemon(sbi, wq, type);
  	} else {
  		wq->wait_ctr++;
++<<<<<<< HEAD
 +		DPRINTK("existing wait id = 0x%08lx, name = %.*s, nfy=%d",
 +			(unsigned long) wq->wait_queue_token, wq->name.len,
 +			wq->name.name, notify);
++=======
+ 		pr_debug("existing wait id = 0x%08lx, name = %.*s, nfy=%d\n",
+ 			 (unsigned long) wq->wait_queue_token, wq->name.len,
+ 			 wq->name.name, notify);
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  		mutex_unlock(&sbi->wq_mutex);
  		kfree(qstr.name);
  	}
@@@ -489,7 -494,7 +515,11 @@@
  		recalc_sigpending();
  		spin_unlock_irqrestore(&current->sighand->siglock, irqflags);
  	} else {
++<<<<<<< HEAD
 +		DPRINTK("skipped sleeping");
++=======
+ 		pr_debug("skipped sleeping\n");
++>>>>>>> 8a78d5930410 (autofs4: use pr_xxx() macros directly for logging)
  	}
  
  	status = wq->status;
* Unmerged path fs/autofs4/autofs_i.h
* Unmerged path fs/autofs4/dev-ioctl.c
* Unmerged path fs/autofs4/expire.c
* Unmerged path fs/autofs4/inode.c
* Unmerged path fs/autofs4/root.c
* Unmerged path fs/autofs4/waitq.c
