net/mlx5e: ConnectX-4 firmware support for DCBX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: ConnectX-4 firmware support for DCBX (Don Dutile) [1386547 1385330 1417286]
Rebuild_FUZZ: 95.56%
commit-author Huy Nguyen <huyn@mellanox.com>
commit e207b7e991768b724f6d216de49c9b800e203eed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e207b7e9.failed

DBCX by default is controlled by firmware where dcbx capability bit
is set. In this mode, firmware is responsible for reading/sending the
TLV packets from/to the remote partner.

This patch sets up the infrastructure to move between HOST/FW DCBX
control mode.

	Signed-off-by: Huy Nguyen <huyn@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e207b7e991768b724f6d216de49c9b800e203eed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index b01f5bb32ed7,6c954cddfe66..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -187,10 -214,33 +187,34 @@@ struct mlx5e_params 
  	u8  toeplitz_hash_key[40];
  	u32 indirection_rqt[MLX5E_INDIR_RQT_SIZE];
  	bool vlan_strip_disable;
 -	bool rx_am_enabled;
 -	u32 lro_timeout;
 -};
 -
  #ifdef CONFIG_MLX5_CORE_EN_DCB
++<<<<<<< HEAD
 +	struct ieee_ets ets;
++=======
+ struct mlx5e_cee_config {
+ 	/* bw pct for priority group */
+ 	u8                         pg_bw_pct[CEE_DCBX_MAX_PGS];
+ 	u8                         prio_to_pg_map[CEE_DCBX_MAX_PRIO];
+ 	bool                       pfc_setting[CEE_DCBX_MAX_PRIO];
+ 	bool                       pfc_enable;
+ };
+ 
+ enum {
+ 	MLX5_DCB_CHG_RESET,
+ 	MLX5_DCB_NO_CHG,
+ 	MLX5_DCB_CHG_NO_RESET,
+ };
+ 
+ struct mlx5e_dcbx {
+ 	enum mlx5_dcbx_oper_mode   mode;
+ 	struct mlx5e_cee_config    cee_cfg; /* pending configuration */
+ 
+ 	/* The only setting that cannot be read from FW */
+ 	u8                         tc_tsa[IEEE_8021QAZ_MAX_TCS];
+ };
++>>>>>>> e207b7e99176 (net/mlx5e: ConnectX-4 firmware support for DCBX)
  #endif
 +};
  
  struct mlx5e_tstamp {
  	rwlock_t                   lock;
@@@ -643,8 -844,83 +667,9 @@@ extern const struct ethtool_ops mlx5e_e
  #ifdef CONFIG_MLX5_CORE_EN_DCB
  extern const struct dcbnl_rtnl_ops mlx5e_dcbnl_ops;
  int mlx5e_dcbnl_ieee_setets_core(struct mlx5e_priv *priv, struct ieee_ets *ets);
+ void mlx5e_dcbnl_initialize(struct mlx5e_priv *priv);
  #endif
  
 -#ifndef CONFIG_RFS_ACCEL
 -static inline int mlx5e_arfs_create_tables(struct mlx5e_priv *priv)
 -{
 -	return 0;
 -}
 -
 -static inline void mlx5e_arfs_destroy_tables(struct mlx5e_priv *priv) {}
 -
 -static inline int mlx5e_arfs_enable(struct mlx5e_priv *priv)
 -{
 -	return -ENOTSUPP;
 -}
 -
 -static inline int mlx5e_arfs_disable(struct mlx5e_priv *priv)
 -{
 -	return -ENOTSUPP;
 -}
 -#else
 -int mlx5e_arfs_create_tables(struct mlx5e_priv *priv);
 -void mlx5e_arfs_destroy_tables(struct mlx5e_priv *priv);
 -int mlx5e_arfs_enable(struct mlx5e_priv *priv);
 -int mlx5e_arfs_disable(struct mlx5e_priv *priv);
 -int mlx5e_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,
 -			u16 rxq_index, u32 flow_id);
 -#endif
 -
  u16 mlx5e_get_max_inline_cap(struct mlx5_core_dev *mdev);
 -int mlx5e_create_tir(struct mlx5_core_dev *mdev,
 -		     struct mlx5e_tir *tir, u32 *in, int inlen);
 -void mlx5e_destroy_tir(struct mlx5_core_dev *mdev,
 -		       struct mlx5e_tir *tir);
 -int mlx5e_create_mdev_resources(struct mlx5_core_dev *mdev);
 -void mlx5e_destroy_mdev_resources(struct mlx5_core_dev *mdev);
 -int mlx5e_refresh_tirs_self_loopback_enable(struct mlx5_core_dev *mdev);
 -
 -struct mlx5_eswitch_rep;
 -int mlx5e_vport_rep_load(struct mlx5_eswitch *esw,
 -			 struct mlx5_eswitch_rep *rep);
 -void mlx5e_vport_rep_unload(struct mlx5_eswitch *esw,
 -			    struct mlx5_eswitch_rep *rep);
 -int mlx5e_nic_rep_load(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep);
 -void mlx5e_nic_rep_unload(struct mlx5_eswitch *esw,
 -			  struct mlx5_eswitch_rep *rep);
 -int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 -void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
 -int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
 -void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 -void mlx5e_update_hw_rep_counters(struct mlx5e_priv *priv);
 -
 -int mlx5e_create_direct_rqts(struct mlx5e_priv *priv);
 -void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt);
 -int mlx5e_create_direct_tirs(struct mlx5e_priv *priv);
 -void mlx5e_destroy_direct_tirs(struct mlx5e_priv *priv);
 -int mlx5e_create_tises(struct mlx5e_priv *priv);
 -void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv);
 -int mlx5e_close(struct net_device *netdev);
 -int mlx5e_open(struct net_device *netdev);
 -void mlx5e_update_stats_work(struct work_struct *work);
 -struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
 -				       const struct mlx5e_profile *profile,
 -				       void *ppriv);
 -void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv);
 -int mlx5e_attach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
 -void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
 -u32 mlx5e_choose_lro_timeout(struct mlx5_core_dev *mdev, u32 wanted_timeout);
 -void mlx5e_add_vxlan_port(struct net_device *netdev,
 -			  struct udp_tunnel_info *ti);
 -void mlx5e_del_vxlan_port(struct net_device *netdev,
 -			  struct udp_tunnel_info *ti);
 -
 -int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev,
 -			    void *sp);
 -bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
 -
 -bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 -bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv);
 +
  #endif /* __MLX5_EN_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index 762af16ed021,1753182e8959..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@@ -38,6 -38,48 +38,51 @@@
  #define MLX5E_100MB (100000)
  #define MLX5E_1GB   (1000000)
  
++<<<<<<< HEAD
++=======
+ #define MLX5E_CEE_STATE_UP    1
+ #define MLX5E_CEE_STATE_DOWN  0
+ 
+ /* If dcbx mode is non-host set the dcbx mode to host.
+  */
+ static int mlx5e_dcbnl_set_dcbx_mode(struct mlx5e_priv *priv,
+ 				     enum mlx5_dcbx_oper_mode mode)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u32 param[MLX5_ST_SZ_DW(dcbx_param)];
+ 	int err;
+ 
+ 	err = mlx5_query_port_dcbx_param(mdev, param);
+ 	if (err)
+ 		return err;
+ 
+ 	MLX5_SET(dcbx_param, param, version_admin, mode);
+ 	if (mode != MLX5E_DCBX_PARAM_VER_OPER_HOST)
+ 		MLX5_SET(dcbx_param, param, willing_admin, 1);
+ 
+ 	return mlx5_set_port_dcbx_param(mdev, param);
+ }
+ 
+ static int mlx5e_dcbnl_switch_to_host_mode(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_dcbx *dcbx = &priv->dcbx;
+ 	int err;
+ 
+ 	if (!MLX5_CAP_GEN(priv->mdev, dcbx))
+ 		return 0;
+ 
+ 	if (dcbx->mode == MLX5E_DCBX_PARAM_VER_OPER_HOST)
+ 		return 0;
+ 
+ 	err = mlx5e_dcbnl_set_dcbx_mode(priv, MLX5E_DCBX_PARAM_VER_OPER_HOST);
+ 	if (err)
+ 		return err;
+ 
+ 	dcbx->mode = MLX5E_DCBX_PARAM_VER_OPER_HOST;
+ 	return 0;
+ }
+ 
++>>>>>>> e207b7e99176 (net/mlx5e: ConnectX-4 firmware support for DCBX)
  static int mlx5e_dcbnl_ieee_getets(struct net_device *netdev,
  				   struct ieee_ets *ets)
  {
@@@ -227,8 -294,11 +272,11 @@@ static u8 mlx5e_dcbnl_getdcbx(struct ne
  
  static u8 mlx5e_dcbnl_setdcbx(struct net_device *dev, u8 mode)
  {
+ 	if (mlx5e_dcbnl_switch_to_host_mode(netdev_priv(dev)))
+ 		return 1;
+ 
  	if ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||
 -	    !(mode & DCB_CAP_DCBX_VER_CEE) ||
 +	    (mode & DCB_CAP_DCBX_VER_CEE) ||
  	    !(mode & DCB_CAP_DCBX_VER_IEEE) ||
  	    !(mode & DCB_CAP_DCBX_HOST))
  		return 1;
@@@ -313,4 -661,70 +361,53 @@@ const struct dcbnl_rtnl_ops mlx5e_dcbnl
  	.ieee_setpfc	= mlx5e_dcbnl_ieee_setpfc,
  	.getdcbx	= mlx5e_dcbnl_getdcbx,
  	.setdcbx	= mlx5e_dcbnl_setdcbx,
 -
 -/* CEE interfaces */
 -	.setall         = mlx5e_dcbnl_setall,
 -	.getstate       = mlx5e_dcbnl_getstate,
 -	.getpermhwaddr  = mlx5e_dcbnl_getpermhwaddr,
 -
 -	.setpgtccfgtx   = mlx5e_dcbnl_setpgtccfgtx,
 -	.setpgbwgcfgtx  = mlx5e_dcbnl_setpgbwgcfgtx,
 -	.getpgtccfgtx   = mlx5e_dcbnl_getpgtccfgtx,
 -	.getpgbwgcfgtx  = mlx5e_dcbnl_getpgbwgcfgtx,
 -
 -	.setpfccfg      = mlx5e_dcbnl_setpfccfg,
 -	.getpfccfg      = mlx5e_dcbnl_getpfccfg,
 -	.getcap         = mlx5e_dcbnl_getcap,
 -	.getnumtcs      = mlx5e_dcbnl_getnumtcs,
 -	.getpfcstate    = mlx5e_dcbnl_getpfcstate,
 -	.setpfcstate    = mlx5e_dcbnl_setpfcstate,
  };
+ 
+ static void mlx5e_dcbnl_query_dcbx_mode(struct mlx5e_priv *priv,
+ 					enum mlx5_dcbx_oper_mode *mode)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(dcbx_param)];
+ 
+ 	*mode = MLX5E_DCBX_PARAM_VER_OPER_HOST;
+ 
+ 	if (!mlx5_query_port_dcbx_param(priv->mdev, out))
+ 		*mode = MLX5_GET(dcbx_param, out, version_oper);
+ 
+ 	/* From driver's point of view, we only care if the mode
+ 	 * is host (HOST) or non-host (AUTO)
+ 	 */
+ 	if (*mode != MLX5E_DCBX_PARAM_VER_OPER_HOST)
+ 		*mode = MLX5E_DCBX_PARAM_VER_OPER_AUTO;
+ }
+ 
+ static void mlx5e_ets_init(struct mlx5e_priv *priv)
+ {
+ 	int i;
+ 	struct ieee_ets ets;
+ 
+ 	memset(&ets, 0, sizeof(ets));
+ 	ets.ets_cap = mlx5_max_tc(priv->mdev) + 1;
+ 	for (i = 0; i < ets.ets_cap; i++) {
+ 		ets.tc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;
+ 		ets.tc_tsa[i] = IEEE_8021QAZ_TSA_VENDOR;
+ 		ets.prio_tc[i] = i;
+ 	}
+ 
+ 	memcpy(priv->dcbx.tc_tsa, ets.tc_tsa, sizeof(ets.tc_tsa));
+ 
+ 	/* tclass[prio=0]=1, tclass[prio=1]=0, tclass[prio=i]=i (for i>1) */
+ 	ets.prio_tc[0] = 1;
+ 	ets.prio_tc[1] = 0;
+ 
+ 	mlx5e_dcbnl_ieee_setets_core(priv, &ets);
+ }
+ 
+ void mlx5e_dcbnl_initialize(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_dcbx *dcbx = &priv->dcbx;
+ 
+ 	if (MLX5_CAP_GEN(priv->mdev, dcbx))
+ 		mlx5e_dcbnl_query_dcbx_mode(priv, &dcbx->mode);
+ 
+ 	mlx5e_ets_init(priv);
+ }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index cc20a22c48b8,f5b93c27a884..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2648,24 -3325,6 +2648,27 @@@ u16 mlx5e_get_max_inline_cap(struct mlx
  	       2 /*sizeof(mlx5e_tx_wqe.inline_hdr_start)*/;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_MLX5_CORE_EN_DCB
 +static void mlx5e_ets_init(struct mlx5e_priv *priv)
 +{
 +	int i;
 +
 +	priv->params.ets.ets_cap = mlx5_max_tc(priv->mdev) + 1;
 +	for (i = 0; i < priv->params.ets.ets_cap; i++) {
 +		priv->params.ets.tc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;
 +		priv->params.ets.tc_tsa[i] = IEEE_8021QAZ_TSA_VENDOR;
 +		priv->params.ets.prio_tc[i] = i;
 +	}
 +
 +	/* tclass[prio=0]=1, tclass[prio=1]=0, tclass[prio=i]=i (for i>1) */
 +	priv->params.ets.prio_tc[0] = 1;
 +	priv->params.ets.prio_tc[1] = 0;
 +}
 +#endif
 +
++=======
++>>>>>>> e207b7e99176 (net/mlx5e: ConnectX-4 firmware support for DCBX)
  void mlx5e_build_default_indir_rqt(struct mlx5_core_dev *mdev,
  				   u32 *indirection_rqt, int len,
  				   int num_channels)
@@@ -3003,18 -3661,176 +3006,181 @@@ static int mlx5e_create_umr_mkey(struc
  	return err;
  }
  
 -static void mlx5e_nic_init(struct mlx5_core_dev *mdev,
 -			   struct net_device *netdev,
 -			   const struct mlx5e_profile *profile,
 -			   void *ppriv)
 +static void *mlx5e_create_netdev(struct mlx5_core_dev *mdev)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	mlx5e_build_nic_netdev_priv(mdev, netdev, profile, ppriv);
+ 	mlx5e_build_nic_netdev(netdev);
+ 	mlx5e_vxlan_init(priv);
+ }
+ 
+ static void mlx5e_nic_cleanup(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	mlx5e_vxlan_cleanup(priv);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		mlx5_eswitch_unregister_vport_rep(esw, 0);
+ 
+ 	if (priv->xdp_prog)
+ 		bpf_prog_put(priv->xdp_prog);
+ }
+ 
+ static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int err;
+ 	int i;
+ 
+ 	err = mlx5e_create_indirect_rqts(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create indirect rqts failed, %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	err = mlx5e_create_direct_rqts(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create direct rqts failed, %d\n", err);
+ 		goto err_destroy_indirect_rqts;
+ 	}
+ 
+ 	err = mlx5e_create_indirect_tirs(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create indirect tirs failed, %d\n", err);
+ 		goto err_destroy_direct_rqts;
+ 	}
+ 
+ 	err = mlx5e_create_direct_tirs(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create direct tirs failed, %d\n", err);
+ 		goto err_destroy_indirect_tirs;
+ 	}
+ 
+ 	err = mlx5e_create_flow_steering(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create flow steering failed, %d\n", err);
+ 		goto err_destroy_direct_tirs;
+ 	}
+ 
+ 	err = mlx5e_tc_init(priv);
+ 	if (err)
+ 		goto err_destroy_flow_steering;
+ 
+ 	return 0;
+ 
+ err_destroy_flow_steering:
+ 	mlx5e_destroy_flow_steering(priv);
+ err_destroy_direct_tirs:
+ 	mlx5e_destroy_direct_tirs(priv);
+ err_destroy_indirect_tirs:
+ 	mlx5e_destroy_indirect_tirs(priv);
+ err_destroy_direct_rqts:
+ 	for (i = 0; i < priv->profile->max_nch(mdev); i++)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
+ err_destroy_indirect_rqts:
+ 	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
+ 	return err;
+ }
+ 
+ static void mlx5e_cleanup_nic_rx(struct mlx5e_priv *priv)
+ {
+ 	int i;
+ 
+ 	mlx5e_tc_cleanup(priv);
+ 	mlx5e_destroy_flow_steering(priv);
+ 	mlx5e_destroy_direct_tirs(priv);
+ 	mlx5e_destroy_indirect_tirs(priv);
+ 	for (i = 0; i < priv->profile->max_nch(priv->mdev); i++)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
+ 	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
+ }
+ 
+ static int mlx5e_init_nic_tx(struct mlx5e_priv *priv)
+ {
+ 	int err;
+ 
+ 	err = mlx5e_create_tises(priv);
+ 	if (err) {
+ 		mlx5_core_warn(priv->mdev, "create tises failed, %d\n", err);
+ 		return err;
+ 	}
+ 
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 	mlx5e_dcbnl_initialize(priv);
+ #endif
+ 	return 0;
+ }
+ 
+ static void mlx5e_nic_enable(struct mlx5e_priv *priv)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	struct mlx5_eswitch_rep rep;
+ 
+ 	mlx5_lag_add(mdev, netdev);
+ 
+ 	if (mlx5e_vxlan_allowed(mdev)) {
+ 		rtnl_lock();
+ 		udp_tunnel_get_rx_info(netdev);
+ 		rtnl_unlock();
+ 	}
+ 
+ 	mlx5e_enable_async_events(priv);
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager)) {
+ 		mlx5_query_nic_vport_mac_address(mdev, 0, rep.hw_id);
+ 		rep.load = mlx5e_nic_rep_load;
+ 		rep.unload = mlx5e_nic_rep_unload;
+ 		rep.vport = FDB_UPLINK_VPORT;
+ 		rep.priv_data = priv;
+ 		mlx5_eswitch_register_vport_rep(esw, 0, &rep);
+ 	}
+ }
+ 
+ static void mlx5e_nic_disable(struct mlx5e_priv *priv)
+ {
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
+ 	mlx5e_disable_async_events(priv);
+ 	mlx5_lag_remove(priv->mdev);
+ }
+ 
+ static const struct mlx5e_profile mlx5e_nic_profile = {
+ 	.init		   = mlx5e_nic_init,
+ 	.cleanup	   = mlx5e_nic_cleanup,
+ 	.init_rx	   = mlx5e_init_nic_rx,
+ 	.cleanup_rx	   = mlx5e_cleanup_nic_rx,
+ 	.init_tx	   = mlx5e_init_nic_tx,
+ 	.cleanup_tx	   = mlx5e_cleanup_nic_tx,
+ 	.enable		   = mlx5e_nic_enable,
+ 	.disable	   = mlx5e_nic_disable,
+ 	.update_stats	   = mlx5e_update_stats,
+ 	.max_nch	   = mlx5e_get_max_num_channels,
+ 	.max_tc		   = MLX5E_MAX_NUM_TC,
+ };
+ 
+ struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
+ 				       const struct mlx5e_profile *profile,
+ 				       void *ppriv)
+ {
+ 	int nch = profile->max_nch(mdev);
++>>>>>>> e207b7e99176 (net/mlx5e: ConnectX-4 firmware support for DCBX)
  	struct net_device *netdev;
  	struct mlx5e_priv *priv;
 +	int nch = mlx5e_get_max_num_channels(mdev);
 +	int err;
 +
 +	if (mlx5e_check_required_hca_cap(mdev))
 +		return NULL;
  
  	netdev = alloc_etherdev_mqs(sizeof(struct mlx5e_priv),
 -				    nch * profile->max_tc,
 +				    nch * MLX5E_MAX_NUM_TC,
  				    nch);
  	if (!netdev) {
  		mlx5_core_err(mdev, "alloc_etherdev_mqs() failed\n");
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
