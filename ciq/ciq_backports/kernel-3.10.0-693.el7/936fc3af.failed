EDAC, amd64: Reserve correct PCI devices on AMD Fam17h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [edac] amd64: Reserve correct PCI devices on AMD Fam17h (Suravee Suthikulpanit) [1303712]
Rebuild_FUZZ: 94.12%
commit-author Yazen Ghannam <Yazen.Ghannam@amd.com>
commit 936fc3afaa8abc20dfea306c9b6d19a6e7ca5caf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/936fc3af.failed

Fam17h needs PCI device functions 0 and 6 instead of 1 and 2 as on older
systems. Update struct amd64_pvt to hold the new functions and reserve
them if on Fam17h.

Also, allocate an array of UMC structs within our newly allocated PVT
struct.

	Signed-off-by: Yazen Ghannam <Yazen.Ghannam@amd.com>
	Cc: Aravind Gopalakrishnan <aravindksg.lkml@gmail.com>
	Cc: linux-edac <linux-edac@vger.kernel.org>
	Cc: x86-ml <x86@kernel.org>
Link: http://lkml.kernel.org/r/1479423463-8536-11-git-send-email-Yazen.Ghannam@amd.com
[ init_one_instance() error handling, shorten lines, unbreak >80 cols lines. ]
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 936fc3afaa8abc20dfea306c9b6d19a6e7ca5caf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/amd64_edac.c
diff --cc drivers/edac/amd64_edac.c
index e233d8dbf7f6,1f3de3402d48..000000000000
--- a/drivers/edac/amd64_edac.c
+++ b/drivers/edac/amd64_edac.c
@@@ -2195,38 -2271,58 +2195,88 @@@ static inline void __amd64_decode_bus_e
  	__log_ecc_error(mci, &err, ecc_type);
  }
  
 +void amd64_decode_bus_error(int node_id, struct mce *m)
 +{
 +	__amd64_decode_bus_error(mcis[node_id], m);
 +}
 +
  /*
++<<<<<<< HEAD
 + * Use pvt->F2 which contains the F2 CPU PCI device to get the related
 + * F1 (AddrMap) and F3 (Misc) devices. Return negative value on error.
 + */
 +static int reserve_mc_sibling_devs(struct amd64_pvt *pvt, u16 f1_id, u16 f3_id)
- {
++=======
+  * Use pvt->F3 which contains the F3 CPU PCI device to get the related
+  * F1 (AddrMap) and F2 (Dct) devices. Return negative value on error.
+  * Reserve F0 and F6 on systems with a UMC.
+  */
+ static int
+ reserve_mc_sibling_devs(struct amd64_pvt *pvt, u16 pci_id1, u16 pci_id2)
++>>>>>>> 936fc3afaa8a (EDAC, amd64: Reserve correct PCI devices on AMD Fam17h)
+ {
+ 	if (pvt->umc) {
+ 		pvt->F0 = pci_get_related_function(pvt->F3->vendor, pci_id1, pvt->F3);
+ 		if (!pvt->F0) {
+ 		amd64_err("error F0 device not found: vendor %x device 0x%x (broken BIOS?)\n",
+ 			  PCI_VENDOR_ID_AMD, pci_id1);
+ 			return -ENODEV;
+ 		}
+ 
+ 		pvt->F6 = pci_get_related_function(pvt->F3->vendor, pci_id2, pvt->F3);
+ 		if (!pvt->F6) {
+ 			pci_dev_put(pvt->F0);
+ 			pvt->F0 = NULL;
+ 
+ 		amd64_err("error F6 device not found: vendor %x device 0x%x (broken BIOS?)\n",
+ 			  PCI_VENDOR_ID_AMD, pci_id2);
+ 
+ 			return -ENODEV;
+ 		}
+ 		edac_dbg(1, "F0: %s\n", pci_name(pvt->F0));
+ 		edac_dbg(1, "F3: %s\n", pci_name(pvt->F3));
+ 		edac_dbg(1, "F6: %s\n", pci_name(pvt->F6));
+ 
+ 		return 0;
+ 	}
+ 
  	/* Reserve the ADDRESS MAP Device */
++<<<<<<< HEAD
 +	pvt->F1 = pci_get_related_function(pvt->F2->vendor, f1_id, pvt->F2);
++=======
+ 	pvt->F1 = pci_get_related_function(pvt->F3->vendor, pci_id1, pvt->F3);
++>>>>>>> 936fc3afaa8a (EDAC, amd64: Reserve correct PCI devices on AMD Fam17h)
  	if (!pvt->F1) {
- 		amd64_err("error address map device not found: "
- 			  "vendor %x device 0x%x (broken BIOS?)\n",
- 			  PCI_VENDOR_ID_AMD, f1_id);
+ 	amd64_err("error address map device not found: vendor %x device 0x%x (broken BIOS?)\n",
+ 		  PCI_VENDOR_ID_AMD, pci_id1);
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	/* Reserve the MISC Device */
 +	pvt->F3 = pci_get_related_function(pvt->F2->vendor, f3_id, pvt->F2);
 +	if (!pvt->F3) {
 +		pci_dev_put(pvt->F1);
 +		pvt->F1 = NULL;
 +
 +		amd64_err("error F3 device not found: "
 +			  "vendor %x device 0x%x (broken BIOS?)\n",
 +			  PCI_VENDOR_ID_AMD, f3_id);
 +
 +		return -ENODEV;
++=======
+ 	/* Reserve the DCT Device */
+ 	pvt->F2 = pci_get_related_function(pvt->F3->vendor, pci_id2, pvt->F3);
+ 	if (!pvt->F2) {
+ 		pci_dev_put(pvt->F1);
+ 		pvt->F1 = NULL;
+ 
+ 	amd64_err("error F2 device not found: vendor %x device 0x%x (broken BIOS?)\n",
+ 		  PCI_VENDOR_ID_AMD, pci_id2);
+ 			return -ENODEV;
++>>>>>>> 936fc3afaa8a (EDAC, amd64: Reserve correct PCI devices on AMD Fam17h)
  	}
+ 
  	edac_dbg(1, "F1: %s\n", pci_name(pvt->F1));
  	edac_dbg(1, "F2: %s\n", pci_name(pvt->F2));
  	edac_dbg(1, "F3: %s\n", pci_name(pvt->F3));
@@@ -2236,8 -2332,13 +2286,18 @@@
  
  static void free_mc_sibling_devs(struct amd64_pvt *pvt)
  {
++<<<<<<< HEAD
 +	pci_dev_put(pvt->F1);
 +	pci_dev_put(pvt->F3);
++=======
+ 	if (pvt->umc) {
+ 		pci_dev_put(pvt->F0);
+ 		pci_dev_put(pvt->F6);
+ 	} else {
+ 		pci_dev_put(pvt->F1);
+ 		pci_dev_put(pvt->F2);
+ 	}
++>>>>>>> 936fc3afaa8a (EDAC, amd64: Reserve correct PCI devices on AMD Fam17h)
  }
  
  /*
@@@ -2800,8 -2893,9 +2860,13 @@@ static int init_one_instance(struct pci
  	struct amd64_family_type *fam_type = NULL;
  	struct mem_ctl_info *mci = NULL;
  	struct edac_mc_layer layers[2];
++<<<<<<< HEAD
++=======
+ 	struct amd64_pvt *pvt = NULL;
+ 	u16 pci_id1, pci_id2;
++>>>>>>> 936fc3afaa8a (EDAC, amd64: Reserve correct PCI devices on AMD Fam17h)
  	int err = 0, ret;
 +	u16 nid = amd_get_node_id(F2);
  
  	ret = -ENOMEM;
  	pvt = kzalloc(sizeof(struct amd64_pvt), GFP_KERNEL);
@@@ -2816,10 -2910,23 +2881,28 @@@
  	if (!fam_type)
  		goto err_free;
  
++<<<<<<< HEAD
 +	ret = -ENODEV;
 +	err = reserve_mc_sibling_devs(pvt, fam_type->f1_id, fam_type->f3_id);
++=======
+ 	if (pvt->fam >= 0x17) {
+ 		pvt->umc = kcalloc(NUM_UMCS, sizeof(struct amd64_umc), GFP_KERNEL);
+ 		if (!pvt->umc) {
+ 			ret = -ENOMEM;
+ 			goto err_free;
+ 		}
+ 
+ 		pci_id1 = fam_type->f0_id;
+ 		pci_id2 = fam_type->f6_id;
+ 	} else {
+ 		pci_id1 = fam_type->f1_id;
+ 		pci_id2 = fam_type->f2_id;
+ 	}
+ 
+ 	err = reserve_mc_sibling_devs(pvt, pci_id1, pci_id2);
++>>>>>>> 936fc3afaa8a (EDAC, amd64: Reserve correct PCI devices on AMD Fam17h)
  	if (err)
- 		goto err_free;
+ 		goto err_post_init;
  
  	read_mc_regs(pvt);
  
* Unmerged path drivers/edac/amd64_edac.c
diff --git a/drivers/edac/amd64_edac.h b/drivers/edac/amd64_edac.h
index 42bc4a8e049e..bd7e1d7fa6e9 100644
--- a/drivers/edac/amd64_edac.h
+++ b/drivers/edac/amd64_edac.h
@@ -351,7 +351,7 @@ struct amd64_pvt {
 	struct low_ops *ops;
 
 	/* pci_device handles which we utilize */
-	struct pci_dev *F1, *F2, *F3;
+	struct pci_dev *F0, *F1, *F2, *F3, *F6;
 
 	u16 mc_node_id;		/* MC index of this MC node */
 	u8 fam;			/* CPU family */
