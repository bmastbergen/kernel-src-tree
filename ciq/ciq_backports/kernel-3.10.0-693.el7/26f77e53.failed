i40e: fix RSS queues only operating on PF0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lihong Yang <lihong.yang@intel.com>
commit 26f77e53cfee2b1b066071353be03988897e23c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/26f77e53.failed

This patch fixes the issue that RSS offloading only works on PF0 by
using the direct register writing of the hash keys for the VFs instead
of using the admin queue command to do so.

Change-ID: Ia02cda7dbaa23def342e8786097a2c03db6f580b
	Signed-off-by: Lihong Yang <lihong.yang@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 26f77e53cfee2b1b066071353be03988897e23c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index a661762b4de2,115a7286ab8f..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -696,11 -696,14 +696,22 @@@ static int i40e_alloc_vsi_res(struct i4
  					 "Could not add MAC filter %pM for VF %d\n",
  					vf->default_lan_addr.addr, vf->vf_id);
  		}
++<<<<<<< HEAD
 +		spin_unlock_bh(&vsi->mac_filter_list_lock);
 +		i40e_write_rx_ctl(&pf->hw, I40E_VFQF_HENA1(0, vf->vf_id),
 +				  (u32)hena);
 +		i40e_write_rx_ctl(&pf->hw, I40E_VFQF_HENA1(1, vf->vf_id),
 +				  (u32)(hena >> 32));
++=======
+ 		eth_broadcast_addr(broadcast);
+ 		f = i40e_add_mac_filter(vsi, broadcast);
+ 		if (!f)
+ 			dev_info(&pf->pdev->dev,
+ 				 "Could not allocate VF broadcast filter\n");
+ 		spin_unlock_bh(&vsi->mac_filter_hash_lock);
+ 		wr32(&pf->hw, I40E_VFQF_HENA1(0, vf->vf_id), (u32)hena);
+ 		wr32(&pf->hw, I40E_VFQF_HENA1(1, vf->vf_id), (u32)(hena >> 32));
++>>>>>>> 26f77e53cfee (i40e: fix RSS queues only operating on PF0)
  	}
  
  	/* program mac filter */
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 9c2dc0216237..6fdb98dbe65e 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -8228,13 +8228,10 @@ static int i40e_config_rss_reg(struct i40e_vsi *vsi, const u8 *seed,
 
 		if (vsi->type == I40E_VSI_MAIN) {
 			for (i = 0; i <= I40E_PFQF_HKEY_MAX_INDEX; i++)
-				i40e_write_rx_ctl(hw, I40E_PFQF_HKEY(i),
-						  seed_dw[i]);
+				wr32(hw, I40E_PFQF_HKEY(i), seed_dw[i]);
 		} else if (vsi->type == I40E_VSI_SRIOV) {
 			for (i = 0; i <= I40E_VFQF_HKEY1_MAX_INDEX; i++)
-				i40e_write_rx_ctl(hw,
-						  I40E_VFQF_HKEY1(i, vf_id),
-						  seed_dw[i]);
+				wr32(hw, I40E_VFQF_HKEY1(i, vf_id), seed_dw[i]);
 		} else {
 			dev_err(&pf->pdev->dev, "Cannot set RSS seed - invalid VSI type\n");
 		}
@@ -8252,9 +8249,7 @@ static int i40e_config_rss_reg(struct i40e_vsi *vsi, const u8 *seed,
 			if (lut_size != I40E_VF_HLUT_ARRAY_SIZE)
 				return -EINVAL;
 			for (i = 0; i <= I40E_VFQF_HLUT_MAX_INDEX; i++)
-				i40e_write_rx_ctl(hw,
-						  I40E_VFQF_HLUT1(i, vf_id),
-						  lut_dw[i]);
+				wr32(hw, I40E_VFQF_HLUT1(i, vf_id), lut_dw[i]);
 		} else {
 			dev_err(&pf->pdev->dev, "Cannot set RSS LUT - invalid VSI type\n");
 		}
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
