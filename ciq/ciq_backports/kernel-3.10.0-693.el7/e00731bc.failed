scsi: megaraid_sas: Cleanup VD_EXT_DEBUG and SPAN_DEBUG related debug prints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: Cleanup VD_EXT_DEBUG and SPAN_DEBUG related debug prints (Tomas Henzl) [1417038]
Rebuild_FUZZ: 95.89%
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit e00731bc5abb8f00f64e74fc8deb3feca580f22d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e00731bc.failed

	Signed-off-by: Kashyap Desai <kashyap.desai@broadcom.com>
	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit e00731bc5abb8f00f64e74fc8deb3feca580f22d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/megaraid/megaraid_sas_fp.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index 20d0591e6622,5e0dea14287f..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -4515,21 -4580,27 +4515,31 @@@ static void megasas_update_ext_vd_detai
  		instance->supportmax256vd ? "Extended VD(240 VD)firmware" :
  		"Legacy(64 VD) firmware");
  
 -	if (instance->max_raid_mapsize) {
 -		ventura_map_sz = instance->max_raid_mapsize *
 -						MR_MIN_MAP_SIZE; /* 64k */
 -		fusion->current_map_sz = ventura_map_sz;
 -		fusion->max_map_sz = ventura_map_sz;
 -	} else {
 -		fusion->old_map_sz =  sizeof(struct MR_FW_RAID_MAP) +
 -					(sizeof(struct MR_LD_SPAN_MAP) *
 -					(instance->fw_supported_vd_count - 1));
 -		fusion->new_map_sz =  sizeof(struct MR_FW_RAID_MAP_EXT);
 +	old_map_sz = sizeof(struct MR_FW_RAID_MAP) +
 +				(sizeof(struct MR_LD_SPAN_MAP) *
 +				(instance->fw_supported_vd_count - 1));
 +	new_map_sz = sizeof(struct MR_FW_RAID_MAP_EXT);
 +	fusion->drv_map_sz = sizeof(struct MR_DRV_RAID_MAP) +
 +				(sizeof(struct MR_LD_SPAN_MAP) *
 +				(instance->drv_supported_vd_count - 1));
 +
 +	fusion->max_map_sz = max(old_map_sz, new_map_sz);
  
 -		fusion->max_map_sz =
 -			max(fusion->old_map_sz, fusion->new_map_sz);
++<<<<<<< HEAD
  
 +	if (instance->supportmax256vd)
 +		fusion->current_map_sz = new_map_sz;
 +	else
 +		fusion->current_map_sz = old_map_sz;
++=======
+ 		if (instance->supportmax256vd)
+ 			fusion->current_map_sz = fusion->new_map_sz;
+ 		else
+ 			fusion->current_map_sz = fusion->old_map_sz;
+ 	}
+ 	/* irrespective of FW raid maps, driver raid map is constant */
+ 	fusion->drv_map_sz = sizeof(struct MR_DRV_RAID_MAP_ALL);
++>>>>>>> e00731bc5abb (scsi: megaraid_sas: Cleanup VD_EXT_DEBUG and SPAN_DEBUG related debug prints)
  }
  
  /**
@@@ -5141,13 -5201,13 +5151,23 @@@ static int megasas_init_fw(struct megas
  			goto fail_ready_state;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * MSI-X host index 0 is common for all adapter.
 +	 * It is used for all MPT based Adapters.
 +	 */
 +	instance->reply_post_host_index_addr[0] =
 +		(u32 __iomem *)((u8 __iomem *)instance->reg_set +
 +		MPI2_REPLY_POST_HOST_INDEX_OFFSET);
++=======
+ 	if (instance->is_ventura) {
+ 		scratch_pad_3 =
+ 			readl(&instance->reg_set->outbound_scratch_pad_3);
+ 		instance->max_raid_mapsize = ((scratch_pad_3 >>
+ 			MR_MAX_RAID_MAP_SIZE_OFFSET_SHIFT) &
+ 			MR_MAX_RAID_MAP_SIZE_MASK);
+ 	}
++>>>>>>> e00731bc5abb (scsi: megaraid_sas: Cleanup VD_EXT_DEBUG and SPAN_DEBUG related debug prints)
  
  	/* Check if MSI-X is supported while in ready state */
  	msix_enable = (instance->instancet->read_fw_status_reg(reg_set) &
diff --cc drivers/scsi/megaraid/megaraid_sas_fp.c
index 53238db53032,7dc7708a7957..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fp.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fp.c
@@@ -186,11 -193,95 +185,102 @@@ void MR_PopulateDrvRaidMap(struct megas
  	struct MR_DRV_RAID_MAP_ALL *drv_map =
  			fusion->ld_drv_map[(instance->map_id & 1)];
  	struct MR_DRV_RAID_MAP *pDrvRaidMap = &drv_map->raidMap;
++<<<<<<< HEAD
++=======
+ 	void *raid_map_data = NULL;
+ 
+ 	memset(drv_map, 0, fusion->drv_map_sz);
+ 	memset(pDrvRaidMap->ldTgtIdToLd,
+ 		0xff, (sizeof(u16) * MAX_LOGICAL_DRIVES_DYN));
+ 
+ 	if (instance->max_raid_mapsize) {
+ 		fw_map_dyn = fusion->ld_map[(instance->map_id & 1)];
+ 		desc_table =
+ 		(struct MR_RAID_MAP_DESC_TABLE *)((void *)fw_map_dyn + le32_to_cpu(fw_map_dyn->desc_table_offset));
+ 		if (desc_table != fw_map_dyn->raid_map_desc_table)
+ 			dev_dbg(&instance->pdev->dev, "offsets of desc table are not matching desc %p original %p\n",
+ 				desc_table, fw_map_dyn->raid_map_desc_table);
+ 
+ 		ld_count = (u16)le16_to_cpu(fw_map_dyn->ld_count);
+ 		pDrvRaidMap->ldCount = (__le16)cpu_to_le16(ld_count);
+ 		pDrvRaidMap->fpPdIoTimeoutSec =
+ 			fw_map_dyn->fp_pd_io_timeout_sec;
+ 		pDrvRaidMap->totalSize =
+ 			cpu_to_le32(sizeof(struct MR_DRV_RAID_MAP_ALL));
+ 		/* point to actual data starting point*/
+ 		raid_map_data = (void *)fw_map_dyn +
+ 			le32_to_cpu(fw_map_dyn->desc_table_offset) +
+ 			le32_to_cpu(fw_map_dyn->desc_table_size);
+ 
+ 		for (i = 0; i < le32_to_cpu(fw_map_dyn->desc_table_num_elements); ++i) {
+ 			switch (le32_to_cpu(desc_table->raid_map_desc_type)) {
+ 			case RAID_MAP_DESC_TYPE_DEVHDL_INFO:
+ 				fw_map_dyn->dev_hndl_info =
+ 				(struct MR_DEV_HANDLE_INFO *)(raid_map_data + le32_to_cpu(desc_table->raid_map_desc_offset));
+ 				memcpy(pDrvRaidMap->devHndlInfo,
+ 				fw_map_dyn->dev_hndl_info,
+ 				sizeof(struct MR_DEV_HANDLE_INFO) *
+ 				le32_to_cpu(desc_table->raid_map_desc_elements));
+ 			break;
+ 			case RAID_MAP_DESC_TYPE_TGTID_INFO:
+ 				fw_map_dyn->ld_tgt_id_to_ld =
+ 				(u16 *) (raid_map_data +
+ 				le32_to_cpu(desc_table->raid_map_desc_offset));
+ 			for (j = 0; j < le32_to_cpu(desc_table->raid_map_desc_elements); j++) {
+ 				pDrvRaidMap->ldTgtIdToLd[j] =
+ 					le16_to_cpu(fw_map_dyn->ld_tgt_id_to_ld[j]);
+ 			}
+ 			break;
+ 			case RAID_MAP_DESC_TYPE_ARRAY_INFO:
+ 				fw_map_dyn->ar_map_info =
+ 				(struct MR_ARRAY_INFO *)
+ 				(raid_map_data + le32_to_cpu(desc_table->raid_map_desc_offset));
+ 				memcpy(pDrvRaidMap->arMapInfo,
+ 				fw_map_dyn->ar_map_info,
+ 				sizeof(struct MR_ARRAY_INFO) * le32_to_cpu(desc_table->raid_map_desc_elements));
+ 			break;
+ 			case RAID_MAP_DESC_TYPE_SPAN_INFO:
+ 				fw_map_dyn->ld_span_map =
+ 				(struct MR_LD_SPAN_MAP *)
+ 				(raid_map_data + le32_to_cpu(desc_table->raid_map_desc_offset));
+ 				memcpy(pDrvRaidMap->ldSpanMap,
+ 				fw_map_dyn->ld_span_map,
+ 				sizeof(struct MR_LD_SPAN_MAP) * le32_to_cpu(desc_table->raid_map_desc_elements));
+ 			break;
+ 			default:
+ 				dev_dbg(&instance->pdev->dev, "wrong number of desctableElements %d\n",
+ 					fw_map_dyn->desc_table_num_elements);
+ 			}
+ 			++desc_table;
+ 		}
+ 
+ 	} else if (instance->supportmax256vd) {
+ 		fw_map_ext =
+ 		(struct MR_FW_RAID_MAP_EXT *) fusion->ld_map[(instance->map_id & 1)];
+ 		ld_count = (u16)le16_to_cpu(fw_map_ext->ldCount);
+ 		if (ld_count > MAX_LOGICAL_DRIVES_EXT) {
+ 			dev_dbg(&instance->pdev->dev, "megaraid_sas: LD count exposed in RAID map in not valid\n");
+ 			return;
+ 		}
+ 
+ 		pDrvRaidMap->ldCount = (__le16)cpu_to_le16(ld_count);
+ 		pDrvRaidMap->fpPdIoTimeoutSec = fw_map_ext->fpPdIoTimeoutSec;
+ 		for (i = 0; i < (MAX_LOGICAL_DRIVES_EXT); i++)
+ 			pDrvRaidMap->ldTgtIdToLd[i] =
+ 				(u16)fw_map_ext->ldTgtIdToLd[i];
+ 		memcpy(pDrvRaidMap->ldSpanMap, fw_map_ext->ldSpanMap,
+ 				sizeof(struct MR_LD_SPAN_MAP) * ld_count);
+ 		memcpy(pDrvRaidMap->arMapInfo, fw_map_ext->arMapInfo,
+ 			sizeof(struct MR_ARRAY_INFO) * MAX_API_ARRAYS_EXT);
+ 		memcpy(pDrvRaidMap->devHndlInfo, fw_map_ext->devHndlInfo,
+ 			sizeof(struct MR_DEV_HANDLE_INFO) *
+ 					MAX_RAIDMAP_PHYSICAL_DEVICES);
++>>>>>>> e00731bc5abb (scsi: megaraid_sas: Cleanup VD_EXT_DEBUG and SPAN_DEBUG related debug prints)
  
 +	if (instance->supportmax256vd) {
 +		memcpy(fusion->ld_drv_map[instance->map_id & 1],
 +			fusion->ld_map[instance->map_id & 1],
 +			fusion->current_map_sz);
  		/* New Raid map will not set totalSize, so keep expected value
  		 * for legacy code in ValidateMapInfo
  		 */
@@@ -201,50 -292,14 +291,33 @@@
  			fusion->ld_map[(instance->map_id & 1)];
  		pFwRaidMap = &fw_map_old->raidMap;
  		ld_count = (u16)le32_to_cpu(pFwRaidMap->ldCount);
++<<<<<<< HEAD
 +
 +#if VD_EXT_DEBUG
 +		for (i = 0; i < ld_count; i++) {
 +			dev_dbg(&instance->pdev->dev, "(%d) :Index 0x%x "
 +				"Target Id 0x%x Seq Num 0x%x Size 0/%llx\n",
 +				instance->unique_id, i,
 +				fw_map_old->raidMap.ldSpanMap[i].ldRaid.targetId,
 +				fw_map_old->raidMap.ldSpanMap[i].ldRaid.seqNum,
 +				fw_map_old->raidMap.ldSpanMap[i].ldRaid.size);
 +		}
 +#endif
 +
 +		memset(drv_map, 0, fusion->drv_map_sz);
++=======
++>>>>>>> e00731bc5abb (scsi: megaraid_sas: Cleanup VD_EXT_DEBUG and SPAN_DEBUG related debug prints)
  		pDrvRaidMap->totalSize = pFwRaidMap->totalSize;
  		pDrvRaidMap->ldCount = (__le16)cpu_to_le16(ld_count);
  		pDrvRaidMap->fpPdIoTimeoutSec = pFwRaidMap->fpPdIoTimeoutSec;
  		for (i = 0; i < MAX_RAIDMAP_LOGICAL_DRIVES + MAX_RAIDMAP_VIEWS; i++)
  			pDrvRaidMap->ldTgtIdToLd[i] =
  				(u8)pFwRaidMap->ldTgtIdToLd[i];
 +		for (i = (MAX_RAIDMAP_LOGICAL_DRIVES + MAX_RAIDMAP_VIEWS);
 +			i < MAX_LOGICAL_DRIVES_EXT; i++)
 +			pDrvRaidMap->ldTgtIdToLd[i] = 0xff;
  		for (i = 0; i < ld_count; i++) {
  			pDrvRaidMap->ldSpanMap[i] = pFwRaidMap->ldSpanMap[i];
- #if VD_EXT_DEBUG
- 			dev_dbg(&instance->pdev->dev,
- 				"pFwRaidMap->ldSpanMap[%d].ldRaid.targetId 0x%x "
- 				"pFwRaidMap->ldSpanMap[%d].ldRaid.seqNum 0x%x "
- 				"size 0x%x\n", i, i,
- 				pFwRaidMap->ldSpanMap[i].ldRaid.targetId,
- 				pFwRaidMap->ldSpanMap[i].ldRaid.seqNum,
- 				(u32)pFwRaidMap->ldSpanMap[i].ldRaid.rowSize);
- 			dev_dbg(&instance->pdev->dev,
- 				"pDrvRaidMap->ldSpanMap[%d].ldRaid.targetId 0x%x "
- 				"pDrvRaidMap->ldSpanMap[%d].ldRaid.seqNum 0x%x "
- 				"size 0x%x\n", i, i,
- 				pDrvRaidMap->ldSpanMap[i].ldRaid.targetId,
- 				pDrvRaidMap->ldSpanMap[i].ldRaid.seqNum,
- 				(u32)pDrvRaidMap->ldSpanMap[i].ldRaid.rowSize);
- 			dev_dbg(&instance->pdev->dev, "Driver raid map all %p "
- 				"raid map %p LD RAID MAP %p/%p\n", drv_map,
- 				pDrvRaidMap, &pFwRaidMap->ldSpanMap[i].ldRaid,
- 				&pDrvRaidMap->ldSpanMap[i].ldRaid);
- #endif
  		}
  		memcpy(pDrvRaidMap->arMapInfo, pFwRaidMap->arMapInfo,
  			sizeof(struct MR_ARRAY_INFO) * MAX_RAIDMAP_ARRAYS);
@@@ -1351,30 -1309,36 +1302,33 @@@ u8 megasas_get_best_arm_pd(struct megas
  	pd1 = MR_ArPdGet(arRef, (arm + 1) >= span_row_size ?
  		(arm + 1 - span_row_size) : arm + 1, drv_map);
  
 -	/* Get PD1 Dev Handle */
 +	/* get the pending cmds for the data and mirror arms */
 +	pend0 = atomic_read(&lbInfo->scsi_pending_cmds[pd0]);
 +	pend1 = atomic_read(&lbInfo->scsi_pending_cmds[pd1]);
  
 -	pd1_dev_handle = MR_PdDevHandleGet(pd1, drv_map);
 +	/* Determine the disk whose head is nearer to the req. block */
 +	diff0 = ABS_DIFF(block, lbInfo->last_accessed_block[pd0]);
 +	diff1 = ABS_DIFF(block, lbInfo->last_accessed_block[pd1]);
 +	bestArm = (diff0 <= diff1 ? arm : arm ^ 1);
  
 -	if (pd1_dev_handle == MR_DEVHANDLE_INVALID) {
 -		bestArm = arm;
 -	} else {
 -		/* get the pending cmds for the data and mirror arms */
 -		pend0 = atomic_read(&lbInfo->scsi_pending_cmds[pd0]);
 -		pend1 = atomic_read(&lbInfo->scsi_pending_cmds[pd1]);
 -
 -		/* Determine the disk whose head is nearer to the req. block */
 -		diff0 = ABS_DIFF(block, lbInfo->last_accessed_block[pd0]);
 -		diff1 = ABS_DIFF(block, lbInfo->last_accessed_block[pd1]);
 -		bestArm = (diff0 <= diff1 ? arm : arm ^ 1);
 -
 -		/* Make balance count from 16 to 4 to
 -		 *  keep driver in sync with Firmware
 -		 */
 -		if ((bestArm == arm && pend0 > pend1 + lb_pending_cmds)  ||
 +	if ((bestArm == arm && pend0 > pend1 + lb_pending_cmds)  ||
  			(bestArm != arm && pend1 > pend0 + lb_pending_cmds))
 -			bestArm ^= 1;
 -
 -		/* Update the last accessed block on the correct pd */
 -		io_info->span_arm =
 -			(span << RAID_CTX_SPANARM_SPAN_SHIFT) | bestArm;
 -		io_info->pd_after_lb = (bestArm == arm) ? pd0 : pd1;
 -	}
 +		bestArm ^= 1;
  
 +	/* Update the last accessed block on the correct pd */
 +	io_info->pd_after_lb = (bestArm == arm) ? pd0 : pd1;
  	lbInfo->last_accessed_block[io_info->pd_after_lb] = block + count - 1;
++<<<<<<< HEAD
 +	io_info->span_arm = (span << RAID_CTX_SPANARM_SPAN_SHIFT) | bestArm;
 +#if SPAN_DEBUG
 +	if (arm != bestArm)
 +		dev_dbg(&instance->pdev->dev, "LSI Debug R1 Load balance "
 +			"occur - span 0x%x arm 0x%x bestArm 0x%x "
 +			"io_info->span_arm 0x%x\n",
 +			span, arm, bestArm, io_info->span_arm);
 +#endif
++=======
++>>>>>>> e00731bc5abb (scsi: megaraid_sas: Cleanup VD_EXT_DEBUG and SPAN_DEBUG related debug prints)
  	return io_info->pd_after_lb;
  }
  
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index d09b4ae240a5..14a2bfd64221 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -1344,8 +1344,6 @@ struct megasas_ctrl_info {
 
 #define MEGASAS_FW_BUSY				1
 
-#define VD_EXT_DEBUG 0
-
 /* Driver's internal Logging levels*/
 #define OCR_LOGS    (1 << 0)
 
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fp.c
diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c
index dad24a6b5eae..5971fd1d9ce4 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@ -1056,11 +1056,6 @@ megasas_get_ld_map_info(struct megasas_instance *instance)
 
 	memset(ci, 0, fusion->max_map_sz);
 	memset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);
-#if VD_EXT_DEBUG
-	dev_dbg(&instance->pdev->dev,
-		"%s sending MR_DCMD_LD_MAP_GET_INFO with size %d\n",
-		__func__, cpu_to_le32(size_map_info));
-#endif
 	dcmd->cmd = MFI_CMD_DCMD;
 	dcmd->cmd_status = 0xFF;
 	dcmd->sge_count = 1;
