dell-wmi: Support new hotkeys on the XPS 13 9350 (Skylake)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andy Lutomirski <luto@kernel.org>
commit a464afb9581f6a9eabce8a4aa0c70cb71e6bf4d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a464afb9.failed

The XPS 13 9350 sends WMI keypress events that aren't enumerated in
the DMI table.  Add a table listing them.  To avoid breaking things
that worked before, these un-enumerated hotkeys won't be used if the
DMI table maps them to something else.

FWIW, it appears that the DMI table may be a legacy thing and we
might want to rethink how we handle events in general.  As an
example, a whole lot of things map to KEY_PROG3 via the DMI table.

This doesn't send keypress events for any of the new events.  They
appear to all be handled by other means (keyboard illumination is
handled automatically and rfkill is handled by intel-hid).

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Acked-by: Pali Roh√°r <pali.rohar@gmail.com>
	Signed-off-by: Darren Hart <dvhart@linux.intel.com>
(cherry picked from commit a464afb9581f6a9eabce8a4aa0c70cb71e6bf4d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/dell-wmi.c
diff --cc drivers/platform/x86/dell-wmi.c
index 29c8dbd4c921,e38258a82be5..000000000000
--- a/drivers/platform/x86/dell-wmi.c
+++ b/drivers/platform/x86/dell-wmi.c
@@@ -337,16 -364,56 +361,60 @@@ static void dell_wmi_notify(u32 value, 
  	kfree(obj);
  }
  
++<<<<<<< HEAD
 +static const struct key_entry * __init dell_wmi_prepare_new_keymap(void)
 +{
 +	int hotkey_num = (dell_bios_hotkey_table->header.length - 4) /
++=======
+ static bool have_scancode(u32 scancode, const struct key_entry *keymap, int len)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < len; i++)
+ 		if (keymap[i].code == scancode)
+ 			return true;
+ 
+ 	return false;
+ }
+ 
+ static void __init handle_dmi_entry(const struct dmi_header *dm,
+ 
+ 				    void *opaque)
+ 
+ {
+ 	struct dell_dmi_results *results = opaque;
+ 	struct dell_bios_hotkey_table *table;
+ 	int hotkey_num, i, pos = 0;
+ 	struct key_entry *keymap;
+ 	int num_bios_keys;
+ 
+ 	if (results->err || results->keymap)
+ 		return;		/* We already found the hotkey table. */
+ 
+ 	if (dm->type != 0xb2)
+ 		return;
+ 
+ 	table = container_of(dm, struct dell_bios_hotkey_table, header);
+ 
+ 	hotkey_num = (table->header.length -
+ 		      sizeof(struct dell_bios_hotkey_table)) /
++>>>>>>> a464afb9581f (dell-wmi: Support new hotkeys on the XPS 13 9350 (Skylake))
  				sizeof(struct dell_bios_keymap_entry);
 -	if (hotkey_num < 1) {
 -		/*
 -		 * Historically, dell-wmi would ignore a DMI entry of
 -		 * fewer than 7 bytes.  Sizes between 4 and 8 bytes are
 -		 * nonsensical (both the header and all entries are 4
 -		 * bytes), so we approximate the old behavior by
 -		 * ignoring tables with fewer than one entry.
 -		 */
 -		return;
 -	}
 +	struct key_entry *keymap;
 +	int i;
  
++<<<<<<< HEAD
 +	keymap = kcalloc(hotkey_num + 1, sizeof(struct key_entry), GFP_KERNEL);
 +	if (!keymap)
 +		return NULL;
++=======
+ 	keymap = kcalloc(hotkey_num + ARRAY_SIZE(dell_wmi_extra_keymap) + 1,
+ 			 sizeof(struct key_entry), GFP_KERNEL);
+ 	if (!keymap) {
+ 		results->err = -ENOMEM;
+ 		return;
+ 	}
++>>>>>>> a464afb9581f (dell-wmi: Support new hotkeys on the XPS 13 9350 (Skylake))
  
  	for (i = 0; i < hotkey_num; i++) {
  		const struct dell_bios_keymap_entry *bios_entry =
@@@ -370,16 -437,34 +438,34 @@@
  		}
  
  		if (keycode == KEY_KBDILLUMTOGGLE)
- 			keymap[i].type = KE_IGNORE;
+ 			keymap[pos].type = KE_IGNORE;
  		else
- 			keymap[i].type = KE_KEY;
- 		keymap[i].code = bios_entry->scancode;
- 		keymap[i].keycode = keycode;
+ 			keymap[pos].type = KE_KEY;
+ 		keymap[pos].code = bios_entry->scancode;
+ 		keymap[pos].keycode = keycode;
+ 
+ 		pos++;
+ 	}
+ 
+ 	num_bios_keys = pos;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dell_wmi_extra_keymap); i++) {
+ 		const struct key_entry *entry = &dell_wmi_extra_keymap[i];
+ 
+ 		/*
+ 		 * Check if we've already found this scancode.  This takes
+ 		 * quadratic time, but it doesn't matter unless the list
+ 		 * of extra keys gets very long.
+ 		 */
+ 		if (!have_scancode(entry->code, keymap, num_bios_keys)) {
+ 			keymap[pos] = *entry;
+ 			pos++;
+ 		}
  	}
  
- 	keymap[hotkey_num].type = KE_END;
+ 	keymap[pos].type = KE_END;
  
 -	results->keymap = keymap;
 +	return keymap;
  }
  
  static int __init dell_wmi_input_setup(void)
* Unmerged path drivers/platform/x86/dell-wmi.c
