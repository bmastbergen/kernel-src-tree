drm/nouveau/fb/gf100-: rework ram detection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] nouveau/fb/gf100-: rework ram detection (Ben Skeggs) [1371629]
Rebuild_FUZZ: 95.12%
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 97e5268d57bb2ec9c82cf8758fa97a2f04ea9d1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/97e5268d.failed

This commit reworks the RAM detection algorithm, using RAM-per-LTC to
determine whether a board has a mixed-memory configuration instead of
using RAM-per-FBPA.  I'm not certain the algorithm is perfect, but it
should handle all currently known configurations in the very least.

This should fix GTX 970 boards with 4GiB of RAM where the last 512MiB
isn't fully accessible, as well as only detecting half the VRAM on
GF108 boards.

As a nice side-effect, GP10x memory detection now reuses the majority
of the code from earlier chipsets.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 97e5268d57bb2ec9c82cf8758fa97a2f04ea9d1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/iceland_smumgr.h
#	drivers/gpu/drm/nouveau/nvkm/subdev/fb/ram.h
#	drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
#	drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c
#	drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgm107.c
#	drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgp100.c
diff --cc drivers/gpu/drm/amd/amdgpu/iceland_smumgr.h
index 1e0769e110fa,fd8facf90476..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/iceland_smumgr.h
+++ b/drivers/gpu/drm/amd/amdgpu/iceland_smumgr.h
@@@ -19,23 -19,50 +19,69 @@@
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
   *
 - * Authors: Ben Skeggs <bskeggs@redhat.com>
   */
 -#include "ram.h"
  
++<<<<<<< HEAD:drivers/gpu/drm/amd/amdgpu/iceland_smumgr.h
 +#ifndef ICELAND_SMUMGR_H
 +#define ICELAND_SMUMGR_H
 +
 +#include "ppsmc.h"
 +
 +extern int iceland_smu_init(struct amdgpu_device *adev);
 +extern int iceland_smu_fini(struct amdgpu_device *adev);
 +extern int iceland_smu_start(struct amdgpu_device *adev);
 +
 +struct iceland_smu_private_data
 +{
 +	uint8_t *header;
 +	uint8_t *mec_image;
 +	uint32_t header_addr_high;
 +	uint32_t header_addr_low;
 +};
 +
 +#endif
++=======
+ u32
+ gm200_ram_probe_fbp_amount(const struct nvkm_ram_func *func, u32 fbpao,
+ 			   struct nvkm_device *device, int fbp, int *pltcs)
+ {
+ 	u32 ltcs  = nvkm_rd32(device, 0x022450);
+ 	u32 fbpas = nvkm_rd32(device, 0x022458);
+ 	u32 fbpa  = fbp * fbpas;
+ 	u32 size  = 0;
+ 	if (!(nvkm_rd32(device, 0x021d38) & BIT(fbp))) {
+ 		u32 ltco = nvkm_rd32(device, 0x021d70 + (fbp * 4));
+ 		u32 ltcm = ~ltco & ((1 << ltcs) - 1);
+ 
+ 		while (fbpas--) {
+ 			if (!(fbpao & (1 << fbpa)))
+ 				size += func->probe_fbpa_amount(device, fbpa);
+ 			fbpa++;
+ 		}
+ 
+ 		*pltcs = hweight32(ltcm);
+ 	}
+ 	return size;
+ }
+ 
+ static const struct nvkm_ram_func
+ gm200_ram = {
+ 	.upper = 0x1000000000,
+ 	.probe_fbp = gm107_ram_probe_fbp,
+ 	.probe_fbp_amount = gm200_ram_probe_fbp_amount,
+ 	.probe_fbpa_amount = gf100_ram_probe_fbpa_amount,
+ 	.dtor = gk104_ram_dtor,
+ 	.init = gk104_ram_init,
+ 	.get = gf100_ram_get,
+ 	.put = gf100_ram_put,
+ 	.calc = gk104_ram_calc,
+ 	.prog = gk104_ram_prog,
+ 	.tidy = gk104_ram_tidy,
+ };
+ 
+ int
+ gm200_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)
+ {
+ 	return gk104_ram_new_(&gm200_ram, fb, pram);
+ }
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection):drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgm200.c
diff --cc drivers/gpu/drm/nouveau/nvkm/subdev/fb/ram.h
index ee0cfe09def5,fac7e73c3ddf..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ram.h
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ram.h
@@@ -19,12 -19,38 +19,36 @@@ int  nv50_ram_get(struct nvkm_ram *, u6
  void nv50_ram_put(struct nvkm_ram *, struct nvkm_mem **);
  void __nv50_ram_put(struct nvkm_ram *, struct nvkm_mem *);
  
 -int gf100_ram_new_(const struct nvkm_ram_func *, struct nvkm_fb *,
 -		   struct nvkm_ram **);
  int  gf100_ram_ctor(const struct nvkm_ram_func *, struct nvkm_fb *,
- 		    u32, struct nvkm_ram *);
+ 		    struct nvkm_ram *);
+ u32  gf100_ram_probe_fbp(const struct nvkm_ram_func *,
+ 			 struct nvkm_device *, int, int *);
+ u32  gf100_ram_probe_fbp_amount(const struct nvkm_ram_func *, u32,
+ 				struct nvkm_device *, int, int *);
+ u32  gf100_ram_probe_fbpa_amount(struct nvkm_device *, int);
  int  gf100_ram_get(struct nvkm_ram *, u64, u32, u32, u32, struct nvkm_mem **);
  void gf100_ram_put(struct nvkm_ram *, struct nvkm_mem **);
 -int gf100_ram_init(struct nvkm_ram *);
 -int gf100_ram_calc(struct nvkm_ram *, u32);
 -int gf100_ram_prog(struct nvkm_ram *);
 -void gf100_ram_tidy(struct nvkm_ram *);
  
++<<<<<<< HEAD
 +int  gk104_ram_init(struct nvkm_ram *ram);
++=======
+ u32 gf108_ram_probe_fbp_amount(const struct nvkm_ram_func *, u32,
+ 			       struct nvkm_device *, int, int *);
+ 
+ int gk104_ram_new_(const struct nvkm_ram_func *, struct nvkm_fb *,
+ 		   struct nvkm_ram **);
+ void *gk104_ram_dtor(struct nvkm_ram *);
+ int gk104_ram_init(struct nvkm_ram *);
+ int gk104_ram_calc(struct nvkm_ram *, u32);
+ int gk104_ram_prog(struct nvkm_ram *);
+ void gk104_ram_tidy(struct nvkm_ram *);
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
+ 
+ u32 gm107_ram_probe_fbp(const struct nvkm_ram_func *,
+ 			struct nvkm_device *, int, int *);
+ 
+ u32 gm200_ram_probe_fbp_amount(const struct nvkm_ram_func *, u32,
+ 			       struct nvkm_device *, int, int *);
  
  /* RAM type-specific MR calculation routines */
  int nvkm_sddr2_calc(struct nvkm_ram *);
diff --cc drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
index 772425ca5a9e,53c32fc694e9..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
@@@ -545,15 -543,30 +545,42 @@@ gf100_ram_init(struct nvkm_ram *base
  	return 0;
  }
  
++<<<<<<< HEAD
 +static const struct nvkm_ram_func
 +gf100_ram_func = {
 +	.init = gf100_ram_init,
 +	.get = gf100_ram_get,
 +	.put = gf100_ram_put,
 +	.calc = gf100_ram_calc,
 +	.prog = gf100_ram_prog,
 +	.tidy = gf100_ram_tidy,
 +};
++=======
+ u32
+ gf100_ram_probe_fbpa_amount(struct nvkm_device *device, int fbpa)
+ {
+ 	return nvkm_rd32(device, 0x11020c + (fbpa * 0x1000));
+ }
+ 
+ u32
+ gf100_ram_probe_fbp_amount(const struct nvkm_ram_func *func, u32 fbpao,
+ 			   struct nvkm_device *device, int fbp, int *pltcs)
+ {
+ 	if (!(fbpao & BIT(fbp))) {
+ 		*pltcs = 1;
+ 		return func->probe_fbpa_amount(device, fbp);
+ 	}
+ 	return 0;
+ }
+ 
+ u32
+ gf100_ram_probe_fbp(const struct nvkm_ram_func *func,
+ 		    struct nvkm_device *device, int fbp, int *pltcs)
+ {
+ 	u32 fbpao = nvkm_rd32(device, 0x022554);
+ 	return func->probe_fbp_amount(func, fbpao, device, fbp, pltcs);
+ }
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
  
  int
  gf100_ram_ctor(const struct nvkm_ram_func *func, struct nvkm_fb *fb,
@@@ -637,7 -655,7 +668,11 @@@ gf100_ram_new(struct nvkm_fb *fb, struc
  		return -ENOMEM;
  	*pram = &ram->base;
  
++<<<<<<< HEAD
 +	ret = gf100_ram_ctor(&gf100_ram_func, fb, 0x022554, &ram->base);
++=======
+ 	ret = gf100_ram_ctor(func, fb, &ram->base);
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
  	if (ret)
  		return ret;
  
@@@ -713,3 -731,23 +748,26 @@@
  	ram->fuc.r_0x13d8f4 = ramfuc_reg(0x13d8f4);
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static const struct nvkm_ram_func
+ gf100_ram = {
+ 	.upper = 0x0200000000,
+ 	.probe_fbp = gf100_ram_probe_fbp,
+ 	.probe_fbp_amount = gf100_ram_probe_fbp_amount,
+ 	.probe_fbpa_amount = gf100_ram_probe_fbpa_amount,
+ 	.init = gf100_ram_init,
+ 	.get = gf100_ram_get,
+ 	.put = gf100_ram_put,
+ 	.calc = gf100_ram_calc,
+ 	.prog = gf100_ram_prog,
+ 	.tidy = gf100_ram_tidy,
+ };
+ 
+ int
+ gf100_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)
+ {
+ 	return gf100_ram_new_(&gf100_ram, fb, pram);
+ }
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
diff --cc drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c
index 1fa3ade468ae,f6c00791722c..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c
@@@ -1516,19 -1522,9 +1516,24 @@@ gk104_ram_dtor(struct nvkm_ram *base
  	return ram;
  }
  
 +static const struct nvkm_ram_func
 +gk104_ram_func = {
 +	.dtor = gk104_ram_dtor,
 +	.init = gk104_ram_init,
 +	.get = gf100_ram_get,
 +	.put = gf100_ram_put,
 +	.calc = gk104_ram_calc,
 +	.prog = gk104_ram_prog,
 +	.tidy = gk104_ram_tidy,
 +};
 +
  int
++<<<<<<< HEAD
 +gk104_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)
++=======
+ gk104_ram_new_(const struct nvkm_ram_func *func, struct nvkm_fb *fb,
+ 	       struct nvkm_ram **pram)
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
  {
  	struct nvkm_subdev *subdev = &fb->subdev;
  	struct nvkm_device *device = subdev->device;
@@@ -1544,7 -1539,7 +1549,11 @@@
  		return -ENOMEM;
  	*pram = &ram->base;
  
++<<<<<<< HEAD
 +	ret = gf100_ram_ctor(&gk104_ram_func, fb, 0x022554, &ram->base);
++=======
+ 	ret = gf100_ram_ctor(func, fb, &ram->base);
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
  	if (ret)
  		return ret;
  
@@@ -1705,3 -1700,24 +1714,27 @@@
  	ram->fuc.r_0x100750 = ramfuc_reg(0x100750);
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static const struct nvkm_ram_func
+ gk104_ram = {
+ 	.upper = 0x0200000000,
+ 	.probe_fbp = gf100_ram_probe_fbp,
+ 	.probe_fbp_amount = gf108_ram_probe_fbp_amount,
+ 	.probe_fbpa_amount = gf100_ram_probe_fbpa_amount,
+ 	.dtor = gk104_ram_dtor,
+ 	.init = gk104_ram_init,
+ 	.get = gf100_ram_get,
+ 	.put = gf100_ram_put,
+ 	.calc = gk104_ram_calc,
+ 	.prog = gk104_ram_prog,
+ 	.tidy = gk104_ram_tidy,
+ };
+ 
+ int
+ gk104_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)
+ {
+ 	return gk104_ram_new_(&gk104_ram, fb, pram);
+ }
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
diff --cc drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgm107.c
index 43d807f6ca71,3f0b56347291..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgm107.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgm107.c
@@@ -23,8 -23,21 +23,25 @@@
   */
  #include "ram.h"
  
+ u32
+ gm107_ram_probe_fbp(const struct nvkm_ram_func *func,
+ 		    struct nvkm_device *device, int fbp, int *pltcs)
+ {
+ 	u32 fbpao = nvkm_rd32(device, 0x021c14);
+ 	return func->probe_fbp_amount(func, fbpao, device, fbp, pltcs);
+ }
+ 
  static const struct nvkm_ram_func
++<<<<<<< HEAD
 +gm107_ram_func = {
++=======
+ gm107_ram = {
+ 	.upper = 0x1000000000,
+ 	.probe_fbp = gm107_ram_probe_fbp,
+ 	.probe_fbp_amount = gf108_ram_probe_fbp_amount,
+ 	.probe_fbpa_amount = gf100_ram_probe_fbpa_amount,
+ 	.dtor = gk104_ram_dtor,
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
  	.init = gk104_ram_init,
  	.get = gf100_ram_get,
  	.put = gf100_ram_put,
@@@ -33,8 -49,5 +50,12 @@@
  int
  gm107_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)
  {
++<<<<<<< HEAD
 +	if (!(*pram = kzalloc(sizeof(**pram), GFP_KERNEL)))
 +		return -ENOMEM;
 +
 +	return gf100_ram_ctor(&gm107_ram_func, fb, 0x021c14, *pram);
++=======
+ 	return gk104_ram_new_(&gm107_ram, fb, pram);
++>>>>>>> 97e5268d57bb (drm/nouveau/fb/gf100-: rework ram detection)
  }
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgp100.c
* Unmerged path drivers/gpu/drm/amd/amdgpu/iceland_smumgr.h
diff --git a/drivers/gpu/drm/nouveau/include/nvkm/subdev/fb.h b/drivers/gpu/drm/nouveau/include/nvkm/subdev/fb.h
index b921cc4e3677..40ef7131f91c 100644
--- a/drivers/gpu/drm/nouveau/include/nvkm/subdev/fb.h
+++ b/drivers/gpu/drm/nouveau/include/nvkm/subdev/fb.h
@@ -138,6 +138,12 @@ struct nvkm_ram {
 };
 
 struct nvkm_ram_func {
+	u64 upper;
+	u32 (*probe_fbp)(const struct nvkm_ram_func *, struct nvkm_device *,
+			 int fbp, int *pltcs);
+	u32 (*probe_fbp_amount)(const struct nvkm_ram_func *, u32 fbpao,
+				struct nvkm_device *, int fbp, int *pltcs);
+	u32 (*probe_fbpa_amount)(struct nvkm_device *, int fbpa);
 	void *(*dtor)(struct nvkm_ram *);
 	int (*init)(struct nvkm_ram *);
 
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/fb/ram.h
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf108.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf108.c
index ddab0db3a7a5..985ec64cf369 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf108.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf108.c
@@ -23,8 +23,30 @@
  */
 #include "ram.h"
 
+u32
+gf108_ram_probe_fbp_amount(const struct nvkm_ram_func *func, u32 fbpao,
+			   struct nvkm_device *device, int fbp, int *pltcs)
+{
+	u32 fbpt  = nvkm_rd32(device, 0x022438);
+	u32 fbpat = nvkm_rd32(device, 0x02243c);
+	u32 fbpas = fbpat / fbpt;
+	u32 fbpa  = fbp * fbpas;
+	u32 size  = 0;
+	while (fbpas--) {
+		if (!(fbpao & BIT(fbpa)))
+			size += func->probe_fbpa_amount(device, fbpa);
+		fbpa++;
+	}
+	*pltcs = 1;
+	return size;
+}
+
 static const struct nvkm_ram_func
 gf108_ram = {
+	.upper = 0x0200000000,
+	.probe_fbp = gf100_ram_probe_fbp,
+	.probe_fbp_amount = gf108_ram_probe_fbp_amount,
+	.probe_fbpa_amount = gf100_ram_probe_fbpa_amount,
 	.init = gf100_ram_init,
 	.get = gf100_ram_get,
 	.put = gf100_ram_put,
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgm107.c
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgp100.c
