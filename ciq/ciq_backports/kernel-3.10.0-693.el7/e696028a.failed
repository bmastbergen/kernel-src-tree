net/sched: Reflect HW offload status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: Reflect HW offload status (Ivan Vecera) [1390693]
Rebuild_FUZZ: 94.12%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit e696028acc458aa3d43ad899371a963eb28336d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e696028a.failed

Currently there is no way of querying whether a filter is
offloaded to HW or not when using "both" policy (where none
of skip_sw or skip_hw flags are set by user-space).

Add two new flags, "in hw" and "not in hw" such that user
space can determine if a filter is actually offloaded to
hw or not. The "in hw" UAPI semantics was chosen so it's
similar to the "skip hw" flag logic.

If none of these two flags are set, this signals running
over older kernel.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Amir Vadai <amir@vadai.me>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e696028acc458aa3d43ad899371a963eb28336d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	include/uapi/linux/pkt_cls.h
diff --cc include/net/pkt_cls.h
index b606c03c3836,269fd78bb0ae..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -392,9 -435,106 +392,98 @@@ struct tc_cls_u32_offload 
  	};
  };
  
 -static inline bool tc_can_offload(const struct net_device *dev,
 -				  const struct tcf_proto *tp)
 +static inline bool tc_should_offload(struct net_device *dev)
  {
 -	const struct Qdisc *sch = tp->q;
 -	const struct Qdisc_class_ops *cops = sch->ops->cl_ops;
 -
 -	if (!(dev->features & NETIF_F_HW_TC))
 -		return false;
 -	if (!dev->netdev_ops->ndo_setup_tc)
 -		return false;
 -	if (cops && cops->tcf_cl_offload)
 -		return cops->tcf_cl_offload(tp->classid);
 -
 -	return true;
 +	return dev->netdev_ops->ndo_setup_tc;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool tc_skip_hw(u32 flags)
+ {
+ 	return (flags & TCA_CLS_FLAGS_SKIP_HW) ? true : false;
+ }
+ 
+ static inline bool tc_should_offload(const struct net_device *dev,
+ 				     const struct tcf_proto *tp, u32 flags)
+ {
+ 	if (tc_skip_hw(flags))
+ 		return false;
+ 	return tc_can_offload(dev, tp);
+ }
+ 
+ static inline bool tc_skip_sw(u32 flags)
+ {
+ 	return (flags & TCA_CLS_FLAGS_SKIP_SW) ? true : false;
+ }
+ 
+ /* SKIP_HW and SKIP_SW are mutually exclusive flags. */
+ static inline bool tc_flags_valid(u32 flags)
+ {
+ 	if (flags & ~(TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW))
+ 		return false;
+ 
+ 	if (!(flags ^ (TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW)))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static inline bool tc_in_hw(u32 flags)
+ {
+ 	return (flags & TCA_CLS_FLAGS_IN_HW) ? true : false;
+ }
+ 
+ enum tc_fl_command {
+ 	TC_CLSFLOWER_REPLACE,
+ 	TC_CLSFLOWER_DESTROY,
+ 	TC_CLSFLOWER_STATS,
+ };
+ 
+ struct tc_cls_flower_offload {
+ 	enum tc_fl_command command;
+ 	u32 prio;
+ 	unsigned long cookie;
+ 	struct flow_dissector *dissector;
+ 	struct fl_flow_key *mask;
+ 	struct fl_flow_key *key;
+ 	struct tcf_exts *exts;
+ };
+ 
+ enum tc_matchall_command {
+ 	TC_CLSMATCHALL_REPLACE,
+ 	TC_CLSMATCHALL_DESTROY,
+ };
+ 
+ struct tc_cls_matchall_offload {
+ 	enum tc_matchall_command command;
+ 	struct tcf_exts *exts;
+ 	unsigned long cookie;
+ };
+ 
+ enum tc_clsbpf_command {
+ 	TC_CLSBPF_ADD,
+ 	TC_CLSBPF_REPLACE,
+ 	TC_CLSBPF_DESTROY,
+ 	TC_CLSBPF_STATS,
+ };
+ 
+ struct tc_cls_bpf_offload {
+ 	enum tc_clsbpf_command command;
+ 	struct tcf_exts *exts;
+ 	struct bpf_prog *prog;
+ 	const char *name;
+ 	bool exts_integrated;
+ 	u32 gen_flags;
+ };
+ 
+ 
+ /* This structure holds cookie structure that is passed from user
+  * to the kernel for actions and classifiers
+  */
+ struct tc_cookie {
+ 	u8  *data;
+ 	u32 len;
+ };
++>>>>>>> e696028acc45 (net/sched: Reflect HW offload status)
  #endif
diff --cc include/uapi/linux/pkt_cls.h
index 3abfe7f00823,7a69f2a4ca0c..000000000000
--- a/include/uapi/linux/pkt_cls.h
+++ b/include/uapi/linux/pkt_cls.h
@@@ -171,6 -102,12 +171,15 @@@ enum 
  
  #define TCA_POLICE_MAX (__TCA_POLICE_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ /* tca flags definitions */
+ #define TCA_CLS_FLAGS_SKIP_HW	(1 << 0) /* don't offload filter to HW */
+ #define TCA_CLS_FLAGS_SKIP_SW	(1 << 1) /* don't use filter in SW */
+ #define TCA_CLS_FLAGS_IN_HW	(1 << 2) /* filter is offloaded to HW */
+ #define TCA_CLS_FLAGS_NOT_IN_HW (1 << 3) /* filter isn't offloaded to HW */
+ 
++>>>>>>> e696028acc45 (net/sched: Reflect HW offload status)
  /* U32 filters */
  
  #define TC_U32_HTID(h) ((h)&0xFFF00000)
* Unmerged path include/net/pkt_cls.h
* Unmerged path include/uapi/linux/pkt_cls.h
