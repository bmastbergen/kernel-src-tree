dax: for truncate/hole-punch, do zeroing through the driver if possible

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Vishal Verma <vishal.l.verma@intel.com>
commit 4b0228fa1d753f77fe0e6cf4c41398ec77dfbd2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4b0228fa.failed

In the truncate or hole-punch path in dax, we clear out sub-page ranges.
If these sub-page ranges are sector aligned and sized, we can do the
zeroing through the driver instead so that error-clearing is handled
automatically.

For sub-sector ranges, we still have to rely on clear_pmem and have the
possibility of tripping over errors.

	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Jan Kara <jack@suse.cz>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
(cherry picked from commit 4b0228fa1d753f77fe0e6cf4c41398ec77dfbd2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index 2dc57eba7712,0b9a16934017..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -1058,6 -947,43 +1058,46 @@@ int dax_pfn_mkwrite(struct vm_area_stru
  }
  EXPORT_SYMBOL_GPL(dax_pfn_mkwrite);
  
++<<<<<<< HEAD
++=======
+ static bool dax_range_is_aligned(struct block_device *bdev,
+ 				 unsigned int offset, unsigned int length)
+ {
+ 	unsigned short sector_size = bdev_logical_block_size(bdev);
+ 
+ 	if (!IS_ALIGNED(offset, sector_size))
+ 		return false;
+ 	if (!IS_ALIGNED(length, sector_size))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ int __dax_zero_page_range(struct block_device *bdev, sector_t sector,
+ 		unsigned int offset, unsigned int length)
+ {
+ 	struct blk_dax_ctl dax = {
+ 		.sector		= sector,
+ 		.size		= PAGE_SIZE,
+ 	};
+ 
+ 	if (dax_range_is_aligned(bdev, offset, length)) {
+ 		sector_t start_sector = dax.sector + (offset >> 9);
+ 
+ 		return blkdev_issue_zeroout(bdev, start_sector,
+ 				length >> 9, GFP_NOFS, true);
+ 	} else {
+ 		if (dax_map_atomic(bdev, &dax) < 0)
+ 			return PTR_ERR(dax.addr);
+ 		clear_pmem(dax.addr + offset, length);
+ 		wmb_pmem();
+ 		dax_unmap_atomic(bdev, &dax);
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(__dax_zero_page_range);
+ 
++>>>>>>> 4b0228fa1d75 (dax: for truncate/hole-punch, do zeroing through the driver if possible)
  /**
   * dax_zero_page_range - zero a range within a page of a DAX file
   * @inode: The file being truncated
diff --git a/Documentation/filesystems/dax.txt b/Documentation/filesystems/dax.txt
index c83efbfcdab2..616ca39cb7f0 100644
--- a/Documentation/filesystems/dax.txt
+++ b/Documentation/filesystems/dax.txt
@@ -77,6 +77,38 @@ These filesystems may be used for inspiration:
 - ext4: the fourth extended filesystem, see Documentation/filesystems/ext4.txt
 
 
+Handling Media Errors
+---------------------
+
+The libnvdimm subsystem stores a record of known media error locations for
+each pmem block device (in gendisk->badblocks). If we fault at such location,
+or one with a latent error not yet discovered, the application can expect
+to receive a SIGBUS. Libnvdimm also allows clearing of these errors by simply
+writing the affected sectors (through the pmem driver, and if the underlying
+NVDIMM supports the clear_poison DSM defined by ACPI).
+
+Since DAX IO normally doesn't go through the driver/bio path, applications or
+sysadmins have an option to restore the lost data from a prior backup/inbuilt
+redundancy in the following ways:
+
+1. Delete the affected file, and restore from a backup (sysadmin route):
+   This will free the file system blocks that were being used by the file,
+   and the next time they're allocated, they will be zeroed first, which
+   happens through the driver, and will clear bad sectors.
+
+2. Truncate or hole-punch the part of the file that has a bad-block (at least
+   an entire aligned sector has to be hole-punched, but not necessarily an
+   entire filesystem block).
+
+These are the two basic paths that allow DAX filesystems to continue operating
+in the presence of media errors. More robust error recovery mechanisms can be
+built on top of this in the future, for example, involving redundancy/mirroring
+provided at the block layer through DM, or additionally, at the filesystem
+level. These would have to rely on the above two tenets, that error clearing
+can happen either by sending an IO through the driver, or zeroing (also through
+the driver).
+
+
 Shortcomings
 ------------
 
* Unmerged path fs/dax.c
