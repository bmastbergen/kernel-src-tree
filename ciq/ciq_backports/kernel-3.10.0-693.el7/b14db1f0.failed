IB/hfi1: Add sysfs entry to override SDMA interrupt affinity

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tadeusz Struk <tadeusz.struk@intel.com>
commit b14db1f0aa4fccd0e5ebcbe588d1136f3a23dbc6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b14db1f0.failed

Add sysfs entry to allow user to override affinity for SDMA
engine interrupts.

	Reviewed-by: Dean Luick <dean.luick@intel.com>
	Signed-off-by: Tadeusz Struk <tadeusz.struk@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit b14db1f0aa4fccd0e5ebcbe588d1136f3a23dbc6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/affinity.c
#	drivers/infiniband/hw/hfi1/affinity.h
diff --cc drivers/infiniband/hw/hfi1/affinity.c
index 1ca2154de24c,79575ee873f2..000000000000
--- a/drivers/infiniband/hw/hfi1/affinity.c
+++ b/drivers/infiniband/hw/hfi1/affinity.c
@@@ -423,6 -672,72 +424,75 @@@ void hfi1_put_proc_affinity(struct hfi1
  		set->gen--;
  		cpumask_copy(&set->used, &set->mask);
  	}
 -	spin_unlock(&affinity->lock);
 +	spin_unlock(&dd->affinity->lock);
  }
  
++<<<<<<< HEAD
++=======
+ /* Prevents concurrent reads and writes of the sdma_affinity attrib */
+ static DEFINE_MUTEX(sdma_affinity_mutex);
+ 
+ int hfi1_set_sdma_affinity(struct hfi1_devdata *dd, const char *buf,
+ 			   size_t count)
+ {
+ 	struct hfi1_affinity_node *entry;
+ 	struct cpumask mask;
+ 	int ret, i;
+ 
+ 	spin_lock(&node_affinity.lock);
+ 	entry = node_affinity_lookup(dd->node);
+ 	spin_unlock(&node_affinity.lock);
+ 
+ 	if (!entry)
+ 		return -EINVAL;
+ 
+ 	ret = cpulist_parse(buf, &mask);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!cpumask_subset(&mask, cpu_online_mask) || cpumask_empty(&mask)) {
+ 		dd_dev_warn(dd, "Invalid CPU mask\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	mutex_lock(&sdma_affinity_mutex);
+ 	/* reset the SDMA interrupt affinity details */
+ 	init_cpu_mask_set(&entry->def_intr);
+ 	cpumask_copy(&entry->def_intr.mask, &mask);
+ 	/*
+ 	 * Reassign the affinity for each SDMA interrupt.
+ 	 */
+ 	for (i = 0; i < dd->num_msix_entries; i++) {
+ 		struct hfi1_msix_entry *msix;
+ 
+ 		msix = &dd->msix_entries[i];
+ 		if (msix->type != IRQ_SDMA)
+ 			continue;
+ 
+ 		ret = hfi1_get_irq_affinity(dd, msix);
+ 
+ 		if (ret)
+ 			break;
+ 	}
+ 
+ 	mutex_unlock(&sdma_affinity_mutex);
+ 	return ret ? ret : strnlen(buf, PAGE_SIZE);
+ }
+ 
+ int hfi1_get_sdma_affinity(struct hfi1_devdata *dd, char *buf)
+ {
+ 	struct hfi1_affinity_node *entry;
+ 
+ 	spin_lock(&node_affinity.lock);
+ 	entry = node_affinity_lookup(dd->node);
+ 	spin_unlock(&node_affinity.lock);
+ 
+ 	if (!entry)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&sdma_affinity_mutex);
+ 	cpumap_print_to_pagebuf(true, buf, &entry->def_intr.mask);
+ 	mutex_unlock(&sdma_affinity_mutex);
+ 	return strnlen(buf, PAGE_SIZE);
+ }
++>>>>>>> b14db1f0aa4f (IB/hfi1: Add sysfs entry to override SDMA interrupt affinity)
diff --cc drivers/infiniband/hw/hfi1/affinity.h
index 20f52fe74091,8879cf7a8cac..000000000000
--- a/drivers/infiniband/hw/hfi1/affinity.h
+++ b/drivers/infiniband/hw/hfi1/affinity.h
@@@ -101,8 -98,35 +101,39 @@@ void hfi1_put_irq_affinity(struct hfi1_
   * Determine a CPU affinity for a user process, if the process does not
   * have an affinity set yet.
   */
 -int hfi1_get_proc_affinity(int);
 +int hfi1_get_proc_affinity(struct hfi1_devdata *, int);
  /* Release a CPU used by a user process. */
++<<<<<<< HEAD
 +void hfi1_put_proc_affinity(struct hfi1_devdata *, int);
++=======
+ void hfi1_put_proc_affinity(int);
+ 
+ int hfi1_get_sdma_affinity(struct hfi1_devdata *dd, char *buf);
+ int hfi1_set_sdma_affinity(struct hfi1_devdata *dd, const char *buf,
+ 			   size_t count);
+ 
+ struct hfi1_affinity_node {
+ 	int node;
+ 	struct cpu_mask_set def_intr;
+ 	struct cpu_mask_set rcv_intr;
+ 	struct cpumask general_intr_mask;
+ 	struct list_head list;
+ };
+ 
+ struct hfi1_affinity_node_list {
+ 	struct list_head list;
+ 	struct cpumask real_cpu_mask;
+ 	struct cpu_mask_set proc;
+ 	int num_core_siblings;
+ 	int num_online_nodes;
+ 	int num_online_cpus;
+ 	/* protect affinity node list */
+ 	spinlock_t lock;
+ };
+ 
+ int node_affinity_init(void);
+ void node_affinity_destroy(void);
+ extern struct hfi1_affinity_node_list node_affinity;
++>>>>>>> b14db1f0aa4f (IB/hfi1: Add sysfs entry to override SDMA interrupt affinity)
  
  #endif /* _HFI1_AFFINITY_H */
* Unmerged path drivers/infiniband/hw/hfi1/affinity.c
* Unmerged path drivers/infiniband/hw/hfi1/affinity.h
diff --git a/drivers/infiniband/hw/hfi1/sysfs.c b/drivers/infiniband/hw/hfi1/sysfs.c
index 91fc2aed6aed..74c84c655f7e 100644
--- a/drivers/infiniband/hw/hfi1/sysfs.c
+++ b/drivers/infiniband/hw/hfi1/sysfs.c
@@ -49,6 +49,7 @@
 #include "hfi.h"
 #include "mad.h"
 #include "trace.h"
+#include "affinity.h"
 
 /*
  * Start of per-port congestion control structures and support code
@@ -622,6 +623,27 @@ static ssize_t show_tempsense(struct device *device,
 	return ret;
 }
 
+static ssize_t show_sdma_affinity(struct device *device,
+				  struct device_attribute *attr, char *buf)
+{
+	struct hfi1_ibdev *dev =
+		container_of(device, struct hfi1_ibdev, rdi.ibdev.dev);
+	struct hfi1_devdata *dd = dd_from_dev(dev);
+
+	return hfi1_get_sdma_affinity(dd, buf);
+}
+
+static ssize_t store_sdma_affinity(struct device *device,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct hfi1_ibdev *dev =
+		container_of(device, struct hfi1_ibdev, rdi.ibdev.dev);
+	struct hfi1_devdata *dd = dd_from_dev(dev);
+
+	return hfi1_set_sdma_affinity(dd, buf, count);
+}
+
 /*
  * end of per-unit (or driver, in some cases, but replicated
  * per unit) functions
@@ -636,6 +658,8 @@ static DEVICE_ATTR(serial, S_IRUGO, show_serial, NULL);
 static DEVICE_ATTR(boardversion, S_IRUGO, show_boardversion, NULL);
 static DEVICE_ATTR(tempsense, S_IRUGO, show_tempsense, NULL);
 static DEVICE_ATTR(chip_reset, S_IWUSR, NULL, store_chip_reset);
+static DEVICE_ATTR(sdma_affinity, S_IWUSR | S_IRUGO, show_sdma_affinity,
+		   store_sdma_affinity);
 
 static struct device_attribute *hfi1_attributes[] = {
 	&dev_attr_hw_rev,
@@ -646,6 +670,7 @@ static struct device_attribute *hfi1_attributes[] = {
 	&dev_attr_boardversion,
 	&dev_attr_tempsense,
 	&dev_attr_chip_reset,
+	&dev_attr_sdma_affinity,
 };
 
 int hfi1_create_port_files(struct ib_device *ibdev, u8 port_num,
