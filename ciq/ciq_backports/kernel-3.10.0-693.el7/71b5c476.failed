HID: wacom: Simplify check for presence of single-finger touch

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Simplify check for presence of single-finger touch (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.80%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 71b5c4766c1ca4c646a90f64552b140b1368f2f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/71b5c476.failed

To determine if a touch is present in the single-touch case, we can
simply check if the BTN_TOUCH key is active or not. This will work for
both HID_GENERIC and other device types.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 71b5c4766c1ca4c646a90f64552b140b1368f2f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index bc916ccd4c20,091bab4a0034..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -853,6 -1019,73 +853,76 @@@ static int int_dist(int x1, int y1, in
  	return int_sqrt(x*x + y*y);
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_intuos_bt_process_data(struct wacom_wac *wacom,
+ 		unsigned char *data)
+ {
+ 	memcpy(wacom->data, data, 10);
+ 	wacom_intuos_irq(wacom);
+ 
+ 	input_sync(wacom->input);
+ 	if (wacom->pad_input)
+ 		input_sync(wacom->pad_input);
+ }
+ 
+ static int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)
+ {
+ 	unsigned char data[WACOM_PKGLEN_MAX];
+ 	int i = 1;
+ 	unsigned power_raw, battery_capacity, bat_charging, ps_connected;
+ 
+ 	memcpy(data, wacom->data, len);
+ 
+ 	switch (data[0]) {
+ 	case 0x04:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		/* fall through */
+ 	case 0x03:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		power_raw = data[i];
+ 		bat_charging = (power_raw & 0x08) ? 1 : 0;
+ 		ps_connected = (power_raw & 0x10) ? 1 : 0;
+ 		battery_capacity = batcap_i4[power_raw & 0x07];
+ 		wacom_notify_battery(wacom, battery_capacity, bat_charging,
+ 				     battery_capacity || bat_charging,
+ 				     ps_connected);
+ 		break;
+ 	default:
+ 		dev_dbg(wacom->input->dev.parent,
+ 				"Unknown report: %d,%d size:%zu\n",
+ 				data[0], data[1], len);
+ 		return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ static int wacom_wac_finger_count_touches(struct wacom_wac *wacom)
+ {
+ 	struct input_dev *input = wacom->input;
+ 	unsigned touch_max = wacom->features.touch_max;
+ 	int count = 0;
+ 	int i;
+ 
+ 	if (touch_max == 1)
+ 		return test_bit(BTN_TOUCH, input->key) &&
+ 		       !wacom->shared->stylus_in_proximity;
+ 
+ 	for (i = 0; i < input->mt->num_slots; i++) {
+ 		struct input_mt_slot *ps = &input->mt->slots[i];
+ 		int id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);
+ 		if (id >= 0)
+ 			count++;
+ 	}
+ 
+ 	return count;
+ }
+ 
++>>>>>>> 71b5c4766c1c (HID: wacom: Simplify check for presence of single-finger touch)
  static int wacom_24hdt_irq(struct wacom_wac *wacom)
  {
  	struct input_dev *input = wacom->input;
* Unmerged path drivers/hid/wacom_wac.c
