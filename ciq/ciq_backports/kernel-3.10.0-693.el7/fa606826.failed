nvme: use symbolic constants for CNS values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [nvme] use symbolic constants for CNS values (David Milburn) [1384526 1389755 1366753 1374291 1383834]
Rebuild_FUZZ: 92.50%
commit-author Christoph Hellwig <hch@lst.de>
commit fa60682677c594d81e9b68b8a4046cde75a7374b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fa606826.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Gabriel Krisman Bertazi <krisman@linux.vnet.ibm.com>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit fa60682677c594d81e9b68b8a4046cde75a7374b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 0588703d149f,79e679d12f3b..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -266,14 -479,83 +266,21 @@@ int nvme_submit_user_cmd(struct request
  			result, timeout);
  }
  
 -static void nvme_keep_alive_end_io(struct request *rq, int error)
 -{
 -	struct nvme_ctrl *ctrl = rq->end_io_data;
 -
 -	blk_mq_free_request(rq);
 -
 -	if (error) {
 -		dev_err(ctrl->device,
 -			"failed nvme_keep_alive_end_io error=%d\n", error);
 -		return;
 -	}
 -
 -	schedule_delayed_work(&ctrl->ka_work, ctrl->kato * HZ);
 -}
 -
 -static int nvme_keep_alive(struct nvme_ctrl *ctrl)
 -{
 -	struct nvme_command c;
 -	struct request *rq;
 -
 -	memset(&c, 0, sizeof(c));
 -	c.common.opcode = nvme_admin_keep_alive;
 -
 -	rq = nvme_alloc_request(ctrl->admin_q, &c, BLK_MQ_REQ_RESERVED,
 -			NVME_QID_ANY);
 -	if (IS_ERR(rq))
 -		return PTR_ERR(rq);
 -
 -	rq->timeout = ctrl->kato * HZ;
 -	rq->end_io_data = ctrl;
 -
 -	blk_execute_rq_nowait(rq->q, NULL, rq, 0, nvme_keep_alive_end_io);
 -
 -	return 0;
 -}
 -
 -static void nvme_keep_alive_work(struct work_struct *work)
 -{
 -	struct nvme_ctrl *ctrl = container_of(to_delayed_work(work),
 -			struct nvme_ctrl, ka_work);
 -
 -	if (nvme_keep_alive(ctrl)) {
 -		/* allocation failure, reset the controller */
 -		dev_err(ctrl->device, "keep-alive failed\n");
 -		ctrl->ops->reset_ctrl(ctrl);
 -		return;
 -	}
 -}
 -
 -void nvme_start_keep_alive(struct nvme_ctrl *ctrl)
 -{
 -	if (unlikely(ctrl->kato == 0))
 -		return;
 -
 -	INIT_DELAYED_WORK(&ctrl->ka_work, nvme_keep_alive_work);
 -	schedule_delayed_work(&ctrl->ka_work, ctrl->kato * HZ);
 -}
 -EXPORT_SYMBOL_GPL(nvme_start_keep_alive);
 -
 -void nvme_stop_keep_alive(struct nvme_ctrl *ctrl)
 -{
 -	if (unlikely(ctrl->kato == 0))
 -		return;
 -
 -	cancel_delayed_work_sync(&ctrl->ka_work);
 -}
 -EXPORT_SYMBOL_GPL(nvme_stop_keep_alive);
 -
  int nvme_identify_ctrl(struct nvme_ctrl *dev, struct nvme_id_ctrl **id)
  {
 -	struct nvme_command c = { };
 +	struct nvme_command c = {
 +		.identify.opcode = nvme_admin_identify,
 +		.identify.cns = cpu_to_le32(1),
 +	};
  	int error;
  
++<<<<<<< HEAD
++=======
+ 	/* gcc-4.4.4 (at least) has issues with initializers and anon unions */
+ 	c.identify.opcode = nvme_admin_identify;
+ 	c.identify.cns = cpu_to_le32(NVME_ID_CNS_CTRL);
+ 
++>>>>>>> fa60682677c5 (nvme: use symbolic constants for CNS values)
  	*id = kmalloc(sizeof(struct nvme_id_ctrl), GFP_KERNEL);
  	if (!*id)
  		return -ENOMEM;
* Unmerged path drivers/nvme/host/core.c
