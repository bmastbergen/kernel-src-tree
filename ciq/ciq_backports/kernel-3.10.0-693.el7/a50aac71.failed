HID: wacom: leds: dynamically allocate LED groups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: leds: dynamically allocate LED groups (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.62%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit a50aac7193f18a5a997588556f1212b0d1ba029b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a50aac71.failed

We need to add an action to ensure wacom->led.groups is null when
wacom_led_control() gets called after the resources has been freed.

This also prevents to send a LED command when there is no support
from the device.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit a50aac7193f18a5a997588556f1212b0d1ba029b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom.h
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom.h
index 87d2c48e3adc,8ac1eb8a4382..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -109,18 -105,25 +109,37 @@@ MODULE_LICENSE(DRIVER_LICENSE)
  #define USB_VENDOR_ID_WACOM	0x056a
  #define USB_VENDOR_ID_LENOVO	0x17ef
  
++<<<<<<< HEAD
++=======
+ enum wacom_worker {
+ 	WACOM_WORKER_WIRELESS,
+ 	WACOM_WORKER_BATTERY,
+ };
+ 
+ struct wacom_group_leds {
+ 	u8 select; /* status led selector (0..3) */
+ };
+ 
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  struct wacom {
 +	dma_addr_t data_dma;
  	struct usb_device *usbdev;
  	struct usb_interface *intf;
 +	struct urb *irq;
  	struct wacom_wac wacom_wac;
 -	struct hid_device *hdev;
  	struct mutex lock;
++<<<<<<< HEAD
 +	struct work_struct work;
 +	bool open;
 +	char phys[32];
 +	struct wacom_led {
 +		u8 select[2]; /* status led selector (0..3) */
++=======
+ 	struct work_struct wireless_work;
+ 	struct work_struct battery_work;
+ 	struct wacom_leds {
+ 		struct wacom_group_leds *groups;
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  		u8 llv;       /* status led brightness no button (1..127) */
  		u8 hlv;       /* status led brightness button pressed (1..127) */
  		u8 img_lum;   /* OLED matrix display brightness */
diff --cc drivers/hid/wacom_sys.c
index e75b5002a526,4d4c737593df..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -738,8 -644,17 +738,19 @@@ static int wacom_led_control(struct wac
  {
  	unsigned char *buf;
  	int retval;
 -	unsigned char report_id = WAC_CMD_LED_CONTROL;
 -	int buf_size = 9;
  
++<<<<<<< HEAD
 +	buf = kzalloc(9, GFP_KERNEL);
++=======
+ 	if (!wacom->led.groups)
+ 		return -ENOTSUPP;
+ 
+ 	if (wacom->wacom_wac.pid) { /* wireless connected */
+ 		report_id = WAC_CMD_WL_LED_CONTROL;
+ 		buf_size = 13;
+ 	}
+ 	buf = kzalloc(buf_size, GFP_KERNEL);
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  	if (!buf)
  		return -ENOMEM;
  
@@@ -750,21 -665,28 +761,21 @@@
  		 * one of four values:
  		 *    0 = Low; 1 = Medium; 2 = High; 3 = Off
  		 */
- 		int ring_led = wacom->led.select[0] & 0x03;
+ 		int ring_led = wacom->led.groups[0].select & 0x03;
  		int ring_lum = (((wacom->led.llv & 0x60) >> 5) - 1) & 0x03;
  		int crop_lum = 0;
 -		unsigned char led_bits = (crop_lum << 4) | (ring_lum << 2) | (ring_led);
 -
 -		buf[0] = report_id;
 -		if (wacom->wacom_wac.pid) {
 -			wacom_get_report(wacom->hdev, HID_FEATURE_REPORT,
 -					 buf, buf_size, WAC_CMD_RETRIES);
 -			buf[0] = report_id;
 -			buf[4] = led_bits;
 -		} else
 -			buf[1] = led_bits;
 +
 +		buf[0] = WAC_CMD_LED_CONTROL;
 +		buf[1] = (crop_lum << 4) | (ring_lum << 2) | (ring_led);
  	}
  	else {
- 		int led = wacom->led.select[0] | 0x4;
+ 		int led = wacom->led.groups[0].select | 0x4;
  
  		if (wacom->wacom_wac.features.type == WACOM_21UX2 ||
  		    wacom->wacom_wac.features.type == WACOM_24HD)
- 			led |= (wacom->led.select[1] << 4) | 0x40;
+ 			led |= (wacom->led.groups[1].select << 4) | 0x40;
  
 -		buf[0] = report_id;
 +		buf[0] = WAC_CMD_LED_CONTROL;
  		buf[1] = led;
  		buf[2] = wacom->led.llv;
  		buf[3] = wacom->led.hlv;
@@@ -848,10 -773,12 +859,17 @@@ static ssize_t wacom_led##SET_ID##_sele
  static ssize_t wacom_led##SET_ID##_select_show(struct device *dev,	\
  	struct device_attribute *attr, char *buf)			\
  {									\
++<<<<<<< HEAD
 +	struct wacom *wacom = dev_get_drvdata(dev);			\
 +	return snprintf(buf, 2, "%d\n", wacom->led.select[SET_ID]);	\
++=======
+ 	struct hid_device *hdev = to_hid_device(dev);\
+ 	struct wacom *wacom = hid_get_drvdata(hdev);			\
+ 	return scnprintf(buf, PAGE_SIZE, "%d\n",			\
+ 			 wacom->led.groups[SET_ID].select);		\
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  }									\
 -static DEVICE_ATTR(status_led##SET_ID##_select, DEV_ATTR_RW_PERM,	\
 +static DEVICE_ATTR(status_led##SET_ID##_select, S_IWUSR | S_IRUSR,	\
  		    wacom_led##SET_ID##_select_show,			\
  		    wacom_led##SET_ID##_select_store)
  
@@@ -973,6 -919,74 +991,77 @@@ static struct attribute_group intuos5_l
  	.attrs = intuos5_led_attrs,
  };
  
++<<<<<<< HEAD
++=======
+ struct wacom_sysfs_group_devres {
+ 	struct attribute_group *group;
+ 	struct kobject *root;
+ };
+ 
+ static void wacom_devm_sysfs_group_release(struct device *dev, void *res)
+ {
+ 	struct wacom_sysfs_group_devres *devres = res;
+ 	struct kobject *kobj = devres->root;
+ 
+ 	dev_dbg(dev, "%s: dropping reference to %s\n",
+ 		__func__, devres->group->name);
+ 	sysfs_remove_group(kobj, devres->group);
+ }
+ 
+ static int wacom_devm_sysfs_create_group(struct wacom *wacom,
+ 					 struct attribute_group *group)
+ {
+ 	struct wacom_sysfs_group_devres *devres;
+ 	int error;
+ 
+ 	devres = devres_alloc(wacom_devm_sysfs_group_release,
+ 			      sizeof(struct wacom_sysfs_group_devres),
+ 			      GFP_KERNEL);
+ 	if (!devres)
+ 		return -ENOMEM;
+ 
+ 	devres->group = group;
+ 	devres->root = &wacom->hdev->dev.kobj;
+ 
+ 	error = sysfs_create_group(devres->root, group);
+ 	if (error)
+ 		return error;
+ 
+ 	devres_add(&wacom->hdev->dev, devres);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_led_groups_release(void *data)
+ {
+ 	struct wacom *wacom = data;
+ 
+ 	wacom->led.groups = NULL;
+ }
+ 
+ static int wacom_led_groups_allocate(struct wacom *wacom, int count)
+ {
+ 	struct wacom_group_leds *groups;
+ 	int error;
+ 
+ 	groups = devm_kzalloc(&wacom->hdev->dev,
+ 			      sizeof(struct wacom_group_leds) * count,
+ 			      GFP_KERNEL);
+ 	if (!groups)
+ 		return -ENOMEM;
+ 
+ 	error = devm_add_action_or_reset(&wacom->hdev->dev,
+ 					 wacom_led_groups_release,
+ 					 wacom);
+ 	if (error)
+ 		return error;
+ 
+ 	wacom->led.groups = groups;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  static int wacom_initialize_leds(struct wacom *wacom)
  {
  	int error;
@@@ -981,14 -998,21 +1070,25 @@@
  	switch (wacom->wacom_wac.features.type) {
  	case INTUOS4S:
  	case INTUOS4:
 -	case INTUOS4WL:
  	case INTUOS4L:
- 		wacom->led.select[0] = 0;
- 		wacom->led.select[1] = 0;
  		wacom->led.llv = 10;
  		wacom->led.hlv = 20;
  		wacom->led.img_lum = 10;
++<<<<<<< HEAD
 +		error = sysfs_create_group(&wacom->intf->dev.kobj,
 +					   &intuos4_led_attr_group);
++=======
+ 
+ 		error = wacom_led_groups_allocate(wacom, 1);
+ 		if (error) {
+ 			hid_err(wacom->hdev,
+ 				"cannot create leds err: %d\n", error);
+ 			return error;
+ 		}
+ 
+ 		error = wacom_devm_sysfs_create_group(wacom,
+ 						      &intuos4_led_attr_group);
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  		break;
  
  	case WACOM_24HD:
@@@ -999,8 -1021,15 +1097,20 @@@
  		wacom->led.hlv = 0;
  		wacom->led.img_lum = 0;
  
++<<<<<<< HEAD
 +		error = sysfs_create_group(&wacom->intf->dev.kobj,
 +					   &cintiq_led_attr_group);
++=======
+ 		error = wacom_led_groups_allocate(wacom, 2);
+ 		if (error) {
+ 			hid_err(wacom->hdev,
+ 				"cannot create leds err: %d\n", error);
+ 			return error;
+ 		}
+ 
+ 		error = wacom_devm_sysfs_create_group(wacom,
+ 						      &cintiq_led_attr_group);
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  		break;
  
  	case INTUOS5S:
@@@ -1009,19 -1038,30 +1119,44 @@@
  	case INTUOSPS:
  	case INTUOSPM:
  	case INTUOSPL:
++<<<<<<< HEAD
 +		if (wacom->wacom_wac.features.device_type == BTN_TOOL_PEN) {
 +			wacom->led.select[0] = 0;
 +			wacom->led.select[1] = 0;
 +			wacom->led.llv = 32;
 +			wacom->led.hlv = 0;
 +			wacom->led.img_lum = 0;
 +
 +			error = sysfs_create_group(&wacom->intf->dev.kobj,
 +						  &intuos5_led_attr_group);
 +		} else
 +			return 0;
++=======
+ 		wacom->led.llv = 32;
+ 		wacom->led.hlv = 0;
+ 		wacom->led.img_lum = 0;
+ 
+ 		error = wacom_led_groups_allocate(wacom, 1);
+ 		if (error) {
+ 			hid_err(wacom->hdev,
+ 				"cannot create leds err: %d\n", error);
+ 			return error;
+ 		}
+ 
+ 		error = wacom_devm_sysfs_create_group(wacom,
+ 						      &intuos5_led_attr_group);
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  		break;
  
+ 	case REMOTE:
+ 		error = wacom_led_groups_allocate(wacom, 5);
+ 		if (error) {
+ 			hid_err(wacom->hdev,
+ 				"cannot create leds err: %d\n", error);
+ 			return error;
+ 		}
+ 		return 0;
+ 
  	default:
  		return 0;
  	}
@@@ -1127,35 -1219,572 +1262,253 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
++<<<<<<< HEAD
 +static int wacom_register_input(struct wacom *wacom)
++=======
+ static ssize_t wacom_show_speed(struct device *dev,
+ 				struct device_attribute
+ 				*attr, char *buf)
+ {
+ 	struct hid_device *hdev = to_hid_device(dev);
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
+ }
+ 
+ static ssize_t wacom_store_speed(struct device *dev,
+ 				struct device_attribute *attr,
+ 				const char *buf, size_t count)
+ {
+ 	struct hid_device *hdev = to_hid_device(dev);
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	u8 new_speed;
+ 
+ 	if (kstrtou8(buf, 0, &new_speed))
+ 		return -EINVAL;
+ 
+ 	if (new_speed != 0 && new_speed != 1)
+ 		return -EINVAL;
+ 
+ 	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
+ 		wacom_show_speed, wacom_store_speed);
+ 
+ 
+ static ssize_t wacom_show_remote_mode(struct kobject *kobj,
+ 				      struct kobj_attribute *kattr,
+ 				      char *buf, int index)
+ {
+ 	struct device *dev = kobj_to_dev(kobj->parent);
+ 	struct hid_device *hdev = to_hid_device(dev);
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	u8 mode;
+ 
+ 	mode = wacom->led.groups[index].select;
+ 	if (mode >= 0 && mode < 3)
+ 		return snprintf(buf, PAGE_SIZE, "%d\n", mode);
+ 	else
+ 		return snprintf(buf, PAGE_SIZE, "%d\n", -1);
+ }
+ 
+ #define DEVICE_EKR_ATTR_GROUP(SET_ID)					\
+ static ssize_t wacom_show_remote##SET_ID##_mode(struct kobject *kobj,	\
+ 			       struct kobj_attribute *kattr, char *buf)	\
+ {									\
+ 	return wacom_show_remote_mode(kobj, kattr, buf, SET_ID);	\
+ }									\
+ static struct kobj_attribute remote##SET_ID##_mode_attr = {		\
+ 	.attr = {.name = "remote_mode",					\
+ 		.mode = DEV_ATTR_RO_PERM},				\
+ 	.show = wacom_show_remote##SET_ID##_mode,			\
+ };									\
+ static struct attribute *remote##SET_ID##_serial_attrs[] = {		\
+ 	&remote##SET_ID##_mode_attr.attr,				\
+ 	NULL								\
+ };									\
+ static struct attribute_group remote##SET_ID##_serial_group = {		\
+ 	.name = NULL,							\
+ 	.attrs = remote##SET_ID##_serial_attrs,				\
+ }
+ 
+ DEVICE_EKR_ATTR_GROUP(0);
+ DEVICE_EKR_ATTR_GROUP(1);
+ DEVICE_EKR_ATTR_GROUP(2);
+ DEVICE_EKR_ATTR_GROUP(3);
+ DEVICE_EKR_ATTR_GROUP(4);
+ 
+ int wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial, int index)
+ {
+ 	int error = 0;
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	wacom_wac->serial[index] = serial;
+ 
+ 	wacom->remote_group[index].name = devm_kasprintf(&wacom->hdev->dev,
+ 							 GFP_KERNEL,
+ 							 "%d", serial);
+ 	if (!wacom->remote_group[index].name)
+ 		return -ENOMEM;
+ 
+ 	error = sysfs_create_group(wacom->remote_dir,
+ 				   &wacom->remote_group[index]);
+ 	if (error) {
+ 		hid_err(wacom->hdev,
+ 			"cannot create sysfs group err: %d\n", error);
+ 		return error;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void wacom_remote_destroy_attr_group(struct wacom *wacom, __u32 serial)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	int i;
+ 
+ 	if (!serial)
+ 		return;
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (wacom_wac->serial[i] == serial) {
+ 			wacom_wac->serial[i] = 0;
+ 			wacom->led.groups[i].select = WACOM_STATUS_UNKNOWN;
+ 			if (wacom->remote_group[i].name) {
+ 				sysfs_remove_group(wacom->remote_dir,
+ 						   &wacom->remote_group[i]);
+ 				devm_kfree(&wacom->hdev->dev,
+ 					   (char *)wacom->remote_group[i].name);
+ 				wacom->remote_group[i].name = NULL;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static int wacom_cmd_unpair_remote(struct wacom *wacom, unsigned char selector)
+ {
+ 	const size_t buf_size = 2;
+ 	unsigned char *buf;
+ 	int retval;
+ 
+ 	buf = kzalloc(buf_size, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	buf[0] = WAC_CMD_DELETE_PAIRING;
+ 	buf[1] = selector;
+ 
+ 	retval = wacom_set_report(wacom->hdev, HID_OUTPUT_REPORT, buf,
+ 				  buf_size, WAC_CMD_RETRIES);
+ 	kfree(buf);
+ 
+ 	return retval;
+ }
+ 
+ static ssize_t wacom_store_unpair_remote(struct kobject *kobj,
+ 					 struct kobj_attribute *attr,
+ 					 const char *buf, size_t count)
+ {
+ 	unsigned char selector = 0;
+ 	struct device *dev = kobj_to_dev(kobj->parent);
+ 	struct hid_device *hdev = to_hid_device(dev);
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	int err;
+ 
+ 	if (!strncmp(buf, "*\n", 2)) {
+ 		selector = WAC_CMD_UNPAIR_ALL;
+ 	} else {
+ 		hid_info(wacom->hdev, "remote: unrecognized unpair code: %s\n",
+ 			 buf);
+ 		return -1;
+ 	}
+ 
+ 	mutex_lock(&wacom->lock);
+ 
+ 	err = wacom_cmd_unpair_remote(wacom, selector);
+ 	mutex_unlock(&wacom->lock);
+ 
+ 	return err < 0 ? err : count;
+ }
+ 
+ static struct kobj_attribute unpair_remote_attr = {
+ 	.attr = {.name = "unpair_remote", .mode = 0200},
+ 	.store = wacom_store_unpair_remote,
+ };
+ 
+ static const struct attribute *remote_unpair_attrs[] = {
+ 	&unpair_remote_attr.attr,
+ 	NULL
+ };
+ 
+ static int wacom_initialize_remote(struct wacom *wacom)
+ {
+ 	int error = 0;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 	int i;
+ 
+ 	if (wacom->wacom_wac.features.type != REMOTE)
+ 		return 0;
+ 
+ 	wacom->remote_group[0] = remote0_serial_group;
+ 	wacom->remote_group[1] = remote1_serial_group;
+ 	wacom->remote_group[2] = remote2_serial_group;
+ 	wacom->remote_group[3] = remote3_serial_group;
+ 	wacom->remote_group[4] = remote4_serial_group;
+ 
+ 	wacom->remote_dir = kobject_create_and_add("wacom_remote",
+ 						   &wacom->hdev->dev.kobj);
+ 	if (!wacom->remote_dir)
+ 		return -ENOMEM;
+ 
+ 	error = sysfs_create_files(wacom->remote_dir, remote_unpair_attrs);
+ 
+ 	if (error) {
+ 		hid_err(wacom->hdev,
+ 			"cannot create sysfs group err: %d\n", error);
+ 		return error;
+ 	}
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		wacom->led.groups[i].select = WACOM_STATUS_UNKNOWN;
+ 		wacom_wac->serial[i] = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct input_dev *wacom_allocate_input(struct wacom *wacom)
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  {
  	struct input_dev *input_dev;
 -	struct hid_device *hdev = wacom->hdev;
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 +	int error;
  
 -	input_dev = devm_input_allocate_device(&hdev->dev);
 -	if (!input_dev)
 -		return NULL;
 +	input_dev = input_allocate_device();
 +	if (!input_dev) {
 +		error = -ENOMEM;
 +		goto fail1;
 +	}
  
 -	input_dev->name = wacom_wac->features.name;
 -	input_dev->phys = hdev->phys;
 -	input_dev->dev.parent = &hdev->dev;
 +	input_dev->name = wacom_wac->name;
 +	input_dev->dev.parent = &intf->dev;
  	input_dev->open = wacom_open;
  	input_dev->close = wacom_close;
 -	input_dev->uniq = hdev->uniq;
 -	input_dev->id.bustype = hdev->bus;
 -	input_dev->id.vendor  = hdev->vendor;
 -	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
 -	input_dev->id.version = hdev->version;
 +	usb_to_input_id(dev, &input_dev->id);
  	input_set_drvdata(input_dev, wacom);
  
 -	return input_dev;
 -}
 -
 -static int wacom_allocate_inputs(struct wacom *wacom)
 -{
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -
 -	wacom_wac->pen_input = wacom_allocate_input(wacom);
 -	wacom_wac->touch_input = wacom_allocate_input(wacom);
 -	wacom_wac->pad_input = wacom_allocate_input(wacom);
 -	if (!wacom_wac->pen_input ||
 -	    !wacom_wac->touch_input ||
 -	    !wacom_wac->pad_input)
 -		return -ENOMEM;
 -
 -	wacom_wac->pen_input->name = wacom_wac->pen_name;
 -	wacom_wac->touch_input->name = wacom_wac->touch_name;
 -	wacom_wac->pad_input->name = wacom_wac->pad_name;
 -
 -	return 0;
 -}
 -
 -static int wacom_register_inputs(struct wacom *wacom)
 -{
 -	struct input_dev *pen_input_dev, *touch_input_dev, *pad_input_dev;
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -	int error = 0;
 -
 -	pen_input_dev = wacom_wac->pen_input;
 -	touch_input_dev = wacom_wac->touch_input;
 -	pad_input_dev = wacom_wac->pad_input;
 -
 -	if (!pen_input_dev || !touch_input_dev || !pad_input_dev)
 -		return -EINVAL;
 -
 -	error = wacom_setup_pen_input_capabilities(pen_input_dev, wacom_wac);
 -	if (error) {
 -		/* no pen in use on this interface */
 -		input_free_device(pen_input_dev);
 -		wacom_wac->pen_input = NULL;
 -		pen_input_dev = NULL;
 -	} else {
 -		error = input_register_device(pen_input_dev);
 -		if (error)
 -			goto fail;
 -	}
 -
 -	error = wacom_setup_touch_input_capabilities(touch_input_dev, wacom_wac);
 -	if (error) {
 -		/* no touch in use on this interface */
 -		input_free_device(touch_input_dev);
 -		wacom_wac->touch_input = NULL;
 -		touch_input_dev = NULL;
 -	} else {
 -		error = input_register_device(touch_input_dev);
 -		if (error)
 -			goto fail;
 -	}
 -
 -	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
 -	if (error) {
 -		/* no pad in use on this interface */
 -		input_free_device(pad_input_dev);
 -		wacom_wac->pad_input = NULL;
 -		pad_input_dev = NULL;
 -	} else {
 -		error = input_register_device(pad_input_dev);
 -		if (error)
 -			goto fail;
 -	}
 -
 -	return 0;
 -
 -fail:
 -	wacom_wac->pad_input = NULL;
 -	wacom_wac->touch_input = NULL;
 -	wacom_wac->pen_input = NULL;
 -	return error;
 -}
 -
 -/*
 - * Not all devices report physical dimensions from HID.
 - * Compute the default from hardcoded logical dimension
 - * and resolution before driver overwrites them.
 - */
 -static void wacom_set_default_phy(struct wacom_features *features)
 -{
 -	if (features->x_resolution) {
 -		features->x_phy = (features->x_max * 100) /
 -					features->x_resolution;
 -		features->y_phy = (features->y_max * 100) /
 -					features->y_resolution;
 -	}
 -}
 -
 -static void wacom_calculate_res(struct wacom_features *features)
 -{
 -	/* set unit to "100th of a mm" for devices not reported by HID */
 -	if (!features->unit) {
 -		features->unit = 0x11;
 -		features->unitExpo = -3;
 -	}
 -
 -	features->x_resolution = wacom_calc_hid_res(features->x_max,
 -						    features->x_phy,
 -						    features->unit,
 -						    features->unitExpo);
 -	features->y_resolution = wacom_calc_hid_res(features->y_max,
 -						    features->y_phy,
 -						    features->unit,
 -						    features->unitExpo);
 -}
 -
 -void wacom_battery_work(struct work_struct *work)
 -{
 -	struct wacom *wacom = container_of(work, struct wacom, battery_work);
 -
 -	if ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
 -	     !wacom->battery) {
 -		wacom_initialize_battery(wacom);
 -	}
 -	else if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
 -		 wacom->battery) {
 -		wacom_destroy_battery(wacom);
 -	}
 -}
 -
 -static size_t wacom_compute_pktlen(struct hid_device *hdev)
 -{
 -	struct hid_report_enum *report_enum;
 -	struct hid_report *report;
 -	size_t size = 0;
 -
 -	report_enum = hdev->report_enum + HID_INPUT_REPORT;
 -
 -	list_for_each_entry(report, &report_enum->report_list, list) {
 -		size_t report_size = hid_report_len(report);
 -		if (report_size > size)
 -			size = report_size;
 -	}
 -
 -	return size;
 -}
 -
 -static void wacom_update_name(struct wacom *wacom, const char *suffix)
 -{
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct wacom_features *features = &wacom_wac->features;
 -	char name[WACOM_NAME_MAX];
 -
 -	/* Generic devices name unspecified */
 -	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
 -		if (strstr(wacom->hdev->name, "Wacom") ||
 -		    strstr(wacom->hdev->name, "wacom") ||
 -		    strstr(wacom->hdev->name, "WACOM")) {
 -			/* name is in HID descriptor, use it */
 -			strlcpy(name, wacom->hdev->name, sizeof(name));
 -
 -			/* strip out excess whitespaces */
 -			while (1) {
 -				char *gap = strstr(name, "  ");
 -				if (gap == NULL)
 -					break;
 -				/* shift everything including the terminator */
 -				memmove(gap, gap+1, strlen(gap));
 -			}
 -			/* get rid of trailing whitespace */
 -			if (name[strlen(name)-1] == ' ')
 -				name[strlen(name)-1] = '\0';
 -		} else {
 -			/* no meaningful name retrieved. use product ID */
 -			snprintf(name, sizeof(name),
 -				 "%s %X", features->name, wacom->hdev->product);
 -		}
 -	} else {
 -		strlcpy(name, features->name, sizeof(name));
 -	}
 -
 -	/* Append the device type to the name */
 -	snprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),
 -		"%s%s Pen", name, suffix);
 -	snprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),
 -		"%s%s Finger", name, suffix);
 -	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
 -		"%s%s Pad", name, suffix);
 -}
 -
 -static void wacom_release_resources(struct wacom *wacom)
 -{
 -	struct hid_device *hdev = wacom->hdev;
 -
 -	if (!wacom->resources)
 -		return;
 -
 -	devres_release_group(&hdev->dev, wacom);
 -
 -	wacom->resources = false;
 -
 -	wacom->wacom_wac.pen_input = NULL;
 -	wacom->wacom_wac.touch_input = NULL;
 -	wacom->wacom_wac.pad_input = NULL;
 -}
 -
 -static int wacom_parse_and_register(struct wacom *wacom, bool wireless)
 -{
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct wacom_features *features = &wacom_wac->features;
 -	struct hid_device *hdev = wacom->hdev;
 -	int error;
 -	unsigned int connect_mask = HID_CONNECT_HIDRAW;
 -
 -	features->pktlen = wacom_compute_pktlen(hdev);
 -	if (features->pktlen > WACOM_PKGLEN_MAX)
 -		return -EINVAL;
 -
 -	if (!devres_open_group(&hdev->dev, wacom, GFP_KERNEL))
 -		return -ENOMEM;
 -
 -	wacom->resources = true;
 -
 -	error = wacom_allocate_inputs(wacom);
 +	wacom_wac->input = input_dev;
 +	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
  	if (error)
 -		goto fail_open_group;
 -
 -	/*
 -	 * Bamboo Pad has a generic hid handling for the Pen, and we switch it
 -	 * into debug mode for the touch part.
 -	 * We ignore the other interfaces.
 -	 */
 -	if (features->type == BAMBOO_PAD) {
 -		if (features->pktlen == WACOM_PKGLEN_PENABLED) {
 -			features->type = HID_GENERIC;
 -		} else if ((features->pktlen != WACOM_PKGLEN_BPAD_TOUCH) &&
 -			   (features->pktlen != WACOM_PKGLEN_BPAD_TOUCH_USB)) {
 -			error = -ENODEV;
 -			goto fail_allocate_inputs;
 -		}
 -	}
 -
 -	/* set the default size in case we do not get them from hid */
 -	wacom_set_default_phy(features);
 -
 -	/* Retrieve the physical and logical size for touch devices */
 -	wacom_retrieve_hid_descriptor(hdev, features);
 -	wacom_setup_device_quirks(wacom);
 -
 -	if (features->device_type == WACOM_DEVICETYPE_NONE &&
 -	    features->type != WIRELESS) {
 -		error = features->type == HID_GENERIC ? -ENODEV : 0;
 -
 -		dev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",
 -			 hdev->name,
 -			 error ? "Ignoring" : "Assuming pen");
 -
 -		if (error)
 -			goto fail_parsed;
 -
 -		features->device_type |= WACOM_DEVICETYPE_PEN;
 -	}
 +		goto fail1;
  
 -	wacom_calculate_res(features);
 -
 -	wacom_update_name(wacom, wireless ? " (WL)" : "");
 -
 -	error = wacom_add_shared_data(hdev);
 -	if (error)
 -		goto fail_shared_data;
 -
 -	if (!(features->device_type & WACOM_DEVICETYPE_WL_MONITOR) &&
 -	     (features->quirks & WACOM_QUIRK_BATTERY)) {
 -		error = wacom_initialize_battery(wacom);
 -		if (error)
 -			goto fail_battery;
 -	}
 -
 -	error = wacom_register_inputs(wacom);
 +	error = input_register_device(input_dev);
  	if (error)
 -		goto fail_register_inputs;
 -
 -	if (wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD) {
 -		error = wacom_initialize_leds(wacom);
 -		if (error)
 -			goto fail_leds;
 -
 -		error = wacom_initialize_remote(wacom);
 -		if (error)
 -			goto fail_remote;
 -	}
 -
 -	if (features->type == HID_GENERIC)
 -		connect_mask |= HID_CONNECT_DRIVER;
 -
 -	/* Regular HID work starts now */
 -	error = hid_hw_start(hdev, connect_mask);
 -	if (error) {
 -		hid_err(hdev, "hw start failed\n");
 -		goto fail_hw_start;
 -	}
 -
 -	if (!wireless) {
 -		/* Note that if query fails it is not a hard failure */
 -		wacom_query_tablet_data(hdev, features);
 -	}
 -
 -	/* touch only Bamboo doesn't support pen */
 -	if ((features->type == BAMBOO_TOUCH) &&
 -	    (features->device_type & WACOM_DEVICETYPE_PEN)) {
 -		error = -ENODEV;
 -		goto fail_quirks;
 -	}
 -
 -	/* pen only Bamboo neither support touch nor pad */
 -	if ((features->type == BAMBOO_PEN) &&
 -	    ((features->device_type & WACOM_DEVICETYPE_TOUCH) ||
 -	    (features->device_type & WACOM_DEVICETYPE_PAD))) {
 -		error = -ENODEV;
 -		goto fail_quirks;
 -	}
 -
 -	if (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)
 -		error = hid_hw_open(hdev);
 -
 -	if ((wacom_wac->features.type == INTUOSHT ||
 -	     wacom_wac->features.type == INTUOSHT2) &&
 -	    (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)) {
 -		wacom_wac->shared->type = wacom_wac->features.type;
 -		wacom_wac->shared->touch_input = wacom_wac->touch_input;
 -	}
 -
 -	devres_close_group(&hdev->dev, wacom);
 +		goto fail2;
  
  	return 0;
  
diff --cc drivers/hid/wacom_wac.c
index 98c7d65145c2,932d3eec933b..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -481,9 -745,128 +481,134 @@@ static int wacom_intuos_inout(struct wa
  		return 2;
  	}
  
++<<<<<<< HEAD
 +	/* don't report other events if we don't know the ID */
 +	if (!wacom->id[idx])
 +		return 1;
++=======
+ 	return 0;
+ }
+ 
+ static int wacom_remote_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	unsigned char *data = wacom_wac->data;
+ 	struct input_dev *input = wacom_wac->pad_input;
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	int bat_charging, bat_percent, touch_ring_mode;
+ 	__u32 serial;
+ 	int i;
+ 
+ 	if (data[0] != WACOM_REPORT_REMOTE) {
+ 		dev_dbg(input->dev.parent,
+ 			"%s: received unknown report #%d", __func__, data[0]);
+ 		return 0;
+ 	}
+ 
+ 	serial = data[3] + (data[4] << 8) + (data[5] << 16);
+ 	wacom_wac->id[0] = PAD_DEVICE_ID;
+ 
+ 	input_report_key(input, BTN_0, (data[9] & 0x01));
+ 	input_report_key(input, BTN_1, (data[9] & 0x02));
+ 	input_report_key(input, BTN_2, (data[9] & 0x04));
+ 	input_report_key(input, BTN_3, (data[9] & 0x08));
+ 	input_report_key(input, BTN_4, (data[9] & 0x10));
+ 	input_report_key(input, BTN_5, (data[9] & 0x20));
+ 	input_report_key(input, BTN_6, (data[9] & 0x40));
+ 	input_report_key(input, BTN_7, (data[9] & 0x80));
+ 
+ 	input_report_key(input, BTN_8, (data[10] & 0x01));
+ 	input_report_key(input, BTN_9, (data[10] & 0x02));
+ 	input_report_key(input, BTN_A, (data[10] & 0x04));
+ 	input_report_key(input, BTN_B, (data[10] & 0x08));
+ 	input_report_key(input, BTN_C, (data[10] & 0x10));
+ 	input_report_key(input, BTN_X, (data[10] & 0x20));
+ 	input_report_key(input, BTN_Y, (data[10] & 0x40));
+ 	input_report_key(input, BTN_Z, (data[10] & 0x80));
+ 
+ 	input_report_key(input, BTN_BASE, (data[11] & 0x01));
+ 	input_report_key(input, BTN_BASE2, (data[11] & 0x02));
+ 
+ 	if (data[12] & 0x80)
+ 		input_report_abs(input, ABS_WHEEL, (data[12] & 0x7f));
+ 	else
+ 		input_report_abs(input, ABS_WHEEL, 0);
+ 
+ 	bat_percent = data[7] & 0x7f;
+ 	bat_charging = !!(data[7] & 0x80);
+ 
+ 	if (data[9] | data[10] | (data[11] & 0x03) | data[12])
+ 		input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 	else
+ 		input_report_abs(input, ABS_MISC, 0);
+ 
+ 	input_event(input, EV_MSC, MSC_SERIAL, serial);
+ 
+ 	/*Which mode select (LED light) is currently on?*/
+ 	touch_ring_mode = (data[11] & 0xC0) >> 6;
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (wacom_wac->serial[i] == serial)
+ 			wacom->led.groups[i].select = touch_ring_mode;
+ 	}
+ 
+ 	if (!wacom->battery &&
+ 	    !(features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		features->quirks |= WACOM_QUIRK_BATTERY;
+ 		wacom_schedule_work(wacom_wac, WACOM_WORKER_BATTERY);
+ 	}
+ 
+ 	wacom_notify_battery(wacom_wac, bat_percent, bat_charging, 1,
+ 			     bat_charging);
+ 
+ 	return 1;
+ }
+ 
+ static int wacom_remote_status_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	unsigned char *data = wacom_wac->data;
+ 	int i;
+ 
+ 	if (data[0] != WACOM_REPORT_DEVICE_LIST)
+ 		return 0;
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		int j = i * 6;
+ 		int serial = (data[j+6] << 16) + (data[j+5] << 8) + data[j+4];
+ 		bool connected = data[j+2];
+ 
+ 		if (connected) {
+ 			int k;
+ 
+ 			if (wacom_wac->serial[i] == serial)
+ 				continue;
+ 
+ 			if (wacom_wac->serial[i]) {
+ 				wacom_remote_destroy_attr_group(wacom,
+ 							wacom_wac->serial[i]);
+ 			}
+ 
+ 			/* A remote can pair more than once with an EKR,
+ 			 * check to make sure this serial isn't already paired.
+ 			 */
+ 			for (k = 0; k < WACOM_MAX_REMOTES; k++) {
+ 				if (wacom_wac->serial[k] == serial)
+ 					break;
+ 			}
+ 
+ 			if (k < WACOM_MAX_REMOTES) {
+ 				wacom_wac->serial[i] = serial;
+ 				continue;
+ 			}
+ 			wacom_remote_create_attr_group(wacom, serial, i);
+ 
+ 		} else if (wacom_wac->serial[i]) {
+ 			wacom_remote_destroy_attr_group(wacom,
+ 							wacom_wac->serial[i]);
+ 		}
+ 	}
++>>>>>>> a50aac7193f1 (HID: wacom: leds: dynamically allocate LED groups)
  
  	return 0;
  }
* Unmerged path drivers/hid/wacom.h
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
