KVM: PPC: Book3S HV: Move struct kvmppc_vcore from kvm_host.h to kvm_book3s.h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suraj Jitindar Singh <sjitindarsingh@gmail.com>
commit e64fb7e272885c1ea3cd2f68f267ae12fa04c8b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e64fb7e2.failed

The next commit will introduce a member to the kvmppc_vcore struct which
references MAX_SMT_THREADS which is defined in kvm_book3s_asm.h, however
this file isn't included in kvm_host.h directly. Thus compiling for
certain platforms such as pmac32_defconfig and ppc64e_defconfig with KVM
fails due to MAX_SMT_THREADS not being defined.

Move the struct kvmppc_vcore definition to kvm_book3s.h which explicitly
includes kvm_book3s_asm.h.

	Signed-off-by: Suraj Jitindar Singh <sjitindarsingh@gmail.com>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit e64fb7e272885c1ea3cd2f68f267ae12fa04c8b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/kvm_host.h
diff --cc arch/powerpc/include/asm/kvm_host.h
index 8841a038084f,7ff9919916c3..000000000000
--- a/arch/powerpc/include/asm/kvm_host.h
+++ b/arch/powerpc/include/asm/kvm_host.h
@@@ -270,41 -277,6 +270,44 @@@ struct kvm_arch 
  #endif
  };
  
++<<<<<<< HEAD
 +/*
 + * Struct for a virtual core.
 + * Note: entry_exit_map combines a bitmap of threads that have entered
 + * in the bottom 8 bits and a bitmap of threads that have exited in the
 + * next 8 bits.  This is so that we can atomically set the entry bit
 + * iff the exit map is 0 without taking a lock.
 + */
 +struct kvmppc_vcore {
 +	int n_runnable;
 +	int num_threads;
 +	int entry_exit_map;
 +	int napping_threads;
 +	int first_vcpuid;
 +	u16 pcpu;
 +	u16 last_cpu;
 +	u8 vcore_state;
 +	u8 in_guest;
 +	struct kvmppc_vcore *master_vcore;
 +	struct list_head runnable_threads;
 +	struct list_head preempt_list;
 +	spinlock_t lock;
 +	wait_queue_head_t wq;
 +	spinlock_t stoltb_lock;	/* protects stolen_tb and preempt_tb */
 +	u64 stolen_tb;
 +	u64 preempt_tb;
 +	struct kvm_vcpu *runner;
 +	struct kvm *kvm;
 +	u64 tb_offset;		/* guest timebase - host timebase */
 +	ulong lpcr;
 +	u32 arch_compat;
 +	ulong pcr;
 +	ulong dpdes;		/* doorbell state (POWER8) */
 +	ulong conferring_threads;
 +};
 +
++=======
++>>>>>>> e64fb7e27288 (KVM: PPC: Book3S HV: Move struct kvmppc_vcore from kvm_host.h to kvm_book3s.h)
  #define VCORE_ENTRY_MAP(vc)	((vc)->entry_exit_map & 0xff)
  #define VCORE_EXIT_MAP(vc)	((vc)->entry_exit_map >> 8)
  #define VCORE_IS_EXITING(vc)	(VCORE_EXIT_MAP(vc) != 0)
diff --git a/arch/powerpc/include/asm/kvm_book3s.h b/arch/powerpc/include/asm/kvm_book3s.h
index 8f39796c9da8..a50c5fec9790 100644
--- a/arch/powerpc/include/asm/kvm_book3s.h
+++ b/arch/powerpc/include/asm/kvm_book3s.h
@@ -69,6 +69,41 @@ struct hpte_cache {
 	int pagesize;
 };
 
+/*
+ * Struct for a virtual core.
+ * Note: entry_exit_map combines a bitmap of threads that have entered
+ * in the bottom 8 bits and a bitmap of threads that have exited in the
+ * next 8 bits.  This is so that we can atomically set the entry bit
+ * iff the exit map is 0 without taking a lock.
+ */
+struct kvmppc_vcore {
+	int n_runnable;
+	int num_threads;
+	int entry_exit_map;
+	int napping_threads;
+	int first_vcpuid;
+	u16 pcpu;
+	u16 last_cpu;
+	u8 vcore_state;
+	u8 in_guest;
+	struct kvmppc_vcore *master_vcore;
+	struct list_head runnable_threads;
+	struct list_head preempt_list;
+	spinlock_t lock;
+	struct swait_queue_head wq;
+	spinlock_t stoltb_lock;	/* protects stolen_tb and preempt_tb */
+	u64 stolen_tb;
+	u64 preempt_tb;
+	struct kvm_vcpu *runner;
+	struct kvm *kvm;
+	u64 tb_offset;		/* guest timebase - host timebase */
+	ulong lpcr;
+	u32 arch_compat;
+	ulong pcr;
+	ulong dpdes;		/* doorbell state (POWER8) */
+	ulong conferring_threads;
+};
+
 struct kvmppc_vcpu_book3s {
 	struct kvmppc_sid_map sid_map[SID_MAP_NUM];
 	struct {
* Unmerged path arch/powerpc/include/asm/kvm_host.h
