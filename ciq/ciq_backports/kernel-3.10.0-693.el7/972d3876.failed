flow dissector: ICMP support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Simon Horman <simon.horman@netronome.com>
commit 972d3876faa8a9195122b2d2bcd3155f904fff37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/972d3876.failed

Allow dissection of ICMP(V6) type and code. This should only occur
if a packet is ICMP(V6) and the dissector has FLOW_DISSECTOR_KEY_ICMP set.

There are currently no users of FLOW_DISSECTOR_KEY_ICMP.
A follow-up patch will allow FLOW_DISSECTOR_KEY_ICMP to be used by
the flower classifier.

	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 972d3876faa8a9195122b2d2bcd3155f904fff37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_dissector.h
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,d6447dc10371..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -63,17 -57,28 +63,39 @@@ void skb_flow_dissector_init(struct flo
  }
  EXPORT_SYMBOL(skb_flow_dissector_init);
  
 +/* copy saddr & daddr, possibly using 64bit load/store
 + * Equivalent to :	flow->src = iph->saddr;
 + *			flow->dst = iph->daddr;
 + */
 +static void iph_to_flow_copy_addrs(struct flow_keys *flow, const struct iphdr *iph)
 +{
 +	BUILD_BUG_ON(offsetof(typeof(*flow), dst) !=
 +		     offsetof(typeof(*flow), src) + sizeof(flow->src));
 +	memcpy(&flow->src, &iph->saddr, sizeof(flow->src) + sizeof(flow->dst));
 +}
 +
+ /**
+  * skb_flow_get_be16 - extract be16 entity
+  * @skb: sk_buff to extract from
+  * @poff: offset to extract at
+  * @data: raw buffer pointer to the packet
+  * @hlen: packet header length
+  *
+  * The function will try to retrieve a be32 entity at
+  * offset poff
+  */
+ __be16 skb_flow_get_be16(const struct sk_buff *skb, int poff, void *data,
+ 			 int hlen)
+ {
+ 	__be16 *u, _u;
+ 
+ 	u = __skb_header_pointer(skb, poff, sizeof(_u), data, hlen, &_u);
+ 	if (u)
+ 		return *u;
+ 
+ 	return 0;
+ }
+ 
  /**
   * __skb_flow_get_ports - extract the upper layer ports and return them
   * @skb: sk_buff to extract the ports from
@@@ -116,13 -123,29 +138,27 @@@ EXPORT_SYMBOL(__skb_flow_get_ports)
   * @nhoff: network header offset, if @data is NULL use skb_network_offset(skb)
   * @hlen: packet header length, if @data is NULL use skb_headlen(skb)
   *
 - * The function will try to retrieve individual keys into target specified
 - * by flow_dissector from either the skbuff or a raw buffer specified by the
 - * rest parameters.
 - *
 - * Caller must take care of zeroing target container memory.
 + * The function will try to retrieve the struct flow_keys from either the skbuff
 + * or a raw buffer specified by the rest parameters
   */
 -bool __skb_flow_dissect(const struct sk_buff *skb,
 -			struct flow_dissector *flow_dissector,
 -			void *target_container,
 -			void *data, __be16 proto, int nhoff, int hlen,
 -			unsigned int flags)
 +bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow,
 +			void *data, __be16 proto, int nhoff, int hlen)
  {
++<<<<<<< HEAD
 +	u8 ip_proto;
++=======
+ 	struct flow_dissector_key_control *key_control;
+ 	struct flow_dissector_key_basic *key_basic;
+ 	struct flow_dissector_key_addrs *key_addrs;
+ 	struct flow_dissector_key_ports *key_ports;
+ 	struct flow_dissector_key_icmp *key_icmp;
+ 	struct flow_dissector_key_tags *key_tags;
+ 	struct flow_dissector_key_vlan *key_vlan;
+ 	struct flow_dissector_key_keyid *key_keyid;
+ 	bool skip_vlan = false;
+ 	u8 ip_proto = 0;
+ 	bool ret;
++>>>>>>> 972d3876faa8 (flow dissector: ICMP support)
  
  	if (!data) {
  		data = skb->data;
@@@ -319,12 -560,37 +355,37 @@@ ip_proto_again
  		break;
  	}
  
 -	if (dissector_uses_key(flow_dissector,
 -			       FLOW_DISSECTOR_KEY_PORTS)) {
 -		key_ports = skb_flow_dissector_target(flow_dissector,
 -						      FLOW_DISSECTOR_KEY_PORTS,
 -						      target_container);
 -		key_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,
 -							data, hlen);
 -	}
 +	flow->n_proto = proto;
 +	flow->ip_proto = ip_proto;
 +	flow->ports = __skb_flow_get_ports(skb, nhoff, ip_proto, data, hlen);
 +	flow->thoff = (u16) nhoff;
  
++<<<<<<< HEAD
 +	return true;
++=======
+ 	if (dissector_uses_key(flow_dissector,
+ 			       FLOW_DISSECTOR_KEY_ICMP)) {
+ 		key_icmp = skb_flow_dissector_target(flow_dissector,
+ 						     FLOW_DISSECTOR_KEY_ICMP,
+ 						     target_container);
+ 		key_icmp->icmp = skb_flow_get_be16(skb, nhoff, data, hlen);
+ 	}
+ 
+ out_good:
+ 	ret = true;
+ 
+ 	key_control->thoff = (u16)nhoff;
+ out:
+ 	key_basic->n_proto = proto;
+ 	key_basic->ip_proto = ip_proto;
+ 
+ 	return ret;
+ 
+ out_bad:
+ 	ret = false;
+ 	key_control->thoff = min_t(u16, nhoff, skb ? skb->len : hlen);
+ 	goto out;
++>>>>>>> 972d3876faa8 (flow dissector: ICMP support)
  }
  EXPORT_SYMBOL(__skb_flow_dissect);
  
* Unmerged path include/net/flow_dissector.h
* Unmerged path include/net/flow_dissector.h
* Unmerged path net/core/flow_dissector.c
