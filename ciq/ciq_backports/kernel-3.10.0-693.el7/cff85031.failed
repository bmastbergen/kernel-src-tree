random: only update the last_pulled time if we actually transferred entropy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit cff850312cc7c0e0b9fe8b573687812dea232031
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cff85031.failed

In xfer_secondary_pull(), check to make sure we need to pull from the
secondary pool before checking and potentially updating the
last_pulled time.

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: George Spelvin <linux@horizon.com>
(cherry picked from commit cff850312cc7c0e0b9fe8b573687812dea232031)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/random.c
diff --cc drivers/char/random.c
index dd02db5d6935,364a8001a2bd..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -905,9 -917,13 +905,16 @@@ static ssize_t extract_entropy(struct e
   * from the primary pool to the secondary extraction pool. We make
   * sure we pull enough for a 'catastrophic reseed'.
   */
 -static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes);
  static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
  {
++<<<<<<< HEAD
 +	__u32	tmp[OUTPUT_POOL_WORDS];
++=======
+ 	if (!r->pull ||
+ 	    r->entropy_count >= (nbytes << (ENTROPY_SHIFT + 3)) ||
+ 	    r->entropy_count > r->poolinfo->poolfracbits)
+ 		return;
++>>>>>>> cff850312cc7 (random: only update the last_pulled time if we actually transferred entropy)
  
  	if (r->limit == 0 && random_min_urandom_seed) {
  		unsigned long now = jiffies;
@@@ -917,28 -933,45 +924,34 @@@
  			return;
  		r->last_pulled = now;
  	}
++<<<<<<< HEAD
 +	if (r->pull &&
 +	    r->entropy_count < (nbytes << (ENTROPY_SHIFT + 3)) &&
 +	    r->entropy_count < r->poolinfo->poolfracbits) {
 +		/* If we're limited, always leave two wakeup worth's BITS */
 +		int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;
 +		int bytes = nbytes;
++=======
+ 
+ 	_xfer_secondary_pool(r, nbytes);
+ }
 -
 -static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
 -{
 -	__u32	tmp[OUTPUT_POOL_WORDS];
 -
 -	/* For /dev/random's pool, always leave two wakeups' worth */
 -	int rsvd_bytes = r->limit ? 0 : random_read_wakeup_bits / 4;
 -	int bytes = nbytes;
 -
 -	/* pull at least as much as a wakeup */
 -	bytes = max_t(int, bytes, random_read_wakeup_bits / 8);
 -	/* but never more than the buffer size */
 -	bytes = min_t(int, bytes, sizeof(tmp));
 -
 -	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
 -				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));
 -	bytes = extract_entropy(r->pull, tmp, bytes,
 -				random_read_wakeup_bits / 8, rsvd_bytes);
 -	mix_pool_bytes(r, tmp, bytes);
 -	credit_entropy_bits(r, bytes*8);
 -}
 -
 -/*
 - * Used as a workqueue function so that when the input pool is getting
 - * full, we can "spill over" some entropy to the output pools.  That
 - * way the output pools can store some of the excess entropy instead
 - * of letting it go to waste.
 - */
 -static void push_to_pool(struct work_struct *work)
 -{
 -	struct entropy_store *r = container_of(work, struct entropy_store,
 -					      push_work);
 -	BUG_ON(!r);
 -	_xfer_secondary_pool(r, random_read_wakeup_bits/8);
 -	trace_push_to_pool(r->name, r->entropy_count >> ENTROPY_SHIFT,
 -			   r->pull->entropy_count >> ENTROPY_SHIFT);
++>>>>>>> cff850312cc7 (random: only update the last_pulled time if we actually transferred entropy)
 +
 +		/* pull at least as many as BYTES as wakeup BITS */
 +		bytes = max_t(int, bytes, random_read_wakeup_thresh / 8);
 +		/* but never more than the buffer size */
 +		bytes = min_t(int, bytes, sizeof(tmp));
 +
 +		DEBUG_ENT("going to reseed %s with %d bits "
 +			  "(%zu of %d requested)\n",
 +			  r->name, bytes * 8, nbytes * 8,
 +			  r->entropy_count >> ENTROPY_SHIFT);
 +
 +		bytes = extract_entropy(r->pull, tmp, bytes,
 +					random_read_wakeup_thresh / 8, rsvd);
 +		mix_pool_bytes(r, tmp, bytes, NULL);
 +		credit_entropy_bits(r, bytes*8);
 +	}
  }
  
  /*
* Unmerged path drivers/char/random.c
