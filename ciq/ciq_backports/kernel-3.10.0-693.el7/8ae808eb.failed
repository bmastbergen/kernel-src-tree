sctp: remove the old ttl expires policy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 8ae808eb853e3789b81b8a502cdf22bb01b76880
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8ae808eb.failed

The prsctp polices include ttl expires policy already, we should remove
the old ttl expires codes, and just adjust the new polices' codes to be
compatible with the old one for users.

This patch is to remove all the old expires codes, and if prsctp polices
are not set, it will still set msg's expires_at and check the expires in
sctp_check_abandoned.

Note that asoc->prsctp_enable is set by default, so users can't feel any
difference even if they use the old expires api in userspace.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8ae808eb853e3789b81b8a502cdf22bb01b76880)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/chunk.c
diff --cc net/sctp/chunk.c
index f6f8876e4253,615f0ddd41df..000000000000
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@@ -175,20 -181,11 +174,24 @@@ struct sctp_datamsg *sctp_datamsg_from_
  	/* Note: Calculate this outside of the loop, so that all fragments
  	 * have the same expiration.
  	 */
- 	if (sinfo->sinfo_timetolive) {
- 		/* sinfo_timetolive is in milliseconds */
+ 	if (asoc->peer.prsctp_capable && sinfo->sinfo_timetolive &&
+ 	    (SCTP_PR_TTL_ENABLED(sinfo->sinfo_flags) ||
+ 	     !SCTP_PR_POLICY(sinfo->sinfo_flags)))
  		msg->expires_at = jiffies +
  				    msecs_to_jiffies(sinfo->sinfo_timetolive);
++<<<<<<< HEAD
 +		msg->can_abandon = 1;
 +
 +		pr_debug("%s: msg:%p expires_at:%ld jiffies:%ld\n", __func__,
 +			 msg, msg->expires_at, jiffies);
 +	}
 +
 +	if (asoc->prsctp_enable &&
 +	    SCTP_PR_TTL_ENABLED(sinfo->sinfo_flags))
 +		msg->expires_at =
 +			jiffies + msecs_to_jiffies(sinfo->sinfo_timetolive);
++=======
++>>>>>>> 8ae808eb853e (sctp: remove the old ttl expires policy)
  
  	/* This is the biggest possible DATA chunk that can fit into
  	 * the packet
@@@ -348,18 -344,8 +351,21 @@@ errout
  /* Check whether this message has expired. */
  int sctp_chunk_abandoned(struct sctp_chunk *chunk)
  {
++<<<<<<< HEAD
 +	if (!chunk->asoc->prsctp_enable ||
 +	    !SCTP_PR_POLICY(chunk->sinfo.sinfo_flags)) {
 +		struct sctp_datamsg *msg = chunk->msg;
 +
 +		if (!msg->can_abandon)
 +			return 0;
 +
 +		if (time_after(jiffies, msg->expires_at))
 +			return 1;
 +
++=======
+ 	if (!chunk->asoc->peer.prsctp_capable)
++>>>>>>> 8ae808eb853e (sctp: remove the old ttl expires policy)
  		return 0;
- 	}
  
  	if (SCTP_PR_TTL_ENABLED(chunk->sinfo.sinfo_flags) &&
  	    time_after(jiffies, chunk->msg->expires_at)) {
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2dad8dd39aaf..19092c245834 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -535,7 +535,6 @@ struct sctp_datamsg {
 	/* Did the messenge fail to send? */
 	int send_error;
 	u8 send_failed:1,
-	   can_abandon:1,   /* can chunks from this message can be abandoned. */
 	   can_delay;	    /* should this message be Nagle delayed */
 };
 
* Unmerged path net/sctp/chunk.c
diff --git a/net/sctp/output.c b/net/sctp/output.c
index 8e152cbf6445..b206979707f9 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -877,9 +877,6 @@ static void sctp_packet_append_data(struct sctp_packet *packet,
 		rwnd = 0;
 
 	asoc->peer.rwnd = rwnd;
-	/* Has been accepted for transmission. */
-	if (!asoc->peer.prsctp_capable)
-		chunk->msg->can_abandon = 0;
 	sctp_chunk_assign_tsn(chunk);
 	sctp_chunk_assign_ssn(chunk);
 }
