ceph: fix non static symbol warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] ccp - Fix non static symbol warning (Suravee Suthikulpanit) [1390820]
Rebuild_FUZZ: 91.43%
commit-author Wei Yongjun <weiyongjun1@huawei.com>
commit 5130ccea7cf4646a24c005be1309b7f86f1e91c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5130ccea.failed

Fixes the following sparse warning:

fs/ceph/xattr.c:19:28: warning:
 symbol 'ceph_other_xattr_handler' was not declared. Should it be static?

	Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 5130ccea7cf4646a24c005be1309b7f86f1e91c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/xattr.c
diff --cc fs/ceph/xattr.c
index b75e117ea4f4,febc28f9e2c2..000000000000
--- a/fs/ceph/xattr.c
+++ b/fs/ceph/xattr.c
@@@ -15,6 -15,9 +15,12 @@@
  
  static int __remove_xattr(struct ceph_inode_info *ci,
  			  struct ceph_inode_xattr *xattr);
++<<<<<<< HEAD
++=======
+ 
+ static const struct xattr_handler ceph_other_xattr_handler;
+ 
++>>>>>>> 5130ccea7cf4 (ceph: fix non static symbol warning)
  /*
   * List of handlers for synthetic system.* attributes. Other
   * attributes are handled directly.
@@@ -1068,146 -1067,30 +1074,154 @@@ out
  	return err;
  }
  
 -static int ceph_get_xattr_handler(const struct xattr_handler *handler,
 -				  struct dentry *dentry, struct inode *inode,
 -				  const char *name, void *value, size_t size)
 +int ceph_setxattr(struct dentry *dentry, const char *name,
 +		  const void *value, size_t size, int flags)
  {
 -	if (!ceph_is_valid_xattr(name))
 -		return -EOPNOTSUPP;
 -	return __ceph_getxattr(inode, name, value, size);
 +	if (ceph_snap(dentry->d_inode) != CEPH_NOSNAP)
 +		return -EROFS;
 +
 +	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 +		return generic_setxattr(dentry, name, value, size, flags);
 +
 +	if (size == 0)
 +		value = "";  /* empty EA, do not remove */
 +
 +	return __ceph_setxattr(dentry, name, value, size, flags);
  }
  
 -static int ceph_set_xattr_handler(const struct xattr_handler *handler,
 -				  struct dentry *unused, struct inode *inode,
 -				  const char *name, const void *value,
 -				  size_t size, int flags)
 +static int ceph_send_removexattr(struct dentry *dentry, const char *name)
  {
 +	struct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);
 +	struct ceph_mds_client *mdsc = fsc->mdsc;
 +	struct inode *inode = dentry->d_inode;
 +	struct ceph_mds_request *req;
 +	int err;
 +
 +	req = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_RMXATTR,
 +				       USE_AUTH_MDS);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +	req->r_path2 = kstrdup(name, GFP_NOFS);
 +	if (!req->r_path2)
 +		return -ENOMEM;
 +
 +	req->r_inode = inode;
 +	ihold(inode);
 +	req->r_num_caps = 1;
 +	req->r_inode_drop = CEPH_CAP_XATTR_SHARED;
 +	err = ceph_mdsc_do_request(mdsc, NULL, req);
 +	ceph_mdsc_put_request(req);
 +	return err;
 +}
 +
++<<<<<<< HEAD
 +int __ceph_removexattr(struct dentry *dentry, const char *name)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct ceph_vxattr *vxattr;
 +	struct ceph_inode_info *ci = ceph_inode(inode);
 +	struct ceph_mds_client *mdsc = ceph_sb_to_client(dentry->d_sb)->mdsc;
 +	struct ceph_cap_flush *prealloc_cf = NULL;
 +	int issued;
 +	int err;
 +	int required_blob_size;
 +	int dirty;
 +	bool lock_snap_rwsem = false;
 +
  	if (!ceph_is_valid_xattr(name))
  		return -EOPNOTSUPP;
 -	return __ceph_setxattr(inode, name, value, size, flags);
 +
 +	vxattr = ceph_match_vxattr(inode, name);
 +	if (vxattr && vxattr->readonly)
 +		return -EOPNOTSUPP;
 +
 +	/* pass any unhandled ceph.* xattrs through to the MDS */
 +	if (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))
 +		goto do_sync_unlocked;
 +
 +	prealloc_cf = ceph_alloc_cap_flush();
 +	if (!prealloc_cf)
 +		return -ENOMEM;
 +
 +	err = -ENOMEM;
 +	spin_lock(&ci->i_ceph_lock);
 +retry:
 +	issued = __ceph_caps_issued(ci, NULL);
 +	if (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))
 +		goto do_sync;
 +
 +	if (!lock_snap_rwsem && !ci->i_head_snapc) {
 +		lock_snap_rwsem = true;
 +		if (!down_read_trylock(&mdsc->snap_rwsem)) {
 +			spin_unlock(&ci->i_ceph_lock);
 +			down_read(&mdsc->snap_rwsem);
 +			spin_lock(&ci->i_ceph_lock);
 +			goto retry;
 +		}
 +	}
 +
 +	dout("removexattr %p issued %s\n", inode, ceph_cap_string(issued));
 +
 +	__build_xattrs(inode);
 +
 +	required_blob_size = __get_required_blob_size(ci, 0, 0);
 +
 +	if (!ci->i_xattrs.prealloc_blob ||
 +	    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {
 +		struct ceph_buffer *blob;
 +
 +		spin_unlock(&ci->i_ceph_lock);
 +		dout(" preaallocating new blob size=%d\n", required_blob_size);
 +		blob = ceph_buffer_new(required_blob_size, GFP_NOFS);
 +		if (!blob)
 +			goto do_sync_unlocked;
 +		spin_lock(&ci->i_ceph_lock);
 +		if (ci->i_xattrs.prealloc_blob)
 +			ceph_buffer_put(ci->i_xattrs.prealloc_blob);
 +		ci->i_xattrs.prealloc_blob = blob;
 +		goto retry;
 +	}
 +
 +	err = __remove_xattr_by_name(ceph_inode(inode), name);
 +
 +	dirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL,
 +				       &prealloc_cf);
 +	ci->i_xattrs.dirty = true;
 +	inode->i_ctime = current_fs_time(inode->i_sb);
 +	spin_unlock(&ci->i_ceph_lock);
 +	if (lock_snap_rwsem)
 +		up_read(&mdsc->snap_rwsem);
 +	if (dirty)
 +		__mark_inode_dirty(inode, dirty);
 +	ceph_free_cap_flush(prealloc_cf);
 +	return err;
 +do_sync:
 +	spin_unlock(&ci->i_ceph_lock);
 +do_sync_unlocked:
 +	if (lock_snap_rwsem)
 +		up_read(&mdsc->snap_rwsem);
 +	ceph_free_cap_flush(prealloc_cf);
 +	err = ceph_send_removexattr(dentry, name);
 +	return err;
  }
  
 +int ceph_removexattr(struct dentry *dentry, const char *name)
 +{
 +	if (ceph_snap(dentry->d_inode) != CEPH_NOSNAP)
 +		return -EROFS;
 +
 +	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 +		return generic_removexattr(dentry, name);
 +
 +	return __ceph_removexattr(dentry, name);
 +}
++=======
+ static const struct xattr_handler ceph_other_xattr_handler = {
+ 	.prefix = "",  /* match any name => handlers called with full name */
+ 	.get = ceph_get_xattr_handler,
+ 	.set = ceph_set_xattr_handler,
+ };
++>>>>>>> 5130ccea7cf4 (ceph: fix non static symbol warning)
  
  #ifdef CONFIG_SECURITY
  bool ceph_security_xattr_wanted(struct inode *in)
* Unmerged path fs/ceph/xattr.c
