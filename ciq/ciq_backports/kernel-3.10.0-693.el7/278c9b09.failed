x86/platform/UV: Add basic CPU NMI health check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] platform/uv: Add basic CPU NMI health check (Frank Ramsay) [1416460]
Rebuild_FUZZ: 95.56%
commit-author travis@sgi.com <travis@sgi.com>
commit 278c9b099b2fc0cc0a51de95a1dcefcf54ca2183
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/278c9b09.failed

Add a low impact health check triggered by the system NMI command
that essentially checks which CPUs are responding to external NMI's.

	Signed-off-by: Mike Travis <travis@sgi.com>
	Reviewed-by: Russ Anderson <rja@hpe.com>
	Reviewed-by: Alex Thorlton <athorlton@sgi.com>
	Acked-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Dimitri Sivanich <sivanich@hpe.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20170125163517.756690240@asylum.americas.sgi.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 278c9b099b2fc0cc0a51de95a1dcefcf54ca2183)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/uv/uv_nmi.c
diff --cc arch/x86/platform/uv/uv_nmi.c
index c6fd36338c09,8a4aa5b3c11a..000000000000
--- a/arch/x86/platform/uv/uv_nmi.c
+++ b/arch/x86/platform/uv/uv_nmi.c
@@@ -150,8 -176,9 +150,9 @@@ module_param_named(retry_count, uv_nmi_
   *  "kdump"	- do crash dump
   *  "kdb"	- enter KDB (default)
   *  "kgdb"	- enter KGDB
+  *  "health"	- check if CPUs respond to NMI
   */
 -static char uv_nmi_action[8] = "kdb";
 +static char uv_nmi_action[8] = "kdump";
  module_param_string(action, uv_nmi_action, sizeof(uv_nmi_action), 0644);
  
  static inline bool uv_nmi_action_is(const char *action)
@@@ -630,16 -758,26 +647,23 @@@ int uv_handle_nmi(unsigned int reason, 
  	/* Pause as all cpus enter the NMI handler */
  	uv_nmi_wait(master);
  
++<<<<<<< HEAD
 +	/* Dump state of each cpu */
 +	if (uv_nmi_action_is("ips") || uv_nmi_action_is("dump"))
++=======
+ 	/* Process actions other than "kdump": */
+ 	if (uv_nmi_action_is("health")) {
+ 		uv_nmi_action_health(cpu, regs, master);
+ 	} else if (uv_nmi_action_is("ips") || uv_nmi_action_is("dump")) {
++>>>>>>> 278c9b099b2f (x86/platform/UV: Add basic CPU NMI health check)
  		uv_nmi_dump_state(cpu, regs, master);
 -	} else if (uv_nmi_action_is("kdb") || uv_nmi_action_is("kgdb")) {
 +
 +	/* Call KGDB/KDB if enabled */
 +	else if (uv_nmi_action_is("kdb") || uv_nmi_action_is("kgdb"))
  		uv_call_kgdb_kdb(cpu, regs, master);
 -	} else {
 -		if (master)
 -			pr_alert("UV: unknown NMI action: %s\n", uv_nmi_action);
 -		uv_nmi_sync_exit(master);
 -	}
  
 -	/* Clear per_cpu "in_nmi" flag */
 -	this_cpu_write(uv_cpu_nmi.state, UV_NMI_STATE_OUT);
 +	/* Clear per_cpu "in nmi" flag */
 +	atomic_set(&uv_cpu_nmi.state, UV_NMI_STATE_OUT);
  
  	/* Clear MMR NMI flag on each hub */
  	uv_clear_nmi(cpu);
* Unmerged path arch/x86/platform/uv/uv_nmi.c
