scsi: megaraid_sas: Indentation and smatch warning fixes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: Indentation and smatch warning fixes (Tomas Henzl) [1417038]
Rebuild_FUZZ: 94.34%
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit 41064f1bf8886bc43afbd9aa23a698f97bc65664
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/41064f1b.failed

Fix indentation issues and smatch warning reported by Dan Carpenter
for previous series as discussed below.
http://www.spinics.net/lists/linux-scsi/msg103635.html
http://www.spinics.net/lists/linux-scsi/msg103603.html

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Kashyap Desai <kashyap.desai@broadcom.com>
	Signed-off-by: Sasikumar Chandrasekaran <sasikumar.pc@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 41064f1bf8886bc43afbd9aa23a698f97bc65664)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas.h
#	drivers/scsi/megaraid/megaraid_sas_fp.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.h
diff --cc drivers/scsi/megaraid/megaraid_sas.h
index d09b4ae240a5,8c06cbfd07b8..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@@ -1317,7 -1328,55 +1317,59 @@@ struct megasas_ctrl_info 
  #endif
  	} adapterOperations3;
  
++<<<<<<< HEAD
 +	u8          pad[0x800-0x7EC];
++=======
+ 	struct {
+ #if defined(__BIG_ENDIAN_BITFIELD)
+ 	u8 reserved:7;
+ 	/* Indicates whether the CPLD image is part of
+ 	 *  the package and stored in flash
+ 	 */
+ 	u8 cpld_in_flash:1;
+ #else
+ 	u8 cpld_in_flash:1;
+ 	u8 reserved:7;
+ #endif
+ 	u8 reserved1[3];
+ 	/* Null terminated string. Has the version
+ 	 *  information if cpld_in_flash = FALSE
+ 	 */
+ 	u8 userCodeDefinition[12];
+ 	} cpld;  /* Valid only if upgradableCPLD is TRUE */
+ 
+ 	struct {
+ 	#if defined(__BIG_ENDIAN_BITFIELD)
+ 		u16 reserved:8;
+ 		u16 fw_swaps_bbu_vpd_info:1;
+ 		u16 support_pd_map_target_id:1;
+ 		u16 support_ses_ctrl_in_multipathcfg:1;
+ 		u16 image_upload_supported:1;
+ 		u16 support_encrypted_mfc:1;
+ 		u16 supported_enc_algo:1;
+ 		u16 support_ibutton_less:1;
+ 		u16 ctrl_info_ext_supported:1;
+ 	#else
+ 
+ 		u16 ctrl_info_ext_supported:1;
+ 		u16 support_ibutton_less:1;
+ 		u16 supported_enc_algo:1;
+ 		u16 support_encrypted_mfc:1;
+ 		u16 image_upload_supported:1;
+ 		/* FW supports LUN based association and target port based */
+ 		u16 support_ses_ctrl_in_multipathcfg:1;
+ 		/* association for the SES device connected in multipath mode */
+ 		/* FW defines Jbod target Id within MR_PD_CFG_SEQ */
+ 		u16 support_pd_map_target_id:1;
+ 		/* FW swaps relevant fields in MR_BBU_VPD_INFO_FIXED to
+ 		 *  provide the data in little endian order
+ 		 */
+ 		u16 fw_swaps_bbu_vpd_info:1;
+ 		u16 reserved:8;
+ 	#endif
+ 		} adapter_operations4;
+ 	u8 pad[0x800 - 0x7FE]; /* 0x7FE pad to 2K for expansion */
++>>>>>>> 41064f1bf888 (scsi: megaraid_sas: Indentation and smatch warning fixes)
  } __packed;
  
  /*
diff --cc drivers/scsi/megaraid/megaraid_sas_fp.c
index 53238db53032,62affa76133d..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fp.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fp.c
@@@ -186,11 -193,98 +186,105 @@@ void MR_PopulateDrvRaidMap(struct megas
  	struct MR_DRV_RAID_MAP_ALL *drv_map =
  			fusion->ld_drv_map[(instance->map_id & 1)];
  	struct MR_DRV_RAID_MAP *pDrvRaidMap = &drv_map->raidMap;
++<<<<<<< HEAD
++=======
+ 	void *raid_map_data = NULL;
+ 
+ 	memset(drv_map, 0, fusion->drv_map_sz);
+ 	memset(pDrvRaidMap->ldTgtIdToLd,
+ 	       0xff, (sizeof(u16) * MAX_LOGICAL_DRIVES_DYN));
+ 
+ 	if (instance->max_raid_mapsize) {
+ 		fw_map_dyn = fusion->ld_map[(instance->map_id & 1)];
+ 		desc_table =
+ 		(struct MR_RAID_MAP_DESC_TABLE *)((void *)fw_map_dyn + le32_to_cpu(fw_map_dyn->desc_table_offset));
+ 		if (desc_table != fw_map_dyn->raid_map_desc_table)
+ 			dev_dbg(&instance->pdev->dev, "offsets of desc table are not matching desc %p original %p\n",
+ 				desc_table, fw_map_dyn->raid_map_desc_table);
+ 
+ 		ld_count = (u16)le16_to_cpu(fw_map_dyn->ld_count);
+ 		pDrvRaidMap->ldCount = (__le16)cpu_to_le16(ld_count);
+ 		pDrvRaidMap->fpPdIoTimeoutSec =
+ 			fw_map_dyn->fp_pd_io_timeout_sec;
+ 		pDrvRaidMap->totalSize =
+ 			cpu_to_le32(sizeof(struct MR_DRV_RAID_MAP_ALL));
+ 		/* point to actual data starting point*/
+ 		raid_map_data = (void *)fw_map_dyn +
+ 			le32_to_cpu(fw_map_dyn->desc_table_offset) +
+ 			le32_to_cpu(fw_map_dyn->desc_table_size);
+ 
+ 		for (i = 0; i < le32_to_cpu(fw_map_dyn->desc_table_num_elements); ++i) {
+ 			switch (le32_to_cpu(desc_table->raid_map_desc_type)) {
+ 			case RAID_MAP_DESC_TYPE_DEVHDL_INFO:
+ 				fw_map_dyn->dev_hndl_info =
+ 				(struct MR_DEV_HANDLE_INFO *)(raid_map_data + le32_to_cpu(desc_table->raid_map_desc_offset));
+ 				memcpy(pDrvRaidMap->devHndlInfo,
+ 					fw_map_dyn->dev_hndl_info,
+ 					sizeof(struct MR_DEV_HANDLE_INFO) *
+ 					le32_to_cpu(desc_table->raid_map_desc_elements));
+ 			break;
+ 			case RAID_MAP_DESC_TYPE_TGTID_INFO:
+ 				fw_map_dyn->ld_tgt_id_to_ld =
+ 					(u16 *)(raid_map_data +
+ 					le32_to_cpu(desc_table->raid_map_desc_offset));
+ 				for (j = 0; j < le32_to_cpu(desc_table->raid_map_desc_elements); j++) {
+ 					pDrvRaidMap->ldTgtIdToLd[j] =
+ 						le16_to_cpu(fw_map_dyn->ld_tgt_id_to_ld[j]);
+ 				}
+ 			break;
+ 			case RAID_MAP_DESC_TYPE_ARRAY_INFO:
+ 				fw_map_dyn->ar_map_info =
+ 					(struct MR_ARRAY_INFO *)
+ 					(raid_map_data + le32_to_cpu(desc_table->raid_map_desc_offset));
+ 				memcpy(pDrvRaidMap->arMapInfo,
+ 				       fw_map_dyn->ar_map_info,
+ 				       sizeof(struct MR_ARRAY_INFO) *
+ 				       le32_to_cpu(desc_table->raid_map_desc_elements));
+ 			break;
+ 			case RAID_MAP_DESC_TYPE_SPAN_INFO:
+ 				fw_map_dyn->ld_span_map =
+ 					(struct MR_LD_SPAN_MAP *)
+ 					(raid_map_data +
+ 					le32_to_cpu(desc_table->raid_map_desc_offset));
+ 				memcpy(pDrvRaidMap->ldSpanMap,
+ 				       fw_map_dyn->ld_span_map,
+ 				       sizeof(struct MR_LD_SPAN_MAP) *
+ 				       le32_to_cpu(desc_table->raid_map_desc_elements));
+ 			break;
+ 			default:
+ 				dev_dbg(&instance->pdev->dev, "wrong number of desctableElements %d\n",
+ 					fw_map_dyn->desc_table_num_elements);
+ 			}
+ 			++desc_table;
+ 		}
+ 
+ 	} else if (instance->supportmax256vd) {
+ 		fw_map_ext =
+ 			(struct MR_FW_RAID_MAP_EXT *)fusion->ld_map[(instance->map_id & 1)];
+ 		ld_count = (u16)le16_to_cpu(fw_map_ext->ldCount);
+ 		if (ld_count > MAX_LOGICAL_DRIVES_EXT) {
+ 			dev_dbg(&instance->pdev->dev, "megaraid_sas: LD count exposed in RAID map in not valid\n");
+ 			return;
+ 		}
+ 
+ 		pDrvRaidMap->ldCount = (__le16)cpu_to_le16(ld_count);
+ 		pDrvRaidMap->fpPdIoTimeoutSec = fw_map_ext->fpPdIoTimeoutSec;
+ 		for (i = 0; i < (MAX_LOGICAL_DRIVES_EXT); i++)
+ 			pDrvRaidMap->ldTgtIdToLd[i] =
+ 				(u16)fw_map_ext->ldTgtIdToLd[i];
+ 		memcpy(pDrvRaidMap->ldSpanMap, fw_map_ext->ldSpanMap,
+ 		       sizeof(struct MR_LD_SPAN_MAP) * ld_count);
+ 		memcpy(pDrvRaidMap->arMapInfo, fw_map_ext->arMapInfo,
+ 		       sizeof(struct MR_ARRAY_INFO) * MAX_API_ARRAYS_EXT);
+ 		memcpy(pDrvRaidMap->devHndlInfo, fw_map_ext->devHndlInfo,
+ 		       sizeof(struct MR_DEV_HANDLE_INFO) *
+ 		       MAX_RAIDMAP_PHYSICAL_DEVICES);
++>>>>>>> 41064f1bf888 (scsi: megaraid_sas: Indentation and smatch warning fixes)
  
 +	if (instance->supportmax256vd) {
 +		memcpy(fusion->ld_drv_map[instance->map_id & 1],
 +			fusion->ld_map[instance->map_id & 1],
 +			fusion->current_map_sz);
  		/* New Raid map will not set totalSize, so keep expected value
  		 * for legacy code in ValidateMapInfo
  		 */
@@@ -287,8 -347,10 +381,15 @@@ u8 MR_ValidateMapInfo(struct megasas_in
  			(sizeof(struct MR_LD_SPAN_MAP) * le16_to_cpu(pDrvRaidMap->ldCount)));
  
  	if (le32_to_cpu(pDrvRaidMap->totalSize) != expected_size) {
++<<<<<<< HEAD
 +		dev_err(&instance->pdev->dev, "map info structure size 0x%x is not matching with ld count\n",
 +		       (unsigned int) expected_size);
++=======
+ 		dev_dbg(&instance->pdev->dev, "megasas: map info structure size 0x%x",
+ 			le32_to_cpu(pDrvRaidMap->totalSize));
+ 		dev_dbg(&instance->pdev->dev, "is not matching expected size 0x%x\n",
+ 			(unsigned int)expected_size);
++>>>>>>> 41064f1bf888 (scsi: megaraid_sas: Indentation and smatch warning fixes)
  		dev_err(&instance->pdev->dev, "megasas: span map %x, pDrvRaidMap->totalSize : %x\n",
  			(unsigned int)sizeof(struct MR_LD_SPAN_MAP),
  			le32_to_cpu(pDrvRaidMap->totalSize));
@@@ -804,9 -772,17 +905,23 @@@ static u8 mr_spanset_get_phy_params(str
  	}
  
  	*pdBlock += stripRef + le64_to_cpu(MR_LdSpanPtrGet(ld, span, map)->startBlk);
++<<<<<<< HEAD
 +	pRAID_Context->spanArm = (span << RAID_CTX_SPANARM_SPAN_SHIFT) |
 +					physArm;
 +	io_info->span_arm = pRAID_Context->spanArm;
++=======
+ 	if (instance->is_ventura) {
+ 		((struct RAID_CONTEXT_G35 *)pRAID_Context)->span_arm =
+ 			(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;
+ 		io_info->span_arm =
+ 			(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;
+ 	} else {
+ 		pRAID_Context->span_arm =
+ 			(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;
+ 		io_info->span_arm = pRAID_Context->span_arm;
+ 	}
+ 	io_info->pd_after_lb = pd;
++>>>>>>> 41064f1bf888 (scsi: megaraid_sas: Indentation and smatch warning fixes)
  	return retval;
  }
  
@@@ -910,9 -890,17 +1025,23 @@@ u8 MR_GetPhyParams(struct megasas_insta
  	}
  
  	*pdBlock += stripRef + le64_to_cpu(MR_LdSpanPtrGet(ld, span, map)->startBlk);
++<<<<<<< HEAD
 +	pRAID_Context->spanArm = (span << RAID_CTX_SPANARM_SPAN_SHIFT) |
 +		physArm;
 +	io_info->span_arm = pRAID_Context->spanArm;
++=======
+ 	if (instance->is_ventura) {
+ 		((struct RAID_CONTEXT_G35 *)pRAID_Context)->span_arm =
+ 				(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;
+ 		io_info->span_arm =
+ 				(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;
+ 	} else {
+ 		pRAID_Context->span_arm =
+ 			(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;
+ 		io_info->span_arm = pRAID_Context->span_arm;
+ 	}
+ 	io_info->pd_after_lb = pd;
++>>>>>>> 41064f1bf888 (scsi: megaraid_sas: Indentation and smatch warning fixes)
  	return retval;
  }
  
@@@ -1351,30 -1312,36 +1480,57 @@@ u8 megasas_get_best_arm_pd(struct megas
  	pd1 = MR_ArPdGet(arRef, (arm + 1) >= span_row_size ?
  		(arm + 1 - span_row_size) : arm + 1, drv_map);
  
 -	/* Get PD1 Dev Handle */
 +	/* get the pending cmds for the data and mirror arms */
 +	pend0 = atomic_read(&lbInfo->scsi_pending_cmds[pd0]);
 +	pend1 = atomic_read(&lbInfo->scsi_pending_cmds[pd1]);
  
 -	pd1_dev_handle = MR_PdDevHandleGet(pd1, drv_map);
 +	/* Determine the disk whose head is nearer to the req. block */
 +	diff0 = ABS_DIFF(block, lbInfo->last_accessed_block[pd0]);
 +	diff1 = ABS_DIFF(block, lbInfo->last_accessed_block[pd1]);
 +	bestArm = (diff0 <= diff1 ? arm : arm ^ 1);
  
++<<<<<<< HEAD
 +	if ((bestArm == arm && pend0 > pend1 + lb_pending_cmds)  ||
 +			(bestArm != arm && pend1 > pend0 + lb_pending_cmds))
 +		bestArm ^= 1;
++=======
+ 	if (pd1_dev_handle == MR_DEVHANDLE_INVALID) {
+ 		bestArm = arm;
+ 	} else {
+ 		/* get the pending cmds for the data and mirror arms */
+ 		pend0 = atomic_read(&lbInfo->scsi_pending_cmds[pd0]);
+ 		pend1 = atomic_read(&lbInfo->scsi_pending_cmds[pd1]);
+ 
+ 		/* Determine the disk whose head is nearer to the req. block */
+ 		diff0 = ABS_DIFF(block, lbInfo->last_accessed_block[pd0]);
+ 		diff1 = ABS_DIFF(block, lbInfo->last_accessed_block[pd1]);
+ 		bestArm = (diff0 <= diff1 ? arm : arm ^ 1);
+ 
+ 		/* Make balance count from 16 to 4 to
+ 		 *  keep driver in sync with Firmware
+ 		 */
+ 		if ((bestArm == arm && pend0 > pend1 + lb_pending_cmds)  ||
+ 		    (bestArm != arm && pend1 > pend0 + lb_pending_cmds))
+ 			bestArm ^= 1;
+ 
+ 		/* Update the last accessed block on the correct pd */
+ 		io_info->span_arm =
+ 			(span << RAID_CTX_SPANARM_SPAN_SHIFT) | bestArm;
+ 		io_info->pd_after_lb = (bestArm == arm) ? pd0 : pd1;
+ 	}
++>>>>>>> 41064f1bf888 (scsi: megaraid_sas: Indentation and smatch warning fixes)
  
 +	/* Update the last accessed block on the correct pd */
 +	io_info->pd_after_lb = (bestArm == arm) ? pd0 : pd1;
  	lbInfo->last_accessed_block[io_info->pd_after_lb] = block + count - 1;
 +	io_info->span_arm = (span << RAID_CTX_SPANARM_SPAN_SHIFT) | bestArm;
 +#if SPAN_DEBUG
 +	if (arm != bestArm)
 +		dev_dbg(&instance->pdev->dev, "LSI Debug R1 Load balance "
 +			"occur - span 0x%x arm 0x%x bestArm 0x%x "
 +			"io_info->span_arm 0x%x\n",
 +			span, arm, bestArm, io_info->span_arm);
 +#endif
  	return io_info->pd_after_lb;
  }
  
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index dad24a6b5eae,9928766445d6..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -1774,48 -2046,46 +1772,71 @@@ static void megasas_stream_detect(struc
  	struct STREAM_DETECT *current_sd;
  	/* find possible stream */
  	for (i = 0; i < MAX_STREAMS_TRACKED; ++i) {
- 		stream_num =
- 		(*track_stream >> (i * BITS_PER_INDEX_STREAM)) &
+ 		stream_num = (*track_stream >>
+ 			(i * BITS_PER_INDEX_STREAM)) &
  			STREAM_MASK;
  		current_sd = &current_ld_sd->stream_track[stream_num];
++<<<<<<< HEAD
 +	/* if we found a stream, update the raid
 +	 *  context and also update the mruBitMap
 +	 */
 +	/*	boundary condition */
 +	if ((current_sd->next_seq_lba) &&
 +		(io_info->ldStartBlock >= current_sd->next_seq_lba) &&
 +		(io_info->ldStartBlock <= (current_sd->next_seq_lba+32)) &&
 +		(current_sd->is_read == io_info->isRead)) {
 +
 +		if ((io_info->ldStartBlock != current_sd->next_seq_lba)
 +			&& ((!io_info->isRead) || (!is_read_ahead)))
 +			/*
 +			 * Once the API availible we need to change this.
 +			 * At this point we are not allowing any gap
 +			 */
 +			continue;
 +
 +		cmd->io_request->RaidContext.raid_context_g35.stream_detected = true;
 +		current_sd->next_seq_lba =
 +		io_info->ldStartBlock + io_info->numBlocks;
 +		/*
 +		 *	update the mruBitMap LRU
++=======
+ 		/* if we found a stream, update the raid
+ 		 *  context and also update the mruBitMap
++>>>>>>> 41064f1bf888 (scsi: megaraid_sas: Indentation and smatch warning fixes)
  		 */
- 		shifted_values_mask =
- 			(1 <<  i * BITS_PER_INDEX_STREAM) - 1;
- 		shifted_values = ((*track_stream & shifted_values_mask)
- 					<< BITS_PER_INDEX_STREAM);
- 		index_value_mask =
- 			STREAM_MASK << i * BITS_PER_INDEX_STREAM;
- 		unshifted_values =
- 			*track_stream & ~(shifted_values_mask |
- 			index_value_mask);
- 		*track_stream =
- 			unshifted_values | shifted_values | stream_num;
- 		return;
- 
+ 		/*	boundary condition */
+ 		if ((current_sd->next_seq_lba) &&
+ 		    (io_info->ldStartBlock >= current_sd->next_seq_lba) &&
+ 		    (io_info->ldStartBlock <= (current_sd->next_seq_lba + 32)) &&
+ 		    (current_sd->is_read == io_info->isRead)) {
+ 
+ 			if ((io_info->ldStartBlock != current_sd->next_seq_lba)	&&
+ 			    ((!io_info->isRead) || (!is_read_ahead)))
+ 				/*
+ 				 * Once the API availible we need to change this.
+ 				 * At this point we are not allowing any gap
+ 				 */
+ 				continue;
+ 
+ 			SET_STREAM_DETECTED(cmd->io_request->RaidContext.raid_context_g35);
+ 			current_sd->next_seq_lba =
+ 			io_info->ldStartBlock + io_info->numBlocks;
+ 			/*
+ 			 *	update the mruBitMap LRU
+ 			 */
+ 			shifted_values_mask =
+ 				(1 <<  i * BITS_PER_INDEX_STREAM) - 1;
+ 			shifted_values = ((*track_stream & shifted_values_mask)
+ 						<< BITS_PER_INDEX_STREAM);
+ 			index_value_mask =
+ 				STREAM_MASK << i * BITS_PER_INDEX_STREAM;
+ 			unshifted_values =
+ 				*track_stream & ~(shifted_values_mask |
+ 				index_value_mask);
+ 			*track_stream =
+ 				unshifted_values | shifted_values | stream_num;
+ 			return;
  		}
- 
  	}
  	/*
  	 * if we did not find any stream, create a new one
@@@ -1827,12 -2097,90 +1848,10 @@@
  	current_sd = &current_ld_sd->stream_track[stream_num];
  	current_sd->is_read = io_info->isRead;
  	current_sd->next_seq_lba = io_info->ldStartBlock + io_info->numBlocks;
- 	*track_stream =
- 	(((*track_stream & ZERO_LAST_STREAM) << 4) | stream_num);
+ 	*track_stream = (((*track_stream & ZERO_LAST_STREAM) << 4) | stream_num);
  	return;
- 
  }
  
 -/**
 - * megasas_set_raidflag_cpu_affinity - This function sets the cpu
 - * affinity (cpu of the controller) and raid_flags in the raid context
 - * based on IO type.
 - *
 - * @praid_context:	IO RAID context
 - * @raid:		LD raid map
 - * @fp_possible:	Is fast path possible?
 - * @is_read:		Is read IO?
 - *
 - */
 -static void
 -megasas_set_raidflag_cpu_affinity(union RAID_CONTEXT_UNION *praid_context,
 -				  struct MR_LD_RAID *raid, bool fp_possible,
 -				  u8 is_read, u32 scsi_buff_len)
 -{
 -	u8 cpu_sel = MR_RAID_CTX_CPUSEL_0;
 -	struct RAID_CONTEXT_G35 *rctx_g35;
 -
 -	rctx_g35 = &praid_context->raid_context_g35;
 -	if (fp_possible) {
 -		if (is_read) {
 -			if ((raid->cpuAffinity.pdRead.cpu0) &&
 -			    (raid->cpuAffinity.pdRead.cpu1))
 -				cpu_sel = MR_RAID_CTX_CPUSEL_FCFS;
 -			else if (raid->cpuAffinity.pdRead.cpu1)
 -				cpu_sel = MR_RAID_CTX_CPUSEL_1;
 -		} else {
 -			if ((raid->cpuAffinity.pdWrite.cpu0) &&
 -			    (raid->cpuAffinity.pdWrite.cpu1))
 -				cpu_sel = MR_RAID_CTX_CPUSEL_FCFS;
 -			else if (raid->cpuAffinity.pdWrite.cpu1)
 -				cpu_sel = MR_RAID_CTX_CPUSEL_1;
 -			/* Fast path cache by pass capable R0/R1 VD */
 -			if ((raid->level <= 1) &&
 -			    (raid->capability.fp_cache_bypass_capable)) {
 -				rctx_g35->routing_flags |=
 -					(1 << MR_RAID_CTX_ROUTINGFLAGS_SLD_SHIFT);
 -				rctx_g35->raid_flags =
 -					(MR_RAID_FLAGS_IO_SUB_TYPE_CACHE_BYPASS
 -					<< MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT);
 -			}
 -		}
 -	} else {
 -		if (is_read) {
 -			if ((raid->cpuAffinity.ldRead.cpu0) &&
 -			    (raid->cpuAffinity.ldRead.cpu1))
 -				cpu_sel = MR_RAID_CTX_CPUSEL_FCFS;
 -			else if (raid->cpuAffinity.ldRead.cpu1)
 -				cpu_sel = MR_RAID_CTX_CPUSEL_1;
 -		} else {
 -			if ((raid->cpuAffinity.ldWrite.cpu0) &&
 -			    (raid->cpuAffinity.ldWrite.cpu1))
 -				cpu_sel = MR_RAID_CTX_CPUSEL_FCFS;
 -			else if (raid->cpuAffinity.ldWrite.cpu1)
 -				cpu_sel = MR_RAID_CTX_CPUSEL_1;
 -
 -			if (is_stream_detected(rctx_g35) &&
 -			    (raid->level == 5) &&
 -			    (raid->writeMode == MR_RL_WRITE_THROUGH_MODE) &&
 -			    (cpu_sel == MR_RAID_CTX_CPUSEL_FCFS))
 -				cpu_sel = MR_RAID_CTX_CPUSEL_0;
 -		}
 -	}
 -
 -	rctx_g35->routing_flags |=
 -		(cpu_sel << MR_RAID_CTX_ROUTINGFLAGS_CPUSEL_SHIFT);
 -
 -	/* Always give priority to MR_RAID_FLAGS_IO_SUB_TYPE_LDIO_BW_LIMIT
 -	 * vs MR_RAID_FLAGS_IO_SUB_TYPE_CACHE_BYPASS.
 -	 * IO Subtype is not bitmap.
 -	 */
 -	if ((raid->level == 1) && (!is_read)) {
 -		if (scsi_buff_len > MR_LARGE_IO_MIN_SIZE)
 -			praid_context->raid_context_g35.raid_flags =
 -				(MR_RAID_FLAGS_IO_SUB_TYPE_LDIO_BW_LIMIT
 -				<< MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT);
 -	}
 -}
 -
  /**
   * megasas_build_ldio_fusion -	Prepares IOs to devices
   * @instance:		Adapter soft state
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.h
index ef6bfe55344c,8e8c35f6b872..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.h
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.h
@@@ -789,7 -875,36 +789,40 @@@ struct MR_LD_RAID 
  
  	u8	LUN[8]; /* 0x24 8 byte LUN field used for SCSI IO's */
  	u8	fpIoTimeoutForLd;/*0x2C timeout value used by driver in FP IO*/
++<<<<<<< HEAD
 +	u8      reserved3[0x80-0x2D]; /* 0x2D */
++=======
+ 	/* Ox2D This LD accept priority boost of this type */
+ 	u8 ld_accept_priority_type;
+ 	u8 reserved2[2];	        /* 0x2E - 0x2F */
+ 	/* 0x30 - 0x33, Logical block size for the LD */
+ 	u32 logical_block_length;
+ 	struct {
+ #ifndef MFI_BIG_ENDIAN
+ 	/* 0x34, P_I_EXPONENT from READ CAPACITY 16 */
+ 	u32 ld_pi_exp:4;
+ 	/* 0x34, LOGICAL BLOCKS PER PHYSICAL
+ 	 *  BLOCK EXPONENT from READ CAPACITY 16
+ 	 */
+ 	u32 ld_logical_block_exp:4;
+ 	u32 reserved1:24;           /* 0x34 */
+ #else
+ 	u32 reserved1:24;           /* 0x34 */
+ 	/* 0x34, LOGICAL BLOCKS PER PHYSICAL
+ 	 *  BLOCK EXPONENT from READ CAPACITY 16
+ 	 */
+ 	u32 ld_logical_block_exp:4;
+ 	/* 0x34, P_I_EXPONENT from READ CAPACITY 16 */
+ 	u32 ld_pi_exp:4;
+ #endif
+ 	};                               /* 0x34 - 0x37 */
+ 	 /* 0x38 - 0x3f, This will determine which
+ 	  *  core will process LD IO and PD IO.
+ 	  */
+ 	struct MR_IO_AFFINITY cpuAffinity;
+      /* Bit definiations are specified by MR_IO_AFFINITY */
+ 	u8 reserved3[0x80 - 0x40];    /* 0x40 - 0x7f */
++>>>>>>> 41064f1bf888 (scsi: megaraid_sas: Indentation and smatch warning fixes)
  };
  
  struct MR_LD_SPAN_MAP {
* Unmerged path drivers/scsi/megaraid/megaraid_sas.h
diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c
index 20d0591e6622..318ba873812c 100644
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@ -5249,14 +5249,14 @@ static int megasas_init_fw(struct megasas_instance *instance)
 	memset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);
 
 	/* stream detection initialization */
-	if (instance->is_ventura) {
+	if (instance->is_ventura && fusion) {
 		fusion->stream_detect_by_ld =
-		kzalloc(sizeof(struct LD_STREAM_DETECT *)
-		* MAX_LOGICAL_DRIVES_EXT,
-		GFP_KERNEL);
+			kzalloc(sizeof(struct LD_STREAM_DETECT *)
+			* MAX_LOGICAL_DRIVES_EXT,
+			GFP_KERNEL);
 		if (!fusion->stream_detect_by_ld) {
 			dev_err(&instance->pdev->dev,
-					"unable to allocate stream detection for pool of LDs\n");
+				"unable to allocate stream detection for pool of LDs\n");
 			goto fail_get_ld_pd_list;
 		}
 		for (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i) {
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fp.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.h
