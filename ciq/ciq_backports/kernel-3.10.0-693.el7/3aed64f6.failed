pvclock: introduce seqcount-like API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 3aed64f6d341cdb62bb2d6232589fb13448ce063
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3aed64f6.failed

The version field in struct pvclock_vcpu_time_info basically implements
a seqcount.  Wrap it with the usual read_begin and read_retry functions,
and use these APIs instead of peppering the code with smp_rmb()s.
While at it, change it to the more pedantically correct virt_rmb().

With this change, __pvclock_read_cycles can be simplified noticeably.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3aed64f6d341cdb62bb2d6232589fb13448ce063)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/vdso/vclock_gettime.c
#	arch/x86/include/asm/pvclock.h
#	arch/x86/kernel/pvclock.c
diff --cc arch/x86/include/asm/pvclock.h
index 2a0809bda147,d019f0cc80ec..000000000000
--- a/arch/x86/include/asm/pvclock.h
+++ b/arch/x86/include/asm/pvclock.h
@@@ -60,21 -87,12 +78,27 @@@ static inline u64 pvclock_scale_delta(u
  }
  
  static __always_inline
- unsigned __pvclock_read_cycles(const struct pvclock_vcpu_time_info *src,
- 			       cycle_t *cycles, u8 *flags)
+ cycle_t __pvclock_read_cycles(const struct pvclock_vcpu_time_info *src)
  {
++<<<<<<< HEAD
 +	unsigned version;
 +	cycle_t offset;
 +	u64 delta;
 +
 +	version = src->version;
 +
 +	delta = rdtsc_ordered() - src->tsc_timestamp;
 +	offset = pvclock_scale_delta(delta, src->tsc_to_system_mul,
 +				   src->tsc_shift);
 +	*cycles = src->system_time + offset;
 +	*flags = src->flags;
 +	return version;
++=======
+ 	u64 delta = rdtsc_ordered() - src->tsc_timestamp;
+ 	cycle_t offset = pvclock_scale_delta(delta, src->tsc_to_system_mul,
+ 					     src->tsc_shift);
+ 	return src->system_time + offset;
++>>>>>>> 3aed64f6d341 (pvclock: introduce seqcount-like API)
  }
  
  struct pvclock_vsyscall_time_info {
diff --cc arch/x86/kernel/pvclock.c
index 2f355d229a58,3599404e3089..000000000000
--- a/arch/x86/kernel/pvclock.c
+++ b/arch/x86/kernel/pvclock.c
@@@ -65,8 -64,9 +65,14 @@@ u8 pvclock_read_flags(struct pvclock_vc
  	u8 flags;
  
  	do {
++<<<<<<< HEAD
 +		version = __pvclock_read_cycles(src, &ret, &flags);
 +	} while ((src->version & 1) || version != src->version);
++=======
+ 		version = pvclock_read_begin(src);
+ 		flags = src->flags;
+ 	} while (pvclock_read_retry(src, version));
++>>>>>>> 3aed64f6d341 (pvclock: introduce seqcount-like API)
  
  	return flags & valid_flags;
  }
@@@ -79,8 -79,10 +85,15 @@@ cycle_t pvclock_clocksource_read(struc
  	u8 flags;
  
  	do {
++<<<<<<< HEAD
 +		version = __pvclock_read_cycles(src, &ret, &flags);
 +	} while ((src->version & 1) || version != src->version);
++=======
+ 		version = pvclock_read_begin(src);
+ 		ret = __pvclock_read_cycles(src);
+ 		flags = src->flags;
+ 	} while (pvclock_read_retry(src, version));
++>>>>>>> 3aed64f6d341 (pvclock: introduce seqcount-like API)
  
  	if (unlikely((flags & PVCLOCK_GUEST_STOPPED) != 0)) {
  		src->flags &= ~PVCLOCK_GUEST_STOPPED;
* Unmerged path arch/x86/entry/vdso/vclock_gettime.c
* Unmerged path arch/x86/entry/vdso/vclock_gettime.c
* Unmerged path arch/x86/include/asm/pvclock.h
* Unmerged path arch/x86/kernel/pvclock.c
