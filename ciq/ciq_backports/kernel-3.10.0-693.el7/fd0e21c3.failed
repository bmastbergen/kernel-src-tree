virtio_balloon: Allow to resize and update the balloon stats in parallel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Petr Mladek <pmladek@suse.com>
commit fd0e21c31e1e6383af978239d07ced6e4e5d82c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fd0e21c3.failed

The virtio balloon statistics are not updated when the balloon
is being resized. But it seems that both tasks could be done
in parallel.

stats_handle_request() updates the statistics in the balloon
structure and then communicates with the host.

update_balloon_stats() calls all_vm_events() that just reads
some per-CPU variables. The values might change during and
after the call but it is expected and happens even without
this patch.

update_balloon_stats() also calls si_meminfo(). It is a bit
more complex function. It too just reads some variables and
looks lock-less safe. In each case, it seems to be called
lock-less on several similar locations, e.g. from post_status()
in dm_thread_func(), or from vmballoon_send_get_target().

The communication with the host is done via a separate virtqueue,
see vb->stats_vq vs. vb->inflate_vq and vb->deflate_vq. Therefore
it could be used in parallel with fill_balloon() and leak_balloon().

This patch splits the existing work into two pieces. One is for
updating the balloon stats. The other is for resizing of the balloon.
It seems that they can be proceed in parallel without any
extra locking.

	Signed-off-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit fd0e21c31e1e6383af978239d07ced6e4e5d82c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/virtio/virtio_balloon.c
diff --cc drivers/virtio/virtio_balloon.c
index a9ca908865d3,9057cc768ca5..000000000000
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@@ -49,11 -48,13 +49,17 @@@ struct virtio_balloon 
  	struct virtio_device *vdev;
  	struct virtqueue *inflate_vq, *deflate_vq, *stats_vq;
  
++<<<<<<< HEAD
 +	/* Where the ballooning thread waits for config to change. */
 +	wait_queue_head_t config_change;
++=======
+ 	/* The balloon servicing is delegated to a freezable workqueue. */
+ 	struct work_struct update_balloon_stats_work;
+ 	struct work_struct update_balloon_size_work;
++>>>>>>> fd0e21c31e1e (virtio_balloon: Allow to resize and update the balloon stats in parallel)
  
 -	/* Prevent updating balloon when it is being canceled. */
 -	spinlock_t stop_update_lock;
 -	bool stop_update;
 +	/* The thread servicing the balloon. */
 +	struct task_struct *thread;
  
  	/* Waiting for host to ack the pages we released. */
  	wait_queue_head_t acked;
@@@ -73,10 -74,9 +79,9 @@@
  
  	/* The array of pfns we tell the Host about. */
  	unsigned int num_pfns;
 -	u32 pfns[VIRTIO_BALLOON_ARRAY_PFNS_MAX];
 +	__virtio32 pfns[VIRTIO_BALLOON_ARRAY_PFNS_MAX];
  
  	/* Memory statistics */
- 	int need_stats_update;
  	struct virtio_balloon_stat stats[VIRTIO_BALLOON_S_NR];
  
  	/* To register callback in oom notifier call chain */
@@@ -123,10 -123,10 +128,11 @@@ static void tell_host(struct virtio_bal
  
  	/* When host has read buffer, this completes via balloon_ack */
  	wait_event(vb->acked, virtqueue_get_buf(vq, &len));
+ 
  }
  
 -static void set_page_pfns(u32 pfns[], struct page *page)
 +static void set_page_pfns(struct virtio_balloon *vb,
 +			  __virtio32 pfns[], struct page *page)
  {
  	unsigned int i;
  
@@@ -268,8 -263,10 +274,15 @@@ static void stats_request(struct virtqu
  {
  	struct virtio_balloon *vb = vq->vdev->priv;
  
++<<<<<<< HEAD
 +	vb->need_stats_update = 1;
 +	wake_up(&vb->config_change);
++=======
+ 	spin_lock(&vb->stop_update_lock);
+ 	if (!vb->stop_update)
+ 		queue_work(system_freezable_wq, &vb->update_balloon_stats_work);
+ 	spin_unlock(&vb->stop_update_lock);
++>>>>>>> fd0e21c31e1e (virtio_balloon: Allow to resize and update the balloon stats in parallel)
  }
  
  static void stats_handle_request(struct virtio_balloon *vb)
@@@ -292,8 -288,12 +304,15 @@@
  static void virtballoon_changed(struct virtio_device *vdev)
  {
  	struct virtio_balloon *vb = vdev->priv;
 -	unsigned long flags;
  
++<<<<<<< HEAD
 +	wake_up(&vb->config_change);
++=======
+ 	spin_lock_irqsave(&vb->stop_update_lock, flags);
+ 	if (!vb->stop_update)
+ 		queue_work(system_freezable_wq, &vb->update_balloon_size_work);
+ 	spin_unlock_irqrestore(&vb->stop_update_lock, flags);
++>>>>>>> fd0e21c31e1e (virtio_balloon: Allow to resize and update the balloon stats in parallel)
  }
  
  static inline s64 towards_target(struct virtio_balloon *vb)
@@@ -356,35 -356,32 +375,63 @@@ static int virtballoon_oom_notify(struc
  	return NOTIFY_OK;
  }
  
++<<<<<<< HEAD
 +static int balloon(void *_vballoon)
++=======
+ static void update_balloon_stats_func(struct work_struct *work)
+ {
+ 	struct virtio_balloon *vb;
+ 
+ 	vb = container_of(work, struct virtio_balloon,
+ 			  update_balloon_stats_work);
+ 	stats_handle_request(vb);
+ }
+ 
+ static void update_balloon_size_func(struct work_struct *work)
++>>>>>>> fd0e21c31e1e (virtio_balloon: Allow to resize and update the balloon stats in parallel)
  {
 -	struct virtio_balloon *vb;
 -	s64 diff;
 +	struct virtio_balloon *vb = _vballoon;
 +
++<<<<<<< HEAD
 +	set_freezable();
 +	while (!kthread_should_stop()) {
 +		s64 diff;
 +
 +		try_to_freeze();
 +		wait_event_interruptible(vb->config_change,
 +					 (diff = towards_target(vb)) != 0
 +					 || vb->need_stats_update
 +					 || kthread_should_stop()
 +					 || freezing(current));
 +		if (vb->need_stats_update)
 +			stats_handle_request(vb);
 +		if (diff > 0)
 +			fill_balloon(vb, diff);
 +		else if (diff < 0)
 +			leak_balloon(vb, -diff);
 +		update_balloon_size(vb);
  
 +		/*
 +		 * For large balloon changes, we could spend a lot of time
 +		 * and always have work to do.  Be nice if preempt disabled.
 +		 */
 +		cond_resched();
 +	}
 +	return 0;
++=======
+ 	vb = container_of(work, struct virtio_balloon,
+ 			  update_balloon_size_work);
+ 	diff = towards_target(vb);
+ 
+ 	if (diff > 0)
+ 		diff -= fill_balloon(vb, diff);
+ 	else if (diff < 0)
+ 		diff += leak_balloon(vb, -diff);
+ 	update_balloon_size(vb);
+ 
+ 	if (diff)
+ 		queue_work(system_freezable_wq, work);
++>>>>>>> fd0e21c31e1e (virtio_balloon: Allow to resize and update the balloon stats in parallel)
  }
  
  static int init_vqs(struct virtio_balloon *vb)
@@@ -502,12 -499,14 +549,18 @@@ static int virtballoon_probe(struct vir
  		goto out;
  	}
  
++<<<<<<< HEAD
++=======
+ 	INIT_WORK(&vb->update_balloon_stats_work, update_balloon_stats_func);
+ 	INIT_WORK(&vb->update_balloon_size_work, update_balloon_size_func);
+ 	spin_lock_init(&vb->stop_update_lock);
+ 	vb->stop_update = false;
++>>>>>>> fd0e21c31e1e (virtio_balloon: Allow to resize and update the balloon stats in parallel)
  	vb->num_pages = 0;
  	mutex_init(&vb->balloon_lock);
 +	init_waitqueue_head(&vb->config_change);
  	init_waitqueue_head(&vb->acked);
  	vb->vdev = vdev;
- 	vb->need_stats_update = 0;
  
  	balloon_devinfo_init(&vb->vb_dev_info);
  #ifdef CONFIG_BALLOON_COMPACTION
@@@ -562,7 -553,13 +615,17 @@@ static void virtballoon_remove(struct v
  	struct virtio_balloon *vb = vdev->priv;
  
  	unregister_oom_notifier(&vb->nb);
++<<<<<<< HEAD
 +	kthread_stop(vb->thread);
++=======
+ 
+ 	spin_lock_irq(&vb->stop_update_lock);
+ 	vb->stop_update = true;
+ 	spin_unlock_irq(&vb->stop_update_lock);
+ 	cancel_work_sync(&vb->update_balloon_size_work);
+ 	cancel_work_sync(&vb->update_balloon_stats_work);
+ 
++>>>>>>> fd0e21c31e1e (virtio_balloon: Allow to resize and update the balloon stats in parallel)
  	remove_common(vb);
  	kfree(vb);
  }
* Unmerged path drivers/virtio/virtio_balloon.c
