ACPICA: Tables: Add acpi_install_table() API for early table installation.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [acpi] acpica: tables: Add acpi_install_table() API for early table installation (Prarit Bhargava) [1425180]
Rebuild_FUZZ: 99.32%
commit-author Lv Zheng <lv.zheng@intel.com>
commit caf4a15c5f930aae41951b4916289e3e59dda8eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/caf4a15c.failed

This patch adds a new API - acpi_install_table(). OSPMs can use this API
to install tables during early boot stage.  Lv Zheng.

References: https://lkml.org/lkml/2014/2/28/372
	Cc: Thomas Renninger <trenn@suse.de>
	Signed-off-by: Lv Zheng <lv.zheng@intel.com>
	Signed-off-by: Bob Moore <robert.moore@intel.com>
[rjw: Subject]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit caf4a15c5f930aae41951b4916289e3e59dda8eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpica/actables.h
#	drivers/acpi/acpica/exconfig.c
#	drivers/acpi/acpica/tbinstal.c
#	drivers/acpi/acpica/tbutils.c
#	drivers/acpi/acpica/tbxfload.c
diff --cc drivers/acpi/acpica/actables.h
index 917315ec21dd,3d20a96f6f09..000000000000
--- a/drivers/acpi/acpica/actables.h
+++ b/drivers/acpi/acpica/actables.h
@@@ -70,15 -72,28 +70,35 @@@ acpi_tb_find_table(char *signature
   */
  acpi_status acpi_tb_resize_root_table_list(void);
  
 -acpi_status acpi_tb_validate_table(struct acpi_table_desc *table_desc);
 +acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc);
  
 -void acpi_tb_invalidate_table(struct acpi_table_desc *table_desc);
 +struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 +						 *table_header,
 +						 struct acpi_table_desc
 +						 *table_desc);
  
  acpi_status
++<<<<<<< HEAD
 +acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index);
++=======
+ acpi_tb_verify_table(struct acpi_table_desc *table_desc, char *signature);
+ 
+ void acpi_tb_override_table(struct acpi_table_desc *old_table_desc);
+ 
+ acpi_status
+ acpi_tb_acquire_table(struct acpi_table_desc *table_desc,
+ 		      struct acpi_table_header **table_ptr,
+ 		      u32 *table_length, u8 *table_flags);
+ 
+ void
+ acpi_tb_release_table(struct acpi_table_header *table,
+ 		      u32 table_length, u8 table_flags);
+ 
+ acpi_status
+ acpi_tb_install_non_fixed_table(acpi_physical_address address,
+ 				u8 flags,
+ 				u8 reload, u8 override, u32 *table_index);
++>>>>>>> caf4a15c5f93 (ACPICA: Tables: Add acpi_install_table() API for early table installation.)
  
  acpi_status
  acpi_tb_store_table(acpi_physical_address address,
@@@ -122,8 -137,18 +142,23 @@@ void acpi_tb_check_dsdt_header(void)
  struct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index);
  
  void
++<<<<<<< HEAD
 +acpi_tb_install_table(acpi_physical_address address,
 +		      char *signature, u32 table_index);
++=======
+ acpi_tb_install_table(struct acpi_table_desc *table_desc,
+ 		      acpi_physical_address address,
+ 		      u8 flags, struct acpi_table_header *table);
+ 
+ void
+ acpi_tb_install_and_override_table(u32 table_index,
+ 				   struct acpi_table_desc *new_table_desc,
+ 				   u8 override);
+ 
+ acpi_status
+ acpi_tb_install_fixed_table(acpi_physical_address address,
+ 			    char *signature, u32 table_index);
++>>>>>>> caf4a15c5f93 (ACPICA: Tables: Add acpi_install_table() API for early table installation.)
  
  acpi_status acpi_tb_parse_root_table(acpi_physical_address rsdp_address);
  
diff --cc drivers/acpi/acpica/exconfig.c
index 5bff332aa0f0,815003d81b5c..000000000000
--- a/drivers/acpi/acpica/exconfig.c
+++ b/drivers/acpi/acpica/exconfig.c
@@@ -484,22 -478,14 +484,31 @@@ acpi_ex_load_op(union acpi_operand_obje
  		return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
  	}
  
 +	/* Validate table checksum (will not get validated in tb_add_table) */
 +
 +	status = acpi_tb_verify_checksum(table_desc.pointer, length);
 +	if (ACPI_FAILURE(status)) {
 +		ACPI_FREE(table_desc.pointer);
 +		return_ACPI_STATUS(status);
 +	}
 +
 +	/* Complete the table descriptor */
 +
 +	table_desc.length = length;
 +	table_desc.flags = ACPI_TABLE_ORIGIN_ALLOCATED;
 +
  	/* Install the new table into the local data structures */
  
++<<<<<<< HEAD
 +	status = acpi_tb_add_table(&table_desc, &table_index);
++=======
+ 	ACPI_INFO((AE_INFO, "Dynamic OEM Table Load:"));
+ 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+ 	status = acpi_tb_install_non_fixed_table(ACPI_PTR_TO_PHYSADDR(table),
+ 						 ACPI_TABLE_ORIGIN_INTERN_VIRTUAL,
+ 						 TRUE, TRUE, &table_index);
+ 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
++>>>>>>> caf4a15c5f93 (ACPICA: Tables: Add acpi_install_table() API for early table installation.)
  	if (ACPI_FAILURE(status)) {
  
  		/* Delete allocated table buffer */
diff --cc drivers/acpi/acpica/tbinstal.c
index 4024bfc5fa21,9835213269e6..000000000000
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@@ -112,9 -278,280 +112,284 @@@ acpi_status acpi_tb_verify_table(struc
  
  /*******************************************************************************
   *
 - * FUNCTION:    acpi_tb_install_table
 + * FUNCTION:    acpi_tb_add_table
   *
++<<<<<<< HEAD
 + * PARAMETERS:  table_desc          - Table descriptor
++=======
+  * PARAMETERS:  table_desc              - Table descriptor
+  *              address                 - Physical address of the table
+  *              flags                   - Allocation flags of the table
+  *              table                   - Pointer to the table
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Install an ACPI table into the global data structure.
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_tb_install_table(struct acpi_table_desc *table_desc,
+ 		      acpi_physical_address address,
+ 		      u8 flags, struct acpi_table_header *table)
+ {
+ 	/*
+ 	 * Initialize the table entry. Set the pointer to NULL, since the
+ 	 * table is not fully mapped at this time.
+ 	 */
+ 	ACPI_MEMSET(table_desc, 0, sizeof(struct acpi_table_desc));
+ 	table_desc->address = address;
+ 	table_desc->length = table->length;
+ 	table_desc->flags = flags;
+ 	ACPI_MOVE_32_TO_32(table_desc->signature.ascii, table->signature);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_acquire_temporal_table
+  *
+  * PARAMETERS:  table_desc          - Table descriptor to be acquired
+  *              address             - Address of the table
+  *              flags               - Allocation flags of the table
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: This function validates the table header to obtain the length
+  *              of a table and fills the table descriptor to make its state as
+  *              "INSTALLED".  Such table descriptor is only used for verified
+  *              installation.
+  *
+  ******************************************************************************/
+ 
+ static acpi_status
+ acpi_tb_acquire_temporal_table(struct acpi_table_desc *table_desc,
+ 			       acpi_physical_address address, u8 flags)
+ {
+ 	struct acpi_table_header *table_header;
+ 
+ 	switch (flags & ACPI_TABLE_ORIGIN_MASK) {
+ 	case ACPI_TABLE_ORIGIN_INTERN_PHYSICAL:
+ 
+ 		/* Try to obtain the length of the table */
+ 
+ 		table_header =
+ 		    acpi_os_map_memory(address,
+ 				       sizeof(struct acpi_table_header));
+ 		if (!table_header) {
+ 			return (AE_NO_MEMORY);
+ 		}
+ 		acpi_tb_install_table(table_desc, address, flags, table_header);
+ 		acpi_os_unmap_memory(table_header,
+ 				     sizeof(struct acpi_table_header));
+ 		return (AE_OK);
+ 
+ 	case ACPI_TABLE_ORIGIN_INTERN_VIRTUAL:
+ 	case ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL:
+ 
+ 		table_header = ACPI_CAST_PTR(struct acpi_table_header, address);
+ 		if (!table_header) {
+ 			return (AE_NO_MEMORY);
+ 		}
+ 		acpi_tb_install_table(table_desc, address, flags, table_header);
+ 		return (AE_OK);
+ 
+ 	default:
+ 
+ 		break;
+ 	}
+ 
+ 	/* Table is not valid yet */
+ 
+ 	return (AE_NO_MEMORY);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_release_temporal_table
+  *
+  * PARAMETERS:  table_desc          - Table descriptor to be released
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: The reversal of acpi_tb_acquire_temporal_table().
+  *
+  ******************************************************************************/
+ 
+ static void acpi_tb_release_temporal_table(struct acpi_table_desc *table_desc)
+ {
+ 	/*
+ 	 * Note that the .Address is maintained by the callers of
+ 	 * acpi_tb_acquire_temporal_table(), thus do not invoke acpi_tb_uninstall_table()
+ 	 * where .Address will be freed.
+ 	 */
+ 	acpi_tb_invalidate_table(table_desc);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_install_and_override_table
+  *
+  * PARAMETERS:  table_index             - Index into root table array
+  *              new_table_desc          - New table descriptor to install
+  *              override                - Whether override should be performed
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Install an ACPI table into the global data structure. The
+  *              table override mechanism is called to allow the host
+  *              OS to replace any table before it is installed in the root
+  *              table array.
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_tb_install_and_override_table(u32 table_index,
+ 				   struct acpi_table_desc *new_table_desc,
+ 				   u8 override)
+ {
+ 	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * ACPI Table Override:
+ 	 *
+ 	 * Before we install the table, let the host OS override it with a new
+ 	 * one if desired. Any table within the RSDT/XSDT can be replaced,
+ 	 * including the DSDT which is pointed to by the FADT.
+ 	 */
+ 	if (override) {
+ 		acpi_tb_override_table(new_table_desc);
+ 	}
+ 
+ 	acpi_tb_install_table(&acpi_gbl_root_table_list.tables[table_index],
+ 			      new_table_desc->address, new_table_desc->flags,
+ 			      new_table_desc->pointer);
+ 
+ 	acpi_tb_print_table_header(new_table_desc->address,
+ 				   new_table_desc->pointer);
+ 
+ 	/* Set the global integer width (based upon revision of the DSDT) */
+ 
+ 	if (table_index == ACPI_TABLE_INDEX_DSDT) {
+ 		acpi_ut_set_integer_width(new_table_desc->pointer->revision);
+ 	}
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_install_fixed_table
+  *
+  * PARAMETERS:  address                 - Physical address of DSDT or FACS
+  *              signature               - Table signature, NULL if no need to
+  *                                        match
+  *              table_index             - Index into root table array
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Install a fixed ACPI table (DSDT/FACS) into the global data
+  *              structure.
+  *
+  ******************************************************************************/
+ 
+ acpi_status
+ acpi_tb_install_fixed_table(acpi_physical_address address,
+ 			    char *signature, u32 table_index)
+ {
+ 	struct acpi_table_desc new_table_desc;
+ 	acpi_status status;
+ 
+ 	ACPI_FUNCTION_TRACE(tb_install_fixed_table);
+ 
+ 	if (!address) {
+ 		ACPI_ERROR((AE_INFO,
+ 			    "Null physical address for ACPI table [%s]",
+ 			    signature));
+ 		return (AE_NO_MEMORY);
+ 	}
+ 
+ 	/* Fill a table descriptor for validation */
+ 
+ 	status = acpi_tb_acquire_temporal_table(&new_table_desc, address,
+ 						ACPI_TABLE_ORIGIN_INTERN_PHYSICAL);
+ 	if (ACPI_FAILURE(status)) {
+ 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
+ 			    ACPI_CAST_PTR(void, address)));
+ 		return_ACPI_STATUS(status);
+ 	}
+ 
+ 	/* Validate and verify a table before installation */
+ 
+ 	status = acpi_tb_verify_table(&new_table_desc, signature);
+ 	if (ACPI_FAILURE(status)) {
+ 		goto release_and_exit;
+ 	}
+ 
+ 	acpi_tb_install_and_override_table(table_index, &new_table_desc, TRUE);
+ 
+ release_and_exit:
+ 
+ 	/* Release the temporal table descriptor */
+ 
+ 	acpi_tb_release_temporal_table(&new_table_desc);
+ 	return_ACPI_STATUS(status);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_is_equivalent_table
+  *
+  * PARAMETERS:  table_desc          - Table 1 descriptor to be compared
+  *              table_index         - Index of table 2 to be compared
+  *
+  * RETURN:      TRUE if 2 tables are equivalent
+  *
+  * DESCRIPTION: This function is called to compare a table with what have
+  *              already been installed in the root table list.
+  *
+  ******************************************************************************/
+ 
+ static u8
+ acpi_tb_is_equivalent_table(struct acpi_table_desc *table_desc, u32 table_index)
+ {
+ 	acpi_status status = AE_OK;
+ 	u8 is_equivalent;
+ 	struct acpi_table_header *table;
+ 	u32 table_length;
+ 	u8 table_flags;
+ 
+ 	status =
+ 	    acpi_tb_acquire_table(&acpi_gbl_root_table_list.tables[table_index],
+ 				  &table, &table_length, &table_flags);
+ 	if (ACPI_FAILURE(status)) {
+ 		return (FALSE);
+ 	}
+ 
+ 	/*
+ 	 * Check for a table match on the entire table length,
+ 	 * not just the header.
+ 	 */
+ 	is_equivalent = (u8)((table_desc->length != table_length ||
+ 			      ACPI_MEMCMP(table_desc->pointer, table,
+ 					  table_length)) ? FALSE : TRUE);
+ 
+ 	/* Release the acquired table */
+ 
+ 	acpi_tb_release_table(table, table_length, table_flags);
+ 
+ 	return (is_equivalent);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_tb_install_non_fixed_table
+  *
+  * PARAMETERS:  address             - Address of the table (might be a virtual
+  *                                    address depending on the table_flags)
+  *              flags               - Flags for the table
+  *              reload              - Whether reload should be performed
+  *              override            - Whether override should be performed
++>>>>>>> caf4a15c5f93 (ACPICA: Tables: Add acpi_install_table() API for early table installation.)
   *              table_index         - Where the table index is returned
   *
   * RETURN:      Status
@@@ -126,7 -566,9 +401,13 @@@
   ******************************************************************************/
  
  acpi_status
++<<<<<<< HEAD
 +acpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)
++=======
+ acpi_tb_install_non_fixed_table(acpi_physical_address address,
+ 				u8 flags,
+ 				u8 reload, u8 override, u32 *table_index)
++>>>>>>> caf4a15c5f93 (ACPICA: Tables: Add acpi_install_table() API for early table installation.)
  {
  	u32 i;
  	acpi_status status = AE_OK;
@@@ -232,28 -686,20 +513,33 @@@
  		}
  	}
  
 +	/*
 +	 * ACPI Table Override:
 +	 * Allow the host to override dynamically loaded tables.
 +	 * NOTE: the table is fully mapped at this point, and the mapping will
 +	 * be deleted by tb_table_override if the table is actually overridden.
 +	 */
 +	(void)acpi_tb_table_override(table_desc->pointer, table_desc);
 +
  	/* Add the table to the global root table list */
  
 -	status = acpi_tb_acquire_root_table_entry(&i);
 +	status = acpi_tb_store_table(table_desc->address, table_desc->pointer,
 +				     table_desc->length, table_desc->flags,
 +				     table_index);
  	if (ACPI_FAILURE(status)) {
 -		goto release_and_exit;
 +		goto release;
  	}
++<<<<<<< HEAD
++=======
+ 	*table_index = i;
+ 	acpi_tb_install_and_override_table(i, &new_table_desc, override);
++>>>>>>> caf4a15c5f93 (ACPICA: Tables: Add acpi_install_table() API for early table installation.)
  
 -release_and_exit:
 -
 -	/* Release the temporal table descriptor */
 +      print_header:
 +	acpi_tb_print_table_header(table_desc->address, table_desc->pointer);
  
 -	acpi_tb_release_temporal_table(&new_table_desc);
 +      release:
 +	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
  	return_ACPI_STATUS(status);
  }
  
diff --cc drivers/acpi/acpica/tbutils.c
index 61ffb069ecd5,aa11949815df..000000000000
--- a/drivers/acpi/acpica/tbutils.c
+++ b/drivers/acpi/acpica/tbutils.c
@@@ -564,12 -469,21 +564,28 @@@ acpi_tb_parse_root_table(acpi_physical_
  
  		/* Get the table physical address (32-bit for RSDT, 64-bit for XSDT) */
  
++<<<<<<< HEAD
 +		acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.
 +						current_table_count].address =
 +		    acpi_tb_get_root_table_entry(table_entry, table_entry_size);
++=======
+ 		status =
+ 		    acpi_tb_install_non_fixed_table(acpi_tb_get_root_table_entry
+ 						    (table_entry,
+ 						     table_entry_size),
+ 						    ACPI_TABLE_ORIGIN_INTERN_PHYSICAL,
+ 						    FALSE, TRUE, &table_index);
+ 
+ 		if (ACPI_SUCCESS(status) &&
+ 		    ACPI_COMPARE_NAME(&acpi_gbl_root_table_list.
+ 				      tables[table_index].signature,
+ 				      ACPI_SIG_FADT)) {
+ 			acpi_tb_parse_fadt(table_index);
+ 		}
++>>>>>>> caf4a15c5f93 (ACPICA: Tables: Add acpi_install_table() API for early table installation.)
  
  		table_entry += table_entry_size;
 +		acpi_gbl_root_table_list.current_table_count++;
  	}
  
  	/*
diff --cc drivers/acpi/acpica/tbxfload.c
index 2620dbe96cfa,529f633efa55..000000000000
--- a/drivers/acpi/acpica/tbxfload.c
+++ b/drivers/acpi/acpica/tbxfload.c
@@@ -255,7 -271,22 +293,26 @@@ acpi_status acpi_load_table(struct acpi
  	/* Install the table and load it into the namespace */
  
  	ACPI_INFO((AE_INFO, "Host-directed Dynamic ACPI Table Load:"));
++<<<<<<< HEAD
 +	status = acpi_tb_add_table(&table_desc, &table_index);
++=======
+ 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
+ 	status = acpi_tb_install_non_fixed_table(ACPI_PTR_TO_PHYSADDR(table),
+ 						 ACPI_TABLE_ORIGIN_EXTERN_VIRTUAL,
+ 						 TRUE, FALSE, &table_index);
+ 	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
+ 	if (ACPI_FAILURE(status)) {
+ 		goto unlock_and_exit;
+ 	}
+ 
+ 	/*
+ 	 * Note: Now table is "INSTALLED", it must be validated before
+ 	 * using.
+ 	 */
+ 	status =
+ 	    acpi_tb_validate_table(&acpi_gbl_root_table_list.
+ 				   tables[table_index]);
++>>>>>>> caf4a15c5f93 (ACPICA: Tables: Add acpi_install_table() API for early table installation.)
  	if (ACPI_FAILURE(status)) {
  		goto unlock_and_exit;
  	}
* Unmerged path drivers/acpi/acpica/actables.h
* Unmerged path drivers/acpi/acpica/exconfig.c
* Unmerged path drivers/acpi/acpica/tbinstal.c
* Unmerged path drivers/acpi/acpica/tbutils.c
* Unmerged path drivers/acpi/acpica/tbxfload.c
diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h
index 4f88d18b72e7..9f0f63bc3a31 100644
--- a/include/acpi/acpixf.h
+++ b/include/acpi/acpixf.h
@@ -159,6 +159,9 @@ acpi_decode_pld_buffer(u8 *in_buffer,
 /*
  * ACPI table load/unload interfaces
  */
+acpi_status __init
+acpi_install_table(acpi_physical_address address, u8 physical);
+
 acpi_status acpi_load_table(struct acpi_table_header *table);
 
 acpi_status acpi_unload_parent_table(acpi_handle object);
