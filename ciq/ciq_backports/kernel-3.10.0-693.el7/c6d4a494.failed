perf trace: Add --max-stack knob

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit c6d4a494a207a336b45e52a44550150964daf1ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c6d4a494.failed

Similar to the one in the other tools (report, script, top).

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Milian Wolff <milian.wolff@kdab.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-lh7kk5a5t3erwxw31ah0cgar@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit c6d4a494a207a336b45e52a44550150964daf1ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-trace.c
diff --cc tools/perf/builtin-trace.c
index 5c663a0da608,39a158923acf..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -1869,6 -1880,29 +1871,32 @@@ out_put
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int trace__fprintf_callchain(struct trace *trace, struct perf_evsel *evsel,
+ 				    struct perf_sample *sample)
+ {
+ 	struct addr_location al;
+ 	/* TODO: user-configurable print_opts */
+ 	const unsigned int print_opts = EVSEL__PRINT_SYM |
+ 				        EVSEL__PRINT_DSO |
+ 				        EVSEL__PRINT_UNKNOWN_AS_ADDR;
+ 
+ 	if (sample->callchain == NULL)
+ 		return 0;
+ 
+ 	if (machine__resolve(trace->host, &al, sample) < 0 ||
+ 	    thread__resolve_callchain(al.thread, &callchain_cursor, evsel,
+ 				      sample, NULL, NULL, trace->max_stack)) {
+ 		pr_err("Problem processing %s callchain, skipping...\n",
+ 			perf_evsel__name(evsel));
+ 		return 0;
+ 	}
+ 
+ 	return sample__fprintf_callchain(sample, 38, print_opts, &callchain_cursor, trace->output);
+ }
+ 
++>>>>>>> c6d4a494a207 (perf trace: Add --max-stack knob)
  static int trace__sys_exit(struct trace *trace, struct perf_evsel *evsel,
  			   union perf_event *event __maybe_unused,
  			   struct perf_sample *sample)
@@@ -2923,6 -3030,8 +2951,11 @@@ int cmd_trace(int argc, const char **ar
  		.output = stderr,
  		.show_comm = true,
  		.trace_syscalls = true,
++<<<<<<< HEAD
++=======
+ 		.kernel_syscallchains = false,
+ 		.max_stack = PERF_MAX_STACK_DEPTH,
++>>>>>>> c6d4a494a207 (perf trace: Add --max-stack knob)
  	};
  	const char *output_name = NULL;
  	const char *ev_qualifier_str = NULL;
@@@ -2968,6 -3077,15 +3001,18 @@@
  		     "Trace pagefaults", parse_pagefaults, "maj"),
  	OPT_BOOLEAN(0, "syscalls", &trace.trace_syscalls, "Trace syscalls"),
  	OPT_BOOLEAN('f', "force", &trace.force, "don't complain, do it"),
++<<<<<<< HEAD
++=======
+ 	OPT_CALLBACK(0, "call-graph", &trace.opts,
+ 		     "record_mode[,record_size]", record_callchain_help,
+ 		     &record_parse_callchain_opt),
+ 	OPT_BOOLEAN(0, "kernel-syscall-graph", &trace.kernel_syscallchains,
+ 		    "Show the kernel callchains on the syscall exit path"),
+ 	OPT_UINTEGER(0, "max-stack", &trace.max_stack,
+ 		     "Set the maximum stack depth when parsing the callchain, "
+ 		     "anything beyond the specified depth will be ignored. "
+ 		     "Default: " __stringify(PERF_MAX_STACK_DEPTH)),
++>>>>>>> c6d4a494a207 (perf trace: Add --max-stack knob)
  	OPT_UINTEGER(0, "proc-map-timeout", &trace.opts.proc_map_timeout,
  			"per thread proc mmap processing timeout in ms"),
  	OPT_END()
diff --git a/tools/perf/Documentation/perf-trace.txt b/tools/perf/Documentation/perf-trace.txt
index 13293de8869f..9ce5750c9734 100644
--- a/tools/perf/Documentation/perf-trace.txt
+++ b/tools/perf/Documentation/perf-trace.txt
@@ -120,6 +120,15 @@ the thread executes on the designated CPUs. Default is to monitor all CPUs.
 --event::
 	Trace other events, see 'perf list' for a complete list.
 
+--max-stack::
+        Set the stack depth limit when parsing the callchain, anything
+        beyond the specified depth will be ignored. Note that at this point
+        this is just about the presentation part, i.e. the kernel is still
+        not limiting, the overhead of callchains needs to be set via the
+        knobs in --call-graph dwarf.
+
+        Default: 127
+
 --proc-map-timeout::
 	When processing pre-existing threads /proc/XXX/mmap, it may take a long time,
 	because the file may be huge. A time out is needed in such cases.
* Unmerged path tools/perf/builtin-trace.c
