nohz: Fix buggy tick delay on IRQ storms

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Frederic Weisbecker <fweisbec@gmail.com>
commit f99973e18b65ca1fff8c81532e3132b8f622aea8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f99973e1.failed

When the tick is stopped and we reach the dynticks evaluation code on
IRQ exit, we perform a soft tick restart if we observe an expired timer
from there. It means we program the nearest possible tick but we stay in
dynticks mode (ts->tick_stopped = 1) because we may need to stop the tick
again after that expired timer is handled.

Now this solution works most of the time but if we suffer an IRQ storm
and those interrupts trigger faster than the hardware clockevents min
delay, our tick won't fire until that IRQ storm is finished.

Here is the problem: on IRQ exit we reprog the timer to at least
NOW() + min_clockevents_delay. Another IRQ fires before the tick so we
reschedule again to NOW() + min_clockevents_delay, etc... The tick
is eternally rescheduled min_clockevents_delay ahead.

A solution is to simply remove this soft tick restart. After all
the normal dynticks evaluation path can handle 0 delay just fine. And
by doing that we benefit from the optimization branch which avoids
clock reprogramming if the clockevents deadline hasn't changed since
the last reprog. This fixes our issue because we don't do repetitive
clock reprog that always add hardware min delay.

As a side effect it should even optimize the 0 delay path in general.

Reported-and-tested-by: Octavian Purdila <octavian.purdila@nxp.com>
	Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1496328429-13317-1-git-send-email-fweisbec@gmail.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit f99973e18b65ca1fff8c81532e3132b8f622aea8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/tick-sched.c
diff --cc kernel/time/tick-sched.c
index fdd2f0bbaf27,9d31f1e0067b..000000000000
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@@ -590,13 -713,17 +590,27 @@@ static ktime_t tick_nohz_stop_sched_tic
  	 */
  	delta = next_tick - basemono;
  	if (delta <= (u64)TICK_NSEC) {
++<<<<<<< HEAD
 +		tick.tv64 = 0;
 +
 +		if (!ts->tick_stopped)
 +			goto out;
 +		if (delta == 0) {
 +			/* Tick is stopped, but required now. Enforce it */
 +			tick_nohz_restart(ts, now);
++=======
+ 		/*
+ 		 * Tell the timer code that the base is not idle, i.e. undo
+ 		 * the effect of get_next_timer_interrupt():
+ 		 */
+ 		timer_clear_idle();
+ 		/*
+ 		 * We've not stopped the tick yet, and there's a timer in the
+ 		 * next period, so no point in stopping it either, bail.
+ 		 */
+ 		if (!ts->tick_stopped) {
+ 			tick = 0;
++>>>>>>> f99973e18b65 (nohz: Fix buggy tick delay on IRQ storms)
  			goto out;
  		}
  	}
* Unmerged path kernel/time/tick-sched.c
