net/mlx5e: Register/unregister vport representors on interface attach/detach

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Register/unregister vport representors on interface attach/detach (Jonathan Toppins) [1448565]
Rebuild_FUZZ: 97.30%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 6f08a22c5fb2b9aefb8ecd8496758e7a677c1fde
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6f08a22c.failed

Currently vport representors are added only on driver load and removed on
driver unload.  Apparently we forgot to handle them when we added the
seamless reset flow feature.  This caused to leave the representors
netdevs alive and active with open HW resources on pci shutdown and on
error reset flows.

To overcome this we move their handling to interface attach/detach, so
they would be cleaned up on shutdown and recreated on reset flows.

Fixes: 26e59d8077a3 ("net/mlx5e: Implement mlx5e interface attach/detach callbacks")
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Hadar Hen Zion <hadarh@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6f08a22c5fb2b9aefb8ecd8496758e7a677c1fde)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index ae009c7fda21,c24366868b39..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3120,6 -3926,157 +3120,160 @@@ static void *mlx5e_create_netdev(struc
  
  	mlx5e_set_dev_port_mtu(netdev);
  
++<<<<<<< HEAD
++=======
+ 	if (profile->enable)
+ 		profile->enable(priv);
+ 
+ 	rtnl_lock();
+ 	if (netif_running(netdev))
+ 		mlx5e_open(netdev);
+ 	netif_device_attach(netdev);
+ 	rtnl_unlock();
+ 
+ 	return 0;
+ 
+ err_close_drop_rq:
+ 	mlx5e_close_drop_rq(priv);
+ 
+ err_cleanup_tx:
+ 	profile->cleanup_tx(priv);
+ 
+ out:
+ 	return err;
+ }
+ 
+ static void mlx5e_register_vport_rep(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	int vport;
+ 	u8 mac[ETH_ALEN];
+ 
+ 	if (!MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		return;
+ 
+ 	mlx5_query_nic_vport_mac_address(mdev, 0, mac);
+ 
+ 	for (vport = 1; vport < total_vfs; vport++) {
+ 		struct mlx5_eswitch_rep rep;
+ 
+ 		rep.load = mlx5e_vport_rep_load;
+ 		rep.unload = mlx5e_vport_rep_unload;
+ 		rep.vport = vport;
+ 		ether_addr_copy(rep.hw_id, mac);
+ 		mlx5_eswitch_register_vport_rep(esw, vport, &rep);
+ 	}
+ }
+ 
+ static void mlx5e_unregister_vport_rep(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	int vport;
+ 
+ 	if (!MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		return;
+ 
+ 	for (vport = 1; vport < total_vfs; vport++)
+ 		mlx5_eswitch_unregister_vport_rep(esw, vport);
+ }
+ 
+ void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	const struct mlx5e_profile *profile = priv->profile;
+ 
+ 	set_bit(MLX5E_STATE_DESTROYING, &priv->state);
+ 
+ 	rtnl_lock();
+ 	if (netif_running(netdev))
+ 		mlx5e_close(netdev);
+ 	netif_device_detach(netdev);
+ 	rtnl_unlock();
+ 
+ 	if (profile->disable)
+ 		profile->disable(priv);
+ 	flush_workqueue(priv->wq);
+ 
+ 	mlx5e_destroy_q_counter(priv);
+ 	profile->cleanup_rx(priv);
+ 	mlx5e_close_drop_rq(priv);
+ 	profile->cleanup_tx(priv);
+ 	cancel_delayed_work_sync(&priv->update_stats_work);
+ }
+ 
+ /* mlx5e_attach and mlx5e_detach scope should be only creating/destroying
+  * hardware contexts and to connect it to the current netdev.
+  */
+ static int mlx5e_attach(struct mlx5_core_dev *mdev, void *vpriv)
+ {
+ 	struct mlx5e_priv *priv = vpriv;
+ 	struct net_device *netdev = priv->netdev;
+ 	int err;
+ 
+ 	if (netif_device_present(netdev))
+ 		return 0;
+ 
+ 	err = mlx5e_create_mdev_resources(mdev);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlx5e_attach_netdev(mdev, netdev);
+ 	if (err) {
+ 		mlx5e_destroy_mdev_resources(mdev);
+ 		return err;
+ 	}
+ 
+ 	mlx5e_register_vport_rep(mdev);
+ 	return 0;
+ }
+ 
+ static void mlx5e_detach(struct mlx5_core_dev *mdev, void *vpriv)
+ {
+ 	struct mlx5e_priv *priv = vpriv;
+ 	struct net_device *netdev = priv->netdev;
+ 
+ 	if (!netif_device_present(netdev))
+ 		return;
+ 
+ 	mlx5e_unregister_vport_rep(mdev);
+ 	mlx5e_detach_netdev(mdev, netdev);
+ 	mlx5e_destroy_mdev_resources(mdev);
+ }
+ 
+ static void *mlx5e_add(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	void *ppriv = NULL;
+ 	void *priv;
+ 	int vport;
+ 	int err;
+ 	struct net_device *netdev;
+ 
+ 	err = mlx5e_check_required_hca_cap(mdev);
+ 	if (err)
+ 		return NULL;
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		ppriv = &esw->offloads.vport_reps[0];
+ 
+ 	netdev = mlx5e_create_netdev(mdev, &mlx5e_nic_profile, ppriv);
+ 	if (!netdev) {
+ 		mlx5_core_err(mdev, "mlx5e_create_netdev failed\n");
+ 		goto err_unregister_reps;
+ 	}
+ 
+ 	priv = netdev_priv(netdev);
+ 
+ 	err = mlx5e_attach(mdev, priv);
+ 	if (err) {
+ 		mlx5_core_err(mdev, "mlx5e_attach failed, %d\n", err);
+ 		goto err_destroy_netdev;
+ 	}
+ 
++>>>>>>> 6f08a22c5fb2 (net/mlx5e: Register/unregister vport representors on interface attach/detach)
  	err = register_netdev(netdev);
  	if (err) {
  		mlx5_core_err(mdev, "register_netdev failed, %d\n", err);
@@@ -3178,40 -4098,24 +3332,50 @@@ err_free_netdev
  	return NULL;
  }
  
 -void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv)
 +static void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, void *vpriv)
  {
 -	const struct mlx5e_profile *profile = priv->profile;
 +	struct mlx5e_priv *priv = vpriv;
  	struct net_device *netdev = priv->netdev;
  
 +	set_bit(MLX5E_STATE_DESTROYING, &priv->state);
 +
 +	queue_work(priv->wq, &priv->set_rx_mode_work);
 +	mlx5e_disable_async_events(priv);
 +	flush_workqueue(priv->wq);
 +	if (test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state)) {
 +		netif_device_detach(netdev);
 +		mlx5e_close(netdev);
 +	} else {
 +		unregister_netdev(netdev);
 +	}
 +
 +	mlx5e_vxlan_cleanup(priv);
 +	mlx5e_destroy_q_counter(priv);
 +	mlx5e_destroy_flow_tables(priv);
 +	mlx5e_destroy_tirs(priv);
 +	mlx5e_destroy_rqts(priv);
 +	mlx5e_close_drop_rq(priv);
 +	mlx5e_destroy_tises(priv);
 +	mlx5_core_destroy_mkey(priv->mdev, &priv->umr_mkey);
 +	mlx5_core_destroy_mkey(priv->mdev, &priv->mkey);
 +	mlx5_core_dealloc_transport_domain(priv->mdev, priv->tdn);
 +	mlx5_core_dealloc_pd(priv->mdev, priv->pdn);
 +	mlx5_unmap_free_uar(priv->mdev, &priv->cq_uar);
 +	cancel_delayed_work_sync(&priv->update_stats_work);
  	destroy_workqueue(priv->wq);
 -	if (profile->cleanup)
 -		profile->cleanup(priv);
 -	free_netdev(netdev);
 -}
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state))
 +		free_netdev(netdev);
++=======
+ static void mlx5e_remove(struct mlx5_core_dev *mdev, void *vpriv)
+ {
+ 	struct mlx5e_priv *priv = vpriv;
+ 
+ 	unregister_netdev(priv->netdev);
+ 	mlx5e_detach(mdev, vpriv);
+ 	mlx5e_destroy_netdev(mdev, priv);
++>>>>>>> 6f08a22c5fb2 (net/mlx5e: Register/unregister vport representors on interface attach/detach)
  }
  
  static void *mlx5e_get_netdev(void *vpriv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
