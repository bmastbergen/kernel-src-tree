net/mlx5: SRIOV core code refactoring

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] mlx5: SRIOV core code refactoring (Don Dutile) [1385214 1385330 1417285]
Rebuild_FUZZ: 94.29%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit 6b6adee3dad25bbe568ee24fc843372d02fb425f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6b6adee3.failed

Simplify the code and makes it look modular and symmetric.
Split sriov enable/disable to two levels: device level and pci level.
When user enable/disable sriov (via sriov_configure driver callback) we
will enable/disable both device and pci sriov.
When driver load/unload we will enable/disable (on demand) only device
sriov while keeping the PCI sriov enabled for next driver load.
On internal/pci error, VFs will be kept enabled on PCI and the reset
is done only in device level.

	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6b6adee3dad25bbe568ee24fc843372d02fb425f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/sriov.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/sriov.c
index d6a3f412ba9f,72a8215a2d02..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
@@@ -37,7 -37,14 +37,18 @@@
  #include "eswitch.h"
  #endif
  
++<<<<<<< HEAD
 +static void enable_vfs(struct mlx5_core_dev *dev, int num_vfs)
++=======
+ bool mlx5_sriov_is_enabled(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_core_sriov *sriov = &dev->priv.sriov;
+ 
+ 	return !!sriov->num_vfs;
+ }
+ 
+ static int mlx5_device_enable_sriov(struct mlx5_core_dev *dev, int num_vfs)
++>>>>>>> 6b6adee3dad2 (net/mlx5: SRIOV core code refactoring)
  {
  	struct mlx5_core_sriov *sriov = &dev->priv.sriov;
  	int err;
@@@ -144,47 -175,17 +179,61 @@@ int mlx5_core_sriov_configure(struct pc
  	if (!mlx5_core_is_pf(dev))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	mlx5_core_cleanup_vfs(dev);
 +
 +	if (!num_vfs) {
 +#ifdef CONFIG_MLX5_CORE_EN
 +		mlx5_eswitch_disable_sriov(dev->priv.eswitch);
 +#endif
 +		kfree(sriov->vfs_ctx);
 +		sriov->vfs_ctx = NULL;
 +		if (!pci_vfs_assigned(pdev))
 +			pci_disable_sriov(pdev);
 +		else
 +			pr_info("unloading PF driver while leaving orphan VFs\n");
 +		return 0;
 +	}
 +
 +	err = mlx5_core_sriov_enable(pdev, num_vfs);
 +	if (err) {
 +		dev_warn(&pdev->dev, "mlx5_core_sriov_enable failed %d\n", err);
 +		return err;
 +	}
 +
 +	mlx5_core_init_vfs(dev, num_vfs);
 +#ifdef CONFIG_MLX5_CORE_EN
 +	mlx5_eswitch_enable_sriov(dev->priv.eswitch, num_vfs);
 +#endif
 +
 +	return num_vfs;
 +}
 +
 +static int sync_required(struct pci_dev *pdev)
 +{
 +	struct mlx5_core_dev *dev  = pci_get_drvdata(pdev);
 +	struct mlx5_core_sriov *sriov = &dev->priv.sriov;
 +	int cur_vfs = pci_num_vf(pdev);
 +
 +	if (cur_vfs != sriov->num_vfs) {
 +		pr_info("current VFs %d, registered %d - sync needed\n", cur_vfs, sriov->num_vfs);
 +		return 1;
 +	}
 +
 +	return 0;
++=======
+ 	if (num_vfs && mlx5_lag_is_active(dev)) {
+ 		mlx5_core_warn(dev, "can't turn sriov on while LAG is active");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (num_vfs)
+ 		err = mlx5_sriov_enable(pdev, num_vfs);
+ 	else
+ 		mlx5_sriov_disable(pdev);
+ 
+ 	return err ? err : num_vfs;
++>>>>>>> 6b6adee3dad2 (net/mlx5: SRIOV core code refactoring)
  }
  
  int mlx5_sriov_init(struct mlx5_core_dev *dev)
@@@ -204,30 -203,21 +251,43 @@@
  	if (!sriov->vfs_ctx)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	sriov->enabled_vfs = cur_vfs;
 +
 +	mlx5_core_init_vfs(dev, cur_vfs);
 +#ifdef CONFIG_MLX5_CORE_EN
 +	if (cur_vfs)
 +		mlx5_eswitch_enable_sriov(dev->priv.eswitch, cur_vfs);
 +#endif
 +
 +	enable_vfs(dev, cur_vfs);
 +
 +	return 0;
 +}
 +
 +int mlx5_sriov_cleanup(struct mlx5_core_dev *dev)
 +{
 +	struct pci_dev *pdev = dev->pdev;
 +	int err;
 +
 +	if (!mlx5_core_is_pf(dev))
++=======
+ 	/* If sriov VFs exist in PCI level, enable them in device level */
+ 	if (!sriov->num_vfs)
++>>>>>>> 6b6adee3dad2 (net/mlx5: SRIOV core code refactoring)
  		return 0;
  
- 	err = mlx5_core_sriov_configure(pdev, 0);
- 	if (err)
- 		return err;
- 
+ 	mlx5_device_enable_sriov(dev, sriov->num_vfs);
  	return 0;
  }
+ 
+ void mlx5_sriov_cleanup(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_core_sriov *sriov = &dev->priv.sriov;
+ 
+ 	if (!mlx5_core_is_pf(dev))
+ 		return;
+ 
+ 	mlx5_device_disable_sriov(dev);
+ 	kfree(sriov->vfs_ctx);
+ }
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index e782d0fde09e..659618878089 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -1176,8 +1176,7 @@ out:
 	return 0;
 
 err_sriov:
-	if (mlx5_sriov_cleanup(dev))
-		dev_err(&dev->pdev->dev, "sriov cleanup failed\n");
+	mlx5_sriov_cleanup(dev);
 
 #ifdef CONFIG_MLX5_CORE_EN
 	mlx5_eswitch_cleanup(dev->priv.eswitch);
@@ -1235,19 +1234,14 @@ static int mlx5_unload_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv)
 {
 	int err = 0;
 
-	err = mlx5_sriov_cleanup(dev);
-	if (err) {
-		dev_warn(&dev->pdev->dev, "%s: sriov cleanup failed - abort\n",
-			 __func__);
-		return err;
-	}
-
 	mutex_lock(&dev->intf_state_mutex);
 	if (test_bit(MLX5_INTERFACE_STATE_DOWN, &dev->intf_state)) {
 		dev_warn(&dev->pdev->dev, "%s: interface is down, NOP\n",
 			 __func__);
 		goto out;
 	}
+
+	mlx5_sriov_cleanup(dev);
 	mlx5_unregister_device(dev);
 #ifdef CONFIG_MLX5_CORE_EN
 	mlx5_eswitch_cleanup(dev->priv.eswitch);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index f0d87046af8e..ff626d4d2ee8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -94,6 +94,8 @@ void mlx5_core_event(struct mlx5_core_dev *dev, enum mlx5_dev_event event,
 		     unsigned long param);
 void mlx5_enter_error_state(struct mlx5_core_dev *dev);
 void mlx5_disable_device(struct mlx5_core_dev *dev);
+int mlx5_sriov_init(struct mlx5_core_dev *dev);
+void mlx5_sriov_cleanup(struct mlx5_core_dev *dev);
 int mlx5_core_sriov_configure(struct pci_dev *dev, int num_vfs);
 int mlx5_core_enable_hca(struct mlx5_core_dev *dev, u16 func_id);
 int mlx5_core_disable_hca(struct mlx5_core_dev *dev, u16 func_id);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/sriov.c
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index f24904979fc5..16b215e5a36d 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -781,8 +781,6 @@ void mlx5_pagealloc_init(struct mlx5_core_dev *dev);
 void mlx5_pagealloc_cleanup(struct mlx5_core_dev *dev);
 int mlx5_pagealloc_start(struct mlx5_core_dev *dev);
 void mlx5_pagealloc_stop(struct mlx5_core_dev *dev);
-int mlx5_sriov_init(struct mlx5_core_dev *dev);
-int mlx5_sriov_cleanup(struct mlx5_core_dev *dev);
 void mlx5_core_req_pages_handler(struct mlx5_core_dev *dev, u16 func_id,
 				 s32 npages);
 int mlx5_satisfy_startup_pages(struct mlx5_core_dev *dev, int boot);
