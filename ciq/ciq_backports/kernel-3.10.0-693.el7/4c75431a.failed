net: prevent of emerging cross-namespace symlinks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] prevent of emerging cross-namespace symlinks (Adrian Reber) [1412898]
Rebuild_FUZZ: 94.62%
commit-author Alexander Y. Fomichev <git.user@gmail.com>
commit 4c75431ac3520631f1d9e74aa88407e6374dbbc4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4c75431a.failed

Code manipulating sysfs symlinks on adjacent net_devices(s)
currently doesn't take into account that devices potentially
belong to different namespaces.

This patch trying to fix an issue as follows:
- check for net_ns before creating / deleting symlink.
  for now only netdev_adjacent_rename_links and
  __netdev_adjacent_dev_remove are affected, afaics
  __netdev_adjacent_dev_insert implies both net_devs
  belong to the same namespace.
- Drop all existing symlinks to / from all adj_devs before
  switching namespace and recreate them just after.

	Signed-off-by: Alexander Y. Fomichev <git.user@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4c75431ac3520631f1d9e74aa88407e6374dbbc4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index 0198b4df7270,66738e9d66e4..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -5545,25 -5160,55 +5546,77 @@@ void netdev_upper_dev_unlink(struct net
  }
  EXPORT_SYMBOL(netdev_upper_dev_unlink);
  
++<<<<<<< HEAD
 +/**
 + * netdev_bonding_info_change - Dispatch event about slave change
 + * @dev: device
 + * @netdev_bonding_info: info to dispatch
 + *
 + * Send NETDEV_BONDING_INFO to netdev notifiers with info.
 + * The caller must hold the RTNL lock.
 + */
 +void netdev_bonding_info_change(struct net_device *dev,
 +				struct netdev_bonding_info *bonding_info)
 +{
 +	struct netdev_notifier_bonding_info	info;
 +
 +	memcpy(&info.bonding_info, bonding_info,
 +	       sizeof(struct netdev_bonding_info));
 +	call_netdevice_notifiers_info(NETDEV_BONDING_INFO, dev,
 +				      &info.info);
 +}
 +EXPORT_SYMBOL(netdev_bonding_info_change);
++=======
+ void netdev_adjacent_add_links(struct net_device *dev)
+ {
+ 	struct netdev_adjacent *iter;
+ 
+ 	struct net *net = dev_net(dev);
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.upper, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_add(iter->dev, dev,
+ 					  &iter->dev->adj_list.lower);
+ 		netdev_adjacent_sysfs_add(dev, iter->dev,
+ 					  &dev->adj_list.upper);
+ 	}
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.lower, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_add(iter->dev, dev,
+ 					  &iter->dev->adj_list.upper);
+ 		netdev_adjacent_sysfs_add(dev, iter->dev,
+ 					  &dev->adj_list.lower);
+ 	}
+ }
+ 
+ void netdev_adjacent_del_links(struct net_device *dev)
+ {
+ 	struct netdev_adjacent *iter;
+ 
+ 	struct net *net = dev_net(dev);
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.upper, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_del(iter->dev, dev->name,
+ 					  &iter->dev->adj_list.lower);
+ 		netdev_adjacent_sysfs_del(dev, iter->dev->name,
+ 					  &dev->adj_list.upper);
+ 	}
+ 
+ 	list_for_each_entry(iter, &dev->adj_list.lower, list) {
+ 		if (!net_eq(net,dev_net(iter->dev)))
+ 			continue;
+ 		netdev_adjacent_sysfs_del(iter->dev, dev->name,
+ 					  &iter->dev->adj_list.upper);
+ 		netdev_adjacent_sysfs_del(dev, iter->dev->name,
+ 					  &dev->adj_list.lower);
+ 	}
+ }
++>>>>>>> 4c75431ac352 (net: prevent of emerging cross-namespace symlinks)
  
  void netdev_adjacent_rename_links(struct net_device *dev, char *oldname)
  {
* Unmerged path net/core/dev.c
