ntb: use errata flag set via DID to implement workaround

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] use errata flag set via DID to implement workaround (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 95.33%
commit-author Dave Jiang <dave.jiang@intel.com>
commit 069684e888da73f175da0f10fe26da4f450d8c18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/069684e8.failed

Instead of using a module parameter, we should detect the errata via
PCI DID and then set an appropriate flag. This will be used for additional
errata later on.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit 069684e888da73f175da0f10fe26da4f450d8c18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_hw.c
#	drivers/ntb/ntb_hw.h
diff --cc drivers/ntb/ntb_hw.c
index b250e730a323,53b739df8cd5..000000000000
--- a/drivers/ntb/ntb_hw.c
+++ b/drivers/ntb/ntb_hw.c
@@@ -62,12 -64,8 +62,8 @@@ MODULE_VERSION(NTB_VER)
  MODULE_LICENSE("Dual BSD/GPL");
  MODULE_AUTHOR("Intel Corporation");
  
- static bool xeon_errata_workaround = true;
- module_param(xeon_errata_workaround, bool, 0644);
- MODULE_PARM_DESC(xeon_errata_workaround, "Workaround for the Xeon Errata");
- 
  enum {
 -	NTB_CONN_TRANSPARENT = 0,
 +	NTB_CONN_CLASSIC = 0,
  	NTB_CONN_B2B,
  	NTB_CONN_RP,
  };
@@@ -99,6 -105,65 +95,68 @@@ static const struct pci_device_id ntb_p
  };
  MODULE_DEVICE_TABLE(pci, ntb_pci_tbl);
  
++<<<<<<< HEAD
++=======
+ static int is_ntb_xeon(struct ntb_device *ndev)
+ {
+ 	switch (ndev->pdev->device) {
+ 	case PCI_DEVICE_ID_INTEL_NTB_SS_JSF:
+ 	case PCI_DEVICE_ID_INTEL_NTB_SS_SNB:
+ 	case PCI_DEVICE_ID_INTEL_NTB_SS_IVT:
+ 	case PCI_DEVICE_ID_INTEL_NTB_SS_HSX:
+ 	case PCI_DEVICE_ID_INTEL_NTB_PS_JSF:
+ 	case PCI_DEVICE_ID_INTEL_NTB_PS_SNB:
+ 	case PCI_DEVICE_ID_INTEL_NTB_PS_IVT:
+ 	case PCI_DEVICE_ID_INTEL_NTB_PS_HSX:
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_JSF:
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_SNB:
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_IVT:
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_HSX:
+ 		return 1;
+ 	default:
+ 		return 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int is_ntb_atom(struct ntb_device *ndev)
+ {
+ 	switch (ndev->pdev->device) {
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_BWD:
+ 		return 1;
+ 	default:
+ 		return 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void ntb_set_errata_flags(struct ntb_device *ndev)
+ {
+ 	switch (ndev->pdev->device) {
+ 	/*
+ 	 * this workaround applies to all platform up to IvyBridge
+ 	 * Haswell has splitbar support and use a different workaround
+ 	 */
+ 	case PCI_DEVICE_ID_INTEL_NTB_SS_JSF:
+ 	case PCI_DEVICE_ID_INTEL_NTB_SS_SNB:
+ 	case PCI_DEVICE_ID_INTEL_NTB_SS_IVT:
+ 	case PCI_DEVICE_ID_INTEL_NTB_SS_HSX:
+ 	case PCI_DEVICE_ID_INTEL_NTB_PS_JSF:
+ 	case PCI_DEVICE_ID_INTEL_NTB_PS_SNB:
+ 	case PCI_DEVICE_ID_INTEL_NTB_PS_IVT:
+ 	case PCI_DEVICE_ID_INTEL_NTB_PS_HSX:
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_JSF:
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_SNB:
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_IVT:
+ 	case PCI_DEVICE_ID_INTEL_NTB_B2B_HSX:
+ 		ndev->wa_flags |= WA_SNB_ERR;
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 069684e888da (ntb: use errata flag set via DID to implement workaround)
  /**
   * ntb_register_event_callback() - register event callback
   * @ndev: pointer to ntb_device instance
@@@ -557,23 -722,183 +615,197 @@@ static void bwd_link_poll(struct work_s
  
  static int ntb_xeon_setup(struct ntb_device *ndev)
  {
 -	switch (ndev->conn_type) {
 +	int rc;
 +	u8 val;
 +
 +	ndev->hw_type = SNB_HW;
 +
 +	rc = pci_read_config_byte(ndev->pdev, NTB_PPD_OFFSET, &val);
 +	if (rc)
 +		return rc;
 +
 +	switch (val & SNB_PPD_CONN_TYPE) {
  	case NTB_CONN_B2B:
++<<<<<<< HEAD
 +		ndev->conn_type = NTB_CONN_B2B;
++=======
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
+ 		ndev->limits.max_spads = SNB_MAX_B2B_SPADS;
+ 
+ 		/* There is a Xeon hardware errata related to writes to
+ 		 * SDOORBELL or B2BDOORBELL in conjunction with inbound access
+ 		 * to NTB MMIO Space, which may hang the system.  To workaround
+ 		 * this use the second memory window to access the interrupt and
+ 		 * scratch pad registers on the remote system.
+ 		 */
+ 		if (ndev->wa_flags & WA_SNB_ERR) {
+ 			if (!ndev->mw[1].bar_sz)
+ 				return -EINVAL;
+ 
+ 			ndev->limits.max_mw = SNB_ERRATA_MAX_MW;
+ 			ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 			ndev->reg_ofs.spad_write = ndev->mw[1].vbase +
+ 						   SNB_SPAD_OFFSET;
+ 			ndev->reg_ofs.rdb = ndev->mw[1].vbase +
+ 					    SNB_PDOORBELL_OFFSET;
+ 
+ 			/* Set the Limit register to 4k, the minimum size, to
+ 			 * prevent an illegal access
+ 			 */
+ 			writeq(ndev->mw[1].bar_sz + 0x1000, ndev->reg_base +
+ 			       SNB_PBAR4LMT_OFFSET);
+ 			/* HW errata on the Limit registers.  They can only be
+ 			 * written when the base register is 4GB aligned and
+ 			 * < 32bit.  This should already be the case based on
+ 			 * the driver defaults, but write the Limit registers
+ 			 * first just in case.
+ 			 */
+ 		} else {
+ 			ndev->limits.max_mw = SNB_MAX_MW;
+ 
+ 			/* HW Errata on bit 14 of b2bdoorbell register.  Writes
+ 			 * will not be mirrored to the remote system.  Shrink
+ 			 * the number of bits by one, since bit 14 is the last
+ 			 * bit.
+ 			 */
+ 			ndev->limits.max_db_bits = SNB_MAX_DB_BITS - 1;
+ 			ndev->reg_ofs.spad_write = ndev->reg_base +
+ 						   SNB_B2B_SPAD_OFFSET;
+ 			ndev->reg_ofs.rdb = ndev->reg_base +
+ 					    SNB_B2B_DOORBELL_OFFSET;
+ 
+ 			/* Disable the Limit register, just incase it is set to
+ 			 * something silly
+ 			 */
+ 			writeq(0, ndev->reg_base + SNB_PBAR4LMT_OFFSET);
+ 			/* HW errata on the Limit registers.  They can only be
+ 			 * written when the base register is 4GB aligned and
+ 			 * < 32bit.  This should already be the case based on
+ 			 * the driver defaults, but write the Limit registers
+ 			 * first just in case.
+ 			 */
+ 		}
+ 
+ 		/* The Xeon errata workaround requires setting SBAR Base
+ 		 * addresses to known values, so that the PBAR XLAT can be
+ 		 * pointed at SBAR0 of the remote system.
+ 		 */
+ 		if (ndev->dev_type == NTB_DEV_USD) {
+ 			writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
+ 			       SNB_PBAR2XLAT_OFFSET);
+ 			if (ndev->wa_flags & WA_SNB_ERR)
+ 				writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 			else {
+ 				writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 				/* B2B_XLAT_OFFSET is a 64bit register, but can
+ 				 * only take 32bit writes
+ 				 */
+ 				writel(SNB_MBAR01_DSD_ADDR & 0xffffffff,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
+ 				writel(SNB_MBAR01_DSD_ADDR >> 32,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
+ 			}
+ 
+ 			writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR0BASE_OFFSET);
+ 			writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR2BASE_OFFSET);
+ 			writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR4BASE_OFFSET);
+ 		} else {
+ 			writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
+ 			       SNB_PBAR2XLAT_OFFSET);
+ 			if (ndev->wa_flags & WA_SNB_ERR)
+ 				writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 			else {
+ 				writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 				/* B2B_XLAT_OFFSET is a 64bit register, but can
+ 				 * only take 32bit writes
+ 				 */
+ 				writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
+ 				writel(SNB_MBAR01_USD_ADDR >> 32,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
+ 			}
+ 			writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR0BASE_OFFSET);
+ 			writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR2BASE_OFFSET);
+ 			writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR4BASE_OFFSET);
+ 		}
++>>>>>>> 069684e888da (ntb: use errata flag set via DID to implement workaround)
  		break;
 +	case NTB_CONN_CLASSIC:
  	case NTB_CONN_RP:
++<<<<<<< HEAD
++=======
+ 		if (ndev->wa_flags & WA_SNB_ERR) {
+ 			dev_err(&ndev->pdev->dev,
+ 				"NTB-RP disabled due to hardware errata.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* Scratch pads need to have exclusive access from the primary
+ 		 * or secondary side.  Halve the num spads so that each side can
+ 		 * have an equal amount.
+ 		 */
+ 		ndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;
+ 		ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 		/* Note: The SDOORBELL is the cause of the errata.  You REALLY
+ 		 * don't want to touch it.
+ 		 */
+ 		ndev->reg_ofs.rdb = ndev->reg_base + SNB_SDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
+ 		/* Offset the start of the spads to correspond to whether it is
+ 		 * primary or secondary
+ 		 */
+ 		ndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET +
+ 					   ndev->limits.max_spads * 4;
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ 		break;
+ 	case NTB_CONN_TRANSPARENT:
+ 		if (ndev->wa_flags & WA_SNB_ERR) {
+ 			dev_err(&ndev->pdev->dev,
+ 				"NTB-TRANSPARENT disabled due to hardware errata.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* Scratch pads need to have exclusive access from the primary
+ 		 * or secondary side.  Halve the num spads so that each side can
+ 		 * have an equal amount.
+ 		 */
+ 		ndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;
+ 		ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 		ndev->reg_ofs.rdb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_SDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_SDBMSK_OFFSET;
+ 		ndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		/* Offset the start of the spads to correspond to whether it is
+ 		 * primary or secondary
+ 		 */
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET +
+ 					  ndev->limits.max_spads * 4;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_PBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_PBAR4XLAT_OFFSET;
+ 
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ 		break;
++>>>>>>> 069684e888da (ntb: use errata flag set via DID to implement workaround)
  	default:
 -		/*
 -		 * we should never hit this. the detect function should've
 -		 * take cared of everything.
 -		 */
 +		dev_err(&ndev->pdev->dev, "Only B2B supported at this time\n");
  		return -EINVAL;
  	}
  
diff --cc drivers/ntb/ntb_hw.h
index 32fde1724b87,5380ca16198a..000000000000
--- a/drivers/ntb/ntb_hw.h
+++ b/drivers/ntb/ntb_hw.h
@@@ -141,7 -150,13 +143,13 @@@ struct ntb_device 
  	struct delayed_work hb_timer;
  	unsigned long last_ts;
  
 -	struct delayed_work lr_timer;
 -
  	struct dentry *debugfs_dir;
++<<<<<<< HEAD
++=======
+ 	struct dentry *debugfs_info;
+ 
+ 	unsigned int wa_flags;
++>>>>>>> 069684e888da (ntb: use errata flag set via DID to implement workaround)
  };
  
  /**
* Unmerged path drivers/ntb/ntb_hw.c
* Unmerged path drivers/ntb/ntb_hw.h
