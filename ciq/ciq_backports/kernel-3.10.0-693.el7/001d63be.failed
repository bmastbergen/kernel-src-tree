scsi: rename SG related struct and functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] rename SG related struct and functions (David Milburn) [1384526 1389755 1366753 1374291 1383834]
Rebuild_FUZZ: 92.68%
commit-author Ming Lin <ming.l@ssi.samsung.com>
commit 001d63be61c3b5a0413a46bacafbfc60c353951a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/001d63be.failed

Rename SCSI specific struct and functions to more genenic names.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ming Lin <ming.l@ssi.samsung.com>
	Reviewed-by: Sagi Grimberg <sgi@grimberg.me>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 001d63be61c3b5a0413a46bacafbfc60c353951a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index f484f378d9a4,08134f621450..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -594,34 -583,32 +594,53 @@@ static struct scatterlist *sg_pool_allo
  	return mempool_alloc(sgp->pool, gfp_mask);
  }
  
++<<<<<<< HEAD
 +static void scsi_free_sgtable(struct scsi_data_buffer *sdb, bool mq)
++=======
+ static void sg_free_table_chained(struct sg_table *table, bool first_chunk)
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  {
 -	if (first_chunk && table->orig_nents <= SCSI_MAX_SG_SEGMENTS)
 +	if (mq && sdb->table.orig_nents <= SCSI_MAX_SG_SEGMENTS)
  		return;
++<<<<<<< HEAD
 +	__sg_free_table(&sdb->table, SCSI_MAX_SG_SEGMENTS, mq, scsi_sg_free);
 +}
 +
 +static int scsi_alloc_sgtable(struct scsi_data_buffer *sdb, int nents,
 +			      gfp_t gfp_mask, bool mq)
++=======
+ 	__sg_free_table(table, SCSI_MAX_SG_SEGMENTS, first_chunk, sg_pool_free);
+ }
+ 
+ static int sg_alloc_table_chained(struct sg_table *table, int nents,
+ 		struct scatterlist *first_chunk)
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  {
 +	struct scatterlist *first_chunk = NULL;
  	int ret;
  
  	BUG_ON(!nents);
  
 -	if (first_chunk) {
 +	if (mq) {
  		if (nents <= SCSI_MAX_SG_SEGMENTS) {
 -			table->nents = table->orig_nents = nents;
 -			sg_init_table(table->sgl, nents);
 +			sdb->table.nents = sdb->table.orig_nents = nents;
 +			sg_init_table(sdb->table.sgl, nents);
  			return 0;
  		}
 +		first_chunk = sdb->table.sgl;
  	}
  
++<<<<<<< HEAD
 +	ret = __sg_alloc_table(&sdb->table, nents, SCSI_MAX_SG_SEGMENTS,
 +			       first_chunk, gfp_mask, scsi_sg_alloc);
 +	if (unlikely(ret))
 +		scsi_free_sgtable(sdb, mq);
++=======
+ 	ret = __sg_alloc_table(table, nents, SCSI_MAX_SG_SEGMENTS,
+ 			       first_chunk, GFP_ATOMIC, sg_pool_alloc);
+ 	if (unlikely(ret))
+ 		sg_free_table_chained(table, (bool)first_chunk);
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  	return ret;
  }
  
@@@ -637,12 -624,17 +656,23 @@@ static void scsi_uninit_cmd(struct scsi
  
  static void scsi_mq_free_sgtables(struct scsi_cmnd *cmd)
  {
 -	struct scsi_data_buffer *sdb;
 -
  	if (cmd->sdb.table.nents)
++<<<<<<< HEAD
 +		scsi_free_sgtable(&cmd->sdb, true);
 +	if (cmd->request->next_rq && cmd->request->next_rq->special)
 +		scsi_free_sgtable(cmd->request->next_rq->special, true);
 +	if (scsi_prot_sg_count(cmd))
 +		scsi_free_sgtable(cmd->prot_sdb, true);
++=======
+ 		sg_free_table_chained(&cmd->sdb.table, true);
+ 	if (cmd->request->next_rq) {
+ 		sdb = cmd->request->next_rq->special;
+ 		if (sdb)
+ 			sg_free_table_chained(&sdb->table, true);
+ 	}
+ 	if (scsi_prot_sg_count(cmd))
+ 		sg_free_table_chained(&cmd->prot_sdb->table, true);
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  }
  
  static void scsi_mq_uninit_cmd(struct scsi_cmnd *cmd)
@@@ -678,23 -670,22 +708,35 @@@
   *		the __init_io() function.  Primarily this would involve
   *		the scatter-gather table.
   */
 -static void scsi_release_buffers(struct scsi_cmnd *cmd)
 +void scsi_release_buffers(struct scsi_cmnd *cmd)
  {
  	if (cmd->sdb.table.nents)
++<<<<<<< HEAD
 +		scsi_free_sgtable(&cmd->sdb, false);
++=======
+ 		sg_free_table_chained(&cmd->sdb.table, false);
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  
  	memset(&cmd->sdb, 0, sizeof(cmd->sdb));
  
  	if (scsi_prot_sg_count(cmd))
++<<<<<<< HEAD
 +		scsi_free_sgtable(cmd->prot_sdb, false);
++=======
+ 		sg_free_table_chained(&cmd->prot_sdb->table, false);
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  }
 +EXPORT_SYMBOL(scsi_release_buffers);
  
  static void scsi_release_bidi_buffers(struct scsi_cmnd *cmd)
  {
  	struct scsi_data_buffer *bidi_sdb = cmd->request->next_rq->special;
  
++<<<<<<< HEAD
 +	scsi_free_sgtable(bidi_sdb, false);
++=======
+ 	sg_free_table_chained(&bidi_sdb->table, false);
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  	kmem_cache_free(scsi_sdb_cache, bidi_sdb);
  	cmd->request->next_rq->special = NULL;
  }
@@@ -1101,12 -1089,10 +1143,17 @@@ static int scsi_init_sgtable(struct req
  	/*
  	 * If sg table allocation fails, requeue request later.
  	 */
++<<<<<<< HEAD
 +	if (unlikely(scsi_alloc_sgtable(sdb, req->nr_phys_segments,
 +					gfp_mask, req->mq_ctx != NULL)))
++=======
+ 	if (unlikely(sg_alloc_table_chained(&sdb->table, req->nr_phys_segments,
+ 					sdb->table.sgl)))
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  		return BLKPREP_DEFER;
  
 +	req->buffer = NULL;
 +
  	/* 
  	 * Next, walk the list, and fill in the addresses and sizes of
  	 * each segment.
@@@ -1177,7 -1162,8 +1224,12 @@@ int scsi_init_io(struct scsi_cmnd *cmd
  
  		ivecs = blk_rq_count_integrity_sg(rq->q, rq->bio);
  
++<<<<<<< HEAD
 +		if (scsi_alloc_sgtable(prot_sdb, ivecs, gfp_mask, is_mq)) {
++=======
+ 		if (sg_alloc_table_chained(&prot_sdb->table, ivecs,
+ 				prot_sdb->table.sgl)) {
++>>>>>>> 001d63be61c3 (scsi: rename SG related struct and functions)
  			error = BLKPREP_DEFER;
  			goto err_exit;
  		}
* Unmerged path drivers/scsi/scsi_lib.c
