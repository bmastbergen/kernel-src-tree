mlxsw: spectrum: Make the add_matchall_tc_entry symmetric

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Yotam Gigi <yotamg@mellanox.com>
commit 65acb5d0827c8a05022e77eced63cdc8616ba43a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/65acb5d0.failed

Currently, the mlxsw spectrum driver only supports offloading the matchall
classifier together with the mirred action. To allow more matchall tc
offloads, make the code symmetric so that it can be easily extended later
on for other actions.

	Signed-off-by: Yotam Gigi <yotamg@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 65acb5d0827c8a05022e77eced63cdc8616ba43a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 807dafe8d66a,f4b8ba21dd8f..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@@ -1228,26 -1222,44 +1224,58 @@@ static int mlxsw_sp_port_add_cls_matcha
  					  struct tc_cls_matchall_offload *cls,
  					  bool ingress)
  {
++<<<<<<< HEAD
 +	struct tcf_exts *exts = cls->exts;
++=======
+ 	struct mlxsw_sp_port_mall_tc_entry *mall_tc_entry;
++>>>>>>> 65acb5d0827c (mlxsw: spectrum: Make the add_matchall_tc_entry symmetric)
  	const struct tc_action *a;
 -	LIST_HEAD(actions);
  	int err;
  
 -	if (!tc_single_action(cls->exts)) {
 +	if (!list_is_singular(&exts->actions)) {
  		netdev_err(mlxsw_sp_port->dev, "only singular actions are supported\n");
  		return -ENOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	a = list_first_entry(&exts->actions, struct tc_action, list);
 +	if (is_tcf_mirred_mirror(a) && protocol == htons(ETH_P_ALL)) {
 +		err = mlxsw_sp_port_add_cls_matchall_mirror(mlxsw_sp_port, cls,
 +							    a, ingress);
 +		if (err)
 +			return err;
 +	} else {
 +		return -ENOTSUPP;
++=======
+ 	mall_tc_entry = kzalloc(sizeof(*mall_tc_entry), GFP_KERNEL);
+ 	if (!mall_tc_entry)
+ 		return -ENOMEM;
+ 	mall_tc_entry->cookie = cls->cookie;
+ 
+ 	tcf_exts_to_list(cls->exts, &actions);
+ 	a = list_first_entry(&actions, struct tc_action, list);
+ 
+ 	if (is_tcf_mirred_egress_mirror(a) && protocol == htons(ETH_P_ALL)) {
+ 		struct mlxsw_sp_port_mall_mirror_tc_entry *mirror;
+ 
+ 		mall_tc_entry->type = MLXSW_SP_PORT_MALL_MIRROR;
+ 		mirror = &mall_tc_entry->mirror;
+ 		err = mlxsw_sp_port_add_cls_matchall_mirror(mlxsw_sp_port,
+ 							    mirror, a, ingress);
+ 	} else {
+ 		err = -EOPNOTSUPP;
++>>>>>>> 65acb5d0827c (mlxsw: spectrum: Make the add_matchall_tc_entry symmetric)
  	}
  
+ 	if (err)
+ 		goto err_add_action;
+ 
+ 	list_add_tail(&mall_tc_entry->list, &mlxsw_sp_port->mall_tc_list);
  	return 0;
+ 
+ err_add_action:
+ 	kfree(mall_tc_entry);
+ 	return err;
  }
  
  static void mlxsw_sp_port_del_cls_matchall(struct mlxsw_sp_port *mlxsw_sp_port,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.c
