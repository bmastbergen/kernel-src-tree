switchdev: use new swdev ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Scott Feldman <sfeldma@gmail.com>
commit 98237d433b98d27fdffb09e4a1a510e9f00c6f31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/98237d43.failed

Move swdev wrappers over to new swdev ops (from previous ndo ops).  No
functional changes to the implementation.

	Signed-off-by: Scott Feldman <sfeldma@gmail.com>

rocker: move to new swdev ops

	Signed-off-by: Scott Feldman <sfeldma@gmail.com>

dsa: move to new swdev ops

	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 98237d433b98d27fdffb09e4a1a510e9f00c6f31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/rocker/rocker.c
#	net/dsa/slave.c
#	net/switchdev/switchdev.c
diff --cc net/dsa/slave.c
index 6ebd8fbd9285,f0af7aa331c1..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -9,9 -9,15 +9,18 @@@
   */
  
  #include <linux/list.h>
 -#include <linux/etherdevice.h>
  #include <linux/netdevice.h>
 +#include <linux/etherdevice.h>
  #include <linux/phy.h>
++<<<<<<< HEAD
++=======
+ #include <linux/phy_fixed.h>
+ #include <linux/of_net.h>
+ #include <linux/of_mdio.h>
+ #include <net/rtnetlink.h>
+ #include <net/switchdev.h>
+ #include <linux/if_bridge.h>
++>>>>>>> 98237d433b98 (switchdev: use new swdev ops)
  #include "dsa_priv.h"
  
  /* slave mii_bus handling ***************************************************/
@@@ -303,52 -573,202 +312,61 @@@ static const struct net_device_ops dsa_
  	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
  	.ndo_set_mac_address	= dsa_slave_set_mac_address,
  	.ndo_do_ioctl		= dsa_slave_ioctl,
++<<<<<<< HEAD
++=======
+ };
+ 
+ static const struct swdev_ops dsa_slave_swdev_ops = {
+ 	.swdev_parent_id_get = dsa_slave_parent_id_get,
+ 	.swdev_port_stp_update = dsa_slave_stp_update,
++>>>>>>> 98237d433b98 (switchdev: use new swdev ops)
  };
 -
 -static void dsa_slave_adjust_link(struct net_device *dev)
 -{
 -	struct dsa_slave_priv *p = netdev_priv(dev);
 -	struct dsa_switch *ds = p->parent;
 -	unsigned int status_changed = 0;
 -
 -	if (p->old_link != p->phy->link) {
 -		status_changed = 1;
 -		p->old_link = p->phy->link;
 -	}
 -
 -	if (p->old_duplex != p->phy->duplex) {
 -		status_changed = 1;
 -		p->old_duplex = p->phy->duplex;
 -	}
 -
 -	if (p->old_pause != p->phy->pause) {
 -		status_changed = 1;
 -		p->old_pause = p->phy->pause;
 -	}
 -
 -	if (ds->drv->adjust_link && status_changed)
 -		ds->drv->adjust_link(ds, p->port, p->phy);
 -
 -	if (status_changed)
 -		phy_print_status(p->phy);
 -}
 -
 -static int dsa_slave_fixed_link_update(struct net_device *dev,
 -				       struct fixed_phy_status *status)
 -{
 -	struct dsa_slave_priv *p = netdev_priv(dev);
 -	struct dsa_switch *ds = p->parent;
 -
 -	if (ds->drv->fixed_link_update)
 -		ds->drv->fixed_link_update(ds, p->port, status);
 -
 -	return 0;
 -}
 +#endif
 +#ifdef CONFIG_NET_DSA_TAG_EDSA
 +static const struct net_device_ops edsa_netdev_ops = {
 +	.ndo_init		= dsa_slave_init,
 +	.ndo_open	 	= dsa_slave_open,
 +	.ndo_stop		= dsa_slave_close,
 +	.ndo_start_xmit		= edsa_xmit,
 +	.ndo_change_rx_flags	= dsa_slave_change_rx_flags,
 +	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
 +	.ndo_set_mac_address	= dsa_slave_set_mac_address,
 +	.ndo_do_ioctl		= dsa_slave_ioctl,
 +};
 +#endif
 +#ifdef CONFIG_NET_DSA_TAG_TRAILER
 +static const struct net_device_ops trailer_netdev_ops = {
 +	.ndo_init		= dsa_slave_init,
 +	.ndo_open	 	= dsa_slave_open,
 +	.ndo_stop		= dsa_slave_close,
 +	.ndo_start_xmit		= trailer_xmit,
 +	.ndo_change_rx_flags	= dsa_slave_change_rx_flags,
 +	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
 +	.ndo_set_mac_address	= dsa_slave_set_mac_address,
 +	.ndo_do_ioctl		= dsa_slave_ioctl,
 +};
 +#endif
  
  /* slave device setup *******************************************************/
 -static int dsa_slave_phy_connect(struct dsa_slave_priv *p,
 -				 struct net_device *slave_dev,
 -				 int addr)
 -{
 -	struct dsa_switch *ds = p->parent;
 -
 -	p->phy = ds->slave_mii_bus->phy_map[addr];
 -	if (!p->phy)
 -		return -ENODEV;
 -
 -	/* Use already configured phy mode */
 -	p->phy_interface = p->phy->interface;
 -	phy_connect_direct(slave_dev, p->phy, dsa_slave_adjust_link,
 -			   p->phy_interface);
 -
 -	return 0;
 -}
 -
 -static int dsa_slave_phy_setup(struct dsa_slave_priv *p,
 -				struct net_device *slave_dev)
 -{
 -	struct dsa_switch *ds = p->parent;
 -	struct dsa_chip_data *cd = ds->pd;
 -	struct device_node *phy_dn, *port_dn;
 -	bool phy_is_fixed = false;
 -	u32 phy_flags = 0;
 -	int mode, ret;
 -
 -	port_dn = cd->port_dn[p->port];
 -	mode = of_get_phy_mode(port_dn);
 -	if (mode < 0)
 -		mode = PHY_INTERFACE_MODE_NA;
 -	p->phy_interface = mode;
 -
 -	phy_dn = of_parse_phandle(port_dn, "phy-handle", 0);
 -	if (of_phy_is_fixed_link(port_dn)) {
 -		/* In the case of a fixed PHY, the DT node associated
 -		 * to the fixed PHY is the Port DT node
 -		 */
 -		ret = of_phy_register_fixed_link(port_dn);
 -		if (ret) {
 -			netdev_err(slave_dev, "failed to register fixed PHY\n");
 -			return ret;
 -		}
 -		phy_is_fixed = true;
 -		phy_dn = port_dn;
 -	}
 -
 -	if (ds->drv->get_phy_flags)
 -		phy_flags = ds->drv->get_phy_flags(ds, p->port);
 -
 -	if (phy_dn) {
 -		ret = of_mdio_parse_addr(&slave_dev->dev, phy_dn);
 -		/* If this PHY address is part of phys_mii_mask, which means
 -		 * that we need to divert reads and writes to/from it, then we
 -		 * want to bind this device using the slave MII bus created by
 -		 * DSA to make that happen.
 -		 */
 -		if (!phy_is_fixed && ret >= 0 &&
 -		    (ds->phys_mii_mask & (1 << ret))) {
 -			ret = dsa_slave_phy_connect(p, slave_dev, ret);
 -			if (ret)
 -				return ret;
 -		} else {
 -			p->phy = of_phy_connect(slave_dev, phy_dn,
 -						dsa_slave_adjust_link,
 -						phy_flags,
 -						p->phy_interface);
 -		}
 -	}
 -
 -	if (p->phy && phy_is_fixed)
 -		fixed_phy_set_link_update(p->phy, dsa_slave_fixed_link_update);
 -
 -	/* We could not connect to a designated PHY, so use the switch internal
 -	 * MDIO bus instead
 -	 */
 -	if (!p->phy) {
 -		ret = dsa_slave_phy_connect(p, slave_dev, p->port);
 -		if (ret)
 -			return ret;
 -	} else {
 -		netdev_info(slave_dev, "attached PHY at address %d [%s]\n",
 -			    p->phy->addr, p->phy->drv->name);
 -	}
 -
 -	return 0;
 -}
 -
 -int dsa_slave_suspend(struct net_device *slave_dev)
 -{
 -	struct dsa_slave_priv *p = netdev_priv(slave_dev);
 -
 -	netif_device_detach(slave_dev);
 -
 -	if (p->phy) {
 -		phy_stop(p->phy);
 -		p->old_pause = -1;
 -		p->old_link = -1;
 -		p->old_duplex = -1;
 -		phy_suspend(p->phy);
 -	}
 -
 -	return 0;
 -}
 -
 -int dsa_slave_resume(struct net_device *slave_dev)
 -{
 -	struct dsa_slave_priv *p = netdev_priv(slave_dev);
 -
 -	netif_device_attach(slave_dev);
 -
 -	if (p->phy) {
 -		phy_resume(p->phy);
 -		phy_start(p->phy);
 -	}
 -
 -	return 0;
 -}
 -
 -int dsa_slave_create(struct dsa_switch *ds, struct device *parent,
 -		     int port, char *name)
 +struct net_device *
 +dsa_slave_create(struct dsa_switch *ds, struct device *parent,
 +		 int port, char *name)
  {
  	struct net_device *master = ds->dst->master_netdev;
  	struct net_device *slave_dev;
  	struct dsa_slave_priv *p;
  	int ret;
  
 -	slave_dev = alloc_netdev(sizeof(struct dsa_slave_priv), name,
 -				 NET_NAME_UNKNOWN, ether_setup);
 +	slave_dev = alloc_netdev(sizeof(struct dsa_slave_priv),
 +				 name, ether_setup);
  	if (slave_dev == NULL)
 -		return -ENOMEM;
 +		return slave_dev;
  
  	slave_dev->features = master->vlan_features;
 -	slave_dev->ethtool_ops = &dsa_slave_ethtool_ops;
 -	eth_hw_addr_inherit(slave_dev, master);
 +	SET_ETHTOOL_OPS(slave_dev, &dsa_slave_ethtool_ops);
 +	memcpy(slave_dev->dev_addr, master->dev_addr, ETH_ALEN);
  	slave_dev->tx_queue_len = 0;
 -	slave_dev->netdev_ops = &dsa_slave_netdev_ops;
 -	slave_dev->swdev_ops = &dsa_slave_swdev_ops;
 -
 -	SET_NETDEV_DEV(slave_dev, parent);
 -	slave_dev->dev.of_node = ds->pd->port_dn[port];
 -	slave_dev->vlan_features = master->vlan_features;
 -
 -	p = netdev_priv(slave_dev);
 -	p->dev = slave_dev;
 -	p->parent = ds;
 -	p->port = port;
++<<<<<<< HEAD
  
  	switch (ds->dst->tag_protocol) {
  #ifdef CONFIG_NET_DSA_TAG_DSA
@@@ -367,24 -792,29 +385,28 @@@
  		break;
  #endif
  	default:
 -		p->xmit	= dsa_slave_notag_xmit;
 -		break;
 +		BUG();
  	}
++=======
++	slave_dev->netdev_ops = &dsa_slave_netdev_ops;
++	slave_dev->swdev_ops = &dsa_slave_swdev_ops;
++>>>>>>> 98237d433b98 (switchdev: use new swdev ops)
  
 -	p->old_pause = -1;
 -	p->old_link = -1;
 -	p->old_duplex = -1;
 +	SET_NETDEV_DEV(slave_dev, parent);
 +	slave_dev->vlan_features = master->vlan_features;
  
 -	ret = dsa_slave_phy_setup(p, slave_dev);
 -	if (ret) {
 -		free_netdev(slave_dev);
 -		return ret;
 -	}
 +	p = netdev_priv(slave_dev);
 +	p->dev = slave_dev;
 +	p->parent = ds;
 +	p->port = port;
 +	p->phy = ds->slave_mii_bus->phy_map[port];
  
 -	ds->ports[port] = slave_dev;
  	ret = register_netdev(slave_dev);
  	if (ret) {
 -		netdev_err(master, "error %d registering interface %s\n",
 -			   ret, slave_dev->name);
 -		phy_disconnect(p->phy);
 -		ds->ports[port] = NULL;
 +		printk(KERN_ERR "%s: error %d registering interface %s\n",
 +				master->name, ret, slave_dev->name);
  		free_netdev(slave_dev);
 -		return ret;
 +		return NULL;
  	}
  
  	netif_carrier_off(slave_dev);
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path net/switchdev/switchdev.c
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path net/dsa/slave.c
* Unmerged path net/switchdev/switchdev.c
