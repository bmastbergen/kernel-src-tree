KVM: nVMX: fix msr bitmaps to prevent L2 from accessing L0 x2APIC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit d048c098218e91ed0e10dfa1f0f80e2567fe4ef7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d048c098.failed

msr bitmap can be used to avoid a VM exit (interception) on guest MSR
accesses.  In some configurations of VMX controls, the guest can even
directly access host's x2APIC MSRs.  See SDM 29.5 VIRTUALIZING MSR-BASED
APIC ACCESSES.

L2 could read all L0's x2APIC MSRs and write TPR, EOI, and SELF_IPI.
To do so, L1 would first trick KVM to disable all possible interceptions
by enabling APICv features and then would turn those features off;
nested_vmx_merge_msr_bitmap() only disabled interceptions, so VMX would
not intercept previously enabled MSRs even though they were not safe
with the new configuration.

Correctly re-enabling interceptions is not enough as a second bug would
still allow L1+L2 to access host's MSRs: msr bitmap was shared for all
VMCSs, so L1 could trigger a race to get the desired combination of msr
bitmap and VMX controls.

This fix allocates a msr bitmap for every L1 VCPU, allows only safe
x2APIC MSRs from L1's msr bitmap, and disables msr bitmaps if they would
have to intercept everything anyway.

Fixes: 3af18d9c5fe9 ("KVM: nVMX: Prepare for using hardware MSR bitmap")
	Reported-by: Jim Mattson <jmattson@google.com>
	Suggested-by: Wincy Van <fanwenyi0529@gmail.com>
	Reviewed-by: Wanpeng Li <wanpeng.li@hotmail.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit d048c098218e91ed0e10dfa1f0f80e2567fe4ef7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 2db5d4e3b019,c66ac2c70d22..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -429,8 -434,9 +429,10 @@@ struct nested_vmx 
  	struct pi_desc *pi_desc;
  	bool pi_pending;
  	u16 posted_intr_nv;
 +	u64 msr_ia32_feature_control;
  
+ 	unsigned long *msr_bitmap;
+ 
  	struct hrtimer preemption_timer;
  	bool preemption_timer_expired;
  
@@@ -2342,8 -2509,10 +2343,15 @@@ static void vmx_set_msr_bitmap(struct k
  	unsigned long *msr_bitmap;
  
  	if (is_guest_mode(vcpu))
++<<<<<<< HEAD
 +		msr_bitmap = vmx_msr_bitmap_nested;
 +	else if (vcpu->arch.apic_base & X2APIC_ENABLE) {
++=======
+ 		msr_bitmap = to_vmx(vcpu)->nested.msr_bitmap;
+ 	else if (cpu_has_secondary_exec_ctrls() &&
+ 		 (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &
+ 		  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {
++>>>>>>> d048c098218e (KVM: nVMX: fix msr bitmaps to prevent L2 from accessing L0 x2APIC)
  		if (is_long_mode(vcpu))
  			msr_bitmap = vmx_msr_bitmap_longmode_x2apic;
  		else
* Unmerged path arch/x86/kvm/vmx.c
