net: fix wrong skb_get() usage / crash in IGMP/MLD parsing code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] fix wrong skb_get() usage / crash in IGMP/MLD parsing code (Ivan Vecera) [1352289]
Rebuild_FUZZ: 95.87%
commit-author Linus Lüssing <linus.luessing@c0d3.blue>
commit a516993f0ac1694673412eb2d16a091eafa77d2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a516993f.failed

The recent refactoring of the IGMP and MLD parsing code into
ipv6_mc_check_mld() / ip_mc_check_igmp() introduced a potential crash /
BUG() invocation for bridges:

I wrongly assumed that skb_get() could be used as a simple reference
counter for an skb which is not the case. skb_get() bears additional
semantics, a user count. This leads to a BUG() invocation in
pskb_expand_head() / kernel panic if pskb_may_pull() is called on an skb
with a user count greater than one - unfortunately the refactoring did
just that.

Fixing this by removing the skb_get() call and changing the API: The
caller of ipv6_mc_check_mld() / ip_mc_check_igmp() now needs to
additionally check whether the returned skb_trimmed is a clone.

Fixes: 9afd85c9e455 ("net: Export IGMP/MLD message validation code")
	Reported-by: Brenden Blanco <bblanco@plumgrid.com>
	Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
	Acked-by: Alexei Starovoitov <ast@plumgrid.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a516993f0ac1694673412eb2d16a091eafa77d2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/core/skbuff.c
#	net/ipv4/igmp.c
#	net/ipv6/mcast_snoop.c
diff --cc net/bridge/br_multicast.c
index a266582e6c63,1285eaf5dc22..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -1589,11 -1591,9 +1589,17 @@@ static int br_multicast_ipv4_rcv(struc
  		break;
  	}
  
++<<<<<<< HEAD
 +out:
 +	__skb_push(skb2, offset);
 +err_out:
 +	if (skb2 != skb)
 +		kfree_skb(skb2);
++=======
+ 	if (skb_trimmed && skb_trimmed != skb)
+ 		kfree_skb(skb_trimmed);
+ 
++>>>>>>> a516993f0ac1 (net: fix wrong skb_get() usage / crash in IGMP/MLD parsing code)
  	return err;
  }
  
@@@ -1702,27 -1625,20 +1708,33 @@@ static int br_multicast_ipv6_rcv(struc
  		BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
  		err = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid);
  		break;
 +	    }
  	case ICMPV6_MLD2_REPORT:
 -		err = br_ip6_multicast_mld2_report(br, port, skb_trimmed, vid);
 +		err = br_ip6_multicast_mld2_report(br, port, skb2, vid);
  		break;
  	case ICMPV6_MGM_QUERY:
 -		err = br_ip6_multicast_query(br, port, skb_trimmed, vid);
 +		err = br_ip6_multicast_query(br, port, skb2, vid);
  		break;
  	case ICMPV6_MGM_REDUCTION:
 +	    {
 +		struct mld_msg *mld;
 +		if (!pskb_may_pull(skb2, sizeof(*mld))) {
 +			err = -EINVAL;
 +			goto out;
 +		}
 +		mld = (struct mld_msg *)skb_transport_header(skb2);
  		br_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid);
 -		break;
 +	    }
  	}
  
++<<<<<<< HEAD
 +out:
 +	kfree_skb(skb2);
++=======
+ 	if (skb_trimmed && skb_trimmed != skb)
+ 		kfree_skb(skb_trimmed);
+ 
++>>>>>>> a516993f0ac1 (net: fix wrong skb_get() usage / crash in IGMP/MLD parsing code)
  	return err;
  }
  #endif
diff --cc net/core/skbuff.c
index c7043c783fdb,bf9a5d93c2d1..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -3770,6 -3780,324 +3770,327 @@@ bool skb_partial_csum_set(struct sk_buf
  }
  EXPORT_SYMBOL_GPL(skb_partial_csum_set);
  
++<<<<<<< HEAD
++=======
+ static int skb_maybe_pull_tail(struct sk_buff *skb, unsigned int len,
+ 			       unsigned int max)
+ {
+ 	if (skb_headlen(skb) >= len)
+ 		return 0;
+ 
+ 	/* If we need to pullup then pullup to the max, so we
+ 	 * won't need to do it again.
+ 	 */
+ 	if (max > skb->len)
+ 		max = skb->len;
+ 
+ 	if (__pskb_pull_tail(skb, max - skb_headlen(skb)) == NULL)
+ 		return -ENOMEM;
+ 
+ 	if (skb_headlen(skb) < len)
+ 		return -EPROTO;
+ 
+ 	return 0;
+ }
+ 
+ #define MAX_TCP_HDR_LEN (15 * 4)
+ 
+ static __sum16 *skb_checksum_setup_ip(struct sk_buff *skb,
+ 				      typeof(IPPROTO_IP) proto,
+ 				      unsigned int off)
+ {
+ 	switch (proto) {
+ 		int err;
+ 
+ 	case IPPROTO_TCP:
+ 		err = skb_maybe_pull_tail(skb, off + sizeof(struct tcphdr),
+ 					  off + MAX_TCP_HDR_LEN);
+ 		if (!err && !skb_partial_csum_set(skb, off,
+ 						  offsetof(struct tcphdr,
+ 							   check)))
+ 			err = -EPROTO;
+ 		return err ? ERR_PTR(err) : &tcp_hdr(skb)->check;
+ 
+ 	case IPPROTO_UDP:
+ 		err = skb_maybe_pull_tail(skb, off + sizeof(struct udphdr),
+ 					  off + sizeof(struct udphdr));
+ 		if (!err && !skb_partial_csum_set(skb, off,
+ 						  offsetof(struct udphdr,
+ 							   check)))
+ 			err = -EPROTO;
+ 		return err ? ERR_PTR(err) : &udp_hdr(skb)->check;
+ 	}
+ 
+ 	return ERR_PTR(-EPROTO);
+ }
+ 
+ /* This value should be large enough to cover a tagged ethernet header plus
+  * maximally sized IP and TCP or UDP headers.
+  */
+ #define MAX_IP_HDR_LEN 128
+ 
+ static int skb_checksum_setup_ipv4(struct sk_buff *skb, bool recalculate)
+ {
+ 	unsigned int off;
+ 	bool fragment;
+ 	__sum16 *csum;
+ 	int err;
+ 
+ 	fragment = false;
+ 
+ 	err = skb_maybe_pull_tail(skb,
+ 				  sizeof(struct iphdr),
+ 				  MAX_IP_HDR_LEN);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	if (ip_hdr(skb)->frag_off & htons(IP_OFFSET | IP_MF))
+ 		fragment = true;
+ 
+ 	off = ip_hdrlen(skb);
+ 
+ 	err = -EPROTO;
+ 
+ 	if (fragment)
+ 		goto out;
+ 
+ 	csum = skb_checksum_setup_ip(skb, ip_hdr(skb)->protocol, off);
+ 	if (IS_ERR(csum))
+ 		return PTR_ERR(csum);
+ 
+ 	if (recalculate)
+ 		*csum = ~csum_tcpudp_magic(ip_hdr(skb)->saddr,
+ 					   ip_hdr(skb)->daddr,
+ 					   skb->len - off,
+ 					   ip_hdr(skb)->protocol, 0);
+ 	err = 0;
+ 
+ out:
+ 	return err;
+ }
+ 
+ /* This value should be large enough to cover a tagged ethernet header plus
+  * an IPv6 header, all options, and a maximal TCP or UDP header.
+  */
+ #define MAX_IPV6_HDR_LEN 256
+ 
+ #define OPT_HDR(type, skb, off) \
+ 	(type *)(skb_network_header(skb) + (off))
+ 
+ static int skb_checksum_setup_ipv6(struct sk_buff *skb, bool recalculate)
+ {
+ 	int err;
+ 	u8 nexthdr;
+ 	unsigned int off;
+ 	unsigned int len;
+ 	bool fragment;
+ 	bool done;
+ 	__sum16 *csum;
+ 
+ 	fragment = false;
+ 	done = false;
+ 
+ 	off = sizeof(struct ipv6hdr);
+ 
+ 	err = skb_maybe_pull_tail(skb, off, MAX_IPV6_HDR_LEN);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	nexthdr = ipv6_hdr(skb)->nexthdr;
+ 
+ 	len = sizeof(struct ipv6hdr) + ntohs(ipv6_hdr(skb)->payload_len);
+ 	while (off <= len && !done) {
+ 		switch (nexthdr) {
+ 		case IPPROTO_DSTOPTS:
+ 		case IPPROTO_HOPOPTS:
+ 		case IPPROTO_ROUTING: {
+ 			struct ipv6_opt_hdr *hp;
+ 
+ 			err = skb_maybe_pull_tail(skb,
+ 						  off +
+ 						  sizeof(struct ipv6_opt_hdr),
+ 						  MAX_IPV6_HDR_LEN);
+ 			if (err < 0)
+ 				goto out;
+ 
+ 			hp = OPT_HDR(struct ipv6_opt_hdr, skb, off);
+ 			nexthdr = hp->nexthdr;
+ 			off += ipv6_optlen(hp);
+ 			break;
+ 		}
+ 		case IPPROTO_AH: {
+ 			struct ip_auth_hdr *hp;
+ 
+ 			err = skb_maybe_pull_tail(skb,
+ 						  off +
+ 						  sizeof(struct ip_auth_hdr),
+ 						  MAX_IPV6_HDR_LEN);
+ 			if (err < 0)
+ 				goto out;
+ 
+ 			hp = OPT_HDR(struct ip_auth_hdr, skb, off);
+ 			nexthdr = hp->nexthdr;
+ 			off += ipv6_authlen(hp);
+ 			break;
+ 		}
+ 		case IPPROTO_FRAGMENT: {
+ 			struct frag_hdr *hp;
+ 
+ 			err = skb_maybe_pull_tail(skb,
+ 						  off +
+ 						  sizeof(struct frag_hdr),
+ 						  MAX_IPV6_HDR_LEN);
+ 			if (err < 0)
+ 				goto out;
+ 
+ 			hp = OPT_HDR(struct frag_hdr, skb, off);
+ 
+ 			if (hp->frag_off & htons(IP6_OFFSET | IP6_MF))
+ 				fragment = true;
+ 
+ 			nexthdr = hp->nexthdr;
+ 			off += sizeof(struct frag_hdr);
+ 			break;
+ 		}
+ 		default:
+ 			done = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	err = -EPROTO;
+ 
+ 	if (!done || fragment)
+ 		goto out;
+ 
+ 	csum = skb_checksum_setup_ip(skb, nexthdr, off);
+ 	if (IS_ERR(csum))
+ 		return PTR_ERR(csum);
+ 
+ 	if (recalculate)
+ 		*csum = ~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
+ 					 &ipv6_hdr(skb)->daddr,
+ 					 skb->len - off, nexthdr, 0);
+ 	err = 0;
+ 
+ out:
+ 	return err;
+ }
+ 
+ /**
+  * skb_checksum_setup - set up partial checksum offset
+  * @skb: the skb to set up
+  * @recalculate: if true the pseudo-header checksum will be recalculated
+  */
+ int skb_checksum_setup(struct sk_buff *skb, bool recalculate)
+ {
+ 	int err;
+ 
+ 	switch (skb->protocol) {
+ 	case htons(ETH_P_IP):
+ 		err = skb_checksum_setup_ipv4(skb, recalculate);
+ 		break;
+ 
+ 	case htons(ETH_P_IPV6):
+ 		err = skb_checksum_setup_ipv6(skb, recalculate);
+ 		break;
+ 
+ 	default:
+ 		err = -EPROTO;
+ 		break;
+ 	}
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL(skb_checksum_setup);
+ 
+ /**
+  * skb_checksum_maybe_trim - maybe trims the given skb
+  * @skb: the skb to check
+  * @transport_len: the data length beyond the network header
+  *
+  * Checks whether the given skb has data beyond the given transport length.
+  * If so, returns a cloned skb trimmed to this transport length.
+  * Otherwise returns the provided skb. Returns NULL in error cases
+  * (e.g. transport_len exceeds skb length or out-of-memory).
+  *
+  * Caller needs to set the skb transport header and free any returned skb if it
+  * differs from the provided skb.
+  */
+ static struct sk_buff *skb_checksum_maybe_trim(struct sk_buff *skb,
+ 					       unsigned int transport_len)
+ {
+ 	struct sk_buff *skb_chk;
+ 	unsigned int len = skb_transport_offset(skb) + transport_len;
+ 	int ret;
+ 
+ 	if (skb->len < len)
+ 		return NULL;
+ 	else if (skb->len == len)
+ 		return skb;
+ 
+ 	skb_chk = skb_clone(skb, GFP_ATOMIC);
+ 	if (!skb_chk)
+ 		return NULL;
+ 
+ 	ret = pskb_trim_rcsum(skb_chk, len);
+ 	if (ret) {
+ 		kfree_skb(skb_chk);
+ 		return NULL;
+ 	}
+ 
+ 	return skb_chk;
+ }
+ 
+ /**
+  * skb_checksum_trimmed - validate checksum of an skb
+  * @skb: the skb to check
+  * @transport_len: the data length beyond the network header
+  * @skb_chkf: checksum function to use
+  *
+  * Applies the given checksum function skb_chkf to the provided skb.
+  * Returns a checked and maybe trimmed skb. Returns NULL on error.
+  *
+  * If the skb has data beyond the given transport length, then a
+  * trimmed & cloned skb is checked and returned.
+  *
+  * Caller needs to set the skb transport header and free any returned skb if it
+  * differs from the provided skb.
+  */
+ struct sk_buff *skb_checksum_trimmed(struct sk_buff *skb,
+ 				     unsigned int transport_len,
+ 				     __sum16(*skb_chkf)(struct sk_buff *skb))
+ {
+ 	struct sk_buff *skb_chk;
+ 	unsigned int offset = skb_transport_offset(skb);
+ 	__sum16 ret;
+ 
+ 	skb_chk = skb_checksum_maybe_trim(skb, transport_len);
+ 	if (!skb_chk)
+ 		goto err;
+ 
+ 	if (!pskb_may_pull(skb_chk, offset))
+ 		goto err;
+ 
+ 	__skb_pull(skb_chk, offset);
+ 	ret = skb_chkf(skb_chk);
+ 	__skb_push(skb_chk, offset);
+ 
+ 	if (ret)
+ 		goto err;
+ 
+ 	return skb_chk;
+ 
+ err:
+ 	if (skb_chk && skb_chk != skb)
+ 		kfree_skb(skb_chk);
+ 
+ 	return NULL;
+ 
+ }
+ EXPORT_SYMBOL(skb_checksum_trimmed);
+ 
++>>>>>>> a516993f0ac1 (net: fix wrong skb_get() usage / crash in IGMP/MLD parsing code)
  void __skb_warn_lro_forwarding(const struct sk_buff *skb)
  {
  	net_warn_ratelimited("%s: received packets cannot be forwarded while LRO is enabled\n",
diff --cc net/ipv4/igmp.c
index bfef4eb42f41,9fdfd9deac11..000000000000
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@@ -1287,6 -1339,171 +1287,174 @@@ out
  }
  EXPORT_SYMBOL(ip_mc_inc_group);
  
++<<<<<<< HEAD
++=======
+ static int ip_mc_check_iphdr(struct sk_buff *skb)
+ {
+ 	const struct iphdr *iph;
+ 	unsigned int len;
+ 	unsigned int offset = skb_network_offset(skb) + sizeof(*iph);
+ 
+ 	if (!pskb_may_pull(skb, offset))
+ 		return -EINVAL;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	if (iph->version != 4 || ip_hdrlen(skb) < sizeof(*iph))
+ 		return -EINVAL;
+ 
+ 	offset += ip_hdrlen(skb) - sizeof(*iph);
+ 
+ 	if (!pskb_may_pull(skb, offset))
+ 		return -EINVAL;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))
+ 		return -EINVAL;
+ 
+ 	len = skb_network_offset(skb) + ntohs(iph->tot_len);
+ 	if (skb->len < len || len < offset)
+ 		return -EINVAL;
+ 
+ 	skb_set_transport_header(skb, offset);
+ 
+ 	return 0;
+ }
+ 
+ static int ip_mc_check_igmp_reportv3(struct sk_buff *skb)
+ {
+ 	unsigned int len = skb_transport_offset(skb);
+ 
+ 	len += sizeof(struct igmpv3_report);
+ 
+ 	return pskb_may_pull(skb, len) ? 0 : -EINVAL;
+ }
+ 
+ static int ip_mc_check_igmp_query(struct sk_buff *skb)
+ {
+ 	unsigned int len = skb_transport_offset(skb);
+ 
+ 	len += sizeof(struct igmphdr);
+ 	if (skb->len < len)
+ 		return -EINVAL;
+ 
+ 	/* IGMPv{1,2}? */
+ 	if (skb->len != len) {
+ 		/* or IGMPv3? */
+ 		len += sizeof(struct igmpv3_query) - sizeof(struct igmphdr);
+ 		if (skb->len < len || !pskb_may_pull(skb, len))
+ 			return -EINVAL;
+ 	}
+ 
+ 	/* RFC2236+RFC3376 (IGMPv2+IGMPv3) require the multicast link layer
+ 	 * all-systems destination addresses (224.0.0.1) for general queries
+ 	 */
+ 	if (!igmp_hdr(skb)->group &&
+ 	    ip_hdr(skb)->daddr != htonl(INADDR_ALLHOSTS_GROUP))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int ip_mc_check_igmp_msg(struct sk_buff *skb)
+ {
+ 	switch (igmp_hdr(skb)->type) {
+ 	case IGMP_HOST_LEAVE_MESSAGE:
+ 	case IGMP_HOST_MEMBERSHIP_REPORT:
+ 	case IGMPV2_HOST_MEMBERSHIP_REPORT:
+ 		/* fall through */
+ 		return 0;
+ 	case IGMPV3_HOST_MEMBERSHIP_REPORT:
+ 		return ip_mc_check_igmp_reportv3(skb);
+ 	case IGMP_HOST_MEMBERSHIP_QUERY:
+ 		return ip_mc_check_igmp_query(skb);
+ 	default:
+ 		return -ENOMSG;
+ 	}
+ }
+ 
+ static inline __sum16 ip_mc_validate_checksum(struct sk_buff *skb)
+ {
+ 	return skb_checksum_simple_validate(skb);
+ }
+ 
+ static int __ip_mc_check_igmp(struct sk_buff *skb, struct sk_buff **skb_trimmed)
+ 
+ {
+ 	struct sk_buff *skb_chk;
+ 	unsigned int transport_len;
+ 	unsigned int len = skb_transport_offset(skb) + sizeof(struct igmphdr);
+ 	int ret = -EINVAL;
+ 
+ 	transport_len = ntohs(ip_hdr(skb)->tot_len) - ip_hdrlen(skb);
+ 
+ 	skb_chk = skb_checksum_trimmed(skb, transport_len,
+ 				       ip_mc_validate_checksum);
+ 	if (!skb_chk)
+ 		goto err;
+ 
+ 	if (!pskb_may_pull(skb_chk, len))
+ 		goto err;
+ 
+ 	ret = ip_mc_check_igmp_msg(skb_chk);
+ 	if (ret)
+ 		goto err;
+ 
+ 	if (skb_trimmed)
+ 		*skb_trimmed = skb_chk;
+ 	/* free now unneeded clone */
+ 	else if (skb_chk != skb)
+ 		kfree_skb(skb_chk);
+ 
+ 	ret = 0;
+ 
+ err:
+ 	if (ret && skb_chk && skb_chk != skb)
+ 		kfree_skb(skb_chk);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * ip_mc_check_igmp - checks whether this is a sane IGMP packet
+  * @skb: the skb to validate
+  * @skb_trimmed: to store an skb pointer trimmed to IPv4 packet tail (optional)
+  *
+  * Checks whether an IPv4 packet is a valid IGMP packet. If so sets
+  * skb transport header accordingly and returns zero.
+  *
+  * -EINVAL: A broken packet was detected, i.e. it violates some internet
+  *  standard
+  * -ENOMSG: IP header validation succeeded but it is not an IGMP packet.
+  * -ENOMEM: A memory allocation failure happened.
+  *
+  * Optionally, an skb pointer might be provided via skb_trimmed (or set it
+  * to NULL): After parsing an IGMP packet successfully it will point to
+  * an skb which has its tail aligned to the IP packet end. This might
+  * either be the originally provided skb or a trimmed, cloned version if
+  * the skb frame had data beyond the IP packet. A cloned skb allows us
+  * to leave the original skb and its full frame unchanged (which might be
+  * desirable for layer 2 frame jugglers).
+  *
+  * Caller needs to set the skb network header and free any returned skb if it
+  * differs from the provided skb.
+  */
+ int ip_mc_check_igmp(struct sk_buff *skb, struct sk_buff **skb_trimmed)
+ {
+ 	int ret = ip_mc_check_iphdr(skb);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
+ 		return -ENOMSG;
+ 
+ 	return __ip_mc_check_igmp(skb, skb_trimmed);
+ }
+ EXPORT_SYMBOL(ip_mc_check_igmp);
+ 
++>>>>>>> a516993f0ac1 (net: fix wrong skb_get() usage / crash in IGMP/MLD parsing code)
  /*
   *	Resend IGMP JOIN report; used by netdev notifier.
   */
* Unmerged path net/ipv6/mcast_snoop.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/core/skbuff.c
* Unmerged path net/ipv4/igmp.c
* Unmerged path net/ipv6/mcast_snoop.c
