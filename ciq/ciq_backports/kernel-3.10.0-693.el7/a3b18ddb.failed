net: Only do flow_dissector hash computation once per packet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] Only do flow_dissector hash computation once per packet (Ivan Vecera) [1382040]
Rebuild_FUZZ: 95.65%
commit-author Tom Herbert <therbert@google.com>
commit a3b18ddb9cc1056eea24e3edc1828cfb3fd0726f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a3b18ddb.failed

Add sw_hash flag to skbuff to indicate that skb->hash was computed
from flow_dissector. This flag is checked in skb_get_hash to avoid
repeatedly trying to compute the hash (ie. in the case that no L4 hash
can be computed).

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a3b18ddb9cc1056eea24e3edc1828cfb3fd0726f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index 449d0a455cd2,890fb3307dd6..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -659,27 -562,28 +660,39 @@@ struct sk_buff 
  #endif
  	__u8			pfmemalloc:1;
  	__u8			ooo_okay:1;
++<<<<<<< HEAD
 +	__u8			RH_KABI_RENAME(l4_rxhash, l4_hash):1;
++=======
+ 	__u8			l4_hash:1;
+ 	__u8			sw_hash:1;
++>>>>>>> a3b18ddb9cc1 (net: Only do flow_dissector hash computation once per packet)
  	__u8			wifi_acked_valid:1;
  	__u8			wifi_acked:1;
  	__u8			no_fcs:1;
  	__u8			head_frag:1;
 -	/* Encapsulation protocol and NIC drivers should use
 -	 * this flag to indicate to each other if the skb contains
 -	 * encapsulated packet or not and maybe use the inner packet
 -	 * headers if needed
 -	 */
 +	/* Indicates the inner headers are valid in the skbuff. */
  	__u8			encapsulation:1;
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(__u8			encap_hdr_csum:1)
 +	RH_KABI_EXTEND(__u8			csum_valid:1)
 +	RH_KABI_EXTEND(__u8			csum_complete_sw:1)
 +	RH_KABI_EXTEND(__u8			xmit_more:1)
 +	RH_KABI_EXTEND(__u8			inner_protocol_type:1)
 +	RH_KABI_EXTEND(__u8			remcsum_offload:1)
 +	/* 0/2 bit hole (depending on ndisc_nodetype presence) */
++=======
+ 	__u8			encap_hdr_csum:1;
+ 	__u8			csum_valid:1;
+ 	__u8			csum_complete_sw:1;
+ 	/* 2/4 bit hole (depending on ndisc_nodetype presence) */
++>>>>>>> a3b18ddb9cc1 (net: Only do flow_dissector hash computation once per packet)
  	kmemcheck_bitfield_end(flags2);
  
 -#if defined CONFIG_NET_DMA || defined CONFIG_NET_RX_BUSY_POLL
 +#if defined CONFIG_NET_DMA_RH_KABI || defined CONFIG_NET_RX_BUSY_POLL || defined CONFIG_XPS
  	union {
  		unsigned int	napi_id;
 -		dma_cookie_t	dma_cookie;
 +		RH_KABI_EXTEND(unsigned int	sender_cpu)
 +		RH_KABI_DEPRECATE(dma_cookie_t,	dma_cookie)
  	};
  #endif
  #ifdef CONFIG_NETWORK_SECMARK
* Unmerged path include/linux/skbuff.h
diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index b6ed85ba825b..f79ec5dfc24c 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -270,6 +270,8 @@ void __skb_get_hash(struct sk_buff *skb)
 	if (keys.ports)
 		skb->l4_hash = 1;
 
+	skb->sw_hash = 1;
+
 	skb->hash = __flow_hash_from_keys(&keys);
 }
 EXPORT_SYMBOL(__skb_get_hash);
