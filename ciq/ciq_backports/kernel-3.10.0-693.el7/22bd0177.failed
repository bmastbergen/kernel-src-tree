powerpc/fadump: remove dependency with CONFIG_KEXEC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [powerpc] fadump: remove dependency with CONFIG_KEXEC (Gustavo Duarte) [1384941]
Rebuild_FUZZ: 91.49%
commit-author Hari Bathini <hbathini@linux.vnet.ibm.com>
commit 22bd0177bd08677a8888f4d1d8361b0326f9119b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/22bd0177.failed

Now that crashkernel parameter parsing and vmcoreinfo related code is
moved under CONFIG_CRASH_CORE instead of CONFIG_KEXEC_CORE, remove
dependency with CONFIG_KEXEC for CONFIG_FA_DUMP.  While here, get rid of
definitions of fadump_append_elf_note() & fadump_final_note() functions
to reuse similar functions compiled under CONFIG_CRASH_CORE.

Link: http://lkml.kernel.org/r/149035343956.6881.1536459326017709354.stgit@hbathini.in.ibm.com
	Signed-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>
	Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
	Acked-by: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Eric Biederman <ebiederm@xmission.com>
	Cc: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 22bd0177bd08677a8888f4d1d8361b0326f9119b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/Kconfig
diff --cc arch/powerpc/Kconfig
index e42024f8779d,d8834e8bfb05..000000000000
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@@ -405,34 -519,71 +405,40 @@@ config KEXE
  
  	  It is an ongoing process to be certain the hardware in a machine
  	  is properly shutdown, so do not be surprised if this code does not
 -	  initially work for you.  As of this writing the exact hardware
 -	  interface is strongly in flux, so no good recommendation can be
 -	  made.
 -
 -config KEXEC_FILE
 -	bool "kexec file based system call"
 -	select KEXEC_CORE
 -	select HAVE_IMA_KEXEC
 -	select BUILD_BIN2C
 -	depends on PPC64
 -	depends on CRYPTO=y
 -	depends on CRYPTO_SHA256=y
 -	help
 -	  This is a new version of the kexec system call. This call is
 -	  file based and takes in file descriptors as system call arguments
 -	  for kernel and initramfs as opposed to a list of segments as is the
 -	  case for the older kexec call.
 -
 -config RELOCATABLE
 -	bool "Build a relocatable kernel"
 -	depends on PPC64 || (FLATMEM && (44x || FSL_BOOKE))
 -	select NONSTATIC_KERNEL
 -	select MODULE_REL_CRCS if MODVERSIONS
 -	help
 -	  This builds a kernel image that is capable of running at the
 -	  location the kernel is loaded at. For ppc32, there is no any
 -	  alignment restrictions, and this feature is a superset of
 -	  DYNAMIC_MEMSTART and hence overrides it. For ppc64, we should use
 -	  16k-aligned base address. The kernel is linked as a
 -	  position-independent executable (PIE) and contains dynamic relocations
 -	  which are processed early in the bootup process.
 -
 -	  One use is for the kexec on panic case where the recovery kernel
 -	  must live at a different physical address than the primary
 -	  kernel.
 -
 -	  Note: If CONFIG_RELOCATABLE=y, then the kernel runs from the address
 -	  it has been loaded at and the compile time physical addresses
 -	  CONFIG_PHYSICAL_START is ignored.  However CONFIG_PHYSICAL_START
 -	  setting can still be useful to bootwrappers that need to know the
 -	  load address of the kernel (eg. u-boot/mkimage).
 +	  initially work for you.  It may help to enable device hotplugging
 +	  support.  As of this writing the exact hardware interface is
 +	  strongly in flux, so no good recommendation can be made.
  
 -config RELOCATABLE_TEST
 -	bool "Test relocatable kernel"
 -	depends on (PPC64 && RELOCATABLE)
 -	default n
 -	help
 -	  This runs the relocatable kernel at the address it was initially
 -	  loaded at, which tends to be non-zero and therefore test the
 -	  relocation code.
 +config KEXEC_AUTO_RESERVE
 +	bool "automatically reserve memory for kexec kernel"
 +	depends on KEXEC
 +	default y
 +	---help---
 +	  Automatically reserve memory for a kexec kernel, so that you don't
 +	  need to specify numbers for the "crashkernel=X@Y" boot option,
 +	  instead you can use "crashkernel=auto". To make this work, you need
 +	  to have more than 2G/8G memory. On PPC, 128M or 256M is reserved, on
 +	  PPC64 1/32 of your physical memory, but it will not exceed 4G.
  
  config CRASH_DUMP
- 	bool "Build a kdump crash kernel"
+ 	bool "Build a dump capture kernel"
  	depends on PPC64 || 6xx || FSL_BOOKE || (44x && !SMP)
 -	select RELOCATABLE if PPC64 || 44x || FSL_BOOKE
 +	select RELOCATABLE if PPC64 || 44x
 +	select DYNAMIC_MEMSTART if FSL_BOOKE
  	help
- 	  Build a kernel suitable for use as a kdump capture kernel.
+ 	  Build a kernel suitable for use as a dump capture kernel.
  	  The same kernel binary can be used as production kernel and dump
  	  capture kernel.
  
  config FA_DUMP
  	bool "Firmware-assisted dump"
++<<<<<<< HEAD
 +	depends on PPC64 && PPC_RTAS && CRASH_DUMP && KEXEC
++=======
+ 	depends on PPC64 && PPC_RTAS
+ 	select CRASH_CORE
+ 	select CRASH_DUMP
++>>>>>>> 22bd0177bd08 (powerpc/fadump: remove dependency with CONFIG_KEXEC)
  	help
  	  A robust mechanism to get reliable kernel crash dump with
  	  assistance from firmware. This approach does not use kexec,
* Unmerged path arch/powerpc/Kconfig
diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 0c6ffc3143da..cea31eb2d4a8 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -77,6 +77,8 @@
 	reg_entry++;							\
 })
 
+extern int crashing_cpu;
+
 /* Kernel Dump section info */
 struct fadump_section {
 	__be32	request_flag;
diff --git a/arch/powerpc/kernel/crash.c b/arch/powerpc/kernel/crash.c
index 51dbace3269b..22ead5c52da2 100644
--- a/arch/powerpc/kernel/crash.c
+++ b/arch/powerpc/kernel/crash.c
@@ -43,8 +43,6 @@
 #define IPI_TIMEOUT		10000
 #define REAL_MODE_TIMEOUT	10000
 
-/* This keeps a track of which one is the crashing cpu. */
-int crashing_cpu = -1;
 static int time_to_dump;
 
 #define CRASH_HANDLER_MAX 3
diff --git a/arch/powerpc/kernel/fadump.c b/arch/powerpc/kernel/fadump.c
index 88972a026ab4..3b13f0202081 100644
--- a/arch/powerpc/kernel/fadump.c
+++ b/arch/powerpc/kernel/fadump.c
@@ -504,34 +504,6 @@ fadump_read_registers(struct fadump_reg_entry *reg_entry, struct pt_regs *regs)
 	return reg_entry;
 }
 
-static u32 *fadump_append_elf_note(u32 *buf, char *name, unsigned type,
-						void *data, size_t data_len)
-{
-	struct elf_note note;
-
-	note.n_namesz = strlen(name) + 1;
-	note.n_descsz = data_len;
-	note.n_type   = type;
-	memcpy(buf, &note, sizeof(note));
-	buf += (sizeof(note) + 3)/4;
-	memcpy(buf, name, note.n_namesz);
-	buf += (note.n_namesz + 3)/4;
-	memcpy(buf, data, note.n_descsz);
-	buf += (note.n_descsz + 3)/4;
-
-	return buf;
-}
-
-static void fadump_final_note(u32 *buf)
-{
-	struct elf_note note;
-
-	note.n_namesz = 0;
-	note.n_descsz = 0;
-	note.n_type   = 0;
-	memcpy(buf, &note, sizeof(note));
-}
-
 static u32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)
 {
 	struct elf_prstatus prstatus;
@@ -542,8 +514,8 @@ static u32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)
 	 * prstatus.pr_pid = ????
 	 */
 	elf_core_copy_kernel_regs(&prstatus.pr_reg, regs);
-	buf = fadump_append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,
-				&prstatus, sizeof(prstatus));
+	buf = append_elf_note(buf, CRASH_CORE_NOTE_NAME, NT_PRSTATUS,
+			      &prstatus, sizeof(prstatus));
 	return buf;
 }
 
@@ -684,7 +656,7 @@ static int __init fadump_build_cpu_notes(const struct fadump_mem_struct *fdm)
 			note_buf = fadump_regs_to_elf_notes(note_buf, &regs);
 		}
 	}
-	fadump_final_note(note_buf);
+	final_note(note_buf);
 
 	if (fdh) {
 		pr_debug("Updating elfcore header (%llx) with cpu notes\n",
diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c
index baa2a3f2bbee..ad196e22c20a 100644
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@ -107,6 +107,11 @@ int ppc_do_canonicalize_irqs;
 EXPORT_SYMBOL(ppc_do_canonicalize_irqs);
 #endif
 
+#ifdef CONFIG_CRASH_CORE
+/* This keeps a track of which one is the crashing cpu. */
+int crashing_cpu = -1;
+#endif
+
 /* also used by kexec */
 void machine_shutdown(void)
 {
