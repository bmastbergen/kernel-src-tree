HID: wacom: put the managed resources in a group

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: put the managed resources in a group (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.51%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 84dfbd7f2a58c8c79ba7947159fc5f2c521348f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/84dfbd7f.failed

We currently have a complex clean_inputs() function while this can be
handled all by devres. Set a group that we can destroy in wireless_work().

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 84dfbd7f2a58c8c79ba7947159fc5f2c521348f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom.h
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom.h
index 87d2c48e3adc,6f5555fa1eab..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -126,19 -125,47 +126,29 @@@ struct wacom 
  		u8 img_lum;   /* OLED matrix display brightness */
  	} led;
  	bool led_initialized;
++<<<<<<< HEAD
 +	struct power_supply battery;
++=======
+ 	struct power_supply *battery;
+ 	struct power_supply *ac;
+ 	struct power_supply_desc battery_desc;
+ 	struct power_supply_desc ac_desc;
+ 	struct kobject *remote_dir;
+ 	struct attribute_group remote_group[5];
+ 	bool resources;
++>>>>>>> 84dfbd7f2a58 (HID: wacom: put the managed resources in a group)
  };
  
 -static inline void wacom_schedule_work(struct wacom_wac *wacom_wac,
 -				       enum wacom_worker which)
 +static inline void wacom_schedule_work(struct wacom_wac *wacom_wac)
  {
  	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
 -
 -	switch (which) {
 -	case WACOM_WORKER_WIRELESS:
 -		schedule_work(&wacom->wireless_work);
 -		break;
 -	case WACOM_WORKER_BATTERY:
 -		schedule_work(&wacom->battery_work);
 -		break;
 -	}
 +	schedule_work(&wacom->work);
  }
  
 -extern const struct hid_device_id wacom_ids[];
 +extern const struct usb_device_id wacom_ids[];
  
  void wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len);
 -void wacom_setup_device_quirks(struct wacom *wacom);
 -int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 -				   struct wacom_wac *wacom_wac);
 -int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 +void wacom_setup_device_quirks(struct wacom_features *features);
 +int wacom_setup_input_capabilities(struct input_dev *input_dev,
  				   struct wacom_wac *wacom_wac);
 -int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
 -				       struct wacom_wac *wacom_wac);
 -void wacom_wac_usage_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage);
 -int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
 -		struct hid_usage *usage, __s32 value);
 -void wacom_wac_report(struct hid_device *hdev, struct hid_report *report);
 -void wacom_battery_work(struct work_struct *work);
 -int wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial,
 -				   int index);
 -void wacom_remote_destroy_attr_group(struct wacom *wacom, __u32 serial);
  #endif
diff --cc drivers/hid/wacom_sys.c
index e75b5002a526,08f6d1f29c73..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1120,150 -1147,328 +1120,194 @@@ static int wacom_initialize_battery(str
  
  static void wacom_destroy_battery(struct wacom *wacom)
  {
 -	if (wacom->battery) {
 -		devres_release_group(&wacom->hdev->dev, &wacom->battery_desc);
 -		wacom->battery = NULL;
 -		wacom->ac = NULL;
 -	}
 -}
 -
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = to_hid_device(dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 -{
 -	struct hid_device *hdev = to_hid_device(dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 -
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 -
 -
 -static ssize_t wacom_show_remote_mode(struct kobject *kobj,
 -				      struct kobj_attribute *kattr,
 -				      char *buf, int index)
 -{
 -	struct device *dev = kobj_to_dev(kobj->parent);
 -	struct hid_device *hdev = to_hid_device(dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 mode;
 -
 -	mode = wacom->led.select[index];
 -	if (mode >= 0 && mode < 3)
 -		return snprintf(buf, PAGE_SIZE, "%d\n", mode);
 -	else
 -		return snprintf(buf, PAGE_SIZE, "%d\n", -1);
 -}
 -
 -#define DEVICE_EKR_ATTR_GROUP(SET_ID)					\
 -static ssize_t wacom_show_remote##SET_ID##_mode(struct kobject *kobj,	\
 -			       struct kobj_attribute *kattr, char *buf)	\
 -{									\
 -	return wacom_show_remote_mode(kobj, kattr, buf, SET_ID);	\
 -}									\
 -static struct kobj_attribute remote##SET_ID##_mode_attr = {		\
 -	.attr = {.name = "remote_mode",					\
 -		.mode = DEV_ATTR_RO_PERM},				\
 -	.show = wacom_show_remote##SET_ID##_mode,			\
 -};									\
 -static struct attribute *remote##SET_ID##_serial_attrs[] = {		\
 -	&remote##SET_ID##_mode_attr.attr,				\
 -	NULL								\
 -};									\
 -static struct attribute_group remote##SET_ID##_serial_group = {		\
 -	.name = NULL,							\
 -	.attrs = remote##SET_ID##_serial_attrs,				\
 -}
 -
 -DEVICE_EKR_ATTR_GROUP(0);
 -DEVICE_EKR_ATTR_GROUP(1);
 -DEVICE_EKR_ATTR_GROUP(2);
 -DEVICE_EKR_ATTR_GROUP(3);
 -DEVICE_EKR_ATTR_GROUP(4);
 -
 -int wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial, int index)
 -{
 -	int error = 0;
 -	char *buf;
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -
 -	wacom_wac->serial[index] = serial;
 -
 -	buf = kzalloc(WAC_REMOTE_SERIAL_MAX_STRLEN, GFP_KERNEL);
 -	if (!buf)
 -		return -ENOMEM;
 -	snprintf(buf, WAC_REMOTE_SERIAL_MAX_STRLEN, "%d", serial);
 -	wacom->remote_group[index].name = buf;
 -
 -	error = sysfs_create_group(wacom->remote_dir,
 -				   &wacom->remote_group[index]);
 -	if (error) {
 -		hid_err(wacom->hdev,
 -			"cannot create sysfs group err: %d\n", error);
 -		kobject_put(wacom->remote_dir);
 -		return error;
 +	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_MONITOR &&
 +	    wacom->battery.dev) {
 +		power_supply_unregister(&wacom->battery);
 +		wacom->battery.dev = NULL;
  	}
 -
 -	return 0;
  }
  
 -void wacom_remote_destroy_attr_group(struct wacom *wacom, __u32 serial)
 -{
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	int i;
 -
 -	if (!serial)
 -		return;
 -
 -	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
 -		if (wacom_wac->serial[i] == serial) {
 -			wacom_wac->serial[i] = 0;
 -			wacom->led.select[i] = WACOM_STATUS_UNKNOWN;
 -			if (wacom->remote_group[i].name) {
 -				sysfs_remove_group(wacom->remote_dir,
 -						   &wacom->remote_group[i]);
 -				kfree(wacom->remote_group[i].name);
 -				wacom->remote_group[i].name = NULL;
 -			}
 -		}
 -	}
 -}
 -
 -static int wacom_cmd_unpair_remote(struct wacom *wacom, unsigned char selector)
 -{
 -	const size_t buf_size = 2;
 -	unsigned char *buf;
 -	int retval;
 -
 -	buf = kzalloc(buf_size, GFP_KERNEL);
 -	if (!buf)
 -		return -ENOMEM;
 -
 -	buf[0] = WAC_CMD_DELETE_PAIRING;
 -	buf[1] = selector;
 -
 -	retval = wacom_set_report(wacom->hdev, HID_OUTPUT_REPORT, buf,
 -				  buf_size, WAC_CMD_RETRIES);
 -	kfree(buf);
 -
 -	return retval;
 -}
 -
 -static ssize_t wacom_store_unpair_remote(struct kobject *kobj,
 -					 struct kobj_attribute *attr,
 -					 const char *buf, size_t count)
 -{
 -	unsigned char selector = 0;
 -	struct device *dev = kobj_to_dev(kobj->parent);
 -	struct hid_device *hdev = to_hid_device(dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	int err;
 -
 -	if (!strncmp(buf, "*\n", 2)) {
 -		selector = WAC_CMD_UNPAIR_ALL;
 -	} else {
 -		hid_info(wacom->hdev, "remote: unrecognized unpair code: %s\n",
 -			 buf);
 -		return -1;
 -	}
 -
 -	mutex_lock(&wacom->lock);
 -
 -	err = wacom_cmd_unpair_remote(wacom, selector);
 -	mutex_unlock(&wacom->lock);
 -
 -	return err < 0 ? err : count;
 -}
 -
 -static struct kobj_attribute unpair_remote_attr = {
 -	.attr = {.name = "unpair_remote", .mode = 0200},
 -	.store = wacom_store_unpair_remote,
 -};
 -
 -static const struct attribute *remote_unpair_attrs[] = {
 -	&unpair_remote_attr.attr,
 -	NULL
 -};
 -
 -static int wacom_initialize_remote(struct wacom *wacom)
 -{
 -	int error = 0;
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -	int i;
 -
 -	if (wacom->wacom_wac.features.type != REMOTE)
 -		return 0;
 -
 -	wacom->remote_group[0] = remote0_serial_group;
 -	wacom->remote_group[1] = remote1_serial_group;
 -	wacom->remote_group[2] = remote2_serial_group;
 -	wacom->remote_group[3] = remote3_serial_group;
 -	wacom->remote_group[4] = remote4_serial_group;
 -
 -	wacom->remote_dir = kobject_create_and_add("wacom_remote",
 -						   &wacom->hdev->dev.kobj);
 -	if (!wacom->remote_dir)
 -		return -ENOMEM;
 -
 -	error = sysfs_create_files(wacom->remote_dir, remote_unpair_attrs);
 -
 -	if (error) {
 -		hid_err(wacom->hdev,
 -			"cannot create sysfs group err: %d\n", error);
 -		return error;
 -	}
 -
 -	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
 -		wacom->led.select[i] = WACOM_STATUS_UNKNOWN;
 -		wacom_wac->serial[i] = 0;
 -	}
 -
 -	return 0;
 -}
 -
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 +static int wacom_register_input(struct wacom *wacom)
  {
  	struct input_dev *input_dev;
 -	struct hid_device *hdev = wacom->hdev;
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 +	int error;
  
 -	input_dev = devm_input_allocate_device(&hdev->dev);
 -	if (!input_dev)
 -		return NULL;
 +	input_dev = input_allocate_device();
 +	if (!input_dev) {
 +		error = -ENOMEM;
 +		goto fail1;
 +	}
  
 -	input_dev->name = wacom_wac->features.name;
 -	input_dev->phys = hdev->phys;
 -	input_dev->dev.parent = &hdev->dev;
 +	input_dev->name = wacom_wac->name;
 +	input_dev->dev.parent = &intf->dev;
  	input_dev->open = wacom_open;
  	input_dev->close = wacom_close;
 -	input_dev->uniq = hdev->uniq;
 -	input_dev->id.bustype = hdev->bus;
 -	input_dev->id.vendor  = hdev->vendor;
 -	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
 -	input_dev->id.version = hdev->version;
 +	usb_to_input_id(dev, &input_dev->id);
  	input_set_drvdata(input_dev, wacom);
  
 -	return input_dev;
 -}
 +	wacom_wac->input = input_dev;
 +	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
 +	if (error)
 +		goto fail1;
  
++<<<<<<< HEAD
 +	error = input_register_device(input_dev);
 +	if (error)
 +		goto fail2;
++=======
+ static int wacom_allocate_inputs(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	wacom_wac->pen_input = wacom_allocate_input(wacom);
+ 	wacom_wac->touch_input = wacom_allocate_input(wacom);
+ 	wacom_wac->pad_input = wacom_allocate_input(wacom);
+ 	if (!wacom_wac->pen_input ||
+ 	    !wacom_wac->touch_input ||
+ 	    !wacom_wac->pad_input)
+ 		return -ENOMEM;
+ 
+ 	wacom_wac->pen_input->name = wacom_wac->pen_name;
+ 	wacom_wac->touch_input->name = wacom_wac->touch_name;
+ 	wacom_wac->pad_input->name = wacom_wac->pad_name;
++>>>>>>> 84dfbd7f2a58 (HID: wacom: put the managed resources in a group)
  
  	return 0;
 +
 +fail2:
 +	input_free_device(input_dev);
 +	wacom_wac->input = NULL;
 +fail1:
 +	return error;
  }
  
 -static int wacom_register_inputs(struct wacom *wacom)
 +static void wacom_wireless_work(struct work_struct *work)
  {
 -	struct input_dev *pen_input_dev, *touch_input_dev, *pad_input_dev;
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -	int error = 0;
 +	struct wacom *wacom = container_of(work, struct wacom, work);
 +	struct usb_device *usbdev = wacom->usbdev;
 +	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 +	struct wacom *wacom1, *wacom2;
 +	struct wacom_wac *wacom_wac1, *wacom_wac2;
 +	int error;
  
 -	pen_input_dev = wacom_wac->pen_input;
 -	touch_input_dev = wacom_wac->touch_input;
 -	pad_input_dev = wacom_wac->pad_input;
 +	/*
 +	 * Regardless if this is a disconnect or a new tablet,
 +	 * remove any existing input and battery devices.
 +	 */
  
 -	if (!pen_input_dev || !touch_input_dev || !pad_input_dev)
 -		return -EINVAL;
 +	wacom_destroy_battery(wacom);
  
 -	error = wacom_setup_pen_input_capabilities(pen_input_dev, wacom_wac);
 -	if (error) {
 -		/* no pen in use on this interface */
 -		input_free_device(pen_input_dev);
 -		wacom_wac->pen_input = NULL;
 -		pen_input_dev = NULL;
 +	/* Stylus interface */
 +	wacom1 = usb_get_intfdata(usbdev->config->interface[1]);
 +	wacom_wac1 = &(wacom1->wacom_wac);
 +	if (wacom_wac1->input)
 +		input_unregister_device(wacom_wac1->input);
 +	wacom_wac1->input = NULL;
 +
 +	/* Touch interface */
 +	wacom2 = usb_get_intfdata(usbdev->config->interface[2]);
 +	wacom_wac2 = &(wacom2->wacom_wac);
 +	if (wacom_wac2->input)
 +		input_unregister_device(wacom_wac2->input);
 +	wacom_wac2->input = NULL;
 +
 +	if (wacom_wac->pid == 0) {
 +		dev_info(&wacom->intf->dev, "wireless tablet disconnected\n");
  	} else {
 -		error = input_register_device(pen_input_dev);
 +		const struct usb_device_id *id = wacom_ids;
 +
 +		dev_info(&wacom->intf->dev,
 +			 "wireless tablet connected with PID %x\n",
 +			 wacom_wac->pid);
 +
 +		while (id->match_flags) {
 +			if (id->idVendor == USB_VENDOR_ID_WACOM &&
 +			    id->idProduct == wacom_wac->pid)
 +				break;
 +			id++;
 +		}
 +
 +		if (!id->match_flags) {
 +			dev_info(&wacom->intf->dev,
 +				 "ignoring unknown PID.\n");
 +			return;
 +		}
 +
 +		/* Stylus interface */
 +		wacom_wac1->features =
 +			*((struct wacom_features *)id->driver_info);
 +		wacom_wac1->features.device_type = BTN_TOOL_PEN;
 +		snprintf(wacom_wac1->name, WACOM_NAME_MAX, "%s (WL) Pen",
 +			 wacom_wac1->features.name);
 +		error = wacom_register_input(wacom1);
  		if (error)
  			goto fail;
++<<<<<<< HEAD
++=======
+ 	}
++>>>>>>> 84dfbd7f2a58 (HID: wacom: put the managed resources in a group)
  
 -	error = wacom_setup_touch_input_capabilities(touch_input_dev, wacom_wac);
 -	if (error) {
 -		/* no touch in use on this interface */
 -		input_free_device(touch_input_dev);
 -		wacom_wac->touch_input = NULL;
 -		touch_input_dev = NULL;
 -	} else {
 -		error = input_register_device(touch_input_dev);
 +		/* Touch interface */
 +		if (wacom_wac1->features.touch_max) {
 +			wacom_wac2->features =
 +				*((struct wacom_features *)id->driver_info);
 +			wacom_wac2->features.pktlen = WACOM_PKGLEN_BBTOUCH3;
 +			wacom_wac2->features.device_type = BTN_TOOL_FINGER;
 +			wacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;
 +			if (wacom_wac2->features.touch_max)
 +				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
 +					 "%s (WL) Finger",wacom_wac2->features.name);
 +			else
 +				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
 +					 "%s (WL) Pad",wacom_wac2->features.name);
 +			error = wacom_register_input(wacom2);
 +			if (error)
 +				goto fail;
 +		}
 +
 +		error = wacom_initialize_battery(wacom);
  		if (error)
  			goto fail;
  	}
  
++<<<<<<< HEAD
 +	return;
 +
 +fail:
 +	if (wacom_wac2->input) {
 +		input_unregister_device(wacom_wac2->input);
 +		wacom_wac2->input = NULL;
 +	}
 +
 +	if (wacom_wac1->input) {
 +		input_unregister_device(wacom_wac1->input);
 +		wacom_wac1->input = NULL;
 +	}
 +	return;
++=======
+ 	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pad in use on this interface */
+ 		input_free_device(pad_input_dev);
+ 		wacom_wac->pad_input = NULL;
+ 		pad_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pad_input_dev);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ 
+ fail:
+ 	wacom_wac->pad_input = NULL;
+ 	wacom_wac->touch_input = NULL;
+ 	wacom_wac->pen_input = NULL;
+ 	return error;
++>>>>>>> 84dfbd7f2a58 (HID: wacom: put the managed resources in a group)
  }
  
  /*
@@@ -1293,10 -1504,339 +1337,343 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -void wacom_battery_work(struct work_struct *work)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct wacom *wacom = container_of(work, struct wacom, battery_work);
+ 
+ 	if ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 	     !wacom->battery) {
+ 		wacom_initialize_battery(wacom);
+ 	}
+ 	else if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery) {
+ 		wacom_destroy_battery(wacom);
+ 	}
+ }
+ 
+ static size_t wacom_compute_pktlen(struct hid_device *hdev)
+ {
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom, const char *suffix)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	char name[WACOM_NAME_MAX];
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(name, wacom->hdev->name, sizeof(name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (name[strlen(name)-1] == ' ')
+ 				name[strlen(name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(name, sizeof(name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(name, features->name, sizeof(name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),
+ 		"%s%s Pen", name, suffix);
+ 	snprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),
+ 		"%s%s Finger", name, suffix);
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s%s Pad", name, suffix);
+ }
+ 
+ static void wacom_release_resources(struct wacom *wacom)
+ {
+ 	struct hid_device *hdev = wacom->hdev;
+ 
+ 	if (!wacom->resources)
+ 		return;
+ 
+ 	devres_release_group(&hdev->dev, wacom);
+ 
+ 	wacom->resources = false;
+ 
+ 	wacom->wacom_wac.pen_input = NULL;
+ 	wacom->wacom_wac.touch_input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ }
+ 
+ static int wacom_parse_and_register(struct wacom *wacom, bool wireless)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	struct hid_device *hdev = wacom->hdev;
+ 	int error;
+ 	unsigned int connect_mask = HID_CONNECT_HIDRAW;
+ 
+ 	features->pktlen = wacom_compute_pktlen(hdev);
+ 	if (features->pktlen > WACOM_PKGLEN_MAX)
+ 		return -EINVAL;
+ 
+ 	if (!devres_open_group(&hdev->dev, wacom, GFP_KERNEL))
+ 		return -ENOMEM;
+ 
+ 	wacom->resources = true;
+ 
+ 	error = wacom_allocate_inputs(wacom);
+ 	if (error)
+ 		goto fail_open_group;
+ 
+ 	/*
+ 	 * Bamboo Pad has a generic hid handling for the Pen, and we switch it
+ 	 * into debug mode for the touch part.
+ 	 * We ignore the other interfaces.
+ 	 */
+ 	if (features->type == BAMBOO_PAD) {
+ 		if (features->pktlen == WACOM_PKGLEN_PENABLED) {
+ 			features->type = HID_GENERIC;
+ 		} else if ((features->pktlen != WACOM_PKGLEN_BPAD_TOUCH) &&
+ 			   (features->pktlen != WACOM_PKGLEN_BPAD_TOUCH_USB)) {
+ 			error = -ENODEV;
+ 			goto fail_allocate_inputs;
+ 		}
+ 	}
+ 
+ 	/* set the default size in case we do not get them from hid */
+ 	wacom_set_default_phy(features);
+ 
+ 	/* Retrieve the physical and logical size for touch devices */
+ 	wacom_retrieve_hid_descriptor(hdev, features);
+ 	wacom_setup_device_quirks(wacom);
+ 
+ 	if (features->device_type == WACOM_DEVICETYPE_NONE &&
+ 	    features->type != WIRELESS) {
+ 		error = features->type == HID_GENERIC ? -ENODEV : 0;
+ 
+ 		dev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",
+ 			 hdev->name,
+ 			 error ? "Ignoring" : "Assuming pen");
+ 
+ 		if (error)
+ 			goto fail_parsed;
+ 
+ 		features->device_type |= WACOM_DEVICETYPE_PEN;
+ 	}
+ 
+ 	wacom_calculate_res(features);
+ 
+ 	wacom_update_name(wacom, wireless ? " (WL)" : "");
+ 
+ 	error = wacom_add_shared_data(hdev);
+ 	if (error)
+ 		goto fail_shared_data;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_WL_MONITOR) &&
+ 	     (features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail_battery;
+ 	}
+ 
+ 	error = wacom_register_inputs(wacom);
+ 	if (error)
+ 		goto fail_register_inputs;
+ 
+ 	if (wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD) {
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail_leds;
+ 
+ 		error = wacom_initialize_remote(wacom);
+ 		if (error)
+ 			goto fail_remote;
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		connect_mask |= HID_CONNECT_DRIVER;
+ 
+ 	/* Regular HID work starts now */
+ 	error = hid_hw_start(hdev, connect_mask);
+ 	if (error) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto fail_hw_start;
+ 	}
+ 
+ 	if (!wireless) {
+ 		/* Note that if query fails it is not a hard failure */
+ 		wacom_query_tablet_data(hdev, features);
+ 	}
+ 
+ 	/* touch only Bamboo doesn't support pen */
+ 	if ((features->type == BAMBOO_TOUCH) &&
+ 	    (features->device_type & WACOM_DEVICETYPE_PEN)) {
+ 		error = -ENODEV;
+ 		goto fail_quirks;
+ 	}
+ 
+ 	/* pen only Bamboo neither support touch nor pad */
+ 	if ((features->type == BAMBOO_PEN) &&
+ 	    ((features->device_type & WACOM_DEVICETYPE_TOUCH) ||
+ 	    (features->device_type & WACOM_DEVICETYPE_PAD))) {
+ 		error = -ENODEV;
+ 		goto fail_quirks;
+ 	}
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)
+ 		error = hid_hw_open(hdev);
+ 
+ 	if ((wacom_wac->features.type == INTUOSHT ||
+ 	     wacom_wac->features.type == INTUOSHT2) &&
+ 	    (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)) {
+ 		wacom_wac->shared->type = wacom_wac->features.type;
+ 		wacom_wac->shared->touch_input = wacom_wac->touch_input;
+ 	}
+ 
+ 	devres_close_group(&hdev->dev, wacom);
+ 
+ 	return 0;
+ 
+ fail_quirks:
+ 	hid_hw_stop(hdev);
+ fail_hw_start:
+ 	kobject_put(wacom->remote_dir);
+ fail_remote:
+ 	wacom_destroy_leds(wacom);
+ fail_leds:
+ fail_register_inputs:
+ fail_battery:
+ 	wacom_remove_shared_data(wacom);
+ fail_shared_data:
+ fail_parsed:
+ fail_allocate_inputs:
+ fail_open_group:
+ 	wacom_release_resources(wacom);
+ 	return error;
+ }
+ 
+ static void wacom_wireless_work(struct work_struct *work)
+ {
+ 	struct wacom *wacom = container_of(work, struct wacom, wireless_work);
+ 	struct usb_device *usbdev = wacom->usbdev;
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_device *hdev1, *hdev2;
+ 	struct wacom *wacom1, *wacom2;
+ 	struct wacom_wac *wacom_wac1, *wacom_wac2;
+ 	int error;
+ 
+ 	/*
+ 	 * Regardless if this is a disconnect or a new tablet,
+ 	 * remove any existing input and battery devices.
+ 	 */
+ 
+ 	wacom_destroy_battery(wacom);
+ 
+ 	/* Stylus interface */
+ 	hdev1 = usb_get_intfdata(usbdev->config->interface[1]);
+ 	wacom1 = hid_get_drvdata(hdev1);
+ 	wacom_wac1 = &(wacom1->wacom_wac);
+ 	wacom_destroy_leds(wacom1);
+ 	wacom_release_resources(wacom1);
+ 
+ 	/* Touch interface */
+ 	hdev2 = usb_get_intfdata(usbdev->config->interface[2]);
+ 	wacom2 = hid_get_drvdata(hdev2);
+ 	wacom_wac2 = &(wacom2->wacom_wac);
+ 	wacom_destroy_leds(wacom2);
+ 	wacom_release_resources(wacom2);
+ 
+ 	if (wacom_wac->pid == 0) {
+ 		hid_info(wacom->hdev, "wireless tablet disconnected\n");
+ 		wacom_wac1->shared->type = 0;
+ 	} else {
+ 		const struct hid_device_id *id = wacom_ids;
+ 
+ 		hid_info(wacom->hdev, "wireless tablet connected with PID %x\n",
+ 			 wacom_wac->pid);
+ 
+ 		while (id->bus) {
+ 			if (id->vendor == USB_VENDOR_ID_WACOM &&
+ 			    id->product == wacom_wac->pid)
+ 				break;
+ 			id++;
+ 		}
+ 
+ 		if (!id->bus) {
+ 			hid_info(wacom->hdev, "ignoring unknown PID.\n");
+ 			return;
+ 		}
+ 
+ 		/* Stylus interface */
+ 		wacom_wac1->features =
+ 			*((struct wacom_features *)id->driver_data);
+ 
+ 		wacom_wac1->pid = wacom_wac->pid;
+ 		hid_hw_stop(hdev1);
+ 		error = wacom_parse_and_register(wacom1, true);
+ 		if (error)
+ 			goto fail;
+ 
+ 		/* Touch interface */
+ 		if (wacom_wac1->features.touch_max ||
+ 		    (wacom_wac1->features.type >= INTUOSHT &&
+ 		    wacom_wac1->features.type <= BAMBOO_PT)) {
+ 			wacom_wac2->features =
+ 				*((struct wacom_features *)id->driver_data);
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			hid_hw_stop(hdev2);
+ 			error = wacom_parse_and_register(wacom2, true);
+ 			if (error)
+ 				goto fail;
+ 		}
+ 
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	return;
+ 
+ fail:
+ 	wacom_destroy_leds(wacom1);
+ 	wacom_release_resources(wacom1);
+ 	wacom_destroy_leds(wacom2);
+ 	wacom_release_resources(wacom2);
+ 	return;
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> 84dfbd7f2a58 (HID: wacom: put the managed resources in a group)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
diff --cc drivers/hid/wacom_wac.c
index 98c7d65145c2,3e2c90323326..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1181,49 -1538,391 +1181,57 @@@ static void wacom_bpt3_touch_msg(struc
  	}
  }
  
 -static void wacom_wac_finger_usage_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage)
 +static void wacom_bpt3_button_msg(struct wacom_wac *wacom, unsigned char *data)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct wacom_features *features = &wacom_wac->features;
 -	struct input_dev *input = wacom_wac->touch_input;
 -	unsigned touch_max = wacom_wac->features.touch_max;
 -
 -	switch (usage->hid) {
 -	case HID_GD_X:
 -		features->last_slot_field = usage->hid;
 -		if (touch_max == 1)
 -			wacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);
 -		else
 -			wacom_map_usage(input, usage, field, EV_ABS,
 -					ABS_MT_POSITION_X, 4);
 -		break;
 -	case HID_GD_Y:
 -		features->last_slot_field = usage->hid;
 -		if (touch_max == 1)
 -			wacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);
 -		else
 -			wacom_map_usage(input, usage, field, EV_ABS,
 -					ABS_MT_POSITION_Y, 4);
 -		break;
 -	case HID_DG_WIDTH:
 -	case HID_DG_HEIGHT:
 -		features->last_slot_field = usage->hid;
 -		wacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
 -		wacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MINOR, 0);
 -		input_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);
 -		break;
 -	case HID_DG_CONTACTID:
 -		features->last_slot_field = usage->hid;
 -		break;
 -	case HID_DG_INRANGE:
 -		features->last_slot_field = usage->hid;
 -		break;
 -	case HID_DG_INVERT:
 -		features->last_slot_field = usage->hid;
 -		break;
 -	case HID_DG_TIPSWITCH:
 -		features->last_slot_field = usage->hid;
 -		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);
 -		break;
 -	case HID_DG_CONTACTCOUNT:
 -		wacom_wac->hid_data.cc_report = field->report->id;
 -		wacom_wac->hid_data.cc_index = field->index;
 -		wacom_wac->hid_data.cc_value_index = usage->usage_index;
 -		break;
 -	}
 +	struct input_dev *input = wacom->input;
 +
 +	input_report_key(input, BTN_LEFT, (data[1] & 0x08) != 0);
 +	input_report_key(input, BTN_FORWARD, (data[1] & 0x04) != 0);
 +	input_report_key(input, BTN_BACK, (data[1] & 0x02) != 0);
 +	input_report_key(input, BTN_RIGHT, (data[1] & 0x01) != 0);
  }
  
 -static void wacom_wac_finger_slot(struct wacom_wac *wacom_wac,
 -		struct input_dev *input)
 +static int wacom_bpt3_touch(struct wacom_wac *wacom)
  {
 -	struct hid_data *hid_data = &wacom_wac->hid_data;
 -	bool mt = wacom_wac->features.touch_max > 1;
 -	bool prox = hid_data->tipswitch &&
 -		    !wacom_wac->shared->stylus_in_proximity;
 +	struct input_dev *input = wacom->input;
 +	unsigned char *data = wacom->data;
 +	int count = data[1] & 0x07;
 +	int i;
  
 -	wacom_wac->hid_data.num_received++;
 -	if (wacom_wac->hid_data.num_received > wacom_wac->hid_data.num_expected)
 -		return;
 +	if (data[0] != 0x02)
 +	    return 0;
 +
 +	/* data has up to 7 fixed sized 8-byte messages starting at data[2] */
 +	for (i = 0; i < count; i++) {
 +		int offset = (8 * i) + 2;
 +		int msg_id = data[offset];
  
 -	if (mt) {
 -		int slot;
 +		if (msg_id >= 2 && msg_id <= 17)
 +			wacom_bpt3_touch_msg(wacom, data + offset);
 +		else if (msg_id == 128)
 +			wacom_bpt3_button_msg(wacom, data + offset);
  
 -		slot = input_mt_get_slot_by_key(input, hid_data->id);
 -		input_mt_slot(input, slot);
 -		input_mt_report_slot_state(input, MT_TOOL_FINGER, prox);
 -	}
 -	else {
 -		input_report_key(input, BTN_TOUCH, prox);
  	}
 +	input_mt_sync_frame(input);
  
 -	if (prox) {
 -		input_report_abs(input, mt ? ABS_MT_POSITION_X : ABS_X,
 -				 hid_data->x);
 -		input_report_abs(input, mt ? ABS_MT_POSITION_Y : ABS_Y,
 -				 hid_data->y);
 -
 -		if (test_bit(ABS_MT_TOUCH_MAJOR, input->absbit)) {
 -			input_report_abs(input, ABS_MT_TOUCH_MAJOR, max(hid_data->width, hid_data->height));
 -			input_report_abs(input, ABS_MT_TOUCH_MINOR, min(hid_data->width, hid_data->height));
 -			if (hid_data->width != hid_data->height)
 -				input_report_abs(input, ABS_MT_ORIENTATION, hid_data->width <= hid_data->height ? 0 : 1);
 -		}
++<<<<<<< HEAD
 +	input_sync(input);
++=======
++	/* only update touch if we actually have a touchpad and touch data changed */
++	if (wacom->touch_input && touch_changed) {
++		input_mt_sync_frame(wacom->touch_input);
++		wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
+ 	}
++>>>>>>> 84dfbd7f2a58 (HID: wacom: put the managed resources in a group)
 +
 +	return 0;
  }
  
 -static int wacom_wac_finger_event(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage, __s32 value)
 +static int wacom_bpt_pen(struct wacom_wac *wacom)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -
 -	switch (usage->hid) {
 -	case HID_GD_X:
 -		wacom_wac->hid_data.x = value;
 -		break;
 -	case HID_GD_Y:
 -		wacom_wac->hid_data.y = value;
 -		break;
 -	case HID_DG_WIDTH:
 -		wacom_wac->hid_data.width = value;
 -		break;
 -	case HID_DG_HEIGHT:
 -		wacom_wac->hid_data.height = value;
 -		break;
 -	case HID_DG_CONTACTID:
 -		wacom_wac->hid_data.id = value;
 -		break;
 -	case HID_DG_TIPSWITCH:
 -		wacom_wac->hid_data.tipswitch = value;
 -		break;
 -	}
 -
 -
 -	if (usage->usage_index + 1 == field->report_count) {
 -		if (usage->hid == wacom_wac->features.last_slot_field)
 -			wacom_wac_finger_slot(wacom_wac, wacom_wac->touch_input);
 -	}
 -
 -	return 0;
 -}
 -
 -static void wacom_wac_finger_pre_report(struct hid_device *hdev,
 -		struct hid_report *report)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct hid_data* hid_data = &wacom_wac->hid_data;
 -
 -	if (hid_data->cc_report != 0 &&
 -	    hid_data->cc_report != report->id) {
 -		int i;
 -
 -		hid_data->cc_report = report->id;
 -		hid_data->cc_index = -1;
 -		hid_data->cc_value_index = -1;
 -
 -		for (i = 0; i < report->maxfield; i++) {
 -			struct hid_field *field = report->field[i];
 -			int j;
 -
 -			for (j = 0; j < field->maxusage; j++) {
 -				if (field->usage[j].hid == HID_DG_CONTACTCOUNT) {
 -					hid_data->cc_index = i;
 -					hid_data->cc_value_index = j;
 -
 -					/* break */
 -					i = report->maxfield;
 -					j = field->maxusage;
 -				}
 -			}
 -		}
 -	}
 -	if (hid_data->cc_report != 0 &&
 -	    hid_data->cc_index >= 0) {
 -		struct hid_field *field = report->field[hid_data->cc_index];
 -		int value = field->value[hid_data->cc_value_index];
 -		if (value)
 -			hid_data->num_expected = value;
 -	}
 -	else {
 -		hid_data->num_expected = wacom_wac->features.touch_max;
 -	}
 -}
 -
 -static void wacom_wac_finger_report(struct hid_device *hdev,
 -		struct hid_report *report)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct input_dev *input = wacom_wac->touch_input;
 -	unsigned touch_max = wacom_wac->features.touch_max;
 -
 -	/* If more packets of data are expected, give us a chance to
 -	 * process them rather than immediately syncing a partial
 -	 * update.
 -	 */
 -	if (wacom_wac->hid_data.num_received < wacom_wac->hid_data.num_expected)
 -		return;
 -
 -	if (touch_max > 1)
 -		input_mt_sync_frame(input);
 -
 -	input_sync(input);
 -	wacom_wac->hid_data.num_received = 0;
 -
 -	/* keep touch state for pen event */
 -	wacom_wac->shared->touch_down = wacom_wac_finger_count_touches(wacom_wac);
 -}
 -
 -void wacom_wac_usage_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -
 -	/* currently, only direct devices have proper hid report descriptors */
 -	__set_bit(INPUT_PROP_DIRECT, wacom_wac->pen_input->propbit);
 -	__set_bit(INPUT_PROP_DIRECT, wacom_wac->touch_input->propbit);
 -
 -	if (WACOM_PEN_FIELD(field))
 -		return wacom_wac_pen_usage_mapping(hdev, field, usage);
 -
 -	if (WACOM_FINGER_FIELD(field))
 -		return wacom_wac_finger_usage_mapping(hdev, field, usage);
 -}
 -
 -int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
 -		struct hid_usage *usage, __s32 value)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	if (wacom->wacom_wac.features.type != HID_GENERIC)
 -		return 0;
 -
 -	if (WACOM_PEN_FIELD(field))
 -		return wacom_wac_pen_event(hdev, field, usage, value);
 -
 -	if (WACOM_FINGER_FIELD(field))
 -		return wacom_wac_finger_event(hdev, field, usage, value);
 -
 -	return 0;
 -}
 -
 -static void wacom_report_events(struct hid_device *hdev, struct hid_report *report)
 -{
 -	int r;
 -
 -	for (r = 0; r < report->maxfield; r++) {
 -		struct hid_field *field;
 -		unsigned count, n;
 -
 -		field = report->field[r];
 -		count = field->report_count;
 -
 -		if (!(HID_MAIN_ITEM_VARIABLE & field->flags))
 -			continue;
 -
 -		for (n = 0; n < count; n++)
 -			wacom_wac_event(hdev, field, &field->usage[n], field->value[n]);
 -	}
 -}
 -
 -void wacom_wac_report(struct hid_device *hdev, struct hid_report *report)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct hid_field *field = report->field[0];
 -
 -	if (wacom_wac->features.type != HID_GENERIC)
 -		return;
 -
 -	if (WACOM_PEN_FIELD(field))
 -		wacom_wac_pen_pre_report(hdev, report);
 -
 -	if (WACOM_FINGER_FIELD(field))
 -		wacom_wac_finger_pre_report(hdev, report);
 -
 -	wacom_report_events(hdev, report);
 -
 -	if (WACOM_PEN_FIELD(field))
 -		return wacom_wac_pen_report(hdev, report);
 -
 -	if (WACOM_FINGER_FIELD(field))
 -		return wacom_wac_finger_report(hdev, report);
 -}
 -
 -static int wacom_bpt_touch(struct wacom_wac *wacom)
 -{
 -	struct wacom_features *features = &wacom->features;
 -	struct input_dev *input = wacom->touch_input;
 -	struct input_dev *pad_input = wacom->pad_input;
 -	unsigned char *data = wacom->data;
 -	int i;
 -
 -	if (data[0] != 0x02)
 -	    return 0;
 -
 -	for (i = 0; i < 2; i++) {
 -		int offset = (data[1] & 0x80) ? (8 * i) : (9 * i);
 -		bool touch = data[offset + 3] & 0x80;
 -
 -		/*
 -		 * Touch events need to be disabled while stylus is
 -		 * in proximity because user's hand is resting on touchpad
 -		 * and sending unwanted events.  User expects tablet buttons
 -		 * to continue working though.
 -		 */
 -		touch = touch && !wacom->shared->stylus_in_proximity;
 -
 -		input_mt_slot(input, i);
 -		input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
 -		if (touch) {
 -			int x = get_unaligned_be16(&data[offset + 3]) & 0x7ff;
 -			int y = get_unaligned_be16(&data[offset + 5]) & 0x7ff;
 -			if (features->quirks & WACOM_QUIRK_BBTOUCH_LOWRES) {
 -				x <<= 5;
 -				y <<= 5;
 -			}
 -			input_report_abs(input, ABS_MT_POSITION_X, x);
 -			input_report_abs(input, ABS_MT_POSITION_Y, y);
 -		}
 -	}
 -
 -	input_mt_sync_frame(input);
 -
 -	input_report_key(pad_input, BTN_LEFT, (data[1] & 0x08) != 0);
 -	input_report_key(pad_input, BTN_FORWARD, (data[1] & 0x04) != 0);
 -	input_report_key(pad_input, BTN_BACK, (data[1] & 0x02) != 0);
 -	input_report_key(pad_input, BTN_RIGHT, (data[1] & 0x01) != 0);
 -	wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
 -
 -	return 1;
 -}
 -
 -static void wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data)
 -{
 -	struct wacom_features *features = &wacom->features;
 -	struct input_dev *input = wacom->touch_input;
 -	bool touch = data[1] & 0x80;
 -	int slot = input_mt_get_slot_by_key(input, data[0]);
 -
 -	if (slot < 0)
 -		return;
 -
 -	touch = touch && !wacom->shared->stylus_in_proximity;
 -
 -	input_mt_slot(input, slot);
 -	input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
 -
 -	if (touch) {
 -		int x = (data[2] << 4) | (data[4] >> 4);
 -		int y = (data[3] << 4) | (data[4] & 0x0f);
 -		int width, height;
 -
 -		if (features->type >= INTUOSPS && features->type <= INTUOSHT2) {
 -			width  = data[5] * 100;
 -			height = data[6] * 100;
 -		} else {
 -			/*
 -			 * "a" is a scaled-down area which we assume is
 -			 * roughly circular and which can be described as:
 -			 * a=(pi*r^2)/C.
 -			 */
 -			int a = data[5];
 -			int x_res = input_abs_get_res(input, ABS_MT_POSITION_X);
 -			int y_res = input_abs_get_res(input, ABS_MT_POSITION_Y);
 -			width = 2 * int_sqrt(a * WACOM_CONTACT_AREA_SCALE);
 -			height = width * y_res / x_res;
 -		}
 -
 -		input_report_abs(input, ABS_MT_POSITION_X, x);
 -		input_report_abs(input, ABS_MT_POSITION_Y, y);
 -		input_report_abs(input, ABS_MT_TOUCH_MAJOR, width);
 -		input_report_abs(input, ABS_MT_TOUCH_MINOR, height);
 -	}
 -}
 -
 -static void wacom_bpt3_button_msg(struct wacom_wac *wacom, unsigned char *data)
 -{
 -	struct input_dev *input = wacom->pad_input;
 -	struct wacom_features *features = &wacom->features;
 -
 -	if (features->type == INTUOSHT || features->type == INTUOSHT2) {
 -		input_report_key(input, BTN_LEFT, (data[1] & 0x02) != 0);
 -		input_report_key(input, BTN_BACK, (data[1] & 0x08) != 0);
 -	} else {
 -		input_report_key(input, BTN_BACK, (data[1] & 0x02) != 0);
 -		input_report_key(input, BTN_LEFT, (data[1] & 0x08) != 0);
 -	}
 -	input_report_key(input, BTN_FORWARD, (data[1] & 0x04) != 0);
 -	input_report_key(input, BTN_RIGHT, (data[1] & 0x01) != 0);
 -}
 -
 -static int wacom_bpt3_touch(struct wacom_wac *wacom)
 -{
 -	unsigned char *data = wacom->data;
 -	int count = data[1] & 0x07;
 -	int  touch_changed = 0, i;
 +	struct input_dev *input = wacom->input;
 +	unsigned char *data = wacom->data;
 +	int prox = 0, x = 0, y = 0, p = 0, d = 0, pen = 0, btn1 = 0, btn2 = 0;
  
  	if (data[0] != 0x02)
  	    return 0;
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,d5b973d0567c..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -138,14 -194,46 +138,20 @@@ struct wacom_shared 
  };
  
  struct wacom_wac {
 -	char pen_name[WACOM_NAME_MAX];
 -	char touch_name[WACOM_NAME_MAX];
 -	char pad_name[WACOM_NAME_MAX];
 -	char bat_name[WACOM_NAME_MAX];
 -	char ac_name[WACOM_NAME_MAX];
 -	unsigned char data[WACOM_PKGLEN_MAX];
 +	char name[WACOM_NAME_MAX];
 +	unsigned char *data;
  	int tool[2];
  	int id[2];
 -	__u32 serial[5];
 -	bool reporting_data;
 +	__u32 serial[2];
  	struct wacom_features features;
  	struct wacom_shared *shared;
++<<<<<<< HEAD
 +	struct input_dev *input;
++=======
+ 	struct input_dev *pen_input;
+ 	struct input_dev *touch_input;
+ 	struct input_dev *pad_input;
++>>>>>>> 84dfbd7f2a58 (HID: wacom: put the managed resources in a group)
  	int pid;
  	int battery_capacity;
  	int num_contacts_left;
* Unmerged path drivers/hid/wacom.h
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
