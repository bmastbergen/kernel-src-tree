nvme.h: resync with nvme-cli

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Christoph Hellwig <hch@lst.de>
commit a446c0840e244f34c22cc13b3a62d50aa51fb4c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a446c084.failed

Import a few updates to nvme.h from nvme-cli.  This mostly includes a few
new fields and error codes, but also a few renames that so far are only
used in user space.  Also one field is moved from an array of two le64
values to one of 16 u8 values so that we can more easily access it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Reviewed-by: Gabriel Krisman Bertazi <krisman@linux.vnet.ibm.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit a446c0840e244f34c22cc13b3a62d50aa51fb4c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/admin-cmd.c
#	drivers/nvme/target/discovery.c
#	include/linux/nvme.h
diff --cc include/linux/nvme.h
index 69a54c418685,989699641e10..000000000000
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@@ -577,6 -716,126 +586,129 @@@ struct nvme_get_log_page_command 
  	__u32			rsvd14[2];
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * Fabrics subcommands.
+  */
+ enum nvmf_fabrics_opcode {
+ 	nvme_fabrics_command		= 0x7f,
+ };
+ 
+ enum nvmf_capsule_command {
+ 	nvme_fabrics_type_property_set	= 0x00,
+ 	nvme_fabrics_type_connect	= 0x01,
+ 	nvme_fabrics_type_property_get	= 0x04,
+ };
+ 
+ struct nvmf_common_command {
+ 	__u8	opcode;
+ 	__u8	resv1;
+ 	__u16	command_id;
+ 	__u8	fctype;
+ 	__u8	resv2[35];
+ 	__u8	ts[24];
+ };
+ 
+ /*
+  * The legal cntlid range a NVMe Target will provide.
+  * Note that cntlid of value 0 is considered illegal in the fabrics world.
+  * Devices based on earlier specs did not have the subsystem concept;
+  * therefore, those devices had their cntlid value set to 0 as a result.
+  */
+ #define NVME_CNTLID_MIN		1
+ #define NVME_CNTLID_MAX		0xffef
+ #define NVME_CNTLID_DYNAMIC	0xffff
+ 
+ #define MAX_DISC_LOGS	255
+ 
+ /* Discovery log page entry */
+ struct nvmf_disc_rsp_page_entry {
+ 	__u8		trtype;
+ 	__u8		adrfam;
+ 	__u8		subtype;
+ 	__u8		treq;
+ 	__le16		portid;
+ 	__le16		cntlid;
+ 	__le16		asqsz;
+ 	__u8		resv8[22];
+ 	char		trsvcid[NVMF_TRSVCID_SIZE];
+ 	__u8		resv64[192];
+ 	char		subnqn[NVMF_NQN_FIELD_LEN];
+ 	char		traddr[NVMF_TRADDR_SIZE];
+ 	union tsas {
+ 		char		common[NVMF_TSAS_SIZE];
+ 		struct rdma {
+ 			__u8	qptype;
+ 			__u8	prtype;
+ 			__u8	cms;
+ 			__u8	resv3[5];
+ 			__u16	pkey;
+ 			__u8	resv10[246];
+ 		} rdma;
+ 	} tsas;
+ };
+ 
+ /* Discovery log page header */
+ struct nvmf_disc_rsp_page_hdr {
+ 	__le64		genctr;
+ 	__le64		numrec;
+ 	__le16		recfmt;
+ 	__u8		resv14[1006];
+ 	struct nvmf_disc_rsp_page_entry entries[0];
+ };
+ 
+ struct nvmf_connect_command {
+ 	__u8		opcode;
+ 	__u8		resv1;
+ 	__u16		command_id;
+ 	__u8		fctype;
+ 	__u8		resv2[19];
+ 	union nvme_data_ptr dptr;
+ 	__le16		recfmt;
+ 	__le16		qid;
+ 	__le16		sqsize;
+ 	__u8		cattr;
+ 	__u8		resv3;
+ 	__le32		kato;
+ 	__u8		resv4[12];
+ };
+ 
+ struct nvmf_connect_data {
+ 	uuid_be		hostid;
+ 	__le16		cntlid;
+ 	char		resv4[238];
+ 	char		subsysnqn[NVMF_NQN_FIELD_LEN];
+ 	char		hostnqn[NVMF_NQN_FIELD_LEN];
+ 	char		resv5[256];
+ };
+ 
+ struct nvmf_property_set_command {
+ 	__u8		opcode;
+ 	__u8		resv1;
+ 	__u16		command_id;
+ 	__u8		fctype;
+ 	__u8		resv2[35];
+ 	__u8		attrib;
+ 	__u8		resv3[3];
+ 	__le32		offset;
+ 	__le64		value;
+ 	__u8		resv4[8];
+ };
+ 
+ struct nvmf_property_get_command {
+ 	__u8		opcode;
+ 	__u8		resv1;
+ 	__u16		command_id;
+ 	__u8		fctype;
+ 	__u8		resv2[35];
+ 	__u8		attrib;
+ 	__u8		resv3[3];
+ 	__le32		offset;
+ 	__u8		resv4[16];
+ };
+ 
++>>>>>>> a446c0840e24 (nvme.h: resync with nvme-cli)
  struct nvme_command {
  	union {
  		struct nvme_common_command common;
@@@ -633,7 -919,22 +765,26 @@@ enum 
  	NVME_SC_FEATURE_NOT_SAVEABLE	= 0x10d,
  	NVME_SC_FEATURE_NOT_CHANGEABLE	= 0x10e,
  	NVME_SC_FEATURE_NOT_PER_NS	= 0x10f,
++<<<<<<< HEAD
 +	NVME_SC_FW_NEEDS_RESET_SUBSYS	= 0x110,
++=======
+ 	NVME_SC_FW_NEEDS_SUBSYS_RESET	= 0x110,
+ 	NVME_SC_FW_NEEDS_RESET		= 0x111,
+ 	NVME_SC_FW_NEEDS_MAX_TIME	= 0x112,
+ 	NVME_SC_FW_ACIVATE_PROHIBITED	= 0x113,
+ 	NVME_SC_OVERLAPPING_RANGE	= 0x114,
+ 	NVME_SC_NS_INSUFFICENT_CAP	= 0x115,
+ 	NVME_SC_NS_ID_UNAVAILABLE	= 0x116,
+ 	NVME_SC_NS_ALREADY_ATTACHED	= 0x118,
+ 	NVME_SC_NS_IS_PRIVATE		= 0x119,
+ 	NVME_SC_NS_NOT_ATTACHED		= 0x11a,
+ 	NVME_SC_THIN_PROV_NOT_SUPP	= 0x11b,
+ 	NVME_SC_CTRL_LIST_INVALID	= 0x11c,
+ 
+ 	/*
+ 	 * I/O Command Set Specific - NVM commands:
+ 	 */
++>>>>>>> a446c0840e24 (nvme.h: resync with nvme-cli)
  	NVME_SC_BAD_ATTRIBUTES		= 0x180,
  	NVME_SC_INVALID_PI		= 0x181,
  	NVME_SC_READ_ONLY		= 0x182,
@@@ -644,6 -961,8 +795,11 @@@
  	NVME_SC_REFTAG_CHECK		= 0x284,
  	NVME_SC_COMPARE_FAILED		= 0x285,
  	NVME_SC_ACCESS_DENIED		= 0x286,
++<<<<<<< HEAD
++=======
+ 	NVME_SC_UNWRITTEN_BLOCK		= 0x287,
+ 
++>>>>>>> a446c0840e24 (nvme.h: resync with nvme-cli)
  	NVME_SC_DNR			= 0x4000,
  };
  
* Unmerged path drivers/nvme/target/admin-cmd.c
* Unmerged path drivers/nvme/target/discovery.c
* Unmerged path drivers/nvme/target/admin-cmd.c
* Unmerged path drivers/nvme/target/discovery.c
* Unmerged path include/linux/nvme.h
