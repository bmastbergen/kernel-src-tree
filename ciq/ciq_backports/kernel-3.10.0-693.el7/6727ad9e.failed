nmi_backtrace: generate one-line reports for idle cpus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Chris Metcalf <cmetcalf@mellanox.com>
commit 6727ad9e206cc08b80d8000a4d67f8417e53539d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6727ad9e.failed

When doing an nmi backtrace of many cores, most of which are idle, the
output is a little overwhelming and very uninformative.  Suppress
messages for cpus that are idling when they are interrupted and just
emit one line, "NMI backtrace for N skipped: idling at pc 0xNNN".

We do this by grouping all the cpuidle code together into a new
.cpuidle.text section, and then checking the address of the interrupted
PC to see if it lies within that section.

This commit suitably tags x86 and tile idle routines, and only adds in
the minimal framework for other architectures.

Link: http://lkml.kernel.org/r/1472487169-14923-5-git-send-email-cmetcalf@mellanox.com
	Signed-off-by: Chris Metcalf <cmetcalf@mellanox.com>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Tested-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Tested-by: Daniel Thompson <daniel.thompson@linaro.org> [arm]
	Tested-by: Petr Mladek <pmladek@suse.com>
	Cc: Aaron Tomlin <atomlin@redhat.com>
	Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
	Cc: Russell King <linux@arm.linux.org.uk>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@elte.hu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6727ad9e206cc08b80d8000a4d67f8417e53539d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/kernel/vmlinux-xip.lds.S
#	arch/h8300/kernel/vmlinux.lds.S
#	arch/nios2/kernel/vmlinux.lds.S
#	arch/x86/kernel/process.c
#	drivers/acpi/processor_idle.c
#	drivers/cpuidle/driver.c
#	kernel/sched/idle.c
#	lib/nmi_backtrace.c
#	scripts/mod/modpost.c
diff --cc arch/h8300/kernel/vmlinux.lds.S
index 03d356d96e5d,7f11da1b895e..000000000000
--- a/arch/h8300/kernel/vmlinux.lds.S
+++ b/arch/h8300/kernel/vmlinux.lds.S
@@@ -55,101 -12,57 +55,111 @@@ ENTRY(__start
  SECTIONS
  {
  #if defined(CONFIG_ROMKERNEL)
 -	. = ROMTOP;
 +	. = ROMTOP; 
  	.vectors :
  	{
 -	_vector = . ;
 -		*(.vector*)
 +	__vector = . ;
 +		*(.vectors*)
  	}
  #else
 -	. = RAMTOP;
 -	_ramstart = .;
 -	. = . + CONFIG_OFFSET;
 +	. = RAMTOP; 
 +	.bootvec :	
 +	{
 +		*(.bootvec)
 +	}
  #endif
 +        .text :
 +	{
  	_text = .;
++<<<<<<< HEAD
++=======
+ 	HEAD_TEXT_SECTION
+ 	.text : {
+ 	_stext = . ;
+ 		TEXT_TEXT
+ 		SCHED_TEXT
+ 		CPUIDLE_TEXT
+ 		LOCK_TEXT
++>>>>>>> 6727ad9e206c (nmi_backtrace: generate one-line reports for idle cpus)
  #if defined(CONFIG_ROMKERNEL)
 -		*(.int_redirect)
 +	*(.int_redirect)
  #endif
 -	_etext = . ;
 +	__stext = . ;
 +	TEXT_TEXT
 +	SCHED_TEXT
 +	LOCK_TEXT
 +	__etext = . ;
  	}
  	EXCEPTION_TABLE(16)
 -	NOTES
 -	RO_DATA_SECTION(4)
 -	ROMEND = .;
 +
 +	RODATA
  #if defined(CONFIG_ROMKERNEL)
 -	. = RAMTOP;
 -	_ramstart = .;
 -#define ADDR(x) ROMEND
 +	SECURITY_INIT
  #endif
 -	_sdata = . ;
 -	__data_start = . ;
 -	RW_DATA_SECTION(0, PAGE_SIZE, THREAD_SIZE)
 +	ROEND = .; 
  #if defined(CONFIG_ROMKERNEL)
 -#undef ADDR
 +	. = RAMTOP;
 +	.data :	AT(ROEND)
 +#else
 +	.data :	
  #endif
 +	{
 +	__sdata = . ;
 +	___data_start = . ;
 +
 +	INIT_TASK_DATA(0x2000)
 +	. = ALIGN(0x4) ;
 +		DATA_DATA
 +	. = ALIGN(0x4) ;
 +		*(.data.*)	
 +
 +	. = ALIGN(0x4) ;
 +	___init_begin = .;
 +	__sinittext = .; 
 +		INIT_TEXT
 +	__einittext = .; 
 +		INIT_DATA
 +	. = ALIGN(0x4) ;
 +	INIT_SETUP(0x4)
 +	___setup_start = .;
 +		*(.init.setup)
 +	. = ALIGN(0x4) ;
 +	___setup_end = .;
 +	INIT_CALLS
 +	CON_INITCALL
 +		EXIT_TEXT
 +		EXIT_DATA
 +	INIT_RAM_FS
  	. = ALIGN(0x4) ;
 -	__init_begin = .;
 -	INIT_TEXT_SECTION(4)
 -	INIT_DATA_SECTION(4)
 +	___init_end = .;
 +	__edata = . ;
 +	}
 +#if defined(CONFIG_RAMKERNEL)
  	SECURITY_INIT
 -	__init_end = .;
 -	_edata = . ;
 -	_begin_data = LOADADDR(.data);
 -	_sbss =.;
 -	BSS_SECTION(0, 0 ,0)
 -	_ebss =.;
 -	_ramend = .;
 -	_end = .;
 +#endif
 +	__begin_data = LOADADDR(.data);
 +        .bss : 
 +        {
 +	. = ALIGN(0x4) ;
 +	__sbss = . ;
 +		*(.bss*)
 +	. = ALIGN(0x4) ;
 +		*(COMMON)
 +	. = ALIGN(0x4) ;
 +	__ebss = . ;
 +	__end = . ;
 +	__ramstart = .;
 +	}
 +        .romfs :	
 +	{
 +		*(.romfs*)
 +	}
 +	. = RAMTOP+RAMSIZE;
 +        .dummy :
 +        {
 +	COMMAND_START = . - 0x200 ;
 +	__ramend = . ;
 +	}
 +
  	DISCARDS
  }
diff --cc arch/x86/kernel/process.c
index 543c088dc8f5,28cea7802ecb..000000000000
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@@ -401,6 -391,54 +401,57 @@@ static void amd_e400_idle(void
  		default_idle();
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Intel Core2 and older machines prefer MWAIT over HALT for C1.
+  * We can't rely on cpuidle installing MWAIT, because it will not load
+  * on systems that support only C1 -- so the boot default must be MWAIT.
+  *
+  * Some AMD machines are the opposite, they depend on using HALT.
+  *
+  * So for default C1, which is used during boot until cpuidle loads,
+  * use MWAIT-C1 on Intel HW that has it, else use HALT.
+  */
+ static int prefer_mwait_c1_over_halt(const struct cpuinfo_x86 *c)
+ {
+ 	if (c->x86_vendor != X86_VENDOR_INTEL)
+ 		return 0;
+ 
+ 	if (!cpu_has(c, X86_FEATURE_MWAIT) || static_cpu_has_bug(X86_BUG_MONITOR))
+ 		return 0;
+ 
+ 	return 1;
+ }
+ 
+ /*
+  * MONITOR/MWAIT with no hints, used for default C1 state. This invokes MWAIT
+  * with interrupts enabled and no flags, which is backwards compatible with the
+  * original MWAIT implementation.
+  */
+ static __cpuidle void mwait_idle(void)
+ {
+ 	if (!current_set_polling_and_test()) {
+ 		trace_cpu_idle_rcuidle(1, smp_processor_id());
+ 		if (this_cpu_has(X86_BUG_CLFLUSH_MONITOR)) {
+ 			mb(); /* quirk */
+ 			clflush((void *)&current_thread_info()->flags);
+ 			mb(); /* quirk */
+ 		}
+ 
+ 		__monitor((void *)&current_thread_info()->flags, 0, 0);
+ 		if (!need_resched())
+ 			__sti_mwait(0, 0);
+ 		else
+ 			local_irq_enable();
+ 		trace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());
+ 	} else {
+ 		local_irq_enable();
+ 	}
+ 	__current_clr_polling();
+ }
+ 
++>>>>>>> 6727ad9e206c (nmi_backtrace: generate one-line reports for idle cpus)
  void select_idle_routine(const struct cpuinfo_x86 *c)
  {
  #ifdef CONFIG_SMP
diff --cc drivers/acpi/processor_idle.c
index 0a522c65c418,2237d3f24f0e..000000000000
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@@ -32,9 -29,10 +32,14 @@@
  #include <linux/acpi.h>
  #include <linux/dmi.h>
  #include <linux/sched.h>       /* need_resched() */
 -#include <linux/tick.h>
 +#include <linux/clockchips.h>
  #include <linux/cpuidle.h>
++<<<<<<< HEAD
 +#include <linux/syscore_ops.h>
++=======
+ #include <linux/cpu.h>
+ #include <acpi/processor.h>
++>>>>>>> 6727ad9e206c (nmi_backtrace: generate one-line reports for idle cpus)
  
  /*
   * Include the apic definitions for x86 to have the APIC timer related defines
@@@ -691,10 -646,8 +696,14 @@@ static int acpi_idle_bm_check(void
   *
   * Caller disables interrupt before call and enables interrupt after return.
   */
++<<<<<<< HEAD
 +static inline void acpi_idle_do_entry(struct acpi_processor_cx *cx)
++=======
+ static void __cpuidle acpi_idle_do_entry(struct acpi_processor_cx *cx)
++>>>>>>> 6727ad9e206c (nmi_backtrace: generate one-line reports for idle cpus)
  {
 +	/* Don't trace irqs off for idle */
 +	stop_critical_timings();
  	if (cx->entry_method == ACPI_CSTATE_FFH) {
  		/* Call into architectural FFH based C-state */
  		acpi_processor_ffh_cstate_enter(cx);
diff --cc drivers/cpuidle/driver.c
index 3ac499d5a207,ab264d393233..000000000000
--- a/drivers/cpuidle/driver.c
+++ b/drivers/cpuidle/driver.c
@@@ -10,9 -10,11 +10,14 @@@
  
  #include <linux/mutex.h>
  #include <linux/module.h>
 -#include <linux/sched.h>
  #include <linux/cpuidle.h>
  #include <linux/cpumask.h>
++<<<<<<< HEAD
 +#include <linux/clockchips.h>
++=======
+ #include <linux/tick.h>
+ #include <linux/cpu.h>
++>>>>>>> 6727ad9e206c (nmi_backtrace: generate one-line reports for idle cpus)
  
  #include "cpuidle.h"
  
@@@ -169,20 -168,46 +174,53 @@@ static int __cpuidle_driver_init(struc
  	/*
  	 * Look for the timer stop flag in the different states, so that we know
  	 * if the broadcast timer has to be set up.  The loop is in the reverse
 -	 * order, because usually one of the deeper states have this flag set.
 +	 * order, because usually on of the the deeper states has this flag set.
  	 */
  	for (i = drv->state_count - 1; i >= 0 ; i--) {
 -		if (drv->states[i].flags & CPUIDLE_FLAG_TIMER_STOP) {
 -			drv->bctimer = 1;
 -			break;
 -		}
 +
 +		if (!(drv->states[i].flags & CPUIDLE_FLAG_TIMER_STOP))
 +			continue;
 +
 +		drv->bctimer = 1;
 +		break;
  	}
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARCH_HAS_CPU_RELAX
+ static int __cpuidle poll_idle(struct cpuidle_device *dev,
+ 			       struct cpuidle_driver *drv, int index)
+ {
+ 	local_irq_enable();
+ 	if (!current_set_polling_and_test()) {
+ 		while (!need_resched())
+ 			cpu_relax();
+ 	}
+ 	current_clr_polling();
+ 
+ 	return index;
+ }
+ 
+ static void poll_idle_init(struct cpuidle_driver *drv)
+ {
+ 	struct cpuidle_state *state = &drv->states[0];
+ 
+ 	snprintf(state->name, CPUIDLE_NAME_LEN, "POLL");
+ 	snprintf(state->desc, CPUIDLE_DESC_LEN, "CPUIDLE CORE POLL IDLE");
+ 	state->exit_latency = 0;
+ 	state->target_residency = 0;
+ 	state->power_usage = -1;
+ 	state->enter = poll_idle;
+ 	state->disabled = false;
+ }
+ #else
+ static void poll_idle_init(struct cpuidle_driver *drv) {}
+ #endif /* !CONFIG_ARCH_HAS_CPU_RELAX */
+ 
++>>>>>>> 6727ad9e206c (nmi_backtrace: generate one-line reports for idle cpus)
  /**
   * __cpuidle_register_driver: register the driver
   * @drv: a valid pointer to a struct cpuidle_driver
diff --cc scripts/mod/modpost.c
index 2b64dcd22b32,bd8349759095..000000000000
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@@ -887,11 -886,14 +887,20 @@@ static void check_section(const char *m
  #define ALL_INIT_SECTIONS INIT_SECTIONS, ALL_XXXINIT_SECTIONS
  #define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS
  
++<<<<<<< HEAD
 +#define DATA_SECTIONS ".data$", ".data.rel$"
 +#define TEXT_SECTIONS ".text$"
++=======
+ #define DATA_SECTIONS ".data", ".data.rel"
+ #define TEXT_SECTIONS ".text", ".text.unlikely", ".sched.text", \
+ 		".kprobes.text", ".cpuidle.text"
+ #define OTHER_TEXT_SECTIONS ".ref.text", ".head.text", ".spinlock.text", \
+ 		".fixup", ".entry.text", ".exception.text", ".text.*", \
+ 		".coldtext"
++>>>>>>> 6727ad9e206c (nmi_backtrace: generate one-line reports for idle cpus)
  
  #define INIT_SECTIONS      ".init.*"
 +#define CPU_INIT_SECTIONS  ".cpuinit.*"
  #define MEM_INIT_SECTIONS  ".meminit.*"
  
  #define EXIT_SECTIONS      ".exit.*"
* Unmerged path arch/arm/kernel/vmlinux-xip.lds.S
* Unmerged path arch/nios2/kernel/vmlinux.lds.S
* Unmerged path kernel/sched/idle.c
* Unmerged path lib/nmi_backtrace.c
diff --git a/arch/alpha/kernel/vmlinux.lds.S b/arch/alpha/kernel/vmlinux.lds.S
index 647b84c15382..cebecfb76fbf 100644
--- a/arch/alpha/kernel/vmlinux.lds.S
+++ b/arch/alpha/kernel/vmlinux.lds.S
@@ -22,6 +22,7 @@ SECTIONS
 		HEAD_TEXT
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		*(.fixup)
 		*(.gnu.warning)
diff --git a/arch/arc/kernel/vmlinux.lds.S b/arch/arc/kernel/vmlinux.lds.S
index d3c92f52d444..f58b8c9a5fc2 100644
--- a/arch/arc/kernel/vmlinux.lds.S
+++ b/arch/arc/kernel/vmlinux.lds.S
@@ -97,6 +97,7 @@ SECTIONS
 		_text = .;
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		*(.fixup)
* Unmerged path arch/arm/kernel/vmlinux-xip.lds.S
diff --git a/arch/arm/kernel/vmlinux.lds.S b/arch/arm/kernel/vmlinux.lds.S
index 33f2ea32f5a0..8e820383df65 100644
--- a/arch/arm/kernel/vmlinux.lds.S
+++ b/arch/arm/kernel/vmlinux.lds.S
@@ -102,6 +102,7 @@ SECTIONS
 			IRQENTRY_TEXT
 			TEXT_TEXT
 			SCHED_TEXT
+			CPUIDLE_TEXT
 			LOCK_TEXT
 			KPROBES_TEXT
 			IDMAP_TEXT
diff --git a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S
index 3fae2be8b016..26e31de31466 100644
--- a/arch/arm64/kernel/vmlinux.lds.S
+++ b/arch/arm64/kernel/vmlinux.lds.S
@@ -48,6 +48,7 @@ SECTIONS
 			IRQENTRY_TEXT
 			TEXT_TEXT
 			SCHED_TEXT
+			CPUIDLE_TEXT
 			LOCK_TEXT
 			*(.fixup)
 			*(.gnu.warning)
diff --git a/arch/avr32/kernel/vmlinux.lds.S b/arch/avr32/kernel/vmlinux.lds.S
index 9cd2bd91d64a..a4ac1d9ce79a 100644
--- a/arch/avr32/kernel/vmlinux.lds.S
+++ b/arch/avr32/kernel/vmlinux.lds.S
@@ -52,6 +52,7 @@ SECTIONS
 		KPROBES_TEXT
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		*(.fixup)
 		*(.gnu.warning)
diff --git a/arch/blackfin/kernel/vmlinux.lds.S b/arch/blackfin/kernel/vmlinux.lds.S
index ba35864b2b74..886a0b20d1ae 100644
--- a/arch/blackfin/kernel/vmlinux.lds.S
+++ b/arch/blackfin/kernel/vmlinux.lds.S
@@ -33,6 +33,7 @@ SECTIONS
 #ifndef CONFIG_SCHEDULE_L1
 		SCHED_TEXT
 #endif
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		IRQENTRY_TEXT
 		KPROBES_TEXT
diff --git a/arch/c6x/kernel/vmlinux.lds.S b/arch/c6x/kernel/vmlinux.lds.S
index 1d81c4c129ec..53b7cd60f119 100644
--- a/arch/c6x/kernel/vmlinux.lds.S
+++ b/arch/c6x/kernel/vmlinux.lds.S
@@ -76,6 +76,7 @@ SECTIONS
 		_text = .;
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		IRQENTRY_TEXT
 		KPROBES_TEXT
diff --git a/arch/cris/kernel/vmlinux.lds.S b/arch/cris/kernel/vmlinux.lds.S
index a68b983dcea1..e8a8235d6e1c 100644
--- a/arch/cris/kernel/vmlinux.lds.S
+++ b/arch/cris/kernel/vmlinux.lds.S
@@ -42,6 +42,7 @@ SECTIONS
 	.text : {
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		*(.fixup)
 		*(.text.__*)
diff --git a/arch/frv/kernel/vmlinux.lds.S b/arch/frv/kernel/vmlinux.lds.S
index 7e958d829ec9..aa6e573d57da 100644
--- a/arch/frv/kernel/vmlinux.lds.S
+++ b/arch/frv/kernel/vmlinux.lds.S
@@ -63,6 +63,7 @@ SECTIONS
 	*(.text..tlbmiss)
 	TEXT_TEXT
 	SCHED_TEXT
+	CPUIDLE_TEXT
 	LOCK_TEXT
 #ifdef CONFIG_DEBUG_INFO
 	INIT_TEXT
* Unmerged path arch/h8300/kernel/vmlinux.lds.S
diff --git a/arch/hexagon/kernel/vmlinux.lds.S b/arch/hexagon/kernel/vmlinux.lds.S
index 44d8c47bae2f..e4fa48520a7f 100644
--- a/arch/hexagon/kernel/vmlinux.lds.S
+++ b/arch/hexagon/kernel/vmlinux.lds.S
@@ -50,6 +50,7 @@ SECTIONS
 		_text = .;
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		*(.fixup)
diff --git a/arch/ia64/kernel/vmlinux.lds.S b/arch/ia64/kernel/vmlinux.lds.S
index 0ccb28fab27e..11e85c318ad8 100644
--- a/arch/ia64/kernel/vmlinux.lds.S
+++ b/arch/ia64/kernel/vmlinux.lds.S
@@ -46,6 +46,7 @@ SECTIONS {
 		__end_ivt_text = .;
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		*(.gnu.linkonce.t*)
diff --git a/arch/m32r/kernel/vmlinux.lds.S b/arch/m32r/kernel/vmlinux.lds.S
index 018e4a711d79..ad1fe56455aa 100644
--- a/arch/m32r/kernel/vmlinux.lds.S
+++ b/arch/m32r/kernel/vmlinux.lds.S
@@ -31,6 +31,7 @@ SECTIONS
 	HEAD_TEXT
 	TEXT_TEXT
 	SCHED_TEXT
+	CPUIDLE_TEXT
 	LOCK_TEXT
 	*(.fixup)
 	*(.gnu.warning)
diff --git a/arch/m68k/kernel/vmlinux-nommu.lds b/arch/m68k/kernel/vmlinux-nommu.lds
index 06a763f49fd3..d2c8abf1c8c4 100644
--- a/arch/m68k/kernel/vmlinux-nommu.lds
+++ b/arch/m68k/kernel/vmlinux-nommu.lds
@@ -45,6 +45,7 @@ SECTIONS {
 		HEAD_TEXT
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		*(.fixup)
 		. = ALIGN(16);
diff --git a/arch/m68k/kernel/vmlinux-std.lds b/arch/m68k/kernel/vmlinux-std.lds
index d0993594f558..5b5ce1e4d1ed 100644
--- a/arch/m68k/kernel/vmlinux-std.lds
+++ b/arch/m68k/kernel/vmlinux-std.lds
@@ -16,6 +16,7 @@ SECTIONS
 	HEAD_TEXT
 	TEXT_TEXT
 	SCHED_TEXT
+	CPUIDLE_TEXT
 	LOCK_TEXT
 	*(.fixup)
 	*(.gnu.warning)
diff --git a/arch/m68k/kernel/vmlinux-sun3.lds b/arch/m68k/kernel/vmlinux-sun3.lds
index 8080469ee6c1..fe5ea1974b16 100644
--- a/arch/m68k/kernel/vmlinux-sun3.lds
+++ b/arch/m68k/kernel/vmlinux-sun3.lds
@@ -16,6 +16,7 @@ SECTIONS
 	HEAD_TEXT
 	TEXT_TEXT
 	SCHED_TEXT
+	CPUIDLE_TEXT
 	LOCK_TEXT
 	*(.fixup)
 	*(.gnu.warning)
diff --git a/arch/metag/kernel/vmlinux.lds.S b/arch/metag/kernel/vmlinux.lds.S
index e12055e88bfe..9fc48354d519 100644
--- a/arch/metag/kernel/vmlinux.lds.S
+++ b/arch/metag/kernel/vmlinux.lds.S
@@ -21,6 +21,7 @@ SECTIONS
   .text : {
 	TEXT_TEXT
 	SCHED_TEXT
+	CPUIDLE_TEXT
 	LOCK_TEXT
 	KPROBES_TEXT
 	IRQENTRY_TEXT
diff --git a/arch/microblaze/kernel/vmlinux.lds.S b/arch/microblaze/kernel/vmlinux.lds.S
index 936d01a689d7..85f9b1fdb004 100644
--- a/arch/microblaze/kernel/vmlinux.lds.S
+++ b/arch/microblaze/kernel/vmlinux.lds.S
@@ -33,6 +33,7 @@ SECTIONS {
 		EXIT_TEXT
 		EXIT_CALL
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		IRQENTRY_TEXT
diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S
index 05826d20a792..b33ae812a8e3 100644
--- a/arch/mips/kernel/vmlinux.lds.S
+++ b/arch/mips/kernel/vmlinux.lds.S
@@ -53,6 +53,7 @@ SECTIONS
 	.text : {
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		IRQENTRY_TEXT
diff --git a/arch/mn10300/kernel/vmlinux.lds.S b/arch/mn10300/kernel/vmlinux.lds.S
index 13c4814c29f8..2d5f1c3f1afb 100644
--- a/arch/mn10300/kernel/vmlinux.lds.S
+++ b/arch/mn10300/kernel/vmlinux.lds.S
@@ -30,6 +30,7 @@ SECTIONS
 	HEAD_TEXT
 	TEXT_TEXT
 	SCHED_TEXT
+	CPUIDLE_TEXT
 	LOCK_TEXT
 	KPROBES_TEXT
 	*(.fixup)
* Unmerged path arch/nios2/kernel/vmlinux.lds.S
diff --git a/arch/openrisc/kernel/vmlinux.lds.S b/arch/openrisc/kernel/vmlinux.lds.S
index 2d69a853b742..6c3cf834b5d8 100644
--- a/arch/openrisc/kernel/vmlinux.lds.S
+++ b/arch/openrisc/kernel/vmlinux.lds.S
@@ -47,6 +47,7 @@ SECTIONS
           _stext = .;
 	  TEXT_TEXT
 	  SCHED_TEXT
+	  CPUIDLE_TEXT
 	  LOCK_TEXT
 	  KPROBES_TEXT
 	  IRQENTRY_TEXT
diff --git a/arch/parisc/kernel/vmlinux.lds.S b/arch/parisc/kernel/vmlinux.lds.S
index 4bb095a2f6fc..75a0b9dcf8c2 100644
--- a/arch/parisc/kernel/vmlinux.lds.S
+++ b/arch/parisc/kernel/vmlinux.lds.S
@@ -56,6 +56,7 @@ SECTIONS
 	.text ALIGN(16) : {
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		IRQENTRY_TEXT
diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S
index 1db685104ffc..ecba94a3f367 100644
--- a/arch/powerpc/kernel/vmlinux.lds.S
+++ b/arch/powerpc/kernel/vmlinux.lds.S
@@ -52,6 +52,7 @@ SECTIONS
 		/* careful! __ftr_alt_* sections need to be close to .text */
 		*(.text .fixup __ftr_alt_* .ref.text)
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		IRQENTRY_TEXT
diff --git a/arch/s390/kernel/vmlinux.lds.S b/arch/s390/kernel/vmlinux.lds.S
index 35b13ed0af5f..0b9daab4364e 100644
--- a/arch/s390/kernel/vmlinux.lds.S
+++ b/arch/s390/kernel/vmlinux.lds.S
@@ -32,6 +32,7 @@ SECTIONS
 		HEAD_TEXT
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		IRQENTRY_TEXT
diff --git a/arch/score/kernel/vmlinux.lds.S b/arch/score/kernel/vmlinux.lds.S
index eebcbaa4e978..1ef671642192 100644
--- a/arch/score/kernel/vmlinux.lds.S
+++ b/arch/score/kernel/vmlinux.lds.S
@@ -40,6 +40,7 @@ SECTIONS
 		_text = .;	/* Text and read-only data */
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		*(.text.*)
diff --git a/arch/sh/kernel/vmlinux.lds.S b/arch/sh/kernel/vmlinux.lds.S
index db88cbf9eafd..989500c17358 100644
--- a/arch/sh/kernel/vmlinux.lds.S
+++ b/arch/sh/kernel/vmlinux.lds.S
@@ -36,6 +36,7 @@ SECTIONS
 		TEXT_TEXT
 		EXTRA_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		IRQENTRY_TEXT
diff --git a/arch/sparc/kernel/vmlinux.lds.S b/arch/sparc/kernel/vmlinux.lds.S
index 0bacceb19150..3947e855ac02 100644
--- a/arch/sparc/kernel/vmlinux.lds.S
+++ b/arch/sparc/kernel/vmlinux.lds.S
@@ -44,6 +44,7 @@ SECTIONS
 		HEAD_TEXT
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		IRQENTRY_TEXT
diff --git a/arch/tile/kernel/entry.S b/arch/tile/kernel/entry.S
index f116cb0bce20..0d3b28acb461 100644
--- a/arch/tile/kernel/entry.S
+++ b/arch/tile/kernel/entry.S
@@ -73,7 +73,7 @@ STD_ENTRY(smp_nap)
  * When interrupted at _cpu_idle_nap, we bump the PC forward 8, and
  * as a result return to the function that called _cpu_idle().
  */
-STD_ENTRY(_cpu_idle)
+STD_ENTRY_SECTION(_cpu_idle, .cpuidle.text)
 	movei r1, 1
 	IRQ_ENABLE_LOAD(r2, r3)
 	mtspr INTERRUPT_CRITICAL_SECTION, r1
diff --git a/arch/tile/kernel/vmlinux.lds.S b/arch/tile/kernel/vmlinux.lds.S
index 631f10de12fe..6ca4b0485a4d 100644
--- a/arch/tile/kernel/vmlinux.lds.S
+++ b/arch/tile/kernel/vmlinux.lds.S
@@ -39,6 +39,7 @@ SECTIONS
   .text : AT (ADDR(.text) - LOAD_OFFSET) {
     HEAD_TEXT
     SCHED_TEXT
+    CPUIDLE_TEXT
     LOCK_TEXT
     __fix_text_end = .;   /* tile-cpack won't rearrange before this */
     TEXT_TEXT
diff --git a/arch/um/kernel/dyn.lds.S b/arch/um/kernel/dyn.lds.S
index fb8fd6fb6563..04a5fc17f2b9 100644
--- a/arch/um/kernel/dyn.lds.S
+++ b/arch/um/kernel/dyn.lds.S
@@ -69,6 +69,7 @@ SECTIONS
   .text           : {
     TEXT_TEXT
     SCHED_TEXT
+    CPUIDLE_TEXT
     LOCK_TEXT
     *(.fixup)
     *(.stub .text.* .gnu.linkonce.t.*)
diff --git a/arch/um/kernel/uml.lds.S b/arch/um/kernel/uml.lds.S
index ff65fb4f1a95..3636cd01a3d7 100644
--- a/arch/um/kernel/uml.lds.S
+++ b/arch/um/kernel/uml.lds.S
@@ -29,6 +29,7 @@ SECTIONS
   {
     TEXT_TEXT
     SCHED_TEXT
+    CPUIDLE_TEXT
     LOCK_TEXT
     *(.fixup)
     /* .gnu.warning sections are handled specially by elf32.em.  */
diff --git a/arch/unicore32/kernel/vmlinux.lds.S b/arch/unicore32/kernel/vmlinux.lds.S
index 77e407e49a63..56e788e8ee83 100644
--- a/arch/unicore32/kernel/vmlinux.lds.S
+++ b/arch/unicore32/kernel/vmlinux.lds.S
@@ -37,6 +37,7 @@ SECTIONS
 	.text : {		/* Real text segment */
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 
 		*(.fixup)
diff --git a/arch/x86/include/asm/irqflags.h b/arch/x86/include/asm/irqflags.h
index bba3cf88e624..b927dcc864c7 100644
--- a/arch/x86/include/asm/irqflags.h
+++ b/arch/x86/include/asm/irqflags.h
@@ -4,6 +4,10 @@
 #include <asm/processor-flags.h>
 
 #ifndef __ASSEMBLY__
+
+/* Provide __cpuidle; we can't safely include <linux/cpu.h> */
+#define __cpuidle __attribute__((__section__(".cpuidle.text")))
+
 /*
  * Interrupt control:
  */
@@ -44,12 +48,12 @@ static inline void native_irq_enable(void)
 	asm volatile("sti": : :"memory");
 }
 
-static inline void native_safe_halt(void)
+static inline __cpuidle void native_safe_halt(void)
 {
 	asm volatile("sti; hlt": : :"memory");
 }
 
-static inline void native_halt(void)
+static inline __cpuidle void native_halt(void)
 {
 	asm volatile("hlt": : :"memory");
 }
@@ -86,7 +90,7 @@ static inline notrace void arch_local_irq_enable(void)
  * Used in the idle loop; sti takes one instruction cycle
  * to complete:
  */
-static inline void arch_safe_halt(void)
+static inline __cpuidle void arch_safe_halt(void)
 {
 	native_safe_halt();
 }
@@ -95,7 +99,7 @@ static inline void arch_safe_halt(void)
  * Used when interrupts are already enabled or to
  * shutdown the processor:
  */
-static inline void halt(void)
+static inline __cpuidle void halt(void)
 {
 	native_halt();
 }
diff --git a/arch/x86/kernel/acpi/cstate.c b/arch/x86/kernel/acpi/cstate.c
index e69182fd01cf..2c2a9cfdcb8a 100644
--- a/arch/x86/kernel/acpi/cstate.c
+++ b/arch/x86/kernel/acpi/cstate.c
@@ -150,7 +150,7 @@ int acpi_processor_ffh_cstate_probe(unsigned int cpu,
 }
 EXPORT_SYMBOL_GPL(acpi_processor_ffh_cstate_probe);
 
-void acpi_processor_ffh_cstate_enter(struct acpi_processor_cx *cx)
+void __cpuidle acpi_processor_ffh_cstate_enter(struct acpi_processor_cx *cx)
 {
 	unsigned int cpu = smp_processor_id();
 	struct cstate_entry *percpu_entry;
* Unmerged path arch/x86/kernel/process.c
diff --git a/arch/x86/kernel/vmlinux.lds.S b/arch/x86/kernel/vmlinux.lds.S
index 9b638c1dbfb1..7626a15ee75f 100644
--- a/arch/x86/kernel/vmlinux.lds.S
+++ b/arch/x86/kernel/vmlinux.lds.S
@@ -98,6 +98,7 @@ SECTIONS
 		_stext = .;
 		TEXT_TEXT
 		SCHED_TEXT
+		CPUIDLE_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
 		ENTRY_TEXT
diff --git a/arch/xtensa/kernel/vmlinux.lds.S b/arch/xtensa/kernel/vmlinux.lds.S
index 21acd11b5df2..a5d108057c3d 100644
--- a/arch/xtensa/kernel/vmlinux.lds.S
+++ b/arch/xtensa/kernel/vmlinux.lds.S
@@ -93,6 +93,9 @@ SECTIONS
     VMLINUX_SYMBOL(__sched_text_start) = .;
     *(.sched.literal .sched.text)
     VMLINUX_SYMBOL(__sched_text_end) = .;
+    VMLINUX_SYMBOL(__cpuidle_text_start) = .;
+    *(.cpuidle.literal .cpuidle.text)
+    VMLINUX_SYMBOL(__cpuidle_text_end) = .;
     VMLINUX_SYMBOL(__lock_text_start) = .;
     *(.spinlock.literal .spinlock.text)
     VMLINUX_SYMBOL(__lock_text_end) = .;
* Unmerged path drivers/acpi/processor_idle.c
* Unmerged path drivers/cpuidle/driver.c
diff --git a/drivers/idle/intel_idle.c b/drivers/idle/intel_idle.c
index 2f3840328ea3..523c16bb0826 100644
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@ -685,8 +685,8 @@ static struct cpuidle_state dnv_cstates[] = {
  *
  * Must be called under local_irq_disable().
  */
-static int intel_idle(struct cpuidle_device *dev,
-		struct cpuidle_driver *drv, int index)
+static __cpuidle int intel_idle(struct cpuidle_device *dev,
+				struct cpuidle_driver *drv, int index)
 {
 	unsigned long ecx = 1; /* break on interrupt flag */
 	struct cpuidle_state *state = &drv->states[index];
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index 14023fe3f4f9..c44fab3c1094 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -436,6 +436,12 @@
 		*(.spinlock.text)					\
 		VMLINUX_SYMBOL(__lock_text_end) = .;
 
+#define CPUIDLE_TEXT							\
+		ALIGN_FUNCTION();					\
+		VMLINUX_SYMBOL(__cpuidle_text_start) = .;		\
+		*(.cpuidle.text)					\
+		VMLINUX_SYMBOL(__cpuidle_text_end) = .;
+
 #define KPROBES_TEXT							\
 		ALIGN_FUNCTION();					\
 		VMLINUX_SYMBOL(__kprobes_text_start) = .;		\
diff --git a/include/linux/cpu.h b/include/linux/cpu.h
index 0df7f297fbc6..e2bdd999bd70 100644
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@ -262,6 +262,11 @@ void cpu_idle(void);
 
 void cpu_idle_poll_ctrl(bool enable);
 
+/* Attach to any functions which should be considered cpuidle. */
+#define __cpuidle	__attribute__((__section__(".cpuidle.text")))
+
+bool cpu_in_idle(unsigned long pc);
+
 void arch_cpu_idle(void);
 void arch_cpu_idle_prepare(void);
 void arch_cpu_idle_enter(void);
* Unmerged path kernel/sched/idle.c
* Unmerged path lib/nmi_backtrace.c
* Unmerged path scripts/mod/modpost.c
diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 9c22317778eb..14406a5b7996 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -249,6 +249,7 @@ is_mcounted_section_name(char const *const txtname)
 		strcmp(".spinlock.text", txtname) == 0 ||
 		strcmp(".irqentry.text", txtname) == 0 ||
 		strcmp(".kprobes.text", txtname) == 0 ||
+		strcmp(".cpuidle.text", txtname) == 0 ||
 		strcmp(".text.unlikely", txtname) == 0;
 }
 
diff --git a/scripts/recordmcount.pl b/scripts/recordmcount.pl
index 858966ab019c..083e25995ced 100755
--- a/scripts/recordmcount.pl
+++ b/scripts/recordmcount.pl
@@ -135,6 +135,7 @@ my %text_sections = (
      ".spinlock.text" => 1,
      ".irqentry.text" => 1,
      ".kprobes.text" => 1,
+     ".cpuidle.text" => 1,
      ".text.unlikely" => 1,
 );
 
