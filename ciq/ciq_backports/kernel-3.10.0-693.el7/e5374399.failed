af_iucv: use paged SKBs for big outbound messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eugene Crosser <Eugene.Crosser@ru.ibm.com>
commit e53743994e21d2458f0129d07b253d66f96f5742
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e5374399.failed

When an outbound message is bigger than a page, allocate and fill
a paged SKB, and subsequently use IUCV send primitive with IPBUFLST
flag. This relaxes the pressure to allocate big contiguous kernel
buffers.

	Signed-off-by: Eugene Crosser <Eugene.Crosser@ru.ibm.com>
	Signed-off-by: Ursula Braun <ubraun@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e53743994e21d2458f0129d07b253d66f96f5742)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/iucv/af_iucv.c
diff --cc net/iucv/af_iucv.c
index 14ef3c501c3e,38448d17c006..000000000000
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@@ -1027,8 -1033,9 +1027,9 @@@ static int iucv_sock_sendmsg(struct kio
  {
  	struct sock *sk = sock->sk;
  	struct iucv_sock *iucv = iucv_sk(sk);
+ 	size_t headroom, linear;
  	struct sk_buff *skb;
 -	struct iucv_message txmsg = {0};
 +	struct iucv_message txmsg;
  	struct cmsghdr *cmsg;
  	int cmsg_done;
  	long timeo;
@@@ -1107,20 -1111,31 +1108,38 @@@
  	 * this is fine for SOCK_SEQPACKET (unless we want to support
  	 * segmented records using the MSG_EOR flag), but
  	 * for SOCK_STREAM we might want to improve it in future */
- 	if (iucv->transport == AF_IUCV_TRANS_HIPER)
- 		skb = sock_alloc_send_skb(sk,
- 			len + sizeof(struct af_iucv_trans_hdr) + ETH_HLEN,
- 			noblock, &err);
- 	else
- 		skb = sock_alloc_send_skb(sk, len, noblock, &err);
+ 	headroom = (iucv->transport == AF_IUCV_TRANS_HIPER)
+ 		   ? sizeof(struct af_iucv_trans_hdr) + ETH_HLEN : 0;
+ 	if (headroom + len < PAGE_SIZE) {
+ 		linear = len;
+ 	} else {
+ 		/* In nonlinear "classic" iucv skb,
+ 		 * reserve space for iucv_array
+ 		 */
+ 		if (iucv->transport != AF_IUCV_TRANS_HIPER)
+ 			headroom += sizeof(struct iucv_array) *
+ 				    (MAX_SKB_FRAGS + 1);
+ 		linear = PAGE_SIZE - headroom;
+ 	}
+ 	skb = sock_alloc_send_pskb(sk, headroom + linear, len - linear,
+ 				   noblock, &err, 0);
  	if (!skb)
  		goto out;
++<<<<<<< HEAD
 +	if (iucv->transport == AF_IUCV_TRANS_HIPER)
 +		skb_reserve(skb, sizeof(struct af_iucv_trans_hdr) + ETH_HLEN);
 +	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
 +		err = -EFAULT;
++=======
+ 	if (headroom)
+ 		skb_reserve(skb, headroom);
+ 	skb_put(skb, linear);
+ 	skb->len = len;
+ 	skb->data_len = len - linear;
+ 	err = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, len);
+ 	if (err)
++>>>>>>> e53743994e21 (af_iucv: use paged SKBs for big outbound messages)
  		goto fail;
- 	}
  
  	/* wait if outstanding messages for iucv path has reached */
  	timeo = sock_sndtimeo(sk, noblock);
* Unmerged path net/iucv/af_iucv.c
