e1000e: e1000e_cyclecounter_read(): do overflow check only if needed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Denys Vlasenko <dvlasenk@redhat.com>
commit ab507c9a54ce3580e6a3829c9f4c24a13c32cbac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ab507c9a.failed

SYSTIMH:SYSTIML registers are incremented by 24-bit value TIMINCA[23..0]

er32(SYSTIML) are probably moderately expensive (they are pci bus reads).
Can we avoid one of them? Yes, we can.

If the SYSTIML value we see is smaller than 0xff000000, the overflow
into SYSTIMH would require at least two increments.

We do two reads, er32(SYSTIML) and er32(SYSTIMH), in this order.

Even if one increment happens between them, the overflow into SYSTIMH
is impossible, and we can avoid doing another er32(SYSTIML) read
and overflow check.

	Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit ab507c9a54ce3580e6a3829c9f4c24a13c32cbac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index a2ce770c86fc,0d3c00deb160..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -4306,33 -4275,56 +4306,38 @@@ static cycle_t e1000e_cyclecounter_read
  	struct e1000_adapter *adapter = container_of(cc, struct e1000_adapter,
  						     cc);
  	struct e1000_hw *hw = &adapter->hw;
++<<<<<<< HEAD
 +	u32 systimel_1, systimel_2, systimeh;
 +	cycle_t systim;
++=======
+ 	u32 systimel, systimeh;
+ 	cycle_t systim, systim_next;
++>>>>>>> ab507c9a54ce (e1000e: e1000e_cyclecounter_read(): do overflow check only if needed)
  	/* SYSTIMH latching upon SYSTIML read does not work well.
  	 * This means that if SYSTIML overflows after we read it but before
  	 * we read SYSTIMH, the value of SYSTIMH has been incremented and we
  	 * will experience a huge non linear increment in the systime value
  	 * to fix that we test for overflow and if true, we re-read systime.
  	 */
- 	systimel_1 = er32(SYSTIML);
+ 	systimel = er32(SYSTIML);
  	systimeh = er32(SYSTIMH);
- 	systimel_2 = er32(SYSTIML);
- 	/* Check for overflow. If there was no overflow, use the values */
- 	if (systimel_1 <= systimel_2) {
- 		systim = (cycle_t)systimel_1;
- 		systim |= (cycle_t)systimeh << 32;
- 	} else {
- 		/* There was an overflow, read again SYSTIMH, and use
- 		 * systimel_2
- 		 */
- 		systimeh = er32(SYSTIMH);
- 		systim = (cycle_t)systimel_2;
- 		systim |= (cycle_t)systimeh << 32;
+ 	/* Is systimel is so large that overflow is possible? */
+ 	if (systimel >= (u32)0xffffffff - E1000_TIMINCA_INCVALUE_MASK) {
+ 		u32 systimel_2 = er32(SYSTIML);
+ 		if (systimel > systimel_2) {
+ 			/* There was an overflow, read again SYSTIMH, and use
+ 			 * systimel_2
+ 			 */
+ 			systimeh = er32(SYSTIMH);
+ 			systimel = systimel_2;
+ 		}
  	}
+ 	systim = (cycle_t)systimel;
+ 	systim |= (cycle_t)systimeh << 32;
  
 -	if ((hw->mac.type == e1000_82574) || (hw->mac.type == e1000_82583)) {
 -		u64 time_delta, rem, temp;
 -		u32 incvalue;
 -		int i;
 -
 -		/* errata for 82574/82583 possible bad bits read from SYSTIMH/L
 -		 * check to see that the time is incrementing at a reasonable
 -		 * rate and is a multiple of incvalue
 -		 */
 -		incvalue = er32(TIMINCA) & E1000_TIMINCA_INCVALUE_MASK;
 -		for (i = 0; i < E1000_MAX_82574_SYSTIM_REREADS; i++) {
 -			/* latch SYSTIMH on read of SYSTIML */
 -			systim_next = (cycle_t)er32(SYSTIML);
 -			systim_next |= (cycle_t)er32(SYSTIMH) << 32;
 -
 -			time_delta = systim_next - systim;
 -			temp = time_delta;
 -			rem = do_div(temp, incvalue);
 +	if (adapter->flags2 & FLAG2_CHECK_SYSTIM_OVERFLOW)
 +		systim = e1000e_sanitize_systim(hw, systim);
  
 -			systim = systim_next;
 -
 -			if ((time_delta < E1000_82574_SYSTIM_EPSILON) &&
 -			    (rem == 0))
 -				break;
 -		}
 -	}
  	return systim;
  }
  
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
