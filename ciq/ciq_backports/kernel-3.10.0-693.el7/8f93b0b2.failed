HID: wacom: Provide battery charge state to system over USB if available

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Provide battery charge state to system over USB if available (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.40%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 8f93b0b2b0a336746adc8730921b219f0ba40c29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8f93b0b2.failed

If a wireless adapter (which contains the charging circuitry) is
detected as being attached to the tablet then create a new battery
interface and update its status as data is reported. Also destroy the
battery if the adapter goes away.

	Signed-off-by: Jason Gerecke <killertofu@gmail.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 8f93b0b2b0a336746adc8730921b219f0ba40c29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index d83376be6444,f1e53f15abb5..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1343,6 -1950,49 +1343,52 @@@ static int wacom_wireless_irq(struct wa
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int wacom_status_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	unsigned char *data = wacom_wac->data;
+ 
+ 	if (data[0] != WACOM_REPORT_USB)
+ 		return 0;
+ 
+ 	if (features->type == INTUOSHT &&
+ 	    wacom_wac->shared->touch_input &&
+ 	    features->touch_max) {
+ 		input_report_switch(wacom_wac->shared->touch_input,
+ 				    SW_MUTE_DEVICE, data[8] & 0x40);
+ 		input_sync(wacom_wac->shared->touch_input);
+ 	}
+ 
+ 	if (data[9] & 0x02) { /* wireless module is attached */
+ 		int battery = (data[8] & 0x3f) * 100 / 31;
+ 		bool ps_connected = !!(data[8] & 0x80);
+ 		bool charging = ps_connected &&
+ 				wacom_wac->battery_capacity < 100;
+ 
+ 		wacom_notify_battery(wacom_wac, battery, charging,
+ 				     ps_connected);
+ 
+ 		if (!wacom->battery.dev &&
+ 		    !(features->quirks & WACOM_QUIRK_BATTERY)) {
+ 			features->quirks |= WACOM_QUIRK_BATTERY;
+ 			INIT_WORK(&wacom->work, wacom_battery_work);
+ 			wacom_schedule_work(wacom_wac);
+ 		}
+ 	}
+ 	else if ((features->quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery.dev) {
+ 		features->quirks &= ~WACOM_QUIRK_BATTERY;
+ 		INIT_WORK(&wacom->work, wacom_battery_work);
+ 		wacom_schedule_work(wacom_wac);
+ 		wacom_notify_battery(wacom_wac, 0, 0, 0);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 8f93b0b2b0a3 (HID: wacom: Provide battery charge state to system over USB if available)
  void wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len)
  {
  	bool sync;
* Unmerged path drivers/hid/wacom_wac.c
