scsi: be2iscsi: Remove unused struct members

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] be2iscsi: Remove unused struct members (Maurizio Lombardi) [1382263]
Rebuild_FUZZ: 92.68%
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit fa1261c4b683828f1b012267aff5b9322fd9ab71
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fa1261c4.failed

Fix errors reported in static analysis.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit fa1261c4b683828f1b012267aff5b9322fd9ab71)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_cmds.c
#	drivers/scsi/be2iscsi/be_main.c
#	drivers/scsi/be2iscsi/be_mgmt.c
#	drivers/scsi/be2iscsi/be_mgmt.h
diff --cc drivers/scsi/be2iscsi/be_cmds.c
index bc6b695620e1,5d59e2630ce6..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@@ -1327,3 -1257,567 +1327,570 @@@ int be_cmd_set_vlan(struct beiscsi_hba 
  
  	return tag;
  }
++<<<<<<< HEAD
++=======
+ 
+ int beiscsi_check_supported_fw(struct be_ctrl_info *ctrl,
+ 			       struct beiscsi_hba *phba)
+ {
+ 	struct be_dma_mem nonemb_cmd;
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_mgmt_controller_attributes *req;
+ 	struct be_sge *sge = nonembedded_sgl(wrb);
+ 	int status = 0;
+ 
+ 	nonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,
+ 				sizeof(struct be_mgmt_controller_attributes),
+ 				&nonemb_cmd.dma);
+ 	if (nonemb_cmd.va == NULL) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : pci_alloc_consistent failed in %s\n",
+ 			    __func__);
+ 		return -ENOMEM;
+ 	}
+ 	nonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);
+ 	req = nonemb_cmd.va;
+ 	memset(req, 0, sizeof(*req));
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));
+ 	sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));
+ 	sge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);
+ 	sge->len = cpu_to_le32(nonemb_cmd.size);
+ 	status = be_mbox_notify(ctrl);
+ 	if (!status) {
+ 		struct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;
+ 
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : Firmware Version of CMD : %s\n"
+ 			    "Firmware Version is : %s\n"
+ 			    "Developer Build, not performing version check...\n",
+ 			    resp->params.hba_attribs
+ 			    .flashrom_version_string,
+ 			    resp->params.hba_attribs.
+ 			    firmware_version_string);
+ 
+ 		phba->fw_config.iscsi_features =
+ 				resp->params.hba_attribs.iscsi_features;
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BM_%d : phba->fw_config.iscsi_features = %d\n",
+ 			    phba->fw_config.iscsi_features);
+ 		memcpy(phba->fw_ver_str, resp->params.hba_attribs.
+ 		       firmware_version_string, BEISCSI_VER_STRLEN);
+ 	} else
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d :  Failed in beiscsi_check_supported_fw\n");
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	if (nonemb_cmd.va)
+ 		pci_free_consistent(ctrl->pdev, nonemb_cmd.size,
+ 				    nonemb_cmd.va, nonemb_cmd.dma);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * beiscsi_get_fw_config()- Get the FW config for the function
+  * @ctrl: ptr to Ctrl Info
+  * @phba: ptr to the dev priv structure
+  *
+  * Get the FW config and resources available for the function.
+  * The resources are created based on the count received here.
+  *
+  * return
+  *	Success: 0
+  *	Failure: Non-Zero Value
+  **/
+ int beiscsi_get_fw_config(struct be_ctrl_info *ctrl,
+ 			  struct beiscsi_hba *phba)
+ {
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_fw_cfg *pfw_cfg = embedded_payload(wrb);
+ 	uint32_t cid_count, icd_count;
+ 	int status = -EINVAL;
+ 	uint8_t ulp_num = 0;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	be_wrb_hdr_prepare(wrb, sizeof(*pfw_cfg), true, 0);
+ 
+ 	be_cmd_hdr_prepare(&pfw_cfg->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_QUERY_FIRMWARE_CONFIG,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 
+ 	if (be_mbox_notify(ctrl)) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : Failed in beiscsi_get_fw_config\n");
+ 		goto fail_init;
+ 	}
+ 
+ 	/* FW response formats depend on port id */
+ 	phba->fw_config.phys_port = pfw_cfg->phys_port;
+ 	if (phba->fw_config.phys_port >= BEISCSI_PHYS_PORT_MAX) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : invalid physical port id %d\n",
+ 			    phba->fw_config.phys_port);
+ 		goto fail_init;
+ 	}
+ 
+ 	/* populate and check FW config against min and max values */
+ 	if (!is_chip_be2_be3r(phba)) {
+ 		phba->fw_config.eqid_count = pfw_cfg->eqid_count;
+ 		phba->fw_config.cqid_count = pfw_cfg->cqid_count;
+ 		if (phba->fw_config.eqid_count == 0 ||
+ 		    phba->fw_config.eqid_count > 2048) {
+ 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 				    "BG_%d : invalid EQ count %d\n",
+ 				    phba->fw_config.eqid_count);
+ 			goto fail_init;
+ 		}
+ 		if (phba->fw_config.cqid_count == 0 ||
+ 		    phba->fw_config.cqid_count > 4096) {
+ 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 				    "BG_%d : invalid CQ count %d\n",
+ 				    phba->fw_config.cqid_count);
+ 			goto fail_init;
+ 		}
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : EQ_Count : %d CQ_Count : %d\n",
+ 			    phba->fw_config.eqid_count,
+ 			    phba->fw_config.cqid_count);
+ 	}
+ 
+ 	/**
+ 	 * Check on which all ULP iSCSI Protocol is loaded.
+ 	 * Set the Bit for those ULP. This set flag is used
+ 	 * at all places in the code to check on which ULP
+ 	 * iSCSi Protocol is loaded
+ 	 **/
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
+ 		if (pfw_cfg->ulp[ulp_num].ulp_mode &
+ 		    BEISCSI_ULP_ISCSI_INI_MODE) {
+ 			set_bit(ulp_num, &phba->fw_config.ulp_supported);
+ 
+ 			/* Get the CID, ICD and Chain count for each ULP */
+ 			phba->fw_config.iscsi_cid_start[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].sq_base;
+ 			phba->fw_config.iscsi_cid_count[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].sq_count;
+ 
+ 			phba->fw_config.iscsi_icd_start[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].icd_base;
+ 			phba->fw_config.iscsi_icd_count[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].icd_count;
+ 
+ 			phba->fw_config.iscsi_chain_start[ulp_num] =
+ 				pfw_cfg->chain_icd[ulp_num].chain_base;
+ 			phba->fw_config.iscsi_chain_count[ulp_num] =
+ 				pfw_cfg->chain_icd[ulp_num].chain_count;
+ 
+ 			beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 				    "BG_%d : Function loaded on ULP : %d\n"
+ 				    "\tiscsi_cid_count : %d\n"
+ 				    "\tiscsi_cid_start : %d\n"
+ 				    "\t iscsi_icd_count : %d\n"
+ 				    "\t iscsi_icd_start : %d\n",
+ 				    ulp_num,
+ 				    phba->fw_config.
+ 				    iscsi_cid_count[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_cid_start[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_icd_count[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_icd_start[ulp_num]);
+ 		}
+ 	}
+ 
+ 	if (phba->fw_config.ulp_supported == 0) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : iSCSI initiator mode not set: ULP0 %x ULP1 %x\n",
+ 			    pfw_cfg->ulp[BEISCSI_ULP0].ulp_mode,
+ 			    pfw_cfg->ulp[BEISCSI_ULP1].ulp_mode);
+ 		goto fail_init;
+ 	}
+ 
+ 	/**
+ 	 * ICD is shared among ULPs. Use icd_count of any one loaded ULP
+ 	 **/
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)
+ 		if (test_bit(ulp_num, &phba->fw_config.ulp_supported))
+ 			break;
+ 	icd_count = phba->fw_config.iscsi_icd_count[ulp_num];
+ 	if (icd_count == 0 || icd_count > 65536) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d: invalid ICD count %d\n", icd_count);
+ 		goto fail_init;
+ 	}
+ 
+ 	cid_count = BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP0) +
+ 		    BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP1);
+ 	if (cid_count == 0 || cid_count > 4096) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d: invalid CID count %d\n", cid_count);
+ 		goto fail_init;
+ 	}
+ 
+ 	/**
+ 	 * Check FW is dual ULP aware i.e. can handle either
+ 	 * of the protocols.
+ 	 */
+ 	phba->fw_config.dual_ulp_aware = (pfw_cfg->function_mode &
+ 					  BEISCSI_FUNC_DUA_MODE);
+ 
+ 	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 		    "BG_%d : DUA Mode : 0x%x\n",
+ 		    phba->fw_config.dual_ulp_aware);
+ 
+ 	/* all set, continue using this FW config */
+ 	status = 0;
+ fail_init:
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ /**
+  * beiscsi_get_port_name()- Get port name for the function
+  * @ctrl: ptr to Ctrl Info
+  * @phba: ptr to the dev priv structure
+  *
+  * Get the alphanumeric character for port
+  *
+  **/
+ int beiscsi_get_port_name(struct be_ctrl_info *ctrl, struct beiscsi_hba *phba)
+ {
+ 	int ret = 0;
+ 	struct be_mcc_wrb *wrb;
+ 	struct be_cmd_get_port_name *ioctl;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	ioctl = embedded_payload(wrb);
+ 
+ 	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
+ 	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_GET_PORT_NAME,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 	ret = be_mbox_notify(ctrl);
+ 	phba->port_name = 0;
+ 	if (!ret) {
+ 		phba->port_name = ioctl->p.resp.port_names >>
+ 				  (phba->fw_config.phys_port * 8) & 0xff;
+ 	} else {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : GET_PORT_NAME ret 0x%x status 0x%x\n",
+ 			    ret, ioctl->h.resp_hdr.status);
+ 	}
+ 
+ 	if (phba->port_name == 0)
+ 		phba->port_name = '?';
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return ret;
+ }
+ 
+ int beiscsi_set_uer_feature(struct beiscsi_hba *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_cmd_set_features *ioctl;
+ 	struct be_mcc_wrb *wrb;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	ioctl = embedded_payload(wrb);
+ 
+ 	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
+ 	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_SET_FEATURES,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 	ioctl->feature = BE_CMD_SET_FEATURE_UER;
+ 	ioctl->param_len = sizeof(ioctl->param.req);
+ 	ioctl->param.req.uer = BE_CMD_UER_SUPP_BIT;
+ 	ret = be_mbox_notify(ctrl);
+ 	if (!ret) {
+ 		phba->ue2rp = ioctl->param.resp.ue2rp;
+ 		set_bit(BEISCSI_HBA_UER_SUPP, &phba->state);
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : HBA error recovery supported\n");
+ 	} else {
+ 		/**
+ 		 * Check "MCC_STATUS_INVALID_LENGTH" for SKH.
+ 		 * Older FW versions return this error.
+ 		 */
+ 		if (ret == MCC_STATUS_ILLEGAL_REQUEST ||
+ 		    ret == MCC_STATUS_INVALID_LENGTH)
+ 			__beiscsi_log(phba, KERN_INFO,
+ 				      "BG_%d : HBA error recovery not supported\n");
+ 	}
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return ret;
+ }
+ 
+ static u32 beiscsi_get_post_stage(struct beiscsi_hba *phba)
+ {
+ 	u32 sem;
+ 
+ 	if (is_chip_be2_be3r(phba))
+ 		sem = ioread32(phba->csr_va + SLIPORT_SEMAPHORE_OFFSET_BEx);
+ 	else
+ 		pci_read_config_dword(phba->pcidev,
+ 				      SLIPORT_SEMAPHORE_OFFSET_SH, &sem);
+ 	return sem;
+ }
+ 
+ int beiscsi_check_fw_rdy(struct beiscsi_hba *phba)
+ {
+ 	u32 loop, post, rdy = 0;
+ 
+ 	loop = 1000;
+ 	while (loop--) {
+ 		post = beiscsi_get_post_stage(phba);
+ 		if (post & POST_ERROR_BIT)
+ 			break;
+ 		if ((post & POST_STAGE_MASK) == POST_STAGE_ARMFW_RDY) {
+ 			rdy = 1;
+ 			break;
+ 		}
+ 		msleep(60);
+ 	}
+ 
+ 	if (!rdy) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BC_%d : FW not ready 0x%x\n", post);
+ 	}
+ 
+ 	return rdy;
+ }
+ 
+ int beiscsi_cmd_function_reset(struct beiscsi_hba *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_post_sgl_pages_req *req;
+ 	int status;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 
+ 	req = embedded_payload(wrb);
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_FUNCTION_RESET, sizeof(*req));
+ 	status = be_mbox_notify(ctrl);
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ int beiscsi_cmd_special_wrb(struct be_ctrl_info *ctrl, u32 load)
+ {
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
+ 	u8 *endian_check;
+ 	int status;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 
+ 	endian_check = (u8 *) wrb;
+ 	if (load) {
+ 		/* to start communicating */
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0x12;
+ 		*endian_check++ = 0x34;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0x56;
+ 		*endian_check++ = 0x78;
+ 		*endian_check++ = 0xFF;
+ 	} else {
+ 		/* to stop communicating */
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xAA;
+ 		*endian_check++ = 0xBB;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xCC;
+ 		*endian_check++ = 0xDD;
+ 		*endian_check = 0xFF;
+ 	}
+ 	be_dws_cpu_to_le(wrb, sizeof(*wrb));
+ 
+ 	status = be_mbox_notify(ctrl);
+ 	if (status)
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BC_%d : special WRB message failed\n");
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ int beiscsi_init_sliport(struct beiscsi_hba *phba)
+ {
+ 	int status;
+ 
+ 	/* check POST stage before talking to FW */
+ 	status = beiscsi_check_fw_rdy(phba);
+ 	if (!status)
+ 		return -EIO;
+ 
+ 	/* clear all error states after checking FW rdy */
+ 	phba->state &= ~BEISCSI_HBA_IN_ERR;
+ 
+ 	/* check again UER support */
+ 	phba->state &= ~BEISCSI_HBA_UER_SUPP;
+ 
+ 	/*
+ 	 * SLI COMMON_FUNCTION_RESET completion is indicated by BMBX RDY bit.
+ 	 * It should clean up any stale info in FW for this fn.
+ 	 */
+ 	status = beiscsi_cmd_function_reset(phba);
+ 	if (status) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BC_%d : SLI Function Reset failed\n");
+ 		return status;
+ 	}
+ 
+ 	/* indicate driver is loading */
+ 	return beiscsi_cmd_special_wrb(&phba->ctrl, 1);
+ }
+ 
+ /**
+  * beiscsi_cmd_iscsi_cleanup()- Inform FW to cleanup EP data structures.
+  * @phba: pointer to dev priv structure
+  * @ulp: ULP number.
+  *
+  * return
+  *	Success: 0
+  *	Failure: Non-Zero Value
+  **/
+ int beiscsi_cmd_iscsi_cleanup(struct beiscsi_hba *phba, unsigned short ulp)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct iscsi_cleanup_req_v1 *req_v1;
+ 	struct iscsi_cleanup_req *req;
+ 	u16 hdr_ring_id, data_ring_id;
+ 	struct be_mcc_wrb *wrb;
+ 	int status;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 
+ 	hdr_ring_id = HWI_GET_DEF_HDRQ_ID(phba, ulp);
+ 	data_ring_id = HWI_GET_DEF_BUFQ_ID(phba, ulp);
+ 	if (is_chip_be2_be3r(phba)) {
+ 		req = embedded_payload(wrb);
+ 		be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+ 		be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,
+ 				   OPCODE_COMMON_ISCSI_CLEANUP, sizeof(*req));
+ 		req->chute = (1 << ulp);
+ 		/* BE2/BE3 FW creates 8-bit ring id */
+ 		req->hdr_ring_id = hdr_ring_id;
+ 		req->data_ring_id = data_ring_id;
+ 	} else {
+ 		req_v1 = embedded_payload(wrb);
+ 		be_wrb_hdr_prepare(wrb, sizeof(*req_v1), true, 0);
+ 		be_cmd_hdr_prepare(&req_v1->hdr, CMD_SUBSYSTEM_ISCSI,
+ 				   OPCODE_COMMON_ISCSI_CLEANUP,
+ 				   sizeof(*req_v1));
+ 		req_v1->hdr.version = 1;
+ 		req_v1->chute = (1 << ulp);
+ 		req_v1->hdr_ring_id = cpu_to_le16(hdr_ring_id);
+ 		req_v1->data_ring_id = cpu_to_le16(data_ring_id);
+ 	}
+ 
+ 	status = be_mbox_notify(ctrl);
+ 	if (status)
+ 		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+ 			    "BG_%d : %s failed %d\n", __func__, ulp);
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ /*
+  * beiscsi_detect_ue()- Detect Unrecoverable Error on adapter
+  * @phba: Driver priv structure
+  *
+  * Read registers linked to UE and check for the UE status
+  **/
+ int beiscsi_detect_ue(struct beiscsi_hba *phba)
+ {
+ 	uint32_t ue_mask_hi = 0, ue_mask_lo = 0;
+ 	uint32_t ue_hi = 0, ue_lo = 0;
+ 	uint8_t i = 0;
+ 	int ret = 0;
+ 
+ 	pci_read_config_dword(phba->pcidev,
+ 			      PCICFG_UE_STATUS_LOW, &ue_lo);
+ 	pci_read_config_dword(phba->pcidev,
+ 			      PCICFG_UE_STATUS_MASK_LOW,
+ 			      &ue_mask_lo);
+ 	pci_read_config_dword(phba->pcidev,
+ 			      PCICFG_UE_STATUS_HIGH,
+ 			      &ue_hi);
+ 	pci_read_config_dword(phba->pcidev,
+ 			      PCICFG_UE_STATUS_MASK_HI,
+ 			      &ue_mask_hi);
+ 
+ 	ue_lo = (ue_lo & ~ue_mask_lo);
+ 	ue_hi = (ue_hi & ~ue_mask_hi);
+ 
+ 
+ 	if (ue_lo || ue_hi) {
+ 		set_bit(BEISCSI_HBA_IN_UE, &phba->state);
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BC_%d : HBA error detected\n");
+ 		ret = 1;
+ 	}
+ 
+ 	if (ue_lo) {
+ 		for (i = 0; ue_lo; ue_lo >>= 1, i++) {
+ 			if (ue_lo & 1)
+ 				__beiscsi_log(phba, KERN_ERR,
+ 					      "BC_%d : UE_LOW %s bit set\n",
+ 					      desc_ue_status_low[i]);
+ 		}
+ 	}
+ 
+ 	if (ue_hi) {
+ 		for (i = 0; ue_hi; ue_hi >>= 1, i++) {
+ 			if (ue_hi & 1)
+ 				__beiscsi_log(phba, KERN_ERR,
+ 					      "BC_%d : UE_HIGH %s bit set\n",
+ 					      desc_ue_status_hi[i]);
+ 		}
+ 	}
+ 	return ret;
+ }
+ 
+ /*
+  * beiscsi_detect_tpe()- Detect Transient Parity Error on adapter
+  * @phba: Driver priv structure
+  *
+  * Read SLIPORT SEMAPHORE register to check for UER
+  *
+  **/
+ int beiscsi_detect_tpe(struct beiscsi_hba *phba)
+ {
+ 	u32 post, status;
+ 	int ret = 0;
+ 
+ 	post = beiscsi_get_post_stage(phba);
+ 	status = post & POST_STAGE_MASK;
+ 	if ((status & POST_ERR_RECOVERY_CODE_MASK) ==
+ 	    POST_STAGE_RECOVERABLE_ERR) {
+ 		set_bit(BEISCSI_HBA_IN_TPE, &phba->state);
+ 		__beiscsi_log(phba, KERN_INFO,
+ 			      "BC_%d : HBA error recoverable: 0x%x\n", post);
+ 		ret = 1;
+ 	} else {
+ 		__beiscsi_log(phba, KERN_INFO,
+ 			      "BC_%d : HBA in UE: 0x%x\n", post);
+ 	}
+ 
+ 	return ret;
+ }
++>>>>>>> fa1261c4b683 (scsi: be2iscsi: Remove unused struct members)
diff --cc drivers/scsi/be2iscsi/be_main.c
index ff265d59e294,a8e67c6186f8..000000000000
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@@ -1511,16 -1326,15 +1508,23 @@@ static void adapter_get_sol_cqe(struct 
  static void hwi_complete_cmd(struct beiscsi_conn *beiscsi_conn,
  			     struct beiscsi_hba *phba, struct sol_cqe *psol)
  {
 -	struct iscsi_conn *conn = beiscsi_conn->conn;
 -	struct iscsi_session *session = conn->session;
 +	struct hwi_wrb_context *pwrb_context;
 +	struct wrb_handle *pwrb_handle;
 +	struct iscsi_wrb *pwrb = NULL;
 +	struct hwi_controller *phwi_ctrlr;
 +	struct iscsi_task *task;
 +	unsigned int type;
 +	struct iscsi_conn *conn = beiscsi_conn->conn;
 +	struct iscsi_session *session = conn->session;
  	struct common_sol_cqe csol_cqe = {0};
++<<<<<<< HEAD
++=======
+ 	struct hwi_wrb_context *pwrb_context;
+ 	struct hwi_controller *phwi_ctrlr;
+ 	struct wrb_handle *pwrb_handle;
+ 	struct iscsi_task *task;
++>>>>>>> fa1261c4b683 (scsi: be2iscsi: Remove unused struct members)
  	uint16_t cri_index = 0;
 -	uint8_t type;
  
  	phwi_ctrlr = phba->phwi_ctrlr;
  
@@@ -1533,11 -1347,14 +1537,18 @@@
  	pwrb_handle = pwrb_context->pwrb_handle_basestd[
  		      csol_cqe.wrb_index];
  
 -	spin_lock_bh(&session->back_lock);
  	task = pwrb_handle->pio_handle;
++<<<<<<< HEAD
 +	pwrb = pwrb_handle->pwrb;
++=======
+ 	if (!task) {
+ 		spin_unlock_bh(&session->back_lock);
+ 		return;
+ 	}
++>>>>>>> fa1261c4b683 (scsi: be2iscsi: Remove unused struct members)
  	type = ((struct beiscsi_io_task *)task->dd_data)->wrb_type;
  
 +	spin_lock_bh(&session->lock);
  	switch (type) {
  	case HWH_TYPE_IO:
  	case HWH_TYPE_IO_RD:
@@@ -1663,347 -1563,260 +1674,360 @@@ hwi_get_async_handle(struct beiscsi_hb
  	return pasync_handle;
  }
  
 -static void
 -beiscsi_hdl_purge_handles(struct beiscsi_hba *phba,
 -			  struct hd_async_context *pasync_ctx,
 -			  u16 cri)
 +static unsigned int
 +hwi_update_async_writables(struct beiscsi_hba *phba,
 +			    struct hwi_async_pdu_context *pasync_ctx,
 +			    unsigned int is_header, unsigned int cq_index)
  {
 -	struct hd_async_handle *pasync_handle, *tmp_handle;
 -	struct list_head *plist;
 +	struct list_head *pbusy_list;
 +	struct async_pdu_handle *pasync_handle;
 +	unsigned int num_entries, writables = 0;
 +	unsigned int *pep_read_ptr, *pwritables;
 +
 +	num_entries = pasync_ctx->num_entries;
 +	if (is_header) {
 +		pep_read_ptr = &pasync_ctx->async_header.ep_read_ptr;
 +		pwritables = &pasync_ctx->async_header.writables;
 +	} else {
 +		pep_read_ptr = &pasync_ctx->async_data.ep_read_ptr;
 +		pwritables = &pasync_ctx->async_data.writables;
 +	}
  
 -	plist  = &pasync_ctx->async_entry[cri].wq.list;
 -	list_for_each_entry_safe(pasync_handle, tmp_handle, plist, link) {
 -		list_del(&pasync_handle->link);
 -		beiscsi_hdl_put_handle(pasync_ctx, pasync_handle);
 +	while ((*pep_read_ptr) != cq_index) {
 +		(*pep_read_ptr)++;
 +		*pep_read_ptr = (*pep_read_ptr) % num_entries;
 +
 +		pbusy_list = hwi_get_async_busy_list(pasync_ctx, is_header,
 +						     *pep_read_ptr);
 +		if (writables == 0)
 +			WARN_ON(list_empty(pbusy_list));
 +
 +		if (!list_empty(pbusy_list)) {
 +			pasync_handle = list_entry(pbusy_list->next,
 +						   struct async_pdu_handle,
 +						   link);
 +			WARN_ON(!pasync_handle);
 +			pasync_handle->consumed = 1;
 +		}
 +
 +		writables++;
  	}
  
 -	INIT_LIST_HEAD(&pasync_ctx->async_entry[cri].wq.list);
 -	pasync_ctx->async_entry[cri].wq.hdr_len = 0;
 -	pasync_ctx->async_entry[cri].wq.bytes_received = 0;
 -	pasync_ctx->async_entry[cri].wq.bytes_needed = 0;
 +	if (!writables) {
 +		beiscsi_log(phba, KERN_ERR,
 +			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,
 +			    "BM_%d : Duplicate notification received - index 0x%x!!\n",
 +			    cq_index);
 +		WARN_ON(1);
 +	}
 +
 +	*pwritables = *pwritables + writables;
 +	return 0;
  }
  
 -static unsigned int
 -beiscsi_hdl_fwd_pdu(struct beiscsi_conn *beiscsi_conn,
 -		    struct hd_async_context *pasync_ctx,
 -		    u16 cri)
 +static void hwi_free_async_msg(struct beiscsi_hba *phba,
 +			       struct hwi_async_pdu_context *pasync_ctx,
 +			       unsigned int cri)
  {
 -	struct iscsi_session *session = beiscsi_conn->conn->session;
 -	struct hd_async_handle *pasync_handle, *plast_handle;
 -	struct beiscsi_hba *phba = beiscsi_conn->phba;
 -	void *phdr = NULL, *pdata = NULL;
 -	u32 dlen = 0, status = 0;
 +	struct async_pdu_handle *pasync_handle, *tmp_handle;
  	struct list_head *plist;
  
 -	plist = &pasync_ctx->async_entry[cri].wq.list;
 -	plast_handle = NULL;
 -	list_for_each_entry(pasync_handle, plist, link) {
 -		plast_handle = pasync_handle;
 -		/* get the header, the first entry */
 -		if (!phdr) {
 -			phdr = pasync_handle->pbuffer;
 -			continue;
 -		}
 -		/* use first buffer to collect all the data */
 -		if (!pdata) {
 -			pdata = pasync_handle->pbuffer;
 -			dlen = pasync_handle->buffer_len;
 -			continue;
 +	plist  = &pasync_ctx->async_entry[cri].wait_queue.list;
 +	list_for_each_entry_safe(pasync_handle, tmp_handle, plist, link) {
 +		list_del(&pasync_handle->link);
 +
 +		if (pasync_handle->is_header) {
 +			list_add_tail(&pasync_handle->link,
 +				      &pasync_ctx->async_header.free_list);
 +			pasync_ctx->async_header.free_entries++;
 +		} else {
 +			list_add_tail(&pasync_handle->link,
 +				      &pasync_ctx->async_data.free_list);
 +			pasync_ctx->async_data.free_entries++;
  		}
 -		memcpy(pdata + dlen, pasync_handle->pbuffer,
 -		       pasync_handle->buffer_len);
 -		dlen += pasync_handle->buffer_len;
 -	}
 -
 -	if (!plast_handle->is_final) {
 -		/* last handle should have final PDU notification from FW */
 -		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_ISCSI,
 -			    "BM_%d : cid %u %p fwd async PDU with last handle missing - HL%u:DN%u:DR%u\n",
 -			    beiscsi_conn->beiscsi_conn_cid, plast_handle,
 -			    pasync_ctx->async_entry[cri].wq.hdr_len,
 -			    pasync_ctx->async_entry[cri].wq.bytes_needed,
 -			    pasync_ctx->async_entry[cri].wq.bytes_received);
 -	}
 -	spin_lock_bh(&session->back_lock);
 -	status = beiscsi_complete_pdu(beiscsi_conn, phdr, pdata, dlen);
 -	spin_unlock_bh(&session->back_lock);
 -	beiscsi_hdl_purge_handles(phba, pasync_ctx, cri);
 -	return status;
 +	}
 +
 +	INIT_LIST_HEAD(&pasync_ctx->async_entry[cri].wait_queue.list);
 +	pasync_ctx->async_entry[cri].wait_queue.hdr_received = 0;
 +	pasync_ctx->async_entry[cri].wait_queue.bytes_received = 0;
  }
  
 -static unsigned int
 -beiscsi_hdl_gather_pdu(struct beiscsi_conn *beiscsi_conn,
 -		       struct hd_async_context *pasync_ctx,
 -		       struct hd_async_handle *pasync_handle)
 +static struct phys_addr *
 +hwi_get_ring_address(struct hwi_async_pdu_context *pasync_ctx,
 +		     unsigned int is_header, unsigned int host_write_ptr)
  {
 -	unsigned int bytes_needed = 0, status = 0;
 -	u16 cri = pasync_handle->cri;
 -	struct cri_wait_queue *wq;
 -	struct beiscsi_hba *phba;
 -	struct pdu_base *ppdu;
 -	char *err = "";
 +	struct phys_addr *pasync_sge = NULL;
  
 -	phba = beiscsi_conn->phba;
 -	wq = &pasync_ctx->async_entry[cri].wq;
 -	if (pasync_handle->is_header) {
 -		/* check if PDU hdr is rcv'd when old hdr not completed */
 -		if (wq->hdr_len) {
 -			err = "incomplete";
 -			goto drop_pdu;
 -		}
 -		ppdu = pasync_handle->pbuffer;
 -		bytes_needed = AMAP_GET_BITS(struct amap_pdu_base,
 -					     data_len_hi, ppdu);
 -		bytes_needed <<= 16;
 -		bytes_needed |= be16_to_cpu(AMAP_GET_BITS(struct amap_pdu_base,
 -							  data_len_lo, ppdu));
 -		wq->hdr_len = pasync_handle->buffer_len;
 -		wq->bytes_received = 0;
 -		wq->bytes_needed = bytes_needed;
 -		list_add_tail(&pasync_handle->link, &wq->list);
 -		if (!bytes_needed)
 -			status = beiscsi_hdl_fwd_pdu(beiscsi_conn,
 -						     pasync_ctx, cri);
 -	} else {
 -		/* check if data received has header and is needed */
 -		if (!wq->hdr_len || !wq->bytes_needed) {
 -			err = "header less";
 -			goto drop_pdu;
 -		}
 -		wq->bytes_received += pasync_handle->buffer_len;
 -		/* Something got overwritten? Better catch it here. */
 -		if (wq->bytes_received > wq->bytes_needed) {
 -			err = "overflow";
 -			goto drop_pdu;
 -		}
 -		list_add_tail(&pasync_handle->link, &wq->list);
 -		if (wq->bytes_received == wq->bytes_needed)
 -			status = beiscsi_hdl_fwd_pdu(beiscsi_conn,
 -						     pasync_ctx, cri);
 -	}
 -	return status;
 +	if (is_header)
 +		pasync_sge = pasync_ctx->async_header.ring_base;
 +	else
 +		pasync_sge = pasync_ctx->async_data.ring_base;
  
 -drop_pdu:
 -	beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_ISCSI,
 -		    "BM_%d : cid %u async PDU %s - def-%c:HL%u:DN%u:DR%u\n",
 -		    beiscsi_conn->beiscsi_conn_cid, err,
 -		    pasync_handle->is_header ? 'H' : 'D',
 -		    wq->hdr_len, wq->bytes_needed,
 -		    pasync_handle->buffer_len);
 -	/* discard this handle */
 -	beiscsi_hdl_put_handle(pasync_ctx, pasync_handle);
 -	/* free all the other handles in cri_wait_queue */
 -	beiscsi_hdl_purge_handles(phba, pasync_ctx, cri);
 -	/* try continuing */
 -	return status;
 +	return pasync_sge + host_write_ptr;
  }
  
 -static void
 -beiscsi_hdq_post_handles(struct beiscsi_hba *phba,
 -			 u8 header, u8 ulp_num)
 +static void hwi_post_async_buffers(struct beiscsi_hba *phba,
 +				    unsigned int is_header, uint8_t ulp_num)
  {
 -	struct hd_async_handle *pasync_handle, *tmp, **slot;
 -	struct hd_async_context *pasync_ctx;
  	struct hwi_controller *phwi_ctrlr;
 -	struct list_head *hfree_list;
 +	struct hwi_async_pdu_context *pasync_ctx;
 +	struct async_pdu_handle *pasync_handle;
 +	struct list_head *pfree_link, *pbusy_list;
  	struct phys_addr *pasync_sge;
++<<<<<<< HEAD
 +	unsigned int ring_id, num_entries;
 +	unsigned int host_write_num, doorbell_offset;
 +	unsigned int writables;
 +	unsigned int i = 0;
 +	u32 doorbell = 0;
 +
 +	phwi_ctrlr = phba->phwi_ctrlr;
 +	pasync_ctx = HWI_GET_ASYNC_PDU_CTX(phwi_ctrlr, ulp_num);
 +	num_entries = pasync_ctx->num_entries;
 +
 +	if (is_header) {
 +		writables = min(pasync_ctx->async_header.writables,
 +				pasync_ctx->async_header.free_entries);
 +		pfree_link = pasync_ctx->async_header.free_list.next;
 +		host_write_num = pasync_ctx->async_header.host_write_ptr;
++=======
+ 	u32 ring_id, doorbell = 0;
+ 	u32 doorbell_offset;
+ 	u16 prod = 0, cons;
+ 	u16 index;
+ 
+ 	phwi_ctrlr = phba->phwi_ctrlr;
+ 	pasync_ctx = HWI_GET_ASYNC_PDU_CTX(phwi_ctrlr, ulp_num);
+ 	if (header) {
+ 		cons = pasync_ctx->async_header.free_entries;
+ 		hfree_list = &pasync_ctx->async_header.free_list;
++>>>>>>> fa1261c4b683 (scsi: be2iscsi: Remove unused struct members)
  		ring_id = phwi_ctrlr->default_pdu_hdr[ulp_num].id;
  		doorbell_offset = phwi_ctrlr->default_pdu_hdr[ulp_num].
 -					doorbell_offset;
 +				  doorbell_offset;
  	} else {
 -		cons = pasync_ctx->async_data.free_entries;
 -		hfree_list = &pasync_ctx->async_data.free_list;
 +		writables = min(pasync_ctx->async_data.writables,
 +				pasync_ctx->async_data.free_entries);
 +		pfree_link = pasync_ctx->async_data.free_list.next;
 +		host_write_num = pasync_ctx->async_data.host_write_ptr;
  		ring_id = phwi_ctrlr->default_pdu_data[ulp_num].id;
  		doorbell_offset = phwi_ctrlr->default_pdu_data[ulp_num].
 -					doorbell_offset;
 +				  doorbell_offset;
  	}
 -	/* number of entries posted must be in multiples of 8 */
 -	if (cons % 8)
 -		return;
  
 -	list_for_each_entry_safe(pasync_handle, tmp, hfree_list, link) {
 -		list_del_init(&pasync_handle->link);
 -		pasync_handle->is_final = 0;
 -		pasync_handle->buffer_len = 0;
 +	writables = (writables / 8) * 8;
 +	if (writables) {
 +		for (i = 0; i < writables; i++) {
 +			pbusy_list =
 +			    hwi_get_async_busy_list(pasync_ctx, is_header,
 +						    host_write_num);
 +			pasync_handle =
 +			    list_entry(pfree_link, struct async_pdu_handle,
 +								link);
 +			WARN_ON(!pasync_handle);
 +			pasync_handle->consumed = 0;
  
 -		/* handles can be consumed out of order, use index in handle */
 -		index = pasync_handle->index;
 -		WARN_ON(pasync_handle->is_header != header);
 -		if (header)
 -			slot = &pasync_ctx->async_entry[index].header;
 -		else
 -			slot = &pasync_ctx->async_entry[index].data;
 -		/**
 -		 * The slot just tracks handle's hold and release, so
 -		 * overwriting at the same index won't do any harm but
 -		 * needs to be caught.
 -		 */
 -		if (*slot != NULL) {
 -			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_ISCSI,
 -				    "BM_%d : async PDU %s slot at %u not empty\n",
 -				    header ? "header" : "data", index);
 +			pfree_link = pfree_link->next;
 +
 +			pasync_sge = hwi_get_ring_address(pasync_ctx,
 +						is_header, host_write_num);
 +
 +			pasync_sge->hi = pasync_handle->pa.u.a32.address_lo;
 +			pasync_sge->lo = pasync_handle->pa.u.a32.address_hi;
 +
 +			list_move(&pasync_handle->link, pbusy_list);
 +
 +			host_write_num++;
 +			host_write_num = host_write_num % num_entries;
  		}
 -		/**
 -		 * We use same freed index as in completion to post so this
 -		 * operation is not required for refills. Its required only
 -		 * for ring creation.
 -		 */
 -		if (header)
 -			pasync_sge = pasync_ctx->async_header.ring_base;
 -		else
 -			pasync_sge = pasync_ctx->async_data.ring_base;
 -		pasync_sge += index;
 -		/* if its a refill then address is same; hi is lo */
 -		WARN_ON(pasync_sge->hi &&
 -			pasync_sge->hi != pasync_handle->pa.u.a32.address_lo);
 -		WARN_ON(pasync_sge->lo &&
 -			pasync_sge->lo != pasync_handle->pa.u.a32.address_hi);
 -		pasync_sge->hi = pasync_handle->pa.u.a32.address_lo;
 -		pasync_sge->lo = pasync_handle->pa.u.a32.address_hi;
 -
 -		*slot = pasync_handle;
 -		if (++prod == cons)
 -			break;
 +
 +		if (is_header) {
 +			pasync_ctx->async_header.host_write_ptr =
 +							host_write_num;
 +			pasync_ctx->async_header.free_entries -= writables;
 +			pasync_ctx->async_header.writables -= writables;
 +			pasync_ctx->async_header.busy_entries += writables;
 +		} else {
 +			pasync_ctx->async_data.host_write_ptr = host_write_num;
 +			pasync_ctx->async_data.free_entries -= writables;
 +			pasync_ctx->async_data.writables -= writables;
 +			pasync_ctx->async_data.busy_entries += writables;
 +		}
 +
 +		doorbell |= ring_id & DB_DEF_PDU_RING_ID_MASK;
 +		doorbell |= 1 << DB_DEF_PDU_REARM_SHIFT;
 +		doorbell |= 0 << DB_DEF_PDU_EVENT_SHIFT;
 +		doorbell |= (writables & DB_DEF_PDU_CQPROC_MASK)
 +					<< DB_DEF_PDU_CQPROC_SHIFT;
 +
 +		iowrite32(doorbell, phba->db_va + doorbell_offset);
  	}
 -	if (header)
 -		pasync_ctx->async_header.free_entries -= prod;
 -	else
 -		pasync_ctx->async_data.free_entries -= prod;
 +}
  
 -	doorbell |= ring_id & DB_DEF_PDU_RING_ID_MASK;
 -	doorbell |= 1 << DB_DEF_PDU_REARM_SHIFT;
 -	doorbell |= 0 << DB_DEF_PDU_EVENT_SHIFT;
 -	doorbell |= (prod & DB_DEF_PDU_CQPROC_MASK) << DB_DEF_PDU_CQPROC_SHIFT;
 -	iowrite32(doorbell, phba->db_va + doorbell_offset);
 +static void hwi_flush_default_pdu_buffer(struct beiscsi_hba *phba,
 +					 struct beiscsi_conn *beiscsi_conn,
 +					 struct i_t_dpdu_cqe *pdpdu_cqe)
 +{
 +	struct hwi_controller *phwi_ctrlr;
 +	struct hwi_async_pdu_context *pasync_ctx;
 +	struct async_pdu_handle *pasync_handle = NULL;
 +	unsigned int cq_index = -1;
 +	uint16_t cri_index = BE_GET_CRI_FROM_CID(
 +			     beiscsi_conn->beiscsi_conn_cid);
 +
 +	phwi_ctrlr = phba->phwi_ctrlr;
 +	pasync_ctx = HWI_GET_ASYNC_PDU_CTX(phwi_ctrlr,
 +		     BEISCSI_GET_ULP_FROM_CRI(phwi_ctrlr,
 +		     cri_index));
 +
 +	pasync_handle = hwi_get_async_handle(phba, beiscsi_conn, pasync_ctx,
 +					     pdpdu_cqe, &cq_index);
 +	BUG_ON(pasync_handle->is_header != 0);
 +	if (pasync_handle->consumed == 0)
 +		hwi_update_async_writables(phba, pasync_ctx,
 +					   pasync_handle->is_header, cq_index);
 +
 +	hwi_free_async_msg(phba, pasync_ctx, pasync_handle->cri);
 +	hwi_post_async_buffers(phba, pasync_handle->is_header,
 +			       BEISCSI_GET_ULP_FROM_CRI(phwi_ctrlr,
 +			       cri_index));
  }
  
 -static void
 -beiscsi_hdq_process_compl(struct beiscsi_conn *beiscsi_conn,
 -			  struct i_t_dpdu_cqe *pdpdu_cqe)
 +static unsigned int
 +hwi_fwd_async_msg(struct beiscsi_conn *beiscsi_conn,
 +		  struct beiscsi_hba *phba,
 +		  struct hwi_async_pdu_context *pasync_ctx, unsigned short cri)
  {
 -	struct beiscsi_hba *phba = beiscsi_conn->phba;
 -	struct hd_async_handle *pasync_handle = NULL;
 -	struct hd_async_context *pasync_ctx;
 +	struct list_head *plist;
 +	struct async_pdu_handle *pasync_handle;
 +	void *phdr = NULL;
 +	unsigned int hdr_len = 0, buf_len = 0;
 +	unsigned int status, index = 0, offset = 0;
 +	void *pfirst_buffer = NULL;
 +	unsigned int num_buf = 0;
 +
 +	plist = &pasync_ctx->async_entry[cri].wait_queue.list;
 +
 +	list_for_each_entry(pasync_handle, plist, link) {
 +		if (index == 0) {
 +			phdr = pasync_handle->pbuffer;
 +			hdr_len = pasync_handle->buffer_len;
 +		} else {
 +			buf_len = pasync_handle->buffer_len;
 +			if (!num_buf) {
 +				pfirst_buffer = pasync_handle->pbuffer;
 +				num_buf++;
 +			}
 +			memcpy(pfirst_buffer + offset,
 +			       pasync_handle->pbuffer, buf_len);
 +			offset += buf_len;
 +		}
 +		index++;
 +	}
 +
 +	status = beiscsi_process_async_pdu(beiscsi_conn, phba,
 +					    phdr, hdr_len, pfirst_buffer,
 +					    offset);
 +
 +	hwi_free_async_msg(phba, pasync_ctx, cri);
 +	return 0;
 +}
 +
 +static unsigned int
 +hwi_gather_async_pdu(struct beiscsi_conn *beiscsi_conn,
 +		     struct beiscsi_hba *phba,
 +		     struct async_pdu_handle *pasync_handle)
 +{
 +	struct hwi_async_pdu_context *pasync_ctx;
  	struct hwi_controller *phwi_ctrlr;
 -	u16 cid_cri;
 -	u8 ulp_num;
 +	unsigned int bytes_needed = 0, status = 0;
 +	unsigned short cri = pasync_handle->cri;
 +	struct pdu_base *ppdu;
  
  	phwi_ctrlr = phba->phwi_ctrlr;
 -	cid_cri = BE_GET_CRI_FROM_CID(beiscsi_conn->beiscsi_conn_cid);
 -	ulp_num = BEISCSI_GET_ULP_FROM_CRI(phwi_ctrlr, cid_cri);
 -	pasync_ctx = HWI_GET_ASYNC_PDU_CTX(phwi_ctrlr, ulp_num);
 -	pasync_handle = beiscsi_hdl_get_handle(beiscsi_conn, pasync_ctx,
 -					       pdpdu_cqe);
 -	if (!pasync_handle)
 -		return;
 +	pasync_ctx = HWI_GET_ASYNC_PDU_CTX(phwi_ctrlr,
 +		     BEISCSI_GET_ULP_FROM_CRI(phwi_ctrlr,
 +		     BE_GET_CRI_FROM_CID(beiscsi_conn->
 +				 beiscsi_conn_cid)));
 +
 +	list_del(&pasync_handle->link);
 +	if (pasync_handle->is_header) {
 +		pasync_ctx->async_header.busy_entries--;
 +		if (pasync_ctx->async_entry[cri].wait_queue.hdr_received) {
 +			hwi_free_async_msg(phba, pasync_ctx, cri);
 +			BUG();
 +		}
 +
 +		pasync_ctx->async_entry[cri].wait_queue.bytes_received = 0;
 +		pasync_ctx->async_entry[cri].wait_queue.hdr_received = 1;
 +		pasync_ctx->async_entry[cri].wait_queue.hdr_len =
 +				(unsigned short)pasync_handle->buffer_len;
 +		list_add_tail(&pasync_handle->link,
 +			      &pasync_ctx->async_entry[cri].wait_queue.list);
 +
 +		ppdu = pasync_handle->pbuffer;
 +		bytes_needed = ((((ppdu->dw[offsetof(struct amap_pdu_base,
 +			data_len_hi) / 32] & PDUBASE_DATALENHI_MASK) << 8) &
 +			0xFFFF0000) | ((be16_to_cpu((ppdu->
 +			dw[offsetof(struct amap_pdu_base, data_len_lo) / 32]
 +			& PDUBASE_DATALENLO_MASK) >> 16)) & 0x0000FFFF));
 +
 +		if (status == 0) {
 +			pasync_ctx->async_entry[cri].wait_queue.bytes_needed =
 +			    bytes_needed;
 +
 +			if (bytes_needed == 0)
 +				status = hwi_fwd_async_msg(beiscsi_conn, phba,
 +							   pasync_ctx, cri);
 +		}
 +	} else {
 +		pasync_ctx->async_data.busy_entries--;
 +		if (pasync_ctx->async_entry[cri].wait_queue.hdr_received) {
 +			list_add_tail(&pasync_handle->link,
 +				      &pasync_ctx->async_entry[cri].wait_queue.
 +				      list);
 +			pasync_ctx->async_entry[cri].wait_queue.
 +				bytes_received +=
 +				(unsigned short)pasync_handle->buffer_len;
 +
 +			if (pasync_ctx->async_entry[cri].wait_queue.
 +			    bytes_received >=
 +			    pasync_ctx->async_entry[cri].wait_queue.
 +			    bytes_needed)
 +				status = hwi_fwd_async_msg(beiscsi_conn, phba,
 +							   pasync_ctx, cri);
 +		}
 +	}
 +	return status;
 +}
 +
 +static void hwi_process_default_pdu_ring(struct beiscsi_conn *beiscsi_conn,
 +					 struct beiscsi_hba *phba,
 +					 struct i_t_dpdu_cqe *pdpdu_cqe)
 +{
 +	struct hwi_controller *phwi_ctrlr;
 +	struct hwi_async_pdu_context *pasync_ctx;
 +	struct async_pdu_handle *pasync_handle = NULL;
 +	unsigned int cq_index = -1;
 +	uint16_t cri_index = BE_GET_CRI_FROM_CID(
 +			     beiscsi_conn->beiscsi_conn_cid);
  
 -	beiscsi_hdl_gather_pdu(beiscsi_conn, pasync_ctx, pasync_handle);
 -	beiscsi_hdq_post_handles(phba, pasync_handle->is_header, ulp_num);
 +	phwi_ctrlr = phba->phwi_ctrlr;
 +	pasync_ctx = HWI_GET_ASYNC_PDU_CTX(phwi_ctrlr,
 +		     BEISCSI_GET_ULP_FROM_CRI(phwi_ctrlr,
 +		     cri_index));
 +
 +	pasync_handle = hwi_get_async_handle(phba, beiscsi_conn, pasync_ctx,
 +					     pdpdu_cqe, &cq_index);
 +
 +	if (pasync_handle->consumed == 0)
 +		hwi_update_async_writables(phba, pasync_ctx,
 +					   pasync_handle->is_header, cq_index);
 +
 +	hwi_gather_async_pdu(beiscsi_conn, phba, pasync_handle);
 +	hwi_post_async_buffers(phba, pasync_handle->is_header,
 +			       BEISCSI_GET_ULP_FROM_CRI(
 +			       phwi_ctrlr, cri_index));
  }
  
  void beiscsi_process_mcc_cq(struct beiscsi_hba *phba)
@@@ -3822,6 -3618,115 +3839,118 @@@ static void find_num_cpus(struct beiscs
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void hwi_purge_eq(struct beiscsi_hba *phba)
+ {
+ 	struct hwi_controller *phwi_ctrlr;
+ 	struct hwi_context_memory *phwi_context;
+ 	struct be_queue_info *eq;
+ 	struct be_eq_entry *eqe = NULL;
+ 	int i, eq_msix;
+ 	unsigned int num_processed;
+ 
+ 	if (beiscsi_hba_in_error(phba))
+ 		return;
+ 
+ 	phwi_ctrlr = phba->phwi_ctrlr;
+ 	phwi_context = phwi_ctrlr->phwi_ctxt;
+ 	if (phba->msix_enabled)
+ 		eq_msix = 1;
+ 	else
+ 		eq_msix = 0;
+ 
+ 	for (i = 0; i < (phba->num_cpus + eq_msix); i++) {
+ 		eq = &phwi_context->be_eq[i].q;
+ 		eqe = queue_tail_node(eq);
+ 		num_processed = 0;
+ 		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+ 					& EQE_VALID_MASK) {
+ 			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
+ 			queue_tail_inc(eq);
+ 			eqe = queue_tail_node(eq);
+ 			num_processed++;
+ 		}
+ 
+ 		if (num_processed)
+ 			hwi_ring_eq_db(phba, eq->id, 1,	num_processed, 1, 1);
+ 	}
+ }
+ 
+ static void hwi_cleanup_port(struct beiscsi_hba *phba)
+ {
+ 	struct be_queue_info *q;
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct hwi_controller *phwi_ctrlr;
+ 	struct hwi_context_memory *phwi_context;
+ 	int i, eq_for_mcc, ulp_num;
+ 
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)
+ 		if (test_bit(ulp_num, &phba->fw_config.ulp_supported))
+ 			beiscsi_cmd_iscsi_cleanup(phba, ulp_num);
+ 
+ 	/**
+ 	 * Purge all EQ entries that may have been left out. This is to
+ 	 * workaround a problem we've seen occasionally where driver gets an
+ 	 * interrupt with EQ entry bit set after stopping the controller.
+ 	 */
+ 	hwi_purge_eq(phba);
+ 
+ 	phwi_ctrlr = phba->phwi_ctrlr;
+ 	phwi_context = phwi_ctrlr->phwi_ctxt;
+ 
+ 	be_cmd_iscsi_remove_template_hdr(ctrl);
+ 
+ 	for (i = 0; i < phba->params.cxns_per_ctrl; i++) {
+ 		q = &phwi_context->be_wrbq[i];
+ 		if (q->created)
+ 			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_WRBQ);
+ 	}
+ 	kfree(phwi_context->be_wrbq);
+ 	free_wrb_handles(phba);
+ 
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
+ 		if (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {
+ 
+ 			q = &phwi_context->be_def_hdrq[ulp_num];
+ 			if (q->created)
+ 				beiscsi_cmd_q_destroy(ctrl, q, QTYPE_DPDUQ);
+ 
+ 			q = &phwi_context->be_def_dataq[ulp_num];
+ 			if (q->created)
+ 				beiscsi_cmd_q_destroy(ctrl, q, QTYPE_DPDUQ);
+ 		}
+ 	}
+ 
+ 	beiscsi_cmd_q_destroy(ctrl, NULL, QTYPE_SGL);
+ 
+ 	for (i = 0; i < (phba->num_cpus); i++) {
+ 		q = &phwi_context->be_cq[i];
+ 		if (q->created) {
+ 			be_queue_free(phba, q);
+ 			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_CQ);
+ 		}
+ 	}
+ 
+ 	be_mcc_queues_destroy(phba);
+ 	if (phba->msix_enabled)
+ 		eq_for_mcc = 1;
+ 	else
+ 		eq_for_mcc = 0;
+ 	for (i = 0; i < (phba->num_cpus + eq_for_mcc); i++) {
+ 		q = &phwi_context->be_eq[i].q;
+ 		if (q->created) {
+ 			be_queue_free(phba, q);
+ 			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_EQ);
+ 		}
+ 	}
+ 	/* this ensures complete FW cleanup */
+ 	beiscsi_cmd_function_reset(phba);
+ 	/* last communication, indicate driver is unloading */
+ 	beiscsi_cmd_special_wrb(&phba->ctrl, 0);
+ }
+ 
++>>>>>>> fa1261c4b683 (scsi: be2iscsi: Remove unused struct members)
  static int hwi_init_port(struct beiscsi_hba *phba)
  {
  	struct hwi_controller *phwi_ctrlr;
diff --cc drivers/scsi/be2iscsi/be_mgmt.c
index 794ed5647611,8acacd5ec796..000000000000
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@@ -1423,8 -831,272 +1421,178 @@@ unsigned int be_cmd_get_initname(struc
  	return tag;
  }
  
 -static void beiscsi_boot_process_compl(struct beiscsi_hba *phba,
 -				       unsigned int tag)
 -{
 -	struct be_cmd_get_boot_target_resp *boot_resp;
 -	struct be_cmd_resp_logout_fw_sess *logo_resp;
 -	struct be_cmd_get_session_resp *sess_resp;
 -	struct be_mcc_wrb *wrb;
 -	struct boot_struct *bs;
 -	int boot_work, status;
 -
 -	if (!test_bit(BEISCSI_HBA_BOOT_WORK, &phba->state)) {
 -		__beiscsi_log(phba, KERN_ERR,
 -			      "BG_%d : %s no boot work %lx\n",
 -			      __func__, phba->state);
 -		return;
 -	}
 -
 -	if (phba->boot_struct.tag != tag) {
 -		__beiscsi_log(phba, KERN_ERR,
 -			      "BG_%d : %s tag mismatch %d:%d\n",
 -			      __func__, tag, phba->boot_struct.tag);
 -		return;
 -	}
 -	bs = &phba->boot_struct;
 -	boot_work = 1;
 -	status = 0;
 -	switch (bs->action) {
 -	case BEISCSI_BOOT_REOPEN_SESS:
 -		status = __beiscsi_mcc_compl_status(phba, tag, NULL, NULL);
 -		if (!status)
 -			bs->action = BEISCSI_BOOT_GET_SHANDLE;
 -		else
 -			bs->retry--;
 -		break;
 -	case BEISCSI_BOOT_GET_SHANDLE:
 -		status = __beiscsi_mcc_compl_status(phba, tag, &wrb, NULL);
 -		if (!status) {
 -			boot_resp = embedded_payload(wrb);
 -			bs->s_handle = boot_resp->boot_session_handle;
 -		}
 -		if (bs->s_handle == BE_BOOT_INVALID_SHANDLE) {
 -			bs->action = BEISCSI_BOOT_REOPEN_SESS;
 -			bs->retry--;
 -		} else {
 -			bs->action = BEISCSI_BOOT_GET_SINFO;
 -		}
 -		break;
 -	case BEISCSI_BOOT_GET_SINFO:
 -		status = __beiscsi_mcc_compl_status(phba, tag, NULL,
 -						    &bs->nonemb_cmd);
 -		if (!status) {
 -			sess_resp = bs->nonemb_cmd.va;
 -			memcpy(&bs->boot_sess, &sess_resp->session_info,
 -			       sizeof(struct mgmt_session_info));
 -			bs->action = BEISCSI_BOOT_LOGOUT_SESS;
 -		} else {
 -			__beiscsi_log(phba, KERN_ERR,
 -				      "BG_%d : get boot session info error : 0x%x\n",
 -				      status);
 -			boot_work = 0;
 -		}
 -		pci_free_consistent(phba->ctrl.pdev, bs->nonemb_cmd.size,
 -				    bs->nonemb_cmd.va, bs->nonemb_cmd.dma);
 -		bs->nonemb_cmd.va = NULL;
 -		break;
 -	case BEISCSI_BOOT_LOGOUT_SESS:
 -		status = __beiscsi_mcc_compl_status(phba, tag, &wrb, NULL);
 -		if (!status) {
 -			logo_resp = embedded_payload(wrb);
 -			if (logo_resp->session_status != BE_SESS_STATUS_CLOSE) {
 -				__beiscsi_log(phba, KERN_ERR,
 -					      "BG_%d : FW boot session logout error : 0x%x\n",
 -					      logo_resp->session_status);
 -			}
 -		}
 -		/* continue to create boot_kset even if logout failed? */
 -		bs->action = BEISCSI_BOOT_CREATE_KSET;
 -		break;
 -	default:
 -		break;
 -	}
 -
 -	/* clear the tag so no other completion matches this tag */
 -	bs->tag = 0;
 -	if (!bs->retry) {
 -		boot_work = 0;
 -		__beiscsi_log(phba, KERN_ERR,
 -			      "BG_%d : failed to setup boot target: status %d action %d\n",
 -			      status, bs->action);
 -	}
 -	if (!boot_work) {
 -		/* wait for next event to start boot_work */
 -		clear_bit(BEISCSI_HBA_BOOT_WORK, &phba->state);
 -		return;
 -	}
 -	schedule_work(&phba->boot_work);
 -}
 -
  /**
++<<<<<<< HEAD
 + * be_mgmt_get_boot_shandle()- Get the session handle
++=======
+  * beiscsi_boot_logout_sess()- Logout from boot FW session
+  * @phba: Device priv structure instance
+  *
+  * return
+  *	the TAG used for MBOX Command
+  *
+  */
+ unsigned int beiscsi_boot_logout_sess(struct beiscsi_hba *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_mcc_wrb *wrb;
+ 	struct be_cmd_req_logout_fw_sess *req;
+ 	unsigned int tag;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = alloc_mcc_wrb(phba, &tag);
+ 	if (!wrb) {
+ 		mutex_unlock(&ctrl->mbox_lock);
+ 		return 0;
+ 	}
+ 
+ 	req = embedded_payload(wrb);
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
+ 			   OPCODE_ISCSI_INI_SESSION_LOGOUT_TARGET,
+ 			   sizeof(struct be_cmd_req_logout_fw_sess));
+ 	/* Use the session handle copied into boot_sess */
+ 	req->session_handle = phba->boot_struct.boot_sess.session_handle;
+ 
+ 	phba->boot_struct.tag = tag;
+ 	set_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);
+ 	ctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;
+ 
+ 	be_mcc_notify(phba, tag);
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 
+ 	return tag;
+ }
+ /**
+  * beiscsi_boot_reopen_sess()- Reopen boot session
+  * @phba: Device priv structure instance
+  *
+  * return
+  *	the TAG used for MBOX Command
+  *
+  **/
+ unsigned int beiscsi_boot_reopen_sess(struct beiscsi_hba *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_mcc_wrb *wrb;
+ 	struct be_cmd_reopen_session_req *req;
+ 	unsigned int tag;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = alloc_mcc_wrb(phba, &tag);
+ 	if (!wrb) {
+ 		mutex_unlock(&ctrl->mbox_lock);
+ 		return 0;
+ 	}
+ 
+ 	req = embedded_payload(wrb);
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
+ 			   OPCODE_ISCSI_INI_DRIVER_REOPEN_ALL_SESSIONS,
+ 			   sizeof(struct be_cmd_reopen_session_resp));
+ 	req->reopen_type = BE_REOPEN_BOOT_SESSIONS;
+ 	req->session_handle = BE_BOOT_INVALID_SHANDLE;
+ 
+ 	phba->boot_struct.tag = tag;
+ 	set_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);
+ 	ctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;
+ 
+ 	be_mcc_notify(phba, tag);
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return tag;
+ }
+ 
+ 
+ /**
+  * beiscsi_boot_get_sinfo()- Get boot session info
+  * @phba: device priv structure instance
+  *
+  * Fetches the boot_struct.s_handle info from FW.
+  * return
+  *	the TAG used for MBOX Command
+  *
+  **/
+ unsigned int beiscsi_boot_get_sinfo(struct beiscsi_hba *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_cmd_get_session_req *req;
+ 	struct be_dma_mem *nonemb_cmd;
+ 	struct be_mcc_wrb *wrb;
+ 	struct be_sge *sge;
+ 	unsigned int tag;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = alloc_mcc_wrb(phba, &tag);
+ 	if (!wrb) {
+ 		mutex_unlock(&ctrl->mbox_lock);
+ 		return 0;
+ 	}
+ 
+ 	nonemb_cmd = &phba->boot_struct.nonemb_cmd;
+ 	nonemb_cmd->size = sizeof(struct be_cmd_get_session_resp);
+ 	nonemb_cmd->va = pci_alloc_consistent(phba->ctrl.pdev,
+ 					      nonemb_cmd->size,
+ 					      &nonemb_cmd->dma);
+ 	if (!nonemb_cmd->va) {
+ 		mutex_unlock(&ctrl->mbox_lock);
+ 		return 0;
+ 	}
+ 
+ 	req = nonemb_cmd->va;
+ 	memset(req, 0, sizeof(*req));
+ 	sge = nonembedded_sgl(wrb);
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
+ 			   OPCODE_ISCSI_INI_SESSION_GET_A_SESSION,
+ 			   sizeof(struct be_cmd_get_session_resp));
+ 	req->session_handle = phba->boot_struct.s_handle;
+ 	sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));
+ 	sge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);
+ 	sge->len = cpu_to_le32(nonemb_cmd->size);
+ 
+ 	phba->boot_struct.tag = tag;
+ 	set_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);
+ 	ctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;
+ 
+ 	be_mcc_notify(phba, tag);
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return tag;
+ }
+ 
+ unsigned int __beiscsi_boot_get_shandle(struct beiscsi_hba *phba, int async)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_mcc_wrb *wrb;
+ 	struct be_cmd_get_boot_target_req *req;
+ 	unsigned int tag;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = alloc_mcc_wrb(phba, &tag);
+ 	if (!wrb) {
+ 		mutex_unlock(&ctrl->mbox_lock);
+ 		return 0;
+ 	}
+ 
+ 	req = embedded_payload(wrb);
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,
+ 			   OPCODE_ISCSI_INI_BOOT_GET_BOOT_TARGET,
+ 			   sizeof(struct be_cmd_get_boot_target_resp));
+ 
+ 	if (async) {
+ 		phba->boot_struct.tag = tag;
+ 		set_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);
+ 		ctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;
+ 	}
+ 
+ 	be_mcc_notify(phba, tag);
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return tag;
+ }
+ 
+ /**
+  * beiscsi_boot_get_shandle()- Get boot session handle
++>>>>>>> fa1261c4b683 (scsi: be2iscsi: Remove unused struct members)
   * @phba: device priv structure instance
   * @s_handle: session handle returned for boot session.
   *
diff --cc drivers/scsi/be2iscsi/be_mgmt.h
index 3ae2c46961a3,308f1472f98a..000000000000
--- a/drivers/scsi/be2iscsi/be_mgmt.h
+++ b/drivers/scsi/be2iscsi/be_mgmt.h
@@@ -36,67 -36,6 +36,70 @@@
  #define PCICFG_UE_STATUS_MASK_LOW       0xA8
  #define PCICFG_UE_STATUS_MASK_HI        0xAC
  
++<<<<<<< HEAD
 +/**
 + * Pseudo amap definition in which each bit of the actual structure is defined
 + * as a byte: used to calculate offset/shift/mask of each field
 + */
 +struct amap_mcc_sge {
 +	u8 pa_lo[32];		/* dword 0 */
 +	u8 pa_hi[32];		/* dword 1 */
 +	u8 length[32];		/* DWORD 2 */
 +} __packed;
 +
 +/**
 + * Pseudo amap definition in which each bit of the actual structure is defined
 + * as a byte: used to calculate offset/shift/mask of each field
 + */
 +struct amap_mcc_wrb_payload {
 +	union {
 +		struct amap_mcc_sge sgl[19];
 +		u8 embedded[59 * 32];	/* DWORDS 57 to 115 */
 +	} u;
 +} __packed;
 +
 +/**
 + * Pseudo amap definition in which each bit of the actual structure is defined
 + * as a byte: used to calculate offset/shift/mask of each field
 + */
 +struct amap_mcc_wrb {
 +	u8 embedded;		/* DWORD 0 */
 +	u8 rsvd0[2];		/* DWORD 0 */
 +	u8 sge_count[5];	/* DWORD 0 */
 +	u8 rsvd1[16];		/* DWORD 0 */
 +	u8 special[8];		/* DWORD 0 */
 +	u8 payload_length[32];
 +	u8 tag[64];		/* DWORD 2 */
 +	u8 rsvd2[32];		/* DWORD 4 */
 +	struct amap_mcc_wrb_payload payload;
 +};
 +
 +struct mcc_sge {
 +	u32 pa_lo;		/* dword 0 */
 +	u32 pa_hi;		/* dword 1 */
 +	u32 length;		/* DWORD 2 */
 +} __packed;
 +
 +struct mcc_wrb_payload {
 +	union {
 +		struct mcc_sge sgl[19];
 +		u32 embedded[59];	/* DWORDS 57 to 115 */
 +	} u;
 +} __packed;
 +
 +#define MCC_WRB_EMBEDDED_MASK                0x00000001
 +
 +struct mcc_wrb {
 +	u32 dw[0];		/* DWORD 0 */
 +	u32 payload_length;
 +	u32 tag[2];		/* DWORD 2 */
 +	u32 rsvd2[1];		/* DWORD 4 */
 +	struct mcc_wrb_payload payload;
 +};
 +
 +int mgmt_epfw_cleanup(struct beiscsi_hba *phba, unsigned short chute);
++=======
++>>>>>>> fa1261c4b683 (scsi: be2iscsi: Remove unused struct members)
  int mgmt_open_connection(struct beiscsi_hba *phba,
  			 struct sockaddr *dst_addr,
  			 struct beiscsi_endpoint *beiscsi_ep,
diff --git a/drivers/scsi/be2iscsi/be.h b/drivers/scsi/be2iscsi/be.h
index b862bc2bb57c..87d8b48ed4f6 100644
--- a/drivers/scsi/be2iscsi/be.h
+++ b/drivers/scsi/be2iscsi/be.h
@@ -84,7 +84,6 @@ static inline void queue_tail_inc(struct be_queue_info *q)
 /*ISCSI */
 
 struct be_aic_obj {		/* Adaptive interrupt coalescing (AIC) info */
-	bool enable;
 	u32 min_eqd;		/* in usecs */
 	u32 max_eqd;		/* in usecs */
 	u32 prev_eqd;		/* in usecs */
@@ -94,8 +93,6 @@ struct be_aic_obj {		/* Adaptive interrupt coalescing (AIC) info */
 };
 
 struct be_eq_obj {
-	bool todo_mcc_cq;
-	bool todo_cq;
 	u32 cq_count;
 	struct be_queue_info q;
 	struct beiscsi_hba *phba;
* Unmerged path drivers/scsi/be2iscsi/be_cmds.c
diff --git a/drivers/scsi/be2iscsi/be_cmds.h b/drivers/scsi/be2iscsi/be_cmds.h
index 913b37a8858b..778509e58fec 100644
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@ -31,10 +31,16 @@ struct be_sge {
 	__le32 len;
 };
 
-#define MCC_WRB_SGE_CNT_SHIFT 3	/* bits 3 - 7 of dword 0 */
-#define MCC_WRB_SGE_CNT_MASK 0x1F	/* bits 3 - 7 of dword 0 */
 struct be_mcc_wrb {
-	u32 embedded;		/* dword 0 */
+	u32 emb_sgecnt_special;	/* dword 0 */
+	/* bits 0 - embedded    */
+	/* bits 1 - 2 reserved	*/
+	/* bits 3 - 7 sge count	*/
+	/* bits 8 - 23 reserved	*/
+	/* bits 24 - 31 special	*/
+#define MCC_WRB_EMBEDDED_MASK 1
+#define MCC_WRB_SGE_CNT_SHIFT 3
+#define MCC_WRB_SGE_CNT_MASK 0x1F
 	u32 payload_length;	/* dword 1 */
 	u32 tag0;		/* dword 2 */
 	u32 tag1;		/* dword 3 */
@@ -1064,11 +1070,6 @@ struct tcp_connect_and_offload_out {
 
 } __packed;
 
-struct be_mcc_wrb_context {
-	struct MCC_WRB *wrb;
-	int *users_final_status;
-} __packed;
-
 #define DB_DEF_PDU_RING_ID_MASK	0x3FFF	/* bits 0 - 13 */
 #define DB_DEF_PDU_CQPROC_MASK		0x3FFF	/* bits 16 - 29 */
 #define DB_DEF_PDU_REARM_SHIFT		14
diff --git a/drivers/scsi/be2iscsi/be_iscsi.c b/drivers/scsi/be2iscsi/be_iscsi.c
index 27d616992099..26103daa1509 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -1111,7 +1111,7 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 	nonemb_cmd.size = req_memsize;
 	memset(nonemb_cmd.va, 0, nonemb_cmd.size);
 	tag = mgmt_open_connection(phba, dst_addr, beiscsi_ep, &nonemb_cmd);
-	if (tag <= 0) {
+	if (!tag) {
 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 			    "BS_%d : mgmt_open_connection Failed for cid=%d\n",
 			    beiscsi_ep->ep_cid);
* Unmerged path drivers/scsi/be2iscsi/be_main.c
diff --git a/drivers/scsi/be2iscsi/be_main.h b/drivers/scsi/be2iscsi/be_main.h
index 9df49b3c0177..49b128159ce0 100644
--- a/drivers/scsi/be2iscsi/be_main.h
+++ b/drivers/scsi/be2iscsi/be_main.h
@@ -263,19 +263,7 @@ struct hba_parameters {
 	unsigned int num_cq_entries;
 	unsigned int num_eq_entries;
 	unsigned int wrbs_per_cxn;
-	unsigned int crashmode;
-	unsigned int hba_num;
-
-	unsigned int mgmt_ws_sz;
 	unsigned int hwi_ws_sz;
-
-	unsigned int eto;
-	unsigned int ldto;
-
-	unsigned int dbg_flags;
-	unsigned int num_cxn;
-
-	unsigned int eq_timer;
 	/**
 	 * These are calculated from other params. They're here
 	 * for debug purposes
@@ -358,7 +346,6 @@ struct beiscsi_hba {
 	struct be_bus_address pci_pa;	/* CSR */
 	/* PCI representation of our HBA */
 	struct pci_dev *pcidev;
-	unsigned short asic_revision;
 	unsigned int num_cpus;
 	unsigned int nxt_cqid;
 	struct msix_entry msix_entries[MAX_CPUS];
@@ -379,7 +366,6 @@ struct beiscsi_hba {
 	spinlock_t io_sgl_lock;
 	spinlock_t mgmt_sgl_lock;
 	spinlock_t async_pdu_lock;
-	unsigned int age;
 	struct list_head hba_queue;
 #define BE_MAX_SESSION 2048
 #define BE_SET_CID_TO_CRI(cri_index, cid) \
@@ -508,10 +494,6 @@ struct beiscsi_io_task {
 	struct beiscsi_conn *conn;
 	struct scsi_cmnd *scsi_cmnd;
 	struct hwi_wrb_context *pwrb_context;
-	unsigned int cmd_sn;
-	unsigned int flags;
-	unsigned short cid;
-	unsigned short header_len;
 	itt_t libiscsi_itt;
 	struct be_cmd_bhs *cmd_bhs;
 	struct be_bus_address bhs_pa;
@@ -1029,10 +1011,8 @@ struct hwi_controller {
 	struct list_head io_sgl_list;
 	struct list_head eh_sgl_list;
 	struct sgl_handle *psgl_handle_base;
-	unsigned int wrb_mem_index;
 
 	struct hwi_wrb_context *wrb_context;
-	struct mcc_wrb *pmcc_wrb_base;
 	struct be_ring default_pdu_hdr[BEISCSI_ULP_COUNT];
 	struct be_ring default_pdu_data[BEISCSI_ULP_COUNT];
 	struct hwi_context_memory *phwi_ctxt;
@@ -1049,9 +1029,7 @@ enum hwh_type_enum {
 };
 
 struct wrb_handle {
-	enum hwh_type_enum type;
 	unsigned short wrb_index;
-
 	struct iscsi_task *pio_handle;
 	struct iscsi_wrb *pwrb;
 };
* Unmerged path drivers/scsi/be2iscsi/be_mgmt.c
* Unmerged path drivers/scsi/be2iscsi/be_mgmt.h
