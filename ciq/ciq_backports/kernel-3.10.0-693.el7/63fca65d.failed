net: add confirm_neigh method to dst_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] add confirm_neigh method to dst_ops (Lance Richardson) [1450203]
Rebuild_FUZZ: 93.33%
commit-author Julian Anastasov <ja@ssi.bg>
commit 63fca65d08632fbec9d9b655f671cf08aa1aeeb8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/63fca65d.failed

Add confirm_neigh method to dst_ops and use it from IPv4 and IPv6
to lookup and confirm the neighbour. Its usage via the new helper
dst_confirm_neigh() should be restricted to MSG_PROBE users for
performance reasons.

For XFRM prefer the last tunnel address, if present. With help
from Steffen Klassert.

	Signed-off-by: Julian Anastasov <ja@ssi.bg>
	Acked-by: Steffen Klassert <steffen.klassert@secunet.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 63fca65d08632fbec9d9b655f671cf08aa1aeeb8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ndisc.h
diff --cc include/net/ndisc.h
index 4a7a80f7a6d2,8a0214654b6b..000000000000
--- a/include/net/ndisc.h
+++ b/include/net/ndisc.h
@@@ -200,35 -391,49 +200,57 @@@ static inline struct neighbour *__ipv6_
  	return n;
  }
  
++<<<<<<< HEAD
 +extern int			ndisc_init(void);
 +extern int			ndisc_late_init(void);
++=======
+ static inline void __ipv6_confirm_neigh(struct net_device *dev,
+ 					const void *pkey)
+ {
+ 	struct neighbour *n;
+ 
+ 	rcu_read_lock_bh();
+ 	n = __ipv6_neigh_lookup_noref(dev, pkey);
+ 	if (n) {
+ 		unsigned long now = jiffies;
+ 
+ 		/* avoid dirtying neighbour */
+ 		if (n->confirmed != now)
+ 			n->confirmed = now;
+ 	}
+ 	rcu_read_unlock_bh();
+ }
+ 
+ int ndisc_init(void);
+ int ndisc_late_init(void);
++>>>>>>> 63fca65d0863 (net: add confirm_neigh method to dst_ops)
  
 -void ndisc_late_cleanup(void);
 -void ndisc_cleanup(void);
 +extern void			ndisc_late_cleanup(void);
 +extern void			ndisc_cleanup(void);
  
 -int ndisc_rcv(struct sk_buff *skb);
 +extern int			ndisc_rcv(struct sk_buff *skb);
  
 -void ndisc_send_ns(struct net_device *dev, const struct in6_addr *solicit,
 -		   const struct in6_addr *daddr, const struct in6_addr *saddr,
 -		   u64 nonce);
 +extern void			ndisc_send_ns(struct net_device *dev,
 +					      struct neighbour *neigh,
 +					      const struct in6_addr *solicit,
 +					      const struct in6_addr *daddr,
 +					      const struct in6_addr *saddr);
  
 -void ndisc_send_rs(struct net_device *dev,
 -		   const struct in6_addr *saddr, const struct in6_addr *daddr);
 -void ndisc_send_na(struct net_device *dev, const struct in6_addr *daddr,
 -		   const struct in6_addr *solicited_addr,
 -		   bool router, bool solicited, bool override, bool inc_opt);
 +extern void			ndisc_send_rs(struct net_device *dev,
 +					      const struct in6_addr *saddr,
 +					      const struct in6_addr *daddr);
 +extern void			ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
 +					      const struct in6_addr *daddr,
 +					      const struct in6_addr *solicited_addr,
 +					      bool router, bool solicited, bool override,
 +					      bool inc_opt);
  
 -void ndisc_send_redirect(struct sk_buff *skb, const struct in6_addr *target);
 +extern void			ndisc_send_redirect(struct sk_buff *skb,
 +						    const struct in6_addr *target);
  
 -int ndisc_mc_map(const struct in6_addr *addr, char *buf, struct net_device *dev,
 -		 int dir);
 +extern int			ndisc_mc_map(const struct in6_addr *addr, char *buf,
 +					     struct net_device *dev, int dir);
  
 -void ndisc_update(const struct net_device *dev, struct neighbour *neigh,
 -		  const u8 *lladdr, u8 new, u32 flags, u8 icmp6_type,
 -		  struct ndisc_options *ndopts);
  
  /*
   *	IGMP
diff --git a/include/net/arp.h b/include/net/arp.h
index 7509d9da4e36..4b2bb217e1ee 100644
--- a/include/net/arp.h
+++ b/include/net/arp.h
@@ -46,6 +46,22 @@ static inline struct neighbour *__ipv4_neigh_lookup(struct net_device *dev, u32
 	return n;
 }
 
+static inline void __ipv4_confirm_neigh(struct net_device *dev, u32 key)
+{
+	struct neighbour *n;
+
+	rcu_read_lock_bh();
+	n = __ipv4_neigh_lookup_noref(dev, key);
+	if (n) {
+		unsigned long now = jiffies;
+
+		/* avoid dirtying neighbour */
+		if (n->confirmed != now)
+			n->confirmed = now;
+	}
+	rcu_read_unlock_bh();
+}
+
 void arp_init(void);
 int arp_find(unsigned char *haddr, struct sk_buff *skb);
 int arp_ioctl(struct net *net, unsigned int cmd, void __user *arg);
diff --git a/include/net/dst.h b/include/net/dst.h
index 43e4374a67e5..3ffcd26aa521 100644
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@ -496,6 +496,13 @@ static inline struct neighbour *dst_neigh_lookup_skb(const struct dst_entry *dst
 	return IS_ERR(n) ? NULL : n;
 }
 
+static inline void dst_confirm_neigh(const struct dst_entry *dst,
+				     const void *daddr)
+{
+	if (dst->ops->confirm_neigh)
+		dst->ops->confirm_neigh(dst, daddr);
+}
+
 static inline void dst_link_failure(struct sk_buff *skb)
 {
 	struct dst_entry *dst = skb_dst(skb);
diff --git a/include/net/dst_ops.h b/include/net/dst_ops.h
index 1f99a1de0e4f..14ca53ca7340 100644
--- a/include/net/dst_ops.h
+++ b/include/net/dst_ops.h
@@ -33,6 +33,8 @@ struct dst_ops {
 	struct neighbour *	(*neigh_lookup)(const struct dst_entry *dst,
 						struct sk_buff *skb,
 						const void *daddr);
+	void			(*confirm_neigh)(const struct dst_entry *dst,
+						 const void *daddr);
 
 	struct kmem_cache	*kmem_cachep;
 
* Unmerged path include/net/ndisc.h
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index ffc6c5143efc..e24883d2a080 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -158,6 +158,7 @@ static u32 *ipv4_cow_metrics(struct dst_entry *dst, unsigned long old)
 static struct neighbour *ipv4_neigh_lookup(const struct dst_entry *dst,
 					   struct sk_buff *skb,
 					   const void *daddr);
+static void ipv4_confirm_neigh(const struct dst_entry *dst, const void *daddr);
 
 static struct dst_ops ipv4_dst_ops = {
 	.family =		AF_INET,
@@ -174,6 +175,7 @@ static struct dst_ops ipv4_dst_ops = {
 	.redirect =		ip_do_redirect,
 	.local_out =		__ip_local_out,
 	.neigh_lookup =		ipv4_neigh_lookup,
+	.confirm_neigh =	ipv4_confirm_neigh,
 };
 
 #define ECN_OR_COST(class)	TC_PRIO_##class
@@ -467,6 +469,23 @@ static struct neighbour *ipv4_neigh_lookup(const struct dst_entry *dst,
 	return neigh_create(&arp_tbl, pkey, dev);
 }
 
+static void ipv4_confirm_neigh(const struct dst_entry *dst, const void *daddr)
+{
+	struct net_device *dev = dst->dev;
+	const __be32 *pkey = daddr;
+	const struct rtable *rt;
+
+	rt = (const struct rtable *)dst;
+	if (rt->rt_gateway)
+		pkey = (const __be32 *)&rt->rt_gateway;
+	else if (!daddr ||
+		 (rt->rt_flags &
+		  (RTCF_MULTICAST | RTCF_BROADCAST | RTCF_LOCAL)))
+		return;
+
+	__ipv4_confirm_neigh(dev, *(__force u32 *)pkey);
+}
+
 #define IP_IDENTS_SZ 2048u
 struct ip_ident_bucket {
 	atomic_t	id;
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 5667b499b29e..e68ebfd9a76f 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -215,6 +215,21 @@ static struct neighbour *ip6_neigh_lookup(const struct dst_entry *dst,
 	return neigh_create(&nd_tbl, daddr, dst->dev);
 }
 
+static void ip6_confirm_neigh(const struct dst_entry *dst, const void *daddr)
+{
+	struct net_device *dev = dst->dev;
+	struct rt6_info *rt = (struct rt6_info *)dst;
+
+	daddr = choose_neigh_daddr(rt, NULL, daddr);
+	if (!daddr)
+		return;
+	if (dev->flags & (IFF_NOARP | IFF_LOOPBACK))
+		return;
+	if (ipv6_addr_is_multicast((const struct in6_addr *)daddr))
+		return;
+	__ipv6_confirm_neigh(dev, daddr);
+}
+
 static struct dst_ops ip6_dst_ops_template = {
 	.family			=	AF_INET6,
 	.protocol		=	cpu_to_be16(ETH_P_IPV6),
@@ -232,6 +247,7 @@ static struct dst_ops ip6_dst_ops_template = {
 	.redirect		=	rt6_do_redirect,
 	.local_out		=	__ip6_local_out,
 	.neigh_lookup		=	ip6_neigh_lookup,
+	.confirm_neigh		=	ip6_confirm_neigh,
 };
 
 static unsigned int ip6_blackhole_mtu(const struct dst_entry *dst)
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index a5c3c9b30fff..dc83027cafc9 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -2796,6 +2796,23 @@ static struct neighbour *xfrm_neigh_lookup(const struct dst_entry *dst,
 	return dst->path->ops->neigh_lookup(dst, skb, daddr);
 }
 
+static void xfrm_confirm_neigh(const struct dst_entry *dst, const void *daddr)
+{
+	const struct dst_entry *path = dst->path;
+
+	for (; dst != path; dst = dst->child) {
+		const struct xfrm_state *xfrm = dst->xfrm;
+
+		if (xfrm->props.mode == XFRM_MODE_TRANSPORT)
+			continue;
+		if (xfrm->type->flags & XFRM_TYPE_REMOTE_COADDR)
+			daddr = xfrm->coaddr;
+		else if (!(xfrm->type->flags & XFRM_TYPE_LOCAL_COADDR))
+			daddr = &xfrm->id.daddr;
+	}
+	path->ops->confirm_neigh(path, daddr);
+}
+
 int xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo)
 {
 	int err = 0;
@@ -2822,6 +2839,8 @@ int xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo)
 			dst_ops->link_failure = xfrm_link_failure;
 		if (likely(dst_ops->neigh_lookup == NULL))
 			dst_ops->neigh_lookup = xfrm_neigh_lookup;
+		if (likely(!dst_ops->confirm_neigh))
+			dst_ops->confirm_neigh = xfrm_confirm_neigh;
 		if (likely(afinfo->garbage_collect == NULL))
 			afinfo->garbage_collect = xfrm_garbage_collect_deferred;
 		rcu_assign_pointer(xfrm_policy_afinfo[afinfo->family], afinfo);
