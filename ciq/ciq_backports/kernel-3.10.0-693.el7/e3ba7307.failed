fsnotify: Remove fsnotify_duplicate_mark()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.cz>
commit e3ba730702af370563f66cb610b71aa0ca67955e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e3ba7307.failed

There are only two calls sites of fsnotify_duplicate_mark(). Those are
in kernel/audit_tree.c and both are bogus. Vfsmount pointer is unused
for audit tree, inode pointer and group gets set in
fsnotify_add_mark_locked() later anyway, mask and free_mark are already
set in alloc_chunk(). In fact, calling fsnotify_duplicate_mark() is
actively harmful because following fsnotify_add_mark_locked() will leak
group reference by overwriting the group pointer. So just remove the two
calls to fsnotify_duplicate_mark() and the function.

	Signed-off-by: Jan Kara <jack@suse.cz>
[PM: line wrapping to fit in 80 chars]
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit e3ba730702af370563f66cb610b71aa0ca67955e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/mark.c
#	kernel/audit_tree.c
diff --cc fs/notify/mark.c
index b46c40e4c8a2,6043306e8e21..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -362,25 -485,31 +362,28 @@@ void fsnotify_clear_marks_by_group_flag
  }
  
  /*
 - * Given a group, prepare for freeing all the marks associated with that group.
 - * The marks are attached to the list of marks prepared for destruction, the
 - * caller is responsible for freeing marks in that list after SRCU period has
 - * ended.
 + * Given a group, destroy all of the marks associated with that group.
   */
 -void fsnotify_detach_group_marks(struct fsnotify_group *group)
 +void fsnotify_clear_marks_by_group(struct fsnotify_group *group)
  {
 -	struct fsnotify_mark *mark;
 +	fsnotify_clear_marks_by_group_flags(group, (unsigned int)-1);
 +}
  
 -	while (1) {
 -		mutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);
 -		if (list_empty(&group->marks_list)) {
 -			mutex_unlock(&group->mark_mutex);
 -			break;
 -		}
 -		mark = list_first_entry(&group->marks_list,
 -					struct fsnotify_mark, g_list);
 -		fsnotify_get_mark(mark);
 -		fsnotify_detach_mark(mark);
 -		mutex_unlock(&group->mark_mutex);
 -		__fsnotify_free_mark(mark);
 -		fsnotify_put_mark(mark);
 -	}
++<<<<<<< HEAD
 +void fsnotify_duplicate_mark(struct fsnotify_mark *new, struct fsnotify_mark *old)
 +{
 +	assert_spin_locked(&old->lock);
 +	new->i.inode = old->i.inode;
 +	new->m.mnt = old->m.mnt;
 +	if (old->group)
 +		fsnotify_get_group(old->group);
 +	new->group = old->group;
 +	new->mask = old->mask;
 +	new->free_mark = old->free_mark;
  }
  
++=======
++>>>>>>> e3ba730702af (fsnotify: Remove fsnotify_duplicate_mark())
  /*
   * Nothing fancy, just initialize lists and locks and counters.
   */
diff --cc kernel/audit_tree.c
index 7219796b590d,b4b58400531f..000000000000
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@@ -257,8 -258,8 +257,13 @@@ static void untag_chunk(struct node *p
  	if (!new)
  		goto Fallback;
  
++<<<<<<< HEAD
 +	fsnotify_duplicate_mark(&new->mark, entry);
 +	if (fsnotify_add_mark(&new->mark, new->mark.group, new->mark.i.inode, NULL, 1)) {
++=======
+ 	if (fsnotify_add_mark(&new->mark,
+ 			      entry->group, entry->inode, NULL, 1)) {
++>>>>>>> e3ba730702af (fsnotify: Remove fsnotify_duplicate_mark())
  		fsnotify_put_mark(&new->mark);
  		goto Fallback;
  	}
@@@ -394,8 -395,8 +399,13 @@@ static int tag_chunk(struct inode *inod
  		return -ENOENT;
  	}
  
++<<<<<<< HEAD
 +	fsnotify_duplicate_mark(chunk_entry, old_entry);
 +	if (fsnotify_add_mark(chunk_entry, chunk_entry->group, chunk_entry->i.inode, NULL, 1)) {
++=======
+ 	if (fsnotify_add_mark(chunk_entry,
+ 			      old_entry->group, old_entry->inode, NULL, 1)) {
++>>>>>>> e3ba730702af (fsnotify: Remove fsnotify_duplicate_mark())
  		spin_unlock(&old_entry->lock);
  		fsnotify_put_mark(chunk_entry);
  		fsnotify_put_mark(old_entry);
* Unmerged path fs/notify/mark.c
diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h
index 989de86d62bf..283146028d00 100644
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@ -344,8 +344,6 @@ extern void fsnotify_init_mark(struct fsnotify_mark *mark, void (*free_mark)(str
 extern struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group, struct inode *inode);
 /* find (and take a reference) to a mark associated with group and vfsmount */
 extern struct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group, struct vfsmount *mnt);
-/* copy the values from old into new */
-extern void fsnotify_duplicate_mark(struct fsnotify_mark *new, struct fsnotify_mark *old);
 /* set the ignored_mask of a mark */
 extern void fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask);
 /* set the mask of a mark (might pin the object into memory */
* Unmerged path kernel/audit_tree.c
