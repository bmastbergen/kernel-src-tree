vfio/pci: return -EFAULT if copy_to_user fails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [vfio] pci: return -EFAULT if copy_to_user fails (Tarun Gupta) [1116064]
Rebuild_FUZZ: 94.25%
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit c4aec3101319f84363a57e09086c2aff6c60a3c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c4aec310.failed

The copy_to_user() function returns the number of bytes that were not
copied but we want to return -EFAULT on error here.

Fixes: 188ad9d6cbbc ('vfio/pci: Include sparse mmap capability for MSI-X table regions')
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit c4aec3101319f84363a57e09086c2aff6c60a3c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/pci/vfio_pci.c
diff --cc drivers/vfio/pci/vfio_pci.c
index 2a0043c78806,98059df9cff6..000000000000
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@@ -543,11 -640,43 +543,34 @@@ static long vfio_pci_ioctl(void *device
  
  			break;
  		default:
 -			if (info.index >=
 -			    VFIO_PCI_NUM_REGIONS + vdev->num_regions)
 -				return -EINVAL;
 -
 -			i = info.index - VFIO_PCI_NUM_REGIONS;
 -
 -			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
 -			info.size = vdev->region[i].size;
 -			info.flags = vdev->region[i].flags;
 -
 -			ret = region_type_cap(vdev, &caps,
 -					      vdev->region[i].type,
 -					      vdev->region[i].subtype);
 -			if (ret)
 -				return ret;
 +			return -EINVAL;
  		}
  
++<<<<<<< HEAD
 +		return copy_to_user((void __user *)arg, &info, minsz) ?
 +			-EFAULT : 0;
++=======
+ 		if (caps.size) {
+ 			info.flags |= VFIO_REGION_INFO_FLAG_CAPS;
+ 			if (info.argsz < sizeof(info) + caps.size) {
+ 				info.argsz = sizeof(info) + caps.size;
+ 				info.cap_offset = 0;
+ 			} else {
+ 				vfio_info_cap_shift(&caps, sizeof(info));
+ 				if (copy_to_user((void __user *)arg +
+ 						  sizeof(info), caps.buf,
+ 						  caps.size)) {
+ 					kfree(caps.buf);
+ 					return -EFAULT;
+ 				}
+ 				info.cap_offset = sizeof(info);
+ 			}
+ 
+ 			kfree(caps.buf);
+ 		}
+ 
+ 		return copy_to_user((void __user *)arg, &info, minsz);
++>>>>>>> c4aec3101319 (vfio/pci: return -EFAULT if copy_to_user fails)
  
  	} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {
  		struct vfio_irq_info info;
* Unmerged path drivers/vfio/pci/vfio_pci.c
