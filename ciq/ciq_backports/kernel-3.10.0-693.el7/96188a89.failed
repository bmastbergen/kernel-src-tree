scsi: megaraid_sas: NVME interface target prop added

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: NVME interface target prop added (Tomas Henzl) [1417038]
Rebuild_FUZZ: 93.88%
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit 96188a89cc6d5ad3a0a5b7a6c4abc9f4a6de7678
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/96188a89.failed

This patch fetch true values of NVME property from FW using New DCMD
interface MR_DCMD_DEV_GET_TARGET_PROP

	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Signed-off-by: Kashyap Desai <kashyap.desai@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 96188a89cc6d5ad3a0a5b7a6c4abc9f4a6de7678)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index 1d06c777c981,51b35a619d99..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -116,8 -116,10 +116,15 @@@ static int megasas_ld_list_query(struc
  static int megasas_issue_init_mfi(struct megasas_instance *instance);
  static int megasas_register_aen(struct megasas_instance *instance,
  				u32 seq_num, u32 class_locale_word);
++<<<<<<< HEAD
 +static int
 +megasas_get_pd_info(struct megasas_instance *instance, u16 device_id);
++=======
+ static void megasas_get_pd_info(struct megasas_instance *instance,
+ 				struct scsi_device *sdev);
+ static int megasas_get_target_prop(struct megasas_instance *instance,
+ 				   struct scsi_device *sdev);
++>>>>>>> 96188a89cc6d (scsi: megaraid_sas: NVME interface target prop added)
  /*
   * PCI ID table for all supported controllers
   */
@@@ -1787,45 -1793,102 +1794,104 @@@ void megasas_update_sdev_properties(str
  	}
  }
  
 -/*
 - * megasas_set_nvme_device_properties -
 - * set nomerges=2
 - * set virtual page boundary = 4K (current mr_nvme_pg_size is 4K).
 - * set maximum io transfer = MDTS of NVME device provided by MR firmware.
 - *
 - * MR firmware provides value in KB. Caller of this function converts
 - * kb into bytes.
 - *
 - * e.a MDTS=5 means 2^5 * nvme page size. (In case of 4K page size,
 - * MR firmware provides value 128 as (32 * 4K) = 128K.
 - *
 - * @sdev:				scsi device
 - * @max_io_size:				maximum io transfer size
 - *
 - */
 -static inline void
 -megasas_set_nvme_device_properties(struct scsi_device *sdev, u32 max_io_size)
 +static void megasas_set_device_queue_depth(struct scsi_device *sdev)
  {
 +	u16				pd_index = 0;
 +	int		ret = DCMD_FAILED;
  	struct megasas_instance *instance;
++<<<<<<< HEAD
++=======
+ 	u32 mr_nvme_pg_size;
+ 
+ 	instance = (struct megasas_instance *)sdev->host->hostdata;
+ 	mr_nvme_pg_size = max_t(u32, instance->nvme_page_size,
+ 				MR_DEFAULT_NVME_PAGE_SIZE);
+ 
+ 	blk_queue_max_hw_sectors(sdev->request_queue, (max_io_size / 512));
+ 
+ 	queue_flag_set_unlocked(QUEUE_FLAG_NOMERGES, sdev->request_queue);
+ 	blk_queue_virt_boundary(sdev->request_queue, mr_nvme_pg_size - 1);
+ }
+ 
+ 
+ /*
+  * megasas_set_static_target_properties -
+  * Device property set by driver are static and it is not required to be
+  * updated after OCR.
+  *
+  * set io timeout
+  * set device queue depth
+  * set nvme device properties. see - megasas_set_nvme_device_properties
+  *
+  * @sdev:				scsi device
+  * @is_target_prop			true, if fw provided target properties.
+  */
+ static void megasas_set_static_target_properties(struct scsi_device *sdev,
+ 						 bool is_target_prop)
+ {
+ 	u16	target_index = 0;
+ 	u8 interface_type;
+ 	u32 device_qd = MEGASAS_DEFAULT_CMD_PER_LUN;
+ 	u32 max_io_size_kb = MR_DEFAULT_NVME_MDTS_KB;
+ 	u32 tgt_device_qd;
+ 	struct megasas_instance *instance;
+ 	struct MR_PRIV_DEVICE *mr_device_priv_data;
++>>>>>>> 96188a89cc6d (scsi: megaraid_sas: NVME interface target prop added)
  
  	instance = megasas_lookup_instance(sdev->host->host_no);
 -	mr_device_priv_data = sdev->hostdata;
 -	interface_type  = mr_device_priv_data->interface_type;
  
 -	/*
 -	 * The RAID firmware may require extended timeouts.
 -	 */
 -	blk_queue_rq_timeout(sdev->request_queue, scmd_timeout * HZ);
 +	if (sdev->channel < MEGASAS_MAX_PD_CHANNELS) {
 +		pd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;
  
 -	target_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;
 +		if (instance->pd_info) {
 +			mutex_lock(&instance->hba_mutex);
 +			ret = megasas_get_pd_info(instance, pd_index);
 +			mutex_unlock(&instance->hba_mutex);
 +		}
  
 -	switch (interface_type) {
 -	case SAS_PD:
 -		device_qd = MEGASAS_SAS_QD;
 -		break;
 -	case SATA_PD:
 -		device_qd = MEGASAS_SATA_QD;
 -		break;
 -	case NVME_PD:
 -		device_qd = MEGASAS_NVME_QD;
 -		break;
 +		if (ret != DCMD_SUCCESS)
 +			return;
 +
 +		if (instance->pd_list[pd_index].driveState == MR_PD_STATE_SYSTEM) {
 +
 +			switch (instance->pd_list[pd_index].interface) {
 +			case SAS_PD:
 +				scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev),
 +					MEGASAS_SAS_QD);
 +				break;
 +
 +			case SATA_PD:
 +				scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev),
 +					MEGASAS_SATA_QD);
 +				break;
 +
 +			default:
 +				scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev),
 +					MEGASAS_DEFAULT_PD_QD);
 +			}
 +		}
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (is_target_prop) {
+ 		tgt_device_qd = le32_to_cpu(instance->tgt_prop->device_qdepth);
+ 		if (tgt_device_qd &&
+ 		    (tgt_device_qd <= instance->host->can_queue))
+ 			device_qd = tgt_device_qd;
+ 
+ 		/* max_io_size_kb will be set to non zero for
+ 		 * nvme based vd and syspd.
+ 		 */
+ 		max_io_size_kb = le32_to_cpu(instance->tgt_prop->max_io_size_kb);
+ 	}
+ 
+ 	if (instance->nvme_page_size && max_io_size_kb)
+ 		megasas_set_nvme_device_properties(sdev, (max_io_size_kb << 10));
+ 
+ 	scsi_change_queue_depth(sdev, device_qd);
+ 
++>>>>>>> 96188a89cc6d (scsi: megaraid_sas: NVME interface target prop added)
  }
  
  
@@@ -1844,14 -1909,25 +1912,35 @@@ static int megasas_slave_configure(stru
  				return -ENXIO;
  		}
  	}
 +	megasas_set_device_queue_depth(sdev);
 +	megasas_update_sdev_properties(sdev);
  
++<<<<<<< HEAD
 +	/*
 +	 * The RAID firmware may require extended timeouts.
 +	 */
 +	blk_queue_rq_timeout(sdev->request_queue,
 +		scmd_timeout * HZ);
++=======
+ 	mutex_lock(&instance->hba_mutex);
+ 	/* Send DCMD to Firmware and cache the information */
+ 	if ((instance->pd_info) && !MEGASAS_IS_LOGICAL(sdev))
+ 		megasas_get_pd_info(instance, sdev);
+ 
+ 	/* Some ventura firmware may not have instance->nvme_page_size set.
+ 	 * Do not send MR_DCMD_DRV_GET_TARGET_PROP
+ 	 */
+ 	if ((instance->tgt_prop) && (instance->nvme_page_size))
+ 		ret_target_prop = megasas_get_target_prop(instance, sdev);
+ 
+ 	is_target_prop = (ret_target_prop == DCMD_SUCCESS) ? true : false;
+ 	megasas_set_static_target_properties(sdev, is_target_prop);
+ 
+ 	mutex_unlock(&instance->hba_mutex);
+ 
+ 	/* This sdev property may change post OCR */
+ 	megasas_set_dynamic_target_properties(sdev);
++>>>>>>> 96188a89cc6d (scsi: megaraid_sas: NVME interface target prop added)
  
  	return 0;
  }
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index 724240214af5..28c8b03ab6a2 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -695,6 +695,18 @@ struct  MR_PD_INFO {
 	u8 reserved1[512-428];
 } __packed;
 
+/*
+ * Definition of structure used to expose attributes of VD or JBOD
+ * (this structure is to be filled by firmware when MR_DCMD_DRV_GET_TARGET_PROP
+ * is fired by driver)
+ */
+struct MR_TARGET_PROPERTIES {
+	u32    max_io_size_kb;
+	u32    device_qdepth;
+	u32    sector_size;
+	u8     reserved[500];
+} __packed;
+
  /*
  * defines the physical drive address structure
  */
@@ -2027,6 +2039,8 @@ struct megasas_instance {
 	dma_addr_t hb_host_mem_h;
 	struct MR_PD_INFO *pd_info;
 	dma_addr_t pd_info_h;
+	struct MR_TARGET_PROPERTIES *tgt_prop;
+	dma_addr_t tgt_prop_h;
 
 	__le32 *reply_queue;
 	dma_addr_t reply_queue_h;
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.h b/drivers/scsi/megaraid/megaraid_sas_fusion.h
index ef6bfe55344c..627f90cd5f26 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.h
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.h
@@ -683,6 +683,7 @@ struct MPI2_IOC_INIT_REQUEST {
 #define MAX_RAIDMAP_PHYSICAL_DEVICES (MAX_PHYSICAL_DEVICES)
 #define MR_DCMD_LD_MAP_GET_INFO             0x0300e101
 #define MR_DCMD_SYSTEM_PD_MAP_GET_INFO      0x0200e102
+#define MR_DCMD_DRV_GET_TARGET_PROP         0x0200e103
 #define MR_DCMD_CTRL_SHARED_HOST_MEM_ALLOC  0x010e8485   /* SR-IOV HB alloc*/
 #define MR_DCMD_LD_VF_MAP_GET_ALL_LDS_111   0x03200200
 #define MR_DCMD_LD_VF_MAP_GET_ALL_LDS       0x03150200
