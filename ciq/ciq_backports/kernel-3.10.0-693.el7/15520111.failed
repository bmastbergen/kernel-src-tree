mmc: core: Further fix thread wake-up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] core: Further fix thread wake-up (Don Zickus) [1430497]
Rebuild_FUZZ: 92.75%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 15520111500c33a012aeec28ece8c5f2dcbf6b5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/15520111.failed

Commit e0097cf5f2f1 ("mmc: queue: Fix queue thread wake-up") did not go far
enough. mmc_wait_for_data_req_done() still contains some problems and can
be further simplified.  First it should not touch
context_info->is_waiting_last_req because that is a wake-up control used by
the owner of the context. Secondly, it should always return when one of its
wake-up conditions is met because, again, that is contolled by the owner of
the context.

While the current block driver does not have an issue, these problems were
exposed during testing of the Software Command Queue patches.

Fixes: e0097cf5f2f1 ("mmc: queue: Fix queue thread wake-up")
	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Tested-by: Harjani Ritesh <riteshh@codeaurora.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 15520111500c33a012aeec28ece8c5f2dcbf6b5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/core.c
diff --cc drivers/mmc/core/core.c
index fb4423e547eb,1076b9d89df3..000000000000
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@@ -507,12 -506,9 +506,16 @@@ static enum mmc_blk_status mmc_wait_for
  		wait_event_interruptible(context_info->wait,
  				(context_info->is_done_rcv ||
  				 context_info->is_new_req));
++<<<<<<< HEAD
 +		spin_lock_irqsave(&context_info->lock, flags);
 +		context_info->is_waiting_last_req = false;
 +		spin_unlock_irqrestore(&context_info->lock, flags);
++=======
+ 
++>>>>>>> 15520111500c (mmc: core: Further fix thread wake-up)
  		if (context_info->is_done_rcv) {
  			context_info->is_done_rcv = false;
 +			context_info->is_new_req = false;
  			cmd = mrq->cmd;
  
  			if (!cmd->error || !cmd->retries ||
@@@ -530,11 -526,9 +533,16 @@@
  				__mmc_start_request(host, mrq);
  				continue; /* wait for done/new event again */
  			}
++<<<<<<< HEAD
 +		} else if (context_info->is_new_req) {
 +			context_info->is_new_req = false;
 +			if (!next_req)
 +				return MMC_BLK_NEW_REQUEST;
++=======
++>>>>>>> 15520111500c (mmc: core: Further fix thread wake-up)
  		}
+ 
+ 		return MMC_BLK_NEW_REQUEST;
  	}
  	mmc_retune_release(host);
  	return status;
@@@ -664,10 -655,10 +672,10 @@@ struct mmc_async_req *mmc_start_req(str
  
  	/* Prepare a new request */
  	if (areq)
 -		mmc_pre_req(host, areq->mrq);
 +		mmc_pre_req(host, areq->mrq, !host->areq);
  
  	if (host->areq) {
- 		status = mmc_wait_for_data_req_done(host, host->areq->mrq, areq);
+ 		status = mmc_wait_for_data_req_done(host, host->areq->mrq);
  		if (status == MMC_BLK_NEW_REQUEST) {
  			if (ret_stat)
  				*ret_stat = status;
* Unmerged path drivers/mmc/core/core.c
