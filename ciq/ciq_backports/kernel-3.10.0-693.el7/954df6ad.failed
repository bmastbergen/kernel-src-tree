HID: wacom: PAD is independent with pen/touch

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: PAD is independent with pen/touch (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.12%
commit-author Ping Cheng <pinglinux@gmail.com>
commit 954df6ad00ea2ba732e2e7ae6a68b3111eee4e09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/954df6ad.failed

PAD can be on pen interface (Intuos Pro and Cintiq series) or touch
interface (Bamboo PT and Intuos PT series) or its own interface
(Bamboo pen-only and Intuos Pen M/S). We need to mark it independently.

	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Reviewed-by:  Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 954df6ad00ea2ba732e2e7ae6a68b3111eee4e09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,eb5531657e41..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1127,42 -1036,162 +1127,161 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 +static int wacom_register_input(struct wacom *wacom)
  {
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 +	struct input_dev *input_dev;
++<<<<<<< HEAD
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 +	int error;
  
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 +	input_dev = input_allocate_device();
 +	if (!input_dev) {
 +		error = -ENOMEM;
 +		goto fail1;
 +	}
  
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 -{
 -	struct input_dev *input_dev;
 +	input_dev->name = wacom_wac->name;
 +	input_dev->dev.parent = &intf->dev;
 +	input_dev->open = wacom_open;
 +	input_dev->close = wacom_close;
 +	usb_to_input_id(dev, &input_dev->id);
 +	input_set_drvdata(input_dev, wacom);
++=======
+ 	struct hid_device *hdev = wacom->hdev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	input_dev = input_allocate_device();
+ 	if (!input_dev)
+ 		return NULL;
+ 
+ 	input_dev->name = wacom_wac->name;
+ 	input_dev->phys = hdev->phys;
+ 	input_dev->dev.parent = &hdev->dev;
+ 	input_dev->open = wacom_open;
+ 	input_dev->close = wacom_close;
+ 	input_dev->uniq = hdev->uniq;
+ 	input_dev->id.bustype = hdev->bus;
+ 	input_dev->id.vendor  = hdev->vendor;
+ 	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
+ 	input_dev->id.version = hdev->version;
+ 	input_set_drvdata(input_dev, wacom);
+ 
+ 	return input_dev;
+ }
+ 
+ static void wacom_free_inputs(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	if (wacom_wac->input)
+ 		input_free_device(wacom_wac->input);
+ 	if (wacom_wac->pad_input)
+ 		input_free_device(wacom_wac->pad_input);
+ 	wacom_wac->input = NULL;
+ 	wacom_wac->pad_input = NULL;
+ }
+ 
+ static int wacom_allocate_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *input_dev, *pad_input_dev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	input_dev = wacom_allocate_input(wacom);
+ 	pad_input_dev = wacom_allocate_input(wacom);
+ 	if (!input_dev || !pad_input_dev) {
+ 		wacom_free_inputs(wacom);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	wacom_wac->input = input_dev;
+ 	wacom_wac->pad_input = pad_input_dev;
+ 	wacom_wac->pad_input->name = wacom_wac->pad_name;
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_clean_inputs(struct wacom *wacom)
+ {
+ 	if (wacom->wacom_wac.input) {
+ 		if (wacom->wacom_wac.input_registered)
+ 			input_unregister_device(wacom->wacom_wac.input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.input);
+ 	}
+ 	if (wacom->wacom_wac.pad_input) {
+ 		if (wacom->wacom_wac.pad_registered)
+ 			input_unregister_device(wacom->wacom_wac.pad_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.pad_input);
+ 	}
+ 	wacom->wacom_wac.input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ 	wacom_destroy_leds(wacom);
+ }
+ 
+ static int wacom_register_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *input_dev, *pad_input_dev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 	int error;
+ 
+ 	input_dev = wacom_wac->input;
+ 	pad_input_dev = wacom_wac->pad_input;
+ 
+ 	if (!input_dev || !pad_input_dev)
+ 		return -EINVAL;
+ 
+ 	error = wacom_setup_pentouch_input_capabilities(input_dev, wacom_wac);
+ 	if (!error) {
+ 		error = input_register_device(input_dev);
+ 		if (error)
+ 			return error;
+ 		wacom_wac->input_registered = true;
+ 	}
+ 
+ 	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pad in use on this interface */
+ 		input_free_device(pad_input_dev);
+ 		wacom_wac->pad_input = NULL;
+ 		pad_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pad_input_dev);
+ 		if (error)
+ 			goto fail_register_pad_input;
+ 		wacom_wac->pad_registered = true;
++>>>>>>> 954df6ad00ea (HID: wacom: PAD is independent with pen/touch)
  
 -		error = wacom_initialize_leds(wacom);
 -		if (error)
 -			goto fail_leds;
 -	}
 +	wacom_wac->input = input_dev;
 +	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
 +	if (error)
 +		goto fail1;
 +
++<<<<<<< HEAD
 +	error = input_register_device(input_dev);
 +	if (error)
 +		goto fail2;
 +
 +	return 0;
  
 +fail2:
 +	input_free_device(input_dev);
 +	wacom_wac->input = NULL;
 +fail1:
++=======
+ 	return 0;
+ 
+ fail_leds:
+ 	input_unregister_device(pad_input_dev);
+ 	pad_input_dev = NULL;
+ 	wacom_wac->pad_registered = false;
+ fail_register_pad_input:
+ 	input_unregister_device(input_dev);
+ 	wacom_wac->input = NULL;
+ 	wacom_wac->input_registered = false;
++>>>>>>> 954df6ad00ea (HID: wacom: PAD is independent with pen/touch)
  	return error;
  }
  
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,128cbb337ff6..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -146,6 -181,9 +146,12 @@@ struct wacom_wac 
  	struct wacom_features features;
  	struct wacom_shared *shared;
  	struct input_dev *input;
++<<<<<<< HEAD
++=======
+ 	struct input_dev *pad_input;
+ 	bool input_registered;
+ 	bool pad_registered;
++>>>>>>> 954df6ad00ea (HID: wacom: PAD is independent with pen/touch)
  	int pid;
  	int battery_capacity;
  	int num_contacts_left;
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.h
