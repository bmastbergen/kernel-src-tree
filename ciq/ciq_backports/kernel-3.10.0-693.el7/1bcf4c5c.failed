NFS: Allow getattr to also report readdirplus cache hits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 1bcf4c5c597d1b1862cf54e65198f1c9e3cad29c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1bcf4c5c.failed

If the use called stat() on an 'ls -l' workload, and the attribute
cache was successfully revalidate by READDIRPLUS, then we want to
report that back so that the readdir code continues to use
readdirplus.

	Reviewed-by: Benjamin Coddington <bcodding@redhat.com>
	Tested-by: Benjamin Coddington <bcodding@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 1bcf4c5c597d1b1862cf54e65198f1c9e3cad29c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/internal.h
diff --cc fs/nfs/internal.h
index b446709f1269,6b79c2ca9b9a..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -352,9 -344,12 +352,13 @@@ extern struct nfs_client *nfs_init_clie
  			   const struct nfs_client_initdata *);
  
  /* dir.c */
++<<<<<<< HEAD
 +extern int nfs_access_cache_shrinker(struct shrinker *shrink,
 +					struct shrink_control *sc);
++=======
+ extern void nfs_advise_use_readdirplus(struct inode *dir);
++>>>>>>> 1bcf4c5c597d (NFS: Allow getattr to also report readdirplus cache hits)
  extern void nfs_force_use_readdirplus(struct inode *dir);
 -extern unsigned long nfs_access_cache_count(struct shrinker *shrink,
 -					    struct shrink_control *sc);
 -extern unsigned long nfs_access_cache_scan(struct shrinker *shrink,
 -					   struct shrink_control *sc);
  struct dentry *nfs_lookup(struct inode *, struct dentry *, unsigned int);
  int nfs_create(struct inode *, struct dentry *, umode_t, bool);
  int nfs_mkdir(struct inode *, struct dentry *, umode_t);
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 770fe7b74079..95c92c900e6a 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -444,7 +444,6 @@ bool nfs_use_readdirplus(struct inode *dir, struct file *filp)
  * readdirplus to accelerate any future lookups in the same
  * directory.
  */
-static
 void nfs_advise_use_readdirplus(struct inode *dir)
 {
 	set_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index f056e9789b3f..3da14a2b07de 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -628,15 +628,28 @@ void nfs_setattr_update_inode(struct inode *inode, struct iattr *attr,
 }
 EXPORT_SYMBOL_GPL(nfs_setattr_update_inode);
 
-static void nfs_request_parent_use_readdirplus(struct dentry *dentry)
+static void nfs_readdirplus_parent_cache_miss(struct dentry *dentry)
 {
 	struct dentry *parent;
 
+	if (!nfs_server_capable(d_inode(dentry), NFS_CAP_READDIRPLUS))
+		return;
 	parent = dget_parent(dentry);
 	nfs_force_use_readdirplus(parent->d_inode);
 	dput(parent);
 }
 
+static void nfs_readdirplus_parent_cache_hit(struct dentry *dentry)
+{
+	struct dentry *parent;
+
+	if (!nfs_server_capable(d_inode(dentry), NFS_CAP_READDIRPLUS))
+		return;
+	parent = dget_parent(dentry);
+	nfs_advise_use_readdirplus(d_inode(parent));
+	dput(parent);
+}
+
 static bool nfs_need_revalidate_inode(struct inode *inode)
 {
 	if (NFS_I(inode)->cache_validity &
@@ -679,10 +692,10 @@ int nfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 	if (need_atime || nfs_need_revalidate_inode(inode)) {
 		struct nfs_server *server = NFS_SERVER(inode);
 
-		if (server->caps & NFS_CAP_READDIRPLUS)
-			nfs_request_parent_use_readdirplus(dentry);
+		nfs_readdirplus_parent_cache_miss(dentry);
 		err = __nfs_revalidate_inode(server, inode);
-	}
+	} else
+		nfs_readdirplus_parent_cache_hit(dentry);
 	if (!err) {
 		generic_fillattr(inode, stat);
 		stat->ino = nfs_compat_user_ino64(NFS_FILEID(inode));
* Unmerged path fs/nfs/internal.h
