net/mlx5: Add MTPPS and MTPPSE registers infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Add MTPPS and MTPPSE registers infrastructure (Kamal Heib) [1386723]
Rebuild_FUZZ: 96.23%
commit-author Eugenia Emantayev <eugenia@mellanox.com>
commit f9a1ef720e9e32bc6a4a382c15ac77d62749c79e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f9a1ef72.failed

Implement query and set functionality for MTPPS and MTPPSE registers.
MTPPS (Management Pulse Per Second) provides the device PPS capabilities,
configures the PPS in and out modules and holds the PPS in time stamp.
Query MTPPS is supported only when HCA_CAP.pps is set and modify is supported
when HCA_CAP.pps_modify is set.

MTPPSE (Management Pulse Per Second Event) configures the different event
generation modes for PPS. Supported when HCA_CAP.pps is set.

	Signed-off-by: Eugenia Emantayev <eugenia@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit f9a1ef720e9e32bc6a4a382c15ac77d62749c79e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eq.c
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
#	drivers/net/ethernet/mellanox/mlx5/core/port.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eq.c
index 1c218506675f,ea5d8d37a75c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eq.c
@@@ -289,6 -467,15 +291,18 @@@ static int mlx5_eq_int(struct mlx5_core
  			mlx5_eswitch_vport_event(dev->priv.eswitch, eqe);
  			break;
  #endif
++<<<<<<< HEAD
++=======
+ 
+ 		case MLX5_EVENT_TYPE_PORT_MODULE_EVENT:
+ 			mlx5_port_module_event(dev, eqe);
+ 			break;
+ 
+ 		case MLX5_EVENT_TYPE_PPS_EVENT:
+ 			if (dev->event)
+ 				dev->event(dev, MLX5_DEV_EVENT_PPS, (unsigned long)eqe);
+ 			break;
++>>>>>>> f9a1ef720e9e (net/mlx5: Add MTPPS and MTPPSE registers infrastructure)
  		default:
  			mlx5_core_warn(dev, "Unhandled event 0x%x on EQ 0x%x\n",
  				       eqe->type, eq->eqn);
@@@ -485,9 -685,17 +499,20 @@@ int mlx5_start_eqs(struct mlx5_core_de
  	    mlx5_core_is_pf(dev))
  		async_event_mask |= (1ull << MLX5_EVENT_TYPE_NIC_VPORT_CHANGE);
  
++<<<<<<< HEAD
++=======
+ 	if (MLX5_CAP_GEN(dev, port_module_event))
+ 		async_event_mask |= (1ull << MLX5_EVENT_TYPE_PORT_MODULE_EVENT);
+ 	else
+ 		mlx5_core_dbg(dev, "port_module_event is not set\n");
+ 
+ 	if (MLX5_CAP_GEN(dev, pps))
+ 		async_event_mask |= (1ull << MLX5_EVENT_TYPE_PPS_EVENT);
+ 
++>>>>>>> f9a1ef720e9e (net/mlx5: Add MTPPS and MTPPSE registers infrastructure)
  	err = mlx5_create_map_eq(dev, &table->cmd_eq, MLX5_EQ_VEC_CMD,
  				 MLX5_NUM_CMD_EQE, 1ull << MLX5_EVENT_TYPE_CMD,
 -				 "mlx5_cmd_eq", MLX5_EQ_TYPE_ASYNC);
 +				 "mlx5_cmd_eq", &dev->priv.uuari.uars[0]);
  	if (err) {
  		mlx5_core_warn(dev, "failed to create cmd EQ %d\n", err);
  		return err;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 1f3289b370d9,090e3a1dedc2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -103,6 -113,36 +103,39 @@@ u32 mlx5_get_msix_vec(struct mlx5_core_
  struct mlx5_eq *mlx5_eqn2eq(struct mlx5_core_dev *dev, int eqn);
  void mlx5_cq_tasklet_cb(unsigned long data);
  
++<<<<<<< HEAD
++=======
+ void mlx5_lag_add(struct mlx5_core_dev *dev, struct net_device *netdev);
+ void mlx5_lag_remove(struct mlx5_core_dev *dev);
+ 
+ void mlx5_add_device(struct mlx5_interface *intf, struct mlx5_priv *priv);
+ void mlx5_remove_device(struct mlx5_interface *intf, struct mlx5_priv *priv);
+ void mlx5_attach_device(struct mlx5_core_dev *dev);
+ void mlx5_detach_device(struct mlx5_core_dev *dev);
+ bool mlx5_device_registered(struct mlx5_core_dev *dev);
+ int mlx5_register_device(struct mlx5_core_dev *dev);
+ void mlx5_unregister_device(struct mlx5_core_dev *dev);
+ void mlx5_add_dev_by_protocol(struct mlx5_core_dev *dev, int protocol);
+ void mlx5_remove_dev_by_protocol(struct mlx5_core_dev *dev, int protocol);
+ struct mlx5_core_dev *mlx5_get_next_phys_dev(struct mlx5_core_dev *dev);
+ void mlx5_dev_list_lock(void);
+ void mlx5_dev_list_unlock(void);
+ int mlx5_dev_list_trylock(void);
+ int mlx5_encap_alloc(struct mlx5_core_dev *dev,
+ 		     int header_type,
+ 		     size_t size,
+ 		     void *encap_header,
+ 		     u32 *encap_id);
+ void mlx5_encap_dealloc(struct mlx5_core_dev *dev, u32 encap_id);
+ 
+ bool mlx5_lag_intf_add(struct mlx5_interface *intf, struct mlx5_priv *priv);
+ 
+ int mlx5_query_mtpps(struct mlx5_core_dev *dev, u32 *mtpps, u32 mtpps_size);
+ int mlx5_set_mtpps(struct mlx5_core_dev *mdev, u32 *mtpps, u32 mtpps_size);
+ int mlx5_query_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 *arm, u8 *mode);
+ int mlx5_set_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 arm, u8 mode);
+ 
++>>>>>>> f9a1ef720e9e (net/mlx5: Add MTPPS and MTPPSE registers infrastructure)
  void mlx5e_init(void);
  void mlx5e_cleanup(void);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/port.c
index 96224f6777b6,5ea85336b2e4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@@ -817,3 -809,108 +817,111 @@@ void mlx5_query_port_fcs(struct mlx5_co
  	*supported = !!(MLX5_GET(pcmr_reg, out, fcs_cap));
  	*enabled = !!(MLX5_GET(pcmr_reg, out, fcs_chk));
  }
++<<<<<<< HEAD
++=======
+ 
+ static const char *mlx5_pme_status[MLX5_MODULE_STATUS_NUM] = {
+ 	"Cable plugged",   /* MLX5_MODULE_STATUS_PLUGGED    = 0x1 */
+ 	"Cable unplugged", /* MLX5_MODULE_STATUS_UNPLUGGED  = 0x2 */
+ 	"Cable error",     /* MLX5_MODULE_STATUS_ERROR      = 0x3 */
+ };
+ 
+ static const char *mlx5_pme_error[MLX5_MODULE_EVENT_ERROR_NUM] = {
+ 	"Power budget exceeded",
+ 	"Long Range for non MLNX cable",
+ 	"Bus stuck(I2C or data shorted)",
+ 	"No EEPROM/retry timeout",
+ 	"Enforce part number list",
+ 	"Unknown identifier",
+ 	"High Temperature",
+ 	"Bad or shorted cable/module",
+ 	"Unknown status",
+ };
+ 
+ void mlx5_port_module_event(struct mlx5_core_dev *dev, struct mlx5_eqe *eqe)
+ {
+ 	enum port_module_event_status_type module_status;
+ 	enum port_module_event_error_type error_type;
+ 	struct mlx5_eqe_port_module *module_event_eqe;
+ 	struct mlx5_priv *priv = &dev->priv;
+ 	u8 module_num;
+ 
+ 	module_event_eqe = &eqe->data.port_module;
+ 	module_num = module_event_eqe->module;
+ 	module_status = module_event_eqe->module_status &
+ 			PORT_MODULE_EVENT_MODULE_STATUS_MASK;
+ 	error_type = module_event_eqe->error_type &
+ 		     PORT_MODULE_EVENT_ERROR_TYPE_MASK;
+ 
+ 	if (module_status < MLX5_MODULE_STATUS_ERROR) {
+ 		priv->pme_stats.status_counters[module_status - 1]++;
+ 	} else if (module_status == MLX5_MODULE_STATUS_ERROR) {
+ 		if (error_type >= MLX5_MODULE_EVENT_ERROR_UNKNOWN)
+ 			/* Unknown error type */
+ 			error_type = MLX5_MODULE_EVENT_ERROR_UNKNOWN;
+ 		priv->pme_stats.error_counters[error_type]++;
+ 	}
+ 
+ 	if (!printk_ratelimit())
+ 		return;
+ 
+ 	if (module_status < MLX5_MODULE_STATUS_ERROR)
+ 		mlx5_core_info(dev,
+ 			       "Port module event: module %u, %s\n",
+ 			       module_num, mlx5_pme_status[module_status - 1]);
+ 
+ 	else if (module_status == MLX5_MODULE_STATUS_ERROR)
+ 		mlx5_core_info(dev,
+ 			       "Port module event[error]: module %u, %s, %s\n",
+ 			       module_num, mlx5_pme_status[module_status - 1],
+ 			       mlx5_pme_error[error_type]);
+ }
+ 
+ int mlx5_query_mtpps(struct mlx5_core_dev *mdev, u32 *mtpps, u32 mtpps_size)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};
+ 
+ 	return mlx5_core_access_reg(mdev, in, sizeof(in), mtpps,
+ 				    mtpps_size, MLX5_REG_MTPPS, 0, 0);
+ }
+ 
+ int mlx5_set_mtpps(struct mlx5_core_dev *mdev, u32 *mtpps, u32 mtpps_size)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(mtpps_reg)] = {0};
+ 
+ 	return mlx5_core_access_reg(mdev, mtpps, mtpps_size, out,
+ 				    sizeof(out), MLX5_REG_MTPPS, 0, 1);
+ }
+ 
+ int mlx5_query_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 *arm, u8 *mode)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(mtppse_reg)] = {0};
+ 	u32 in[MLX5_ST_SZ_DW(mtppse_reg)] = {0};
+ 	int err = 0;
+ 
+ 	MLX5_SET(mtppse_reg, in, pin, pin);
+ 
+ 	err = mlx5_core_access_reg(mdev, in, sizeof(in), out,
+ 				   sizeof(out), MLX5_REG_MTPPSE, 0, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	*arm = MLX5_GET(mtppse_reg, in, event_arm);
+ 	*mode = MLX5_GET(mtppse_reg, in, event_generation_mode);
+ 
+ 	return err;
+ }
+ 
+ int mlx5_set_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 arm, u8 mode)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(mtppse_reg)] = {0};
+ 	u32 in[MLX5_ST_SZ_DW(mtppse_reg)] = {0};
+ 
+ 	MLX5_SET(mtppse_reg, in, pin, pin);
+ 	MLX5_SET(mtppse_reg, in, event_arm, arm);
+ 	MLX5_SET(mtppse_reg, in, event_generation_mode, mode);
+ 
+ 	return mlx5_core_access_reg(mdev, in, sizeof(in), out,
+ 				    sizeof(out), MLX5_REG_MTPPSE, 0, 1);
+ }
++>>>>>>> f9a1ef720e9e (net/mlx5: Add MTPPS and MTPPSE registers infrastructure)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eq.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/port.c
diff --git a/include/linux/mlx5/device.h b/include/linux/mlx5/device.h
index bcbc4ce3547e..1f989cdc4bc6 100644
--- a/include/linux/mlx5/device.h
+++ b/include/linux/mlx5/device.h
@@ -292,6 +292,7 @@ enum mlx5_event {
 	MLX5_EVENT_TYPE_GPIO_EVENT	   = 0x15,
 	MLX5_EVENT_TYPE_PORT_MODULE_EVENT  = 0x16,
 	MLX5_EVENT_TYPE_REMOTE_CONFIG	   = 0x19,
+	MLX5_EVENT_TYPE_PPS_EVENT          = 0x25,
 
 	MLX5_EVENT_TYPE_DB_BF_CONGESTION   = 0x1a,
 	MLX5_EVENT_TYPE_STALL_EVENT	   = 0x1b,
@@ -603,6 +604,22 @@ struct mlx5_eqe_port_module {
 	u8        error_type;
 } __packed;
 
+struct mlx5_eqe_pps {
+	u8		rsvd0[3];
+	u8		pin;
+	u8		rsvd1[4];
+	union {
+		struct {
+			__be32		time_sec;
+			__be32		time_nsec;
+		};
+		struct {
+			__be64		time_stamp;
+		};
+	};
+	u8		rsvd2[12];
+} __packed;
+
 union ev_data {
 	__be32				raw[7];
 	struct mlx5_eqe_cmd		cmd;
@@ -617,6 +634,7 @@ union ev_data {
 	struct mlx5_eqe_page_fault	page_fault;
 	struct mlx5_eqe_vport_change	vport_change;
 	struct mlx5_eqe_port_module	port_module;
+	struct mlx5_eqe_pps		pps;
 } __packed;
 
 struct mlx5_eqe {
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index b16df05fa672..741c4619e9b8 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -122,6 +122,8 @@ enum {
 	MLX5_REG_HOST_ENDIANNESS = 0x7004,
 	MLX5_REG_MCIA		 = 0x9014,
 	MLX5_REG_MLCR		 = 0x902b,
+	MLX5_REG_MTPPS		 = 0x9053,
+	MLX5_REG_MTPPSE		 = 0x9054,
 };
 
 enum mlx5_dcbx_oper_mode {
@@ -169,6 +171,7 @@ enum mlx5_dev_event {
 	MLX5_DEV_EVENT_PKEY_CHANGE,
 	MLX5_DEV_EVENT_GUID_CHANGE,
 	MLX5_DEV_EVENT_CLIENT_REREG,
+	MLX5_DEV_EVENT_PPS,
 };
 
 enum mlx5_port_status {
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index 5d35644d91ed..5af0fcfd1291 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -811,7 +811,9 @@ struct mlx5_ifc_cmd_hca_cap_bits {
 	u8         port_type[0x2];
 	u8         num_ports[0x8];
 
-	u8         reserved_at_1c0[0x3];
+	u8         reserved_at_1c0[0x1];
+	u8         pps[0x1];
+	u8         pps_modify[0x1];
 	u8         log_max_msg[0x5];
 	u8         reserved_at_1c8[0x4];
 	u8         max_tc[0x4];
@@ -7607,6 +7609,60 @@ struct mlx5_ifc_initial_seg_bits {
 	u8         reserved_at_80a0[0x17fc0];
 };
 
+struct mlx5_ifc_mtpps_reg_bits {
+	u8         reserved_at_0[0xc];
+	u8         cap_number_of_pps_pins[0x4];
+	u8         reserved_at_10[0x4];
+	u8         cap_max_num_of_pps_in_pins[0x4];
+	u8         reserved_at_18[0x4];
+	u8         cap_max_num_of_pps_out_pins[0x4];
+
+	u8         reserved_at_20[0x24];
+	u8         cap_pin_3_mode[0x4];
+	u8         reserved_at_48[0x4];
+	u8         cap_pin_2_mode[0x4];
+	u8         reserved_at_50[0x4];
+	u8         cap_pin_1_mode[0x4];
+	u8         reserved_at_58[0x4];
+	u8         cap_pin_0_mode[0x4];
+
+	u8         reserved_at_60[0x4];
+	u8         cap_pin_7_mode[0x4];
+	u8         reserved_at_68[0x4];
+	u8         cap_pin_6_mode[0x4];
+	u8         reserved_at_70[0x4];
+	u8         cap_pin_5_mode[0x4];
+	u8         reserved_at_78[0x4];
+	u8         cap_pin_4_mode[0x4];
+
+	u8         reserved_at_80[0x80];
+
+	u8         enable[0x1];
+	u8         reserved_at_101[0xb];
+	u8         pattern[0x4];
+	u8         reserved_at_110[0x4];
+	u8         pin_mode[0x4];
+	u8         pin[0x8];
+
+	u8         reserved_at_120[0x20];
+
+	u8         time_stamp[0x40];
+
+	u8         out_pulse_duration[0x10];
+	u8         out_periodic_adjustment[0x10];
+
+	u8         reserved_at_1a0[0x60];
+};
+
+struct mlx5_ifc_mtppse_reg_bits {
+	u8         reserved_at_0[0x18];
+	u8         pin[0x8];
+	u8         event_arm[0x1];
+	u8         reserved_at_21[0x1b];
+	u8         event_generation_mode[0x4];
+	u8         reserved_at_40[0x40];
+};
+
 union mlx5_ifc_ports_control_registers_document_bits {
 	struct mlx5_ifc_bufferx_reg_bits bufferx_reg;
 	struct mlx5_ifc_eth_2819_cntrs_grp_data_layout_bits eth_2819_cntrs_grp_data_layout;
@@ -7651,6 +7707,8 @@ union mlx5_ifc_ports_control_registers_document_bits {
 	struct mlx5_ifc_pvlc_reg_bits pvlc_reg;
 	struct mlx5_ifc_slrg_reg_bits slrg_reg;
 	struct mlx5_ifc_sltp_reg_bits sltp_reg;
+	struct mlx5_ifc_mtpps_reg_bits mtpps_reg;
+	struct mlx5_ifc_mtppse_reg_bits mtppse_reg;
 	u8         reserved_at_0[0x60e0];
 };
 
