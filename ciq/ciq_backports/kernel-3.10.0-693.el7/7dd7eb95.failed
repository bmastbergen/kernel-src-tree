ipv6: Check ip6_find_1stfragopt() return value properly.

jira LE-1907
cve CVE-2017-9074
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] ipv6: Check ip6_find_1stfragopt() return value properly (Eric Garver) [1459950] {CVE-2017-9074}
Rebuild_FUZZ: 99.10%
commit-author David S. Miller <davem@davemloft.net>
commit 7dd7eb9513bd02184d45f000ab69d78cb1fa1531
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7dd7eb95.failed

Do not use unsigned variables to see if it returns a negative
error or not.

Fixes: 2423496af35d ("ipv6: Prevent overrun when parsing v6 header options")
	Reported-by: Julia Lawall <julia.lawall@lip6.fr>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7dd7eb9513bd02184d45f000ab69d78cb1fa1531)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_offload.c
diff --cc net/ipv6/ip6_offload.c
index b3b3d9e4ed02,280268f1dd7b..000000000000
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@@ -61,7 -63,7 +61,11 @@@ static struct sk_buff *ipv6_gso_segment
  	const struct net_offload *ops;
  	int proto;
  	struct frag_hdr *fptr;
++<<<<<<< HEAD
 +	unsigned int unfrag_ip6hlen;
++=======
+ 	unsigned int payload_len;
++>>>>>>> 7dd7eb9513bd (ipv6: Check ip6_find_1stfragopt() return value properly.)
  	u8 *prevhdr;
  	int offset = 0;
  	bool encap, udpfrag;
@@@ -104,12 -115,12 +108,12 @@@
  		skb->network_header = (u8 *)ipv6h - skb->head;
  
  		if (udpfrag) {
- 			unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
- 			if (unfrag_ip6hlen < 0)
- 				return ERR_PTR(unfrag_ip6hlen);
- 			fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);
+ 			int err = ip6_find_1stfragopt(skb, &prevhdr);
+ 			if (err < 0)
+ 				return ERR_PTR(err);
+ 			fptr = (struct frag_hdr *)((u8 *)ipv6h + err);
  			fptr->frag_off = htons(offset);
 -			if (skb->next)
 +			if (skb->next != NULL)
  				fptr->frag_off |= htons(IP6_MF);
  			offset += (ntohs(ipv6h->payload_len) -
  				   sizeof(struct frag_hdr));
* Unmerged path net/ipv6/ip6_offload.c
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 4080dcb2bf2b..dac50ce6a58c 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -536,11 +536,10 @@ int ip6_fragment(struct sock *sk, struct sk_buff *skb,
 	u8 *prevhdr, nexthdr = 0;
 	struct net *net = dev_net(skb_dst(skb)->dev);
 
-	hlen = ip6_find_1stfragopt(skb, &prevhdr);
-	if (hlen < 0) {
-		err = hlen;
+	err = ip6_find_1stfragopt(skb, &prevhdr);
+	if (err < 0)
 		goto fail;
-	}
+	hlen = err;
 	nexthdr = *prevhdr;
 
 	mtu = ip6_skb_dst_mtu(skb);
diff --git a/net/ipv6/udp_offload.c b/net/ipv6/udp_offload.c
index 2d14ad9e7e73..5f0c5b8c306e 100644
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@ -29,6 +29,7 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
 	u8 frag_hdr_sz = sizeof(struct frag_hdr);
 	__wsum csum;
 	int tnl_hlen;
+	int err;
 
 	mss = skb_shinfo(skb)->gso_size;
 	if (unlikely(skb->len <= mss))
@@ -90,9 +91,10 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
 		/* Find the unfragmentable header and shift it left by frag_hdr_sz
 		 * bytes to insert fragment header.
 		 */
-		unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
-		if (unfrag_ip6hlen < 0)
-			return ERR_PTR(unfrag_ip6hlen);
+		err = ip6_find_1stfragopt(skb, &prevhdr);
+		if (err < 0)
+			return ERR_PTR(err);
+		unfrag_ip6hlen = err;
 		nexthdr = *prevhdr;
 		*prevhdr = NEXTHDR_FRAGMENT;
 		unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +
