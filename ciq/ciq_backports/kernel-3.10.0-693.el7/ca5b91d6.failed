IB/mlx5: Support RAW Ethernet when RoCE is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit ca5b91d63192ceaa41a6145f8c923debb64c71fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ca5b91d6.failed

On some environments, such as certain SRIOV VF configurations, RoCE is
not supported for mlx5 Ethernet ports. Currently, the driver will not
open IB device on that port.

This is problematic, since we do want user-space RAW Ethernet (RAW_PACKET
QPs) functionality to remain in place. For that end, enhance the relevant
driver flows such that we do create a device instance in that case.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit ca5b91d63192ceaa41a6145f8c923debb64c71fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 37c188b28ba8,8b013f8b832a..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -2650,21 -2876,67 +2653,71 @@@ static int mlx5_enable_roce(struct mlx5
  	if (err)
  		return err;
  
- 	err = mlx5_nic_vport_enable_roce(dev->mdev);
- 	if (err)
- 		goto err_unregister_netdevice_notifier;
+ 	if (MLX5_CAP_GEN(dev->mdev, roce)) {
+ 		err = mlx5_nic_vport_enable_roce(dev->mdev);
+ 		if (err)
+ 			goto err_unregister_netdevice_notifier;
+ 	}
  
 -	err = mlx5_eth_lag_init(dev);
 -	if (err)
 -		goto err_disable_roce;
 -
  	return 0;
  
++<<<<<<< HEAD
++=======
+ err_disable_roce:
+ 	if (MLX5_CAP_GEN(dev->mdev, roce))
+ 		mlx5_nic_vport_disable_roce(dev->mdev);
+ 
++>>>>>>> ca5b91d63192 (IB/mlx5: Support RAW Ethernet when RoCE is disabled)
  err_unregister_netdevice_notifier:
 -	mlx5_remove_netdev_notifier(dev);
 +	unregister_netdevice_notifier_rh(&dev->roce.nb);
  	return err;
  }
  
 -static void mlx5_disable_eth(struct mlx5_ib_dev *dev)
 +static void mlx5_disable_roce(struct mlx5_ib_dev *dev)
  {
++<<<<<<< HEAD
 +	mlx5_nic_vport_disable_roce(dev->mdev);
 +	unregister_netdevice_notifier_rh(&dev->roce.nb);
++=======
+ 	mlx5_eth_lag_cleanup(dev);
+ 	if (MLX5_CAP_GEN(dev->mdev, roce))
+ 		mlx5_nic_vport_disable_roce(dev->mdev);
+ }
+ 
+ static void mlx5_ib_dealloc_q_counters(struct mlx5_ib_dev *dev)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < dev->num_ports; i++)
+ 		mlx5_core_dealloc_q_counter(dev->mdev,
+ 					    dev->port[i].q_cnt_id);
+ }
+ 
+ static int mlx5_ib_alloc_q_counters(struct mlx5_ib_dev *dev)
+ {
+ 	int i;
+ 	int ret;
+ 
+ 	for (i = 0; i < dev->num_ports; i++) {
+ 		ret = mlx5_core_alloc_q_counter(dev->mdev,
+ 						&dev->port[i].q_cnt_id);
+ 		if (ret) {
+ 			mlx5_ib_warn(dev,
+ 				     "couldn't allocate queue counter for port %d, err %d\n",
+ 				     i + 1, ret);
+ 			goto dealloc_counters;
+ 		}
+ 	}
+ 
+ 	return 0;
+ 
+ dealloc_counters:
+ 	while (--i >= 0)
+ 		mlx5_core_dealloc_q_counter(dev->mdev,
+ 					    dev->port[i].q_cnt_id);
+ 
+ 	return ret;
++>>>>>>> ca5b91d63192 (IB/mlx5: Support RAW Ethernet when RoCE is disabled)
  }
  
  static const char * const names[] = {
* Unmerged path drivers/infiniband/hw/mlx5/main.c
