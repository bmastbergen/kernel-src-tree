posix_acl: Clear SGID bit when setting file permissions

jira LE-1907
cve CVE-2016-7097
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.cz>
commit 073931017b49d9458aa351605b43a7e34598caef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/07393101.failed

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 073931017b49d9458aa351605b43a7e34598caef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/f2fs/acl.c
#	fs/gfs2/acl.c
#	fs/hfsplus/posix_acl.c
#	fs/jfs/acl.c
#	fs/ocfs2/acl.c
#	fs/orangefs/acl.c
#	fs/posix_acl.c
#	fs/xfs/xfs_acl.c
#	include/linux/posix_acl.h
diff --cc fs/f2fs/acl.c
index 44abc2f286e0,31344247ce89..000000000000
--- a/fs/f2fs/acl.c
+++ b/fs/f2fs/acl.c
@@@ -223,12 -210,10 +223,16 @@@ static int f2fs_set_acl(struct inode *i
  	case ACL_TYPE_ACCESS:
  		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
  		if (acl) {
- 			error = posix_acl_equiv_mode(acl, &inode->i_mode);
- 			if (error < 0)
+ 			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+ 			if (error)
  				return error;
++<<<<<<< HEAD
 +			set_acl_inode(fi, inode->i_mode);
 +			if (error == 0)
 +				acl = NULL;
++=======
+ 			set_acl_inode(inode, inode->i_mode);
++>>>>>>> 073931017b49 (posix_acl: Clear SGID bit when setting file permissions)
  		}
  		break;
  
diff --cc fs/gfs2/acl.c
index 478ce00b530e,2524807ee070..000000000000
--- a/fs/gfs2/acl.c
+++ b/fs/gfs2/acl.c
@@@ -91,19 -86,38 +91,52 @@@ static int gfs2_acl_set(struct inode *i
  	char *data;
  	const char *name = gfs2_acl_name(type);
  
++<<<<<<< HEAD
 +	BUG_ON(name == NULL);
 +	len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
 +	if (len == 0)
 +		return 0;
 +	data = kmalloc(len, GFP_NOFS);
 +	if (data == NULL)
 +		return -ENOMEM;
 +	error = posix_acl_to_xattr(&init_user_ns, acl, data, len);
 +	if (error < 0)
++=======
+ 	if (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
+ 		return -E2BIG;
+ 
+ 	if (type == ACL_TYPE_ACCESS) {
+ 		umode_t mode = inode->i_mode;
+ 
+ 		error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+ 		if (error)
+ 			return error;
+ 		if (mode != inode->i_mode)
+ 			mark_inode_dirty(inode);
+ 	}
+ 
+ 	if (acl) {
+ 		len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
+ 		if (len == 0)
+ 			return 0;
+ 		data = kmalloc(len, GFP_NOFS);
+ 		if (data == NULL)
+ 			return -ENOMEM;
+ 		error = posix_acl_to_xattr(&init_user_ns, acl, data, len);
+ 		if (error < 0)
+ 			goto out;
+ 	} else {
+ 		data = NULL;
+ 		len = 0;
+ 	}
+ 
+ 	error = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);
+ 	if (error)
++>>>>>>> 073931017b49 (posix_acl: Clear SGID bit when setting file permissions)
  		goto out;
 -	set_cached_acl(inode, type, acl);
 +	error = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);
 +	if (!error)
 +		set_cached_acl(inode, type, acl);
  out:
  	kfree(data);
  	return error;
diff --cc fs/jfs/acl.c
index d254d6d35995,3a1e1554a4e3..000000000000
--- a/fs/jfs/acl.c
+++ b/fs/jfs/acl.c
@@@ -80,21 -74,24 +80,41 @@@ static int jfs_set_acl(tid_t tid, struc
  	int size = 0;
  	char *value = NULL;
  
++<<<<<<< HEAD
 +	if (S_ISLNK(inode->i_mode))
 +		return -EOPNOTSUPP;
++=======
+ 	switch (type) {
+ 	case ACL_TYPE_ACCESS:
+ 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
+ 		if (acl) {
+ 			rc = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+ 			if (rc)
+ 				return rc;
+ 			inode->i_ctime = CURRENT_TIME;
+ 			mark_inode_dirty(inode);
+ 		}
+ 		break;
+ 	case ACL_TYPE_DEFAULT:
+ 		ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
++>>>>>>> 073931017b49 (posix_acl: Clear SGID bit when setting file permissions)
  
 +	switch(type) {
 +		case ACL_TYPE_ACCESS:
 +			ea_name = POSIX_ACL_XATTR_ACCESS;
 +			break;
 +		case ACL_TYPE_DEFAULT:
 +			ea_name = POSIX_ACL_XATTR_DEFAULT;
 +			if (!S_ISDIR(inode->i_mode))
 +				return acl ? -EACCES : 0;
 +			break;
 +		default:
 +			return -EINVAL;
 +	}
  	if (acl) {
  		size = posix_acl_xattr_size(acl->a_count);
  		value = kmalloc(size, GFP_KERNEL);
diff --cc fs/ocfs2/acl.c
index 8a404576fb26,164307b99405..000000000000
--- a/fs/ocfs2/acl.c
+++ b/fs/ocfs2/acl.c
@@@ -274,20 -241,16 +274,28 @@@ static int ocfs2_set_acl(handle_t *hand
  	case ACL_TYPE_ACCESS:
  		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
  		if (acl) {
++<<<<<<< HEAD
 +			umode_t mode = inode->i_mode;
 +			ret = posix_acl_equiv_mode(acl, &mode);
 +			if (ret < 0)
 +				return ret;
 +			else {
 +				if (ret == 0)
 +					acl = NULL;
 +
 +				ret = ocfs2_acl_set_mode(inode, di_bh,
 +							 handle, mode);
 +				if (ret)
 +					return ret;
++=======
+ 			umode_t mode;
+ 
+ 			ret = posix_acl_update_mode(inode, &mode, &acl);
+ 			if (ret)
+ 				return ret;
++>>>>>>> 073931017b49 (posix_acl: Clear SGID bit when setting file permissions)
  
 -			ret = ocfs2_acl_set_mode(inode, di_bh,
 -						 handle, mode);
 -			if (ret)
 -				return ret;
 +			}
  		}
  		break;
  	case ACL_TYPE_DEFAULT:
diff --cc fs/posix_acl.c
index 3000aa424973,bfc3ec388322..000000000000
--- a/fs/posix_acl.c
+++ b/fs/posix_acl.c
@@@ -444,4 -547,407 +444,383 @@@ posix_acl_chmod(struct posix_acl **acl
  	*acl = clone;
  	return err;
  }
 -EXPORT_SYMBOL(__posix_acl_chmod);
 -
 -int
 -posix_acl_chmod(struct inode *inode, umode_t mode)
 -{
 -	struct posix_acl *acl;
 -	int ret = 0;
 -
 -	if (!IS_POSIXACL(inode))
 -		return 0;
 -	if (!inode->i_op->set_acl)
 -		return -EOPNOTSUPP;
 -
 -	acl = get_acl(inode, ACL_TYPE_ACCESS);
 -	if (IS_ERR_OR_NULL(acl)) {
 -		if (acl == ERR_PTR(-EOPNOTSUPP))
 -			return 0;
 -		return PTR_ERR(acl);
 -	}
 -
 -	ret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);
 -	if (ret)
 -		return ret;
 -	ret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);
 -	posix_acl_release(acl);
 -	return ret;
 -}
  EXPORT_SYMBOL(posix_acl_chmod);
++<<<<<<< HEAD
++=======
+ 
+ int
+ posix_acl_create(struct inode *dir, umode_t *mode,
+ 		struct posix_acl **default_acl, struct posix_acl **acl)
+ {
+ 	struct posix_acl *p;
+ 	struct posix_acl *clone;
+ 	int ret;
+ 
+ 	*acl = NULL;
+ 	*default_acl = NULL;
+ 
+ 	if (S_ISLNK(*mode) || !IS_POSIXACL(dir))
+ 		return 0;
+ 
+ 	p = get_acl(dir, ACL_TYPE_DEFAULT);
+ 	if (!p || p == ERR_PTR(-EOPNOTSUPP)) {
+ 		*mode &= ~current_umask();
+ 		return 0;
+ 	}
+ 	if (IS_ERR(p))
+ 		return PTR_ERR(p);
+ 
+ 	clone = posix_acl_clone(p, GFP_NOFS);
+ 	if (!clone)
+ 		goto no_mem;
+ 
+ 	ret = posix_acl_create_masq(clone, mode);
+ 	if (ret < 0)
+ 		goto no_mem_clone;
+ 
+ 	if (ret == 0)
+ 		posix_acl_release(clone);
+ 	else
+ 		*acl = clone;
+ 
+ 	if (!S_ISDIR(*mode))
+ 		posix_acl_release(p);
+ 	else
+ 		*default_acl = p;
+ 
+ 	return 0;
+ 
+ no_mem_clone:
+ 	posix_acl_release(clone);
+ no_mem:
+ 	posix_acl_release(p);
+ 	return -ENOMEM;
+ }
+ EXPORT_SYMBOL_GPL(posix_acl_create);
+ 
+ /**
+  * posix_acl_update_mode  -  update mode in set_acl
+  *
+  * Update the file mode when setting an ACL: compute the new file permission
+  * bits based on the ACL.  In addition, if the ACL is equivalent to the new
+  * file mode, set *acl to NULL to indicate that no ACL should be set.
+  *
+  * As with chmod, clear the setgit bit if the caller is not in the owning group
+  * or capable of CAP_FSETID (see inode_change_ok).
+  *
+  * Called from set_acl inode operations.
+  */
+ int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,
+ 			  struct posix_acl **acl)
+ {
+ 	umode_t mode = inode->i_mode;
+ 	int error;
+ 
+ 	error = posix_acl_equiv_mode(*acl, &mode);
+ 	if (error < 0)
+ 		return error;
+ 	if (error == 0)
+ 		*acl = NULL;
+ 	if (!in_group_p(inode->i_gid) &&
+ 	    !capable_wrt_inode_uidgid(inode, CAP_FSETID))
+ 		mode &= ~S_ISGID;
+ 	*mode_p = mode;
+ 	return 0;
+ }
+ EXPORT_SYMBOL(posix_acl_update_mode);
+ 
+ /*
+  * Fix up the uids and gids in posix acl extended attributes in place.
+  */
+ static void posix_acl_fix_xattr_userns(
+ 	struct user_namespace *to, struct user_namespace *from,
+ 	void *value, size_t size)
+ {
+ 	posix_acl_xattr_header *header = (posix_acl_xattr_header *)value;
+ 	posix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;
+ 	int count;
+ 	kuid_t uid;
+ 	kgid_t gid;
+ 
+ 	if (!value)
+ 		return;
+ 	if (size < sizeof(posix_acl_xattr_header))
+ 		return;
+ 	if (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))
+ 		return;
+ 
+ 	count = posix_acl_xattr_count(size);
+ 	if (count < 0)
+ 		return;
+ 	if (count == 0)
+ 		return;
+ 
+ 	for (end = entry + count; entry != end; entry++) {
+ 		switch(le16_to_cpu(entry->e_tag)) {
+ 		case ACL_USER:
+ 			uid = make_kuid(from, le32_to_cpu(entry->e_id));
+ 			entry->e_id = cpu_to_le32(from_kuid(to, uid));
+ 			break;
+ 		case ACL_GROUP:
+ 			gid = make_kgid(from, le32_to_cpu(entry->e_id));
+ 			entry->e_id = cpu_to_le32(from_kgid(to, gid));
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ void posix_acl_fix_xattr_from_user(void *value, size_t size)
+ {
+ 	struct user_namespace *user_ns = current_user_ns();
+ 	if (user_ns == &init_user_ns)
+ 		return;
+ 	posix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);
+ }
+ 
+ void posix_acl_fix_xattr_to_user(void *value, size_t size)
+ {
+ 	struct user_namespace *user_ns = current_user_ns();
+ 	if (user_ns == &init_user_ns)
+ 		return;
+ 	posix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);
+ }
+ 
+ /*
+  * Convert from extended attribute to in-memory representation.
+  */
+ struct posix_acl *
+ posix_acl_from_xattr(struct user_namespace *user_ns,
+ 		     const void *value, size_t size)
+ {
+ 	posix_acl_xattr_header *header = (posix_acl_xattr_header *)value;
+ 	posix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;
+ 	int count;
+ 	struct posix_acl *acl;
+ 	struct posix_acl_entry *acl_e;
+ 
+ 	if (!value)
+ 		return NULL;
+ 	if (size < sizeof(posix_acl_xattr_header))
+ 		 return ERR_PTR(-EINVAL);
+ 	if (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	count = posix_acl_xattr_count(size);
+ 	if (count < 0)
+ 		return ERR_PTR(-EINVAL);
+ 	if (count == 0)
+ 		return NULL;
+ 	
+ 	acl = posix_acl_alloc(count, GFP_NOFS);
+ 	if (!acl)
+ 		return ERR_PTR(-ENOMEM);
+ 	acl_e = acl->a_entries;
+ 	
+ 	for (end = entry + count; entry != end; acl_e++, entry++) {
+ 		acl_e->e_tag  = le16_to_cpu(entry->e_tag);
+ 		acl_e->e_perm = le16_to_cpu(entry->e_perm);
+ 
+ 		switch(acl_e->e_tag) {
+ 			case ACL_USER_OBJ:
+ 			case ACL_GROUP_OBJ:
+ 			case ACL_MASK:
+ 			case ACL_OTHER:
+ 				break;
+ 
+ 			case ACL_USER:
+ 				acl_e->e_uid =
+ 					make_kuid(user_ns,
+ 						  le32_to_cpu(entry->e_id));
+ 				if (!uid_valid(acl_e->e_uid))
+ 					goto fail;
+ 				break;
+ 			case ACL_GROUP:
+ 				acl_e->e_gid =
+ 					make_kgid(user_ns,
+ 						  le32_to_cpu(entry->e_id));
+ 				if (!gid_valid(acl_e->e_gid))
+ 					goto fail;
+ 				break;
+ 
+ 			default:
+ 				goto fail;
+ 		}
+ 	}
+ 	return acl;
+ 
+ fail:
+ 	posix_acl_release(acl);
+ 	return ERR_PTR(-EINVAL);
+ }
+ EXPORT_SYMBOL (posix_acl_from_xattr);
+ 
+ /*
+  * Convert from in-memory to extended attribute representation.
+  */
+ int
+ posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,
+ 		   void *buffer, size_t size)
+ {
+ 	posix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;
+ 	posix_acl_xattr_entry *ext_entry;
+ 	int real_size, n;
+ 
+ 	real_size = posix_acl_xattr_size(acl->a_count);
+ 	if (!buffer)
+ 		return real_size;
+ 	if (real_size > size)
+ 		return -ERANGE;
+ 
+ 	ext_entry = ext_acl->a_entries;
+ 	ext_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);
+ 
+ 	for (n=0; n < acl->a_count; n++, ext_entry++) {
+ 		const struct posix_acl_entry *acl_e = &acl->a_entries[n];
+ 		ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);
+ 		ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);
+ 		switch(acl_e->e_tag) {
+ 		case ACL_USER:
+ 			ext_entry->e_id =
+ 				cpu_to_le32(from_kuid(user_ns, acl_e->e_uid));
+ 			break;
+ 		case ACL_GROUP:
+ 			ext_entry->e_id =
+ 				cpu_to_le32(from_kgid(user_ns, acl_e->e_gid));
+ 			break;
+ 		default:
+ 			ext_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);
+ 			break;
+ 		}
+ 	}
+ 	return real_size;
+ }
+ EXPORT_SYMBOL (posix_acl_to_xattr);
+ 
+ static int
+ posix_acl_xattr_get(const struct xattr_handler *handler,
+ 		    struct dentry *unused, struct inode *inode,
+ 		    const char *name, void *value, size_t size)
+ {
+ 	struct posix_acl *acl;
+ 	int error;
+ 
+ 	if (!IS_POSIXACL(inode))
+ 		return -EOPNOTSUPP;
+ 	if (S_ISLNK(inode->i_mode))
+ 		return -EOPNOTSUPP;
+ 
+ 	acl = get_acl(inode, handler->flags);
+ 	if (IS_ERR(acl))
+ 		return PTR_ERR(acl);
+ 	if (acl == NULL)
+ 		return -ENODATA;
+ 
+ 	error = posix_acl_to_xattr(&init_user_ns, acl, value, size);
+ 	posix_acl_release(acl);
+ 
+ 	return error;
+ }
+ 
+ int
+ set_posix_acl(struct inode *inode, int type, struct posix_acl *acl)
+ {
+ 	if (!IS_POSIXACL(inode))
+ 		return -EOPNOTSUPP;
+ 	if (!inode->i_op->set_acl)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))
+ 		return acl ? -EACCES : 0;
+ 	if (!inode_owner_or_capable(inode))
+ 		return -EPERM;
+ 
+ 	if (acl) {
+ 		int ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	return inode->i_op->set_acl(inode, acl, type);
+ }
+ EXPORT_SYMBOL(set_posix_acl);
+ 
+ static int
+ posix_acl_xattr_set(const struct xattr_handler *handler,
+ 		    struct dentry *unused, struct inode *inode,
+ 		    const char *name, const void *value,
+ 		    size_t size, int flags)
+ {
+ 	struct posix_acl *acl = NULL;
+ 	int ret;
+ 
+ 	if (value) {
+ 		acl = posix_acl_from_xattr(&init_user_ns, value, size);
+ 		if (IS_ERR(acl))
+ 			return PTR_ERR(acl);
+ 	}
+ 	ret = set_posix_acl(inode, handler->flags, acl);
+ 	posix_acl_release(acl);
+ 	return ret;
+ }
+ 
+ static bool
+ posix_acl_xattr_list(struct dentry *dentry)
+ {
+ 	return IS_POSIXACL(d_backing_inode(dentry));
+ }
+ 
+ const struct xattr_handler posix_acl_access_xattr_handler = {
+ 	.name = XATTR_NAME_POSIX_ACL_ACCESS,
+ 	.flags = ACL_TYPE_ACCESS,
+ 	.list = posix_acl_xattr_list,
+ 	.get = posix_acl_xattr_get,
+ 	.set = posix_acl_xattr_set,
+ };
+ EXPORT_SYMBOL_GPL(posix_acl_access_xattr_handler);
+ 
+ const struct xattr_handler posix_acl_default_xattr_handler = {
+ 	.name = XATTR_NAME_POSIX_ACL_DEFAULT,
+ 	.flags = ACL_TYPE_DEFAULT,
+ 	.list = posix_acl_xattr_list,
+ 	.get = posix_acl_xattr_get,
+ 	.set = posix_acl_xattr_set,
+ };
+ EXPORT_SYMBOL_GPL(posix_acl_default_xattr_handler);
+ 
+ int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)
+ {
+ 	int error;
+ 
+ 	if (type == ACL_TYPE_ACCESS) {
+ 		error = posix_acl_equiv_mode(acl, &inode->i_mode);
+ 		if (error < 0)
+ 			return 0;
+ 		if (error == 0)
+ 			acl = NULL;
+ 	}
+ 
+ 	inode->i_ctime = CURRENT_TIME;
+ 	set_cached_acl(inode, type, acl);
+ 	return 0;
+ }
+ 
+ int simple_acl_create(struct inode *dir, struct inode *inode)
+ {
+ 	struct posix_acl *default_acl, *acl;
+ 	int error;
+ 
+ 	error = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);
+ 	if (error)
+ 		return error;
+ 
+ 	set_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);
+ 	set_cached_acl(inode, ACL_TYPE_ACCESS, acl);
+ 
+ 	if (default_acl)
+ 		posix_acl_release(default_acl);
+ 	if (acl)
+ 		posix_acl_release(acl);
+ 	return 0;
+ }
++>>>>>>> 073931017b49 (posix_acl: Clear SGID bit when setting file permissions)
diff --cc fs/xfs/xfs_acl.c
index 20123ec5aa96,8a0dec89ca56..000000000000
--- a/fs/xfs/xfs_acl.c
+++ b/fs/xfs/xfs_acl.c
@@@ -261,163 -244,27 +261,170 @@@ xfs_set_mode(struct inode *inode, umode
  	return error;
  }
  
 +static int
 +xfs_acl_exists(struct inode *inode, unsigned char *name)
 +{
 +	int len = XFS_ACL_MAX_SIZE(XFS_M(inode->i_sb));
 +
 +	return (xfs_attr_get(XFS_I(inode), name, NULL, &len,
 +			    ATTR_ROOT|ATTR_KERNOVAL) == 0);
 +}
 +
 +int
 +posix_acl_access_exists(struct inode *inode)
 +{
 +	return xfs_acl_exists(inode, SGI_ACL_FILE);
 +}
 +
  int
 -xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 +posix_acl_default_exists(struct inode *inode)
  {
 +	if (!S_ISDIR(inode->i_mode))
 +		return 0;
 +	return xfs_acl_exists(inode, SGI_ACL_DEFAULT);
 +}
 +
 +/*
 + * No need for i_mutex because the inode is not yet exposed to the VFS.
 + */
 +int
 +xfs_inherit_acl(struct inode *inode, struct posix_acl *acl)
 +{
 +	umode_t mode = inode->i_mode;
 +	int error = 0, inherit = 0;
 +
 +	if (S_ISDIR(inode->i_mode)) {
 +		error = xfs_set_acl(inode, ACL_TYPE_DEFAULT, acl);
 +		if (error)
 +			goto out;
 +	}
 +
 +	error = posix_acl_create(&acl, GFP_KERNEL, &mode);
 +	if (error < 0)
 +		return error;
 +
 +	/*
 +	 * If posix_acl_create returns a positive value we need to
 +	 * inherit a permission that can't be represented using the Unix
 +	 * mode bits and we actually need to set an ACL.
 +	 */
 +	if (error > 0)
 +		inherit = 1;
 +
 +	error = xfs_set_mode(inode, mode);
 +	if (error)
 +		goto out;
 +
 +	if (inherit)
 +		error = xfs_set_acl(inode, ACL_TYPE_ACCESS, acl);
 +
 +out:
 +	posix_acl_release(acl);
 +	return error;
 +}
 +
 +int
 +xfs_acl_chmod(struct inode *inode)
 +{
 +	struct posix_acl *acl;
 +	int error;
 +
 +	if (S_ISLNK(inode->i_mode))
 +		return -EOPNOTSUPP;
 +
 +	acl = xfs_get_acl(inode, ACL_TYPE_ACCESS);
 +	if (IS_ERR(acl) || !acl)
 +		return PTR_ERR(acl);
 +
 +	error = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
 +	if (error)
 +		return error;
 +
 +	error = xfs_set_acl(inode, ACL_TYPE_ACCESS, acl);
 +	posix_acl_release(acl);
 +	return error;
 +}
 +
 +static int
 +xfs_xattr_acl_get(struct dentry *dentry, const char *name,
 +		void *value, size_t size, int type)
 +{
 +	struct posix_acl *acl;
 +	int error;
 +
 +	acl = xfs_get_acl(dentry->d_inode, type);
 +	if (IS_ERR(acl))
 +		return PTR_ERR(acl);
 +	if (acl == NULL)
 +		return -ENODATA;
 +
 +	error = posix_acl_to_xattr(&init_user_ns, acl, value, size);
 +	posix_acl_release(acl);
 +
 +	return error;
 +}
 +
 +static int
 +xfs_xattr_acl_set(struct dentry *dentry, const char *name,
 +		const void *value, size_t size, int flags, int type)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct posix_acl *acl = NULL;
  	int error = 0;
  
 -	if (!acl)
 +	if (flags & XATTR_CREATE)
 +		return -EINVAL;
 +	if (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))
 +		return value ? -EACCES : 0;
 +	if (!inode_owner_or_capable(inode))
 +		return -EPERM;
 +
 +	if (!value)
  		goto set_acl;
  
 +	acl = posix_acl_from_xattr(&init_user_ns, value, size);
 +	if (!acl) {
 +		/*
 +		 * acl_set_file(3) may request that we set default ACLs with
 +		 * zero length -- defend (gracefully) against that here.
 +		 */
 +		goto out;
 +	}
 +	if (IS_ERR(acl)) {
 +		error = PTR_ERR(acl);
 +		goto out;
 +	}
 +
 +	error = posix_acl_valid(acl);
 +	if (error)
 +		goto out_release;
 +
  	error = -E2BIG;
  	if (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))
 -		return error;
 +		goto out_release;
  
  	if (type == ACL_TYPE_ACCESS) {
++<<<<<<< HEAD
 +		umode_t mode = inode->i_mode;
 +		error = posix_acl_equiv_mode(acl, &mode);
 +
 +		if (error <= 0) {
 +			posix_acl_release(acl);
 +			acl = NULL;
 +
 +			if (error < 0)
 +				return error;
 +		}
++=======
+ 		umode_t mode;
++>>>>>>> 073931017b49 (posix_acl: Clear SGID bit when setting file permissions)
  
+ 		error = posix_acl_update_mode(inode, &mode, &acl);
+ 		if (error)
+ 			return error;
  		error = xfs_set_mode(inode, mode);
  		if (error)
 -			return error;
 +			goto out_release;
  	}
  
   set_acl:
diff --cc include/linux/posix_acl.h
index a8d9918c0b20,bf1046d0397b..000000000000
--- a/include/linux/posix_acl.h
+++ b/include/linux/posix_acl.h
@@@ -95,61 -90,46 +95,79 @@@ extern struct posix_acl *get_posix_acl(
  extern int set_posix_acl(struct inode *, int, struct posix_acl *);
  
  #ifdef CONFIG_FS_POSIX_ACL
++<<<<<<< HEAD
 +static inline struct posix_acl **acl_by_type(struct inode *inode, int type)
++=======
+ extern int posix_acl_chmod(struct inode *, umode_t);
+ extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,
+ 		struct posix_acl **);
+ extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);
+ 
+ extern int simple_set_acl(struct inode *, struct posix_acl *, int);
+ extern int simple_acl_create(struct inode *, struct inode *);
+ 
+ struct posix_acl *get_cached_acl(struct inode *inode, int type);
+ struct posix_acl *get_cached_acl_rcu(struct inode *inode, int type);
+ void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl);
+ void forget_cached_acl(struct inode *inode, int type);
+ void forget_all_cached_acls(struct inode *inode);
+ 
+ static inline void cache_no_acl(struct inode *inode)
++>>>>>>> 073931017b49 (posix_acl: Clear SGID bit when setting file permissions)
  {
 -	inode->i_acl = NULL;
 -	inode->i_default_acl = NULL;
 +	switch (type) {
 +	case ACL_TYPE_ACCESS:
 +		return &inode->i_acl;
 +	case ACL_TYPE_DEFAULT:
 +		return &inode->i_default_acl;
 +	default:
 +		BUG();
 +	}
  }
 -#else
 -static inline int posix_acl_chmod(struct inode *inode, umode_t mode)
 +
 +static inline struct posix_acl *get_cached_acl(struct inode *inode, int type)
  {
 -	return 0;
 +	struct posix_acl **p = acl_by_type(inode, type);
 +	struct posix_acl *acl = ACCESS_ONCE(*p);
 +	if (acl) {
 +		spin_lock(&inode->i_lock);
 +		acl = *p;
 +		if (acl != ACL_NOT_CACHED)
 +			acl = posix_acl_dup(acl);
 +		spin_unlock(&inode->i_lock);
 +	}
 +	return acl;
  }
  
 -#define simple_set_acl		NULL
 -
 -static inline int simple_acl_create(struct inode *dir, struct inode *inode)
 +static inline struct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)
  {
 -	return 0;
 +	return rcu_dereference(*acl_by_type(inode, type));
  }
 -static inline void cache_no_acl(struct inode *inode)
 +
 +static inline void set_cached_acl(struct inode *inode,
 +				  int type,
 +				  struct posix_acl *acl)
  {
 +	struct posix_acl **p = acl_by_type(inode, type);
 +	struct posix_acl *old;
 +	spin_lock(&inode->i_lock);
 +	old = *p;
 +	rcu_assign_pointer(*p, posix_acl_dup(acl));
 +	spin_unlock(&inode->i_lock);
 +	if (old != ACL_NOT_CACHED)
 +		posix_acl_release(old);
  }
  
 -static inline int posix_acl_create(struct inode *inode, umode_t *mode,
 -		struct posix_acl **default_acl, struct posix_acl **acl)
 +static inline void forget_cached_acl(struct inode *inode, int type)
  {
 -	*default_acl = *acl = NULL;
 -	return 0;
 +	struct posix_acl **p = acl_by_type(inode, type);
 +	struct posix_acl *old;
 +	spin_lock(&inode->i_lock);
 +	old = *p;
 +	*p = ACL_NOT_CACHED;
 +	spin_unlock(&inode->i_lock);
 +	if (old != ACL_NOT_CACHED)
 +		posix_acl_release(old);
  }
  
  static inline void forget_all_cached_acls(struct inode *inode)
* Unmerged path fs/hfsplus/posix_acl.c
* Unmerged path fs/orangefs/acl.c
diff --git a/fs/9p/acl.c b/fs/9p/acl.c
index 7af425f53bee..9686c1f17653 100644
--- a/fs/9p/acl.c
+++ b/fs/9p/acl.c
@@ -320,32 +320,26 @@ static int v9fs_xattr_set_acl(struct dentry *dentry, const char *name,
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
-			umode_t mode = inode->i_mode;
-			retval = posix_acl_equiv_mode(acl, &mode);
-			if (retval < 0)
+			struct iattr iattr;
+
+			retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);
+			if (retval)
 				goto err_out;
-			else {
-				struct iattr iattr;
-				if (retval == 0) {
-					/*
-					 * ACL can be represented
-					 * by the mode bits. So don't
-					 * update ACL.
-					 */
-					acl = NULL;
-					value = NULL;
-					size = 0;
-				}
-				/* Updte the mode bits */
-				iattr.ia_mode = ((mode & S_IALLUGO) |
-						 (inode->i_mode & ~S_IALLUGO));
-				iattr.ia_valid = ATTR_MODE;
-				/* FIXME should we update ctime ?
-				 * What is the following setxattr update the
-				 * mode ?
+			if (!acl) {
+				/*
+				 * ACL can be represented
+				 * by the mode bits. So don't
+				 * update ACL.
 				 */
-				v9fs_vfs_setattr_dotl(dentry, &iattr);
+				value = NULL;
+				size = 0;
 			}
+			iattr.ia_valid = ATTR_MODE;
+			/* FIXME should we update ctime ?
+			 * What is the following setxattr update the
+			 * mode ?
+			 */
+			v9fs_vfs_setattr_dotl(dentry, &iattr);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index f3e8df137f07..9e15ea963e7f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -111,11 +111,9 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
-			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (ret < 0)
+			ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (ret)
 				return ret;
-			if (ret == 0)
-				acl = NULL;
 		}
 		ret = 0;
 		break;
diff --git a/fs/ceph/acl.c b/fs/ceph/acl.c
index 13ef95e2a2db..626b3d36ffe2 100644
--- a/fs/ceph/acl.c
+++ b/fs/ceph/acl.c
@@ -115,11 +115,9 @@ static int ceph_set_acl(struct dentry *dentry, struct inode *inode,
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
-			ret = posix_acl_equiv_mode(acl, &new_mode);
-			if (ret < 0)
+			ret = posix_acl_update_mode(inode, &new_mode, &acl);
+			if (ret)
 				goto out;
-			if (ret == 0)
-				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
diff --git a/fs/ext2/acl.c b/fs/ext2/acl.c
index 110b6b371a4e..48c3c2d7d261 100644
--- a/fs/ext2/acl.c
+++ b/fs/ext2/acl.c
@@ -206,15 +206,11 @@ ext2_set_acl(struct inode *inode, int type, struct posix_acl *acl)
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
-				error = posix_acl_equiv_mode(acl, &inode->i_mode);
-				if (error < 0)
+				error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+				if (error)
 					return error;
-				else {
-					inode->i_ctime = CURRENT_TIME_SEC;
-					mark_inode_dirty(inode);
-					if (error == 0)
-						acl = NULL;
-				}
+				inode->i_ctime = CURRENT_TIME_SEC;
+				mark_inode_dirty(inode);
 			}
 			break;
 
diff --git a/fs/ext4/acl.c b/fs/ext4/acl.c
index 39a54a0e9fe4..c844f1bfb451 100644
--- a/fs/ext4/acl.c
+++ b/fs/ext4/acl.c
@@ -211,15 +211,11 @@ ext4_set_acl(handle_t *handle, struct inode *inode, int type,
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
-			error = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (error < 0)
+			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (error)
 				return error;
-			else {
-				inode->i_ctime = ext4_current_time(inode);
-				ext4_mark_inode_dirty(handle, inode);
-				if (error == 0)
-					acl = NULL;
-			}
+			inode->i_ctime = ext4_current_time(inode);
+			ext4_mark_inode_dirty(handle, inode);
 		}
 		break;
 
* Unmerged path fs/f2fs/acl.c
* Unmerged path fs/gfs2/acl.c
* Unmerged path fs/hfsplus/posix_acl.c
diff --git a/fs/jffs2/acl.c b/fs/jffs2/acl.c
index 223283c30111..9335b8d3cf52 100644
--- a/fs/jffs2/acl.c
+++ b/fs/jffs2/acl.c
@@ -243,9 +243,10 @@ static int jffs2_set_acl(struct inode *inode, int type, struct posix_acl *acl)
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
-			umode_t mode = inode->i_mode;
-			rc = posix_acl_equiv_mode(acl, &mode);
-			if (rc < 0)
+			umode_t mode;
+
+			rc = posix_acl_update_mode(inode, &mode, &acl);
+			if (rc)
 				return rc;
 			if (inode->i_mode != mode) {
 				struct iattr attr;
@@ -257,8 +258,6 @@ static int jffs2_set_acl(struct inode *inode, int type, struct posix_acl *acl)
 				if (rc < 0)
 					return rc;
 			}
-			if (rc == 0)
-				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
* Unmerged path fs/jfs/acl.c
* Unmerged path fs/ocfs2/acl.c
* Unmerged path fs/orangefs/acl.c
* Unmerged path fs/posix_acl.c
diff --git a/fs/reiserfs/xattr_acl.c b/fs/reiserfs/xattr_acl.c
index 6c8767fdfc6a..2d73589f37d6 100644
--- a/fs/reiserfs/xattr_acl.c
+++ b/fs/reiserfs/xattr_acl.c
@@ -286,13 +286,9 @@ reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
-			error = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (error < 0)
+			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (error)
 				return error;
-			else {
-				if (error == 0)
-					acl = NULL;
-			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
* Unmerged path fs/xfs/xfs_acl.c
* Unmerged path include/linux/posix_acl.h
