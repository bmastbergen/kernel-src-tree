bnxt_en: Refactor code that determines RFS capability.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Refactor code that determines RFS capability (Jonathan Toppins) [1382378]
Rebuild_FUZZ: 99.07%
commit-author Michael Chan <michael.chan@broadcom.com>
commit 8079e8f107bf02e1e5ece89239dd2fb475a4735f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8079e8f1.failed

Add function bnxt_rfs_supported() that determines if the chip supports
RFS.  Refactor the existing function bnxt_rfs_capable() that determines
if run-time conditions support RFS.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8079e8f107bf02e1e5ece89239dd2fb475a4735f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 3d3cd9192d53,f7ea99ff6fa3..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -4763,16 -4770,152 +4763,160 @@@ static int bnxt_trim_rings(struct bnxt 
  	return 0;
  }
  
 -static void bnxt_setup_msix(struct bnxt *bp)
 +static int bnxt_setup_msix(struct bnxt *bp)
  {
++<<<<<<< HEAD
++=======
+ 	const int len = sizeof(bp->irq_tbl[0].name);
+ 	struct net_device *dev = bp->dev;
+ 	int tcs, i;
+ 
+ 	tcs = netdev_get_num_tc(dev);
+ 	if (tcs > 1) {
+ 		bp->tx_nr_rings_per_tc = bp->tx_nr_rings / tcs;
+ 		if (bp->tx_nr_rings_per_tc == 0) {
+ 			netdev_reset_tc(dev);
+ 			bp->tx_nr_rings_per_tc = bp->tx_nr_rings;
+ 		} else {
+ 			int i, off, count;
+ 
+ 			bp->tx_nr_rings = bp->tx_nr_rings_per_tc * tcs;
+ 			for (i = 0; i < tcs; i++) {
+ 				count = bp->tx_nr_rings_per_tc;
+ 				off = i * count;
+ 				netdev_set_tc_queue(dev, i, count, off);
+ 			}
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < bp->cp_nr_rings; i++) {
+ 		char *attr;
+ 
+ 		if (bp->flags & BNXT_FLAG_SHARED_RINGS)
+ 			attr = "TxRx";
+ 		else if (i < bp->rx_nr_rings)
+ 			attr = "rx";
+ 		else
+ 			attr = "tx";
+ 
+ 		snprintf(bp->irq_tbl[i].name, len, "%s-%s-%d", dev->name, attr,
+ 			 i);
+ 		bp->irq_tbl[i].handler = bnxt_msix;
+ 	}
+ }
+ 
+ static void bnxt_setup_inta(struct bnxt *bp)
+ {
+ 	const int len = sizeof(bp->irq_tbl[0].name);
+ 
+ 	if (netdev_get_num_tc(bp->dev))
+ 		netdev_reset_tc(bp->dev);
+ 
+ 	snprintf(bp->irq_tbl[0].name, len, "%s-%s-%d", bp->dev->name, "TxRx",
+ 		 0);
+ 	bp->irq_tbl[0].handler = bnxt_inta;
+ }
+ 
+ static int bnxt_setup_int_mode(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	if (bp->flags & BNXT_FLAG_USING_MSIX)
+ 		bnxt_setup_msix(bp);
+ 	else
+ 		bnxt_setup_inta(bp);
+ 
+ 	rc = bnxt_set_real_num_queues(bp);
+ 	return rc;
+ }
+ 
+ static unsigned int bnxt_get_max_func_rss_ctxs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_rsscos_ctxs;
+ #endif
+ 	return bp->pf.max_rsscos_ctxs;
+ }
+ 
+ static unsigned int bnxt_get_max_func_vnics(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_vnics;
+ #endif
+ 	return bp->pf.max_vnics;
+ }
+ 
+ unsigned int bnxt_get_max_func_stat_ctxs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_stat_ctxs;
+ #endif
+ 	return bp->pf.max_stat_ctxs;
+ }
+ 
+ void bnxt_set_max_func_stat_ctxs(struct bnxt *bp, unsigned int max)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_stat_ctxs = max;
+ 	else
+ #endif
+ 		bp->pf.max_stat_ctxs = max;
+ }
+ 
+ unsigned int bnxt_get_max_func_cp_rings(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_cp_rings;
+ #endif
+ 	return bp->pf.max_cp_rings;
+ }
+ 
+ void bnxt_set_max_func_cp_rings(struct bnxt *bp, unsigned int max)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_cp_rings = max;
+ 	else
+ #endif
+ 		bp->pf.max_cp_rings = max;
+ }
+ 
+ static unsigned int bnxt_get_max_func_irqs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_irqs;
+ #endif
+ 	return bp->pf.max_irqs;
+ }
+ 
+ void bnxt_set_max_func_irqs(struct bnxt *bp, unsigned int max_irqs)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_irqs = max_irqs;
+ 	else
+ #endif
+ 		bp->pf.max_irqs = max_irqs;
+ }
+ 
+ static int bnxt_init_msix(struct bnxt *bp)
+ {
+ 	int i, total_vecs, rc = 0, min = 1;
++>>>>>>> 8079e8f107bf (bnxt_en: Refactor code that determines RFS capability.)
  	struct msix_entry *msix_ent;
 +	struct net_device *dev = bp->dev;
 +	int i, total_vecs, rc = 0, min = 1;
 +	const int len = sizeof(bp->irq_tbl[0].name);
 +
 +	bp->flags &= ~BNXT_FLAG_USING_MSIX;
 +	total_vecs = bp->cp_nr_rings;
  
 -	total_vecs = bnxt_get_max_func_irqs(bp);
  	msix_ent = kcalloc(total_vecs, sizeof(struct msix_entry), GFP_KERNEL);
  	if (!msix_ent)
  		return -ENOMEM;
@@@ -6948,7 -7119,8 +7102,12 @@@ static int bnxt_init_one(struct pci_de
  				    VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV6;
  	}
  
++<<<<<<< HEAD
 +	if (BNXT_PF(bp) && !BNXT_CHIP_TYPE_NITRO_A0(bp)) {
++=======
+ 	bnxt_hwrm_vnic_qcaps(bp);
+ 	if (bnxt_rfs_supported(bp)) {
++>>>>>>> 8079e8f107bf (bnxt_en: Refactor code that determines RFS capability.)
  		dev->hw_features |= NETIF_F_NTUPLE;
  		if (bnxt_rfs_capable(bp)) {
  			bp->flags |= BNXT_FLAG_RFS;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
