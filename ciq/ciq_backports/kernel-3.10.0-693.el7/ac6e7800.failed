tcp: take care of truncations done by sk_filter()

jira LE-1907
cve CVE-2016-8645
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Dumazet <edumazet@google.com>
commit ac6e780070e30e4c35bd395acfe9191e6268bdd3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ac6e7800.failed

With syzkaller help, Marco Grassi found a bug in TCP stack,
crashing in tcp_collapse()

Root cause is that sk_filter() can truncate the incoming skb,
but TCP stack was not really expecting this to happen.
It probably was expecting a simple DROP or ACCEPT behavior.

We first need to make sure no part of TCP header could be removed.
Then we need to adjust TCP_SKB_CB(skb)->end_seq

Many thanks to syzkaller team and Marco for giving us a reproducer.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Marco Grassi <marco.gra@gmail.com>
	Reported-by: Vladis Dronov <vdronov@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ac6e780070e30e4c35bd395acfe9191e6268bdd3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
#	net/ipv4/tcp_ipv4.c
diff --cc include/net/tcp.h
index b72becc88356,123979fe12bf..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -1073,6 -1219,8 +1073,11 @@@ static inline void tcp_prequeue_init(st
  }
  
  bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);
++<<<<<<< HEAD
++=======
+ bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);
+ int tcp_filter(struct sock *sk, struct sk_buff *skb);
++>>>>>>> ac6e780070e3 (tcp: take care of truncations done by sk_filter())
  
  #undef STATE_TRACE
  
diff --cc net/ipv4/tcp_ipv4.c
index 45719882a4c7,2259114c7242..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -1608,6 -1536,49 +1608,52 @@@ bool tcp_prequeue(struct sock *sk, stru
  }
  EXPORT_SYMBOL(tcp_prequeue);
  
++<<<<<<< HEAD
++=======
+ bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb)
+ {
+ 	u32 limit = sk->sk_rcvbuf + sk->sk_sndbuf;
+ 
+ 	/* Only socket owner can try to collapse/prune rx queues
+ 	 * to reduce memory overhead, so add a little headroom here.
+ 	 * Few sockets backlog are possibly concurrently non empty.
+ 	 */
+ 	limit += 64*1024;
+ 
+ 	/* In case all data was pulled from skb frags (in __pskb_pull_tail()),
+ 	 * we can fix skb->truesize to its real value to avoid future drops.
+ 	 * This is valid because skb is not yet charged to the socket.
+ 	 * It has been noticed pure SACK packets were sometimes dropped
+ 	 * (if cooked by drivers without copybreak feature).
+ 	 */
+ 	if (!skb->data_len)
+ 		skb->truesize = SKB_TRUESIZE(skb_end_offset(skb));
+ 
+ 	if (unlikely(sk_add_backlog(sk, skb, limit))) {
+ 		bh_unlock_sock(sk);
+ 		__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPBACKLOGDROP);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ EXPORT_SYMBOL(tcp_add_backlog);
+ 
+ int tcp_filter(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct tcphdr *th = (struct tcphdr *)skb->data;
+ 	unsigned int eaten = skb->len;
+ 	int err;
+ 
+ 	err = sk_filter_trim_cap(sk, skb, th->doff * 4);
+ 	if (!err) {
+ 		eaten -= skb->len;
+ 		TCP_SKB_CB(skb)->end_seq -= eaten;
+ 	}
+ 	return err;
+ }
+ EXPORT_SYMBOL(tcp_filter);
+ 
++>>>>>>> ac6e780070e3 (tcp: take care of truncations done by sk_filter())
  /*
   *	From tcp_input.c
   */
@@@ -1684,14 -1691,22 +1730,16 @@@ process
  
  	nf_reset(skb);
  
- 	if (sk_filter(sk, skb))
+ 	if (tcp_filter(sk, skb))
  		goto discard_and_relse;
+ 	th = (const struct tcphdr *)skb->data;
+ 	iph = ip_hdr(skb);
  
 +	sk_mark_napi_id(sk, skb);
  	skb->dev = NULL;
  
 -	if (sk->sk_state == TCP_LISTEN) {
 -		ret = tcp_v4_do_rcv(sk, skb);
 -		goto put_and_return;
 -	}
 -
 -	sk_incoming_cpu_update(sk);
 -
  	bh_lock_sock_nested(sk);
 -	tcp_segs_in(tcp_sk(sk), skb);
 +	tcp_sk(sk)->segs_in += max_t(u16, 1, skb_shinfo(skb)->gso_segs);
  	ret = 0;
  	if (!sock_owned_by_user(sk)) {
  		if (!tcp_prequeue(sk, skb))
* Unmerged path include/net/tcp.h
* Unmerged path net/ipv4/tcp_ipv4.c
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 16c7aec20ba5..e404ddcff1a4 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -1264,7 +1264,7 @@ static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
 	if (skb->protocol == htons(ETH_P_IP))
 		return tcp_v4_do_rcv(sk, skb);
 
-	if (sk_filter(sk, skb))
+	if (tcp_filter(sk, skb))
 		goto discard;
 
 	/*
@@ -1440,8 +1440,10 @@ process:
 		goto discard_and_relse;
 #endif
 
-	if (sk_filter(sk, skb))
+	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
+	th = (const struct tcphdr *)skb->data;
+	hdr = ipv6_hdr(skb);
 
 	sk_mark_napi_id(sk, skb);
 	skb->dev = NULL;
