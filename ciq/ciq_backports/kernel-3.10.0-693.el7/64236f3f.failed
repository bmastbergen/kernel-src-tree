ipv6: introduce IFA_F_STABLE_PRIVACY flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 64236f3f3d742469e4027b83a9515e84e9ab21b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/64236f3f.failed

We need to mark appropriate addresses so we can do retries in case their
DAD failed.

	Cc: Erik Kline <ek@google.com>
	Cc: Fernando Gont <fgont@si6networks.com>
	Cc: Lorenzo Colitti <lorenzo@google.com>
	Cc: YOSHIFUJI Hideaki/吉藤英明 <hideaki.yoshifuji@miraclelinux.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 64236f3f3d742469e4027b83a9515e84e9ab21b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index cc12901dc798,c2357b6f62dd..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -2204,6 -2306,12 +2205,15 @@@ void addrconf_prefix_rcv(struct net_dev
  				       in6_dev->token.s6_addr + 8, 8);
  				read_unlock_bh(&in6_dev->lock);
  				tokenized = true;
++<<<<<<< HEAD
++=======
+ 			} else if (in6_dev->addr_gen_mode ==
+ 				   IN6_ADDR_GEN_MODE_STABLE_PRIVACY &&
+ 				   !ipv6_generate_stable_address(&addr, 0,
+ 								 in6_dev)) {
+ 				addr_flags |= IFA_F_STABLE_PRIVACY;
+ 				goto ok;
++>>>>>>> 64236f3f3d74 (ipv6: introduce IFA_F_STABLE_PRIVACY flag)
  			} else if (ipv6_generate_eui64(addr.s6_addr + 8, dev) &&
  				   ipv6_inherit_eui64(addr.s6_addr + 8, in6_dev)) {
  				in6_dev_put(in6_dev);
@@@ -2740,12 -2829,99 +2749,24 @@@ static void addrconf_add_linklocal(stru
  	}
  }
  
 -static bool ipv6_reserved_interfaceid(struct in6_addr address)
 -{
 -	if ((address.s6_addr32[2] | address.s6_addr32[3]) == 0)
 -		return true;
 -
 -	if (address.s6_addr32[2] == htonl(0x02005eff) &&
 -	    ((address.s6_addr32[3] & htonl(0xfe000000)) == htonl(0xfe000000)))
 -		return true;
 -
 -	if (address.s6_addr32[2] == htonl(0xfdffffff) &&
 -	    ((address.s6_addr32[3] & htonl(0xffffff80)) == htonl(0xffffff80)))
 -		return true;
 -
 -	return false;
 -}
 -
 -static int ipv6_generate_stable_address(struct in6_addr *address,
 -					u8 dad_count,
 -					const struct inet6_dev *idev)
 -{
 -	static const int idgen_retries = 3;
 -
 -	static DEFINE_SPINLOCK(lock);
 -	static __u32 digest[SHA_DIGEST_WORDS];
 -	static __u32 workspace[SHA_WORKSPACE_WORDS];
 -
 -	static union {
 -		char __data[SHA_MESSAGE_BYTES];
 -		struct {
 -			struct in6_addr secret;
 -			__be64 prefix;
 -			unsigned char hwaddr[MAX_ADDR_LEN];
 -			u8 dad_count;
 -		} __packed;
 -	} data;
 -
 -	struct in6_addr secret;
 -	struct in6_addr temp;
 -	struct net *net = dev_net(idev->dev);
 -
 -	BUILD_BUG_ON(sizeof(data.__data) != sizeof(data));
 -
 -	if (idev->cnf.stable_secret.initialized)
 -		secret = idev->cnf.stable_secret.secret;
 -	else if (net->ipv6.devconf_dflt->stable_secret.initialized)
 -		secret = net->ipv6.devconf_dflt->stable_secret.secret;
 -	else
 -		return -1;
 -
 -retry:
 -	spin_lock_bh(&lock);
 -
 -	sha_init(digest);
 -	memset(&data, 0, sizeof(data));
 -	memset(workspace, 0, sizeof(workspace));
 -	memcpy(data.hwaddr, idev->dev->perm_addr, idev->dev->addr_len);
 -	data.prefix = ((__be64)address->s6_addr32[0] << 32) |
 -		       (__be64)address->s6_addr32[1];
 -	data.secret = secret;
 -	data.dad_count = dad_count;
 -
 -	sha_transform(digest, data.__data, workspace);
 -
 -	temp = *address;
 -	temp.s6_addr32[2] = digest[0];
 -	temp.s6_addr32[3] = digest[1];
 -
 -	spin_unlock_bh(&lock);
 -
 -	if (ipv6_reserved_interfaceid(temp)) {
 -		dad_count++;
 -		if (dad_count > idgen_retries)
 -			return -1;
 -		goto retry;
 -	}
 -
 -	*address = temp;
 -	return 0;
 -}
 -
  static void addrconf_addr_gen(struct inet6_dev *idev, bool prefix_route)
  {
 -	struct in6_addr addr;
 +	if (idev->addr_gen_mode == IN6_ADDR_GEN_MODE_EUI64) {
 +		struct in6_addr addr;
  
++<<<<<<< HEAD
 +		ipv6_addr_set(&addr,  htonl(0xFE800000), 0, 0, 0);
++=======
+ 	ipv6_addr_set(&addr, htonl(0xFE800000), 0, 0, 0);
+ 
+ 	if (idev->addr_gen_mode == IN6_ADDR_GEN_MODE_STABLE_PRIVACY) {
+ 		if (!ipv6_generate_stable_address(&addr, 0, idev))
+ 			addrconf_add_linklocal(idev, &addr,
+ 					       IFA_F_STABLE_PRIVACY);
+ 		else if (prefix_route)
+ 			addrconf_prefix_route(&addr, 64, idev->dev, 0, 0);
+ 	} else if (idev->addr_gen_mode == IN6_ADDR_GEN_MODE_EUI64) {
++>>>>>>> 64236f3f3d74 (ipv6: introduce IFA_F_STABLE_PRIVACY flag)
  		/* addrconf_add_linklocal also adds a prefix_route and we
  		 * only need to care about prefix routes if ipv6_generate_eui64
  		 * couldn't generate one.
diff --git a/include/uapi/linux/if_addr.h b/include/uapi/linux/if_addr.h
index 40fdfea39714..4318ab1635ce 100644
--- a/include/uapi/linux/if_addr.h
+++ b/include/uapi/linux/if_addr.h
@@ -51,6 +51,7 @@ enum {
 #define IFA_F_MANAGETEMPADDR	0x100
 #define IFA_F_NOPREFIXROUTE	0x200
 #define IFA_F_MCAUTOJOIN	0x400
+#define IFA_F_STABLE_PRIVACY	0x800
 
 struct ifa_cacheinfo {
 	__u32	ifa_prefered;
* Unmerged path net/ipv6/addrconf.c
