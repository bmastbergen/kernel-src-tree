random: introduce getrandom(2) system call

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit c6e9d6f38894798696f23c8084ca7edbf16ee895
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c6e9d6f3.failed

The getrandom(2) system call was requested by the LibreSSL Portable
developers.  It is analoguous to the getentropy(2) system call in
OpenBSD.

The rationale of this system call is to provide resiliance against
file descriptor exhaustion attacks, where the attacker consumes all
available file descriptors, forcing the use of the fallback code where
/dev/[u]random is not available.  Since the fallback code is often not
well-tested, it is better to eliminate this potential failure mode
entirely.

The other feature provided by this new system call is the ability to
request randomness from the /dev/urandom entropy pool, but to block
until at least 128 bits of entropy has been accumulated in the
/dev/urandom entropy pool.  Historically, the emphasis in the
/dev/urandom development has been to ensure that urandom pool is
initialized as quickly as possible after system boot, and preferably
before the init scripts start execution.

This is because changing /dev/urandom reads to block represents an
interface change that could potentially break userspace which is not
acceptable.  In practice, on most x86 desktop and server systems, in
general the entropy pool can be initialized before it is needed (and
in modern kernels, we will printk a warning message if not).  However,
on an embedded system, this may not be the case.  And so with this new
interface, we can provide the functionality of blocking until the
urandom pool has been initialized.  Any userspace program which uses
this new functionality must take care to assure that if it is used
during the boot process, that it will not cause the init scripts or
other portions of the system startup to hang indefinitely.

SYNOPSIS
	#include <linux/random.h>

	int getrandom(void *buf, size_t buflen, unsigned int flags);

DESCRIPTION
	The system call getrandom() fills the buffer pointed to by buf
	with up to buflen random bytes which can be used to seed user
	space random number generators (i.e., DRBG's) or for other
	cryptographic uses.  It should not be used for Monte Carlo
	simulations or other programs/algorithms which are doing
	probabilistic sampling.

	If the GRND_RANDOM flags bit is set, then draw from the
	/dev/random pool instead of the /dev/urandom pool.  The
	/dev/random pool is limited based on the entropy that can be
	obtained from environmental noise, so if there is insufficient
	entropy, the requested number of bytes may not be returned.
	If there is no entropy available at all, getrandom(2) will
	either block, or return an error with errno set to EAGAIN if
	the GRND_NONBLOCK bit is set in flags.

	If the GRND_RANDOM bit is not set, then the /dev/urandom pool
	will be used.  Unlike using read(2) to fetch data from
	/dev/urandom, if the urandom pool has not been sufficiently
	initialized, getrandom(2) will block (or return -1 with the
	errno set to EAGAIN if the GRND_NONBLOCK bit is set in flags).

	The getentropy(2) system call in OpenBSD can be emulated using
	the following function:

            int getentropy(void *buf, size_t buflen)
            {
                    int     ret;

                    if (buflen > 256)
                            goto failure;
                    ret = getrandom(buf, buflen, 0);
                    if (ret < 0)
                            return ret;
                    if (ret == buflen)
                            return 0;
            failure:
                    errno = EIO;
                    return -1;
            }

RETURN VALUE
       On success, the number of bytes that was filled in the buf is
       returned.  This may not be all the bytes requested by the
       caller via buflen if insufficient entropy was present in the
       /dev/random pool, or if the system call was interrupted by a
       signal.

       On error, -1 is returned, and errno is set appropriately.

ERRORS
	EINVAL		An invalid flag was passed to getrandom(2)

	EFAULT		buf is outside the accessible address space.

	EAGAIN		The requested entropy was not available, and
			getentropy(2) would have blocked if the
			GRND_NONBLOCK flag was not set.

	EINTR		While blocked waiting for entropy, the call was
			interrupted by a signal handler; see the description
			of how interrupted read(2) calls on "slow" devices
			are handled with and without the SA_RESTART flag
			in the signal(7) man page.

NOTES
	For small requests (buflen <= 256) getrandom(2) will not
	return EINTR when reading from the urandom pool once the
	entropy pool has been initialized, and it will return all of
	the bytes that have been requested.  This is the recommended
	way to use getrandom(2), and is designed for compatibility
	with OpenBSD's getentropy() system call.

	However, if you are using GRND_RANDOM, then getrandom(2) may
	block until the entropy accounting determines that sufficient
	environmental noise has been gathered such that getrandom(2)
	will be operating as a NRBG instead of a DRBG for those people
	who are working in the NIST SP 800-90 regime.  Since it may
	block for a long time, these guarantees do *not* apply.  The
	user may want to interrupt a hanging process using a signal,
	so blocking until all of the requested bytes are returned
	would be unfriendly.

	For this reason, the user of getrandom(2) MUST always check
	the return value, in case it returns some error, or if fewer
	bytes than requested was returned.  In the case of
	!GRND_RANDOM and small request, the latter should never
	happen, but the careful userspace code (and all crypto code
	should be careful) should check for this anyway!

	Finally, unless you are doing long-term key generation (and
	perhaps not even then), you probably shouldn't be using
	GRND_RANDOM.  The cryptographic algorithms used for
	/dev/urandom are quite conservative, and so should be
	sufficient for all purposes.  The disadvantage of GRND_RANDOM
	is that it can block, and the increased complexity required to
	deal with partially fulfilled getrandom(2) requests.

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Zach Brown <zab@zabbo.net>
(cherry picked from commit c6e9d6f38894798696f23c8084ca7edbf16ee895)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/syscalls/syscall_32.tbl
#	arch/x86/syscalls/syscall_64.tbl
#	drivers/char/random.c
#	include/uapi/asm-generic/unistd.h
diff --cc arch/x86/syscalls/syscall_32.tbl
index 6c93f52b0c39,5b46a618aeb1..000000000000
--- a/arch/x86/syscalls/syscall_32.tbl
+++ b/arch/x86/syscalls/syscall_32.tbl
@@@ -359,5 -359,5 +359,10 @@@
  350	i386	finit_module		sys_finit_module
  351	i386	sched_setattr		sys_sched_setattr
  352	i386	sched_getattr		sys_sched_getattr
++<<<<<<< HEAD
 +356	i386	memfd_create		sys_memfd_create
 +374	i386	userfaultfd		sys_userfaultfd
++=======
+ 353	i386	renameat2		sys_renameat2
+ 355	i386	getrandom		sys_getrandom
++>>>>>>> c6e9d6f38894 (random: introduce getrandom(2) system call)
diff --cc arch/x86/syscalls/syscall_64.tbl
index 4c704c0b050f,0dc4bf891460..000000000000
--- a/arch/x86/syscalls/syscall_64.tbl
+++ b/arch/x86/syscalls/syscall_64.tbl
@@@ -320,12 -320,10 +320,16 @@@
  311	64	process_vm_writev	sys_process_vm_writev
  312	common	kcmp			sys_kcmp
  313	common	finit_module		sys_finit_module
 -314	common	sched_setattr		sys_sched_setattr
 -315	common	sched_getattr		sys_sched_getattr
 +314	common  sched_setattr		sys_sched_setattr
 +315	common  sched_getattr		sys_sched_getattr
  316	common	renameat2		sys_renameat2
++<<<<<<< HEAD
 +319	common	memfd_create		sys_memfd_create
 +320	common	kexec_file_load		sys_kexec_file_load
 +323	common	userfaultfd		sys_userfaultfd
++=======
+ 318	common	getrandom		sys_getrandom
++>>>>>>> c6e9d6f38894 (random: introduce getrandom(2) system call)
  
  #
  # x32-specific system call numbers start at 512 to avoid cache impact
diff --cc drivers/char/random.c
index d734fecb0f95,7d1682ea1e86..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -256,10 -256,10 +256,17 @@@
  #include <linux/fips.h>
  #include <linux/ptrace.h>
  #include <linux/kmemcheck.h>
++<<<<<<< HEAD
 +
 +#ifdef CONFIG_GENERIC_HARDIRQS
 +# include <linux/irq.h>
 +#endif
++=======
+ #include <linux/workqueue.h>
+ #include <linux/irq.h>
+ #include <linux/syscalls.h>
+ #include <linux/completion.h>
++>>>>>>> c6e9d6f38894 (random: introduce getrandom(2) system call)
  
  #include <asm/processor.h>
  #include <asm/uaccess.h>
@@@ -410,19 -406,9 +417,20 @@@ static struct poolinfo 
   */
  static DECLARE_WAIT_QUEUE_HEAD(random_read_wait);
  static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);
+ static DECLARE_WAIT_QUEUE_HEAD(urandom_init_wait);
  static struct fasync_struct *fasync;
  
 +static bool debug;
 +module_param(debug, bool, 0644);
 +#define DEBUG_ENT(fmt, arg...) do { \
 +	if (debug) \
 +		printk(KERN_DEBUG "random %04d %04d %04d: " \
 +		fmt,\
 +		input_pool.entropy_count,\
 +		blocking_pool.entropy_count,\
 +		nonblocking_pool.entropy_count,\
 +		## arg); } while (0)
 +
  /**********************************************************************
   *
   * OS independent entropy store.   Here are the functions which handle
@@@ -658,12 -654,14 +666,23 @@@ retry
  	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
  		goto retry;
  
++<<<<<<< HEAD
 +	if (!r->initialized && nbits > 0) {
 +		r->entropy_total += nbits;
 +		if (r->entropy_total > 128) {
 +			r->initialized = 1;
 +			if (r == &nonblocking_pool)
 +				prandom_reseed_late();
++=======
+ 	r->entropy_total += nbits;
+ 	if (!r->initialized && r->entropy_total > 128) {
+ 		r->initialized = 1;
+ 		r->entropy_total = 0;
+ 		if (r == &nonblocking_pool) {
+ 			prandom_reseed_late();
+ 			wake_up_interruptible(&urandom_init_wait);
+ 			pr_notice("random: %s pool is initialized\n", r->name);
++>>>>>>> c6e9d6f38894 (random: introduce getrandom(2) system call)
  		}
  	}
  
@@@ -1231,63 -1327,80 +1251,80 @@@ void rand_initialize_disk(struct gendis
  }
  #endif
  
 -/*
 - * Attempt an emergency refill using arch_get_random_seed_long().
 - *
 - * As with add_interrupt_randomness() be paranoid and only
 - * credit the output as 50% entropic.
 - */
 -static int arch_random_refill(void)
 +static ssize_t
- random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
++_random_read(int nonblock, char __user *buf, size_t nbytes)
  {
 -	const unsigned int nlongs = 64;	/* Arbitrary number */
 -	unsigned int n = 0;
 -	unsigned int i;
 -	unsigned long buf[nlongs];
 +	ssize_t n, retval = 0, count = 0;
  
 -	if (!arch_has_random_seed())
 +	if (nbytes == 0)
  		return 0;
  
 -	for (i = 0; i < nlongs; i++) {
 -		if (arch_get_random_seed_long(&buf[n]))
 -			n++;
 -	}
 +	while (nbytes > 0) {
 +		n = nbytes;
 +		if (n > SEC_XFER_SIZE)
 +			n = SEC_XFER_SIZE;
  
 -	if (n) {
 -		unsigned int rand_bytes = n * sizeof(unsigned long);
 +		DEBUG_ENT("reading %zu bits\n", n*8);
  
 -		mix_pool_bytes(&input_pool, buf, rand_bytes);
 -		credit_entropy_bits(&input_pool, rand_bytes*4);
 -	}
 +		n = extract_entropy_user(&blocking_pool, buf, n);
  
 -	return n;
 -}
 +		if (n < 0) {
 +			retval = n;
 +			break;
 +		}
  
 -static ssize_t
 -_random_read(int nonblock, char __user *buf, size_t nbytes)
 -{
 -	ssize_t n;
 +		DEBUG_ENT("read got %zd bits (%zd still needed)\n",
 +			  n*8, (nbytes-n)*8);
  
 -	if (nbytes == 0)
 -		return 0;
 +		if (n == 0) {
 +			if (file->f_flags & O_NONBLOCK) {
 +				retval = -EAGAIN;
 +				break;
 +			}
 +
 +			DEBUG_ENT("sleeping?\n");
 +
 +			wait_event_interruptible(random_read_wait,
 +				ENTROPY_BITS(&input_pool) >=
 +				random_read_wakeup_thresh);
 +
 +			DEBUG_ENT("awake\n");
 +
 +			if (signal_pending(current)) {
 +				retval = -ERESTARTSYS;
 +				break;
 +			}
  
 -	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
 -	while (1) {
 -		n = extract_entropy_user(&blocking_pool, buf, nbytes);
 -		if (n < 0)
 -			return n;
 -		trace_random_read(n*8, (nbytes-n)*8,
 -				  ENTROPY_BITS(&blocking_pool),
 -				  ENTROPY_BITS(&input_pool));
 -		if (n > 0)
 -			return n;
 -
 -		/* Pool is (near) empty.  Maybe wait and retry. */
 -
 -		/* First try an emergency refill */
 -		if (arch_random_refill())
  			continue;
 +		}
  
++<<<<<<< HEAD
 +		count += n;
 +		buf += n;
 +		nbytes -= n;
 +		break;		/* This break makes the device work */
 +				/* like a named pipe */
++=======
+ 		if (nonblock)
+ 			return -EAGAIN;
+ 
+ 		wait_event_interruptible(random_read_wait,
+ 			ENTROPY_BITS(&input_pool) >=
+ 			random_read_wakeup_bits);
+ 		if (signal_pending(current))
+ 			return -ERESTARTSYS;
++>>>>>>> c6e9d6f38894 (random: introduce getrandom(2) system call)
  	}
 +
 +	return (count ? count : retval);
  }
  
+ static ssize_t
+ random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+ {
+ 	return _random_read(file->f_flags & O_NONBLOCK, buf, nbytes);
+ }
+ 
  static ssize_t
  urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
  {
diff --cc include/uapi/asm-generic/unistd.h
index 0cc74c4403e4,1d104a2ca643..000000000000
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@@ -692,9 -693,17 +692,23 @@@ __SC_COMP(__NR_process_vm_writev, sys_p
  __SYSCALL(__NR_kcmp, sys_kcmp)
  #define __NR_finit_module 273
  __SYSCALL(__NR_finit_module, sys_finit_module)
++<<<<<<< HEAD
 +
 +#undef __NR_syscalls
 +#define __NR_syscalls 274
++=======
+ #define __NR_sched_setattr 274
+ __SYSCALL(__NR_sched_setattr, sys_sched_setattr)
+ #define __NR_sched_getattr 275
+ __SYSCALL(__NR_sched_getattr, sys_sched_getattr)
+ #define __NR_renameat2 276
+ __SYSCALL(__NR_renameat2, sys_renameat2)
+ #define __NR_getrandom 278
+ __SYSCALL(__NR_getrandom, sys_getrandom)
+ 
+ #undef __NR_syscalls
+ #define __NR_syscalls 279
++>>>>>>> c6e9d6f38894 (random: introduce getrandom(2) system call)
  
  /*
   * All syscalls below here should go away really,
* Unmerged path arch/x86/syscalls/syscall_32.tbl
* Unmerged path arch/x86/syscalls/syscall_64.tbl
* Unmerged path drivers/char/random.c
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index f7e027947e33..d69433229f16 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -860,4 +860,7 @@ asmlinkage long sys_process_vm_writev(pid_t pid,
 asmlinkage long sys_kcmp(pid_t pid1, pid_t pid2, int type,
 			 unsigned long idx1, unsigned long idx2);
 asmlinkage long sys_finit_module(int fd, const char __user *uargs, int flags);
+asmlinkage long sys_getrandom(char __user *buf, size_t count,
+			      unsigned int flags);
+
 #endif
* Unmerged path include/uapi/asm-generic/unistd.h
diff --git a/include/uapi/linux/random.h b/include/uapi/linux/random.h
index fff3528a078f..3f93d1695e7f 100644
--- a/include/uapi/linux/random.h
+++ b/include/uapi/linux/random.h
@@ -40,4 +40,13 @@ struct rand_pool_info {
 	__u32	buf[0];
 };
 
+/*
+ * Flags for getrandom(2)
+ *
+ * GRND_NONBLOCK	Don't block and return EAGAIN instead
+ * GRND_RANDOM		Use the /dev/random pool instead of /dev/urandom
+ */
+#define GRND_NONBLOCK	0x0001
+#define GRND_RANDOM	0x0002
+
 #endif /* _UAPI_LINUX_RANDOM_H */
