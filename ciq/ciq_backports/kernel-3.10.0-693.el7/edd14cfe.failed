genirq: Add untracked irq handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Keith Busch <keith.busch@intel.com>
commit edd14cfebc4404698544d407ecf8eda6e19aa19e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/edd14cfe.failed

This adds a software irq handler for controllers that multiplex
interrupts from multiple devices, but don't know which device generated
the interrupt. For these devices, the irq handler that demuxes must
check every action for every software irq using the same h/w irq in order
to find out which device generated the interrupt. This will inevitably
trigger spurious interrupt detection if we are noting the irq.

The new irq handler does not track the handling for spurious interrupt
detection. An irq that uses this also won't get stats tracked since it
didn't generate the interrupt, nor added to randomness since they are
not random.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: linux-pci@vger.kernel.org
	Cc: Jon Derrick <jonathan.derrick@intel.com>
Link: http://lkml.kernel.org/r/1466200821-29159-1-git-send-email-keith.busch@intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit edd14cfebc4404698544d407ecf8eda6e19aa19e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/irq.h
#	kernel/irq/handle.c
#	kernel/irq/internals.h
diff --cc include/linux/irq.h
index 06861a3c8cfa,562cef010aa8..000000000000
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@@ -409,19 -479,39 +409,31 @@@ static inline int irq_set_parent(int ir
   * Built-in IRQ handlers for various IRQ types,
   * callable via desc->handle_irq()
   */
++<<<<<<< HEAD
 +extern void handle_level_irq(unsigned int irq, struct irq_desc *desc);
 +extern void handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc);
 +extern void handle_edge_irq(unsigned int irq, struct irq_desc *desc);
 +extern void handle_edge_eoi_irq(unsigned int irq, struct irq_desc *desc);
 +extern void handle_simple_irq(unsigned int irq, struct irq_desc *desc);
 +extern void handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
 +extern void handle_percpu_devid_irq(unsigned int irq, struct irq_desc *desc);
 +extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
++=======
+ extern void handle_level_irq(struct irq_desc *desc);
+ extern void handle_fasteoi_irq(struct irq_desc *desc);
+ extern void handle_edge_irq(struct irq_desc *desc);
+ extern void handle_edge_eoi_irq(struct irq_desc *desc);
+ extern void handle_simple_irq(struct irq_desc *desc);
+ extern void handle_untracked_irq(struct irq_desc *desc);
+ extern void handle_percpu_irq(struct irq_desc *desc);
+ extern void handle_percpu_devid_irq(struct irq_desc *desc);
+ extern void handle_bad_irq(struct irq_desc *desc);
++>>>>>>> edd14cfebc44 (genirq: Add untracked irq handler)
  extern void handle_nested_irq(unsigned int irq);
  
 -extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);
 -extern int irq_chip_pm_get(struct irq_data *data);
 -extern int irq_chip_pm_put(struct irq_data *data);
 -#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 -extern void irq_chip_enable_parent(struct irq_data *data);
 -extern void irq_chip_disable_parent(struct irq_data *data);
 -extern void irq_chip_ack_parent(struct irq_data *data);
 -extern int irq_chip_retrigger_hierarchy(struct irq_data *data);
 -extern void irq_chip_mask_parent(struct irq_data *data);
 -extern void irq_chip_unmask_parent(struct irq_data *data);
 -extern void irq_chip_eoi_parent(struct irq_data *data);
 -extern int irq_chip_set_affinity_parent(struct irq_data *data,
 -					const struct cpumask *dest,
 -					bool force);
 -extern int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on);
 -extern int irq_chip_set_vcpu_affinity_parent(struct irq_data *data,
 -					     void *vcpu_info);
 -extern int irq_chip_set_type_parent(struct irq_data *data, unsigned int type);
 -#endif
 -
  /* Handling of unhandled and spurious interrupts: */
 -extern void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret);
 +extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 +			   irqreturn_t action_ret);
  
  
  /* Enable/disable irq debugging output: */
diff --cc kernel/irq/handle.c
index 330d954d787b,d3f24905852c..000000000000
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@@ -130,13 -132,13 +130,21 @@@ static void irq_wake_thread(struct irq_
  	wake_up_process(action->thread);
  }
  
++<<<<<<< HEAD
 +irqreturn_t
 +handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action)
 +{
 +	irqreturn_t retval = IRQ_NONE;
 +	unsigned int flags = 0, irq = desc->irq_data.irq;
++=======
+ irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags)
+ {
+ 	irqreturn_t retval = IRQ_NONE;
+ 	unsigned int irq = desc->irq_data.irq;
+ 	struct irqaction *action;
++>>>>>>> edd14cfebc44 (genirq: Add untracked irq handler)
  
 -	for_each_action_of_desc(desc, action) {
 +	do {
  		irqreturn_t res;
  
  		trace_irq_handler_entry(irq, action);
@@@ -170,13 -172,22 +178,23 @@@
  		}
  
  		retval |= res;
 -	}
 +		action = action->next;
 +	} while (action);
  
- 	add_interrupt_randomness(irq, flags);
+ 	return retval;
+ }
+ 
+ irqreturn_t handle_irq_event_percpu(struct irq_desc *desc)
+ {
+ 	irqreturn_t retval;
+ 	unsigned int flags = 0;
+ 
+ 	retval = __handle_irq_event_percpu(desc, &flags);
+ 
+ 	add_interrupt_randomness(desc->irq_data.irq, flags);
  
  	if (!noirqdebug)
 -		note_interrupt(desc, retval);
 +		note_interrupt(irq, desc, retval);
  	return retval;
  }
  
diff --cc kernel/irq/internals.h
index 001fa5bab490,0c6f35ba9cc0..000000000000
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@@ -76,7 -77,15 +76,12 @@@ extern void unmask_irq(struct irq_desc 
  
  extern void init_kstat_irqs(struct irq_desc *desc, int node, int nr);
  
++<<<<<<< HEAD
 +irqreturn_t handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action);
++=======
+ irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags);
+ irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);
++>>>>>>> edd14cfebc44 (genirq: Add untracked irq handler)
  irqreturn_t handle_irq_event(struct irq_desc *desc);
  
  /* Resending of interrupts :*/
* Unmerged path include/linux/irq.h
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index cbd97ce0b000..55a678703ab6 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -353,6 +353,49 @@ out_unlock:
 }
 EXPORT_SYMBOL_GPL(handle_simple_irq);
 
+/**
+ *	handle_untracked_irq - Simple and software-decoded IRQs.
+ *	@desc:	the interrupt description structure for this irq
+ *
+ *	Untracked interrupts are sent from a demultiplexing interrupt
+ *	handler when the demultiplexer does not know which device it its
+ *	multiplexed irq domain generated the interrupt. IRQ's handled
+ *	through here are not subjected to stats tracking, randomness, or
+ *	spurious interrupt detection.
+ *
+ *	Note: Like handle_simple_irq, the caller is expected to handle
+ *	the ack, clear, mask and unmask issues if necessary.
+ */
+void handle_untracked_irq(struct irq_desc *desc)
+{
+	unsigned int flags = 0;
+
+	raw_spin_lock(&desc->lock);
+
+	if (!irq_may_run(desc))
+		goto out_unlock;
+
+	desc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);
+
+	if (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {
+		desc->istate |= IRQS_PENDING;
+		goto out_unlock;
+	}
+
+	desc->istate &= ~IRQS_PENDING;
+	irqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);
+	raw_spin_unlock(&desc->lock);
+
+	__handle_irq_event_percpu(desc, &flags);
+
+	raw_spin_lock(&desc->lock);
+	irqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);
+
+out_unlock:
+	raw_spin_unlock(&desc->lock);
+}
+EXPORT_SYMBOL_GPL(handle_untracked_irq);
+
 /*
  * Called unconditionally from handle_level_irq() and only for oneshot
  * interrupts from handle_fasteoi_irq()
* Unmerged path kernel/irq/handle.c
* Unmerged path kernel/irq/internals.h
