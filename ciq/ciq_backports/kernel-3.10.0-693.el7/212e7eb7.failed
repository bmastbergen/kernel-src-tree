md/raid1: add failfast handling for writes.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [md] raid1: add failfast handling for writes (Jes Sorensen) [1380016]
Rebuild_FUZZ: 95.12%
commit-author NeilBrown <neilb@suse.com>
commit 212e7eb7a3403464a796c05c2fc46cae3b62d803
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/212e7eb7.failed

When writing to a fastfail device we use MD_FASTFAIL unless
it is the only device being written to.

For resync/recovery, assume there was a working device to
read from so always use REQ_FASTFAIL_DEV.

If a write for resync/recovery fails, we just fail the
device - there is not much else to do.

If a normal failfast write fails, but the device cannot be
failed (must be only one left), we queue for write error
handling.  This will call narrow_write_error() to retry the
write synchronously and without any FAILFAST flags.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 212e7eb7a3403464a796c05c2fc46cae3b62d803)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
diff --cc drivers/md/raid1.c
index 61555b115942,94e0afce6d4c..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -1388,8 -1408,11 +1405,16 @@@ read_again
  				   conf->mirrors[i].rdev->data_offset);
  		mbio->bi_bdev = conf->mirrors[i].rdev->bdev;
  		mbio->bi_end_io	= raid1_end_write_request;
++<<<<<<< HEAD
 +		mbio->bi_rw =
 +			WRITE | do_flush_fua | do_sync | do_discard | do_same;
++=======
+ 		bio_set_op_attrs(mbio, op, do_flush_fua | do_sync);
+ 		if (test_bit(FailFast, &conf->mirrors[i].rdev->flags) &&
+ 		    !test_bit(WriteMostly, &conf->mirrors[i].rdev->flags) &&
+ 		    conf->raid_disks - mddev->degraded > 1)
+ 			mbio->bi_opf |= MD_FAILFAST;
++>>>>>>> 212e7eb7a340 (md/raid1: add failfast handling for writes.)
  		mbio->bi_private = r1_bio;
  
  		atomic_inc(&r1_bio->remaining);
@@@ -2046,7 -2080,10 +2071,14 @@@ static void sync_request_write(struct m
  		      !test_bit(MD_RECOVERY_SYNC, &mddev->recovery))))
  			continue;
  
++<<<<<<< HEAD
 +		wbio->bi_rw = WRITE;
++=======
+ 		bio_set_op_attrs(wbio, REQ_OP_WRITE, 0);
+ 		if (test_bit(FailFast, &conf->mirrors[i].rdev->flags))
+ 			wbio->bi_opf |= MD_FAILFAST;
+ 
++>>>>>>> 212e7eb7a340 (md/raid1: add failfast handling for writes.)
  		wbio->bi_end_io = end_sync_write;
  		atomic_inc(&r1_bio->remaining);
  		md_sync_acct(conf->mirrors[i].rdev->bdev, bio_sectors(wbio));
* Unmerged path drivers/md/raid1.c
