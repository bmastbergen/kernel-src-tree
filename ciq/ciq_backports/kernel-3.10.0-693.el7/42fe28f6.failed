xprtrdma: Do not leak an MW during a DMA map failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 42fe28f607634841e870acf16b10469824594463
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/42fe28f6.failed

Based on code audit.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Tested-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 42fe28f607634841e870acf16b10469824594463)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/fmr_ops.c
#	net/sunrpc/xprtrdma/frwr_ops.c
diff --cc net/sunrpc/xprtrdma/fmr_ops.c
index ecde1e1b320a,6c4527b6c3ca..000000000000
--- a/net/sunrpc/xprtrdma/fmr_ops.c
+++ b/net/sunrpc/xprtrdma/fmr_ops.c
@@@ -220,18 -248,23 +220,28 @@@ fmr_op_map(struct rpcrdma_xprt *r_xprt
  		goto out_maperr;
  
  	seg1->rl_mw = mw;
 -	seg1->mr_rkey = mw->fmr.fm_mr->rkey;
 -	seg1->mr_base = dma_pages[0] + pageoff;
 -	seg1->mr_nsegs = mw->mw_nents;
 +	seg1->mr_rkey = mw->fmr.fmr->rkey;
 +	seg1->mr_base = seg1->mr_dma + pageoff;
 +	seg1->mr_nsegs = i;
  	seg1->mr_len = len;
++<<<<<<< HEAD
 +	return i;
++=======
+ 	return mw->mw_nents;
+ 
+ out_dmamap_err:
+ 	pr_err("rpcrdma: failed to dma map sg %p sg_nents %u\n",
+ 	       mw->mw_sg, mw->mw_nents);
+ 	rpcrdma_defer_mr_recovery(mw);
+ 	return -ENOMEM;
++>>>>>>> 42fe28f60763 (xprtrdma: Do not leak an MW during a DMA map failure)
  
  out_maperr:
 -	pr_err("rpcrdma: ib_map_phys_fmr %u@0x%llx+%i (%d) status %i\n",
 -	       len, (unsigned long long)dma_pages[0],
 -	       pageoff, mw->mw_nents, rc);
 -	rpcrdma_defer_mr_recovery(mw);
 +	dprintk("RPC:       %s: ib_map_phys_fmr %u@0x%llx+%i (%d) status %i\n",
 +		__func__, len, (unsigned long long)seg1->mr_dma,
 +		pageoff, i, rc);
 +	while (i--)
 +		rpcrdma_unmap_one(device, --seg);
  	return rc;
  }
  
diff --cc net/sunrpc/xprtrdma/frwr_ops.c
index 144dce124c80,c9ead2b01b66..000000000000
--- a/net/sunrpc/xprtrdma/frwr_ops.c
+++ b/net/sunrpc/xprtrdma/frwr_ops.c
@@@ -459,15 -430,26 +459,32 @@@ frwr_op_map(struct rpcrdma_xprt *r_xprt
  	seg1->rl_mw = mw;
  	seg1->mr_rkey = mr->rkey;
  	seg1->mr_base = mr->iova;
 -	seg1->mr_nsegs = mw->mw_nents;
 +	seg1->mr_nsegs = frmr->sg_nents;
  	seg1->mr_len = mr->length;
  
++<<<<<<< HEAD
 +	return frmr->sg_nents;
++=======
+ 	return mw->mw_nents;
+ 
+ out_dmamap_err:
+ 	pr_err("rpcrdma: failed to dma map sg %p sg_nents %u\n",
+ 	       mw->mw_sg, mw->mw_nents);
+ 	rpcrdma_defer_mr_recovery(mw);
+ 	return -ENOMEM;
+ 
+ out_mapmr_err:
+ 	pr_err("rpcrdma: failed to map mr %p (%u/%u)\n",
+ 	       frmr->fr_mr, n, mw->mw_nents);
+ 	rc = n < 0 ? n : -EIO;
+ 	rpcrdma_defer_mr_recovery(mw);
+ 	return rc;
++>>>>>>> 42fe28f60763 (xprtrdma: Do not leak an MW during a DMA map failure)
  
  out_senderr:
 -	rpcrdma_defer_mr_recovery(mw);
 +	dprintk("RPC:       %s: ib_post_send status %i\n", __func__, rc);
 +	ib_dma_unmap_sg(device, frmr->sg, dma_nents, direction);
 +	__frwr_queue_recovery(mw);
  	return rc;
  }
  
* Unmerged path net/sunrpc/xprtrdma/fmr_ops.c
* Unmerged path net/sunrpc/xprtrdma/frwr_ops.c
