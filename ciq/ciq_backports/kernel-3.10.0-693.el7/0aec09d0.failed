drop ->s_umount around acct_auto_close()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 0aec09d049d7e994eba54bad4376dd8f58eab797
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0aec09d0.failed

just repeat the frozen check after regaining it, and check that sb
is still alive.  If several threads hit acct_auto_close() at the
same time, acct_auto_close() will survive that just fine.  And we
really don't want to play with writes and closing the file with
->s_umount held exclusive - it's a deadlock country.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 0aec09d049d7e994eba54bad4376dd8f58eab797)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/super.c
diff --cc fs/super.c
index 2255fd76fd29,a369f8964dc1..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -666,13 -702,22 +666,30 @@@ int do_remount_sb(struct super_block *s
  		return -EACCES;
  #endif
  
++<<<<<<< HEAD
 +	if (flags & MS_RDONLY)
 +		acct_auto_close(sb);
 +	shrink_dcache_sb(sb);
 +	sync_filesystem(sb);
 +
++=======
++>>>>>>> 0aec09d049d7 (drop ->s_umount around acct_auto_close())
  	remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);
  
+ 	if (remount_ro) {
+ 		if (sb->s_pins.first) {
+ 			up_write(&sb->s_umount);
+ 			acct_auto_close(&sb->s_pins);
+ 			down_write(&sb->s_umount);
+ 			if (!sb->s_root)
+ 				return 0;
+ 			if (sb->s_writers.frozen != SB_UNFROZEN)
+ 				return -EBUSY;
+ 			remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);
+ 		}
+ 	}
+ 	shrink_dcache_sb(sb);
+ 
  	/* If we are remounting RDONLY and current sb is read/write,
  	   make sure there are no rw files opened */
  	if (remount_ro) {
* Unmerged path fs/super.c
