ACPI / scan: use platform bus type by default for _HID enumeration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Zhang Rui <rui.zhang@intel.com>
commit 48459340b92b00ae1a75179f168ef20d3e61f264
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/48459340.failed

Because of the growing demand for enumerating ACPI devices to
platform bus, change the code to enumerate ACPI device objects to
platform bus by default.  Namely, create platform devices for the
ACPI device objects that
 1. Have pnp.type.platform_id set (device objects with _HID currently).
 2. Do not have a scan handler attached.
 3. Are not SPI/I2C slave devices (that should be enumerated to the
    appropriate buses bus by their parent).

	Signed-off-by: Zhang Rui <rui.zhang@intel.com>
[rjw: Subject and changelog, rebase and code cleanup]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 48459340b92b00ae1a75179f168ef20d3e61f264)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_platform.c
diff --cc drivers/acpi/acpi_platform.c
index b3ba9c50e38e,2bf9082f7523..000000000000
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@@ -22,15 -22,11 +22,23 @@@
  
  ACPI_MODULE_NAME("platform");
  
++<<<<<<< HEAD
 +/*
 + * The following ACPI IDs are known to be suitable for representing as
 + * platform devices.
 + */
 +static const struct acpi_device_id acpi_platform_device_ids[] = {
 +
 +	{ "PNP0D40" },
 +
 +	{ }
++=======
+ static const struct acpi_device_id forbidden_id_list[] = {
+ 	{"PNP0000", 0},	/* PIC */
+ 	{"PNP0100", 0},	/* Timer */
+ 	{"PNP0200", 0},	/* AT DMA Controller */
+ 	{"", 0},
++>>>>>>> 48459340b92b (ACPI / scan: use platform bus type by default for _HID enumeration)
  };
  
  /**
@@@ -114,21 -113,3 +125,24 @@@ struct platform_device *acpi_create_pla
  	kfree(resources);
  	return pdev;
  }
++<<<<<<< HEAD
 +
 +static int acpi_platform_attach(struct acpi_device *adev,
 +				const struct acpi_device_id *id)
 +{
 +	acpi_create_platform_device(adev);
 +	return 1;
 +}
 +
 +static struct acpi_scan_handler platform_handler = {
 +	.ids = acpi_platform_device_ids,
 +	.attach = acpi_platform_attach,
 +};
 +
 +void __init acpi_platform_init(void)
 +{
 +	acpi_scan_add_handler(&platform_handler);
 +}
 +EXPORT_SYMBOL_GPL(acpi_create_platform_device);
++=======
++>>>>>>> 48459340b92b (ACPI / scan: use platform bus type by default for _HID enumeration)
* Unmerged path drivers/acpi/acpi_platform.c
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 2227221e8672..cb8d6d0c6572 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1767,6 +1767,44 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
 	return AE_OK;
 }
 
+static int acpi_check_spi_i2c_slave(struct acpi_resource *ares, void *data)
+{
+	bool *is_spi_i2c_slave_p = data;
+
+	if (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)
+		return 1;
+
+	/*
+	 * devices that are connected to UART still need to be enumerated to
+	 * platform bus
+	 */
+	if (ares->data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)
+		*is_spi_i2c_slave_p = true;
+
+	 /* no need to do more checking */
+	return -1;
+}
+
+static void acpi_default_enumeration(struct acpi_device *device)
+{
+	struct list_head resource_list;
+	bool is_spi_i2c_slave = false;
+
+	if (!device->pnp.type.platform_id || device->handler)
+		return;
+
+	/*
+	 * Do not enemerate SPI/I2C slaves as they will be enuerated by their
+	 * respective parents.
+	 */
+	INIT_LIST_HEAD(&resource_list);
+	acpi_dev_get_resources(device, &resource_list, acpi_check_spi_i2c_slave,
+			       &is_spi_i2c_slave);
+	acpi_dev_free_resource_list(&resource_list);
+	if (!is_spi_i2c_slave)
+		acpi_create_platform_device(device);
+}
+
 static int acpi_scan_attach_handler(struct acpi_device *device)
 {
 	struct acpi_hardware_id *hwid;
@@ -1788,6 +1826,9 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 				break;
 		}
 	}
+	if (!ret)
+		acpi_default_enumeration(device);
+
 	return ret;
 }
 
@@ -1950,7 +1991,6 @@ int __init acpi_scan_init(void)
 	acpi_pci_root_init();
 	acpi_pci_link_init();
 	acpi_processor_init();
-	acpi_platform_init();
 	acpi_lpss_init();
 	acpi_cmos_rtc_init();
 	acpi_container_init();
