NFS: Allow multiple commit requests in flight per file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit af7cf057933f01dc7f33ddfb5e436ad598ed17ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/af7cf057.failed

Allow synchronous RPC calls to wait for pending RPC calls to finish,
but also allow asynchronous ones to just fire off another commit.

With this patch, the xfstests generic/074 test completes in 226s
instead of 242s

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit af7cf057933f01dc7f33ddfb5e436ad598ed17ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/write.c
diff --cc fs/nfs/write.c
index 1c0e89c593fe,ae29f082c9c2..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -1533,27 -1537,29 +1535,35 @@@ static void nfs_writeback_result(struc
  	}
  }
  
- 
- static int nfs_commit_set_lock(struct nfs_inode *nfsi, int may_wait)
+ static int nfs_wait_atomic_killable(atomic_t *key)
  {
- 	int ret;
- 
- 	if (!test_and_set_bit(NFS_INO_COMMIT, &nfsi->flags))
- 		return 1;
- 	if (!may_wait)
- 		return 0;
- 	ret = out_of_line_wait_on_bit_lock(&nfsi->flags,
- 				NFS_INO_COMMIT,
- 				nfs_wait_bit_killable,
- 				TASK_KILLABLE);
- 	return (ret < 0) ? ret : 1;
+ 	if (fatal_signal_pending(current))
+ 		return -ERESTARTSYS;
+ 	freezable_schedule_unsafe();
+ 	return 0;
  }
  
- static void nfs_commit_clear_lock(struct nfs_inode *nfsi)
+ static int wait_on_commit(struct nfs_mds_commit_info *cinfo)
  {
++<<<<<<< HEAD
 +	clear_bit(NFS_INO_COMMIT, &nfsi->flags);
 +	smp_mb__after_clear_bit();
 +	wake_up_bit(&nfsi->flags, NFS_INO_COMMIT);
++=======
+ 	return wait_on_atomic_t(&cinfo->rpcs_out,
+ 			nfs_wait_atomic_killable, TASK_KILLABLE);
+ }
+ 
+ static void nfs_commit_begin(struct nfs_mds_commit_info *cinfo)
+ {
+ 	atomic_inc(&cinfo->rpcs_out);
+ }
+ 
+ static void nfs_commit_end(struct nfs_mds_commit_info *cinfo)
+ {
+ 	if (atomic_dec_and_test(&cinfo->rpcs_out))
+ 		wake_up_atomic_t(&cinfo->rpcs_out);
++>>>>>>> af7cf057933f (NFS: Allow multiple commit requests in flight per file)
  }
  
  void nfs_commitdata_release(struct nfs_commit_data *data)
diff --git a/fs/nfs/direct.c b/fs/nfs/direct.c
index 07e5f6823c61..3cf14f9c7da8 100644
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@ -794,14 +794,8 @@ static void nfs_direct_commit_complete(struct nfs_commit_data *data)
 		nfs_direct_write_complete(dreq, data->inode);
 }
 
-static void nfs_direct_error_cleanup(struct nfs_inode *nfsi)
-{
-	/* There is no lock to clear */
-}
-
 static const struct nfs_commit_completion_ops nfs_direct_commit_completion_ops = {
 	.completion = nfs_direct_commit_complete,
-	.error_cleanup = nfs_direct_error_cleanup,
 };
 
 static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)
diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index c497ac465f2a..264016d7e244 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -516,7 +516,7 @@ static void nfs_check_dirty_writeback(struct page *page,
 	 * so it will not block due to pages that will shortly be freeable.
 	 */
 	nfsi = NFS_I(mapping->host);
-	if (test_bit(NFS_INO_COMMIT, &nfsi->flags)) {
+	if (atomic_read(&nfsi->commit_info.rpcs_out)) {
 		*writeback = true;
 		return;
 	}
diff --git a/fs/nfs/nfstrace.h b/fs/nfs/nfstrace.h
index 59f838cdc009..9f80a086b612 100644
--- a/fs/nfs/nfstrace.h
+++ b/fs/nfs/nfstrace.h
@@ -39,7 +39,6 @@
 			{ 1 << NFS_INO_INVALIDATING, "INVALIDATING" }, \
 			{ 1 << NFS_INO_FLUSHING, "FLUSHING" }, \
 			{ 1 << NFS_INO_FSCACHE, "FSCACHE" }, \
-			{ 1 << NFS_INO_COMMIT, "COMMIT" }, \
 			{ 1 << NFS_INO_LAYOUTCOMMIT, "NEED_LAYOUTCOMMIT" }, \
 			{ 1 << NFS_INO_LAYOUTCOMMITTING, "LAYOUTCOMMIT" })
 
diff --git a/fs/nfs/pnfs_nfs.c b/fs/nfs/pnfs_nfs.c
index 7bab8ecc2235..411a73d8ebe0 100644
--- a/fs/nfs/pnfs_nfs.c
+++ b/fs/nfs/pnfs_nfs.c
@@ -266,17 +266,14 @@ pnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,
 		} else {
 			nfs_retry_commit(mds_pages, NULL, cinfo, 0);
 			pnfs_generic_retry_commit(cinfo, 0);
-			cinfo->completion_ops->error_cleanup(NFS_I(inode));
 			return -ENOMEM;
 		}
 	}
 
 	nreq += pnfs_generic_alloc_ds_commits(cinfo, &list);
 
-	if (nreq == 0) {
-		cinfo->completion_ops->error_cleanup(NFS_I(inode));
+	if (nreq == 0)
 		goto out;
-	}
 
 	atomic_add(nreq, &cinfo->mds->rpcs_out);
 
* Unmerged path fs/nfs/write.c
diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
index 50c488e64add..62a3426dac6f 100644
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -220,7 +220,6 @@ struct nfs_inode {
 #define NFS_INO_FLUSHING	(4)		/* inode is flushing out data */
 #define NFS_INO_FSCACHE		(5)		/* inode can be cached by FS-Cache */
 #define NFS_INO_FSCACHE_LOCK	(6)		/* FS-Cache cookie management lock */
-#define NFS_INO_COMMIT		(7)		/* inode is committing unstable writes */
 #define NFS_INO_LAYOUTCOMMIT	(9)		/* layoutcommit required */
 #define NFS_INO_LAYOUTCOMMITTING (10)		/* layoutcommit inflight */
 #define NFS_INO_LAYOUTSTATS	(11)		/* layoutstats inflight */
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ec4603fd2a1c..088fdada4c7b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1425,7 +1425,6 @@ struct nfs_mds_commit_info {
 struct nfs_commit_data;
 struct nfs_inode;
 struct nfs_commit_completion_ops {
-	void (*error_cleanup) (struct nfs_inode *nfsi);
 	void (*completion) (struct nfs_commit_data *data);
 };
 
