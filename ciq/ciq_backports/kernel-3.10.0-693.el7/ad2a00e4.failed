fs/proc/task_mmu.c: introduce m_next_vma() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] proc/task_mmu.c: introduce m_next_vma() helper (Aaron Tomlin) [1425895]
Rebuild_FUZZ: 96.84%
commit-author Oleg Nesterov <oleg@redhat.com>
commit ad2a00e4b7e20ab03700b0bb13270b6cee45c6e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ad2a00e4.failed

Extract the tail_vma/vm_next calculation from m_next() into the new
trivial helper, m_next_vma().

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Cyrill Gorcunov <gorcunov@openvz.org>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ad2a00e4b7e20ab03700b0bb13270b6cee45c6e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/task_mmu.c
diff --cc fs/proc/task_mmu.c
index 09ca18a42ac3,fef398948462..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -157,22 -138,20 +157,34 @@@ static void vma_stop(struct proc_maps_p
  	mmput(mm);
  }
  
++<<<<<<< HEAD
 +static void *m_start(struct seq_file *m, loff_t *pos)
++=======
+ static struct vm_area_struct *
+ m_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)
+ {
+ 	if (vma == priv->tail_vma)
+ 		return NULL;
+ 	return vma->vm_next ?: priv->tail_vma;
+ }
+ 
+ static void *m_start(struct seq_file *m, loff_t *ppos)
++>>>>>>> ad2a00e4b7e2 (fs/proc/task_mmu.c: introduce m_next_vma() helper)
  {
  	struct proc_maps_private *priv = m->private;
 +	unsigned long last_addr = m->version;
  	struct mm_struct *mm;
 -	struct vm_area_struct *vma;
 -	unsigned int pos = *ppos;
 +	struct vm_area_struct *vma, *tail_vma = NULL;
 +	loff_t l = *pos;
 +
 +	/*
 +	 * We remember last_addr rather than next_addr to hit with
 +	 * mmap_cache most of the time. We have zero last_addr at
 +	 * the beginning and also after lseek. We will have -1 last_addr
 +	 * after the end of the vmas.
 +	 */
 +	if (last_addr == -1UL)
 +		return NULL;
  
  	priv->task = get_pid_task(priv->pid, PIDTYPE_PID);
  	if (!priv->task)
* Unmerged path fs/proc/task_mmu.c
