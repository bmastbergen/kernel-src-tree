xen-netfront: Add support for multiple queues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andrew J. Bennieston <andrew.bennieston@citrix.com>
commit 50ee60611bf0c7328e5cae438ea5c26590f3f747
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/50ee6061.failed

Build on the refactoring of the previous patch to implement multiple
queues between xen-netfront and xen-netback.

Check XenStore for multi-queue support, and set up the rings and event
channels accordingly.

Write ring references and event channels to XenStore in a queue
hierarchy if appropriate, or flat when using only one queue.

Update the xennet_select_queue() function to choose the queue on which
to transmit a packet based on the skb hash result.

	Signed-off-by: Andrew J. Bennieston <andrew.bennieston@citrix.com>
	Acked-by: Wei Liu <wei.liu2@citrix.com>
	Reviewed-by: David Vrabel <david.vrabel@citrix.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 50ee60611bf0c7328e5cae438ea5c26590f3f747)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/xen-netfront.c
diff --cc drivers/net/xen-netfront.c
index 6c33c68dceb8,55bf834d6a8c..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -539,6 -571,24 +545,27 @@@ static int xennet_count_skb_frag_slots(
  	return pages;
  }
  
++<<<<<<< HEAD
++=======
+ static u16 xennet_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			       void *accel_priv, select_queue_fallback_t fallback)
+ {
+ 	unsigned int num_queues = dev->real_num_tx_queues;
+ 	u32 hash;
+ 	u16 queue_idx;
+ 
+ 	/* First, check if there is only one queue */
+ 	if (num_queues == 1) {
+ 		queue_idx = 0;
+ 	} else {
+ 		hash = skb_get_hash(skb);
+ 		queue_idx = hash % num_queues;
+ 	}
+ 
+ 	return queue_idx;
+ }
+ 
++>>>>>>> 50ee60611bf0 (xen-netfront: Add support for multiple queues)
  static int xennet_start_xmit(struct sk_buff *skb, struct net_device *dev)
  {
  	unsigned short id;
@@@ -1274,7 -1334,7 +1301,11 @@@ static struct net_device *xennet_create
  	struct net_device *netdev;
  	struct netfront_info *np;
  
++<<<<<<< HEAD
 +	netdev = alloc_etherdev(sizeof(struct netfront_info));
++=======
+ 	netdev = alloc_etherdev_mq(sizeof(struct netfront_info), xennet_max_queues);
++>>>>>>> 50ee60611bf0 (xen-netfront: Add support for multiple queues)
  	if (!netdev)
  		return ERR_PTR(-ENOMEM);
  
@@@ -1630,6 -1644,149 +1661,152 @@@ fail
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ /* Queue-specific initialisation
+  * This used to be done in xennet_create_dev() but must now
+  * be run per-queue.
+  */
+ static int xennet_init_queue(struct netfront_queue *queue)
+ {
+ 	unsigned short i;
+ 	int err = 0;
+ 
+ 	spin_lock_init(&queue->tx_lock);
+ 	spin_lock_init(&queue->rx_lock);
+ 
+ 	skb_queue_head_init(&queue->rx_batch);
+ 	queue->rx_target     = RX_DFL_MIN_TARGET;
+ 	queue->rx_min_target = RX_DFL_MIN_TARGET;
+ 	queue->rx_max_target = RX_MAX_TARGET;
+ 
+ 	init_timer(&queue->rx_refill_timer);
+ 	queue->rx_refill_timer.data = (unsigned long)queue;
+ 	queue->rx_refill_timer.function = rx_refill_timeout;
+ 
+ 	/* Initialise tx_skbs as a free chain containing every entry. */
+ 	queue->tx_skb_freelist = 0;
+ 	for (i = 0; i < NET_TX_RING_SIZE; i++) {
+ 		skb_entry_set_link(&queue->tx_skbs[i], i+1);
+ 		queue->grant_tx_ref[i] = GRANT_INVALID_REF;
+ 		queue->grant_tx_page[i] = NULL;
+ 	}
+ 
+ 	/* Clear out rx_skbs */
+ 	for (i = 0; i < NET_RX_RING_SIZE; i++) {
+ 		queue->rx_skbs[i] = NULL;
+ 		queue->grant_rx_ref[i] = GRANT_INVALID_REF;
+ 	}
+ 
+ 	/* A grant for every tx ring slot */
+ 	if (gnttab_alloc_grant_references(TX_MAX_TARGET,
+ 					  &queue->gref_tx_head) < 0) {
+ 		pr_alert("can't alloc tx grant refs\n");
+ 		err = -ENOMEM;
+ 		goto exit;
+ 	}
+ 
+ 	/* A grant for every rx ring slot */
+ 	if (gnttab_alloc_grant_references(RX_MAX_TARGET,
+ 					  &queue->gref_rx_head) < 0) {
+ 		pr_alert("can't alloc rx grant refs\n");
+ 		err = -ENOMEM;
+ 		goto exit_free_tx;
+ 	}
+ 
+ 	netif_napi_add(queue->info->netdev, &queue->napi, xennet_poll, 64);
+ 
+ 	return 0;
+ 
+  exit_free_tx:
+ 	gnttab_free_grant_references(queue->gref_tx_head);
+  exit:
+ 	return err;
+ }
+ 
+ static int write_queue_xenstore_keys(struct netfront_queue *queue,
+ 			   struct xenbus_transaction *xbt, int write_hierarchical)
+ {
+ 	/* Write the queue-specific keys into XenStore in the traditional
+ 	 * way for a single queue, or in a queue subkeys for multiple
+ 	 * queues.
+ 	 */
+ 	struct xenbus_device *dev = queue->info->xbdev;
+ 	int err;
+ 	const char *message;
+ 	char *path;
+ 	size_t pathsize;
+ 
+ 	/* Choose the correct place to write the keys */
+ 	if (write_hierarchical) {
+ 		pathsize = strlen(dev->nodename) + 10;
+ 		path = kzalloc(pathsize, GFP_KERNEL);
+ 		if (!path) {
+ 			err = -ENOMEM;
+ 			message = "out of memory while writing ring references";
+ 			goto error;
+ 		}
+ 		snprintf(path, pathsize, "%s/queue-%u",
+ 				dev->nodename, queue->id);
+ 	} else {
+ 		path = (char *)dev->nodename;
+ 	}
+ 
+ 	/* Write ring references */
+ 	err = xenbus_printf(*xbt, path, "tx-ring-ref", "%u",
+ 			queue->tx_ring_ref);
+ 	if (err) {
+ 		message = "writing tx-ring-ref";
+ 		goto error;
+ 	}
+ 
+ 	err = xenbus_printf(*xbt, path, "rx-ring-ref", "%u",
+ 			queue->rx_ring_ref);
+ 	if (err) {
+ 		message = "writing rx-ring-ref";
+ 		goto error;
+ 	}
+ 
+ 	/* Write event channels; taking into account both shared
+ 	 * and split event channel scenarios.
+ 	 */
+ 	if (queue->tx_evtchn == queue->rx_evtchn) {
+ 		/* Shared event channel */
+ 		err = xenbus_printf(*xbt, path,
+ 				"event-channel", "%u", queue->tx_evtchn);
+ 		if (err) {
+ 			message = "writing event-channel";
+ 			goto error;
+ 		}
+ 	} else {
+ 		/* Split event channels */
+ 		err = xenbus_printf(*xbt, path,
+ 				"event-channel-tx", "%u", queue->tx_evtchn);
+ 		if (err) {
+ 			message = "writing event-channel-tx";
+ 			goto error;
+ 		}
+ 
+ 		err = xenbus_printf(*xbt, path,
+ 				"event-channel-rx", "%u", queue->rx_evtchn);
+ 		if (err) {
+ 			message = "writing event-channel-rx";
+ 			goto error;
+ 		}
+ 	}
+ 
+ 	if (write_hierarchical)
+ 		kfree(path);
+ 	return 0;
+ 
+ error:
+ 	if (write_hierarchical)
+ 		kfree(path);
+ 	xenbus_dev_fatal(dev, err, "%s", message);
+ 	return err;
+ }
+ 
++>>>>>>> 50ee60611bf0 (xen-netfront: Add support for multiple queues)
  /* Common code used when first setting up, and when resuming. */
  static int talk_to_netback(struct xenbus_device *dev,
  			   struct netfront_info *info)
@@@ -1637,11 -1794,83 +1814,40 @@@
  	const char *message;
  	struct xenbus_transaction xbt;
  	int err;
++<<<<<<< HEAD
 +
 +	/* Create shared ring, alloc event channel. */
 +	err = setup_netfront(dev, info);
 +	if (err)
++=======
+ 	unsigned int feature_split_evtchn;
+ 	unsigned int i = 0;
+ 	unsigned int max_queues = 0;
+ 	struct netfront_queue *queue = NULL;
+ 	unsigned int num_queues = 1;
+ 
+ 	info->netdev->irq = 0;
+ 
+ 	/* Check if backend supports multiple queues */
+ 	err = xenbus_scanf(XBT_NIL, info->xbdev->otherend,
+ 			   "multi-queue-max-queues", "%u", &max_queues);
+ 	if (err < 0)
+ 		max_queues = 1;
+ 	num_queues = min(max_queues, xennet_max_queues);
+ 
+ 	/* Check feature-split-event-channels */
+ 	err = xenbus_scanf(XBT_NIL, info->xbdev->otherend,
+ 			   "feature-split-event-channels", "%u",
+ 			   &feature_split_evtchn);
+ 	if (err < 0)
+ 		feature_split_evtchn = 0;
+ 
+ 	/* Read mac addr. */
+ 	err = xen_net_read_mac(dev, info->netdev->dev_addr);
+ 	if (err) {
+ 		xenbus_dev_fatal(dev, err, "parsing %s/mac", dev->nodename);
++>>>>>>> 50ee60611bf0 (xen-netfront: Add support for multiple queues)
  		goto out;
 -	}
 -
 -	/* Allocate array of queues */
 -	info->queues = kcalloc(num_queues, sizeof(struct netfront_queue), GFP_KERNEL);
 -	if (!info->queues) {
 -		err = -ENOMEM;
 -		goto out;
 -	}
 -	rtnl_lock();
 -	netif_set_real_num_tx_queues(info->netdev, num_queues);
 -	rtnl_unlock();
 -
 -	/* Create shared ring, alloc event channel -- for each queue */
 -	for (i = 0; i < num_queues; ++i) {
 -		queue = &info->queues[i];
 -		queue->id = i;
 -		queue->info = info;
 -		err = xennet_init_queue(queue);
 -		if (err) {
 -			/* xennet_init_queue() cleans up after itself on failure,
 -			 * but we still have to clean up any previously initialised
 -			 * queues. If i > 0, set num_queues to i, then goto
 -			 * destroy_ring, which calls xennet_disconnect_backend()
 -			 * to tidy up.
 -			 */
 -			if (i > 0) {
 -				rtnl_lock();
 -				netif_set_real_num_tx_queues(info->netdev, i);
 -				rtnl_unlock();
 -				goto destroy_ring;
 -			} else {
 -				goto out;
 -			}
 -		}
 -		err = setup_netfront(dev, queue, feature_split_evtchn);
 -		if (err) {
 -			/* As for xennet_init_queue(), setup_netfront() will tidy
 -			 * up the current queue on error, but we need to clean up
 -			 * those already allocated.
 -			 */
 -			if (i > 0) {
 -				rtnl_lock();
 -				netif_set_real_num_tx_queues(info->netdev, i);
 -				rtnl_unlock();
 -				goto destroy_ring;
 -			} else {
 -				goto out;
 -			}
 -		}
 -	}
  
  again:
  	err = xenbus_transaction_start(&xbt);
@@@ -1650,38 -1879,25 +1856,59 @@@
  		goto destroy_ring;
  	}
  
++<<<<<<< HEAD
 +	err = xenbus_printf(xbt, dev->nodename, "tx-ring-ref", "%u",
 +			    info->tx_ring_ref);
 +	if (err) {
 +		message = "writing tx ring-ref";
 +		goto abort_transaction;
 +	}
 +	err = xenbus_printf(xbt, dev->nodename, "rx-ring-ref", "%u",
 +			    info->rx_ring_ref);
 +	if (err) {
 +		message = "writing rx ring-ref";
 +		goto abort_transaction;
 +	}
 +
 +	if (info->tx_evtchn == info->rx_evtchn) {
 +		err = xenbus_printf(xbt, dev->nodename,
 +				    "event-channel", "%u", info->tx_evtchn);
 +		if (err) {
 +			message = "writing event-channel";
 +			goto abort_transaction;
 +		}
 +	} else {
 +		err = xenbus_printf(xbt, dev->nodename,
 +				    "event-channel-tx", "%u", info->tx_evtchn);
++=======
+ 	if (num_queues == 1) {
+ 		err = write_queue_xenstore_keys(&info->queues[0], &xbt, 0); /* flat */
+ 		if (err)
+ 			goto abort_transaction_no_dev_fatal;
+ 	} else {
+ 		/* Write the number of queues */
+ 		err = xenbus_printf(xbt, dev->nodename, "multi-queue-num-queues",
+ 				    "%u", num_queues);
++>>>>>>> 50ee60611bf0 (xen-netfront: Add support for multiple queues)
  		if (err) {
- 			message = "writing event-channel-tx";
- 			goto abort_transaction;
+ 			message = "writing multi-queue-num-queues";
+ 			goto abort_transaction_no_dev_fatal;
  		}
++<<<<<<< HEAD
 +		err = xenbus_printf(xbt, dev->nodename,
 +				    "event-channel-rx", "%u", info->rx_evtchn);
 +		if (err) {
 +			message = "writing event-channel-rx";
 +			goto abort_transaction;
++=======
+ 
+ 		/* Write the keys for each queue */
+ 		for (i = 0; i < num_queues; ++i) {
+ 			queue = &info->queues[i];
+ 			err = write_queue_xenstore_keys(queue, &xbt, 1); /* hierarchical */
+ 			if (err)
+ 				goto abort_transaction_no_dev_fatal;
++>>>>>>> 50ee60611bf0 (xen-netfront: Add support for multiple queues)
  		}
  	}
  
@@@ -1721,10 -1951,16 +1949,11 @@@
  	return 0;
  
   abort_transaction:
- 	xenbus_transaction_end(xbt, 1);
  	xenbus_dev_fatal(dev, err, "%s", message);
+ abort_transaction_no_dev_fatal:
+ 	xenbus_transaction_end(xbt, 1);
   destroy_ring:
  	xennet_disconnect_backend(info);
 -	kfree(info->queues);
 -	info->queues = NULL;
 -	rtnl_lock();
 -	netif_set_real_num_tx_queues(info->netdev, 0);
 -	rtnl_lock();
   out:
  	return err;
  }
* Unmerged path drivers/net/xen-netfront.c
