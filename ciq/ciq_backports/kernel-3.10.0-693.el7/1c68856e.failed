scsi: aacraid: Fix camel case

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] aacraid: Fix camel case (Scott Benesh) [1384213]
Rebuild_FUZZ: 88.46%
commit-author Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
commit 1c68856e6ea8abd714415e52ef88943c022e24f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1c68856e.failed

Replaced camel case with snake case for init supported options.

	Suggested-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
	Reviewed-by: David Carroll <David.Carroll@microsemi.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1c68856e6ea8abd714415e52ef88943c022e24f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/aacraid/linit.c
#	drivers/scsi/aacraid/src.c
diff --cc drivers/scsi/aacraid/linit.c
index 3ab2679e9b9b,ab4f1e7870b9..000000000000
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@@ -706,70 -750,165 +706,127 @@@ static int aac_eh_reset(struct scsi_cmn
  {
  	struct scsi_device * dev = cmd->device;
  	struct Scsi_Host * host = dev->host;
 -	struct aac_dev * aac = (struct aac_dev *)host->hostdata;
 +	struct scsi_cmnd * command;
  	int count;
 -	u32 bus, cid;
 -	int ret = FAILED;
 -
 -	bus = aac_logical_to_phys(scmd_channel(cmd));
 -	cid = scmd_id(cmd);
 -	if (bus < AAC_MAX_BUSES && cid < AAC_MAX_TARGETS &&
 -		aac->hba_map[bus][cid].devtype == AAC_DEVTYPE_NATIVE_RAW) {
 -		struct fib *fib;
 -		int status;
 -		u64 address;
 -		u8 command;
 -
 -		pr_err("%s: Host adapter reset request. SCSI hang ?\n",
 -			AAC_DRIVERNAME);
 -
 -		fib = aac_fib_alloc(aac);
 -		if (!fib)
 -			return ret;
 -
 -
 -		if (aac->hba_map[bus][cid].reset_state == 0) {
 -			struct aac_hba_tm_req *tmf;
 -
 -			/* start a HBA_TMF_LUN_RESET TMF request */
 -			tmf = (struct aac_hba_tm_req *)fib->hw_fib_va;
 -			memset(tmf, 0, sizeof(*tmf));
 -			tmf->tmf = HBA_TMF_LUN_RESET;
 -			tmf->it_nexus = aac->hba_map[bus][cid].rmw_nexus;
 -			tmf->lun[1] = cmd->device->lun;
 -
 -			address = (u64)fib->hw_error_pa;
 -			tmf->error_ptr_hi = cpu_to_le32
 -					((u32)(address >> 32));
 -			tmf->error_ptr_lo = cpu_to_le32
 -					((u32)(address & 0xffffffff));
 -			tmf->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);
 -			fib->hbacmd_size = sizeof(*tmf);
 -
 -			command = HBA_IU_TYPE_SCSI_TM_REQ;
 -			aac->hba_map[bus][cid].reset_state++;
 -		} else if (aac->hba_map[bus][cid].reset_state >= 1) {
 -			struct aac_hba_reset_req *rst;
 -
 -			/* already tried, start a hard reset now */
 -			rst = (struct aac_hba_reset_req *)fib->hw_fib_va;
 -			memset(rst, 0, sizeof(*rst));
 -			/* reset_type is already zero... */
 -			rst->it_nexus = aac->hba_map[bus][cid].rmw_nexus;
 -
 -			address = (u64)fib->hw_error_pa;
 -			rst->error_ptr_hi = cpu_to_le32((u32)(address >> 32));
 -			rst->error_ptr_lo = cpu_to_le32
 -				((u32)(address & 0xffffffff));
 -			rst->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);
 -			fib->hbacmd_size = sizeof(*rst);
 -
 -			command = HBA_IU_TYPE_SATA_REQ;
 -			aac->hba_map[bus][cid].reset_state = 0;
 -		}
 -		cmd->SCp.sent_command = 0;
 -
 -		status = aac_hba_send(command, fib,
 -				  (fib_callback) aac_hba_callback,
 -				  (void *) cmd);
 -
 -		/* Wait up to 2 minutes for completion */
 -		for (count = 0; count < 120; ++count) {
 -			if (cmd->SCp.sent_command) {
 -				ret = SUCCESS;
 -				break;
 -			}
 -			msleep(1000);
 -		}
 -
 -		if (ret != SUCCESS)
 -			pr_err("%s: Host adapter reset request timed out\n",
 -			AAC_DRIVERNAME);
 -	} else {
 -		struct scsi_cmnd *command;
 -		unsigned long flags;
 -
 -		/* Mark the assoc. FIB to not complete, eh handler does this */
 -		for (count = 0;
 -			count < (host->can_queue + AAC_NUM_MGT_FIB);
 -			++count) {
 -			struct fib *fib = &aac->fibs[count];
 -
 -			if (fib->hw_fib_va->header.XferState &&
 -				(fib->flags & FIB_CONTEXT_FLAG) &&
 -				(fib->callback_data == cmd)) {
 -				fib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;
 -				cmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;
 -			}
 +	struct aac_dev * aac = (struct aac_dev *)host->hostdata;
 +	unsigned long flags;
 +
 +	/* Mark the associated FIB to not complete, eh handler does this */
 +	for (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {
 +		struct fib * fib = &aac->fibs[count];
 +		if (fib->hw_fib_va->header.XferState &&
 +		  (fib->flags & FIB_CONTEXT_FLAG) &&
 +		  (fib->callback_data == cmd)) {
 +			fib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;
 +			cmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;
  		}
 -
 -		pr_err("%s: Host adapter reset request. SCSI hang ?\n",
 +	}
 +	printk(KERN_ERR "%s: Host adapter reset request. SCSI hang ?\n",
  					AAC_DRIVERNAME);
  
++<<<<<<< HEAD
 +	if ((count = aac_check_health(aac)))
 +		return count;
++=======
+ 		count = aac_check_health(aac);
+ 		if (count)
+ 			return count;
+ 		/*
+ 		 * Wait for all commands to complete to this specific
+ 		 * target (block maximum 60 seconds).
+ 		 */
+ 		for (count = 60; count; --count) {
+ 			int active = aac->in_reset;
+ 
+ 			if (active == 0)
+ 			__shost_for_each_device(dev, host) {
+ 				spin_lock_irqsave(&dev->list_lock, flags);
+ 				list_for_each_entry(command, &dev->cmd_list,
+ 					list) {
+ 					if ((command != cmd) &&
+ 					(command->SCp.phase ==
+ 					AAC_OWNER_FIRMWARE)) {
+ 						active++;
+ 						break;
+ 					}
+ 				}
+ 				spin_unlock_irqrestore(&dev->list_lock, flags);
+ 				if (active)
+ 					break;
+ 
+ 			}
+ 			/*
+ 			 * We can exit If all the commands are complete
+ 			 */
+ 			if (active == 0)
+ 				return SUCCESS;
+ 			ssleep(1);
+ 		}
+ 		pr_err("%s: SCSI bus appears hung\n", AAC_DRIVERNAME);
+ 
+ 		/*
+ 		 * This adapter needs a blind reset, only do so for
+ 		 * Adapters that support a register, instead of a commanded,
+ 		 * reset.
+ 		 */
+ 		if (((aac->supplement_adapter_info.supported_options2 &
+ 			  AAC_OPTION_MU_RESET) ||
+ 			  (aac->supplement_adapter_info.supported_options2 &
+ 			  AAC_OPTION_DOORBELL_RESET)) &&
+ 			  aac_check_reset &&
+ 			  ((aac_check_reset != 1) ||
+ 			   !(aac->supplement_adapter_info.supported_options2 &
+ 			    AAC_OPTION_IGNORE_RESET))) {
+ 			/* Bypass wait for command quiesce */
+ 			aac_reset_adapter(aac, 2, IOP_HWSOFT_RESET);
+ 		}
+ 		ret = SUCCESS;
+ 	}
++>>>>>>> 1c68856e6ea8 (scsi: aacraid: Fix camel case)
  	/*
 -	 * Cause an immediate retry of the command with a ten second delay
 -	 * after successful tur
 +	 * Wait for all commands to complete to this specific
 +	 * target (block maximum 60 seconds).
  	 */
 -	return ret;
 +	for (count = 60; count; --count) {
 +		int active = aac->in_reset;
 +
 +		if (active == 0)
 +		__shost_for_each_device(dev, host) {
 +			spin_lock_irqsave(&dev->list_lock, flags);
 +			list_for_each_entry(command, &dev->cmd_list, list) {
 +				if ((command != cmd) &&
 +				    (command->SCp.phase == AAC_OWNER_FIRMWARE)) {
 +					active++;
 +					break;
 +				}
 +			}
 +			spin_unlock_irqrestore(&dev->list_lock, flags);
 +			if (active)
 +				break;
 +
 +		}
 +		/*
 +		 * We can exit If all the commands are complete
 +		 */
 +		if (active == 0)
 +			return SUCCESS;
 +		ssleep(1);
 +	}
 +	printk(KERN_ERR "%s: SCSI bus appears hung\n", AAC_DRIVERNAME);
 +	/*
 +	 * This adapter needs a blind reset, only do so for Adapters that
 +	 * support a register, instead of a commanded, reset.
 +	 */
 +	if (((aac->supplement_adapter_info.SupportedOptions2 &
 +	  AAC_OPTION_MU_RESET) ||
 +	  (aac->supplement_adapter_info.SupportedOptions2 &
 +	  AAC_OPTION_DOORBELL_RESET)) &&
 +	  aac_check_reset &&
 +	  ((aac_check_reset != 1) ||
 +	   !(aac->supplement_adapter_info.SupportedOptions2 &
 +	    AAC_OPTION_IGNORE_RESET)))
 +		aac_reset_adapter(aac, 2); /* Bypass wait for command quiesce */
 +	return SUCCESS; /* Cause an immediate retry of the command with a ten second delay after successful tur */
  }
  
  /**
diff --cc drivers/scsi/aacraid/src.c
index d48e0ad56e25,c17b0603749c..000000000000
--- a/drivers/scsi/aacraid/src.c
+++ b/drivers/scsi/aacraid/src.c
@@@ -578,40 -670,87 +578,85 @@@ static int aac_src_restart_adapter(stru
  {
  	u32 var, reset_mask;
  
++<<<<<<< HEAD
 +	if (bled >= 0) {
 +		if (bled)
 +			printk(KERN_ERR "%s%d: adapter kernel panic'd %x.\n",
++=======
+ 	bled = aac_adapter_sync_cmd(dev, IOP_RESET_ALWAYS,
+ 				    0, 0, 0, 0, 0, 0, &var,
+ 				    &reset_mask, NULL, NULL, NULL);
+ 
+ 	if ((bled || var != 0x00000001) && !dev->doorbell_mask)
+ 		bled = -EINVAL;
+ 	else if (dev->doorbell_mask) {
+ 		reset_mask = dev->doorbell_mask;
+ 		bled = 0;
+ 		var = 0x00000001;
+ 	}
+ 
+ 	aac_set_intx_mode(dev);
+ 
+ 	if (!bled && (dev->supplement_adapter_info.supported_options2 &
+ 	    AAC_OPTION_DOORBELL_RESET)) {
+ 		src_writel(dev, MUnit.IDR, reset_mask);
+ 	} else {
+ 		src_writel(dev, MUnit.IDR, 0x100);
+ 	}
+ 	msleep(30000);
+ }
+ 
+ static void aac_send_hardware_soft_reset(struct aac_dev *dev)
+ {
+ 	u_int32_t val;
+ 
+ 	val = readl(((char *)(dev->base) + IBW_SWR_OFFSET));
+ 	val |= 0x01;
+ 	writel(val, ((char *)(dev->base) + IBW_SWR_OFFSET));
+ 	msleep_interruptible(20000);
+ }
+ 
+ static int aac_src_restart_adapter(struct aac_dev *dev, int bled, u8 reset_type)
+ {
+ 	unsigned long status, start;
+ 
+ 	if (bled < 0)
+ 		goto invalid_out;
+ 
+ 	if (bled)
+ 		pr_err("%s%d: adapter kernel panic'd %x.\n",
++>>>>>>> 1c68856e6ea8 (scsi: aacraid: Fix camel case)
  				dev->name, dev->id, bled);
 +		dev->a_ops.adapter_enable_int = aac_src_disable_interrupt;
 +		bled = aac_adapter_sync_cmd(dev, IOP_RESET_ALWAYS,
 +			0, 0, 0, 0, 0, 0, &var, &reset_mask, NULL, NULL, NULL);
 +		if ((bled || (var != 0x00000001)) &&
 +		    !dev->doorbell_mask)
 +			return -EINVAL;
 +		else if (dev->doorbell_mask) {
 +			reset_mask = dev->doorbell_mask;
 +			bled = 0;
 +			var = 0x00000001;
 +		}
  
 -	dev->a_ops.adapter_enable_int = aac_src_disable_interrupt;
 -
 -	switch (reset_type) {
 -	case IOP_HWSOFT_RESET:
 -		aac_send_iop_reset(dev, bled);
 -		/*
 -		 * Check to see if KERNEL_UP_AND_RUNNING
 -		 * Wait for the adapter to be up and running.
 -		 * If !KERNEL_UP_AND_RUNNING issue HW Soft Reset
 -		 */
 -		status = src_readl(dev, MUnit.OMR);
 -		if (dev->sa_firmware
 -		 && !(status & KERNEL_UP_AND_RUNNING)) {
 -			start = jiffies;
 -			do {
 -				status = src_readl(dev, MUnit.OMR);
 -				if (time_after(jiffies,
 -				 start+HZ*SOFT_RESET_TIME)) {
 -					aac_send_hardware_soft_reset(dev);
 -					start = jiffies;
 -				}
 -			} while (!(status & KERNEL_UP_AND_RUNNING));
 +		if ((dev->pdev->device == PMC_DEVICE_S7 ||
 +		    dev->pdev->device == PMC_DEVICE_S8 ||
 +		    dev->pdev->device == PMC_DEVICE_S9) && dev->msi_enabled) {
 +			aac_src_access_devreg(dev, AAC_ENABLE_INTX);
 +			dev->msi_enabled = 0;
 +			msleep(5000); /* Delay 5 seconds */
  		}
 -		break;
 -	case HW_SOFT_RESET:
 -		if (dev->sa_firmware) {
 -			aac_send_hardware_soft_reset(dev);
 -			aac_set_intx_mode(dev);
 +
 +		if (!bled && (dev->supplement_adapter_info.SupportedOptions2 &
 +		    AAC_OPTION_DOORBELL_RESET)) {
 +			src_writel(dev, MUnit.IDR, reset_mask);
 +			ssleep(45);
 +		} else {
 +			src_writel(dev, MUnit.IDR, 0x100);
 +			ssleep(45);
  		}
 -		break;
 -	default:
 -		aac_send_iop_reset(dev, bled);
 -		break;
  	}
  
 -invalid_out:
 -
  	if (src_readl(dev, MUnit.OMR) & KERNEL_PANIC)
  		return -ENODEV;
  
diff --git a/drivers/scsi/aacraid/aachba.c b/drivers/scsi/aacraid/aachba.c
index e231ab46407a..289a657e2606 100644
--- a/drivers/scsi/aacraid/aachba.c
+++ b/drivers/scsi/aacraid/aachba.c
@@ -483,7 +483,7 @@ int aac_get_containers(struct aac_dev *dev)
 	if (status >= 0) {
 		dresp = (struct aac_get_container_count_resp *)fib_data(fibptr);
 		maximum_num_containers = le32_to_cpu(dresp->ContainerSwitchEntries);
-		if (fibptr->dev->supplement_adapter_info.SupportedOptions2 &
+		if (fibptr->dev->supplement_adapter_info.supported_options2 &
 		    AAC_OPTION_SUPPORTED_240_VOLUMES) {
 			maximum_num_containers =
 				le32_to_cpu(dresp->MaxSimpleVolumes);
@@ -635,13 +635,16 @@ static void _aac_probe_container2(void * context, struct fib * fibptr)
 	fsa_dev_ptr = fibptr->dev->fsa_dev;
 	if (fsa_dev_ptr) {
 		struct aac_mount * dresp = (struct aac_mount *) fib_data(fibptr);
+		__le32 sup_options2;
+
 		fsa_dev_ptr += scmd_id(scsicmd);
+		sup_options2 =
+			fibptr->dev->supplement_adapter_info.supported_options2;
 
 		if ((le32_to_cpu(dresp->status) == ST_OK) &&
 		    (le32_to_cpu(dresp->mnt[0].vol) != CT_NONE) &&
 		    (le32_to_cpu(dresp->mnt[0].state) != FSCS_HIDDEN)) {
-			if (!(fibptr->dev->supplement_adapter_info.SupportedOptions2 &
-			    AAC_OPTION_VARIABLE_BLOCK_SIZE)) {
+			if (!(sup_options2 & AAC_OPTION_VARIABLE_BLOCK_SIZE)) {
 				dresp->mnt[0].fileinfo.bdevinfo.block_size = 0x200;
 				fsa_dev_ptr->block_size = 0x200;
 			} else {
@@ -684,7 +687,7 @@ static void _aac_probe_container1(void * context, struct fib * fibptr)
 	int status;
 
 	dresp = (struct aac_mount *) fib_data(fibptr);
-	if (!(fibptr->dev->supplement_adapter_info.SupportedOptions2 &
+	if (!(fibptr->dev->supplement_adapter_info.supported_options2 &
 	    AAC_OPTION_VARIABLE_BLOCK_SIZE))
 		dresp->mnt[0].capacityhigh = 0;
 	if ((le32_to_cpu(dresp->status) != ST_OK) ||
@@ -701,7 +704,7 @@ static void _aac_probe_container1(void * context, struct fib * fibptr)
 
 	dinfo = (struct aac_query_mount *)fib_data(fibptr);
 
-	if (fibptr->dev->supplement_adapter_info.SupportedOptions2 &
+	if (fibptr->dev->supplement_adapter_info.supported_options2 &
 	    AAC_OPTION_VARIABLE_BLOCK_SIZE)
 		dinfo->command = cpu_to_le32(VM_NameServeAllBlk);
 	else
@@ -741,7 +744,7 @@ static int _aac_probe_container(struct scsi_cmnd * scsicmd, int (*callback)(stru
 
 		dinfo = (struct aac_query_mount *)fib_data(fibptr);
 
-		if (fibptr->dev->supplement_adapter_info.SupportedOptions2 &
+		if (fibptr->dev->supplement_adapter_info.supported_options2 &
 		    AAC_OPTION_VARIABLE_BLOCK_SIZE)
 			dinfo->command = cpu_to_le32(VM_NameServeAllBlk);
 		else
@@ -892,12 +895,14 @@ char * get_container_type(unsigned tindex)
 static void setinqstr(struct aac_dev *dev, void *data, int tindex)
 {
 	struct scsi_inq *str;
+	struct aac_supplement_adapter_info *sup_adap_info;
 
+	sup_adap_info = &dev->supplement_adapter_info;
 	str = (struct scsi_inq *)(data); /* cast data to scsi inq block */
 	memset(str, ' ', sizeof(*str));
 
-	if (dev->supplement_adapter_info.AdapterTypeText[0]) {
-		char * cp = dev->supplement_adapter_info.AdapterTypeText;
+	if (sup_adap_info->adapter_type_text[0]) {
+		char *cp = sup_adap_info->adapter_type_text;
 		int c;
 		if ((cp[0] == 'A') && (cp[1] == 'O') && (cp[2] == 'C'))
 			inqstrcpy("SMC", str->vid);
@@ -907,8 +912,7 @@ static void setinqstr(struct aac_dev *dev, void *data, int tindex)
 				++cp;
 			c = *cp;
 			*cp = '\0';
-			inqstrcpy (dev->supplement_adapter_info.AdapterTypeText,
-				   str->vid);
+			inqstrcpy(sup_adap_info->adapter_type_text, str->vid);
 			*cp = c;
 			while (*cp && *cp != ' ')
 				++cp;
@@ -1671,8 +1675,8 @@ int aac_issue_bmic_identify(struct aac_dev *dev, u32 bus, u32 target)
 	if (!identify_resp)
 		goto fib_free_ptr;
 
-	vbus = (u32)le16_to_cpu(dev->supplement_adapter_info.VirtDeviceBus);
-	vid = (u32)le16_to_cpu(dev->supplement_adapter_info.VirtDeviceTarget);
+	vbus = (u32)le16_to_cpu(dev->supplement_adapter_info.virt_device_bus);
+	vid = (u32)le16_to_cpu(dev->supplement_adapter_info.virt_device_target);
 
 	aac_fib_init(fibptr);
 
@@ -1811,9 +1815,9 @@ int aac_report_phys_luns(struct aac_dev *dev, struct fib *fibptr, int rescan)
 	}
 
 	vbus = (u32) le16_to_cpu(
-			dev->supplement_adapter_info.VirtDeviceBus);
+			dev->supplement_adapter_info.virt_device_bus);
 	vid = (u32) le16_to_cpu(
-			dev->supplement_adapter_info.VirtDeviceTarget);
+			dev->supplement_adapter_info.virt_device_target);
 
 	aac_fib_init(fibptr);
 
@@ -1889,7 +1893,7 @@ int aac_get_adapter_info(struct aac_dev* dev)
 	}
 	memcpy(&dev->adapter_info, info, sizeof(*info));
 
-	dev->supplement_adapter_info.VirtDeviceBus = 0xffff;
+	dev->supplement_adapter_info.virt_device_bus = 0xffff;
 	if (dev->adapter_info.options & AAC_OPT_SUPPLEMENT_ADAPTER_INFO) {
 		struct aac_supplement_adapter_info * sinfo;
 
@@ -1957,7 +1961,7 @@ int aac_get_adapter_info(struct aac_dev* dev)
 	}
 
 	if (!dev->sync_mode && dev->sa_firmware &&
-			dev->supplement_adapter_info.VirtDeviceBus != 0xffff) {
+		dev->supplement_adapter_info.virt_device_bus != 0xffff) {
 		/* Thor SA Firmware -> CISS_REPORT_PHYSICAL_LUNS */
 		rcode = aac_report_phys_luns(dev, fibptr, AAC_INIT);
 	}
@@ -1972,8 +1976,8 @@ int aac_get_adapter_info(struct aac_dev* dev)
 			(tmp>>16)&0xff,
 			tmp&0xff,
 			le32_to_cpu(dev->adapter_info.kernelbuild),
-			(int)sizeof(dev->supplement_adapter_info.BuildDate),
-			dev->supplement_adapter_info.BuildDate);
+			(int)sizeof(dev->supplement_adapter_info.build_date),
+			dev->supplement_adapter_info.build_date);
 		tmp = le32_to_cpu(dev->adapter_info.monitorrev);
 		printk(KERN_INFO "%s%d: monitor %d.%d-%d[%d]\n",
 			dev->name, dev->id,
@@ -1989,14 +1993,15 @@ int aac_get_adapter_info(struct aac_dev* dev)
 		  shost_to_class(dev->scsi_host_ptr), buffer))
 			printk(KERN_INFO "%s%d: serial %s",
 			  dev->name, dev->id, buffer);
-		if (dev->supplement_adapter_info.VpdInfo.Tsid[0]) {
+		if (dev->supplement_adapter_info.vpd_info.tsid[0]) {
 			printk(KERN_INFO "%s%d: TSID %.*s\n",
 			  dev->name, dev->id,
-			  (int)sizeof(dev->supplement_adapter_info.VpdInfo.Tsid),
-			  dev->supplement_adapter_info.VpdInfo.Tsid);
+			  (int)sizeof(dev->supplement_adapter_info
+							.vpd_info.tsid),
+				dev->supplement_adapter_info.vpd_info.tsid);
 		}
 		if (!aac_check_reset || ((aac_check_reset == 1) &&
-		  (dev->supplement_adapter_info.SupportedOptions2 &
+		  (dev->supplement_adapter_info.supported_options2 &
 		  AAC_OPTION_IGNORE_RESET))) {
 			printk(KERN_INFO "%s%d: Reset Adapter Ignored\n",
 			  dev->name, dev->id);
@@ -2004,7 +2009,7 @@ int aac_get_adapter_info(struct aac_dev* dev)
 	}
 
 	dev->cache_protected = 0;
-	dev->jbod = ((dev->supplement_adapter_info.FeatureBits &
+	dev->jbod = ((dev->supplement_adapter_info.feature_bits &
 		AAC_FEATURE_JBOD) != 0);
 	dev->nondasd_support = 0;
 	dev->raid_scsi_mode = 0;
@@ -2627,7 +2632,7 @@ static int aac_start_stop(struct scsi_cmnd *scsicmd)
 	struct scsi_device *sdev = scsicmd->device;
 	struct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;
 
-	if (!(aac->supplement_adapter_info.SupportedOptions2 &
+	if (!(aac->supplement_adapter_info.supported_options2 &
 	      AAC_OPTION_POWER_MANAGEMENT)) {
 		scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |
 				  SAM_STAT_GOOD;
diff --git a/drivers/scsi/aacraid/aacraid.h b/drivers/scsi/aacraid/aacraid.h
index 12890356f33d..aa79bed5e4cf 100644
--- a/drivers/scsi/aacraid/aacraid.h
+++ b/drivers/scsi/aacraid/aacraid.h
@@ -1187,57 +1187,57 @@ struct aac_adapter_info
 
 struct aac_supplement_adapter_info
 {
-	u8	AdapterTypeText[17+1];
-	u8	Pad[2];
-	__le32	FlashMemoryByteSize;
-	__le32	FlashImageId;
-	__le32	MaxNumberPorts;
-	__le32	Version;
-	__le32	FeatureBits;
-	u8	SlotNumber;
-	u8	ReservedPad0[3];
-	u8	BuildDate[12];
-	__le32	CurrentNumberPorts;
+	u8	adapter_type_text[17+1];
+	u8	pad[2];
+	__le32	flash_memory_byte_size;
+	__le32	flash_image_id;
+	__le32	max_number_ports;
+	__le32	version;
+	__le32	feature_bits;
+	u8	slot_number;
+	u8	reserved_pad0[3];
+	u8	build_date[12];
+	__le32	current_number_ports;
 	struct {
-		u8	AssemblyPn[8];
-		u8	FruPn[8];
-		u8	BatteryFruPn[8];
-		u8	EcVersionString[8];
-		u8	Tsid[12];
-	}	VpdInfo;
-	__le32	FlashFirmwareRevision;
-	__le32	FlashFirmwareBuild;
-	__le32	RaidTypeMorphOptions;
-	__le32	FlashFirmwareBootRevision;
-	__le32	FlashFirmwareBootBuild;
-	u8	MfgPcbaSerialNo[12];
-	u8	MfgWWNName[8];
-	__le32	SupportedOptions2;
-	__le32	StructExpansion;
+		u8	assembly_pn[8];
+		u8	fru_pn[8];
+		u8	battery_fru_pn[8];
+		u8	ec_version_string[8];
+		u8	tsid[12];
+	}	vpd_info;
+	__le32	flash_firmware_revision;
+	__le32	flash_firmware_build;
+	__le32	raid_type_morph_options;
+	__le32	flash_firmware_boot_revision;
+	__le32	flash_firmware_boot_build;
+	u8	mfg_pcba_serial_no[12];
+	u8	mfg_wwn_name[8];
+	__le32	supported_options2;
+	__le32	struct_expansion;
 	/* StructExpansion == 1 */
-	__le32	FeatureBits3;
-	__le32	SupportedPerformanceModes;
-	u8	HostBusType;		/* uses HOST_BUS_TYPE_xxx defines */
-	u8	HostBusWidth;		/* actual width in bits or links */
-	u16	HostBusSpeed;		/* actual bus speed/link rate in MHz */
-	u8	MaxRRCDrives;		/* max. number of ITP-RRC drives/pool */
-	u8	MaxDiskXtasks;		/* max. possible num of DiskX Tasks */
-
-	u8	CpldVerLoaded;
-	u8	CpldVerInFlash;
-
-	__le64	MaxRRCCapacity;
-	__le32	CompiledMaxHistLogLevel;
-	u8	CustomBoardName[12];
-	u16	SupportedCntlrMode;	/* identify supported controller mode */
-	u16	ReservedForFuture16;
-	__le32	SupportedOptions3;	/* reserved for future options */
-
-	__le16	VirtDeviceBus;		/* virt. SCSI device for Thor */
-	__le16	VirtDeviceTarget;
-	__le16	VirtDeviceLUN;
-	__le16	Unused;
-	__le32	ReservedForFutureGrowth[68];
+	__le32	feature_bits3;
+	__le32	supported_performance_modes;
+	u8	host_bus_type;		/* uses HOST_BUS_TYPE_xxx defines */
+	u8	host_bus_width;		/* actual width in bits or links */
+	u16	host_bus_speed;		/* actual bus speed/link rate in MHz */
+	u8	max_rrc_drives;		/* max. number of ITP-RRC drives/pool */
+	u8	max_disk_xtasks;	/* max. possible num of DiskX Tasks */
+
+	u8	cpld_ver_loaded;
+	u8	cpld_ver_in_flash;
+
+	__le64	max_rrc_capacity;
+	__le32	compiled_max_hist_log_level;
+	u8	custom_board_name[12];
+	u16	supported_cntlr_mode;	/* identify supported controller mode */
+	u16	reserved_for_future16;
+	__le32	supported_options3;	/* reserved for future options */
+
+	__le16	virt_device_bus;		/* virt. SCSI device for Thor */
+	__le16	virt_device_target;
+	__le16	virt_device_lun;
+	__le16	unused;
+	__le32	reserved_for_future_growth[68];
 
 };
 #define AAC_FEATURE_FALCON	cpu_to_le32(0x00000010)
diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c
index 8317949d1445..aeb212788bed 100644
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -1710,7 +1710,7 @@ int aac_check_health(struct aac_dev * aac)
 	printk(KERN_ERR "%s: Host adapter BLINK LED 0x%x\n", aac->name, BlinkLED);
 
 	if (!aac_check_reset || ((aac_check_reset == 1) &&
-		(aac->supplement_adapter_info.SupportedOptions2 &
+		(aac->supplement_adapter_info.supported_options2 &
 			AAC_OPTION_IGNORE_RESET)))
 		goto out;
 	host = aac->scsi_host_ptr;
@@ -2158,8 +2158,8 @@ static int aac_send_wellness_command(struct aac_dev *dev, char *wellness_str,
 
 	aac_fib_init(fibptr);
 
-	vbus = (u32)le16_to_cpu(dev->supplement_adapter_info.VirtDeviceBus);
-	vid = (u32)le16_to_cpu(dev->supplement_adapter_info.VirtDeviceTarget);
+	vbus = (u32)le16_to_cpu(dev->supplement_adapter_info.virt_device_bus);
+	vid = (u32)le16_to_cpu(dev->supplement_adapter_info.virt_device_target);
 
 	srbcmd = (struct aac_srb *)fib_data(fibptr);
 
* Unmerged path drivers/scsi/aacraid/linit.c
diff --git a/drivers/scsi/aacraid/rx.c b/drivers/scsi/aacraid/rx.c
index a9e1ad191e5a..00b41eccdc32 100644
--- a/drivers/scsi/aacraid/rx.c
+++ b/drivers/scsi/aacraid/rx.c
@@ -475,7 +475,7 @@ static int aac_rx_restart_adapter(struct aac_dev *dev, int bled)
 {
 	u32 var = 0;
 
-	if (!(dev->supplement_adapter_info.SupportedOptions2 &
+	if (!(dev->supplement_adapter_info.supported_options2 &
 	  AAC_OPTION_MU_RESET) || (bled >= 0) || (bled == -2)) {
 		if (bled)
 			printk(KERN_ERR "%s%d: adapter kernel panic'd %x.\n",
* Unmerged path drivers/scsi/aacraid/src.c
