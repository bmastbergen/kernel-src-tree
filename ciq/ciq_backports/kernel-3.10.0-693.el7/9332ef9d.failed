scripts/spelling.txt: add "an user" pattern and fix typo instances

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Masahiro Yamada <yamada.masahiro@socionext.com>
commit 9332ef9dbd172d4ab0a0141df7cb21c696a5ce96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9332ef9d.failed

Fix typos and add the following to the scripts/spelling.txt:

  an user||a user
  an userspace||a userspace

I also added "userspace" to the list since it is a common word in Linux.
I found some instances for "an userfaultfd", but I did not add it to the
list.  I felt it is endless to find words that start with "user" such as
"userland" etc., so must draw a line somewhere.

Link: http://lkml.kernel.org/r/1481573103-11329-4-git-send-email-yamada.masahiro@socionext.com
	Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9332ef9dbd172d4ab0a0141df7cb21c696a5ce96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/ras.rst
#	Documentation/devicetree/bindings/opp/opp.txt
#	Documentation/dvb/ci.txt
#	Documentation/kselftest.txt
#	Documentation/networking/cdc_mbim.txt
#	drivers/media/dvb-core/dvb_ringbuffer.h
#	kernel/irq/manage.c
#	net/bluetooth/hci_sock.c
#	scripts/spelling.txt
diff --cc Documentation/dvb/ci.txt
index 6c3bda50f7dc,69b07e9d1816..000000000000
--- a/Documentation/dvb/ci.txt
+++ b/Documentation/dvb/ci.txt
@@@ -1,21 -1,30 +1,32 @@@
 -Digital TV Conditional Access Interface (CI API)
 -================================================
 -
 -
 -.. note::
 -
 -   This documentation is outdated.
 -
 -This document describes the usage of the high level CI API as
 +* For the user
 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 +NOTE: This document describes the usage of the high level CI API as
  in accordance to the Linux DVB API. This is a not a documentation for the,
  existing low level CI API.
 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
 -.. note::
 +To utilize the High Level CI capabilities,
  
 -   For the Twinhan/Twinhan clones, the dst_ca module handles the CI
 -   hardware handling.This module is loaded automatically if a CI
 -   (Common Interface, that holds the CAM (Conditional Access Module)
 -   is detected.
 +(1*) This point is valid only for the Twinhan/clones
 +  For the Twinhan/Twinhan clones, the dst_ca module handles the CI
 +  hardware handling.This module is loaded automatically if a CI
 +  (Common Interface, that holds the CAM (Conditional Access Module)
 +  is detected.
  
++<<<<<<< HEAD:Documentation/dvb/ci.txt
 +(2) one requires a userspace application, ca_zap. This small userland
 +  application is in charge of sending the descrambling related information
 +  to the CAM.
++=======
+ ca_zap
+ ~~~~~~
+ 
+ A userspace application, like ``ca_zap`` is required to handle encrypted
+ MPEG-TS streams.
+ 
+ The ``ca_zap`` userland application is in charge of sending the
+ descrambling related information to the Conditional Access Module (CAM).
++>>>>>>> 9332ef9dbd17 (scripts/spelling.txt: add "an user" pattern and fix typo instances):Documentation/media/dvb-drivers/ci.rst
  
  This application requires the following to function properly as of now.
  
diff --cc drivers/media/dvb-core/dvb_ringbuffer.h
index 41f04dae69b6,8ed6bcc3a56e..000000000000
--- a/drivers/media/dvb-core/dvb_ringbuffer.h
+++ b/drivers/media/dvb-core/dvb_ringbuffer.h
@@@ -43,79 -51,116 +43,94 @@@ struct dvb_ringbuffer 
  
  #define DVB_RINGBUFFER_PKTHDRSIZE 3
  
 -/**
 - * dvb_ringbuffer_init - initialize ring buffer, lock and queue
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - * @data: pointer to the buffer where the data will be stored
 - * @len: bytes from ring buffer into @buf
 - */
 -extern void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data,
 -				size_t len);
  
 -/**
 - * dvb_ringbuffer_empty - test whether buffer is empty
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - */
 +/*
 +** Notes:
 +** ------
 +** (1) For performance reasons read and write routines don't check buffer sizes
 +**     and/or number of bytes free/available. This has to be done before these
 +**     routines are called. For example:
 +**
 +**     *** write <buflen> bytes ***
 +**     free = dvb_ringbuffer_free(rbuf);
 +**     if (free >= buflen)
 +**         count = dvb_ringbuffer_write(rbuf, buffer, buflen);
 +**     else
 +**         ...
 +**
 +**     *** read min. 1000, max. <bufsize> bytes ***
 +**     avail = dvb_ringbuffer_avail(rbuf);
 +**     if (avail >= 1000)
 +**         count = dvb_ringbuffer_read(rbuf, buffer, min(avail, bufsize));
 +**     else
 +**         ...
 +**
 +** (2) If there is exactly one reader and one writer, there is no need
 +**     to lock read or write operations.
 +**     Two or more readers must be locked against each other.
 +**     Flushing the buffer counts as a read operation.
 +**     Resetting the buffer counts as a read and write operation.
 +**     Two or more writers must be locked against each other.
 +*/
 +
 +/* initialize ring buffer, lock and queue */
 +extern void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len);
 +
 +/* test whether buffer is empty */
  extern int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf);
  
 -/**
 - * dvb_ringbuffer_free - returns the number of free bytes in the buffer
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - *
 - * Return: number of free bytes in the buffer
 - */
 +/* return the number of free bytes in the buffer */
  extern ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf);
  
 -/**
 - * dvb_ringbuffer_avail - returns the number of bytes waiting in the buffer
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - *
 - * Return: number of bytes waiting in the buffer
 - */
 +/* return the number of bytes waiting in the buffer */
  extern ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf);
  
 -/**
 - * dvb_ringbuffer_reset - resets the ringbuffer to initial state
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - *
 - * Resets the read and write pointers to zero and flush the buffer.
 - *
 - * This counts as a read and write operation
 - */
 -extern void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf);
  
  /*
 - * read routines & macros
 - */
 +** Reset the read and write pointers to zero and flush the buffer
 +** This counts as a read and write operation
 +*/
 +extern void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf);
  
 -/**
 - * dvb_ringbuffer_flush - flush buffer
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - */
 +
 +/* read routines & macros */
 +/* ---------------------- */
 +/* flush buffer */
  extern void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf);
  
 -/**
 - * dvb_ringbuffer_flush_spinlock_wakeup- flush buffer protected by spinlock
 - *      and wake-up waiting task(s)
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - */
 +/* flush buffer protected by spinlock and wake-up waiting task(s) */
  extern void dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf);
  
 -/**
 - * DVB_RINGBUFFER_PEEK - peek at byte @offs in the buffer
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - * @offs: offset inside the ringbuffer
 - */
 -#define DVB_RINGBUFFER_PEEK(rbuf, offs)	\
 -			((rbuf)->data[((rbuf)->pread + (offs)) % (rbuf)->size])
 +/* peek at byte <offs> in the buffer */
 +#define DVB_RINGBUFFER_PEEK(rbuf,offs)	\
 +			(rbuf)->data[((rbuf)->pread+(offs))%(rbuf)->size]
  
 -/**
 - * DVB_RINGBUFFER_SKIP - advance read ptr by @num bytes
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - * @num: number of bytes to advance
 - */
 -#define DVB_RINGBUFFER_SKIP(rbuf, num)	{\
 -			(rbuf)->pread = ((rbuf)->pread + (num)) % (rbuf)->size;\
 -}
 +/* advance read ptr by <num> bytes */
 +#define DVB_RINGBUFFER_SKIP(rbuf,num)	\
 +			(rbuf)->pread=((rbuf)->pread+(num))%(rbuf)->size
  
++<<<<<<< HEAD
 +/*
 +** read <len> bytes from ring buffer into <buf>
 +** <usermem> specifies whether <buf> resides in user space
 +** returns number of bytes transferred or -EFAULT
 +*/
++=======
+ /**
+  * dvb_ringbuffer_read_user - Reads a buffer into a user pointer
+  *
+  * @rbuf: pointer to struct dvb_ringbuffer
+  * @buf: pointer to the buffer where the data will be stored
+  * @len: bytes from ring buffer into @buf
+  *
+  * This variant assumes that the buffer is a memory at the userspace. So,
+  * it will internally call copy_to_user().
+  *
+  * Return: number of bytes transferred or -EFAULT
+  */
++>>>>>>> 9332ef9dbd17 (scripts/spelling.txt: add "an user" pattern and fix typo instances)
  extern ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf,
  				   u8 __user *buf, size_t len);
 -
 -/**
 - * dvb_ringbuffer_read - Reads a buffer into a pointer
 - *
 - * @rbuf: pointer to struct dvb_ringbuffer
 - * @buf: pointer to the buffer where the data will be stored
 - * @len: bytes from ring buffer into @buf
 - *
 - * This variant assumes that the buffer is a memory at the Kernel space
 - *
 - * Return: number of bytes transferred or -EFAULT
 - */
  extern void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf,
  				   u8 *buf, size_t len);
  
@@@ -134,16 -192,31 +149,33 @@@
  extern ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf,
  				    size_t len);
  
++<<<<<<< HEAD
++=======
+ /**
+  * dvb_ringbuffer_write_user - Writes a buffer received via a user pointer
+  *
+  * @rbuf: pointer to struct dvb_ringbuffer
+  * @buf: pointer to the buffer where the data will be read
+  * @len: bytes from ring buffer into @buf
+  *
+  * This variant assumes that the buffer is a memory at the userspace. So,
+  * it will internally call copy_from_user().
+  *
+  * Return: number of bytes transferred or -EFAULT
+  */
+ extern ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,
+ 					 const u8 __user *buf, size_t len);
++>>>>>>> 9332ef9dbd17 (scripts/spelling.txt: add "an user" pattern and fix typo instances)
  
  /**
 - * dvb_ringbuffer_pkt_write - Write a packet into the ringbuffer.
 + * Write a packet into the ringbuffer.
   *
 - * @rbuf: Ringbuffer to write to.
 - * @buf: Buffer to write.
 - * @len: Length of buffer (currently limited to 65535 bytes max).
 - *
 - * Return: Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.
 + * <rbuf> Ringbuffer to write to.
 + * <buf> Buffer to write.
 + * <len> Length of buffer (currently limited to 65535 bytes max).
 + * returns Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.
   */
 -extern ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8 *buf,
 +extern ssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf,
  					size_t len);
  
  /**
diff --cc kernel/irq/manage.c
index 90f4309c2057,944d068b6c48..000000000000
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@@ -329,13 -353,14 +329,18 @@@ setup_affinity(unsigned int irq, struc
  		return 0;
  
  	/*
++<<<<<<< HEAD
 +	 * Preserve an userspace affinity setup, but make sure that
 +	 * one of the targets is online.
++=======
+ 	 * Preserve the managed affinity setting and a userspace affinity
+ 	 * setup, but make sure that one of the targets is online.
++>>>>>>> 9332ef9dbd17 (scripts/spelling.txt: add "an user" pattern and fix typo instances)
  	 */
 -	if (irqd_affinity_is_managed(&desc->irq_data) ||
 -	    irqd_has_set(&desc->irq_data, IRQD_AFFINITY_SET)) {
 -		if (cpumask_intersects(desc->irq_common_data.affinity,
 +	if (irqd_has_set(&desc->irq_data, IRQD_AFFINITY_SET)) {
 +		if (cpumask_intersects(desc->irq_data.affinity,
  				       cpu_online_mask))
 -			set = desc->irq_common_data.affinity;
 +			set = desc->irq_data.affinity;
  		else
  			irqd_clear(&desc->irq_data, IRQD_AFFINITY_SET);
  	}
diff --cc net/bluetooth/hci_sock.c
index 6d1d0e526ce6,f64d6566021f..000000000000
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@@ -884,9 -1185,38 +884,32 @@@ static int hci_sock_bind(struct socket 
  			}
  		}
  
++<<<<<<< HEAD
 +		atomic_inc(&hdev->promisc);
++=======
+ 		hci_pi(sk)->channel = haddr.hci_channel;
+ 
+ 		if (!hci_sock_gen_cookie(sk)) {
+ 			/* In the case when a cookie has already been assigned,
+ 			 * this socket will transition from a raw socket into
+ 			 * a user channel socket. For a clean transition, send
+ 			 * the close notification first.
+ 			 */
+ 			skb = create_monitor_ctrl_close(sk);
+ 			if (skb) {
+ 				hci_send_to_channel(HCI_CHANNEL_MONITOR, skb,
+ 						    HCI_SOCK_TRUSTED, NULL);
+ 				kfree_skb(skb);
+ 			}
+ 		}
+ 
+ 		/* The user channel is restricted to CAP_NET_ADMIN
+ 		 * capabilities and with that implicitly trusted.
+ 		 */
+ 		hci_sock_set_flag(sk, HCI_SOCK_TRUSTED);
++>>>>>>> 9332ef9dbd17 (scripts/spelling.txt: add "an user" pattern and fix typo instances)
  
  		hci_pi(sk)->hdev = hdev;
 -
 -		/* Send event to monitor */
 -		skb = create_monitor_ctrl_open(sk);
 -		if (skb) {
 -			hci_send_to_channel(HCI_CHANNEL_MONITOR, skb,
 -					    HCI_SOCK_TRUSTED, NULL);
 -			kfree_skb(skb);
 -		}
 -
 -		atomic_inc(&hdev->promisc);
  		break;
  
  	case HCI_CHANNEL_MONITOR:
* Unmerged path Documentation/admin-guide/ras.rst
* Unmerged path Documentation/devicetree/bindings/opp/opp.txt
* Unmerged path Documentation/kselftest.txt
* Unmerged path Documentation/networking/cdc_mbim.txt
* Unmerged path scripts/spelling.txt
* Unmerged path Documentation/admin-guide/ras.rst
* Unmerged path Documentation/devicetree/bindings/opp/opp.txt
* Unmerged path Documentation/dvb/ci.txt
diff --git a/Documentation/filesystems/quota.txt b/Documentation/filesystems/quota.txt
index 5e8de25bf0f1..9d8580d2f493 100644
--- a/Documentation/filesystems/quota.txt
+++ b/Documentation/filesystems/quota.txt
@@ -6,7 +6,7 @@ Quota subsystem allows system administrator to set limits on used space and
 number of used inodes (inode is a filesystem structure which is associated with
 each file or directory) for users and/or groups. For both used space and number
 of used inodes there are actually two limits. The first one is called softlimit
-and the second one hardlimit.  An user can never exceed a hardlimit for any
+and the second one hardlimit.  A user can never exceed a hardlimit for any
 resource (unless he has CAP_SYS_RESOURCE capability). User is allowed to exceed
 softlimit but only for limited period of time. This period is called "grace
 period" or "grace time". When grace time is over, user is not able to allocate
* Unmerged path Documentation/kselftest.txt
* Unmerged path Documentation/networking/cdc_mbim.txt
diff --git a/Documentation/vm/userfaultfd.txt b/Documentation/vm/userfaultfd.txt
index 70a3c94d1941..5a86192dde47 100644
--- a/Documentation/vm/userfaultfd.txt
+++ b/Documentation/vm/userfaultfd.txt
@@ -129,7 +129,7 @@ migration thread in the QEMU running in the destination node will
 receive the page that triggered the userfault and it'll map it as
 usual with the UFFDIO_COPY|ZEROPAGE (without actually knowing if it
 was spontaneously sent by the source or if it was an urgent page
-requested through an userfault).
+requested through a userfault).
 
 By the time the userfaults start, the QEMU in the destination node
 doesn't need to keep any per-page state bitmap relative to the live
diff --git a/arch/Kconfig b/arch/Kconfig
index b5a4cb176d36..6e7f6bd17f95 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -23,7 +23,7 @@ config OPROFILE_EVENT_MULTIPLEX
 	  The number of hardware counters is limited. The multiplexing
 	  feature enables OProfile to gather more events than counters
 	  are provided by the hardware. This is realized by switching
-	  between events at an user specified time interval.
+	  between events at a user specified time interval.
 
 	  If unsure, say N.
 
diff --git a/arch/powerpc/xmon/ppc-opc.c b/arch/powerpc/xmon/ppc-opc.c
index 6845e91ba04a..954dbf8222d7 100644
--- a/arch/powerpc/xmon/ppc-opc.c
+++ b/arch/powerpc/xmon/ppc-opc.c
@@ -1587,7 +1587,7 @@ extract_tbr (unsigned long insn,
 #define CTX(op, xop)   (OP (op) | (((unsigned long)(xop)) & 0x7))
 #define CTX_MASK CTX(0x3f, 0x7)
 
-/* An User Context form instruction.  */
+/* A User Context form instruction.  */
 #define UCTX(op, xop)  (OP (op) | (((unsigned long)(xop)) & 0x1f))
 #define UCTX_MASK UCTX(0x3f, 0x1f)
 
diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index 9645a520c25f..7c02f291da40 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -3938,7 +3938,7 @@ static void update_permission_bitmask(struct kvm_vcpu *vcpu,
 				 * as a SMAP violation if all of the following
 				 * conditions are ture:
 				 *   - X86_CR4_SMAP is set in CR4
-				 *   - An user page is accessed
+				 *   - A user page is accessed
 				 *   - Page fault in kernel mode
 				 *   - if CPL = 3 or X86_EFLAGS_AC is clear
 				 *
* Unmerged path drivers/media/dvb-core/dvb_ringbuffer.h
diff --git a/drivers/scsi/lpfc/lpfc_attr.c b/drivers/scsi/lpfc/lpfc_attr.c
index c5f7d60f9dff..9612930b0738 100644
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@ -3409,7 +3409,7 @@ static DEVICE_ATTR(lpfc_static_vport, S_IRUGO,
  * @buf: Data buffer.
  * @count: Size of the data buffer.
  *
- * This function get called when an user write to the lpfc_stat_data_ctrl
+ * This function get called when a user write to the lpfc_stat_data_ctrl
  * sysfs file. This function parse the command written to the sysfs file
  * and take appropriate action. These commands are used for controlling
  * driver statistical data collection.
diff --git a/fs/userfaultfd.c b/fs/userfaultfd.c
index d7afc1f69ed4..0fb1ae52ea02 100644
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@ -1467,17 +1467,17 @@ static void init_once_userfaultfd_ctx(void *mem)
 }
 
 /**
- * userfaultfd_file_create - Creates an userfaultfd file pointer.
+ * userfaultfd_file_create - Creates a userfaultfd file pointer.
  * @flags: Flags for the userfaultfd file.
  *
- * This function creates an userfaultfd file pointer, w/out installing
+ * This function creates a userfaultfd file pointer, w/out installing
  * it into the fd table. This is useful when the userfaultfd file is
  * used during the initialization of data structures that require
  * extra setup after the userfaultfd creation. So the userfaultfd
  * creation is split into the file pointer creation phase, and the
  * file descriptor installation phase.  In this way races with
  * userspace closing the newly installed file descriptor can be
- * avoided.  Returns an userfaultfd file pointer, or a proper error
+ * avoided.  Returns a userfaultfd file pointer, or a proper error
  * pointer.
  */
 static struct file *userfaultfd_file_create(int flags)
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index be30b0549b88..737f608c24cc 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -3353,7 +3353,7 @@ enum ieee80211_reconfig_type {
  *	since there won't be any time to beacon before the switch anyway.
  * @pre_channel_switch: This is an optional callback that is called
  *	before a channel switch procedure is started (ie. when a STA
- *	gets a CSA or an userspace initiated channel-switch), allowing
+ *	gets a CSA or a userspace initiated channel-switch), allowing
  *	the driver to prepare for the channel switch.
  * @post_channel_switch: This is an optional callback that is called
  *	after a channel switch procedure is completed, allowing the
* Unmerged path kernel/irq/manage.c
* Unmerged path net/bluetooth/hci_sock.c
diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c
index a5599fc51a6f..4d1afe0e57f9 100644
--- a/net/netfilter/nfnetlink_cthelper.c
+++ b/net/netfilter/nfnetlink_cthelper.c
@@ -48,7 +48,7 @@ nfnl_userspace_cthelper(struct sk_buff *skb, unsigned int protoff,
 	if (helper == NULL)
 		return NF_DROP;
 
-	/* This is an user-space helper not yet configured, skip. */
+	/* This is a user-space helper not yet configured, skip. */
 	if ((helper->flags &
 	    (NF_CT_HELPER_F_USERSPACE | NF_CT_HELPER_F_CONFIGURED)) ==
 	     NF_CT_HELPER_F_USERSPACE)
* Unmerged path scripts/spelling.txt
diff --git a/tools/perf/Documentation/tips.txt b/tools/perf/Documentation/tips.txt
index 8a6479c0eac9..170b0289a7bc 100644
--- a/tools/perf/Documentation/tips.txt
+++ b/tools/perf/Documentation/tips.txt
@@ -22,7 +22,7 @@ If you have debuginfo enabled, try: perf report -s sym,srcline
 For memory address profiling, try: perf mem record / perf mem report
 For tracepoint events, try: perf report -s trace_fields
 To record callchains for each sample: perf record -g
-To record every process run by an user: perf record -u <user>
+To record every process run by a user: perf record -u <user>
 Skip collecing build-id when recording: perf record -B
 To change sampling frequency to 100 Hz: perf record -F 100
 See assembly instructions with percentage: perf annotate <symbol>
