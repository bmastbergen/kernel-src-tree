kvm/x86: add sending hyper-v crash notification to user space

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andrey Smetanin <asmetanin@virtuozzo.com>
commit 2ce7918990641b07e70e1b25752d666369e2016e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2ce79189.failed

Sending of notification is done by exiting vcpu to user space
if KVM_REQ_HV_CRASH is enabled for vcpu. At exit to user space
the kvm_run structure contains system_event with type
KVM_SYSTEM_EVENT_CRASH to notify about guest crash occurred.

	Signed-off-by: Andrey Smetanin <asmetanin@virtuozzo.com>
	Signed-off-by: Denis V. Lunev <den@openvz.org>
	Reviewed-by: Peter Hornyack <peterhornyack@google.com>
CC: Paolo Bonzini <pbonzini@redhat.com>
CC: Gleb Natapov <gleb@kernel.org>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 2ce7918990641b07e70e1b25752d666369e2016e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	include/linux/kvm_host.h
#	include/uapi/linux/kvm.h
diff --cc Documentation/virtual/kvm/api.txt
index 7d0b79a97ed9,a4ebcb712375..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -2901,17 -3273,34 +2901,46 @@@ It gets triggered whenever both KVM_CAP
  external interrupt has just been delivered into the guest. User space
  should put the acknowledged interrupt vector into the 'epr' field.
  
 -		/* KVM_EXIT_SYSTEM_EVENT */
 +		/* KVM_EXIT_IOAPIC_EOI */
  		struct {
++<<<<<<< HEAD
 +			__u8 vector;
 +		} eoi;
 +
 +Indicates that the VCPU's in-kernel local APIC received an EOI for a
 +level-triggered IOAPIC interrupt.  This exit only triggers when the
 +IOAPIC is implemented in userspace (i.e. KVM_CAP_SPLIT_IRQCHIP is enabled);
 +the userspace IOAPIC should process the EOI and retrigger the interrupt if
 +it is still asserted.  Vector is the LAPIC interrupt vector for which the
 +EOI was received.
++=======
+ #define KVM_SYSTEM_EVENT_SHUTDOWN       1
+ #define KVM_SYSTEM_EVENT_RESET          2
+ #define KVM_SYSTEM_EVENT_CRASH          3
+ 			__u32 type;
+ 			__u64 flags;
+ 		} system_event;
+ 
+ If exit_reason is KVM_EXIT_SYSTEM_EVENT then the vcpu has triggered
+ a system-level event using some architecture specific mechanism (hypercall
+ or some special instruction). In case of ARM/ARM64, this is triggered using
+ HVC instruction based PSCI call from the vcpu. The 'type' field describes
+ the system-level event type. The 'flags' field describes architecture
+ specific flags for the system-level event.
+ 
+ Valid values for 'type' are:
+   KVM_SYSTEM_EVENT_SHUTDOWN -- the guest has requested a shutdown of the
+    VM. Userspace is not obliged to honour this, and if it does honour
+    this does not need to destroy the VM synchronously (ie it may call
+    KVM_RUN again before shutdown finally occurs).
+   KVM_SYSTEM_EVENT_RESET -- the guest has requested a reset of the VM.
+    As with SHUTDOWN, userspace can choose to ignore the request, or
+    to schedule the reset to occur in the future and may call KVM_RUN again.
+   KVM_SYSTEM_EVENT_CRASH -- the guest crash occurred and the guest
+    has requested a crash condition maintenance. Userspace can choose
+    to ignore the request, or to gather VM memory core dump and/or
+    reset/shutdown of the VM.
++>>>>>>> 2ce791899064 (kvm/x86: add sending hyper-v crash notification to user space)
  
  		/* Fix the size of the union. */
  		char padding[256];
diff --cc include/linux/kvm_host.h
index b42a4bf67232,51103f0feb7e..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -140,9 -135,11 +140,13 @@@ static inline bool is_error_page(struc
  #define KVM_REQ_EPR_EXIT          20
  #define KVM_REQ_SCAN_IOAPIC       21
  #define KVM_REQ_GLOBAL_CLOCK_UPDATE 22
 -#define KVM_REQ_ENABLE_IBS        23
 -#define KVM_REQ_DISABLE_IBS       24
  #define KVM_REQ_APIC_PAGE_RELOAD  25
  #define KVM_REQ_SMI               26
++<<<<<<< HEAD
 +#define KVM_REQ_IOAPIC_EOI_EXIT   28
++=======
+ #define KVM_REQ_HV_CRASH          27
++>>>>>>> 2ce791899064 (kvm/x86: add sending hyper-v crash notification to user space)
  
  #define KVM_USERSPACE_IRQ_SOURCE_ID		0
  #define KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID	1
diff --cc include/uapi/linux/kvm.h
index 9f7c8e1d99b2,9ef19ebd9df4..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -302,10 -313,23 +302,28 @@@ struct kvm_run 
  		struct {
  			__u32 epr;
  		} epr;
 -		/* KVM_EXIT_SYSTEM_EVENT */
 +		/* KVM_EXIT_IOAPIC_EOI */
  		struct {
++<<<<<<< HEAD
 +			__u8 vector;
 +		} eoi;
++=======
+ #define KVM_SYSTEM_EVENT_SHUTDOWN       1
+ #define KVM_SYSTEM_EVENT_RESET          2
+ #define KVM_SYSTEM_EVENT_CRASH          3
+ 			__u32 type;
+ 			__u64 flags;
+ 		} system_event;
+ 		/* KVM_EXIT_S390_STSI */
+ 		struct {
+ 			__u64 addr;
+ 			__u8 ar;
+ 			__u8 reserved;
+ 			__u8 fc;
+ 			__u8 sel1;
+ 			__u16 sel2;
+ 		} s390_stsi;
++>>>>>>> 2ce791899064 (kvm/x86: add sending hyper-v crash notification to user space)
  		/* Fix the size of the union. */
  		char padding[256];
  	};
* Unmerged path Documentation/virtual/kvm/api.txt
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 06fc23807a36..3ae39ce4a657 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -6665,6 +6665,12 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			vcpu_scan_ioapic(vcpu);
 		if (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))
 			kvm_vcpu_reload_apic_access_page(vcpu);
+		if (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {
+			vcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;
+			vcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;
+			r = 0;
+			goto out;
+		}
 	}
 
 	/*
* Unmerged path include/linux/kvm_host.h
* Unmerged path include/uapi/linux/kvm.h
