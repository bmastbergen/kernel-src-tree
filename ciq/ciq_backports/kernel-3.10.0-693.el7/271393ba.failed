drm/nouveau/fb/gf100-: Fix 32 bit wraparound in new ram detection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] nouveau/fb/gf100-: Fix 32 bit wraparound in new ram detection (Ben Skeggs) [1371629]
Rebuild_FUZZ: 96.83%
commit-author Mario Kleiner <mario.kleiner.de@gmail.com>
commit 271393ba6e2ac384a14e581d34d5d72c5953e3c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/271393ba.failed

A missing u64 cast causes a 32-Bit wraparound from
4096 MiB to 0 MiB and therefore total 0 MiB VRAM detected
if card has 4096 Mib per FBP.

	Signed-off-by: Mario Kleiner <mario.kleiner.de@gmail.com>
	Reviewed-by: Karol Herbst <karolherbst@gmail.com>
	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 271393ba6e2ac384a14e581d34d5d72c5953e3c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
diff --cc drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
index 772425ca5a9e,c63975907c90..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
@@@ -564,34 -577,34 +564,48 @@@ gf100_ram_ctor(const struct nvkm_ram_fu
  	struct nvkm_bios *bios = device->bios;
  	const u32 rsvd_head = ( 256 * 1024); /* vga memory */
  	const u32 rsvd_tail = (1024 * 1024); /* vbios etc */
 +	u32 parts = nvkm_rd32(device, 0x022438);
 +	u32 pmask = nvkm_rd32(device, maskaddr);
 +	u64 bsize = (u64)nvkm_rd32(device, 0x10f20c) << 20;
 +	u64 psize, size = 0;
  	enum nvkm_ram_type type = nvkm_fb_bios_memtype(bios);
 -	u32 fbps = nvkm_rd32(device, 0x022438);
 -	u64 total = 0, lcomm = ~0, lower, ubase, usize;
 -	int ret, fbp, ltcs, ltcn = 0;
 +	bool uniform = true;
 +	int ret, i;
 +
++<<<<<<< HEAD
 +	nvkm_debug(subdev, "100800: %08x\n", nvkm_rd32(device, 0x100800));
 +	nvkm_debug(subdev, "parts %08x mask %08x\n", parts, pmask);
 +
 +	/* read amount of vram attached to each memory controller */
 +	for (i = 0; i < parts; i++) {
 +		if (pmask & (1 << i))
 +			continue;
  
 +		psize = (u64)nvkm_rd32(device, 0x11020c + (i * 0x1000)) << 20;
 +		if (psize != bsize) {
 +			if (psize < bsize)
 +				bsize = psize;
 +			uniform = false;
++=======
+ 	nvkm_debug(subdev, "%d FBP(s)\n", fbps);
+ 	for (fbp = 0; fbp < fbps; fbp++) {
+ 		u32 size = func->probe_fbp(func, device, fbp, &ltcs);
+ 		if (size) {
+ 			nvkm_debug(subdev, "FBP %d: %4d MiB, %d LTC(s)\n",
+ 				   fbp, size, ltcs);
+ 			lcomm  = min(lcomm, (u64)(size / ltcs) << 20);
+ 			total += (u64) size << 20;
+ 			ltcn  += ltcs;
+ 		} else {
+ 			nvkm_debug(subdev, "FBP %d: disabled\n", fbp);
++>>>>>>> 271393ba6e2a (drm/nouveau/fb/gf100-: Fix 32 bit wraparound in new ram detection)
  		}
 -	}
 -
 -	lower = lcomm * ltcn;
 -	ubase = lcomm + func->upper;
 -	usize = total - lower;
  
 -	nvkm_debug(subdev, "Lower: %4lld MiB @ %010llx\n", lower >> 20, 0ULL);
 -	nvkm_debug(subdev, "Upper: %4lld MiB @ %010llx\n", usize >> 20, ubase);
 -	nvkm_debug(subdev, "Total: %4lld MiB\n", total >> 20);
 +		nvkm_debug(subdev, "%d: %d MiB\n", i, (u32)(psize >> 20));
 +		size += psize;
 +	}
  
 -	ret = nvkm_ram_ctor(func, fb, type, total, 0, ram);
 +	ret = nvkm_ram_ctor(func, fb, type, size, 0, ram);
  	if (ret)
  		return ret;
  
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
