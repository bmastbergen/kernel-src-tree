acct: switch to __kernel_write()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit ed44724b79d8e03a40665436019cf22baba80d30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ed44724b.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit ed44724b79d8e03a40665436019cf22baba80d30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/internal.h
diff --cc fs/internal.h
index 3b41f3e8a80a,9a2edba87c2b..000000000000
--- a/fs/internal.h
+++ b/fs/internal.h
@@@ -129,7 -131,13 +129,17 @@@ extern int d_set_mounted(struct dentry 
  /*
   * read_write.c
   */
++<<<<<<< HEAD
 +extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
++=======
+ extern int rw_verify_area(int, struct file *, const loff_t *, size_t);
+ 
+ /*
+  * splice.c
+  */
+ extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
+ 		loff_t *opos, size_t len, unsigned int flags);
++>>>>>>> ed44724b79d8 (acct: switch to __kernel_write())
  
  /*
   * pipe.c
* Unmerged path fs/internal.h
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8dc175024e03..f9be65ff1e90 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2678,6 +2678,7 @@ extern int do_pipe_flags(int *, int);
 
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
+extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */
diff --git a/kernel/acct.c b/kernel/acct.c
index 35610572400a..f007ffdafca9 100644
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@ -456,7 +456,6 @@ static void do_acct_process(struct bsd_acct_struct *acct,
 {
 	struct pacct_struct *pacct = &current->signal->pacct;
 	acct_t ac;
-	mm_segment_t fs;
 	unsigned long flim;
 	u64 elapsed;
 	u64 run_time;
@@ -464,6 +463,11 @@ static void do_acct_process(struct bsd_acct_struct *acct,
 	struct tty_struct *tty;
 	const struct cred *orig_cred;
 
+	/*
+	 * Accounting records are not subject to resource limits.
+	 */
+	flim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
+	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
 	/* Perform file operations on behalf of whoever enabled accounting */
 	orig_cred = override_creds(file->f_cred);
 
@@ -540,25 +544,14 @@ static void do_acct_process(struct bsd_acct_struct *acct,
 	 * Get freeze protection. If the fs is frozen, just skip the write
 	 * as we could deadlock the system otherwise.
 	 */
-	if (!file_start_write_trylock(file))
-		goto out;
-	/*
-	 * Kernel segment override to datasegment and write it
-	 * to the accounting file.
-	 */
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	/*
-	 * Accounting records are not subject to resource limits.
-	 */
-	flim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
-	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
-	file->f_op->write(file, (char *)&ac,
-			       sizeof(acct_t), &file->f_pos);
-	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;
-	set_fs(fs);
-	file_end_write(file);
+	if (file_start_write_trylock(file)) {
+		/* it's been opened O_APPEND, so position is irrelevant */
+		loff_t pos = 0;
+		__kernel_write(file, (char *)&ac, sizeof(acct_t), &pos);
+		file_end_write(file);
+	}
 out:
+	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;
 	revert_creds(orig_cred);
 }
 
