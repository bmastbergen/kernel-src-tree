KVM: x86: add track_flush_slot page track notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Xiaoguang Chen <xiaoguang.chen@intel.com>
commit b5f5fdca65dbccbafe08a481957629d67003db34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b5f5fdca.failed

When a memory slot is being moved or removed users of page track
can be notified. So users can drop write-protection for the pages
in that memory slot.

This notifier type is needed by KVMGT to sync up its shadow page
table when memory slot is being moved or removed.

Register the notifier type track_flush_slot to receive memslot move
and remove event.

	Reviewed-by: Xiao Guangrong <guangrong.xiao@intel.com>
	Signed-off-by: Chen Xiaoguang <xiaoguang.chen@intel.com>
[Squashed commits to avoid bisection breakage and reworded the subject.]
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit b5f5fdca65dbccbafe08a481957629d67003db34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_page_track.h
#	arch/x86/kvm/mmu.c
#	arch/x86/kvm/page_track.c
diff --cc arch/x86/kvm/mmu.c
index 9645a520c25f,25ca7621474a..000000000000
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@@ -4579,8 -4609,30 +4579,33 @@@ void kvm_mmu_setup(struct kvm_vcpu *vcp
  	init_kvm_mmu(vcpu);
  }
  
++<<<<<<< HEAD
++=======
+ static void kvm_mmu_invalidate_zap_pages_in_memslot(struct kvm *kvm,
+ 			struct kvm_memory_slot *slot)
+ {
+ 	kvm_mmu_invalidate_zap_all_pages(kvm);
+ }
+ 
+ void kvm_mmu_init_vm(struct kvm *kvm)
+ {
+ 	struct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;
+ 
+ 	node->track_write = kvm_mmu_pte_write;
+ 	node->track_flush_slot = kvm_mmu_invalidate_zap_pages_in_memslot;
+ 	kvm_page_track_register_notifier(kvm, node);
+ }
+ 
+ void kvm_mmu_uninit_vm(struct kvm *kvm)
+ {
+ 	struct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;
+ 
+ 	kvm_page_track_unregister_notifier(kvm, node);
+ }
+ 
++>>>>>>> b5f5fdca65db (KVM: x86: add track_flush_slot page track notifier)
  /* The return value indicates if tlb flush on all vcpus is needed. */
 -typedef bool (*slot_level_handler) (struct kvm *kvm, struct kvm_rmap_head *rmap_head);
 +typedef bool (*slot_level_handler) (struct kvm *kvm, unsigned long *rmap);
  
  /* The caller should hold mmu-lock before calling this function. */
  static bool
* Unmerged path arch/x86/include/asm/kvm_page_track.h
* Unmerged path arch/x86/kvm/page_track.c
* Unmerged path arch/x86/include/asm/kvm_page_track.h
* Unmerged path arch/x86/kvm/mmu.c
* Unmerged path arch/x86/kvm/page_track.c
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 9677babcc502..9281fffc0e54 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -8251,7 +8251,7 @@ void kvm_arch_flush_shadow_all(struct kvm *kvm)
 void kvm_arch_flush_shadow_memslot(struct kvm *kvm,
 				   struct kvm_memory_slot *slot)
 {
-	kvm_mmu_invalidate_zap_all_pages(kvm);
+	kvm_page_track_flush_slot(kvm, slot);
 }
 
 static inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)
