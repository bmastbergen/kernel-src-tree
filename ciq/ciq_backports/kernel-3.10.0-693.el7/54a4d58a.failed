acct: simplify check_free_space()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 54a4d58a6459a93fc6ee898354b3d2ffb80dd03a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/54a4d58a.failed

a) file can't be NULL
b) file can't be changed under us
c) all writes are serialized by acct->lock; no need to mess with
spinlock there.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 54a4d58a6459a93fc6ee898354b3d2ffb80dd03a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/acct.c
diff --cc kernel/acct.c
index 7ffb48430dba,019f012a3c6f..000000000000
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@@ -93,49 -93,21 +93,47 @@@ static LIST_HEAD(acct_list)
  /*
   * Check the amount of free space and suspend/resume accordingly.
   */
- static int check_free_space(struct bsd_acct_struct *acct, struct file *file)
+ static int check_free_space(struct bsd_acct_struct *acct)
  {
  	struct kstatfs sbuf;
- 	int res;
- 	int act;
- 	u64 resume;
- 	u64 suspend;
  
- 	spin_lock(&acct_lock);
- 	res = acct->active;
- 	if (!file || time_is_before_jiffies(acct->needcheck))
+ 	if (time_is_before_jiffies(acct->needcheck))
  		goto out;
- 	spin_unlock(&acct_lock);
  
  	/* May block */
++<<<<<<< HEAD
 +	if (vfs_statfs(&file->f_path, &sbuf))
 +		return res;
 +	suspend = sbuf.f_blocks * SUSPEND;
 +	resume = sbuf.f_blocks * RESUME;
 +
 +	do_div(suspend, 100);
 +	do_div(resume, 100);
 +
 +	if (sbuf.f_bavail <= suspend)
 +		act = -1;
 +	else if (sbuf.f_bavail >= resume)
 +		act = 1;
 +	else
 +		act = 0;
 +
 +	/*
 +	 * If some joker switched acct->file under us we'ld better be
 +	 * silent and _not_ touch anything.
 +	 */
 +	spin_lock(&acct_lock);
 +	if (file != acct->file) {
 +		if (act)
 +			res = act>0;
++=======
+ 	if (vfs_statfs(&acct->file->f_path, &sbuf))
++>>>>>>> 54a4d58a6459 (acct: simplify check_free_space())
  		goto out;
- 	}
  
  	if (acct->active) {
- 		if (act < 0) {
+ 		u64 suspend = sbuf.f_blocks * SUSPEND;
+ 		do_div(suspend, 100);
+ 		if (sbuf.f_bavail <= suspend) {
  			acct->active = 0;
  			printk(KERN_INFO "Process accounting paused\n");
  		}
@@@ -471,32 -447,11 +469,32 @@@ static u32 encode_float(u64 value
   *  do_exit() or when switching to a different output file.
   */
  
 -static void fill_ac(acct_t *ac)
 +/*
 + *  do_acct_process does all actual work. Caller holds the reference to file.
 + */
 +static void do_acct_process(struct bsd_acct_struct *acct)
  {
  	struct pacct_struct *pacct = &current->signal->pacct;
 -	u64 elapsed, run_time;
 +	acct_t ac;
 +	mm_segment_t fs;
 +	unsigned long flim;
 +	u64 elapsed;
 +	u64 run_time;
 +	struct timespec uptime;
  	struct tty_struct *tty;
 +	const struct cred *orig_cred;
 +	struct pid_namespace *ns = acct->ns;
 +	struct file *file = acct->file;
 +
 +	/* Perform file operations on behalf of whoever enabled accounting */
 +	orig_cred = override_creds(file->f_cred);
 +
 +	/*
 +	 * First check to see if there is enough free_space to continue
 +	 * the process accounting system.
 +	 */
- 	if (!check_free_space(acct, file))
++	if (!check_free_space(acct))
 +		goto out;
  
  	/*
  	 * Fill the accounting struct with the needed info as recorded
* Unmerged path kernel/acct.c
