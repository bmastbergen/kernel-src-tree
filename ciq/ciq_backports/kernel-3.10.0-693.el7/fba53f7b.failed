net/mlx5: Introduce mlx5_flow_steering structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Introduce mlx5_flow_steering structure (Don Dutile) [1383601 1417284]
Rebuild_FUZZ: 95.65%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit fba53f7b571925b8a0d59d460ad6de1fda928a3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fba53f7b.failed

Instead of having all steering private name spaces and
steering module fields flat in mlx5_core_priv, we wrap
them in mlx5_flow_steering for better modularity and
API exposure.

	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fba53f7b571925b8a0d59d460ad6de1fda928a3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
#	include/linux/mlx5/driver.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 3b6147aebe10,0f969cb2291a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -1304,10 -1381,20 +1305,23 @@@ struct mlx5_flow_namespace *mlx5_get_fl
  		prio = type;
  		break;
  	case MLX5_FLOW_NAMESPACE_FDB:
- 		if (dev->priv.fdb_root_ns)
- 			return &dev->priv.fdb_root_ns->ns;
+ 		if (steering->fdb_root_ns)
+ 			return &steering->fdb_root_ns->ns;
+ 		else
+ 			return NULL;
++<<<<<<< HEAD
++=======
+ 	case MLX5_FLOW_NAMESPACE_ESW_EGRESS:
+ 		if (steering->esw_egress_root_ns)
+ 			return &steering->esw_egress_root_ns->ns;
+ 		else
+ 			return NULL;
+ 	case MLX5_FLOW_NAMESPACE_ESW_INGRESS:
+ 		if (steering->esw_ingress_root_ns)
+ 			return &steering->esw_ingress_root_ns->ns;
  		else
  			return NULL;
++>>>>>>> fba53f7b5719 (net/mlx5: Introduce mlx5_flow_steering structure)
  	default:
  		return NULL;
  	}
@@@ -1533,18 -1624,18 +1551,23 @@@ static void set_prio_attrs(struct mlx5_
  
  #define ANCHOR_PRIO 0
  #define ANCHOR_SIZE 1
++<<<<<<< HEAD
 +static int create_anchor_flow_table(struct mlx5_core_dev
 +							*dev)
++=======
+ #define ANCHOR_LEVEL 0
+ static int create_anchor_flow_table(struct mlx5_flow_steering *steering)
++>>>>>>> fba53f7b5719 (net/mlx5: Introduce mlx5_flow_steering structure)
  {
  	struct mlx5_flow_namespace *ns = NULL;
  	struct mlx5_flow_table *ft;
  
- 	ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_ANCHOR);
+ 	ns = mlx5_get_flow_namespace(steering->dev, MLX5_FLOW_NAMESPACE_ANCHOR);
  	if (!ns)
  		return -EINVAL;
 -	ft = mlx5_create_flow_table(ns, ANCHOR_PRIO, ANCHOR_SIZE, ANCHOR_LEVEL);
 +	ft = mlx5_create_flow_table(ns, ANCHOR_PRIO, ANCHOR_SIZE);
  	if (IS_ERR(ft)) {
- 		mlx5_core_err(dev, "Failed to create last anchor flow table");
+ 		mlx5_core_err(steering->dev, "Failed to create last anchor flow table");
  		return PTR_ERR(ft);
  	}
  	return 0;
@@@ -1685,11 -1776,20 +1708,25 @@@ static void cleanup_root_ns(struct mlx5
  
  void mlx5_cleanup_fs(struct mlx5_core_dev *dev)
  {
++<<<<<<< HEAD
 +	cleanup_root_ns(dev);
 +	cleanup_single_prio_root_ns(dev, dev->priv.fdb_root_ns);
++=======
+ 	struct mlx5_flow_steering *steering = dev->priv.steering;
+ 
+ 	if (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)
+ 		return;
+ 
+ 	cleanup_root_ns(steering);
+ 	cleanup_single_prio_root_ns(steering, steering->esw_egress_root_ns);
+ 	cleanup_single_prio_root_ns(steering, steering->esw_ingress_root_ns);
+ 	cleanup_single_prio_root_ns(steering, steering->fdb_root_ns);
+ 	mlx5_cleanup_fc_stats(dev);
+ 	kfree(steering);
++>>>>>>> fba53f7b5719 (net/mlx5: Introduce mlx5_flow_steering structure)
  }
  
- static int init_fdb_root_ns(struct mlx5_core_dev *dev)
+ static int init_fdb_root_ns(struct mlx5_flow_steering *steering)
  {
  	struct fs_prio *prio;
  
@@@ -1707,20 -1807,85 +1744,95 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int init_ingress_acl_root_ns(struct mlx5_flow_steering *steering)
+ {
+ 	struct fs_prio *prio;
+ 
+ 	steering->esw_egress_root_ns = create_root_ns(steering, FS_FT_ESW_EGRESS_ACL);
+ 	if (!steering->esw_egress_root_ns)
+ 		return -ENOMEM;
+ 
+ 	/* create 1 prio*/
+ 	prio = fs_create_prio(&steering->esw_egress_root_ns->ns, 0,
+ 			      MLX5_TOTAL_VPORTS(steering->dev));
+ 	if (IS_ERR(prio))
+ 		return PTR_ERR(prio);
+ 	else
+ 		return 0;
+ }
+ 
+ static int init_egress_acl_root_ns(struct mlx5_flow_steering *steering)
+ {
+ 	struct fs_prio *prio;
+ 
+ 	steering->esw_ingress_root_ns = create_root_ns(steering, FS_FT_ESW_INGRESS_ACL);
+ 	if (!steering->esw_ingress_root_ns)
+ 		return -ENOMEM;
+ 
+ 	/* create 1 prio*/
+ 	prio = fs_create_prio(&steering->esw_ingress_root_ns->ns, 0,
+ 			      MLX5_TOTAL_VPORTS(steering->dev));
+ 	if (IS_ERR(prio))
+ 		return PTR_ERR(prio);
+ 	else
+ 		return 0;
+ }
+ 
++>>>>>>> fba53f7b5719 (net/mlx5: Introduce mlx5_flow_steering structure)
  int mlx5_init_fs(struct mlx5_core_dev *dev)
  {
+ 	struct mlx5_flow_steering *steering;
  	int err = 0;
  
++<<<<<<< HEAD
 +	if (MLX5_CAP_GEN(dev, nic_flow_table)) {
 +		err = init_root_ns(dev);
++=======
+ 	if (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)
+ 		return 0;
+ 
+ 	err = mlx5_init_fc_stats(dev);
+ 	if (err)
+ 		return err;
+ 
+ 	steering = kzalloc(sizeof(*steering), GFP_KERNEL);
+ 	if (!steering)
+ 		return -ENOMEM;
+ 	steering->dev = dev;
+ 	dev->priv.steering = steering;
+ 
+ 	if (MLX5_CAP_GEN(dev, nic_flow_table) &&
+ 	    MLX5_CAP_FLOWTABLE_NIC_RX(dev, ft_support)) {
+ 		err = init_root_ns(steering);
++>>>>>>> fba53f7b5719 (net/mlx5: Introduce mlx5_flow_steering structure)
  		if (err)
 -			goto err;
 +			return err;
  	}
 -
  	if (MLX5_CAP_GEN(dev, eswitch_flow_table)) {
++<<<<<<< HEAD
 +		err = init_fdb_root_ns(dev);
 +		if (err)
 +			cleanup_root_ns(dev);
++=======
+ 		if (MLX5_CAP_ESW_FLOWTABLE_FDB(dev, ft_support)) {
+ 			err = init_fdb_root_ns(steering);
+ 			if (err)
+ 				goto err;
+ 		}
+ 		if (MLX5_CAP_ESW_EGRESS_ACL(dev, ft_support)) {
+ 			err = init_egress_acl_root_ns(steering);
+ 			if (err)
+ 				goto err;
+ 		}
+ 		if (MLX5_CAP_ESW_INGRESS_ACL(dev, ft_support)) {
+ 			err = init_ingress_acl_root_ns(steering);
+ 			if (err)
+ 				goto err;
+ 		}
++>>>>>>> fba53f7b5719 (net/mlx5: Introduce mlx5_flow_steering structure)
  	}
  
 -	return 0;
 -err:
 -	mlx5_cleanup_fs(dev);
  	return err;
  }
diff --cc include/linux/mlx5/driver.h
index e2692f7929e8,f21c45941887..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -527,8 -554,8 +528,13 @@@ struct mlx5_priv 
  	struct mlx5_eswitch     *eswitch;
  	struct mlx5_core_sriov	sriov;
  	unsigned long		pci_dev_data;
++<<<<<<< HEAD
 +	struct mlx5_flow_root_namespace *root_ns;
 +	struct mlx5_flow_root_namespace *fdb_root_ns;
++=======
+ 	struct mlx5_fc_stats		fc_stats;
+ 	struct mlx5_rl_table            rl_table;
++>>>>>>> fba53f7b5719 (net/mlx5: Introduce mlx5_flow_steering structure)
  };
  
  enum mlx5_device_state {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index d607e564f454..9bcf23efa48c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@ -53,6 +53,14 @@ enum fs_fte_status {
 	FS_FTE_STATUS_EXISTING = 1UL << 0,
 };
 
+struct mlx5_flow_steering {
+	struct mlx5_core_dev *dev;
+	struct mlx5_flow_root_namespace *root_ns;
+	struct mlx5_flow_root_namespace *fdb_root_ns;
+	struct mlx5_flow_root_namespace *esw_egress_root_ns;
+	struct mlx5_flow_root_namespace *esw_ingress_root_ns;
+};
+
 struct fs_node {
 	struct list_head	list;
 	struct list_head	children;
* Unmerged path include/linux/mlx5/driver.h
