KVM: nVMX: fix CR3 load if L2 uses PAE paging and EPT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ladi Prosek <lprosek@redhat.com>
commit 7ca29de21362de242025fbc1c22436e19e39dddc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7ca29de2.failed

KVM does not correctly handle L1 hypervisors that emulate L2 real mode with
PAE and EPT, such as Hyper-V. In this mode, the L1 hypervisor populates guest
PDPTE VMCS fields and leaves guest CR3 uninitialized because it is not used
(see 26.3.2.4 Loading Page-Directory-Pointer-Table Entries). KVM always
dereferences CR3 and tries to load PDPTEs if PAE is on. This leads to two
related issues:

1) On the first nested vmentry, the guest PDPTEs, as populated by L1, are
overwritten in ept_load_pdptrs because the registers are believed to have
been loaded in load_pdptrs as part of kvm_set_cr3. This is incorrect. L2 is
running with PAE enabled but PDPTRs have been set up by L1.

2) When L2 is about to enable paging and loads its CR3, we, again, attempt
to load PDPTEs in load_pdptrs called from kvm_set_cr3. There are no guarantees
that this will succeed (it's just a CR3 load, paging is not enabled yet) and
if it doesn't, kvm_set_cr3 returns early without persisting the CR3 which is
then lost and L2 crashes right after it enables paging.

This patch replaces the kvm_set_cr3 call with a simple register write if PAE
and EPT are both on. CR3 is not to be interpreted in this case.

	Signed-off-by: Ladi Prosek <lprosek@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 7ca29de21362de242025fbc1c22436e19e39dddc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index c4ff252596cb,bcad2eb11404..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9695,8 -10288,27 +9697,32 @@@ static void prepare_vmcs02(struct kvm_v
  	vmx_set_cr4(vcpu, vmcs12->guest_cr4);
  	vmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));
  
++<<<<<<< HEAD
 +	/* shadow page tables on either EPT or shadow page tables */
 +	kvm_set_cr3(vcpu, vmcs12->guest_cr3);
++=======
+ 	if (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)
+ 		vcpu->arch.efer = vmcs12->guest_ia32_efer;
+ 	else if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)
+ 		vcpu->arch.efer |= (EFER_LMA | EFER_LME);
+ 	else
+ 		vcpu->arch.efer &= ~(EFER_LMA | EFER_LME);
+ 	/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */
+ 	vmx_set_efer(vcpu, vcpu->arch.efer);
+ 
+ 	/*
+ 	 * Shadow page tables on either EPT or shadow page tables.
+ 	 * If PAE and EPT are both on, CR3 is not used by the CPU and must not
+ 	 * be dereferenced.
+ 	 */
+ 	if (is_pae(vcpu) && is_paging(vcpu) && !is_long_mode(vcpu) &&
+ 	    nested_ept_enabled) {
+ 		vcpu->arch.cr3 = vmcs12->guest_cr3;
+ 		__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);
+ 	} else
+ 		kvm_set_cr3(vcpu, vmcs12->guest_cr3);
+ 
++>>>>>>> 7ca29de21362 (KVM: nVMX: fix CR3 load if L2 uses PAE paging and EPT)
  	kvm_mmu_reset_context(vcpu);
  
  	if (!enable_ept)
* Unmerged path arch/x86/kvm/vmx.c
