net sched: indentation and other OCD stylistic fixes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: indentation and other OCD stylistic fixes (Ivan Vecera) [1450145]
Rebuild_FUZZ: 96.00%
commit-author Jamal Hadi Salim <jhs@mojatatu.com>
commit 0b0f43fe2e7291aa97b1febeaa5a0de453d007ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0b0f43fe.failed

	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
(cherry picked from commit 0b0f43fe2e7291aa97b1febeaa5a0de453d007ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	net/sched/act_bpf.c
diff --cc include/net/act_api.h
index 11aac9abd0ca,db218a12efb5..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -57,42 -94,85 +57,94 @@@ struct tc_action 
  	__u32			type; /* for backward compat(TCA_OLD_COMPAT) */
  	__u32			order;
  	struct list_head	list;
 -	struct tcf_hashinfo	*hinfo;
  };
  
 -#ifdef CONFIG_NET_CLS_ACT
 -
 -#define ACT_P_CREATED 1
 -#define ACT_P_DELETED 1
 -
 +#define TCA_CAP_NONE 0
  struct tc_action_ops {
  	struct list_head head;
 +	struct tcf_hashinfo *hinfo;
  	char    kind[IFNAMSIZ];
  	__u32   type; /* TBD to match kind */
 +	__u32 	capab;  /* capabilities includes 4 bit version */
  	struct module		*owner;
- 	int     (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
+ 	int     (*act)(struct sk_buff *, const struct tc_action *,
+ 		       struct tcf_result *);
  	int     (*dump)(struct sk_buff *, struct tc_action *, int, int);
 -	void	(*cleanup)(struct tc_action *, int bind);
 -	int     (*lookup)(struct net *, struct tc_action *, u32);
 +	int     (*cleanup)(struct tc_action *, int bind);
 +	int     (*lookup)(struct tc_action *, u32);
  	int     (*init)(struct net *net, struct nlattr *nla,
  			struct nlattr *est, struct tc_action *act, int ovr,
  			int bind);
 -	int     (*walk)(struct net *, struct sk_buff *,
 -			struct netlink_callback *, int, struct tc_action *);
 -	void	(*stats_update)(struct tc_action *, u64, u32, u64);
 -};
 -
 -struct tc_action_net {
 -	struct tcf_hashinfo *hinfo;
 -	const struct tc_action_ops *ops;
 +	int     (*walk)(struct sk_buff *, struct netlink_callback *, int, struct tc_action *);
  };
  
 +struct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo);
 +void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 +int tcf_hash_release(struct tcf_common *p, int bind,
 +		     struct tcf_hashinfo *hinfo);
 +u32 tcf_hash_new_index(u32 *idx_gen, struct tcf_hashinfo *hinfo);
 +struct tcf_common *tcf_hash_check(u32 index, struct tc_action *a,
 +				  int bind, struct tcf_hashinfo *hinfo);
 +struct tcf_common *tcf_hash_create(u32 index, struct nlattr *est,
 +				   struct tc_action *a, int size,
 +				   int bind, u32 *idx_gen,
 +				   struct tcf_hashinfo *hinfo);
 +void tcf_hash_insert(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 +
++<<<<<<< HEAD
 +int tcf_register_action(struct tc_action_ops *a);
 +int tcf_unregister_action(struct tc_action_ops *a);
 +void tcf_action_destroy(struct list_head *actions, int bind);
++=======
+ static inline
+ int tc_action_net_init(struct tc_action_net *tn,
+ 		       const struct tc_action_ops *ops, unsigned int mask)
+ {
+ 	int err = 0;
+ 
+ 	tn->hinfo = kmalloc(sizeof(*tn->hinfo), GFP_KERNEL);
+ 	if (!tn->hinfo)
+ 		return -ENOMEM;
+ 	tn->ops = ops;
+ 	err = tcf_hashinfo_init(tn->hinfo, mask);
+ 	if (err)
+ 		kfree(tn->hinfo);
+ 	return err;
+ }
+ 
+ void tcf_hashinfo_destroy(const struct tc_action_ops *ops,
+ 			  struct tcf_hashinfo *hinfo);
+ 
+ static inline void tc_action_net_exit(struct tc_action_net *tn)
+ {
+ 	tcf_hashinfo_destroy(tn->ops, tn->hinfo);
+ 	kfree(tn->hinfo);
+ }
+ 
+ int tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,
+ 		       struct netlink_callback *cb, int type,
+ 		       struct tc_action *a);
+ int tcf_hash_search(struct tc_action_net *tn, struct tc_action *a, u32 index);
+ u32 tcf_hash_new_index(struct tc_action_net *tn);
+ int tcf_hash_check(struct tc_action_net *tn, u32 index, struct tc_action *a,
+ 		   int bind);
+ int tcf_hash_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
+ 		    struct tc_action *a, int size, int bind, bool cpustats);
+ void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
+ void tcf_hash_insert(struct tc_action_net *tn, struct tc_action *a);
+ 
+ int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);
+ 
+ static inline int tcf_hash_release(struct tc_action *a, bool bind)
+ {
+ 	return __tcf_hash_release(a, bind, false);
+ }
+ 
+ int tcf_register_action(struct tc_action_ops *a, struct pernet_operations *ops);
+ int tcf_unregister_action(struct tc_action_ops *a,
+ 			  struct pernet_operations *ops);
+ int tcf_action_destroy(struct list_head *actions, int bind);
++>>>>>>> 0b0f43fe2e72 (net sched: indentation and other OCD stylistic fixes)
  int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
  		    struct tcf_result *res);
  int tcf_action_init(struct net *net, struct nlattr *nla,
* Unmerged path net/sched/act_bpf.c
* Unmerged path include/net/act_api.h
diff --git a/include/net/tc_act/tc_defact.h b/include/net/tc_act/tc_defact.h
index 65f024b80958..474a34b154fa 100644
--- a/include/net/tc_act/tc_defact.h
+++ b/include/net/tc_act/tc_defact.h
@@ -5,8 +5,8 @@
 
 struct tcf_defact {
 	struct tcf_common	common;
-	u32     		tcfd_datalen;
-	void    		*tcfd_defdata;
+	u32		tcfd_datalen;
+	void		*tcfd_defdata;
 };
 #define to_defact(pc) \
 	container_of(pc, struct tcf_defact, common)
diff --git a/include/uapi/linux/pkt_cls.h b/include/uapi/linux/pkt_cls.h
index 3abfe7f00823..2490941c3db3 100644
--- a/include/uapi/linux/pkt_cls.h
+++ b/include/uapi/linux/pkt_cls.h
@@ -135,8 +135,8 @@ struct tc_police {
 	__u32			mtu;
 	struct tc_ratespec	rate;
 	struct tc_ratespec	peakrate;
-	int 			refcnt;
-	int 			bindcnt;
+	int			refcnt;
+	int			bindcnt;
 	__u32			capab;
 };
 
@@ -147,7 +147,7 @@ struct tcf_t {
 };
 
 struct tc_cnt {
-	int                   refcnt; 
+	int                   refcnt;
 	int                   bindcnt;
 };
 
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index 45d305cc522a..26c98a352ec5 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -416,8 +416,8 @@ nla_put_failure:
 }
 EXPORT_SYMBOL(tcf_action_dump_1);
 
-int
-tcf_action_dump(struct sk_buff *skb, struct list_head *actions, int bind, int ref)
+int tcf_action_dump(struct sk_buff *skb, struct list_head *actions,
+		    int bind, int ref)
 {
 	struct tc_action *a;
 	int err = -EINVAL;
@@ -595,9 +595,9 @@ errout:
 	return -1;
 }
 
-static int
-tca_get_fill(struct sk_buff *skb, struct list_head *actions, u32 portid, u32 seq,
-	     u16 flags, int event, int bind, int ref)
+static int tca_get_fill(struct sk_buff *skb, struct list_head *actions,
+			u32 portid, u32 seq, u16 flags, int event, int bind,
+			int ref)
 {
 	struct tcamsg *t;
 	struct nlmsghdr *nlh;
@@ -638,7 +638,8 @@ act_get_notify(struct net *net, u32 portid, struct nlmsghdr *n,
 	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
 	if (!skb)
 		return -ENOBUFS;
-	if (tca_get_fill(skb, actions, portid, n->nlmsg_seq, 0, event, 0, 0) <= 0) {
+	if (tca_get_fill(skb, actions, portid, n->nlmsg_seq, 0, event,
+			 0, 0) <= 0) {
 		kfree_skb(skb);
 		return -EINVAL;
 	}
@@ -746,7 +747,8 @@ static int tca_action_flush(struct net *net, struct nlattr *nla,
 	if (a.ops == NULL) /*some idjot trying to flush unknown action */
 		goto err_out;
 
-	nlh = nlmsg_put(skb, portid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t), 0);
+	nlh = nlmsg_put(skb, portid, n->nlmsg_seq, RTM_DELACTION,
+			sizeof(*t), 0);
 	if (!nlh)
 		goto out_module_put;
 	t = nlmsg_data(nlh);
@@ -905,7 +907,8 @@ static int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n)
 	u32 portid = skb ? NETLINK_CB(skb).portid : 0;
 	int ret = 0, ovr = 0;
 
-	if ((n->nlmsg_type != RTM_GETACTION) && !netlink_capable(skb, CAP_NET_ADMIN))
+	if ((n->nlmsg_type != RTM_GETACTION) &&
+	    !netlink_capable(skb, CAP_NET_ADMIN))
 		return -EPERM;
 
 	ret = nlmsg_parse(n, sizeof(struct tcamsg), tca, TCA_ACT_MAX, NULL);
* Unmerged path net/sched/act_bpf.c
diff --git a/net/sched/act_gact.c b/net/sched/act_gact.c
index 085ab295a109..77116feb43ea 100644
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@ -174,7 +174,8 @@ static void tcf_gact_stats_update(struct tc_action *a, u64 bytes, u32 packets,
 	tm->lastuse = lastuse;
 }
 
-static int tcf_gact_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)
+static int tcf_gact_dump(struct sk_buff *skb, struct tc_action *a,
+			 int bind, int ref)
 {
 	unsigned char *b = skb_tail_pointer(skb);
 	struct tcf_gact *gact = a->priv;
diff --git a/net/sched/act_ipt.c b/net/sched/act_ipt.c
index 90a973aacc76..c6bcb3c70b8f 100644
--- a/net/sched/act_ipt.c
+++ b/net/sched/act_ipt.c
@@ -39,7 +39,8 @@ static struct tcf_hashinfo ipt_hash_info = {
 	.lock	=	&ipt_lock,
 };
 
-static int ipt_init_target(struct xt_entry_target *t, char *table, unsigned int hook)
+static int ipt_init_target(struct xt_entry_target *t, char *table,
+			   unsigned int hook)
 {
 	struct xt_tgchk_param par;
 	struct xt_target *target;
@@ -252,7 +253,8 @@ static int tcf_ipt(struct sk_buff *skb, const struct tc_action *a,
 
 }
 
-static int tcf_ipt_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)
+static int tcf_ipt_dump(struct sk_buff *skb, struct tc_action *a, int bind,
+			int ref)
 {
 	unsigned char *b = skb_tail_pointer(skb);
 	struct tcf_ipt *ipt = a->priv;
diff --git a/net/sched/act_vlan.c b/net/sched/act_vlan.c
index d735ecf0b1a7..aaa35bca7d09 100644
--- a/net/sched/act_vlan.c
+++ b/net/sched/act_vlan.c
@@ -165,7 +165,8 @@ static int tcf_vlan_dump(struct sk_buff *skb, struct tc_action *a,
 
 	if (v->tcfv_action == TCA_VLAN_ACT_PUSH &&
 	    (nla_put_u16(skb, TCA_VLAN_PUSH_VLAN_ID, v->tcfv_push_vid) ||
-	     nla_put_be16(skb, TCA_VLAN_PUSH_VLAN_PROTOCOL, v->tcfv_push_proto)))
+	     nla_put_be16(skb, TCA_VLAN_PUSH_VLAN_PROTOCOL,
+			  v->tcfv_push_proto)))
 		goto nla_put_failure;
 
 	t.install = jiffies_to_clock_t(jiffies - v->tcf_tm.install);
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index a79e83e16a99..1f28dfeb3410 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -346,8 +346,9 @@ errout:
 	return err;
 }
 
-static int tcf_fill_node(struct net *net, struct sk_buff *skb, struct tcf_proto *tp,
-			 unsigned long fh, u32 portid, u32 seq, u16 flags, int event)
+static int tcf_fill_node(struct net *net, struct sk_buff *skb,
+			 struct tcf_proto *tp, unsigned long fh, u32 portid,
+			 u32 seq, u16 flags, int event)
 {
 	struct tcmsg *tcm;
 	struct nlmsghdr  *nlh;
@@ -468,9 +469,11 @@ static int tc_dump_tfilter(struct sk_buff *skb, struct netlink_callback *cb)
 		    TC_H_MIN(tcm->tcm_info) != tp->protocol)
 			continue;
 		if (t > s_t)
-			memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
+			memset(&cb->args[1], 0,
+			       sizeof(cb->args)-sizeof(cb->args[0]));
 		if (cb->args[1] == 0) {
-			if (tcf_fill_node(net, skb, tp, 0, NETLINK_CB(cb->skb).portid,
+			if (tcf_fill_node(net, skb, tp, 0,
+					  NETLINK_CB(cb->skb).portid,
 					  cb->nlh->nlmsg_seq, NLM_F_MULTI,
 					  RTM_NEWTFILTER) <= 0)
 				break;
