x86/PCI: VMD: Synchronize with RCU freeing MSI IRQ descs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] pci: vmd: Synchronize with RCU freeing MSI IRQ descs (Myron Stowe) [1388664]
Rebuild_FUZZ: 96.30%
commit-author Keith Busch <keith.busch@intel.com>
commit ee6ee49fd09fa17c92aadf07961d0ff406fceab8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ee6ee49f.failed

Fix a potential race when disabling MSI/MSI-X on a VMD domain device.  If
the VMD interrupt service is running, it may see a disabled IRQ.  We can
synchronize RCU just before freeing the MSI descriptor.  This is safe since
the irq_desc lock isn't held, and the descriptor is valid even though it is
disabled.  After vmd_msi_free(), though, the handler is reinitialized to
handle_bad_irq(), so we can't let the VMD ISR's list iteration see the
disabled IRQ after this.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by Jon Derrick: <jonathan.derrick@intel.com>
(cherry picked from commit ee6ee49fd09fa17c92aadf07961d0ff406fceab8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/pci/vmd.c
diff --cc arch/x86/pci/vmd.c
index c06f45a0a147,57058520f219..000000000000
--- a/arch/x86/pci/vmd.c
+++ b/arch/x86/pci/vmd.c
@@@ -215,11 -212,15 +215,17 @@@ static int vmd_setup_msi_irqs(struct pc
  	return 0;
  }
  
 -static void vmd_msi_free(struct irq_domain *domain,
 -			struct msi_domain_info *info, unsigned int virq)
 +static void vmd_teardown_msi_irq(unsigned int irq)
  {
 -	struct vmd_irq *vmdirq = irq_get_chip_data(virq);
 +	struct vmd_irq *vmdirq = irq_get_handler_data(irq);
  	unsigned long flags;
  
++<<<<<<< HEAD
++=======
+ 	synchronize_rcu();
+ 
+ 	/* XXX: Potential optimization to rebalance */
++>>>>>>> ee6ee49fd09f (x86/PCI: VMD: Synchronize with RCU freeing MSI IRQ descs)
  	raw_spin_lock_irqsave(&list_lock, flags);
  	vmdirq->irq->count--;
  	raw_spin_unlock_irqrestore(&list_lock, flags);
* Unmerged path arch/x86/pci/vmd.c
