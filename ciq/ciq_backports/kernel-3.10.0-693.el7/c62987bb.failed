bridge: push bridge setting ageing_time down to switchdev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Scott Feldman <sfeldma@gmail.com>
commit c62987bbd8a1a1664f99e89e3959339350a6131e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c62987bb.failed

Use SWITCHDEV_F_SKIP_EOPNOTSUPP to skip over ports in bridge that don't
support setting ageing_time (or setting bridge attrs in general).

If push fails, don't update ageing_time in bridge and return err to user.

If push succeeds, update ageing_time in bridge and run gc_timer now to
recalabrate when to run gc_timer next, based on new ageing_time.

	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c62987bbd8a1a1664f99e89e3959339350a6131e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netlink.c
diff --cc net/bridge/br_netlink.c
index 858d309f4e1a,544ab966d477..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -643,25 -779,454 +643,455 @@@ static int br_dev_newlink(struct net *s
  	return register_netdevice(dev);
  }
  
++<<<<<<< HEAD
++=======
+ static int br_port_slave_changelink(struct net_device *brdev,
+ 				    struct net_device *dev,
+ 				    struct nlattr *tb[],
+ 				    struct nlattr *data[])
+ {
+ 	struct net_bridge *br = netdev_priv(brdev);
+ 	int ret;
+ 
+ 	if (!data)
+ 		return 0;
+ 
+ 	spin_lock_bh(&br->lock);
+ 	ret = br_setport(br_port_get_rtnl(dev), data);
+ 	spin_unlock_bh(&br->lock);
+ 
+ 	return ret;
+ }
+ 
+ static int br_port_fill_slave_info(struct sk_buff *skb,
+ 				   const struct net_device *brdev,
+ 				   const struct net_device *dev)
+ {
+ 	return br_port_fill_attrs(skb, br_port_get_rtnl(dev));
+ }
+ 
+ static size_t br_port_get_slave_size(const struct net_device *brdev,
+ 				     const struct net_device *dev)
+ {
+ 	return br_port_info_size();
+ }
+ 
+ static const struct nla_policy br_policy[IFLA_BR_MAX + 1] = {
+ 	[IFLA_BR_FORWARD_DELAY]	= { .type = NLA_U32 },
+ 	[IFLA_BR_HELLO_TIME]	= { .type = NLA_U32 },
+ 	[IFLA_BR_MAX_AGE]	= { .type = NLA_U32 },
+ 	[IFLA_BR_AGEING_TIME] = { .type = NLA_U32 },
+ 	[IFLA_BR_STP_STATE] = { .type = NLA_U32 },
+ 	[IFLA_BR_PRIORITY] = { .type = NLA_U16 },
+ 	[IFLA_BR_VLAN_FILTERING] = { .type = NLA_U8 },
+ 	[IFLA_BR_VLAN_PROTOCOL] = { .type = NLA_U16 },
+ 	[IFLA_BR_GROUP_FWD_MASK] = { .type = NLA_U16 },
+ 	[IFLA_BR_GROUP_ADDR] = { .type = NLA_BINARY,
+ 				 .len  = ETH_ALEN },
+ 	[IFLA_BR_MCAST_ROUTER] = { .type = NLA_U8 },
+ 	[IFLA_BR_MCAST_SNOOPING] = { .type = NLA_U8 },
+ 	[IFLA_BR_MCAST_QUERY_USE_IFADDR] = { .type = NLA_U8 },
+ 	[IFLA_BR_MCAST_QUERIER] = { .type = NLA_U8 },
+ 	[IFLA_BR_MCAST_HASH_ELASTICITY] = { .type = NLA_U32 },
+ 	[IFLA_BR_MCAST_HASH_MAX] = { .type = NLA_U32 },
+ 	[IFLA_BR_MCAST_LAST_MEMBER_CNT] = { .type = NLA_U32 },
+ 	[IFLA_BR_MCAST_STARTUP_QUERY_CNT] = { .type = NLA_U32 },
+ 	[IFLA_BR_MCAST_LAST_MEMBER_INTVL] = { .type = NLA_U64 },
+ 	[IFLA_BR_MCAST_MEMBERSHIP_INTVL] = { .type = NLA_U64 },
+ 	[IFLA_BR_MCAST_QUERIER_INTVL] = { .type = NLA_U64 },
+ 	[IFLA_BR_MCAST_QUERY_INTVL] = { .type = NLA_U64 },
+ 	[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL] = { .type = NLA_U64 },
+ 	[IFLA_BR_MCAST_STARTUP_QUERY_INTVL] = { .type = NLA_U64 },
+ 	[IFLA_BR_NF_CALL_IPTABLES] = { .type = NLA_U8 },
+ 	[IFLA_BR_NF_CALL_IP6TABLES] = { .type = NLA_U8 },
+ 	[IFLA_BR_NF_CALL_ARPTABLES] = { .type = NLA_U8 },
+ 	[IFLA_BR_VLAN_DEFAULT_PVID] = { .type = NLA_U16 },
+ };
+ 
+ static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
+ 			 struct nlattr *data[])
+ {
+ 	struct net_bridge *br = netdev_priv(brdev);
+ 	int err;
+ 
+ 	if (!data)
+ 		return 0;
+ 
+ 	if (data[IFLA_BR_FORWARD_DELAY]) {
+ 		err = br_set_forward_delay(br, nla_get_u32(data[IFLA_BR_FORWARD_DELAY]));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_HELLO_TIME]) {
+ 		err = br_set_hello_time(br, nla_get_u32(data[IFLA_BR_HELLO_TIME]));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_MAX_AGE]) {
+ 		err = br_set_max_age(br, nla_get_u32(data[IFLA_BR_MAX_AGE]));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_AGEING_TIME]) {
+ 		err = br_set_ageing_time(br, nla_get_u32(data[IFLA_BR_AGEING_TIME]));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_STP_STATE]) {
+ 		u32 stp_enabled = nla_get_u32(data[IFLA_BR_STP_STATE]);
+ 
+ 		br_stp_set_enabled(br, stp_enabled);
+ 	}
+ 
+ 	if (data[IFLA_BR_PRIORITY]) {
+ 		u32 priority = nla_get_u16(data[IFLA_BR_PRIORITY]);
+ 
+ 		br_stp_set_bridge_priority(br, priority);
+ 	}
+ 
+ 	if (data[IFLA_BR_VLAN_FILTERING]) {
+ 		u8 vlan_filter = nla_get_u8(data[IFLA_BR_VLAN_FILTERING]);
+ 
+ 		err = __br_vlan_filter_toggle(br, vlan_filter);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	if (data[IFLA_BR_VLAN_PROTOCOL]) {
+ 		__be16 vlan_proto = nla_get_be16(data[IFLA_BR_VLAN_PROTOCOL]);
+ 
+ 		err = __br_vlan_set_proto(br, vlan_proto);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_VLAN_DEFAULT_PVID]) {
+ 		__u16 defpvid = nla_get_u16(data[IFLA_BR_VLAN_DEFAULT_PVID]);
+ 
+ 		err = __br_vlan_set_default_pvid(br, defpvid);
+ 		if (err)
+ 			return err;
+ 	}
+ #endif
+ 
+ 	if (data[IFLA_BR_GROUP_FWD_MASK]) {
+ 		u16 fwd_mask = nla_get_u16(data[IFLA_BR_GROUP_FWD_MASK]);
+ 
+ 		if (fwd_mask & BR_GROUPFWD_RESTRICTED)
+ 			return -EINVAL;
+ 		br->group_fwd_mask = fwd_mask;
+ 	}
+ 
+ 	if (data[IFLA_BR_GROUP_ADDR]) {
+ 		u8 new_addr[ETH_ALEN];
+ 
+ 		if (nla_len(data[IFLA_BR_GROUP_ADDR]) != ETH_ALEN)
+ 			return -EINVAL;
+ 		memcpy(new_addr, nla_data(data[IFLA_BR_GROUP_ADDR]), ETH_ALEN);
+ 		if (!is_link_local_ether_addr(new_addr))
+ 			return -EINVAL;
+ 		if (new_addr[5] == 1 ||		/* 802.3x Pause address */
+ 		    new_addr[5] == 2 ||		/* 802.3ad Slow protocols */
+ 		    new_addr[5] == 3)		/* 802.1X PAE address */
+ 			return -EINVAL;
+ 		spin_lock_bh(&br->lock);
+ 		memcpy(br->group_addr, new_addr, sizeof(br->group_addr));
+ 		spin_unlock_bh(&br->lock);
+ 		br->group_addr_set = true;
+ 		br_recalculate_fwd_mask(br);
+ 	}
+ 
+ 	if (data[IFLA_BR_FDB_FLUSH])
+ 		br_fdb_flush(br);
+ 
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (data[IFLA_BR_MCAST_ROUTER]) {
+ 		u8 multicast_router = nla_get_u8(data[IFLA_BR_MCAST_ROUTER]);
+ 
+ 		err = br_multicast_set_router(br, multicast_router);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_SNOOPING]) {
+ 		u8 mcast_snooping = nla_get_u8(data[IFLA_BR_MCAST_SNOOPING]);
+ 
+ 		err = br_multicast_toggle(br, mcast_snooping);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_QUERY_USE_IFADDR]) {
+ 		u8 val;
+ 
+ 		val = nla_get_u8(data[IFLA_BR_MCAST_QUERY_USE_IFADDR]);
+ 		br->multicast_query_use_ifaddr = !!val;
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_QUERIER]) {
+ 		u8 mcast_querier = nla_get_u8(data[IFLA_BR_MCAST_QUERIER]);
+ 
+ 		err = br_multicast_set_querier(br, mcast_querier);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_HASH_ELASTICITY]) {
+ 		u32 val = nla_get_u32(data[IFLA_BR_MCAST_HASH_ELASTICITY]);
+ 
+ 		br->hash_elasticity = val;
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_HASH_MAX]) {
+ 		u32 hash_max = nla_get_u32(data[IFLA_BR_MCAST_HASH_MAX]);
+ 
+ 		err = br_multicast_set_hash_max(br, hash_max);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_LAST_MEMBER_CNT]) {
+ 		u32 val = nla_get_u32(data[IFLA_BR_MCAST_LAST_MEMBER_CNT]);
+ 
+ 		br->multicast_last_member_count = val;
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_STARTUP_QUERY_CNT]) {
+ 		u32 val = nla_get_u32(data[IFLA_BR_MCAST_STARTUP_QUERY_CNT]);
+ 
+ 		br->multicast_startup_query_count = val;
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]) {
+ 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]);
+ 
+ 		br->multicast_last_member_interval = clock_t_to_jiffies(val);
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]) {
+ 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]);
+ 
+ 		br->multicast_membership_interval = clock_t_to_jiffies(val);
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_QUERIER_INTVL]) {
+ 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERIER_INTVL]);
+ 
+ 		br->multicast_querier_interval = clock_t_to_jiffies(val);
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_QUERY_INTVL]) {
+ 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_INTVL]);
+ 
+ 		br->multicast_query_interval = clock_t_to_jiffies(val);
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]) {
+ 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]);
+ 
+ 		br->multicast_query_response_interval = clock_t_to_jiffies(val);
+ 	}
+ 
+ 	if (data[IFLA_BR_MCAST_STARTUP_QUERY_INTVL]) {
+ 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_STARTUP_QUERY_INTVL]);
+ 
+ 		br->multicast_startup_query_interval = clock_t_to_jiffies(val);
+ 	}
+ #endif
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+ 	if (data[IFLA_BR_NF_CALL_IPTABLES]) {
+ 		u8 val = nla_get_u8(data[IFLA_BR_NF_CALL_IPTABLES]);
+ 
+ 		br->nf_call_iptables = val ? true : false;
+ 	}
+ 
+ 	if (data[IFLA_BR_NF_CALL_IP6TABLES]) {
+ 		u8 val = nla_get_u8(data[IFLA_BR_NF_CALL_IP6TABLES]);
+ 
+ 		br->nf_call_ip6tables = val ? true : false;
+ 	}
+ 
+ 	if (data[IFLA_BR_NF_CALL_ARPTABLES]) {
+ 		u8 val = nla_get_u8(data[IFLA_BR_NF_CALL_ARPTABLES]);
+ 
+ 		br->nf_call_arptables = val ? true : false;
+ 	}
+ #endif
+ 
+ 	return 0;
+ }
+ 
+ static size_t br_get_size(const struct net_device *brdev)
+ {
+ 	return nla_total_size(sizeof(u32)) +	/* IFLA_BR_FORWARD_DELAY  */
+ 	       nla_total_size(sizeof(u32)) +	/* IFLA_BR_HELLO_TIME */
+ 	       nla_total_size(sizeof(u32)) +	/* IFLA_BR_MAX_AGE */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_AGEING_TIME */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_STP_STATE */
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_PRIORITY */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_VLAN_FILTERING */
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	       nla_total_size(sizeof(__be16)) +	/* IFLA_BR_VLAN_PROTOCOL */
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_VLAN_DEFAULT_PVID */
+ #endif
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_GROUP_FWD_MASK */
+ 	       nla_total_size(sizeof(struct ifla_bridge_id)) +   /* IFLA_BR_ROOT_ID */
+ 	       nla_total_size(sizeof(struct ifla_bridge_id)) +   /* IFLA_BR_BRIDGE_ID */
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_ROOT_PORT */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_ROOT_PATH_COST */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_TOPOLOGY_CHANGE */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_TOPOLOGY_CHANGE_DETECTED */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_HELLO_TIMER */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_TCN_TIMER */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_TOPOLOGY_CHANGE_TIMER */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_GC_TIMER */
+ 	       nla_total_size(ETH_ALEN) +       /* IFLA_BR_GROUP_ADDR */
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_MCAST_ROUTER */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_MCAST_SNOOPING */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_MCAST_QUERY_USE_IFADDR */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_MCAST_QUERIER */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_MCAST_HASH_ELASTICITY */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_MCAST_HASH_MAX */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_MCAST_LAST_MEMBER_CNT */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_MCAST_STARTUP_QUERY_CNT */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_MCAST_LAST_MEMBER_INTVL */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_MCAST_MEMBERSHIP_INTVL */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_MCAST_QUERIER_INTVL */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_MCAST_QUERY_INTVL */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_MCAST_QUERY_RESPONSE_INTVL */
+ 	       nla_total_size(sizeof(u64)) +    /* IFLA_BR_MCAST_STARTUP_QUERY_INTVL */
+ #endif
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_NF_CALL_IPTABLES */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_NF_CALL_IP6TABLES */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_NF_CALL_ARPTABLES */
+ #endif
+ 	       0;
+ }
+ 
+ static int br_fill_info(struct sk_buff *skb, const struct net_device *brdev)
+ {
+ 	struct net_bridge *br = netdev_priv(brdev);
+ 	u32 forward_delay = jiffies_to_clock_t(br->forward_delay);
+ 	u32 hello_time = jiffies_to_clock_t(br->hello_time);
+ 	u32 age_time = jiffies_to_clock_t(br->max_age);
+ 	u32 ageing_time = jiffies_to_clock_t(br->ageing_time);
+ 	u32 stp_enabled = br->stp_enabled;
+ 	u16 priority = (br->bridge_id.prio[0] << 8) | br->bridge_id.prio[1];
+ 	u8 vlan_enabled = br_vlan_enabled(br);
+ 	u64 clockval;
+ 
+ 	clockval = br_timer_value(&br->hello_timer);
+ 	if (nla_put_u64(skb, IFLA_BR_HELLO_TIMER, clockval))
+ 		return -EMSGSIZE;
+ 	clockval = br_timer_value(&br->tcn_timer);
+ 	if (nla_put_u64(skb, IFLA_BR_TCN_TIMER, clockval))
+ 		return -EMSGSIZE;
+ 	clockval = br_timer_value(&br->topology_change_timer);
+ 	if (nla_put_u64(skb, IFLA_BR_TOPOLOGY_CHANGE_TIMER, clockval))
+ 		return -EMSGSIZE;
+ 	clockval = br_timer_value(&br->gc_timer);
+ 	if (nla_put_u64(skb, IFLA_BR_GC_TIMER, clockval))
+ 		return -EMSGSIZE;
+ 
+ 	if (nla_put_u32(skb, IFLA_BR_FORWARD_DELAY, forward_delay) ||
+ 	    nla_put_u32(skb, IFLA_BR_HELLO_TIME, hello_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_MAX_AGE, age_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_AGEING_TIME, ageing_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_STP_STATE, stp_enabled) ||
+ 	    nla_put_u16(skb, IFLA_BR_PRIORITY, priority) ||
+ 	    nla_put_u8(skb, IFLA_BR_VLAN_FILTERING, vlan_enabled) ||
+ 	    nla_put_u16(skb, IFLA_BR_GROUP_FWD_MASK, br->group_fwd_mask) ||
+ 	    nla_put(skb, IFLA_BR_BRIDGE_ID, sizeof(struct ifla_bridge_id),
+ 		    &br->bridge_id) ||
+ 	    nla_put(skb, IFLA_BR_ROOT_ID, sizeof(struct ifla_bridge_id),
+ 		    &br->designated_root) ||
+ 	    nla_put_u16(skb, IFLA_BR_ROOT_PORT, br->root_port) ||
+ 	    nla_put_u32(skb, IFLA_BR_ROOT_PATH_COST, br->root_path_cost) ||
+ 	    nla_put_u8(skb, IFLA_BR_TOPOLOGY_CHANGE, br->topology_change) ||
+ 	    nla_put_u8(skb, IFLA_BR_TOPOLOGY_CHANGE_DETECTED,
+ 		       br->topology_change_detected) ||
+ 	    nla_put(skb, IFLA_BR_GROUP_ADDR, ETH_ALEN, br->group_addr))
+ 		return -EMSGSIZE;
+ 
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	if (nla_put_be16(skb, IFLA_BR_VLAN_PROTOCOL, br->vlan_proto) ||
+ 	    nla_put_u16(skb, IFLA_BR_VLAN_DEFAULT_PVID, br->default_pvid))
+ 		return -EMSGSIZE;
+ #endif
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (nla_put_u8(skb, IFLA_BR_MCAST_ROUTER, br->multicast_router) ||
+ 	    nla_put_u8(skb, IFLA_BR_MCAST_SNOOPING, !br->multicast_disabled) ||
+ 	    nla_put_u8(skb, IFLA_BR_MCAST_QUERY_USE_IFADDR,
+ 		       br->multicast_query_use_ifaddr) ||
+ 	    nla_put_u8(skb, IFLA_BR_MCAST_QUERIER, br->multicast_querier) ||
+ 	    nla_put_u32(skb, IFLA_BR_MCAST_HASH_ELASTICITY,
+ 			br->hash_elasticity) ||
+ 	    nla_put_u32(skb, IFLA_BR_MCAST_HASH_MAX, br->hash_max) ||
+ 	    nla_put_u32(skb, IFLA_BR_MCAST_LAST_MEMBER_CNT,
+ 			br->multicast_last_member_count) ||
+ 	    nla_put_u32(skb, IFLA_BR_MCAST_STARTUP_QUERY_CNT,
+ 			br->multicast_startup_query_count))
+ 		return -EMSGSIZE;
+ 
+ 	clockval = jiffies_to_clock_t(br->multicast_last_member_interval);
+ 	if (nla_put_u64(skb, IFLA_BR_MCAST_LAST_MEMBER_INTVL, clockval))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_membership_interval);
+ 	if (nla_put_u64(skb, IFLA_BR_MCAST_MEMBERSHIP_INTVL, clockval))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_querier_interval);
+ 	if (nla_put_u64(skb, IFLA_BR_MCAST_QUERIER_INTVL, clockval))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_query_interval);
+ 	if (nla_put_u64(skb, IFLA_BR_MCAST_QUERY_INTVL, clockval))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_query_response_interval);
+ 	if (nla_put_u64(skb, IFLA_BR_MCAST_QUERY_RESPONSE_INTVL, clockval))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_startup_query_interval);
+ 	if (nla_put_u64(skb, IFLA_BR_MCAST_STARTUP_QUERY_INTVL, clockval))
+ 		return -EMSGSIZE;
+ #endif
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+ 	if (nla_put_u8(skb, IFLA_BR_NF_CALL_IPTABLES,
+ 		       br->nf_call_iptables ? 1 : 0) ||
+ 	    nla_put_u8(skb, IFLA_BR_NF_CALL_IP6TABLES,
+ 		       br->nf_call_ip6tables ? 1 : 0) ||
+ 	    nla_put_u8(skb, IFLA_BR_NF_CALL_ARPTABLES,
+ 		       br->nf_call_arptables ? 1 : 0))
+ 		return -EMSGSIZE;
+ #endif
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c62987bbd8a1 (bridge: push bridge setting ageing_time down to switchdev)
  static size_t br_get_link_af_size(const struct net_device *dev)
  {
 -	struct net_bridge_port *p;
 -	struct net_bridge *br;
 -	int num_vlans = 0;
 -
 -	if (br_port_exists(dev)) {
 -		p = br_port_get_rtnl(dev);
 -		num_vlans = br_get_num_vlan_infos(nbp_vlan_group(p),
 -						  RTEXT_FILTER_BRVLAN);
 -	} else if (dev->priv_flags & IFF_EBRIDGE) {
 -		br = netdev_priv(dev);
 -		num_vlans = br_get_num_vlan_infos(br_vlan_group(br),
 -						  RTEXT_FILTER_BRVLAN);
 -	}
 +	struct net_port_vlans *pv;
 +
 +	if (br_port_exists(dev))
 +		pv = nbp_get_vlan_info(br_port_get_rtnl(dev));
 +	else if (dev->priv_flags & IFF_EBRIDGE)
 +		pv = br_get_vlan_info((struct net_bridge *)netdev_priv(dev));
 +	else
 +		return 0;
 +
 +	if (!pv)
 +		return 0;
  
  	/* Each VLAN is returned in bridge_vlan_info along with flags */
 -	return num_vlans * nla_total_size(sizeof(struct bridge_vlan_info));
 +	return pv->num_vlans * nla_total_size(sizeof(struct bridge_vlan_info));
  }
  
 -static struct rtnl_af_ops br_af_ops __read_mostly = {
 +static struct rtnl_af_ops br_af_ops = {
  	.family			= AF_BRIDGE,
  	.get_link_af_size	= br_get_link_af_size,
  };
diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c
index b73eaba85667..88173c3e76ff 100644
--- a/net/bridge/br_ioctl.c
+++ b/net/bridge/br_ioctl.c
@@ -200,8 +200,7 @@ static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		if (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))
 			return -EPERM;
 
-		br->ageing_time = clock_t_to_jiffies(args[1]);
-		return 0;
+		return br_set_ageing_time(br, args[1]);
 
 	case BRCTL_GET_PORT_INFO:
 	{
* Unmerged path net/bridge/br_netlink.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index b75519ca3c51..75991be1736b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -783,6 +783,7 @@ void __br_set_forward_delay(struct net_bridge *br, unsigned long t);
 int br_set_forward_delay(struct net_bridge *br, unsigned long x);
 int br_set_hello_time(struct net_bridge *br, unsigned long x);
 int br_set_max_age(struct net_bridge *br, unsigned long x);
+int br_set_ageing_time(struct net_bridge *br, u32 ageing_time);
 
 
 /* br_stp_if.c */
diff --git a/net/bridge/br_stp.c b/net/bridge/br_stp.c
index 48a6519f8bc7..1722e4e310b5 100644
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@ -550,6 +550,29 @@ int br_set_max_age(struct net_bridge *br, unsigned long val)
 
 }
 
+int br_set_ageing_time(struct net_bridge *br, u32 ageing_time)
+{
+	struct switchdev_attr attr = {
+		.id = SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME,
+		.flags = SWITCHDEV_F_SKIP_EOPNOTSUPP,
+		.u.ageing_time = ageing_time,
+	};
+	unsigned long t = clock_t_to_jiffies(ageing_time);
+	int err;
+
+	if (t < BR_MIN_AGEING_TIME || t > BR_MAX_AGEING_TIME)
+		return -ERANGE;
+
+	err = switchdev_port_attr_set(br->dev, &attr);
+	if (err)
+		return err;
+
+	br->ageing_time = t;
+	mod_timer(&br->gc_timer, jiffies);
+
+	return 0;
+}
+
 void __br_set_forward_delay(struct net_bridge *br, unsigned long t)
 {
 	br->bridge_forward_delay = t;
diff --git a/net/bridge/br_sysfs_br.c b/net/bridge/br_sysfs_br.c
index a3eb35988a8a..2c35b02e9880 100644
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@ -104,8 +104,7 @@ static ssize_t show_ageing_time(struct device *d,
 
 static int set_ageing_time(struct net_bridge *br, unsigned long val)
 {
-	br->ageing_time = clock_t_to_jiffies(val);
-	return 0;
+	return br_set_ageing_time(br, val);
 }
 
 static ssize_t store_ageing_time(struct device *d,
