amd-xgbe: Add support for SFP+ modules

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit abf0a1c2b26ad964d19b143ce46735e1b0667f29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/abf0a1c2.failed

Add support for recognizing and using SFP+ modules directly. This includes
using the I2C support to read and interpret the information returned from
an SFP+ module and configuring things properly.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit abf0a1c2b26ad964d19b143ce46735e1b0667f29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/Kconfig
#	drivers/net/ethernet/amd/xgbe/xgbe-common.h
#	drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
#	drivers/net/ethernet/amd/xgbe/xgbe-phy-v1.c
#	drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc drivers/net/ethernet/amd/Kconfig
index 13d74aa4033d,7ab6efbe4189..000000000000
--- a/drivers/net/ethernet/amd/Kconfig
+++ b/drivers/net/ethernet/amd/Kconfig
@@@ -179,4 -171,34 +179,37 @@@ config SUNLANC
  	  To compile this driver as a module, choose M here: the module
  	  will be called sunlance.
  
++<<<<<<< HEAD
++=======
+ config AMD_XGBE
+ 	tristate "AMD 10GbE Ethernet driver"
+ 	depends on ((OF_NET && OF_ADDRESS) || ACPI || PCI) && HAS_IOMEM && HAS_DMA
+ 	depends on X86 || ARM64 || COMPILE_TEST
+ 	select BITREVERSE
+ 	select CRC32
+ 	select PTP_1588_CLOCK
+ 	select PHYLIB
+ 	select AMD_XGBE_HAVE_ECC if X86
+ 	---help---
+ 	  This driver supports the AMD 10GbE Ethernet device found on an
+ 	  AMD SoC.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called amd-xgbe.
+ 
+ config AMD_XGBE_DCB
+ 	bool "Data Center Bridging (DCB) support"
+ 	default n
+ 	depends on AMD_XGBE && DCB
+ 	---help---
+ 	  Say Y here to enable Data Center Bridging (DCB) support in the
+ 	  driver.
+ 
+ 	  If unsure, say N.
+ 
+ config AMD_XGBE_HAVE_ECC
+ 	bool
+ 	default n
+ 
++>>>>>>> abf0a1c2b26a (amd-xgbe: Add support for SFP+ modules)
  endif # NET_VENDOR_AMD
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-common.h
index 3373e9ef2003,b7140f9e9cc6..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
@@@ -743,16 -858,232 +743,234 @@@
  #define MTL_TSA_SP			0x00
  #define MTL_TSA_ETS			0x02
  
 -/* PCS register offsets */
 -#define PCS_V1_WINDOW_SELECT		0x03fc
 -#define PCS_V2_WINDOW_DEF		0x9060
 -#define PCS_V2_WINDOW_SELECT		0x9064
  
 -/* PCS register entry bit positions and sizes */
 -#define PCS_V2_WINDOW_DEF_OFFSET_INDEX	6
 -#define PCS_V2_WINDOW_DEF_OFFSET_WIDTH	14
 -#define PCS_V2_WINDOW_DEF_SIZE_INDEX	2
 -#define PCS_V2_WINDOW_DEF_SIZE_WIDTH	4
 +/* PCS MMD select register offset
 + *  The MMD select register is used for accessing PCS registers
 + *  when the underlying APB3 interface is using indirect addressing.
 + *  Indirect addressing requires accessing registers in two phases,
 + *  an address phase and a data phase.  The address phases requires
 + *  writing an address selection value to the MMD select regiesters.
 + */
 +#define PCS_MMD_SELECT			0xff
  
++<<<<<<< HEAD
++=======
+ /* SerDes integration register offsets */
+ #define SIR0_KR_RT_1			0x002c
+ #define SIR0_STATUS			0x0040
+ #define SIR1_SPEED			0x0000
+ 
+ /* SerDes integration register entry bit positions and sizes */
+ #define SIR0_KR_RT_1_RESET_INDEX	11
+ #define SIR0_KR_RT_1_RESET_WIDTH	1
+ #define SIR0_STATUS_RX_READY_INDEX	0
+ #define SIR0_STATUS_RX_READY_WIDTH	1
+ #define SIR0_STATUS_TX_READY_INDEX	8
+ #define SIR0_STATUS_TX_READY_WIDTH	1
+ #define SIR1_SPEED_CDR_RATE_INDEX	12
+ #define SIR1_SPEED_CDR_RATE_WIDTH	4
+ #define SIR1_SPEED_DATARATE_INDEX	4
+ #define SIR1_SPEED_DATARATE_WIDTH	2
+ #define SIR1_SPEED_PLLSEL_INDEX		3
+ #define SIR1_SPEED_PLLSEL_WIDTH		1
+ #define SIR1_SPEED_RATECHANGE_INDEX	6
+ #define SIR1_SPEED_RATECHANGE_WIDTH	1
+ #define SIR1_SPEED_TXAMP_INDEX		8
+ #define SIR1_SPEED_TXAMP_WIDTH		4
+ #define SIR1_SPEED_WORDMODE_INDEX	0
+ #define SIR1_SPEED_WORDMODE_WIDTH	3
+ 
+ /* SerDes RxTx register offsets */
+ #define RXTX_REG6			0x0018
+ #define RXTX_REG20			0x0050
+ #define RXTX_REG22			0x0058
+ #define RXTX_REG114			0x01c8
+ #define RXTX_REG129			0x0204
+ 
+ /* SerDes RxTx register entry bit positions and sizes */
+ #define RXTX_REG6_RESETB_RXD_INDEX	8
+ #define RXTX_REG6_RESETB_RXD_WIDTH	1
+ #define RXTX_REG20_BLWC_ENA_INDEX	2
+ #define RXTX_REG20_BLWC_ENA_WIDTH	1
+ #define RXTX_REG114_PQ_REG_INDEX	9
+ #define RXTX_REG114_PQ_REG_WIDTH	7
+ #define RXTX_REG129_RXDFE_CONFIG_INDEX	14
+ #define RXTX_REG129_RXDFE_CONFIG_WIDTH	2
+ 
+ /* MAC Control register offsets */
+ #define XP_PROP_0			0x0000
+ #define XP_PROP_1			0x0004
+ #define XP_PROP_2			0x0008
+ #define XP_PROP_3			0x000c
+ #define XP_PROP_4			0x0010
+ #define XP_PROP_5			0x0014
+ #define XP_MAC_ADDR_LO			0x0020
+ #define XP_MAC_ADDR_HI			0x0024
+ #define XP_ECC_ISR			0x0030
+ #define XP_ECC_IER			0x0034
+ #define XP_ECC_CNT0			0x003c
+ #define XP_ECC_CNT1			0x0040
+ #define XP_DRIVER_INT_REQ		0x0060
+ #define XP_DRIVER_INT_RO		0x0064
+ #define XP_DRIVER_SCRATCH_0		0x0068
+ #define XP_DRIVER_SCRATCH_1		0x006c
+ #define XP_INT_EN			0x0078
+ #define XP_I2C_MUTEX			0x0080
+ #define XP_MDIO_MUTEX			0x0084
+ 
+ /* MAC Control register entry bit positions and sizes */
+ #define XP_DRIVER_INT_REQ_REQUEST_INDEX		0
+ #define XP_DRIVER_INT_REQ_REQUEST_WIDTH		1
+ #define XP_DRIVER_INT_RO_STATUS_INDEX		0
+ #define XP_DRIVER_INT_RO_STATUS_WIDTH		1
+ #define XP_DRIVER_SCRATCH_0_COMMAND_INDEX	0
+ #define XP_DRIVER_SCRATCH_0_COMMAND_WIDTH	8
+ #define XP_DRIVER_SCRATCH_0_SUB_COMMAND_INDEX	8
+ #define XP_DRIVER_SCRATCH_0_SUB_COMMAND_WIDTH	8
+ #define XP_ECC_CNT0_RX_DED_INDEX		24
+ #define XP_ECC_CNT0_RX_DED_WIDTH		8
+ #define XP_ECC_CNT0_RX_SEC_INDEX		16
+ #define XP_ECC_CNT0_RX_SEC_WIDTH		8
+ #define XP_ECC_CNT0_TX_DED_INDEX		8
+ #define XP_ECC_CNT0_TX_DED_WIDTH		8
+ #define XP_ECC_CNT0_TX_SEC_INDEX		0
+ #define XP_ECC_CNT0_TX_SEC_WIDTH		8
+ #define XP_ECC_CNT1_DESC_DED_INDEX		8
+ #define XP_ECC_CNT1_DESC_DED_WIDTH		8
+ #define XP_ECC_CNT1_DESC_SEC_INDEX		0
+ #define XP_ECC_CNT1_DESC_SEC_WIDTH		8
+ #define XP_ECC_IER_DESC_DED_INDEX		0
+ #define XP_ECC_IER_DESC_DED_WIDTH		1
+ #define XP_ECC_IER_DESC_SEC_INDEX		1
+ #define XP_ECC_IER_DESC_SEC_WIDTH		1
+ #define XP_ECC_IER_RX_DED_INDEX			2
+ #define XP_ECC_IER_RX_DED_WIDTH			1
+ #define XP_ECC_IER_RX_SEC_INDEX			3
+ #define XP_ECC_IER_RX_SEC_WIDTH			1
+ #define XP_ECC_IER_TX_DED_INDEX			4
+ #define XP_ECC_IER_TX_DED_WIDTH			1
+ #define XP_ECC_IER_TX_SEC_INDEX			5
+ #define XP_ECC_IER_TX_SEC_WIDTH			1
+ #define XP_ECC_ISR_DESC_DED_INDEX		0
+ #define XP_ECC_ISR_DESC_DED_WIDTH		1
+ #define XP_ECC_ISR_DESC_SEC_INDEX		1
+ #define XP_ECC_ISR_DESC_SEC_WIDTH		1
+ #define XP_ECC_ISR_RX_DED_INDEX			2
+ #define XP_ECC_ISR_RX_DED_WIDTH			1
+ #define XP_ECC_ISR_RX_SEC_INDEX			3
+ #define XP_ECC_ISR_RX_SEC_WIDTH			1
+ #define XP_ECC_ISR_TX_DED_INDEX			4
+ #define XP_ECC_ISR_TX_DED_WIDTH			1
+ #define XP_ECC_ISR_TX_SEC_INDEX			5
+ #define XP_ECC_ISR_TX_SEC_WIDTH			1
+ #define XP_I2C_MUTEX_BUSY_INDEX			31
+ #define XP_I2C_MUTEX_BUSY_WIDTH			1
+ #define XP_I2C_MUTEX_ID_INDEX			29
+ #define XP_I2C_MUTEX_ID_WIDTH			2
+ #define XP_I2C_MUTEX_ACTIVE_INDEX		0
+ #define XP_I2C_MUTEX_ACTIVE_WIDTH		1
+ #define XP_MAC_ADDR_HI_VALID_INDEX		31
+ #define XP_MAC_ADDR_HI_VALID_WIDTH		1
+ #define XP_PROP_0_CONN_TYPE_INDEX		28
+ #define XP_PROP_0_CONN_TYPE_WIDTH		3
+ #define XP_PROP_0_MDIO_ADDR_INDEX		16
+ #define XP_PROP_0_MDIO_ADDR_WIDTH		5
+ #define XP_PROP_0_PORT_ID_INDEX			0
+ #define XP_PROP_0_PORT_ID_WIDTH			8
+ #define XP_PROP_0_PORT_MODE_INDEX		8
+ #define XP_PROP_0_PORT_MODE_WIDTH		4
+ #define XP_PROP_0_PORT_SPEEDS_INDEX		23
+ #define XP_PROP_0_PORT_SPEEDS_WIDTH		4
+ #define XP_PROP_1_MAX_RX_DMA_INDEX		24
+ #define XP_PROP_1_MAX_RX_DMA_WIDTH		5
+ #define XP_PROP_1_MAX_RX_QUEUES_INDEX		8
+ #define XP_PROP_1_MAX_RX_QUEUES_WIDTH		5
+ #define XP_PROP_1_MAX_TX_DMA_INDEX		16
+ #define XP_PROP_1_MAX_TX_DMA_WIDTH		5
+ #define XP_PROP_1_MAX_TX_QUEUES_INDEX		0
+ #define XP_PROP_1_MAX_TX_QUEUES_WIDTH		5
+ #define XP_PROP_2_RX_FIFO_SIZE_INDEX		16
+ #define XP_PROP_2_RX_FIFO_SIZE_WIDTH		16
+ #define XP_PROP_2_TX_FIFO_SIZE_INDEX		0
+ #define XP_PROP_2_TX_FIFO_SIZE_WIDTH		16
+ #define XP_PROP_3_GPIO_MASK_INDEX		28
+ #define XP_PROP_3_GPIO_MASK_WIDTH		4
+ #define XP_PROP_3_GPIO_MOD_ABS_INDEX		20
+ #define XP_PROP_3_GPIO_MOD_ABS_WIDTH		4
+ #define XP_PROP_3_GPIO_RATE_SELECT_INDEX	16
+ #define XP_PROP_3_GPIO_RATE_SELECT_WIDTH	4
+ #define XP_PROP_3_GPIO_RX_LOS_INDEX		24
+ #define XP_PROP_3_GPIO_RX_LOS_WIDTH		4
+ #define XP_PROP_3_GPIO_TX_FAULT_INDEX		12
+ #define XP_PROP_3_GPIO_TX_FAULT_WIDTH		4
+ #define XP_PROP_3_GPIO_ADDR_INDEX		8
+ #define XP_PROP_3_GPIO_ADDR_WIDTH		3
+ #define XP_PROP_4_MUX_ADDR_HI_INDEX		8
+ #define XP_PROP_4_MUX_ADDR_HI_WIDTH		5
+ #define XP_PROP_4_MUX_ADDR_LO_INDEX		0
+ #define XP_PROP_4_MUX_ADDR_LO_WIDTH		3
+ #define XP_PROP_4_MUX_CHAN_INDEX		4
+ #define XP_PROP_4_MUX_CHAN_WIDTH		3
+ 
+ /* I2C Control register offsets */
+ #define IC_CON					0x0000
+ #define IC_TAR					0x0004
+ #define IC_DATA_CMD				0x0010
+ #define IC_INTR_STAT				0x002c
+ #define IC_INTR_MASK				0x0030
+ #define IC_RAW_INTR_STAT			0x0034
+ #define IC_CLR_INTR				0x0040
+ #define IC_CLR_TX_ABRT				0x0054
+ #define IC_CLR_STOP_DET				0x0060
+ #define IC_ENABLE				0x006c
+ #define IC_TXFLR				0x0074
+ #define IC_RXFLR				0x0078
+ #define IC_TX_ABRT_SOURCE			0x0080
+ #define IC_ENABLE_STATUS			0x009c
+ #define IC_COMP_PARAM_1				0x00f4
+ 
+ /* I2C Control register entry bit positions and sizes */
+ #define IC_COMP_PARAM_1_MAX_SPEED_MODE_INDEX	2
+ #define IC_COMP_PARAM_1_MAX_SPEED_MODE_WIDTH	2
+ #define IC_COMP_PARAM_1_RX_BUFFER_DEPTH_INDEX	8
+ #define IC_COMP_PARAM_1_RX_BUFFER_DEPTH_WIDTH	8
+ #define IC_COMP_PARAM_1_TX_BUFFER_DEPTH_INDEX	16
+ #define IC_COMP_PARAM_1_TX_BUFFER_DEPTH_WIDTH	8
+ #define IC_CON_MASTER_MODE_INDEX		0
+ #define IC_CON_MASTER_MODE_WIDTH		1
+ #define IC_CON_RESTART_EN_INDEX			5
+ #define IC_CON_RESTART_EN_WIDTH			1
+ #define IC_CON_RX_FIFO_FULL_HOLD_INDEX		9
+ #define IC_CON_RX_FIFO_FULL_HOLD_WIDTH		1
+ #define IC_CON_SLAVE_DISABLE_INDEX		6
+ #define IC_CON_SLAVE_DISABLE_WIDTH		1
+ #define IC_CON_SPEED_INDEX			1
+ #define IC_CON_SPEED_WIDTH			2
+ #define IC_DATA_CMD_CMD_INDEX			8
+ #define IC_DATA_CMD_CMD_WIDTH			1
+ #define IC_DATA_CMD_STOP_INDEX			9
+ #define IC_DATA_CMD_STOP_WIDTH			1
+ #define IC_ENABLE_ABORT_INDEX			1
+ #define IC_ENABLE_ABORT_WIDTH			1
+ #define IC_ENABLE_EN_INDEX			0
+ #define IC_ENABLE_EN_WIDTH			1
+ #define IC_ENABLE_STATUS_EN_INDEX		0
+ #define IC_ENABLE_STATUS_EN_WIDTH		1
+ #define IC_INTR_MASK_TX_EMPTY_INDEX		4
+ #define IC_INTR_MASK_TX_EMPTY_WIDTH		1
+ #define IC_RAW_INTR_STAT_RX_FULL_INDEX		2
+ #define IC_RAW_INTR_STAT_RX_FULL_WIDTH		1
+ #define IC_RAW_INTR_STAT_STOP_DET_INDEX		9
+ #define IC_RAW_INTR_STAT_STOP_DET_WIDTH		1
+ #define IC_RAW_INTR_STAT_TX_ABRT_INDEX		6
+ #define IC_RAW_INTR_STAT_TX_ABRT_WIDTH		1
+ #define IC_RAW_INTR_STAT_TX_EMPTY_INDEX		4
+ #define IC_RAW_INTR_STAT_TX_EMPTY_WIDTH		1
+ 
+ /* I2C Control register value */
+ #define IC_TX_ABRT_7B_ADDR_NOACK		0x0001
+ #define IC_TX_ABRT_ARB_LOST			0x1000
++>>>>>>> abf0a1c2b26a (amd-xgbe: Add support for SFP+ modules)
  
  /* Descriptor/Packet entry bit positions and sizes */
  #define RX_PACKET_ERRORS_CRC_INDEX		2
@@@ -838,6 -1225,76 +1056,79 @@@
  #define MDIO_AN_COMP_STAT		0x0030
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifndef MDIO_AN_INTMASK
+ #define MDIO_AN_INTMASK			0x8001
+ #endif
+ 
+ #ifndef MDIO_AN_INT
+ #define MDIO_AN_INT			0x8002
+ #endif
+ 
+ #ifndef MDIO_VEND2_AN_ADVERTISE
+ #define MDIO_VEND2_AN_ADVERTISE		0x0004
+ #endif
+ 
+ #ifndef MDIO_VEND2_AN_LP_ABILITY
+ #define MDIO_VEND2_AN_LP_ABILITY	0x0005
+ #endif
+ 
+ #ifndef MDIO_VEND2_AN_CTRL
+ #define MDIO_VEND2_AN_CTRL		0x8001
+ #endif
+ 
+ #ifndef MDIO_VEND2_AN_STAT
+ #define MDIO_VEND2_AN_STAT		0x8002
+ #endif
+ 
+ #ifndef MDIO_CTRL1_SPEED1G
+ #define MDIO_CTRL1_SPEED1G		(MDIO_CTRL1_SPEED10G & ~BMCR_SPEED100)
+ #endif
+ 
+ #ifndef MDIO_VEND2_CTRL1_AN_ENABLE
+ #define MDIO_VEND2_CTRL1_AN_ENABLE	BIT(12)
+ #endif
+ 
+ #ifndef MDIO_VEND2_CTRL1_AN_RESTART
+ #define MDIO_VEND2_CTRL1_AN_RESTART	BIT(9)
+ #endif
+ 
+ #ifndef MDIO_VEND2_CTRL1_SS6
+ #define MDIO_VEND2_CTRL1_SS6		BIT(6)
+ #endif
+ 
+ #ifndef MDIO_VEND2_CTRL1_SS13
+ #define MDIO_VEND2_CTRL1_SS13		BIT(13)
+ #endif
+ 
+ /* MDIO mask values */
+ #define XGBE_AN_CL73_INT_CMPLT		BIT(0)
+ #define XGBE_AN_CL73_INC_LINK		BIT(1)
+ #define XGBE_AN_CL73_PG_RCV		BIT(2)
+ #define XGBE_AN_CL73_INT_MASK		0x07
+ 
+ #define XGBE_XNP_MCF_NULL_MESSAGE	0x001
+ #define XGBE_XNP_ACK_PROCESSED		BIT(12)
+ #define XGBE_XNP_MP_FORMATTED		BIT(13)
+ #define XGBE_XNP_NP_EXCHANGE		BIT(15)
+ 
+ #define XGBE_KR_TRAINING_START		BIT(0)
+ #define XGBE_KR_TRAINING_ENABLE		BIT(1)
+ 
+ #define XGBE_PCS_CL37_BP		BIT(12)
+ 
+ #define XGBE_AN_CL37_INT_CMPLT		BIT(0)
+ #define XGBE_AN_CL37_INT_MASK		0x01
+ 
+ #define XGBE_AN_CL37_HD_MASK		0x40
+ #define XGBE_AN_CL37_FD_MASK		0x20
+ 
+ #define XGBE_AN_CL37_PCS_MODE_MASK	0x06
+ #define XGBE_AN_CL37_PCS_MODE_BASEX	0x00
+ #define XGBE_AN_CL37_PCS_MODE_SGMII	0x04
+ #define XGBE_AN_CL37_TX_CONFIG_MASK	0x08
++>>>>>>> abf0a1c2b26a (amd-xgbe: Add support for SFP+ modules)
  
  /* Bit setting and getting macros
   *  The get macro will extract the current bit field value from within
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
index 8514b5841ecd,622675ae4de6..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
@@@ -124,73 -125,958 +124,989 @@@
  #include "xgbe.h"
  #include "xgbe-common.h"
  
 -static void xgbe_an37_clear_interrupts(struct xgbe_prv_data *pdata)
 +
 +static int xgbe_mdio_read(struct mii_bus *mii, int prtad, int mmd_reg)
  {
 -	int reg;
 +	struct xgbe_prv_data *pdata = mii->priv;
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	int mmd_data;
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT);
 -	reg &= ~XGBE_AN_CL37_INT_MASK;
 -	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT, reg);
 +	DBGPR_MDIO("-->xgbe_mdio_read: prtad=%#x mmd_reg=%#x\n",
 +		   prtad, mmd_reg);
 +
 +	mmd_data = hw_if->read_mmd_regs(pdata, prtad, mmd_reg);
 +
 +	DBGPR_MDIO("<--xgbe_mdio_read: mmd_data=%#x\n", mmd_data);
 +
 +	return mmd_data;
  }
  
 -static void xgbe_an37_disable_interrupts(struct xgbe_prv_data *pdata)
 +static int xgbe_mdio_write(struct mii_bus *mii, int prtad, int mmd_reg,
 +			   u16 mmd_val)
  {
 -	int reg;
 +	struct xgbe_prv_data *pdata = mii->priv;
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	int mmd_data = mmd_val;
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
 -	reg &= ~XGBE_AN_CL37_INT_MASK;
 -	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
 +	DBGPR_MDIO("-->xgbe_mdio_write: prtad=%#x mmd_reg=%#x mmd_data=%#x\n",
 +		   prtad, mmd_reg, mmd_data);
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL);
 -	reg &= ~XGBE_PCS_CL37_BP;
 -	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL, reg);
 +	hw_if->write_mmd_regs(pdata, prtad, mmd_reg, mmd_data);
 +
 +	DBGPR_MDIO("<--xgbe_mdio_write\n");
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static void xgbe_adjust_link(struct net_device *netdev)
++=======
+ static void xgbe_an37_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL);
+ 	reg |= XGBE_PCS_CL37_BP;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL, reg);
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
+ 	reg |= XGBE_AN_CL37_INT_MASK;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
+ }
+ 
+ static void xgbe_an73_clear_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, 0);
+ }
+ 
+ static void xgbe_an73_disable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, 0);
+ }
+ 
+ static void xgbe_an73_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, XGBE_AN_CL73_INT_MASK);
+ }
+ 
+ static void xgbe_an_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_enable_interrupts(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_enable_interrupts(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_clear_interrupts_all(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_clear_interrupts(pdata);
+ 	xgbe_an37_clear_interrupts(pdata);
+ }
+ 
+ static void xgbe_an73_enable_kr_training(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 
+ 	reg |= XGBE_KR_TRAINING_ENABLE;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, reg);
+ }
+ 
+ static void xgbe_an73_disable_kr_training(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 
+ 	reg &= ~XGBE_KR_TRAINING_ENABLE;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, reg);
+ }
+ 
+ static void xgbe_kr_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Enable KR training */
+ 	xgbe_an73_enable_kr_training(pdata);
+ 
+ 	/* Set MAC to 10G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_10000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KR);
+ }
+ 
+ static void xgbe_kx_2500_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 2.5G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_2500);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KX_2500);
+ }
+ 
+ static void xgbe_kx_1000_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KX_1000);
+ }
+ 
+ static void xgbe_sfi_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 10G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_10000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SFI);
+ }
+ 
+ static void xgbe_x_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_X);
+ }
+ 
+ static void xgbe_sgmii_1000_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SGMII_1000);
+ }
+ 
+ static void xgbe_sgmii_100_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SGMII_100);
+ }
+ 
+ static enum xgbe_mode xgbe_cur_mode(struct xgbe_prv_data *pdata)
+ {
+ 	return pdata->phy_if.phy_impl.cur_mode(pdata);
+ }
+ 
+ static bool xgbe_in_kr_mode(struct xgbe_prv_data *pdata)
+ {
+ 	return (xgbe_cur_mode(pdata) == XGBE_MODE_KR);
+ }
+ 
+ static void xgbe_change_mode(struct xgbe_prv_data *pdata,
+ 			     enum xgbe_mode mode)
+ {
+ 	switch (mode) {
+ 	case XGBE_MODE_KX_1000:
+ 		xgbe_kx_1000_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_KX_2500:
+ 		xgbe_kx_2500_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_KR:
+ 		xgbe_kr_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_SGMII_100:
+ 		xgbe_sgmii_100_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_SGMII_1000:
+ 		xgbe_sgmii_1000_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_X:
+ 		xgbe_x_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_SFI:
+ 		xgbe_sfi_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_UNKNOWN:
+ 		break;
+ 	default:
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "invalid operation mode requested (%u)\n", mode);
+ 	}
+ }
+ 
+ static void xgbe_switch_mode(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_change_mode(pdata, pdata->phy_if.phy_impl.switch_mode(pdata));
+ }
+ 
+ static void xgbe_set_mode(struct xgbe_prv_data *pdata,
+ 			  enum xgbe_mode mode)
+ {
+ 	if (mode == xgbe_cur_mode(pdata))
+ 		return;
+ 
+ 	xgbe_change_mode(pdata, mode);
+ }
+ 
+ static bool xgbe_use_mode(struct xgbe_prv_data *pdata,
+ 			  enum xgbe_mode mode)
+ {
+ 	return pdata->phy_if.phy_impl.use_mode(pdata, mode);
+ }
+ 
+ static void xgbe_an37_set(struct xgbe_prv_data *pdata, bool enable,
+ 			  bool restart)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_CTRL1);
+ 	reg &= ~MDIO_VEND2_CTRL1_AN_ENABLE;
+ 
+ 	if (enable)
+ 		reg |= MDIO_VEND2_CTRL1_AN_ENABLE;
+ 
+ 	if (restart)
+ 		reg |= MDIO_VEND2_CTRL1_AN_RESTART;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_CTRL1, reg);
+ }
+ 
+ static void xgbe_an37_restart(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an37_enable_interrupts(pdata);
+ 	xgbe_an37_set(pdata, true, true);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN enabled/restarted\n");
+ }
+ 
+ static void xgbe_an37_disable(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an37_set(pdata, false, false);
+ 	xgbe_an37_disable_interrupts(pdata);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN disabled\n");
+ }
+ 
+ static void xgbe_an73_set(struct xgbe_prv_data *pdata, bool enable,
+ 			  bool restart)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1);
+ 	reg &= ~MDIO_AN_CTRL1_ENABLE;
+ 
+ 	if (enable)
+ 		reg |= MDIO_AN_CTRL1_ENABLE;
+ 
+ 	if (restart)
+ 		reg |= MDIO_AN_CTRL1_RESTART;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_CTRL1, reg);
+ }
+ 
+ static void xgbe_an73_restart(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_enable_interrupts(pdata);
+ 	xgbe_an73_set(pdata, true, true);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN enabled/restarted\n");
+ }
+ 
+ static void xgbe_an73_disable(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_set(pdata, false, false);
+ 	xgbe_an73_disable_interrupts(pdata);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN disabled\n");
+ }
+ 
+ static void xgbe_an_restart(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_restart(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_restart(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_disable(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_disable(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_disable(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_disable_all(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_disable(pdata);
+ 	xgbe_an37_disable(pdata);
+ }
+ 
+ static enum xgbe_an xgbe_an73_tx_training(struct xgbe_prv_data *pdata,
+ 					  enum xgbe_rx *state)
+ {
+ 	unsigned int ad_reg, lp_reg, reg;
+ 
+ 	*state = XGBE_RX_COMPLETE;
+ 
+ 	/* If we're not in KR mode then we're done */
+ 	if (!xgbe_in_kr_mode(pdata))
+ 		return XGBE_AN_PAGE_RECEIVED;
+ 
+ 	/* Enable/Disable FEC */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 2);
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_FECCTRL);
+ 	reg &= ~(MDIO_PMA_10GBR_FECABLE_ABLE | MDIO_PMA_10GBR_FECABLE_ERRABLE);
+ 	if ((ad_reg & 0xc000) && (lp_reg & 0xc000))
+ 		reg |= pdata->fec_ability;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_FECCTRL, reg);
+ 
+ 	/* Start KR training */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 	if (reg & XGBE_KR_TRAINING_ENABLE) {
+ 		if (pdata->phy_if.phy_impl.kr_training_pre)
+ 			pdata->phy_if.phy_impl.kr_training_pre(pdata);
+ 
+ 		reg |= XGBE_KR_TRAINING_START;
+ 		XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL,
+ 			    reg);
+ 
+ 		if (pdata->phy_if.phy_impl.kr_training_post)
+ 			pdata->phy_if.phy_impl.kr_training_post(pdata);
+ 
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "KR training initiated\n");
+ 	}
+ 
+ 	return XGBE_AN_PAGE_RECEIVED;
+ }
+ 
+ static enum xgbe_an xgbe_an73_tx_xnp(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	u16 msg;
+ 
+ 	*state = XGBE_RX_XNP;
+ 
+ 	msg = XGBE_XNP_MCF_NULL_MESSAGE;
+ 	msg |= XGBE_XNP_MP_FORMATTED;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP + 2, 0);
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP + 1, 0);
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP, msg);
+ 
+ 	return XGBE_AN_PAGE_RECEIVED;
+ }
+ 
+ static enum xgbe_an xgbe_an73_rx_bpa(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	unsigned int link_support;
+ 	unsigned int reg, ad_reg, lp_reg;
+ 
+ 	/* Read Base Ability register 2 first */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 1);
+ 
+ 	/* Check for a supported mode, otherwise restart in a different one */
+ 	link_support = xgbe_in_kr_mode(pdata) ? 0x80 : 0x20;
+ 	if (!(reg & link_support))
+ 		return XGBE_AN_INCOMPAT_LINK;
+ 
+ 	/* Check Extended Next Page support */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA);
+ 
+ 	return ((ad_reg & XGBE_XNP_NP_EXCHANGE) ||
+ 		(lp_reg & XGBE_XNP_NP_EXCHANGE))
+ 	       ? xgbe_an73_tx_xnp(pdata, state)
+ 	       : xgbe_an73_tx_training(pdata, state);
+ }
+ 
+ static enum xgbe_an xgbe_an73_rx_xnp(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	unsigned int ad_reg, lp_reg;
+ 
+ 	/* Check Extended Next Page support */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_XNP);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPX);
+ 
+ 	return ((ad_reg & XGBE_XNP_NP_EXCHANGE) ||
+ 		(lp_reg & XGBE_XNP_NP_EXCHANGE))
+ 	       ? xgbe_an73_tx_xnp(pdata, state)
+ 	       : xgbe_an73_tx_training(pdata, state);
+ }
+ 
+ static enum xgbe_an xgbe_an73_page_received(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_rx *state;
+ 	unsigned long an_timeout;
+ 	enum xgbe_an ret;
+ 
+ 	if (!pdata->an_start) {
+ 		pdata->an_start = jiffies;
+ 	} else {
+ 		an_timeout = pdata->an_start +
+ 			     msecs_to_jiffies(XGBE_AN_MS_TIMEOUT);
+ 		if (time_after(jiffies, an_timeout)) {
+ 			/* Auto-negotiation timed out, reset state */
+ 			pdata->kr_state = XGBE_RX_BPA;
+ 			pdata->kx_state = XGBE_RX_BPA;
+ 
+ 			pdata->an_start = jiffies;
+ 
+ 			netif_dbg(pdata, link, pdata->netdev,
+ 				  "CL73 AN timed out, resetting state\n");
+ 		}
+ 	}
+ 
+ 	state = xgbe_in_kr_mode(pdata) ? &pdata->kr_state
+ 				       : &pdata->kx_state;
+ 
+ 	switch (*state) {
+ 	case XGBE_RX_BPA:
+ 		ret = xgbe_an73_rx_bpa(pdata, state);
+ 		break;
+ 
+ 	case XGBE_RX_XNP:
+ 		ret = xgbe_an73_rx_xnp(pdata, state);
+ 		break;
+ 
+ 	default:
+ 		ret = XGBE_AN_ERROR;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static enum xgbe_an xgbe_an73_incompat_link(struct xgbe_prv_data *pdata)
+ {
+ 	/* Be sure we aren't looping trying to negotiate */
+ 	if (xgbe_in_kr_mode(pdata)) {
+ 		pdata->kr_state = XGBE_RX_ERROR;
+ 
+ 		if (!(pdata->phy.advertising & ADVERTISED_1000baseKX_Full) &&
+ 		    !(pdata->phy.advertising & ADVERTISED_2500baseX_Full))
+ 			return XGBE_AN_NO_LINK;
+ 
+ 		if (pdata->kx_state != XGBE_RX_BPA)
+ 			return XGBE_AN_NO_LINK;
+ 	} else {
+ 		pdata->kx_state = XGBE_RX_ERROR;
+ 
+ 		if (!(pdata->phy.advertising & ADVERTISED_10000baseKR_Full))
+ 			return XGBE_AN_NO_LINK;
+ 
+ 		if (pdata->kr_state != XGBE_RX_BPA)
+ 			return XGBE_AN_NO_LINK;
+ 	}
+ 
+ 	xgbe_an73_disable(pdata);
+ 
+ 	xgbe_switch_mode(pdata);
+ 
+ 	xgbe_an73_restart(pdata);
+ 
+ 	return XGBE_AN_INCOMPAT_LINK;
+ }
+ 
+ static void xgbe_an37_isr(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	/* Disable AN interrupts */
+ 	xgbe_an37_disable_interrupts(pdata);
+ 
+ 	/* Save the interrupt(s) that fired */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT);
+ 	pdata->an_int = reg & XGBE_AN_CL37_INT_MASK;
+ 	pdata->an_status = reg & ~XGBE_AN_CL37_INT_MASK;
+ 
+ 	if (pdata->an_int) {
+ 		/* Clear the interrupt(s) that fired and process them */
+ 		reg &= ~XGBE_AN_CL37_INT_MASK;
+ 		XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT, reg);
+ 
+ 		queue_work(pdata->an_workqueue, &pdata->an_irq_work);
+ 	} else {
+ 		/* Enable AN interrupts */
+ 		xgbe_an37_enable_interrupts(pdata);
+ 	}
+ }
+ 
+ static void xgbe_an73_isr(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable AN interrupts */
+ 	xgbe_an73_disable_interrupts(pdata);
+ 
+ 	/* Save the interrupt(s) that fired */
+ 	pdata->an_int = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_INT);
+ 
+ 	if (pdata->an_int) {
+ 		/* Clear the interrupt(s) that fired and process them */
+ 		XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, ~pdata->an_int);
+ 
+ 		queue_work(pdata->an_workqueue, &pdata->an_irq_work);
+ 	} else {
+ 		/* Enable AN interrupts */
+ 		xgbe_an73_enable_interrupts(pdata);
+ 	}
+ }
+ 
+ static irqreturn_t xgbe_an_isr(int irq, void *data)
+ {
+ 	struct xgbe_prv_data *pdata = (struct xgbe_prv_data *)data;
+ 
+ 	netif_dbg(pdata, intr, pdata->netdev, "AN interrupt received\n");
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_isr(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_isr(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static irqreturn_t xgbe_an_combined_isr(int irq, struct xgbe_prv_data *pdata)
+ {
+ 	return xgbe_an_isr(irq, pdata);
+ }
+ 
+ static void xgbe_an_irq_work(struct work_struct *work)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(work,
+ 						   struct xgbe_prv_data,
+ 						   an_irq_work);
+ 
+ 	/* Avoid a race between enabling the IRQ and exiting the work by
+ 	 * waiting for the work to finish and then queueing it
+ 	 */
+ 	flush_work(&pdata->an_work);
+ 	queue_work(pdata->an_workqueue, &pdata->an_work);
+ }
+ 
+ static const char *xgbe_state_as_string(enum xgbe_an state)
+ {
+ 	switch (state) {
+ 	case XGBE_AN_READY:
+ 		return "Ready";
+ 	case XGBE_AN_PAGE_RECEIVED:
+ 		return "Page-Received";
+ 	case XGBE_AN_INCOMPAT_LINK:
+ 		return "Incompatible-Link";
+ 	case XGBE_AN_COMPLETE:
+ 		return "Complete";
+ 	case XGBE_AN_NO_LINK:
+ 		return "No-Link";
+ 	case XGBE_AN_ERROR:
+ 		return "Error";
+ 	default:
+ 		return "Undefined";
+ 	}
+ }
+ 
+ static void xgbe_an37_state_machine(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_an cur_state = pdata->an_state;
+ 
+ 	if (!pdata->an_int)
+ 		return;
+ 
+ 	if (pdata->an_int & XGBE_AN_CL37_INT_CMPLT) {
+ 		pdata->an_state = XGBE_AN_COMPLETE;
+ 		pdata->an_int &= ~XGBE_AN_CL37_INT_CMPLT;
+ 
+ 		/* If SGMII is enabled, check the link status */
+ 		if ((pdata->an_mode == XGBE_AN_MODE_CL37_SGMII) &&
+ 		    !(pdata->an_status & XGBE_SGMII_AN_LINK_STATUS))
+ 			pdata->an_state = XGBE_AN_NO_LINK;
+ 	}
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN %s\n",
+ 		  xgbe_state_as_string(pdata->an_state));
+ 
+ 	cur_state = pdata->an_state;
+ 
+ 	switch (pdata->an_state) {
+ 	case XGBE_AN_READY:
+ 		break;
+ 
+ 	case XGBE_AN_COMPLETE:
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "Auto negotiation successful\n");
+ 		break;
+ 
+ 	case XGBE_AN_NO_LINK:
+ 		break;
+ 
+ 	default:
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ 	if (pdata->an_state == XGBE_AN_ERROR) {
+ 		netdev_err(pdata->netdev,
+ 			   "error during auto-negotiation, state=%u\n",
+ 			   cur_state);
+ 
+ 		pdata->an_int = 0;
+ 		xgbe_an37_clear_interrupts(pdata);
+ 	}
+ 
+ 	if (pdata->an_state >= XGBE_AN_COMPLETE) {
+ 		pdata->an_result = pdata->an_state;
+ 		pdata->an_state = XGBE_AN_READY;
+ 
+ 		netif_dbg(pdata, link, pdata->netdev, "CL37 AN result: %s\n",
+ 			  xgbe_state_as_string(pdata->an_result));
+ 	}
+ 
+ 	xgbe_an37_enable_interrupts(pdata);
+ }
+ 
+ static void xgbe_an73_state_machine(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_an cur_state = pdata->an_state;
+ 
+ 	if (!pdata->an_int)
+ 		return;
+ 
+ next_int:
+ 	if (pdata->an_int & XGBE_AN_CL73_PG_RCV) {
+ 		pdata->an_state = XGBE_AN_PAGE_RECEIVED;
+ 		pdata->an_int &= ~XGBE_AN_CL73_PG_RCV;
+ 	} else if (pdata->an_int & XGBE_AN_CL73_INC_LINK) {
+ 		pdata->an_state = XGBE_AN_INCOMPAT_LINK;
+ 		pdata->an_int &= ~XGBE_AN_CL73_INC_LINK;
+ 	} else if (pdata->an_int & XGBE_AN_CL73_INT_CMPLT) {
+ 		pdata->an_state = XGBE_AN_COMPLETE;
+ 		pdata->an_int &= ~XGBE_AN_CL73_INT_CMPLT;
+ 	} else {
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ again:
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN %s\n",
+ 		  xgbe_state_as_string(pdata->an_state));
+ 
+ 	cur_state = pdata->an_state;
+ 
+ 	switch (pdata->an_state) {
+ 	case XGBE_AN_READY:
+ 		pdata->an_supported = 0;
+ 		break;
+ 
+ 	case XGBE_AN_PAGE_RECEIVED:
+ 		pdata->an_state = xgbe_an73_page_received(pdata);
+ 		pdata->an_supported++;
+ 		break;
+ 
+ 	case XGBE_AN_INCOMPAT_LINK:
+ 		pdata->an_supported = 0;
+ 		pdata->parallel_detect = 0;
+ 		pdata->an_state = xgbe_an73_incompat_link(pdata);
+ 		break;
+ 
+ 	case XGBE_AN_COMPLETE:
+ 		pdata->parallel_detect = pdata->an_supported ? 0 : 1;
+ 		netif_dbg(pdata, link, pdata->netdev, "%s successful\n",
+ 			  pdata->an_supported ? "Auto negotiation"
+ 					      : "Parallel detection");
+ 		break;
+ 
+ 	case XGBE_AN_NO_LINK:
+ 		break;
+ 
+ 	default:
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ 	if (pdata->an_state == XGBE_AN_NO_LINK) {
+ 		pdata->an_int = 0;
+ 		xgbe_an73_clear_interrupts(pdata);
+ 	} else if (pdata->an_state == XGBE_AN_ERROR) {
+ 		netdev_err(pdata->netdev,
+ 			   "error during auto-negotiation, state=%u\n",
+ 			   cur_state);
+ 
+ 		pdata->an_int = 0;
+ 		xgbe_an73_clear_interrupts(pdata);
+ 	}
+ 
+ 	if (pdata->an_state >= XGBE_AN_COMPLETE) {
+ 		pdata->an_result = pdata->an_state;
+ 		pdata->an_state = XGBE_AN_READY;
+ 		pdata->kr_state = XGBE_RX_BPA;
+ 		pdata->kx_state = XGBE_RX_BPA;
+ 		pdata->an_start = 0;
+ 
+ 		netif_dbg(pdata, link, pdata->netdev, "CL73 AN result: %s\n",
+ 			  xgbe_state_as_string(pdata->an_result));
+ 	}
+ 
+ 	if (cur_state != pdata->an_state)
+ 		goto again;
+ 
+ 	if (pdata->an_int)
+ 		goto next_int;
+ 
+ 	xgbe_an73_enable_interrupts(pdata);
+ }
+ 
+ static void xgbe_an_state_machine(struct work_struct *work)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(work,
+ 						   struct xgbe_prv_data,
+ 						   an_work);
+ 
+ 	mutex_lock(&pdata->an_mutex);
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_state_machine(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_state_machine(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	mutex_unlock(&pdata->an_mutex);
+ }
+ 
+ static void xgbe_an37_init(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	/* Set up Advertisement register */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE);
+ 	if (pdata->phy.advertising & ADVERTISED_Pause)
+ 		reg |= 0x100;
+ 	else
+ 		reg &= ~0x100;
+ 
+ 	if (pdata->phy.advertising & ADVERTISED_Asym_Pause)
+ 		reg |= 0x80;
+ 	else
+ 		reg &= ~0x80;
+ 
+ 	/* Full duplex, but not half */
+ 	reg |= XGBE_AN_CL37_FD_MASK;
+ 	reg &= ~XGBE_AN_CL37_HD_MASK;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE, reg);
+ 
+ 	/* Set up the Control register */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
+ 	reg &= XGBE_AN_CL37_TX_CONFIG_MASK;
+ 	reg &= XGBE_AN_CL37_PCS_MODE_MASK;
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL37:
+ 		reg |= XGBE_AN_CL37_PCS_MODE_BASEX;
+ 		break;
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		reg |= XGBE_AN_CL37_PCS_MODE_SGMII;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN (%s) initialized\n",
+ 		  (pdata->an_mode == XGBE_AN_MODE_CL37) ? "BaseX" : "SGMII");
+ }
+ 
+ static void xgbe_an73_init(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	/* Set up Advertisement register 3 first */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);
+ 	if (pdata->phy.advertising & ADVERTISED_10000baseR_FEC)
+ 		reg |= 0xc000;
+ 	else
+ 		reg &= ~0xc000;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2, reg);
+ 
+ 	/* Set up Advertisement register 2 next */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1);
+ 	if (pdata->phy.advertising & ADVERTISED_10000baseKR_Full)
+ 		reg |= 0x80;
+ 	else
+ 		reg &= ~0x80;
+ 
+ 	if ((pdata->phy.advertising & ADVERTISED_1000baseKX_Full) ||
+ 	    (pdata->phy.advertising & ADVERTISED_2500baseX_Full))
+ 		reg |= 0x20;
+ 	else
+ 		reg &= ~0x20;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1, reg);
+ 
+ 	/* Set up Advertisement register 1 last */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);
+ 	if (pdata->phy.advertising & ADVERTISED_Pause)
+ 		reg |= 0x400;
+ 	else
+ 		reg &= ~0x400;
+ 
+ 	if (pdata->phy.advertising & ADVERTISED_Asym_Pause)
+ 		reg |= 0x800;
+ 	else
+ 		reg &= ~0x800;
+ 
+ 	/* We don't intend to perform XNP */
+ 	reg &= ~XGBE_XNP_NP_EXCHANGE;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN initialized\n");
+ }
+ 
+ static void xgbe_an_init(struct xgbe_prv_data *pdata)
+ {
+ 	/* Set up advertisement registers based on current settings */
+ 	pdata->an_mode = pdata->phy_if.phy_impl.an_mode(pdata);
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_init(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_init(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static const char *xgbe_phy_fc_string(struct xgbe_prv_data *pdata)
+ {
+ 	if (pdata->tx_pause && pdata->rx_pause)
+ 		return "rx/tx";
+ 	else if (pdata->rx_pause)
+ 		return "rx";
+ 	else if (pdata->tx_pause)
+ 		return "tx";
+ 	else
+ 		return "off";
+ }
+ 
+ static const char *xgbe_phy_speed_string(int speed)
+ {
+ 	switch (speed) {
+ 	case SPEED_100:
+ 		return "100Mbps";
+ 	case SPEED_1000:
+ 		return "1Gbps";
+ 	case SPEED_2500:
+ 		return "2.5Gbps";
+ 	case SPEED_10000:
+ 		return "10Gbps";
+ 	case SPEED_UNKNOWN:
+ 		return "Unknown";
+ 	default:
+ 		return "Unsupported";
+ 	}
+ }
+ 
+ static void xgbe_phy_print_status(struct xgbe_prv_data *pdata)
+ {
+ 	if (pdata->phy.link)
+ 		netdev_info(pdata->netdev,
+ 			    "Link is Up - %s/%s - flow control %s\n",
+ 			    xgbe_phy_speed_string(pdata->phy.speed),
+ 			    pdata->phy.duplex == DUPLEX_FULL ? "Full" : "Half",
+ 			    xgbe_phy_fc_string(pdata));
+ 	else
+ 		netdev_info(pdata->netdev, "Link is Down\n");
+ }
+ 
+ static void xgbe_phy_adjust_link(struct xgbe_prv_data *pdata)
++>>>>>>> abf0a1c2b26a (amd-xgbe: Add support for SFP+ modules)
  {
 +	struct xgbe_prv_data *pdata = netdev_priv(netdev);
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	struct phy_device *phydev = pdata->phydev;
  	int new_state = 0;
  
 -	if (pdata->phy.link) {
 +	if (phydev == NULL)
 +		return;
 +
 +	DBGPR_MDIO("-->xgbe_adjust_link: address=%d, newlink=%d, curlink=%d\n",
 +		   phydev->addr, phydev->link, pdata->phy_link);
 +
 +	if (phydev->link) {
  		/* Flow control support */
 -		pdata->pause_autoneg = pdata->phy.pause_autoneg;
 +		if (pdata->pause_autoneg) {
 +			if (phydev->pause || phydev->asym_pause) {
 +				pdata->tx_pause = 1;
 +				pdata->rx_pause = 1;
 +			} else {
 +				pdata->tx_pause = 0;
 +				pdata->rx_pause = 0;
 +			}
 +		}
  
 -		if (pdata->tx_pause != pdata->phy.tx_pause) {
 -			new_state = 1;
 -			pdata->hw_if.config_tx_flow_control(pdata);
 -			pdata->tx_pause = pdata->phy.tx_pause;
 +		if (pdata->tx_pause != pdata->phy_tx_pause) {
 +			hw_if->config_tx_flow_control(pdata);
 +			pdata->phy_tx_pause = pdata->tx_pause;
  		}
  
 -		if (pdata->rx_pause != pdata->phy.rx_pause) {
 -			new_state = 1;
 -			pdata->hw_if.config_rx_flow_control(pdata);
 -			pdata->rx_pause = pdata->phy.rx_pause;
 +		if (pdata->rx_pause != pdata->phy_rx_pause) {
 +			hw_if->config_rx_flow_control(pdata);
 +			pdata->phy_rx_pause = pdata->rx_pause;
  		}
  
  		/* Speed support */
@@@ -223,206 -1095,470 +1139,551 @@@
  		pdata->phy_speed = SPEED_UNKNOWN;
  	}
  
 -	if (new_state && netif_msg_link(pdata))
 -		xgbe_phy_print_status(pdata);
 +	if (new_state)
 +		phy_print_status(phydev);
 +
 +	DBGPR_MDIO("<--xgbe_adjust_link\n");
  }
  
++<<<<<<< HEAD
 +void xgbe_dump_phy_registers(struct xgbe_prv_data *pdata)
++=======
+ static bool xgbe_phy_valid_speed(struct xgbe_prv_data *pdata, int speed)
+ {
+ 	return pdata->phy_if.phy_impl.valid_speed(pdata, speed);
+ }
+ 
+ static int xgbe_phy_config_fixed(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_mode mode;
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "fixed PHY configuration\n");
+ 
+ 	/* Disable auto-negotiation */
+ 	xgbe_an_disable(pdata);
+ 
+ 	/* Set specified mode for specified speed */
+ 	mode = pdata->phy_if.phy_impl.get_mode(pdata, pdata->phy.speed);
+ 	switch (mode) {
+ 	case XGBE_MODE_KX_1000:
+ 	case XGBE_MODE_KX_2500:
+ 	case XGBE_MODE_KR:
+ 	case XGBE_MODE_SGMII_100:
+ 	case XGBE_MODE_SGMII_1000:
+ 	case XGBE_MODE_X:
+ 	case XGBE_MODE_SFI:
+ 		break;
+ 	case XGBE_MODE_UNKNOWN:
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Validate duplex mode */
+ 	if (pdata->phy.duplex != DUPLEX_FULL)
+ 		return -EINVAL;
+ 
+ 	xgbe_set_mode(pdata, mode);
+ 
+ 	return 0;
+ }
+ 
+ static int __xgbe_phy_config_aneg(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	set_bit(XGBE_LINK_INIT, &pdata->dev_state);
+ 	pdata->link_check = jiffies;
+ 
+ 	ret = pdata->phy_if.phy_impl.an_config(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (pdata->phy.autoneg != AUTONEG_ENABLE)
+ 		return xgbe_phy_config_fixed(pdata);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "AN PHY configuration\n");
+ 
+ 	/* Disable auto-negotiation interrupt */
+ 	disable_irq(pdata->an_irq);
+ 
+ 	/* Start auto-negotiation in a supported mode */
+ 	if (xgbe_use_mode(pdata, XGBE_MODE_KR)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_KR);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_2500)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_KX_2500);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_1000)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_KX_1000);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_SFI)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_SFI);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_X)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_X);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_1000)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_SGMII_1000);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_100)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_SGMII_100);
+ 	} else {
+ 		enable_irq(pdata->an_irq);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Disable and stop any in progress auto-negotiation */
+ 	xgbe_an_disable_all(pdata);
+ 
+ 	/* Clear any auto-negotitation interrupts */
+ 	xgbe_an_clear_interrupts_all(pdata);
+ 
+ 	pdata->an_result = XGBE_AN_READY;
+ 	pdata->an_state = XGBE_AN_READY;
+ 	pdata->kr_state = XGBE_RX_BPA;
+ 	pdata->kx_state = XGBE_RX_BPA;
+ 
+ 	/* Re-enable auto-negotiation interrupt */
+ 	enable_irq(pdata->an_irq);
+ 
+ 	xgbe_an_init(pdata);
+ 	xgbe_an_restart(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_phy_config_aneg(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&pdata->an_mutex);
+ 
+ 	ret = __xgbe_phy_config_aneg(pdata);
+ 	if (ret)
+ 		set_bit(XGBE_LINK_ERR, &pdata->dev_state);
+ 	else
+ 		clear_bit(XGBE_LINK_ERR, &pdata->dev_state);
+ 
+ 	mutex_unlock(&pdata->an_mutex);
+ 
+ 	return ret;
+ }
+ 
+ static bool xgbe_phy_aneg_done(struct xgbe_prv_data *pdata)
+ {
+ 	return (pdata->an_result == XGBE_AN_COMPLETE);
+ }
+ 
+ static void xgbe_check_link_timeout(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned long link_timeout;
+ 
+ 	link_timeout = pdata->link_check + (XGBE_LINK_TIMEOUT * HZ);
+ 	if (time_after(jiffies, link_timeout)) {
+ 		netif_dbg(pdata, link, pdata->netdev, "AN link timeout\n");
+ 		xgbe_phy_config_aneg(pdata);
+ 	}
+ }
+ 
+ static enum xgbe_mode xgbe_phy_status_aneg(struct xgbe_prv_data *pdata)
+ {
+ 	return pdata->phy_if.phy_impl.an_outcome(pdata);
+ }
+ 
+ static void xgbe_phy_status_result(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_mode mode;
+ 
+ 	pdata->phy.lp_advertising = 0;
+ 
+ 	if ((pdata->phy.autoneg != AUTONEG_ENABLE) || pdata->parallel_detect)
+ 		mode = xgbe_cur_mode(pdata);
+ 	else
+ 		mode = xgbe_phy_status_aneg(pdata);
+ 
+ 	switch (mode) {
+ 	case XGBE_MODE_SGMII_100:
+ 		pdata->phy.speed = SPEED_100;
+ 		break;
+ 	case XGBE_MODE_X:
+ 	case XGBE_MODE_KX_1000:
+ 	case XGBE_MODE_SGMII_1000:
+ 		pdata->phy.speed = SPEED_1000;
+ 		break;
+ 	case XGBE_MODE_KX_2500:
+ 		pdata->phy.speed = SPEED_2500;
+ 		break;
+ 	case XGBE_MODE_KR:
+ 	case XGBE_MODE_SFI:
+ 		pdata->phy.speed = SPEED_10000;
+ 		break;
+ 	case XGBE_MODE_UNKNOWN:
+ 	default:
+ 		pdata->phy.speed = SPEED_UNKNOWN;
+ 	}
+ 
+ 	pdata->phy.duplex = DUPLEX_FULL;
+ 
+ 	xgbe_set_mode(pdata, mode);
+ }
+ 
+ static void xgbe_phy_status(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int link_aneg;
+ 	int an_restart;
+ 
+ 	if (test_bit(XGBE_LINK_ERR, &pdata->dev_state)) {
+ 		netif_carrier_off(pdata->netdev);
+ 
+ 		pdata->phy.link = 0;
+ 		goto adjust_link;
+ 	}
+ 
+ 	link_aneg = (pdata->phy.autoneg == AUTONEG_ENABLE);
+ 
+ 	pdata->phy.link = pdata->phy_if.phy_impl.link_status(pdata,
+ 							     &an_restart);
+ 	if (an_restart) {
+ 		xgbe_phy_config_aneg(pdata);
+ 		return;
+ 	}
+ 
+ 	if (pdata->phy.link) {
+ 		if (link_aneg && !xgbe_phy_aneg_done(pdata)) {
+ 			xgbe_check_link_timeout(pdata);
+ 			return;
+ 		}
+ 
+ 		xgbe_phy_status_result(pdata);
+ 
+ 		if (test_bit(XGBE_LINK_INIT, &pdata->dev_state))
+ 			clear_bit(XGBE_LINK_INIT, &pdata->dev_state);
+ 
+ 		netif_carrier_on(pdata->netdev);
+ 	} else {
+ 		if (test_bit(XGBE_LINK_INIT, &pdata->dev_state)) {
+ 			xgbe_check_link_timeout(pdata);
+ 
+ 			if (link_aneg)
+ 				return;
+ 		}
+ 
+ 		xgbe_phy_status_result(pdata);
+ 
+ 		netif_carrier_off(pdata->netdev);
+ 	}
+ 
+ adjust_link:
+ 	xgbe_phy_adjust_link(pdata);
+ }
+ 
+ static void xgbe_phy_stop(struct xgbe_prv_data *pdata)
+ {
+ 	netif_dbg(pdata, link, pdata->netdev, "stopping PHY\n");
+ 
+ 	if (!pdata->phy_started)
+ 		return;
+ 
+ 	/* Indicate the PHY is down */
+ 	pdata->phy_started = 0;
+ 
+ 	/* Disable auto-negotiation */
+ 	xgbe_an_disable_all(pdata);
+ 
+ 	if (pdata->dev_irq != pdata->an_irq)
+ 		devm_free_irq(pdata->dev, pdata->an_irq, pdata);
+ 
+ 	pdata->phy_if.phy_impl.stop(pdata);
+ 
+ 	pdata->phy.link = 0;
+ 	netif_carrier_off(pdata->netdev);
+ 
+ 	xgbe_phy_adjust_link(pdata);
+ }
+ 
+ static int xgbe_phy_start(struct xgbe_prv_data *pdata)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 	int ret;
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "starting PHY\n");
+ 
+ 	ret = pdata->phy_if.phy_impl.start(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* If we have a separate AN irq, enable it */
+ 	if (pdata->dev_irq != pdata->an_irq) {
+ 		ret = devm_request_irq(pdata->dev, pdata->an_irq,
+ 				       xgbe_an_isr, 0, pdata->an_name,
+ 				       pdata);
+ 		if (ret) {
+ 			netdev_err(netdev, "phy irq request failed\n");
+ 			goto err_stop;
+ 		}
+ 	}
+ 
+ 	/* Set initial mode - call the mode setting routines
+ 	 * directly to insure we are properly configured
+ 	 */
+ 	if (xgbe_use_mode(pdata, XGBE_MODE_KR)) {
+ 		xgbe_kr_mode(pdata);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_2500)) {
+ 		xgbe_kx_2500_mode(pdata);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_1000)) {
+ 		xgbe_kx_1000_mode(pdata);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_SFI)) {
+ 		xgbe_sfi_mode(pdata);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_X)) {
+ 		xgbe_x_mode(pdata);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_1000)) {
+ 		xgbe_sgmii_1000_mode(pdata);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_SGMII_100)) {
+ 		xgbe_sgmii_100_mode(pdata);
+ 	} else {
+ 		ret = -EINVAL;
+ 		goto err_irq;
+ 	}
+ 
+ 	/* Indicate the PHY is up and running */
+ 	pdata->phy_started = 1;
+ 
+ 	xgbe_an_init(pdata);
+ 	xgbe_an_enable_interrupts(pdata);
+ 
+ 	return xgbe_phy_config_aneg(pdata);
+ 
+ err_irq:
+ 	if (pdata->dev_irq != pdata->an_irq)
+ 		devm_free_irq(pdata->dev, pdata->an_irq, pdata);
+ 
+ err_stop:
+ 	pdata->phy_if.phy_impl.stop(pdata);
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_phy_reset(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	ret = pdata->phy_if.phy_impl.reset(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Disable auto-negotiation for now */
+ 	xgbe_an_disable_all(pdata);
+ 
+ 	/* Clear auto-negotiation interrupts */
+ 	xgbe_an_clear_interrupts_all(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_dump_phy_registers(struct xgbe_prv_data *pdata)
++>>>>>>> abf0a1c2b26a (amd-xgbe: Add support for SFP+ modules)
  {
  	struct device *dev = pdata->dev;
 -
 -	dev_dbg(dev, "\n************* PHY Reg dump **********************\n");
 -
 -	dev_dbg(dev, "PCS Control Reg (%#06x) = %#06x\n", MDIO_CTRL1,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1));
 -	dev_dbg(dev, "PCS Status Reg (%#06x) = %#06x\n", MDIO_STAT1,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1));
 -	dev_dbg(dev, "Phy Id (PHYS ID 1 %#06x)= %#06x\n", MDIO_DEVID1,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID1));
 -	dev_dbg(dev, "Phy Id (PHYS ID 2 %#06x)= %#06x\n", MDIO_DEVID2,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID2));
 -	dev_dbg(dev, "Devices in Package (%#06x)= %#06x\n", MDIO_DEVS1,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS1));
 -	dev_dbg(dev, "Devices in Package (%#06x)= %#06x\n", MDIO_DEVS2,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS2));
 -
 -	dev_dbg(dev, "Auto-Neg Control Reg (%#06x) = %#06x\n", MDIO_CTRL1,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1));
 -	dev_dbg(dev, "Auto-Neg Status Reg (%#06x) = %#06x\n", MDIO_STAT1,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_STAT1));
 -	dev_dbg(dev, "Auto-Neg Ad Reg 1 (%#06x) = %#06x\n",
 -		MDIO_AN_ADVERTISE,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE));
 -	dev_dbg(dev, "Auto-Neg Ad Reg 2 (%#06x) = %#06x\n",
 -		MDIO_AN_ADVERTISE + 1,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1));
 -	dev_dbg(dev, "Auto-Neg Ad Reg 3 (%#06x) = %#06x\n",
 -		MDIO_AN_ADVERTISE + 2,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2));
 -	dev_dbg(dev, "Auto-Neg Completion Reg (%#06x) = %#06x\n",
 -		MDIO_AN_COMP_STAT,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_COMP_STAT));
 -
 -	dev_dbg(dev, "\n*************************************************\n");
 -}
 -
 -static int xgbe_phy_best_advertised_speed(struct xgbe_prv_data *pdata)
 -{
 +	struct phy_device *phydev = pdata->mii->phy_map[XGBE_PRTAD];
 +	int i;
 +
 +	dev_alert(dev, "\n************* PHY Reg dump **********************\n");
 +
 +	dev_alert(dev, "PCS Control Reg (%#04x) = %#04x\n", MDIO_CTRL1,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1));
 +	dev_alert(dev, "PCS Status Reg (%#04x) = %#04x\n", MDIO_STAT1,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1));
 +	dev_alert(dev, "Phy Id (PHYS ID 1 %#04x)= %#04x\n", MDIO_DEVID1,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID1));
 +	dev_alert(dev, "Phy Id (PHYS ID 2 %#04x)= %#04x\n", MDIO_DEVID2,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID2));
 +	dev_alert(dev, "Devices in Package (%#04x)= %#04x\n", MDIO_DEVS1,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS1));
 +	dev_alert(dev, "Devices in Package (%#04x)= %#04x\n", MDIO_DEVS2,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS2));
 +
 +	dev_alert(dev, "Auto-Neg Control Reg (%#04x) = %#04x\n", MDIO_CTRL1,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1));
 +	dev_alert(dev, "Auto-Neg Status Reg (%#04x) = %#04x\n", MDIO_STAT1,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_STAT1));
 +	dev_alert(dev, "Auto-Neg Ad Reg 1 (%#04x) = %#04x\n",
 +		  MDIO_AN_ADVERTISE,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE));
 +	dev_alert(dev, "Auto-Neg Ad Reg 2 (%#04x) = %#04x\n",
 +		  MDIO_AN_ADVERTISE + 1,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1));
 +	dev_alert(dev, "Auto-Neg Ad Reg 3 (%#04x) = %#04x\n",
 +		  MDIO_AN_ADVERTISE + 2,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2));
 +	dev_alert(dev, "Auto-Neg Completion Reg (%#04x) = %#04x\n",
 +		  MDIO_AN_COMP_STAT,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_COMP_STAT));
 +
 +	dev_alert(dev, "MMD Device Mask = %#x\n",
 +		  phydev->c45_ids.devices_in_package);
 +	for (i = 0; i < ARRAY_SIZE(phydev->c45_ids.device_ids); i++)
 +		dev_alert(dev, "  MMD %d: ID = %#08x\n", i,
 +			  phydev->c45_ids.device_ids[i]);
 +
 +	dev_alert(dev, "\n*************************************************\n");
 +}
 +
 +int xgbe_mdio_register(struct xgbe_prv_data *pdata)
 +{
++<<<<<<< HEAD
 +	struct net_device *netdev = pdata->netdev;
 +	struct device_node *phy_node;
 +	struct mii_bus *mii;
 +	struct phy_device *phydev;
 +	int ret = 0;
++=======
+ 	if (pdata->phy.advertising & ADVERTISED_10000baseKR_Full)
+ 		return SPEED_10000;
+ 	else if (pdata->phy.advertising & ADVERTISED_10000baseT_Full)
+ 		return SPEED_10000;
+ 	else if (pdata->phy.advertising & ADVERTISED_2500baseX_Full)
+ 		return SPEED_2500;
+ 	else if (pdata->phy.advertising & ADVERTISED_1000baseKX_Full)
+ 		return SPEED_1000;
+ 	else if (pdata->phy.advertising & ADVERTISED_1000baseT_Full)
+ 		return SPEED_1000;
+ 	else if (pdata->phy.advertising & ADVERTISED_100baseT_Full)
+ 		return SPEED_100;
++>>>>>>> abf0a1c2b26a (amd-xgbe: Add support for SFP+ modules)
  
 -	return SPEED_UNKNOWN;
 -}
 +	DBGPR("-->xgbe_mdio_register\n");
  
 -static void xgbe_phy_exit(struct xgbe_prv_data *pdata)
 -{
 -	xgbe_phy_stop(pdata);
 +	/* Retrieve the phy-handle */
 +	phy_node = of_parse_phandle(pdata->dev->of_node, "phy-handle", 0);
 +	if (!phy_node) {
 +		dev_err(pdata->dev, "unable to parse phy-handle\n");
 +		return -EINVAL;
 +	}
  
 -	pdata->phy_if.phy_impl.exit(pdata);
 -}
 +	/* Register with the MDIO bus */
 +	mii = mdiobus_alloc();
 +	if (mii == NULL) {
 +		dev_err(pdata->dev, "mdiobus_alloc failed\n");
 +		ret = -ENOMEM;
 +		goto err_node_get;
 +	}
  
 -static int xgbe_phy_init(struct xgbe_prv_data *pdata)
 -{
 -	int ret;
 +	/* Register on the MDIO bus (don't probe any PHYs) */
 +	mii->name = XGBE_PHY_NAME;
 +	mii->read = xgbe_mdio_read;
 +	mii->write = xgbe_mdio_write;
 +	snprintf(mii->id, sizeof(mii->id), "%s", pdata->mii_bus_id);
 +	mii->priv = pdata;
 +	mii->phy_mask = ~0;
 +	mii->parent = pdata->dev;
 +	ret = mdiobus_register(mii);
 +	if (ret) {
 +		dev_err(pdata->dev, "mdiobus_register failed\n");
 +		goto err_mdiobus_alloc;
 +	}
 +	DBGPR("  mdiobus_register succeeded for %s\n", pdata->mii_bus_id);
 +
 +	/* Probe the PCS using Clause 45 */
 +	phydev = get_phy_device(mii, XGBE_PRTAD, true);
 +	if (IS_ERR(phydev) || !phydev ||
 +	    !phydev->c45_ids.device_ids[MDIO_MMD_PCS]) {
 +		dev_err(pdata->dev, "get_phy_device failed\n");
 +		ret = phydev ? PTR_ERR(phydev) : -ENOLINK;
 +		goto err_mdiobus_register;
 +	}
 +	request_module(MDIO_MODULE_PREFIX MDIO_ID_FMT,
 +		       MDIO_ID_ARGS(phydev->c45_ids.device_ids[MDIO_MMD_PCS]));
 +
 +	of_node_get(phy_node);
 +	phydev->dev.of_node = phy_node;
 +	ret = phy_device_register(phydev);
 +	if (ret) {
 +		dev_err(pdata->dev, "phy_device_register failed\n");
 +		of_node_put(phy_node);
 +		goto err_phy_device;
 +	}
 +	if (!phydev->dev.driver) {
 +		dev_err(pdata->dev, "phy driver probe failed\n");
 +		ret = -EIO;
 +		goto err_phy_device;
 +	}
  
 -	mutex_init(&pdata->an_mutex);
 -	INIT_WORK(&pdata->an_irq_work, xgbe_an_irq_work);
 -	INIT_WORK(&pdata->an_work, xgbe_an_state_machine);
 -	pdata->mdio_mmd = MDIO_MMD_PCS;
 +	/* Add a reference to the PHY driver so it can't be unloaded */
 +	pdata->phy_module = phydev->dev.driver->owner;
 +	if (!try_module_get(pdata->phy_module)) {
 +		dev_err(pdata->dev, "try_module_get failed\n");
 +		ret = -EIO;
 +		goto err_phy_device;
 +	}
  
 -	/* Check for FEC support */
 -	pdata->fec_ability = XMDIO_READ(pdata, MDIO_MMD_PMAPMD,
 -					MDIO_PMA_10GBR_FECABLE);
 -	pdata->fec_ability &= (MDIO_PMA_10GBR_FECABLE_ABLE |
 -			       MDIO_PMA_10GBR_FECABLE_ERRABLE);
 +	pdata->mii = mii;
 +	pdata->mdio_mmd = MDIO_MMD_PCS;
  
 -	/* Setup the phy (including supported features) */
 -	ret = pdata->phy_if.phy_impl.init(pdata);
 -	if (ret)
 -		return ret;
 -	pdata->phy.advertising = pdata->phy.supported;
 +	pdata->phy_link = -1;
 +	pdata->phy_speed = SPEED_UNKNOWN;
 +	pdata->phy_tx_pause = pdata->tx_pause;
 +	pdata->phy_rx_pause = pdata->rx_pause;
  
 -	pdata->phy.address = 0;
 +	ret = phy_connect_direct(netdev, phydev, &xgbe_adjust_link,
 +				 pdata->phy_mode);
 +	if (ret) {
 +		netdev_err(netdev, "phy_connect_direct failed\n");
 +		goto err_phy_device;
 +	}
  
 -	if (pdata->phy.advertising & ADVERTISED_Autoneg) {
 -		pdata->phy.autoneg = AUTONEG_ENABLE;
 -		pdata->phy.speed = SPEED_UNKNOWN;
 -		pdata->phy.duplex = DUPLEX_UNKNOWN;
 -	} else {
 -		pdata->phy.autoneg = AUTONEG_DISABLE;
 -		pdata->phy.speed = xgbe_phy_best_advertised_speed(pdata);
 -		pdata->phy.duplex = DUPLEX_FULL;
 +	if (!phydev->drv || (phydev->drv->phy_id == 0)) {
 +		netdev_err(netdev, "phy_id not valid\n");
 +		ret = -ENODEV;
 +		goto err_phy_connect;
  	}
 +	DBGPR("  phy_connect_direct succeeded for PHY %s, link=%d\n",
 +	      dev_name(&phydev->dev), phydev->link);
  
 -	pdata->phy.link = 0;
 +	phydev->autoneg = pdata->default_autoneg;
 +	if (phydev->autoneg == AUTONEG_DISABLE) {
 +		phydev->speed = pdata->default_speed;
 +		phydev->duplex = DUPLEX_FULL;
  
 -	pdata->phy.pause_autoneg = pdata->pause_autoneg;
 -	pdata->phy.tx_pause = pdata->tx_pause;
 -	pdata->phy.rx_pause = pdata->rx_pause;
 +		phydev->advertising &= ~ADVERTISED_Autoneg;
 +	}
  
 -	/* Fix up Flow Control advertising */
 -	pdata->phy.advertising &= ~ADVERTISED_Pause;
 -	pdata->phy.advertising &= ~ADVERTISED_Asym_Pause;
 +	pdata->phydev = phydev;
  
 -	if (pdata->rx_pause) {
 -		pdata->phy.advertising |= ADVERTISED_Pause;
 -		pdata->phy.advertising |= ADVERTISED_Asym_Pause;
 -	}
 +	of_node_put(phy_node);
  
 -	if (pdata->tx_pause)
 -		pdata->phy.advertising ^= ADVERTISED_Asym_Pause;
 +	DBGPHY_REGS(pdata);
  
 -	if (netif_msg_drv(pdata))
 -		xgbe_dump_phy_registers(pdata);
 +	DBGPR("<--xgbe_mdio_register\n");
  
  	return 0;
 +
 +err_phy_connect:
 +	phy_disconnect(phydev);
 +
 +err_phy_device:
 +	phy_device_free(phydev);
 +
 +err_mdiobus_register:
 +	mdiobus_unregister(mii);
 +
 +err_mdiobus_alloc:
 +	mdiobus_free(mii);
 +
 +err_node_get:
 +	of_node_put(phy_node);
 +
 +	return ret;
  }
  
 -void xgbe_init_function_ptrs_phy(struct xgbe_phy_if *phy_if)
 +void xgbe_mdio_unregister(struct xgbe_prv_data *pdata)
  {
 -	phy_if->phy_init        = xgbe_phy_init;
 -	phy_if->phy_exit        = xgbe_phy_exit;
 +	DBGPR("-->xgbe_mdio_unregister\n");
 +
 +	phy_disconnect(pdata->phydev);
 +	pdata->phydev = NULL;
  
 -	phy_if->phy_reset       = xgbe_phy_reset;
 -	phy_if->phy_start       = xgbe_phy_start;
 -	phy_if->phy_stop        = xgbe_phy_stop;
 +	module_put(pdata->phy_module);
 +	pdata->phy_module = NULL;
  
 -	phy_if->phy_status      = xgbe_phy_status;
 -	phy_if->phy_config_aneg = xgbe_phy_config_aneg;
 +	mdiobus_unregister(pdata->mii);
 +	pdata->mii->priv = NULL;
  
 -	phy_if->phy_valid_speed = xgbe_phy_valid_speed;
 +	mdiobus_free(pdata->mii);
 +	pdata->mii = NULL;
  
 -	phy_if->an_isr          = xgbe_an_combined_isr;
 +	DBGPR("<--xgbe_mdio_unregister\n");
  }
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 1903f878545a,a691f844fa72..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -324,18 -485,122 +324,137 @@@ enum xgbe_int_state 
  	XGMAC_INT_STATE_RESTORE,
  };
  
++<<<<<<< HEAD
 +enum xgbe_mtl_fifo_size {
 +	XGMAC_MTL_FIFO_SIZE_256  = 0x00,
 +	XGMAC_MTL_FIFO_SIZE_512  = 0x01,
 +	XGMAC_MTL_FIFO_SIZE_1K   = 0x03,
 +	XGMAC_MTL_FIFO_SIZE_2K   = 0x07,
 +	XGMAC_MTL_FIFO_SIZE_4K   = 0x0f,
 +	XGMAC_MTL_FIFO_SIZE_8K   = 0x1f,
 +	XGMAC_MTL_FIFO_SIZE_16K  = 0x3f,
 +	XGMAC_MTL_FIFO_SIZE_32K  = 0x7f,
 +	XGMAC_MTL_FIFO_SIZE_64K  = 0xff,
 +	XGMAC_MTL_FIFO_SIZE_128K = 0x1ff,
 +	XGMAC_MTL_FIFO_SIZE_256K = 0x3ff,
++=======
+ enum xgbe_ecc_sec {
+ 	XGBE_ECC_SEC_TX,
+ 	XGBE_ECC_SEC_RX,
+ 	XGBE_ECC_SEC_DESC,
+ };
+ 
+ enum xgbe_speed {
+ 	XGBE_SPEED_1000 = 0,
+ 	XGBE_SPEED_2500,
+ 	XGBE_SPEED_10000,
+ 	XGBE_SPEEDS,
+ };
+ 
+ enum xgbe_xpcs_access {
+ 	XGBE_XPCS_ACCESS_V1 = 0,
+ 	XGBE_XPCS_ACCESS_V2,
+ };
+ 
+ enum xgbe_an_mode {
+ 	XGBE_AN_MODE_CL73 = 0,
+ 	XGBE_AN_MODE_CL37,
+ 	XGBE_AN_MODE_CL37_SGMII,
+ 	XGBE_AN_MODE_NONE,
+ };
+ 
+ enum xgbe_an {
+ 	XGBE_AN_READY = 0,
+ 	XGBE_AN_PAGE_RECEIVED,
+ 	XGBE_AN_INCOMPAT_LINK,
+ 	XGBE_AN_COMPLETE,
+ 	XGBE_AN_NO_LINK,
+ 	XGBE_AN_ERROR,
+ };
+ 
+ enum xgbe_rx {
+ 	XGBE_RX_BPA = 0,
+ 	XGBE_RX_XNP,
+ 	XGBE_RX_COMPLETE,
+ 	XGBE_RX_ERROR,
+ };
+ 
+ enum xgbe_mode {
+ 	XGBE_MODE_KX_1000 = 0,
+ 	XGBE_MODE_KX_2500,
+ 	XGBE_MODE_KR,
+ 	XGBE_MODE_X,
+ 	XGBE_MODE_SGMII_100,
+ 	XGBE_MODE_SGMII_1000,
+ 	XGBE_MODE_SFI,
+ 	XGBE_MODE_UNKNOWN,
+ };
+ 
+ enum xgbe_speedset {
+ 	XGBE_SPEEDSET_1000_10000 = 0,
+ 	XGBE_SPEEDSET_2500_10000,
+ };
+ 
+ enum xgbe_mdio_mode {
+ 	XGBE_MDIO_MODE_NONE = 0,
+ 	XGBE_MDIO_MODE_CL22,
+ 	XGBE_MDIO_MODE_CL45,
+ };
+ 
+ struct xgbe_phy {
+ 	u32 supported;
+ 	u32 advertising;
+ 	u32 lp_advertising;
+ 
+ 	int address;
+ 
+ 	int autoneg;
+ 	int speed;
+ 	int duplex;
+ 
+ 	int link;
+ 
+ 	int pause_autoneg;
+ 	int tx_pause;
+ 	int rx_pause;
+ };
+ 
+ enum xgbe_i2c_cmd {
+ 	XGBE_I2C_CMD_READ = 0,
+ 	XGBE_I2C_CMD_WRITE,
+ };
+ 
+ struct xgbe_i2c_op {
+ 	enum xgbe_i2c_cmd cmd;
+ 
+ 	unsigned int target;
+ 
+ 	void *buf;
+ 	unsigned int len;
+ };
+ 
+ struct xgbe_i2c_op_state {
+ 	struct xgbe_i2c_op *op;
+ 
+ 	unsigned int tx_len;
+ 	unsigned char *tx_buf;
+ 
+ 	unsigned int rx_len;
+ 	unsigned char *rx_buf;
+ 
+ 	unsigned int tx_abort_source;
+ 
+ 	int ret;
+ };
+ 
+ struct xgbe_i2c {
+ 	unsigned int started;
+ 	unsigned int max_speed_mode;
+ 	unsigned int rx_fifo_size;
+ 	unsigned int tx_fifo_size;
+ 
+ 	struct xgbe_i2c_op_state op_state;
++>>>>>>> abf0a1c2b26a (amd-xgbe: Add support for SFP+ modules)
  };
  
  struct xgbe_mmc_stats {
@@@ -461,6 -733,114 +580,117 @@@ struct xgbe_hw_if 
  	void (*rx_mmc_int)(struct xgbe_prv_data *);
  	void (*tx_mmc_int)(struct xgbe_prv_data *);
  	void (*read_mmc_stats)(struct xgbe_prv_data *);
++<<<<<<< HEAD
++=======
+ 
+ 	/* For Timestamp config */
+ 	int (*config_tstamp)(struct xgbe_prv_data *, unsigned int);
+ 	void (*update_tstamp_addend)(struct xgbe_prv_data *, unsigned int);
+ 	void (*set_tstamp_time)(struct xgbe_prv_data *, unsigned int sec,
+ 				unsigned int nsec);
+ 	u64 (*get_tstamp_time)(struct xgbe_prv_data *);
+ 	u64 (*get_tx_tstamp)(struct xgbe_prv_data *);
+ 
+ 	/* For Data Center Bridging config */
+ 	void (*config_tc)(struct xgbe_prv_data *);
+ 	void (*config_dcb_tc)(struct xgbe_prv_data *);
+ 	void (*config_dcb_pfc)(struct xgbe_prv_data *);
+ 
+ 	/* For Receive Side Scaling */
+ 	int (*enable_rss)(struct xgbe_prv_data *);
+ 	int (*disable_rss)(struct xgbe_prv_data *);
+ 	int (*set_rss_hash_key)(struct xgbe_prv_data *, const u8 *);
+ 	int (*set_rss_lookup_table)(struct xgbe_prv_data *, const u32 *);
+ 
+ 	/* For ECC */
+ 	void (*disable_ecc_ded)(struct xgbe_prv_data *);
+ 	void (*disable_ecc_sec)(struct xgbe_prv_data *, enum xgbe_ecc_sec);
+ };
+ 
+ /* This structure represents implementation specific routines for an
+  * implementation of a PHY. All routines are required unless noted below.
+  *   Optional routines:
+  *     kr_training_pre, kr_training_post
+  */
+ struct xgbe_phy_impl_if {
+ 	/* Perform Setup/teardown actions */
+ 	int (*init)(struct xgbe_prv_data *);
+ 	void (*exit)(struct xgbe_prv_data *);
+ 
+ 	/* Perform start/stop specific actions */
+ 	int (*reset)(struct xgbe_prv_data *);
+ 	int (*start)(struct xgbe_prv_data *);
+ 	void (*stop)(struct xgbe_prv_data *);
+ 
+ 	/* Return the link status */
+ 	int (*link_status)(struct xgbe_prv_data *, int *);
+ 
+ 	/* Indicate if a particular speed is valid */
+ 	bool (*valid_speed)(struct xgbe_prv_data *, int);
+ 
+ 	/* Check if the specified mode can/should be used */
+ 	bool (*use_mode)(struct xgbe_prv_data *, enum xgbe_mode);
+ 	/* Switch the PHY into various modes */
+ 	void (*set_mode)(struct xgbe_prv_data *, enum xgbe_mode);
+ 	/* Retrieve mode needed for a specific speed */
+ 	enum xgbe_mode (*get_mode)(struct xgbe_prv_data *, int);
+ 	/* Retrieve new/next mode when trying to auto-negotiate */
+ 	enum xgbe_mode (*switch_mode)(struct xgbe_prv_data *);
+ 	/* Retrieve current mode */
+ 	enum xgbe_mode (*cur_mode)(struct xgbe_prv_data *);
+ 
+ 	/* Retrieve current auto-negotiation mode */
+ 	enum xgbe_an_mode (*an_mode)(struct xgbe_prv_data *);
+ 
+ 	/* Configure auto-negotiation settings */
+ 	int (*an_config)(struct xgbe_prv_data *);
+ 
+ 	/* Process results of auto-negotiation */
+ 	enum xgbe_mode (*an_outcome)(struct xgbe_prv_data *);
+ 
+ 	/* Pre/Post KR training enablement support */
+ 	void (*kr_training_pre)(struct xgbe_prv_data *);
+ 	void (*kr_training_post)(struct xgbe_prv_data *);
+ };
+ 
+ struct xgbe_phy_if {
+ 	/* For PHY setup/teardown */
+ 	int (*phy_init)(struct xgbe_prv_data *);
+ 	void (*phy_exit)(struct xgbe_prv_data *);
+ 
+ 	/* For PHY support when setting device up/down */
+ 	int (*phy_reset)(struct xgbe_prv_data *);
+ 	int (*phy_start)(struct xgbe_prv_data *);
+ 	void (*phy_stop)(struct xgbe_prv_data *);
+ 
+ 	/* For PHY support while device is up */
+ 	void (*phy_status)(struct xgbe_prv_data *);
+ 	int (*phy_config_aneg)(struct xgbe_prv_data *);
+ 
+ 	/* For PHY settings validation */
+ 	bool (*phy_valid_speed)(struct xgbe_prv_data *, int);
+ 
+ 	/* For single interrupt support */
+ 	irqreturn_t (*an_isr)(int, struct xgbe_prv_data *);
+ 
+ 	/* PHY implementation specific services */
+ 	struct xgbe_phy_impl_if phy_impl;
+ };
+ 
+ struct xgbe_i2c_if {
+ 	/* For initial I2C setup */
+ 	int (*i2c_init)(struct xgbe_prv_data *);
+ 
+ 	/* For I2C support when setting device up/down */
+ 	int (*i2c_start)(struct xgbe_prv_data *);
+ 	void (*i2c_stop)(struct xgbe_prv_data *);
+ 
+ 	/* For performing I2C operations */
+ 	int (*i2c_xfer)(struct xgbe_prv_data *, struct xgbe_i2c_op *);
+ 
+ 	/* For single interrupt support */
+ 	irqreturn_t (*i2c_isr)(int, struct xgbe_prv_data *);
++>>>>>>> abf0a1c2b26a (amd-xgbe: Add support for SFP+ modules)
  };
  
  struct xgbe_desc_if {
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-phy-v1.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
* Unmerged path drivers/net/ethernet/amd/Kconfig
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-common.h
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-phy-v1.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
