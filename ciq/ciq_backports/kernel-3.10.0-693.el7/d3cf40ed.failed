drm: Add missing __user annotation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [vhost] add missing __user annotations (Wei Xu) [1283257 1425127]
Rebuild_FUZZ: 90.62%
commit-author Thierry Reding <treding@nvidia.com>
commit d3cf40ed7fa1b56bd53d3b52eddf44d0e3c3ec20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d3cf40ed.failed

The drm_copy_field() function copies strings into userspace buffers, so
the first parameter needs to have a __user annotation to avoid warnings
from the sparse checker.

	Signed-off-by: Thierry Reding <treding@nvidia.com>
	Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit d3cf40ed7fa1b56bd53d3b52eddf44d0e3c3ec20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_drv.c
diff --cc drivers/gpu/drm/drm_drv.c
index 167c8d3d4a31,0cc182745e31..000000000000
--- a/drivers/gpu/drm/drm_drv.c
+++ b/drivers/gpu/drm/drm_drv.c
@@@ -929,3 -229,243 +929,246 @@@ static void __exit drm_core_exit(void
  
  module_init(drm_core_init);
  module_exit(drm_core_exit);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * Copy and IOCTL return string to user space
+  */
+ static int drm_copy_field(char __user *buf, size_t *buf_len, const char *value)
+ {
+ 	int len;
+ 
+ 	/* don't overflow userbuf */
+ 	len = strlen(value);
+ 	if (len > *buf_len)
+ 		len = *buf_len;
+ 
+ 	/* let userspace know exact length of driver value (which could be
+ 	 * larger than the userspace-supplied buffer) */
+ 	*buf_len = strlen(value);
+ 
+ 	/* finally, try filling in the userbuf */
+ 	if (len && buf)
+ 		if (copy_to_user(buf, value, len))
+ 			return -EFAULT;
+ 	return 0;
+ }
+ 
+ /**
+  * Get version information
+  *
+  * \param inode device inode.
+  * \param filp file pointer.
+  * \param cmd command.
+  * \param arg user argument, pointing to a drm_version structure.
+  * \return zero on success or negative number on failure.
+  *
+  * Fills in the version information in \p arg.
+  */
+ static int drm_version(struct drm_device *dev, void *data,
+ 		       struct drm_file *file_priv)
+ {
+ 	struct drm_version *version = data;
+ 	int err;
+ 
+ 	version->version_major = dev->driver->major;
+ 	version->version_minor = dev->driver->minor;
+ 	version->version_patchlevel = dev->driver->patchlevel;
+ 	err = drm_copy_field(version->name, &version->name_len,
+ 			dev->driver->name);
+ 	if (!err)
+ 		err = drm_copy_field(version->date, &version->date_len,
+ 				dev->driver->date);
+ 	if (!err)
+ 		err = drm_copy_field(version->desc, &version->desc_len,
+ 				dev->driver->desc);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * drm_ioctl_permit - Check ioctl permissions against caller
+  *
+  * @flags: ioctl permission flags.
+  * @file_priv: Pointer to struct drm_file identifying the caller.
+  *
+  * Checks whether the caller is allowed to run an ioctl with the
+  * indicated permissions. If so, returns zero. Otherwise returns an
+  * error code suitable for ioctl return.
+  */
+ static int drm_ioctl_permit(u32 flags, struct drm_file *file_priv)
+ {
+ 	/* ROOT_ONLY is only for CAP_SYS_ADMIN */
+ 	if (unlikely((flags & DRM_ROOT_ONLY) && !capable(CAP_SYS_ADMIN)))
+ 		return -EACCES;
+ 
+ 	/* AUTH is only for authenticated or render client */
+ 	if (unlikely((flags & DRM_AUTH) && !drm_is_render_client(file_priv) &&
+ 		     !file_priv->authenticated))
+ 		return -EACCES;
+ 
+ 	/* MASTER is only for master or control clients */
+ 	if (unlikely((flags & DRM_MASTER) && !file_priv->is_master &&
+ 		     !drm_is_control_client(file_priv)))
+ 		return -EACCES;
+ 
+ 	/* Control clients must be explicitly allowed */
+ 	if (unlikely(!(flags & DRM_CONTROL_ALLOW) &&
+ 		     drm_is_control_client(file_priv)))
+ 		return -EACCES;
+ 
+ 	/* Render clients must be explicitly allowed */
+ 	if (unlikely(!(flags & DRM_RENDER_ALLOW) &&
+ 		     drm_is_render_client(file_priv)))
+ 		return -EACCES;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * Called whenever a process performs an ioctl on /dev/drm.
+  *
+  * \param inode device inode.
+  * \param file_priv DRM file private.
+  * \param cmd command.
+  * \param arg user argument.
+  * \return zero on success or negative number on failure.
+  *
+  * Looks up the ioctl function in the ::ioctls table, checking for root
+  * previleges if so required, and dispatches to the respective function.
+  */
+ long drm_ioctl(struct file *filp,
+ 	      unsigned int cmd, unsigned long arg)
+ {
+ 	struct drm_file *file_priv = filp->private_data;
+ 	struct drm_device *dev;
+ 	const struct drm_ioctl_desc *ioctl = NULL;
+ 	drm_ioctl_t *func;
+ 	unsigned int nr = DRM_IOCTL_NR(cmd);
+ 	int retcode = -EINVAL;
+ 	char stack_kdata[128];
+ 	char *kdata = NULL;
+ 	unsigned int usize, asize;
+ 
+ 	dev = file_priv->minor->dev;
+ 
+ 	if (drm_device_is_unplugged(dev))
+ 		return -ENODEV;
+ 
+ 	if ((nr >= DRM_CORE_IOCTL_COUNT) &&
+ 	    ((nr < DRM_COMMAND_BASE) || (nr >= DRM_COMMAND_END)))
+ 		goto err_i1;
+ 	if ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_END) &&
+ 	    (nr < DRM_COMMAND_BASE + dev->driver->num_ioctls)) {
+ 		u32 drv_size;
+ 		ioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];
+ 		drv_size = _IOC_SIZE(ioctl->cmd_drv);
+ 		usize = asize = _IOC_SIZE(cmd);
+ 		if (drv_size > asize)
+ 			asize = drv_size;
+ 		cmd = ioctl->cmd_drv;
+ 	}
+ 	else if ((nr >= DRM_COMMAND_END) || (nr < DRM_COMMAND_BASE)) {
+ 		u32 drv_size;
+ 
+ 		ioctl = &drm_ioctls[nr];
+ 
+ 		drv_size = _IOC_SIZE(ioctl->cmd);
+ 		usize = asize = _IOC_SIZE(cmd);
+ 		if (drv_size > asize)
+ 			asize = drv_size;
+ 
+ 		cmd = ioctl->cmd;
+ 	} else
+ 		goto err_i1;
+ 
+ 	DRM_DEBUG("pid=%d, dev=0x%lx, auth=%d, %s\n",
+ 		  task_pid_nr(current),
+ 		  (long)old_encode_dev(file_priv->minor->kdev->devt),
+ 		  file_priv->authenticated, ioctl->name);
+ 
+ 	/* Do not trust userspace, use our own definition */
+ 	func = ioctl->func;
+ 
+ 	if (unlikely(!func)) {
+ 		DRM_DEBUG("no function\n");
+ 		retcode = -EINVAL;
+ 		goto err_i1;
+ 	}
+ 
+ 	retcode = drm_ioctl_permit(ioctl->flags, file_priv);
+ 	if (unlikely(retcode))
+ 		goto err_i1;
+ 
+ 	if (cmd & (IOC_IN | IOC_OUT)) {
+ 		if (asize <= sizeof(stack_kdata)) {
+ 			kdata = stack_kdata;
+ 		} else {
+ 			kdata = kmalloc(asize, GFP_KERNEL);
+ 			if (!kdata) {
+ 				retcode = -ENOMEM;
+ 				goto err_i1;
+ 			}
+ 		}
+ 		if (asize > usize)
+ 			memset(kdata + usize, 0, asize - usize);
+ 	}
+ 
+ 	if (cmd & IOC_IN) {
+ 		if (copy_from_user(kdata, (void __user *)arg,
+ 				   usize) != 0) {
+ 			retcode = -EFAULT;
+ 			goto err_i1;
+ 		}
+ 	} else if (cmd & IOC_OUT) {
+ 		memset(kdata, 0, usize);
+ 	}
+ 
+ 	if (ioctl->flags & DRM_UNLOCKED)
+ 		retcode = func(dev, kdata, file_priv);
+ 	else {
+ 		mutex_lock(&drm_global_mutex);
+ 		retcode = func(dev, kdata, file_priv);
+ 		mutex_unlock(&drm_global_mutex);
+ 	}
+ 
+ 	if (cmd & IOC_OUT) {
+ 		if (copy_to_user((void __user *)arg, kdata,
+ 				 usize) != 0)
+ 			retcode = -EFAULT;
+ 	}
+ 
+       err_i1:
+ 	if (!ioctl)
+ 		DRM_DEBUG("invalid ioctl: pid=%d, dev=0x%lx, auth=%d, cmd=0x%02x, nr=0x%02x\n",
+ 			  task_pid_nr(current),
+ 			  (long)old_encode_dev(file_priv->minor->kdev->devt),
+ 			  file_priv->authenticated, cmd, nr);
+ 
+ 	if (kdata != stack_kdata)
+ 		kfree(kdata);
+ 	if (retcode)
+ 		DRM_DEBUG("ret = %d\n", retcode);
+ 	return retcode;
+ }
+ EXPORT_SYMBOL(drm_ioctl);
+ 
+ /**
+  * drm_ioctl_flags - Check for core ioctl and return ioctl permission flags
+  *
+  * @nr: Ioctl number.
+  * @flags: Where to return the ioctl permission flags
+  */
+ bool drm_ioctl_flags(unsigned int nr, unsigned int *flags)
+ {
+ 	if ((nr >= DRM_COMMAND_END && nr < DRM_CORE_IOCTL_COUNT) ||
+ 	    (nr < DRM_COMMAND_BASE)) {
+ 		*flags = drm_ioctls[nr].flags;
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ EXPORT_SYMBOL(drm_ioctl_flags);
++>>>>>>> d3cf40ed7fa1 (drm: Add missing __user annotation)
* Unmerged path drivers/gpu/drm/drm_drv.c
