fs/hugetlbfs/inode.c: fix bugs in hugetlb_vmtruncate_list()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] hugetlbfs/inode.c: fix bugs in hugetlb_vmtruncate_list() (Andrea Arcangeli) [1430172]
Rebuild_FUZZ: 97.39%
commit-author Mike Kravetz <mike.kravetz@oracle.com>
commit 9aacdd354d197ad64685941b36d28ea20ab88757
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9aacdd35.failed

Hillf Danton noticed bugs in the hugetlb_vmtruncate_list routine.  The
argument end is of type pgoff_t.  It was being converted to a vaddr
offset and passed to unmap_hugepage_range.  However, end was also being
used as an argument to the vma_interval_tree_foreach controlling loop.
In addition, the conversion of end to vaddr offset was incorrect.

hugetlb_vmtruncate_list is called as part of a file truncate or
fallocate hole punch operation.

When truncating a hugetlbfs file, this bug could prevent some pages from
being unmapped.  This is possible if there are multiple vmas mapping the
file, and there is a sufficiently sized hole between the mappings.  The
size of the hole between two vmas (A,B) must be such that the starting
virtual address of B is greater than (ending virtual address of A <<
PAGE_SHIFT).  In this case, the pages in B would not be unmapped.  If
pages are not properly unmapped during truncate, the following BUG is
hit:

	kernel BUG at fs/hugetlbfs/inode.c:428!

In the fallocate hole punch case, this bug could prevent pages from
being unmapped as in the truncate case.  However, for hole punch the
result is that unmapped pages will not be removed during the operation.
For hole punch, it is also possible that more pages than desired will be
unmapped.  This unnecessary unmapping will cause page faults to
reestablish the mappings on subsequent page access.

Fixes: 1bfad99ab (" hugetlbfs: hugetlb_vmtruncate_list() needs to take a range")Reported-by: Hillf Danton <hillf.zj@alibaba-inc.com>
	Signed-off-by: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Davidlohr Bueso <dave@stgolabs.net>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: <stable@vger.kernel.org>	[4.3]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9aacdd354d197ad64685941b36d28ea20ab88757)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/hugetlbfs/inode.c
diff --cc fs/hugetlbfs/inode.c
index bf25a49de3ab,9c07d2d754c9..000000000000
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@@ -407,8 -457,13 +407,9 @@@ hugetlb_vmtruncate_list(struct rb_root 
  {
  	struct vm_area_struct *vma;
  
 -	/*
 -	 * end == 0 indicates that the entire range after
 -	 * start should be unmapped.
 -	 */
 -	vma_interval_tree_foreach(vma, root, start, end ? end : ULONG_MAX) {
 +	vma_interval_tree_foreach(vma, root, pgoff, ULONG_MAX) {
  		unsigned long v_offset;
+ 		unsigned long v_end;
  
  		/*
  		 * Can the expression below overflow on 32-bit arches?
@@@ -421,8 -476,17 +422,22 @@@
  		else
  			v_offset = 0;
  
++<<<<<<< HEAD
 +		unmap_hugepage_range(vma, vma->vm_start + v_offset,
 +				     vma->vm_end, NULL);
++=======
+ 		if (!end)
+ 			v_end = vma->vm_end;
+ 		else {
+ 			v_end = ((end - vma->vm_pgoff) << PAGE_SHIFT)
+ 							+ vma->vm_start;
+ 			if (v_end > vma->vm_end)
+ 				v_end = vma->vm_end;
+ 		}
+ 
+ 		unmap_hugepage_range(vma, vma->vm_start + v_offset, v_end,
+ 									NULL);
++>>>>>>> 9aacdd354d19 (fs/hugetlbfs/inode.c: fix bugs in hugetlb_vmtruncate_list())
  	}
  }
  
* Unmerged path fs/hugetlbfs/inode.c
