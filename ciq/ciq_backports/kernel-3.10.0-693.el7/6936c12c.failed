dm table: fix 'all_blk_mq' inconsistency when an empty table is loaded

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit 6936c12cf809850180b24947271b8f068fdb15e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6936c12c.failed

An earlier DM multipath table could have been build ontop of underlying
devices that were all using blk-mq.  In that case, if that active
multipath table is replaced with an empty DM multipath table (that
reflects all paths have failed) then it is important that the
'all_blk_mq' state of the active table is transfered to the new empty DM
table.  Otherwise dm-rq.c:dm_old_prep_tio() will incorrectly clone a
request that isn't needed by the DM multipath target when it is to issue
IO to an underlying blk-mq device.

Fixes: e83068a5 ("dm mpath: add optional "queue_mode" feature")
	Cc: stable@vger.kernel.org # 4.8+
	Reported-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Tested-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 6936c12cf809850180b24947271b8f068fdb15e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-table.c
diff --cc drivers/md/dm-table.c
index e6a26212de48,53b817b29134..000000000000
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@@ -885,6 -924,13 +885,16 @@@ static int dm_table_set_type(struct dm_
  
  	BUG_ON(!request_based); /* No targets in this table */
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * The only way to establish DM_TYPE_MQ_REQUEST_BASED is by
+ 	 * having a compatible target use dm_table_set_type.
+ 	 */
+ 	t->type = DM_TYPE_REQUEST_BASED;
+ 
+ verify_rq_based:
++>>>>>>> 6936c12cf809 (dm table: fix 'all_blk_mq' inconsistency when an empty table is loaded)
  	/*
  	 * Request-based dm supports only tables that have a single target now.
  	 * To support multiple targets, request splitting support is needed,
@@@ -896,8 -942,20 +906,21 @@@
  		return -EINVAL;
  	}
  
+ 	if (list_empty(devices)) {
+ 		int srcu_idx;
+ 		struct dm_table *live_table = dm_get_live_table(t->md, &srcu_idx);
+ 
+ 		/* inherit live table's type and all_blk_mq */
+ 		if (live_table) {
+ 			t->type = live_table->type;
+ 			t->all_blk_mq = live_table->all_blk_mq;
+ 		}
+ 		dm_put_live_table(t->md, srcu_idx);
+ 		return 0;
+ 	}
+ 
  	/* Non-request-stackable devices can't be used for request-based dm */
 +	devices = dm_table_get_devices(t);
  	list_for_each_entry(dd, devices, list) {
  		struct request_queue *q = bdev_get_queue(dd->dm_dev->bdev);
  
* Unmerged path drivers/md/dm-table.c
