switchdev: s/swdev_/switchdev_/

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit 9d47c0a2d958e06322c88245749278633d333cca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9d47c0a2.failed

Turned out that "switchdev" sticks. So just unify all related terms to use
this prefix.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Acked-by: Andy Gospodarek <gospo@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9d47c0a2d958e06322c88245749278633d333cca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/rocker/rocker.c
#	include/linux/netdevice.h
#	include/net/switchdev.h
#	net/dsa/slave.c
#	net/switchdev/switchdev.c
diff --cc include/linux/netdevice.h
index b6150f910ad9,2b39235b9f13..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1492,69 -1531,63 +1492,75 @@@ struct net_device 
  	struct list_head	dev_list;
  	struct list_head	napi_list;
  	struct list_head	unreg_list;
 -	struct list_head	close_list;
 -	struct list_head	ptype_all;
 -	struct list_head	ptype_specific;
 +	struct list_head	upper_dev_list; /* List of upper devices */
  
 -	struct {
 -		struct list_head upper;
 -		struct list_head lower;
 -	} adj_list;
 -
 -	struct {
 -		struct list_head upper;
 -		struct list_head lower;
 -	} all_adj_list;
  
 +	/* currently active device features */
  	netdev_features_t	features;
 +	/* user-changeable features */
  	netdev_features_t	hw_features;
 +	/* user-requested features */
  	netdev_features_t	wanted_features;
 +	/* mask of features inheritable by VLAN devices */
  	netdev_features_t	vlan_features;
 +	/* mask of features inherited by encapsulating devices
 +	 * This field indicates what encapsulation offloads
 +	 * the hardware is capable of doing, and drivers will
 +	 * need to set them appropriately.
 +	 */
  	netdev_features_t	hw_enc_features;
 +	/* mask of fetures inheritable by MPLS */
  	netdev_features_t	mpls_features;
  
 +	/* Interface index. Unique device identifier	*/
  	int			ifindex;
 -	int			group;
 +	int			iflink;
  
  	struct net_device_stats	stats;
 -
 -	atomic_long_t		rx_dropped;
 -	atomic_long_t		tx_dropped;
 +	atomic_long_t		rx_dropped; /* dropped packets by core network
 +					     * Do not use this in drivers.
 +					     */
  
  #ifdef CONFIG_WIRELESS_EXT
 +	/* List of functions to handle Wireless Extensions (instead of ioctl).
 +	 * See <net/iw_handler.h> for details. Jean II */
  	const struct iw_handler_def *	wireless_handlers;
 +	/* Instance data managed by the core of Wireless Extensions. */
  	struct iw_public_data *	wireless_data;
  #endif
 +	/* Management operations */
  	const struct net_device_ops *netdev_ops;
  	const struct ethtool_ops *ethtool_ops;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NET_SWITCHDEV
+ 	const struct switchdev_ops *switchdev_ops;
+ #endif
++>>>>>>> 9d47c0a2d958 (switchdev: s/swdev_/switchdev_/)
  
 +	/* Hardware header description */
  	const struct header_ops *header_ops;
  
 -	unsigned int		flags;
 -	unsigned int		priv_flags;
 -
 +	unsigned int		flags;	/* interface flags (a la BSD)	*/
 +	unsigned int		priv_flags; /* Like 'flags' but invisible to userspace.
 +					     * See if.h for definitions. */
  	unsigned short		gflags;
 -	unsigned short		padded;
 +	unsigned short		padded;	/* How much padding added by alloc_netdev() */
  
 -	unsigned char		operstate;
 -	unsigned char		link_mode;
 +	unsigned char		operstate; /* RFC2863 operstate */
 +	unsigned char		link_mode; /* mapping policy to operstate */
  
 -	unsigned char		if_port;
 -	unsigned char		dma;
 +	unsigned char		if_port;	/* Selectable AUI, TP,..*/
 +	unsigned char		dma;		/* DMA channel		*/
  
 -	unsigned int		mtu;
 -	unsigned short		type;
 -	unsigned short		hard_header_len;
 +	unsigned int		mtu;	/* interface MTU value		*/
 +	unsigned short		type;	/* interface hardware type	*/
 +	unsigned short		hard_header_len;	/* hardware hdr length	*/
  
 +	/* extra head- and tailroom the hardware may need, but not in all cases
 +	 * can this be guaranteed, especially tailroom. Some cases also use
 +	 * LL_MAX_HEADER instead to allocate the skb.
 +	 */
  	unsigned short		needed_headroom;
  	unsigned short		needed_tailroom;
  
diff --cc net/dsa/slave.c
index 6ebd8fbd9285,1546acf6ebd3..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -302,53 -668,217 +302,65 @@@ static const struct net_device_ops dsa_
  	.ndo_change_rx_flags	= dsa_slave_change_rx_flags,
  	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
  	.ndo_set_mac_address	= dsa_slave_set_mac_address,
 -	.ndo_fdb_add		= dsa_slave_fdb_add,
 -	.ndo_fdb_del		= dsa_slave_fdb_del,
 -	.ndo_fdb_dump		= dsa_slave_fdb_dump,
  	.ndo_do_ioctl		= dsa_slave_ioctl,
 -	.ndo_get_iflink		= dsa_slave_get_iflink,
  };
++<<<<<<< HEAD
 +#endif
 +#ifdef CONFIG_NET_DSA_TAG_EDSA
 +static const struct net_device_ops edsa_netdev_ops = {
 +	.ndo_init		= dsa_slave_init,
 +	.ndo_open	 	= dsa_slave_open,
 +	.ndo_stop		= dsa_slave_close,
 +	.ndo_start_xmit		= edsa_xmit,
 +	.ndo_change_rx_flags	= dsa_slave_change_rx_flags,
 +	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
 +	.ndo_set_mac_address	= dsa_slave_set_mac_address,
 +	.ndo_do_ioctl		= dsa_slave_ioctl,
++=======
+ 
+ static const struct switchdev_ops dsa_slave_switchdev_ops = {
+ 	.switchdev_parent_id_get	= dsa_slave_parent_id_get,
+ 	.switchdev_port_stp_update	= dsa_slave_stp_update,
++>>>>>>> 9d47c0a2d958 (switchdev: s/swdev_/switchdev_/)
  };
 -
 -static void dsa_slave_adjust_link(struct net_device *dev)
 -{
 -	struct dsa_slave_priv *p = netdev_priv(dev);
 -	struct dsa_switch *ds = p->parent;
 -	unsigned int status_changed = 0;
 -
 -	if (p->old_link != p->phy->link) {
 -		status_changed = 1;
 -		p->old_link = p->phy->link;
 -	}
 -
 -	if (p->old_duplex != p->phy->duplex) {
 -		status_changed = 1;
 -		p->old_duplex = p->phy->duplex;
 -	}
 -
 -	if (p->old_pause != p->phy->pause) {
 -		status_changed = 1;
 -		p->old_pause = p->phy->pause;
 -	}
 -
 -	if (ds->drv->adjust_link && status_changed)
 -		ds->drv->adjust_link(ds, p->port, p->phy);
 -
 -	if (status_changed)
 -		phy_print_status(p->phy);
 -}
 -
 -static int dsa_slave_fixed_link_update(struct net_device *dev,
 -				       struct fixed_phy_status *status)
 -{
 -	struct dsa_slave_priv *p = netdev_priv(dev);
 -	struct dsa_switch *ds = p->parent;
 -
 -	if (ds->drv->fixed_link_update)
 -		ds->drv->fixed_link_update(ds, p->port, status);
 -
 -	return 0;
 -}
 +#endif
 +#ifdef CONFIG_NET_DSA_TAG_TRAILER
 +static const struct net_device_ops trailer_netdev_ops = {
 +	.ndo_init		= dsa_slave_init,
 +	.ndo_open	 	= dsa_slave_open,
 +	.ndo_stop		= dsa_slave_close,
 +	.ndo_start_xmit		= trailer_xmit,
 +	.ndo_change_rx_flags	= dsa_slave_change_rx_flags,
 +	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
 +	.ndo_set_mac_address	= dsa_slave_set_mac_address,
 +	.ndo_do_ioctl		= dsa_slave_ioctl,
 +};
 +#endif
  
  /* slave device setup *******************************************************/
 -static int dsa_slave_phy_connect(struct dsa_slave_priv *p,
 -				 struct net_device *slave_dev,
 -				 int addr)
 -{
 -	struct dsa_switch *ds = p->parent;
 -
 -	p->phy = ds->slave_mii_bus->phy_map[addr];
 -	if (!p->phy)
 -		return -ENODEV;
 -
 -	/* Use already configured phy mode */
 -	p->phy_interface = p->phy->interface;
 -	phy_connect_direct(slave_dev, p->phy, dsa_slave_adjust_link,
 -			   p->phy_interface);
 -
 -	return 0;
 -}
 -
 -static int dsa_slave_phy_setup(struct dsa_slave_priv *p,
 -				struct net_device *slave_dev)
 -{
 -	struct dsa_switch *ds = p->parent;
 -	struct dsa_chip_data *cd = ds->pd;
 -	struct device_node *phy_dn, *port_dn;
 -	bool phy_is_fixed = false;
 -	u32 phy_flags = 0;
 -	int mode, ret;
 -
 -	port_dn = cd->port_dn[p->port];
 -	mode = of_get_phy_mode(port_dn);
 -	if (mode < 0)
 -		mode = PHY_INTERFACE_MODE_NA;
 -	p->phy_interface = mode;
 -
 -	phy_dn = of_parse_phandle(port_dn, "phy-handle", 0);
 -	if (of_phy_is_fixed_link(port_dn)) {
 -		/* In the case of a fixed PHY, the DT node associated
 -		 * to the fixed PHY is the Port DT node
 -		 */
 -		ret = of_phy_register_fixed_link(port_dn);
 -		if (ret) {
 -			netdev_err(slave_dev, "failed to register fixed PHY\n");
 -			return ret;
 -		}
 -		phy_is_fixed = true;
 -		phy_dn = port_dn;
 -	}
 -
 -	if (ds->drv->get_phy_flags)
 -		phy_flags = ds->drv->get_phy_flags(ds, p->port);
 -
 -	if (phy_dn) {
 -		ret = of_mdio_parse_addr(&slave_dev->dev, phy_dn);
 -		/* If this PHY address is part of phys_mii_mask, which means
 -		 * that we need to divert reads and writes to/from it, then we
 -		 * want to bind this device using the slave MII bus created by
 -		 * DSA to make that happen.
 -		 */
 -		if (!phy_is_fixed && ret >= 0 &&
 -		    (ds->phys_mii_mask & (1 << ret))) {
 -			ret = dsa_slave_phy_connect(p, slave_dev, ret);
 -			if (ret)
 -				return ret;
 -		} else {
 -			p->phy = of_phy_connect(slave_dev, phy_dn,
 -						dsa_slave_adjust_link,
 -						phy_flags,
 -						p->phy_interface);
 -		}
 -	}
 -
 -	if (p->phy && phy_is_fixed)
 -		fixed_phy_set_link_update(p->phy, dsa_slave_fixed_link_update);
 -
 -	/* We could not connect to a designated PHY, so use the switch internal
 -	 * MDIO bus instead
 -	 */
 -	if (!p->phy) {
 -		ret = dsa_slave_phy_connect(p, slave_dev, p->port);
 -		if (ret)
 -			return ret;
 -	} else {
 -		netdev_info(slave_dev, "attached PHY at address %d [%s]\n",
 -			    p->phy->addr, p->phy->drv->name);
 -	}
 -
 -	return 0;
 -}
 -
 -static struct lock_class_key dsa_slave_netdev_xmit_lock_key;
 -static void dsa_slave_set_lockdep_class_one(struct net_device *dev,
 -					    struct netdev_queue *txq,
 -					    void *_unused)
 -{
 -	lockdep_set_class(&txq->_xmit_lock,
 -			  &dsa_slave_netdev_xmit_lock_key);
 -}
 -
 -int dsa_slave_suspend(struct net_device *slave_dev)
 -{
 -	struct dsa_slave_priv *p = netdev_priv(slave_dev);
 -
 -	if (p->phy) {
 -		phy_stop(p->phy);
 -		p->old_pause = -1;
 -		p->old_link = -1;
 -		p->old_duplex = -1;
 -		phy_suspend(p->phy);
 -	}
 -
 -	return 0;
 -}
 -
 -int dsa_slave_resume(struct net_device *slave_dev)
 -{
 -	struct dsa_slave_priv *p = netdev_priv(slave_dev);
 -
 -	netif_device_attach(slave_dev);
 -
 -	if (p->phy) {
 -		phy_resume(p->phy);
 -		phy_start(p->phy);
 -	}
 -
 -	return 0;
 -}
 -
 -int dsa_slave_create(struct dsa_switch *ds, struct device *parent,
 -		     int port, char *name)
 +struct net_device *
 +dsa_slave_create(struct dsa_switch *ds, struct device *parent,
 +		 int port, char *name)
  {
  	struct net_device *master = ds->dst->master_netdev;
  	struct net_device *slave_dev;
  	struct dsa_slave_priv *p;
  	int ret;
  
 -	slave_dev = alloc_netdev(sizeof(struct dsa_slave_priv), name,
 -				 NET_NAME_UNKNOWN, ether_setup);
 +	slave_dev = alloc_netdev(sizeof(struct dsa_slave_priv),
 +				 name, ether_setup);
  	if (slave_dev == NULL)
 -		return -ENOMEM;
 +		return slave_dev;
  
  	slave_dev->features = master->vlan_features;
 -	slave_dev->ethtool_ops = &dsa_slave_ethtool_ops;
 -	eth_hw_addr_inherit(slave_dev, master);
 +	SET_ETHTOOL_OPS(slave_dev, &dsa_slave_ethtool_ops);
 +	memcpy(slave_dev->dev_addr, master->dev_addr, ETH_ALEN);
  	slave_dev->tx_queue_len = 0;
++<<<<<<< HEAD
++=======
+ 	slave_dev->netdev_ops = &dsa_slave_netdev_ops;
+ 	slave_dev->switchdev_ops = &dsa_slave_switchdev_ops;
 -
 -	netdev_for_each_tx_queue(slave_dev, dsa_slave_set_lockdep_class_one,
 -				 NULL);
 -
 -	SET_NETDEV_DEV(slave_dev, parent);
 -	slave_dev->dev.of_node = ds->pd->port_dn[port];
 -	slave_dev->vlan_features = master->vlan_features;
 -
 -	p = netdev_priv(slave_dev);
 -	p->dev = slave_dev;
 -	p->parent = ds;
 -	p->port = port;
++>>>>>>> 9d47c0a2d958 (switchdev: s/swdev_/switchdev_/)
  
  	switch (ds->dst->tag_protocol) {
  #ifdef CONFIG_NET_DSA_TAG_DSA
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/net/switchdev.h
* Unmerged path net/switchdev/switchdev.c
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/linux/netdevice.h
* Unmerged path include/net/switchdev.h
* Unmerged path net/dsa/slave.c
* Unmerged path net/switchdev/switchdev.c
