flow_dissect: call init_default_flow_dissectors() earlier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] flow_dissector: call init_default_flow_dissectors() earlier (Jonathan Toppins) [1428557]
Rebuild_FUZZ: 98.28%
commit-author Eric Dumazet <edumazet@google.com>
commit c9b8af1330198ae241cd545e1f040019010d44d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c9b8af13.failed

Andre Noll reported panics after my recent fix (commit 34fad54c2537
"net: __skb_flow_dissect() must cap its return value")

After some more headaches, Alexander root caused the problem to
init_default_flow_dissectors() being called too late, in case
a network driver like IGB is not a module and receives DHCP message
very early.

Fix is to call init_default_flow_dissectors() much earlier,
as it is a core infrastructure and does not depend on another
kernel service.

Fixes: 06635a35d13d4 ("flow_dissect: use programable dissector in skb_flow_dissect and friends")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Andre Noll <maan@tuebingen.mpg.de>
Diagnosed-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c9b8af1330198ae241cd545e1f040019010d44d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index fbf58a98e819,c6d8207ffa7e..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -434,3 -885,132 +434,135 @@@ u32 skb_get_poff(const struct sk_buff *
  
  	return __skb_get_poff(skb, skb->data, &keys, skb_headlen(skb));
  }
++<<<<<<< HEAD
++=======
+ 
+ __u32 __get_hash_from_flowi6(const struct flowi6 *fl6, struct flow_keys *keys)
+ {
+ 	memset(keys, 0, sizeof(*keys));
+ 
+ 	memcpy(&keys->addrs.v6addrs.src, &fl6->saddr,
+ 	    sizeof(keys->addrs.v6addrs.src));
+ 	memcpy(&keys->addrs.v6addrs.dst, &fl6->daddr,
+ 	    sizeof(keys->addrs.v6addrs.dst));
+ 	keys->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+ 	keys->ports.src = fl6->fl6_sport;
+ 	keys->ports.dst = fl6->fl6_dport;
+ 	keys->keyid.keyid = fl6->fl6_gre_key;
+ 	keys->tags.flow_label = (__force u32)fl6->flowlabel;
+ 	keys->basic.ip_proto = fl6->flowi6_proto;
+ 
+ 	return flow_hash_from_keys(keys);
+ }
+ EXPORT_SYMBOL(__get_hash_from_flowi6);
+ 
+ __u32 __get_hash_from_flowi4(const struct flowi4 *fl4, struct flow_keys *keys)
+ {
+ 	memset(keys, 0, sizeof(*keys));
+ 
+ 	keys->addrs.v4addrs.src = fl4->saddr;
+ 	keys->addrs.v4addrs.dst = fl4->daddr;
+ 	keys->control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 	keys->ports.src = fl4->fl4_sport;
+ 	keys->ports.dst = fl4->fl4_dport;
+ 	keys->keyid.keyid = fl4->fl4_gre_key;
+ 	keys->basic.ip_proto = fl4->flowi4_proto;
+ 
+ 	return flow_hash_from_keys(keys);
+ }
+ EXPORT_SYMBOL(__get_hash_from_flowi4);
+ 
+ static const struct flow_dissector_key flow_keys_dissector_keys[] = {
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_CONTROL,
+ 		.offset = offsetof(struct flow_keys, control),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_BASIC,
+ 		.offset = offsetof(struct flow_keys, basic),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_IPV4_ADDRS,
+ 		.offset = offsetof(struct flow_keys, addrs.v4addrs),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 		.offset = offsetof(struct flow_keys, addrs.v6addrs),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_TIPC_ADDRS,
+ 		.offset = offsetof(struct flow_keys, addrs.tipcaddrs),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_PORTS,
+ 		.offset = offsetof(struct flow_keys, ports),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_VLAN,
+ 		.offset = offsetof(struct flow_keys, vlan),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_FLOW_LABEL,
+ 		.offset = offsetof(struct flow_keys, tags),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_GRE_KEYID,
+ 		.offset = offsetof(struct flow_keys, keyid),
+ 	},
+ };
+ 
+ static const struct flow_dissector_key flow_keys_dissector_symmetric_keys[] = {
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_CONTROL,
+ 		.offset = offsetof(struct flow_keys, control),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_BASIC,
+ 		.offset = offsetof(struct flow_keys, basic),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_IPV4_ADDRS,
+ 		.offset = offsetof(struct flow_keys, addrs.v4addrs),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 		.offset = offsetof(struct flow_keys, addrs.v6addrs),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_PORTS,
+ 		.offset = offsetof(struct flow_keys, ports),
+ 	},
+ };
+ 
+ static const struct flow_dissector_key flow_keys_buf_dissector_keys[] = {
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_CONTROL,
+ 		.offset = offsetof(struct flow_keys, control),
+ 	},
+ 	{
+ 		.key_id = FLOW_DISSECTOR_KEY_BASIC,
+ 		.offset = offsetof(struct flow_keys, basic),
+ 	},
+ };
+ 
+ struct flow_dissector flow_keys_dissector __read_mostly;
+ EXPORT_SYMBOL(flow_keys_dissector);
+ 
+ struct flow_dissector flow_keys_buf_dissector __read_mostly;
+ 
+ static int __init init_default_flow_dissectors(void)
+ {
+ 	skb_flow_dissector_init(&flow_keys_dissector,
+ 				flow_keys_dissector_keys,
+ 				ARRAY_SIZE(flow_keys_dissector_keys));
+ 	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
+ 				flow_keys_dissector_symmetric_keys,
+ 				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
+ 	skb_flow_dissector_init(&flow_keys_buf_dissector,
+ 				flow_keys_buf_dissector_keys,
+ 				ARRAY_SIZE(flow_keys_buf_dissector_keys));
+ 	return 0;
+ }
+ 
+ core_initcall(init_default_flow_dissectors);
++>>>>>>> c9b8af133019 (flow_dissect: call init_default_flow_dissectors() earlier)
* Unmerged path net/core/flow_dissector.c
