flowi: Abstract out functions to get flow hash based on flowi

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tom Herbert <tom@herbertland.com>
commit c6cc1ca7f4d70cbb3ea3a5ca163c5dabaf155cdb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c6cc1ca7.failed

Create __get_hash_from_flowi6 and __get_hash_from_flowi4 to get the
flow keys and hash based on flowi structures. These are called by
__skb_get_hash_flowi6 and __skb_get_hash_flowi4. Also, created
get_hash_from_flowi6 and get_hash_from_flowi4 which can be called
when just the hash value for a flowi is needed.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c6cc1ca7f4d70cbb3ea3a5ca163c5dabaf155cdb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/net/flow.h
#	include/net/flow_dissector.h
diff --cc include/linux/skbuff.h
index dcb8575fa615,bbe41bccfc5f..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -1001,6 -950,117 +1001,120 @@@ static inline void skb_clear_hash_if_no
  		skb_clear_hash(skb);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void
+ __skb_set_hash(struct sk_buff *skb, __u32 hash, bool is_sw, bool is_l4)
+ {
+ 	skb->l4_hash = is_l4;
+ 	skb->sw_hash = is_sw;
+ 	skb->hash = hash;
+ }
+ 
+ static inline void
+ skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
+ {
+ 	/* Used by drivers to set hash from HW */
+ 	__skb_set_hash(skb, hash, false, type == PKT_HASH_TYPE_L4);
+ }
+ 
+ static inline void
+ __skb_set_sw_hash(struct sk_buff *skb, __u32 hash, bool is_l4)
+ {
+ 	__skb_set_hash(skb, hash, true, is_l4);
+ }
+ 
+ void __skb_get_hash(struct sk_buff *skb);
+ u32 skb_get_poff(const struct sk_buff *skb);
+ u32 __skb_get_poff(const struct sk_buff *skb, void *data,
+ 		   const struct flow_keys *keys, int hlen);
+ __be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
+ 			    void *data, int hlen_proto);
+ 
+ static inline __be32 skb_flow_get_ports(const struct sk_buff *skb,
+ 					int thoff, u8 ip_proto)
+ {
+ 	return __skb_flow_get_ports(skb, thoff, ip_proto, NULL, 0);
+ }
+ 
+ void skb_flow_dissector_init(struct flow_dissector *flow_dissector,
+ 			     const struct flow_dissector_key *key,
+ 			     unsigned int key_count);
+ 
+ bool __skb_flow_dissect(const struct sk_buff *skb,
+ 			struct flow_dissector *flow_dissector,
+ 			void *target_container,
+ 			void *data, __be16 proto, int nhoff, int hlen);
+ 
+ static inline bool skb_flow_dissect(const struct sk_buff *skb,
+ 				    struct flow_dissector *flow_dissector,
+ 				    void *target_container)
+ {
+ 	return __skb_flow_dissect(skb, flow_dissector, target_container,
+ 				  NULL, 0, 0, 0);
+ }
+ 
+ static inline bool skb_flow_dissect_flow_keys(const struct sk_buff *skb,
+ 					      struct flow_keys *flow)
+ {
+ 	memset(flow, 0, sizeof(*flow));
+ 	return __skb_flow_dissect(skb, &flow_keys_dissector, flow,
+ 				  NULL, 0, 0, 0);
+ }
+ 
+ static inline bool skb_flow_dissect_flow_keys_buf(struct flow_keys *flow,
+ 						  void *data, __be16 proto,
+ 						  int nhoff, int hlen)
+ {
+ 	memset(flow, 0, sizeof(*flow));
+ 	return __skb_flow_dissect(NULL, &flow_keys_buf_dissector, flow,
+ 				  data, proto, nhoff, hlen);
+ }
+ 
+ static inline __u32 skb_get_hash(struct sk_buff *skb)
+ {
+ 	if (!skb->l4_hash && !skb->sw_hash)
+ 		__skb_get_hash(skb);
+ 
+ 	return skb->hash;
+ }
+ 
+ __u32 __skb_get_hash_flowi6(struct sk_buff *skb, struct flowi6 *fl6);
+ 
+ static inline __u32 skb_get_hash_flowi6(struct sk_buff *skb, struct flowi6 *fl6)
+ {
+ 	if (!skb->l4_hash && !skb->sw_hash) {
+ 		struct flow_keys keys;
+ 
+ 		__skb_set_sw_hash(skb, __get_hash_from_flowi6(fl6, &keys),
+ 				  flow_keys_have_l4(&keys));
+ 	}
+ 
+ 	return skb->hash;
+ }
+ 
+ __u32 __skb_get_hash_flowi4(struct sk_buff *skb, struct flowi4 *fl);
+ 
+ static inline __u32 skb_get_hash_flowi4(struct sk_buff *skb, struct flowi4 *fl4)
+ {
+ 	if (!skb->l4_hash && !skb->sw_hash) {
+ 		struct flow_keys keys;
+ 
+ 		__skb_set_sw_hash(skb, __get_hash_from_flowi4(fl4, &keys),
+ 				  flow_keys_have_l4(&keys));
+ 	}
+ 
+ 	return skb->hash;
+ }
+ 
+ __u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb);
+ 
+ static inline __u32 skb_get_hash_raw(const struct sk_buff *skb)
+ {
+ 	return skb->hash;
+ }
+ 
++>>>>>>> c6cc1ca7f4d7 (flowi: Abstract out functions to get flow hash based on flowi)
  static inline void skb_copy_hash(struct sk_buff *to, const struct sk_buff *from)
  {
  	to->hash = from->hash;
diff --cc include/net/flow.h
index 484b9b9a822a,dafe97c3c048..000000000000
--- a/include/net/flow.h
+++ b/include/net/flow.h
@@@ -10,7 -10,15 +10,19 @@@
  #include <linux/socket.h>
  #include <linux/in6.h>
  #include <linux/atomic.h>
++<<<<<<< HEAD
 +#include <linux/rh_kabi.h>
++=======
+ #include <net/flow_dissector.h>
+ 
+ /*
+  * ifindex generation is per-net namespace, and loopback is
+  * always the 1st device in ns (see net_dev_init), thus any
+  * loopback device should get ifindex 1
+  */
+ 
+ #define LOOPBACK_IFINDEX	1
++>>>>>>> c6cc1ca7f4d7 (flowi: Abstract out functions to get flow hash based on flowi)
  
  struct flowi_tunnel {
  	__be64			tun_id;
* Unmerged path include/net/flow_dissector.h
* Unmerged path include/linux/skbuff.h
* Unmerged path include/net/flow.h
* Unmerged path include/net/flow_dissector.h
diff --git a/net/core/flow.c b/net/core/flow.c
index e2664a250be5..d46bd34b3091 100644
--- a/net/core/flow.c
+++ b/net/core/flow.c
@@ -22,6 +22,7 @@
 #include <linux/cpumask.h>
 #include <linux/mutex.h>
 #include <net/flow.h>
+#include <net/flow_dissector.h>
 #include <linux/atomic.h>
 #include <linux/security.h>
 #include <net/net_namespace.h>
@@ -498,3 +499,38 @@ void flow_cache_fini(struct net *net)
 	fc->percpu = NULL;
 }
 EXPORT_SYMBOL(flow_cache_fini);
+
+__u32 __get_hash_from_flowi6(struct flowi6 *fl6, struct flow_keys *keys)
+{
+	memset(keys, 0, sizeof(*keys));
+
+	memcpy(&keys->addrs.v6addrs.src, &fl6->saddr,
+	    sizeof(keys->addrs.v6addrs.src));
+	memcpy(&keys->addrs.v6addrs.dst, &fl6->daddr,
+	    sizeof(keys->addrs.v6addrs.dst));
+	keys->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+	keys->ports.src = fl6->fl6_sport;
+	keys->ports.dst = fl6->fl6_dport;
+	keys->keyid.keyid = fl6->fl6_gre_key;
+	keys->tags.flow_label = (__force u32)fl6->flowlabel;
+	keys->basic.ip_proto = fl6->flowi6_proto;
+
+	return flow_hash_from_keys(keys);
+}
+EXPORT_SYMBOL(__get_hash_from_flowi6);
+
+__u32 __get_hash_from_flowi4(struct flowi4 *fl4, struct flow_keys *keys)
+{
+	memset(keys, 0, sizeof(*keys));
+
+	keys->addrs.v4addrs.src = fl4->saddr;
+	keys->addrs.v4addrs.dst = fl4->daddr;
+	keys->control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+	keys->ports.src = fl4->fl4_sport;
+	keys->ports.dst = fl4->fl4_dport;
+	keys->keyid.keyid = fl4->fl4_gre_key;
+	keys->basic.ip_proto = fl4->flowi4_proto;
+
+	return flow_hash_from_keys(keys);
+}
+EXPORT_SYMBOL(__get_hash_from_flowi4);
