autofs - dont hold spin lock over direct mount expire

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] autofs: dont hold spin lock over direct mount expire (Ian Kent) [1320588]
Rebuild_FUZZ: 97.14%
commit-author Ian Kent <ikent@redhat.com>
commit 1c4344a50d702307185cb98fb67bff938cd66aa0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1c4344a5.failed

Commit 7cbdb4a286 altered the autofs indirect mount expire to
not hold a spin lock during the expire check.

The direct mount expire needs the same treatment because to
make autofs expires namespace aware may_umount_tree() needs to
to use a similar method to may_umount() when checking if a mount
tree is in use.

This means may_umount_tree() will end up taking the namespace_sem
for the check so the autofs direct mount expire won't be allowed
to hold a spin lock over the check.

	Signed-off-by: Ian Kent <raven@themaw.net>
	Cc: Al Viro <viro@ZenIV.linux.org.uk>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Omar Sandoval <osandov@osandov.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 1c4344a50d702307185cb98fb67bff938cd66aa0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/expire.c
diff --cc fs/autofs4/expire.c
index 5b220e9acb0a,57725d4a8c59..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -315,28 -310,29 +315,39 @@@ struct dentry *autofs4_expire_direct(st
  	now = jiffies;
  	timeout = sbi->exp_timeout;
  
- 	spin_lock(&sbi->fs_lock);
- 	ino = autofs4_dentry_ino(root);
- 	/* No point expiring a pending mount */
- 	if (ino->flags & AUTOFS_INF_PENDING)
- 		goto out;
  	if (!autofs4_direct_busy(mnt, root, timeout, do_now)) {
++<<<<<<< HEAD
 +		ino->flags |= AUTOFS_INF_NO_RCU;
++=======
+ 		spin_lock(&sbi->fs_lock);
+ 		ino = autofs4_dentry_ino(root);
+ 		/* No point expiring a pending mount */
+ 		if (ino->flags & AUTOFS_INF_PENDING) {
+ 			spin_unlock(&sbi->fs_lock);
+ 			goto out;
+ 		}
+ 		ino->flags |= AUTOFS_INF_WANT_EXPIRE;
++>>>>>>> 1c4344a50d70 (autofs - dont hold spin lock over direct mount expire)
  		spin_unlock(&sbi->fs_lock);
  		synchronize_rcu();
- 		spin_lock(&sbi->fs_lock);
  		if (!autofs4_direct_busy(mnt, root, timeout, do_now)) {
+ 			spin_lock(&sbi->fs_lock);
  			ino->flags |= AUTOFS_INF_EXPIRING;
 +			smp_mb();
 +			ino->flags &= ~AUTOFS_INF_NO_RCU;
  			init_completion(&ino->expire_complete);
  			spin_unlock(&sbi->fs_lock);
  			return root;
  		}
++<<<<<<< HEAD
 +		ino->flags &= ~AUTOFS_INF_NO_RCU;
++=======
+ 		spin_lock(&sbi->fs_lock);
+ 		ino->flags &= ~AUTOFS_INF_WANT_EXPIRE;
+ 		spin_unlock(&sbi->fs_lock);
++>>>>>>> 1c4344a50d70 (autofs - dont hold spin lock over direct mount expire)
  	}
  out:
- 	spin_unlock(&sbi->fs_lock);
  	dput(root);
  
  	return NULL;
* Unmerged path fs/autofs4/expire.c
