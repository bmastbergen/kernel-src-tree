bridge: add vlan info to bridge setlink and dellink notification messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Roopa Prabhu <roopa@cumulusnetworks.com>
commit b7853d73e39b099bbee149cac4c34dbf98f3fefa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b7853d73.failed

vlan add/deletes are not notified to userspace today. This patch adds
vlan info to bridge newlink/dellink notifications generated from the
bridge driver. Notifications use the RTEXT_FILTER_BRVLAN_COMPRESSED
flag to compress vlans into ranges whereever applicable.

The size calculations does not take ranges into account for
simplicity.  This has the potential for allocating a larger skb than
required.

There is an existing inconsistency with bridge NEWLINK and DELLINK
change notifications. Both generate NEWLINK notifications.  Since its
always a NEWLINK notification, this patch includes all vlans the port
belongs to in the notification. The NEWLINK and DELLINK request
messages however only include the vlans to be added and deleted.

	Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b7853d73e39b099bbee149cac4c34dbf98f3fefa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netlink.c
diff --cc net/bridge/br_netlink.c
index 389930889e03,17e0177467f5..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -630,39 -723,7 +650,43 @@@ static int br_fill_info(struct sk_buff 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int br_dev_newlink(struct net *src_net, struct net_device *dev,
 +			  struct nlattr *tb[], struct nlattr *data[])
 +{
 +	struct net_bridge *br = netdev_priv(dev);
 +
 +	if (tb[IFLA_ADDRESS]) {
 +		spin_lock_bh(&br->lock);
 +		br_stp_change_bridge_id(br, nla_data(tb[IFLA_ADDRESS]));
 +		spin_unlock_bh(&br->lock);
 +	}
 +
 +	return register_netdevice(dev);
 +}
 +
 +static size_t br_get_link_af_size(const struct net_device *dev)
 +{
 +	struct net_port_vlans *pv;
 +
 +	if (br_port_exists(dev))
 +		pv = nbp_get_vlan_info(br_port_get_rtnl(dev));
 +	else if (dev->priv_flags & IFF_EBRIDGE)
 +		pv = br_get_vlan_info((struct net_bridge *)netdev_priv(dev));
 +	else
 +		return 0;
 +
 +	if (!pv)
 +		return 0;
 +
 +	/* Each VLAN is returned in bridge_vlan_info along with flags */
 +	return pv->num_vlans * nla_total_size(sizeof(struct bridge_vlan_info));
 +}
 +
 +static struct rtnl_af_ops br_af_ops = {
++=======
+ static struct rtnl_af_ops br_af_ops __read_mostly = {
++>>>>>>> b7853d73e39b (bridge: add vlan info to bridge setlink and dellink notification messages)
  	.family			= AF_BRIDGE,
  	.get_link_af_size	= br_get_link_af_size,
  };
* Unmerged path net/bridge/br_netlink.c
