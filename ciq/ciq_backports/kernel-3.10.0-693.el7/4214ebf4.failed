Fix memory leaks in cifs_do_mount()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Sachin Prabhu <sprabhu@redhat.com>
commit 4214ebf4654798309364d0c678b799e402f38288
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4214ebf4.failed

Fix memory leaks introduced by the patch
fs/cifs: make share unaccessible at root level mountable

Also move allocation of cifs_sb->prepath to cifs_setup_cifs_sb().

	Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
	Tested-by: Aurelien Aptel <aaptel@suse.com>
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit 4214ebf4654798309364d0c678b799e402f38288)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsproto.h
diff --cc fs/cifs/cifsproto.h
index f730c065df34,95dab43646f0..000000000000
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@@ -183,11 -181,10 +183,18 @@@ extern int set_cifs_acl(struct cifs_nts
  
  extern void dequeue_mid(struct mid_q_entry *mid, bool malformed);
  extern int cifs_read_from_socket(struct TCP_Server_Info *server, char *buf,
++<<<<<<< HEAD
 +		     unsigned int to_read);
 +extern int cifs_readv_from_socket(struct TCP_Server_Info *server,
 +		struct kvec *iov_orig, unsigned int nr_segs,
 +		unsigned int to_read);
 +extern void cifs_setup_cifs_sb(struct smb_vol *pvolume_info,
++=======
+ 			         unsigned int to_read);
+ extern int cifs_read_page_from_socket(struct TCP_Server_Info *server,
+ 				      struct page *page, unsigned int to_read);
+ extern int cifs_setup_cifs_sb(struct smb_vol *pvolume_info,
++>>>>>>> 4214ebf46547 (Fix memory leaks in cifs_do_mount())
  			       struct cifs_sb_info *cifs_sb);
  extern int cifs_match_super(struct super_block *, void *);
  extern void cifs_cleanup_volume_info(struct smb_vol *pvolume_info);
diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 79c6909b9f8c..4fc9eaa59a0d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -684,26 +684,22 @@ cifs_do_mount(struct file_system_type *fs_type,
 	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
 	if (cifs_sb->mountdata == NULL) {
 		root = ERR_PTR(-ENOMEM);
-		goto out_cifs_sb;
+		goto out_free;
 	}
 
-	if (volume_info->prepath) {
-		cifs_sb->prepath = kstrdup(volume_info->prepath, GFP_KERNEL);
-		if (cifs_sb->prepath == NULL) {
-			root = ERR_PTR(-ENOMEM);
-			goto out_cifs_sb;
-		}
+	rc = cifs_setup_cifs_sb(volume_info, cifs_sb);
+	if (rc) {
+		root = ERR_PTR(rc);
+		goto out_free;
 	}
 
-	cifs_setup_cifs_sb(volume_info, cifs_sb);
-
 	rc = cifs_mount(cifs_sb, volume_info);
 	if (rc) {
 		if (!(flags & MS_SILENT))
 			cifs_dbg(VFS, "cifs_mount failed w/return code = %d\n",
 				 rc);
 		root = ERR_PTR(rc);
-		goto out_mountdata;
+		goto out_free;
 	}
 
 	mnt_data.vol = volume_info;
@@ -750,9 +746,9 @@ out:
 	cifs_cleanup_volume_info(volume_info);
 	return root;
 
-out_mountdata:
+out_free:
+	kfree(cifs_sb->prepath);
 	kfree(cifs_sb->mountdata);
-out_cifs_sb:
 	kfree(cifs_sb);
 out_nls:
 	unload_nls(volume_info->local_nls);
* Unmerged path fs/cifs/cifsproto.h
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 3fdc63ce2508..9e0a29f678a9 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -3277,7 +3277,7 @@ void reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,
 	}
 }
 
-void cifs_setup_cifs_sb(struct smb_vol *pvolume_info,
+int cifs_setup_cifs_sb(struct smb_vol *pvolume_info,
 			struct cifs_sb_info *cifs_sb)
 {
 	INIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);
@@ -3371,6 +3371,14 @@ void cifs_setup_cifs_sb(struct smb_vol *pvolume_info,
 
 	if ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))
 		cifs_dbg(VFS, "mount option dynperm ignored if cifsacl mount option supported\n");
+
+	if (pvolume_info->prepath) {
+		cifs_sb->prepath = kstrdup(pvolume_info->prepath, GFP_KERNEL);
+		if (cifs_sb->prepath == NULL)
+			return -ENOMEM;
+	}
+
+	return 0;
 }
 
 static void
