Drivers: hv: vmbus: On the read path cleanup the logic to interrupt the host

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hv] vmbus: On the read path cleanup the logic to interrupt the host (Vitaly Kuznetsov) [1406404 1418889]
Rebuild_FUZZ: 90.65%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 3372592a140db69fd63837e81f048ab4abf8111e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3372592a.failed

Signal the host when we determine the host is to be signaled -
on th read path. The currrent code determines the need to signal in the
ringbuffer code and actually issues the signal elsewhere. This can result
in the host viewing this interrupt as spurious since the host may also
poll the channel. Make the necessary adjustments.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3372592a140db69fd63837e81f048ab4abf8111e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hyperv.h
diff --cc include/linux/hyperv.h
index b44df892a232,fdb0a87323f3..000000000000
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@@ -1436,4 -1464,132 +1436,135 @@@ extern __u32 vmbus_proto_version
  int vmbus_send_tl_connect_request(const uuid_le *shv_guest_servie_id,
  				  const uuid_le *shv_host_servie_id);
  void vmbus_set_event(struct vmbus_channel *channel);
++<<<<<<< HEAD
++=======
+ 
+ /* Get the start of the ring buffer. */
+ static inline void *
+ hv_get_ring_buffer(struct hv_ring_buffer_info *ring_info)
+ {
+ 	return (void *)ring_info->ring_buffer->buffer;
+ }
+ 
+ /*
+  * To optimize the flow management on the send-side,
+  * when the sender is blocked because of lack of
+  * sufficient space in the ring buffer, potential the
+  * consumer of the ring buffer can signal the producer.
+  * This is controlled by the following parameters:
+  *
+  * 1. pending_send_sz: This is the size in bytes that the
+  *    producer is trying to send.
+  * 2. The feature bit feat_pending_send_sz set to indicate if
+  *    the consumer of the ring will signal when the ring
+  *    state transitions from being full to a state where
+  *    there is room for the producer to send the pending packet.
+  */
+ 
+ static inline  void hv_signal_on_read(struct vmbus_channel *channel)
+ {
+ 	u32 cur_write_sz;
+ 	u32 pending_sz;
+ 	struct hv_ring_buffer_info *rbi = &channel->inbound;
+ 
+ 	/*
+ 	 * Issue a full memory barrier before making the signaling decision.
+ 	 * Here is the reason for having this barrier:
+ 	 * If the reading of the pend_sz (in this function)
+ 	 * were to be reordered and read before we commit the new read
+ 	 * index (in the calling function)  we could
+ 	 * have a problem. If the host were to set the pending_sz after we
+ 	 * have sampled pending_sz and go to sleep before we commit the
+ 	 * read index, we could miss sending the interrupt. Issue a full
+ 	 * memory barrier to address this.
+ 	 */
+ 	virt_mb();
+ 
+ 	pending_sz = READ_ONCE(rbi->ring_buffer->pending_send_sz);
+ 	/* If the other end is not blocked on write don't bother. */
+ 	if (pending_sz == 0)
+ 		return;
+ 
+ 	cur_write_sz = hv_get_bytes_to_write(rbi);
+ 
+ 	if (cur_write_sz >= pending_sz)
+ 		vmbus_setevent(channel);
+ 
+ 	return;
+ }
+ 
+ /*
+  * An API to support in-place processing of incoming VMBUS packets.
+  */
+ #define VMBUS_PKT_TRAILER	8
+ 
+ static inline struct vmpacket_descriptor *
+ get_next_pkt_raw(struct vmbus_channel *channel)
+ {
+ 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+ 	u32 priv_read_loc = ring_info->priv_read_index;
+ 	void *ring_buffer = hv_get_ring_buffer(ring_info);
+ 	u32 dsize = ring_info->ring_datasize;
+ 	/*
+ 	 * delta is the difference between what is available to read and
+ 	 * what was already consumed in place. We commit read index after
+ 	 * the whole batch is processed.
+ 	 */
+ 	u32 delta = priv_read_loc >= ring_info->ring_buffer->read_index ?
+ 		priv_read_loc - ring_info->ring_buffer->read_index :
+ 		(dsize - ring_info->ring_buffer->read_index) + priv_read_loc;
+ 	u32 bytes_avail_toread = (hv_get_bytes_to_read(ring_info) - delta);
+ 
+ 	if (bytes_avail_toread < sizeof(struct vmpacket_descriptor))
+ 		return NULL;
+ 
+ 	return ring_buffer + priv_read_loc;
+ }
+ 
+ /*
+  * A helper function to step through packets "in-place"
+  * This API is to be called after each successful call
+  * get_next_pkt_raw().
+  */
+ static inline void put_pkt_raw(struct vmbus_channel *channel,
+ 				struct vmpacket_descriptor *desc)
+ {
+ 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+ 	u32 packetlen = desc->len8 << 3;
+ 	u32 dsize = ring_info->ring_datasize;
+ 
+ 	/*
+ 	 * Include the packet trailer.
+ 	 */
+ 	ring_info->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
+ 	ring_info->priv_read_index %= dsize;
+ }
+ 
+ /*
+  * This call commits the read index and potentially signals the host.
+  * Here is the pattern for using the "in-place" consumption APIs:
+  *
+  * while (get_next_pkt_raw() {
+  *	process the packet "in-place";
+  *	put_pkt_raw();
+  * }
+  * if (packets processed in place)
+  *	commit_rd_index();
+  */
+ static inline void commit_rd_index(struct vmbus_channel *channel)
+ {
+ 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+ 	/*
+ 	 * Make sure all reads are done before we update the read index since
+ 	 * the writer may start writing to the read area once the read index
+ 	 * is updated.
+ 	 */
+ 	virt_rmb();
+ 	ring_info->ring_buffer->read_index = ring_info->priv_read_index;
+ 
+ 	hv_signal_on_read(channel);
+ }
+ 
+ 
++>>>>>>> 3372592a140d (Drivers: hv: vmbus: On the read path cleanup the logic to interrupt the host)
  #endif /* _HYPERV_H */
diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index 3d0a3a54c6b4..647182158bc0 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -961,16 +961,9 @@ __vmbus_recvpacket(struct vmbus_channel *channel, void *buffer,
 		   u32 bufferlen, u32 *buffer_actual_len, u64 *requestid,
 		   bool raw)
 {
-	int ret;
-	bool signal = false;
-
-	ret = hv_ringbuffer_read(&channel->inbound, buffer, bufferlen,
-				 buffer_actual_len, requestid, &signal, raw);
+	return hv_ringbuffer_read(channel, buffer, bufferlen,
+				  buffer_actual_len, requestid, raw);
 
-	if (signal)
-		vmbus_setevent(channel);
-
-	return ret;
 }
 
 int vmbus_recvpacket(struct vmbus_channel *channel, void *buffer,
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index 93373f350590..ff9cad9e83c8 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -624,9 +624,9 @@ int hv_ringbuffer_write(struct hv_ring_buffer_info *ring_info,
 		    u32 kv_count, bool *signal, bool lock,
 		    enum hv_signal_policy policy);
 
-int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info,
+int hv_ringbuffer_read(struct vmbus_channel *channel,
 		       void *buffer, u32 buflen, u32 *buffer_actual_len,
-		       u64 *requestid, bool *signal, bool raw);
+		       u64 *requestid, bool raw);
 
 void hv_ringbuffer_get_debuginfo(struct hv_ring_buffer_info *ring_info,
 			    struct hv_ring_buffer_debug_info *debug_info);
diff --git a/drivers/hv/ring_buffer.c b/drivers/hv/ring_buffer.c
index d27dcebfaf0f..4e569570b0fd 100644
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@ -368,9 +368,9 @@ int hv_ringbuffer_write(struct hv_ring_buffer_info *outring_info,
 	return 0;
 }
 
-int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info,
+int hv_ringbuffer_read(struct vmbus_channel *channel,
 		       void *buffer, u32 buflen, u32 *buffer_actual_len,
-		       u64 *requestid, bool *signal, bool raw)
+		       u64 *requestid, bool raw)
 {
 	u32 bytes_avail_toread;
 	u32 next_read_location = 0;
@@ -379,6 +379,7 @@ int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info,
 	u32 offset;
 	u32 packetlen;
 	int ret = 0;
+	struct hv_ring_buffer_info *inring_info = &channel->inbound;
 
 	if (buflen <= 0)
 		return -EINVAL;
@@ -436,7 +437,7 @@ int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info,
 	/* Update the read index */
 	hv_set_next_read_location(inring_info, next_read_location);
 
-	*signal = hv_need_to_signal_on_read(inring_info);
+	hv_signal_on_read(channel);
 
 	return ret;
 }
* Unmerged path include/linux/hyperv.h
