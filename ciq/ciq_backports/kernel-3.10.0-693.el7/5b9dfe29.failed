amd-xgbe: Provide support for receive side scaling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 5b9dfe299e55604af47cdca9d03d2e9d4fe2ad53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5b9dfe29.failed

This patch provides support for receive side scaling (RSS). RSS allows
for spreading incoming network packets across the Rx queues.  When used
in conjunction with the per DMA channel interrupt support, this allows
the receive processing to be spread across multiple processors.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5b9dfe299e55604af47cdca9d03d2e9d4fe2ad53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-common.h
#	drivers/net/ethernet/amd/xgbe/xgbe-dev.c
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
#	drivers/net/ethernet/amd/xgbe/xgbe-main.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-common.h
index 3373e9ef2003,2fe8fc71fe01..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
@@@ -314,6 -308,19 +314,22 @@@
  #define MAC_MACA0LR			0x0304
  #define MAC_MACA1HR			0x0308
  #define MAC_MACA1LR			0x030c
++<<<<<<< HEAD
++=======
+ #define MAC_RSSCR			0x0c80
+ #define MAC_RSSAR			0x0c88
+ #define MAC_RSSDR			0x0c8c
+ #define MAC_TSCR			0x0d00
+ #define MAC_SSIR			0x0d04
+ #define MAC_STSR			0x0d08
+ #define MAC_STNR			0x0d0c
+ #define MAC_STSUR			0x0d10
+ #define MAC_STNUR			0x0d14
+ #define MAC_TSAR			0x0d18
+ #define MAC_TSSR			0x0d20
+ #define MAC_TXSNR			0x0d30
+ #define MAC_TXSSR			0x0d34
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  
  #define MAC_QTFCR_INC			4
  #define MAC_MACA_INC			4
@@@ -421,10 -444,36 +437,35 @@@
  #define MAC_RCR_LM_WIDTH		1
  #define MAC_RCR_RE_INDEX		0
  #define MAC_RCR_RE_WIDTH		1
 -#define MAC_RFCR_PFCE_INDEX		8
 -#define MAC_RFCR_PFCE_WIDTH		1
  #define MAC_RFCR_RFE_INDEX		0
  #define MAC_RFCR_RFE_WIDTH		1
 -#define MAC_RFCR_UP_INDEX		1
 -#define MAC_RFCR_UP_WIDTH		1
  #define MAC_RQC0R_RXQ0EN_INDEX		0
  #define MAC_RQC0R_RXQ0EN_WIDTH		2
++<<<<<<< HEAD
++=======
+ #define MAC_RSSAR_ADDRT_INDEX		2
+ #define MAC_RSSAR_ADDRT_WIDTH		1
+ #define MAC_RSSAR_CT_INDEX		1
+ #define MAC_RSSAR_CT_WIDTH		1
+ #define MAC_RSSAR_OB_INDEX		0
+ #define MAC_RSSAR_OB_WIDTH		1
+ #define MAC_RSSAR_RSSIA_INDEX		8
+ #define MAC_RSSAR_RSSIA_WIDTH		8
+ #define MAC_RSSCR_IP2TE_INDEX		1
+ #define MAC_RSSCR_IP2TE_WIDTH		1
+ #define MAC_RSSCR_RSSE_INDEX		0
+ #define MAC_RSSCR_RSSE_WIDTH		1
+ #define MAC_RSSCR_TCP4TE_INDEX		2
+ #define MAC_RSSCR_TCP4TE_WIDTH		1
+ #define MAC_RSSCR_UDP4TE_INDEX		3
+ #define MAC_RSSCR_UDP4TE_WIDTH		1
+ #define MAC_RSSDR_DMCH_INDEX		0
+ #define MAC_RSSDR_DMCH_WIDTH		4
+ #define MAC_SSIR_SNSINC_INDEX		8
+ #define MAC_SSIR_SNSINC_WIDTH		8
+ #define MAC_SSIR_SSINC_INDEX		16
+ #define MAC_SSIR_SSINC_WIDTH		8
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  #define MAC_TCR_SS_INDEX		29
  #define MAC_TCR_SS_WIDTH		2
  #define MAC_TCR_TE_INDEX		0
@@@ -770,6 -863,14 +811,17 @@@
  #define RX_PACKET_ATTRIBUTES_VLAN_CTAG_WIDTH	1
  #define RX_PACKET_ATTRIBUTES_INCOMPLETE_INDEX	2
  #define RX_PACKET_ATTRIBUTES_INCOMPLETE_WIDTH	1
++<<<<<<< HEAD
++=======
+ #define RX_PACKET_ATTRIBUTES_CONTEXT_NEXT_INDEX	3
+ #define RX_PACKET_ATTRIBUTES_CONTEXT_NEXT_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_CONTEXT_INDEX	4
+ #define RX_PACKET_ATTRIBUTES_CONTEXT_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_RX_TSTAMP_INDEX	5
+ #define RX_PACKET_ATTRIBUTES_RX_TSTAMP_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_RSS_HASH_INDEX	6
+ #define RX_PACKET_ATTRIBUTES_RSS_HASH_WIDTH	1
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  
  #define RX_NORMAL_DESC0_OVT_INDEX		0
  #define RX_NORMAL_DESC0_OVT_WIDTH		16
@@@ -777,15 -884,33 +829,26 @@@
  #define RX_NORMAL_DESC3_ES_WIDTH		1
  #define RX_NORMAL_DESC3_ETLT_INDEX		16
  #define RX_NORMAL_DESC3_ETLT_WIDTH		4
 -#define RX_NORMAL_DESC3_FD_INDEX		29
 -#define RX_NORMAL_DESC3_FD_WIDTH		1
  #define RX_NORMAL_DESC3_INTE_INDEX		30
  #define RX_NORMAL_DESC3_INTE_WIDTH		1
+ #define RX_NORMAL_DESC3_L34T_INDEX		20
+ #define RX_NORMAL_DESC3_L34T_WIDTH		4
  #define RX_NORMAL_DESC3_LD_INDEX		28
  #define RX_NORMAL_DESC3_LD_WIDTH		1
  #define RX_NORMAL_DESC3_OWN_INDEX		31
  #define RX_NORMAL_DESC3_OWN_WIDTH		1
  #define RX_NORMAL_DESC3_PL_INDEX		0
  #define RX_NORMAL_DESC3_PL_WIDTH		14
+ #define RX_NORMAL_DESC3_RSV_INDEX		26
+ #define RX_NORMAL_DESC3_RSV_WIDTH		1
+ 
+ #define RX_DESC3_L34T_IPV4_TCP			1
+ #define RX_DESC3_L34T_IPV4_UDP			2
+ #define RX_DESC3_L34T_IPV4_ICMP			3
+ #define RX_DESC3_L34T_IPV6_TCP			9
+ #define RX_DESC3_L34T_IPV6_UDP			10
+ #define RX_DESC3_L34T_IPV6_ICMP			11
  
 -#define RX_CONTEXT_DESC3_TSA_INDEX		4
 -#define RX_CONTEXT_DESC3_TSA_WIDTH		1
 -#define RX_CONTEXT_DESC3_TSD_INDEX		6
 -#define RX_CONTEXT_DESC3_TSD_WIDTH		1
 -
  #define TX_PACKET_ATTRIBUTES_CSUM_ENABLE_INDEX	0
  #define TX_PACKET_ATTRIBUTES_CSUM_ENABLE_WIDTH	1
  #define TX_PACKET_ATTRIBUTES_TSO_ENABLE_INDEX	1
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index 2da3691ffcd6,551794c29d09..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@@ -334,6 -335,143 +334,146 @@@ static void xgbe_config_tso_mode(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void xgbe_config_sph_mode(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_CR, SPH, 1);
+ 	}
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, HDSMS, XGBE_SPH_HDSMS_SIZE);
+ }
+ 
+ static int xgbe_write_rss_reg(struct xgbe_prv_data *pdata, unsigned int type,
+ 			      unsigned int index, unsigned int val)
+ {
+ 	unsigned int wait;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&pdata->rss_mutex);
+ 
+ 	if (XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB)) {
+ 		ret = -EBUSY;
+ 		goto unlock;
+ 	}
+ 
+ 	XGMAC_IOWRITE(pdata, MAC_RSSDR, val);
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, RSSIA, index);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, ADDRT, type);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, CT, 0);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, OB, 1);
+ 
+ 	wait = 1000;
+ 	while (wait--) {
+ 		if (!XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB))
+ 			goto unlock;
+ 
+ 		usleep_range(1000, 1500);
+ 	}
+ 
+ 	ret = -EBUSY;
+ 
+ unlock:
+ 	mutex_unlock(&pdata->rss_mutex);
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_write_rss_hash_key(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int key_regs = sizeof(pdata->rss_key) / sizeof(u32);
+ 	unsigned int *key = (unsigned int *)&pdata->rss_key;
+ 	int ret;
+ 
+ 	while (key_regs--) {
+ 		ret = xgbe_write_rss_reg(pdata, XGBE_RSS_HASH_KEY_TYPE,
+ 					 key_regs, *key++);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_write_rss_lookup_table(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++) {
+ 		ret = xgbe_write_rss_reg(pdata,
+ 					 XGBE_RSS_LOOKUP_TABLE_TYPE, i,
+ 					 pdata->rss_table[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_enable_rss(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	if (!pdata->hw_feat.rss)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Program the hash key */
+ 	ret = xgbe_write_rss_hash_key(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Program the lookup table */
+ 	ret = xgbe_write_rss_lookup_table(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Set the RSS options */
+ 	XGMAC_IOWRITE(pdata, MAC_RSSCR, pdata->rss_options);
+ 
+ 	/* Enable RSS */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 1);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_disable_rss(struct xgbe_prv_data *pdata)
+ {
+ 	if (!pdata->hw_feat.rss)
+ 		return -EOPNOTSUPP;
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 0);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_config_rss(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	if (!pdata->hw_feat.rss)
+ 		return;
+ 
+ 	if (pdata->netdev->features & NETIF_F_RXHASH)
+ 		ret = xgbe_enable_rss(pdata);
+ 	else
+ 		ret = xgbe_disable_rss(pdata);
+ 
+ 	if (ret)
+ 		netdev_err(pdata->netdev,
+ 			   "error configuring RSS, RSS disabled\n");
+ }
+ 
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  static int xgbe_disable_tx_flow_control(struct xgbe_prv_data *pdata)
  {
  	unsigned int max_q_count, q_count;
@@@ -1129,6 -1544,50 +1269,53 @@@ static int xgbe_dev_read(struct xgbe_ch
  	xgbe_dump_rx_desc(ring, rdesc, ring->cur);
  #endif
  
++<<<<<<< HEAD
++=======
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, CTXT)) {
+ 		/* Timestamp Context Descriptor */
+ 		xgbe_get_rx_tstamp(packet, rdesc);
+ 
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       CONTEXT, 1);
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       CONTEXT_NEXT, 0);
+ 		return 0;
+ 	}
+ 
+ 	/* Normal Descriptor, be sure Context Descriptor bit is off */
+ 	XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES, CONTEXT, 0);
+ 
+ 	/* Indicate if a Context Descriptor is next */
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, CDA))
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       CONTEXT_NEXT, 1);
+ 
+ 	/* Get the header length */
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, FD))
+ 		rdata->hdr_len = XGMAC_GET_BITS_LE(rdesc->desc2,
+ 						   RX_NORMAL_DESC2, HL);
+ 
+ 	/* Get the RSS hash */
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, RSV)) {
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       RSS_HASH, 1);
+ 
+ 		packet->rss_hash = le32_to_cpu(rdesc->desc1);
+ 
+ 		l34t = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, L34T);
+ 		switch (l34t) {
+ 		case RX_DESC3_L34T_IPV4_TCP:
+ 		case RX_DESC3_L34T_IPV4_UDP:
+ 		case RX_DESC3_L34T_IPV6_TCP:
+ 		case RX_DESC3_L34T_IPV6_UDP:
+ 			packet->rss_hash_type = PKT_HASH_TYPE_L4;
+ 
+ 		default:
+ 			packet->rss_hash_type = PKT_HASH_TYPE_L3;
+ 		}
+ 	}
+ 
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  	/* Get the packet length */
  	rdata->len = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, PL);
  
@@@ -2084,6 -2619,8 +2271,11 @@@ static int xgbe_init(struct xgbe_prv_da
  	xgbe_config_tx_coalesce(pdata);
  	xgbe_config_rx_buffer_size(pdata);
  	xgbe_config_tso_mode(pdata);
++<<<<<<< HEAD
++=======
+ 	xgbe_config_sph_mode(pdata);
+ 	xgbe_config_rss(pdata);
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  	desc_if->wrapper_tx_desc_init(pdata);
  	desc_if->wrapper_rx_desc_init(pdata);
  	xgbe_enable_dma_interrupts(pdata);
@@@ -2209,5 -2745,20 +2401,23 @@@ void xgbe_init_function_ptrs_dev(struc
  	hw_if->rx_mmc_int = xgbe_rx_mmc_int;
  	hw_if->read_mmc_stats = xgbe_read_mmc_stats;
  
++<<<<<<< HEAD
++=======
+ 	/* For PTP config */
+ 	hw_if->config_tstamp = xgbe_config_tstamp;
+ 	hw_if->update_tstamp_addend = xgbe_update_tstamp_addend;
+ 	hw_if->set_tstamp_time = xgbe_set_tstamp_time;
+ 	hw_if->get_tstamp_time = xgbe_get_tstamp_time;
+ 	hw_if->get_tx_tstamp = xgbe_get_tx_tstamp;
+ 
+ 	/* For Data Center Bridging config */
+ 	hw_if->config_dcb_tc = xgbe_config_dcb_tc;
+ 	hw_if->config_dcb_pfc = xgbe_config_dcb_pfc;
+ 
+ 	/* For Receive Side Scaling */
+ 	hw_if->enable_rss = xgbe_enable_rss;
+ 	hw_if->disable_rss = xgbe_disable_rss;
+ 
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  	DBGPR("<--xgbe_init_function_ptrs\n");
  }
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index 6baf601c4282,6c5a7079697c..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -1034,26 -1661,35 +1034,45 @@@ static int xgbe_set_features(struct net
  {
  	struct xgbe_prv_data *pdata = netdev_priv(netdev);
  	struct xgbe_hw_if *hw_if = &pdata->hw_if;
++<<<<<<< HEAD
 +	unsigned int rxcsum_enabled, rxvlan_enabled;
 +
 +	rxcsum_enabled = !!(pdata->netdev_features & NETIF_F_RXCSUM);
 +	rxvlan_enabled = !!(pdata->netdev_features & NETIF_F_HW_VLAN_CTAG_RX);
 +
 +	if ((features & NETIF_F_RXCSUM) && !rxcsum_enabled) {
++=======
+ 	netdev_features_t rxhash, rxcsum, rxvlan, rxvlan_filter;
+ 	int ret = 0;
+ 
+ 	rxhash = pdata->netdev_features & NETIF_F_RXHASH;
+ 	rxcsum = pdata->netdev_features & NETIF_F_RXCSUM;
+ 	rxvlan = pdata->netdev_features & NETIF_F_HW_VLAN_CTAG_RX;
+ 	rxvlan_filter = pdata->netdev_features & NETIF_F_HW_VLAN_CTAG_FILTER;
+ 
+ 	if ((features & NETIF_F_RXHASH) && !rxhash)
+ 		ret = hw_if->enable_rss(pdata);
+ 	else if (!(features & NETIF_F_RXHASH) && rxhash)
+ 		ret = hw_if->disable_rss(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if ((features & NETIF_F_RXCSUM) && !rxcsum)
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  		hw_if->enable_rx_csum(pdata);
 -	else if (!(features & NETIF_F_RXCSUM) && rxcsum)
 +		netdev_alert(netdev, "state change - rxcsum enabled\n");
 +	} else if (!(features & NETIF_F_RXCSUM) && rxcsum_enabled) {
  		hw_if->disable_rx_csum(pdata);
 +		netdev_alert(netdev, "state change - rxcsum disabled\n");
 +	}
  
 -	if ((features & NETIF_F_HW_VLAN_CTAG_RX) && !rxvlan)
 +	if ((features & NETIF_F_HW_VLAN_CTAG_RX) && !rxvlan_enabled) {
  		hw_if->enable_rx_vlan_stripping(pdata);
 -	else if (!(features & NETIF_F_HW_VLAN_CTAG_RX) && rxvlan)
 +		netdev_alert(netdev, "state change - rxvlan enabled\n");
 +	} else if (!(features & NETIF_F_HW_VLAN_CTAG_RX) && rxvlan_enabled) {
  		hw_if->disable_rx_vlan_stripping(pdata);
 -
 -	if ((features & NETIF_F_HW_VLAN_CTAG_FILTER) && !rxvlan_filter)
 -		hw_if->enable_rx_vlan_filtering(pdata);
 -	else if (!(features & NETIF_F_HW_VLAN_CTAG_FILTER) && rxvlan_filter)
 -		hw_if->disable_rx_vlan_filtering(pdata);
 +		netdev_alert(netdev, "state change - rxvlan disabled\n");
 +	}
  
  	pdata->netdev_features = features;
  
@@@ -1262,6 -1959,21 +1281,24 @@@ read_again
  			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
  					       packet->vlan_ctag);
  
++<<<<<<< HEAD
++=======
+ 		if (XGMAC_GET_BITS(packet->attributes,
+ 				   RX_PACKET_ATTRIBUTES, RX_TSTAMP)) {
+ 			u64 nsec;
+ 
+ 			nsec = timecounter_cyc2time(&pdata->tstamp_tc,
+ 						    packet->rx_tstamp);
+ 			hwtstamps = skb_hwtstamps(skb);
+ 			hwtstamps->hwtstamp = ns_to_ktime(nsec);
+ 		}
+ 
+ 		if (XGMAC_GET_BITS(packet->attributes,
+ 				   RX_PACKET_ATTRIBUTES, RSS_HASH))
+ 			skb_set_hash(skb, packet->rss_hash,
+ 				     packet->rss_hash_type);
+ 
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  		skb->dev = netdev;
  		skb->protocol = eth_type_trans(skb, netdev);
  		skb_record_rx_queue(skb, channel->queue_index);
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-main.c
index 5ad0a540825b,05fbdf96e77e..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@@ -245,6 -191,8 +246,11 @@@ static int xgbe_probe(struct platform_d
  
  	spin_lock_init(&pdata->lock);
  	mutex_init(&pdata->xpcs_mutex);
++<<<<<<< HEAD
++=======
+ 	mutex_init(&pdata->rss_mutex);
+ 	spin_lock_init(&pdata->tstamp_lock);
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  
  	/* Set and validate the number of descriptors for a ring */
  	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);
@@@ -366,13 -337,16 +372,26 @@@
  		goto err_io;
  	}
  
++<<<<<<< HEAD
 +	/* Allocate the rings for the DMA channels */
 +	pdata->channel = xgbe_alloc_rings(pdata);
 +	if (!pdata->channel) {
 +		dev_err(dev, "ring allocation failed\n");
 +		ret = -ENOMEM;
 +		goto err_io;
 +	}
++=======
+ 	/* Initialize RSS hash key and lookup table */
+ 	get_random_bytes(pdata->rss_key, sizeof(pdata->rss_key));
+ 
+ 	for (i = 0; i < XGBE_RSS_MAX_TABLE_SIZE; i++)
+ 		XGMAC_SET_BITS(pdata->rss_table[i], MAC_RSSDR, DMCH,
+ 			       i % pdata->rx_ring_count);
+ 
+ 	XGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, IP2TE, 1);
+ 	XGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, TCP4TE, 1);
+ 	XGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, UDP4TE, 1);
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  
  	/* Prepare to regsiter with MDIO */
  	pdata->mii_bus_id = kasprintf(GFP_KERNEL, "%s", pdev->name);
@@@ -398,8 -375,12 +417,11 @@@
  			      NETIF_F_TSO6 |
  			      NETIF_F_GRO |
  			      NETIF_F_HW_VLAN_CTAG_RX |
 -			      NETIF_F_HW_VLAN_CTAG_TX |
 -			      NETIF_F_HW_VLAN_CTAG_FILTER;
 +			      NETIF_F_HW_VLAN_CTAG_TX;
  
+ 	if (pdata->hw_feat.rss)
+ 		netdev->hw_features |= NETIF_F_RXHASH;
+ 
  	netdev->vlan_features |= NETIF_F_SG |
  				 NETIF_F_IP_CSUM |
  				 NETIF_F_IPV6_CSUM |
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 30435fbd04b3,2ac4f176ad88..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -194,7 -212,15 +194,13 @@@
  /* Flow control queue count */
  #define XGMAC_MAX_FLOW_CONTROL_QUEUES	8
  
 -/* Maximum MAC address hash table size (256 bits = 8 bytes) */
 -#define XGBE_MAC_HASH_TABLE_SIZE	8
  
+ /* Receive Side Scaling */
+ #define XGBE_RSS_HASH_KEY_SIZE		40
+ #define XGBE_RSS_MAX_TABLE_SIZE		256
+ #define XGBE_RSS_LOOKUP_TABLE_TYPE	0
+ #define XGBE_RSS_HASH_KEY_TYPE		1
+ 
  struct xgbe_prv_data;
  
  struct xgbe_packet_data {
@@@ -211,6 -237,11 +217,14 @@@
  	unsigned short mss;
  
  	unsigned short vlan_ctag;
++<<<<<<< HEAD
++=======
+ 
+ 	u64 rx_tstamp;
+ 
+ 	u32 rss_hash;
+ 	enum pkt_hash_types rss_hash_type;
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  };
  
  /* Common Rx and Tx descriptor mapping */
@@@ -461,6 -541,22 +475,25 @@@ struct xgbe_hw_if 
  	void (*rx_mmc_int)(struct xgbe_prv_data *);
  	void (*tx_mmc_int)(struct xgbe_prv_data *);
  	void (*read_mmc_stats)(struct xgbe_prv_data *);
++<<<<<<< HEAD
++=======
+ 
+ 	/* For Timestamp config */
+ 	int (*config_tstamp)(struct xgbe_prv_data *, unsigned int);
+ 	void (*update_tstamp_addend)(struct xgbe_prv_data *, unsigned int);
+ 	void (*set_tstamp_time)(struct xgbe_prv_data *, unsigned int sec,
+ 				unsigned int nsec);
+ 	u64 (*get_tstamp_time)(struct xgbe_prv_data *);
+ 	u64 (*get_tx_tstamp)(struct xgbe_prv_data *);
+ 
+ 	/* For Data Center Bridging config */
+ 	void (*config_dcb_tc)(struct xgbe_prv_data *);
+ 	void (*config_dcb_pfc)(struct xgbe_prv_data *);
+ 
+ 	/* For Receive Side Scaling */
+ 	int (*enable_rss)(struct xgbe_prv_data *);
+ 	int (*disable_rss)(struct xgbe_prv_data *);
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  };
  
  struct xgbe_desc_if {
@@@ -529,7 -629,11 +562,15 @@@ struct xgbe_prv_data 
  	/* XPCS indirect addressing mutex */
  	struct mutex xpcs_mutex;
  
++<<<<<<< HEAD
 +	int irq_number;
++=======
+ 	/* RSS addressing mutex */
+ 	struct mutex rss_mutex;
+ 
+ 	int dev_irq;
+ 	unsigned int per_channel_irq;
++>>>>>>> 5b9dfe299e55 (amd-xgbe: Provide support for receive side scaling)
  
  	struct xgbe_hw_if hw_if;
  	struct xgbe_desc_if desc_if;
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-common.h
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-dev.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-main.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
