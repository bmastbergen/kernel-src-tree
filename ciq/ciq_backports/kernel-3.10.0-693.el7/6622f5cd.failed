i40e: make use of __dev_uc_sync and __dev_mc_sync

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 6622f5cdbaf3786314d76969d2aab132b36ba2e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6622f5cd.failed

The kernel provides __dev_uc_sync and __dev_mc_sync in order for drivers
which need individual notification of add and delete for each filter.
These functions allow us to vastly simplify our .set_rx_mode handler. We
need to implement two functions for sync and unsync which add and remove
filters respectively.

This change avoids a very complex and inefficient algorithm which
resulted in an abnormal latency for the .set_rx_mode NDO operation. The
resulting code after this change is more readable, more efficient, and
less code.

Due to the callback signature used by these functions we also must
update several other functions to take a const u8 * pointer.

Change-Id: I2ca7fd4e10c0c07ed2291db1ea41bf5987fc6474
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 6622f5cdbaf3786314d76969d2aab132b36ba2e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index 68870b273109,a9c02289049f..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -725,10 -720,8 +725,15 @@@ u32 i40e_get_global_fd_count(struct i40
  bool i40e_set_ntuple(struct i40e_pf *pf, netdev_features_t features);
  void i40e_set_ethtool_ops(struct net_device *netdev);
  struct i40e_mac_filter *i40e_add_filter(struct i40e_vsi *vsi,
++<<<<<<< HEAD
 +					u8 *macaddr, s16 vlan,
 +					bool is_vf, bool is_netdev);
 +void i40e_del_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan,
 +		     bool is_vf, bool is_netdev);
++=======
+ 					const u8 *macaddr, s16 vlan);
+ void i40e_del_filter(struct i40e_vsi *vsi, const u8 *macaddr, s16 vlan);
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  int i40e_sync_vsi_filters(struct i40e_vsi *vsi);
  struct i40e_vsi *i40e_vsi_setup(struct i40e_pf *pf, u8 type,
  				u16 uplink, u32 param1);
@@@ -819,13 -812,11 +824,21 @@@ int i40e_vsi_open(struct i40e_vsi *vsi)
  void i40e_vlan_stripping_disable(struct i40e_vsi *vsi);
  int i40e_vsi_add_vlan(struct i40e_vsi *vsi, s16 vid);
  int i40e_vsi_kill_vlan(struct i40e_vsi *vsi, s16 vid);
++<<<<<<< HEAD
 +struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +					     bool is_vf, bool is_netdev);
 +int i40e_del_mac_all_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +			  bool is_vf, bool is_netdev);
 +bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi);
 +struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, u8 *macaddr,
 +				      bool is_vf, bool is_netdev);
++=======
+ struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi,
+ 					     const u8 *macaddr);
+ int i40e_del_mac_all_vlan(struct i40e_vsi *vsi, const u8 *macaddr);
+ bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi);
+ struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, const u8 *macaddr);
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  #ifdef I40E_FCOE
  int __i40e_setup_tc(struct net_device *netdev, u32 handle, __be16 proto,
  		    struct tc_to_netdev *tc);
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 6f5b9c2cdeec,c63dc0153765..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -1157,8 -1149,7 +1157,12 @@@ void i40e_update_stats(struct i40e_vsi 
   * Returns ptr to the filter object or NULL
   **/
  static struct i40e_mac_filter *i40e_find_filter(struct i40e_vsi *vsi,
++<<<<<<< HEAD
 +						u8 *macaddr, s16 vlan,
 +						bool is_vf, bool is_netdev)
++=======
+ 						const u8 *macaddr, s16 vlan)
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  {
  	struct i40e_mac_filter *f;
  
@@@ -1185,8 -1172,7 +1189,12 @@@
   * Returns the first filter with the provided MAC address or NULL if
   * MAC address was not found
   **/
++<<<<<<< HEAD
 +struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, u8 *macaddr,
 +				      bool is_vf, bool is_netdev)
++=======
+ struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, const u8 *macaddr)
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  {
  	struct i40e_mac_filter *f;
  
@@@ -1235,8 -1217,8 +1243,13 @@@ bool i40e_is_vsi_in_vlan(struct i40e_vs
   *
   * Returns first filter found on success, else NULL
   **/
++<<<<<<< HEAD
 +struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +					     bool is_vf, bool is_netdev)
++=======
+ struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi,
+ 					     const u8 *macaddr)
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  {
  	struct i40e_mac_filter *f;
  
@@@ -1266,8 -1244,7 +1279,12 @@@
   *
   * Returns 0 for success, or error
   **/
++<<<<<<< HEAD
 +int i40e_del_mac_all_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +			  bool is_vf, bool is_netdev)
++=======
+ int i40e_del_mac_all_vlan(struct i40e_vsi *vsi, const u8 *macaddr)
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  {
  	struct i40e_mac_filter *f = NULL;
  	int changed = 0;
@@@ -1306,11 -1276,9 +1323,15 @@@
   * being held.
   **/
  struct i40e_mac_filter *i40e_add_filter(struct i40e_vsi *vsi,
++<<<<<<< HEAD
 +					u8 *macaddr, s16 vlan,
 +					bool is_vf, bool is_netdev)
++=======
+ 					const u8 *macaddr, s16 vlan)
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  {
  	struct i40e_mac_filter *f;
 +	int changed = false;
  
  	if (!vsi || !macaddr)
  		return NULL;
@@@ -1374,9 -1339,7 +1395,13 @@@ add_filter_out
   * the "safe" variants of any list iterators, e.g. list_for_each_entry_safe()
   * instead of list_for_each_entry().
   **/
++<<<<<<< HEAD
 +void i40e_del_filter(struct i40e_vsi *vsi,
 +		     u8 *macaddr, s16 vlan,
 +		     bool is_vf, bool is_netdev)
++=======
+ void i40e_del_filter(struct i40e_vsi *vsi, const u8 *macaddr, s16 vlan)
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  {
  	struct i40e_mac_filter *f;
  
@@@ -1647,56 -1629,9 +1717,59 @@@ static void i40e_set_rx_mode(struct net
  
  	spin_lock_bh(&vsi->mac_filter_list_lock);
  
++<<<<<<< HEAD
 +	/* add addr if not already in the filter list */
 +	netdev_for_each_uc_addr(uca, netdev) {
 +		if (!i40e_find_mac(vsi, uca->addr, false, true)) {
 +			if (i40e_is_vsi_in_vlan(vsi))
 +				i40e_put_mac_in_vlan(vsi, uca->addr,
 +						     false, true);
 +			else
 +				i40e_add_filter(vsi, uca->addr, I40E_VLAN_ANY,
 +						false, true);
 +		}
 +	}
 +
 +	netdev_for_each_mc_addr(mca, netdev) {
 +		if (!i40e_find_mac(vsi, mca->addr, false, true)) {
 +			if (i40e_is_vsi_in_vlan(vsi))
 +				i40e_put_mac_in_vlan(vsi, mca->addr,
 +						     false, true);
 +			else
 +				i40e_add_filter(vsi, mca->addr, I40E_VLAN_ANY,
 +						false, true);
 +		}
 +	}
 +
 +	/* remove filter if not in netdev list */
 +	list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list) {
 +
 +		if (!f->is_netdev)
 +			continue;
 +
 +		netdev_for_each_mc_addr(mca, netdev)
 +			if (ether_addr_equal(mca->addr, f->macaddr))
 +				goto bottom_of_search_loop;
 +
 +		netdev_for_each_uc_addr(uca, netdev)
 +			if (ether_addr_equal(uca->addr, f->macaddr))
 +				goto bottom_of_search_loop;
 +
 +		for_each_dev_addr(netdev, ha)
 +			if (ether_addr_equal(ha->addr, f->macaddr))
 +				goto bottom_of_search_loop;
 +
 +		/* f->macaddr wasn't found in uc, mc, or ha list so delete it */
 +		i40e_del_filter(vsi, f->macaddr, I40E_VLAN_ANY, false, true);
 +
 +bottom_of_search_loop:
 +		continue;
 +	}
++=======
+ 	__dev_uc_sync(netdev, i40e_addr_sync, i40e_addr_unsync);
+ 	__dev_mc_sync(netdev, i40e_addr_sync, i40e_addr_unsync);
+ 
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  	spin_unlock_bh(&vsi->mac_filter_list_lock);
  
  	/* check for other flag changes */
@@@ -9580,9 -9440,17 +9653,22 @@@ int i40e_vsi_release(struct i40e_vsi *v
  	}
  
  	spin_lock_bh(&vsi->mac_filter_list_lock);
+ 
+ 	/* clear the sync flag on all filters */
+ 	if (vsi->netdev) {
+ 		__dev_uc_unsync(vsi->netdev, NULL);
+ 		__dev_mc_unsync(vsi->netdev, NULL);
+ 	}
+ 
+ 	/* make sure any remaining filters are marked for deletion */
  	list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list)
++<<<<<<< HEAD
 +		i40e_del_filter(vsi, f->macaddr, f->vlan,
 +				f->is_vf, f->is_netdev);
++=======
+ 		i40e_del_filter(vsi, f->macaddr, f->vlan);
+ 
++>>>>>>> 6622f5cdbaf3 (i40e: make use of __dev_uc_sync and __dev_mc_sync)
  	spin_unlock_bh(&vsi->mac_filter_list_lock);
  
  	i40e_sync_vsi_filters(vsi);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
