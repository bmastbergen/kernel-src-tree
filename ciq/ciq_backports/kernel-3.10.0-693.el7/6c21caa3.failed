USB: OHCI: make ohci-da8xx a separate driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [usb] ohci: make ohci-da8xx a separate driver (Torez Smith) [1383823]
Rebuild_FUZZ: 93.98%
commit-author Manjunath Goudar <manjunath.goudar@linaro.org>
commit 6c21caa333f98e9adb93be5f01f5a4041c0d9256
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6c21caa3.failed

Separate the Davinci OHCI host controller driver from ohci-hcd
host code so that it can be built as a separate driver module.
This work is part of enabling multi-platform kernels on ARM

	Tested-by: David Lechner <david@lechnology.com>
	Signed-off-by: Manjunath Goudar <manjunath.goudar@linaro.org>
[Axel: adapted and rebased, fixed minor comments]
	Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6c21caa333f98e9adb93be5f01f5a4041c0d9256)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/Kconfig
#	drivers/usb/host/ohci-da8xx.c
diff --cc drivers/usb/host/Kconfig
index 68681d8826ce,6361fc739306..000000000000
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@@ -491,9 -479,10 +491,14 @@@ config USB_OHCI_HCD_OMAP
  	  OMAP3 and later chips.
  
  config USB_OHCI_HCD_DAVINCI
- 	bool "OHCI support for TI DaVinci DA8xx"
+ 	tristate "OHCI support for TI DaVinci DA8xx"
  	depends on ARCH_DAVINCI_DA8XX
++<<<<<<< HEAD
 +	depends on USB_OHCI_HCD=y
++=======
+ 	depends on USB_OHCI_HCD
+ 	select PHY_DA8XX_USB
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  	default y
  	help
  	  Enables support for the DaVinci DA8xx integrated OHCI
diff --cc drivers/usb/host/ohci-da8xx.c
index 0b815a856811,30c48789389e..000000000000
--- a/drivers/usb/host/ohci-da8xx.c
+++ b/drivers/usb/host/ohci-da8xx.c
@@@ -11,22 -11,32 +11,40 @@@
   * kind, whether express or implied.
   */
  
+ #include <linux/clk.h>
+ #include <linux/io.h>
  #include <linux/interrupt.h>
  #include <linux/jiffies.h>
+ #include <linux/kernel.h>
+ #include <linux/module.h>
  #include <linux/platform_device.h>
++<<<<<<< HEAD
 +#include <linux/clk.h>
 +
 +#include <mach/da8xx.h>
++=======
+ #include <linux/phy/phy.h>
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  #include <linux/platform_data/usb-davinci.h>
+ #include <linux/usb.h>
+ #include <linux/usb/hcd.h>
+ #include <asm/unaligned.h>
  
- #ifndef CONFIG_ARCH_DAVINCI_DA8XX
- #error "This file is DA8xx bus glue.  Define CONFIG_ARCH_DAVINCI_DA8XX."
- #endif
+ #include "ohci.h"
+ 
+ #define DRIVER_DESC "DA8XX"
+ #define DRV_NAME "ohci"
+ 
+ static struct hc_driver __read_mostly ohci_da8xx_hc_driver;
+ 
+ static int (*orig_ohci_hub_control)(struct usb_hcd  *hcd, u16 typeReq,
+ 			u16 wValue, u16 wIndex, char *buf, u16 wLength);
+ static int (*orig_ohci_hub_status_data)(struct usb_hcd *hcd, char *buf);
  
 +#define CFGCHIP2	DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP2_REG)
 +
  static struct clk *usb11_clk;
 -static struct phy *usb11_phy;
 +static struct clk *usb20_clk;
  
  /* Over-current indicator change bitmask */
  static volatile u16 ocic_mask;
@@@ -82,10 -87,10 +100,10 @@@ static void ohci_da8xx_ocic_handler(str
  		hub->set_power(port, 0);
  }
  
- static int ohci_da8xx_init(struct usb_hcd *hcd)
+ static int ohci_da8xx_reset(struct usb_hcd *hcd)
  {
  	struct device *dev		= hcd->self.controller;
 -	struct da8xx_ohci_root_hub *hub	= dev_get_platdata(dev);
 +	struct da8xx_ohci_root_hub *hub	= dev->platform_data;
  	struct ohci_hcd	*ohci		= hcd_to_ohci(hcd);
  	int result;
  	u32 rh_a;
@@@ -100,9 -107,11 +118,15 @@@
  	 */
  	ohci->num_ports = 1;
  
++<<<<<<< HEAD
 +	result = ohci_init(ohci);
 +	if (result < 0)
++=======
+ 	result = ohci_setup(hcd);
+ 	if (result < 0) {
+ 		ohci_da8xx_disable();
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  		return result;
 -	}
  
  	/*
  	 * Since we're providing a board-specific root hub port power control
@@@ -126,24 -135,6 +150,27 @@@
  	return result;
  }
  
++<<<<<<< HEAD
 +static void ohci_da8xx_stop(struct usb_hcd *hcd)
 +{
 +	ohci_stop(hcd);
 +	ohci_da8xx_clock(0);
 +}
 +
 +static int ohci_da8xx_start(struct usb_hcd *hcd)
 +{
 +	struct ohci_hcd	*ohci		= hcd_to_ohci(hcd);
 +	int result;
 +
 +	result = ohci_run(ohci);
 +	if (result < 0)
 +		ohci_da8xx_stop(hcd);
 +
 +	return result;
 +}
 +
++=======
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  /*
   * Update the status data from the hub with the over-current indicator change.
   */
@@@ -231,68 -222,15 +258,15 @@@ check_port
  		}
  	}
  
- 	return ohci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);
+ 	return orig_ohci_hub_control(hcd, typeReq, wValue,
+ 			wIndex, buf, wLength);
  }
  
- static const struct hc_driver ohci_da8xx_hc_driver = {
- 	.description		= hcd_name,
- 	.product_desc		= "DA8xx OHCI",
- 	.hcd_priv_size		= sizeof(struct ohci_hcd),
- 
- 	/*
- 	 * generic hardware linkage
- 	 */
- 	.irq			= ohci_irq,
- 	.flags			= HCD_USB11 | HCD_MEMORY,
- 
- 	/*
- 	 * basic lifecycle operations
- 	 */
- 	.reset			= ohci_da8xx_init,
- 	.start			= ohci_da8xx_start,
- 	.stop			= ohci_da8xx_stop,
- 	.shutdown		= ohci_shutdown,
- 
- 	/*
- 	 * managing i/o requests and associated device resources
- 	 */
- 	.urb_enqueue		= ohci_urb_enqueue,
- 	.urb_dequeue		= ohci_urb_dequeue,
- 	.endpoint_disable	= ohci_endpoint_disable,
- 
- 	/*
- 	 * scheduling support
- 	 */
- 	.get_frame_number	= ohci_get_frame,
- 
- 	/*
- 	 * root hub support
- 	 */
- 	.hub_status_data	= ohci_da8xx_hub_status_data,
- 	.hub_control		= ohci_da8xx_hub_control,
- 
- #ifdef	CONFIG_PM
- 	.bus_suspend		= ohci_bus_suspend,
- 	.bus_resume		= ohci_bus_resume,
- #endif
- 	.start_port_reset	= ohci_start_port_reset,
- };
- 
  /*-------------------------------------------------------------------------*/
  
- 
- /**
-  * usb_hcd_da8xx_probe - initialize DA8xx-based HCDs
-  * Context: !in_interrupt()
-  *
-  * Allocates basic resources for this USB host controller, and
-  * then invokes the start() method for the HCD associated with it
-  * through the hotplug entry's driver_data.
-  */
- static int usb_hcd_da8xx_probe(const struct hc_driver *driver,
- 			       struct platform_device *pdev)
+ static int ohci_da8xx_probe(struct platform_device *pdev)
  {
 -	struct da8xx_ohci_root_hub *hub	= dev_get_platdata(&pdev->dev);
 +	struct da8xx_ohci_root_hub *hub	= pdev->dev.platform_data;
  	struct usb_hcd	*hcd;
  	struct resource *mem;
  	int error, irq;
@@@ -300,53 -238,46 +274,64 @@@
  	if (hub == NULL)
  		return -ENODEV;
  
 -	usb11_clk = devm_clk_get(&pdev->dev, "usb11");
 -	if (IS_ERR(usb11_clk)) {
 -		if (PTR_ERR(usb11_clk) != -EPROBE_DEFER)
 -			dev_err(&pdev->dev, "Failed to get clock.\n");
 +	usb11_clk = clk_get(&pdev->dev, "usb11");
 +	if (IS_ERR(usb11_clk))
  		return PTR_ERR(usb11_clk);
 -	}
  
 -	usb11_phy = devm_phy_get(&pdev->dev, "usb-phy");
 -	if (IS_ERR(usb11_phy)) {
 -		if (PTR_ERR(usb11_phy) != -EPROBE_DEFER)
 -			dev_err(&pdev->dev, "Failed to get phy.\n");
 -		return PTR_ERR(usb11_phy);
 +	usb20_clk = clk_get(&pdev->dev, "usb20");
 +	if (IS_ERR(usb20_clk)) {
 +		error = PTR_ERR(usb20_clk);
 +		goto err0;
  	}
  
++<<<<<<< HEAD
 +	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
 +	if (!hcd) {
 +		error = -ENOMEM;
 +		goto err1;
 +	}
++=======
+ 	hcd = usb_create_hcd(&ohci_da8xx_hc_driver, &pdev->dev,
+ 				dev_name(&pdev->dev));
+ 	if (!hcd)
+ 		return -ENOMEM;
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  
  	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	hcd->regs = devm_ioremap_resource(&pdev->dev, mem);
 -	if (IS_ERR(hcd->regs)) {
 -		error = PTR_ERR(hcd->regs);
 -		dev_err(&pdev->dev, "failed to map ohci.\n");
 -		goto err;
 +	if (!mem) {
 +		error = -ENODEV;
 +		goto err2;
  	}
  	hcd->rsrc_start = mem->start;
  	hcd->rsrc_len = resource_size(mem);
  
++<<<<<<< HEAD
 +	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
 +		dev_dbg(&pdev->dev, "request_mem_region failed\n");
 +		error = -EBUSY;
 +		goto err2;
 +	}
 +
 +	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
 +	if (!hcd->regs) {
 +		dev_err(&pdev->dev, "ioremap failed\n");
 +		error = -ENOMEM;
 +		goto err3;
 +	}
 +
 +	ohci_hcd_init(hcd_to_ohci(hcd));
 +
++=======
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  	irq = platform_get_irq(pdev, 0);
  	if (irq < 0) {
  		error = -ENODEV;
 -		goto err;
 +		goto err4;
  	}
+ 
  	error = usb_add_hcd(hcd, irq, 0);
  	if (error)
 -		goto err;
 -
 -	device_wakeup_enable(hcd->self.controller);
 +		goto err4;
  
  	if (hub->ocic_notify) {
  		error = hub->ocic_notify(ohci_da8xx_ocic_handler);
@@@ -368,40 -291,14 +353,38 @@@ err0
  	return error;
  }
  
- /**
-  * usb_hcd_da8xx_remove - shutdown processing for DA8xx-based HCDs
-  * @dev: USB Host Controller being removed
-  * Context: !in_interrupt()
-  *
-  * Reverses the effect of usb_hcd_da8xx_probe(), first invoking
-  * the HCD's stop() method.  It is always called from a thread
-  * context, normally "rmmod", "apmd", or something similar.
-  */
- static inline void
- usb_hcd_da8xx_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+ static int ohci_da8xx_remove(struct platform_device *pdev)
  {
++<<<<<<< HEAD
 +	struct da8xx_ohci_root_hub *hub	= pdev->dev.platform_data;
++=======
+ 	struct usb_hcd	*hcd = platform_get_drvdata(pdev);
+ 	struct da8xx_ohci_root_hub *hub	= dev_get_platdata(&pdev->dev);
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  
  	hub->ocic_notify(NULL);
  	usb_remove_hcd(hcd);
 +	iounmap(hcd->regs);
 +	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
  	usb_put_hcd(hcd);
++<<<<<<< HEAD
 +	clk_put(usb20_clk);
 +	clk_put(usb11_clk);
 +}
 +
 +static int ohci_hcd_da8xx_drv_probe(struct platform_device *dev)
 +{
 +	return usb_hcd_da8xx_probe(&ohci_da8xx_hc_driver, dev);
 +}
 +
 +static int ohci_hcd_da8xx_drv_remove(struct platform_device *dev)
 +{
 +	struct usb_hcd	*hcd = platform_get_drvdata(dev);
 +
 +	usb_hcd_da8xx_remove(hcd, dev);
 +	platform_set_drvdata(dev, NULL);
++=======
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  
  	return 0;
  }
@@@ -450,8 -364,7 +437,12 @@@ static struct platform_driver ohci_hcd_
  	.resume		= ohci_da8xx_resume,
  #endif
  	.driver		= {
++<<<<<<< HEAD
 +		.owner	= THIS_MODULE,
 +		.name	= "ohci",
++=======
+ 		.name	= DRV_NAME,
++>>>>>>> 6c21caa333f9 (USB: OHCI: make ohci-da8xx a separate driver)
  	},
  };
  
* Unmerged path drivers/usb/host/Kconfig
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index c8df3ea57e04..f7d71ade4ab9 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -64,6 +64,7 @@ obj-$(CONFIG_USB_OHCI_HCD_AT91)	+= ohci-at91.o
 obj-$(CONFIG_USB_OHCI_HCD_S3C2410)	+= ohci-s3c2410.o
 obj-$(CONFIG_USB_OHCI_HCD_LPC32XX)	+= ohci-nxp.o
 obj-$(CONFIG_USB_OHCI_HCD_PXA27X)	+= ohci-pxa27x.o
+obj-$(CONFIG_USB_OHCI_HCD_DAVINCI)	+= ohci-da8xx.o
 
 obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
 obj-$(CONFIG_USB_FHCI_HCD)	+= fhci.o
* Unmerged path drivers/usb/host/ohci-da8xx.c
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index b01f69e223dc..6f39fbb0c0a9 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1220,11 +1220,6 @@ MODULE_LICENSE ("GPL");
 #define SA1111_DRIVER		ohci_hcd_sa1111_driver
 #endif
 
-#ifdef CONFIG_USB_OHCI_HCD_DAVINCI
-#include "ohci-da8xx.c"
-#define DAVINCI_PLATFORM_DRIVER	ohci_hcd_da8xx_driver
-#endif
-
 #ifdef CONFIG_USB_OHCI_HCD_PPC_OF
 #include "ohci-ppc-of.c"
 #define OF_PLATFORM_DRIVER	ohci_hcd_ppc_of_driver
@@ -1309,19 +1304,9 @@ static int __init ohci_hcd_mod_init(void)
 		goto error_tmio;
 #endif
 
-#ifdef DAVINCI_PLATFORM_DRIVER
-	retval = platform_driver_register(&DAVINCI_PLATFORM_DRIVER);
-	if (retval < 0)
-		goto error_davinci;
-#endif
-
 	return retval;
 
 	/* Error path */
-#ifdef DAVINCI_PLATFORM_DRIVER
-	platform_driver_unregister(&DAVINCI_PLATFORM_DRIVER);
- error_davinci:
-#endif
 #ifdef TMIO_OHCI_DRIVER
 	platform_driver_unregister(&TMIO_OHCI_DRIVER);
  error_tmio:
@@ -1357,9 +1342,6 @@ module_init(ohci_hcd_mod_init);
 
 static void __exit ohci_hcd_mod_exit(void)
 {
-#ifdef DAVINCI_PLATFORM_DRIVER
-	platform_driver_unregister(&DAVINCI_PLATFORM_DRIVER);
-#endif
 #ifdef TMIO_OHCI_DRIVER
 	platform_driver_unregister(&TMIO_OHCI_DRIVER);
 #endif
