selinux: don't revalidate an inode's label when explicitly setting it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Paul Moore <paul@paul-moore.com>
commit 2c97165befb487c0dc8b25d39f457d0d91d22a6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2c97165b.failed

There is no point in attempting to revalidate an inode's security
label when we are in the process of setting it.

	Reported-by: Stephen Smalley <sds@tycho.nsa.gov>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 2c97165befb487c0dc8b25d39f457d0d91d22a6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 85f0076df17e,f8ecc0a3c0fa..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -231,6 -242,79 +231,82 @@@ static int inode_alloc_security(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry);
+ 
+ /*
+  * Try reloading inode security labels that have been marked as invalid.  The
+  * @may_sleep parameter indicates when sleeping and thus reloading labels is
+  * allowed; when set to false, returns ERR_PTR(-ECHILD) when the label is
+  * invalid.  The @opt_dentry parameter should be set to a dentry of the inode;
+  * when no dentry is available, set it to NULL instead.
+  */
+ static int __inode_security_revalidate(struct inode *inode,
+ 				       struct dentry *opt_dentry,
+ 				       bool may_sleep)
+ {
+ 	struct inode_security_struct *isec = inode->i_security;
+ 
+ 	might_sleep_if(may_sleep);
+ 
+ 	if (isec->initialized != LABEL_INITIALIZED) {
+ 		if (!may_sleep)
+ 			return -ECHILD;
+ 
+ 		/*
+ 		 * Try reloading the inode security label.  This will fail if
+ 		 * @opt_dentry is NULL and no dentry for this inode can be
+ 		 * found; in that case, continue using the old label.
+ 		 */
+ 		inode_doinit_with_dentry(inode, opt_dentry);
+ 	}
+ 	return 0;
+ }
+ 
+ static struct inode_security_struct *inode_security_novalidate(struct inode *inode)
+ {
+ 	return inode->i_security;
+ }
+ 
+ static struct inode_security_struct *inode_security_rcu(struct inode *inode, bool rcu)
+ {
+ 	int error;
+ 
+ 	error = __inode_security_revalidate(inode, NULL, !rcu);
+ 	if (error)
+ 		return ERR_PTR(error);
+ 	return inode->i_security;
+ }
+ 
+ /*
+  * Get the security label of an inode.
+  */
+ static struct inode_security_struct *inode_security(struct inode *inode)
+ {
+ 	__inode_security_revalidate(inode, NULL, true);
+ 	return inode->i_security;
+ }
+ 
+ static struct inode_security_struct *backing_inode_security_novalidate(struct dentry *dentry)
+ {
+ 	struct inode *inode = d_backing_inode(dentry);
+ 
+ 	return inode->i_security;
+ }
+ 
+ /*
+  * Get the security label of a dentry's backing inode.
+  */
+ static struct inode_security_struct *backing_inode_security(struct dentry *dentry)
+ {
+ 	struct inode *inode = d_backing_inode(dentry);
+ 
+ 	__inode_security_revalidate(inode, dentry, true);
+ 	return inode->i_security;
+ }
+ 
++>>>>>>> 2c97165befb4 (selinux: don't revalidate an inode's label when explicitly setting it)
  static void inode_free_rcu(struct rcu_head *head)
  {
  	struct inode_security_struct *isec;
@@@ -586,8 -692,8 +662,13 @@@ static int selinux_set_mnt_opts(struct 
  	int rc = 0, i;
  	struct superblock_security_struct *sbsec = sb->s_security;
  	const char *name = sb->s_type->name;
++<<<<<<< HEAD
 +	struct inode *inode = sbsec->sb->s_root->d_inode;
 +	struct inode_security_struct *root_isec = inode->i_security;
++=======
+ 	struct dentry *root = sbsec->sb->s_root;
+ 	struct inode_security_struct *root_isec;
++>>>>>>> 2c97165befb4 (selinux: don't revalidate an inode's label when explicitly setting it)
  	u32 fscontext_sid = 0, context_sid = 0, rootcontext_sid = 0;
  	u32 defcontext_sid = 0;
  	char **mount_options = opts->mnt_opts;
@@@ -3074,7 -3231,7 +3157,11 @@@ out_nofree
  static int selinux_inode_setsecurity(struct inode *inode, const char *name,
  				     const void *value, size_t size, int flags)
  {
++<<<<<<< HEAD
 +	struct inode_security_struct *isec = inode->i_security;
++=======
+ 	struct inode_security_struct *isec = inode_security_novalidate(inode);
++>>>>>>> 2c97165befb4 (selinux: don't revalidate an inode's label when explicitly setting it)
  	u32 newsid;
  	int rc;
  
* Unmerged path security/selinux/hooks.c
