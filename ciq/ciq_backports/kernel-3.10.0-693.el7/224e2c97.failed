perf script: Support insn and insnlen

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andi Kleen <ak@linux.intel.com>
commit 224e2c977b647d1ae72bf1d8e3424cd3e5e83f0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/224e2c97.failed

When looking at Intel PT traces with perf script it is useful to have
some indication of the instruction. Dump the instruction bytes and
instruction length, which can be used for simple pattern analysis in
scripts.

% perf record -e intel_pt// foo
% perf script --itrace=i0ns -F ip,insn,insnlen
 ffffffff8101232f ilen: 5 insn: 0f 1f 44 00 00
 ffffffff81012334 ilen: 1 insn: 5b
 ffffffff81012335 ilen: 1 insn: 5d
 ffffffff81012336 ilen: 1 insn: c3
 ffffffff810123e3 ilen: 1 insn: 5b
 ffffffff810123e4 ilen: 2 insn: 41 5c
 ffffffff810123e6 ilen: 1 insn: 5d
 ffffffff810123e7 ilen: 1 insn: c3
 ffffffff810124a6 ilen: 2 insn: 31 c0
 ffffffff810124a8 ilen: 9 insn: 41 83 bc 24 a8 01 00 00 01
 ffffffff810124b1 ilen: 2 insn: 75 87
...

	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Acked-by: Adrian Hunter <adrian.hunter@intel.com>
Link: http://lkml.kernel.org/r/1475847747-30994-4-git-send-email-adrian.hunter@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 224e2c977b647d1ae72bf1d8e3424cd3e5e83f0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-script.txt
#	tools/perf/builtin-script.c
diff --cc tools/perf/Documentation/perf-script.txt
index a46030d8962d,c01904f388ce..000000000000
--- a/tools/perf/Documentation/perf-script.txt
+++ b/tools/perf/Documentation/perf-script.txt
@@@ -116,8 -116,8 +116,13 @@@ OPTION
  --fields::
          Comma separated list of fields to print. Options are:
          comm, tid, pid, time, cpu, event, trace, ip, sym, dso, addr, symoff,
++<<<<<<< HEAD
 +	srcline, period, iregs, brstack, brstacksym, flags.
 +        Field list can be prepended with the type, trace, sw or hw,
++=======
+         srcline, period, iregs, brstack, brstacksym, flags, bpf-output,
+         callindent, insn, insnlen. Field list can be prepended with the type, trace, sw or hw,
++>>>>>>> 224e2c977b64 (perf script: Support insn and insnlen)
          to indicate to which event type the field list applies.
          e.g., -F sw:comm,tid,time,ip,sym  and -F trace:time,cpu,trace
  
@@@ -177,6 -177,14 +182,17 @@@
  	"tr end" for "bE". However the "x" flag will be display separately in those
  	cases e.g. "jcc     (x)" for a condition branch within a transaction.
  
++<<<<<<< HEAD
++=======
+ 	The callindent field is synthesized and may have a value when
+ 	Instruction Trace decoding. For calls and returns, it will display the
+ 	name of the symbol indented with spaces to reflect the stack depth.
+ 
+ 	When doing instruction trace decoding insn and insnlen give the
+ 	instruction bytes and the instruction length of the current
+ 	instruction.
+ 
++>>>>>>> 224e2c977b64 (perf script: Support insn and insnlen)
  	Finally, a user may not set fields to none for all event types.
  	i.e., -F "" is not allowed.
  
diff --cc tools/perf/builtin-script.c
index 877b738767ba,412fb6e65ac0..000000000000
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@@ -62,6 -64,10 +62,13 @@@ enum perf_output_field 
  	PERF_OUTPUT_BRSTACKSYM	    = 1U << 16,
  	PERF_OUTPUT_DATA_SRC	    = 1U << 17,
  	PERF_OUTPUT_WEIGHT	    = 1U << 18,
++<<<<<<< HEAD
++=======
+ 	PERF_OUTPUT_BPF_OUTPUT	    = 1U << 19,
+ 	PERF_OUTPUT_CALLINDENT	    = 1U << 20,
+ 	PERF_OUTPUT_INSN	    = 1U << 21,
+ 	PERF_OUTPUT_INSNLEN	    = 1U << 22,
++>>>>>>> 224e2c977b64 (perf script: Support insn and insnlen)
  };
  
  struct output_option {
@@@ -87,6 -93,10 +94,13 @@@
  	{.str = "brstacksym", .field = PERF_OUTPUT_BRSTACKSYM},
  	{.str = "data_src", .field = PERF_OUTPUT_DATA_SRC},
  	{.str = "weight",   .field = PERF_OUTPUT_WEIGHT},
++<<<<<<< HEAD
++=======
+ 	{.str = "bpf-output",   .field = PERF_OUTPUT_BPF_OUTPUT},
+ 	{.str = "callindent", .field = PERF_OUTPUT_CALLINDENT},
+ 	{.str = "insn", .field = PERF_OUTPUT_INSN},
+ 	{.str = "insnlen", .field = PERF_OUTPUT_INSNLEN},
++>>>>>>> 224e2c977b64 (perf script: Support insn and insnlen)
  };
  
  /* default set to maintain compatibility with current format */
@@@ -560,6 -572,76 +574,79 @@@ static void print_sample_addr(struct pe
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void print_sample_callindent(struct perf_sample *sample,
+ 				    struct perf_evsel *evsel,
+ 				    struct thread *thread,
+ 				    struct addr_location *al)
+ {
+ 	struct perf_event_attr *attr = &evsel->attr;
+ 	size_t depth = thread_stack__depth(thread);
+ 	struct addr_location addr_al;
+ 	const char *name = NULL;
+ 	static int spacing;
+ 	int len = 0;
+ 	u64 ip = 0;
+ 
+ 	/*
+ 	 * The 'return' has already been popped off the stack so the depth has
+ 	 * to be adjusted to match the 'call'.
+ 	 */
+ 	if (thread->ts && sample->flags & PERF_IP_FLAG_RETURN)
+ 		depth += 1;
+ 
+ 	if (sample->flags & (PERF_IP_FLAG_CALL | PERF_IP_FLAG_TRACE_BEGIN)) {
+ 		if (sample_addr_correlates_sym(attr)) {
+ 			thread__resolve(thread, &addr_al, sample);
+ 			if (addr_al.sym)
+ 				name = addr_al.sym->name;
+ 			else
+ 				ip = sample->addr;
+ 		} else {
+ 			ip = sample->addr;
+ 		}
+ 	} else if (sample->flags & (PERF_IP_FLAG_RETURN | PERF_IP_FLAG_TRACE_END)) {
+ 		if (al->sym)
+ 			name = al->sym->name;
+ 		else
+ 			ip = sample->ip;
+ 	}
+ 
+ 	if (name)
+ 		len = printf("%*s%s", (int)depth * 4, "", name);
+ 	else if (ip)
+ 		len = printf("%*s%16" PRIx64, (int)depth * 4, "", ip);
+ 
+ 	if (len < 0)
+ 		return;
+ 
+ 	/*
+ 	 * Try to keep the output length from changing frequently so that the
+ 	 * output lines up more nicely.
+ 	 */
+ 	if (len > spacing || (len && len < spacing - 52))
+ 		spacing = round_up(len + 4, 32);
+ 
+ 	if (len < spacing)
+ 		printf("%*s", spacing - len, "");
+ }
+ 
+ static void print_insn(struct perf_sample *sample,
+ 		       struct perf_event_attr *attr)
+ {
+ 	if (PRINT_FIELD(INSNLEN))
+ 		printf(" ilen: %d", sample->insn_len);
+ 	if (PRINT_FIELD(INSN)) {
+ 		int i;
+ 
+ 		printf(" insn:");
+ 		for (i = 0; i < sample->insn_len; i++)
+ 			printf(" %02x", (unsigned char)sample->insn[i]);
+ 	}
+ }
+ 
++>>>>>>> 224e2c977b64 (perf script: Support insn and insnlen)
  static void print_sample_bts(struct perf_sample *sample,
  			     struct perf_evsel *evsel,
  			     struct thread *thread,
@@@ -758,6 -929,9 +847,12 @@@ static void process_event(struct perf_s
  	else if (PRINT_FIELD(BRSTACKSYM))
  		print_sample_brstacksym(sample, thread);
  
++<<<<<<< HEAD
++=======
+ 	if (perf_evsel__is_bpf_output(evsel) && PRINT_FIELD(BPF_OUTPUT))
+ 		print_sample_bpf_output(sample);
+ 	print_insn(sample, attr);
++>>>>>>> 224e2c977b64 (perf script: Support insn and insnlen)
  	printf("\n");
  }
  
@@@ -1969,7 -2143,8 +2064,12 @@@ int cmd_script(int argc, const char **a
  		     "comma separated output fields prepend with 'type:'. "
  		     "Valid types: hw,sw,trace,raw. "
  		     "Fields: comm,tid,pid,time,cpu,event,trace,ip,sym,dso,"
++<<<<<<< HEAD
 +		     "addr,symoff,period,iregs,brstack,brstacksym,flags", parse_output_fields),
++=======
+ 		     "addr,symoff,period,iregs,brstack,brstacksym,flags,"
+ 		     "bpf-output,callindent,insn,insnlen", parse_output_fields),
++>>>>>>> 224e2c977b64 (perf script: Support insn and insnlen)
  	OPT_BOOLEAN('a', "all-cpus", &system_wide,
  		    "system-wide collection from all CPUs"),
  	OPT_STRING('S', "symbols", &symbol_conf.sym_list_str, "symbol[,symbol...]",
* Unmerged path tools/perf/Documentation/perf-script.txt
* Unmerged path tools/perf/builtin-script.c
