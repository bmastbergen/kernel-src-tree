Move locks API users to locks_lock_inode_wait()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Benjamin Coddington <bcodding@redhat.com>
commit 4f6563677ae833baad8003e14353241bc25da4fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4f656367.failed

Instead of having users check for FL_POSIX or FL_FLOCK to call the correct
locks API function, use the check within locks_lock_inode_wait().  This
allows for some later cleanup.

	Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
(cherry picked from commit 4f6563677ae833baad8003e14353241bc25da4fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/lustre/lustre/llite/file.c
#	fs/gfs2/file.c
#	fs/ocfs2/locks.c
diff --cc fs/gfs2/file.c
index af0d418da809,9287a2d17b8c..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -1120,8 -1071,8 +1120,13 @@@ static void do_unflock(struct file *fil
  	struct gfs2_holder *fl_gh = &fp->f_fl_gh;
  
  	mutex_lock(&fp->f_fl_mutex);
++<<<<<<< HEAD
 +	flock_lock_file_wait(file, fl);
 +	if (gfs2_holder_initialized(fl_gh)) {
++=======
+ 	locks_lock_file_wait(file, fl);
+ 	if (fl_gh->gh_gl) {
++>>>>>>> 4f6563677ae8 (Move locks API users to locks_lock_inode_wait())
  		gfs2_glock_dq(fl_gh);
  		gfs2_holder_uninit(fl_gh);
  	}
diff --cc fs/ocfs2/locks.c
index e57c804069ea,652ece4a9d9e..000000000000
--- a/fs/ocfs2/locks.c
+++ b/fs/ocfs2/locks.c
@@@ -81,7 -81,9 +81,13 @@@ static int ocfs2_do_flock(struct file *
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	ret = flock_lock_file_wait(file, fl);
++=======
+ 	ret = locks_lock_file_wait(file, fl);
+ 	if (ret)
+ 		ocfs2_file_unlock(file);
++>>>>>>> 4f6563677ae8 (Move locks API users to locks_lock_inode_wait())
  
  out:
  	mutex_unlock(&fp->fp_mutex);
* Unmerged path drivers/staging/lustre/lustre/llite/file.c
* Unmerged path drivers/staging/lustre/lustre/llite/file.c
diff --git a/fs/9p/vfs_file.c b/fs/9p/vfs_file.c
index d384a8b77ee8..7b7aeb5266c7 100644
--- a/fs/9p/vfs_file.c
+++ b/fs/9p/vfs_file.c
@@ -159,7 +159,7 @@ static int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)
 	if ((fl->fl_flags & FL_POSIX) != FL_POSIX)
 		BUG();
 
-	res = posix_lock_file_wait(filp, fl);
+	res = locks_lock_file_wait(filp, fl);
 	if (res < 0)
 		goto out;
 
@@ -227,7 +227,7 @@ static int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)
 	if (res < 0 && fl->fl_type != F_UNLCK) {
 		fl_type = fl->fl_type;
 		fl->fl_type = F_UNLCK;
-		res = posix_lock_file_wait(filp, fl);
+		res = locks_lock_file_wait(filp, fl);
 		fl->fl_type = fl_type;
 	}
 out:
diff --git a/fs/ceph/locks.c b/fs/ceph/locks.c
index 6bb1fbfbcb04..e3d082d9c261 100644
--- a/fs/ceph/locks.c
+++ b/fs/ceph/locks.c
@@ -231,12 +231,12 @@ int ceph_flock(struct file *file, int cmd, struct file_lock *fl)
 	err = ceph_lock_message(CEPH_LOCK_FLOCK, CEPH_MDS_OP_SETFILELOCK,
 				file, lock_cmd, wait, fl);
 	if (!err) {
-		err = flock_lock_file_wait(file, fl);
+		err = locks_lock_file_wait(file, fl);
 		if (err) {
 			ceph_lock_message(CEPH_LOCK_FLOCK,
 					  CEPH_MDS_OP_SETFILELOCK,
 					  file, CEPH_LOCK_UNLOCK, 0, fl);
-			dout("got %d on flock_lock_file_wait, undid lock", err);
+			dout("got %d on locks_lock_file_wait, undid lock", err);
 		}
 	}
 	return err;
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index 99620b9ffbac..fab9496dd94f 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -1604,7 +1604,7 @@ cifs_setlk(struct file *file, struct file_lock *flock, __u32 type,
 
 out:
 	if (flock->fl_flags & FL_POSIX && !rc)
-		rc = posix_lock_file_wait(file, flock);
+		rc = locks_lock_file_wait(file, flock);
 	return rc;
 }
 
diff --git a/fs/dlm/plock.c b/fs/dlm/plock.c
index f704458ea5f5..aa8c68edd236 100644
--- a/fs/dlm/plock.c
+++ b/fs/dlm/plock.c
@@ -172,7 +172,7 @@ int dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,
 	rv = op->info.rv;
 
 	if (!rv) {
-		if (posix_lock_file_wait(file, fl) < 0)
+		if (locks_lock_file_wait(file, fl) < 0)
 			log_error(ls, "dlm_posix_lock: vfs lock error %llx",
 				  (unsigned long long)number);
 	}
@@ -262,7 +262,7 @@ int dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,
 	/* cause the vfs unlock to return ENOENT if lock is not found */
 	fl->fl_flags |= FL_EXISTS;
 
-	rv = posix_lock_file_wait(file, fl);
+	rv = locks_lock_file_wait(file, fl);
 	if (rv == -ENOENT) {
 		rv = 0;
 		goto out_free;
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index ed212b08f7f8..5f2f05da41bf 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -1788,7 +1788,7 @@ static int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)
 	int err;
 
 	if (fc->no_flock) {
-		err = flock_lock_file_wait(file, fl);
+		err = locks_lock_file_wait(file, fl);
 	} else {
 		struct fuse_file *ff = file->private_data;
 
* Unmerged path fs/gfs2/file.c
diff --git a/fs/lockd/clntproc.c b/fs/lockd/clntproc.c
index acd394716349..112952037933 100644
--- a/fs/lockd/clntproc.c
+++ b/fs/lockd/clntproc.c
@@ -474,18 +474,7 @@ static void nlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *ho
 
 static int do_vfs_lock(struct file_lock *fl)
 {
-	int res = 0;
-	switch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {
-		case FL_POSIX:
-			res = posix_lock_file_wait(fl->fl_file, fl);
-			break;
-		case FL_FLOCK:
-			res = flock_lock_file_wait(fl->fl_file, fl);
-			break;
-		default:
-			BUG();
-	}
-	return res;
+	return locks_lock_file_wait(fl->fl_file, fl);
 }
 
 /*
diff --git a/fs/locks.c b/fs/locks.c
index 907930d95be4..b440579df743 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1895,7 +1895,7 @@ SYSCALL_DEFINE2(flock, unsigned int, fd, unsigned int, cmd)
 					  (can_sleep) ? F_SETLKW : F_SETLK,
 					  lock);
 	else
-		error = flock_lock_file_wait(f.file, lock);
+		error = locks_lock_file_wait(f.file, lock);
 
  out_free:
 	locks_free_lock(lock);
diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index c497ac465f2a..80c8894f397f 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -767,18 +767,7 @@ out_noconflict:
 
 static int do_vfs_lock(struct file *file, struct file_lock *fl)
 {
-	int res = 0;
-	switch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {
-		case FL_POSIX:
-			res = posix_lock_file_wait(file, fl);
-			break;
-		case FL_FLOCK:
-			res = flock_lock_file_wait(file, fl);
-			break;
-		default:
-			BUG();
-	}
-	return res;
+	return locks_lock_file_wait(file, fl);
 }
 
 static int
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 2f4df4d62ee1..a6e314853735 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -5692,18 +5692,7 @@ static int nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *
 
 static int do_vfs_lock(struct inode *inode, struct file_lock *fl)
 {
-	int res = 0;
-	switch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {
-		case FL_POSIX:
-			res = posix_lock_inode_wait(inode, fl);
-			break;
-		case FL_FLOCK:
-			res = flock_lock_inode_wait(inode, fl);
-			break;
-		default:
-			BUG();
-	}
-	return res;
+	return locks_lock_inode_wait(inode, fl);
 }
 
 struct nfs4_unlockdata {
* Unmerged path fs/ocfs2/locks.c
