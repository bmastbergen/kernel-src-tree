tracing: Have max_latency be defined for HWLAT_TRACER as well

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Steven Rostedt (Red Hat) <rostedt@goodmis.org>
commit f971cc9aabc287120bbe7f3f1abe70c13e61ee94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f971cc9a.failed

The hwlat tracer uses tr->max_latency, and if it's the only tracer enabled
that uses it, the build will fail. Add max_latency and its file when the
hwlat tracer is enabled.

Link: http://lkml.kernel.org/r/d6c3b7eb-ba95-1ffa-0453-464e1e24262a@infradead.org

	Reported-by: Randy Dunlap <rdunlap@infradead.org>
	Tested-by: Randy Dunlap <rdunlap@infradead.org>
	Acked-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit f971cc9aabc287120bbe7f3f1abe70c13e61ee94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace.c
#	kernel/trace/trace.h
diff --cc kernel/trace/trace.c
index d31b92ef362d,e0d0cfc1aa20..000000000000
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@@ -4084,6 -4913,56 +4084,59 @@@ tracing_max_lat_write(struct file *filp
  	return cnt;
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t
+ tracing_thresh_read(struct file *filp, char __user *ubuf,
+ 		    size_t cnt, loff_t *ppos)
+ {
+ 	return tracing_nsecs_read(&tracing_thresh, ubuf, cnt, ppos);
+ }
+ 
+ static ssize_t
+ tracing_thresh_write(struct file *filp, const char __user *ubuf,
+ 		     size_t cnt, loff_t *ppos)
+ {
+ 	struct trace_array *tr = filp->private_data;
+ 	int ret;
+ 
+ 	mutex_lock(&trace_types_lock);
+ 	ret = tracing_nsecs_write(&tracing_thresh, ubuf, cnt, ppos);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	if (tr->current_trace->update_thresh) {
+ 		ret = tr->current_trace->update_thresh(tr);
+ 		if (ret < 0)
+ 			goto out;
+ 	}
+ 
+ 	ret = cnt;
+ out:
+ 	mutex_unlock(&trace_types_lock);
+ 
+ 	return ret;
+ }
+ 
+ #if defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)
+ 
+ static ssize_t
+ tracing_max_lat_read(struct file *filp, char __user *ubuf,
+ 		     size_t cnt, loff_t *ppos)
+ {
+ 	return tracing_nsecs_read(filp->private_data, ubuf, cnt, ppos);
+ }
+ 
+ static ssize_t
+ tracing_max_lat_write(struct file *filp, const char __user *ubuf,
+ 		      size_t cnt, loff_t *ppos)
+ {
+ 	return tracing_nsecs_write(filp->private_data, ubuf, cnt, ppos);
+ }
+ 
+ #endif
+ 
++>>>>>>> f971cc9aabc2 (tracing: Have max_latency be defined for HWLAT_TRACER as well)
  static int tracing_open_pipe(struct inode *inode, struct file *filp)
  {
  	struct trace_array *tr = inode->i_private;
@@@ -5002,6 -5860,14 +5055,17 @@@ static int snapshot_raw_open(struct ino
  #endif /* CONFIG_TRACER_SNAPSHOT */
  
  
++<<<<<<< HEAD
++=======
+ static const struct file_operations tracing_thresh_fops = {
+ 	.open		= tracing_open_generic,
+ 	.read		= tracing_thresh_read,
+ 	.write		= tracing_thresh_write,
+ 	.llseek		= generic_file_llseek,
+ };
+ 
+ #if defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)
++>>>>>>> f971cc9aabc2 (tracing: Have max_latency be defined for HWLAT_TRACER as well)
  static const struct file_operations tracing_max_lat_fops = {
  	.open		= tracing_open_generic,
  	.read		= tracing_max_lat_read,
@@@ -6314,6 -7193,16 +6378,19 @@@ init_tracer_debugfs(struct trace_array 
  	trace_create_file("tracing_on", 0644, d_tracer,
  			  tr, &rb_simple_fops);
  
++<<<<<<< HEAD
++=======
+ 	create_trace_options_dir(tr);
+ 
+ #if defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)
+ 	trace_create_file("tracing_max_latency", 0644, d_tracer,
+ 			&tr->max_latency, &tracing_max_lat_fops);
+ #endif
+ 
+ 	if (ftrace_create_function_files(tr, d_tracer))
+ 		WARN(1, "Could not allocate function filter files");
+ 
++>>>>>>> f971cc9aabc2 (tracing: Have max_latency be defined for HWLAT_TRACER as well)
  #ifdef CONFIG_TRACER_SNAPSHOT
  	trace_create_file("snapshot", 0644, d_tracer,
  			  tr, &snapshot_fops);
diff --cc kernel/trace/trace.h
index 6be1e47b4081,fd24b1f9ac43..000000000000
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@@ -194,9 -214,26 +194,15 @@@ struct trace_array 
  	 */
  	struct trace_buffer	max_buffer;
  	bool			allocated_snapshot;
++<<<<<<< HEAD
++=======
+ #endif
+ #if defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)
+ 	unsigned long		max_latency;
++>>>>>>> f971cc9aabc2 (tracing: Have max_latency be defined for HWLAT_TRACER as well)
  #endif
 -	struct trace_pid_list	__rcu *filtered_pids;
 -	/*
 -	 * max_lock is used to protect the swapping of buffers
 -	 * when taking a max snapshot. The buffers themselves are
 -	 * protected by per_cpu spinlocks. But the action of the swap
 -	 * needs its own lock.
 -	 *
 -	 * This is defined as a arch_spinlock_t in order to help
 -	 * with performance when lockdep debugging is enabled.
 -	 *
 -	 * It is also used in other places outside the update_max_tr
 -	 * so it needs to be defined outside of the
 -	 * CONFIG_TRACER_MAX_TRACE.
 -	 */
 -	arch_spinlock_t		max_lock;
  	int			buffer_disabled;
 +	struct trace_cpu	trace_cpu;	/* place holder */
  #ifdef CONFIG_FTRACE_SYSCALLS
  	int			sys_refcount_enter;
  	int			sys_refcount_exit;
* Unmerged path kernel/trace/trace.c
* Unmerged path kernel/trace/trace.h
