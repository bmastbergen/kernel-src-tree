bridge: Support 802.1ad vlan filtering

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit 204177f3f30c2dbd2db0aa62b5e9cf9029786450
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/204177f3.failed

This enables us to change the vlan protocol for vlan filtering.
We come to be able to filter frames on the basis of 802.1ad vlan tags
through a bridge.

This also changes br->group_addr if it has not been set by user.
This is needed for an 802.1ad bridge.
(See IEEE 802.1Q-2011 8.13.5.)

Furthermore, this sets br->group_fwd_mask_required so that an 802.1ad
bridge can forward the Nearest Customer Bridge group addresses except
for br->group_addr, which should be passed to higher layer.

To change the vlan protocol, write a protocol in sysfs:
# echo 0x88a8 > /sys/class/net/br0/bridge/vlan_protocol

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 204177f3f30c2dbd2db0aa62b5e9cf9029786450)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private.h
#	net/bridge/br_sysfs_br.c
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_private.h
index 5a2c9ac93713,23caf5b0309e..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -601,9 -598,10 +602,15 @@@ int br_vlan_add(struct net_bridge *br, 
  int br_vlan_delete(struct net_bridge *br, u16 vid);
  void br_vlan_flush(struct net_bridge *br);
  bool br_vlan_find(struct net_bridge *br, u16 vid);
+ void br_recalculate_fwd_mask(struct net_bridge *br);
  int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
++<<<<<<< HEAD
 +int br_vlan_init(struct net_bridge *br);
 +int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
++=======
+ int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
+ void br_vlan_init(struct net_bridge *br);
++>>>>>>> 204177f3f30c (bridge: Support 802.1ad vlan filtering)
  int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
  int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
  void nbp_vlan_flush(struct net_bridge_port *port);
@@@ -700,9 -697,12 +707,17 @@@ static inline bool br_vlan_find(struct 
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline int br_vlan_init(struct net_bridge *br)
++=======
+ static inline void br_recalculate_fwd_mask(struct net_bridge *br)
+ {
+ }
+ 
+ static inline void br_vlan_init(struct net_bridge *br)
++>>>>>>> 204177f3f30c (bridge: Support 802.1ad vlan filtering)
  {
 +	return 0;
  }
  
  static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)
diff --cc net/bridge/br_sysfs_br.c
index a3eb35988a8a,c9e2572b15f4..000000000000
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@@ -731,24 -708,23 +740,44 @@@ static ssize_t store_vlan_filtering(str
  {
  	return store_bridge_parm(d, buf, len, br_vlan_filter_toggle);
  }
++<<<<<<< HEAD
 +static DEVICE_ATTR(vlan_filtering, S_IRUGO | S_IWUSR,
 +		   show_vlan_filtering, store_vlan_filtering);
 +
 +static ssize_t default_pvid_show(struct device *d,
 +				 struct device_attribute *attr,
 +				 char *buf)
 +{
 +	struct net_bridge *br = to_bridge(d);
 +	return sprintf(buf, "%d\n", br->default_pvid);
 +}
 +
 +static ssize_t default_pvid_store(struct device *d,
 +				  struct device_attribute *attr,
 +				  const char *buf, size_t len)
 +{
 +	return store_bridge_parm(d, buf, len, br_vlan_set_default_pvid);
 +}
 +static DEVICE_ATTR_RW(default_pvid);
++=======
+ static DEVICE_ATTR_RW(vlan_filtering);
+ 
+ static ssize_t vlan_protocol_show(struct device *d,
+ 				  struct device_attribute *attr,
+ 				  char *buf)
+ {
+ 	struct net_bridge *br = to_bridge(d);
+ 	return sprintf(buf, "%#06x\n", ntohs(br->vlan_proto));
+ }
+ 
+ static ssize_t vlan_protocol_store(struct device *d,
+ 				   struct device_attribute *attr,
+ 				   const char *buf, size_t len)
+ {
+ 	return store_bridge_parm(d, buf, len, br_vlan_set_proto);
+ }
+ static DEVICE_ATTR_RW(vlan_protocol);
++>>>>>>> 204177f3f30c (bridge: Support 802.1ad vlan filtering)
  #endif
  
  static struct attribute *bridge_attrs[] = {
@@@ -794,7 -770,7 +823,11 @@@
  #endif
  #ifdef CONFIG_BRIDGE_VLAN_FILTERING
  	&dev_attr_vlan_filtering.attr,
++<<<<<<< HEAD
 +	&dev_attr_default_pvid.attr,
++=======
+ 	&dev_attr_vlan_protocol.attr,
++>>>>>>> 204177f3f30c (bridge: Support 802.1ad vlan filtering)
  #endif
  	NULL
  };
diff --cc net/bridge/br_vlan.c
index a0e88a3656e6,2b2774fe0703..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -382,70 -378,31 +382,98 @@@ out
  	return found;
  }
  
++<<<<<<< HEAD
 +static void br_set_hw_filters(struct net_bridge *br)
 +{
 +	struct net_bridge_port *p;
 +	struct net_port_vlans *pv;
 +	u16 vid, errvid;
 +	int err;
 +
 +	/* For each port, walk the vlan bitmap and write the vlan
 +	 * info to port driver.
 +	 */
 +	list_for_each_entry(p, &br->port_list, list) {
 +		pv = rtnl_dereference(p->vlan_info);
 +		if (!pv)
 +			continue;
 +
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
 +			err = vlan_vid_add(p->dev, br->vlan_proto, vid);
 +			if (err)
 +				goto err_flt;
 +		}
 +	}
 +
 +	return;
 +
 +err_flt:
 +	errvid = vid;
 +	for_each_set_bit(vid, pv->vlan_bitmap, errvid)
 +		vlan_vid_del(p->dev, br->vlan_proto, vid);
 +
 +	list_for_each_entry_continue_reverse(p, &br->port_list, list) {
 +		pv = rtnl_dereference(p->vlan_info);
 +		if (!pv)
 +			continue;
 +
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
 +			vlan_vid_del(p->dev, br->vlan_proto, vid);
 +	}
 +}
 +
 +static void br_clear_hw_filters(struct net_bridge *br)
 +{
 +	struct net_bridge_port *p;
 +	struct net_port_vlans *pv;
 +	u16 vid;
 +
 +	/* For each port, walk the vlan bitmap and clear
 +	 * the vlan info from the port driver.
 +	 */
 +	list_for_each_entry(p, &br->port_list, list) {
 +		pv = rtnl_dereference(p->vlan_info);
 +		if (!pv)
 +			continue;
 +
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
 +			vlan_vid_del(p->dev, br->vlan_proto, vid);
 +	}
 +}
 +
 +static void br_manage_vlans(struct net_bridge *br)
 +{
 +	if (br->vlan_enabled)
 +		br_set_hw_filters(br);
 +	else
 +		br_clear_hw_filters(br);
++=======
+ /* Must be protected by RTNL. */
+ static void recalculate_group_addr(struct net_bridge *br)
+ {
+ 	if (br->group_addr_set)
+ 		return;
+ 
+ 	spin_lock_bh(&br->lock);
+ 	if (!br->vlan_enabled || br->vlan_proto == htons(ETH_P_8021Q)) {
+ 		/* Bridge Group Address */
+ 		br->group_addr[5] = 0x00;
+ 	} else { /* vlan_enabled && ETH_P_8021AD */
+ 		/* Provider Bridge Group Address */
+ 		br->group_addr[5] = 0x08;
+ 	}
+ 	spin_unlock_bh(&br->lock);
+ }
+ 
+ /* Must be protected by RTNL. */
+ void br_recalculate_fwd_mask(struct net_bridge *br)
+ {
+ 	if (!br->vlan_enabled || br->vlan_proto == htons(ETH_P_8021Q))
+ 		br->group_fwd_mask_required = BR_GROUPFWD_DEFAULT;
+ 	else /* vlan_enabled && ETH_P_8021AD */
+ 		br->group_fwd_mask_required = BR_GROUPFWD_8021AD &
+ 					      ~(1u << br->group_addr[5]);
++>>>>>>> 204177f3f30c (bridge: Support 802.1ad vlan filtering)
  }
  
  int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)
@@@ -457,149 -414,86 +485,221 @@@
  		goto unlock;
  
  	br->vlan_enabled = val;
 +	br_manage_vlans(br);
  	br_manage_promisc(br);
+ 	recalculate_group_addr(br);
+ 	br_recalculate_fwd_mask(br);
  
  unlock:
  	rtnl_unlock();
  	return 0;
  }
  
++<<<<<<< HEAD
 +static bool vlan_default_pvid(struct net_port_vlans *pv, u16 vid)
 +{
 +	return pv && vid == pv->pvid && test_bit(vid, pv->untagged_bitmap);
 +}
 +
 +static void br_vlan_disable_default_pvid(struct net_bridge *br)
 +{
 +	struct net_bridge_port *p;
 +	u16 pvid = br->default_pvid;
 +
 +	/* Disable default_pvid on all ports where it is still
 +	 * configured.
 +	 */
 +	if (vlan_default_pvid(br_get_vlan_info(br), pvid))
 +		br_vlan_delete(br, pvid);
 +
 +	list_for_each_entry(p, &br->port_list, list) {
 +		if (vlan_default_pvid(nbp_get_vlan_info(p), pvid))
 +			nbp_vlan_delete(p, pvid);
 +	}
 +
 +	br->default_pvid = 0;
 +}
 +
 +static int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid)
 +{
 +	struct net_bridge_port *p;
 +	u16 old_pvid;
 +	int err = 0;
 +	unsigned long *changed;
 +
 +	changed = kcalloc(BITS_TO_LONGS(BR_MAX_PORTS), sizeof(unsigned long),
 +			  GFP_KERNEL);
 +	if (!changed)
 +		return -ENOMEM;
 +
 +	old_pvid = br->default_pvid;
 +
 +	/* Update default_pvid config only if we do not conflict with
 +	 * user configuration.
 +	 */
 +	if ((!old_pvid || vlan_default_pvid(br_get_vlan_info(br), old_pvid)) &&
 +	    !br_vlan_find(br, pvid)) {
 +		err = br_vlan_add(br, pvid,
 +				  BRIDGE_VLAN_INFO_PVID |
 +				  BRIDGE_VLAN_INFO_UNTAGGED);
 +		if (err)
 +			goto out;
 +		br_vlan_delete(br, old_pvid);
 +		set_bit(0, changed);
 +	}
 +
 +	list_for_each_entry(p, &br->port_list, list) {
 +		/* Update default_pvid config only if we do not conflict with
 +		 * user configuration.
 +		 */
 +		if ((old_pvid &&
 +		     !vlan_default_pvid(nbp_get_vlan_info(p), old_pvid)) ||
 +		    nbp_vlan_find(p, pvid))
 +			continue;
 +
 +		err = nbp_vlan_add(p, pvid,
 +				   BRIDGE_VLAN_INFO_PVID |
 +				   BRIDGE_VLAN_INFO_UNTAGGED);
 +		if (err)
 +			goto err_port;
 +		nbp_vlan_delete(p, old_pvid);
 +		set_bit(p->port_no, changed);
 +	}
 +
 +	br->default_pvid = pvid;
 +
 +out:
 +	kfree(changed);
 +	return err;
 +
 +err_port:
 +	list_for_each_entry_continue_reverse(p, &br->port_list, list) {
 +		if (!test_bit(p->port_no, changed))
 +			continue;
 +
 +		if (old_pvid)
 +			nbp_vlan_add(p, old_pvid,
 +				     BRIDGE_VLAN_INFO_PVID |
 +				     BRIDGE_VLAN_INFO_UNTAGGED);
 +		nbp_vlan_delete(p, pvid);
 +	}
 +
 +	if (test_bit(0, changed)) {
 +		if (old_pvid)
 +			br_vlan_add(br, old_pvid,
 +				    BRIDGE_VLAN_INFO_PVID |
 +				    BRIDGE_VLAN_INFO_UNTAGGED);
 +		br_vlan_delete(br, pvid);
 +	}
 +	goto out;
 +}
 +
 +int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val)
 +{
 +	u16 pvid = val;
 +	int err = 0;
 +
 +	if (val >= VLAN_VID_MASK)
 +		return -EINVAL;
++=======
+ int br_vlan_set_proto(struct net_bridge *br, unsigned long val)
+ {
+ 	int err = 0;
+ 	struct net_bridge_port *p;
+ 	struct net_port_vlans *pv;
+ 	__be16 proto, oldproto;
+ 	u16 vid, errvid;
+ 
+ 	if (val != ETH_P_8021Q && val != ETH_P_8021AD)
+ 		return -EPROTONOSUPPORT;
++>>>>>>> 204177f3f30c (bridge: Support 802.1ad vlan filtering)
  
  	if (!rtnl_trylock())
  		return restart_syscall();
  
++<<<<<<< HEAD
 +	if (pvid == br->default_pvid)
 +		goto unlock;
 +
 +	/* Only allow default pvid change when filtering is disabled */
 +	if (br->vlan_enabled) {
 +		pr_info_once("Please disable vlan filtering to change default_pvid\n");
 +		err = -EPERM;
 +		goto unlock;
 +	}
 +
 +	if (!pvid)
 +		br_vlan_disable_default_pvid(br);
 +	else
 +		err = __br_vlan_set_default_pvid(br, pvid);
++=======
+ 	proto = htons(val);
+ 	if (br->vlan_proto == proto)
+ 		goto unlock;
+ 
+ 	/* Add VLANs for the new proto to the device filter. */
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
+ 			err = vlan_vid_add(p->dev, proto, vid);
+ 			if (err)
+ 				goto err_filt;
+ 		}
+ 	}
+ 
+ 	oldproto = br->vlan_proto;
+ 	br->vlan_proto = proto;
+ 
+ 	recalculate_group_addr(br);
+ 	br_recalculate_fwd_mask(br);
+ 
+ 	/* Delete VLANs for the old proto from the device filter. */
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
+ 			vlan_vid_del(p->dev, oldproto, vid);
+ 	}
++>>>>>>> 204177f3f30c (bridge: Support 802.1ad vlan filtering)
  
  unlock:
  	rtnl_unlock();
  	return err;
++<<<<<<< HEAD
 +}
 +
 +int br_vlan_init(struct net_bridge *br)
++=======
+ 
+ err_filt:
+ 	errvid = vid;
+ 	for_each_set_bit(vid, pv->vlan_bitmap, errvid)
+ 		vlan_vid_del(p->dev, proto, vid);
+ 
+ 	list_for_each_entry_continue_reverse(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
+ 			vlan_vid_del(p->dev, proto, vid);
+ 	}
+ 
+ 	goto unlock;
+ }
+ 
+ void br_vlan_init(struct net_bridge *br)
++>>>>>>> 204177f3f30c (bridge: Support 802.1ad vlan filtering)
  {
  	br->vlan_proto = htons(ETH_P_8021Q);
 +	br->default_pvid = 1;
 +	return br_vlan_add(br, 1,
 +			   BRIDGE_VLAN_INFO_PVID | BRIDGE_VLAN_INFO_UNTAGGED);
  }
  
  /* Must be protected by RTNL.
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_sysfs_br.c
* Unmerged path net/bridge/br_vlan.c
