i40e: set broadcast promiscuous mode for each active VLAN

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 435c084aad9615c7c77464e7c04600da920fc208
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/435c084a.failed

A previous workaround added to ensure receipt of all broadcast frames
incorrectly set the broadcast promiscuous mode unconditionally
regardless of active VLAN status.

Replace this partial workaround with a complete solution that sets the
broadcast promiscuous filters in i40e_sync_vsi_filters. This new method
sets the promiscuous mode based on when broadcast filters are added or
removed.

I40E_VLAN_ANY will request a broadcast filter for all VLANs, (as we're
in untagged mode) while a broadcast filter on a specific VLAN will only
request broadcast for that VLAN.

Thus, we restore addition of broadcast filter to the array, but we add
special handling for these such that they enable the broadcast
promiscuous mode instead of being sent as regular filters.

The end result is that we will correctly receive all broadcast packets
(even those with a *source* address equal to the broadcast address) but
will not receive packets for which we don't have an active VLAN filter.

Change-ID: I7d0585c5cec1a5bf55bf533b42e5e817d5db6a2d
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 435c084aad9615c7c77464e7c04600da920fc208)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 9f10febff1fc,594856d605ec..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -1315,7 -1245,7 +1315,11 @@@ struct i40e_mac_filter *i40e_add_filter
  	if (!vsi || !macaddr)
  		return NULL;
  
++<<<<<<< HEAD
 +	f = i40e_find_filter(vsi, macaddr, vlan, is_vf, is_netdev);
++=======
+ 	f = i40e_find_filter(vsi, macaddr, vlan);
++>>>>>>> 435c084aad96 (i40e: set broadcast promiscuous mode for each active VLAN)
  	if (!f) {
  		f = kzalloc(sizeof(*f), GFP_ATOMIC);
  		if (!f)
@@@ -1783,6 -1776,121 +1787,124 @@@ i40e_update_filter_state(int count
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_aqc_del_filters - Request firmware to delete a set of filters
+  * @vsi: ptr to the VSI
+  * @vsi_name: name to display in messages
+  * @list: the list of filters to send to firmware
+  * @num_del: the number of filters to delete
+  * @retval: Set to -EIO on failure to delete
+  *
+  * Send a request to firmware via AdminQ to delete a set of filters. Uses
+  * *retval instead of a return value so that success does not force ret_val to
+  * be set to 0. This ensures that a sequence of calls to this function
+  * preserve the previous value of *retval on successful delete.
+  */
+ static
+ void i40e_aqc_del_filters(struct i40e_vsi *vsi, const char *vsi_name,
+ 			  struct i40e_aqc_remove_macvlan_element_data *list,
+ 			  int num_del, int *retval)
+ {
+ 	struct i40e_hw *hw = &vsi->back->hw;
+ 	i40e_status aq_ret;
+ 	int aq_err;
+ 
+ 	aq_ret = i40e_aq_remove_macvlan(hw, vsi->seid, list, num_del, NULL);
+ 	aq_err = hw->aq.asq_last_status;
+ 
+ 	/* Explicitly ignore and do not report when firmware returns ENOENT */
+ 	if (aq_ret && !(aq_err == I40E_AQ_RC_ENOENT)) {
+ 		*retval = -EIO;
+ 		dev_info(&vsi->back->pdev->dev,
+ 			 "ignoring delete macvlan error on %s, err %s, aq_err %s\n",
+ 			 vsi_name, i40e_stat_str(hw, aq_ret),
+ 			 i40e_aq_str(hw, aq_err));
+ 	}
+ }
+ 
+ /**
+  * i40e_aqc_add_filters - Request firmware to add a set of filters
+  * @vsi: ptr to the VSI
+  * @vsi_name: name to display in messages
+  * @list: the list of filters to send to firmware
+  * @add_head: Position in the add hlist
+  * @num_add: the number of filters to add
+  * @promisc_change: set to true on exit if promiscuous mode was forced on
+  *
+  * Send a request to firmware via AdminQ to add a chunk of filters. Will set
+  * promisc_changed to true if the firmware has run out of space for more
+  * filters.
+  */
+ static
+ void i40e_aqc_add_filters(struct i40e_vsi *vsi, const char *vsi_name,
+ 			  struct i40e_aqc_add_macvlan_element_data *list,
+ 			  struct i40e_mac_filter *add_head,
+ 			  int num_add, bool *promisc_changed)
+ {
+ 	struct i40e_hw *hw = &vsi->back->hw;
+ 	i40e_status aq_ret;
+ 	int aq_err, fcnt;
+ 
+ 	aq_ret = i40e_aq_add_macvlan(hw, vsi->seid, list, num_add, NULL);
+ 	aq_err = hw->aq.asq_last_status;
+ 	fcnt = i40e_update_filter_state(num_add, list, add_head, aq_ret);
+ 	vsi->active_filters += fcnt;
+ 
+ 	if (fcnt != num_add) {
+ 		*promisc_changed = true;
+ 		set_bit(__I40E_FILTER_OVERFLOW_PROMISC, &vsi->state);
+ 		vsi->promisc_threshold = (vsi->active_filters * 3) / 4;
+ 		dev_warn(&vsi->back->pdev->dev,
+ 			 "Error %s adding RX filters on %s, promiscuous mode forced on\n",
+ 			 i40e_aq_str(hw, aq_err),
+ 			 vsi_name);
+ 	}
+ }
+ 
+ /**
+  * i40e_aqc_broadcast_filter - Set promiscuous broadcast flags
+  * @vsi: pointer to the VSI
+  * @f: filter data
+  *
+  * This function sets or clears the promiscuous broadcast flags for VLAN
+  * filters in order to properly receive broadcast frames. Assumes that only
+  * broadcast filters are passed.
+  **/
+ static
+ void i40e_aqc_broadcast_filter(struct i40e_vsi *vsi, const char *vsi_name,
+ 			       struct i40e_mac_filter *f)
+ {
+ 	bool enable = f->state == I40E_FILTER_NEW;
+ 	struct i40e_hw *hw = &vsi->back->hw;
+ 	i40e_status aq_ret;
+ 
+ 	if (f->vlan == I40E_VLAN_ANY) {
+ 		aq_ret = i40e_aq_set_vsi_broadcast(hw,
+ 						   vsi->seid,
+ 						   enable,
+ 						   NULL);
+ 	} else {
+ 		aq_ret = i40e_aq_set_vsi_bc_promisc_on_vlan(hw,
+ 							    vsi->seid,
+ 							    enable,
+ 							    f->vlan,
+ 							    NULL);
+ 	}
+ 
+ 	if (aq_ret) {
+ 		dev_warn(&vsi->back->pdev->dev,
+ 			 "Error %s setting broadcast promiscuous mode on %s\n",
+ 			 i40e_aq_str(hw, hw->aq.asq_last_status),
+ 			 vsi_name);
+ 		f->state = I40E_FILTER_FAILED;
+ 	} else if (enable) {
+ 		f->state = I40E_FILTER_ACTIVE;
+ 	}
+ }
+ 
+ /**
++>>>>>>> 435c084aad96 (i40e: set broadcast promiscuous mode for each active VLAN)
   * i40e_sync_vsi_filters - Update the VSI filter list to the HW
   * @vsi: ptr to the VSI
   *
@@@ -1858,18 -2032,23 +1980,29 @@@ int i40e_sync_vsi_filters(struct i40e_v
  		list_size = filter_list_len *
  			    sizeof(struct i40e_aqc_remove_macvlan_element_data);
  		del_list = kzalloc(list_size, GFP_ATOMIC);
 -		if (!del_list)
 -			goto err_no_memory;
 +		if (!del_list) {
 +			/* Undo VSI's MAC filter entry element updates */
 +			spin_lock_bh(&vsi->mac_filter_list_lock);
 +			i40e_undo_del_filter_entries(vsi, &tmp_del_list);
 +			spin_unlock_bh(&vsi->mac_filter_list_lock);
 +			retval = -ENOMEM;
 +			goto out;
 +		}
  
 -		hlist_for_each_entry_safe(f, h, &tmp_del_list, hlist) {
 +		list_for_each_entry_safe(f, ftmp, &tmp_del_list, list) {
  			cmd_flags = 0;
  
+ 			/* handle broadcast filters by updating the broadcast
+ 			 * promiscuous flag instead of deleting a MAC filter.
+ 			 */
+ 			if (is_broadcast_ether_addr(f->macaddr)) {
+ 				i40e_aqc_broadcast_filter(vsi, vsi_name, f);
+ 
+ 				hlist_del(&f->hlist);
+ 				kfree(f);
+ 				continue;
+ 			}
+ 
  			/* add to delete list */
  			ether_addr_copy(del_list[num_del].mac_addr, f->macaddr);
  			if (f->vlan == I40E_VLAN_ANY) {
@@@ -1942,12 -2101,11 +2075,16 @@@
  		list_size = filter_list_len *
  			       sizeof(struct i40e_aqc_add_macvlan_element_data);
  		add_list = kzalloc(list_size, GFP_ATOMIC);
 -		if (!add_list)
 -			goto err_no_memory;
 -
 +		if (!add_list) {
 +			retval = -ENOMEM;
 +			goto out;
 +		}
  		num_add = 0;
++<<<<<<< HEAD
 +		list_for_each_entry(f, &tmp_add_list, list) {
++=======
+ 		hlist_for_each_entry_safe(f, h, &tmp_add_list, hlist) {
++>>>>>>> 435c084aad96 (i40e: set broadcast promiscuous mode for each active VLAN)
  			if (test_bit(__I40E_FILTER_OVERFLOW_PROMISC,
  				     &vsi->state)) {
  				f->state = I40E_FILTER_FAILED;
@@@ -9264,11 -9300,29 +9415,29 @@@ static int i40e_config_netdev(struct i4
  			 pf->vsi[pf->lan_vsi]->netdev->name);
  		random_ether_addr(mac_addr);
  
 -		spin_lock_bh(&vsi->mac_filter_hash_lock);
 -		i40e_add_filter(vsi, mac_addr, I40E_VLAN_ANY);
 -		spin_unlock_bh(&vsi->mac_filter_hash_lock);
 +		spin_lock_bh(&vsi->mac_filter_list_lock);
 +		i40e_add_filter(vsi, mac_addr, I40E_VLAN_ANY, false, false);
 +		spin_unlock_bh(&vsi->mac_filter_list_lock);
  	}
  
+ 	/* Add the broadcast filter so that we initially will receive
+ 	 * broadcast packets. Note that when a new VLAN is first added the
+ 	 * driver will convert all filters marked I40E_VLAN_ANY into VLAN
+ 	 * specific filters as part of transitioning into "vlan" operation.
+ 	 * When more VLANs are added, the driver will copy each existing MAC
+ 	 * filter and add it for the new VLAN.
+ 	 *
+ 	 * Broadcast filters are handled specially by
+ 	 * i40e_sync_filters_subtask, as the driver must to set the broadcast
+ 	 * promiscuous bit instead of adding this directly as a MAC/VLAN
+ 	 * filter. The subtask will update the correct broadcast promiscuous
+ 	 * bits as VLANs become active or inactive.
+ 	 */
+ 	eth_broadcast_addr(broadcast);
+ 	spin_lock_bh(&vsi->mac_filter_hash_lock);
+ 	i40e_add_filter(vsi, broadcast, I40E_VLAN_ANY);
+ 	spin_unlock_bh(&vsi->mac_filter_hash_lock);
+ 
  	ether_addr_copy(netdev->dev_addr, mac_addr);
  	ether_addr_copy(netdev->perm_addr, mac_addr);
  
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index 4fb0bfac177f,05ed49b4b7c0..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -696,7 -697,13 +697,17 @@@ static int i40e_alloc_vsi_res(struct i4
  					 "Could not add MAC filter %pM for VF %d\n",
  					vf->default_lan_addr.addr, vf->vf_id);
  		}
++<<<<<<< HEAD
 +		spin_unlock_bh(&vsi->mac_filter_list_lock);
++=======
+ 		eth_broadcast_addr(broadcast);
+ 		f = i40e_add_filter(vsi, broadcast,
+ 				    vf->port_vlan_id ? vf->port_vlan_id : -1);
+ 		if (!f)
+ 			dev_info(&pf->pdev->dev,
+ 				 "Could not allocate VF broadcast filter\n");
+ 		spin_unlock_bh(&vsi->mac_filter_hash_lock);
++>>>>>>> 435c084aad96 (i40e: set broadcast promiscuous mode for each active VLAN)
  		i40e_write_rx_ctl(&pf->hw, I40E_VFQF_HENA1(0, vf->vf_id),
  				  (u32)hena);
  		i40e_write_rx_ctl(&pf->hw, I40E_VFQF_HENA1(1, vf->vf_id),
diff --git a/drivers/net/ethernet/intel/i40e/i40e_common.c b/drivers/net/ethernet/intel/i40e/i40e_common.c
index 1185ddab88a1..cb732081279d 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c
@@ -2170,6 +2170,40 @@ enum i40e_status_code i40e_aq_set_vsi_uc_promisc_on_vlan(struct i40e_hw *hw,
 	return status;
 }
 
+/**
+ * i40e_aq_set_vsi_bc_promisc_on_vlan
+ * @hw: pointer to the hw struct
+ * @seid: vsi number
+ * @enable: set broadcast promiscuous enable/disable for a given VLAN
+ * @vid: The VLAN tag filter - capture any broadcast packet with this VLAN tag
+ * @cmd_details: pointer to command details structure or NULL
+ **/
+i40e_status i40e_aq_set_vsi_bc_promisc_on_vlan(struct i40e_hw *hw,
+				u16 seid, bool enable, u16 vid,
+				struct i40e_asq_cmd_details *cmd_details)
+{
+	struct i40e_aq_desc desc;
+	struct i40e_aqc_set_vsi_promiscuous_modes *cmd =
+		(struct i40e_aqc_set_vsi_promiscuous_modes *)&desc.params.raw;
+	i40e_status status;
+	u16 flags = 0;
+
+	i40e_fill_default_direct_cmd_desc(&desc,
+					i40e_aqc_opc_set_vsi_promiscuous_modes);
+
+	if (enable)
+		flags |= I40E_AQC_SET_VSI_PROMISC_BROADCAST;
+
+	cmd->promiscuous_flags = cpu_to_le16(flags);
+	cmd->valid_flags = cpu_to_le16(I40E_AQC_SET_VSI_PROMISC_BROADCAST);
+	cmd->seid = cpu_to_le16(seid);
+	cmd->vlan_tag = cpu_to_le16(vid | I40E_AQC_SET_VSI_VLAN_VALID);
+
+	status = i40e_asq_send_command(hw, &desc, NULL, 0, cmd_details);
+
+	return status;
+}
+
 /**
  * i40e_aq_set_vsi_broadcast
  * @hw: pointer to the hw struct
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_prototype.h b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
index 82dedc978482..37d67e792ad0 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_prototype.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
@@ -144,6 +144,9 @@ enum i40e_status_code i40e_aq_set_vsi_uc_promisc_on_vlan(struct i40e_hw *hw,
 							 u16 seid, bool enable,
 							 u16 vid,
 				struct i40e_asq_cmd_details *cmd_details);
+i40e_status i40e_aq_set_vsi_bc_promisc_on_vlan(struct i40e_hw *hw,
+				u16 seid, bool enable, u16 vid,
+				struct i40e_asq_cmd_details *cmd_details);
 i40e_status i40e_aq_set_vsi_vlan_promisc(struct i40e_hw *hw,
 				u16 seid, bool enable,
 				struct i40e_asq_cmd_details *cmd_details);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
