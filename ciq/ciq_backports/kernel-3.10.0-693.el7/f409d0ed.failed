bridge: vlan: move back vlan_flush

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit f409d0ed87d2721e1099ce36266e98c5aea2d486
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f409d0ed.failed

Ido Schimmel reported a problem with switchdev devices because of the
order change of del_nbp operations, more specifically the move of
nbp_vlan_flush() which deletes all vlans and frees vlgrp after the
rx_handler has been unregistered. So in order to fix this move
vlan_flush back where it was and make it destroy the rhtable after
NULLing vlgrp and waiting a grace period to make sure noone can see it.

	Reported-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f409d0ed87d2721e1099ce36266e98c5aea2d486)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private.h
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_private.h
index b75519ca3c51,216018c76018..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -69,19 -69,69 +69,22 @@@ struct bridge_mcast_other_query 
  	struct timer_list		timer;
  	unsigned long			delay_time;
  };
 -
 -/* selected querier */
 -struct bridge_mcast_querier {
 -	struct br_ip addr;
 -	struct net_bridge_port __rcu	*port;
 -};
  #endif
  
 -/**
 - * struct net_bridge_vlan - per-vlan entry
 - *
 - * @vnode: rhashtable member
 - * @vid: VLAN id
 - * @flags: bridge vlan flags
 - * @br: if MASTER flag set, this points to a bridge struct
 - * @port: if MASTER flag unset, this points to a port struct
 - * @refcnt: if MASTER flag set, this is bumped for each port referencing it
 - * @brvlan: if MASTER flag unset, this points to the global per-VLAN context
 - *          for this VLAN entry
 - * @vlist: sorted list of VLAN entries
 - * @rcu: used for entry destruction
 - *
 - * This structure is shared between the global per-VLAN entries contained in
 - * the bridge rhashtable and the local per-port per-VLAN entries contained in
 - * the port's rhashtable. The union entries should be interpreted depending on
 - * the entry flags that are set.
 - */
 -struct net_bridge_vlan {
 -	struct rhash_head		vnode;
 -	u16				vid;
 -	u16				flags;
 -	union {
 -		struct net_bridge	*br;
 -		struct net_bridge_port	*port;
 -	};
 +struct net_port_vlans {
 +	u16				port_idx;
 +	u16				pvid;
++<<<<<<< HEAD
  	union {
 -		atomic_t		refcnt;
 -		struct net_bridge_vlan	*brvlan;
 -	};
 -	struct list_head		vlist;
 -
 +		struct net_bridge_port		*port;
 +		struct net_bridge		*br;
 +	}				parent;
  	struct rcu_head			rcu;
 -};
 -
 -/**
 - * struct net_bridge_vlan_group
 - *
 - * @vlan_hash: VLAN entry rhashtable
 - * @vlan_list: sorted VLAN entry list
 - * @num_vlans: number of total VLAN entries
 - * @pvid: PVID VLAN id
 - *
 - * IMPORTANT: Be careful when checking if there're VLAN entries using list
 - *            primitives because the bridge can have entries in its list which
 - *            are just for global context but not for filtering, i.e. they have
 - *            the master flag set but not the brentry flag. If you have to check
 - *            if there're "real" entries in the bridge please test @num_vlans
 - */
 -struct net_bridge_vlan_group {
 -	struct rhashtable		vlan_hash;
 -	struct list_head		vlan_list;
 +	unsigned long			vlan_bitmap[BR_VLAN_BITMAP_LEN];
 +	unsigned long			untagged_bitmap[BR_VLAN_BITMAP_LEN];
  	u16				num_vlans;
 -	u16				pvid;
++=======
++>>>>>>> f409d0ed87d2 (bridge: vlan: move back vlan_flush)
  };
  
  struct net_bridge_fdb_entry
diff --cc net/bridge/br_vlan.c
index 1122c9d717ea,5f0d0cc4744f..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -63,68 -212,115 +63,85 @@@ static int __vlan_add(struct net_port_v
  		 * This ensures tagged traffic enters the bridge when
  		 * promiscuous mode is disabled by br_manage_promisc().
  		 */
 -		err = __vlan_vid_add(dev, br, v->vid, flags);
 +		err = vlan_vid_add(dev, br->vlan_proto, vid);
  		if (err)
 -			goto out;
 -
 -		/* need to work on the master vlan too */
 -		if (flags & BRIDGE_VLAN_INFO_MASTER) {
 -			err = br_vlan_add(br, v->vid, flags |
 -						      BRIDGE_VLAN_INFO_BRENTRY);
 -			if (err)
 -				goto out_filt;
 -		}
 -
 -		masterv = br_vlan_get_master(br, v->vid);
 -		if (!masterv)
 -			goto out_filt;
 -		v->brvlan = masterv;
 +			return err;
  	}
  
 -	/* Add the dev mac and count the vlan only if it's usable */
 -	if (br_vlan_should_use(v)) {
 -		err = br_fdb_insert(br, p, dev->dev_addr, v->vid);
 -		if (err) {
 -			br_err(br, "failed insert local address into bridge forwarding table\n");
 -			goto out_filt;
 -		}
 -		vg->num_vlans++;
 +	err = br_fdb_insert(br, p, dev->dev_addr, vid);
 +	if (err) {
 +		br_err(br, "failed insert local address into bridge "
 +		       "forwarding table\n");
 +		goto out_filt;
  	}
  
 -	err = rhashtable_lookup_insert_fast(&vg->vlan_hash, &v->vnode,
 -					    br_vlan_rht_params);
 -	if (err)
 -		goto out_fdb_insert;
 +	set_bit(vid, v->vlan_bitmap);
 +	v->num_vlans++;
 +	__vlan_add_flags(v, vid, flags);
  
 -	__vlan_add_list(v);
 -	__vlan_add_flags(v, flags);
 -out:
 -	return err;
 -
 -out_fdb_insert:
 -	if (br_vlan_should_use(v)) {
 -		br_fdb_find_delete_local(br, p, dev->dev_addr, v->vid);
 -		vg->num_vlans--;
 -	}
 +	return 0;
  
  out_filt:
 -	if (p) {
 -		__vlan_vid_del(dev, br, v->vid);
 -		if (masterv) {
 -			br_vlan_put_master(masterv);
 -			v->brvlan = NULL;
 -		}
 -	}
 +	if (p && p->br->vlan_enabled)
 +		vlan_vid_del(dev, br->vlan_proto, vid);
 +	return err;
 +}
  
 -	goto out;
++<<<<<<< HEAD
 +static int __vlan_del(struct net_port_vlans *v, u16 vid)
++=======
++static void __vlan_group_free(struct net_bridge_vlan_group *vg)
++{
++	WARN_ON(!list_empty(&vg->vlan_list));
++	rhashtable_destroy(&vg->vlan_hash);
++	kfree(vg);
+ }
+ 
 -static int __vlan_del(struct net_bridge_vlan *v)
++static void __vlan_flush(struct net_bridge_vlan_group *vg)
++>>>>>>> f409d0ed87d2 (bridge: vlan: move back vlan_flush)
  {
 -	struct net_bridge_vlan *masterv = v;
 -	struct net_bridge_vlan_group *vg;
 -	struct net_bridge_port *p = NULL;
 -	int err = 0;
 +	if (!test_bit(vid, v->vlan_bitmap))
 +		return -EINVAL;
  
 -	if (br_vlan_is_master(v)) {
 -		vg = br_vlan_group(v->br);
 -	} else {
 -		p = v->port;
 -		vg = nbp_vlan_group(v->port);
 -		masterv = v->brvlan;
 -	}
++<<<<<<< HEAD
 +	__vlan_delete_pvid(v, vid);
 +	clear_bit(vid, v->untagged_bitmap);
  
 -	__vlan_delete_pvid(vg, v->vid);
 -	if (p) {
 -		err = __vlan_vid_del(p->dev, p->br, v->vid);
 -		if (err)
 -			goto out;
 -	}
 +	if (v->port_idx) {
 +		struct net_bridge_port *p = v->parent.port;
  
 -	if (br_vlan_should_use(v)) {
 -		v->flags &= ~BRIDGE_VLAN_INFO_BRENTRY;
 -		vg->num_vlans--;
 +		/* Toggle HW filters when filtering is enabled */
 +		if (p->br->vlan_enabled)
 +			vlan_vid_del(p->dev, p->br->vlan_proto, vid);
  	}
  
 -	if (masterv != v) {
 -		rhashtable_remove_fast(&vg->vlan_hash, &v->vnode,
 -				       br_vlan_rht_params);
 -		__vlan_del_list(v);
 +	clear_bit(vid, v->vlan_bitmap);
 +	v->num_vlans--;
 +	if (bitmap_empty(v->vlan_bitmap, VLAN_N_VID)) {
 +		if (v->port_idx)
 +			RCU_INIT_POINTER(v->parent.port->vlan_info, NULL);
 +		else
 +			RCU_INIT_POINTER(v->parent.br->vlan_info, NULL);
  		kfree_rcu(v, rcu);
  	}
 -
 -	br_vlan_put_master(masterv);
 -out:
 -	return err;
 -}
 -
 -static void __vlan_group_free(struct net_bridge_vlan_group *vg)
 -{
 -	WARN_ON(!list_empty(&vg->vlan_list));
 -	rhashtable_destroy(&vg->vlan_hash);
 -	kfree(vg);
 +	return 0;
  }
  
 -static void __vlan_flush(struct net_bridge_vlan_group *vg)
 +static void __vlan_flush(struct net_port_vlans *v)
  {
 -	struct net_bridge_vlan *vlan, *tmp;
 -
 +	smp_wmb();
 +	v->pvid = 0;
 +	bitmap_zero(v->vlan_bitmap, VLAN_N_VID);
 +	if (v->port_idx)
 +		RCU_INIT_POINTER(v->parent.port->vlan_info, NULL);
 +	else
 +		RCU_INIT_POINTER(v->parent.br->vlan_info, NULL);
 +	kfree_rcu(v, rcu);
++=======
+ 	__vlan_delete_pvid(vg, vg->pvid);
+ 	list_for_each_entry_safe(vlan, tmp, &vg->vlan_list, vlist)
+ 		__vlan_del(vlan);
++>>>>>>> f409d0ed87d2 (bridge: vlan: move back vlan_flush)
  }
  
  struct sk_buff *br_handle_vlan(struct net_bridge *br,
@@@ -355,54 -576,94 +372,80 @@@ int br_vlan_delete(struct net_bridge *b
  
  void br_vlan_flush(struct net_bridge *br)
  {
++<<<<<<< HEAD
 +	struct net_port_vlans *pv;
 +
 +	ASSERT_RTNL();
 +	pv = rtnl_dereference(br->vlan_info);
 +	if (!pv)
++=======
+ 	struct net_bridge_vlan_group *vg;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	vg = br_vlan_group(br);
+ 	__vlan_flush(vg);
+ 	RCU_INIT_POINTER(br->vlgrp, NULL);
+ 	synchronize_rcu();
+ 	__vlan_group_free(vg);
+ }
+ 
+ struct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg, u16 vid)
+ {
+ 	if (!vg)
+ 		return NULL;
+ 
+ 	return br_vlan_lookup(&vg->vlan_hash, vid);
+ }
+ 
+ /* Must be protected by RTNL. */
+ static void recalculate_group_addr(struct net_bridge *br)
+ {
+ 	if (br->group_addr_set)
++>>>>>>> f409d0ed87d2 (bridge: vlan: move back vlan_flush)
  		return;
  
 -	spin_lock_bh(&br->lock);
 -	if (!br->vlan_enabled || br->vlan_proto == htons(ETH_P_8021Q)) {
 -		/* Bridge Group Address */
 -		br->group_addr[5] = 0x00;
 -	} else { /* vlan_enabled && ETH_P_8021AD */
 -		/* Provider Bridge Group Address */
 -		br->group_addr[5] = 0x08;
 -	}
 -	spin_unlock_bh(&br->lock);
 +	__vlan_flush(pv);
  }
  
 -/* Must be protected by RTNL. */
 -void br_recalculate_fwd_mask(struct net_bridge *br)
 +bool br_vlan_find(struct net_bridge *br, u16 vid)
  {
 -	if (!br->vlan_enabled || br->vlan_proto == htons(ETH_P_8021Q))
 -		br->group_fwd_mask_required = BR_GROUPFWD_DEFAULT;
 -	else /* vlan_enabled && ETH_P_8021AD */
 -		br->group_fwd_mask_required = BR_GROUPFWD_8021AD &
 -					      ~(1u << br->group_addr[5]);
 -}
 +	struct net_port_vlans *pv;
 +	bool found = false;
  
 -int __br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)
 -{
 -	if (br->vlan_enabled == val)
 -		return 0;
 -
 -	br->vlan_enabled = val;
 -	br_manage_promisc(br);
 -	recalculate_group_addr(br);
 -	br_recalculate_fwd_mask(br);
 +	rcu_read_lock();
 +	pv = rcu_dereference(br->vlan_info);
  
 -	return 0;
 -}
 -
 -int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)
 -{
 -	if (!rtnl_trylock())
 -		return restart_syscall();
 +	if (!pv)
 +		goto out;
  
 -	__br_vlan_filter_toggle(br, val);
 -	rtnl_unlock();
 +	if (test_bit(vid, pv->vlan_bitmap))
 +		found = true;
  
 -	return 0;
 +out:
 +	rcu_read_unlock();
 +	return found;
  }
  
 -int __br_vlan_set_proto(struct net_bridge *br, __be16 proto)
 +static void br_set_hw_filters(struct net_bridge *br)
  {
 -	int err = 0;
  	struct net_bridge_port *p;
 -	struct net_bridge_vlan *vlan;
 -	struct net_bridge_vlan_group *vg;
 -	__be16 oldproto;
 -
 -	if (br->vlan_proto == proto)
 -		return 0;
 +	struct net_port_vlans *pv;
 +	u16 vid, errvid;
 +	int err;
  
 -	/* Add VLANs for the new proto to the device filter. */
 +	/* For each port, walk the vlan bitmap and write the vlan
 +	 * info to port driver.
 +	 */
  	list_for_each_entry(p, &br->port_list, list) {
 -		vg = nbp_vlan_group(p);
 -		list_for_each_entry(vlan, &vg->vlan_list, vlist) {
 -			err = vlan_vid_add(p->dev, proto, vlan->vid);
 +		pv = rtnl_dereference(p->vlan_info);
 +		if (!pv)
 +			continue;
 +
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
 +			err = vlan_vid_add(p->dev, br->vlan_proto, vid);
  			if (err)
 -				goto err_filt;
 +				goto err_flt;
  		}
  	}
  
@@@ -661,47 -970,13 +704,59 @@@ int nbp_vlan_delete(struct net_bridge_p
  
  void nbp_vlan_flush(struct net_bridge_port *port)
  {
++<<<<<<< HEAD
 +	struct net_port_vlans *pv;
 +	u16 vid;
 +
 +	ASSERT_RTNL();
 +
 +	pv = rtnl_dereference(port->vlan_info);
 +	if (!pv)
 +		return;
 +
 +	if (port->br->vlan_enabled) {
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
 +			vlan_vid_del(port->dev, port->br->vlan_proto, vid);
 +	}
 +
 +	__vlan_flush(pv);
 +}
 +
 +bool nbp_vlan_find(struct net_bridge_port *port, u16 vid)
 +{
 +	struct net_port_vlans *pv;
 +	bool found = false;
 +
 +	rcu_read_lock();
 +	pv = rcu_dereference(port->vlan_info);
 +
 +	if (!pv)
 +		goto out;
 +
 +	if (test_bit(vid, pv->vlan_bitmap))
 +		found = true;
 +
 +out:
 +	rcu_read_unlock();
 +	return found;
 +}
 +
 +int nbp_vlan_init(struct net_bridge_port *p)
 +{
 +	return p->br->default_pvid ?
 +			nbp_vlan_add(p, p->br->default_pvid,
 +				     BRIDGE_VLAN_INFO_PVID |
 +				     BRIDGE_VLAN_INFO_UNTAGGED) :
 +			0;
++=======
+ 	struct net_bridge_vlan_group *vg;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	vg = nbp_vlan_group(port);
+ 	__vlan_flush(vg);
+ 	RCU_INIT_POINTER(port->vlgrp, NULL);
+ 	synchronize_rcu();
+ 	__vlan_group_free(vg);
++>>>>>>> f409d0ed87d2 (bridge: vlan: move back vlan_flush)
  }
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_vlan.c
