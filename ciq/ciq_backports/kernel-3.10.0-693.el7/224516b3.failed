flow_dissector: Correctly handle parsing FCoE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 224516b3a798a0563346748744f8cd19feaf09be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/224516b3.failed

The flow dissector bits handling FCoE didn't bother to actually validate
that the space there was enough for the FCoE header.  So we need to update
things so that if there is room we add the header and report a good result,
otherwise we do not add the header, and report the bad result.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Acked-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 224516b3a798a0563346748744f8cd19feaf09be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,6288153d7f36..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -212,18 -300,53 +212,26 @@@ ipv6
  		} *hdr, _hdr;
  		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
  		if (!hdr)
 -			goto out_bad;
 -
 -		if (dissector_uses_key(flow_dissector,
 -				       FLOW_DISSECTOR_KEY_TIPC_ADDRS)) {
 -			key_addrs = skb_flow_dissector_target(flow_dissector,
 -							      FLOW_DISSECTOR_KEY_TIPC_ADDRS,
 -							      target_container);
 -			key_addrs->tipcaddrs.srcnode = hdr->srcnode;
 -			key_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;
 -		}
 -		goto out_good;
 -	}
 -
 -	case htons(ETH_P_MPLS_UC):
 -	case htons(ETH_P_MPLS_MC): {
 -		struct mpls_label *hdr, _hdr[2];
 -mpls:
 -		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,
 -					   hlen, &_hdr);
 -		if (!hdr)
 -			goto out_bad;
 -
 -		if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>
 -		     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {
 -			if (dissector_uses_key(flow_dissector,
 -					       FLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {
 -				key_keyid = skb_flow_dissector_target(flow_dissector,
 -								      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,
 -								      target_container);
 -				key_keyid->keyid = hdr[1].entry &
 -					htonl(MPLS_LS_LABEL_MASK);
 -			}
 -
 -			goto out_good;
 -		}
 -
 -		goto out_good;
 +			return false;
 +		flow->src = hdr->srcnode;
 +		flow->dst = 0;
 +		flow->n_proto = proto;
 +		flow->thoff = (u16)nhoff;
 +		return true;
  	}
 -
  	case htons(ETH_P_FCOE):
++<<<<<<< HEAD
 +		flow->thoff = (u16)(nhoff + FCOE_HEADER_LEN);
 +		/* fall through */
++=======
+ 		if ((hlen - nhoff) < FCOE_HEADER_LEN)
+ 			goto out_bad;
+ 
+ 		nhoff += FCOE_HEADER_LEN;
+ 		goto out_good;
++>>>>>>> 224516b3a798 (flow_dissector: Correctly handle parsing FCoE)
  	default:
 -		goto out_bad;
 +		return false;
  	}
  
  ip_proto_again:
* Unmerged path net/core/flow_dissector.c
