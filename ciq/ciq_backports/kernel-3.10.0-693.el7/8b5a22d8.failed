NTB: Schedule to receive on QP link up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] Schedule to receive on QP link up (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 92.96%
commit-author Allen Hubbe <Allen.Hubbe@emc.com>
commit 8b5a22d8f18496f5921ccb92554a7051cbfd9b0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8b5a22d8.failed

Schedule to receive on QP link up, to make sure that the doorbell is
properly cleared for interrupts.

	Signed-off-by: Allen Hubbe <Allen.Hubbe@emc.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit 8b5a22d8f18496f5921ccb92554a7051cbfd9b0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_transport.c
diff --cc drivers/ntb/ntb_transport.c
index 0d5e96e60628,b82171e3e07d..000000000000
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@@ -818,38 -874,30 +818,45 @@@ static void ntb_qp_link_work(struct wor
  	struct ntb_transport_qp *qp = container_of(work,
  						   struct ntb_transport_qp,
  						   link_work.work);
 -	struct pci_dev *pdev = qp->ndev->pdev;
 -	struct ntb_transport_ctx *nt = qp->transport;
 -	int val;
 +	struct pci_dev *pdev = ntb_query_pdev(qp->ndev);
 +	struct ntb_transport *nt = qp->transport;
 +	int rc, val;
  
 -	WARN_ON(!nt->link_is_up);
 +	WARN_ON(nt->transport_link != NTB_LINK_UP);
  
 -	val = ntb_spad_read(nt->ndev, QP_LINKS);
 +	rc = ntb_read_local_spad(nt->ndev, QP_LINKS, &val);
 +	if (rc) {
 +		dev_err(&pdev->dev, "Error reading spad %d\n", QP_LINKS);
 +		return;
 +	}
  
 -	ntb_peer_spad_write(nt->ndev, QP_LINKS, val | BIT(qp->qp_num));
 +	rc = ntb_write_remote_spad(nt->ndev, QP_LINKS, val | 1 << qp->qp_num);
 +	if (rc)
 +		dev_err(&pdev->dev, "Error writing %x to remote spad %d\n",
 +			val | 1 << qp->qp_num, QP_LINKS);
  
  	/* query remote spad for qp ready bits */
 -	ntb_peer_spad_read(nt->ndev, QP_LINKS);
 -	dev_dbg_ratelimited(&pdev->dev, "Remote QP link status = %x\n", val);
 +	rc = ntb_read_remote_spad(nt->ndev, QP_LINKS, &val);
 +	if (rc)
 +		dev_err(&pdev->dev, "Error reading remote spad %d\n", QP_LINKS);
 +
 +	dev_dbg(&pdev->dev, "Remote QP link status = %x\n", val);
  
  	/* See if the remote side is up */
 -	if (val & BIT(qp->qp_num)) {
 -		dev_info(&pdev->dev, "qp %d: Link Up\n", qp->qp_num);
 -		qp->link_is_up = true;
 +	if (1 << qp->qp_num & val) {
 +		qp->qp_link = NTB_LINK_UP;
  
 +		dev_info(&pdev->dev, "qp %d: Link Up\n", qp->qp_num);
  		if (qp->event_handler)
++<<<<<<< HEAD
 +			qp->event_handler(qp->cb_data, NTB_LINK_UP);
 +	} else if (nt->transport_link == NTB_LINK_UP)
++=======
+ 			qp->event_handler(qp->cb_data, qp->link_is_up);
+ 
+ 		tasklet_schedule(&qp->rxc_db_work);
+ 	} else if (nt->link_is_up)
++>>>>>>> 8b5a22d8f184 (NTB: Schedule to receive on QP link up)
  		schedule_delayed_work(&qp->link_work,
  				      msecs_to_jiffies(NTB_LINK_DOWN_TIMEOUT));
  }
* Unmerged path drivers/ntb/ntb_transport.c
