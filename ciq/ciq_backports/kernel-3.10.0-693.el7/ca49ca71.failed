userfaultfd: non-cooperative: add event for exit() notification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mike Rapoport <rppt@linux.vnet.ibm.com>
commit ca49ca7114553587736fe78319e22f073b631380
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ca49ca71.failed

Allow userfaultfd monitor track termination of the processes that have
memory backed by the uffd.

[rppt@linux.vnet.ibm.com: add comment]
  Link: http://lkml.kernel.org/r/20170202135448.GB19804@rapoport-lnxLink: http://lkml.kernel.org/r/1485542673-24387-4-git-send-email-rppt@linux.vnet.ibm.com
	Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Acked-by: Hillf Danton <hillf.zj@alibaba-inc.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: "Dr. David Alan Gilbert" <dgilbert@redhat.com>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Pavel Emelyanov <xemul@virtuozzo.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ca49ca7114553587736fe78319e22f073b631380)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/userfaultfd.c
#	include/linux/userfaultfd_k.h
#	include/uapi/linux/userfaultfd.h
diff --cc fs/userfaultfd.c
index 0eadec862028,b676575f2268..000000000000
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@@ -517,6 -578,230 +517,233 @@@ static void userfaultfd_event_complete(
  	__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
  }
  
++<<<<<<< HEAD
++=======
+ int dup_userfaultfd(struct vm_area_struct *vma, struct list_head *fcs)
+ {
+ 	struct userfaultfd_ctx *ctx = NULL, *octx;
+ 	struct userfaultfd_fork_ctx *fctx;
+ 
+ 	octx = vma->vm_userfaultfd_ctx.ctx;
+ 	if (!octx || !(octx->features & UFFD_FEATURE_EVENT_FORK)) {
+ 		vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;
+ 		vma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);
+ 		return 0;
+ 	}
+ 
+ 	list_for_each_entry(fctx, fcs, list)
+ 		if (fctx->orig == octx) {
+ 			ctx = fctx->new;
+ 			break;
+ 		}
+ 
+ 	if (!ctx) {
+ 		fctx = kmalloc(sizeof(*fctx), GFP_KERNEL);
+ 		if (!fctx)
+ 			return -ENOMEM;
+ 
+ 		ctx = kmem_cache_alloc(userfaultfd_ctx_cachep, GFP_KERNEL);
+ 		if (!ctx) {
+ 			kfree(fctx);
+ 			return -ENOMEM;
+ 		}
+ 
+ 		atomic_set(&ctx->refcount, 1);
+ 		ctx->flags = octx->flags;
+ 		ctx->state = UFFD_STATE_RUNNING;
+ 		ctx->features = octx->features;
+ 		ctx->released = false;
+ 		ctx->mm = vma->vm_mm;
+ 		atomic_inc(&ctx->mm->mm_count);
+ 
+ 		userfaultfd_ctx_get(octx);
+ 		fctx->orig = octx;
+ 		fctx->new = ctx;
+ 		list_add_tail(&fctx->list, fcs);
+ 	}
+ 
+ 	vma->vm_userfaultfd_ctx.ctx = ctx;
+ 	return 0;
+ }
+ 
+ static int dup_fctx(struct userfaultfd_fork_ctx *fctx)
+ {
+ 	struct userfaultfd_ctx *ctx = fctx->orig;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	msg_init(&ewq.msg);
+ 
+ 	ewq.msg.event = UFFD_EVENT_FORK;
+ 	ewq.msg.arg.reserved.reserved1 = (unsigned long)fctx->new;
+ 
+ 	return userfaultfd_event_wait_completion(ctx, &ewq);
+ }
+ 
+ void dup_userfaultfd_complete(struct list_head *fcs)
+ {
+ 	int ret = 0;
+ 	struct userfaultfd_fork_ctx *fctx, *n;
+ 
+ 	list_for_each_entry_safe(fctx, n, fcs, list) {
+ 		if (!ret)
+ 			ret = dup_fctx(fctx);
+ 		list_del(&fctx->list);
+ 		kfree(fctx);
+ 	}
+ }
+ 
+ void mremap_userfaultfd_prep(struct vm_area_struct *vma,
+ 			     struct vm_userfaultfd_ctx *vm_ctx)
+ {
+ 	struct userfaultfd_ctx *ctx;
+ 
+ 	ctx = vma->vm_userfaultfd_ctx.ctx;
+ 	if (ctx && (ctx->features & UFFD_FEATURE_EVENT_REMAP)) {
+ 		vm_ctx->ctx = ctx;
+ 		userfaultfd_ctx_get(ctx);
+ 	}
+ }
+ 
+ void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx *vm_ctx,
+ 				 unsigned long from, unsigned long to,
+ 				 unsigned long len)
+ {
+ 	struct userfaultfd_ctx *ctx = vm_ctx->ctx;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	if (!ctx)
+ 		return;
+ 
+ 	if (to & ~PAGE_MASK) {
+ 		userfaultfd_ctx_put(ctx);
+ 		return;
+ 	}
+ 
+ 	msg_init(&ewq.msg);
+ 
+ 	ewq.msg.event = UFFD_EVENT_REMAP;
+ 	ewq.msg.arg.remap.from = from;
+ 	ewq.msg.arg.remap.to = to;
+ 	ewq.msg.arg.remap.len = len;
+ 
+ 	userfaultfd_event_wait_completion(ctx, &ewq);
+ }
+ 
+ void userfaultfd_remove(struct vm_area_struct *vma,
+ 			struct vm_area_struct **prev,
+ 			unsigned long start, unsigned long end)
+ {
+ 	struct mm_struct *mm = vma->vm_mm;
+ 	struct userfaultfd_ctx *ctx;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	ctx = vma->vm_userfaultfd_ctx.ctx;
+ 	if (!ctx || !(ctx->features & UFFD_FEATURE_EVENT_REMOVE))
+ 		return;
+ 
+ 	userfaultfd_ctx_get(ctx);
+ 	up_read(&mm->mmap_sem);
+ 
+ 	*prev = NULL; /* We wait for ACK w/o the mmap semaphore */
+ 
+ 	msg_init(&ewq.msg);
+ 
+ 	ewq.msg.event = UFFD_EVENT_REMOVE;
+ 	ewq.msg.arg.remove.start = start;
+ 	ewq.msg.arg.remove.end = end;
+ 
+ 	userfaultfd_event_wait_completion(ctx, &ewq);
+ 
+ 	down_read(&mm->mmap_sem);
+ }
+ 
+ static bool has_unmap_ctx(struct userfaultfd_ctx *ctx, struct list_head *unmaps,
+ 			  unsigned long start, unsigned long end)
+ {
+ 	struct userfaultfd_unmap_ctx *unmap_ctx;
+ 
+ 	list_for_each_entry(unmap_ctx, unmaps, list)
+ 		if (unmap_ctx->ctx == ctx && unmap_ctx->start == start &&
+ 		    unmap_ctx->end == end)
+ 			return true;
+ 
+ 	return false;
+ }
+ 
+ int userfaultfd_unmap_prep(struct vm_area_struct *vma,
+ 			   unsigned long start, unsigned long end,
+ 			   struct list_head *unmaps)
+ {
+ 	for ( ; vma && vma->vm_start < end; vma = vma->vm_next) {
+ 		struct userfaultfd_unmap_ctx *unmap_ctx;
+ 		struct userfaultfd_ctx *ctx = vma->vm_userfaultfd_ctx.ctx;
+ 
+ 		if (!ctx || !(ctx->features & UFFD_FEATURE_EVENT_UNMAP) ||
+ 		    has_unmap_ctx(ctx, unmaps, start, end))
+ 			continue;
+ 
+ 		unmap_ctx = kzalloc(sizeof(*unmap_ctx), GFP_KERNEL);
+ 		if (!unmap_ctx)
+ 			return -ENOMEM;
+ 
+ 		userfaultfd_ctx_get(ctx);
+ 		unmap_ctx->ctx = ctx;
+ 		unmap_ctx->start = start;
+ 		unmap_ctx->end = end;
+ 		list_add_tail(&unmap_ctx->list, unmaps);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void userfaultfd_unmap_complete(struct mm_struct *mm, struct list_head *uf)
+ {
+ 	struct userfaultfd_unmap_ctx *ctx, *n;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	list_for_each_entry_safe(ctx, n, uf, list) {
+ 		msg_init(&ewq.msg);
+ 
+ 		ewq.msg.event = UFFD_EVENT_UNMAP;
+ 		ewq.msg.arg.remove.start = ctx->start;
+ 		ewq.msg.arg.remove.end = ctx->end;
+ 
+ 		userfaultfd_event_wait_completion(ctx->ctx, &ewq);
+ 
+ 		list_del(&ctx->list);
+ 		kfree(ctx);
+ 	}
+ }
+ 
+ void userfaultfd_exit(struct mm_struct *mm)
+ {
+ 	struct vm_area_struct *vma = mm->mmap;
+ 
+ 	/*
+ 	 * We can do the vma walk without locking because the caller
+ 	 * (exit_mm) knows it now has exclusive access
+ 	 */
+ 	while (vma) {
+ 		struct userfaultfd_ctx *ctx = vma->vm_userfaultfd_ctx.ctx;
+ 
+ 		if (ctx && (ctx->features & UFFD_FEATURE_EVENT_EXIT)) {
+ 			struct userfaultfd_wait_queue ewq;
+ 
+ 			userfaultfd_ctx_get(ctx);
+ 
+ 			msg_init(&ewq.msg);
+ 			ewq.msg.event = UFFD_EVENT_EXIT;
+ 
+ 			userfaultfd_event_wait_completion(ctx, &ewq);
+ 
+ 			ctx->features &= ~UFFD_FEATURE_EVENT_EXIT;
+ 		}
+ 
+ 		vma = vma->vm_next;
+ 	}
+ }
+ 
++>>>>>>> ca49ca711455 (userfaultfd: non-cooperative: add event for exit() notification)
  static int userfaultfd_release(struct inode *inode, struct file *file)
  {
  	struct userfaultfd_ctx *ctx = file->private_data;
diff --cc include/linux/userfaultfd_k.h
index 587480ad41b7,0468548acebf..000000000000
--- a/include/linux/userfaultfd_k.h
+++ b/include/linux/userfaultfd_k.h
@@@ -53,6 -52,28 +53,31 @@@ static inline bool userfaultfd_armed(st
  	return vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP);
  }
  
++<<<<<<< HEAD
++=======
+ extern int dup_userfaultfd(struct vm_area_struct *, struct list_head *);
+ extern void dup_userfaultfd_complete(struct list_head *);
+ 
+ extern void mremap_userfaultfd_prep(struct vm_area_struct *,
+ 				    struct vm_userfaultfd_ctx *);
+ extern void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx *,
+ 					unsigned long from, unsigned long to,
+ 					unsigned long len);
+ 
+ extern void userfaultfd_remove(struct vm_area_struct *vma,
+ 			       struct vm_area_struct **prev,
+ 			       unsigned long start,
+ 			       unsigned long end);
+ 
+ extern int userfaultfd_unmap_prep(struct vm_area_struct *vma,
+ 				  unsigned long start, unsigned long end,
+ 				  struct list_head *uf);
+ extern void userfaultfd_unmap_complete(struct mm_struct *mm,
+ 				       struct list_head *uf);
+ 
+ extern void userfaultfd_exit(struct mm_struct *mm);
+ 
++>>>>>>> ca49ca711455 (userfaultfd: non-cooperative: add event for exit() notification)
  #else /* CONFIG_USERFAULTFD */
  
  /* mm helpers */
@@@ -80,6 -98,51 +105,54 @@@ static inline bool userfaultfd_armed(st
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int dup_userfaultfd(struct vm_area_struct *vma,
+ 				  struct list_head *l)
+ {
+ 	return 0;
+ }
+ 
+ static inline void dup_userfaultfd_complete(struct list_head *l)
+ {
+ }
+ 
+ static inline void mremap_userfaultfd_prep(struct vm_area_struct *vma,
+ 					   struct vm_userfaultfd_ctx *ctx)
+ {
+ }
+ 
+ static inline void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx *ctx,
+ 					       unsigned long from,
+ 					       unsigned long to,
+ 					       unsigned long len)
+ {
+ }
+ 
+ static inline void userfaultfd_remove(struct vm_area_struct *vma,
+ 				      struct vm_area_struct **prev,
+ 				      unsigned long start,
+ 				      unsigned long end)
+ {
+ }
+ 
+ static inline int userfaultfd_unmap_prep(struct vm_area_struct *vma,
+ 					 unsigned long start, unsigned long end,
+ 					 struct list_head *uf)
+ {
+ 	return 0;
+ }
+ 
+ static inline void userfaultfd_unmap_complete(struct mm_struct *mm,
+ 					      struct list_head *uf)
+ {
+ }
+ 
+ static inline void userfaultfd_exit(struct mm_struct *mm)
+ {
+ }
+ 
++>>>>>>> ca49ca711455 (userfaultfd: non-cooperative: add event for exit() notification)
  #endif /* CONFIG_USERFAULTFD */
  
  #endif /* _LINUX_USERFAULTFD_K_H */
diff --cc include/uapi/linux/userfaultfd.h
index abfce32281cc,c055947c5c98..000000000000
--- a/include/uapi/linux/userfaultfd.h
+++ b/include/uapi/linux/userfaultfd.h
@@@ -18,12 -18,13 +18,22 @@@
   * means the userland is reading).
   */
  #define UFFD_API ((__u64)0xAA)
++<<<<<<< HEAD
 +/*
 + * After implementing the respective features it will become:
 + * #define UFFD_API_FEATURES (UFFD_FEATURE_PAGEFAULT_FLAG_WP | \
 + *			      UFFD_FEATURE_EVENT_FORK)
 + */
 +#define UFFD_API_FEATURES (0)
++=======
+ #define UFFD_API_FEATURES (UFFD_FEATURE_EVENT_EXIT |		\
+ 			   UFFD_FEATURE_EVENT_FORK |		\
+ 			   UFFD_FEATURE_EVENT_REMAP |		\
+ 			   UFFD_FEATURE_EVENT_REMOVE |	\
+ 			   UFFD_FEATURE_EVENT_UNMAP |		\
+ 			   UFFD_FEATURE_MISSING_HUGETLBFS |	\
+ 			   UFFD_FEATURE_MISSING_SHMEM)
++>>>>>>> ca49ca711455 (userfaultfd: non-cooperative: add event for exit() notification)
  #define UFFD_API_IOCTLS				\
  	((__u64)1 << _UFFDIO_REGISTER |		\
  	 (__u64)1 << _UFFDIO_UNREGISTER |	\
@@@ -93,9 -109,11 +103,16 @@@ struct uffd_msg 
   * Start at 0x12 and not at 0 to be more strict against bugs.
   */
  #define UFFD_EVENT_PAGEFAULT	0x12
 +#if 0 /* not available yet */
  #define UFFD_EVENT_FORK		0x13
++<<<<<<< HEAD
 +#endif
++=======
+ #define UFFD_EVENT_REMAP	0x14
+ #define UFFD_EVENT_REMOVE	0x15
+ #define UFFD_EVENT_UNMAP	0x16
+ #define UFFD_EVENT_EXIT		0x17
++>>>>>>> ca49ca711455 (userfaultfd: non-cooperative: add event for exit() notification)
  
  /* flags for UFFD_EVENT_PAGEFAULT */
  #define UFFD_PAGEFAULT_FLAG_WRITE	(1<<0)	/* If this was a write fault */
@@@ -113,11 -131,39 +130,20 @@@ struct uffdio_api 
  	 * Note: UFFD_EVENT_PAGEFAULT and UFFD_PAGEFAULT_FLAG_WRITE
  	 * are to be considered implicitly always enabled in all kernels as
  	 * long as the uffdio_api.api requested matches UFFD_API.
 -	 *
 -	 * UFFD_FEATURE_MISSING_HUGETLBFS means an UFFDIO_REGISTER
 -	 * with UFFDIO_REGISTER_MODE_MISSING mode will succeed on
 -	 * hugetlbfs virtual memory ranges. Adding or not adding
 -	 * UFFD_FEATURE_MISSING_HUGETLBFS to uffdio_api.features has
 -	 * no real functional effect after UFFDIO_API returns, but
 -	 * it's only useful for an initial feature set probe at
 -	 * UFFDIO_API time. There are two ways to use it:
 -	 *
 -	 * 1) by adding UFFD_FEATURE_MISSING_HUGETLBFS to the
 -	 *    uffdio_api.features before calling UFFDIO_API, an error
 -	 *    will be returned by UFFDIO_API on a kernel without
 -	 *    hugetlbfs missing support
 -	 *
 -	 * 2) the UFFD_FEATURE_MISSING_HUGETLBFS can not be added in
 -	 *    uffdio_api.features and instead it will be set by the
 -	 *    kernel in the uffdio_api.features if the kernel supports
 -	 *    it, so userland can later check if the feature flag is
 -	 *    present in uffdio_api.features after UFFDIO_API
 -	 *    succeeded.
 -	 *
 -	 * UFFD_FEATURE_MISSING_SHMEM works the same as
 -	 * UFFD_FEATURE_MISSING_HUGETLBFS, but it applies to shmem
 -	 * (i.e. tmpfs and other shmem based APIs).
  	 */
 +#if 0 /* not available yet */
  #define UFFD_FEATURE_PAGEFAULT_FLAG_WP		(1<<0)
  #define UFFD_FEATURE_EVENT_FORK			(1<<1)
++<<<<<<< HEAD
 +#endif
++=======
+ #define UFFD_FEATURE_EVENT_REMAP		(1<<2)
+ #define UFFD_FEATURE_EVENT_REMOVE		(1<<3)
+ #define UFFD_FEATURE_MISSING_HUGETLBFS		(1<<4)
+ #define UFFD_FEATURE_MISSING_SHMEM		(1<<5)
+ #define UFFD_FEATURE_EVENT_UNMAP		(1<<6)
+ #define UFFD_FEATURE_EVENT_EXIT			(1<<7)
++>>>>>>> ca49ca711455 (userfaultfd: non-cooperative: add event for exit() notification)
  	__u64 features;
  
  	__u64 ioctls;
* Unmerged path fs/userfaultfd.c
* Unmerged path include/linux/userfaultfd_k.h
* Unmerged path include/uapi/linux/userfaultfd.h
diff --git a/kernel/exit.c b/kernel/exit.c
index a077150a21be..777fd6dd740e 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -46,6 +46,7 @@
 #include <linux/task_io_accounting_ops.h>
 #include <linux/tracehook.h>
 #include <linux/fs_struct.h>
+#include <linux/userfaultfd_k.h>
 #include <linux/init_task.h>
 #include <linux/perf_event.h>
 #include <trace/events/sched.h>
@@ -502,6 +503,7 @@ static void exit_mm(struct task_struct * tsk)
 	enter_lazy_tlb(mm, current);
 	task_unlock(tsk);
 	mm_update_next_owner(mm);
+	userfaultfd_exit(mm);
 	mmput(mm);
 }
 
