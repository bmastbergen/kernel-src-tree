pnfs: only tear down lsegs that precede seqid in LAYOUTRETURN args

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jeff Layton <jlayton@poochiereds.net>
commit 6d597e1750126a2c6fd99e4b2cc176955bb9972e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6d597e17.failed

LAYOUTRETURN is "special" in that servers and clients are expected to
work with old stateids. When the client sends a LAYOUTRETURN with an old
stateid in it then the server is expected to only tear down layout
segments that were present when that seqid was current. Ensure that the
client handles its accounting accordingly.

	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 6d597e1750126a2c6fd99e4b2cc176955bb9972e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
#	fs/nfs/pnfs.h
diff --cc fs/nfs/pnfs.c
index fd03bf04b6ba,21ff53fe7a9e..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -528,7 -549,8 +549,12 @@@ static bool pnfs_seqid_is_newer(u32 s1
  int
  pnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,
  			    struct list_head *tmp_list,
++<<<<<<< HEAD
 +			    struct pnfs_layout_range *recall_range)
++=======
+ 			    const struct pnfs_layout_range *recall_range,
+ 			    u32 seq)
++>>>>>>> 6d597e175012 (pnfs: only tear down lsegs that precede seqid in LAYOUTRETURN args)
  {
  	struct pnfs_layout_segment *lseg, *next;
  	int remaining = 0;
@@@ -1744,12 -1763,38 +1763,17 @@@ out_forget_reply
  	goto out;
  }
  
 -static void
 -pnfs_set_plh_return_info(struct pnfs_layout_hdr *lo, enum pnfs_iomode iomode,
 -			 u32 seq)
 -{
 -	if (lo->plh_return_iomode == iomode)
 -		return;
 -	if (lo->plh_return_iomode != 0)
 -		iomode = IOMODE_ANY;
 -	lo->plh_return_iomode = iomode;
 -	set_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags);
 -	if (!lo->plh_return_seq || pnfs_seqid_is_newer(seq, lo->plh_return_seq))
 -		lo->plh_return_seq = seq;
 -}
 -
 -/**
 - * pnfs_mark_matching_lsegs_return - Free or return matching layout segments
 - * @lo: pointer to layout header
 - * @tmp_list: list header to be used with pnfs_free_lseg_list()
 - * @return_range: describe layout segment ranges to be returned
 - *
 - * This function is mainly intended for use by layoutrecall. It attempts
 - * to free the layout segment immediately, or else to mark it for return
 - * as soon as its reference count drops to zero.
 - */
 -int
 +void
  pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
  				struct list_head *tmp_list,
++<<<<<<< HEAD
 +				struct pnfs_layout_range *return_range)
++=======
+ 				const struct pnfs_layout_range *return_range,
+ 				u32 seq)
++>>>>>>> 6d597e175012 (pnfs: only tear down lsegs that precede seqid in LAYOUTRETURN args)
  {
  	struct pnfs_layout_segment *lseg, *next;
 -	int remaining = 0;
  
  	dprintk("%s:Begin lo %p\n", __func__, lo);
  
@@@ -1765,11 -1810,16 +1789,20 @@@
  				lseg, lseg->pls_range.iomode,
  				lseg->pls_range.offset,
  				lseg->pls_range.length);
 -			if (mark_lseg_invalid(lseg, tmp_list))
 -				continue;
 -			remaining++;
  			set_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);
++<<<<<<< HEAD
 +			mark_lseg_invalid(lseg, tmp_list);
 +			set_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,
 +					&lo->plh_flags);
 +		}
++=======
+ 		}
+ 
+ 	if (remaining)
+ 		pnfs_set_plh_return_info(lo, return_range->iomode, seq);
+ 
+ 	return remaining;
++>>>>>>> 6d597e175012 (pnfs: only tear down lsegs that precede seqid in LAYOUTRETURN args)
  }
  
  void pnfs_error_mark_layout_for_return(struct inode *inode,
@@@ -1793,8 -1841,20 +1826,25 @@@
  	 * segments at hand when sending layoutreturn. See pnfs_put_lseg()
  	 * for how it works.
  	 */
++<<<<<<< HEAD
 +	pnfs_mark_matching_lsegs_return(lo, &free_me, &range);
 +	spin_unlock(&inode->i_lock);
++=======
+ 	if (!pnfs_mark_matching_lsegs_return(lo, &free_me,
+ 						&range, lseg->pls_seq)) {
+ 		nfs4_stateid stateid;
+ 		enum pnfs_iomode iomode = lo->plh_return_iomode;
+ 
+ 		nfs4_stateid_copy(&stateid, &lo->plh_stateid);
+ 		return_now = pnfs_prepare_layoutreturn(lo);
+ 		spin_unlock(&inode->i_lock);
+ 		if (return_now)
+ 			pnfs_send_layoutreturn(lo, &stateid, iomode, false);
+ 	} else {
+ 		spin_unlock(&inode->i_lock);
+ 		nfs_commit_inode(inode, 0);
+ 	}
++>>>>>>> 6d597e175012 (pnfs: only tear down lsegs that precede seqid in LAYOUTRETURN args)
  	pnfs_free_lseg_list(&free_me);
  }
  EXPORT_SYMBOL_GPL(pnfs_error_mark_layout_for_return);
diff --cc fs/nfs/pnfs.h
index dbdd40fae50e,971068b58647..000000000000
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@@ -265,10 -266,12 +265,19 @@@ int pnfs_choose_layoutget_stateid(nfs4_
  				  struct nfs4_state *open_state);
  int pnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,
  				struct list_head *tmp_list,
++<<<<<<< HEAD
 +				struct pnfs_layout_range *recall_range);
 +void pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
 +				struct list_head *tmp_list,
 +				struct pnfs_layout_range *recall_range);
++=======
+ 				const struct pnfs_layout_range *recall_range,
+ 				u32 seq);
+ int pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
+ 				struct list_head *tmp_list,
+ 				const struct pnfs_layout_range *recall_range,
+ 				u32 seq);
++>>>>>>> 6d597e175012 (pnfs: only tear down lsegs that precede seqid in LAYOUTRETURN args)
  bool pnfs_roc(struct inode *ino);
  void pnfs_roc_release(struct inode *ino);
  void pnfs_roc_set_barrier(struct inode *ino, u32 barrier);
diff --git a/fs/nfs/callback_proc.c b/fs/nfs/callback_proc.c
index 4dc2a0214dc2..50ce56a2e8d4 100644
--- a/fs/nfs/callback_proc.c
+++ b/fs/nfs/callback_proc.c
@@ -217,7 +217,8 @@ static u32 initiate_file_draining(struct nfs_client *clp,
 	}
 
 	if (pnfs_mark_matching_lsegs_return(lo, &free_me_list,
-					&args->cbl_range)) {
+				&args->cbl_range,
+				be32_to_cpu(args->cbl_stateid.seqid))) {
 		rv = NFS4_OK;
 		goto unlock;
 	}
diff --git a/fs/nfs/nfs42proc.c b/fs/nfs/nfs42proc.c
index 0e396a18ce21..cbd78487db62 100644
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@ -231,7 +231,7 @@ nfs42_layoutstat_done(struct rpc_task *task, void *calldata)
 			 * with the current stateid.
 			 */
 			set_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);
-			pnfs_mark_matching_lsegs_invalid(lo, &head, NULL);
+			pnfs_mark_matching_lsegs_invalid(lo, &head, NULL, 0);
 			spin_unlock(&inode->i_lock);
 			pnfs_free_lseg_list(&head);
 		} else
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 761fc7d53e27..cc89f479346b 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -8076,7 +8076,7 @@ static void nfs4_layoutget_done(struct rpc_task *task, void *calldata)
 			 * with the current stateid.
 			 */
 			set_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);
-			pnfs_mark_matching_lsegs_invalid(lo, &head, NULL);
+			pnfs_mark_matching_lsegs_invalid(lo, &head, NULL, 0);
 			spin_unlock(&inode->i_lock);
 			pnfs_free_lseg_list(&head);
 		} else
@@ -8268,7 +8268,8 @@ static void nfs4_layoutreturn_release(void *calldata)
 
 	dprintk("--> %s\n", __func__);
 	spin_lock(&lo->plh_inode->i_lock);
-	pnfs_mark_matching_lsegs_invalid(lo, &freeme, &lrp->args.range);
+	pnfs_mark_matching_lsegs_invalid(lo, &freeme, &lrp->args.range,
+			be32_to_cpu(lrp->args.stateid.seqid));
 	pnfs_mark_layout_returned_if_empty(lo);
 	if (lrp->res.lrs_present)
 		pnfs_set_layout_stateid(lo, &lrp->res.stateid, true);
* Unmerged path fs/nfs/pnfs.c
* Unmerged path fs/nfs/pnfs.h
