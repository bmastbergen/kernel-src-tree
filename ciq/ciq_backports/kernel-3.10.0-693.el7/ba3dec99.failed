tools/power turbostat: Gracefully handle ACPI S3

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: Gracefully handle ACPI S3 (Prarit Bhargava) [1422076]
Rebuild_FUZZ: 93.33%
commit-author Len Brown <len.brown@intel.com>
commit ba3dec99fc99fbe5a08d6c37f06feeb4d4bcb921
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ba3dec99.failed

turbostat gives valid results across suspend to idle, aka freeze,
whether invoked in  interval mode, or in command mode.
Indeed, this can be used to measure suspend to idle:

turbostat echo freeze > /sys/power/state

But this does not work across suspend to ACPI S3, because the
processor counters, including the TSC, are reset on resume.
Further, when turbostat detects a problem, it does't forgive
the hardware, and interval mode will print *'s from there on out.

Instead, upon detecting counters going backwards, simply
reset and start over.

Interval mode across ACPI S3: (observe TSC going backwards)

root@sharkbay:/home/lenb/turbostat-src# ./turbostat -M 0x10
     CPU Avg_MHz   Busy% Bzy_MHz TSC_MHz           MSR 0x010
       -       1    0.06     858    2294  0x0000000000000000
       0       0    0.06     847    2294  0x0000002a254b98ac
       1       1    0.06     878    2294  0x0000002a254efa3a
       2       1    0.07     843    2294  0x0000002a2551df65
       3       0    0.05     863    2294  0x0000002a2553fea2
turbostat: re-initialized with num_cpus 4
     CPU Avg_MHz   Busy% Bzy_MHz TSC_MHz           MSR 0x010
       -       2    0.20     849    2294  0x0000000000000000
       0       2    0.26     856    2294  0x0000000449abb60d
       1       2    0.20     844    2294  0x0000000449b087ec
       2       2    0.21     850    2294  0x0000000449b35d5d
       3       1    0.12     839    2294  0x0000000449b5fd5a
^C

Command mode across ACPI S3:
root@sharkbay:/home/lenb/turbostat-src# ./turbostat -M 0x10 sleep 10
./turbostat: Counter reset detected
14.196299 sec

	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit ba3dec99fc99fbe5a08d6c37f06feeb4d4bcb921)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index 92e6f5e6c99d,c0dade0c1921..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -502,13 -542,9 +499,19 @@@ int format_counters(struct thread_data 
  		outp += sprintf(outp, "%8.0f",
  			1.0 / units * t->aperf / interval_float);
  
++<<<<<<< HEAD
 +	/* %Busy */
 +	if (has_aperf) {
 +		if (!skip_c0)
 +			outp += sprintf(outp, "%8.2f", 100.0 * t->mperf/t->tsc/tsc_tweak);
 +		else
 +			outp += sprintf(outp, "********");
 +	}
++=======
+ 	/* Busy% */
+ 	if (has_aperf)
+ 		outp += sprintf(outp, "%8.2f", 100.0 * t->mperf/t->tsc/tsc_tweak);
++>>>>>>> ba3dec99fc99 (tools/power turbostat: Gracefully handle ACPI S3)
  
  	/* Bzy_MHz */
  	if (has_aperf) {
@@@ -570,6 -609,20 +569,23 @@@
  	if (do_ptm)
  		outp += sprintf(outp, "%8d", p->pkg_temp_c);
  
++<<<<<<< HEAD
++=======
+ 	/* GFXrc6 */
+ 	if (do_gfx_rc6_ms) {
+ 		if (p->gfx_rc6_ms == -1) {	/* detect GFX counter reset */
+ 			outp += sprintf(outp, "   **.**");
+ 		} else {
+ 			outp += sprintf(outp, "%8.2f",
+ 				p->gfx_rc6_ms / 10.0 / interval_float);
+ 		}
+ 	}
+ 
+ 	/* GFXMHz */
+ 	if (do_gfx_mhz)
+ 		outp += sprintf(outp, "%8d", p->gfx_mhz);
+ 
++>>>>>>> ba3dec99fc99 (tools/power turbostat: Gracefully handle ACPI S3)
  	/* Totl%C0, Any%C0 GFX%C0 CPUGFX% */
  	if (do_skl_residency) {
  		outp += sprintf(outp, "%8.2f", 100.0 * p->pkg_wtd_core_c0/t->tsc);
@@@ -736,20 -808,7 +754,24 @@@ delta_thread(struct thread_data *new, s
  			old->aperf = new->aperf - old->aperf;
  			old->mperf = new->mperf - old->mperf;
  		} else {
++<<<<<<< HEAD
 +
 +			if (!aperf_mperf_unstable) {
 +				fprintf(stderr, "%s: APERF or MPERF went backwards *\n", progname);
 +				fprintf(stderr, "* Frequency results do not cover entire interval *\n");
 +				fprintf(stderr, "* fix this by running Linux-2.6.30 or later *\n");
 +
 +				aperf_mperf_unstable = 1;
 +			}
 +			/*
 +			 * mperf delta is likely a huge "positive" number
 +			 * can not use it for calculating c0 time
 +			 */
 +			skip_c0 = 1;
 +			skip_c1 = 1;
++=======
+ 			return -1;
++>>>>>>> ba3dec99fc99 (tools/power turbostat: Gracefully handle ACPI S3)
  		}
  	}
  
@@@ -790,8 -850,13 +812,10 @@@
  	old->extra_msr32 = new->extra_msr32;
  	old->extra_msr64 = new->extra_msr64;
  
 -	if (do_irq)
 -		old->irq_count = new->irq_count - old->irq_count;
 -
  	if (do_smi)
  		old->smi_count = new->smi_count - old->smi_count;
+ 
+ 	return 0;
  }
  
  int delta_cpu(struct thread_data *t, struct core_data *c,
@@@ -1724,11 -2051,16 +1752,14 @@@ restart
  		}
  		gettimeofday(&tv_odd, (struct timezone *)NULL);
  		timersub(&tv_odd, &tv_even, &tv_delta);
- 		for_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS);
+ 		if (for_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS)) {
+ 			re_initialize();
+ 			goto restart;
+ 		}
  		compute_average(EVEN_COUNTERS);
  		format_all_counters(EVEN_COUNTERS);
 -		flush_output_stdout();
 +		flush_stdout();
  		nanosleep(&interval_ts, NULL);
 -		if (snapshot_proc_sysfs_files())
 -			goto restart;
  		retval = for_all_cpus(get_counters, EVEN_COUNTERS);
  		if (retval < -1) {
  			exit(retval);
@@@ -1738,10 -2070,13 +1769,13 @@@
  		}
  		gettimeofday(&tv_even, (struct timezone *)NULL);
  		timersub(&tv_even, &tv_odd, &tv_delta);
- 		for_all_cpus_2(delta_cpu, EVEN_COUNTERS, ODD_COUNTERS);
+ 		if (for_all_cpus_2(delta_cpu, EVEN_COUNTERS, ODD_COUNTERS)) {
+ 			re_initialize();
+ 			goto restart;
+ 		}
  		compute_average(ODD_COUNTERS);
  		format_all_counters(ODD_COUNTERS);
 -		flush_output_stdout();
 +		flush_stdout();
  	}
  }
  
@@@ -3152,12 -3683,16 +3186,21 @@@ int fork_it(char **argv
  	for_all_cpus(get_counters, ODD_COUNTERS);
  	gettimeofday(&tv_odd, (struct timezone *)NULL);
  	timersub(&tv_odd, &tv_even, &tv_delta);
++<<<<<<< HEAD
 +	for_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS);
 +	compute_average(EVEN_COUNTERS);
 +	format_all_counters(EVEN_COUNTERS);
 +	flush_stderr();
++=======
+ 	if (for_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS))
+ 		fprintf(outf, "%s: Counter reset detected\n", progname);
+ 	else {
+ 		compute_average(EVEN_COUNTERS);
+ 		format_all_counters(EVEN_COUNTERS);
+ 	}
++>>>>>>> ba3dec99fc99 (tools/power turbostat: Gracefully handle ACPI S3)
  
 -	fprintf(outf, "%.6f sec\n", tv_delta.tv_sec + tv_delta.tv_usec/1000000.0);
 -
 -	flush_output_stderr();
 +	fprintf(stderr, "%.6f sec\n", tv_delta.tv_sec + tv_delta.tv_usec/1000000.0);
  
  	return status;
  }
@@@ -3180,7 -3715,7 +3223,11 @@@ int get_and_dump_counters(void
  }
  
  void print_version() {
++<<<<<<< HEAD
 +	fprintf(stderr, "turbostat version 4.12 5 Apr 2016"
++=======
+ 	fprintf(outf, "turbostat version 4.13 22 Apr 2016"
++>>>>>>> ba3dec99fc99 (tools/power turbostat: Gracefully handle ACPI S3)
  		" - Len Brown <lenb@kernel.org>\n");
  }
  
* Unmerged path tools/power/x86/turbostat/turbostat.c
