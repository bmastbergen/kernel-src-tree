HID: wacom: Handle failing HID_DG_CONTACTMAX requests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Handle failing HID_DG_CONTACTMAX requests (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.05%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 05e8fd9202247ac6cdc26f6bafb5453120065490
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/05e8fd92.failed

Hardware may not respond to a request for the HID_DG_CONTACTMAX feature and
we should be tolerant of such a failure. This is especially true when using
hid-replay where the hardware doesn't exist, but also for devices attached
to a flaky bus. This patch increases the number of allowable retries to
match other calls to 'wacom_get_report' and also provides a fallback which
forces 'touch_max = 16' (enough for any Wacom device seen so far).

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 05e8fd9202247ac6cdc26f6bafb5453120065490)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,eea18a6cbdc7..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -172,92 -91,63 +172,124 @@@ static void wacom_close(struct input_de
  }
  
  /*
 - * Calculate the resolution of the X or Y axis using hidinput_calc_abs_res.
 + * Calculate the resolution of the X or Y axis, given appropriate HID data.
 + * This function is little more than hidinput_calc_abs_res stripped down.
   */
  static int wacom_calc_hid_res(int logical_extents, int physical_extents,
 -			       unsigned unit, int exponent)
 +                              unsigned char unit, unsigned char exponent)
  {
 -	struct hid_field field = {
 -		.logical_maximum = logical_extents,
 -		.physical_maximum = physical_extents,
 -		.unit = unit,
 -		.unit_exponent = exponent,
 -	};
 -
 -	return hidinput_calc_abs_res(&field, ABS_X);
 +	int prev, unit_exponent;
 +
 +	/* Check if the extents are sane */
 +	if (logical_extents <= 0 || physical_extents <= 0)
 +		return 0;
 +
 +	/* Get signed value of nybble-sized twos-compliment exponent */
 +	unit_exponent = exponent;
 +	if (unit_exponent > 7)
 +		unit_exponent -= 16;
 +
 +	/* Convert physical_extents to millimeters */
 +	if (unit == 0x11) {		/* If centimeters */
 +		unit_exponent += 1;
 +	} else if (unit == 0x13) {	/* If inches */
 +		prev = physical_extents;
 +		physical_extents *= 254;
 +		if (physical_extents < prev)
 +			return 0;
 +		unit_exponent -= 1;
 +	} else {
 +		return 0;
 +	}
 +
 +	/* Apply negative unit exponent */
 +	for (; unit_exponent < 0; unit_exponent++) {
 +		prev = logical_extents;
 +		logical_extents *= 10;
 +		if (logical_extents < prev)
 +			return 0;
 +	}
 +	/* Apply positive unit exponent */
 +	for (; unit_exponent > 0; unit_exponent--) {
 +		prev = physical_extents;
 +		physical_extents *= 10;
 +		if (physical_extents < prev)
 +			return 0;
 +	}
 +
 +	/* Calculate resolution */
 +	return logical_extents / physical_extents;
  }
  
 -static void wacom_feature_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage)
 +static int wacom_parse_logical_collection(unsigned char *report,
 +					  struct wacom_features *features)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_features *features = &wacom->wacom_wac.features;
 -	struct hid_data *hid_data = &wacom->wacom_wac.hid_data;
 -	u8 *data;
 -	int ret;
 +	int length = 0;
  
++<<<<<<< HEAD
 +	if (features->type == BAMBOO_PT) {
++=======
+ 	switch (usage->hid) {
+ 	case HID_DG_CONTACTMAX:
+ 		/* leave touch_max as is if predefined */
+ 		if (!features->touch_max) {
+ 			/* read manually */
+ 			data = kzalloc(2, GFP_KERNEL);
+ 			if (!data)
+ 				break;
+ 			data[0] = field->report->id;
+ 			ret = wacom_get_report(hdev, HID_FEATURE_REPORT,
+ 						data, 2, WAC_CMD_RETRIES);
+ 			if (ret == 2) {
+ 				features->touch_max = data[1];
+ 			} else {
+ 				features->touch_max = 16;
+ 				hid_warn(hdev, "wacom_feature_mapping: "
+ 					 "could not get HID_DG_CONTACTMAX, "
+ 					 "defaulting to %d\n",
+ 					  features->touch_max);
+ 			}
+ 			kfree(data);
+ 		}
+ 		break;
+ 	case HID_DG_INPUTMODE:
+ 		/* Ignore if value index is out of bounds. */
+ 		if (usage->usage_index >= field->report_count) {
+ 			dev_err(&hdev->dev, "HID_DG_INPUTMODE out of range\n");
+ 			break;
+ 		}
++>>>>>>> 05e8fd920224 (HID: wacom: Handle failing HID_DG_CONTACTMAX requests)
  
 -		hid_data->inputmode = field->report->id;
 -		hid_data->inputmode_index = usage->usage_index;
 -		break;
 +		/* Logical collection is only used by 3rd gen Bamboo Touch */
 +		features->pktlen = WACOM_PKGLEN_BBTOUCH3;
 +		features->device_type = BTN_TOOL_FINGER;
 +
 +		features->x_max = features->y_max =
 +			get_unaligned_le16(&report[10]);
 +
 +		length = 11;
 +	}
 +	return length;
 +}
 +
 +static void wacom_retrieve_report_data(struct usb_interface *intf,
 +				       struct wacom_features *features)
 +{
 +	int result = 0;
 +	unsigned char *rep_data;
 +
 +	rep_data = kmalloc(2, GFP_KERNEL);
 +	if (rep_data) {
 +
 +		rep_data[0] = 12;
 +		result = wacom_get_report(intf, WAC_HID_FEATURE_REPORT,
 +					  rep_data[0], rep_data, 2,
 +					  WAC_MSG_RETRIES);
 +
 +		if (result >= 0 && rep_data[1] > 2)
 +			features->touch_max = rep_data[1];
 +
 +		kfree(rep_data);
  	}
  }
  
* Unmerged path drivers/hid/wacom_sys.c
