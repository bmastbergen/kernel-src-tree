KVM: MTRR: sort variable MTRRs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Xiao Guangrong <guangrong.xiao@linux.intel.com>
commit 19efffa244071ccd0385b240d03adb38feaab04e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/19efffa2.failed

Sort all valid variable MTRRs based on its base address, it will help us to
check a range to see if it's fully contained in variable MTRRs

	Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
[Fix list insertion sort, simplify var_mtrr_range_is_valid to just
 test the V bit. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 19efffa244071ccd0385b240d03adb38feaab04e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/mtrr.c
#	arch/x86/kvm/x86.c
#	arch/x86/kvm/x86.h
diff --cc arch/x86/include/asm/kvm_host.h
index 38430109c621,f2d60cce7595..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -357,9 -342,18 +357,24 @@@ enum 
  	KVM_DEBUGREG_RELOAD = 4,
  };
  
++<<<<<<< HEAD
 +/* Hyper-V per vcpu emulation context */
 +struct kvm_vcpu_hv {
 +	u64 hv_vapic;
++=======
+ struct kvm_mtrr_range {
+ 	u64 base;
+ 	u64 mask;
+ 	struct list_head node;
+ };
+ 
+ struct kvm_mtrr {
+ 	struct kvm_mtrr_range var_ranges[KVM_NR_VAR_MTRR];
+ 	mtrr_type fixed_ranges[KVM_NR_FIXED_MTRR_REGION];
+ 	u64 deftype;
+ 
+ 	struct list_head head;
++>>>>>>> 19efffa24407 (KVM: MTRR: sort variable MTRRs)
  };
  
  struct kvm_vcpu_arch {
diff --cc arch/x86/kvm/x86.c
index 5adefe6db615,6574fa36cb65..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -7541,7 -7379,7 +7541,11 @@@ int kvm_arch_vcpu_setup(struct kvm_vcp
  {
  	int r;
  
++<<<<<<< HEAD
 +	vcpu->arch.mtrr_state.have_fixed = 1;
++=======
+ 	kvm_vcpu_mtrr_init(vcpu);
++>>>>>>> 19efffa24407 (KVM: MTRR: sort variable MTRRs)
  	r = vcpu_load(vcpu);
  	if (r)
  		return r;
diff --cc arch/x86/kvm/x86.h
index c4ca2474e8c0,0e4727c49279..000000000000
--- a/arch/x86/kvm/x86.h
+++ b/arch/x86/kvm/x86.h
@@@ -171,8 -162,11 +171,13 @@@ int kvm_write_guest_virt_system(struct 
  	gva_t addr, void *val, unsigned int bytes,
  	struct x86_exception *exception);
  
++<<<<<<< HEAD
++=======
+ void kvm_vcpu_mtrr_init(struct kvm_vcpu *vcpu);
+ u8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn);
++>>>>>>> 19efffa24407 (KVM: MTRR: sort variable MTRRs)
  bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data);
 -int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data);
 -int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata);
 +bool kvm_vector_hashing_enabled(void);
  
  #define KVM_SUPPORTED_XCR0     (XSTATE_FP | XSTATE_SSE | XSTATE_YMM \
  				| XSTATE_BNDREGS | XSTATE_BNDCSR \
* Unmerged path arch/x86/kvm/mtrr.c
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/mtrr.c
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path arch/x86/kvm/x86.h
