IB/mlx5: LAG QP load balancing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Aviv Heller <avivh@mellanox.com>
commit 13eab21f92de21f324fd6afe1aeca310446b8731
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/13eab21f.failed

When LAG is active, QP tx affinity (the physical port
to which a QP is affined, or the TIS in case of raw-eth)
is set in a round robin fashion during state transition
from RESET to INIT.

	Signed-off-by: Aviv Heller <avivh@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 13eab21f92de21f324fd6afe1aeca310446b8731)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 5360ba421477,2ec88c649ac0..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -1825,7 -1873,8 +1825,12 @@@ static void get_cqs(struct mlx5_ib_qp *
  }
  
  static int modify_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,
++<<<<<<< HEAD
 +				u16 operation);
++=======
+ 				const struct mlx5_modify_raw_qp_param *raw_qp_param,
+ 				u8 lag_tx_affinity);
++>>>>>>> 13eab21f92de (IB/mlx5: LAG QP load balancing)
  
  static void destroy_qp_common(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)
  {
@@@ -1851,11 -1896,14 +1856,19 @@@
  		if (qp->ibqp.qp_type != IB_QPT_RAW_PACKET) {
  			mlx5_ib_qp_disable_pagefaults(qp);
  			err = mlx5_core_qp_modify(dev->mdev,
 -						  MLX5_CMD_OP_2RST_QP, 0,
 -						  NULL, &base->mqp);
 +						  MLX5_CMD_OP_2RST_QP, in, 0,
 +						  &base->mqp);
  		} else {
++<<<<<<< HEAD
 +			err = modify_raw_packet_qp(dev, qp,
 +						   MLX5_CMD_OP_2RST_QP);
++=======
+ 			struct mlx5_modify_raw_qp_param raw_qp_param = {
+ 				.operation = MLX5_CMD_OP_2RST_QP
+ 			};
+ 
+ 			err = modify_raw_packet_qp(dev, qp, &raw_qp_param, 0);
++>>>>>>> 13eab21f92de (IB/mlx5: LAG QP load balancing)
  		}
  		if (err)
  			mlx5_ib_warn(dev, "mlx5_ib: modify QP 0x%06x to RESET failed\n",
@@@ -2379,7 -2472,8 +2417,12 @@@ out
  }
  
  static int modify_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,
++<<<<<<< HEAD
 +				u16 operation)
++=======
+ 				const struct mlx5_modify_raw_qp_param *raw_qp_param,
+ 				u8 tx_affinity)
++>>>>>>> 13eab21f92de (IB/mlx5: LAG QP load balancing)
  {
  	struct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;
  	struct mlx5_ib_rq *rq = &raw_packet_qp->rq;
@@@ -2478,12 -2582,12 +2529,13 @@@ static int __mlx5_ib_modify_qp(struct i
  	int mlx5_st;
  	int err;
  	u16 op;
+ 	u8 tx_affinity = 0;
  
 -	context = kzalloc(sizeof(*context), GFP_KERNEL);
 -	if (!context)
 +	in = kzalloc(sizeof(*in), GFP_KERNEL);
 +	if (!in)
  		return -ENOMEM;
  
 +	context = &in->ctx;
  	err = to_mlx5_st(ibqp->qp_type);
  	if (err < 0) {
  		mlx5_ib_dbg(dev, "unsupported qp type %d\n", ibqp->qp_type);
@@@ -2647,13 -2768,21 +2716,27 @@@
  	op = optab[mlx5_cur][mlx5_new];
  	optpar = ib_mask_to_mlx5_opt(attr_mask);
  	optpar &= opt_mask[mlx5_cur][mlx5_new][mlx5_st];
 +	in->optparam = cpu_to_be32(optpar);
  
++<<<<<<< HEAD
 +	if (qp->ibqp.qp_type == IB_QPT_RAW_PACKET)
 +		err = modify_raw_packet_qp(dev, qp, op);
 +	else
 +		err = mlx5_core_qp_modify(dev->mdev, op, in, sqd_event,
++=======
+ 	if (qp->ibqp.qp_type == IB_QPT_RAW_PACKET) {
+ 		struct mlx5_modify_raw_qp_param raw_qp_param = {};
+ 
+ 		raw_qp_param.operation = op;
+ 		if (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {
+ 			raw_qp_param.rq_q_ctr_id = mibport->q_cnt_id;
+ 			raw_qp_param.set_mask |= MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID;
+ 		}
+ 		err = modify_raw_packet_qp(dev, qp, &raw_qp_param, tx_affinity);
+ 	} else {
+ 		err = mlx5_core_qp_modify(dev->mdev, op, optpar, context,
++>>>>>>> 13eab21f92de (IB/mlx5: LAG QP load balancing)
  					  &base->mqp);
 -	}
 -
  	if (err)
  		goto out;
  
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index 31e9d3e994da..c2c4b0c0222b 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -600,6 +600,7 @@ struct mlx5_roce {
 	rwlock_t		netdev_lock;
 	struct net_device	*netdev;
 	struct notifier_block	nb;
+	atomic_t		next_port;
 };
 
 struct mlx5_ib_dev {
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
