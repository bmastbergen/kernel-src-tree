ipv6: make IPV6_RECVPKTINFO work for ipv4 datagrams

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 4b261c75a99f29c93a0b6babfc180cdf566bd654
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4b261c75.failed

We currently don't report IPV6_RECVPKTINFO in cmsg access ancillary data
for IPv4 datagrams on IPv6 sockets.

This patch splits the ip6_datagram_recv_ctl into two functions, one
which handles both protocol families, AF_INET and AF_INET6, while the
ip6_datagram_recv_specific_ctl only handles IPv6 cmsg data.

ip6_datagram_recv_*_ctl never reported back any errors, so we can make
them return void. Also provide a helper for protocols which don't offer dual
personality to further use ip6_datagram_recv_ctl, which is exported to
modules.

I needed to shuffle the code for ping around a bit to make it easier to
implement dual personality for ping ipv6 sockets in future.

	Reported-by: Gert Doering <gert@space.net>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4b261c75a99f29c93a0b6babfc180cdf566bd654)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ping.h
#	include/net/transp_v6.h
#	net/ipv4/ping.c
#	net/ipv6/ping.c
diff --cc include/net/ping.h
index 682b5ae9af51,026479b61a2d..000000000000
--- a/include/net/ping.h
+++ b/include/net/ping.h
@@@ -28,9 -29,21 +28,27 @@@
   */
  #define GID_T_MAX (((gid_t)~0U) >> 1)
  
++<<<<<<< HEAD
 +struct ping_table {
 +	struct hlist_nulls_head	hash[PING_HTABLE_SIZE];
 +	rwlock_t		lock;
++=======
+ /* Compatibility glue so we can support IPv6 when it's compiled as a module */
+ struct pingv6_ops {
+ 	int (*ipv6_recv_error)(struct sock *sk, struct msghdr *msg, int len,
+ 			       int *addr_len);
+ 	void (*ip6_datagram_recv_common_ctl)(struct sock *sk,
+ 					     struct msghdr *msg,
+ 					     struct sk_buff *skb);
+ 	void (*ip6_datagram_recv_specific_ctl)(struct sock *sk,
+ 					       struct msghdr *msg,
+ 					       struct sk_buff *skb);
+ 	int (*icmpv6_err_convert)(u8 type, u8 code, int *err);
+ 	void (*ipv6_icmp_error)(struct sock *sk, struct sk_buff *skb, int err,
+ 				__be16 port, u32 info, u8 *payload);
+ 	int (*ipv6_chk_addr)(struct net *net, const struct in6_addr *addr,
+ 			     const struct net_device *dev, int strict);
++>>>>>>> 4b261c75a99f (ipv6: make IPV6_RECVPKTINFO work for ipv4 datagrams)
  };
  
  struct ping_iter_state {
diff --cc include/net/transp_v6.h
index f36e870dea57,b927413dde86..000000000000
--- a/include/net/transp_v6.h
+++ b/include/net/transp_v6.h
@@@ -15,57 -13,52 +15,67 @@@ extern struct proto tcpv6_prot
  struct flowi6;
  
  /* extension headers */
 -int ipv6_exthdrs_init(void);
 -void ipv6_exthdrs_exit(void);
 -int ipv6_frag_init(void);
 -void ipv6_frag_exit(void);
 +extern int				ipv6_exthdrs_init(void);
 +extern void				ipv6_exthdrs_exit(void);
 +extern int				ipv6_frag_init(void);
 +extern void				ipv6_frag_exit(void);
  
  /* transport protocols */
 -int pingv6_init(void);
 -void pingv6_exit(void);
 -int rawv6_init(void);
 -void rawv6_exit(void);
 -int udpv6_init(void);
 -void udpv6_exit(void);
 -int udplitev6_init(void);
 -void udplitev6_exit(void);
 -int tcpv6_init(void);
 -void tcpv6_exit(void);
 +extern int				rawv6_init(void);
 +extern void				rawv6_exit(void);
 +extern int				udpv6_init(void);
 +extern void				udpv6_exit(void);
 +extern int 				udplitev6_init(void);
 +extern void 				udplitev6_exit(void);
 +extern int				tcpv6_init(void);
 +extern void				tcpv6_exit(void);
  
 -int udpv6_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 +extern int				udpv6_connect(struct sock *sk,
 +						      struct sockaddr *uaddr,
 +						      int addr_len);
  
++<<<<<<< HEAD
 +extern int			ip6_datagram_recv_ctl(struct sock *sk,
 +						      struct msghdr *msg,
 +						      struct sk_buff *skb);
++=======
+ /* this does all the common and the specific ctl work */
+ void ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,
+ 			   struct sk_buff *skb);
+ void ip6_datagram_recv_common_ctl(struct sock *sk, struct msghdr *msg,
+ 				  struct sk_buff *skb);
+ void ip6_datagram_recv_specific_ctl(struct sock *sk, struct msghdr *msg,
+ 				    struct sk_buff *skb);
++>>>>>>> 4b261c75a99f (ipv6: make IPV6_RECVPKTINFO work for ipv4 datagrams)
  
 -int ip6_datagram_send_ctl(struct net *net, struct sock *sk, struct msghdr *msg,
 -			  struct flowi6 *fl6, struct ipv6_txoptions *opt,
 -			  int *hlimit, int *tclass, int *dontfrag);
 +extern int			ip6_datagram_send_ctl(struct net *net,
 +						      struct sock *sk,
 +						      struct msghdr *msg,
 +						      struct flowi6 *fl6,
 +						      struct ipv6_txoptions *opt,
 +						      int *hlimit, int *tclass,
 +						      int *dontfrag);
  
 -void ip6_dgram_sock_seq_show(struct seq_file *seq, struct sock *sp,
 -			     __u16 srcp, __u16 destp, int bucket);
 +extern void		ip6_dgram_sock_seq_show(struct seq_file *seq,
 +						struct sock *sp,
 +						__u16 srcp,
 +						__u16 destp,
 +						int bucket);
  
 -#define LOOPBACK4_IPV6 cpu_to_be32(0x7f000006)
 +#define		LOOPBACK4_IPV6		cpu_to_be32(0x7f000006)
  
 -/* address family specific functions */
 +/*
 + *	address family specific functions
 + */
  extern const struct inet_connection_sock_af_ops ipv4_specific;
  
 -void inet6_destroy_sock(struct sock *sk);
 +extern void inet6_destroy_sock(struct sock *sk);
  
 -#define IPV6_SEQ_DGRAM_HEADER					       \
 -	"  sl  "						       \
 -	"local_address                         "		       \
 -	"remote_address                        "		       \
 -	"st tx_queue rx_queue tr tm->when retrnsmt"		       \
 -	"   uid  timeout inode ref pointer drops\n"
 +#define IPV6_SEQ_DGRAM_HEADER \
 +			   "  sl  "					\
 +			   "local_address                         "	\
 +			   "remote_address                        "	\
 +			   "st tx_queue rx_queue tr tm->when retrnsmt"	\
 +			   "   uid  timeout inode ref pointer drops\n"
  
  #endif
diff --cc net/ipv4/ping.c
index 291ac786a807,4a9e4266a0c3..000000000000
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@@ -666,18 -871,52 +666,61 @@@ static int ping_recvmsg(struct kiocb *i
  
  	sock_recv_timestamp(msg, sk, skb);
  
 -	/* Copy the address and add cmsg data. */
 -	if (family == AF_INET) {
 -		DECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);
 -
 +	/* Copy the address. */
 +	if (msg->msg_name) {
 +		struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
 +
++<<<<<<< HEAD
 +		sin->sin_family = AF_INET;
 +		sin->sin_port = 0 /* skb->h.uh->source */;
 +		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 +		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
 +		*addr_len = sizeof(*sin);
++=======
+ 		if (sin) {
+ 			sin->sin_family = AF_INET;
+ 			sin->sin_port = 0 /* skb->h.uh->source */;
+ 			sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
+ 			memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+ 			*addr_len = sizeof(*sin);
+ 		}
+ 
+ 		if (isk->cmsg_flags)
+ 			ip_cmsg_recv(msg, skb);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (family == AF_INET6) {
+ 		struct ipv6_pinfo *np = inet6_sk(sk);
+ 		struct ipv6hdr *ip6 = ipv6_hdr(skb);
+ 		DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);
+ 
+ 		if (sin6) {
+ 			sin6->sin6_family = AF_INET6;
+ 			sin6->sin6_port = 0;
+ 			sin6->sin6_addr = ip6->saddr;
+ 			sin6->sin6_flowinfo = 0;
+ 			if (np->sndflow)
+ 				sin6->sin6_flowinfo = ip6_flowinfo(ip6);
+ 			sin6->sin6_scope_id =
+ 				ipv6_iface_scope_id(&sin6->sin6_addr,
+ 						    IP6CB(skb)->iif);
+ 			*addr_len = sizeof(*sin6);
+ 		}
+ 
+ 		if (inet6_sk(sk)->rxopt.all)
+ 			pingv6_ops.ip6_datagram_recv_common_ctl(sk, msg, skb);
+ 		if (skb->protocol == htons(ETH_P_IPV6) &&
+ 		    inet6_sk(sk)->rxopt.all)
+ 			pingv6_ops.ip6_datagram_recv_specific_ctl(sk, msg, skb);
+ 		else if (skb->protocol == htons(ETH_P_IP) && isk->cmsg_flags)
+ 			ip_cmsg_recv(msg, skb);
+ #endif
+ 	} else {
+ 		BUG();
++>>>>>>> 4b261c75a99f (ipv6: make IPV6_RECVPKTINFO work for ipv4 datagrams)
  	}
 -
 +	if (isk->cmsg_flags)
 +		ip_cmsg_recv(msg, skb);
  	err = copied;
  
  done:
* Unmerged path net/ipv6/ping.c
diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h
index bf6b55bb15ef..1d74df2c900e 100644
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -273,6 +273,8 @@ static inline void inet_sk_copy_descendant(struct sock *sk_to,
 
 #define __ipv6_only_sock(sk)	(inet6_sk(sk)->ipv6only)
 #define ipv6_only_sock(sk)	((sk)->sk_family == PF_INET6 && __ipv6_only_sock(sk))
+#define ipv6_sk_rxinfo(sk)	((sk)->sk_family == PF_INET6 && \
+				 inet6_sk(sk)->rxopt.bits.rxinfo)
 
 static inline const struct in6_addr *inet6_rcv_saddr(const struct sock *sk)
 {
@@ -289,6 +291,7 @@ static inline int inet_v6_ipv6only(const struct sock *sk)
 #else
 #define __ipv6_only_sock(sk)	0
 #define ipv6_only_sock(sk)	0
+#define ipv6_sk_rxinfo(sk)	0
 
 static inline struct ipv6_pinfo * inet6_sk(const struct sock *__sk)
 {
diff --git a/include/net/ip.h b/include/net/ip.h
index 5506ed81f7f4..93511e106d4e 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -66,6 +66,7 @@ struct ipcm_cookie {
 };
 
 #define IPCB(skb) ((struct inet_skb_parm*)((skb)->cb))
+#define PKTINFO_SKB_CB(skb) ((struct in_pktinfo *)((skb)->cb))
 
 struct ip_ra_chain {
 	struct ip_ra_chain __rcu *next;
* Unmerged path include/net/ping.h
* Unmerged path include/net/transp_v6.h
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 29d411fe019d..34083ec8f533 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -56,7 +56,6 @@
 /*
  *	SOL_IP control messages.
  */
-#define PKTINFO_SKB_CB(__skb) ((struct in_pktinfo *)((__skb)->cb))
 
 static void ip_cmsg_recv_pktinfo(struct msghdr *msg, struct sk_buff *skb)
 {
@@ -1084,9 +1083,10 @@ e_inval:
 void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)
 {
 	struct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);
+	bool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||
+		       ipv6_sk_rxinfo(sk);
 
-	if ((inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) &&
-	    skb_rtable(skb)) {
+	if (prepare && skb_rtable(skb)) {
 		pktinfo->ipi_ifindex = inet_iif(skb);
 		pktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);
 	} else {
* Unmerged path net/ipv4/ping.c
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index 053beb286c7e..25b5b0a2dbc5 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -427,10 +427,12 @@ int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
 		sin->sin6_family = AF_INET6;
 		sin->sin6_flowinfo = 0;
 		sin->sin6_port = 0;
+		if (np->rxopt.all)
+			ip6_datagram_recv_common_ctl(sk, msg, skb);
 		if (skb->protocol == htons(ETH_P_IPV6)) {
 			sin->sin6_addr = ipv6_hdr(skb)->saddr;
 			if (np->rxopt.all)
-				ip6_datagram_recv_ctl(sk, msg, skb);
+				ip6_datagram_recv_specific_ctl(sk, msg, skb);
 			sin->sin6_scope_id =
 				ipv6_iface_scope_id(&sin->sin6_addr,
 						    IP6CB(skb)->iif);
@@ -522,20 +524,34 @@ out:
 }
 
 
-int ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,
-			  struct sk_buff *skb)
+void ip6_datagram_recv_common_ctl(struct sock *sk, struct msghdr *msg,
+				 struct sk_buff *skb)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
-	struct inet6_skb_parm *opt = IP6CB(skb);
-	unsigned char *nh = skb_network_header(skb);
+	bool is_ipv6 = skb->protocol == htons(ETH_P_IPV6);
 
 	if (np->rxopt.bits.rxinfo) {
 		struct in6_pktinfo src_info;
 
-		src_info.ipi6_ifindex = opt->iif;
-		src_info.ipi6_addr = ipv6_hdr(skb)->daddr;
+		if (is_ipv6) {
+			src_info.ipi6_ifindex = IP6CB(skb)->iif;
+			src_info.ipi6_addr = ipv6_hdr(skb)->daddr;
+		} else {
+			src_info.ipi6_ifindex =
+				PKTINFO_SKB_CB(skb)->ipi_ifindex;
+			ipv6_addr_set_v4mapped(ip_hdr(skb)->daddr,
+					       &src_info.ipi6_addr);
+		}
 		put_cmsg(msg, SOL_IPV6, IPV6_PKTINFO, sizeof(src_info), &src_info);
 	}
+}
+
+void ip6_datagram_recv_specific_ctl(struct sock *sk, struct msghdr *msg,
+				    struct sk_buff *skb)
+{
+	struct ipv6_pinfo *np = inet6_sk(sk);
+	struct inet6_skb_parm *opt = IP6CB(skb);
+	unsigned char *nh = skb_network_header(skb);
 
 	if (np->rxopt.bits.rxhlim) {
 		int hlim = ipv6_hdr(skb)->hop_limit;
@@ -653,7 +669,13 @@ int ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,
 			put_cmsg(msg, SOL_IPV6, IPV6_ORIGDSTADDR, sizeof(sin6), &sin6);
 		}
 	}
-	return 0;
+}
+
+void ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,
+			  struct sk_buff *skb)
+{
+	ip6_datagram_recv_common_ctl(sk, msg, skb);
+	ip6_datagram_recv_specific_ctl(sk, msg, skb);
 }
 EXPORT_SYMBOL_GPL(ip6_datagram_recv_ctl);
 
diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
index 1e9c9fe3e9e8..40f8d4e649a1 100644
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -1034,10 +1034,8 @@ static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,
 		release_sock(sk);
 
 		if (skb) {
-			int err = ip6_datagram_recv_ctl(sk, &msg, skb);
+			ip6_datagram_recv_ctl(sk, &msg, skb);
 			kfree_skb(skb);
-			if (err)
-				return err;
 		} else {
 			if (np->rxopt.bits.rxinfo) {
 				struct in6_pktinfo src_info;
* Unmerged path net/ipv6/ping.c
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index addc33af6bd2..d34b75b631ee 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -494,12 +494,16 @@ try_again:
 		}
 		*addr_len = sizeof(*sin6);
 	}
+
+	if (np->rxopt.all)
+		ip6_datagram_recv_common_ctl(sk, msg, skb);
+
 	if (is_udp4) {
 		if (inet->cmsg_flags)
 			ip_cmsg_recv(msg, skb);
 	} else {
 		if (np->rxopt.all)
-			ip6_datagram_recv_ctl(sk, msg, skb);
+			ip6_datagram_recv_specific_ctl(sk, msg, skb);
 	}
 
 	err = copied;
