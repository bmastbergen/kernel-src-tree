random: replace non-blocking pool with a Chacha20-based CRNG

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit e192be9d9a30555aae2ca1dc3aad37cba484cd4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e192be9d.failed

The CRNG is faster, and we don't pretend to track entropy usage in the
CRNG any more.

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit e192be9d9a30555aae2ca1dc3aad37cba484cd4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/chacha20_generic.c
#	drivers/char/random.c
#	include/crypto/chacha20.h
#	lib/Makefile
diff --cc drivers/char/random.c
index 9e6776a12d13,dc2a9c2d8dcf..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -256,10 -256,12 +256,19 @@@
  #include <linux/fips.h>
  #include <linux/ptrace.h>
  #include <linux/kmemcheck.h>
++<<<<<<< HEAD
 +
 +#ifdef CONFIG_GENERIC_HARDIRQS
 +# include <linux/irq.h>
 +#endif
++=======
+ #include <linux/workqueue.h>
+ #include <linux/irq.h>
+ #include <linux/syscalls.h>
+ #include <linux/completion.h>
+ #include <linux/uuid.h>
+ #include <crypto/chacha20.h>
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  
  #include <asm/processor.h>
  #include <asm/uaccess.h>
@@@ -406,19 -408,37 +415,44 @@@ static struct poolinfo 
   */
  static DECLARE_WAIT_QUEUE_HEAD(random_read_wait);
  static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);
 -static DECLARE_WAIT_QUEUE_HEAD(urandom_init_wait);
  static struct fasync_struct *fasync;
  
 -static DEFINE_SPINLOCK(random_ready_list_lock);
 -static LIST_HEAD(random_ready_list);
 +static bool debug;
 +module_param(debug, bool, 0644);
 +#define DEBUG_ENT(fmt, arg...) do { \
 +	if (debug) \
 +		printk(KERN_DEBUG "random %04d %04d %04d: " \
 +		fmt,\
 +		input_pool.entropy_count,\
 +		blocking_pool.entropy_count,\
 +		nonblocking_pool.entropy_count,\
 +		## arg); } while (0)
  
+ struct crng_state {
+ 	__u32		state[16];
+ 	unsigned long	init_time;
+ 	spinlock_t	lock;
+ };
+ 
+ struct crng_state primary_crng = {
+ 	.lock = __SPIN_LOCK_UNLOCKED(primary_crng.lock),
+ };
+ 
+ /*
+  * crng_init =  0 --> Uninitialized
+  *		1 --> Initialized
+  *		2 --> Initialized from input_pool
+  *
+  * crng_init is protected by primary_crng->lock, and only increases
+  * its value (from 0->1->2).
+  */
+ static int crng_init = 0;
+ #define crng_ready() (likely(crng_init > 0))
+ static int crng_init_cnt = 0;
+ #define CRNG_INIT_CNT_THRESH (2*CHACHA20_KEY_SIZE)
+ static void extract_crng(__u8 out[CHACHA20_BLOCK_SIZE]);
+ static void process_random_ready_list(void);
+ 
  /**********************************************************************
   *
   * OS independent entropy store.   Here are the functions which handle
@@@ -447,9 -468,15 +481,18 @@@ struct entropy_store 
  	__u8 last_data[EXTRACT_SIZE];
  };
  
++<<<<<<< HEAD
++=======
+ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
+ 			       size_t nbytes, int min, int rsvd);
+ static ssize_t _extract_entropy(struct entropy_store *r, void *buf,
+ 				size_t nbytes, int fips);
+ 
+ static void crng_reseed(struct crng_state *crng, struct entropy_store *r);
+ static void push_to_pool(struct work_struct *work);
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  static __u32 input_pool_data[INPUT_POOL_WORDS];
  static __u32 blocking_pool_data[OUTPUT_POOL_WORDS];
- static __u32 nonblocking_pool_data[OUTPUT_POOL_WORDS];
  
  static struct entropy_store input_pool = {
  	.poolinfo = &poolinfo_table[0],
@@@ -465,17 -492,11 +508,20 @@@ static struct entropy_store blocking_po
  	.limit = 1,
  	.pull = &input_pool,
  	.lock = __SPIN_LOCK_UNLOCKED(blocking_pool.lock),
 -	.pool = blocking_pool_data,
 -	.push_work = __WORK_INITIALIZER(blocking_pool.push_work,
 -					push_to_pool),
 +	.pool = blocking_pool_data
 +};
 +
++<<<<<<< HEAD
 +static struct entropy_store nonblocking_pool = {
 +	.poolinfo = &poolinfo_table[1],
 +	.name = "nonblocking",
 +	.pull = &input_pool,
 +	.lock = __SPIN_LOCK_UNLOCKED(nonblocking_pool.lock),
 +	.pool = nonblocking_pool_data
  };
  
++=======
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  static __u32 const twist_table[8] = {
  	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
  	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
@@@ -661,24 -695,43 +707,61 @@@ retry
  	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
  		goto retry;
  
++<<<<<<< HEAD
 +	if (!r->initialized && nbits > 0) {
 +		r->entropy_total += nbits;
 +		if (r->entropy_total > 128) {
 +			r->initialized = 1;
 +			if (r == &nonblocking_pool)
 +				prandom_reseed_late();
 +		}
++=======
+ 	r->entropy_total += nbits;
+ 	if (!r->initialized && r->entropy_total > 128) {
+ 		r->initialized = 1;
+ 		r->entropy_total = 0;
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  	}
  
  	trace_credit_entropy_bits(r->name, nbits,
  				  entropy_count >> ENTROPY_SHIFT,
  				  r->entropy_total, _RET_IP_);
  
++<<<<<<< HEAD
 +	/* should we wake readers? */
 +	if (r == &input_pool &&
 +	    (entropy_count >> ENTROPY_SHIFT) >= random_read_wakeup_thresh) {
 +		wake_up_interruptible(&random_read_wait);
 +		kill_fasync(&fasync, SIGIO, POLL_IN);
++=======
+ 	if (r == &input_pool) {
+ 		int entropy_bits = entropy_count >> ENTROPY_SHIFT;
+ 
+ 		if (crng_init < 2 && entropy_bits >= 128) {
+ 			crng_reseed(&primary_crng, r);
+ 			entropy_bits = r->entropy_count >> ENTROPY_SHIFT;
+ 		}
+ 
+ 		/* should we wake readers? */
+ 		if (entropy_bits >= random_read_wakeup_bits) {
+ 			wake_up_interruptible(&random_read_wait);
+ 			kill_fasync(&fasync, SIGIO, POLL_IN);
+ 		}
+ 		/* If the input pool is getting full, send some
+ 		 * entropy to the blocking pool until it is 75% full.
+ 		 */
+ 		if (entropy_bits > random_write_wakeup_bits &&
+ 		    r->initialized &&
+ 		    r->entropy_total >= 2*random_read_wakeup_bits) {
+ 			struct entropy_store *other = &blocking_pool;
+ 
+ 			if (other->entropy_count <=
+ 			    3 * other->poolinfo->poolfracbits / 4) {
+ 				schedule_work(&other->push_work);
+ 				r->entropy_total = 0;
+ 			}
+ 		}
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  	}
  }
  
@@@ -723,14 -922,9 +952,17 @@@ void add_device_randomness(const void *
  
  	trace_add_device_randomness(size, _RET_IP_);
  	spin_lock_irqsave(&input_pool.lock, flags);
 -	_mix_pool_bytes(&input_pool, buf, size);
 -	_mix_pool_bytes(&input_pool, &time, sizeof(time));
 +	_mix_pool_bytes(&input_pool, buf, size, NULL);
 +	_mix_pool_bytes(&input_pool, &time, sizeof(time), NULL);
  	spin_unlock_irqrestore(&input_pool.lock, flags);
++<<<<<<< HEAD
 +
 +	spin_lock_irqsave(&nonblocking_pool.lock, flags);
 +	_mix_pool_bytes(&nonblocking_pool, buf, size, NULL);
 +	_mix_pool_bytes(&nonblocking_pool, &time, sizeof(time), NULL);
 +	spin_unlock_irqrestore(&nonblocking_pool.lock, flags);
++=======
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  }
  EXPORT_SYMBOL(add_device_randomness);
  
@@@ -761,8 -955,8 +993,13 @@@ static void add_timer_randomness(struc
  	sample.jiffies = jiffies;
  	sample.cycles = random_get_entropy();
  	sample.num = num;
++<<<<<<< HEAD
 +	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
 +	mix_pool_bytes(r, &sample, sizeof(sample), NULL);
++=======
+ 	r = &input_pool;
+ 	mix_pool_bytes(r, &sample, sizeof(sample));
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  
  	/*
  	 * Calculate number of bits of randomness we probably added.
@@@ -1214,6 -1447,64 +1478,67 @@@ void get_random_bytes(void *buf, int nb
  EXPORT_SYMBOL(get_random_bytes);
  
  /*
++<<<<<<< HEAD
++=======
+  * Add a callback function that will be invoked when the nonblocking
+  * pool is initialised.
+  *
+  * returns: 0 if callback is successfully added
+  *	    -EALREADY if pool is already initialised (callback not called)
+  *	    -ENOENT if module for callback is not alive
+  */
+ int add_random_ready_callback(struct random_ready_callback *rdy)
+ {
+ 	struct module *owner;
+ 	unsigned long flags;
+ 	int err = -EALREADY;
+ 
+ 	if (crng_ready())
+ 		return err;
+ 
+ 	owner = rdy->owner;
+ 	if (!try_module_get(owner))
+ 		return -ENOENT;
+ 
+ 	spin_lock_irqsave(&random_ready_list_lock, flags);
+ 	if (crng_ready())
+ 		goto out;
+ 
+ 	owner = NULL;
+ 
+ 	list_add(&rdy->list, &random_ready_list);
+ 	err = 0;
+ 
+ out:
+ 	spin_unlock_irqrestore(&random_ready_list_lock, flags);
+ 
+ 	module_put(owner);
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL(add_random_ready_callback);
+ 
+ /*
+  * Delete a previously registered readiness callback function.
+  */
+ void del_random_ready_callback(struct random_ready_callback *rdy)
+ {
+ 	unsigned long flags;
+ 	struct module *owner = NULL;
+ 
+ 	spin_lock_irqsave(&random_ready_list_lock, flags);
+ 	if (!list_empty(&rdy->list)) {
+ 		list_del_init(&rdy->list);
+ 		owner = rdy->owner;
+ 	}
+ 	spin_unlock_irqrestore(&random_ready_list_lock, flags);
+ 
+ 	module_put(owner);
+ }
+ EXPORT_SYMBOL(del_random_ready_callback);
+ 
+ /*
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
   * This function will use the architecture-specific hardware random
   * number generator if it is available.  The arch-specific hw RNG will
   * almost certainly be faster than what we can do in software, but it
@@@ -1368,7 -1639,23 +1693,27 @@@ random_read(struct file *file, char __u
  static ssize_t
  urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
  {
++<<<<<<< HEAD
 +	return extract_entropy_user(&nonblocking_pool, buf, nbytes);
++=======
+ 	unsigned long flags;
+ 	static int maxwarn = 10;
+ 	int ret;
+ 
+ 	if (!crng_ready() && maxwarn > 0) {
+ 		maxwarn--;
+ 		printk(KERN_NOTICE "random: %s: uninitialized urandom read "
+ 		       "(%zd bytes read)\n",
+ 		       current->comm, nbytes);
+ 		spin_lock_irqsave(&primary_crng.lock, flags);
+ 		crng_init_cnt = 0;
+ 		spin_unlock_irqrestore(&primary_crng.lock, flags);
+ 	}
+ 	nbytes = min_t(size_t, nbytes, INT_MAX >> (ENTROPY_SHIFT + 3));
+ 	ret = extract_crng_user(buf, nbytes);
+ 	trace_urandom_read(8 * nbytes, 0, ENTROPY_BITS(&input_pool));
+ 	return ret;
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  }
  
  static unsigned int
@@@ -1497,25 -1780,27 +1838,45 @@@ const struct file_operations urandom_fo
  	.llseek = noop_llseek,
  };
  
 -SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count,
 -		unsigned int, flags)
 +/***************************************************************
 + * Random UUID interface
 + *
 + * Used here for a Boot ID, but can be useful for other kernel
 + * drivers.
 + ***************************************************************/
 +
 +/*
 + * Generate random UUID
 + */
 +void generate_random_uuid(unsigned char uuid_out[16])
  {
++<<<<<<< HEAD
 +	get_random_bytes(uuid_out, 16);
 +	/* Set UUID version to 4 --- truly random generation */
 +	uuid_out[6] = (uuid_out[6] & 0x0F) | 0x40;
 +	/* Set the UUID variant to DCE */
 +	uuid_out[8] = (uuid_out[8] & 0x3F) | 0x80;
++=======
+ 	if (flags & ~(GRND_NONBLOCK|GRND_RANDOM))
+ 		return -EINVAL;
+ 
+ 	if (count > INT_MAX)
+ 		count = INT_MAX;
+ 
+ 	if (flags & GRND_RANDOM)
+ 		return _random_read(flags & GRND_NONBLOCK, buf, count);
+ 
+ 	if (!crng_ready()) {
+ 		if (flags & GRND_NONBLOCK)
+ 			return -EAGAIN;
+ 		crng_wait_ready();
+ 		if (signal_pending(current))
+ 			return -ERESTARTSYS;
+ 	}
+ 	return urandom_read(NULL, buf, count, NULL);
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  }
 +EXPORT_SYMBOL(generate_random_uuid);
  
  /********************************************************************
   *
@@@ -1779,13 -2031,18 +2140,26 @@@ void add_hwgenerator_randomness(const c
  {
  	struct entropy_store *poolp = &input_pool;
  
++<<<<<<< HEAD
++=======
+ 	if (!crng_ready()) {
+ 		crng_fast_load(buffer, count);
+ 		return;
+ 	}
+ 
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  	/* Suspend writing if we're above the trickle threshold.
  	 * We'll be woken up again once below random_write_wakeup_thresh,
  	 * or when the calling thread is about to terminate.
  	 */
  	wait_event_interruptible(random_write_wait, kthread_should_stop() ||
++<<<<<<< HEAD
 +			input_pool.entropy_count <= random_write_wakeup_thresh);
 +	mix_pool_bytes(poolp, buffer, count, NULL);
++=======
+ 			ENTROPY_BITS(&input_pool) <= random_write_wakeup_bits);
+ 	mix_pool_bytes(poolp, buffer, count);
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  	credit_entropy_bits(poolp, entropy);
  }
  EXPORT_SYMBOL_GPL(add_hwgenerator_randomness);
diff --cc lib/Makefile
index 02e3e68fb863,34e205facfa3..000000000000
--- a/lib/Makefile
+++ b/lib/Makefile
@@@ -10,10 -10,22 +10,15 @@@ endi
  lib-y := ctype.o string.o vsprintf.o cmdline.o \
  	 rbtree.o radix-tree.o dump_stack.o timerqueue.o\
  	 idr.o int_sqrt.o extable.o \
++<<<<<<< HEAD
 +	 sha1.o md5.o irq_regs.o reciprocal_div.o argv_split.o \
 +	 proportions.o flex_proportions.o prio_heap.o ratelimit.o show_mem.o \
++=======
+ 	 sha1.o chacha20.o md5.o irq_regs.o argv_split.o \
+ 	 flex_proportions.o ratelimit.o show_mem.o \
++>>>>>>> e192be9d9a30 (random: replace non-blocking pool with a Chacha20-based CRNG)
  	 is_single_threaded.o plist.o decompress.o kobject_uevent.o \
 -	 earlycpio.o seq_buf.o nmi_backtrace.o nodemask.o
 +	 earlycpio.o percpu-refcount.o percpu_ida.o seq_buf.o
  
  obj-$(CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS) += usercopy.o
  lib-$(CONFIG_MMU) += ioremap.o
* Unmerged path crypto/chacha20_generic.c
* Unmerged path include/crypto/chacha20.h
* Unmerged path crypto/chacha20_generic.c
* Unmerged path drivers/char/random.c
* Unmerged path include/crypto/chacha20.h
* Unmerged path lib/Makefile
diff --git a/lib/chacha20.c b/lib/chacha20.c
new file mode 100644
index 000000000000..250ceed9ec9a
--- /dev/null
+++ b/lib/chacha20.c
@@ -0,0 +1,79 @@
+/*
+ * ChaCha20 256-bit cipher algorithm, RFC7539
+ *
+ * Copyright (C) 2015 Martin Willi
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/bitops.h>
+#include <linux/cryptohash.h>
+#include <asm/unaligned.h>
+#include <crypto/chacha20.h>
+
+static inline u32 rotl32(u32 v, u8 n)
+{
+	return (v << n) | (v >> (sizeof(v) * 8 - n));
+}
+
+extern void chacha20_block(u32 *state, void *stream)
+{
+	u32 x[16], *out = stream;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(x); i++)
+		x[i] = state[i];
+
+	for (i = 0; i < 20; i += 2) {
+		x[0]  += x[4];    x[12] = rotl32(x[12] ^ x[0],  16);
+		x[1]  += x[5];    x[13] = rotl32(x[13] ^ x[1],  16);
+		x[2]  += x[6];    x[14] = rotl32(x[14] ^ x[2],  16);
+		x[3]  += x[7];    x[15] = rotl32(x[15] ^ x[3],  16);
+
+		x[8]  += x[12];   x[4]  = rotl32(x[4]  ^ x[8],  12);
+		x[9]  += x[13];   x[5]  = rotl32(x[5]  ^ x[9],  12);
+		x[10] += x[14];   x[6]  = rotl32(x[6]  ^ x[10], 12);
+		x[11] += x[15];   x[7]  = rotl32(x[7]  ^ x[11], 12);
+
+		x[0]  += x[4];    x[12] = rotl32(x[12] ^ x[0],   8);
+		x[1]  += x[5];    x[13] = rotl32(x[13] ^ x[1],   8);
+		x[2]  += x[6];    x[14] = rotl32(x[14] ^ x[2],   8);
+		x[3]  += x[7];    x[15] = rotl32(x[15] ^ x[3],   8);
+
+		x[8]  += x[12];   x[4]  = rotl32(x[4]  ^ x[8],   7);
+		x[9]  += x[13];   x[5]  = rotl32(x[5]  ^ x[9],   7);
+		x[10] += x[14];   x[6]  = rotl32(x[6]  ^ x[10],  7);
+		x[11] += x[15];   x[7]  = rotl32(x[7]  ^ x[11],  7);
+
+		x[0]  += x[5];    x[15] = rotl32(x[15] ^ x[0],  16);
+		x[1]  += x[6];    x[12] = rotl32(x[12] ^ x[1],  16);
+		x[2]  += x[7];    x[13] = rotl32(x[13] ^ x[2],  16);
+		x[3]  += x[4];    x[14] = rotl32(x[14] ^ x[3],  16);
+
+		x[10] += x[15];   x[5]  = rotl32(x[5]  ^ x[10], 12);
+		x[11] += x[12];   x[6]  = rotl32(x[6]  ^ x[11], 12);
+		x[8]  += x[13];   x[7]  = rotl32(x[7]  ^ x[8],  12);
+		x[9]  += x[14];   x[4]  = rotl32(x[4]  ^ x[9],  12);
+
+		x[0]  += x[5];    x[15] = rotl32(x[15] ^ x[0],   8);
+		x[1]  += x[6];    x[12] = rotl32(x[12] ^ x[1],   8);
+		x[2]  += x[7];    x[13] = rotl32(x[13] ^ x[2],   8);
+		x[3]  += x[4];    x[14] = rotl32(x[14] ^ x[3],   8);
+
+		x[10] += x[15];   x[5]  = rotl32(x[5]  ^ x[10],  7);
+		x[11] += x[12];   x[6]  = rotl32(x[6]  ^ x[11],  7);
+		x[8]  += x[13];   x[7]  = rotl32(x[7]  ^ x[8],   7);
+		x[9]  += x[14];   x[4]  = rotl32(x[4]  ^ x[9],   7);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(x); i++)
+		out[i] = cpu_to_le32(x[i] + state[i]);
+
+	state[12]++;
+}
+EXPORT_SYMBOL(chacha20_block);
