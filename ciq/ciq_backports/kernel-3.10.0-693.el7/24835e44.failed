drm: reference count event->completion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] reference count event->completion (Rob Clark) [1422186]
Rebuild_FUZZ: 92.96%
commit-author Daniel Vetter <daniel.vetter@ffwll.ch>
commit 24835e442f289813aa568d142a755672a740503c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/24835e44.failed

When writing the generic nonblocking commit code I assumed that
through clever lifetime management I can assure that the completion
(stored in drm_crtc_commit) only gets freed after it is completed. And
that worked.

I also wanted to make nonblocking helpers resilient against driver
bugs, by having timeouts everywhere. And that worked too.

Unfortunately taking boths things together results in oopses :( Well,
at least sometimes: What seems to happen is that the drm event hangs
around forever stuck in limbo land. The nonblocking helpers eventually
time out, move on and release it. Now the bug I tested all this
against is drivers that just entirely fail to deliver the vblank
events like they should, and in those cases the event is simply
leaked. But what seems to happen, at least sometimes, on i915 is that
the event is set up correctly, but somohow the vblank fails to fire in
time. Which means the event isn't leaked, it's still there waiting for
eventually a vblank to fire. That tends to happen when re-enabling the
pipe, and then the trap springs and the kernel oopses.

The correct fix here is simply to refcount the crtc commit to make
sure that the event sticks around even for drivers which only
sometimes fail to deliver vblanks for some arbitrary reasons. Since
crtc commits are already refcounted that's easy to do.

References: https://bugs.freedesktop.org/show_bug.cgi?id=96781
	Cc: Jim Rees <rees@umich.edu>
	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Cc: Jani Nikula <jani.nikula@linux.intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20161221102331.31033-1-daniel.vetter@ffwll.ch
(cherry picked from commit 24835e442f289813aa568d142a755672a740503c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_atomic_helper.c
#	drivers/gpu/drm/drm_fops.c
#	include/drm/drmP.h
diff --cc drivers/gpu/drm/drm_atomic_helper.c
index 5e6caef116dd,9460f3a4c1c2..000000000000
--- a/drivers/gpu/drm/drm_atomic_helper.c
+++ b/drivers/gpu/drm/drm_atomic_helper.c
@@@ -1217,8 -1304,321 +1217,320 @@@ EXPORT_SYMBOL(drm_atomic_helper_commit)
   * commit helpers: a) pre-plane commit b) plane commit c) post-plane commit and
   * then cleaning up the framebuffers after the old framebuffer is no longer
   * being displayed.
 - *
 - * The above scheme is implemented in the atomic helper libraries in
 - * drm_atomic_helper_commit() using a bunch of helper functions. See
 - * drm_atomic_helper_setup_commit() for a starting point.
   */
  
++<<<<<<< HEAD
++=======
+ static int stall_checks(struct drm_crtc *crtc, bool nonblock)
+ {
+ 	struct drm_crtc_commit *commit, *stall_commit = NULL;
+ 	bool completed = true;
+ 	int i;
+ 	long ret = 0;
+ 
+ 	spin_lock(&crtc->commit_lock);
+ 	i = 0;
+ 	list_for_each_entry(commit, &crtc->commit_list, commit_entry) {
+ 		if (i == 0) {
+ 			completed = try_wait_for_completion(&commit->flip_done);
+ 			/* Userspace is not allowed to get ahead of the previous
+ 			 * commit with nonblocking ones. */
+ 			if (!completed && nonblock) {
+ 				spin_unlock(&crtc->commit_lock);
+ 				return -EBUSY;
+ 			}
+ 		} else if (i == 1) {
+ 			stall_commit = commit;
+ 			drm_crtc_commit_get(stall_commit);
+ 			break;
+ 		}
+ 
+ 		i++;
+ 	}
+ 	spin_unlock(&crtc->commit_lock);
+ 
+ 	if (!stall_commit)
+ 		return 0;
+ 
+ 	/* We don't want to let commits get ahead of cleanup work too much,
+ 	 * stalling on 2nd previous commit means triple-buffer won't ever stall.
+ 	 */
+ 	ret = wait_for_completion_interruptible_timeout(&stall_commit->cleanup_done,
+ 							10*HZ);
+ 	if (ret == 0)
+ 		DRM_ERROR("[CRTC:%d:%s] cleanup_done timed out\n",
+ 			  crtc->base.id, crtc->name);
+ 
+ 	drm_crtc_commit_put(stall_commit);
+ 
+ 	return ret < 0 ? ret : 0;
+ }
+ 
+ void release_crtc_commit(struct completion *completion)
+ {
+ 	struct drm_crtc_commit *commit = container_of(completion,
+ 						      typeof(*commit),
+ 						      flip_done);
+ 
+ 	drm_crtc_commit_put(commit);
+ }
+ 
+ /**
+  * drm_atomic_helper_setup_commit - setup possibly nonblocking commit
+  * @state: new modeset state to be committed
+  * @nonblock: whether nonblocking behavior is requested.
+  *
+  * This function prepares @state to be used by the atomic helper's support for
+  * nonblocking commits. Drivers using the nonblocking commit infrastructure
+  * should always call this function from their ->atomic_commit hook.
+  *
+  * To be able to use this support drivers need to use a few more helper
+  * functions. drm_atomic_helper_wait_for_dependencies() must be called before
+  * actually committing the hardware state, and for nonblocking commits this call
+  * must be placed in the async worker. See also drm_atomic_helper_swap_state()
+  * and it's stall parameter, for when a driver's commit hooks look at the
+  * ->state pointers of &struct drm_crtc, &drm_plane or &drm_connector directly.
+  *
+  * Completion of the hardware commit step must be signalled using
+  * drm_atomic_helper_commit_hw_done(). After this step the driver is not allowed
+  * to read or change any permanent software or hardware modeset state. The only
+  * exception is state protected by other means than &drm_modeset_lock locks.
+  * Only the free standing @state with pointers to the old state structures can
+  * be inspected, e.g. to clean up old buffers using
+  * drm_atomic_helper_cleanup_planes().
+  *
+  * At the very end, before cleaning up @state drivers must call
+  * drm_atomic_helper_commit_cleanup_done().
+  *
+  * This is all implemented by in drm_atomic_helper_commit(), giving drivers a
+  * complete and esay-to-use default implementation of the atomic_commit() hook.
+  *
+  * The tracking of asynchronously executed and still pending commits is done
+  * using the core structure &drm_crtc_commit.
+  *
+  * By default there's no need to clean up resources allocated by this function
+  * explicitly: drm_atomic_state_default_clear() will take care of that
+  * automatically.
+  *
+  * Returns:
+  *
+  * 0 on success. -EBUSY when userspace schedules nonblocking commits too fast,
+  * -ENOMEM on allocation failures and -EINTR when a signal is pending.
+  */
+ int drm_atomic_helper_setup_commit(struct drm_atomic_state *state,
+ 				   bool nonblock)
+ {
+ 	struct drm_crtc *crtc;
+ 	struct drm_crtc_state *crtc_state;
+ 	struct drm_crtc_commit *commit;
+ 	int i, ret;
+ 
+ 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+ 		commit = kzalloc(sizeof(*commit), GFP_KERNEL);
+ 		if (!commit)
+ 			return -ENOMEM;
+ 
+ 		init_completion(&commit->flip_done);
+ 		init_completion(&commit->hw_done);
+ 		init_completion(&commit->cleanup_done);
+ 		INIT_LIST_HEAD(&commit->commit_entry);
+ 		kref_init(&commit->ref);
+ 		commit->crtc = crtc;
+ 
+ 		state->crtcs[i].commit = commit;
+ 
+ 		ret = stall_checks(crtc, nonblock);
+ 		if (ret)
+ 			return ret;
+ 
+ 		/* Drivers only send out events when at least either current or
+ 		 * new CRTC state is active. Complete right away if everything
+ 		 * stays off. */
+ 		if (!crtc->state->active && !crtc_state->active) {
+ 			complete_all(&commit->flip_done);
+ 			continue;
+ 		}
+ 
+ 		/* Legacy cursor updates are fully unsynced. */
+ 		if (state->legacy_cursor_update) {
+ 			complete_all(&commit->flip_done);
+ 			continue;
+ 		}
+ 
+ 		if (!crtc_state->event) {
+ 			commit->event = kzalloc(sizeof(*commit->event),
+ 						GFP_KERNEL);
+ 			if (!commit->event)
+ 				return -ENOMEM;
+ 
+ 			crtc_state->event = commit->event;
+ 		}
+ 
+ 		crtc_state->event->base.completion = &commit->flip_done;
+ 		crtc_state->event->base.completion_release = release_crtc_commit;
+ 		drm_crtc_commit_get(commit);
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(drm_atomic_helper_setup_commit);
+ 
+ 
+ static struct drm_crtc_commit *preceeding_commit(struct drm_crtc *crtc)
+ {
+ 	struct drm_crtc_commit *commit;
+ 	int i = 0;
+ 
+ 	list_for_each_entry(commit, &crtc->commit_list, commit_entry) {
+ 		/* skip the first entry, that's the current commit */
+ 		if (i == 1)
+ 			return commit;
+ 		i++;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * drm_atomic_helper_wait_for_dependencies - wait for required preceeding commits
+  * @old_state: atomic state object with old state structures
+  *
+  * This function waits for all preceeding commits that touch the same CRTC as
+  * @old_state to both be committed to the hardware (as signalled by
+  * drm_atomic_helper_commit_hw_done) and executed by the hardware (as signalled
+  * by calling drm_crtc_vblank_send_event on the event member of
+  * &drm_crtc_state).
+  *
+  * This is part of the atomic helper support for nonblocking commits, see
+  * drm_atomic_helper_setup_commit() for an overview.
+  */
+ void drm_atomic_helper_wait_for_dependencies(struct drm_atomic_state *old_state)
+ {
+ 	struct drm_crtc *crtc;
+ 	struct drm_crtc_state *crtc_state;
+ 	struct drm_crtc_commit *commit;
+ 	int i;
+ 	long ret;
+ 
+ 	for_each_crtc_in_state(old_state, crtc, crtc_state, i) {
+ 		spin_lock(&crtc->commit_lock);
+ 		commit = preceeding_commit(crtc);
+ 		if (commit)
+ 			drm_crtc_commit_get(commit);
+ 		spin_unlock(&crtc->commit_lock);
+ 
+ 		if (!commit)
+ 			continue;
+ 
+ 		ret = wait_for_completion_timeout(&commit->hw_done,
+ 						  10*HZ);
+ 		if (ret == 0)
+ 			DRM_ERROR("[CRTC:%d:%s] hw_done timed out\n",
+ 				  crtc->base.id, crtc->name);
+ 
+ 		/* Currently no support for overwriting flips, hence
+ 		 * stall for previous one to execute completely. */
+ 		ret = wait_for_completion_timeout(&commit->flip_done,
+ 						  10*HZ);
+ 		if (ret == 0)
+ 			DRM_ERROR("[CRTC:%d:%s] flip_done timed out\n",
+ 				  crtc->base.id, crtc->name);
+ 
+ 		drm_crtc_commit_put(commit);
+ 	}
+ }
+ EXPORT_SYMBOL(drm_atomic_helper_wait_for_dependencies);
+ 
+ /**
+  * drm_atomic_helper_commit_hw_done - setup possible nonblocking commit
+  * @old_state: atomic state object with old state structures
+  *
+  * This function is used to signal completion of the hardware commit step. After
+  * this step the driver is not allowed to read or change any permanent software
+  * or hardware modeset state. The only exception is state protected by other
+  * means than &drm_modeset_lock locks.
+  *
+  * Drivers should try to postpone any expensive or delayed cleanup work after
+  * this function is called.
+  *
+  * This is part of the atomic helper support for nonblocking commits, see
+  * drm_atomic_helper_setup_commit() for an overview.
+  */
+ void drm_atomic_helper_commit_hw_done(struct drm_atomic_state *old_state)
+ {
+ 	struct drm_crtc *crtc;
+ 	struct drm_crtc_state *crtc_state;
+ 	struct drm_crtc_commit *commit;
+ 	int i;
+ 
+ 	for_each_crtc_in_state(old_state, crtc, crtc_state, i) {
+ 		commit = old_state->crtcs[i].commit;
+ 		if (!commit)
+ 			continue;
+ 
+ 		/* backend must have consumed any event by now */
+ 		WARN_ON(crtc->state->event);
+ 		spin_lock(&crtc->commit_lock);
+ 		complete_all(&commit->hw_done);
+ 		spin_unlock(&crtc->commit_lock);
+ 	}
+ }
+ EXPORT_SYMBOL(drm_atomic_helper_commit_hw_done);
+ 
+ /**
+  * drm_atomic_helper_commit_cleanup_done - signal completion of commit
+  * @old_state: atomic state object with old state structures
+  *
+  * This signals completion of the atomic update @old_state, including any
+  * cleanup work. If used, it must be called right before calling
+  * drm_atomic_state_put().
+  *
+  * This is part of the atomic helper support for nonblocking commits, see
+  * drm_atomic_helper_setup_commit() for an overview.
+  */
+ void drm_atomic_helper_commit_cleanup_done(struct drm_atomic_state *old_state)
+ {
+ 	struct drm_crtc *crtc;
+ 	struct drm_crtc_state *crtc_state;
+ 	struct drm_crtc_commit *commit;
+ 	int i;
+ 	long ret;
+ 
+ 	for_each_crtc_in_state(old_state, crtc, crtc_state, i) {
+ 		commit = old_state->crtcs[i].commit;
+ 		if (WARN_ON(!commit))
+ 			continue;
+ 
+ 		spin_lock(&crtc->commit_lock);
+ 		complete_all(&commit->cleanup_done);
+ 		WARN_ON(!try_wait_for_completion(&commit->hw_done));
+ 
+ 		/* commit_list borrows our reference, need to remove before we
+ 		 * clean up our drm_atomic_state. But only after it actually
+ 		 * completed, otherwise subsequent commits won't stall properly. */
+ 		if (try_wait_for_completion(&commit->flip_done))
+ 			goto del_commit;
+ 
+ 		spin_unlock(&crtc->commit_lock);
+ 
+ 		/* We must wait for the vblank event to signal our completion
+ 		 * before releasing our reference, since the vblank work does
+ 		 * not hold a reference of its own. */
+ 		ret = wait_for_completion_timeout(&commit->flip_done,
+ 						  10*HZ);
+ 		if (ret == 0)
+ 			DRM_ERROR("[CRTC:%d:%s] flip_done timed out\n",
+ 				  crtc->base.id, crtc->name);
+ 
+ 		spin_lock(&crtc->commit_lock);
+ del_commit:
+ 		list_del(&commit->commit_entry);
+ 		spin_unlock(&crtc->commit_lock);
+ 	}
+ }
+ EXPORT_SYMBOL(drm_atomic_helper_commit_cleanup_done);
+ 
++>>>>>>> 24835e442f28 (drm: reference count event->completion)
  /**
   * drm_atomic_helper_prepare_planes - prepare plane resources before commit
   * @dev: DRM device
diff --cc drivers/gpu/drm/drm_fops.c
index aeef58ed359b,e22645375e60..000000000000
--- a/drivers/gpu/drm/drm_fops.c
+++ b/drivers/gpu/drm/drm_fops.c
@@@ -801,8 -688,19 +801,22 @@@ void drm_send_event_locked(struct drm_d
  {
  	assert_spin_locked(&dev->event_lock);
  
++<<<<<<< HEAD
++=======
+ 	if (e->completion) {
+ 		complete_all(e->completion);
+ 		e->completion_release(e->completion);
+ 		e->completion = NULL;
+ 	}
+ 
+ 	if (e->fence) {
+ 		dma_fence_signal(e->fence);
+ 		dma_fence_put(e->fence);
+ 	}
+ 
++>>>>>>> 24835e442f28 (drm: reference count event->completion)
  	if (!e->file_priv) {
 -		kfree(e);
 +		e->destroy(e);
  		return;
  	}
  
diff --cc include/drm/drmP.h
index 3c8422c69572,ffa8b6d6d367..000000000000
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@@ -281,7 -359,10 +281,12 @@@ struct drm_ioctl_desc 
  
  /* Event queued up for userspace to read */
  struct drm_pending_event {
++<<<<<<< HEAD
++=======
+ 	struct completion *completion;
+ 	void (*completion_release)(struct completion *completion);
++>>>>>>> 24835e442f28 (drm: reference count event->completion)
  	struct drm_event *event;
 -	struct dma_fence *fence;
  	struct list_head link;
  	struct list_head pending_link;
  	struct drm_file *file_priv;
* Unmerged path drivers/gpu/drm/drm_atomic_helper.c
* Unmerged path drivers/gpu/drm/drm_fops.c
* Unmerged path include/drm/drmP.h
