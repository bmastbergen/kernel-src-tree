HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.87%
commit-author Jason Gerecke <killertofu@gmail.com>
commit e5bc8eb1b02244be4e97e9654d394275e615923a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e5bc8eb1.failed

"Direct" input devices like Cintiqs and Tablet PCs set the INPUT_PROP_DIRECT
property to notify userspace that the sensor and screen are overlaid. This
information can also be useful elsewhere within the kernel driver, however,
so we introduce a new WACOM_DEVICETYPE_DIRECT that signals this to other
kernel code.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit e5bc8eb1b02244be4e97e9654d394275e615923a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_wac.c
index 98c7d65145c2,a545c2451156..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1090,6 -1419,409 +1090,412 @@@ static int wacom_tpc_irq(struct wacom_w
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_map_usage(struct input_dev *input, struct hid_usage *usage,
+ 		struct hid_field *field, __u8 type, __u16 code, int fuzz)
+ {
+ 	int fmin = field->logical_minimum;
+ 	int fmax = field->logical_maximum;
+ 
+ 	usage->type = type;
+ 	usage->code = code;
+ 
+ 	set_bit(type, input->evbit);
+ 
+ 	switch (type) {
+ 	case EV_ABS:
+ 		input_set_abs_params(input, code, fmin, fmax, fuzz, 0);
+ 		input_abs_set_res(input, code,
+ 				  hidinput_calc_abs_res(field, code));
+ 		break;
+ 	case EV_KEY:
+ 		input_set_capability(input, EV_KEY, code);
+ 		break;
+ 	case EV_MSC:
+ 		input_set_capability(input, EV_MSC, code);
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_pen_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_PRESSURE, 0);
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOOL_PEN, 0);
+ 		break;
+ 	case HID_DG_INVERT:
+ 		wacom_map_usage(input, usage, field, EV_KEY,
+ 				BTN_TOOL_RUBBER, 0);
+ 		break;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH2:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS2, 0);
+ 		break;
+ 	case HID_DG_TOOLSERIALNUMBER:
+ 		wacom_map_usage(input, usage, field, EV_MSC, MSC_SERIAL, 0);
+ 		break;
+ 	}
+ }
+ 
+ static int wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 
+ 	/* checking which Tool / tip switch to send */
+ 	switch (usage->hid) {
+ 	case HID_DG_INRANGE:
+ 		wacom_wac->hid_data.inrange_state = value;
+ 		return 0;
+ 	case HID_DG_INVERT:
+ 		wacom_wac->hid_data.invert_state = value;
+ 		return 0;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch |= value;
+ 		return 0;
+ 	}
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!usage->type || wacom_wac->shared->touch_down)
+ 		return 0;
+ 
+ 	input_event(input, usage->type, usage->code, value);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_pen_pre_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	return;
+ }
+ 
+ static void wacom_wac_pen_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 	bool prox = wacom_wac->hid_data.inrange_state;
+ 
+ 	if (!wacom_wac->shared->stylus_in_proximity) /* first in prox */
+ 		/* Going into proximity select tool */
+ 		wacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?
+ 						BTN_TOOL_RUBBER : BTN_TOOL_PEN;
+ 
+ 	/* keep pen state for touch events */
+ 	wacom_wac->shared->stylus_in_proximity = prox;
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!wacom_wac->shared->touch_down) {
+ 		input_report_key(input, BTN_TOUCH,
+ 				wacom_wac->hid_data.tipswitch);
+ 		input_report_key(input, wacom_wac->tool[0], prox);
+ 
+ 		wacom_wac->hid_data.tipswitch = false;
+ 
+ 		input_sync(input);
+ 	}
+ }
+ 
+ static void wacom_wac_finger_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	struct input_dev *input = wacom_wac->touch_input;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		features->last_slot_field = usage->hid;
+ 		if (touch_max == 1)
+ 			wacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);
+ 		else
+ 			wacom_map_usage(input, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		features->last_slot_field = usage->hid;
+ 		if (touch_max == 1)
+ 			wacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);
+ 		else
+ 			wacom_map_usage(input, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_Y, 4);
+ 		break;
+ 	case HID_DG_WIDTH:
+ 	case HID_DG_HEIGHT:
+ 		features->last_slot_field = usage->hid;
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MINOR, 0);
+ 		input_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_INVERT:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		features->last_slot_field = usage->hid;
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	case HID_DG_CONTACTCOUNT:
+ 		wacom_wac->hid_data.cc_report = field->report->id;
+ 		wacom_wac->hid_data.cc_index = field->index;
+ 		wacom_wac->hid_data.cc_value_index = usage->usage_index;
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_finger_slot(struct wacom_wac *wacom_wac,
+ 		struct input_dev *input)
+ {
+ 	struct hid_data *hid_data = &wacom_wac->hid_data;
+ 	bool mt = wacom_wac->features.touch_max > 1;
+ 	bool prox = hid_data->tipswitch &&
+ 		    !wacom_wac->shared->stylus_in_proximity;
+ 
+ 	wacom_wac->hid_data.num_received++;
+ 	if (wacom_wac->hid_data.num_received > wacom_wac->hid_data.num_expected)
+ 		return;
+ 
+ 	if (mt) {
+ 		int slot;
+ 
+ 		slot = input_mt_get_slot_by_key(input, hid_data->id);
+ 		input_mt_slot(input, slot);
+ 		input_mt_report_slot_state(input, MT_TOOL_FINGER, prox);
+ 	}
+ 	else {
+ 		input_report_key(input, BTN_TOUCH, prox);
+ 	}
+ 
+ 	if (prox) {
+ 		input_report_abs(input, mt ? ABS_MT_POSITION_X : ABS_X,
+ 				 hid_data->x);
+ 		input_report_abs(input, mt ? ABS_MT_POSITION_Y : ABS_Y,
+ 				 hid_data->y);
+ 
+ 		if (test_bit(ABS_MT_TOUCH_MAJOR, input->absbit)) {
+ 			input_report_abs(input, ABS_MT_TOUCH_MAJOR, max(hid_data->width, hid_data->height));
+ 			input_report_abs(input, ABS_MT_TOUCH_MINOR, min(hid_data->width, hid_data->height));
+ 			if (hid_data->width != hid_data->height)
+ 				input_report_abs(input, ABS_MT_ORIENTATION, hid_data->width <= hid_data->height ? 0 : 1);
+ 		}
+ 	}
+ }
+ 
+ static int wacom_wac_finger_event(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_wac->hid_data.x = value;
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_wac->hid_data.y = value;
+ 		break;
+ 	case HID_DG_WIDTH:
+ 		wacom_wac->hid_data.width = value;
+ 		break;
+ 	case HID_DG_HEIGHT:
+ 		wacom_wac->hid_data.height = value;
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		wacom_wac->hid_data.id = value;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch = value;
+ 		break;
+ 	}
+ 
+ 
+ 	if (usage->usage_index + 1 == field->report_count) {
+ 		if (usage->hid == wacom_wac->features.last_slot_field)
+ 			wacom_wac_finger_slot(wacom_wac, wacom_wac->touch_input);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_finger_pre_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_data* hid_data = &wacom_wac->hid_data;
+ 
+ 	if (hid_data->cc_report != 0 &&
+ 	    hid_data->cc_report != report->id) {
+ 		int i;
+ 
+ 		hid_data->cc_report = report->id;
+ 		hid_data->cc_index = -1;
+ 		hid_data->cc_value_index = -1;
+ 
+ 		for (i = 0; i < report->maxfield; i++) {
+ 			struct hid_field *field = report->field[i];
+ 			int j;
+ 
+ 			for (j = 0; j < field->maxusage; j++) {
+ 				if (field->usage[j].hid == HID_DG_CONTACTCOUNT) {
+ 					hid_data->cc_index = i;
+ 					hid_data->cc_value_index = j;
+ 
+ 					/* break */
+ 					i = report->maxfield;
+ 					j = field->maxusage;
+ 				}
+ 			}
+ 		}
+ 	}
+ 	if (hid_data->cc_report != 0 &&
+ 	    hid_data->cc_index >= 0) {
+ 		struct hid_field *field = report->field[hid_data->cc_index];
+ 		int value = field->value[hid_data->cc_value_index];
+ 		if (value)
+ 			hid_data->num_expected = value;
+ 	}
+ 	else {
+ 		hid_data->num_expected = wacom_wac->features.touch_max;
+ 	}
+ }
+ 
+ static void wacom_wac_finger_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->touch_input;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	/* If more packets of data are expected, give us a chance to
+ 	 * process them rather than immediately syncing a partial
+ 	 * update.
+ 	 */
+ 	if (wacom_wac->hid_data.num_received < wacom_wac->hid_data.num_expected)
+ 		return;
+ 
+ 	if (touch_max > 1)
+ 		input_mt_sync_frame(input);
+ 
+ 	input_sync(input);
+ 	wacom_wac->hid_data.num_received = 0;
+ 
+ 	/* keep touch state for pen event */
+ 	wacom_wac->shared->touch_down = wacom_wac_finger_count_touches(wacom_wac);
+ }
+ 
+ void wacom_wac_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	/* currently, only direct devices have proper hid report descriptors */
+ 	features->device_type |= WACOM_DEVICETYPE_DIRECT;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_usage_mapping(hdev, field, usage);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_usage_mapping(hdev, field, usage);
+ }
+ 
+ int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	if (wacom->wacom_wac.features.type != HID_GENERIC)
+ 		return 0;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_event(hdev, field, usage, value);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_event(hdev, field, usage, value);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_report_events(struct hid_device *hdev, struct hid_report *report)
+ {
+ 	int r;
+ 
+ 	for (r = 0; r < report->maxfield; r++) {
+ 		struct hid_field *field;
+ 		unsigned count, n;
+ 
+ 		field = report->field[r];
+ 		count = field->report_count;
+ 
+ 		if (!(HID_MAIN_ITEM_VARIABLE & field->flags))
+ 			continue;
+ 
+ 		for (n = 0; n < count; n++)
+ 			wacom_wac_event(hdev, field, &field->usage[n], field->value[n]);
+ 	}
+ }
+ 
+ void wacom_wac_report(struct hid_device *hdev, struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_field *field = report->field[0];
+ 
+ 	if (wacom_wac->features.type != HID_GENERIC)
+ 		return;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		wacom_wac_pen_pre_report(hdev, report);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		wacom_wac_finger_pre_report(hdev, report);
+ 
+ 	wacom_report_events(hdev, report);
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_report(hdev, report);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_report(hdev, report);
+ }
+ 
++>>>>>>> e5bc8eb1b022 (HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar)
  static int wacom_bpt_touch(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
@@@ -1469,11 -2413,81 +1875,89 @@@ void wacom_setup_device_quirks(struct w
  		features->y_max = 1023;
  	}
  
++<<<<<<< HEAD
 +	/* these device have multiple inputs */
 +	if (features->type >= WIRELESS ||
 +	    (features->type >= INTUOS5S && features->type <= INTUOSPL) ||
 +	    (features->oVid && features->oPid))
 +		features->quirks |= WACOM_QUIRK_MULTI_INPUT;
++=======
+ 	/*
+ 	 * Intuos5/Pro and Bamboo 3rd gen have no useful data about its
+ 	 * touch interface in its HID descriptor. If this is the touch
+ 	 * interface (PacketSize of WACOM_PKGLEN_BBTOUCH3), override the
+ 	 * tablet values.
+ 	 */
+ 	if ((features->type >= INTUOS5S && features->type <= INTUOSPL) ||
+ 		(features->type >= INTUOSHT && features->type <= BAMBOO_PT)) {
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			if (features->touch_max)
+ 				features->device_type |= WACOM_DEVICETYPE_TOUCH;
+ 			if (features->type >= INTUOSHT && features->type <= BAMBOO_PT)
+ 				features->device_type |= WACOM_DEVICETYPE_PAD;
+ 
+ 			features->x_max = 4096;
+ 			features->y_max = 4096;
+ 		}
+ 		else if (features->pktlen == WACOM_PKGLEN_BBTOUCH) {
+ 			features->device_type |= WACOM_DEVICETYPE_PAD;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Hack for the Bamboo One:
+ 	 * the device presents a PAD/Touch interface as most Bamboos and even
+ 	 * sends ghosts PAD data on it. However, later, we must disable this
+ 	 * ghost interface, and we can not detect it unless we set it here
+ 	 * to WACOM_DEVICETYPE_PAD or WACOM_DEVICETYPE_TOUCH.
+ 	 */
+ 	if (features->type == BAMBOO_PEN &&
+ 	    features->pktlen == WACOM_PKGLEN_BBTOUCH3)
+ 		features->device_type |= WACOM_DEVICETYPE_PAD;
+ 
+ 	/*
+ 	 * Raw Wacom-mode pen and touch events both come from interface
+ 	 * 0, whose HID descriptor has an application usage of 0xFF0D
+ 	 * (i.e., WACOM_VENDORDEFINED_PEN). We route pen packets back
+ 	 * out through the HID_GENERIC device created for interface 1,
+ 	 * so rewrite this one to be of type WACOM_DEVICETYPE_TOUCH.
+ 	 */
+ 	if (features->type == BAMBOO_PAD)
+ 		features->device_type = WACOM_DEVICETYPE_TOUCH;
+ 
+ 	if (features->type == REMOTE)
+ 		features->device_type = WACOM_DEVICETYPE_PAD;
+ 
+ 	switch (features->type) {
+ 	case PL:
+ 	case DTU:
+ 	case DTUS:
+ 	case DTUSX:
+ 	case WACOM_21UX2:
+ 	case WACOM_22HD:
+ 	case DTK:
+ 	case WACOM_24HD:
+ 	case WACOM_27QHD:
+ 	case CINTIQ_HYBRID:
+ 	case CINTIQ_COMPANION_2:
+ 	case CINTIQ:
+ 	case WACOM_BEE:
+ 	case WACOM_13HD:
+ 	case WACOM_24HDT:
+ 	case WACOM_27QHDT:
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 	case TABLETPC2FG:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 		features->device_type |= WACOM_DEVICETYPE_DIRECT;
+ 		break;
+ 	}
+ 
+ 	if (wacom->hdev->bus == BUS_BLUETOOTH)
+ 		features->quirks |= WACOM_QUIRK_BATTERY;
++>>>>>>> e5bc8eb1b022 (HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar)
  
  	/* quirk for bamboo touch with 2 low res touches */
  	if ((features->type == BAMBOO_PT || features->type == BAMBOO_TOUCH) &&
@@@ -1545,21 -2516,41 +2029,53 @@@ int wacom_setup_input_capabilities(stru
  
  	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
  
++<<<<<<< HEAD
 +	__set_bit(BTN_TOUCH, input_dev->keybit);
 +	__set_bit(ABS_MISC, input_dev->absbit);
 +
 +	wacom_abs_set_axis(input_dev, wacom_wac);
++=======
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PEN))
+ 		return -ENODEV;
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_DIRECT)
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 	else
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 	if (features->type == HID_GENERIC)
+ 		/* setup has already been done */
+ 		return 0;
+ 
+ 	__set_bit(BTN_TOUCH, input_dev->keybit);
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	input_set_abs_params(input_dev, ABS_X, features->x_min,
+ 			     features->x_max, features->x_fuzz, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, features->y_min,
+ 			     features->y_max, features->y_fuzz, 0);
+ 	input_set_abs_params(input_dev, ABS_PRESSURE, 0,
+ 		features->pressure_max, features->pressure_fuzz, 0);
+ 
+ 	/* penabled devices have fixed resolution for each model */
+ 	input_abs_set_res(input_dev, ABS_X, features->x_resolution);
+ 	input_abs_set_res(input_dev, ABS_Y, features->y_resolution);
+ 
+ 	switch (features->type) {
+ 	case GRAPHIRE_BT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
++>>>>>>> e5bc8eb1b022 (HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar)
  
 +	switch (wacom_wac->features.type) {
  	case WACOM_MO:
 +		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 +		/* fall through */
 +
  	case WACOM_G4:
 -		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 -					      features->distance_max,
 -					      features->distance_fuzz, 0);
 +		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
 +
 +		__set_bit(BTN_BACK, input_dev->keybit);
 +		__set_bit(BTN_FORWARD, input_dev->keybit);
  		/* fall through */
  
  	case GRAPHIRE:
@@@ -1574,90 -2565,20 +2090,92 @@@
  		__set_bit(BTN_TOOL_MOUSE, input_dev->keybit);
  		__set_bit(BTN_STYLUS, input_dev->keybit);
  		__set_bit(BTN_STYLUS2, input_dev->keybit);
- 
- 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
 -	case WACOM_27QHD:
  	case WACOM_24HD:
 +		__set_bit(BTN_A, input_dev->keybit);
 +		__set_bit(BTN_B, input_dev->keybit);
 +		__set_bit(BTN_C, input_dev->keybit);
 +		__set_bit(BTN_X, input_dev->keybit);
 +		__set_bit(BTN_Y, input_dev->keybit);
 +		__set_bit(BTN_Z, input_dev->keybit);
 +
 +		for (i = 6; i < 10; i++)
 +			__set_bit(BTN_0 + i, input_dev->keybit);
 +
 +		__set_bit(KEY_PROG1, input_dev->keybit);
 +		__set_bit(KEY_PROG2, input_dev->keybit);
 +		__set_bit(KEY_PROG3, input_dev->keybit);
 +
 +		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
 +		/* fall through */
 +
  	case DTK:
 +		for (i = 0; i < 6; i++)
 +			__set_bit(BTN_0 + i, input_dev->keybit);
 +
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
 +
 +		wacom_setup_cintiq(wacom_wac);
 +		break;
 +
 +	case WACOM_27QHD:
 +		__set_bit(KEY_PROG1, input_dev->keybit);
 +		__set_bit(KEY_PROG2, input_dev->keybit);
 +		__set_bit(KEY_PROG3, input_dev->keybit);
 +
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
 +
 +		wacom_setup_cintiq(wacom_wac);
 +
 +		break;
 +
  	case WACOM_22HD:
 +		__set_bit(KEY_PROG1, input_dev->keybit);
 +		__set_bit(KEY_PROG2, input_dev->keybit);
 +		__set_bit(KEY_PROG3, input_dev->keybit);
 +		/* fall through */
 +
  	case WACOM_21UX2:
 +		__set_bit(BTN_A, input_dev->keybit);
 +		__set_bit(BTN_B, input_dev->keybit);
 +		__set_bit(BTN_C, input_dev->keybit);
 +		__set_bit(BTN_X, input_dev->keybit);
 +		__set_bit(BTN_Y, input_dev->keybit);
 +		__set_bit(BTN_Z, input_dev->keybit);
 +		__set_bit(BTN_BASE, input_dev->keybit);
 +		__set_bit(BTN_BASE2, input_dev->keybit);
 +		/* fall through */
 +
  	case WACOM_BEE:
 +		__set_bit(BTN_8, input_dev->keybit);
 +		__set_bit(BTN_9, input_dev->keybit);
 +		/* fall through */
 +
  	case CINTIQ:
 +		for (i = 0; i < 8; i++)
 +			__set_bit(BTN_0 + i, input_dev->keybit);
 +
 +		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
 +		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
 +		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
 +
 +		wacom_setup_cintiq(wacom_wac);
 +		break;
 +
  	case WACOM_13HD:
 -	case CINTIQ_HYBRID:
 -	case CINTIQ_COMPANION_2:
 +		for (i = 0; i < 9; i++)
 +			__set_bit(BTN_0 + i, input_dev->keybit);
 +
  		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
++<<<<<<< HEAD
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
++=======
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
++>>>>>>> e5bc8eb1b022 (HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar)
  		wacom_setup_cintiq(wacom_wac);
  		break;
  
@@@ -1691,52 -2601,16 +2207,58 @@@
  	case INTUOS5L:
  	case INTUOSPM:
  	case INTUOSPL:
 +		if (features->device_type == BTN_TOOL_PEN) {
 +			__set_bit(BTN_7, input_dev->keybit);
 +			__set_bit(BTN_8, input_dev->keybit);
 +		}
 +		/* fall through */
 +
  	case INTUOS5S:
  	case INTUOSPS:
++<<<<<<< HEAD
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 +
 +		if (features->device_type == BTN_TOOL_PEN) {
 +			for (i = 0; i < 7; i++)
 +				__set_bit(BTN_0 + i, input_dev->keybit);
 +
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
 +
 +			input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +
 +			wacom_setup_intuos(wacom_wac);
 +		} else if (features->device_type == BTN_TOOL_FINGER) {
 +			__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
 +			                     0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,
 +			                     0, features->y_max, 0, 0);
 +			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
 +		}
 +		break;
 +
 +	case INTUOS4:
 +	case INTUOS4L:
 +		__set_bit(BTN_7, input_dev->keybit);
 +		__set_bit(BTN_8, input_dev->keybit);
 +		/* fall through */
 +
 +	case INTUOS4S:
 +		for (i = 0; i < 7; i++)
 +			__set_bit(BTN_0 + i, input_dev->keybit);
++=======
+ 		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 				      features->distance_max,
+ 				      features->distance_fuzz, 0);
++>>>>>>> e5bc8eb1b022 (HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar)
  
  		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 -		input_abs_set_res(input_dev, ABS_Z, 287);
 -
  		wacom_setup_intuos(wacom_wac);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
  	case WACOM_24HDT:
@@@ -1790,46 -2642,395 +2310,427 @@@
  		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
  		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
  		__set_bit(BTN_STYLUS, input_dev->keybit);
- 
- 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
 -	case INTUOSHT:
  	case BAMBOO_PT:
++<<<<<<< HEAD
 +		__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 +
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_POINTER;
 +
 +			__set_bit(BTN_LEFT, input_dev->keybit);
 +			__set_bit(BTN_FORWARD, input_dev->keybit);
 +			__set_bit(BTN_BACK, input_dev->keybit);
 +			__set_bit(BTN_RIGHT, input_dev->keybit);
 +
 +			if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MAJOR,
 +						     0, features->x_max, 0, 0);
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MINOR,
 +						     0, features->y_max, 0, 0);
 +			} else {
 +				__set_bit(BTN_TOOL_FINGER, input_dev->keybit);
 +				__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);
 +				flags = 0;
 +			}
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		} else if (features->device_type == BTN_TOOL_PEN) {
++=======
+ 	case BAMBOO_PEN:
+ 	case INTUOSHT2:
+ 		if (features->type == INTUOSHT2) {
+ 			wacom_setup_basic_pro_pen(wacom_wac);
+ 		} else {
+ 			__clear_bit(ABS_MISC, input_dev->absbit);
+ 			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
++>>>>>>> e5bc8eb1b022 (HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar)
  			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
  			__set_bit(BTN_STYLUS, input_dev->keybit);
  			__set_bit(BTN_STYLUS2, input_dev->keybit);
  			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 -				      features->distance_max,
 -				      features->distance_fuzz, 0);
 +					      features->distance_max,
 +					      0, 0);
  		}
  		break;
++<<<<<<< HEAD
++=======
+ 	case BAMBOO_PAD:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
+ 					 struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_TOUCH))
+ 		return -ENODEV;
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_DIRECT)
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 	else
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 	if (features->type == HID_GENERIC)
+ 		/* setup has already been done */
+ 		return 0;
+ 
+ 	__set_bit(BTN_TOUCH, input_dev->keybit);
+ 
+ 	if (features->touch_max == 1) {
+ 		input_set_abs_params(input_dev, ABS_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_Y,
+ 				  features->y_resolution);
+ 	}
+ 	else if (features->touch_max > 1) {
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
+ 				  features->y_resolution);
+ 	}
+ 
+ 	switch (features->type) {
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		/* fall through */
+ 
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/*fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case INTUOSHT2:
+ 		input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 		__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 	case BAMBOO_TOUCH:
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MAJOR,
+ 				     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MINOR,
+ 				     0, features->y_max, 0, 0);
+ 		}
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case BAMBOO_PAD:
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static void wacom_setup_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		__set_bit(BTN_0 + i, input_dev->keybit);
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		__set_bit(BTN_A + (i-10), input_dev->keybit);
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		__set_bit(BTN_BASE + (i-16), input_dev->keybit);
+ }
+ 
+ static void wacom_24hd_update_leds(struct wacom *wacom, int mask, int group)
+ {
+ 	struct wacom_led *led;
+ 	int i;
+ 	bool updated = false;
+ 
+ 	/*
+ 	 * 24HD has LED group 1 to the left and LED group 0 to the right.
+ 	 * So group 0 matches the second half of the buttons and thus the mask
+ 	 * needs to be shifted.
+ 	 */
+ 	if (group == 0)
+ 		mask >>= 8;
+ 
+ 	for (i = 0; i < 3; i++) {
+ 		led = wacom_led_find(wacom, group, i);
+ 		if (!led) {
+ 			hid_err(wacom->hdev, "can't find LED %d in group %d\n",
+ 				i, group);
+ 			continue;
+ 		}
+ 		if (!updated && mask & BIT(i)) {
+ 			led->held = true;
+ 			led_trigger_event(&led->trigger, LED_FULL);
+ 		} else {
+ 			led->held = false;
+ 		}
+ 	}
+ }
+ 
+ static bool wacom_is_led_toggled(struct wacom *wacom, int button_count,
+ 				 int mask, int group)
+ {
+ 	int button_per_group;
+ 
+ 	/*
+ 	 * 21UX2 has LED group 1 to the left and LED group 0
+ 	 * to the right. We need to reverse the group to match this
+ 	 * historical behavior.
+ 	 */
+ 	if (wacom->wacom_wac.features.type == WACOM_21UX2)
+ 		group = 1 - group;
+ 
+ 	button_per_group = button_count/wacom->led.count;
+ 
+ 	return mask & (1 << (group * button_per_group));
+ }
+ 
+ static void wacom_update_led(struct wacom *wacom, int button_count, int mask,
+ 			     int group)
+ {
+ 	struct wacom_led *led, *next_led;
+ 	int cur;
+ 	bool pressed;
+ 
+ 	if (wacom->wacom_wac.features.type == WACOM_24HD)
+ 		return wacom_24hd_update_leds(wacom, mask, group);
+ 
+ 	pressed = wacom_is_led_toggled(wacom, button_count, mask, group);
+ 	cur = wacom->led.groups[group].select;
+ 
+ 	led = wacom_led_find(wacom, group, cur);
+ 	if (!led) {
+ 		hid_err(wacom->hdev, "can't find current LED %d in group %d\n",
+ 			cur, group);
+ 		return;
+ 	}
+ 
+ 	if (!pressed) {
+ 		led->held = false;
+ 		return;
+ 	}
+ 
+ 	if (led->held && pressed)
+ 		return;
+ 
+ 	next_led = wacom_led_next(wacom, led);
+ 	if (!next_led) {
+ 		hid_err(wacom->hdev, "can't find next LED in group %d\n",
+ 			group);
+ 		return;
+ 	}
+ 	if (next_led == led)
+ 		return;
+ 
+ 	next_led->held = true;
+ 	led_trigger_event(&next_led->trigger,
+ 			  wacom_leds_brightness_get(next_led));
+ }
+ 
+ static void wacom_report_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count, int mask)
+ {
+ 	struct wacom *wacom = input_get_drvdata(input_dev);
+ 	int i;
+ 
+ 	for (i = 0; i < wacom->led.count; i++)
+ 		wacom_update_led(wacom,  button_count, mask, i);
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		input_report_key(input_dev, BTN_0 + i, mask & (1 << i));
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		input_report_key(input_dev, BTN_A + (i-10), mask & (1 << i));
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		input_report_key(input_dev, BTN_BASE + (i-16), mask & (1 << i));
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PAD))
+ 		return -ENODEV;
+ 
+ 	if (features->type == REMOTE && input_dev == wacom_wac->pad_input)
+ 		return -ENODEV;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	wacom_setup_numbered_buttons(input_dev, features->numbered_buttons);
+ 
+ 	switch (features->type) {
+ 
+ 	case CINTIQ_HYBRID:
+ 	case CINTIQ_COMPANION_2:
+ 	case DTK:
+ 	case DTUS:
+ 	case GRAPHIRE_BT:
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
+ 	case WACOM_24HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_27QHD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_X, 1024); /* points/g */
+ 		input_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Y, 1024);
+ 		input_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 1024);
+ 		__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);
+ 		break;
+ 
+ 	case WACOM_22HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case WACOM_13HD:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		/* fall through */
+ 
+ 	case INTUOS3S:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS4WL:
+ 		/*
+ 		 * For Bluetooth devices, the udev rule does not work correctly
+ 		 * for pads unless we add a stylus capability, which forces
+ 		 * ID_INPUT_TABLET to be set.
+ 		 */
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case INTUOS4:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
+ 	case BAMBOO_TOUCH:
+ 	case INTUOSHT2:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 		break;
+ 
+ 	case REMOTE:
+ 		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	default:
+ 		/* no pad supported */
+ 		return -ENODEV;
++>>>>>>> e5bc8eb1b022 (HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar)
  	}
  	return 0;
  }
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,de5d1adafc6b..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -53,16 -54,53 +53,47 @@@
  #define WACOM_REPORT_TPC1FG		6
  #define WACOM_REPORT_TPC2FG		13
  #define WACOM_REPORT_TPCMT		13
 -#define WACOM_REPORT_TPCMT2		3
  #define WACOM_REPORT_TPCHID		15
 -#define WACOM_REPORT_CINTIQ		16
 -#define WACOM_REPORT_CINTIQPAD		17
  #define WACOM_REPORT_TPCST		16
 -#define WACOM_REPORT_DTUS		17
  #define WACOM_REPORT_TPC1FGE		18
  #define WACOM_REPORT_24HDT		1
 -#define WACOM_REPORT_WL			128
 -#define WACOM_REPORT_USB		192
 -#define WACOM_REPORT_BPAD_PEN		3
 -#define WACOM_REPORT_BPAD_TOUCH		16
 -#define WACOM_REPORT_DEVICE_LIST	16
 -#define WACOM_REPORT_INTUOS_PEN		16
 -#define WACOM_REPORT_REMOTE		17
 -#define WACOM_REPORT_INTUOSHT2_ID	8
  
  /* device quirks */
++<<<<<<< HEAD
 +#define WACOM_QUIRK_MULTI_INPUT		0x0001
 +#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0002
 +#define WACOM_QUIRK_NO_INPUT		0x0004
 +#define WACOM_QUIRK_MONITOR		0x0008
++=======
+ #define WACOM_QUIRK_BBTOUCH_LOWRES	0x0001
+ #define WACOM_QUIRK_BATTERY		0x0008
+ 
+ /* device types */
+ #define WACOM_DEVICETYPE_NONE           0x0000
+ #define WACOM_DEVICETYPE_PEN            0x0001
+ #define WACOM_DEVICETYPE_TOUCH          0x0002
+ #define WACOM_DEVICETYPE_PAD            0x0004
+ #define WACOM_DEVICETYPE_WL_MONITOR     0x0008
+ #define WACOM_DEVICETYPE_DIRECT         0x0010
+ 
+ #define WACOM_VENDORDEFINED_PEN		0xff0d0001
+ #define WACOM_G9_PAGE			0xff090000
+ #define WACOM_G9_DIGITIZER		(WACOM_G9_PAGE | 0x02)
+ #define WACOM_G9_TOUCHSCREEN		(WACOM_G9_PAGE | 0x11)
+ #define WACOM_G11_PAGE			0xff110000
+ #define WACOM_G11_DIGITIZER		(WACOM_G11_PAGE | 0x02)
+ #define WACOM_G11_TOUCHSCREEN		(WACOM_G11_PAGE | 0x11)
+ 
+ #define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_PEN) || \
+ 				 ((f)->application == HID_DG_PEN) || \
+ 				 ((f)->application == HID_DG_DIGITIZER) || \
+ 				 ((f)->application == WACOM_VENDORDEFINED_PEN))
+ #define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
+ 				 ((f)->physical == HID_DG_FINGER) || \
+ 				 ((f)->application == HID_DG_TOUCHSCREEN))
++>>>>>>> e5bc8eb1b022 (HID: wacom: Add WACOM_DEVICETYPE_DIRECT for Cintiqs and similar)
  
  enum {
  	PENPARTNER = 0,
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
