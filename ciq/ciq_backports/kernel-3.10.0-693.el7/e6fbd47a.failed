amd-xgbe: Fix mask appliciation for Clause 37 register

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit e6fbd47add0d13189bacb1881fe006db5027536e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e6fbd47a.failed

The application of a mask to clear an area of a clause 37 register value
was not properly applied. Update the code to do the proper application
of the mask.

	Reported-by: Marion & Christophe JAILLET <christophe.jaillet@wanadoo.fr>
	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e6fbd47add0d13189bacb1881fe006db5027536e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
index 8514b5841ecd,4c5b90eea4af..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
@@@ -124,73 -125,972 +124,1003 @@@
  #include "xgbe.h"
  #include "xgbe-common.h"
  
 -static void xgbe_an37_clear_interrupts(struct xgbe_prv_data *pdata)
 +
 +static int xgbe_mdio_read(struct mii_bus *mii, int prtad, int mmd_reg)
  {
 -	int reg;
 +	struct xgbe_prv_data *pdata = mii->priv;
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	int mmd_data;
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT);
 -	reg &= ~XGBE_AN_CL37_INT_MASK;
 -	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT, reg);
 +	DBGPR_MDIO("-->xgbe_mdio_read: prtad=%#x mmd_reg=%#x\n",
 +		   prtad, mmd_reg);
 +
 +	mmd_data = hw_if->read_mmd_regs(pdata, prtad, mmd_reg);
 +
 +	DBGPR_MDIO("<--xgbe_mdio_read: mmd_data=%#x\n", mmd_data);
 +
 +	return mmd_data;
  }
  
 -static void xgbe_an37_disable_interrupts(struct xgbe_prv_data *pdata)
 +static int xgbe_mdio_write(struct mii_bus *mii, int prtad, int mmd_reg,
 +			   u16 mmd_val)
  {
 -	int reg;
 +	struct xgbe_prv_data *pdata = mii->priv;
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	int mmd_data = mmd_val;
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
 -	reg &= ~XGBE_AN_CL37_INT_MASK;
 -	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
 +	DBGPR_MDIO("-->xgbe_mdio_write: prtad=%#x mmd_reg=%#x mmd_data=%#x\n",
 +		   prtad, mmd_reg, mmd_data);
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL);
 -	reg &= ~XGBE_PCS_CL37_BP;
 -	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL, reg);
 +	hw_if->write_mmd_regs(pdata, prtad, mmd_reg, mmd_data);
 +
 +	DBGPR_MDIO("<--xgbe_mdio_write\n");
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static void xgbe_adjust_link(struct net_device *netdev)
++=======
+ static void xgbe_an37_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL);
+ 	reg |= XGBE_PCS_CL37_BP;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL, reg);
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
+ 	reg |= XGBE_AN_CL37_INT_MASK;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
+ }
+ 
+ static void xgbe_an73_clear_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, 0);
+ }
+ 
+ static void xgbe_an73_disable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, 0);
+ }
+ 
+ static void xgbe_an73_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, XGBE_AN_CL73_INT_MASK);
+ }
+ 
+ static void xgbe_an_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 	case XGBE_AN_MODE_CL73_REDRV:
+ 		xgbe_an73_enable_interrupts(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_enable_interrupts(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_clear_interrupts_all(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_clear_interrupts(pdata);
+ 	xgbe_an37_clear_interrupts(pdata);
+ }
+ 
+ static void xgbe_an73_enable_kr_training(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 
+ 	reg |= XGBE_KR_TRAINING_ENABLE;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, reg);
+ }
+ 
+ static void xgbe_an73_disable_kr_training(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 
+ 	reg &= ~XGBE_KR_TRAINING_ENABLE;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, reg);
+ }
+ 
+ static void xgbe_kr_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Enable KR training */
+ 	xgbe_an73_enable_kr_training(pdata);
+ 
+ 	/* Set MAC to 10G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_10000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KR);
+ }
+ 
+ static void xgbe_kx_2500_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 2.5G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_2500);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KX_2500);
+ }
+ 
+ static void xgbe_kx_1000_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KX_1000);
+ }
+ 
+ static void xgbe_sfi_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* If a KR re-driver is present, change to KR mode instead */
+ 	if (pdata->kr_redrv)
+ 		return xgbe_kr_mode(pdata);
+ 
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 10G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_10000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SFI);
+ }
+ 
+ static void xgbe_x_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_X);
+ }
+ 
+ static void xgbe_sgmii_1000_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SGMII_1000);
+ }
+ 
+ static void xgbe_sgmii_100_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_SGMII_100);
+ }
+ 
+ static enum xgbe_mode xgbe_cur_mode(struct xgbe_prv_data *pdata)
+ {
+ 	return pdata->phy_if.phy_impl.cur_mode(pdata);
+ }
+ 
+ static bool xgbe_in_kr_mode(struct xgbe_prv_data *pdata)
+ {
+ 	return (xgbe_cur_mode(pdata) == XGBE_MODE_KR);
+ }
+ 
+ static void xgbe_change_mode(struct xgbe_prv_data *pdata,
+ 			     enum xgbe_mode mode)
+ {
+ 	switch (mode) {
+ 	case XGBE_MODE_KX_1000:
+ 		xgbe_kx_1000_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_KX_2500:
+ 		xgbe_kx_2500_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_KR:
+ 		xgbe_kr_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_SGMII_100:
+ 		xgbe_sgmii_100_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_SGMII_1000:
+ 		xgbe_sgmii_1000_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_X:
+ 		xgbe_x_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_SFI:
+ 		xgbe_sfi_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_UNKNOWN:
+ 		break;
+ 	default:
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "invalid operation mode requested (%u)\n", mode);
+ 	}
+ }
+ 
+ static void xgbe_switch_mode(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_change_mode(pdata, pdata->phy_if.phy_impl.switch_mode(pdata));
+ }
+ 
+ static void xgbe_set_mode(struct xgbe_prv_data *pdata,
+ 			  enum xgbe_mode mode)
+ {
+ 	if (mode == xgbe_cur_mode(pdata))
+ 		return;
+ 
+ 	xgbe_change_mode(pdata, mode);
+ }
+ 
+ static bool xgbe_use_mode(struct xgbe_prv_data *pdata,
+ 			  enum xgbe_mode mode)
+ {
+ 	return pdata->phy_if.phy_impl.use_mode(pdata, mode);
+ }
+ 
+ static void xgbe_an37_set(struct xgbe_prv_data *pdata, bool enable,
+ 			  bool restart)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_CTRL1);
+ 	reg &= ~MDIO_VEND2_CTRL1_AN_ENABLE;
+ 
+ 	if (enable)
+ 		reg |= MDIO_VEND2_CTRL1_AN_ENABLE;
+ 
+ 	if (restart)
+ 		reg |= MDIO_VEND2_CTRL1_AN_RESTART;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_CTRL1, reg);
+ }
+ 
+ static void xgbe_an37_restart(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an37_enable_interrupts(pdata);
+ 	xgbe_an37_set(pdata, true, true);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN enabled/restarted\n");
+ }
+ 
+ static void xgbe_an37_disable(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an37_set(pdata, false, false);
+ 	xgbe_an37_disable_interrupts(pdata);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN disabled\n");
+ }
+ 
+ static void xgbe_an73_set(struct xgbe_prv_data *pdata, bool enable,
+ 			  bool restart)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1);
+ 	reg &= ~MDIO_AN_CTRL1_ENABLE;
+ 
+ 	if (enable)
+ 		reg |= MDIO_AN_CTRL1_ENABLE;
+ 
+ 	if (restart)
+ 		reg |= MDIO_AN_CTRL1_RESTART;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_CTRL1, reg);
+ }
+ 
+ static void xgbe_an73_restart(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_enable_interrupts(pdata);
+ 	xgbe_an73_set(pdata, true, true);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN enabled/restarted\n");
+ }
+ 
+ static void xgbe_an73_disable(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_set(pdata, false, false);
+ 	xgbe_an73_disable_interrupts(pdata);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN disabled\n");
+ }
+ 
+ static void xgbe_an_restart(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 	case XGBE_AN_MODE_CL73_REDRV:
+ 		xgbe_an73_restart(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_restart(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_disable(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 	case XGBE_AN_MODE_CL73_REDRV:
+ 		xgbe_an73_disable(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_disable(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_disable_all(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_disable(pdata);
+ 	xgbe_an37_disable(pdata);
+ }
+ 
+ static enum xgbe_an xgbe_an73_tx_training(struct xgbe_prv_data *pdata,
+ 					  enum xgbe_rx *state)
+ {
+ 	unsigned int ad_reg, lp_reg, reg;
+ 
+ 	*state = XGBE_RX_COMPLETE;
+ 
+ 	/* If we're not in KR mode then we're done */
+ 	if (!xgbe_in_kr_mode(pdata))
+ 		return XGBE_AN_PAGE_RECEIVED;
+ 
+ 	/* Enable/Disable FEC */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 2);
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_FECCTRL);
+ 	reg &= ~(MDIO_PMA_10GBR_FECABLE_ABLE | MDIO_PMA_10GBR_FECABLE_ERRABLE);
+ 	if ((ad_reg & 0xc000) && (lp_reg & 0xc000))
+ 		reg |= pdata->fec_ability;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_FECCTRL, reg);
+ 
+ 	/* Start KR training */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 	if (reg & XGBE_KR_TRAINING_ENABLE) {
+ 		if (pdata->phy_if.phy_impl.kr_training_pre)
+ 			pdata->phy_if.phy_impl.kr_training_pre(pdata);
+ 
+ 		reg |= XGBE_KR_TRAINING_START;
+ 		XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL,
+ 			    reg);
+ 
+ 		if (pdata->phy_if.phy_impl.kr_training_post)
+ 			pdata->phy_if.phy_impl.kr_training_post(pdata);
+ 
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "KR training initiated\n");
+ 	}
+ 
+ 	return XGBE_AN_PAGE_RECEIVED;
+ }
+ 
+ static enum xgbe_an xgbe_an73_tx_xnp(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	u16 msg;
+ 
+ 	*state = XGBE_RX_XNP;
+ 
+ 	msg = XGBE_XNP_MCF_NULL_MESSAGE;
+ 	msg |= XGBE_XNP_MP_FORMATTED;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP + 2, 0);
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP + 1, 0);
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP, msg);
+ 
+ 	return XGBE_AN_PAGE_RECEIVED;
+ }
+ 
+ static enum xgbe_an xgbe_an73_rx_bpa(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	unsigned int link_support;
+ 	unsigned int reg, ad_reg, lp_reg;
+ 
+ 	/* Read Base Ability register 2 first */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 1);
+ 
+ 	/* Check for a supported mode, otherwise restart in a different one */
+ 	link_support = xgbe_in_kr_mode(pdata) ? 0x80 : 0x20;
+ 	if (!(reg & link_support))
+ 		return XGBE_AN_INCOMPAT_LINK;
+ 
+ 	/* Check Extended Next Page support */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA);
+ 
+ 	return ((ad_reg & XGBE_XNP_NP_EXCHANGE) ||
+ 		(lp_reg & XGBE_XNP_NP_EXCHANGE))
+ 	       ? xgbe_an73_tx_xnp(pdata, state)
+ 	       : xgbe_an73_tx_training(pdata, state);
+ }
+ 
+ static enum xgbe_an xgbe_an73_rx_xnp(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	unsigned int ad_reg, lp_reg;
+ 
+ 	/* Check Extended Next Page support */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_XNP);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPX);
+ 
+ 	return ((ad_reg & XGBE_XNP_NP_EXCHANGE) ||
+ 		(lp_reg & XGBE_XNP_NP_EXCHANGE))
+ 	       ? xgbe_an73_tx_xnp(pdata, state)
+ 	       : xgbe_an73_tx_training(pdata, state);
+ }
+ 
+ static enum xgbe_an xgbe_an73_page_received(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_rx *state;
+ 	unsigned long an_timeout;
+ 	enum xgbe_an ret;
+ 
+ 	if (!pdata->an_start) {
+ 		pdata->an_start = jiffies;
+ 	} else {
+ 		an_timeout = pdata->an_start +
+ 			     msecs_to_jiffies(XGBE_AN_MS_TIMEOUT);
+ 		if (time_after(jiffies, an_timeout)) {
+ 			/* Auto-negotiation timed out, reset state */
+ 			pdata->kr_state = XGBE_RX_BPA;
+ 			pdata->kx_state = XGBE_RX_BPA;
+ 
+ 			pdata->an_start = jiffies;
+ 
+ 			netif_dbg(pdata, link, pdata->netdev,
+ 				  "CL73 AN timed out, resetting state\n");
+ 		}
+ 	}
+ 
+ 	state = xgbe_in_kr_mode(pdata) ? &pdata->kr_state
+ 				       : &pdata->kx_state;
+ 
+ 	switch (*state) {
+ 	case XGBE_RX_BPA:
+ 		ret = xgbe_an73_rx_bpa(pdata, state);
+ 		break;
+ 
+ 	case XGBE_RX_XNP:
+ 		ret = xgbe_an73_rx_xnp(pdata, state);
+ 		break;
+ 
+ 	default:
+ 		ret = XGBE_AN_ERROR;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static enum xgbe_an xgbe_an73_incompat_link(struct xgbe_prv_data *pdata)
+ {
+ 	/* Be sure we aren't looping trying to negotiate */
+ 	if (xgbe_in_kr_mode(pdata)) {
+ 		pdata->kr_state = XGBE_RX_ERROR;
+ 
+ 		if (!(pdata->phy.advertising & ADVERTISED_1000baseKX_Full) &&
+ 		    !(pdata->phy.advertising & ADVERTISED_2500baseX_Full))
+ 			return XGBE_AN_NO_LINK;
+ 
+ 		if (pdata->kx_state != XGBE_RX_BPA)
+ 			return XGBE_AN_NO_LINK;
+ 	} else {
+ 		pdata->kx_state = XGBE_RX_ERROR;
+ 
+ 		if (!(pdata->phy.advertising & ADVERTISED_10000baseKR_Full))
+ 			return XGBE_AN_NO_LINK;
+ 
+ 		if (pdata->kr_state != XGBE_RX_BPA)
+ 			return XGBE_AN_NO_LINK;
+ 	}
+ 
+ 	xgbe_an73_disable(pdata);
+ 
+ 	xgbe_switch_mode(pdata);
+ 
+ 	xgbe_an73_restart(pdata);
+ 
+ 	return XGBE_AN_INCOMPAT_LINK;
+ }
+ 
+ static void xgbe_an37_isr(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	/* Disable AN interrupts */
+ 	xgbe_an37_disable_interrupts(pdata);
+ 
+ 	/* Save the interrupt(s) that fired */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT);
+ 	pdata->an_int = reg & XGBE_AN_CL37_INT_MASK;
+ 	pdata->an_status = reg & ~XGBE_AN_CL37_INT_MASK;
+ 
+ 	if (pdata->an_int) {
+ 		/* Clear the interrupt(s) that fired and process them */
+ 		reg &= ~XGBE_AN_CL37_INT_MASK;
+ 		XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT, reg);
+ 
+ 		queue_work(pdata->an_workqueue, &pdata->an_irq_work);
+ 	} else {
+ 		/* Enable AN interrupts */
+ 		xgbe_an37_enable_interrupts(pdata);
+ 	}
+ }
+ 
+ static void xgbe_an73_isr(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable AN interrupts */
+ 	xgbe_an73_disable_interrupts(pdata);
+ 
+ 	/* Save the interrupt(s) that fired */
+ 	pdata->an_int = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_INT);
+ 
+ 	if (pdata->an_int) {
+ 		/* Clear the interrupt(s) that fired and process them */
+ 		XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, ~pdata->an_int);
+ 
+ 		queue_work(pdata->an_workqueue, &pdata->an_irq_work);
+ 	} else {
+ 		/* Enable AN interrupts */
+ 		xgbe_an73_enable_interrupts(pdata);
+ 	}
+ }
+ 
+ static irqreturn_t xgbe_an_isr(int irq, void *data)
+ {
+ 	struct xgbe_prv_data *pdata = (struct xgbe_prv_data *)data;
+ 
+ 	netif_dbg(pdata, intr, pdata->netdev, "AN interrupt received\n");
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 	case XGBE_AN_MODE_CL73_REDRV:
+ 		xgbe_an73_isr(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_isr(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static irqreturn_t xgbe_an_combined_isr(int irq, struct xgbe_prv_data *pdata)
+ {
+ 	return xgbe_an_isr(irq, pdata);
+ }
+ 
+ static void xgbe_an_irq_work(struct work_struct *work)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(work,
+ 						   struct xgbe_prv_data,
+ 						   an_irq_work);
+ 
+ 	/* Avoid a race between enabling the IRQ and exiting the work by
+ 	 * waiting for the work to finish and then queueing it
+ 	 */
+ 	flush_work(&pdata->an_work);
+ 	queue_work(pdata->an_workqueue, &pdata->an_work);
+ }
+ 
+ static const char *xgbe_state_as_string(enum xgbe_an state)
+ {
+ 	switch (state) {
+ 	case XGBE_AN_READY:
+ 		return "Ready";
+ 	case XGBE_AN_PAGE_RECEIVED:
+ 		return "Page-Received";
+ 	case XGBE_AN_INCOMPAT_LINK:
+ 		return "Incompatible-Link";
+ 	case XGBE_AN_COMPLETE:
+ 		return "Complete";
+ 	case XGBE_AN_NO_LINK:
+ 		return "No-Link";
+ 	case XGBE_AN_ERROR:
+ 		return "Error";
+ 	default:
+ 		return "Undefined";
+ 	}
+ }
+ 
+ static void xgbe_an37_state_machine(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_an cur_state = pdata->an_state;
+ 
+ 	if (!pdata->an_int)
+ 		return;
+ 
+ 	if (pdata->an_int & XGBE_AN_CL37_INT_CMPLT) {
+ 		pdata->an_state = XGBE_AN_COMPLETE;
+ 		pdata->an_int &= ~XGBE_AN_CL37_INT_CMPLT;
+ 
+ 		/* If SGMII is enabled, check the link status */
+ 		if ((pdata->an_mode == XGBE_AN_MODE_CL37_SGMII) &&
+ 		    !(pdata->an_status & XGBE_SGMII_AN_LINK_STATUS))
+ 			pdata->an_state = XGBE_AN_NO_LINK;
+ 	}
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN %s\n",
+ 		  xgbe_state_as_string(pdata->an_state));
+ 
+ 	cur_state = pdata->an_state;
+ 
+ 	switch (pdata->an_state) {
+ 	case XGBE_AN_READY:
+ 		break;
+ 
+ 	case XGBE_AN_COMPLETE:
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "Auto negotiation successful\n");
+ 		break;
+ 
+ 	case XGBE_AN_NO_LINK:
+ 		break;
+ 
+ 	default:
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ 	if (pdata->an_state == XGBE_AN_ERROR) {
+ 		netdev_err(pdata->netdev,
+ 			   "error during auto-negotiation, state=%u\n",
+ 			   cur_state);
+ 
+ 		pdata->an_int = 0;
+ 		xgbe_an37_clear_interrupts(pdata);
+ 	}
+ 
+ 	if (pdata->an_state >= XGBE_AN_COMPLETE) {
+ 		pdata->an_result = pdata->an_state;
+ 		pdata->an_state = XGBE_AN_READY;
+ 
+ 		netif_dbg(pdata, link, pdata->netdev, "CL37 AN result: %s\n",
+ 			  xgbe_state_as_string(pdata->an_result));
+ 	}
+ 
+ 	xgbe_an37_enable_interrupts(pdata);
+ }
+ 
+ static void xgbe_an73_state_machine(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_an cur_state = pdata->an_state;
+ 
+ 	if (!pdata->an_int)
+ 		return;
+ 
+ next_int:
+ 	if (pdata->an_int & XGBE_AN_CL73_PG_RCV) {
+ 		pdata->an_state = XGBE_AN_PAGE_RECEIVED;
+ 		pdata->an_int &= ~XGBE_AN_CL73_PG_RCV;
+ 	} else if (pdata->an_int & XGBE_AN_CL73_INC_LINK) {
+ 		pdata->an_state = XGBE_AN_INCOMPAT_LINK;
+ 		pdata->an_int &= ~XGBE_AN_CL73_INC_LINK;
+ 	} else if (pdata->an_int & XGBE_AN_CL73_INT_CMPLT) {
+ 		pdata->an_state = XGBE_AN_COMPLETE;
+ 		pdata->an_int &= ~XGBE_AN_CL73_INT_CMPLT;
+ 	} else {
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ again:
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN %s\n",
+ 		  xgbe_state_as_string(pdata->an_state));
+ 
+ 	cur_state = pdata->an_state;
+ 
+ 	switch (pdata->an_state) {
+ 	case XGBE_AN_READY:
+ 		pdata->an_supported = 0;
+ 		break;
+ 
+ 	case XGBE_AN_PAGE_RECEIVED:
+ 		pdata->an_state = xgbe_an73_page_received(pdata);
+ 		pdata->an_supported++;
+ 		break;
+ 
+ 	case XGBE_AN_INCOMPAT_LINK:
+ 		pdata->an_supported = 0;
+ 		pdata->parallel_detect = 0;
+ 		pdata->an_state = xgbe_an73_incompat_link(pdata);
+ 		break;
+ 
+ 	case XGBE_AN_COMPLETE:
+ 		pdata->parallel_detect = pdata->an_supported ? 0 : 1;
+ 		netif_dbg(pdata, link, pdata->netdev, "%s successful\n",
+ 			  pdata->an_supported ? "Auto negotiation"
+ 					      : "Parallel detection");
+ 		break;
+ 
+ 	case XGBE_AN_NO_LINK:
+ 		break;
+ 
+ 	default:
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ 	if (pdata->an_state == XGBE_AN_NO_LINK) {
+ 		pdata->an_int = 0;
+ 		xgbe_an73_clear_interrupts(pdata);
+ 	} else if (pdata->an_state == XGBE_AN_ERROR) {
+ 		netdev_err(pdata->netdev,
+ 			   "error during auto-negotiation, state=%u\n",
+ 			   cur_state);
+ 
+ 		pdata->an_int = 0;
+ 		xgbe_an73_clear_interrupts(pdata);
+ 	}
+ 
+ 	if (pdata->an_state >= XGBE_AN_COMPLETE) {
+ 		pdata->an_result = pdata->an_state;
+ 		pdata->an_state = XGBE_AN_READY;
+ 		pdata->kr_state = XGBE_RX_BPA;
+ 		pdata->kx_state = XGBE_RX_BPA;
+ 		pdata->an_start = 0;
+ 
+ 		netif_dbg(pdata, link, pdata->netdev, "CL73 AN result: %s\n",
+ 			  xgbe_state_as_string(pdata->an_result));
+ 	}
+ 
+ 	if (cur_state != pdata->an_state)
+ 		goto again;
+ 
+ 	if (pdata->an_int)
+ 		goto next_int;
+ 
+ 	xgbe_an73_enable_interrupts(pdata);
+ }
+ 
+ static void xgbe_an_state_machine(struct work_struct *work)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(work,
+ 						   struct xgbe_prv_data,
+ 						   an_work);
+ 
+ 	mutex_lock(&pdata->an_mutex);
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 	case XGBE_AN_MODE_CL73_REDRV:
+ 		xgbe_an73_state_machine(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_state_machine(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	mutex_unlock(&pdata->an_mutex);
+ }
+ 
+ static void xgbe_an37_init(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int advertising, reg;
+ 
+ 	advertising = pdata->phy_if.phy_impl.an_advertising(pdata);
+ 
+ 	/* Set up Advertisement register */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE);
+ 	if (advertising & ADVERTISED_Pause)
+ 		reg |= 0x100;
+ 	else
+ 		reg &= ~0x100;
+ 
+ 	if (advertising & ADVERTISED_Asym_Pause)
+ 		reg |= 0x80;
+ 	else
+ 		reg &= ~0x80;
+ 
+ 	/* Full duplex, but not half */
+ 	reg |= XGBE_AN_CL37_FD_MASK;
+ 	reg &= ~XGBE_AN_CL37_HD_MASK;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE, reg);
+ 
+ 	/* Set up the Control register */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
+ 	reg &= ~XGBE_AN_CL37_TX_CONFIG_MASK;
+ 	reg &= ~XGBE_AN_CL37_PCS_MODE_MASK;
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL37:
+ 		reg |= XGBE_AN_CL37_PCS_MODE_BASEX;
+ 		break;
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		reg |= XGBE_AN_CL37_PCS_MODE_SGMII;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN (%s) initialized\n",
+ 		  (pdata->an_mode == XGBE_AN_MODE_CL37) ? "BaseX" : "SGMII");
+ }
+ 
+ static void xgbe_an73_init(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int advertising, reg;
+ 
+ 	advertising = pdata->phy_if.phy_impl.an_advertising(pdata);
+ 
+ 	/* Set up Advertisement register 3 first */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);
+ 	if (advertising & ADVERTISED_10000baseR_FEC)
+ 		reg |= 0xc000;
+ 	else
+ 		reg &= ~0xc000;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2, reg);
+ 
+ 	/* Set up Advertisement register 2 next */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1);
+ 	if (advertising & ADVERTISED_10000baseKR_Full)
+ 		reg |= 0x80;
+ 	else
+ 		reg &= ~0x80;
+ 
+ 	if ((advertising & ADVERTISED_1000baseKX_Full) ||
+ 	    (advertising & ADVERTISED_2500baseX_Full))
+ 		reg |= 0x20;
+ 	else
+ 		reg &= ~0x20;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1, reg);
+ 
+ 	/* Set up Advertisement register 1 last */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);
+ 	if (advertising & ADVERTISED_Pause)
+ 		reg |= 0x400;
+ 	else
+ 		reg &= ~0x400;
+ 
+ 	if (advertising & ADVERTISED_Asym_Pause)
+ 		reg |= 0x800;
+ 	else
+ 		reg &= ~0x800;
+ 
+ 	/* We don't intend to perform XNP */
+ 	reg &= ~XGBE_XNP_NP_EXCHANGE;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN initialized\n");
+ }
+ 
+ static void xgbe_an_init(struct xgbe_prv_data *pdata)
+ {
+ 	/* Set up advertisement registers based on current settings */
+ 	pdata->an_mode = pdata->phy_if.phy_impl.an_mode(pdata);
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 	case XGBE_AN_MODE_CL73_REDRV:
+ 		xgbe_an73_init(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_init(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static const char *xgbe_phy_fc_string(struct xgbe_prv_data *pdata)
+ {
+ 	if (pdata->tx_pause && pdata->rx_pause)
+ 		return "rx/tx";
+ 	else if (pdata->rx_pause)
+ 		return "rx";
+ 	else if (pdata->tx_pause)
+ 		return "tx";
+ 	else
+ 		return "off";
+ }
+ 
+ static const char *xgbe_phy_speed_string(int speed)
+ {
+ 	switch (speed) {
+ 	case SPEED_100:
+ 		return "100Mbps";
+ 	case SPEED_1000:
+ 		return "1Gbps";
+ 	case SPEED_2500:
+ 		return "2.5Gbps";
+ 	case SPEED_10000:
+ 		return "10Gbps";
+ 	case SPEED_UNKNOWN:
+ 		return "Unknown";
+ 	default:
+ 		return "Unsupported";
+ 	}
+ }
+ 
+ static void xgbe_phy_print_status(struct xgbe_prv_data *pdata)
+ {
+ 	if (pdata->phy.link)
+ 		netdev_info(pdata->netdev,
+ 			    "Link is Up - %s/%s - flow control %s\n",
+ 			    xgbe_phy_speed_string(pdata->phy.speed),
+ 			    pdata->phy.duplex == DUPLEX_FULL ? "Full" : "Half",
+ 			    xgbe_phy_fc_string(pdata));
+ 	else
+ 		netdev_info(pdata->netdev, "Link is Down\n");
+ }
+ 
+ static void xgbe_phy_adjust_link(struct xgbe_prv_data *pdata)
++>>>>>>> e6fbd47add0d (amd-xgbe: Fix mask appliciation for Clause 37 register)
  {
 +	struct xgbe_prv_data *pdata = netdev_priv(netdev);
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	struct phy_device *phydev = pdata->phydev;
  	int new_state = 0;
  
 -	if (pdata->phy.link) {
 +	if (phydev == NULL)
 +		return;
 +
 +	DBGPR_MDIO("-->xgbe_adjust_link: address=%d, newlink=%d, curlink=%d\n",
 +		   phydev->addr, phydev->link, pdata->phy_link);
 +
 +	if (phydev->link) {
  		/* Flow control support */
 -		pdata->pause_autoneg = pdata->phy.pause_autoneg;
 +		if (pdata->pause_autoneg) {
 +			if (phydev->pause || phydev->asym_pause) {
 +				pdata->tx_pause = 1;
 +				pdata->rx_pause = 1;
 +			} else {
 +				pdata->tx_pause = 0;
 +				pdata->rx_pause = 0;
 +			}
 +		}
  
 -		if (pdata->tx_pause != pdata->phy.tx_pause) {
 -			new_state = 1;
 -			pdata->hw_if.config_tx_flow_control(pdata);
 -			pdata->tx_pause = pdata->phy.tx_pause;
 +		if (pdata->tx_pause != pdata->phy_tx_pause) {
 +			hw_if->config_tx_flow_control(pdata);
 +			pdata->phy_tx_pause = pdata->tx_pause;
  		}
  
 -		if (pdata->rx_pause != pdata->phy.rx_pause) {
 -			new_state = 1;
 -			pdata->hw_if.config_rx_flow_control(pdata);
 -			pdata->rx_pause = pdata->phy.rx_pause;
 +		if (pdata->rx_pause != pdata->phy_rx_pause) {
 +			hw_if->config_rx_flow_control(pdata);
 +			pdata->phy_rx_pause = pdata->rx_pause;
  		}
  
  		/* Speed support */
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
