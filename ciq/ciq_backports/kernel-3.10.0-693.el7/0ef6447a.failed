Btrfs: Fix integer overflow when calculating bytes_per_bitmap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Feifei Xu <xufeifei@linux.vnet.ibm.com>
commit 0ef6447a3d2f014e49069c4da33f905ed803aa2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0ef6447a.failed

On ppc64, bytes_per_bitmap will be (65536*8*65536). Hence append UL to
fix integer overflow.

	Reviewed-by: Josef Bacik <jbacik@fb.com>
	Reviewed-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
	Signed-off-by: Feifei Xu <xufeifei@linux.vnet.ibm.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 0ef6447a3d2f014e49069c4da33f905ed803aa2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/free-space-cache.c
#	fs/btrfs/tests/free-space-tests.c
diff --cc fs/btrfs/free-space-cache.c
index 4c2a64aa0c50,2813ef0718a2..000000000000
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@@ -29,8 -29,8 +29,13 @@@
  #include "inode-map.h"
  #include "volumes.h"
  
++<<<<<<< HEAD
 +#define BITS_PER_BITMAP		(PAGE_CACHE_SIZE * 8)
 +#define MAX_CACHE_BYTES_PER_GIG	(32 * 1024)
++=======
+ #define BITS_PER_BITMAP		(PAGE_SIZE * 8UL)
+ #define MAX_CACHE_BYTES_PER_GIG	SZ_32K
++>>>>>>> 0ef6447a3d2f (Btrfs: Fix integer overflow when calculating bytes_per_bitmap)
  
  struct btrfs_trim_range {
  	u64 start;
diff --cc fs/btrfs/tests/free-space-tests.c
index 69a11e63d668,f3756d6b9ba2..000000000000
--- a/fs/btrfs/tests/free-space-tests.c
+++ b/fs/btrfs/tests/free-space-tests.c
@@@ -22,45 -22,10 +22,49 @@@
  #include "../disk-io.h"
  #include "../free-space-cache.h"
  
++<<<<<<< HEAD
 +#define BITS_PER_BITMAP		(PAGE_CACHE_SIZE * 8)
 +static struct btrfs_block_group_cache *init_test_block_group(void)
 +{
 +	struct btrfs_block_group_cache *cache;
 +
 +	cache = kzalloc(sizeof(*cache), GFP_NOFS);
 +	if (!cache)
 +		return NULL;
 +	cache->free_space_ctl = kzalloc(sizeof(*cache->free_space_ctl),
 +					GFP_NOFS);
 +	if (!cache->free_space_ctl) {
 +		kfree(cache);
 +		return NULL;
 +	}
 +	cache->fs_info = btrfs_alloc_dummy_fs_info();
 +	if (!cache->fs_info) {
 +		kfree(cache->free_space_ctl);
 +		kfree(cache);
 +		return NULL;
 +	}
 +
 +	cache->key.objectid = 0;
 +	cache->key.offset = 1024 * 1024 * 1024;
 +	cache->key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;
 +	cache->sectorsize = 4096;
 +	cache->full_stripe_len = 4096;
 +
 +	spin_lock_init(&cache->lock);
 +	INIT_LIST_HEAD(&cache->list);
 +	INIT_LIST_HEAD(&cache->cluster_list);
 +	INIT_LIST_HEAD(&cache->bg_list);
 +
 +	btrfs_init_free_space_ctl(cache);
 +
 +	return cache;
 +}
++=======
+ #define BITS_PER_BITMAP		(PAGE_SIZE * 8UL)
++>>>>>>> 0ef6447a3d2f (Btrfs: Fix integer overflow when calculating bytes_per_bitmap)
  
  /*
 - * This test just does basic sanity checking, making sure we can add an extent
 + * This test just does basic sanity checking, making sure we can add an exten
   * entry and remove space from either end and the middle, and make sure we can
   * remove space that covers adjacent extent entries.
   */
* Unmerged path fs/btrfs/free-space-cache.c
* Unmerged path fs/btrfs/tests/free-space-tests.c
