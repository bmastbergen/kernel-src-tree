NTB: Rate limit ntb_qp_link_work

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] Rate limit ntb_qp_link_work (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 91.53%
commit-author Allen Hubbe <Allen.Hubbe@emc.com>
commit 2876228941ac5dcab12854aa5a3462b3f2274b09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/28762289.failed

When the ntb transport is connecting and waiting for the peer, the debug
console receives lots of debug level messages about the remote qp link
status being down.  Rate limit those messages.

	Signed-off-by: Allen Hubbe <Allen.Hubbe@emc.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit 2876228941ac5dcab12854aa5a3462b3f2274b09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_transport.c
diff --cc drivers/ntb/ntb_transport.c
index bf77f3a0b404,8ce0bf67ac20..000000000000
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@@ -814,38 -838,28 +814,43 @@@ static void ntb_qp_link_work(struct wor
  	struct ntb_transport_qp *qp = container_of(work,
  						   struct ntb_transport_qp,
  						   link_work.work);
 -	struct pci_dev *pdev = qp->ndev->pdev;
 -	struct ntb_transport_ctx *nt = qp->transport;
 -	int val;
 +	struct pci_dev *pdev = ntb_query_pdev(qp->ndev);
 +	struct ntb_transport *nt = qp->transport;
 +	int rc, val;
  
 -	WARN_ON(!nt->link_is_up);
 +	WARN_ON(nt->transport_link != NTB_LINK_UP);
  
 -	val = ntb_spad_read(nt->ndev, QP_LINKS);
 +	rc = ntb_read_local_spad(nt->ndev, QP_LINKS, &val);
 +	if (rc) {
 +		dev_err(&pdev->dev, "Error reading spad %d\n", QP_LINKS);
 +		return;
 +	}
  
 -	ntb_peer_spad_write(nt->ndev, QP_LINKS, val | BIT(qp->qp_num));
 +	rc = ntb_write_remote_spad(nt->ndev, QP_LINKS, val | 1 << qp->qp_num);
 +	if (rc)
 +		dev_err(&pdev->dev, "Error writing %x to remote spad %d\n",
 +			val | 1 << qp->qp_num, QP_LINKS);
  
  	/* query remote spad for qp ready bits */
++<<<<<<< HEAD
 +	rc = ntb_read_remote_spad(nt->ndev, QP_LINKS, &val);
 +	if (rc)
 +		dev_err(&pdev->dev, "Error reading remote spad %d\n", QP_LINKS);
 +
 +	dev_dbg(&pdev->dev, "Remote QP link status = %x\n", val);
++=======
+ 	ntb_peer_spad_read(nt->ndev, QP_LINKS);
+ 	dev_dbg_ratelimited(&pdev->dev, "Remote QP link status = %x\n", val);
++>>>>>>> 2876228941ac (NTB: Rate limit ntb_qp_link_work)
  
  	/* See if the remote side is up */
 -	if (val & BIT(qp->qp_num)) {
 -		dev_info(&pdev->dev, "qp %d: Link Up\n", qp->qp_num);
 -		qp->link_is_up = true;
 +	if (1 << qp->qp_num & val) {
 +		qp->qp_link = NTB_LINK_UP;
  
 +		dev_info(&pdev->dev, "qp %d: Link Up\n", qp->qp_num);
  		if (qp->event_handler)
 -			qp->event_handler(qp->cb_data, qp->link_is_up);
 -	} else if (nt->link_is_up)
 +			qp->event_handler(qp->cb_data, NTB_LINK_UP);
 +	} else if (nt->transport_link == NTB_LINK_UP)
  		schedule_delayed_work(&qp->link_work,
  				      msecs_to_jiffies(NTB_LINK_DOWN_TIMEOUT));
  }
* Unmerged path drivers/ntb/ntb_transport.c
