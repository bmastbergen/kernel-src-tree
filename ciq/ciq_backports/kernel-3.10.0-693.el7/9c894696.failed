Btrfs: remove some no-op casts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit 9c894696f56f5d84fb5766af81bcda4a7cb9a842
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9c894696.failed

We cast 0 to a u8 but then because of type promotion, it's immediately
cast to int back to int before we do a bitwise negate.  The cast doesn't
matter in this case, the code works as intended.  It causes a static
checker warning though so let's remove it.

	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Reviewed-by: David Sterba <dsterba@suse.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 9c894696f56f5d84fb5766af81bcda4a7cb9a842)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/extent_io.c
diff --cc fs/btrfs/extent_io.c
index 4e9385653aea,8ed05d95584a..000000000000
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@@ -5560,17 -5558,45 +5560,59 @@@ void copy_extent_buffer(struct extent_b
  	}
  }
  
++<<<<<<< HEAD
 +/*
 + * The extent buffer bitmap operations are done with byte granularity because
 + * bitmap items are not guaranteed to be aligned to a word and therefore a
 + * single word in a bitmap may straddle two pages in the extent buffer.
 + */
 +#define BIT_BYTE(nr) ((nr) / BITS_PER_BYTE)
 +#define BYTE_MASK ((1 << BITS_PER_BYTE) - 1)
 +#define BITMAP_FIRST_BYTE_MASK(start) \
 +	((BYTE_MASK << ((start) & (BITS_PER_BYTE - 1))) & BYTE_MASK)
 +#define BITMAP_LAST_BYTE_MASK(nbits) \
 +	(BYTE_MASK >> (-(nbits) & (BITS_PER_BYTE - 1)))
++=======
+ void le_bitmap_set(u8 *map, unsigned int start, int len)
+ {
+ 	u8 *p = map + BIT_BYTE(start);
+ 	const unsigned int size = start + len;
+ 	int bits_to_set = BITS_PER_BYTE - (start % BITS_PER_BYTE);
+ 	u8 mask_to_set = BITMAP_FIRST_BYTE_MASK(start);
+ 
+ 	while (len - bits_to_set >= 0) {
+ 		*p |= mask_to_set;
+ 		len -= bits_to_set;
+ 		bits_to_set = BITS_PER_BYTE;
+ 		mask_to_set = ~0;
+ 		p++;
+ 	}
+ 	if (len) {
+ 		mask_to_set &= BITMAP_LAST_BYTE_MASK(size);
+ 		*p |= mask_to_set;
+ 	}
+ }
+ 
+ void le_bitmap_clear(u8 *map, unsigned int start, int len)
+ {
+ 	u8 *p = map + BIT_BYTE(start);
+ 	const unsigned int size = start + len;
+ 	int bits_to_clear = BITS_PER_BYTE - (start % BITS_PER_BYTE);
+ 	u8 mask_to_clear = BITMAP_FIRST_BYTE_MASK(start);
+ 
+ 	while (len - bits_to_clear >= 0) {
+ 		*p &= ~mask_to_clear;
+ 		len -= bits_to_clear;
+ 		bits_to_clear = BITS_PER_BYTE;
+ 		mask_to_clear = ~0;
+ 		p++;
+ 	}
+ 	if (len) {
+ 		mask_to_clear &= BITMAP_LAST_BYTE_MASK(size);
+ 		*p &= ~mask_to_clear;
+ 	}
+ }
++>>>>>>> 9c894696f56f (Btrfs: remove some no-op casts)
  
  /*
   * eb_bitmap_offset() - calculate the page and offset of the byte containing the
@@@ -5653,8 -5679,8 +5695,13 @@@ void extent_buffer_bitmap_set(struct ex
  		kaddr[offset] |= mask_to_set;
  		len -= bits_to_set;
  		bits_to_set = BITS_PER_BYTE;
++<<<<<<< HEAD
 +		mask_to_set = ~0U;
 +		if (++offset >= PAGE_CACHE_SIZE && len > 0) {
++=======
+ 		mask_to_set = ~0;
+ 		if (++offset >= PAGE_SIZE && len > 0) {
++>>>>>>> 9c894696f56f (Btrfs: remove some no-op casts)
  			offset = 0;
  			page = eb->pages[++i];
  			WARN_ON(!PageUptodate(page));
@@@ -5695,8 -5721,8 +5742,13 @@@ void extent_buffer_bitmap_clear(struct 
  		kaddr[offset] &= ~mask_to_clear;
  		len -= bits_to_clear;
  		bits_to_clear = BITS_PER_BYTE;
++<<<<<<< HEAD
 +		mask_to_clear = ~0U;
 +		if (++offset >= PAGE_CACHE_SIZE && len > 0) {
++=======
+ 		mask_to_clear = ~0;
+ 		if (++offset >= PAGE_SIZE && len > 0) {
++>>>>>>> 9c894696f56f (Btrfs: remove some no-op casts)
  			offset = 0;
  			page = eb->pages[++i];
  			WARN_ON(!PageUptodate(page));
* Unmerged path fs/btrfs/extent_io.c
