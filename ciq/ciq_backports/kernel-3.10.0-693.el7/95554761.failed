libcxgb,iw_cxgb4,cxgbit: add cxgb_find_route6()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [target] libcxgb, iw_cxgb4, cxgbit: add cxgb_find_route6() (Don Dutile) [1385866 1417285]
Rebuild_FUZZ: 97.92%
commit-author Varun Prakash <varun@chelsio.com>
commit 95554761d1db54f7c058cc0ed389282ce7361999
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/95554761.failed

Add cxgb_find_route6() in libcxgb_cm.c to remove
it's duplicate definitions from cxgb4/cm.c and
cxgbit/cxgbit_cm.c.

	Signed-off-by: Varun Prakash <varun@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 95554761d1db54f7c058cc0ed389282ce7361999)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
#	drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
#	drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.c
#	drivers/target/iscsi/cxgbit/cxgbit_cm.c
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index 7fc4048a8a8f,a08a74839c13..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -466,72 -465,6 +466,75 @@@ static struct net_device *get_real_dev(
  	return rdma_vlan_dev_real_dev(egress_dev) ? : egress_dev;
  }
  
++<<<<<<< HEAD
 +static int our_interface(struct c4iw_dev *dev, struct net_device *egress_dev)
 +{
 +	int i;
 +
 +	egress_dev = get_real_dev(egress_dev);
 +	for (i = 0; i < dev->rdev.lldi.nports; i++)
 +		if (dev->rdev.lldi.ports[i] == egress_dev)
 +			return 1;
 +	return 0;
 +}
 +
 +static struct dst_entry *find_route6(struct c4iw_dev *dev, __u8 *local_ip,
 +				     __u8 *peer_ip, __be16 local_port,
 +				     __be16 peer_port, u8 tos,
 +				     __u32 sin6_scope_id)
 +{
 +	struct dst_entry *dst = NULL;
 +
 +	if (IS_ENABLED(CONFIG_IPV6)) {
 +		struct flowi6 fl6;
 +
 +		memset(&fl6, 0, sizeof(fl6));
 +		memcpy(&fl6.daddr, peer_ip, 16);
 +		memcpy(&fl6.saddr, local_ip, 16);
 +		if (ipv6_addr_type(&fl6.daddr) & IPV6_ADDR_LINKLOCAL)
 +			fl6.flowi6_oif = sin6_scope_id;
 +		dst = ip6_route_output(&init_net, NULL, &fl6);
 +		if (!dst)
 +			goto out;
 +		if (!our_interface(dev, ip6_dst_idev(dst)->dev) &&
 +		    !(ip6_dst_idev(dst)->dev->flags & IFF_LOOPBACK)) {
 +			dst_release(dst);
 +			dst = NULL;
 +		}
 +	}
 +
 +out:
 +	return dst;
 +}
 +
 +static struct dst_entry *find_route(struct c4iw_dev *dev, __be32 local_ip,
 +				 __be32 peer_ip, __be16 local_port,
 +				 __be16 peer_port, u8 tos)
 +{
 +	struct rtable *rt;
 +	struct flowi4 fl4;
 +	struct neighbour *n;
 +
 +	rt = ip_route_output_ports(&init_net, &fl4, NULL, peer_ip, local_ip,
 +				   peer_port, local_port, IPPROTO_TCP,
 +				   tos, 0);
 +	if (IS_ERR(rt))
 +		return NULL;
 +	n = dst_neigh_lookup(&rt->dst, &peer_ip);
 +	if (!n)
 +		return NULL;
 +	if (!our_interface(dev, n->dev) &&
 +	    !(n->dev->flags & IFF_LOOPBACK)) {
 +		neigh_release(n);
 +		dst_release(&rt->dst);
 +		return NULL;
 +	}
 +	neigh_release(n);
 +	return &rt->dst;
 +}
 +
++=======
++>>>>>>> 95554761d1db (libcxgb,iw_cxgb4,cxgbit: add cxgb_find_route6())
  static void arp_failure_discard(void *handle, struct sk_buff *skb)
  {
  	pr_err(MOD "ARP failure\n");
diff --cc drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
index 1d7bd82a1fb1,c4df04a4a323..000000000000
--- a/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
+++ b/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
@@@ -30,33 -30,21 +30,48 @@@
   * SOFTWARE.
   */
  
 -#ifndef __LIBCXGB_CM_H__
 -#define __LIBCXGB_CM_H__
 +/*
 + * This file is conditionally built on PowerPC only.  Otherwise weak symbol
 + * versions of the functions exported from here are used.
 + */
  
 -#include <cxgb4.h>
 -#include <t4_msg.h>
 +#include "ipath_kernel.h"
  
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +/**
 + * ipath_enable_wc - enable write combining for MMIO writes to the device
 + * @dd: infinipath device
 + *
 + * Nothing to do on PowerPC, so just return without error.
 + */
 +int ipath_enable_wc(struct ipath_devdata *dd)
 +{
 +	return 0;
 +}
 +
 +/**
 + * ipath_unordered_wc - indicate whether write combining is unordered
 + *
 + * Because our performance depends on our ability to do write
 + * combining mmio writes in the most efficient way, we need to
 + * know if we are on a processor that may reorder stores when
 + * write combining.
 + */
 +int ipath_unordered_wc(void)
 +{
 +	return 1;
 +}
++=======
+ void
+ cxgb_get_4tuple(struct cpl_pass_accept_req *, enum chip_type,
+ 		int *, __u8 *, __u8 *, __be16 *, __be16 *);
+ struct dst_entry *
+ cxgb_find_route(struct cxgb4_lld_info *,
+ 		struct net_device *(*)(struct net_device *),
+ 		__be32, __be32, __be16,	__be16, u8);
+ struct dst_entry *
+ cxgb_find_route6(struct cxgb4_lld_info *,
+ 		 struct net_device *(*)(struct net_device *),
+ 		 __u8 *, __u8 *, __be16, __be16, u8, __u32);
+ #endif
++>>>>>>> 95554761d1db (libcxgb,iw_cxgb4,cxgbit: add cxgb_find_route6()):drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.h
diff --cc drivers/target/iscsi/cxgbit/cxgbit_cm.c
index 0ae0b131abfc,e961ac4bf5db..000000000000
--- a/drivers/target/iscsi/cxgbit/cxgbit_cm.c
+++ b/drivers/target/iscsi/cxgbit/cxgbit_cm.c
@@@ -789,109 -790,6 +789,112 @@@ void _cxgbit_free_csk(struct kref *kref
  	kfree(csk);
  }
  
++<<<<<<< HEAD
 +static void
 +cxgbit_get_tuple_info(struct cpl_pass_accept_req *req, int *iptype,
 +		      __u8 *local_ip, __u8 *peer_ip, __be16 *local_port,
 +		      __be16 *peer_port)
 +{
 +	u32 eth_len = ETH_HDR_LEN_G(be32_to_cpu(req->hdr_len));
 +	u32 ip_len = IP_HDR_LEN_G(be32_to_cpu(req->hdr_len));
 +	struct iphdr *ip = (struct iphdr *)((u8 *)(req + 1) + eth_len);
 +	struct ipv6hdr *ip6 = (struct ipv6hdr *)((u8 *)(req + 1) + eth_len);
 +	struct tcphdr *tcp = (struct tcphdr *)
 +			      ((u8 *)(req + 1) + eth_len + ip_len);
 +
 +	if (ip->version == 4) {
 +		pr_debug("%s saddr 0x%x daddr 0x%x sport %u dport %u\n",
 +			 __func__,
 +			 ntohl(ip->saddr), ntohl(ip->daddr),
 +			 ntohs(tcp->source),
 +			 ntohs(tcp->dest));
 +		*iptype = 4;
 +		memcpy(peer_ip, &ip->saddr, 4);
 +		memcpy(local_ip, &ip->daddr, 4);
 +	} else {
 +		pr_debug("%s saddr %pI6 daddr %pI6 sport %u dport %u\n",
 +			 __func__,
 +			 ip6->saddr.s6_addr, ip6->daddr.s6_addr,
 +			 ntohs(tcp->source),
 +			 ntohs(tcp->dest));
 +		*iptype = 6;
 +		memcpy(peer_ip, ip6->saddr.s6_addr, 16);
 +		memcpy(local_ip, ip6->daddr.s6_addr, 16);
 +	}
 +
 +	*peer_port = tcp->source;
 +	*local_port = tcp->dest;
 +}
 +
 +static int
 +cxgbit_our_interface(struct cxgbit_device *cdev, struct net_device *egress_dev)
 +{
 +	u8 i;
 +
 +	egress_dev = cxgbit_get_real_dev(egress_dev);
 +	for (i = 0; i < cdev->lldi.nports; i++)
 +		if (cdev->lldi.ports[i] == egress_dev)
 +			return 1;
 +	return 0;
 +}
 +
 +static struct dst_entry *
 +cxgbit_find_route6(struct cxgbit_device *cdev, __u8 *local_ip, __u8 *peer_ip,
 +		   __be16 local_port, __be16 peer_port, u8 tos,
 +		   __u32 sin6_scope_id)
 +{
 +	struct dst_entry *dst = NULL;
 +
 +	if (IS_ENABLED(CONFIG_IPV6)) {
 +		struct flowi6 fl6;
 +
 +		memset(&fl6, 0, sizeof(fl6));
 +		memcpy(&fl6.daddr, peer_ip, 16);
 +		memcpy(&fl6.saddr, local_ip, 16);
 +		if (ipv6_addr_type(&fl6.daddr) & IPV6_ADDR_LINKLOCAL)
 +			fl6.flowi6_oif = sin6_scope_id;
 +		dst = ip6_route_output(&init_net, NULL, &fl6);
 +		if (!dst)
 +			goto out;
 +		if (!cxgbit_our_interface(cdev, ip6_dst_idev(dst)->dev) &&
 +		    !(ip6_dst_idev(dst)->dev->flags & IFF_LOOPBACK)) {
 +			dst_release(dst);
 +			dst = NULL;
 +		}
 +	}
 +out:
 +	return dst;
 +}
 +
 +static struct dst_entry *
 +cxgbit_find_route(struct cxgbit_device *cdev, __be32 local_ip, __be32 peer_ip,
 +		  __be16 local_port, __be16 peer_port, u8 tos)
 +{
 +	struct rtable *rt;
 +	struct flowi4 fl4;
 +	struct neighbour *n;
 +
 +	rt = ip_route_output_ports(&init_net, &fl4, NULL, peer_ip,
 +				   local_ip,
 +				   peer_port, local_port, IPPROTO_TCP,
 +				   tos, 0);
 +	if (IS_ERR(rt))
 +		return NULL;
 +	n = dst_neigh_lookup(&rt->dst, &peer_ip);
 +	if (!n)
 +		return NULL;
 +	if (!cxgbit_our_interface(cdev, n->dev) &&
 +	    !(n->dev->flags & IFF_LOOPBACK)) {
 +		neigh_release(n);
 +		dst_release(&rt->dst);
 +		return NULL;
 +	}
 +	neigh_release(n);
 +	return &rt->dst;
 +}
 +
++=======
++>>>>>>> 95554761d1db (libcxgb,iw_cxgb4,cxgbit: add cxgb_find_route6())
  static void cxgbit_set_tcp_window(struct cxgbit_sock *csk, struct port_info *pi)
  {
  	unsigned int linkspeed;
* Unmerged path drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.c
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
* Unmerged path drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
* Unmerged path drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.c
* Unmerged path drivers/target/iscsi/cxgbit/cxgbit_cm.c
