kvm: nVMX: fix nested tsc scaling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Peter Feiner <pfeiner@google.com>
commit c95ba92afb238ac565c68968fc72e38ca8d1b6e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c95ba92a.failed

When the host supported TSC scaling, L2 would use a TSC multiplier of
0, which causes a VM entry failure. Now L2's TSC uses the same
multiplier as L1.

	Signed-off-by: Peter Feiner <pfeiner@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c95ba92afb238ac565c68968fc72e38ca8d1b6e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 2bf72c9864bd,5cede40e2552..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2031,6 -2199,13 +2031,16 @@@ static void vmx_vcpu_pi_load(struct kvm
  	} while (cmpxchg(&pi_desc->control, old.control,
  			new.control) != old.control);
  }
++<<<<<<< HEAD
++=======
+ 
+ static void decache_tsc_multiplier(struct vcpu_vmx *vmx)
+ {
+ 	vmx->current_tsc_ratio = vmx->vcpu.arch.tsc_scaling_ratio;
+ 	vmcs_write64(TSC_MULTIPLIER, vmx->current_tsc_ratio);
+ }
+ 
++>>>>>>> c95ba92afb23 (kvm: nVMX: fix nested tsc scaling)
  /*
   * Switches to specified vcpu, until a matching vcpu_put(), but assumes
   * vcpu mutex is already taken.
@@@ -2085,12 -2264,11 +2095,10 @@@ static void vmx_vcpu_load(struct kvm_vc
  
  	/* Setup TSC multiplier */
  	if (kvm_has_tsc_control &&
- 	    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio) {
- 		vmx->current_tsc_ratio = vcpu->arch.tsc_scaling_ratio;
- 		vmcs_write64(TSC_MULTIPLIER, vmx->current_tsc_ratio);
- 	}
+ 	    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio)
+ 		decache_tsc_multiplier(vmx);
  
  	vmx_vcpu_pi_load(vcpu, cpu);
 -	vmx->host_pkru = read_pkru();
  }
  
  static void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)
@@@ -10376,8 -10753,22 +10386,25 @@@ static void nested_vmx_vmexit(struct kv
  
  	load_vmcs12_host_state(vcpu, vmcs12);
  
 -	/* Update any VMCS fields that might have changed while L2 ran */
 +	/* Update TSC_OFFSET if TSC was changed while L2 ran */
  	vmcs_write64(TSC_OFFSET, vmx->nested.vmcs01_tsc_offset);
++<<<<<<< HEAD
++=======
+ 	if (vmx->hv_deadline_tsc == -1)
+ 		vmcs_clear_bits(PIN_BASED_VM_EXEC_CONTROL,
+ 				PIN_BASED_VMX_PREEMPTION_TIMER);
+ 	else
+ 		vmcs_set_bits(PIN_BASED_VM_EXEC_CONTROL,
+ 			      PIN_BASED_VMX_PREEMPTION_TIMER);
+ 	if (kvm_has_tsc_control)
+ 		decache_tsc_multiplier(vmx);
+ 
+ 	if (vmx->nested.change_vmcs01_virtual_x2apic_mode) {
+ 		vmx->nested.change_vmcs01_virtual_x2apic_mode = false;
+ 		vmx_set_virtual_x2apic_mode(vcpu,
+ 				vcpu->arch.apic_base & X2APIC_ENABLE);
+ 	}
++>>>>>>> c95ba92afb23 (kvm: nVMX: fix nested tsc scaling)
  
  	/* This is needed for same reason as it was needed in prepare_vmcs02 */
  	vmx->host_rsp = 0;
* Unmerged path arch/x86/kvm/vmx.c
