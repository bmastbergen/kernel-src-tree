net: Update API for VF vlan protocol 802.1ad support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] Update API for VF vlan protocol 802.1ad support (Ivan Vecera) [1382040]
Rebuild_FUZZ: 94.95%
commit-author Moshe Shemesh <moshe@mellanox.com>
commit 79aab093a0b5370d7fc4e99df75996f4744dc03f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/79aab093.failed

Introduce new rtnl UAPI that exposes a list of vlans per VF, giving
the ability for user-space application to specify it for the VF, as an
option to support 802.1ad.
We adjusted IP Link tool to support this option.

For future use cases, the new UAPI supports multiple vlans. For now we
limit the list size to a single vlan in kernel.
Add IFLA_VF_VLAN_LIST in addition to IFLA_VF_VLAN to keep backward
compatibility with older versions of IP Link tool.

Add a vlan protocol parameter to the ndo_set_vf_vlan callback.
We kept 802.1Q as the drivers' default vlan protocol.
Suitable ip link tool command examples:
  Set vf vlan protocol 802.1ad:
    ip link set eth0 vf 1 vlan 100 proto 802.1ad
  Set vf to VST (802.1Q) mode:
    ip link set eth0 vf 1 vlan 100 proto 802.1Q
  Or by omitting the new parameter
    ip link set eth0 vf 1 vlan 100

	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 79aab093a0b5370d7fc4e99df75996f4744dc03f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
#	drivers/net/ethernet/intel/fm10k/fm10k.h
#	drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h
#	include/linux/if_link.h
#	include/linux/netdevice.h
#	net/core/rtnetlink.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
index 363884dd9e8a,ec6cd18842c3..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
@@@ -143,6 -183,12 +144,15 @@@ int bnxt_set_vf_vlan(struct net_device 
  	u16 vlan_tag;
  	int rc;
  
++<<<<<<< HEAD
++=======
+ 	if (bp->hwrm_spec_code < 0x10201)
+ 		return -ENOTSUPP;
+ 
+ 	if (vlan_proto != htons(ETH_P_8021Q))
+ 		return -EPROTONOSUPPORT;
+ 
++>>>>>>> 79aab093a0b5 (net: Update API for VF vlan protocol 802.1ad support)
  	rc = bnxt_vf_ndo_prep(bp, vf_id);
  	if (rc)
  		return rc;
diff --cc drivers/net/ethernet/intel/fm10k/fm10k.h
index b67767cd2f60,4d19e46f7c55..000000000000
--- a/drivers/net/ethernet/intel/fm10k/fm10k.h
+++ b/drivers/net/ethernet/intel/fm10k/fm10k.h
@@@ -524,8 -507,9 +524,14 @@@ int fm10k_iov_configure(struct pci_dev 
  s32 fm10k_iov_update_pvid(struct fm10k_intfc *interface, u16 glort, u16 pvid);
  int fm10k_ndo_set_vf_mac(struct net_device *netdev, int vf_idx, u8 *mac);
  int fm10k_ndo_set_vf_vlan(struct net_device *netdev,
++<<<<<<< HEAD
 +			  int vf_idx, u16 vid, u8 qos);
 +int fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx, int rate);
++=======
+ 			  int vf_idx, u16 vid, u8 qos, __be16 vlan_proto);
+ int fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx, int rate,
+ 			int unused);
++>>>>>>> 79aab093a0b5 (net: Update API for VF vlan protocol 802.1ad support)
  int fm10k_ndo_get_vf_config(struct net_device *netdev,
  			    int vf_idx, struct ifla_vf_info *ivi);
  
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h
index dad925706f4c,0c7977d27b71..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h
@@@ -43,7 -43,8 +43,12 @@@ void ixgbe_disable_tx_rx(struct ixgbe_a
  void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter);
  int ixgbe_ndo_set_vf_mac(struct net_device *netdev, int queue, u8 *mac);
  int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int queue, u16 vlan,
++<<<<<<< HEAD
 +			   u8 qos);
++=======
+ 			   u8 qos, __be16 vlan_proto);
+ int ixgbe_link_mbps(struct ixgbe_adapter *adapter);
++>>>>>>> 79aab093a0b5 (net: Update API for VF vlan protocol 802.1ad support)
  int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate,
  			int max_tx_rate);
  int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting);
diff --cc include/linux/if_link.h
index f72e3dcbf9f2,0b17c585b5cd..000000000000
--- a/include/linux/if_link.h
+++ b/include/linux/if_link.h
@@@ -19,11 -19,12 +19,19 @@@ struct ifla_vf_info 
  	__u8 mac[32];
  	__u32 vlan;
  	__u32 qos;
 +	RH_KABI_REPLACE(__u32 tx_rate, __u32 max_tx_rate)
  	__u32 spoofchk;
  	__u32 linkstate;
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(__u32 min_tx_rate)
 +	RH_KABI_EXTEND(__u32 rss_query_en)
 +	RH_KABI_EXTEND(__u32 trusted)
++=======
+ 	__u32 min_tx_rate;
+ 	__u32 max_tx_rate;
+ 	__u32 rss_query_en;
+ 	__u32 trusted;
+ 	__be16 vlan_proto;
++>>>>>>> 79aab093a0b5 (net: Update API for VF vlan protocol 802.1ad support)
  };
  #endif /* _LINUX_IF_LINK_H */
diff --cc include/linux/netdevice.h
index 0c457a76a538,1e8a5c734d72..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1174,11 -1188,15 +1175,19 @@@ struct net_device_ops 
  	int			(*ndo_set_vf_mac)(struct net_device *dev,
  						  int queue, u8 *mac);
  	int			(*ndo_set_vf_vlan)(struct net_device *dev,
++<<<<<<< HEAD
 +						   int queue, u16 vlan, u8 qos);
 +	int			(*ndo_set_vf_tx_rate)(struct net_device *dev,
 +						      int vf, int rate);
++=======
+ 						   int queue, u16 vlan,
+ 						   u8 qos, __be16 proto);
+ 	int			(*ndo_set_vf_rate)(struct net_device *dev,
+ 						   int vf, int min_tx_rate,
+ 						   int max_tx_rate);
++>>>>>>> 79aab093a0b5 (net: Update API for VF vlan protocol 802.1ad support)
  	int			(*ndo_set_vf_spoofchk)(struct net_device *dev,
  						       int vf, bool setting);
 -	int			(*ndo_set_vf_trust)(struct net_device *dev,
 -						    int vf, bool setting);
  	int			(*ndo_get_vf_config)(struct net_device *dev,
  						     int vf,
  						     struct ifla_vf_info *ivf);
diff --cc net/core/rtnetlink.c
index 8209decfe5a9,3ac8946bf244..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1024,6 -1043,236 +1027,239 @@@ static int rtnl_phys_port_id_fill(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int rtnl_phys_port_name_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	char name[IFNAMSIZ];
+ 	int err;
+ 
+ 	err = dev_get_phys_port_name(dev, name, sizeof(name));
+ 	if (err) {
+ 		if (err == -EOPNOTSUPP)
+ 			return 0;
+ 		return err;
+ 	}
+ 
+ 	if (nla_put(skb, IFLA_PHYS_PORT_NAME, strlen(name), name))
+ 		return -EMSGSIZE;
+ 
+ 	return 0;
+ }
+ 
+ static int rtnl_phys_switch_id_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	int err;
+ 	struct switchdev_attr attr = {
+ 		.orig_dev = dev,
+ 		.id = SWITCHDEV_ATTR_ID_PORT_PARENT_ID,
+ 		.flags = SWITCHDEV_F_NO_RECURSE,
+ 	};
+ 
+ 	err = switchdev_port_attr_get(dev, &attr);
+ 	if (err) {
+ 		if (err == -EOPNOTSUPP)
+ 			return 0;
+ 		return err;
+ 	}
+ 
+ 	if (nla_put(skb, IFLA_PHYS_SWITCH_ID, attr.u.ppid.id_len,
+ 		    attr.u.ppid.id))
+ 		return -EMSGSIZE;
+ 
+ 	return 0;
+ }
+ 
+ static noinline_for_stack int rtnl_fill_stats(struct sk_buff *skb,
+ 					      struct net_device *dev)
+ {
+ 	struct rtnl_link_stats64 *sp;
+ 	struct nlattr *attr;
+ 
+ 	attr = nla_reserve_64bit(skb, IFLA_STATS64,
+ 				 sizeof(struct rtnl_link_stats64), IFLA_PAD);
+ 	if (!attr)
+ 		return -EMSGSIZE;
+ 
+ 	sp = nla_data(attr);
+ 	dev_get_stats(dev, sp);
+ 
+ 	attr = nla_reserve(skb, IFLA_STATS,
+ 			   sizeof(struct rtnl_link_stats));
+ 	if (!attr)
+ 		return -EMSGSIZE;
+ 
+ 	copy_rtnl_link_stats(nla_data(attr), sp);
+ 
+ 	return 0;
+ }
+ 
+ static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,
+ 					       struct net_device *dev,
+ 					       int vfs_num,
+ 					       struct nlattr *vfinfo)
+ {
+ 	struct ifla_vf_rss_query_en vf_rss_query_en;
+ 	struct nlattr *vf, *vfstats, *vfvlanlist;
+ 	struct ifla_vf_link_state vf_linkstate;
+ 	struct ifla_vf_vlan_info vf_vlan_info;
+ 	struct ifla_vf_spoofchk vf_spoofchk;
+ 	struct ifla_vf_tx_rate vf_tx_rate;
+ 	struct ifla_vf_stats vf_stats;
+ 	struct ifla_vf_trust vf_trust;
+ 	struct ifla_vf_vlan vf_vlan;
+ 	struct ifla_vf_rate vf_rate;
+ 	struct ifla_vf_mac vf_mac;
+ 	struct ifla_vf_info ivi;
+ 
+ 	/* Not all SR-IOV capable drivers support the
+ 	 * spoofcheck and "RSS query enable" query.  Preset to
+ 	 * -1 so the user space tool can detect that the driver
+ 	 * didn't report anything.
+ 	 */
+ 	ivi.spoofchk = -1;
+ 	ivi.rss_query_en = -1;
+ 	ivi.trusted = -1;
+ 	memset(ivi.mac, 0, sizeof(ivi.mac));
+ 	/* The default value for VF link state is "auto"
+ 	 * IFLA_VF_LINK_STATE_AUTO which equals zero
+ 	 */
+ 	ivi.linkstate = 0;
+ 	/* VLAN Protocol by default is 802.1Q */
+ 	ivi.vlan_proto = htons(ETH_P_8021Q);
+ 	if (dev->netdev_ops->ndo_get_vf_config(dev, vfs_num, &ivi))
+ 		return 0;
+ 
+ 	vf_mac.vf =
+ 		vf_vlan.vf =
+ 		vf_vlan_info.vf =
+ 		vf_rate.vf =
+ 		vf_tx_rate.vf =
+ 		vf_spoofchk.vf =
+ 		vf_linkstate.vf =
+ 		vf_rss_query_en.vf =
+ 		vf_trust.vf = ivi.vf;
+ 
+ 	memcpy(vf_mac.mac, ivi.mac, sizeof(ivi.mac));
+ 	vf_vlan.vlan = ivi.vlan;
+ 	vf_vlan.qos = ivi.qos;
+ 	vf_vlan_info.vlan = ivi.vlan;
+ 	vf_vlan_info.qos = ivi.qos;
+ 	vf_vlan_info.vlan_proto = ivi.vlan_proto;
+ 	vf_tx_rate.rate = ivi.max_tx_rate;
+ 	vf_rate.min_tx_rate = ivi.min_tx_rate;
+ 	vf_rate.max_tx_rate = ivi.max_tx_rate;
+ 	vf_spoofchk.setting = ivi.spoofchk;
+ 	vf_linkstate.link_state = ivi.linkstate;
+ 	vf_rss_query_en.setting = ivi.rss_query_en;
+ 	vf_trust.setting = ivi.trusted;
+ 	vf = nla_nest_start(skb, IFLA_VF_INFO);
+ 	if (!vf)
+ 		goto nla_put_vfinfo_failure;
+ 	if (nla_put(skb, IFLA_VF_MAC, sizeof(vf_mac), &vf_mac) ||
+ 	    nla_put(skb, IFLA_VF_VLAN, sizeof(vf_vlan), &vf_vlan) ||
+ 	    nla_put(skb, IFLA_VF_RATE, sizeof(vf_rate),
+ 		    &vf_rate) ||
+ 	    nla_put(skb, IFLA_VF_TX_RATE, sizeof(vf_tx_rate),
+ 		    &vf_tx_rate) ||
+ 	    nla_put(skb, IFLA_VF_SPOOFCHK, sizeof(vf_spoofchk),
+ 		    &vf_spoofchk) ||
+ 	    nla_put(skb, IFLA_VF_LINK_STATE, sizeof(vf_linkstate),
+ 		    &vf_linkstate) ||
+ 	    nla_put(skb, IFLA_VF_RSS_QUERY_EN,
+ 		    sizeof(vf_rss_query_en),
+ 		    &vf_rss_query_en) ||
+ 	    nla_put(skb, IFLA_VF_TRUST,
+ 		    sizeof(vf_trust), &vf_trust))
+ 		goto nla_put_vf_failure;
+ 	vfvlanlist = nla_nest_start(skb, IFLA_VF_VLAN_LIST);
+ 	if (!vfvlanlist)
+ 		goto nla_put_vf_failure;
+ 	if (nla_put(skb, IFLA_VF_VLAN_INFO, sizeof(vf_vlan_info),
+ 		    &vf_vlan_info)) {
+ 		nla_nest_cancel(skb, vfvlanlist);
+ 		goto nla_put_vf_failure;
+ 	}
+ 	nla_nest_end(skb, vfvlanlist);
+ 	memset(&vf_stats, 0, sizeof(vf_stats));
+ 	if (dev->netdev_ops->ndo_get_vf_stats)
+ 		dev->netdev_ops->ndo_get_vf_stats(dev, vfs_num,
+ 						&vf_stats);
+ 	vfstats = nla_nest_start(skb, IFLA_VF_STATS);
+ 	if (!vfstats)
+ 		goto nla_put_vf_failure;
+ 	if (nla_put_u64_64bit(skb, IFLA_VF_STATS_RX_PACKETS,
+ 			      vf_stats.rx_packets, IFLA_VF_STATS_PAD) ||
+ 	    nla_put_u64_64bit(skb, IFLA_VF_STATS_TX_PACKETS,
+ 			      vf_stats.tx_packets, IFLA_VF_STATS_PAD) ||
+ 	    nla_put_u64_64bit(skb, IFLA_VF_STATS_RX_BYTES,
+ 			      vf_stats.rx_bytes, IFLA_VF_STATS_PAD) ||
+ 	    nla_put_u64_64bit(skb, IFLA_VF_STATS_TX_BYTES,
+ 			      vf_stats.tx_bytes, IFLA_VF_STATS_PAD) ||
+ 	    nla_put_u64_64bit(skb, IFLA_VF_STATS_BROADCAST,
+ 			      vf_stats.broadcast, IFLA_VF_STATS_PAD) ||
+ 	    nla_put_u64_64bit(skb, IFLA_VF_STATS_MULTICAST,
+ 			      vf_stats.multicast, IFLA_VF_STATS_PAD)) {
+ 		nla_nest_cancel(skb, vfstats);
+ 		goto nla_put_vf_failure;
+ 	}
+ 	nla_nest_end(skb, vfstats);
+ 	nla_nest_end(skb, vf);
+ 	return 0;
+ 
+ nla_put_vf_failure:
+ 	nla_nest_cancel(skb, vf);
+ nla_put_vfinfo_failure:
+ 	nla_nest_cancel(skb, vfinfo);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct rtnl_link_ifmap map;
+ 
+ 	memset(&map, 0, sizeof(map));
+ 	map.mem_start   = dev->mem_start;
+ 	map.mem_end     = dev->mem_end;
+ 	map.base_addr   = dev->base_addr;
+ 	map.irq         = dev->irq;
+ 	map.dma         = dev->dma;
+ 	map.port        = dev->if_port;
+ 
+ 	if (nla_put_64bit(skb, IFLA_MAP, sizeof(map), &map, IFLA_PAD))
+ 		return -EMSGSIZE;
+ 
+ 	return 0;
+ }
+ 
+ static int rtnl_xdp_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct netdev_xdp xdp_op = {};
+ 	struct nlattr *xdp;
+ 	int err;
+ 
+ 	if (!dev->netdev_ops->ndo_xdp)
+ 		return 0;
+ 	xdp = nla_nest_start(skb, IFLA_XDP);
+ 	if (!xdp)
+ 		return -EMSGSIZE;
+ 	xdp_op.command = XDP_QUERY_PROG;
+ 	err = dev->netdev_ops->ndo_xdp(dev, &xdp_op);
+ 	if (err)
+ 		goto err_cancel;
+ 	err = nla_put_u8(skb, IFLA_XDP_ATTACHED, xdp_op.prog_attached);
+ 	if (err)
+ 		goto err_cancel;
+ 
+ 	nla_nest_end(skb, xdp);
+ 	return 0;
+ 
+ err_cancel:
+ 	nla_nest_cancel(skb, xdp);
+ 	return err;
+ }
+ 
++>>>>>>> 79aab093a0b5 (net: Update API for VF vlan protocol 802.1ad support)
  static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
  			    int type, u32 pid, u32 seq, u32 change,
  			    unsigned int flags, u32 ext_filter_mask)
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
index 0e68fadecfdb..243cb9748d35 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
@@ -492,7 +492,8 @@ int __bnx2x_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
 int bnx2x_get_vf_config(struct net_device *dev, int vf,
 			struct ifla_vf_info *ivi);
 int bnx2x_set_vf_mac(struct net_device *dev, int queue, u8 *mac);
-int bnx2x_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos);
+int bnx2x_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos,
+		      __be16 vlan_proto);
 
 /* select_queue callback */
 u16 bnx2x_select_queue(struct net_device *dev, struct sk_buff *skb,
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
index 632daff117d3..2f18bd856913 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
@@ -2527,7 +2527,8 @@ void bnx2x_pf_set_vfs_vlan(struct bnx2x *bp)
 	for_each_vf(bp, vfidx) {
 		bulletin = BP_VF_BULLETIN(bp, vfidx);
 		if (bulletin->valid_bitmap & (1 << VLAN_VALID))
-			bnx2x_set_vf_vlan(bp->dev, vfidx, bulletin->vlan, 0);
+			bnx2x_set_vf_vlan(bp->dev, vfidx, bulletin->vlan, 0,
+					  htons(ETH_P_8021Q));
 	}
 }
 
@@ -2787,7 +2788,8 @@ static int bnx2x_set_vf_vlan_filter(struct bnx2x *bp, struct bnx2x_virtf *vf,
 	return 0;
 }
 
-int bnx2x_set_vf_vlan(struct net_device *dev, int vfidx, u16 vlan, u8 qos)
+int bnx2x_set_vf_vlan(struct net_device *dev, int vfidx, u16 vlan, u8 qos,
+		      __be16 vlan_proto)
 {
 	struct pf_vf_bulletin_content *bulletin = NULL;
 	struct bnx2x *bp = netdev_priv(dev);
@@ -2802,6 +2804,9 @@ int bnx2x_set_vf_vlan(struct net_device *dev, int vfidx, u16 vlan, u8 qos)
 		return -EINVAL;
 	}
 
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+
 	DP(BNX2X_MSG_IOV, "configuring VF %d with VLAN %d qos %d\n",
 	   vfidx, vlan, 0);
 
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.h b/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.h
index 0392670ab49c..1ab72e4820af 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.h
@@ -12,7 +12,7 @@
 
 int bnxt_get_vf_config(struct net_device *, int, struct ifla_vf_info *);
 int bnxt_set_vf_mac(struct net_device *, int, u8 *);
-int bnxt_set_vf_vlan(struct net_device *, int, u16, u8);
+int bnxt_set_vf_vlan(struct net_device *, int, u16, u8, __be16);
 int bnxt_set_vf_bw(struct net_device *, int, int, int);
 int bnxt_set_vf_link_state(struct net_device *, int, int);
 int bnxt_set_vf_spoofchk(struct net_device *, int, bool);
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index 0ac66d3441d7..3ec738936a98 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -1702,7 +1702,8 @@ static int be_clear_vf_tvt(struct be_adapter *adapter, int vf)
 	return 0;
 }
 
-static int be_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos)
+static int be_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos,
+			  __be16 vlan_proto)
 {
 	struct be_adapter *adapter = netdev_priv(netdev);
 	struct be_vf_cfg *vf_cfg = &adapter->vf_cfg[vf];
@@ -1714,6 +1715,9 @@ static int be_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos)
 	if (vf >= adapter->num_vfs || vlan > 4095 || qos > 7)
 		return -EINVAL;
 
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+
 	if (vlan || qos) {
 		vlan |= qos << VLAN_PRIO_SHIFT;
 		status = be_set_vf_tvt(adapter, vf, vlan);
* Unmerged path drivers/net/ethernet/intel/fm10k/fm10k.h
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_iov.c b/drivers/net/ethernet/intel/fm10k/fm10k_iov.c
index cdafc4b2fd54..0b66ce69e7fa 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_iov.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_iov.c
@@ -445,7 +445,7 @@ int fm10k_ndo_set_vf_mac(struct net_device *netdev, int vf_idx, u8 *mac)
 }
 
 int fm10k_ndo_set_vf_vlan(struct net_device *netdev, int vf_idx, u16 vid,
-			  u8 qos)
+			  u8 qos, __be16 vlan_proto)
 {
 	struct fm10k_intfc *interface = netdev_priv(netdev);
 	struct fm10k_iov_data *iov_data = interface->iov_data;
@@ -460,6 +460,10 @@ int fm10k_ndo_set_vf_vlan(struct net_device *netdev, int vf_idx, u16 vid,
 	if (qos || (vid > (VLAN_VID_MASK - 1)))
 		return -EINVAL;
 
+	/* VF VLAN Protocol part to default is unsupported */
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+
 	vf_info = &iov_data->vf_info[vf_idx];
 
 	/* exit if there is nothing to do */
diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index ba2d37755d79..d3f3b4c54b36 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@ -2741,11 +2741,12 @@ error_param:
  * @vf_id: VF identifier
  * @vlan_id: mac address
  * @qos: priority setting
+ * @vlan_proto: vlan protocol
  *
  * program VF vlan id and/or qos
  **/
-int i40e_ndo_set_vf_port_vlan(struct net_device *netdev,
-			      int vf_id, u16 vlan_id, u8 qos)
+int i40e_ndo_set_vf_port_vlan(struct net_device *netdev, int vf_id,
+			      u16 vlan_id, u8 qos, __be16 vlan_proto)
 {
 	u16 vlanprio = vlan_id | (qos << I40E_VLAN_PRIORITY_SHIFT);
 	struct i40e_netdev_priv *np = netdev_priv(netdev);
@@ -2768,6 +2769,12 @@ int i40e_ndo_set_vf_port_vlan(struct net_device *netdev,
 		goto error_pvid;
 	}
 
+	if (vlan_proto != htons(ETH_P_8021Q)) {
+		dev_err(&pf->pdev->dev, "VF VLAN protocol is not supported\n");
+		ret = -EPROTONOSUPPORT;
+		goto error_pvid;
+	}
+
 	vf = &(pf->vf[vf_id]);
 	vsi = pf->vsi[vf->lan_vsi_idx];
 	if (!test_bit(I40E_VF_STAT_INIT, &vf->vf_states)) {
diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
index 875174141451..4012d069939a 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
@@ -129,8 +129,8 @@ void i40e_vc_notify_vf_reset(struct i40e_vf *vf);
 
 /* VF configuration related iplink handlers */
 int i40e_ndo_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac);
-int i40e_ndo_set_vf_port_vlan(struct net_device *netdev,
-			      int vf_id, u16 vlan_id, u8 qos);
+int i40e_ndo_set_vf_port_vlan(struct net_device *netdev, int vf_id,
+			      u16 vlan_id, u8 qos, __be16 vlan_proto);
 int i40e_ndo_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate,
 		       int max_tx_rate);
 int i40e_ndo_set_vf_trust(struct net_device *netdev, int vf_id, bool setting);
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index 01dc74f6140a..4c1f6b0ccd94 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -169,7 +169,7 @@ static int igb_set_vf_mac(struct igb_adapter *, int, unsigned char *);
 static void igb_restore_vf_multicasts(struct igb_adapter *adapter);
 static int igb_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac);
 static int igb_ndo_set_vf_vlan(struct net_device *netdev,
-			       int vf, u16 vlan, u8 qos);
+			       int vf, u16 vlan, u8 qos, __be16 vlan_proto);
 static int igb_ndo_set_vf_bw(struct net_device *, int, int, int);
 static int igb_ndo_set_vf_spoofchk(struct net_device *netdev, int vf,
 				   bool setting);
@@ -6149,14 +6149,17 @@ static int igb_disable_port_vlan(struct igb_adapter *adapter, int vf)
 	return 0;
 }
 
-static int igb_ndo_set_vf_vlan(struct net_device *netdev,
-			       int vf, u16 vlan, u8 qos)
+static int igb_ndo_set_vf_vlan(struct net_device *netdev, int vf,
+			       u16 vlan, u8 qos, __be16 vlan_proto)
 {
 	struct igb_adapter *adapter = netdev_priv(netdev);
 
 	if ((vf >= adapter->vfs_allocated_count) || (vlan > 4095) || (qos > 7))
 		return -EINVAL;
 
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+
 	return (vlan || qos) ? igb_enable_port_vlan(adapter, vf, vlan, qos) :
 			       igb_disable_port_vlan(adapter, vf);
 }
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
index 9021c06fd5c9..d86a6de8a8a1 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
@@ -1357,13 +1357,16 @@ static int ixgbe_disable_port_vlan(struct ixgbe_adapter *adapter, int vf)
 	return err;
 }
 
-int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos)
+int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan,
+			  u8 qos, __be16 vlan_proto)
 {
 	int err = 0;
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
 	if ((vf >= adapter->num_vfs) || (vlan > 4095) || (qos > 7))
 		return -EINVAL;
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
 	if (vlan || qos) {
 		/* Check if there is already a port VLAN set, if so
 		 * we have to delete the old one first before we
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 5e3b15bcd2e7..51b03319ab3a 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -2363,11 +2363,15 @@ static int mlx4_en_set_vf_mac(struct net_device *dev, int queue, u8 *mac)
 	return mlx4_set_vf_mac(mdev->dev, en_priv->port, queue, mac_u64);
 }
 
-static int mlx4_en_set_vf_vlan(struct net_device *dev, int vf, u16 vlan, u8 qos)
+static int mlx4_en_set_vf_vlan(struct net_device *dev, int vf, u16 vlan, u8 qos,
+			       __be16 vlan_proto)
 {
 	struct mlx4_en_priv *en_priv = netdev_priv(dev);
 	struct mlx4_en_dev *mdev = en_priv->mdev;
 
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+
 	return mlx4_set_vf_vlan(mdev->dev, en_priv->port, vf, vlan, qos);
 }
 
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 5b3eec92a461..aa54122ed6ea 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -2436,11 +2436,15 @@ static int mlx5e_set_vf_mac(struct net_device *dev, int vf, u8 *mac)
 	return mlx5_eswitch_set_vport_mac(mdev->priv.eswitch, vf + 1, mac);
 }
 
-static int mlx5e_set_vf_vlan(struct net_device *dev, int vf, u16 vlan, u8 qos)
+static int mlx5e_set_vf_vlan(struct net_device *dev, int vf, u16 vlan, u8 qos,
+			     __be16 vlan_proto)
 {
 	struct mlx5e_priv *priv = netdev_priv(dev);
 	struct mlx5_core_dev *mdev = priv->mdev;
 
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+
 	return mlx5_eswitch_set_vport_vlan(mdev->priv.eswitch, vf + 1,
 					   vlan, qos);
 }
diff --git a/drivers/net/ethernet/qlogic/qede/qede_main.c b/drivers/net/ethernet/qlogic/qede/qede_main.c
index eb2658484288..b6b412bffa96 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_main.c
@@ -103,7 +103,8 @@ static int qede_alloc_rx_buffer(struct qede_dev *edev,
 static void qede_link_update(void *dev, struct qed_link_output *link);
 
 #ifdef CONFIG_QED_SRIOV
-static int qede_set_vf_vlan(struct net_device *ndev, int vf, u16 vlan, u8 qos)
+static int qede_set_vf_vlan(struct net_device *ndev, int vf, u16 vlan, u8 qos,
+			    __be16 vlan_proto)
 {
 	struct qede_dev *edev = netdev_priv(ndev);
 
@@ -112,6 +113,9 @@ static int qede_set_vf_vlan(struct net_device *ndev, int vf, u16 vlan, u8 qos)
 		return -EINVAL;
 	}
 
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+
 	DP_VERBOSE(edev, QED_MSG_IOV, "Setting Vlan 0x%04x to VF [%d]\n",
 		   vlan, vf);
 
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov.h b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov.h
index 24061b9b92e8..5f327659efa7 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov.h
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov.h
@@ -238,7 +238,7 @@ int qlcnic_sriov_set_vf_mac(struct net_device *, int, u8 *);
 int qlcnic_sriov_set_vf_tx_rate(struct net_device *, int, int, int);
 int qlcnic_sriov_get_vf_config(struct net_device *, int ,
 			       struct ifla_vf_info *);
-int qlcnic_sriov_set_vf_vlan(struct net_device *, int, u16, u8);
+int qlcnic_sriov_set_vf_vlan(struct net_device *, int, u16, u8, __be16);
 int qlcnic_sriov_set_vf_spoofchk(struct net_device *, int, bool);
 #else
 static inline void qlcnic_sriov_pf_disable(struct qlcnic_adapter *adapter) {}
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c
index 4032e89116d0..53c145f3d930 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c
@@ -1908,7 +1908,7 @@ int qlcnic_sriov_set_vf_tx_rate(struct net_device *netdev, int vf,
 }
 
 int qlcnic_sriov_set_vf_vlan(struct net_device *netdev, int vf,
-			     u16 vlan, u8 qos)
+			     u16 vlan, u8 qos, __be16 vlan_proto)
 {
 	struct qlcnic_adapter *adapter = netdev_priv(netdev);
 	struct qlcnic_sriov *sriov = adapter->ahw->sriov;
@@ -1921,6 +1921,9 @@ int qlcnic_sriov_set_vf_vlan(struct net_device *netdev, int vf,
 	if (vf >= sriov->num_vfs || qos > 7)
 		return -EINVAL;
 
+	if (vlan_proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+
 	if (vlan > MAX_VLAN_ID) {
 		netdev_err(netdev,
 			   "Invalid VLAN ID, allowed range is [0 - %d]\n",
diff --git a/drivers/net/ethernet/sfc/sriov.c b/drivers/net/ethernet/sfc/sriov.c
index 816c44689e67..9abcf4aded30 100644
--- a/drivers/net/ethernet/sfc/sriov.c
+++ b/drivers/net/ethernet/sfc/sriov.c
@@ -22,7 +22,7 @@ int efx_sriov_set_vf_mac(struct net_device *net_dev, int vf_i, u8 *mac)
 }
 
 int efx_sriov_set_vf_vlan(struct net_device *net_dev, int vf_i, u16 vlan,
-			  u8 qos)
+			  u8 qos, __be16 vlan_proto)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
@@ -31,6 +31,9 @@ int efx_sriov_set_vf_vlan(struct net_device *net_dev, int vf_i, u16 vlan,
 		    (qos & ~(VLAN_PRIO_MASK >> VLAN_PRIO_SHIFT)))
 			return -EINVAL;
 
+		if (vlan_proto != htons(ETH_P_8021Q))
+			return -EPROTONOSUPPORT;
+
 		return efx->type->sriov_set_vf_vlan(efx, vf_i, vlan, qos);
 	} else {
 		return -EOPNOTSUPP;
diff --git a/drivers/net/ethernet/sfc/sriov.h b/drivers/net/ethernet/sfc/sriov.h
index 400df526586d..ba1762e7f216 100644
--- a/drivers/net/ethernet/sfc/sriov.h
+++ b/drivers/net/ethernet/sfc/sriov.h
@@ -16,7 +16,7 @@
 
 int efx_sriov_set_vf_mac(struct net_device *net_dev, int vf_i, u8 *mac);
 int efx_sriov_set_vf_vlan(struct net_device *net_dev, int vf_i, u16 vlan,
-			  u8 qos);
+			  u8 qos, __be16 vlan_proto);
 int efx_sriov_set_vf_spoofchk(struct net_device *net_dev, int vf_i,
 			      bool spoofchk);
 int efx_sriov_get_vf_config(struct net_device *net_dev, int vf_i,
* Unmerged path include/linux/if_link.h
* Unmerged path include/linux/netdevice.h
diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
index 1b43f8aab560..21cdb5fc55a5 100644
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -492,7 +492,7 @@ enum {
 enum {
 	IFLA_VF_UNSPEC,
 	IFLA_VF_MAC,		/* Hardware queue specific attributes */
-	IFLA_VF_VLAN,
+	IFLA_VF_VLAN,		/* VLAN ID and QoS */
 	IFLA_VF_TX_RATE,	/* Max TX Bandwidth Allocation */
 	IFLA_VF_SPOOFCHK,	/* Spoof Checking on/off switch */
 	IFLA_VF_LINK_STATE,	/* link state enable/disable/auto switch */
@@ -504,6 +504,7 @@ enum {
 	IFLA_VF_TRUST,		/* Trust VF */
 	IFLA_VF_IB_NODE_GUID,	/* VF Infiniband node GUID */
 	IFLA_VF_IB_PORT_GUID,	/* VF Infiniband port GUID */
+	IFLA_VF_VLAN_LIST,	/* nested list of vlans, option for QinQ */
 	__IFLA_VF_MAX,
 };
 
@@ -520,6 +521,22 @@ struct ifla_vf_vlan {
 	__u32 qos;
 };
 
+enum {
+	IFLA_VF_VLAN_INFO_UNSPEC,
+	IFLA_VF_VLAN_INFO,	/* VLAN ID, QoS and VLAN protocol */
+	__IFLA_VF_VLAN_INFO_MAX,
+};
+
+#define IFLA_VF_VLAN_INFO_MAX (__IFLA_VF_VLAN_INFO_MAX - 1)
+#define MAX_VLAN_LIST_LEN 1
+
+struct ifla_vf_vlan_info {
+	__u32 vf;
+	__u32 vlan; /* 0 - 4095, 0 disables VLAN filter */
+	__u32 qos;
+	__be16 vlan_proto; /* VLAN protocol either 802.1Q or 802.1ad */
+};
+
 struct ifla_vf_tx_rate {
 	__u32 vf;
 	__u32 rate; /* Max TX bandwidth in Mbps, 0 disables throttling */
* Unmerged path net/core/rtnetlink.c
