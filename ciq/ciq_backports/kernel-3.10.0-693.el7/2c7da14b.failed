md/r5cache: sysfs entry journal_mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [md] r5cache: sysfs entry journal_mode (Jes Sorensen) [1380016]
Rebuild_FUZZ: 95.65%
commit-author Song Liu <songliubraving@fb.com>
commit 2c7da14b90a01e48b17a028de6050a796cfd6d8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2c7da14b.failed

With write cache, journal_mode is the knob to switch between
write-back and write-through.

Below is an example:

root@virt-test:~/# cat /sys/block/md0/md/journal_mode
[write-through] write-back
root@virt-test:~/# echo write-back > /sys/block/md0/md/journal_mode
root@virt-test:~/# cat /sys/block/md0/md/journal_mode
write-through [write-back]

	Signed-off-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 2c7da14b90a01e48b17a028de6050a796cfd6d8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5-cache.c
#	drivers/md/raid5.h
diff --cc drivers/md/raid5-cache.c
index f9e52fb68a1e,b9ad0e8fcf67..000000000000
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@@ -40,6 -50,49 +40,52 @@@
   */
  #define R5L_POOL_SIZE	4
  
++<<<<<<< HEAD
++=======
+ /*
+  * r5c journal modes of the array: write-back or write-through.
+  * write-through mode has identical behavior as existing log only
+  * implementation.
+  */
+ enum r5c_journal_mode {
+ 	R5C_JOURNAL_MODE_WRITE_THROUGH = 0,
+ 	R5C_JOURNAL_MODE_WRITE_BACK = 1,
+ };
+ 
+ static char *r5c_journal_mode_str[] = {"write-through",
+ 				       "write-back"};
+ /*
+  * raid5 cache state machine
+  *
+  * With rhe RAID cache, each stripe works in two phases:
+  *	- caching phase
+  *	- writing-out phase
+  *
+  * These two phases are controlled by bit STRIPE_R5C_CACHING:
+  *   if STRIPE_R5C_CACHING == 0, the stripe is in writing-out phase
+  *   if STRIPE_R5C_CACHING == 1, the stripe is in caching phase
+  *
+  * When there is no journal, or the journal is in write-through mode,
+  * the stripe is always in writing-out phase.
+  *
+  * For write-back journal, the stripe is sent to caching phase on write
+  * (r5c_try_caching_write). r5c_make_stripe_write_out() kicks off
+  * the write-out phase by clearing STRIPE_R5C_CACHING.
+  *
+  * Stripes in caching phase do not write the raid disks. Instead, all
+  * writes are committed from the log device. Therefore, a stripe in
+  * caching phase handles writes as:
+  *	- write to log device
+  *	- return IO
+  *
+  * Stripes in writing-out phase handle writes as:
+  *	- calculate parity
+  *	- write pending data and parity to journal
+  *	- write data and parity to raid disks
+  *	- return IO for pending writes
+  */
+ 
++>>>>>>> 2c7da14b90a0 (md/r5cache: sysfs entry journal_mode)
  struct r5l_log {
  	struct md_rdev *rdev;
  
@@@ -1123,6 -1619,266 +1169,269 @@@ static void r5l_write_super(struct r5l_
  	set_bit(MD_CHANGE_DEVS, &mddev->flags);
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t r5c_journal_mode_show(struct mddev *mddev, char *page)
+ {
+ 	struct r5conf *conf = mddev->private;
+ 	int ret;
+ 
+ 	if (!conf->log)
+ 		return 0;
+ 
+ 	switch (conf->log->r5c_journal_mode) {
+ 	case R5C_JOURNAL_MODE_WRITE_THROUGH:
+ 		ret = snprintf(
+ 			page, PAGE_SIZE, "[%s] %s\n",
+ 			r5c_journal_mode_str[R5C_JOURNAL_MODE_WRITE_THROUGH],
+ 			r5c_journal_mode_str[R5C_JOURNAL_MODE_WRITE_BACK]);
+ 		break;
+ 	case R5C_JOURNAL_MODE_WRITE_BACK:
+ 		ret = snprintf(
+ 			page, PAGE_SIZE, "%s [%s]\n",
+ 			r5c_journal_mode_str[R5C_JOURNAL_MODE_WRITE_THROUGH],
+ 			r5c_journal_mode_str[R5C_JOURNAL_MODE_WRITE_BACK]);
+ 		break;
+ 	default:
+ 		ret = 0;
+ 	}
+ 	return ret;
+ }
+ 
+ static ssize_t r5c_journal_mode_store(struct mddev *mddev,
+ 				      const char *page, size_t length)
+ {
+ 	struct r5conf *conf = mddev->private;
+ 	struct r5l_log *log = conf->log;
+ 	int val = -1, i;
+ 	int len = length;
+ 
+ 	if (!log)
+ 		return -ENODEV;
+ 
+ 	if (len && page[len - 1] == '\n')
+ 		len -= 1;
+ 	for (i = 0; i < ARRAY_SIZE(r5c_journal_mode_str); i++)
+ 		if (strlen(r5c_journal_mode_str[i]) == len &&
+ 		    strncmp(page, r5c_journal_mode_str[i], len) == 0) {
+ 			val = i;
+ 			break;
+ 		}
+ 	if (val < R5C_JOURNAL_MODE_WRITE_THROUGH ||
+ 	    val > R5C_JOURNAL_MODE_WRITE_BACK)
+ 		return -EINVAL;
+ 
+ 	mddev_suspend(mddev);
+ 	conf->log->r5c_journal_mode = val;
+ 	mddev_resume(mddev);
+ 
+ 	pr_debug("md/raid:%s: setting r5c cache mode to %d: %s\n",
+ 		 mdname(mddev), val, r5c_journal_mode_str[val]);
+ 	return length;
+ }
+ 
+ struct md_sysfs_entry
+ r5c_journal_mode = __ATTR(journal_mode, 0644,
+ 			  r5c_journal_mode_show, r5c_journal_mode_store);
+ 
+ /*
+  * Try handle write operation in caching phase. This function should only
+  * be called in write-back mode.
+  *
+  * If all outstanding writes can be handled in caching phase, returns 0
+  * If writes requires write-out phase, call r5c_make_stripe_write_out()
+  * and returns -EAGAIN
+  */
+ int r5c_try_caching_write(struct r5conf *conf,
+ 			  struct stripe_head *sh,
+ 			  struct stripe_head_state *s,
+ 			  int disks)
+ {
+ 	struct r5l_log *log = conf->log;
+ 	int i;
+ 	struct r5dev *dev;
+ 	int to_cache = 0;
+ 
+ 	BUG_ON(!r5c_is_writeback(log));
+ 
+ 	if (!test_bit(STRIPE_R5C_CACHING, &sh->state)) {
+ 		/*
+ 		 * There are two different scenarios here:
+ 		 *  1. The stripe has some data cached, and it is sent to
+ 		 *     write-out phase for reclaim
+ 		 *  2. The stripe is clean, and this is the first write
+ 		 *
+ 		 * For 1, return -EAGAIN, so we continue with
+ 		 * handle_stripe_dirtying().
+ 		 *
+ 		 * For 2, set STRIPE_R5C_CACHING and continue with caching
+ 		 * write.
+ 		 */
+ 
+ 		/* case 1: anything injournal or anything in written */
+ 		if (s->injournal > 0 || s->written > 0)
+ 			return -EAGAIN;
+ 		/* case 2 */
+ 		set_bit(STRIPE_R5C_CACHING, &sh->state);
+ 	}
+ 
+ 	for (i = disks; i--; ) {
+ 		dev = &sh->dev[i];
+ 		/* if non-overwrite, use writing-out phase */
+ 		if (dev->towrite && !test_bit(R5_OVERWRITE, &dev->flags) &&
+ 		    !test_bit(R5_InJournal, &dev->flags)) {
+ 			r5c_make_stripe_write_out(sh);
+ 			return -EAGAIN;
+ 		}
+ 	}
+ 
+ 	for (i = disks; i--; ) {
+ 		dev = &sh->dev[i];
+ 		if (dev->towrite) {
+ 			set_bit(R5_Wantwrite, &dev->flags);
+ 			set_bit(R5_Wantdrain, &dev->flags);
+ 			set_bit(R5_LOCKED, &dev->flags);
+ 			to_cache++;
+ 		}
+ 	}
+ 
+ 	if (to_cache) {
+ 		set_bit(STRIPE_OP_BIODRAIN, &s->ops_request);
+ 		/*
+ 		 * set STRIPE_LOG_TRAPPED, which triggers r5c_cache_data()
+ 		 * in ops_run_io(). STRIPE_LOG_TRAPPED will be cleared in
+ 		 * r5c_handle_data_cached()
+ 		 */
+ 		set_bit(STRIPE_LOG_TRAPPED, &sh->state);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * free extra pages (orig_page) we allocated for prexor
+  */
+ void r5c_release_extra_page(struct stripe_head *sh)
+ {
+ 	int i;
+ 
+ 	for (i = sh->disks; i--; )
+ 		if (sh->dev[i].page != sh->dev[i].orig_page) {
+ 			struct page *p = sh->dev[i].orig_page;
+ 
+ 			sh->dev[i].orig_page = sh->dev[i].page;
+ 			put_page(p);
+ 		}
+ }
+ 
+ /*
+  * clean up the stripe (clear R5_InJournal for dev[pd_idx] etc.) after the
+  * stripe is committed to RAID disks.
+  */
+ void r5c_finish_stripe_write_out(struct r5conf *conf,
+ 				 struct stripe_head *sh,
+ 				 struct stripe_head_state *s)
+ {
+ 	int i;
+ 	int do_wakeup = 0;
+ 
+ 	if (!conf->log ||
+ 	    !test_bit(R5_InJournal, &sh->dev[sh->pd_idx].flags))
+ 		return;
+ 
+ 	WARN_ON(test_bit(STRIPE_R5C_CACHING, &sh->state));
+ 	clear_bit(R5_InJournal, &sh->dev[sh->pd_idx].flags);
+ 
+ 	if (conf->log->r5c_journal_mode == R5C_JOURNAL_MODE_WRITE_THROUGH)
+ 		return;
+ 
+ 	for (i = sh->disks; i--; ) {
+ 		clear_bit(R5_InJournal, &sh->dev[i].flags);
+ 		if (test_and_clear_bit(R5_Overlap, &sh->dev[i].flags))
+ 			do_wakeup = 1;
+ 	}
+ 
+ 	/*
+ 	 * analyse_stripe() runs before r5c_finish_stripe_write_out(),
+ 	 * We updated R5_InJournal, so we also update s->injournal.
+ 	 */
+ 	s->injournal = 0;
+ 
+ 	if (test_and_clear_bit(STRIPE_FULL_WRITE, &sh->state))
+ 		if (atomic_dec_and_test(&conf->pending_full_writes))
+ 			md_wakeup_thread(conf->mddev->thread);
+ 
+ 	if (do_wakeup)
+ 		wake_up(&conf->wait_for_overlap);
+ 
+ 	if (conf->log->r5c_journal_mode == R5C_JOURNAL_MODE_WRITE_THROUGH)
+ 		return;
+ 
+ 	spin_lock_irq(&conf->log->stripe_in_journal_lock);
+ 	list_del_init(&sh->r5c);
+ 	spin_unlock_irq(&conf->log->stripe_in_journal_lock);
+ 	sh->log_start = MaxSector;
+ 	atomic_dec(&conf->log->stripe_in_journal_count);
+ }
+ 
+ int
+ r5c_cache_data(struct r5l_log *log, struct stripe_head *sh,
+ 	       struct stripe_head_state *s)
+ {
+ 	struct r5conf *conf = sh->raid_conf;
+ 	int pages = 0;
+ 	int reserve;
+ 	int i;
+ 	int ret = 0;
+ 
+ 	BUG_ON(!log);
+ 
+ 	for (i = 0; i < sh->disks; i++) {
+ 		void *addr;
+ 
+ 		if (!test_bit(R5_Wantwrite, &sh->dev[i].flags))
+ 			continue;
+ 		addr = kmap_atomic(sh->dev[i].page);
+ 		sh->dev[i].log_checksum = crc32c_le(log->uuid_checksum,
+ 						    addr, PAGE_SIZE);
+ 		kunmap_atomic(addr);
+ 		pages++;
+ 	}
+ 	WARN_ON(pages == 0);
+ 
+ 	/*
+ 	 * The stripe must enter state machine again to call endio, so
+ 	 * don't delay.
+ 	 */
+ 	clear_bit(STRIPE_DELAYED, &sh->state);
+ 	atomic_inc(&sh->count);
+ 
+ 	mutex_lock(&log->io_mutex);
+ 	/* meta + data */
+ 	reserve = (1 + pages) << (PAGE_SHIFT - 9);
+ 
+ 	if (test_bit(R5C_LOG_CRITICAL, &conf->cache_state) &&
+ 	    sh->log_start == MaxSector)
+ 		r5l_add_no_space_stripe(log, sh);
+ 	else if (!r5l_has_free_space(log, reserve)) {
+ 		if (sh->log_start == log->last_checkpoint)
+ 			BUG();
+ 		else
+ 			r5l_add_no_space_stripe(log, sh);
+ 	} else {
+ 		ret = r5l_log_stripe(log, sh, pages, 0);
+ 		if (ret) {
+ 			spin_lock_irq(&log->io_list_lock);
+ 			list_add_tail(&sh->log_list, &log->no_mem_stripes);
+ 			spin_unlock_irq(&log->io_list_lock);
+ 		}
+ 	}
+ 
+ 	mutex_unlock(&log->io_mutex);
+ 	return 0;
+ }
+ 
++>>>>>>> 2c7da14b90a0 (md/r5cache: sysfs entry journal_mode)
  static int r5l_load_log(struct r5l_log *log)
  {
  	struct md_rdev *rdev = log->rdev;
diff --cc drivers/md/raid5.h
index 517d4b68a1be,a698113c6188..000000000000
--- a/drivers/md/raid5.h
+++ b/drivers/md/raid5.h
@@@ -635,4 -756,22 +635,25 @@@ extern void r5l_stripe_write_finished(s
  extern int r5l_handle_flush_request(struct r5l_log *log, struct bio *bio);
  extern void r5l_quiesce(struct r5l_log *log, int state);
  extern bool r5l_log_disk_error(struct r5conf *conf);
++<<<<<<< HEAD
++=======
+ extern bool r5c_is_writeback(struct r5l_log *log);
+ extern int
+ r5c_try_caching_write(struct r5conf *conf, struct stripe_head *sh,
+ 		      struct stripe_head_state *s, int disks);
+ extern void
+ r5c_finish_stripe_write_out(struct r5conf *conf, struct stripe_head *sh,
+ 			    struct stripe_head_state *s);
+ extern void r5c_release_extra_page(struct stripe_head *sh);
+ extern void r5l_wake_reclaim(struct r5l_log *log, sector_t space);
+ extern void r5c_handle_cached_data_endio(struct r5conf *conf,
+ 	struct stripe_head *sh, int disks, struct bio_list *return_bi);
+ extern int r5c_cache_data(struct r5l_log *log, struct stripe_head *sh,
+ 			  struct stripe_head_state *s);
+ extern void r5c_make_stripe_write_out(struct stripe_head *sh);
+ extern void r5c_flush_cache(struct r5conf *conf, int num);
+ extern void r5c_check_stripe_cache_usage(struct r5conf *conf);
+ extern void r5c_check_cached_full_stripe(struct r5conf *conf);
+ extern struct md_sysfs_entry r5c_journal_mode;
++>>>>>>> 2c7da14b90a0 (md/r5cache: sysfs entry journal_mode)
  #endif
* Unmerged path drivers/md/raid5-cache.c
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index e4353594a601..6d4db64b3723 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -6259,6 +6259,7 @@ static struct attribute *raid5_attrs[] =  {
 	&raid5_group_thread_cnt.attr,
 	&raid5_skip_copy.attr,
 	&raid5_rmw_level.attr,
+	&r5c_journal_mode.attr,
 	NULL,
 };
 static struct attribute_group raid5_attrs_group = {
* Unmerged path drivers/md/raid5.h
