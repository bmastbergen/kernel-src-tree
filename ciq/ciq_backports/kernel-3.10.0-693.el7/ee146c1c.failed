KVM: nVMX: propagate errors from prepare_vmcs02

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ladi Prosek <lprosek@redhat.com>
commit ee146c1c100dbe9ca92252be2e901b957476b253
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ee146c1c.failed

It is possible that prepare_vmcs02 fails to load the guest state. This
patch adds the proper error handling for such a case. L1 will receive
an INVALID_STATE vmexit with the appropriate exit qualification if it
happens.

A failure to set guest CR3 is the only error propagated from prepare_vmcs02
at the moment.

	Signed-off-by: Ladi Prosek <lprosek@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit ee146c1c100dbe9ca92252be2e901b957476b253)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index c4ff252596cb,39a389f17f4a..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9695,8 -10291,31 +9698,36 @@@ static int prepare_vmcs02(struct kvm_vc
  	vmx_set_cr4(vcpu, vmcs12->guest_cr4);
  	vmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));
  
++<<<<<<< HEAD
 +	/* shadow page tables on either EPT or shadow page tables */
 +	kvm_set_cr3(vcpu, vmcs12->guest_cr3);
++=======
+ 	if (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)
+ 		vcpu->arch.efer = vmcs12->guest_ia32_efer;
+ 	else if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)
+ 		vcpu->arch.efer |= (EFER_LMA | EFER_LME);
+ 	else
+ 		vcpu->arch.efer &= ~(EFER_LMA | EFER_LME);
+ 	/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */
+ 	vmx_set_efer(vcpu, vcpu->arch.efer);
+ 
+ 	/*
+ 	 * Shadow page tables on either EPT or shadow page tables.
+ 	 * If PAE and EPT are both on, CR3 is not used by the CPU and must not
+ 	 * be dereferenced.
+ 	 */
+ 	if (is_pae(vcpu) && is_paging(vcpu) && !is_long_mode(vcpu) &&
+ 	    nested_ept_enabled) {
+ 		vcpu->arch.cr3 = vmcs12->guest_cr3;
+ 		__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);
+ 	} else {
+ 		if (kvm_set_cr3(vcpu, vmcs12->guest_cr3)) {
+ 			*entry_failure_code = ENTRY_FAIL_DEFAULT;
+ 			return 1;
+ 		}
+ 	}
+ 
++>>>>>>> ee146c1c100d (KVM: nVMX: propagate errors from prepare_vmcs02)
  	kvm_mmu_reset_context(vcpu);
  
  	if (!enable_ept)
@@@ -9728,12 -10348,14 +9760,13 @@@ static int nested_vmx_run(struct kvm_vc
  	struct loaded_vmcs *vmcs02;
  	bool ia32e;
  	u32 msr_entry_idx;
+ 	unsigned long exit_qualification;
  
 -	if (!nested_vmx_check_permission(vcpu))
 +	if (!nested_vmx_check_permission(vcpu) ||
 +	    !nested_vmx_check_vmcs12(vcpu))
  		return 1;
  
 -	if (!nested_vmx_check_vmcs12(vcpu))
 -		goto out;
 -
 +	skip_emulated_instruction(vcpu);
  	vmcs12 = get_vmcs12(vcpu);
  
  	if (enable_shadow_vmcs)
* Unmerged path arch/x86/kvm/vmx.c
