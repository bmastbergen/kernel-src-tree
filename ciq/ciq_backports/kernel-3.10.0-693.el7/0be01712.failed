HID: wacom: Report correct device resolution when using the wireless adapater

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Report correct device resolution when using the wireless adapater (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.64%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 0be017120b80f0fe3da9a8239f989a27e54828f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0be01712.failed

The 'wacom_wireless_work' function does not recalculate the tablet's
resolution, causing the value contained in the 'features' struct to
always be reported to userspace. This value is valid only for the pen
interface, meaning that the value will be incorrect for the touchpad (if
present). This in particular causes problems for libinput which relies
on the reported resolution being correct.

This patch adds the necessary calls to recalculate the resolution for
each interface. This requires a little bit of code shuffling since both
the 'wacom_set_default_phy' and 'wacom_calculate_res' are declared below
their new first point of use in 'wacom_wireless_work'.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 0be017120b80f0fe3da9a8239f989a27e54828f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,01b937e63cf3..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1220,30 -1369,52 +1253,59 @@@ static void wacom_wireless_work(struct 
  
  		/* Stylus interface */
  		wacom_wac1->features =
++<<<<<<< HEAD
 +			*((struct wacom_features *)id->driver_info);
 +		wacom_wac1->features.device_type = BTN_TOOL_PEN;
 +		snprintf(wacom_wac1->name, WACOM_NAME_MAX, "%s (WL) Pen",
++=======
+ 			*((struct wacom_features *)id->driver_data);
+ 		wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PEN;
+ 		if (wacom_wac1->features.type != INTUOSHT &&
+ 		    wacom_wac1->features.type != BAMBOO_PT)
+ 			wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PAD;
+ 		wacom_set_default_phy(&wacom_wac1->features);
+ 		wacom_calculate_res(&wacom_wac1->features);
+ 		snprintf(wacom_wac1->pen_name, WACOM_NAME_MAX, "%s (WL) Pen",
++>>>>>>> 0be017120b80 (HID: wacom: Report correct device resolution when using the wireless adapater)
  			 wacom_wac1->features.name);
 -		snprintf(wacom_wac1->pad_name, WACOM_NAME_MAX, "%s (WL) Pad",
 -			 wacom_wac1->features.name);
 -		wacom_wac1->shared->touch_max = wacom_wac1->features.touch_max;
 -		wacom_wac1->shared->type = wacom_wac1->features.type;
 -		wacom_wac1->pid = wacom_wac->pid;
 -		error = wacom_allocate_inputs(wacom1) ||
 -			wacom_register_inputs(wacom1);
 +		error = wacom_register_input(wacom1);
  		if (error)
  			goto fail;
  
  		/* Touch interface */
 -		if (wacom_wac1->features.touch_max ||
 -		    wacom_wac1->features.type == INTUOSHT) {
 +		if (wacom_wac1->features.touch_max) {
  			wacom_wac2->features =
 -				*((struct wacom_features *)id->driver_data);
 +				*((struct wacom_features *)id->driver_info);
  			wacom_wac2->features.pktlen = WACOM_PKGLEN_BBTOUCH3;
++<<<<<<< HEAD
 +			wacom_wac2->features.device_type = BTN_TOOL_FINGER;
 +			wacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;
 +			if (wacom_wac2->features.touch_max)
 +				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
 +					 "%s (WL) Finger",wacom_wac2->features.name);
 +			else
 +				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
 +					 "%s (WL) Pad",wacom_wac2->features.name);
 +			error = wacom_register_input(wacom2);
++=======
+ 			wacom_set_default_phy(&wacom_wac2->features);
+ 			wacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;
+ 			wacom_calculate_res(&wacom_wac2->features);
+ 			snprintf(wacom_wac2->touch_name, WACOM_NAME_MAX,
+ 				 "%s (WL) Finger",wacom_wac2->features.name);
+ 			snprintf(wacom_wac2->pad_name, WACOM_NAME_MAX,
+ 				 "%s (WL) Pad",wacom_wac2->features.name);
+ 			if (wacom_wac1->features.touch_max)
+ 				wacom_wac2->features.device_type |= WACOM_DEVICETYPE_TOUCH;
+ 			if (wacom_wac1->features.type == INTUOSHT ||
+ 			    wacom_wac1->features.type == BAMBOO_PT)
+ 				wacom_wac2->features.device_type |= WACOM_DEVICETYPE_PAD;
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			error = wacom_allocate_inputs(wacom2) ||
+ 				wacom_register_inputs(wacom2);
++>>>>>>> 0be017120b80 (HID: wacom: Report correct device resolution when using the wireless adapater)
  			if (error)
  				goto fail;
 -
 -			if (wacom_wac1->features.type == INTUOSHT &&
 -			    wacom_wac1->features.touch_max)
 -				wacom_wac->shared->touch_input = wacom_wac2->touch_input;
  		}
  
  		error = wacom_initialize_battery(wacom);
@@@ -1266,37 -1430,85 +1328,55 @@@ fail
  	return;
  }
  
++<<<<<<< HEAD
 +/*
 + * Not all devices report physical dimensions from HID.
 + * Compute the default from hardcoded logical dimension
 + * and resolution before driver overwrites them.
 + */
 +static void wacom_set_default_phy(struct wacom_features *features)
 +{
 +	if (features->x_resolution) {
 +		features->x_phy = (features->x_max * 100) /
 +					features->x_resolution;
 +		features->y_phy = (features->y_max * 100) /
 +					features->y_resolution;
 +	}
 +}
 +
 +static void wacom_calculate_res(struct wacom_features *features)
 +{
 +	features->x_resolution = wacom_calc_hid_res(features->x_max,
 +						    features->x_phy,
 +						    features->unit,
 +						    features->unitExpo);
 +	features->y_resolution = wacom_calc_hid_res(features->y_max,
 +						    features->y_phy,
 +						    features->unit,
 +						    features->unitExpo);
 +}
 +
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
++=======
+ void wacom_battery_work(struct work_struct *work)
+ {
+ 	struct wacom *wacom = container_of(work, struct wacom, work);
+ 
+ 	if ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 	     !wacom->battery) {
+ 		wacom_initialize_battery(wacom);
+ 	}
+ 	else if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery) {
+ 		wacom_destroy_battery(wacom);
+ 	}
+ }
+ 
+ static size_t wacom_compute_pktlen(struct hid_device *hdev)
++>>>>>>> 0be017120b80 (HID: wacom: Report correct device resolution when using the wireless adapater)
  {
 -	struct hid_report_enum *report_enum;
 -	struct hid_report *report;
 -	size_t size = 0;
 -
 -	report_enum = hdev->report_enum + HID_INPUT_REPORT;
 -
 -	list_for_each_entry(report, &report_enum->report_list, list) {
 -		size_t report_size = hid_report_len(report);
 -		if (report_size > size)
 -			size = report_size;
 -	}
 -
 -	return size;
 -}
 -
 -static void wacom_update_name(struct wacom *wacom)
 -{
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct wacom_features *features = &wacom_wac->features;
 -	char name[WACOM_NAME_MAX];
 -
 -	/* Generic devices name unspecified */
 -	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
 -		if (strstr(wacom->hdev->name, "Wacom") ||
 -		    strstr(wacom->hdev->name, "wacom") ||
 -		    strstr(wacom->hdev->name, "WACOM")) {
 -			/* name is in HID descriptor, use it */
 -			strlcpy(name, wacom->hdev->name, sizeof(name));
 -
 -			/* strip out excess whitespaces */
 -			while (1) {
 -				char *gap = strstr(name, "  ");
 -				if (gap == NULL)
 -					break;
 -				/* shift everything including the terminator */
 -				memmove(gap, gap+1, strlen(gap));
 -			}
 -			/* get rid of trailing whitespace */
 -			if (name[strlen(name)-1] == ' ')
 -				name[strlen(name)-1] = '\0';
 -		} else {
 -			/* no meaningful name retrieved. use product ID */
 -			snprintf(name, sizeof(name),
 -				 "%s %X", features->name, wacom->hdev->product);
 -		}
 -	} else {
 -		strlcpy(name, features->name, sizeof(name));
 -	}
 -
 -	/* Append the device type to the name */
 -	snprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),
 -		"%s Pen", name);
 -	snprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),
 -		"%s Finger", name);
 -	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
 -		"%s Pad", name);
 -}
 -
 -static int wacom_probe(struct hid_device *hdev,
 -		const struct hid_device_id *id)
 -{
 -	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
* Unmerged path drivers/hid/wacom_sys.c
