net: ip_tunnel: remove 'csum_help' argument to iptunnel_handle_offloads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] ip_tunnel: remove 'csum_help' argument to iptunnel_handle_offloads (Sabrina Dubroca) [1326318]
Rebuild_FUZZ: 96.35%
commit-author Edward Cree <ecree@solarflare.com>
commit 6fa79666e24d32be1b709f5269af41ed9e829e7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6fa79666.failed

All users now pass false, so we can remove it, and remove the code that
 was conditional upon it.

	Signed-off-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6fa79666e24d32be1b709f5269af41ed9e829e7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fou.c
#	net/netfilter/ipvs/ip_vs_xmit.c
diff --cc net/ipv4/fou.c
index f471d6929968,88dab0c1670c..000000000000
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@@ -679,11 -783,11 +679,15 @@@ static void fou_build_udp(struct sk_buf
  int fou_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
  		     u8 *protocol, struct flowi4 *fl4)
  {
 -	int type = e->flags & TUNNEL_ENCAP_FLAG_CSUM ? SKB_GSO_UDP_TUNNEL_CSUM :
 -						       SKB_GSO_UDP_TUNNEL;
 +	bool csum = !!(e->flags & TUNNEL_ENCAP_FLAG_CSUM);
 +	int type = csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
  	__be16 sport;
  
++<<<<<<< HEAD
 +	skb = iptunnel_handle_offloads(skb, csum, type);
++=======
+ 	skb = iptunnel_handle_offloads(skb, type);
++>>>>>>> 6fa79666e24d (net: ip_tunnel: remove 'csum_help' argument to iptunnel_handle_offloads)
  
  	if (IS_ERR(skb))
  		return PTR_ERR(skb);
@@@ -717,7 -820,7 +721,11 @@@ int gue_build_header(struct sk_buff *sk
  
  	optlen += need_priv ? GUE_LEN_PRIV : 0;
  
++<<<<<<< HEAD
 +	skb = iptunnel_handle_offloads(skb, csum, type);
++=======
+ 	skb = iptunnel_handle_offloads(skb, type);
++>>>>>>> 6fa79666e24d (net: ip_tunnel: remove 'csum_help' argument to iptunnel_handle_offloads)
  
  	if (IS_ERR(skb))
  		return PTR_ERR(skb);
diff --cc net/netfilter/ipvs/ip_vs_xmit.c
index 4fbf1730c473,a3f5cd9b3c4c..000000000000
--- a/net/netfilter/ipvs/ip_vs_xmit.c
+++ b/net/netfilter/ipvs/ip_vs_xmit.c
@@@ -857,16 -1011,17 +857,22 @@@ ip_vs_tunnel_xmit(struct sk_buff *skb, 
  	 */
  	max_headroom = LL_RESERVED_SPACE(tdev) + sizeof(struct iphdr);
  
 -	/* We only care about the df field if sysctl_pmtu_disc(ipvs) is set */
 -	dfp = sysctl_pmtu_disc(ipvs) ? &df : NULL;
 -	skb = ip_vs_prepare_tunneled_skb(skb, cp->af, max_headroom,
 -					 &next_protocol, NULL, &dsfield,
 -					 &ttl, dfp);
 -	if (IS_ERR(skb))
 -		goto tx_error;
 +	if (skb_headroom(skb) < max_headroom || skb_cloned(skb)) {
 +		struct sk_buff *new_skb =
 +			skb_realloc_headroom(skb, max_headroom);
  
++<<<<<<< HEAD
 +		if (!new_skb)
 +			goto tx_error;
 +		consume_skb(skb);
 +		skb = new_skb;
 +		old_iph = ip_hdr(skb);
 +	}
++=======
+ 	skb = iptunnel_handle_offloads(skb, __tun_gso_type_mask(AF_INET, cp->af));
+ 	if (IS_ERR(skb))
+ 		goto tx_error;
++>>>>>>> 6fa79666e24d (net: ip_tunnel: remove 'csum_help' argument to iptunnel_handle_offloads)
  
  	skb->transport_header = skb->network_header;
  
@@@ -948,16 -1105,15 +954,22 @@@ ip_vs_tunnel_xmit_v6(struct sk_buff *sk
  	 */
  	max_headroom = LL_RESERVED_SPACE(tdev) + sizeof(struct ipv6hdr);
  
 -	skb = ip_vs_prepare_tunneled_skb(skb, cp->af, max_headroom,
 -					 &next_protocol, &payload_len,
 -					 &dsfield, &ttl, NULL);
 -	if (IS_ERR(skb))
 -		goto tx_error;
 +	if (skb_headroom(skb) < max_headroom || skb_cloned(skb)) {
 +		struct sk_buff *new_skb =
 +			skb_realloc_headroom(skb, max_headroom);
  
++<<<<<<< HEAD
 +		if (!new_skb)
 +			goto tx_error;
 +		consume_skb(skb);
 +		skb = new_skb;
 +		old_iph = ipv6_hdr(skb);
 +	}
++=======
+ 	skb = iptunnel_handle_offloads(skb, __tun_gso_type_mask(AF_INET6, cp->af));
+ 	if (IS_ERR(skb))
+ 		goto tx_error;
++>>>>>>> 6fa79666e24d (net: ip_tunnel: remove 'csum_help' argument to iptunnel_handle_offloads)
  
  	skb->transport_header = skb->network_header;
  
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index 8f88cba29f1a..0bb3a5432545 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -1800,7 +1800,7 @@ static int vxlan_build_skb(struct sk_buff *skb, struct dst_entry *dst,
 	if (WARN_ON(!skb))
 		return -ENOMEM;
 
-	skb = iptunnel_handle_offloads(skb, false, type);
+	skb = iptunnel_handle_offloads(skb, type);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
diff --git a/include/net/ip_tunnels.h b/include/net/ip_tunnels.h
index c62b45515469..dc79f9405f87 100644
--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@ -314,8 +314,7 @@ void iptunnel_xmit(struct sock *sk, struct rtable *rt, struct sk_buff *skb,
 struct metadata_dst *iptunnel_metadata_reply(struct metadata_dst *md,
 					     gfp_t flags);
 
-struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb, bool gre_csum,
-					 int gso_type_mask);
+struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb, int gso_type_mask);
 
 static inline int iptunnel_pull_offloads(struct sk_buff *skb)
 {
diff --git a/include/net/udp_tunnel.h b/include/net/udp_tunnel.h
index fdc50733c4fe..43db8c692706 100644
--- a/include/net/udp_tunnel.h
+++ b/include/net/udp_tunnel.h
@@ -110,8 +110,7 @@ static inline struct sk_buff *udp_tunnel_handle_offloads(struct sk_buff *skb,
 {
 	int type = udp_csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
 
-	/* As we're a UDP tunnel, we support LCO, so don't need csum_help */
-	return iptunnel_handle_offloads(skb, false, type);
+	return iptunnel_handle_offloads(skb, type);
 }
 
 static inline void udp_tunnel_encap_enable(struct socket *sock)
* Unmerged path net/ipv4/fou.c
diff --git a/net/ipv4/ip_gre.c b/net/ipv4/ip_gre.c
index 685bbcd70289..ca91da699ab9 100644
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@ -504,8 +504,7 @@ static void __gre_xmit(struct sk_buff *skb, struct net_device *dev,
 static struct sk_buff *gre_handle_offloads(struct sk_buff *skb,
 					   bool csum)
 {
-	return iptunnel_handle_offloads(skb, false,
-					csum ? SKB_GSO_GRE_CSUM : SKB_GSO_GRE);
+	return iptunnel_handle_offloads(skb, csum ? SKB_GSO_GRE_CSUM : SKB_GSO_GRE);
 }
 
 static struct rtable *gre_get_rt(struct sk_buff *skb,
diff --git a/net/ipv4/ip_tunnel_core.c b/net/ipv4/ip_tunnel_core.c
index 709e729b47bf..18458f53d1e0 100644
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@ -148,7 +148,6 @@ struct metadata_dst *iptunnel_metadata_reply(struct metadata_dst *md,
 EXPORT_SYMBOL_GPL(iptunnel_metadata_reply);
 
 struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb,
-					 bool csum_help,
 					 int gso_type_mask)
 {
 	int err;
@@ -166,18 +165,13 @@ struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb,
 		return skb;
 	}
 
-	/* If packet is not gso and we are not offloading inner checksum,
-	 * clear encapsulation flag. This allows setting CHECKSUM_PARTIAL
-	 * on the outer header without confusing devices that implement
-	 * NETIF_F_IP_CSUM with encapsulation.
-	 */
-	if (skb->ip_summed == CHECKSUM_PARTIAL && csum_help) {
-		skb->encapsulation = 0;
-		err = skb_checksum_help(skb);
-		if (unlikely(err))
-			goto error;
-	} else if (skb->ip_summed != CHECKSUM_PARTIAL) {
+	if (skb->ip_summed != CHECKSUM_PARTIAL) {
 		skb->ip_summed = CHECKSUM_NONE;
+		/* We clear encapsulation here to prevent badly-written
+		 * drivers potentially deciding to offload an inner checksum
+		 * if we set CHECKSUM_PARTIAL on the outer header.
+		 * This should go away when the drivers are all fixed.
+		 */
 		skb->encapsulation = 0;
 	}
 
diff --git a/net/ipv4/ipip.c b/net/ipv4/ipip.c
index 8a09cef5a5aa..9013cc06f49f 100644
--- a/net/ipv4/ipip.c
+++ b/net/ipv4/ipip.c
@@ -220,7 +220,7 @@ static netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (unlikely(skb->protocol != htons(ETH_P_IP)))
 		goto tx_error;
 
-	skb = iptunnel_handle_offloads(skb, false, SKB_GSO_IPIP);
+	skb = iptunnel_handle_offloads(skb, SKB_GSO_IPIP);
 	if (IS_ERR(skb))
 		goto out;
 
diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c
index 06e147737499..bb65479460a6 100644
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@ -824,7 +824,7 @@ static netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,
 		goto tx_error;
 	}
 
-	skb = iptunnel_handle_offloads(skb, false, SKB_GSO_SIT);
+	skb = iptunnel_handle_offloads(skb, SKB_GSO_SIT);
 	if (IS_ERR(skb)) {
 		ip_rt_put(rt);
 		goto out;
@@ -913,7 +913,7 @@ static netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct ip_tunnel *tunnel = netdev_priv(dev);
 	const struct iphdr  *tiph = &tunnel->parms.iph;
 
-	skb = iptunnel_handle_offloads(skb, false, SKB_GSO_IPIP);
+	skb = iptunnel_handle_offloads(skb, SKB_GSO_IPIP);
 	if (IS_ERR(skb))
 		goto out;
 
* Unmerged path net/netfilter/ipvs/ip_vs_xmit.c
