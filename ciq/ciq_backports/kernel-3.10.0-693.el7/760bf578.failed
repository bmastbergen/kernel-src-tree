target: fix race during implicit transition work flushes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [target] fix race during implicit transition work flushes (Mike Christie) [1429008 1407016]
Rebuild_FUZZ: 92.31%
commit-author Mike Christie <mchristi@redhat.com>
commit 760bf578edf8122f2503a3a6a3f4b0de3b6ce0bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/760bf578.failed

This fixes the following races:

1. core_alua_do_transition_tg_pt could have read
tg_pt_gp_alua_access_state and gone into this if chunk:

if (!explicit &&
        atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state) ==
           ALUA_ACCESS_STATE_TRANSITION) {

and then core_alua_do_transition_tg_pt_work could update the
state. core_alua_do_transition_tg_pt would then only set
tg_pt_gp_alua_pending_state and the tg_pt_gp_alua_access_state would
not get updated with the second calls state.

2. core_alua_do_transition_tg_pt could be setting
tg_pt_gp_transition_complete while the tg_pt_gp_transition_work
is already completing. core_alua_do_transition_tg_pt then waits on the
completion that will never be called.

To handle these issues, we just call flush_work which will return when
core_alua_do_transition_tg_pt_work has completed so there is no need
to do the complete/wait. And, if core_alua_do_transition_tg_pt_work
was running, instead of trying to sneak in the state change, we just
schedule up another core_alua_do_transition_tg_pt_work call.

Note that this does not handle a possible race where there are multiple
threads call core_alua_do_transition_tg_pt at the same time. I think
we need a mutex in target_tg_pt_gp_alua_access_state_store.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 760bf578edf8122f2503a3a6a3f4b0de3b6ce0bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_alua.c
diff --cc drivers/target/target_core_alua.c
index 4483cd8d504a,fd7c16a7ca6e..000000000000
--- a/drivers/target/target_core_alua.c
+++ b/drivers/target/target_core_alua.c
@@@ -1083,17 -1079,8 +1083,22 @@@ static int core_alua_do_transition_tg_p
  	/*
  	 * Flush any pending transitions
  	 */
++<<<<<<< HEAD
 +	if (!explicit && tg_pt_gp->tg_pt_gp_implicit_trans_secs &&
 +	    atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state) ==
 +	    ALUA_ACCESS_STATE_TRANSITION) {
 +		/* Just in case */
 +		tg_pt_gp->tg_pt_gp_alua_pending_state = new_state;
 +		tg_pt_gp->tg_pt_gp_transition_complete = &wait;
 +		flush_delayed_work(&tg_pt_gp->tg_pt_gp_transition_work);
 +		wait_for_completion(&wait);
 +		tg_pt_gp->tg_pt_gp_transition_complete = NULL;
 +		return 0;
 +	}
++=======
+ 	if (!explicit)
+ 		flush_work(&tg_pt_gp->tg_pt_gp_transition_work);
++>>>>>>> 760bf578edf8 (target: fix race during implicit transition work flushes)
  
  	/*
  	 * Save the old primary ALUA access state, and set the current state
* Unmerged path drivers/target/target_core_alua.c
