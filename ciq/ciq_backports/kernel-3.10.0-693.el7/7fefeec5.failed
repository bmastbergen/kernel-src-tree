HID: wacom: rename failN with some meaningful information

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: rename failN with some meaningful information (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.41%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 7fefeec5176861c2747b8dcd9656acf42c288ded
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7fefeec5.failed

When we have to deal with new elements in probe, having the exit labels
named sequencially is a pain to maintain. Put a meaningful name instead
so that we do not have to renumber them on inserts.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Jason Gerecke <killertofu@gmail.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 7fefeec5176861c2747b8dcd9656acf42c288ded)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,97e1feffc6e4..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1127,42 -995,134 +1127,82 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 -
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 -
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 +static int wacom_register_input(struct wacom *wacom)
  {
  	struct input_dev *input_dev;
 -	struct hid_device *hdev = wacom->hdev;
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 +	int error;
  
  	input_dev = input_allocate_device();
 -	if (!input_dev)
 -		return NULL;
 +	if (!input_dev) {
 +		error = -ENOMEM;
- 		goto fail1;
++		goto fail_allocate_input;
 +	}
  
  	input_dev->name = wacom_wac->name;
 -	input_dev->phys = hdev->phys;
 -	input_dev->dev.parent = &hdev->dev;
 +	input_dev->dev.parent = &intf->dev;
  	input_dev->open = wacom_open;
  	input_dev->close = wacom_close;
 -	input_dev->uniq = hdev->uniq;
 -	input_dev->id.bustype = hdev->bus;
 -	input_dev->id.vendor  = hdev->vendor;
 -	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
 -	input_dev->id.version = hdev->version;
 +	usb_to_input_id(dev, &input_dev->id);
  	input_set_drvdata(input_dev, wacom);
  
 -	return input_dev;
 -}
 -
 -static void wacom_unregister_inputs(struct wacom *wacom)
 -{
 -	if (wacom->wacom_wac.input)
 -		input_unregister_device(wacom->wacom_wac.input);
 -	if (wacom->wacom_wac.pad_input)
 -		input_unregister_device(wacom->wacom_wac.pad_input);
 -	wacom->wacom_wac.input = NULL;
 -	wacom->wacom_wac.pad_input = NULL;
 -	wacom_destroy_leds(wacom);
 -}
 -
 -static int wacom_register_inputs(struct wacom *wacom)
 -{
 -	struct input_dev *input_dev, *pad_input_dev;
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -	int error;
 -
 -	input_dev = wacom_allocate_input(wacom);
 -	pad_input_dev = wacom_allocate_input(wacom);
 -	if (!input_dev || !pad_input_dev) {
 -		error = -ENOMEM;
 -		goto fail_allocate_input;
 -	}
 -
  	wacom_wac->input = input_dev;
 -	wacom_wac->pad_input = pad_input_dev;
 -	wacom_wac->pad_input->name = wacom_wac->pad_name;
 -
  	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
  	if (error)
++<<<<<<< HEAD
 +		goto fail1;
++=======
+ 		goto fail_input_cap;
++>>>>>>> 7fefeec51768 (HID: wacom: rename failN with some meaningful information)
  
  	error = input_register_device(input_dev);
  	if (error)
- 		goto fail2;
+ 		goto fail_register_input;
  
++<<<<<<< HEAD
 +	return 0;
 +
 +fail2:
 +	input_free_device(input_dev);
 +	wacom_wac->input = NULL;
 +fail1:
++=======
+ 	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pad in use on this interface */
+ 		input_free_device(pad_input_dev);
+ 		wacom_wac->pad_input = NULL;
+ 		pad_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pad_input_dev);
+ 		if (error)
+ 			goto fail_register_pad_input;
+ 
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail_leds;
+ 	}
+ 
+ 	return 0;
+ 
+ fail_leds:
+ 	input_unregister_device(pad_input_dev);
+ 	pad_input_dev = NULL;
+ fail_register_pad_input:
+ 	input_unregister_device(input_dev);
+ 	input_dev = NULL;
+ fail_register_input:
+ fail_input_cap:
+ 	wacom_wac->input = NULL;
+ 	wacom_wac->pad_input = NULL;
+ fail_allocate_input:
+ 	if (input_dev)
+ 		input_free_device(input_dev);
+ 	if (pad_input_dev)
+ 		input_free_device(pad_input_dev);
++>>>>>>> 7fefeec51768 (HID: wacom: rename failN with some meaningful information)
  	return error;
  }
  
@@@ -1309,25 -1299,28 +1349,44 @@@ static int wacom_probe(struct usb_inter
  	if (!wacom)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	hid_set_drvdata(hdev, wacom);
+ 	wacom->hdev = hdev;
+ 
+ 	/* ask for the report descriptor to be loaded by HID */
+ 	error = hid_parse(hdev);
+ 	if (error) {
+ 		hid_err(hdev, "parse failed\n");
+ 		goto fail_parse;
+ 	}
+ 
++>>>>>>> 7fefeec51768 (HID: wacom: rename failN with some meaningful information)
  	wacom_wac = &wacom->wacom_wac;
 -	wacom_wac->features = *((struct wacom_features *)id->driver_data);
 +	wacom_wac->features = *((struct wacom_features *)id->driver_info);
  	features = &wacom_wac->features;
 -	features->pktlen = wacom_compute_pktlen(hdev);
  	if (features->pktlen > WACOM_PKGLEN_MAX) {
  		error = -EINVAL;
- 		goto fail1;
+ 		goto fail_pktlen;
  	}
  
++<<<<<<< HEAD
 +	wacom_wac->data = usb_alloc_coherent(dev, WACOM_PKGLEN_MAX,
 +					     GFP_KERNEL, &wacom->data_dma);
 +	if (!wacom_wac->data) {
 +		error = -ENOMEM;
 +		goto fail1;
++=======
+ 	if (features->check_for_hid_type && features->hid_type != hdev->type) {
+ 		error = -ENODEV;
+ 		goto fail_type;
++>>>>>>> 7fefeec51768 (HID: wacom: rename failN with some meaningful information)
 +	}
 +
 +	wacom->irq = usb_alloc_urb(0, GFP_KERNEL);
 +	if (!wacom->irq) {
 +		error = -ENOMEM;
 +		goto fail2;
  	}
  
  	wacom->usbdev = dev;
@@@ -1386,50 -1387,67 +1445,94 @@@
  		else
  			strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
  
++<<<<<<< HEAD
 +		other_dev = wacom_get_sibling(dev, features->oVid, features->oPid);
 +		if (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)
 +			other_dev = dev;
 +		error = wacom_add_shared_data(wacom_wac, other_dev);
++=======
+ 		error = wacom_add_shared_data(hdev);
+ 		if (error)
+ 			goto fail_shared_data;
+ 	}
+ 
+ 	if (!(features->quirks & WACOM_QUIRK_MONITOR) &&
+ 	     (features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail_battery;
+ 	}
+ 
+ 	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
+ 		error = wacom_register_inputs(wacom);
++>>>>>>> 7fefeec51768 (HID: wacom: rename failN with some meaningful information)
  		if (error)
- 			goto fail3;
+ 			goto fail_register_inputs;
  	}
  
 -	if (hdev->bus == BUS_BLUETOOTH) {
 -		error = device_create_file(&hdev->dev, &dev_attr_speed);
 +	usb_fill_int_urb(wacom->irq, dev,
 +			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
 +			 wacom_wac->data, features->pktlen,
 +			 wacom_sys_irq, wacom, endpoint->bInterval);
 +	wacom->irq->transfer_dma = wacom->data_dma;
 +	wacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 +
 +	error = wacom_initialize_leds(wacom);
 +	if (error)
 +		goto fail4;
 +
 +	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 +		error = wacom_register_input(wacom);
  		if (error)
 -			hid_warn(hdev,
 -				 "can't create sysfs speed attribute err: %d\n",
 -				 error);
 +			goto fail5;
  	}
  
  	/* Note that if query fails it is not a hard failure */
 -	wacom_query_tablet_data(hdev, features);
 +	wacom_query_tablet_data(intf, features);
  
++<<<<<<< HEAD
 +	usb_set_intfdata(intf, wacom);
++=======
+ 	/* Regular HID work starts now */
+ 	error = hid_hw_start(hdev, HID_CONNECT_HIDRAW);
+ 	if (error) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto fail_hw_start;
+ 	}
++>>>>>>> 7fefeec51768 (HID: wacom: rename failN with some meaningful information)
  
 -	if (features->quirks & WACOM_QUIRK_MONITOR)
 -		error = hid_hw_open(hdev);
 -
 -	if (wacom_wac->features.type == INTUOSHT && wacom_wac->features.touch_max) {
 -		if (wacom_wac->features.device_type == BTN_TOOL_FINGER)
 -			wacom_wac->shared->touch_input = wacom_wac->input;
 +	if (features->quirks & WACOM_QUIRK_MONITOR) {
 +		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) {
 +			error = -EIO;
 +			goto fail5;
 +		}
  	}
  
  	return 0;
  
++<<<<<<< HEAD
 + fail5: wacom_destroy_leds(wacom);
 + fail4:	wacom_remove_shared_data(wacom_wac);
 + fail3:	usb_free_urb(wacom->irq);
 + fail2:	usb_free_coherent(dev, WACOM_PKGLEN_MAX, wacom_wac->data, wacom->data_dma);
 + fail1:	kfree(wacom);
++=======
+ fail_hw_start:
+ 	wacom_unregister_inputs(wacom);
+ 	if (hdev->bus == BUS_BLUETOOTH)
+ 		device_remove_file(&hdev->dev, &dev_attr_speed);
+ fail_register_inputs:
+ 	wacom_unregister_inputs(wacom);
+ 	wacom_destroy_battery(wacom);
+ fail_battery:
+ 	wacom_remove_shared_data(wacom_wac);
+ fail_shared_data:
+ fail_type:
+ fail_pktlen:
+ fail_parse:
+ 	kfree(wacom);
+ 	hid_set_drvdata(hdev, NULL);
++>>>>>>> 7fefeec51768 (HID: wacom: rename failN with some meaningful information)
  	return error;
  }
  
* Unmerged path drivers/hid/wacom_sys.c
