selinux: simply inode label states to INVALID and INITIALIZED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Paul Moore <paul@paul-moore.com>
commit 4b57d6bcd94034e2eb168bdec2474e3b2b848e44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4b57d6bc.failed

There really is no need for LABEL_MISSING as we really only care if
the inode's label is INVALID or INITIALIZED.  Also adjust the
revalidate code to reload the label whenever the label is not
INITIALIZED so we are less sensitive to label state in the future.

	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 4b57d6bcd94034e2eb168bdec2474e3b2b848e44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
#	security/selinux/include/objsec.h
diff --cc security/selinux/hooks.c
index 85f0076df17e,dd1fbea37b78..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -231,6 -242,72 +231,75 @@@ static int inode_alloc_security(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry);
+ 
+ /*
+  * Try reloading inode security labels that have been marked as invalid.  The
+  * @may_sleep parameter indicates when sleeping and thus reloading labels is
+  * allowed; when set to false, returns ERR_PTR(-ECHILD) when the label is
+  * invalid.  The @opt_dentry parameter should be set to a dentry of the inode;
+  * when no dentry is available, set it to NULL instead.
+  */
+ static int __inode_security_revalidate(struct inode *inode,
+ 				       struct dentry *opt_dentry,
+ 				       bool may_sleep)
+ {
+ 	struct inode_security_struct *isec = inode->i_security;
+ 
+ 	might_sleep_if(may_sleep);
+ 
+ 	if (isec->initialized != LABEL_INITIALIZED) {
+ 		if (!may_sleep)
+ 			return -ECHILD;
+ 
+ 		/*
+ 		 * Try reloading the inode security label.  This will fail if
+ 		 * @opt_dentry is NULL and no dentry for this inode can be
+ 		 * found; in that case, continue using the old label.
+ 		 */
+ 		inode_doinit_with_dentry(inode, opt_dentry);
+ 	}
+ 	return 0;
+ }
+ 
+ static struct inode_security_struct *inode_security_novalidate(struct inode *inode)
+ {
+ 	return inode->i_security;
+ }
+ 
+ static struct inode_security_struct *inode_security_rcu(struct inode *inode, bool rcu)
+ {
+ 	int error;
+ 
+ 	error = __inode_security_revalidate(inode, NULL, !rcu);
+ 	if (error)
+ 		return ERR_PTR(error);
+ 	return inode->i_security;
+ }
+ 
+ /*
+  * Get the security label of an inode.
+  */
+ static struct inode_security_struct *inode_security(struct inode *inode)
+ {
+ 	__inode_security_revalidate(inode, NULL, true);
+ 	return inode->i_security;
+ }
+ 
+ /*
+  * Get the security label of a dentry's backing inode.
+  */
+ static struct inode_security_struct *backing_inode_security(struct dentry *dentry)
+ {
+ 	struct inode *inode = d_backing_inode(dentry);
+ 
+ 	__inode_security_revalidate(inode, dentry, true);
+ 	return inode->i_security;
+ }
+ 
++>>>>>>> 4b57d6bcd940 (selinux: simply inode label states to INVALID and INITIALIZED)
  static void inode_free_rcu(struct rcu_head *head)
  {
  	struct inode_security_struct *isec;
diff --cc security/selinux/include/objsec.h
index 2a3be7adc071,c21e135460a5..000000000000
--- a/security/selinux/include/objsec.h
+++ b/security/selinux/include/objsec.h
@@@ -37,6 -37,11 +37,14 @@@ struct task_security_struct 
  	u32 sockcreate_sid;	/* fscreate SID */
  };
  
++<<<<<<< HEAD
++=======
+ enum label_initialized {
+ 	LABEL_INVALID,		/* invalid or not initialized */
+ 	LABEL_INITIALIZED	/* initialized */
+ };
+ 
++>>>>>>> 4b57d6bcd940 (selinux: simply inode label states to INVALID and INITIALIZED)
  struct inode_security_struct {
  	struct inode *inode;	/* back pointer to inode object */
  	union {
* Unmerged path security/selinux/hooks.c
* Unmerged path security/selinux/include/objsec.h
