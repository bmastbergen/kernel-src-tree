bonding: improve link-status update in mii-monitoring

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mahesh Bandewar <maheshb@google.com>
commit de77ecd4ef02ca783f7762e04e92b3d0964be66b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/de77ecd4.failed

The primary issue is that mii-inspect phase updates link-state and
expects changes to be committed during the mii-commit phase. After
the inspect phase if it fails to acquire rtnl-mutex, the commit
phase (bond_mii_commit) doesn't get to run. This partially updated
state stays and makes the internal-state inconsistent.

e.g. setup bond0 => slaves: eth1, eth2
eth1 goes DOWN -> UP
   mii_monitor()
	mii-inspect()
	    bond_set_slave_link_state(eth1, UP, DontNotify)
	rtnl_trylock() <- fails!

Next mii-monitor round
eth1: No change
   mii_monitor()
	mii-inspect()
	    eth1->link == current-status (ethtool_ops->get_link)
	    no-change-detected

End result:
    eth1:
      Link = BOND_LINK_UP
      Speed = 0xfffff  [SpeedUnknown]
      Duplex = 0xff    [DuplexUnknown]

This doesn't always happen but for some unlucky machines in a large set
of machines it creates problems.

The fix for this is to avoid making changes during inspect phase and
postpone them until acquiring the rtnl-mutex / invoking commit phase.

	Signed-off-by: Mahesh Bandewar <maheshb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit de77ecd4ef02ca783f7762e04e92b3d0964be66b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 58b4e35aeaa3,85999e479916..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -2003,7 -2033,7 +2003,11 @@@ static int bond_miimon_inspect(struct b
  			if (link_state)
  				continue;
  
++<<<<<<< HEAD
 +			bond_set_slave_link_state(slave, BOND_LINK_FAIL);
++=======
+ 			bond_propose_link_state(slave, BOND_LINK_FAIL);
++>>>>>>> de77ecd4ef02 (bonding: improve link-status update in mii-monitoring)
  			slave->delay = bond->params.downdelay;
  			if (slave->delay) {
  				netdev_info(bond->dev, "link status down for %sinterface %s, disabling it in %d ms\n",
@@@ -2018,7 -2048,7 +2022,11 @@@
  		case BOND_LINK_FAIL:
  			if (link_state) {
  				/* recovered before downdelay expired */
++<<<<<<< HEAD
 +				bond_set_slave_link_state(slave, BOND_LINK_UP);
++=======
+ 				bond_propose_link_state(slave, BOND_LINK_UP);
++>>>>>>> de77ecd4ef02 (bonding: improve link-status update in mii-monitoring)
  				slave->last_link_up = jiffies;
  				netdev_info(bond->dev, "link status up again after %d ms for interface %s\n",
  					    (bond->params.downdelay - slave->delay) *
@@@ -2040,7 -2070,7 +2048,11 @@@
  			if (!link_state)
  				continue;
  
++<<<<<<< HEAD
 +			bond_set_slave_link_state(slave, BOND_LINK_BACK);
++=======
+ 			bond_propose_link_state(slave, BOND_LINK_BACK);
++>>>>>>> de77ecd4ef02 (bonding: improve link-status update in mii-monitoring)
  			slave->delay = bond->params.updelay;
  
  			if (slave->delay) {
@@@ -2053,8 -2083,7 +2065,12 @@@
  			/*FALLTHRU*/
  		case BOND_LINK_BACK:
  			if (!link_state) {
++<<<<<<< HEAD
 +				bond_set_slave_link_state(slave,
 +							  BOND_LINK_DOWN);
++=======
+ 				bond_propose_link_state(slave, BOND_LINK_DOWN);
++>>>>>>> de77ecd4ef02 (bonding: improve link-status update in mii-monitoring)
  				netdev_info(bond->dev, "link status down again after %d ms for interface %s\n",
  					    (bond->params.updelay - slave->delay) *
  					    bond->params.miimon,
* Unmerged path drivers/net/bonding/bond_main.c
