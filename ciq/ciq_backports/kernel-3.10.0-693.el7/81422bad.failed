crypto: ccp - Make syslog errors human-readable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] ccp - Make syslog errors human-readable (Suravee Suthikulpanit) [1390820]
Rebuild_FUZZ: 90.70%
commit-author Gary R Hook <gary.hook@amd.com>
commit 81422badb39078fde1ffcecda3caac555226fc7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/81422bad.failed

Add human-readable strings to log messages about CCP errors

	Signed-off-by: Gary R Hook <gary.hook@amd.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 81422badb39078fde1ffcecda3caac555226fc7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/ccp/ccp-dev-v3.c
#	drivers/crypto/ccp/ccp-dev-v5.c
#	drivers/crypto/ccp/ccp-dev.c
#	drivers/crypto/ccp/ccp-dev.h
diff --cc drivers/crypto/ccp/ccp-dev.c
index 2777dc97b570,cafa633aae10..000000000000
--- a/drivers/crypto/ccp/ccp-dev.c
+++ b/drivers/crypto/ccp/ccp-dev.c
@@@ -35,23 -40,226 +35,91 @@@ struct ccp_tasklet_data 
  	struct ccp_cmd *cmd;
  };
  
++<<<<<<< HEAD
++=======
+ /* Human-readable error strings */
+ char *ccp_error_codes[] = {
+ 	"",
+ 	"ERR 01: ILLEGAL_ENGINE",
+ 	"ERR 02: ILLEGAL_KEY_ID",
+ 	"ERR 03: ILLEGAL_FUNCTION_TYPE",
+ 	"ERR 04: ILLEGAL_FUNCTION_MODE",
+ 	"ERR 05: ILLEGAL_FUNCTION_ENCRYPT",
+ 	"ERR 06: ILLEGAL_FUNCTION_SIZE",
+ 	"ERR 07: Zlib_MISSING_INIT_EOM",
+ 	"ERR 08: ILLEGAL_FUNCTION_RSVD",
+ 	"ERR 09: ILLEGAL_BUFFER_LENGTH",
+ 	"ERR 10: VLSB_FAULT",
+ 	"ERR 11: ILLEGAL_MEM_ADDR",
+ 	"ERR 12: ILLEGAL_MEM_SEL",
+ 	"ERR 13: ILLEGAL_CONTEXT_ID",
+ 	"ERR 14: ILLEGAL_KEY_ADDR",
+ 	"ERR 15: 0xF Reserved",
+ 	"ERR 16: Zlib_ILLEGAL_MULTI_QUEUE",
+ 	"ERR 17: Zlib_ILLEGAL_JOBID_CHANGE",
+ 	"ERR 18: CMD_TIMEOUT",
+ 	"ERR 19: IDMA0_AXI_SLVERR",
+ 	"ERR 20: IDMA0_AXI_DECERR",
+ 	"ERR 21: 0x15 Reserved",
+ 	"ERR 22: IDMA1_AXI_SLAVE_FAULT",
+ 	"ERR 23: IDMA1_AIXI_DECERR",
+ 	"ERR 24: 0x18 Reserved",
+ 	"ERR 25: ZLIBVHB_AXI_SLVERR",
+ 	"ERR 26: ZLIBVHB_AXI_DECERR",
+ 	"ERR 27: 0x1B Reserved",
+ 	"ERR 27: ZLIB_UNEXPECTED_EOM",
+ 	"ERR 27: ZLIB_EXTRA_DATA",
+ 	"ERR 30: ZLIB_BTYPE",
+ 	"ERR 31: ZLIB_UNDEFINED_SYMBOL",
+ 	"ERR 32: ZLIB_UNDEFINED_DISTANCE_S",
+ 	"ERR 33: ZLIB_CODE_LENGTH_SYMBOL",
+ 	"ERR 34: ZLIB _VHB_ILLEGAL_FETCH",
+ 	"ERR 35: ZLIB_UNCOMPRESSED_LEN",
+ 	"ERR 36: ZLIB_LIMIT_REACHED",
+ 	"ERR 37: ZLIB_CHECKSUM_MISMATCH0",
+ 	"ERR 38: ODMA0_AXI_SLVERR",
+ 	"ERR 39: ODMA0_AXI_DECERR",
+ 	"ERR 40: 0x28 Reserved",
+ 	"ERR 41: ODMA1_AXI_SLVERR",
+ 	"ERR 42: ODMA1_AXI_DECERR",
+ 	"ERR 43: LSB_PARITY_ERR",
+ };
+ 
+ void ccp_log_error(struct ccp_device *d, int e)
+ {
+ 	dev_err(d->dev, "CCP error: %s (0x%x)\n", ccp_error_codes[e], e);
+ }
+ 
+ /* List of CCPs, CCP count, read-write access lock, and access functions
+  *
+  * Lock structure: get ccp_unit_lock for reading whenever we need to
+  * examine the CCP list. While holding it for reading we can acquire
+  * the RR lock to update the round-robin next-CCP pointer. The unit lock
+  * must be acquired before the RR lock.
+  *
+  * If the unit-lock is acquired for writing, we have total control over
+  * the list, so there's no value in getting the RR lock.
+  */
+ static DEFINE_RWLOCK(ccp_unit_lock);
+ static LIST_HEAD(ccp_units);
++>>>>>>> 81422badb390 (crypto: ccp - Make syslog errors human-readable)
  
 -/* Round-robin counter */
 -static DEFINE_SPINLOCK(ccp_rr_lock);
 -static struct ccp_device *ccp_rr;
 -
 -/* Ever-increasing value to produce unique unit numbers */
 -static atomic_t ccp_unit_ordinal;
 -static unsigned int ccp_increment_unit_ordinal(void)
 -{
 -	return atomic_inc_return(&ccp_unit_ordinal);
 -}
 -
 -/**
 - * ccp_add_device - add a CCP device to the list
 - *
 - * @ccp: ccp_device struct pointer
 - *
 - * Put this CCP on the unit list, which makes it available
 - * for use.
 - *
 - * Returns zero if a CCP device is present, -ENODEV otherwise.
 - */
 -void ccp_add_device(struct ccp_device *ccp)
 -{
 -	unsigned long flags;
 -
 -	write_lock_irqsave(&ccp_unit_lock, flags);
 -	list_add_tail(&ccp->entry, &ccp_units);
 -	if (!ccp_rr)
 -		/* We already have the list lock (we're first) so this
 -		 * pointer can't change on us. Set its initial value.
 -		 */
 -		ccp_rr = ccp;
 -	write_unlock_irqrestore(&ccp_unit_lock, flags);
 -}
 -
 -/**
 - * ccp_del_device - remove a CCP device from the list
 - *
 - * @ccp: ccp_device struct pointer
 - *
 - * Remove this unit from the list of devices. If the next device
 - * up for use is this one, adjust the pointer. If this is the last
 - * device, NULL the pointer.
 - */
 -void ccp_del_device(struct ccp_device *ccp)
 -{
 -	unsigned long flags;
 -
 -	write_lock_irqsave(&ccp_unit_lock, flags);
 -	if (ccp_rr == ccp) {
 -		/* ccp_unit_lock is read/write; any read access
 -		 * will be suspended while we make changes to the
 -		 * list and RR pointer.
 -		 */
 -		if (list_is_last(&ccp_rr->entry, &ccp_units))
 -			ccp_rr = list_first_entry(&ccp_units, struct ccp_device,
 -						  entry);
 -		else
 -			ccp_rr = list_next_entry(ccp_rr, entry);
 -	}
 -	list_del(&ccp->entry);
 -	if (list_empty(&ccp_units))
 -		ccp_rr = NULL;
 -	write_unlock_irqrestore(&ccp_unit_lock, flags);
 -}
 -
 -
 -
 -int ccp_register_rng(struct ccp_device *ccp)
 +static struct ccp_device *ccp_dev;
 +static inline struct ccp_device *ccp_get_device(void)
  {
 -	int ret = 0;
 -
 -	dev_dbg(ccp->dev, "Registering RNG...\n");
 -	/* Register an RNG */
 -	ccp->hwrng.name = ccp->rngname;
 -	ccp->hwrng.read = ccp_trng_read;
 -	ret = hwrng_register(&ccp->hwrng);
 -	if (ret)
 -		dev_err(ccp->dev, "error registering hwrng (%d)\n", ret);
 -
 -	return ret;
 +	return ccp_dev;
  }
  
 -void ccp_unregister_rng(struct ccp_device *ccp)
 +static inline void ccp_add_device(struct ccp_device *ccp)
  {
 -	if (ccp->hwrng.name)
 -		hwrng_unregister(&ccp->hwrng);
 +	ccp_dev = ccp;
  }
  
 -static struct ccp_device *ccp_get_device(void)
 +static inline void ccp_del_device(struct ccp_device *ccp)
  {
 -	unsigned long flags;
 -	struct ccp_device *dp = NULL;
 -
 -	/* We round-robin through the unit list.
 -	 * The (ccp_rr) pointer refers to the next unit to use.
 -	 */
 -	read_lock_irqsave(&ccp_unit_lock, flags);
 -	if (!list_empty(&ccp_units)) {
 -		spin_lock(&ccp_rr_lock);
 -		dp = ccp_rr;
 -		if (list_is_last(&ccp_rr->entry, &ccp_units))
 -			ccp_rr = list_first_entry(&ccp_units, struct ccp_device,
 -						  entry);
 -		else
 -			ccp_rr = list_next_entry(ccp_rr, entry);
 -		spin_unlock(&ccp_rr_lock);
 -	}
 -	read_unlock_irqrestore(&ccp_unit_lock, flags);
 -
 -	return dp;
 +	ccp_dev = NULL;
  }
  
 -/**
 - * ccp_present - check if a CCP device is present
 - *
 - * Returns zero if a CCP device is present, -ENODEV otherwise.
 - */
 -int ccp_present(void)
 -{
 -	unsigned long flags;
 -	int ret;
 -
 -	read_lock_irqsave(&ccp_unit_lock, flags);
 -	ret = list_empty(&ccp_units);
 -	read_unlock_irqrestore(&ccp_unit_lock, flags);
 -
 -	return ret ? -ENODEV : 0;
 -}
 -EXPORT_SYMBOL_GPL(ccp_present);
 -
 -/**
 - * ccp_version - get the version of the CCP device
 - *
 - * Returns the version from the first unit on the list;
 - * otherwise a zero if no CCP device is present
 - */
 -unsigned int ccp_version(void)
 -{
 -	struct ccp_device *dp;
 -	unsigned long flags;
 -	int ret = 0;
 -
 -	read_lock_irqsave(&ccp_unit_lock, flags);
 -	if (!list_empty(&ccp_units)) {
 -		dp = list_first_entry(&ccp_units, struct ccp_device, entry);
 -		ret = dp->vdata->version;
 -	}
 -	read_unlock_irqrestore(&ccp_unit_lock, flags);
 -
 -	return ret;
 -}
 -EXPORT_SYMBOL_GPL(ccp_version);
 -
  /**
   * ccp_enqueue_cmd - queue an operation for processing by the CCP
   *
diff --cc drivers/crypto/ccp/ccp-dev.h
index 72bf1536b653,da5f4a678083..000000000000
--- a/drivers/crypto/ccp/ccp-dev.h
+++ b/drivers/crypto/ccp/ccp-dev.h
@@@ -259,13 -595,54 +259,24 @@@ struct ccp_device 
  int ccp_pci_init(void);
  void ccp_pci_exit(void);
  
++<<<<<<< HEAD
++=======
+ int ccp_platform_init(void);
+ void ccp_platform_exit(void);
+ 
+ void ccp_add_device(struct ccp_device *ccp);
+ void ccp_del_device(struct ccp_device *ccp);
+ 
+ extern void ccp_log_error(struct ccp_device *, int);
+ 
++>>>>>>> 81422badb390 (crypto: ccp - Make syslog errors human-readable)
  struct ccp_device *ccp_alloc_struct(struct device *dev);
 +int ccp_init(struct ccp_device *ccp);
 +void ccp_destroy(struct ccp_device *ccp);
  bool ccp_queues_suspended(struct ccp_device *ccp);
 -int ccp_cmd_queue_thread(void *data);
 -int ccp_trng_read(struct hwrng *rng, void *data, size_t max, bool wait);
 -
 -int ccp_run_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd);
  
 -int ccp_register_rng(struct ccp_device *ccp);
 -void ccp_unregister_rng(struct ccp_device *ccp);
 -int ccp_dmaengine_register(struct ccp_device *ccp);
 -void ccp_dmaengine_unregister(struct ccp_device *ccp);
 -
 -/* Structure for computation functions that are device-specific */
 -struct ccp_actions {
 -	int (*aes)(struct ccp_op *);
 -	int (*xts_aes)(struct ccp_op *);
 -	int (*sha)(struct ccp_op *);
 -	int (*rsa)(struct ccp_op *);
 -	int (*passthru)(struct ccp_op *);
 -	int (*ecc)(struct ccp_op *);
 -	u32 (*sballoc)(struct ccp_cmd_queue *, unsigned int);
 -	void (*sbfree)(struct ccp_cmd_queue *, unsigned int,
 -			       unsigned int);
 -	unsigned int (*get_free_slots)(struct ccp_cmd_queue *);
 -	int (*init)(struct ccp_device *);
 -	void (*destroy)(struct ccp_device *);
 -	irqreturn_t (*irqhandler)(int, void *);
 -};
 +irqreturn_t ccp_irq_handler(int irq, void *data);
  
 -/* Structure to hold CCP version-specific values */
 -struct ccp_vdata {
 -	const unsigned int version;
 -	void (*setup)(struct ccp_device *);
 -	const struct ccp_actions *perform;
 -	const unsigned int bar;
 -	const unsigned int offset;
 -};
 -
 -extern const struct ccp_vdata ccpv3;
 -extern const struct ccp_vdata ccpv5a;
 -extern const struct ccp_vdata ccpv5b;
 +int ccp_run_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd);
  
  #endif
* Unmerged path drivers/crypto/ccp/ccp-dev-v3.c
* Unmerged path drivers/crypto/ccp/ccp-dev-v5.c
* Unmerged path drivers/crypto/ccp/ccp-dev-v3.c
* Unmerged path drivers/crypto/ccp/ccp-dev-v5.c
* Unmerged path drivers/crypto/ccp/ccp-dev.c
* Unmerged path drivers/crypto/ccp/ccp-dev.h
