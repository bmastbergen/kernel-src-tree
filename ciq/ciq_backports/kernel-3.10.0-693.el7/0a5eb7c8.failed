vfs: Keep a list of mounts on a mount point

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederman@twitter.com>
commit 0a5eb7c8189922e86a840972cd0b57e41de6f031
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0a5eb7c8.failed

To spot any possible problems call BUG if a mountpoint
is put when it's list of mounts is not empty.

AV: use hlist instead of list_head

	Reviewed-by: Miklos Szeredi <miklos@szeredi.hu>
	Signed-off-by: Eric W. Biederman <ebiederman@twitter.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 0a5eb7c8189922e86a840972cd0b57e41de6f031)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index eeea79ae4dd3,99572dd08336..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -672,7 -731,8 +673,12 @@@ static struct mountpoint *new_mountpoin
  
  	mp->m_dentry = dentry;
  	mp->m_count = 1;
++<<<<<<< HEAD
 +	list_add(&mp->m_hash, chain);
++=======
+ 	hlist_add_head(&mp->m_hash, chain);
+ 	INIT_HLIST_HEAD(&mp->m_list);
++>>>>>>> 0a5eb7c81899 (vfs: Keep a list of mounts on a mount point)
  	return mp;
  }
  
@@@ -725,7 -786,8 +732,12 @@@ static void detach_mnt(struct mount *mn
  	mnt->mnt_parent = mnt;
  	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
  	list_del_init(&mnt->mnt_child);
++<<<<<<< HEAD
 +	list_del_init(&mnt->mnt_hash);
++=======
+ 	hlist_del_init_rcu(&mnt->mnt_hash);
+ 	hlist_del_init(&mnt->mnt_mp_list);
++>>>>>>> 0a5eb7c81899 (vfs: Keep a list of mounts on a mount point)
  	put_mountpoint(mnt->mnt_mp);
  	mnt->mnt_mp = NULL;
  }
@@@ -1221,9 -1344,12 +1234,10 @@@ void umount_tree(struct mount *mnt, in
  		list_del_init(&p->mnt_list);
  		__touch_mnt_namespace(p->mnt_ns);
  		p->mnt_ns = NULL;
 -		if (how < 2)
 -			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
 +		list_del_init(&p->mnt_child);
  		if (mnt_has_parent(p)) {
+ 			hlist_del_init(&p->mnt_mp_list);
  			put_mountpoint(p->mnt_mp);
 -			mnt_add_count(p->mnt_parent, -1);
  			/* move the reference to mountpoint into ->mnt_ex_mountpoint */
  			p->mnt_ex_mountpoint.dentry = p->mnt_mountpoint;
  			p->mnt_ex_mountpoint.mnt = &p->mnt_parent->mnt;
diff --git a/fs/mount.h b/fs/mount.h
index e343bfffd887..ffb4c6e4a3a1 100644
--- a/fs/mount.h
+++ b/fs/mount.h
@@ -21,6 +21,7 @@ struct mnt_pcp {
 struct mountpoint {
 	struct list_head m_hash;
 	struct dentry *m_dentry;
+	struct hlist_head m_list;
 	int m_count;
 };
 
@@ -47,6 +48,7 @@ struct mount {
 	struct mount *mnt_master;	/* slave is on master->mnt_slave_list */
 	struct mnt_namespace *mnt_ns;	/* containing namespace */
 	struct mountpoint *mnt_mp;	/* where is it mounted */
+	struct hlist_node mnt_mp_list;	/* list mounts with the same mountpoint */
 #ifdef CONFIG_FSNOTIFY
 	struct hlist_head mnt_fsnotify_marks;
 	__u32 mnt_fsnotify_mask;
* Unmerged path fs/namespace.c
