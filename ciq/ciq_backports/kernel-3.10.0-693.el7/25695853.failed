qede: Prevent GSO on long Geneve headers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Manish Chopra <manish.chopra@caviumnetworks.com>
commit 256958538ae2616e4aa14efab8c0d11df1e188db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/25695853.failed

Due to hardware limitation, when transmitting a geneve-encapsulated
packet with more than 32 bytes worth of geneve options the hardware
would not be able to crack the packet and consider it a regular UDP
packet.

This implements the ndo_features_check() in qede in order to prevent
GSO on said transmitted packets.

	Signed-off-by: Manish Chopra <manish.chopra@caviumnetworks.com>
	Signed-off-by: Yuval Mintz <Yuval.Mintz@caviumnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 256958538ae2616e4aa14efab8c0d11df1e188db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qede/qede_main.c
diff --cc drivers/net/ethernet/qlogic/qede/qede_main.c
index f6cf39613aa4,6c2b09c255d5..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_main.c
@@@ -2164,76 -2170,110 +2164,110 @@@ static int qede_set_features(struct net
  	return 0;
  }
  
 -static void qede_udp_tunnel_add(struct net_device *dev,
 -				struct udp_tunnel_info *ti)
 +#ifdef CONFIG_QEDE_VXLAN
 +static void qede_add_vxlan_port(struct net_device *dev,
 +				sa_family_t sa_family, __be16 port)
  {
  	struct qede_dev *edev = netdev_priv(dev);
 -	u16 t_port = ntohs(ti->port);
 +	u16 t_port = ntohs(port);
  
 -	switch (ti->type) {
 -	case UDP_TUNNEL_TYPE_VXLAN:
 -		if (edev->vxlan_dst_port)
 -			return;
 +	if (edev->vxlan_dst_port)
 +		return;
  
 -		edev->vxlan_dst_port = t_port;
 +	edev->vxlan_dst_port = t_port;
  
 -		DP_VERBOSE(edev, QED_MSG_DEBUG, "Added vxlan port=%d\n",
 -			   t_port);
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Added vxlan port=%d", t_port);
  
 -		set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
 -		break;
 -	case UDP_TUNNEL_TYPE_GENEVE:
 -		if (edev->geneve_dst_port)
 -			return;
 +	set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
 +	schedule_delayed_work(&edev->sp_task, 0);
 +}
  
 -		edev->geneve_dst_port = t_port;
 +static void qede_del_vxlan_port(struct net_device *dev,
 +				sa_family_t sa_family, __be16 port)
 +{
 +	struct qede_dev *edev = netdev_priv(dev);
 +	u16 t_port = ntohs(port);
  
 -		DP_VERBOSE(edev, QED_MSG_DEBUG, "Added geneve port=%d\n",
 -			   t_port);
 -		set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
 -		break;
 -	default:
 +	if (t_port != edev->vxlan_dst_port)
  		return;
 -	}
  
 +	edev->vxlan_dst_port = 0;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted vxlan port=%d", t_port);
 +
 +	set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
  	schedule_delayed_work(&edev->sp_task, 0);
  }
 +#endif
  
 -static void qede_udp_tunnel_del(struct net_device *dev,
 -				struct udp_tunnel_info *ti)
 +#ifdef CONFIG_QEDE_GENEVE
 +static void qede_add_geneve_port(struct net_device *dev,
 +				 sa_family_t sa_family, __be16 port)
  {
  	struct qede_dev *edev = netdev_priv(dev);
 -	u16 t_port = ntohs(ti->port);
 -
 -	switch (ti->type) {
 -	case UDP_TUNNEL_TYPE_VXLAN:
 -		if (t_port != edev->vxlan_dst_port)
 -			return;
 +	u16 t_port = ntohs(port);
  
 -		edev->vxlan_dst_port = 0;
 +	if (edev->geneve_dst_port)
 +		return;
  
 -		DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted vxlan port=%d\n",
 -			   t_port);
 +	edev->geneve_dst_port = t_port;
  
 -		set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
 -		break;
 -	case UDP_TUNNEL_TYPE_GENEVE:
 -		if (t_port != edev->geneve_dst_port)
 -			return;
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Added geneve port=%d", t_port);
 +	set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
 +	schedule_delayed_work(&edev->sp_task, 0);
 +}
  
 -		edev->geneve_dst_port = 0;
 +static void qede_del_geneve_port(struct net_device *dev,
 +				 sa_family_t sa_family, __be16 port)
 +{
 +	struct qede_dev *edev = netdev_priv(dev);
 +	u16 t_port = ntohs(port);
  
 -		DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted geneve port=%d\n",
 -			   t_port);
 -		set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
 -		break;
 -	default:
 +	if (t_port != edev->geneve_dst_port)
  		return;
 -	}
  
 +	edev->geneve_dst_port = 0;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted geneve port=%d", t_port);
 +	set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
  	schedule_delayed_work(&edev->sp_task, 0);
  }
 +#endif
  
+ /* 8B udp header + 8B base tunnel header + 32B option length */
+ #define QEDE_MAX_TUN_HDR_LEN 48
+ 
+ static netdev_features_t qede_features_check(struct sk_buff *skb,
+ 					     struct net_device *dev,
+ 					     netdev_features_t features)
+ {
+ 	if (skb->encapsulation) {
+ 		u8 l4_proto = 0;
+ 
+ 		switch (vlan_get_protocol(skb)) {
+ 		case htons(ETH_P_IP):
+ 			l4_proto = ip_hdr(skb)->protocol;
+ 			break;
+ 		case htons(ETH_P_IPV6):
+ 			l4_proto = ipv6_hdr(skb)->nexthdr;
+ 			break;
+ 		default:
+ 			return features;
+ 		}
+ 
+ 		/* Disable offloads for geneve tunnels, as HW can't parse
+ 		 * the geneve header which has option length greater than 32B.
+ 		 */
+ 		if ((l4_proto == IPPROTO_UDP) &&
+ 		    ((skb_inner_mac_header(skb) -
+ 		      skb_transport_header(skb)) > QEDE_MAX_TUN_HDR_LEN))
+ 			return features & ~(NETIF_F_CSUM_MASK |
+ 					    NETIF_F_GSO_MASK);
+ 	}
+ 
+ 	return features;
+ }
+ 
  static const struct net_device_ops qede_netdev_ops = {
  	.ndo_open = qede_open,
  	.ndo_stop = qede_close,
@@@ -2256,14 -2296,9 +2290,20 @@@
  	.ndo_get_vf_config = qede_get_vf_config,
  	.ndo_set_vf_rate = qede_set_vf_rate,
  #endif
++<<<<<<< HEAD
 +#ifdef CONFIG_QEDE_VXLAN
 +	.ndo_add_vxlan_port = qede_add_vxlan_port,
 +	.ndo_del_vxlan_port = qede_del_vxlan_port,
 +#endif
 +#ifdef CONFIG_QEDE_GENEVE
 +	.ndo_add_geneve_port = qede_add_geneve_port,
 +	.ndo_del_geneve_port = qede_del_geneve_port,
 +#endif
++=======
+ 	.ndo_udp_tunnel_add = qede_udp_tunnel_add,
+ 	.ndo_udp_tunnel_del = qede_udp_tunnel_del,
+ 	.ndo_features_check = qede_features_check,
++>>>>>>> 256958538ae2 (qede: Prevent GSO on long Geneve headers)
  };
  
  /* -------------------------------------------------------------------------
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_main.c
