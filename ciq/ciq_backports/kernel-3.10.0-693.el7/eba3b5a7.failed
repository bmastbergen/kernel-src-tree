ipvs: SH fallback and L4 hashing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Frolkin <avf@eldamar.org.uk>
commit eba3b5a78799d21dea05118b294524958f0ab592
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/eba3b5a7.failed

By default the SH scheduler rejects connections that are hashed onto a
realserver of weight 0.  This patch adds a flag to make SH choose a
different realserver in this case, instead of rejecting the connection.

The patch also adds a flag to make SH include the source port (TCP, UDP,
SCTP) in the hash as well as the source address.  This basically allows
for deterministic round-robin load balancing (i.e., where any director
in a cluster of directors with identical config will send the same
packet the same way).

The flags are service flags (IP_VS_SVC_F_SCHED*) so that these options
can be set per service.  They are set using a new option to ipvsadm.

	Signed-off-by: Alexander Frolkin <avf@eldamar.org.uk>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Simon Horman <horms@verge.net.au>
(cherry picked from commit eba3b5a78799d21dea05118b294524958f0ab592)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipvs/ip_vs_sh.c
diff --cc net/netfilter/ipvs/ip_vs_sh.c
index a65edfe4b16c,f16c027df15b..000000000000
--- a/net/netfilter/ipvs/ip_vs_sh.c
+++ b/net/netfilter/ipvs/ip_vs_sh.c
@@@ -231,18 -296,21 +295,35 @@@ ip_vs_sh_schedule(struct ip_vs_service 
  {
  	struct ip_vs_dest *dest;
  	struct ip_vs_sh_state *s;
++<<<<<<< HEAD
 +	struct ip_vs_iphdr iph;
 +
 +	ip_vs_fill_iph_addr_only(svc->af, skb, &iph);
++=======
+ 	__be16 port = 0;
++>>>>>>> eba3b5a78799 (ipvs: SH fallback and L4 hashing)
  
  	IP_VS_DBG(6, "ip_vs_sh_schedule(): Scheduling...\n");
  
+ 	if (svc->flags & IP_VS_SVC_F_SCHED_SH_PORT)
+ 		port = ip_vs_sh_get_port(skb, iph);
+ 
  	s = (struct ip_vs_sh_state *) svc->sched_data;
++<<<<<<< HEAD
 +	dest = ip_vs_sh_get(svc->af, s, &iph.saddr);
 +	if (!dest
 +	    || !(dest->flags & IP_VS_DEST_F_AVAILABLE)
 +	    || atomic_read(&dest->weight) <= 0
 +	    || is_overloaded(dest)) {
++=======
+ 
+ 	if (svc->flags & IP_VS_SVC_F_SCHED_SH_FALLBACK)
+ 		dest = ip_vs_sh_get_fallback(svc, s, &iph->saddr, port);
+ 	else
+ 		dest = ip_vs_sh_get(svc, s, &iph->saddr, port);
+ 
+ 	if (!dest) {
++>>>>>>> eba3b5a78799 (ipvs: SH fallback and L4 hashing)
  		ip_vs_scheduler_err(svc, "no destination available");
  		return NULL;
  	}
diff --git a/include/uapi/linux/ip_vs.h b/include/uapi/linux/ip_vs.h
index a24537725e80..29458223d044 100644
--- a/include/uapi/linux/ip_vs.h
+++ b/include/uapi/linux/ip_vs.h
@@ -20,6 +20,12 @@
 #define IP_VS_SVC_F_PERSISTENT	0x0001		/* persistent port */
 #define IP_VS_SVC_F_HASHED	0x0002		/* hashed entry */
 #define IP_VS_SVC_F_ONEPACKET	0x0004		/* one-packet scheduling */
+#define IP_VS_SVC_F_SCHED1	0x0008		/* scheduler flag 1 */
+#define IP_VS_SVC_F_SCHED2	0x0010		/* scheduler flag 2 */
+#define IP_VS_SVC_F_SCHED3	0x0020		/* scheduler flag 3 */
+
+#define IP_VS_SVC_F_SCHED_SH_FALLBACK	IP_VS_SVC_F_SCHED1 /* SH fallback */
+#define IP_VS_SVC_F_SCHED_SH_PORT	IP_VS_SVC_F_SCHED2 /* SH use port */
 
 /*
  *      Destination Server Flags
* Unmerged path net/netfilter/ipvs/ip_vs_sh.c
