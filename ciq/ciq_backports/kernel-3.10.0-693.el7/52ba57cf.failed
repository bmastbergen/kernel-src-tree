switchdev: rename switchdev_obj_fdb to switchdev_obj_port_fdb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Pirko <jiri@mellanox.com>
commit 52ba57cfdc4c90da3bf996dfbe0c5feb731eb477
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/52ba57cf.failed

Make the struct name in sync with object id name.

	Suggested-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Scott Feldman <sfeldma@gmail.com>
	Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 52ba57cfdc4c90da3bf996dfbe0c5feb731eb477)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/rocker/rocker.c
#	include/net/switchdev.h
#	net/bridge/br_fdb.c
#	net/dsa/slave.c
#	net/switchdev/switchdev.c
diff --cc net/bridge/br_fdb.c
index 46b89ee4408e,36aab5e4784c..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -130,6 -131,16 +130,19 @@@ static void fdb_del_hw_addr(struct net_
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void fdb_del_external_learn(struct net_bridge_fdb_entry *f)
+ {
+ 	struct switchdev_obj_port_fdb fdb = {
+ 		.addr = f->addr.addr,
+ 		.vid = f->vlan_id,
+ 	};
+ 
+ 	switchdev_port_obj_del(f->dst->dev, SWITCHDEV_OBJ_ID_PORT_FDB, &fdb);
+ }
+ 
++>>>>>>> 52ba57cfdc4c (switchdev: rename switchdev_obj_fdb to switchdev_obj_port_fdb)
  static void fdb_delete(struct net_bridge *br, struct net_bridge_fdb_entry *f)
  {
  	if (f->is_static)
diff --cc net/dsa/slave.c
index 6ebd8fbd9285,6e8dc6a0102c..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -161,6 -200,208 +161,211 @@@ out
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int dsa_bridge_check_vlan_range(struct dsa_switch *ds,
+ 				       const struct net_device *bridge,
+ 				       u16 vid_begin, u16 vid_end)
+ {
+ 	struct dsa_slave_priv *p;
+ 	struct net_device *dev, *vlan_br;
+ 	DECLARE_BITMAP(members, DSA_MAX_PORTS);
+ 	DECLARE_BITMAP(untagged, DSA_MAX_PORTS);
+ 	u16 vid;
+ 	int member, err;
+ 
+ 	if (!ds->drv->vlan_getnext || !vid_begin)
+ 		return -EOPNOTSUPP;
+ 
+ 	vid = vid_begin - 1;
+ 
+ 	do {
+ 		err = ds->drv->vlan_getnext(ds, &vid, members, untagged);
+ 		if (err)
+ 			break;
+ 
+ 		if (vid > vid_end)
+ 			break;
+ 
+ 		member = find_first_bit(members, DSA_MAX_PORTS);
+ 		if (member == DSA_MAX_PORTS)
+ 			continue;
+ 
+ 		dev = ds->ports[member];
+ 		p = netdev_priv(dev);
+ 		vlan_br = p->bridge_dev;
+ 		if (vlan_br == bridge)
+ 			continue;
+ 
+ 		netdev_dbg(vlan_br, "hardware VLAN %d already in use\n", vid);
+ 		return -EOPNOTSUPP;
+ 	} while (vid < vid_end);
+ 
+ 	return err == -ENOENT ? 0 : err;
+ }
+ 
+ static int dsa_slave_port_vlan_add(struct net_device *dev,
+ 				   const struct switchdev_obj_port_vlan *vlan,
+ 				   struct switchdev_trans *trans)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	u16 vid;
+ 	int err;
+ 
+ 	if (switchdev_trans_ph_prepare(trans)) {
+ 		if (!ds->drv->port_vlan_add || !ds->drv->port_pvid_set)
+ 			return -EOPNOTSUPP;
+ 
+ 		/* If the requested port doesn't belong to the same bridge as
+ 		 * the VLAN members, fallback to software VLAN (hopefully).
+ 		 */
+ 		err = dsa_bridge_check_vlan_range(ds, p->bridge_dev,
+ 						  vlan->vid_begin,
+ 						  vlan->vid_end);
+ 		if (err)
+ 			return err;
+ 	} else {
+ 		for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
+ 			err = ds->drv->port_vlan_add(ds, p->port, vid,
+ 						     vlan->flags &
+ 						     BRIDGE_VLAN_INFO_UNTAGGED);
+ 			if (!err && vlan->flags & BRIDGE_VLAN_INFO_PVID)
+ 				err = ds->drv->port_pvid_set(ds, p->port, vid);
+ 			if (err)
+ 				return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int dsa_slave_port_vlan_del(struct net_device *dev,
+ 				   const struct switchdev_obj_port_vlan *vlan)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	u16 vid;
+ 	int err;
+ 
+ 	if (!ds->drv->port_vlan_del)
+ 		return -EOPNOTSUPP;
+ 
+ 	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
+ 		err = ds->drv->port_vlan_del(ds, p->port, vid);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int dsa_slave_port_vlan_dump(struct net_device *dev,
+ 				    struct switchdev_obj_port_vlan *vlan,
+ 				    int (*cb)(void *obj))
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	DECLARE_BITMAP(members, DSA_MAX_PORTS);
+ 	DECLARE_BITMAP(untagged, DSA_MAX_PORTS);
+ 	u16 pvid, vid = 0;
+ 	int err;
+ 
+ 	if (!ds->drv->vlan_getnext || !ds->drv->port_pvid_get)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = ds->drv->port_pvid_get(ds, p->port, &pvid);
+ 	if (err)
+ 		return err;
+ 
+ 	for (;;) {
+ 		err = ds->drv->vlan_getnext(ds, &vid, members, untagged);
+ 		if (err)
+ 			break;
+ 
+ 		if (!test_bit(p->port, members))
+ 			continue;
+ 
+ 		memset(vlan, 0, sizeof(*vlan));
+ 		vlan->vid_begin = vlan->vid_end = vid;
+ 
+ 		if (vid == pvid)
+ 			vlan->flags |= BRIDGE_VLAN_INFO_PVID;
+ 
+ 		if (test_bit(p->port, untagged))
+ 			vlan->flags |= BRIDGE_VLAN_INFO_UNTAGGED;
+ 
+ 		err = cb(vlan);
+ 		if (err)
+ 			break;
+ 	}
+ 
+ 	return err == -ENOENT ? 0 : err;
+ }
+ 
+ static int dsa_slave_port_fdb_add(struct net_device *dev,
+ 				  const struct switchdev_obj_port_fdb *fdb,
+ 				  struct switchdev_trans *trans)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	if (switchdev_trans_ph_prepare(trans))
+ 		ret = ds->drv->port_fdb_add ? 0 : -EOPNOTSUPP;
+ 	else
+ 		ret = ds->drv->port_fdb_add(ds, p->port, fdb->addr, fdb->vid);
+ 
+ 	return ret;
+ }
+ 
+ static int dsa_slave_port_fdb_del(struct net_device *dev,
+ 				  const struct switchdev_obj_port_fdb *fdb)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	if (ds->drv->port_fdb_del)
+ 		ret = ds->drv->port_fdb_del(ds, p->port, fdb->addr, fdb->vid);
+ 
+ 	return ret;
+ }
+ 
+ static int dsa_slave_port_fdb_dump(struct net_device *dev,
+ 				   struct switchdev_obj_port_fdb *fdb,
+ 				   int (*cb)(void *obj))
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	unsigned char addr[ETH_ALEN] = { 0 };
+ 	u16 vid = 0;
+ 	int ret;
+ 
+ 	if (!ds->drv->port_fdb_getnext)
+ 		return -EOPNOTSUPP;
+ 
+ 	for (;;) {
+ 		bool is_static;
+ 
+ 		ret = ds->drv->port_fdb_getnext(ds, p->port, addr, &vid,
+ 						&is_static);
+ 		if (ret < 0)
+ 			break;
+ 
+ 		fdb->addr = addr;
+ 		fdb->vid = vid;
+ 		fdb->ndm_state = is_static ? NUD_NOARP : NUD_REACHABLE;
+ 
+ 		ret = cb(fdb);
+ 		if (ret < 0)
+ 			break;
+ 	}
+ 
+ 	return ret == -ENOENT ? 0 : ret;
+ }
+ 
++>>>>>>> 52ba57cfdc4c (switchdev: rename switchdev_obj_fdb to switchdev_obj_port_fdb)
  static int dsa_slave_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
  {
  	struct dsa_slave_priv *p = netdev_priv(dev);
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/net/switchdev.h
* Unmerged path net/switchdev/switchdev.c
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/net/switchdev.h
* Unmerged path net/bridge/br_fdb.c
* Unmerged path net/dsa/slave.c
* Unmerged path net/switchdev/switchdev.c
