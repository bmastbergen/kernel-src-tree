treewide: fix typos in comment blocks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Masahiro Yamada <yamada.masahiro@socionext.com>
commit e1c05067c323fb92d27418fb3586171bd7ce2e12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e1c05067.failed

Looks like the word "contiguous" is often mistyped.

	Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.com>
(cherry picked from commit e1c05067c323fb92d27418fb3586171bd7ce2e12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/mips/kernel/setup.c
#	drivers/gpio/gpiolib-acpi.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
#	drivers/usb/gadget/udc/bdc/bdc.h
diff --cc arch/mips/kernel/setup.c
index c7f90519e58c,35b8316002f8..000000000000
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@@ -467,6 -476,7 +467,10 @@@ static void __init bootmem_init(void
   *  o bootmem_init()
   *  o sparse_init()
   *  o paging_init()
++<<<<<<< HEAD
++=======
+  *  o dma_contiguous_reserve()
++>>>>>>> e1c05067c323 (treewide: fix typos in comment blocks)
   *
   * At this stage the bootmem allocator is ready to use.
   *
diff --cc drivers/gpio/gpiolib-acpi.c
index 716ee9843110,143a9bdbaa53..000000000000
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@@ -34,6 -57,58 +34,61 @@@ static int acpi_gpiochip_find(struct gp
  	return ACPI_HANDLE(gc->dev) == data;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PINCTRL
+ /**
+  * acpi_gpiochip_pin_to_gpio_offset() - translates ACPI GPIO to Linux GPIO
+  * @chip: GPIO chip
+  * @pin: ACPI GPIO pin number from GpioIo/GpioInt resource
+  *
+  * Function takes ACPI GpioIo/GpioInt pin number as a parameter and
+  * translates it to a corresponding offset suitable to be passed to a
+  * GPIO controller driver.
+  *
+  * Typically the returned offset is same as @pin, but if the GPIO
+  * controller uses pin controller and the mapping is not contiguous the
+  * offset might be different.
+  */
+ static int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip, int pin)
+ {
+ 	struct gpio_pin_range *pin_range;
+ 
+ 	/* If there are no ranges in this chip, use 1:1 mapping */
+ 	if (list_empty(&chip->pin_ranges))
+ 		return pin;
+ 
+ 	list_for_each_entry(pin_range, &chip->pin_ranges, node) {
+ 		const struct pinctrl_gpio_range *range = &pin_range->range;
+ 		int i;
+ 
+ 		if (range->pins) {
+ 			for (i = 0; i < range->npins; i++) {
+ 				if (range->pins[i] == pin)
+ 					return range->base + i - chip->base;
+ 			}
+ 		} else {
+ 			if (pin >= range->pin_base &&
+ 			    pin < range->pin_base + range->npins) {
+ 				unsigned gpio_base;
+ 
+ 				gpio_base = range->base - chip->base;
+ 				return gpio_base + pin - range->pin_base;
+ 			}
+ 		}
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ #else
+ static inline int acpi_gpiochip_pin_to_gpio_offset(struct gpio_chip *chip,
+ 						   int pin)
+ {
+ 	return pin;
+ }
+ #endif
+ 
++>>>>>>> e1c05067c323 (treewide: fix typos in comment blocks)
  /**
   * acpi_get_gpiod() - Translate ACPI GPIO pin to GPIO descriptor usable with GPIO API
   * @path:	ACPI GPIO controller full path name, (e.g. "\\_SB.GPO1")
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 1903f878545a,8c9d01ef730d..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -135,10 -140,25 +135,24 @@@
  
  #define XGBE_TX_MAX_BUF_SIZE	(0x3fff & ~(64 - 1))
  
++<<<<<<< HEAD
++=======
+ /* Descriptors required for maximum contiguous TSO/GSO packet */
+ #define XGBE_TX_MAX_SPLIT	((GSO_MAX_SIZE / XGBE_TX_MAX_BUF_SIZE) + 1)
+ 
+ /* Maximum possible descriptors needed for an SKB:
+  * - Maximum number of SKB frags
+  * - Maximum descriptors for contiguous TSO/GSO packet
+  * - Possible context descriptor
+  * - Possible TSO header descriptor
+  */
+ #define XGBE_TX_MAX_DESCS	(MAX_SKB_FRAGS + XGBE_TX_MAX_SPLIT + 2)
+ 
++>>>>>>> e1c05067c323 (treewide: fix typos in comment blocks)
  #define XGBE_RX_MIN_BUF_SIZE	(ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN)
  #define XGBE_RX_BUF_ALIGN	64
 -#define XGBE_SKB_ALLOC_SIZE	256
 -#define XGBE_SPH_HDSMS_SIZE	2	/* Keep in sync with SKB_ALLOC_SIZE */
  
  #define XGBE_MAX_DMA_CHANNELS	16
 -#define XGBE_MAX_QUEUES		16
 -#define XGBE_DMA_STOP_TIMEOUT	5
  
  /* DMA cache settings - Outer sharable, write-back, write-allocate */
  #define XGBE_DMA_OS_AXDOMAIN	0x2
* Unmerged path drivers/usb/gadget/udc/bdc/bdc.h
* Unmerged path arch/mips/kernel/setup.c
* Unmerged path drivers/gpio/gpiolib-acpi.c
diff --git a/drivers/media/platform/exynos4-is/fimc-m2m.c b/drivers/media/platform/exynos4-is/fimc-m2m.c
index bde1f47f7ed3..86abe36a47c1 100644
--- a/drivers/media/platform/exynos4-is/fimc-m2m.c
+++ b/drivers/media/platform/exynos4-is/fimc-m2m.c
@@ -185,7 +185,7 @@ static int fimc_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
 	if (IS_ERR(f))
 		return PTR_ERR(f);
 	/*
-	 * Return number of non-contigous planes (plane buffers)
+	 * Return number of non-contiguous planes (plane buffers)
 	 * depending on the configured color format.
 	 */
 	if (!f->fmt)
diff --git a/drivers/media/v4l2-core/videobuf2-memops.c b/drivers/media/v4l2-core/videobuf2-memops.c
index 81c1ad8b2cf1..0d49b7951f84 100644
--- a/drivers/media/v4l2-core/videobuf2-memops.c
+++ b/drivers/media/v4l2-core/videobuf2-memops.c
@@ -125,7 +125,7 @@ int vb2_get_contig_userptr(unsigned long vaddr, unsigned long size,
 	}
 
 	/*
-	 * Memory is contigous, lock vma and return to the caller
+	 * Memory is contiguous, lock vma and return to the caller
 	 */
 	*res_vma = vb2_get_vma(vma);
 	if (*res_vma == NULL)
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
diff --git a/drivers/net/wireless/ath/ath6kl/wmi.c b/drivers/net/wireless/ath/ath6kl/wmi.c
index 4d7f9e4712e9..da6e74885b73 100644
--- a/drivers/net/wireless/ath/ath6kl/wmi.c
+++ b/drivers/net/wireless/ath/ath6kl/wmi.c
@@ -105,7 +105,7 @@ struct ath6kl_vif *ath6kl_get_vif_by_index(struct ath6kl *ar, u8 if_idx)
 }
 
 /*  Performs DIX to 802.3 encapsulation for transmit packets.
- *  Assumes the entire DIX header is contigous and that there is
+ *  Assumes the entire DIX header is contiguous and that there is
  *  enough room in the buffer for a 802.3 mac header and LLC+SNAP headers.
  */
 int ath6kl_wmi_dix_2_dot3(struct wmi *wmi, struct sk_buff *skb)
@@ -400,7 +400,7 @@ int ath6kl_wmi_dot11_hdr_remove(struct wmi *wmi, struct sk_buff *skb)
 
 /*
  * Performs 802.3 to DIX encapsulation for received packets.
- * Assumes the entire 802.3 header is contigous.
+ * Assumes the entire 802.3 header is contiguous.
  */
 int ath6kl_wmi_dot3_2_dix(struct sk_buff *skb)
 {
* Unmerged path drivers/usb/gadget/udc/bdc/bdc.h
diff --git a/fs/ocfs2/ocfs2_fs.h b/fs/ocfs2/ocfs2_fs.h
index 938387a10d5d..888ed701e002 100644
--- a/fs/ocfs2/ocfs2_fs.h
+++ b/fs/ocfs2/ocfs2_fs.h
@@ -167,7 +167,7 @@
 /* Refcount tree support */
 #define OCFS2_FEATURE_INCOMPAT_REFCOUNT_TREE	0x1000
 
-/* Discontigous block groups */
+/* Discontiguous block groups */
 #define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG	0x2000
 
 /*
@@ -928,7 +928,7 @@ struct ocfs2_group_desc
 			/*
 			 * Block groups may be discontiguous when
 			 * OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG is set.
-			 * The extents of a discontigous block group are
+			 * The extents of a discontiguous block group are
 			 * stored in bg_list.  It is a flat list.
 			 * l_tree_depth must always be zero.  A
 			 * discontiguous group is signified by a non-zero
diff --git a/include/media/videobuf-core.h b/include/media/videobuf-core.h
index 8c6e825940e5..d760aa73ebbb 100644
--- a/include/media/videobuf-core.h
+++ b/include/media/videobuf-core.h
@@ -37,7 +37,7 @@ struct videobuf_queue;
  *
  * about the mmap helpers (videobuf_mmap_*):
  *
- * The mmaper function allows to map any subset of contingous buffers.
+ * The mmaper function allows to map any subset of contiguous buffers.
  * This includes one mmap() call for all buffers (which the original
  * video4linux API uses) as well as one mmap() for every single buffer
  * (which v4l2 uses).
diff --git a/mm/nommu.c b/mm/nommu.c
index 33d45217ae7b..9a961c7c3ed9 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -331,12 +331,12 @@ long vwrite(char *buf, char *addr, unsigned long count)
 }
 
 /*
- *	vmalloc  -  allocate virtually continguos memory
+ *	vmalloc  -  allocate virtually contiguous memory
  *
  *	@size:		allocation size
  *
  *	Allocate enough pages to cover @size from the page level
- *	allocator and map them into continguos kernel virtual space.
+ *	allocator and map them into contiguous kernel virtual space.
  *
  *	For tight control over page level allocator and protection flags
  *	use __vmalloc() instead.
@@ -348,12 +348,12 @@ void *vmalloc(unsigned long size)
 EXPORT_SYMBOL(vmalloc);
 
 /*
- *	vzalloc - allocate virtually continguos memory with zero fill
+ *	vzalloc - allocate virtually contiguous memory with zero fill
  *
  *	@size:		allocation size
  *
  *	Allocate enough pages to cover @size from the page level
- *	allocator and map them into continguos kernel virtual space.
+ *	allocator and map them into contiguous kernel virtual space.
  *	The memory allocated is set to zero.
  *
  *	For tight control over page level allocator and protection flags
@@ -427,7 +427,7 @@ void *vmalloc_exec(unsigned long size)
  *	@size:		allocation size
  *
  *	Allocate enough 32bit PA addressable pages to cover @size from the
- *	page level allocator and map them into continguos kernel virtual space.
+ *	page level allocator and map them into contiguous kernel virtual space.
  */
 void *vmalloc_32(unsigned long size)
 {
