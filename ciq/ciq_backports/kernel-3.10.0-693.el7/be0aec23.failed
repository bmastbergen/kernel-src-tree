x86/mce/AMD, EDAC: Enable error decoding of Scalable MCA errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Aravind Gopalakrishnan <Aravind.Gopalakrishnan@amd.com>
commit be0aec23bf4624fd55650629fe8df20483487049
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/be0aec23.failed

For Scalable MCA enabled processors, errors are listed per IP block. And
since it is not required for an IP to map to a particular bank, we need
to use HWID and McaType values from the MCx_IPID register to figure out
which IP a given bank represents.

We also have a new bit (TCC) in the MCx_STATUS register to indicate Task
context is corrupt.

Add logic here to decode errors from all known IP blocks for Fam17h
Model 00-0fh and to print TCC errors.

[ Minor fixups. ]
	Signed-off-by: Aravind Gopalakrishnan <Aravind.Gopalakrishnan@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: linux-edac <linux-edac@vger.kernel.org>
Link: http://lkml.kernel.org/r/1457021458-2522-3-git-send-email-Aravind.Gopalakrishnan@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit be0aec23bf4624fd55650629fe8df20483487049)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/mce_amd.c
diff --cc drivers/edac/mce_amd.c
index 896ecd88aae5,49768c08ac07..000000000000
--- a/drivers/edac/mce_amd.c
+++ b/drivers/edac/mce_amd.c
@@@ -138,6 -138,144 +138,147 @@@ static const char * const mc5_mce_desc[
  	"Retire status queue"
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const mc6_mce_desc[] = {
+ 	"Hardware Assertion",
+ 	"Free List",
+ 	"Physical Register File",
+ 	"Retire Queue",
+ 	"Scheduler table",
+ 	"Status Register File",
+ };
+ 
+ /* Scalable MCA error strings */
+ static const char * const f17h_ls_mce_desc[] = {
+ 	"Load queue parity",
+ 	"Store queue parity",
+ 	"Miss address buffer payload parity",
+ 	"L1 TLB parity",
+ 	"",						/* reserved */
+ 	"DC tag error type 6",
+ 	"DC tag error type 1",
+ 	"Internal error type 1",
+ 	"Internal error type 2",
+ 	"Sys Read data error thread 0",
+ 	"Sys read data error thread 1",
+ 	"DC tag error type 2",
+ 	"DC data error type 1 (poison comsumption)",
+ 	"DC data error type 2",
+ 	"DC data error type 3",
+ 	"DC tag error type 4",
+ 	"L2 TLB parity",
+ 	"PDC parity error",
+ 	"DC tag error type 3",
+ 	"DC tag error type 5",
+ 	"L2 fill data error",
+ };
+ 
+ static const char * const f17h_if_mce_desc[] = {
+ 	"microtag probe port parity error",
+ 	"IC microtag or full tag multi-hit error",
+ 	"IC full tag parity",
+ 	"IC data array parity",
+ 	"Decoupling queue phys addr parity error",
+ 	"L0 ITLB parity error",
+ 	"L1 ITLB parity error",
+ 	"L2 ITLB parity error",
+ 	"BPQ snoop parity on Thread 0",
+ 	"BPQ snoop parity on Thread 1",
+ 	"L1 BTB multi-match error",
+ 	"L2 BTB multi-match error",
+ };
+ 
+ static const char * const f17h_l2_mce_desc[] = {
+ 	"L2M tag multi-way-hit error",
+ 	"L2M tag ECC error",
+ 	"L2M data ECC error",
+ 	"HW assert",
+ };
+ 
+ static const char * const f17h_de_mce_desc[] = {
+ 	"uop cache tag parity error",
+ 	"uop cache data parity error",
+ 	"Insn buffer parity error",
+ 	"Insn dispatch queue parity error",
+ 	"Fetch address FIFO parity",
+ 	"Patch RAM data parity",
+ 	"Patch RAM sequencer parity",
+ 	"uop buffer parity"
+ };
+ 
+ static const char * const f17h_ex_mce_desc[] = {
+ 	"Watchdog timeout error",
+ 	"Phy register file parity",
+ 	"Flag register file parity",
+ 	"Immediate displacement register file parity",
+ 	"Address generator payload parity",
+ 	"EX payload parity",
+ 	"Checkpoint queue parity",
+ 	"Retire dispatch queue parity",
+ };
+ 
+ static const char * const f17h_fp_mce_desc[] = {
+ 	"Physical register file parity",
+ 	"Freelist parity error",
+ 	"Schedule queue parity",
+ 	"NSQ parity error",
+ 	"Retire queue parity",
+ 	"Status register file parity",
+ };
+ 
+ static const char * const f17h_l3_mce_desc[] = {
+ 	"Shadow tag macro ECC error",
+ 	"Shadow tag macro multi-way-hit error",
+ 	"L3M tag ECC error",
+ 	"L3M tag multi-way-hit error",
+ 	"L3M data ECC error",
+ 	"XI parity, L3 fill done channel error",
+ 	"L3 victim queue parity",
+ 	"L3 HW assert",
+ };
+ 
+ static const char * const f17h_cs_mce_desc[] = {
+ 	"Illegal request from transport layer",
+ 	"Address violation",
+ 	"Security violation",
+ 	"Illegal response from transport layer",
+ 	"Unexpected response",
+ 	"Parity error on incoming request or probe response data",
+ 	"Parity error on incoming read response data",
+ 	"Atomic request parity",
+ 	"ECC error on probe filter access",
+ };
+ 
+ static const char * const f17h_pie_mce_desc[] = {
+ 	"HW assert",
+ 	"Internal PIE register security violation",
+ 	"Error on GMI link",
+ 	"Poison data written to internal PIE register",
+ };
+ 
+ static const char * const f17h_umc_mce_desc[] = {
+ 	"DRAM ECC error",
+ 	"Data poison error on DRAM",
+ 	"SDP parity error",
+ 	"Advanced peripheral bus error",
+ 	"Command/address parity error",
+ 	"Write data CRC error",
+ };
+ 
+ static const char * const f17h_pb_mce_desc[] = {
+ 	"Parameter Block RAM ECC error",
+ };
+ 
+ static const char * const f17h_psp_mce_desc[] = {
+ 	"PSP RAM ECC or parity error",
+ };
+ 
+ static const char * const f17h_smu_mce_desc[] = {
+ 	"SMU RAM ECC or parity error",
+ };
+ 
++>>>>>>> be0aec23bf46 (x86/mce/AMD, EDAC: Enable error decoding of Scalable MCA errors)
  static bool f12h_mc0_mce(u16 ec, u8 xec)
  {
  	bool ret = false;
diff --git a/arch/x86/include/asm/mce.h b/arch/x86/include/asm/mce.h
index 539b24ee777f..7510d21c443a 100644
--- a/arch/x86/include/asm/mce.h
+++ b/arch/x86/include/asm/mce.h
@@ -42,6 +42,18 @@
 /* AMD-specific bits */
 #define MCI_STATUS_DEFERRED	(1ULL<<44)  /* declare an uncorrected error */
 #define MCI_STATUS_POISON	(1ULL<<43)  /* access poisonous data */
+#define MCI_STATUS_TCC		(1ULL<<55)  /* Task context corrupt */
+
+/*
+ * McaX field if set indicates a given bank supports MCA extensions:
+ *  - Deferred error interrupt type is specifiable by bank.
+ *  - MCx_MISC0[BlkPtr] field indicates presence of extended MISC registers,
+ *    But should not be used to determine MSR numbers.
+ *  - TCC bit is present in MCx_STATUS.
+ */
+#define MCI_CONFIG_MCAX		0x1
+#define MCI_IPID_MCATYPE	0xFFFF0000
+#define MCI_IPID_HWID		0xFFF
 
 /*
  * Note that the full MCACOD field of IA32_MCi_STATUS MSR is
@@ -93,7 +105,9 @@
 
 /* AMD Scalable MCA */
 #define MSR_AMD64_SMCA_MC0_CONFIG	0xc0002004
+#define MSR_AMD64_SMCA_MC0_IPID		0xc0002005
 #define MSR_AMD64_SMCA_MCx_CONFIG(x)	(MSR_AMD64_SMCA_MC0_CONFIG + 0x10*(x))
+#define MSR_AMD64_SMCA_MCx_IPID(x)	(MSR_AMD64_SMCA_MC0_IPID + 0x10*(x))
 
 /*
  * This structure contains all data related to the MCE log.  Also
@@ -295,4 +309,49 @@ struct cper_sec_mem_err;
 extern void apei_mce_report_mem_error(int corrected,
 				      struct cper_sec_mem_err *mem_err);
 
+/*
+ * Enumerate new IP types and HWID values in AMD processors which support
+ * Scalable MCA.
+ */
+#ifdef CONFIG_X86_MCE_AMD
+enum amd_ip_types {
+	SMCA_F17H_CORE = 0,	/* Core errors */
+	SMCA_DF,		/* Data Fabric */
+	SMCA_UMC,		/* Unified Memory Controller */
+	SMCA_PB,		/* Parameter Block */
+	SMCA_PSP,		/* Platform Security Processor */
+	SMCA_SMU,		/* System Management Unit */
+	N_AMD_IP_TYPES
+};
+
+struct amd_hwid {
+	const char *name;
+	unsigned int hwid;
+};
+
+extern struct amd_hwid amd_hwids[N_AMD_IP_TYPES];
+
+enum amd_core_mca_blocks {
+	SMCA_LS = 0,	/* Load Store */
+	SMCA_IF,	/* Instruction Fetch */
+	SMCA_L2_CACHE,	/* L2 cache */
+	SMCA_DE,	/* Decoder unit */
+	RES,		/* Reserved */
+	SMCA_EX,	/* Execution unit */
+	SMCA_FP,	/* Floating Point */
+	SMCA_L3_CACHE,	/* L3 cache */
+	N_CORE_MCA_BLOCKS
+};
+
+extern const char * const amd_core_mcablock_names[N_CORE_MCA_BLOCKS];
+
+enum amd_df_mca_blocks {
+	SMCA_CS = 0,	/* Coherent Slave */
+	SMCA_PIE,	/* Power management, Interrupts, etc */
+	N_DF_BLOCKS
+};
+
+extern const char * const amd_df_mcablock_names[N_DF_BLOCKS];
+#endif
+
 #endif /* _ASM_X86_MCE_H */
diff --git a/arch/x86/kernel/cpu/mcheck/mce_amd.c b/arch/x86/kernel/cpu/mcheck/mce_amd.c
index 575b2d601c94..95887d4cb471 100644
--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c
@@ -71,6 +71,35 @@ static const char * const th_names[] = {
 	"execution_unit",
 };
 
+/* Define HWID to IP type mappings for Scalable MCA */
+struct amd_hwid amd_hwids[] = {
+	[SMCA_F17H_CORE]	= { "f17h_core",	0xB0 },
+	[SMCA_DF]		= { "data_fabric",	0x2E },
+	[SMCA_UMC]		= { "umc",		0x96 },
+	[SMCA_PB]		= { "param_block",	0x5 },
+	[SMCA_PSP]		= { "psp",		0xFF },
+	[SMCA_SMU]		= { "smu",		0x1 },
+};
+EXPORT_SYMBOL_GPL(amd_hwids);
+
+const char * const amd_core_mcablock_names[] = {
+	[SMCA_LS]		= "load_store",
+	[SMCA_IF]		= "insn_fetch",
+	[SMCA_L2_CACHE]		= "l2_cache",
+	[SMCA_DE]		= "decode_unit",
+	[RES]			= "",
+	[SMCA_EX]		= "execution_unit",
+	[SMCA_FP]		= "floating_point",
+	[SMCA_L3_CACHE]		= "l3_cache",
+};
+EXPORT_SYMBOL_GPL(amd_core_mcablock_names);
+
+const char * const amd_df_mcablock_names[] = {
+	[SMCA_CS]		= "coherent_slave",
+	[SMCA_PIE]		= "pie",
+};
+EXPORT_SYMBOL_GPL(amd_df_mcablock_names);
+
 static DEFINE_PER_CPU(struct threshold_bank **, threshold_banks);
 static DEFINE_PER_CPU(unsigned char, bank_map);	/* see which banks are on */
 
* Unmerged path drivers/edac/mce_amd.c
