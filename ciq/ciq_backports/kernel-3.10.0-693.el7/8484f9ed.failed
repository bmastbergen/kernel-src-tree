net/mlx5e: Don't post fragmented MPWQE when RQ is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Don't post fragmented MPWQE when RQ is disabled (Don Dutile) [1417284]
Rebuild_FUZZ: 96.43%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 8484f9ed13b26043be80ff5774506024956eae8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8484f9ed.failed

ICO (Internal control operations) SQ (Send Queue) is closed/disabled
after RQ (Receive Queue).  After RQ is closed an ICO SQ completion
might post a fragmented MPWQE (Multi Packet Work Queue Element) into
that RQ.

As on regular RQ post, check if we are allowed to post to that
RQ (RQ is enabled). Cleanup in-progress UMR MPWQE on mlx5e_free_rx_descs
if needed.

Fixes: bc77b240b3c5 ('net/mlx5e: Add fragmented memory support for RX multi packet WQE')
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8484f9ed13b26043be80ff5774506024956eae8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 03cb4d7e741a,e259eaa18f55..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -497,6 -527,27 +497,30 @@@ static int mlx5e_wait_for_min_rx_wqes(s
  	return -ETIMEDOUT;
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_free_rx_descs(struct mlx5e_rq *rq)
+ {
+ 	struct mlx5_wq_ll *wq = &rq->wq;
+ 	struct mlx5e_rx_wqe *wqe;
+ 	__be16 wqe_ix_be;
+ 	u16 wqe_ix;
+ 
+ 	/* UMR WQE (if in progress) is always at wq->head */
+ 	if (test_bit(MLX5E_RQ_STATE_UMR_WQE_IN_PROGRESS, &rq->state))
+ 		mlx5e_free_rx_fragmented_mpwqe(rq, &rq->wqe_info[wq->head]);
+ 
+ 	while (!mlx5_wq_ll_is_empty(wq)) {
+ 		wqe_ix_be = *wq->tail_next;
+ 		wqe_ix    = be16_to_cpu(wqe_ix_be);
+ 		wqe       = mlx5_wq_ll_get_wqe(&rq->wq, wqe_ix);
+ 		rq->dealloc_wqe(rq, wqe_ix);
+ 		mlx5_wq_ll_pop(&rq->wq, wqe_ix_be,
+ 			       &wqe->next.next_wqe_index);
+ 	}
+ }
+ 
++>>>>>>> 8484f9ed13b2 (net/mlx5e: Don't post fragmented MPWQE when RQ is disabled)
  static int mlx5e_open_rq(struct mlx5e_channel *c,
  			 struct mlx5e_rq_param *param,
  			 struct mlx5e_rq *rq)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index cfbbe9c677e6..0d004a635ddc 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@ -506,6 +506,12 @@ void mlx5e_post_rx_fragmented_mpwqe(struct mlx5e_rq *rq)
 	struct mlx5e_rx_wqe *wqe = mlx5_wq_ll_get_wqe(wq, wq->head);
 
 	clear_bit(MLX5E_RQ_STATE_UMR_WQE_IN_PROGRESS, &rq->state);
+
+	if (unlikely(test_bit(MLX5E_RQ_STATE_FLUSH, &rq->state))) {
+		mlx5e_free_rx_fragmented_mpwqe(rq, &rq->wqe_info[wq->head]);
+		return;
+	}
+
 	mlx5_wq_ll_push(wq, be16_to_cpu(wqe->next.next_wqe_index));
 	rq->stats.mpwqe_frag++;
 
