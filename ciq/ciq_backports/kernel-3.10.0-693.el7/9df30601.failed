net/mlx5e: Restore vlan filter after seamless reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Restore vlan filter after seamless reset (Don Dutile) [1385214 1385330 1417285]
Rebuild_FUZZ: 95.92%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit 9df30601c843aeb9877c966d9d75d4947117c923
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9df30601.failed

When detaching the mlx5e interface clear all the vlans rules from the
vlan flow table.
When attaching it back restore all the active vlans rules to the HW.

	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9df30601c843aeb9877c966d9d75d4947117c923)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 4df49e660587,36fbc6b21a33..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -655,12 -294,42 +655,42 @@@ int mlx5e_vlan_rx_kill_vid(struct net_d
  	return 0;
  }
  
+ static void mlx5e_add_vlan_rules(struct mlx5e_priv *priv)
+ {
+ 	int i;
+ 
+ 	mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);
+ 
+ 	for_each_set_bit(i, priv->fs.vlan.active_vlans, VLAN_N_VID) {
+ 		mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_VID, i);
+ 	}
+ 
+ 	if (priv->fs.vlan.filter_disabled &&
+ 	    !(priv->netdev->flags & IFF_PROMISC))
+ 		mlx5e_add_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_ANY_VID, 0);
+ }
+ 
+ static void mlx5e_del_vlan_rules(struct mlx5e_priv *priv)
+ {
+ 	int i;
+ 
+ 	mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);
+ 
+ 	for_each_set_bit(i, priv->fs.vlan.active_vlans, VLAN_N_VID) {
+ 		mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_MATCH_VID, i);
+ 	}
+ 
+ 	if (priv->fs.vlan.filter_disabled &&
+ 	    !(priv->netdev->flags & IFF_PROMISC))
+ 		mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_ANY_VID, 0);
+ }
+ 
  #define mlx5e_for_each_hash_node(hn, tmp, hash, i) \
 -	for (i = 0; i < MLX5E_L2_ADDR_HASH_SIZE; i++) \
 +	for (i = 0; i < MLX5E_ETH_ADDR_HASH_SIZE; i++) \
  		hlist_for_each_entry_safe(hn, tmp, &hash[i], hlist)
  
 -static void mlx5e_execute_l2_action(struct mlx5e_priv *priv,
 -				    struct mlx5e_l2_hash_node *hn)
 +static void mlx5e_execute_action(struct mlx5e_priv *priv,
 +				 struct mlx5e_eth_addr_hash_node *hn)
  {
  	switch (hn->action) {
  	case MLX5E_ACTION_ADD:
@@@ -1167,6 -1054,8 +1197,11 @@@ static int mlx5e_create_vlan_flow_table
  	if (err)
  		goto err_free_g;
  
++<<<<<<< HEAD
++=======
+ 	mlx5e_add_vlan_rules(priv);
+ 
++>>>>>>> 9df30601c843 (net/mlx5e: Restore vlan filter after seamless reset)
  	return 0;
  
  err_free_g:
@@@ -1179,12 -1067,13 +1214,17 @@@ err_destroy_vlan_flow_table
  	return err;
  }
  
 -static void mlx5e_destroy_vlan_table(struct mlx5e_priv *priv)
 +static void mlx5e_destroy_vlan_flow_table(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	mlx5e_destroy_flow_table(&priv->fts.vlan);
++=======
+ 	mlx5e_del_vlan_rules(priv);
+ 	mlx5e_destroy_flow_table(&priv->fs.vlan.ft);
++>>>>>>> 9df30601c843 (net/mlx5e: Restore vlan filter after seamless reset)
  }
  
 -int mlx5e_create_flow_steering(struct mlx5e_priv *priv)
 +int mlx5e_create_flow_tables(struct mlx5e_priv *priv)
  {
  	int err;
  
@@@ -1216,9 -1125,11 +1256,17 @@@ err_destroy_vlan_flow_table
  	return err;
  }
  
 -void mlx5e_destroy_flow_steering(struct mlx5e_priv *priv)
 +void mlx5e_destroy_flow_tables(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	mlx5e_del_vlan_rule(priv, MLX5E_VLAN_RULE_TYPE_UNTAGGED, 0);
 +	mlx5e_destroy_main_flow_table(priv);
 +	mlx5e_destroy_vlan_flow_table(priv);
++=======
+ 	mlx5e_destroy_vlan_table(priv);
+ 	mlx5e_destroy_l2_table(priv);
+ 	mlx5e_destroy_ttc_table(priv);
+ 	mlx5e_arfs_destroy_tables(priv);
+ 	mlx5e_ethtool_cleanup_steering(priv);
++>>>>>>> 9df30601c843 (net/mlx5e: Restore vlan filter after seamless reset)
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
