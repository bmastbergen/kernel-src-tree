rhashtable: Add rhlist interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit ca26893f05e86497a86732768ec53cd38c0819ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ca26893f.failed

The insecure_elasticity setting is an ugly wart brought out by
users who need to insert duplicate objects (that is, distinct
objects with identical keys) into the same table.

In fact, those users have a much bigger problem.  Once those
duplicate objects are inserted, they don't have an interface to
find them (unless you count the walker interface which walks
over the entire table).

Some users have resorted to doing a manual walk over the hash
table which is of course broken because they don't handle the
potential existence of multiple hash tables.  The result is that
they will break sporadically when they encounter a hash table
resize/rehash.

This patch provides a way out for those users, at the expense
of an extra pointer per object.  Essentially each object is now
a list of objects carrying the same key.  The hash table will
only see the lists so nothing changes as far as rhashtable is
concerned.

To use this new interface, you need to insert a struct rhlist_head
into your objects instead of struct rhash_head.  While the hash
table is unchanged, for type-safety you'll need to use struct
rhltable instead of struct rhashtable.  All the existing interfaces
have been duplicated for rhlist, including the hash table walker.

One missing feature is nulls marking because AFAIK the only potential
user of it does not need duplicate objects.  Should anyone need
this it shouldn't be too hard to add.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ca26893f05e86497a86732768ec53cd38c0819ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rhashtable.h
#	lib/rhashtable.c
diff --cc include/linux/rhashtable.h
index 08f2323b6cc0,5c132d3188be..000000000000
--- a/include/linux/rhashtable.h
+++ b/include/linux/rhashtable.h
@@@ -173,7 -189,8 +189,12 @@@ struct rhashtable_walker 
  struct rhashtable_iter {
  	struct rhashtable *ht;
  	struct rhash_head *p;
++<<<<<<< HEAD
 +	struct rhashtable_walker *walker;
++=======
+ 	struct rhlist_head *list;
+ 	struct rhashtable_walker walker;
++>>>>>>> ca26893f05e8 (rhashtable: Add rhlist interface)
  	unsigned int slot;
  	unsigned int skip;
  };
@@@ -339,15 -356,14 +360,13 @@@ static inline int lockdep_rht_bucket_is
  
  int rhashtable_init(struct rhashtable *ht,
  		    const struct rhashtable_params *params);
+ int rhltable_init(struct rhltable *hlt,
+ 		  const struct rhashtable_params *params);
  
- struct bucket_table *rhashtable_insert_slow(struct rhashtable *ht,
- 					    const void *key,
- 					    struct rhash_head *obj,
- 					    struct bucket_table *old_tbl,
- 					    void **data);
- int rhashtable_insert_rehash(struct rhashtable *ht, struct bucket_table *tbl);
+ void *rhashtable_insert_slow(struct rhashtable *ht, const void *key,
+ 			     struct rhash_head *obj);
  
 -void rhashtable_walk_enter(struct rhashtable *ht,
 -			   struct rhashtable_iter *iter);
 +int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter);
  void rhashtable_walk_exit(struct rhashtable_iter *iter);
  int rhashtable_walk_start(struct rhashtable_iter *iter) __acquires(RCU);
  void *rhashtable_walk_next(struct rhashtable_iter *iter);
@@@ -949,4 -1166,59 +1169,62 @@@ static inline int rhashtable_replace_fa
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ /* Obsolete function, do not use in new code. */
+ static inline int rhashtable_walk_init(struct rhashtable *ht,
+ 				       struct rhashtable_iter *iter, gfp_t gfp)
+ {
+ 	rhashtable_walk_enter(ht, iter);
+ 	return 0;
+ }
+ 
+ /**
+  * rhltable_walk_enter - Initialise an iterator
+  * @hlt:	Table to walk over
+  * @iter:	Hash table Iterator
+  *
+  * This function prepares a hash table walk.
+  *
+  * Note that if you restart a walk after rhashtable_walk_stop you
+  * may see the same object twice.  Also, you may miss objects if
+  * there are removals in between rhashtable_walk_stop and the next
+  * call to rhashtable_walk_start.
+  *
+  * For a completely stable walk you should construct your own data
+  * structure outside the hash table.
+  *
+  * This function may sleep so you must not call it from interrupt
+  * context or with spin locks held.
+  *
+  * You must call rhashtable_walk_exit after this function returns.
+  */
+ static inline void rhltable_walk_enter(struct rhltable *hlt,
+ 				       struct rhashtable_iter *iter)
+ {
+ 	return rhashtable_walk_enter(&hlt->ht, iter);
+ }
+ 
+ /**
+  * rhltable_free_and_destroy - free elements and destroy hash list table
+  * @hlt:	the hash list table to destroy
+  * @free_fn:	callback to release resources of element
+  * @arg:	pointer passed to free_fn
+  *
+  * See documentation for rhashtable_free_and_destroy.
+  */
+ static inline void rhltable_free_and_destroy(struct rhltable *hlt,
+ 					     void (*free_fn)(void *ptr,
+ 							     void *arg),
+ 					     void *arg)
+ {
+ 	return rhashtable_free_and_destroy(&hlt->ht, free_fn, arg);
+ }
+ 
+ static inline void rhltable_destroy(struct rhltable *hlt)
+ {
+ 	return rhltable_free_and_destroy(hlt, NULL, NULL);
+ }
+ 
++>>>>>>> ca26893f05e8 (rhashtable: Add rhlist interface)
  #endif /* _LINUX_RHASHTABLE_H */
diff --cc lib/rhashtable.c
index 343a52a9f280,32d0ad058380..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -600,12 -686,17 +694,21 @@@ EXPORT_SYMBOL_GPL(rhashtable_walk_start
   */
  void *rhashtable_walk_next(struct rhashtable_iter *iter)
  {
++<<<<<<< HEAD
 +	struct bucket_table *tbl = iter->walker->tbl;
++=======
+ 	struct bucket_table *tbl = iter->walker.tbl;
+ 	struct rhlist_head *list = iter->list;
++>>>>>>> ca26893f05e8 (rhashtable: Add rhlist interface)
  	struct rhashtable *ht = iter->ht;
  	struct rhash_head *p = iter->p;
+ 	bool rhlist = ht->rhlist;
  
  	if (p) {
- 		p = rht_dereference_bucket_rcu(p->next, tbl, iter->slot);
+ 		if (!rhlist || !(list = rcu_dereference(list->next))) {
+ 			p = rcu_dereference(p->next);
+ 			list = container_of(p, struct rhlist_head, rhead);
+ 		}
  		goto next;
  	}
  
* Unmerged path include/linux/rhashtable.h
* Unmerged path lib/rhashtable.c
