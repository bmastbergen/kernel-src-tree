xprtrdma: Rename fields in rpcrdma_fmr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 88975ebed5a82b7f0a16f22c81253fdd1ba15fce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/88975ebe.failed

Clean up: Use the same naming convention used in other
RPC/RDMA-related data structures.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Tested-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 88975ebed5a82b7f0a16f22c81253fdd1ba15fce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/fmr_ops.c
diff --cc net/sunrpc/xprtrdma/fmr_ops.c
index ecde1e1b320a,b8a5533225fa..000000000000
--- a/net/sunrpc/xprtrdma/fmr_ops.c
+++ b/net/sunrpc/xprtrdma/fmr_ops.c
@@@ -60,6 -66,44 +60,47 @@@ fmr_destroy_recovery_wq(void
  }
  
  static int
++<<<<<<< HEAD
++=======
+ __fmr_init(struct rpcrdma_mw *mw, struct ib_pd *pd)
+ {
+ 	static struct ib_fmr_attr fmr_attr = {
+ 		.max_pages	= RPCRDMA_MAX_FMR_SGES,
+ 		.max_maps	= 1,
+ 		.page_shift	= PAGE_SHIFT
+ 	};
+ 
+ 	mw->fmr.fm_physaddrs = kcalloc(RPCRDMA_MAX_FMR_SGES,
+ 				       sizeof(u64), GFP_KERNEL);
+ 	if (!mw->fmr.fm_physaddrs)
+ 		goto out_free;
+ 
+ 	mw->mw_sg = kcalloc(RPCRDMA_MAX_FMR_SGES,
+ 			    sizeof(*mw->mw_sg), GFP_KERNEL);
+ 	if (!mw->mw_sg)
+ 		goto out_free;
+ 
+ 	sg_init_table(mw->mw_sg, RPCRDMA_MAX_FMR_SGES);
+ 
+ 	mw->fmr.fm_mr = ib_alloc_fmr(pd, RPCRDMA_FMR_ACCESS_FLAGS,
+ 				     &fmr_attr);
+ 	if (IS_ERR(mw->fmr.fm_mr))
+ 		goto out_fmr_err;
+ 
+ 	return 0;
+ 
+ out_fmr_err:
+ 	dprintk("RPC:       %s: ib_alloc_fmr returned %ld\n", __func__,
+ 		PTR_ERR(mw->fmr.fm_mr));
+ 
+ out_free:
+ 	kfree(mw->mw_sg);
+ 	kfree(mw->fmr.fm_physaddrs);
+ 	return -ENOMEM;
+ }
+ 
+ static int
++>>>>>>> 88975ebed5a8 (xprtrdma: Rename fields in rpcrdma_fmr)
  __fmr_unmap(struct rpcrdma_mw *mw)
  {
  	LIST_HEAD(l);
@@@ -71,6 -115,30 +112,33 @@@
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ __fmr_dma_unmap(struct rpcrdma_xprt *r_xprt, struct rpcrdma_mr_seg *seg)
+ {
+ 	struct ib_device *device = r_xprt->rx_ia.ri_device;
+ 	int nsegs = seg->mr_nsegs;
+ 
+ 	while (nsegs--)
+ 		rpcrdma_unmap_one(device, seg++);
+ }
+ 
+ static void
+ __fmr_release(struct rpcrdma_mw *r)
+ {
+ 	int rc;
+ 
+ 	kfree(r->fmr.fm_physaddrs);
+ 	kfree(r->mw_sg);
+ 
+ 	rc = ib_dealloc_fmr(r->fmr.fm_mr);
+ 	if (rc)
+ 		pr_err("rpcrdma: final ib_dealloc_fmr for %p returned %i\n",
+ 		       r, rc);
+ }
+ 
++>>>>>>> 88975ebed5a8 (xprtrdma: Rename fields in rpcrdma_fmr)
  /* Deferred reset of a single FMR. Generate a fresh rkey by
   * replacing the MR. There's no recovery if this fails.
   */
* Unmerged path net/sunrpc/xprtrdma/fmr_ops.c
diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h
index 616f26ccd604..40736d6ce2a2 100644
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -236,8 +236,8 @@ struct rpcrdma_frmr {
 };
 
 struct rpcrdma_fmr {
-	struct ib_fmr		*fmr;
-	u64			*physaddrs;
+	struct ib_fmr		*fm_mr;
+	u64			*fm_physaddrs;
 };
 
 struct rpcrdma_mw {
