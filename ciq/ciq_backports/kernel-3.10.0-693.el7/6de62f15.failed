crypto: algif_hash - Require setkey before accept(2)

jira LE-1907
cve CVE-2015-8970
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] algif_hash - Require setkey before accept(2) ("Bruno E. O. Meneguele") [1386234] {CVE-2015-8970}
Rebuild_FUZZ: 91.67%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 6de62f15b581f920ade22d758f4c338311c2f0d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6de62f15.failed

Hash implementations that require a key may crash if you use
them without setting a key.  This patch adds the necessary checks
so that if you do attempt to use them without a key that we return
-ENOKEY instead of proceeding.

This patch also adds a compatibility path to support old applications
that do acept(2) before setkey.

	Cc: stable@vger.kernel.org
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 6de62f15b581f920ade22d758f4c338311c2f0d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/algif_hash.c
diff --cc crypto/algif_hash.c
index a68b56a368a8,46637bed4db8..000000000000
--- a/crypto/algif_hash.c
+++ b/crypto/algif_hash.c
@@@ -34,8 -34,13 +34,18 @@@ struct hash_ctx 
  	struct ahash_request req;
  };
  
++<<<<<<< HEAD
 +static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
 +			struct msghdr *msg, size_t ignored)
++=======
+ struct algif_hash_tfm {
+ 	struct crypto_ahash *hash;
+ 	bool has_key;
+ };
+ 
+ static int hash_sendmsg(struct socket *sock, struct msghdr *msg,
+ 			size_t ignored)
++>>>>>>> 6de62f15b581 (crypto: algif_hash - Require setkey before accept(2))
  {
  	int limit = ALG_MAX_PAGES * PAGE_SIZE;
  	struct sock *sk = sock->sk;
@@@ -266,9 -389,14 +405,14 @@@ static void hash_sock_destruct_common(s
  	struct alg_sock *ask = alg_sk(sk);
  	struct hash_ctx *ctx = ask->private;
  
 -	sock_kzfree_s(sk, ctx->result,
 -		      crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
 +	sock_kfree_s(sk, ctx->result,
 +		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
  	sock_kfree_s(sk, ctx, ctx->len);
+ }
+ 
+ static void hash_sock_destruct(struct sock *sk)
+ {
+ 	hash_sock_destruct_common(sk);
  	af_alg_release_parent(sk);
  }
  
* Unmerged path crypto/algif_hash.c
