i40e: implement __i40e_del_filter and use where applicable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 290d255719af42ae4baaf49165a69b9ad47f2049
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/290d2557.failed

When inside a loop where we call i40e_del_filter we use an O(n^2)
pattern where i40e_del_filter calls i40e_find_filter for us. We can
avoid this O(n^2) logic by factoring a function, __i40e_del_filter() out
from the i40e_del_filter code. This allows us to re-use the delete logic
where appropriate without having to search for the filter twice.

This new function benefits several functions including i40e_vsi_add_vlan,
i40e_vsi_kill_vlan, i40e_del_mac_vlan_all, and i40e_vsi_release.

Change-ID: I75fabe0f53bf73f56b80d342e5fdcfcc28f4d3eb
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 290d255719af42ae4baaf49165a69b9ad47f2049)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 6f5b9c2cdeec,25db8d80b684..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -1361,12 -1271,13 +1361,22 @@@ add_filter_out
  }
  
  /**
++<<<<<<< HEAD
 + * i40e_del_filter - Remove a mac/vlan filter from the VSI
 + * @vsi: the VSI to be searched
 + * @macaddr: the MAC address
 + * @vlan: the vlan
 + * @is_vf: make sure it's a VF filter, else doesn't matter
 + * @is_netdev: make sure it's a netdev filter, else doesn't matter
++=======
+  * __i40e_del_filter - Remove a specific filter from the VSI
+  * @vsi: VSI to remove from
+  * @f: the filter to remove from the list
+  *
+  * This function should be called instead of i40e_del_filter only if you know
+  * the exact filter you will remove already, such as via i40e_find_filter or
+  * i40e_find_mac.
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
   *
   * NOTE: This function is expected to be called with mac_filter_list_lock
   * being held.
@@@ -1374,57 -1285,106 +1384,137 @@@
   * the "safe" variants of any list iterators, e.g. list_for_each_entry_safe()
   * instead of list_for_each_entry().
   **/
++<<<<<<< HEAD
 +void i40e_del_filter(struct i40e_vsi *vsi,
 +		     u8 *macaddr, s16 vlan,
 +		     bool is_vf, bool is_netdev)
 +{
 +	struct i40e_mac_filter *f;
 +
 +	if (!vsi || !macaddr)
 +		return;
 +
 +	f = i40e_find_filter(vsi, macaddr, vlan, is_vf, is_netdev);
 +	if (!f || f->counter == 0)
++=======
+ static void __i40e_del_filter(struct i40e_vsi *vsi, struct i40e_mac_filter *f)
+ {
+ 	if (!f)
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  		return;
  
 -	if ((f->state == I40E_FILTER_FAILED) ||
 -	    (f->state == I40E_FILTER_NEW)) {
 -		/* this one never got added by the FW. Just remove it,
 -		 * no need to sync anything.
 -		 */
 -		list_del(&f->list);
 -		kfree(f);
 +	if (is_vf) {
 +		if (f->is_vf) {
 +			f->is_vf = false;
 +			f->counter--;
 +		}
 +	} else if (is_netdev) {
 +		if (f->is_netdev) {
 +			f->is_netdev = false;
 +			f->counter--;
 +		}
  	} else {
 -		f->state = I40E_FILTER_REMOVE;
 -		vsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;
 -		vsi->back->flags |= I40E_FLAG_FILTER_SYNC;
 -	}
 -}
 +		/* make sure we don't remove a filter in use by VF or netdev */
 +		int min_f = 0;
  
++<<<<<<< HEAD
 +		min_f += (f->is_vf ? 1 : 0);
 +		min_f += (f->is_netdev ? 1 : 0);
++=======
+ /**
+  * i40e_del_filter - Remove a MAC/VLAN filter from the VSI
+  * @vsi: the VSI to be searched
+  * @macaddr: the MAC address
+  * @vlan: the VLAN
+  *
+  * NOTE: This function is expected to be called with mac_filter_list_lock
+  * being held.
+  * ANOTHER NOTE: This function MUST be called from within the context of
+  * the "safe" variants of any list iterators, e.g. list_for_each_entry_safe()
+  * instead of list_for_each_entry().
+  **/
+ void i40e_del_filter(struct i40e_vsi *vsi, const u8 *macaddr, s16 vlan)
+ {
+ 	struct i40e_mac_filter *f;
+ 
+ 	if (!vsi || !macaddr)
+ 		return;
+ 
+ 	f = i40e_find_filter(vsi, macaddr, vlan);
+ 	__i40e_del_filter(vsi, f);
+ }
+ 
+ /**
+  * i40e_put_mac_in_vlan - Make macvlan filters from macaddrs and vlans
+  * @vsi: the VSI to be searched
+  * @macaddr: the mac address to be filtered
+  *
+  * Goes through all the macvlan filters and adds a macvlan filter for each
+  * unique vlan that already exists. If a PVID has been assigned, instead only
+  * add the macaddr to that VLAN.
+  *
+  * Returns last filter added on success, else NULL
+  **/
+ struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi,
+ 					     const u8 *macaddr)
+ {
+ 	struct i40e_mac_filter *f, *add = NULL;
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  
 -	if (vsi->info.pvid)
 -		return i40e_add_filter(vsi, macaddr,
 -				       le16_to_cpu(vsi->info.pvid));
 -
 -	list_for_each_entry(f, &vsi->mac_filter_list, list) {
 -		if (f->state == I40E_FILTER_REMOVE)
 -			continue;
 -		add = i40e_add_filter(vsi, macaddr, f->vlan);
 -		if (!add)
 -			return NULL;
 +		if (f->counter > min_f)
 +			f->counter--;
  	}
  
++<<<<<<< HEAD
 +	/* counter == 0 tells sync_filters_subtask to
 +	 * remove the filter from the firmware's list
 +	 */
 +	if (f->counter == 0) {
 +		if ((f->state == I40E_FILTER_FAILED) ||
 +		    (f->state == I40E_FILTER_NEW)) {
 +			/* this one never got added by the FW. Just remove it,
 +			 * no need to sync anything.
 +			 */
 +			list_del(&f->list);
 +			kfree(f);
 +		} else {
 +			f->state = I40E_FILTER_REMOVE;
 +			vsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;
 +			vsi->back->flags |= I40E_FLAG_FILTER_SYNC;
 +		}
 +	}
++=======
+ 	return add;
+ }
+ 
+ /**
+  * i40e_del_mac_all_vlan - Remove a MAC filter from all VLANS
+  * @vsi: the VSI to be searched
+  * @macaddr: the mac address to be removed
+  *
+  * Removes a given MAC address from a VSI, regardless of VLAN
+  *
+  * Returns 0 for success, or error
+  **/
+ int i40e_del_mac_all_vlan(struct i40e_vsi *vsi, const u8 *macaddr)
+ {
+ 	struct i40e_mac_filter *f, *ftmp;
+ 	bool found = false;
+ 
+ 	WARN(!spin_is_locked(&vsi->mac_filter_list_lock),
+ 	     "Missing mac_filter_list_lock\n");
+ 	list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list) {
+ 		if (ether_addr_equal(macaddr, f->macaddr)) {
+ 			__i40e_del_filter(vsi, f);
+ 			found = true;
+ 		}
+ 	}
+ 
+ 	if (found)
+ 		return 0;
+ 	else
+ 		return -ENOENT;
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  }
  
  /**
@@@ -2326,11 -2277,7 +2416,15 @@@ static void i40e_vlan_rx_register(struc
   **/
  int i40e_vsi_add_vlan(struct i40e_vsi *vsi, s16 vid)
  {
++<<<<<<< HEAD
 +	struct i40e_mac_filter *f, *ftmp, *add_f;
 +	bool is_netdev, is_vf;
 +
 +	is_vf = (vsi->type == I40E_VSI_SRIOV);
 +	is_netdev = !!(vsi->netdev);
++=======
+ 	struct i40e_mac_filter *f, *ftmp, *add_f, *del_f;
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  
  	/* Locked once because all functions invoked below iterates list*/
  	spin_lock_bh(&vsi->mac_filter_list_lock);
@@@ -2363,14 -2311,12 +2457,23 @@@
  	 * with 0, so we now accept untagged and specified tagged traffic
  	 * (and not all tags along with untagged)
  	 */
++<<<<<<< HEAD
 +	if (vid > 0) {
 +		if (is_netdev && i40e_find_filter(vsi, vsi->netdev->dev_addr,
 +						  I40E_VLAN_ANY,
 +						  is_vf, is_netdev)) {
 +			i40e_del_filter(vsi, vsi->netdev->dev_addr,
 +					I40E_VLAN_ANY, is_vf, is_netdev);
 +			add_f = i40e_add_filter(vsi, vsi->netdev->dev_addr, 0,
 +						is_vf, is_netdev);
++=======
+ 	if (vid > 0 && vsi->netdev) {
+ 		del_f = i40e_find_filter(vsi, vsi->netdev->dev_addr,
+ 					 I40E_VLAN_ANY);
+ 		if (del_f) {
+ 			__i40e_del_filter(vsi, del_f);
+ 			add_f = i40e_add_filter(vsi, vsi->netdev->dev_addr, 0);
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  			if (!add_f) {
  				dev_info(&vsi->back->pdev->dev,
  					 "Could not add filter 0 for %pM\n",
@@@ -2384,13 -2330,14 +2487,22 @@@
  	/* Do not assume that I40E_VLAN_ANY should be reset to VLAN 0 */
  	if (vid > 0 && !vsi->info.pvid) {
  		list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list) {
 -			if (f->state == I40E_FILTER_REMOVE)
 +			if (!i40e_find_filter(vsi, f->macaddr, I40E_VLAN_ANY,
 +					      is_vf, is_netdev))
  				continue;
++<<<<<<< HEAD
 +			i40e_del_filter(vsi, f->macaddr, I40E_VLAN_ANY,
 +					is_vf, is_netdev);
 +			add_f = i40e_add_filter(vsi, f->macaddr,
 +						0, is_vf, is_netdev);
++=======
+ 			del_f = i40e_find_filter(vsi, f->macaddr,
+ 						 I40E_VLAN_ANY);
+ 			if (!del_f)
+ 				continue;
+ 			__i40e_del_filter(vsi, del_f);
+ 			add_f = i40e_add_filter(vsi, f->macaddr, 0);
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  			if (!add_f) {
  				dev_info(&vsi->back->pdev->dev,
  					 "Could not add filter 0 for %pM\n",
@@@ -2433,11 -2373,13 +2545,18 @@@ int i40e_vsi_kill_vlan(struct i40e_vsi 
  	/* Locked once because all functions invoked below iterates list */
  	spin_lock_bh(&vsi->mac_filter_list_lock);
  
 -	if (vsi->netdev)
 -		i40e_del_filter(vsi, netdev->dev_addr, vid);
 +	if (is_netdev)
 +		i40e_del_filter(vsi, netdev->dev_addr, vid, is_vf, is_netdev);
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list)
 +		i40e_del_filter(vsi, f->macaddr, vid, is_vf, is_netdev);
++=======
+ 	list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list) {
+ 		if (f->vlan == vid)
+ 			__i40e_del_filter(vsi, f);
+ 	}
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  
  	/* go through all the filters for this VSI and if there is only
  	 * vid == 0 it means there are no other filters, so vid 0 must
@@@ -2470,9 -2411,9 +2589,15 @@@
  
  	if (!filter_count) {
  		list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list) {
++<<<<<<< HEAD
 +			i40e_del_filter(vsi, f->macaddr, 0, is_vf, is_netdev);
 +			add_f = i40e_add_filter(vsi, f->macaddr, I40E_VLAN_ANY,
 +						is_vf, is_netdev);
++=======
+ 			if (!f->vlan)
+ 				__i40e_del_filter(vsi, f);
+ 			add_f = i40e_add_filter(vsi, f->macaddr, I40E_VLAN_ANY);
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  			if (!add_f) {
  				dev_info(&vsi->back->pdev->dev,
  					 "Could not add filter %d for %pM\n",
@@@ -9580,9 -9472,17 +9705,14 @@@ int i40e_vsi_release(struct i40e_vsi *v
  	}
  
  	spin_lock_bh(&vsi->mac_filter_list_lock);
 -
 -	/* clear the sync flag on all filters */
 -	if (vsi->netdev) {
 -		__dev_uc_unsync(vsi->netdev, NULL);
 -		__dev_mc_unsync(vsi->netdev, NULL);
 -	}
 -
 -	/* make sure any remaining filters are marked for deletion */
  	list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list)
++<<<<<<< HEAD
 +		i40e_del_filter(vsi, f->macaddr, f->vlan,
 +				f->is_vf, f->is_netdev);
++=======
+ 		__i40e_del_filter(vsi, f);
+ 
++>>>>>>> 290d255719af (i40e: implement __i40e_del_filter and use where applicable)
  	spin_unlock_bh(&vsi->mac_filter_list_lock);
  
  	i40e_sync_vsi_filters(vsi);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
