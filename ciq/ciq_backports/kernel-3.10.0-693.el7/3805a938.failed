flow_dissector: Check skb for VLAN only if skb specified.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Garver <e@erig.me>
commit 3805a938a6c24284863732fd45cec5a04609a224
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3805a938.failed

Fixes a panic when calling eth_get_headlen(). Noticed on i40e driver.

Fixes: d5709f7ab776 ("flow_dissector: For stripped vlan, get vlan info from skb->vlan_tci")
	Signed-off-by: Eric Garver <e@erig.me>
	Reviewed-by: Jakub Sitnicki <jkbs@redhat.com>
	Acked-by: Amir Vadai <amir@vadai.me>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3805a938a6c24284863732fd45cec5a04609a224)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,44e6ba9d3a6b..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -173,20 -243,49 +173,58 @@@ ipv6
  
  		break;
  	}
 -	case htons(ETH_P_8021AD):
 -	case htons(ETH_P_8021Q): {
 +	case __constant_htons(ETH_P_8021AD):
 +	case __constant_htons(ETH_P_8021Q): {
  		const struct vlan_hdr *vlan;
 +		struct vlan_hdr _vlan;
  
++<<<<<<< HEAD
 +		vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);
 +		if (!vlan)
 +			return false;
++=======
+ 		if (skb && skb_vlan_tag_present(skb))
+ 			proto = skb->protocol;
+ 
+ 		if (eth_type_vlan(proto)) {
+ 			struct vlan_hdr _vlan;
+ 
+ 			vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan),
+ 						    data, hlen, &_vlan);
+ 			if (!vlan)
+ 				goto out_bad;
+ 			proto = vlan->h_vlan_encapsulated_proto;
+ 			nhoff += sizeof(*vlan);
+ 			if (skip_vlan)
+ 				goto again;
+ 		}
+ 
+ 		skip_vlan = true;
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_VLAN)) {
+ 			key_vlan = skb_flow_dissector_target(flow_dissector,
+ 							     FLOW_DISSECTOR_KEY_VLAN,
+ 							     target_container);
+ 
+ 			if (skb_vlan_tag_present(skb)) {
+ 				key_vlan->vlan_id = skb_vlan_tag_get_id(skb);
+ 				key_vlan->vlan_priority =
+ 					(skb_vlan_tag_get_prio(skb) >> VLAN_PRIO_SHIFT);
+ 			} else {
+ 				key_vlan->vlan_id = ntohs(vlan->h_vlan_TCI) &
+ 					VLAN_VID_MASK;
+ 				key_vlan->vlan_priority =
+ 					(ntohs(vlan->h_vlan_TCI) &
+ 					 VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;
+ 			}
+ 		}
++>>>>>>> 3805a938a6c2 (flow_dissector: Check skb for VLAN only if skb specified.)
  
 +		proto = vlan->h_vlan_encapsulated_proto;
 +		nhoff += sizeof(*vlan);
  		goto again;
  	}
 -	case htons(ETH_P_PPP_SES): {
 +	case __constant_htons(ETH_P_PPP_SES): {
  		struct {
  			struct pppoe_hdr hdr;
  			__be16 proto;
* Unmerged path net/core/flow_dissector.c
