HID: wacom: store the hid_device pointers of the sibling devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: store the hid_device pointers of the sibling devices (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.93%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit a97ac10401fe86fa30ef73315241e31d8594a651
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a97ac104.failed

The Bamboo PAD in debug mode needs to re-route events from the debug
interface to the Pen interface. This can be easily done with
hid_input_report(), but that means that we need to keep a reference to
the various hid_devices.

There should be only one touch and one pen interface per physical tablet,
so there is no need to keep a list of hid-devices, plain pointers are
sufficient.

	Tested-by: Josep Sanchez Ferreres <josep.sanchez.ferreres@est.fib.upc.edu>
	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit a97ac10401fe86fa30ef73315241e31d8594a651)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,b3c2395aef3b..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -704,8 -522,13 +704,13 @@@ static int wacom_add_shared_data(struc
  		list_add_tail(&data->list, &wacom_udev_list);
  	}
  
 -	wacom_wac->shared = &data->shared;
 +	wacom->shared = &data->shared;
  
+ 	if (wacom_wac->features.device_type == BTN_TOOL_FINGER)
+ 		wacom_wac->shared->touch = hdev;
+ 	else if (wacom_wac->features.device_type == BTN_TOOL_PEN)
+ 		wacom_wac->shared->pen = hdev;
+ 
  out:
  	mutex_unlock(&wacom_udev_list_lock);
  	return retval;
@@@ -723,14 -546,22 +728,29 @@@ static void wacom_release_shared_data(s
  	kfree(data);
  }
  
- static void wacom_remove_shared_data(struct wacom_wac *wacom)
+ static void wacom_remove_shared_data(struct wacom *wacom)
  {
++<<<<<<< HEAD
 +	struct wacom_usbdev_data *data;
 +
 +	if (wacom->shared) {
 +		data = container_of(wacom->shared, struct wacom_usbdev_data, shared);
++=======
+ 	struct wacom_hdev_data *data;
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	if (wacom_wac->shared) {
+ 		data = container_of(wacom_wac->shared, struct wacom_hdev_data,
+ 				    shared);
+ 
+ 		if (wacom_wac->shared->touch == wacom->hdev)
+ 			wacom_wac->shared->touch = NULL;
+ 		else if (wacom_wac->shared->pen == wacom->hdev)
+ 			wacom_wac->shared->pen = NULL;
+ 
++>>>>>>> a97ac10401fe (HID: wacom: store the hid_device pointers of the sibling devices)
  		kref_put(&data->kref, wacom_release_shared_data);
- 		wacom->shared = NULL;
+ 		wacom_wac->shared = NULL;
  	}
  }
  
@@@ -1425,30 -1533,39 +1445,55 @@@ static int wacom_probe(struct usb_inter
  
  	return 0;
  
++<<<<<<< HEAD
 + fail5: wacom_destroy_leds(wacom);
 + fail4:	wacom_remove_shared_data(wacom_wac);
 + fail3:	usb_free_urb(wacom->irq);
 + fail2:	usb_free_coherent(dev, WACOM_PKGLEN_MAX, wacom_wac->data, wacom->data_dma);
 + fail1:	kfree(wacom);
++=======
+ fail_hw_start:
+ 	if (hdev->bus == BUS_BLUETOOTH)
+ 		device_remove_file(&hdev->dev, &dev_attr_speed);
+ fail_register_inputs:
+ 	wacom_clean_inputs(wacom);
+ 	wacom_destroy_battery(wacom);
+ fail_battery:
+ 	wacom_remove_shared_data(wacom);
+ fail_shared_data:
+ 	wacom_clean_inputs(wacom);
+ fail_allocate_inputs:
+ fail_type:
+ fail_pktlen:
+ fail_parse:
+ 	kfree(wacom);
+ 	hid_set_drvdata(hdev, NULL);
++>>>>>>> a97ac10401fe (HID: wacom: store the hid_device pointers of the sibling devices)
  	return error;
  }
  
 -static void wacom_remove(struct hid_device *hdev)
 +static void wacom_disconnect(struct usb_interface *intf)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 +	struct wacom *wacom = usb_get_intfdata(intf);
  
 -	hid_hw_stop(hdev);
 +	usb_set_intfdata(intf, NULL);
  
 +	usb_kill_urb(wacom->irq);
  	cancel_work_sync(&wacom->work);
 -	wacom_clean_inputs(wacom);
 -	if (hdev->bus == BUS_BLUETOOTH)
 -		device_remove_file(&hdev->dev, &dev_attr_speed);
 +	if (wacom->wacom_wac.input)
 +		input_unregister_device(wacom->wacom_wac.input);
  	wacom_destroy_battery(wacom);
++<<<<<<< HEAD
 +	wacom_destroy_leds(wacom);
 +	usb_free_urb(wacom->irq);
 +	usb_free_coherent(interface_to_usbdev(intf), WACOM_PKGLEN_MAX,
 +			wacom->wacom_wac.data, wacom->data_dma);
 +	wacom_remove_shared_data(&wacom->wacom_wac);
++=======
+ 	wacom_remove_shared_data(wacom);
+ 
+ 	hid_set_drvdata(hdev, NULL);
++>>>>>>> a97ac10401fe (HID: wacom: store the hid_device pointers of the sibling devices)
  	kfree(wacom);
  }
  
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,e42efbe3338c..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -135,6 -165,26 +135,29 @@@ struct wacom_features 
  struct wacom_shared {
  	bool stylus_in_proximity;
  	bool touch_down;
++<<<<<<< HEAD
++=======
+ 	/* for wireless device to access USB interfaces */
+ 	unsigned touch_max;
+ 	int type;
+ 	struct input_dev *touch_input;
+ 	struct hid_device *pen;
+ 	struct hid_device *touch;
+ };
+ 
+ struct hid_data {
+ 	__s16 inputmode;	/* InputMode HID feature, -1 if non-existent */
+ 	__s16 inputmode_index;	/* InputMode HID feature index in the report */
+ 	bool inrange_state;
+ 	bool invert_state;
+ 	bool tipswitch;
+ 	int x;
+ 	int y;
+ 	int pressure;
+ 	int width;
+ 	int height;
+ 	int id;
++>>>>>>> a97ac10401fe (HID: wacom: store the hid_device pointers of the sibling devices)
  };
  
  struct wacom_wac {
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.h
