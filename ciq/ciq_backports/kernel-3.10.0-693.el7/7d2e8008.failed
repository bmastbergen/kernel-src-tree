nvme: allow transitioning from NEW to LIVE state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [nvme] allow transitioning from NEW to LIVE state (David Milburn) [1384526 1389755 1366753 1374291 1383834]
Rebuild_FUZZ: 93.33%
commit-author Christoph Hellwig <hch@lst.de>
commit 7d2e80080d186c1267f3033b6de91f0ff2f2863d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7d2e8008.failed

For Fabrics we're not going through an intermediate reset state
(at least for now).

	Reviewed-by: Jay Freyensee <james.p.freyensee@intel.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 7d2e80080d186c1267f3033b6de91f0ff2f2863d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 63f6b5f40b5c,f874c0e6b4bd..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -56,6 -58,82 +56,85 @@@ DEFINE_SPINLOCK(dev_list_lock)
  
  static struct class *nvme_class;
  
++<<<<<<< HEAD
++=======
+ void nvme_cancel_request(struct request *req, void *data, bool reserved)
+ {
+ 	int status;
+ 
+ 	if (!blk_mq_request_started(req))
+ 		return;
+ 
+ 	dev_dbg_ratelimited(((struct nvme_ctrl *) data)->device,
+ 				"Cancelling I/O %d", req->tag);
+ 
+ 	status = NVME_SC_ABORT_REQ;
+ 	if (blk_queue_dying(req->q))
+ 		status |= NVME_SC_DNR;
+ 	blk_mq_complete_request(req, status);
+ }
+ EXPORT_SYMBOL_GPL(nvme_cancel_request);
+ 
+ bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
+ 		enum nvme_ctrl_state new_state)
+ {
+ 	enum nvme_ctrl_state old_state = ctrl->state;
+ 	bool changed = false;
+ 
+ 	spin_lock_irq(&ctrl->lock);
+ 	switch (new_state) {
+ 	case NVME_CTRL_LIVE:
+ 		switch (old_state) {
+ 		case NVME_CTRL_NEW:
+ 		case NVME_CTRL_RESETTING:
+ 			changed = true;
+ 			/* FALLTHRU */
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	case NVME_CTRL_RESETTING:
+ 		switch (old_state) {
+ 		case NVME_CTRL_NEW:
+ 		case NVME_CTRL_LIVE:
+ 			changed = true;
+ 			/* FALLTHRU */
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	case NVME_CTRL_DELETING:
+ 		switch (old_state) {
+ 		case NVME_CTRL_LIVE:
+ 		case NVME_CTRL_RESETTING:
+ 			changed = true;
+ 			/* FALLTHRU */
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	case NVME_CTRL_DEAD:
+ 		switch (old_state) {
+ 		case NVME_CTRL_DELETING:
+ 			changed = true;
+ 			/* FALLTHRU */
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 	spin_unlock_irq(&ctrl->lock);
+ 
+ 	if (changed)
+ 		ctrl->state = new_state;
+ 
+ 	return changed;
+ }
+ EXPORT_SYMBOL_GPL(nvme_change_ctrl_state);
+ 
++>>>>>>> 7d2e80080d18 (nvme: allow transitioning from NEW to LIVE state)
  static void nvme_free_ns(struct kref *kref)
  {
  	struct nvme_ns *ns = container_of(kref, struct nvme_ns, kref);
* Unmerged path drivers/nvme/host/core.c
