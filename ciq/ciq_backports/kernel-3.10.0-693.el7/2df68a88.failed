HID: wacom: convert LEDs to devres

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: convert LEDs to devres (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 92.06%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 2df68a8864883ff006b76f50dfc32fd230247ef9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2df68a88.failed

Use our own wacom_devm_sysfs_create_group() as there is currently no
generic one. It has been requested at least twice [1][2] but has been
always rejected.
However, in the Wacom case, for the wirelessly connected devices, we need
to be able to release the created sysfs files without removing the parent
kobject.

[1] https://patchwork.kernel.org/patch/7526551/
[2] https://lkml.org/lkml/2013/3/14/728

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 2df68a8864883ff006b76f50dfc32fd230247ef9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom.h
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom.h
index 87d2c48e3adc,bcfeb517221e..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -125,20 -124,47 +125,30 @@@ struct wacom 
  		u8 hlv;       /* status led brightness button pressed (1..127) */
  		u8 img_lum;   /* OLED matrix display brightness */
  	} led;
++<<<<<<< HEAD
 +	bool led_initialized;
 +	struct power_supply battery;
++=======
+ 	struct power_supply *battery;
+ 	struct power_supply *ac;
+ 	struct power_supply_desc battery_desc;
+ 	struct power_supply_desc ac_desc;
+ 	struct kobject *remote_dir;
+ 	struct attribute_group remote_group[5];
+ 	bool resources;
++>>>>>>> 2df68a886488 (HID: wacom: convert LEDs to devres)
  };
  
 -static inline void wacom_schedule_work(struct wacom_wac *wacom_wac,
 -				       enum wacom_worker which)
 +static inline void wacom_schedule_work(struct wacom_wac *wacom_wac)
  {
  	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
 -
 -	switch (which) {
 -	case WACOM_WORKER_WIRELESS:
 -		schedule_work(&wacom->wireless_work);
 -		break;
 -	case WACOM_WORKER_BATTERY:
 -		schedule_work(&wacom->battery_work);
 -		break;
 -	}
 +	schedule_work(&wacom->work);
  }
  
 -extern const struct hid_device_id wacom_ids[];
 +extern const struct usb_device_id wacom_ids[];
  
  void wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len);
 -void wacom_setup_device_quirks(struct wacom *wacom);
 -int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 -				   struct wacom_wac *wacom_wac);
 -int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 +void wacom_setup_device_quirks(struct wacom_features *features);
 +int wacom_setup_input_capabilities(struct input_dev *input_dev,
  				   struct wacom_wac *wacom_wac);
 -int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
 -				       struct wacom_wac *wacom_wac);
 -void wacom_wac_usage_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage);
 -int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
 -		struct hid_usage *usage, __s32 value);
 -void wacom_wac_report(struct hid_device *hdev, struct hid_report *report);
 -void wacom_battery_work(struct work_struct *work);
 -int wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial,
 -				   int index);
 -void wacom_remote_destroy_attr_group(struct wacom *wacom, __u32 serial);
  #endif
diff --cc drivers/hid/wacom_sys.c
index e75b5002a526,c08a7522fdb9..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -987,8 -966,8 +1026,13 @@@ static int wacom_initialize_leds(struc
  		wacom->led.llv = 10;
  		wacom->led.hlv = 20;
  		wacom->led.img_lum = 10;
++<<<<<<< HEAD
 +		error = sysfs_create_group(&wacom->intf->dev.kobj,
 +					   &intuos4_led_attr_group);
++=======
+ 		error = wacom_devm_sysfs_create_group(wacom,
+ 						      &intuos4_led_attr_group);
++>>>>>>> 2df68a886488 (HID: wacom: convert LEDs to devres)
  		break;
  
  	case WACOM_24HD:
@@@ -999,8 -978,8 +1043,13 @@@
  		wacom->led.hlv = 0;
  		wacom->led.img_lum = 0;
  
++<<<<<<< HEAD
 +		error = sysfs_create_group(&wacom->intf->dev.kobj,
 +					   &cintiq_led_attr_group);
++=======
+ 		error = wacom_devm_sysfs_create_group(wacom,
+ 						      &cintiq_led_attr_group);
++>>>>>>> 2df68a886488 (HID: wacom: convert LEDs to devres)
  		break;
  
  	case INTUOS5S:
@@@ -1009,17 -988,14 +1058,22 @@@
  	case INTUOSPS:
  	case INTUOSPM:
  	case INTUOSPL:
 -		wacom->led.select[0] = 0;
 -		wacom->led.select[1] = 0;
 -		wacom->led.llv = 32;
 -		wacom->led.hlv = 0;
 -		wacom->led.img_lum = 0;
 -
 +		if (wacom->wacom_wac.features.device_type == BTN_TOOL_PEN) {
 +			wacom->led.select[0] = 0;
 +			wacom->led.select[1] = 0;
 +			wacom->led.llv = 32;
 +			wacom->led.hlv = 0;
 +			wacom->led.img_lum = 0;
 +
++<<<<<<< HEAD
 +			error = sysfs_create_group(&wacom->intf->dev.kobj,
 +						  &intuos5_led_attr_group);
 +		} else
 +			return 0;
++=======
+ 		error = wacom_devm_sysfs_create_group(wacom,
+ 						      &intuos5_led_attr_group);
++>>>>>>> 2df68a886488 (HID: wacom: convert LEDs to devres)
  		break;
  
  	default:
@@@ -1037,41 -1012,10 +1090,44 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void wacom_destroy_leds(struct wacom *wacom)
 +{
 +	if (!wacom->led_initialized)
 +		return;
 +
 +	wacom->led_initialized = false;
 +
 +	switch (wacom->wacom_wac.features.type) {
 +	case INTUOS4S:
 +	case INTUOS4:
 +	case INTUOS4L:
 +		sysfs_remove_group(&wacom->intf->dev.kobj,
 +				   &intuos4_led_attr_group);
 +		break;
 +
 +	case WACOM_24HD:
 +	case WACOM_21UX2:
 +		sysfs_remove_group(&wacom->intf->dev.kobj,
 +				   &cintiq_led_attr_group);
 +		break;
 +
 +	case INTUOS5S:
 +	case INTUOS5:
 +	case INTUOS5L:
 +	case INTUOSPS:
 +	case INTUOSPM:
 +	case INTUOSPL:
 +		if (wacom->wacom_wac.features.device_type == BTN_TOOL_PEN)
 +			sysfs_remove_group(&wacom->intf->dev.kobj,
 +					   &intuos5_led_attr_group);
 +		break;
 +	}
 +}
 +
++=======
++>>>>>>> 2df68a886488 (HID: wacom: convert LEDs to devres)
  static enum power_supply_property wacom_battery_props[] = {
 -	POWER_SUPPLY_PROP_PRESENT,
 -	POWER_SUPPLY_PROP_STATUS,
 -	POWER_SUPPLY_PROP_SCOPE,
  	POWER_SUPPLY_PROP_CAPACITY
  };
  
@@@ -1293,10 -1505,334 +1349,338 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -void wacom_battery_work(struct work_struct *work)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct wacom *wacom = container_of(work, struct wacom, battery_work);
+ 
+ 	if ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 	     !wacom->battery) {
+ 		wacom_initialize_battery(wacom);
+ 	}
+ 	else if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery) {
+ 		wacom_destroy_battery(wacom);
+ 	}
+ }
+ 
+ static size_t wacom_compute_pktlen(struct hid_device *hdev)
+ {
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom, const char *suffix)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	char name[WACOM_NAME_MAX];
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(name, wacom->hdev->name, sizeof(name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (name[strlen(name)-1] == ' ')
+ 				name[strlen(name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(name, sizeof(name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(name, features->name, sizeof(name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),
+ 		"%s%s Pen", name, suffix);
+ 	snprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),
+ 		"%s%s Finger", name, suffix);
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s%s Pad", name, suffix);
+ }
+ 
+ static void wacom_release_resources(struct wacom *wacom)
+ {
+ 	struct hid_device *hdev = wacom->hdev;
+ 
+ 	if (!wacom->resources)
+ 		return;
+ 
+ 	devres_release_group(&hdev->dev, wacom);
+ 
+ 	wacom->resources = false;
+ 
+ 	wacom->wacom_wac.pen_input = NULL;
+ 	wacom->wacom_wac.touch_input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ }
+ 
+ static int wacom_parse_and_register(struct wacom *wacom, bool wireless)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	struct hid_device *hdev = wacom->hdev;
+ 	int error;
+ 	unsigned int connect_mask = HID_CONNECT_HIDRAW;
+ 
+ 	features->pktlen = wacom_compute_pktlen(hdev);
+ 	if (features->pktlen > WACOM_PKGLEN_MAX)
+ 		return -EINVAL;
+ 
+ 	if (!devres_open_group(&hdev->dev, wacom, GFP_KERNEL))
+ 		return -ENOMEM;
+ 
+ 	wacom->resources = true;
+ 
+ 	error = wacom_allocate_inputs(wacom);
+ 	if (error)
+ 		goto fail_open_group;
+ 
+ 	/*
+ 	 * Bamboo Pad has a generic hid handling for the Pen, and we switch it
+ 	 * into debug mode for the touch part.
+ 	 * We ignore the other interfaces.
+ 	 */
+ 	if (features->type == BAMBOO_PAD) {
+ 		if (features->pktlen == WACOM_PKGLEN_PENABLED) {
+ 			features->type = HID_GENERIC;
+ 		} else if ((features->pktlen != WACOM_PKGLEN_BPAD_TOUCH) &&
+ 			   (features->pktlen != WACOM_PKGLEN_BPAD_TOUCH_USB)) {
+ 			error = -ENODEV;
+ 			goto fail_allocate_inputs;
+ 		}
+ 	}
+ 
+ 	/* set the default size in case we do not get them from hid */
+ 	wacom_set_default_phy(features);
+ 
+ 	/* Retrieve the physical and logical size for touch devices */
+ 	wacom_retrieve_hid_descriptor(hdev, features);
+ 	wacom_setup_device_quirks(wacom);
+ 
+ 	if (features->device_type == WACOM_DEVICETYPE_NONE &&
+ 	    features->type != WIRELESS) {
+ 		error = features->type == HID_GENERIC ? -ENODEV : 0;
+ 
+ 		dev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",
+ 			 hdev->name,
+ 			 error ? "Ignoring" : "Assuming pen");
+ 
+ 		if (error)
+ 			goto fail_parsed;
+ 
+ 		features->device_type |= WACOM_DEVICETYPE_PEN;
+ 	}
+ 
+ 	wacom_calculate_res(features);
+ 
+ 	wacom_update_name(wacom, wireless ? " (WL)" : "");
+ 
+ 	error = wacom_add_shared_data(hdev);
+ 	if (error)
+ 		goto fail_shared_data;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_WL_MONITOR) &&
+ 	     (features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail_battery;
+ 	}
+ 
+ 	error = wacom_register_inputs(wacom);
+ 	if (error)
+ 		goto fail_register_inputs;
+ 
+ 	if (wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD) {
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail_leds;
+ 
+ 		error = wacom_initialize_remote(wacom);
+ 		if (error)
+ 			goto fail_remote;
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		connect_mask |= HID_CONNECT_DRIVER;
+ 
+ 	/* Regular HID work starts now */
+ 	error = hid_hw_start(hdev, connect_mask);
+ 	if (error) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto fail_hw_start;
+ 	}
+ 
+ 	if (!wireless) {
+ 		/* Note that if query fails it is not a hard failure */
+ 		wacom_query_tablet_data(hdev, features);
+ 	}
+ 
+ 	/* touch only Bamboo doesn't support pen */
+ 	if ((features->type == BAMBOO_TOUCH) &&
+ 	    (features->device_type & WACOM_DEVICETYPE_PEN)) {
+ 		error = -ENODEV;
+ 		goto fail_quirks;
+ 	}
+ 
+ 	/* pen only Bamboo neither support touch nor pad */
+ 	if ((features->type == BAMBOO_PEN) &&
+ 	    ((features->device_type & WACOM_DEVICETYPE_TOUCH) ||
+ 	    (features->device_type & WACOM_DEVICETYPE_PAD))) {
+ 		error = -ENODEV;
+ 		goto fail_quirks;
+ 	}
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)
+ 		error = hid_hw_open(hdev);
+ 
+ 	if ((wacom_wac->features.type == INTUOSHT ||
+ 	     wacom_wac->features.type == INTUOSHT2) &&
+ 	    (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)) {
+ 		wacom_wac->shared->type = wacom_wac->features.type;
+ 		wacom_wac->shared->touch_input = wacom_wac->touch_input;
+ 	}
+ 
+ 	devres_close_group(&hdev->dev, wacom);
+ 
+ 	return 0;
+ 
+ fail_quirks:
+ 	hid_hw_stop(hdev);
+ fail_hw_start:
+ 	kobject_put(wacom->remote_dir);
+ fail_remote:
+ fail_leds:
+ fail_register_inputs:
+ fail_battery:
+ 	wacom_remove_shared_data(wacom);
+ fail_shared_data:
+ fail_parsed:
+ fail_allocate_inputs:
+ fail_open_group:
+ 	wacom_release_resources(wacom);
+ 	return error;
+ }
+ 
+ static void wacom_wireless_work(struct work_struct *work)
+ {
+ 	struct wacom *wacom = container_of(work, struct wacom, wireless_work);
+ 	struct usb_device *usbdev = wacom->usbdev;
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_device *hdev1, *hdev2;
+ 	struct wacom *wacom1, *wacom2;
+ 	struct wacom_wac *wacom_wac1, *wacom_wac2;
+ 	int error;
+ 
+ 	/*
+ 	 * Regardless if this is a disconnect or a new tablet,
+ 	 * remove any existing input and battery devices.
+ 	 */
+ 
+ 	wacom_destroy_battery(wacom);
+ 
+ 	/* Stylus interface */
+ 	hdev1 = usb_get_intfdata(usbdev->config->interface[1]);
+ 	wacom1 = hid_get_drvdata(hdev1);
+ 	wacom_wac1 = &(wacom1->wacom_wac);
+ 	wacom_release_resources(wacom1);
+ 
+ 	/* Touch interface */
+ 	hdev2 = usb_get_intfdata(usbdev->config->interface[2]);
+ 	wacom2 = hid_get_drvdata(hdev2);
+ 	wacom_wac2 = &(wacom2->wacom_wac);
+ 	wacom_release_resources(wacom2);
+ 
+ 	if (wacom_wac->pid == 0) {
+ 		hid_info(wacom->hdev, "wireless tablet disconnected\n");
+ 		wacom_wac1->shared->type = 0;
+ 	} else {
+ 		const struct hid_device_id *id = wacom_ids;
+ 
+ 		hid_info(wacom->hdev, "wireless tablet connected with PID %x\n",
+ 			 wacom_wac->pid);
+ 
+ 		while (id->bus) {
+ 			if (id->vendor == USB_VENDOR_ID_WACOM &&
+ 			    id->product == wacom_wac->pid)
+ 				break;
+ 			id++;
+ 		}
+ 
+ 		if (!id->bus) {
+ 			hid_info(wacom->hdev, "ignoring unknown PID.\n");
+ 			return;
+ 		}
+ 
+ 		/* Stylus interface */
+ 		wacom_wac1->features =
+ 			*((struct wacom_features *)id->driver_data);
+ 
+ 		wacom_wac1->pid = wacom_wac->pid;
+ 		hid_hw_stop(hdev1);
+ 		error = wacom_parse_and_register(wacom1, true);
+ 		if (error)
+ 			goto fail;
+ 
+ 		/* Touch interface */
+ 		if (wacom_wac1->features.touch_max ||
+ 		    (wacom_wac1->features.type >= INTUOSHT &&
+ 		    wacom_wac1->features.type <= BAMBOO_PT)) {
+ 			wacom_wac2->features =
+ 				*((struct wacom_features *)id->driver_data);
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			hid_hw_stop(hdev2);
+ 			error = wacom_parse_and_register(wacom2, true);
+ 			if (error)
+ 				goto fail;
+ 		}
+ 
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	return;
+ 
+ fail:
+ 	wacom_release_resources(wacom1);
+ 	wacom_release_resources(wacom2);
+ 	return;
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> 2df68a886488 (HID: wacom: convert LEDs to devres)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
@@@ -1435,22 -1899,25 +1819,35 @@@
  	return error;
  }
  
 -static void wacom_remove(struct hid_device *hdev)
 +static void wacom_disconnect(struct usb_interface *intf)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct wacom_features *features = &wacom_wac->features;
 +	struct wacom *wacom = usb_get_intfdata(intf);
  
 -	if (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)
 -		hid_hw_close(hdev);
 +	usb_set_intfdata(intf, NULL);
  
++<<<<<<< HEAD
 +	usb_kill_urb(wacom->irq);
 +	cancel_work_sync(&wacom->work);
 +	if (wacom->wacom_wac.input)
 +		input_unregister_device(wacom->wacom_wac.input);
 +	wacom_destroy_battery(wacom);
 +	wacom_destroy_leds(wacom);
 +	usb_free_urb(wacom->irq);
 +	usb_free_coherent(interface_to_usbdev(intf), WACOM_PKGLEN_MAX,
 +			wacom->wacom_wac.data, wacom->data_dma);
 +	wacom_remove_shared_data(&wacom->wacom_wac);
++=======
+ 	hid_hw_stop(hdev);
+ 
+ 	cancel_work_sync(&wacom->wireless_work);
+ 	cancel_work_sync(&wacom->battery_work);
+ 	kobject_put(wacom->remote_dir);
+ 	if (hdev->bus == BUS_BLUETOOTH)
+ 		device_remove_file(&hdev->dev, &dev_attr_speed);
+ 	wacom_remove_shared_data(wacom);
+ 
+ 	hid_set_drvdata(hdev, NULL);
++>>>>>>> 2df68a886488 (HID: wacom: convert LEDs to devres)
  	kfree(wacom);
  }
  
* Unmerged path drivers/hid/wacom.h
* Unmerged path drivers/hid/wacom_sys.c
