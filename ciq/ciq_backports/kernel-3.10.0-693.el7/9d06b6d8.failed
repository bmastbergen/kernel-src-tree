bridge: mdb: Separate br_mdb_entry->state from net_bridge_port_group->state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Elad Raz <eladr@mellanox.com>
commit 9d06b6d8a3fcba8eb8e1c62c92942452afea8057
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9d06b6d8.failed

Change net_bridge_port_group 'state' member to 'flags' and define new set
of flags internal to the kernel.

	Signed-off-by: Elad Raz <eladr@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9d06b6d8a3fcba8eb8e1c62c92942452afea8057)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_mdb.c
index 66d85f7b04f3,5312570e79fa..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -84,7 -93,8 +92,12 @@@ static int br_mdb_fill_info(struct sk_b
  					struct br_mdb_entry e;
  					memset(&e, 0, sizeof(e));
  					e.ifindex = port->dev->ifindex;
++<<<<<<< HEAD
 +					e.state = p->state;
++=======
+ 					e.vid = p->addr.vid;
+ 					__mdb_entry_fill_flags(&e, p->flags);
++>>>>>>> 9d06b6d8a3fc (bridge: mdb: Separate br_mdb_entry->state from net_bridge_port_group->state)
  					if (p->addr.proto == htons(ETH_P_IP))
  						e.addr.u.ip4 = p->addr.u.ip4;
  #if IS_ENABLED(CONFIG_IPV6)
@@@ -252,7 -262,7 +265,11 @@@ errout
  }
  
  void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
++<<<<<<< HEAD
 +		   struct br_ip *group, int type)
++=======
+ 		   struct br_ip *group, int type, u8 flags)
++>>>>>>> 9d06b6d8a3fc (bridge: mdb: Separate br_mdb_entry->state from net_bridge_port_group->state)
  {
  	struct br_mdb_entry entry;
  
@@@ -263,6 -273,8 +280,11 @@@
  #if IS_ENABLED(CONFIG_IPV6)
  	entry.addr.u.ip6 = group->u.ip6;
  #endif
++<<<<<<< HEAD
++=======
+ 	entry.vid = group->vid;
+ 	__mdb_entry_fill_flags(&entry, flags);
++>>>>>>> 9d06b6d8a3fc (bridge: mdb: Separate br_mdb_entry->state from net_bridge_port_group->state)
  	__br_mdb_notify(dev, &entry, type);
  }
  
diff --cc net/bridge/br_multicast.c
index e267dc359e3a,d156491ee4e8..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -694,7 -706,7 +694,11 @@@ static int br_multicast_add_group(struc
  	if (unlikely(!p))
  		goto err;
  	rcu_assign_pointer(*pp, p);
++<<<<<<< HEAD
 +	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
++=======
+ 	br_mdb_notify(br->dev, port, group, RTM_NEWMDB, 0);
++>>>>>>> 9d06b6d8a3fc (bridge: mdb: Separate br_mdb_entry->state from net_bridge_port_group->state)
  
  found:
  	mod_timer(&p->timer, now + br->multicast_membership_interval);
@@@ -946,11 -975,13 +950,11 @@@ void br_multicast_disable_port(struct n
  
  	spin_lock(&br->multicast_lock);
  	hlist_for_each_entry_safe(pg, n, &port->mglist, mglist)
- 		if (pg->state == MDB_TEMPORARY)
+ 		if (!(pg->flags & MDB_PG_FLAGS_PERMANENT))
  			br_multicast_del_pg(br, pg);
  
 -	if (!hlist_unhashed(&port->rlist)) {
 +	if (!hlist_unhashed(&port->rlist))
  		hlist_del_init_rcu(&port->rlist);
 -		br_rtr_notify(br->dev, port, RTM_DELMDB);
 -	}
  	del_timer(&port->multicast_router_timer);
  	del_timer(&port->ip4_own_query.timer);
  #if IS_ENABLED(CONFIG_IPV6)
@@@ -1365,7 -1453,8 +1369,12 @@@ br_multicast_leave_group(struct net_bri
  			hlist_del_init(&p->mglist);
  			del_timer(&p->timer);
  			call_rcu_bh(&p->rcu, br_multicast_free_pg);
++<<<<<<< HEAD
 +			br_mdb_notify(br->dev, port, group, RTM_DELMDB);
++=======
+ 			br_mdb_notify(br->dev, port, group, RTM_DELMDB,
+ 				      p->flags);
++>>>>>>> 9d06b6d8a3fc (bridge: mdb: Separate br_mdb_entry->state from net_bridge_port_group->state)
  
  			if (!mp->ports && !mp->mglist &&
  			    netif_running(br->dev))
diff --cc net/bridge/br_private.h
index b75519ca3c51,67f4dce3c3d2..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -479,12 -556,14 +482,23 @@@ br_multicast_new_group(struct net_bridg
  void br_multicast_free_pg(struct rcu_head *head);
  struct net_bridge_port_group *
  br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
++<<<<<<< HEAD
 +			    struct net_bridge_port_group *next,
 +			    unsigned char state);
 +void br_mdb_init(void);
 +void br_mdb_uninit(void);
 +void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 +		   struct br_ip *group, int type);
++=======
+ 			    struct net_bridge_port_group __rcu *next,
+ 			    unsigned char flags);
+ void br_mdb_init(void);
+ void br_mdb_uninit(void);
+ void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
+ 		   struct br_ip *group, int type, u8 flags);
+ void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
+ 		   int type);
++>>>>>>> 9d06b6d8a3fc (bridge: mdb: Separate br_mdb_entry->state from net_bridge_port_group->state)
  
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
* Unmerged path net/bridge/br_mdb.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
