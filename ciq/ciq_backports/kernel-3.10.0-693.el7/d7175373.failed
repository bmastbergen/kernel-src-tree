target: fix ALUA transition timeout handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [target] fix ALUA transition timeout handling (Mike Christie) [1429008 1407016]
Rebuild_FUZZ: 90.00%
commit-author Mike Christie <mchristi@redhat.com>
commit d7175373f2745ed4abe5b388d5aabd06304f801e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d7175373.failed

The implicit transition time tells initiators the min time
to wait before timing out a transition. We currently schedule
the transition to occur in tg_pt_gp_implicit_trans_secs
seconds so there is no room for delays. If
core_alua_do_transition_tg_pt_work->core_alua_update_tpg_primary_metadata
needs to write out info to a remote file, then the initiator can
easily time out the operation.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit d7175373f2745ed4abe5b388d5aabd06304f801e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_alua.c
diff --cc drivers/target/target_core_alua.c
index 4483cd8d504a,594807cd92cb..000000000000
--- a/drivers/target/target_core_alua.c
+++ b/drivers/target/target_core_alua.c
@@@ -1007,27 -995,29 +1007,40 @@@ static void core_alua_do_transition_tg_
  			 * se_deve->se_lun_acl pointer may be NULL for a
  			 * entry created without explicit Node+MappedLUN ACLs
  			 */
 -			if (lacl && (tg_pt_gp->tg_pt_gp_alua_nacl != NULL) &&
 -			    (tg_pt_gp->tg_pt_gp_alua_nacl == lacl->se_lun_nacl))
 +			if (!lacl)
 +				continue;
 +
 +			if ((tg_pt_gp->tg_pt_gp_alua_access_status ==
 +			     ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG) &&
 +			   (tg_pt_gp->tg_pt_gp_alua_nacl != NULL) &&
 +			    (tg_pt_gp->tg_pt_gp_alua_nacl == lacl->se_lun_nacl) &&
 +			   (tg_pt_gp->tg_pt_gp_alua_port != NULL) &&
 +			    (tg_pt_gp->tg_pt_gp_alua_port == port))
  				continue;
  
 -			core_scsi3_ua_allocate(se_deve, 0x2A,
 +			core_scsi3_ua_allocate(lacl->se_lun_nacl,
 +				se_deve->mapped_lun, 0x2A,
  				ASCQ_2AH_ASYMMETRIC_ACCESS_STATE_CHANGED);
  		}
 -		spin_unlock(&lun->lun_deve_lock);
 +		spin_unlock_bh(&port->sep_alua_lock);
  
  		spin_lock(&tg_pt_gp->tg_pt_gp_lock);
 -		percpu_ref_put(&lun->lun_ref);
 +		atomic_dec_mb(&mem->tg_pt_gp_mem_ref_cnt);
  	}
  	spin_unlock(&tg_pt_gp->tg_pt_gp_lock);
++<<<<<<< HEAD
++=======
+ }
+ 
+ static void core_alua_do_transition_tg_pt_work(struct work_struct *work)
+ {
+ 	struct t10_alua_tg_pt_gp *tg_pt_gp = container_of(work,
+ 		struct t10_alua_tg_pt_gp, tg_pt_gp_transition_work);
+ 	struct se_device *dev = tg_pt_gp->tg_pt_gp_dev;
+ 	bool explicit = (tg_pt_gp->tg_pt_gp_alua_access_status ==
+ 			 ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG);
+ 
++>>>>>>> d7175373f274 (target: fix ALUA transition timeout handling)
  	/*
  	 * Update the ALUA metadata buf that has been allocated in
  	 * core_alua_do_port_transition(), this metadata will be written
* Unmerged path drivers/target/target_core_alua.c
diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h
index 985ca4c907fe..f5ffca229998 100644
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@ -328,7 +328,7 @@ struct t10_alua_tg_pt_gp {
 	struct list_head tg_pt_gp_mem_list;
 	struct se_port *tg_pt_gp_alua_port;
 	struct se_node_acl *tg_pt_gp_alua_nacl;
-	struct delayed_work tg_pt_gp_transition_work;
+	struct work_struct tg_pt_gp_transition_work;
 	struct completion *tg_pt_gp_transition_complete;
 };
 
