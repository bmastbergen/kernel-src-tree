btrfs: don't run delayed references while we are creating the free space tree

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Chris Mason <clm@fb.com>
commit 511711af91f21d80b27f18b569352d6896562828
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/511711af.failed

This is a short term solution to make sure btrfs_run_delayed_refs()
doesn't change the extent tree while we are scanning it to create the
free space tree.

Longer term we need to synchronize scanning the block groups one by one,
similar to what happens during a balance.

	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 511711af91f21d80b27f18b569352d6896562828)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/disk-io.c
diff --cc fs/btrfs/disk-io.c
index bd7a1d01f11d,dc6b73a95342..000000000000
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@@ -3101,6 -3102,18 +3113,21 @@@ retry_root_backup
  
  	btrfs_qgroup_rescan_resume(fs_info);
  
++<<<<<<< HEAD
++=======
+ 	if (btrfs_test_opt(tree_root, CLEAR_CACHE) &&
+ 	    btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {
+ 		pr_info("BTRFS: clearing free space tree\n");
+ 		ret = btrfs_clear_free_space_tree(fs_info);
+ 		if (ret) {
+ 			pr_warn("BTRFS: failed to clear free space tree %d\n",
+ 				ret);
+ 			close_ctree(tree_root);
+ 			return ret;
+ 		}
+ 	}
+ 
++>>>>>>> 511711af91f2 (btrfs: don't run delayed references while we are creating the free space tree)
  	if (!fs_info->uuid_root) {
  		pr_info("BTRFS: creating UUID tree\n");
  		ret = btrfs_create_uuid_tree(fs_info);
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index f5bb492fb7ad..c4445071f881 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -1850,6 +1850,8 @@ struct btrfs_fs_info {
 	 * and will be latter freed. Protected by fs_info->chunk_mutex.
 	 */
 	struct list_head pinned_chunks;
+
+	int creating_free_space_tree;
 };
 
 struct btrfs_subvolume_writers {
* Unmerged path fs/btrfs/disk-io.c
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index a71ed9b2925a..a72b69724966 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -2910,6 +2910,9 @@ int btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,
 	if (trans->aborted)
 		return 0;
 
+	if (root->fs_info->creating_free_space_tree)
+		return 0;
+
 	if (root == root->fs_info->extent_root)
 		root = root->fs_info->tree_root;
 
diff --git a/fs/btrfs/free-space-tree.c b/fs/btrfs/free-space-tree.c
index cbe36dd0d97b..393e36bd5845 100644
--- a/fs/btrfs/free-space-tree.c
+++ b/fs/btrfs/free-space-tree.c
@@ -1067,6 +1067,8 @@ static int populate_free_space_tree(struct btrfs_trans_handle *trans,
 	if (ret)
 		goto out;
 
+	mutex_lock(&block_group->free_space_lock);
+
 	/*
 	 * Iterate through all of the extent and metadata items in this block
 	 * group, adding the free space between them and the free space at the
@@ -1080,7 +1082,7 @@ static int populate_free_space_tree(struct btrfs_trans_handle *trans,
 
 	ret = btrfs_search_slot_for_read(extent_root, &key, path, 1, 0);
 	if (ret < 0)
-		goto out;
+		goto out_locked;
 	ASSERT(ret == 0);
 
 	start = block_group->key.objectid;
@@ -1100,7 +1102,7 @@ static int populate_free_space_tree(struct btrfs_trans_handle *trans,
 							       key.objectid -
 							       start);
 				if (ret)
-					goto out;
+					goto out_locked;
 			}
 			start = key.objectid;
 			if (key.type == BTRFS_METADATA_ITEM_KEY)
@@ -1114,7 +1116,7 @@ static int populate_free_space_tree(struct btrfs_trans_handle *trans,
 
 		ret = btrfs_next_item(extent_root, path);
 		if (ret < 0)
-			goto out;
+			goto out_locked;
 		if (ret)
 			break;
 	}
@@ -1122,10 +1124,12 @@ static int populate_free_space_tree(struct btrfs_trans_handle *trans,
 		ret = __add_to_free_space_tree(trans, fs_info, block_group,
 					       path2, start, end - start);
 		if (ret)
-			goto out;
+			goto out_locked;
 	}
 
 	ret = 0;
+out_locked:
+	mutex_unlock(&block_group->free_space_lock);
 out:
 	btrfs_free_path(path2);
 	btrfs_free_path(path);
@@ -1145,6 +1149,7 @@ int btrfs_create_free_space_tree(struct btrfs_fs_info *fs_info)
 	if (IS_ERR(trans))
 		return PTR_ERR(trans);
 
+	fs_info->creating_free_space_tree = 1;
 	free_space_root = btrfs_create_tree(trans, fs_info,
 					    BTRFS_FREE_SPACE_TREE_OBJECTID);
 	if (IS_ERR(free_space_root)) {
@@ -1164,6 +1169,7 @@ int btrfs_create_free_space_tree(struct btrfs_fs_info *fs_info)
 	}
 
 	btrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE);
+	fs_info->creating_free_space_tree = 0;
 
 	ret = btrfs_commit_transaction(trans, tree_root);
 	if (ret)
@@ -1172,6 +1178,7 @@ int btrfs_create_free_space_tree(struct btrfs_fs_info *fs_info)
 	return 0;
 
 abort:
+	fs_info->creating_free_space_tree = 0;
 	btrfs_abort_transaction(trans, tree_root, ret);
 	btrfs_end_transaction(trans, tree_root);
 	return ret;
