mei: amthif: fix deadlock in initialization during a reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit e728ae271f4cf71218ec06a6daf61b79466cb466
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e728ae27.failed

The device lock was unnecessary obtained in bus rescan work before the
amthif client search.  That causes incorrect lock ordering and task
hang:
...
[88004.613213] INFO: task kworker/1:14:21832 blocked for more than 120 seconds.
...
[88004.645934] Workqueue: events mei_cl_bus_rescan_work
...

The correct lock order is
 cl_bus_lock
  device_lock
   me_clients_rwsem

Move device_lock into amthif init function that called
after me_clients_rwsem is released.

This fixes regression introduced by commit:
commit 025fb792bac3 ("mei: split amthif client init from end of clients enumeration")

	Cc: <stable@vger.kernel.org> # 4.6+
	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit e728ae271f4cf71218ec06a6daf61b79466cb466)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/bus.c
diff --cc drivers/misc/mei/amthif.c
index 2b49e28c1122,082462ea90c9..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -68,20 -66,27 +68,35 @@@ int mei_amthif_host_init(struct mei_dev
  	struct mei_cl *cl = &dev->iamthif_cl;
  	int ret;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&dev->device_lock);
+ 
+ 	if (mei_cl_is_connected(cl)) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 
++>>>>>>> e728ae271f4c (mei: amthif: fix deadlock in initialization during a reset)
  	dev->iamthif_state = MEI_IAMTHIF_IDLE;
  
  	mei_cl_init(cl, dev);
  
 -	ret = mei_cl_link(cl);
 +	ret = mei_cl_link(cl, MEI_IAMTHIF_HOST_CLIENT_ID);
  	if (ret < 0) {
  		dev_err(dev->dev, "amthif: failed cl_link %d\n", ret);
- 		return ret;
+ 		goto out;
  	}
  
  	ret = mei_cl_connect(cl, me_cl, NULL);
  
++<<<<<<< HEAD
 +	dev->iamthif_state = MEI_IAMTHIF_IDLE;
 +
++=======
+ out:
+ 	mutex_unlock(&dev->device_lock);
++>>>>>>> e728ae271f4c (mei: amthif: fix deadlock in initialization during a reset)
  	return ret;
  }
  
diff --cc drivers/misc/mei/bus.c
index 66c920a236b3,8cac7ef9ad0d..000000000000
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@@ -982,6 -982,12 +982,15 @@@ void mei_cl_bus_rescan_work(struct work
  {
  	struct mei_device *bus =
  		container_of(work, struct mei_device, bus_rescan_work);
++<<<<<<< HEAD
++=======
+ 	struct mei_me_client *me_cl;
+ 
+ 	me_cl = mei_me_cl_by_uuid(bus, &mei_amthif_guid);
+ 	if (me_cl)
+ 		mei_amthif_host_init(bus, me_cl);
+ 	mei_me_cl_put(me_cl);
++>>>>>>> e728ae271f4c (mei: amthif: fix deadlock in initialization during a reset)
  
  	mei_cl_bus_rescan(bus);
  }
* Unmerged path drivers/misc/mei/amthif.c
* Unmerged path drivers/misc/mei/bus.c
