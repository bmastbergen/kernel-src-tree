locks: __break_lease cleanup in preparation of allowing direct removal of leases

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jeff Layton <jlayton@primarydata.com>
commit 03d12ddf845a4eb874ffa558d65a548aee9b715b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/03d12ddf.failed

Eliminate an unneeded "flock" variable. We can use "fl" as a loop cursor
everywhere. Add a any_leases_conflict helper function as well to
consolidate a bit of code.

	Signed-off-by: Jeff Layton <jlayton@primarydata.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 03d12ddf845a4eb874ffa558d65a548aee9b715b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
diff --cc fs/locks.c
index 698f674a522a,7d627ac0ed87..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -1345,11 -1381,11 +1359,10 @@@ any_leases_conflict(struct inode *inode
  int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)
  {
  	int error = 0;
- 	struct file_lock *new_fl, *flock;
+ 	struct file_lock *new_fl;
  	struct file_lock *fl;
  	unsigned long break_time;
- 	bool lease_conflict = false;
  	int want_write = (mode & O_ACCMODE) != O_RDONLY;
 -	LIST_HEAD(dispose);
  
  	new_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);
  	if (IS_ERR(new_fl))
@@@ -1358,19 -1394,9 +1371,9 @@@
  
  	spin_lock(&inode->i_lock);
  
 -	time_out_leases(inode, &dispose);
 +	time_out_leases(inode);
  
- 	flock = inode->i_flock;
- 	if ((flock == NULL) || !IS_LEASE(flock))
- 		goto out;
- 
- 	for (fl = flock; fl && IS_LEASE(fl); fl = fl->fl_next) {
- 		if (leases_conflict(fl, new_fl)) {
- 			lease_conflict = true;
- 			break;
- 		}
- 	}
- 	if (!lease_conflict)
+ 	if (!any_leases_conflict(inode, new_fl))
  		goto out;
  
  	break_time = 0;
@@@ -1409,17 -1435,16 +1412,20 @@@ restart
  		break_time -= jiffies;
  	if (break_time == 0)
  		break_time++;
- 	locks_insert_block(flock, new_fl);
+ 	locks_insert_block(inode->i_flock, new_fl);
  	trace_break_lease_block(inode, new_fl);
  	spin_unlock(&inode->i_lock);
 -	locks_dispose_list(&dispose);
  	error = wait_event_interruptible_timeout(new_fl->fl_wait,
  						!new_fl->fl_next, break_time);
  	spin_lock(&inode->i_lock);
  	trace_break_lease_unblock(inode, new_fl);
  	locks_delete_block(new_fl);
  	if (error >= 0) {
++<<<<<<< HEAD
 +		if (error == 0)
 +			time_out_leases(inode);
++=======
++>>>>>>> 03d12ddf845a (locks: __break_lease cleanup in preparation of allowing direct removal of leases)
  		/*
  		 * Wait for the next conflicting lease that has not been
  		 * broken yet
* Unmerged path fs/locks.c
