amd-xgbe: Fix IRQ processing when running in single IRQ mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 896b4db685cf06bd7d50ed22c53ebd069e0b90e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/896b4db6.failed

When running in single IRQ mode, the additional IRQ routines were being
skipped because only the XGMAC interrupt status was being checked.
Update the code so that the additional IRQ routines are checked whenever
an interrupt is received.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 896b4db685cf06bd7d50ed22c53ebd069e0b90e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index d58e85811bc9,9943629fcbf9..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -254,13 -511,47 +254,19 @@@ static irqreturn_t xgbe_isr(int irq, vo
  
  		if (XGMAC_GET_BITS(mac_isr, MAC_ISR, MMCRXIS))
  			hw_if->rx_mmc_int(pdata);
 -
 -		if (XGMAC_GET_BITS(mac_isr, MAC_ISR, TSIS)) {
 -			mac_tssr = XGMAC_IOREAD(pdata, MAC_TSSR);
 -
 -			netif_dbg(pdata, intr, pdata->netdev,
 -				  "MAC_TSSR=%#010x\n", mac_tssr);
 -
 -			if (XGMAC_GET_BITS(mac_tssr, MAC_TSSR, TXTSC)) {
 -				/* Read Tx Timestamp to clear interrupt */
 -				pdata->tx_tstamp =
 -					hw_if->get_tx_tstamp(pdata);
 -				queue_work(pdata->dev_workqueue,
 -					   &pdata->tx_tstamp_work);
 -			}
 -		}
 -
 -		if (XGMAC_GET_BITS(mac_isr, MAC_ISR, SMI)) {
 -			mac_mdioisr = XGMAC_IOREAD(pdata, MAC_MDIOISR);
 -
 -			netif_dbg(pdata, intr, pdata->netdev,
 -				  "MAC_MDIOISR=%#010x\n", mac_mdioisr);
 -
 -			if (XGMAC_GET_BITS(mac_mdioisr, MAC_MDIOISR,
 -					   SNGLCOMPINT))
 -				complete(&pdata->mdio_complete);
 -		}
  	}
  
++<<<<<<< HEAD
 +	DBGPR("  DMA_ISR = %08x\n", XGMAC_IOREAD(pdata, DMA_ISR));
++=======
+ isr_done:
+ 	/* If there is not a separate AN irq, handle it here */
+ 	if (pdata->dev_irq == pdata->an_irq)
+ 		pdata->phy_if.an_isr(irq, pdata);
++>>>>>>> 896b4db685cf (amd-xgbe: Fix IRQ processing when running in single IRQ mode)
  
 -	/* If there is not a separate ECC irq, handle it here */
 -	if (pdata->vdata->ecc_support && (pdata->dev_irq == pdata->ecc_irq))
 -		xgbe_ecc_isr(irq, pdata);
 -
 -	/* If there is not a separate I2C irq, handle it here */
 -	if (pdata->vdata->i2c_support && (pdata->dev_irq == pdata->i2c_irq))
 -		pdata->i2c_if.i2c_isr(irq, pdata);
 +	DBGPR("<--xgbe_isr\n");
  
- isr_done:
  	return IRQ_HANDLED;
  }
  
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
