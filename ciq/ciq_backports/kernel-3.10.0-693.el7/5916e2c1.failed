RDS: TCP: Enable multipath RDS for TCP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Sowmini Varadhan <sowmini.varadhan@oracle.com>
commit 5916e2c1554f3e36f770401c989c3c7fadf619ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5916e2c1.failed

Use RDS probe-ping to compute how many paths may be used with
the peer, and to synchronously start the multiple paths. If mprds is
supported, hash outgoing traffic to one of multiple paths in rds_sendmsg()
when multipath RDS is supported by the transport.

CC: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: Sowmini Varadhan <sowmini.varadhan@oracle.com>
	Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5916e2c1554f3e36f770401c989c3c7fadf619ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/connection.c
#	net/rds/rds.h
#	net/rds/send.c
#	net/rds/tcp_connect.c
#	net/rds/tcp_listen.c
#	net/rds/threads.c
diff --cc net/rds/connection.c
index 92b812312d9d,f5058559bb08..000000000000
--- a/net/rds/connection.c
+++ b/net/rds/connection.c
@@@ -127,11 -155,8 +127,15 @@@ static struct rds_connection *__rds_con
  	struct hlist_head *head = rds_conn_bucket(laddr, faddr);
  	struct rds_transport *loop_trans;
  	unsigned long flags;
++<<<<<<< HEAD
 +	int ret;
 +	struct rds_transport *otrans = trans;
++=======
+ 	int ret, i;
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  
 +	if (!is_outgoing && otrans->t_type == RDS_TRANS_TCP)
 +		goto new_conn;
  	rcu_read_lock();
  	conn = rds_conn_lookup(net, head, laddr, faddr, trans);
  	if (conn && conn->c_loopback && conn->c_trans != &rds_loop_transport &&
@@@ -632,10 -657,17 +642,15 @@@ void rds_conn_exit(void
  /*
   * Force a disconnect
   */
 -void rds_conn_path_drop(struct rds_conn_path *cp)
 -{
 -	atomic_set(&cp->cp_state, RDS_CONN_ERROR);
 -	queue_work(rds_wq, &cp->cp_down_w);
 -}
 -EXPORT_SYMBOL_GPL(rds_conn_path_drop);
 -
  void rds_conn_drop(struct rds_connection *conn)
  {
++<<<<<<< HEAD
 +	atomic_set(&conn->c_state, RDS_CONN_ERROR);
 +	queue_work(rds_wq, &conn->c_down_w);
++=======
+ 	WARN_ON(conn->c_trans->t_mp_capable);
+ 	rds_conn_path_drop(&conn->c_path[0]);
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  }
  EXPORT_SYMBOL_GPL(rds_conn_drop);
  
diff --cc net/rds/rds.h
index 8889455d9d7c,b2d17f0fafa8..000000000000
--- a/net/rds/rds.h
+++ b/net/rds/rds.h
@@@ -84,14 -84,60 +84,67 @@@ enum 
  #define RDS_IN_XMIT		2
  #define RDS_RECV_REFILL		3
  
++<<<<<<< HEAD
++=======
+ /* Max number of multipaths per RDS connection. Must be a power of 2 */
+ #define	RDS_MPATH_WORKERS	8
+ #define	RDS_MPATH_HASH(rs, n) (jhash_1word((rs)->rs_bound_port, \
+ 			       (rs)->rs_hash_initval) & ((n) - 1))
+ 
+ /* Per mpath connection state */
+ struct rds_conn_path {
+ 	struct rds_connection	*cp_conn;
+ 	struct rds_message	*cp_xmit_rm;
+ 	unsigned long		cp_xmit_sg;
+ 	unsigned int		cp_xmit_hdr_off;
+ 	unsigned int		cp_xmit_data_off;
+ 	unsigned int		cp_xmit_atomic_sent;
+ 	unsigned int		cp_xmit_rdma_sent;
+ 	unsigned int		cp_xmit_data_sent;
+ 
+ 	spinlock_t		cp_lock;		/* protect msg queues */
+ 	u64			cp_next_tx_seq;
+ 	struct list_head	cp_send_queue;
+ 	struct list_head	cp_retrans;
+ 
+ 	u64			cp_next_rx_seq;
+ 
+ 	void			*cp_transport_data;
+ 
+ 	atomic_t		cp_state;
+ 	unsigned long		cp_send_gen;
+ 	unsigned long		cp_flags;
+ 	unsigned long		cp_reconnect_jiffies;
+ 	struct delayed_work	cp_send_w;
+ 	struct delayed_work	cp_recv_w;
+ 	struct delayed_work	cp_conn_w;
+ 	struct work_struct	cp_down_w;
+ 	struct mutex		cp_cm_lock;	/* protect cp_state & cm */
+ 	wait_queue_head_t	cp_waitq;
+ 
+ 	unsigned int		cp_unacked_packets;
+ 	unsigned int		cp_unacked_bytes;
+ 	unsigned int		cp_outgoing:1,
+ 				cp_pad_to_32:31;
+ 	unsigned int		cp_index;
+ };
+ 
+ /* One rds_connection per RDS address pair */
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  struct rds_connection {
  	struct hlist_node	c_hash_node;
  	__be32			c_laddr;
  	__be32			c_faddr;
  	unsigned int		c_loopback:1,
++<<<<<<< HEAD
 +				c_outgoing:1,
 +				c_pad_to_32:30;
++=======
+ 				c_ping_triggered:1,
+ 				c_pad_to_32:30;
+ 	int			c_npaths;
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  	struct rds_connection	*c_passive;
 -	struct rds_transport	*c_trans;
  
  	struct rds_cong_map	*c_lcong;
  	struct rds_cong_map	*c_fcong;
@@@ -128,12 -149,8 +181,17 @@@
  	struct list_head	c_map_item;
  	unsigned long		c_map_queued;
  
++<<<<<<< HEAD
 +	unsigned int		c_unacked_packets;
 +	unsigned int		c_unacked_bytes;
 +
 +	/* Protocol version */
 +	unsigned int		c_version;
 +	possible_net_t		c_net;
++=======
+ 	struct rds_conn_path	c_path[RDS_MPATH_WORKERS];
+ 	wait_queue_head_t	c_hs_waitq; /* handshake waitq */
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  };
  
  static inline
diff --cc net/rds/send.c
index 283757171fc5,896626b9a0ef..000000000000
--- a/net/rds/send.c
+++ b/net/rds/send.c
@@@ -961,8 -963,30 +961,35 @@@ static int rds_cmsg_send(struct rds_soc
  	return ret;
  }
  
++<<<<<<< HEAD
 +int rds_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 +		size_t payload_len)
++=======
+ static void rds_send_ping(struct rds_connection *conn);
+ 
+ static int rds_send_mprds_hash(struct rds_sock *rs, struct rds_connection *conn)
+ {
+ 	int hash;
+ 
+ 	if (conn->c_npaths == 0)
+ 		hash = RDS_MPATH_HASH(rs, RDS_MPATH_WORKERS);
+ 	else
+ 		hash = RDS_MPATH_HASH(rs, conn->c_npaths);
+ 	if (conn->c_npaths == 0 && hash != 0) {
+ 		rds_send_ping(conn);
+ 
+ 		if (conn->c_npaths == 0) {
+ 			wait_event_interruptible(conn->c_hs_waitq,
+ 						 (conn->c_npaths != 0));
+ 		}
+ 		if (conn->c_npaths == 1)
+ 			hash = 0;
+ 	}
+ 	return hash;
+ }
+ 
+ int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  {
  	struct sock *sk = sock->sk;
  	struct rds_sock *rs = rds_sk_to_rs(sk);
diff --cc net/rds/tcp_connect.c
index a86fb96b1ae0,05f61c533ed3..000000000000
--- a/net/rds/tcp_connect.c
+++ b/net/rds/tcp_connect.c
@@@ -78,12 -78,19 +78,22 @@@ int rds_tcp_conn_connect(struct rds_con
  	struct socket *sock = NULL;
  	struct sockaddr_in src, dest;
  	int ret;
 -	struct rds_connection *conn = cp->cp_conn;
 -	struct rds_tcp_connection *tc = cp->cp_transport_data;
 +	struct rds_tcp_connection *tc = conn->c_transport_data;
  
++<<<<<<< HEAD
 +	mutex_lock(&tc->t_conn_lock);
++=======
+ 	/* for multipath rds,we only trigger the connection after
+ 	 * the handshake probe has determined the number of paths.
+ 	 */
+ 	if (cp->cp_index > 0 && cp->cp_conn->c_npaths < 2)
+ 		return -EAGAIN;
+ 
+ 	mutex_lock(&tc->t_conn_path_lock);
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  
 -	if (rds_conn_path_up(cp)) {
 -		mutex_unlock(&tc->t_conn_path_lock);
 +	if (rds_conn_up(conn)) {
 +		mutex_unlock(&tc->t_conn_lock);
  		return 0;
  	}
  	ret = sock_create_kern(rds_conn_net(conn), PF_INET,
diff --cc net/rds/tcp_listen.c
index ecfec7ecfd15,e0b23fb5b8d5..000000000000
--- a/net/rds/tcp_listen.c
+++ b/net/rds/tcp_listen.c
@@@ -118,11 -165,14 +164,22 @@@ int rds_tcp_accept_one(struct socket *s
  	 * If the client reboots, this conn will need to be cleaned up.
  	 * rds_tcp_state_change() will do that cleanup
  	 */
++<<<<<<< HEAD
 +	rs_tcp = (struct rds_tcp_connection *)conn->c_transport_data;
 +	rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING);
 +	mutex_lock(&rs_tcp->t_conn_lock);
 +	conn_state = rds_conn_state(conn);
 +	if (conn_state != RDS_CONN_CONNECTING && conn_state != RDS_CONN_UP)
++=======
+ 	rs_tcp = rds_tcp_accept_one_path(conn);
+ 	if (!rs_tcp)
+ 		goto rst_nsk;
+ 	mutex_lock(&rs_tcp->t_conn_path_lock);
+ 	cp = rs_tcp->t_cpath;
+ 	conn_state = rds_conn_path_state(cp);
+ 	if (conn_state != RDS_CONN_CONNECTING && conn_state != RDS_CONN_UP &&
+ 	    conn_state != RDS_CONN_ERROR)
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  		goto rst_nsk;
  	if (rs_tcp->t_sock) {
  		/* Need to resolve a duelling SYN between peers.
@@@ -132,17 -182,17 +189,25 @@@
  		 * c_transport_data.
  		 */
  		if (ntohl(inet->inet_saddr) < ntohl(inet->inet_daddr) ||
++<<<<<<< HEAD
 +		    !conn->c_outgoing) {
 +			goto rst_nsk;
 +		} else {
 +			rds_tcp_reset_callbacks(new_sock, conn);
 +			conn->c_outgoing = 0;
++=======
+ 		    !cp->cp_outgoing) {
+ 			goto rst_nsk;
+ 		} else {
+ 			rds_tcp_reset_callbacks(new_sock, cp);
+ 			cp->cp_outgoing = 0;
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  			/* rds_connect_path_complete() marks RDS_CONN_UP */
 -			rds_connect_path_complete(cp, RDS_CONN_RESETTING);
 +			rds_connect_path_complete(conn, RDS_CONN_RESETTING);
  		}
  	} else {
 -		rds_tcp_set_callbacks(new_sock, cp);
 -		rds_connect_path_complete(cp, RDS_CONN_CONNECTING);
 +		rds_tcp_set_callbacks(new_sock, conn);
 +		rds_connect_path_complete(conn, RDS_CONN_CONNECTING);
  	}
  	new_sock = NULL;
  	ret = 0;
diff --cc net/rds/threads.c
index 55bb19ff40f2,e42df11bf30a..000000000000
--- a/net/rds/threads.c
+++ b/net/rds/threads.c
@@@ -144,12 -150,18 +144,21 @@@ void rds_queue_reconnect(struct rds_con
  
  void rds_connect_worker(struct work_struct *work)
  {
 -	struct rds_conn_path *cp = container_of(work,
 -						struct rds_conn_path,
 -						cp_conn_w.work);
 -	struct rds_connection *conn = cp->cp_conn;
 +	struct rds_connection *conn = container_of(work, struct rds_connection, c_conn_w.work);
  	int ret;
  
++<<<<<<< HEAD
 +	clear_bit(RDS_RECONNECT_PENDING, &conn->c_flags);
 +	if (rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING)) {
 +		ret = conn->c_trans->conn_connect(conn);
++=======
+ 	if (cp->cp_index > 1 && cp->cp_conn->c_laddr > cp->cp_conn->c_faddr)
+ 		return;
+ 	clear_bit(RDS_RECONNECT_PENDING, &cp->cp_flags);
+ 	ret = rds_conn_path_transition(cp, RDS_CONN_DOWN, RDS_CONN_CONNECTING);
+ 	if (ret) {
+ 		ret = conn->c_trans->conn_path_connect(cp);
++>>>>>>> 5916e2c1554f (RDS: TCP: Enable multipath RDS for TCP)
  		rdsdebug("conn %p for %pI4 to %pI4 dispatched, ret %d\n",
  			conn, &conn->c_laddr, &conn->c_faddr, ret);
  
diff --git a/net/rds/bind.c b/net/rds/bind.c
index 5e061746da51..2d43c320ef69 100644
--- a/net/rds/bind.c
+++ b/net/rds/bind.c
@@ -81,6 +81,8 @@ static int rds_add_bound(struct rds_sock *rs, __be32 addr, __be16 *port)
 
 	if (*port != 0) {
 		rover = be16_to_cpu(*port);
+		if (rover == RDS_FLAG_PROBE_PORT)
+			return -EINVAL;
 		last = rover;
 	} else {
 		rover = max_t(u16, net_random(), 2);
@@ -91,12 +93,16 @@ static int rds_add_bound(struct rds_sock *rs, __be32 addr, __be16 *port)
 		if (rover == 0)
 			rover++;
 
+		if (rover == RDS_FLAG_PROBE_PORT)
+			continue;
 		key = ((u64)addr << 32) | cpu_to_be16(rover);
 		if (rhashtable_lookup_fast(&bind_hash_table, &key, ht_parms))
 			continue;
 
 		rs->rs_bound_key = key;
 		rs->rs_bound_addr = addr;
+		net_get_random_once(&rs->rs_hash_initval,
+				    sizeof(rs->rs_hash_initval));
 		rs->rs_bound_port = cpu_to_be16(rover);
 		rs->rs_bound_node.next = NULL;
 		rds_sock_addref(rs);
* Unmerged path net/rds/connection.c
diff --git a/net/rds/message.c b/net/rds/message.c
index aba232f9f308..701b4395e46f 100644
--- a/net/rds/message.c
+++ b/net/rds/message.c
@@ -41,6 +41,7 @@ static unsigned int	rds_exthdr_size[__RDS_EXTHDR_MAX] = {
 [RDS_EXTHDR_VERSION]	= sizeof(struct rds_ext_header_version),
 [RDS_EXTHDR_RDMA]	= sizeof(struct rds_ext_header_rdma),
 [RDS_EXTHDR_RDMA_DEST]	= sizeof(struct rds_ext_header_rdma_dest),
+[RDS_EXTHDR_NPATHS]	= sizeof(u16),
 };
 
 
* Unmerged path net/rds/rds.h
diff --git a/net/rds/recv.c b/net/rds/recv.c
index aa7e3b20218b..07292ab88aad 100644
--- a/net/rds/recv.c
+++ b/net/rds/recv.c
@@ -156,6 +156,67 @@ static void rds_recv_incoming_exthdrs(struct rds_incoming *inc, struct rds_sock
 	}
 }
 
+static void rds_recv_hs_exthdrs(struct rds_header *hdr,
+				struct rds_connection *conn)
+{
+	unsigned int pos = 0, type, len;
+	union {
+		struct rds_ext_header_version version;
+		u16 rds_npaths;
+	} buffer;
+
+	while (1) {
+		len = sizeof(buffer);
+		type = rds_message_next_extension(hdr, &pos, &buffer, &len);
+		if (type == RDS_EXTHDR_NONE)
+			break;
+		/* Process extension header here */
+		switch (type) {
+		case RDS_EXTHDR_NPATHS:
+			conn->c_npaths = min_t(int, RDS_MPATH_WORKERS,
+					       buffer.rds_npaths);
+			break;
+		default:
+			pr_warn_ratelimited("ignoring unknown exthdr type "
+					     "0x%x\n", type);
+		}
+	}
+	/* if RDS_EXTHDR_NPATHS was not found, default to a single-path */
+	conn->c_npaths = max_t(int, conn->c_npaths, 1);
+}
+
+/* rds_start_mprds() will synchronously start multiple paths when appropriate.
+ * The scheme is based on the following rules:
+ *
+ * 1. rds_sendmsg on first connect attempt sends the probe ping, with the
+ *    sender's npaths (s_npaths)
+ * 2. rcvr of probe-ping knows the mprds_paths = min(s_npaths, r_npaths). It
+ *    sends back a probe-pong with r_npaths. After that, if rcvr is the
+ *    smaller ip addr, it starts rds_conn_path_connect_if_down on all
+ *    mprds_paths.
+ * 3. sender gets woken up, and can move to rds_conn_path_connect_if_down.
+ *    If it is the smaller ipaddr, rds_conn_path_connect_if_down can be
+ *    called after reception of the probe-pong on all mprds_paths.
+ *    Otherwise (sender of probe-ping is not the smaller ip addr): just call
+ *    rds_conn_path_connect_if_down on the hashed path. (see rule 4)
+ * 4. when cp_index > 0, rds_connect_worker must only trigger
+ *    a connection if laddr < faddr.
+ * 5. sender may end up queuing the packet on the cp. will get sent out later.
+ *    when connection is completed.
+ */
+static void rds_start_mprds(struct rds_connection *conn)
+{
+	int i;
+	struct rds_conn_path *cp;
+
+	if (conn->c_npaths > 1 && conn->c_laddr < conn->c_faddr) {
+		for (i = 1; i < conn->c_npaths; i++) {
+			cp = &conn->c_path[i];
+			rds_conn_path_connect_if_down(cp);
+		}
+	}
+}
+
 /*
  * The transport must make sure that this is serialized against other
  * rx and conn reset on this specific conn.
@@ -232,6 +293,20 @@ void rds_recv_incoming(struct rds_connection *conn, __be32 saddr, __be32 daddr,
 		}
 		rds_stats_inc(s_recv_ping);
 		rds_send_pong(cp, inc->i_hdr.h_sport);
+		/* if this is a handshake ping, start multipath if necessary */
+		if (RDS_HS_PROBE(inc->i_hdr.h_sport, inc->i_hdr.h_dport)) {
+			rds_recv_hs_exthdrs(&inc->i_hdr, cp->cp_conn);
+			rds_start_mprds(cp->cp_conn);
+		}
+		goto out;
+	}
+
+	if (inc->i_hdr.h_dport ==  RDS_FLAG_PROBE_PORT &&
+	    inc->i_hdr.h_sport == 0) {
+		rds_recv_hs_exthdrs(&inc->i_hdr, cp->cp_conn);
+		/* if this is a handshake pong, start multipath if necessary */
+		rds_start_mprds(cp->cp_conn);
+		wake_up(&cp->cp_conn->c_hs_waitq);
 		goto out;
 	}
 
* Unmerged path net/rds/send.c
diff --git a/net/rds/tcp.c b/net/rds/tcp.c
index 47047d2fa425..141fc33ddf38 100644
--- a/net/rds/tcp.c
+++ b/net/rds/tcp.c
@@ -352,6 +352,7 @@ struct rds_transport rds_tcp_transport = {
 	.t_name			= "tcp",
 	.t_type			= RDS_TRANS_TCP,
 	.t_prefer_loopback	= 1,
+	.t_mp_capable		= 1,
 };
 
 static int rds_tcp_netid;
* Unmerged path net/rds/tcp_connect.c
* Unmerged path net/rds/tcp_listen.c
diff --git a/net/rds/tcp_send.c b/net/rds/tcp_send.c
index 4be8e6261b9f..682ecad3e7e8 100644
--- a/net/rds/tcp_send.c
+++ b/net/rds/tcp_send.c
@@ -80,7 +80,8 @@ static int rds_tcp_sendmsg(struct socket *sock, void *data, unsigned int len)
 int rds_tcp_xmit(struct rds_connection *conn, struct rds_message *rm,
 	         unsigned int hdr_off, unsigned int sg, unsigned int off)
 {
-	struct rds_tcp_connection *tc = conn->c_transport_data;
+	struct rds_conn_path *cp = rm->m_inc.i_conn_path;
+	struct rds_tcp_connection *tc = cp->cp_transport_data;
 	int done = 0;
 	int ret = 0;
 	int more;
@@ -149,10 +150,17 @@ out:
 			rds_tcp_stats_inc(s_tcp_sndbuf_full);
 			ret = 0;
 		} else {
-			printk(KERN_WARNING "RDS/tcp: send to %pI4 "
-			       "returned %d, disconnecting and reconnecting\n",
-			       &conn->c_faddr, ret);
-			rds_conn_drop(conn);
+			/* No need to disconnect/reconnect if path_drop
+			 * has already been triggered, because, e.g., of
+			 * an incoming RST.
+			 */
+			if (rds_conn_path_up(cp)) {
+				pr_warn("RDS/tcp: send to %pI4 on cp [%d]"
+					"returned %d, "
+					"disconnecting and reconnecting\n",
+					&conn->c_faddr, cp->cp_index, ret);
+				rds_conn_path_drop(cp);
+			}
 		}
 	}
 	if (done == 0)
* Unmerged path net/rds/threads.c
