net/mlx5: Check max encap header size capability

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Check max encap header size capability (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 95.65%
commit-author Hadar Hen Zion <hadarh@mellanox.com>
commit 43f93839e359c8044200ec3f6fa455b47ba3aa2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/43f93839.failed

Instead of comparing to a const value, check the value of max encap
header size capability as reported by the Firmware.

Fixes: 575ddf5888ea ('net/mlx5: Introduce alloc_encap and dealloc_encap commands')
	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 43f93839e359c8044200ec3f6fa455b47ba3aa2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index 9255fb6f5d9d,301cec896eb6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@@ -353,6 -387,122 +353,126 @@@ int mlx5_cmd_fc_query(struct mlx5_core_
  	stats = MLX5_ADDR_OF(query_flow_counter_out, out, flow_statistics);
  	*packets = MLX5_GET64(traffic_counter, stats, packets);
  	*bytes = MLX5_GET64(traffic_counter, stats, octets);
 +
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ struct mlx5_cmd_fc_bulk {
+ 	u16 id;
+ 	int num;
+ 	int outlen;
+ 	u32 out[0];
+ };
+ 
+ struct mlx5_cmd_fc_bulk *
+ mlx5_cmd_fc_bulk_alloc(struct mlx5_core_dev *dev, u16 id, int num)
+ {
+ 	struct mlx5_cmd_fc_bulk *b;
+ 	int outlen =
+ 		MLX5_ST_SZ_BYTES(query_flow_counter_out) +
+ 		MLX5_ST_SZ_BYTES(traffic_counter) * num;
+ 
+ 	b = kzalloc(sizeof(*b) + outlen, GFP_KERNEL);
+ 	if (!b)
+ 		return NULL;
+ 
+ 	b->id = id;
+ 	b->num = num;
+ 	b->outlen = outlen;
+ 
+ 	return b;
+ }
+ 
+ void mlx5_cmd_fc_bulk_free(struct mlx5_cmd_fc_bulk *b)
+ {
+ 	kfree(b);
+ }
+ 
+ int
+ mlx5_cmd_fc_bulk_query(struct mlx5_core_dev *dev, struct mlx5_cmd_fc_bulk *b)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(query_flow_counter_in)] = {0};
+ 
+ 	MLX5_SET(query_flow_counter_in, in, opcode,
+ 		 MLX5_CMD_OP_QUERY_FLOW_COUNTER);
+ 	MLX5_SET(query_flow_counter_in, in, op_mod, 0);
+ 	MLX5_SET(query_flow_counter_in, in, flow_counter_id, b->id);
+ 	MLX5_SET(query_flow_counter_in, in, num_of_counters, b->num);
+ 	return mlx5_cmd_exec(dev, in, sizeof(in), b->out, b->outlen);
+ }
+ 
+ void mlx5_cmd_fc_bulk_get(struct mlx5_core_dev *dev,
+ 			  struct mlx5_cmd_fc_bulk *b, u16 id,
+ 			  u64 *packets, u64 *bytes)
+ {
+ 	int index = id - b->id;
+ 	void *stats;
+ 
+ 	if (index < 0 || index >= b->num) {
+ 		mlx5_core_warn(dev, "Flow counter id (0x%x) out of range (0x%x..0x%x). Counter ignored.\n",
+ 			       id, b->id, b->id + b->num - 1);
+ 		return;
+ 	}
+ 
+ 	stats = MLX5_ADDR_OF(query_flow_counter_out, b->out,
+ 			     flow_statistics[index]);
+ 	*packets = MLX5_GET64(traffic_counter, stats, packets);
+ 	*bytes = MLX5_GET64(traffic_counter, stats, octets);
+ }
+ 
+ int mlx5_encap_alloc(struct mlx5_core_dev *dev,
+ 		     int header_type,
+ 		     size_t size,
+ 		     void *encap_header,
+ 		     u32 *encap_id)
+ {
+ 	int max_encap_size = MLX5_CAP_ESW(dev, max_encap_header_size);
+ 	u32 out[MLX5_ST_SZ_DW(alloc_encap_header_out)];
+ 	void *encap_header_in;
+ 	void *header;
+ 	int inlen;
+ 	int err;
+ 	u32 *in;
+ 
+ 	if (size > MLX5_CAP_ESW(dev, max_encap_header_size))
+ 		return -EINVAL;
+ 
+ 	in = kzalloc(MLX5_ST_SZ_BYTES(alloc_encap_header_in) + max_encap_size,
+ 		     GFP_KERNEL);
+ 	if (!in)
+ 		return -ENOMEM;
+ 
+ 	encap_header_in = MLX5_ADDR_OF(alloc_encap_header_in, in, encap_header);
+ 	header = MLX5_ADDR_OF(encap_header_in, encap_header_in, encap_header);
+ 	inlen = header - (void *)in  + size;
+ 
+ 	memset(in, 0, inlen);
+ 	MLX5_SET(alloc_encap_header_in, in, opcode,
+ 		 MLX5_CMD_OP_ALLOC_ENCAP_HEADER);
+ 	MLX5_SET(encap_header_in, encap_header_in, encap_header_size, size);
+ 	MLX5_SET(encap_header_in, encap_header_in, header_type, header_type);
+ 	memcpy(header, encap_header, size);
+ 
+ 	memset(out, 0, sizeof(out));
+ 	err = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));
+ 
+ 	*encap_id = MLX5_GET(alloc_encap_header_out, out, encap_id);
+ 	kfree(in);
+ 	return err;
+ }
+ 
+ void mlx5_encap_dealloc(struct mlx5_core_dev *dev, u32 encap_id)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(dealloc_encap_header_in)];
+ 	u32 out[MLX5_ST_SZ_DW(dealloc_encap_header_out)];
+ 
+ 	memset(in, 0, sizeof(in));
+ 	MLX5_SET(dealloc_encap_header_in, in, opcode,
+ 		 MLX5_CMD_OP_DEALLOC_ENCAP_HEADER);
+ 	MLX5_SET(dealloc_encap_header_in, in, encap_id, encap_id);
+ 
+ 	mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ }
++>>>>>>> 43f93839e359 (net/mlx5: Check max encap header size capability)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
