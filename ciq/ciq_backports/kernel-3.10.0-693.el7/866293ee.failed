futex: Add another early deadlock detection check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 866293ee54227584ffcb4a42f69c1f365974ba7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/866293ee.failed

Dave Jones trinity syscall fuzzer exposed an issue in the deadlock
detection code of rtmutex:
  http://lkml.kernel.org/r/20140429151655.GA14277@redhat.com

That underlying issue has been fixed with a patch to the rtmutex code,
but the futex code must not call into rtmutex in that case because
    - it can detect that issue early
    - it avoids a different and more complex fixup for backing out

If the user space variable got manipulated to 0x80000000 which means
no lock holder, but the waiters bit set and an active pi_state in the
kernel is found we can figure out the recursive locking issue by
looking at the pi_state owner. If that is the current task, then we
can safely return -EDEADLK.

The check should have been added in commit 59fa62451 (futex: Handle
futex_pi OWNER_DIED take over correctly) already, but I did not see
the above issue caused by user space manipulation back then.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Dave Jones <davej@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Darren Hart <darren@dvhart.com>
	Cc: Davidlohr Bueso <davidlohr@hp.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Clark Williams <williams@redhat.com>
	Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
	Cc: Roland McGrath <roland@hack.frob.com>
	Cc: Carlos ODonell <carlos@redhat.com>
	Cc: Jakub Jelinek <jakub@redhat.com>
	Cc: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Link: http://lkml.kernel.org/r/20140512201701.097349971@linutronix.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: stable@vger.kernel.org
(cherry picked from commit 866293ee54227584ffcb4a42f69c1f365974ba7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/futex.c
diff --cc kernel/futex.c
index 6def74bb1608,7c68225e3967..000000000000
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@@ -735,58 -743,10 +735,59 @@@ void exit_pi_state_list(struct task_str
  	raw_spin_unlock_irq(&curr->pi_lock);
  }
  
 +/*
 + * We need to check the following states:
 + *
 + *      Waiter | pi_state | pi->owner | uTID      | uODIED | ?
 + *
 + * [1]  NULL   | ---      | ---       | 0         | 0/1    | Valid
 + * [2]  NULL   | ---      | ---       | >0        | 0/1    | Valid
 + *
 + * [3]  Found  | NULL     | --        | Any       | 0/1    | Invalid
 + *
 + * [4]  Found  | Found    | NULL      | 0         | 1      | Valid
 + * [5]  Found  | Found    | NULL      | >0        | 1      | Invalid
 + *
 + * [6]  Found  | Found    | task      | 0         | 1      | Valid
 + *
 + * [7]  Found  | Found    | NULL      | Any       | 0      | Invalid
 + *
 + * [8]  Found  | Found    | task      | ==taskTID | 0/1    | Valid
 + * [9]  Found  | Found    | task      | 0         | 0      | Invalid
 + * [10] Found  | Found    | task      | !=taskTID | 0/1    | Invalid
 + *
 + * [1]	Indicates that the kernel can acquire the futex atomically. We
 + *	came came here due to a stale FUTEX_WAITERS/FUTEX_OWNER_DIED bit.
 + *
 + * [2]	Valid, if TID does not belong to a kernel thread. If no matching
 + *      thread is found then it indicates that the owner TID has died.
 + *
 + * [3]	Invalid. The waiter is queued on a non PI futex
 + *
 + * [4]	Valid state after exit_robust_list(), which sets the user space
 + *	value to FUTEX_WAITERS | FUTEX_OWNER_DIED.
 + *
 + * [5]	The user space value got manipulated between exit_robust_list()
 + *	and exit_pi_state_list()
 + *
 + * [6]	Valid state after exit_pi_state_list() which sets the new owner in
 + *	the pi_state but cannot access the user space value.
 + *
 + * [7]	pi_state->owner can only be NULL when the OWNER_DIED bit is set.
 + *
 + * [8]	Owner and user space value match
 + *
 + * [9]	There is no transient state which sets the user space TID to 0
 + *	except exit_robust_list(), but this is indicated by the
 + *	FUTEX_OWNER_DIED bit. See [4]
 + *
 + * [10] There is no transient state which leaves owner and user space
 + *	TID out of sync.
 + */
  static int
  lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
- 		union futex_key *key, struct futex_pi_state **ps)
+ 		union futex_key *key, struct futex_pi_state **ps,
+ 		struct task_struct *task)
  {
  	struct futex_pi_state *pi_state = NULL;
  	struct futex_q *this, *next;
@@@ -856,17 -788,18 +857,29 @@@
  			}
  
  			/*
++<<<<<<< HEAD
 +			 * Bail out if user space manipulated the
 +			 * futex value. If pi state exists then the
 +			 * owner TID must be the same as the user
 +			 * space TID. [9/10]
 +			 */
 +			if (pid != task_pid_vnr(pi_state->owner))
 +				return -EINVAL;
 +
 +		out_state:
++=======
+ 			 * Protect against a corrupted uval. If uval
+ 			 * is 0x80000000 then pid is 0 and the waiter
+ 			 * bit is set. So the deadlock check in the
+ 			 * calling code has failed and we did not fall
+ 			 * into the check above due to !pid.
+ 			 */
+ 			if (task && pi_state->owner == task)
+ 				return -EDEADLK;
+ 
++>>>>>>> 866293ee5422 (futex: Add another early deadlock detection check)
  			atomic_inc(&pi_state->refcount);
  			*ps = pi_state;
 -
  			return 0;
  		}
  	}
@@@ -1512,16 -1434,8 +1527,15 @@@ static int futex_requeue(u32 __user *ua
  	struct futex_pi_state *pi_state = NULL;
  	struct futex_hash_bucket *hb1, *hb2;
  	struct futex_q *this, *next;
- 	u32 curval2;
  
  	if (requeue_pi) {
 +		/*
 +		 * Requeue PI only works on two distinct uaddrs. This
 +		 * check is only valid for private futexes. See below.
 +		 */
 +		if (uaddr1 == uaddr2)
 +			return -EINVAL;
 +
  		/*
  		 * requeue_pi requires a pi_state, try to allocate it now
  		 * without any locks in case it fails.
* Unmerged path kernel/futex.c
