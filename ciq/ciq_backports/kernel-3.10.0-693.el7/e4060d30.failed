bnxt_en: Reserve RDMA resources by default.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Reserve RDMA resources by default (Jonathan Toppins) [1382378]
Rebuild_FUZZ: 98.82%
commit-author Michael Chan <michael.chan@broadcom.com>
commit e4060d306b5196966d74e05dee48e6c3a52aaad4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e4060d30.failed

If the device supports RDMA, we'll setup network default rings so that
there are enough minimum resources for RDMA, if possible.  However, the
user can still increase network rings to the max if he wants.  The actual
RDMA resources won't be reserved until the RDMA driver registers.

v2: Fix compile warning when BNXT_CONFIG_SRIOV is not set.

	Signed-off-by: Somnath Kotur <somnath.kotur@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e4060d306b5196966d74e05dee48e6c3a52aaad4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index c6f371a45f71,57285bd76944..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -4725,16 -4748,114 +4730,122 @@@ static int bnxt_trim_rings(struct bnxt 
  	return 0;
  }
  
 -static void bnxt_setup_msix(struct bnxt *bp)
 +static int bnxt_setup_msix(struct bnxt *bp)
  {
++<<<<<<< HEAD
++=======
+ 	const int len = sizeof(bp->irq_tbl[0].name);
+ 	struct net_device *dev = bp->dev;
+ 	int tcs, i;
+ 
+ 	tcs = netdev_get_num_tc(dev);
+ 	if (tcs > 1) {
+ 		bp->tx_nr_rings_per_tc = bp->tx_nr_rings / tcs;
+ 		if (bp->tx_nr_rings_per_tc == 0) {
+ 			netdev_reset_tc(dev);
+ 			bp->tx_nr_rings_per_tc = bp->tx_nr_rings;
+ 		} else {
+ 			int i, off, count;
+ 
+ 			bp->tx_nr_rings = bp->tx_nr_rings_per_tc * tcs;
+ 			for (i = 0; i < tcs; i++) {
+ 				count = bp->tx_nr_rings_per_tc;
+ 				off = i * count;
+ 				netdev_set_tc_queue(dev, i, count, off);
+ 			}
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < bp->cp_nr_rings; i++) {
+ 		char *attr;
+ 
+ 		if (bp->flags & BNXT_FLAG_SHARED_RINGS)
+ 			attr = "TxRx";
+ 		else if (i < bp->rx_nr_rings)
+ 			attr = "rx";
+ 		else
+ 			attr = "tx";
+ 
+ 		snprintf(bp->irq_tbl[i].name, len, "%s-%s-%d", dev->name, attr,
+ 			 i);
+ 		bp->irq_tbl[i].handler = bnxt_msix;
+ 	}
+ }
+ 
+ static void bnxt_setup_inta(struct bnxt *bp)
+ {
+ 	const int len = sizeof(bp->irq_tbl[0].name);
+ 
+ 	if (netdev_get_num_tc(bp->dev))
+ 		netdev_reset_tc(bp->dev);
+ 
+ 	snprintf(bp->irq_tbl[0].name, len, "%s-%s-%d", bp->dev->name, "TxRx",
+ 		 0);
+ 	bp->irq_tbl[0].handler = bnxt_inta;
+ }
+ 
+ static int bnxt_setup_int_mode(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	if (bp->flags & BNXT_FLAG_USING_MSIX)
+ 		bnxt_setup_msix(bp);
+ 	else
+ 		bnxt_setup_inta(bp);
+ 
+ 	rc = bnxt_set_real_num_queues(bp);
+ 	return rc;
+ }
+ 
+ unsigned int bnxt_get_max_func_stat_ctxs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_stat_ctxs;
+ #endif
+ 	return bp->pf.max_stat_ctxs;
+ }
+ 
+ unsigned int bnxt_get_max_func_cp_rings(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_cp_rings;
+ #endif
+ 	return bp->pf.max_cp_rings;
+ }
+ 
+ static unsigned int bnxt_get_max_func_irqs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_irqs;
+ #endif
+ 	return bp->pf.max_irqs;
+ }
+ 
+ void bnxt_set_max_func_irqs(struct bnxt *bp, unsigned int max_irqs)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_irqs = max_irqs;
+ 	else
+ #endif
+ 		bp->pf.max_irqs = max_irqs;
+ }
+ 
+ static int bnxt_init_msix(struct bnxt *bp)
+ {
+ 	int i, total_vecs, rc = 0, min = 1;
++>>>>>>> e4060d306b51 (bnxt_en: Reserve RDMA resources by default.)
  	struct msix_entry *msix_ent;
 +	struct net_device *dev = bp->dev;
 +	int i, total_vecs, rc = 0, min = 1;
 +	const int len = sizeof(bp->irq_tbl[0].name);
 +
 +	bp->flags &= ~BNXT_FLAG_USING_MSIX;
 +	total_vecs = bp->cp_nr_rings;
  
 -	total_vecs = bnxt_get_max_func_irqs(bp);
  	msix_ent = kcalloc(total_vecs, sizeof(struct msix_entry), GFP_KERNEL);
  	if (!msix_ent)
  		return -ENOMEM;
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index d19388f26026,d796836633c8..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1218,7 -1241,11 +1225,15 @@@ int _hwrm_send_message(struct bnxt *, v
  int hwrm_send_message(struct bnxt *, void *, u32, int);
  int hwrm_send_message_silent(struct bnxt *, void *, u32, int);
  int bnxt_hwrm_set_coal(struct bnxt *);
++<<<<<<< HEAD
 +int bnxt_hwrm_func_qcaps(struct bnxt *);
++=======
+ unsigned int bnxt_get_max_func_stat_ctxs(struct bnxt *bp);
+ unsigned int bnxt_get_max_func_cp_rings(struct bnxt *bp);
+ void bnxt_set_max_func_irqs(struct bnxt *bp, unsigned int max);
+ void bnxt_tx_disable(struct bnxt *bp);
+ void bnxt_tx_enable(struct bnxt *bp);
++>>>>>>> e4060d306b51 (bnxt_en: Reserve RDMA resources by default.)
  int bnxt_hwrm_set_pause(struct bnxt *);
  int bnxt_hwrm_set_link_setting(struct bnxt *, bool, bool);
  int bnxt_hwrm_fw_set_time(struct bnxt *);
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
