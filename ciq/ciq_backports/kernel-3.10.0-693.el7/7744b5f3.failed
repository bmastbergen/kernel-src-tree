pktgen: fix UDP checksum computation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit 7744b5f3693cc06695cb9d6667671c790282730f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7744b5f3.failed

This patch fixes two issues in UDP checksum computation in pktgen.

First, the pseudo-header uses the source and destination IP
addresses. Currently, the ports are used for IPv4.

Second, the UDP checksum covers both header and data.  So we need to
generate the data earlier (move pktgen_finalize_skb up), and compute
the checksum for UDP header + data.

Fixes: c26bf4a51308c ("pktgen: Add UDPCSUM flag to support UDP checksums")
	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7744b5f3693cc06695cb9d6667671c790282730f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/pktgen.c
diff --cc net/core/pktgen.c
index e06341827eab,9fa25b0ea145..000000000000
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@@ -2794,8 -2841,26 +2794,31 @@@ static struct sk_buff *fill_packet_ipv4
  	skb->protocol = protocol;
  	skb->dev = odev;
  	skb->pkt_type = PACKET_HOST;
++<<<<<<< HEAD
 +	pktgen_finalize_skb(pkt_dev, skb, datalen);
 +
++=======
+ 
+ 	pktgen_finalize_skb(pkt_dev, skb, datalen);
+ 
+ 	if (!(pkt_dev->flags & F_UDPCSUM)) {
+ 		skb->ip_summed = CHECKSUM_NONE;
+ 	} else if (odev->features & NETIF_F_V4_CSUM) {
+ 		skb->ip_summed = CHECKSUM_PARTIAL;
+ 		skb->csum = 0;
+ 		udp4_hwcsum(skb, iph->saddr, iph->daddr);
+ 	} else {
+ 		__wsum csum = skb_checksum(skb, skb_transport_offset(skb), datalen + 8, 0);
+ 
+ 		/* add protocol-dependent pseudo-header */
+ 		udph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,
+ 						datalen + 8, IPPROTO_UDP, csum);
+ 
+ 		if (udph->check == 0)
+ 			udph->check = CSUM_MANGLED_0;
+ 	}
+ 
++>>>>>>> 7744b5f3693c (pktgen: fix UDP checksum computation)
  #ifdef CONFIG_XFRM
  	if (!process_ipsec(pkt_dev, skb, protocol))
  		return NULL;
@@@ -2912,6 -2978,23 +2935,26 @@@ static struct sk_buff *fill_packet_ipv6
  
  	pktgen_finalize_skb(pkt_dev, skb, datalen);
  
++<<<<<<< HEAD
++=======
+ 	if (!(pkt_dev->flags & F_UDPCSUM)) {
+ 		skb->ip_summed = CHECKSUM_NONE;
+ 	} else if (odev->features & NETIF_F_V6_CSUM) {
+ 		skb->ip_summed = CHECKSUM_PARTIAL;
+ 		skb->csum_start = skb_transport_header(skb) - skb->head;
+ 		skb->csum_offset = offsetof(struct udphdr, check);
+ 		udph->check = ~csum_ipv6_magic(&iph->saddr, &iph->daddr, udplen, IPPROTO_UDP, 0);
+ 	} else {
+ 		__wsum csum = skb_checksum(skb, skb_transport_offset(skb), udplen, 0);
+ 
+ 		/* add protocol-dependent pseudo-header */
+ 		udph->check = csum_ipv6_magic(&iph->saddr, &iph->daddr, udplen, IPPROTO_UDP, csum);
+ 
+ 		if (udph->check == 0)
+ 			udph->check = CSUM_MANGLED_0;
+ 	}
+ 
++>>>>>>> 7744b5f3693c (pktgen: fix UDP checksum computation)
  	return skb;
  }
  
* Unmerged path net/core/pktgen.c
