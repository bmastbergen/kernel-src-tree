svcrdma: backchannel cannot share a page for send and rcv buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 8d42629be0cb6c58a5c77cd02e47974c0e724e63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8d42629b.failed

The underlying transport releases the page pointed to by rq_buffer
during xprt_rdma_bc_send_request. When the backchannel reply arrives,
rq_rbuffer then points to freed memory.

Fixes: 68778945e46f ('SUNRPC: Separate buffer pointers for RPC ...')
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Cc: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 8d42629be0cb6c58a5c77cd02e47974c0e724e63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/svc_rdma_backchannel.c
diff --cc net/sunrpc/xprtrdma/svc_rdma_backchannel.c
index 803b076ae064,20027f8de129..000000000000
--- a/net/sunrpc/xprtrdma/svc_rdma_backchannel.c
+++ b/net/sunrpc/xprtrdma/svc_rdma_backchannel.c
@@@ -173,22 -171,32 +173,37 @@@ xprt_rdma_bc_allocate(struct rpc_task *
  
  	rdma = container_of(sxprt, struct svcxprt_rdma, sc_xprt);
  
 -	if (size > PAGE_SIZE) {
 +	/* Prevent an infinite loop: try to make this case work */
 +	if (size > PAGE_SIZE)
  		WARN_ONCE(1, "svcrdma: large bc buffer request (size %zu)\n",
  			  size);
 -		return -EINVAL;
 -	}
  
+ 	/* svc_rdma_sendto releases this page */
  	page = alloc_page(RPCRDMA_DEF_GFP);
  	if (!page)
++<<<<<<< HEAD
 +		return NULL;
 +
 +	return page_address(page);
++=======
+ 		return -ENOMEM;
+ 	rqst->rq_buffer = page_address(page);
+ 
+ 	rqst->rq_rbuffer = kmalloc(rqst->rq_rcvsize, RPCRDMA_DEF_GFP);
+ 	if (!rqst->rq_rbuffer) {
+ 		put_page(page);
+ 		return -ENOMEM;
+ 	}
+ 	return 0;
++>>>>>>> 8d42629be0cb (svcrdma: backchannel cannot share a page for send and rcv buffers)
  }
  
  static void
 -xprt_rdma_bc_free(struct rpc_task *task)
 +xprt_rdma_bc_free(void *buffer)
  {
- 	/* No-op: ctxt and page have already been freed. */
+ 	struct rpc_rqst *rqst = task->tk_rqstp;
+ 
+ 	kfree(rqst->rq_rbuffer);
  }
  
  static int
* Unmerged path net/sunrpc/xprtrdma/svc_rdma_backchannel.c
