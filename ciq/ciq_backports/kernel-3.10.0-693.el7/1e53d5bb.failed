net: Pass VLAN ID to rtnl_fdb_notify.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] rtnetlink: Pass VLAN ID to rtnl_fdb_notify (Ivan Vecera) [1382040]
Rebuild_FUZZ: 91.14%
commit-author Hubert Sokolowski <hubert.sokolowski@intel.com>
commit 1e53d5bb8878dcbdbffde334ab89b1f57778b48c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1e53d5bb.failed

When an FDB entry is added or deleted the information about VLAN
is not passed to listening applications like 'bridge monitor fdb'.
With this patch VLAN ID is passed if it was set in the original
netlink message.

Also remove an unused bdev variable.

	Signed-off-by: Hubert Sokolowski <hubert.sokolowski@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1e53d5bb8878dcbdbffde334ab89b1f57778b48c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index 131bb4450ad1,c3bf19000d3a..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -2845,44 -2756,69 +2849,97 @@@ EXPORT_SYMBOL(ndo_dflt_fdb_dump)
  
  static int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)
  {
++<<<<<<< HEAD
++=======
+ 	struct net_device *dev;
+ 	struct nlattr *tb[IFLA_MAX+1];
+ 	struct net_device *br_dev = NULL;
+ 	const struct net_device_ops *ops = NULL;
+ 	const struct net_device_ops *cops = NULL;
+ 	struct ifinfomsg *ifm = nlmsg_data(cb->nlh);
+ 	struct net *net = sock_net(skb->sk);
+ 	int brport_idx = 0;
+ 	int br_idx = 0;
++>>>>>>> 1e53d5bb8878 (net: Pass VLAN ID to rtnl_fdb_notify.)
  	int idx = 0;
 +	struct net *net = sock_net(skb->sk);
 +	struct net_device *dev;
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	cb->args[1] = 0;
 +	for_each_netdev_rcu(net, dev) {
++=======
+ 	if (nlmsg_parse(cb->nlh, sizeof(struct ifinfomsg), tb, IFLA_MAX,
+ 			ifla_policy) == 0) {
+ 		if (tb[IFLA_MASTER])
+ 			br_idx = nla_get_u32(tb[IFLA_MASTER]);
+ 	}
+ 
+ 	brport_idx = ifm->ifi_index;
+ 
+ 	if (br_idx) {
+ 		br_dev = __dev_get_by_index(net, br_idx);
+ 		if (!br_dev)
+ 			return -ENODEV;
+ 
+ 		ops = br_dev->netdev_ops;
+ 	}
+ 
+ 	for_each_netdev(net, dev) {
+ 		if (brport_idx && (dev->ifindex != brport_idx))
+ 			continue;
+ 
+ 		if (!br_idx) { /* user did not specify a specific bridge */
+ 			if (dev->priv_flags & IFF_BRIDGE_PORT) {
+ 				br_dev = netdev_master_upper_dev_get(dev);
+ 				cops = br_dev->netdev_ops;
+ 			}
+ 
+ 		} else {
+ 			if (dev != br_dev &&
+ 			    !(dev->priv_flags & IFF_BRIDGE_PORT))
+ 				continue;
+ 
+ 			if (br_dev != netdev_master_upper_dev_get(dev) &&
+ 			    !(dev->priv_flags & IFF_EBRIDGE))
+ 				continue;
+ 
+ 			cops = ops;
+ 		}
+ 
++>>>>>>> 1e53d5bb8878 (net: Pass VLAN ID to rtnl_fdb_notify.)
  		if (dev->priv_flags & IFF_BRIDGE_PORT) {
 -			if (cops && cops->ndo_fdb_dump)
 -				idx = cops->ndo_fdb_dump(skb, cb, br_dev, dev,
 -							 idx);
 +			struct net_device *br_dev;
 +			const struct net_device_ops *ops;
 +
 +			br_dev = netdev_master_upper_dev_get(dev);
 +			ops = br_dev->netdev_ops;
 +			if (get_ndo_ext(ops, ndo_fdb_dump))
 +				idx = get_ndo_ext(ops, ndo_fdb_dump)(skb, cb,
 +								     dev, NULL,
 +								     idx);
 +			else if (ops->ndo_fdb_dump_rh72)
 +				idx = ops->ndo_fdb_dump_rh72(skb, cb, dev, idx);
  		}
 +		if (cb->args[1] == -EMSGSIZE)
 +			break;
  
 -		if (dev->netdev_ops->ndo_fdb_dump)
 -			idx = dev->netdev_ops->ndo_fdb_dump(skb, cb, dev, NULL,
 -							    idx);
 +		if (get_ndo_ext(dev->netdev_ops, ndo_fdb_dump))
 +			idx = get_ndo_ext(dev->netdev_ops, ndo_fdb_dump)(skb,
 +									 cb,
 +									 dev,
 +									 NULL,
 +									 idx);
 +		else if (dev->netdev_ops->ndo_fdb_dump_rh72)
 +			idx = dev->netdev_ops->ndo_fdb_dump_rh72(skb, cb, dev,
 +								 idx);
  		else
  			idx = ndo_dflt_fdb_dump(skb, cb, dev, NULL, idx);
 -
 -		cops = NULL;
 +		if (cb->args[1] == -EMSGSIZE)
 +			break;
  	}
 +	rcu_read_unlock();
  
  	cb->args[0] = idx;
  	return skb->len;
* Unmerged path net/core/rtnetlink.c
