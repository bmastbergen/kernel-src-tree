mnt: Clarify and correct the disconnect logic in umount_tree

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f2d0a123.failed

rmdir mntpoint will result in an infinite loop when there is
a mount locked on the mountpoint in another mount namespace.

This is because the logic to test to see if a mount should
be disconnected in umount_tree is buggy.

Move the logic to decide if a mount should remain connected to
it's mountpoint into it's own function disconnect_mount so that
clarity of expression instead of terseness of expression becomes
a virtue.

When the conditions where it is invalid to leave a mount connected
are first ruled out, the logic for deciding if a mount should
be disconnected becomes much clearer and simpler.

Fixes: e0c9c0afd2fc958ffa34b697972721d81df8a56f mnt: Update detach_mounts to leave mounts connected
Fixes: ce07d891a0891d3c0d0c2d73d577490486b809e1 mnt: Honor MNT_LOCKED when detaching mounts
	Cc: stable@vger.kernel.org
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
#	fs/pnode.h
diff --cc fs/namespace.c
index 91fbddebae10,7829eab0b706..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1208,11 -1356,46 +1208,49 @@@ static inline void namespace_lock(void
  	down_write(&namespace_sem);
  }
  
++<<<<<<< HEAD
++=======
+ enum umount_tree_flags {
+ 	UMOUNT_SYNC = 1,
+ 	UMOUNT_PROPAGATE = 2,
+ 	UMOUNT_CONNECTED = 4,
+ };
+ 
+ static bool disconnect_mount(struct mount *mnt, enum umount_tree_flags how)
+ {
+ 	/* Leaving mounts connected is only valid for lazy umounts */
+ 	if (how & UMOUNT_SYNC)
+ 		return true;
+ 
+ 	/* A mount without a parent has nothing to be connected to */
+ 	if (!mnt_has_parent(mnt))
+ 		return true;
+ 
+ 	/* Because the reference counting rules change when mounts are
+ 	 * unmounted and connected, umounted mounts may not be
+ 	 * connected to mounted mounts.
+ 	 */
+ 	if (!(mnt->mnt_parent->mnt.mnt_flags & MNT_UMOUNT))
+ 		return true;
+ 
+ 	/* Has it been requested that the mount remain connected? */
+ 	if (how & UMOUNT_CONNECTED)
+ 		return false;
+ 
+ 	/* Is the mount locked such that it needs to remain connected? */
+ 	if (IS_MNT_LOCKED(mnt))
+ 		return false;
+ 
+ 	/* By default disconnect the mount */
+ 	return true;
+ }
+ 
++>>>>>>> f2d0a123bcf1 (mnt: Clarify and correct the disconnect logic in umount_tree)
  /*
 - * mount_lock must be held
 + * vfsmount lock must be held for write
   * namespace_sem must be held for write
   */
 -static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 +void umount_tree(struct mount *mnt, int propagate)
  {
  	LIST_HEAD(tmp_list);
  	struct mount *p;
@@@ -1228,15 -1425,21 +1266,25 @@@
  		list_del_init(&p->mnt_list);
  		__touch_mnt_namespace(p->mnt_ns);
  		p->mnt_ns = NULL;
++<<<<<<< HEAD
 +		list_del_init(&p->mnt_child);
++=======
+ 		if (how & UMOUNT_SYNC)
+ 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
+ 
+ 		disconnect = disconnect_mount(p, how);
+ 
+ 		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
+ 				 disconnect ? &unmounted : NULL);
++>>>>>>> f2d0a123bcf1 (mnt: Clarify and correct the disconnect logic in umount_tree)
  		if (mnt_has_parent(p)) {
 -			mnt_add_count(p->mnt_parent, -1);
 -			if (!disconnect) {
 -				/* Don't forget about p */
 -				list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
 -			} else {
 -				umount_mnt(p);
 -			}
 +			put_mountpoint(p->mnt_mp);
 +			/* move the reference to mountpoint into ->mnt_ex_mountpoint */
 +			p->mnt_ex_mountpoint.dentry = p->mnt_mountpoint;
 +			p->mnt_ex_mountpoint.mnt = &p->mnt_parent->mnt;
 +			p->mnt_mountpoint = p->mnt.mnt_root;
 +			p->mnt_parent = p;
 +			p->mnt_mp = NULL;
  		}
  		change_mnt_propagation(p, MS_PRIVATE);
  	}
diff --cc fs/pnode.h
index 65e04f65fa1a,0fcdbe7ca648..000000000000
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@@ -19,6 -19,7 +19,10 @@@
  #define IS_MNT_MARKED(m) ((m)->mnt.mnt_flags & MNT_MARKED)
  #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)
  #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)
++<<<<<<< HEAD
++=======
+ #define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)
++>>>>>>> f2d0a123bcf1 (mnt: Clarify and correct the disconnect logic in umount_tree)
  
  #define CL_EXPIRE    		0x01
  #define CL_SLAVE     		0x02
* Unmerged path fs/namespace.c
* Unmerged path fs/pnode.h
