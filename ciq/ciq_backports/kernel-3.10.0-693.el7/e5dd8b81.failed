amd-xgbe: Add ethtool error and debug messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit e5dd8b81107881f8928378a38f6e47aa2da62c37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e5dd8b81.failed

Add error and dynamic debug messages to various ethtool functions in
the driver while also removing the DBGPR debug print calls. Also, change
the message level for some error messages from alert to err.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e5dd8b81107881f8928378a38f6e47aa2da62c37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
index 4d8dc09465af,95b63730aa58..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
@@@ -236,45 -233,41 +224,57 @@@ static void xgbe_get_pauseparam(struct 
  {
  	struct xgbe_prv_data *pdata = netdev_priv(netdev);
  
++<<<<<<< HEAD
 +	DBGPR("-->xgbe_get_pauseparam\n");
 +
 +	pause->autoneg = pdata->pause_autoneg;
 +	pause->tx_pause = pdata->tx_pause;
 +	pause->rx_pause = pdata->rx_pause;
 +
 +	DBGPR("<--xgbe_get_pauseparam\n");
++=======
+ 	pause->autoneg = pdata->phy.pause_autoneg;
+ 	pause->tx_pause = pdata->phy.tx_pause;
+ 	pause->rx_pause = pdata->phy.rx_pause;
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  }
  
  static int xgbe_set_pauseparam(struct net_device *netdev,
  			       struct ethtool_pauseparam *pause)
  {
  	struct xgbe_prv_data *pdata = netdev_priv(netdev);
 +	struct phy_device *phydev = pdata->phydev;
  	int ret = 0;
  
++<<<<<<< HEAD
 +	DBGPR("-->xgbe_set_pauseparam\n");
 +
 +	DBGPR("  autoneg = %d, tx_pause = %d, rx_pause = %d\n",
 +	      pause->autoneg, pause->tx_pause, pause->rx_pause);
 +
 +	pdata->pause_autoneg = pause->autoneg;
 +	if (pause->autoneg) {
 +		phydev->advertising |= ADVERTISED_Pause;
 +		phydev->advertising |= ADVERTISED_Asym_Pause;
++=======
+ 	if (pause->autoneg && (pdata->phy.autoneg != AUTONEG_ENABLE)) {
+ 		netdev_err(netdev,
+ 			   "autoneg disabled, pause autoneg not avialable\n");
+ 		return -EINVAL;
+ 	}
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  
 -	pdata->phy.pause_autoneg = pause->autoneg;
 -	pdata->phy.tx_pause = pause->tx_pause;
 -	pdata->phy.rx_pause = pause->rx_pause;
 +	} else {
 +		phydev->advertising &= ~ADVERTISED_Pause;
 +		phydev->advertising &= ~ADVERTISED_Asym_Pause;
  
 -	pdata->phy.advertising &= ~ADVERTISED_Pause;
 -	pdata->phy.advertising &= ~ADVERTISED_Asym_Pause;
 -
 -	if (pause->rx_pause) {
 -		pdata->phy.advertising |= ADVERTISED_Pause;
 -		pdata->phy.advertising |= ADVERTISED_Asym_Pause;
 +		pdata->tx_pause = pause->tx_pause;
 +		pdata->rx_pause = pause->rx_pause;
  	}
  
 -	if (pause->tx_pause)
 -		pdata->phy.advertising ^= ADVERTISED_Asym_Pause;
 -
  	if (netif_running(netdev))
 -		ret = pdata->phy_if.phy_config_aneg(pdata);
 +		ret = phy_start_aneg(phydev);
  
- 	DBGPR("<--xgbe_set_pauseparam\n");
- 
  	return ret;
  }
  
@@@ -282,18 -275,21 +282,26 @@@ static int xgbe_get_settings(struct net
  			     struct ethtool_cmd *cmd)
  {
  	struct xgbe_prv_data *pdata = netdev_priv(netdev);
 +	int ret;
  
 -	cmd->phy_address = pdata->phy.address;
++<<<<<<< HEAD
 +	DBGPR("-->xgbe_get_settings\n");
  
 -	cmd->supported = pdata->phy.supported;
 -	cmd->advertising = pdata->phy.advertising;
 -	cmd->lp_advertising = pdata->phy.lp_advertising;
 +	if (!pdata->phydev)
 +		return -ENODEV;
++=======
++	cmd->phy_address = pdata->phy.address;
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  
 -	cmd->autoneg = pdata->phy.autoneg;
 -	ethtool_cmd_speed_set(cmd, pdata->phy.speed);
 -	cmd->duplex = pdata->phy.duplex;
 +	ret = phy_ethtool_gset(pdata->phydev, cmd);
  
 -	cmd->port = PORT_NONE;
 -	cmd->transceiver = XCVR_INTERNAL;
++<<<<<<< HEAD
 +	DBGPR("<--xgbe_get_settings\n");
  
 +	return ret;
++=======
+ 	return 0;
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  }
  
  static int xgbe_set_settings(struct net_device *netdev,
@@@ -304,19 -299,20 +312,31 @@@
  	u32 speed;
  	int ret;
  
++<<<<<<< HEAD
 +	DBGPR("-->xgbe_set_settings\n");
 +
 +	if (!pdata->phydev)
 +		return -ENODEV;
 +
 +	speed = ethtool_cmd_speed(cmd);
 +
 +	if (cmd->phy_address != phydev->addr)
++=======
+ 	speed = ethtool_cmd_speed(cmd);
+ 
+ 	if (cmd->phy_address != pdata->phy.address) {
+ 		netdev_err(netdev, "invalid phy address %hhu\n",
+ 			   cmd->phy_address);
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  		return -EINVAL;
+ 	}
  
  	if ((cmd->autoneg != AUTONEG_ENABLE) &&
- 	    (cmd->autoneg != AUTONEG_DISABLE))
+ 	    (cmd->autoneg != AUTONEG_DISABLE)) {
+ 		netdev_err(netdev, "unsupported autoneg %hhu\n",
+ 			   cmd->autoneg);
  		return -EINVAL;
+ 	}
  
  	if (cmd->autoneg == AUTONEG_DISABLE) {
  		switch (speed) {
@@@ -328,30 -325,38 +349,43 @@@
  			return -EINVAL;
  		}
  
- 		if (cmd->duplex != DUPLEX_FULL)
+ 		if (cmd->duplex != DUPLEX_FULL) {
+ 			netdev_err(netdev, "unsupported duplex %hhu\n",
+ 				   cmd->duplex);
  			return -EINVAL;
+ 		}
  	}
  
++<<<<<<< HEAD
 +	cmd->advertising &= phydev->supported;
 +	if ((cmd->autoneg == AUTONEG_ENABLE) && !cmd->advertising)
++=======
+ 	netif_dbg(pdata, link, netdev,
+ 		  "requested advertisement %#x, phy supported %#x\n",
+ 		  cmd->advertising, pdata->phy.supported);
+ 
+ 	cmd->advertising &= pdata->phy.supported;
+ 	if ((cmd->autoneg == AUTONEG_ENABLE) && !cmd->advertising) {
+ 		netdev_err(netdev,
+ 			   "unsupported requested advertisement\n");
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  		return -EINVAL;
+ 	}
  
  	ret = 0;
 -	pdata->phy.autoneg = cmd->autoneg;
 -	pdata->phy.speed = speed;
 -	pdata->phy.duplex = cmd->duplex;
 -	pdata->phy.advertising = cmd->advertising;
 +	phydev->autoneg = cmd->autoneg;
 +	phydev->speed = speed;
 +	phydev->duplex = cmd->duplex;
 +	phydev->advertising = cmd->advertising;
  
  	if (cmd->autoneg == AUTONEG_ENABLE)
 -		pdata->phy.advertising |= ADVERTISED_Autoneg;
 +		phydev->advertising |= ADVERTISED_Autoneg;
  	else
 -		pdata->phy.advertising &= ~ADVERTISED_Autoneg;
 +		phydev->advertising &= ~ADVERTISED_Autoneg;
  
  	if (netif_running(netdev))
 -		ret = pdata->phy_if.phy_config_aneg(pdata);
 +		ret = phy_start_aneg(phydev);
  
- 	DBGPR("<--xgbe_set_settings\n");
- 
  	return ret;
  }
  
@@@ -397,11 -401,8 +429,9 @@@ static int xgbe_get_coalesce(struct net
  	ec->rx_coalesce_usecs = pdata->rx_usecs;
  	ec->rx_max_coalesced_frames = pdata->rx_frames;
  
 +	ec->tx_coalesce_usecs = pdata->tx_usecs;
  	ec->tx_max_coalesced_frames = pdata->tx_frames;
  
- 	DBGPR("<--xgbe_get_coalesce\n");
- 
  	return 0;
  }
  
@@@ -411,10 -412,8 +441,8 @@@ static int xgbe_set_coalesce(struct net
  	struct xgbe_prv_data *pdata = netdev_priv(netdev);
  	struct xgbe_hw_if *hw_if = &pdata->hw_if;
  	unsigned int rx_frames, rx_riwt, rx_usecs;
 -	unsigned int tx_frames;
 +	unsigned int tx_frames, tx_usecs;
  
- 	DBGPR("-->xgbe_set_coalesce\n");
- 
  	/* Check for not supported parameters  */
  	if ((ec->rx_coalesce_usecs_irq) ||
  	    (ec->rx_max_coalesced_frames_irq) ||
@@@ -433,19 -433,11 +461,21 @@@
  	    (ec->rx_max_coalesced_frames_high) ||
  	    (ec->tx_coalesce_usecs_high) ||
  	    (ec->tx_max_coalesced_frames_high) ||
- 	    (ec->rate_sample_interval))
+ 	    (ec->rate_sample_interval)) {
+ 		netdev_err(netdev, "unsupported coalescing parameter\n");
  		return -EOPNOTSUPP;
+ 	}
  
 +	/* Can only change rx-frames when interface is down (see
 +	 * rx_descriptor_init in xgbe-dev.c)
 +	 */
 +	rx_frames = pdata->rx_frames;
 +	if (rx_frames != ec->rx_max_coalesced_frames && netif_running(netdev)) {
 +		netdev_alert(netdev,
 +			     "interface must be down to change rx-frames\n");
 +		return -EINVAL;
 +	}
 +
  	rx_riwt = hw_if->usec_to_riwt(pdata, ec->rx_coalesce_usecs);
  	rx_usecs = ec->rx_coalesce_usecs;
  	rx_frames = ec->rx_max_coalesced_frames;
@@@ -456,13 -448,13 +486,19 @@@
  
  	/* Check the bounds of values for Rx */
  	if (rx_riwt > XGMAC_MAX_DMA_RIWT) {
- 		netdev_alert(netdev, "rx-usec is limited to %d usecs\n",
- 			     hw_if->riwt_to_usec(pdata, XGMAC_MAX_DMA_RIWT));
+ 		netdev_err(netdev, "rx-usec is limited to %d usecs\n",
+ 			   hw_if->riwt_to_usec(pdata, XGMAC_MAX_DMA_RIWT));
  		return -EINVAL;
  	}
++<<<<<<< HEAD
 +	if (rx_frames > pdata->channel->rx_ring->rdesc_count) {
 +		netdev_alert(netdev, "rx-frames is limited to %d frames\n",
 +			     pdata->channel->rx_ring->rdesc_count);
++=======
+ 	if (rx_frames > pdata->rx_desc_count) {
+ 		netdev_err(netdev, "rx-frames is limited to %d frames\n",
+ 			   pdata->rx_desc_count);
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  		return -EINVAL;
  	}
  
@@@ -470,9 -461,9 +506,15 @@@
  	tx_frames = ec->tx_max_coalesced_frames;
  
  	/* Check the bounds of values for Tx */
++<<<<<<< HEAD
 +	if (tx_frames > pdata->channel->tx_ring->rdesc_count) {
 +		netdev_alert(netdev, "tx-frames is limited to %d frames\n",
 +			     pdata->channel->tx_ring->rdesc_count);
++=======
+ 	if (tx_frames > pdata->tx_desc_count) {
+ 		netdev_err(netdev, "tx-frames is limited to %d frames\n",
+ 			   pdata->tx_desc_count);
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  		return -EINVAL;
  	}
  
@@@ -485,11 -475,120 +527,123 @@@
  	pdata->tx_frames = tx_frames;
  	hw_if->config_tx_coalesce(pdata);
  
- 	DBGPR("<--xgbe_set_coalesce\n");
+ 	return 0;
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int xgbe_get_rxnfc(struct net_device *netdev,
+ 			  struct ethtool_rxnfc *rxnfc, u32 *rule_locs)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	switch (rxnfc->cmd) {
+ 	case ETHTOOL_GRXRINGS:
+ 		rxnfc->data = pdata->rx_ring_count;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 xgbe_get_rxfh_key_size(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	return sizeof(pdata->rss_key);
+ }
+ 
+ static u32 xgbe_get_rxfh_indir_size(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	return ARRAY_SIZE(pdata->rss_table);
+ }
+ 
+ static int xgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+ 			 u8 *hfunc)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	unsigned int i;
+ 
+ 	if (indir) {
+ 		for (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)
+ 			indir[i] = XGMAC_GET_BITS(pdata->rss_table[i],
+ 						  MAC_RSSDR, DMCH);
+ 	}
+ 
+ 	if (key)
+ 		memcpy(key, pdata->rss_key, sizeof(pdata->rss_key));
+ 
+ 	if (hfunc)
+ 		*hfunc = ETH_RSS_HASH_TOP;
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_rxfh(struct net_device *netdev, const u32 *indir,
+ 			 const u8 *key, const u8 hfunc)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned int ret;
+ 
+ 	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP) {
+ 		netdev_err(netdev, "unsupported hash function\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (indir) {
+ 		ret = hw_if->set_rss_lookup_table(pdata, indir);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (key) {
+ 		ret = hw_if->set_rss_hash_key(pdata, key);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_get_ts_info(struct net_device *netdev,
+ 			    struct ethtool_ts_info *ts_info)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	ts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |
+ 				   SOF_TIMESTAMPING_RX_SOFTWARE |
+ 				   SOF_TIMESTAMPING_SOFTWARE |
+ 				   SOF_TIMESTAMPING_TX_HARDWARE |
+ 				   SOF_TIMESTAMPING_RX_HARDWARE |
+ 				   SOF_TIMESTAMPING_RAW_HARDWARE;
+ 
+ 	if (pdata->ptp_clock)
+ 		ts_info->phc_index = ptp_clock_index(pdata->ptp_clock);
+ 	else
+ 		ts_info->phc_index = -1;
+ 
+ 	ts_info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
+ 	ts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_ALL);
  
  	return 0;
  }
  
++>>>>>>> e5dd8b811078 (amd-xgbe: Add ethtool error and debug messages)
  static const struct ethtool_ops xgbe_ethtool_ops = {
  	.get_settings = xgbe_get_settings,
  	.set_settings = xgbe_set_settings,
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
