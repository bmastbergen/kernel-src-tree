ethtool: Remove link_mode param and derive link params from driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Danielle Ratson <danieller@nvidia.com>
commit a975d7d8a356ce92872af0b007b101183f0224e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/a975d7d8.failed

Some drivers clear the 'ethtool_link_ksettings' struct in their
get_link_ksettings() callback, before populating it with actual values.
Such drivers will set the new 'link_mode' field to zero, resulting in
user space receiving wrong link mode information given that zero is a
valid value for the field.

Another problem is that some drivers (notably tun) can report random
values in the 'link_mode' field. This can result in a general protection
fault when the field is used as an index to the 'link_mode_params' array
[1].

This happens because such drivers implement their set_link_ksettings()
callback by simply overwriting their private copy of
'ethtool_link_ksettings' struct with the one they get from the stack,
which is not always properly initialized.

Fix these problems by removing 'link_mode' from 'ethtool_link_ksettings'
and instead have drivers call ethtool_params_from_link_mode() with the
current link mode. The function will derive the link parameters (e.g.,
speed) from the link mode and fill them in the 'ethtool_link_ksettings'
struct.

v3:
	* Remove link_mode parameter and derive the link parameters in
	  the driver instead of passing link_mode parameter to ethtool
	  and derive it there.

v2:
	* Introduce 'cap_link_mode_supported' instead of adding a
	  validity field to 'ethtool_link_ksettings' struct.

[1]
general protection fault, probably for non-canonical address 0xdffffc00f14cc32c: 0000 [#1] PREEMPT SMP KASAN
KASAN: probably user-memory-access in range [0x000000078a661960-0x000000078a661967]
CPU: 0 PID: 8452 Comm: syz-executor360 Not tainted 5.11.0-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
RIP: 0010:__ethtool_get_link_ksettings+0x1a3/0x3a0 net/ethtool/ioctl.c:446
Code: b7 3e fa 83 fd ff 0f 84 30 01 00 00 e8 16 b0 3e fa 48 8d 3c ed 60 d5 69 8a 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <0f> b6 14 02 48 89 f8 83 e0 07 83 c0 03
+38 d0 7c 08 84 d2 0f 85 b9
RSP: 0018:ffffc900019df7a0 EFLAGS: 00010202
RAX: dffffc0000000000 RBX: ffff888026136008 RCX: 0000000000000000
RDX: 00000000f14cc32c RSI: ffffffff873439ca RDI: 000000078a661960
RBP: 00000000ffff8880 R08: 00000000ffffffff R09: ffff88802613606f
R10: ffffffff873439bc R11: 0000000000000000 R12: 0000000000000000
R13: ffff88802613606c R14: ffff888011d0c210 R15: ffff888011d0c210
FS:  0000000000749300(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000004b60f0 CR3: 00000000185c2000 CR4: 00000000001506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 linkinfo_prepare_data+0xfd/0x280 net/ethtool/linkinfo.c:37
 ethnl_default_notify+0x1dc/0x630 net/ethtool/netlink.c:586
 ethtool_notify+0xbd/0x1f0 net/ethtool/netlink.c:656
 ethtool_set_link_ksettings+0x277/0x330 net/ethtool/ioctl.c:620
 dev_ethtool+0x2b35/0x45d0 net/ethtool/ioctl.c:2842
 dev_ioctl+0x463/0xb70 net/core/dev_ioctl.c:440
 sock_do_ioctl+0x148/0x2d0 net/socket.c:1060
 sock_ioctl+0x477/0x6a0 net/socket.c:1177
 vfs_ioctl fs/ioctl.c:48 [inline]
 __do_sys_ioctl fs/ioctl.c:753 [inline]
 __se_sys_ioctl fs/ioctl.c:739 [inline]
 __x64_sys_ioctl+0x193/0x200 fs/ioctl.c:739
 do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46
 entry_SYSCALL_64_after_hwframe+0x44/0xa9

Fixes: c8907043c6ac9 ("ethtool: Get link mode in use instead of speed and duplex parameters")
	Signed-off-by: Danielle Ratson <danieller@nvidia.com>
	Reported-by: Eric Dumazet <eric.dumazet@gmail.com>
	Reviewed-by: Ido Schimmel <idosch@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a975d7d8a356ce92872af0b007b101183f0224e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ethtool.h
#	net/ethtool/ioctl.c
diff --cc include/linux/ethtool.h
index a7a4f19e9241,cdca84e6dd6b..000000000000
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@@ -128,6 -126,7 +128,10 @@@ struct ethtool_link_ksettings 
  		__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
  		__ETHTOOL_DECLARE_LINK_MODE_MASK(lp_advertising);
  	} link_modes;
++<<<<<<< HEAD
++=======
+ 	u32	lanes;
++>>>>>>> a975d7d8a356 (ethtool: Remove link_mode param and derive link params from driver)
  };
  
  /**
@@@ -621,13 -573,12 +625,24 @@@ struct ethtool_phy_ops 
   */
  void ethtool_set_ethtool_phy_ops(const struct ethtool_phy_ops *ops);
  
++<<<<<<< HEAD
 +/**
 + * ethtool_sprintf - Write formatted string to ethtool string data
 + * @data: Pointer to start of string to update
 + * @fmt: Format of string to write
 + *
 + * Write formatted string to data. Update data to point at start of
 + * next string.
 + */
 +extern __printf(2, 3) void ethtool_sprintf(u8 **data, const char *fmt, ...);
++=======
+ /*
+  * ethtool_params_from_link_mode - Derive link parameters from a given link mode
+  * @link_ksettings: Link parameters to be derived from the link mode
+  * @link_mode: Link mode
+  */
+ void
+ ethtool_params_from_link_mode(struct ethtool_link_ksettings *link_ksettings,
+ 			      enum ethtool_link_mode_bit_indices link_mode);
++>>>>>>> a975d7d8a356 (ethtool: Remove link_mode param and derive link params from driver)
  #endif /* _LINUX_ETHTOOL_H */
diff --cc net/ethtool/ioctl.c
index 4e254a1ffe3b,771688e1b0da..000000000000
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@@ -438,33 -426,13 +438,43 @@@ struct ethtool_link_usettings 
  int __ethtool_get_link_ksettings(struct net_device *dev,
  				 struct ethtool_link_ksettings *link_ksettings)
  {
++<<<<<<< HEAD
 +	int err;
 +	struct ethtool_cmd cmd;
 +
 +	ASSERT_RTNL();
 +
 +	if (__rh_has_get_link_ksettings(dev)) {
 +		memset(link_ksettings, 0, sizeof(*link_ksettings));
 +		return __rh_call_get_link_ksettings(dev, link_ksettings);
 +	}
 +
 +	/* driver doesn't support %ethtool_link_ksettings API. revert to
 +	 * legacy %ethtool_cmd API, unless it's not supported either.
 +	 * TODO: remove when ethtool_ops::get_settings disappears internally
 +	 */
 +	if (!dev->ethtool_ops->get_settings)
 +		return -EOPNOTSUPP;
 +
 +	memset(&cmd, 0, sizeof(cmd));
 +	cmd.cmd = ETHTOOL_GSET;
 +	err = dev->ethtool_ops->get_settings(dev, &cmd);
 +	if (err < 0)
 +		return err;
 +
 +	/* we ignore deprecated fields transceiver/maxrxpkt/maxtxpkt
 +	 */
 +	convert_legacy_settings_to_link_ksettings(link_ksettings, &cmd);
 +	return err;
++=======
+ 	ASSERT_RTNL();
+ 
+ 	if (!dev->ethtool_ops->get_link_ksettings)
+ 		return -EOPNOTSUPP;
+ 
+ 	memset(link_ksettings, 0, sizeof(*link_ksettings));
+ 	return dev->ethtool_ops->get_link_ksettings(dev, link_ksettings);
++>>>>>>> a975d7d8a356 (ethtool: Remove link_mode param and derive link params from driver)
  }
  EXPORT_SYMBOL(__ethtool_get_link_ksettings);
  
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_ethtool.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_ethtool.c
index bd7f873f6290..bf49a7e9d677 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_ethtool.c
@@ -1225,16 +1225,22 @@ mlxsw_sp1_from_ptys_link_mode(struct mlxsw_sp *mlxsw_sp, bool carrier_ok,
 			      u32 ptys_eth_proto,
 			      struct ethtool_link_ksettings *cmd)
 {
+	struct mlxsw_sp1_port_link_mode link;
 	int i;
 
-	cmd->link_mode = -1;
+	cmd->base.speed = SPEED_UNKNOWN;
+	cmd->base.duplex = DUPLEX_UNKNOWN;
+	cmd->lanes = 0;
 
 	if (!carrier_ok)
 		return;
 
 	for (i = 0; i < MLXSW_SP1_PORT_LINK_MODE_LEN; i++) {
-		if (ptys_eth_proto & mlxsw_sp1_port_link_mode[i].mask)
-			cmd->link_mode = mlxsw_sp1_port_link_mode[i].mask_ethtool;
+		if (ptys_eth_proto & mlxsw_sp1_port_link_mode[i].mask) {
+			link = mlxsw_sp1_port_link_mode[i];
+			ethtool_params_from_link_mode(cmd,
+						      link.mask_ethtool);
+		}
 	}
 }
 
@@ -1667,7 +1673,9 @@ mlxsw_sp2_from_ptys_link_mode(struct mlxsw_sp *mlxsw_sp, bool carrier_ok,
 	struct mlxsw_sp2_port_link_mode link;
 	int i;
 
-	cmd->link_mode = -1;
+	cmd->base.speed = SPEED_UNKNOWN;
+	cmd->base.duplex = DUPLEX_UNKNOWN;
+	cmd->lanes = 0;
 
 	if (!carrier_ok)
 		return;
@@ -1675,7 +1683,8 @@ mlxsw_sp2_from_ptys_link_mode(struct mlxsw_sp *mlxsw_sp, bool carrier_ok,
 	for (i = 0; i < MLXSW_SP2_PORT_LINK_MODE_LEN; i++) {
 		if (ptys_eth_proto & mlxsw_sp2_port_link_mode[i].mask) {
 			link = mlxsw_sp2_port_link_mode[i];
-			cmd->link_mode = link.mask_ethtool[1];
+			ethtool_params_from_link_mode(cmd,
+						      link.mask_ethtool[1]);
 		}
 	}
 }
* Unmerged path include/linux/ethtool.h
diff --git a/net/ethtool/common.c b/net/ethtool/common.c
index 94b9b3252ee9..e3969df40189 100644
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@ -397,3 +397,19 @@ void ethtool_set_ethtool_phy_ops(const struct ethtool_phy_ops *ops)
 	rtnl_unlock();
 }
 EXPORT_SYMBOL_GPL(ethtool_set_ethtool_phy_ops);
+
+void
+ethtool_params_from_link_mode(struct ethtool_link_ksettings *link_ksettings,
+			      enum ethtool_link_mode_bit_indices link_mode)
+{
+	const struct link_mode_info *link_info;
+
+	if (WARN_ON_ONCE(link_mode >= __ETHTOOL_LINK_MODE_MASK_NBITS))
+		return;
+
+	link_info = &link_mode_params[link_mode];
+	link_ksettings->base.speed = link_info->speed;
+	link_ksettings->lanes = link_info->lanes;
+	link_ksettings->base.duplex = link_info->duplex;
+}
+EXPORT_SYMBOL_GPL(ethtool_params_from_link_mode);
* Unmerged path net/ethtool/ioctl.c
