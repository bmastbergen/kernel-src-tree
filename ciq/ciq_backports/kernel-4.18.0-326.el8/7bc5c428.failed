dma-direct: remove __dma_to_phys

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 7bc5c428a660d4d1bc95ba54bf4cb6bccf8c3029
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/7bc5c428.failed

There is no harm in just always clearing the SME encryption bit, while
significantly simplifying the interface.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Robin Murphy <robin.murphy@arm.com>
(cherry picked from commit 7bc5c428a660d4d1bc95ba54bf4cb6bccf8c3029)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/mips/bmips/dma.c
#	arch/mips/cavium-octeon/dma-octeon.c
#	arch/mips/include/asm/dma-direct.h
#	arch/mips/loongson2ef/fuloong-2e/dma.c
#	arch/mips/loongson2ef/lemote-2f/dma.c
#	arch/mips/loongson64/dma.c
#	arch/mips/pci/pci-ar2315.c
#	arch/mips/pci/pci-xtalk-bridge.c
#	arch/mips/sgi-ip32/ip32-dma.c
diff --cc arch/mips/bmips/dma.c
index 6dec30842b2f,ba2a5d33dfd3..000000000000
--- a/arch/mips/bmips/dma.c
+++ b/arch/mips/bmips/dma.c
@@@ -52,17 -52,7 +52,21 @@@ static dma_addr_t bmips_phys_to_dma(str
  	return pa;
  }
  
++<<<<<<< HEAD
 +dma_addr_t plat_map_dma_mem(struct device *dev, void *addr, size_t size)
 +{
 +	return bmips_phys_to_dma(dev, virt_to_phys(addr));
 +}
 +
 +dma_addr_t plat_map_dma_mem_page(struct device *dev, struct page *page)
 +{
 +	return bmips_phys_to_dma(dev, page_to_phys(page));
 +}
 +
 +unsigned long plat_dma_addr_to_phys(struct device *dev, dma_addr_t dma_addr)
++=======
+ phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dma_addr)
++>>>>>>> 7bc5c428a660 (dma-direct: remove __dma_to_phys)
  {
  	struct bmips_dma_range *r;
  
diff --cc arch/mips/cavium-octeon/dma-octeon.c
index a598807e1e94,388b13ba2558..000000000000
--- a/arch/mips/cavium-octeon/dma-octeon.c
+++ b/arch/mips/cavium-octeon/dma-octeon.c
@@@ -171,8 -173,16 +171,12 @@@ static dma_addr_t octeon_unity_phys_to_
  	return paddr;
  }
  
++<<<<<<< HEAD
 +static phys_addr_t octeon_unity_dma_to_phys(struct device *dev, dma_addr_t daddr)
++=======
+ phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr)
++>>>>>>> 7bc5c428a660 (dma-direct: remove __dma_to_phys)
  {
 -#ifdef CONFIG_PCI
 -	if (dev && dev_is_pci(dev))
 -		return octeon_pci_dma_ops->dma_to_phys(dev, daddr);
 -#endif
  	return daddr;
  }
  
diff --cc arch/mips/include/asm/dma-direct.h
index f32f15530aba,8e178651c638..000000000000
--- a/arch/mips/include/asm/dma-direct.h
+++ b/arch/mips/include/asm/dma-direct.h
@@@ -1,1 -1,8 +1,12 @@@
++<<<<<<< HEAD
 +#include <asm/dma-coherence.h>
++=======
+ /* SPDX-License-Identifier: GPL-2.0 */
+ #ifndef _MIPS_DMA_DIRECT_H
+ #define _MIPS_DMA_DIRECT_H 1
+ 
+ dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr);
+ phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr);
+ 
+ #endif /* _MIPS_DMA_DIRECT_H */
++>>>>>>> 7bc5c428a660 (dma-direct: remove __dma_to_phys)
diff --cc arch/mips/pci/pci-ar2315.c
index b4fa6413c4e5,d88395684f48..000000000000
--- a/arch/mips/pci/pci-ar2315.c
+++ b/arch/mips/pci/pci-ar2315.c
@@@ -167,6 -163,23 +167,26 @@@ struct ar2315_pci_ctrl 
  	struct resource io_res;
  };
  
++<<<<<<< HEAD
++=======
+ static inline dma_addr_t ar2315_dev_offset(struct device *dev)
+ {
+ 	if (dev && dev_is_pci(dev))
+ 		return AR2315_PCI_HOST_SDRAM_BASEADDR;
+ 	return 0;
+ }
+ 
+ dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
+ {
+ 	return paddr + ar2315_dev_offset(dev);
+ }
+ 
+ phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dma_addr)
+ {
+ 	return dma_addr - ar2315_dev_offset(dev);
+ }
+ 
++>>>>>>> 7bc5c428a660 (dma-direct: remove __dma_to_phys)
  static inline struct ar2315_pci_ctrl *ar2315_pci_bus_to_apc(struct pci_bus *bus)
  {
  	struct pci_controller *hose = bus->sysdata;
* Unmerged path arch/mips/loongson2ef/fuloong-2e/dma.c
* Unmerged path arch/mips/loongson2ef/lemote-2f/dma.c
* Unmerged path arch/mips/loongson64/dma.c
* Unmerged path arch/mips/pci/pci-xtalk-bridge.c
* Unmerged path arch/mips/sgi-ip32/ip32-dma.c
diff --git a/arch/arm/include/asm/dma-direct.h b/arch/arm/include/asm/dma-direct.h
index b67e5fc1fe43..49c4f19334da 100644
--- a/arch/arm/include/asm/dma-direct.h
+++ b/arch/arm/include/asm/dma-direct.h
@@ -8,7 +8,7 @@ static inline dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
 	return pfn_to_dma(dev, __phys_to_pfn(paddr)) + offset;
 }
 
-static inline phys_addr_t __dma_to_phys(struct device *dev, dma_addr_t dev_addr)
+static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dev_addr)
 {
 	unsigned int offset = dev_addr & ~PAGE_MASK;
 	return __pfn_to_phys(dma_to_pfn(dev, dev_addr)) + offset;
* Unmerged path arch/mips/bmips/dma.c
* Unmerged path arch/mips/cavium-octeon/dma-octeon.c
* Unmerged path arch/mips/include/asm/dma-direct.h
* Unmerged path arch/mips/loongson2ef/fuloong-2e/dma.c
* Unmerged path arch/mips/loongson2ef/lemote-2f/dma.c
* Unmerged path arch/mips/loongson64/dma.c
* Unmerged path arch/mips/pci/pci-ar2315.c
* Unmerged path arch/mips/pci/pci-xtalk-bridge.c
* Unmerged path arch/mips/sgi-ip32/ip32-dma.c
diff --git a/arch/powerpc/include/asm/dma-direct.h b/arch/powerpc/include/asm/dma-direct.h
index e29e8a236b8d..73159340c9f4 100644
--- a/arch/powerpc/include/asm/dma-direct.h
+++ b/arch/powerpc/include/asm/dma-direct.h
@@ -9,7 +9,7 @@ static inline dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
 	return paddr + dev->archdata.dma_offset;
 }
 
-static inline phys_addr_t __dma_to_phys(struct device *dev, dma_addr_t daddr)
+static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr)
 {
 	if (!dev)
 		return daddr - PCI_DRAM_OFFSET;
diff --git a/include/linux/dma-direct.h b/include/linux/dma-direct.h
index 627dda026934..2de6d1ed2e40 100644
--- a/include/linux/dma-direct.h
+++ b/include/linux/dma-direct.h
@@ -24,11 +24,12 @@ static inline dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
 	return dev_addr - ((dma_addr_t)dev->dma_pfn_offset << PAGE_SHIFT);
 }
 
-static inline phys_addr_t __dma_to_phys(struct device *dev, dma_addr_t dev_addr)
+static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dev_addr)
 {
-	phys_addr_t paddr = (phys_addr_t)dev_addr;
+	phys_addr_t paddr = (phys_addr_t)dev_addr +
+		((phys_addr_t)dev->dma_pfn_offset << PAGE_SHIFT);
 
-	return paddr + ((phys_addr_t)dev->dma_pfn_offset << PAGE_SHIFT);
+	return __sme_clr(paddr);
 }
 #endif /* !CONFIG_ARCH_HAS_PHYS_TO_DMA */
 
@@ -44,7 +45,7 @@ static inline bool force_dma_unencrypted(struct device *dev)
 /*
  * If memory encryption is supported, phys_to_dma will set the memory encryption
  * bit in the DMA address, and dma_to_phys will clear it.  The raw __phys_to_dma
- * and __dma_to_phys versions should only be used on non-encrypted memory for
+ * version should only be used on non-encrypted memory for
  * special occasions like DMA coherent buffers.
  */
 static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
@@ -52,11 +53,6 @@ static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
 	return __sme_set(__phys_to_dma(dev, paddr));
 }
 
-static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr)
-{
-	return __sme_clr(__dma_to_phys(dev, daddr));
-}
-
 static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size,
 		bool is_ram)
 {
diff --git a/kernel/dma/direct.c b/kernel/dma/direct.c
index b992d9926af3..7bbfe05f4540 100644
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -48,11 +48,6 @@ static gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,
 {
 	u64 dma_limit = min_not_zero(dma_mask, dev->bus_dma_limit);
 
-	if (force_dma_unencrypted(dev))
-		*phys_limit = __dma_to_phys(dev, dma_limit);
-	else
-		*phys_limit = dma_to_phys(dev, dma_limit);
-
 	/*
 	 * Optimistically try the zone that the physical address mask falls
 	 * into first.  If that returns memory that isn't actually addressable
@@ -61,6 +56,7 @@ static gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,
 	 * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding
 	 * zones.
 	 */
+	*phys_limit = dma_to_phys(dev, dma_limit);
 	if (*phys_limit <= DMA_BIT_MASK(zone_dma_bits))
 		return GFP_DMA;
 	if (*phys_limit <= DMA_BIT_MASK(32))
