net/mlx5: E-Switch, Protect changing mode while adding rules

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 7dc84de98babc709910947b24e8cd1c2e01c7857
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/7dc84de9.failed

We re-use the native NIC port net device instance for the Uplink
representor, a driver currently cannot unbind TC setup callback
actively, hence protect changing E-Switch mode while adding rules.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Parav Pandit <parav@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 7dc84de98babc709910947b24e8cd1c2e01c7857)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 288fbfd3c714,6b260dacf853..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -2527,4 -2574,103 +2529,102 @@@ bool mlx5_esw_multipath_prereq(struct m
  		dev1->priv.eswitch->mode == MLX5_ESWITCH_OFFLOADS);
  }
  
 -int mlx5_esw_event_notifier_register(struct mlx5_eswitch *esw, struct notifier_block *nb)
 -{
 -	return blocking_notifier_chain_register(&esw->n_head, nb);
 -}
  
++<<<<<<< HEAD
++=======
+ void mlx5_esw_event_notifier_unregister(struct mlx5_eswitch *esw, struct notifier_block *nb)
+ {
+ 	blocking_notifier_chain_unregister(&esw->n_head, nb);
+ }
+ 
+ /**
+  * mlx5_esw_hold() - Try to take a read lock on esw mode lock.
+  * @mdev: mlx5 core device.
+  *
+  * Should be called by esw resources callers.
+  *
+  * Return: true on success or false.
+  */
+ bool mlx5_esw_hold(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	/* e.g. VF doesn't have eswitch so nothing to do */
+ 	if (!ESW_ALLOWED(esw))
+ 		return true;
+ 
+ 	if (down_read_trylock(&esw->mode_lock) != 0)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /**
+  * mlx5_esw_release() - Release a read lock on esw mode lock.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_release(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (ESW_ALLOWED(esw))
+ 		up_read(&esw->mode_lock);
+ }
+ 
+ /**
+  * mlx5_esw_get() - Increase esw user count.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_get(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (ESW_ALLOWED(esw))
+ 		atomic64_inc(&esw->user_count);
+ }
+ 
+ /**
+  * mlx5_esw_put() - Decrease esw user count.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_put(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (ESW_ALLOWED(esw))
+ 		atomic64_dec_if_positive(&esw->user_count);
+ }
+ 
+ /**
+  * mlx5_esw_try_lock() - Take a write lock on esw mode lock.
+  * @esw: eswitch device.
+  *
+  * Should be called by esw mode change routine.
+  *
+  * Return:
+  * * 0       - esw mode if successfully locked and refcount is 0.
+  * * -EBUSY  - refcount is not 0.
+  * * -EINVAL - In the middle of switching mode or lock is already held.
+  */
+ int mlx5_esw_try_lock(struct mlx5_eswitch *esw)
+ {
+ 	if (down_write_trylock(&esw->mode_lock) == 0)
+ 		return -EINVAL;
+ 
+ 	if (atomic64_read(&esw->user_count) > 0) {
+ 		up_write(&esw->mode_lock);
+ 		return -EBUSY;
+ 	}
+ 
+ 	return esw->mode;
+ }
+ 
+ /**
+  * mlx5_esw_unlock() - Release write lock on esw mode lock
+  * @esw: eswitch device.
+  */
+ void mlx5_esw_unlock(struct mlx5_eswitch *esw)
+ {
+ 	up_write(&esw->mode_lock);
+ }
++>>>>>>> 7dc84de98bab (net/mlx5: E-Switch, Protect changing mode while adding rules)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 56dee7425530,56d85cedb9bd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -738,6 -747,29 +739,32 @@@ int mlx5_esw_offloads_sf_vport_enable(s
  				      u16 vport_num, u32 sfnum);
  void mlx5_esw_offloads_sf_vport_disable(struct mlx5_eswitch *esw, u16 vport_num);
  
++<<<<<<< HEAD
++=======
+ int mlx5_esw_vport_vhca_id_set(struct mlx5_eswitch *esw, u16 vport_num);
+ void mlx5_esw_vport_vhca_id_clear(struct mlx5_eswitch *esw, u16 vport_num);
+ int mlx5_eswitch_vhca_id_to_vport(struct mlx5_eswitch *esw, u16 vhca_id, u16 *vport_num);
+ 
+ /**
+  * mlx5_esw_event_info - Indicates eswitch mode changed/changing.
+  *
+  * @new_mode: New mode of eswitch.
+  */
+ struct mlx5_esw_event_info {
+ 	u16 new_mode;
+ };
+ 
+ int mlx5_esw_event_notifier_register(struct mlx5_eswitch *esw, struct notifier_block *n);
+ void mlx5_esw_event_notifier_unregister(struct mlx5_eswitch *esw, struct notifier_block *n);
+ 
+ bool mlx5_esw_hold(struct mlx5_core_dev *dev);
+ void mlx5_esw_release(struct mlx5_core_dev *dev);
+ void mlx5_esw_get(struct mlx5_core_dev *dev);
+ void mlx5_esw_put(struct mlx5_core_dev *dev);
+ int mlx5_esw_try_lock(struct mlx5_eswitch *esw);
+ void mlx5_esw_unlock(struct mlx5_eswitch *esw);
+ 
++>>>>>>> 7dc84de98bab (net/mlx5: E-Switch, Protect changing mode while adding rules)
  #else  /* CONFIG_MLX5_ESWITCH */
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 8d4d2686ea65..8fac43ba2976 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -4836,6 +4836,11 @@ int mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,
 	struct mlx5e_tc_flow *flow;
 	int err = 0;
 
+	if (!mlx5_esw_hold(priv->mdev))
+		return -EAGAIN;
+
+	mlx5_esw_get(priv->mdev);
+
 	rcu_read_lock();
 	flow = rhashtable_lookup(tc_ht, &f->cookie, tc_ht_params);
 	if (flow) {
@@ -4873,11 +4878,14 @@ int mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,
 	if (err)
 		goto err_free;
 
+	mlx5_esw_release(priv->mdev);
 	return 0;
 
 err_free:
 	mlx5e_flow_put(priv, flow);
 out:
+	mlx5_esw_put(priv->mdev);
+	mlx5_esw_release(priv->mdev);
 	return err;
 }
 
@@ -4917,6 +4925,7 @@ int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
 	trace_mlx5e_delete_flower(f);
 	mlx5e_flow_put(priv, flow);
 
+	mlx5_esw_put(priv->mdev);
 	return 0;
 
 errout:
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index f7bb42e9f1b0..2150c7a2d375 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -1545,6 +1545,7 @@ static void esw_destroy_offloads_fdb_tables(struct mlx5_eswitch *esw)
 	/* Holds true only as long as DMFS is the default */
 	mlx5_flow_namespace_set_mode(esw->fdb_table.offloads.ns,
 				     MLX5_FLOW_STEERING_MODE_DMFS);
+	atomic64_set(&esw->user_count, 0);
 }
 
 static int esw_create_offloads_table(struct mlx5_eswitch *esw)
@@ -2263,6 +2264,7 @@ static int esw_offloads_steering_init(struct mlx5_eswitch *esw)
 	memset(&esw->fdb_table.offloads, 0, sizeof(struct offloads_fdb));
 	mutex_init(&esw->fdb_table.offloads.vports.lock);
 	hash_init(esw->fdb_table.offloads.vports.table);
+	atomic64_set(&esw->user_count, 0);
 
 	indir = mlx5_esw_indir_table_init();
 	if (IS_ERR(indir)) {
@@ -2604,8 +2606,14 @@ int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode,
 	if (esw_mode_from_devlink(mode, &mlx5_mode))
 		return -EINVAL;
 
-	down_write(&esw->mode_lock);
-	cur_mlx5_mode = esw->mode;
+	err = mlx5_esw_try_lock(esw);
+	if (err < 0) {
+		NL_SET_ERR_MSG_MOD(extack, "Can't change mode, E-Switch is busy");
+		return err;
+	}
+	cur_mlx5_mode = err;
+	err = 0;
+
 	if (cur_mlx5_mode == mlx5_mode)
 		goto unlock;
 
@@ -2617,7 +2625,7 @@ int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode,
 		err = -EINVAL;
 
 unlock:
-	up_write(&esw->mode_lock);
+	mlx5_esw_unlock(esw);
 	return err;
 }
 
