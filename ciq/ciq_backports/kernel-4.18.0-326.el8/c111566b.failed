PM: runtime: Add pm_runtime_get_if_active()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Sakari Ailus <sakari.ailus@linux.intel.com>
commit c111566bea7ccd8a05e2c56f1fb3cbb6f4b7b441
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/c111566b.failed

pm_runtime_get_if_in_use() bumps up the PM-runtime usage count if it
is not equal to zero and the device's PM-runtime status is 'active'.
This works for drivers that do not use autoidle, but for those that
do, the function returns zero even when the device is active.

In order to maintain sane device state while the device is powered on
in the hope that it'll be needed, pm_runtime_get_if_active(dev, true)
returns a positive value if the device's PM-runtime status is 'active'
when it is called, in which case it also increments the device's usage
count.

If the second argument of pm_runtime_get_if_active() is 'false', the
function behaves just like pm_runtime_get_if_in_use(), so redefine
the latter as a wrapper around the former.

	Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
[ rjw: Changelog ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit c111566bea7ccd8a05e2c56f1fb3cbb6f4b7b441)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/runtime.c
diff --cc drivers/base/power/runtime.c
index da974fcde82d,99c7da112c95..000000000000
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@@ -1084,13 -1112,22 +1094,28 @@@ int pm_runtime_get_if_active(struct dev
  	int retval;
  
  	spin_lock_irqsave(&dev->power.lock, flags);
++<<<<<<< HEAD
 +	retval = dev->power.disable_depth > 0 ? -EINVAL :
 +		dev->power.runtime_status == RPM_ACTIVE
 +			&& atomic_inc_not_zero(&dev->power.usage_count);
++=======
+ 	if (dev->power.disable_depth > 0) {
+ 		retval = -EINVAL;
+ 	} else if (dev->power.runtime_status != RPM_ACTIVE) {
+ 		retval = 0;
+ 	} else if (ign_usage_count) {
+ 		retval = 1;
+ 		atomic_inc(&dev->power.usage_count);
+ 	} else {
+ 		retval = atomic_inc_not_zero(&dev->power.usage_count);
+ 	}
+ 	trace_rpm_usage_rcuidle(dev, 0);
++>>>>>>> c111566bea7c (PM: runtime: Add pm_runtime_get_if_active())
  	spin_unlock_irqrestore(&dev->power.lock, flags);
+ 
  	return retval;
  }
- EXPORT_SYMBOL_GPL(pm_runtime_get_if_in_use);
+ EXPORT_SYMBOL_GPL(pm_runtime_get_if_active);
  
  /**
   * __pm_runtime_set_status - Set runtime PM status of a device.
diff --git a/Documentation/power/runtime_pm.rst b/Documentation/power/runtime_pm.rst
index ab8406c84254..0553008b6279 100644
--- a/Documentation/power/runtime_pm.rst
+++ b/Documentation/power/runtime_pm.rst
@@ -382,6 +382,12 @@ drivers/base/power/runtime.c and include/linux/pm_runtime.h:
       nonzero, increment the counter and return 1; otherwise return 0 without
       changing the counter
 
+  `int pm_runtime_get_if_active(struct device *dev, bool ign_usage_count);`
+    - return -EINVAL if 'power.disable_depth' is nonzero; otherwise, if the
+      runtime PM status is RPM_ACTIVE, and either ign_usage_count is true
+      or the device's usage_count is non-zero, increment the counter and
+      return 1; otherwise return 0 without changing the counter
+
   `void pm_runtime_put_noidle(struct device *dev);`
     - decrement the device's usage counter
 
* Unmerged path drivers/base/power/runtime.c
diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index d47970716320..6d2125465ffd 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -39,7 +39,7 @@ extern int pm_runtime_force_resume(struct device *dev);
 extern int __pm_runtime_idle(struct device *dev, int rpmflags);
 extern int __pm_runtime_suspend(struct device *dev, int rpmflags);
 extern int __pm_runtime_resume(struct device *dev, int rpmflags);
-extern int pm_runtime_get_if_in_use(struct device *dev);
+extern int pm_runtime_get_if_active(struct device *dev, bool ign_usage_count);
 extern int pm_schedule_suspend(struct device *dev, unsigned int delay);
 extern int __pm_runtime_set_status(struct device *dev, unsigned int status);
 extern int pm_runtime_barrier(struct device *dev);
@@ -61,6 +61,11 @@ extern void pm_runtime_put_suppliers(struct device *dev);
 extern void pm_runtime_new_link(struct device *dev);
 extern void pm_runtime_drop_link(struct device *dev);
 
+static inline int pm_runtime_get_if_in_use(struct device *dev)
+{
+	return pm_runtime_get_if_active(dev, false);
+}
+
 static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
 {
 	dev->power.ignore_children = enable;
@@ -144,6 +149,11 @@ static inline int pm_runtime_get_if_in_use(struct device *dev)
 {
 	return -EINVAL;
 }
+static inline int pm_runtime_get_if_active(struct device *dev,
+					   bool ign_usage_count)
+{
+	return -EINVAL;
+}
 static inline int __pm_runtime_set_status(struct device *dev,
 					    unsigned int status) { return 0; }
 static inline int pm_runtime_barrier(struct device *dev) { return 0; }
