ionic: set up hw timestamp queues

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Shannon Nelson <snelson@pensando.io>
commit f0790bcd36063f2850301982f167128139a51f62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/f0790bcd.failed

We do hardware timestamping through a separate Tx queue,
and optionally through a separate Rx queue.  These queues
are allocated, freed, and tracked separately from the basic
queue arrays.

	Signed-off-by: Allen Hubbe <allenbh@pensando.io>
	Signed-off-by: Shannon Nelson <snelson@pensando.io>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f0790bcd36063f2850301982f167128139a51f62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/pensando/ionic/ionic_lif.c
diff --cc drivers/net/ethernet/pensando/ionic/ionic_lif.c
index ff3f4b510503,26c066ed74c4..000000000000
--- a/drivers/net/ethernet/pensando/ionic/ionic_lif.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_lif.c
@@@ -827,6 -830,254 +827,257 @@@ static int ionic_lif_rxq_init(struct io
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int ionic_lif_create_hwstamp_txq(struct ionic_lif *lif)
+ {
+ 	unsigned int num_desc, desc_sz, comp_sz, sg_desc_sz;
+ 	unsigned int txq_i, flags;
+ 	struct ionic_qcq *txq;
+ 	u64 features;
+ 	int err;
+ 
+ 	mutex_lock(&lif->queue_lock);
+ 
+ 	if (lif->hwstamp_txq)
+ 		goto out;
+ 
+ 	features = IONIC_Q_F_2X_CQ_DESC | IONIC_TXQ_F_HWSTAMP;
+ 
+ 	num_desc = IONIC_MIN_TXRX_DESC;
+ 	desc_sz = sizeof(struct ionic_txq_desc);
+ 	comp_sz = 2 * sizeof(struct ionic_txq_comp);
+ 
+ 	if (lif->qtype_info[IONIC_QTYPE_TXQ].version >= 1 &&
+ 	    lif->qtype_info[IONIC_QTYPE_TXQ].sg_desc_sz == sizeof(struct ionic_txq_sg_desc_v1))
+ 		sg_desc_sz = sizeof(struct ionic_txq_sg_desc_v1);
+ 	else
+ 		sg_desc_sz = sizeof(struct ionic_txq_sg_desc);
+ 
+ 	txq_i = lif->ionic->ntxqs_per_lif;
+ 	flags = IONIC_QCQ_F_TX_STATS | IONIC_QCQ_F_SG;
+ 
+ 	err = ionic_qcq_alloc(lif, IONIC_QTYPE_TXQ, txq_i, "hwstamp_tx", flags,
+ 			      num_desc, desc_sz, comp_sz, sg_desc_sz,
+ 			      lif->kern_pid, &txq);
+ 	if (err)
+ 		goto err_qcq_alloc;
+ 
+ 	txq->q.features = features;
+ 
+ 	ionic_link_qcq_interrupts(lif->adminqcq, txq);
+ 	ionic_debugfs_add_qcq(lif, txq);
+ 
+ 	lif->hwstamp_txq = txq;
+ 
+ 	if (netif_running(lif->netdev)) {
+ 		err = ionic_lif_txq_init(lif, txq);
+ 		if (err)
+ 			goto err_qcq_init;
+ 
+ 		if (test_bit(IONIC_LIF_F_UP, lif->state)) {
+ 			err = ionic_qcq_enable(txq);
+ 			if (err)
+ 				goto err_qcq_enable;
+ 		}
+ 	}
+ 
+ out:
+ 	mutex_unlock(&lif->queue_lock);
+ 
+ 	return 0;
+ 
+ err_qcq_enable:
+ 	ionic_lif_qcq_deinit(lif, txq);
+ err_qcq_init:
+ 	lif->hwstamp_txq = NULL;
+ 	ionic_debugfs_del_qcq(txq);
+ 	ionic_qcq_free(lif, txq);
+ 	devm_kfree(lif->ionic->dev, txq);
+ err_qcq_alloc:
+ 	mutex_unlock(&lif->queue_lock);
+ 	return err;
+ }
+ 
+ int ionic_lif_create_hwstamp_rxq(struct ionic_lif *lif)
+ {
+ 	unsigned int num_desc, desc_sz, comp_sz, sg_desc_sz;
+ 	unsigned int rxq_i, flags;
+ 	struct ionic_qcq *rxq;
+ 	u64 features;
+ 	int err;
+ 
+ 	mutex_lock(&lif->queue_lock);
+ 
+ 	if (lif->hwstamp_rxq)
+ 		goto out;
+ 
+ 	features = IONIC_Q_F_2X_CQ_DESC | IONIC_RXQ_F_HWSTAMP;
+ 
+ 	num_desc = IONIC_MIN_TXRX_DESC;
+ 	desc_sz = sizeof(struct ionic_rxq_desc);
+ 	comp_sz = 2 * sizeof(struct ionic_rxq_comp);
+ 	sg_desc_sz = sizeof(struct ionic_rxq_sg_desc);
+ 
+ 	rxq_i = lif->ionic->nrxqs_per_lif;
+ 	flags = IONIC_QCQ_F_RX_STATS | IONIC_QCQ_F_SG;
+ 
+ 	err = ionic_qcq_alloc(lif, IONIC_QTYPE_RXQ, rxq_i, "hwstamp_rx", flags,
+ 			      num_desc, desc_sz, comp_sz, sg_desc_sz,
+ 			      lif->kern_pid, &rxq);
+ 	if (err)
+ 		goto err_qcq_alloc;
+ 
+ 	rxq->q.features = features;
+ 
+ 	ionic_link_qcq_interrupts(lif->adminqcq, rxq);
+ 	ionic_debugfs_add_qcq(lif, rxq);
+ 
+ 	lif->hwstamp_rxq = rxq;
+ 
+ 	if (netif_running(lif->netdev)) {
+ 		err = ionic_lif_rxq_init(lif, rxq);
+ 		if (err)
+ 			goto err_qcq_init;
+ 
+ 		if (test_bit(IONIC_LIF_F_UP, lif->state)) {
+ 			ionic_rx_fill(&rxq->q);
+ 			err = ionic_qcq_enable(rxq);
+ 			if (err)
+ 				goto err_qcq_enable;
+ 		}
+ 	}
+ 
+ out:
+ 	mutex_unlock(&lif->queue_lock);
+ 
+ 	return 0;
+ 
+ err_qcq_enable:
+ 	ionic_lif_qcq_deinit(lif, rxq);
+ err_qcq_init:
+ 	lif->hwstamp_rxq = NULL;
+ 	ionic_debugfs_del_qcq(rxq);
+ 	ionic_qcq_free(lif, rxq);
+ 	devm_kfree(lif->ionic->dev, rxq);
+ err_qcq_alloc:
+ 	mutex_unlock(&lif->queue_lock);
+ 	return err;
+ }
+ 
+ int ionic_lif_config_hwstamp_rxq_all(struct ionic_lif *lif, bool rx_all)
+ {
+ 	struct ionic_queue_params qparam;
+ 
+ 	ionic_init_queue_params(lif, &qparam);
+ 
+ 	if (rx_all)
+ 		qparam.rxq_features = IONIC_Q_F_2X_CQ_DESC | IONIC_RXQ_F_HWSTAMP;
+ 	else
+ 		qparam.rxq_features = 0;
+ 
+ 	/* if we're not running, just set the values and return */
+ 	if (!netif_running(lif->netdev)) {
+ 		lif->rxq_features = qparam.rxq_features;
+ 		return 0;
+ 	}
+ 
+ 	return ionic_reconfigure_queues(lif, &qparam);
+ }
+ 
+ int ionic_lif_set_hwstamp_txmode(struct ionic_lif *lif, u16 txstamp_mode)
+ {
+ 	struct ionic_admin_ctx ctx = {
+ 		.work = COMPLETION_INITIALIZER_ONSTACK(ctx.work),
+ 		.cmd.lif_setattr = {
+ 			.opcode = IONIC_CMD_LIF_SETATTR,
+ 			.index = cpu_to_le16(lif->index),
+ 			.attr = IONIC_LIF_ATTR_TXSTAMP,
+ 			.txstamp_mode = cpu_to_le16(txstamp_mode),
+ 		},
+ 	};
+ 
+ 	return ionic_adminq_post_wait(lif, &ctx);
+ }
+ 
+ static void ionic_lif_del_hwstamp_rxfilt(struct ionic_lif *lif)
+ {
+ 	struct ionic_admin_ctx ctx = {
+ 		.work = COMPLETION_INITIALIZER_ONSTACK(ctx.work),
+ 		.cmd.rx_filter_del = {
+ 			.opcode = IONIC_CMD_RX_FILTER_DEL,
+ 			.lif_index = cpu_to_le16(lif->index),
+ 		},
+ 	};
+ 	struct ionic_rx_filter *f;
+ 	u32 filter_id;
+ 	int err;
+ 
+ 	spin_lock_bh(&lif->rx_filters.lock);
+ 
+ 	f = ionic_rx_filter_rxsteer(lif);
+ 	if (!f) {
+ 		spin_unlock_bh(&lif->rx_filters.lock);
+ 		return;
+ 	}
+ 
+ 	filter_id = f->filter_id;
+ 	ionic_rx_filter_free(lif, f);
+ 
+ 	spin_unlock_bh(&lif->rx_filters.lock);
+ 
+ 	netdev_dbg(lif->netdev, "rx_filter del RXSTEER (id %d)\n", filter_id);
+ 
+ 	ctx.cmd.rx_filter_del.filter_id = cpu_to_le32(filter_id);
+ 
+ 	err = ionic_adminq_post_wait(lif, &ctx);
+ 	if (err && err != -EEXIST)
+ 		netdev_dbg(lif->netdev, "failed to delete rx_filter RXSTEER (id %d)\n", filter_id);
+ }
+ 
+ static int ionic_lif_add_hwstamp_rxfilt(struct ionic_lif *lif, u64 pkt_class)
+ {
+ 	struct ionic_admin_ctx ctx = {
+ 		.work = COMPLETION_INITIALIZER_ONSTACK(ctx.work),
+ 		.cmd.rx_filter_add = {
+ 			.opcode = IONIC_CMD_RX_FILTER_ADD,
+ 			.lif_index = cpu_to_le16(lif->index),
+ 			.match = cpu_to_le16(IONIC_RX_FILTER_STEER_PKTCLASS),
+ 			.pkt_class = cpu_to_le64(pkt_class),
+ 		},
+ 	};
+ 	u8 qtype;
+ 	u32 qid;
+ 	int err;
+ 
+ 	if (!lif->hwstamp_rxq)
+ 		return -EINVAL;
+ 
+ 	qtype = lif->hwstamp_rxq->q.type;
+ 	ctx.cmd.rx_filter_add.qtype = qtype;
+ 
+ 	qid = lif->hwstamp_rxq->q.index;
+ 	ctx.cmd.rx_filter_add.qid = cpu_to_le32(qid);
+ 
+ 	netdev_dbg(lif->netdev, "rx_filter add RXSTEER\n");
+ 	err = ionic_adminq_post_wait(lif, &ctx);
+ 	if (err && err != -EEXIST)
+ 		return err;
+ 
+ 	return ionic_rx_filter_save(lif, 0, qid, 0, &ctx);
+ }
+ 
+ int ionic_lif_set_hwstamp_rxfilt(struct ionic_lif *lif, u64 pkt_class)
+ {
+ 	ionic_lif_del_hwstamp_rxfilt(lif);
+ 
+ 	if (!pkt_class)
+ 		return 0;
+ 
+ 	return ionic_lif_add_hwstamp_rxfilt(lif, pkt_class);
+ }
+ 
++>>>>>>> f0790bcd3606 (ionic: set up hw timestamp queues)
  static bool ionic_notifyq_service(struct ionic_cq *cq,
  				  struct ionic_cq_info *cq_info)
  {
* Unmerged path drivers/net/ethernet/pensando/ionic/ionic_lif.c
