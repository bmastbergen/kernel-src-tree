drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Gerd Hoffmann <kraxel@redhat.com>
commit f7ed28e13f82710b4b17049bf5d6cf9e818eb23c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/f7ed28e1.failed

Append _locked to Make clear that these functions should be called with
reserved bo's only.  While being at it also rename kmap -> vmap.

No functional change.

	Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
	Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
Link: http://patchwork.freedesktop.org/patch/msgid/20210217123213.2199186-6-kraxel@redhat.com
(cherry picked from commit f7ed28e13f82710b4b17049bf5d6cf9e818eb23c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/qxl/qxl_display.c
#	drivers/gpu/drm/qxl/qxl_draw.c
#	drivers/gpu/drm/qxl/qxl_object.c
#	drivers/gpu/drm/qxl/qxl_object.h
#	drivers/gpu/drm/qxl/qxl_prime.c
diff --cc drivers/gpu/drm/qxl/qxl_display.c
index 59ef1f0c985d,bfcc93089a94..000000000000
--- a/drivers/gpu/drm/qxl/qxl_display.c
+++ b/drivers/gpu/drm/qxl/qxl_display.c
@@@ -595,9 -600,10 +595,13 @@@ static void qxl_cursor_atomic_update(st
  		user_bo = gem_to_qxl_bo(obj);
  
  		/* pinning is done in the prepare/cleanup framevbuffer */
++<<<<<<< HEAD
 +		ret = qxl_bo_kmap(user_bo, &user_ptr);
++=======
+ 		ret = qxl_bo_vmap_locked(user_bo, &user_map);
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  		if (ret)
  			goto out_free_release;
 -		user_ptr = user_map.vaddr; /* TODO: Use mapping abstraction properly */
  
  		ret = qxl_alloc_bo_reserved(qdev, release,
  					    sizeof(struct qxl_cursor) + size,
@@@ -613,9 -619,13 +617,13 @@@
  		if (ret)
  			goto out_unpin;
  
++<<<<<<< HEAD
 +		ret = qxl_bo_kmap(cursor_bo, (void **)&cursor);
++=======
+ 		ret = qxl_bo_vmap_locked(cursor_bo, &cursor_map);
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  		if (ret)
  			goto out_backoff;
 -		if (cursor_map.is_iomem) /* TODO: Use mapping abstraction properly */
 -			cursor = (struct qxl_cursor __force *)cursor_map.vaddr_iomem;
 -		else
 -			cursor = (struct qxl_cursor *)cursor_map.vaddr;
  
  		cursor->header.unique = 0;
  		cursor->header.type = SPICE_CURSOR_TYPE_ALPHA;
@@@ -1154,7 -1163,7 +1162,11 @@@ int qxl_create_monitors_object(struct q
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	qxl_bo_kmap(qdev->monitors_config_bo, NULL);
++=======
+ 	qxl_bo_vmap_locked(qdev->monitors_config_bo, &map);
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  
  	qdev->monitors_config = qdev->monitors_config_bo->kptr;
  	qdev->ram_header->monitors_config =
diff --cc drivers/gpu/drm/qxl/qxl_draw.c
index 3599db096973,7d27891e87fa..000000000000
--- a/drivers/gpu/drm/qxl/qxl_draw.c
+++ b/drivers/gpu/drm/qxl/qxl_draw.c
@@@ -45,10 -47,12 +45,15 @@@ static struct qxl_rect *drawable_set_cl
  	struct qxl_clip_rects *dev_clips;
  	int ret;
  
++<<<<<<< HEAD
 +	ret = qxl_bo_kmap(clips_bo, (void **)&dev_clips);
 +	if (ret) {
++=======
+ 	ret = qxl_bo_vmap_locked(clips_bo, &map);
+ 	if (ret)
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  		return NULL;
 -	dev_clips = map.vaddr; /* TODO: Use mapping abstraction properly */
 -
 +	}
  	dev_clips->num_rects = num_clips;
  	dev_clips->chunk.next_chunk = 0;
  	dev_clips->chunk.prev_chunk = 0;
@@@ -197,9 -202,10 +202,13 @@@ void qxl_draw_dirty_fb(struct qxl_devic
  	if (ret)
  		goto out_release_backoff;
  
++<<<<<<< HEAD
 +	ret = qxl_bo_kmap(bo, (void **)&surface_base);
++=======
+ 	ret = qxl_bo_vmap_locked(bo, &surface_map);
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  	if (ret)
  		goto out_release_backoff;
 -	surface_base = surface_map.vaddr; /* TODO: Use mapping abstraction properly */
  
  	ret = qxl_image_init(qdev, release, dimage, surface_base,
  			     left - dumb_shadow_offset,
diff --cc drivers/gpu/drm/qxl/qxl_object.c
index 80e7a17aaddd,f4a015381a7f..000000000000
--- a/drivers/gpu/drm/qxl/qxl_object.c
+++ b/drivers/gpu/drm/qxl/qxl_object.c
@@@ -143,9 -155,8 +143,13 @@@ int qxl_bo_create(struct qxl_device *qd
  	return 0;
  }
  
++<<<<<<< HEAD
 +int qxl_bo_kmap(struct qxl_bo *bo, void **ptr)
++=======
+ int qxl_bo_vmap_locked(struct qxl_bo *bo, struct dma_buf_map *map)
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  {
 +	bool is_iomem;
  	int r;
  
  	if (bo->kptr) {
@@@ -187,9 -203,10 +191,13 @@@ fallback
  		return rptr;
  	}
  
++<<<<<<< HEAD
 +	ret = qxl_bo_kmap(bo, &rptr);
++=======
+ 	ret = qxl_bo_vmap_locked(bo, &bo_map);
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  	if (ret)
  		return NULL;
 -	rptr = bo_map.vaddr; /* TODO: Use mapping abstraction properly */
  
  	rptr += page_offset * PAGE_SIZE;
  	return rptr;
diff --cc drivers/gpu/drm/qxl/qxl_object.h
index 21fa81048f4f,2495e5cdf353..000000000000
--- a/drivers/gpu/drm/qxl/qxl_object.h
+++ b/drivers/gpu/drm/qxl/qxl_object.h
@@@ -84,10 -61,11 +84,15 @@@ static inline int qxl_bo_wait(struct qx
  extern int qxl_bo_create(struct qxl_device *qdev,
  			 unsigned long size,
  			 bool kernel, bool pinned, u32 domain,
 -			 u32 priority,
  			 struct qxl_surface *surf,
  			 struct qxl_bo **bo_ptr);
++<<<<<<< HEAD
 +extern int qxl_bo_kmap(struct qxl_bo *bo, void **ptr);
 +extern void qxl_bo_kunmap(struct qxl_bo *bo);
++=======
+ int qxl_bo_vmap_locked(struct qxl_bo *bo, struct dma_buf_map *map);
+ void qxl_bo_vunmap_locked(struct qxl_bo *bo);
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  void *qxl_bo_kmap_atomic_page(struct qxl_device *qdev, struct qxl_bo *bo, int page_offset);
  void qxl_bo_kunmap_atomic_page(struct qxl_device *qdev, struct qxl_bo *bo, void *map);
  extern struct qxl_bo *qxl_bo_ref(struct qxl_bo *bo);
diff --cc drivers/gpu/drm/qxl/qxl_prime.c
index 7d3816fca5a8,2bebe662516f..000000000000
--- a/drivers/gpu/drm/qxl/qxl_prime.c
+++ b/drivers/gpu/drm/qxl/qxl_prime.c
@@@ -54,20 -54,20 +54,24 @@@ struct drm_gem_object *qxl_gem_prime_im
  	return ERR_PTR(-ENOSYS);
  }
  
 -int qxl_gem_prime_vmap(struct drm_gem_object *obj, struct dma_buf_map *map)
 +void *qxl_gem_prime_vmap(struct drm_gem_object *obj)
  {
  	struct qxl_bo *bo = gem_to_qxl_bo(obj);
 +	void *ptr;
  	int ret;
  
++<<<<<<< HEAD
 +	ret = qxl_bo_kmap(bo, &ptr);
++=======
+ 	ret = qxl_bo_vmap_locked(bo, map);
++>>>>>>> f7ed28e13f82 (drm/qxl: rename qxl_bo_kmap -> qxl_bo_vmap_locked)
  	if (ret < 0)
 -		return ret;
 +		return ERR_PTR(ret);
  
 -	return 0;
 +	return ptr;
  }
  
 -void qxl_gem_prime_vunmap(struct drm_gem_object *obj,
 -			  struct dma_buf_map *map)
 +void qxl_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr)
  {
  	struct qxl_bo *bo = gem_to_qxl_bo(obj);
  
* Unmerged path drivers/gpu/drm/qxl/qxl_display.c
* Unmerged path drivers/gpu/drm/qxl/qxl_draw.c
diff --git a/drivers/gpu/drm/qxl/qxl_image.c b/drivers/gpu/drm/qxl/qxl_image.c
index 60ab7151b84d..ffff54e5fb31 100644
--- a/drivers/gpu/drm/qxl/qxl_image.c
+++ b/drivers/gpu/drm/qxl/qxl_image.c
@@ -186,7 +186,7 @@ qxl_image_init_helper(struct qxl_device *qdev,
 			}
 		}
 	}
-	qxl_bo_kunmap(chunk_bo);
+	qxl_bo_vunmap_locked(chunk_bo);
 
 	image_bo = dimage->bo;
 	ptr = qxl_bo_kmap_atomic_page(qdev, image_bo, 0);
* Unmerged path drivers/gpu/drm/qxl/qxl_object.c
* Unmerged path drivers/gpu/drm/qxl/qxl_object.h
* Unmerged path drivers/gpu/drm/qxl/qxl_prime.c
