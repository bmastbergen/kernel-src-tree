NFS: Fix open coded versions of nfs_set_cache_invalid() in NFSv4

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit b6f80a2ebb97f184c4679518ac83074598bf9bf4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/b6f80a2e.failed

nfs_set_cache_invalid() has code to handle delegations, and other
optimisations, so let's use it when appropriate.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit b6f80a2ebb97f184c4679518ac83074598bf9bf4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42proc.c
diff --cc fs/nfs/nfs42proc.c
index d425d0044860,094024b0aca1..000000000000
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@@ -306,10 -357,16 +306,19 @@@ static ssize_t _nfs42_proc_copy(struct 
  	truncate_pagecache_range(dst_inode, pos_dst,
  				 pos_dst + res->write_res.count);
  	spin_lock(&dst_inode->i_lock);
- 	NFS_I(dst_inode)->cache_validity |= (NFS_INO_REVAL_PAGECACHE |
- 			NFS_INO_REVAL_FORCED | NFS_INO_INVALID_SIZE |
- 			NFS_INO_INVALID_ATTR | NFS_INO_INVALID_DATA);
+ 	nfs_set_cache_invalid(
+ 		dst_inode, NFS_INO_REVAL_PAGECACHE | NFS_INO_REVAL_FORCED |
+ 				   NFS_INO_INVALID_SIZE | NFS_INO_INVALID_ATTR |
+ 				   NFS_INO_INVALID_DATA);
  	spin_unlock(&dst_inode->i_lock);
++<<<<<<< HEAD
++=======
+ 	spin_lock(&src_inode->i_lock);
+ 	nfs_set_cache_invalid(src_inode, NFS_INO_REVAL_PAGECACHE |
+ 						 NFS_INO_REVAL_FORCED |
+ 						 NFS_INO_INVALID_ATIME);
+ 	spin_unlock(&src_inode->i_lock);
++>>>>>>> b6f80a2ebb97 (NFS: Fix open coded versions of nfs_set_cache_invalid() in NFSv4)
  	status = res->write_res.count;
  out:
  	if (args->sync)
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index 524365a75062..78715e3f4241 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -214,6 +214,7 @@ static void nfs_set_cache_invalid(struct inode *inode, unsigned long flags)
 	if (flags & NFS_INO_INVALID_DATA)
 		nfs_fscache_invalidate(inode);
 }
+EXPORT_SYMBOL_GPL(nfs_set_cache_invalid);
 
 /*
  * Invalidate the local caches
* Unmerged path fs/nfs/nfs42proc.c
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 86577143835b..4a23e7802d8c 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1169,14 +1169,14 @@ int nfs4_call_sync(struct rpc_clnt *clnt,
 static void
 nfs4_inc_nlink_locked(struct inode *inode)
 {
-	NFS_I(inode)->cache_validity |= NFS_INO_INVALID_OTHER;
+	nfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);
 	inc_nlink(inode);
 }
 
 static void
 nfs4_dec_nlink_locked(struct inode *inode)
 {
-	NFS_I(inode)->cache_validity |= NFS_INO_INVALID_OTHER;
+	nfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);
 	drop_nlink(inode);
 }
 
@@ -1187,35 +1187,31 @@ nfs4_update_changeattr_locked(struct inode *inode,
 {
 	struct nfs_inode *nfsi = NFS_I(inode);
 
-	nfsi->cache_validity |= NFS_INO_INVALID_CTIME
-		| NFS_INO_INVALID_MTIME
-		| cache_validity;
+	cache_validity |= NFS_INO_INVALID_CTIME | NFS_INO_INVALID_MTIME;
 
 	if (cinfo->atomic && cinfo->before == inode_peek_iversion_raw(inode)) {
 		nfsi->cache_validity &= ~NFS_INO_REVAL_PAGECACHE;
 		nfsi->attrtimeo_timestamp = jiffies;
 	} else {
 		if (S_ISDIR(inode->i_mode)) {
-			nfsi->cache_validity |= NFS_INO_INVALID_DATA;
+			cache_validity |= NFS_INO_INVALID_DATA;
 			nfs_force_lookup_revalidate(inode);
 		} else {
 			if (!NFS_PROTO(inode)->have_delegation(inode,
 							       FMODE_READ))
-				nfsi->cache_validity |= NFS_INO_REVAL_PAGECACHE;
+				cache_validity |= NFS_INO_REVAL_PAGECACHE;
 		}
 
 		if (cinfo->before != inode_peek_iversion_raw(inode))
-			nfsi->cache_validity |= NFS_INO_INVALID_ACCESS |
-						NFS_INO_INVALID_ACL |
-						NFS_INO_INVALID_XATTR;
+			cache_validity |= NFS_INO_INVALID_ACCESS |
+					  NFS_INO_INVALID_ACL |
+					  NFS_INO_INVALID_XATTR;
 	}
 	inode_set_iversion_raw(inode, cinfo->after);
 	nfsi->read_cache_jiffies = timestamp;
 	nfsi->attr_gencount = nfs_inc_attr_generation_counter();
+	nfs_set_cache_invalid(inode, cache_validity);
 	nfsi->cache_validity &= ~NFS_INO_INVALID_CHANGE;
-
-	if (nfsi->cache_validity & NFS_INO_INVALID_DATA)
-		nfs_fscache_invalidate(inode);
 }
 
 void
@@ -5884,9 +5880,9 @@ static int __nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t bufl
 	 * so mark the attribute cache invalid.
 	 */
 	spin_lock(&inode->i_lock);
-	NFS_I(inode)->cache_validity |= NFS_INO_INVALID_CHANGE
-		| NFS_INO_INVALID_CTIME
-		| NFS_INO_REVAL_FORCED;
+	nfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE |
+					     NFS_INO_INVALID_CTIME |
+					     NFS_INO_REVAL_FORCED);
 	spin_unlock(&inode->i_lock);
 	nfs_access_zap_cache(inode);
 	nfs_zap_acl_cache(inode);
