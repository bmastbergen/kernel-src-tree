xfs: refactor default quota grace period setting code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit ccc8e771aa7a80eb047fc263780816ca76dd02a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/ccc8e771.failed

Refactor the code that sets the default quota grace period into a helper
function so that we can override the ondisk behavior later.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Allison Collins <allison.henderson@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit ccc8e771aa7a80eb047fc263780816ca76dd02a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_format.h
#	fs/xfs/xfs_dquot.c
#	fs/xfs/xfs_dquot.h
#	fs/xfs/xfs_qm_syscalls.c
diff --cc fs/xfs/libxfs/xfs_format.h
index e15c62640885,4b68a473b090..000000000000
--- a/fs/xfs/libxfs/xfs_format.h
+++ b/fs/xfs/libxfs/xfs_format.h
@@@ -1188,6 -1188,54 +1188,57 @@@ static inline void xfs_dinode_put_rdev(
  #define XFS_DQUOT_MAGIC		0x4451		/* 'DQ' */
  #define XFS_DQUOT_VERSION	(uint8_t)0x01	/* latest version number */
  
++<<<<<<< HEAD
++=======
+ #define XFS_DQTYPE_USER		0x01		/* user dquot record */
+ #define XFS_DQTYPE_PROJ		0x02		/* project dquot record */
+ #define XFS_DQTYPE_GROUP	0x04		/* group dquot record */
+ 
+ /* bitmask to determine if this is a user/group/project dquot */
+ #define XFS_DQTYPE_REC_MASK	(XFS_DQTYPE_USER | \
+ 				 XFS_DQTYPE_PROJ | \
+ 				 XFS_DQTYPE_GROUP)
+ 
+ #define XFS_DQTYPE_ANY		(XFS_DQTYPE_REC_MASK)
+ 
+ /*
+  * XFS Quota Timers
+  * ================
+  *
+  * Traditional quota grace period expiration timers are an unsigned 32-bit
+  * seconds counter; time zero is the Unix epoch, Jan  1 00:00:01 UTC 1970.
+  * Note that an expiration value of zero means that the quota limit has not
+  * been reached, and therefore no expiration has been set.  Therefore, the
+  * ondisk min and max defined here can be used directly to constrain the incore
+  * quota expiration timestamps on a Unix system.
+  *
+  * The grace period for each quota type is stored in the root dquot (id = 0)
+  * and is applied to a non-root dquot when it exceeds the soft or hard limits.
+  * The length of quota grace periods are unsigned 32-bit quantities measured in
+  * units of seconds.  A value of zero means to use the default period.
+  */
+ 
+ /*
+  * Smallest possible ondisk quota expiration value with traditional timestamps.
+  * This corresponds exactly with the incore expiration Jan  1 00:00:01 UTC 1970.
+  */
+ #define XFS_DQ_LEGACY_EXPIRY_MIN	((int64_t)1)
+ 
+ /*
+  * Largest possible ondisk quota expiration value with traditional timestamps.
+  * This corresponds exactly with the incore expiration Feb  7 06:28:15 UTC 2106.
+  */
+ #define XFS_DQ_LEGACY_EXPIRY_MAX	((int64_t)U32_MAX)
+ 
++>>>>>>> ccc8e771aa7a (xfs: refactor default quota grace period setting code)
+ /*
+  * Default quota grace periods, ranging from zero (use the compiled defaults)
+  * to ~136 years.  These are applied to a non-root dquot that has exceeded
+  * either limit.
+  */
+ #define XFS_DQ_GRACE_MIN		((int64_t)0)
+ #define XFS_DQ_GRACE_MAX		((int64_t)U32_MAX)
+ 
  /*
   * This is the main portion of the on-disk representation of quota information
   * for a user.  We pad this with some more expansion room to construct the on
diff --cc fs/xfs/xfs_dquot.c
index f02c86042c85,91ec6d998aef..000000000000
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@@ -98,6 -98,51 +98,54 @@@ xfs_qm_adjust_dqlimits
  		xfs_dquot_set_prealloc_limits(dq);
  }
  
++<<<<<<< HEAD
++=======
+ /* Set the expiration time of a quota's grace period. */
+ time64_t
+ xfs_dquot_set_timeout(
+ 	struct xfs_mount	*mp,
+ 	time64_t		timeout)
+ {
+ 	struct xfs_quotainfo	*qi = mp->m_quotainfo;
+ 
+ 	return clamp_t(time64_t, timeout, qi->qi_expiry_min,
+ 					  qi->qi_expiry_max);
+ }
+ 
+ /* Set the length of the default grace period. */
+ time64_t
+ xfs_dquot_set_grace_period(
+ 	time64_t		grace)
+ {
+ 	return clamp_t(time64_t, grace, XFS_DQ_GRACE_MIN, XFS_DQ_GRACE_MAX);
+ }
+ 
+ /*
+  * Determine if this quota counter is over either limit and set the quota
+  * timers as appropriate.
+  */
+ static inline void
+ xfs_qm_adjust_res_timer(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_dquot_res	*res,
+ 	struct xfs_quota_limits	*qlim)
+ {
+ 	ASSERT(res->hardlimit == 0 || res->softlimit <= res->hardlimit);
+ 
+ 	if ((res->softlimit && res->count > res->softlimit) ||
+ 	    (res->hardlimit && res->count > res->hardlimit)) {
+ 		if (res->timer == 0)
+ 			res->timer = xfs_dquot_set_timeout(mp,
+ 					ktime_get_real_seconds() + qlim->time);
+ 	} else {
+ 		if (res->timer == 0)
+ 			res->warnings = 0;
+ 		else
+ 			res->timer = 0;
+ 	}
+ }
+ 
++>>>>>>> ccc8e771aa7a (xfs: refactor default quota grace period setting code)
  /*
   * Check the limits and timers of a dquot and start or reset timers
   * if necessary.
diff --cc fs/xfs/xfs_dquot.h
index 0a5b0b61e7b1,f642884a6834..000000000000
--- a/fs/xfs/xfs_dquot.h
+++ b/fs/xfs/xfs_dquot.h
@@@ -214,9 -232,12 +214,15 @@@ static inline struct xfs_dquot *xfs_qm_
  	return dqp;
  }
  
 -typedef int (*xfs_qm_dqiterate_fn)(struct xfs_dquot *dq,
 -		xfs_dqtype_t type, void *priv);
 -int xfs_qm_dqiterate(struct xfs_mount *mp, xfs_dqtype_t type,
 +typedef int (*xfs_qm_dqiterate_fn)(struct xfs_dquot *dq, uint dqtype,
 +		void *priv);
 +int xfs_qm_dqiterate(struct xfs_mount *mp, uint dqtype,
  		xfs_qm_dqiterate_fn iter_fn, void *priv);
  
++<<<<<<< HEAD
++=======
+ time64_t xfs_dquot_set_timeout(struct xfs_mount *mp, time64_t timeout);
+ time64_t xfs_dquot_set_grace_period(time64_t grace);
+ 
++>>>>>>> ccc8e771aa7a (xfs: refactor default quota grace period setting code)
  #endif /* __XFS_DQUOT_H__ */
diff --cc fs/xfs/xfs_qm_syscalls.c
index 6a5fe01070c6,ca1b57d291dc..000000000000
--- a/fs/xfs/xfs_qm_syscalls.c
+++ b/fs/xfs/xfs_qm_syscalls.c
@@@ -437,6 -437,64 +437,67 @@@ xfs_qm_scall_quotaon
  	(QC_LIMIT_MASK | QC_TIMER_MASK | QC_WARNS_MASK)
  
  /*
++<<<<<<< HEAD
++=======
+  * Adjust limits of this quota, and the defaults if passed in.  Returns true
+  * if the new limits made sense and were applied, false otherwise.
+  */
+ static inline bool
+ xfs_setqlim_limits(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_dquot_res	*res,
+ 	struct xfs_quota_limits	*qlim,
+ 	xfs_qcnt_t		hard,
+ 	xfs_qcnt_t		soft,
+ 	const char		*tag)
+ {
+ 	/* The hard limit can't be less than the soft limit. */
+ 	if (hard != 0 && hard < soft) {
+ 		xfs_debug(mp, "%shard %lld < %ssoft %lld", tag, hard, tag,
+ 				soft);
+ 		return false;
+ 	}
+ 
+ 	res->hardlimit = hard;
+ 	res->softlimit = soft;
+ 	if (qlim) {
+ 		qlim->hard = hard;
+ 		qlim->soft = soft;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static inline void
+ xfs_setqlim_warns(
+ 	struct xfs_dquot_res	*res,
+ 	struct xfs_quota_limits	*qlim,
+ 	int			warns)
+ {
+ 	res->warnings = warns;
+ 	if (qlim)
+ 		qlim->warn = warns;
+ }
+ 
+ static inline void
+ xfs_setqlim_timer(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_dquot_res	*res,
+ 	struct xfs_quota_limits	*qlim,
+ 	s64			timer)
+ {
+ 	if (qlim) {
+ 		/* Set the length of the default grace period. */
+ 		res->timer = xfs_dquot_set_grace_period(timer);
+ 		qlim->time = res->timer;
+ 	} else {
+ 		/* Set the grace period expiration on a quota. */
+ 		res->timer = xfs_dquot_set_timeout(mp, timer);
+ 	}
+ }
+ 
+ /*
++>>>>>>> ccc8e771aa7a (xfs: refactor default quota grace period setting code)
   * Adjust quota limits, and start/stop timers accordingly.
   */
  int
* Unmerged path fs/xfs/libxfs/xfs_format.h
* Unmerged path fs/xfs/xfs_dquot.c
* Unmerged path fs/xfs/xfs_dquot.h
* Unmerged path fs/xfs/xfs_qm_syscalls.c
