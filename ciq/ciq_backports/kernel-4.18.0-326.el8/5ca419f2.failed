bpf: Add BPF_FETCH field / create atomic_fetch_add instruction

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Brendan Jackman <jackmanb@google.com>
commit 5ca419f2864a2c60940dcf4bbaeb69546200e36f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5ca419f2.failed

The BPF_FETCH field can be set in bpf_insn.imm, for BPF_ATOMIC
instructions, in order to have the previous value of the
atomically-modified memory location loaded into the src register
after an atomic op is carried out.

	Suggested-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Brendan Jackman <jackmanb@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/20210114181751.768687-7-jackmanb@google.com
(cherry picked from commit 5ca419f2864a2c60940dcf4bbaeb69546200e36f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/net/bpf_jit_comp.c
#	include/linux/filter.h
#	kernel/bpf/core.c
#	kernel/bpf/disasm.c
#	kernel/bpf/verifier.c
#	tools/include/linux/filter.h
diff --cc arch/x86/net/bpf_jit_comp.c
index dd4d8265af59,eea7d8b0bb12..000000000000
--- a/arch/x86/net/bpf_jit_comp.c
+++ b/arch/x86/net/bpf_jit_comp.c
@@@ -799,6 -795,37 +799,40 @@@ static void emit_stx(u8 **pprog, u32 si
  	*pprog = prog;
  }
  
++<<<<<<< HEAD
++=======
+ static int emit_atomic(u8 **pprog, u8 atomic_op,
+ 		       u32 dst_reg, u32 src_reg, s16 off, u8 bpf_size)
+ {
+ 	u8 *prog = *pprog;
+ 	int cnt = 0;
+ 
+ 	EMIT1(0xF0); /* lock prefix */
+ 
+ 	maybe_emit_mod(&prog, dst_reg, src_reg, bpf_size == BPF_DW);
+ 
+ 	/* emit opcode */
+ 	switch (atomic_op) {
+ 	case BPF_ADD:
+ 		/* lock *(u32/u64*)(dst_reg + off) <op>= src_reg */
+ 		EMIT1(simple_alu_opcodes[atomic_op]);
+ 		break;
+ 	case BPF_ADD | BPF_FETCH:
+ 		/* src_reg = atomic_fetch_add(dst_reg + off, src_reg); */
+ 		EMIT2(0x0F, 0xC1);
+ 		break;
+ 	default:
+ 		pr_err("bpf_jit: unknown atomic opcode %02x\n", atomic_op);
+ 		return -EFAULT;
+ 	}
+ 
+ 	emit_insn_suffix(&prog, dst_reg, src_reg, off);
+ 
+ 	*pprog = prog;
+ 	return 0;
+ }
+ 
++>>>>>>> 5ca419f2864a (bpf: Add BPF_FETCH field / create atomic_fetch_add instruction)
  static bool ex_handler_bpf(const struct exception_table_entry *x,
  			   struct pt_regs *regs, int trapnr,
  			   unsigned long error_code, unsigned long fault_addr)
diff --cc include/linux/filter.h
index 3267b6630b89,23fca41b8540..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -259,11 -259,17 +259,22 @@@ static inline bool insn_is_zext(const s
  		.off   = OFF,					\
  		.imm   = 0 })
  
 +/* Atomic memory add, *(uint *)(dst_reg + off16) += src_reg */
  
++<<<<<<< HEAD
 +#define BPF_STX_XADD(SIZE, DST, SRC, OFF)			\
++=======
+ /*
+  * Atomic operations:
+  *
+  *   BPF_ADD                  *(uint *) (dst_reg + off16) += src_reg
+  *   BPF_ADD | BPF_FETCH      src_reg = atomic_fetch_add(dst_reg + off16, src_reg);
+  */
+ 
+ #define BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF)			\
++>>>>>>> 5ca419f2864a (bpf: Add BPF_FETCH field / create atomic_fetch_add instruction)
  	((struct bpf_insn) {					\
 -		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC,	\
 +		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_XADD,	\
  		.dst_reg = DST,					\
  		.src_reg = SRC,					\
  		.off   = OFF,					\
diff --cc kernel/bpf/core.c
index a915516dd706,28d6000463e4..000000000000
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@@ -1631,13 -1618,38 +1631,48 @@@ out
  	LDX_PROBE(DW, 8)
  #undef LDX_PROBE
  
++<<<<<<< HEAD
 +	STX_XADD_W: /* lock xadd *(u32 *)(dst_reg + off16) += src_reg */
 +		atomic_add((u32) SRC, (atomic_t *)(unsigned long)
 +			   (DST + insn->off));
 +		CONT;
 +	STX_XADD_DW: /* lock xadd *(u64 *)(dst_reg + off16) += src_reg */
 +		atomic64_add((u64) SRC, (atomic64_t *)(unsigned long)
 +			     (DST + insn->off));
++=======
+ 	STX_ATOMIC_W:
+ 		switch (IMM) {
+ 		case BPF_ADD:
+ 			/* lock xadd *(u32 *)(dst_reg + off16) += src_reg */
+ 			atomic_add((u32) SRC, (atomic_t *)(unsigned long)
+ 				   (DST + insn->off));
+ 			break;
+ 		case BPF_ADD | BPF_FETCH:
+ 			SRC = (u32) atomic_fetch_add(
+ 				(u32) SRC,
+ 				(atomic_t *)(unsigned long) (DST + insn->off));
+ 			break;
+ 		default:
+ 			goto default_label;
+ 		}
+ 		CONT;
+ 
+ 	STX_ATOMIC_DW:
+ 		switch (IMM) {
+ 		case BPF_ADD:
+ 			/* lock xadd *(u64 *)(dst_reg + off16) += src_reg */
+ 			atomic64_add((u64) SRC, (atomic64_t *)(unsigned long)
+ 				     (DST + insn->off));
+ 			break;
+ 		case BPF_ADD | BPF_FETCH:
+ 			SRC = (u64) atomic64_fetch_add(
+ 				(u64) SRC,
+ 				(atomic64_t *)(unsigned long) (DST + insn->off));
+ 			break;
+ 		default:
+ 			goto default_label;
+ 		}
++>>>>>>> 5ca419f2864a (bpf: Add BPF_FETCH field / create atomic_fetch_add instruction)
  		CONT;
  
  	default_label:
diff --cc kernel/bpf/disasm.c
index d9ce383c0f9c,d2e20f6d0516..000000000000
--- a/kernel/bpf/disasm.c
+++ b/kernel/bpf/disasm.c
@@@ -167,8 -160,16 +167,19 @@@ void print_bpf_insn(const struct bpf_in
  				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
  				insn->dst_reg, insn->off,
  				insn->src_reg);
++<<<<<<< HEAD
 +		else
++=======
+ 		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
+ 			   insn->imm == (BPF_ADD | BPF_FETCH)) {
+ 			verbose(cbs->private_data, "(%02x) r%d = atomic%s_fetch_add((%s *)(r%d %+d), r%d)\n",
+ 				insn->code, insn->src_reg,
+ 				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
+ 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
+ 				insn->dst_reg, insn->off, insn->src_reg);
+ 		} else {
++>>>>>>> 5ca419f2864a (bpf: Add BPF_FETCH field / create atomic_fetch_add instruction)
  			verbose(cbs->private_data, "BUG_%02x\n", insn->code);
 -		}
  	} else if (class == BPF_ST) {
  		if (BPF_MODE(insn->code) != BPF_MEM) {
  			verbose(cbs->private_data, "BUG_st_%02x\n", insn->code);
diff --cc kernel/bpf/verifier.c
index 628ac51f9efd,6aa1fc919761..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -3606,9 -3608,17 +3606,23 @@@ static int check_xadd(struct bpf_verifi
  {
  	int err;
  
++<<<<<<< HEAD
 +	if ((BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) ||
 +	    insn->imm != 0) {
 +		verbose(env, "BPF_XADD uses reserved fields\n");
++=======
+ 	switch (insn->imm) {
+ 	case BPF_ADD:
+ 	case BPF_ADD | BPF_FETCH:
+ 		break;
+ 	default:
+ 		verbose(env, "BPF_ATOMIC uses invalid atomic opcode %02x\n", insn->imm);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) {
+ 		verbose(env, "invalid atomic operand size\n");
++>>>>>>> 5ca419f2864a (bpf: Add BPF_FETCH field / create atomic_fetch_add instruction)
  		return -EINVAL;
  	}
  
@@@ -3643,9 -3653,21 +3657,27 @@@
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	/* check whether atomic_add can write into the same memory */
 +	return check_mem_access(env, insn_idx, insn->dst_reg, insn->off,
 +				BPF_SIZE(insn->code), BPF_WRITE, -1, true);
++=======
+ 	/* check whether we can write into the same memory */
+ 	err = check_mem_access(env, insn_idx, insn->dst_reg, insn->off,
+ 			       BPF_SIZE(insn->code), BPF_WRITE, -1, true);
+ 	if (err)
+ 		return err;
+ 
+ 	if (!(insn->imm & BPF_FETCH))
+ 		return 0;
+ 
+ 	/* check and record load of old value into src reg  */
+ 	err = check_reg_arg(env, insn->src_reg, DST_OP);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
++>>>>>>> 5ca419f2864a (bpf: Add BPF_FETCH field / create atomic_fetch_add instruction)
  }
  
  static int __check_stack_boundary(struct bpf_verifier_env *env, u32 regno,
@@@ -9503,8 -9544,8 +9535,13 @@@ static int do_check(struct bpf_verifier
  		} else if (class == BPF_STX) {
  			enum bpf_reg_type *prev_dst_type, dst_reg_type;
  
++<<<<<<< HEAD
 +			if (BPF_MODE(insn->code) == BPF_XADD) {
 +				err = check_xadd(env, env->insn_idx, insn);
++=======
+ 			if (BPF_MODE(insn->code) == BPF_ATOMIC) {
+ 				err = check_atomic(env, env->insn_idx, insn);
++>>>>>>> 5ca419f2864a (bpf: Add BPF_FETCH field / create atomic_fetch_add instruction)
  				if (err)
  					return err;
  				env->insn_idx++;
diff --cc tools/include/linux/filter.h
index ca28b6ab8db7,7211ce9fba53..000000000000
--- a/tools/include/linux/filter.h
+++ b/tools/include/linux/filter.h
@@@ -169,11 -169,16 +169,20 @@@
  		.off   = OFF,					\
  		.imm   = 0 })
  
++<<<<<<< HEAD
 +/* Atomic memory add, *(uint *)(dst_reg + off16) += src_reg */
++=======
+ /*
+  * Atomic operations:
+  *
+  *   BPF_ADD                  *(uint *) (dst_reg + off16) += src_reg
+  *   BPF_ADD | BPF_FETCH      src_reg = atomic_fetch_add(dst_reg + off16, src_reg);
+  */
++>>>>>>> 5ca419f2864a (bpf: Add BPF_FETCH field / create atomic_fetch_add instruction)
  
 -#define BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF)			\
 +#define BPF_STX_XADD(SIZE, DST, SRC, OFF)			\
  	((struct bpf_insn) {					\
 -		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC,	\
 +		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_XADD,	\
  		.dst_reg = DST,					\
  		.src_reg = SRC,					\
  		.off   = OFF,					\
* Unmerged path arch/x86/net/bpf_jit_comp.c
* Unmerged path include/linux/filter.h
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index a19a1e1a1ca1..d9e8fad92e16 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -43,6 +43,9 @@
 #define BPF_CALL	0x80	/* function call */
 #define BPF_EXIT	0x90	/* function return */
 
+/* atomic op type fields (stored in immediate) */
+#define BPF_FETCH	0x01	/* fetch previous value into src reg */
+
 /* Register numbers */
 enum {
 	BPF_REG_0 = 0,
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/disasm.c
* Unmerged path kernel/bpf/verifier.c
* Unmerged path tools/include/linux/filter.h
diff --git a/tools/include/uapi/linux/bpf.h b/tools/include/uapi/linux/bpf.h
index 8c3a5948ff2a..94f53bdfba05 100644
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@ -43,6 +43,9 @@
 #define BPF_CALL	0x80	/* function call */
 #define BPF_EXIT	0x90	/* function return */
 
+/* atomic op type fields (stored in immediate) */
+#define BPF_FETCH	0x01	/* fetch previous value into src reg */
+
 /* Register numbers */
 enum {
 	BPF_REG_0 = 0,
