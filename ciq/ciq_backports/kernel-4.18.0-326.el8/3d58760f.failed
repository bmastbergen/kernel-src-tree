ALSA: usb-audio: Unify the code for the next packet size calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 3d58760f4d0015cc1e7765b580daa007d759d86b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/3d58760f.failed

There are two places calculating the next packet size for the playback
stream in the exactly same way.  Provide the single helper for this
purpose and use it from both places gracefully.

	Tested-by: Keith Milner <kamilner@superlative.org>
	Tested-by: Dylan Robinson <dylan_robinson@motu.com>
Link: https://lore.kernel.org/r/20201123085347.19667-32-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 3d58760f4d0015cc1e7765b580daa007d759d86b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/endpoint.h
diff --cc sound/usb/endpoint.h
index e2fddb3dcf7a,11e3bb839fd7..000000000000
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@@ -36,14 -45,7 +36,19 @@@ void snd_usb_endpoint_release(struct sn
  void snd_usb_endpoint_free(struct snd_usb_endpoint *ep);
  
  int snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep);
++<<<<<<< HEAD
 +int snd_usb_endpoint_slave_next_packet_size(struct snd_usb_endpoint *ep);
 +int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep);
 +void snd_usb_endpoint_set_syncinterval(struct snd_usb_audio *chip,
 +				       struct snd_usb_endpoint *ep,
 +				       struct usb_host_interface *alts);
 +
 +void snd_usb_handle_sync_urb(struct snd_usb_endpoint *ep,
 +			     struct snd_usb_endpoint *sender,
 +			     const struct urb *urb);
++=======
+ int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep,
+ 				      struct snd_urb_ctx *ctx, int idx);
++>>>>>>> 3d58760f4d00 (ALSA: usb-audio: Unify the code for the next packet size calculation)
  
  #endif /* __USBAUDIO_ENDPOINT_H */
diff --git a/sound/usb/endpoint.c b/sound/usb/endpoint.c
index 208ac2aff462..53f680b967eb 100644
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@ -123,13 +123,13 @@ int snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep)
 }
 
 /*
- * For streaming based on information derived from sync endpoints,
- * prepare_outbound_urb_sizes() will call slave_next_packet_size() to
- * determine the number of samples to be sent in the next packet.
+ * Return the number of samples to be sent in the next packet
+ * for streaming based on information derived from sync endpoints
  *
- * For implicit feedback, slave_next_packet_size() is unused.
+ * This won't be used for implicit feedback which takes the packet size
+ * returned from the sync source
  */
-int snd_usb_endpoint_slave_next_packet_size(struct snd_usb_endpoint *ep)
+static int slave_next_packet_size(struct snd_usb_endpoint *ep)
 {
 	unsigned long flags;
 	int ret;
@@ -147,11 +147,10 @@ int snd_usb_endpoint_slave_next_packet_size(struct snd_usb_endpoint *ep)
 }
 
 /*
- * For adaptive and synchronous endpoints, prepare_outbound_urb_sizes()
- * will call next_packet_size() to determine the number of samples to be
- * sent in the next packet.
+ * Return the number of samples to be sent in the next packet
+ * for adaptive and synchronous endpoints
  */
-int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep)
+static int next_packet_size(struct snd_usb_endpoint *ep)
 {
 	int ret;
 
@@ -169,6 +168,21 @@ int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep)
 	return ret;
 }
 
+/*
+ * snd_usb_endpoint_next_packet_size: Return the number of samples to be sent
+ * in the next packet
+ */
+int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep,
+				      struct snd_urb_ctx *ctx, int idx)
+{
+	if (ctx->packet_size[idx])
+		return ctx->packet_size[idx];
+	else if (ep->sync_master)
+		return slave_next_packet_size(ep);
+	else
+		return next_packet_size(ep);
+}
+
 static void call_retire_callback(struct snd_usb_endpoint *ep,
 				 struct urb *urb)
 {
@@ -219,13 +233,7 @@ static void prepare_silent_urb(struct snd_usb_endpoint *ep,
 		unsigned int length;
 		int counts;
 
-		if (ctx->packet_size[i])
-			counts = ctx->packet_size[i];
-		else if (ep->sync_master)
-			counts = snd_usb_endpoint_slave_next_packet_size(ep);
-		else
-			counts = snd_usb_endpoint_next_packet_size(ep);
-
+		counts = snd_usb_endpoint_next_packet_size(ep, ctx, i);
 		length = counts * ep->stride; /* number of silent bytes */
 		offset = offs * ep->stride + extra * i;
 		urb->iso_frame_desc[i].offset = offset;
* Unmerged path sound/usb/endpoint.h
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index 6f25783cf701..902881f6e078 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -1639,13 +1639,7 @@ static void prepare_playback_urb(struct snd_usb_substream *subs,
 	spin_lock_irqsave(&subs->lock, flags);
 	subs->frame_limit += ep->max_urb_frames;
 	for (i = 0; i < ctx->packets; i++) {
-		if (ctx->packet_size[i])
-			counts = ctx->packet_size[i];
-		else if (ep->sync_master)
-			counts = snd_usb_endpoint_slave_next_packet_size(ep);
-		else
-			counts = snd_usb_endpoint_next_packet_size(ep);
-
+		counts = snd_usb_endpoint_next_packet_size(ep, ctx, i);
 		/* set up descriptor */
 		urb->iso_frame_desc[i].offset = frames * ep->stride;
 		urb->iso_frame_desc[i].length = counts * ep->stride;
