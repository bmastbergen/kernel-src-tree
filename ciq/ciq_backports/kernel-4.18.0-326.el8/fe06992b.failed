net/mlx5: Check returned value from health recover sequence

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit fe06992b04a90767cee921b22fb2cb09c93447a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/fe06992b.failed

MLX5_INTERFACE_STATE_UP is far from being reliable check for success to
recover, because it can be changed any time and health logic doesn't
have any locks to protect from it.

The locks are not needed here because health recover is good to have,
but not must to success, so rely on the returned value from the
mlx5_recover_device() as a marker for success/failure.

	Reviewed-by: Moshe Shemesh <moshe@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit fe06992b04a90767cee921b22fb2cb09c93447a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index 05b97cb32145,a0a851640804..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -317,22 -317,25 +317,26 @@@ static int mlx5_health_try_recover(stru
  {
  	unsigned long end;
  
 +	mlx5_core_warn(dev, "handling bad device here\n");
 +	mlx5_handle_bad_state(dev);
  	end = jiffies + msecs_to_jiffies(MLX5_RECOVERY_WAIT_MSECS);
  	while (sensor_pci_not_working(dev)) {
 -		if (time_after(jiffies, end))
 -			return -ETIMEDOUT;
 +		if (time_after(jiffies, end)) {
 +			mlx5_core_err(dev,
 +				      "health recovery flow aborted, PCI reads still not working\n");
 +			return -EIO;
 +		}
  		msleep(100);
  	}
 -	return 0;
 -}
  
 -static int mlx5_health_try_recover(struct mlx5_core_dev *dev)
 -{
 -	mlx5_core_warn(dev, "handling bad device here\n");
 -	mlx5_handle_bad_state(dev);
 -	if (mlx5_health_wait_pci_up(dev)) {
 -		mlx5_core_err(dev, "health recovery flow aborted, PCI reads still not working\n");
 -		return -EIO;
 -	}
  	mlx5_core_err(dev, "starting health recovery flow\n");
++<<<<<<< HEAD
 +	mlx5_recover_device(dev);
 +	if (!test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state) ||
 +	    check_fatal_sensors(dev)) {
++=======
+ 	if (mlx5_recover_device(dev) || mlx5_health_check_fatal_sensors(dev)) {
++>>>>>>> fe06992b04a9 (net/mlx5: Check returned value from health recover sequence)
  		mlx5_core_err(dev, "health recovery failed\n");
  		return -EIO;
  	}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index c11d8b42508a..daf75dc1ad54 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -1666,11 +1666,14 @@ void mlx5_disable_device(struct mlx5_core_dev *dev)
 	mlx5_unload_one(dev, false);
 }
 
-void mlx5_recover_device(struct mlx5_core_dev *dev)
+int mlx5_recover_device(struct mlx5_core_dev *dev)
 {
+	int ret = -EIO;
+
 	mlx5_pci_disable_device(dev);
 	if (mlx5_pci_slot_reset(dev->pdev) == PCI_ERS_RESULT_RECOVERED)
-		mlx5_pci_resume(dev->pdev);
+		ret = mlx5_load_one(dev);
+	return ret;
 }
 
 static struct pci_driver mlx5_core_driver = {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 210215550543..8edc7adcf9c9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -125,7 +125,7 @@ int mlx5_cmd_fast_teardown_hca(struct mlx5_core_dev *dev);
 void mlx5_enter_error_state(struct mlx5_core_dev *dev, bool force);
 void mlx5_error_sw_reset(struct mlx5_core_dev *dev);
 void mlx5_disable_device(struct mlx5_core_dev *dev);
-void mlx5_recover_device(struct mlx5_core_dev *dev);
+int mlx5_recover_device(struct mlx5_core_dev *dev);
 int mlx5_sriov_init(struct mlx5_core_dev *dev);
 void mlx5_sriov_cleanup(struct mlx5_core_dev *dev);
 int mlx5_sriov_attach(struct mlx5_core_dev *dev);
