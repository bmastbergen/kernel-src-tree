drm/i915: Split adl-s/rkl from icl_ddi_combo_{enable,disable}_clock()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 40b316d4b0865358a846ca3c9df9d443b10d3c4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/40b316d4.failed

Since .{enable,disable}_clock() are already vfuncs it's a bit silly to
have if-ladders inside them. Just provide specialized version for adl-s
and rkl so we don't need any of that.

v2: s/dev_priv/i915/ (Lucas)
    Fix typos in platform names (Lucas)

	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210205214634.19341-13-ville.syrjala@linux.intel.com
(cherry picked from commit 40b316d4b0865358a846ca3c9df9d443b10d3c4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 87726ca7041c,685fc22d6ccb..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -2816,66 -1599,170 +2816,207 @@@ static u32 icl_dpclka_cfgcr0_clk_off(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void icl_map_plls_to_ports(struct intel_encoder *encoder,
 +				  const struct intel_crtc_state *crtc_state)
++=======
+ static void _cnl_ddi_enable_clock(struct drm_i915_private *i915, i915_reg_t reg,
+ 				  u32 clk_sel_mask, u32 clk_sel, u32 clk_off)
+ {
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	intel_de_rmw(i915, reg, clk_sel_mask, clk_sel);
+ 
+ 	/*
+ 	 * "This step and the step before must be
+ 	 *  done with separate register writes."
+ 	 */
+ 	intel_de_rmw(i915, reg, clk_off, 0);
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void _cnl_ddi_disable_clock(struct drm_i915_private *i915, i915_reg_t reg,
+ 				   u32 clk_off)
+ {
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	intel_de_rmw(i915, reg, 0, clk_off);
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void adls_ddi_enable_clock(struct intel_encoder *encoder,
+ 				  const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum phy phy = intel_port_to_phy(i915, encoder->port);
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	_cnl_ddi_enable_clock(i915, ADLS_DPCLKA_CFGCR(phy),
+ 			      ADLS_DPCLKA_CFGCR_DDI_CLK_SEL_MASK(phy),
+ 			      pll->info->id << ADLS_DPCLKA_CFGCR_DDI_SHIFT(phy),
+ 			      ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ }
+ 
+ static void adls_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum phy phy = intel_port_to_phy(i915, encoder->port);
+ 
+ 	_cnl_ddi_disable_clock(i915, ADLS_DPCLKA_CFGCR(phy),
+ 			       ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ }
+ 
+ static void rkl_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum phy phy = intel_port_to_phy(i915, encoder->port);
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	_cnl_ddi_enable_clock(i915, ICL_DPCLKA_CFGCR0,
+ 			      RKL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy),
+ 			      RKL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy),
+ 			      RKL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ }
+ 
+ static void rkl_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum phy phy = intel_port_to_phy(i915, encoder->port);
+ 
+ 	_cnl_ddi_disable_clock(i915, ICL_DPCLKA_CFGCR0,
+ 			       RKL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ }
+ 
+ static void dg1_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
++>>>>>>> 40b316d4b086 (drm/i915: Split adl-s/rkl from icl_ddi_combo_{enable,disable}_clock())
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
 +	struct intel_shared_dpll *pll = crtc_state->shared_dpll;
  	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
++<<<<<<< HEAD
++=======
+ 
+ 	if (drm_WARN_ON(&dev_priv->drm, !pll))
+ 		return;
+ 
+ 	/*
+ 	 * If we fail this, something went very wrong: first 2 PLLs should be
+ 	 * used by first 2 phys and last 2 PLLs by last phys
+ 	 */
+ 	if (drm_WARN_ON(&dev_priv->drm,
+ 			(pll->info->id < DPLL_ID_DG1_DPLL2 && phy >= PHY_C) ||
+ 			(pll->info->id >= DPLL_ID_DG1_DPLL2 && phy < PHY_C)))
+ 		return;
+ 
+ 	_cnl_ddi_enable_clock(dev_priv, DG1_DPCLKA_CFGCR0(phy),
+ 			      DG1_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy),
+ 			      DG1_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy),
+ 			      DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ }
+ 
+ static void dg1_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
+ 
+ 	_cnl_ddi_disable_clock(dev_priv, DG1_DPCLKA_CFGCR0(phy),
+ 			       DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ }
+ 
+ static void icl_ddi_combo_enable_clock(struct intel_encoder *encoder,
+ 				       const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
+ 
+ 	if (drm_WARN_ON(&dev_priv->drm, !pll))
+ 		return;
+ 
+ 	_cnl_ddi_enable_clock(dev_priv, ICL_DPCLKA_CFGCR0,
+ 			      ICL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy),
+ 			      ICL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy),
+ 			      ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ }
+ 
+ static void icl_ddi_combo_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
+ 
+ 	_cnl_ddi_disable_clock(dev_priv, ICL_DPCLKA_CFGCR0,
+ 			       ICL_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ }
+ 
+ static void dg1_sanitize_port_clk_off(struct drm_i915_private *dev_priv,
+ 				      u32 port_mask, bool ddi_clk_needed)
+ {
+ 	enum port port;
++>>>>>>> 40b316d4b086 (drm/i915: Split adl-s/rkl from icl_ddi_combo_{enable,disable}_clock())
  	u32 val;
  
 -	for_each_port_masked(port, port_mask) {
 -		enum phy phy = intel_port_to_phy(dev_priv, port);
 -		bool ddi_clk_off;
 +	mutex_lock(&dev_priv->dpll.lock);
  
 -		val = intel_de_read(dev_priv, DG1_DPCLKA_CFGCR0(phy));
 -		ddi_clk_off = val & DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy);
 +	val = intel_de_read(dev_priv, ICL_DPCLKA_CFGCR0);
 +	drm_WARN_ON(&dev_priv->drm,
 +		    (val & icl_dpclka_cfgcr0_clk_off(dev_priv, phy)) == 0);
  
 -		if (ddi_clk_needed == !ddi_clk_off)
 -			continue;
 +	if (intel_phy_is_combo(dev_priv, phy)) {
 +		u32 mask, sel;
 +
 +		if (IS_ROCKETLAKE(dev_priv)) {
 +			mask = RKL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);
 +			sel = RKL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);
 +		} else {
 +			mask = ICL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);
 +			sel = ICL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);
 +		}
  
  		/*
 -		 * Punt on the case now where clock is gated, but it would
 -		 * be needed by the port. Something else is really broken then.
 +		 * Even though this register references DDIs, note that we
 +		 * want to pass the PHY rather than the port (DDI).  For
 +		 * ICL, port=phy in all cases so it doesn't matter, but for
 +		 * EHL the bspec notes the following:
 +		 *
 +		 *   "DDID clock tied to DDIA clock, so DPCLKA_CFGCR0 DDIA
 +		 *   Clock Select chooses the PLL for both DDIA and DDID and
 +		 *   drives port A in all cases."
  		 */
 -		if (drm_WARN_ON(&dev_priv->drm, ddi_clk_needed))
 -			continue;
 -
 -		drm_notice(&dev_priv->drm,
 -			   "PHY %c is disabled with an ungated DDI clock, gate it\n",
 -			   phy_name(phy));
 -		val |= DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy);
 -		intel_de_write(dev_priv, DG1_DPCLKA_CFGCR0(phy), val);
 +		val &= ~mask;
 +		val |= sel;
 +		intel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, val);
 +		intel_de_posting_read(dev_priv, ICL_DPCLKA_CFGCR0);
  	}
 +
 +	val &= ~icl_dpclka_cfgcr0_clk_off(dev_priv, phy);
 +	intel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, val);
 +
 +	mutex_unlock(&dev_priv->dpll.lock);
 +}
 +
 +static void icl_unmap_plls_to_ports(struct intel_encoder *encoder)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 +	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
 +	u32 val;
 +
 +	mutex_lock(&dev_priv->dpll.lock);
 +
 +	val = intel_de_read(dev_priv, ICL_DPCLKA_CFGCR0);
 +	val |= icl_dpclka_cfgcr0_clk_off(dev_priv, phy);
 +	intel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, val);
 +
 +	mutex_unlock(&dev_priv->dpll.lock);
  }
  
  static void icl_sanitize_port_clk_off(struct drm_i915_private *dev_priv,
@@@ -4970,6 -4158,59 +5111,62 @@@ void intel_ddi_init(struct drm_i915_pri
  	encoder->cloneable = 0;
  	encoder->pipe_mask = ~0;
  
++<<<<<<< HEAD
++=======
+ 	if (IS_ALDERLAKE_S(dev_priv)) {
+ 		encoder->enable_clock = adls_ddi_enable_clock;
+ 		encoder->disable_clock = adls_ddi_disable_clock;
+ 	} else if (IS_ROCKETLAKE(dev_priv)) {
+ 		encoder->enable_clock = rkl_ddi_enable_clock;
+ 		encoder->disable_clock = rkl_ddi_disable_clock;
+ 	} else if (IS_DG1(dev_priv)) {
+ 		encoder->enable_clock = dg1_ddi_enable_clock;
+ 		encoder->disable_clock = dg1_ddi_disable_clock;
+ 	} else if (IS_JSL_EHL(dev_priv)) {
+ 		if (intel_ddi_is_tc(dev_priv, port)) {
+ 			encoder->enable_clock = jsl_ddi_tc_enable_clock;
+ 			encoder->disable_clock = jsl_ddi_tc_disable_clock;
+ 		} else {
+ 			encoder->enable_clock = icl_ddi_combo_enable_clock;
+ 			encoder->disable_clock = icl_ddi_combo_disable_clock;
+ 		}
+ 	} else if (INTEL_GEN(dev_priv) >= 11) {
+ 		if (intel_ddi_is_tc(dev_priv, port)) {
+ 			encoder->enable_clock = icl_ddi_tc_enable_clock;
+ 			encoder->disable_clock = icl_ddi_tc_disable_clock;
+ 		} else {
+ 			encoder->enable_clock = icl_ddi_combo_enable_clock;
+ 			encoder->disable_clock = icl_ddi_combo_disable_clock;
+ 		}
+ 	} else if (IS_CANNONLAKE(dev_priv)) {
+ 		encoder->enable_clock = cnl_ddi_enable_clock;
+ 		encoder->disable_clock = cnl_ddi_disable_clock;
+ 	} else if (IS_GEN9_BC(dev_priv)) {
+ 		encoder->enable_clock = skl_ddi_enable_clock;
+ 		encoder->disable_clock = skl_ddi_disable_clock;
+ 	} else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {
+ 		encoder->enable_clock = hsw_ddi_enable_clock;
+ 		encoder->disable_clock = hsw_ddi_disable_clock;
+ 	}
+ 
+ 	if (IS_DG1(dev_priv))
+ 		encoder->hpd_pin = dg1_hpd_pin(dev_priv, port);
+ 	else if (IS_ROCKETLAKE(dev_priv))
+ 		encoder->hpd_pin = rkl_hpd_pin(dev_priv, port);
+ 	else if (INTEL_GEN(dev_priv) >= 12)
+ 		encoder->hpd_pin = tgl_hpd_pin(dev_priv, port);
+ 	else if (IS_JSL_EHL(dev_priv))
+ 		encoder->hpd_pin = ehl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 11))
+ 		encoder->hpd_pin = icl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 10))
+ 		encoder->hpd_pin = cnl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 9))
+ 		encoder->hpd_pin = skl_hpd_pin(dev_priv, port);
+ 	else
+ 		encoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);
+ 
++>>>>>>> 40b316d4b086 (drm/i915: Split adl-s/rkl from icl_ddi_combo_{enable,disable}_clock())
  	if (INTEL_GEN(dev_priv) >= 11)
  		dig_port->saved_port_bits =
  			intel_de_read(dev_priv, DDI_BUF_CTL(port))
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
