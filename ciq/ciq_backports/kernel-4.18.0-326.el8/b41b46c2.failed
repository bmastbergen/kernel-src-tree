xfs: remove the m_active_trans counter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Dave Chinner <dchinner@redhat.com>
commit b41b46c20c0bd32cd0a3795fcd2b892213cb6f5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/b41b46c2.failed

It's a global atomic counter, and we are hitting it at a rate of
half a million transactions a second, so it's bouncing the counter
cacheline all over the place on large machines. We don't actually
need it anymore - it used to be required because the VFS freeze code
could not track/prevent filesystem transactions that were running,
but that problem no longer exists.

Hence to remove the counter, we simply have to ensure that nothing
calls xfs_sync_sb() while we are trying to quiesce the filesytem.
That only happens if the log worker is still running when we call
xfs_quiesce_attr(). The log worker is cancelled at the end of
xfs_quiesce_attr() by calling xfs_log_quiesce(), so just call it
early here and then we can remove the counter altogether.

Concurrent create, 50 million inodes, identical 16p/16GB virtual
machines on different physical hosts. Machine A has twice the CPU
cores per socket of machine B:

		unpatched	patched
machine A:	3m16s		2m00s
machine B:	4m04s		4m05s

Create rates:
		unpatched	patched
machine A:	282k+/-31k	468k+/-21k
machine B:	231k+/-8k	233k+/-11k

Concurrent rm of same 50 million inodes:

		unpatched	patched
machine A:	6m42s		2m33s
machine B:	4m47s		4m47s

The transaction rate on the fast machine went from just under
300k/sec to 700k/sec, which indicates just how much of a bottleneck
this atomic counter was.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit b41b46c20c0bd32cd0a3795fcd2b892213cb6f5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_mount.h
#	fs/xfs/xfs_trans.c
diff --cc fs/xfs/xfs_mount.h
index 6bc49943ff28,3725d25ad97e..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -155,11 -176,6 +155,14 @@@ typedef struct xfs_mount 
  	uint64_t		m_resblks;	/* total reserved blocks */
  	uint64_t		m_resblks_avail;/* available reserved blocks */
  	uint64_t		m_resblks_save;	/* reserved blks @ remount,ro */
++<<<<<<< HEAD
 +	int			m_dalign;	/* stripe unit */
 +	int			m_swidth;	/* stripe width */
 +	uint8_t			m_sectbb_log;	/* sectlog - BBSHIFT */
 +	atomic_t		m_active_trans;	/* number trans frozen */
 +	struct xfs_mru_cache	*m_filestream;  /* per-mount filestream data */
++=======
++>>>>>>> b41b46c20c0b (xfs: remove the m_active_trans counter)
  	struct delayed_work	m_reclaim_work;	/* background inode reclaim */
  	struct delayed_work	m_eofblocks_work; /* background eof blocks
  						     trimming */
diff --cc fs/xfs/xfs_trans.c
index f42bd3b823d1,3c94e5ff4316..000000000000
--- a/fs/xfs/xfs_trans.c
+++ b/fs/xfs/xfs_trans.c
@@@ -276,9 -272,6 +273,12 @@@ xfs_trans_alloc
  	 */
  	WARN_ON(resp->tr_logres > 0 &&
  		mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);
++<<<<<<< HEAD
 +	ASSERT(!(flags & XFS_TRANS_RES_FDBLKS) ||
 +	       xfs_sb_version_haslazysbcount(&mp->m_sb));
 +	atomic_inc(&mp->m_active_trans);
++=======
++>>>>>>> b41b46c20c0b (xfs: remove the m_active_trans counter)
  
  	tp->t_magic = XFS_TRANS_HEADER_MAGIC;
  	tp->t_flags = flags;
* Unmerged path fs/xfs/xfs_mount.h
diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c
index a5f1e182e8c9..2a20f5a695fc 100644
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -875,8 +875,10 @@ xfs_restore_resvblks(struct xfs_mount *mp)
  * there is no log replay required to write the inodes to disk - this is the
  * primary difference between a sync and a quiesce.
  *
- * Note: xfs_log_quiesce() stops background log work - the callers must ensure
- * it is started again when appropriate.
+ * We cancel log work early here to ensure all transactions the log worker may
+ * run have finished before we clean up and log the superblock and write an
+ * unmount record. The unfreeze process is responsible for restarting the log
+ * worker correctly.
  */
 void
 xfs_quiesce_attr(
@@ -884,9 +886,7 @@ xfs_quiesce_attr(
 {
 	int	error = 0;
 
-	/* wait for all modifications to complete */
-	while (atomic_read(&mp->m_active_trans) > 0)
-		delay(100);
+	cancel_delayed_work_sync(&mp->m_log->l_work);
 
 	/* force the log to unpin objects from the now complete transactions */
 	xfs_log_force(mp, XFS_LOG_SYNC);
@@ -900,12 +900,6 @@ xfs_quiesce_attr(
 	if (error)
 		xfs_warn(mp, "xfs_attr_quiesce: failed to log sb changes. "
 				"Frozen image may not be consistent.");
-	/*
-	 * Just warn here till VFS can correctly support
-	 * read-only remount without racing.
-	 */
-	WARN_ON(atomic_read(&mp->m_active_trans) != 0);
-
 	xfs_log_quiesce(mp);
 }
 
@@ -1820,7 +1814,6 @@ static int xfs_init_fs_context(
 	INIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);
 	spin_lock_init(&mp->m_perag_lock);
 	mutex_init(&mp->m_growlock);
-	atomic_set(&mp->m_active_trans, 0);
 	INIT_WORK(&mp->m_flush_inodes_work, xfs_flush_inodes_worker);
 	INIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);
 	INIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);
* Unmerged path fs/xfs/xfs_trans.c
