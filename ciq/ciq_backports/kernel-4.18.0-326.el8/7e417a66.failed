net: napi: use READ_ONCE()/WRITE_ONCE()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 7e417a66b86c110f4b282945dac82e21e0b08328
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/7e417a66.failed

gro_flush_timeout and napi_defer_hard_irqs can be read
from napi_complete_done() while other cpus write the value,
whithout explicit synchronization.

Use READ_ONCE()/WRITE_ONCE() to annotate the races.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7e417a66b86c110f4b282945dac82e21e0b08328)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
#	net/core/net-sysfs.c
diff --cc net/core/dev.c
index 1e7b7a3fd02e,afff16849c26..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -6065,12 -6240,18 +6065,27 @@@ bool napi_complete_done(struct napi_str
  				 NAPIF_STATE_IN_BUSY_POLL)))
  		return false;
  
++<<<<<<< HEAD
 +	if (!list_empty(&n->gro_list)) {
 +		unsigned long timeout = 0;
 +
 +		if (work_done)
 +			timeout = n->dev->gro_flush_timeout;
 +
++=======
+ 	if (work_done) {
+ 		if (n->gro_bitmask)
+ 			timeout = READ_ONCE(n->dev->gro_flush_timeout);
+ 		n->defer_hard_irqs_count = READ_ONCE(n->dev->napi_defer_hard_irqs);
+ 	}
+ 	if (n->defer_hard_irqs_count > 0) {
+ 		n->defer_hard_irqs_count--;
+ 		timeout = READ_ONCE(n->dev->gro_flush_timeout);
+ 		if (timeout)
+ 			ret = false;
+ 	}
+ 	if (n->gro_bitmask) {
++>>>>>>> 7e417a66b86c (net: napi: use READ_ONCE()/WRITE_ONCE())
  		/* When the NAPI instance uses a timeout and keeps postponing
  		 * it, we need to bound somehow the time packets are kept in
  		 * the GRO layer
diff --cc net/core/net-sysfs.c
index 932caab67e72,880e89c894f6..000000000000
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@@ -387,6 -382,23 +387,26 @@@ static ssize_t gro_flush_timeout_store(
  }
  NETDEVICE_SHOW_RW(gro_flush_timeout, fmt_ulong);
  
++<<<<<<< HEAD
++=======
+ static int change_napi_defer_hard_irqs(struct net_device *dev, unsigned long val)
+ {
+ 	WRITE_ONCE(dev->napi_defer_hard_irqs, val);
+ 	return 0;
+ }
+ 
+ static ssize_t napi_defer_hard_irqs_store(struct device *dev,
+ 					  struct device_attribute *attr,
+ 					  const char *buf, size_t len)
+ {
+ 	if (!capable(CAP_NET_ADMIN))
+ 		return -EPERM;
+ 
+ 	return netdev_store(dev, attr, buf, len, change_napi_defer_hard_irqs);
+ }
+ NETDEVICE_SHOW_RW(napi_defer_hard_irqs, fmt_dec);
+ 
++>>>>>>> 7e417a66b86c (net: napi: use READ_ONCE()/WRITE_ONCE())
  static ssize_t ifalias_store(struct device *dev, struct device_attribute *attr,
  			     const char *buf, size_t len)
  {
* Unmerged path net/core/dev.c
* Unmerged path net/core/net-sysfs.c
