bpf: Add a BPF helper for getting the IMA hash of an inode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author KP Singh <kpsingh@google.com>
commit 27672f0d280a3f286a410a8db2004f46ace72a17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/27672f0d.failed

Provide a wrapper function to get the IMA hash of an inode. This helper
is useful in fingerprinting files (e.g executables on execution) and
using these fingerprints in detections like an executable unlinking
itself.

Since the ima_inode_hash can sleep, it's only allowed for sleepable
LSM hooks.

	Signed-off-by: KP Singh <kpsingh@google.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Yonghong Song <yhs@fb.com>
Link: https://lore.kernel.org/bpf/20201124151210.1081188-3-kpsingh@chromium.org
(cherry picked from commit 27672f0d280a3f286a410a8db2004f46ace72a17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/bpf_lsm.c
#	tools/include/uapi/linux/bpf.h
diff --cc include/uapi/linux/bpf.h
index 0db238cbb096,c3458ec1f30a..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -3762,6 -3743,80 +3762,83 @@@ union bpf_attr 
   * 	Return
   * 		The helper returns **TC_ACT_REDIRECT** on success or
   * 		**TC_ACT_SHOT** on error.
++<<<<<<< HEAD
++=======
+  *
+  * void *bpf_task_storage_get(struct bpf_map *map, struct task_struct *task, void *value, u64 flags)
+  *	Description
+  *		Get a bpf_local_storage from the *task*.
+  *
+  *		Logically, it could be thought of as getting the value from
+  *		a *map* with *task* as the **key**.  From this
+  *		perspective,  the usage is not much different from
+  *		**bpf_map_lookup_elem**\ (*map*, **&**\ *task*) except this
+  *		helper enforces the key must be an task_struct and the map must also
+  *		be a **BPF_MAP_TYPE_TASK_STORAGE**.
+  *
+  *		Underneath, the value is stored locally at *task* instead of
+  *		the *map*.  The *map* is used as the bpf-local-storage
+  *		"type". The bpf-local-storage "type" (i.e. the *map*) is
+  *		searched against all bpf_local_storage residing at *task*.
+  *
+  *		An optional *flags* (**BPF_LOCAL_STORAGE_GET_F_CREATE**) can be
+  *		used such that a new bpf_local_storage will be
+  *		created if one does not exist.  *value* can be used
+  *		together with **BPF_LOCAL_STORAGE_GET_F_CREATE** to specify
+  *		the initial value of a bpf_local_storage.  If *value* is
+  *		**NULL**, the new bpf_local_storage will be zero initialized.
+  *	Return
+  *		A bpf_local_storage pointer is returned on success.
+  *
+  *		**NULL** if not found or there was an error in adding
+  *		a new bpf_local_storage.
+  *
+  * long bpf_task_storage_delete(struct bpf_map *map, struct task_struct *task)
+  *	Description
+  *		Delete a bpf_local_storage from a *task*.
+  *	Return
+  *		0 on success.
+  *
+  *		**-ENOENT** if the bpf_local_storage cannot be found.
+  *
+  * struct task_struct *bpf_get_current_task_btf(void)
+  *	Description
+  *		Return a BTF pointer to the "current" task.
+  *		This pointer can also be used in helpers that accept an
+  *		*ARG_PTR_TO_BTF_ID* of type *task_struct*.
+  *	Return
+  *		Pointer to the current task.
+  *
+  * long bpf_bprm_opts_set(struct linux_binprm *bprm, u64 flags)
+  *	Description
+  *		Set or clear certain options on *bprm*:
+  *
+  *		**BPF_F_BPRM_SECUREEXEC** Set the secureexec bit
+  *		which sets the **AT_SECURE** auxv for glibc. The bit
+  *		is cleared if the flag is not specified.
+  *	Return
+  *		**-EINVAL** if invalid *flags* are passed, zero otherwise.
+  *
+  * u64 bpf_ktime_get_coarse_ns(void)
+  * 	Description
+  * 		Return a coarse-grained version of the time elapsed since
+  * 		system boot, in nanoseconds. Does not include time the system
+  * 		was suspended.
+  *
+  * 		See: **clock_gettime**\ (**CLOCK_MONOTONIC_COARSE**)
+  * 	Return
+  * 		Current *ktime*.
+  *
+  * long bpf_ima_inode_hash(struct inode *inode, void *dst, u32 size)
+  *	Description
+  *		Returns the stored IMA hash of the *inode* (if it's avaialable).
+  *		If the hash is larger than *size*, then only *size*
+  *		bytes will be copied to *dst*
+  *	Return
+  *		The **hash_algo** is returned on success,
+  *		**-EOPNOTSUP** if IMA is disabled or **-EINVAL** if
+  *		invalid arguments are passed.
++>>>>>>> 27672f0d280a (bpf: Add a BPF helper for getting the IMA hash of an inode)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -3917,9 -3972,15 +3994,18 @@@
  	FN(seq_printf_btf),		\
  	FN(skb_cgroup_classid),		\
  	FN(redirect_neigh),		\
 -	FN(bpf_per_cpu_ptr),            \
 -	FN(bpf_this_cpu_ptr),		\
 +	FN(per_cpu_ptr),		\
 +	FN(this_cpu_ptr),		\
  	FN(redirect_peer),		\
++<<<<<<< HEAD
++=======
+ 	FN(task_storage_get),		\
+ 	FN(task_storage_delete),	\
+ 	FN(get_current_task_btf),	\
+ 	FN(bprm_opts_set),		\
+ 	FN(ktime_get_coarse_ns),	\
+ 	FN(ima_inode_hash),		\
++>>>>>>> 27672f0d280a (bpf: Add a BPF helper for getting the IMA hash of an inode)
  	/* */
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
diff --cc kernel/bpf/bpf_lsm.c
index 766a0b370169,70e5e0b6d69d..000000000000
--- a/kernel/bpf/bpf_lsm.c
+++ b/kernel/bpf/bpf_lsm.c
@@@ -51,6 -53,52 +52,55 @@@ int bpf_lsm_verify_prog(struct bpf_veri
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* Mask for all the currently supported BPRM option flags */
+ #define BPF_F_BRPM_OPTS_MASK	BPF_F_BPRM_SECUREEXEC
+ 
+ BPF_CALL_2(bpf_bprm_opts_set, struct linux_binprm *, bprm, u64, flags)
+ {
+ 	if (flags & ~BPF_F_BRPM_OPTS_MASK)
+ 		return -EINVAL;
+ 
+ 	bprm->secureexec = (flags & BPF_F_BPRM_SECUREEXEC);
+ 	return 0;
+ }
+ 
+ BTF_ID_LIST_SINGLE(bpf_bprm_opts_set_btf_ids, struct, linux_binprm)
+ 
+ const static struct bpf_func_proto bpf_bprm_opts_set_proto = {
+ 	.func		= bpf_bprm_opts_set,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_BTF_ID,
+ 	.arg1_btf_id	= &bpf_bprm_opts_set_btf_ids[0],
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_3(bpf_ima_inode_hash, struct inode *, inode, void *, dst, u32, size)
+ {
+ 	return ima_inode_hash(inode, dst, size);
+ }
+ 
+ static bool bpf_ima_inode_hash_allowed(const struct bpf_prog *prog)
+ {
+ 	return bpf_lsm_is_sleepable_hook(prog->aux->attach_btf_id);
+ }
+ 
+ BTF_ID_LIST_SINGLE(bpf_ima_inode_hash_btf_ids, struct, inode)
+ 
+ const static struct bpf_func_proto bpf_ima_inode_hash_proto = {
+ 	.func		= bpf_ima_inode_hash,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_BTF_ID,
+ 	.arg1_btf_id	= &bpf_ima_inode_hash_btf_ids[0],
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.allowed	= bpf_ima_inode_hash_allowed,
+ };
+ 
++>>>>>>> 27672f0d280a (bpf: Add a BPF helper for getting the IMA hash of an inode)
  static const struct bpf_func_proto *
  bpf_lsm_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
  {
@@@ -67,6 -115,14 +117,17 @@@
  		return &bpf_spin_lock_proto;
  	case BPF_FUNC_spin_unlock:
  		return &bpf_spin_unlock_proto;
++<<<<<<< HEAD
++=======
+ 	case BPF_FUNC_task_storage_get:
+ 		return &bpf_task_storage_get_proto;
+ 	case BPF_FUNC_task_storage_delete:
+ 		return &bpf_task_storage_delete_proto;
+ 	case BPF_FUNC_bprm_opts_set:
+ 		return &bpf_bprm_opts_set_proto;
+ 	case BPF_FUNC_ima_inode_hash:
+ 		return prog->aux->sleepable ? &bpf_ima_inode_hash_proto : NULL;
++>>>>>>> 27672f0d280a (bpf: Add a BPF helper for getting the IMA hash of an inode)
  	default:
  		return tracing_prog_func_proto(func_id, prog);
  	}
diff --cc tools/include/uapi/linux/bpf.h
index b1d65d8c4595,c3458ec1f30a..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -3742,6 -3743,80 +3742,83 @@@ union bpf_attr 
   * 	Return
   * 		The helper returns **TC_ACT_REDIRECT** on success or
   * 		**TC_ACT_SHOT** on error.
++<<<<<<< HEAD
++=======
+  *
+  * void *bpf_task_storage_get(struct bpf_map *map, struct task_struct *task, void *value, u64 flags)
+  *	Description
+  *		Get a bpf_local_storage from the *task*.
+  *
+  *		Logically, it could be thought of as getting the value from
+  *		a *map* with *task* as the **key**.  From this
+  *		perspective,  the usage is not much different from
+  *		**bpf_map_lookup_elem**\ (*map*, **&**\ *task*) except this
+  *		helper enforces the key must be an task_struct and the map must also
+  *		be a **BPF_MAP_TYPE_TASK_STORAGE**.
+  *
+  *		Underneath, the value is stored locally at *task* instead of
+  *		the *map*.  The *map* is used as the bpf-local-storage
+  *		"type". The bpf-local-storage "type" (i.e. the *map*) is
+  *		searched against all bpf_local_storage residing at *task*.
+  *
+  *		An optional *flags* (**BPF_LOCAL_STORAGE_GET_F_CREATE**) can be
+  *		used such that a new bpf_local_storage will be
+  *		created if one does not exist.  *value* can be used
+  *		together with **BPF_LOCAL_STORAGE_GET_F_CREATE** to specify
+  *		the initial value of a bpf_local_storage.  If *value* is
+  *		**NULL**, the new bpf_local_storage will be zero initialized.
+  *	Return
+  *		A bpf_local_storage pointer is returned on success.
+  *
+  *		**NULL** if not found or there was an error in adding
+  *		a new bpf_local_storage.
+  *
+  * long bpf_task_storage_delete(struct bpf_map *map, struct task_struct *task)
+  *	Description
+  *		Delete a bpf_local_storage from a *task*.
+  *	Return
+  *		0 on success.
+  *
+  *		**-ENOENT** if the bpf_local_storage cannot be found.
+  *
+  * struct task_struct *bpf_get_current_task_btf(void)
+  *	Description
+  *		Return a BTF pointer to the "current" task.
+  *		This pointer can also be used in helpers that accept an
+  *		*ARG_PTR_TO_BTF_ID* of type *task_struct*.
+  *	Return
+  *		Pointer to the current task.
+  *
+  * long bpf_bprm_opts_set(struct linux_binprm *bprm, u64 flags)
+  *	Description
+  *		Set or clear certain options on *bprm*:
+  *
+  *		**BPF_F_BPRM_SECUREEXEC** Set the secureexec bit
+  *		which sets the **AT_SECURE** auxv for glibc. The bit
+  *		is cleared if the flag is not specified.
+  *	Return
+  *		**-EINVAL** if invalid *flags* are passed, zero otherwise.
+  *
+  * u64 bpf_ktime_get_coarse_ns(void)
+  * 	Description
+  * 		Return a coarse-grained version of the time elapsed since
+  * 		system boot, in nanoseconds. Does not include time the system
+  * 		was suspended.
+  *
+  * 		See: **clock_gettime**\ (**CLOCK_MONOTONIC_COARSE**)
+  * 	Return
+  * 		Current *ktime*.
+  *
+  * long bpf_ima_inode_hash(struct inode *inode, void *dst, u32 size)
+  *	Description
+  *		Returns the stored IMA hash of the *inode* (if it's avaialable).
+  *		If the hash is larger than *size*, then only *size*
+  *		bytes will be copied to *dst*
+  *	Return
+  *		The **hash_algo** is returned on success,
+  *		**-EOPNOTSUP** if IMA is disabled or **-EINVAL** if
+  *		invalid arguments are passed.
++>>>>>>> 27672f0d280a (bpf: Add a BPF helper for getting the IMA hash of an inode)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -3897,9 -3972,15 +3974,18 @@@
  	FN(seq_printf_btf),		\
  	FN(skb_cgroup_classid),		\
  	FN(redirect_neigh),		\
 -	FN(bpf_per_cpu_ptr),            \
 -	FN(bpf_this_cpu_ptr),		\
 +	FN(per_cpu_ptr),		\
 +	FN(this_cpu_ptr),		\
  	FN(redirect_peer),		\
++<<<<<<< HEAD
++=======
+ 	FN(task_storage_get),		\
+ 	FN(task_storage_delete),	\
+ 	FN(get_current_task_btf),	\
+ 	FN(bprm_opts_set),		\
+ 	FN(ktime_get_coarse_ns),	\
+ 	FN(ima_inode_hash),		\
++>>>>>>> 27672f0d280a (bpf: Add a BPF helper for getting the IMA hash of an inode)
  	/* */
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/bpf_lsm.c
diff --git a/scripts/bpf_helpers_doc.py b/scripts/bpf_helpers_doc.py
index 31484377b8b1..c238ae3c7695 100755
--- a/scripts/bpf_helpers_doc.py
+++ b/scripts/bpf_helpers_doc.py
@@ -435,6 +435,7 @@ class PrinterHelpers(Printer):
             'struct xdp_md',
             'struct path',
             'struct btf_ptr',
+            'struct inode',
     ]
     known_types = {
             '...',
@@ -478,6 +479,7 @@ class PrinterHelpers(Printer):
             'struct task_struct',
             'struct path',
             'struct btf_ptr',
+            'struct inode',
     }
     mapped_types = {
             'u8': '__u8',
* Unmerged path tools/include/uapi/linux/bpf.h
