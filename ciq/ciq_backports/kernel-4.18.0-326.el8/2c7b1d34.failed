drm/i195: Extract cnl_ddi_{enable,disable}_clock()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 2c7b1d340f194cff57373500240b3a44f20059cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/2c7b1d34.failed

Extract the DDI clock routing for CNL into the new vfuncs.

v2: s/dev_priv/i915/ (Lucas)

	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210205214634.19341-6-ville.syrjala@linux.intel.com
(cherry picked from commit 2c7b1d340f194cff57373500240b3a44f20059cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 87726ca7041c,637cc39194eb..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -2988,35 -1871,6 +2987,38 @@@ static void intel_ddi_clk_select(struc
  			 */
  			intel_de_write(dev_priv, DDI_CLK_SEL(port),
  				       DDI_CLK_SEL_MG);
++<<<<<<< HEAD
 +	} else if (IS_CANNONLAKE(dev_priv)) {
 +		/* Configure DPCLKA_CFGCR0 to map the DPLL to the DDI. */
 +		val = intel_de_read(dev_priv, DPCLKA_CFGCR0);
 +		val &= ~DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(port);
 +		val |= DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, port);
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0, val);
 +
 +		/*
 +		 * Configure DPCLKA_CFGCR0 to turn on the clock for the DDI.
 +		 * This step and the step before must be done with separate
 +		 * register writes.
 +		 */
 +		val = intel_de_read(dev_priv, DPCLKA_CFGCR0);
 +		val &= ~DPCLKA_CFGCR0_DDI_CLK_OFF(port);
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0, val);
 +	} else if (IS_GEN9_BC(dev_priv)) {
 +		/* DDI -> PLL mapping  */
 +		val = intel_de_read(dev_priv, DPLL_CTRL2);
 +
 +		val &= ~(DPLL_CTRL2_DDI_CLK_OFF(port) |
 +			 DPLL_CTRL2_DDI_CLK_SEL_MASK(port));
 +		val |= (DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |
 +			DPLL_CTRL2_DDI_SEL_OVERRIDE(port));
 +
 +		intel_de_write(dev_priv, DPLL_CTRL2, val);
 +
 +	} else if (INTEL_GEN(dev_priv) < 9) {
 +		intel_de_write(dev_priv, PORT_CLK_SEL(port),
 +			       hsw_pll_to_ddi_pll_sel(pll));
++=======
++>>>>>>> 2c7b1d340f19 (drm/i195: Extract cnl_ddi_{enable,disable}_clock())
  	}
  
  	mutex_unlock(&dev_priv->dpll.lock);
@@@ -3030,21 -1884,122 +3032,137 @@@ static void intel_ddi_clk_disable(struc
  
  	if (INTEL_GEN(dev_priv) >= 11) {
  		if (!intel_phy_is_combo(dev_priv, phy) ||
 -		    (IS_JSL_EHL(dev_priv) && port >= PORT_C))
 +		    (IS_ELKHARTLAKE(dev_priv) && port >= PORT_C))
  			intel_de_write(dev_priv, DDI_CLK_SEL(port),
  				       DDI_CLK_SEL_NONE);
++<<<<<<< HEAD
 +	} else if (IS_CANNONLAKE(dev_priv)) {
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0,
 +			       intel_de_read(dev_priv, DPCLKA_CFGCR0) | DPCLKA_CFGCR0_DDI_CLK_OFF(port));
 +	} else if (IS_GEN9_BC(dev_priv)) {
 +		intel_de_write(dev_priv, DPLL_CTRL2,
 +			       intel_de_read(dev_priv, DPLL_CTRL2) | DPLL_CTRL2_DDI_CLK_OFF(port));
 +	} else if (INTEL_GEN(dev_priv) < 9) {
 +		intel_de_write(dev_priv, PORT_CLK_SEL(port),
 +			       PORT_CLK_SEL_NONE);
 +	}
 +}
 +
++=======
+ 	}
+ }
+ 
+ static void cnl_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	val = intel_de_read(i915, DPCLKA_CFGCR0);
+ 	val &= ~DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(port);
+ 	val |= DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, port);
+ 	intel_de_write(i915, DPCLKA_CFGCR0, val);
+ 
+ 	/*
+ 	 * "This step and the step before must be
+ 	 *  done with separate register writes."
+ 	 */
+ 	val = intel_de_read(i915, DPCLKA_CFGCR0);
+ 	val &= ~DPCLKA_CFGCR0_DDI_CLK_OFF(port);
+ 	intel_de_write(i915, DPCLKA_CFGCR0, val);
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void cnl_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, DPCLKA_CFGCR0,
+ 		       intel_de_read(i915, DPCLKA_CFGCR0) | DPCLKA_CFGCR0_DDI_CLK_OFF(port));
+ }
+ 
+ static void skl_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	val = intel_de_read(i915, DPLL_CTRL2);
+ 
+ 	val &= ~(DPLL_CTRL2_DDI_CLK_OFF(port) |
+ 		 DPLL_CTRL2_DDI_CLK_SEL_MASK(port));
+ 	val |= (DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |
+ 		DPLL_CTRL2_DDI_SEL_OVERRIDE(port));
+ 
+ 	intel_de_write(i915, DPLL_CTRL2, val);
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void skl_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, DPLL_CTRL2,
+ 		       intel_de_read(i915, DPLL_CTRL2) | DPLL_CTRL2_DDI_CLK_OFF(port));
+ }
+ 
+ void hsw_ddi_enable_clock(struct intel_encoder *encoder,
+ 			  const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	intel_de_write(i915, PORT_CLK_SEL(port), hsw_pll_to_ddi_pll_sel(pll));
+ }
+ 
+ void hsw_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, PORT_CLK_SEL(port), PORT_CLK_SEL_NONE);
+ }
+ 
+ void intel_ddi_enable_clock(struct intel_encoder *encoder,
+ 			    const struct intel_crtc_state *crtc_state)
+ {
+ 	if (encoder->enable_clock)
+ 		encoder->enable_clock(encoder, crtc_state);
+ 	else
+ 		intel_ddi_clk_select(encoder, crtc_state);
+ }
+ 
+ static void intel_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	if (encoder->disable_clock)
+ 		encoder->disable_clock(encoder);
+ 	else
+ 		intel_ddi_clk_disable(encoder);
+ }
+ 
++>>>>>>> 2c7b1d340f19 (drm/i195: Extract cnl_ddi_{enable,disable}_clock())
  static void
  icl_program_mg_dp_mode(struct intel_digital_port *dig_port,
  		       const struct intel_crtc_state *crtc_state)
@@@ -4970,6 -4137,34 +5088,37 @@@ void intel_ddi_init(struct drm_i915_pri
  	encoder->cloneable = 0;
  	encoder->pipe_mask = ~0;
  
++<<<<<<< HEAD
++=======
+ 	if (IS_CANNONLAKE(dev_priv)) {
+ 		encoder->enable_clock = cnl_ddi_enable_clock;
+ 		encoder->disable_clock = cnl_ddi_disable_clock;
+ 	} else if (IS_GEN9_BC(dev_priv)) {
+ 		encoder->enable_clock = skl_ddi_enable_clock;
+ 		encoder->disable_clock = skl_ddi_disable_clock;
+ 	} else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {
+ 		encoder->enable_clock = hsw_ddi_enable_clock;
+ 		encoder->disable_clock = hsw_ddi_disable_clock;
+ 	}
+ 
+ 	if (IS_DG1(dev_priv))
+ 		encoder->hpd_pin = dg1_hpd_pin(dev_priv, port);
+ 	else if (IS_ROCKETLAKE(dev_priv))
+ 		encoder->hpd_pin = rkl_hpd_pin(dev_priv, port);
+ 	else if (INTEL_GEN(dev_priv) >= 12)
+ 		encoder->hpd_pin = tgl_hpd_pin(dev_priv, port);
+ 	else if (IS_JSL_EHL(dev_priv))
+ 		encoder->hpd_pin = ehl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 11))
+ 		encoder->hpd_pin = icl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 10))
+ 		encoder->hpd_pin = cnl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 9))
+ 		encoder->hpd_pin = skl_hpd_pin(dev_priv, port);
+ 	else
+ 		encoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);
+ 
++>>>>>>> 2c7b1d340f19 (drm/i195: Extract cnl_ddi_{enable,disable}_clock())
  	if (INTEL_GEN(dev_priv) >= 11)
  		dig_port->saved_port_bits =
  			intel_de_read(dev_priv, DDI_BUF_CTL(port))
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
