mm/hmm: use device_private_entry_to_pfn()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit f66c9a33aee943aa43b3698c1f6f2619e28a1c77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/f66c9a33.failed

swp_offset() should not be called directly, the wrappers are supposed to
abstract away the encoding of the device_private specific information in
the swap entry.

Link: https://lore.kernel.org/r/20200327200021.29372-7-jgg@ziepe.ca
	Reviewed-by: Ralph Campbell <rcampbell@nvidia.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Ralph Campbell <rcampbell@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit f66c9a33aee943aa43b3698c1f6f2619e28a1c77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hmm.c
diff --cc mm/hmm.c
index 3233a7437881,53192c32abc9..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -536,21 -262,15 +536,28 @@@ static int hmm_vma_handle_pte(struct mm
  		swp_entry_t entry = pte_to_swp_entry(pte);
  
  		/*
 -		 * Never fault in device private pages pages, but just report
 -		 * the PFN even if not present.
 +		 * This is a special swap entry, ignore migration, use
 +		 * device and report anything else as error.
  		 */
 -		if (hmm_is_device_private_entry(range, entry)) {
 +		if (is_device_private_entry(entry)) {
 +			cpu_flags = range->flags[HMM_PFN_VALID] |
 +				range->flags[HMM_PFN_DEVICE_PRIVATE];
 +			cpu_flags |= is_write_device_private_entry(entry) ?
 +				range->flags[HMM_PFN_WRITE] : 0;
 +			hmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,
 +					   &fault, &write_fault);
 +			if (fault || write_fault)
 +				goto fault;
  			*pfn = hmm_device_entry_from_pfn(range,
++<<<<<<< HEAD
 +					    swp_offset(entry));
 +			*pfn |= cpu_flags;
++=======
+ 				device_private_entry_to_pfn(entry));
+ 			*pfn |= range->flags[HMM_PFN_VALID];
+ 			if (is_write_device_private_entry(entry))
+ 				*pfn |= range->flags[HMM_PFN_WRITE];
++>>>>>>> f66c9a33aee9 (mm/hmm: use device_private_entry_to_pfn())
  			return 0;
  		}
  
* Unmerged path mm/hmm.c
