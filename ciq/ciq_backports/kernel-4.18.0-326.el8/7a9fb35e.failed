net/mlx5e: Do not reload ethernet ports when changing eswitch mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 7a9fb35e8c3a67145fca262c304de65cb2f83abf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/7a9fb35e.failed

When switching modes between legacy and switchdev and back, do not
reload ethernet interfaces. just change the profile from nic profile
to uplink rep profile in switchdev mode.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 7a9fb35e8c3a67145fca262c304de65cb2f83abf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/reporter_rx.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	include/linux/mlx5/driver.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index db8f75b14f22,1f5bc4d91060..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -1095,12 -1171,11 +1095,18 @@@ mlx5e_create_netdev(struct mlx5_core_de
  int mlx5e_attach_netdev(struct mlx5e_priv *priv);
  void mlx5e_detach_netdev(struct mlx5e_priv *priv);
  void mlx5e_destroy_netdev(struct mlx5e_priv *priv);
++<<<<<<< HEAD
++=======
+ int mlx5e_netdev_change_profile(struct mlx5e_priv *priv,
+ 				const struct mlx5e_profile *new_profile, void *new_ppriv);
+ void mlx5e_netdev_attach_nic_profile(struct mlx5e_priv *priv);
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  void mlx5e_set_netdev_mtu_boundaries(struct mlx5e_priv *priv);
 -void mlx5e_build_nic_params(struct mlx5e_priv *priv, struct mlx5e_xsk *xsk, u16 mtu);
 +void mlx5e_build_nic_params(struct mlx5e_priv *priv,
 +			    struct mlx5e_xsk *xsk,
 +			    struct mlx5e_rss_params *rss_params,
 +			    struct mlx5e_params *params,
 +			    u16 mtu);
  void mlx5e_build_rq_params(struct mlx5_core_dev *mdev,
  			   struct mlx5e_params *params);
  void mlx5e_build_rss_params(struct mlx5e_rss_params *rss_params,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/reporter_rx.c
index 32ed1067e6dc,34b3b316b688..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/reporter_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/reporter_rx.c
@@@ -631,5 -634,6 +631,10 @@@ void mlx5e_reporter_rx_destroy(struct m
  	if (!priv->rx_reporter)
  		return;
  
++<<<<<<< HEAD
 +	devlink_health_reporter_destroy(priv->rx_reporter);
++=======
+ 	devlink_port_health_reporter_destroy(priv->rx_reporter);
+ 	priv->rx_reporter = NULL;
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c
index 826584380216,63ee3b9416de..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c
@@@ -462,5 -592,6 +462,10 @@@ void mlx5e_reporter_tx_destroy(struct m
  	if (!priv->tx_reporter)
  		return;
  
++<<<<<<< HEAD
 +	devlink_health_reporter_destroy(priv->tx_reporter);
++=======
+ 	devlink_port_health_reporter_destroy(priv->tx_reporter);
+ 	priv->tx_reporter = NULL;
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index cefb35faad69,9c08f0bd1fcc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -5511,13 -5677,81 +5511,86 @@@ void mlx5e_detach_netdev(struct mlx5e_p
  	cancel_work_sync(&priv->update_stats_work);
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mlx5e_netdev_attach_profile(struct mlx5e_priv *priv,
+ 			    const struct mlx5e_profile *new_profile, void *new_ppriv)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int err;
+ 
+ 	err = mlx5e_priv_init(priv, netdev, mdev);
+ 	if (err) {
+ 		mlx5_core_err(mdev, "mlx5e_priv_init failed, err=%d\n", err);
+ 		return err;
+ 	}
+ 	netif_carrier_off(netdev);
+ 	priv->profile = new_profile;
+ 	priv->ppriv = new_ppriv;
+ 	err = new_profile->init(priv->mdev, priv->netdev);
+ 	if (err)
+ 		return err;
+ 	err = mlx5e_attach_netdev(priv);
+ 	if (err)
+ 		new_profile->cleanup(priv);
+ 	return err;
+ }
+ 
+ int mlx5e_netdev_change_profile(struct mlx5e_priv *priv,
+ 				const struct mlx5e_profile *new_profile, void *new_ppriv)
+ {
+ 	unsigned int new_max_nch = mlx5e_calc_max_nch(priv, new_profile);
+ 	const struct mlx5e_profile *orig_profile = priv->profile;
+ 	void *orig_ppriv = priv->ppriv;
+ 	int err, rollback_err;
+ 
+ 	/* sanity */
+ 	if (new_max_nch != priv->max_nch) {
+ 		netdev_warn(priv->netdev,
+ 			    "%s: Replacing profile with different max channels\n",
+ 			    __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* cleanup old profile */
+ 	mlx5e_detach_netdev(priv);
+ 	priv->profile->cleanup(priv);
+ 	mlx5e_priv_cleanup(priv);
+ 
+ 	err = mlx5e_netdev_attach_profile(priv, new_profile, new_ppriv);
+ 	if (err) { /* roll back to original profile */
+ 		netdev_warn(priv->netdev, "%s: new profile init failed, %d\n",
+ 			    __func__, err);
+ 		goto rollback;
+ 	}
+ 
+ 	return 0;
+ 
+ rollback:
+ 	rollback_err = mlx5e_netdev_attach_profile(priv, orig_profile, orig_ppriv);
+ 	if (rollback_err) {
+ 		netdev_err(priv->netdev,
+ 			   "%s: failed to rollback to orig profile, %d\n",
+ 			   __func__, rollback_err);
+ 	}
+ 	return err;
+ }
+ 
+ void mlx5e_netdev_attach_nic_profile(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_netdev_change_profile(priv, &mlx5e_nic_profile, NULL);
+ }
+ 
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  void mlx5e_destroy_netdev(struct mlx5e_priv *priv)
  {
 +	const struct mlx5e_profile *profile = priv->profile;
  	struct net_device *netdev = priv->netdev;
  
 -	mlx5e_priv_cleanup(priv);
 +	if (profile->cleanup)
 +		profile->cleanup(priv);
  	free_netdev(netdev);
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 0350572b18db,4cc902e0d71b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -711,26 -588,13 +712,37 @@@ static void mlx5e_build_rep_params(stru
  	mlx5e_build_rss_params(&priv->rss_params, params->num_channels);
  }
  
++<<<<<<< HEAD
 +static void mlx5e_build_rep_netdev(struct net_device *netdev)
++=======
+ static void mlx5e_build_rep_netdev(struct net_device *netdev,
+ 				   struct mlx5_core_dev *mdev)
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  {
 +	struct mlx5e_priv *priv = netdev_priv(netdev);
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 +	struct mlx5_eswitch_rep *rep = rpriv->rep;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +
  	SET_NETDEV_DEV(netdev, mdev->device);
++<<<<<<< HEAD
 +	if (rep->vport == MLX5_VPORT_UPLINK) {
 +		netdev->netdev_ops = &mlx5e_netdev_ops_uplink_rep;
 +		/* we want a persistent mac for the uplink rep */
 +		mlx5_query_mac_address(mdev, netdev->dev_addr);
 +		netdev->ethtool_ops = &mlx5e_uplink_rep_ethtool_ops;
 +		mlx5e_vxlan_set_netdev_info(priv);
 +		mlx5e_dcbnl_build_rep_netdev(netdev);
 +	} else {
 +		netdev->netdev_ops = &mlx5e_netdev_ops_rep;
 +		eth_hw_addr_random(netdev);
 +		netdev->ethtool_ops = &mlx5e_rep_ethtool_ops;
 +	}
++=======
+ 	netdev->netdev_ops = &mlx5e_netdev_ops_rep;
+ 	eth_hw_addr_random(netdev);
+ 	netdev->ethtool_ops = &mlx5e_rep_ethtool_ops;
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  
  	netdev->watchdog_timeo    = 15 * HZ;
  
@@@ -1215,25 -1082,60 +1236,72 @@@ static const struct mlx5e_profile mlx5e
  
  /* e-Switch vport representors */
  static int
- mlx5e_vport_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
+ mlx5e_vport_uplink_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(mlx5_uplink_netdev_get(dev));
+ 	struct mlx5e_rep_priv *rpriv = mlx5e_rep_to_rep_priv(rep);
+ 	struct devlink_port *dl_port;
+ 	int err;
+ 
+ 	rpriv->netdev = priv->netdev;
+ 
+ 	err = mlx5e_netdev_change_profile(priv, &mlx5e_uplink_rep_profile,
+ 					  rpriv);
+ 	if (err)
+ 		return err;
+ 
+ 	dl_port = mlx5_esw_offloads_devlink_port(dev->priv.eswitch, rpriv->rep->vport);
+ 	if (dl_port)
+ 		devlink_port_type_eth_set(dl_port, rpriv->netdev);
+ 
+ 	return 0;
+ }
+ 
+ static void
+ mlx5e_vport_uplink_rep_unload(struct mlx5e_rep_priv *rpriv)
+ {
+ 	struct net_device *netdev = rpriv->netdev;
+ 	struct devlink_port *dl_port;
+ 	struct mlx5_core_dev *dev;
+ 	struct mlx5e_priv *priv;
+ 
+ 	priv = netdev_priv(netdev);
+ 	dev = priv->mdev;
+ 
+ 	dl_port = mlx5_esw_offloads_devlink_port(dev->priv.eswitch, rpriv->rep->vport);
+ 	if (dl_port)
+ 		devlink_port_type_clear(dl_port);
+ 	mlx5e_netdev_attach_nic_profile(priv);
+ }
+ 
+ static int
+ mlx5e_vport_vf_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
  {
+ 	struct mlx5e_rep_priv *rpriv = mlx5e_rep_to_rep_priv(rep);
  	const struct mlx5e_profile *profile;
- 	struct mlx5e_rep_priv *rpriv;
  	struct devlink_port *dl_port;
  	struct net_device *netdev;
 -	struct mlx5e_priv *priv;
 -	unsigned int txqs, rxqs;
  	int nch, err;
  
++<<<<<<< HEAD
 +	rpriv = kzalloc(sizeof(*rpriv), GFP_KERNEL);
 +	if (!rpriv)
 +		return -ENOMEM;
 +
 +	/* rpriv->rep to be looked up when profile->init() is called */
 +	rpriv->rep = rep;
 +
 +	nch = mlx5e_get_max_num_channels(dev);
 +	profile = (rep->vport == MLX5_VPORT_UPLINK) ?
 +		  &mlx5e_uplink_rep_profile : &mlx5e_rep_profile;
 +	netdev = mlx5e_create_netdev(dev, profile, nch, rpriv);
++=======
+ 	profile = &mlx5e_rep_profile;
+ 	nch = mlx5e_get_max_num_channels(dev);
+ 	txqs = nch * profile->max_tc;
+ 	rxqs = nch * profile->rq_groups;
+ 	netdev = mlx5e_create_netdev(dev, txqs, rxqs);
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  	if (!netdev) {
  		mlx5_core_warn(dev,
  			       "Failed to create representor netdev for vport %d\n",
@@@ -1241,18 -1143,18 +1309,25 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	dev_net_set(netdev, mlx5_core_net(dev));
++=======
+ 	mlx5e_build_rep_netdev(netdev, dev);
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  	rpriv->netdev = netdev;
- 	rep->rep_data[REP_ETH].priv = rpriv;
- 	INIT_LIST_HEAD(&rpriv->vport_sqs_list);
  
- 	if (rep->vport == MLX5_VPORT_UPLINK) {
- 		err = mlx5e_create_mdev_resources(dev);
- 		if (err)
- 			goto err_destroy_netdev;
++<<<<<<< HEAD
++=======
+ 	priv = netdev_priv(netdev);
+ 	priv->profile = profile;
+ 	priv->ppriv = rpriv;
+ 	err = profile->init(dev, netdev);
+ 	if (err) {
+ 		netdev_warn(netdev, "rep profile init failed, %d\n", err);
+ 		goto err_destroy_netdev;
  	}
  
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  	err = mlx5e_attach_netdev(netdev_priv(netdev));
  	if (err) {
  		netdev_warn(netdev,
@@@ -1277,9 -1179,8 +1352,14 @@@
  err_detach_netdev:
  	mlx5e_detach_netdev(netdev_priv(netdev));
  
++<<<<<<< HEAD
 +err_destroy_mdev_resources:
 +	if (rep->vport == MLX5_VPORT_UPLINK)
 +		mlx5e_destroy_mdev_resources(dev);
++=======
+ err_cleanup_profile:
+ 	priv->profile->cleanup(priv);
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  
  err_destroy_netdev:
  	mlx5e_destroy_netdev(netdev_priv(netdev));
@@@ -1302,9 -1233,9 +1412,14 @@@ mlx5e_vport_rep_unload(struct mlx5_eswi
  		devlink_port_type_clear(dl_port);
  	unregister_netdev(netdev);
  	mlx5e_detach_netdev(priv);
++<<<<<<< HEAD
 +	if (rep->vport == MLX5_VPORT_UPLINK)
 +		mlx5e_destroy_mdev_resources(priv->mdev);
++=======
+ 	priv->profile->cleanup(priv);
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  	mlx5e_destroy_netdev(priv);
+ free_ppriv:
  	kfree(ppriv); /* mlx5e_rep_priv */
  }
  
diff --cc include/linux/mlx5/driver.h
index e17592e9c3ee,23bb01d7c9b9..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -630,10 -644,14 +630,21 @@@ struct mlx5_td 
  };
  
  struct mlx5e_resources {
++<<<<<<< HEAD
 +	u32                        pdn;
 +	struct mlx5_td             td;
 +	struct mlx5_core_mkey      mkey;
 +	struct mlx5_sq_bfreg       bfreg;
++=======
+ 	struct mlx5e_hw_objs {
+ 		u32                        pdn;
+ 		struct mlx5_td             td;
+ 		struct mlx5_core_mkey      mkey;
+ 		struct mlx5_sq_bfreg       bfreg;
+ 	} hw_objs;
+ 	struct devlink_port dl_port;
+ 	struct net_device *uplink_netdev;
++>>>>>>> 7a9fb35e8c3a (net/mlx5e: Do not reload ethernet ports when changing eswitch mode)
  };
  
  enum mlx5_sw_icm_type {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/dev.c b/drivers/net/ethernet/mellanox/mlx5/core/dev.c
index d43ad78fefd9..3c9be213b11b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/dev.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/dev.c
@@ -58,9 +58,6 @@ static bool is_eth_supported(struct mlx5_core_dev *dev)
 	if (!IS_ENABLED(CONFIG_MLX5_CORE_EN))
 		return false;
 
-	if (is_eth_rep_supported(dev))
-		return false;
-
 	if (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)
 		return false;
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/reporter_rx.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lib/mlx5.h b/drivers/net/ethernet/mellanox/mlx5/core/lib/mlx5.h
index d046db7bb047..2f536c5d30b1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lib/mlx5.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/mlx5.h
@@ -95,4 +95,13 @@ static inline struct net *mlx5_core_net(struct mlx5_core_dev *dev)
 	return devlink_net(priv_to_devlink(dev));
 }
 
+static inline void mlx5_uplink_netdev_set(struct mlx5_core_dev *mdev, struct net_device *netdev)
+{
+	mdev->mlx5e_res.uplink_netdev = netdev;
+}
+
+static inline struct net_device *mlx5_uplink_netdev_get(struct mlx5_core_dev *mdev)
+{
+	return mdev->mlx5e_res.uplink_netdev;
+}
 #endif
* Unmerged path include/linux/mlx5/driver.h
