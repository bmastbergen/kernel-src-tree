net/mlx5e: Fix mapping of ct_label zero

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ariel Levkovich <lariel@nvidia.com>
commit d24f847e54214049814b9515771622eaab3f42ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/d24f847e.failed

ct_label 0 is a default label each flow has and therefore
there can be rules that match on ct_label=0 without a prior
rule that set the ct_label to this value.

The ct_label value is not used directly in the HW rules and
instead it is mapped to some id within a defined range and this
id is used to set and match the metadata register which carries
the ct_label.

If we have a rule that matches on ct_label=0, the hw rule will
perform matching on a value that is != 0 because of the mapping
from label to id. Since the metadata register default value is
0 and it was never set before to anything else by an action that
sets the ct_label, there will always be a mismatch between that
register and the value in the rule.

To support such rule, a forced mapping of ct_label 0 to id=0
is done so that it will match the metadata register default
value of 0.

Fixes: 54b154ecfb8c ("net/mlx5e: CT: Map 128 bits labels to 32 bit map ID")
	Signed-off-by: Ariel Levkovich <lariel@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit d24f847e54214049814b9515771622eaab3f42ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
index 65e9e986ce96,68e54cc1cd16..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
@@@ -445,10 -455,10 +467,17 @@@ mlx5_tc_ct_entry_del_rule(struct mlx5_t
  
  	ct_dbg("Deleting ct entry rule in zone %d", entry->tuple.zone);
  
++<<<<<<< HEAD
 +	mlx5_eswitch_del_offloaded_rule(esw, zone_rule->rule, attr);
 +	mlx5e_mod_hdr_detach(ct_priv->esw->dev,
 +			     &esw->offloads.mod_hdr, zone_rule->mh);
 +	mapping_remove(ct_priv->labels_mapping, attr->ct_attr.ct_labels_id);
++=======
+ 	mlx5_tc_rule_delete(netdev_priv(ct_priv->netdev), zone_rule->rule, attr);
+ 	mlx5e_mod_hdr_detach(ct_priv->dev,
+ 			     ct_priv->mod_hdr_tbl, zone_rule->mh);
+ 	mlx5_put_label_mapping(ct_priv, attr->ct_attr.ct_labels_id);
++>>>>>>> d24f847e5421 (net/mlx5e: Fix mapping of ct_label zero)
  	kfree(attr);
  }
  
@@@ -746,9 -765,9 +775,15 @@@ mlx5_tc_ct_entry_add_rule(struct mlx5_t
  	return 0;
  
  err_rule:
++<<<<<<< HEAD
 +	mlx5e_mod_hdr_detach(ct_priv->esw->dev,
 +			     &esw->offloads.mod_hdr, zone_rule->mh);
 +	mapping_remove(ct_priv->labels_mapping, attr->ct_attr.ct_labels_id);
++=======
+ 	mlx5e_mod_hdr_detach(ct_priv->dev,
+ 			     ct_priv->mod_hdr_tbl, zone_rule->mh);
+ 	mlx5_put_label_mapping(ct_priv, attr->ct_attr.ct_labels_id);
++>>>>>>> d24f847e5421 (net/mlx5e: Fix mapping of ct_label zero)
  err_mod_hdr:
  	kfree(attr);
  err_attr:
@@@ -1195,14 -1214,12 +1230,18 @@@ int mlx5_tc_ct_add_no_trk_match(struct 
  	return 0;
  }
  
 -void mlx5_tc_ct_match_del(struct mlx5_tc_ct_priv *priv, struct mlx5_ct_attr *ct_attr)
 +void mlx5_tc_ct_match_del(struct mlx5e_priv *priv, struct mlx5_ct_attr *ct_attr)
  {
 -	if (!priv || !ct_attr->ct_labels_id)
 +	struct mlx5_tc_ct_priv *ct_priv = mlx5_tc_ct_get_ct_priv(priv);
 +
 +	if (!ct_priv || !ct_attr->ct_labels_id)
  		return;
  
++<<<<<<< HEAD
 +	mapping_remove(ct_priv->labels_mapping, ct_attr->ct_labels_id);
++=======
+ 	mlx5_put_label_mapping(priv, ct_attr->ct_labels_id);
++>>>>>>> d24f847e5421 (net/mlx5e: Fix mapping of ct_label zero)
  }
  
  int
@@@ -1306,7 -1302,7 +1345,11 @@@ mlx5_tc_ct_match_add(struct mlx5e_priv 
  		ct_labels[1] = key->ct_labels[1] & mask->ct_labels[1];
  		ct_labels[2] = key->ct_labels[2] & mask->ct_labels[2];
  		ct_labels[3] = key->ct_labels[3] & mask->ct_labels[3];
++<<<<<<< HEAD
 +		if (mapping_add(ct_priv->labels_mapping, ct_labels, &ct_attr->ct_labels_id))
++=======
+ 		if (mlx5_get_label_mapping(priv, ct_labels, &ct_attr->ct_labels_id))
++>>>>>>> d24f847e5421 (net/mlx5e: Fix mapping of ct_label zero)
  			return -EOPNOTSUPP;
  		mlx5e_tc_match_to_reg_match(spec, LABELS_TO_REG, ct_attr->ct_labels_id,
  					    MLX5_CT_LABELS_MASK);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
