ALSA: usb-audio: Annotate the endpoint index in audioformat

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit eae4d054f909d9e9589d0940f9b5b0cd68de1e2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/eae4d054.failed

There are devices that have multiple endpoints sharing the same
iface/altset not only for sync but also for the actual streams, and
the audioformat for such an endpoint needs to be handled with the
proper endpoint index; otherwise it confuses the endpoint management.

This patch extends the audioformat to annotate the endpoint index, and
put the proper ep_idx=1 to Pioneer device quirk entries accordingly.

Fixes: bf6313a0ff76 ("ALSA: usb-audio: Refactor endpoint management")
Link: https://lore.kernel.org/r/20210108075219.21463-5-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit eae4d054f909d9e9589d0940f9b5b0cd68de1e2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/endpoint.c
#	sound/usb/quirks-table.h
diff --cc sound/usb/endpoint.c
index 208ac2aff462,fe73fe3ff2bc..000000000000
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@@ -548,25 -590,169 +548,107 @@@ int snd_usb_add_endpoint(struct snd_usb
  }
  
  /* Set up syncinterval and maxsyncsize for a sync EP */
 -static void endpoint_set_syncinterval(struct snd_usb_audio *chip,
 -				      struct snd_usb_endpoint *ep)
 +void snd_usb_endpoint_set_syncinterval(struct snd_usb_audio *chip,
 +				       struct snd_usb_endpoint *ep,
 +				       struct usb_host_interface *alts)
  {
 -	struct usb_host_interface *alts;
 -	struct usb_endpoint_descriptor *desc;
 -
 -	alts = snd_usb_get_host_interface(chip, ep->iface, ep->altsetting);
 -	if (!alts)
 -		return;
 -
 -	desc = get_endpoint(alts, ep->ep_idx);
 -	if (desc->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&
 -	    desc->bRefresh >= 1 && desc->bRefresh <= 9)
 -		ep->syncinterval = desc->bRefresh;
 -	else if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)
 -		ep->syncinterval = 1;
 -	else if (desc->bInterval >= 1 && desc->bInterval <= 16)
 -		ep->syncinterval = desc->bInterval - 1;
 -	else
 -		ep->syncinterval = 3;
 -
 -	ep->syncmaxsize = le16_to_cpu(desc->wMaxPacketSize);
 -}
 -
 -static bool endpoint_compatible(struct snd_usb_endpoint *ep,
 -				const struct audioformat *fp,
 -				const struct snd_pcm_hw_params *params)
 -{
 -	if (!ep->opened)
 -		return false;
 -	if (ep->cur_audiofmt != fp)
 -		return false;
 -	if (ep->cur_rate != params_rate(params) ||
 -	    ep->cur_format != params_format(params) ||
 -	    ep->cur_period_frames != params_period_size(params) ||
 -	    ep->cur_buffer_periods != params_periods(params))
 -		return false;
 -	return true;
 -}
 -
 -/*
 - * Check whether the given fp and hw params are compatbile with the current
 - * setup of the target EP for implicit feedback sync
 - */
 -bool snd_usb_endpoint_compatible(struct snd_usb_audio *chip,
 -				 struct snd_usb_endpoint *ep,
 -				 const struct audioformat *fp,
 -				 const struct snd_pcm_hw_params *params)
 -{
 -	bool ret;
 -
 -	mutex_lock(&chip->mutex);
 -	ret = endpoint_compatible(ep, fp, params);
 -	mutex_unlock(&chip->mutex);
 -	return ret;
 -}
 -
 -/*
 - * snd_usb_endpoint_open: Open the endpoint
 - *
 - * Called from hw_params to assign the endpoint to the substream.
 - * It's reference-counted, and only the first opener is allowed to set up
 - * arbitrary parameters.  The later opener must be compatible with the
 - * former opened parameters.
 - * The endpoint needs to be closed via snd_usb_endpoint_close() later.
 - *
 - * Note that this function doesn't configure the endpoint.  The substream
 - * needs to set it up later via snd_usb_endpoint_configure().
 - */
 -struct snd_usb_endpoint *
 -snd_usb_endpoint_open(struct snd_usb_audio *chip,
 -		      const struct audioformat *fp,
 -		      const struct snd_pcm_hw_params *params,
 -		      bool is_sync_ep)
 -{
 -	struct snd_usb_endpoint *ep;
 -	int ep_num = is_sync_ep ? fp->sync_ep : fp->endpoint;
 -
 -	mutex_lock(&chip->mutex);
 -	ep = snd_usb_get_endpoint(chip, ep_num);
 -	if (!ep) {
 -		usb_audio_err(chip, "Cannot find EP 0x%x to open\n", ep_num);
 -		goto unlock;
 +	struct usb_endpoint_descriptor *desc = get_endpoint(alts, 1);
 +
 +	if (ep->type == SND_USB_ENDPOINT_TYPE_SYNC) {
 +		if (desc->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&
 +		    desc->bRefresh >= 1 && desc->bRefresh <= 9)
 +			ep->syncinterval = desc->bRefresh;
 +		else if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)
 +			ep->syncinterval = 1;
 +		else if (desc->bInterval >= 1 && desc->bInterval <= 16)
 +			ep->syncinterval = desc->bInterval - 1;
 +		else
 +			ep->syncinterval = 3;
 +
 +		ep->syncmaxsize = le16_to_cpu(desc->wMaxPacketSize);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (!ep->opened) {
+ 		if (is_sync_ep) {
+ 			ep->iface = fp->sync_iface;
+ 			ep->altsetting = fp->sync_altsetting;
+ 			ep->ep_idx = fp->sync_ep_idx;
+ 		} else {
+ 			ep->iface = fp->iface;
+ 			ep->altsetting = fp->altsetting;
+ 			ep->ep_idx = fp->ep_idx;
+ 		}
+ 		usb_audio_dbg(chip, "Open EP 0x%x, iface=%d:%d, idx=%d\n",
+ 			      ep_num, ep->iface, ep->altsetting, ep->ep_idx);
+ 
+ 		ep->iface_ref = iface_ref_find(chip, ep->iface);
+ 		if (!ep->iface_ref) {
+ 			ep = NULL;
+ 			goto unlock;
+ 		}
+ 
+ 		ep->cur_audiofmt = fp;
+ 		ep->cur_channels = fp->channels;
+ 		ep->cur_rate = params_rate(params);
+ 		ep->cur_format = params_format(params);
+ 		ep->cur_frame_bytes = snd_pcm_format_physical_width(ep->cur_format) *
+ 			ep->cur_channels / 8;
+ 		ep->cur_period_frames = params_period_size(params);
+ 		ep->cur_period_bytes = ep->cur_period_frames * ep->cur_frame_bytes;
+ 		ep->cur_buffer_periods = params_periods(params);
+ 
+ 		if (ep->type == SND_USB_ENDPOINT_TYPE_SYNC)
+ 			endpoint_set_syncinterval(chip, ep);
+ 
+ 		ep->implicit_fb_sync = fp->implicit_fb;
+ 		ep->need_setup = true;
+ 
+ 		usb_audio_dbg(chip, "  channels=%d, rate=%d, format=%s, period_bytes=%d, periods=%d, implicit_fb=%d\n",
+ 			      ep->cur_channels, ep->cur_rate,
+ 			      snd_pcm_format_name(ep->cur_format),
+ 			      ep->cur_period_bytes, ep->cur_buffer_periods,
+ 			      ep->implicit_fb_sync);
+ 
+ 	} else {
+ 		if (WARN_ON(!ep->iface_ref)) {
+ 			ep = NULL;
+ 			goto unlock;
+ 		}
+ 
+ 		if (!endpoint_compatible(ep, fp, params)) {
+ 			usb_audio_err(chip, "Incompatible EP setup for 0x%x\n",
+ 				      ep_num);
+ 			ep = NULL;
+ 			goto unlock;
+ 		}
+ 
+ 		usb_audio_dbg(chip, "Reopened EP 0x%x (count %d)\n",
+ 			      ep_num, ep->opened);
+ 	}
+ 
+ 	if (!ep->iface_ref->opened++)
+ 		ep->iface_ref->need_setup = true;
+ 
+ 	ep->opened++;
+ 
+  unlock:
+ 	mutex_unlock(&chip->mutex);
+ 	return ep;
+ }
+ 
+ /*
+  * snd_usb_endpoint_set_sync: Link data and sync endpoints
+  *
+  * Pass NULL to sync_ep to unlink again
+  */
+ void snd_usb_endpoint_set_sync(struct snd_usb_audio *chip,
+ 			       struct snd_usb_endpoint *data_ep,
+ 			       struct snd_usb_endpoint *sync_ep)
+ {
+ 	data_ep->sync_source = sync_ep;
++>>>>>>> eae4d054f909 (ALSA: usb-audio: Annotate the endpoint index in audioformat)
  }
  
  /*
diff --cc sound/usb/quirks-table.h
index dda4a7c239d9,c8a4bdf18207..000000000000
--- a/sound/usb/quirks-table.h
+++ b/sound/usb/quirks-table.h
@@@ -3580,6 -3585,64 +3584,67 @@@ AU0828_DEVICE(0x2040, 0x7270, "Hauppaug
  
  {
  	/*
++<<<<<<< HEAD
++=======
+ 	 * PIONEER DJ DDJ-SR2
+ 	 * PCM is 4 channels out, 6 channels in @ 44.1 fixed
+ 	 * The Feedback for the output is the input
+ 	 */
+ 	USB_DEVICE_VENDOR_SPEC(0x2b73, 0x001e),
+ 		.driver_info = (unsigned long) &(const struct snd_usb_audio_quirk) {
+ 		.ifnum = QUIRK_ANY_INTERFACE,
+ 		.type = QUIRK_COMPOSITE,
+ 		.data = (const struct snd_usb_audio_quirk[]) {
+ 			{
+ 				.ifnum = 0,
+ 				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
+ 				.data = &(const struct audioformat) {
+ 					.formats = SNDRV_PCM_FMTBIT_S24_3LE,
+ 					.channels = 4,
+ 					.iface = 0,
+ 					.altsetting = 1,
+ 					.altset_idx = 1,
+ 					.endpoint = 0x01,
+ 					.ep_attr = USB_ENDPOINT_XFER_ISOC|
+ 						USB_ENDPOINT_SYNC_ASYNC,
+ 					.rates = SNDRV_PCM_RATE_44100,
+ 					.rate_min = 44100,
+ 					.rate_max = 44100,
+ 					.nr_rates = 1,
+ 					.rate_table = (unsigned int[]) { 44100 }
+ 				}
+ 			},
+ 			{
+ 				.ifnum = 0,
+ 				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
+ 				.data = &(const struct audioformat) {
+ 					.formats = SNDRV_PCM_FMTBIT_S24_3LE,
+ 					.channels = 6,
+ 					.iface = 0,
+ 					.altsetting = 1,
+ 					.altset_idx = 1,
+ 					.endpoint = 0x82,
+ 					.ep_idx = 1,
+ 					.ep_attr = USB_ENDPOINT_XFER_ISOC|
+ 						USB_ENDPOINT_SYNC_ASYNC|
+ 					USB_ENDPOINT_USAGE_IMPLICIT_FB,
+ 					.rates = SNDRV_PCM_RATE_44100,
+ 					.rate_min = 44100,
+ 					.rate_max = 44100,
+ 					.nr_rates = 1,
+ 					.rate_table = (unsigned int[]) { 44100 }
+ 				}
+ 			},
+ 			{
+ 				.ifnum = -1
+ 			}
+ 		}
+ 	}
+ },
+ 
+ {
+ 	/*
++>>>>>>> eae4d054f909 (ALSA: usb-audio: Annotate the endpoint index in audioformat)
  	 * Pioneer DJ DJM-900NXS2
  	 * 10 channels playback & 12 channels capture @ 44.1/48/96kHz S24LE
  	 */
diff --git a/sound/usb/card.h b/sound/usb/card.h
index ce446f8dba4b..70ea71ea7f58 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -18,6 +18,7 @@ struct audioformat {
 	unsigned int frame_size;	/* samples per frame for non-audio */
 	int iface;			/* interface number */
 	unsigned char altsetting;	/* corresponding alternate setting */
+	unsigned char ep_idx;		/* endpoint array index */
 	unsigned char altset_idx;	/* array index of altenate setting */
 	unsigned char attributes;	/* corresponding attributes of cs endpoint */
 	unsigned char endpoint;		/* endpoint */
* Unmerged path sound/usb/endpoint.c
* Unmerged path sound/usb/quirks-table.h
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 581db82b9cb7..02c731d7ac35 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -194,7 +194,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	}
 	alts = &iface->altsetting[fp->altset_idx];
 	altsd = get_iface_desc(alts);
-	if (altsd->bNumEndpoints < 1) {
+	if (altsd->bNumEndpoints <= fp->ep_idx) {
 		err = -EINVAL;
 		goto error;
 	}
@@ -204,7 +204,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	if (fp->datainterval == 0)
 		fp->datainterval = snd_usb_parse_datainterval(chip, alts);
 	if (fp->maxpacksize == 0)
-		fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+		fp->maxpacksize = le16_to_cpu(get_endpoint(alts, fp->ep_idx)->wMaxPacketSize);
 	if (!fp->fmt_type)
 		fp->fmt_type = UAC_FORMAT_TYPE_I;
 
