drm/i915: split out stepping info to a new file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Jani Nikula <jani.nikula@intel.com>
commit 7eb186bbe9f30e17cfdadf18ed012aefcbb70d6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/7eb186bb.failed

gt/intel_workarounds.c is decidedly the wrong place for handling
stepping info. Add new intel_step.[ch] for the data, and move the
stepping arrays there. No functional changes.

v2: Rename stepping->step

	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/f69baf82819a8a35815fca25a520de5c38a7e1b5.1616764798.git.jani.nikula@intel.com
(cherry picked from commit 7eb186bbe9f30e17cfdadf18ed012aefcbb70d6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_drv.h
diff --cc drivers/gpu/drm/i915/i915_drv.h
index 9206a6040183,0c7fdb5d867c..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@@ -1525,14 -1456,26 +1526,25 @@@ IS_SUBPLATFORM(const struct drm_i915_pr
  #define IS_BXT_REVID(dev_priv, since, until) \
  	(IS_BROXTON(dev_priv) && IS_REVID(dev_priv, since, until))
  
 -enum {
 -	KBL_REVID_A0,
 -	KBL_REVID_B0,
 -	KBL_REVID_B1,
 -	KBL_REVID_C0,
 -	KBL_REVID_D0,
 -	KBL_REVID_D1,
 -	KBL_REVID_E0,
 -	KBL_REVID_F0,
 -	KBL_REVID_G0,
 -};
 +#define KBL_REVID_A0		0x0
 +#define KBL_REVID_B0		0x1
 +#define KBL_REVID_C0		0x2
 +#define KBL_REVID_D0		0x3
 +#define KBL_REVID_E0		0x4
  
++<<<<<<< HEAD
 +#define IS_KBL_REVID(dev_priv, since, until) \
 +	(IS_KABYLAKE(dev_priv) && IS_REVID(dev_priv, since, until))
++=======
+ #define IS_KBL_GT_REVID(dev_priv, since, until) \
+ 	(IS_KABYLAKE(dev_priv) && \
+ 	 kbl_revids[INTEL_REVID(dev_priv)].gt_stepping >= since && \
+ 	 kbl_revids[INTEL_REVID(dev_priv)].gt_stepping <= until)
+ #define IS_KBL_DISP_REVID(dev_priv, since, until) \
+ 	(IS_KABYLAKE(dev_priv) && \
+ 	 kbl_revids[INTEL_REVID(dev_priv)].disp_stepping >= since && \
+ 	 kbl_revids[INTEL_REVID(dev_priv)].disp_stepping <= until)
++>>>>>>> 7eb186bbe9f3 (drm/i915: split out stepping info to a new file)
  
  #define GLK_REVID_A0		0x0
  #define GLK_REVID_A1		0x1
@@@ -1559,16 -1502,58 +1571,57 @@@
  	(IS_ICELAKE(p) && IS_REVID(p, since, until))
  
  #define EHL_REVID_A0            0x0
 -#define EHL_REVID_B0            0x1
 -
 -#define IS_JSL_EHL_REVID(p, since, until) \
 -	(IS_JSL_EHL(p) && IS_REVID(p, since, until))
 -
 -enum {
 -	STEP_A0,
 -	STEP_A2,
 -	STEP_B0,
 -	STEP_B1,
 -	STEP_C0,
 -	STEP_D0,
 -};
  
 +#define IS_EHL_REVID(p, since, until) \
 +	(IS_ELKHARTLAKE(p) && IS_REVID(p, since, until))
 +
 +#define TGL_REVID_A0		0x0
 +#define TGL_REVID_B0		0x1
 +#define TGL_REVID_C0		0x2
 +
++<<<<<<< HEAD
 +#define IS_TGL_REVID(p, since, until) \
 +	(IS_TIGERLAKE(p) && IS_REVID(p, since, until))
++=======
+ static inline const struct i915_rev_steppings *
+ tgl_stepping_get(struct drm_i915_private *dev_priv)
+ {
+ 	u8 revid = INTEL_REVID(dev_priv);
+ 	u8 size;
+ 	const struct i915_rev_steppings *revid_step_tbl;
+ 
+ 	if (IS_ALDERLAKE_S(dev_priv)) {
+ 		revid_step_tbl = adls_revid_step_tbl;
+ 		size = ARRAY_SIZE(adls_revid_step_tbl);
+ 	} else if (IS_TGL_U(dev_priv) || IS_TGL_Y(dev_priv)) {
+ 		revid_step_tbl = tgl_uy_revid_step_tbl;
+ 		size = ARRAY_SIZE(tgl_uy_revid_step_tbl);
+ 	} else {
+ 		revid_step_tbl = tgl_revid_step_tbl;
+ 		size = ARRAY_SIZE(tgl_revid_step_tbl);
+ 	}
+ 
+ 	revid = min_t(u8, revid, size - 1);
+ 
+ 	return &revid_step_tbl[revid];
+ }
+ 
+ #define IS_TGL_DISP_STEPPING(p, since, until) \
+ 	(IS_TIGERLAKE(p) && \
+ 	 tgl_stepping_get(p)->disp_stepping >= (since) && \
+ 	 tgl_stepping_get(p)->disp_stepping <= (until))
+ 
+ #define IS_TGL_UY_GT_STEPPING(p, since, until) \
+ 	((IS_TGL_U(p) || IS_TGL_Y(p)) && \
+ 	 tgl_stepping_get(p)->gt_stepping >= (since) && \
+ 	 tgl_stepping_get(p)->gt_stepping <= (until))
+ 
+ #define IS_TGL_GT_STEPPING(p, since, until) \
+ 	(IS_TIGERLAKE(p) && \
+ 	 !(IS_TGL_U(p) || IS_TGL_Y(p)) && \
+ 	 tgl_stepping_get(p)->gt_stepping >= (since) && \
+ 	 tgl_stepping_get(p)->gt_stepping <= (until))
++>>>>>>> 7eb186bbe9f3 (drm/i915: split out stepping info to a new file)
  
  #define RKL_REVID_A0		0x0
  #define RKL_REVID_B0		0x1
diff --git a/drivers/gpu/drm/i915/Makefile b/drivers/gpu/drm/i915/Makefile
index bda4c0e408f8..ef8a0979c121 100644
--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@ -52,6 +52,7 @@ i915-y += i915_drv.o \
 	  intel_pm.o \
 	  intel_runtime_pm.o \
 	  intel_sideband.o \
+	  intel_step.o \
 	  intel_uncore.o \
 	  intel_wakeref.o \
 	  vlv_suspend.o
* Unmerged path drivers/gpu/drm/i915/i915_drv.h
diff --git a/drivers/gpu/drm/i915/intel_step.c b/drivers/gpu/drm/i915/intel_step.c
new file mode 100644
index 000000000000..e19820cbe8e3
--- /dev/null
+++ b/drivers/gpu/drm/i915/intel_step.c
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright © 2020,2021 Intel Corporation
+ */
+
+#include "i915_drv.h"
+#include "intel_step.h"
+
+/*
+ * KBL revision ID ordering is bizarre; higher revision ID's map to lower
+ * steppings in some cases.  So rather than test against the revision ID
+ * directly, let's map that into our own range of increasing ID's that we
+ * can test against in a regular manner.
+ */
+
+const struct i915_rev_steppings kbl_revids[] = {
+	[0] = { .gt_stepping = KBL_REVID_A0, .disp_stepping = KBL_REVID_A0 },
+	[1] = { .gt_stepping = KBL_REVID_B0, .disp_stepping = KBL_REVID_B0 },
+	[2] = { .gt_stepping = KBL_REVID_C0, .disp_stepping = KBL_REVID_B0 },
+	[3] = { .gt_stepping = KBL_REVID_D0, .disp_stepping = KBL_REVID_B0 },
+	[4] = { .gt_stepping = KBL_REVID_F0, .disp_stepping = KBL_REVID_C0 },
+	[5] = { .gt_stepping = KBL_REVID_C0, .disp_stepping = KBL_REVID_B1 },
+	[6] = { .gt_stepping = KBL_REVID_D1, .disp_stepping = KBL_REVID_B1 },
+	[7] = { .gt_stepping = KBL_REVID_G0, .disp_stepping = KBL_REVID_C0 },
+};
+
+const struct i915_rev_steppings tgl_uy_revid_step_tbl[] = {
+	[0] = { .gt_stepping = STEP_A0, .disp_stepping = STEP_A0 },
+	[1] = { .gt_stepping = STEP_B0, .disp_stepping = STEP_C0 },
+	[2] = { .gt_stepping = STEP_B1, .disp_stepping = STEP_C0 },
+	[3] = { .gt_stepping = STEP_C0, .disp_stepping = STEP_D0 },
+};
+
+/* Same GT stepping between tgl_uy_revids and tgl_revids don't mean the same HW */
+const struct i915_rev_steppings tgl_revid_step_tbl[] = {
+	[0] = { .gt_stepping = STEP_A0, .disp_stepping = STEP_B0 },
+	[1] = { .gt_stepping = STEP_B0, .disp_stepping = STEP_D0 },
+};
+
+const struct i915_rev_steppings adls_revid_step_tbl[] = {
+	[0x0] = { .gt_stepping = STEP_A0, .disp_stepping = STEP_A0 },
+	[0x1] = { .gt_stepping = STEP_A0, .disp_stepping = STEP_A2 },
+	[0x4] = { .gt_stepping = STEP_B0, .disp_stepping = STEP_B0 },
+	[0x8] = { .gt_stepping = STEP_C0, .disp_stepping = STEP_B0 },
+	[0xC] = { .gt_stepping = STEP_D0, .disp_stepping = STEP_C0 },
+};
diff --git a/drivers/gpu/drm/i915/intel_step.h b/drivers/gpu/drm/i915/intel_step.h
new file mode 100644
index 000000000000..af922ae3bb4e
--- /dev/null
+++ b/drivers/gpu/drm/i915/intel_step.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright © 2020,2021 Intel Corporation
+ */
+
+#ifndef __INTEL_STEP_H__
+#define __INTEL_STEP_H__
+
+#include <linux/types.h>
+
+struct i915_rev_steppings {
+	u8 gt_stepping;
+	u8 disp_stepping;
+};
+
+#define TGL_UY_REVID_STEP_TBL_SIZE	4
+#define TGL_REVID_STEP_TBL_SIZE		2
+#define ADLS_REVID_STEP_TBL_SIZE	13
+
+extern const struct i915_rev_steppings kbl_revids[];
+extern const struct i915_rev_steppings tgl_uy_revid_step_tbl[TGL_UY_REVID_STEP_TBL_SIZE];
+extern const struct i915_rev_steppings tgl_revid_step_tbl[TGL_REVID_STEP_TBL_SIZE];
+extern const struct i915_rev_steppings adls_revid_step_tbl[ADLS_REVID_STEP_TBL_SIZE];
+
+#endif /* __INTEL_STEP_H__ */
