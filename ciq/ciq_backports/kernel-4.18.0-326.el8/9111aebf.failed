iommu/arm-smmu-v3: Add support for VHE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Jean-Philippe Brucker <jean-philippe@linaro.org>
commit 9111aebf770d6a6c9fcfd6301da4a0025f2d610f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/9111aebf.failed

ARMv8.1 extensions added Virtualization Host Extensions (VHE), which allow
to run a host kernel at EL2. When using normal DMA, Device and CPU address
spaces are dissociated, and do not need to implement the same
capabilities, so VHE hasn't been used in the SMMU until now.

With shared address spaces however, ASIDs are shared between MMU and SMMU,
and broadcast TLB invalidations issued by a CPU are taken into account by
the SMMU. TLB entries on both sides need to have identical exception level
in order to be cleared with a single invalidation.

When the CPU is using VHE, enable VHE in the SMMU for all STEs. Normal DMA
mappings will need to use TLBI_EL2 commands instead of TLBI_NH, but
shouldn't be otherwise affected by this change.

	Acked-by: Will Deacon <will@kernel.org>
	Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
	Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
Link: https://lore.kernel.org/r/20210122151054.2833521-4-jean-philippe@linaro.org
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit 9111aebf770d6a6c9fcfd6301da4a0025f2d610f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/arm-smmu-v3.c
#	drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
diff --cc drivers/iommu/arm-smmu-v3.c
index 97ca17f430f0,baebaac34a83..000000000000
--- a/drivers/iommu/arm-smmu-v3.c
+++ b/drivers/iommu/arm-smmu-v3.c
@@@ -1534,6 -879,18 +1539,21 @@@ static int arm_smmu_cmdq_batch_submit(s
  }
  
  /* Context descriptor manipulation functions */
++<<<<<<< HEAD:drivers/iommu/arm-smmu-v3.c
++=======
+ void arm_smmu_tlb_inv_asid(struct arm_smmu_device *smmu, u16 asid)
+ {
+ 	struct arm_smmu_cmdq_ent cmd = {
+ 		.opcode	= smmu->features & ARM_SMMU_FEAT_E2H ?
+ 			CMDQ_OP_TLBI_EL2_ASID : CMDQ_OP_TLBI_NH_ASID,
+ 		.tlbi.asid = asid,
+ 	};
+ 
+ 	arm_smmu_cmdq_issue_cmd(smmu, &cmd);
+ 	arm_smmu_cmdq_issue_sync(smmu);
+ }
+ 
++>>>>>>> 9111aebf770d (iommu/arm-smmu-v3: Add support for VHE):drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
  static void arm_smmu_sync_cd(struct arm_smmu_domain *smmu_domain,
  			     int ssid, bool leaf)
  {
@@@ -2368,6 -1753,22 +2392,25 @@@ static void arm_smmu_tlb_inv_range_doma
  	arm_smmu_atc_inv_domain(smmu_domain, 0, iova, size);
  }
  
++<<<<<<< HEAD:drivers/iommu/arm-smmu-v3.c
++=======
+ void arm_smmu_tlb_inv_range_asid(unsigned long iova, size_t size, int asid,
+ 				 size_t granule, bool leaf,
+ 				 struct arm_smmu_domain *smmu_domain)
+ {
+ 	struct arm_smmu_cmdq_ent cmd = {
+ 		.opcode	= smmu_domain->smmu->features & ARM_SMMU_FEAT_E2H ?
+ 			  CMDQ_OP_TLBI_EL2_VA : CMDQ_OP_TLBI_NH_VA,
+ 		.tlbi = {
+ 			.asid	= asid,
+ 			.leaf	= leaf,
+ 		},
+ 	};
+ 
+ 	__arm_smmu_tlb_inv_range(&cmd, iova, size, granule, smmu_domain);
+ }
+ 
++>>>>>>> 9111aebf770d (iommu/arm-smmu-v3: Add support for VHE):drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
  static void arm_smmu_tlb_inv_page_nosync(struct iommu_iotlb_gather *gather,
  					 unsigned long iova, size_t granule,
  					 void *cookie)
* Unmerged path drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
* Unmerged path drivers/iommu/arm-smmu-v3.c
* Unmerged path drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
