net: allow traceroute with a specified interface in a vrf

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Mike Manning <mmanning@vyatta.att-mail.com>
commit f64bf6b8ae802e93231155b0d92a619d896cd0bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/f64bf6b8.failed

Traceroute executed in a vrf succeeds if no device is given or if the
vrf is given as the device, but fails if the interface is given as the
device. This is for default UDP probes, it succeeds for TCP SYN or ICMP
ECHO probes. As the skb bound dev is the interface and the sk dev is
the vrf, sk lookup fails for ICMP_DEST_UNREACH and ICMP_TIME_EXCEEDED
messages. The solution is for the secondary dev to be passed so that
the interface is available for the device match to succeed, in the same
way as is already done for non-error cases.

	Signed-off-by: Mike Manning <mmanning@vyatta.att-mail.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f64bf6b8ae802e93231155b0d92a619d896cd0bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc net/ipv4/udp.c
index fcf45cd0a19e,ca3ed931f2a9..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -681,18 -609,11 +681,26 @@@ int __udp4_lib_err(struct sk_buff *skb
  	struct net *net = dev_net(skb->dev);
  
  	sk = __udp4_lib_lookup(net, iph->daddr, uh->dest,
++<<<<<<< HEAD
 +			       iph->saddr, uh->source, skb->dev->ifindex, 0,
 +			       udptable, NULL);
 +	if (!sk || udp_sk(sk)->encap_type) {
 +		/* No socket for error: try tunnels before discarding */
 +		if (static_branch_unlikely(&udp_encap_needed_key))
 +			sk = __udp4_lib_err_encap(net, iph, uh, udptable, skb);
 +
 +		if (!sk) {
 +			__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);
 +			return -ENOENT;
 +		}
 +		tunnel = true;
++=======
+ 			       iph->saddr, uh->source, skb->dev->ifindex,
+ 			       inet_sdif(skb), udptable, NULL);
+ 	if (!sk) {
+ 		__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);
+ 		return;	/* No socket for error */
++>>>>>>> f64bf6b8ae80 (net: allow traceroute with a specified interface in a vrf)
  	}
  
  	err = 0;
diff --cc net/ipv6/udp.c
index ce21cb783201,d2d97d07ef27..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -543,20 -478,11 +543,28 @@@ int __udp6_lib_err(struct sk_buff *skb
  	struct net *net = dev_net(skb->dev);
  
  	sk = __udp6_lib_lookup(net, daddr, uh->dest, saddr, uh->source,
++<<<<<<< HEAD
 +			       inet6_iif(skb), 0, udptable, NULL);
 +	if (!sk || udp_sk(sk)->encap_type) {
 +		/* No socket for error: try tunnels before discarding */
 +		if (static_branch_unlikely(&udpv6_encap_needed_key)) {
 +			sk = __udp6_lib_err_encap(net, hdr, offset, uh,
 +						  udptable, skb);
 +		}
 +
 +		if (!sk) {
 +			__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),
 +					  ICMP6_MIB_INERRORS);
 +			return -ENOENT;
 +		}
 +		tunnel = true;
++=======
+ 			       inet6_iif(skb), inet6_sdif(skb), udptable, skb);
+ 	if (!sk) {
+ 		__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),
+ 				  ICMP6_MIB_INERRORS);
+ 		return;
++>>>>>>> f64bf6b8ae80 (net: allow traceroute with a specified interface in a vrf)
  	}
  
  	harderr = icmpv6_err_convert(type, code, &err);
* Unmerged path net/ipv4/udp.c
* Unmerged path net/ipv6/udp.c
