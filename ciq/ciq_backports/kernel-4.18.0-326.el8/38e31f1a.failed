drm/i915: Extract skl_ddi_{enable,disable}_clock()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 38e31f1acd643f27881e2a5a3e117e265b38d78f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/38e31f1a.failed

Extract the DDI clock routing clode for skl/derivatives
into the new encoder vfuncs.

v2: s/dev_priv/i915/ (Lucas)

	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210205214634.19341-5-ville.syrjala@linux.intel.com
(cherry picked from commit 38e31f1acd643f27881e2a5a3e117e265b38d78f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 87726ca7041c,dba6c98a8ccf..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -3003,20 -1887,6 +3003,23 @@@ static void intel_ddi_clk_select(struc
  		val = intel_de_read(dev_priv, DPCLKA_CFGCR0);
  		val &= ~DPCLKA_CFGCR0_DDI_CLK_OFF(port);
  		intel_de_write(dev_priv, DPCLKA_CFGCR0, val);
++<<<<<<< HEAD
 +	} else if (IS_GEN9_BC(dev_priv)) {
 +		/* DDI -> PLL mapping  */
 +		val = intel_de_read(dev_priv, DPLL_CTRL2);
 +
 +		val &= ~(DPLL_CTRL2_DDI_CLK_OFF(port) |
 +			 DPLL_CTRL2_DDI_CLK_SEL_MASK(port));
 +		val |= (DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |
 +			DPLL_CTRL2_DDI_SEL_OVERRIDE(port));
 +
 +		intel_de_write(dev_priv, DPLL_CTRL2, val);
 +
 +	} else if (INTEL_GEN(dev_priv) < 9) {
 +		intel_de_write(dev_priv, PORT_CLK_SEL(port),
 +			       hsw_pll_to_ddi_pll_sel(pll));
++=======
++>>>>>>> 38e31f1acd64 (drm/i915: Extract skl_ddi_{enable,disable}_clock())
  	}
  
  	mutex_unlock(&dev_priv->dpll.lock);
@@@ -3036,15 -1906,81 +3039,93 @@@ static void intel_ddi_clk_disable(struc
  	} else if (IS_CANNONLAKE(dev_priv)) {
  		intel_de_write(dev_priv, DPCLKA_CFGCR0,
  			       intel_de_read(dev_priv, DPCLKA_CFGCR0) | DPCLKA_CFGCR0_DDI_CLK_OFF(port));
++<<<<<<< HEAD
 +	} else if (IS_GEN9_BC(dev_priv)) {
 +		intel_de_write(dev_priv, DPLL_CTRL2,
 +			       intel_de_read(dev_priv, DPLL_CTRL2) | DPLL_CTRL2_DDI_CLK_OFF(port));
 +	} else if (INTEL_GEN(dev_priv) < 9) {
 +		intel_de_write(dev_priv, PORT_CLK_SEL(port),
 +			       PORT_CLK_SEL_NONE);
 +	}
 +}
 +
++=======
+ 	}
+ }
+ 
+ static void skl_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	val = intel_de_read(i915, DPLL_CTRL2);
+ 
+ 	val &= ~(DPLL_CTRL2_DDI_CLK_OFF(port) |
+ 		 DPLL_CTRL2_DDI_CLK_SEL_MASK(port));
+ 	val |= (DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |
+ 		DPLL_CTRL2_DDI_SEL_OVERRIDE(port));
+ 
+ 	intel_de_write(i915, DPLL_CTRL2, val);
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void skl_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, DPLL_CTRL2,
+ 		       intel_de_read(i915, DPLL_CTRL2) | DPLL_CTRL2_DDI_CLK_OFF(port));
+ }
+ 
+ void hsw_ddi_enable_clock(struct intel_encoder *encoder,
+ 			  const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	intel_de_write(i915, PORT_CLK_SEL(port), hsw_pll_to_ddi_pll_sel(pll));
+ }
+ 
+ void hsw_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, PORT_CLK_SEL(port), PORT_CLK_SEL_NONE);
+ }
+ 
+ void intel_ddi_enable_clock(struct intel_encoder *encoder,
+ 			    const struct intel_crtc_state *crtc_state)
+ {
+ 	if (encoder->enable_clock)
+ 		encoder->enable_clock(encoder, crtc_state);
+ 	else
+ 		intel_ddi_clk_select(encoder, crtc_state);
+ }
+ 
+ static void intel_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	if (encoder->disable_clock)
+ 		encoder->disable_clock(encoder);
+ 	else
+ 		intel_ddi_clk_disable(encoder);
+ }
+ 
++>>>>>>> 38e31f1acd64 (drm/i915: Extract skl_ddi_{enable,disable}_clock())
  static void
  icl_program_mg_dp_mode(struct intel_digital_port *dig_port,
  		       const struct intel_crtc_state *crtc_state)
@@@ -4970,6 -4118,31 +5051,34 @@@ void intel_ddi_init(struct drm_i915_pri
  	encoder->cloneable = 0;
  	encoder->pipe_mask = ~0;
  
++<<<<<<< HEAD
++=======
+ 	if (IS_GEN9_BC(dev_priv)) {
+ 		encoder->enable_clock = skl_ddi_enable_clock;
+ 		encoder->disable_clock = skl_ddi_disable_clock;
+ 	} else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {
+ 		encoder->enable_clock = hsw_ddi_enable_clock;
+ 		encoder->disable_clock = hsw_ddi_disable_clock;
+ 	}
+ 
+ 	if (IS_DG1(dev_priv))
+ 		encoder->hpd_pin = dg1_hpd_pin(dev_priv, port);
+ 	else if (IS_ROCKETLAKE(dev_priv))
+ 		encoder->hpd_pin = rkl_hpd_pin(dev_priv, port);
+ 	else if (INTEL_GEN(dev_priv) >= 12)
+ 		encoder->hpd_pin = tgl_hpd_pin(dev_priv, port);
+ 	else if (IS_JSL_EHL(dev_priv))
+ 		encoder->hpd_pin = ehl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 11))
+ 		encoder->hpd_pin = icl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 10))
+ 		encoder->hpd_pin = cnl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 9))
+ 		encoder->hpd_pin = skl_hpd_pin(dev_priv, port);
+ 	else
+ 		encoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);
+ 
++>>>>>>> 38e31f1acd64 (drm/i915: Extract skl_ddi_{enable,disable}_clock())
  	if (INTEL_GEN(dev_priv) >= 11)
  		dig_port->saved_port_bits =
  			intel_de_read(dev_priv, DDI_BUF_CTL(port))
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
