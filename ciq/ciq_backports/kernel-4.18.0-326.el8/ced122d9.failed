sock: expose so_timestamping options for mptcp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Florian Westphal <fw@strlen.de>
commit ced122d90f52eb6ff37272e32941845d46ac64c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/ced122d9.failed

Similar to previous patch: expose SO_TIMESTAMPING helper so we do not
have to copy & paste this into the mptcp core.

	Acked-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ced122d90f52eb6ff37272e32941845d46ac64c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
#	net/core/sock.c
diff --cc include/net/sock.h
index af8e0faa1fb6,9b341c2c924f..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -2650,6 -2743,10 +2650,13 @@@ static inline bool sk_dev_equal_l3scope
  void sock_def_readable(struct sock *sk);
  
  int sock_bindtoindex(struct sock *sk, int ifindex, bool lock_sk);
++<<<<<<< HEAD
++=======
+ void sock_set_timestamp(struct sock *sk, int optname, bool valbool);
+ int sock_set_timestamping(struct sock *sk, int optname, int val);
+ 
+ void sock_enable_timestamps(struct sock *sk);
++>>>>>>> ced122d90f52 (sock: expose so_timestamping options for mptcp)
  void sock_no_linger(struct sock *sk);
  void sock_set_keepalive(struct sock *sk);
  void sock_set_priority(struct sock *sk, u32 priority);
diff --cc net/core/sock.c
index 72337c8d4eb6,bd887cb075ce..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -774,6 -736,98 +774,101 @@@ void sock_no_linger(struct sock *sk
  }
  EXPORT_SYMBOL(sock_no_linger);
  
++<<<<<<< HEAD
++=======
+ void sock_set_priority(struct sock *sk, u32 priority)
+ {
+ 	lock_sock(sk);
+ 	sk->sk_priority = priority;
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_priority);
+ 
+ void sock_set_sndtimeo(struct sock *sk, s64 secs)
+ {
+ 	lock_sock(sk);
+ 	if (secs && secs < MAX_SCHEDULE_TIMEOUT / HZ - 1)
+ 		sk->sk_sndtimeo = secs * HZ;
+ 	else
+ 		sk->sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_sndtimeo);
+ 
+ static void __sock_set_timestamps(struct sock *sk, bool val, bool new, bool ns)
+ {
+ 	if (val)  {
+ 		sock_valbool_flag(sk, SOCK_TSTAMP_NEW, new);
+ 		sock_valbool_flag(sk, SOCK_RCVTSTAMPNS, ns);
+ 		sock_set_flag(sk, SOCK_RCVTSTAMP);
+ 		sock_enable_timestamp(sk, SOCK_TIMESTAMP);
+ 	} else {
+ 		sock_reset_flag(sk, SOCK_RCVTSTAMP);
+ 		sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
+ 	}
+ }
+ 
+ void sock_enable_timestamps(struct sock *sk)
+ {
+ 	lock_sock(sk);
+ 	__sock_set_timestamps(sk, true, false, true);
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_enable_timestamps);
+ 
+ void sock_set_timestamp(struct sock *sk, int optname, bool valbool)
+ {
+ 	switch (optname) {
+ 	case SO_TIMESTAMP_OLD:
+ 		__sock_set_timestamps(sk, valbool, false, false);
+ 		break;
+ 	case SO_TIMESTAMP_NEW:
+ 		__sock_set_timestamps(sk, valbool, true, false);
+ 		break;
+ 	case SO_TIMESTAMPNS_OLD:
+ 		__sock_set_timestamps(sk, valbool, false, true);
+ 		break;
+ 	case SO_TIMESTAMPNS_NEW:
+ 		__sock_set_timestamps(sk, valbool, true, true);
+ 		break;
+ 	}
+ }
+ 
+ int sock_set_timestamping(struct sock *sk, int optname, int val)
+ {
+ 	if (val & ~SOF_TIMESTAMPING_MASK)
+ 		return -EINVAL;
+ 
+ 	if (val & SOF_TIMESTAMPING_OPT_ID &&
+ 	    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {
+ 		if (sk->sk_protocol == IPPROTO_TCP &&
+ 		    sk->sk_type == SOCK_STREAM) {
+ 			if ((1 << sk->sk_state) &
+ 			    (TCPF_CLOSE | TCPF_LISTEN))
+ 				return -EINVAL;
+ 			sk->sk_tskey = tcp_sk(sk)->snd_una;
+ 		} else {
+ 			sk->sk_tskey = 0;
+ 		}
+ 	}
+ 
+ 	if (val & SOF_TIMESTAMPING_OPT_STATS &&
+ 	    !(val & SOF_TIMESTAMPING_OPT_TSONLY))
+ 		return -EINVAL;
+ 
+ 	sk->sk_tsflags = val;
+ 	sock_valbool_flag(sk, SOCK_TSTAMP_NEW, optname == SO_TIMESTAMPING_NEW);
+ 
+ 	if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
+ 		sock_enable_timestamp(sk,
+ 				      SOCK_TIMESTAMPING_RX_SOFTWARE);
+ 	else
+ 		sock_disable_timestamp(sk,
+ 				       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
+ 	return 0;
+ }
+ 
++>>>>>>> ced122d90f52 (sock: expose so_timestamping options for mptcp)
  void sock_set_keepalive(struct sock *sk)
  {
  	lock_sock(sk);
@@@ -972,55 -1040,16 +1067,61 @@@ set_rcvbuf
  			clear_bit(SOCK_PASSCRED, &sock->flags);
  		break;
  
 -	case SO_TIMESTAMP_OLD:
 -	case SO_TIMESTAMP_NEW:
 -	case SO_TIMESTAMPNS_OLD:
 -	case SO_TIMESTAMPNS_NEW:
 -		sock_set_timestamp(sk, valbool, optname);
 +	case SO_TIMESTAMP:
 +	case SO_TIMESTAMPNS:
 +		if (valbool)  {
 +			if (optname == SO_TIMESTAMP)
 +				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
 +			else
 +				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
 +			sock_set_flag(sk, SOCK_RCVTSTAMP);
 +			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 +		} else {
 +			sock_reset_flag(sk, SOCK_RCVTSTAMP);
 +			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
 +		}
  		break;
  
++<<<<<<< HEAD
 +	case SO_TIMESTAMPING:
 +		if (val & ~SOF_TIMESTAMPING_MASK) {
 +			ret = -EINVAL;
 +			break;
 +		}
 +
 +		if (val & SOF_TIMESTAMPING_OPT_ID &&
 +		    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {
 +			if (sk->sk_protocol == IPPROTO_TCP &&
 +			    sk->sk_type == SOCK_STREAM) {
 +				if ((1 << sk->sk_state) &
 +				    (TCPF_CLOSE | TCPF_LISTEN)) {
 +					ret = -EINVAL;
 +					break;
 +				}
 +				sk->sk_tskey = tcp_sk(sk)->snd_una;
 +			} else {
 +				sk->sk_tskey = 0;
 +			}
 +		}
 +
 +		if (val & SOF_TIMESTAMPING_OPT_STATS &&
 +		    !(val & SOF_TIMESTAMPING_OPT_TSONLY)) {
 +			ret = -EINVAL;
 +			break;
 +		}
 +
 +		sk->sk_tsflags = val;
 +		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
 +			sock_enable_timestamp(sk,
 +					      SOCK_TIMESTAMPING_RX_SOFTWARE);
 +		else
 +			sock_disable_timestamp(sk,
 +					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
++=======
+ 	case SO_TIMESTAMPING_NEW:
+ 	case SO_TIMESTAMPING_OLD:
+ 		ret = sock_set_timestamping(sk, optname, val);
++>>>>>>> ced122d90f52 (sock: expose so_timestamping options for mptcp)
  		break;
  
  	case SO_RCVLOWAT:
* Unmerged path include/net/sock.h
* Unmerged path net/core/sock.c
