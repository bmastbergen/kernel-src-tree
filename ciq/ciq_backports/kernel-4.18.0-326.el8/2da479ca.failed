ionic: generic tx skb mapping

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Shannon Nelson <snelson@pensando.io>
commit 2da479ca0814c604454616ad1de813ab662e23cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/2da479ca.failed

Make the new ionic_tx_map_tso() usable by the non-TSO paths,
and pull the call up a level into ionic_tx() before calling
the csum or no-csum routines.

	Signed-off-by: Shannon Nelson <snelson@pensando.io>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2da479ca0814c604454616ad1de813ab662e23cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/pensando/ionic/ionic_txrx.c
diff --cc drivers/net/ethernet/pensando/ionic/ionic_txrx.c
index 8369e1e143a1,1d27d6cad504..000000000000
--- a/drivers/net/ethernet/pensando/ionic/ionic_txrx.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_txrx.c
@@@ -631,6 -605,50 +631,53 @@@ static dma_addr_t ionic_tx_map_frag(str
  	return dma_addr;
  }
  
++<<<<<<< HEAD
++=======
+ static int ionic_tx_map_skb(struct ionic_queue *q, struct sk_buff *skb,
+ 			    struct ionic_desc_info *desc_info)
+ {
+ 	struct ionic_buf_info *buf_info = desc_info->bufs;
+ 	struct device *dev = q->dev;
+ 	dma_addr_t dma_addr;
+ 	unsigned int nfrags;
+ 	skb_frag_t *frag;
+ 	int frag_idx;
+ 
+ 	dma_addr = ionic_tx_map_single(q, skb->data, skb_headlen(skb));
+ 	if (dma_mapping_error(dev, dma_addr))
+ 		return -EIO;
+ 	buf_info->dma_addr = dma_addr;
+ 	buf_info->len = skb_headlen(skb);
+ 	buf_info++;
+ 
+ 	frag = skb_shinfo(skb)->frags;
+ 	nfrags = skb_shinfo(skb)->nr_frags;
+ 	for (frag_idx = 0; frag_idx < nfrags; frag_idx++, frag++) {
+ 		dma_addr = ionic_tx_map_frag(q, frag, 0, skb_frag_size(frag));
+ 		if (dma_mapping_error(dev, dma_addr))
+ 			goto dma_fail;
+ 		buf_info->dma_addr = dma_addr;
+ 		buf_info->len = skb_frag_size(frag);
+ 		buf_info++;
+ 	}
+ 
+ 	desc_info->nbufs = 1 + nfrags;
+ 
+ 	return 0;
+ 
+ dma_fail:
+ 	/* unwind the frag mappings and the head mapping */
+ 	while (frag_idx > 0) {
+ 		frag_idx--;
+ 		buf_info--;
+ 		dma_unmap_page(dev, buf_info->dma_addr,
+ 			       buf_info->len, DMA_TO_DEVICE);
+ 	}
+ 	dma_unmap_single(dev, buf_info->dma_addr, buf_info->len, DMA_TO_DEVICE);
+ 	return -EIO;
+ }
+ 
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  static void ionic_tx_clean(struct ionic_queue *q,
  			   struct ionic_desc_info *desc_info,
  			   struct ionic_cq_info *cq_info,
@@@ -811,38 -832,21 +858,42 @@@ static void ionic_tx_tso_post(struct io
  static int ionic_tx_tso(struct ionic_queue *q, struct sk_buff *skb)
  {
  	struct ionic_tx_stats *stats = q_to_tx_stats(q);
++<<<<<<< HEAD
 +	struct ionic_desc_info *rewind_desc_info;
 +	struct device *dev = q->lif->ionic->dev;
 +	struct ionic_txq_sg_elem *elem;
 +	struct ionic_txq_desc *desc;
 +	unsigned int frag_left = 0;
 +	unsigned int offset = 0;
 +	u16 abort = q->head_idx;
 +	unsigned int len_left;
++=======
+ 	struct ionic_desc_info *desc_info;
+ 	struct ionic_buf_info *buf_info;
+ 	struct ionic_txq_sg_elem *elem;
+ 	struct ionic_txq_desc *desc;
+ 	unsigned int chunk_len;
+ 	unsigned int frag_rem;
+ 	unsigned int tso_rem;
+ 	unsigned int seg_rem;
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  	dma_addr_t desc_addr;
 -	dma_addr_t frag_addr;
  	unsigned int hdrlen;
++<<<<<<< HEAD
 +	unsigned int nfrags;
 +	unsigned int seglen;
 +	u64 total_bytes = 0;
 +	u64 total_pkts = 0;
 +	u16 rewind = abort;
 +	unsigned int left;
++=======
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  	unsigned int len;
  	unsigned int mss;
 +	skb_frag_t *frag;
  	bool start, done;
  	bool outer_csum;
 +	dma_addr_t addr;
  	bool has_vlan;
  	u16 desc_len;
  	u8 desc_nsge;
@@@ -850,9 -854,14 +901,20 @@@
  	bool encap;
  	int err;
  
++<<<<<<< HEAD
 +	mss = skb_shinfo(skb)->gso_size;
 +	nfrags = skb_shinfo(skb)->nr_frags;
 +	len_left = skb->len - skb_headlen(skb);
++=======
+ 	desc_info = &q->info[q->head_idx];
+ 	buf_info = desc_info->bufs;
+ 
+ 	if (unlikely(ionic_tx_map_skb(q, skb, desc_info)))
+ 		return -EIO;
+ 
+ 	len = skb->len;
+ 	mss = skb_shinfo(skb)->gso_size;
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  	outer_csum = (skb_shinfo(skb)->gso_type & SKB_GSO_GRE_CSUM) ||
  		     (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM);
  	has_vlan = !!skb_vlan_tag_present(skb);
@@@ -877,125 -886,75 +939,178 @@@
  	else
  		hdrlen = skb_transport_offset(skb) + tcp_hdrlen(skb);
  
++<<<<<<< HEAD
 +	seglen = hdrlen + mss;
 +	left = skb_headlen(skb);
++=======
+ 	tso_rem = len;
+ 	seg_rem = min(tso_rem, hdrlen + mss);
+ 
+ 	frag_addr = 0;
+ 	frag_rem = 0;
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  
 +	desc = ionic_tx_tso_next(q, &elem);
  	start = true;
  
 -	while (tso_rem > 0) {
 -		desc = NULL;
 -		elem = NULL;
 -		desc_addr = 0;
 -		desc_len = 0;
 +	/* Chop skb->data up into desc segments */
 +
 +	while (left > 0) {
 +		len = min(seglen, left);
 +		frag_left = seglen - len;
 +		desc_addr = ionic_tx_map_single(q, skb->data + offset, len);
 +		if (dma_mapping_error(dev, desc_addr))
 +			goto err_out_abort;
 +		desc_len = len;
  		desc_nsge = 0;
++<<<<<<< HEAD
 +		left -= len;
 +		offset += len;
 +		if (nfrags > 0 && frag_left > 0)
 +			continue;
 +		done = (nfrags == 0 && left == 0);
++=======
+ 		/* use fragments until we have enough to post a single descriptor */
+ 		while (seg_rem > 0) {
+ 			/* if the fragment is exhausted then move to the next one */
+ 			if (frag_rem == 0) {
+ 				/* grab the next fragment */
+ 				frag_addr = buf_info->dma_addr;
+ 				frag_rem = buf_info->len;
+ 				buf_info++;
+ 			}
+ 			chunk_len = min(frag_rem, seg_rem);
+ 			if (!desc) {
+ 				/* fill main descriptor */
+ 				desc = desc_info->txq_desc;
+ 				elem = desc_info->txq_sg_desc->elems;
+ 				desc_addr = frag_addr;
+ 				desc_len = chunk_len;
+ 			} else {
+ 				/* fill sg descriptor */
+ 				elem->addr = cpu_to_le64(frag_addr);
+ 				elem->len = cpu_to_le16(chunk_len);
+ 				elem++;
+ 				desc_nsge++;
+ 			}
+ 			frag_addr += chunk_len;
+ 			frag_rem -= chunk_len;
+ 			tso_rem -= chunk_len;
+ 			seg_rem -= chunk_len;
+ 		}
+ 		seg_rem = min(tso_rem, mss);
+ 		done = (tso_rem == 0);
+ 		/* post descriptor */
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  		ionic_tx_tso_post(q, desc, skb,
  				  desc_addr, desc_nsge, desc_len,
 -				  hdrlen, mss, outer_csum, vlan_tci, has_vlan,
 +				  hdrlen, mss,
 +				  outer_csum,
 +				  vlan_tci, has_vlan,
  				  start, done);
 +		total_pkts++;
 +		total_bytes += start ? len : len + hdrlen;
 +		desc = ionic_tx_tso_next(q, &elem);
  		start = false;
++<<<<<<< HEAD
 +		seglen = mss;
++=======
+ 		/* Buffer information is stored with the first tso descriptor */
+ 		desc_info = &q->info[q->head_idx];
+ 		desc_info->nbufs = 0;
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
 +	}
 +
 +	/* Chop skb frags into desc segments */
 +
 +	for (frag = skb_shinfo(skb)->frags; len_left; frag++) {
 +		offset = 0;
 +		left = skb_frag_size(frag);
 +		len_left -= left;
 +		nfrags--;
 +		stats->frags++;
 +
 +		while (left > 0) {
 +			if (frag_left > 0) {
 +				len = min(frag_left, left);
 +				frag_left -= len;
 +				addr = ionic_tx_map_frag(q, frag, offset, len);
 +				if (dma_mapping_error(dev, addr))
 +					goto err_out_abort;
 +				elem->addr = cpu_to_le64(addr);
 +				elem->len = cpu_to_le16(len);
 +				elem++;
 +				desc_nsge++;
 +				left -= len;
 +				offset += len;
 +				if (nfrags > 0 && frag_left > 0)
 +					continue;
 +				done = (nfrags == 0 && left == 0);
 +				ionic_tx_tso_post(q, desc, skb, desc_addr,
 +						  desc_nsge, desc_len,
 +						  hdrlen, mss, outer_csum,
 +						  vlan_tci, has_vlan,
 +						  start, done);
 +				total_pkts++;
 +				total_bytes += start ? len : len + hdrlen;
 +				desc = ionic_tx_tso_next(q, &elem);
 +				start = false;
 +			} else {
 +				len = min(mss, left);
 +				frag_left = mss - len;
 +				desc_addr = ionic_tx_map_frag(q, frag,
 +							      offset, len);
 +				if (dma_mapping_error(dev, desc_addr))
 +					goto err_out_abort;
 +				desc_len = len;
 +				desc_nsge = 0;
 +				left -= len;
 +				offset += len;
 +				if (nfrags > 0 && frag_left > 0)
 +					continue;
 +				done = (nfrags == 0 && left == 0);
 +				ionic_tx_tso_post(q, desc, skb, desc_addr,
 +						  desc_nsge, desc_len,
 +						  hdrlen, mss, outer_csum,
 +						  vlan_tci, has_vlan,
 +						  start, done);
 +				total_pkts++;
 +				total_bytes += start ? len : len + hdrlen;
 +				desc = ionic_tx_tso_next(q, &elem);
 +				start = false;
 +			}
 +		}
  	}
  
 -	stats->pkts += DIV_ROUND_UP(len - hdrlen, mss);
 -	stats->bytes += len;
 +	stats->pkts += total_pkts;
 +	stats->bytes += total_bytes;
  	stats->tso++;
 -	stats->tso_bytes = len;
 +	stats->tso_bytes += total_bytes;
  
  	return 0;
 +
 +err_out_abort:
 +	while (rewind != q->head_idx) {
 +		rewind_desc_info = &q->info[rewind];
 +		ionic_tx_clean(q, rewind_desc_info, NULL, NULL);
 +		rewind = (rewind + 1) & (q->num_descs - 1);
 +	}
 +	q->head_idx = abort;
 +
 +	return -ENOMEM;
  }
  
- static int ionic_tx_calc_csum(struct ionic_queue *q, struct sk_buff *skb)
+ static int ionic_tx_calc_csum(struct ionic_queue *q, struct sk_buff *skb,
+ 			      struct ionic_desc_info *desc_info)
  {
- 	struct ionic_txq_desc *desc = q->info[q->head_idx].txq_desc;
+ 	struct ionic_txq_desc *desc = desc_info->txq_desc;
+ 	struct ionic_buf_info *buf_info = desc_info->bufs;
  	struct ionic_tx_stats *stats = q_to_tx_stats(q);
++<<<<<<< HEAD
 +	struct device *dev = q->lif->ionic->dev;
 +	dma_addr_t dma_addr;
++=======
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  	bool has_vlan;
  	u8 flags = 0;
  	bool encap;
@@@ -1030,12 -988,12 +1144,17 @@@
  	return 0;
  }
  
- static int ionic_tx_calc_no_csum(struct ionic_queue *q, struct sk_buff *skb)
+ static int ionic_tx_calc_no_csum(struct ionic_queue *q, struct sk_buff *skb,
+ 				 struct ionic_desc_info *desc_info)
  {
- 	struct ionic_txq_desc *desc = q->info[q->head_idx].txq_desc;
+ 	struct ionic_txq_desc *desc = desc_info->txq_desc;
+ 	struct ionic_buf_info *buf_info = desc_info->bufs;
  	struct ionic_tx_stats *stats = q_to_tx_stats(q);
++<<<<<<< HEAD
 +	struct device *dev = q->lif->ionic->dev;
 +	dma_addr_t dma_addr;
++=======
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  	bool has_vlan;
  	u8 flags = 0;
  	bool encap;
@@@ -1065,28 -1024,22 +1185,29 @@@
  	return 0;
  }
  
- static int ionic_tx_skb_frags(struct ionic_queue *q, struct sk_buff *skb)
+ static int ionic_tx_skb_frags(struct ionic_queue *q, struct sk_buff *skb,
+ 			      struct ionic_desc_info *desc_info)
  {
- 	struct ionic_txq_sg_desc *sg_desc = q->info[q->head_idx].txq_sg_desc;
- 	unsigned int len_left = skb->len - skb_headlen(skb);
+ 	struct ionic_txq_sg_desc *sg_desc = desc_info->txq_sg_desc;
+ 	struct ionic_buf_info *buf_info = &desc_info->bufs[1];
  	struct ionic_txq_sg_elem *elem = sg_desc->elems;
  	struct ionic_tx_stats *stats = q_to_tx_stats(q);
++<<<<<<< HEAD
 +	struct device *dev = q->lif->ionic->dev;
 +	dma_addr_t dma_addr;
 +	skb_frag_t *frag;
 +	u16 len;
++=======
+ 	unsigned int i;
++>>>>>>> 2da479ca0814 (ionic: generic tx skb mapping)
  
- 	for (frag = skb_shinfo(skb)->frags; len_left; frag++, elem++) {
- 		len = skb_frag_size(frag);
- 		elem->len = cpu_to_le16(len);
- 		dma_addr = ionic_tx_map_frag(q, frag, 0, len);
- 		if (dma_mapping_error(dev, dma_addr))
- 			return -ENOMEM;
- 		elem->addr = cpu_to_le64(dma_addr);
- 		len_left -= len;
- 		stats->frags++;
+ 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++, buf_info++, elem++) {
+ 		elem->addr = cpu_to_le64(buf_info->dma_addr);
+ 		elem->len = cpu_to_le16(buf_info->len);
  	}
  
+ 	stats->frags += skb_shinfo(skb)->nr_frags;
+ 
  	return 0;
  }
  
* Unmerged path drivers/net/ethernet/pensando/ionic/ionic_txrx.c
