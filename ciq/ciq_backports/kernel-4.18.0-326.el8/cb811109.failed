bpf: Adds support for setting window clamp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Prankur gupta <prankgup@fb.com>
commit cb81110997d1f5097f29dd8e49d32a1fc55cbf86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/cb811109.failed

Adds a new bpf_setsockopt for TCP sockets, TCP_BPF_WINDOW_CLAMP,
which sets the maximum receiver window size. It will be useful for
limiting receiver window based on RTT.

	Signed-off-by: Prankur gupta <prankgup@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20201202213152.435886-2-prankgup@fb.com
(cherry picked from commit cb81110997d1f5097f29dd8e49d32a1fc55cbf86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
diff --cc net/ipv4/tcp.c
index 5426b63bed77,17379f6dd955..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -2845,6 -2998,45 +2845,48 @@@ int tcp_sock_set_keepidle(struct sock *
  }
  EXPORT_SYMBOL(tcp_sock_set_keepidle);
  
++<<<<<<< HEAD
++=======
+ int tcp_sock_set_keepintvl(struct sock *sk, int val)
+ {
+ 	if (val < 1 || val > MAX_TCP_KEEPINTVL)
+ 		return -EINVAL;
+ 
+ 	lock_sock(sk);
+ 	tcp_sk(sk)->keepalive_intvl = val * HZ;
+ 	release_sock(sk);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(tcp_sock_set_keepintvl);
+ 
+ int tcp_sock_set_keepcnt(struct sock *sk, int val)
+ {
+ 	if (val < 1 || val > MAX_TCP_KEEPCNT)
+ 		return -EINVAL;
+ 
+ 	lock_sock(sk);
+ 	tcp_sk(sk)->keepalive_probes = val;
+ 	release_sock(sk);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(tcp_sock_set_keepcnt);
+ 
+ int tcp_set_window_clamp(struct sock *sk, int val)
+ {
+ 	struct tcp_sock *tp = tcp_sk(sk);
+ 
+ 	if (!val) {
+ 		if (sk->sk_state != TCP_CLOSE)
+ 			return -EINVAL;
+ 		tp->window_clamp = 0;
+ 	} else {
+ 		tp->window_clamp = val < SOCK_MIN_RCVBUF / 2 ?
+ 			SOCK_MIN_RCVBUF / 2 : val;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> cb81110997d1 (bpf: Adds support for setting window clamp)
  /*
   *	Socket option code for TCP.
   */
diff --git a/include/net/tcp.h b/include/net/tcp.h
index 45046e9e247c..681cbe58929d 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -416,6 +416,7 @@ void tcp_syn_ack_timeout(const struct request_sock *req);
 int tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
 		int flags, int *addr_len);
 int tcp_set_rcvlowat(struct sock *sk, int val);
+int tcp_set_window_clamp(struct sock *sk, int val);
 void tcp_data_ready(struct sock *sk);
 #ifdef CONFIG_MMU
 int tcp_mmap(struct file *file, struct socket *sock,
diff --git a/net/core/filter.c b/net/core/filter.c
index c817409c6680..0d0d8ee639ce 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -4916,6 +4916,9 @@ static int _bpf_setsockopt(struct sock *sk, int level, int optname,
 				tp->notsent_lowat = val;
 				sk->sk_write_space(sk);
 				break;
+			case TCP_WINDOW_CLAMP:
+				ret = tcp_set_window_clamp(sk, val);
+				break;
 			default:
 				ret = -EINVAL;
 			}
* Unmerged path net/ipv4/tcp.c
