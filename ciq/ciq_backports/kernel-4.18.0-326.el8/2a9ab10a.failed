net/mlx5e: TC, Add sampler termination table API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Chris Mi <cmi@nvidia.com>
commit 2a9ab10a5689a4612d441df1cc628c381dc75ed3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/2a9ab10a.failed

Sampled packets are sent to software using termination tables. There
is only one rule in that table that is to forward sampled packets to
the e-switch management vport.

Create a sampler termination table and rule for each eswitch.

	Signed-off-by: Chris Mi <cmi@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 2a9ab10a5689a4612d441df1cc628c381dc75ed3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 8d4d2686ea65,1a403112defd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -63,6 -64,9 +63,12 @@@
  #include "en/mapping.h"
  #include "en/tc_ct.h"
  #include "en/mod_hdr.h"
++<<<<<<< HEAD
++=======
+ #include "en/tc_priv.h"
+ #include "en/tc_tun_encap.h"
+ #include "esw/sample.h"
++>>>>>>> 2a9ab10a5689 (net/mlx5e: TC, Add sampler termination table API)
  #include "lib/devcom.h"
  #include "lib/geneve.h"
  #include "lib/fs_chains.h"
@@@ -5275,17 -4861,26 +5281,21 @@@ int mlx5e_tc_esw_init(struct rhashtabl
  {
  	const size_t sz_enc_opts = sizeof(struct tunnel_match_enc_opts);
  	struct mlx5_rep_uplink_priv *uplink_priv;
 -	struct mlx5e_rep_priv *rpriv;
 +	struct mlx5e_rep_priv *priv;
  	struct mapping_ctx *mapping;
 -	struct mlx5_eswitch *esw;
 -	struct mlx5e_priv *priv;
 -	int err = 0;
 +	int err;
  
  	uplink_priv = container_of(tc_ht, struct mlx5_rep_uplink_priv, tc_ht);
 -	rpriv = container_of(uplink_priv, struct mlx5e_rep_priv, uplink_priv);
 -	priv = netdev_priv(rpriv->netdev);
 -	esw = priv->mdev->priv.eswitch;
 +	priv = container_of(uplink_priv, struct mlx5e_rep_priv, uplink_priv);
  
 -	uplink_priv->ct_priv = mlx5_tc_ct_init(netdev_priv(priv->netdev),
 -					       esw_chains(esw),
 -					       &esw->offloads.mod_hdr,
 -					       MLX5_FLOW_NAMESPACE_FDB);
 +	err = mlx5_tc_ct_init(uplink_priv);
 +	if (err)
 +		goto err_ct;
  
+ #if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
+ 	uplink_priv->esw_psample = mlx5_esw_sample_init(netdev_priv(priv->netdev));
+ #endif
+ 
  	mapping = mapping_create(sizeof(struct tunnel_match_key),
  				 TUNNEL_INFO_BITS_MASK, true);
  	if (IS_ERR(mapping)) {
@@@ -5314,8 -4918,10 +5324,15 @@@ err_ht_init
  err_enc_opts_mapping:
  	mapping_destroy(uplink_priv->tunnel_mapping);
  err_tun_mapping:
++<<<<<<< HEAD
 +	mlx5_tc_ct_clean(uplink_priv);
 +err_ct:
++=======
+ #if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
+ 	mlx5_esw_sample_cleanup(uplink_priv->esw_psample);
+ #endif
+ 	mlx5_tc_ct_clean(uplink_priv->ct_priv);
++>>>>>>> 2a9ab10a5689 (net/mlx5e: TC, Add sampler termination table API)
  	netdev_warn(priv->netdev,
  		    "Failed to initialize tc (eswitch), err: %d", err);
  	return err;
@@@ -5331,7 -4939,10 +5348,14 @@@ void mlx5e_tc_esw_cleanup(struct rhasht
  	mapping_destroy(uplink_priv->tunnel_enc_opts_mapping);
  	mapping_destroy(uplink_priv->tunnel_mapping);
  
++<<<<<<< HEAD
 +	mlx5_tc_ct_clean(uplink_priv);
++=======
+ #if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
+ 	mlx5_esw_sample_cleanup(uplink_priv->esw_psample);
+ #endif
+ 	mlx5_tc_ct_clean(uplink_priv->ct_priv);
++>>>>>>> 2a9ab10a5689 (net/mlx5e: TC, Add sampler termination table API)
  }
  
  int mlx5e_tc_num_filters(struct mlx5e_priv *priv, unsigned long flags)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/Kconfig b/drivers/net/ethernet/mellanox/mlx5/core/Kconfig
index b8cc3a5d2c46..377285810876 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/Kconfig
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Kconfig
@@ -103,6 +103,18 @@ config MLX5_TC_CT
 
 	  If unsure, set to Y
 
+config MLX5_TC_SAMPLE
+	bool "MLX5 TC sample offload support"
+	depends on MLX5_CLS_ACT
+	default y
+	help
+	  Say Y here if you want to support offloading sample rules via tc
+	  sample action.
+	  If set to N, will not be able to configure tc rules with sample
+	  action.
+
+	  If unsure, set to Y
+
 config MLX5_CORE_EN_DCB
 	bool "Data Center Bridging (DCB) Support"
 	default y
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/Makefile b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 586484b0079a..47a6c73c44a7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@ -52,6 +52,7 @@ mlx5_core-$(CONFIG_MLX5_ESWITCH)   += esw/acl/helper.o \
 				      esw/acl/egress_lgcy.o esw/acl/egress_ofld.o \
 				      esw/acl/ingress_lgcy.o esw/acl/ingress_ofld.o \
 				      esw/devlink_port.o esw/vporttbl.o
+mlx5_core-$(CONFIG_MLX5_TC_SAMPLE) += esw/sample.o
 
 mlx5_core-$(CONFIG_MLX5_MPFS)      += lib/mpfs.o
 mlx5_core-$(CONFIG_VXLAN)          += lib/vxlan.o
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 3b54d6f40570..d3ec9ca09633 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -87,6 +87,7 @@ struct mlx5_rep_uplink_priv {
 	struct mapping_ctx *tunnel_enc_opts_mapping;
 
 	struct mlx5_tc_ct_priv *ct_priv;
+	struct mlx5_esw_psample *esw_psample;
 
 	/* support eswitch vports bonding */
 	struct mlx5e_rep_bond *bond;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c b/drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c
new file mode 100644
index 000000000000..9bd996e8d28a
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+/* Copyright (c) 2021 Mellanox Technologies. */
+
+#include "esw/sample.h"
+#include "eswitch.h"
+
+struct mlx5_esw_psample {
+	struct mlx5e_priv *priv;
+	struct mlx5_flow_table *termtbl;
+	struct mlx5_flow_handle *termtbl_rule;
+};
+
+static int
+sampler_termtbl_create(struct mlx5_esw_psample *esw_psample)
+{
+	struct mlx5_core_dev *dev = esw_psample->priv->mdev;
+	struct mlx5_eswitch *esw = dev->priv.eswitch;
+	struct mlx5_flow_table_attr ft_attr = {};
+	struct mlx5_flow_destination dest = {};
+	struct mlx5_flow_namespace *root_ns;
+	struct mlx5_flow_act act = {};
+	int err;
+
+	if (!MLX5_CAP_ESW_FLOWTABLE_FDB(dev, termination_table))  {
+		mlx5_core_warn(dev, "termination table is not supported\n");
+		return -EOPNOTSUPP;
+	}
+
+	root_ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);
+	if (!root_ns) {
+		mlx5_core_warn(dev, "failed to get FDB flow namespace\n");
+		return -EOPNOTSUPP;
+	}
+
+	ft_attr.flags = MLX5_FLOW_TABLE_TERMINATION | MLX5_FLOW_TABLE_UNMANAGED;
+	ft_attr.autogroup.max_num_groups = 1;
+	ft_attr.prio = FDB_SLOW_PATH;
+	ft_attr.max_fte = 1;
+	ft_attr.level = 1;
+	esw_psample->termtbl = mlx5_create_auto_grouped_flow_table(root_ns, &ft_attr);
+	if (IS_ERR(esw_psample->termtbl)) {
+		err = PTR_ERR(esw_psample->termtbl);
+		mlx5_core_warn(dev, "failed to create termtbl, err: %d\n", err);
+		return err;
+	}
+
+	act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
+	dest.vport.num = esw->manager_vport;
+	esw_psample->termtbl_rule = mlx5_add_flow_rules(esw_psample->termtbl, NULL, &act, &dest, 1);
+	if (IS_ERR(esw_psample->termtbl_rule)) {
+		err = PTR_ERR(esw_psample->termtbl_rule);
+		mlx5_core_warn(dev, "failed to create termtbl rule, err: %d\n", err);
+		mlx5_destroy_flow_table(esw_psample->termtbl);
+		return err;
+	}
+
+	return 0;
+}
+
+static void
+sampler_termtbl_destroy(struct mlx5_esw_psample *esw_psample)
+{
+	mlx5_del_flow_rules(esw_psample->termtbl_rule);
+	mlx5_destroy_flow_table(esw_psample->termtbl);
+}
+
+struct mlx5_esw_psample *
+mlx5_esw_sample_init(struct mlx5e_priv *priv)
+{
+	struct mlx5_esw_psample *esw_psample;
+	int err;
+
+	esw_psample = kzalloc(sizeof(*esw_psample), GFP_KERNEL);
+	if (!esw_psample)
+		return ERR_PTR(-ENOMEM);
+	esw_psample->priv = priv;
+	err = sampler_termtbl_create(esw_psample);
+	if (err)
+		goto err_termtbl;
+
+	return esw_psample;
+
+err_termtbl:
+	kfree(esw_psample);
+	return ERR_PTR(err);
+}
+
+void
+mlx5_esw_sample_cleanup(struct mlx5_esw_psample *esw_psample)
+{
+	if (IS_ERR_OR_NULL(esw_psample))
+		return;
+
+	sampler_termtbl_destroy(esw_psample);
+	kfree(esw_psample);
+}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h
