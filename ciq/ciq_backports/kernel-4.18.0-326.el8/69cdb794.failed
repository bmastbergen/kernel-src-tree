ibmvnic: remove excessive irqsave

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Junlin Yang <yangjunlin@yulong.com>
commit 69cdb7947adb816fc9325b4ec02a6dddd5070b82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/69cdb794.failed

ibmvnic_remove locks multiple spinlocks while disabling interrupts:
spin_lock_irqsave(&adapter->state_lock, flags);
spin_lock_irqsave(&adapter->rwi_lock, flags);

As reported by coccinelle, the second _irqsave() overwrites the value
saved in 'flags' by the first _irqsave(),   therefore when the second
_irqrestore() comes,the value in 'flags' is not valid,the value saved
by the first _irqsave() has been lost.
This likely leads to IRQs remaining disabled. So remove the second
_irqsave():
spin_lock_irqsave(&adapter->state_lock, flags);
spin_lock(&adapter->rwi_lock);

Generated by: ./scripts/coccinelle/locks/flags.cocci
./drivers/net/ethernet/ibm/ibmvnic.c:5413:1-18:
ERROR: nested lock+irqsave that reuses flags from line 5404.

Fixes: 4a41c421f367 ("ibmvnic: serialize access to work queue on remove")
	Signed-off-by: Junlin Yang <yangjunlin@yulong.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 69cdb7947adb816fc9325b4ec02a6dddd5070b82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index c3c11936a552,161fa95e8768..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -5451,7 -5400,18 +5451,22 @@@ static void ibmvnic_remove(struct vio_d
  	unsigned long flags;
  
  	spin_lock_irqsave(&adapter->state_lock, flags);
++<<<<<<< HEAD
 +	adapter->state = VNIC_REMOVING;
++=======
+ 
+ 	/* If ibmvnic_reset() is scheduling a reset, wait for it to
+ 	 * finish. Then, set the state to REMOVING to prevent it from
+ 	 * scheduling any more work and to have reset functions ignore
+ 	 * any resets that have already been scheduled. Drop the lock
+ 	 * after setting state, so __ibmvnic_reset() which is called
+ 	 * from the flush_work() below, can make progress.
+ 	 */
+ 	spin_lock(&adapter->rwi_lock);
+ 	adapter->state = VNIC_REMOVING;
+ 	spin_unlock(&adapter->rwi_lock);
+ 
++>>>>>>> 69cdb7947adb (ibmvnic: remove excessive irqsave)
  	spin_unlock_irqrestore(&adapter->state_lock, flags);
  
  	flush_work(&adapter->ibmvnic_reset);
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
