drivers/base/memory.c: drop pages_correctly_probed()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author David Hildenbrand <david@redhat.com>
commit fada9ae3edeb4175e0f0ac9b369333806dcffbaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/fada9ae3.failed

pages_correctly_probed() is a leftover from ancient times.  It dates back
to commit 3947be1969a9 ("[PATCH] memory hotplug: sysfs and add/remove
functions"), where Pg_reserved checks were added as a sfety net:

	/*
	 * The probe routines leave the pages reserved, just
	 * as the bootmem code does.  Make sure they're still
	 * that way.
	 */

The checks were refactored quite a bit over the years, especially in
commit b77eab7079d9 ("mm/memory_hotplug: optimize probe routine"), where
checks for present, valid, and online sections were added.

Hotplugged memory is added via add_memory(), which will create the full
memmap for the hotplugged memory, and mark all sections valid and present.

Only full memory blocks are onlined/offlined, so we also cannot have an
inconsistency in that regard (especially, memory blocks with some sections
being online and some being offline).

1. Boot memory always starts online.  Since commit c5e79ef561b0
   ("mm/memory_hotplug.c: don't allow to online/offline memory blocks with
   holes") we disallow to offline any memory with holes.  Therefore, we
   never online memory with holes.  Present and validity checks are
   superfluous.

2. Only complete memory blocks are onlined/offlined (and especially,
   the state - online or offline - is stored for whole memory blocks).
   Besides the core, only arch/powerpc/platforms/powernv/memtrace.c
   manually calls offline_pages() and fiddels with memory block states.
   But it also only offlines complete memory blocks.

3. To make any of these conditions trigger, something would have to be
   terribly messed up in the core.  (e.g., online/offline only some
   sections of a memory block).

4. Memory unplug properly makes sure that all sysfs attributes were
   removed (and therefore, that all threads left the sysfs handlers).  We
   don't have to worry about zombie devices at this point.

5. The valid_section_nr(section_nr) check is actually dead code, as it
   would never have been reached due to the WARN_ON_ONCE(!pfn_valid(pfn)).

No wonder we haven't seen any of these errors in a long time (or even
   ever, according to my search).  Let's just get rid of them.  Now, all
   checks that could hinder onlining and offlining are completely
   contained in online_pages()/offline_pages().

	Signed-off-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Anshuman Khandual <anshuman.khandual@arm.com>
Link: http://lkml.kernel.org/r/20200127110424.5757-3-david@redhat.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit fada9ae3edeb4175e0f0ac9b369333806dcffbaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/memory.c
diff --cc drivers/base/memory.c
index 45e30146ad4f,96c80dfaac90..000000000000
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@@ -185,45 -145,6 +185,48 @@@ int memory_notify(unsigned long val, vo
  }
  
  /*
++<<<<<<< HEAD
 + * The probe routines leave the pages uninitialized, just as the bootmem code
 + * does. Make sure we do not access them, but instead use only information from
 + * within sections.
 + */
 +static bool pages_correctly_probed(unsigned long start_pfn)
 +{
 +	unsigned long section_nr = pfn_to_section_nr(start_pfn);
 +	unsigned long section_nr_end = section_nr + sections_per_block;
 +	unsigned long pfn = start_pfn;
 +
 +	/*
 +	 * memmap between sections is not contiguous except with
 +	 * SPARSEMEM_VMEMMAP. We lookup the page once per section
 +	 * and assume memmap is contiguous within each section
 +	 */
 +	for (; section_nr < section_nr_end; section_nr++) {
 +		if (WARN_ON_ONCE(!pfn_valid(pfn)))
 +			return false;
 +
 +		if (!present_section_nr(section_nr)) {
 +			pr_warn("section %ld pfn[%lx, %lx) not present",
 +				section_nr, pfn, pfn + PAGES_PER_SECTION);
 +			return false;
 +		} else if (!valid_section_nr(section_nr)) {
 +			pr_warn("section %ld pfn[%lx, %lx) no valid memmap",
 +				section_nr, pfn, pfn + PAGES_PER_SECTION);
 +			return false;
 +		} else if (online_section_nr(section_nr)) {
 +			pr_warn("section %ld pfn[%lx, %lx) is already online",
 +				section_nr, pfn, pfn + PAGES_PER_SECTION);
 +			return false;
 +		}
 +		pfn += PAGES_PER_SECTION;
 +	}
 +
 +	return true;
 +}
 +
 +/*
++=======
++>>>>>>> fada9ae3edeb (drivers/base/memory.c: drop pages_correctly_probed())
   * MEMORY_HOTPLUG depends on SPARSEMEM in mm/Kconfig, so it is
   * OK to have direct references to sparsemem variables in here.
   */
* Unmerged path drivers/base/memory.c
