xfs: refactor xfs_qm_scall_setqlim

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit d1520deab039ca1bac50c53b941a3df3b3a680de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/d1520dea.failed

Now that we can pass around quota resource and limit structures, clean
up the open-coded field setting in xfs_qm_scall_setqlim.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Allison Collins <allison.henderson@oracle.com>
	Reviewed-by: Chandan Babu R <chandanrlinux@gmail.com>
(cherry picked from commit d1520deab039ca1bac50c53b941a3df3b3a680de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_qm_syscalls.c
diff --cc fs/xfs/xfs_qm_syscalls.c
index 78a79a1edda6,cbe352187d32..000000000000
--- a/fs/xfs/xfs_qm_syscalls.c
+++ b/fs/xfs/xfs_qm_syscalls.c
@@@ -489,79 -543,13 +543,88 @@@ xfs_qm_scall_setqlim
  	xfs_trans_dqjoin(tp, dqp);
  
  	/*
+ 	 * Update quota limits, warnings, and timers, and the defaults
+ 	 * if we're touching id == 0.
+ 	 *
  	 * Make sure that hardlimits are >= soft limits before changing.
++<<<<<<< HEAD
 +	 */
 +	hard = (newlim->d_fieldmask & QC_SPC_HARD) ?
 +		(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :
 +			dqp->q_blk.hardlimit;
 +	soft = (newlim->d_fieldmask & QC_SPC_SOFT) ?
 +		(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :
 +			dqp->q_blk.softlimit;
 +	if (hard == 0 || hard >= soft) {
 +		dqp->q_blk.hardlimit = hard;
 +		dqp->q_blk.softlimit = soft;
 +		xfs_dquot_set_prealloc_limits(dqp);
 +		if (id == 0) {
 +			defq->bhardlimit = hard;
 +			defq->bsoftlimit = soft;
 +		}
 +	} else {
 +		xfs_debug(mp, "blkhard %Ld < blksoft %Ld", hard, soft);
 +	}
 +	hard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?
 +		(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :
 +			dqp->q_rtb.hardlimit;
 +	soft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?
 +		(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :
 +			dqp->q_rtb.softlimit;
 +	if (hard == 0 || hard >= soft) {
 +		dqp->q_rtb.hardlimit = hard;
 +		dqp->q_rtb.softlimit = soft;
 +		if (id == 0) {
 +			defq->rtbhardlimit = hard;
 +			defq->rtbsoftlimit = soft;
 +		}
 +	} else {
 +		xfs_debug(mp, "rtbhard %Ld < rtbsoft %Ld", hard, soft);
 +	}
 +
 +	hard = (newlim->d_fieldmask & QC_INO_HARD) ?
 +		(xfs_qcnt_t) newlim->d_ino_hardlimit :
 +			dqp->q_ino.hardlimit;
 +	soft = (newlim->d_fieldmask & QC_INO_SOFT) ?
 +		(xfs_qcnt_t) newlim->d_ino_softlimit :
 +			dqp->q_ino.softlimit;
 +	if (hard == 0 || hard >= soft) {
 +		dqp->q_ino.hardlimit = hard;
 +		dqp->q_ino.softlimit = soft;
 +		if (id == 0) {
 +			defq->ihardlimit = hard;
 +			defq->isoftlimit = soft;
 +		}
 +	} else {
 +		xfs_debug(mp, "ihard %Ld < isoft %Ld", hard, soft);
 +	}
 +
 +	/*
 +	 * Update warnings counter(s) if requested
 +	 */
 +	if (newlim->d_fieldmask & QC_SPC_WARNS)
 +		dqp->q_blk.warnings = newlim->d_spc_warns;
 +	if (newlim->d_fieldmask & QC_INO_WARNS)
 +		dqp->q_ino.warnings = newlim->d_ino_warns;
 +	if (newlim->d_fieldmask & QC_RT_SPC_WARNS)
 +		dqp->q_rtb.warnings = newlim->d_rt_spc_warns;
 +
 +	if (id == 0) {
 +		if (newlim->d_fieldmask & QC_SPC_WARNS)
 +			defq->bwarnlimit = newlim->d_spc_warns;
 +		if (newlim->d_fieldmask & QC_INO_WARNS)
 +			defq->iwarnlimit = newlim->d_ino_warns;
 +		if (newlim->d_fieldmask & QC_RT_SPC_WARNS)
 +			defq->rtbwarnlimit = newlim->d_rt_spc_warns;
 +	}
 +
 +	/*
++=======
+ 	 *
+ 	 * Update warnings counter(s) if requested.
+ 	 *
++>>>>>>> d1520deab039 (xfs: refactor xfs_qm_scall_setqlim)
  	 * Timelimits for the super user set the relative time the other users
  	 * can be over quota for this file system. If it is zero a default is
  	 * used.  Ditto for the default soft and hard limit values (already
@@@ -570,21 -558,55 +633,66 @@@
  	 * For other IDs, userspace can bump out the grace period if over
  	 * the soft limit.
  	 */
- 	if (newlim->d_fieldmask & QC_SPC_TIMER)
- 		dqp->q_blk.timer = newlim->d_spc_timer;
- 	if (newlim->d_fieldmask & QC_INO_TIMER)
- 		dqp->q_ino.timer = newlim->d_ino_timer;
- 	if (newlim->d_fieldmask & QC_RT_SPC_TIMER)
- 		dqp->q_rtb.timer = newlim->d_rt_spc_timer;
  
++<<<<<<< HEAD
 +	if (id == 0) {
 +		if (newlim->d_fieldmask & QC_SPC_TIMER)
 +			defq->btimelimit = newlim->d_spc_timer;
 +		if (newlim->d_fieldmask & QC_INO_TIMER)
 +			defq->itimelimit = newlim->d_ino_timer;
 +		if (newlim->d_fieldmask & QC_RT_SPC_TIMER)
 +			defq->rtbtimelimit = newlim->d_rt_spc_timer;
 +	}
++=======
+ 	/* Blocks on the data device. */
+ 	hard = (newlim->d_fieldmask & QC_SPC_HARD) ?
+ 		(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :
+ 			dqp->q_blk.hardlimit;
+ 	soft = (newlim->d_fieldmask & QC_SPC_SOFT) ?
+ 		(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :
+ 			dqp->q_blk.softlimit;
+ 	res = &dqp->q_blk;
+ 	qlim = id == 0 ? &defq->blk : NULL;
+ 
+ 	if (xfs_setqlim_limits(mp, res, qlim, hard, soft, "blk"))
+ 		xfs_dquot_set_prealloc_limits(dqp);
+ 	if (newlim->d_fieldmask & QC_SPC_WARNS)
+ 		xfs_setqlim_warns(res, qlim, newlim->d_spc_warns);
+ 	if (newlim->d_fieldmask & QC_SPC_TIMER)
+ 		xfs_setqlim_timer(res, qlim, newlim->d_spc_timer);
+ 
+ 	/* Blocks on the realtime device. */
+ 	hard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?
+ 		(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :
+ 			dqp->q_rtb.hardlimit;
+ 	soft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?
+ 		(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :
+ 			dqp->q_rtb.softlimit;
+ 	res = &dqp->q_rtb;
+ 	qlim = id == 0 ? &defq->rtb : NULL;
+ 
+ 	xfs_setqlim_limits(mp, res, qlim, hard, soft, "rtb");
+ 	if (newlim->d_fieldmask & QC_RT_SPC_WARNS)
+ 		xfs_setqlim_warns(res, qlim, newlim->d_rt_spc_warns);
+ 	if (newlim->d_fieldmask & QC_RT_SPC_TIMER)
+ 		xfs_setqlim_timer(res, qlim, newlim->d_rt_spc_timer);
+ 
+ 	/* Inodes */
+ 	hard = (newlim->d_fieldmask & QC_INO_HARD) ?
+ 		(xfs_qcnt_t) newlim->d_ino_hardlimit :
+ 			dqp->q_ino.hardlimit;
+ 	soft = (newlim->d_fieldmask & QC_INO_SOFT) ?
+ 		(xfs_qcnt_t) newlim->d_ino_softlimit :
+ 			dqp->q_ino.softlimit;
+ 	res = &dqp->q_ino;
+ 	qlim = id == 0 ? &defq->ino : NULL;
+ 
+ 	xfs_setqlim_limits(mp, res, qlim, hard, soft, "ino");
+ 	if (newlim->d_fieldmask & QC_INO_WARNS)
+ 		xfs_setqlim_warns(res, qlim, newlim->d_ino_warns);
+ 	if (newlim->d_fieldmask & QC_INO_TIMER)
+ 		xfs_setqlim_timer(res, qlim, newlim->d_ino_timer);
++>>>>>>> d1520deab039 (xfs: refactor xfs_qm_scall_setqlim)
  
  	if (id != 0) {
  		/*
* Unmerged path fs/xfs/xfs_qm_syscalls.c
