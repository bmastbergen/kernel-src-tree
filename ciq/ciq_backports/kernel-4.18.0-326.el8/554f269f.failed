platform/x86: intel_pmc_core: Add Intel Elkhart Lake support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Gayatri Kammela <gayatri.kammela@intel.com>
commit 554f269f0f384d34f7e8052242df3b97be325924
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/554f269f.failed

Add Intel Elkhart Lake to the list of the platforms that driver supports
for the PMC device.

Just like Ice Lake and Tiger Lake, Elkhart Lake can also reuse all the
Cannon Lake PCH IPs. Also, it uses the same PCH IPs of Tiger Lake, no
additional effort is needed to enable but to simply reuse them.

	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
	Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: David E. Box <david.e.box@intel.com>
	Cc: Rajneesh Bhardwaj <irenic.rajneesh@gmail.com>
	Cc: Tony Luck <tony.luck@intel.com>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
(cherry picked from commit 554f269f0f384d34f7e8052242df3b97be325924)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/intel_pmc_core.c
diff --cc drivers/platform/x86/intel_pmc_core.c
index aa1e8688e919,92d4b4763f18..000000000000
--- a/drivers/platform/x86/intel_pmc_core.c
+++ b/drivers/platform/x86/intel_pmc_core.c
@@@ -1116,36 -858,30 +1116,51 @@@ static void pmc_core_dbgfs_register(str
  		debugfs_create_bool("slp_s0_dbg_latch", 0644,
  				    dir, &slps0_dbg_latch);
  	}
 -}
 -#else
 -static inline void pmc_core_dbgfs_register(struct pmc_dev *pmcdev)
 -{
 -}
  
 -static inline void pmc_core_dbgfs_unregister(struct pmc_dev *pmcdev)
 -{
 +	if (pmcdev->map->lpm_en_offset) {
 +		debugfs_create_file("substate_residencies", 0444,
 +				    pmcdev->dbgfs_dir, pmcdev,
 +				    &pmc_core_substate_res_fops);
 +	}
 +
 +	if (pmcdev->map->lpm_status_offset) {
 +		debugfs_create_file("substate_status_registers", 0444,
 +				    pmcdev->dbgfs_dir, pmcdev,
 +				    &pmc_core_substate_sts_regs_fops);
 +		debugfs_create_file("substate_live_status_registers", 0444,
 +				    pmcdev->dbgfs_dir, pmcdev,
 +				    &pmc_core_substate_l_sts_regs_fops);
 +	}
  }
 -#endif /* CONFIG_DEBUG_FS */
  
  static const struct x86_cpu_id intel_pmc_core_ids[] = {
++<<<<<<< HEAD
 +	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_L,		&spt_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE,		&spt_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(KABYLAKE_L,		&spt_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(KABYLAKE,		&spt_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(CANNONLAKE_L,	&cnp_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,		&icl_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_NNPI,	&icl_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(COMETLAKE,		&cnp_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(COMETLAKE_L,		&cnp_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE_L,		&tgl_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE,		&tgl_reg_map),
 +	X86_MATCH_INTEL_FAM6_MODEL(ROCKETLAKE,		&tgl_reg_map),
++=======
+ 	INTEL_CPU_FAM6(SKYLAKE_L, spt_reg_map),
+ 	INTEL_CPU_FAM6(SKYLAKE, spt_reg_map),
+ 	INTEL_CPU_FAM6(KABYLAKE_L, spt_reg_map),
+ 	INTEL_CPU_FAM6(KABYLAKE, spt_reg_map),
+ 	INTEL_CPU_FAM6(CANNONLAKE_L, cnp_reg_map),
+ 	INTEL_CPU_FAM6(ICELAKE_L, icl_reg_map),
+ 	INTEL_CPU_FAM6(ICELAKE_NNPI, icl_reg_map),
+ 	INTEL_CPU_FAM6(COMETLAKE, cnp_reg_map),
+ 	INTEL_CPU_FAM6(COMETLAKE_L, cnp_reg_map),
+ 	INTEL_CPU_FAM6(TIGERLAKE_L, tgl_reg_map),
+ 	INTEL_CPU_FAM6(TIGERLAKE, tgl_reg_map),
+ 	INTEL_CPU_FAM6(ATOM_TREMONT, tgl_reg_map),
++>>>>>>> 554f269f0f38 (platform/x86: intel_pmc_core: Add Intel Elkhart Lake support)
  	{}
  };
  
* Unmerged path drivers/platform/x86/intel_pmc_core.c
