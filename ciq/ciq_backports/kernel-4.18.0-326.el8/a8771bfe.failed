ionic: add and enable tx and rx timestamp handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Shannon Nelson <snelson@pensando.io>
commit a8771bfe05549f3068532c60e3682441ff8159fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/a8771bfe.failed

The Tx and Rx timestamped packets are handled through separate
queues.  Here we set them up, service them, and tear them down
along with the normal Tx and Rx queues.

	Signed-off-by: Allen Hubbe <allenbh@pensando.io>
	Signed-off-by: Shannon Nelson <snelson@pensando.io>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a8771bfe05549f3068532c60e3682441ff8159fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/pensando/ionic/ionic_dev.h
#	drivers/net/ethernet/pensando/ionic/ionic_txrx.c
diff --cc drivers/net/ethernet/pensando/ionic/ionic_dev.h
index 565a891e2691,c25cf9b744c5..000000000000
--- a/drivers/net/ethernet/pensando/ionic/ionic_dev.h
+++ b/drivers/net/ethernet/pensando/ionic/ionic_dev.h
@@@ -214,6 -219,8 +214,11 @@@ struct ionic_queue 
  	u16 tail_idx;
  	unsigned int index;
  	unsigned int num_descs;
++<<<<<<< HEAD
++=======
+ 	unsigned int max_sg_elems;
+ 	u64 features;
++>>>>>>> a8771bfe0554 (ionic: add and enable tx and rx timestamp handling)
  	u64 dbell_count;
  	u64 stop;
  	u64 wake;
diff --cc drivers/net/ethernet/pensando/ionic/ionic_txrx.c
index c718ad9db767,3478b0f2495f..000000000000
--- a/drivers/net/ethernet/pensando/ionic/ionic_txrx.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_txrx.c
@@@ -10,15 -10,7 +10,13 @@@
  #include "ionic_lif.h"
  #include "ionic_txrx.h"
  
 +static void ionic_rx_clean(struct ionic_queue *q,
 +			   struct ionic_desc_info *desc_info,
 +			   struct ionic_cq_info *cq_info,
 +			   void *cb_arg);
 +
 +static bool ionic_rx_service(struct ionic_cq *cq, struct ionic_cq_info *cq_info);
  
- static bool ionic_tx_service(struct ionic_cq *cq, struct ionic_cq_info *cq_info);
- 
  static inline void ionic_txq_post(struct ionic_queue *q, bool ring_dbell,
  				  ionic_desc_cb cb_func, void *cb_arg)
  {
@@@ -326,11 -322,13 +344,11 @@@ static void ionic_rx_clean(struct ionic
  		napi_gro_frags(&qcq->napi);
  }
  
- static bool ionic_rx_service(struct ionic_cq *cq, struct ionic_cq_info *cq_info)
+ bool ionic_rx_service(struct ionic_cq *cq, struct ionic_cq_info *cq_info)
  {
 +	struct ionic_rxq_comp *comp = cq_info->cq_desc;
  	struct ionic_queue *q = cq->bound_q;
  	struct ionic_desc_info *desc_info;
 -	struct ionic_rxq_comp *comp;
 -
 -	comp = cq_info->cq_desc + cq->desc_size - sizeof(*comp);
  
  	if (!color_match(comp->pkt_type_color, cq->done_color))
  		return false;
@@@ -636,56 -681,70 +654,89 @@@ static void ionic_tx_clean(struct ionic
  			   struct ionic_cq_info *cq_info,
  			   void *cb_arg)
  {
 -	struct ionic_buf_info *buf_info = desc_info->bufs;
 +	struct ionic_txq_sg_desc *sg_desc = desc_info->sg_desc;
 +	struct ionic_txq_sg_elem *elem = sg_desc->elems;
  	struct ionic_tx_stats *stats = q_to_tx_stats(q);
++<<<<<<< HEAD
 +	struct ionic_txq_desc *desc = desc_info->desc;
 +	struct device *dev = q->lif->ionic->dev;
 +	u8 opcode, flags, nsge;
 +	u16 queue_index;
 +	unsigned int i;
 +	u64 addr;
++=======
+ 	struct ionic_qcq *qcq = q_to_qcq(q);
+ 	struct sk_buff *skb = cb_arg;
+ 	struct device *dev = q->dev;
+ 	unsigned int i;
+ 	u16 qi;
++>>>>>>> a8771bfe0554 (ionic: add and enable tx and rx timestamp handling)
  
 -	if (desc_info->nbufs) {
 -		dma_unmap_single(dev, (dma_addr_t)buf_info->dma_addr,
 -				 buf_info->len, DMA_TO_DEVICE);
 -		buf_info++;
 -		for (i = 1; i < desc_info->nbufs; i++, buf_info++)
 -			dma_unmap_page(dev, (dma_addr_t)buf_info->dma_addr,
 -				       buf_info->len, DMA_TO_DEVICE);
 -	}
 +	decode_txq_desc_cmd(le64_to_cpu(desc->cmd),
 +			    &opcode, &flags, &nsge, &addr);
 +
 +	/* use unmap_single only if either this is not TSO,
 +	 * or this is first descriptor of a TSO
 +	 */
 +	if (opcode != IONIC_TXQ_DESC_OPCODE_TSO ||
 +	    flags & IONIC_TXQ_DESC_FLAG_TSO_SOT)
 +		dma_unmap_single(dev, (dma_addr_t)addr,
 +				 le16_to_cpu(desc->len), DMA_TO_DEVICE);
 +	else
 +		dma_unmap_page(dev, (dma_addr_t)addr,
 +			       le16_to_cpu(desc->len), DMA_TO_DEVICE);
 +
 +	for (i = 0; i < nsge; i++, elem++)
 +		dma_unmap_page(dev, (dma_addr_t)le64_to_cpu(elem->addr),
 +			       le16_to_cpu(elem->len), DMA_TO_DEVICE);
  
- 	if (cb_arg) {
- 		struct sk_buff *skb = cb_arg;
+ 	if (!skb)
+ 		return;
+ 
+ 	qi = skb_get_queue_mapping(skb);
  
- 		queue_index = skb_get_queue_mapping(skb);
- 		if (unlikely(__netif_subqueue_stopped(q->lif->netdev,
- 						      queue_index))) {
- 			netif_wake_subqueue(q->lif->netdev, queue_index);
- 			q->wake++;
- 		}
+ 	if (unlikely(q->features & IONIC_TXQ_F_HWSTAMP)) {
+ 		if (cq_info) {
+ 			struct skb_shared_hwtstamps hwts = {};
+ 			__le64 *cq_desc_hwstamp;
+ 			u64 hwstamp;
+ 
+ 			cq_desc_hwstamp =
+ 				cq_info->cq_desc +
+ 				qcq->cq.desc_size -
+ 				sizeof(struct ionic_txq_comp) -
+ 				IONIC_HWSTAMP_CQ_NEGOFFSET;
  
- 		desc_info->bytes = skb->len;
- 		stats->clean++;
+ 			hwstamp = le64_to_cpu(*cq_desc_hwstamp);
  
- 		dev_consume_skb_any(skb);
+ 			if (hwstamp != IONIC_HWSTAMP_INVALID) {
+ 				hwts.hwtstamp = ionic_lif_phc_ktime(q->lif, hwstamp);
+ 
+ 				skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+ 				skb_tstamp_tx(skb, &hwts);
+ 
+ 				stats->hwstamp_valid++;
+ 			} else {
+ 				stats->hwstamp_invalid++;
+ 			}
+ 		}
+ 
+ 	} else if (unlikely(__netif_subqueue_stopped(q->lif->netdev, qi))) {
+ 		netif_wake_subqueue(q->lif->netdev, qi);
+ 		q->wake++;
  	}
+ 
+ 	desc_info->bytes = skb->len;
+ 	stats->clean++;
+ 
+ 	dev_consume_skb_any(skb);
  }
  
- static bool ionic_tx_service(struct ionic_cq *cq, struct ionic_cq_info *cq_info)
+ bool ionic_tx_service(struct ionic_cq *cq, struct ionic_cq_info *cq_info)
  {
 +	struct ionic_txq_comp *comp = cq_info->cq_desc;
  	struct ionic_queue *q = cq->bound_q;
  	struct ionic_desc_info *desc_info;
 -	struct ionic_txq_comp *comp;
  	int bytes = 0;
  	int pkts = 0;
  	u16 index;
@@@ -820,12 -881,13 +871,18 @@@ static void ionic_tx_tso_post(struct io
  	desc->hdr_len = cpu_to_le16(hdrlen);
  	desc->mss = cpu_to_le16(mss);
  
 -	if (start) {
 +	if (done) {
  		skb_tx_timestamp(skb);
++<<<<<<< HEAD
 +		netdev_tx_sent_queue(q_to_ndq(q), skb->len);
 +		ionic_txq_post(q, !netdev_xmit_more(), ionic_tx_clean, skb);
++=======
+ 		if (!unlikely(q->features & IONIC_TXQ_F_HWSTAMP))
+ 			netdev_tx_sent_queue(q_to_ndq(q), skb->len);
+ 		ionic_txq_post(q, false, ionic_tx_clean, skb);
++>>>>>>> a8771bfe0554 (ionic: add and enable tx and rx timestamp handling)
  	} else {
 -		ionic_txq_post(q, done, NULL, NULL);
 +		ionic_txq_post(q, false, ionic_tx_clean, NULL);
  	}
  }
  
* Unmerged path drivers/net/ethernet/pensando/ionic/ionic_dev.h
diff --git a/drivers/net/ethernet/pensando/ionic/ionic_lif.c b/drivers/net/ethernet/pensando/ionic/ionic_lif.c
index ff3f4b510503..ab744e4d1075 100644
--- a/drivers/net/ethernet/pensando/ionic/ionic_lif.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_lif.c
@@ -894,9 +894,12 @@ static int ionic_adminq_napi(struct napi_struct *napi, int budget)
 	struct ionic_dev *idev = &lif->ionic->idev;
 	unsigned long irqflags;
 	unsigned int flags = 0;
+	int rx_work = 0;
+	int tx_work = 0;
 	int n_work = 0;
 	int a_work = 0;
 	int work_done;
+	int credits;
 
 	if (lif->notifyqcq && lif->notifyqcq->flags & IONIC_QCQ_F_INITED)
 		n_work = ionic_cq_service(&lif->notifyqcq->cq, budget,
@@ -908,7 +911,15 @@ static int ionic_adminq_napi(struct napi_struct *napi, int budget)
 					  ionic_adminq_service, NULL, NULL);
 	spin_unlock_irqrestore(&lif->adminq_lock, irqflags);
 
-	work_done = max(n_work, a_work);
+	if (lif->hwstamp_rxq)
+		rx_work = ionic_cq_service(&lif->hwstamp_rxq->cq, budget,
+					   ionic_rx_service, NULL, NULL);
+
+	if (lif->hwstamp_txq)
+		tx_work = ionic_cq_service(&lif->hwstamp_txq->cq, budget,
+					   ionic_tx_service, NULL, NULL);
+
+	work_done = max(max(n_work, a_work), max(rx_work, tx_work));
 	if (work_done < budget && napi_complete_done(napi, work_done)) {
 		flags |= IONIC_INTR_CRED_UNMASK;
 		intr->rearm_count++;
@@ -916,9 +927,8 @@ static int ionic_adminq_napi(struct napi_struct *napi, int budget)
 
 	if (work_done || flags) {
 		flags |= IONIC_INTR_CRED_RESET_COALESCE;
-		ionic_intr_credits(idev->intr_ctrl,
-				   intr->index,
-				   n_work + a_work, flags);
+		credits = n_work + a_work + rx_work + tx_work;
+		ionic_intr_credits(idev->intr_ctrl, intr->index, credits, flags);
 	}
 
 	return work_done;
@@ -1278,6 +1288,7 @@ static int ionic_set_nic_features(struct ionic_lif *lif,
 	int err;
 
 	ctx.cmd.lif_setattr.features = ionic_netdev_features_to_nic(features);
+
 	err = ionic_adminq_post_wait(lif, &ctx);
 	if (err)
 		return err;
@@ -1694,6 +1705,17 @@ static void ionic_txrx_deinit(struct ionic_lif *lif)
 		}
 	}
 	lif->rx_mode = 0;
+
+	if (lif->hwstamp_txq) {
+		ionic_lif_qcq_deinit(lif, lif->hwstamp_txq);
+		ionic_tx_flush(&lif->hwstamp_txq->cq);
+		ionic_tx_empty(&lif->hwstamp_txq->q);
+	}
+
+	if (lif->hwstamp_rxq) {
+		ionic_lif_qcq_deinit(lif, lif->hwstamp_rxq);
+		ionic_rx_empty(&lif->hwstamp_rxq->q);
+	}
 }
 
 static void ionic_txrx_free(struct ionic_lif *lif)
@@ -1844,8 +1866,26 @@ static int ionic_txrx_enable(struct ionic_lif *lif)
 		}
 	}
 
+	if (lif->hwstamp_rxq) {
+		ionic_rx_fill(&lif->hwstamp_rxq->q);
+		err = ionic_qcq_enable(lif->hwstamp_rxq);
+		if (err)
+			goto err_out_hwstamp_rx;
+	}
+
+	if (lif->hwstamp_txq) {
+		err = ionic_qcq_enable(lif->hwstamp_txq);
+		if (err)
+			goto err_out_hwstamp_tx;
+	}
+
 	return 0;
 
+err_out_hwstamp_tx:
+	if (lif->hwstamp_rxq)
+		derr = ionic_qcq_disable(lif->hwstamp_rxq, (derr != -ETIMEDOUT));
+err_out_hwstamp_rx:
+	i = lif->nxqs;
 err_out:
 	while (i--) {
 		derr = ionic_qcq_disable(lif->txqcqs[i], (derr != -ETIMEDOUT));
@@ -2636,6 +2676,9 @@ static void ionic_lif_handle_fw_up(struct ionic_lif *lif)
 			goto err_txrx_free;
 	}
 
+	/* restore the hardware timestamping queues */
+	ionic_lif_hwstamp_set(lif, NULL);
+
 	clear_bit(IONIC_LIF_F_FW_RESET, lif->state);
 	ionic_link_status_check_request(lif, CAN_SLEEP);
 	netif_device_attach(lif->netdev);
* Unmerged path drivers/net/ethernet/pensando/ionic/ionic_txrx.c
diff --git a/drivers/net/ethernet/pensando/ionic/ionic_txrx.h b/drivers/net/ethernet/pensando/ionic/ionic_txrx.h
index 7667b72232b8..d7cbaad8a6fb 100644
--- a/drivers/net/ethernet/pensando/ionic/ionic_txrx.h
+++ b/drivers/net/ethernet/pensando/ionic/ionic_txrx.h
@@ -14,4 +14,7 @@ int ionic_tx_napi(struct napi_struct *napi, int budget);
 int ionic_txrx_napi(struct napi_struct *napi, int budget);
 netdev_tx_t ionic_start_xmit(struct sk_buff *skb, struct net_device *netdev);
 
+bool ionic_rx_service(struct ionic_cq *cq, struct ionic_cq_info *cq_info);
+bool ionic_tx_service(struct ionic_cq *cq, struct ionic_cq_info *cq_info);
+
 #endif /* _IONIC_TXRX_H_ */
