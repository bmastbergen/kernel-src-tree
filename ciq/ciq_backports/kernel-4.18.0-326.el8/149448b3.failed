iommu: Delete iommu_dma_free_cpu_cached_iovas()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author John Garry <john.garry@huawei.com>
commit 149448b353e2517ecc6eced7d9f46e9f3e08b89e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/149448b3.failed

Function iommu_dma_free_cpu_cached_iovas() no longer has any caller, so
delete it.

With that, function free_cpu_cached_iovas() may be made static.

	Signed-off-by: John Garry <john.garry@huawei.com>
	Reviewed-by: Robin Murphy <robin.murphy@arm.com>
Link: https://lore.kernel.org/r/1616675401-151997-4-git-send-email-john.garry@huawei.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 149448b353e2517ecc6eced7d9f46e9f3e08b89e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/dma-iommu.c
diff --cc drivers/iommu/dma-iommu.c
index fe135a263f73,0af4048f9b3f..000000000000
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@@ -64,6 -52,29 +64,32 @@@ struct iommu_dma_cookie 
  };
  
  static DEFINE_STATIC_KEY_FALSE(iommu_deferred_attach_enabled);
++<<<<<<< HEAD
++=======
+ bool iommu_dma_forcedac __read_mostly;
+ 
+ static int __init iommu_dma_forcedac_setup(char *str)
+ {
+ 	int ret = kstrtobool(str, &iommu_dma_forcedac);
+ 
+ 	if (!ret && iommu_dma_forcedac)
+ 		pr_info("Forcing DAC for PCI devices\n");
+ 	return ret;
+ }
+ early_param("iommu.forcedac", iommu_dma_forcedac_setup);
+ 
+ static void iommu_dma_entry_dtor(unsigned long data)
+ {
+ 	struct page *freelist = (struct page *)data;
+ 
+ 	while (freelist) {
+ 		unsigned long p = (unsigned long)page_address(freelist);
+ 
+ 		freelist = freelist->freelist;
+ 		free_page(p);
+ 	}
+ }
++>>>>>>> 149448b353e2 (iommu: Delete iommu_dma_free_cpu_cached_iovas())
  
  static inline size_t cookie_msi_granule(struct iommu_dma_cookie *cookie)
  {
* Unmerged path drivers/iommu/dma-iommu.c
diff --git a/drivers/iommu/iova.c b/drivers/iommu/iova.c
index 4d73f359de21..2c794b69557b 100644
--- a/drivers/iommu/iova.c
+++ b/drivers/iommu/iova.c
@@ -34,6 +34,7 @@ static unsigned long iova_rcache_get(struct iova_domain *iovad,
 				     unsigned long size,
 				     unsigned long limit_pfn);
 static void init_iova_rcaches(struct iova_domain *iovad);
+static void free_cpu_cached_iovas(unsigned int cpu, struct iova_domain *iovad);
 static void free_iova_rcaches(struct iova_domain *iovad);
 static void fq_destroy_all_entries(struct iova_domain *iovad);
 static void fq_flush_timeout(struct timer_list *t);
@@ -1052,7 +1053,7 @@ static void free_iova_rcaches(struct iova_domain *iovad)
 /*
  * free all the IOVA ranges cached by a cpu (used when cpu is unplugged)
  */
-void free_cpu_cached_iovas(unsigned int cpu, struct iova_domain *iovad)
+static void free_cpu_cached_iovas(unsigned int cpu, struct iova_domain *iovad)
 {
 	struct iova_cpu_rcache *cpu_rcache;
 	struct iova_rcache *rcache;
diff --git a/include/linux/iova.h b/include/linux/iova.h
index ab4894bdf10a..4512ea4f00b8 100644
--- a/include/linux/iova.h
+++ b/include/linux/iova.h
@@ -159,7 +159,6 @@ int init_iova_flush_queue(struct iova_domain *iovad,
 			  iova_flush_cb flush_cb, iova_entry_dtor entry_dtor);
 struct iova *find_iova(struct iova_domain *iovad, unsigned long pfn);
 void put_iova_domain(struct iova_domain *iovad);
-void free_cpu_cached_iovas(unsigned int cpu, struct iova_domain *iovad);
 #else
 static inline int iova_cache_get(void)
 {
@@ -236,10 +235,6 @@ static inline void put_iova_domain(struct iova_domain *iovad)
 {
 }
 
-static inline void free_cpu_cached_iovas(unsigned int cpu,
-					 struct iova_domain *iovad)
-{
-}
 #endif
 
 #endif
