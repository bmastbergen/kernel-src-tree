SUNRPC: Fixes for xdr_align_data()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 9a20f6f4e6ba9713605fbf7e7426ca22f1181545
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/9a20f6f4.failed

The main use case right now for xdr_align_data() is to shift the page
data to the left, and in practice shrink the total XDR data buffer.
This patch ensures that we fix up the accounting for the buffer length
as we shift that data around.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 9a20f6f4e6ba9713605fbf7e7426ca22f1181545)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xdr.c
diff --cc net/sunrpc/xdr.c
index 984778f0eee8,c474339ba9ac..000000000000
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@@ -1252,26 -1353,36 +1332,40 @@@ unsigned int xdr_align_data(struct xdr_
  
  	xdr_realign_pages(xdr);
  	from = xdr_page_pos(xdr);
- 	bytes = xdr_stream_remaining(xdr);
- 	if (length < bytes)
- 		bytes = length;
+ 
+ 	if (from >= buf->page_len + buf->tail->iov_len)
+ 		return 0;
+ 	if (from + buf->head->iov_len >= buf->len)
+ 		return 0;
+ 
+ 	len = buf->len - buf->head->iov_len;
+ 
+ 	/* We only shift data left! */
+ 	if (WARN_ONCE(from < offset, "SUNRPC: misaligned data src=%u dst=%u\n",
+ 		      from, offset))
+ 		return 0;
+ 	if (WARN_ONCE(offset > buf->page_len,
+ 		      "SUNRPC: buffer overflow. offset=%u, page_len=%u\n",
+ 		      offset, buf->page_len))
+ 		return 0;
  
  	/* Move page data to the left */
- 	if (from > offset) {
- 		shift = min_t(unsigned int, bytes, buf->page_len - from);
- 		_shift_data_left_pages(buf->pages,
- 				       buf->page_base + offset,
- 				       buf->page_base + from,
- 				       shift);
- 		bytes -= shift;
- 
- 		/* Move tail data into the pages, if necessary */
- 		if (bytes > 0)
- 			_shift_data_left_tail(buf, offset + shift, bytes);
- 	}
+ 	shift = from - offset;
+ 	xdr_buf_pages_shift_left(buf, from, len, shift);
+ 	xdr->buf->len -= shift;
+ 	xdr->nwords -= XDR_QUADLEN(shift);
+ 
+ 	bytes = xdr_stream_remaining(xdr);
+ 	if (length > bytes)
+ 		length = bytes;
+ 	bytes -= length;
  
  	xdr->nwords -= XDR_QUADLEN(length);
++<<<<<<< HEAD
 +	xdr_set_page(xdr, from + length, PAGE_SIZE);
++=======
+ 	xdr_set_page(xdr, offset + length, bytes);
++>>>>>>> 9a20f6f4e6ba (SUNRPC: Fixes for xdr_align_data())
  	return length;
  }
  EXPORT_SYMBOL_GPL(xdr_align_data);
diff --git a/include/linux/sunrpc/xdr.h b/include/linux/sunrpc/xdr.h
index 751d63851e5c..0060262f65aa 100644
--- a/include/linux/sunrpc/xdr.h
+++ b/include/linux/sunrpc/xdr.h
@@ -251,7 +251,7 @@ extern __be32 *xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes);
 extern unsigned int xdr_read_pages(struct xdr_stream *xdr, unsigned int len);
 extern void xdr_enter_page(struct xdr_stream *xdr, unsigned int len);
 extern int xdr_process_buf(struct xdr_buf *buf, unsigned int offset, unsigned int len, int (*actor)(struct scatterlist *, void *), void *data);
-extern uint64_t xdr_align_data(struct xdr_stream *, uint64_t, uint32_t);
+extern unsigned int xdr_align_data(struct xdr_stream *, unsigned int offset, unsigned int length);
 extern uint64_t xdr_expand_hole(struct xdr_stream *, uint64_t, uint64_t);
 
 /**
* Unmerged path net/sunrpc/xdr.c
