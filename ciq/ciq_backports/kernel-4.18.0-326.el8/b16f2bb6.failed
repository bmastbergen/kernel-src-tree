net/mlx5: E-Switch, Convert a macro to a helper routine

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Parav Pandit <parav@nvidia.com>
commit b16f2bb6b6ca926e303273913288461091ba8cd8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/b16f2bb6.failed

Convert ESW_ALLOWED macro to a helper routine so that it can be used in
other eswitch files.

	Signed-off-by: Parav Pandit <parav@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit b16f2bb6b6ca926e303273913288461091ba8cd8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 6f56131481bc,6a70e385beb8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -2485,9 -2528,11 +2483,15 @@@ free_out
  	return err;
  }
  
 -u8 mlx5_eswitch_mode(struct mlx5_core_dev *dev)
 +u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw)
  {
++<<<<<<< HEAD
 +	return ESW_ALLOWED(esw) ? esw->mode : MLX5_ESWITCH_NONE;
++=======
+ 	struct mlx5_eswitch *esw = dev->priv.eswitch;
+ 
+ 	return mlx5_esw_allowed(esw) ? esw->mode : MLX5_ESWITCH_NONE;
++>>>>>>> b16f2bb6b6ca (net/mlx5: E-Switch, Convert a macro to a helper routine)
  }
  EXPORT_SYMBOL_GPL(mlx5_eswitch_mode);
  
@@@ -2520,4 -2565,103 +2524,102 @@@ bool mlx5_esw_multipath_prereq(struct m
  		dev1->priv.eswitch->mode == MLX5_ESWITCH_OFFLOADS);
  }
  
 -int mlx5_esw_event_notifier_register(struct mlx5_eswitch *esw, struct notifier_block *nb)
 -{
 -	return blocking_notifier_chain_register(&esw->n_head, nb);
 -}
  
++<<<<<<< HEAD
++=======
+ void mlx5_esw_event_notifier_unregister(struct mlx5_eswitch *esw, struct notifier_block *nb)
+ {
+ 	blocking_notifier_chain_unregister(&esw->n_head, nb);
+ }
+ 
+ /**
+  * mlx5_esw_hold() - Try to take a read lock on esw mode lock.
+  * @mdev: mlx5 core device.
+  *
+  * Should be called by esw resources callers.
+  *
+  * Return: true on success or false.
+  */
+ bool mlx5_esw_hold(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	/* e.g. VF doesn't have eswitch so nothing to do */
+ 	if (!mlx5_esw_allowed(esw))
+ 		return true;
+ 
+ 	if (down_read_trylock(&esw->mode_lock) != 0)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /**
+  * mlx5_esw_release() - Release a read lock on esw mode lock.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_release(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (mlx5_esw_allowed(esw))
+ 		up_read(&esw->mode_lock);
+ }
+ 
+ /**
+  * mlx5_esw_get() - Increase esw user count.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_get(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (mlx5_esw_allowed(esw))
+ 		atomic64_inc(&esw->user_count);
+ }
+ 
+ /**
+  * mlx5_esw_put() - Decrease esw user count.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_put(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (mlx5_esw_allowed(esw))
+ 		atomic64_dec_if_positive(&esw->user_count);
+ }
+ 
+ /**
+  * mlx5_esw_try_lock() - Take a write lock on esw mode lock.
+  * @esw: eswitch device.
+  *
+  * Should be called by esw mode change routine.
+  *
+  * Return:
+  * * 0       - esw mode if successfully locked and refcount is 0.
+  * * -EBUSY  - refcount is not 0.
+  * * -EINVAL - In the middle of switching mode or lock is already held.
+  */
+ int mlx5_esw_try_lock(struct mlx5_eswitch *esw)
+ {
+ 	if (down_write_trylock(&esw->mode_lock) == 0)
+ 		return -EINVAL;
+ 
+ 	if (atomic64_read(&esw->user_count) > 0) {
+ 		up_write(&esw->mode_lock);
+ 		return -EBUSY;
+ 	}
+ 
+ 	return esw->mode;
+ }
+ 
+ /**
+  * mlx5_esw_unlock() - Release write lock on esw mode lock
+  * @esw: eswitch device.
+  */
+ void mlx5_esw_unlock(struct mlx5_eswitch *esw)
+ {
+ 	up_write(&esw->mode_lock);
+ }
++>>>>>>> b16f2bb6b6ca (net/mlx5: E-Switch, Convert a macro to a helper routine)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index f8d344738e70..7eeca9a7fe9a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -486,6 +486,11 @@ const u32 *mlx5_esw_query_functions(struct mlx5_core_dev *dev);
 #define esw_debug(dev, format, ...)				\
 	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
 
+static inline bool mlx5_esw_allowed(const struct mlx5_eswitch *esw)
+{
+	return esw && MLX5_ESWITCH_MANAGER(esw->dev);
+}
+
 /* The returned number is valid only when the dev is eswitch manager. */
 static inline u16 mlx5_eswitch_manager_vport(struct mlx5_core_dev *dev)
 {
