netfilter: nft_exthdr: Fix for unsafe packet data read

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Phil Sutter <phil@nwl.cc>
commit cf6b5ffdce5a78b2fcb0e53b3a2487c490bcbf7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/cf6b5ffd.failed

While iterating through an SCTP packet's chunks, skb_header_pointer() is
called for the minimum expected chunk header size. If (that part of) the
skbuff is non-linear, the following memcpy() may read data past
temporary buffer '_sch'. Use skb_copy_bits() instead which does the
right thing in this situation.

Fixes: 133dc203d77df ("netfilter: nft_exthdr: Support SCTP chunks")
	Suggested-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Phil Sutter <phil@nwl.cc>
	Reviewed-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit cf6b5ffdce5a78b2fcb0e53b3a2487c490bcbf7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_exthdr.c
diff --cc net/netfilter/nft_exthdr.c
index 79d8531d95a7,7f705b5c09de..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -207,6 -302,45 +207,48 @@@ static void nft_exthdr_tcp_set_eval(con
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void nft_exthdr_sctp_eval(const struct nft_expr *expr,
+ 				 struct nft_regs *regs,
+ 				 const struct nft_pktinfo *pkt)
+ {
+ 	unsigned int offset = nft_thoff(pkt) + sizeof(struct sctphdr);
+ 	struct nft_exthdr *priv = nft_expr_priv(expr);
+ 	u32 *dest = &regs->data[priv->dreg];
+ 	const struct sctp_chunkhdr *sch;
+ 	struct sctp_chunkhdr _sch;
+ 
+ 	do {
+ 		sch = skb_header_pointer(pkt->skb, offset, sizeof(_sch), &_sch);
+ 		if (!sch || !sch->length)
+ 			break;
+ 
+ 		if (sch->type == priv->type) {
+ 			if (priv->flags & NFT_EXTHDR_F_PRESENT) {
+ 				nft_reg_store8(dest, true);
+ 				return;
+ 			}
+ 			if (priv->offset + priv->len > ntohs(sch->length) ||
+ 			    offset + ntohs(sch->length) > pkt->skb->len)
+ 				break;
+ 
+ 			dest[priv->len / NFT_REG32_SIZE] = 0;
+ 			if (skb_copy_bits(pkt->skb, offset + priv->offset,
+ 					  dest, priv->len) < 0)
+ 				break;
+ 			return;
+ 		}
+ 		offset += SCTP_PAD4(ntohs(sch->length));
+ 	} while (offset < pkt->skb->len);
+ 
+ 	if (priv->flags & NFT_EXTHDR_F_PRESENT)
+ 		nft_reg_store8(dest, false);
+ 	else
+ 		regs->verdict.code = NFT_BREAK;
+ }
+ 
++>>>>>>> cf6b5ffdce5a (netfilter: nft_exthdr: Fix for unsafe packet data read)
  static const struct nla_policy nft_exthdr_policy[NFTA_EXTHDR_MAX + 1] = {
  	[NFTA_EXTHDR_DREG]		= { .type = NLA_U32 },
  	[NFTA_EXTHDR_TYPE]		= { .type = NLA_U8 },
* Unmerged path net/netfilter/nft_exthdr.c
