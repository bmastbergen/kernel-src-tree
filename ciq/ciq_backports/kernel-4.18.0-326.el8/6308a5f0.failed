net/mlx5: E-Switch, Make vport number u16

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Parav Pandit <parav@nvidia.com>
commit 6308a5f06be08f3ea1f1a895a9ef54c7b65c4c35
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/6308a5f0.failed

Vport number is 16-bit field in hardware. Make it u16.

Move location of vport in the structure so that it reduces a hole
in the structure.

	Signed-off-by: Parav Pandit <parav@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 6308a5f06be08f3ea1f1a895a9ef54c7b65c4c35)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index ff63d3681390,bbb707117296..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -707,6 -969,82 +707,85 @@@ void mlx5_eswitch_del_send_to_vport_rul
  	mlx5_del_flow_rules(rule);
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5_eswitch_del_send_to_vport_meta_rules(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_flow_handle **flows = esw->fdb_table.offloads.send_to_vport_meta_rules;
+ 	int i = 0, num_vfs = esw->esw_funcs.num_vfs, vport_num;
+ 
+ 	if (!num_vfs || !flows)
+ 		return;
+ 
+ 	mlx5_esw_for_each_vf_vport_num(esw, vport_num, num_vfs)
+ 		mlx5_del_flow_rules(flows[i++]);
+ 
+ 	kvfree(flows);
+ }
+ 
+ static int
+ mlx5_eswitch_add_send_to_vport_meta_rules(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_flow_destination dest = {};
+ 	struct mlx5_flow_act flow_act = {0};
+ 	int num_vfs, rule_idx = 0, err = 0;
+ 	struct mlx5_flow_handle *flow_rule;
+ 	struct mlx5_flow_handle **flows;
+ 	struct mlx5_flow_spec *spec;
+ 	u16 vport_num;
+ 
+ 	num_vfs = esw->esw_funcs.num_vfs;
+ 	flows = kvzalloc(num_vfs * sizeof(*flows), GFP_KERNEL);
+ 	if (!flows)
+ 		return -ENOMEM;
+ 
+ 	spec = kvzalloc(sizeof(*spec), GFP_KERNEL);
+ 	if (!spec) {
+ 		err = -ENOMEM;
+ 		goto alloc_err;
+ 	}
+ 
+ 	MLX5_SET(fte_match_param, spec->match_criteria,
+ 		 misc_parameters_2.metadata_reg_c_0, mlx5_eswitch_get_vport_metadata_mask());
+ 	MLX5_SET(fte_match_param, spec->match_criteria,
+ 		 misc_parameters_2.metadata_reg_c_1, ESW_TUN_MASK);
+ 	MLX5_SET(fte_match_param, spec->match_value, misc_parameters_2.metadata_reg_c_1,
+ 		 ESW_TUN_SLOW_TABLE_GOTO_VPORT_MARK);
+ 
+ 	spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2;
+ 	dest.type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 	flow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
+ 
+ 	mlx5_esw_for_each_vf_vport_num(esw, vport_num, num_vfs) {
+ 		MLX5_SET(fte_match_param, spec->match_value, misc_parameters_2.metadata_reg_c_0,
+ 			 mlx5_eswitch_get_vport_metadata_for_match(esw, vport_num));
+ 		dest.vport.num = vport_num;
+ 
+ 		flow_rule = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
+ 						spec, &flow_act, &dest, 1);
+ 		if (IS_ERR(flow_rule)) {
+ 			err = PTR_ERR(flow_rule);
+ 			esw_warn(esw->dev, "FDB: Failed to add send to vport meta rule idx %d, err %ld\n",
+ 				 rule_idx, PTR_ERR(flow_rule));
+ 			goto rule_err;
+ 		}
+ 		flows[rule_idx++] = flow_rule;
+ 	}
+ 
+ 	esw->fdb_table.offloads.send_to_vport_meta_rules = flows;
+ 	kvfree(spec);
+ 	return 0;
+ 
+ rule_err:
+ 	while (--rule_idx >= 0)
+ 		mlx5_del_flow_rules(flows[rule_idx]);
+ 	kvfree(spec);
+ alloc_err:
+ 	kvfree(flows);
+ 	return err;
+ }
+ 
++>>>>>>> 6308a5f06be0 (net/mlx5: E-Switch, Make vport number u16)
  static bool mlx5_eswitch_reg_c1_loopback_supported(struct mlx5_eswitch *esw)
  {
  	return MLX5_CAP_ESW_FLOWTABLE(esw->dev, fdb_to_vport_reg_c_id) &
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index f8d344738e70..09cec0047788 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -133,7 +133,6 @@ enum mlx5_eswitch_vport_event {
 
 struct mlx5_vport {
 	struct mlx5_core_dev    *dev;
-	int                     vport;
 	struct hlist_head       uc_list[MLX5_L2_ADDR_HASH_SIZE];
 	struct hlist_head       mc_list[MLX5_L2_ADDR_HASH_SIZE];
 	struct mlx5_flow_handle *promisc_rule;
@@ -155,6 +154,7 @@ struct mlx5_vport {
 		u32 max_rate;
 	} qos;
 
+	u16 vport;
 	bool                    enabled;
 	enum mlx5_eswitch_vport_event enabled_events;
 	struct devlink_port *dl_port;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/include/linux/mlx5/eswitch.h b/include/linux/mlx5/eswitch.h
index b0ae8020f13e..062baa8cde75 100644
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@ -123,8 +123,7 @@ mlx5_eswitch_vport_match_metadata_enabled(const struct mlx5_eswitch *esw)
 };
 
 static inline u32
-mlx5_eswitch_get_vport_metadata_for_match(struct mlx5_eswitch *esw,
-					  int vport_num)
+mlx5_eswitch_get_vport_metadata_for_match(struct mlx5_eswitch *esw, u16 vport_num)
 {
 	return 0;
 };
