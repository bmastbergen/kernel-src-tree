xfs: actually bump warning counts when we send warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 4b8628d57b725b32616965e66975fcdebe008fe7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/4b8628d5.failed

Currently, xfs quotas have the ability to send netlink warnings when a
user exceeds the limits.  They also have all the support code necessary
to convert softlimit warnings into failures if the number of warnings
exceeds a limit set by the administrator.  Unfortunately, we never
actually increase the warning counter, so this never actually happens.
Make it so we actually do something useful with the warning counts.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Chandan Babu R <chandanrlinux@gmail.com>
(cherry picked from commit 4b8628d57b725b32616965e66975fcdebe008fe7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_trans_dquot.c
diff --cc fs/xfs/xfs_trans_dquot.c
index 1bea111c0f6a,6be6287da1ac..000000000000
--- a/fs/xfs/xfs_trans_dquot.c
+++ b/fs/xfs/xfs_trans_dquot.c
@@@ -544,6 -544,59 +544,62 @@@ xfs_quota_warn
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Decide if we can make an additional reservation against a quota resource.
+  * Returns an inode QUOTA_NL_ warning code and whether or not it's fatal.
+  *
+  * Note that we assume that the numeric difference between the inode and block
+  * warning codes will always be 3 since it's userspace ABI now, and will never
+  * decrease the quota reservation, so the *BELOW messages are irrelevant.
+  */
+ static inline int
+ xfs_dqresv_check(
+ 	struct xfs_dquot_res	*res,
+ 	struct xfs_quota_limits	*qlim,
+ 	int64_t			delta,
+ 	bool			*fatal)
+ {
+ 	xfs_qcnt_t		hardlimit = res->hardlimit;
+ 	xfs_qcnt_t		softlimit = res->softlimit;
+ 	xfs_qcnt_t		total_count = res->reserved + delta;
+ 
+ 	BUILD_BUG_ON(QUOTA_NL_BHARDWARN     != QUOTA_NL_IHARDWARN + 3);
+ 	BUILD_BUG_ON(QUOTA_NL_BSOFTLONGWARN != QUOTA_NL_ISOFTLONGWARN + 3);
+ 	BUILD_BUG_ON(QUOTA_NL_BSOFTWARN     != QUOTA_NL_ISOFTWARN + 3);
+ 
+ 	*fatal = false;
+ 	if (delta <= 0)
+ 		return QUOTA_NL_NOWARN;
+ 
+ 	if (!hardlimit)
+ 		hardlimit = qlim->hard;
+ 	if (!softlimit)
+ 		softlimit = qlim->soft;
+ 
+ 	if (hardlimit && total_count > hardlimit) {
+ 		*fatal = true;
+ 		return QUOTA_NL_IHARDWARN;
+ 	}
+ 
+ 	if (softlimit && total_count > softlimit) {
+ 		time64_t	now = ktime_get_real_seconds();
+ 
+ 		if ((res->timer != 0 && now > res->timer) ||
+ 		    (res->warnings != 0 && res->warnings >= qlim->warn)) {
+ 			*fatal = true;
+ 			return QUOTA_NL_ISOFTLONGWARN;
+ 		}
+ 
+ 		res->warnings++;
+ 		return QUOTA_NL_ISOFTWARN;
+ 	}
+ 
+ 	return QUOTA_NL_NOWARN;
+ }
+ 
+ /*
++>>>>>>> 4b8628d57b72 (xfs: actually bump warning counts when we send warnings)
   * This reserves disk blocks and inodes against a dquot.
   * Flags indicate if the dquot is to be locked here and also
   * if the blk reservation is for RT or regular blocks.
* Unmerged path fs/xfs/xfs_trans_dquot.c
