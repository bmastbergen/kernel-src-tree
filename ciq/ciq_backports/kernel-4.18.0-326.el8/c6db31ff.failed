ethtool: allow netdev driver to define phy tunables

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Igor Russkikh <irusskikh@marvell.com>
commit c6db31ffe202c3120147e9f3455a4dbc90546d39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/c6db31ff.failed

Define get/set phy tunable callbacks in ethtool ops.
This will allow MAC drivers with integrated PHY still to implement
these tunables.

	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c6db31ffe202c3120147e9f3455a4dbc90546d39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ethtool.h
diff --cc include/linux/ethtool.h
index b35bf5fe9205,6408b446051f..000000000000
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@@ -524,44 -505,13 +524,52 @@@ struct ethtool_ops 
  				      struct ethtool_fecparam *);
  	void	(*get_ethtool_phy_stats)(struct net_device *,
  					 struct ethtool_stats *, u64 *);
++<<<<<<< HEAD
++=======
+ 	int	(*get_phy_tunable)(struct net_device *,
+ 				   const struct ethtool_tunable *, void *);
+ 	int	(*set_phy_tunable)(struct net_device *,
+ 				   const struct ethtool_tunable *, const void *);
+ };
 -
 -int ethtool_check_ops(const struct ethtool_ops *ops);
++>>>>>>> c6db31ffe202 (ethtool: allow netdev driver to define phy tunables)
 +
 +	RH_KABI_USE(1, int	(*get_link_ksettings)(struct net_device *,
 +				      struct ethtool_link_ksettings *))
 +	RH_KABI_USE(2, int	(*set_link_ksettings)(struct net_device *,
 +				      const struct ethtool_link_ksettings *))
 +	RH_KABI_USE(3, u32	supported_coalesce_params)
 +	RH_KABI_USE(4, int	(*get_link_ext_state)(struct net_device *,
 +				      struct ethtool_link_ext_state_info *))
 +	RH_KABI_USE(5, void	(*get_pause_stats)(struct net_device *dev,
 +				   struct ethtool_pause_stats *pause_stats))
 +	RH_KABI_RESERVE(6)
 +	RH_KABI_RESERVE(7)
 +	RH_KABI_RESERVE(8)
 +	RH_KABI_RESERVE(9)
 +	RH_KABI_RESERVE(10)
 +	RH_KABI_RESERVE(11)
 +	RH_KABI_RESERVE(12)
 +	RH_KABI_RESERVE(13)
 +	RH_KABI_RESERVE(14)
 +	RH_KABI_RESERVE(15)
 +	RH_KABI_RESERVE(16)
 +	RH_KABI_RESERVE(17)
 +	RH_KABI_RESERVE(18)
 +	RH_KABI_RESERVE(19)
 +	RH_KABI_RESERVE(20)
 +	RH_KABI_RESERVE(21)
 +	RH_KABI_RESERVE(22)
 +	RH_KABI_RESERVE(23)
 +	RH_KABI_RESERVE(24)
 +	RH_KABI_RESERVE(25)
 +	RH_KABI_RESERVE(26)
 +	RH_KABI_RESERVE(27)
 +	RH_KABI_RESERVE(28)
 +	RH_KABI_RESERVE(29)
 +	RH_KABI_RESERVE(30)
 +	RH_KABI_RESERVE(31)
 +	RH_KABI_AUX_EMBED(ethtool_ops_extended)
 +};
  
  struct ethtool_rx_flow_rule {
  	struct flow_rule	*rule;
* Unmerged path include/linux/ethtool.h
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 6f94027689d8..d21e8aebfcd6 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -2567,14 +2567,15 @@ static int ethtool_phy_tunable_valid(const struct ethtool_tunable *tuna)
 
 static int get_phy_tunable(struct net_device *dev, void __user *useraddr)
 {
-	int ret;
-	struct ethtool_tunable tuna;
 	struct phy_device *phydev = dev->phydev;
+	struct ethtool_tunable tuna;
+	bool phy_drv_tunable;
 	void *data;
+	int ret;
 
-	if (!(phydev && phydev->drv && phydev->drv->get_tunable))
+	phy_drv_tunable = phydev && phydev->drv && phydev->drv->get_tunable;
+	if (!phy_drv_tunable && !dev->ethtool_ops->get_phy_tunable)
 		return -EOPNOTSUPP;
-
 	if (copy_from_user(&tuna, useraddr, sizeof(tuna)))
 		return -EFAULT;
 	ret = ethtool_phy_tunable_valid(&tuna);
@@ -2583,9 +2584,13 @@ static int get_phy_tunable(struct net_device *dev, void __user *useraddr)
 	data = kmalloc(tuna.len, GFP_USER);
 	if (!data)
 		return -ENOMEM;
-	mutex_lock(&phydev->lock);
-	ret = phydev->drv->get_tunable(phydev, &tuna, data);
-	mutex_unlock(&phydev->lock);
+	if (phy_drv_tunable) {
+		mutex_lock(&phydev->lock);
+		ret = phydev->drv->get_tunable(phydev, &tuna, data);
+		mutex_unlock(&phydev->lock);
+	} else {
+		ret = dev->ethtool_ops->get_phy_tunable(dev, &tuna, data);
+	}
 	if (ret)
 		goto out;
 	useraddr += sizeof(tuna);
@@ -2601,12 +2606,14 @@ static int get_phy_tunable(struct net_device *dev, void __user *useraddr)
 
 static int set_phy_tunable(struct net_device *dev, void __user *useraddr)
 {
-	int ret;
-	struct ethtool_tunable tuna;
 	struct phy_device *phydev = dev->phydev;
+	struct ethtool_tunable tuna;
+	bool phy_drv_tunable;
 	void *data;
+	int ret;
 
-	if (!(phydev && phydev->drv && phydev->drv->set_tunable))
+	phy_drv_tunable = phydev && phydev->drv && phydev->drv->get_tunable;
+	if (!phy_drv_tunable && !dev->ethtool_ops->set_phy_tunable)
 		return -EOPNOTSUPP;
 	if (copy_from_user(&tuna, useraddr, sizeof(tuna)))
 		return -EFAULT;
@@ -2617,9 +2624,13 @@ static int set_phy_tunable(struct net_device *dev, void __user *useraddr)
 	data = memdup_user(useraddr, tuna.len);
 	if (IS_ERR(data))
 		return PTR_ERR(data);
-	mutex_lock(&phydev->lock);
-	ret = phydev->drv->set_tunable(phydev, &tuna, data);
-	mutex_unlock(&phydev->lock);
+	if (phy_drv_tunable) {
+		mutex_lock(&phydev->lock);
+		ret = phydev->drv->set_tunable(phydev, &tuna, data);
+		mutex_unlock(&phydev->lock);
+	} else {
+		ret = dev->ethtool_ops->set_phy_tunable(dev, &tuna, data);
+	}
 
 	kfree(data);
 	return ret;
