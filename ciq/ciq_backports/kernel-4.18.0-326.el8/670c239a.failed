net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ariel Levkovich <lariel@nvidia.com>
commit 670c239a648f0a5e19d05d8256df292564cc0c0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/670c239a.failed

Keep and use a direct reference to the mlx5 core device in all of
tc_ct code instead of accessing it via a pointer to mlx5 eswitch
in order to support nic mode ct offload for VF devices that don't
have a valid eswitch pointer set.

	Signed-off-by: Ariel Levkovich <lariel@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 670c239a648f0a5e19d05d8256df292564cc0c0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
index 261de0cf38e0,b5f8ed30047b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
@@@ -43,8 -39,9 +43,8 @@@
  	netdev_dbg(ct_priv->netdev, "ct_debug: " fmt "\n", ##args)
  
  struct mlx5_tc_ct_priv {
- 	struct mlx5_eswitch *esw;
+ 	struct mlx5_core_dev *dev;
  	const struct net_device *netdev;
 -	struct mod_hdr_tbl *mod_hdr_tbl;
  	struct idr fte_ids;
  	struct xarray tuple_ids;
  	struct rhashtable zone_ht;
@@@ -424,14 -392,13 +424,19 @@@ mlx5_tc_ct_set_tuple_match(struct mlx5e
  }
  
  static void
 -mlx5_tc_ct_shared_counter_put(struct mlx5_tc_ct_priv *ct_priv, struct mlx5_ct_entry *entry)
 +mlx5_tc_ct_counter_put(struct mlx5_tc_ct_priv *ct_priv, struct mlx5_ct_entry *entry)
  {
 -	if (!refcount_dec_and_test(&entry->shared_counter->refcount))
 +	if (entry->counter->is_shared &&
 +	    !refcount_dec_and_test(&entry->counter->refcount))
  		return;
  
++<<<<<<< HEAD
 +	mlx5_fc_destroy(ct_priv->esw->dev, entry->counter->counter);
 +	kfree(entry->counter);
++=======
+ 	mlx5_fc_destroy(ct_priv->dev, entry->shared_counter->counter);
+ 	kfree(entry->shared_counter);
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  }
  
  static void
@@@ -445,9 -411,9 +450,15 @@@ mlx5_tc_ct_entry_del_rule(struct mlx5_t
  
  	ct_dbg("Deleting ct entry rule in zone %d", entry->tuple.zone);
  
++<<<<<<< HEAD
 +	mlx5_eswitch_del_offloaded_rule(esw, zone_rule->rule, attr);
 +	mlx5e_mod_hdr_detach(ct_priv->esw->dev,
 +			     &esw->offloads.mod_hdr, zone_rule->mh);
++=======
+ 	mlx5_tc_rule_delete(netdev_priv(ct_priv->netdev), zone_rule->rule, attr);
+ 	mlx5e_mod_hdr_detach(ct_priv->dev,
+ 			     ct_priv->mod_hdr_tbl, zone_rule->mh);
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  	mapping_remove(ct_priv->labels_mapping, attr->ct_attr.ct_labels_id);
  	kfree(attr);
  }
@@@ -484,29 -449,40 +494,62 @@@ mlx5_tc_ct_entry_set_registers(struct m
  			       u32 labels_id,
  			       u8 zone_restore_id)
  {
++<<<<<<< HEAD
 +	struct mlx5_eswitch *esw = ct_priv->esw;
 +	int err;
 +
 +	err = mlx5e_tc_match_to_reg_set(esw->dev, mod_acts,
++=======
+ 	enum mlx5_flow_namespace_type ns = ct_priv->ns_type;
+ 	struct mlx5_core_dev *dev = ct_priv->dev;
+ 	int err;
+ 
+ 	err = mlx5e_tc_match_to_reg_set(dev, mod_acts, ns,
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  					CTSTATE_TO_REG, ct_state);
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = mlx5e_tc_match_to_reg_set(esw->dev, mod_acts,
++=======
+ 	err = mlx5e_tc_match_to_reg_set(dev, mod_acts, ns,
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  					MARK_TO_REG, mark);
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = mlx5e_tc_match_to_reg_set(esw->dev, mod_acts,
++=======
+ 	err = mlx5e_tc_match_to_reg_set(dev, mod_acts, ns,
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  					LABELS_TO_REG, labels_id);
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = mlx5e_tc_match_to_reg_set(esw->dev, mod_acts,
++=======
+ 	err = mlx5e_tc_match_to_reg_set(dev, mod_acts, ns,
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  					ZONE_RESTORE_TO_REG, zone_restore_id);
  	if (err)
  		return err;
  
++<<<<<<< HEAD
++=======
+ 	/* Make another copy of zone id in reg_b for
+ 	 * NIC rx flows since we don't copy reg_c1 to
+ 	 * reg_b upon miss.
+ 	 */
+ 	if (ns != MLX5_FLOW_NAMESPACE_FDB) {
+ 		err = mlx5e_tc_match_to_reg_set(dev, mod_acts, ns,
+ 						NIC_ZONE_RESTORE_TO_REG, zone_restore_id);
+ 		if (err)
+ 			return err;
+ 	}
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  	return 0;
  }
  
@@@ -665,9 -639,9 +708,15 @@@ mlx5_tc_ct_entry_create_mod_hdr(struct 
  	if (err)
  		goto err_mapping;
  
++<<<<<<< HEAD
 +	*mh = mlx5e_mod_hdr_attach(ct_priv->esw->dev,
 +				   &ct_priv->esw->offloads.mod_hdr,
 +				   MLX5_FLOW_NAMESPACE_FDB,
++=======
+ 	*mh = mlx5e_mod_hdr_attach(ct_priv->dev,
+ 				   ct_priv->mod_hdr_tbl,
+ 				   ct_priv->ns_type,
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  				   &mod_acts);
  	if (IS_ERR(*mh)) {
  		err = PTR_ERR(*mh);
@@@ -746,8 -720,8 +795,13 @@@ mlx5_tc_ct_entry_add_rule(struct mlx5_t
  	return 0;
  
  err_rule:
++<<<<<<< HEAD
 +	mlx5e_mod_hdr_detach(ct_priv->esw->dev,
 +			     &esw->offloads.mod_hdr, zone_rule->mh);
++=======
+ 	mlx5e_mod_hdr_detach(ct_priv->dev,
+ 			     ct_priv->mod_hdr_tbl, zone_rule->mh);
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  	mapping_remove(ct_priv->labels_mapping, attr->ct_attr.ct_labels_id);
  err_mod_hdr:
  	kfree(attr);
@@@ -864,10 -735,10 +918,15 @@@ mlx5_tc_ct_shared_counter_get(struct ml
  			      struct mlx5_ct_entry *entry)
  {
  	struct mlx5_ct_tuple rev_tuple = entry->tuple;
++<<<<<<< HEAD
 +	struct mlx5_ct_counter *shared_counter;
++=======
+ 	struct mlx5_ct_shared_counter *shared_counter;
+ 	struct mlx5_core_dev *dev = ct_priv->dev;
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  	struct mlx5_ct_entry *rev_entry;
  	__be16 tmp_port;
 +	int ret;
  
  	/* get the reversed tuple */
  	tmp_port = rev_tuple.port.src;
@@@ -889,34 -760,28 +948,46 @@@
  	}
  
  	/* Use the same counter as the reverse direction */
 -	mutex_lock(&ct_priv->shared_counter_lock);
 -	rev_entry = rhashtable_lookup_fast(&ct_priv->ct_tuples_ht, &rev_tuple,
 -					   tuples_ht_params);
 -	if (rev_entry) {
 -		if (refcount_inc_not_zero(&rev_entry->shared_counter->refcount)) {
 -			mutex_unlock(&ct_priv->shared_counter_lock);
 -			return rev_entry->shared_counter;
 -		}
 -	}
 -	mutex_unlock(&ct_priv->shared_counter_lock);
 -
 +	spin_lock_bh(&ct_priv->ht_lock);
 +	rev_entry = mlx5_tc_ct_entry_get(ct_priv, &rev_tuple);
 +
++<<<<<<< HEAD
 +	if (IS_ERR(rev_entry)) {
 +		spin_unlock_bh(&ct_priv->ht_lock);
 +		goto create_counter;
++=======
+ 	shared_counter = kzalloc(sizeof(*shared_counter), GFP_KERNEL);
+ 	if (!shared_counter)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	shared_counter->counter = mlx5_fc_create(dev, true);
+ 	if (IS_ERR(shared_counter->counter)) {
+ 		ct_dbg("Failed to create counter for ct entry");
+ 		kfree(shared_counter);
+ 		return ERR_PTR(PTR_ERR(shared_counter->counter));
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
 +	}
 +
 +	if (rev_entry && refcount_inc_not_zero(&rev_entry->counter->refcount)) {
 +		ct_dbg("Using shared counter entry=0x%p rev=0x%p\n", entry, rev_entry);
 +		shared_counter = rev_entry->counter;
 +		spin_unlock_bh(&ct_priv->ht_lock);
 +
 +		mlx5_tc_ct_entry_put(rev_entry);
 +		return shared_counter;
  	}
  
 +	spin_unlock_bh(&ct_priv->ht_lock);
 +
 +create_counter:
 +
 +	shared_counter = mlx5_tc_ct_counter_create(ct_priv);
 +	if (IS_ERR(shared_counter)) {
 +		ret = PTR_ERR(shared_counter);
 +		return ERR_PTR(ret);
 +	}
 +
 +	shared_counter->is_shared = true;
  	refcount_set(&shared_counter->refcount, 1);
  	return shared_counter;
  }
@@@ -1344,8 -1158,8 +1415,13 @@@ static int tc_ct_pre_ct_add_rules(struc
  {
  	struct mlx5_tc_ct_priv *ct_priv = ct_ft->ct_priv;
  	struct mlx5e_tc_mod_hdr_acts pre_mod_acts = {};
++<<<<<<< HEAD
 +	struct mlx5_core_dev *dev = ct_priv->esw->dev;
 +	struct mlx5_flow_table *fdb = pre_ct->fdb;
++=======
+ 	struct mlx5_core_dev *dev = ct_priv->dev;
+ 	struct mlx5_flow_table *ft = pre_ct->ft;
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  	struct mlx5_flow_destination dest = {};
  	struct mlx5_flow_act flow_act = {};
  	struct mlx5_modify_hdr *mod_hdr;
@@@ -2095,10 -1929,12 +2171,19 @@@ mlx5_tc_ct_init(struct mlx5_rep_uplink_
  		goto err_mapping_labels;
  	}
  
++<<<<<<< HEAD
 +	spin_lock_init(&ct_priv->ht_lock);
 +	ct_priv->esw = esw;
 +	ct_priv->netdev = rpriv->netdev;
 +	ct_priv->ct = mlx5_chains_create_global_table(esw_chains(esw));
++=======
+ 	ct_priv->ns_type = ns_type;
+ 	ct_priv->chains = chains;
+ 	ct_priv->netdev = priv->netdev;
+ 	ct_priv->dev = priv->mdev;
+ 	ct_priv->mod_hdr_tbl = mod_hdr;
+ 	ct_priv->ct = mlx5_chains_create_global_table(chains);
++>>>>>>> 670c239a648f (net/mlx5e: Keep direct reference to mlx5_core_dev in tc ct)
  	if (IS_ERR(ct_priv->ct)) {
  		err = PTR_ERR(ct_priv->ct);
  		mlx5_core_warn(dev,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
