xhci: move and rename xhci_cleanup_halted_endpoint()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Mathias Nyman <mathias.nyman@linux.intel.com>
commit 7c6c334e6fc8cd99e780fd74cd29687886a81862
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/7c6c334e.failed

Halted endpoints can be discoverd both when handling transfer events and
command completion events. Move code that handles halted endpoints before
both of those event handlers.

Rename the function to xhci_handle_halted_ep() to better describe
what it does. Try to reserve "cleanup" word in function names for last
stage cleanup activities.

No functional changes

	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
Link: https://lore.kernel.org/r/20210129130044.206855-21-mathias.nyman@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 7c6c334e6fc8cd99e780fd74cd29687886a81862)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci-ring.c
diff --cc drivers/usb/host/xhci-ring.c
index bd30ef5cce7a,42639deac4ad..000000000000
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@@ -749,6 -749,103 +749,106 @@@ static void xhci_unmap_td_bounce_buffer
  	seg->bounce_offs = 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int xhci_td_cleanup(struct xhci_hcd *xhci, struct xhci_td *td,
+ 			   struct xhci_ring *ep_ring, int status)
+ {
+ 	struct urb *urb = NULL;
+ 
+ 	/* Clean up the endpoint's TD list */
+ 	urb = td->urb;
+ 
+ 	/* if a bounce buffer was used to align this td then unmap it */
+ 	xhci_unmap_td_bounce_buffer(xhci, ep_ring, td);
+ 
+ 	/* Do one last check of the actual transfer length.
+ 	 * If the host controller said we transferred more data than the buffer
+ 	 * length, urb->actual_length will be a very big number (since it's
+ 	 * unsigned).  Play it safe and say we didn't transfer anything.
+ 	 */
+ 	if (urb->actual_length > urb->transfer_buffer_length) {
+ 		xhci_warn(xhci, "URB req %u and actual %u transfer length mismatch\n",
+ 			  urb->transfer_buffer_length, urb->actual_length);
+ 		urb->actual_length = 0;
+ 		status = 0;
+ 	}
+ 	/* TD might be removed from td_list if we are giving back a cancelled URB */
+ 	if (!list_empty(&td->td_list))
+ 		list_del_init(&td->td_list);
+ 	/* Giving back a cancelled URB, or if a slated TD completed anyway */
+ 	if (!list_empty(&td->cancelled_td_list))
+ 		list_del_init(&td->cancelled_td_list);
+ 
+ 	inc_td_cnt(urb);
+ 	/* Giveback the urb when all the tds are completed */
+ 	if (last_td_in_urb(td)) {
+ 		if ((urb->actual_length != urb->transfer_buffer_length &&
+ 		     (urb->transfer_flags & URB_SHORT_NOT_OK)) ||
+ 		    (status != 0 && !usb_endpoint_xfer_isoc(&urb->ep->desc)))
+ 			xhci_dbg(xhci, "Giveback URB %p, len = %d, expected = %d, status = %d\n",
+ 				 urb, urb->actual_length,
+ 				 urb->transfer_buffer_length, status);
+ 
+ 		/* set isoc urb status to 0 just as EHCI, UHCI, and OHCI */
+ 		if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
+ 			status = 0;
+ 		xhci_giveback_urb_in_irq(xhci, td, status);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xhci_reset_halted_ep(struct xhci_hcd *xhci, unsigned int slot_id,
+ 				unsigned int ep_index, enum xhci_ep_reset_type reset_type)
+ {
+ 	struct xhci_command *command;
+ 	int ret = 0;
+ 
+ 	command = xhci_alloc_command(xhci, false, GFP_ATOMIC);
+ 	if (!command) {
+ 		ret = -ENOMEM;
+ 		goto done;
+ 	}
+ 
+ 	ret = xhci_queue_reset_ep(xhci, command, slot_id, ep_index, reset_type);
+ done:
+ 	if (ret)
+ 		xhci_err(xhci, "ERROR queuing reset endpoint for slot %d ep_index %d, %d\n",
+ 			 slot_id, ep_index, ret);
+ 	return ret;
+ }
+ 
+ static void xhci_handle_halted_endpoint(struct xhci_hcd *xhci,
+ 				struct xhci_virt_ep *ep, unsigned int stream_id,
+ 				struct xhci_td *td,
+ 				enum xhci_ep_reset_type reset_type)
+ {
+ 	unsigned int slot_id = ep->vdev->slot_id;
+ 	int err;
+ 
+ 	/*
+ 	 * Avoid resetting endpoint if link is inactive. Can cause host hang.
+ 	 * Device will be reset soon to recover the link so don't do anything
+ 	 */
+ 	if (ep->vdev->flags & VDEV_PORT_ERROR)
+ 		return;
+ 
+ 	ep->ep_state |= EP_HALTED;
+ 
+ 	err = xhci_reset_halted_ep(xhci, slot_id, ep->ep_index, reset_type);
+ 	if (err)
+ 		return;
+ 
+ 	if (reset_type == EP_HARD_RESET) {
+ 		ep->ep_state |= EP_HARD_CLEAR_TOGGLE;
+ 		xhci_cleanup_stalled_ring(xhci, slot_id, ep->ep_index, stream_id,
+ 					  td);
+ 	}
+ 	xhci_ring_cmd_db(xhci);
+ }
+ 
++>>>>>>> 7c6c334e6fc8 (xhci: move and rename xhci_cleanup_halted_endpoint())
  /*
   * Fix up the ep ring first, so HW stops executing cancelled TDs.
   * We have the xHCI lock, so nothing can modify this list until we drop it.
@@@ -1900,37 -1993,6 +2000,40 @@@ static void xhci_clear_hub_tt_buffer(st
  	}
  }
  
++<<<<<<< HEAD
 +static void xhci_cleanup_halted_endpoint(struct xhci_hcd *xhci,
 +		unsigned int slot_id, unsigned int ep_index,
 +		unsigned int stream_id, struct xhci_td *td,
 +		enum xhci_ep_reset_type reset_type)
 +{
 +	struct xhci_virt_ep *ep = &xhci->devs[slot_id]->eps[ep_index];
 +	struct xhci_command *command;
 +
 +	/*
 +	 * Avoid resetting endpoint if link is inactive. Can cause host hang.
 +	 * Device will be reset soon to recover the link so don't do anything
 +	 */
 +	if (xhci->devs[slot_id]->flags & VDEV_PORT_ERROR)
 +		return;
 +
 +	command = xhci_alloc_command(xhci, false, GFP_ATOMIC);
 +	if (!command)
 +		return;
 +
 +	ep->ep_state |= EP_HALTED;
 +
 +	xhci_queue_reset_ep(xhci, command, slot_id, ep_index, reset_type);
 +
 +	if (reset_type == EP_HARD_RESET) {
 +		ep->ep_state |= EP_HARD_CLEAR_TOGGLE;
 +		xhci_cleanup_stalled_ring(xhci, slot_id, ep_index, stream_id,
 +					  td);
 +	}
 +	xhci_ring_cmd_db(xhci);
 +}
 +
++=======
++>>>>>>> 7c6c334e6fc8 (xhci: move and rename xhci_cleanup_halted_endpoint())
  /* Check if an error has halted the endpoint ring.  The class driver will
   * cleanup the halt for a non-default control endpoint if we indicate a stall.
   * However, a babble and other errors also halt the endpoint ring, and the class
@@@ -2057,10 -2066,11 +2160,16 @@@ static int finish_td(struct xhci_hcd *x
  		 * stall later. Hub TT buffer should only be cleared for FS/LS
  		 * devices behind HS hubs for functional stalls.
  		 */
 -		if ((ep->ep_index != 0) || (trb_comp_code != COMP_STALL_ERROR))
 +		if ((ep_index != 0) || (trb_comp_code != COMP_STALL_ERROR))
  			xhci_clear_hub_tt_buffer(xhci, td, ep);
++<<<<<<< HEAD
 +		xhci_cleanup_halted_endpoint(xhci, slot_id, ep_index,
 +					ep_ring->stream_id, td, EP_HARD_RESET);
++=======
+ 
+ 		xhci_handle_halted_endpoint(xhci, ep, ep_ring->stream_id, td,
+ 					     EP_HARD_RESET);
++>>>>>>> 7c6c334e6fc8 (xhci: move and rename xhci_cleanup_halted_endpoint())
  	} else {
  		/* Update ring dequeue pointer */
  		ep_ring->dequeue = td->last_trb;
@@@ -2353,9 -2353,11 +2462,17 @@@ static int process_bulk_intr_td(struct 
  		if ((ep_ring->err_count++ > MAX_SOFT_RETRY) ||
  		    le32_to_cpu(slot_ctx->tt_info) & TT_SLOT)
  			break;
++<<<<<<< HEAD
 +		*status = 0;
 +		xhci_cleanup_halted_endpoint(xhci, slot_id, ep_index,
 +					ep_ring->stream_id, td, EP_SOFT_RESET);
++=======
+ 
+ 		td->status = 0;
+ 
+ 		xhci_handle_halted_endpoint(xhci, ep, ep_ring->stream_id, td,
+ 					    EP_SOFT_RESET);
++>>>>>>> 7c6c334e6fc8 (xhci: move and rename xhci_cleanup_halted_endpoint())
  		return 0;
  	default:
  		/* do nothing */
@@@ -2428,8 -2430,8 +2545,13 @@@ static int handle_tx_event(struct xhci_
  		case COMP_USB_TRANSACTION_ERROR:
  		case COMP_INVALID_STREAM_TYPE_ERROR:
  		case COMP_INVALID_STREAM_ID_ERROR:
++<<<<<<< HEAD
 +			xhci_cleanup_halted_endpoint(xhci, slot_id, ep_index, 0,
 +						     NULL, EP_SOFT_RESET);
++=======
+ 			xhci_handle_halted_endpoint(xhci, ep, 0, NULL,
+ 						    EP_SOFT_RESET);
++>>>>>>> 7c6c334e6fc8 (xhci: move and rename xhci_cleanup_halted_endpoint())
  			goto cleanup;
  		case COMP_RING_UNDERRUN:
  		case COMP_RING_OVERRUN:
@@@ -2613,11 -2615,10 +2735,18 @@@
  			if (trb_comp_code == COMP_STALL_ERROR ||
  			    xhci_requires_manual_halt_cleanup(xhci, ep_ctx,
  							      trb_comp_code)) {
++<<<<<<< HEAD
 +				xhci_cleanup_halted_endpoint(xhci, slot_id,
 +							     ep_index,
 +							     ep_ring->stream_id,
 +							     NULL,
 +							     EP_HARD_RESET);
++=======
+ 				xhci_handle_halted_endpoint(xhci, ep,
+ 							    ep_ring->stream_id,
+ 							    NULL,
+ 							    EP_HARD_RESET);
++>>>>>>> 7c6c334e6fc8 (xhci: move and rename xhci_cleanup_halted_endpoint())
  			}
  			goto cleanup;
  		}
@@@ -2708,10 -2710,9 +2837,16 @@@
  			if (trb_comp_code == COMP_STALL_ERROR ||
  			    xhci_requires_manual_halt_cleanup(xhci, ep_ctx,
  							      trb_comp_code))
++<<<<<<< HEAD
 +				xhci_cleanup_halted_endpoint(xhci, slot_id,
 +							     ep_index,
 +							     ep_ring->stream_id,
 +							     td, EP_HARD_RESET);
++=======
+ 				xhci_handle_halted_endpoint(xhci, ep,
+ 							    ep_ring->stream_id,
+ 							    td, EP_HARD_RESET);
++>>>>>>> 7c6c334e6fc8 (xhci: move and rename xhci_cleanup_halted_endpoint())
  			goto cleanup;
  		}
  
* Unmerged path drivers/usb/host/xhci-ring.c
