xfs: refactor quota exceeded test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit ea0cc6fa8f89a0089c561b65b909ceab48463338
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/ea0cc6fa.failed

Refactor the open-coded test for whether or not we're over quota.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Chandan Babu R <chandanrlinux@gmail.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit ea0cc6fa8f89a0089c561b65b909ceab48463338)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_dquot.c
diff --cc fs/xfs/xfs_dquot.c
index 9621581b70c7,98cb31f28aaf..000000000000
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@@ -122,71 -145,9 +145,77 @@@ xfs_qm_adjust_dqtimers
  	ASSERT(dq->q_id);
  	defq = xfs_get_defquota(qi, xfs_dquot_type(dq));
  
++<<<<<<< HEAD
 +#ifdef DEBUG
 +	if (dq->q_blk.hardlimit)
 +		ASSERT(dq->q_blk.softlimit <= dq->q_blk.hardlimit);
 +	if (dq->q_ino.hardlimit)
 +		ASSERT(dq->q_ino.softlimit <= dq->q_ino.hardlimit);
 +	if (dq->q_rtb.hardlimit)
 +		ASSERT(dq->q_rtb.softlimit <= dq->q_rtb.hardlimit);
 +#endif
 +
 +	if (!dq->q_blk.timer) {
 +		if ((dq->q_blk.softlimit &&
 +		     (dq->q_blk.count > dq->q_blk.softlimit)) ||
 +		    (dq->q_blk.hardlimit &&
 +		     (dq->q_blk.count > dq->q_blk.hardlimit))) {
 +			dq->q_blk.timer = ktime_get_real_seconds() +
 +					defq->btimelimit;
 +		} else {
 +			dq->q_blk.warnings = 0;
 +		}
 +	} else {
 +		if ((!dq->q_blk.softlimit ||
 +		     (dq->q_blk.count <= dq->q_blk.softlimit)) &&
 +		    (!dq->q_blk.hardlimit ||
 +		    (dq->q_blk.count <= dq->q_blk.hardlimit))) {
 +			dq->q_blk.timer = 0;
 +		}
 +	}
 +
 +	if (!dq->q_ino.timer) {
 +		if ((dq->q_ino.softlimit &&
 +		     (dq->q_ino.count > dq->q_ino.softlimit)) ||
 +		    (dq->q_ino.hardlimit &&
 +		     (dq->q_ino.count > dq->q_ino.hardlimit))) {
 +			dq->q_ino.timer = ktime_get_real_seconds() +
 +					defq->itimelimit;
 +		} else {
 +			dq->q_ino.warnings = 0;
 +		}
 +	} else {
 +		if ((!dq->q_ino.softlimit ||
 +		     (dq->q_ino.count <= dq->q_ino.softlimit))  &&
 +		    (!dq->q_ino.hardlimit ||
 +		     (dq->q_ino.count <= dq->q_ino.hardlimit))) {
 +			dq->q_ino.timer = 0;
 +		}
 +	}
 +
 +	if (!dq->q_rtb.timer) {
 +		if ((dq->q_rtb.softlimit &&
 +		     (dq->q_rtb.count > dq->q_rtb.softlimit)) ||
 +		    (dq->q_rtb.hardlimit &&
 +		     (dq->q_rtb.count > dq->q_rtb.hardlimit))) {
 +			dq->q_rtb.timer = ktime_get_real_seconds() +
 +					defq->rtbtimelimit;
 +		} else {
 +			dq->q_rtb.warnings = 0;
 +		}
 +	} else {
 +		if ((!dq->q_rtb.softlimit ||
 +		     (dq->q_rtb.count <= dq->q_rtb.softlimit)) &&
 +		    (!dq->q_rtb.hardlimit ||
 +		     (dq->q_rtb.count <= dq->q_rtb.hardlimit))) {
 +			dq->q_rtb.timer = 0;
 +		}
 +	}
++=======
+ 	xfs_qm_adjust_res_timer(&dq->q_blk, &defq->blk);
+ 	xfs_qm_adjust_res_timer(&dq->q_ino, &defq->ino);
+ 	xfs_qm_adjust_res_timer(&dq->q_rtb, &defq->rtb);
++>>>>>>> ea0cc6fa8f89 (xfs: refactor quota exceeded test)
  }
  
  /*
* Unmerged path fs/xfs/xfs_dquot.c
