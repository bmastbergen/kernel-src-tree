x86/fault: Check user_mode(regs) when avoiding an mmap_sem deadlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Andy Lutomirski <luto@kernel.org>
commit 6344be608c039f3a787f1144c46fcb04c0f76561
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/6344be60.failed

The fault-handling code that takes mmap_sem needs to avoid a
deadlock that could occur if the kernel took a bad (OOPS-worthy)
page fault on a user address while holding mmap_sem.  This can only
happen if the faulting instruction was in the kernel
(i.e. user_mode(regs)).  Rather than checking the sw_error_code
(which will have the USER bit set if the fault was a USER-permission
access *or* if user_mode(regs)), just check user_mode(regs)
directly.

The old code would have malfunctioned if the kernel executed a bogus
WRUSS instruction while holding mmap_sem.  Fortunately, that is
extremely unlikely in current kernels, which don't use WRUSS.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Yu-cheng Yu <yu-cheng.yu@intel.com>
Link: http://lkml.kernel.org/r/4b89b542e8ceba9bd6abde2f386afed6d99244a9.1542667307.git.luto@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6344be608c039f3a787f1144c46fcb04c0f76561)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/fault.c
diff --cc arch/x86/mm/fault.c
index 7f5ccfefd8cb,8624cb7d8d65..000000000000
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@@ -1376,25 -1318,40 +1376,55 @@@ __do_page_fault(struct pt_regs *regs, u
  	if (sw_error_code & X86_PF_INSTR)
  		flags |= FAULT_FLAG_INSTRUCTION;
  
 -#ifdef CONFIG_X86_64
  	/*
 -	 * Instruction fetch faults in the vsyscall page might need
 -	 * emulation.  The vsyscall page is at a high address
 -	 * (>PAGE_OFFSET), but is considered to be part of the user
 -	 * address space.
 +	 * When running in the kernel we expect faults to occur only to
 +	 * addresses in user space.  All other faults represent errors in
 +	 * the kernel and should generate an OOPS.  Unfortunately, in the
 +	 * case of an erroneous fault occurring in a code path which already
 +	 * holds mmap_sem we will deadlock attempting to validate the fault
 +	 * against the address space.  Luckily the kernel only validly
 +	 * references user space from well defined areas of code, which are
 +	 * listed in the exceptions table.
  	 *
++<<<<<<< HEAD
 +	 * As the vast majority of faults will be valid we will only perform
 +	 * the source reference check when there is a possibility of a
 +	 * deadlock. Attempt to lock the address space, if we cannot we then
 +	 * validate the source. If this is invalid we can skip the address
 +	 * space check, thus avoiding the deadlock:
 +	 */
 +	if (unlikely(!down_read_trylock(&mm->mmap_sem))) {
 +		if (!(sw_error_code & X86_PF_USER) &&
 +		    !search_exception_tables(regs->ip)) {
++=======
+ 	 * The vsyscall page does not have a "real" VMA, so do this
+ 	 * emulation before we go searching for VMAs.
+ 	 */
+ 	if ((sw_error_code & X86_PF_INSTR) && is_vsyscall_vaddr(address)) {
+ 		if (emulate_vsyscall(regs, address))
+ 			return;
+ 	}
+ #endif
+ 
+ 	/*
+ 	 * Kernel-mode access to the user address space should only occur
+ 	 * on well-defined single instructions listed in the exception
+ 	 * tables.  But, an erroneous kernel fault occurring outside one of
+ 	 * those areas which also holds mmap_sem might deadlock attempting
+ 	 * to validate the fault against the address space.
+ 	 *
+ 	 * Only do the expensive exception table search when we might be at
+ 	 * risk of a deadlock.  This happens if we
+ 	 * 1. Failed to acquire mmap_sem, and
+ 	 * 2. The access did not originate in userspace.
+ 	 */
+ 	if (unlikely(!down_read_trylock(&mm->mmap_sem))) {
+ 		if (!user_mode(regs) && !search_exception_tables(regs->ip)) {
+ 			/*
+ 			 * Fault from code in kernel from
+ 			 * which we do not expect faults.
+ 			 */
++>>>>>>> 6344be608c03 (x86/fault: Check user_mode(regs) when avoiding an mmap_sem deadlock)
  			bad_area_nosemaphore(regs, sw_error_code, address);
  			return;
  		}
* Unmerged path arch/x86/mm/fault.c
