netfilter: nft_exthdr: Search chunks in SCTP packets only

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Phil Sutter <phil@nwl.cc>
commit 5acc44f39458f43dac9724cefa4da29847cfe997
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5acc44f3.failed

Since user space does not generate a payload dependency, plain sctp
chunk matches cause searching in non-SCTP packets, too. Avoid this
potential mis-interpretation of packet data by checking pkt->tprot.

Fixes: 133dc203d77df ("netfilter: nft_exthdr: Support SCTP chunks")
	Signed-off-by: Phil Sutter <phil@nwl.cc>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 5acc44f39458f43dac9724cefa4da29847cfe997)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_exthdr.c
diff --cc net/netfilter/nft_exthdr.c
index 79d8531d95a7,9cf86be2cff4..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -207,6 -302,48 +207,51 @@@ static void nft_exthdr_tcp_set_eval(con
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void nft_exthdr_sctp_eval(const struct nft_expr *expr,
+ 				 struct nft_regs *regs,
+ 				 const struct nft_pktinfo *pkt)
+ {
+ 	unsigned int offset = nft_thoff(pkt) + sizeof(struct sctphdr);
+ 	struct nft_exthdr *priv = nft_expr_priv(expr);
+ 	u32 *dest = &regs->data[priv->dreg];
+ 	const struct sctp_chunkhdr *sch;
+ 	struct sctp_chunkhdr _sch;
+ 
+ 	if (pkt->tprot != IPPROTO_SCTP)
+ 		goto err;
+ 
+ 	do {
+ 		sch = skb_header_pointer(pkt->skb, offset, sizeof(_sch), &_sch);
+ 		if (!sch || !sch->length)
+ 			break;
+ 
+ 		if (sch->type == priv->type) {
+ 			if (priv->flags & NFT_EXTHDR_F_PRESENT) {
+ 				nft_reg_store8(dest, true);
+ 				return;
+ 			}
+ 			if (priv->offset + priv->len > ntohs(sch->length) ||
+ 			    offset + ntohs(sch->length) > pkt->skb->len)
+ 				break;
+ 
+ 			dest[priv->len / NFT_REG32_SIZE] = 0;
+ 			if (skb_copy_bits(pkt->skb, offset + priv->offset,
+ 					  dest, priv->len) < 0)
+ 				break;
+ 			return;
+ 		}
+ 		offset += SCTP_PAD4(ntohs(sch->length));
+ 	} while (offset < pkt->skb->len);
+ err:
+ 	if (priv->flags & NFT_EXTHDR_F_PRESENT)
+ 		nft_reg_store8(dest, false);
+ 	else
+ 		regs->verdict.code = NFT_BREAK;
+ }
+ 
++>>>>>>> 5acc44f39458 (netfilter: nft_exthdr: Search chunks in SCTP packets only)
  static const struct nla_policy nft_exthdr_policy[NFTA_EXTHDR_MAX + 1] = {
  	[NFTA_EXTHDR_DREG]		= { .type = NLA_U32 },
  	[NFTA_EXTHDR_TYPE]		= { .type = NLA_U8 },
* Unmerged path net/netfilter/nft_exthdr.c
