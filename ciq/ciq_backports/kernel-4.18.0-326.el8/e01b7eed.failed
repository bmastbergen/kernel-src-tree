xfs: Convert xfs_attr_sf macros to inline functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Carlos Maiolino <cmaiolino@redhat.com>
commit e01b7eed5d0a9b101da53701e92136c3985998af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/e01b7eed.failed

xfs_attr_sf_totsize() requires access to xfs_inode structure, so, once
xfs_attr_shortform_addname() is its only user, move it to xfs_attr.c
instead of playing with more #includes.

	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>

	Signed-off-by: Carlos Maiolino <cmaiolino@redhat.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit e01b7eed5d0a9b101da53701e92136c3985998af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr_leaf.c
diff --cc fs/xfs/libxfs/xfs_attr_leaf.c
index fb4822895d54,bb128db220ac..000000000000
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@@ -663,6 -660,51 +663,54 @@@ xfs_attr_shortform_create(xfs_da_args_
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Return -EEXIST if attr is found, or -ENOATTR if not
+  * args:  args containing attribute name and namelen
+  * sfep:  If not null, pointer will be set to the last attr entry found on
+ 	  -EEXIST.  On -ENOATTR pointer is left at the last entry in the list
+  * basep: If not null, pointer is set to the byte offset of the entry in the
+  *	  list on -EEXIST.  On -ENOATTR, pointer is left at the byte offset of
+  *	  the last entry in the list
+  */
+ int
+ xfs_attr_sf_findname(
+ 	struct xfs_da_args	 *args,
+ 	struct xfs_attr_sf_entry **sfep,
+ 	unsigned int		 *basep)
+ {
+ 	struct xfs_attr_shortform *sf;
+ 	struct xfs_attr_sf_entry *sfe;
+ 	unsigned int		base = sizeof(struct xfs_attr_sf_hdr);
+ 	int			size = 0;
+ 	int			end;
+ 	int			i;
+ 
+ 	sf = (struct xfs_attr_shortform *)args->dp->i_afp->if_u1.if_data;
+ 	sfe = &sf->list[0];
+ 	end = sf->hdr.count;
+ 	for (i = 0; i < end; sfe = xfs_attr_sf_nextentry(sfe),
+ 			     base += size, i++) {
+ 		size = xfs_attr_sf_entsize(sfe);
+ 		if (!xfs_attr_match(args, sfe->namelen, sfe->nameval,
+ 				    sfe->flags))
+ 			continue;
+ 		break;
+ 	}
+ 
+ 	if (sfep != NULL)
+ 		*sfep = sfe;
+ 
+ 	if (basep != NULL)
+ 		*basep = base;
+ 
+ 	if (i == end)
+ 		return -ENOATTR;
+ 	return -EEXIST;
+ }
+ 
+ /*
++>>>>>>> e01b7eed5d0a (xfs: Convert xfs_attr_sf macros to inline functions)
   * Add a name/value pair to the shortform attribute list.
   * Overflow from the inode has already been checked for.
   */
@@@ -684,17 -728,14 +732,17 @@@ xfs_attr_shortform_add(xfs_da_args_t *a
  
  	ifp = dp->i_afp;
  	ASSERT(ifp->if_flags & XFS_IFINLINE);
 -	sf = (struct xfs_attr_shortform *)ifp->if_u1.if_data;
 -	if (xfs_attr_sf_findname(args, &sfe, NULL) == -EEXIST)
 -		ASSERT(0);
 +	sf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;
 +	sfe = &sf->list[0];
 +	for (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {
 +		ASSERT(!xfs_attr_match(args, sfe->namelen, sfe->nameval,
 +			sfe->flags));
 +	}
  
  	offset = (char *)sfe - (char *)sf;
- 	size = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);
+ 	size = xfs_attr_sf_entsize_byname(args->namelen, args->valuelen);
  	xfs_idata_realloc(dp, size, XFS_ATTR_FORK);
 -	sf = (struct xfs_attr_shortform *)ifp->if_u1.if_data;
 +	sf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;
  	sfe = (struct xfs_attr_sf_entry *)((char *)sf + offset);
  
  	sfe->namelen = args->namelen;
@@@ -744,19 -787,12 +792,28 @@@ xfs_attr_shortform_remove(xfs_da_args_
  
  	dp = args->dp;
  	mp = dp->i_mount;
++<<<<<<< HEAD
 +	base = sizeof(xfs_attr_sf_hdr_t);
 +	sf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;
 +	sfe = &sf->list[0];
 +	end = sf->hdr.count;
 +	for (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),
 +					base += size, i++) {
 +		size = XFS_ATTR_SF_ENTSIZE(sfe);
 +		if (xfs_attr_match(args, sfe->namelen, sfe->nameval,
 +				sfe->flags))
 +			break;
 +	}
 +	if (i == end)
 +		return -ENOATTR;
++=======
+ 	sf = (struct xfs_attr_shortform *)dp->i_afp->if_u1.if_data;
+ 
+ 	error = xfs_attr_sf_findname(args, &sfe, &base);
+ 	if (error != -EEXIST)
+ 		return error;
+ 	size = xfs_attr_sf_entsize(sfe);
++>>>>>>> e01b7eed5d0a (xfs: Convert xfs_attr_sf macros to inline functions)
  
  	/*
  	 * Fix up the attribute fork data, covering the hole
@@@ -810,10 -846,10 +867,10 @@@ xfs_attr_shortform_lookup(xfs_da_args_
  
  	ifp = args->dp->i_afp;
  	ASSERT(ifp->if_flags & XFS_IFINLINE);
 -	sf = (struct xfs_attr_shortform *)ifp->if_u1.if_data;
 +	sf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;
  	sfe = &sf->list[0];
  	for (i = 0; i < sf->hdr.count;
- 				sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {
+ 				sfe = xfs_attr_sf_nextentry(sfe), i++) {
  		if (xfs_attr_match(args, sfe->namelen, sfe->nameval,
  				sfe->flags))
  			return -EEXIST;
@@@ -837,10 -873,10 +894,10 @@@ xfs_attr_shortform_getvalue
  	int			i;
  
  	ASSERT(args->dp->i_afp->if_flags == XFS_IFINLINE);
 -	sf = (struct xfs_attr_shortform *)args->dp->i_afp->if_u1.if_data;
 +	sf = (xfs_attr_shortform_t *)args->dp->i_afp->if_u1.if_data;
  	sfe = &sf->list[0];
  	for (i = 0; i < sf->hdr.count;
- 				sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {
+ 				sfe = xfs_attr_sf_nextentry(sfe), i++) {
  		if (xfs_attr_match(args, sfe->namelen, sfe->nameval,
  				sfe->flags))
  			return xfs_attr_copy_value(args,
diff --git a/fs/xfs/libxfs/xfs_attr.c b/fs/xfs/libxfs/xfs_attr.c
index 9cb14a5eed33..9acf7da74d6d 100644
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@ -329,7 +329,7 @@ xfs_attr_set(
 		 */
 		if (XFS_IFORK_Q(dp) == 0) {
 			int sf_size = sizeof(struct xfs_attr_sf_hdr) +
-				XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen,
+				xfs_attr_sf_entsize_byname(args->namelen,
 						args->valuelen);
 
 			error = xfs_bmap_add_attrfork(dp, sf_size, rsvd);
@@ -424,6 +424,14 @@ xfs_attr_set(
  * External routines when attribute list is inside the inode
  *========================================================================*/
 
+static inline int xfs_attr_sf_totsize(struct xfs_inode *dp)
+{
+	struct xfs_attr_shortform *sf;
+
+	sf = (struct xfs_attr_shortform *)dp->i_afp->if_u1.if_data;
+	return be16_to_cpu(sf->hdr.totsize);
+}
+
 /*
  * Add a name to the shortform attribute list structure
  * This is the external routine.
@@ -456,8 +464,8 @@ xfs_attr_shortform_addname(xfs_da_args_t *args)
 	    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)
 		return -ENOSPC;
 
-	newsize = XFS_ATTR_SF_TOTSIZE(args->dp);
-	newsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);
+	newsize = xfs_attr_sf_totsize(args->dp);
+	newsize += xfs_attr_sf_entsize_byname(args->namelen, args->valuelen);
 
 	forkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);
 	if (!forkoff)
* Unmerged path fs/xfs/libxfs/xfs_attr_leaf.c
diff --git a/fs/xfs/libxfs/xfs_attr_sf.h b/fs/xfs/libxfs/xfs_attr_sf.h
index 29934103ce55..37578b369d9b 100644
--- a/fs/xfs/libxfs/xfs_attr_sf.h
+++ b/fs/xfs/libxfs/xfs_attr_sf.h
@@ -26,18 +26,26 @@ typedef struct xfs_attr_sf_sort {
 	unsigned char	*name;		/* name value, pointer into buffer */
 } xfs_attr_sf_sort_t;
 
-#define XFS_ATTR_SF_ENTSIZE_BYNAME(nlen,vlen)	/* space name/value uses */ \
-	((sizeof(struct xfs_attr_sf_entry) + (nlen) + (vlen)))
 #define XFS_ATTR_SF_ENTSIZE_MAX			/* max space for name&value */ \
 	((1 << (NBBY*(int)sizeof(uint8_t))) - 1)
-#define XFS_ATTR_SF_ENTSIZE(sfep)		/* space an entry uses */ \
-	((int)sizeof(struct xfs_attr_sf_entry) + \
-		(sfep)->namelen+(sfep)->valuelen)
-#define XFS_ATTR_SF_NEXTENTRY(sfep)		/* next entry in struct */ \
-	((struct xfs_attr_sf_entry *)((char *)(sfep) + \
-		XFS_ATTR_SF_ENTSIZE(sfep)))
-#define XFS_ATTR_SF_TOTSIZE(dp)			/* total space in use */ \
-	(be16_to_cpu(((struct xfs_attr_shortform *)	\
-		((dp)->i_afp->if_u1.if_data))->hdr.totsize))
+
+/* space name/value uses */
+static inline int xfs_attr_sf_entsize_byname(uint8_t nlen, uint8_t vlen)
+{
+	return sizeof(struct xfs_attr_sf_entry) + nlen + vlen;
+}
+
+/* space an entry uses */
+static inline int xfs_attr_sf_entsize(struct xfs_attr_sf_entry *sfep)
+{
+	return struct_size(sfep, nameval, sfep->namelen + sfep->valuelen);
+}
+
+/* next entry in struct */
+static inline struct xfs_attr_sf_entry *
+xfs_attr_sf_nextentry(struct xfs_attr_sf_entry *sfep)
+{
+	return (void *)sfep + xfs_attr_sf_entsize(sfep);
+}
 
 #endif	/* __XFS_ATTR_SF_H__ */
diff --git a/fs/xfs/xfs_attr_list.c b/fs/xfs/xfs_attr_list.c
index c231c085c4ba..291da7fa894d 100644
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@ -96,7 +96,7 @@ xfs_attr_shortform_list(
 			 */
 			if (context->seen_enough)
 				break;
-			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
+			sfe = xfs_attr_sf_nextentry(sfe);
 		}
 		trace_xfs_attr_list_sf_all(context);
 		return 0;
@@ -136,7 +136,7 @@ xfs_attr_shortform_list(
 		/* These are bytes, and both on-disk, don't endian-flip */
 		sbp->valuelen = sfe->valuelen;
 		sbp->flags = sfe->flags;
-		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
+		sfe = xfs_attr_sf_nextentry(sfe);
 		sbp++;
 		nsbuf++;
 	}
