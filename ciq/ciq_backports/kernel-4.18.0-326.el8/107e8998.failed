mm/hmm: define the pre-processor related parts of hmm.h even if disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 107e899874e95dcddc779142942bf285eba38bc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/107e8998.failed

Only the function calls are stubbed out with static inlines that always
fail. This is the standard way to write a header for an optional component
and makes it easier for drivers that only optionally need HMM_MIRROR.

Link: https://lore.kernel.org/r/20191112202231.3856-5-jgg@ziepe.ca
	Reviewed-by: Jérôme Glisse <jglisse@redhat.com>
	Tested-by: Ralph Campbell <rcampbell@nvidia.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 107e899874e95dcddc779142942bf285eba38bc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hmm.h
diff --cc include/linux/hmm.h
index 6a8157d67186,cb69bf10dc78..000000000000
--- a/include/linux/hmm.h
+++ b/include/linux/hmm.h
@@@ -71,8 -62,6 +71,11 @@@
  #include <linux/kconfig.h>
  #include <asm/pgtable.h>
  
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_HMM)
 +
++=======
++>>>>>>> 107e899874e9 (mm/hmm: define the pre-processor related parts of hmm.h even if disabled)
  #include <linux/device.h>
  #include <linux/migrate.h>
  #include <linux/memremap.h>
@@@ -477,14 -387,11 +489,20 @@@ void hmm_mirror_unregister(struct hmm_m
  /*
   * Please see Documentation/vm/hmm.rst for how to use the range API.
   */
 -int hmm_range_register(struct hmm_range *range, struct hmm_mirror *mirror);
 +int hmm_range_register(struct hmm_range *range,
 +		       struct hmm_mirror *mirror,
 +		       unsigned long start,
 +		       unsigned long end,
 +		       unsigned page_shift);
  void hmm_range_unregister(struct hmm_range *range);
++<<<<<<< HEAD
 +long hmm_range_snapshot(struct hmm_range *range);
 +long hmm_range_fault(struct hmm_range *range, bool block);
++=======
+ 
+ long hmm_range_fault(struct hmm_range *range, unsigned int flags);
+ 
++>>>>>>> 107e899874e9 (mm/hmm: define the pre-processor related parts of hmm.h even if disabled)
  long hmm_range_dma_map(struct hmm_range *range,
  		       struct device *device,
  		       dma_addr_t *daddrs,
@@@ -503,15 -448,4 +559,18 @@@ static inline long hmm_range_dma_unmap(
   */
  #define HMM_RANGE_DEFAULT_TIMEOUT 1000
  
++<<<<<<< HEAD
 +#endif /* IS_ENABLED(CONFIG_HMM_MIRROR) */
 +
 +/* Below are for HMM internal use only! Not to be used by device driver! */
 +static inline void hmm_mm_init(struct mm_struct *mm)
 +{
 +	mm->hmm = NULL;
 +}
 +#else /* IS_ENABLED(CONFIG_HMM) */
 +static inline void hmm_mm_init(struct mm_struct *mm) {}
 +#endif /* IS_ENABLED(CONFIG_HMM) */
 +
++=======
++>>>>>>> 107e899874e9 (mm/hmm: define the pre-processor related parts of hmm.h even if disabled)
  #endif /* LINUX_HMM_H */
* Unmerged path include/linux/hmm.h
diff --git a/kernel/fork.c b/kernel/fork.c
index 49643d403a07..1b938e25e7ff 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -37,7 +37,6 @@
 #include <linux/binfmts.h>
 #include <linux/mman.h>
 #include <linux/mmu_notifier.h>
-#include <linux/hmm.h>
 #include <linux/fs.h>
 #include <linux/mm.h>
 #include <linux/vmacache.h>
