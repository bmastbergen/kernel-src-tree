powerpc/eeh_cache: Add a way to dump the EEH address cache

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Oliver O'Halloran <oohall@gmail.com>
commit 5ca85ae6318df34874999e3fd1760a88208e2a8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5ca85ae6.failed

Adds a debugfs file that can be read to view the contents of the EEH
address cache. This is pretty similar to the existing
eeh_addr_cache_print() function, but that function is intended to debug
issues inside of the kernel since it's #ifdef`ed out by default, and writes
into the kernel log.

	Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
	Reviewed-by: Sam Bobroff <sbobroff@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 5ca85ae6318df34874999e3fd1760a88208e2a8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh.c
#	arch/powerpc/kernel/eeh_cache.c
diff --cc arch/powerpc/kernel/eeh.c
index 530283a6e685,8d36c50e906f..000000000000
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@@ -1981,15 -1841,9 +1981,21 @@@ static int __init eeh_init_proc(void
  		debugfs_create_file_unsafe("eeh_enable", 0600,
  					   powerpc_debugfs_root, NULL,
  					   &eeh_enable_dbgfs_ops);
++<<<<<<< HEAD
 +		debugfs_create_file_unsafe("eeh_max_freezes", 0600,
 +					   powerpc_debugfs_root, NULL,
 +					   &eeh_freeze_dbgfs_ops);
 +		debugfs_create_file_unsafe("eeh_dev_check", 0600,
 +				powerpc_debugfs_root, NULL,
 +				&eeh_dev_check_fops);
 +		debugfs_create_file_unsafe("eeh_dev_break", 0600,
 +				powerpc_debugfs_root, NULL,
 +				&eeh_dev_break_fops);
++=======
+ 		debugfs_create_u32("eeh_max_freezes", 0600,
+ 				powerpc_debugfs_root, &eeh_max_freezes);
+ 		eeh_cache_debugfs_init();
++>>>>>>> 5ca85ae6318d (powerpc/eeh_cache: Add a way to dump the EEH address cache)
  #endif
  	}
  
diff --cc arch/powerpc/kernel/eeh_cache.c
index 2fef28c07e0b,5c5697cced41..000000000000
--- a/arch/powerpc/kernel/eeh_cache.c
+++ b/arch/powerpc/kernel/eeh_cache.c
@@@ -267,12 -268,61 +268,57 @@@ void eeh_addr_cache_rmv_dev(struct pci_
  }
  
  /**
 - * eeh_addr_cache_build - Build a cache of I/O addresses
 + * eeh_addr_cache_init - Initialize a cache of I/O addresses
   *
 - * Build a cache of pci i/o addresses.  This cache will be used to
 + * Initialize a cache of pci i/o addresses.  This cache will be used to
   * find the pci device that corresponds to a given address.
 - * This routine scans all pci busses to build the cache.
 - * Must be run late in boot process, after the pci controllers
 - * have been scanned for devices (after all device resources are known).
   */
 -void eeh_addr_cache_build(void)
 +void eeh_addr_cache_init(void)
  {
 -	struct pci_dn *pdn;
 -	struct eeh_dev *edev;
 -	struct pci_dev *dev = NULL;
 -
  	spin_lock_init(&pci_io_addr_cache_root.piar_lock);
++<<<<<<< HEAD
++=======
+ 
+ 	for_each_pci_dev(dev) {
+ 		pdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);
+ 		if (!pdn)
+ 			continue;
+ 
+ 		edev = pdn_to_eeh_dev(pdn);
+ 		if (!edev)
+ 			continue;
+ 
+ 		dev->dev.archdata.edev = edev;
+ 		edev->pdev = dev;
+ 
+ 		eeh_addr_cache_insert_dev(dev);
+ 		eeh_sysfs_add_device(dev);
+ 	}
+ }
+ 
+ static int eeh_addr_cache_show(struct seq_file *s, void *v)
+ {
+ 	struct pci_io_addr_range *piar;
+ 	struct rb_node *n;
+ 
+ 	spin_lock(&pci_io_addr_cache_root.piar_lock);
+ 	for (n = rb_first(&pci_io_addr_cache_root.rb_root); n; n = rb_next(n)) {
+ 		piar = rb_entry(n, struct pci_io_addr_range, rb_node);
+ 
+ 		seq_printf(s, "%s addr range [%pap-%pap]: %s\n",
+ 		       (piar->flags & IORESOURCE_IO) ? "i/o" : "mem",
+ 		       &piar->addr_lo, &piar->addr_hi, pci_name(piar->pcidev));
+ 	}
+ 	spin_unlock(&pci_io_addr_cache_root.piar_lock);
+ 
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(eeh_addr_cache);
+ 
+ void eeh_cache_debugfs_init(void)
+ {
+ 	debugfs_create_file_unsafe("eeh_address_cache", 0400,
+ 			powerpc_debugfs_root, NULL,
+ 			&eeh_addr_cache_fops);
++>>>>>>> 5ca85ae6318d (powerpc/eeh_cache: Add a way to dump the EEH address cache)
  }
diff --git a/arch/powerpc/include/asm/eeh.h b/arch/powerpc/include/asm/eeh.h
index 761a86991ffd..e4281062c2fe 100644
--- a/arch/powerpc/include/asm/eeh.h
+++ b/arch/powerpc/include/asm/eeh.h
@@ -481,6 +481,9 @@ static inline void eeh_readsl(const volatile void __iomem *addr, void * buf,
 		eeh_check_failure(addr);
 }
 
+
+void eeh_cache_debugfs_init(void);
+
 #endif /* CONFIG_PPC64 */
 #endif /* __KERNEL__ */
 #endif /* _POWERPC_EEH_H */
* Unmerged path arch/powerpc/kernel/eeh.c
* Unmerged path arch/powerpc/kernel/eeh_cache.c
