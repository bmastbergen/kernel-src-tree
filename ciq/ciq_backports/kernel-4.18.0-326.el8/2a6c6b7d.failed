perf/core: Add PERF_SAMPLE_WEIGHT_STRUCT

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Kan Liang <kan.liang@linux.intel.com>
commit 2a6c6b7d7ad346f0679d0963cb19b3f0ea7ef32c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/2a6c6b7d.failed

Current PERF_SAMPLE_WEIGHT sample type is very useful to expresses the
cost of an action represented by the sample. This allows the profiler
to scale the samples to be more informative to the programmer. It could
also help to locate a hotspot, e.g., when profiling by memory latencies,
the expensive load appear higher up in the histograms. But current
PERF_SAMPLE_WEIGHT sample type is solely determined by one factor. This
could be a problem, if users want two or more factors to contribute to
the weight. For example, Golden Cove core PMU can provide both the
instruction latency and the cache Latency information as factors for the
memory profiling.

For current X86 platforms, although meminfo::latency is defined as a
u64, only the lower 32 bits include the valid data in practice (No
memory access could last than 4G cycles). The higher 32 bits can be used
to store new factors.

Add a new sample type, PERF_SAMPLE_WEIGHT_STRUCT, to indicate the new
sample weight structure. It shares the same space as the
PERF_SAMPLE_WEIGHT sample type.

Users can apply either the PERF_SAMPLE_WEIGHT sample type or the
PERF_SAMPLE_WEIGHT_STRUCT sample type to retrieve the sample weight, but
they cannot apply both sample types simultaneously.

Currently, only X86 and PowerPC use the PERF_SAMPLE_WEIGHT sample type.
- For PowerPC, there is nothing changed for the PERF_SAMPLE_WEIGHT
  sample type. There is no effect for the new PERF_SAMPLE_WEIGHT_STRUCT
  sample type. PowerPC can re-struct the weight field similarly later.
- For X86, the same value will be dumped for the PERF_SAMPLE_WEIGHT
  sample type or the PERF_SAMPLE_WEIGHT_STRUCT sample type for now.
  The following patches will apply the new factors for the
  PERF_SAMPLE_WEIGHT_STRUCT sample type.

The field in the union perf_sample_weight should be shared among
different architectures. A generic name is required, but it's hard to
abstract a name that applies to all architectures. For example, on X86,
the fields are to store all kinds of latency. While on PowerPC, it
stores MMCRA[TECX/TECM], which should not be latency. So a general name
prefix 'var$NUM' is used here.

	Suggested-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/1611873611-156687-2-git-send-email-kan.liang@linux.intel.com
(cherry picked from commit 2a6c6b7d7ad346f0679d0963cb19b3f0ea7ef32c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/intel/ds.c
#	include/uapi/linux/perf_event.h
diff --cc arch/x86/events/intel/ds.c
index 0c07c71a8cbf,2f54b1fbb895..000000000000
--- a/arch/x86/events/intel/ds.c
+++ b/arch/x86/events/intel/ds.c
@@@ -960,8 -960,10 +960,15 @@@ static void adaptive_pebs_record_size_u
  }
  
  #define PERF_PEBS_MEMINFO_TYPE	(PERF_SAMPLE_ADDR | PERF_SAMPLE_DATA_SRC |   \
++<<<<<<< HEAD
 +				PERF_SAMPLE_PHYS_ADDR | PERF_SAMPLE_WEIGHT | \
 +				PERF_SAMPLE_TRANSACTION)
++=======
+ 				PERF_SAMPLE_PHYS_ADDR |			     \
+ 				PERF_SAMPLE_WEIGHT_TYPE |		     \
+ 				PERF_SAMPLE_TRANSACTION |		     \
+ 				PERF_SAMPLE_DATA_PAGE_SIZE)
++>>>>>>> 2a6c6b7d7ad3 (perf/core: Add PERF_SAMPLE_WEIGHT_STRUCT)
  
  static u64 pebs_update_adaptive_cfg(struct perf_event *event)
  {
diff --cc include/uapi/linux/perf_event.h
index 72f783ce7bd8,b2cc246ec119..000000000000
--- a/include/uapi/linux/perf_event.h
+++ b/include/uapi/linux/perf_event.h
@@@ -143,8 -143,11 +143,16 @@@ enum perf_event_sample_format 
  	PERF_SAMPLE_PHYS_ADDR			= 1U << 19,
  	PERF_SAMPLE_AUX				= 1U << 20,
  	PERF_SAMPLE_CGROUP			= 1U << 21,
++<<<<<<< HEAD
 +
 +	PERF_SAMPLE_MAX = 1U << 22,		/* non-ABI */
++=======
+ 	PERF_SAMPLE_DATA_PAGE_SIZE		= 1U << 22,
+ 	PERF_SAMPLE_CODE_PAGE_SIZE		= 1U << 23,
+ 	PERF_SAMPLE_WEIGHT_STRUCT		= 1U << 24,
+ 
+ 	PERF_SAMPLE_MAX = 1U << 25,		/* non-ABI */
++>>>>>>> 2a6c6b7d7ad3 (perf/core: Add PERF_SAMPLE_WEIGHT_STRUCT)
  
  	__PERF_SAMPLE_CALLCHAIN_EARLY		= 1ULL << 63, /* non-ABI; internal use */
  };
diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c
index 94a88f336409..9f6372883798 100644
--- a/arch/powerpc/perf/core-book3s.c
+++ b/arch/powerpc/perf/core-book3s.c
@@ -2221,7 +2221,7 @@ static void record_and_restart(struct perf_event *event, unsigned long val,
 
 		if (event->attr.sample_type & PERF_SAMPLE_WEIGHT &&
 						ppmu->get_mem_weight)
-			ppmu->get_mem_weight(&data.weight);
+			ppmu->get_mem_weight(&data.weight.full);
 
 		if (perf_event_overflow(event, &data, regs))
 			power_pmu_stop(event, 0);
* Unmerged path arch/x86/events/intel/ds.c
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index d93e3b10efdc..69bb1066c21e 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -1022,7 +1022,7 @@ struct perf_sample_data {
 	struct perf_raw_record		*raw;
 	struct perf_branch_stack	*br_stack;
 	u64				period;
-	u64				weight;
+	union perf_sample_weight	weight;
 	u64				txn;
 	union  perf_mem_data_src	data_src;
 
@@ -1070,7 +1070,7 @@ static inline void perf_sample_data_init(struct perf_sample_data *data,
 	data->raw  = NULL;
 	data->br_stack = NULL;
 	data->period = period;
-	data->weight = 0;
+	data->weight.full = 0;
 	data->data_src.val = PERF_MEM_NA;
 	data->txn = 0;
 }
* Unmerged path include/uapi/linux/perf_event.h
diff --git a/kernel/events/core.c b/kernel/events/core.c
index dfaf9a30d869..0684c8df5bfe 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -1880,8 +1880,8 @@ static void __perf_event_header_size(struct perf_event *event, u64 sample_type)
 	if (sample_type & PERF_SAMPLE_PERIOD)
 		size += sizeof(data->period);
 
-	if (sample_type & PERF_SAMPLE_WEIGHT)
-		size += sizeof(data->weight);
+	if (sample_type & PERF_SAMPLE_WEIGHT_TYPE)
+		size += sizeof(data->weight.full);
 
 	if (sample_type & PERF_SAMPLE_READ)
 		size += event->read_size;
@@ -6909,8 +6909,8 @@ void perf_output_sample(struct perf_output_handle *handle,
 					  data->regs_user.regs);
 	}
 
-	if (sample_type & PERF_SAMPLE_WEIGHT)
-		perf_output_put(handle, data->weight);
+	if (sample_type & PERF_SAMPLE_WEIGHT_TYPE)
+		perf_output_put(handle, data->weight.full);
 
 	if (sample_type & PERF_SAMPLE_DATA_SRC)
 		perf_output_put(handle, data->data_src.val);
@@ -11464,6 +11464,9 @@ static int perf_copy_attr(struct perf_event_attr __user *uattr,
 	if (attr->sample_type & PERF_SAMPLE_CGROUP)
 		return -EINVAL;
 #endif
+	if ((attr->sample_type & PERF_SAMPLE_WEIGHT) &&
+	    (attr->sample_type & PERF_SAMPLE_WEIGHT_STRUCT))
+		return -EINVAL;
 
 out:
 	return ret;
