s390/zcrypt: remove set_fs() invocation in zcrypt device driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 52f72feba9dbe4fac848ae0d90bc0b85b17f91bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/52f72feb.failed

This patch reworks the zcrypt device driver so that the set_fs()
invocation is not needed any more. Instead there is a new flag bool
userspace passed through all the functions which tells if the pointer
arguments are userspace or kernelspace. Together with the two new
inline functions z_copy_from_user() and z_copy_to_user() which either
invoke copy_from_user (userspace is true) or memcpy (userspace is
false) the zcrypt dd and the AP bus now has no requirement for
the set_fs() functionality any more.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 52f72feba9dbe4fac848ae0d90bc0b85b17f91bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/zcrypt_api.c
#	drivers/s390/crypto/zcrypt_api.h
#	drivers/s390/crypto/zcrypt_msgtype6.c
diff --cc drivers/s390/crypto/zcrypt_api.c
index e44116e47ecd,a711728c3857..000000000000
--- a/drivers/s390/crypto/zcrypt_api.c
+++ b/drivers/s390/crypto/zcrypt_api.c
@@@ -847,8 -797,7 +847,12 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +static long _zcrypt_send_cprb(struct ap_perms *perms,
 +			      struct zcrypt_track *tr,
++=======
+ static long _zcrypt_send_cprb(bool userspace, struct ap_perms *perms,
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  			      struct ica_xcRB *xcRB)
  {
  	struct zcrypt_card *zc, *pref_zc;
@@@ -864,18 -813,7 +868,22 @@@
  
  	xcRB->status = 0;
  	ap_init_message(&ap_msg);
++<<<<<<< HEAD
 +
 +#ifdef CONFIG_ZCRYPT_DEBUG
 +	if (tr && tr->fi.cmd)
 +		ap_msg.fi.cmd = tr->fi.cmd;
 +	if (tr && tr->fi.action == AP_FI_ACTION_CCA_AGENT_FF) {
 +		ZCRYPT_DBF_WARN("%s fi cmd 0x%04x: forcing invalid agent_ID 'FF'\n",
 +				__func__, tr->fi.cmd);
 +		xcRB->agent_ID = 0x4646;
 +	}
 +#endif
 +
 +	rc = get_cprb_fc(xcRB, &ap_msg, &func_code, &domain);
++=======
+ 	rc = get_cprb_fc(userspace, xcRB, &ap_msg, &func_code, &domain);
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  	if (rc)
  		goto out;
  
@@@ -950,18 -878,10 +958,22 @@@
  	if (*domain == AUTOSEL_DOM)
  		*domain = AP_QID_QUEUE(qid);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_ZCRYPT_DEBUG
 +	if (tr && tr->fi.action == AP_FI_ACTION_CCA_DOM_INVAL) {
 +		ZCRYPT_DBF_WARN("%s fi cmd 0x%04x: forcing invalid domain\n",
 +				__func__, tr->fi.cmd);
 +		*domain = 99;
 +	}
 +#endif
 +
 +	rc = pref_zq->ops->send_cprb(pref_zq, xcRB, &ap_msg);
++=======
+ 	rc = pref_zq->ops->send_cprb(userspace, pref_zq, xcRB, &ap_msg);
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  
  	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, mod, weight);
 +	zcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);
  	spin_unlock(&zcrypt_list_lock);
  
  out:
@@@ -977,7 -893,7 +989,11 @@@
  
  long zcrypt_send_cprb(struct ica_xcRB *xcRB)
  {
++<<<<<<< HEAD
 +	return _zcrypt_send_cprb(&ap_perms, NULL, xcRB);
++=======
+ 	return _zcrypt_send_cprb(false, &ap_perms, xcRB);
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  }
  EXPORT_SYMBOL(zcrypt_send_cprb);
  
@@@ -1008,8 -924,7 +1024,12 @@@ static bool is_desired_ep11_queue(unsig
  	return false;
  }
  
++<<<<<<< HEAD
 +static long _zcrypt_send_ep11_cprb(struct ap_perms *perms,
 +				   struct zcrypt_track *tr,
++=======
+ static long _zcrypt_send_ep11_cprb(bool userspace, struct ap_perms *perms,
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  				   struct ep11_urb *xcrb)
  {
  	struct zcrypt_card *zc, *pref_zc;
@@@ -1115,10 -1015,10 +1135,10 @@@
  	}
  
  	qid = pref_zq->queue->qid;
- 	rc = pref_zq->ops->send_ep11_cprb(pref_zq, xcrb, &ap_msg);
+ 	rc = pref_zq->ops->send_ep11_cprb(userspace, pref_zq, xcrb, &ap_msg);
  
  	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, mod, weight);
 +	zcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);
  	spin_unlock(&zcrypt_list_lock);
  
  out_free:
@@@ -1136,7 -1032,7 +1156,11 @@@ out
  
  long zcrypt_send_ep11_cprb(struct ep11_urb *xcrb)
  {
++<<<<<<< HEAD
 +	return _zcrypt_send_ep11_cprb(&ap_perms, NULL, xcrb);
++=======
+ 	return _zcrypt_send_ep11_cprb(false, &ap_perms, xcrb);
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  }
  EXPORT_SYMBOL(zcrypt_send_ep11_cprb);
  
@@@ -1493,38 -1348,18 +1517,48 @@@ static int zsecsendcprb_ioctl(struct ap
  {
  	int rc;
  	struct ica_xcRB xcRB;
 +	struct zcrypt_track tr;
  	struct ica_xcRB __user *uxcRB = (void __user *) arg;
  
 +	memset(&tr, 0, sizeof(tr));
  	if (copy_from_user(&xcRB, uxcRB, sizeof(xcRB)))
  		return -EFAULT;
 +
 +#ifdef CONFIG_ZCRYPT_DEBUG
 +	if (xcRB.status & (1U << 31)) {
 +		if (!capable(CAP_SYS_ADMIN))
 +			return -EPERM;
 +		tr.fi.cmd = (u16)(xcRB.status >> 16);
 +	}
 +	xcRB.status &= 0x0000FFFF;
 +#endif
 +
  	do {
++<<<<<<< HEAD
 +		rc = _zcrypt_send_cprb(perms, &tr, &xcRB);
 +		if (rc == -EAGAIN)
 +			tr.again_counter++;
 +#ifdef CONFIG_ZCRYPT_DEBUG
 +		if (rc == -EAGAIN && (tr.fi.flags & AP_FI_FLAG_NO_RETRY))
 +			break;
 +#endif
 +	} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);
 +	/* on failure: retry once again after a requested rescan */
 +	if ((rc == -ENODEV) && (zcrypt_process_rescan()))
 +		do {
 +			rc = _zcrypt_send_cprb(perms, &tr, &xcRB);
 +			if (rc == -EAGAIN)
 +				tr.again_counter++;
 +		} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);
++=======
+ 		rc = _zcrypt_send_cprb(true, perms, &xcRB);
+ 	} while (rc == -EAGAIN);
+ 	/* on failure: retry once again after a requested rescan */
+ 	if ((rc == -ENODEV) && (zcrypt_process_rescan()))
+ 		do {
+ 			rc = _zcrypt_send_cprb(true, perms, &xcRB);
+ 		} while (rc == -EAGAIN);
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  	if (rc)
  		ZCRYPT_DBF(DBF_DEBUG, "ioctl ZSENDCPRB rc=%d status=0x%x\n",
  			   rc, xcRB.status);
@@@ -1537,38 -1372,18 +1571,48 @@@ static int zsendep11cprb_ioctl(struct a
  {
  	int rc;
  	struct ep11_urb xcrb;
 +	struct zcrypt_track tr;
  	struct ep11_urb __user *uxcrb = (void __user *)arg;
  
 +	memset(&tr, 0, sizeof(tr));
  	if (copy_from_user(&xcrb, uxcrb, sizeof(xcrb)))
  		return -EFAULT;
 +
 +#ifdef CONFIG_ZCRYPT_DEBUG
 +	if (xcrb.req_len & (1ULL << 63)) {
 +		if (!capable(CAP_SYS_ADMIN))
 +			return -EPERM;
 +		tr.fi.cmd = (u16)(xcrb.req_len >> 48);
 +	}
 +	xcrb.req_len &= 0x0000FFFFFFFFFFFFULL;
 +#endif
 +
  	do {
++<<<<<<< HEAD
 +		rc = _zcrypt_send_ep11_cprb(perms, &tr, &xcrb);
 +		if (rc == -EAGAIN)
 +			tr.again_counter++;
 +#ifdef CONFIG_ZCRYPT_DEBUG
 +		if (rc == -EAGAIN && (tr.fi.flags & AP_FI_FLAG_NO_RETRY))
 +			break;
 +#endif
 +	} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);
 +	/* on failure: retry once again after a requested rescan */
 +	if ((rc == -ENODEV) && (zcrypt_process_rescan()))
 +		do {
 +			rc = _zcrypt_send_ep11_cprb(perms, &tr, &xcrb);
 +			if (rc == -EAGAIN)
 +				tr.again_counter++;
 +		} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);
++=======
+ 		rc = _zcrypt_send_ep11_cprb(true, perms, &xcrb);
+ 	} while (rc == -EAGAIN);
+ 	/* on failure: retry once again after a requested rescan */
+ 	if ((rc == -ENODEV) && (zcrypt_process_rescan()))
+ 		do {
+ 			rc = _zcrypt_send_ep11_cprb(true, perms, &xcrb);
+ 		} while (rc == -EAGAIN);
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  	if (rc)
  		ZCRYPT_DBF(DBF_DEBUG, "ioctl ZSENDEP11CPRB rc=%d\n", rc);
  	if (copy_to_user(uxcrb, &xcrb, sizeof(xcrb)))
@@@ -1855,17 -1655,13 +1899,27 @@@ static long trans_xcRB32(struct ap_perm
  	xcRB64.priority_window = xcRB32.priority_window;
  	xcRB64.status = xcRB32.status;
  	do {
++<<<<<<< HEAD
 +		rc = _zcrypt_send_cprb(perms, &tr, &xcRB64);
 +		if (rc == -EAGAIN)
 +			tr.again_counter++;
 +	} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);
 +	/* on failure: retry once again after a requested rescan */
 +	if ((rc == -ENODEV) && (zcrypt_process_rescan()))
 +		do {
 +			rc = _zcrypt_send_cprb(perms, &tr, &xcRB64);
 +			if (rc == -EAGAIN)
 +				tr.again_counter++;
 +		} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);
++=======
+ 		rc = _zcrypt_send_cprb(true, perms, &xcRB64);
+ 	} while (rc == -EAGAIN);
+ 	/* on failure: retry once again after a requested rescan */
+ 	if ((rc == -ENODEV) && (zcrypt_process_rescan()))
+ 		do {
+ 			rc = _zcrypt_send_cprb(true, perms, &xcRB64);
+ 		} while (rc == -EAGAIN);
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  	xcRB32.reply_control_blk_length = xcRB64.reply_control_blk_length;
  	xcRB32.reply_data_length = xcRB64.reply_data_length;
  	xcRB32.status = xcRB64.status;
diff --cc drivers/s390/crypto/zcrypt_api.h
index 8696e9fae7b1,19ddfc38e029..000000000000
--- a/drivers/s390/crypto/zcrypt_api.h
+++ b/drivers/s390/crypto/zcrypt_api.h
@@@ -55,30 -55,13 +55,35 @@@ enum crypto_ops 
  
  struct zcrypt_queue;
  
 +/* struct to hold tracking information for a userspace request/response */
 +struct zcrypt_track {
 +	int again_counter;		/* retry attempts counter */
 +	int last_qid;			/* last qid used */
 +	int last_rc;			/* last return code */
 +#ifdef CONFIG_ZCRYPT_DEBUG
 +	struct ap_fi fi;		/* failure injection cmd */
 +#endif
 +};
 +
 +/* defines related to message tracking */
 +#define TRACK_AGAIN_MAX 10
 +#define TRACK_AGAIN_CARD_WEIGHT_PENALTY  1000
 +#define TRACK_AGAIN_QUEUE_WEIGHT_PENALTY 10000
 +
  struct zcrypt_ops {
 -	long (*rsa_modexpo)(struct zcrypt_queue *, struct ica_rsa_modexpo *);
 +	long (*rsa_modexpo)(struct zcrypt_queue *, struct ica_rsa_modexpo *,
 +			    struct ap_message *);
  	long (*rsa_modexpo_crt)(struct zcrypt_queue *,
++<<<<<<< HEAD
 +				struct ica_rsa_modexpo_crt *,
 +				struct ap_message *);
 +	long (*send_cprb)(struct zcrypt_queue *, struct ica_xcRB *,
++=======
+ 				struct ica_rsa_modexpo_crt *);
+ 	long (*send_cprb)(bool userspace, struct zcrypt_queue *, struct ica_xcRB *,
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  			  struct ap_message *);
- 	long (*send_ep11_cprb)(struct zcrypt_queue *, struct ep11_urb *,
+ 	long (*send_ep11_cprb)(bool userspace, struct zcrypt_queue *, struct ep11_urb *,
  			       struct ap_message *);
  	long (*rng)(struct zcrypt_queue *, char *, struct ap_message *);
  	struct list_head list;		/* zcrypt ops list. */
diff --cc drivers/s390/crypto/zcrypt_msgtype6.c
index 273be405125f,3db901883a5c..000000000000
--- a/drivers/s390/crypto/zcrypt_msgtype6.c
+++ b/drivers/s390/crypto/zcrypt_msgtype6.c
@@@ -482,15 -482,10 +482,15 @@@ static int XCRB_msg_to_type6CPRB_msgX(b
  	    || memcmp(function_code, "AU", 2) == 0)
  		ap_msg->flags |= AP_MSG_FLAG_SPECIAL;
  
 +#ifdef CONFIG_ZCRYPT_DEBUG
 +	if (ap_msg->fi.flags & AP_FI_FLAG_TOGGLE_SPECIAL)
 +		ap_msg->flags ^= AP_MSG_FLAG_SPECIAL;
 +#endif
 +
  	/* copy data block */
  	if (xcRB->request_data_length &&
- 	    copy_from_user(req_data, xcRB->request_data_address,
- 		xcRB->request_data_length))
+ 	    z_copy_from_user(userspace, req_data, xcRB->request_data_address,
+ 			     xcRB->request_data_length))
  		return -EFAULT;
  
  	return 0;
@@@ -841,8 -831,8 +841,13 @@@ static int convert_response_xcrb(bool u
  			return convert_error(zq, reply);
  		}
  		if (msg->cprbx.cprb_ver_id == 0x02)
++<<<<<<< HEAD
 +			return convert_type86_xcrb(zq, reply, xcRB);
 +		/* fall through - wrong cprb version is an unknown response */
++=======
+ 			return convert_type86_xcrb(userspace, zq, reply, xcRB);
+ 		fallthrough;	/* wrong cprb version is an unknown response */
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  	default: /* Unknown response type, this should NEVER EVER happen */
  		xcRB->status = 0x0008044DL; /* HDD_InvalidParm */
  		zq->online = 0;
@@@ -871,19 -861,19 +876,24 @@@ static int convert_response_ep11_xcrb(b
  		if (msg->hdr.reply_code)
  			return convert_error(zq, reply);
  		if (msg->cprbx.cprb_ver_id == 0x04)
++<<<<<<< HEAD
 +			return convert_type86_ep11_xcrb(zq, reply, xcRB);
 +		/* fall through - wrong cprb version is an unknown resp */
++=======
+ 			return convert_type86_ep11_xcrb(userspace, zq, reply, xcRB);
+ 		fallthrough;	/* wrong cprb version is an unknown resp */
++>>>>>>> 52f72feba9db (s390/zcrypt: remove set_fs() invocation in zcrypt device driver)
  	default: /* Unknown response type, this should NEVER EVER happen */
  		zq->online = 0;
 -		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
 +		pr_err("Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
  		       AP_QID_CARD(zq->queue->qid),
 -		       AP_QID_QUEUE(zq->queue->qid));
 -		ZCRYPT_DBF(DBF_ERR,
 -			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
 -			   AP_QID_CARD(zq->queue->qid),
 -			   AP_QID_QUEUE(zq->queue->qid),
 -			   (int) msg->hdr.type);
 -		return -EAGAIN; /* repeat the request on a different device. */
 +		       AP_QID_QUEUE(zq->queue->qid),
 +		       (int) msg->hdr.type);
 +		ZCRYPT_DBF_ERR("dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
 +			       AP_QID_CARD(zq->queue->qid),
 +			       AP_QID_QUEUE(zq->queue->qid),
 +			       (int) msg->hdr.type);
 +		return -EAGAIN;
  	}
  }
  
* Unmerged path drivers/s390/crypto/zcrypt_api.c
* Unmerged path drivers/s390/crypto/zcrypt_api.h
diff --git a/drivers/s390/crypto/zcrypt_ccamisc.c b/drivers/s390/crypto/zcrypt_ccamisc.c
index 16c844cfe5ee..76a1b010eb36 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.c
+++ b/drivers/s390/crypto/zcrypt_ccamisc.c
@@ -248,24 +248,6 @@ static inline void prep_xcrb(struct ica_xcRB *pxcrb,
 	pxcrb->reply_control_blk_addr = (void __user *) prepcblk;
 }
 
-/*
- * Helper function which calls zcrypt_send_cprb with
- * memory management segment adjusted to kernel space
- * so that the copy_from_user called within this
- * function do in fact copy from kernel space.
- */
-static inline int _zcrypt_send_cprb(struct ica_xcRB *xcrb)
-{
-	int rc;
-	mm_segment_t old_fs = get_fs();
-
-	set_fs(KERNEL_DS);
-	rc = zcrypt_send_cprb(xcrb);
-	set_fs(old_fs);
-
-	return rc;
-}
-
 /*
  * Generate (random) CCA AES DATA secure key.
  */
@@ -359,7 +341,7 @@ int cca_genseckey(u16 cardnr, u16 domain,
 	prep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);
 
 	/* forward xcrb with request CPRB and reply CPRB to zcrypt dd */
-	rc = _zcrypt_send_cprb(&xcrb);
+	rc = zcrypt_send_cprb(&xcrb);
 	if (rc) {
 		DEBUG_ERR("%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, errno %d\n",
 			  __func__, (int) cardnr, (int) domain, rc);
@@ -497,7 +479,7 @@ int cca_clr2seckey(u16 cardnr, u16 domain, u32 keybitsize,
 	prep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);
 
 	/* forward xcrb with request CPRB and reply CPRB to zcrypt dd */
-	rc = _zcrypt_send_cprb(&xcrb);
+	rc = zcrypt_send_cprb(&xcrb);
 	if (rc) {
 		DEBUG_ERR("%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\n",
 			  __func__, (int) cardnr, (int) domain, rc);
@@ -624,7 +606,7 @@ int cca_sec2protkey(u16 cardnr, u16 domain,
 	prep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);
 
 	/* forward xcrb with request CPRB and reply CPRB to zcrypt dd */
-	rc = _zcrypt_send_cprb(&xcrb);
+	rc = zcrypt_send_cprb(&xcrb);
 	if (rc) {
 		DEBUG_ERR("%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\n",
 			  __func__, (int) cardnr, (int) domain, rc);
@@ -850,7 +832,7 @@ int cca_gencipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,
 	prep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);
 
 	/* forward xcrb with request CPRB and reply CPRB to zcrypt dd */
-	rc = _zcrypt_send_cprb(&xcrb);
+	rc = zcrypt_send_cprb(&xcrb);
 	if (rc) {
 		DEBUG_ERR(
 			"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\n",
@@ -1018,7 +1000,7 @@ static int _ip_cprb_helper(u16 cardnr, u16 domain,
 	prep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);
 
 	/* forward xcrb with request CPRB and reply CPRB to zcrypt dd */
-	rc = _zcrypt_send_cprb(&xcrb);
+	rc = zcrypt_send_cprb(&xcrb);
 	if (rc) {
 		DEBUG_ERR(
 			"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\n",
@@ -1235,7 +1217,7 @@ int cca_cipher2protkey(u16 cardnr, u16 domain, const u8 *ckey,
 	prep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);
 
 	/* forward xcrb with request CPRB and reply CPRB to zcrypt dd */
-	rc = _zcrypt_send_cprb(&xcrb);
+	rc = zcrypt_send_cprb(&xcrb);
 	if (rc) {
 		DEBUG_ERR(
 			"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\n",
@@ -1366,7 +1348,7 @@ int cca_query_crypto_facility(u16 cardnr, u16 domain,
 	prep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);
 
 	/* forward xcrb with request CPRB and reply CPRB to zcrypt dd */
-	rc = _zcrypt_send_cprb(&xcrb);
+	rc = zcrypt_send_cprb(&xcrb);
 	if (rc) {
 		DEBUG_ERR("%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\n",
 			  __func__, (int) cardnr, (int) domain, rc);
diff --git a/drivers/s390/crypto/zcrypt_ep11misc.c b/drivers/s390/crypto/zcrypt_ep11misc.c
index 7dd987afcd55..7c036c83845d 100644
--- a/drivers/s390/crypto/zcrypt_ep11misc.c
+++ b/drivers/s390/crypto/zcrypt_ep11misc.c
@@ -169,24 +169,6 @@ int ep11_check_aeskeyblob(debug_info_t *dbg, int dbflvl,
 }
 EXPORT_SYMBOL(ep11_check_aeskeyblob);
 
-/*
- * Helper function which calls zcrypt_send_ep11_cprb with
- * memory management segment adjusted to kernel space
- * so that the copy_from_user called within this
- * function do in fact copy from kernel space.
- */
-static inline int _zcrypt_send_ep11_cprb(struct ep11_urb *urb)
-{
-	int rc;
-	mm_segment_t old_fs = get_fs();
-
-	set_fs(KERNEL_DS);
-	rc = zcrypt_send_ep11_cprb(urb);
-	set_fs(old_fs);
-
-	return rc;
-}
-
 /*
  * Allocate and prepare ep11 cprb plus additional payload.
  */
@@ -400,7 +382,7 @@ static int ep11_query_info(u16 cardnr, u16 domain, u32 query_type,
 		 req, sizeof(*req) + sizeof(*req_pl),
 		 rep, sizeof(*rep) + sizeof(*rep_pl) + buflen);
 
-	rc = _zcrypt_send_ep11_cprb(urb);
+	rc = zcrypt_send_ep11_cprb(urb);
 	if (rc) {
 		DEBUG_ERR(
 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
@@ -638,7 +620,7 @@ int ep11_genaeskey(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,
 		 req, sizeof(*req) + sizeof(*req_pl),
 		 rep, sizeof(*rep) + sizeof(*rep_pl));
 
-	rc = _zcrypt_send_ep11_cprb(urb);
+	rc = zcrypt_send_ep11_cprb(urb);
 	if (rc) {
 		DEBUG_ERR(
 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
@@ -758,7 +740,7 @@ static int ep11_cryptsingle(u16 card, u16 domain,
 		 req, sizeof(*req) + req_pl_size,
 		 rep, sizeof(*rep) + rep_pl_size);
 
-	rc = _zcrypt_send_ep11_cprb(urb);
+	rc = zcrypt_send_ep11_cprb(urb);
 	if (rc) {
 		DEBUG_ERR(
 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
@@ -906,7 +888,7 @@ static int ep11_unwrapkey(u16 card, u16 domain,
 		 req, sizeof(*req) + req_pl_size,
 		 rep, sizeof(*rep) + sizeof(*rep_pl));
 
-	rc = _zcrypt_send_ep11_cprb(urb);
+	rc = zcrypt_send_ep11_cprb(urb);
 	if (rc) {
 		DEBUG_ERR(
 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
@@ -1034,7 +1016,7 @@ static int ep11_wrapkey(u16 card, u16 domain,
 		 req, sizeof(*req) + req_pl_size,
 		 rep, sizeof(*rep) + sizeof(*rep_pl));
 
-	rc = _zcrypt_send_ep11_cprb(urb);
+	rc = zcrypt_send_ep11_cprb(urb);
 	if (rc) {
 		DEBUG_ERR(
 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
* Unmerged path drivers/s390/crypto/zcrypt_msgtype6.c
diff --git a/drivers/s390/crypto/zcrypt_msgtype6.h b/drivers/s390/crypto/zcrypt_msgtype6.h
index 0de280a81dd4..0a0bf074206b 100644
--- a/drivers/s390/crypto/zcrypt_msgtype6.h
+++ b/drivers/s390/crypto/zcrypt_msgtype6.h
@@ -96,9 +96,9 @@ struct type86_fmt2_ext {
 	unsigned int	  offset4;	/* 0x00000000			*/
 } __packed;
 
-unsigned int get_cprb_fc(struct ica_xcRB *, struct ap_message *,
+unsigned int get_cprb_fc(bool userspace, struct ica_xcRB *, struct ap_message *,
 			 unsigned int *, unsigned short **);
-unsigned int get_ep11cprb_fc(struct ep11_urb *, struct ap_message *,
+unsigned int get_ep11cprb_fc(bool userspace, struct ep11_urb *, struct ap_message *,
 			     unsigned int *);
 unsigned int get_rng_fc(struct ap_message *, int *, unsigned int *);
 
