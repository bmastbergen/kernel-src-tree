net/mlx5e: Check correct ip_version in decapsulation route resolution

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 1e74152ed065ef491c30ccbbe119992e3e5200be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/1e74152e.failed

flow_attr->ip_version has the matching that should be done inner/outer.
When working with chains, decapsulation is done on chain0 and next chain
match on outer header which is the original inner which could be ipv4.
So in tunnel route resolution we cannot use that to know which ip version
we are at so save tun_ip_version when parsing the tunnel match and use
that.

Fixes: a508728a4c8b ("net/mlx5e: VF tunnel RX traffic offloading")
	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Dmytro Linkin <dlinkin@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 1e74152ed065ef491c30ccbbe119992e3e5200be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun_encap.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
index b2322fbe0687,172e0474f2e6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
@@@ -466,6 -676,57 +466,60 @@@ release_neigh
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ int mlx5e_tc_tun_route_lookup(struct mlx5e_priv *priv,
+ 			      struct mlx5_flow_spec *spec,
+ 			      struct mlx5_flow_attr *flow_attr)
+ {
+ 	struct mlx5_esw_flow_attr *esw_attr = flow_attr->esw_attr;
+ 	TC_TUN_ROUTE_ATTR_INIT(attr);
+ 	u16 vport_num;
+ 	int err = 0;
+ 
+ 	if (flow_attr->tun_ip_version == 4) {
+ 		/* Addresses are swapped for decap */
+ 		attr.fl.fl4.saddr = esw_attr->rx_tun_attr->dst_ip.v4;
+ 		attr.fl.fl4.daddr = esw_attr->rx_tun_attr->src_ip.v4;
+ 		err = mlx5e_route_lookup_ipv4_get(priv, priv->netdev, &attr);
+ 	}
+ #if IS_ENABLED(CONFIG_INET) && IS_ENABLED(CONFIG_IPV6)
+ 	else if (flow_attr->tun_ip_version == 6) {
+ 		/* Addresses are swapped for decap */
+ 		attr.fl.fl6.saddr = esw_attr->rx_tun_attr->dst_ip.v6;
+ 		attr.fl.fl6.daddr = esw_attr->rx_tun_attr->src_ip.v6;
+ 		err = mlx5e_route_lookup_ipv6_get(priv, priv->netdev, &attr);
+ 	}
+ #endif
+ 	else
+ 		return 0;
+ 
+ 	if (err)
+ 		return err;
+ 
+ 	if (attr.route_dev->netdev_ops != &mlx5e_netdev_ops ||
+ 	    !mlx5e_tc_is_vf_tunnel(attr.out_dev, attr.route_dev))
+ 		goto out;
+ 
+ 	err = mlx5e_tc_query_route_vport(attr.out_dev, attr.route_dev, &vport_num);
+ 	if (err)
+ 		goto out;
+ 
+ 	esw_attr->rx_tun_attr->vni = MLX5_GET(fte_match_param, spec->match_value,
+ 					      misc_parameters.vxlan_vni);
+ 	esw_attr->rx_tun_attr->decap_vport = vport_num;
+ 
+ out:
+ 	if (flow_attr->tun_ip_version == 4)
+ 		mlx5e_route_lookup_ipv4_put(&attr);
+ #if IS_ENABLED(CONFIG_INET) && IS_ENABLED(CONFIG_IPV6)
+ 	else if (flow_attr->tun_ip_version == 6)
+ 		mlx5e_route_lookup_ipv6_put(&attr);
+ #endif
+ 	return err;
+ }
+ 
++>>>>>>> 1e74152ed065 (net/mlx5e: Check correct ip_version in decapsulation route resolution)
  bool mlx5e_tc_tun_device_to_offload(struct mlx5e_priv *priv,
  				    struct net_device *netdev)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun_encap.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun_encap.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 00b8693ad3dc..3b2557b1803f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -71,6 +71,7 @@ struct mlx5_flow_attr {
 	u8 inner_match_level;
 	u8 outer_match_level;
 	u8 ip_version;
+	u8 tun_ip_version;
 	u32 flags;
 	union {
 		struct mlx5_esw_flow_attr esw_attr[0];
