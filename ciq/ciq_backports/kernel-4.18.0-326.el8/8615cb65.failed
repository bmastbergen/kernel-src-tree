dm: remove useless loop in __split_and_process_bio

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 8615cb65bd638ba5f9ebe71115cc5956eb1713d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/8615cb65.failed

Remove useless "while" loop. If the condition ci.sector_count && !error is
true, we go to a branch that ends with "break". If this condition is
false, the "while" loop will not be executed again. So, the loop can't be
executed more than once.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 8615cb65bd638ba5f9ebe71115cc5956eb1713d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index fdf3ef7e35e3,1dac75cb55ab..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1648,38 -1641,35 +1648,70 @@@ static blk_qc_t __split_and_process_bio
  	} else {
  		ci.bio = bio;
  		ci.sector_count = bio_sectors(bio);
++<<<<<<< HEAD
 +		while (ci.sector_count && !error) {
 +			error = __split_and_process_non_flush(&ci);
 +			if (ci.sector_count && !error) {
 +				/*
 +				 * Remainder must be passed to generic_make_request()
 +				 * so that it gets handled *after* bios already submitted
 +				 * have been completely processed.
 +				 * We take a clone of the original to store in
 +				 * ci.io->orig_bio to be used by end_io_acct() and
 +				 * for dec_pending to use for completion handling.
 +				 */
 +				struct bio *b = bio_split(bio, bio_sectors(bio) - ci.sector_count,
 +							  GFP_NOIO, &md->queue->bio_split);
 +				ci.io->orig_bio = b;
 +
 +				/*
 +				 * Adjust IO stats for each split, otherwise upon queue
 +				 * reentry there will be redundant IO accounting.
 +				 * NOTE: this is a stop-gap fix, a proper fix involves
 +				 * significant refactoring of DM core's bio splitting
 +				 * (by eliminating DM's splitting and just using bio_split)
 +				 */
 +				part_stat_lock();
 +				__dm_part_stat_sub(&dm_disk(md)->part0,
 +						   sectors[op_stat_group(bio_op(bio))], ci.sector_count);
 +				part_stat_unlock();
 +
 +				bio_chain(b, bio);
 +				trace_block_split(md->queue, b, bio->bi_iter.bi_sector);
 +				ret = generic_make_request(bio);
 +				break;
 +			}
++=======
+ 		error = __split_and_process_non_flush(&ci);
+ 		if (ci.sector_count && !error) {
+ 			/*
+ 			 * Remainder must be passed to submit_bio_noacct()
+ 			 * so that it gets handled *after* bios already submitted
+ 			 * have been completely processed.
+ 			 * We take a clone of the original to store in
+ 			 * ci.io->orig_bio to be used by end_io_acct() and
+ 			 * for dec_pending to use for completion handling.
+ 			 */
+ 			struct bio *b = bio_split(bio, bio_sectors(bio) - ci.sector_count,
+ 						  GFP_NOIO, &md->queue->bio_split);
+ 			ci.io->orig_bio = b;
+ 
+ 			/*
+ 			 * Adjust IO stats for each split, otherwise upon queue
+ 			 * reentry there will be redundant IO accounting.
+ 			 * NOTE: this is a stop-gap fix, a proper fix involves
+ 			 * significant refactoring of DM core's bio splitting
+ 			 * (by eliminating DM's splitting and just using bio_split)
+ 			 */
+ 			part_stat_lock();
+ 			__dm_part_stat_sub(dm_disk(md)->part0,
+ 					   sectors[op_stat_group(bio_op(bio))], ci.sector_count);
+ 			part_stat_unlock();
+ 
+ 			bio_chain(b, bio);
+ 			trace_block_split(b, bio->bi_iter.bi_sector);
+ 			ret = submit_bio_noacct(bio);
++>>>>>>> 8615cb65bd63 (dm: remove useless loop in __split_and_process_bio)
  		}
  	}
  
* Unmerged path drivers/md/dm.c
