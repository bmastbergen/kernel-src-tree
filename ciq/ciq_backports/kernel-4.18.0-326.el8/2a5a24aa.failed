scsi: blk-mq: Return budget token from .get_budget callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 2a5a24aa83382a88c43d18a901fab66e6ffe1199
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/2a5a24aa.failed

SCSI uses a global atomic variable to track queue depth for each
LUN/request queue.

This doesn't scale well when there are lots of CPU cores and the disk is
very fast. It has been observed that IOPS is affected a lot by tracking
queue depth via sdev->device_busy in the I/O path.

Return budget token from .get_budget callback. The budget token can be
passed to driver so that we can replace the atomic variable with
sbitmap_queue and alleviate the scaling problems that way.

Link: https://lore.kernel.org/r/20210122023317.687987-9-ming.lei@redhat.com
	Cc: Omar Sandoval <osandov@fb.com>
	Cc: Kashyap Desai <kashyap.desai@broadcom.com>
	Cc: Sumanesh Samanta <sumanesh.samanta@broadcom.com>
	Cc: Ewan D. Milne <emilne@redhat.com>
	Tested-by: Sumanesh Samanta <sumanesh.samanta@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 2a5a24aa83382a88c43d18a901fab66e6ffe1199)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-sched.c
#	block/blk-mq.c
#	block/blk-mq.h
#	drivers/scsi/scsi_lib.c
#	include/linux/blk-mq.h
diff --cc block/blk-mq-sched.c
index 7c86fdd65b44,712b7f0afd63..000000000000
--- a/block/blk-mq-sched.c
+++ b/block/blk-mq-sched.c
@@@ -141,12 -141,13 +142,21 @@@ static int __blk_mq_do_dispatch_sched(s
  			break;
  		}
  
++<<<<<<< HEAD
 +		if (!blk_mq_get_dispatch_budget(hctx))
++=======
+ 		budget_token = blk_mq_get_dispatch_budget(q);
+ 		if (budget_token < 0)
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  			break;
  
  		rq = e->type->ops.dispatch_request(hctx);
  		if (!rq) {
++<<<<<<< HEAD
 +			blk_mq_put_dispatch_budget(hctx);
++=======
+ 			blk_mq_put_dispatch_budget(q, budget_token);
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  			/*
  			 * We're releasing without dispatching. Holding the
  			 * budget could have blocked any "hctx"s with the
@@@ -239,12 -244,13 +253,21 @@@ static int blk_mq_do_dispatch_ctx(struc
  		if (!sbitmap_any_bit_set(&hctx->ctx_map))
  			break;
  
++<<<<<<< HEAD
 +		if (!blk_mq_get_dispatch_budget(hctx))
++=======
+ 		budget_token = blk_mq_get_dispatch_budget(q);
+ 		if (budget_token < 0)
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  			break;
  
  		rq = blk_mq_dequeue_from_ctx(hctx, ctx);
  		if (!rq) {
++<<<<<<< HEAD
 +			blk_mq_put_dispatch_budget(hctx);
++=======
+ 			blk_mq_put_dispatch_budget(q, budget_token);
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  			/*
  			 * We're releasing without dispatching. Holding the
  			 * budget could have blocked any "hctx"s with the
diff --cc block/blk-mq.c
index 2c7e4bee30bc,2e825a7a3606..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1321,10 -1277,15 +1321,21 @@@ static enum prep_dispatch blk_mq_prep_d
  						  bool need_budget)
  {
  	struct blk_mq_hw_ctx *hctx = rq->mq_hctx;
+ 	int budget_token = -1;
  
++<<<<<<< HEAD
 +	if (need_budget && !blk_mq_get_dispatch_budget(hctx)) {
 +		blk_mq_put_driver_tag(rq);
 +		return PREP_DISPATCH_NO_BUDGET;
++=======
+ 	if (need_budget) {
+ 		budget_token = blk_mq_get_dispatch_budget(rq->q);
+ 		if (budget_token < 0) {
+ 			blk_mq_put_driver_tag(rq);
+ 			return PREP_DISPATCH_NO_BUDGET;
+ 		}
+ 		blk_mq_set_rq_budget_token(rq, budget_token);
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  	}
  
  	if (!blk_mq_get_driver_tag(rq)) {
@@@ -1341,7 -1302,7 +1352,11 @@@
  			 * together during handling partial dispatch
  			 */
  			if (need_budget)
++<<<<<<< HEAD
 +				blk_mq_put_dispatch_budget(hctx);
++=======
+ 				blk_mq_put_dispatch_budget(rq->q, budget_token);
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  			return PREP_DISPATCH_NO_TAG;
  		}
  	}
@@@ -1350,13 -1311,17 +1365,27 @@@
  }
  
  /* release all allocated budgets before calling to blk_mq_dispatch_rq_list */
++<<<<<<< HEAD
 +static void blk_mq_release_budgets(struct blk_mq_hw_ctx *hctx,
 +		unsigned int nr_budgets)
++=======
+ static void blk_mq_release_budgets(struct request_queue *q,
+ 		struct list_head *list)
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  {
- 	int i;
+ 	struct request *rq;
  
++<<<<<<< HEAD
 +	for (i = 0; i < nr_budgets; i++)
 +		blk_mq_put_dispatch_budget(hctx);
++=======
+ 	list_for_each_entry(rq, list, queuelist) {
+ 		int budget_token = blk_mq_get_rq_budget_token(rq);
+ 
+ 		if (budget_token >= 0)
+ 			blk_mq_put_dispatch_budget(q, budget_token);
+ 	}
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  }
  
  /*
@@@ -1449,15 -1419,8 +1478,20 @@@ out
  			(hctx->flags & BLK_MQ_F_TAG_QUEUE_SHARED);
  		bool no_budget_avail = prep == PREP_DISPATCH_NO_BUDGET;
  
++<<<<<<< HEAD
 +		blk_mq_release_budgets(hctx, nr_budgets);
 +
 +		/*
 +		 * If we didn't flush the entire list, we could have told
 +		 * the driver there was more coming, but that turned out to
 +		 * be a lie.
 +		 */
 +		if (q->mq_ops->commit_rqs && queued)
 +			q->mq_ops->commit_rqs(hctx);
++=======
+ 		if (nr_budgets)
+ 			blk_mq_release_budgets(q, list);
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  
  		spin_lock(&hctx->lock);
  		list_splice_tail_init(list, &hctx->dispatch);
@@@ -2065,11 -2037,14 +2100,22 @@@ static blk_status_t __blk_mq_try_issue_
  	if (q->elevator && !bypass_insert)
  		goto insert;
  
++<<<<<<< HEAD
 +	if (!blk_mq_get_dispatch_budget(hctx))
++=======
+ 	budget_token = blk_mq_get_dispatch_budget(q);
+ 	if (budget_token < 0)
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  		goto insert;
  
+ 	blk_mq_set_rq_budget_token(rq, budget_token);
+ 
  	if (!blk_mq_get_driver_tag(rq)) {
++<<<<<<< HEAD
 +		blk_mq_put_dispatch_budget(hctx);
++=======
+ 		blk_mq_put_dispatch_budget(q, budget_token);
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  		goto insert;
  	}
  
diff --cc block/blk-mq.h
index db1f5f2293f7,9ce64bc4a6c8..000000000000
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@@ -188,25 -182,39 +188,58 @@@ static inline bool blk_mq_hw_queue_mapp
  	return hctx->nr_ctx && hctx->tags;
  }
  
 -unsigned int blk_mq_in_flight(struct request_queue *q,
 -		struct block_device *part);
 -void blk_mq_in_flight_rw(struct request_queue *q, struct block_device *part,
 -		unsigned int inflight[2]);
 +unsigned int blk_mq_in_flight(struct request_queue *q, struct hd_struct *part);
 +void blk_mq_in_flight_rw(struct request_queue *q, struct hd_struct *part,
 +			 unsigned int inflight[2]);
  
++<<<<<<< HEAD
 +static inline void blk_mq_put_dispatch_budget(struct blk_mq_hw_ctx *hctx)
++=======
+ static inline void blk_mq_put_dispatch_budget(struct request_queue *q,
+ 					      int budget_token)
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  {
 +	struct request_queue *q = hctx->queue;
 +
  	if (q->mq_ops->put_budget)
++<<<<<<< HEAD
 +		q->mq_ops->put_budget(hctx);
 +}
 +
 +static inline bool blk_mq_get_dispatch_budget(struct blk_mq_hw_ctx *hctx)
++=======
+ 		q->mq_ops->put_budget(q, budget_token);
+ }
+ 
+ static inline int blk_mq_get_dispatch_budget(struct request_queue *q)
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  {
 +	struct request_queue *q = hctx->queue;
 +
  	if (q->mq_ops->get_budget)
++<<<<<<< HEAD
 +		return q->mq_ops->get_budget(hctx);
 +	return true;
++=======
+ 		return q->mq_ops->get_budget(q);
+ 	return 0;
+ }
+ 
+ static inline void blk_mq_set_rq_budget_token(struct request *rq, int token)
+ {
+ 	if (token < 0)
+ 		return;
+ 
+ 	if (rq->q->mq_ops->set_rq_budget_token)
+ 		rq->q->mq_ops->set_rq_budget_token(rq, token);
+ }
+ 
+ static inline int blk_mq_get_rq_budget_token(struct request *rq)
+ {
+ 	if (rq->q->mq_ops->get_rq_budget_token)
+ 		return rq->q->mq_ops->get_rq_budget_token(rq);
+ 	return -1;
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  }
  
  static inline void __blk_mq_inc_active_requests(struct blk_mq_hw_ctx *hctx)
diff --cc drivers/scsi/scsi_lib.c
index 31348ae4746b,dae9f66caffd..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -1125,8 -1142,9 +1126,9 @@@ void scsi_init_command(struct scsi_devi
  	struct request *rq = blk_mq_rq_from_pdu(cmd);
  	unsigned int flags = cmd->flags & SCMD_PRESERVED_FLAGS;
  	unsigned long jiffies_at_alloc;
 -	int retries, to_clear;
 +	int retries;
  	bool in_flight;
+ 	int budget_token = cmd->budget_token;
  
  	if (!blk_rq_is_scsi(rq) && !(flags & SCMD_INITIALIZED)) {
  		flags |= SCMD_INITIALIZED;
@@@ -1149,8 -1173,8 +1151,9 @@@
  	cmd->retries = retries;
  	if (in_flight)
  		__set_bit(SCMD_STATE_INFLIGHT, &cmd->state);
+ 	cmd->budget_token = budget_token;
  
 +	scsi_add_cmd_to_list(cmd);
  }
  
  static blk_status_t scsi_setup_scsi_cmnd(struct scsi_device *sdev,
@@@ -1582,17 -1608,15 +1585,25 @@@ static void scsi_mq_done(struct scsi_cm
  	blk_mq_complete_request(cmd->request);
  }
  
++<<<<<<< HEAD
 +static void scsi_mq_put_budget(struct blk_mq_hw_ctx *hctx)
++=======
+ static void scsi_mq_put_budget(struct request_queue *q, int budget_token)
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  {
 +	struct request_queue *q = hctx->queue;
  	struct scsi_device *sdev = q->queuedata;
  
  	atomic_dec(&sdev->device_busy);
  }
  
++<<<<<<< HEAD
 +static bool scsi_mq_get_budget(struct blk_mq_hw_ctx *hctx)
++=======
+ static int scsi_mq_get_budget(struct request_queue *q)
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  {
 +	struct request_queue *q = hctx->queue;
  	struct scsi_device *sdev = q->queuedata;
  
  	if (scsi_dev_queue_ready(q, sdev))
@@@ -1618,9 -1642,23 +1629,9 @@@
  	if (unlikely(atomic_read(&sdev->device_busy) == 0 &&
  				!scsi_device_blocked(sdev)))
  		blk_mq_delay_run_hw_queues(sdev->request_queue, SCSI_QUEUE_DELAY);
- 	return false;
+ 	return -1;
  }
  
 -static void scsi_mq_set_rq_budget_token(struct request *req, int token)
 -{
 -	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
 -
 -	cmd->budget_token = token;
 -}
 -
 -static int scsi_mq_get_rq_budget_token(struct request *req)
 -{
 -	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
 -
 -	return cmd->budget_token;
 -}
 -
  static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
  			 const struct blk_mq_queue_data *bd)
  {
@@@ -1686,7 -1723,8 +1699,12 @@@ out_dec_target_busy
  	if (scsi_target(sdev)->can_queue > 0)
  		atomic_dec(&scsi_target(sdev)->target_busy);
  out_put_budget:
++<<<<<<< HEAD
 +	scsi_mq_put_budget(hctx);
++=======
+ 	scsi_mq_put_budget(q, cmd->budget_token);
+ 	cmd->budget_token = -1;
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  	switch (ret) {
  	case BLK_STS_OK:
  		break;
diff --cc include/linux/blk-mq.h
index f9f05156519e,3bd3ee651143..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -228,32 -306,51 +228,41 @@@ struct blk_mq_ops 
  	 * reserved budget. Also we have to handle failure case
  	 * of .get_budget for avoiding I/O deadlock.
  	 */
++<<<<<<< HEAD
 +	get_budget_fn		*get_budget;
 +	put_budget_fn		*put_budget;
++=======
+ 	int (*get_budget)(struct request_queue *);
+ 
+ 	/**
+ 	 * @put_budget: Release the reserved budget.
+ 	 */
+ 	void (*put_budget)(struct request_queue *, int);
++>>>>>>> 2a5a24aa8338 (scsi: blk-mq: Return budget token from .get_budget callback)
  
  	/*
 -	 * @set_rq_budget_toekn: store rq's budget token
 -	 */
 -	void (*set_rq_budget_token)(struct request *, int);
 -	/*
 -	 * @get_rq_budget_toekn: retrieve rq's budget token
 -	 */
 -	int (*get_rq_budget_token)(struct request *);
 -
 -	/**
 -	 * @timeout: Called on request timeout.
 +	 * Called on request timeout
  	 */
 -	enum blk_eh_timer_return (*timeout)(struct request *, bool);
 +	timeout_fn		*timeout;
  
 -	/**
 -	 * @poll: Called to poll for completion of a specific tag.
 +	/*
 +	 * Called to poll for completion of a specific tag.
  	 */
 -	int (*poll)(struct blk_mq_hw_ctx *);
 +	poll_fn			*poll;
  
 -	/**
 -	 * @complete: Mark the request as complete.
 -	 */
 -	void (*complete)(struct request *);
 +	complete_fn		*complete;
  
 -	/**
 -	 * @init_hctx: Called when the block layer side of a hardware queue has
 -	 * been set up, allowing the driver to allocate/init matching
 -	 * structures.
 -	 */
 -	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
 -	/**
 -	 * @exit_hctx: Ditto for exit/teardown.
 +	/*
 +	 * Called when the block layer side of a hardware queue has been
 +	 * set up, allowing the driver to allocate/init matching structures.
 +	 * Ditto for exit/teardown.
  	 */
 -	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
 +	init_hctx_fn		*init_hctx;
 +	exit_hctx_fn		*exit_hctx;
  
 -	/**
 -	 * @init_request: Called for every command allocated by the block layer
 -	 * to allow the driver to set up driver specific data.
 +	/*
 +	 * Called for every command allocated by the block layer to allow
 +	 * the driver to set up driver specific data.
  	 *
  	 * Tag greater than or equal to queue_depth is for setting up
  	 * flush request.
* Unmerged path block/blk-mq-sched.c
* Unmerged path block/blk-mq.c
* Unmerged path block/blk-mq.h
* Unmerged path drivers/scsi/scsi_lib.c
* Unmerged path include/linux/blk-mq.h
