xfs: refactor xfs_trans_dqresv

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 292b47b4fcfad2b8b2bc749d68c8baa63fc8bf36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/292b47b4.failed

Now that we've refactored the resource usage and limits into
per-resource structures, we can refactor some of the open-coded
reservation limit checking in xfs_trans_dqresv.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Chandan Babu R <chandanrlinux@gmail.com>
	Reviewed-by: Allison Collins <allison.henderson@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 292b47b4fcfad2b8b2bc749d68c8baa63fc8bf36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_trans_dquot.c
diff --cc fs/xfs/xfs_trans_dquot.c
index 5ad1158397ae,9dc8dd9f852c..000000000000
--- a/fs/xfs/xfs_trans_dquot.c
+++ b/fs/xfs/xfs_trans_dquot.c
@@@ -585,83 -631,41 +631,80 @@@ xfs_trans_dqresv
  	defq = xfs_get_defquota(q, xfs_dquot_type(dqp));
  
  	if (flags & XFS_TRANS_DQ_RES_BLKS) {
++<<<<<<< HEAD
 +		hardlimit = dqp->q_blk.hardlimit;
 +		if (!hardlimit)
 +			hardlimit = defq->bhardlimit;
 +		softlimit = dqp->q_blk.softlimit;
 +		if (!softlimit)
 +			softlimit = defq->bsoftlimit;
 +		timer = dqp->q_blk.timer;
 +		warns = dqp->q_blk.warnings;
 +		warnlimit = defq->bwarnlimit;
 +		resbcountp = &dqp->q_blk.reserved;
 +	} else {
 +		ASSERT(flags & XFS_TRANS_DQ_RES_RTBLKS);
 +		hardlimit = dqp->q_rtb.hardlimit;
 +		if (!hardlimit)
 +			hardlimit = defq->rtbhardlimit;
 +		softlimit = dqp->q_rtb.softlimit;
 +		if (!softlimit)
 +			softlimit = defq->rtbsoftlimit;
 +		timer = dqp->q_rtb.timer;
 +		warns = dqp->q_rtb.warnings;
 +		warnlimit = defq->rtbwarnlimit;
 +		resbcountp = &dqp->q_rtb.reserved;
++=======
+ 		blkres = &dqp->q_blk;
+ 		qlim = &defq->blk;
+ 	} else {
+ 		blkres = &dqp->q_rtb;
+ 		qlim = &defq->rtb;
++>>>>>>> 292b47b4fcfa (xfs: refactor xfs_trans_dqresv)
  	}
  
  	if ((flags & XFS_QMOPT_FORCE_RES) == 0 && dqp->q_id &&
  	    ((XFS_IS_UQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISUDQ(dqp)) ||
  	     (XFS_IS_GQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISGDQ(dqp)) ||
  	     (XFS_IS_PQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISPDQ(dqp)))) {
- 		if (nblks > 0) {
+ 		int		quota_nl;
+ 		bool		fatal;
+ 
+ 		/*
+ 		 * dquot is locked already. See if we'd go over the hardlimit
+ 		 * or exceed the timelimit if we'd reserve resources.
+ 		 */
+ 		quota_nl = xfs_dqresv_check(blkres, qlim, nblks, &fatal);
+ 		if (quota_nl != QUOTA_NL_NOWARN) {
  			/*
- 			 * dquot is locked already. See if we'd go over the
- 			 * hardlimit or exceed the timelimit if we allocate
- 			 * nblks.
+ 			 * Quota block warning codes are 3 more than the inode
+ 			 * codes, which we check above.
  			 */
- 			total_count = *resbcountp + nblks;
- 			if (hardlimit && total_count > hardlimit) {
- 				xfs_quota_warn(mp, dqp, QUOTA_NL_BHARDWARN);
+ 			xfs_quota_warn(mp, dqp, quota_nl + 3);
+ 			if (fatal)
  				goto error_return;
- 			}
- 			if (softlimit && total_count > softlimit) {
- 				if ((timer != 0 &&
- 				     ktime_get_real_seconds() > timer) ||
- 				    (warns != 0 && warns >= warnlimit)) {
- 					xfs_quota_warn(mp, dqp,
- 						       QUOTA_NL_BSOFTLONGWARN);
- 					goto error_return;
- 				}
- 
- 				xfs_quota_warn(mp, dqp, QUOTA_NL_BSOFTWARN);
- 			}
  		}
++<<<<<<< HEAD
 +		if (ninos > 0) {
 +			total_count = dqp->q_ino.reserved + ninos;
 +			timer = dqp->q_ino.timer;
 +			warns = dqp->q_ino.warnings;
 +			warnlimit = defq->iwarnlimit;
 +			hardlimit = dqp->q_ino.hardlimit;
 +			if (!hardlimit)
 +				hardlimit = defq->ihardlimit;
 +			softlimit = dqp->q_ino.softlimit;
 +			if (!softlimit)
 +				softlimit = defq->isoftlimit;
- 
- 			if (hardlimit && total_count > hardlimit) {
- 				xfs_quota_warn(mp, dqp, QUOTA_NL_IHARDWARN);
++=======
++>>>>>>> 292b47b4fcfa (xfs: refactor xfs_trans_dqresv)
+ 
+ 		quota_nl = xfs_dqresv_check(&dqp->q_ino, &defq->ino, ninos,
+ 				&fatal);
+ 		if (quota_nl != QUOTA_NL_NOWARN) {
+ 			xfs_quota_warn(mp, dqp, quota_nl);
+ 			if (fatal)
  				goto error_return;
- 			}
- 			if (softlimit && total_count > softlimit) {
- 				if  ((timer != 0 &&
- 				      ktime_get_real_seconds() > timer) ||
- 				     (warns != 0 && warns >= warnlimit)) {
- 					xfs_quota_warn(mp, dqp,
- 						       QUOTA_NL_ISOFTLONGWARN);
- 					goto error_return;
- 				}
- 				xfs_quota_warn(mp, dqp, QUOTA_NL_ISOFTWARN);
- 			}
  		}
  	}
  
* Unmerged path fs/xfs/xfs_trans_dquot.c
