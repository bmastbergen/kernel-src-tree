xhci: remove obsolete dequeue pointer moving code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Mathias Nyman <mathias.nyman@linux.intel.com>
commit 741eafb3457ca3c5159e01809a3fd7c754079d25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/741eafb3.failed

xhci_find_new_dequeue_state() and xhci_queue_new_dequeue_state() are no
longer used afer introducing the move_dequeue_past_td() function.

also remove struct xhci_dequeue_state as its no longer used.

	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
Link: https://lore.kernel.org/r/20210129130044.206855-26-mathias.nyman@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 741eafb3457ca3c5159e01809a3fd7c754079d25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci-ring.c
diff --cc drivers/usb/host/xhci-ring.c
index bd30ef5cce7a,1440041acae2..000000000000
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@@ -547,73 -551,55 +547,122 @@@ static u64 xhci_get_hw_deq(struct xhci_
  	return le64_to_cpu(ep_ctx->deq);
  }
  
++<<<<<<< HEAD
 +/*
 + * Move the xHC's endpoint ring dequeue pointer past cur_td.
 + * Record the new state of the xHC's endpoint ring dequeue segment,
 + * dequeue pointer, stream id, and new consumer cycle state in state.
 + * Update our internal representation of the ring's dequeue pointer.
 + *
 + * We do this in three jumps:
 + *  - First we update our new ring state to be the same as when the xHC stopped.
 + *  - Then we traverse the ring to find the segment that contains
 + *    the last TRB in the TD.  We toggle the xHC's new cycle state when we pass
 + *    any link TRBs with the toggle cycle bit set.
 + *  - Finally we move the dequeue state one TRB further, toggling the cycle bit
 + *    if we've moved it past a link TRB with the toggle cycle bit set.
 + *
 + * Some of the uses of xhci_generic_trb are grotty, but if they're done
 + * with correct __le32 accesses they should work fine.  Only users of this are
 + * in here.
 + */
 +void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
 +		unsigned int slot_id, unsigned int ep_index,
 +		unsigned int stream_id, struct xhci_td *cur_td,
 +		struct xhci_dequeue_state *state)
++=======
+ static int xhci_move_dequeue_past_td(struct xhci_hcd *xhci,
+ 				unsigned int slot_id, unsigned int ep_index,
+ 				unsigned int stream_id, struct xhci_td *td)
++>>>>>>> 741eafb3457c (xhci: remove obsolete dequeue pointer moving code)
  {
  	struct xhci_virt_device *dev = xhci->devs[slot_id];
  	struct xhci_virt_ep *ep = &dev->eps[ep_index];
  	struct xhci_ring *ep_ring;
++<<<<<<< HEAD
 +	struct xhci_segment *new_seg;
 +	union xhci_trb *new_deq;
++=======
+ 	struct xhci_command *cmd;
+ 	struct xhci_segment *new_seg;
+ 	union xhci_trb *new_deq;
+ 	int new_cycle;
++>>>>>>> 741eafb3457c (xhci: remove obsolete dequeue pointer moving code)
  	dma_addr_t addr;
  	u64 hw_dequeue;
  	bool cycle_found = false;
  	bool td_last_trb_found = false;
++<<<<<<< HEAD
++=======
+ 	u32 trb_sct = 0;
+ 	int ret;
++>>>>>>> 741eafb3457c (xhci: remove obsolete dequeue pointer moving code)
  
  	ep_ring = xhci_triad_to_transfer_ring(xhci, slot_id,
  			ep_index, stream_id);
  	if (!ep_ring) {
++<<<<<<< HEAD
 +		xhci_warn(xhci, "WARN can't find new dequeue state "
 +				"for invalid stream ID %u.\n",
 +				stream_id);
 +		return;
 +	}
 +	/*
 +	 * A cancelled TD can complete with a stall if HW cached the trb.
 +	 * In this case driver can't find cur_td, but if the ring is empty we
 +	 * can move the dequeue pointer to the current enqueue position.
 +	 */
 +	if (!cur_td) {
 +		if (list_empty(&ep_ring->td_list)) {
 +			state->new_deq_seg = ep_ring->enq_seg;
 +			state->new_deq_ptr = ep_ring->enqueue;
 +			state->new_cycle_state = ep_ring->cycle_state;
 +			goto done;
 +		} else {
 +			xhci_warn(xhci, "Can't find new dequeue state, missing cur_td\n");
 +			return;
 +		}
 +	}
 +
 +	/* Dig out the cycle state saved by the xHC during the stop ep cmd */
 +	xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 +			"Finding endpoint context");
 +
 +	hw_dequeue = xhci_get_hw_deq(xhci, dev, ep_index, stream_id);
 +	new_seg = ep_ring->deq_seg;
 +	new_deq = ep_ring->dequeue;
 +	state->new_cycle_state = hw_dequeue & 0x1;
 +	state->stream_id = stream_id;
++=======
+ 		xhci_warn(xhci, "WARN can't find new dequeue, invalid stream ID %u\n",
+ 			  stream_id);
+ 		return -ENODEV;
+ 	}
+ 	/*
+ 	 * A cancelled TD can complete with a stall if HW cached the trb.
+ 	 * In this case driver can't find td, but if the ring is empty we
+ 	 * can move the dequeue pointer to the current enqueue position.
+ 	 * We shouldn't hit this anymore as cached cancelled TRBs are given back
+ 	 * after clearing the cache, but be on the safe side and keep it anyway
+ 	 */
+ 	if (!td) {
+ 		if (list_empty(&ep_ring->td_list)) {
+ 			new_seg = ep_ring->enq_seg;
+ 			new_deq = ep_ring->enqueue;
+ 			new_cycle = ep_ring->cycle_state;
+ 			xhci_dbg(xhci, "ep ring empty, Set new dequeue = enqueue");
+ 			goto deq_found;
+ 		} else {
+ 			xhci_warn(xhci, "Can't find new dequeue state, missing td\n");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	hw_dequeue = xhci_get_hw_deq(xhci, dev, ep_index, stream_id);
+ 	new_seg = ep_ring->deq_seg;
+ 	new_deq = ep_ring->dequeue;
+ 	new_cycle = hw_dequeue & 0x1;
++>>>>>>> 741eafb3457c (xhci: remove obsolete dequeue pointer moving code)
  
  	/*
  	 * We want to find the pointer, segment and cycle state of the new trb
@@@ -628,40 -614,71 +677,103 @@@
  			if (td_last_trb_found)
  				break;
  		}
++<<<<<<< HEAD
 +		if (new_deq == cur_td->last_trb)
++=======
+ 		if (new_deq == td->last_trb)
++>>>>>>> 741eafb3457c (xhci: remove obsolete dequeue pointer moving code)
  			td_last_trb_found = true;
  
  		if (cycle_found && trb_is_link(new_deq) &&
  		    link_trb_toggles_cycle(new_deq))
++<<<<<<< HEAD
 +			state->new_cycle_state ^= 0x1;
++=======
+ 			new_cycle ^= 0x1;
++>>>>>>> 741eafb3457c (xhci: remove obsolete dequeue pointer moving code)
  
  		next_trb(xhci, ep_ring, &new_seg, &new_deq);
  
  		/* Search wrapped around, bail out */
  		if (new_deq == ep->ring->dequeue) {
  			xhci_err(xhci, "Error: Failed finding new dequeue state\n");
++<<<<<<< HEAD
 +			state->new_deq_seg = NULL;
 +			state->new_deq_ptr = NULL;
 +			return;
++=======
+ 			return -EINVAL;
++>>>>>>> 741eafb3457c (xhci: remove obsolete dequeue pointer moving code)
  		}
  
  	} while (!cycle_found || !td_last_trb_found);
  
++<<<<<<< HEAD
 +	state->new_deq_seg = new_seg;
 +	state->new_deq_ptr = new_deq;
 +
 +done:
 +	/* Don't update the ring cycle state for the producer (us). */
 +	xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 +			"Cycle state = 0x%x", state->new_cycle_state);
 +
 +	xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 +			"New dequeue segment = %p (virtual)",
 +			state->new_deq_seg);
 +	addr = xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr);
 +	xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 +			"New dequeue pointer = 0x%llx (DMA)",
 +			(unsigned long long) addr);
++=======
+ deq_found:
+ 
+ 	/* Don't update the ring cycle state for the producer (us). */
+ 	addr = xhci_trb_virt_to_dma(new_seg, new_deq);
+ 	if (addr == 0) {
+ 		xhci_warn(xhci, "Can't find dma of new dequeue ptr\n");
+ 		xhci_warn(xhci, "deq seg = %p, deq ptr = %p\n", new_seg, new_deq);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((ep->ep_state & SET_DEQ_PENDING)) {
+ 		xhci_warn(xhci, "Set TR Deq already pending, don't submit for 0x%pad\n",
+ 			  &addr);
+ 		return -EBUSY;
+ 	}
+ 
+ 	/* This function gets called from contexts where it cannot sleep */
+ 	cmd = xhci_alloc_command(xhci, false, GFP_ATOMIC);
+ 	if (!cmd) {
+ 		xhci_warn(xhci, "Can't alloc Set TR Deq cmd 0x%pad\n", &addr);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	if (stream_id)
+ 		trb_sct = SCT_FOR_TRB(SCT_PRI_TR);
+ 	ret = queue_command(xhci, cmd,
+ 		lower_32_bits(addr) | trb_sct | new_cycle,
+ 		upper_32_bits(addr),
+ 		STREAM_ID_FOR_TRB(stream_id), SLOT_ID_FOR_TRB(slot_id) |
+ 		EP_ID_FOR_TRB(ep_index) | TRB_TYPE(TRB_SET_DEQ), false);
+ 	if (ret < 0) {
+ 		xhci_free_command(xhci, cmd);
+ 		return ret;
+ 	}
+ 	ep->queued_deq_seg = new_seg;
+ 	ep->queued_deq_ptr = new_deq;
+ 
+ 	xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
+ 		       "Set TR Deq ptr 0x%llx, cycle %u\n", addr, new_cycle);
+ 
+ 	/* Stop the TD queueing code from ringing the doorbell until
+ 	 * this command completes.  The HC won't set the dequeue pointer
+ 	 * if the ring is running, and ringing the doorbell starts the
+ 	 * ring running.
+ 	 */
+ 	ep->ep_state |= SET_DEQ_PENDING;
+ 	xhci_ring_cmd_db(xhci);
+ 	return 0;
++>>>>>>> 741eafb3457c (xhci: remove obsolete dequeue pointer moving code)
  }
  
  /* flip_cycle means flip the cycle bit of all but the first and last TRB.
* Unmerged path drivers/usb/host/xhci-ring.c
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index db601e9a0692..d9a097b8cc3d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1559,13 +1559,6 @@ struct xhci_cd {
 	union xhci_trb		*cmd_trb;
 };
 
-struct xhci_dequeue_state {
-	struct xhci_segment *new_deq_seg;
-	union xhci_trb *new_deq_ptr;
-	int new_cycle_state;
-	unsigned int stream_id;
-};
-
 enum xhci_ring_type {
 	TYPE_CTRL = 0,
 	TYPE_ISOC,
@@ -2125,13 +2118,6 @@ int xhci_queue_reset_ep(struct xhci_hcd *xhci, struct xhci_command *cmd,
 		enum xhci_ep_reset_type reset_type);
 int xhci_queue_reset_device(struct xhci_hcd *xhci, struct xhci_command *cmd,
 		u32 slot_id);
-void xhci_find_new_dequeue_state(struct xhci_hcd *xhci,
-		unsigned int slot_id, unsigned int ep_index,
-		unsigned int stream_id, struct xhci_td *cur_td,
-		struct xhci_dequeue_state *state);
-void xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,
-		unsigned int slot_id, unsigned int ep_index,
-		struct xhci_dequeue_state *deq_state);
 void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci, unsigned int slot_id,
 			       unsigned int ep_index, unsigned int stream_id,
 			       struct xhci_td *td);
