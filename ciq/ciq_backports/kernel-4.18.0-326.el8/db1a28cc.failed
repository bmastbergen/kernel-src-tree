xfs: Add helpers xfs_attr_is_shortform and xfs_attr_set_shortform

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Allison Collins <allison.henderson@oracle.com>
commit db1a28cc591c1abe5470bedca1a489bb165c4c7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/db1a28cc.failed

In this patch, we hoist code from xfs_attr_set_args into two new helpers
xfs_attr_is_shortform and xfs_attr_set_shortform.  These two will help
to simplify xfs_attr_set_args when we get into delayed attrs later.

	Signed-off-by: Allison Collins <allison.henderson@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Chandan Rajendra <chandanrlinux@gmail.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Acked-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit db1a28cc591c1abe5470bedca1a489bb165c4c7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr.c
diff --cc fs/xfs/libxfs/xfs_attr.c
index 25860d669bf6,93a1c55cceb2..000000000000
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@@ -189,14 -197,72 +189,74 @@@ xfs_attr_try_sf_addname
  	if (!error && !(args->op_flags & XFS_DA_OP_NOTIME))
  		xfs_trans_ichgtime(args->trans, dp, XFS_ICHGTIME_CHG);
  
 -	if (dp->i_mount->m_flags & XFS_MOUNT_WSYNC)
 +	if (mp->m_flags & XFS_MOUNT_WSYNC)
  		xfs_trans_set_sync(args->trans);
  
 -	return error;
 +	error2 = xfs_trans_commit(args->trans);
 +	args->trans = NULL;
 +	return error ? error : error2;
  }
  
+ /*
+  * Check to see if the attr should be upgraded from non-existent or shortform to
+  * single-leaf-block attribute list.
+  */
+ static inline bool
+ xfs_attr_is_shortform(
+ 	struct xfs_inode    *ip)
+ {
+ 	return ip->i_afp->if_format == XFS_DINODE_FMT_LOCAL ||
+ 	       (ip->i_afp->if_format == XFS_DINODE_FMT_EXTENTS &&
+ 		ip->i_afp->if_nextents == 0);
+ }
+ 
+ /*
+  * Attempts to set an attr in shortform, or converts short form to leaf form if
+  * there is not enough room.  If the attr is set, the transaction is committed
+  * and set to NULL.
+  */
+ STATIC int
+ xfs_attr_set_shortform(
+ 	struct xfs_da_args	*args,
+ 	struct xfs_buf		**leaf_bp)
+ {
+ 	struct xfs_inode	*dp = args->dp;
+ 	int			error, error2 = 0;
+ 
+ 	/*
+ 	 * Try to add the attr to the attribute list in the inode.
+ 	 */
+ 	error = xfs_attr_try_sf_addname(dp, args);
+ 	if (error != -ENOSPC) {
+ 		error2 = xfs_trans_commit(args->trans);
+ 		args->trans = NULL;
+ 		return error ? error : error2;
+ 	}
+ 	/*
+ 	 * It won't fit in the shortform, transform to a leaf block.  GROT:
+ 	 * another possible req'mt for a double-split btree op.
+ 	 */
+ 	error = xfs_attr_shortform_to_leaf(args, leaf_bp);
+ 	if (error)
+ 		return error;
+ 
+ 	/*
+ 	 * Prevent the leaf buffer from being unlocked so that a concurrent AIL
+ 	 * push cannot grab the half-baked leaf buffer and run into problems
+ 	 * with the write verifier. Once we're done rolling the transaction we
+ 	 * can release the hold and add the attr to the leaf.
+ 	 */
+ 	xfs_trans_bhold(args->trans, *leaf_bp);
+ 	error = xfs_defer_finish(&args->trans);
+ 	xfs_trans_bhold_release(args->trans, *leaf_bp);
+ 	if (error) {
+ 		xfs_trans_brelse(args->trans, *leaf_bp);
+ 		return error;
+ 	}
+ 
+ 	return 0;
+ }
+ 
  /*
   * Set the attribute specified in @args.
   */
@@@ -206,57 -272,52 +266,60 @@@ xfs_attr_set_args
  {
  	struct xfs_inode	*dp = args->dp;
  	struct xfs_buf          *leaf_bp = NULL;
++<<<<<<< HEAD
 +	int			error;
++=======
+ 	int			error = 0;
++>>>>>>> db1a28cc591c (xfs: Add helpers xfs_attr_is_shortform and xfs_attr_set_shortform)
  
  	/*
- 	 * If the attribute list is non-existent or a shortform list,
- 	 * upgrade it to a single-leaf-block attribute list.
+ 	 * If the attribute list is already in leaf format, jump straight to
+ 	 * leaf handling.  Otherwise, try to add the attribute to the shortform
+ 	 * list; if there's no room then convert the list to leaf format and try
+ 	 * again.
  	 */
++<<<<<<< HEAD
 +	if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||
 +	    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&
 +	     dp->i_d.di_anextents == 0)) {
 +
 +		/*
 +		 * Build initial attribute list (if required).
 +		 */
 +		if (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)
 +			xfs_attr_shortform_create(args);
++=======
+ 	if (xfs_attr_is_shortform(dp)) {
++>>>>>>> db1a28cc591c (xfs: Add helpers xfs_attr_is_shortform and xfs_attr_set_shortform)
  
  		/*
- 		 * Try to add the attr to the attribute list in the inode.
+ 		 * If the attr was successfully set in shortform, the
+ 		 * transaction is committed and set to NULL.  Otherwise, is it
+ 		 * converted from shortform to leaf, and the transaction is
+ 		 * retained.
  		 */
 -		error = xfs_attr_set_shortform(args, &leaf_bp);
 -		if (error || !args->trans)
 -			return error;
 -	}
 -
 -	if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {
 -		error = xfs_attr_leaf_addname(args);
++<<<<<<< HEAD
 +		error = xfs_attr_try_sf_addname(dp, args);
  		if (error != -ENOSPC)
  			return error;
  
  		/*
 -		 * Finish any deferred work items and roll the transaction once
 -		 * more.  The goal here is to call node_addname with the inode
 -		 * and transaction in the same state (inode locked and joined,
 -		 * transaction clean) no matter how we got to this step.
 +		 * It won't fit in the shortform, transform to a leaf block.
 +		 * GROT: another possible req'mt for a double-split btree op.
  		 */
 -		error = xfs_defer_finish(&args->trans);
 -		if (error)
 -			return error;
 -
 -		/*
 -		 * Commit the current trans (including the inode) and
 -		 * start a new one.
 -		 */
 -		error = xfs_trans_roll_inode(&args->trans, dp);
 +		error = xfs_attr_shortform_to_leaf(args, &leaf_bp);
  		if (error)
++=======
++		error = xfs_attr_set_shortform(args, &leaf_bp);
++		if (error || !args->trans)
++>>>>>>> db1a28cc591c (xfs: Add helpers xfs_attr_is_shortform and xfs_attr_set_shortform)
  			return error;
- 
- 		/*
- 		 * Prevent the leaf buffer from being unlocked so that a
- 		 * concurrent AIL push cannot grab the half-baked leaf
- 		 * buffer and run into problems with the write verifier.
- 		 * Once we're done rolling the transaction we can release
- 		 * the hold and add the attr to the leaf.
- 		 */
- 		xfs_trans_bhold(args->trans, leaf_bp);
- 		error = xfs_defer_finish(&args->trans);
- 		xfs_trans_bhold_release(args->trans, leaf_bp);
- 		if (error) {
- 			xfs_trans_brelse(args->trans, leaf_bp);
- 			return error;
- 		}
  	}
  
 -	error = xfs_attr_node_addname(args);
 +	if (xfs_bmap_one_block(dp, XFS_ATTR_FORK))
 +		error = xfs_attr_leaf_addname(args);
 +	else
 +		error = xfs_attr_node_addname(args);
  	return error;
  }
  
* Unmerged path fs/xfs/libxfs/xfs_attr.c
