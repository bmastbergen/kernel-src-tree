net/mlx5e: Use nic mode netdev ndos and ethtool ops for uplink representor

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Roi Dayan <roid@nvidia.com>
commit c97a2c06919ae8cf09773b8dfa24909ccfba9316
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/c97a2c06.failed

Remove dedicated uplink rep netdev ndos and ethtools ops.
We will re-use the native NIC port net device instance and ethtool ops for
the Uplink representor.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit c97a2c06919ae8cf09773b8dfa24909ccfba9316)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 0350572b18db,9533085005c3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -641,31 -535,10 +535,35 @@@ static const struct net_device_ops mlx5
  	.ndo_change_carrier      = mlx5e_rep_change_carrier,
  };
  
++<<<<<<< HEAD
 +static const struct net_device_ops mlx5e_netdev_ops_uplink_rep = {
 +	.ndo_open                = mlx5e_open,
 +	.ndo_stop                = mlx5e_close,
 +	.ndo_start_xmit          = mlx5e_xmit,
 +	.ndo_set_mac_address     = mlx5e_uplink_rep_set_mac,
 +	.ndo_setup_tc            = mlx5e_rep_setup_tc,
 +	.ndo_get_devlink_port    = mlx5e_rep_get_devlink_port,
 +	.ndo_get_stats64         = mlx5e_get_stats,
 +	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
 +	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
 +	.ndo_change_mtu          = mlx5e_uplink_rep_change_mtu,
 +	.ndo_udp_tunnel_add      = udp_tunnel_nic_add_port,
 +	.ndo_udp_tunnel_del      = udp_tunnel_nic_del_port,
 +	.ndo_features_check      = mlx5e_features_check,
 +	.ndo_set_vf_mac          = mlx5e_set_vf_mac,
 +	.ndo_set_vf_rate         = mlx5e_set_vf_rate,
 +	.ndo_get_vf_config       = mlx5e_get_vf_config,
 +	.ndo_get_vf_stats        = mlx5e_get_vf_stats,
 +	.ndo_set_vf_vlan         = mlx5e_uplink_rep_set_vf_vlan,
 +	.ndo_set_features        = mlx5e_set_features,
 +};
 +
++=======
++>>>>>>> c97a2c06919a (net/mlx5e: Use nic mode netdev ndos and ethtool ops for uplink representor)
  bool mlx5e_eswitch_uplink_rep(struct net_device *netdev)
  {
- 	return netdev->netdev_ops == &mlx5e_netdev_ops_uplink_rep;
+ 	return netdev->netdev_ops == &mlx5e_netdev_ops &&
+ 	       mlx5e_is_uplink_rep(netdev_priv(netdev));
  }
  
  bool mlx5e_eswitch_vf_rep(struct net_device *netdev)
@@@ -711,20 -587,16 +609,24 @@@ static void mlx5e_build_rep_params(stru
  	mlx5e_build_rss_params(&priv->rss_params, params->num_channels);
  }
  
 -static void mlx5e_build_rep_netdev(struct net_device *netdev,
 -				   struct mlx5_core_dev *mdev,
 -				   struct mlx5_eswitch_rep *rep)
 +static void mlx5e_build_rep_netdev(struct net_device *netdev)
  {
 +	struct mlx5e_priv *priv = netdev_priv(netdev);
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 +	struct mlx5_eswitch_rep *rep = rpriv->rep;
 +	struct mlx5_core_dev *mdev = priv->mdev;
 +
  	SET_NETDEV_DEV(netdev, mdev->device);
  	if (rep->vport == MLX5_VPORT_UPLINK) {
- 		netdev->netdev_ops = &mlx5e_netdev_ops_uplink_rep;
+ 		netdev->netdev_ops = &mlx5e_netdev_ops;
  		/* we want a persistent mac for the uplink rep */
  		mlx5_query_mac_address(mdev, netdev->dev_addr);
++<<<<<<< HEAD
 +		netdev->ethtool_ops = &mlx5e_uplink_rep_ethtool_ops;
 +		mlx5e_vxlan_set_netdev_info(priv);
++=======
+ 		netdev->ethtool_ops = &mlx5e_ethtool_ops;
++>>>>>>> c97a2c06919a (net/mlx5e: Use nic mode netdev ndos and ethtool ops for uplink representor)
  		mlx5e_dcbnl_build_rep_netdev(netdev);
  	} else {
  		netdev->netdev_ops = &mlx5e_netdev_ops_rep;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
