RDMA/mlx5: Fail QP creation if the device can not support the CQE TS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Aharon Landau <aharonl@nvidia.com>
commit 2fe8d4b87802dcde7fa015229c84bb726f631b4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/2fe8d4b8.failed

In ConnectX6Dx device, HW can work in real time timestamp mode according
to the device capabilities per RQ/SQ/QP.

When the flag IB_UVERBS_CQ_FLAGS_TIMESTAMP_COMPLETION is set, the user
expect to get TS on the CQEs in free running format, so we need to fail
the QP creation if the current mode of the device doesn't support it.

Link: https://lore.kernel.org/r/20210209131107.698833-3-leon@kernel.org
	Signed-off-by: Aharon Landau <aharonl@nvidia.com>
	Signed-off-by: Maor Gottlieb <maorg@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 2fe8d4b87802dcde7fa015229c84bb726f631b4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 352114fcd4c0,2e234fecc00e..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -1209,18 -1248,29 +1272,28 @@@ static int create_raw_packet_qp_sq(stru
  	void *wq;
  	int inlen;
  	int err;
++<<<<<<< HEAD
 +	int page_shift = 0;
 +	int npages;
 +	int ncont = 0;
 +	u32 offset = 0;
++=======
+ 	unsigned int page_offset_quantized;
+ 	unsigned long page_size;
+ 	int ts_format;
+ 
+ 	ts_format = get_sq_ts_format(dev, cq);
+ 	if (ts_format < 0)
+ 		return ts_format;
++>>>>>>> 2fe8d4b87802 (RDMA/mlx5: Fail QP creation if the device can not support the CQE TS)
  
 -	sq->ubuffer.umem = ib_umem_get(&dev->ib_dev, ubuffer->buf_addr,
 -				       ubuffer->buf_size, 0);
 -	if (IS_ERR(sq->ubuffer.umem))
 -		return PTR_ERR(sq->ubuffer.umem);
 -	page_size = mlx5_umem_find_best_quantized_pgoff(
 -		ubuffer->umem, wq, log_wq_pg_sz, MLX5_ADAPTER_PAGE_SHIFT,
 -		page_offset, 64, &page_offset_quantized);
 -	if (!page_size) {
 -		err = -EINVAL;
 -		goto err_umem;
 -	}
 +	err = mlx5_ib_umem_get(dev, udata, ubuffer->buf_addr, ubuffer->buf_size,
 +			       &sq->ubuffer.umem, &npages, &page_shift, &ncont,
 +			       &offset);
 +	if (err)
 +		return err;
  
 -	inlen = MLX5_ST_SZ_BYTES(create_sq_in) +
 -		sizeof(u64) *
 -			ib_umem_num_dma_blocks(sq->ubuffer.umem, page_size);
 +	inlen = MLX5_ST_SZ_BYTES(create_sq_in) + sizeof(u64) * ncont;
  	in = kvzalloc(inlen, GFP_KERNEL);
  	if (!in) {
  		err = -ENOMEM;
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
