ALSA: usb-audio: Constify audioformat pointer references

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit cab941b7e5cf054502b01f776db724400ee5c1b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/cab941b7.failed

The audioformat is referred in many places but most of usages are
read-only.  Let's add const prefix in the possible places.

	Tested-by: Keith Milner <kamilner@superlative.org>
	Tested-by: Dylan Robinson <dylan_robinson@motu.com>
Link: https://lore.kernel.org/r/20201123085347.19667-28-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit cab941b7e5cf054502b01f776db724400ee5c1b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/card.h
#	sound/usb/endpoint.c
#	sound/usb/endpoint.h
#	sound/usb/pcm.c
diff --cc sound/usb/card.h
index ce446f8dba4b,53f0ce61f858..000000000000
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@@ -111,11 -113,14 +111,15 @@@ struct snd_usb_endpoint 
  	unsigned char silence_value;
  	unsigned int stride;
  	int iface, altsetting;
 -	unsigned char ep_idx;		/* endpoint array index */
  	int skip_packets;		/* quirks for devices to ignore the first n packets
  					   in a stream */
 -	bool implicit_fb_sync;		/* syncs with implicit feedback */
 -	bool need_setup;		/* (re-)need for configure? */
 +	bool is_implicit_feedback;      /* This endpoint is used as implicit feedback */
  
  	/* for hw constraints */
++<<<<<<< HEAD
++=======
+ 	const struct audioformat *cur_audiofmt;
++>>>>>>> cab941b7e5cf (ALSA: usb-audio: Constify audioformat pointer references)
  	unsigned int cur_rate;
  	snd_pcm_format_t cur_format;
  	unsigned int cur_channels;
diff --cc sound/usb/endpoint.c
index 208ac2aff462,49fb934ee432..000000000000
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@@ -548,25 -552,155 +548,101 @@@ int snd_usb_add_endpoint(struct snd_usb
  }
  
  /* Set up syncinterval and maxsyncsize for a sync EP */
 -static void endpoint_set_syncinterval(struct snd_usb_audio *chip,
 -				      struct snd_usb_endpoint *ep)
 +void snd_usb_endpoint_set_syncinterval(struct snd_usb_audio *chip,
 +				       struct snd_usb_endpoint *ep,
 +				       struct usb_host_interface *alts)
  {
 -	struct usb_host_interface *alts;
 -	struct usb_endpoint_descriptor *desc;
 -
 -	alts = snd_usb_get_host_interface(chip, ep->iface, ep->altsetting);
 -	if (!alts)
 -		return;
 +	struct usb_endpoint_descriptor *desc = get_endpoint(alts, 1);
 +
 +	if (ep->type == SND_USB_ENDPOINT_TYPE_SYNC) {
 +		if (desc->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&
 +		    desc->bRefresh >= 1 && desc->bRefresh <= 9)
 +			ep->syncinterval = desc->bRefresh;
 +		else if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)
 +			ep->syncinterval = 1;
 +		else if (desc->bInterval >= 1 && desc->bInterval <= 16)
 +			ep->syncinterval = desc->bInterval - 1;
 +		else
 +			ep->syncinterval = 3;
  
++<<<<<<< HEAD
 +		ep->syncmaxsize = le16_to_cpu(desc->wMaxPacketSize);
++=======
+ 	desc = get_endpoint(alts, ep->ep_idx);
+ 	if (desc->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&
+ 	    desc->bRefresh >= 1 && desc->bRefresh <= 9)
+ 		ep->syncinterval = desc->bRefresh;
+ 	else if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)
+ 		ep->syncinterval = 1;
+ 	else if (desc->bInterval >= 1 && desc->bInterval <= 16)
+ 		ep->syncinterval = desc->bInterval - 1;
+ 	else
+ 		ep->syncinterval = 3;
+ 
+ 	ep->syncmaxsize = le16_to_cpu(desc->wMaxPacketSize);
+ }
+ 
+ static bool endpoint_compatible(struct snd_usb_endpoint *ep,
+ 				const struct audioformat *fp,
+ 				const struct snd_pcm_hw_params *params)
+ {
+ 	if (!ep->opened)
+ 		return false;
+ 	if (ep->cur_audiofmt != fp)
+ 		return false;
+ 	if (ep->cur_rate != params_rate(params) ||
+ 	    ep->cur_format != params_format(params) ||
+ 	    ep->cur_period_frames != params_period_size(params) ||
+ 	    ep->cur_buffer_periods != params_periods(params))
+ 		return false;
+ 	return true;
+ }
+ 
+ /*
+  * Check whether the given fp and hw params are compatbile with the current
+  * setup of the target EP for implicit feedback sync
+  */
+ bool snd_usb_endpoint_compatible(struct snd_usb_audio *chip,
+ 				 struct snd_usb_endpoint *ep,
+ 				 const struct audioformat *fp,
+ 				 const struct snd_pcm_hw_params *params)
+ {
+ 	bool ret;
+ 
+ 	mutex_lock(&chip->mutex);
+ 	ret = endpoint_compatible(ep, fp, params);
+ 	mutex_unlock(&chip->mutex);
+ 	return ret;
+ }
+ 
+ /*
+  * snd_usb_endpoint_open: Open the endpoint
+  *
+  * Called from hw_params to assign the endpoint to the substream.
+  * It's reference-counted, and only the first opener is allowed to set up
+  * arbitrary parameters.  The later opener must be compatible with the
+  * former opened parameters.
+  * The endpoint needs to be closed via snd_usb_endpoint_close() later.
+  *
+  * Note that this function doesn't configure the endpoint.  The substream
+  * needs to set it up later via snd_usb_endpoint_configure().
+  */
+ struct snd_usb_endpoint *
+ snd_usb_endpoint_open(struct snd_usb_audio *chip,
+ 		      const struct audioformat *fp,
+ 		      const struct snd_pcm_hw_params *params,
+ 		      bool is_sync_ep)
+ {
+ 	struct snd_usb_endpoint *ep;
+ 	int ep_num = is_sync_ep ? fp->sync_ep : fp->endpoint;
+ 
+ 	mutex_lock(&chip->mutex);
+ 	ep = snd_usb_get_endpoint(chip, ep_num);
+ 	if (!ep) {
+ 		usb_audio_err(chip, "Cannot find EP 0x%x to open\n", ep_num);
+ 		goto unlock;
++>>>>>>> cab941b7e5cf (ALSA: usb-audio: Constify audioformat pointer references)
  	}
 -
 -	if (!ep->opened) {
 -		if (is_sync_ep) {
 -			ep->iface = fp->sync_iface;
 -			ep->altsetting = fp->sync_altsetting;
 -			ep->ep_idx = fp->sync_ep_idx;
 -		} else {
 -			ep->iface = fp->iface;
 -			ep->altsetting = fp->altsetting;
 -			ep->ep_idx = 0;
 -		}
 -		usb_audio_dbg(chip, "Open EP 0x%x, iface=%d:%d, idx=%d\n",
 -			      ep_num, ep->iface, ep->altsetting, ep->ep_idx);
 -
 -		ep->cur_audiofmt = fp;
 -		ep->cur_channels = fp->channels;
 -		ep->cur_rate = params_rate(params);
 -		ep->cur_format = params_format(params);
 -		ep->cur_frame_bytes = snd_pcm_format_physical_width(ep->cur_format) *
 -			ep->cur_channels / 8;
 -		ep->cur_period_frames = params_period_size(params);
 -		ep->cur_period_bytes = ep->cur_period_frames * ep->cur_frame_bytes;
 -		ep->cur_buffer_periods = params_periods(params);
 -
 -		if (ep->type == SND_USB_ENDPOINT_TYPE_SYNC)
 -			endpoint_set_syncinterval(chip, ep);
 -
 -		ep->implicit_fb_sync = fp->implicit_fb;
 -		ep->need_setup = true;
 -
 -		usb_audio_dbg(chip, "  channels=%d, rate=%d, format=%s, period_bytes=%d, periods=%d, implicit_fb=%d\n",
 -			      ep->cur_channels, ep->cur_rate,
 -			      snd_pcm_format_name(ep->cur_format),
 -			      ep->cur_period_bytes, ep->cur_buffer_periods,
 -			      ep->implicit_fb_sync);
 -
 -	} else {
 -		if (!endpoint_compatible(ep, fp, params)) {
 -			usb_audio_err(chip, "Incompatible EP setup for 0x%x\n",
 -				      ep_num);
 -			ep = NULL;
 -			goto unlock;
 -		}
 -
 -		usb_audio_dbg(chip, "Reopened EP 0x%x (count %d)\n",
 -			      ep_num, ep->opened);
 -	}
 -
 -	ep->opened++;
 -
 - unlock:
 -	mutex_unlock(&chip->mutex);
 -	return ep;
 -}
 -
 -/*
 - * snd_usb_endpoint_set_sync: Link data and sync endpoints
 - *
 - * Pass NULL to sync_ep to unlink again
 - */
 -void snd_usb_endpoint_set_sync(struct snd_usb_audio *chip,
 -			       struct snd_usb_endpoint *data_ep,
 -			       struct snd_usb_endpoint *sync_ep)
 -{
 -	data_ep->sync_master = sync_ep;
  }
  
  /*
diff --cc sound/usb/endpoint.h
index e2fddb3dcf7a,201011d89659..000000000000
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@@ -10,16 -10,25 +10,29 @@@ struct snd_usb_endpoint *snd_usb_get_en
  
  int snd_usb_add_endpoint(struct snd_usb_audio *chip, int ep_num, int type);
  
++<<<<<<< HEAD
 +int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 +				snd_pcm_format_t pcm_format,
 +				unsigned int channels,
 +				unsigned int period_bytes,
 +				unsigned int period_frames,
 +				unsigned int buffer_periods,
 +				unsigned int rate,
 +				struct audioformat *fmt,
 +				struct snd_usb_endpoint *sync_ep);
++=======
+ struct snd_usb_endpoint *
+ snd_usb_endpoint_open(struct snd_usb_audio *chip,
+ 		      const struct audioformat *fp,
+ 		      const struct snd_pcm_hw_params *params,
+ 		      bool is_sync_ep);
+ void snd_usb_endpoint_close(struct snd_usb_audio *chip,
+ 			    struct snd_usb_endpoint *ep);
+ int snd_usb_endpoint_configure(struct snd_usb_audio *chip,
+ 			       struct snd_usb_endpoint *ep);
+ void snd_usb_endpoint_suspend(struct snd_usb_endpoint *ep);
++>>>>>>> cab941b7e5cf (ALSA: usb-audio: Constify audioformat pointer references)
  
 -bool snd_usb_endpoint_compatible(struct snd_usb_audio *chip,
 -				 struct snd_usb_endpoint *ep,
 -				 const struct audioformat *fp,
 -				 const struct snd_pcm_hw_params *params);
 -
 -void snd_usb_endpoint_set_sync(struct snd_usb_audio *chip,
 -			       struct snd_usb_endpoint *data_ep,
 -			       struct snd_usb_endpoint *sync_ep);
  void snd_usb_endpoint_set_callback(struct snd_usb_endpoint *ep,
  				   void (*prepare)(struct snd_usb_substream *subs,
  						   struct urb *urb),
diff --cc sound/usb/pcm.c
index 6f25783cf701,fc028492dd1a..000000000000
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@@ -79,14 -80,13 +79,21 @@@ static snd_pcm_uframes_t snd_usb_pcm_po
  /*
   * find a matching audio format
   */
++<<<<<<< HEAD
 +static struct audioformat *find_format(struct list_head *fmt_list_head,
 +				       snd_pcm_format_t format,
 +				       unsigned int rate,
 +				       unsigned int channels,
 +				       struct snd_usb_substream *subs)
++=======
+ static const struct audioformat *
+ find_format(struct list_head *fmt_list_head, snd_pcm_format_t format,
+ 	    unsigned int rate, unsigned int channels, bool strict_match,
+ 	    struct snd_usb_substream *subs)
++>>>>>>> cab941b7e5cf (ALSA: usb-audio: Constify audioformat pointer references)
  {
- 	struct audioformat *fp;
- 	struct audioformat *found = NULL;
+ 	const struct audioformat *fp;
+ 	const struct audioformat *found = NULL;
  	int cur_attr = 0, attr;
  
  	list_for_each_entry(fp, fmt_list_head, list) {
@@@ -139,17 -141,18 +146,23 @@@
  	return found;
  }
  
++<<<<<<< HEAD
 +static struct audioformat *find_substream_format(struct snd_usb_substream *subs)
++=======
+ static const struct audioformat *
+ find_substream_format(struct snd_usb_substream *subs,
+ 		      const struct snd_pcm_hw_params *params)
++>>>>>>> cab941b7e5cf (ALSA: usb-audio: Constify audioformat pointer references)
  {
 -	return find_format(&subs->fmt_list, params_format(params),
 -			   params_rate(params), params_channels(params),
 -			   true, subs);
 +	return find_format(&subs->fmt_list, subs->pcm_format, subs->cur_rate,
 +			   subs->channels, subs);
  }
  
 -static int init_pitch_v1(struct snd_usb_audio *chip, int ep)
 +static int init_pitch_v1(struct snd_usb_audio *chip,
 +			 struct audioformat *fmt)
  {
  	struct usb_device *dev = chip->dev;
 +	unsigned int ep;
  	unsigned char data[1];
  	int err;
  
@@@ -194,8 -182,10 +207,8 @@@ static int init_pitch_v2(struct snd_usb
   * initialize the pitch control and sample rate
   */
  int snd_usb_init_pitch(struct snd_usb_audio *chip,
- 		       struct audioformat *fmt)
+ 		       const struct audioformat *fmt)
  {
 -	int err;
 -
  	/* if endpoint doesn't have pitch control, bail out */
  	if (!(fmt->attributes & UAC_EP_CS_ATTR_PITCH_CONTROL))
  		return 0;
@@@ -867,6 -625,92 +880,95 @@@ int snd_usb_pcm_resume(struct snd_usb_s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static struct snd_usb_substream *
+ find_matching_substream(struct snd_usb_audio *chip, int stream, int ep_num,
+ 			int fmt_type)
+ {
+ 	struct snd_usb_stream *as;
+ 	struct snd_usb_substream *subs;
+ 
+ 	list_for_each_entry(as, &chip->pcm_list, list) {
+ 		subs = &as->substream[stream];
+ 		if (as->fmt_type == fmt_type && subs->ep_num == ep_num)
+ 			return subs;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static const struct audioformat *
+ find_implicit_fb_sync_format(struct snd_usb_audio *chip,
+ 			     const struct audioformat *target,
+ 			     const struct snd_pcm_hw_params *params,
+ 			     int stream)
+ {
+ 	struct snd_usb_substream *subs;
+ 	const struct audioformat *fp, *sync_fmt;
+ 	int score, high_score;
+ 
+ 	subs = find_matching_substream(chip, stream, target->sync_ep,
+ 				       target->fmt_type);
+ 	if (!subs)
+ 		return NULL;
+ 
+ 	sync_fmt = NULL;
+ 	high_score = 0;
+ 	list_for_each_entry(fp, &subs->fmt_list, list) {
+ 		score = match_endpoint_audioformats(subs, fp,
+ 						    params_rate(params),
+ 						    params_channels(params),
+ 						    params_format(params));
+ 		if (score > high_score) {
+ 			sync_fmt = fp;
+ 			high_score = score;
+ 		}
+ 	}
+ 
+ 	return sync_fmt;
+ }
+ 
+ static void close_endpoints(struct snd_usb_audio *chip,
+ 			    struct snd_usb_substream *subs)
+ {
+ 	if (subs->data_endpoint) {
+ 		snd_usb_endpoint_set_sync(chip, subs->data_endpoint, NULL);
+ 		snd_usb_endpoint_close(chip, subs->data_endpoint);
+ 		subs->data_endpoint = NULL;
+ 	}
+ 
+ 	if (subs->sync_endpoint) {
+ 		snd_usb_endpoint_close(chip, subs->sync_endpoint);
+ 		subs->sync_endpoint = NULL;
+ 	}
+ }
+ 
+ static int configure_endpoints(struct snd_usb_audio *chip,
+ 			       struct snd_usb_substream *subs)
+ {
+ 	int err;
+ 
+ 	if (subs->data_endpoint->need_setup) {
+ 		/* stop any running stream beforehand */
+ 		if (stop_endpoints(subs))
+ 			sync_pending_stops(subs);
+ 		err = snd_usb_endpoint_configure(chip, subs->data_endpoint);
+ 		if (err < 0)
+ 			return err;
+ 		snd_usb_set_format_quirk(subs, subs->cur_audiofmt);
+ 	}
+ 
+ 	if (subs->sync_endpoint) {
+ 		err = snd_usb_endpoint_configure(chip, subs->sync_endpoint);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> cab941b7e5cf (ALSA: usb-audio: Constify audioformat pointer references)
  /*
   * hw_params callback
   *
@@@ -881,27 -725,47 +983,33 @@@ static int snd_usb_hw_params(struct snd
  			     struct snd_pcm_hw_params *hw_params)
  {
  	struct snd_usb_substream *subs = substream->runtime->private_data;
++<<<<<<< HEAD
 +	struct audioformat *fmt;
++=======
+ 	struct snd_usb_audio *chip = subs->stream->chip;
+ 	const struct audioformat *fmt;
+ 	const struct audioformat *sync_fmt;
++>>>>>>> cab941b7e5cf (ALSA: usb-audio: Constify audioformat pointer references)
  	int ret;
  
 -	ret = snd_media_start_pipeline(subs);
 -	if (ret)
 -		return ret;
 +	subs->pcm_format = params_format(hw_params);
 +	subs->period_bytes = params_period_bytes(hw_params);
 +	subs->period_frames = params_period_size(hw_params);
 +	subs->buffer_periods = params_periods(hw_params);
 +	subs->channels = params_channels(hw_params);
 +	subs->cur_rate = params_rate(hw_params);
  
 -	fmt = find_substream_format(subs, hw_params);
 +	fmt = find_substream_format(subs);
  	if (!fmt) {
 -		usb_audio_dbg(chip,
 -			      "cannot find format: format=%s, rate=%d, channels=%d\n",
 -			      snd_pcm_format_name(params_format(hw_params)),
 -			      params_rate(hw_params), params_channels(hw_params));
 -		ret = -EINVAL;
 -		goto stop_pipeline;
 -	}
 -
 -	if (fmt->implicit_fb &&
 -	    (fmt->iface != fmt->sync_iface ||
 -	     fmt->altsetting != fmt->sync_altsetting)) {
 -		sync_fmt = find_implicit_fb_sync_format(chip, fmt, hw_params,
 -							!substream->stream);
 -		if (!sync_fmt) {
 -			usb_audio_dbg(chip,
 -				      "cannot find sync format: ep=0x%x, iface=%d:%d, format=%s, rate=%d, channels=%d\n",
 -				      fmt->sync_ep, fmt->sync_iface,
 -				      fmt->sync_altsetting,
 -				      snd_pcm_format_name(params_format(hw_params)),
 -				      params_rate(hw_params), params_channels(hw_params));
 -			ret = -EINVAL;
 -			goto stop_pipeline;
 -		}
 -	} else {
 -		sync_fmt = fmt;
 +		dev_dbg(&subs->dev->dev,
 +			"cannot set format: format = %#x, rate = %d, channels = %d\n",
 +			   subs->pcm_format, subs->cur_rate, subs->channels);
 +		return -EINVAL;
  	}
  
 -	ret = snd_usb_lock_shutdown(chip);
 +	ret = snd_usb_lock_shutdown(subs->stream->chip);
  	if (ret < 0)
 -		goto stop_pipeline;
 +		return ret;
  
  	ret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D0);
  	if (ret < 0)
@@@ -1236,10 -1109,9 +1344,10 @@@ static int apply_hw_constraint_from_syn
  {
  	struct snd_usb_audio *chip = subs->stream->chip;
  	struct snd_usb_endpoint *ep;
- 	struct audioformat *fp;
+ 	const struct audioformat *fp;
  	int err;
  
 +	subs->fixed_hw = 0;
  	list_for_each_entry(fp, &subs->fmt_list, list) {
  		ep = snd_usb_get_endpoint(chip, fp->endpoint);
  		if (ep && ep->cur_rate)
* Unmerged path sound/usb/card.h
diff --git a/sound/usb/clock.c b/sound/usb/clock.c
index e1fec82cc59e..31843507b4c8 100644
--- a/sound/usb/clock.c
+++ b/sound/usb/clock.c
@@ -152,7 +152,7 @@ static int uac_clock_selector_set_val(struct snd_usb_audio *chip, int selector_i
 }
 
 static bool uac_clock_source_is_valid_quirk(struct snd_usb_audio *chip,
-					    struct audioformat *fmt,
+					    const struct audioformat *fmt,
 					    int source_id)
 {
 	bool ret = false;
@@ -215,7 +215,7 @@ static bool uac_clock_source_is_valid_quirk(struct snd_usb_audio *chip,
 }
 
 static bool uac_clock_source_is_valid(struct snd_usb_audio *chip,
-				      struct audioformat *fmt,
+				      const struct audioformat *fmt,
 				      int source_id)
 {
 	int err;
@@ -264,7 +264,7 @@ static bool uac_clock_source_is_valid(struct snd_usb_audio *chip,
 }
 
 static int __uac_clock_find_source(struct snd_usb_audio *chip,
-				   struct audioformat *fmt, int entity_id,
+				   const struct audioformat *fmt, int entity_id,
 				   unsigned long *visited, bool validate)
 {
 	struct uac_clock_source_descriptor *source;
@@ -358,7 +358,7 @@ static int __uac_clock_find_source(struct snd_usb_audio *chip,
 }
 
 static int __uac3_clock_find_source(struct snd_usb_audio *chip,
-				    struct audioformat *fmt, int entity_id,
+				    const struct audioformat *fmt, int entity_id,
 				    unsigned long *visited, bool validate)
 {
 	struct uac3_clock_source_descriptor *source;
@@ -464,7 +464,7 @@ static int __uac3_clock_find_source(struct snd_usb_audio *chip,
  * Returns the clock source UnitID (>=0) on success, or an error.
  */
 int snd_usb_clock_find_source(struct snd_usb_audio *chip,
-			      struct audioformat *fmt, bool validate)
+			      const struct audioformat *fmt, bool validate)
 {
 	DECLARE_BITMAP(visited, 256);
 	memset(visited, 0, sizeof(visited));
@@ -482,7 +482,7 @@ int snd_usb_clock_find_source(struct snd_usb_audio *chip,
 }
 
 static int set_sample_rate_v1(struct snd_usb_audio *chip,
-			      struct audioformat *fmt, int rate)
+			      const struct audioformat *fmt, int rate)
 {
 	struct usb_device *dev = chip->dev;
 	struct usb_host_interface *alts;
@@ -611,7 +611,7 @@ int snd_usb_set_sample_rate_v2v3(struct snd_usb_audio *chip,
 }
 
 static int set_sample_rate_v2v3(struct snd_usb_audio *chip,
-				struct audioformat *fmt, int rate)
+				const struct audioformat *fmt, int rate)
 {
 	struct usb_device *dev = chip->dev;
 	int cur_rate, prev_rate;
@@ -673,7 +673,7 @@ static int set_sample_rate_v2v3(struct snd_usb_audio *chip,
 }
 
 int snd_usb_init_sample_rate(struct snd_usb_audio *chip,
-			     struct audioformat *fmt, int rate)
+			     const struct audioformat *fmt, int rate)
 {
 	switch (fmt->protocol) {
 	case UAC_VERSION_1:
diff --git a/sound/usb/clock.h b/sound/usb/clock.h
index 8d406ed294d6..ed9fc2dc0510 100644
--- a/sound/usb/clock.h
+++ b/sound/usb/clock.h
@@ -3,10 +3,10 @@
 #define __USBAUDIO_CLOCK_H
 
 int snd_usb_init_sample_rate(struct snd_usb_audio *chip,
-			     struct audioformat *fmt, int rate);
+			     const struct audioformat *fmt, int rate);
 
 int snd_usb_clock_find_source(struct snd_usb_audio *chip,
-			      struct audioformat *fmt, bool validate);
+			      const struct audioformat *fmt, bool validate);
 
 int snd_usb_set_sample_rate_v2v3(struct snd_usb_audio *chip,
 				 const struct audioformat *fmt,
* Unmerged path sound/usb/endpoint.c
* Unmerged path sound/usb/endpoint.h
* Unmerged path sound/usb/pcm.c
diff --git a/sound/usb/pcm.h b/sound/usb/pcm.h
index a4f784225abc..06c586467d3f 100644
--- a/sound/usb/pcm.h
+++ b/sound/usb/pcm.h
@@ -10,7 +10,7 @@ int snd_usb_pcm_suspend(struct snd_usb_stream *as);
 int snd_usb_pcm_resume(struct snd_usb_stream *as);
 
 int snd_usb_init_pitch(struct snd_usb_audio *chip,
-		       struct audioformat *fmt);
+		       const struct audioformat *fmt);
 void snd_usb_preallocate_buffer(struct snd_usb_substream *subs);
 
 int snd_usb_audioformat_set_sync_ep(struct snd_usb_audio *chip,
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 83bcb952d999..8e0b528b0a13 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1375,7 +1375,8 @@ int snd_usb_apply_boot_quirk_once(struct usb_device *dev,
 /*
  * check if the device uses big-endian samples
  */
-int snd_usb_is_big_endian_format(struct snd_usb_audio *chip, struct audioformat *fp)
+int snd_usb_is_big_endian_format(struct snd_usb_audio *chip,
+				 const struct audioformat *fp)
 {
 	/* it depends on altsetting whether the device is big-endian or not */
 	switch (chip->usb_id) {
@@ -1414,7 +1415,7 @@ enum {
 };
 
 static void set_format_emu_quirk(struct snd_usb_substream *subs,
-				 struct audioformat *fmt)
+				 const struct audioformat *fmt)
 {
 	unsigned char emu_samplerate_id = 0;
 
@@ -1476,7 +1477,7 @@ static int pioneer_djm_set_format_quirk(struct snd_usb_substream *subs)
 }
 
 void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
-			      struct audioformat *fmt)
+			      const struct audioformat *fmt)
 {
 	switch (subs->stream->chip->usb_id) {
 	case USB_ID(0x041e, 0x3f02): /* E-Mu 0202 USB */
@@ -1543,7 +1544,7 @@ static bool is_itf_usb_dsd_dac(unsigned int id)
 }
 
 int snd_usb_select_mode_quirk(struct snd_usb_audio *chip,
-			      struct audioformat *fmt)
+			      const struct audioformat *fmt)
 {
 	struct usb_device *dev = chip->dev;
 	int err;
diff --git a/sound/usb/quirks.h b/sound/usb/quirks.h
index 011f22cf2bf6..67a02303c820 100644
--- a/sound/usb/quirks.h
+++ b/sound/usb/quirks.h
@@ -26,12 +26,12 @@ int snd_usb_apply_boot_quirk_once(struct usb_device *dev,
 				  unsigned int usb_id);
 
 void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
-			      struct audioformat *fmt);
+			      const struct audioformat *fmt);
 
 bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip);
 
 int snd_usb_is_big_endian_format(struct snd_usb_audio *chip,
-				 struct audioformat *fp);
+				 const struct audioformat *fp);
 
 void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep);
 
@@ -41,7 +41,7 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 			   __u16 index, void *data, __u16 size);
 
 int snd_usb_select_mode_quirk(struct snd_usb_audio *chip,
-			      struct audioformat *fmt);
+			      const struct audioformat *fmt);
 
 u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 					struct audioformat *fp,
