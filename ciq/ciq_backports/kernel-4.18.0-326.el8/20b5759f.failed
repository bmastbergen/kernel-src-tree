mptcp: avoid OOB access in setsockopt()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 20b5759f21cf53a0e03031bd3fe539e332b13568
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/20b5759f.failed

We can't use tcp_set_congestion_control() on an mptcp socket, as
such function can end-up accessing a tcp-specific field -
prior_ssthresh - causing an OOB access.

To allow propagating the correct ca algo on subflow, cache the ca
name at initialization time.

Additionally avoid overriding the user-selected CA (if any) at
clone time.

Closes: https://github.com/multipath-tcp/mptcp_net-next/issues/182
Fixes: aa1fbd94e5c7 ("mptcp: sockopt: add TCP_CONGESTION and TCP_INFO")
	Acked-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 20b5759f21cf53a0e03031bd3fe539e332b13568)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
#	net/mptcp/protocol.h
#	net/mptcp/sockopt.c
diff --cc net/mptcp/protocol.c
index d500a813635c,2bc199549a88..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -2404,14 -2423,15 +2404,19 @@@ static int __mptcp_init_sock(struct soc
  	/* re-use the csk retrans timer for MPTCP-level retrans */
  	timer_setup(&msk->sk.icsk_retransmit_timer, mptcp_retransmit_timer, 0);
  	timer_setup(&sk->sk_timer, mptcp_timeout_timer, 0);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 20b5759f21cf (mptcp: avoid OOB access in setsockopt())
  	return 0;
  }
  
  static int mptcp_init_sock(struct sock *sk)
  {
+ 	struct inet_connection_sock *icsk = inet_csk(sk);
  	struct net *net = sock_net(sk);
  	int ret;
 +	static bool warned;
  
  	ret = __mptcp_init_sock(sk);
  	if (ret)
@@@ -2605,6 -2630,7 +2620,10 @@@ static void __mptcp_destroy_sock(struc
  	WARN_ON_ONCE(msk->rmem_released);
  	sk_stream_kill_queues(sk);
  	xfrm_sk_free_policy(sk);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 20b5759f21cf (mptcp: avoid OOB access in setsockopt())
  	sk_refcnt_debug_release(sk);
  	mptcp_dispose_initial_subflow(msk);
  	sock_put(sk);
diff --cc net/mptcp/protocol.h
index e6d63dde4722,165c8b40b384..000000000000
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@@ -255,6 -256,9 +255,12 @@@ struct mptcp_sock 
  		u64	time;	/* start time of measurement window */
  		u64	rtt_us; /* last maximum rtt of subflows */
  	} rcvq_space;
++<<<<<<< HEAD
++=======
+ 
+ 	u32 setsockopt_seq;
+ 	char		ca_name[TCP_CA_NAME_MAX];
++>>>>>>> 20b5759f21cf (mptcp: avoid OOB access in setsockopt())
  };
  
  #define mptcp_lock_sock(___sk, cb) do {					\
* Unmerged path net/mptcp/sockopt.c
* Unmerged path net/mptcp/protocol.c
* Unmerged path net/mptcp/protocol.h
* Unmerged path net/mptcp/sockopt.c
