xfs: Simplify xfs_attr_node_addname

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Allison Collins <allison.henderson@oracle.com>
commit bf4a5cfffee096624764d5aed82f786c708dfe90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/bf4a5cff.failed

Invert the rename logic in xfs_attr_node_addname to simplify the
delayed attr logic later.

	Signed-off-by: Allison Collins <allison.henderson@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Acked-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit bf4a5cfffee096624764d5aed82f786c708dfe90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr.c
diff --cc fs/xfs/libxfs/xfs_attr.c
index 9cb14a5eed33,cdfc136b5bfb..000000000000
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@@ -908,100 -1025,77 +908,168 @@@ restart
  			return error;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * If this is an atomic rename operation, we must "flip" the
 +	 * incomplete flags on the "new" and "old" attribute/value pairs
 +	 * so that one disappears and one appears atomically.  Then we
 +	 * must remove the "old" attribute/value pair.
 +	 */
 +	if (args->op_flags & XFS_DA_OP_RENAME) {
 +		/*
 +		 * In a separate transaction, set the incomplete flag on the
 +		 * "old" attr and clear the incomplete flag on the "new" attr.
 +		 */
 +		error = xfs_attr3_leaf_flipflags(args);
 +		if (error)
 +			goto out;
 +		/*
 +		 * Commit the flag value change and start the next trans in
 +		 * series
 +		 */
 +		error = xfs_trans_roll_inode(&args->trans, args->dp);
 +		if (error)
 +			goto out;
 +
 +		/*
 +		 * Dismantle the "old" attribute/value pair by removing
 +		 * a "remote" value (if it exists).
 +		 */
 +		xfs_attr_restore_rmt_blk(args);
 +
 +		if (args->rmtblkno) {
 +			error = xfs_attr_rmtval_invalidate(args);
 +			if (error)
 +				return error;
 +
 +			error = xfs_attr_rmtval_remove(args);
 +			if (error)
 +				return error;
 +		}
 +
 +		/*
 +		 * Re-find the "old" attribute entry after any split ops.
 +		 * The INCOMPLETE flag means that we will find the "old"
 +		 * attr, not the "new" one.
 +		 */
 +		args->attr_filter |= XFS_ATTR_INCOMPLETE;
 +		state = xfs_da_state_alloc();
 +		state->args = args;
 +		state->mp = mp;
 +		state->inleaf = 0;
 +		error = xfs_da3_node_lookup_int(state, &retval);
 +		if (error)
 +			goto out;
 +
 +		/*
 +		 * Remove the name and update the hashvals in the tree.
 +		 */
 +		blk = &state->path.blk[ state->path.active-1 ];
 +		ASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);
 +		error = xfs_attr3_leaf_remove(blk->bp, args);
 +		xfs_da3_fixhashpath(state, &state->path);
 +
 +		/*
 +		 * Check to see if the tree needs to be collapsed.
 +		 */
 +		if (retval && (state->path.active > 1)) {
 +			error = xfs_da3_join(state);
 +			if (error)
 +				goto out;
 +			error = xfs_defer_finish(&args->trans);
 +			if (error)
 +				goto out;
 +		}
 +
 +		/*
 +		 * Commit and start the next trans in the chain.
 +		 */
 +		error = xfs_trans_roll_inode(&args->trans, dp);
 +		if (error)
 +			goto out;
 +
 +	} else if (args->rmtblkno > 0) {
++=======
+ 	if (!(args->op_flags & XFS_DA_OP_RENAME)) {
++>>>>>>> bf4a5cfffee0 (xfs: Simplify xfs_attr_node_addname)
  		/*
  		 * Added a "remote" value, just clear the incomplete flag.
  		 */
- 		error = xfs_attr3_leaf_clearflag(args);
+ 		if (args->rmtblkno > 0)
+ 			error = xfs_attr3_leaf_clearflag(args);
+ 		retval = error;
+ 		goto out;
+ 	}
+ 
+ 	/*
+ 	 * If this is an atomic rename operation, we must "flip" the incomplete
+ 	 * flags on the "new" and "old" attribute/value pairs so that one
+ 	 * disappears and one appears atomically.  Then we must remove the "old"
+ 	 * attribute/value pair.
+ 	 *
+ 	 * In a separate transaction, set the incomplete flag on the "old" attr
+ 	 * and clear the incomplete flag on the "new" attr.
+ 	 */
+ 	error = xfs_attr3_leaf_flipflags(args);
+ 	if (error)
+ 		goto out;
+ 	/*
+ 	 * Commit the flag value change and start the next trans in series
+ 	 */
+ 	error = xfs_trans_roll_inode(&args->trans, args->dp);
+ 	if (error)
+ 		goto out;
+ 
+ 	/*
+ 	 * Dismantle the "old" attribute/value pair by removing a "remote" value
+ 	 * (if it exists).
+ 	 */
+ 	xfs_attr_restore_rmt_blk(args);
+ 
+ 	if (args->rmtblkno) {
+ 		error = xfs_attr_rmtval_invalidate(args);
+ 		if (error)
+ 			return error;
+ 
+ 		error = xfs_attr_rmtval_remove(args);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * Re-find the "old" attribute entry after any split ops. The INCOMPLETE
+ 	 * flag means that we will find the "old" attr, not the "new" one.
+ 	 */
+ 	args->attr_filter |= XFS_ATTR_INCOMPLETE;
+ 	state = xfs_da_state_alloc(args);
+ 	state->inleaf = 0;
+ 	error = xfs_da3_node_lookup_int(state, &retval);
+ 	if (error)
+ 		goto out;
+ 
+ 	/*
+ 	 * Remove the name and update the hashvals in the tree.
+ 	 */
+ 	blk = &state->path.blk[state->path.active-1];
+ 	ASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);
+ 	error = xfs_attr3_leaf_remove(blk->bp, args);
+ 	xfs_da3_fixhashpath(state, &state->path);
+ 
+ 	/*
+ 	 * Check to see if the tree needs to be collapsed.
+ 	 */
+ 	if (retval && (state->path.active > 1)) {
+ 		error = xfs_da3_join(state);
  		if (error)
  			goto out;
 +
 +		 /*
 +		  * Commit the flag value change and start the next trans in
 +		  * series.
 +		  */
 +		error = xfs_trans_roll_inode(&args->trans, args->dp);
 +		if (error)
 +			goto out;
  	}
  	retval = error = 0;
  
* Unmerged path fs/xfs/libxfs/xfs_attr.c
