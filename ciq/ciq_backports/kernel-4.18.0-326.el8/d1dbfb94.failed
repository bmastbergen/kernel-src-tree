xhci: introduce a new move_dequeue_past_td() function to replace old code.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Mathias Nyman <mathias.nyman@linux.intel.com>
commit d1dbfb942c33bff563af7222418cff3f01c9fbc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/d1dbfb94.failed

Replace xhci_find_new_dequeue_state() and xhci_queue_new_dequeue_state()
functions with one combined function.
These function were always called after each other, and had a lot of extra
code just to pass the newly found dequeue state from the first function
to the other.

The new function also returns error in case there is a failure to
queue the new dequeue state. This way the caller can decide on
recovery measures to handle it.

	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
Link: https://lore.kernel.org/r/20210129130044.206855-25-mathias.nyman@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d1dbfb942c33bff563af7222418cff3f01c9fbc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci-ring.c
diff --cc drivers/usb/host/xhci-ring.c
index bd30ef5cce7a,e3edc8f2c2cb..000000000000
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@@ -762,8 -1022,11 +896,13 @@@ static int xhci_invalidate_cancelled_td
  	struct xhci_hcd		*xhci;
  	struct xhci_td		*td = NULL;
  	struct xhci_td		*tmp_td = NULL;
 -	struct xhci_td		*cached_td = NULL;
  	struct xhci_ring	*ring;
  	u64			hw_deq;
++<<<<<<< HEAD
++=======
+ 	unsigned int		slot_id = ep->vdev->slot_id;
+ 	int			err;
++>>>>>>> d1dbfb942c33 (xhci: introduce a new move_dequeue_past_td() function to replace old code.)
  
  	xhci = ep->xhci;
  
@@@ -789,18 -1052,57 +928,57 @@@
  
  		if (trb_in_td(xhci, td->start_seg, td->first_trb,
  			      td->last_trb, hw_deq, false)) {
 -			switch (td->cancel_status) {
 -			case TD_CLEARED: /* TD is already no-op */
 -			case TD_CLEARING_CACHE: /* set TR deq command already queued */
 -				break;
 -			case TD_DIRTY: /* TD is cached, clear it */
 -			case TD_HALTED:
 -				/* FIXME  stream case, several stopped rings */
 -				cached_td = td;
 -				break;
 -			}
 +			xhci_find_new_dequeue_state(xhci, ep->vdev->slot_id,
 +						    ep->ep_index,
 +						    td->urb->stream_id,
 +						    td, deq_state);
  		} else {
  			td_to_noop(xhci, ring, td, false);
 -			td->cancel_status = TD_CLEARED;
  		}
++<<<<<<< HEAD
 +
++=======
+ 	}
+ 	if (cached_td) {
+ 		cached_td->cancel_status = TD_CLEARING_CACHE;
+ 
+ 		err = xhci_move_dequeue_past_td(xhci, slot_id, ep->ep_index,
+ 						cached_td->urb->stream_id,
+ 						cached_td);
+ 		/* Failed to move past cached td, try just setting it noop */
+ 		if (err) {
+ 			td_to_noop(xhci, ring, cached_td, false);
+ 			cached_td->cancel_status = TD_CLEARED;
+ 		}
+ 		cached_td = NULL;
++>>>>>>> d1dbfb942c33 (xhci: introduce a new move_dequeue_past_td() function to replace old code.)
  	}
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Returns the TD the endpoint ring halted on.
+  * Only call for non-running rings without streams.
+  */
+ static struct xhci_td *find_halted_td(struct xhci_virt_ep *ep)
+ {
+ 	struct xhci_td	*td;
+ 	u64		hw_deq;
+ 
+ 	if (!list_empty(&ep->ring->td_list)) { /* Not streams compatible */
+ 		hw_deq = xhci_get_hw_deq(ep->xhci, ep->vdev, ep->ep_index, 0);
+ 		hw_deq &= ~0xf;
+ 		td = list_first_entry(&ep->ring->td_list, struct xhci_td, td_list);
+ 		if (trb_in_td(ep->xhci, td->start_seg, td->first_trb,
+ 				td->last_trb, hw_deq, false))
+ 			return td;
+ 	}
+ 	return NULL;
+ }
+ 
++>>>>>>> d1dbfb942c33 (xhci: introduce a new move_dequeue_past_td() function to replace old code.)
  /*
   * When we get a command completion for a Stop Endpoint Command, we need to
   * unlink any cancelled TDs from the ring.  There are two ways to do that:
* Unmerged path drivers/usb/host/xhci-ring.c
