xhci: use xhci_td_cleanup() helper when giving back cancelled URBs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Mathias Nyman <mathias.nyman@linux.intel.com>
commit e1a298390e987ddeb767cad18d913cb2782fda15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/e1a29839.failed

use the existing xhci_td_cleanup() to give back cancelled TDs when a
ring is stopped.

A minor change to make sure we don't try to remove an already removed
td from the list is needed as cancelled TDs are already removed from the
td_list immediatelty when it's cancelled.

	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
Link: https://lore.kernel.org/r/20210129130044.206855-18-mathias.nyman@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit e1a298390e987ddeb767cad18d913cb2782fda15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci-ring.c
diff --cc drivers/usb/host/xhci-ring.c
index fdb8f13b8e27,47597af50b5d..000000000000
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@@ -749,6 -749,74 +749,77 @@@ static void xhci_unmap_td_bounce_buffer
  	seg->bounce_offs = 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int xhci_td_cleanup(struct xhci_hcd *xhci, struct xhci_td *td,
+ 		struct xhci_ring *ep_ring, int *status)
+ {
+ 	struct urb *urb = NULL;
+ 
+ 	/* Clean up the endpoint's TD list */
+ 	urb = td->urb;
+ 
+ 	/* if a bounce buffer was used to align this td then unmap it */
+ 	xhci_unmap_td_bounce_buffer(xhci, ep_ring, td);
+ 
+ 	/* Do one last check of the actual transfer length.
+ 	 * If the host controller said we transferred more data than the buffer
+ 	 * length, urb->actual_length will be a very big number (since it's
+ 	 * unsigned).  Play it safe and say we didn't transfer anything.
+ 	 */
+ 	if (urb->actual_length > urb->transfer_buffer_length) {
+ 		xhci_warn(xhci, "URB req %u and actual %u transfer length mismatch\n",
+ 			  urb->transfer_buffer_length, urb->actual_length);
+ 		urb->actual_length = 0;
+ 		*status = 0;
+ 	}
+ 	/* TD might be removed from td_list if we are giving back a cancelled URB */
+ 	if (!list_empty(&td->td_list))
+ 		list_del_init(&td->td_list);
+ 	/* Giving back a cancelled URB, or if a slated TD completed anyway */
+ 	if (!list_empty(&td->cancelled_td_list))
+ 		list_del_init(&td->cancelled_td_list);
+ 
+ 	inc_td_cnt(urb);
+ 	/* Giveback the urb when all the tds are completed */
+ 	if (last_td_in_urb(td)) {
+ 		if ((urb->actual_length != urb->transfer_buffer_length &&
+ 		     (urb->transfer_flags & URB_SHORT_NOT_OK)) ||
+ 		    (*status != 0 && !usb_endpoint_xfer_isoc(&urb->ep->desc)))
+ 			xhci_dbg(xhci, "Giveback URB %p, len = %d, expected = %d, status = %d\n",
+ 				 urb, urb->actual_length,
+ 				 urb->transfer_buffer_length, *status);
+ 
+ 		/* set isoc urb status to 0 just as EHCI, UHCI, and OHCI */
+ 		if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
+ 			*status = 0;
+ 		xhci_giveback_urb_in_irq(xhci, td, *status);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xhci_reset_halted_ep(struct xhci_hcd *xhci, unsigned int slot_id,
+ 				unsigned int ep_index, enum xhci_ep_reset_type reset_type)
+ {
+ 	struct xhci_command *command;
+ 	int ret = 0;
+ 
+ 	command = xhci_alloc_command(xhci, false, GFP_ATOMIC);
+ 	if (!command) {
+ 		ret = -ENOMEM;
+ 		goto done;
+ 	}
+ 
+ 	ret = xhci_queue_reset_ep(xhci, command, slot_id, ep_index, reset_type);
+ done:
+ 	if (ret)
+ 		xhci_err(xhci, "ERROR queuing reset endpoint for slot %d ep_index %d, %d\n",
+ 			 slot_id, ep_index, ret);
+ 	return ret;
+ }
+ 
++>>>>>>> e1a298390e98 (xhci: use xhci_td_cleanup() helper when giving back cancelled URBs)
  /*
   * When we get a command completion for a Stop Endpoint Command, we need to
   * unlink any cancelled TDs from the ring.  There are two ways to do that:
* Unmerged path drivers/usb/host/xhci-ring.c
