xfs: add support for free space btree staging cursors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit e6eb33d905c287eb07ee1c69d38871276db154dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/e6eb33d9.failed

Add support for btree staging cursors for the free space btrees.  This
is needed both for online repair and also to convert xfs_repair to use
btree bulk loading.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit e6eb33d905c287eb07ee1c69d38871276db154dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc_btree.c
diff --cc fs/xfs/libxfs/xfs_alloc_btree.c
index 422a822a9957,60c453cb3ee3..000000000000
--- a/fs/xfs/libxfs/xfs_alloc_btree.c
+++ b/fs/xfs/libxfs/xfs_alloc_btree.c
@@@ -497,22 -492,44 +494,53 @@@ xfs_allocbt_init_common
  	cur->bc_blocklog = mp->m_sb.sb_blocklog;
  
  	if (btnum == XFS_BTNUM_CNT) {
- 		cur->bc_statoff = XFS_STATS_CALC_INDEX(xs_abtc_2);
  		cur->bc_ops = &xfs_cntbt_ops;
- 		cur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);
+ 		cur->bc_statoff = XFS_STATS_CALC_INDEX(xs_abtc_2);
  		cur->bc_flags = XFS_BTREE_LASTREC_UPDATE;
  	} else {
- 		cur->bc_statoff = XFS_STATS_CALC_INDEX(xs_abtb_2);
  		cur->bc_ops = &xfs_bnobt_ops;
- 		cur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);
+ 		cur->bc_statoff = XFS_STATS_CALC_INDEX(xs_abtb_2);
  	}
  
+ 	cur->bc_ag.agno = agno;
+ 	cur->bc_ag.abt.active = false;
+ 
+ 	if (xfs_sb_version_hascrc(&mp->m_sb))
+ 		cur->bc_flags |= XFS_BTREE_CRC_BLOCKS;
+ 
+ 	return cur;
+ }
+ 
+ /*
+  * Allocate a new allocation btree cursor.
+  */
+ struct xfs_btree_cur *			/* new alloc btree cursor */
+ xfs_allocbt_init_cursor(
+ 	struct xfs_mount	*mp,		/* file system mount point */
+ 	struct xfs_trans	*tp,		/* transaction pointer */
+ 	struct xfs_buf		*agbp,		/* buffer for agf structure */
+ 	xfs_agnumber_t		agno,		/* allocation group number */
+ 	xfs_btnum_t		btnum)		/* btree identifier */
+ {
+ 	struct xfs_agf		*agf = agbp->b_addr;
+ 	struct xfs_btree_cur	*cur;
+ 
+ 	cur = xfs_allocbt_init_common(mp, tp, agno, btnum);
+ 	if (btnum == XFS_BTNUM_CNT)
+ 		cur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]);
+ 	else
+ 		cur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);
+ 
++<<<<<<< HEAD
 +	cur->bc_private.a.agbp = agbp;
 +	cur->bc_private.a.agno = agno;
 +	cur->bc_private.a.priv.abt.active = false;
 +
 +	if (xfs_sb_version_hascrc(&mp->m_sb))
 +		cur->bc_flags |= XFS_BTREE_CRC_BLOCKS;
++=======
+ 	cur->bc_ag.agbp = agbp;
++>>>>>>> e6eb33d905c2 (xfs: add support for free space btree staging cursors)
  
  	return cur;
  }
* Unmerged path fs/xfs/libxfs/xfs_alloc_btree.c
diff --git a/fs/xfs/libxfs/xfs_alloc_btree.h b/fs/xfs/libxfs/xfs_alloc_btree.h
index c9305ebb69f6..047f09f0be3c 100644
--- a/fs/xfs/libxfs/xfs_alloc_btree.h
+++ b/fs/xfs/libxfs/xfs_alloc_btree.h
@@ -13,6 +13,7 @@
 struct xfs_buf;
 struct xfs_btree_cur;
 struct xfs_mount;
+struct xbtree_afakeroot;
 
 /*
  * Btree block header size depends on a superblock flag.
@@ -48,8 +49,14 @@ struct xfs_mount;
 extern struct xfs_btree_cur *xfs_allocbt_init_cursor(struct xfs_mount *,
 		struct xfs_trans *, struct xfs_buf *,
 		xfs_agnumber_t, xfs_btnum_t);
+struct xfs_btree_cur *xfs_allocbt_stage_cursor(struct xfs_mount *mp,
+		struct xbtree_afakeroot *afake, xfs_agnumber_t agno,
+		xfs_btnum_t btnum);
 extern int xfs_allocbt_maxrecs(struct xfs_mount *, int, int);
 extern xfs_extlen_t xfs_allocbt_calc_size(struct xfs_mount *mp,
 		unsigned long long len);
 
+void xfs_allocbt_commit_staged_btree(struct xfs_btree_cur *cur,
+		struct xfs_trans *tp, struct xfs_buf *agbp);
+
 #endif	/* __XFS_ALLOC_BTREE_H__ */
