SUNRPC: Clean up open coded setting of the xdr_stream 'nwords' field

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 5a5f1c2c2cbb6ddef637abb7c7e7cab20b9cc933
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5a5f1c2c.failed

Move the setting of the xdr_stream 'nwords' field into the helpers that
reset the xdr_stream cursor.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 5a5f1c2c2cbb6ddef637abb7c7e7cab20b9cc933)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xdr.c
diff --cc net/sunrpc/xdr.c
index 09eff12df7e6,f0444bf5617c..000000000000
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@@ -1175,10 -1396,9 +1185,16 @@@ static void xdr_realign_pages(struct xd
  
  	/* Realign pages to current pointer position */
  	if (iov->iov_len > cur) {
++<<<<<<< HEAD
 +		offset = iov->iov_len - cur;
 +		copied = xdr_shrink_bufhead(buf, offset);
 +		trace_rpc_xdr_alignment(xdr, offset, copied);
 +		xdr->nwords = XDR_QUADLEN(buf->len - cur);
++=======
+ 		copied = xdr_shrink_bufhead(buf, cur);
+ 		trace_rpc_xdr_alignment(xdr, cur, copied);
+ 		xdr_set_page(xdr, 0, buf->page_len);
++>>>>>>> 5a5f1c2c2cbb (SUNRPC: Clean up open coded setting of the xdr_stream 'nwords' field)
  	}
  }
  
@@@ -1186,8 -1406,7 +1202,12 @@@ static unsigned int xdr_align_pages(str
  {
  	struct xdr_buf *buf = xdr->buf;
  	unsigned int nwords = XDR_QUADLEN(len);
++<<<<<<< HEAD
 +	unsigned int cur = xdr_stream_pos(xdr);
 +	unsigned int copied, offset;
++=======
+ 	unsigned int copied;
++>>>>>>> 5a5f1c2c2cbb (SUNRPC: Clean up open coded setting of the xdr_stream 'nwords' field)
  
  	if (xdr->nwords == 0)
  		return 0;
@@@ -1201,10 -1420,8 +1221,15 @@@
  		len = buf->page_len;
  	else if (nwords < xdr->nwords) {
  		/* Truncate page data and move it into the tail */
++<<<<<<< HEAD
 +		offset = buf->page_len - len;
 +		copied = xdr_shrink_pagelen(buf, offset);
 +		trace_rpc_xdr_alignment(xdr, offset, copied);
 +		xdr->nwords = XDR_QUADLEN(buf->len - cur);
++=======
+ 		copied = xdr_shrink_pagelen(buf, len);
+ 		trace_rpc_xdr_alignment(xdr, len, copied);
++>>>>>>> 5a5f1c2c2cbb (SUNRPC: Clean up open coded setting of the xdr_stream 'nwords' field)
  	}
  	return len;
  }
@@@ -1252,26 -1464,34 +1275,36 @@@ uint64_t xdr_align_data(struct xdr_stre
  
  	xdr_realign_pages(xdr);
  	from = xdr_page_pos(xdr);
 -
 -	if (from >= buf->page_len + buf->tail->iov_len)
 -		return 0;
 -	if (from + buf->head->iov_len >= buf->len)
 -		return 0;
 -
 -	len = buf->len - buf->head->iov_len;
 -
 -	/* We only shift data left! */
 -	if (WARN_ONCE(from < offset, "SUNRPC: misaligned data src=%u dst=%u\n",
 -		      from, offset))
 -		return 0;
 -	if (WARN_ONCE(offset > buf->page_len,
 -		      "SUNRPC: buffer overflow. offset=%u, page_len=%u\n",
 -		      offset, buf->page_len))
 -		return 0;
 +	bytes = xdr_stream_remaining(xdr);
 +	if (length < bytes)
 +		bytes = length;
  
  	/* Move page data to the left */
++<<<<<<< HEAD
 +	if (from > offset) {
 +		shift = min_t(unsigned int, bytes, buf->page_len - from);
 +		_shift_data_left_pages(buf->pages,
 +				       buf->page_base + offset,
 +				       buf->page_base + from,
 +				       shift);
 +		bytes -= shift;
++=======
+ 	shift = from - offset;
+ 	xdr_buf_pages_shift_left(buf, from, len, shift);
++>>>>>>> 5a5f1c2c2cbb (SUNRPC: Clean up open coded setting of the xdr_stream 'nwords' field)
  
 -	bytes = xdr_stream_remaining(xdr);
 -	if (length > bytes)
 -		length = bytes;
 -	bytes -= length;
 +		/* Move tail data into the pages, if necessary */
 +		if (bytes > 0)
 +			_shift_data_left_tail(buf, offset + shift, bytes);
 +	}
  
++<<<<<<< HEAD
 +	xdr->nwords -= XDR_QUADLEN(length);
 +	xdr_set_page(xdr, from + length, PAGE_SIZE);
++=======
+ 	xdr->buf->len -= shift;
+ 	xdr_set_page(xdr, offset + length, bytes);
++>>>>>>> 5a5f1c2c2cbb (SUNRPC: Clean up open coded setting of the xdr_stream 'nwords' field)
  	return length;
  }
  EXPORT_SYMBOL_GPL(xdr_align_data);
@@@ -1289,26 -1504,19 +1322,40 @@@ uint64_t xdr_expand_hole(struct xdr_str
  
  	xdr_realign_pages(xdr);
  	from = xdr_page_pos(xdr);
 -	to = xdr_align_size(offset + length);
 +	bytes = xdr_stream_remaining(xdr);
  
++<<<<<<< HEAD
 +	if (offset + length + bytes > buf->page_len) {
 +		unsigned int shift = (offset + length + bytes) - buf->page_len;
 +		unsigned int res = _shift_data_right_tail(buf, from + bytes - shift, shift);
 +		truncated = shift - res;
 +		xdr->nwords -= XDR_QUADLEN(truncated);
 +		bytes -= shift;
 +	}
 +
 +	/* Now move the page data over and zero pages */
 +	if (bytes > 0)
 +		_shift_data_right_pages(buf->pages,
 +					buf->page_base + offset + length,
 +					buf->page_base + from,
 +					bytes);
 +	_zero_pages(buf->pages, buf->page_base + offset, length);
 +
 +	buf->len += length - (from - offset) - truncated;
 +	xdr_set_page(xdr, offset + length, PAGE_SIZE);
++=======
+ 	/* Could the hole be behind us? */
+ 	if (to > from) {
+ 		unsigned int buflen = buf->len - buf->head->iov_len;
+ 		shift = to - from;
+ 		xdr_buf_try_expand(buf, shift);
+ 		xdr_buf_pages_shift_right(buf, from, buflen, shift);
+ 		xdr_set_page(xdr, to, xdr_stream_remaining(xdr));
+ 	} else if (to != from)
+ 		xdr_align_data(xdr, to, 0);
+ 	xdr_buf_pages_zero(buf, offset, length);
+ 
++>>>>>>> 5a5f1c2c2cbb (SUNRPC: Clean up open coded setting of the xdr_stream 'nwords' field)
  	return length;
  }
  EXPORT_SYMBOL_GPL(xdr_expand_hole);
* Unmerged path net/sunrpc/xdr.c
