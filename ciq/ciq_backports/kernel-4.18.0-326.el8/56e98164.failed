xfs: add support for refcount btree staging cursors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 56e98164ffea2a9ee577e5e4f368c6d5182ed8eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/56e98164.failed

Add support for btree staging cursors for the refcount btrees.  This
is needed both for online repair and also to convert xfs_repair to use
btree bulk loading.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit 56e98164ffea2a9ee577e5e4f368c6d5182ed8eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_refcount_btree.c
diff --cc fs/xfs/libxfs/xfs_refcount_btree.c
index a76997740e45,7fd6044a4f78..000000000000
--- a/fs/xfs/libxfs/xfs_refcount_btree.c
+++ b/fs/xfs/libxfs/xfs_refcount_btree.c
@@@ -331,18 -330,45 +330,56 @@@ xfs_refcountbt_init_common
  	cur->bc_mp = mp;
  	cur->bc_btnum = XFS_BTNUM_REFC;
  	cur->bc_blocklog = mp->m_sb.sb_blocklog;
- 	cur->bc_ops = &xfs_refcountbt_ops;
  	cur->bc_statoff = XFS_STATS_CALC_INDEX(xs_refcbt_2);
  
+ 	cur->bc_ag.agno = agno;
+ 	cur->bc_flags |= XFS_BTREE_CRC_BLOCKS;
+ 
+ 	cur->bc_ag.refc.nr_ops = 0;
+ 	cur->bc_ag.refc.shape_changes = 0;
+ 	cur->bc_ops = &xfs_refcountbt_ops;
+ 	return cur;
+ }
+ 
+ /* Create a btree cursor. */
+ struct xfs_btree_cur *
+ xfs_refcountbt_init_cursor(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_trans	*tp,
+ 	struct xfs_buf		*agbp,
+ 	xfs_agnumber_t		agno)
+ {
+ 	struct xfs_agf		*agf = agbp->b_addr;
+ 	struct xfs_btree_cur	*cur;
+ 
+ 	cur = xfs_refcountbt_init_common(mp, tp, agno);
  	cur->bc_nlevels = be32_to_cpu(agf->agf_refcount_level);
++<<<<<<< HEAD
 +
 +	cur->bc_private.a.agbp = agbp;
 +	cur->bc_private.a.agno = agno;
 +	cur->bc_flags |= XFS_BTREE_CRC_BLOCKS;
 +
 +	cur->bc_private.a.priv.refc.nr_ops = 0;
 +	cur->bc_private.a.priv.refc.shape_changes = 0;
 +
++=======
+ 	cur->bc_ag.agbp = agbp;
++>>>>>>> 56e98164ffea (xfs: add support for refcount btree staging cursors)
+ 	return cur;
+ }
+ 
+ /* Create a btree cursor with a fake root for staging. */
+ struct xfs_btree_cur *
+ xfs_refcountbt_stage_cursor(
+ 	struct xfs_mount	*mp,
+ 	struct xbtree_afakeroot	*afake,
+ 	xfs_agnumber_t		agno)
+ {
+ 	struct xfs_btree_cur	*cur;
+ 
+ 	cur = xfs_refcountbt_init_common(mp, NULL, agno);
+ 	xfs_btree_stage_afakeroot(cur, afake);
  	return cur;
  }
  
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
diff --git a/fs/xfs/libxfs/xfs_refcount_btree.h b/fs/xfs/libxfs/xfs_refcount_btree.h
index ba416f71c824..69dc515db671 100644
--- a/fs/xfs/libxfs/xfs_refcount_btree.h
+++ b/fs/xfs/libxfs/xfs_refcount_btree.h
@@ -13,6 +13,7 @@
 struct xfs_buf;
 struct xfs_btree_cur;
 struct xfs_mount;
+struct xbtree_afakeroot;
 
 /*
  * Btree block header size
@@ -46,6 +47,8 @@ struct xfs_mount;
 extern struct xfs_btree_cur *xfs_refcountbt_init_cursor(struct xfs_mount *mp,
 		struct xfs_trans *tp, struct xfs_buf *agbp,
 		xfs_agnumber_t agno);
+struct xfs_btree_cur *xfs_refcountbt_stage_cursor(struct xfs_mount *mp,
+		struct xbtree_afakeroot *afake, xfs_agnumber_t agno);
 extern int xfs_refcountbt_maxrecs(int blocklen, bool leaf);
 extern void xfs_refcountbt_compute_maxlevels(struct xfs_mount *mp);
 
@@ -58,4 +61,7 @@ extern int xfs_refcountbt_calc_reserves(struct xfs_mount *mp,
 		struct xfs_trans *tp, xfs_agnumber_t agno, xfs_extlen_t *ask,
 		xfs_extlen_t *used);
 
+void xfs_refcountbt_commit_staged_btree(struct xfs_btree_cur *cur,
+		struct xfs_trans *tp, struct xfs_buf *agbp);
+
 #endif	/* __XFS_REFCOUNT_BTREE_H__ */
