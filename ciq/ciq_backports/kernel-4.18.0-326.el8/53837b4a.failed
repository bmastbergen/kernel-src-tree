ALSA: usb-audio: Replace slave/master terms

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 53837b4ac2bd33ede5cd799940341ce5ea7b2902
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/53837b4a.failed

Follow the inclusive terminology, just replace sync_master/sync_slave
with sync_source/sync_sink.  It's also a bit clearer from its meaning,
too.

	Tested-by: Keith Milner <kamilner@superlative.org>
	Tested-by: Dylan Robinson <dylan_robinson@motu.com>
Link: https://lore.kernel.org/r/20201123085347.19667-34-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 53837b4ac2bd33ede5cd799940341ce5ea7b2902)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/endpoint.c
diff --cc sound/usb/endpoint.c
index 208ac2aff462,5f1d5f1ed8db..000000000000
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@@ -169,6 -166,21 +169,24 @@@ int snd_usb_endpoint_next_packet_size(s
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * snd_usb_endpoint_next_packet_size: Return the number of samples to be sent
+  * in the next packet
+  */
+ int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep,
+ 				      struct snd_urb_ctx *ctx, int idx)
+ {
+ 	if (ctx->packet_size[idx])
+ 		return ctx->packet_size[idx];
+ 	else if (ep->sync_source)
+ 		return slave_next_packet_size(ep);
+ 	else
+ 		return next_packet_size(ep);
+ }
+ 
++>>>>>>> 53837b4ac2bd (ALSA: usb-audio: Replace slave/master terms)
  static void call_retire_callback(struct snd_usb_endpoint *ep,
  				 struct urb *urb)
  {
@@@ -189,14 -205,16 +207,24 @@@ static void retire_inbound_urb(struct s
  			       struct snd_urb_ctx *urb_ctx)
  {
  	struct urb *urb = urb_ctx->urb;
++<<<<<<< HEAD
++=======
+ 	struct snd_usb_endpoint *sync_sink;
++>>>>>>> 53837b4ac2bd (ALSA: usb-audio: Replace slave/master terms)
  
  	if (unlikely(ep->skip_packets > 0)) {
  		ep->skip_packets--;
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (ep->sync_slave)
 +		snd_usb_handle_sync_urb(ep->sync_slave, ep, urb);
++=======
+ 	sync_sink = READ_ONCE(ep->sync_sink);
+ 	if (sync_sink)
+ 		snd_usb_handle_sync_urb(sync_sink, ep, urb);
++>>>>>>> 53837b4ac2bd (ALSA: usb-audio: Replace slave/master terms)
  
  	call_retire_callback(ep, urb);
  }
@@@ -548,25 -560,155 +576,93 @@@ int snd_usb_add_endpoint(struct snd_usb
  }
  
  /* Set up syncinterval and maxsyncsize for a sync EP */
 -static void endpoint_set_syncinterval(struct snd_usb_audio *chip,
 -				      struct snd_usb_endpoint *ep)
 -{
 -	struct usb_host_interface *alts;
 -	struct usb_endpoint_descriptor *desc;
 -
 -	alts = snd_usb_get_host_interface(chip, ep->iface, ep->altsetting);
 -	if (!alts)
 -		return;
 -
 -	desc = get_endpoint(alts, ep->ep_idx);
 -	if (desc->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&
 -	    desc->bRefresh >= 1 && desc->bRefresh <= 9)
 -		ep->syncinterval = desc->bRefresh;
 -	else if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)
 -		ep->syncinterval = 1;
 -	else if (desc->bInterval >= 1 && desc->bInterval <= 16)
 -		ep->syncinterval = desc->bInterval - 1;
 -	else
 -		ep->syncinterval = 3;
 -
 -	ep->syncmaxsize = le16_to_cpu(desc->wMaxPacketSize);
 -}
 -
 -static bool endpoint_compatible(struct snd_usb_endpoint *ep,
 -				const struct audioformat *fp,
 -				const struct snd_pcm_hw_params *params)
 -{
 -	if (!ep->opened)
 -		return false;
 -	if (ep->cur_audiofmt != fp)
 -		return false;
 -	if (ep->cur_rate != params_rate(params) ||
 -	    ep->cur_format != params_format(params) ||
 -	    ep->cur_period_frames != params_period_size(params) ||
 -	    ep->cur_buffer_periods != params_periods(params))
 -		return false;
 -	return true;
 -}
 -
 -/*
 - * Check whether the given fp and hw params are compatbile with the current
 - * setup of the target EP for implicit feedback sync
 - */
 -bool snd_usb_endpoint_compatible(struct snd_usb_audio *chip,
 -				 struct snd_usb_endpoint *ep,
 -				 const struct audioformat *fp,
 -				 const struct snd_pcm_hw_params *params)
 +void snd_usb_endpoint_set_syncinterval(struct snd_usb_audio *chip,
 +				       struct snd_usb_endpoint *ep,
 +				       struct usb_host_interface *alts)
  {
 -	bool ret;
 -
 -	mutex_lock(&chip->mutex);
 -	ret = endpoint_compatible(ep, fp, params);
 -	mutex_unlock(&chip->mutex);
 -	return ret;
 -}
 -
 -/*
 - * snd_usb_endpoint_open: Open the endpoint
 - *
 - * Called from hw_params to assign the endpoint to the substream.
 - * It's reference-counted, and only the first opener is allowed to set up
 - * arbitrary parameters.  The later opener must be compatible with the
 - * former opened parameters.
 - * The endpoint needs to be closed via snd_usb_endpoint_close() later.
 - *
 - * Note that this function doesn't configure the endpoint.  The substream
 - * needs to set it up later via snd_usb_endpoint_configure().
 - */
 -struct snd_usb_endpoint *
 -snd_usb_endpoint_open(struct snd_usb_audio *chip,
 -		      const struct audioformat *fp,
 -		      const struct snd_pcm_hw_params *params,
 -		      bool is_sync_ep)
 -{
 -	struct snd_usb_endpoint *ep;
 -	int ep_num = is_sync_ep ? fp->sync_ep : fp->endpoint;
 -
 -	mutex_lock(&chip->mutex);
 -	ep = snd_usb_get_endpoint(chip, ep_num);
 -	if (!ep) {
 -		usb_audio_err(chip, "Cannot find EP 0x%x to open\n", ep_num);
 -		goto unlock;
 +	struct usb_endpoint_descriptor *desc = get_endpoint(alts, 1);
 +
 +	if (ep->type == SND_USB_ENDPOINT_TYPE_SYNC) {
 +		if (desc->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&
 +		    desc->bRefresh >= 1 && desc->bRefresh <= 9)
 +			ep->syncinterval = desc->bRefresh;
 +		else if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)
 +			ep->syncinterval = 1;
 +		else if (desc->bInterval >= 1 && desc->bInterval <= 16)
 +			ep->syncinterval = desc->bInterval - 1;
 +		else
 +			ep->syncinterval = 3;
 +
 +		ep->syncmaxsize = le16_to_cpu(desc->wMaxPacketSize);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (!ep->opened) {
+ 		if (is_sync_ep) {
+ 			ep->iface = fp->sync_iface;
+ 			ep->altsetting = fp->sync_altsetting;
+ 			ep->ep_idx = fp->sync_ep_idx;
+ 		} else {
+ 			ep->iface = fp->iface;
+ 			ep->altsetting = fp->altsetting;
+ 			ep->ep_idx = 0;
+ 		}
+ 		usb_audio_dbg(chip, "Open EP 0x%x, iface=%d:%d, idx=%d\n",
+ 			      ep_num, ep->iface, ep->altsetting, ep->ep_idx);
+ 
+ 		ep->cur_audiofmt = fp;
+ 		ep->cur_channels = fp->channels;
+ 		ep->cur_rate = params_rate(params);
+ 		ep->cur_format = params_format(params);
+ 		ep->cur_frame_bytes = snd_pcm_format_physical_width(ep->cur_format) *
+ 			ep->cur_channels / 8;
+ 		ep->cur_period_frames = params_period_size(params);
+ 		ep->cur_period_bytes = ep->cur_period_frames * ep->cur_frame_bytes;
+ 		ep->cur_buffer_periods = params_periods(params);
+ 
+ 		if (ep->type == SND_USB_ENDPOINT_TYPE_SYNC)
+ 			endpoint_set_syncinterval(chip, ep);
+ 
+ 		ep->implicit_fb_sync = fp->implicit_fb;
+ 		ep->need_setup = true;
+ 
+ 		usb_audio_dbg(chip, "  channels=%d, rate=%d, format=%s, period_bytes=%d, periods=%d, implicit_fb=%d\n",
+ 			      ep->cur_channels, ep->cur_rate,
+ 			      snd_pcm_format_name(ep->cur_format),
+ 			      ep->cur_period_bytes, ep->cur_buffer_periods,
+ 			      ep->implicit_fb_sync);
+ 
+ 	} else {
+ 		if (!endpoint_compatible(ep, fp, params)) {
+ 			usb_audio_err(chip, "Incompatible EP setup for 0x%x\n",
+ 				      ep_num);
+ 			ep = NULL;
+ 			goto unlock;
+ 		}
+ 
+ 		usb_audio_dbg(chip, "Reopened EP 0x%x (count %d)\n",
+ 			      ep_num, ep->opened);
+ 	}
+ 
+ 	ep->opened++;
+ 
+  unlock:
+ 	mutex_unlock(&chip->mutex);
+ 	return ep;
+ }
+ 
+ /*
+  * snd_usb_endpoint_set_sync: Link data and sync endpoints
+  *
+  * Pass NULL to sync_ep to unlink again
+  */
+ void snd_usb_endpoint_set_sync(struct snd_usb_audio *chip,
+ 			       struct snd_usb_endpoint *data_ep,
+ 			       struct snd_usb_endpoint *sync_ep)
+ {
+ 	data_ep->sync_source = sync_ep;
++>>>>>>> 53837b4ac2bd (ALSA: usb-audio: Replace slave/master terms)
  }
  
  /*
@@@ -948,9 -969,9 +1044,15 @@@ static int data_ep_set_params(struct sn
  		packs_per_ms = 1;
  		max_packs_per_urb = MAX_PACKS;
  	}
++<<<<<<< HEAD
 +	if (sync_ep && !snd_usb_endpoint_implicit_feedback_sink(ep))
 +		max_packs_per_urb = min(max_packs_per_urb,
 +					1U << sync_ep->syncinterval);
++=======
+ 	if (ep->sync_source && !ep->implicit_fb_sync)
+ 		max_packs_per_urb = min(max_packs_per_urb,
+ 					1U << ep->sync_source->syncinterval);
++>>>>>>> 53837b4ac2bd (ALSA: usb-audio: Replace slave/master terms)
  	max_packs_per_urb = max(1u, max_packs_per_urb >> ep->datainterval);
  
  	/*
@@@ -996,7 -1015,7 +1098,11 @@@
  		minsize = (ep->freqn >> (16 - ep->datainterval)) *
  				(frame_bits >> 3);
  		/* with sync from device, assume it can be 12% lower */
++<<<<<<< HEAD
 +		if (sync_ep)
++=======
+ 		if (ep->sync_source)
++>>>>>>> 53837b4ac2bd (ALSA: usb-audio: Replace slave/master terms)
  			minsize -= minsize >> 3;
  		minsize = max(minsize, 1u);
  
@@@ -1224,16 -1272,17 +1330,25 @@@ int snd_usb_endpoint_start(struct snd_u
  	if (atomic_read(&ep->chip->shutdown))
  		return -EBADFD;
  
++<<<<<<< HEAD
 +	usb_audio_dbg(ep->chip, "Starting %s EP 0x%x (count %d)\n",
 +		      ep_type_name(ep->type), ep->ep_num, ep->use_count);
++=======
+ 	if (ep->sync_source)
+ 		WRITE_ONCE(ep->sync_source->sync_sink, ep);
+ 
+ 	usb_audio_dbg(ep->chip, "Starting %s EP 0x%x (running %d)\n",
+ 		      ep_type_name(ep->type), ep->ep_num,
+ 		      atomic_read(&ep->running));
++>>>>>>> 53837b4ac2bd (ALSA: usb-audio: Replace slave/master terms)
  
  	/* already running? */
 -	if (atomic_inc_return(&ep->running) != 1)
 +	if (++ep->use_count != 1)
  		return 0;
  
 +	/* just to be sure */
 +	deactivate_urbs(ep, false);
 +
  	ep->active_mask = 0;
  	ep->unlink_mask = 0;
  	ep->phase = 0;
@@@ -1309,43 -1359,18 +1424,48 @@@ void snd_usb_endpoint_stop(struct snd_u
  	if (!ep)
  		return;
  
 -	usb_audio_dbg(ep->chip, "Stopping %s EP 0x%x (running %d)\n",
 -		      ep_type_name(ep->type), ep->ep_num,
 -		      atomic_read(&ep->running));
 +	usb_audio_dbg(ep->chip, "Stopping %s EP 0x%x (count %d)\n",
 +		      ep_type_name(ep->type), ep->ep_num, ep->use_count);
  
 -	if (snd_BUG_ON(!atomic_read(&ep->running)))
 +	if (snd_BUG_ON(ep->use_count == 0))
  		return;
  
++<<<<<<< HEAD
 +	if (--ep->use_count == 0) {
 +		deactivate_urbs(ep, false);
 +		set_bit(EP_FLAG_STOPPING, &ep->flags);
 +	}
 +}
++=======
+ 	if (ep->sync_source)
+ 		WRITE_ONCE(ep->sync_source->sync_sink, NULL);
++>>>>>>> 53837b4ac2bd (ALSA: usb-audio: Replace slave/master terms)
  
 -	if (!atomic_dec_return(&ep->running))
 -		stop_and_unlink_urbs(ep, false, false);
 +/**
 + * snd_usb_endpoint_deactivate: deactivate an snd_usb_endpoint
 + *
 + * @ep: the endpoint to deactivate
 + *
 + * If the endpoint is not currently in use, this functions will
 + * deactivate its associated URBs.
 + *
 + * In case of any active users, this functions does nothing.
 + */
 +void snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep)
 +{
 +	if (!ep)
 +		return;
 +
 +	if (ep->use_count != 0)
 +		return;
 +
 +	deactivate_urbs(ep, true);
 +	wait_clear_urbs(ep);
 +
 +	/* clear the saved hw params */
 +	spin_lock_irq(&ep->lock);
 +	ep->cur_rate = 0;
 +	spin_unlock_irq(&ep->lock);
  }
  
  /**
diff --git a/sound/usb/card.h b/sound/usb/card.h
index ce446f8dba4b..74a59106b5bd 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -69,8 +69,8 @@ struct snd_usb_endpoint {
 				 struct urb *urb);
 
 	struct snd_usb_substream *data_subs;
-	struct snd_usb_endpoint *sync_master;
-	struct snd_usb_endpoint *sync_slave;
+	struct snd_usb_endpoint *sync_source;
+	struct snd_usb_endpoint *sync_sink;
 
 	struct snd_urb_ctx urb[MAX_URBS];
 
* Unmerged path sound/usb/endpoint.c
