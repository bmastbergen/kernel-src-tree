xfs: Simplify xfs_attr_leaf_addname

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Allison Collins <allison.henderson@oracle.com>
commit 5fdca0ad5c95464a60c5954f853c22127f8bb64f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5fdca0ad.failed

Invert the rename logic in xfs_attr_leaf_addname to simplify the
delayed attr logic later.

	Signed-off-by: Allison Collins <allison.henderson@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Acked-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 5fdca0ad5c95464a60c5954f853c22127f8bb64f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr.c
diff --cc fs/xfs/libxfs/xfs_attr.c
index 9cb14a5eed33,44288e4baea7..000000000000
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@@ -601,91 -695,93 +601,158 @@@ xfs_attr_leaf_addname
  			return error;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * If this is an atomic rename operation, we must "flip" the
 +	 * incomplete flags on the "new" and "old" attribute/value pairs
 +	 * so that one disappears and one appears atomically.  Then we
 +	 * must remove the "old" attribute/value pair.
 +	 */
 +	if (args->op_flags & XFS_DA_OP_RENAME) {
 +		/*
 +		 * In a separate transaction, set the incomplete flag on the
 +		 * "old" attr and clear the incomplete flag on the "new" attr.
 +		 */
 +		error = xfs_attr3_leaf_flipflags(args);
 +		if (error)
 +			return error;
 +		/*
 +		 * Commit the flag value change and start the next trans in
 +		 * series.
 +		 */
 +		error = xfs_trans_roll_inode(&args->trans, args->dp);
 +		if (error)
 +			return error;
 +
 +		/*
 +		 * Dismantle the "old" attribute/value pair by removing
 +		 * a "remote" value (if it exists).
 +		 */
 +		xfs_attr_restore_rmt_blk(args);
 +
 +		if (args->rmtblkno) {
 +			error = xfs_attr_rmtval_invalidate(args);
 +			if (error)
 +				return error;
 +
 +			error = xfs_attr_rmtval_remove(args);
 +			if (error)
 +				return error;
 +		}
 +
 +		/*
 +		 * Read in the block containing the "old" attr, then
 +		 * remove the "old" attr from that block (neat, huh!)
 +		 */
 +		error = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,
 +					   &bp);
 +		if (error)
 +			return error;
 +
 +		xfs_attr3_leaf_remove(bp, args);
 +
 +		/*
 +		 * If the result is small enough, shrink it all into the inode.
 +		 */
 +		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
 +			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 +			/* bp is gone due to xfs_da_shrink_inode */
 +			if (error)
 +				return error;
 +			error = xfs_defer_finish(&args->trans);
 +			if (error)
 +				return error;
 +		}
 +
 +		/*
 +		 * Commit the remove and start the next trans in series.
 +		 */
 +		error = xfs_trans_roll_inode(&args->trans, dp);
 +
 +	} else if (args->rmtblkno > 0) {
 +		/*
 +		 * Added a "remote" value, just clear the incomplete flag.
 +		 */
 +		error = xfs_attr3_leaf_clearflag(args);
 +		if (error)
 +			return error;
 +
 +		/*
 +		 * Commit the flag value change and start the next trans in
 +		 * series.
 +		 */
 +		error = xfs_trans_roll_inode(&args->trans, args->dp);
++=======
+ 	if (!(args->op_flags & XFS_DA_OP_RENAME)) {
+ 		/*
+ 		 * Added a "remote" value, just clear the incomplete flag.
+ 		 */
+ 		if (args->rmtblkno > 0)
+ 			error = xfs_attr3_leaf_clearflag(args);
+ 
+ 		return error;
++>>>>>>> 5fdca0ad5c95 (xfs: Simplify xfs_attr_leaf_addname)
  	}
+ 
+ 	/*
+ 	 * If this is an atomic rename operation, we must "flip" the incomplete
+ 	 * flags on the "new" and "old" attribute/value pairs so that one
+ 	 * disappears and one appears atomically.  Then we must remove the "old"
+ 	 * attribute/value pair.
+ 	 *
+ 	 * In a separate transaction, set the incomplete flag on the "old" attr
+ 	 * and clear the incomplete flag on the "new" attr.
+ 	 */
+ 
+ 	error = xfs_attr3_leaf_flipflags(args);
+ 	if (error)
+ 		return error;
+ 	/*
+ 	 * Commit the flag value change and start the next trans in series.
+ 	 */
+ 	error = xfs_trans_roll_inode(&args->trans, args->dp);
+ 	if (error)
+ 		return error;
+ 
+ 	/*
+ 	 * Dismantle the "old" attribute/value pair by removing a "remote" value
+ 	 * (if it exists).
+ 	 */
+ 	xfs_attr_restore_rmt_blk(args);
+ 
+ 	if (args->rmtblkno) {
+ 		error = xfs_attr_rmtval_invalidate(args);
+ 		if (error)
+ 			return error;
+ 
+ 		error = xfs_attr_rmtval_remove(args);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * Read in the block containing the "old" attr, then remove the "old"
+ 	 * attr from that block (neat, huh!)
+ 	 */
+ 	error = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,
+ 				   &bp);
+ 	if (error)
+ 		return error;
+ 
+ 	xfs_attr3_leaf_remove(bp, args);
+ 
+ 	/*
+ 	 * If the result is small enough, shrink it all into the inode.
+ 	 */
+ 	forkoff = xfs_attr_shortform_allfit(bp, dp);
+ 	if (forkoff)
+ 		error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
+ 		/* bp is gone due to xfs_da_shrink_inode */
+ 
  	return error;
 -}
 -
 -/*
 - * Return EEXIST if attr is found, or ENOATTR if not
 - */
 -STATIC int
 -xfs_attr_leaf_hasname(
 -	struct xfs_da_args	*args,
 -	struct xfs_buf		**bp)
 -{
 -	int                     error = 0;
 -
 -	error = xfs_attr3_leaf_read(args->trans, args->dp, 0, bp);
 -	if (error)
 -		return error;
 -
 -	error = xfs_attr3_leaf_lookup_int(*bp, args);
 -	if (error != -ENOATTR && error != -EEXIST)
 -		xfs_trans_brelse(args->trans, *bp);
 -
 -	return error;
 +out_brelse:
 +	xfs_trans_brelse(args->trans, bp);
 +	return retval;
  }
  
  /*
* Unmerged path fs/xfs/libxfs/xfs_attr.c
