perf: Break deadlock involving exec_update_mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author peterz@infradead.org <peterz@infradead.org>
commit 78af4dc949daaa37b3fcd5f348f373085b4e858f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/78af4dc9.failed

Syzbot reported a lock inversion involving perf. The sore point being
perf holding exec_update_mutex() for a very long time, specifically
across a whole bunch of filesystem ops in pmu::event_init() (uprobes)
and anon_inode_getfile().

This then inverts against procfs code trying to take
exec_update_mutex.

Move the permission checks later, such that we need to hold the mutex
over less code.

	Reported-by: syzbot+db9cdf3dd1f64252c6ef@syzkaller.appspotmail.com
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
(cherry picked from commit 78af4dc949daaa37b3fcd5f348f373085b4e858f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index dfaf9a30d869,19ae6c931c52..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -11725,24 -11832,6 +11725,27 @@@ SYSCALL_DEFINE5(perf_event_open
  		goto err_task;
  	}
  
++<<<<<<< HEAD
 +	if (task) {
 +		err = mutex_lock_interruptible(&task->signal->cred_guard_mutex);
 +		if (err)
 +			goto err_task;
 +
 +		/*
 +		 * Preserve ptrace permission check for backwards compatibility.
 +		 *
 +		 * We must hold cred_guard_mutex across this and any potential
 +		 * perf_install_in_context() call for this new event to
 +		 * serialize against exec() altering our credentials (and the
 +		 * perf_event_exit_task() that could imply).
 +		 */
 +		err = -EACCES;
 +		if (!perfmon_capable() && !ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
 +			goto err_cred;
 +	}
 +
++=======
++>>>>>>> 78af4dc949da (perf: Break deadlock involving exec_update_mutex)
  	if (flags & PERF_FLAG_PID_CGROUP)
  		cgroup_fd = pid;
  
@@@ -12056,9 -12166,6 +12080,12 @@@ err_alloc
  	 */
  	if (!event_file)
  		free_event(event);
++<<<<<<< HEAD
 +err_cred:
 +	if (task)
 +		mutex_unlock(&task->signal->cred_guard_mutex);
++=======
++>>>>>>> 78af4dc949da (perf: Break deadlock involving exec_update_mutex)
  err_task:
  	if (task)
  		put_task_struct(task);
* Unmerged path kernel/events/core.c
