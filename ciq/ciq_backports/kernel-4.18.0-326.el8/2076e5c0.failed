mm/hmm: update HMM documentation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ralph Campbell <rcampbell@nvidia.com>
commit 2076e5c0451ca943ff8ecc6def7239c84c77e070
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/2076e5c0.failed

Update the HMM documentation to reflect the latest API and make a few
minor wording changes.

	Cc: John Hubbard <jhubbard@nvidia.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Balbir Singh <bsingharora@gmail.com>
	Cc: Dan Carpenter <dan.carpenter@oracle.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Souptick Joarder <jrdr.linux@gmail.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Ralph Campbell <rcampbell@nvidia.com>
	Reviewed-by: Jérôme Glisse <jglisse@redhat.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 2076e5c0451ca943ff8ecc6def7239c84c77e070)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/vm/hmm.rst
diff --cc Documentation/vm/hmm.rst
index b4b84a2cecd8,7b6eeda5a7c0..000000000000
--- a/Documentation/vm/hmm.rst
+++ b/Documentation/vm/hmm.rst
@@@ -329,6 -336,32 +336,35 @@@ directly using struct page for device m
  unaware of the difference. We only need to make sure that no one ever tries to
  map those pages from the CPU side.
  
++<<<<<<< HEAD
++=======
+ HMM provides a set of helpers to register and hotplug device memory as a new
+ region needing a struct page. This is offered through a very simple API::
+ 
+  struct hmm_devmem *hmm_devmem_add(const struct hmm_devmem_ops *ops,
+                                    struct device *device,
+                                    unsigned long size);
+  void hmm_devmem_remove(struct hmm_devmem *devmem);
+ 
+ The hmm_devmem_ops is where most of the important things are::
+ 
+  struct hmm_devmem_ops {
+      void (*free)(struct hmm_devmem *devmem, struct page *page);
+      vm_fault_t (*fault)(struct hmm_devmem *devmem,
+                   struct vm_area_struct *vma,
+                   unsigned long addr,
+                   struct page *page,
+                   unsigned flags,
+                   pmd_t *pmdp);
+  };
+ 
+ The first callback (free()) happens when the last reference on a device page is
+ dropped. This means the device page is now free and no longer used by anyone.
+ The second callback happens whenever the CPU tries to access a device page
+ which it cannot do. This second callback must trigger a migration back to
+ system memory.
+ 
++>>>>>>> 2076e5c0451c (mm/hmm: update HMM documentation)
  
  Migration to and from device memory
  ===================================
* Unmerged path Documentation/vm/hmm.rst
diff --git a/include/linux/hmm.h b/include/linux/hmm.h
index 86b23fe09dc9..741633a47b88 100644
--- a/include/linux/hmm.h
+++ b/include/linux/hmm.h
@@ -428,9 +428,10 @@ struct hmm_mirror_ops {
 	 *
 	 * @mirror: pointer to struct hmm_mirror
 	 *
-	 * This is called when the mm_struct is being released.
-	 * The callback should make sure no references to the mirror occur
-	 * after the callback returns.
+	 * This is called when the mm_struct is being released.  The callback
+	 * must ensure that all access to any pages obtained from this mirror
+	 * is halted before the callback returns. All future access should
+	 * fault.
 	 */
 	void (*release)(struct hmm_mirror *mirror);
 
