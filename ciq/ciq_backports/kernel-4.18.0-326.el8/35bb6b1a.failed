drm/i915: Convert DG1 over to .{enable,disable}_clock()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 35bb6b1a0d19ef619cdfe2bcf6d95c0625f9492e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/35bb6b1a.failed

Replace dg1_{map,unmap}_plls_to_ports() with the appropriate
encoder vfuncs. And let's relocate the disable function next to
the enable function while at it.

	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210205214634.19341-7-ville.syrjala@linux.intel.com
(cherry picked from commit 35bb6b1a0d19ef619cdfe2bcf6d95c0625f9492e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 87726ca7041c,4a0798b5cc30..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -2816,17 -1599,79 +2816,79 @@@ static u32 icl_dpclka_cfgcr0_clk_off(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void icl_map_plls_to_ports(struct intel_encoder *encoder,
 +				  const struct intel_crtc_state *crtc_state)
++=======
+ static void dg1_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
++>>>>>>> 35bb6b1a0d19 (drm/i915: Convert DG1 over to .{enable,disable}_clock())
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
  	struct intel_shared_dpll *pll = crtc_state->shared_dpll;
  	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
  	u32 val;
  
 -	/*
 -	 * If we fail this, something went very wrong: first 2 PLLs should be
 -	 * used by first 2 phys and last 2 PLLs by last phys
 -	 */
 -	if (drm_WARN_ON(&dev_priv->drm,
 -			(pll->info->id < DPLL_ID_DG1_DPLL2 && phy >= PHY_C) ||
 -			(pll->info->id >= DPLL_ID_DG1_DPLL2 && phy < PHY_C)))
 -		return;
 -
  	mutex_lock(&dev_priv->dpll.lock);
  
++<<<<<<< HEAD
 +	val = intel_de_read(dev_priv, ICL_DPCLKA_CFGCR0);
++=======
+ 	val = intel_de_read(dev_priv, DG1_DPCLKA_CFGCR0(phy));
+ 	drm_WARN_ON(&dev_priv->drm,
+ 		    (val & DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy)) == 0);
+ 
+ 	val &= ~DG1_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);
+ 	val |= DG1_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);
+ 	intel_de_write(dev_priv, DG1_DPCLKA_CFGCR0(phy), val);
+ 	intel_de_posting_read(dev_priv, DG1_DPCLKA_CFGCR0(phy));
+ 
+ 	val &= ~DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy);
+ 	intel_de_write(dev_priv, DG1_DPCLKA_CFGCR0(phy), val);
+ 
+ 	mutex_unlock(&dev_priv->dpll.lock);
+ }
+ 
+ static void dg1_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
+ 
+ 	mutex_lock(&dev_priv->dpll.lock);
+ 
+ 	intel_de_rmw(dev_priv, DG1_DPCLKA_CFGCR0(phy), 0,
+ 		     DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ 
+ 	mutex_unlock(&dev_priv->dpll.lock);
+ }
+ 
+ static void icl_map_plls_to_ports(struct intel_encoder *encoder,
+ 				  const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
+ 	u32 val, mask, sel;
+ 	i915_reg_t reg;
+ 
+ 	if (IS_ALDERLAKE_S(dev_priv)) {
+ 		reg = ADLS_DPCLKA_CFGCR(phy);
+ 		mask = ADLS_DPCLKA_CFGCR_DDI_CLK_SEL_MASK(phy);
+ 		sel = ((pll->info->id) << ADLS_DPCLKA_CFGCR_DDI_SHIFT(phy));
+ 	} else if (IS_ROCKETLAKE(dev_priv)) {
+ 		reg = ICL_DPCLKA_CFGCR0;
+ 		mask = RKL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);
+ 		sel = RKL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);
+ 	} else {
+ 		reg = ICL_DPCLKA_CFGCR0;
+ 		mask = ICL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);
+ 		sel = ICL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);
+ 	}
+ 
+ 	mutex_lock(&dev_priv->dpll.lock);
+ 
+ 	val = intel_de_read(dev_priv, reg);
++>>>>>>> 35bb6b1a0d19 (drm/i915: Convert DG1 over to .{enable,disable}_clock())
  	drm_WARN_ON(&dev_priv->drm,
  		    (val & icl_dpclka_cfgcr0_clk_off(dev_priv, phy)) == 0);
  
@@@ -2858,7 -1693,7 +2920,11 @@@
  	}
  
  	val &= ~icl_dpclka_cfgcr0_clk_off(dev_priv, phy);
++<<<<<<< HEAD
 +	intel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, val);
++=======
+ 	intel_de_write(dev_priv, reg, val);
++>>>>>>> 35bb6b1a0d19 (drm/i915: Convert DG1 over to .{enable,disable}_clock())
  
  	mutex_unlock(&dev_priv->dpll.lock);
  }
@@@ -3485,7 -2479,7 +3551,11 @@@ static void intel_ddi_pre_enable(struc
  
  	drm_WARN_ON(&dev_priv->drm, crtc_state->has_pch_encoder);
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) >= 11)
++=======
+ 	if (!IS_DG1(dev_priv) && INTEL_GEN(dev_priv) >= 11)
++>>>>>>> 35bb6b1a0d19 (drm/i915: Convert DG1 over to .{enable,disable}_clock())
  		icl_map_plls_to_ports(encoder, crtc_state);
  
  	intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);
@@@ -3671,7 -2680,7 +3741,11 @@@ static void intel_ddi_post_disable(stru
  		intel_ddi_post_disable_dp(state, encoder, old_crtc_state,
  					  old_conn_state);
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) >= 11)
++=======
+ 	if (!IS_DG1(dev_priv) && INTEL_GEN(dev_priv) >= 11)
++>>>>>>> 35bb6b1a0d19 (drm/i915: Convert DG1 over to .{enable,disable}_clock())
  		icl_unmap_plls_to_ports(encoder);
  
  	if (intel_crtc_has_dp_encoder(old_crtc_state) || is_tc_port)
@@@ -4970,6 -4133,37 +5044,40 @@@ void intel_ddi_init(struct drm_i915_pri
  	encoder->cloneable = 0;
  	encoder->pipe_mask = ~0;
  
++<<<<<<< HEAD
++=======
+ 	if (IS_DG1(dev_priv)) {
+ 		encoder->enable_clock = dg1_ddi_enable_clock;
+ 		encoder->disable_clock = dg1_ddi_disable_clock;
+ 	} else if (IS_CANNONLAKE(dev_priv)) {
+ 		encoder->enable_clock = cnl_ddi_enable_clock;
+ 		encoder->disable_clock = cnl_ddi_disable_clock;
+ 	} else if (IS_GEN9_BC(dev_priv)) {
+ 		encoder->enable_clock = skl_ddi_enable_clock;
+ 		encoder->disable_clock = skl_ddi_disable_clock;
+ 	} else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {
+ 		encoder->enable_clock = hsw_ddi_enable_clock;
+ 		encoder->disable_clock = hsw_ddi_disable_clock;
+ 	}
+ 
+ 	if (IS_DG1(dev_priv))
+ 		encoder->hpd_pin = dg1_hpd_pin(dev_priv, port);
+ 	else if (IS_ROCKETLAKE(dev_priv))
+ 		encoder->hpd_pin = rkl_hpd_pin(dev_priv, port);
+ 	else if (INTEL_GEN(dev_priv) >= 12)
+ 		encoder->hpd_pin = tgl_hpd_pin(dev_priv, port);
+ 	else if (IS_JSL_EHL(dev_priv))
+ 		encoder->hpd_pin = ehl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 11))
+ 		encoder->hpd_pin = icl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 10))
+ 		encoder->hpd_pin = cnl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 9))
+ 		encoder->hpd_pin = skl_hpd_pin(dev_priv, port);
+ 	else
+ 		encoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);
+ 
++>>>>>>> 35bb6b1a0d19 (drm/i915: Convert DG1 over to .{enable,disable}_clock())
  	if (INTEL_GEN(dev_priv) >= 11)
  		dig_port->saved_port_bits =
  			intel_de_read(dev_priv, DDI_BUF_CTL(port))
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
