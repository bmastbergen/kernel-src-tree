net/mlx5e: TC, Refactor tc update skb function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Chris Mi <cmi@nvidia.com>
commit 7319a1cc3ca9f719e4ef1b1882f6fdb57d0719b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/7319a1cc.failed

As a pre-step to process sampled packet in this function.

	Signed-off-by: Chris Mi <cmi@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 7319a1cc3ca9f719e4ef1b1882f6fdb57d0719b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
index 0664a4e01bff,a25ec309d298..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
@@@ -609,14 -647,10 +639,21 @@@ bool mlx5e_rep_tc_update_skb(struct mlx
  			     struct sk_buff *skb,
  			     struct mlx5e_tc_update_priv *tc_priv)
  {
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
 +	u32 chain = 0, reg_c0, reg_c1, tunnel_id, zone_restore_id;
 +	struct mlx5_rep_uplink_priv *uplink_priv;
 +	struct mlx5e_rep_priv *uplink_rpriv;
 +	struct tc_skb_ext *tc_skb_ext;
 +	struct mlx5_eswitch *esw;
 +	struct mlx5e_priv *priv;
 +	int tunnel_moffset;
++=======
+ 	struct mlx5_mapped_obj mapped_obj;
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5e_priv *priv;
+ 	u32 reg_c0, reg_c1;
++>>>>>>> 7319a1cc3ca9 (net/mlx5e: TC, Refactor tc update skb function)
  	int err;
  
  	reg_c0 = (be32_to_cpu(cqe->sop_drop_qpn) & MLX5E_TC_FLOW_ID_MASK);
@@@ -632,38 -662,25 +669,52 @@@
  	 */
  	skb->mark = 0;
  
 -	reg_c1 = be32_to_cpu(cqe->ft_metadata);
 -
  	priv = netdev_priv(skb->dev);
  	esw = priv->mdev->priv.eswitch;
++<<<<<<< HEAD
 +
 +	err = mlx5_get_chain_for_tag(esw_chains(esw), reg_c0, &chain);
++=======
+ 	err = mapping_find(esw->offloads.reg_c0_obj_pool, reg_c0, &mapped_obj);
++>>>>>>> 7319a1cc3ca9 (net/mlx5e: TC, Refactor tc update skb function)
  	if (err) {
  		netdev_dbg(priv->netdev,
 -			   "Couldn't find mapped object for reg_c0: %d, err: %d\n",
 +			   "Couldn't find chain for chain tag: %d, err: %d\n",
  			   reg_c0, err);
  		return false;
  	}
  
++<<<<<<< HEAD
 +	if (chain) {
 +		tc_skb_ext = skb_ext_add(skb, TC_SKB_EXT);
 +		if (!tc_skb_ext) {
 +			WARN_ON(1);
 +			return false;
 +		}
 +
 +		tc_skb_ext->chain = chain;
 +
 +		zone_restore_id = reg_c1 & ZONE_RESTORE_MAX;
 +
 +		uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
 +		uplink_priv = &uplink_rpriv->uplink_priv;
 +		if (!mlx5e_tc_ct_restore_flow(uplink_priv, skb,
 +					      zone_restore_id))
 +			return false;
 +	}
 +
 +	tunnel_moffset = mlx5e_tc_attr_to_reg_mappings[TUNNEL_TO_REG].moffset;
 +	tunnel_id = reg_c1 >> (8 * tunnel_moffset);
 +	return mlx5e_restore_tunnel(priv, skb, tc_priv, tunnel_id);
++=======
+ #if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+ 	if (mapped_obj.type == MLX5_MAPPED_OBJ_CHAIN) {
+ 		return mlx5e_restore_skb(skb, mapped_obj.chain, reg_c1, tc_priv);
+ 	} else {
+ 		netdev_dbg(priv->netdev, "Invalid mapped object type: %d\n", mapped_obj.type);
+ 		return false;
+ 	}
++>>>>>>> 7319a1cc3ca9 (net/mlx5e: TC, Refactor tc update skb function)
  #endif /* CONFIG_NET_TC_SKB_EXT */
  
  	return true;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
