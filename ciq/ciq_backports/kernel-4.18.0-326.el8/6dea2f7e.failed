net/mlx5: Separate probe vs. reload flows

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit 6dea2f7eff9659049f90922283756830364e6278
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/6dea2f7e.failed

The mix between probe/unprobe and reload flows causes to have an extra
mutex lock intf_state_mutex that generates LOCKDEP warning between it
and devlink_mutex. As a preparation for the future removal, separate
those flows.

	Reviewed-by: Moshe Shemesh <moshe@nvidia.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 6dea2f7eff9659049f90922283756830364e6278)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
#	drivers/net/ethernet/mellanox/mlx5/core/fw_reset.c
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
#	drivers/net/ethernet/mellanox/mlx5/core/sf/dev/driver.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index 6a896d13c53b,6729720e1ab7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -87,8 -146,19 +87,24 @@@ static int mlx5_devlink_reload_down(str
  		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	mlx5_unload_one(dev, false);
 +	return 0;
++=======
+ 	switch (action) {
+ 	case DEVLINK_RELOAD_ACTION_DRIVER_REINIT:
+ 		mlx5_unload_one(dev);
+ 		return 0;
+ 	case DEVLINK_RELOAD_ACTION_FW_ACTIVATE:
+ 		if (limit == DEVLINK_RELOAD_LIMIT_NO_RESET)
+ 			return mlx5_devlink_trigger_fw_live_patch(devlink, extack);
+ 		return mlx5_devlink_reload_fw_activate(devlink, extack);
+ 	default:
+ 		/* Unsupported action should not get to this function */
+ 		WARN_ON(1);
+ 		return -EOPNOTSUPP;
+ 	}
++>>>>>>> 6dea2f7eff96 (net/mlx5: Separate probe vs. reload flows)
  }
  
  static int mlx5_devlink_reload_up(struct devlink *devlink, enum devlink_reload_action action,
@@@ -97,8 -167,23 +113,28 @@@
  {
  	struct mlx5_core_dev *dev = devlink_priv(devlink);
  
++<<<<<<< HEAD
 +	*actions_performed = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);
 +	return mlx5_load_one(dev, false);
++=======
+ 	*actions_performed = BIT(action);
+ 	switch (action) {
+ 	case DEVLINK_RELOAD_ACTION_DRIVER_REINIT:
+ 		return mlx5_load_one(dev);
+ 	case DEVLINK_RELOAD_ACTION_FW_ACTIVATE:
+ 		if (limit == DEVLINK_RELOAD_LIMIT_NO_RESET)
+ 			break;
+ 		/* On fw_activate action, also driver is reloaded and reinit performed */
+ 		*actions_performed |= BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);
+ 		return mlx5_load_one(dev);
+ 	default:
+ 		/* Unsupported action should not get to this function */
+ 		WARN_ON(1);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 6dea2f7eff96 (net/mlx5: Separate probe vs. reload flows)
  }
  
  static struct mlx5_devlink_trap *mlx5_find_trap_by_id(struct mlx5_core_dev *dev, int trap_id)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fw_reset.c
index 7feae827b4bc,255bd0059da1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fw_reset.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fw_reset.c
@@@ -49,3 -95,369 +49,372 @@@ int mlx5_fw_reset_set_live_patch(struc
  {
  	return mlx5_reg_mfrl_set(dev, MLX5_MFRL_REG_RESET_LEVEL0, 0, 0, false);
  }
++<<<<<<< HEAD
++=======
+ 
+ static void mlx5_fw_reset_complete_reload(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;
+ 
+ 	/* if this is the driver that initiated the fw reset, devlink completed the reload */
+ 	if (test_bit(MLX5_FW_RESET_FLAGS_PENDING_COMP, &fw_reset->reset_flags)) {
+ 		complete(&fw_reset->done);
+ 	} else {
+ 		mlx5_load_one(dev);
+ 		devlink_remote_reload_actions_performed(priv_to_devlink(dev), 0,
+ 							BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |
+ 							BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE));
+ 	}
+ }
+ 
+ static void mlx5_sync_reset_reload_work(struct work_struct *work)
+ {
+ 	struct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,
+ 						      reset_reload_work);
+ 	struct mlx5_core_dev *dev = fw_reset->dev;
+ 	int err;
+ 
+ 	mlx5_enter_error_state(dev, true);
+ 	mlx5_unload_one(dev);
+ 	err = mlx5_health_wait_pci_up(dev);
+ 	if (err)
+ 		mlx5_core_err(dev, "reset reload flow aborted, PCI reads still not working\n");
+ 	fw_reset->ret = err;
+ 	mlx5_fw_reset_complete_reload(dev);
+ }
+ 
+ static void mlx5_stop_sync_reset_poll(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;
+ 
+ 	del_timer(&fw_reset->timer);
+ }
+ 
+ static void mlx5_sync_reset_clear_reset_requested(struct mlx5_core_dev *dev, bool poll_health)
+ {
+ 	struct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;
+ 
+ 	mlx5_stop_sync_reset_poll(dev);
+ 	clear_bit(MLX5_FW_RESET_FLAGS_RESET_REQUESTED, &fw_reset->reset_flags);
+ 	if (poll_health)
+ 		mlx5_start_health_poll(dev);
+ }
+ 
+ #define MLX5_RESET_POLL_INTERVAL	(HZ / 10)
+ static void poll_sync_reset(struct timer_list *t)
+ {
+ 	struct mlx5_fw_reset *fw_reset = from_timer(fw_reset, t, timer);
+ 	struct mlx5_core_dev *dev = fw_reset->dev;
+ 	u32 fatal_error;
+ 
+ 	if (!test_bit(MLX5_FW_RESET_FLAGS_RESET_REQUESTED, &fw_reset->reset_flags))
+ 		return;
+ 
+ 	fatal_error = mlx5_health_check_fatal_sensors(dev);
+ 
+ 	if (fatal_error) {
+ 		mlx5_core_warn(dev, "Got Device Reset\n");
+ 		mlx5_sync_reset_clear_reset_requested(dev, false);
+ 		queue_work(fw_reset->wq, &fw_reset->reset_reload_work);
+ 		return;
+ 	}
+ 
+ 	mod_timer(&fw_reset->timer, round_jiffies(jiffies + MLX5_RESET_POLL_INTERVAL));
+ }
+ 
+ static void mlx5_start_sync_reset_poll(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;
+ 
+ 	timer_setup(&fw_reset->timer, poll_sync_reset, 0);
+ 	fw_reset->timer.expires = round_jiffies(jiffies + MLX5_RESET_POLL_INTERVAL);
+ 	add_timer(&fw_reset->timer);
+ }
+ 
+ static int mlx5_fw_reset_set_reset_sync_ack(struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_reg_mfrl_set(dev, MLX5_MFRL_REG_RESET_LEVEL3, 0, 1, false);
+ }
+ 
+ static int mlx5_fw_reset_set_reset_sync_nack(struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_reg_mfrl_set(dev, MLX5_MFRL_REG_RESET_LEVEL3, 0, 2, false);
+ }
+ 
+ static void mlx5_sync_reset_set_reset_requested(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;
+ 
+ 	mlx5_stop_health_poll(dev, true);
+ 	set_bit(MLX5_FW_RESET_FLAGS_RESET_REQUESTED, &fw_reset->reset_flags);
+ 	mlx5_start_sync_reset_poll(dev);
+ }
+ 
+ static void mlx5_fw_live_patch_event(struct work_struct *work)
+ {
+ 	struct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,
+ 						      fw_live_patch_work);
+ 	struct mlx5_core_dev *dev = fw_reset->dev;
+ 	struct mlx5_fw_tracer *tracer;
+ 
+ 	mlx5_core_info(dev, "Live patch updated firmware version: %d.%d.%d\n", fw_rev_maj(dev),
+ 		       fw_rev_min(dev), fw_rev_sub(dev));
+ 
+ 	tracer = dev->tracer;
+ 	if (IS_ERR_OR_NULL(tracer))
+ 		return;
+ 
+ 	if (mlx5_fw_tracer_reload(tracer))
+ 		mlx5_core_err(dev, "Failed to reload FW tracer\n");
+ }
+ 
+ static void mlx5_sync_reset_request_event(struct work_struct *work)
+ {
+ 	struct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,
+ 						      reset_request_work);
+ 	struct mlx5_core_dev *dev = fw_reset->dev;
+ 	int err;
+ 
+ 	if (test_bit(MLX5_FW_RESET_FLAGS_NACK_RESET_REQUEST, &fw_reset->reset_flags)) {
+ 		err = mlx5_fw_reset_set_reset_sync_nack(dev);
+ 		mlx5_core_warn(dev, "PCI Sync FW Update Reset Nack %s",
+ 			       err ? "Failed" : "Sent");
+ 		return;
+ 	}
+ 	mlx5_sync_reset_set_reset_requested(dev);
+ 	err = mlx5_fw_reset_set_reset_sync_ack(dev);
+ 	if (err)
+ 		mlx5_core_warn(dev, "PCI Sync FW Update Reset Ack Failed. Error code: %d\n", err);
+ 	else
+ 		mlx5_core_warn(dev, "PCI Sync FW Update Reset Ack. Device reset is expected.\n");
+ }
+ 
+ #define MLX5_PCI_LINK_UP_TIMEOUT 2000
+ 
+ static int mlx5_pci_link_toggle(struct mlx5_core_dev *dev)
+ {
+ 	struct pci_bus *bridge_bus = dev->pdev->bus;
+ 	struct pci_dev *bridge = bridge_bus->self;
+ 	u16 reg16, dev_id, sdev_id;
+ 	unsigned long timeout;
+ 	struct pci_dev *sdev;
+ 	int cap, err;
+ 	u32 reg32;
+ 
+ 	/* Check that all functions under the pci bridge are PFs of
+ 	 * this device otherwise fail this function.
+ 	 */
+ 	err = pci_read_config_word(dev->pdev, PCI_DEVICE_ID, &dev_id);
+ 	if (err)
+ 		return err;
+ 	list_for_each_entry(sdev, &bridge_bus->devices, bus_list) {
+ 		err = pci_read_config_word(sdev, PCI_DEVICE_ID, &sdev_id);
+ 		if (err)
+ 			return err;
+ 		if (sdev_id != dev_id)
+ 			return -EPERM;
+ 	}
+ 
+ 	cap = pci_find_capability(bridge, PCI_CAP_ID_EXP);
+ 	if (!cap)
+ 		return -EOPNOTSUPP;
+ 
+ 	list_for_each_entry(sdev, &bridge_bus->devices, bus_list) {
+ 		pci_save_state(sdev);
+ 		pci_cfg_access_lock(sdev);
+ 	}
+ 	/* PCI link toggle */
+ 	err = pci_read_config_word(bridge, cap + PCI_EXP_LNKCTL, &reg16);
+ 	if (err)
+ 		return err;
+ 	reg16 |= PCI_EXP_LNKCTL_LD;
+ 	err = pci_write_config_word(bridge, cap + PCI_EXP_LNKCTL, reg16);
+ 	if (err)
+ 		return err;
+ 	msleep(500);
+ 	reg16 &= ~PCI_EXP_LNKCTL_LD;
+ 	err = pci_write_config_word(bridge, cap + PCI_EXP_LNKCTL, reg16);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Check link */
+ 	err = pci_read_config_dword(bridge, cap + PCI_EXP_LNKCAP, &reg32);
+ 	if (err)
+ 		return err;
+ 	if (!(reg32 & PCI_EXP_LNKCAP_DLLLARC)) {
+ 		mlx5_core_warn(dev, "No PCI link reporting capability (0x%08x)\n", reg32);
+ 		msleep(1000);
+ 		goto restore;
+ 	}
+ 
+ 	timeout = jiffies + msecs_to_jiffies(MLX5_PCI_LINK_UP_TIMEOUT);
+ 	do {
+ 		err = pci_read_config_word(bridge, cap + PCI_EXP_LNKSTA, &reg16);
+ 		if (err)
+ 			return err;
+ 		if (reg16 & PCI_EXP_LNKSTA_DLLLA)
+ 			break;
+ 		msleep(20);
+ 	} while (!time_after(jiffies, timeout));
+ 
+ 	if (reg16 & PCI_EXP_LNKSTA_DLLLA) {
+ 		mlx5_core_info(dev, "PCI Link up\n");
+ 	} else {
+ 		mlx5_core_err(dev, "PCI link not ready (0x%04x) after %d ms\n",
+ 			      reg16, MLX5_PCI_LINK_UP_TIMEOUT);
+ 		err = -ETIMEDOUT;
+ 	}
+ 
+ restore:
+ 	list_for_each_entry(sdev, &bridge_bus->devices, bus_list) {
+ 		pci_cfg_access_unlock(sdev);
+ 		pci_restore_state(sdev);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static void mlx5_sync_reset_now_event(struct work_struct *work)
+ {
+ 	struct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,
+ 						      reset_now_work);
+ 	struct mlx5_core_dev *dev = fw_reset->dev;
+ 	int err;
+ 
+ 	mlx5_sync_reset_clear_reset_requested(dev, false);
+ 
+ 	mlx5_core_warn(dev, "Sync Reset now. Device is going to reset.\n");
+ 
+ 	err = mlx5_cmd_fast_teardown_hca(dev);
+ 	if (err) {
+ 		mlx5_core_warn(dev, "Fast teardown failed, no reset done, err %d\n", err);
+ 		goto done;
+ 	}
+ 
+ 	err = mlx5_pci_link_toggle(dev);
+ 	if (err) {
+ 		mlx5_core_warn(dev, "mlx5_pci_link_toggle failed, no reset done, err %d\n", err);
+ 		goto done;
+ 	}
+ 
+ 	mlx5_enter_error_state(dev, true);
+ 	mlx5_unload_one(dev);
+ done:
+ 	fw_reset->ret = err;
+ 	mlx5_fw_reset_complete_reload(dev);
+ }
+ 
+ static void mlx5_sync_reset_abort_event(struct work_struct *work)
+ {
+ 	struct mlx5_fw_reset *fw_reset = container_of(work, struct mlx5_fw_reset,
+ 						      reset_abort_work);
+ 	struct mlx5_core_dev *dev = fw_reset->dev;
+ 
+ 	mlx5_sync_reset_clear_reset_requested(dev, true);
+ 	mlx5_core_warn(dev, "PCI Sync FW Update Reset Aborted.\n");
+ }
+ 
+ static void mlx5_sync_reset_events_handle(struct mlx5_fw_reset *fw_reset, struct mlx5_eqe *eqe)
+ {
+ 	struct mlx5_eqe_sync_fw_update *sync_fw_update_eqe;
+ 	u8 sync_event_rst_type;
+ 
+ 	sync_fw_update_eqe = &eqe->data.sync_fw_update;
+ 	sync_event_rst_type = sync_fw_update_eqe->sync_rst_state & SYNC_RST_STATE_MASK;
+ 	switch (sync_event_rst_type) {
+ 	case MLX5_SYNC_RST_STATE_RESET_REQUEST:
+ 		queue_work(fw_reset->wq, &fw_reset->reset_request_work);
+ 		break;
+ 	case MLX5_SYNC_RST_STATE_RESET_NOW:
+ 		queue_work(fw_reset->wq, &fw_reset->reset_now_work);
+ 		break;
+ 	case MLX5_SYNC_RST_STATE_RESET_ABORT:
+ 		queue_work(fw_reset->wq, &fw_reset->reset_abort_work);
+ 		break;
+ 	}
+ }
+ 
+ static int fw_reset_event_notifier(struct notifier_block *nb, unsigned long action, void *data)
+ {
+ 	struct mlx5_fw_reset *fw_reset = mlx5_nb_cof(nb, struct mlx5_fw_reset, nb);
+ 	struct mlx5_eqe *eqe = data;
+ 
+ 	switch (eqe->sub_type) {
+ 	case MLX5_GENERAL_SUBTYPE_FW_LIVE_PATCH_EVENT:
+ 			queue_work(fw_reset->wq, &fw_reset->fw_live_patch_work);
+ 		break;
+ 	case MLX5_GENERAL_SUBTYPE_PCI_SYNC_FOR_FW_UPDATE_EVENT:
+ 		mlx5_sync_reset_events_handle(fw_reset, eqe);
+ 		break;
+ 	default:
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ #define MLX5_FW_RESET_TIMEOUT_MSEC 5000
+ int mlx5_fw_reset_wait_reset_done(struct mlx5_core_dev *dev)
+ {
+ 	unsigned long timeout = msecs_to_jiffies(MLX5_FW_RESET_TIMEOUT_MSEC);
+ 	struct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;
+ 	int err;
+ 
+ 	if (!wait_for_completion_timeout(&fw_reset->done, timeout)) {
+ 		mlx5_core_warn(dev, "FW sync reset timeout after %d seconds\n",
+ 			       MLX5_FW_RESET_TIMEOUT_MSEC / 1000);
+ 		err = -ETIMEDOUT;
+ 		goto out;
+ 	}
+ 	err = fw_reset->ret;
+ out:
+ 	clear_bit(MLX5_FW_RESET_FLAGS_PENDING_COMP, &fw_reset->reset_flags);
+ 	return err;
+ }
+ 
+ void mlx5_fw_reset_events_start(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;
+ 
+ 	MLX5_NB_INIT(&fw_reset->nb, fw_reset_event_notifier, GENERAL_EVENT);
+ 	mlx5_eq_notifier_register(dev, &fw_reset->nb);
+ }
+ 
+ void mlx5_fw_reset_events_stop(struct mlx5_core_dev *dev)
+ {
+ 	mlx5_eq_notifier_unregister(dev, &dev->priv.fw_reset->nb);
+ }
+ 
+ int mlx5_fw_reset_init(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_fw_reset *fw_reset = kzalloc(sizeof(*fw_reset), GFP_KERNEL);
+ 
+ 	if (!fw_reset)
+ 		return -ENOMEM;
+ 	fw_reset->wq = create_singlethread_workqueue("mlx5_fw_reset_events");
+ 	if (!fw_reset->wq) {
+ 		kfree(fw_reset);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	fw_reset->dev = dev;
+ 	dev->priv.fw_reset = fw_reset;
+ 
+ 	INIT_WORK(&fw_reset->fw_live_patch_work, mlx5_fw_live_patch_event);
+ 	INIT_WORK(&fw_reset->reset_request_work, mlx5_sync_reset_request_event);
+ 	INIT_WORK(&fw_reset->reset_reload_work, mlx5_sync_reset_reload_work);
+ 	INIT_WORK(&fw_reset->reset_now_work, mlx5_sync_reset_now_event);
+ 	INIT_WORK(&fw_reset->reset_abort_work, mlx5_sync_reset_abort_event);
+ 
+ 	init_completion(&fw_reset->done);
+ 	return 0;
+ }
+ 
+ void mlx5_fw_reset_cleanup(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_fw_reset *fw_reset = dev->priv.fw_reset;
+ 
+ 	destroy_workqueue(fw_reset->wq);
+ 	kfree(dev->priv.fw_reset);
+ }
++>>>>>>> 6dea2f7eff96 (net/mlx5: Separate probe vs. reload flows)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 210215550543,02993a51b114..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -250,8 -260,19 +250,22 @@@ enum 
  u8 mlx5_get_nic_state(struct mlx5_core_dev *dev);
  void mlx5_set_nic_state(struct mlx5_core_dev *dev, u8 state);
  
++<<<<<<< HEAD
 +void mlx5_unload_one(struct mlx5_core_dev *dev, bool cleanup);
 +int mlx5_load_one(struct mlx5_core_dev *dev, bool boot);
++=======
+ static inline bool mlx5_core_is_sf(const struct mlx5_core_dev *dev)
+ {
+ 	return dev->coredev_type == MLX5_COREDEV_SF;
+ }
+ 
+ int mlx5_mdev_init(struct mlx5_core_dev *dev, int profile_idx);
+ void mlx5_mdev_uninit(struct mlx5_core_dev *dev);
+ int mlx5_init_one(struct mlx5_core_dev *dev);
+ void mlx5_uninit_one(struct mlx5_core_dev *dev);
+ void mlx5_unload_one(struct mlx5_core_dev *dev);
+ int mlx5_load_one(struct mlx5_core_dev *dev);
 -
 -int mlx5_vport_get_other_func_cap(struct mlx5_core_dev *dev, u16 function_id, void *out);
++>>>>>>> 6dea2f7eff96 (net/mlx5: Separate probe vs. reload flows)
  
  void mlx5_events_work_enqueue(struct mlx5_core_dev *dev, struct work_struct *work);
  #endif /* __MLX5_CORE_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/sf/dev/driver.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fw_reset.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index c11d8b42508a..badf660a13eb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -1222,7 +1222,7 @@ static void mlx5_unload(struct mlx5_core_dev *dev)
 	mlx5_put_uars_page(dev, dev->priv.uar);
 }
 
-int mlx5_load_one(struct mlx5_core_dev *dev, bool boot)
+int mlx5_init_one(struct mlx5_core_dev *dev)
 {
 	int err = 0;
 
@@ -1234,16 +1234,14 @@ int mlx5_load_one(struct mlx5_core_dev *dev, bool boot)
 	/* remove any previous indication of internal error */
 	dev->state = MLX5_DEVICE_STATE_UP;
 
-	err = mlx5_function_setup(dev, boot);
+	err = mlx5_function_setup(dev, true);
 	if (err)
 		goto err_function;
 
-	if (boot) {
-		err = mlx5_init_once(dev);
-		if (err) {
-			mlx5_core_err(dev, "sw objs init failed\n");
-			goto function_teardown;
-		}
+	err = mlx5_init_once(dev);
+	if (err) {
+		mlx5_core_err(dev, "sw objs init failed\n");
+		goto function_teardown;
 	}
 
 	err = mlx5_load(dev);
@@ -1252,16 +1250,11 @@ int mlx5_load_one(struct mlx5_core_dev *dev, bool boot)
 
 	set_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state);
 
-	if (boot) {
-		err = mlx5_devlink_register(priv_to_devlink(dev), dev->device);
-		if (err)
-			goto err_devlink_reg;
-
-		err = mlx5_register_device(dev);
-	} else {
-		err = mlx5_attach_device(dev);
-	}
+	err = mlx5_devlink_register(priv_to_devlink(dev), dev->device);
+	if (err)
+		goto err_devlink_reg;
 
+	err = mlx5_register_device(dev);
 	if (err)
 		goto err_register;
 
@@ -1269,16 +1262,14 @@ int mlx5_load_one(struct mlx5_core_dev *dev, bool boot)
 	return 0;
 
 err_register:
-	if (boot)
-		mlx5_devlink_unregister(priv_to_devlink(dev));
+	mlx5_devlink_unregister(priv_to_devlink(dev));
 err_devlink_reg:
 	clear_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state);
 	mlx5_unload(dev);
 err_load:
-	if (boot)
-		mlx5_cleanup_once(dev);
+	mlx5_cleanup_once(dev);
 function_teardown:
-	mlx5_function_teardown(dev, boot);
+	mlx5_function_teardown(dev, true);
 err_function:
 	dev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;
 out:
@@ -1286,33 +1277,84 @@ int mlx5_load_one(struct mlx5_core_dev *dev, bool boot)
 	return err;
 }
 
-void mlx5_unload_one(struct mlx5_core_dev *dev, bool cleanup)
+void mlx5_uninit_one(struct mlx5_core_dev *dev)
 {
 	mutex_lock(&dev->intf_state_mutex);
 
-	if (cleanup) {
-		mlx5_unregister_device(dev);
-		mlx5_devlink_unregister(priv_to_devlink(dev));
-	} else {
-		mlx5_detach_device(dev);
-	}
+	mlx5_unregister_device(dev);
+	mlx5_devlink_unregister(priv_to_devlink(dev));
 
 	if (!test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
 		mlx5_core_warn(dev, "%s: interface is down, NOP\n",
 			       __func__);
-		if (cleanup)
-			mlx5_cleanup_once(dev);
+		mlx5_cleanup_once(dev);
 		goto out;
 	}
 
 	clear_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state);
+	mlx5_unload(dev);
+	mlx5_cleanup_once(dev);
+	mlx5_function_teardown(dev, true);
+out:
+	mutex_unlock(&dev->intf_state_mutex);
+}
+
+int mlx5_load_one(struct mlx5_core_dev *dev)
+{
+	int err = 0;
+
+	mutex_lock(&dev->intf_state_mutex);
+	if (test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
+		mlx5_core_warn(dev, "interface is up, NOP\n");
+		goto out;
+	}
+	/* remove any previous indication of internal error */
+	dev->state = MLX5_DEVICE_STATE_UP;
+
+	err = mlx5_function_setup(dev, false);
+	if (err)
+		goto err_function;
+
+	err = mlx5_load(dev);
+	if (err)
+		goto err_load;
+
+	set_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state);
 
+	err = mlx5_attach_device(dev);
+	if (err)
+		goto err_attach;
+
+	mutex_unlock(&dev->intf_state_mutex);
+	return 0;
+
+err_attach:
+	clear_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state);
 	mlx5_unload(dev);
+err_load:
+	mlx5_function_teardown(dev, false);
+err_function:
+	dev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;
+out:
+	mutex_unlock(&dev->intf_state_mutex);
+	return err;
+}
 
-	if (cleanup)
-		mlx5_cleanup_once(dev);
+void mlx5_unload_one(struct mlx5_core_dev *dev)
+{
+	mutex_lock(&dev->intf_state_mutex);
+
+	mlx5_detach_device(dev);
+
+	if (!test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
+		mlx5_core_warn(dev, "%s: interface is down, NOP\n",
+			       __func__);
+		goto out;
+	}
 
-	mlx5_function_teardown(dev, cleanup);
+	clear_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state);
+	mlx5_unload(dev);
+	mlx5_function_teardown(dev, false);
 out:
 	mutex_unlock(&dev->intf_state_mutex);
 }
@@ -1384,7 +1426,7 @@ static void mlx5_mdev_uninit(struct mlx5_core_dev *dev)
 	mutex_destroy(&dev->intf_state_mutex);
 }
 
-static int init_one(struct pci_dev *pdev, const struct pci_device_id *id)
+static int probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	struct mlx5_core_dev *dev;
 	struct devlink *devlink;
@@ -1420,11 +1462,11 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		goto pci_init_err;
 	}
 
-	err = mlx5_load_one(dev, true);
+	err = mlx5_init_one(dev);
 	if (err) {
-		mlx5_core_err(dev, "mlx5_load_one failed with error code %d\n",
+		mlx5_core_err(dev, "mlx5_init_one failed with error code %d\n",
 			      err);
-		goto err_load_one;
+		goto err_init_one;
 	}
 
 	err = mlx5_crdump_enable(dev);
@@ -1436,7 +1478,7 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		devlink_reload_enable(devlink);
 	return 0;
 
-err_load_one:
+err_init_one:
 	mlx5_pci_close(dev);
 pci_init_err:
 	mlx5_mdev_uninit(dev);
@@ -1456,7 +1498,7 @@ static void remove_one(struct pci_dev *pdev)
 	devlink_reload_disable(devlink);
 	mlx5_crdump_disable(dev);
 	mlx5_drain_health_wq(dev);
-	mlx5_unload_one(dev, true);
+	mlx5_uninit_one(dev);
 	mlx5_pci_close(dev);
 	mlx5_mdev_uninit(dev);
 	mlx5_adev_idx_free(dev->priv.adev_idx);
@@ -1472,7 +1514,7 @@ static pci_ers_result_t mlx5_pci_err_detected(struct pci_dev *pdev,
 
 	mlx5_enter_error_state(dev, false);
 	mlx5_error_sw_reset(dev);
-	mlx5_unload_one(dev, false);
+	mlx5_unload_one(dev);
 	mlx5_drain_health_wq(dev);
 	mlx5_pci_disable_device(dev);
 
@@ -1542,7 +1584,7 @@ static void mlx5_pci_resume(struct pci_dev *pdev)
 
 	mlx5_core_info(dev, "%s was called\n", __func__);
 
-	err = mlx5_load_one(dev, false);
+	err = mlx5_load_one(dev);
 	if (err)
 		mlx5_core_err(dev, "%s: mlx5_load_one failed with error code: %d\n",
 			      __func__, err);
@@ -1614,7 +1656,7 @@ static void shutdown(struct pci_dev *pdev)
 	mlx5_core_info(dev, "Shutdown was called\n");
 	err = mlx5_try_fast_unload(dev);
 	if (err)
-		mlx5_unload_one(dev, false);
+		mlx5_unload_one(dev);
 	mlx5_pci_disable_device(dev);
 }
 
@@ -1622,7 +1664,7 @@ static int mlx5_suspend(struct pci_dev *pdev, pm_message_t state)
 {
 	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
 
-	mlx5_unload_one(dev, false);
+	mlx5_unload_one(dev);
 
 	return 0;
 }
@@ -1631,7 +1673,7 @@ static int mlx5_resume(struct pci_dev *pdev)
 {
 	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
 
-	return mlx5_load_one(dev, false);
+	return mlx5_load_one(dev);
 }
 
 static const struct pci_device_id mlx5_core_pci_table[] = {
@@ -1663,7 +1705,7 @@ MODULE_DEVICE_TABLE(pci, mlx5_core_pci_table);
 void mlx5_disable_device(struct mlx5_core_dev *dev)
 {
 	mlx5_error_sw_reset(dev);
-	mlx5_unload_one(dev, false);
+	mlx5_unload_one(dev);
 }
 
 void mlx5_recover_device(struct mlx5_core_dev *dev)
@@ -1676,7 +1718,7 @@ void mlx5_recover_device(struct mlx5_core_dev *dev)
 static struct pci_driver mlx5_core_driver = {
 	.name           = KBUILD_MODNAME,
 	.id_table       = mlx5_core_pci_table,
-	.probe          = init_one,
+	.probe          = probe_one,
 	.remove         = remove_one,
 	.suspend        = mlx5_suspend,
 	.resume         = mlx5_resume,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/sf/dev/driver.c
