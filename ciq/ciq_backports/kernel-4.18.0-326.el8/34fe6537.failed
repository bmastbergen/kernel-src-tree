mm/vmalloc.c:__vmalloc_area_node(): avoid 32-bit overflow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Andrew Morton <akpm@linux-foundation.org>
commit 34fe653716b0d340bc26dd4823d2dbe00c57f849
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/34fe6537.failed

With a machine with 3 TB (more than 2 TB memory).  If you use vmalloc to
allocate > 2 TB memory, the array_size below will be overflowed.

The array_size is an unsigned int and can only be used to allocate less
than 2 TB memory.  If you pass 2*1028*1028*1024*1024 = 2 * 2^40 in the
argument of vmalloc.  The array_size will become 2*2^31 = 2^32.  The 2^32
cannot be store with a 32 bit integer.

The fix is to change the type of array_size to unsigned long.

[akpm@linux-foundation.org: rework for current mainline]

Link: https://bugzilla.kernel.org/show_bug.cgi?id=210023
	Reported-by: <hsinhuiwu@gmail.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 34fe653716b0d340bc26dd4823d2dbe00c57f849)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/vmalloc.c
diff --cc mm/vmalloc.c
index fb27844ba07f,8a2dc571bc8d..000000000000
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@@ -2366,22 -2459,21 +2366,36 @@@ static void *__vmalloc_node(unsigned lo
  static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,
  				 pgprot_t prot, int node)
  {
++<<<<<<< HEAD
++=======
+ 	const gfp_t nested_gfp = (gfp_mask & GFP_RECLAIM_MASK) | __GFP_ZERO;
+ 	unsigned int nr_pages = get_vm_area_size(area) >> PAGE_SHIFT;
+ 	unsigned long array_size;
+ 	unsigned int i;
++>>>>>>> 34fe653716b0 (mm/vmalloc.c:__vmalloc_area_node(): avoid 32-bit overflow)
  	struct page **pages;
 -
 +	unsigned int nr_pages, array_size, i;
 +	const gfp_t nested_gfp = (gfp_mask & GFP_RECLAIM_MASK) | __GFP_ZERO;
 +	const gfp_t alloc_mask = gfp_mask | __GFP_NOWARN;
 +	const gfp_t highmem_mask = (gfp_mask & (GFP_DMA | GFP_DMA32)) ?
 +					0 :
 +					__GFP_HIGHMEM;
 +
++<<<<<<< HEAD
 +	nr_pages = get_vm_area_size(area) >> PAGE_SHIFT;
 +	array_size = (nr_pages * sizeof(struct page *));
++=======
+ 	array_size = (unsigned long)nr_pages * sizeof(struct page *);
+ 	gfp_mask |= __GFP_NOWARN;
+ 	if (!(gfp_mask & (GFP_DMA | GFP_DMA32)))
+ 		gfp_mask |= __GFP_HIGHMEM;
++>>>>>>> 34fe653716b0 (mm/vmalloc.c:__vmalloc_area_node(): avoid 32-bit overflow)
  
 +	area->nr_pages = nr_pages;
  	/* Please note that the recursion is strictly bounded. */
  	if (array_size > PAGE_SIZE) {
 -		pages = __vmalloc_node(array_size, 1, nested_gfp, node,
 -					area->caller);
 +		pages = __vmalloc_node(array_size, 1, nested_gfp|highmem_mask,
 +				PAGE_KERNEL, node, area->caller);
  	} else {
  		pages = kmalloc_node(array_size, nested_gfp, node);
  	}
* Unmerged path mm/vmalloc.c
