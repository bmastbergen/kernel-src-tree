mm/hmm: remove HMM_PFN_SPECIAL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 5c8f3c4cf18ad007242bc370da54d45d4d4293dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5c8f3c4c.failed

This is just an alias for HMM_PFN_ERROR, nothing cares that the error was
because of a special page vs any other error case.

Link: https://lore.kernel.org/r/4-v2-b4e84f444c7d+24f57-hmm_no_flags_jgg@mellanox.com
	Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: John Hubbard <jhubbard@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 5c8f3c4cf18ad007242bc370da54d45d4d4293dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
#	drivers/gpu/drm/nouveau/nouveau_svm.c
#	include/linux/hmm.h
diff --cc drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
index b7fd0cdffce0,76b4a4fa39ed..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
@@@ -885,6 -766,17 +885,20 @@@ struct amdgpu_ttm_tt 
  };
  
  #ifdef CONFIG_DRM_AMDGPU_USERPTR
++<<<<<<< HEAD
++=======
+ /* flags used by HMM internal, not related to CPU/GPU PTE flags */
+ static const uint64_t hmm_range_flags[HMM_PFN_FLAG_MAX] = {
+ 	(1 << 0), /* HMM_PFN_VALID */
+ 	(1 << 1), /* HMM_PFN_WRITE */
+ };
+ 
+ static const uint64_t hmm_range_values[HMM_PFN_VALUE_MAX] = {
+ 	0xfffffffffffffffeUL, /* HMM_PFN_ERROR */
+ 	0, /* HMM_PFN_NONE */
+ };
+ 
++>>>>>>> 5c8f3c4cf18a (mm/hmm: remove HMM_PFN_SPECIAL)
  /**
   * amdgpu_ttm_tt_get_user_pages - get device accessible pages that back user
   * memory and start HMM tracking CPU page table update
diff --cc drivers/gpu/drm/nouveau/nouveau_svm.c
index 4f69e4c3dafd,cf0d9bd61beb..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_svm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_svm.c
@@@ -366,6 -369,18 +366,21 @@@ out_free
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static const u64
+ nouveau_svm_pfn_flags[HMM_PFN_FLAG_MAX] = {
+ 	[HMM_PFN_VALID         ] = NVIF_VMM_PFNMAP_V0_V,
+ 	[HMM_PFN_WRITE         ] = NVIF_VMM_PFNMAP_V0_W,
+ };
+ 
+ static const u64
+ nouveau_svm_pfn_values[HMM_PFN_VALUE_MAX] = {
+ 	[HMM_PFN_ERROR  ] = ~NVIF_VMM_PFNMAP_V0_V,
+ 	[HMM_PFN_NONE   ] =  NVIF_VMM_PFNMAP_V0_NONE,
+ };
+ 
++>>>>>>> 5c8f3c4cf18a (mm/hmm: remove HMM_PFN_SPECIAL)
  /* Issue fault replay for GPU to retry accesses that faulted previously. */
  static void
  nouveau_svm_fault_replay(struct nouveau_svm *svm)
diff --cc include/linux/hmm.h
index 6a8157d67186,81c302c884c0..000000000000
--- a/include/linux/hmm.h
+++ b/include/linux/hmm.h
@@@ -142,10 -44,6 +142,13 @@@ enum hmm_pfn_flag_e 
   * Flags:
   * HMM_PFN_ERROR: corresponding CPU page table entry points to poisoned memory
   * HMM_PFN_NONE: corresponding CPU page table entry is pte_none()
++<<<<<<< HEAD
 + * HMM_PFN_SPECIAL: corresponding CPU page table entry is special; i.e., the
 + *      result of vm_insert_pfn() or vm_insert_page(). Therefore, it should not
 + *      be mirrored by a device, because the entry will never have HMM_PFN_VALID
 + *      set and the pfn value is undefined.
++=======
++>>>>>>> 5c8f3c4cf18a (mm/hmm: remove HMM_PFN_SPECIAL)
   *
   * Driver provides values for none entry, error entry, and special entry.
   * Driver can alias (i.e., use same value) error and special, but
* Unmerged path drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
* Unmerged path drivers/gpu/drm/nouveau/nouveau_svm.c
* Unmerged path include/linux/hmm.h
diff --git a/mm/hmm.c b/mm/hmm.c
index 3233a7437881..0010b4fa3111 100644
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@ -592,7 +592,7 @@ static int hmm_vma_handle_pte(struct mm_walk *walk, unsigned long addr,
 			pte_unmap(ptep);
 			return -EFAULT;
 		}
-		*pfn = range->values[HMM_PFN_SPECIAL];
+		*pfn = range->values[HMM_PFN_ERROR];
 		return 0;
 	}
 
