net/mlx5: E-Switch, Return eswitch max ports when eswitch is supported

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Parav Pandit <parav@nvidia.com>
commit 06ec5acc7747f225154fcafaf2afe52324694baa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/06ec5acc.failed

mlx5_eswitch_get_total_vports() doesn't honor MLX5_ESWICH Kconfig flag.

When MLX5_ESWITCH is disabled, FS layer continues to initialize eswitch
specific ACL namespaces.
Instead, start honoring MLX5_ESWITCH flag and perform vport specific
initialization only when vport count is non zero.

	Signed-off-by: Parav Pandit <parav@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Vu Pham <vuhuong@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 06ec5acc7747f225154fcafaf2afe52324694baa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/vport.c
#	include/linux/mlx5/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 6f56131481bc,c3a58224ae12..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -2520,4 -2105,116 +2520,115 @@@ bool mlx5_esw_multipath_prereq(struct m
  		dev1->priv.eswitch->mode == MLX5_ESWITCH_OFFLOADS);
  }
  
 -int mlx5_esw_event_notifier_register(struct mlx5_eswitch *esw, struct notifier_block *nb)
 -{
 -	return blocking_notifier_chain_register(&esw->n_head, nb);
 -}
  
++<<<<<<< HEAD
++=======
+ void mlx5_esw_event_notifier_unregister(struct mlx5_eswitch *esw, struct notifier_block *nb)
+ {
+ 	blocking_notifier_chain_unregister(&esw->n_head, nb);
+ }
+ 
+ /**
+  * mlx5_esw_hold() - Try to take a read lock on esw mode lock.
+  * @mdev: mlx5 core device.
+  *
+  * Should be called by esw resources callers.
+  *
+  * Return: true on success or false.
+  */
+ bool mlx5_esw_hold(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	/* e.g. VF doesn't have eswitch so nothing to do */
+ 	if (!mlx5_esw_allowed(esw))
+ 		return true;
+ 
+ 	if (down_read_trylock(&esw->mode_lock) != 0)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /**
+  * mlx5_esw_release() - Release a read lock on esw mode lock.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_release(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (mlx5_esw_allowed(esw))
+ 		up_read(&esw->mode_lock);
+ }
+ 
+ /**
+  * mlx5_esw_get() - Increase esw user count.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_get(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (mlx5_esw_allowed(esw))
+ 		atomic64_inc(&esw->user_count);
+ }
+ 
+ /**
+  * mlx5_esw_put() - Decrease esw user count.
+  * @mdev: mlx5 core device.
+  */
+ void mlx5_esw_put(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	if (mlx5_esw_allowed(esw))
+ 		atomic64_dec_if_positive(&esw->user_count);
+ }
+ 
+ /**
+  * mlx5_esw_try_lock() - Take a write lock on esw mode lock.
+  * @esw: eswitch device.
+  *
+  * Should be called by esw mode change routine.
+  *
+  * Return:
+  * * 0       - esw mode if successfully locked and refcount is 0.
+  * * -EBUSY  - refcount is not 0.
+  * * -EINVAL - In the middle of switching mode or lock is already held.
+  */
+ int mlx5_esw_try_lock(struct mlx5_eswitch *esw)
+ {
+ 	if (down_write_trylock(&esw->mode_lock) == 0)
+ 		return -EINVAL;
+ 
+ 	if (atomic64_read(&esw->user_count) > 0) {
+ 		up_write(&esw->mode_lock);
+ 		return -EBUSY;
+ 	}
+ 
+ 	return esw->mode;
+ }
+ 
+ /**
+  * mlx5_esw_unlock() - Release write lock on esw mode lock
+  * @esw: eswitch device.
+  */
+ void mlx5_esw_unlock(struct mlx5_eswitch *esw)
+ {
+ 	up_write(&esw->mode_lock);
+ }
+ 
+ /**
+  * mlx5_eswitch_get_total_vports - Get total vports of the eswitch
+  *
+  * @dev: Pointer to core device
+  *
+  * mlx5_eswitch_get_total_vports returns total number of eswitch vports.
+  */
+ u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev)
+ {
+ 	return MLX5_SPECIAL_VPORTS(dev) + mlx5_core_max_vfs(dev) + mlx5_sf_max_functions(dev);
+ }
+ EXPORT_SYMBOL_GPL(mlx5_eswitch_get_total_vports);
++>>>>>>> 06ec5acc7747 (net/mlx5: E-Switch, Return eswitch max ports when eswitch is supported)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vport.c
index ba78e0660523,457ad42eaa2a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
@@@ -1151,16 -1151,14 +1151,30 @@@ u64 mlx5_query_nic_system_image_guid(st
  }
  EXPORT_SYMBOL_GPL(mlx5_query_nic_system_image_guid);
  
++<<<<<<< HEAD
 +/**
 + * mlx5_eswitch_get_total_vports - Get total vports of the eswitch
 + *
 + * @dev:	Pointer to core device
 + *
 + * mlx5_eswitch_get_total_vports returns total number of vports for
 + * the eswitch.
 + */
 +u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev)
 +{
 +	return MLX5_SPECIAL_VPORTS(dev) + mlx5_core_max_vfs(dev) + mlx5_sf_max_functions(dev);
 +}
 +EXPORT_SYMBOL_GPL(mlx5_eswitch_get_total_vports);
++=======
+ int mlx5_vport_get_other_func_cap(struct mlx5_core_dev *dev, u16 function_id, void *out)
+ {
+ 	u16 opmod = (MLX5_CAP_GENERAL << 1) | (HCA_CAP_OPMOD_GET_MAX & 0x01);
+ 	u8 in[MLX5_ST_SZ_BYTES(query_hca_cap_in)] = {};
+ 
+ 	MLX5_SET(query_hca_cap_in, in, opcode, MLX5_CMD_OP_QUERY_HCA_CAP);
+ 	MLX5_SET(query_hca_cap_in, in, op_mod, opmod);
+ 	MLX5_SET(query_hca_cap_in, in, function_id, function_id);
+ 	MLX5_SET(query_hca_cap_in, in, other_function, true);
+ 	return mlx5_cmd_exec_inout(dev, query_hca_cap, in, out);
+ }
++>>>>>>> 06ec5acc7747 (net/mlx5: E-Switch, Return eswitch max ports when eswitch is supported)
diff --cc include/linux/mlx5/eswitch.h
index b0ae8020f13e,17109b65c1ac..000000000000
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@@ -61,11 -62,9 +61,9 @@@ struct mlx5_eswitch_rep *mlx5_eswitch_v
  						u16 vport_num);
  void *mlx5_eswitch_uplink_get_proto_dev(struct mlx5_eswitch *esw, u8 rep_type);
  struct mlx5_flow_handle *
 -mlx5_eswitch_add_send_to_vport_rule(struct mlx5_eswitch *on_esw,
 -				    struct mlx5_eswitch_rep *rep, u32 sqn);
 +mlx5_eswitch_add_send_to_vport_rule(struct mlx5_eswitch *esw,
 +				    u16 vport_num, u32 sqn);
  
- u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev);
- 
  #ifdef CONFIG_MLX5_ESWITCH
  enum devlink_eswitch_encap_mode
  mlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev);
@@@ -96,10 -94,41 +94,45 @@@ static inline u32 mlx5_eswitch_get_vpor
  
  u32 mlx5_eswitch_get_vport_metadata_for_match(struct mlx5_eswitch *esw,
  					      u16 vport_num);
++<<<<<<< HEAD
 +u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw);
++=======
+ u32 mlx5_eswitch_get_vport_metadata_for_set(struct mlx5_eswitch *esw,
+ 					    u16 vport_num);
+ 
+ /* Reg C1 usage:
+  * Reg C1 = < ESW_TUN_ID(12) | ESW_TUN_OPTS(12) | ESW_ZONE_ID(8) >
+  *
+  * Highest 12 bits of reg c1 is the encapsulation tunnel id, next 12 bits is
+  * encapsulation tunnel options, and the lowest 8 bits are used for zone id.
+  *
+  * Zone id is used to restore CT flow when packet misses on chain.
+  *
+  * Tunnel id and options are used together to restore the tunnel info metadata
+  * on miss and to support inner header rewrite by means of implicit chain 0
+  * flows.
+  */
+ #define ESW_ZONE_ID_BITS 8
+ #define ESW_TUN_OPTS_BITS 12
+ #define ESW_TUN_ID_BITS 12
+ #define ESW_TUN_OPTS_OFFSET ESW_ZONE_ID_BITS
+ #define ESW_TUN_OFFSET ESW_TUN_OPTS_OFFSET
+ #define ESW_ZONE_ID_MASK GENMASK(ESW_ZONE_ID_BITS - 1, 0)
+ #define ESW_TUN_OPTS_MASK GENMASK(32 - ESW_TUN_ID_BITS - 1, ESW_TUN_OPTS_OFFSET)
+ #define ESW_TUN_MASK GENMASK(31, ESW_TUN_OFFSET)
+ #define ESW_TUN_ID_SLOW_TABLE_GOTO_VPORT 0 /* 0 is not a valid tunnel id */
+ #define ESW_TUN_OPTS_SLOW_TABLE_GOTO_VPORT 0xFFF /* 0xFFF is a reserved mapping */
+ #define ESW_TUN_SLOW_TABLE_GOTO_VPORT ((ESW_TUN_ID_SLOW_TABLE_GOTO_VPORT << ESW_TUN_OPTS_BITS) | \
+ 				       ESW_TUN_OPTS_SLOW_TABLE_GOTO_VPORT)
+ #define ESW_TUN_SLOW_TABLE_GOTO_VPORT_MARK ESW_TUN_OPTS_MASK
+ 
+ u8 mlx5_eswitch_mode(struct mlx5_core_dev *dev);
+ u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev);
+ 
++>>>>>>> 06ec5acc7747 (net/mlx5: E-Switch, Return eswitch max ports when eswitch is supported)
  #else  /* CONFIG_MLX5_ESWITCH */
  
 -static inline u8 mlx5_eswitch_mode(struct mlx5_core_dev *dev)
 +static inline u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw)
  {
  	return MLX5_ESWITCH_NONE;
  }
@@@ -134,6 -162,17 +167,20 @@@ mlx5_eswitch_get_vport_metadata_mask(vo
  {
  	return 0;
  }
+ 
+ static inline u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev)
+ {
+ 	return 0;
+ }
+ 
  #endif /* CONFIG_MLX5_ESWITCH */
  
++<<<<<<< HEAD
++=======
+ static inline bool is_mdev_switchdev_mode(struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_eswitch_mode(dev) == MLX5_ESWITCH_OFFLOADS;
+ }
+ 
++>>>>>>> 06ec5acc7747 (net/mlx5: E-Switch, Return eswitch max ports when eswitch is supported)
  #endif
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vport.c
* Unmerged path include/linux/mlx5/eswitch.h
