drm/dp_mst: Avoid to mess up payload table by ports in stale topology

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Wayne Lin <Wayne.Lin@amd.com>
commit 3769e4c0af5b82c8ea21d037013cb9564dfaa51f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/3769e4c0.failed

[Why]
After unplug/hotplug hub from the system, userspace might start to
clear stale payloads gradually. If we call drm_dp_mst_deallocate_vcpi()
to release stale VCPI of those ports which are not relating to current
topology, we have chane to wrongly clear active payload table entry for
current topology.

E.g.
We have allocated VCPI 1 in current payload table and we call
drm_dp_mst_deallocate_vcpi() to clean VCPI 1 in stale topology. In
drm_dp_mst_deallocate_vcpi(), it will call drm_dp_mst_put_payload_id()
tp put VCPI 1 and which means ID 1 is available again. Thereafter, if we
want to allocate a new payload stream, it will find ID 1 is available by
drm_dp_mst_assign_payload_id(). However, ID 1 is being used

[How]
Check target sink is relating to current topology or not before doing
any payload table update.
Searching upward to find the target sink's relevant root branch device.
If the found root branch device is not the same root of current
topology, don't update payload table.

Changes since v1:
* Change debug macro to use drm_dbg_kms() instead
* Amend the commit message to add Cc tag.

	Signed-off-by: Wayne Lin <Wayne.Lin@amd.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Lyude Paul <lyude@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210616035501.3776-3-Wayne.Lin@amd.com
	Reviewed-by: Lyude Paul <lyude@redhat.com>
(cherry picked from commit 3769e4c0af5b82c8ea21d037013cb9564dfaa51f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_dp_mst_topology.c
diff --cc drivers/gpu/drm/drm_dp_mst_topology.c
index e78db08a0bd0,9ac148efd9e4..000000000000
--- a/drivers/gpu/drm/drm_dp_mst_topology.c
+++ b/drivers/gpu/drm/drm_dp_mst_topology.c
@@@ -3324,7 -3501,14 +3337,18 @@@ int drm_dp_update_payload_part2(struct 
  
  		port = container_of(mgr->proposed_vcpis[i], struct drm_dp_mst_port, vcpi);
  
++<<<<<<< HEAD
 +		DRM_DEBUG_KMS("payload %d %d\n", i, mgr->payloads[i].payload_state);
++=======
+ 		mutex_lock(&mgr->lock);
+ 		skip = !drm_dp_mst_port_downstream_of_branch(port, mgr->mst_primary);
+ 		mutex_unlock(&mgr->lock);
+ 
+ 		if (skip)
+ 			continue;
+ 
+ 		drm_dbg_kms(mgr->dev, "payload %d %d\n", i, mgr->payloads[i].payload_state);
++>>>>>>> 3769e4c0af5b (drm/dp_mst: Avoid to mess up payload table by ports in stale topology)
  		if (mgr->payloads[i].payload_state == DP_PAYLOAD_LOCAL) {
  			ret = drm_dp_create_payload_step2(mgr, port, mgr->proposed_vcpis[i]->vcpi, &mgr->payloads[i]);
  		} else if (mgr->payloads[i].payload_state == DP_PAYLOAD_DELETE_LOCAL) {
* Unmerged path drivers/gpu/drm/drm_dp_mst_topology.c
