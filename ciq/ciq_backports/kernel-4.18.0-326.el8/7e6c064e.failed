drm/i915/tgl: Use TGL stepping info for applying WAs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Aditya Swarup <aditya.swarup@intel.com>
commit 7e6c064ed834c86bb517841b72bed146d1a2d36d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/7e6c064e.failed

TGL adds another level of indirection for applying WA based on stepping
information rather than PCI REVID. So change TGL_REVID enum into
stepping enum and use PCI REVID as index into revid to stepping table to
fetch correct display and GT stepping for application of WAs as
suggested by Matt Roper.

	Cc: Matt Roper <matthew.d.roper@intel.com>
	Cc: Lucas De Marchi <lucas.demarchi@intel.com>
	Cc: Jos√© Roberto de Souza <jose.souza@intel.com>
	Signed-off-by: Aditya Swarup <aditya.swarup@intel.com>
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
	Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210119192931.1116500-1-lucas.demarchi@intel.com
(cherry picked from commit 7e6c064ed834c86bb517841b72bed146d1a2d36d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display_power.c
#	drivers/gpu/drm/i915/display/intel_psr.c
#	drivers/gpu/drm/i915/display/intel_sprite.c
#	drivers/gpu/drm/i915/gt/intel_workarounds.c
#	drivers/gpu/drm/i915/i915_drv.h
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/display/intel_display_power.c
index 612e28814ad9,bb04b502a442..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@@ -5264,8 -5339,9 +5264,14 @@@ static void tgl_bw_buddy_init(struct dr
  	unsigned long abox_mask = INTEL_INFO(dev_priv)->abox_mask;
  	int config, i;
  
++<<<<<<< HEAD
 +	if (IS_TGL_REVID(dev_priv, TGL_REVID_A0, TGL_REVID_B0))
 +		/* Wa_1409767108: tgl */
++=======
+ 	if (IS_DG1_REVID(dev_priv, DG1_REVID_A0, DG1_REVID_A0) ||
+ 	    IS_TGL_DISP_STEPPING(dev_priv, STEP_A0, STEP_B0))
+ 		/* Wa_1409767108:tgl,dg1 */
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  		table = wa_1409767108_buddy_page_masks;
  	else
  		table = tgl_buddy_page_masks;
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 66e0a6406c3b,a93717178957..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -553,6 -548,22 +553,25 @@@ static void hsw_activate_psr2(struct in
  		val |= EDP_PSR2_FAST_WAKE(7);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (dev_priv->psr.psr2_sel_fetch_enabled) {
+ 		/* WA 1408330847 */
+ 		if (IS_TGL_DISP_STEPPING(dev_priv, STEP_A0, STEP_A0) ||
+ 		    IS_RKL_REVID(dev_priv, RKL_REVID_A0, RKL_REVID_A0))
+ 			intel_de_rmw(dev_priv, CHICKEN_PAR1_1,
+ 				     DIS_RAM_BYPASS_PSR2_MAN_TRACK,
+ 				     DIS_RAM_BYPASS_PSR2_MAN_TRACK);
+ 
+ 		intel_de_write(dev_priv,
+ 			       PSR2_MAN_TRK_CTL(dev_priv->psr.transcoder),
+ 			       PSR2_MAN_TRK_CTL_ENABLE);
+ 	} else if (HAS_PSR2_SEL_FETCH(dev_priv)) {
+ 		intel_de_write(dev_priv,
+ 			       PSR2_MAN_TRK_CTL(dev_priv->psr.transcoder), 0);
+ 	}
+ 
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  	/*
  	 * PSR2 HW is incorrectly using EDP_PSR_TP1_TP3_SEL and BSpec is
  	 * recommending keep this bit unset while PSR2 is enabled.
@@@ -1058,6 -1100,13 +1077,16 @@@ static void intel_psr_disable_locked(st
  				    psr_status_mask, 2000))
  		drm_err(&dev_priv->drm, "Timed out waiting PSR idle state\n");
  
++<<<<<<< HEAD
++=======
+ 	/* WA 1408330847 */
+ 	if (dev_priv->psr.psr2_sel_fetch_enabled &&
+ 	    (IS_TGL_DISP_STEPPING(dev_priv, STEP_A0, STEP_A0) ||
+ 	     IS_RKL_REVID(dev_priv, RKL_REVID_A0, RKL_REVID_A0)))
+ 		intel_de_rmw(dev_priv, CHICKEN_PAR1_1,
+ 			     DIS_RAM_BYPASS_PSR2_MAN_TRACK, 0);
+ 
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  	/* Disable PSR on Sink */
  	drm_dp_dpcd_writeb(&intel_dp->aux, DP_PSR_EN_CFG, 0);
  
diff --cc drivers/gpu/drm/i915/display/intel_sprite.c
index 6b72223981be,4ce32df3855f..000000000000
--- a/drivers/gpu/drm/i915/display/intel_sprite.c
+++ b/drivers/gpu/drm/i915/display/intel_sprite.c
@@@ -2843,9 -3031,9 +2843,15 @@@ static bool skl_plane_format_mod_suppor
  static bool gen12_plane_supports_mc_ccs(struct drm_i915_private *dev_priv,
  					enum plane_id plane_id)
  {
++<<<<<<< HEAD
 +	/* Wa_14010477008:tgl[a0..c0],rkl[all] */
 +	if (IS_ROCKETLAKE(dev_priv) ||
 +	    IS_TGL_REVID(dev_priv, TGL_REVID_A0, TGL_REVID_C0))
++=======
+ 	/* Wa_14010477008:tgl[a0..c0],rkl[all],dg1[all] */
+ 	if (IS_DG1(dev_priv) || IS_ROCKETLAKE(dev_priv) ||
+ 	    IS_TGL_DISP_STEPPING(dev_priv, STEP_A0, STEP_C0))
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  		return false;
  
  	return plane_id < PLANE_SPRITE4;
diff --cc drivers/gpu/drm/i915/gt/intel_workarounds.c
index 9cc4a89424f5,077c18fe1ae7..000000000000
--- a/drivers/gpu/drm/i915/gt/intel_workarounds.c
+++ b/drivers/gpu/drm/i915/gt/intel_workarounds.c
@@@ -52,6 -53,37 +52,40 @@@
   * - Public functions to init or apply the given workaround type.
   */
  
++<<<<<<< HEAD
++=======
+ /*
+  * KBL revision ID ordering is bizarre; higher revision ID's map to lower
+  * steppings in some cases.  So rather than test against the revision ID
+  * directly, let's map that into our own range of increasing ID's that we
+  * can test against in a regular manner.
+  */
+ 
+ const struct i915_rev_steppings kbl_revids[] = {
+ 	[0] = { .gt_stepping = KBL_REVID_A0, .disp_stepping = KBL_REVID_A0 },
+ 	[1] = { .gt_stepping = KBL_REVID_B0, .disp_stepping = KBL_REVID_B0 },
+ 	[2] = { .gt_stepping = KBL_REVID_C0, .disp_stepping = KBL_REVID_B0 },
+ 	[3] = { .gt_stepping = KBL_REVID_D0, .disp_stepping = KBL_REVID_B0 },
+ 	[4] = { .gt_stepping = KBL_REVID_F0, .disp_stepping = KBL_REVID_C0 },
+ 	[5] = { .gt_stepping = KBL_REVID_C0, .disp_stepping = KBL_REVID_B1 },
+ 	[6] = { .gt_stepping = KBL_REVID_D1, .disp_stepping = KBL_REVID_B1 },
+ 	[7] = { .gt_stepping = KBL_REVID_G0, .disp_stepping = KBL_REVID_C0 },
+ };
+ 
+ const struct i915_rev_steppings tgl_uy_revid_step_tbl[] = {
+ 	[0] = { .gt_stepping = STEP_A0, .disp_stepping = STEP_A0 },
+ 	[1] = { .gt_stepping = STEP_B0, .disp_stepping = STEP_C0 },
+ 	[2] = { .gt_stepping = STEP_B1, .disp_stepping = STEP_C0 },
+ 	[3] = { .gt_stepping = STEP_C0, .disp_stepping = STEP_D0 },
+ };
+ 
+ /* Same GT stepping between tgl_uy_revids and tgl_revids don't mean the same HW */
+ const struct i915_rev_steppings tgl_revid_step_tbl[] = {
+ 	[0] = { .gt_stepping = STEP_A0, .disp_stepping = STEP_B0 },
+ 	[1] = { .gt_stepping = STEP_B0, .disp_stepping = STEP_D0 },
+ };
+ 
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  static void wa_init_start(struct i915_wa_list *wal, const char *name, const char *engine_name)
  {
  	wal->name = name;
@@@ -1201,16 -1123,45 +1235,56 @@@ tgl_gt_workarounds_init(struct drm_i915
  	gen12_gt_workarounds_init(i915, wal);
  
  	/* Wa_1409420604:tgl */
++<<<<<<< HEAD
 +	if (IS_TGL_REVID(i915, TGL_REVID_A0, TGL_REVID_A0))
++=======
+ 	if (IS_TGL_UY_GT_STEPPING(i915, STEP_A0, STEP_A0))
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  		wa_write_or(wal,
  			    SUBSLICE_UNIT_LEVEL_CLKGATE2,
  			    CPSSUNIT_CLKGATE_DIS);
  
  	/* Wa_1607087056:tgl also know as BUG:1409180338 */
++<<<<<<< HEAD
 +	if (IS_TGL_REVID(i915, TGL_REVID_A0, TGL_REVID_A0))
 +		wa_write_or(wal,
 +			    SLICE_UNIT_LEVEL_CLKGATE,
 +			    L3_CLKGATE_DIS | L3_CR2X_CLKGATE_DIS);
++=======
+ 	if (IS_TGL_UY_GT_STEPPING(i915, STEP_A0, STEP_A0))
+ 		wa_write_or(wal,
+ 			    SLICE_UNIT_LEVEL_CLKGATE,
+ 			    L3_CLKGATE_DIS | L3_CR2X_CLKGATE_DIS);
+ 
+ 	/* Wa_1408615072:tgl[a0] */
+ 	if (IS_TGL_UY_GT_STEPPING(i915, STEP_A0, STEP_A0))
+ 		wa_write_or(wal, UNSLICE_UNIT_LEVEL_CLKGATE2,
+ 			    VSUNIT_CLKGATE_DIS_TGL);
+ }
+ 
+ static void
+ dg1_gt_workarounds_init(struct drm_i915_private *i915, struct i915_wa_list *wal)
+ {
+ 	gen12_gt_workarounds_init(i915, wal);
+ 
+ 	/* Wa_1607087056:dg1 */
+ 	if (IS_DG1_REVID(i915, DG1_REVID_A0, DG1_REVID_A0))
+ 		wa_write_or(wal,
+ 			    SLICE_UNIT_LEVEL_CLKGATE,
+ 			    L3_CLKGATE_DIS | L3_CR2X_CLKGATE_DIS);
+ 
+ 	/* Wa_1409420604:dg1 */
+ 	if (IS_DG1(i915))
+ 		wa_write_or(wal,
+ 			    SUBSLICE_UNIT_LEVEL_CLKGATE2,
+ 			    CPSSUNIT_CLKGATE_DIS);
+ 
+ 	/* Wa_1408615072:dg1 */
+ 	/* Empirical testing shows this register is unaffected by engine reset. */
+ 	if (IS_DG1(i915))
+ 		wa_write_or(wal, UNSLICE_UNIT_LEVEL_CLKGATE2,
+ 			    VSUNIT_CLKGATE_DIS_TGL);
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  }
  
  static void
@@@ -1642,15 -1612,18 +1716,24 @@@ rcs_engine_wa_init(struct intel_engine_
  {
  	struct drm_i915_private *i915 = engine->i915;
  
++<<<<<<< HEAD
 +	if (IS_TGL_REVID(i915, TGL_REVID_A0, TGL_REVID_A0)) {
++=======
+ 	if (IS_DG1_REVID(i915, DG1_REVID_A0, DG1_REVID_A0) ||
+ 	    IS_TGL_UY_GT_STEPPING(i915, STEP_A0, STEP_A0)) {
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  		/*
 -		 * Wa_1607138336:tgl[a0],dg1[a0]
 -		 * Wa_1607063988:tgl[a0],dg1[a0]
 +		 * Wa_1607138336:tgl
 +		 * Wa_1607063988:tgl
  		 */
  		wa_write_or(wal,
  			    GEN9_CTX_PREEMPT_REG,
  			    GEN12_DISABLE_POSH_BUSY_FF_DOP_CG);
 -	}
  
++<<<<<<< HEAD
++=======
+ 	if (IS_TGL_UY_GT_STEPPING(i915, STEP_A0, STEP_A0)) {
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  		/*
  		 * Wa_1606679103:tgl
  		 * (see also Wa_1606682166:icl)
diff --cc drivers/gpu/drm/i915/i915_drv.h
index b81b4c05e6c3,c7d5a9bed441..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@@ -1554,16 -1553,60 +1554,68 @@@ IS_SUBPLATFORM(const struct drm_i915_pr
  	(IS_ICELAKE(p) && IS_REVID(p, since, until))
  
  #define EHL_REVID_A0            0x0
 -#define EHL_REVID_B0            0x1
  
 -#define IS_JSL_EHL_REVID(p, since, until) \
 -	(IS_JSL_EHL(p) && IS_REVID(p, since, until))
 +#define IS_EHL_REVID(p, since, until) \
 +	(IS_ELKHARTLAKE(p) && IS_REVID(p, since, until))
 +
++<<<<<<< HEAD
 +#define TGL_REVID_A0		0x0
 +#define TGL_REVID_B0		0x1
 +#define TGL_REVID_C0		0x2
  
 +#define IS_TGL_REVID(p, since, until) \
 +	(IS_TIGERLAKE(p) && IS_REVID(p, since, until))
++=======
+ enum {
+ 	STEP_A0,
+ 	STEP_B0,
+ 	STEP_B1,
+ 	STEP_C0,
+ 	STEP_D0,
+ };
+ 
+ #define TGL_UY_REVID_STEP_TBL_SIZE	4
+ #define TGL_REVID_STEP_TBL_SIZE		2
+ 
+ extern const struct i915_rev_steppings tgl_uy_revid_step_tbl[TGL_UY_REVID_STEP_TBL_SIZE];
+ extern const struct i915_rev_steppings tgl_revid_step_tbl[TGL_REVID_STEP_TBL_SIZE];
+ 
+ static inline const struct i915_rev_steppings *
+ tgl_stepping_get(struct drm_i915_private *dev_priv)
+ {
+ 	u8 revid = INTEL_REVID(dev_priv);
+ 	u8 size;
+ 	const struct i915_rev_steppings *revid_step_tbl;
+ 
+ 	if (IS_TGL_U(dev_priv) || IS_TGL_Y(dev_priv)) {
+ 		revid_step_tbl = tgl_uy_revid_step_tbl;
+ 		size = ARRAY_SIZE(tgl_uy_revid_step_tbl);
+ 	} else {
+ 		revid_step_tbl = tgl_revid_step_tbl;
+ 		size = ARRAY_SIZE(tgl_revid_step_tbl);
+ 	}
+ 
+ 	revid = min_t(u8, revid, size - 1);
+ 
+ 	return &revid_step_tbl[revid];
+ }
+ 
+ #define IS_TGL_DISP_STEPPING(p, since, until) \
+ 	(IS_TIGERLAKE(p) && \
+ 	 tgl_stepping_get(p)->disp_stepping >= (since) && \
+ 	 tgl_stepping_get(p)->disp_stepping <= (until))
+ 
+ #define IS_TGL_UY_GT_STEPPING(p, since, until) \
+ 	((IS_TGL_U(p) || IS_TGL_Y(p)) && \
+ 	 tgl_stepping_get(p)->gt_stepping >= (since) && \
+ 	 tgl_stepping_get(p)->gt_stepping <= (until))
+ 
+ #define IS_TGL_GT_STEPPING(p, since, until) \
+ 	(IS_TIGERLAKE(p) && \
+ 	 !(IS_TGL_U(p) || IS_TGL_Y(p)) && \
+ 	 tgl_stepping_get(p)->gt_stepping >= (since) && \
+ 	 tgl_stepping_get(p)->gt_stepping <= (until))
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  
  #define RKL_REVID_A0		0x0
  #define RKL_REVID_B0		0x1
diff --cc drivers/gpu/drm/i915/intel_pm.c
index e1253a1e2a4f,319acca2630b..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -7129,8 -7110,8 +7129,13 @@@ static void tgl_init_clock_gating(struc
  		   ILK_DPFC_CHICKEN_COMP_DUMMY_PIXEL);
  
  	/* Wa_1409825376:tgl (pre-prod)*/
++<<<<<<< HEAD
 +	if (IS_TGL_REVID(dev_priv, TGL_REVID_A0, TGL_REVID_A0))
 +		I915_WRITE(GEN9_CLKGATE_DIS_3, I915_READ(GEN9_CLKGATE_DIS_3) |
++=======
+ 	if (IS_TGL_DISP_STEPPING(dev_priv, STEP_A0, STEP_B1))
+ 		intel_uncore_write(&dev_priv->uncore, GEN9_CLKGATE_DIS_3, intel_uncore_read(&dev_priv->uncore, GEN9_CLKGATE_DIS_3) |
++>>>>>>> 7e6c064ed834 (drm/i915/tgl: Use TGL stepping info for applying WAs)
  			   TGL_VRH_GATING_DIS);
  
  	/* Wa_14011059788:tgl */
* Unmerged path drivers/gpu/drm/i915/display/intel_display_power.c
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
* Unmerged path drivers/gpu/drm/i915/display/intel_sprite.c
* Unmerged path drivers/gpu/drm/i915/gt/intel_workarounds.c
* Unmerged path drivers/gpu/drm/i915/i915_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
