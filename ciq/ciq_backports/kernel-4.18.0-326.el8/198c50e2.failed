dma-mapping: refactor dma_{alloc,free}_pages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 198c50e2ccff5c78ddbe0cb01593ac32458deb69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/198c50e2.failed

Factour out internal versions without the dma_debug calls in preparation
for callers that will need different dma_debug calls.

Note that this changes the dma_debug calls to get the not page aligned
size values, but as long as alloc and free agree on one variant we are
fine.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Tomasz Figa <tfiga@chromium.org>
	Tested-by: Ricardo Ribalda <ribalda@chromium.org>
(cherry picked from commit 198c50e2ccff5c78ddbe0cb01593ac32458deb69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/mapping.c
diff --cc kernel/dma/mapping.c
index 0597cdaee492,07f964ebcda1..000000000000
--- a/kernel/dma/mapping.c
+++ b/kernel/dma/mapping.c
@@@ -528,6 -477,68 +528,71 @@@ void dma_free_attrs(struct device *dev
  }
  EXPORT_SYMBOL(dma_free_attrs);
  
++<<<<<<< HEAD
++=======
+ static struct page *__dma_alloc_pages(struct device *dev, size_t size,
+ 		dma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	if (WARN_ON_ONCE(!dev->coherent_dma_mask))
+ 		return NULL;
+ 	if (WARN_ON_ONCE(gfp & (__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM)))
+ 		return NULL;
+ 
+ 	size = PAGE_ALIGN(size);
+ 	if (dma_alloc_direct(dev, ops))
+ 		return dma_direct_alloc_pages(dev, size, dma_handle, dir, gfp);
+ 	if (!ops->alloc_pages)
+ 		return NULL;
+ 	return ops->alloc_pages(dev, size, dma_handle, dir, gfp);
+ }
+ 
+ struct page *dma_alloc_pages(struct device *dev, size_t size,
+ 		dma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)
+ {
+ 	struct page *page = __dma_alloc_pages(dev, size, dma_handle, dir, gfp);
+ 
+ 	if (page)
+ 		debug_dma_map_page(dev, page, 0, size, dir, *dma_handle);
+ 	return page;
+ }
+ EXPORT_SYMBOL_GPL(dma_alloc_pages);
+ 
+ static void __dma_free_pages(struct device *dev, size_t size, struct page *page,
+ 		dma_addr_t dma_handle, enum dma_data_direction dir)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	size = PAGE_ALIGN(size);
+ 	if (dma_alloc_direct(dev, ops))
+ 		dma_direct_free_pages(dev, size, page, dma_handle, dir);
+ 	else if (ops->free_pages)
+ 		ops->free_pages(dev, size, page, dma_handle, dir);
+ }
+ 
+ void dma_free_pages(struct device *dev, size_t size, struct page *page,
+ 		dma_addr_t dma_handle, enum dma_data_direction dir)
+ {
+ 	debug_dma_unmap_page(dev, dma_handle, size, dir);
+ 	__dma_free_pages(dev, size, page, dma_handle, dir);
+ }
+ EXPORT_SYMBOL_GPL(dma_free_pages);
+ 
+ int dma_mmap_pages(struct device *dev, struct vm_area_struct *vma,
+ 		size_t size, struct page *page)
+ {
+ 	unsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+ 
+ 	if (vma->vm_pgoff >= count || vma_pages(vma) > count - vma->vm_pgoff)
+ 		return -ENXIO;
+ 	return remap_pfn_range(vma, vma->vm_start,
+ 			       page_to_pfn(page) + vma->vm_pgoff,
+ 			       vma_pages(vma) << PAGE_SHIFT, vma->vm_page_prot);
+ }
+ EXPORT_SYMBOL_GPL(dma_mmap_pages);
+ 
++>>>>>>> 198c50e2ccff (dma-mapping: refactor dma_{alloc,free}_pages)
  int dma_supported(struct device *dev, u64 mask)
  {
  	const struct dma_map_ops *ops = get_dma_ops(dev);
* Unmerged path kernel/dma/mapping.c
