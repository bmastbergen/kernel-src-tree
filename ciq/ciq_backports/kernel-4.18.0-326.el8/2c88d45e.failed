x86, sched: Treat Intel SNC topology as default, COD as exception

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Alison Schofield <alison.schofield@intel.com>
commit 2c88d45edbb89029c1190bb3b136d2602f057c98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/2c88d45e.failed

Commit 1340ccfa9a9a ("x86,sched: Allow topologies where NUMA nodes
share an LLC") added a vendor and model specific check to never
call topology_sane() for Intel Skylake Server systems where NUMA
nodes share an LLC.

Intel Ice Lake and Sapphire Rapids CPUs also enumerate an LLC that is
shared by multiple NUMA nodes. The LLC on these CPUs is shared for
off-package data access but private to the NUMA node for on-package
access. Rather than managing a list of allowable SNC topologies, make
this SNC topology the default, and treat Intel's Cluster-On-Die (COD)
topology as the exception.

In SNC mode, Sky Lake, Ice Lake, and Sapphire Rapids servers do not
emit this warning:

sched: CPU #3's llc-sibling CPU #0 is not on the same node! [node: 1 != 0]. Ignoring dependency.

	Suggested-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Alison Schofield <alison.schofield@intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/r/20210310190233.31752-1-alison.schofield@intel.com
(cherry picked from commit 2c88d45edbb89029c1190bb3b136d2602f057c98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/smpboot.c
diff --cc arch/x86/kernel/smpboot.c
index e53450218c84,147b2f3a2a09..000000000000
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@@ -495,7 -501,9 +516,15 @@@ static const struct x86_cpu_id intel_co
  
  static bool match_llc(struct cpuinfo_x86 *c, struct cpuinfo_x86 *o)
  {
++<<<<<<< HEAD
++	if ((c->phys_proc_id == o->phys_proc_id) &&
++	    (c->_rh.cpu_die_id == o->_rh.cpu_die_id))
++		return true;
++	return false;
++=======
+ 	const struct x86_cpu_id *id = x86_match_cpu(intel_cod_cpu);
  	int cpu1 = c->cpu_index, cpu2 = o->cpu_index;
+ 	bool intel_snc = id && id->driver_data;
  
  	/* Do not match if we do not have a valid APICID for cpu: */
  	if (per_cpu(cpu_llc_id, cpu1) == BAD_APICID)
@@@ -514,26 -522,6 +543,7 @@@
  		return false;
  
  	return topology_sane(c, o, "llc");
- }
- 
- /*
-  * Unlike the other levels, we do not enforce keeping a
-  * multicore group inside a NUMA node.  If this happens, we will
-  * discard the MC level of the topology later.
-  */
- static bool match_pkg(struct cpuinfo_x86 *c, struct cpuinfo_x86 *o)
- {
- 	if (c->phys_proc_id == o->phys_proc_id)
- 		return true;
- 	return false;
- }
- 
- static bool match_die(struct cpuinfo_x86 *c, struct cpuinfo_x86 *o)
- {
- 	if ((c->phys_proc_id == o->phys_proc_id) &&
- 	    (c->_rh.cpu_die_id == o->_rh.cpu_die_id))
- 		return true;
- 	return false;
++>>>>>>> 2c88d45edbb8 (x86, sched: Treat Intel SNC topology as default, COD as exception)
  }
  
  
* Unmerged path arch/x86/kernel/smpboot.c
