ALSA: usb-audio: Factor out the implicit feedback quirk code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 9fddc15e803945a744f357a4d1c94301e1ed6681
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/9fddc15e.failed

The code dealing with the implicit feedback mode grew recently, and
it's becoming messy.  As we receive more and more devices that need
the similar handling, it's better to be processed through a table
instead of the open code.

This patch moves the code that is relevant with parsing the implicit
feedback mode and some helpers into another file, implicit.c.  The
detection and the setup of the implicit feedback sync EPs are
rewritten to use the ID/class matching table instead.

There should be no functional changes.

	Tested-by: Keith Milner <kamilner@superlative.org>
	Tested-by: Dylan Robinson <dylan_robinson@motu.com>
Link: https://lore.kernel.org/r/20201123085347.19667-38-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 9fddc15e803945a744f357a4d1c94301e1ed6681)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/pcm.c
diff --cc sound/usb/pcm.c
index ec793eb507a0,56079901769f..000000000000
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@@ -22,6 -22,8 +22,11 @@@
  #include "pcm.h"
  #include "clock.h"
  #include "power.h"
++<<<<<<< HEAD
++=======
+ #include "media.h"
+ #include "implicit.h"
++>>>>>>> 9fddc15e8039 (ALSA: usb-audio: Factor out the implicit feedback quirk code)
  
  #define SUBSTREAM_FLAG_DATA_EP_STARTED	0
  #define SUBSTREAM_FLAG_SYNC_EP_STARTED	1
@@@ -276,210 -277,7 +281,214 @@@ static int snd_usb_pcm_sync_stop(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +/* Check whether the given iface:altsetting points to an implicit fb source */
 +static bool search_generic_implicit_fb(struct snd_usb_audio *chip, int ifnum,
 +				       unsigned int altsetting,
 +				       struct usb_host_interface **altsp,
 +				       unsigned int *ep)
 +{
 +	struct usb_host_interface *alts;
 +	struct usb_interface_descriptor *altsd;
 +	struct usb_endpoint_descriptor *epd;
 +
 +	alts = snd_usb_get_host_interface(chip, ifnum, altsetting);
 +	if (!alts)
 +		return false;
 +	altsd = get_iface_desc(alts);
 +	if (altsd->bInterfaceClass != USB_CLASS_AUDIO ||
 +	    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING ||
 +	    altsd->bInterfaceProtocol != UAC_VERSION_2 ||
 +	    altsd->bNumEndpoints < 1)
 +		return false;
 +	epd = get_endpoint(alts, 0);
 +	if (!usb_endpoint_is_isoc_in(epd) ||
 +	    (epd->bmAttributes & USB_ENDPOINT_USAGE_MASK) !=
 +					USB_ENDPOINT_USAGE_IMPLICIT_FB)
 +		return false;
 +	*ep = epd->bEndpointAddress;
 +	*altsp = alts;
 +	return true;
 +}
 +
 +/* Like the function above, but specific to Roland with vendor class and hack */
 +static bool search_roland_implicit_fb(struct snd_usb_audio *chip, int ifnum,
 +				      unsigned int altsetting,
 +				      struct usb_host_interface **altsp,
 +				      unsigned int *ep)
 +{
 +	struct usb_host_interface *alts;
 +	struct usb_interface_descriptor *altsd;
 +	struct usb_endpoint_descriptor *epd;
 +
 +	alts = snd_usb_get_host_interface(chip, ifnum, altsetting);
 +	if (!alts)
 +		return false;
 +	altsd = get_iface_desc(alts);
 +	if (altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC ||
 +	    (altsd->bInterfaceSubClass != 2 &&
 +	     altsd->bInterfaceProtocol != 2) ||
 +	    altsd->bNumEndpoints < 1)
 +		return false;
 +	epd = get_endpoint(alts, 0);
 +	if (!usb_endpoint_is_isoc_in(epd) ||
 +	    (epd->bmAttributes & USB_ENDPOINT_USAGE_MASK) !=
 +					USB_ENDPOINT_USAGE_IMPLICIT_FB)
 +		return false;
 +	*ep = epd->bEndpointAddress;
 +	*altsp = alts;
 +	return true;
 +}
 +
 +/* Setup an implicit feedback endpoint from a quirk. Returns 0 if no quirk
 + * applies. Returns 1 if a quirk was found.
 + */
 +static int audioformat_implicit_fb_quirk(struct snd_usb_audio *chip,
 +					 struct audioformat *fmt,
 +					 struct usb_host_interface *alts)
 +{
 +	struct usb_device *dev = chip->dev;
 +	struct usb_interface_descriptor *altsd = get_iface_desc(alts);
 +	struct usb_interface *iface;
 +	unsigned int attr = fmt->ep_attr & USB_ENDPOINT_SYNCTYPE;
 +	unsigned int ep;
 +	unsigned int ifnum;
 +
 +	switch (chip->usb_id) {
 +	case USB_ID(0x0763, 0x2030): /* M-Audio Fast Track C400 */
 +	case USB_ID(0x0763, 0x2031): /* M-Audio Fast Track C600 */
 +	case USB_ID(0x22f0, 0x0006): /* Allen&Heath Qu-16 */
 +		ep = 0x81;
 +		ifnum = 3;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x0763, 0x2080): /* M-Audio FastTrack Ultra */
 +	case USB_ID(0x0763, 0x2081):
 +		ep = 0x81;
 +		ifnum = 2;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x2466, 0x8003): /* Fractal Audio Axe-Fx II */
 +	case USB_ID(0x0499, 0x172a): /* Yamaha MODX */
 +		ep = 0x86;
 +		ifnum = 2;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x2466, 0x8010): /* Fractal Audio Axe-Fx III */
 +		ep = 0x81;
 +		ifnum = 2;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x1686, 0xf029): /* Zoom UAC-2 */
 +		ep = 0x82;
 +		ifnum = 2;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x1397, 0x0001): /* Behringer UFX1604 */
 +	case USB_ID(0x1397, 0x0002): /* Behringer UFX1204 */
 +		ep = 0x81;
 +		ifnum = 1;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x07fd, 0x0004): /* MOTU MicroBook II/IIc */
 +		/* MicroBook IIc */
 +		if (altsd->bInterfaceClass == USB_CLASS_AUDIO)
 +			return 0;
 +
 +		/* MicroBook II */
 +		ep = 0x84;
 +		ifnum = 0;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x07fd, 0x0008): /* MOTU M Series */
 +	case USB_ID(0x31e9, 0x0001): /* Solid State Logic SSL2 */
 +	case USB_ID(0x31e9, 0x0002): /* Solid State Logic SSL2+ */
 +	case USB_ID(0x0499, 0x172f): /* Steinberg UR22C */
 +	case USB_ID(0x0d9a, 0x00df): /* RTX6001 */
 +		ep = 0x81;
 +		ifnum = 2;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x2b73, 0x000a): /* Pioneer DJ DJM-900NXS2 */
 +	case USB_ID(0x2b73, 0x0017): /* Pioneer DJ DJM-250MK2 */
 +		ep = 0x82;
 +		ifnum = 0;
 +		goto add_sync_ep_from_ifnum;
 +	case USB_ID(0x0582, 0x01d8): /* BOSS Katana */
 +		/* BOSS Katana amplifiers do not need quirks */
 +		return 0;
 +	case USB_ID(0x0582, 0x01e5): /* BOSS GT-001 */
 +		/* BOSS GT-001 needs no implicit fb for playback */
 +		return 0;
 +	}
 +
 +	/* Generic UAC2 implicit feedback */
 +	if (attr == USB_ENDPOINT_SYNC_ASYNC &&
 +	    altsd->bInterfaceClass == USB_CLASS_AUDIO &&
 +	    altsd->bInterfaceProtocol == UAC_VERSION_2 &&
 +	    altsd->bNumEndpoints == 1) {
 +		ifnum = altsd->bInterfaceNumber + 1;
 +		if (search_generic_implicit_fb(chip, ifnum,
 +					       altsd->bAlternateSetting,
 +					       &alts, &ep))
 +			goto add_sync_ep;
 +	}
 +
 +	/* Roland/BOSS implicit feedback with vendor spec class */
 +	if (attr == USB_ENDPOINT_SYNC_ASYNC &&
 +	    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&
 +	    altsd->bInterfaceProtocol == 2 &&
 +	    altsd->bNumEndpoints == 1 &&
 +	    USB_ID_VENDOR(chip->usb_id) == 0x0582 /* Roland */) {
 +		ifnum = altsd->bInterfaceNumber + 1;
 +		if (search_roland_implicit_fb(chip, ifnum,
 +					      altsd->bAlternateSetting,
 +					      &alts, &ep))
 +			goto add_sync_ep;
 +	}
 +
 +	/* No quirk */
 +	return 0;
 +
 +add_sync_ep_from_ifnum:
 +	iface = usb_ifnum_to_if(dev, ifnum);
 +
 +	if (!iface || iface->num_altsetting < 2)
 +		return 0;
 +
 +	alts = &iface->altsetting[1];
 +
 +add_sync_ep:
 +	fmt->sync_ep = ep;
 +	fmt->sync_iface = ifnum;
 +	fmt->sync_altsetting = alts->desc.bAlternateSetting;
 +	fmt->implicit_fb = 1;
 +	dev_dbg(&dev->dev, "%d:%d: found implicit_fb sync_ep=%x, iface=%d, alt=%d\n",
 +		fmt->iface, fmt->altsetting, fmt->sync_ep, fmt->sync_iface,
 +		fmt->sync_altsetting);
 +
 +	return 1;
 +}
 +
 +static int audioformat_capture_quirk(struct snd_usb_audio *chip,
 +				     struct audioformat *fmt,
 +				     struct usb_host_interface *alts)
 +{
 +	struct usb_device *dev = chip->dev;
 +
 +	switch (chip->usb_id) {
 +	case USB_ID(0x0582, 0x01e5): /* BOSS GT-001 */
 +		if (!snd_usb_get_host_interface(chip, 0x01, 0x01))
 +			return 0;
 +		fmt->sync_ep = 0x0d;
 +		fmt->sync_iface = 0x01;
 +		fmt->sync_altsetting = 0x01;
 +		fmt->sync_ep_idx = 0;
 +		fmt->implicit_fb = 1;
 +		dev_dbg(&dev->dev, "%d:%d: added fake capture sync sync_ep=%x, iface=%d, alt=%d\n",
 +			fmt->iface, fmt->altsetting, fmt->sync_ep, fmt->sync_iface,
 +			fmt->sync_altsetting);
 +		return 1;
 +	}
 +	return 0;
 +
 +}
 +
++=======
+ /* Set up sync endpoint */
++>>>>>>> 9fddc15e8039 (ALSA: usb-audio: Factor out the implicit feedback quirk code)
  int snd_usb_audioformat_set_sync_ep(struct snd_usb_audio *chip,
  				    struct audioformat *fmt)
  {
@@@ -567,289 -364,6 +574,292 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int set_sync_endpoint(struct snd_usb_substream *subs,
 +			     struct audioformat *fmt)
 +{
 +	struct usb_device *dev = subs->dev;
 +	struct usb_host_interface *alts;
 +	struct snd_usb_audio *chip = subs->stream->chip;
 +	int is_playback = subs->direction == SNDRV_PCM_STREAM_PLAYBACK;
 +	unsigned int ep;
 +	int err;
 +
 +	subs->sync_endpoint = NULL;
 +	subs->data_endpoint->sync_master = NULL;
 +
 +	ep = fmt->sync_ep;
 +	if (!ep)
 +		return 0;
 +
 +	alts = snd_usb_get_host_interface(subs->stream->chip, fmt->sync_iface,
 +					  fmt->altsetting);
 +	if (!alts)
 +		return 0;
 +
 +	subs->sync_endpoint = snd_usb_get_endpoint(chip, ep);
 +	if (!subs->sync_endpoint) {
 +		if (is_playback &&
 +		    (fmt->ep_attr & USB_ENDPOINT_SYNCTYPE) == USB_ENDPOINT_SYNC_NONE)
 +			return 0;
 +		return -EINVAL;
 +	}
 +
 +	subs->sync_endpoint->iface = fmt->sync_iface;
 +	subs->sync_endpoint->altsetting = fmt->sync_altsetting;
 +	subs->sync_endpoint->is_implicit_feedback = fmt->implicit_fb;
 +
 +	subs->data_endpoint->sync_master = subs->sync_endpoint;
 +
 +	snd_usb_endpoint_set_syncinterval(subs->stream->chip, subs->sync_endpoint, alts);
 +
 +	if (!subs->sync_endpoint->use_count &&
 +	    (subs->data_endpoint->iface != subs->sync_endpoint->iface ||
 +	     subs->data_endpoint->altsetting != subs->sync_endpoint->altsetting)) {
 +		err = usb_set_interface(subs->dev,
 +					subs->sync_endpoint->iface,
 +					subs->sync_endpoint->altsetting);
 +		if (err < 0)
 +			return err;
 +		dev_dbg(&dev->dev, "setting usb interface %d:%d\n",
 +			subs->sync_endpoint->iface,
 +			subs->sync_endpoint->altsetting);
 +		snd_usb_set_interface_quirk(chip);
 +	}
 +
 +	return 0;
 +}
 +
 +/*
 + * find a matching format and set up the interface
 + */
 +static int set_format(struct snd_usb_substream *subs, struct audioformat *fmt)
 +{
 +	struct usb_device *dev = subs->dev;
 +	struct snd_usb_audio *chip = subs->stream->chip;
 +	struct usb_host_interface *alts;
 +	struct usb_interface *iface;
 +	struct snd_usb_endpoint *ep;
 +	int err;
 +
 +	iface = usb_ifnum_to_if(dev, fmt->iface);
 +	if (WARN_ON(!iface))
 +		return -EINVAL;
 +	alts = usb_altnum_to_altsetting(iface, fmt->altsetting);
 +	if (WARN_ON(!alts))
 +		return -EINVAL;
 +
 +	if (fmt == subs->cur_audiofmt && !subs->need_setup_fmt)
 +		return 0;
 +
 +	/* shared EP with implicit fb */
 +	if (fmt->implicit_fb && !subs->need_setup_fmt) {
 +		ep = snd_usb_get_endpoint(chip, fmt->endpoint);
 +		if (ep && ep->use_count > 0)
 +			goto add_data_ep;
 +	}
 +
 +	/* close the old interface */
 +	if (subs->interface >= 0 && (subs->interface != fmt->iface || subs->need_setup_fmt)) {
 +		if (!subs->stream->chip->keep_iface) {
 +			err = usb_set_interface(subs->dev, subs->interface, 0);
 +			if (err < 0) {
 +				dev_err(&dev->dev,
 +					"%d:%d: return to setting 0 failed (%d)\n",
 +					fmt->iface, fmt->altsetting, err);
 +				return -EIO;
 +			}
 +		}
 +		subs->interface = -1;
 +		subs->altset_idx = 0;
 +	}
 +
 +	if (subs->need_setup_fmt)
 +		subs->need_setup_fmt = false;
 +
 +	/* set interface */
 +	if (iface->cur_altsetting != alts) {
 +		err = snd_usb_select_mode_quirk(chip, fmt);
 +		if (err < 0)
 +			return -EIO;
 +
 +		err = usb_set_interface(dev, fmt->iface, fmt->altsetting);
 +		if (err < 0) {
 +			dev_err(&dev->dev,
 +				"%d:%d: usb_set_interface failed (%d)\n",
 +				fmt->iface, fmt->altsetting, err);
 +			return -EIO;
 +		}
 +		dev_dbg(&dev->dev, "setting usb interface %d:%d\n",
 +			fmt->iface, fmt->altsetting);
 +		snd_usb_set_interface_quirk(chip);
 +	}
 +
 +	subs->need_setup_ep = true;
 +
 + add_data_ep:
 +	subs->interface = fmt->iface;
 +	subs->altset_idx = fmt->altset_idx;
 +	subs->data_endpoint = snd_usb_get_endpoint(chip, fmt->endpoint);
 +	if (!subs->data_endpoint)
 +		return -EINVAL;
 +	subs->data_endpoint->iface = fmt->iface;
 +	subs->data_endpoint->altsetting = fmt->altsetting;
 +
 +	err = set_sync_endpoint(subs, fmt);
 +	if (err < 0)
 +		return err;
 +
 +	if (subs->need_setup_ep) {
 +		err = snd_usb_init_pitch(chip, fmt);
 +		if (err < 0)
 +			return err;
 +	}
 +
 +	subs->cur_audiofmt = fmt;
 +
 +	snd_usb_set_format_quirk(subs, fmt);
 +
 +	return 0;
 +}
 +
 +/*
 + * Return the score of matching two audioformats.
 + * Veto the audioformat if:
 + * - It has no channels for some reason.
 + * - Requested PCM format is not supported.
 + * - Requested sample rate is not supported.
 + */
 +static int match_endpoint_audioformats(struct snd_usb_substream *subs,
 +				       struct audioformat *fp,
 +				       struct audioformat *match, int rate,
 +				       snd_pcm_format_t pcm_format)
 +{
 +	int i, score;
 +
 +	if (fp->channels < 1)
 +		return 0;
 +
 +	if (!(fp->formats & pcm_format_to_bits(pcm_format)))
 +		return 0;
 +
 +	if (fp->rates & SNDRV_PCM_RATE_CONTINUOUS) {
 +		if (rate < fp->rate_min || rate > fp->rate_max)
 +			return 0;
 +	} else {
 +		for (i = 0; i < fp->nr_rates; i++) {
 +			if (fp->rate_table[i] == rate)
 +				break;
 +		}
 +		if (i >= fp->nr_rates)
 +			return 0;
 +	}
 +
 +	score = 1;
 +	if (fp->channels == match->channels)
 +		score++;
 +
 +	return score;
 +}
 +
 +/*
 + * Configure the sync ep using the rate and pcm format of the data ep.
 + */
 +static int configure_sync_endpoint(struct snd_usb_substream *subs)
 +{
 +	struct audioformat *fp;
 +	struct audioformat *sync_fp = NULL;
 +	int cur_score = 0;
 +	int sync_period_bytes = subs->period_bytes;
 +	struct snd_usb_substream *sync_subs =
 +		&subs->stream->substream[subs->direction ^ 1];
 +
 +	if (subs->fixed_hw ||
 +	    !subs->sync_endpoint->is_implicit_feedback) {
 +		sync_fp = subs->cur_audiofmt;
 +		goto configure;
 +	}
 +
 +	sync_fp = find_format(&sync_subs->fmt_list, subs->pcm_format,
 +			      subs->cur_rate, subs->channels, NULL);
 +	if (sync_fp)
 +		goto configure;
 +
 +	/* Try to find the best matching audioformat. */
 +	list_for_each_entry(fp, &sync_subs->fmt_list, list) {
 +		int score = match_endpoint_audioformats(subs,
 +							fp, subs->cur_audiofmt,
 +			subs->cur_rate, subs->pcm_format);
 +
 +		if (score > cur_score) {
 +			sync_fp = fp;
 +			cur_score = score;
 +		}
 +	}
 +
 +	if (unlikely(sync_fp == NULL)) {
 +		dev_err(&subs->dev->dev,
 +			"%s: no valid audioformat for sync ep %x found\n",
 +			__func__, sync_subs->ep_num);
 +		return -EINVAL;
 +	}
 +
 +	/*
 +	 * Recalculate the period bytes if channel number differ between
 +	 * data and sync ep audioformat.
 +	 */
 +	if (sync_fp->channels != subs->channels) {
 +		sync_period_bytes = (subs->period_bytes / subs->channels) *
 +			sync_fp->channels;
 +		dev_dbg(&subs->dev->dev,
 +			"%s: adjusted sync ep period bytes (%d -> %d)\n",
 +			__func__, subs->period_bytes, sync_period_bytes);
 +	}
 +
 + configure:
 +	return snd_usb_endpoint_set_params(subs->sync_endpoint,
 +					   subs->pcm_format,
 +					   sync_fp->channels,
 +					   sync_period_bytes,
 +					   subs->period_frames,
 +					   subs->buffer_periods,
 +					   subs->cur_rate,
 +					   sync_fp,
 +					   NULL);
 +}
 +
 +/*
 + * configure endpoint params
 + *
 + * called  during initial setup and upon resume
 + */
 +static int configure_endpoint(struct snd_usb_substream *subs)
 +{
 +	int ret;
 +
 +	/* format changed */
 +	stop_endpoints(subs);
 +	sync_pending_stops(subs);
 +	ret = snd_usb_endpoint_set_params(subs->data_endpoint,
 +					  subs->pcm_format,
 +					  subs->channels,
 +					  subs->period_bytes,
 +					  subs->period_frames,
 +					  subs->buffer_periods,
 +					  subs->cur_rate,
 +					  subs->cur_audiofmt,
 +					  subs->sync_endpoint);
 +	if (ret < 0)
 +		return ret;
 +
 +	if (subs->sync_endpoint)
 +		ret = configure_sync_endpoint(subs);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 9fddc15e8039 (ALSA: usb-audio: Factor out the implicit feedback quirk code)
  static int snd_usb_pcm_change_state(struct snd_usb_substream *subs, int state)
  {
  	int ret;
@@@ -898,6 -412,45 +908,48 @@@ int snd_usb_pcm_resume(struct snd_usb_s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void close_endpoints(struct snd_usb_audio *chip,
+ 			    struct snd_usb_substream *subs)
+ {
+ 	if (subs->data_endpoint) {
+ 		snd_usb_endpoint_set_sync(chip, subs->data_endpoint, NULL);
+ 		snd_usb_endpoint_close(chip, subs->data_endpoint);
+ 		subs->data_endpoint = NULL;
+ 	}
+ 
+ 	if (subs->sync_endpoint) {
+ 		snd_usb_endpoint_close(chip, subs->sync_endpoint);
+ 		subs->sync_endpoint = NULL;
+ 	}
+ }
+ 
+ static int configure_endpoints(struct snd_usb_audio *chip,
+ 			       struct snd_usb_substream *subs)
+ {
+ 	int err;
+ 
+ 	if (subs->data_endpoint->need_setup) {
+ 		/* stop any running stream beforehand */
+ 		if (stop_endpoints(subs))
+ 			sync_pending_stops(subs);
+ 		err = snd_usb_endpoint_configure(chip, subs->data_endpoint);
+ 		if (err < 0)
+ 			return err;
+ 		snd_usb_set_format_quirk(subs, subs->cur_audiofmt);
+ 	}
+ 
+ 	if (subs->sync_endpoint) {
+ 		err = snd_usb_endpoint_configure(chip, subs->sync_endpoint);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 9fddc15e8039 (ALSA: usb-audio: Factor out the implicit feedback quirk code)
  /*
   * hw_params callback
   *
@@@ -912,27 -465,46 +964,49 @@@ static int snd_usb_hw_params(struct snd
  			     struct snd_pcm_hw_params *hw_params)
  {
  	struct snd_usb_substream *subs = substream->runtime->private_data;
 -	struct snd_usb_audio *chip = subs->stream->chip;
 -	const struct audioformat *fmt;
 -	const struct audioformat *sync_fmt;
 +	struct audioformat *fmt;
  	int ret;
  
 -	ret = snd_media_start_pipeline(subs);
 -	if (ret)
 -		return ret;
 +	subs->pcm_format = params_format(hw_params);
 +	subs->period_bytes = params_period_bytes(hw_params);
 +	subs->period_frames = params_period_size(hw_params);
 +	subs->buffer_periods = params_periods(hw_params);
 +	subs->channels = params_channels(hw_params);
 +	subs->cur_rate = params_rate(hw_params);
  
 -	fmt = find_substream_format(subs, hw_params);
 +	fmt = find_substream_format(subs);
  	if (!fmt) {
 -		usb_audio_dbg(chip,
 -			      "cannot find format: format=%s, rate=%d, channels=%d\n",
 -			      snd_pcm_format_name(params_format(hw_params)),
 -			      params_rate(hw_params), params_channels(hw_params));
 -		ret = -EINVAL;
 -		goto stop_pipeline;
 +		dev_dbg(&subs->dev->dev,
 +			"cannot set format: format = %#x, rate = %d, channels = %d\n",
 +			   subs->pcm_format, subs->cur_rate, subs->channels);
 +		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	ret = snd_usb_lock_shutdown(subs->stream->chip);
++=======
+ 	if (fmt->implicit_fb) {
+ 		sync_fmt = snd_usb_find_implicit_fb_sync_format(chip, fmt,
+ 								hw_params,
+ 								!substream->stream);
+ 		if (!sync_fmt) {
+ 			usb_audio_dbg(chip,
+ 				      "cannot find sync format: ep=0x%x, iface=%d:%d, format=%s, rate=%d, channels=%d\n",
+ 				      fmt->sync_ep, fmt->sync_iface,
+ 				      fmt->sync_altsetting,
+ 				      snd_pcm_format_name(params_format(hw_params)),
+ 				      params_rate(hw_params), params_channels(hw_params));
+ 			ret = -EINVAL;
+ 			goto stop_pipeline;
+ 		}
+ 	} else {
+ 		sync_fmt = fmt;
+ 	}
+ 
+ 	ret = snd_usb_lock_shutdown(chip);
++>>>>>>> 9fddc15e8039 (ALSA: usb-audio: Factor out the implicit feedback quirk code)
  	if (ret < 0)
 -		goto stop_pipeline;
 +		return ret;
  
  	ret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D0);
  	if (ret < 0)
diff --git a/sound/usb/Makefile b/sound/usb/Makefile
index 46bef3097a42..58ac3f21f440 100644
--- a/sound/usb/Makefile
+++ b/sound/usb/Makefile
@@ -8,6 +8,7 @@ snd-usb-audio-objs := 	card.o \
 			endpoint.o \
 			format.o \
 			helper.o \
+			implicit.o \
 			mixer.o \
 			mixer_quirks.o \
 			mixer_scarlett.o \
diff --git a/sound/usb/implicit.c b/sound/usb/implicit.c
new file mode 100644
index 000000000000..bc7edecff946
--- /dev/null
+++ b/sound/usb/implicit.c
@@ -0,0 +1,347 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+//
+// Special handling for implicit feedback mode
+//
+
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/audio.h>
+#include <linux/usb/audio-v2.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include "usbaudio.h"
+#include "card.h"
+#include "helper.h"
+#include "implicit.h"
+
+enum {
+	IMPLICIT_FB_NONE,
+	IMPLICIT_FB_FIXED,
+};
+
+struct snd_usb_implicit_fb_match {
+	unsigned int id;
+	unsigned int iface_class;
+	unsigned int ep_num;
+	unsigned int iface;
+	int type;
+};
+
+#define IMPLICIT_FB_FIXED_DEV(vend, prod, ep, ifnum) \
+	{ .id = USB_ID(vend, prod), .type = IMPLICIT_FB_FIXED, .ep_num = (ep),\
+	    .iface = (ifnum) }
+#define IMPLICIT_FB_SKIP_DEV(vend, prod) \
+	{ .id = USB_ID(vend, prod), .type = IMPLICIT_FB_NONE }
+
+/* Implicit feedback quirk table for playback */
+static const struct snd_usb_implicit_fb_match playback_implicit_fb_quirks[] = {
+	/* Fixed EP */
+	IMPLICIT_FB_FIXED_DEV(0x1397, 0x0001, 0x81, 1), /* Behringer UFX1604 */
+	IMPLICIT_FB_FIXED_DEV(0x1397, 0x0002, 0x81, 1), /* Behringer UFX1204 */
+	IMPLICIT_FB_FIXED_DEV(0x0763, 0x2080, 0x81, 2), /* M-Audio FastTrack Ultra */
+	IMPLICIT_FB_FIXED_DEV(0x0763, 0x2081, 0x81, 2), /* M-Audio FastTrack Ultra */
+	IMPLICIT_FB_FIXED_DEV(0x2466, 0x8010, 0x81, 2), /* Fractal Audio Axe-Fx III */
+	IMPLICIT_FB_FIXED_DEV(0x07fd, 0x0008, 0x81, 2), /* MOTU M Series */
+	IMPLICIT_FB_FIXED_DEV(0x31e9, 0x0001, 0x81, 2), /* Solid State Logic SSL2 */
+	IMPLICIT_FB_FIXED_DEV(0x31e9, 0x0002, 0x81, 2), /* Solid State Logic SSL2+ */
+	IMPLICIT_FB_FIXED_DEV(0x0499, 0x172f, 0x81, 2), /* Steinberg UR22C */
+	IMPLICIT_FB_FIXED_DEV(0x0d9a, 0x00df, 0x81, 2), /* RTX6001 */
+	IMPLICIT_FB_FIXED_DEV(0x0763, 0x2030, 0x81, 3), /* M-Audio Fast Track C400 */
+	IMPLICIT_FB_FIXED_DEV(0x0763, 0x2031, 0x81, 3), /* M-Audio Fast Track C600 */
+	IMPLICIT_FB_FIXED_DEV(0x22f0, 0x0006, 0x81, 3), /* Allen&Heath Qu-16 */
+	IMPLICIT_FB_FIXED_DEV(0x2b73, 0x000a, 0x82, 0), /* Pioneer DJ DJM-900NXS2 */
+	IMPLICIT_FB_FIXED_DEV(0x2b73, 0x0017, 0x82, 0), /* Pioneer DJ DJM-250MK2 */
+	IMPLICIT_FB_FIXED_DEV(0x1686, 0xf029, 0x82, 2), /* Zoom UAC-2 */
+	IMPLICIT_FB_FIXED_DEV(0x2466, 0x8003, 0x86, 2), /* Fractal Audio Axe-Fx II */
+	IMPLICIT_FB_FIXED_DEV(0x0499, 0x172a, 0x86, 2), /* Yamaha MODX */
+
+	/* Special matching */
+	{ .id = USB_ID(0x07fd, 0x0004), .iface_class = USB_CLASS_AUDIO,
+	  .type = IMPLICIT_FB_NONE },		/* MicroBook IIc */
+	/* ep = 0x84, ifnum = 0 */
+	{ .id = USB_ID(0x07fd, 0x0004), .iface_class = USB_CLASS_VENDOR_SPEC,
+	  .type = IMPLICIT_FB_FIXED,
+	  .ep_num = 0x84, .iface = 0 },		/* MOTU MicroBook II */
+
+	/* No quirk */
+	IMPLICIT_FB_SKIP_DEV(0x0582, 0x01d8),	/* BOSS Katana */
+
+	/* No quirk for playback but with capture quirk (see below) */
+	IMPLICIT_FB_SKIP_DEV(0x0582, 0x01e5),	/* BOSS GT-001 */
+
+	{} /* terminator */
+};
+
+/* Implicit feedback quirk table for capture */
+static const struct snd_usb_implicit_fb_match capture_implicit_fb_quirks[] = {
+	IMPLICIT_FB_FIXED_DEV(0x0582, 0x01e5, 0x0d, 0x01), /* BOSS GT-001 */
+
+	{} /* terminator */
+};
+
+/* set up sync EP information on the audioformat */
+static int add_implicit_fb_sync_ep(struct snd_usb_audio *chip,
+				   struct audioformat *fmt,
+				   int ep, int ifnum,
+				   const struct usb_host_interface *alts)
+{
+	struct usb_interface *iface;
+
+	if (!alts) {
+		iface = usb_ifnum_to_if(chip->dev, ifnum);
+		if (!iface || iface->num_altsetting < 2)
+			return 0;
+		alts = &iface->altsetting[1];
+	}
+
+	fmt->sync_ep = ep;
+	fmt->sync_iface = ifnum;
+	fmt->sync_altsetting = alts->desc.bAlternateSetting;
+	fmt->sync_ep_idx = 0;
+	fmt->implicit_fb = 1;
+	usb_audio_dbg(chip,
+		      "%d:%d: added %s implicit_fb sync_ep %x, iface %d:%d\n",
+		      fmt->iface, fmt->altsetting,
+		      (ep & USB_DIR_IN) ? "playback" : "capture",
+		      fmt->sync_ep, fmt->sync_iface, fmt->sync_altsetting);
+	return 1;
+}
+
+/* Check whether the given UAC2 iface:altset points to an implicit fb source */
+static int add_generic_uac2_implicit_fb(struct snd_usb_audio *chip,
+					struct audioformat *fmt,
+					unsigned int ifnum,
+					unsigned int altsetting)
+{
+	struct usb_host_interface *alts;
+	struct usb_endpoint_descriptor *epd;
+
+	alts = snd_usb_get_host_interface(chip, ifnum, altsetting);
+	if (!alts)
+		return 0;
+	if (alts->desc.bInterfaceClass != USB_CLASS_AUDIO ||
+	    alts->desc.bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING ||
+	    alts->desc.bInterfaceProtocol != UAC_VERSION_2 ||
+	    alts->desc.bNumEndpoints < 1)
+		return 0;
+	epd = get_endpoint(alts, 0);
+	if (!usb_endpoint_is_isoc_in(epd) ||
+	    (epd->bmAttributes & USB_ENDPOINT_USAGE_MASK) !=
+					USB_ENDPOINT_USAGE_IMPLICIT_FB)
+		return 0;
+	return add_implicit_fb_sync_ep(chip, fmt, epd->bEndpointAddress,
+				       ifnum, alts);
+}
+
+/* Like the function above, but specific to Roland with vendor class and hack */
+static int add_roland_implicit_fb(struct snd_usb_audio *chip,
+				  struct audioformat *fmt,
+				  unsigned int ifnum,
+				  unsigned int altsetting)
+{
+	struct usb_host_interface *alts;
+	struct usb_endpoint_descriptor *epd;
+
+	alts = snd_usb_get_host_interface(chip, ifnum, altsetting);
+	if (!alts)
+		return 0;
+	if (alts->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC ||
+	    (alts->desc.bInterfaceSubClass != 2 &&
+	     alts->desc.bInterfaceProtocol != 2) ||
+	    alts->desc.bNumEndpoints < 1)
+		return 0;
+	epd = get_endpoint(alts, 0);
+	if (!usb_endpoint_is_isoc_in(epd) ||
+	    (epd->bmAttributes & USB_ENDPOINT_USAGE_MASK) !=
+					USB_ENDPOINT_USAGE_IMPLICIT_FB)
+		return 0;
+	return add_implicit_fb_sync_ep(chip, fmt, epd->bEndpointAddress,
+				       ifnum, alts);
+}
+
+static const struct snd_usb_implicit_fb_match *
+find_implicit_fb_entry(struct snd_usb_audio *chip,
+		       const struct snd_usb_implicit_fb_match *match,
+		       const struct usb_host_interface *alts)
+{
+	for (; match->id; match++)
+		if (match->id == chip->usb_id &&
+		    (!match->iface_class ||
+		     (alts->desc.bInterfaceClass == match->iface_class)))
+			return match;
+
+	return NULL;
+}
+
+/* Setup an implicit feedback endpoint from a quirk. Returns 0 if no quirk
+ * applies. Returns 1 if a quirk was found.
+ */
+static int audioformat_implicit_fb_quirk(struct snd_usb_audio *chip,
+					 struct audioformat *fmt,
+					 struct usb_host_interface *alts)
+{
+	const struct snd_usb_implicit_fb_match *p;
+	unsigned int attr = fmt->ep_attr & USB_ENDPOINT_SYNCTYPE;
+
+	p = find_implicit_fb_entry(chip, playback_implicit_fb_quirks, alts);
+	if (p) {
+		switch (p->type) {
+		case IMPLICIT_FB_NONE:
+			return 0; /* No quirk */
+		case IMPLICIT_FB_FIXED:
+			return add_implicit_fb_sync_ep(chip, fmt, p->ep_num,
+						       p->iface, NULL);
+		}
+	}
+
+	/* Generic UAC2 implicit feedback */
+	if (attr == USB_ENDPOINT_SYNC_ASYNC &&
+	    alts->desc.bInterfaceClass == USB_CLASS_AUDIO &&
+	    alts->desc.bInterfaceProtocol == UAC_VERSION_2 &&
+	    alts->desc.bNumEndpoints == 1) {
+		if (add_generic_uac2_implicit_fb(chip, fmt,
+						 alts->desc.bInterfaceNumber + 1,
+						 alts->desc.bAlternateSetting))
+			return 1;
+	}
+
+	/* Roland/BOSS implicit feedback with vendor spec class */
+	if (attr == USB_ENDPOINT_SYNC_ASYNC &&
+	    alts->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC &&
+	    alts->desc.bInterfaceProtocol == 2 &&
+	    alts->desc.bNumEndpoints == 1 &&
+	    USB_ID_VENDOR(chip->usb_id) == 0x0582 /* Roland */) {
+		if (add_roland_implicit_fb(chip, fmt,
+					   alts->desc.bInterfaceNumber + 1,
+					   alts->desc.bAlternateSetting))
+			return 1;
+	}
+
+	/* No quirk */
+	return 0;
+}
+
+/* same for capture, but only handling FIXED entry */
+static int audioformat_capture_quirk(struct snd_usb_audio *chip,
+				     struct audioformat *fmt,
+				     struct usb_host_interface *alts)
+{
+	const struct snd_usb_implicit_fb_match *p;
+
+	p = find_implicit_fb_entry(chip, capture_implicit_fb_quirks, alts);
+	if (p && p->type == IMPLICIT_FB_FIXED)
+		return add_implicit_fb_sync_ep(chip, fmt, p->ep_num, p->iface,
+					       NULL);
+	return 0;
+}
+
+/*
+ * Parse altset and set up implicit feedback endpoint on the audioformat
+ */
+int snd_usb_parse_implicit_fb_quirk(struct snd_usb_audio *chip,
+				    struct audioformat *fmt,
+				    struct usb_host_interface *alts)
+{
+	if (fmt->endpoint & USB_DIR_IN)
+		return audioformat_capture_quirk(chip, fmt, alts);
+	else
+		return audioformat_implicit_fb_quirk(chip, fmt, alts);
+}
+
+/*
+ * Return the score of matching two audioformats.
+ * Veto the audioformat if:
+ * - It has no channels for some reason.
+ * - Requested PCM format is not supported.
+ * - Requested sample rate is not supported.
+ */
+static int match_endpoint_audioformats(struct snd_usb_substream *subs,
+				       const struct audioformat *fp,
+				       int rate, int channels,
+				       snd_pcm_format_t pcm_format)
+{
+	int i, score;
+
+	if (fp->channels < 1)
+		return 0;
+
+	if (!(fp->formats & pcm_format_to_bits(pcm_format)))
+		return 0;
+
+	if (fp->rates & SNDRV_PCM_RATE_CONTINUOUS) {
+		if (rate < fp->rate_min || rate > fp->rate_max)
+			return 0;
+	} else {
+		for (i = 0; i < fp->nr_rates; i++) {
+			if (fp->rate_table[i] == rate)
+				break;
+		}
+		if (i >= fp->nr_rates)
+			return 0;
+	}
+
+	score = 1;
+	if (fp->channels == channels)
+		score++;
+
+	return score;
+}
+
+static struct snd_usb_substream *
+find_matching_substream(struct snd_usb_audio *chip, int stream, int ep_num,
+			int fmt_type)
+{
+	struct snd_usb_stream *as;
+	struct snd_usb_substream *subs;
+
+	list_for_each_entry(as, &chip->pcm_list, list) {
+		subs = &as->substream[stream];
+		if (as->fmt_type == fmt_type && subs->ep_num == ep_num)
+			return subs;
+	}
+
+	return NULL;
+}
+
+/*
+ * Return the audioformat that is suitable for the implicit fb
+ */
+const struct audioformat *
+snd_usb_find_implicit_fb_sync_format(struct snd_usb_audio *chip,
+				     const struct audioformat *target,
+				     const struct snd_pcm_hw_params *params,
+				     int stream)
+{
+	struct snd_usb_substream *subs;
+	const struct audioformat *fp, *sync_fmt;
+	int score, high_score;
+
+	/* When sharing the same altset, use the original audioformat */
+	if (target->iface == target->sync_iface &&
+	    target->altsetting == target->sync_altsetting)
+		return target;
+
+	subs = find_matching_substream(chip, stream, target->sync_ep,
+				       target->fmt_type);
+	if (!subs)
+		return NULL;
+
+	sync_fmt = NULL;
+	high_score = 0;
+	list_for_each_entry(fp, &subs->fmt_list, list) {
+		score = match_endpoint_audioformats(subs, fp,
+						    params_rate(params),
+						    params_channels(params),
+						    params_format(params));
+		if (score > high_score) {
+			sync_fmt = fp;
+			high_score = score;
+		}
+	}
+
+	return sync_fmt;
+}
+
diff --git a/sound/usb/implicit.h b/sound/usb/implicit.h
new file mode 100644
index 000000000000..ccb415a0ea86
--- /dev/null
+++ b/sound/usb/implicit.h
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef __USBAUDIO_IMPLICIT_H
+#define __USBAUDIO_IMPLICIT_H
+
+int snd_usb_parse_implicit_fb_quirk(struct snd_usb_audio *chip,
+				    struct audioformat *fmt,
+				    struct usb_host_interface *alts);
+const struct audioformat *
+snd_usb_find_implicit_fb_sync_format(struct snd_usb_audio *chip,
+				     const struct audioformat *target,
+				     const struct snd_pcm_hw_params *params,
+				     int stream);
+
+#endif /* __USBAUDIO_IMPLICIT_H */
* Unmerged path sound/usb/pcm.c
