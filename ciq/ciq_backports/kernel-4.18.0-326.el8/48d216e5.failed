net/mlx5e: Refactor reg_c1 usage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Vlad Buslov <vladbu@nvidia.com>
commit 48d216e5596a58e3cfa6d4548343f982c5921b79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/48d216e5.failed

Following patch in series uses reg_c1 in eswitch code. To use reg_c1
helpers in both TC and eswitch code, refactor existing helpers according to
similar use case of reg_c0 and move the functionality into eswitch.h.
Calculate reg mappings length from new defines to ensure that they are
always in sync and only need to be changed in single place.

	Signed-off-by: Vlad Buslov <vladbu@nvidia.com>
	Signed-off-by: Dmytro Linkin <dlinkin@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 48d216e5596a58e3cfa6d4548343f982c5921b79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	include/linux/mlx5/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
index 0664a4e01bff,14bcebd4a0b6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
@@@ -661,8 -660,7 +661,12 @@@ bool mlx5e_rep_tc_update_skb(struct mlx
  			return false;
  	}
  
++<<<<<<< HEAD
 +	tunnel_moffset = mlx5e_tc_attr_to_reg_mappings[TUNNEL_TO_REG].moffset;
 +	tunnel_id = reg_c1 >> (8 * tunnel_moffset);
++=======
+ 	tunnel_id = reg_c1 >> ESW_TUN_OFFSET;
++>>>>>>> 48d216e5596a (net/mlx5e: Refactor reg_c1 usage)
  	return mlx5e_restore_tunnel(priv, skb, tc_priv, tunnel_id);
  #endif /* CONFIG_NET_TC_SKB_EXT */
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
index 54b6bf93a330,69e618d17071..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
@@@ -76,9 -78,15 +76,21 @@@ struct mlx5_ct_attr 
  				 misc_parameters_2.metadata_reg_c_1) + 3,\
  }
  
++<<<<<<< HEAD
 +#define REG_MAPPING_MLEN(reg) (mlx5e_tc_attr_to_reg_mappings[reg].mlen)
 +#define ZONE_RESTORE_BITS (REG_MAPPING_MLEN(ZONE_RESTORE_TO_REG) * 8)
 +#define ZONE_RESTORE_MAX GENMASK(ZONE_RESTORE_BITS - 1, 0)
++=======
+ #define nic_zone_restore_to_reg_ct {\
+ 	.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_B,\
+ 	.moffset = 2,\
+ 	.mlen = (ESW_ZONE_ID_BITS / 8),\
+ }
+ 
+ #define REG_MAPPING_MLEN(reg) (mlx5e_tc_attr_to_reg_mappings[reg].mlen)
+ #define REG_MAPPING_MOFFSET(reg) (mlx5e_tc_attr_to_reg_mappings[reg].moffset)
+ #define REG_MAPPING_SHIFT(reg) (REG_MAPPING_MOFFSET(reg) * 8)
++>>>>>>> 48d216e5596a (net/mlx5e: Refactor reg_c1 usage)
  
  #if IS_ENABLED(CONFIG_MLX5_TC_CT)
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 00c2a6fd4471,90db5a99879d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -5398,6 -5647,13 +5398,16 @@@ bool mlx5e_tc_update_skb(struct mlx5_cq
  			return false;
  
  		tc_skb_ext->chain = chain;
++<<<<<<< HEAD
++=======
+ 
+ 		zone_restore_id = (reg_b >> REG_MAPPING_SHIFT(NIC_ZONE_RESTORE_TO_REG)) &
+ 			ESW_ZONE_ID_MASK;
+ 
+ 		if (!mlx5e_tc_ct_restore_flow(tc->ct, skb,
+ 					      zone_restore_id))
+ 			return false;
++>>>>>>> 48d216e5596a (net/mlx5e: Refactor reg_c1 usage)
  	}
  #endif /* CONFIG_NET_TC_SKB_EXT */
  
diff --cc include/linux/mlx5/eswitch.h
index b0ae8020f13e,3b20e84049c1..000000000000
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@@ -96,10 -96,31 +96,35 @@@ static inline u32 mlx5_eswitch_get_vpor
  
  u32 mlx5_eswitch_get_vport_metadata_for_match(struct mlx5_eswitch *esw,
  					      u16 vport_num);
++<<<<<<< HEAD
 +u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw);
++=======
+ u32 mlx5_eswitch_get_vport_metadata_for_set(struct mlx5_eswitch *esw,
+ 					    u16 vport_num);
+ 
+ /* Reg C1 usage:
+  * Reg C1 = < ESW_TUN_ID(12) | ESW_TUN_OPTS(12) | ESW_ZONE_ID(8) >
+  *
+  * Highest 12 bits of reg c1 is the encapsulation tunnel id, next 12 bits is
+  * encapsulation tunnel options, and the lowest 8 bits are used for zone id.
+  *
+  * Zone id is used to restore CT flow when packet misses on chain.
+  *
+  * Tunnel id and options are used together to restore the tunnel info metadata
+  * on miss and to support inner header rewrite by means of implicit chain 0
+  * flows.
+  */
+ #define ESW_ZONE_ID_BITS 8
+ #define ESW_TUN_OPTS_BITS 12
+ #define ESW_TUN_ID_BITS 12
+ #define ESW_TUN_OFFSET ESW_ZONE_ID_BITS
+ #define ESW_ZONE_ID_MASK GENMASK(ESW_ZONE_ID_BITS - 1, 0)
+ 
+ u8 mlx5_eswitch_mode(struct mlx5_core_dev *dev);
++>>>>>>> 48d216e5596a (net/mlx5e: Refactor reg_c1 usage)
  #else  /* CONFIG_MLX5_ESWITCH */
  
 -static inline u8 mlx5_eswitch_mode(struct mlx5_core_dev *dev)
 +static inline u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw)
  {
  	return MLX5_ESWITCH_NONE;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 00b8693ad3dc..35a45be09fef 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -271,7 +271,7 @@ static inline bool mlx5e_cqe_regb_chain(struct mlx5_cqe64 *cqe)
 
 	reg_b = be32_to_cpu(cqe->ft_metadata);
 
-	if (reg_b >> (MLX5E_TC_TABLE_CHAIN_TAG_BITS + ZONE_RESTORE_BITS))
+	if (reg_b >> (MLX5E_TC_TABLE_CHAIN_TAG_BITS + ESW_ZONE_ID_BITS))
 		return false;
 
 	chain = reg_b & MLX5E_TC_TABLE_CHAIN_TAG_MASK;
* Unmerged path include/linux/mlx5/eswitch.h
