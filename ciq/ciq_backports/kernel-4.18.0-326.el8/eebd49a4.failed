xfrm: remove the fragment check for ipv6 beet mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Xin Long <lucien.xin@gmail.com>
commit eebd49a4ffb420a991c606e54aa3c9f02857a334
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/eebd49a4.failed

In commit 68dc022d04eb ("xfrm: BEET mode doesn't support fragments
for inner packets"), it tried to fix the issue that in TX side the
packet is fragmented before the ESP encapping while in the RX side
the fragments always get reassembled before decapping with ESP.

This is not true for IPv6. IPv6 is different, and it's using exthdr
to save fragment info, as well as the ESP info. Exthdrs are added
in TX and processed in RX both in order. So in the above case, the
ESP decapping will be done earlier than the fragment reassembling
in TX side.

Here just remove the fragment check for the IPv6 inner packets to
recover the fragments support for BEET mode.

Fixes: 68dc022d04eb ("xfrm: BEET mode doesn't support fragments for inner packets")
	Reported-by: Xiumei Mu <xmu@redhat.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit eebd49a4ffb420a991c606e54aa3c9f02857a334)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_output.c
diff --cc net/xfrm/xfrm_output.c
index d9edce1e45bb,ac907b9d32d1..000000000000
--- a/net/xfrm/xfrm_output.c
+++ b/net/xfrm/xfrm_output.c
@@@ -621,11 -629,107 +621,112 @@@ out
  }
  EXPORT_SYMBOL_GPL(xfrm_output);
  
++<<<<<<< HEAD
++=======
+ static int xfrm4_tunnel_check_size(struct sk_buff *skb)
+ {
+ 	int mtu, ret = 0;
+ 
+ 	if (IPCB(skb)->flags & IPSKB_XFRM_TUNNEL_SIZE)
+ 		goto out;
+ 
+ 	if (!(ip_hdr(skb)->frag_off & htons(IP_DF)) || skb->ignore_df)
+ 		goto out;
+ 
+ 	mtu = dst_mtu(skb_dst(skb));
+ 	if ((!skb_is_gso(skb) && skb->len > mtu) ||
+ 	    (skb_is_gso(skb) &&
+ 	     !skb_gso_validate_network_len(skb, ip_skb_dst_mtu(skb->sk, skb)))) {
+ 		skb->protocol = htons(ETH_P_IP);
+ 
+ 		if (skb->sk)
+ 			xfrm_local_error(skb, mtu);
+ 		else
+ 			icmp_send(skb, ICMP_DEST_UNREACH,
+ 				  ICMP_FRAG_NEEDED, htonl(mtu));
+ 		ret = -EMSGSIZE;
+ 	}
+ out:
+ 	return ret;
+ }
+ 
+ static int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb)
+ {
+ 	int err;
+ 
+ 	if (x->outer_mode.encap == XFRM_MODE_BEET &&
+ 	    ip_is_fragment(ip_hdr(skb))) {
+ 		net_warn_ratelimited("BEET mode doesn't support inner IPv4 fragments\n");
+ 		return -EAFNOSUPPORT;
+ 	}
+ 
+ 	err = xfrm4_tunnel_check_size(skb);
+ 	if (err)
+ 		return err;
+ 
+ 	XFRM_MODE_SKB_CB(skb)->protocol = ip_hdr(skb)->protocol;
+ 
+ 	xfrm4_extract_header(skb);
+ 	return 0;
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static int xfrm6_tunnel_check_size(struct sk_buff *skb)
+ {
+ 	int mtu, ret = 0;
+ 	struct dst_entry *dst = skb_dst(skb);
+ 
+ 	if (skb->ignore_df)
+ 		goto out;
+ 
+ 	mtu = dst_mtu(dst);
+ 	if (mtu < IPV6_MIN_MTU)
+ 		mtu = IPV6_MIN_MTU;
+ 
+ 	if ((!skb_is_gso(skb) && skb->len > mtu) ||
+ 	    (skb_is_gso(skb) &&
+ 	     !skb_gso_validate_network_len(skb, ip6_skb_dst_mtu(skb)))) {
+ 		skb->dev = dst->dev;
+ 		skb->protocol = htons(ETH_P_IPV6);
+ 
+ 		if (xfrm6_local_dontfrag(skb->sk))
+ 			ipv6_stub->xfrm6_local_rxpmtu(skb, mtu);
+ 		else if (skb->sk)
+ 			xfrm_local_error(skb, mtu);
+ 		else
+ 			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
+ 		ret = -EMSGSIZE;
+ 	}
+ out:
+ 	return ret;
+ }
+ #endif
+ 
+ static int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	int err;
+ 
+ 	err = xfrm6_tunnel_check_size(skb);
+ 	if (err)
+ 		return err;
+ 
+ 	XFRM_MODE_SKB_CB(skb)->protocol = ipv6_hdr(skb)->nexthdr;
+ 
+ 	xfrm6_extract_header(skb);
+ 	return 0;
+ #else
+ 	WARN_ON_ONCE(1);
+ 	return -EAFNOSUPPORT;
+ #endif
+ }
+ 
++>>>>>>> eebd49a4ffb4 (xfrm: remove the fragment check for ipv6 beet mode)
  static int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb)
  {
 +	const struct xfrm_state_afinfo *afinfo;
  	const struct xfrm_mode *inner_mode;
 +	int err = -EAFNOSUPPORT;
  
  	if (x->sel.family == AF_UNSPEC)
  		inner_mode = xfrm_ip2inner_mode(x,
* Unmerged path net/xfrm/xfrm_output.c
