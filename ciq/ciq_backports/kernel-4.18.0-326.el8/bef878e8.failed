net/mlx5: Add support for devlink reload limit no reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Moshe Shemesh <moshe@mellanox.com>
commit bef878e865ea8a4e08d5b5d4ef56df681ff1d6b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/bef878e8.failed

Add support for devlink reload action fw_activate with reload limit
no_reset which does firmware live patching, updating the firmware image
without reset, no downtime and no configuration lose. The driver checks
if the firmware is capable of handling the pending firmware changes as a
live patch. If it is then it triggers firmware live patching flow.

	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Reviewed-by: Saeed Mahameed <saeedm@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit bef878e865ea8a4e08d5b5d4ef56df681ff1d6b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index d092736f7837,a28f95df2901..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -75,6 -85,51 +75,54 @@@ mlx5_devlink_info_get(struct devlink *d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5_devlink_reload_fw_activate(struct devlink *devlink, struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	u8 reset_level, reset_type, net_port_alive;
+ 	int err;
+ 
+ 	err = mlx5_fw_reset_query(dev, &reset_level, &reset_type);
+ 	if (err)
+ 		return err;
+ 	if (!(reset_level & MLX5_MFRL_REG_RESET_LEVEL3)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "FW activate requires reboot");
+ 		return -EINVAL;
+ 	}
+ 
+ 	net_port_alive = !!(reset_type & MLX5_MFRL_REG_RESET_TYPE_NET_PORT_ALIVE);
+ 	err = mlx5_fw_reset_set_reset_sync(dev, net_port_alive);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = mlx5_fw_reset_wait_reset_done(dev);
+ out:
+ 	if (err)
+ 		NL_SET_ERR_MSG_MOD(extack, "FW activate command failed");
+ 	return err;
+ }
+ 
+ static int mlx5_devlink_trigger_fw_live_patch(struct devlink *devlink,
+ 					      struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	u8 reset_level;
+ 	int err;
+ 
+ 	err = mlx5_fw_reset_query(dev, &reset_level, NULL);
+ 	if (err)
+ 		return err;
+ 	if (!(reset_level & MLX5_MFRL_REG_RESET_LEVEL0)) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "FW upgrade to the stored FW can't be done by FW live patching");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return mlx5_fw_reset_set_live_patch(dev);
+ }
+ 
++>>>>>>> bef878e865ea (net/mlx5: Add support for devlink reload limit no reset)
  static int mlx5_devlink_reload_down(struct devlink *devlink, bool netns_change,
  				    enum devlink_reload_action action,
  				    enum devlink_reload_limit limit,
@@@ -82,13 -137,19 +130,27 @@@
  {
  	struct mlx5_core_dev *dev = devlink_priv(devlink);
  
++<<<<<<< HEAD
 +	if (mlx5_lag_is_active(dev)) {
 +		NL_SET_ERR_MSG_MOD(extack, "reload is unsupported in Lag mode\n");
++=======
+ 	switch (action) {
+ 	case DEVLINK_RELOAD_ACTION_DRIVER_REINIT:
+ 		mlx5_unload_one(dev, false);
+ 		return 0;
+ 	case DEVLINK_RELOAD_ACTION_FW_ACTIVATE:
+ 		if (limit == DEVLINK_RELOAD_LIMIT_NO_RESET)
+ 			return mlx5_devlink_trigger_fw_live_patch(devlink, extack);
+ 		return mlx5_devlink_reload_fw_activate(devlink, extack);
+ 	default:
+ 		/* Unsupported action should not get to this function */
+ 		WARN_ON(1);
++>>>>>>> bef878e865ea (net/mlx5: Add support for devlink reload limit no reset)
  		return -EOPNOTSUPP;
  	}
 +
 +	mlx5_unload_one(dev, false);
 +	return 0;
  }
  
  static int mlx5_devlink_reload_up(struct devlink *devlink, enum devlink_reload_action action,
@@@ -97,8 -158,23 +159,28 @@@
  {
  	struct mlx5_core_dev *dev = devlink_priv(devlink);
  
++<<<<<<< HEAD
 +	*actions_performed = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);
 +	return mlx5_load_one(dev, false);
++=======
+ 	*actions_performed = BIT(action);
+ 	switch (action) {
+ 	case DEVLINK_RELOAD_ACTION_DRIVER_REINIT:
+ 		return mlx5_load_one(dev, false);
+ 	case DEVLINK_RELOAD_ACTION_FW_ACTIVATE:
+ 		if (limit == DEVLINK_RELOAD_LIMIT_NO_RESET)
+ 			break;
+ 		/* On fw_activate action, also driver is reloaded and reinit performed */
+ 		*actions_performed |= BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);
+ 		return mlx5_load_one(dev, false);
+ 	default:
+ 		/* Unsupported action should not get to this function */
+ 		WARN_ON(1);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
++>>>>>>> bef878e865ea (net/mlx5: Add support for devlink reload limit no reset)
  }
  
  static const struct devlink_ops mlx5_devlink_ops = {
@@@ -114,7 -190,9 +196,13 @@@
  #endif
  	.flash_update = mlx5_devlink_flash_update,
  	.info_get = mlx5_devlink_info_get,
++<<<<<<< HEAD
 +	.reload_actions = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT),
++=======
+ 	.reload_actions = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |
+ 			  BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE),
+ 	.reload_limits = BIT(DEVLINK_RELOAD_LIMIT_NO_RESET),
++>>>>>>> bef878e865ea (net/mlx5: Add support for devlink reload limit no reset)
  	.reload_down = mlx5_devlink_reload_down,
  	.reload_up = mlx5_devlink_reload_up,
  };
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
