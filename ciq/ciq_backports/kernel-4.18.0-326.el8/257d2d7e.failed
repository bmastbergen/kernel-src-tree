ALSA: usb-audio: Don't avoid stopping the stream at disconnection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 257d2d7e9e798305d65825cb82b0a7d1c0511e89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/257d2d7e.failed

In the later patch, we're going to issue the PCM sync_stop calls at
disconnection.  But currently the USB-audio driver can't handle it
because it has a check of shutdown flag for stopping the URBs.  This
is basically superfluous (the stopping URBs are safe at disconnection
state), so let's drop the check.

Fixes: dc5eafe7787c ("ALSA: usb-audio: Support PCM sync_stop")
	Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/20210206203052.15606-4-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 257d2d7e9e798305d65825cb82b0a7d1c0511e89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/endpoint.c
diff --cc sound/usb/endpoint.c
index 208ac2aff462,102d53515a76..000000000000
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@@ -631,10 -890,11 +631,18 @@@ static int deactivate_urbs(struct snd_u
  {
  	unsigned int i;
  
++<<<<<<< HEAD
 +	if (!force && atomic_read(&ep->chip->shutdown)) /* to be sure... */
 +		return -EBADFD;
 +
 +	clear_bit(EP_FLAG_RUNNING, &ep->flags);
++=======
+ 	if (!force && atomic_read(&ep->running))
+ 		return -EBUSY;
+ 
+ 	if (!ep_state_update(ep, EP_STATE_RUNNING, EP_STATE_STOPPING))
+ 		return 0;
++>>>>>>> 257d2d7e9e79 (ALSA: usb-audio: Don't avoid stopping the stream at disconnection)
  
  	INIT_LIST_HEAD(&ep->ready_playback_urbs);
  	ep->next_packet_head = 0;
* Unmerged path sound/usb/endpoint.c
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index d682ba2a35f0..b443a8154a96 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -269,10 +269,7 @@ static int snd_usb_pcm_sync_stop(struct snd_pcm_substream *substream)
 {
 	struct snd_usb_substream *subs = substream->runtime->private_data;
 
-	if (!snd_usb_lock_shutdown(subs->stream->chip)) {
-		sync_pending_stops(subs);
-		snd_usb_unlock_shutdown(subs->stream->chip);
-	}
+	sync_pending_stops(subs);
 	return 0;
 }
 
