selftests/bpf: Replace EXPECT_EQ with ASSERT_EQ and refactor verify_results

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Alexander Duyck <alexanderduyck@fb.com>
commit d3813ea14b696053c076123239093822b527f0f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/d3813ea1.failed

There is already logic in test_progs.h for asserting that a value is
expected to be another value. So instead of reinventing it we should just
make use of ASSERT_EQ in tcpbpf_user.c. This will allow for better
debugging and integrates much more closely with the test_progs framework.

In addition we can refactor the code a bit to merge together the two
verify functions and tie them together into a single function. Doing this
helps to clean the code up a bit and makes it more readable as all the
verification is now done in one function.

Lastly we can relocate the verification to the end of the run_test since it
is logically part of the test itself. With this we can drop the need for a
return value from run_test since verification becomes the last step of the
call and then immediately following is the tear down of the test setup.

	Signed-off-by: Alexander Duyck <alexanderduyck@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/160443930408.1086697.16101205859962113000.stgit@localhost.localdomain
(cherry picked from commit d3813ea14b696053c076123239093822b527f0f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_tcpbpf_user.c
diff --cc tools/testing/selftests/bpf/test_tcpbpf_user.c
index 74a9e49988b6,22c359871af6..000000000000
--- a/tools/testing/selftests/bpf/test_tcpbpf_user.c
+++ b/tools/testing/selftests/bpf/test_tcpbpf_user.c
@@@ -1,108 -1,143 +1,201 @@@
  // SPDX-License-Identifier: GPL-2.0
++<<<<<<< HEAD:tools/testing/selftests/bpf/test_tcpbpf_user.c
 +#include <inttypes.h>
 +#include <stdio.h>
 +#include <stdlib.h>
 +#include <unistd.h>
 +#include <errno.h>
 +#include <string.h>
 +#include <linux/bpf.h>
 +#include <sys/types.h>
 +#include <bpf/bpf.h>
 +#include <bpf/libbpf.h>
 +
 +#include "bpf_rlimit.h"
 +#include "bpf_util.h"
 +#include "cgroup_helpers.h"
++=======
+ #include <test_progs.h>
+ #include <network_helpers.h>
++>>>>>>> d3813ea14b69 (selftests/bpf: Replace EXPECT_EQ with ASSERT_EQ and refactor verify_results):tools/testing/selftests/bpf/prog_tests/tcpbpf_user.c
  
  #include "test_tcpbpf.h"
  
 -#define LO_ADDR6 "::1"
 -#define CG_NAME "/tcpbpf-user-test"
 -
 -static __u32 duration;
 +/* 3 comes from one listening socket + both ends of the connection */
 +#define EXPECTED_CLOSE_EVENTS		3
  
- #define EXPECT_EQ(expected, actual, fmt)			\
- 	do {							\
- 		if ((expected) != (actual)) {			\
- 			printf("  Value of: " #actual "\n"	\
- 			       "    Actual: %" fmt "\n"		\
- 			       "  Expected: %" fmt "\n",	\
- 			       (actual), (expected));		\
- 			ret--;					\
- 		}						\
- 	} while (0)
- 
- int verify_result(const struct tcpbpf_globals *result)
+ static void verify_result(int map_fd, int sock_map_fd)
  {
- 	__u32 expected_events;
- 	int ret = 0;
+ 	__u32 expected_events = ((1 << BPF_SOCK_OPS_TIMEOUT_INIT) |
+ 				 (1 << BPF_SOCK_OPS_RWND_INIT) |
+ 				 (1 << BPF_SOCK_OPS_TCP_CONNECT_CB) |
+ 				 (1 << BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB) |
+ 				 (1 << BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB) |
+ 				 (1 << BPF_SOCK_OPS_NEEDS_ECN) |
+ 				 (1 << BPF_SOCK_OPS_STATE_CB) |
+ 				 (1 << BPF_SOCK_OPS_TCP_LISTEN_CB));
+ 	struct tcpbpf_globals result;
+ 	__u32 key = 0;
+ 	int res, rv;
  
- 	expected_events = ((1 << BPF_SOCK_OPS_TIMEOUT_INIT) |
- 			   (1 << BPF_SOCK_OPS_RWND_INIT) |
- 			   (1 << BPF_SOCK_OPS_TCP_CONNECT_CB) |
- 			   (1 << BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB) |
- 			   (1 << BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB) |
- 			   (1 << BPF_SOCK_OPS_NEEDS_ECN) |
- 			   (1 << BPF_SOCK_OPS_STATE_CB) |
- 			   (1 << BPF_SOCK_OPS_TCP_LISTEN_CB));
+ 	rv = bpf_map_lookup_elem(map_fd, &key, &result);
+ 	if (CHECK(rv, "bpf_map_lookup_elem(map_fd)", "err:%d errno:%d",
+ 		  rv, errno))
+ 		return;
  
++<<<<<<< HEAD:tools/testing/selftests/bpf/test_tcpbpf_user.c
 +	EXPECT_EQ(expected_events, result->event_map, "#" PRIx32);
 +	EXPECT_EQ(501ULL, result->bytes_received, "llu");
 +	EXPECT_EQ(1002ULL, result->bytes_acked, "llu");
 +	EXPECT_EQ(1, result->data_segs_in, PRIu32);
 +	EXPECT_EQ(1, result->data_segs_out, PRIu32);
 +	EXPECT_EQ(0x80, result->bad_cb_test_rv, PRIu32);
 +	EXPECT_EQ(0, result->good_cb_test_rv, PRIu32);
 +	EXPECT_EQ(1, result->num_listen, PRIu32);
 +	EXPECT_EQ(EXPECTED_CLOSE_EVENTS, result->num_close_events, PRIu32);
 +
 +	return ret;
 +}
 +
 +int verify_sockopt_result(int sock_map_fd)
 +{
 +	__u32 key = 0;
 +	int ret = 0;
 +	int res;
 +	int rv;
++=======
+ 	/* check global map */
+ 	CHECK(expected_events != result.event_map, "event_map",
+ 	      "unexpected event_map: actual 0x%08x != expected 0x%08x\n",
+ 	      result.event_map, expected_events);
+ 
+ 	ASSERT_EQ(result.bytes_received, 501, "bytes_received");
+ 	ASSERT_EQ(result.bytes_acked, 1002, "bytes_acked");
+ 	ASSERT_EQ(result.data_segs_in, 1, "data_segs_in");
+ 	ASSERT_EQ(result.data_segs_out, 1, "data_segs_out");
+ 	ASSERT_EQ(result.bad_cb_test_rv, 0x80, "bad_cb_test_rv");
+ 	ASSERT_EQ(result.good_cb_test_rv, 0, "good_cb_test_rv");
+ 	ASSERT_EQ(result.num_listen, 1, "num_listen");
+ 
+ 	/* 3 comes from one listening socket + both ends of the connection */
+ 	ASSERT_EQ(result.num_close_events, 3, "num_close_events");
++>>>>>>> d3813ea14b69 (selftests/bpf: Replace EXPECT_EQ with ASSERT_EQ and refactor verify_results):tools/testing/selftests/bpf/prog_tests/tcpbpf_user.c
  
  	/* check setsockopt for SAVE_SYN */
  	rv = bpf_map_lookup_elem(sock_map_fd, &key, &res);
- 	EXPECT_EQ(0, rv, "d");
- 	EXPECT_EQ(0, res, "d");
- 	key = 1;
+ 	CHECK(rv, "bpf_map_lookup_elem(sock_map_fd)", "err:%d errno:%d",
+ 	      rv, errno);
+ 	ASSERT_EQ(res, 0, "bpf_setsockopt(TCP_SAVE_SYN)");
+ 
  	/* check getsockopt for SAVED_SYN */
+ 	key = 1;
  	rv = bpf_map_lookup_elem(sock_map_fd, &key, &res);
- 	EXPECT_EQ(0, rv, "d");
- 	EXPECT_EQ(1, res, "d");
- 	return ret;
+ 	CHECK(rv, "bpf_map_lookup_elem(sock_map_fd)", "err:%d errno:%d",
+ 	      rv, errno);
+ 	ASSERT_EQ(res, 1, "bpf_getsockopt(TCP_SAVED_SYN)");
  }
  
++<<<<<<< HEAD:tools/testing/selftests/bpf/test_tcpbpf_user.c
 +static int bpf_find_map(const char *test, struct bpf_object *obj,
 +			const char *name)
++=======
+ static void run_test(int map_fd, int sock_map_fd)
++>>>>>>> d3813ea14b69 (selftests/bpf: Replace EXPECT_EQ with ASSERT_EQ and refactor verify_results):tools/testing/selftests/bpf/prog_tests/tcpbpf_user.c
  {
 -	int listen_fd = -1, cli_fd = -1, accept_fd = -1;
 -	char buf[1000];
 -	int err = -1;
 -	int i, rv;
 +	struct bpf_map *map;
  
++<<<<<<< HEAD:tools/testing/selftests/bpf/test_tcpbpf_user.c
 +	map = bpf_object__find_map_by_name(obj, name);
 +	if (!map) {
 +		printf("%s:FAIL:map '%s' not found\n", test, name);
 +		return -1;
 +	}
 +	return bpf_map__fd(map);
++=======
+ 	listen_fd = start_server(AF_INET6, SOCK_STREAM, LO_ADDR6, 0, 0);
+ 	if (CHECK(listen_fd == -1, "start_server", "listen_fd:%d errno:%d\n",
+ 		  listen_fd, errno))
+ 		goto done;
+ 
+ 	cli_fd = connect_to_fd(listen_fd, 0);
+ 	if (CHECK(cli_fd == -1, "connect_to_fd(listen_fd)",
+ 		  "cli_fd:%d errno:%d\n", cli_fd, errno))
+ 		goto done;
+ 
+ 	accept_fd = accept(listen_fd, NULL, NULL);
+ 	if (CHECK(accept_fd == -1, "accept(listen_fd)",
+ 		  "accept_fd:%d errno:%d\n", accept_fd, errno))
+ 		goto done;
+ 
+ 	/* Send 1000B of '+'s from cli_fd -> accept_fd */
+ 	for (i = 0; i < 1000; i++)
+ 		buf[i] = '+';
+ 
+ 	rv = send(cli_fd, buf, 1000, 0);
+ 	if (CHECK(rv != 1000, "send(cli_fd)", "rv:%d errno:%d\n", rv, errno))
+ 		goto done;
+ 
+ 	rv = recv(accept_fd, buf, 1000, 0);
+ 	if (CHECK(rv != 1000, "recv(accept_fd)", "rv:%d errno:%d\n", rv, errno))
+ 		goto done;
+ 
+ 	/* Send 500B of '.'s from accept_fd ->cli_fd */
+ 	for (i = 0; i < 500; i++)
+ 		buf[i] = '.';
+ 
+ 	rv = send(accept_fd, buf, 500, 0);
+ 	if (CHECK(rv != 500, "send(accept_fd)", "rv:%d errno:%d\n", rv, errno))
+ 		goto done;
+ 
+ 	rv = recv(cli_fd, buf, 500, 0);
+ 	if (CHECK(rv != 500, "recv(cli_fd)", "rv:%d errno:%d\n", rv, errno))
+ 		goto done;
+ 
+ 	/*
+ 	 * shutdown accept first to guarantee correct ordering for
+ 	 * bytes_received and bytes_acked when we go to verify the results.
+ 	 */
+ 	shutdown(accept_fd, SHUT_WR);
+ 	err = recv(cli_fd, buf, 1, 0);
+ 	if (CHECK(err, "recv(cli_fd) for fin", "err:%d errno:%d\n", err, errno))
+ 		goto done;
+ 
+ 	shutdown(cli_fd, SHUT_WR);
+ 	err = recv(accept_fd, buf, 1, 0);
+ 	CHECK(err, "recv(accept_fd) for fin", "err:%d errno:%d\n", err, errno);
+ done:
+ 	if (accept_fd != -1)
+ 		close(accept_fd);
+ 	if (cli_fd != -1)
+ 		close(cli_fd);
+ 	if (listen_fd != -1)
+ 		close(listen_fd);
+ 
+ 	if (!err)
+ 		verify_result(map_fd, sock_map_fd);
++>>>>>>> d3813ea14b69 (selftests/bpf: Replace EXPECT_EQ with ASSERT_EQ and refactor verify_results):tools/testing/selftests/bpf/prog_tests/tcpbpf_user.c
  }
  
 -void test_tcpbpf_user(void)
 +int main(int argc, char **argv)
  {
  	const char *file = "test_tcpbpf_kern.o";
  	int prog_fd, map_fd, sock_map_fd;
++<<<<<<< HEAD:tools/testing/selftests/bpf/test_tcpbpf_user.c
 +	struct tcpbpf_globals g = {0};
 +	const char *cg_path = "/foo";
  	int error = EXIT_FAILURE;
  	struct bpf_object *obj;
  	int cg_fd = -1;
 +	int retry = 10;
 +	__u32 key = 0;
++=======
++	int error = EXIT_FAILURE;
++	struct bpf_object *obj;
++	int cg_fd = -1;
++>>>>>>> d3813ea14b69 (selftests/bpf: Replace EXPECT_EQ with ASSERT_EQ and refactor verify_results):tools/testing/selftests/bpf/prog_tests/tcpbpf_user.c
  	int rv;
  
 -	cg_fd = test__join_cgroup(CG_NAME);
 +	cg_fd = cgroup_setup_and_join(cg_path);
  	if (cg_fd < 0)
  		goto err;
  
@@@ -131,31 -161,8 +224,35 @@@
  	if (sock_map_fd < 0)
  		goto err;
  
++<<<<<<< HEAD:tools/testing/selftests/bpf/test_tcpbpf_user.c
 +retry_lookup:
 +	rv = bpf_map_lookup_elem(map_fd, &key, &g);
 +	if (rv != 0) {
 +		printf("FAILED: bpf_map_lookup_elem returns %d\n", rv);
 +		goto err;
 +	}
 +
 +	if (g.num_close_events != EXPECTED_CLOSE_EVENTS && retry--) {
 +		printf("Unexpected number of close events (%d), retrying!\n",
 +		       g.num_close_events);
 +		usleep(100);
 +		goto retry_lookup;
 +	}
 +
 +	if (verify_result(&g)) {
 +		printf("FAILED: Wrong stats\n");
 +		goto err;
 +	}
 +
 +	if (verify_sockopt_result(sock_map_fd)) {
 +		printf("FAILED: Wrong sockopt stats\n");
 +		goto err;
 +	}
++=======
+ 	run_test(map_fd, sock_map_fd);
++>>>>>>> d3813ea14b69 (selftests/bpf: Replace EXPECT_EQ with ASSERT_EQ and refactor verify_results):tools/testing/selftests/bpf/prog_tests/tcpbpf_user.c
  
 +	printf("PASSED!\n");
  	error = 0;
  err:
  	bpf_prog_detach(cg_fd, BPF_CGROUP_SOCK_OPS);
* Unmerged path tools/testing/selftests/bpf/test_tcpbpf_user.c
