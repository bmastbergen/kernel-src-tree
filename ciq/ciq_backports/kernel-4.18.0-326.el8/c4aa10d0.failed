xfs: make the btree ag cursor private union anonymous

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Dave Chinner <dchinner@redhat.com>
commit c4aa10d041968f55f00fe8ca768b6f45f4066a69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/c4aa10d0.failed

This is much less widely used than the bc_private union was, so this
is done as a single patch. The named union xfs_btree_cur_private
goes away and is embedded into the struct xfs_btree_cur_ag as an
anonymous union, and the code is modified via this script:

$ sed -i 's/priv\.\([abt|refc]\)/\1/g' fs/xfs/*[ch] fs/xfs/*/*[ch]

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit c4aa10d041968f55f00fe8ca768b6f45f4066a69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc.c
#	fs/xfs/libxfs/xfs_alloc_btree.c
#	fs/xfs/libxfs/xfs_btree.h
#	fs/xfs/libxfs/xfs_refcount.c
#	fs/xfs/libxfs/xfs_refcount_btree.c
diff --cc fs/xfs/libxfs/xfs_alloc.c
index 87dbbf764135,337822115bbc..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -151,7 -151,7 +151,11 @@@ xfs_alloc_lookup_eq
  	cur->bc_rec.a.ar_startblock = bno;
  	cur->bc_rec.a.ar_blockcount = len;
  	error = xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);
++<<<<<<< HEAD
 +	cur->bc_private.a.priv.abt.active = (*stat == 1);
++=======
+ 	cur->bc_ag.abt.active = (*stat == 1);
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  	return error;
  }
  
@@@ -171,7 -171,7 +175,11 @@@ xfs_alloc_lookup_ge
  	cur->bc_rec.a.ar_startblock = bno;
  	cur->bc_rec.a.ar_blockcount = len;
  	error = xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);
++<<<<<<< HEAD
 +	cur->bc_private.a.priv.abt.active = (*stat == 1);
++=======
+ 	cur->bc_ag.abt.active = (*stat == 1);
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  	return error;
  }
  
@@@ -190,7 -190,7 +198,11 @@@ xfs_alloc_lookup_le
  	cur->bc_rec.a.ar_startblock = bno;
  	cur->bc_rec.a.ar_blockcount = len;
  	error = xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);
++<<<<<<< HEAD
 +	cur->bc_private.a.priv.abt.active = (*stat == 1);
++=======
+ 	cur->bc_ag.abt.active = (*stat == 1);
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  	return error;
  }
  
@@@ -198,7 -198,7 +210,11 @@@ static inline boo
  xfs_alloc_cur_active(
  	struct xfs_btree_cur	*cur)
  {
++<<<<<<< HEAD
 +	return cur && cur->bc_private.a.priv.abt.active;
++=======
+ 	return cur && cur->bc_ag.abt.active;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  }
  
  /*
@@@ -908,7 -908,7 +924,11 @@@ xfs_alloc_cur_check
  		deactivate = true;
  out:
  	if (deactivate)
++<<<<<<< HEAD
 +		cur->bc_private.a.priv.abt.active = false;
++=======
+ 		cur->bc_ag.abt.active = false;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  	trace_xfs_alloc_cur_check(args->mp, cur->bc_btnum, bno, len, diff,
  				  *new);
  	return 0;
@@@ -1352,7 -1352,7 +1372,11 @@@ xfs_alloc_walk_iter
  		if (error)
  			return error;
  		if (i == 0)
++<<<<<<< HEAD
 +			cur->bc_private.a.priv.abt.active = false;
++=======
+ 			cur->bc_ag.abt.active = false;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  
  		if (count > 0)
  			count--;
@@@ -1467,7 -1467,7 +1491,11 @@@ xfs_alloc_ag_vextent_locality
  		if (error)
  			return error;
  		if (i) {
++<<<<<<< HEAD
 +			acur->cnt->bc_private.a.priv.abt.active = true;
++=======
+ 			acur->cnt->bc_ag.abt.active = true;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  			fbcur = acur->cnt;
  			fbinc = false;
  		}
diff --cc fs/xfs/libxfs/xfs_alloc_btree.c
index 422a822a9957,a28041fdf4c0..000000000000
--- a/fs/xfs/libxfs/xfs_alloc_btree.c
+++ b/fs/xfs/libxfs/xfs_alloc_btree.c
@@@ -507,9 -505,9 +507,15 @@@ xfs_allocbt_init_cursor
  		cur->bc_nlevels = be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]);
  	}
  
++<<<<<<< HEAD
 +	cur->bc_private.a.agbp = agbp;
 +	cur->bc_private.a.agno = agno;
 +	cur->bc_private.a.priv.abt.active = false;
++=======
+ 	cur->bc_ag.agbp = agbp;
+ 	cur->bc_ag.agno = agno;
+ 	cur->bc_ag.abt.active = false;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  
  	if (xfs_sb_version_hascrc(&mp->m_sb))
  		cur->bc_flags |= XFS_BTREE_CRC_BLOCKS;
diff --cc fs/xfs/libxfs/xfs_btree.h
index 4a1c98bdfaad,133b858bf096..000000000000
--- a/fs/xfs/libxfs/xfs_btree.h
+++ b/fs/xfs/libxfs/xfs_btree.h
@@@ -177,15 -177,33 +177,45 @@@ union xfs_btree_irec 
  	struct xfs_refcount_irec	rc;
  };
  
++<<<<<<< HEAD
 +/* Per-AG btree private information. */
 +union xfs_btree_cur_private {
 +	struct {
 +		unsigned long	nr_ops;		/* # record updates */
 +		int		shape_changes;	/* # of extent splits */
 +	} refc;
 +	struct {
 +		bool		active;		/* allocation cursor state */
 +	} abt;
++=======
+ /* Per-AG btree information. */
+ struct xfs_btree_cur_ag {
+ 	struct xfs_buf		*agbp;
+ 	xfs_agnumber_t		agno;
+ 	union {
+ 		struct {
+ 			unsigned long nr_ops;	/* # record updates */
+ 			int	shape_changes;	/* # of extent splits */
+ 		} refc;
+ 		struct {
+ 			bool	active;		/* allocation cursor state */
+ 		} abt;
+ 	};
+ };
+ 
+ /* Btree-in-inode cursor information */
+ struct xfs_btree_cur_ino {
+ 	struct xfs_inode		*ip;
+ 	int				allocated;
+ 	short				forksize;
+ 	char				whichfork;
+ 	char				flags;
+ /* We are converting a delalloc reservation */
+ #define	XFS_BTCUR_BMBT_WASDEL		(1 << 0)
+ 
+ /* For extent swap, ignore owner check in verifier */
+ #define	XFS_BTCUR_BMBT_INVALID_OWNER	(1 << 1)
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  };
  
  /*
diff --cc fs/xfs/libxfs/xfs_refcount.c
index 6e1665f2cb67,2076627243b0..000000000000
--- a/fs/xfs/libxfs/xfs_refcount.c
+++ b/fs/xfs/libxfs/xfs_refcount.c
@@@ -883,7 -883,7 +883,11 @@@ xfs_refcount_still_have_space
  {
  	unsigned long			overhead;
  
++<<<<<<< HEAD
 +	overhead = cur->bc_private.a.priv.refc.shape_changes *
++=======
+ 	overhead = cur->bc_ag.refc.shape_changes *
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  			xfs_allocfree_log_count(cur->bc_mp, 1);
  	overhead *= cur->bc_mp->m_sb.sb_blocksize;
  
@@@ -891,17 -891,17 +895,29 @@@
  	 * Only allow 2 refcount extent updates per transaction if the
  	 * refcount continue update "error" has been injected.
  	 */
++<<<<<<< HEAD
 +	if (cur->bc_private.a.priv.refc.nr_ops > 2 &&
++=======
+ 	if (cur->bc_ag.refc.nr_ops > 2 &&
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  	    XFS_TEST_ERROR(false, cur->bc_mp,
  			XFS_ERRTAG_REFCOUNT_CONTINUE_UPDATE))
  		return false;
  
++<<<<<<< HEAD
 +	if (cur->bc_private.a.priv.refc.nr_ops == 0)
++=======
+ 	if (cur->bc_ag.refc.nr_ops == 0)
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  		return true;
  	else if (overhead > cur->bc_tp->t_log_res)
  		return false;
  	return  cur->bc_tp->t_log_res - overhead >
++<<<<<<< HEAD
 +		cur->bc_private.a.priv.refc.nr_ops * XFS_REFCOUNT_ITEM_OVERHEAD;
++=======
+ 		cur->bc_ag.refc.nr_ops * XFS_REFCOUNT_ITEM_OVERHEAD;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  }
  
  /*
@@@ -968,10 -968,10 +984,14 @@@ xfs_refcount_adjust_extents
  					error = -EFSCORRUPTED;
  					goto out_error;
  				}
++<<<<<<< HEAD
 +				cur->bc_private.a.priv.refc.nr_ops++;
++=======
+ 				cur->bc_ag.refc.nr_ops++;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  			} else {
  				fsbno = XFS_AGB_TO_FSB(cur->bc_mp,
 -						cur->bc_ag.agno,
 +						cur->bc_private.a.agno,
  						tmp.rc_startblock);
  				xfs_bmap_add_free(cur->bc_tp, fsbno,
  						  tmp.rc_blockcount, oinfo);
@@@ -1003,7 -1003,7 +1023,11 @@@
  			error = xfs_refcount_update(cur, &ext);
  			if (error)
  				goto out_error;
++<<<<<<< HEAD
 +			cur->bc_private.a.priv.refc.nr_ops++;
++=======
+ 			cur->bc_ag.refc.nr_ops++;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  		} else if (ext.rc_refcount == 1) {
  			error = xfs_refcount_delete(cur, &found_rec);
  			if (error)
@@@ -1012,7 -1012,7 +1036,11 @@@
  				error = -EFSCORRUPTED;
  				goto out_error;
  			}
++<<<<<<< HEAD
 +			cur->bc_private.a.priv.refc.nr_ops++;
++=======
+ 			cur->bc_ag.refc.nr_ops++;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  			goto advloop;
  		} else {
  			fsbno = XFS_AGB_TO_FSB(cur->bc_mp,
@@@ -1088,7 -1088,7 +1116,11 @@@ xfs_refcount_adjust
  	if (shape_changed)
  		shape_changes++;
  	if (shape_changes)
++<<<<<<< HEAD
 +		cur->bc_private.a.priv.refc.shape_changes++;
++=======
+ 		cur->bc_ag.refc.shape_changes++;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  
  	/* Now that we've taken care of the ends, adjust the middle extents */
  	error = xfs_refcount_adjust_extents(cur, new_agbno, new_aglen,
@@@ -1165,9 -1165,9 +1197,15 @@@ xfs_refcount_finish_one
  	 * the startblock, get one now.
  	 */
  	rcur = *pcur;
++<<<<<<< HEAD
 +	if (rcur != NULL && rcur->bc_private.a.agno != agno) {
 +		nr_ops = rcur->bc_private.a.priv.refc.nr_ops;
 +		shape_changes = rcur->bc_private.a.priv.refc.shape_changes;
++=======
+ 	if (rcur != NULL && rcur->bc_ag.agno != agno) {
+ 		nr_ops = rcur->bc_ag.refc.nr_ops;
+ 		shape_changes = rcur->bc_ag.refc.shape_changes;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  		xfs_refcount_finish_one_cleanup(tp, rcur, 0);
  		rcur = NULL;
  		*pcur = NULL;
@@@ -1183,8 -1183,8 +1221,13 @@@
  			error = -ENOMEM;
  			goto out_cur;
  		}
++<<<<<<< HEAD
 +		rcur->bc_private.a.priv.refc.nr_ops = nr_ops;
 +		rcur->bc_private.a.priv.refc.shape_changes = shape_changes;
++=======
+ 		rcur->bc_ag.refc.nr_ops = nr_ops;
+ 		rcur->bc_ag.refc.shape_changes = shape_changes;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  	}
  	*pcur = rcur;
  
diff --cc fs/xfs/libxfs/xfs_refcount_btree.c
index a76997740e45,e07a2c45f8ec..000000000000
--- a/fs/xfs/libxfs/xfs_refcount_btree.c
+++ b/fs/xfs/libxfs/xfs_refcount_btree.c
@@@ -336,12 -336,12 +336,17 @@@ xfs_refcountbt_init_cursor
  
  	cur->bc_nlevels = be32_to_cpu(agf->agf_refcount_level);
  
 -	cur->bc_ag.agbp = agbp;
 -	cur->bc_ag.agno = agno;
 +	cur->bc_private.a.agbp = agbp;
 +	cur->bc_private.a.agno = agno;
  	cur->bc_flags |= XFS_BTREE_CRC_BLOCKS;
  
++<<<<<<< HEAD
 +	cur->bc_private.a.priv.refc.nr_ops = 0;
 +	cur->bc_private.a.priv.refc.shape_changes = 0;
++=======
+ 	cur->bc_ag.refc.nr_ops = 0;
+ 	cur->bc_ag.refc.shape_changes = 0;
++>>>>>>> c4aa10d04196 (xfs: make the btree ag cursor private union anonymous)
  
  	return cur;
  }
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
* Unmerged path fs/xfs/libxfs/xfs_alloc_btree.c
* Unmerged path fs/xfs/libxfs/xfs_btree.h
* Unmerged path fs/xfs/libxfs/xfs_refcount.c
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
