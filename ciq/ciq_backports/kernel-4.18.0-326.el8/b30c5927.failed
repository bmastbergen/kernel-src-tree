mm/memory_hotplug: mark pageblocks MIGRATE_ISOLATE while onlining memory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author David Hildenbrand <david@redhat.com>
commit b30c59279d6891bbd583aed2e1f0cd2a73ab475a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/b30c5927.failed

Currently, it can happen that pages are allocated (and freed) via the
buddy before we finished basic memory onlining.

For example, pages are exposed to the buddy and can be allocated before we
actually mark the sections online.  Allocated pages could suddenly fail
pfn_to_online_page() checks.  We had similar issues with pcp handling,
when pages are allocated+freed before we reach zone_pcp_update() in
online_pages() [1].

Instead, mark all pageblocks MIGRATE_ISOLATE, such that allocations are
impossible.  Once done with the heavy lifting, use
undo_isolate_page_range() to move the pages to the MIGRATE_MOVABLE
freelist, marking them ready for allocation.  Similar to offline_pages(),
we have to manually adjust zone->nr_isolate_pageblock.

[1] https://lkml.kernel.org/r/1597150703-19003-1-git-send-email-charante@codeaurora.org

	Signed-off-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Wei Yang <richard.weiyang@linux.alibaba.com>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Pankaj Gupta <pankaj.gupta.linux@gmail.com>
	Cc: Charan Teja Reddy <charante@codeaurora.org>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: Logan Gunthorpe <logang@deltatee.com>
	Cc: "Matthew Wilcox (Oracle)" <willy@infradead.org>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Michel Lespinasse <walken@google.com>
	Cc: Mike Rapoport <rppt@kernel.org>
	Cc: Tony Luck <tony.luck@intel.com>
Link: https://lkml.kernel.org/r/20200819175957.28465-11-david@redhat.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b30c59279d6891bbd583aed2e1f0cd2a73ab475a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory_hotplug.c
diff --cc mm/memory_hotplug.c
index 3f7b739a6e53,1b40eebae3e4..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -775,7 -813,7 +775,11 @@@ int __ref online_pages(unsigned long pf
  
  	/* associate pfn range with the zone */
  	zone = zone_for_pfn_range(online_type, nid, pfn, nr_pages);
++<<<<<<< HEAD
 +	move_pfn_range_to_zone(zone, pfn, nr_pages, NULL);
++=======
+ 	move_pfn_range_to_zone(zone, pfn, nr_pages, NULL, MIGRATE_ISOLATE);
++>>>>>>> b30c59279d68 (mm/memory_hotplug: mark pageblocks MIGRATE_ISOLATE while onlining memory)
  
  	arg.start_pfn = pfn;
  	arg.nr_pages = nr_pages;
diff --git a/mm/Kconfig b/mm/Kconfig
index 5cfa72e3ac8c..a36b98de7428 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -147,6 +147,7 @@ config HAVE_BOOTMEM_INFO_NODE
 # eventually, we can have this option just 'select SPARSEMEM'
 config MEMORY_HOTPLUG
 	bool "Allow for memory hot-add"
+	select MEMORY_ISOLATION
 	depends on SPARSEMEM || X86_64_ACPI_NUMA
 	depends on ARCH_ENABLE_MEMORY_HOTPLUG
 
@@ -172,7 +173,6 @@ config MEMORY_HOTPLUG_DEFAULT_ONLINE
 
 config MEMORY_HOTREMOVE
 	bool "Allow for memory hot remove"
-	select MEMORY_ISOLATION
 	select HAVE_BOOTMEM_INFO_NODE if (X86_64 || PPC64)
 	depends on MEMORY_HOTPLUG && ARCH_ENABLE_MEMORY_HOTREMOVE
 	depends on MIGRATION
* Unmerged path mm/memory_hotplug.c
