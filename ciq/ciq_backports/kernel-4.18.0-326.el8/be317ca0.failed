drm/i915: Sprinkle a few missing locks around shared DDI clock registers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit be317ca0a338ab3976d7c74975458638d0cedf90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/be317ca0.failed

The current code attempts to protect the RMWs into global
clock routing registers with a mutex, but forgets to do so
in a few places. Let's remedy that.

Note that at the moment we serialize all modesets onto single
wq, so this shouldn't actually matter. But maybe one day we
wish to attempt parallel modesets again...

	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210205214634.19341-10-ville.syrjala@linux.intel.com
(cherry picked from commit be317ca0a338ab3976d7c74975458638d0cedf90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 87726ca7041c,a14baea12800..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -2949,100 -1814,195 +2949,177 @@@ void icl_sanitize_encoder_pll_mapping(s
  			if (other_encoder == encoder)
  				continue;
  
 -			if (drm_WARN_ON(&dev_priv->drm,
 -					port_mask & BIT(other_encoder->port)))
 -				return;
 -		}
 -		/*
 -		 * For DSI we keep the ddi clocks gated
 -		 * except during enable/disable sequence.
 -		 */
 -		ddi_clk_needed = false;
 -	}
 -
 -	if (IS_DG1(dev_priv))
 -		dg1_sanitize_port_clk_off(dev_priv, port_mask, ddi_clk_needed);
 -	else
 -		icl_sanitize_port_clk_off(dev_priv, port_mask, ddi_clk_needed);
 -}
 -
 -static void jsl_ddi_tc_enable_clock(struct intel_encoder *encoder,
 -				    const struct intel_crtc_state *crtc_state)
 -{
 -	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
 -	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
 -	enum port port = encoder->port;
 -
 -	if (drm_WARN_ON(&i915->drm, !pll))
 -		return;
 -
 -	/*
 -	 * "For DDIC and DDID, program DDI_CLK_SEL to map the MG clock to the port.
 -	 *  MG does not exist, but the programming is required to ungate DDIC and DDID."
 -	 */
 -	intel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_MG);
 -
 -	icl_ddi_combo_enable_clock(encoder, crtc_state);
 -}
 -
 -static void jsl_ddi_tc_disable_clock(struct intel_encoder *encoder)
 -{
 -	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
 -	enum port port = encoder->port;
 -
 -	icl_ddi_combo_disable_clock(encoder);
 -
 -	intel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_NONE);
 -}
 -
 -static void icl_ddi_tc_enable_clock(struct intel_encoder *encoder,
 -				    const struct intel_crtc_state *crtc_state)
 -{
 -	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
 -	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
 -	enum tc_port tc_port = intel_port_to_tc(i915, encoder->port);
 -	enum port port = encoder->port;
 -
 -	if (drm_WARN_ON(&i915->drm, !pll))
 -		return;
 -
 -	intel_de_write(i915, DDI_CLK_SEL(port),
 -		       icl_pll_to_ddi_clk_sel(encoder, crtc_state));
 -
 -	mutex_lock(&i915->dpll.lock);
 -
 -	intel_de_rmw(i915, ICL_DPCLKA_CFGCR0,
 -		     ICL_DPCLKA_CFGCR0_TC_CLK_OFF(tc_port), 0);
 -
 -	mutex_unlock(&i915->dpll.lock);
 -}
 -
 -static void icl_ddi_tc_disable_clock(struct intel_encoder *encoder)
 -{
 -	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
 -	enum tc_port tc_port = intel_port_to_tc(i915, encoder->port);
 -	enum port port = encoder->port;
 -
 -	mutex_lock(&i915->dpll.lock);
 -
 -	intel_de_rmw(i915, ICL_DPCLKA_CFGCR0,
 -		     0, ICL_DPCLKA_CFGCR0_TC_CLK_OFF(tc_port));
 -
 -	mutex_unlock(&i915->dpll.lock);
 +			if (drm_WARN_ON(&dev_priv->drm,
 +					port_mask & BIT(other_encoder->port)))
 +				return;
 +		}
 +		/*
 +		 * For DSI we keep the ddi clocks gated
 +		 * except during enable/disable sequence.
 +		 */
 +		ddi_clk_needed = false;
 +	}
  
 -	intel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_NONE);
 +	icl_sanitize_port_clk_off(dev_priv, port_mask, ddi_clk_needed);
  }
  
 -static void cnl_ddi_enable_clock(struct intel_encoder *encoder,
 +static void intel_ddi_clk_select(struct intel_encoder *encoder,
  				 const struct intel_crtc_state *crtc_state)
  {
 -	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
 -	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
 +	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
  	enum port port = encoder->port;
 +	enum phy phy = intel_port_to_phy(dev_priv, port);
 +	u32 val;
 +	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
  
 -	if (drm_WARN_ON(&i915->drm, !pll))
 +	if (drm_WARN_ON(&dev_priv->drm, !pll))
  		return;
  
 -	mutex_lock(&i915->dpll.lock);
 +	mutex_lock(&dev_priv->dpll.lock);
  
 -	intel_de_rmw(i915, DPCLKA_CFGCR0,
 -		     DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(port),
 -		     DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, port));
 +	if (INTEL_GEN(dev_priv) >= 11) {
 +		if (!intel_phy_is_combo(dev_priv, phy))
 +			intel_de_write(dev_priv, DDI_CLK_SEL(port),
 +				       icl_pll_to_ddi_clk_sel(encoder, crtc_state));
 +		else if (IS_ELKHARTLAKE(dev_priv) && port >= PORT_C)
 +			/*
 +			 * MG does not exist but the programming is required
 +			 * to ungate DDIC and DDID
 +			 */
 +			intel_de_write(dev_priv, DDI_CLK_SEL(port),
 +				       DDI_CLK_SEL_MG);
 +	} else if (IS_CANNONLAKE(dev_priv)) {
 +		/* Configure DPCLKA_CFGCR0 to map the DPLL to the DDI. */
 +		val = intel_de_read(dev_priv, DPCLKA_CFGCR0);
 +		val &= ~DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(port);
 +		val |= DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, port);
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0, val);
  
 -	/*
 -	 * "This step and the step before must be
 -	 *  done with separate register writes."
 -	 */
 -	intel_de_rmw(i915, DPCLKA_CFGCR0,
 -		     DPCLKA_CFGCR0_DDI_CLK_OFF(port), 0);
 +		/*
 +		 * Configure DPCLKA_CFGCR0 to turn on the clock for the DDI.
 +		 * This step and the step before must be done with separate
 +		 * register writes.
 +		 */
 +		val = intel_de_read(dev_priv, DPCLKA_CFGCR0);
 +		val &= ~DPCLKA_CFGCR0_DDI_CLK_OFF(port);
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0, val);
 +	} else if (IS_GEN9_BC(dev_priv)) {
 +		/* DDI -> PLL mapping  */
 +		val = intel_de_read(dev_priv, DPLL_CTRL2);
  
 -	mutex_unlock(&i915->dpll.lock);
 +		val &= ~(DPLL_CTRL2_DDI_CLK_OFF(port) |
 +			 DPLL_CTRL2_DDI_CLK_SEL_MASK(port));
 +		val |= (DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |
 +			DPLL_CTRL2_DDI_SEL_OVERRIDE(port));
 +
 +		intel_de_write(dev_priv, DPLL_CTRL2, val);
 +
 +	} else if (INTEL_GEN(dev_priv) < 9) {
 +		intel_de_write(dev_priv, PORT_CLK_SEL(port),
 +			       hsw_pll_to_ddi_pll_sel(pll));
 +	}
 +
 +	mutex_unlock(&dev_priv->dpll.lock);
  }
  
 -static void cnl_ddi_disable_clock(struct intel_encoder *encoder)
 +static void intel_ddi_clk_disable(struct intel_encoder *encoder)
  {
 -	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
 +	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
  	enum port port = encoder->port;
 +	enum phy phy = intel_port_to_phy(dev_priv, port);
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) >= 11) {
 +		if (!intel_phy_is_combo(dev_priv, phy) ||
 +		    (IS_ELKHARTLAKE(dev_priv) && port >= PORT_C))
 +			intel_de_write(dev_priv, DDI_CLK_SEL(port),
 +				       DDI_CLK_SEL_NONE);
 +	} else if (IS_CANNONLAKE(dev_priv)) {
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0,
 +			       intel_de_read(dev_priv, DPCLKA_CFGCR0) | DPCLKA_CFGCR0_DDI_CLK_OFF(port));
 +	} else if (IS_GEN9_BC(dev_priv)) {
 +		intel_de_write(dev_priv, DPLL_CTRL2,
 +			       intel_de_read(dev_priv, DPLL_CTRL2) | DPLL_CTRL2_DDI_CLK_OFF(port));
 +	} else if (INTEL_GEN(dev_priv) < 9) {
 +		intel_de_write(dev_priv, PORT_CLK_SEL(port),
 +			       PORT_CLK_SEL_NONE);
 +	}
++=======
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	intel_de_rmw(i915, DPCLKA_CFGCR0,
+ 		     0, DPCLKA_CFGCR0_DDI_CLK_OFF(port));
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void skl_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	intel_de_rmw(i915, DPLL_CTRL2,
+ 		     DPLL_CTRL2_DDI_CLK_OFF(port) |
+ 		     DPLL_CTRL2_DDI_CLK_SEL_MASK(port),
+ 		     DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |
+ 		     DPLL_CTRL2_DDI_SEL_OVERRIDE(port));
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void skl_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	intel_de_rmw(i915, DPLL_CTRL2,
+ 		     0, DPLL_CTRL2_DDI_CLK_OFF(port));
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ void hsw_ddi_enable_clock(struct intel_encoder *encoder,
+ 			  const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	intel_de_write(i915, PORT_CLK_SEL(port), hsw_pll_to_ddi_pll_sel(pll));
+ }
+ 
+ void hsw_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, PORT_CLK_SEL(port), PORT_CLK_SEL_NONE);
+ }
+ 
+ void intel_ddi_enable_clock(struct intel_encoder *encoder,
+ 			    const struct intel_crtc_state *crtc_state)
+ {
+ 	if (encoder->enable_clock)
+ 		encoder->enable_clock(encoder, crtc_state);
+ }
+ 
+ static void intel_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	if (encoder->disable_clock)
+ 		encoder->disable_clock(encoder);
++>>>>>>> be317ca0a338 (drm/i915: Sprinkle a few missing locks around shared DDI clock registers)
  }
  
  static void
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
