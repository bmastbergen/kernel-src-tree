net/mlx5e: TC, Add support to offload sample action

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Chris Mi <cmi@nvidia.com>
commit f94d6389f6a8abd04760dcd015d14961260a8000
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/f94d6389.failed

The following diagram illustrates the hardware model for tc sample action:

        +---------------------+
        + original flow table +
        +---------------------+
        +   original match    +
        +---------------------+
                   |
                   v
+------------------------------------------------+
+                Flow Sampler Object             +
+------------------------------------------------+
+                    sample ratio                +
+------------------------------------------------+
+    sample table id    |    default table id    +
+------------------------------------------------+
           |                            |
           v                            v
+-----------------------------+  +----------------------------------------+
+        sample table         +  + default table per <vport, chain, prio> +
+-----------------------------+  +----------------------------------------+
+ forward to management vport +  +            original match              +
+-----------------------------+  +----------------------------------------+
                                 +            other actions               +
                                 +----------------------------------------+

The sample action is translated to a goto flow table object
destination which samples packets according to the provided
sample ratio. Sampled packets are duplicated. One copy is
processed by a termination table, named the sample table,
which sends the packet to the eswitch manager port (that will
be processed by software).

The second copy is processed by the default table which executes
the subsequent actions. The default table is created per <vport,
chain, prio> tuple as rules with different prios and chains may
overlap.

	Signed-off-by: Chris Mi <cmi@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Reviewed-by: Mark Bloch <mbloch@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit f94d6389f6a8abd04760dcd015d14961260a8000)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c
#	drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 8d4d2686ea65,d157d1b9cad6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -274,9 -200,110 +274,113 @@@ mlx5e_tc_match_to_reg_set(struct mlx5_c
  	MLX5_SET(set_action_in, modact, offset, moffset * 8);
  	MLX5_SET(set_action_in, modact, length, mlen * 8);
  	MLX5_SET(set_action_in, modact, data, data);
 -	err = mod_hdr_acts->num_actions;
  	mod_hdr_acts->num_actions++;
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	return err;
+ }
+ 
+ static struct mlx5_tc_ct_priv *
+ get_ct_priv(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 	struct mlx5_rep_uplink_priv *uplink_priv;
+ 	struct mlx5e_rep_priv *uplink_rpriv;
+ 
+ 	if (is_mdev_switchdev_mode(priv->mdev)) {
+ 		uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
+ 		uplink_priv = &uplink_rpriv->uplink_priv;
+ 
+ 		return uplink_priv->ct_priv;
+ 	}
+ 
+ 	return priv->fs.tc.ct;
+ }
+ 
+ #if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
+ static struct mlx5_esw_psample *
+ get_sample_priv(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 	struct mlx5_rep_uplink_priv *uplink_priv;
+ 	struct mlx5e_rep_priv *uplink_rpriv;
+ 
+ 	if (is_mdev_switchdev_mode(priv->mdev)) {
+ 		uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
+ 		uplink_priv = &uplink_rpriv->uplink_priv;
+ 
+ 		return uplink_priv->esw_psample;
+ 	}
+ 
+ 	return NULL;
+ }
+ #endif
+ 
+ struct mlx5_flow_handle *
+ mlx5_tc_rule_insert(struct mlx5e_priv *priv,
+ 		    struct mlx5_flow_spec *spec,
+ 		    struct mlx5_flow_attr *attr)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 
+ 	if (is_mdev_switchdev_mode(priv->mdev))
+ 		return mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
+ 
+ 	return	mlx5e_add_offloaded_nic_rule(priv, spec, attr);
+ }
+ 
+ void
+ mlx5_tc_rule_delete(struct mlx5e_priv *priv,
+ 		    struct mlx5_flow_handle *rule,
+ 		    struct mlx5_flow_attr *attr)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 
+ 	if (is_mdev_switchdev_mode(priv->mdev)) {
+ 		mlx5_eswitch_del_offloaded_rule(esw, rule, attr);
+ 
+ 		return;
+ 	}
+ 
+ 	mlx5e_del_offloaded_nic_rule(priv, rule, attr);
+ }
+ 
+ int
+ mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
+ 			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+ 			  enum mlx5_flow_namespace_type ns,
+ 			  enum mlx5e_tc_attr_to_reg type,
+ 			  u32 data)
+ {
+ 	int ret = mlx5e_tc_match_to_reg_set_and_get_id(mdev, mod_hdr_acts, ns, type, data);
+ 
+ 	return ret < 0 ? ret : 0;
+ }
+ 
+ void mlx5e_tc_match_to_reg_mod_hdr_change(struct mlx5_core_dev *mdev,
+ 					  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+ 					  enum mlx5e_tc_attr_to_reg type,
+ 					  int act_id, u32 data)
+ {
+ 	int moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;
+ 	int mfield = mlx5e_tc_attr_to_reg_mappings[type].mfield;
+ 	int mlen = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	char *modact;
+ 
+ 	modact = mod_hdr_acts->actions + (act_id * MLX5_MH_ACT_SZ);
+ 
+ 	/* Firmware has 5bit length field and 0 means 32bits */
+ 	if (mlen == 4)
+ 		mlen = 0;
+ 
+ 	MLX5_SET(set_action_in, modact, action_type, MLX5_ACTION_TYPE_SET);
+ 	MLX5_SET(set_action_in, modact, field, mfield);
+ 	MLX5_SET(set_action_in, modact, offset, moffset * 8);
+ 	MLX5_SET(set_action_in, modact, length, mlen * 8);
+ 	MLX5_SET(set_action_in, modact, data, data);
++>>>>>>> f94d6389f6a8 (net/mlx5e: TC, Add support to offload sample action)
  }
  
  struct mlx5e_hairpin {
@@@ -1111,11 -1108,17 +1215,20 @@@ mlx5e_tc_offload_fdb_rules(struct mlx5_
  	if (flow_flag_test(flow, CT)) {
  		mod_hdr_acts = &attr->parse_attr->mod_hdr_acts;
  
 -		rule = mlx5_tc_ct_flow_offload(get_ct_priv(flow->priv),
 -					       flow, spec, attr,
 +		return mlx5_tc_ct_flow_offload(flow->priv, flow, spec, attr,
  					       mod_hdr_acts);
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_MLX5_TC_SAMPLE)
+ 	} else if (flow_flag_test(flow, SAMPLE)) {
+ 		rule = mlx5_esw_sample_offload(get_sample_priv(flow->priv), spec, attr);
+ #endif
+ 	} else {
+ 		rule = mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
++>>>>>>> f94d6389f6a8 (net/mlx5e: TC, Add support to offload sample action)
  	}
  
 +	rule = mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
  	if (IS_ERR(rule))
  		return rule;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 451410599bb1,deafb0e03787..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -396,6 -425,8 +399,11 @@@ enum 
  	MLX5_ESW_ATTR_FLAG_VLAN_HANDLED  = BIT(0),
  	MLX5_ESW_ATTR_FLAG_SLOW_PATH     = BIT(1),
  	MLX5_ESW_ATTR_FLAG_NO_IN_PORT    = BIT(2),
++<<<<<<< HEAD
++=======
+ 	MLX5_ESW_ATTR_FLAG_SRC_REWRITE   = BIT(3),
+ 	MLX5_ESW_ATTR_FLAG_SAMPLE        = BIT(4),
++>>>>>>> f94d6389f6a8 (net/mlx5e: TC, Add support to offload sample action)
  };
  
  struct mlx5_esw_flow_attr {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index ff63d3681390,ac92ffc8a5d3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -119,10 -151,50 +139,36 @@@ mlx5_eswitch_set_rule_source_port(struc
  	}
  }
  
 -static int
 -esw_setup_decap_indir(struct mlx5_eswitch *esw,
 -		      struct mlx5_flow_attr *attr,
 -		      struct mlx5_flow_spec *spec)
 -{
 -	struct mlx5_flow_table *ft;
 -
 -	if (!(attr->flags & MLX5_ESW_ATTR_FLAG_SRC_REWRITE))
 -		return -EOPNOTSUPP;
 -
 -	ft = mlx5_esw_indir_table_get(esw, attr, spec,
 -				      mlx5_esw_indir_table_decap_vport(attr), true);
 -	return PTR_ERR_OR_ZERO(ft);
 -}
 -
  static void
++<<<<<<< HEAD
++=======
+ esw_cleanup_decap_indir(struct mlx5_eswitch *esw,
+ 			struct mlx5_flow_attr *attr)
+ {
+ 	if (mlx5_esw_indir_table_decap_vport(attr))
+ 		mlx5_esw_indir_table_put(esw, attr,
+ 					 mlx5_esw_indir_table_decap_vport(attr),
+ 					 true);
+ }
+ 
+ static int
+ esw_setup_sampler_dest(struct mlx5_flow_destination *dest,
+ 		       struct mlx5_flow_act *flow_act,
+ 		       struct mlx5_esw_flow_attr *esw_attr,
+ 		       int i)
+ {
+ 	flow_act->flags |= FLOW_ACT_IGNORE_FLOW_LEVEL;
+ 	dest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_SAMPLER;
+ 	dest[i].sampler_id = esw_attr->sample->sampler_id;
+ 
+ 	return 0;
+ }
+ 
+ static int
++>>>>>>> f94d6389f6a8 (net/mlx5e: TC, Add support to offload sample action)
  esw_setup_ft_dest(struct mlx5_flow_destination *dest,
  		  struct mlx5_flow_act *flow_act,
 -		  struct mlx5_eswitch *esw,
  		  struct mlx5_flow_attr *attr,
 -		  struct mlx5_flow_spec *spec,
  		  int i)
  {
  	flow_act->flags |= FLOW_ACT_IGNORE_FLOW_LEVEL;
@@@ -210,8 -412,17 +256,22 @@@ esw_setup_dests(struct mlx5_flow_destin
  	struct mlx5_fs_chains *chains = esw_chains(esw);
  	int err = 0;
  
++<<<<<<< HEAD
 +	if (attr->dest_ft) {
 +		esw_setup_ft_dest(dest, flow_act, attr, *i);
++=======
+ 	if (!mlx5_eswitch_termtbl_required(esw, attr, flow_act, spec) &&
+ 	    MLX5_CAP_GEN(esw_attr->in_mdev, reg_c_preserve) &&
+ 	    mlx5_eswitch_vport_match_metadata_enabled(esw) &&
+ 	    MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, ignore_flow_level))
+ 		attr->flags |= MLX5_ESW_ATTR_FLAG_SRC_REWRITE;
+ 
+ 	if (attr->flags & MLX5_ESW_ATTR_FLAG_SAMPLE) {
+ 		esw_setup_sampler_dest(dest, flow_act, esw_attr, *i);
+ 		(*i)++;
+ 	} else if (attr->dest_ft) {
+ 		esw_setup_ft_dest(dest, flow_act, esw, attr, spec, *i);
++>>>>>>> f94d6389f6a8 (net/mlx5e: TC, Add support to offload sample action)
  		(*i)++;
  	} else if (attr->flags & MLX5_ESW_ATTR_FLAG_SLOW_PATH) {
  		esw_setup_slow_path_dest(dest, flow_act, chains, *i);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/sample.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/sample.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
