mm, page_alloc: simplify pageset_update()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Vlastimil Babka <vbabka@suse.cz>
commit 5c3ad2eb7104754a36580079a2e4aed04a10631d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5c3ad2eb.failed

pageset_update() attempts to update pcplist's high and batch values in a
way that readers don't observe batch > high.  It uses smp_wmb() to order
the updates in a way to achieve this.  However, without proper pairing
read barriers in readers this guarantee doesn't hold, and there are no
such barriers in e.g.  free_unref_page_commit().

Commit 88e8ac11d2ea ("mm, page_alloc: fix core hung in
free_pcppages_bulk()") already showed this is problematic, and solved this
by ultimately only trusing pcp->count of the current cpu with interrupts
disabled.

The update dance with unpaired write barriers thus makes no sense.
Replace them with plain WRITE_ONCE to prevent store tearing, and document
that the values can change asynchronously and should not be trusted for
correctness.

All current readers appear to be OK after 88e8ac11d2ea.  Convert them to
READ_ONCE to prevent unnecessary read tearing, but mainly to alert anybody
making future changes to the code that special care is needed.

Link: https://lkml.kernel.org/r/20201111092812.11329-5-vbabka@suse.cz
	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Acked-by: David Hildenbrand <david@redhat.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5c3ad2eb7104754a36580079a2e4aed04a10631d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index 15c303e87cbd,0c47af9e97c6..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -6224,13 -6270,16 +6224,21 @@@ static int zone_batchsize(struct zone *
  }
  
  /*
-  * pcp->high and pcp->batch values are related and dependent on one another:
-  * ->batch must never be higher then ->high.
-  * The following function updates them in a safe manner without read side
-  * locking.
+  * pcp->high and pcp->batch values are related and generally batch is lower
+  * than high. They are also related to pcp->count such that count is lower
+  * than high, and as soon as it reaches high, the pcplist is flushed.
   *
++<<<<<<< HEAD
 + * Any new users of pcp->batch and pcp->high should ensure they can cope with
 + * those fields changing asynchronously (acording the the above rule).
++=======
+  * However, guaranteeing these relations at all times would require e.g. write
+  * barriers here but also careful usage of read barriers at the read side, and
+  * thus be prone to error and bad for performance. Thus the update only prevents
+  * store tearing. Any new users of pcp->batch and pcp->high should ensure they
+  * can cope with those fields changing asynchronously, and fully trust only the
+  * pcp->count field on the local CPU with interrupts disabled.
++>>>>>>> 5c3ad2eb7104 (mm, page_alloc: simplify pageset_update())
   *
   * mutex_is_locked(&pcp_batch_high_lock) required when calling this function
   * outside of boot time (or some other assurance that no concurrent updaters
* Unmerged path mm/page_alloc.c
