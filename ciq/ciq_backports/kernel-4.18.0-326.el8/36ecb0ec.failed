drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 36ecb0ec105412aa7e7c89991a7cff90bf90b2f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/36ecb0ec.failed

For ICL+ we have several styles of clock routing for DDIs:
1) TC DDI + TC PHY
   -> needs DDI_CLK_SEL==MG/TBT part form intel_ddi_clk_{select,disable}()
   and ICL_DPCLKA_CFGCR0_TC_CLK_OFF part form icl_{map,unmap}_plls_to_ports()
2) ICL/TGL combo DDI + combo PHY
   -> just need the stuff from icl_{map,unmap}_plls_to_ports()
3) JSL/EHL TC DDI + combo PHY
   -> needs DDI_CLK_SEL==MG part from intel_ddi_clk_{select,disable}() and
   the full combo style clock selection from icl_{map,unmap}_plls_to_ports()
4) ADLS/RKL
   -> these use both TC and combo DDIs with combo PHYs, however they
   always use the full combo style clock selection as per
   icl_{map,unmap}_plls_to_ports() and do not use DDI_CLK_SEL at all,
   thus get treated the same as 2)

We extract all that from the current mess in the following way:
1) icl_ddi_tc_{enable,disable}_clock()
2) icl_ddi_combo_{enable,disable}_clock()
3) jsl_ddi_tc_{enable,disable}_clock()
4) for now we reuse icl_ddi_combo_{enable,disable}_clock() here

v2: s/dev_priv/i915/ (Lucas)

	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210205214634.19341-8-ville.syrjala@linux.intel.com
(cherry picked from commit 36ecb0ec105412aa7e7c89991a7cff90bf90b2f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 87726ca7041c,c325e54fb3e7..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -2816,8 -1599,55 +2816,60 @@@ static u32 icl_dpclka_cfgcr0_clk_off(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void icl_map_plls_to_ports(struct intel_encoder *encoder,
 +				  const struct intel_crtc_state *crtc_state)
++=======
+ static void dg1_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
+ 	u32 val;
+ 
+ 	/*
+ 	 * If we fail this, something went very wrong: first 2 PLLs should be
+ 	 * used by first 2 phys and last 2 PLLs by last phys
+ 	 */
+ 	if (drm_WARN_ON(&dev_priv->drm,
+ 			(pll->info->id < DPLL_ID_DG1_DPLL2 && phy >= PHY_C) ||
+ 			(pll->info->id >= DPLL_ID_DG1_DPLL2 && phy < PHY_C)))
+ 		return;
+ 
+ 	mutex_lock(&dev_priv->dpll.lock);
+ 
+ 	val = intel_de_read(dev_priv, DG1_DPCLKA_CFGCR0(phy));
+ 	drm_WARN_ON(&dev_priv->drm,
+ 		    (val & DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy)) == 0);
+ 
+ 	val &= ~DG1_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);
+ 	val |= DG1_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);
+ 	intel_de_write(dev_priv, DG1_DPCLKA_CFGCR0(phy), val);
+ 	intel_de_posting_read(dev_priv, DG1_DPCLKA_CFGCR0(phy));
+ 
+ 	val &= ~DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy);
+ 	intel_de_write(dev_priv, DG1_DPCLKA_CFGCR0(phy), val);
+ 
+ 	mutex_unlock(&dev_priv->dpll.lock);
+ }
+ 
+ static void dg1_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
+ 
+ 	mutex_lock(&dev_priv->dpll.lock);
+ 
+ 	intel_de_rmw(dev_priv, DG1_DPCLKA_CFGCR0(phy), 0,
+ 		     DG1_DPCLKA_CFGCR0_DDI_CLK_OFF(phy));
+ 
+ 	mutex_unlock(&dev_priv->dpll.lock);
+ }
+ 
+ static void icl_ddi_combo_enable_clock(struct intel_encoder *encoder,
+ 				       const struct intel_crtc_state *crtc_state)
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
  	struct intel_shared_dpll *pll = crtc_state->shared_dpll;
@@@ -2830,35 -1675,23 +2882,52 @@@
  	drm_WARN_ON(&dev_priv->drm,
  		    (val & icl_dpclka_cfgcr0_clk_off(dev_priv, phy)) == 0);
  
++<<<<<<< HEAD
 +	if (intel_phy_is_combo(dev_priv, phy)) {
 +		u32 mask, sel;
 +
 +		if (IS_ROCKETLAKE(dev_priv)) {
 +			mask = RKL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);
 +			sel = RKL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);
 +		} else {
 +			mask = ICL_DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(phy);
 +			sel = ICL_DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, phy);
 +		}
 +
 +		/*
 +		 * Even though this register references DDIs, note that we
 +		 * want to pass the PHY rather than the port (DDI).  For
 +		 * ICL, port=phy in all cases so it doesn't matter, but for
 +		 * EHL the bspec notes the following:
 +		 *
 +		 *   "DDID clock tied to DDIA clock, so DPCLKA_CFGCR0 DDIA
 +		 *   Clock Select chooses the PLL for both DDIA and DDID and
 +		 *   drives port A in all cases."
 +		 */
 +		val &= ~mask;
 +		val |= sel;
 +		intel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, val);
 +		intel_de_posting_read(dev_priv, ICL_DPCLKA_CFGCR0);
 +	}
++=======
+ 	/*
+ 	 * Even though this register references DDIs, note that we
+ 	 * want to pass the PHY rather than the port (DDI).  For
+ 	 * ICL, port=phy in all cases so it doesn't matter, but for
+ 	 * EHL the bspec notes the following:
+ 	 *
+ 	 *   "DDID clock tied to DDIA clock, so DPCLKA_CFGCR0 DDIA
+ 	 *   Clock Select chooses the PLL for both DDIA and DDID and
+ 	 *   drives port A in all cases."
+ 	 */
+ 	val &= ~mask;
+ 	val |= sel;
+ 	intel_de_write(dev_priv, reg, val);
+ 	intel_de_posting_read(dev_priv, reg);
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  
  	val &= ~icl_dpclka_cfgcr0_clk_off(dev_priv, phy);
 -	intel_de_write(dev_priv, reg, val);
 +	intel_de_write(dev_priv, ICL_DPCLKA_CFGCR0, val);
  
  	mutex_unlock(&dev_priv->dpll.lock);
  }
@@@ -2960,91 -1839,185 +3029,258 @@@ void icl_sanitize_encoder_pll_mapping(s
  		ddi_clk_needed = false;
  	}
  
 -	if (IS_DG1(dev_priv))
 -		dg1_sanitize_port_clk_off(dev_priv, port_mask, ddi_clk_needed);
 -	else
 -		icl_sanitize_port_clk_off(dev_priv, port_mask, ddi_clk_needed);
 +	icl_sanitize_port_clk_off(dev_priv, port_mask, ddi_clk_needed);
  }
  
++<<<<<<< HEAD
 +static void intel_ddi_clk_select(struct intel_encoder *encoder,
 +				 const struct intel_crtc_state *crtc_state)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 +	enum port port = encoder->port;
 +	enum phy phy = intel_port_to_phy(dev_priv, port);
 +	u32 val;
++=======
+ static void jsl_ddi_tc_enable_clock(struct intel_encoder *encoder,
+ 				    const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
  
- 	if (drm_WARN_ON(&dev_priv->drm, !pll))
+ 	if (drm_WARN_ON(&i915->drm, !pll))
  		return;
  
- 	mutex_lock(&dev_priv->dpll.lock);
+ 	/*
+ 	 * "For DDIC and DDID, program DDI_CLK_SEL to map the MG clock to the port.
+ 	 *  MG does not exist, but the programming is required to ungate DDIC and DDID."
+ 	 */
+ 	intel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_MG);
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) >= 11) {
 +		if (!intel_phy_is_combo(dev_priv, phy))
 +			intel_de_write(dev_priv, DDI_CLK_SEL(port),
 +				       icl_pll_to_ddi_clk_sel(encoder, crtc_state));
 +		else if (IS_ELKHARTLAKE(dev_priv) && port >= PORT_C)
 +			/*
 +			 * MG does not exist but the programming is required
 +			 * to ungate DDIC and DDID
 +			 */
 +			intel_de_write(dev_priv, DDI_CLK_SEL(port),
 +				       DDI_CLK_SEL_MG);
 +	} else if (IS_CANNONLAKE(dev_priv)) {
 +		/* Configure DPCLKA_CFGCR0 to map the DPLL to the DDI. */
 +		val = intel_de_read(dev_priv, DPCLKA_CFGCR0);
 +		val &= ~DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(port);
 +		val |= DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, port);
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0, val);
 +
 +		/*
 +		 * Configure DPCLKA_CFGCR0 to turn on the clock for the DDI.
 +		 * This step and the step before must be done with separate
 +		 * register writes.
 +		 */
 +		val = intel_de_read(dev_priv, DPCLKA_CFGCR0);
 +		val &= ~DPCLKA_CFGCR0_DDI_CLK_OFF(port);
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0, val);
 +	} else if (IS_GEN9_BC(dev_priv)) {
 +		/* DDI -> PLL mapping  */
 +		val = intel_de_read(dev_priv, DPLL_CTRL2);
 +
 +		val &= ~(DPLL_CTRL2_DDI_CLK_OFF(port) |
 +			 DPLL_CTRL2_DDI_CLK_SEL_MASK(port));
 +		val |= (DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |
 +			DPLL_CTRL2_DDI_SEL_OVERRIDE(port));
 +
 +		intel_de_write(dev_priv, DPLL_CTRL2, val);
 +
 +	} else if (INTEL_GEN(dev_priv) < 9) {
 +		intel_de_write(dev_priv, PORT_CLK_SEL(port),
 +			       hsw_pll_to_ddi_pll_sel(pll));
 +	}
 +
 +	mutex_unlock(&dev_priv->dpll.lock);
++=======
+ 	icl_ddi_combo_enable_clock(encoder, crtc_state);
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  }
  
- static void intel_ddi_clk_disable(struct intel_encoder *encoder)
+ static void jsl_ddi_tc_disable_clock(struct intel_encoder *encoder)
  {
- 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
  	enum port port = encoder->port;
- 	enum phy phy = intel_port_to_phy(dev_priv, port);
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) >= 11) {
 +		if (!intel_phy_is_combo(dev_priv, phy) ||
 +		    (IS_ELKHARTLAKE(dev_priv) && port >= PORT_C))
 +			intel_de_write(dev_priv, DDI_CLK_SEL(port),
 +				       DDI_CLK_SEL_NONE);
 +	} else if (IS_CANNONLAKE(dev_priv)) {
 +		intel_de_write(dev_priv, DPCLKA_CFGCR0,
 +			       intel_de_read(dev_priv, DPCLKA_CFGCR0) | DPCLKA_CFGCR0_DDI_CLK_OFF(port));
 +	} else if (IS_GEN9_BC(dev_priv)) {
 +		intel_de_write(dev_priv, DPLL_CTRL2,
 +			       intel_de_read(dev_priv, DPLL_CTRL2) | DPLL_CTRL2_DDI_CLK_OFF(port));
 +	} else if (INTEL_GEN(dev_priv) < 9) {
 +		intel_de_write(dev_priv, PORT_CLK_SEL(port),
 +			       PORT_CLK_SEL_NONE);
 +	}
 +}
 +
++=======
+ 	icl_ddi_combo_disable_clock(encoder);
+ 
+ 	intel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_NONE);
+ }
+ 
+ static void icl_ddi_tc_enable_clock(struct intel_encoder *encoder,
+ 				    const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum tc_port tc_port = intel_port_to_tc(i915, encoder->port);
+ 	enum port port = encoder->port;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	intel_de_write(i915, DDI_CLK_SEL(port),
+ 		       icl_pll_to_ddi_clk_sel(encoder, crtc_state));
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	intel_de_rmw(i915, ICL_DPCLKA_CFGCR0,
+ 		     ICL_DPCLKA_CFGCR0_TC_CLK_OFF(tc_port), 0);
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void icl_ddi_tc_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum tc_port tc_port = intel_port_to_tc(i915, encoder->port);
+ 	enum port port = encoder->port;
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	intel_de_rmw(i915, ICL_DPCLKA_CFGCR0,
+ 		     0, ICL_DPCLKA_CFGCR0_TC_CLK_OFF(tc_port));
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ 
+ 	intel_de_write(i915, DDI_CLK_SEL(port), DDI_CLK_SEL_NONE);
+ }
+ 
+ static void cnl_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	val = intel_de_read(i915, DPCLKA_CFGCR0);
+ 	val &= ~DPCLKA_CFGCR0_DDI_CLK_SEL_MASK(port);
+ 	val |= DPCLKA_CFGCR0_DDI_CLK_SEL(pll->info->id, port);
+ 	intel_de_write(i915, DPCLKA_CFGCR0, val);
+ 
+ 	/*
+ 	 * "This step and the step before must be
+ 	 *  done with separate register writes."
+ 	 */
+ 	val = intel_de_read(i915, DPCLKA_CFGCR0);
+ 	val &= ~DPCLKA_CFGCR0_DDI_CLK_OFF(port);
+ 	intel_de_write(i915, DPCLKA_CFGCR0, val);
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void cnl_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, DPCLKA_CFGCR0,
+ 		       intel_de_read(i915, DPCLKA_CFGCR0) | DPCLKA_CFGCR0_DDI_CLK_OFF(port));
+ }
+ 
+ static void skl_ddi_enable_clock(struct intel_encoder *encoder,
+ 				 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 	u32 val;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	mutex_lock(&i915->dpll.lock);
+ 
+ 	val = intel_de_read(i915, DPLL_CTRL2);
+ 
+ 	val &= ~(DPLL_CTRL2_DDI_CLK_OFF(port) |
+ 		 DPLL_CTRL2_DDI_CLK_SEL_MASK(port));
+ 	val |= (DPLL_CTRL2_DDI_CLK_SEL(pll->info->id, port) |
+ 		DPLL_CTRL2_DDI_SEL_OVERRIDE(port));
+ 
+ 	intel_de_write(i915, DPLL_CTRL2, val);
+ 
+ 	mutex_unlock(&i915->dpll.lock);
+ }
+ 
+ static void skl_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, DPLL_CTRL2,
+ 		       intel_de_read(i915, DPLL_CTRL2) | DPLL_CTRL2_DDI_CLK_OFF(port));
+ }
+ 
+ void hsw_ddi_enable_clock(struct intel_encoder *encoder,
+ 			  const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	const struct intel_shared_dpll *pll = crtc_state->shared_dpll;
+ 	enum port port = encoder->port;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !pll))
+ 		return;
+ 
+ 	intel_de_write(i915, PORT_CLK_SEL(port), hsw_pll_to_ddi_pll_sel(pll));
+ }
+ 
+ void hsw_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	struct drm_i915_private *i915 = to_i915(encoder->base.dev);
+ 	enum port port = encoder->port;
+ 
+ 	intel_de_write(i915, PORT_CLK_SEL(port), PORT_CLK_SEL_NONE);
+ }
+ 
+ void intel_ddi_enable_clock(struct intel_encoder *encoder,
+ 			    const struct intel_crtc_state *crtc_state)
+ {
+ 	if (encoder->enable_clock)
+ 		encoder->enable_clock(encoder, crtc_state);
+ }
+ 
+ static void intel_ddi_disable_clock(struct intel_encoder *encoder)
+ {
+ 	if (encoder->disable_clock)
+ 		encoder->disable_clock(encoder);
+ }
+ 
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  static void
  icl_program_mg_dp_mode(struct intel_digital_port *dig_port,
  		       const struct intel_crtc_state *crtc_state)
@@@ -3485,9 -2497,6 +3721,12 @@@ static void intel_ddi_pre_enable(struc
  
  	drm_WARN_ON(&dev_priv->drm, crtc_state->has_pch_encoder);
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) >= 11)
 +		icl_map_plls_to_ports(encoder, crtc_state);
 +
++=======
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  	intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);
  
  	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {
@@@ -3671,12 -2695,10 +3910,15 @@@ static void intel_ddi_post_disable(stru
  		intel_ddi_post_disable_dp(state, encoder, old_crtc_state,
  					  old_conn_state);
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) >= 11)
 +		icl_unmap_plls_to_ports(encoder);
 +
++=======
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  	if (intel_crtc_has_dp_encoder(old_crtc_state) || is_tc_port)
 -		intel_display_power_put(dev_priv,
 -					intel_ddi_main_link_aux_domain(dig_port),
 -					fetch_and_zero(&dig_port->aux_wakeref));
 +		intel_display_power_put_unchecked(dev_priv,
 +						  intel_ddi_main_link_aux_domain(dig_port));
  
  	if (is_tc_port)
  		intel_tc_port_put_link(dig_port);
@@@ -4893,10 -3970,90 +5135,94 @@@ intel_ddi_max_lanes(struct intel_digita
  static bool hti_uses_phy(struct drm_i915_private *i915, enum phy phy)
  {
  	return i915->hti_state & HDPORT_ENABLED &&
 -	       i915->hti_state & HDPORT_DDI_USED(phy);
 +		(i915->hti_state & HDPORT_PHY_USED_DP(phy) ||
 +		 i915->hti_state & HDPORT_PHY_USED_HDMI(phy));
  }
  
++<<<<<<< HEAD
++=======
+ static enum hpd_pin dg1_hpd_pin(struct drm_i915_private *dev_priv,
+ 				enum port port)
+ {
+ 	if (port >= PORT_TC1)
+ 		return HPD_PORT_C + port - PORT_TC1;
+ 	else
+ 		return HPD_PORT_A + port - PORT_A;
+ }
+ 
+ static enum hpd_pin tgl_hpd_pin(struct drm_i915_private *dev_priv,
+ 				enum port port)
+ {
+ 	if (port >= PORT_TC1)
+ 		return HPD_PORT_TC1 + port - PORT_TC1;
+ 	else
+ 		return HPD_PORT_A + port - PORT_A;
+ }
+ 
+ static enum hpd_pin rkl_hpd_pin(struct drm_i915_private *dev_priv,
+ 				enum port port)
+ {
+ 	if (HAS_PCH_TGP(dev_priv))
+ 		return tgl_hpd_pin(dev_priv, port);
+ 
+ 	if (port >= PORT_TC1)
+ 		return HPD_PORT_C + port - PORT_TC1;
+ 	else
+ 		return HPD_PORT_A + port - PORT_A;
+ }
+ 
+ static enum hpd_pin icl_hpd_pin(struct drm_i915_private *dev_priv,
+ 				enum port port)
+ {
+ 	if (port >= PORT_C)
+ 		return HPD_PORT_TC1 + port - PORT_C;
+ 	else
+ 		return HPD_PORT_A + port - PORT_A;
+ }
+ 
+ static enum hpd_pin ehl_hpd_pin(struct drm_i915_private *dev_priv,
+ 				enum port port)
+ {
+ 	if (port == PORT_D)
+ 		return HPD_PORT_A;
+ 
+ 	if (HAS_PCH_MCC(dev_priv))
+ 		return icl_hpd_pin(dev_priv, port);
+ 
+ 	return HPD_PORT_A + port - PORT_A;
+ }
+ 
+ static enum hpd_pin cnl_hpd_pin(struct drm_i915_private *dev_priv,
+ 				enum port port)
+ {
+ 	if (port == PORT_F)
+ 		return HPD_PORT_E;
+ 
+ 	return HPD_PORT_A + port - PORT_A;
+ }
+ 
+ static enum hpd_pin skl_hpd_pin(struct drm_i915_private *dev_priv, enum port port)
+ {
+ 	if (HAS_PCH_TGP(dev_priv))
+ 		return icl_hpd_pin(dev_priv, port);
+ 
+ 	return HPD_PORT_A + port - PORT_A;
+ }
+ 
+ static bool intel_ddi_is_tc(struct drm_i915_private *i915, enum port port)
+ {
+ 	if (INTEL_GEN(i915) >= 12)
+ 		return port >= PORT_TC1;
+ 	else if (INTEL_GEN(i915) >= 11)
+ 		return port >= PORT_C;
+ 	else
+ 		return false;
+ }
+ 
+ #define port_tc_name(port) ((port) - PORT_TC1 + '1')
+ #define tc_port_name(tc_port) ((tc_port) - TC_PORT_1 + '1')
+ 
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  void intel_ddi_init(struct drm_i915_private *dev_priv, enum port port)
  {
  	struct intel_digital_port *dig_port;
@@@ -4970,6 -4155,56 +5296,59 @@@
  	encoder->cloneable = 0;
  	encoder->pipe_mask = ~0;
  
++<<<<<<< HEAD
++=======
+ 	if (IS_ALDERLAKE_S(dev_priv) || IS_ROCKETLAKE(dev_priv)) {
+ 		encoder->enable_clock = icl_ddi_combo_enable_clock;
+ 		encoder->disable_clock = icl_ddi_combo_disable_clock;
+ 	} else if (IS_DG1(dev_priv)) {
+ 		encoder->enable_clock = dg1_ddi_enable_clock;
+ 		encoder->disable_clock = dg1_ddi_disable_clock;
+ 	} else if (IS_JSL_EHL(dev_priv)) {
+ 		if (intel_ddi_is_tc(dev_priv, port)) {
+ 			encoder->enable_clock = jsl_ddi_tc_enable_clock;
+ 			encoder->disable_clock = jsl_ddi_tc_disable_clock;
+ 		} else {
+ 			encoder->enable_clock = icl_ddi_combo_enable_clock;
+ 			encoder->disable_clock = icl_ddi_combo_disable_clock;
+ 		}
+ 	} else if (INTEL_GEN(dev_priv) >= 11) {
+ 		if (intel_ddi_is_tc(dev_priv, port)) {
+ 			encoder->enable_clock = icl_ddi_tc_enable_clock;
+ 			encoder->disable_clock = icl_ddi_tc_disable_clock;
+ 		} else {
+ 			encoder->enable_clock = icl_ddi_combo_enable_clock;
+ 			encoder->disable_clock = icl_ddi_combo_disable_clock;
+ 		}
+ 	} else if (IS_CANNONLAKE(dev_priv)) {
+ 		encoder->enable_clock = cnl_ddi_enable_clock;
+ 		encoder->disable_clock = cnl_ddi_disable_clock;
+ 	} else if (IS_GEN9_BC(dev_priv)) {
+ 		encoder->enable_clock = skl_ddi_enable_clock;
+ 		encoder->disable_clock = skl_ddi_disable_clock;
+ 	} else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {
+ 		encoder->enable_clock = hsw_ddi_enable_clock;
+ 		encoder->disable_clock = hsw_ddi_disable_clock;
+ 	}
+ 
+ 	if (IS_DG1(dev_priv))
+ 		encoder->hpd_pin = dg1_hpd_pin(dev_priv, port);
+ 	else if (IS_ROCKETLAKE(dev_priv))
+ 		encoder->hpd_pin = rkl_hpd_pin(dev_priv, port);
+ 	else if (INTEL_GEN(dev_priv) >= 12)
+ 		encoder->hpd_pin = tgl_hpd_pin(dev_priv, port);
+ 	else if (IS_JSL_EHL(dev_priv))
+ 		encoder->hpd_pin = ehl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 11))
+ 		encoder->hpd_pin = icl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 10))
+ 		encoder->hpd_pin = cnl_hpd_pin(dev_priv, port);
+ 	else if (IS_GEN(dev_priv, 9))
+ 		encoder->hpd_pin = skl_hpd_pin(dev_priv, port);
+ 	else
+ 		encoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);
+ 
++>>>>>>> 36ecb0ec1054 (drm/i915: Extract icl+ .{enable,disable}_clock() vfuncs)
  	if (INTEL_GEN(dev_priv) >= 11)
  		dig_port->saved_port_bits =
  			intel_de_read(dev_priv, DDI_BUF_CTL(port))
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
