dma-direct: rename and cleanup __phys_to_dma

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 5ceda74093a5c1c3f42a02b894df031f3bbc9af1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5ceda740.failed

The __phys_to_dma vs phys_to_dma distinction isn't exactly obvious.  Try
to improve the situation by renaming __phys_to_dma to
phys_to_dma_unencryped, and not forcing architectures that want to
override phys_to_dma to actually provide __phys_to_dma.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Robin Murphy <robin.murphy@arm.com>
(cherry picked from commit 5ceda74093a5c1c3f42a02b894df031f3bbc9af1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/mips/bmips/dma.c
#	arch/mips/cavium-octeon/dma-octeon.c
#	arch/mips/include/asm/dma-direct.h
#	arch/mips/loongson2ef/fuloong-2e/dma.c
#	arch/mips/loongson2ef/lemote-2f/dma.c
#	arch/mips/loongson64/dma.c
#	arch/mips/pci/pci-ar2315.c
#	arch/mips/pci/pci-xtalk-bridge.c
#	arch/mips/sgi-ip32/ip32-dma.c
#	include/linux/dma-direct.h
diff --cc arch/mips/bmips/dma.c
index 6dec30842b2f,49061b870680..000000000000
--- a/arch/mips/bmips/dma.c
+++ b/arch/mips/bmips/dma.c
@@@ -40,7 -40,7 +40,11 @@@ static struct bmips_dma_range *bmips_dm
  
  #define FLUSH_RAC		0x100
  
++<<<<<<< HEAD
 +static dma_addr_t bmips_phys_to_dma(struct device *dev, phys_addr_t pa)
++=======
+ dma_addr_t phys_to_dma(struct device *dev, phys_addr_t pa)
++>>>>>>> 5ceda74093a5 (dma-direct: rename and cleanup __phys_to_dma)
  {
  	struct bmips_dma_range *r;
  
diff --cc arch/mips/cavium-octeon/dma-octeon.c
index a598807e1e94,232fa1017b1e..000000000000
--- a/arch/mips/cavium-octeon/dma-octeon.c
+++ b/arch/mips/cavium-octeon/dma-octeon.c
@@@ -121,53 -140,40 +121,57 @@@ static phys_addr_t octeon_small_dma_to_
  	return daddr;
  }
  
 -static const struct octeon_dma_map_ops octeon_small_ops = {
 -	.phys_to_dma	= octeon_small_phys_to_dma,
 -	.dma_to_phys	= octeon_small_dma_to_phys,
 -};
 +#endif /* CONFIG_PCI */
  
 -static const struct octeon_dma_map_ops *octeon_pci_dma_ops;
++<<<<<<< HEAD
 +static dma_addr_t octeon_dma_map_page(struct device *dev, struct page *page,
 +	unsigned long offset, size_t size, enum dma_data_direction direction,
 +	unsigned long attrs)
 +{
 +	dma_addr_t daddr = swiotlb_map_page(dev, page, offset, size,
 +					    direction, attrs);
 +	mb();
  
 -void __init octeon_pci_dma_init(void)
 +	return daddr;
 +}
 +
 +static int octeon_dma_map_sg(struct device *dev, struct scatterlist *sg,
 +	int nents, enum dma_data_direction direction, unsigned long attrs)
  {
 -	switch (octeon_dma_bar_type) {
 -	case OCTEON_DMA_BAR_TYPE_PCIE:
 -		octeon_pci_dma_ops = &octeon_gen1_ops;
 -		break;
 -	case OCTEON_DMA_BAR_TYPE_PCIE2:
 -		octeon_pci_dma_ops = &octeon_gen2_ops;
 -		break;
 -	case OCTEON_DMA_BAR_TYPE_BIG:
 -		octeon_pci_dma_ops = &octeon_big_ops;
 -		break;
 -	case OCTEON_DMA_BAR_TYPE_SMALL:
 -		octeon_pci_dma_ops = &octeon_small_ops;
 -		break;
 -	default:
 -		BUG();
 -	}
 +	int r = swiotlb_map_sg_attrs(dev, sg, nents, direction, attrs);
 +	mb();
 +	return r;
 +}
 +
 +static void octeon_dma_sync_single_for_device(struct device *dev,
 +	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
 +{
 +	swiotlb_sync_single_for_device(dev, dma_handle, size, direction);
 +	mb();
 +}
 +
 +static void octeon_dma_sync_sg_for_device(struct device *dev,
 +	struct scatterlist *sg, int nelems, enum dma_data_direction direction)
 +{
 +	swiotlb_sync_sg_for_device(dev, sg, nelems, direction);
 +	mb();
 +}
 +
 +static void *octeon_dma_alloc_coherent(struct device *dev, size_t size,
 +	dma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)
 +{
 +	void *ret = swiotlb_alloc(dev, size, dma_handle, gfp, attrs);
 +
 +	mb();
 +
 +	return ret;
  }
 -#endif /* CONFIG_PCI */
  
 +static dma_addr_t octeon_unity_phys_to_dma(struct device *dev, phys_addr_t paddr)
++=======
+ dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
++>>>>>>> 5ceda74093a5 (dma-direct: rename and cleanup __phys_to_dma)
  {
 -#ifdef CONFIG_PCI
 -	if (dev && dev_is_pci(dev))
 -		return octeon_pci_dma_ops->phys_to_dma(dev, paddr);
 -#endif
  	return paddr;
  }
  
diff --cc arch/mips/include/asm/dma-direct.h
index f32f15530aba,9a640118316c..000000000000
--- a/arch/mips/include/asm/dma-direct.h
+++ b/arch/mips/include/asm/dma-direct.h
@@@ -1,1 -1,8 +1,12 @@@
++<<<<<<< HEAD
 +#include <asm/dma-coherence.h>
++=======
+ /* SPDX-License-Identifier: GPL-2.0 */
+ #ifndef _MIPS_DMA_DIRECT_H
+ #define _MIPS_DMA_DIRECT_H 1
+ 
+ dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr);
+ phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr);
+ 
+ #endif /* _MIPS_DMA_DIRECT_H */
++>>>>>>> 5ceda74093a5 (dma-direct: rename and cleanup __phys_to_dma)
diff --cc arch/mips/pci/pci-ar2315.c
index b4fa6413c4e5,cef4a47ab063..000000000000
--- a/arch/mips/pci/pci-ar2315.c
+++ b/arch/mips/pci/pci-ar2315.c
@@@ -167,6 -163,23 +167,26 @@@ struct ar2315_pci_ctrl 
  	struct resource io_res;
  };
  
++<<<<<<< HEAD
++=======
+ static inline dma_addr_t ar2315_dev_offset(struct device *dev)
+ {
+ 	if (dev && dev_is_pci(dev))
+ 		return AR2315_PCI_HOST_SDRAM_BASEADDR;
+ 	return 0;
+ }
+ 
+ dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
+ {
+ 	return paddr + ar2315_dev_offset(dev);
+ }
+ 
+ phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dma_addr)
+ {
+ 	return dma_addr - ar2315_dev_offset(dev);
+ }
+ 
++>>>>>>> 5ceda74093a5 (dma-direct: rename and cleanup __phys_to_dma)
  static inline struct ar2315_pci_ctrl *ar2315_pci_bus_to_apc(struct pci_bus *bus)
  {
  	struct pci_controller *hose = bus->sysdata;
diff --cc include/linux/dma-direct.h
index 627dda026934,805010ea5346..000000000000
--- a/include/linux/dma-direct.h
+++ b/include/linux/dma-direct.h
@@@ -24,11 -28,23 +28,26 @@@ static inline dma_addr_t phys_to_dma_un
  	return dev_addr - ((dma_addr_t)dev->dma_pfn_offset << PAGE_SHIFT);
  }
  
++<<<<<<< HEAD
 +static inline phys_addr_t __dma_to_phys(struct device *dev, dma_addr_t dev_addr)
++=======
+ /*
+  * If memory encryption is supported, phys_to_dma will set the memory encryption
+  * bit in the DMA address, and dma_to_phys will clear it.
+  * phys_to_dma_unencrypted is for use on special unencrypted memory like swiotlb
+  * buffers.
+  */
+ static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
+ {
+ 	return __sme_set(phys_to_dma_unencrypted(dev, paddr));
+ }
+ 
+ static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dev_addr)
++>>>>>>> 5ceda74093a5 (dma-direct: rename and cleanup __phys_to_dma)
  {
 -	phys_addr_t paddr = (phys_addr_t)dev_addr +
 -		((phys_addr_t)dev->dma_pfn_offset << PAGE_SHIFT);
 +	phys_addr_t paddr = (phys_addr_t)dev_addr;
  
 -	return __sme_clr(paddr);
 +	return paddr + ((phys_addr_t)dev->dma_pfn_offset << PAGE_SHIFT);
  }
  #endif /* !CONFIG_ARCH_HAS_PHYS_TO_DMA */
  
@@@ -41,22 -57,6 +60,25 @@@ static inline bool force_dma_unencrypte
  }
  #endif /* CONFIG_ARCH_HAS_FORCE_DMA_UNENCRYPTED */
  
++<<<<<<< HEAD
 +/*
 + * If memory encryption is supported, phys_to_dma will set the memory encryption
 + * bit in the DMA address, and dma_to_phys will clear it.  The raw __phys_to_dma
 + * and __dma_to_phys versions should only be used on non-encrypted memory for
 + * special occasions like DMA coherent buffers.
 + */
 +static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
 +{
 +	return __sme_set(__phys_to_dma(dev, paddr));
 +}
 +
 +static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr)
 +{
 +	return __sme_clr(__dma_to_phys(dev, daddr));
 +}
 +
++=======
++>>>>>>> 5ceda74093a5 (dma-direct: rename and cleanup __phys_to_dma)
  static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size,
  		bool is_ram)
  {
* Unmerged path arch/mips/loongson2ef/fuloong-2e/dma.c
* Unmerged path arch/mips/loongson2ef/lemote-2f/dma.c
* Unmerged path arch/mips/loongson64/dma.c
* Unmerged path arch/mips/pci/pci-xtalk-bridge.c
* Unmerged path arch/mips/sgi-ip32/ip32-dma.c
diff --git a/arch/arm/include/asm/dma-direct.h b/arch/arm/include/asm/dma-direct.h
index b67e5fc1fe43..c9f4e70a4fe2 100644
--- a/arch/arm/include/asm/dma-direct.h
+++ b/arch/arm/include/asm/dma-direct.h
@@ -2,7 +2,7 @@
 #ifndef ASM_ARM_DMA_DIRECT_H
 #define ASM_ARM_DMA_DIRECT_H 1
 
-static inline dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
+static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
 {
 	unsigned int offset = paddr & ~PAGE_MASK;
 	return pfn_to_dma(dev, __phys_to_pfn(paddr)) + offset;
* Unmerged path arch/mips/bmips/dma.c
* Unmerged path arch/mips/cavium-octeon/dma-octeon.c
* Unmerged path arch/mips/include/asm/dma-direct.h
* Unmerged path arch/mips/loongson2ef/fuloong-2e/dma.c
* Unmerged path arch/mips/loongson2ef/lemote-2f/dma.c
* Unmerged path arch/mips/loongson64/dma.c
* Unmerged path arch/mips/pci/pci-ar2315.c
* Unmerged path arch/mips/pci/pci-xtalk-bridge.c
* Unmerged path arch/mips/sgi-ip32/ip32-dma.c
diff --git a/arch/powerpc/include/asm/dma-direct.h b/arch/powerpc/include/asm/dma-direct.h
index e29e8a236b8d..c1dd6e540970 100644
--- a/arch/powerpc/include/asm/dma-direct.h
+++ b/arch/powerpc/include/asm/dma-direct.h
@@ -2,7 +2,7 @@
 #ifndef ASM_POWERPC_DMA_DIRECT_H
 #define ASM_POWERPC_DMA_DIRECT_H 1
 
-static inline dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
+static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
 {
 	if (!dev)
 		return paddr + PCI_DRAM_OFFSET;
diff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c
index 57eb505e357a..4e7242c99651 100644
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@ -3826,7 +3826,7 @@ bounce_map_single(struct device *dev, phys_addr_t paddr, size_t size,
 	 */
 	if (!IS_ALIGNED(paddr | size, VTD_PAGE_SIZE)) {
 		tlb_addr = swiotlb_tbl_map_single(dev,
-				__phys_to_dma(dev, io_tlb_start),
+				phys_to_dma_unencrypted(dev, io_tlb_start),
 				paddr, size, aligned_size, dir, attrs);
 		if (tlb_addr == DMA_MAPPING_ERROR) {
 			goto swiotlb_error;
* Unmerged path include/linux/dma-direct.h
diff --git a/kernel/dma/direct.c b/kernel/dma/direct.c
index b992d9926af3..4bc59d89a731 100644
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -25,7 +25,7 @@ static inline dma_addr_t phys_to_dma_direct(struct device *dev,
 		phys_addr_t phys)
 {
 	if (force_dma_unencrypted(dev))
-		return __phys_to_dma(dev, phys);
+		return phys_to_dma_unencrypted(dev, phys);
 	return phys_to_dma(dev, phys);
 }
 
@@ -439,13 +439,13 @@ int dma_direct_supported(struct device *dev, u64 mask)
 		return 1;
 
 	/*
-	 * This check needs to be against the actual bit mask value, so
-	 * use __phys_to_dma() here so that the SME encryption mask isn't
+	 * This check needs to be against the actual bit mask value, so use
+	 * phys_to_dma_unencrypted() here so that the SME encryption mask isn't
 	 * part of the check.
 	 */
 	if (IS_ENABLED(CONFIG_ZONE_DMA))
 		min_mask = min_t(u64, min_mask, DMA_BIT_MASK(zone_dma_bits));
-	return mask >= __phys_to_dma(dev, min_mask);
+	return mask >= phys_to_dma_unencrypted(dev, min_mask);
 }
 
 size_t dma_direct_max_mapping_size(struct device *dev)
diff --git a/kernel/dma/swiotlb.c b/kernel/dma/swiotlb.c
index a4f70082b490..8178f883d3c5 100644
--- a/kernel/dma/swiotlb.c
+++ b/kernel/dma/swiotlb.c
@@ -671,13 +671,13 @@ dma_addr_t swiotlb_map(struct device *dev, phys_addr_t paddr, size_t size,
 			      swiotlb_force);
 
 	swiotlb_addr = swiotlb_tbl_map_single(dev,
-			__phys_to_dma(dev, io_tlb_start),
+			phys_to_dma_unencrypted(dev, io_tlb_start),
 			paddr, size, size, dir, attrs);
 	if (swiotlb_addr == (phys_addr_t)DMA_MAPPING_ERROR)
 		return DMA_MAPPING_ERROR;
 
 	/* Ensure that the address returned is DMA'ble */
-	dma_addr = __phys_to_dma(dev, swiotlb_addr);
+	dma_addr = phys_to_dma_unencrypted(dev, swiotlb_addr);
 	if (unlikely(!dma_capable(dev, dma_addr, size, true))) {
 		swiotlb_tbl_unmap_single(dev, swiotlb_addr, size, size, dir,
 			attrs | DMA_ATTR_SKIP_CPU_SYNC);
