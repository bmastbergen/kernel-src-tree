KVM: VMX: Enable SGX virtualization for SGX1, SGX2 and LC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 72add915fbd5bf5c57deee3da5b2605e966ac199
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/72add915.failed

Enable SGX virtualization now that KVM has the VM-Exit handlers needed
to trap-and-execute ENCLS to ensure correctness and/or enforce the CPU
model exposed to the guest.  Add a KVM module param, "sgx", to allow an
admin to disable SGX virtualization independent of the kernel.

When supported in hardware and the kernel, advertise SGX1, SGX2 and SGX
LC to userspace via CPUID and wire up the ENCLS_EXITING bitmap based on
the guest's SGX capabilities, i.e. to allow ENCLS to be executed in an
SGX-enabled guest.  With the exception of the provision key, all SGX
attribute bits may be exposed to the guest.  Guest access to the
provision key, which is controlled via securityfs, will be added in a
future patch.

Note, KVM does not yet support exposing ENCLS_C leafs or ENCLV leafs.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Kai Huang <kai.huang@intel.com>
Message-Id: <a99e9c23310c79f2f4175c1af4c4cbcef913c3e5.1618196135.git.kai.huang@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 72add915fbd5bf5c57deee3da5b2605e966ac199)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/sgx.c
#	arch/x86/kvm/vmx/sgx.h
diff --cc arch/x86/kvm/vmx/sgx.c
index d874eb180b7d,6693ebdc0770..000000000000
--- a/arch/x86/kvm/vmx/sgx.c
+++ b/arch/x86/kvm/vmx/sgx.c
@@@ -9,8 -10,347 +10,9 @@@
  #include "vmx.h"
  #include "x86.h"
  
- bool __read_mostly enable_sgx;
+ bool __read_mostly enable_sgx = 1;
+ module_param_named(sgx, enable_sgx, bool, 0444);
  
 -/* Initial value of guest's virtual SGX_LEPUBKEYHASHn MSRs */
 -static u64 sgx_pubkey_hash[4] __ro_after_init;
 -
 -/*
 - * ENCLS's memory operands use a fixed segment (DS) and a fixed
 - * address size based on the mode.  Related prefixes are ignored.
 - */
 -static int sgx_get_encls_gva(struct kvm_vcpu *vcpu, unsigned long offset,
 -			     int size, int alignment, gva_t *gva)
 -{
 -	struct kvm_segment s;
 -	bool fault;
 -
 -	/* Skip vmcs.GUEST_DS retrieval for 64-bit mode to avoid VMREADs. */
 -	*gva = offset;
 -	if (!is_long_mode(vcpu)) {
 -		vmx_get_segment(vcpu, &s, VCPU_SREG_DS);
 -		*gva += s.base;
 -	}
 -
 -	if (!IS_ALIGNED(*gva, alignment)) {
 -		fault = true;
 -	} else if (likely(is_long_mode(vcpu))) {
 -		fault = is_noncanonical_address(*gva, vcpu);
 -	} else {
 -		*gva &= 0xffffffff;
 -		fault = (s.unusable) ||
 -			(s.type != 2 && s.type != 3) ||
 -			(*gva > s.limit) ||
 -			((s.base != 0 || s.limit != 0xffffffff) &&
 -			(((u64)*gva + size - 1) > s.limit + 1));
 -	}
 -	if (fault)
 -		kvm_inject_gp(vcpu, 0);
 -	return fault ? -EINVAL : 0;
 -}
 -
 -static void sgx_handle_emulation_failure(struct kvm_vcpu *vcpu, u64 addr,
 -					 unsigned int size)
 -{
 -	vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
 -	vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
 -	vcpu->run->internal.ndata = 2;
 -	vcpu->run->internal.data[0] = addr;
 -	vcpu->run->internal.data[1] = size;
 -}
 -
 -static int sgx_read_hva(struct kvm_vcpu *vcpu, unsigned long hva, void *data,
 -			unsigned int size)
 -{
 -	if (__copy_from_user(data, (void __user *)hva, size)) {
 -		sgx_handle_emulation_failure(vcpu, hva, size);
 -		return -EFAULT;
 -	}
 -
 -	return 0;
 -}
 -
 -static int sgx_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t gva, bool write,
 -			  gpa_t *gpa)
 -{
 -	struct x86_exception ex;
 -
 -	if (write)
 -		*gpa = kvm_mmu_gva_to_gpa_write(vcpu, gva, &ex);
 -	else
 -		*gpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, &ex);
 -
 -	if (*gpa == UNMAPPED_GVA) {
 -		kvm_inject_emulated_page_fault(vcpu, &ex);
 -		return -EFAULT;
 -	}
 -
 -	return 0;
 -}
 -
 -static int sgx_gpa_to_hva(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned long *hva)
 -{
 -	*hva = kvm_vcpu_gfn_to_hva(vcpu, PFN_DOWN(gpa));
 -	if (kvm_is_error_hva(*hva)) {
 -		sgx_handle_emulation_failure(vcpu, gpa, 1);
 -		return -EFAULT;
 -	}
 -
 -	*hva |= gpa & ~PAGE_MASK;
 -
 -	return 0;
 -}
 -
 -static int sgx_inject_fault(struct kvm_vcpu *vcpu, gva_t gva, int trapnr)
 -{
 -	struct x86_exception ex;
 -
 -	/*
 -	 * A non-EPCM #PF indicates a bad userspace HVA.  This *should* check
 -	 * for PFEC.SGX and not assume any #PF on SGX2 originated in the EPC,
 -	 * but the error code isn't (yet) plumbed through the ENCLS helpers.
 -	 */
 -	if (trapnr == PF_VECTOR && !boot_cpu_has(X86_FEATURE_SGX2)) {
 -		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
 -		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
 -		vcpu->run->internal.ndata = 0;
 -		return 0;
 -	}
 -
 -	/*
 -	 * If the guest thinks it's running on SGX2 hardware, inject an SGX
 -	 * #PF if the fault matches an EPCM fault signature (#GP on SGX1,
 -	 * #PF on SGX2).  The assumption is that EPCM faults are much more
 -	 * likely than a bad userspace address.
 -	 */
 -	if ((trapnr == PF_VECTOR || !boot_cpu_has(X86_FEATURE_SGX2)) &&
 -	    guest_cpuid_has(vcpu, X86_FEATURE_SGX2)) {
 -		memset(&ex, 0, sizeof(ex));
 -		ex.vector = PF_VECTOR;
 -		ex.error_code = PFERR_PRESENT_MASK | PFERR_WRITE_MASK |
 -				PFERR_SGX_MASK;
 -		ex.address = gva;
 -		ex.error_code_valid = true;
 -		ex.nested_page_fault = false;
 -		kvm_inject_page_fault(vcpu, &ex);
 -	} else {
 -		kvm_inject_gp(vcpu, 0);
 -	}
 -	return 1;
 -}
 -
 -static int __handle_encls_ecreate(struct kvm_vcpu *vcpu,
 -				  struct sgx_pageinfo *pageinfo,
 -				  unsigned long secs_hva,
 -				  gva_t secs_gva)
 -{
 -	struct sgx_secs *contents = (struct sgx_secs *)pageinfo->contents;
 -	struct kvm_cpuid_entry2 *sgx_12_0, *sgx_12_1;
 -	u64 attributes, xfrm, size;
 -	u32 miscselect;
 -	u8 max_size_log2;
 -	int trapnr, ret;
 -
 -	sgx_12_0 = kvm_find_cpuid_entry(vcpu, 0x12, 0);
 -	sgx_12_1 = kvm_find_cpuid_entry(vcpu, 0x12, 1);
 -	if (!sgx_12_0 || !sgx_12_1) {
 -		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
 -		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
 -		vcpu->run->internal.ndata = 0;
 -		return 0;
 -	}
 -
 -	miscselect = contents->miscselect;
 -	attributes = contents->attributes;
 -	xfrm = contents->xfrm;
 -	size = contents->size;
 -
 -	/* Enforce restriction of access to the PROVISIONKEY. */
 -	if (!vcpu->kvm->arch.sgx_provisioning_allowed &&
 -	    (attributes & SGX_ATTR_PROVISIONKEY)) {
 -		if (sgx_12_1->eax & SGX_ATTR_PROVISIONKEY)
 -			pr_warn_once("KVM: SGX PROVISIONKEY advertised but not allowed\n");
 -		kvm_inject_gp(vcpu, 0);
 -		return 1;
 -	}
 -
 -	/* Enforce CPUID restrictions on MISCSELECT, ATTRIBUTES and XFRM. */
 -	if ((u32)miscselect & ~sgx_12_0->ebx ||
 -	    (u32)attributes & ~sgx_12_1->eax ||
 -	    (u32)(attributes >> 32) & ~sgx_12_1->ebx ||
 -	    (u32)xfrm & ~sgx_12_1->ecx ||
 -	    (u32)(xfrm >> 32) & ~sgx_12_1->edx) {
 -		kvm_inject_gp(vcpu, 0);
 -		return 1;
 -	}
 -
 -	/* Enforce CPUID restriction on max enclave size. */
 -	max_size_log2 = (attributes & SGX_ATTR_MODE64BIT) ? sgx_12_0->edx >> 8 :
 -							    sgx_12_0->edx;
 -	if (size >= BIT_ULL(max_size_log2))
 -		kvm_inject_gp(vcpu, 0);
 -
 -	/*
 -	 * sgx_virt_ecreate() returns:
 -	 *  1) 0:	ECREATE was successful
 -	 *  2) -EFAULT:	ECREATE was run but faulted, and trapnr was set to the
 -	 *		exception number.
 -	 *  3) -EINVAL:	access_ok() on @secs_hva failed. This should never
 -	 *		happen as KVM checks host addresses at memslot creation.
 -	 *		sgx_virt_ecreate() has already warned in this case.
 -	 */
 -	ret = sgx_virt_ecreate(pageinfo, (void __user *)secs_hva, &trapnr);
 -	if (!ret)
 -		return kvm_skip_emulated_instruction(vcpu);
 -	if (ret == -EFAULT)
 -		return sgx_inject_fault(vcpu, secs_gva, trapnr);
 -
 -	return ret;
 -}
 -
 -static int handle_encls_ecreate(struct kvm_vcpu *vcpu)
 -{
 -	gva_t pageinfo_gva, secs_gva;
 -	gva_t metadata_gva, contents_gva;
 -	gpa_t metadata_gpa, contents_gpa, secs_gpa;
 -	unsigned long metadata_hva, contents_hva, secs_hva;
 -	struct sgx_pageinfo pageinfo;
 -	struct sgx_secs *contents;
 -	struct x86_exception ex;
 -	int r;
 -
 -	if (sgx_get_encls_gva(vcpu, kvm_rbx_read(vcpu), 32, 32, &pageinfo_gva) ||
 -	    sgx_get_encls_gva(vcpu, kvm_rcx_read(vcpu), 4096, 4096, &secs_gva))
 -		return 1;
 -
 -	/*
 -	 * Copy the PAGEINFO to local memory, its pointers need to be
 -	 * translated, i.e. we need to do a deep copy/translate.
 -	 */
 -	r = kvm_read_guest_virt(vcpu, pageinfo_gva, &pageinfo,
 -				sizeof(pageinfo), &ex);
 -	if (r == X86EMUL_PROPAGATE_FAULT) {
 -		kvm_inject_emulated_page_fault(vcpu, &ex);
 -		return 1;
 -	} else if (r != X86EMUL_CONTINUE) {
 -		sgx_handle_emulation_failure(vcpu, pageinfo_gva,
 -					     sizeof(pageinfo));
 -		return 0;
 -	}
 -
 -	if (sgx_get_encls_gva(vcpu, pageinfo.metadata, 64, 64, &metadata_gva) ||
 -	    sgx_get_encls_gva(vcpu, pageinfo.contents, 4096, 4096,
 -			      &contents_gva))
 -		return 1;
 -
 -	/*
 -	 * Translate the SECINFO, SOURCE and SECS pointers from GVA to GPA.
 -	 * Resume the guest on failure to inject a #PF.
 -	 */
 -	if (sgx_gva_to_gpa(vcpu, metadata_gva, false, &metadata_gpa) ||
 -	    sgx_gva_to_gpa(vcpu, contents_gva, false, &contents_gpa) ||
 -	    sgx_gva_to_gpa(vcpu, secs_gva, true, &secs_gpa))
 -		return 1;
 -
 -	/*
 -	 * ...and then to HVA.  The order of accesses isn't architectural, i.e.
 -	 * KVM doesn't have to fully process one address at a time.  Exit to
 -	 * userspace if a GPA is invalid.
 -	 */
 -	if (sgx_gpa_to_hva(vcpu, metadata_gpa, &metadata_hva) ||
 -	    sgx_gpa_to_hva(vcpu, contents_gpa, &contents_hva) ||
 -	    sgx_gpa_to_hva(vcpu, secs_gpa, &secs_hva))
 -		return 0;
 -
 -	/*
 -	 * Copy contents into kernel memory to prevent TOCTOU attack. E.g. the
 -	 * guest could do ECREATE w/ SECS.SGX_ATTR_PROVISIONKEY=0, and
 -	 * simultaneously set SGX_ATTR_PROVISIONKEY to bypass the check to
 -	 * enforce restriction of access to the PROVISIONKEY.
 -	 */
 -	contents = (struct sgx_secs *)__get_free_page(GFP_KERNEL_ACCOUNT);
 -	if (!contents)
 -		return -ENOMEM;
 -
 -	/* Exit to userspace if copying from a host userspace address fails. */
 -	if (sgx_read_hva(vcpu, contents_hva, (void *)contents, PAGE_SIZE)) {
 -		free_page((unsigned long)contents);
 -		return 0;
 -	}
 -
 -	pageinfo.metadata = metadata_hva;
 -	pageinfo.contents = (u64)contents;
 -
 -	r = __handle_encls_ecreate(vcpu, &pageinfo, secs_hva, secs_gva);
 -
 -	free_page((unsigned long)contents);
 -
 -	return r;
 -}
 -
 -static int handle_encls_einit(struct kvm_vcpu *vcpu)
 -{
 -	unsigned long sig_hva, secs_hva, token_hva, rflags;
 -	struct vcpu_vmx *vmx = to_vmx(vcpu);
 -	gva_t sig_gva, secs_gva, token_gva;
 -	gpa_t sig_gpa, secs_gpa, token_gpa;
 -	int ret, trapnr;
 -
 -	if (sgx_get_encls_gva(vcpu, kvm_rbx_read(vcpu), 1808, 4096, &sig_gva) ||
 -	    sgx_get_encls_gva(vcpu, kvm_rcx_read(vcpu), 4096, 4096, &secs_gva) ||
 -	    sgx_get_encls_gva(vcpu, kvm_rdx_read(vcpu), 304, 512, &token_gva))
 -		return 1;
 -
 -	/*
 -	 * Translate the SIGSTRUCT, SECS and TOKEN pointers from GVA to GPA.
 -	 * Resume the guest on failure to inject a #PF.
 -	 */
 -	if (sgx_gva_to_gpa(vcpu, sig_gva, false, &sig_gpa) ||
 -	    sgx_gva_to_gpa(vcpu, secs_gva, true, &secs_gpa) ||
 -	    sgx_gva_to_gpa(vcpu, token_gva, false, &token_gpa))
 -		return 1;
 -
 -	/*
 -	 * ...and then to HVA.  The order of accesses isn't architectural, i.e.
 -	 * KVM doesn't have to fully process one address at a time.  Exit to
 -	 * userspace if a GPA is invalid.  Note, all structures are aligned and
 -	 * cannot split pages.
 -	 */
 -	if (sgx_gpa_to_hva(vcpu, sig_gpa, &sig_hva) ||
 -	    sgx_gpa_to_hva(vcpu, secs_gpa, &secs_hva) ||
 -	    sgx_gpa_to_hva(vcpu, token_gpa, &token_hva))
 -		return 0;
 -
 -	ret = sgx_virt_einit((void __user *)sig_hva, (void __user *)token_hva,
 -			     (void __user *)secs_hva,
 -			     vmx->msr_ia32_sgxlepubkeyhash, &trapnr);
 -
 -	if (ret == -EFAULT)
 -		return sgx_inject_fault(vcpu, secs_gva, trapnr);
 -
 -	/*
 -	 * sgx_virt_einit() returns -EINVAL when access_ok() fails on @sig_hva,
 -	 * @token_hva or @secs_hva. This should never happen as KVM checks host
 -	 * addresses at memslot creation. sgx_virt_einit() has already warned
 -	 * in this case, so just return.
 -	 */
 -	if (ret < 0)
 -		return ret;
 -
 -	rflags = vmx_get_rflags(vcpu) & ~(X86_EFLAGS_CF | X86_EFLAGS_PF |
 -					  X86_EFLAGS_AF | X86_EFLAGS_SF |
 -					  X86_EFLAGS_OF);
 -	if (ret)
 -		rflags |= X86_EFLAGS_ZF;
 -	else
 -		rflags &= ~X86_EFLAGS_ZF;
 -	vmx_set_rflags(vcpu, rflags);
 -
 -	kvm_rax_write(vcpu, ret);
 -	return kvm_skip_emulated_instruction(vcpu);
 -}
 -
  static inline bool encls_leaf_enabled_in_guest(struct kvm_vcpu *vcpu, u32 leaf)
  {
  	if (!enable_sgx || !guest_cpuid_has(vcpu, X86_FEATURE_SGX))
@@@ -48,3 -392,111 +50,114 @@@ int handle_encls(struct kvm_vcpu *vcpu
  	}
  	return 1;
  }
++<<<<<<< HEAD
++=======
+ 
+ void setup_default_sgx_lepubkeyhash(void)
+ {
+ 	/*
+ 	 * Use Intel's default value for Skylake hardware if Launch Control is
+ 	 * not supported, i.e. Intel's hash is hardcoded into silicon, or if
+ 	 * Launch Control is supported and enabled, i.e. mimic the reset value
+ 	 * and let the guest write the MSRs at will.  If Launch Control is
+ 	 * supported but disabled, then use the current MSR values as the hash
+ 	 * MSRs exist but are read-only (locked and not writable).
+ 	 */
+ 	if (!enable_sgx || boot_cpu_has(X86_FEATURE_SGX_LC) ||
+ 	    rdmsrl_safe(MSR_IA32_SGXLEPUBKEYHASH0, &sgx_pubkey_hash[0])) {
+ 		sgx_pubkey_hash[0] = 0xa6053e051270b7acULL;
+ 		sgx_pubkey_hash[1] = 0x6cfbe8ba8b3b413dULL;
+ 		sgx_pubkey_hash[2] = 0xc4916d99f2b3735dULL;
+ 		sgx_pubkey_hash[3] = 0xd4f8c05909f9bb3bULL;
+ 	} else {
+ 		/* MSR_IA32_SGXLEPUBKEYHASH0 is read above */
+ 		rdmsrl(MSR_IA32_SGXLEPUBKEYHASH1, sgx_pubkey_hash[1]);
+ 		rdmsrl(MSR_IA32_SGXLEPUBKEYHASH2, sgx_pubkey_hash[2]);
+ 		rdmsrl(MSR_IA32_SGXLEPUBKEYHASH3, sgx_pubkey_hash[3]);
+ 	}
+ }
+ 
+ void vcpu_setup_sgx_lepubkeyhash(struct kvm_vcpu *vcpu)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 
+ 	memcpy(vmx->msr_ia32_sgxlepubkeyhash, sgx_pubkey_hash,
+ 	       sizeof(sgx_pubkey_hash));
+ }
+ 
+ /*
+  * ECREATE must be intercepted to enforce MISCSELECT, ATTRIBUTES and XFRM
+  * restrictions if the guest's allowed-1 settings diverge from hardware.
+  */
+ static bool sgx_intercept_encls_ecreate(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *guest_cpuid;
+ 	u32 eax, ebx, ecx, edx;
+ 
+ 	if (!vcpu->kvm->arch.sgx_provisioning_allowed)
+ 		return true;
+ 
+ 	guest_cpuid = kvm_find_cpuid_entry(vcpu, 0x12, 0);
+ 	if (!guest_cpuid)
+ 		return true;
+ 
+ 	cpuid_count(0x12, 0, &eax, &ebx, &ecx, &edx);
+ 	if (guest_cpuid->ebx != ebx || guest_cpuid->edx != edx)
+ 		return true;
+ 
+ 	guest_cpuid = kvm_find_cpuid_entry(vcpu, 0x12, 1);
+ 	if (!guest_cpuid)
+ 		return true;
+ 
+ 	cpuid_count(0x12, 1, &eax, &ebx, &ecx, &edx);
+ 	if (guest_cpuid->eax != eax || guest_cpuid->ebx != ebx ||
+ 	    guest_cpuid->ecx != ecx || guest_cpuid->edx != edx)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ void vmx_write_encls_bitmap(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
+ {
+ 	/*
+ 	 * There is no software enable bit for SGX that is virtualized by
+ 	 * hardware, e.g. there's no CR4.SGXE, so when SGX is disabled in the
+ 	 * guest (either by the host or by the guest's BIOS) but enabled in the
+ 	 * host, trap all ENCLS leafs and inject #UD/#GP as needed to emulate
+ 	 * the expected system behavior for ENCLS.
+ 	 */
+ 	u64 bitmap = -1ull;
+ 
+ 	/* Nothing to do if hardware doesn't support SGX */
+ 	if (!cpu_has_vmx_encls_vmexit())
+ 		return;
+ 
+ 	if (guest_cpuid_has(vcpu, X86_FEATURE_SGX) &&
+ 	    sgx_enabled_in_guest_bios(vcpu)) {
+ 		if (guest_cpuid_has(vcpu, X86_FEATURE_SGX1)) {
+ 			bitmap &= ~GENMASK_ULL(ETRACK, ECREATE);
+ 			if (sgx_intercept_encls_ecreate(vcpu))
+ 				bitmap |= (1 << ECREATE);
+ 		}
+ 
+ 		if (guest_cpuid_has(vcpu, X86_FEATURE_SGX2))
+ 			bitmap &= ~GENMASK_ULL(EMODT, EAUG);
+ 
+ 		/*
+ 		 * Trap and execute EINIT if launch control is enabled in the
+ 		 * host using the guest's values for launch control MSRs, even
+ 		 * if the guest's values are fixed to hardware default values.
+ 		 * The MSRs are not loaded/saved on VM-Enter/VM-Exit as writing
+ 		 * the MSRs is extraordinarily expensive.
+ 		 */
+ 		if (boot_cpu_has(X86_FEATURE_SGX_LC))
+ 			bitmap |= (1 << EINIT);
+ 
+ 		if (!vmcs12 && is_guest_mode(vcpu))
+ 			vmcs12 = get_vmcs12(vcpu);
+ 		if (vmcs12 && nested_cpu_has_encls_exit(vmcs12))
+ 			bitmap |= vmcs12->encls_exiting_bitmap;
+ 	}
+ 	vmcs_write64(ENCLS_EXITING_BITMAP, bitmap);
+ }
++>>>>>>> 72add915fbd5 (KVM: VMX: Enable SGX virtualization for SGX1, SGX2 and LC)
diff --cc arch/x86/kvm/vmx/sgx.h
index 6e17ecd4aca3,a400888b376d..000000000000
--- a/arch/x86/kvm/vmx/sgx.h
+++ b/arch/x86/kvm/vmx/sgx.h
@@@ -8,8 -11,24 +11,29 @@@
  extern bool __read_mostly enable_sgx;
  
  int handle_encls(struct kvm_vcpu *vcpu);
++<<<<<<< HEAD
 +#else
 +#define enable_sgx 0
++=======
+ 
+ void setup_default_sgx_lepubkeyhash(void);
+ void vcpu_setup_sgx_lepubkeyhash(struct kvm_vcpu *vcpu);
+ 
+ void vmx_write_encls_bitmap(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12);
+ #else
+ #define enable_sgx 0
+ 
+ static inline void setup_default_sgx_lepubkeyhash(void) { }
+ static inline void vcpu_setup_sgx_lepubkeyhash(struct kvm_vcpu *vcpu) { }
+ 
+ static inline void vmx_write_encls_bitmap(struct kvm_vcpu *vcpu,
+ 					  struct vmcs12 *vmcs12)
+ {
+ 	/* Nothing to do if hardware doesn't support SGX */
+ 	if (cpu_has_vmx_encls_vmexit())
+ 		vmcs_write64(ENCLS_EXITING_BITMAP, -1ull);
+ }
++>>>>>>> 72add915fbd5 (KVM: VMX: Enable SGX virtualization for SGX1, SGX2 and LC)
  #endif
  
  #endif /* __KVM_X86_SGX_H */
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index 6605e91db9d8..4839914fe217 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -18,6 +18,7 @@
 #include <asm/processor.h>
 #include <asm/user.h>
 #include <asm/fpu/xstate.h>
+#include <asm/sgx.h>
 #include "cpuid.h"
 #include "lapic.h"
 #include "mmu.h"
@@ -171,6 +172,21 @@ static void kvm_vcpu_after_set_cpuid(struct kvm_vcpu *vcpu)
 		vcpu->arch.guest_supported_xcr0 =
 			(best->eax | ((u64)best->edx << 32)) & supported_xcr0;
 
+	/*
+	 * Bits 127:0 of the allowed SECS.ATTRIBUTES (CPUID.0x12.0x1) enumerate
+	 * the supported XSAVE Feature Request Mask (XFRM), i.e. the enclave's
+	 * requested XCR0 value.  The enclave's XFRM must be a subset of XCRO
+	 * at the time of EENTER, thus adjust the allowed XFRM by the guest's
+	 * supported XCR0.  Similar to XCR0 handling, FP and SSE are forced to
+	 * '1' even on CPUs that don't support XSAVE.
+	 */
+	best = kvm_find_cpuid_entry(vcpu, 0x12, 0x1);
+	if (best) {
+		best->ecx &= vcpu->arch.guest_supported_xcr0 & 0xffffffff;
+		best->edx &= vcpu->arch.guest_supported_xcr0 >> 32;
+		best->ecx |= XFEATURE_MASK_FPSSE;
+	}
+
 	kvm_update_pv_runtime(vcpu);
 
 	vcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);
@@ -429,7 +445,7 @@ void kvm_set_cpu_caps(void)
 	);
 
 	kvm_cpu_cap_mask(CPUID_7_0_EBX,
-		F(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |
+		F(FSGSBASE) | F(SGX) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |
 		F(BMI2) | F(ERMS) | F(INVPCID) | F(RTM) | 0 /*MPX*/ | F(RDSEED) |
 		F(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |
 		F(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |
@@ -440,7 +456,8 @@ void kvm_set_cpu_caps(void)
 		F(AVX512VBMI) | F(LA57) | F(PKU) | 0 /*OSPKE*/ | F(RDPID) |
 		F(AVX512_VPOPCNTDQ) | F(UMIP) | F(AVX512_VBMI2) | F(GFNI) |
 		F(VAES) | F(VPCLMULQDQ) | F(AVX512_VNNI) | F(AVX512_BITALG) |
-		F(CLDEMOTE) | F(MOVDIRI) | F(MOVDIR64B) | 0 /*WAITPKG*/
+		F(CLDEMOTE) | F(MOVDIRI) | F(MOVDIR64B) | 0 /*WAITPKG*/ |
+		F(SGX_LC)
 	);
 	/* Set LA57 based on hardware capability. */
 	if (cpuid_ecx(7) & F(LA57))
@@ -479,6 +496,10 @@ void kvm_set_cpu_caps(void)
 		F(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | F(XSAVES)
 	);
 
+	kvm_cpu_cap_init_scattered(CPUID_12_EAX,
+		SF(SGX1) | SF(SGX2)
+	);
+
 	kvm_cpu_cap_mask(CPUID_8000_0001_ECX,
 		F(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |
 		F(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |
@@ -800,6 +821,38 @@ static inline int __do_cpuid_func(struct kvm_cpuid_array *array, u32 function)
 			entry->edx = 0;
 		}
 		break;
+	case 0x12:
+		/* Intel SGX */
+		if (!kvm_cpu_cap_has(X86_FEATURE_SGX)) {
+			entry->eax = entry->ebx = entry->ecx = entry->edx = 0;
+			break;
+		}
+
+		/*
+		 * Index 0: Sub-features, MISCSELECT (a.k.a extended features)
+		 * and max enclave sizes.   The SGX sub-features and MISCSELECT
+		 * are restricted by kernel and KVM capabilities (like most
+		 * feature flags), while enclave size is unrestricted.
+		 */
+		cpuid_entry_override(entry, CPUID_12_EAX);
+		entry->ebx &= SGX_MISC_EXINFO;
+
+		entry = do_host_cpuid(array, function, 1);
+		if (!entry)
+			goto out;
+
+		/*
+		 * Index 1: SECS.ATTRIBUTES.  ATTRIBUTES are restricted a la
+		 * feature flags.  Advertise all supported flags, including
+		 * privileged attributes that require explicit opt-in from
+		 * userspace.  ATTRIBUTES.XFRM is not adjusted as userspace is
+		 * expected to derive it from supported XCR0.
+		 */
+		entry->eax &= SGX_ATTR_DEBUG | SGX_ATTR_MODE64BIT |
+			      /* PROVISIONKEY | */ SGX_ATTR_EINITTOKENKEY |
+			      SGX_ATTR_KSS;
+		entry->ebx &= 0;
+		break;
 	/* Intel PT */
 	case 0x14:
 		if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT)) {
diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.c
index b06ca9487bfd..cb58f34cc3f9 100644
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@ -11,6 +11,7 @@
 #include "mmu.h"
 #include "nested.h"
 #include "pmu.h"
+#include "sgx.h"
 #include "trace.h"
 #include "vmx.h"
 #include "x86.h"
@@ -2300,6 +2301,9 @@ static void prepare_vmcs02_early(struct vcpu_vmx *vmx, struct vmcs12 *vmcs12)
 		if (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))
 		    exec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;
 
+		if (exec_control & SECONDARY_EXEC_ENCLS_EXITING)
+			vmx_write_encls_bitmap(&vmx->vcpu, vmcs12);
+
 		secondary_exec_controls_set(vmx, exec_control);
 	}
 
@@ -5712,6 +5716,21 @@ static bool nested_vmx_exit_handled_cr(struct kvm_vcpu *vcpu,
 	return false;
 }
 
+static bool nested_vmx_exit_handled_encls(struct kvm_vcpu *vcpu,
+					  struct vmcs12 *vmcs12)
+{
+	u32 encls_leaf;
+
+	if (!guest_cpuid_has(vcpu, X86_FEATURE_SGX) ||
+	    !nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENCLS_EXITING))
+		return false;
+
+	encls_leaf = kvm_rax_read(vcpu);
+	if (encls_leaf > 62)
+		encls_leaf = 63;
+	return vmcs12->encls_exiting_bitmap & BIT_ULL(encls_leaf);
+}
+
 static bool nested_vmx_exit_handled_vmcs_access(struct kvm_vcpu *vcpu,
 	struct vmcs12 *vmcs12, gpa_t bitmap)
 {
@@ -5808,9 +5827,6 @@ static bool nested_vmx_l0_wants_exit(struct kvm_vcpu *vcpu,
 	case EXIT_REASON_VMFUNC:
 		/* VM functions are emulated through L2->L0 vmexits. */
 		return true;
-	case EXIT_REASON_ENCLS:
-		/* SGX is never exposed to L1 */
-		return true;
 	default:
 		break;
 	}
@@ -5934,6 +5950,8 @@ static bool nested_vmx_l1_wants_exit(struct kvm_vcpu *vcpu,
 	case EXIT_REASON_TPAUSE:
 		return nested_cpu_has2(vmcs12,
 			SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE);
+	case EXIT_REASON_ENCLS:
+		return nested_vmx_exit_handled_encls(vcpu, vmcs12);
 	default:
 		return true;
 	}
@@ -6509,6 +6527,9 @@ void nested_vmx_setup_ctls_msrs(struct nested_vmx_msrs *msrs, u32 ept_caps)
 		msrs->secondary_ctls_high |=
 			SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
 
+	if (enable_sgx)
+		msrs->secondary_ctls_high |= SECONDARY_EXEC_ENCLS_EXITING;
+
 	/* miscellaneous data */
 	rdmsr(MSR_IA32_VMX_MISC,
 		msrs->misc_low,
diff --git a/arch/x86/kvm/vmx/nested.h b/arch/x86/kvm/vmx/nested.h
index 197148d76b8f..184418baeb3c 100644
--- a/arch/x86/kvm/vmx/nested.h
+++ b/arch/x86/kvm/vmx/nested.h
@@ -244,6 +244,11 @@ static inline bool nested_exit_on_intr(struct kvm_vcpu *vcpu)
 		PIN_BASED_EXT_INTR_MASK;
 }
 
+static inline bool nested_cpu_has_encls_exit(struct vmcs12 *vmcs12)
+{
+	return nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENCLS_EXITING);
+}
+
 /*
  * if fixed0[i] == 1: val[i] must be 1
  * if fixed1[i] == 0: val[i] must be 0
* Unmerged path arch/x86/kvm/vmx/sgx.c
* Unmerged path arch/x86/kvm/vmx/sgx.h
diff --git a/arch/x86/kvm/vmx/vmcs12.c b/arch/x86/kvm/vmx/vmcs12.c
index c8e51c004f78..034adb6404dc 100644
--- a/arch/x86/kvm/vmx/vmcs12.c
+++ b/arch/x86/kvm/vmx/vmcs12.c
@@ -50,6 +50,7 @@ const unsigned short vmcs_field_to_offset_table[] = {
 	FIELD64(VMREAD_BITMAP, vmread_bitmap),
 	FIELD64(VMWRITE_BITMAP, vmwrite_bitmap),
 	FIELD64(XSS_EXIT_BITMAP, xss_exit_bitmap),
+	FIELD64(ENCLS_EXITING_BITMAP, encls_exiting_bitmap),
 	FIELD64(GUEST_PHYSICAL_ADDRESS, guest_physical_address),
 	FIELD64(VMCS_LINK_POINTER, vmcs_link_pointer),
 	FIELD64(GUEST_IA32_DEBUGCTL, guest_ia32_debugctl),
diff --git a/arch/x86/kvm/vmx/vmcs12.h b/arch/x86/kvm/vmx/vmcs12.h
index 80232daf00ff..13494956d0e9 100644
--- a/arch/x86/kvm/vmx/vmcs12.h
+++ b/arch/x86/kvm/vmx/vmcs12.h
@@ -69,7 +69,8 @@ struct __packed vmcs12 {
 	u64 vm_function_control;
 	u64 eptp_list_address;
 	u64 pml_address;
-	u64 padding64[3]; /* room for future expansion */
+	u64 encls_exiting_bitmap;
+	u64 padding64[2]; /* room for future expansion */
 	/*
 	 * To allow migration of L1 (complete with its L2 guests) between
 	 * machines of different natural widths (32 or 64 bit), we cannot have
@@ -256,6 +257,7 @@ static inline void vmx_check_vmcs12_offsets(void)
 	CHECK_OFFSET(vm_function_control, 296);
 	CHECK_OFFSET(eptp_list_address, 304);
 	CHECK_OFFSET(pml_address, 312);
+	CHECK_OFFSET(encls_exiting_bitmap, 320);
 	CHECK_OFFSET(cr0_guest_host_mask, 344);
 	CHECK_OFFSET(cr4_guest_host_mask, 352);
 	CHECK_OFFSET(cr0_read_shadow, 360);
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 25d7dafe8b1a..3ddbde879475 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -2214,6 +2214,9 @@ static int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		vmx->msr_ia32_feature_control = data;
 		if (msr_info->host_initiated && data == 0)
 			vmx_leave_nested(vcpu);
+
+		/* SGX may be enabled/disabled by guest's firmware */
+		vmx_write_encls_bitmap(vcpu, NULL);
 		break;
 	case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:
 		if (!msr_info->host_initiated)
@@ -4450,8 +4453,7 @@ static void init_vmcs(struct vcpu_vmx *vmx)
 		vmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);
 	}
 
-	if (cpu_has_vmx_encls_vmexit())
-		vmcs_write64(ENCLS_EXITING_BITMAP, -1ull);
+	vmx_write_encls_bitmap(&vmx->vcpu, NULL);
 
 	if (vmx_pt_mode_is_host_guest()) {
 		memset(&vmx->pt_desc, 0, sizeof(vmx->pt_desc));
@@ -7279,6 +7281,19 @@ static void vmx_vcpu_after_set_cpuid(struct kvm_vcpu *vcpu)
 
 	set_cr4_guest_host_mask(vmx);
 
+	vmx_write_encls_bitmap(vcpu, NULL);
+	if (guest_cpuid_has(vcpu, X86_FEATURE_SGX))
+		vmx->msr_ia32_feature_control_valid_bits |= FEAT_CTL_SGX_ENABLED;
+	else
+		vmx->msr_ia32_feature_control_valid_bits &= ~FEAT_CTL_SGX_ENABLED;
+
+	if (guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC))
+		vmx->msr_ia32_feature_control_valid_bits |=
+			FEAT_CTL_SGX_LC_ENABLED;
+	else
+		vmx->msr_ia32_feature_control_valid_bits &=
+			~FEAT_CTL_SGX_LC_ENABLED;
+
 	/* Refresh #PF interception to account for MAXPHYADDR changes. */
 	vmx_update_exception_bitmap(vcpu);
 }
@@ -7299,6 +7314,13 @@ static __init void vmx_set_cpu_caps(void)
 	if (vmx_pt_mode_is_host_guest())
 		kvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);
 
+	if (!enable_sgx) {
+		kvm_cpu_cap_clear(X86_FEATURE_SGX);
+		kvm_cpu_cap_clear(X86_FEATURE_SGX_LC);
+		kvm_cpu_cap_clear(X86_FEATURE_SGX1);
+		kvm_cpu_cap_clear(X86_FEATURE_SGX2);
+	}
+
 	if (vmx_umip_emulated())
 		kvm_cpu_cap_set(X86_FEATURE_UMIP);
 
