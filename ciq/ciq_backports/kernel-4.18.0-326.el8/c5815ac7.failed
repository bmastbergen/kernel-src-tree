samples: bpf: Refactor hbm program with libbpf

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Daniel T. Lee <danieltimlee@gmail.com>
commit c5815ac7e2aaff4f00b2b9e21d84b9f2fddddb48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/c5815ac7.failed

This commit refactors the existing cgroup programs with libbpf
bpf loader. Since bpf_program__attach doesn't support cgroup program
attachment, this explicitly attaches cgroup bpf program with
bpf_program__attach_cgroup(bpf_prog, cg1).

Also, to change attach_type of bpf program, this uses libbpf's
bpf_program__set_expected_attach_type helper to switch EGRESS to
INGRESS. To keep bpf program attached to the cgroup hierarchy even
after the exit, this commit uses the BPF_LINK_PINNING to pin the link
attachment even after it is closed.

Besides, this program was broken due to the typo of BPF MAP definition.
But this commit solves the problem by fixing this from 'queue_stats' map
struct hvm_queue_stats -> hbm_queue_stats.

Fixes: 36b5d471135c ("selftests/bpf: samples/bpf: Split off legacy stuff from bpf_helpers.h")
	Signed-off-by: Daniel T. Lee <danieltimlee@gmail.com>
	Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
Link: https://lore.kernel.org/bpf/20201124090310.24374-2-danieltimlee@gmail.com
(cherry picked from commit c5815ac7e2aaff4f00b2b9e21d84b9f2fddddb48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	samples/bpf/Makefile
diff --cc samples/bpf/Makefile
index cd1f5b1161d2,7c61118525f7..000000000000
--- a/samples/bpf/Makefile
+++ b/samples/bpf/Makefile
@@@ -108,67 -109,69 +108,72 @@@ xsk_fwd-objs := xsk_fwd.
  xdp_fwd-objs := xdp_fwd_user.o
  task_fd_query-objs := bpf_load.o task_fd_query_user.o $(TRACE_HELPERS)
  xdp_sample_pkts-objs := xdp_sample_pkts_user.o $(TRACE_HELPERS)
++<<<<<<< HEAD
 +hbm-objs := bpf_load.o hbm.o $(CGROUP_HELPERS)
++=======
+ ibumad-objs := bpf_load.o ibumad_user.o $(TRACE_HELPERS)
+ hbm-objs := hbm.o $(CGROUP_HELPERS)
++>>>>>>> c5815ac7e2aa (samples: bpf: Refactor hbm program with libbpf)
  
  # Tell kbuild to always build the programs
 -always-y := $(tprogs-y)
 -always-y += sockex1_kern.o
 -always-y += sockex2_kern.o
 -always-y += sockex3_kern.o
 -always-y += tracex1_kern.o
 -always-y += tracex2_kern.o
 -always-y += tracex3_kern.o
 -always-y += tracex4_kern.o
 -always-y += tracex5_kern.o
 -always-y += tracex6_kern.o
 -always-y += tracex7_kern.o
 -always-y += sock_flags_kern.o
 -always-y += test_probe_write_user_kern.o
 -always-y += trace_output_kern.o
 -always-y += tcbpf1_kern.o
 -always-y += tc_l2_redirect_kern.o
 -always-y += lathist_kern.o
 -always-y += offwaketime_kern.o
 -always-y += spintest_kern.o
 -always-y += map_perf_test_kern.o
 -always-y += test_overhead_tp_kern.o
 -always-y += test_overhead_raw_tp_kern.o
 -always-y += test_overhead_kprobe_kern.o
 -always-y += parse_varlen.o parse_simple.o parse_ldabs.o
 -always-y += test_cgrp2_tc_kern.o
 -always-y += xdp1_kern.o
 -always-y += xdp2_kern.o
 -always-y += xdp_router_ipv4_kern.o
 -always-y += test_current_task_under_cgroup_kern.o
 -always-y += trace_event_kern.o
 -always-y += sampleip_kern.o
 -always-y += lwt_len_hist_kern.o
 -always-y += xdp_tx_iptunnel_kern.o
 -always-y += test_map_in_map_kern.o
 -always-y += tcp_synrto_kern.o
 -always-y += tcp_rwnd_kern.o
 -always-y += tcp_bufs_kern.o
 -always-y += tcp_cong_kern.o
 -always-y += tcp_iw_kern.o
 -always-y += tcp_clamp_kern.o
 -always-y += tcp_basertt_kern.o
 -always-y += tcp_tos_reflect_kern.o
 -always-y += tcp_dumpstats_kern.o
 -always-y += xdp_redirect_kern.o
 -always-y += xdp_redirect_map_kern.o
 -always-y += xdp_redirect_cpu_kern.o
 -always-y += xdp_monitor_kern.o
 -always-y += xdp_rxq_info_kern.o
 -always-y += xdp2skb_meta_kern.o
 -always-y += syscall_tp_kern.o
 -always-y += cpustat_kern.o
 -always-y += xdp_adjust_tail_kern.o
 -always-y += xdp_fwd_kern.o
 -always-y += task_fd_query_kern.o
 -always-y += xdp_sample_pkts_kern.o
 -always-y += ibumad_kern.o
 -always-y += hbm_out_kern.o
 -always-y += hbm_edt_kern.o
 -always-y += xdpsock_kern.o
 +always := $(tprogs-y)
 +always += sockex1_kern.o
 +always += sockex2_kern.o
 +always += sockex3_kern.o
 +always += tracex1_kern.o
 +always += tracex2_kern.o
 +always += tracex3_kern.o
 +always += tracex4_kern.o
 +always += tracex5_kern.o
 +always += tracex6_kern.o
 +always += tracex7_kern.o
 +always += sock_flags_kern.o
 +always += test_probe_write_user_kern.o
 +always += trace_output_kern.o
 +always += tcbpf1_kern.o
 +always += tc_l2_redirect_kern.o
 +always += lathist_kern.o
 +always += offwaketime_kern.o
 +always += spintest_kern.o
 +always += map_perf_test_kern.o
 +always += test_overhead_tp_kern.o
 +always += test_overhead_raw_tp_kern.o
 +always += test_overhead_kprobe_kern.o
 +always += parse_varlen.o parse_simple.o parse_ldabs.o
 +always += test_cgrp2_tc_kern.o
 +always += xdp1_kern.o
 +always += xdp2_kern.o
 +always += xdp_router_ipv4_kern.o
 +always += test_current_task_under_cgroup_kern.o
 +always += trace_event_kern.o
 +always += sampleip_kern.o
 +always += lwt_len_hist_kern.o
 +always += xdp_tx_iptunnel_kern.o
 +always += test_map_in_map_kern.o
 +always += tcp_synrto_kern.o
 +always += tcp_rwnd_kern.o
 +always += tcp_bufs_kern.o
 +always += tcp_cong_kern.o
 +always += tcp_iw_kern.o
 +always += tcp_clamp_kern.o
 +always += tcp_basertt_kern.o
 +always += tcp_tos_reflect_kern.o
 +always += tcp_dumpstats_kern.o
 +always += xdp_redirect_kern.o
 +always += xdp_redirect_map_kern.o
 +always += xdp_redirect_cpu_kern.o
 +always += xdp_monitor_kern.o
 +always += xdp_rxq_info_kern.o
 +always += xdp2skb_meta_kern.o
 +always += syscall_tp_kern.o
 +always += cpustat_kern.o
 +always += xdp_adjust_tail_kern.o
 +always += xdp_fwd_kern.o
 +always += task_fd_query_kern.o
 +always += xdp_sample_pkts_kern.o
 +always += hbm_out_kern.o
 +always += hbm_edt_kern.o
 +always += xdpsock_kern.o
  
  ifeq ($(ARCH), arm)
  # Strip all except -D__LINUX_ARM_ARCH__ option needed to handle linux
diff --git a/samples/bpf/.gitignore b/samples/bpf/.gitignore
index 1ca84d488a2f..9d59aecc8ec9 100644
--- a/samples/bpf/.gitignore
+++ b/samples/bpf/.gitignore
@@ -51,3 +51,6 @@ xdp_tx_iptunnel
 xdpsock
 xsk_fwd
 testfile.img
+hbm_out.log
+iperf.*
+*.out
* Unmerged path samples/bpf/Makefile
diff --git a/samples/bpf/do_hbm_test.sh b/samples/bpf/do_hbm_test.sh
index ffe4c0607341..21790ea5c460 100755
--- a/samples/bpf/do_hbm_test.sh
+++ b/samples/bpf/do_hbm_test.sh
@@ -91,6 +91,16 @@ qdisc=""
 flags=""
 do_stats=0
 
+BPFFS=/sys/fs/bpf
+function config_bpffs () {
+	if mount | grep $BPFFS > /dev/null; then
+		echo "bpffs already mounted"
+	else
+		echo "bpffs not mounted. Mounting..."
+		mount -t bpf none $BPFFS
+	fi
+}
+
 function start_hbm () {
   rm -f hbm.out
   echo "./hbm $dir -n $id -r $rate -t $dur $flags $dbg $prog" > hbm.out
@@ -192,6 +202,7 @@ processArgs () {
 }
 
 processArgs
+config_bpffs
 
 if [ $debug_flag -eq 1 ] ; then
   rm -f hbm_out.log
@@ -201,7 +212,7 @@ hbm_pid=$(start_hbm)
 usleep 100000
 
 host=`hostname`
-cg_base_dir=/sys/fs/cgroup
+cg_base_dir=/sys/fs/cgroup/unified
 cg_dir="$cg_base_dir/cgroup-test-work-dir/hbm$id"
 
 echo $$ >> $cg_dir/cgroup.procs
@@ -411,23 +422,8 @@ fi
 
 sleep 1
 
-# Detach any BPF programs that may have lingered
-ttx=`bpftool cgroup tree | grep hbm`
-v=2
-for x in $ttx ; do
-    if [ "${x:0:36}" == "/sys/fs/cgroup/cgroup-test-work-dir/" ] ; then
-	cg=$x ; v=0
-    else
-	if [ $v -eq 0 ] ; then
-	    id=$x ; v=1
-	else
-	    if [ $v -eq 1 ] ; then
-		type=$x ; bpftool cgroup detach $cg $type id $id
-		v=0
-	    fi
-	fi
-    fi
-done
+# Detach any pinned BPF programs that may have lingered
+rm -rf $BPFFS/hbm*
 
 if [ $use_netperf -ne 0 ] ; then
   if [ "$server" == "" ] ; then
diff --git a/samples/bpf/hbm.c b/samples/bpf/hbm.c
index 400e741a56eb..b0c18efe7928 100644
--- a/samples/bpf/hbm.c
+++ b/samples/bpf/hbm.c
@@ -46,7 +46,6 @@
 #include <bpf/bpf.h>
 #include <getopt.h>
 
-#include "bpf_load.h"
 #include "bpf_rlimit.h"
 #include "cgroup_helpers.h"
 #include "hbm.h"
@@ -70,9 +69,9 @@ static void do_error(char *msg, bool errno_flag);
 
 #define DEBUGFS "/sys/kernel/debug/tracing/"
 
-struct bpf_object *obj;
-int bpfprog_fd;
-int cgroup_storage_fd;
+static struct bpf_program *bpf_prog;
+static struct bpf_object *obj;
+static int queue_stats_fd;
 
 static void read_trace_pipe2(void)
 {
@@ -121,56 +120,50 @@ static void do_error(char *msg, bool errno_flag)
 
 static int prog_load(char *prog)
 {
-	struct bpf_prog_load_attr prog_load_attr = {
-		.prog_type = BPF_PROG_TYPE_CGROUP_SKB,
-		.file = prog,
-		.expected_attach_type = BPF_CGROUP_INET_EGRESS,
-	};
-	int map_fd;
-	struct bpf_map *map;
-
-	int ret = 0;
-
-	if (access(prog, O_RDONLY) < 0) {
-		printf("Error accessing file %s: %s\n", prog, strerror(errno));
+	obj = bpf_object__open_file(prog, NULL);
+	if (libbpf_get_error(obj)) {
+		printf("ERROR: opening BPF object file failed\n");
 		return 1;
 	}
-	if (bpf_prog_load_xattr(&prog_load_attr, &obj, &bpfprog_fd))
-		ret = 1;
-	if (!ret) {
-		map = bpf_object__find_map_by_name(obj, "queue_stats");
-		map_fd = bpf_map__fd(map);
-		if (map_fd < 0) {
-			printf("Map not found: %s\n", strerror(map_fd));
-			ret = 1;
-		}
+
+	/* load BPF program */
+	if (bpf_object__load(obj)) {
+		printf("ERROR: loading BPF object file failed\n");
+		goto err;
 	}
 
-	if (ret) {
-		printf("ERROR: bpf_prog_load_xattr failed for: %s\n", prog);
-		printf("  Output from verifier:\n%s\n------\n", bpf_log_buf);
-		ret = -1;
-	} else {
-		ret = map_fd;
+	bpf_prog = bpf_object__find_program_by_title(obj, "cgroup_skb/egress");
+	if (!bpf_prog) {
+		printf("ERROR: finding a prog in obj file failed\n");
+		goto err;
+	}
+
+	queue_stats_fd = bpf_object__find_map_fd_by_name(obj, "queue_stats");
+	if (queue_stats_fd < 0) {
+		printf("ERROR: finding a map in obj file failed\n");
+		goto err;
 	}
 
-	return ret;
+	return 0;
+
+err:
+	bpf_object__close(obj);
+	return 1;
 }
 
 static int run_bpf_prog(char *prog, int cg_id)
 {
-	int map_fd;
-	int rc = 0;
+	struct hbm_queue_stats qstats = {0};
+	char cg_dir[100], cg_pin_path[100];
+	struct bpf_link *link = NULL;
 	int key = 0;
 	int cg1 = 0;
-	int type = BPF_CGROUP_INET_EGRESS;
-	char cg_dir[100];
-	struct hbm_queue_stats qstats = {0};
+	int rc = 0;
 
 	sprintf(cg_dir, "/hbm%d", cg_id);
-	map_fd = prog_load(prog);
-	if (map_fd  == -1)
-		return 1;
+	rc = prog_load(prog);
+	if (rc != 0)
+		return rc;
 
 	if (setup_cgroup_environment()) {
 		printf("ERROR: setting cgroup environment\n");
@@ -190,16 +183,24 @@ static int run_bpf_prog(char *prog, int cg_id)
 	qstats.stats = stats_flag ? 1 : 0;
 	qstats.loopback = loopback_flag ? 1 : 0;
 	qstats.no_cn = no_cn_flag ? 1 : 0;
-	if (bpf_map_update_elem(map_fd, &key, &qstats, BPF_ANY)) {
+	if (bpf_map_update_elem(queue_stats_fd, &key, &qstats, BPF_ANY)) {
 		printf("ERROR: Could not update map element\n");
 		goto err;
 	}
 
 	if (!outFlag)
-		type = BPF_CGROUP_INET_INGRESS;
-	if (bpf_prog_attach(bpfprog_fd, cg1, type, 0)) {
-		printf("ERROR: bpf_prog_attach fails!\n");
-		log_err("Attaching prog");
+		bpf_program__set_expected_attach_type(bpf_prog, BPF_CGROUP_INET_INGRESS);
+
+	link = bpf_program__attach_cgroup(bpf_prog, cg1);
+	if (libbpf_get_error(link)) {
+		fprintf(stderr, "ERROR: bpf_program__attach_cgroup failed\n");
+		goto err;
+	}
+
+	sprintf(cg_pin_path, "/sys/fs/bpf/hbm%d", cg_id);
+	rc = bpf_link__pin(link, cg_pin_path);
+	if (rc < 0) {
+		printf("ERROR: bpf_link__pin failed: %d\n", rc);
 		goto err;
 	}
 
@@ -213,7 +214,7 @@ static int run_bpf_prog(char *prog, int cg_id)
 #define DELTA_RATE_CHECK 10000		/* in us */
 #define RATE_THRESHOLD 9500000000	/* 9.5 Gbps */
 
-		bpf_map_lookup_elem(map_fd, &key, &qstats);
+		bpf_map_lookup_elem(queue_stats_fd, &key, &qstats);
 		if (gettimeofday(&t0, NULL) < 0)
 			do_error("gettimeofday failed", true);
 		t_last = t0;
@@ -242,7 +243,7 @@ static int run_bpf_prog(char *prog, int cg_id)
 			fclose(fin);
 			printf("  new_eth_tx_bytes:%llu\n",
 			       new_eth_tx_bytes);
-			bpf_map_lookup_elem(map_fd, &key, &qstats);
+			bpf_map_lookup_elem(queue_stats_fd, &key, &qstats);
 			new_cg_tx_bytes = qstats.bytes_total;
 			delta_bytes = new_eth_tx_bytes - last_eth_tx_bytes;
 			last_eth_tx_bytes = new_eth_tx_bytes;
@@ -289,14 +290,14 @@ static int run_bpf_prog(char *prog, int cg_id)
 					rate = minRate;
 				qstats.rate = rate;
 			}
-			if (bpf_map_update_elem(map_fd, &key, &qstats, BPF_ANY))
+			if (bpf_map_update_elem(queue_stats_fd, &key, &qstats, BPF_ANY))
 				do_error("update map element fails", false);
 		}
 	} else {
 		sleep(dur);
 	}
 	// Get stats!
-	if (stats_flag && bpf_map_lookup_elem(map_fd, &key, &qstats)) {
+	if (stats_flag && bpf_map_lookup_elem(queue_stats_fd, &key, &qstats)) {
 		char fname[100];
 		FILE *fout;
 
@@ -394,14 +395,20 @@ static int run_bpf_prog(char *prog, int cg_id)
 
 	if (debugFlag)
 		read_trace_pipe2();
-	return rc;
+	goto cleanup;
+
 err:
 	rc = 1;
 
-	if (cg1)
+cleanup:
+	bpf_link__destroy(link);
+	bpf_object__close(obj);
+
+	if (cg1 != -1)
 		close(cg1);
-	cleanup_cgroup_environment();
 
+	if (rc != 0)
+		cleanup_cgroup_environment();
 	return rc;
 }
 
diff --git a/samples/bpf/hbm_kern.h b/samples/bpf/hbm_kern.h
index e00f26f6afba..722b3fadb467 100644
--- a/samples/bpf/hbm_kern.h
+++ b/samples/bpf/hbm_kern.h
@@ -69,7 +69,7 @@ struct {
 	__uint(type, BPF_MAP_TYPE_ARRAY);
 	__uint(max_entries, 1);
 	__type(key, u32);
-	__type(value, struct hvm_queue_stats);
+	__type(value, struct hbm_queue_stats);
 } queue_stats SEC(".maps");
 
 struct hbm_pkt_info {
