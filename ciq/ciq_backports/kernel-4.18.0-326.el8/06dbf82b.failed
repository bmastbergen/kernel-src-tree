xfs: trace timestamp limits

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 06dbf82b044cbc268612958af0bc6c3529385ca0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/06dbf82b.failed

Add a couple of tracepoints so that we can check the timestamp limits
being set on inodes and quotas.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Allison Collins <allison.henderson@oracle.com>
	Reviewed-by: Gao Xiang <hsiangkao@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 06dbf82b044cbc268612958af0bc6c3529385ca0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_qm.c
#	fs/xfs/xfs_super.c
#	fs/xfs/xfs_trace.h
diff --cc fs/xfs/xfs_qm.c
index ebb106499144,3f82e0c92c2d..000000000000
--- a/fs/xfs/xfs_qm.c
+++ b/fs/xfs/xfs_qm.c
@@@ -661,6 -661,17 +661,20 @@@ xfs_qm_init_quotainfo
  	/* Precalc some constants */
  	qinf->qi_dqchunklen = XFS_FSB_TO_BB(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);
  	qinf->qi_dqperchunk = xfs_calc_dquots_per_chunk(qinf->qi_dqchunklen);
++<<<<<<< HEAD
++=======
+ 	if (xfs_sb_version_hasbigtime(&mp->m_sb)) {
+ 		qinf->qi_expiry_min =
+ 			xfs_dq_bigtime_to_unix(XFS_DQ_BIGTIME_EXPIRY_MIN);
+ 		qinf->qi_expiry_max =
+ 			xfs_dq_bigtime_to_unix(XFS_DQ_BIGTIME_EXPIRY_MAX);
+ 	} else {
+ 		qinf->qi_expiry_min = XFS_DQ_LEGACY_EXPIRY_MIN;
+ 		qinf->qi_expiry_max = XFS_DQ_LEGACY_EXPIRY_MAX;
+ 	}
+ 	trace_xfs_quota_expiry_range(mp, qinf->qi_expiry_min,
+ 			qinf->qi_expiry_max);
++>>>>>>> 06dbf82b044c (xfs: trace timestamp limits)
  
  	mp->m_qflags |= (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_CHKD);
  
diff --cc fs/xfs/xfs_super.c
index 667d38f17ae1,baf5de30eebb..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1498,8 -1484,14 +1498,19 @@@ xfs_fc_fill_super
  	sb->s_maxbytes = MAX_LFS_FILESIZE;
  	sb->s_max_links = XFS_MAXLINK;
  	sb->s_time_gran = 1;
++<<<<<<< HEAD
 +	sb->s_time_min = XFS_LEGACY_TIME_MIN;
 +	sb->s_time_max = XFS_LEGACY_TIME_MAX;
++=======
+ 	if (xfs_sb_version_hasbigtime(&mp->m_sb)) {
+ 		sb->s_time_min = xfs_bigtime_to_unix(XFS_BIGTIME_TIME_MIN);
+ 		sb->s_time_max = xfs_bigtime_to_unix(XFS_BIGTIME_TIME_MAX);
+ 	} else {
+ 		sb->s_time_min = XFS_LEGACY_TIME_MIN;
+ 		sb->s_time_max = XFS_LEGACY_TIME_MAX;
+ 	}
+ 	trace_xfs_inode_timestamp_range(mp, sb->s_time_min, sb->s_time_max);
++>>>>>>> 06dbf82b044c (xfs: trace timestamp limits)
  	sb->s_iflags |= SB_I_CGROUPWB;
  
  	set_posix_acl_flag(sb);
diff --cc fs/xfs/xfs_trace.h
index bc5b3eeb83fe,dcdcf99cfa5d..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -3552,6 -3698,177 +3552,180 @@@ TRACE_EVENT(xfs_check_new_dalign
  		  __entry->calc_rootino)
  )
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(xfs_btree_commit_afakeroot,
+ 	TP_PROTO(struct xfs_btree_cur *cur),
+ 	TP_ARGS(cur),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_btnum_t, btnum)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(unsigned int, levels)
+ 		__field(unsigned int, blocks)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = cur->bc_mp->m_super->s_dev;
+ 		__entry->btnum = cur->bc_btnum;
+ 		__entry->agno = cur->bc_ag.agno;
+ 		__entry->agbno = cur->bc_ag.afake->af_root;
+ 		__entry->levels = cur->bc_ag.afake->af_levels;
+ 		__entry->blocks = cur->bc_ag.afake->af_blocks;
+ 	),
+ 	TP_printk("dev %d:%d btree %s ag %u levels %u blocks %u root %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __print_symbolic(__entry->btnum, XFS_BTNUM_STRINGS),
+ 		  __entry->agno,
+ 		  __entry->levels,
+ 		  __entry->blocks,
+ 		  __entry->agbno)
+ )
+ 
+ TRACE_EVENT(xfs_btree_commit_ifakeroot,
+ 	TP_PROTO(struct xfs_btree_cur *cur),
+ 	TP_ARGS(cur),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_btnum_t, btnum)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agino_t, agino)
+ 		__field(unsigned int, levels)
+ 		__field(unsigned int, blocks)
+ 		__field(int, whichfork)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = cur->bc_mp->m_super->s_dev;
+ 		__entry->btnum = cur->bc_btnum;
+ 		__entry->agno = XFS_INO_TO_AGNO(cur->bc_mp,
+ 					cur->bc_ino.ip->i_ino);
+ 		__entry->agino = XFS_INO_TO_AGINO(cur->bc_mp,
+ 					cur->bc_ino.ip->i_ino);
+ 		__entry->levels = cur->bc_ino.ifake->if_levels;
+ 		__entry->blocks = cur->bc_ino.ifake->if_blocks;
+ 		__entry->whichfork = cur->bc_ino.whichfork;
+ 	),
+ 	TP_printk("dev %d:%d btree %s ag %u agino %u whichfork %s levels %u blocks %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __print_symbolic(__entry->btnum, XFS_BTNUM_STRINGS),
+ 		  __entry->agno,
+ 		  __entry->agino,
+ 		  __entry->whichfork == XFS_ATTR_FORK ? "attr" : "data",
+ 		  __entry->levels,
+ 		  __entry->blocks)
+ )
+ 
+ TRACE_EVENT(xfs_btree_bload_level_geometry,
+ 	TP_PROTO(struct xfs_btree_cur *cur, unsigned int level,
+ 		 uint64_t nr_this_level, unsigned int nr_per_block,
+ 		 unsigned int desired_npb, uint64_t blocks,
+ 		 uint64_t blocks_with_extra),
+ 	TP_ARGS(cur, level, nr_this_level, nr_per_block, desired_npb, blocks,
+ 		blocks_with_extra),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_btnum_t, btnum)
+ 		__field(unsigned int, level)
+ 		__field(unsigned int, nlevels)
+ 		__field(uint64_t, nr_this_level)
+ 		__field(unsigned int, nr_per_block)
+ 		__field(unsigned int, desired_npb)
+ 		__field(unsigned long long, blocks)
+ 		__field(unsigned long long, blocks_with_extra)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = cur->bc_mp->m_super->s_dev;
+ 		__entry->btnum = cur->bc_btnum;
+ 		__entry->level = level;
+ 		__entry->nlevels = cur->bc_nlevels;
+ 		__entry->nr_this_level = nr_this_level;
+ 		__entry->nr_per_block = nr_per_block;
+ 		__entry->desired_npb = desired_npb;
+ 		__entry->blocks = blocks;
+ 		__entry->blocks_with_extra = blocks_with_extra;
+ 	),
+ 	TP_printk("dev %d:%d btree %s level %u/%u nr_this_level %llu nr_per_block %u desired_npb %u blocks %llu blocks_with_extra %llu",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __print_symbolic(__entry->btnum, XFS_BTNUM_STRINGS),
+ 		  __entry->level,
+ 		  __entry->nlevels,
+ 		  __entry->nr_this_level,
+ 		  __entry->nr_per_block,
+ 		  __entry->desired_npb,
+ 		  __entry->blocks,
+ 		  __entry->blocks_with_extra)
+ )
+ 
+ TRACE_EVENT(xfs_btree_bload_block,
+ 	TP_PROTO(struct xfs_btree_cur *cur, unsigned int level,
+ 		 uint64_t block_idx, uint64_t nr_blocks,
+ 		 union xfs_btree_ptr *ptr, unsigned int nr_records),
+ 	TP_ARGS(cur, level, block_idx, nr_blocks, ptr, nr_records),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_btnum_t, btnum)
+ 		__field(unsigned int, level)
+ 		__field(unsigned long long, block_idx)
+ 		__field(unsigned long long, nr_blocks)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(unsigned int, nr_records)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = cur->bc_mp->m_super->s_dev;
+ 		__entry->btnum = cur->bc_btnum;
+ 		__entry->level = level;
+ 		__entry->block_idx = block_idx;
+ 		__entry->nr_blocks = nr_blocks;
+ 		if (cur->bc_flags & XFS_BTREE_LONG_PTRS) {
+ 			xfs_fsblock_t	fsb = be64_to_cpu(ptr->l);
+ 
+ 			__entry->agno = XFS_FSB_TO_AGNO(cur->bc_mp, fsb);
+ 			__entry->agbno = XFS_FSB_TO_AGBNO(cur->bc_mp, fsb);
+ 		} else {
+ 			__entry->agno = cur->bc_ag.agno;
+ 			__entry->agbno = be32_to_cpu(ptr->s);
+ 		}
+ 		__entry->nr_records = nr_records;
+ 	),
+ 	TP_printk("dev %d:%d btree %s level %u block %llu/%llu fsb (%u/%u) recs %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __print_symbolic(__entry->btnum, XFS_BTNUM_STRINGS),
+ 		  __entry->level,
+ 		  __entry->block_idx,
+ 		  __entry->nr_blocks,
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __entry->nr_records)
+ )
+ 
+ DECLARE_EVENT_CLASS(xfs_timestamp_range_class,
+ 	TP_PROTO(struct xfs_mount *mp, time64_t min, time64_t max),
+ 	TP_ARGS(mp, min, max),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(long long, min)
+ 		__field(long long, max)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->min = min;
+ 		__entry->max = max;
+ 	),
+ 	TP_printk("dev %d:%d min %lld max %lld",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->min,
+ 		  __entry->max)
+ )
+ 
+ #define DEFINE_TIMESTAMP_RANGE_EVENT(name) \
+ DEFINE_EVENT(xfs_timestamp_range_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, long long min, long long max), \
+ 	TP_ARGS(mp, min, max))
+ DEFINE_TIMESTAMP_RANGE_EVENT(xfs_inode_timestamp_range);
+ DEFINE_TIMESTAMP_RANGE_EVENT(xfs_quota_expiry_range);
+ 
++>>>>>>> 06dbf82b044c (xfs: trace timestamp limits)
  #endif /* _TRACE_XFS_H */
  
  #undef TRACE_INCLUDE_PATH
* Unmerged path fs/xfs/xfs_qm.c
* Unmerged path fs/xfs/xfs_super.c
* Unmerged path fs/xfs/xfs_trace.h
