mm: remove the HMM config option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 43535b0aefab29ea6564e608de4c783ed2ab6c49
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/43535b0a.failed

All the mm/hmm.c code is better keyed off HMM_MIRROR.  Also let nouveau
depend on it instead of the mix of a dummy dependency symbol plus the
actually selected one.  Drop various odd dependencies, as the code is
pretty portable.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 43535b0aefab29ea6564e608de4c783ed2ab6c49)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/Kconfig
#	mm/Kconfig
#	mm/Makefile
diff --cc drivers/gpu/drm/nouveau/Kconfig
index 5dec1e5694b7,66c839d8e9d1..000000000000
--- a/drivers/gpu/drm/nouveau/Kconfig
+++ b/drivers/gpu/drm/nouveau/Kconfig
@@@ -96,10 -86,8 +96,15 @@@ config DRM_NOUVEAU_SV
  	bool "(EXPERIMENTAL) Enable SVM (Shared Virtual Memory) support"
  	depends on DEVICE_PRIVATE
  	depends on DRM_NOUVEAU
++<<<<<<< HEAD
 +	depends on MMU
 +	depends on STAGING
 +	select HMM_MIRROR
 +	select MMU_NOTIFIER
++=======
+ 	depends on HMM_MIRROR
+ 	depends on STAGING
++>>>>>>> 43535b0aefab (mm: remove the HMM config option)
  	default n
  	help
  	  Say Y here if you want to enable experimental support for
diff --cc mm/Kconfig
index 5cfa72e3ac8c,1e426c26b1d6..000000000000
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@@ -685,28 -669,18 +685,42 @@@ config ZONE_DEVIC
  
  	  If FS_DAX is enabled, then say Y.
  
++<<<<<<< HEAD
 +config ARCH_HAS_HMM
 +	bool
 +	default y
 +	depends on (X86_64 || PPC64)
 +	depends on ZONE_DEVICE
 +	depends on MMU && 64BIT
 +	depends on MEMORY_HOTPLUG
 +	depends on MEMORY_HOTREMOVE
 +	depends on SPARSEMEM_VMEMMAP
++=======
+ config MIGRATE_VMA_HELPER
+ 	bool
++>>>>>>> 43535b0aefab (mm: remove the HMM config option)
  
  config DEV_PAGEMAP_OPS
  	bool
  
++<<<<<<< HEAD
 +config HMM
 +	bool
 +	select MIGRATE_VMA_HELPER
 +
 +config HMM_MIRROR
 +	bool "HMM mirror CPU page table into a device page table"
 +	depends on ARCH_HAS_HMM
 +	select MMU_NOTIFIER
 +	select HMM
++=======
+ config HMM_MIRROR
+ 	bool "HMM mirror CPU page table into a device page table"
+ 	depends on (X86_64 || PPC64)
+ 	depends on MMU && 64BIT
+ 	select MMU_NOTIFIER
+ 	select MIGRATE_VMA_HELPER
++>>>>>>> 43535b0aefab (mm: remove the HMM config option)
  	help
  	  Select HMM_MIRROR if you want to mirror range of the CPU page table of a
  	  process into a device page table. Here, mirror means "keep synchronized".
diff --cc mm/Makefile
index 8501050ca7da,91c99040065c..000000000000
--- a/mm/Makefile
+++ b/mm/Makefile
@@@ -110,8 -102,5 +110,12 @@@ obj-$(CONFIG_FRAME_VECTOR) += frame_vec
  obj-$(CONFIG_DEBUG_PAGE_REF) += debug_page_ref.o
  obj-$(CONFIG_HARDENED_USERCOPY) += usercopy.o
  obj-$(CONFIG_PERCPU_STATS) += percpu-stats.o
++<<<<<<< HEAD
 +obj-$(CONFIG_ZONE_DEVICE) += memremap.o
 +obj-$(CONFIG_HMM) += hmm.o
++=======
+ obj-$(CONFIG_HMM_MIRROR) += hmm.o
++>>>>>>> 43535b0aefab (mm: remove the HMM config option)
  obj-$(CONFIG_MEMFD_CREATE) += memfd.o
 +obj-$(CONFIG_MAPPING_DIRTY_HELPERS) += mapping_dirty_helpers.o
 +obj-$(CONFIG_PAGE_REPORTING) += page_reporting.o
* Unmerged path drivers/gpu/drm/nouveau/Kconfig
diff --git a/include/linux/hmm.h b/include/linux/hmm.h
index 86b23fe09dc9..90d54566ebea 100644
--- a/include/linux/hmm.h
+++ b/include/linux/hmm.h
@@ -71,7 +71,7 @@
 #include <linux/kconfig.h>
 #include <asm/pgtable.h>
 
-#if IS_ENABLED(CONFIG_HMM)
+#ifdef CONFIG_HMM_MIRROR
 
 #include <linux/device.h>
 #include <linux/migrate.h>
@@ -342,9 +342,6 @@ static inline uint64_t hmm_pfn_from_pfn(const struct hmm_range *range,
 	return hmm_device_entry_from_pfn(range, pfn);
 }
 
-
-
-#if IS_ENABLED(CONFIG_HMM_MIRROR)
 /*
  * Mirroring: how to synchronize device page table with CPU page table.
  *
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 713a008717dc..f7bc8e64731f 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -551,7 +551,7 @@ struct mm_struct {
 #endif
 		struct work_struct async_put_work;
 
-#if IS_ENABLED(CONFIG_HMM)
+#ifdef CONFIG_HMM_MIRROR
 		/* HMM needs to track a few things per mm */
 		struct hmm *hmm;
 #endif
* Unmerged path mm/Kconfig
* Unmerged path mm/Makefile
diff --git a/mm/hmm.c b/mm/hmm.c
index 44f8c4b225fa..795fdfeefbce 100644
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@ -35,7 +35,6 @@
 #include <linux/mmu_notifier.h>
 #include <linux/memory_hotplug.h>
 
-#if IS_ENABLED(CONFIG_HMM_MIRROR)
 static const struct mmu_notifier_ops hmm_mmu_notifier_ops;
 
 /**
@@ -1300,4 +1299,3 @@ long hmm_range_dma_unmap(struct hmm_range *range,
 	return cpages;
 }
 EXPORT_SYMBOL(hmm_range_dma_unmap);
-#endif /* IS_ENABLED(CONFIG_HMM_MIRROR) */
