ALSA: usb-audio: Always apply the hw constraints for implicit fb sync

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit e4ea77f8e53f9accb9371fba34c189d0447ecce0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/e4ea77f8.failed

Since the commit 5a6c3e11c9c9 ("ALSA: usb-audio: Add hw constraint for
implicit fb sync"), we apply the hw constraints for the implicit
feedback sync to make the secondary open aligned with the already
opened stream setup.  This change assumed that the secondary open is
performed after the first stream has been already set up, and adds the
hw constraints to sync with the first stream's parameters only when
the EP setup for the first stream was confirmed at the open time.
However, most of applications handling the full-duplex operations do
open both playback and capture streams at first, then set up both
streams.  This results in skipping the additional hw constraints since
the counter-part stream hasn't been set up yet at the open of the
second stream, and it eventually leads to "incompatible EP" error in
the end.

This patch corrects the behavior by always applying the hw constraints
for the implicit fb sync.  The hw constraint rules are defined so that
they check the sync EP dynamically at each invocation, instead.  This
covers the concurrent stream setups better and lets the hw refine
calls resolving to the right configuration.

Also this patch corrects a minor error that has existed in the debug
print that isn't built as default.

Fixes: 5a6c3e11c9c9 ("ALSA: usb-audio: Add hw constraint for implicit fb sync")
Link: https://lore.kernel.org/r/20210111081611.12790-1-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit e4ea77f8e53f9accb9371fba34c189d0447ecce0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/pcm.c
diff --cc sound/usb/pcm.c
index ec793eb507a0,f71965bf815f..000000000000
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@@ -1203,13 -775,8 +1203,15 @@@ static int hw_rule_channels(struct snd_
  	return apply_hw_params_minmax(it, rmin, rmax);
  }
  
- static int hw_rule_format(struct snd_pcm_hw_params *params,
- 			  struct snd_pcm_hw_rule *rule)
+ static int apply_hw_params_format_bits(struct snd_mask *fmt, u64 fbits)
  {
++<<<<<<< HEAD
 +	struct snd_usb_substream *subs = rule->private;
 +	struct audioformat *fp;
 +	struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
 +	u64 fbits;
++=======
++>>>>>>> e4ea77f8e53f (ALSA: usb-audio: Always apply the hw constraints for implicit fb sync)
  	u32 oldbits[2];
  	int changed;
  
@@@ -1261,16 -838,14 +1273,21 @@@ static int hw_rule_period_time(struct s
  	return apply_hw_params_minmax(it, pmin, UINT_MAX);
  }
  
- /* apply PCM hw constraints from the concurrent sync EP */
- static int apply_hw_constraint_from_sync(struct snd_pcm_runtime *runtime,
- 					 struct snd_usb_substream *subs)
+ /* get the EP or the sync EP for implicit fb when it's already set up */
+ static const struct snd_usb_endpoint *
+ get_sync_ep_from_substream(struct snd_usb_substream *subs)
  {
  	struct snd_usb_audio *chip = subs->stream->chip;
++<<<<<<< HEAD
 +	struct snd_usb_endpoint *ep;
 +	struct audioformat *fp;
 +	int err;
++=======
+ 	const struct audioformat *fp;
+ 	const struct snd_usb_endpoint *ep;
++>>>>>>> e4ea77f8e53f (ALSA: usb-audio: Always apply the hw constraints for implicit fb sync)
  
 +	subs->fixed_hw = 0;
  	list_for_each_entry(fp, &subs->fmt_list, list) {
  		ep = snd_usb_get_endpoint(chip, fp->endpoint);
  		if (ep && ep->cur_rate)
@@@ -1280,42 -855,75 +1297,101 @@@
  		/* for the implicit fb, check the sync ep as well */
  		ep = snd_usb_get_endpoint(chip, fp->sync_ep);
  		if (ep && ep->cur_rate)
- 			goto found;
+ 			return ep;
  	}
- 	return 0;
+ 	return NULL;
+ }
  
++<<<<<<< HEAD
 + found:
 +	if (!find_format(&subs->fmt_list, ep->cur_format, ep->cur_rate,
 +			 ep->cur_channels, NULL)) {
 +		usb_audio_dbg(chip, "EP 0x%x being used, but not applicable\n",
 +			      ep->ep_num);
++=======
+ /* additional hw constraints for implicit feedback mode */
+ static int hw_rule_format_implicit_fb(struct snd_pcm_hw_params *params,
+ 				      struct snd_pcm_hw_rule *rule)
+ {
+ 	struct snd_usb_substream *subs = rule->private;
+ 	const struct snd_usb_endpoint *ep;
+ 	struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
+ 
+ 	ep = get_sync_ep_from_substream(subs);
+ 	if (!ep)
++>>>>>>> e4ea77f8e53f (ALSA: usb-audio: Always apply the hw constraints for implicit fb sync)
  		return 0;
- 	}
  
++<<<<<<< HEAD
 +	usb_audio_dbg(chip, "EP 0x%x being used, using fixed params:\n",
 +		      ep->ep_num);
 +	usb_audio_dbg(chip, "rate=%d, format=%s, channels=%d, period_size=%d, periods=%d\n",
 +		      ep->cur_rate, snd_pcm_format_name(ep->cur_format),
 +		      ep->cur_channels, ep->cur_period_frames,
 +		      ep->cur_buffer_periods);
 +
 +	runtime->hw.formats = pcm_format_to_bits(ep->cur_format);
 +	runtime->hw.rate_min = runtime->hw.rate_max = ep->cur_rate;
 +	runtime->hw.channels_min = runtime->hw.channels_max =
 +		ep->cur_channels;
 +	runtime->hw.rates = SNDRV_PCM_RATE_KNOT;
 +	runtime->hw.periods_min = runtime->hw.periods_max =
 +		ep->cur_buffer_periods;
 +	subs->fixed_hw = 1;
++=======
+ 	hwc_debug("applying %s\n", __func__);
+ 	return apply_hw_params_format_bits(fmt, pcm_format_to_bits(ep->cur_format));
+ }
  
- 	err = snd_pcm_hw_constraint_minmax(runtime,
- 					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
- 					   ep->cur_period_frames,
- 					   ep->cur_period_frames);
- 	if (err < 0)
- 		return err;
+ static int hw_rule_rate_implicit_fb(struct snd_pcm_hw_params *params,
+ 				    struct snd_pcm_hw_rule *rule)
+ {
+ 	struct snd_usb_substream *subs = rule->private;
+ 	const struct snd_usb_endpoint *ep;
+ 	struct snd_interval *it;
+ 
+ 	ep = get_sync_ep_from_substream(subs);
+ 	if (!ep)
+ 		return 0;
++>>>>>>> e4ea77f8e53f (ALSA: usb-audio: Always apply the hw constraints for implicit fb sync)
+ 
+ 	hwc_debug("applying %s\n", __func__);
+ 	it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+ 	return apply_hw_params_minmax(it, ep->cur_rate, ep->cur_rate);
+ }
+ 
+ static int hw_rule_period_size_implicit_fb(struct snd_pcm_hw_params *params,
+ 					   struct snd_pcm_hw_rule *rule)
+ {
+ 	struct snd_usb_substream *subs = rule->private;
+ 	const struct snd_usb_endpoint *ep;
+ 	struct snd_interval *it;
+ 
+ 	ep = get_sync_ep_from_substream(subs);
+ 	if (!ep)
+ 		return 0;
+ 
+ 	hwc_debug("applying %s\n", __func__);
+ 	it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+ 	return apply_hw_params_minmax(it, ep->cur_period_frames,
+ 				      ep->cur_period_frames);
+ }
+ 
+ static int hw_rule_periods_implicit_fb(struct snd_pcm_hw_params *params,
+ 				       struct snd_pcm_hw_rule *rule)
+ {
+ 	struct snd_usb_substream *subs = rule->private;
+ 	const struct snd_usb_endpoint *ep;
+ 	struct snd_interval *it;
  
- 	return 1; /* notify the finding */
+ 	ep = get_sync_ep_from_substream(subs);
+ 	if (!ep)
+ 		return 0;
+ 
+ 	hwc_debug("applying %s\n", __func__);
+ 	it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIODS);
+ 	return apply_hw_params_minmax(it, ep->cur_buffer_periods,
+ 				      ep->cur_buffer_periods);
  }
  
  /*
@@@ -1324,8 -932,7 +1400,12 @@@
  
  static int setup_hw_info(struct snd_pcm_runtime *runtime, struct snd_usb_substream *subs)
  {
++<<<<<<< HEAD
 +	struct snd_usb_audio *chip = subs->stream->chip;
 +	struct audioformat *fp;
++=======
+ 	const struct audioformat *fp;
++>>>>>>> e4ea77f8e53f (ALSA: usb-audio: Always apply the hw constraints for implicit fb sync)
  	unsigned int pt, ptmin;
  	int param_period_time_if_needed = -1;
  	int err;
@@@ -1418,7 -1016,29 +1489,33 @@@
  			return err;
  	}
  
++<<<<<<< HEAD
 +	return snd_usb_autoresume(subs->stream->chip);
++=======
+ 	/* additional hw constraints for implicit fb */
+ 	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,
+ 				  hw_rule_format_implicit_fb, subs,
+ 				  SNDRV_PCM_HW_PARAM_FORMAT, -1);
+ 	if (err < 0)
+ 		return err;
+ 	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+ 				  hw_rule_rate_implicit_fb, subs,
+ 				  SNDRV_PCM_HW_PARAM_RATE, -1);
+ 	if (err < 0)
+ 		return err;
+ 	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+ 				  hw_rule_period_size_implicit_fb, subs,
+ 				  SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);
+ 	if (err < 0)
+ 		return err;
+ 	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIODS,
+ 				  hw_rule_periods_implicit_fb, subs,
+ 				  SNDRV_PCM_HW_PARAM_PERIODS, -1);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	return 0;
++>>>>>>> e4ea77f8e53f (ALSA: usb-audio: Always apply the hw constraints for implicit fb sync)
  }
  
  static int snd_usb_pcm_open(struct snd_pcm_substream *substream)
* Unmerged path sound/usb/pcm.c
