net/mlx5e: mlx5_tc_ct_init does not fail

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Saeed Mahameed <saeedm@nvidia.com>
commit 51ada5a52379e4dbf69cba70be6a348413f7a01f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/51ada5a5.failed

mlx5_tc_ct_init() either returns a valid pointer or a NULL, either way
the caller can continue, remove IS_ERR check from callers as it has no
effect.

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 51ada5a52379e4dbf69cba70be6a348413f7a01f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 8d4d2686ea65,dc126389291d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -5220,6 -4644,9 +5220,12 @@@ int mlx5e_tc_nic_init(struct mlx5e_pri
  		goto err_chains;
  	}
  
++<<<<<<< HEAD
++=======
+ 	tc->ct = mlx5_tc_ct_init(priv, tc->chains, &priv->fs.tc.mod_hdr,
+ 				 MLX5_FLOW_NAMESPACE_KERNEL);
+ 
++>>>>>>> 51ada5a52379 (net/mlx5e: mlx5_tc_ct_init does not fail)
  	tc->netdevice_nb.notifier_call = mlx5e_tc_netdev_event;
  	err = register_netdevice_notifier_dev_net(priv->netdev,
  						  &tc->netdevice_nb,
@@@ -5233,6 -4660,7 +5239,10 @@@
  	return 0;
  
  err_reg:
++<<<<<<< HEAD
++=======
+ 	mlx5_tc_ct_clean(tc->ct);
++>>>>>>> 51ada5a52379 (net/mlx5e: mlx5_tc_ct_init does not fail)
  	mlx5_chains_destroy(tc->chains);
  err_chains:
  	rhashtable_destroy(&tc->ht);
@@@ -5275,16 -4704,21 +5285,23 @@@ int mlx5e_tc_esw_init(struct rhashtabl
  {
  	const size_t sz_enc_opts = sizeof(struct tunnel_match_enc_opts);
  	struct mlx5_rep_uplink_priv *uplink_priv;
 -	struct mlx5e_rep_priv *rpriv;
 +	struct mlx5e_rep_priv *priv;
  	struct mapping_ctx *mapping;
 -	struct mlx5_eswitch *esw;
 -	struct mlx5e_priv *priv;
 -	int err = 0;
 +	int err;
  
  	uplink_priv = container_of(tc_ht, struct mlx5_rep_uplink_priv, tc_ht);
 -	rpriv = container_of(uplink_priv, struct mlx5e_rep_priv, uplink_priv);
 -	priv = netdev_priv(rpriv->netdev);
 -	esw = priv->mdev->priv.eswitch;
 +	priv = container_of(uplink_priv, struct mlx5e_rep_priv, uplink_priv);
  
++<<<<<<< HEAD
 +	err = mlx5_tc_ct_init(uplink_priv);
 +	if (err)
 +		goto err_ct;
++=======
+ 	uplink_priv->ct_priv = mlx5_tc_ct_init(netdev_priv(priv->netdev),
+ 					       esw_chains(esw),
+ 					       &esw->offloads.mod_hdr,
+ 					       MLX5_FLOW_NAMESPACE_FDB);
++>>>>>>> 51ada5a52379 (net/mlx5e: mlx5_tc_ct_init does not fail)
  
  	mapping = mapping_create(sizeof(struct tunnel_match_key),
  				 TUNNEL_INFO_BITS_MASK, true);
@@@ -5314,8 -4757,7 +5331,12 @@@ err_ht_init
  err_enc_opts_mapping:
  	mapping_destroy(uplink_priv->tunnel_mapping);
  err_tun_mapping:
++<<<<<<< HEAD
 +	mlx5_tc_ct_clean(uplink_priv);
 +err_ct:
++=======
+ 	mlx5_tc_ct_clean(uplink_priv->ct_priv);
++>>>>>>> 51ada5a52379 (net/mlx5e: mlx5_tc_ct_init does not fail)
  	netdev_warn(priv->netdev,
  		    "Failed to initialize tc (eswitch), err: %d", err);
  	return err;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
