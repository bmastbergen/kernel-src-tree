ALSA: usb-audio: Allow modifying parameters with succeeding hw_params calls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 5f5e6a3e8b1df52f79122e447855cffbf1710540
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/5f5e6a3e.failed

The recent fix for the hw constraints for implicit feedback streams
via commit e4ea77f8e53f ("ALSA: usb-audio: Always apply the hw
constraints for implicit fb sync") added the check of the matching
endpoints and whether those EPs are already opened.  This is needed
and correct, per se, even for the normal streams without the implicit
feedback, as the endpoint setup is exclusive.

However, it's reported that there seem applications that behave in
unexpected ways to update the hw_params without clearing the previous
setup via hw_free, and those hit a problem now: then hw_params is
called with still the previous EP setup kept, hence it's restricted
with the previous own setup.  Although the obvious fix is to call
snd_pcm_hw_free() API in the application side, it's a kind of
unwelcome change.

This patch tries to ease the situation: in the endpoint check, we add
a couple of more conditions and now skip the endpoint that is being
used only by the stream in question itself.  That is, in addition to
the presence check of ep (ep->cur_audiofmt is non-NULL), when the
following conditions are met, we skip such an ep:
- ep->opened == 1, and
- ep->cur_audiofmt == subs->cur_audiofmt.

subs->cur_audiofmt is non-NULL only if it's a re-setup of hw_params,
and ep->cur_audiofmt points to the currently set up parameters.  So if
those match, it must be this stream itself.

Fixes: e4ea77f8e53f ("ALSA: usb-audio: Always apply the hw constraints for implicit fb sync")
BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=211941
	Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/20210228080138.9936-1-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 5f5e6a3e8b1df52f79122e447855cffbf1710540)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/pcm.c
diff --cc sound/usb/pcm.c
index d682ba2a35f0,e5311b6bb3f6..000000000000
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@@ -1261,61 -835,98 +1261,77 @@@ static int hw_rule_period_time(struct s
  	return apply_hw_params_minmax(it, pmin, UINT_MAX);
  }
  
 -/* get the EP or the sync EP for implicit fb when it's already set up */
 -static const struct snd_usb_endpoint *
 -get_sync_ep_from_substream(struct snd_usb_substream *subs)
 +/* apply PCM hw constraints from the concurrent sync EP */
 +static int apply_hw_constraint_from_sync(struct snd_pcm_runtime *runtime,
 +					 struct snd_usb_substream *subs)
  {
  	struct snd_usb_audio *chip = subs->stream->chip;
 -	const struct audioformat *fp;
 -	const struct snd_usb_endpoint *ep;
 +	struct snd_usb_endpoint *ep;
 +	struct audioformat *fp;
 +	int err;
  
 +	subs->fixed_hw = 0;
  	list_for_each_entry(fp, &subs->fmt_list, list) {
  		ep = snd_usb_get_endpoint(chip, fp->endpoint);
++<<<<<<< HEAD
 +		if (ep && ep->cur_rate)
 +			goto found;
++=======
+ 		if (ep && ep->cur_audiofmt) {
+ 			/* if EP is already opened solely for this substream,
+ 			 * we still allow us to change the parameter; otherwise
+ 			 * this substream has to follow the existing parameter
+ 			 */
+ 			if (ep->cur_audiofmt != subs->cur_audiofmt || ep->opened > 1)
+ 				return ep;
+ 		}
++>>>>>>> 5f5e6a3e8b1d (ALSA: usb-audio: Allow modifying parameters with succeeding hw_params calls)
  		if (!fp->implicit_fb)
  			continue;
  		/* for the implicit fb, check the sync ep as well */
  		ep = snd_usb_get_endpoint(chip, fp->sync_ep);
++<<<<<<< HEAD
 +		if (ep && ep->cur_rate)
 +			goto found;
++=======
+ 		if (ep && ep->cur_audiofmt)
+ 			return ep;
++>>>>>>> 5f5e6a3e8b1d (ALSA: usb-audio: Allow modifying parameters with succeeding hw_params calls)
  	}
 -	return NULL;
 -}
 -
 -/* additional hw constraints for implicit feedback mode */
 -static int hw_rule_format_implicit_fb(struct snd_pcm_hw_params *params,
 -				      struct snd_pcm_hw_rule *rule)
 -{
 -	struct snd_usb_substream *subs = rule->private;
 -	const struct snd_usb_endpoint *ep;
 -	struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
 -
 -	ep = get_sync_ep_from_substream(subs);
 -	if (!ep)
 -		return 0;
 -
 -	hwc_debug("applying %s\n", __func__);
 -	return apply_hw_params_format_bits(fmt, pcm_format_to_bits(ep->cur_format));
 -}
 -
 -static int hw_rule_rate_implicit_fb(struct snd_pcm_hw_params *params,
 -				    struct snd_pcm_hw_rule *rule)
 -{
 -	struct snd_usb_substream *subs = rule->private;
 -	const struct snd_usb_endpoint *ep;
 -	struct snd_interval *it;
 -
 -	ep = get_sync_ep_from_substream(subs);
 -	if (!ep)
 -		return 0;
 -
 -	hwc_debug("applying %s\n", __func__);
 -	it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 -	return apply_hw_params_minmax(it, ep->cur_rate, ep->cur_rate);
 -}
 -
 -static int hw_rule_period_size_implicit_fb(struct snd_pcm_hw_params *params,
 -					   struct snd_pcm_hw_rule *rule)
 -{
 -	struct snd_usb_substream *subs = rule->private;
 -	const struct snd_usb_endpoint *ep;
 -	struct snd_interval *it;
 +	return 0;
  
 -	ep = get_sync_ep_from_substream(subs);
 -	if (!ep)
 + found:
 +	if (!find_format(&subs->fmt_list, ep->cur_format, ep->cur_rate,
 +			 ep->cur_channels, NULL)) {
 +		usb_audio_dbg(chip, "EP 0x%x being used, but not applicable\n",
 +			      ep->ep_num);
  		return 0;
 +	}
  
 -	hwc_debug("applying %s\n", __func__);
 -	it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
 -	return apply_hw_params_minmax(it, ep->cur_period_frames,
 -				      ep->cur_period_frames);
 -}
 -
 -static int hw_rule_periods_implicit_fb(struct snd_pcm_hw_params *params,
 -				       struct snd_pcm_hw_rule *rule)
 -{
 -	struct snd_usb_substream *subs = rule->private;
 -	const struct snd_usb_endpoint *ep;
 -	struct snd_interval *it;
 +	usb_audio_dbg(chip, "EP 0x%x being used, using fixed params:\n",
 +		      ep->ep_num);
 +	usb_audio_dbg(chip, "rate=%d, format=%s, channels=%d, period_size=%d, periods=%d\n",
 +		      ep->cur_rate, snd_pcm_format_name(ep->cur_format),
 +		      ep->cur_channels, ep->cur_period_frames,
 +		      ep->cur_buffer_periods);
 +
 +	runtime->hw.formats = pcm_format_to_bits(ep->cur_format);
 +	runtime->hw.rate_min = runtime->hw.rate_max = ep->cur_rate;
 +	runtime->hw.channels_min = runtime->hw.channels_max =
 +		ep->cur_channels;
 +	runtime->hw.rates = SNDRV_PCM_RATE_KNOT;
 +	runtime->hw.periods_min = runtime->hw.periods_max =
 +		ep->cur_buffer_periods;
 +	subs->fixed_hw = 1;
  
 -	ep = get_sync_ep_from_substream(subs);
 -	if (!ep)
 -		return 0;
 +	err = snd_pcm_hw_constraint_minmax(runtime,
 +					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 +					   ep->cur_period_frames,
 +					   ep->cur_period_frames);
 +	if (err < 0)
 +		return err;
  
 -	hwc_debug("applying %s\n", __func__);
 -	it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIODS);
 -	return apply_hw_params_minmax(it, ep->cur_buffer_periods,
 -				      ep->cur_buffer_periods);
 +	return 1; /* notify the finding */
  }
  
  /*
* Unmerged path sound/usb/pcm.c
