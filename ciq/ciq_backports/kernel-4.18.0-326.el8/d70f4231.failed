xhci: adjust parameters passed to cleanup_halted_endpoint()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-326.el8
commit-author Mathias Nyman <mathias.nyman@linux.intel.com>
commit d70f4231b81eeb6dd78bd913ff42729b524eec51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-326.el8/d70f4231.failed

Instead of passing slot id and endpoint index to
cleanup_halted_endpoint() pass the endpoint structure pointer
as it's already known.

Avoids again digging out the endpoint structure based on
slot id and endpoint index, and passing them along the
call chain for this purpose only.

Add slot_id to the virt_dev structure so that it
can easily be found from a virt_dev, or its child, the
virt_ep endpoint structure.

	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
Link: https://lore.kernel.org/r/20210129130044.206855-4-mathias.nyman@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d70f4231b81eeb6dd78bd913ff42729b524eec51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci-ring.c
diff --cc drivers/usb/host/xhci-ring.c
index ed8336be1549,7bcc5793a8b8..000000000000
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@@ -1970,18 -1969,12 +1969,20 @@@ static int finish_td(struct xhci_hcd *x
  	struct xhci_transfer_event *event,
  	struct xhci_virt_ep *ep, int *status)
  {
 +	struct xhci_virt_device *xdev;
  	struct xhci_ep_ctx *ep_ctx;
  	struct xhci_ring *ep_ring;
- 	unsigned int slot_id;
  	u32 trb_comp_code;
 -
 +	int ep_index;
 +
++<<<<<<< HEAD
 +	slot_id = TRB_TO_SLOT_ID(le32_to_cpu(event->flags));
 +	xdev = xhci->devs[slot_id];
 +	ep_index = TRB_TO_EP_ID(le32_to_cpu(event->flags)) - 1;
++=======
++>>>>>>> d70f4231b81e (xhci: adjust parameters passed to cleanup_halted_endpoint())
  	ep_ring = xhci_dma_to_transfer_ring(ep, le64_to_cpu(event->buffer));
 -	ep_ctx = xhci_get_ep_ctx(xhci, ep->vdev->out_ctx, ep->ep_index);
 +	ep_ctx = xhci_get_ep_ctx(xhci, xdev->out_ctx, ep_index);
  	trb_comp_code = GET_COMP_CODE(le32_to_cpu(event->transfer_len));
  
  	if (trb_comp_code == COMP_STOPPED_LENGTH_INVALID ||
@@@ -2006,10 -1999,10 +2007,15 @@@
  		 * stall later. Hub TT buffer should only be cleared for FS/LS
  		 * devices behind HS hubs for functional stalls.
  		 */
 -		if ((ep->ep_index != 0) || (trb_comp_code != COMP_STALL_ERROR))
 +		if ((ep_index != 0) || (trb_comp_code != COMP_STALL_ERROR))
  			xhci_clear_hub_tt_buffer(xhci, td, ep);
++<<<<<<< HEAD
 +		xhci_cleanup_halted_endpoint(xhci, slot_id, ep_index,
 +					ep_ring->stream_id, td, EP_HARD_RESET);
++=======
+ 		xhci_cleanup_halted_endpoint(xhci, ep, ep_ring->stream_id, td,
+ 					     EP_HARD_RESET);
++>>>>>>> d70f4231b81e (xhci: adjust parameters passed to cleanup_halted_endpoint())
  	} else {
  		/* Update ring dequeue pointer */
  		while (ep_ring->dequeue != td->last_trb)
@@@ -2258,12 -2245,8 +2264,17 @@@ static int process_bulk_intr_td(struct 
  	struct xhci_ring *ep_ring;
  	u32 trb_comp_code;
  	u32 remaining, requested, ep_trb_len;
++<<<<<<< HEAD
 +	unsigned int slot_id;
 +	int ep_index;
 +
 +	slot_id = TRB_TO_SLOT_ID(le32_to_cpu(event->flags));
 +	slot_ctx = xhci_get_slot_ctx(xhci, xhci->devs[slot_id]->out_ctx);
 +	ep_index = TRB_TO_EP_ID(le32_to_cpu(event->flags)) - 1;
++=======
+ 
+ 	slot_ctx = xhci_get_slot_ctx(xhci, ep->vdev->out_ctx);
++>>>>>>> d70f4231b81e (xhci: adjust parameters passed to cleanup_halted_endpoint())
  	ep_ring = xhci_dma_to_transfer_ring(ep, le64_to_cpu(event->buffer));
  	trb_comp_code = GET_COMP_CODE(le32_to_cpu(event->transfer_len));
  	remaining = EVENT_TRB_LEN(le32_to_cpu(event->transfer_len));
@@@ -2301,8 -2284,8 +2312,13 @@@
  		    le32_to_cpu(slot_ctx->tt_info) & TT_SLOT)
  			break;
  		*status = 0;
++<<<<<<< HEAD
 +		xhci_cleanup_halted_endpoint(xhci, slot_id, ep_index,
 +					ep_ring->stream_id, td, EP_SOFT_RESET);
++=======
+ 		xhci_cleanup_halted_endpoint(xhci, ep, ep_ring->stream_id, td,
+ 					     EP_SOFT_RESET);
++>>>>>>> d70f4231b81e (xhci: adjust parameters passed to cleanup_halted_endpoint())
  		return 0;
  	default:
  		/* do nothing */
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 326ce389cc99..f52a63cb38bc 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -994,6 +994,8 @@ int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id,
 	if (!dev)
 		return 0;
 
+	dev->slot_id = slot_id;
+
 	/* Allocate the (output) device context that will be used in the HC. */
 	dev->out_ctx = xhci_alloc_container_ctx(xhci, XHCI_CTX_TYPE_DEVICE, flags);
 	if (!dev->out_ctx)
* Unmerged path drivers/usb/host/xhci-ring.c
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 335d8d821b24..32777c3d0cb6 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -995,6 +995,7 @@ struct xhci_interval_bw_table {
 
 
 struct xhci_virt_device {
+	int				slot_id;
 	struct usb_device		*udev;
 	/*
 	 * Commands to the hardware are passed an "input context" that
