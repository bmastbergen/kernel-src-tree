neigh: wrap proc dointvec functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit cb5b09c17fe60056bc8f127ffc987d361c40ed4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/cb5b09c1.failed

This will be needed later on to provide better management of default values.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cb5b09c17fe60056bc8f127ffc987d361c40ed4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/neighbour.h
#	net/core/neighbour.c
diff --cc include/net/neighbour.h
index 7e748ad8b50c,ed7eba045297..000000000000
--- a/include/net/neighbour.h
+++ b/include/net/neighbour.h
@@@ -270,15 -291,23 +270,30 @@@ struct neigh_seq_state 
  #define NEIGH_SEQ_IS_PNEIGH	0x00000002
  #define NEIGH_SEQ_SKIP_NOARP	0x00000004
  };
 -void *neigh_seq_start(struct seq_file *, loff_t *, struct neigh_table *,
 -		      unsigned int);
 -void *neigh_seq_next(struct seq_file *, void *, loff_t *);
 -void neigh_seq_stop(struct seq_file *, void *);
 -
 +extern void *neigh_seq_start(struct seq_file *, loff_t *, struct neigh_table *, unsigned int);
 +extern void *neigh_seq_next(struct seq_file *, void *, loff_t *);
 +extern void neigh_seq_stop(struct seq_file *, void *);
 +
++<<<<<<< HEAD
 +extern int			neigh_sysctl_register(struct net_device *dev, 
 +						      struct neigh_parms *p,
 +						      char *p_name,
 +						      proc_handler *proc_handler);
 +extern void			neigh_sysctl_unregister(struct neigh_parms *p);
++=======
+ int neigh_proc_dointvec(struct ctl_table *ctl, int write,
+ 			void __user *buffer, size_t *lenp, loff_t *ppos);
+ int neigh_proc_dointvec_jiffies(struct ctl_table *ctl, int write,
+ 				void __user *buffer,
+ 				size_t *lenp, loff_t *ppos);
+ int neigh_proc_dointvec_ms_jiffies(struct ctl_table *ctl, int write,
+ 				   void __user *buffer,
+ 				   size_t *lenp, loff_t *ppos);
+ 
+ int neigh_sysctl_register(struct net_device *dev, struct neigh_parms *p,
+ 			  char *p_name, proc_handler *proc_handler);
+ void neigh_sysctl_unregister(struct neigh_parms *p);
++>>>>>>> cb5b09c17fe6 (neigh: wrap proc dointvec functions)
  
  static inline void __neigh_parms_put(struct neigh_parms *parms)
  {
diff --cc net/core/neighbour.c
index 05242ae7bdcf,60edd97ad2bc..000000000000
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@@ -2782,28 -2813,84 +2782,109 @@@ static int proc_unres_qlen(ctl_table *c
  	return ret;
  }
  
++<<<<<<< HEAD
 +enum {
 +	NEIGH_VAR_MCAST_PROBE,
 +	NEIGH_VAR_UCAST_PROBE,
 +	NEIGH_VAR_APP_PROBE,
 +	NEIGH_VAR_RETRANS_TIME,
 +	NEIGH_VAR_BASE_REACHABLE_TIME,
 +	NEIGH_VAR_DELAY_PROBE_TIME,
 +	NEIGH_VAR_GC_STALETIME,
 +	NEIGH_VAR_QUEUE_LEN,
 +	NEIGH_VAR_QUEUE_LEN_BYTES,
 +	NEIGH_VAR_PROXY_QLEN,
 +	NEIGH_VAR_ANYCAST_DELAY,
 +	NEIGH_VAR_PROXY_DELAY,
 +	NEIGH_VAR_LOCKTIME,
 +	NEIGH_VAR_RETRANS_TIME_MS,
 +	NEIGH_VAR_BASE_REACHABLE_TIME_MS,
 +	NEIGH_VAR_GC_INTERVAL,
 +	NEIGH_VAR_GC_THRESH1,
 +	NEIGH_VAR_GC_THRESH2,
 +	NEIGH_VAR_GC_THRESH3,
 +	NEIGH_VAR_MAX
 +};
++=======
+ static int neigh_proc_dointvec_zero_intmax(struct ctl_table *ctl, int write,
+ 					   void __user *buffer,
+ 					   size_t *lenp, loff_t *ppos)
+ {
+ 	struct ctl_table tmp = *ctl;
+ 
+ 	tmp.extra1 = &zero;
+ 	tmp.extra2 = &int_max;
+ 
+ 	return proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+ }
+ 
+ int neigh_proc_dointvec(struct ctl_table *ctl, int write,
+ 			void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return proc_dointvec(ctl, write, buffer, lenp, ppos);
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec);
+ 
+ int neigh_proc_dointvec_jiffies(struct ctl_table *ctl, int write,
+ 				void __user *buffer,
+ 				size_t *lenp, loff_t *ppos)
+ {
+ 	return proc_dointvec_jiffies(ctl, write, buffer, lenp, ppos);
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec_jiffies);
+ 
+ static int neigh_proc_dointvec_userhz_jiffies(struct ctl_table *ctl, int write,
+ 					      void __user *buffer,
+ 					      size_t *lenp, loff_t *ppos)
+ {
+ 	return proc_dointvec_userhz_jiffies(ctl, write, buffer, lenp, ppos);
+ }
+ 
+ int neigh_proc_dointvec_ms_jiffies(struct ctl_table *ctl, int write,
+ 				   void __user *buffer,
+ 				   size_t *lenp, loff_t *ppos)
+ {
+ 	return proc_dointvec_ms_jiffies(ctl, write, buffer, lenp, ppos);
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec_ms_jiffies);
+ 
+ static int neigh_proc_dointvec_unres_qlen(struct ctl_table *ctl, int write,
+ 					  void __user *buffer,
+ 					  size_t *lenp, loff_t *ppos)
+ {
+ 	return proc_unres_qlen(ctl, write, buffer, lenp, ppos);
+ }
+ 
+ #define NEIGH_PARMS_DATA_OFFSET(index)	\
+ 	(&((struct neigh_parms *) 0)->data[index])
+ 
+ #define NEIGH_SYSCTL_ENTRY(attr, data_attr, name, mval, proc) \
+ 	[NEIGH_VAR_ ## attr] = { \
+ 		.procname	= name, \
+ 		.data		= NEIGH_PARMS_DATA_OFFSET(NEIGH_VAR_ ## data_attr), \
+ 		.maxlen		= sizeof(int), \
+ 		.mode		= mval, \
+ 		.proc_handler	= proc, \
+ 	}
+ 
+ #define NEIGH_SYSCTL_ZERO_INTMAX_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_zero_intmax)
+ 
+ #define NEIGH_SYSCTL_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_jiffies)
+ 
+ #define NEIGH_SYSCTL_USERHZ_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_userhz_jiffies)
+ 
+ #define NEIGH_SYSCTL_MS_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_ms_jiffies)
+ 
+ #define NEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(attr, data_attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, data_attr, name, 0644, neigh_proc_dointvec_ms_jiffies)
+ 
+ #define NEIGH_SYSCTL_UNRES_QLEN_REUSED_ENTRY(attr, data_attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, data_attr, name, 0644, neigh_proc_dointvec_unres_qlen)
++>>>>>>> cb5b09c17fe6 (neigh: wrap proc dointvec functions)
  
  static struct neigh_sysctl_table {
  	struct ctl_table_header *sysctl_header;
@@@ -2954,21 -2958,10 +3035,28 @@@ int neigh_sysctl_register(struct net_de
  	if (!t)
  		goto err;
  
++<<<<<<< HEAD
 +	t->neigh_vars[NEIGH_VAR_MCAST_PROBE].data  = &p->mcast_probes;
 +	t->neigh_vars[NEIGH_VAR_UCAST_PROBE].data  = &p->ucast_probes;
 +	t->neigh_vars[NEIGH_VAR_APP_PROBE].data  = &p->app_probes;
 +	t->neigh_vars[NEIGH_VAR_RETRANS_TIME].data  = &p->retrans_time;
 +	t->neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME].data  = &p->base_reachable_time;
 +	t->neigh_vars[NEIGH_VAR_DELAY_PROBE_TIME].data  = &p->delay_probe_time;
 +	t->neigh_vars[NEIGH_VAR_GC_STALETIME].data  = &p->gc_staletime;
 +	t->neigh_vars[NEIGH_VAR_QUEUE_LEN].data  = &p->queue_len_bytes;
 +	t->neigh_vars[NEIGH_VAR_QUEUE_LEN_BYTES].data  = &p->queue_len_bytes;
 +	t->neigh_vars[NEIGH_VAR_PROXY_QLEN].data  = &p->proxy_qlen;
 +	t->neigh_vars[NEIGH_VAR_ANYCAST_DELAY].data  = &p->anycast_delay;
 +	t->neigh_vars[NEIGH_VAR_PROXY_DELAY].data = &p->proxy_delay;
 +	t->neigh_vars[NEIGH_VAR_LOCKTIME].data = &p->locktime;
 +	t->neigh_vars[NEIGH_VAR_RETRANS_TIME_MS].data  = &p->retrans_time;
 +	t->neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME_MS].data  = &p->base_reachable_time;
++=======
+ 	for (i = 0; i < ARRAY_SIZE(t->neigh_vars); i++) {
+ 		t->neigh_vars[i].data += (long) p;
+ 		t->neigh_vars[i].extra1 = dev;
+ 	}
++>>>>>>> cb5b09c17fe6 (neigh: wrap proc dointvec functions)
  
  	if (dev) {
  		dev_name_source = dev->name;
* Unmerged path include/net/neighbour.h
* Unmerged path net/core/neighbour.c
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index d252600afd68..385ed81d8aa7 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -1629,16 +1629,16 @@ int ndisc_ifinfo_sysctl_change(struct ctl_table *ctl, int write, void __user *bu
 		ndisc_warn_deprecated_sysctl(ctl, "syscall", dev ? dev->name : "default");
 
 	if (strcmp(ctl->procname, "retrans_time") == 0)
-		ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+		ret = neigh_proc_dointvec(ctl, write, buffer, lenp, ppos);
 
 	else if (strcmp(ctl->procname, "base_reachable_time") == 0)
-		ret = proc_dointvec_jiffies(ctl, write,
-					    buffer, lenp, ppos);
+		ret = neigh_proc_dointvec_jiffies(ctl, write,
+						  buffer, lenp, ppos);
 
 	else if ((strcmp(ctl->procname, "retrans_time_ms") == 0) ||
 		 (strcmp(ctl->procname, "base_reachable_time_ms") == 0))
-		ret = proc_dointvec_ms_jiffies(ctl, write,
-					       buffer, lenp, ppos);
+		ret = neigh_proc_dointvec_ms_jiffies(ctl, write,
+						     buffer, lenp, ppos);
 	else
 		ret = -1;
 
