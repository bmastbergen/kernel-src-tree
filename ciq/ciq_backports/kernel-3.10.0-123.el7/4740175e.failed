xfs: vectorise remaining shortform dir2 ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 4740175e75f70ab71f76ae98ab00f7db731a48f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/4740175e.failed

Following from the initial patch to introduce the directory
operations vector, convert the rest of the shortform directory
operations to use vectored ops rather than superblock feature
checks. This further reduces the size of the built binary:

   text    data     bss     dec     hex filename
 794490   96802    1096  892388   d9de4 fs/xfs/xfs.o.orig
 792986   96802    1096  890884   d9804 fs/xfs/xfs.o.p1
 792350   96802    1096  890248   d9588 fs/xfs/xfs.o.p2

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 4740175e75f70ab71f76ae98ab00f7db731a48f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_da_format.c
#	fs/xfs/xfs_dir2.h
#	fs/xfs/xfs_dir2_block.c
#	fs/xfs/xfs_dir2_format.h
#	fs/xfs/xfs_dir2_readdir.c
#	fs/xfs/xfs_dir2_sf.c
diff --cc fs/xfs/xfs_dir2.h
index e937d9991c18,0e94b3e662af..000000000000
--- a/fs/xfs/xfs_dir2.h
+++ b/fs/xfs/xfs_dir2.h
@@@ -27,6 -32,31 +27,34 @@@ struct xfs_trans
  extern struct xfs_name	xfs_name_dotdot;
  
  /*
++<<<<<<< HEAD
++=======
+  * directory operations vector for encode/decode routines
+  */
+ struct xfs_dir_ops {
+ 	int	(*sf_entsize)(struct xfs_dir2_sf_hdr *hdr, int len);
+ 	struct xfs_dir2_sf_entry *
+ 		(*sf_nextentry)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	__uint8_t (*sf_get_ftype)(struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ftype)(struct xfs_dir2_sf_entry *sfep,
+ 				__uint8_t ftype);
+ 	xfs_ino_t (*sf_get_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 			      struct xfs_dir2_sf_entry *sfep,
+ 			      xfs_ino_t ino);
+ 	xfs_ino_t (*sf_get_parent_ino)(struct xfs_dir2_sf_hdr *hdr);
+ 	void	(*sf_put_parent_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				     xfs_ino_t ino);
+ };
+ 
+ extern const struct xfs_dir_ops xfs_dir2_ops;
+ extern const struct xfs_dir_ops xfs_dir2_ftype_ops;
+ extern const struct xfs_dir_ops xfs_dir3_ops;
+ 
+ /*
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
   * Generic directory interface routines
   */
  extern void xfs_dir_startup(void);
@@@ -57,4 -87,36 +85,39 @@@ extern int xfs_dir_canenter(struct xfs_
   */
  extern int xfs_dir2_sf_to_block(struct xfs_da_args *args);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Interface routines used by userspace utilities
+  */
+ extern int xfs_dir2_isblock(struct xfs_trans *tp, struct xfs_inode *dp, int *r);
+ extern int xfs_dir2_isleaf(struct xfs_trans *tp, struct xfs_inode *dp, int *r);
+ extern int xfs_dir2_shrink_inode(struct xfs_da_args *args, xfs_dir2_db_t db,
+ 				struct xfs_buf *bp);
+ 
+ extern void xfs_dir2_data_freescan(struct xfs_mount *mp,
+ 		struct xfs_dir2_data_hdr *hdr, int *loghead);
+ extern void xfs_dir2_data_log_entry(struct xfs_trans *tp, struct xfs_buf *bp,
+ 		struct xfs_dir2_data_entry *dep);
+ extern void xfs_dir2_data_log_header(struct xfs_trans *tp,
+ 		struct xfs_buf *bp);
+ extern void xfs_dir2_data_log_unused(struct xfs_trans *tp, struct xfs_buf *bp,
+ 		struct xfs_dir2_data_unused *dup);
+ extern void xfs_dir2_data_make_free(struct xfs_trans *tp, struct xfs_buf *bp,
+ 		xfs_dir2_data_aoff_t offset, xfs_dir2_data_aoff_t len,
+ 		int *needlogp, int *needscanp);
+ extern void xfs_dir2_data_use_free(struct xfs_trans *tp, struct xfs_buf *bp,
+ 		struct xfs_dir2_data_unused *dup, xfs_dir2_data_aoff_t offset,
+ 		xfs_dir2_data_aoff_t len, int *needlogp, int *needscanp);
+ 
+ extern struct xfs_dir2_data_free *xfs_dir2_data_freefind(
+ 		struct xfs_dir2_data_hdr *hdr, struct xfs_dir2_data_unused *dup);
+ 
+ extern const struct xfs_buf_ops xfs_dir3_block_buf_ops;
+ extern const struct xfs_buf_ops xfs_dir3_leafn_buf_ops;
+ extern const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops;
+ extern const struct xfs_buf_ops xfs_dir3_free_buf_ops;
+ extern const struct xfs_buf_ops xfs_dir3_data_buf_ops;
+ 
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  #endif	/* __XFS_DIR2_H__ */
diff --cc fs/xfs/xfs_dir2_block.c
index 53b9aa26d567,960f3ab526f6..000000000000
--- a/fs/xfs/xfs_dir2_block.c
+++ b/fs/xfs/xfs_dir2_block.c
@@@ -1266,11 -1172,12 +1266,16 @@@ xfs_dir2_sf_to_block
  	/*
  	 * Create entry for ..
  	 */
++<<<<<<< HEAD
 +	dep = xfs_dir3_data_dotdot_entry_p(hdr);
 +	dep->inumber = cpu_to_be64(xfs_dir2_sf_get_parent_ino(sfp));
++=======
+ 	dep = xfs_dir3_data_dotdot_entry_p(mp, hdr);
+ 	dep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  	dep->namelen = 2;
  	dep->name[0] = dep->name[1] = '.';
 -	xfs_dir3_dirent_put_ftype(mp, dep, XFS_DIR3_FT_DIR);
 -	tagp = xfs_dir3_data_entry_tag_p(mp, dep);
 +	tagp = xfs_dir2_data_entry_tag_p(dep);
  	*tagp = cpu_to_be16((char *)dep - (char *)hdr);
  	xfs_dir2_data_log_entry(tp, bp, dep);
  	blp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);
@@@ -1315,10 -1222,12 +1320,17 @@@
  		 * Copy a real entry.
  		 */
  		dep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);
++<<<<<<< HEAD
 +		dep->inumber = cpu_to_be64(xfs_dir2_sfe_get_ino(sfp, sfep));
 +		dep->namelen = sfep->namelen;
++=======
+ 		dep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));
+ 		dep->namelen = sfep->namelen;
+ 		xfs_dir3_dirent_put_ftype(mp, dep,
+ 					  dp->d_ops->sf_get_ftype(sfep));
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  		memcpy(dep->name, sfep->name, dep->namelen);
 -		tagp = xfs_dir3_data_entry_tag_p(mp, dep);
 +		tagp = xfs_dir2_data_entry_tag_p(dep);
  		*tagp = cpu_to_be16((char *)dep - (char *)hdr);
  		xfs_dir2_data_log_entry(tp, bp, dep);
  		name.name = sfep->name;
diff --cc fs/xfs/xfs_dir2_format.h
index 2095e17b75cb,68c2ad5ba54f..000000000000
--- a/fs/xfs/xfs_dir2_format.h
+++ b/fs/xfs/xfs_dir2_format.h
@@@ -179,15 -329,6 +179,18 @@@ xfs_dir2_sf_firstentry(struct xfs_dir2_
  		((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));
  }
  
++<<<<<<< HEAD:fs/xfs/xfs_dir2_format.h
 +static inline struct xfs_dir2_sf_entry *
 +xfs_dir2_sf_nextentry(struct xfs_dir2_sf_hdr *hdr,
 +		struct xfs_dir2_sf_entry *sfep)
 +{
 +	return (struct xfs_dir2_sf_entry *)
 +		((char *)sfep + xfs_dir2_sf_entsize(hdr, sfep->namelen));
 +}
 +
 +
++=======
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops):fs/xfs/xfs_da_format.h
  /*
   * Data block structures.
   *
diff --cc fs/xfs/xfs_dir2_sf.c
index 6157424dbf8f,ec0d39b5fa12..000000000000
--- a/fs/xfs/xfs_dir2_sf.c
+++ b/fs/xfs/xfs_dir2_sf.c
@@@ -57,82 -57,6 +57,85 @@@ static void xfs_dir2_sf_toino8(xfs_da_a
  #endif /* XFS_BIG_INUMS */
  
  /*
++<<<<<<< HEAD
 + * Inode numbers in short-form directories can come in two versions,
 + * either 4 bytes or 8 bytes wide.  These helpers deal with the
 + * two forms transparently by looking at the headers i8count field.
 + *
 + * For 64-bit inode number the most significant byte must be zero.
 + */
 +static xfs_ino_t
 +xfs_dir2_sf_get_ino(
 +	struct xfs_dir2_sf_hdr	*hdr,
 +	xfs_dir2_inou_t		*from)
 +{
 +	if (hdr->i8count)
 +		return get_unaligned_be64(&from->i8.i) & 0x00ffffffffffffffULL;
 +	else
 +		return get_unaligned_be32(&from->i4.i);
 +}
 +
 +static void
 +xfs_dir2_sf_put_ino(
 +	struct xfs_dir2_sf_hdr	*hdr,
 +	xfs_dir2_inou_t		*to,
 +	xfs_ino_t		ino)
 +{
 +	ASSERT((ino & 0xff00000000000000ULL) == 0);
 +
 +	if (hdr->i8count)
 +		put_unaligned_be64(ino, &to->i8.i);
 +	else
 +		put_unaligned_be32(ino, &to->i4.i);
 +}
 +
 +xfs_ino_t
 +xfs_dir2_sf_get_parent_ino(
 +	struct xfs_dir2_sf_hdr	*hdr)
 +{
 +	return xfs_dir2_sf_get_ino(hdr, &hdr->parent);
 +}
 +
 +static void
 +xfs_dir2_sf_put_parent_ino(
 +	struct xfs_dir2_sf_hdr	*hdr,
 +	xfs_ino_t		ino)
 +{
 +	xfs_dir2_sf_put_ino(hdr, &hdr->parent, ino);
 +}
 +
 +/*
 + * In short-form directory entries the inode numbers are stored at variable
 + * offset behind the entry name.  The inode numbers may only be accessed
 + * through the helpers below.
 + */
 +static xfs_dir2_inou_t *
 +xfs_dir2_sfe_inop(
 +	struct xfs_dir2_sf_entry *sfep)
 +{
 +	return (xfs_dir2_inou_t *)&sfep->name[sfep->namelen];
 +}
 +
 +xfs_ino_t
 +xfs_dir2_sfe_get_ino(
 +	struct xfs_dir2_sf_hdr	*hdr,
 +	struct xfs_dir2_sf_entry *sfep)
 +{
 +	return xfs_dir2_sf_get_ino(hdr, xfs_dir2_sfe_inop(sfep));
 +}
 +
 +static void
 +xfs_dir2_sfe_put_ino(
 +	struct xfs_dir2_sf_hdr	*hdr,
 +	struct xfs_dir2_sf_entry *sfep,
 +	xfs_ino_t		ino)
 +{
 +	xfs_dir2_sf_put_ino(hdr, xfs_dir2_sfe_inop(sfep), ino);
 +}
 +
 +/*
++=======
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
   * Given a block directory (dp/block), calculate its size as a shortform (sf)
   * directory and a header for the sf directory, if it will fit it the
   * space currently present in the inode.  If it won't fit, the output
@@@ -316,12 -248,14 +319,19 @@@ xfs_dir2_block_to_sf
  				(xfs_dir2_data_aoff_t)
  				((char *)dep - (char *)hdr));
  			memcpy(sfep->name, dep->name, dep->namelen);
++<<<<<<< HEAD
 +			xfs_dir2_sfe_put_ino(sfp, sfep,
 +					     be64_to_cpu(dep->inumber));
++=======
+ 			dp->d_ops->sf_put_ino(sfp, sfep,
+ 					      be64_to_cpu(dep->inumber));
+ 			dp->d_ops->sf_put_ftype(sfep,
+ 					xfs_dir3_dirent_get_ftype(mp, dep));
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  
 -			sfep = dp->d_ops->sf_nextentry(sfp, sfep);
 +			sfep = xfs_dir2_sf_nextentry(sfp, sfep);
  		}
 -		ptr += xfs_dir3_data_entsize(mp, dep->namelen);
 +		ptr += xfs_dir2_data_entsize(dep->namelen);
  	}
  	ASSERT((char *)sfep - (char *)sfp == size);
  	xfs_dir2_sf_check(args);
@@@ -479,7 -413,9 +489,13 @@@ xfs_dir2_sf_addname_easy
  	sfep->namelen = args->namelen;
  	xfs_dir2_sf_put_offset(sfep, offset);
  	memcpy(sfep->name, args->name, sfep->namelen);
++<<<<<<< HEAD
 +	xfs_dir2_sfe_put_ino(sfp, sfep, args->inumber);
++=======
+ 	dp->d_ops->sf_put_ino(sfp, sfep, args->inumber);
+ 	dp->d_ops->sf_put_ftype(sfep, args->filetype);
+ 
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  	/*
  	 * Update the header and inode.
  	 */
@@@ -570,7 -508,8 +586,12 @@@ xfs_dir2_sf_addname_hard
  	sfep->namelen = args->namelen;
  	xfs_dir2_sf_put_offset(sfep, offset);
  	memcpy(sfep->name, args->name, sfep->namelen);
++<<<<<<< HEAD
 +	xfs_dir2_sfe_put_ino(sfp, sfep, args->inumber);
++=======
+ 	dp->d_ops->sf_put_ino(sfp, sfep, args->inumber);
+ 	dp->d_ops->sf_put_ftype(sfep, args->filetype);
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  	sfp->count++;
  #if XFS_BIG_INUMS
  	if (args->inumber > XFS_DIR2_MAX_SHORT_INUM && !objchange)
@@@ -684,23 -623,26 +705,37 @@@ xfs_dir2_sf_check
  	int			offset;		/* data offset */
  	xfs_dir2_sf_entry_t	*sfep;		/* shortform dir entry */
  	xfs_dir2_sf_hdr_t	*sfp;		/* shortform structure */
 -	struct xfs_mount	*mp;
  
  	dp = args->dp;
 -	mp = dp->i_mount;
  
  	sfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;
++<<<<<<< HEAD
 +	offset = XFS_DIR3_DATA_FIRST_OFFSET(dp->i_mount);
 +	ino = xfs_dir2_sf_get_parent_ino(sfp);
++=======
+ 	offset = xfs_dir3_data_first_offset(mp);
+ 	ino = dp->d_ops->sf_get_parent_ino(sfp);
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  	i8count = ino > XFS_DIR2_MAX_SHORT_INUM;
  
  	for (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);
  	     i < sfp->count;
 -	     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {
 +	     i++, sfep = xfs_dir2_sf_nextentry(sfp, sfep)) {
  		ASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);
++<<<<<<< HEAD
 +		ino = xfs_dir2_sfe_get_ino(sfp, sfep);
 +		i8count += ino > XFS_DIR2_MAX_SHORT_INUM;
 +		offset =
 +			xfs_dir2_sf_get_offset(sfep) +
 +			xfs_dir2_data_entsize(sfep->namelen);
++=======
+ 		ino = dp->d_ops->sf_get_ino(sfp, sfep);
+ 		i8count += ino > XFS_DIR2_MAX_SHORT_INUM;
+ 		offset =
+ 			xfs_dir2_sf_get_offset(sfep) +
+ 			xfs_dir3_data_entsize(mp, sfep->namelen);
+ 		ASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  	}
  	ASSERT(i8count == sfp->i8count);
  	ASSERT(XFS_BIG_INUMS || i8count == 0);
@@@ -910,8 -753,9 +945,8 @@@ xfs_dir2_sf_lookup
  	 */
  	if (args->namelen == 2 &&
  	    args->name[0] == '.' && args->name[1] == '.') {
- 		args->inumber = xfs_dir2_sf_get_parent_ino(sfp);
+ 		args->inumber = dp->d_ops->sf_get_parent_ino(sfp);
  		args->cmpresult = XFS_CMP_EXACT;
 -		args->filetype = XFS_DIR3_FT_DIR;
  		return XFS_ERROR(EEXIST);
  	}
  	/*
@@@ -929,7 -773,8 +964,12 @@@
  								sfep->namelen);
  		if (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {
  			args->cmpresult = cmp;
++<<<<<<< HEAD
 +			args->inumber = xfs_dir2_sfe_get_ino(sfp, sfep);
++=======
+ 			args->inumber = dp->d_ops->sf_get_ino(sfp, sfep);
+ 			args->filetype = dp->d_ops->sf_get_ftype(sfep);
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  			if (cmp == XFS_CMP_EXACT)
  				return XFS_ERROR(EEXIST);
  			ci_sfep = sfep;
@@@ -985,10 -830,10 +1025,14 @@@ xfs_dir2_sf_removename
  	 * Find the one we're deleting.
  	 */
  	for (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;
 -	     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {
 +				i++, sfep = xfs_dir2_sf_nextentry(sfp, sfep)) {
  		if (xfs_da_compname(args, sfep->name, sfep->namelen) ==
  								XFS_CMP_EXACT) {
++<<<<<<< HEAD
 +			ASSERT(xfs_dir2_sfe_get_ino(sfp, sfep) ==
++=======
+ 			ASSERT(dp->d_ops->sf_get_ino(sfp, sfep) ==
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  			       args->inumber);
  			break;
  		}
@@@ -1124,10 -968,11 +1168,18 @@@ xfs_dir2_sf_replace
  			if (xfs_da_compname(args, sfep->name, sfep->namelen) ==
  								XFS_CMP_EXACT) {
  #if XFS_BIG_INUMS || defined(DEBUG)
++<<<<<<< HEAD
 +				ino = xfs_dir2_sfe_get_ino(sfp, sfep);
 +				ASSERT(args->inumber != ino);
 +#endif
 +				xfs_dir2_sfe_put_ino(sfp, sfep, args->inumber);
++=======
+ 				ino = dp->d_ops->sf_get_ino(sfp, sfep);
+ 				ASSERT(args->inumber != ino);
+ #endif
+ 				dp->d_ops->sf_put_ino(sfp, sfep, args->inumber);
+ 				dp->d_ops->sf_put_ftype(sfep, args->filetype);
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  				break;
  			}
  		}
@@@ -1240,8 -1087,9 +1292,14 @@@ xfs_dir2_sf_toino4
  		sfep->namelen = oldsfep->namelen;
  		sfep->offset = oldsfep->offset;
  		memcpy(sfep->name, oldsfep->name, sfep->namelen);
++<<<<<<< HEAD
 +		xfs_dir2_sfe_put_ino(sfp, sfep,
 +			xfs_dir2_sfe_get_ino(oldsfp, oldsfep));
++=======
+ 		dp->d_ops->sf_put_ino(sfp, sfep,
+ 				      dp->d_ops->sf_get_ino(oldsfp, oldsfep));
+ 		dp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  	}
  	/*
  	 * Clean up the inode.
@@@ -1315,8 -1165,9 +1373,14 @@@ xfs_dir2_sf_toino8
  		sfep->namelen = oldsfep->namelen;
  		sfep->offset = oldsfep->offset;
  		memcpy(sfep->name, oldsfep->name, sfep->namelen);
++<<<<<<< HEAD
 +		xfs_dir2_sfe_put_ino(sfp, sfep,
 +			xfs_dir2_sfe_get_ino(oldsfp, oldsfep));
++=======
+ 		dp->d_ops->sf_put_ino(sfp, sfep,
+ 				      dp->d_ops->sf_get_ino(oldsfp, oldsfep));
+ 		dp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));
++>>>>>>> 4740175e75f7 (xfs: vectorise remaining shortform dir2 ops)
  	}
  	/*
  	 * Clean up the inode.
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_dir2_readdir.c
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_dir2.h
* Unmerged path fs/xfs/xfs_dir2_block.c
* Unmerged path fs/xfs/xfs_dir2_format.h
* Unmerged path fs/xfs/xfs_dir2_readdir.c
* Unmerged path fs/xfs/xfs_dir2_sf.c
