RPCSEC_GSS: Switch auth_gss to use the new framework for pipefs dentries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] sunrpc: RPCSEC_GSS, Switch auth_gss to use the new framework for pipefs dentries (Jeff Layton) [1002576]
Rebuild_FUZZ: 93.42%
commit-author Trond Myklebust <Trond.Myklebust@netapp.com>
commit 1917228435eebdf4e3267fa95cace694b2fb4efd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/19172284.failed

	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit 1917228435eebdf4e3267fa95cace694b2fb4efd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/auth_gss/auth_gss.c
diff --cc net/sunrpc/auth_gss/auth_gss.c
index 5f322fd964f7,d214aecdbeef..000000000000
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@@ -805,66 -810,71 +809,90 @@@ static void gss_pipe_dentry_destroy(str
  	}
  }
  
- static int gss_pipes_dentries_create(struct rpc_auth *auth)
+ static int gss_pipe_dentry_create(struct dentry *dir,
+ 		struct rpc_pipe_dir_object *pdo)
  {
- 	int err;
- 	struct gss_auth *gss_auth;
- 	struct rpc_clnt *clnt;
+ 	struct gss_pipe *p = pdo->pdo_data;
  	struct dentry *dentry;
  
- 	gss_auth = container_of(auth, struct gss_auth, rpc_auth);
- 	clnt = gss_auth->client;
+ 	dentry = rpc_mkpipe_dentry(dir, p->name, p->clnt, p->pipe);
+ 	if (IS_ERR(dentry))
+ 		return PTR_ERR(dentry);
+ 	p->pipe->dentry = dentry;
+ 	return 0;
+ }
+ 
+ static const struct rpc_pipe_dir_object_ops gss_pipe_dir_object_ops = {
+ 	.create = gss_pipe_dentry_create,
+ 	.destroy = gss_pipe_dentry_destroy,
+ };
+ 
+ static struct gss_pipe *gss_pipe_alloc(struct rpc_clnt *clnt,
+ 		const char *name,
+ 		const struct rpc_pipe_ops *upcall_ops)
+ {
+ 	struct net *net = rpc_net_ns(clnt);
+ 	struct gss_pipe *p;
+ 	int err = -ENOMEM;
  
- 	dentry = rpc_mkpipe_dentry(clnt->cl_dentry, "gssd",
- 			clnt, gss_auth->pipe[1]);
- 	if (IS_ERR(dentry)) {
- 		err = PTR_ERR(dentry);
+ 	p = kmalloc(sizeof(*p), GFP_KERNEL);
+ 	if (p == NULL)
  		goto err;
+ 	p->pipe = rpc_mkpipe_data(upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);
+ 	if (IS_ERR(p->pipe)) {
+ 		err = PTR_ERR(p->pipe);
+ 		goto err_free_gss_pipe;
  	}
- 	gss_auth->pipe[1]->dentry = dentry;
- 	dentry = rpc_mkpipe_dentry(clnt->cl_dentry, gss_auth->mech->gm_name,
- 			clnt, gss_auth->pipe[0]);
- 	if (IS_ERR(dentry)) {
- 		err = PTR_ERR(dentry);
- 		goto err_unlink_pipe_1;
- 	}
- 	return 0;
- 
- err_unlink_pipe_1:
- 	rpc_unlink(gss_auth->pipe[1]->dentry);
- 	gss_auth->pipe[1]->dentry = NULL;
+ 	p->name = name;
+ 	p->clnt = clnt;
+ 	rpc_init_pipe_dir_object(&p->pdo,
+ 			&gss_pipe_dir_object_ops,
+ 			p);
+ 	err = rpc_add_pipe_dir_object(net, &clnt->cl_pipedir_objects, &p->pdo);
+ 	if (!err)
+ 		return p;
+ 	rpc_destroy_pipe_data(p->pipe);
+ err_free_gss_pipe:
+ 	kfree(p);
  err:
- 	return err;
+ 	return ERR_PTR(err);
  }
  
- static void gss_pipes_dentries_destroy_net(struct rpc_clnt *clnt,
- 					   struct rpc_auth *auth)
+ static void __gss_pipe_free(struct gss_pipe *p)
  {
++<<<<<<< HEAD
 +	struct net *net = rpc_net_ns(clnt);
 +	struct super_block *sb;
++=======
+ 	struct rpc_clnt *clnt = p->clnt;
+ 	struct net *net = rpc_net_ns(clnt);
++>>>>>>> 1917228435ee (RPCSEC_GSS: Switch auth_gss to use the new framework for pipefs dentries)
  
- 	sb = rpc_get_sb_net(net);
- 	if (sb) {
- 		if (clnt->cl_dentry)
- 			gss_pipes_dentries_destroy(auth);
- 		rpc_put_sb_net(net);
- 	}
+ 	rpc_remove_pipe_dir_object(net,
+ 			&clnt->cl_pipedir_objects,
+ 			&p->pdo);
+ 	rpc_destroy_pipe_data(p->pipe);
+ 	kfree(p);
  }
  
- static int gss_pipes_dentries_create_net(struct rpc_clnt *clnt,
- 					 struct rpc_auth *auth)
+ static void gss_pipe_free(struct gss_pipe *p)
  {
++<<<<<<< HEAD
 +	struct net *net = rpc_net_ns(clnt);
 +	struct super_block *sb;
 +	int err = 0;
 +
 +	sb = rpc_get_sb_net(net);
 +	if (sb) {
 +		if (clnt->cl_dentry)
 +			err = gss_pipes_dentries_create(auth);
 +		rpc_put_sb_net(net);
 +	}
 +	return err;
++=======
+ 	if (p != NULL)
+ 		__gss_pipe_free(p);
++>>>>>>> 1917228435ee (RPCSEC_GSS: Switch auth_gss to use the new framework for pipefs dentries)
  }
  
  /*
@@@ -915,35 -930,30 +947,28 @@@ gss_create(struct rpc_auth_create_args 
  	 * that we supported only the old pipe.  So we instead create
  	 * the new pipe first.
  	 */
- 	gss_auth->pipe[1] = rpc_mkpipe_data(&gss_upcall_ops_v1,
- 					    RPC_PIPE_WAIT_FOR_OPEN);
- 	if (IS_ERR(gss_auth->pipe[1])) {
- 		err = PTR_ERR(gss_auth->pipe[1]);
- 		goto err_put_mech;
+ 	gss_pipe = gss_pipe_alloc(clnt, "gssd", &gss_upcall_ops_v1);
+ 	if (IS_ERR(gss_pipe)) {
+ 		err = PTR_ERR(gss_pipe);
+ 		goto err_destroy_credcache;
  	}
+ 	gss_auth->gss_pipe[1] = gss_pipe;
  
- 	gss_auth->pipe[0] = rpc_mkpipe_data(&gss_upcall_ops_v0,
- 					    RPC_PIPE_WAIT_FOR_OPEN);
- 	if (IS_ERR(gss_auth->pipe[0])) {
- 		err = PTR_ERR(gss_auth->pipe[0]);
+ 	gss_pipe = gss_pipe_alloc(clnt, gss_auth->mech->gm_name,
+ 			&gss_upcall_ops_v0);
+ 	if (IS_ERR(gss_pipe)) {
+ 		err = PTR_ERR(gss_pipe);
  		goto err_destroy_pipe_1;
  	}
- 	err = gss_pipes_dentries_create_net(clnt, auth);
- 	if (err)
- 		goto err_destroy_pipe_0;
- 	err = rpcauth_init_credcache(auth);
- 	if (err)
- 		goto err_unlink_pipes;
+ 	gss_auth->gss_pipe[0] = gss_pipe;
  
  	return auth;
- err_unlink_pipes:
- 	gss_pipes_dentries_destroy_net(clnt, auth);
- err_destroy_pipe_0:
- 	rpc_destroy_pipe_data(gss_auth->pipe[0]);
  err_destroy_pipe_1:
- 	rpc_destroy_pipe_data(gss_auth->pipe[1]);
+ 	__gss_pipe_free(gss_auth->gss_pipe[1]);
+ err_destroy_credcache:
+ 	rpcauth_destroy_credcache(auth);
  err_put_mech:
  	gss_mech_put(gss_auth->mech);
 -err_put_net:
 -	put_net(gss_auth->net);
  err_free:
  	kfree(gss_auth->target_name);
  	kfree(gss_auth);
@@@ -955,10 -965,10 +980,9 @@@ out_dec
  static void
  gss_free(struct gss_auth *gss_auth)
  {
- 	gss_pipes_dentries_destroy_net(gss_auth->client, &gss_auth->rpc_auth);
- 	rpc_destroy_pipe_data(gss_auth->pipe[0]);
- 	rpc_destroy_pipe_data(gss_auth->pipe[1]);
+ 	gss_pipe_free(gss_auth->gss_pipe[0]);
+ 	gss_pipe_free(gss_auth->gss_pipe[1]);
  	gss_mech_put(gss_auth->mech);
 -	put_net(gss_auth->net);
  	kfree(gss_auth->target_name);
  
  	kfree(gss_auth);
* Unmerged path net/sunrpc/auth_gss/auth_gss.c
