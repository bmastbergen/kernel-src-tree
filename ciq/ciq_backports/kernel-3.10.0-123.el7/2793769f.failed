ALSA: hda - Enable mute/mic-mute LEDs for more Thinkpads with Realtek codec

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [alsa] hda: Enable mute/mic-mute LEDs for more Thinkpads with Realtek codec (Jaroslav Kysela) [1044022]
Rebuild_FUZZ: 93.71%
commit-author David Henningsson <david.henningsson@canonical.com>
commit 2793769f4450d9e4845257c953ae278ecdff7d94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/2793769f.failed

We're using the ACPI interface to detect whether we're dealing with a Thinkpad
or not. This way we're not loading the thinkpad_acpi module when we're not on
a Thinkpad, but at the same time, we give the opportunity to check for, and
potentially enable, both present and future Thinkpad with mute/micmute LEDs.

At least those running the ALC269 family (269 to 299) of Realtek codecs.

	Cc: Alex Hung <alex.hung@canonical.com>
	Tested-by: Hui Wang <hui.wang@canonical.com>
	Signed-off-by: David Henningsson <david.henningsson@canonical.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 2793769f4450d9e4845257c953ae278ecdff7d94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_realtek.c
diff --cc sound/pci/hda/patch_realtek.c
index fd9f8f333568,05987ffb59d0..000000000000
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@@ -3461,6 -3640,105 +3461,108 @@@ static void alc282_fixup_asus_tx300(str
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void alc290_fixup_mono_speakers(struct hda_codec *codec,
+ 				       const struct hda_fixup *fix, int action)
+ {
+ 	if (action == HDA_FIXUP_ACT_PRE_PROBE)
+ 		/* Remove DAC node 0x03, as it seems to be
+ 		   giving mono output */
+ 		snd_hda_override_wcaps(codec, 0x03, 0);
+ }
+ 
+ #if IS_ENABLED(CONFIG_THINKPAD_ACPI)
+ 
+ #include <linux/thinkpad_acpi.h>
+ #include <acpi/acpi.h>
+ 
+ static int (*led_set_func)(int, bool);
+ 
+ static acpi_status acpi_check_cb(acpi_handle handle, u32 lvl, void *context,
+ 				 void **rv)
+ {
+ 	bool *found = context;
+ 	*found = true;
+ 	return AE_OK;
+ }
+ 
+ static bool is_thinkpad(struct hda_codec *codec)
+ {
+ 	bool found = false;
+ 	if (codec->subsystem_id >> 16 != 0x17aa)
+ 		return false;
+ 	if (ACPI_SUCCESS(acpi_get_devices("LEN0068", acpi_check_cb, &found, NULL)) && found)
+ 		return true;
+ 	found = false;
+ 	return ACPI_SUCCESS(acpi_get_devices("IBM0068", acpi_check_cb, &found, NULL)) && found;
+ }
+ 
+ static void update_tpacpi_mute_led(void *private_data, int enabled)
+ {
+ 	if (led_set_func)
+ 		led_set_func(TPACPI_LED_MUTE, !enabled);
+ }
+ 
+ static void update_tpacpi_micmute_led(struct hda_codec *codec,
+ 				      struct snd_ctl_elem_value *ucontrol)
+ {
+ 	if (!ucontrol || !led_set_func)
+ 		return;
+ 	if (strcmp("Capture Switch", ucontrol->id.name) == 0 && ucontrol->id.index == 0) {
+ 		/* TODO: How do I verify if it's a mono or stereo here? */
+ 		bool val = ucontrol->value.integer.value[0] || ucontrol->value.integer.value[1];
+ 		led_set_func(TPACPI_LED_MICMUTE, !val);
+ 	}
+ }
+ 
+ static void alc_fixup_thinkpad_acpi(struct hda_codec *codec,
+ 				  const struct hda_fixup *fix, int action)
+ {
+ 	struct alc_spec *spec = codec->spec;
+ 	bool removefunc = false;
+ 
+ 	if (action == HDA_FIXUP_ACT_PROBE) {
+ 		if (!is_thinkpad(codec))
+ 			return;
+ 		if (!led_set_func)
+ 			led_set_func = symbol_request(tpacpi_led_set);
+ 		if (!led_set_func) {
+ 			snd_printk(KERN_WARNING "Failed to find thinkpad-acpi symbol tpacpi_led_set\n");
+ 			return;
+ 		}
+ 
+ 		removefunc = true;
+ 		if (led_set_func(TPACPI_LED_MUTE, false) >= 0) {
+ 			spec->gen.vmaster_mute.hook = update_tpacpi_mute_led;
+ 			removefunc = false;
+ 		}
+ 		if (led_set_func(TPACPI_LED_MICMUTE, false) >= 0) {
+ 			if (spec->gen.num_adc_nids > 1)
+ 				snd_printdd("Skipping micmute LED control due to several ADCs");
+ 			else {
+ 				spec->gen.cap_sync_hook = update_tpacpi_micmute_led;
+ 				removefunc = false;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (led_set_func && (action == HDA_FIXUP_ACT_FREE || removefunc)) {
+ 		symbol_put(tpacpi_led_set);
+ 		led_set_func = NULL;
+ 	}
+ }
+ 
+ #else
+ 
+ static void alc_fixup_thinkpad_acpi(struct hda_codec *codec,
+ 				  const struct hda_fixup *fix, int action)
+ {
+ }
+ 
+ #endif
+ 
++>>>>>>> 2793769f4450 (ALSA: hda - Enable mute/mic-mute LEDs for more Thinkpads with Realtek codec)
  enum {
  	ALC269_FIXUP_SONY_VAIO,
  	ALC275_FIXUP_SONY_VAIO_GPIO2,
@@@ -3776,6 -4085,30 +3880,33 @@@ static const struct hda_fixup alc269_fi
  		.chained = true,
  		.chain_id = ALC269_FIXUP_LIMIT_INT_MIC_BOOST
  	},
++<<<<<<< HEAD
++=======
+ 	[ALC290_FIXUP_MONO_SPEAKERS] = {
+ 		.type = HDA_FIXUP_FUNC,
+ 		.v.func = alc290_fixup_mono_speakers,
+ 		.chained = true,
+ 		.chain_id = ALC269_FIXUP_DELL3_MIC_NO_PRESENCE,
+ 	},
+ 	[ALC269_FIXUP_THINKPAD_ACPI] = {
+ 		.type = HDA_FIXUP_FUNC,
+ 		.v.func = alc_fixup_thinkpad_acpi,
+ 	},
+ 	[ALC255_FIXUP_DELL1_MIC_NO_PRESENCE] = {
+ 		.type = HDA_FIXUP_PINS,
+ 		.v.pins = (const struct hda_pintbl[]) {
+ 			{ 0x19, 0x01a1913c }, /* use as headset mic, without its own jack detect */
+ 			{ 0x1a, 0x01a1913d }, /* use as headphone mic, without its own jack detect */
+ 			{ }
+ 		},
+ 		.chained = true,
+ 		.chain_id = ALC255_FIXUP_HEADSET_MODE
+ 	},
+ 	[ALC255_FIXUP_HEADSET_MODE] = {
+ 		.type = HDA_FIXUP_FUNC,
+ 		.v.func = alc_fixup_headset_mode_alc255,
+ 	},
++>>>>>>> 2793769f4450 (ALSA: hda - Enable mute/mic-mute LEDs for more Thinkpads with Realtek codec)
  };
  
  static const struct snd_pci_quirk alc269_fixup_tbl[] = {
* Unmerged path sound/pci/hda/patch_realtek.c
