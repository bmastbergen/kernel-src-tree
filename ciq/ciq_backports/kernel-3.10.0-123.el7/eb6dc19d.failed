RPCSEC_GSS: Share all credential caches on a per-transport basis

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] sunrpc: RPCSEC_GSS, Share all credential caches on a per-transport basis (Jeff Layton) [1002576]
Rebuild_FUZZ: 92.65%
commit-author Trond Myklebust <Trond.Myklebust@netapp.com>
commit eb6dc19d8e72ce3a957af5511d20c0db0a8bd007
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/eb6dc19d.failed

Ensure that all struct rpc_clnt for any given socket/rdma channel
share the same RPCSEC_GSS/krb5,krb5i,krb5p caches.

	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit eb6dc19d8e72ce3a957af5511d20c0db0a8bd007)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/auth_gss/auth_gss.c
diff --cc net/sunrpc/auth_gss/auth_gss.c
index 5f322fd964f7,dc4b449d3680..000000000000
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@@ -71,8 -72,20 +72,23 @@@ static unsigned int gss_expired_cred_re
   * using integrity (two 4-byte integers): */
  #define GSS_VERF_SLACK		100
  
++<<<<<<< HEAD
++=======
+ static DEFINE_HASHTABLE(gss_auth_hash_table, 16);
+ static DEFINE_SPINLOCK(gss_auth_hash_lock);
+ 
+ struct gss_pipe {
+ 	struct rpc_pipe_dir_object pdo;
+ 	struct rpc_pipe *pipe;
+ 	struct rpc_clnt *clnt;
+ 	const char *name;
+ 	struct kref kref;
+ };
+ 
++>>>>>>> eb6dc19d8e72 (RPCSEC_GSS: Share all credential caches on a per-transport basis)
  struct gss_auth {
  	struct kref kref;
+ 	struct hlist_node hash;
  	struct rpc_auth rpc_auth;
  	struct gss_api_mech *mech;
  	enum rpc_gss_svc service;
@@@ -915,35 -995,30 +932,39 @@@ gss_create_new(struct rpc_auth_create_a
  	 * that we supported only the old pipe.  So we instead create
  	 * the new pipe first.
  	 */
 -	gss_pipe = gss_pipe_get(clnt, "gssd", &gss_upcall_ops_v1);
 -	if (IS_ERR(gss_pipe)) {
 -		err = PTR_ERR(gss_pipe);
 -		goto err_destroy_credcache;
 +	gss_auth->pipe[1] = rpc_mkpipe_data(&gss_upcall_ops_v1,
 +					    RPC_PIPE_WAIT_FOR_OPEN);
 +	if (IS_ERR(gss_auth->pipe[1])) {
 +		err = PTR_ERR(gss_auth->pipe[1]);
 +		goto err_put_mech;
  	}
 -	gss_auth->gss_pipe[1] = gss_pipe;
  
 -	gss_pipe = gss_pipe_get(clnt, gss_auth->mech->gm_name,
 -			&gss_upcall_ops_v0);
 -	if (IS_ERR(gss_pipe)) {
 -		err = PTR_ERR(gss_pipe);
 +	gss_auth->pipe[0] = rpc_mkpipe_data(&gss_upcall_ops_v0,
 +					    RPC_PIPE_WAIT_FOR_OPEN);
 +	if (IS_ERR(gss_auth->pipe[0])) {
 +		err = PTR_ERR(gss_auth->pipe[0]);
  		goto err_destroy_pipe_1;
  	}
 -	gss_auth->gss_pipe[0] = gss_pipe;
 -
 +	err = gss_pipes_dentries_create_net(clnt, auth);
 +	if (err)
 +		goto err_destroy_pipe_0;
 +	err = rpcauth_init_credcache(auth);
 +	if (err)
 +		goto err_unlink_pipes;
 +
++<<<<<<< HEAD
 +	return auth;
 +err_unlink_pipes:
 +	gss_pipes_dentries_destroy_net(clnt, auth);
 +err_destroy_pipe_0:
 +	rpc_destroy_pipe_data(gss_auth->pipe[0]);
++=======
+ 	return gss_auth;
++>>>>>>> eb6dc19d8e72 (RPCSEC_GSS: Share all credential caches on a per-transport basis)
  err_destroy_pipe_1:
 -	gss_pipe_free(gss_auth->gss_pipe[1]);
 -err_destroy_credcache:
 -	rpcauth_destroy_credcache(auth);
 +	rpc_destroy_pipe_data(gss_auth->pipe[1]);
  err_put_mech:
  	gss_mech_put(gss_auth->mech);
 -err_put_net:
 -	put_net(gss_auth->net);
  err_free:
  	kfree(gss_auth->target_name);
  	kfree(gss_auth);
@@@ -981,9 -1057,18 +1002,22 @@@ gss_destroy(struct rpc_auth *auth
  	dprintk("RPC:       destroying GSS authenticator %p flavor %d\n",
  			auth, auth->au_flavor);
  
++<<<<<<< HEAD
++=======
+ 	if (hash_hashed(&gss_auth->hash)) {
+ 		spin_lock(&gss_auth_hash_lock);
+ 		hash_del(&gss_auth->hash);
+ 		spin_unlock(&gss_auth_hash_lock);
+ 	}
+ 
+ 	gss_pipe_free(gss_auth->gss_pipe[0]);
+ 	gss_auth->gss_pipe[0] = NULL;
+ 	gss_pipe_free(gss_auth->gss_pipe[1]);
+ 	gss_auth->gss_pipe[1] = NULL;
++>>>>>>> eb6dc19d8e72 (RPCSEC_GSS: Share all credential caches on a per-transport basis)
  	rpcauth_destroy_credcache(auth);
  
 +	gss_auth = container_of(auth, struct gss_auth, rpc_auth);
  	kref_put(&gss_auth->kref, gss_free_callback);
  }
  
* Unmerged path net/sunrpc/auth_gss/auth_gss.c
