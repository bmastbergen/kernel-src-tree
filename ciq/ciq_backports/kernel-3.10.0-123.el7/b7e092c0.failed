netfilter: ctnetlink: fix uninitialized variable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Florian Westphal <fw@strlen.de>
commit b7e092c05b308674c642ed7fb754d555f0ebba81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/b7e092c0.failed

net/netfilter/nf_conntrack_netlink.c: In function 'ctnetlink_nfqueue_attach_expect':
'helper' may be used uninitialized in this function

It was only initialized in if CTA_EXPECT_HELP_NAME attribute was
present, it must be NULL otherwise.

Problem added recently in bd077937
(netfilter: nfnetlink_queue: allow to attach expectations to conntracks).

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit b7e092c05b308674c642ed7fb754d555f0ebba81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_netlink.c
diff --cc net/netfilter/nf_conntrack_netlink.c
index 9aaa68bbbcdb,eea936b70d15..000000000000
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@@ -2127,6 -2140,64 +2127,67 @@@ ctnetlink_nfqueue_parse(const struct nl
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int ctnetlink_nfqueue_exp_parse(const struct nlattr * const *cda,
+ 				       const struct nf_conn *ct,
+ 				       struct nf_conntrack_tuple *tuple,
+ 				       struct nf_conntrack_tuple *mask)
+ {
+ 	int err;
+ 
+ 	err = ctnetlink_parse_tuple(cda, tuple, CTA_EXPECT_TUPLE,
+ 				    nf_ct_l3num(ct));
+ 	if (err < 0)
+ 		return err;
+ 
+ 	return ctnetlink_parse_tuple(cda, mask, CTA_EXPECT_MASK,
+ 				     nf_ct_l3num(ct));
+ }
+ 
+ static int
+ ctnetlink_nfqueue_attach_expect(const struct nlattr *attr, struct nf_conn *ct,
+ 				u32 portid, u32 report)
+ {
+ 	struct nlattr *cda[CTA_EXPECT_MAX+1];
+ 	struct nf_conntrack_tuple tuple, mask;
+ 	struct nf_conntrack_helper *helper = NULL;
+ 	struct nf_conntrack_expect *exp;
+ 	int err;
+ 
+ 	err = nla_parse_nested(cda, CTA_EXPECT_MAX, attr, exp_nla_policy);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = ctnetlink_nfqueue_exp_parse((const struct nlattr * const *)cda,
+ 					  ct, &tuple, &mask);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (cda[CTA_EXPECT_HELP_NAME]) {
+ 		const char *helpname = nla_data(cda[CTA_EXPECT_HELP_NAME]);
+ 
+ 		helper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),
+ 						    nf_ct_protonum(ct));
+ 		if (helper == NULL)
+ 			return -EOPNOTSUPP;
+ 	}
+ 
+ 	exp = ctnetlink_alloc_expect((const struct nlattr * const *)cda, ct,
+ 				     helper, &tuple, &mask);
+ 	if (IS_ERR(exp))
+ 		return PTR_ERR(exp);
+ 
+ 	err = nf_ct_expect_related_report(exp, portid, report);
+ 	if (err < 0) {
+ 		nf_ct_expect_put(exp);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> b7e092c05b30 (netfilter: ctnetlink: fix uninitialized variable)
  static struct nfq_ct_hook ctnetlink_nfqueue_hook = {
  	.build_size	= ctnetlink_nfqueue_build_size,
  	.build		= ctnetlink_nfqueue_build,
* Unmerged path net/netfilter/nf_conntrack_netlink.c
