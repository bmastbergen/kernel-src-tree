ath9k: Add custom parameters for CUS198

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Sujith Manoharan <c_manoha@qca.qualcomm.com>
commit 9b60b64bfe98b9cc01b21e6126819b11a0f0a971
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/9b60b64b.failed

CUS198 is a card based on AR9485. There are differences
between the base reference design HB125 and CUS198.
Identify such cards based on the PCI subsystem IDs and
set HW parameters appropriately.

Addresses this bug - https://bugzilla.kernel.org/show_bug.cgi?id=49201

	Cc: jkp@iki.fi
	Cc: gfmichaud@gmail.com
	Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
	Signed-off-by: John W. Linville <linville@tuxdriver.com>
(cherry picked from commit 9b60b64bfe98b9cc01b21e6126819b11a0f0a971)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
diff --cc drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
index e6b92ff265fd,9a00bc0a9304..000000000000
--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
@@@ -3563,14 -3563,24 +3563,32 @@@ static void ar9003_hw_ant_ctrl_apply(st
  {
  	struct ath9k_hw_capabilities *pCap = &ah->caps;
  	int chain;
++<<<<<<< HEAD
 +	u32 regval;
++=======
+ 	u32 regval, value, gpio;
++>>>>>>> 9b60b64bfe98 (ath9k: Add custom parameters for CUS198)
  	static const u32 switch_chain_reg[AR9300_MAX_CHAINS] = {
  			AR_PHY_SWITCH_CHAIN_0,
  			AR_PHY_SWITCH_CHAIN_1,
  			AR_PHY_SWITCH_CHAIN_2,
  	};
  
++<<<<<<< HEAD
 +	u32 value = ar9003_hw_ant_ctrl_common_get(ah, is2ghz);
++=======
+ 	if (AR_SREV_9485(ah) && (ar9003_hw_get_rx_gain_idx(ah) == 0)) {
+ 		if (ah->config.xlna_gpio)
+ 			gpio = ah->config.xlna_gpio;
+ 		else
+ 			gpio = AR9300_EXT_LNA_CTL_GPIO_AR9485;
+ 
+ 		ath9k_hw_cfg_output(ah, AR9300_EXT_LNA_CTL_GPIO_AR9485,
+ 				    AR_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED);
+ 	}
+ 
+ 	value = ar9003_hw_ant_ctrl_common_get(ah, is2ghz);
++>>>>>>> 9b60b64bfe98 (ath9k: Add custom parameters for CUS198)
  
  	if (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {
  		REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,
* Unmerged path drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
diff --git a/drivers/net/wireless/ath/ath9k/ath9k.h b/drivers/net/wireless/ath/ath9k/ath9k.h
index 42b03dc39d14..7c587fc45233 100644
--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -623,6 +623,8 @@ void ath_ant_comb_update(struct ath_softc *sc);
 /* Main driver core */
 /********************/
 
+#define ATH9K_PCI_CUS198 0x0001
+
 /*
  * Default cache line size, in bytes.
  * Used when PCI device not fully initialized by bootrom/BIOS
@@ -706,6 +708,7 @@ struct ath_softc {
 
 	unsigned int hw_busy_count;
 	unsigned long sc_flags;
+	unsigned long driver_data;
 
 	u32 intrstatus;
 	u16 ps_flags; /* PS_* */
diff --git a/drivers/net/wireless/ath/ath9k/hw.h b/drivers/net/wireless/ath/ath9k/hw.h
index ae3034374bc4..a0f0027985e5 100644
--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -310,6 +310,10 @@ struct ath9k_ops_config {
 	u16 spurchans[AR_EEPROM_MODAL_SPURS][2];
 	u8 max_txtrig_level;
 	u16 ani_poll_interval; /* ANI poll interval in ms */
+
+	/* Platform specific config */
+	u32 xlna_gpio;
+	bool xatten_margin_cfg;
 };
 
 enum ath9k_int {
diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c
index 2ba494567777..c784a94abeca 100644
--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -510,6 +510,22 @@ static void ath9k_init_misc(struct ath_softc *sc)
 	sc->spec_config.fft_period = 0xF;
 }
 
+static void ath9k_init_platform(struct ath_softc *sc)
+{
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	if (common->bus_ops->ath_bus_type != ATH_PCI)
+		return;
+
+	if (sc->driver_data & ATH9K_PCI_CUS198) {
+		ah->config.xlna_gpio = 9;
+		ah->config.xatten_margin_cfg = true;
+
+		ath_info(common, "Set parameters for CUS198\n");
+	}
+}
+
 static void ath9k_eeprom_request_cb(const struct firmware *eeprom_blob,
 				    void *ctx)
 {
@@ -601,6 +617,11 @@ static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
 	common->btcoex_enabled = ath9k_btcoex_enable == 1;
 	common->disable_ani = false;
 
+	/*
+	 * Platform quirks.
+	 */
+	ath9k_init_platform(sc);
+
 	/*
 	 * Enable Antenna diversity only when BTCOEX is disabled
 	 * and the user manually requests the feature.
diff --git a/drivers/net/wireless/ath/ath9k/pci.c b/drivers/net/wireless/ath/ath9k/pci.c
index 0e0d39583837..4ac00b4b0d25 100644
--- a/drivers/net/wireless/ath/ath9k/pci.c
+++ b/drivers/net/wireless/ath/ath9k/pci.c
@@ -34,6 +34,34 @@ static DEFINE_PCI_DEVICE_TABLE(ath_pci_id_table) = {
 	{ PCI_VDEVICE(ATHEROS, 0x002D) }, /* PCI   */
 	{ PCI_VDEVICE(ATHEROS, 0x002E) }, /* PCI-E */
 	{ PCI_VDEVICE(ATHEROS, 0x0030) }, /* PCI-E  AR9300 */
+
+	/* PCI-E CUS198 */
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+			 0x0032,
+			 PCI_VENDOR_ID_AZWAVE,
+			 0x2086),
+	  .driver_data = ATH9K_PCI_CUS198 },
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+			 0x0032,
+			 PCI_VENDOR_ID_AZWAVE,
+			 0x1237),
+	  .driver_data = ATH9K_PCI_CUS198 },
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+			 0x0032,
+			 PCI_VENDOR_ID_AZWAVE,
+			 0x2126),
+	  .driver_data = ATH9K_PCI_CUS198 },
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+			 0x0032,
+			 PCI_VENDOR_ID_AZWAVE,
+			 0x2152),
+	  .driver_data = ATH9K_PCI_CUS198 },
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+			 0x0032,
+			 PCI_VENDOR_ID_FOXCONN,
+			 0xE075),
+	  .driver_data = ATH9K_PCI_CUS198 },
+
 	{ PCI_VDEVICE(ATHEROS, 0x0032) }, /* PCI-E  AR9485 */
 	{ PCI_VDEVICE(ATHEROS, 0x0033) }, /* PCI-E  AR9580 */
 	{ PCI_VDEVICE(ATHEROS, 0x0034) }, /* PCI-E  AR9462 */
@@ -221,6 +249,7 @@ static int ath_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	sc->hw = hw;
 	sc->dev = &pdev->dev;
 	sc->mem = pcim_iomap_table(pdev)[0];
+	sc->driver_data = id->driver_data;
 
 	/* Will be cleared in ath9k_start() */
 	set_bit(SC_OP_INVALID, &sc->sc_flags);
