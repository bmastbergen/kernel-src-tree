ARC: fix smatch warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [scsi] bfa: Fix smatch warnings (Vijay Guvva) [1032723]
Rebuild_FUZZ: 89.36%
commit-author Vineet Gupta <vgupta@kernel.org>
commit 4eb69d00fe967699b9d93f7e74a990fe813e8d2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/4eb69d00.failed

	Reported-by: kernel test robot <lkp@intel.com>
	Reported-by: Dan Carpenter <error27@gmail.com>
Closes: https://lore.kernel.org/r/202311280906.VAIwEAfT-lkp@intel.com/
	Signed-off-by: Vineet Gupta <vgupta@kernel.org>
(cherry picked from commit 4eb69d00fe967699b9d93f7e74a990fe813e8d2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arc/kernel/setup.c
diff --cc arch/arc/kernel/setup.c
index b2b3731dd1e9,d08a5092c2b4..000000000000
--- a/arch/arc/kernel/setup.c
+++ b/arch/arc/kernel/setup.c
@@@ -35,60 -44,156 +35,139 @@@ struct machine_desc *machine_desc __cpu
  
  struct task_struct *_current_task[NR_CPUS];	/* For stack switching */
  
 -struct cpuinfo_arc {
 -	int arcver;
 -	unsigned int t0:1, t1:1;
 -	struct {
 -		unsigned long base;
 -		unsigned int sz;
 -	} iccm, dccm;
 -};
 +struct cpuinfo_arc cpuinfo_arc700[NR_CPUS];
  
 -#ifdef CONFIG_ISA_ARCV2
  
 -static const struct id_to_str arc_hs_rel[] = {
 -	/* ID.ARCVER,	Release */
 -	{ 0x51, 	"R2.0" },
 -	{ 0x52, 	"R2.1" },
 -	{ 0x53,		"R3.0" },
 -};
 +void __cpuinit read_arc_build_cfg_regs(void)
 +{
 +	struct bcr_perip uncached_space;
 +	struct cpuinfo_arc *cpu = &cpuinfo_arc700[smp_processor_id()];
 +	FIX_PTR(cpu);
  
 -static const struct id_to_str arc_hs_ver54_rel[] = {
 -	/* UARCH.MAJOR,	Release */
 -	{  0,		"R3.10a"},
 -	{  1,		"R3.50a"},
 -	{  2,		"R3.60a"},
 -	{  3,		"R4.00a"},
 -	{  0xFF,	NULL   }
 -};
 -#endif
 +	READ_BCR(AUX_IDENTITY, cpu->core);
  
 -static int
 -arcompact_mumbojumbo(int c, struct cpuinfo_arc *info, char *buf, int len)
 -{
 -	int n = 0;
 -#ifdef CONFIG_ISA_ARCOMPACT
 -	char *cpu_nm, *isa_nm = "ARCompact";
 -	struct bcr_fp_arcompact fpu_sp, fpu_dp;
 -	int atomic = 0, be, present;
 -	int bpu_full, bpu_cache, bpu_pred;
 -	struct bcr_bpu_arcompact bpu;
 -	struct bcr_iccm_arcompact iccm;
 -	struct bcr_dccm_arcompact dccm;
 -	struct bcr_generic isa;
 -
 -	READ_BCR(ARC_REG_ISA_CFG_BCR, isa);
 -
 -	if (!isa.ver)	/* ISA BCR absent, use Kconfig info */
 -		atomic = IS_ENABLED(CONFIG_ARC_HAS_LLSC);
 -	else {
 -		/* ARC700_BUILD only has 2 bits of isa info */
 -		atomic = isa.info & 1;
 -	}
 +	cpu->timers = read_aux_reg(ARC_REG_TIMERS_BCR);
  
 -	be = IS_ENABLED(CONFIG_CPU_BIG_ENDIAN);
 +	cpu->vec_base = read_aux_reg(AUX_INTR_VEC_BASE);
 +	if (cpu->vec_base == 0)
 +		cpu->vec_base = (unsigned int)_int_vec_base_lds;
  
 -	if (info->arcver < 0x34)
 -		cpu_nm = "ARC750";
 -	else
 -		cpu_nm = "ARC770";
 +	READ_BCR(ARC_REG_D_UNCACH_BCR, uncached_space);
 +	cpu->uncached_base = uncached_space.start << 24;
  
 -	n += scnprintf(buf + n, len - n, "processor [%d]\t: %s (%s ISA) %s%s%s\n",
 -		       c, cpu_nm, isa_nm,
 -		       IS_AVAIL2(atomic, "atomic ", CONFIG_ARC_HAS_LLSC),
 -		       IS_AVAIL1(be, "[Big-Endian]"));
 +	cpu->extn.mul = read_aux_reg(ARC_REG_MUL_BCR);
 +	cpu->extn.swap = read_aux_reg(ARC_REG_SWAP_BCR);
 +	cpu->extn.norm = read_aux_reg(ARC_REG_NORM_BCR);
 +	cpu->extn.minmax = read_aux_reg(ARC_REG_MIXMAX_BCR);
 +	cpu->extn.barrel = read_aux_reg(ARC_REG_BARREL_BCR);
 +	READ_BCR(ARC_REG_MAC_BCR, cpu->extn_mac_mul);
  
 -	READ_BCR(ARC_REG_FP_BCR, fpu_sp);
 -	READ_BCR(ARC_REG_DPFP_BCR, fpu_dp);
 +	cpu->extn.ext_arith = read_aux_reg(ARC_REG_EXTARITH_BCR);
 +	cpu->extn.crc = read_aux_reg(ARC_REG_CRC_BCR);
  
++<<<<<<< HEAD
 +	/* Note that we read the CCM BCRs independent of kernel config
 +	 * This is to catch the cases where user doesn't know that
 +	 * CCMs are present in hardware build
++=======
+ 	if (fpu_sp.ver | fpu_dp.ver)
+ 		n += scnprintf(buf + n, len - n, "FPU\t\t: %s%s\n",
+ 			       IS_AVAIL1(fpu_sp.ver, "SP "),
+ 			       IS_AVAIL1(fpu_dp.ver, "DP "));
+ 
+ 	READ_BCR(ARC_REG_BPU_BCR, bpu);
+ 	bpu_full = bpu.fam ? 1 : 0;
+ 	bpu_cache = 256 << (bpu.ent - 1);
+ 	bpu_pred = 256 << (bpu.ent - 1);
+ 
+ 	n += scnprintf(buf + n, len - n,
+ 			"BPU\t\t: %s%s match, cache:%d, Predict Table:%d\n",
+ 			IS_AVAIL1(bpu_full, "full"),
+ 			IS_AVAIL1(!bpu_full, "partial"),
+ 			bpu_cache, bpu_pred);
+ 
+ 	READ_BCR(ARC_REG_ICCM_BUILD, iccm);
+ 	if (iccm.ver) {
+ 		info->iccm.sz = 4096 << iccm.sz;	/* 8K to 512K */
+ 		info->iccm.base = iccm.base << 16;
+ 	}
+ 
+ 	READ_BCR(ARC_REG_DCCM_BUILD, dccm);
+ 	if (dccm.ver) {
+ 		unsigned long base;
+ 		info->dccm.sz = 2048 << dccm.sz;	/* 2K to 256K */
+ 
+ 		base = read_aux_reg(ARC_REG_DCCM_BASE_BUILD);
+ 		info->dccm.base = base & ~0xF;
+ 	}
+ 
+ 	/* ARCompact ISA specific sanity checks */
+ 	present = fpu_dp.ver;	/* SP has no arch visible regs */
+ 	CHK_OPT_STRICT(CONFIG_ARC_FPU_SAVE_RESTORE, present);
+ #endif
+ 	return n;
+ 
+ }
+ 
+ static int arcv2_mumbojumbo(int c, struct cpuinfo_arc *info, char *buf, int len)
+ {
+ 	int n = 0;
+ #ifdef CONFIG_ISA_ARCV2
+ 	const char *release = "", *cpu_nm = "HS38", *isa_nm = "ARCv2";
+ 	int dual_issue = 0, dual_enb = 0, mpy_opt, present;
+ 	int bpu_full, bpu_cache, bpu_pred, bpu_ret_stk;
+ 	char mpy_nm[16], lpb_nm[32];
+ 	struct bcr_isa_arcv2 isa;
+ 	struct bcr_mpy mpy;
+ 	struct bcr_fp_arcv2 fpu;
+ 	struct bcr_bpu_arcv2 bpu;
+ 	struct bcr_lpb lpb;
+ 	struct bcr_iccm_arcv2 iccm;
+ 	struct bcr_dccm_arcv2 dccm;
+ 	struct bcr_erp erp;
+ 
+ 	/*
+ 	 * Initial HS cores bumped AUX IDENTITY.ARCVER for each release until
+ 	 * ARCVER 0x54 which introduced AUX MICRO_ARCH_BUILD and subsequent
+ 	 * releases only update it.
++>>>>>>> 4eb69d00fe96 (ARC: fix smatch warning)
  	 */
 -
 +	{
 +		struct bcr_iccm iccm;
 +		struct bcr_dccm dccm;
 +		struct bcr_dccm_base dccm_base;
 +		unsigned int bcr_32bit_val;
 +
++<<<<<<< HEAD
 +		bcr_32bit_val = read_aux_reg(ARC_REG_ICCM_BCR);
 +		if (bcr_32bit_val) {
 +			iccm = *((struct bcr_iccm *)&bcr_32bit_val);
 +			cpu->iccm.base_addr = iccm.base << 16;
 +			cpu->iccm.sz = 0x2000 << (iccm.sz - 1);
++=======
+ 	if (info->arcver > 0x50 && info->arcver <= 0x53) {
+ 		release = arc_hs_rel[info->arcver - 0x51].str;
+ 	} else {
+ 		const struct id_to_str *tbl;
+ 		struct bcr_uarch_build uarch;
+ 
+ 		READ_BCR(ARC_REG_MICRO_ARCH_BCR, uarch);
+ 
+ 		for (tbl = &arc_hs_ver54_rel[0]; tbl->id != 0xFF; tbl++) {
+ 			if (uarch.maj == tbl->id) {
+ 				release = tbl->str;
+ 				break;
+ 			}
++>>>>>>> 4eb69d00fe96 (ARC: fix smatch warning)
  		}
 -		if (uarch.prod == 4) {
 -			unsigned int exec_ctrl;
 -
 -			cpu_nm = "HS48";
 -			dual_issue = 1;
 -			/* if dual issue hardware, is it enabled ? */
 -			READ_BCR(AUX_EXEC_CTRL, exec_ctrl);
 -			dual_enb = !(exec_ctrl & 1);
 +
 +		bcr_32bit_val = read_aux_reg(ARC_REG_DCCM_BCR);
 +		if (bcr_32bit_val) {
 +			dccm = *((struct bcr_dccm *)&bcr_32bit_val);
 +			cpu->dccm.sz = 0x800 << (dccm.sz);
 +
 +			READ_BCR(ARC_REG_DCCMBASE_BCR, dccm_base);
 +			cpu->dccm.base_addr = dccm_base.addr << 8;
  		}
  	}
  
* Unmerged path arch/arc/kernel/setup.c
