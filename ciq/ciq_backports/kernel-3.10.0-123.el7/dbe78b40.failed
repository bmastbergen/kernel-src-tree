powerpc/pseries: Do not start secondaries in Open Firmware

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [powerpc] pseries: Do not start secondaries in Open Firmware (Steve Best) [1012654]
Rebuild_FUZZ: 92.59%
commit-author Benjamin Herrenschmidt <benh@kernel.crashing.org>
commit dbe78b40118636f2d5d276144239dd4bfd5f04f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/dbe78b40.failed

Starting secondary CPUs early on from Open Firmware and placing them
in a holding spin loop slows down the boot process significantly under
some hypervisors such as KVM.

This is also unnecessary when RTAS supports querying the CPU state

So let's not do it.

	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit dbe78b40118636f2d5d276144239dd4bfd5f04f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/prom_init.c
diff --cc arch/powerpc/kernel/prom_init.c
index 5eccda9fd33f,5fe2842e8bab..000000000000
--- a/arch/powerpc/kernel/prom_init.c
+++ b/arch/powerpc/kernel/prom_init.c
@@@ -1540,12 -1569,19 +1542,21 @@@ static void __init prom_instantiate_rta
  
  	reserve_mem(base, size);
  
 -	val = cpu_to_be32(base);
  	prom_setprop(rtas_node, "/rtas", "linux,rtas-base",
 -		     &val, sizeof(val));
 -	val = cpu_to_be32(entry);
 +		     &base, sizeof(base));
  	prom_setprop(rtas_node, "/rtas", "linux,rtas-entry",
 -		     &val, sizeof(val));
 +		     &entry, sizeof(entry));
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PPC_POWERNV
++=======
+ 	/* Check if it supports "query-cpu-stopped-state" */
+ 	if (prom_getprop(rtas_node, "query-cpu-stopped-state",
+ 			 &val, sizeof(val)) != PROM_ERROR)
+ 		rtas_has_query_cpu_stopped = true;
+ 
+ #if defined(CONFIG_PPC_POWERNV) && defined(__BIG_ENDIAN__)
++>>>>>>> dbe78b401186 (powerpc/pseries: Do not start secondaries in Open Firmware)
  	/* PowerVN takeover hack */
  	prom_rtas_data = base;
  	prom_rtas_entry = entry;
* Unmerged path arch/powerpc/kernel/prom_init.c
diff --git a/arch/powerpc/platforms/pseries/smp.c b/arch/powerpc/platforms/pseries/smp.c
index 12bc8c3663ad..b48ccb2a0ec0 100644
--- a/arch/powerpc/platforms/pseries/smp.c
+++ b/arch/powerpc/platforms/pseries/smp.c
@@ -249,18 +249,24 @@ static void __init smp_init_pseries(void)
 
 	alloc_bootmem_cpumask_var(&of_spin_mask);
 
-	/* Mark threads which are still spinning in hold loops. */
-	if (cpu_has_feature(CPU_FTR_SMT)) {
-		for_each_present_cpu(i) { 
-			if (cpu_thread_in_core(i) == 0)
-				cpumask_set_cpu(i, of_spin_mask);
-		}
-	} else {
-		cpumask_copy(of_spin_mask, cpu_present_mask);
+	/*
+	 * Mark threads which are still spinning in hold loops
+	 *
+	 * We know prom_init will not have started them if RTAS supports
+	 * query-cpu-stopped-state.
+	 */
+	if (rtas_token("query-cpu-stopped-state") == RTAS_UNKNOWN_SERVICE) {
+		if (cpu_has_feature(CPU_FTR_SMT)) {
+			for_each_present_cpu(i) {
+				if (cpu_thread_in_core(i) == 0)
+					cpumask_set_cpu(i, of_spin_mask);
+			}
+		} else
+			cpumask_copy(of_spin_mask, cpu_present_mask);
+
+		cpumask_clear_cpu(boot_cpuid, of_spin_mask);
 	}
 
-	cpumask_clear_cpu(boot_cpuid, of_spin_mask);
-
 	/* Non-lpar has additional take/give timebase */
 	if (rtas_token("freeze-time-base") != RTAS_UNKNOWN_SERVICE) {
 		smp_ops->give_timebase = rtas_give_timebase;
