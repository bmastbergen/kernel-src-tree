i40e: refactor flow director

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit cbf613252496ed00f8669328bbd94296a03bcc79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/cbf61325.failed

The i40e hardware was generating some inconsistent results
when using current programming methods.  This refactor
fixes the inconsistencies that were preventing clean
unloads of the driver, and moves the queues for handling
flow director errors into their own hardware VSI.

This patch also implements a corrected version of the
basic ethtool add ntuple rule, which will disable
the driver's automatic flow programming.  A future patch
adds remove/replay/list support for ntuple.

	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Kavindya Deegala <kavindya.s.deegala@intel.com>
	Signed-off-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cbf613252496ed00f8669328bbd94296a03bcc79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 20705fef15bc,0dd578f5d803..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -4691,23 -4814,25 +4765,35 @@@ static void i40e_fdir_sb_setup(struct i
  	bool new_vsi = false;
  	int err, i;
  
++<<<<<<< HEAD
 +	if (!(pf->flags & (I40E_FLAG_FDIR_ENABLED |
 +			   I40E_FLAG_FDIR_ATR_ENABLED)))
++=======
+ 	if (!(pf->flags & I40E_FLAG_FD_SB_ENABLED))
++>>>>>>> cbf613252496 (i40e: refactor flow director)
  		return;
  
- 	pf->atr_sample_rate = I40E_DEFAULT_ATR_SAMPLE_RATE;
- 
- 	/* find existing or make new FDIR VSI */
+ 	/* find existing VSI and see if it needs configuring */
  	vsi = NULL;
- 	for (i = 0; i < pf->hw.func_caps.num_vsis; i++)
- 		if (pf->vsi[i] && pf->vsi[i]->type == I40E_VSI_FDIR)
+ 	for (i = 0; i < pf->hw.func_caps.num_vsis; i++) {
+ 		if (pf->vsi[i] && pf->vsi[i]->type == I40E_VSI_FDIR) {
  			vsi = pf->vsi[i];
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* create a new VSI if none exists */
  	if (!vsi) {
- 		vsi = i40e_vsi_setup(pf, I40E_VSI_FDIR, pf->mac_seid, 0);
+ 		vsi = i40e_vsi_setup(pf, I40E_VSI_FDIR,
+ 				     pf->vsi[pf->lan_vsi]->seid, 0);
  		if (!vsi) {
  			dev_info(&pf->pdev->dev, "Couldn't create FDir VSI\n");
++<<<<<<< HEAD
 +			pf->flags &= ~I40E_FLAG_FDIR_ENABLED;
 +			return;
++=======
+ 			goto err_vsi;
++>>>>>>> cbf613252496 (i40e: refactor flow director)
  		}
  		new_vsi = true;
  	}
@@@ -5778,21 -5976,25 +5884,36 @@@ static int i40e_sw_init(struct i40e_pf 
  	else
  		pf->num_tc_qps = 0;
  
++<<<<<<< HEAD
 +	if (pf->hw.func_caps.fd) {
 +		/* FW/NVM is not yet fixed in this regard */
 +		if ((pf->hw.func_caps.fd_filters_guaranteed > 0) ||
 +		    (pf->hw.func_caps.fd_filters_best_effort > 0)) {
 +			pf->flags |= I40E_FLAG_FDIR_ATR_ENABLED;
 +			dev_info(&pf->pdev->dev,
 +				 "Flow Director ATR mode Enabled\n");
 +			pf->flags |= I40E_FLAG_FDIR_ENABLED;
++=======
+ 	/* FW/NVM is not yet fixed in this regard */
+ 	if ((pf->hw.func_caps.fd_filters_guaranteed > 0) ||
+ 	    (pf->hw.func_caps.fd_filters_best_effort > 0)) {
+ 		pf->flags |= I40E_FLAG_FD_ATR_ENABLED;
+ 		pf->atr_sample_rate = I40E_DEFAULT_ATR_SAMPLE_RATE;
+ 		dev_info(&pf->pdev->dev,
+ 			"Flow Director ATR mode Enabled\n");
+ 		if (!(pf->flags & I40E_FLAG_MFP_ENABLED)) {
+ 			pf->flags |= I40E_FLAG_FD_SB_ENABLED;
++>>>>>>> cbf613252496 (i40e: refactor flow director)
  			dev_info(&pf->pdev->dev,
  				 "Flow Director Side Band mode Enabled\n");
- 			pf->fdir_pf_filter_count =
- 					 pf->hw.func_caps.fd_filters_guaranteed;
+ 		} else {
+ 			dev_info(&pf->pdev->dev,
+ 				 "Flow Director Side Band mode Disabled in MFP mode\n");
  		}
- 	} else {
- 		pf->fdir_pf_filter_count = 0;
+ 		pf->fdir_pf_filter_count =
+ 				 pf->hw.func_caps.fd_filters_guaranteed;
+ 		pf->hw.fdir_shared_filter_count =
+ 				 pf->hw.func_caps.fd_filters_best_effort;
  	}
  
  	if (pf->hw.func_caps.vmdq) {
@@@ -6957,14 -7327,8 +7077,8 @@@ static int i40e_setup_pf_switch(struct 
  	}
  	i40e_pf_reset_stats(pf);
  
- 	/* fdir VSI must happen first to be sure it gets queue 0, but only
- 	 * if there is enough room for the fdir VSI
- 	 */
- 	if (pf->num_lan_qps > 1)
- 		i40e_fdir_setup(pf);
- 
  	/* first time setup */
 -	if (pf->lan_vsi == I40E_NO_VSI || reinit) {
 +	if (pf->lan_vsi == I40E_NO_VSI) {
  		struct i40e_vsi *vsi = NULL;
  		u16 uplink_seid;
  
@@@ -7106,93 -7458,39 +7204,123 @@@ static void i40e_determine_queue_usage(
  	 */
  	queues_left = pf->hw.func_caps.num_tx_qp;
  
++<<<<<<< HEAD
 +	if   (!((pf->flags & I40E_FLAG_MSIX_ENABLED)		 &&
 +		(pf->flags & I40E_FLAG_MQ_ENABLED))		 ||
 +		!(pf->flags & (I40E_FLAG_RSS_ENABLED |
 +		I40E_FLAG_FDIR_ENABLED | I40E_FLAG_DCB_ENABLED)) ||
 +		(queues_left == 1)) {
 +
++=======
+ 	if ((queues_left == 1) ||
+ 	    !(pf->flags & I40E_FLAG_MSIX_ENABLED) ||
+ 	    !(pf->flags & (I40E_FLAG_RSS_ENABLED | I40E_FLAG_FD_SB_ENABLED |
+ 			   I40E_FLAG_DCB_ENABLED))) {
++>>>>>>> cbf613252496 (i40e: refactor flow director)
  		/* one qp for PF, no queues for anything else */
  		queues_left = 0;
  		pf->rss_size = pf->num_lan_qps = 1;
  
  		/* make sure all the fancies are disabled */
++<<<<<<< HEAD
 +		pf->flags &= ~(I40E_FLAG_RSS_ENABLED       |
 +				I40E_FLAG_MQ_ENABLED	   |
 +				I40E_FLAG_FDIR_ENABLED	   |
 +				I40E_FLAG_FDIR_ATR_ENABLED |
 +				I40E_FLAG_DCB_ENABLED	   |
 +				I40E_FLAG_SRIOV_ENABLED	   |
 +				I40E_FLAG_VMDQ_ENABLED);
 +
 +	} else if (pf->flags & I40E_FLAG_RSS_ENABLED	  &&
 +		   !(pf->flags & I40E_FLAG_FDIR_ENABLED)  &&
 +		   !(pf->flags & I40E_FLAG_DCB_ENABLED)) {
 +
 +		pf->rss_size = i40e_set_rss_size(pf, queues_left);
 +
 +		queues_left -= pf->rss_size;
 +		pf->num_lan_qps = pf->rss_size_max;
 +
 +	} else if (pf->flags & I40E_FLAG_RSS_ENABLED	  &&
 +		   !(pf->flags & I40E_FLAG_FDIR_ENABLED)  &&
 +		   (pf->flags & I40E_FLAG_DCB_ENABLED)) {
 +
 +		/* save num_tc_qps queues for TCs 1 thru 7 and the rest
 +		 * are set up for RSS in TC0
 +		 */
 +		queues_left -= accum_tc_size;
 +
 +		pf->rss_size = i40e_set_rss_size(pf, queues_left);
 +
 +		queues_left -= pf->rss_size;
 +		if (queues_left < 0) {
 +			dev_info(&pf->pdev->dev, "not enough queues for DCB\n");
 +			return;
 +		}
 +
 +		pf->num_lan_qps = pf->rss_size_max + accum_tc_size;
 +
 +	} else if (pf->flags & I40E_FLAG_RSS_ENABLED   &&
 +		  (pf->flags & I40E_FLAG_FDIR_ENABLED) &&
 +		  !(pf->flags & I40E_FLAG_DCB_ENABLED)) {
 +
 +		queues_left -= 1; /* save 1 queue for FD */
 +
 +		pf->rss_size = i40e_set_rss_size(pf, queues_left);
 +
 +		queues_left -= pf->rss_size;
 +		if (queues_left < 0) {
 +			dev_info(&pf->pdev->dev, "not enough queues for Flow Director\n");
 +			return;
 +		}
 +
 +		pf->num_lan_qps = pf->rss_size_max;
 +
 +	} else if (pf->flags & I40E_FLAG_RSS_ENABLED   &&
 +		  (pf->flags & I40E_FLAG_FDIR_ENABLED) &&
 +		  (pf->flags & I40E_FLAG_DCB_ENABLED)) {
 +
 +		/* save 1 queue for TCs 1 thru 7,
 +		 * 1 queue for flow director,
 +		 * and the rest are set up for RSS in TC0
 +		 */
 +		queues_left -= 1;
 +		queues_left -= accum_tc_size;
 +
 +		pf->rss_size = i40e_set_rss_size(pf, queues_left);
 +		queues_left -= pf->rss_size;
 +		if (queues_left < 0) {
 +			dev_info(&pf->pdev->dev, "not enough queues for DCB and Flow Director\n");
 +			return;
 +		}
 +
 +		pf->num_lan_qps = pf->rss_size_max + accum_tc_size;
 +
++=======
+ 		pf->flags &= ~(I40E_FLAG_RSS_ENABLED	|
+ 			       I40E_FLAG_FD_SB_ENABLED	|
+ 			       I40E_FLAG_FD_ATR_ENABLED	|
+ 			       I40E_FLAG_DCB_ENABLED	|
+ 			       I40E_FLAG_SRIOV_ENABLED	|
+ 			       I40E_FLAG_VMDQ_ENABLED);
++>>>>>>> cbf613252496 (i40e: refactor flow director)
  	} else {
- 		dev_info(&pf->pdev->dev,
- 			 "Invalid configuration, flags=0x%08llx\n", pf->flags);
- 		return;
+ 		/* Not enough queues for all TCs */
+ 		if ((pf->flags & I40E_FLAG_DCB_ENABLED) &&
+ 		    (queues_left < I40E_MAX_TRAFFIC_CLASS)) {
+ 			pf->flags &= ~I40E_FLAG_DCB_ENABLED;
+ 			dev_info(&pf->pdev->dev, "not enough queues for DCB. DCB is disabled.\n");
+ 		}
+ 		pf->num_lan_qps = pf->rss_size_max;
+ 		queues_left -= pf->num_lan_qps;
+ 	}
+ 
+ 	if (pf->flags & I40E_FLAG_FD_SB_ENABLED) {
+ 		if (queues_left > 1) {
+ 			queues_left -= 1; /* save 1 queue for FD */
+ 		} else {
+ 			pf->flags &= ~I40E_FLAG_FD_SB_ENABLED;
+ 			dev_info(&pf->pdev->dev, "not enough queues for Flow Director. Flow Director feature is disabled\n");
+ 		}
  	}
  
  	if ((pf->flags & I40E_FLAG_SRIOV_ENABLED) &&
diff --git a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
index 913ba9e64f58..3d07aedf9d4f 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
@@ -1003,6 +1003,22 @@ static void i40e_dbg_dump_veb_all(struct i40e_pf *pf)
 	}
 }
 
+/**
+ * i40e_dbg_cmd_fd_ctrl - Enable/disable FD sideband/ATR
+ * @pf: the pf that would be altered
+ * @flag: flag that needs enabling or disabling
+ * @enable: Enable/disable FD SD/ATR
+ **/
+static void i40e_dbg_cmd_fd_ctrl(struct i40e_pf *pf, u64 flag, bool enable)
+{
+	if (enable)
+		pf->flags |= flag;
+	else
+		pf->flags &= ~flag;
+	dev_info(&pf->pdev->dev, "requesting a pf reset\n");
+	i40e_do_reset_safe(pf, (1 << __I40E_PF_RESET_REQUESTED));
+}
+
 #define I40E_MAX_DEBUG_OUT_BUFFER (4096*4)
 /**
  * i40e_dbg_command_write - write into command datum
@@ -1714,6 +1730,14 @@ static ssize_t i40e_dbg_command_write(struct file *filp,
 		fd_data.raw_packet = NULL;
 		kfree(asc_packet);
 		asc_packet = NULL;
+	} else if (strncmp(cmd_buf, "fd-atr off", 10) == 0) {
+		i40e_dbg_cmd_fd_ctrl(pf, I40E_FLAG_FD_ATR_ENABLED, false);
+	} else if (strncmp(cmd_buf, "fd-atr on", 9) == 0) {
+		i40e_dbg_cmd_fd_ctrl(pf, I40E_FLAG_FD_ATR_ENABLED, true);
+	} else if (strncmp(cmd_buf, "fd-sb off", 9) == 0) {
+		i40e_dbg_cmd_fd_ctrl(pf, I40E_FLAG_FD_SB_ENABLED, false);
+	} else if (strncmp(cmd_buf, "fd-sb on", 8) == 0) {
+		i40e_dbg_cmd_fd_ctrl(pf, I40E_FLAG_FD_SB_ENABLED, true);
 	} else if (strncmp(cmd_buf, "lldp", 4) == 0) {
 		if (strncmp(&cmd_buf[5], "stop", 4) == 0) {
 			int ret;
@@ -1900,6 +1924,10 @@ static ssize_t i40e_dbg_command_write(struct file *filp,
 		dev_info(&pf->pdev->dev, "  send indirect aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3> <buffer_len>\n");
 		dev_info(&pf->pdev->dev, "  add fd_filter <dest q_index> <flex_off> <pctype> <dest_vsi> <dest_ctl> <fd_status> <cnt_index> <fd_id> <packet_len> <packet>\n");
 		dev_info(&pf->pdev->dev, "  rem fd_filter <dest q_index> <flex_off> <pctype> <dest_vsi> <dest_ctl> <fd_status> <cnt_index> <fd_id> <packet_len> <packet>\n");
+		dev_info(&pf->pdev->dev, "  fd-atr off\n");
+		dev_info(&pf->pdev->dev, "  fd-atr on\n");
+		dev_info(&pf->pdev->dev, "  fd-sb off\n");
+		dev_info(&pf->pdev->dev, "  fd-sb on\n");
 		dev_info(&pf->pdev->dev, "  lldp start\n");
 		dev_info(&pf->pdev->dev, "  lldp stop\n");
 		dev_info(&pf->pdev->dev, "  lldp get local\n");
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 342a6e13ac8b..143a09d395b4 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -1104,6 +1104,7 @@ static int i40e_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd,
 		ret = i40e_get_rss_hash_opts(pf, cmd);
 		break;
 	case ETHTOOL_GRXCLSRLCNT:
+		cmd->rule_cnt = 10;
 		ret = 0;
 		break;
 	case ETHTOOL_GRXCLSRULE:
@@ -1338,6 +1339,13 @@ static int i40e_add_del_fdir_tcpv4(struct i40e_vsi *vsi,
 	ip->saddr = fsp->h_u.tcp_ip4_spec.ip4src;
 	tcp->source = fsp->h_u.tcp_ip4_spec.psrc;
 
+	if (add) {
+		if (pf->flags & I40E_FLAG_FD_ATR_ENABLED) {
+			dev_info(&pf->pdev->dev, "Forcing ATR off, sideband rules for TCP/IPv4 flow being applied\n");
+			pf->flags &= ~I40E_FLAG_FD_ATR_ENABLED;
+		}
+	}
+
 	fd_data->pctype = I40E_FILTER_PCTYPE_NONF_IPV4_TCP_SYN;
 	ret = i40e_program_fdir_filter(fd_data, pf, add);
 
@@ -1477,8 +1485,8 @@ static int i40e_add_del_fdir_ethtool(struct i40e_vsi *vsi,
 	fd_data.flex_off = 0;
 	fd_data.pctype = 0;
 	fd_data.dest_vsi = vsi->id;
-	fd_data.dest_ctl = 0;
-	fd_data.fd_status = 0;
+	fd_data.dest_ctl = I40E_FILTER_PROGRAM_DESC_DEST_DIRECT_PACKET_QINDEX;
+	fd_data.fd_status = I40E_FILTER_PROGRAM_DESC_FD_STATUS_FD_ID;
 	fd_data.cnt_index = 0;
 	fd_data.fd_id = 0;
 
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
