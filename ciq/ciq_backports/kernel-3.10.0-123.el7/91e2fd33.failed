net: avoid calling sched_clock when LLS is off

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] busy_poll: avoid calling sched_clock when LLS is off (Neil Horman) [958330]
Rebuild_FUZZ: 87.76%
commit-author Eliezer Tamir <eliezer.tamir@linux.intel.com>
commit 91e2fd337839319c7745e2cb84cfbf8cf1426a1a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/91e2fd33.failed

Change Low Latency Sockets code for select and poll so that
when LLS is disabled sched_clock() is never called.

Also, avoid sending POLL_LL to sockets if disabled.

	Reported-by: Andi Kleen <andi@firstfloor.org>
	Signed-off-by: Eliezer Tamir <eliezer.tamir@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 91e2fd337839319c7745e2cb84cfbf8cf1426a1a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/select.c
#	include/net/ll_poll.h
diff --cc fs/select.c
index 6b14dc7df3a4,36540754bad7..000000000000
--- a/fs/select.c
+++ b/fs/select.c
@@@ -402,6 -402,8 +402,11 @@@ int do_select(int n, fd_set_bits *fds, 
  	poll_table *wait;
  	int retval, i, timed_out = 0;
  	unsigned long slack = 0;
++<<<<<<< HEAD
++=======
+ 	unsigned int ll_flag = ll_get_flag();
+ 	u64 ll_time = ll_end_time();
++>>>>>>> 91e2fd337839 (net: avoid calling sched_clock when LLS is off)
  
  	rcu_read_lock();
  	retval = max_select_fd(n, fds);
@@@ -488,6 -497,10 +493,13 @@@
  			break;
  		}
  
++<<<<<<< HEAD
++=======
+ 		/* only if on, have sockets with POLL_LL and not out of time */
+ 		if (ll_flag && can_ll && can_poll_ll(ll_time))
+ 			continue;
+ 
++>>>>>>> 91e2fd337839 (net: avoid calling sched_clock when LLS is off)
  		/*
  		 * If this is the first loop and we have a timeout
  		 * given, then we convert to ktime_t and set the to
@@@ -752,6 -769,8 +764,11 @@@ static int do_poll(unsigned int nfds,  
  	ktime_t expire, *to = NULL;
  	int timed_out = 0, count = 0;
  	unsigned long slack = 0;
++<<<<<<< HEAD
++=======
+ 	unsigned int ll_flag = ll_get_flag();
+ 	u64 ll_time = ll_end_time();
++>>>>>>> 91e2fd337839 (net: avoid calling sched_clock when LLS is off)
  
  	/* Optimise the no-wait case */
  	if (end_time && !end_time->tv_sec && !end_time->tv_nsec) {
@@@ -797,6 -818,10 +814,13 @@@
  		if (count || timed_out)
  			break;
  
++<<<<<<< HEAD
++=======
+ 		/* only if on, have sockets with POLL_LL and not out of time */
+ 		if (ll_flag && can_ll && can_poll_ll(ll_time))
+ 			continue;
+ 
++>>>>>>> 91e2fd337839 (net: avoid calling sched_clock when LLS is off)
  		/*
  		 * If this is the first loop and we have a timeout
  		 * given, then we convert to ktime_t and set the to
* Unmerged path include/net/ll_poll.h
* Unmerged path fs/select.c
* Unmerged path include/net/ll_poll.h
