mei: me: do not load the driver if the FW doesn't support MEI interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [mei] me: do not load the driver if the FW doesn't support MEI interface (Prarit Bhargava) [1082789]
Rebuild_FUZZ: 96.35%
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 5e6533a6f52f1a8283b2f818f5828be99a417dd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/5e6533a6.failed

NM and SPS  FW types that may run on ME device on server platforms
do not have valid MEI/HECI interface and driver should not
be bound to it as this might lead to system hung.
In practice not all BIOSes effectively hide such devices from the
OS and in some cases it is not possible.

We determine FW type by examining Host FW status registers in order to
unbind the driver.
In this patch we are adding check for ME on Cougar Point, Lynx Point
Devices

	Cc: stable <stable@vger.kernel.org> # 3.10+
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Tested-by: Nikola Ciprich <nikola.ciprich@linuxbox.cz>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 5e6533a6f52f1a8283b2f818f5828be99a417dd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/hw-me-regs.h
diff --cc drivers/misc/mei/hw-me-regs.h
index 6a203b6e8346,cabc04383685..000000000000
--- a/drivers/misc/mei/hw-me-regs.h
+++ b/drivers/misc/mei/hw-me-regs.h
@@@ -109,8 -109,17 +109,19 @@@
  #define MEI_DEV_ID_PPT_2      0x1CBA  /* Panther Point */
  #define MEI_DEV_ID_PPT_3      0x1DBA  /* Panther Point */
  
 -#define MEI_DEV_ID_LPT_H      0x8C3A  /* Lynx Point H */
 -#define MEI_DEV_ID_LPT_W      0x8D3A  /* Lynx Point - Wellsburg */
 +#define MEI_DEV_ID_LPT        0x8C3A  /* Lynx Point */
  #define MEI_DEV_ID_LPT_LP     0x9C3A  /* Lynx Point LP */
++<<<<<<< HEAD
++=======
+ #define MEI_DEV_ID_LPT_HR     0x8CBA  /* Lynx Point H Refresh */
+ 
+ #define MEI_DEV_ID_WPT_LP     0x9CBA  /* Wildcat Point LP */
+ 
+ /* Host Firmware Status Registers in PCI Config Space */
+ #define PCI_CFG_HFS_1         0x40
+ #define PCI_CFG_HFS_2         0x48
+ 
++>>>>>>> 5e6533a6f52f (mei: me: do not load the driver if the FW doesn't support MEI interface)
  /*
   * MEI HW Section
   */
* Unmerged path drivers/misc/mei/hw-me-regs.h
diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c
index 0f268329bd3a..82bc9ecb5c87 100644
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@ -102,15 +102,31 @@ static bool mei_me_quirk_probe(struct pci_dev *pdev,
 				const struct pci_device_id *ent)
 {
 	u32 reg;
-	if (ent->device == MEI_DEV_ID_PBG_1) {
-		pci_read_config_dword(pdev, 0x48, &reg);
-		/* make sure that bit 9 is up and bit 10 is down */
-		if ((reg & 0x600) == 0x200) {
-			dev_info(&pdev->dev, "Device doesn't have valid ME Interface\n");
-			return false;
-		}
+	/* Cougar Point || Patsburg */
+	if (ent->device == MEI_DEV_ID_CPT_1 ||
+	    ent->device == MEI_DEV_ID_PBG_1) {
+		pci_read_config_dword(pdev, PCI_CFG_HFS_2, &reg);
+		/* make sure that bit 9 (NM) is up and bit 10 (DM) is down */
+		if ((reg & 0x600) == 0x200)
+			goto no_mei;
 	}
+
+	/* Lynx Point */
+	if (ent->device == MEI_DEV_ID_LPT_H  ||
+	    ent->device == MEI_DEV_ID_LPT_W  ||
+	    ent->device == MEI_DEV_ID_LPT_HR) {
+		/* Read ME FW Status check for SPS Firmware */
+		pci_read_config_dword(pdev, PCI_CFG_HFS_1, &reg);
+		/* if bits [19:16] = 15, running SPS Firmware */
+		if ((reg & 0xf0000) == 0xf0000)
+			goto no_mei;
+	}
+
 	return true;
+
+no_mei:
+	dev_info(&pdev->dev, "Device doesn't have valid ME Interface\n");
+	return false;
 }
 /**
  * mei_probe - Device Initialization Routine
