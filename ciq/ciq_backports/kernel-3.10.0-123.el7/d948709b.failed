xfs: remove usage of is_bad_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Ben Myers <bpm@sgi.com>
commit d948709b8e468510d8c855d1e4c9f1cb7b524880
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/d948709b.failed

XFS never calls mark_inode_bad or iget_failed, so it will never see a
bad inode.  Remove all checks for is_bad_inode because they are
unnecessary.

	Signed-off-by: Ben Myers <bpm@sgi.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>

(cherry picked from commit d948709b8e468510d8c855d1e4c9f1cb7b524880)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index da3cfa9c9058,5ac716b2df22..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -771,6 -1574,271 +771,274 @@@ out_bmap_cancel
  	goto out;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ xfs_release(
+ 	xfs_inode_t	*ip)
+ {
+ 	xfs_mount_t	*mp = ip->i_mount;
+ 	int		error;
+ 
+ 	if (!S_ISREG(ip->i_d.di_mode) || (ip->i_d.di_mode == 0))
+ 		return 0;
+ 
+ 	/* If this is a read-only mount, don't do this (would generate I/O) */
+ 	if (mp->m_flags & XFS_MOUNT_RDONLY)
+ 		return 0;
+ 
+ 	if (!XFS_FORCED_SHUTDOWN(mp)) {
+ 		int truncated;
+ 
+ 		/*
+ 		 * If we are using filestreams, and we have an unlinked
+ 		 * file that we are processing the last close on, then nothing
+ 		 * will be able to reopen and write to this file. Purge this
+ 		 * inode from the filestreams cache so that it doesn't delay
+ 		 * teardown of the inode.
+ 		 */
+ 		if ((ip->i_d.di_nlink == 0) && xfs_inode_is_filestream(ip))
+ 			xfs_filestream_deassociate(ip);
+ 
+ 		/*
+ 		 * If we previously truncated this file and removed old data
+ 		 * in the process, we want to initiate "early" writeout on
+ 		 * the last close.  This is an attempt to combat the notorious
+ 		 * NULL files problem which is particularly noticeable from a
+ 		 * truncate down, buffered (re-)write (delalloc), followed by
+ 		 * a crash.  What we are effectively doing here is
+ 		 * significantly reducing the time window where we'd otherwise
+ 		 * be exposed to that problem.
+ 		 */
+ 		truncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);
+ 		if (truncated) {
+ 			xfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);
+ 			if (VN_DIRTY(VFS_I(ip)) && ip->i_delayed_blks > 0) {
+ 				error = -filemap_flush(VFS_I(ip)->i_mapping);
+ 				if (error)
+ 					return error;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (ip->i_d.di_nlink == 0)
+ 		return 0;
+ 
+ 	if (xfs_can_free_eofblocks(ip, false)) {
+ 
+ 		/*
+ 		 * If we can't get the iolock just skip truncating the blocks
+ 		 * past EOF because we could deadlock with the mmap_sem
+ 		 * otherwise.  We'll get another chance to drop them once the
+ 		 * last reference to the inode is dropped, so we'll never leak
+ 		 * blocks permanently.
+ 		 *
+ 		 * Further, check if the inode is being opened, written and
+ 		 * closed frequently and we have delayed allocation blocks
+ 		 * outstanding (e.g. streaming writes from the NFS server),
+ 		 * truncating the blocks past EOF will cause fragmentation to
+ 		 * occur.
+ 		 *
+ 		 * In this case don't do the truncation, either, but we have to
+ 		 * be careful how we detect this case. Blocks beyond EOF show
+ 		 * up as i_delayed_blks even when the inode is clean, so we
+ 		 * need to truncate them away first before checking for a dirty
+ 		 * release. Hence on the first dirty close we will still remove
+ 		 * the speculative allocation, but after that we will leave it
+ 		 * in place.
+ 		 */
+ 		if (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))
+ 			return 0;
+ 
+ 		error = xfs_free_eofblocks(mp, ip, true);
+ 		if (error && error != EAGAIN)
+ 			return error;
+ 
+ 		/* delalloc blocks after truncation means it really is dirty */
+ 		if (ip->i_delayed_blks)
+ 			xfs_iflags_set(ip, XFS_IDIRTY_RELEASE);
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * xfs_inactive
+  *
+  * This is called when the vnode reference count for the vnode
+  * goes to zero.  If the file has been unlinked, then it must
+  * now be truncated.  Also, we clear all of the read-ahead state
+  * kept for the inode here since the file is now closed.
+  */
+ int
+ xfs_inactive(
+ 	xfs_inode_t	*ip)
+ {
+ 	xfs_bmap_free_t		free_list;
+ 	xfs_fsblock_t		first_block;
+ 	int			committed;
+ 	struct xfs_trans	*tp;
+ 	struct xfs_mount	*mp;
+ 	struct xfs_trans_res	*resp;
+ 	int			error;
+ 	int			truncate = 0;
+ 
+ 	/*
+ 	 * If the inode is already free, then there can be nothing
+ 	 * to clean up here.
+ 	 */
+ 	if (ip->i_d.di_mode == 0) {
+ 		ASSERT(ip->i_df.if_real_bytes == 0);
+ 		ASSERT(ip->i_df.if_broot_bytes == 0);
+ 		return VN_INACTIVE_CACHE;
+ 	}
+ 
+ 	mp = ip->i_mount;
+ 
+ 	error = 0;
+ 
+ 	/* If this is a read-only mount, don't do this (would generate I/O) */
+ 	if (mp->m_flags & XFS_MOUNT_RDONLY)
+ 		goto out;
+ 
+ 	if (ip->i_d.di_nlink != 0) {
+ 		/*
+ 		 * force is true because we are evicting an inode from the
+ 		 * cache. Post-eof blocks must be freed, lest we end up with
+ 		 * broken free space accounting.
+ 		 */
+ 		if (xfs_can_free_eofblocks(ip, true)) {
+ 			error = xfs_free_eofblocks(mp, ip, false);
+ 			if (error)
+ 				return VN_INACTIVE_CACHE;
+ 		}
+ 		goto out;
+ 	}
+ 
+ 	if (S_ISREG(ip->i_d.di_mode) &&
+ 	    (ip->i_d.di_size != 0 || XFS_ISIZE(ip) != 0 ||
+ 	     ip->i_d.di_nextents > 0 || ip->i_delayed_blks > 0))
+ 		truncate = 1;
+ 
+ 	error = xfs_qm_dqattach(ip, 0);
+ 	if (error)
+ 		return VN_INACTIVE_CACHE;
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);
+ 	resp = (truncate || S_ISLNK(ip->i_d.di_mode)) ?
+ 		&M_RES(mp)->tr_itruncate : &M_RES(mp)->tr_ifree;
+ 
+ 	error = xfs_trans_reserve(tp, resp, 0, 0);
+ 	if (error) {
+ 		ASSERT(XFS_FORCED_SHUTDOWN(mp));
+ 		xfs_trans_cancel(tp, 0);
+ 		return VN_INACTIVE_CACHE;
+ 	}
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, 0);
+ 
+ 	if (S_ISLNK(ip->i_d.di_mode)) {
+ 		error = xfs_inactive_symlink(ip, &tp);
+ 		if (error)
+ 			goto out_cancel;
+ 	} else if (truncate) {
+ 		ip->i_d.di_size = 0;
+ 		xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
+ 
+ 		error = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);
+ 		if (error)
+ 			goto out_cancel;
+ 
+ 		ASSERT(ip->i_d.di_nextents == 0);
+ 	}
+ 
+ 	/*
+ 	 * If there are attributes associated with the file then blow them away
+ 	 * now.  The code calls a routine that recursively deconstructs the
+ 	 * attribute fork.  We need to just commit the current transaction
+ 	 * because we can't use it for xfs_attr_inactive().
+ 	 */
+ 	if (ip->i_d.di_anextents > 0) {
+ 		ASSERT(ip->i_d.di_forkoff != 0);
+ 
+ 		error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 		if (error)
+ 			goto out_unlock;
+ 
+ 		xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ 
+ 		error = xfs_attr_inactive(ip);
+ 		if (error)
+ 			goto out;
+ 
+ 		tp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);
+ 		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ifree, 0, 0);
+ 		if (error) {
+ 			xfs_trans_cancel(tp, 0);
+ 			goto out;
+ 		}
+ 
+ 		xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 		xfs_trans_ijoin(tp, ip, 0);
+ 	}
+ 
+ 	if (ip->i_afp)
+ 		xfs_idestroy_fork(ip, XFS_ATTR_FORK);
+ 
+ 	ASSERT(ip->i_d.di_anextents == 0);
+ 
+ 	/*
+ 	 * Free the inode.
+ 	 */
+ 	xfs_bmap_init(&free_list, &first_block);
+ 	error = xfs_ifree(tp, ip, &free_list);
+ 	if (error) {
+ 		/*
+ 		 * If we fail to free the inode, shut down.  The cancel
+ 		 * might do that, we need to make sure.  Otherwise the
+ 		 * inode might be lost for a long time or forever.
+ 		 */
+ 		if (!XFS_FORCED_SHUTDOWN(mp)) {
+ 			xfs_notice(mp, "%s: xfs_ifree returned error %d",
+ 				__func__, error);
+ 			xfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);
+ 		}
+ 		xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
+ 	} else {
+ 		/*
+ 		 * Credit the quota account(s). The inode is gone.
+ 		 */
+ 		xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);
+ 
+ 		/*
+ 		 * Just ignore errors at this point.  There is nothing we can
+ 		 * do except to try to keep going. Make sure it's not a silent
+ 		 * error.
+ 		 */
+ 		error = xfs_bmap_finish(&tp,  &free_list, &committed);
+ 		if (error)
+ 			xfs_notice(mp, "%s: xfs_bmap_finish returned error %d",
+ 				__func__, error);
+ 		error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 		if (error)
+ 			xfs_notice(mp, "%s: xfs_trans_commit returned error %d",
+ 				__func__, error);
+ 	}
+ 
+ 	/*
+ 	 * Release the dquots held by inode, if any.
+ 	 */
+ 	xfs_qm_dqdetach(ip);
+ out_unlock:
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ out:
+ 	return VN_INACTIVE_CACHE;
+ out_cancel:
+ 	xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);
+ 	goto out_unlock;
+ }
+ 
++>>>>>>> d948709b8e46 (xfs: remove usage of is_bad_inode)
  /*
   * This is called when the inode's link count goes to 0.
   * We place the on-disk inode on a list in the AGI.  It
diff --git a/fs/xfs/xfs_icache.c b/fs/xfs/xfs_icache.c
index 5a3fffd694ac..35f9701a3b70 100644
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@ -500,11 +500,6 @@ xfs_inode_ag_walk_grab(
 	if (!igrab(inode))
 		return ENOENT;
 
-	if (is_bad_inode(inode)) {
-		IRELE(ip);
-		return ENOENT;
-	}
-
 	/* inode is valid */
 	return 0;
 
@@ -918,8 +913,6 @@ restart:
 		xfs_iflock(ip);
 	}
 
-	if (is_bad_inode(VFS_I(ip)))
-		goto reclaim;
 	if (XFS_FORCED_SHUTDOWN(ip->i_mount)) {
 		xfs_iunpin_wait(ip);
 		xfs_iflush_abort(ip, false);
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c
index ea70ee7165e3..67abb1b29f97 100644
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -947,10 +947,6 @@ xfs_fs_destroy_inode(
 
 	XFS_STATS_INC(vn_reclaim);
 
-	/* bad inode, get out here ASAP */
-	if (is_bad_inode(inode))
-		goto out_reclaim;
-
 	ASSERT(XFS_FORCED_SHUTDOWN(ip->i_mount) || ip->i_delayed_blks == 0);
 
 	/*
@@ -966,7 +962,6 @@ xfs_fs_destroy_inode(
 	 * this more efficiently than we can here, so simply let background
 	 * reclaim tear down all inodes.
 	 */
-out_reclaim:
 	xfs_inode_set_reclaim_tag(ip);
 }
 
@@ -1492,10 +1487,6 @@ xfs_fs_fill_super(
 		error = ENOENT;
 		goto out_unmount;
 	}
-	if (is_bad_inode(root)) {
-		error = EINVAL;
-		goto out_unmount;
-	}
 	sb->s_root = d_make_root(root);
 	if (!sb->s_root) {
 		error = ENOMEM;
