xfs: push down inactive transaction mgmt for truncate

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Brian Foster <bfoster@redhat.com>
commit f7be2d7f594cbc7a00902b5427332a1ad519a528
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/f7be2d7f.failed

Create the new xfs_inactive_truncate() function to handle the
truncate portion of xfs_inactive(). Push the locking and
transaction management into the new function.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit f7be2d7f594cbc7a00902b5427332a1ad519a528)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index da3cfa9c9058,7b86f643046b..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -771,6 -1574,291 +771,294 @@@ out_bmap_cancel
  	goto out;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ xfs_release(
+ 	xfs_inode_t	*ip)
+ {
+ 	xfs_mount_t	*mp = ip->i_mount;
+ 	int		error;
+ 
+ 	if (!S_ISREG(ip->i_d.di_mode) || (ip->i_d.di_mode == 0))
+ 		return 0;
+ 
+ 	/* If this is a read-only mount, don't do this (would generate I/O) */
+ 	if (mp->m_flags & XFS_MOUNT_RDONLY)
+ 		return 0;
+ 
+ 	if (!XFS_FORCED_SHUTDOWN(mp)) {
+ 		int truncated;
+ 
+ 		/*
+ 		 * If we are using filestreams, and we have an unlinked
+ 		 * file that we are processing the last close on, then nothing
+ 		 * will be able to reopen and write to this file. Purge this
+ 		 * inode from the filestreams cache so that it doesn't delay
+ 		 * teardown of the inode.
+ 		 */
+ 		if ((ip->i_d.di_nlink == 0) && xfs_inode_is_filestream(ip))
+ 			xfs_filestream_deassociate(ip);
+ 
+ 		/*
+ 		 * If we previously truncated this file and removed old data
+ 		 * in the process, we want to initiate "early" writeout on
+ 		 * the last close.  This is an attempt to combat the notorious
+ 		 * NULL files problem which is particularly noticeable from a
+ 		 * truncate down, buffered (re-)write (delalloc), followed by
+ 		 * a crash.  What we are effectively doing here is
+ 		 * significantly reducing the time window where we'd otherwise
+ 		 * be exposed to that problem.
+ 		 */
+ 		truncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);
+ 		if (truncated) {
+ 			xfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);
+ 			if (VN_DIRTY(VFS_I(ip)) && ip->i_delayed_blks > 0) {
+ 				error = -filemap_flush(VFS_I(ip)->i_mapping);
+ 				if (error)
+ 					return error;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (ip->i_d.di_nlink == 0)
+ 		return 0;
+ 
+ 	if (xfs_can_free_eofblocks(ip, false)) {
+ 
+ 		/*
+ 		 * If we can't get the iolock just skip truncating the blocks
+ 		 * past EOF because we could deadlock with the mmap_sem
+ 		 * otherwise.  We'll get another chance to drop them once the
+ 		 * last reference to the inode is dropped, so we'll never leak
+ 		 * blocks permanently.
+ 		 *
+ 		 * Further, check if the inode is being opened, written and
+ 		 * closed frequently and we have delayed allocation blocks
+ 		 * outstanding (e.g. streaming writes from the NFS server),
+ 		 * truncating the blocks past EOF will cause fragmentation to
+ 		 * occur.
+ 		 *
+ 		 * In this case don't do the truncation, either, but we have to
+ 		 * be careful how we detect this case. Blocks beyond EOF show
+ 		 * up as i_delayed_blks even when the inode is clean, so we
+ 		 * need to truncate them away first before checking for a dirty
+ 		 * release. Hence on the first dirty close we will still remove
+ 		 * the speculative allocation, but after that we will leave it
+ 		 * in place.
+ 		 */
+ 		if (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))
+ 			return 0;
+ 
+ 		error = xfs_free_eofblocks(mp, ip, true);
+ 		if (error && error != EAGAIN)
+ 			return error;
+ 
+ 		/* delalloc blocks after truncation means it really is dirty */
+ 		if (ip->i_delayed_blks)
+ 			xfs_iflags_set(ip, XFS_IDIRTY_RELEASE);
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * xfs_inactive_truncate
+  *
+  * Called to perform a truncate when an inode becomes unlinked.
+  */
+ STATIC int
+ xfs_inactive_truncate(
+ 	struct xfs_inode *ip)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_trans	*tp;
+ 	int			error;
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);
+ 	if (error) {
+ 		ASSERT(XFS_FORCED_SHUTDOWN(mp));
+ 		xfs_trans_cancel(tp, 0);
+ 		return error;
+ 	}
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, 0);
+ 
+ 	/*
+ 	 * Log the inode size first to prevent stale data exposure in the event
+ 	 * of a system crash before the truncate completes. See the related
+ 	 * comment in xfs_setattr_size() for details.
+ 	 */
+ 	ip->i_d.di_size = 0;
+ 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
+ 
+ 	error = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);
+ 	if (error)
+ 		goto error_trans_cancel;
+ 
+ 	ASSERT(ip->i_d.di_nextents == 0);
+ 
+ 	error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 	if (error)
+ 		goto error_unlock;
+ 
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ 	return 0;
+ 
+ error_trans_cancel:
+ 	xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);
+ error_unlock:
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ 	return error;
+ }
+ 
+ /*
+  * xfs_inactive
+  *
+  * This is called when the vnode reference count for the vnode
+  * goes to zero.  If the file has been unlinked, then it must
+  * now be truncated.  Also, we clear all of the read-ahead state
+  * kept for the inode here since the file is now closed.
+  */
+ int
+ xfs_inactive(
+ 	xfs_inode_t	*ip)
+ {
+ 	xfs_bmap_free_t		free_list;
+ 	xfs_fsblock_t		first_block;
+ 	int			committed;
+ 	struct xfs_trans	*tp;
+ 	struct xfs_mount	*mp;
+ 	int			error;
+ 	int			truncate = 0;
+ 
+ 	/*
+ 	 * If the inode is already free, then there can be nothing
+ 	 * to clean up here.
+ 	 */
+ 	if (ip->i_d.di_mode == 0) {
+ 		ASSERT(ip->i_df.if_real_bytes == 0);
+ 		ASSERT(ip->i_df.if_broot_bytes == 0);
+ 		return VN_INACTIVE_CACHE;
+ 	}
+ 
+ 	mp = ip->i_mount;
+ 
+ 	error = 0;
+ 
+ 	/* If this is a read-only mount, don't do this (would generate I/O) */
+ 	if (mp->m_flags & XFS_MOUNT_RDONLY)
+ 		goto out;
+ 
+ 	if (ip->i_d.di_nlink != 0) {
+ 		/*
+ 		 * force is true because we are evicting an inode from the
+ 		 * cache. Post-eof blocks must be freed, lest we end up with
+ 		 * broken free space accounting.
+ 		 */
+ 		if (xfs_can_free_eofblocks(ip, true)) {
+ 			error = xfs_free_eofblocks(mp, ip, false);
+ 			if (error)
+ 				return VN_INACTIVE_CACHE;
+ 		}
+ 		goto out;
+ 	}
+ 
+ 	if (S_ISREG(ip->i_d.di_mode) &&
+ 	    (ip->i_d.di_size != 0 || XFS_ISIZE(ip) != 0 ||
+ 	     ip->i_d.di_nextents > 0 || ip->i_delayed_blks > 0))
+ 		truncate = 1;
+ 
+ 	error = xfs_qm_dqattach(ip, 0);
+ 	if (error)
+ 		return VN_INACTIVE_CACHE;
+ 
+ 	if (S_ISLNK(ip->i_d.di_mode))
+ 		error = xfs_inactive_symlink(ip);
+ 	else if (truncate)
+ 		error = xfs_inactive_truncate(ip);
+ 	if (error)
+ 		goto out;
+ 
+ 	/*
+ 	 * If there are attributes associated with the file then blow them away
+ 	 * now.  The code calls a routine that recursively deconstructs the
+ 	 * attribute fork.  We need to just commit the current transaction
+ 	 * because we can't use it for xfs_attr_inactive().
+ 	 */
+ 	if (ip->i_d.di_anextents > 0) {
+ 		ASSERT(ip->i_d.di_forkoff != 0);
+ 
+ 		error = xfs_attr_inactive(ip);
+ 		if (error)
+ 			goto out;
+ 	}
+ 
+ 	if (ip->i_afp)
+ 		xfs_idestroy_fork(ip, XFS_ATTR_FORK);
+ 
+ 	ASSERT(ip->i_d.di_anextents == 0);
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ifree, 0, 0);
+ 	if (error) {
+ 		ASSERT(XFS_FORCED_SHUTDOWN(mp));
+ 		xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 		goto out;
+ 	}
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, 0);
+ 
+ 	/*
+ 	 * Free the inode.
+ 	 */
+ 	xfs_bmap_init(&free_list, &first_block);
+ 	error = xfs_ifree(tp, ip, &free_list);
+ 	if (error) {
+ 		/*
+ 		 * If we fail to free the inode, shut down.  The cancel
+ 		 * might do that, we need to make sure.  Otherwise the
+ 		 * inode might be lost for a long time or forever.
+ 		 */
+ 		if (!XFS_FORCED_SHUTDOWN(mp)) {
+ 			xfs_notice(mp, "%s: xfs_ifree returned error %d",
+ 				__func__, error);
+ 			xfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);
+ 		}
+ 		xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
+ 	} else {
+ 		/*
+ 		 * Credit the quota account(s). The inode is gone.
+ 		 */
+ 		xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);
+ 
+ 		/*
+ 		 * Just ignore errors at this point.  There is nothing we can
+ 		 * do except to try to keep going. Make sure it's not a silent
+ 		 * error.
+ 		 */
+ 		error = xfs_bmap_finish(&tp,  &free_list, &committed);
+ 		if (error)
+ 			xfs_notice(mp, "%s: xfs_bmap_finish returned error %d",
+ 				__func__, error);
+ 		error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 		if (error)
+ 			xfs_notice(mp, "%s: xfs_trans_commit returned error %d",
+ 				__func__, error);
+ 	}
+ 
+ 	/*
+ 	 * Release the dquots held by inode, if any.
+ 	 */
+ 	xfs_qm_dqdetach(ip);
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ out:
+ 	return VN_INACTIVE_CACHE;
+ }
+ 
++>>>>>>> f7be2d7f594c (xfs: push down inactive transaction mgmt for truncate)
  /*
   * This is called when the inode's link count goes to 0.
   * We place the on-disk inode on a list in the AGI.  It
* Unmerged path fs/xfs/xfs_inode.c
