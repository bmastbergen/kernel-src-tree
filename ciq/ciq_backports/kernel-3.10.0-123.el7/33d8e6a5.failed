bnx2x: Add AER support (missing bits)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Yuval Mintz <yuvalmin@broadcom.com>
commit 33d8e6a5f555b0d61cb3cb0e3c28e611c7408f4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/33d8e6a5.failed

This function adds several OS calls required to fully enable PCIe AER support -
pci_enable_pcie_error_reporting() and pci_cleanup_aer_uncorrect_error_status().

	Signed-off-by: Yuval Mintz <yuvalmin@broadcom.com>
	Signed-off-by: Ariel Elior <ariele@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 33d8e6a5f555b0d61cb3cb0e3c28e611c7408f4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
index f6399d9d451e,dad67905f4e2..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
@@@ -1391,6 -1545,8 +1391,11 @@@ struct bnx2x 
  #define IS_VF_FLAG			(1 << 22)
  #define INTERRUPTS_ENABLED_FLAG		(1 << 23)
  #define BC_SUPPORTS_RMMOD_CMD		(1 << 24)
++<<<<<<< HEAD
++=======
+ #define HAS_PHYS_PORT_ID		(1 << 25)
+ #define AER_ENABLED			(1 << 26)
++>>>>>>> 33d8e6a5f555 (bnx2x: Add AER support (missing bits))
  
  #define BP_NOMCP(bp)			((bp)->flags & NO_MCP_FLAG)
  
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
index 95e657eaf4e7..6a90993ff4e3 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -27,6 +27,7 @@
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
+#include <linux/aer.h>
 #include <linux/init.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -12203,6 +12204,14 @@ static int bnx2x_set_coherency_mask(struct bnx2x *bp)
 	return 0;
 }
 
+static void bnx2x_disable_pcie_error_reporting(struct bnx2x *bp)
+{
+	if (bp->flags & AER_ENABLED) {
+		pci_disable_pcie_error_reporting(bp->pdev);
+		bp->flags &= ~AER_ENABLED;
+	}
+}
+
 static int bnx2x_init_dev(struct bnx2x *bp, struct pci_dev *pdev,
 			  struct net_device *dev, unsigned long board_type)
 {
@@ -12309,6 +12318,14 @@ static int bnx2x_init_dev(struct bnx2x *bp, struct pci_dev *pdev,
 	/* clean indirect addresses */
 	pci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,
 			       PCICFG_VENDOR_ID_OFFSET);
+
+	/* AER (Advanced Error reporting) configuration */
+	rc = pci_enable_pcie_error_reporting(pdev);
+	if (!rc)
+		bp->flags |= AER_ENABLED;
+	else
+		BNX2X_DEV_INFO("Failed To configure PCIe AER [%d]\n", rc);
+
 	/*
 	 * Clean the following indirect addresses for all functions since it
 	 * is not used by the driver.
@@ -12916,6 +12933,8 @@ static int bnx2x_init_one(struct pci_dev *pdev,
 	return 0;
 
 init_one_exit:
+	bnx2x_disable_pcie_error_reporting(bp);
+
 	if (bp->regview)
 		iounmap(bp->regview);
 
@@ -12989,6 +13008,8 @@ static void __bnx2x_remove(struct pci_dev *pdev,
 		pci_set_power_state(pdev, PCI_D3hot);
 	}
 
+	bnx2x_disable_pcie_error_reporting(bp);
+
 	if (bp->regview)
 		iounmap(bp->regview);
 
@@ -13166,6 +13187,14 @@ static pci_ers_result_t bnx2x_io_slot_reset(struct pci_dev *pdev)
 
 	rtnl_unlock();
 
+	/* If AER, perform cleanup of the PCIe registers */
+	if (bp->flags & AER_ENABLED) {
+		if (pci_cleanup_aer_uncorrect_error_status(pdev))
+			BNX2X_ERR("pci_cleanup_aer_uncorrect_error_status failed\n");
+		else
+			DP(NETIF_MSG_HW, "pci_cleanup_aer_uncorrect_error_status succeeded\n");
+	}
+
 	return PCI_ERS_RESULT_RECOVERED;
 }
 
