blk-throttle: implement throtl_grp->has_rules[]

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Tejun Heo <tj@kernel.org>
commit 693e751e70843c29884cde326016e746fa16073a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/693e751e.failed

blk_throtl_bio() has a quick exit path for throtl_grps without limits
configured.  It looks at the bps and iops limits and if both are not
configured, the bio is issued immediately.  While this is correct in
the current flat hierarchy as each throtl_grp behaves completely
independently, it would become wrong in proper hierarchy mode.  A
group without any limits could still be limited by one of its
ancestors and bio's queued for such group should not bypass
blk-throtl.

As having a quick bypass mechanism is beneficial, this patch
reimplements the mechanism such that it's correct even with proper
hierarchy.  throtl_grp->has_rules[] is added.  These booleans are
updated for the whole subtree whenever a config is updated so that
has_rules[] of the whole subtree stays synchronized.  They're also
updated when a new throtl_grp comes online so that it can't escape the
limits of its ancestors.

As no throtl_grp has another throtl_grp as parent now, this patch
doesn't yet make any behavior differences.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Acked-by: Vivek Goyal <vgoyal@redhat.com>
(cherry picked from commit 693e751e70843c29884cde326016e746fa16073a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-throttle.c
diff --cc block/blk-throttle.c
index e65e45a33372,27f006bb363b..000000000000
--- a/block/blk-throttle.c
+++ b/block/blk-throttle.c
@@@ -950,7 -1327,9 +971,13 @@@ static int tg_set_conf(struct cgroup *c
  	struct blkcg *blkcg = cgroup_to_blkcg(cgrp);
  	struct blkg_conf_ctx ctx;
  	struct throtl_grp *tg;
++<<<<<<< HEAD
 +	struct throtl_data *td;
++=======
+ 	struct throtl_service_queue *sq;
+ 	struct blkcg_gq *blkg;
+ 	struct cgroup *pos_cgrp;
++>>>>>>> 693e751e7084 (blk-throttle: implement throtl_grp->has_rules[])
  	int ret;
  
  	ret = blkg_conf_prep(blkcg, &blkcg_policy_throtl, buf, &ctx);
@@@ -968,10 -1347,22 +995,21 @@@
  	else
  		*(unsigned int *)((void *)tg + cft->private) = ctx.v;
  
 -	throtl_log(&tg->service_queue,
 -		   "limit change rbps=%llu wbps=%llu riops=%u wiops=%u",
 -		   tg->bps[READ], tg->bps[WRITE],
 -		   tg->iops[READ], tg->iops[WRITE]);
 +	throtl_log_tg(tg, "limit change rbps=%llu wbps=%llu riops=%u wiops=%u",
 +		      tg->bps[READ], tg->bps[WRITE],
 +		      tg->iops[READ], tg->iops[WRITE]);
  
+ 	/*
+ 	 * Update has_rules[] flags for the updated tg's subtree.  A tg is
+ 	 * considered to have rules if either the tg itself or any of its
+ 	 * ancestors has rules.  This identifies groups without any
+ 	 * restrictions in the whole hierarchy and allows them to bypass
+ 	 * blk-throttle.
+ 	 */
+ 	tg_update_has_rules(tg);
+ 	blkg_for_each_descendant_pre(blkg, pos_cgrp, ctx.blkg)
+ 		tg_update_has_rules(blkg_to_tg(blkg));
+ 
  	/*
  	 * We're already holding queue_lock and know @tg is valid.  Let's
  	 * apply the new config directly.
* Unmerged path block/blk-throttle.c
