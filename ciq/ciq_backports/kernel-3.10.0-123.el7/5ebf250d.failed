s390: fix handling of runtime instrumentation psw bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [s390] fix handling of runtime instrumentation psw bit (Hendrik Brueckner) [1029884]
Rebuild_FUZZ: 94.00%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 5ebf250dabbae83ad875f0dda5a108503cf78f3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/5ebf250d.failed

Fix the following bugs:
- When returning from a signal the signal handler copies the saved psw mask
  from user space and uses parts of it. Especially it restores the RI bit
  unconditionally. If however the machine doesn't support RI, or RI is
  disabled for the task, the last lpswe instruction which returns to user
  space will generate a specification exception.
  To fix this check if the RI bit is allowed to be set and kill the task
  if not.
- In the compat mode signal handler code the RI bit of the psw mask gets
  propagated to the mask of the return psw: if user space enables RI in the
  signal handler, RI will also be enabled after the signal handler is
  finished.
  This is a different behaviour than with 64 bit tasks. So change this to
  match the 64 bit semantics, which restores the original RI bit value.
- Fix similar oddities within the ptrace code as well.

	Reviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 5ebf250dabbae83ad875f0dda5a108503cf78f3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/compat_signal.c
#	arch/s390/kernel/ptrace.c
#	arch/s390/kernel/signal.c
diff --cc arch/s390/kernel/compat_signal.c
index c439ac9ced09,8764c88a84fe..000000000000
--- a/arch/s390/kernel/compat_signal.c
+++ b/arch/s390/kernel/compat_signal.c
@@@ -153,24 -153,26 +153,31 @@@ int copy_siginfo_from_user32(siginfo_t 
  
  static int save_sigregs32(struct pt_regs *regs, _sigregs32 __user *sregs)
  {
 -	_sigregs32 user_sregs;
 -	int i;
 -
 +	_s390_regs_common32 regs32;
 +	int err, i;
 +
++<<<<<<< HEAD
 +	regs32.psw.mask = psw32_user_bits |
 +		((__u32)(regs->psw.mask >> 32) & PSW32_MASK_USER);
 +	regs32.psw.addr = (__u32) regs->psw.addr |
++=======
+ 	user_sregs.regs.psw.mask = (__u32)(regs->psw.mask >> 32);
+ 	user_sregs.regs.psw.mask &= PSW32_MASK_USER | PSW32_MASK_RI;
+ 	user_sregs.regs.psw.mask |= psw32_user_bits;
+ 	user_sregs.regs.psw.addr = (__u32) regs->psw.addr |
++>>>>>>> 5ebf250dabba (s390: fix handling of runtime instrumentation psw bit)
  		(__u32)(regs->psw.mask & PSW_MASK_BA);
  	for (i = 0; i < NUM_GPRS; i++)
 -		user_sregs.regs.gprs[i] = (__u32) regs->gprs[i];
 +		regs32.gprs[i] = (__u32) regs->gprs[i];
  	save_access_regs(current->thread.acrs);
 -	memcpy(&user_sregs.regs.acrs, current->thread.acrs,
 -	       sizeof(user_sregs.regs.acrs));
 -	save_fp_ctl(&current->thread.fp_regs.fpc);
 -	save_fp_regs(current->thread.fp_regs.fprs);
 -	memcpy(&user_sregs.fpregs, &current->thread.fp_regs,
 -	       sizeof(user_sregs.fpregs));
 -	if (__copy_to_user(sregs, &user_sregs, sizeof(_sigregs32)))
 -		return -EFAULT;
 -	return 0;
 +	memcpy(regs32.acrs, current->thread.acrs, sizeof(regs32.acrs));
 +	err = __copy_to_user(&sregs->regs, &regs32, sizeof(regs32));
 +	if (err)
 +		return err;
 +	save_fp_regs(&current->thread.fp_regs);
 +	/* s390_fp_regs and _s390_fp_regs32 are the same ! */
 +	return __copy_to_user(&sregs->fpregs, &current->thread.fp_regs,
 +			      sizeof(_s390_fp_regs32));
  }
  
  static int restore_sigregs32(struct pt_regs *regs,_sigregs32 __user *sregs)
@@@ -181,29 -183,36 +188,47 @@@
  	/* Alwys make any pending restarted system call return -EINTR */
  	current_thread_info()->restart_block.fn = do_no_restart_syscall;
  
++<<<<<<< HEAD
 +	err = __copy_from_user(&regs32, &sregs->regs, sizeof(regs32));
 +	if (err)
 +		return err;
 +	regs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |
 +		(__u64)(regs32.psw.mask & PSW32_MASK_USER) << 32 |
 +		(__u64)(regs32.psw.addr & PSW32_ADDR_AMODE);
++=======
+ 	if (__copy_from_user(&user_sregs, &sregs->regs, sizeof(user_sregs)))
+ 		return -EFAULT;
+ 
+ 	if (!is_ri_task(current) && (user_sregs.regs.psw.mask & PSW32_MASK_RI))
+ 		return -EINVAL;
+ 
+ 	/* Loading the floating-point-control word can fail. Do that first. */
+ 	if (restore_fp_ctl(&user_sregs.fpregs.fpc))
+ 		return -EINVAL;
+ 
+ 	/* Use regs->psw.mask instead of PSW_USER_BITS to preserve PER bit. */
+ 	regs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |
+ 		(__u64)(user_sregs.regs.psw.mask & PSW32_MASK_USER) << 32 |
+ 		(__u64)(user_sregs.regs.psw.mask & PSW32_MASK_RI) << 32 |
+ 		(__u64)(user_sregs.regs.psw.addr & PSW32_ADDR_AMODE);
++>>>>>>> 5ebf250dabba (s390: fix handling of runtime instrumentation psw bit)
  	/* Check for invalid user address space control. */
 -	if ((regs->psw.mask & PSW_MASK_ASC) == PSW_ASC_HOME)
 -		regs->psw.mask = PSW_ASC_PRIMARY |
 +	if ((regs->psw.mask & PSW_MASK_ASC) >= (psw_kernel_bits & PSW_MASK_ASC))
 +		regs->psw.mask = (psw_user_bits & PSW_MASK_ASC) |
  			(regs->psw.mask & ~PSW_MASK_ASC);
 -	regs->psw.addr = (__u64)(user_sregs.regs.psw.addr & PSW32_ADDR_INSN);
 +	regs->psw.addr = (__u64)(regs32.psw.addr & PSW32_ADDR_INSN);
  	for (i = 0; i < NUM_GPRS; i++)
 -		regs->gprs[i] = (__u64) user_sregs.regs.gprs[i];
 -	memcpy(&current->thread.acrs, &user_sregs.regs.acrs,
 -	       sizeof(current->thread.acrs));
 +		regs->gprs[i] = (__u64) regs32.gprs[i];
 +	memcpy(current->thread.acrs, regs32.acrs, sizeof(current->thread.acrs));
  	restore_access_regs(current->thread.acrs);
  
 -	memcpy(&current->thread.fp_regs, &user_sregs.fpregs,
 -	       sizeof(current->thread.fp_regs));
 +	err = __copy_from_user(&current->thread.fp_regs, &sregs->fpregs,
 +			       sizeof(_s390_fp_regs32));
 +	current->thread.fp_regs.fpc &= FPC_VALID_MASK;
 +	if (err)
 +		return err;
  
 -	restore_fp_regs(current->thread.fp_regs.fprs);
 +	restore_fp_regs(&current->thread.fp_regs);
  	clear_thread_flag(TIF_SYSCALL);	/* No longer in a system call */
  	return 0;
  }
diff --cc arch/s390/kernel/ptrace.c
index a314c57f4e94,1d1f9c30c5fa..000000000000
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@@ -190,9 -198,11 +190,15 @@@ static unsigned long __peek_user(struc
  		 * psw and gprs are stored on the stack
  		 */
  		tmp = *(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr);
- 		if (addr == (addr_t) &dummy->regs.psw.mask)
+ 		if (addr == (addr_t) &dummy->regs.psw.mask) {
  			/* Return a clean psw mask. */
++<<<<<<< HEAD
 +			tmp = psw_user_bits | (tmp & PSW_MASK_USER);
++=======
+ 			tmp &= PSW_MASK_USER | PSW_MASK_RI;
+ 			tmp |= PSW_USER_BITS;
+ 		}
++>>>>>>> 5ebf250dabba (s390: fix handling of runtime instrumentation psw bit)
  
  	} else if (addr < (addr_t) &dummy->regs.orig_gpr2) {
  		/*
@@@ -313,11 -322,15 +319,23 @@@ static int __poke_user(struct task_stru
  		/*
  		 * psw and gprs are stored on the stack
  		 */
++<<<<<<< HEAD
 +		if (addr == (addr_t) &dummy->regs.psw.mask &&
 +		    ((data & ~PSW_MASK_USER) != psw_user_bits ||
 +		     ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))))
 +			/* Invalid psw mask. */
 +			return -EINVAL;
++=======
+ 		if (addr == (addr_t) &dummy->regs.psw.mask) {
+ 			unsigned long mask = PSW_MASK_USER;
+ 
+ 			mask |= is_ri_task(child) ? PSW_MASK_RI : 0;
+ 			if ((data & ~mask) != PSW_USER_BITS)
+ 				return -EINVAL;
+ 			if ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))
+ 				return -EINVAL;
+ 		}
++>>>>>>> 5ebf250dabba (s390: fix handling of runtime instrumentation psw bit)
  		*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;
  
  	} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {
diff --cc arch/s390/kernel/signal.c
index c45becf82e01,fb535874a246..000000000000
--- a/arch/s390/kernel/signal.c
+++ b/arch/s390/kernel/signal.c
@@@ -57,8 -57,8 +57,13 @@@ static int save_sigregs(struct pt_regs 
  
  	/* Copy a 'clean' PSW mask to the user to avoid leaking
  	   information about whether PER is currently on.  */
++<<<<<<< HEAD
 +	user_sregs.regs.psw.mask = psw_user_bits |
 +		(regs->psw.mask & PSW_MASK_USER);
++=======
+ 	user_sregs.regs.psw.mask = PSW_USER_BITS |
+ 		(regs->psw.mask & (PSW_MASK_USER | PSW_MASK_RI));
++>>>>>>> 5ebf250dabba (s390: fix handling of runtime instrumentation psw bit)
  	user_sregs.regs.psw.addr = regs->psw.addr;
  	memcpy(&user_sregs.regs.gprs, &regs->gprs, sizeof(sregs->regs.gprs));
  	memcpy(&user_sregs.regs.acrs, current->thread.acrs,
@@@ -82,15 -83,22 +87,29 @@@ static int restore_sigregs(struct pt_re
  	/* Alwys make any pending restarted system call return -EINTR */
  	current_thread_info()->restart_block.fn = do_no_restart_syscall;
  
++<<<<<<< HEAD
 +	err = __copy_from_user(&user_sregs, sregs, sizeof(_sigregs));
 +	if (err)
 +		return err;
 +	/* Use regs->psw.mask instead of psw_user_bits to preserve PER bit. */
++=======
+ 	if (__copy_from_user(&user_sregs, sregs, sizeof(user_sregs)))
+ 		return -EFAULT;
+ 
+ 	if (!is_ri_task(current) && (user_sregs.regs.psw.mask & PSW_MASK_RI))
+ 		return -EINVAL;
+ 
+ 	/* Loading the floating-point-control word can fail. Do that first. */
+ 	if (restore_fp_ctl(&user_sregs.fpregs.fpc))
+ 		return -EINVAL;
+ 
+ 	/* Use regs->psw.mask instead of PSW_USER_BITS to preserve PER bit. */
++>>>>>>> 5ebf250dabba (s390: fix handling of runtime instrumentation psw bit)
  	regs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |
- 		(user_sregs.regs.psw.mask & PSW_MASK_USER);
+ 		(user_sregs.regs.psw.mask & (PSW_MASK_USER | PSW_MASK_RI));
  	/* Check for invalid user address space control. */
 -	if ((regs->psw.mask & PSW_MASK_ASC) == PSW_ASC_HOME)
 -		regs->psw.mask = PSW_ASC_PRIMARY |
 +	if ((regs->psw.mask & PSW_MASK_ASC) >= (psw_kernel_bits & PSW_MASK_ASC))
 +		regs->psw.mask = (psw_user_bits & PSW_MASK_ASC) |
  			(regs->psw.mask & ~PSW_MASK_ASC);
  	/* Check for invalid amode */
  	if (regs->psw.mask & PSW_MASK_EA)
diff --git a/arch/s390/include/asm/compat.h b/arch/s390/include/asm/compat.h
index c1e7c646727c..7604cabf02c0 100644
--- a/arch/s390/include/asm/compat.h
+++ b/arch/s390/include/asm/compat.h
@@ -22,6 +22,7 @@
 #define PSW32_MASK_ASC		0x0000C000UL
 #define PSW32_MASK_CC		0x00003000UL
 #define PSW32_MASK_PM		0x00000f00UL
+#define PSW32_MASK_RI		0x00000080UL
 
 #define PSW32_MASK_USER		0x0000FF00UL
 
diff --git a/arch/s390/include/asm/processor.h b/arch/s390/include/asm/processor.h
index 80eb061ece46..97bced77561a 100644
--- a/arch/s390/include/asm/processor.h
+++ b/arch/s390/include/asm/processor.h
@@ -168,6 +168,9 @@ unsigned long get_wchan(struct task_struct *p);
 #define KSTK_EIP(tsk)	(task_pt_regs(tsk)->psw.addr)
 #define KSTK_ESP(tsk)	(task_pt_regs(tsk)->gprs[15])
 
+/* Has task runtime instrumentation enabled ? */
+#define is_ri_task(tsk) (!!(tsk)->thread.ri_cb)
+
 static inline unsigned short stap(void)
 {
 	unsigned short cpu_address;
diff --git a/arch/s390/include/uapi/asm/ptrace.h b/arch/s390/include/uapi/asm/ptrace.h
index 3aa9f1ec5b29..c301fcbe6fff 100644
--- a/arch/s390/include/uapi/asm/ptrace.h
+++ b/arch/s390/include/uapi/asm/ptrace.h
@@ -263,7 +263,7 @@ typedef struct
 #define PSW_MASK_EA		0x0000000100000000UL
 #define PSW_MASK_BA		0x0000000080000000UL
 
-#define PSW_MASK_USER		0x0000FF8180000000UL
+#define PSW_MASK_USER		0x0000FF0180000000UL
 
 #define PSW_ADDR_AMODE		0x0000000000000000UL
 #define PSW_ADDR_INSN		0xFFFFFFFFFFFFFFFFUL
* Unmerged path arch/s390/kernel/compat_signal.c
* Unmerged path arch/s390/kernel/ptrace.c
* Unmerged path arch/s390/kernel/signal.c
