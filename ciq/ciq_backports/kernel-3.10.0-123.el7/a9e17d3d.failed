cifs: fix static checker warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Paulo Alcantara <pc@cjr.nz>
commit a9e17d3d74d14e5fd10d54f0a07e0fce4e5f80dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/a9e17d3d.failed

Remove unnecessary NULL check of oparam->cifs_sb when parsing symlink
error response as it's already set by all smb2_open_file() callers and
deferenced earlier.

This fixes below report:

  fs/cifs/smb2file.c:126 smb2_open_file()
  warn: variable dereferenced before check 'oparms->cifs_sb' (see line 112)

Link: https://lore.kernel.org/r/Y0kt42j2tdpYakRu@kili
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit a9e17d3d74d14e5fd10d54f0a07e0fce4e5f80dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2file.c
diff --cc fs/cifs/smb2file.c
index 5da1b55a2258,ffbd9a99fc12..000000000000
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@@ -64,50 -100,86 +64,78 @@@ smb2_open_file(const unsigned int xid, 
  {
  	int rc;
  	__le16 *smb2_path;
 -	__u8 smb2_oplock;
 -	struct cifs_open_info_data *data = buf;
 -	struct smb2_file_all_info file_info = {};
 -	struct smb2_file_all_info *smb2_data = data ? &file_info : NULL;
 -	struct kvec err_iov = {};
 -	int err_buftype = CIFS_NO_BUFFER;
 -	struct cifs_fid *fid = oparms->fid;
 -	struct network_resiliency_req nr_ioctl_req;
 +	struct smb2_file_all_info *smb2_data = NULL;
 +	__u8 smb2_oplock[17];
  
++<<<<<<< HEAD
 +	smb2_path = cifs_convert_path_to_utf16(path, cifs_sb);
 +	if (smb2_path == NULL) {
 +		rc = -ENOMEM;
 +		goto out;
++=======
+ 	smb2_path = cifs_convert_path_to_utf16(oparms->path, oparms->cifs_sb);
+ 	if (smb2_path == NULL)
+ 		return -ENOMEM;
+ 
+ 	oparms->desired_access |= FILE_READ_ATTRIBUTES;
+ 	smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;
+ 
+ 	rc = SMB2_open(xid, oparms, smb2_path, &smb2_oplock, smb2_data, NULL, &err_iov,
+ 		       &err_buftype);
+ 	if (rc && data) {
+ 		struct smb2_hdr *hdr = err_iov.iov_base;
+ 
+ 		if (unlikely(!err_iov.iov_base || err_buftype == CIFS_NO_BUFFER))
+ 			rc = -ENOMEM;
+ 		else if (hdr->Status == STATUS_STOPPED_ON_SYMLINK) {
+ 			rc = smb2_parse_symlink_response(oparms->cifs_sb, &err_iov,
+ 							 &data->symlink_target);
+ 			if (!rc) {
+ 				memset(smb2_data, 0, sizeof(*smb2_data));
+ 				oparms->create_options |= OPEN_REPARSE_POINT;
+ 				rc = SMB2_open(xid, oparms, smb2_path, &smb2_oplock, smb2_data,
+ 					       NULL, NULL, NULL);
+ 				oparms->create_options &= ~OPEN_REPARSE_POINT;
+ 			}
+ 		}
++>>>>>>> a9e17d3d74d1 (cifs: fix static checker warning)
  	}
  
 -	if (rc)
 +	smb2_data = kzalloc(sizeof(struct smb2_file_all_info) + MAX_NAME * 2,
 +			    GFP_KERNEL);
 +	if (smb2_data == NULL) {
 +		rc = -ENOMEM;
  		goto out;
 +	}
  
 -	if (oparms->tcon->use_resilient) {
 -		/* default timeout is 0, servers pick default (120 seconds) */
 -		nr_ioctl_req.Timeout =
 -			cpu_to_le32(oparms->tcon->handle_timeout);
 -		nr_ioctl_req.Reserved = 0;
 -		rc = SMB2_ioctl(xid, oparms->tcon, fid->persistent_fid,
 -			fid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY,
 -			(char *)&nr_ioctl_req, sizeof(nr_ioctl_req),
 -			CIFSMaxBufSize, NULL, NULL /* no return info */);
 -		if (rc == -EOPNOTSUPP) {
 -			cifs_dbg(VFS,
 -			     "resiliency not supported by server, disabling\n");
 -			oparms->tcon->use_resilient = false;
 -		} else if (rc)
 -			cifs_dbg(FYI, "error %d setting resiliency\n", rc);
 +	desired_access |= FILE_READ_ATTRIBUTES;
 +	*smb2_oplock = SMB2_OPLOCK_LEVEL_EXCLUSIVE;
  
 -		rc = 0;
 -	}
 +	if (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
 +		memcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);
 +
 +	rc = SMB2_open(xid, tcon, smb2_path, &fid->persistent_fid,
 +		       &fid->volatile_fid, desired_access, disposition,
 +		       0, 0, smb2_oplock, smb2_data);
 +	if (rc)
 +		goto out;
  
 -	if (smb2_data) {
 -		/* if open response does not have IndexNumber field - get it */
 -		if (smb2_data->IndexNumber == 0) {
 -			rc = SMB2_get_srv_num(xid, oparms->tcon,
 -				      fid->persistent_fid,
 +	if (buf) {
 +		/* open response does not have IndexNumber field - get it */
 +		rc = SMB2_get_srv_num(xid, tcon, fid->persistent_fid,
  				      fid->volatile_fid,
  				      &smb2_data->IndexNumber);
 -			if (rc) {
 -				/*
 -				 * let get_inode_info disable server inode
 -				 * numbers
 -				 */
 -				smb2_data->IndexNumber = 0;
 -				rc = 0;
 -			}
 +		if (rc) {
 +			/* let get_inode_info disable server inode numbers */
 +			smb2_data->IndexNumber = 0;
 +			rc = 0;
  		}
 -		memcpy(&data->fi, smb2_data, sizeof(data->fi));
 +		move_smb2_info_to_cifs(buf, smb2_data);
  	}
  
 -	*oplock = smb2_oplock;
 +	*oplock = *smb2_oplock;
  out:
 -	free_rsp_buf(err_buftype, err_iov.iov_base);
 +	kfree(smb2_data);
  	kfree(smb2_path);
  	return rc;
  }
* Unmerged path fs/cifs/smb2file.c
