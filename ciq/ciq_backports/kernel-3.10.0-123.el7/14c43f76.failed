NFS: Add label lifecycle management

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author David Quigley <dpquigl@davequigley.com>
commit 14c43f767818c42f91ec7ffa586ee975845f68c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/14c43f76.failed

This patch adds the lifecycle management for the security label structure
introduced in an earlier patch. The label is not used yet but allocations and
freeing of the structure is handled.

	Signed-off-by: Matthew N. Dodd <Matthew.Dodd@sparta.com>
	Signed-off-by: Miguel Rodel Felipe <Rodel_FM@dsi.a-star.edu.sg>
	Signed-off-by: Phua Eu Gene <PHUA_Eu_Gene@dsi.a-star.edu.sg>
	Signed-off-by: Khin Mi Mi Aung <Mi_Mi_AUNG@dsi.a-star.edu.sg>
	Signed-off-by: Steve Dickson <steved@redhat.com>
	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit 14c43f767818c42f91ec7ffa586ee975845f68c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/dir.c
#	fs/nfs/inode.c
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/dir.c
index c662ff6befd6,736b607ac8a8..000000000000
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@@ -1082,7 -1091,11 +1090,15 @@@ static int nfs_lookup_revalidate(struc
  	if (fhandle == NULL || fattr == NULL)
  		goto out_error;
  
++<<<<<<< HEAD
 +	error = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr);
++=======
+ 	label = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);
+ 	if (IS_ERR(label))
+ 		goto out_error;
+ 
+ 	error = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);
++>>>>>>> 14c43f767818 (NFS: Add label lifecycle management)
  	if (error)
  		goto out_bad;
  	if (nfs_compare_fh(NFS_FH(inode), fhandle))
diff --cc fs/nfs/inode.c
index a0314a74b8a7,12e8ad85ae50..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -843,7 -836,14 +843,18 @@@ __nfs_revalidate_inode(struct nfs_serve
  		goto out;
  
  	nfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);
++<<<<<<< HEAD
 +	status = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr);
++=======
+ 
+ 	label = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);
+ 	if (IS_ERR(label)) {
+ 		status = PTR_ERR(label);
+ 		goto out;
+ 	}
+ 
+ 	status = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);
++>>>>>>> 14c43f767818 (NFS: Add label lifecycle management)
  	if (status != 0) {
  		dfprintk(PAGECACHE, "nfs_revalidate_inode: (%s/%Ld) getattr failed, error=%d\n",
  			 inode->i_sb->s_id,
diff --cc fs/nfs/nfs4proc.c
index 158cbe44e4ee,e9488f5e1037..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -2059,10 -2048,9 +2078,14 @@@ static int _nfs4_do_open(struct inode *
  	if (dentry->d_inode != NULL)
  		opendata->state = nfs4_get_open_state(dentry->d_inode, sp);
  
 -	status = _nfs4_open_and_get_state(opendata, fmode, flags, &state);
 +	status = _nfs4_open_and_get_state(opendata, fmode, flags, ctx);
  	if (status != 0)
++<<<<<<< HEAD
 +		goto err_opendata_put;
 +	state = ctx->state;
++=======
+ 		goto err_free_label;
++>>>>>>> 14c43f767818 (NFS: Add label lifecycle management)
  
  	if ((opendata->o_arg.open_flags & O_EXCL) &&
  	    (opendata->o_arg.createmode != NFS4_CREATE_GUARDED)) {
@@@ -2083,9 -2072,14 +2106,13 @@@
  		kfree(opendata->f_attr.mdsthreshold);
  	opendata->f_attr.mdsthreshold = NULL;
  
+ 	nfs4_label_free(olabel);
+ 
  	nfs4_opendata_put(opendata);
  	nfs4_put_state_owner(sp);
 -	*res = state;
  	return 0;
+ err_free_label:
+ 	nfs4_label_free(olabel);
  err_opendata_put:
  	kfree(opendata->f_attr.mdsthreshold);
  	nfs4_opendata_put(opendata);
@@@ -2685,10 -2693,14 +2712,18 @@@ static int nfs4_proc_get_root(struct nf
  		return error;
  	}
  
++<<<<<<< HEAD
 +	error = nfs4_proc_getattr(server, mntfh, fattr);
++=======
+ 	label = nfs4_label_alloc(server, GFP_KERNEL);
+ 	if (IS_ERR(label))
+ 		return PTR_ERR(label);
+ 
+ 	error = nfs4_proc_getattr(server, mntfh, fattr, label);
++>>>>>>> 14c43f767818 (NFS: Add label lifecycle management)
  	if (error < 0) {
  		dprintk("nfs4_get_root: getattr error = %d\n", -error);
- 		return error;
+ 		goto err_free_label;
  	}
  
  	if (fattr->valid & NFS_ATTR_FATTR_FSID &&
@@@ -2823,9 -2842,15 +2862,19 @@@ nfs4_proc_setattr(struct dentry *dentry
  		}
  	}
  
++<<<<<<< HEAD
 +	status = nfs4_do_setattr(inode, cred, fattr, sattr, state);
++=======
+ 	label = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);
+ 	if (IS_ERR(label))
+ 		return PTR_ERR(label);
+ 
+ 	status = nfs4_do_setattr(inode, cred, fattr, sattr, state, NULL, label);
++>>>>>>> 14c43f767818 (NFS: Add label lifecycle management)
  	if (status == 0)
  		nfs_setattr_update_inode(inode, sattr);
+ 
+ 	nfs4_label_free(label);
  	return status;
  }
  
* Unmerged path fs/nfs/dir.c
* Unmerged path fs/nfs/inode.c
* Unmerged path fs/nfs/nfs4proc.c
