drm/nouveau/core: split lock into list+exec and enable refcount locks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [drm] nouveau: split lock into list+exec and enable refcount locks (Rob Clark) [1018414]
Rebuild_FUZZ: 93.02%
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 15689c3c819d1d659cff464f427f398758a683de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/15689c3c.failed

This fixes a reported locking inversion when interacting with the DRM
core's vblank routines.

	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>
	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 15689c3c819d1d659cff464f427f398758a683de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/core/core/event.c
diff --cc drivers/gpu/drm/nouveau/core/core/event.c
index 9393c37b71c9,3f3c76581a9e..000000000000
--- a/drivers/gpu/drm/nouveau/core/core/event.c
+++ b/drivers/gpu/drm/nouveau/core/core/event.c
@@@ -23,69 -23,114 +23,146 @@@
  #include <core/os.h>
  #include <core/event.h>
  
- static void
- nouveau_event_put_locked(struct nouveau_event *event, int index,
- 			 struct nouveau_eventh *handler)
- {
- 	if (__test_and_clear_bit(NVKM_EVENT_ENABLE, &handler->flags)) {
- 		if (!--event->index[index].refs) {
- 			if (event->disable)
- 				event->disable(event, index);
- 		}
- 		list_del(&handler->head);
- 	}
- }
- 
  void
 -nouveau_event_put(struct nouveau_eventh *handler)
 +nouveau_event_put(struct nouveau_event *event, int index,
 +		  struct nouveau_eventh *handler)
  {
 -	struct nouveau_event *event = handler->event;
  	unsigned long flags;
++<<<<<<< HEAD
 +
 +	if (index >= event->index_nr)
 +		return;
 +
 +	spin_lock_irqsave(&event->lock, flags);
 +	nouveau_event_put_locked(event, index, handler);
 +	spin_unlock_irqrestore(&event->lock, flags);
++=======
+ 	if (__test_and_clear_bit(NVKM_EVENT_ENABLE, &handler->flags)) {
+ 		spin_lock_irqsave(&event->refs_lock, flags);
+ 		if (!--event->index[handler->index].refs) {
+ 			if (event->disable)
+ 				event->disable(event, handler->index);
+ 		}
+ 		spin_unlock_irqrestore(&event->refs_lock, flags);
+ 	}
++>>>>>>> 15689c3c819d (drm/nouveau/core: split lock into list+exec and enable refcount locks)
  }
  
  void
 -nouveau_event_get(struct nouveau_eventh *handler)
 +nouveau_event_get(struct nouveau_event *event, int index,
 +		  struct nouveau_eventh *handler)
  {
 -	struct nouveau_event *event = handler->event;
  	unsigned long flags;
++<<<<<<< HEAD
 +
 +	if (index >= event->index_nr)
 +		return;
 +
 +	spin_lock_irqsave(&event->lock, flags);
 +	if (!__test_and_set_bit(NVKM_EVENT_ENABLE, &handler->flags)) {
 +		list_add(&handler->head, &event->index[index].list);
 +		if (!event->index[index].refs++) {
++=======
+ 	if (!__test_and_set_bit(NVKM_EVENT_ENABLE, &handler->flags)) {
+ 		spin_lock_irqsave(&event->refs_lock, flags);
+ 		if (!event->index[handler->index].refs++) {
++>>>>>>> 15689c3c819d (drm/nouveau/core: split lock into list+exec and enable refcount locks)
  			if (event->enable)
 -				event->enable(event, handler->index);
 +				event->enable(event, index);
  		}
+ 		spin_unlock_irqrestore(&event->refs_lock, flags);
  	}
- 	spin_unlock_irqrestore(&event->lock, flags);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ nouveau_event_fini(struct nouveau_eventh *handler)
+ {
+ 	struct nouveau_event *event = handler->event;
+ 	unsigned long flags;
+ 	nouveau_event_put(handler);
+ 	spin_lock_irqsave(&event->list_lock, flags);
+ 	list_del(&handler->head);
+ 	spin_unlock_irqrestore(&event->list_lock, flags);
+ }
+ 
+ static int
+ nouveau_event_init(struct nouveau_event *event, int index,
+ 		   int (*func)(void *, int), void *priv,
+ 		   struct nouveau_eventh *handler)
+ {
+ 	unsigned long flags;
+ 
+ 	if (index >= event->index_nr)
+ 		return -EINVAL;
+ 
+ 	handler->event = event;
+ 	handler->flags = 0;
+ 	handler->index = index;
+ 	handler->func = func;
+ 	handler->priv = priv;
+ 
+ 	spin_lock_irqsave(&event->list_lock, flags);
+ 	list_add_tail(&handler->head, &event->index[index].list);
+ 	spin_unlock_irqrestore(&event->list_lock, flags);
+ 	return 0;
+ }
+ 
+ int
+ nouveau_event_new(struct nouveau_event *event, int index,
+ 		  int (*func)(void *, int), void *priv,
+ 		  struct nouveau_eventh **phandler)
+ {
+ 	struct nouveau_eventh *handler;
+ 	int ret = -ENOMEM;
+ 
+ 	handler = *phandler = kmalloc(sizeof(*handler), GFP_KERNEL);
+ 	if (handler) {
+ 		ret = nouveau_event_init(event, index, func, priv, handler);
+ 		if (ret)
+ 			kfree(handler);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ void
+ nouveau_event_ref(struct nouveau_eventh *handler, struct nouveau_eventh **ref)
+ {
+ 	BUG_ON(handler != NULL);
+ 	if (*ref) {
+ 		nouveau_event_fini(*ref);
+ 		kfree(*ref);
+ 	}
+ 	*ref = handler;
+ }
+ 
++>>>>>>> 15689c3c819d (drm/nouveau/core: split lock into list+exec and enable refcount locks)
  void
  nouveau_event_trigger(struct nouveau_event *event, int index)
  {
- 	struct nouveau_eventh *handler, *temp;
+ 	struct nouveau_eventh *handler;
  	unsigned long flags;
  
- 	if (index >= event->index_nr)
+ 	if (WARN_ON(index >= event->index_nr))
  		return;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&event->lock, flags);
 +	list_for_each_entry_safe(handler, temp, &event->index[index].list, head) {
 +		if (handler->func(handler, index) == NVKM_EVENT_DROP) {
 +			nouveau_event_put_locked(event, index, handler);
 +		}
++=======
+ 	spin_lock_irqsave(&event->list_lock, flags);
+ 	list_for_each_entry(handler, &event->index[index].list, head) {
+ 		if (test_bit(NVKM_EVENT_ENABLE, &handler->flags) &&
+ 		    handler->func(handler->priv, index) == NVKM_EVENT_DROP)
+ 			nouveau_event_put(handler);
++>>>>>>> 15689c3c819d (drm/nouveau/core: split lock into list+exec and enable refcount locks)
  	}
- 	spin_unlock_irqrestore(&event->lock, flags);
+ 	spin_unlock_irqrestore(&event->list_lock, flags);
  }
  
  void
* Unmerged path drivers/gpu/drm/nouveau/core/core/event.c
diff --git a/drivers/gpu/drm/nouveau/core/include/core/event.h b/drivers/gpu/drm/nouveau/core/include/core/event.h
index cb2f632cb3a5..372975c01b45 100644
--- a/drivers/gpu/drm/nouveau/core/include/core/event.h
+++ b/drivers/gpu/drm/nouveau/core/include/core/event.h
@@ -16,7 +16,8 @@ struct nouveau_eventh {
 };
 
 struct nouveau_event {
-	spinlock_t lock;
+	spinlock_t list_lock;
+	spinlock_t refs_lock;
 
 	void *priv;
 	void (*enable)(struct nouveau_event *, int index);
