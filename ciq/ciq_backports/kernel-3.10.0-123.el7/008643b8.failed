KEYS: Add a 'trusted' flag and a 'trusted only' flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author David Howells <dhowells@redhat.com>
commit 008643b86c5f33c115c84ccdda1725cac3ad50ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/008643b8.failed

Add KEY_FLAG_TRUSTED to indicate that a key either comes from a trusted source
or had a cryptographic signature chain that led back to a trusted key the
kernel already possessed.

Add KEY_FLAGS_TRUSTED_ONLY to indicate that a keyring will only accept links to
keys marked with KEY_FLAGS_TRUSTED.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit 008643b86c5f33c115c84ccdda1725cac3ad50ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/system_keyring.c
#	security/keys/key.c
#	security/keys/keyring.c
diff --cc security/keys/key.c
index 7d716b82a61e,d331ea9ef380..000000000000
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@@ -828,7 -830,12 +831,16 @@@ key_ref_t key_create_or_update(key_ref_
  	}
  	index_key.desc_len = strlen(index_key.description);
  
++<<<<<<< HEAD
 +	ret = __key_link_begin(keyring, &index_key, &prealloc);
++=======
+ 	key_ref = ERR_PTR(-EPERM);
+ 	if (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))
+ 		goto error_free_prep;
+ 	flags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;
+ 
+ 	ret = __key_link_begin(keyring, &index_key, &edit);
++>>>>>>> 008643b86c5f (KEYS: Add a 'trusted' flag and a 'trusted only' flag)
  	if (ret < 0) {
  		key_ref = ERR_PTR(ret);
  		goto error_free_prep;
diff --cc security/keys/keyring.c
index eeef1a073db4,9b6f6e09b50c..000000000000
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@@ -1005,14 -1181,22 +1005,22 @@@ int key_link(struct key *keyring, struc
  	key_check(keyring);
  	key_check(key);
  
++<<<<<<< HEAD
 +	ret = __key_link_begin(keyring, &key->index_key, &prealloc);
++=======
+ 	if (test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags) &&
+ 	    !test_bit(KEY_FLAG_TRUSTED, &key->flags))
+ 		return -EPERM;
+ 
+ 	ret = __key_link_begin(keyring, &key->index_key, &edit);
++>>>>>>> 008643b86c5f (KEYS: Add a 'trusted' flag and a 'trusted only' flag)
  	if (ret == 0) {
 -		kdebug("begun {%d,%d}", keyring->serial, atomic_read(&keyring->usage));
  		ret = __key_link_check_live_key(keyring, key);
  		if (ret == 0)
 -			__key_link(key, &edit);
 -		__key_link_end(keyring, &key->index_key, edit);
 +			__key_link(keyring, key, &prealloc);
 +		__key_link_end(keyring, &key->index_key, prealloc);
  	}
  
 -	kleave(" = %d {%d,%d}", ret, keyring->serial, atomic_read(&keyring->usage));
  	return ret;
  }
  EXPORT_SYMBOL(key_link);
* Unmerged path kernel/system_keyring.c
diff --git a/include/linux/key-type.h b/include/linux/key-type.h
index f58737bcb050..a74c3a84dfdd 100644
--- a/include/linux/key-type.h
+++ b/include/linux/key-type.h
@@ -45,6 +45,7 @@ struct key_preparsed_payload {
 	const void	*data;		/* Raw data */
 	size_t		datalen;	/* Raw datalen */
 	size_t		quotalen;	/* Quota length for proposed payload */
+	bool		trusted;	/* True if key is trusted */
 };
 
 typedef int (*request_key_actor_t)(struct key_construction *key,
diff --git a/include/linux/key.h b/include/linux/key.h
index ef596c7af585..d85b4a121722 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -167,6 +167,8 @@ struct key {
 #define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
 #define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
 #define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
+#define KEY_FLAG_TRUSTED	8	/* set if key is trusted */
+#define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
@@ -214,6 +216,7 @@ extern struct key *key_alloc(struct key_type *type,
 #define KEY_ALLOC_IN_QUOTA	0x0000	/* add to quota, reject if would overrun */
 #define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
+#define KEY_ALLOC_TRUSTED	0x0004	/* Key should be flagged as trusted */
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
* Unmerged path kernel/system_keyring.c
* Unmerged path security/keys/key.c
* Unmerged path security/keys/keyring.c
