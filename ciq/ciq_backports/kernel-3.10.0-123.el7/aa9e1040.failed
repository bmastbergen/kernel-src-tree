xfs: = vs == typo in ASSERT()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit aa9e10409eae9dd61a336c6307d0a0b538063970
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/aa9e1040.failed

There is a '=' vs '==' typo so the ASSERT()s are always true.

	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Eric Sandeen <sandeen@redhat.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit aa9e10409eae9dd61a336c6307d0a0b538063970)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_btree.c
diff --cc fs/xfs/xfs_bmap_btree.c
index cf3bc76710c3,bb8de8e399c4..000000000000
--- a/fs/xfs/xfs_bmap_btree.c
+++ b/fs/xfs/xfs_bmap_btree.c
@@@ -925,3 -925,47 +925,50 @@@ xfs_bmdr_maxrecs
  		return blocklen / sizeof(xfs_bmdr_rec_t);
  	return blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Change the owner of a btree format fork fo the inode passed in. Change it to
+  * the owner of that is passed in so that we can change owners before or after
+  * we switch forks between inodes. The operation that the caller is doing will
+  * determine whether is needs to change owner before or after the switch.
+  *
+  * For demand paged transactional modification, the fork switch should be done
+  * after reading in all the blocks, modifying them and pinning them in the
+  * transaction. For modification when the buffers are already pinned in memory,
+  * the fork switch can be done before changing the owner as we won't need to
+  * validate the owner until the btree buffers are unpinned and writes can occur
+  * again.
+  *
+  * For recovery based ownership change, there is no transactional context and
+  * so a buffer list must be supplied so that we can record the buffers that we
+  * modified for the caller to issue IO on.
+  */
+ int
+ xfs_bmbt_change_owner(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	int			whichfork,
+ 	xfs_ino_t		new_owner,
+ 	struct list_head	*buffer_list)
+ {
+ 	struct xfs_btree_cur	*cur;
+ 	int			error;
+ 
+ 	ASSERT(tp || buffer_list);
+ 	ASSERT(!(tp && buffer_list));
+ 	if (whichfork == XFS_DATA_FORK)
+ 		ASSERT(ip->i_d.di_format == XFS_DINODE_FMT_BTREE);
+ 	else
+ 		ASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE);
+ 
+ 	cur = xfs_bmbt_init_cursor(ip->i_mount, tp, ip, whichfork);
+ 	if (!cur)
+ 		return ENOMEM;
+ 
+ 	error = xfs_btree_change_owner(cur, new_owner, buffer_list);
+ 	xfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 	return error;
+ }
++>>>>>>> aa9e10409eae (xfs: = vs == typo in ASSERT())
* Unmerged path fs/xfs/xfs_bmap_btree.c
