be2net: do not call be_set/get_fw_log_level() on Skyhawk-R

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Vasundhara Volam <vasundhara.volam@emulex.com>
commit baaa08d148ac2d02567126e85213e82675ca55c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/baaa08d1.failed

Skyhawk-R FW does not support SET/GET_EXT_FAT_CAPABILITIES cmds via which
FW logging level can be controlled. Also, the hack used in BE3 to control
FW logging level via the ethtool interface is not needed in Skyhawk-R.

This patch also cleans up this code by moving be_set/get_fw_log_level()
routines to be_cmds.c where they belong.

	Signed-off-by: Vasundhara Volam <vasundhara.volam@emulex.com>

remove new line
	Signed-off-by: Sathya Perla <sathya.perla@emulex.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit baaa08d148ac2d02567126e85213e82675ca55c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be_cmds.h
diff --cc drivers/net/ethernet/emulex/benet/be_cmds.h
index b7bfef713606,39b99f2f7113..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_cmds.h
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.h
@@@ -1949,130 -1963,115 +1949,144 @@@ struct be_cmd_resp_get_iface_list 
  	struct be_if_desc if_desc;
  };
  
 -int be_pci_fnum_get(struct be_adapter *adapter);
 -int be_fw_wait_ready(struct be_adapter *adapter);
 -int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
 -			  bool permanent, u32 if_handle, u32 pmac_id);
 -int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr, u32 if_id,
 -		    u32 *pmac_id, u32 domain);
 -int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id, int pmac_id,
 -		    u32 domain);
 -int be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags, u32 en_flags,
 -		     u32 *if_handle, u32 domain);
 -int be_cmd_if_destroy(struct be_adapter *adapter, int if_handle, u32 domain);
 -int be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo);
 -int be_cmd_cq_create(struct be_adapter *adapter, struct be_queue_info *cq,
 -		     struct be_queue_info *eq, bool no_delay,
 -		     int num_cqe_dma_coalesce);
 -int be_cmd_mccq_create(struct be_adapter *adapter, struct be_queue_info *mccq,
 -		       struct be_queue_info *cq);
 -int be_cmd_txq_create(struct be_adapter *adapter, struct be_tx_obj *txo);
 -int be_cmd_rxq_create(struct be_adapter *adapter, struct be_queue_info *rxq,
 -		      u16 cq_id, u16 frag_size, u32 if_id, u32 rss, u8 *rss_id);
 -int be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,
 -		     int type);
 -int be_cmd_rxq_destroy(struct be_adapter *adapter, struct be_queue_info *q);
 -int be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,
 -			     u8 *link_status, u32 dom);
 -int be_cmd_reset(struct be_adapter *adapter);
 -int be_cmd_get_stats(struct be_adapter *adapter, struct be_dma_mem *nonemb_cmd);
 -int lancer_cmd_get_pport_stats(struct be_adapter *adapter,
 -			       struct be_dma_mem *nonemb_cmd);
 -int be_cmd_get_fw_ver(struct be_adapter *adapter, char *fw_ver,
 -		      char *fw_on_flash);
 -int be_cmd_modify_eqd(struct be_adapter *adapter, struct be_set_eqd *, int num);
 -int be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id, u16 *vtag_array,
 -		       u32 num, bool promiscuous);
 -int be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 status);
 -int be_cmd_set_flow_control(struct be_adapter *adapter, u32 tx_fc, u32 rx_fc);
 -int be_cmd_get_flow_control(struct be_adapter *adapter, u32 *tx_fc, u32 *rx_fc);
 -int be_cmd_query_fw_cfg(struct be_adapter *adapter, u32 *port_num,
 -			u32 *function_mode, u32 *function_caps, u16 *asic_rev);
 -int be_cmd_reset_function(struct be_adapter *adapter);
 -int be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,
 -		      u32 rss_hash_opts, u16 table_size);
 -int be_process_mcc(struct be_adapter *adapter);
 -int be_cmd_set_beacon_state(struct be_adapter *adapter, u8 port_num, u8 beacon,
 -			    u8 status, u8 state);
 -int be_cmd_get_beacon_state(struct be_adapter *adapter, u8 port_num,
 -			    u32 *state);
 -int be_cmd_write_flashrom(struct be_adapter *adapter, struct be_dma_mem *cmd,
 -			  u32 flash_oper, u32 flash_opcode, u32 buf_size);
 -int lancer_cmd_write_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
 -			    u32 data_size, u32 data_offset,
 -			    const char *obj_name, u32 *data_written,
 -			    u8 *change_status, u8 *addn_status);
 -int lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
 -			   u32 data_size, u32 data_offset, const char *obj_name,
 -			   u32 *data_read, u32 *eof, u8 *addn_status);
 -int be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,
 -			 int offset);
 -int be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,
 -			    struct be_dma_mem *nonemb_cmd);
 -int be_cmd_fw_init(struct be_adapter *adapter);
 -int be_cmd_fw_clean(struct be_adapter *adapter);
 -void be_async_mcc_enable(struct be_adapter *adapter);
 -void be_async_mcc_disable(struct be_adapter *adapter);
 -int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,
 -			 u32 loopback_type, u32 pkt_size, u32 num_pkts,
 -			 u64 pattern);
 -int be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern, u32 byte_cnt,
 -			struct be_dma_mem *cmd);
 -int be_cmd_get_seeprom_data(struct be_adapter *adapter,
 -			    struct be_dma_mem *nonemb_cmd);
 -int be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,
 -			u8 loopback_type, u8 enable);
 -int be_cmd_get_phy_info(struct be_adapter *adapter);
 -int be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain);
 -void be_detect_error(struct be_adapter *adapter);
 -int be_cmd_get_die_temperature(struct be_adapter *adapter);
 -int be_cmd_get_cntl_attributes(struct be_adapter *adapter);
 -int be_cmd_req_native_mode(struct be_adapter *adapter);
 -int be_cmd_get_reg_len(struct be_adapter *adapter, u32 *log_size);
 -void be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf);
 -int be_cmd_get_fn_privileges(struct be_adapter *adapter, u32 *privilege,
 -			     u32 domain);
 -int be_cmd_set_fn_privileges(struct be_adapter *adapter, u32 privileges,
 -			     u32 vf_num);
 -int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
 -			     bool *pmac_id_active, u32 *pmac_id, u8 domain);
 -int be_cmd_get_active_mac(struct be_adapter *adapter, u32 pmac_id, u8 *mac);
 -int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac);
 -int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array, u8 mac_count,
 +extern int be_pci_fnum_get(struct be_adapter *adapter);
 +extern int be_fw_wait_ready(struct be_adapter *adapter);
 +extern int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
 +				 bool permanent, u32 if_handle, u32 pmac_id);
 +extern int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,
 +			u32 if_id, u32 *pmac_id, u32 domain);
 +extern int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id,
 +			int pmac_id, u32 domain);
 +extern int be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags,
 +			    u32 en_flags, u32 *if_handle, u32 domain);
 +extern int be_cmd_if_destroy(struct be_adapter *adapter, int if_handle,
  			u32 domain);
++<<<<<<< HEAD
 +extern int be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo);
 +extern int be_cmd_cq_create(struct be_adapter *adapter,
 +			struct be_queue_info *cq, struct be_queue_info *eq,
 +			bool no_delay, int num_cqe_dma_coalesce);
 +extern int be_cmd_mccq_create(struct be_adapter *adapter,
 +			struct be_queue_info *mccq,
 +			struct be_queue_info *cq);
 +extern int be_cmd_txq_create(struct be_adapter *adapter,
 +			struct be_tx_obj *txo);
 +extern int be_cmd_rxq_create(struct be_adapter *adapter,
 +			struct be_queue_info *rxq, u16 cq_id,
 +			u16 frag_size, u32 if_id, u32 rss, u8 *rss_id);
 +extern int be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,
 +			int type);
 +extern int be_cmd_rxq_destroy(struct be_adapter *adapter,
 +			struct be_queue_info *q);
 +extern int be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,
 +				    u8 *link_status, u32 dom);
 +extern int be_cmd_reset(struct be_adapter *adapter);
 +extern int be_cmd_get_stats(struct be_adapter *adapter,
 +			struct be_dma_mem *nonemb_cmd);
 +extern int lancer_cmd_get_pport_stats(struct be_adapter *adapter,
 +			struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_get_fw_ver(struct be_adapter *adapter, char *fw_ver,
 +		char *fw_on_flash);
 +
 +extern int be_cmd_modify_eqd(struct be_adapter *adapter, u32 eq_id, u32 eqd);
 +extern int be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id,
 +			u16 *vtag_array, u32 num, bool untagged,
 +			bool promiscuous);
 +extern int be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 status);
 +extern int be_cmd_set_flow_control(struct be_adapter *adapter,
 +			u32 tx_fc, u32 rx_fc);
 +extern int be_cmd_get_flow_control(struct be_adapter *adapter,
 +			u32 *tx_fc, u32 *rx_fc);
 +extern int be_cmd_query_fw_cfg(struct be_adapter *adapter, u32 *port_num,
 +			u32 *function_mode, u32 *function_caps, u16 *asic_rev);
 +extern int be_cmd_reset_function(struct be_adapter *adapter);
 +extern int be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,
 +			     u32 rss_hash_opts, u16 table_size);
 +extern int be_process_mcc(struct be_adapter *adapter);
 +extern int be_cmd_set_beacon_state(struct be_adapter *adapter,
 +			u8 port_num, u8 beacon, u8 status, u8 state);
 +extern int be_cmd_get_beacon_state(struct be_adapter *adapter,
 +			u8 port_num, u32 *state);
 +extern int be_cmd_write_flashrom(struct be_adapter *adapter,
 +			struct be_dma_mem *cmd, u32 flash_oper,
 +			u32 flash_opcode, u32 buf_size);
 +extern int lancer_cmd_write_object(struct be_adapter *adapter,
++=======
+ int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id, u32 dom);
+ int be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid, u32 domain,
+ 			  u16 intf_id, u16 hsw_mode);
+ int be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid, u32 domain,
+ 			  u16 intf_id, u8 *mode);
+ int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter);
+ int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level);
+ int be_cmd_get_fw_log_level(struct be_adapter *adapter);
+ int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
+ 				   struct be_dma_mem *cmd);
+ int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,
++>>>>>>> baaa08d148ac (be2net: do not call be_set/get_fw_log_level() on Skyhawk-R)
  				   struct be_dma_mem *cmd,
 -				   struct be_fat_conf_params *cfgs);
 -int lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask);
 -int lancer_initiate_dump(struct be_adapter *adapter);
 -bool dump_present(struct be_adapter *adapter);
 -int lancer_test_and_set_rdy_state(struct be_adapter *adapter);
 -int be_cmd_query_port_name(struct be_adapter *adapter, u8 *port_name);
 +				   u32 data_size, u32 data_offset,
 +				   const char *obj_name,
 +				   u32 *data_written, u8 *change_status,
 +				   u8 *addn_status);
 +int lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
 +		u32 data_size, u32 data_offset, const char *obj_name,
 +		u32 *data_read, u32 *eof, u8 *addn_status);
 +int be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,
 +				int offset);
 +extern int be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,
 +				struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_fw_init(struct be_adapter *adapter);
 +extern int be_cmd_fw_clean(struct be_adapter *adapter);
 +extern void be_async_mcc_enable(struct be_adapter *adapter);
 +extern void be_async_mcc_disable(struct be_adapter *adapter);
 +extern int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,
 +				u32 loopback_type, u32 pkt_size,
 +				u32 num_pkts, u64 pattern);
 +extern int be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern,
 +			u32 byte_cnt, struct be_dma_mem *cmd);
 +extern int be_cmd_get_seeprom_data(struct be_adapter *adapter,
 +				struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,
 +				u8 loopback_type, u8 enable);
 +extern int be_cmd_get_phy_info(struct be_adapter *adapter);
 +extern int be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain);
 +extern void be_detect_error(struct be_adapter *adapter);
 +extern int be_cmd_get_die_temperature(struct be_adapter *adapter);
 +extern int be_cmd_get_cntl_attributes(struct be_adapter *adapter);
 +extern int be_cmd_req_native_mode(struct be_adapter *adapter);
 +extern int be_cmd_get_reg_len(struct be_adapter *adapter, u32 *log_size);
 +extern void be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf);
 +extern int be_cmd_get_fn_privileges(struct be_adapter *adapter,
 +				    u32 *privilege, u32 domain);
 +extern int be_cmd_set_fn_privileges(struct be_adapter *adapter,
 +				    u32 privileges, u32 vf_num);
 +extern int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
 +				    bool *pmac_id_active, u32 *pmac_id,
 +				    u8 domain);
 +extern int be_cmd_get_active_mac(struct be_adapter *adapter, u32 pmac_id,
 +				 u8 *mac);
 +extern int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac);
 +extern int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,
 +						u8 mac_count, u32 domain);
 +extern int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id,
 +			  u32 dom);
 +extern int be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid,
 +				 u32 domain, u16 intf_id, u16 hsw_mode);
 +extern int be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid,
 +				 u32 domain, u16 intf_id, u8 *mode);
 +extern int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter);
 +extern int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
 +					  struct be_dma_mem *cmd);
 +extern int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,
 +					  struct be_dma_mem *cmd,
 +					  struct be_fat_conf_params *cfgs);
 +extern int lancer_wait_ready(struct be_adapter *adapter);
 +extern int lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask);
 +extern int lancer_initiate_dump(struct be_adapter *adapter);
 +extern bool dump_present(struct be_adapter *adapter);
 +extern int lancer_test_and_set_rdy_state(struct be_adapter *adapter);
 +extern int be_cmd_query_port_name(struct be_adapter *adapter, u8 *port_name);
  int be_cmd_get_func_config(struct be_adapter *adapter,
  			   struct be_resources *res);
  int be_cmd_get_profile_config(struct be_adapter *adapter,
diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c
index 37416551ad4f..a0406f89d21d 100644
--- a/drivers/net/ethernet/emulex/benet/be_cmds.c
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c
@@ -3069,6 +3069,76 @@ err:
 	return status;
 
 }
+
+int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)
+{
+	struct be_dma_mem extfat_cmd;
+	struct be_fat_conf_params *cfgs;
+	int status;
+	int i, j;
+
+	memset(&extfat_cmd, 0, sizeof(struct be_dma_mem));
+	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
+	extfat_cmd.va = pci_alloc_consistent(adapter->pdev, extfat_cmd.size,
+					     &extfat_cmd.dma);
+	if (!extfat_cmd.va)
+		return -ENOMEM;
+
+	status = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);
+	if (status)
+		goto err;
+
+	cfgs = (struct be_fat_conf_params *)
+			(extfat_cmd.va + sizeof(struct be_cmd_resp_hdr));
+	for (i = 0; i < le32_to_cpu(cfgs->num_modules); i++) {
+		u32 num_modes = le32_to_cpu(cfgs->module[i].num_modes);
+		for (j = 0; j < num_modes; j++) {
+			if (cfgs->module[i].trace_lvl[j].mode == MODE_UART)
+				cfgs->module[i].trace_lvl[j].dbg_lvl =
+							cpu_to_le32(level);
+		}
+	}
+
+	status = be_cmd_set_ext_fat_capabilites(adapter, &extfat_cmd, cfgs);
+err:
+	pci_free_consistent(adapter->pdev, extfat_cmd.size, extfat_cmd.va,
+			    extfat_cmd.dma);
+	return status;
+}
+
+int be_cmd_get_fw_log_level(struct be_adapter *adapter)
+{
+	struct be_dma_mem extfat_cmd;
+	struct be_fat_conf_params *cfgs;
+	int status, j;
+	int level = 0;
+
+	memset(&extfat_cmd, 0, sizeof(struct be_dma_mem));
+	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
+	extfat_cmd.va = pci_alloc_consistent(adapter->pdev, extfat_cmd.size,
+					     &extfat_cmd.dma);
+
+	if (!extfat_cmd.va) {
+		dev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n",
+			__func__);
+		goto err;
+	}
+
+	status = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);
+	if (!status) {
+		cfgs = (struct be_fat_conf_params *)(extfat_cmd.va +
+						sizeof(struct be_cmd_resp_hdr));
+		for (j = 0; j < le32_to_cpu(cfgs->module[0].num_modes); j++) {
+			if (cfgs->module[0].trace_lvl[j].mode == MODE_UART)
+				level = cfgs->module[0].trace_lvl[j].dbg_lvl;
+		}
+	}
+	pci_free_consistent(adapter->pdev, extfat_cmd.size, extfat_cmd.va,
+			    extfat_cmd.dma);
+err:
+	return level;
+}
+
 int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
 				   struct be_dma_mem *cmd)
 {
* Unmerged path drivers/net/ethernet/emulex/benet/be_cmds.h
diff --git a/drivers/net/ethernet/emulex/benet/be_ethtool.c b/drivers/net/ethernet/emulex/benet/be_ethtool.c
index 5573355e2bb6..346808f65349 100644
--- a/drivers/net/ethernet/emulex/benet/be_ethtool.c
+++ b/drivers/net/ethernet/emulex/benet/be_ethtool.c
@@ -901,73 +901,21 @@ static u32 be_get_msg_level(struct net_device *netdev)
 {
 	struct be_adapter *adapter = netdev_priv(netdev);
 
-	if (lancer_chip(adapter)) {
-		dev_err(&adapter->pdev->dev, "Operation not supported\n");
-		return -EOPNOTSUPP;
-	}
-
 	return adapter->msg_enable;
 }
 
-static void be_set_fw_log_level(struct be_adapter *adapter, u32 level)
-{
-	struct be_dma_mem extfat_cmd;
-	struct be_fat_conf_params *cfgs;
-	int status;
-	int i, j;
-
-	memset(&extfat_cmd, 0, sizeof(struct be_dma_mem));
-	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
-	extfat_cmd.va = pci_alloc_consistent(adapter->pdev, extfat_cmd.size,
-					     &extfat_cmd.dma);
-	if (!extfat_cmd.va) {
-		dev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n",
-			__func__);
-		goto err;
-	}
-	status = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);
-	if (!status) {
-		cfgs = (struct be_fat_conf_params *)(extfat_cmd.va +
-					sizeof(struct be_cmd_resp_hdr));
-		for (i = 0; i < le32_to_cpu(cfgs->num_modules); i++) {
-			u32 num_modes = le32_to_cpu(cfgs->module[i].num_modes);
-			for (j = 0; j < num_modes; j++) {
-				if (cfgs->module[i].trace_lvl[j].mode ==
-								MODE_UART)
-					cfgs->module[i].trace_lvl[j].dbg_lvl =
-							cpu_to_le32(level);
-			}
-		}
-		status = be_cmd_set_ext_fat_capabilites(adapter, &extfat_cmd,
-							cfgs);
-		if (status)
-			dev_err(&adapter->pdev->dev,
-				"Message level set failed\n");
-	} else {
-		dev_err(&adapter->pdev->dev, "Message level get failed\n");
-	}
-
-	pci_free_consistent(adapter->pdev, extfat_cmd.size, extfat_cmd.va,
-			    extfat_cmd.dma);
-err:
-	return;
-}
-
 static void be_set_msg_level(struct net_device *netdev, u32 level)
 {
 	struct be_adapter *adapter = netdev_priv(netdev);
 
-	if (lancer_chip(adapter)) {
-		dev_err(&adapter->pdev->dev, "Operation not supported\n");
-		return;
-	}
-
 	if (adapter->msg_enable == level)
 		return;
 
 	if ((level & NETIF_MSG_HW) != (adapter->msg_enable & NETIF_MSG_HW))
-		be_set_fw_log_level(adapter, level & NETIF_MSG_HW ?
-				    FW_LOG_LEVEL_DEFAULT : FW_LOG_LEVEL_FATAL);
+		if (BEx_chip(adapter))
+			be_cmd_set_fw_log_level(adapter, level & NETIF_MSG_HW ?
+						FW_LOG_LEVEL_DEFAULT :
+						FW_LOG_LEVEL_FATAL);
 	adapter->msg_enable = level;
 
 	return;
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index eca2ad55d42f..7b05a93edb3c 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -4216,47 +4216,9 @@ bool be_is_wol_supported(struct be_adapter *adapter)
 		!be_is_wol_excluded(adapter)) ? true : false;
 }
 
-u32 be_get_fw_log_level(struct be_adapter *adapter)
-{
-	struct be_dma_mem extfat_cmd;
-	struct be_fat_conf_params *cfgs;
-	int status;
-	u32 level = 0;
-	int j;
-
-	if (lancer_chip(adapter))
-		return 0;
-
-	memset(&extfat_cmd, 0, sizeof(struct be_dma_mem));
-	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
-	extfat_cmd.va = pci_alloc_consistent(adapter->pdev, extfat_cmd.size,
-					     &extfat_cmd.dma);
-
-	if (!extfat_cmd.va) {
-		dev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n",
-			__func__);
-		goto err;
-	}
-
-	status = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);
-	if (!status) {
-		cfgs = (struct be_fat_conf_params *)(extfat_cmd.va +
-						sizeof(struct be_cmd_resp_hdr));
-		for (j = 0; j < le32_to_cpu(cfgs->module[0].num_modes); j++) {
-			if (cfgs->module[0].trace_lvl[j].mode == MODE_UART)
-				level = cfgs->module[0].trace_lvl[j].dbg_lvl;
-		}
-	}
-	pci_free_consistent(adapter->pdev, extfat_cmd.size, extfat_cmd.va,
-			    extfat_cmd.dma);
-err:
-	return level;
-}
-
 static int be_get_initial_config(struct be_adapter *adapter)
 {
-	int status;
-	u32 level;
+	int status, level;
 
 	status = be_cmd_get_cntl_attributes(adapter);
 	if (status)
@@ -4276,8 +4238,11 @@ static int be_get_initial_config(struct be_adapter *adapter)
 	/* Must be a power of 2 or else MODULO will BUG_ON */
 	adapter->be_get_temp_freq = 64;
 
-	level = be_get_fw_log_level(adapter);
-	adapter->msg_enable = level <= FW_LOG_LEVEL_DEFAULT ? NETIF_MSG_HW : 0;
+	if (BEx_chip(adapter)) {
+		level = be_cmd_get_fw_log_level(adapter);
+		adapter->msg_enable =
+			level <= FW_LOG_LEVEL_DEFAULT ? NETIF_MSG_HW : 0;
+	}
 
 	adapter->cfg_num_qs = netif_get_num_default_rss_queues();
 	return 0;
