ipv6 addrconf: don't cleanup prefix route for IFA_F_NOPREFIXROUTE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] ipv6: addrconf: don't cleanup prefix route for IFA_F_NOPREFIXROUTE (Jiri Pirko) [1052884]
Rebuild_FUZZ: 99.24%
commit-author Thomas Haller <thaller@redhat.com>
commit 5b84efecb7d939d06790b7bace5e513537d0767c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/5b84efec.failed

Refactor the deletion/update of prefix routes when removing an
address. Now also consider IFA_F_NOPREFIXROUTE and if there is an address
present with this flag, to not cleanup the route. Instead, assume
that userspace is taking care of this route.

Also perform the same cleanup, when userspace changes an existing address
to add NOPREFIXROUTE (to an address that didn't have this flag). This is
done because when the address was added, a prefix route was created for it.
Since the user now wants to handle this route by himself, we cleanup this
route.

This cleanup of the route is not totally robust. There is no guarantee,
that the route we are about to delete was really the one added by the
kernel. This behavior does not change by the patch, and in practice it
should work just fine.

	Signed-off-by: Thomas Haller <thaller@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5b84efecb7d939d06790b7bace5e513537d0767c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 157713521b56,6913a82f4669..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3676,6 -3654,8 +3695,11 @@@ static int inet6_addr_modify(struct ine
  	u32 flags;
  	clock_t expires;
  	unsigned long timeout;
++<<<<<<< HEAD
++=======
+ 	bool was_managetempaddr;
+ 	bool had_prefixroute;
++>>>>>>> 5b84efecb7d9 (ipv6 addrconf: don't cleanup prefix route for IFA_F_NOPREFIXROUTE)
  
  	if (!valid_lft || (prefered_lft > valid_lft))
  		return -EINVAL;
@@@ -3699,7 -3683,13 +3723,17 @@@
  	}
  
  	spin_lock_bh(&ifp->lock);
++<<<<<<< HEAD
 +	ifp->flags = (ifp->flags & ~(IFA_F_DEPRECATED | IFA_F_PERMANENT | IFA_F_NODAD | IFA_F_HOMEADDRESS)) | ifa_flags;
++=======
+ 	was_managetempaddr = ifp->flags & IFA_F_MANAGETEMPADDR;
+ 	had_prefixroute = ifp->flags & IFA_F_PERMANENT &&
+ 			  !(ifp->flags & IFA_F_NOPREFIXROUTE);
+ 	ifp->flags &= ~(IFA_F_DEPRECATED | IFA_F_PERMANENT | IFA_F_NODAD |
+ 			IFA_F_HOMEADDRESS | IFA_F_MANAGETEMPADDR |
+ 			IFA_F_NOPREFIXROUTE);
+ 	ifp->flags |= ifa_flags;
++>>>>>>> 5b84efecb7d9 (ipv6 addrconf: don't cleanup prefix route for IFA_F_NOPREFIXROUTE)
  	ifp->tstamp = jiffies;
  	ifp->valid_lft = valid_lft;
  	ifp->prefered_lft = prefered_lft;
@@@ -3708,8 -3698,30 +3742,35 @@@
  	if (!(ifp->flags&IFA_F_TENTATIVE))
  		ipv6_ifa_notify(0, ifp);
  
++<<<<<<< HEAD
 +	addrconf_prefix_route(&ifp->addr, ifp->prefix_len, ifp->idev->dev,
 +			      expires, flags);
++=======
+ 	if (!(ifa_flags & IFA_F_NOPREFIXROUTE)) {
+ 		addrconf_prefix_route(&ifp->addr, ifp->prefix_len, ifp->idev->dev,
+ 				      expires, flags);
+ 	} else if (had_prefixroute) {
+ 		enum cleanup_prefix_rt_t action;
+ 		unsigned long rt_expires;
+ 
+ 		write_lock_bh(&ifp->idev->lock);
+ 		action = check_cleanup_prefix_route(ifp, &rt_expires);
+ 		write_unlock_bh(&ifp->idev->lock);
+ 
+ 		if (action != CLEANUP_PREFIX_RT_NOP) {
+ 			cleanup_prefix_route(ifp, rt_expires,
+ 				action == CLEANUP_PREFIX_RT_DEL);
+ 		}
+ 	}
+ 
+ 	if (was_managetempaddr || ifp->flags & IFA_F_MANAGETEMPADDR) {
+ 		if (was_managetempaddr && !(ifp->flags & IFA_F_MANAGETEMPADDR))
+ 			valid_lft = prefered_lft = 0;
+ 		manage_tempaddrs(ifp->idev, ifp, valid_lft, prefered_lft,
+ 				 !was_managetempaddr, jiffies);
+ 	}
+ 
++>>>>>>> 5b84efecb7d9 (ipv6 addrconf: don't cleanup prefix route for IFA_F_NOPREFIXROUTE)
  	addrconf_verify(0);
  
  	return 0;
* Unmerged path net/ipv6/addrconf.c
