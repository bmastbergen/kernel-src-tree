xfs: vectorise encoding/decoding directory headers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 01ba43b873d9e91ba2e0341fe8cb7e89eaa41661
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/01ba43b8.failed

Conversion from on-disk structures to in-core header structures
currently relies on magic number checks. If the magic number is
wrong, but one of the supported values, we do the wrong thing with
the encode/decode operation. Split these functions so that there are
discrete operations for the specific directory format we are
handling.

In doing this, move all the header encode/decode functions to
xfs_da_format.c as they are directly manipulating the on-disk
format. It should be noted that all the growth in binary size is
from xfs_da_format.c - the rest of the code actaully shrinks.

   text    data     bss     dec     hex filename
 794490   96802    1096  892388   d9de4 fs/xfs/xfs.o.orig
 792986   96802    1096  890884   d9804 fs/xfs/xfs.o.p1
 792350   96802    1096  890248   d9588 fs/xfs/xfs.o.p2
 789293   96802    1096  887191   d8997 fs/xfs/xfs.o.p3
 789005   96802    1096  886903   d8997 fs/xfs/xfs.o.p4
 789061   96802    1096  886959   d88af fs/xfs/xfs.o.p5
 789733   96802    1096  887631   d8b4f fs/xfs/xfs.o.p6
 791421   96802    1096  889319   d91e7 fs/xfs/xfs.o.p7

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Ben Myers <bpm@sgi.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 01ba43b873d9e91ba2e0341fe8cb7e89eaa41661)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_attr_leaf.c
#	fs/xfs/xfs_attr_list.c
#	fs/xfs/xfs_da_btree.c
#	fs/xfs/xfs_da_format.c
#	fs/xfs/xfs_dir2.h
#	fs/xfs/xfs_dir2_block.c
#	fs/xfs/xfs_dir2_format.h
#	fs/xfs/xfs_dir2_leaf.c
#	fs/xfs/xfs_dir2_node.c
#	fs/xfs/xfs_dir2_priv.h
diff --cc fs/xfs/xfs_attr_leaf.c
index 86db20a9cc02,fdf9992dcbbc..000000000000
--- a/fs/xfs/xfs_attr_leaf.c
+++ b/fs/xfs/xfs_attr_leaf.c
@@@ -918,8 -916,8 +918,13 @@@ xfs_attr3_leaf_to_node
  	if (error)
  		goto out;
  	node = bp1->b_addr;
++<<<<<<< HEAD
 +	xfs_da3_node_hdr_from_disk(&icnodehdr, node);
 +	btree = xfs_da3_node_tree_p(node);
++=======
+ 	dp->d_ops->node_hdr_from_disk(&icnodehdr, node);
+ 	btree = dp->d_ops->node_tree_p(node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	leaf = bp2->b_addr;
  	xfs_attr3_leaf_hdr_from_disk(&icleafhdr, leaf);
diff --cc fs/xfs/xfs_attr_list.c
index cbc80d485177,2d174b128153..000000000000
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@@ -312,8 -311,8 +312,13 @@@ xfs_attr_node_list(xfs_attr_list_contex
  				return XFS_ERROR(EFSCORRUPTED);
  			}
  
++<<<<<<< HEAD
 +			xfs_da3_node_hdr_from_disk(&nodehdr, node);
 +			btree = xfs_da3_node_tree_p(node);
++=======
+ 			dp->d_ops->node_hdr_from_disk(&nodehdr, node);
+ 			btree = dp->d_ops->node_tree_p(node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  			for (i = 0; i < nodehdr.count; btree++, i++) {
  				if (cursor->hashval
  						<= be32_to_cpu(btree->hashval)) {
diff --cc fs/xfs/xfs_da_btree.c
index 6a2a7bb089e3,a51762dae543..000000000000
--- a/fs/xfs/xfs_da_btree.c
+++ b/fs/xfs/xfs_da_btree.c
@@@ -378,9 -331,10 +332,14 @@@ xfs_da3_node_create
  	}
  	ichdr.level = level;
  
- 	xfs_da3_node_hdr_to_disk(node, &ichdr);
+ 	dp->d_ops->node_hdr_to_disk(node, &ichdr);
  	xfs_trans_log_buf(tp, bp,
++<<<<<<< HEAD
 +		XFS_DA_LOGRANGE(node, &node->hdr, xfs_da3_node_hdr_size(node)));
++=======
+ 		XFS_DA_LOGRANGE(node, &node->hdr,
+ 				dp->d_ops->node_hdr_size()));
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	*bpp = bp;
  	return(0);
@@@ -590,8 -544,8 +549,13 @@@ xfs_da3_root_split
  	    oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC)) {
  		struct xfs_da3_icnode_hdr nodehdr;
  
++<<<<<<< HEAD
 +		xfs_da3_node_hdr_from_disk(&nodehdr, oldroot);
 +		btree = xfs_da3_node_tree_p(oldroot);
++=======
+ 		dp->d_ops->node_hdr_from_disk(&nodehdr, oldroot);
+ 		btree = dp->d_ops->node_tree_p(oldroot);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  		size = (int)((char *)&btree[nodehdr.count] - (char *)oldroot);
  		level = nodehdr.level;
  
@@@ -605,8 -559,8 +569,13 @@@
  		struct xfs_dir2_leaf_entry *ents;
  
  		leaf = (xfs_dir2_leaf_t *)oldroot;
++<<<<<<< HEAD
 +		xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +		ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 		dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 		ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  		ASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||
  		       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);
@@@ -650,8 -604,8 +619,13 @@@
  		return error;
  
  	node = bp->b_addr;
++<<<<<<< HEAD
 +	xfs_da3_node_hdr_from_disk(&nodehdr, node);
 +	btree = xfs_da3_node_tree_p(node);
++=======
+ 	dp->d_ops->node_hdr_from_disk(&nodehdr, node);
+ 	btree = dp->d_ops->node_tree_p(node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	btree[0].hashval = cpu_to_be32(blk1->hashval);
  	btree[0].before = cpu_to_be32(blk1->blkno);
  	btree[1].hashval = cpu_to_be32(blk2->hashval);
@@@ -799,10 -755,10 +774,17 @@@ xfs_da3_node_rebalance
  
  	node1 = blk1->bp->b_addr;
  	node2 = blk2->bp->b_addr;
++<<<<<<< HEAD
 +	xfs_da3_node_hdr_from_disk(&nodehdr1, node1);
 +	xfs_da3_node_hdr_from_disk(&nodehdr2, node2);
 +	btree1 = xfs_da3_node_tree_p(node1);
 +	btree2 = xfs_da3_node_tree_p(node2);
++=======
+ 	dp->d_ops->node_hdr_from_disk(&nodehdr1, node1);
+ 	dp->d_ops->node_hdr_from_disk(&nodehdr2, node2);
+ 	btree1 = dp->d_ops->node_tree_p(node1);
+ 	btree2 = dp->d_ops->node_tree_p(node2);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	/*
  	 * Figure out how many entries need to move, and in which direction.
@@@ -815,10 -771,10 +797,17 @@@
  		tmpnode = node1;
  		node1 = node2;
  		node2 = tmpnode;
++<<<<<<< HEAD
 +		xfs_da3_node_hdr_from_disk(&nodehdr1, node1);
 +		xfs_da3_node_hdr_from_disk(&nodehdr2, node2);
 +		btree1 = xfs_da3_node_tree_p(node1);
 +		btree2 = xfs_da3_node_tree_p(node2);
++=======
+ 		dp->d_ops->node_hdr_from_disk(&nodehdr1, node1);
+ 		dp->d_ops->node_hdr_from_disk(&nodehdr2, node2);
+ 		btree1 = dp->d_ops->node_tree_p(node1);
+ 		btree2 = dp->d_ops->node_tree_p(node2);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  		swap = 1;
  	}
  
@@@ -880,15 -836,15 +869,15 @@@
  	/*
  	 * Log header of node 1 and all current bits of node 2.
  	 */
- 	xfs_da3_node_hdr_to_disk(node1, &nodehdr1);
+ 	dp->d_ops->node_hdr_to_disk(node1, &nodehdr1);
  	xfs_trans_log_buf(tp, blk1->bp,
  		XFS_DA_LOGRANGE(node1, &node1->hdr,
 -				dp->d_ops->node_hdr_size()));
 +				xfs_da3_node_hdr_size(node1)));
  
- 	xfs_da3_node_hdr_to_disk(node2, &nodehdr2);
+ 	dp->d_ops->node_hdr_to_disk(node2, &nodehdr2);
  	xfs_trans_log_buf(tp, blk2->bp,
  		XFS_DA_LOGRANGE(node2, &node2->hdr,
 -				dp->d_ops->node_hdr_size() +
 +				xfs_da3_node_hdr_size(node2) +
  				(sizeof(btree2[0]) * nodehdr2.count)));
  
  	/*
@@@ -898,10 -854,10 +887,17 @@@
  	if (swap) {
  		node1 = blk1->bp->b_addr;
  		node2 = blk2->bp->b_addr;
++<<<<<<< HEAD
 +		xfs_da3_node_hdr_from_disk(&nodehdr1, node1);
 +		xfs_da3_node_hdr_from_disk(&nodehdr2, node2);
 +		btree1 = xfs_da3_node_tree_p(node1);
 +		btree2 = xfs_da3_node_tree_p(node2);
++=======
+ 		dp->d_ops->node_hdr_from_disk(&nodehdr1, node1);
+ 		dp->d_ops->node_hdr_from_disk(&nodehdr2, node2);
+ 		btree1 = dp->d_ops->node_tree_p(node1);
+ 		btree2 = dp->d_ops->node_tree_p(node2);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	}
  	blk1->hashval = be32_to_cpu(btree1[nodehdr1.count - 1].hashval);
  	blk2->hashval = be32_to_cpu(btree2[nodehdr2.count - 1].hashval);
@@@ -932,8 -889,8 +928,13 @@@ xfs_da3_node_add
  	trace_xfs_da_node_add(state->args);
  
  	node = oldblk->bp->b_addr;
++<<<<<<< HEAD
 +	xfs_da3_node_hdr_from_disk(&nodehdr, node);
 +	btree = xfs_da3_node_tree_p(node);
++=======
+ 	dp->d_ops->node_hdr_from_disk(&nodehdr, node);
+ 	btree = dp->d_ops->node_tree_p(node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	ASSERT(oldblk->index >= 0 && oldblk->index <= nodehdr.count);
  	ASSERT(newblk->blkno != 0);
@@@ -956,9 -913,9 +957,9 @@@
  				tmp + sizeof(*btree)));
  
  	nodehdr.count += 1;
- 	xfs_da3_node_hdr_to_disk(node, &nodehdr);
+ 	dp->d_ops->node_hdr_to_disk(node, &nodehdr);
  	xfs_trans_log_buf(state->args->trans, oldblk->bp,
 -		XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size()));
 +		XFS_DA_LOGRANGE(node, &node->hdr, xfs_da3_node_hdr_size(node)));
  
  	/*
  	 * Copy the last hash value from the oldblk to propagate upwards.
@@@ -1116,10 -1074,10 +1118,14 @@@ xfs_da3_root_join
  	 * Read in the (only) child block, then copy those bytes into
  	 * the root block's buffer and free the original child block.
  	 */
++<<<<<<< HEAD
 +	btree = xfs_da3_node_tree_p(oldroot);
++=======
+ 	btree = dp->d_ops->node_tree_p(oldroot);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	child = be32_to_cpu(btree[0].before);
  	ASSERT(child != 0);
- 	error = xfs_da3_node_read(args->trans, args->dp, child, -1, &bp,
+ 	error = xfs_da3_node_read(args->trans, dp, child, -1, &bp,
  					     args->whichfork);
  	if (error)
  		return error;
@@@ -1237,10 -1197,10 +1244,14 @@@ xfs_da3_node_toosmall
  			return(error);
  
  		node = bp->b_addr;
++<<<<<<< HEAD
 +		xfs_da3_node_hdr_from_disk(&nodehdr, node);
++=======
+ 		dp->d_ops->node_hdr_from_disk(&thdr, node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  		xfs_trans_brelse(state->args->trans, bp);
  
 -		if (count - thdr.count >= 0)
 +		if (count - nodehdr.count >= 0)
  			break;	/* fits with at least 25% to spare */
  	}
  	if (i >= 2) {
@@@ -1333,8 -1295,8 +1344,13 @@@ xfs_da3_fixhashpath
  		struct xfs_da3_icnode_hdr nodehdr;
  
  		node = blk->bp->b_addr;
++<<<<<<< HEAD
 +		xfs_da3_node_hdr_from_disk(&nodehdr, node);
 +		btree = xfs_da3_node_tree_p(node);
++=======
+ 		dp->d_ops->node_hdr_from_disk(&nodehdr, node);
+ 		btree = dp->d_ops->node_tree_p(node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  		if (be32_to_cpu(btree->hashval) == lasthash)
  			break;
  		blk->hashval = lasthash;
@@@ -1385,9 -1348,9 +1401,9 @@@ xfs_da3_node_remove
  	xfs_trans_log_buf(state->args->trans, drop_blk->bp,
  	    XFS_DA_LOGRANGE(node, &btree[index], sizeof(btree[index])));
  	nodehdr.count -= 1;
- 	xfs_da3_node_hdr_to_disk(node, &nodehdr);
+ 	dp->d_ops->node_hdr_to_disk(node, &nodehdr);
  	xfs_trans_log_buf(state->args->trans, drop_blk->bp,
 -	    XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size()));
 +	    XFS_DA_LOGRANGE(node, &node->hdr, xfs_da3_node_hdr_size(node)));
  
  	/*
  	 * Copy the last hash value from the block to propagate upwards.
@@@ -1419,10 -1383,10 +1435,17 @@@ xfs_da3_node_unbalance
  
  	drop_node = drop_blk->bp->b_addr;
  	save_node = save_blk->bp->b_addr;
++<<<<<<< HEAD
 +	xfs_da3_node_hdr_from_disk(&drop_hdr, drop_node);
 +	xfs_da3_node_hdr_from_disk(&save_hdr, save_node);
 +	drop_btree = xfs_da3_node_tree_p(drop_node);
 +	save_btree = xfs_da3_node_tree_p(save_node);
++=======
+ 	dp->d_ops->node_hdr_from_disk(&drop_hdr, drop_node);
+ 	dp->d_ops->node_hdr_from_disk(&save_hdr, save_node);
+ 	drop_btree = dp->d_ops->node_tree_p(drop_node);
+ 	save_btree = dp->d_ops->node_tree_p(save_node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	tp = state->args->trans;
  
  	/*
@@@ -1456,10 -1420,10 +1479,10 @@@
  	memcpy(&save_btree[sindex], &drop_btree[0], tmp);
  	save_hdr.count += drop_hdr.count;
  
- 	xfs_da3_node_hdr_to_disk(save_node, &save_hdr);
+ 	dp->d_ops->node_hdr_to_disk(save_node, &save_hdr);
  	xfs_trans_log_buf(tp, save_blk->bp,
  		XFS_DA_LOGRANGE(save_node, &save_node->hdr,
 -				dp->d_ops->node_hdr_size()));
 +				xfs_da3_node_hdr_size(save_node)));
  
  	/*
  	 * Save the last hashval in the remaining block for upward propagation.
@@@ -1547,8 -1513,8 +1570,13 @@@ xfs_da3_node_lookup_int
  		 * Search an intermediate node for a match.
  		 */
  		node = blk->bp->b_addr;
++<<<<<<< HEAD
 +		xfs_da3_node_hdr_from_disk(&nodehdr, node);
 +		btree = xfs_da3_node_tree_p(node);
++=======
+ 		dp->d_ops->node_hdr_from_disk(&nodehdr, node);
+ 		btree = dp->d_ops->node_tree_p(node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  		max = nodehdr.count;
  		blk->hashval = be32_to_cpu(btree[max - 1].hashval);
@@@ -1655,10 -1622,10 +1683,17 @@@ xfs_da3_node_order
  
  	node1 = node1_bp->b_addr;
  	node2 = node2_bp->b_addr;
++<<<<<<< HEAD
 +	xfs_da3_node_hdr_from_disk(&node1hdr, node1);
 +	xfs_da3_node_hdr_from_disk(&node2hdr, node2);
 +	btree1 = xfs_da3_node_tree_p(node1);
 +	btree2 = xfs_da3_node_tree_p(node2);
++=======
+ 	dp->d_ops->node_hdr_from_disk(&node1hdr, node1);
+ 	dp->d_ops->node_hdr_from_disk(&node2hdr, node2);
+ 	btree1 = dp->d_ops->node_tree_p(node1);
+ 	btree2 = dp->d_ops->node_tree_p(node2);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	if (node1hdr.count > 0 && node2hdr.count > 0 &&
  	    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||
@@@ -1876,8 -1845,8 +1911,13 @@@ xfs_da3_path_shift
  	level = (path->active-1) - 1;	/* skip bottom layer in path */
  	for (blk = &path->blk[level]; level >= 0; blk--, level--) {
  		node = blk->bp->b_addr;
++<<<<<<< HEAD
 +		xfs_da3_node_hdr_from_disk(&nodehdr, node);
 +		btree = xfs_da3_node_tree_p(node);
++=======
+ 		dp->d_ops->node_hdr_from_disk(&nodehdr, node);
+ 		btree = dp->d_ops->node_tree_p(node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  		if (forward && (blk->index < nodehdr.count - 1)) {
  			blk->index++;
@@@ -1933,8 -1902,8 +1973,13 @@@
  		case XFS_DA3_NODE_MAGIC:
  			blk->magic = XFS_DA_NODE_MAGIC;
  			node = (xfs_da_intnode_t *)info;
++<<<<<<< HEAD
 +			xfs_da3_node_hdr_from_disk(&nodehdr, node);
 +			btree = xfs_da3_node_tree_p(node);
++=======
+ 			dp->d_ops->node_hdr_from_disk(&nodehdr, node);
+ 			btree = dp->d_ops->node_tree_p(node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  			blk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);
  			if (forward)
  				blk->index = 0;
@@@ -2222,16 -2190,16 +2267,26 @@@ xfs_da3_swap_lastblock
  		struct xfs_dir2_leaf_entry *ents;
  
  		dead_leaf2 = (xfs_dir2_leaf_t *)dead_info;
++<<<<<<< HEAD
 +		xfs_dir3_leaf_hdr_from_disk(&leafhdr, dead_leaf2);
 +		ents = xfs_dir3_leaf_ents_p(dead_leaf2);
++=======
+ 		dp->d_ops->leaf_hdr_from_disk(&leafhdr, dead_leaf2);
+ 		ents = dp->d_ops->leaf_ents_p(dead_leaf2);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  		dead_level = 0;
  		dead_hash = be32_to_cpu(ents[leafhdr.count - 1].hashval);
  	} else {
  		struct xfs_da3_icnode_hdr deadhdr;
  
  		dead_node = (xfs_da_intnode_t *)dead_info;
++<<<<<<< HEAD
 +		xfs_da3_node_hdr_from_disk(&deadhdr, dead_node);
 +		btree = xfs_da3_node_tree_p(dead_node);
++=======
+ 		dp->d_ops->node_hdr_from_disk(&deadhdr, dead_node);
+ 		btree = dp->d_ops->node_tree_p(dead_node);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  		dead_level = deadhdr.level;
  		dead_hash = be32_to_cpu(btree[deadhdr.count - 1].hashval);
  	}
diff --cc fs/xfs/xfs_dir2.h
index e937d9991c18,61195348f667..000000000000
--- a/fs/xfs/xfs_dir2.h
+++ b/fs/xfs/xfs_dir2.h
@@@ -27,6 -32,78 +27,81 @@@ struct xfs_trans
  extern struct xfs_name	xfs_name_dotdot;
  
  /*
++<<<<<<< HEAD
++=======
+  * directory operations vector for encode/decode routines
+  */
+ struct xfs_dir_ops {
+ 	int	(*sf_entsize)(struct xfs_dir2_sf_hdr *hdr, int len);
+ 	struct xfs_dir2_sf_entry *
+ 		(*sf_nextentry)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	__uint8_t (*sf_get_ftype)(struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ftype)(struct xfs_dir2_sf_entry *sfep,
+ 				__uint8_t ftype);
+ 	xfs_ino_t (*sf_get_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 			      struct xfs_dir2_sf_entry *sfep,
+ 			      xfs_ino_t ino);
+ 	xfs_ino_t (*sf_get_parent_ino)(struct xfs_dir2_sf_hdr *hdr);
+ 	void	(*sf_put_parent_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				     xfs_ino_t ino);
+ 
+ 	int	(*data_entsize)(int len);
+ 	__uint8_t (*data_get_ftype)(struct xfs_dir2_data_entry *dep);
+ 	void	(*data_put_ftype)(struct xfs_dir2_data_entry *dep,
+ 				__uint8_t ftype);
+ 	__be16 * (*data_entry_tag_p)(struct xfs_dir2_data_entry *dep);
+ 	struct xfs_dir2_data_free *
+ 		(*data_bestfree_p)(struct xfs_dir2_data_hdr *hdr);
+ 
+ 	xfs_dir2_data_aoff_t (*data_dot_offset)(void);
+ 	xfs_dir2_data_aoff_t (*data_dotdot_offset)(void);
+ 	xfs_dir2_data_aoff_t (*data_first_offset)(void);
+ 	size_t	(*data_entry_offset)(void);
+ 
+ 	struct xfs_dir2_data_entry *
+ 		(*data_dot_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_dotdot_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_first_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_unused *
+ 		(*data_unused_p)(struct xfs_dir2_data_hdr *hdr);
+ 
+ 	int	(*leaf_hdr_size)(void);
+ 	void	(*leaf_hdr_to_disk)(struct xfs_dir2_leaf *to,
+ 				    struct xfs_dir3_icleaf_hdr *from);
+ 	void	(*leaf_hdr_from_disk)(struct xfs_dir3_icleaf_hdr *to,
+ 				      struct xfs_dir2_leaf *from);
+ 	int	(*leaf_max_ents)(struct xfs_mount *mp);
+ 	struct xfs_dir2_leaf_entry *
+ 		(*leaf_ents_p)(struct xfs_dir2_leaf *lp);
+ 
+ 	int	(*node_hdr_size)(void);
+ 	void	(*node_hdr_to_disk)(struct xfs_da_intnode *to,
+ 				    struct xfs_da3_icnode_hdr *from);
+ 	void	(*node_hdr_from_disk)(struct xfs_da3_icnode_hdr *to,
+ 				      struct xfs_da_intnode *from);
+ 	struct xfs_da_node_entry *
+ 		(*node_tree_p)(struct xfs_da_intnode *dap);
+ 
+ 	void	(*free_hdr_to_disk)(struct xfs_dir2_free *to,
+ 				    struct xfs_dir3_icfree_hdr *from);
+ 	void	(*free_hdr_from_disk)(struct xfs_dir3_icfree_hdr *to,
+ 				      struct xfs_dir2_free *from);
+ };
+ 
+ extern const struct xfs_dir_ops *
+ 	xfs_dir_get_ops(struct xfs_mount *mp, struct xfs_inode *dp);
+ extern const struct xfs_dir_ops *
+ 	xfs_nondir_get_ops(struct xfs_mount *mp, struct xfs_inode *dp);
+ 
+ /*
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
   * Generic directory interface routines
   */
  extern void xfs_dir_startup(void);
diff --cc fs/xfs/xfs_dir2_block.c
index 53b9aa26d567,c1ff552aa7bf..000000000000
--- a/fs/xfs/xfs_dir2_block.c
+++ b/fs/xfs/xfs_dir2_block.c
@@@ -1029,8 -936,8 +1029,13 @@@ xfs_dir2_leaf_to_block
  	tp = args->trans;
  	mp = dp->i_mount;
  	leaf = lbp->b_addr;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +	ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	ltp = xfs_dir2_leaf_tail_p(mp, leaf);
  
  	ASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||
diff --cc fs/xfs/xfs_dir2_format.h
index 2095e17b75cb,1ff7b9f42097..000000000000
--- a/fs/xfs/xfs_dir2_format.h
+++ b/fs/xfs/xfs_dir2_format.h
@@@ -16,8 -16,113 +16,118 @@@
   * along with this program; if not, write the Free Software Foundation,
   * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   */
++<<<<<<< HEAD:fs/xfs/xfs_dir2_format.h
 +#ifndef __XFS_DIR2_FORMAT_H__
 +#define __XFS_DIR2_FORMAT_H__
++=======
+ #ifndef __XFS_DA_FORMAT_H__
+ #define __XFS_DA_FORMAT_H__
+ 
+ /*========================================================================
+  * Directory Structure when greater than XFS_LBSIZE(mp) bytes.
+  *========================================================================*/
+ 
+ /*
+  * This structure is common to both leaf nodes and non-leaf nodes in the Btree.
+  *
+  * It is used to manage a doubly linked list of all blocks at the same
+  * level in the Btree, and to identify which type of block this is.
+  */
+ #define XFS_DA_NODE_MAGIC	0xfebe	/* magic number: non-leaf blocks */
+ #define XFS_ATTR_LEAF_MAGIC	0xfbee	/* magic number: attribute leaf blks */
+ #define	XFS_DIR2_LEAF1_MAGIC	0xd2f1	/* magic number: v2 dirlf single blks */
+ #define	XFS_DIR2_LEAFN_MAGIC	0xd2ff	/* magic number: v2 dirlf multi blks */
+ 
+ typedef struct xfs_da_blkinfo {
+ 	__be32		forw;			/* previous block in list */
+ 	__be32		back;			/* following block in list */
+ 	__be16		magic;			/* validity check on block */
+ 	__be16		pad;			/* unused */
+ } xfs_da_blkinfo_t;
+ 
+ /*
+  * CRC enabled directory structure types
+  *
+  * The headers change size for the additional verification information, but
+  * otherwise the tree layouts and contents are unchanged. Hence the da btree
+  * code can use the struct xfs_da_blkinfo for manipulating the tree links and
+  * magic numbers without modification for both v2 and v3 nodes.
+  */
+ #define XFS_DA3_NODE_MAGIC	0x3ebe	/* magic number: non-leaf blocks */
+ #define XFS_ATTR3_LEAF_MAGIC	0x3bee	/* magic number: attribute leaf blks */
+ #define	XFS_DIR3_LEAF1_MAGIC	0x3df1	/* magic number: v2 dirlf single blks */
+ #define	XFS_DIR3_LEAFN_MAGIC	0x3dff	/* magic number: v2 dirlf multi blks */
+ 
+ struct xfs_da3_blkinfo {
+ 	/*
+ 	 * the node link manipulation code relies on the fact that the first
+ 	 * element of this structure is the struct xfs_da_blkinfo so it can
+ 	 * ignore the differences in the rest of the structures.
+ 	 */
+ 	struct xfs_da_blkinfo	hdr;
+ 	__be32			crc;	/* CRC of block */
+ 	__be64			blkno;	/* first block of the buffer */
+ 	__be64			lsn;	/* sequence number of last write */
+ 	uuid_t			uuid;	/* filesystem we belong to */
+ 	__be64			owner;	/* inode that owns the block */
+ };
+ 
+ /*
+  * This is the structure of the root and intermediate nodes in the Btree.
+  * The leaf nodes are defined above.
+  *
+  * Entries are not packed.
+  *
+  * Since we have duplicate keys, use a binary search but always follow
+  * all match in the block, not just the first match found.
+  */
+ #define	XFS_DA_NODE_MAXDEPTH	5	/* max depth of Btree */
+ 
+ typedef struct xfs_da_node_hdr {
+ 	struct xfs_da_blkinfo	info;	/* block type, links, etc. */
+ 	__be16			__count; /* count of active entries */
+ 	__be16			__level; /* level above leaves (leaf == 0) */
+ } xfs_da_node_hdr_t;
+ 
+ struct xfs_da3_node_hdr {
+ 	struct xfs_da3_blkinfo	info;	/* block type, links, etc. */
+ 	__be16			__count; /* count of active entries */
+ 	__be16			__level; /* level above leaves (leaf == 0) */
+ 	__be32			__pad32;
+ };
+ 
+ #define XFS_DA3_NODE_CRC_OFF	(offsetof(struct xfs_da3_node_hdr, info.crc))
+ 
+ typedef struct xfs_da_node_entry {
+ 	__be32	hashval;	/* hash value for this descendant */
+ 	__be32	before;		/* Btree block before this key */
+ } xfs_da_node_entry_t;
+ 
+ typedef struct xfs_da_intnode {
+ 	struct xfs_da_node_hdr	hdr;
+ 	struct xfs_da_node_entry __btree[];
+ } xfs_da_intnode_t;
+ 
+ struct xfs_da3_intnode {
+ 	struct xfs_da3_node_hdr	hdr;
+ 	struct xfs_da_node_entry __btree[];
+ };
+ 
+ /*
+  * In-core version of the node header to abstract the differences in the v2 and
+  * v3 disk format of the headers. Callers need to convert to/from disk format as
+  * appropriate.
+  */
+ struct xfs_da3_icnode_hdr {
+ 	__uint32_t	forw;
+ 	__uint32_t	back;
+ 	__uint16_t	magic;
+ 	__uint16_t	count;
+ 	__uint16_t	level;
+ };
+ 
+ #define	XFS_LBSIZE(mp)	(mp)->m_sb.sb_blocksize
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers):fs/xfs/xfs_da_format.h
  
  /*
   * Directory version 2.
@@@ -519,39 -513,6 +629,42 @@@ struct xfs_dir3_leaf 
  
  #define XFS_DIR3_LEAF_CRC_OFF  offsetof(struct xfs_dir3_leaf_hdr, info.crc)
  
++<<<<<<< HEAD:fs/xfs/xfs_dir2_format.h
 +extern void xfs_dir3_leaf_hdr_from_disk(struct xfs_dir3_icleaf_hdr *to,
 +					struct xfs_dir2_leaf *from);
 +
 +static inline int
 +xfs_dir3_leaf_hdr_size(struct xfs_dir2_leaf *lp)
 +{
 +	if (lp->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||
 +	    lp->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC))
 +		return sizeof(struct xfs_dir3_leaf_hdr);
 +	return sizeof(struct xfs_dir2_leaf_hdr);
 +}
 +
 +static inline int
 +xfs_dir3_max_leaf_ents(struct xfs_mount *mp, struct xfs_dir2_leaf *lp)
 +{
 +	return (mp->m_dirblksize - xfs_dir3_leaf_hdr_size(lp)) /
 +		(uint)sizeof(struct xfs_dir2_leaf_entry);
 +}
 +
 +/*
 + * Get address of the bestcount field in the single-leaf block.
 + */
 +static inline struct xfs_dir2_leaf_entry *
 +xfs_dir3_leaf_ents_p(struct xfs_dir2_leaf *lp)
 +{
 +	if (lp->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||
 +	    lp->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {
 +		struct xfs_dir3_leaf *lp3 = (struct xfs_dir3_leaf *)lp;
 +		return lp3->__ents;
 +	}
 +	return lp->__ents;
 +}
 +
++=======
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers):fs/xfs/xfs_da_format.h
  /*
   * Get address of the bestcount field in the single-leaf block.
   */
diff --cc fs/xfs/xfs_dir2_leaf.c
index 2dedee56777d,2fb8db9fb574..000000000000
--- a/fs/xfs/xfs_dir2_leaf.c
+++ b/fs/xfs/xfs_dir2_leaf.c
@@@ -74,68 -73,12 +74,12 @@@ xfs_dir3_leaf1_check
  	} else if (leafhdr.magic != XFS_DIR2_LEAF1_MAGIC)
  		return false;
  
 -	return xfs_dir3_leaf_check_int(dp->i_mount, dp, &leafhdr, leaf);
 +	return xfs_dir3_leaf_check_int(mp, &leafhdr, leaf);
  }
  #else
 -#define	xfs_dir3_leaf_check(dp, bp)
 +#define	xfs_dir3_leaf_check(mp, bp)
  #endif
  
- void
- xfs_dir3_leaf_hdr_from_disk(
- 	struct xfs_dir3_icleaf_hdr	*to,
- 	struct xfs_dir2_leaf		*from)
- {
- 	if (from->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||
- 	    from->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC)) {
- 		to->forw = be32_to_cpu(from->hdr.info.forw);
- 		to->back = be32_to_cpu(from->hdr.info.back);
- 		to->magic = be16_to_cpu(from->hdr.info.magic);
- 		to->count = be16_to_cpu(from->hdr.count);
- 		to->stale = be16_to_cpu(from->hdr.stale);
- 	} else {
- 		struct xfs_dir3_leaf_hdr *hdr3 = (struct xfs_dir3_leaf_hdr *)from;
- 
- 		to->forw = be32_to_cpu(hdr3->info.hdr.forw);
- 		to->back = be32_to_cpu(hdr3->info.hdr.back);
- 		to->magic = be16_to_cpu(hdr3->info.hdr.magic);
- 		to->count = be16_to_cpu(hdr3->count);
- 		to->stale = be16_to_cpu(hdr3->stale);
- 	}
- 
- 	ASSERT(to->magic == XFS_DIR2_LEAF1_MAGIC ||
- 	       to->magic == XFS_DIR3_LEAF1_MAGIC ||
- 	       to->magic == XFS_DIR2_LEAFN_MAGIC ||
- 	       to->magic == XFS_DIR3_LEAFN_MAGIC);
- }
- 
- void
- xfs_dir3_leaf_hdr_to_disk(
- 	struct xfs_dir2_leaf		*to,
- 	struct xfs_dir3_icleaf_hdr	*from)
- {
- 	ASSERT(from->magic == XFS_DIR2_LEAF1_MAGIC ||
- 	       from->magic == XFS_DIR3_LEAF1_MAGIC ||
- 	       from->magic == XFS_DIR2_LEAFN_MAGIC ||
- 	       from->magic == XFS_DIR3_LEAFN_MAGIC);
- 
- 	if (from->magic == XFS_DIR2_LEAF1_MAGIC ||
- 	    from->magic == XFS_DIR2_LEAFN_MAGIC) {
- 		to->hdr.info.forw = cpu_to_be32(from->forw);
- 		to->hdr.info.back = cpu_to_be32(from->back);
- 		to->hdr.info.magic = cpu_to_be16(from->magic);
- 		to->hdr.count = cpu_to_be16(from->count);
- 		to->hdr.stale = cpu_to_be16(from->stale);
- 	} else {
- 		struct xfs_dir3_leaf_hdr *hdr3 = (struct xfs_dir3_leaf_hdr *)to;
- 
- 		hdr3->info.hdr.forw = cpu_to_be32(from->forw);
- 		hdr3->info.hdr.back = cpu_to_be32(from->back);
- 		hdr3->info.hdr.magic = cpu_to_be16(from->magic);
- 		hdr3->count = cpu_to_be16(from->count);
- 		hdr3->stale = cpu_to_be16(from->stale);
- 	}
- }
- 
  bool
  xfs_dir3_leaf_check_int(
  	struct xfs_mount	*mp,
@@@ -146,8 -90,21 +90,26 @@@
  	xfs_dir2_leaf_tail_t	*ltp;
  	int			stale;
  	int			i;
++<<<<<<< HEAD
 +
 +	ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 	const struct xfs_dir_ops *ops;
+ 	struct xfs_dir3_icleaf_hdr leafhdr;
+ 
+ 	/*
+ 	 * we can be passed a null dp here from a verifier, so we need to go the
+ 	 * hard way to get them.
+ 	 */
+ 	ops = xfs_dir_get_ops(mp, dp);
+ 
+ 	if (!hdr) {
+ 		ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 		hdr = &leafhdr;
+ 	}
+ 
+ 	ents = ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	ltp = xfs_dir2_leaf_tail_p(mp, leaf);
  
  	/*
@@@ -213,8 -169,7 +174,12 @@@ xfs_dir3_leaf_verify
  			return false;
  	}
  
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +	return xfs_dir3_leaf_check_int(mp, &leafhdr, leaf);
++=======
+ 	return xfs_dir3_leaf_check_int(mp, NULL, NULL, leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  }
  
  static void
@@@ -467,11 -422,11 +432,16 @@@ xfs_dir2_block_to_leaf
  	/*
  	 * Set the counts in the leaf header.
  	 */
- 	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
  	leafhdr.count = be32_to_cpu(btp->count);
  	leafhdr.stale = be32_to_cpu(btp->stale);
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);
 +	xfs_dir3_leaf_log_header(tp, lbp);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);
+ 	xfs_dir3_leaf_log_header(tp, dp, lbp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	/*
  	 * Could compact these but I think we always do the conversion
@@@ -698,10 -653,10 +668,15 @@@ xfs_dir2_leaf_addname
  	index = xfs_dir2_leaf_search_hash(args, lbp);
  	leaf = lbp->b_addr;
  	ltp = xfs_dir2_leaf_tail_p(mp, leaf);
++<<<<<<< HEAD
 +	ents = xfs_dir3_leaf_ents_p(leaf);
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
++=======
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	bestsp = xfs_dir2_leaf_bests_p(ltp);
 -	length = dp->d_ops->data_entsize(args->namelen);
 +	length = xfs_dir2_data_entsize(args->namelen);
  
  	/*
  	 * See if there are any entries with the same hash value
@@@ -937,10 -893,10 +912,17 @@@
  	/*
  	 * Log the leaf fields and give up the buffers.
  	 */
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);
 +	xfs_dir3_leaf_log_header(tp, lbp);
 +	xfs_dir3_leaf_log_ents(tp, lbp, lfloglow, lfloghigh);
 +	xfs_dir3_leaf_check(mp, lbp);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);
+ 	xfs_dir3_leaf_log_header(tp, dp, lbp);
+ 	xfs_dir3_leaf_log_ents(tp, dp, lbp, lfloglow, lfloghigh);
+ 	xfs_dir3_leaf_check(dp, lbp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	xfs_dir3_data_check(dp, dbp);
  	return 0;
  }
@@@ -968,7 -925,7 +951,11 @@@ xfs_dir3_leaf_compact
  	/*
  	 * Compress out the stale entries in place.
  	 */
++<<<<<<< HEAD
 +	ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	for (from = to = 0, loglow = -1; from < leafhdr->count; from++) {
  		if (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))
  			continue;
@@@ -989,10 -946,10 +976,17 @@@
  	leafhdr->count -= leafhdr->stale;
  	leafhdr->stale = 0;
  
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(leaf, leafhdr);
 +	xfs_dir3_leaf_log_header(args->trans, bp);
 +	if (loglow != -1)
 +		xfs_dir3_leaf_log_ents(args->trans, bp, loglow, to - 1);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(leaf, leafhdr);
+ 	xfs_dir3_leaf_log_header(args->trans, dp, bp);
+ 	if (loglow != -1)
+ 		xfs_dir3_leaf_log_ents(args->trans, dp, bp, loglow, to - 1);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  }
  
  /*
@@@ -1668,9 -1236,9 +1662,15 @@@ xfs_dir2_leaf_lookup_int
  
  	*lbpp = lbp;
  	leaf = lbp->b_addr;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_check(mp, lbp);
 +	ents = xfs_dir3_leaf_ents_p(leaf);
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
++=======
+ 	xfs_dir3_leaf_check(dp, lbp);
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	/*
  	 * Look for the first leaf entry with our hash value.
@@@ -1804,9 -1372,9 +1804,15 @@@ xfs_dir2_leaf_removename
  	leaf = lbp->b_addr;
  	hdr = dbp->b_addr;
  	xfs_dir3_data_check(dp, dbp);
++<<<<<<< HEAD
 +	bf = xfs_dir3_data_bestfree_p(hdr);
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +	ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 	bf = dp->d_ops->data_bestfree_p(hdr);
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	/*
  	 * Point to the leaf entry, use that to point to the data entry.
  	 */
@@@ -1829,11 -1397,11 +1835,16 @@@
  	 * We just mark the leaf entry stale by putting a null in it.
  	 */
  	leafhdr.stale++;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);
 +	xfs_dir3_leaf_log_header(tp, lbp);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);
+ 	xfs_dir3_leaf_log_header(tp, dp, lbp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	lep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);
 -	xfs_dir3_leaf_log_ents(tp, dp, lbp, index, index);
 +	xfs_dir3_leaf_log_ents(tp, lbp, index, index);
  
  	/*
  	 * Scan the freespace in the data block again if necessary,
@@@ -1980,8 -1549,8 +1991,13 @@@ xfs_dir2_leaf_search_hash
  	struct xfs_dir3_icleaf_hdr leafhdr;
  
  	leaf = lbp->b_addr;
++<<<<<<< HEAD
 +	ents = xfs_dir3_leaf_ents_p(leaf);
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
++=======
+ 	ents = args->dp->d_ops->leaf_ents_p(leaf);
+ 	args->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	/*
  	 * Note, the table cannot be empty, so we have to go through the loop.
@@@ -2219,11 -1788,11 +2235,16 @@@ xfs_dir2_node_to_leaf
  	memcpy(xfs_dir2_leaf_bests_p(ltp), xfs_dir3_free_bests_p(mp, free),
  		freehdr.nvalid * sizeof(xfs_dir2_data_off_t));
  
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);
 +	xfs_dir3_leaf_log_header(tp, lbp);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);
+ 	xfs_dir3_leaf_log_header(tp, dp, lbp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	xfs_dir3_leaf_log_bests(tp, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);
  	xfs_dir3_leaf_log_tail(tp, lbp);
 -	xfs_dir3_leaf_check(dp, lbp);
 +	xfs_dir3_leaf_check(mp, lbp);
  
  	/*
  	 * Get rid of the freespace block.
diff --cc fs/xfs/xfs_dir2_node.c
index cae73a62bfcc,eaee8c36bcc4..000000000000
--- a/fs/xfs/xfs_dir2_node.c
+++ b/fs/xfs/xfs_dir2_node.c
@@@ -442,8 -395,8 +395,13 @@@ xfs_dir2_leafn_add
  	mp = dp->i_mount;
  	tp = args->trans;
  	leaf = bp->b_addr;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +	ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	/*
  	 * Quick check just to make sure we are not going to index
@@@ -497,10 -450,10 +455,17 @@@
  	lep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(mp,
  				args->blkno, args->index));
  
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);
 +	xfs_dir3_leaf_log_header(tp, bp);
 +	xfs_dir3_leaf_log_ents(tp, bp, lfloglow, lfloghigh);
 +	xfs_dir3_leaf_check(mp, bp);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);
+ 	xfs_dir3_leaf_log_header(tp, dp, bp);
+ 	xfs_dir3_leaf_log_ents(tp, dp, bp, lfloglow, lfloghigh);
+ 	xfs_dir3_leaf_check(dp, bp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  	return 0;
  }
  
@@@ -583,10 -537,10 +548,15 @@@ xfs_dir2_leafn_lookup_for_addname
  	tp = args->trans;
  	mp = dp->i_mount;
  	leaf = bp->b_addr;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +	ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
 -	xfs_dir3_leaf_check(dp, bp);
 +	xfs_dir3_leaf_check(mp, bp);
  	ASSERT(leafhdr.count > 0);
  
  	/*
@@@ -733,10 -687,10 +703,15 @@@ xfs_dir2_leafn_lookup_for_entry
  	tp = args->trans;
  	mp = dp->i_mount;
  	leaf = bp->b_addr;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +	ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
 -	xfs_dir3_leaf_check(dp, bp);
 +	xfs_dir3_leaf_check(mp, bp);
  	ASSERT(leafhdr.count > 0);
  
  	/*
@@@ -964,10 -922,10 +939,17 @@@ xfs_dir2_leafn_order
  	struct xfs_dir3_icleaf_hdr hdr1;
  	struct xfs_dir3_icleaf_hdr hdr2;
  
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&hdr1, leaf1);
 +	xfs_dir3_leaf_hdr_from_disk(&hdr2, leaf2);
 +	ents1 = xfs_dir3_leaf_ents_p(leaf1);
 +	ents2 = xfs_dir3_leaf_ents_p(leaf2);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);
+ 	dp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);
+ 	ents1 = dp->d_ops->leaf_ents_p(leaf1);
+ 	ents2 = dp->d_ops->leaf_ents_p(leaf2);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	if (hdr1.count > 0 && hdr2.count > 0 &&
  	    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||
@@@ -1019,10 -978,10 +1001,17 @@@ xfs_dir2_leafn_rebalance
  	}
  	leaf1 = blk1->bp->b_addr;
  	leaf2 = blk2->bp->b_addr;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&hdr1, leaf1);
 +	xfs_dir3_leaf_hdr_from_disk(&hdr2, leaf2);
 +	ents1 = xfs_dir3_leaf_ents_p(leaf1);
 +	ents2 = xfs_dir3_leaf_ents_p(leaf2);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);
+ 	dp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);
+ 	ents1 = dp->d_ops->leaf_ents_p(leaf1);
+ 	ents2 = dp->d_ops->leaf_ents_p(leaf2);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	oldsum = hdr1.count + hdr2.count;
  #if defined(DEBUG) || defined(XFS_WARN)
@@@ -1068,13 -1027,13 +1057,20 @@@
  	ASSERT(hdr1.stale + hdr2.stale == oldstale);
  
  	/* log the changes made when moving the entries */
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(leaf1, &hdr1);
 +	xfs_dir3_leaf_hdr_to_disk(leaf2, &hdr2);
 +	xfs_dir3_leaf_log_header(args->trans, blk1->bp);
 +	xfs_dir3_leaf_log_header(args->trans, blk2->bp);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(leaf1, &hdr1);
+ 	dp->d_ops->leaf_hdr_to_disk(leaf2, &hdr2);
+ 	xfs_dir3_leaf_log_header(args->trans, dp, blk1->bp);
+ 	xfs_dir3_leaf_log_header(args->trans, dp, blk2->bp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
 -	xfs_dir3_leaf_check(dp, blk1->bp);
 -	xfs_dir3_leaf_check(dp, blk2->bp);
 +	xfs_dir3_leaf_check(args->dp->i_mount, blk1->bp);
 +	xfs_dir3_leaf_check(args->dp->i_mount, blk2->bp);
  
  	/*
  	 * Mark whether we're inserting into the old or new leaf.
@@@ -1220,8 -1180,8 +1217,13 @@@ xfs_dir2_leafn_remove
  	tp = args->trans;
  	mp = dp->i_mount;
  	leaf = bp->b_addr;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +	ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	/*
  	 * Point to the entry we're removing.
@@@ -1241,11 -1201,11 +1243,16 @@@
  	 * Log the leaf block changes.
  	 */
  	leafhdr.stale++;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);
 +	xfs_dir3_leaf_log_header(tp, bp);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);
+ 	xfs_dir3_leaf_log_header(tp, dp, bp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	lep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);
 -	xfs_dir3_leaf_log_ents(tp, dp, bp, index, index);
 +	xfs_dir3_leaf_log_ents(tp, bp, index, index);
  
  	/*
  	 * Make the data entry free.  Keep track of the longest freespace
@@@ -1440,12 -1403,12 +1447,18 @@@ xfs_dir2_leafn_toosmall
  	 */
  	blk = &state->path.blk[state->path.active - 1];
  	leaf = blk->bp->b_addr;
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
 +	ents = xfs_dir3_leaf_ents_p(leaf);
 +	xfs_dir3_leaf_check(state->args->dp->i_mount, blk->bp);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
+ 	ents = dp->d_ops->leaf_ents_p(leaf);
+ 	xfs_dir3_leaf_check(dp, blk->bp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	count = leafhdr.count - leafhdr.stale;
 -	bytes = dp->d_ops->leaf_hdr_size() + count * sizeof(ents[0]);
 +	bytes = xfs_dir3_leaf_hdr_size(leaf) + count * sizeof(ents[0]);
  	if (bytes > (state->blocksize >> 1)) {
  		/*
  		 * Blk over 50%, don't try to join.
@@@ -1502,8 -1465,8 +1515,13 @@@
  		bytes = state->blocksize - (state->blocksize >> 2);
  
  		leaf = bp->b_addr;
++<<<<<<< HEAD
 +		xfs_dir3_leaf_hdr_from_disk(&hdr2, leaf);
 +		ents = xfs_dir3_leaf_ents_p(leaf);
++=======
+ 		dp->d_ops->leaf_hdr_from_disk(&hdr2, leaf);
+ 		ents = dp->d_ops->leaf_ents_p(leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  		count += hdr2.count - hdr2.stale;
  		bytes -= count * sizeof(ents[0]);
  
@@@ -1564,10 -1528,10 +1582,17 @@@ xfs_dir2_leafn_unbalance
  	drop_leaf = drop_blk->bp->b_addr;
  	save_leaf = save_blk->bp->b_addr;
  
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_from_disk(&savehdr, save_leaf);
 +	xfs_dir3_leaf_hdr_from_disk(&drophdr, drop_leaf);
 +	sents = xfs_dir3_leaf_ents_p(save_leaf);
 +	dents = xfs_dir3_leaf_ents_p(drop_leaf);
++=======
+ 	dp->d_ops->leaf_hdr_from_disk(&savehdr, save_leaf);
+ 	dp->d_ops->leaf_hdr_from_disk(&drophdr, drop_leaf);
+ 	sents = dp->d_ops->leaf_ents_p(save_leaf);
+ 	dents = dp->d_ops->leaf_ents_p(drop_leaf);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
  	/*
  	 * If there are any stale leaf entries, take this opportunity
@@@ -1593,13 -1557,13 +1618,20 @@@
  	save_blk->hashval = be32_to_cpu(sents[savehdr.count - 1].hashval);
  
  	/* log the changes made when moving the entries */
++<<<<<<< HEAD
 +	xfs_dir3_leaf_hdr_to_disk(save_leaf, &savehdr);
 +	xfs_dir3_leaf_hdr_to_disk(drop_leaf, &drophdr);
 +	xfs_dir3_leaf_log_header(args->trans, save_blk->bp);
 +	xfs_dir3_leaf_log_header(args->trans, drop_blk->bp);
++=======
+ 	dp->d_ops->leaf_hdr_to_disk(save_leaf, &savehdr);
+ 	dp->d_ops->leaf_hdr_to_disk(drop_leaf, &drophdr);
+ 	xfs_dir3_leaf_log_header(args->trans, dp, save_blk->bp);
+ 	xfs_dir3_leaf_log_header(args->trans, dp, drop_blk->bp);
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  
 -	xfs_dir3_leaf_check(dp, save_blk->bp);
 -	xfs_dir3_leaf_check(dp, drop_blk->bp);
 +	xfs_dir3_leaf_check(args->dp->i_mount, save_blk->bp);
 +	xfs_dir3_leaf_check(args->dp->i_mount, drop_blk->bp);
  }
  
  /*
diff --cc fs/xfs/xfs_dir2_priv.h
index 7cf573c88aad,8b9d2281f85b..000000000000
--- a/fs/xfs/xfs_dir2_priv.h
+++ b/fs/xfs/xfs_dir2_priv.h
@@@ -112,11 -94,7 +112,15 @@@ xfs_dir3_leaf_find_entry(struct xfs_dir
  		int lowstale, int highstale, int *lfloglow, int *lfloghigh);
  extern int xfs_dir2_node_to_leaf(struct xfs_da_state *state);
  
++<<<<<<< HEAD
 +extern void xfs_dir3_leaf_hdr_from_disk(struct xfs_dir3_icleaf_hdr *to,
 +		struct xfs_dir2_leaf *from);
 +extern void xfs_dir3_leaf_hdr_to_disk(struct xfs_dir2_leaf *to,
 +		struct xfs_dir3_icleaf_hdr *from);
 +extern bool xfs_dir3_leaf_check_int(struct xfs_mount *mp,
++=======
+ extern bool xfs_dir3_leaf_check_int(struct xfs_mount *mp, struct xfs_inode *dp,
++>>>>>>> 01ba43b873d9 (xfs: vectorise encoding/decoding directory headers)
  		struct xfs_dir3_icleaf_hdr *hdr, struct xfs_dir2_leaf *leaf);
  
  /* xfs_dir2_node.c */
* Unmerged path fs/xfs/xfs_da_format.c
diff --git a/fs/xfs/xfs_attr_inactive.c b/fs/xfs/xfs_attr_inactive.c
index 9a4e42599cd7..d93cfd3b32e3 100644
--- a/fs/xfs/xfs_attr_inactive.c
+++ b/fs/xfs/xfs_attr_inactive.c
@@ -233,7 +233,7 @@ xfs_attr3_node_inactive(
 	}
 
 	node = bp->b_addr;
-	xfs_da3_node_hdr_from_disk(&ichdr, node);
+	dp->d_ops->node_hdr_from_disk(&ichdr, node);
 	parent_blkno = bp->b_bn;
 	if (!ichdr.count) {
 		xfs_trans_brelse(*trans, bp);
* Unmerged path fs/xfs/xfs_attr_leaf.c
* Unmerged path fs/xfs/xfs_attr_list.c
* Unmerged path fs/xfs/xfs_da_btree.c
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_dir2.h
* Unmerged path fs/xfs/xfs_dir2_block.c
* Unmerged path fs/xfs/xfs_dir2_format.h
* Unmerged path fs/xfs/xfs_dir2_leaf.c
* Unmerged path fs/xfs/xfs_dir2_node.c
* Unmerged path fs/xfs/xfs_dir2_priv.h
