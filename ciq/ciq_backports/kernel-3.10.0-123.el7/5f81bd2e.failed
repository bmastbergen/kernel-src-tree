ipv6: export a stub for IPv6 symbols used by vxlan

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Cong Wang <amwang@redhat.com>
commit 5f81bd2e5d804ca93f3ec8873451b22d2f454721
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/5f81bd2e.failed

In case IPv6 is compiled as a module, introduce a stub
for ipv6_sock_mc_join and ipv6_sock_mc_drop etc.. It will be used
by vxlan module. Suggested by Ben.

This is an ugly but easy solution for now.

	Cc: Ben Hutchings <bhutchings@solarflare.com>
	Cc: Stephen Hemminger <stephen@networkplumber.org>
	Cc: David S. Miller <davem@davemloft.net>
	Signed-off-by: Cong Wang <amwang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5f81bd2e5d804ca93f3ec8873451b22d2f454721)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/addrconf.h
diff --cc include/net/addrconf.h
index c7b181cb47a6,5339cab356bb..000000000000
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@@ -134,31 -118,44 +134,50 @@@ extern u32			ipv6_addr_label(struct ne
  /*
   *	multicast prototypes (mcast.c)
   */
 -int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 -		      const struct in6_addr *addr);
 -int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
 -		      const struct in6_addr *addr);
 -void ipv6_sock_mc_close(struct sock *sk);
 -bool inet6_mc_check(struct sock *sk, const struct in6_addr *mc_addr,
 -		    const struct in6_addr *src_addr);
 -
 -int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
 -int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 -int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
 -void ipv6_mc_up(struct inet6_dev *idev);
 -void ipv6_mc_down(struct inet6_dev *idev);
 -void ipv6_mc_unmap(struct inet6_dev *idev);
 -void ipv6_mc_remap(struct inet6_dev *idev);
 -void ipv6_mc_init_dev(struct inet6_dev *idev);
 -void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 -void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 -
 -bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,
 -			 const struct in6_addr *src_addr);
 -
 +extern int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 +			     const struct in6_addr *addr);
 +extern int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
 +			     const struct in6_addr *addr);
 +extern void ipv6_sock_mc_close(struct sock *sk);
 +extern bool inet6_mc_check(struct sock *sk,
 +			   const struct in6_addr *mc_addr,
 +			   const struct in6_addr *src_addr);
 +
 +extern int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
 +extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 +extern int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
 +extern void ipv6_mc_up(struct inet6_dev *idev);
 +extern void ipv6_mc_down(struct inet6_dev *idev);
 +extern void ipv6_mc_unmap(struct inet6_dev *idev);
 +extern void ipv6_mc_remap(struct inet6_dev *idev);
 +extern void ipv6_mc_init_dev(struct inet6_dev *idev);
 +extern void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 +extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 +
 +extern bool ipv6_chk_mcast_addr(struct net_device *dev,
 +				const struct in6_addr *group,
 +				const struct in6_addr *src_addr);
 +
++<<<<<<< HEAD
 +extern void ipv6_mc_dad_complete(struct inet6_dev *idev);
++=======
+ void ipv6_mc_dad_complete(struct inet6_dev *idev);
+ 
+ /* A stub used by vxlan module. This is ugly, ideally these
+  * symbols should be built into the core kernel.
+  */
+ struct ipv6_stub {
+ 	int (*ipv6_sock_mc_join)(struct sock *sk, int ifindex,
+ 				 const struct in6_addr *addr);
+ 	int (*ipv6_sock_mc_drop)(struct sock *sk, int ifindex,
+ 				 const struct in6_addr *addr);
+ 	int (*ipv6_dst_lookup)(struct sock *sk, struct dst_entry **dst,
+ 				struct flowi6 *fl6);
+ 	void (*udpv6_encap_enable)(void);
+ };
+ extern const struct ipv6_stub *ipv6_stub __read_mostly;
+ 
++>>>>>>> 5f81bd2e5d80 (ipv6: export a stub for IPv6 symbols used by vxlan)
  /*
   * identify MLD packets for MLD filter exceptions
   */
* Unmerged path include/net/addrconf.h
diff --git a/net/ipv6/addrconf_core.c b/net/ipv6/addrconf_core.c
index 72104562c864..3807a7941cb4 100644
--- a/net/ipv6/addrconf_core.c
+++ b/net/ipv6/addrconf_core.c
@@ -97,3 +97,6 @@ int inet6addr_notifier_call_chain(unsigned long val, void *v)
 	return atomic_notifier_call_chain(&inet6addr_chain, val, v);
 }
 EXPORT_SYMBOL(inet6addr_notifier_call_chain);
+
+const struct ipv6_stub *ipv6_stub __read_mostly;
+EXPORT_SYMBOL_GPL(ipv6_stub);
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index ab5c7ad482cd..58de0555fbce 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -808,6 +808,13 @@ static struct pernet_operations inet6_net_ops = {
 	.exit = inet6_net_exit,
 };
 
+static const struct ipv6_stub ipv6_stub_impl = {
+	.ipv6_sock_mc_join = ipv6_sock_mc_join,
+	.ipv6_sock_mc_drop = ipv6_sock_mc_drop,
+	.ipv6_dst_lookup = ip6_dst_lookup,
+	.udpv6_encap_enable = udpv6_encap_enable,
+};
+
 static int __init inet6_init(void)
 {
 	struct list_head *r;
@@ -879,6 +886,9 @@ static int __init inet6_init(void)
 	err = igmp6_init();
 	if (err)
 		goto igmp_fail;
+
+	ipv6_stub = &ipv6_stub_impl;
+
 	err = ipv6_netfilter_init();
 	if (err)
 		goto netfilter_fail;
@@ -1027,6 +1037,7 @@ static void __exit inet6_exit(void)
 	raw6_proc_exit();
 #endif
 	ipv6_netfilter_fini();
+	ipv6_stub = NULL;
 	igmp6_cleanup();
 	ndisc_cleanup();
 	ip6_mr_cleanup();
