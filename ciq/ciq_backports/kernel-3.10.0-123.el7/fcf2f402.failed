s390/pci: obtain function handle in hotplug notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [s390] pci: obtain function handle in hotplug notifier (Hendrik Brueckner) [1059247]
Rebuild_FUZZ: 94.95%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit fcf2f402937a6696f6fa2a1aa882c5075e5fac34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/fcf2f402.failed

When using the CLP interface to enable or disable a pci device a
valid function handle needs to be delivered. So far our assumption
was that we always have an up-to-date version of the function handle
(since it doesn't change when the device is in use). This assumption
is incorrect if the pci device is enabled or disabled outside of our
control. When we are notified about such a change we already receive
the new function handle. Just use it.

	Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit fcf2f402937a6696f6fa2a1aa882c5075e5fac34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_event.c
diff --cc arch/s390/pci/pci_event.c
index bbbed1e7538f,069607209a30..000000000000
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@@ -84,5 -60,60 +84,64 @@@ void zpci_event_error(void *data
  
  void zpci_event_availability(void *data)
  {
++<<<<<<< HEAD
 +	zpci_event_log_avail(data);
++=======
+ 	struct zpci_ccdf_avail *ccdf = data;
+ 	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
+ 	struct pci_dev *pdev = zdev ? zdev->pdev : NULL;
+ 	int ret;
+ 
+ 	pr_info("%s: Event 0x%x reconfigured PCI function 0x%x\n",
+ 		pdev ? pci_name(pdev) : "n/a", ccdf->pec, ccdf->fid);
+ 	zpci_err("avail CCDF:\n");
+ 	zpci_err_hex(ccdf, sizeof(*ccdf));
+ 
+ 	switch (ccdf->pec) {
+ 	case 0x0301: /* Standby -> Configured */
+ 		if (!zdev || zdev->state == ZPCI_FN_STATE_CONFIGURED)
+ 			break;
+ 		zdev->state = ZPCI_FN_STATE_CONFIGURED;
+ 		zdev->fh = ccdf->fh;
+ 		ret = zpci_enable_device(zdev);
+ 		if (ret)
+ 			break;
+ 		pci_rescan_bus(zdev->bus);
+ 		break;
+ 	case 0x0302: /* Reserved -> Standby */
+ 		clp_add_pci_device(ccdf->fid, ccdf->fh, 0);
+ 		break;
+ 	case 0x0303: /* Deconfiguration requested */
+ 		if (pdev)
+ 			pci_stop_and_remove_bus_device(pdev);
+ 
+ 		ret = zpci_disable_device(zdev);
+ 		if (ret)
+ 			break;
+ 
+ 		ret = sclp_pci_deconfigure(zdev->fid);
+ 		zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, ret);
+ 		if (!ret)
+ 			zdev->state = ZPCI_FN_STATE_STANDBY;
+ 
+ 		break;
+ 	case 0x0304: /* Configured -> Standby */
+ 		if (pdev)
+ 			pci_stop_and_remove_bus_device(pdev);
+ 
+ 		zdev->fh = ccdf->fh;
+ 		zpci_disable_device(zdev);
+ 		zdev->state = ZPCI_FN_STATE_STANDBY;
+ 		break;
+ 	case 0x0306: /* 0x308 or 0x302 for multiple devices */
+ 		clp_rescan_pci_devices();
+ 		break;
+ 	case 0x0308: /* Standby -> Reserved */
+ 		pci_stop_root_bus(zdev->bus);
+ 		pci_remove_root_bus(zdev->bus);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> fcf2f402937a (s390/pci: obtain function handle in hotplug notifier)
  }
* Unmerged path arch/s390/pci/pci_event.c
