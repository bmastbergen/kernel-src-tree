EDAC: Poll timeout cannot be zero, p2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [edac] Poll timeout cannot be zero, p2 (Aristeu Rozanski) [1055892]
Rebuild_FUZZ: 91.18%
commit-author Borislav Petkov <bp@suse.de>
commit 9da21b1509d8aa7ab4846722817d16c72d656c91
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/9da21b15.failed

Sanitize code even more to accept unsigned longs only and to not allow
polling intervals below 1 second as this is unnecessary and doesn't make
much sense anyway for polling errors.

	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: http://lkml.kernel.org/r/1391457913-881-1-git-send-email-prarit@redhat.com
	Cc: Doug Thompson <dougthompson@xmission.com>
	Cc: <stable@vger.kernel.org>
(cherry picked from commit 9da21b1509d8aa7ab4846722817d16c72d656c91)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/edac_mc_sysfs.c
diff --cc drivers/edac/edac_mc_sysfs.c
index 67610a6ebf87,b335c6ab5efe..000000000000
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@@ -58,10 -58,14 +58,19 @@@ static int edac_set_poll_msec(const cha
  	if (!val)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	ret = strict_strtol(val, 0, &l);
 +	if (ret == -EINVAL || ((int)l != l))
++=======
+ 	ret = kstrtoul(val, 0, &l);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (l < 1000)
++>>>>>>> 9da21b1509d8 (EDAC: Poll timeout cannot be zero, p2)
  		return -EINVAL;
- 	*((int *)kp->arg) = l;
+ 
+ 	*((unsigned long *)kp->arg) = l;
  
  	/* notify edac_mc engine to reset the poll period */
  	edac_mc_reset_delay_period(l);
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index 27e86d938262..75ed29b00b16 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -599,7 +599,7 @@ static void edac_mc_workq_teardown(struct mem_ctl_info *mci)
  *	user space has updated our poll period value, need to
  *	reset our workq delays
  */
-void edac_mc_reset_delay_period(int value)
+void edac_mc_reset_delay_period(unsigned long value)
 {
 	struct mem_ctl_info *mci;
 	struct list_head *item;
@@ -609,7 +609,7 @@ void edac_mc_reset_delay_period(int value)
 	list_for_each(item, &mc_devices) {
 		mci = list_entry(item, struct mem_ctl_info, link);
 
-		edac_mc_workq_setup(mci, (unsigned long) value);
+		edac_mc_workq_setup(mci, value);
 	}
 
 	mutex_unlock(&mem_ctls_mutex);
* Unmerged path drivers/edac/edac_mc_sysfs.c
diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 3d139c6e7fe3..f2118bfcf8df 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -52,7 +52,7 @@ extern void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 extern void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_reset_delay_period(struct edac_device_ctl_info
 					   *edac_dev, unsigned long value);
-extern void edac_mc_reset_delay_period(int value);
+extern void edac_mc_reset_delay_period(unsigned long value);
 
 extern void *edac_align_ptr(void **p, unsigned size, int n_elems);
 
