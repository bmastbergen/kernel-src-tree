PCI/ACPI: Separate out _OSC "we don't support enough services" path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [acpi] Separate out _OSC "we don't support enough services" path (Myron Stowe) [1033834]
Rebuild_FUZZ: 92.06%
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit de18966228ed4b42393ecbe83ba20ff3db78bfdc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/de189662.failed

Test the services we support (extended config space, ASPM, MSI) separately
so we can give a better message.  Previously we said "Unable to request
_OSC control..."; now we'll say "we support %#02x but %#02x are required".

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit de18966228ed4b42393ecbe83ba20ff3db78bfdc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/pci_root.c
diff --cc drivers/acpi/pci_root.c
index ed36e22817d8,65aefcf78552..000000000000
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@@ -360,6 -360,90 +360,93 @@@ out
  }
  EXPORT_SYMBOL(acpi_pci_osc_control_set);
  
++<<<<<<< HEAD
++=======
+ static void negotiate_os_control(struct acpi_pci_root *root, int *no_aspm,
+ 				 int *clear_aspm)
+ {
+ 	u32 support, control;
+ 	acpi_status status;
+ 	struct acpi_device *device = root->device;
+ 	acpi_handle handle = device->handle;
+ 
+ 	/*
+ 	 * All supported architectures that use ACPI have support for
+ 	 * PCI domains, so we indicate this in _OSC support capabilities.
+ 	 */
+ 	support = OSC_PCI_SEGMENT_GROUPS_SUPPORT;
+ 	if (pci_ext_cfg_avail())
+ 		support |= OSC_PCI_EXT_CONFIG_SUPPORT;
+ 	if (pcie_aspm_support_enabled())
+ 		support |= OSC_PCI_ASPM_SUPPORT | OSC_PCI_CLOCK_PM_SUPPORT;
+ 	if (pci_msi_enabled())
+ 		support |= OSC_PCI_MSI_SUPPORT;
+ 	status = acpi_pci_osc_support(root, support);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_info(&device->dev, "_OSC failed (%s); disabling ASPM\n",
+ 			 acpi_format_exception(status));
+ 		*no_aspm = 1;
+ 		return;
+ 	}
+ 
+ 	if (pcie_ports_disabled) {
+ 		dev_info(&device->dev, "PCIe port services disabled; not requesting _OSC control\n");
+ 		return;
+ 	}
+ 
+ 	if ((support & ACPI_PCIE_REQ_SUPPORT) != ACPI_PCIE_REQ_SUPPORT) {
+ 		dev_info(&device->dev, "Not requesting _OSC control (we support %#02x but %#02x are required)\n",
+ 			 support, ACPI_PCIE_REQ_SUPPORT);
+ 		return;
+ 	}
+ 
+ 	control = OSC_PCI_EXPRESS_CAPABILITY_CONTROL
+ 		| OSC_PCI_EXPRESS_NATIVE_HP_CONTROL
+ 		| OSC_PCI_EXPRESS_PME_CONTROL;
+ 
+ 	if (pci_aer_available()) {
+ 		if (aer_acpi_firmware_first())
+ 			dev_dbg(&device->dev,
+ 				"PCIe errors handled by BIOS.\n");
+ 		else
+ 			control |= OSC_PCI_EXPRESS_AER_CONTROL;
+ 	}
+ 
+ 	dev_info(&device->dev,
+ 		 "Requesting ACPI _OSC control (0x%02x)\n", control);
+ 
+ 	status = acpi_pci_osc_control_set(handle, &control,
+ 					  OSC_PCI_EXPRESS_CAPABILITY_CONTROL);
+ 	if (ACPI_SUCCESS(status)) {
+ 		dev_info(&device->dev,
+ 			 "ACPI _OSC control (0x%02x) granted\n",
+ 			 control);
+ 		if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {
+ 			/*
+ 			 * We have ASPM control, but the FADT indicates
+ 			 * that it's unsupported. Clear it.
+ 			 */
+ 			*clear_aspm = 1;
+ 		}
+ 	} else {
+ 		dev_info(&device->dev,
+ 			"ACPI _OSC request failed (%s), "
+ 			"returned control mask: 0x%02x\n",
+ 			acpi_format_exception(status), control);
+ 		dev_info(&device->dev,
+ 			 "ACPI _OSC control for PCIe not granted, disabling ASPM\n");
+ 		/*
+ 		 * We want to disable ASPM here, but aspm_disabled
+ 		 * needs to remain in its state from boot so that we
+ 		 * properly handle PCIe 1.1 devices.  So we set this
+ 		 * flag here, to defer the action until after the ACPI
+ 		 * root scan.
+ 		 */
+ 		*no_aspm = 1;
+ 	}
+ }
+ 
++>>>>>>> de18966228ed (PCI/ACPI: Separate out _OSC "we don't support enough services" path)
  static int acpi_pci_root_add(struct acpi_device *device,
  			     const struct acpi_device_id *not_used)
  {
* Unmerged path drivers/acpi/pci_root.c
