be2net: use GET_MAC_LIST cmd to query mac-address from a pmac-id

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Suresh Reddy <suresh.reddy@emulex.com>
commit b188f0907aa82ca1bee917e4a263c2f29a0895de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/b188f090.failed

The use of NTKW_MAC_QUERY cmd has been deprecated for Skyhawk-R.
Replace the last remaining usage in be_vfs_mac_query() routine.

	Signed-off-by: Suresh Reddy <suresh.reddy@emulex.com>
	Signed-off-by: Sathya Perla <sathya.perla@emulex.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b188f0907aa82ca1bee917e4a263c2f29a0895de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be_cmds.h
diff --cc drivers/net/ethernet/emulex/benet/be_cmds.h
index 3e476a230a4b,fc4e076dc202..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_cmds.h
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.h
@@@ -1957,130 -1971,117 +1957,225 @@@ struct be_cmd_resp_get_iface_list 
  	struct be_if_desc if_desc;
  };
  
++<<<<<<< HEAD
 +extern int be_pci_fnum_get(struct be_adapter *adapter);
 +extern int be_fw_wait_ready(struct be_adapter *adapter);
 +extern int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
 +				 bool permanent, u32 if_handle, u32 pmac_id);
 +extern int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,
 +			u32 if_id, u32 *pmac_id, u32 domain);
 +extern int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id,
 +			int pmac_id, u32 domain);
 +extern int be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags,
 +			    u32 en_flags, u32 *if_handle, u32 domain);
 +extern int be_cmd_if_destroy(struct be_adapter *adapter, int if_handle,
++=======
+ int be_pci_fnum_get(struct be_adapter *adapter);
+ int be_fw_wait_ready(struct be_adapter *adapter);
+ int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
+ 			  bool permanent, u32 if_handle, u32 pmac_id);
+ int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr, u32 if_id,
+ 		    u32 *pmac_id, u32 domain);
+ int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id, int pmac_id,
+ 		    u32 domain);
+ int be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags, u32 en_flags,
+ 		     u32 *if_handle, u32 domain);
+ int be_cmd_if_destroy(struct be_adapter *adapter, int if_handle, u32 domain);
+ int be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo);
+ int be_cmd_cq_create(struct be_adapter *adapter, struct be_queue_info *cq,
+ 		     struct be_queue_info *eq, bool no_delay,
+ 		     int num_cqe_dma_coalesce);
+ int be_cmd_mccq_create(struct be_adapter *adapter, struct be_queue_info *mccq,
+ 		       struct be_queue_info *cq);
+ int be_cmd_txq_create(struct be_adapter *adapter, struct be_tx_obj *txo);
+ int be_cmd_rxq_create(struct be_adapter *adapter, struct be_queue_info *rxq,
+ 		      u16 cq_id, u16 frag_size, u32 if_id, u32 rss, u8 *rss_id);
+ int be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,
+ 		     int type);
+ int be_cmd_rxq_destroy(struct be_adapter *adapter, struct be_queue_info *q);
+ int be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,
+ 			     u8 *link_status, u32 dom);
+ int be_cmd_reset(struct be_adapter *adapter);
+ int be_cmd_get_stats(struct be_adapter *adapter, struct be_dma_mem *nonemb_cmd);
+ int lancer_cmd_get_pport_stats(struct be_adapter *adapter,
+ 			       struct be_dma_mem *nonemb_cmd);
+ int be_cmd_get_fw_ver(struct be_adapter *adapter, char *fw_ver,
+ 		      char *fw_on_flash);
+ int be_cmd_modify_eqd(struct be_adapter *adapter, struct be_set_eqd *, int num);
+ int be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id, u16 *vtag_array,
+ 		       u32 num, bool promiscuous);
+ int be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 status);
+ int be_cmd_set_flow_control(struct be_adapter *adapter, u32 tx_fc, u32 rx_fc);
+ int be_cmd_get_flow_control(struct be_adapter *adapter, u32 *tx_fc, u32 *rx_fc);
+ int be_cmd_query_fw_cfg(struct be_adapter *adapter, u32 *port_num,
+ 			u32 *function_mode, u32 *function_caps, u16 *asic_rev);
+ int be_cmd_reset_function(struct be_adapter *adapter);
+ int be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,
+ 		      u32 rss_hash_opts, u16 table_size);
+ int be_process_mcc(struct be_adapter *adapter);
+ int be_cmd_set_beacon_state(struct be_adapter *adapter, u8 port_num, u8 beacon,
+ 			    u8 status, u8 state);
+ int be_cmd_get_beacon_state(struct be_adapter *adapter, u8 port_num,
+ 			    u32 *state);
+ int be_cmd_write_flashrom(struct be_adapter *adapter, struct be_dma_mem *cmd,
+ 			  u32 flash_oper, u32 flash_opcode, u32 buf_size);
+ int lancer_cmd_write_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
+ 			    u32 data_size, u32 data_offset,
+ 			    const char *obj_name, u32 *data_written,
+ 			    u8 *change_status, u8 *addn_status);
+ int lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
+ 			   u32 data_size, u32 data_offset, const char *obj_name,
+ 			   u32 *data_read, u32 *eof, u8 *addn_status);
+ int be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,
+ 			 int offset);
+ int be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,
+ 			    struct be_dma_mem *nonemb_cmd);
+ int be_cmd_fw_init(struct be_adapter *adapter);
+ int be_cmd_fw_clean(struct be_adapter *adapter);
+ void be_async_mcc_enable(struct be_adapter *adapter);
+ void be_async_mcc_disable(struct be_adapter *adapter);
+ int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,
+ 			 u32 loopback_type, u32 pkt_size, u32 num_pkts,
+ 			 u64 pattern);
+ int be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern, u32 byte_cnt,
+ 			struct be_dma_mem *cmd);
+ int be_cmd_get_seeprom_data(struct be_adapter *adapter,
+ 			    struct be_dma_mem *nonemb_cmd);
+ int be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,
+ 			u8 loopback_type, u8 enable);
+ int be_cmd_get_phy_info(struct be_adapter *adapter);
+ int be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain);
+ void be_detect_error(struct be_adapter *adapter);
+ int be_cmd_get_die_temperature(struct be_adapter *adapter);
+ int be_cmd_get_cntl_attributes(struct be_adapter *adapter);
+ int be_cmd_req_native_mode(struct be_adapter *adapter);
+ int be_cmd_get_reg_len(struct be_adapter *adapter, u32 *log_size);
+ void be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf);
+ int be_cmd_get_fn_privileges(struct be_adapter *adapter, u32 *privilege,
+ 			     u32 domain);
+ int be_cmd_set_fn_privileges(struct be_adapter *adapter, u32 privileges,
+ 			     u32 vf_num);
+ int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
+ 			     bool *pmac_id_active, u32 *pmac_id,
+ 			     u32 if_handle, u8 domain);
+ int be_cmd_get_active_mac(struct be_adapter *adapter, u32 pmac_id, u8 *mac,
+ 			  u32 if_handle, bool active, u32 domain);
+ int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac);
+ int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array, u8 mac_count,
++>>>>>>> b188f0907aa8 (be2net: use GET_MAC_LIST cmd to query mac-address from a pmac-id)
  			u32 domain);
 -int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id, u32 dom);
 -int be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid, u32 domain,
 -			  u16 intf_id, u16 hsw_mode);
 -int be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid, u32 domain,
 -			  u16 intf_id, u8 *mode);
 -int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter);
 -int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level);
 -int be_cmd_get_fw_log_level(struct be_adapter *adapter);
 -int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
 -				   struct be_dma_mem *cmd);
 -int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,
 +extern int be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo);
 +extern int be_cmd_cq_create(struct be_adapter *adapter,
 +			struct be_queue_info *cq, struct be_queue_info *eq,
 +			bool no_delay, int num_cqe_dma_coalesce);
 +extern int be_cmd_mccq_create(struct be_adapter *adapter,
 +			struct be_queue_info *mccq,
 +			struct be_queue_info *cq);
 +extern int be_cmd_txq_create(struct be_adapter *adapter,
 +			struct be_tx_obj *txo);
 +extern int be_cmd_rxq_create(struct be_adapter *adapter,
 +			struct be_queue_info *rxq, u16 cq_id,
 +			u16 frag_size, u32 if_id, u32 rss, u8 *rss_id);
 +extern int be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,
 +			int type);
 +extern int be_cmd_rxq_destroy(struct be_adapter *adapter,
 +			struct be_queue_info *q);
 +extern int be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,
 +				    u8 *link_status, u32 dom);
 +extern int be_cmd_reset(struct be_adapter *adapter);
 +extern int be_cmd_get_stats(struct be_adapter *adapter,
 +			struct be_dma_mem *nonemb_cmd);
 +extern int lancer_cmd_get_pport_stats(struct be_adapter *adapter,
 +			struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_get_fw_ver(struct be_adapter *adapter, char *fw_ver,
 +		char *fw_on_flash);
 +
 +extern int be_cmd_modify_eqd(struct be_adapter *adapter, u32 eq_id, u32 eqd);
 +extern int be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id,
 +			u16 *vtag_array, u32 num, bool untagged,
 +			bool promiscuous);
 +extern int be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 status);
 +extern int be_cmd_set_flow_control(struct be_adapter *adapter,
 +			u32 tx_fc, u32 rx_fc);
 +extern int be_cmd_get_flow_control(struct be_adapter *adapter,
 +			u32 *tx_fc, u32 *rx_fc);
 +extern int be_cmd_query_fw_cfg(struct be_adapter *adapter, u32 *port_num,
 +			u32 *function_mode, u32 *function_caps, u16 *asic_rev);
 +extern int be_cmd_reset_function(struct be_adapter *adapter);
 +extern int be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,
 +			     u32 rss_hash_opts, u16 table_size);
 +extern int be_process_mcc(struct be_adapter *adapter);
 +extern int be_cmd_set_beacon_state(struct be_adapter *adapter,
 +			u8 port_num, u8 beacon, u8 status, u8 state);
 +extern int be_cmd_get_beacon_state(struct be_adapter *adapter,
 +			u8 port_num, u32 *state);
 +extern int be_cmd_write_flashrom(struct be_adapter *adapter,
 +			struct be_dma_mem *cmd, u32 flash_oper,
 +			u32 flash_opcode, u32 buf_size);
 +extern int lancer_cmd_write_object(struct be_adapter *adapter,
  				   struct be_dma_mem *cmd,
 -				   struct be_fat_conf_params *cfgs);
 -int lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask);
 -int lancer_initiate_dump(struct be_adapter *adapter);
 -bool dump_present(struct be_adapter *adapter);
 -int lancer_test_and_set_rdy_state(struct be_adapter *adapter);
 -int be_cmd_query_port_name(struct be_adapter *adapter, u8 *port_name);
 +				   u32 data_size, u32 data_offset,
 +				   const char *obj_name,
 +				   u32 *data_written, u8 *change_status,
 +				   u8 *addn_status);
 +int lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
 +		u32 data_size, u32 data_offset, const char *obj_name,
 +		u32 *data_read, u32 *eof, u8 *addn_status);
 +int be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,
 +				int offset);
 +extern int be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,
 +				struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_fw_init(struct be_adapter *adapter);
 +extern int be_cmd_fw_clean(struct be_adapter *adapter);
 +extern void be_async_mcc_enable(struct be_adapter *adapter);
 +extern void be_async_mcc_disable(struct be_adapter *adapter);
 +extern int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,
 +				u32 loopback_type, u32 pkt_size,
 +				u32 num_pkts, u64 pattern);
 +extern int be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern,
 +			u32 byte_cnt, struct be_dma_mem *cmd);
 +extern int be_cmd_get_seeprom_data(struct be_adapter *adapter,
 +				struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,
 +				u8 loopback_type, u8 enable);
 +extern int be_cmd_get_phy_info(struct be_adapter *adapter);
 +extern int be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain);
 +extern void be_detect_error(struct be_adapter *adapter);
 +extern int be_cmd_get_die_temperature(struct be_adapter *adapter);
 +extern int be_cmd_get_cntl_attributes(struct be_adapter *adapter);
 +extern int be_cmd_req_native_mode(struct be_adapter *adapter);
 +extern int be_cmd_get_reg_len(struct be_adapter *adapter, u32 *log_size);
 +extern void be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf);
 +extern int be_cmd_get_fn_privileges(struct be_adapter *adapter,
 +				    u32 *privilege, u32 domain);
 +extern int be_cmd_set_fn_privileges(struct be_adapter *adapter,
 +				    u32 privileges, u32 vf_num);
 +extern int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
 +				    bool *pmac_id_active, u32 *pmac_id,
 +				    u8 domain);
 +extern int be_cmd_get_active_mac(struct be_adapter *adapter, u32 pmac_id,
 +				 u8 *mac);
 +extern int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac);
 +extern int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,
 +						u8 mac_count, u32 domain);
 +extern int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id,
 +			  u32 dom);
 +extern int be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid,
 +				 u32 domain, u16 intf_id, u16 hsw_mode);
 +extern int be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid,
 +				 u32 domain, u16 intf_id, u8 *mode);
 +extern int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter);
 +extern int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
 +					  struct be_dma_mem *cmd);
 +extern int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,
 +					  struct be_dma_mem *cmd,
 +					  struct be_fat_conf_params *cfgs);
 +extern int lancer_wait_ready(struct be_adapter *adapter);
 +extern int lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask);
 +extern int lancer_initiate_dump(struct be_adapter *adapter);
 +extern bool dump_present(struct be_adapter *adapter);
 +extern int lancer_test_and_set_rdy_state(struct be_adapter *adapter);
 +extern int be_cmd_query_port_name(struct be_adapter *adapter, u8 *port_name);
  int be_cmd_get_func_config(struct be_adapter *adapter,
  			   struct be_resources *res);
  int be_cmd_get_profile_config(struct be_adapter *adapter,
diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c
index 138b2a691be6..a54b6e03331f 100644
--- a/drivers/net/ethernet/emulex/benet/be_cmds.c
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c
@@ -2727,7 +2727,8 @@ err:
  *		  If pmac_id is returned, pmac_id_valid is returned as true
  */
 int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
-			     bool *pmac_id_valid, u32 *pmac_id, u8 domain)
+			     bool *pmac_id_valid, u32 *pmac_id, u32 if_handle,
+			     u8 domain)
 {
 	struct be_mcc_wrb *wrb;
 	struct be_cmd_req_get_mac_list *req;
@@ -2765,7 +2766,7 @@ int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
 	req->mac_type = MAC_ADDRESS_TYPE_NETWORK;
 	if (*pmac_id_valid) {
 		req->mac_id = cpu_to_le32(*pmac_id);
-		req->iface_id = cpu_to_le16(adapter->if_handle);
+		req->iface_id = cpu_to_le16(if_handle);
 		req->perm_override = 0;
 	} else {
 		req->perm_override = 1;
@@ -2818,17 +2819,21 @@ out:
 	return status;
 }
 
-int be_cmd_get_active_mac(struct be_adapter *adapter, u32 curr_pmac_id, u8 *mac)
+int be_cmd_get_active_mac(struct be_adapter *adapter, u32 curr_pmac_id, u8 *mac,
+			  u32 if_handle, bool active, u32 domain)
 {
-	bool active = true;
 
+	if (!active)
+		be_cmd_get_mac_from_list(adapter, mac, &active, &curr_pmac_id,
+					 if_handle, domain);
 	if (BEx_chip(adapter))
 		return be_cmd_mac_addr_query(adapter, mac, false,
-					     adapter->if_handle, curr_pmac_id);
+					     if_handle, curr_pmac_id);
 	else
 		/* Fetch the MAC address using pmac_id */
 		return be_cmd_get_mac_from_list(adapter, mac, &active,
-						&curr_pmac_id, 0);
+						&curr_pmac_id,
+						if_handle, domain);
 }
 
 int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac)
@@ -2847,7 +2852,7 @@ int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac)
 						       adapter->if_handle, 0);
 	} else {
 		status = be_cmd_get_mac_from_list(adapter, mac, &pmac_valid,
-						  NULL, 0);
+						  NULL, adapter->if_handle, 0);
 	}
 
 	return status;
@@ -2908,7 +2913,8 @@ int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id, u32 dom)
 	int status;
 
 	status = be_cmd_get_mac_from_list(adapter, old_mac, &active_mac,
-					  &pmac_id, dom);
+					  &pmac_id, if_id, dom);
+
 	if (!status && active_mac)
 		be_cmd_pmac_del(adapter, if_id, pmac_id, dom);
 
* Unmerged path drivers/net/ethernet/emulex/benet/be_cmds.h
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index b0663a6b2cc5..38ce432a4849 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -279,7 +279,8 @@ static int be_mac_addr_set(struct net_device *netdev, void *p)
 	/* Decide if the new MAC is successfully activated only after
 	 * querying the FW
 	 */
-	status = be_cmd_get_active_mac(adapter, curr_pmac_id, mac);
+	status = be_cmd_get_active_mac(adapter, curr_pmac_id, mac,
+				       adapter->if_handle, true, 0);
 	if (status)
 		goto err;
 
@@ -2797,14 +2798,11 @@ static int be_vfs_mac_query(struct be_adapter *adapter)
 	int status, vf;
 	u8 mac[ETH_ALEN];
 	struct be_vf_cfg *vf_cfg;
-	bool active = false;
 
 	for_all_vfs(adapter, vf_cfg, vf) {
-		be_cmd_get_mac_from_list(adapter, mac, &active,
-					 &vf_cfg->pmac_id, 0);
-
-		status = be_cmd_mac_addr_query(adapter, mac, false,
-					       vf_cfg->if_handle, 0);
+		status = be_cmd_get_active_mac(adapter, vf_cfg->pmac_id,
+					       mac, vf_cfg->if_handle,
+					       false, vf+1);
 		if (status)
 			return status;
 		memcpy(vf_cfg->mac_addr, mac, ETH_ALEN);
