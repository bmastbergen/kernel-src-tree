GFS2: Fix use-after-free race when calling gfs2_remove_from_ail

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 9290a9a7c0bcf5400e8dbfbf9707fa68ea3fb338
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/9290a9a7.failed

Function gfs2_remove_from_ail drops the reference on the bh via
brelse. This patch fixes a race condition whereby bh is deferenced
after the brelse when setting bd->bd_blkno = bh->b_blocknr;
Under certain rare circumstances, bh might be gone or reused,
and bd->bd_blkno is set to whatever that memory happens to be,
which is often 0. Later, in gfs2_trans_add_unrevoke, that bd fails
the test "bd->bd_blkno >= blkno" which causes it to never be freed.
The end result is that the bd is never freed from the bufdata cache,
which results in this error:
slab error in kmem_cache_destroy(): cache `gfs2_bufdata': Can't free all objects

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
(cherry picked from commit 9290a9a7c0bcf5400e8dbfbf9707fa68ea3fb338)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
diff --cc fs/gfs2/log.c
index b404f4853034,9dcb9777a5f8..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -545,6 -546,76 +545,79 @@@ void gfs2_ordered_del_inode(struct gfs2
  	spin_unlock(&sdp->sd_ordered_lock);
  }
  
++<<<<<<< HEAD
++=======
+ void gfs2_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
+ {
+ 	struct buffer_head *bh = bd->bd_bh;
+ 	struct gfs2_glock *gl = bd->bd_gl;
+ 
+ 	bh->b_private = NULL;
+ 	bd->bd_blkno = bh->b_blocknr;
+ 	gfs2_remove_from_ail(bd); /* drops ref on bh */
+ 	bd->bd_bh = NULL;
+ 	bd->bd_ops = &gfs2_revoke_lops;
+ 	sdp->sd_log_num_revoke++;
+ 	atomic_inc(&gl->gl_revokes);
+ 	set_bit(GLF_LFLUSH, &gl->gl_flags);
+ 	list_add(&bd->bd_list, &sdp->sd_log_le_revoke);
+ }
+ 
+ void gfs2_write_revokes(struct gfs2_sbd *sdp)
+ {
+ 	struct gfs2_trans *tr;
+ 	struct gfs2_bufdata *bd, *tmp;
+ 	int have_revokes = 0;
+ 	int max_revokes = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / sizeof(u64);
+ 
+ 	gfs2_ail1_empty(sdp);
+ 	spin_lock(&sdp->sd_ail_lock);
+ 	list_for_each_entry(tr, &sdp->sd_ail1_list, tr_list) {
+ 		list_for_each_entry(bd, &tr->tr_ail2_list, bd_ail_st_list) {
+ 			if (list_empty(&bd->bd_list)) {
+ 				have_revokes = 1;
+ 				goto done;
+ 			}
+ 		}
+ 	}
+ done:
+ 	spin_unlock(&sdp->sd_ail_lock);
+ 	if (have_revokes == 0)
+ 		return;
+ 	while (sdp->sd_log_num_revoke > max_revokes)
+ 		max_revokes += (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header)) / sizeof(u64);
+ 	max_revokes -= sdp->sd_log_num_revoke;
+ 	if (!sdp->sd_log_num_revoke) {
+ 		atomic_dec(&sdp->sd_log_blks_free);
+ 		/* If no blocks have been reserved, we need to also
+ 		 * reserve a block for the header */
+ 		if (!sdp->sd_log_blks_reserved)
+ 			atomic_dec(&sdp->sd_log_blks_free);
+ 	}
+ 	gfs2_log_lock(sdp);
+ 	spin_lock(&sdp->sd_ail_lock);
+ 	list_for_each_entry(tr, &sdp->sd_ail1_list, tr_list) {
+ 		list_for_each_entry_safe(bd, tmp, &tr->tr_ail2_list, bd_ail_st_list) {
+ 			if (max_revokes == 0)
+ 				goto out_of_blocks;
+ 			if (!list_empty(&bd->bd_list))
+ 				continue;
+ 			gfs2_add_revoke(sdp, bd);
+ 			max_revokes--;
+ 		}
+ 	}
+ out_of_blocks:
+ 	spin_unlock(&sdp->sd_ail_lock);
+ 	gfs2_log_unlock(sdp);
+ 
+ 	if (!sdp->sd_log_num_revoke) {
+ 		atomic_inc(&sdp->sd_log_blks_free);
+ 		if (!sdp->sd_log_blks_reserved)
+ 			atomic_inc(&sdp->sd_log_blks_free);
+ 	}
+ }
+ 
++>>>>>>> 9290a9a7c0bc (GFS2: Fix use-after-free race when calling gfs2_remove_from_ail)
  /**
   * log_write_header - Get and initialize a journal header buffer
   * @sdp: The GFS2 superblock
* Unmerged path fs/gfs2/log.c
