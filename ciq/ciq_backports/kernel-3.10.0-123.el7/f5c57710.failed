powerpc/eeh: Use partial hotplug for EEH unaware drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [powerpc] eeh: Use partial hotplug for EEH unaware drivers (Steve Best) [1033086]
Rebuild_FUZZ: 92.31%
commit-author Gavin Shan <shangw@linux.vnet.ibm.com>
commit f5c57710dd62dd06f176934a8b4b8accbf00f9f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/f5c57710.failed

When EEH error happens to one specific PE, some devices with drivers
supporting EEH won't except hotplug on the device. However, there
might have other deivces without driver, or with driver without EEH
support. For the case, we need do partial hotplug in order to make
sure that the PE becomes absolutely quite during reset. Otherise,
the PE reset might fail and leads to failure of error recovery.

The current code doesn't handle that 'mixed' case properly, it either
uses the error callbacks to the drivers, or tries hotplug, but doesn't
handle a PE (EEH domain) composed of a combination of the two.

The patch intends to support so-called "partial" hotplug for EEH:
Before we do reset, we stop and remove those PCI devices without
EEH sensitive driver. The corresponding EEH devices are not detached
from its PE, but with special flag. After the reset is done, those
EEH devices with the special flag will be scanned one by one.

	Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit f5c57710dd62dd06f176934a8b4b8accbf00f9f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh.c
#	arch/powerpc/kernel/eeh_driver.c
#	arch/powerpc/platforms/powernv/eeh-powernv.c
diff --cc arch/powerpc/kernel/eeh.c
index 16c2bbaf5883,a5783f1a7a96..000000000000
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@@ -967,10 -1000,20 +981,24 @@@ static void eeh_remove_device(struct pc
  		pr_debug("EEH: Not referenced !\n");
  		return;
  	}
+ 
+ 	/*
+ 	 * During the hotplug for EEH error recovery, we need the EEH
+ 	 * device attached to the parent PE in order for BAR restore
+ 	 * a bit later. So we keep it for BAR restore and remove it
+ 	 * from the parent PE during the BAR resotre.
+ 	 */
  	edev->pdev = NULL;
  	dev->dev.archdata.edev = NULL;
+ 	if (!(edev->pe->state & EEH_PE_KEEP))
+ 		eeh_rmv_from_parent_pe(edev);
+ 	else
+ 		edev->mode |= EEH_DEV_DISCONNECTED;
  
++<<<<<<< HEAD
 +	eeh_rmv_from_parent_pe(edev, purge_pe);
++=======
++>>>>>>> f5c57710dd62 (powerpc/eeh: Use partial hotplug for EEH unaware drivers)
  	eeh_addr_cache_rmv_dev(dev);
  	eeh_sysfs_remove_device(dev);
  }
diff --cc arch/powerpc/kernel/eeh_driver.c
index 7491ac9e984c,9fda75d1f5aa..000000000000
--- a/arch/powerpc/kernel/eeh_driver.c
+++ b/arch/powerpc/kernel/eeh_driver.c
@@@ -362,8 -411,11 +411,16 @@@ static int eeh_reset_device(struct eeh_
  	 * devices are expected to be attached soon when calling
  	 * into pcibios_add_pci_devices().
  	 */
++<<<<<<< HEAD
 +	if (bus)
 +		__pcibios_remove_pci_devices(bus, 0);
++=======
+ 	eeh_pe_state_mark(pe, EEH_PE_KEEP);
+ 	if (bus)
+ 		pcibios_remove_pci_devices(bus);
+ 	else if (frozen_bus)
+ 		eeh_pe_dev_traverse(pe, eeh_rmv_device, &removed);
++>>>>>>> f5c57710dd62 (powerpc/eeh: Use partial hotplug for EEH unaware drivers)
  
  	/* Reset the pci controller. (Asserts RST#; resets config space).
  	 * Reconfigure bridges and devices. Don't try to bring the system
@@@ -384,9 -436,24 +441,27 @@@
  	 * potentially weird things happen.
  	 */
  	if (bus) {
+ 		pr_info("EEH: Sleep 5s ahead of complete hotplug\n");
  		ssleep(5);
+ 
+ 		/*
+ 		 * The EEH device is still connected with its parent
+ 		 * PE. We should disconnect it so the binding can be
+ 		 * rebuilt when adding PCI devices.
+ 		 */
+ 		eeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);
  		pcibios_add_pci_devices(bus);
++<<<<<<< HEAD
++=======
+ 	} else if (frozen_bus && removed) {
+ 		pr_info("EEH: Sleep 5s ahead of partial hotplug\n");
+ 		ssleep(5);
+ 
+ 		eeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);
+ 		pcibios_add_pci_devices(frozen_bus);
++>>>>>>> f5c57710dd62 (powerpc/eeh: Use partial hotplug for EEH unaware drivers)
  	}
+ 	eeh_pe_state_clear(pe, EEH_PE_KEEP);
  
  	pe->tstamp = tstamp;
  	pe->freeze_count = cnt;
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
diff --git a/arch/powerpc/include/asm/eeh.h b/arch/powerpc/include/asm/eeh.h
index f2d19467c123..989628a26a43 100644
--- a/arch/powerpc/include/asm/eeh.h
+++ b/arch/powerpc/include/asm/eeh.h
@@ -81,7 +81,8 @@ struct eeh_pe {
  * another tree except the currently existing tree of PCI
  * buses and PCI devices
  */
-#define EEH_DEV_IRQ_DISABLED	(1<<0)	/* Interrupt disabled		*/
+#define EEH_DEV_IRQ_DISABLED	(1 << 0)	/* Interrupt disabled	*/
+#define EEH_DEV_DISCONNECTED	(1 << 1)	/* Removing from PE	*/
 
 struct eeh_dev {
 	int mode;			/* EEH mode			*/
@@ -94,6 +95,7 @@ struct eeh_dev {
 	struct pci_controller *phb;	/* Associated PHB		*/
 	struct device_node *dn;		/* Associated device node	*/
 	struct pci_dev *pdev;		/* Associated PCI device	*/
+	struct pci_bus *bus;		/* PCI bus for partial hotplug	*/
 };
 
 static inline struct device_node *eeh_dev_to_of_node(struct eeh_dev *edev)
@@ -205,6 +207,8 @@ struct eeh_pe *eeh_pe_get(struct eeh_dev *edev);
 int eeh_add_to_parent_pe(struct eeh_dev *edev);
 int eeh_rmv_from_parent_pe(struct eeh_dev *edev, int purge_pe);
 void eeh_pe_update_time_stamp(struct eeh_pe *pe);
+void *eeh_pe_traverse(struct eeh_pe *root,
+		eeh_traverse_func fn, void *flag);
 void *eeh_pe_dev_traverse(struct eeh_pe *root,
 		eeh_traverse_func fn, void *flag);
 void eeh_pe_restore_bars(struct eeh_pe *pe);
* Unmerged path arch/powerpc/kernel/eeh.c
* Unmerged path arch/powerpc/kernel/eeh_driver.c
diff --git a/arch/powerpc/kernel/eeh_pe.c b/arch/powerpc/kernel/eeh_pe.c
index 6ab3eb589ca3..1e36eeb5afd2 100644
--- a/arch/powerpc/kernel/eeh_pe.c
+++ b/arch/powerpc/kernel/eeh_pe.c
@@ -151,8 +151,8 @@ static struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,
  * callback returns something other than NULL, or no more PEs
  * to be traversed.
  */
-static void *eeh_pe_traverse(struct eeh_pe *root,
-			eeh_traverse_func fn, void *flag)
+void *eeh_pe_traverse(struct eeh_pe *root,
+		      eeh_traverse_func fn, void *flag)
 {
 	struct eeh_pe *pe;
 	void *ret;
@@ -415,8 +415,8 @@ int eeh_rmv_from_parent_pe(struct eeh_dev *edev, int purge_pe)
 	int cnt;
 
 	if (!edev->pe) {
-		pr_warning("%s: No PE found for EEH device %s\n",
-			__func__, edev->dn->full_name);
+		pr_debug("%s: No PE found for EEH device %s\n",
+			 __func__, edev->dn->full_name);
 		return -EEXIST;
 	}
 
@@ -742,18 +742,12 @@ static void eeh_restore_device_bars(struct eeh_dev *edev,
  */
 static void *eeh_restore_one_device_bars(void *data, void *flag)
 {
-	struct pci_dev *pdev = NULL;
 	struct eeh_dev *edev = (struct eeh_dev *)data;
+	struct pci_dev *pdev = eeh_dev_to_pci_dev(edev);
 	struct device_node *dn = eeh_dev_to_of_node(edev);
 
-	/* Trace the PCI bridge */
-	if (eeh_probe_mode_dev()) {
-		pdev = eeh_dev_to_pci_dev(edev);
-		if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE)
-                        pdev = NULL;
-        }
-
-	if (pdev)
+	/* Do special restore for bridges */
+	if (pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
 		eeh_restore_bridge_bars(pdev, edev, dn);
 	else
 		eeh_restore_device_bars(edev, dn);
diff --git a/arch/powerpc/kernel/eeh_sysfs.c b/arch/powerpc/kernel/eeh_sysfs.c
index e7ae3484918c..61e2a1452131 100644
--- a/arch/powerpc/kernel/eeh_sysfs.c
+++ b/arch/powerpc/kernel/eeh_sysfs.c
@@ -68,6 +68,13 @@ void eeh_sysfs_add_device(struct pci_dev *pdev)
 
 void eeh_sysfs_remove_device(struct pci_dev *pdev)
 {
+	/*
+	 * The parent directory might have been removed. We needn't
+	 * continue for that case.
+	 */
+	if (!pdev->dev.kobj.sd)
+		return;
+
 	device_remove_file(&pdev->dev, &dev_attr_eeh_mode);
 	device_remove_file(&pdev->dev, &dev_attr_eeh_config_addr);
 	device_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
diff --git a/arch/powerpc/platforms/pseries/eeh_pseries.c b/arch/powerpc/platforms/pseries/eeh_pseries.c
index b456b157d33d..0f44f9fe49ac 100644
--- a/arch/powerpc/platforms/pseries/eeh_pseries.c
+++ b/arch/powerpc/platforms/pseries/eeh_pseries.c
@@ -153,7 +153,7 @@ static void *pseries_eeh_of_probe(struct device_node *dn, void *flag)
 
 	/* Retrieve OF node and eeh device */
 	edev = of_node_to_eeh_dev(dn);
-	if (!of_device_is_available(dn))
+	if (edev->pe || !of_device_is_available(dn))
 		return NULL;
 
 	/* Retrieve class/vendor/device IDs */
