ALSA: hda - Fix possible races in HDMI driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [alsa] hda: Fix possible races in HDMI driver (Jaroslav Kysela) [1044022]
Rebuild_FUZZ: 89.16%
commit-author Takashi Iwai <tiwai@suse.de>
commit cbbaa603a03cc46681e24d6b2804b62fde95a2af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/cbbaa603.failed

Some per_pin fields and ELD contents might be changed dynamically in
multiple ways where the concurrent accesses are still opened in the
current code.  This patch fixes such possible races by using eld->lock
in appropriate places.

	Reported-by: Anssi Hannula <anssi.hannula@iki.fi>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit cbbaa603a03cc46681e24d6b2804b62fde95a2af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_hdmi.c
diff --cc sound/pci/hda/patch_hdmi.c
index cc259696a8da,c2bad9587d54..000000000000
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@@ -1358,8 -1391,15 +1358,7 @@@ static void hdmi_present_sense(struct h
  			       eld->eld_size);
  		pin_eld->eld_size = eld->eld_size;
  		pin_eld->info = eld->info;
 -
 -		/* Haswell-specific workaround: re-setup when the transcoder is
 -		 * changed during the stream playback
 -		 */
 -		if (is_haswell(codec) &&
 -		    eld->eld_valid && !old_eld_valid && per_pin->setup)
 -			hdmi_setup_audio_infoframe(codec, per_pin,
 -						   per_pin->non_pcm);
  	}
- 	mutex_unlock(&pin_eld->lock);
  
  	if (eld_changed)
  		snd_ctl_notify(codec->bus->card,
@@@ -1534,10 -1577,12 +1535,19 @@@ static int generic_hdmi_playback_pcm_pr
  	bool non_pcm;
  
  	non_pcm = check_non_pcm_per_cvt(codec, cvt_nid);
++<<<<<<< HEAD
 +
 +	hdmi_set_channel_count(codec, cvt_nid, substream->runtime->channels);
 +
 +	hdmi_setup_audio_infoframe(codec, pin_idx, non_pcm, substream);
++=======
+ 	mutex_lock(&per_pin->sink_eld.lock);
+ 	per_pin->channels = substream->runtime->channels;
+ 	per_pin->setup = true;
+ 
+ 	hdmi_setup_audio_infoframe(codec, per_pin, non_pcm);
+ 	mutex_unlock(&per_pin->sink_eld.lock);
++>>>>>>> cbbaa603a03c (ALSA: hda - Fix possible races in HDMI driver)
  
  	return hdmi_setup_stream(codec, cvt_nid, pin_nid, stream_tag, format);
  }
@@@ -1575,8 -1620,14 +1585,17 @@@ static int hdmi_pcm_close(struct hda_pc
  		per_pin = get_pin(spec, pin_idx);
  
  		snd_hda_spdif_ctls_unassign(codec, pin_idx);
+ 
+ 		mutex_lock(&per_pin->sink_eld.lock);
  		per_pin->chmap_set = false;
  		memset(per_pin->chmap, 0, sizeof(per_pin->chmap));
++<<<<<<< HEAD
++=======
+ 
+ 		per_pin->setup = false;
+ 		per_pin->channels = 0;
+ 		mutex_unlock(&per_pin->sink_eld.lock);
++>>>>>>> cbbaa603a03c (ALSA: hda - Fix possible races in HDMI driver)
  	}
  
  	return 0;
@@@ -1708,8 -1760,8 +1728,13 @@@ static int hdmi_chmap_ctl_put(struct sn
  	per_pin->chmap_set = true;
  	memcpy(per_pin->chmap, chmap, sizeof(chmap));
  	if (prepared)
++<<<<<<< HEAD
 +		hdmi_setup_audio_infoframe(codec, pin_idx, per_pin->non_pcm,
 +					   substream);
++=======
+ 		hdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);
+ 	mutex_unlock(&per_pin->sink_eld.lock);
++>>>>>>> cbbaa603a03c (ALSA: hda - Fix possible races in HDMI driver)
  
  	return 0;
  }
* Unmerged path sound/pci/hda/patch_hdmi.c
