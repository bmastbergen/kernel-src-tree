net: Export skb_zerocopy() to zerocopy from one skb to another

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] Export skb_zerocopy() to zerocopy from one skb to another (Francesco Fusco) [1057099]
Rebuild_FUZZ: 95.80%
commit-author Thomas Graf <tgraf@suug.ch>
commit af2806f8f90a150160be898cd85332459c83c5cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/af2806f8.failed

Make the skb zerocopy logic written for nfnetlink queue available for
use by other modules.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Reviewed-by: Daniel Borkmann <dborkman@redhat.com>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Jesse Gross <jesse@nicira.com>
(cherry picked from commit af2806f8f90a150160be898cd85332459c83c5cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/netfilter/nfnetlink_queue_core.c
diff --cc include/linux/skbuff.h
index 68e9d4dbcf3b,7c48e2d4c72b..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2334,56 -2316,73 +2334,95 @@@ static inline void skb_frag_add_head(st
  #define skb_walk_frags(skb, iter)	\
  	for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)
  
++<<<<<<< HEAD
 +extern struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
 +					   int *peeked, int *off, int *err);
 +extern struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags,
 +					 int noblock, int *err);
 +extern unsigned int    datagram_poll(struct file *file, struct socket *sock,
 +				     struct poll_table_struct *wait);
 +extern int	       skb_copy_datagram_iovec(const struct sk_buff *from,
 +					       int offset, struct iovec *to,
 +					       int size);
 +extern int	       skb_copy_and_csum_datagram_iovec(struct sk_buff *skb,
 +							int hlen,
 +							struct iovec *iov);
 +extern int	       skb_copy_datagram_from_iovec(struct sk_buff *skb,
 +						    int offset,
 +						    const struct iovec *from,
 +						    int from_offset,
 +						    int len);
 +extern int	       skb_copy_datagram_const_iovec(const struct sk_buff *from,
 +						     int offset,
 +						     const struct iovec *to,
 +						     int to_offset,
 +						     int size);
 +extern void	       skb_free_datagram(struct sock *sk, struct sk_buff *skb);
 +extern void	       skb_free_datagram_locked(struct sock *sk,
 +						struct sk_buff *skb);
 +extern int	       skb_kill_datagram(struct sock *sk, struct sk_buff *skb,
 +					 unsigned int flags);
 +extern __wsum	       skb_checksum(const struct sk_buff *skb, int offset,
 +				    int len, __wsum csum);
 +extern int	       skb_copy_bits(const struct sk_buff *skb, int offset,
 +				     void *to, int len);
 +extern int	       skb_store_bits(struct sk_buff *skb, int offset,
 +				      const void *from, int len);
 +extern __wsum	       skb_copy_and_csum_bits(const struct sk_buff *skb,
 +					      int offset, u8 *to, int len,
 +					      __wsum csum);
 +extern int             skb_splice_bits(struct sk_buff *skb,
 +						unsigned int offset,
 +						struct pipe_inode_info *pipe,
 +						unsigned int len,
 +						unsigned int flags);
 +extern void	       skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
 +extern void	       skb_split(struct sk_buff *skb,
 +				 struct sk_buff *skb1, const u32 len);
 +extern int	       skb_shift(struct sk_buff *tgt, struct sk_buff *skb,
 +				 int shiftlen);
 +extern void	       skb_scrub_packet(struct sk_buff *skb);
++=======
+ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
+ 				    int *peeked, int *off, int *err);
+ struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags, int noblock,
+ 				  int *err);
+ unsigned int datagram_poll(struct file *file, struct socket *sock,
+ 			   struct poll_table_struct *wait);
+ int skb_copy_datagram_iovec(const struct sk_buff *from, int offset,
+ 			    struct iovec *to, int size);
+ int skb_copy_and_csum_datagram_iovec(struct sk_buff *skb, int hlen,
+ 				     struct iovec *iov);
+ int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
+ 				 const struct iovec *from, int from_offset,
+ 				 int len);
+ int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *frm,
+ 			   int offset, size_t count);
+ int skb_copy_datagram_const_iovec(const struct sk_buff *from, int offset,
+ 				  const struct iovec *to, int to_offset,
+ 				  int size);
+ void skb_free_datagram(struct sock *sk, struct sk_buff *skb);
+ void skb_free_datagram_locked(struct sock *sk, struct sk_buff *skb);
+ int skb_kill_datagram(struct sock *sk, struct sk_buff *skb, unsigned int flags);
+ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len);
+ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len);
+ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset, u8 *to,
+ 			      int len, __wsum csum);
+ int skb_splice_bits(struct sk_buff *skb, unsigned int offset,
+ 		    struct pipe_inode_info *pipe, unsigned int len,
+ 		    unsigned int flags);
+ void skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
+ unsigned int skb_zerocopy_headlen(const struct sk_buff *from);
+ void skb_zerocopy(struct sk_buff *to, const struct sk_buff *from,
+ 		  int len, int hlen);
+ void skb_split(struct sk_buff *skb, struct sk_buff *skb1, const u32 len);
+ int skb_shift(struct sk_buff *tgt, struct sk_buff *skb, int shiftlen);
+ void skb_scrub_packet(struct sk_buff *skb, bool xnet);
+ struct sk_buff *skb_segment(struct sk_buff *skb, netdev_features_t features);
++>>>>>>> af2806f8f90a (net: Export skb_zerocopy() to zerocopy from one skb to another)
  
 -struct skb_checksum_ops {
 -	__wsum (*update)(const void *mem, int len, __wsum wsum);
 -	__wsum (*combine)(__wsum csum, __wsum csum2, int offset, int len);
 -};
 -
 -__wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
 -		      __wsum csum, const struct skb_checksum_ops *ops);
 -__wsum skb_checksum(const struct sk_buff *skb, int offset, int len,
 -		    __wsum csum);
 -
 -/**
 - *	pskb_trim_rcsum - trim received skb and update checksum
 - *	@skb: buffer to trim
 - *	@len: new length
 - *
 - *	This is exactly the same as pskb_trim except that it ensures the
 - *	checksum of received packets are still valid after the operation.
 - */
 -
 -static inline int pskb_trim_rcsum(struct sk_buff *skb, unsigned int len)
 -{
 -	if (likely(len >= skb->len))
 -		return 0;
 -	if (skb->ip_summed == CHECKSUM_COMPLETE) {
 -		__wsum adj = skb_checksum(skb, len, skb->len - len, 0);
 -
 -		skb->csum = csum_sub(skb->csum, adj);
 -	}
 -	return __pskb_trim(skb, len);
 -}
 +extern struct sk_buff *skb_segment(struct sk_buff *skb,
 +				   netdev_features_t features);
  
  static inline void *skb_header_pointer(const struct sk_buff *skb, int offset,
  				       int len, void *buffer)
diff --cc net/netfilter/nfnetlink_queue_core.c
index fbd7d76d053e,615ee12647ae..000000000000
--- a/net/netfilter/nfnetlink_queue_core.c
+++ b/net/netfilter/nfnetlink_queue_core.c
@@@ -345,18 -308,11 +300,23 @@@ nfqnl_build_packet_message(struct nfqnl
  			return NULL;
  
  		data_len = ACCESS_ONCE(queue->copy_range);
 -		if (data_len > entskb->len)
 +		if (data_len == 0 || data_len > entskb->len)
  			data_len = entskb->len;
  
++<<<<<<< HEAD
 +
 +		if (!entskb->head_frag ||
 +		    skb_headlen(entskb) < L1_CACHE_BYTES ||
 +		    skb_shinfo(entskb)->nr_frags >= MAX_SKB_FRAGS)
 +			hlen = skb_headlen(entskb);
 +
 +		if (skb_has_frag_list(entskb))
 +			hlen = entskb->len;
 +		hlen = min_t(int, data_len, hlen);
++=======
+ 		hlen = skb_zerocopy_headlen(entskb);
+ 		hlen = min_t(unsigned int, hlen, data_len);
++>>>>>>> af2806f8f90a (net: Export skb_zerocopy() to zerocopy from one skb to another)
  		size += sizeof(struct nlattr) + hlen;
  		cap_len = entskb->len;
  		break;
* Unmerged path include/linux/skbuff.h
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 297f9134ef13..76b0a349a332 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -2074,6 +2074,91 @@ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset,
 }
 EXPORT_SYMBOL(skb_copy_and_csum_bits);
 
+ /**
+ *	skb_zerocopy_headlen - Calculate headroom needed for skb_zerocopy()
+ *	@from: source buffer
+ *
+ *	Calculates the amount of linear headroom needed in the 'to' skb passed
+ *	into skb_zerocopy().
+ */
+unsigned int
+skb_zerocopy_headlen(const struct sk_buff *from)
+{
+	unsigned int hlen = 0;
+
+	if (!from->head_frag ||
+	    skb_headlen(from) < L1_CACHE_BYTES ||
+	    skb_shinfo(from)->nr_frags >= MAX_SKB_FRAGS)
+		hlen = skb_headlen(from);
+
+	if (skb_has_frag_list(from))
+		hlen = from->len;
+
+	return hlen;
+}
+EXPORT_SYMBOL_GPL(skb_zerocopy_headlen);
+
+/**
+ *	skb_zerocopy - Zero copy skb to skb
+ *	@to: destination buffer
+ *	@source: source buffer
+ *	@len: number of bytes to copy from source buffer
+ *	@hlen: size of linear headroom in destination buffer
+ *
+ *	Copies up to `len` bytes from `from` to `to` by creating references
+ *	to the frags in the source buffer.
+ *
+ *	The `hlen` as calculated by skb_zerocopy_headlen() specifies the
+ *	headroom in the `to` buffer.
+ */
+void
+skb_zerocopy(struct sk_buff *to, const struct sk_buff *from, int len, int hlen)
+{
+	int i, j = 0;
+	int plen = 0; /* length of skb->head fragment */
+	struct page *page;
+	unsigned int offset;
+
+	BUG_ON(!from->head_frag && !hlen);
+
+	/* dont bother with small payloads */
+	if (len <= skb_tailroom(to)) {
+		skb_copy_bits(from, 0, skb_put(to, len), len);
+		return;
+	}
+
+	if (hlen) {
+		skb_copy_bits(from, 0, skb_put(to, hlen), hlen);
+		len -= hlen;
+	} else {
+		plen = min_t(int, skb_headlen(from), len);
+		if (plen) {
+			page = virt_to_head_page(from->head);
+			offset = from->data - (unsigned char *)page_address(page);
+			__skb_fill_page_desc(to, 0, page, offset, plen);
+			get_page(page);
+			j = 1;
+			len -= plen;
+		}
+	}
+
+	to->truesize += len + plen;
+	to->len += len + plen;
+	to->data_len += len + plen;
+
+	for (i = 0; i < skb_shinfo(from)->nr_frags; i++) {
+		if (!len)
+			break;
+		skb_shinfo(to)->frags[j] = skb_shinfo(from)->frags[i];
+		skb_shinfo(to)->frags[j].size = min_t(int, skb_shinfo(to)->frags[j].size, len);
+		len -= skb_shinfo(to)->frags[j].size;
+		skb_frag_ref(to, j);
+		j++;
+	}
+	skb_shinfo(to)->nr_frags = j;
+}
+EXPORT_SYMBOL_GPL(skb_zerocopy);
+
 void skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to)
 {
 	__wsum csum;
* Unmerged path net/netfilter/nfnetlink_queue_core.c
