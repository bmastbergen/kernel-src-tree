x86: EFI stub support for large memory maps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [x86] EFI stub support for large memory maps (George Beshers) [973417]
Rebuild_FUZZ: 93.83%
commit-author Linn Crosetto <linn@hp.com>
commit d2078d5adbe227d64d7963d93f13479c890a9a16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/d2078d5a.failed

This patch fixes a problem with EFI memory maps larger than 128 entries
when booting using the EFI stub, which results in overflowing e820_map
in boot_params and an eventual halt when checking the map size in
sanitize_e820_map().

If the number of map entries is greater than what can fit in e820_map,
add the extra entries to the setup_data list using type SETUP_E820_EXT.
These extra entries are then picked up when the setup_data list is
parsed in parse_e820_ext().

	Signed-off-by: Linn Crosetto <linn@hp.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit d2078d5adbe227d64d7963d93f13479c890a9a16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
diff --cc arch/x86/boot/compressed/eboot.c
index cebd3ffb4774,5c0dc55f2387..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -543,69 -519,47 +543,97 @@@ fail
  	return NULL;
  }
  
- static efi_status_t exit_boot(struct boot_params *boot_params,
- 			      void *handle)
+ static void add_e820ext(struct boot_params *params,
+ 			struct setup_data *e820ext, u32 nr_entries)
  {
- 	struct efi_info *efi = &boot_params->efi_info;
- 	struct e820entry *e820_map = &boot_params->e820_map[0];
- 	struct e820entry *prev = NULL;
- 	unsigned long size, key, desc_size, _size;
- 	efi_memory_desc_t *mem_map;
+ 	struct setup_data *data;
  	efi_status_t status;
++<<<<<<< HEAD
 +	__u32 desc_version;
 +	u8 nr_entries;
 +	int i;
 +
 +	size = sizeof(*mem_map) * 32;
 +
 +again:
 +	size += sizeof(*mem_map);
 +	_size = size;
 +	status = efi_low_alloc(sys_table, size, 1, (unsigned long *)&mem_map);
 +	if (status != EFI_SUCCESS)
 +		return status;
 +
 +	status = efi_call_phys5(sys_table->boottime->get_memory_map, &size,
 +				mem_map, &key, &desc_size, &desc_version);
 +	if (status == EFI_BUFFER_TOO_SMALL) {
 +		efi_free(sys_table, _size, (unsigned long)mem_map);
 +		goto again;
 +	}
 +
 +	if (status != EFI_SUCCESS)
 +		goto free_mem_map;
 +
 +	memcpy(&efi->efi_loader_signature, EFI_LOADER_SIGNATURE, sizeof(__u32));
 +	efi->efi_systab = (unsigned long)sys_table;
 +	efi->efi_memdesc_size = desc_size;
 +	efi->efi_memdesc_version = desc_version;
 +	efi->efi_memmap = (unsigned long)mem_map;
 +	efi->efi_memmap_size = size;
 +
 +#ifdef CONFIG_X86_64
 +	efi->efi_systab_hi = (unsigned long)sys_table >> 32;
 +	efi->efi_memmap_hi = (unsigned long)mem_map >> 32;
 +#endif
 +
 +	/* Might as well exit boot services now */
 +	status = efi_call_phys2(sys_table->boottime->exit_boot_services,
 +				handle, key);
 +	if (status != EFI_SUCCESS)
 +		goto free_mem_map;
 +
 +	/* Historic? */
 +	boot_params->alt_mem_k = 32 * 1024;
 +
 +	/*
 +	 * Convert the EFI memory map to E820.
 +	 */
++=======
+ 	unsigned long size;
+ 
+ 	e820ext->type = SETUP_E820_EXT;
+ 	e820ext->len = nr_entries * sizeof(struct e820entry);
+ 	e820ext->next = 0;
+ 
+ 	data = (struct setup_data *)(unsigned long)params->hdr.setup_data;
+ 
+ 	while (data && data->next)
+ 		data = (struct setup_data *)(unsigned long)data->next;
+ 
+ 	if (data)
+ 		data->next = (unsigned long)e820ext;
+ 	else
+ 		params->hdr.setup_data = (unsigned long)e820ext;
+ }
+ 
+ static efi_status_t setup_e820(struct boot_params *params,
+ 			       struct setup_data *e820ext, u32 e820ext_size)
+ {
+ 	struct e820entry *e820_map = &params->e820_map[0];
+ 	struct efi_info *efi = &params->efi_info;
+ 	struct e820entry *prev = NULL;
+ 	u32 nr_entries;
+ 	u32 nr_desc;
+ 	int i;
+ 
++>>>>>>> d2078d5adbe2 (x86: EFI stub support for large memory maps)
  	nr_entries = 0;
- 	for (i = 0; i < size / desc_size; i++) {
+ 	nr_desc = efi->efi_memmap_size / efi->efi_memdesc_size;
+ 
+ 	for (i = 0; i < nr_desc; i++) {
  		efi_memory_desc_t *d;
  		unsigned int e820_type = 0;
- 		unsigned long m = (unsigned long)mem_map;
+ 		unsigned long m = efi->efi_memmap;
  
- 		d = (efi_memory_desc_t *)(m + (i * desc_size));
+ 		d = (efi_memory_desc_t *)(m + (i * efi->efi_memdesc_size));
  		switch (d->type) {
  		case EFI_RESERVED_TYPE:
  		case EFI_RUNTIME_SERVICES_CODE:
* Unmerged path arch/x86/boot/compressed/eboot.c
