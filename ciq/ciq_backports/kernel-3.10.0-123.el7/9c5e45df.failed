KEYS: Fix searching of nested keyrings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author David Howells <dhowells@redhat.com>
commit 9c5e45df215b4788f7a41c983ce862d08a083c2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/9c5e45df.failed

If a keyring contains more than 16 keyrings (the capacity of a single node in
the associative array) then those keyrings are split over multiple nodes
arranged as a tree.

If search_nested_keyrings() is called to search the keyring then it will
attempt to manually walk over just the 0 branch of the associative array tree
where all the keyring links are stored.  This works provided the key is found
before the algorithm steps from one node containing keyrings to a child node
or if there are sufficiently few keyring links that the keyrings are all in
one node.

However, if the algorithm does need to step from a node to a child node, it
doesn't change the node pointer unless a shortcut also gets transited.  This
means that the algorithm will keep scanning the same node over and over again
without terminating and without returning.

To fix this, move the internal-pointer-to-node translation from inside the
shortcut transit handler so that it applies it to node arrival as well.

This can be tested by:

	r=`keyctl newring sandbox @s`
	for ((i=0; i<=16; i++)); do keyctl newring ring$i $r; done
	for ((i=0; i<=16; i++)); do keyctl add user a$i a %:ring$i; done
	for ((i=0; i<=16; i++)); do keyctl search $r user a$i; done
	for ((i=17; i<=20; i++)); do keyctl search $r user a$i; done

The searches should all complete successfully (or with an error for 17-20),
but instead one or more of them will hang.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Tested-by: Stephen Gallagher <sgallagh@redhat.com>
(cherry picked from commit 9c5e45df215b4788f7a41c983ce862d08a083c2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/keys/keyring.c
diff --cc security/keys/keyring.c
index eeef1a073db4,d46cbc5e335e..000000000000
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@@ -277,6 -499,301 +277,304 @@@ struct key *keyring_alloc(const char *d
  }
  EXPORT_SYMBOL(keyring_alloc);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Iteration function to consider each key found.
+  */
+ static int keyring_search_iterator(const void *object, void *iterator_data)
+ {
+ 	struct keyring_search_context *ctx = iterator_data;
+ 	const struct key *key = keyring_ptr_to_key(object);
+ 	unsigned long kflags = key->flags;
+ 
+ 	kenter("{%d}", key->serial);
+ 
+ 	/* ignore keys not of this type */
+ 	if (key->type != ctx->index_key.type) {
+ 		kleave(" = 0 [!type]");
+ 		return 0;
+ 	}
+ 
+ 	/* skip invalidated, revoked and expired keys */
+ 	if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {
+ 		if (kflags & ((1 << KEY_FLAG_INVALIDATED) |
+ 			      (1 << KEY_FLAG_REVOKED))) {
+ 			ctx->result = ERR_PTR(-EKEYREVOKED);
+ 			kleave(" = %d [invrev]", ctx->skipped_ret);
+ 			goto skipped;
+ 		}
+ 
+ 		if (key->expiry && ctx->now.tv_sec >= key->expiry) {
+ 			ctx->result = ERR_PTR(-EKEYEXPIRED);
+ 			kleave(" = %d [expire]", ctx->skipped_ret);
+ 			goto skipped;
+ 		}
+ 	}
+ 
+ 	/* keys that don't match */
+ 	if (!ctx->match(key, ctx->match_data)) {
+ 		kleave(" = 0 [!match]");
+ 		return 0;
+ 	}
+ 
+ 	/* key must have search permissions */
+ 	if (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&
+ 	    key_task_permission(make_key_ref(key, ctx->possessed),
+ 				ctx->cred, KEY_SEARCH) < 0) {
+ 		ctx->result = ERR_PTR(-EACCES);
+ 		kleave(" = %d [!perm]", ctx->skipped_ret);
+ 		goto skipped;
+ 	}
+ 
+ 	if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {
+ 		/* we set a different error code if we pass a negative key */
+ 		if (kflags & (1 << KEY_FLAG_NEGATIVE)) {
+ 			smp_rmb();
+ 			ctx->result = ERR_PTR(key->type_data.reject_error);
+ 			kleave(" = %d [neg]", ctx->skipped_ret);
+ 			goto skipped;
+ 		}
+ 	}
+ 
+ 	/* Found */
+ 	ctx->result = make_key_ref(key, ctx->possessed);
+ 	kleave(" = 1 [found]");
+ 	return 1;
+ 
+ skipped:
+ 	return ctx->skipped_ret;
+ }
+ 
+ /*
+  * Search inside a keyring for a key.  We can search by walking to it
+  * directly based on its index-key or we can iterate over the entire
+  * tree looking for it, based on the match function.
+  */
+ static int search_keyring(struct key *keyring, struct keyring_search_context *ctx)
+ {
+ 	if ((ctx->flags & KEYRING_SEARCH_LOOKUP_TYPE) ==
+ 	    KEYRING_SEARCH_LOOKUP_DIRECT) {
+ 		const void *object;
+ 
+ 		object = assoc_array_find(&keyring->keys,
+ 					  &keyring_assoc_array_ops,
+ 					  &ctx->index_key);
+ 		return object ? ctx->iterator(object, ctx) : 0;
+ 	}
+ 	return assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);
+ }
+ 
+ /*
+  * Search a tree of keyrings that point to other keyrings up to the maximum
+  * depth.
+  */
+ static bool search_nested_keyrings(struct key *keyring,
+ 				   struct keyring_search_context *ctx)
+ {
+ 	struct {
+ 		struct key *keyring;
+ 		struct assoc_array_node *node;
+ 		int slot;
+ 	} stack[KEYRING_SEARCH_MAX_DEPTH];
+ 
+ 	struct assoc_array_shortcut *shortcut;
+ 	struct assoc_array_node *node;
+ 	struct assoc_array_ptr *ptr;
+ 	struct key *key;
+ 	int sp = 0, slot;
+ 
+ 	kenter("{%d},{%s,%s}",
+ 	       keyring->serial,
+ 	       ctx->index_key.type->name,
+ 	       ctx->index_key.description);
+ 
+ 	if (ctx->index_key.description)
+ 		ctx->index_key.desc_len = strlen(ctx->index_key.description);
+ 
+ 	/* Check to see if this top-level keyring is what we are looking for
+ 	 * and whether it is valid or not.
+ 	 */
+ 	if (ctx->flags & KEYRING_SEARCH_LOOKUP_ITERATE ||
+ 	    keyring_compare_object(keyring, &ctx->index_key)) {
+ 		ctx->skipped_ret = 2;
+ 		ctx->flags |= KEYRING_SEARCH_DO_STATE_CHECK;
+ 		switch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {
+ 		case 1:
+ 			goto found;
+ 		case 2:
+ 			return false;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	ctx->skipped_ret = 0;
+ 	if (ctx->flags & KEYRING_SEARCH_NO_STATE_CHECK)
+ 		ctx->flags &= ~KEYRING_SEARCH_DO_STATE_CHECK;
+ 
+ 	/* Start processing a new keyring */
+ descend_to_keyring:
+ 	kdebug("descend to %d", keyring->serial);
+ 	if (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |
+ 			      (1 << KEY_FLAG_REVOKED)))
+ 		goto not_this_keyring;
+ 
+ 	/* Search through the keys in this keyring before its searching its
+ 	 * subtrees.
+ 	 */
+ 	if (search_keyring(keyring, ctx))
+ 		goto found;
+ 
+ 	/* Then manually iterate through the keyrings nested in this one.
+ 	 *
+ 	 * Start from the root node of the index tree.  Because of the way the
+ 	 * hash function has been set up, keyrings cluster on the leftmost
+ 	 * branch of the root node (root slot 0) or in the root node itself.
+ 	 * Non-keyrings avoid the leftmost branch of the root entirely (root
+ 	 * slots 1-15).
+ 	 */
+ 	ptr = ACCESS_ONCE(keyring->keys.root);
+ 	if (!ptr)
+ 		goto not_this_keyring;
+ 
+ 	if (assoc_array_ptr_is_shortcut(ptr)) {
+ 		/* If the root is a shortcut, either the keyring only contains
+ 		 * keyring pointers (everything clusters behind root slot 0) or
+ 		 * doesn't contain any keyring pointers.
+ 		 */
+ 		shortcut = assoc_array_ptr_to_shortcut(ptr);
+ 		smp_read_barrier_depends();
+ 		if ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)
+ 			goto not_this_keyring;
+ 
+ 		ptr = ACCESS_ONCE(shortcut->next_node);
+ 		node = assoc_array_ptr_to_node(ptr);
+ 		goto begin_node;
+ 	}
+ 
+ 	node = assoc_array_ptr_to_node(ptr);
+ 	smp_read_barrier_depends();
+ 
+ 	ptr = node->slots[0];
+ 	if (!assoc_array_ptr_is_meta(ptr))
+ 		goto begin_node;
+ 
+ descend_to_node:
+ 	/* Descend to a more distal node in this keyring's content tree and go
+ 	 * through that.
+ 	 */
+ 	kdebug("descend");
+ 	if (assoc_array_ptr_is_shortcut(ptr)) {
+ 		shortcut = assoc_array_ptr_to_shortcut(ptr);
+ 		smp_read_barrier_depends();
+ 		ptr = ACCESS_ONCE(shortcut->next_node);
+ 		BUG_ON(!assoc_array_ptr_is_node(ptr));
+ 	}
+ 	node = assoc_array_ptr_to_node(ptr);
+ 
+ begin_node:
+ 	kdebug("begin_node");
+ 	smp_read_barrier_depends();
+ 	slot = 0;
+ ascend_to_node:
+ 	/* Go through the slots in a node */
+ 	for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {
+ 		ptr = ACCESS_ONCE(node->slots[slot]);
+ 
+ 		if (assoc_array_ptr_is_meta(ptr) && node->back_pointer)
+ 			goto descend_to_node;
+ 
+ 		if (!keyring_ptr_is_keyring(ptr))
+ 			continue;
+ 
+ 		key = keyring_ptr_to_key(ptr);
+ 
+ 		if (sp >= KEYRING_SEARCH_MAX_DEPTH) {
+ 			if (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {
+ 				ctx->result = ERR_PTR(-ELOOP);
+ 				return false;
+ 			}
+ 			goto not_this_keyring;
+ 		}
+ 
+ 		/* Search a nested keyring */
+ 		if (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&
+ 		    key_task_permission(make_key_ref(key, ctx->possessed),
+ 					ctx->cred, KEY_SEARCH) < 0)
+ 			continue;
+ 
+ 		/* stack the current position */
+ 		stack[sp].keyring = keyring;
+ 		stack[sp].node = node;
+ 		stack[sp].slot = slot;
+ 		sp++;
+ 
+ 		/* begin again with the new keyring */
+ 		keyring = key;
+ 		goto descend_to_keyring;
+ 	}
+ 
+ 	/* We've dealt with all the slots in the current node, so now we need
+ 	 * to ascend to the parent and continue processing there.
+ 	 */
+ 	ptr = ACCESS_ONCE(node->back_pointer);
+ 	slot = node->parent_slot;
+ 
+ 	if (ptr && assoc_array_ptr_is_shortcut(ptr)) {
+ 		shortcut = assoc_array_ptr_to_shortcut(ptr);
+ 		smp_read_barrier_depends();
+ 		ptr = ACCESS_ONCE(shortcut->back_pointer);
+ 		slot = shortcut->parent_slot;
+ 	}
+ 	if (!ptr)
+ 		goto not_this_keyring;
+ 	node = assoc_array_ptr_to_node(ptr);
+ 	smp_read_barrier_depends();
+ 	slot++;
+ 
+ 	/* If we've ascended to the root (zero backpointer), we must have just
+ 	 * finished processing the leftmost branch rather than the root slots -
+ 	 * so there can't be any more keyrings for us to find.
+ 	 */
+ 	if (node->back_pointer) {
+ 		kdebug("ascend %d", slot);
+ 		goto ascend_to_node;
+ 	}
+ 
+ 	/* The keyring we're looking at was disqualified or didn't contain a
+ 	 * matching key.
+ 	 */
+ not_this_keyring:
+ 	kdebug("not_this_keyring %d", sp);
+ 	if (sp <= 0) {
+ 		kleave(" = false");
+ 		return false;
+ 	}
+ 
+ 	/* Resume the processing of a keyring higher up in the tree */
+ 	sp--;
+ 	keyring = stack[sp].keyring;
+ 	node = stack[sp].node;
+ 	slot = stack[sp].slot + 1;
+ 	kdebug("ascend to %d [%d]", keyring->serial, slot);
+ 	goto ascend_to_node;
+ 
+ 	/* We found a viable match */
+ found:
+ 	key = key_ref_to_ptr(ctx->result);
+ 	key_check(key);
+ 	if (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {
+ 		key->last_used_at = ctx->now.tv_sec;
+ 		keyring->last_used_at = ctx->now.tv_sec;
+ 		while (sp > 0)
+ 			stack[--sp].keyring->last_used_at = ctx->now.tv_sec;
+ 	}
+ 	kleave(" = true");
+ 	return true;
+ }
+ 
++>>>>>>> 9c5e45df215b (KEYS: Fix searching of nested keyrings)
  /**
   * keyring_search_aux - Search a keyring tree for a key matching some criteria
   * @keyring_ref: A pointer to the keyring with possession indicator.
* Unmerged path security/keys/keyring.c
