PCI/ACPI: Split _OSC "support" and "control" flags into separate variables

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [acpi] Split _OSC "support" and "control" flags into separate variables (Myron Stowe) [1033834]
Rebuild_FUZZ: 92.75%
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit b8eb67fcc4548b9f0d00bbfd1c0c8f72d8018900
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/b8eb67fc.failed

Previously we used "flags" for both:

  - the bitmask of features we support (segments, ASPM, MSI, etc.), and
  - the bitmask of features we want to control (native hotplug, AER, etc.)

To reduce confusion, this patch splits this into two variables:
"support" is the bitmask of features we support, and "control" is the
bitmask of features we want to control.  No functional change.

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit b8eb67fcc4548b9f0d00bbfd1c0c8f72d8018900)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/pci_root.c
diff --cc drivers/acpi/pci_root.c
index ed36e22817d8,3e06d4e179ec..000000000000
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@@ -360,109 -360,35 +360,118 @@@ out
  }
  EXPORT_SYMBOL(acpi_pci_osc_control_set);
  
 -static void negotiate_os_control(struct acpi_pci_root *root, int *no_aspm,
 -				 int *clear_aspm)
 +static int acpi_pci_root_add(struct acpi_device *device,
 +			     const struct acpi_device_id *not_used)
  {
++<<<<<<< HEAD
 +	unsigned long long segment, bus;
++=======
+ 	u32 support, base_support, control;
++>>>>>>> b8eb67fcc454 (PCI/ACPI: Split _OSC "support" and "control" flags into separate variables)
  	acpi_status status;
 -	struct acpi_device *device = root->device;
 +	int result;
 +	struct acpi_pci_root *root;
 +	u32 flags, base_flags;
  	acpi_handle handle = device->handle;
  
 +	root = kzalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);
 +	if (!root)
 +		return -ENOMEM;
 +
 +	segment = 0;
 +	status = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL,
 +				       &segment);
 +	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
 +		printk(KERN_ERR PREFIX "can't evaluate _SEG\n");
 +		result = -ENODEV;
 +		goto end;
 +	}
 +
 +	/* Check _CRS first, then _BBN.  If no _BBN, default to zero. */
 +	root->secondary.flags = IORESOURCE_BUS;
 +	status = try_get_root_bridge_busnr(handle, &root->secondary);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * We need both the start and end of the downstream bus range
 +		 * to interpret _CBA (MMCONFIG base address), so it really is
 +		 * supposed to be in _CRS.  If we don't find it there, all we
 +		 * can do is assume [_BBN-0xFF] or [0-0xFF].
 +		 */
 +		root->secondary.end = 0xFF;
 +		printk(KERN_WARNING FW_BUG PREFIX
 +		       "no secondary bus range in _CRS\n");
 +		status = acpi_evaluate_integer(handle, METHOD_NAME__BBN,
 +					       NULL, &bus);
 +		if (ACPI_SUCCESS(status))
 +			root->secondary.start = bus;
 +		else if (status == AE_NOT_FOUND)
 +			root->secondary.start = 0;
 +		else {
 +			printk(KERN_ERR PREFIX "can't evaluate _BBN\n");
 +			result = -ENODEV;
 +			goto end;
 +		}
 +	}
 +
 +	root->device = device;
 +	root->segment = segment & 0xFFFF;
 +	strcpy(acpi_device_name(device), ACPI_PCI_ROOT_DEVICE_NAME);
 +	strcpy(acpi_device_class(device), ACPI_PCI_ROOT_CLASS);
 +	device->driver_data = root;
 +
 +	printk(KERN_INFO PREFIX "%s [%s] (domain %04x %pR)\n",
 +	       acpi_device_name(device), acpi_device_bid(device),
 +	       root->segment, &root->secondary);
 +
 +	root->mcfg_addr = acpi_pci_root_get_mcfg_addr(handle);
 +
  	/*
  	 * All supported architectures that use ACPI have support for
  	 * PCI domains, so we indicate this in _OSC support capabilities.
  	 */
- 	flags = base_flags = OSC_PCI_SEGMENT_GROUPS_SUPPORT;
- 	acpi_pci_osc_support(root, flags);
+ 	support = base_support = OSC_PCI_SEGMENT_GROUPS_SUPPORT;
+ 	acpi_pci_osc_support(root, support);
  
 +	/*
 +	 * TBD: Need PCI interface for enumeration/configuration of roots.
 +	 */
 +
 +	/*
 +	 * Scan the Root Bridge
 +	 * --------------------
 +	 * Must do this prior to any attempt to bind the root device, as the
 +	 * PCI namespace does not get created until this call is made (and
 +	 * thus the root bridge's pci_dev does not exist).
 +	 */
 +	root->bus = pci_acpi_scan_root(root);
 +	if (!root->bus) {
 +		printk(KERN_ERR PREFIX
 +			    "Bus %04x:%02x not present in PCI namespace\n",
 +			    root->segment, (unsigned int)root->secondary.start);
 +		result = -ENODEV;
 +		goto end;
 +	}
 +
 +	/* Indicate support for various _OSC capabilities. */
  	if (pci_ext_cfg_avail())
- 		flags |= OSC_PCI_EXT_CONFIG_SUPPORT;
+ 		support |= OSC_PCI_EXT_CONFIG_SUPPORT;
  	if (pcie_aspm_support_enabled()) {
- 		flags |= OSC_PCI_ASPM_SUPPORT | OSC_PCI_CLOCK_PM_SUPPORT;
+ 		support |= OSC_PCI_ASPM_SUPPORT | OSC_PCI_CLOCK_PM_SUPPORT;
  	}
  	if (pci_msi_enabled())
- 		flags |= OSC_PCI_MSI_SUPPORT;
- 	if (flags != base_flags) {
- 		status = acpi_pci_osc_support(root, flags);
+ 		support |= OSC_PCI_MSI_SUPPORT;
+ 	if (support != base_support) {
+ 		status = acpi_pci_osc_support(root, support);
  		if (ACPI_FAILURE(status)) {
  			dev_info(&device->dev, "ACPI _OSC support "
  				"notification failed, disabling PCIe ASPM\n");
++<<<<<<< HEAD
 +			pcie_no_aspm();
 +			flags = base_flags;
++=======
+ 			*no_aspm = 1;
+ 			support = base_support;
++>>>>>>> b8eb67fcc454 (PCI/ACPI: Split _OSC "support" and "control" flags into separate variables)
  		}
  	}
  
@@@ -499,16 -426,114 +509,30 @@@
  			dev_info(&device->dev,
  				"ACPI _OSC request failed (%s), "
  				"returned control mask: 0x%02x\n",
++<<<<<<< HEAD
 +				acpi_format_exception(status), flags);
 +			pr_info("ACPI _OSC control for PCIe not granted, "
 +				"disabling ASPM\n");
 +			pcie_no_aspm();
++=======
+ 				acpi_format_exception(status), control);
+ 			dev_info(&device->dev,
+ 				 "ACPI _OSC control for PCIe not granted, disabling ASPM\n");
+ 			/*
+ 			 * We want to disable ASPM here, but aspm_disabled
+ 			 * needs to remain in its state from boot so that we
+ 			 * properly handle PCIe 1.1 devices.  So we set this
+ 			 * flag here, to defer the action until after the ACPI
+ 			 * root scan.
+ 			 */
+ 			*no_aspm = 1;
++>>>>>>> b8eb67fcc454 (PCI/ACPI: Split _OSC "support" and "control" flags into separate variables)
  		}
  	} else {
  		dev_info(&device->dev,
  			 "Unable to request _OSC control "
- 			 "(_OSC support mask: 0x%02x)\n", flags);
+ 			 "(_OSC support mask: 0x%02x)\n", support);
  	}
 -}
 -
 -static int acpi_pci_root_add(struct acpi_device *device,
 -			     const struct acpi_device_id *not_used)
 -{
 -	unsigned long long segment, bus;
 -	acpi_status status;
 -	int result;
 -	struct acpi_pci_root *root;
 -	acpi_handle handle = device->handle;
 -	int no_aspm = 0, clear_aspm = 0;
 -
 -	root = kzalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);
 -	if (!root)
 -		return -ENOMEM;
 -
 -	segment = 0;
 -	status = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL,
 -				       &segment);
 -	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
 -		dev_err(&device->dev,  "can't evaluate _SEG\n");
 -		result = -ENODEV;
 -		goto end;
 -	}
 -
 -	/* Check _CRS first, then _BBN.  If no _BBN, default to zero. */
 -	root->secondary.flags = IORESOURCE_BUS;
 -	status = try_get_root_bridge_busnr(handle, &root->secondary);
 -	if (ACPI_FAILURE(status)) {
 -		/*
 -		 * We need both the start and end of the downstream bus range
 -		 * to interpret _CBA (MMCONFIG base address), so it really is
 -		 * supposed to be in _CRS.  If we don't find it there, all we
 -		 * can do is assume [_BBN-0xFF] or [0-0xFF].
 -		 */
 -		root->secondary.end = 0xFF;
 -		dev_warn(&device->dev,
 -			 FW_BUG "no secondary bus range in _CRS\n");
 -		status = acpi_evaluate_integer(handle, METHOD_NAME__BBN,
 -					       NULL, &bus);
 -		if (ACPI_SUCCESS(status))
 -			root->secondary.start = bus;
 -		else if (status == AE_NOT_FOUND)
 -			root->secondary.start = 0;
 -		else {
 -			dev_err(&device->dev, "can't evaluate _BBN\n");
 -			result = -ENODEV;
 -			goto end;
 -		}
 -	}
 -
 -	root->device = device;
 -	root->segment = segment & 0xFFFF;
 -	strcpy(acpi_device_name(device), ACPI_PCI_ROOT_DEVICE_NAME);
 -	strcpy(acpi_device_class(device), ACPI_PCI_ROOT_CLASS);
 -	device->driver_data = root;
 -
 -	pr_info(PREFIX "%s [%s] (domain %04x %pR)\n",
 -	       acpi_device_name(device), acpi_device_bid(device),
 -	       root->segment, &root->secondary);
 -
 -	root->mcfg_addr = acpi_pci_root_get_mcfg_addr(handle);
 -
 -	negotiate_os_control(root, &no_aspm, &clear_aspm);
 -
 -	/*
 -	 * TBD: Need PCI interface for enumeration/configuration of roots.
 -	 */
 -
 -	/*
 -	 * Scan the Root Bridge
 -	 * --------------------
 -	 * Must do this prior to any attempt to bind the root device, as the
 -	 * PCI namespace does not get created until this call is made (and
 -	 * thus the root bridge's pci_dev does not exist).
 -	 */
 -	root->bus = pci_acpi_scan_root(root);
 -	if (!root->bus) {
 -		dev_err(&device->dev,
 -			"Bus %04x:%02x not present in PCI namespace\n",
 -			root->segment, (unsigned int)root->secondary.start);
 -		result = -ENODEV;
 -		goto end;
 -	}
 -
 -	if (clear_aspm) {
 -		dev_info(&device->dev, "Disabling ASPM (FADT indicates it is unsupported)\n");
 -		pcie_clear_aspm(root->bus);
 -	}
 -	if (no_aspm)
 -		pcie_no_aspm();
  
  	pci_acpi_add_bus_pm_notifier(device, root->bus);
  	if (device->wakeup.flags.run_wake)
* Unmerged path drivers/acpi/pci_root.c
