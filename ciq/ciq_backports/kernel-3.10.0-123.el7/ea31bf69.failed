drm/radeon: remove generic rptr/wptr functions (v2)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [drm] radeon: remove generic rptr/wptr functions (Steve Best) [1048290]
Rebuild_FUZZ: 90.32%
commit-author Alex Deucher <alexander.deucher@amd.com>
commit ea31bf697d27270188a93cd78cf9de4bc968aca3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/ea31bf69.failed

Fill in asic family specific versions rather than
using the generic version.  This lets us handle asic
specific differences more easily.  In this case, we
disable sw swapping of the rtpr writeback value on
r6xx+ since the hw does it for us.  Fixes bogus
rptr readback on BE systems.

v2: remove missed cpu_to_le32(), add comments

	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit ea31bf697d27270188a93cd78cf9de4bc968aca3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/radeon/cik.c
#	drivers/gpu/drm/radeon/cik_sdma.c
#	drivers/gpu/drm/radeon/evergreen.c
#	drivers/gpu/drm/radeon/ni.c
#	drivers/gpu/drm/radeon/ni_dma.c
#	drivers/gpu/drm/radeon/r100.c
#	drivers/gpu/drm/radeon/r600.c
#	drivers/gpu/drm/radeon/r600_dma.c
#	drivers/gpu/drm/radeon/radeon.h
#	drivers/gpu/drm/radeon/radeon_asic.c
#	drivers/gpu/drm/radeon/radeon_asic.h
#	drivers/gpu/drm/radeon/radeon_ring.c
#	drivers/gpu/drm/radeon/rv770.c
#	drivers/gpu/drm/radeon/si.c
diff --cc drivers/gpu/drm/radeon/evergreen.c
index 0d9455192306,21d975007037..000000000000
--- a/drivers/gpu/drm/radeon/evergreen.c
+++ b/drivers/gpu/drm/radeon/evergreen.c
@@@ -4763,15 -5184,13 +4763,23 @@@ static int evergreen_startup(struct rad
  
  	ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     R600_CP_RB_RPTR, R600_CP_RB_WPTR,
 +			     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 			     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     DMA_RB_RPTR, DMA_RB_WPTR,
 +			     2, 0x3fffc, DMA_PACKET(DMA_PACKET_NOP, 0, 0));
++=======
+ 			     DMA_PACKET(DMA_PACKET_NOP, 0, 0));
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
@@@ -4787,12 -5206,10 +4795,17 @@@
  
  	ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];
  	if (ring->ring_size) {
++<<<<<<< HEAD
 +		r = radeon_ring_init(rdev, ring, ring->ring_size,
 +				     R600_WB_UVD_RPTR_OFFSET,
 +				     UVD_RBC_RB_RPTR, UVD_RBC_RB_WPTR,
 +				     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 		r = radeon_ring_init(rdev, ring, ring->ring_size, 0,
+ 				     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  		if (!r)
 -			r = uvd_v1_0_init(rdev);
 +			r = r600_uvd_init(rdev);
  
  		if (r)
  			DRM_ERROR("radeon: error initializing UVD (%d).\n", r);
diff --cc drivers/gpu/drm/radeon/ni.c
index 84583302b081,05a900945613..000000000000
--- a/drivers/gpu/drm/radeon/ni.c
+++ b/drivers/gpu/drm/radeon/ni.c
@@@ -2040,24 -2012,19 +2099,36 @@@ static int cayman_startup(struct radeon
  	evergreen_irq_set(rdev);
  
  	r = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     CP_RB0_RPTR, CP_RB0_WPTR,
 +			     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 			     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     DMA_RB_RPTR + DMA0_REGISTER_OFFSET,
 +			     DMA_RB_WPTR + DMA0_REGISTER_OFFSET,
 +			     2, 0x3fffc, DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));
++=======
+ 			     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, CAYMAN_WB_DMA1_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     DMA_RB_RPTR + DMA1_REGISTER_OFFSET,
 +			     DMA_RB_WPTR + DMA1_REGISTER_OFFSET,
 +			     2, 0x3fffc, DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));
++=======
+ 			     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
@@@ -2074,12 -2041,10 +2145,17 @@@
  
  	ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];
  	if (ring->ring_size) {
++<<<<<<< HEAD
 +		r = radeon_ring_init(rdev, ring, ring->ring_size,
 +				     R600_WB_UVD_RPTR_OFFSET,
 +				     UVD_RBC_RB_RPTR, UVD_RBC_RB_WPTR,
 +				     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 		r = radeon_ring_init(rdev, ring, ring->ring_size, 0,
+ 				     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  		if (!r)
 -			r = uvd_v1_0_init(rdev);
 +			r = r600_uvd_init(rdev);
  		if (r)
  			DRM_ERROR("radeon: failed initializing UVD (%d).\n", r);
  	}
diff --cc drivers/gpu/drm/radeon/r100.c
index d0314ecbd7c1,ef024ce3f7cc..000000000000
--- a/drivers/gpu/drm/radeon/r100.c
+++ b/drivers/gpu/drm/radeon/r100.c
@@@ -1110,8 -1132,7 +1140,12 @@@ int r100_cp_init(struct radeon_device *
  	ring_size = (1 << (rb_bufsz + 1)) * 4;
  	r100_cp_load_microcode(rdev);
  	r = radeon_ring_init(rdev, ring, ring_size, RADEON_WB_CP_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     RADEON_CP_RB_RPTR, RADEON_CP_RB_WPTR,
 +			     0, 0x7fffff, RADEON_CP_PACKET2);
++=======
+ 			     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r) {
  		return r;
  	}
diff --cc drivers/gpu/drm/radeon/r600.c
index 6948eb88c2b7,bf0792cf0729..000000000000
--- a/drivers/gpu/drm/radeon/r600.c
+++ b/drivers/gpu/drm/radeon/r600.c
@@@ -3268,15 -2848,13 +3298,23 @@@ static int r600_startup(struct radeon_d
  
  	ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     R600_CP_RB_RPTR, R600_CP_RB_WPTR,
 +			     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 			     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     DMA_RB_RPTR, DMA_RB_WPTR,
 +			     2, 0x3fffc, DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));
++=======
+ 			     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
diff --cc drivers/gpu/drm/radeon/radeon.h
index 142ce6cc69f5,ba74aad25226..000000000000
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@@ -818,8 -953,7 +816,12 @@@ unsigned radeon_ring_backup(struct rade
  int radeon_ring_restore(struct radeon_device *rdev, struct radeon_ring *ring,
  			unsigned size, uint32_t *data);
  int radeon_ring_init(struct radeon_device *rdev, struct radeon_ring *cp, unsigned ring_size,
++<<<<<<< HEAD
 +		     unsigned rptr_offs, unsigned rptr_reg, unsigned wptr_reg,
 +		     u32 ptr_reg_shift, u32 ptr_reg_mask, u32 nop);
++=======
+ 		     unsigned rptr_offs, u32 nop);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  void radeon_ring_fini(struct radeon_device *rdev, struct radeon_ring *cp);
  
  
diff --cc drivers/gpu/drm/radeon/radeon_asic.c
index a2802b47ee95,f55879dd11c6..000000000000
--- a/drivers/gpu/drm/radeon/radeon_asic.c
+++ b/drivers/gpu/drm/radeon/radeon_asic.c
@@@ -168,6 -172,21 +168,24 @@@ void radeon_agp_disable(struct radeon_d
  /*
   * ASIC
   */
++<<<<<<< HEAD
++=======
+ 
+ static struct radeon_asic_ring r100_gfx_ring = {
+ 	.ib_execute = &r100_ring_ib_execute,
+ 	.emit_fence = &r100_fence_ring_emit,
+ 	.emit_semaphore = &r100_semaphore_ring_emit,
+ 	.cs_parse = &r100_cs_parse,
+ 	.ring_start = &r100_ring_start,
+ 	.ring_test = &r100_ring_test,
+ 	.ib_test = &r100_ib_test,
+ 	.is_lockup = &r100_gpu_is_lockup,
+ 	.get_rptr = &r100_gfx_get_rptr,
+ 	.get_wptr = &r100_gfx_get_wptr,
+ 	.set_wptr = &r100_gfx_set_wptr,
+ };
+ 
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  static struct radeon_asic r100_asic = {
  	.init = &r100_init,
  	.fini = &r100_fini,
@@@ -320,6 -321,20 +338,23 @@@ static struct radeon_asic r200_asic = 
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static struct radeon_asic_ring r300_gfx_ring = {
+ 	.ib_execute = &r100_ring_ib_execute,
+ 	.emit_fence = &r300_fence_ring_emit,
+ 	.emit_semaphore = &r100_semaphore_ring_emit,
+ 	.cs_parse = &r300_cs_parse,
+ 	.ring_start = &r300_ring_start,
+ 	.ring_test = &r100_ring_test,
+ 	.ib_test = &r100_ib_test,
+ 	.is_lockup = &r100_gpu_is_lockup,
+ 	.get_rptr = &r100_gfx_get_rptr,
+ 	.get_wptr = &r100_gfx_get_wptr,
+ 	.set_wptr = &r100_gfx_set_wptr,
+ };
+ 
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  static struct radeon_asic r300_asic = {
  	.init = &r300_init,
  	.fini = &r300_fini,
@@@ -932,6 -875,32 +967,35 @@@ static struct radeon_asic r520_asic = 
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static struct radeon_asic_ring r600_gfx_ring = {
+ 	.ib_execute = &r600_ring_ib_execute,
+ 	.emit_fence = &r600_fence_ring_emit,
+ 	.emit_semaphore = &r600_semaphore_ring_emit,
+ 	.cs_parse = &r600_cs_parse,
+ 	.ring_test = &r600_ring_test,
+ 	.ib_test = &r600_ib_test,
+ 	.is_lockup = &r600_gfx_is_lockup,
+ 	.get_rptr = &r600_gfx_get_rptr,
+ 	.get_wptr = &r600_gfx_get_wptr,
+ 	.set_wptr = &r600_gfx_set_wptr,
+ };
+ 
+ static struct radeon_asic_ring r600_dma_ring = {
+ 	.ib_execute = &r600_dma_ring_ib_execute,
+ 	.emit_fence = &r600_dma_fence_ring_emit,
+ 	.emit_semaphore = &r600_dma_semaphore_ring_emit,
+ 	.cs_parse = &r600_dma_cs_parse,
+ 	.ring_test = &r600_dma_ring_test,
+ 	.ib_test = &r600_dma_ib_test,
+ 	.is_lockup = &r600_dma_is_lockup,
+ 	.get_rptr = &r600_dma_get_rptr,
+ 	.get_wptr = &r600_dma_get_wptr,
+ 	.set_wptr = &r600_dma_set_wptr,
+ };
+ 
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  static struct radeon_asic r600_asic = {
  	.init = &r600_init,
  	.fini = &r600_fini,
@@@ -1206,6 -1262,32 +1270,35 @@@ static struct radeon_asic rv770_asic = 
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static struct radeon_asic_ring evergreen_gfx_ring = {
+ 	.ib_execute = &evergreen_ring_ib_execute,
+ 	.emit_fence = &r600_fence_ring_emit,
+ 	.emit_semaphore = &r600_semaphore_ring_emit,
+ 	.cs_parse = &evergreen_cs_parse,
+ 	.ring_test = &r600_ring_test,
+ 	.ib_test = &r600_ib_test,
+ 	.is_lockup = &evergreen_gfx_is_lockup,
+ 	.get_rptr = &r600_gfx_get_rptr,
+ 	.get_wptr = &r600_gfx_get_wptr,
+ 	.set_wptr = &r600_gfx_set_wptr,
+ };
+ 
+ static struct radeon_asic_ring evergreen_dma_ring = {
+ 	.ib_execute = &evergreen_dma_ring_ib_execute,
+ 	.emit_fence = &evergreen_dma_fence_ring_emit,
+ 	.emit_semaphore = &r600_dma_semaphore_ring_emit,
+ 	.cs_parse = &evergreen_dma_cs_parse,
+ 	.ring_test = &r600_dma_ring_test,
+ 	.ib_test = &r600_dma_ib_test,
+ 	.is_lockup = &evergreen_dma_is_lockup,
+ 	.get_rptr = &r600_dma_get_rptr,
+ 	.get_wptr = &r600_dma_get_wptr,
+ 	.set_wptr = &r600_dma_set_wptr,
+ };
+ 
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  static struct radeon_asic evergreen_asic = {
  	.init = &evergreen_init,
  	.fini = &evergreen_fini,
@@@ -1500,6 -1566,49 +1593,52 @@@ static struct radeon_asic btc_asic = 
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static struct radeon_asic_ring cayman_gfx_ring = {
+ 	.ib_execute = &cayman_ring_ib_execute,
+ 	.ib_parse = &evergreen_ib_parse,
+ 	.emit_fence = &cayman_fence_ring_emit,
+ 	.emit_semaphore = &r600_semaphore_ring_emit,
+ 	.cs_parse = &evergreen_cs_parse,
+ 	.ring_test = &r600_ring_test,
+ 	.ib_test = &r600_ib_test,
+ 	.is_lockup = &cayman_gfx_is_lockup,
+ 	.vm_flush = &cayman_vm_flush,
+ 	.get_rptr = &cayman_gfx_get_rptr,
+ 	.get_wptr = &cayman_gfx_get_wptr,
+ 	.set_wptr = &cayman_gfx_set_wptr,
+ };
+ 
+ static struct radeon_asic_ring cayman_dma_ring = {
+ 	.ib_execute = &cayman_dma_ring_ib_execute,
+ 	.ib_parse = &evergreen_dma_ib_parse,
+ 	.emit_fence = &evergreen_dma_fence_ring_emit,
+ 	.emit_semaphore = &r600_dma_semaphore_ring_emit,
+ 	.cs_parse = &evergreen_dma_cs_parse,
+ 	.ring_test = &r600_dma_ring_test,
+ 	.ib_test = &r600_dma_ib_test,
+ 	.is_lockup = &cayman_dma_is_lockup,
+ 	.vm_flush = &cayman_dma_vm_flush,
+ 	.get_rptr = &cayman_dma_get_rptr,
+ 	.get_wptr = &cayman_dma_get_wptr,
+ 	.set_wptr = &cayman_dma_set_wptr
+ };
+ 
+ static struct radeon_asic_ring cayman_uvd_ring = {
+ 	.ib_execute = &uvd_v1_0_ib_execute,
+ 	.emit_fence = &uvd_v2_2_fence_emit,
+ 	.emit_semaphore = &uvd_v3_1_semaphore_emit,
+ 	.cs_parse = &radeon_uvd_cs_parse,
+ 	.ring_test = &uvd_v1_0_ring_test,
+ 	.ib_test = &uvd_v1_0_ib_test,
+ 	.is_lockup = &radeon_ring_test_lockup,
+ 	.get_rptr = &uvd_v1_0_get_rptr,
+ 	.get_wptr = &uvd_v1_0_get_wptr,
+ 	.set_wptr = &uvd_v1_0_set_wptr,
+ };
+ 
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  static struct radeon_asic cayman_asic = {
  	.init = &cayman_init,
  	.fini = &cayman_fini,
@@@ -1780,6 -1811,36 +1919,39 @@@ static struct radeon_asic trinity_asic 
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static struct radeon_asic_ring si_gfx_ring = {
+ 	.ib_execute = &si_ring_ib_execute,
+ 	.ib_parse = &si_ib_parse,
+ 	.emit_fence = &si_fence_ring_emit,
+ 	.emit_semaphore = &r600_semaphore_ring_emit,
+ 	.cs_parse = NULL,
+ 	.ring_test = &r600_ring_test,
+ 	.ib_test = &r600_ib_test,
+ 	.is_lockup = &si_gfx_is_lockup,
+ 	.vm_flush = &si_vm_flush,
+ 	.get_rptr = &cayman_gfx_get_rptr,
+ 	.get_wptr = &cayman_gfx_get_wptr,
+ 	.set_wptr = &cayman_gfx_set_wptr,
+ };
+ 
+ static struct radeon_asic_ring si_dma_ring = {
+ 	.ib_execute = &cayman_dma_ring_ib_execute,
+ 	.ib_parse = &evergreen_dma_ib_parse,
+ 	.emit_fence = &evergreen_dma_fence_ring_emit,
+ 	.emit_semaphore = &r600_dma_semaphore_ring_emit,
+ 	.cs_parse = NULL,
+ 	.ring_test = &r600_dma_ring_test,
+ 	.ib_test = &r600_dma_ib_test,
+ 	.is_lockup = &si_dma_is_lockup,
+ 	.vm_flush = &si_dma_vm_flush,
+ 	.get_rptr = &cayman_dma_get_rptr,
+ 	.get_wptr = &cayman_dma_get_wptr,
+ 	.set_wptr = &cayman_dma_set_wptr,
+ };
+ 
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  static struct radeon_asic si_asic = {
  	.init = &si_init,
  	.fini = &si_fini,
@@@ -1911,6 -1915,274 +2083,277 @@@
  		.set_pcie_lanes = &r600_set_pcie_lanes,
  		.set_clock_gating = NULL,
  		.set_uvd_clocks = &si_set_uvd_clocks,
++<<<<<<< HEAD
++=======
+ 		.get_temperature = &si_get_temp,
+ 	},
+ 	.dpm = {
+ 		.init = &si_dpm_init,
+ 		.setup_asic = &si_dpm_setup_asic,
+ 		.enable = &si_dpm_enable,
+ 		.late_enable = &si_dpm_late_enable,
+ 		.disable = &si_dpm_disable,
+ 		.pre_set_power_state = &si_dpm_pre_set_power_state,
+ 		.set_power_state = &si_dpm_set_power_state,
+ 		.post_set_power_state = &si_dpm_post_set_power_state,
+ 		.display_configuration_changed = &si_dpm_display_configuration_changed,
+ 		.fini = &si_dpm_fini,
+ 		.get_sclk = &ni_dpm_get_sclk,
+ 		.get_mclk = &ni_dpm_get_mclk,
+ 		.print_power_state = &ni_dpm_print_power_state,
+ 		.debugfs_print_current_performance_level = &si_dpm_debugfs_print_current_performance_level,
+ 		.force_performance_level = &si_dpm_force_performance_level,
+ 		.vblank_too_short = &ni_dpm_vblank_too_short,
+ 	},
+ 	.pflip = {
+ 		.pre_page_flip = &evergreen_pre_page_flip,
+ 		.page_flip = &evergreen_page_flip,
+ 		.post_page_flip = &evergreen_post_page_flip,
+ 	},
+ };
+ 
+ static struct radeon_asic_ring ci_gfx_ring = {
+ 	.ib_execute = &cik_ring_ib_execute,
+ 	.ib_parse = &cik_ib_parse,
+ 	.emit_fence = &cik_fence_gfx_ring_emit,
+ 	.emit_semaphore = &cik_semaphore_ring_emit,
+ 	.cs_parse = NULL,
+ 	.ring_test = &cik_ring_test,
+ 	.ib_test = &cik_ib_test,
+ 	.is_lockup = &cik_gfx_is_lockup,
+ 	.vm_flush = &cik_vm_flush,
+ 	.get_rptr = &cik_gfx_get_rptr,
+ 	.get_wptr = &cik_gfx_get_wptr,
+ 	.set_wptr = &cik_gfx_set_wptr,
+ };
+ 
+ static struct radeon_asic_ring ci_cp_ring = {
+ 	.ib_execute = &cik_ring_ib_execute,
+ 	.ib_parse = &cik_ib_parse,
+ 	.emit_fence = &cik_fence_compute_ring_emit,
+ 	.emit_semaphore = &cik_semaphore_ring_emit,
+ 	.cs_parse = NULL,
+ 	.ring_test = &cik_ring_test,
+ 	.ib_test = &cik_ib_test,
+ 	.is_lockup = &cik_gfx_is_lockup,
+ 	.vm_flush = &cik_vm_flush,
+ 	.get_rptr = &cik_compute_get_rptr,
+ 	.get_wptr = &cik_compute_get_wptr,
+ 	.set_wptr = &cik_compute_set_wptr,
+ };
+ 
+ static struct radeon_asic_ring ci_dma_ring = {
+ 	.ib_execute = &cik_sdma_ring_ib_execute,
+ 	.ib_parse = &cik_ib_parse,
+ 	.emit_fence = &cik_sdma_fence_ring_emit,
+ 	.emit_semaphore = &cik_sdma_semaphore_ring_emit,
+ 	.cs_parse = NULL,
+ 	.ring_test = &cik_sdma_ring_test,
+ 	.ib_test = &cik_sdma_ib_test,
+ 	.is_lockup = &cik_sdma_is_lockup,
+ 	.vm_flush = &cik_dma_vm_flush,
+ 	.get_rptr = &cik_sdma_get_rptr,
+ 	.get_wptr = &cik_sdma_get_wptr,
+ 	.set_wptr = &cik_sdma_set_wptr,
+ };
+ 
+ static struct radeon_asic ci_asic = {
+ 	.init = &cik_init,
+ 	.fini = &cik_fini,
+ 	.suspend = &cik_suspend,
+ 	.resume = &cik_resume,
+ 	.asic_reset = &cik_asic_reset,
+ 	.vga_set_state = &r600_vga_set_state,
+ 	.ioctl_wait_idle = NULL,
+ 	.gui_idle = &r600_gui_idle,
+ 	.mc_wait_for_idle = &evergreen_mc_wait_for_idle,
+ 	.get_xclk = &cik_get_xclk,
+ 	.get_gpu_clock_counter = &cik_get_gpu_clock_counter,
+ 	.gart = {
+ 		.tlb_flush = &cik_pcie_gart_tlb_flush,
+ 		.set_page = &rs600_gart_set_page,
+ 	},
+ 	.vm = {
+ 		.init = &cik_vm_init,
+ 		.fini = &cik_vm_fini,
+ 		.set_page = &cik_sdma_vm_set_page,
+ 	},
+ 	.ring = {
+ 		[RADEON_RING_TYPE_GFX_INDEX] = &ci_gfx_ring,
+ 		[CAYMAN_RING_TYPE_CP1_INDEX] = &ci_cp_ring,
+ 		[CAYMAN_RING_TYPE_CP2_INDEX] = &ci_cp_ring,
+ 		[R600_RING_TYPE_DMA_INDEX] = &ci_dma_ring,
+ 		[CAYMAN_RING_TYPE_DMA1_INDEX] = &ci_dma_ring,
+ 		[R600_RING_TYPE_UVD_INDEX] = &cayman_uvd_ring,
+ 	},
+ 	.irq = {
+ 		.set = &cik_irq_set,
+ 		.process = &cik_irq_process,
+ 	},
+ 	.display = {
+ 		.bandwidth_update = &dce8_bandwidth_update,
+ 		.get_vblank_counter = &evergreen_get_vblank_counter,
+ 		.wait_for_vblank = &dce4_wait_for_vblank,
+ 		.set_backlight_level = &atombios_set_backlight_level,
+ 		.get_backlight_level = &atombios_get_backlight_level,
+ 		.hdmi_enable = &evergreen_hdmi_enable,
+ 		.hdmi_setmode = &evergreen_hdmi_setmode,
+ 	},
+ 	.copy = {
+ 		.blit = NULL,
+ 		.blit_ring_index = RADEON_RING_TYPE_GFX_INDEX,
+ 		.dma = &cik_copy_dma,
+ 		.dma_ring_index = R600_RING_TYPE_DMA_INDEX,
+ 		.copy = &cik_copy_dma,
+ 		.copy_ring_index = R600_RING_TYPE_DMA_INDEX,
+ 	},
+ 	.surface = {
+ 		.set_reg = r600_set_surface_reg,
+ 		.clear_reg = r600_clear_surface_reg,
+ 	},
+ 	.hpd = {
+ 		.init = &evergreen_hpd_init,
+ 		.fini = &evergreen_hpd_fini,
+ 		.sense = &evergreen_hpd_sense,
+ 		.set_polarity = &evergreen_hpd_set_polarity,
+ 	},
+ 	.pm = {
+ 		.misc = &evergreen_pm_misc,
+ 		.prepare = &evergreen_pm_prepare,
+ 		.finish = &evergreen_pm_finish,
+ 		.init_profile = &sumo_pm_init_profile,
+ 		.get_dynpm_state = &r600_pm_get_dynpm_state,
+ 		.get_engine_clock = &radeon_atom_get_engine_clock,
+ 		.set_engine_clock = &radeon_atom_set_engine_clock,
+ 		.get_memory_clock = &radeon_atom_get_memory_clock,
+ 		.set_memory_clock = &radeon_atom_set_memory_clock,
+ 		.get_pcie_lanes = NULL,
+ 		.set_pcie_lanes = NULL,
+ 		.set_clock_gating = NULL,
+ 		.set_uvd_clocks = &cik_set_uvd_clocks,
+ 		.get_temperature = &ci_get_temp,
+ 	},
+ 	.dpm = {
+ 		.init = &ci_dpm_init,
+ 		.setup_asic = &ci_dpm_setup_asic,
+ 		.enable = &ci_dpm_enable,
+ 		.late_enable = &ci_dpm_late_enable,
+ 		.disable = &ci_dpm_disable,
+ 		.pre_set_power_state = &ci_dpm_pre_set_power_state,
+ 		.set_power_state = &ci_dpm_set_power_state,
+ 		.post_set_power_state = &ci_dpm_post_set_power_state,
+ 		.display_configuration_changed = &ci_dpm_display_configuration_changed,
+ 		.fini = &ci_dpm_fini,
+ 		.get_sclk = &ci_dpm_get_sclk,
+ 		.get_mclk = &ci_dpm_get_mclk,
+ 		.print_power_state = &ci_dpm_print_power_state,
+ 		.debugfs_print_current_performance_level = &ci_dpm_debugfs_print_current_performance_level,
+ 		.force_performance_level = &ci_dpm_force_performance_level,
+ 		.vblank_too_short = &ci_dpm_vblank_too_short,
+ 		.powergate_uvd = &ci_dpm_powergate_uvd,
+ 	},
+ 	.pflip = {
+ 		.pre_page_flip = &evergreen_pre_page_flip,
+ 		.page_flip = &evergreen_page_flip,
+ 		.post_page_flip = &evergreen_post_page_flip,
+ 	},
+ };
+ 
+ static struct radeon_asic kv_asic = {
+ 	.init = &cik_init,
+ 	.fini = &cik_fini,
+ 	.suspend = &cik_suspend,
+ 	.resume = &cik_resume,
+ 	.asic_reset = &cik_asic_reset,
+ 	.vga_set_state = &r600_vga_set_state,
+ 	.ioctl_wait_idle = NULL,
+ 	.gui_idle = &r600_gui_idle,
+ 	.mc_wait_for_idle = &evergreen_mc_wait_for_idle,
+ 	.get_xclk = &cik_get_xclk,
+ 	.get_gpu_clock_counter = &cik_get_gpu_clock_counter,
+ 	.gart = {
+ 		.tlb_flush = &cik_pcie_gart_tlb_flush,
+ 		.set_page = &rs600_gart_set_page,
+ 	},
+ 	.vm = {
+ 		.init = &cik_vm_init,
+ 		.fini = &cik_vm_fini,
+ 		.set_page = &cik_sdma_vm_set_page,
+ 	},
+ 	.ring = {
+ 		[RADEON_RING_TYPE_GFX_INDEX] = &ci_gfx_ring,
+ 		[CAYMAN_RING_TYPE_CP1_INDEX] = &ci_cp_ring,
+ 		[CAYMAN_RING_TYPE_CP2_INDEX] = &ci_cp_ring,
+ 		[R600_RING_TYPE_DMA_INDEX] = &ci_dma_ring,
+ 		[CAYMAN_RING_TYPE_DMA1_INDEX] = &ci_dma_ring,
+ 		[R600_RING_TYPE_UVD_INDEX] = &cayman_uvd_ring,
+ 	},
+ 	.irq = {
+ 		.set = &cik_irq_set,
+ 		.process = &cik_irq_process,
+ 	},
+ 	.display = {
+ 		.bandwidth_update = &dce8_bandwidth_update,
+ 		.get_vblank_counter = &evergreen_get_vblank_counter,
+ 		.wait_for_vblank = &dce4_wait_for_vblank,
+ 		.set_backlight_level = &atombios_set_backlight_level,
+ 		.get_backlight_level = &atombios_get_backlight_level,
+ 		.hdmi_enable = &evergreen_hdmi_enable,
+ 		.hdmi_setmode = &evergreen_hdmi_setmode,
+ 	},
+ 	.copy = {
+ 		.blit = NULL,
+ 		.blit_ring_index = RADEON_RING_TYPE_GFX_INDEX,
+ 		.dma = &cik_copy_dma,
+ 		.dma_ring_index = R600_RING_TYPE_DMA_INDEX,
+ 		.copy = &cik_copy_dma,
+ 		.copy_ring_index = R600_RING_TYPE_DMA_INDEX,
+ 	},
+ 	.surface = {
+ 		.set_reg = r600_set_surface_reg,
+ 		.clear_reg = r600_clear_surface_reg,
+ 	},
+ 	.hpd = {
+ 		.init = &evergreen_hpd_init,
+ 		.fini = &evergreen_hpd_fini,
+ 		.sense = &evergreen_hpd_sense,
+ 		.set_polarity = &evergreen_hpd_set_polarity,
+ 	},
+ 	.pm = {
+ 		.misc = &evergreen_pm_misc,
+ 		.prepare = &evergreen_pm_prepare,
+ 		.finish = &evergreen_pm_finish,
+ 		.init_profile = &sumo_pm_init_profile,
+ 		.get_dynpm_state = &r600_pm_get_dynpm_state,
+ 		.get_engine_clock = &radeon_atom_get_engine_clock,
+ 		.set_engine_clock = &radeon_atom_set_engine_clock,
+ 		.get_memory_clock = &radeon_atom_get_memory_clock,
+ 		.set_memory_clock = &radeon_atom_set_memory_clock,
+ 		.get_pcie_lanes = NULL,
+ 		.set_pcie_lanes = NULL,
+ 		.set_clock_gating = NULL,
+ 		.set_uvd_clocks = &cik_set_uvd_clocks,
+ 		.get_temperature = &kv_get_temp,
+ 	},
+ 	.dpm = {
+ 		.init = &kv_dpm_init,
+ 		.setup_asic = &kv_dpm_setup_asic,
+ 		.enable = &kv_dpm_enable,
+ 		.late_enable = &kv_dpm_late_enable,
+ 		.disable = &kv_dpm_disable,
+ 		.pre_set_power_state = &kv_dpm_pre_set_power_state,
+ 		.set_power_state = &kv_dpm_set_power_state,
+ 		.post_set_power_state = &kv_dpm_post_set_power_state,
+ 		.display_configuration_changed = &kv_dpm_display_configuration_changed,
+ 		.fini = &kv_dpm_fini,
+ 		.get_sclk = &kv_dpm_get_sclk,
+ 		.get_mclk = &kv_dpm_get_mclk,
+ 		.print_power_state = &kv_dpm_print_power_state,
+ 		.debugfs_print_current_performance_level = &kv_dpm_debugfs_print_current_performance_level,
+ 		.force_performance_level = &kv_dpm_force_performance_level,
+ 		.powergate_uvd = &kv_dpm_powergate_uvd,
+ 		.enable_bapm = &kv_dpm_enable_bapm,
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	},
  	.pflip = {
  		.pre_page_flip = &evergreen_pre_page_flip,
diff --cc drivers/gpu/drm/radeon/radeon_asic.h
index a72759ede753,b3bc433eed4c..000000000000
--- a/drivers/gpu/drm/radeon/radeon_asic.h
+++ b/drivers/gpu/drm/radeon/radeon_asic.h
@@@ -47,7 -47,6 +47,10 @@@ u8 atombios_get_backlight_level(struct 
  void radeon_legacy_set_backlight_level(struct radeon_encoder *radeon_encoder, u8 level);
  u8 radeon_legacy_get_backlight_level(struct radeon_encoder *radeon_encoder);
  
++<<<<<<< HEAD
 +
++=======
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  /*
   * r100,rv100,rs100,rv200,rs200
   */
@@@ -362,9 -367,13 +372,15 @@@ int r600_count_pipe_bits(uint32_t val)
  int r600_mc_wait_for_idle(struct radeon_device *rdev);
  int r600_pcie_gart_init(struct radeon_device *rdev);
  void r600_scratch_init(struct radeon_device *rdev);
 +int r600_blit_init(struct radeon_device *rdev);
 +void r600_blit_fini(struct radeon_device *rdev);
  int r600_init_microcode(struct radeon_device *rdev);
+ u32 r600_gfx_get_rptr(struct radeon_device *rdev,
+ 		      struct radeon_ring *ring);
+ u32 r600_gfx_get_wptr(struct radeon_device *rdev,
+ 		      struct radeon_ring *ring);
+ void r600_gfx_set_wptr(struct radeon_device *rdev,
+ 		       struct radeon_ring *ring);
  /* r600 irq */
  int r600_irq_process(struct radeon_device *rdev);
  int r600_irq_init(struct radeon_device *rdev);
@@@ -514,10 -592,68 +530,63 @@@ void cayman_dma_ring_ib_execute(struct 
  				struct radeon_ib *ib);
  bool cayman_gfx_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring);
  bool cayman_dma_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring);
 -void cayman_dma_vm_set_page(struct radeon_device *rdev,
 -			    struct radeon_ib *ib,
 -			    uint64_t pe,
 -			    uint64_t addr, unsigned count,
 -			    uint32_t incr, uint32_t flags);
 -
  void cayman_dma_vm_flush(struct radeon_device *rdev, int ridx, struct radeon_vm *vm);
  
++<<<<<<< HEAD
++=======
+ u32 cayman_gfx_get_rptr(struct radeon_device *rdev,
+ 			struct radeon_ring *ring);
+ u32 cayman_gfx_get_wptr(struct radeon_device *rdev,
+ 			struct radeon_ring *ring);
+ void cayman_gfx_set_wptr(struct radeon_device *rdev,
+ 			 struct radeon_ring *ring);
+ uint32_t cayman_dma_get_rptr(struct radeon_device *rdev,
+ 			     struct radeon_ring *ring);
+ uint32_t cayman_dma_get_wptr(struct radeon_device *rdev,
+ 			     struct radeon_ring *ring);
+ void cayman_dma_set_wptr(struct radeon_device *rdev,
+ 			 struct radeon_ring *ring);
+ 
+ int ni_dpm_init(struct radeon_device *rdev);
+ void ni_dpm_setup_asic(struct radeon_device *rdev);
+ int ni_dpm_enable(struct radeon_device *rdev);
+ void ni_dpm_disable(struct radeon_device *rdev);
+ int ni_dpm_pre_set_power_state(struct radeon_device *rdev);
+ int ni_dpm_set_power_state(struct radeon_device *rdev);
+ void ni_dpm_post_set_power_state(struct radeon_device *rdev);
+ void ni_dpm_fini(struct radeon_device *rdev);
+ u32 ni_dpm_get_sclk(struct radeon_device *rdev, bool low);
+ u32 ni_dpm_get_mclk(struct radeon_device *rdev, bool low);
+ void ni_dpm_print_power_state(struct radeon_device *rdev,
+ 			      struct radeon_ps *ps);
+ void ni_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,
+ 						    struct seq_file *m);
+ int ni_dpm_force_performance_level(struct radeon_device *rdev,
+ 				   enum radeon_dpm_forced_level level);
+ bool ni_dpm_vblank_too_short(struct radeon_device *rdev);
+ int trinity_dpm_init(struct radeon_device *rdev);
+ int trinity_dpm_enable(struct radeon_device *rdev);
+ int trinity_dpm_late_enable(struct radeon_device *rdev);
+ void trinity_dpm_disable(struct radeon_device *rdev);
+ int trinity_dpm_pre_set_power_state(struct radeon_device *rdev);
+ int trinity_dpm_set_power_state(struct radeon_device *rdev);
+ void trinity_dpm_post_set_power_state(struct radeon_device *rdev);
+ void trinity_dpm_setup_asic(struct radeon_device *rdev);
+ void trinity_dpm_display_configuration_changed(struct radeon_device *rdev);
+ void trinity_dpm_fini(struct radeon_device *rdev);
+ u32 trinity_dpm_get_sclk(struct radeon_device *rdev, bool low);
+ u32 trinity_dpm_get_mclk(struct radeon_device *rdev, bool low);
+ void trinity_dpm_print_power_state(struct radeon_device *rdev,
+ 				   struct radeon_ps *ps);
+ void trinity_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,
+ 							 struct seq_file *m);
+ int trinity_dpm_force_performance_level(struct radeon_device *rdev,
+ 					enum radeon_dpm_forced_level level);
+ void trinity_dpm_enable_bapm(struct radeon_device *rdev, bool enable);
+ 
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  /* DCE6 - SI */
  void dce6_bandwidth_update(struct radeon_device *rdev);
 -int dce6_audio_init(struct radeon_device *rdev);
 -void dce6_audio_fini(struct radeon_device *rdev);
  
  /*
   * si
@@@ -552,5 -688,177 +621,180 @@@ void si_dma_vm_flush(struct radeon_devi
  u32 si_get_xclk(struct radeon_device *rdev);
  uint64_t si_get_gpu_clock_counter(struct radeon_device *rdev);
  int si_set_uvd_clocks(struct radeon_device *rdev, u32 vclk, u32 dclk);
++<<<<<<< HEAD
++=======
+ int si_get_temp(struct radeon_device *rdev);
+ int si_dpm_init(struct radeon_device *rdev);
+ void si_dpm_setup_asic(struct radeon_device *rdev);
+ int si_dpm_enable(struct radeon_device *rdev);
+ int si_dpm_late_enable(struct radeon_device *rdev);
+ void si_dpm_disable(struct radeon_device *rdev);
+ int si_dpm_pre_set_power_state(struct radeon_device *rdev);
+ int si_dpm_set_power_state(struct radeon_device *rdev);
+ void si_dpm_post_set_power_state(struct radeon_device *rdev);
+ void si_dpm_fini(struct radeon_device *rdev);
+ void si_dpm_display_configuration_changed(struct radeon_device *rdev);
+ void si_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,
+ 						    struct seq_file *m);
+ int si_dpm_force_performance_level(struct radeon_device *rdev,
+ 				   enum radeon_dpm_forced_level level);
+ 
+ /* DCE8 - CIK */
+ void dce8_bandwidth_update(struct radeon_device *rdev);
+ 
+ /*
+  * cik
+  */
+ uint64_t cik_get_gpu_clock_counter(struct radeon_device *rdev);
+ u32 cik_get_xclk(struct radeon_device *rdev);
+ uint32_t cik_pciep_rreg(struct radeon_device *rdev, uint32_t reg);
+ void cik_pciep_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v);
+ int cik_set_uvd_clocks(struct radeon_device *rdev, u32 vclk, u32 dclk);
+ void cik_sdma_fence_ring_emit(struct radeon_device *rdev,
+ 			      struct radeon_fence *fence);
+ bool cik_sdma_semaphore_ring_emit(struct radeon_device *rdev,
+ 				  struct radeon_ring *ring,
+ 				  struct radeon_semaphore *semaphore,
+ 				  bool emit_wait);
+ void cik_sdma_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib);
+ int cik_copy_dma(struct radeon_device *rdev,
+ 		 uint64_t src_offset, uint64_t dst_offset,
+ 		 unsigned num_gpu_pages,
+ 		 struct radeon_fence **fence);
+ int cik_copy_cpdma(struct radeon_device *rdev,
+ 		   uint64_t src_offset, uint64_t dst_offset,
+ 		   unsigned num_gpu_pages,
+ 		   struct radeon_fence **fence);
+ int cik_sdma_ring_test(struct radeon_device *rdev, struct radeon_ring *ring);
+ int cik_sdma_ib_test(struct radeon_device *rdev, struct radeon_ring *ring);
+ bool cik_sdma_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring);
+ void cik_fence_gfx_ring_emit(struct radeon_device *rdev,
+ 			     struct radeon_fence *fence);
+ void cik_fence_compute_ring_emit(struct radeon_device *rdev,
+ 				 struct radeon_fence *fence);
+ bool cik_semaphore_ring_emit(struct radeon_device *rdev,
+ 			     struct radeon_ring *cp,
+ 			     struct radeon_semaphore *semaphore,
+ 			     bool emit_wait);
+ void cik_pcie_gart_tlb_flush(struct radeon_device *rdev);
+ int cik_init(struct radeon_device *rdev);
+ void cik_fini(struct radeon_device *rdev);
+ int cik_suspend(struct radeon_device *rdev);
+ int cik_resume(struct radeon_device *rdev);
+ bool cik_gfx_is_lockup(struct radeon_device *rdev, struct radeon_ring *cp);
+ int cik_asic_reset(struct radeon_device *rdev);
+ void cik_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib);
+ int cik_ring_test(struct radeon_device *rdev, struct radeon_ring *ring);
+ int cik_ib_test(struct radeon_device *rdev, struct radeon_ring *ring);
+ int cik_irq_set(struct radeon_device *rdev);
+ int cik_irq_process(struct radeon_device *rdev);
+ int cik_vm_init(struct radeon_device *rdev);
+ void cik_vm_fini(struct radeon_device *rdev);
+ void cik_vm_flush(struct radeon_device *rdev, int ridx, struct radeon_vm *vm);
+ void cik_sdma_vm_set_page(struct radeon_device *rdev,
+ 			  struct radeon_ib *ib,
+ 			  uint64_t pe,
+ 			  uint64_t addr, unsigned count,
+ 			  uint32_t incr, uint32_t flags);
+ void cik_dma_vm_flush(struct radeon_device *rdev, int ridx, struct radeon_vm *vm);
+ int cik_ib_parse(struct radeon_device *rdev, struct radeon_ib *ib);
+ u32 cik_gfx_get_rptr(struct radeon_device *rdev,
+ 		     struct radeon_ring *ring);
+ u32 cik_gfx_get_wptr(struct radeon_device *rdev,
+ 		     struct radeon_ring *ring);
+ void cik_gfx_set_wptr(struct radeon_device *rdev,
+ 		      struct radeon_ring *ring);
+ u32 cik_compute_get_rptr(struct radeon_device *rdev,
+ 			 struct radeon_ring *ring);
+ u32 cik_compute_get_wptr(struct radeon_device *rdev,
+ 			 struct radeon_ring *ring);
+ void cik_compute_set_wptr(struct radeon_device *rdev,
+ 			  struct radeon_ring *ring);
+ u32 cik_sdma_get_rptr(struct radeon_device *rdev,
+ 		      struct radeon_ring *ring);
+ u32 cik_sdma_get_wptr(struct radeon_device *rdev,
+ 		      struct radeon_ring *ring);
+ void cik_sdma_set_wptr(struct radeon_device *rdev,
+ 		       struct radeon_ring *ring);
+ int ci_get_temp(struct radeon_device *rdev);
+ int kv_get_temp(struct radeon_device *rdev);
+ 
+ int ci_dpm_init(struct radeon_device *rdev);
+ int ci_dpm_enable(struct radeon_device *rdev);
+ int ci_dpm_late_enable(struct radeon_device *rdev);
+ void ci_dpm_disable(struct radeon_device *rdev);
+ int ci_dpm_pre_set_power_state(struct radeon_device *rdev);
+ int ci_dpm_set_power_state(struct radeon_device *rdev);
+ void ci_dpm_post_set_power_state(struct radeon_device *rdev);
+ void ci_dpm_setup_asic(struct radeon_device *rdev);
+ void ci_dpm_display_configuration_changed(struct radeon_device *rdev);
+ void ci_dpm_fini(struct radeon_device *rdev);
+ u32 ci_dpm_get_sclk(struct radeon_device *rdev, bool low);
+ u32 ci_dpm_get_mclk(struct radeon_device *rdev, bool low);
+ void ci_dpm_print_power_state(struct radeon_device *rdev,
+ 			      struct radeon_ps *ps);
+ void ci_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,
+ 						    struct seq_file *m);
+ int ci_dpm_force_performance_level(struct radeon_device *rdev,
+ 				   enum radeon_dpm_forced_level level);
+ bool ci_dpm_vblank_too_short(struct radeon_device *rdev);
+ void ci_dpm_powergate_uvd(struct radeon_device *rdev, bool gate);
+ 
+ int kv_dpm_init(struct radeon_device *rdev);
+ int kv_dpm_enable(struct radeon_device *rdev);
+ int kv_dpm_late_enable(struct radeon_device *rdev);
+ void kv_dpm_disable(struct radeon_device *rdev);
+ int kv_dpm_pre_set_power_state(struct radeon_device *rdev);
+ int kv_dpm_set_power_state(struct radeon_device *rdev);
+ void kv_dpm_post_set_power_state(struct radeon_device *rdev);
+ void kv_dpm_setup_asic(struct radeon_device *rdev);
+ void kv_dpm_display_configuration_changed(struct radeon_device *rdev);
+ void kv_dpm_fini(struct radeon_device *rdev);
+ u32 kv_dpm_get_sclk(struct radeon_device *rdev, bool low);
+ u32 kv_dpm_get_mclk(struct radeon_device *rdev, bool low);
+ void kv_dpm_print_power_state(struct radeon_device *rdev,
+ 			      struct radeon_ps *ps);
+ void kv_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,
+ 						    struct seq_file *m);
+ int kv_dpm_force_performance_level(struct radeon_device *rdev,
+ 				   enum radeon_dpm_forced_level level);
+ void kv_dpm_powergate_uvd(struct radeon_device *rdev, bool gate);
+ void kv_dpm_enable_bapm(struct radeon_device *rdev, bool enable);
+ 
+ /* uvd v1.0 */
+ uint32_t uvd_v1_0_get_rptr(struct radeon_device *rdev,
+                            struct radeon_ring *ring);
+ uint32_t uvd_v1_0_get_wptr(struct radeon_device *rdev,
+                            struct radeon_ring *ring);
+ void uvd_v1_0_set_wptr(struct radeon_device *rdev,
+                        struct radeon_ring *ring);
+ 
+ int uvd_v1_0_init(struct radeon_device *rdev);
+ void uvd_v1_0_fini(struct radeon_device *rdev);
+ int uvd_v1_0_start(struct radeon_device *rdev);
+ void uvd_v1_0_stop(struct radeon_device *rdev);
+ 
+ int uvd_v1_0_ring_test(struct radeon_device *rdev, struct radeon_ring *ring);
+ int uvd_v1_0_ib_test(struct radeon_device *rdev, struct radeon_ring *ring);
+ bool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,
+ 			     struct radeon_ring *ring,
+ 			     struct radeon_semaphore *semaphore,
+ 			     bool emit_wait);
+ void uvd_v1_0_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib);
+ 
+ /* uvd v2.2 */
+ int uvd_v2_2_resume(struct radeon_device *rdev);
+ void uvd_v2_2_fence_emit(struct radeon_device *rdev,
+ 			 struct radeon_fence *fence);
+ 
+ /* uvd v3.1 */
+ bool uvd_v3_1_semaphore_emit(struct radeon_device *rdev,
+ 			     struct radeon_ring *ring,
+ 			     struct radeon_semaphore *semaphore,
+ 			     bool emit_wait);
+ 
+ /* uvd v4.2 */
+ int uvd_v4_2_resume(struct radeon_device *rdev);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  
  #endif
diff --cc drivers/gpu/drm/radeon/radeon_ring.c
index 82434018cbe8,1b783f0e6d3a..000000000000
--- a/drivers/gpu/drm/radeon/radeon_ring.c
+++ b/drivers/gpu/drm/radeon/radeon_ring.c
@@@ -693,27 -659,18 +693,37 @@@ int radeon_ring_restore(struct radeon_d
   * @ring: radeon_ring structure holding ring information
   * @ring_size: size of the ring
   * @rptr_offs: offset of the rptr writeback location in the WB buffer
++<<<<<<< HEAD
 + * @rptr_reg: MMIO offset of the rptr register
 + * @wptr_reg: MMIO offset of the wptr register
 + * @ptr_reg_shift: bit offset of the rptr/wptr values
 + * @ptr_reg_mask: bit mask of the rptr/wptr values
++=======
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
   * @nop: nop packet for this ring
   *
   * Initialize the driver information for the selected ring (all asics).
   * Returns 0 on success, error on failure.
   */
  int radeon_ring_init(struct radeon_device *rdev, struct radeon_ring *ring, unsigned ring_size,
++<<<<<<< HEAD
 +		     unsigned rptr_offs, unsigned rptr_reg, unsigned wptr_reg,
 +		     u32 ptr_reg_shift, u32 ptr_reg_mask, u32 nop)
++=======
+ 		     unsigned rptr_offs, u32 nop)
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  {
  	int r;
  
  	ring->ring_size = ring_size;
  	ring->rptr_offs = rptr_offs;
++<<<<<<< HEAD
 +	ring->rptr_reg = rptr_reg;
 +	ring->wptr_reg = wptr_reg;
 +	ring->ptr_reg_shift = ptr_reg_shift;
 +	ring->ptr_reg_mask = ptr_reg_mask;
++=======
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	ring->nop = nop;
  	/* Allocate ring buffer */
  	if (ring->ring_obj == NULL) {
@@@ -804,20 -762,36 +814,32 @@@ static int radeon_debugfs_ring_info(str
  
  	radeon_ring_free_size(rdev, ring);
  	count = (ring->ring_size / 4) - ring->ring_free_dw;
++<<<<<<< HEAD
 +	tmp = RREG32(ring->wptr_reg) >> ring->ptr_reg_shift;
 +	seq_printf(m, "wptr(0x%04x): 0x%08x [%5d]\n", ring->wptr_reg, tmp, tmp);
 +	tmp = RREG32(ring->rptr_reg) >> ring->ptr_reg_shift;
 +	seq_printf(m, "rptr(0x%04x): 0x%08x [%5d]\n", ring->rptr_reg, tmp, tmp);
++=======
+ 
+ 	wptr = radeon_ring_get_wptr(rdev, ring);
+ 	seq_printf(m, "wptr: 0x%08x [%5d]\n",
+ 		   wptr, wptr);
+ 
+ 	rptr = radeon_ring_get_rptr(rdev, ring);
+ 	seq_printf(m, "rptr: 0x%08x [%5d]\n",
+ 		   rptr, rptr);
+ 
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (ring->rptr_save_reg) {
 -		rptr_next = RREG32(ring->rptr_save_reg);
 -		seq_printf(m, "rptr next(0x%04x): 0x%08x [%5d]\n",
 -			   ring->rptr_save_reg, rptr_next, rptr_next);
 -	} else
 -		rptr_next = ~0;
 -
 -	seq_printf(m, "driver's copy of the wptr: 0x%08x [%5d]\n",
 -		   ring->wptr, ring->wptr);
 -	seq_printf(m, "driver's copy of the rptr: 0x%08x [%5d]\n",
 -		   ring->rptr, ring->rptr);
 -	seq_printf(m, "last semaphore signal addr : 0x%016llx\n",
 -		   ring->last_semaphore_signal_addr);
 -	seq_printf(m, "last semaphore wait addr   : 0x%016llx\n",
 -		   ring->last_semaphore_wait_addr);
 +		seq_printf(m, "rptr next(0x%04x): 0x%08x\n", ring->rptr_save_reg,
 +			   RREG32(ring->rptr_save_reg));
 +	}
 +	seq_printf(m, "driver's copy of the wptr: 0x%08x [%5d]\n", ring->wptr, ring->wptr);
 +	seq_printf(m, "driver's copy of the rptr: 0x%08x [%5d]\n", ring->rptr, ring->rptr);
 +	seq_printf(m, "last semaphore signal addr : 0x%016llx\n", ring->last_semaphore_signal_addr);
 +	seq_printf(m, "last semaphore wait addr   : 0x%016llx\n", ring->last_semaphore_wait_addr);
  	seq_printf(m, "%u free dwords in ring\n", ring->ring_free_dw);
  	seq_printf(m, "%u dwords in ring\n", count);
 -
 -	if (!ring->ready)
 -		return 0;
 -
  	/* print 8 dw before current rptr as often it's the last executed
  	 * packet that is the root issue
  	 */
diff --cc drivers/gpu/drm/radeon/rv770.c
index 4a62ad2e5399,82e06e9a76d2..000000000000
--- a/drivers/gpu/drm/radeon/rv770.c
+++ b/drivers/gpu/drm/radeon/rv770.c
@@@ -1903,15 -1720,13 +1903,23 @@@ static int rv770_startup(struct radeon_
  
  	ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     R600_CP_RB_RPTR, R600_CP_RB_WPTR,
 +			     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 			     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     DMA_RB_RPTR, DMA_RB_WPTR,
 +			     2, 0x3fffc, DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));
++=======
+ 			     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
@@@ -1928,12 -1743,10 +1936,17 @@@
  
  	ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];
  	if (ring->ring_size) {
++<<<<<<< HEAD
 +		r = radeon_ring_init(rdev, ring, ring->ring_size,
 +				     R600_WB_UVD_RPTR_OFFSET,
 +				     UVD_RBC_RB_RPTR, UVD_RBC_RB_WPTR,
 +				     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 		r = radeon_ring_init(rdev, ring, ring->ring_size, 0,
+ 				     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  		if (!r)
 -			r = uvd_v1_0_init(rdev);
 +			r = r600_uvd_init(rdev);
  
  		if (r)
  			DRM_ERROR("radeon: failed initializing UVD (%d).\n", r);
diff --cc drivers/gpu/drm/radeon/si.c
index a1b0da6b5808,c698e3fe007a..000000000000
--- a/drivers/gpu/drm/radeon/si.c
+++ b/drivers/gpu/drm/radeon/si.c
@@@ -5366,38 -6412,31 +5366,58 @@@ static int si_startup(struct radeon_dev
  
  	ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     CP_RB0_RPTR, CP_RB0_WPTR,
 +			     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 			     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP1_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     CP_RB1_RPTR, CP_RB1_WPTR,
 +			     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 			     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP2_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     CP_RB2_RPTR, CP_RB2_WPTR,
 +			     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 			     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     DMA_RB_RPTR + DMA0_REGISTER_OFFSET,
 +			     DMA_RB_WPTR + DMA0_REGISTER_OFFSET,
 +			     2, 0x3fffc, DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0, 0));
++=======
+ 			     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0, 0));
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
  	ring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];
  	r = radeon_ring_init(rdev, ring, ring->ring_size, CAYMAN_WB_DMA1_RPTR_OFFSET,
++<<<<<<< HEAD
 +			     DMA_RB_RPTR + DMA1_REGISTER_OFFSET,
 +			     DMA_RB_WPTR + DMA1_REGISTER_OFFSET,
 +			     2, 0x3fffc, DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0, 0));
++=======
+ 			     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0, 0));
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  	if (r)
  		return r;
  
@@@ -5415,12 -6454,10 +5435,17 @@@
  	if (rdev->has_uvd) {
  		ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];
  		if (ring->ring_size) {
++<<<<<<< HEAD
 +			r = radeon_ring_init(rdev, ring, ring->ring_size,
 +					     R600_WB_UVD_RPTR_OFFSET,
 +					     UVD_RBC_RB_RPTR, UVD_RBC_RB_WPTR,
 +					     0, 0xfffff, RADEON_CP_PACKET2);
++=======
+ 			r = radeon_ring_init(rdev, ring, ring->ring_size, 0,
+ 					     RADEON_CP_PACKET2);
++>>>>>>> ea31bf697d27 (drm/radeon: remove generic rptr/wptr functions (v2))
  			if (!r)
 -				r = uvd_v1_0_init(rdev);
 +				r = r600_uvd_init(rdev);
  			if (r)
  				DRM_ERROR("radeon: failed initializing UVD (%d).\n", r);
  		}
* Unmerged path drivers/gpu/drm/radeon/cik.c
* Unmerged path drivers/gpu/drm/radeon/cik_sdma.c
* Unmerged path drivers/gpu/drm/radeon/ni_dma.c
* Unmerged path drivers/gpu/drm/radeon/r600_dma.c
* Unmerged path drivers/gpu/drm/radeon/cik.c
* Unmerged path drivers/gpu/drm/radeon/cik_sdma.c
* Unmerged path drivers/gpu/drm/radeon/evergreen.c
* Unmerged path drivers/gpu/drm/radeon/ni.c
* Unmerged path drivers/gpu/drm/radeon/ni_dma.c
* Unmerged path drivers/gpu/drm/radeon/r100.c
* Unmerged path drivers/gpu/drm/radeon/r600.c
* Unmerged path drivers/gpu/drm/radeon/r600_dma.c
* Unmerged path drivers/gpu/drm/radeon/radeon.h
* Unmerged path drivers/gpu/drm/radeon/radeon_asic.c
* Unmerged path drivers/gpu/drm/radeon/radeon_asic.h
* Unmerged path drivers/gpu/drm/radeon/radeon_ring.c
* Unmerged path drivers/gpu/drm/radeon/rv770.c
* Unmerged path drivers/gpu/drm/radeon/si.c
