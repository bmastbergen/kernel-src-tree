stop_machine: Fix race between stop_two_cpus() and stop_cpus()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [kernel] stop_machine: fix race between stop_two_cpus and stop_cpus (Rik van Riel) [1023627]
Rebuild_FUZZ: 96.67%
commit-author Rik van Riel <riel@redhat.com>
commit 7053ea1a34fa8567cb5e3c39e04ace4c5d0fbeaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/7053ea1a.failed

There is a race between stop_two_cpus, and the global stop_cpus.

It is possible for two CPUs to get their stopper functions queued
"backwards" from one another, resulting in the stopper threads
getting stuck, and the system hanging. This can happen because
queuing up stoppers is not synchronized.

This patch adds synchronization between stop_cpus (a rare operation),
and stop_two_cpus.

Reported-and-Tested-by: Prarit Bhargava <prarit@redhat.com>
	Signed-off-by: Rik van Riel <riel@redhat.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
	Acked-by: Mel Gorman <mgorman@suse.de>
Link: http://lkml.kernel.org/r/20131101104146.03d1e043@annuminas.surriel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 7053ea1a34fa8567cb5e3c39e04ace4c5d0fbeaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/stop_machine.c
diff --cc kernel/stop_machine.c
index 32a6c44d8f78,84571e09c907..000000000000
--- a/kernel/stop_machine.c
+++ b/kernel/stop_machine.c
@@@ -262,16 -273,32 +271,38 @@@ int stop_two_cpus(unsigned int cpu1, un
  	set_state(&msdata, MULTI_STOP_PREPARE);
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * If we observe both CPUs active we know _cpu_down() cannot yet have
+ 	 * queued its stop_machine works and therefore ours will get executed
+ 	 * first. Or its not either one of our CPUs that's getting unplugged,
+ 	 * in which case we don't care.
+ 	 *
+ 	 * This relies on the stopper workqueues to be FIFO.
+ 	 */
+ 	if (!cpu_active(cpu1) || !cpu_active(cpu2)) {
+ 		preempt_enable();
+ 		return -ENOENT;
+ 	}
+ 
+ 	lg_local_lock(&stop_cpus_lock);
+ 	/*
++>>>>>>> 7053ea1a34fa (stop_machine: Fix race between stop_two_cpus() and stop_cpus())
  	 * Queuing needs to be done by the lowest numbered CPU, to ensure
  	 * that works are always queued in the same order on every CPU.
  	 * This prevents deadlocks.
  	 */
 -	smp_call_function_single(min(cpu1, cpu2),
 -				 &irq_cpu_stop_queue_work,
 +	call_cpu = min(cpu1, cpu2);
 +
 +	smp_call_function_single(call_cpu, &irq_cpu_stop_queue_work,
  				 &call_args, 0);
++<<<<<<< HEAD
++=======
+ 	lg_local_unlock(&stop_cpus_lock);
+ 	preempt_enable();
++>>>>>>> 7053ea1a34fa (stop_machine: Fix race between stop_two_cpus() and stop_cpus())
  
  	wait_for_completion(&done.completion);
 -
  	return done.executed ? done.ret : -ENOENT;
  }
  
* Unmerged path kernel/stop_machine.c
