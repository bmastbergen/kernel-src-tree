cpufreq: Do not hold driver module references for additional policy CPUs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [cpufreq] Do not hold driver module references for additional policy CPUs (Prarit Bhargava) [1043788]
Rebuild_FUZZ: 93.33%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 71c3461ef7c67024792d283b88630245a6c169ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/71c3461e.failed

The cpufreq core is a little inconsistent in the way it uses the
driver module refcount.

Namely, if __cpufreq_add_dev() is called for a CPU that doesn't
share the policy object with any other CPUs, the driver module
refcount it grabs to start with will be dropped by it before
returning and will be equal to whatever it had been before that
function was invoked.

However, if the given CPU does share the policy object with other
CPUs, either cpufreq_add_policy_cpu() is called to link the new CPU
to the existing policy, or cpufreq_add_dev_symlink() is used to link
the other CPUs sharing the policy with it to the just created policy
object.  In that case, because both cpufreq_add_policy_cpu() and
cpufreq_add_dev_symlink() call cpufreq_cpu_get() for the given
policy (the latter possibly many times) without the balancing
cpufreq_cpu_put() (unless there is an error), the driver module
refcount will be left by __cpufreq_add_dev() with a nonzero value
(different from the initial one).

To remove that inconsistency make cpufreq_add_policy_cpu() execute
cpufreq_cpu_put() for the given policy before returning, which
decrements the driver module refcount so that it will be equal to its
initial value after __cpufreq_add_dev() returns.  Also remove the
cpufreq_cpu_get() call from cpufreq_add_dev_symlink(), since both the
policy refcount and the driver module refcount are nonzero when it is
called and they don't need to be bumped up by it.

Accordingly, drop the cpufreq_cpu_put() from __cpufreq_remove_dev(),
since it is only necessary to balance the cpufreq_cpu_get() called
by cpufreq_add_policy_cpu() or cpufreq_add_dev_symlink().

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
(cherry picked from commit 71c3461ef7c67024792d283b88630245a6c169ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index 0b7665c6b866,c8b2ca0f44ae..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -807,7 -818,6 +807,10 @@@ static int cpufreq_add_dev_symlink(unsi
  			continue;
  
  		pr_debug("Adding link for CPU: %u\n", j);
++<<<<<<< HEAD
 +		cpufreq_cpu_get(cpu);
++=======
++>>>>>>> 71c3461ef7c6 (cpufreq: Do not hold driver module references for additional policy CPUs)
  		cpu_dev = get_cpu_device(j);
  		ret = sysfs_create_link(&cpu_dev->kobj, &policy->kobj,
  					"cpufreq");
@@@ -922,13 -927,12 +924,22 @@@ static int cpufreq_add_policy_cpu(unsig
  		__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
  	}
  
++<<<<<<< HEAD
 +	ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
 +	if (ret) {
 +		cpufreq_cpu_put(policy);
 +		return ret;
 +	}
 +
 +	return 0;
++=======
+ 	/* Don't touch sysfs links during light-weight init */
+ 	if (!frozen)
+ 		ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
+ 
+ 	cpufreq_cpu_put(policy);
+ 	return ret;
++>>>>>>> 71c3461ef7c6 (cpufreq: Do not hold driver module references for additional policy CPUs)
  }
  #endif
  
@@@ -1186,12 -1287,9 +1197,15 @@@ static int __cpufreq_remove_dev(struct 
  		if (cpufreq_driver->exit)
  			cpufreq_driver->exit(data);
  
 -		if (!frozen)
 -			cpufreq_policy_free(data);
 +		free_cpumask_var(data->related_cpus);
 +		free_cpumask_var(data->cpus);
 +		kfree(data);
  	} else {
++<<<<<<< HEAD
 +		pr_debug("%s: removing link, cpu: %d\n", __func__, cpu);
 +		cpufreq_cpu_put(data);
++=======
++>>>>>>> 71c3461ef7c6 (cpufreq: Do not hold driver module references for additional policy CPUs)
  		if (cpufreq_driver->target) {
  			__cpufreq_governor(data, CPUFREQ_GOV_START);
  			__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
* Unmerged path drivers/cpufreq/cpufreq.c
