GFS2: If requested is too large, use the largest extent in the rgrp

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 5ce13431dd3365d5dd4f3890394dac59b687c0ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/5ce13431.failed

Here is a second try at a patch I posted earlier, which also implements
suggestions Steve made:

Before this patch, GFS2 would keep searching through all the rgrps
until it found one that had a chunk of free blocks big enough to
satisfy the size hint, which is based on the file write size,
regardless of whether the chunk was big enough to perform the write.
However, when doing big writes there may not be a large enough
chunk of free blocks in any rgrp, due to file system fragmentation.
The largest chunk may be big enough to satisfy the write request,
but it may not meet the ideal reservation size from the "size hint".
The writes would slow to a crawl because every write would search
every rgrp, then finally give up and default to a single-block write.
In my case, performance would drop from 425MB/s to 18KB/s, or 24000
times slower.

This patch basically makes it so that if we can't find a contiguous
chunk of blocks big enough to satisfy the sizehint, we'll use the
largest chunk of blocks we found that will still contain the write.
It does so by keeping track of the largest run of blocks within the
rgrp.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
(cherry picked from commit 5ce13431dd3365d5dd4f3890394dac59b687c0ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/rgrp.c
diff --cc fs/gfs2/rgrp.c
index 8a321e6e1175,809fecd82970..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -1548,11 -1597,12 +1565,12 @@@ fail
   * Returns: 0 on success, -ENOSPC if there is no block of the requested state
   */
  
- static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 minext,
- 			 const struct gfs2_inode *ip, bool nowrap)
+ static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,
+ 			 const struct gfs2_inode *ip, bool nowrap,
+ 			 const struct gfs2_alloc_parms *ap)
  {
  	struct buffer_head *bh;
 -	int initial_bii;
 +	struct gfs2_bitmap *initial_bi;
  	u32 initial_offset;
  	u32 offset;
  	u8 *buffer;
@@@ -1560,6 -1609,8 +1578,11 @@@
  	int n = 0;
  	int iters = rbm->rgd->rd_length;
  	int ret;
++<<<<<<< HEAD
++=======
+ 	struct gfs2_bitmap *bi;
+ 	struct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };
++>>>>>>> 5ce13431dd33 (GFS2: If requested is too large, use the largest extent in the rgrp)
  
  	/* If we are not starting at the beginning of a bitmap, then we
  	 * need to add one to the bitmap count to ensure that we search
@@@ -1586,8 -1638,10 +1609,15 @@@
  		if (ip == NULL)
  			return 0;
  
++<<<<<<< HEAD
 +		initial_bi = rbm->bi;
 +		ret = gfs2_reservation_check_and_update(rbm, ip, minext);
++=======
+ 		initial_bii = rbm->bii;
+ 		ret = gfs2_reservation_check_and_update(rbm, ip,
+ 							minext ? *minext : 0,
+ 							&maxext);
++>>>>>>> 5ce13431dd33 (GFS2: If requested is too large, use the largest extent in the rgrp)
  		if (ret == 0)
  			return 0;
  		if (ret > 0) {
@@@ -2122,19 -2216,13 +2164,29 @@@ int gfs2_alloc_blocks(struct gfs2_inod
  	u64 block; /* block, within the file system scope */
  	int error;
  
++<<<<<<< HEAD
 +	if (gfs2_rs_active(ip->i_res))
 +		goal = gfs2_rbm_to_block(&ip->i_res->rs_rbm);
 +	else if (!dinode && rgrp_contains_block(rbm.rgd, ip->i_goal))
 +		goal = ip->i_goal;
 +	else
 +		goal = rbm.rgd->rd_last_alloc + rbm.rgd->rd_data0;
 +
 +	gfs2_rbm_from_block(&rbm, goal);
 +	error = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, 0, ip, false);
 +
 +	if (error == -ENOSPC) {
 +		gfs2_rbm_from_block(&rbm, goal);
 +		error = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, 0, NULL, false);
++=======
+ 	gfs2_set_alloc_start(&rbm, ip, dinode);
+ 	error = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);
+ 
+ 	if (error == -ENOSPC) {
+ 		gfs2_set_alloc_start(&rbm, ip, dinode);
+ 		error = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,
+ 				      NULL);
++>>>>>>> 5ce13431dd33 (GFS2: If requested is too large, use the largest extent in the rgrp)
  	}
  
  	/* Since all blocks are reserved in advance, this shouldn't happen */
* Unmerged path fs/gfs2/rgrp.c
