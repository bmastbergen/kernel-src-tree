net: convert resend IGMP to notifier event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] convert resend IGMP to notifier event (Jiri Pirko) [1069520]
Rebuild_FUZZ: 93.67%
commit-author Jiri Pirko <jiri@resnulli.us>
commit 4aa5dee4d9997879adff858514844efab5a15a01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/4aa5dee4.failed

Until now, bond_resend_igmp_join_requests() looks for vlans attached to
bonding device, bridge where bonding act as port manually. It does not
care of other scenarios, like stacked bonds or team device above. Make
this more generic and use netdev notifier to propagate the event to
upper devices and to actually call ip_mc_rejoin_groups().

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Acked-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4aa5dee4d9997879adff858514844efab5a15a01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	include/linux/netdevice.h
diff --cc drivers/net/bonding/bond_main.c
index e3e7db1acee1,ae9864c9fa38..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -706,54 -715,6 +706,57 @@@ static int bond_set_allmulti(struct bon
  	return err;
  }
  
++<<<<<<< HEAD
 +/*
 + * Add a Multicast address to slaves
 + * according to mode
 + */
 +static void bond_mc_add(struct bonding *bond, void *addr)
 +{
 +	if (USES_PRIMARY(bond->params.mode)) {
 +		/* write lock already acquired */
 +		if (bond->curr_active_slave)
 +			dev_mc_add(bond->curr_active_slave->dev, addr);
 +	} else {
 +		struct slave *slave;
 +		int i;
 +
 +		bond_for_each_slave(bond, slave, i)
 +			dev_mc_add(slave->dev, addr);
 +	}
 +}
 +
 +/*
 + * Remove a multicast address from slave
 + * according to mode
 + */
 +static void bond_mc_del(struct bonding *bond, void *addr)
 +{
 +	if (USES_PRIMARY(bond->params.mode)) {
 +		/* write lock already acquired */
 +		if (bond->curr_active_slave)
 +			dev_mc_del(bond->curr_active_slave->dev, addr);
 +	} else {
 +		struct slave *slave;
 +		int i;
 +		bond_for_each_slave(bond, slave, i) {
 +			dev_mc_del(slave->dev, addr);
 +		}
 +	}
 +}
 +
 +
 +static void __bond_resend_igmp_join_requests(struct net_device *dev)
 +{
 +	struct in_device *in_dev;
 +
 +	in_dev = __in_dev_get_rcu(dev);
 +	if (in_dev)
 +		ip_mc_rejoin_groups(in_dev);
 +}
 +
++=======
++>>>>>>> 4aa5dee4d999 (net: convert resend IGMP to notifier event)
  /*
   * Retrieve the list of registered multicast addresses for the bonding
   * device and retransmit an IGMP JOIN request to the current active
diff --cc include/linux/netdevice.h
index 8c357c3b8198,2bb2357d83bb..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1664,6 -1632,8 +1664,11 @@@ struct packet_offload 
  #define NETDEV_RELEASE		0x0012
  #define NETDEV_NOTIFY_PEERS	0x0013
  #define NETDEV_JOIN		0x0014
++<<<<<<< HEAD
++=======
+ #define NETDEV_CHANGEUPPER	0x0015
+ #define NETDEV_RESEND_IGMP	0x0016
++>>>>>>> 4aa5dee4d999 (net: convert resend IGMP to notifier event)
  
  extern int register_netdevice_notifier(struct notifier_block *nb);
  extern int unregister_netdevice_notifier(struct notifier_block *nb);
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c
index a0b6fec27697..3036ff115106 100644
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@ -2789,6 +2789,10 @@ static int team_device_event(struct notifier_block *unused,
 	case NETDEV_PRE_TYPE_CHANGE:
 		/* Forbid to change type of underlaying device */
 		return NOTIFY_BAD;
+	case NETDEV_RESEND_IGMP:
+		/* Propagate to master device */
+		call_netdevice_notifiers(event, port->team->dev);
+		break;
 	}
 	return NOTIFY_DONE;
 }
diff --git a/include/linux/igmp.h b/include/linux/igmp.h
index 7f2bf1518480..d88f60f71a94 100644
--- a/include/linux/igmp.h
+++ b/include/linux/igmp.h
@@ -128,6 +128,5 @@ extern void ip_mc_unmap(struct in_device *);
 extern void ip_mc_remap(struct in_device *);
 extern void ip_mc_dec_group(struct in_device *in_dev, __be32 addr);
 extern void ip_mc_inc_group(struct in_device *in_dev, __be32 addr);
-extern void ip_mc_rejoin_groups(struct in_device *in_dev);
 
 #endif
* Unmerged path include/linux/netdevice.h
diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c
index 5999a8a2c1de..8d73845771a0 100644
--- a/net/8021q/vlan.c
+++ b/net/8021q/vlan.c
@@ -461,6 +461,7 @@ static int vlan_device_event(struct notifier_block *unused, unsigned long event,
 
 	case NETDEV_NOTIFY_PEERS:
 	case NETDEV_BONDING_FAILOVER:
+	case NETDEV_RESEND_IGMP:
 		/* Propagate to vlan devices */
 		vlan_group_for_each_dev(grp, i, vlandev)
 			call_netdevice_notifiers(event, vlandev);
diff --git a/net/bridge/br_notify.c b/net/bridge/br_notify.c
index 1644b3e1f947..7800ad84fd97 100644
--- a/net/bridge/br_notify.c
+++ b/net/bridge/br_notify.c
@@ -102,6 +102,11 @@ static int br_device_event(struct notifier_block *unused, unsigned long event, v
 	case NETDEV_PRE_TYPE_CHANGE:
 		/* Forbid underlaying device to change its type. */
 		return NOTIFY_BAD;
+
+	case NETDEV_RESEND_IGMP:
+		/* Propagate to master device */
+		call_netdevice_notifiers(event, br->dev);
+		break;
 	}
 
 	/* Events that may cause spanning tree to refresh */
diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c
index 10b78cc9cdf2..23cc3cbbddc7 100644
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@ -1273,16 +1273,17 @@ out:
 EXPORT_SYMBOL(ip_mc_inc_group);
 
 /*
- *	Resend IGMP JOIN report; used for bonding.
- *	Called with rcu_read_lock()
+ *	Resend IGMP JOIN report; used by netdev notifier.
  */
-void ip_mc_rejoin_groups(struct in_device *in_dev)
+static void ip_mc_rejoin_groups(struct in_device *in_dev)
 {
 #ifdef CONFIG_IP_MULTICAST
 	struct ip_mc_list *im;
 	int type;
 
-	for_each_pmc_rcu(in_dev, im) {
+	ASSERT_RTNL();
+
+	for_each_pmc_rtnl(in_dev, im) {
 		if (im->multiaddr == IGMP_ALL_HOSTS)
 			continue;
 
@@ -1299,7 +1300,6 @@ void ip_mc_rejoin_groups(struct in_device *in_dev)
 	}
 #endif
 }
-EXPORT_SYMBOL(ip_mc_rejoin_groups);
 
 /*
  *	A socket has left a multicast group on device dev
@@ -2675,8 +2675,42 @@ static struct pernet_operations igmp_net_ops = {
 	.exit = igmp_net_exit,
 };
 
+static int igmp_netdev_event(struct notifier_block *this,
+			     unsigned long event, void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+	struct in_device *in_dev;
+
+	switch (event) {
+	case NETDEV_RESEND_IGMP:
+		in_dev = __in_dev_get_rtnl(dev);
+		if (in_dev)
+			ip_mc_rejoin_groups(in_dev);
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block igmp_notifier = {
+	.notifier_call = igmp_netdev_event,
+};
+
 int __init igmp_mc_proc_init(void)
 {
-	return register_pernet_subsys(&igmp_net_ops);
+	int err;
+
+	err = register_pernet_subsys(&igmp_net_ops);
+	if (err)
+		return err;
+	err = register_netdevice_notifier(&igmp_notifier);
+	if (err)
+		goto reg_notif_fail;
+	return 0;
+
+reg_notif_fail:
+	unregister_pernet_subsys(&igmp_net_ops);
+	return err;
 }
 #endif
