xfs: remove xfs_iunlock_map_shared

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Christoph Hellwig <hch@infradead.org>
commit 01f4f3277556d4f4f833371db0219b0ca11c5409
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/01f4f327.failed

We can just use xfs_iunlock without any loss of clarity.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 01f4f3277556d4f4f833371db0219b0ca11c5409)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index a18b684cea27,967f90625eae..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -383,6 -554,49 +370,52 @@@ xfs_dic2xflags
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Lookups up an inode from "name". If ci_name is not NULL, then a CI match
+  * is allowed, otherwise it has to be an exact match. If a CI match is found,
+  * ci_name->name will point to a the actual name (caller must free) or
+  * will be set to NULL if an exact match is found.
+  */
+ int
+ xfs_lookup(
+ 	xfs_inode_t		*dp,
+ 	struct xfs_name		*name,
+ 	xfs_inode_t		**ipp,
+ 	struct xfs_name		*ci_name)
+ {
+ 	xfs_ino_t		inum;
+ 	int			error;
+ 	uint			lock_mode;
+ 
+ 	trace_xfs_lookup(dp, name);
+ 
+ 	if (XFS_FORCED_SHUTDOWN(dp->i_mount))
+ 		return XFS_ERROR(EIO);
+ 
+ 	lock_mode = xfs_ilock_map_shared(dp);
+ 	error = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);
+ 	xfs_iunlock(dp, lock_mode);
+ 
+ 	if (error)
+ 		goto out;
+ 
+ 	error = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);
+ 	if (error)
+ 		goto out_free_name;
+ 
+ 	return 0;
+ 
+ out_free_name:
+ 	if (ci_name)
+ 		kmem_free(ci_name->name);
+ out:
+ 	*ipp = NULL;
+ 	return error;
+ }
+ 
+ /*
++>>>>>>> 01f4f3277556 (xfs: remove xfs_iunlock_map_shared)
   * Allocate an inode on disk and return a copy of its in-core version.
   * The in-core inode is locked exclusively.  Set mode, nlink, and rdev
   * appropriately within the inode.  The uid and gid for the inode are
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index e877b47203d1..7af2eeec3511 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -735,7 +735,7 @@ xfs_getbmap(
  out_free_map:
 	kmem_free(map);
  out_unlock_ilock:
-	xfs_iunlock_map_shared(ip, lock);
+	xfs_iunlock(ip, lock);
  out_unlock_iolock:
 	xfs_iunlock(ip, XFS_IOLOCK_SHARED);
 
diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c
index 3be477a9f116..a266daa2996c 100644
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@ -1278,7 +1278,7 @@ out:
 		file->f_pos = offset;
 
 out_unlock:
-	xfs_iunlock_map_shared(ip, lock);
+	xfs_iunlock(ip, lock);
 
 	if (error)
 		return -error;
@@ -1387,7 +1387,7 @@ out:
 		file->f_pos = offset;
 
 out_unlock:
-	xfs_iunlock_map_shared(ip, lock);
+	xfs_iunlock(ip, lock);
 
 	if (error)
 		return -error;
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index 8f775ed722a9..4f73dd4f2a37 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -324,7 +324,6 @@ void		xfs_iunlock(xfs_inode_t *, uint);
 void		xfs_ilock_demote(xfs_inode_t *, uint);
 int		xfs_isilocked(xfs_inode_t *, uint);
 uint		xfs_ilock_map_shared(xfs_inode_t *);
-void		xfs_iunlock_map_shared(xfs_inode_t *, uint);
 int		xfs_ialloc(struct xfs_trans *, xfs_inode_t *, umode_t,
 			   xfs_nlink_t, xfs_dev_t, prid_t, int,
 			   struct xfs_buf **, xfs_inode_t **);
