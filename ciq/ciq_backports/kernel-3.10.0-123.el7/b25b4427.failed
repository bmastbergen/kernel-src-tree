drm/nouveau: only runtime suspend by default in optimus configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [drm] nouveau: only runtime suspend by default in optimus configuration (Rob Clark) [1054409]
Rebuild_FUZZ: 97.01%
commit-author Ilia Mirkin <imirkin@alum.mit.edu>
commit b25b4427e9dfba073cf9bc86603956ed395eb6e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/b25b4427.failed

The intent was to only enable it by default for optimus, e.g. see the
runtime_idle callback. The suspend callback may be called directly, e.g.
as a result of nouveau_crtc_set_config.

	Reported-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>
	Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
	Tested-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>
	Cc: stable@vger.kernel.org
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit b25b4427e9dfba073cf9bc86603956ed395eb6e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nouveau_drm.c
diff --cc drivers/gpu/drm/nouveau/nouveau_drm.c
index 2850ed0cc755,98a22e6e27a1..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_drm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c
@@@ -739,6 -849,99 +739,102 @@@ nouveau_drm_pci_table[] = 
  	{}
  };
  
++<<<<<<< HEAD
++=======
+ static int nouveau_pmops_runtime_suspend(struct device *dev)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+ 	int ret;
+ 
+ 	if (nouveau_runtime_pm == 0)
+ 		return -EINVAL;
+ 
+ 	/* are we optimus enabled? */
+ 	if (nouveau_runtime_pm == -1 && !nouveau_is_optimus() && !nouveau_is_v1_dsm()) {
+ 		DRM_DEBUG_DRIVER("failing to power off - not optimus\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	nv_debug_level(SILENT);
+ 	drm_kms_helper_poll_disable(drm_dev);
+ 	vga_switcheroo_set_dynamic_switch(pdev, VGA_SWITCHEROO_OFF);
+ 	nouveau_switcheroo_optimus_dsm();
+ 	ret = nouveau_do_suspend(drm_dev);
+ 	pci_save_state(pdev);
+ 	pci_disable_device(pdev);
+ 	pci_set_power_state(pdev, PCI_D3cold);
+ 	drm_dev->switch_power_state = DRM_SWITCH_POWER_DYNAMIC_OFF;
+ 	return ret;
+ }
+ 
+ static int nouveau_pmops_runtime_resume(struct device *dev)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+ 	struct nouveau_device *device = nouveau_dev(drm_dev);
+ 	int ret;
+ 
+ 	if (nouveau_runtime_pm == 0)
+ 		return -EINVAL;
+ 
+ 	pci_set_power_state(pdev, PCI_D0);
+ 	pci_restore_state(pdev);
+ 	ret = pci_enable_device(pdev);
+ 	if (ret)
+ 		return ret;
+ 	pci_set_master(pdev);
+ 
+ 	ret = nouveau_do_resume(drm_dev);
+ 	if (drm_dev->mode_config.num_crtc)
+ 		nouveau_display_resume(drm_dev);
+ 	drm_kms_helper_poll_enable(drm_dev);
+ 	/* do magic */
+ 	nv_mask(device, 0x88488, (1 << 25), (1 << 25));
+ 	vga_switcheroo_set_dynamic_switch(pdev, VGA_SWITCHEROO_ON);
+ 	drm_dev->switch_power_state = DRM_SWITCH_POWER_ON;
+ 	nv_debug_level(NORMAL);
+ 	return ret;
+ }
+ 
+ static int nouveau_pmops_runtime_idle(struct device *dev)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+ 	struct nouveau_drm *drm = nouveau_drm(drm_dev);
+ 	struct drm_crtc *crtc;
+ 
+ 	if (nouveau_runtime_pm == 0)
+ 		return -EBUSY;
+ 
+ 	/* are we optimus enabled? */
+ 	if (nouveau_runtime_pm == -1 && !nouveau_is_optimus() && !nouveau_is_v1_dsm()) {
+ 		DRM_DEBUG_DRIVER("failing to power off - not optimus\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	/* if we have a hdmi audio device - make sure it has a driver loaded */
+ 	if (drm->hdmi_device) {
+ 		if (!drm->hdmi_device->driver) {
+ 			DRM_DEBUG_DRIVER("failing to power off - no HDMI audio driver loaded\n");
+ 			pm_runtime_mark_last_busy(dev);
+ 			return -EBUSY;
+ 		}
+ 	}
+ 
+ 	list_for_each_entry(crtc, &drm->dev->mode_config.crtc_list, head) {
+ 		if (crtc->enabled) {
+ 			DRM_DEBUG_DRIVER("failing to power off - crtc active\n");
+ 			return -EBUSY;
+ 		}
+ 	}
+ 	pm_runtime_mark_last_busy(dev);
+ 	pm_runtime_autosuspend(dev);
+ 	/* we don't want the main rpm_idle to call suspend - we want to autosuspend */
+ 	return 1;
+ }
+ 
++>>>>>>> b25b4427e9df (drm/nouveau: only runtime suspend by default in optimus configuration)
  static const struct dev_pm_ops nouveau_pm_ops = {
  	.suspend = nouveau_pmops_suspend,
  	.resume = nouveau_pmops_resume,
* Unmerged path drivers/gpu/drm/nouveau/nouveau_drm.c
