netfilter: nf_tables: add "inet" table for IPv4/IPv6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 1d49144c0aaa61be4e3ccbef9cc5c40b0ec5f2fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/1d49144c.failed

This patch adds a new table family and a new filter chain that you can
use to attach IPv4 and IPv6 rules. This should help to simplify
rule-set maintainance in dual-stack setups.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 1d49144c0aaa61be4e3ccbef9cc5c40b0ec5f2fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables_ipv4.h
#	include/net/netfilter/nf_tables_ipv6.h
#	include/net/netns/nftables.h
#	net/ipv4/netfilter/nf_tables_ipv4.c
#	net/ipv6/netfilter/nf_tables_ipv6.c
#	net/netfilter/Kconfig
#	net/netfilter/Makefile
diff --cc net/netfilter/Kconfig
index 112ddfea8c1a,37d2092705a7..000000000000
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@@ -408,8 -408,128 +408,128 @@@ config NF_NAT_TFT
  	depends on NF_CONNTRACK && NF_NAT
  	default NF_NAT && NF_CONNTRACK_TFTP
  
 -config NETFILTER_SYNPROXY
 -	tristate
 -
  endif # NF_CONNTRACK
  
++<<<<<<< HEAD
++=======
+ config NF_TABLES
+ 	select NETFILTER_NETLINK
+ 	tristate "Netfilter nf_tables support"
+ 	help
+ 	  nftables is the new packet classification framework that intends to
+ 	  replace the existing {ip,ip6,arp,eb}_tables infrastructure. It
+ 	  provides a pseudo-state machine with an extensible instruction-set
+ 	  (also known as expressions) that the userspace 'nft' utility
+ 	  (http://www.netfilter.org/projects/nftables) uses to build the
+ 	  rule-set. It also comes with the generic set infrastructure that
+ 	  allows you to construct mappings between matchings and actions
+ 	  for performance lookups.
+ 
+ 	  To compile it as a module, choose M here.
+ 
+ config NF_TABLES_INET
+ 	depends on NF_TABLES
+ 	select NF_TABLES_IPV4
+ 	select NF_TABLES_IPV6
+ 	tristate "Netfilter nf_tables mixed IPv4/IPv6 tables support"
+ 	help
+ 	  This option enables support for a mixed IPv4/IPv6 "inet" table.
+ 
+ config NFT_EXTHDR
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables IPv6 exthdr module"
+ 	help
+ 	  This option adds the "exthdr" expression that you can use to match
+ 	  IPv6 extension headers.
+ 
+ config NFT_META
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables meta module"
+ 	help
+ 	  This option adds the "meta" expression that you can use to match and
+ 	  to set packet metainformation such as the packet mark.
+ 
+ config NFT_CT
+ 	depends on NF_TABLES
+ 	depends on NF_CONNTRACK
+ 	tristate "Netfilter nf_tables conntrack module"
+ 	help
+ 	  This option adds the "meta" expression that you can use to match
+ 	  connection tracking information such as the flow state.
+ 
+ config NFT_RBTREE
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables rbtree set module"
+ 	help
+ 	  This option adds the "rbtree" set type (Red Black tree) that is used
+ 	  to build interval-based sets.
+ 
+ config NFT_HASH
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables hash set module"
+ 	help
+ 	  This option adds the "hash" set type that is used to build one-way
+ 	  mappings between matchings and actions.
+ 
+ config NFT_COUNTER
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables counter module"
+ 	help
+ 	  This option adds the "counter" expression that you can use to
+ 	  include packet and byte counters in a rule.
+ 
+ config NFT_LOG
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables log module"
+ 	help
+ 	  This option adds the "log" expression that you can use to log
+ 	  packets matching some criteria.
+ 
+ config NFT_LIMIT
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables limit module"
+ 	help
+ 	  This option adds the "limit" expression that you can use to
+ 	  ratelimit rule matchings.
+ 
+ config NFT_NAT
+ 	depends on NF_TABLES
+ 	depends on NF_CONNTRACK
+ 	depends on NF_NAT
+ 	tristate "Netfilter nf_tables nat module"
+ 	help
+ 	  This option adds the "nat" expression that you can use to perform
+ 	  typical Network Address Translation (NAT) packet transformations.
+ 
+ config NFT_QUEUE
+ 	depends on NF_TABLES
+ 	depends on NETFILTER_XTABLES
+ 	depends on NETFILTER_NETLINK_QUEUE
+ 	tristate "Netfilter nf_tables queue module"
+ 	help
+ 	  This is required if you intend to use the userspace queueing
+ 	  infrastructure (also known as NFQUEUE) from nftables.
+ 
+ config NFT_REJECT
+ 	depends on NF_TABLES
+ 	depends on NF_TABLES_IPV6 || !NF_TABLES_IPV6
+ 	default m if NETFILTER_ADVANCED=n
+ 	tristate "Netfilter nf_tables reject support"
+ 	help
+ 	  This option adds the "reject" expression that you can use to
+ 	  explicitly deny and notify via TCP reset/ICMP informational errors
+ 	  unallowed traffic.
+ 
+ config NFT_COMPAT
+ 	depends on NF_TABLES
+ 	depends on NETFILTER_XTABLES
+ 	tristate "Netfilter x_tables over nf_tables module"
+ 	help
+ 	  This is required if you intend to use any of existing
+ 	  x_tables match/target extensions over the nf_tables
+ 	  framework.
+ 
++>>>>>>> 1d49144c0aaa (netfilter: nf_tables: add "inet" table for IPv4/IPv6)
  config NETFILTER_XTABLES
  	tristate "Netfilter Xtables support (required for ip_tables)"
  	default m if NETFILTER_ADVANCED=n
diff --cc net/netfilter/Makefile
index ebfa7dc747cd,74c066109334..000000000000
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@@ -61,6 -61,29 +61,32 @@@ obj-$(CONFIG_NF_NAT_IRC) += nf_nat_irc.
  obj-$(CONFIG_NF_NAT_SIP) += nf_nat_sip.o
  obj-$(CONFIG_NF_NAT_TFTP) += nf_nat_tftp.o
  
++<<<<<<< HEAD
++=======
+ # SYNPROXY
+ obj-$(CONFIG_NETFILTER_SYNPROXY) += nf_synproxy_core.o
+ 
+ # nf_tables
+ nf_tables-objs += nf_tables_core.o nf_tables_api.o
+ nf_tables-objs += nft_immediate.o nft_cmp.o nft_lookup.o
+ nf_tables-objs += nft_bitwise.o nft_byteorder.o nft_payload.o
+ 
+ obj-$(CONFIG_NF_TABLES)		+= nf_tables.o
+ obj-$(CONFIG_NF_TABLES_INET)	+= nf_tables_inet.o
+ obj-$(CONFIG_NFT_COMPAT)	+= nft_compat.o
+ obj-$(CONFIG_NFT_EXTHDR)	+= nft_exthdr.o
+ obj-$(CONFIG_NFT_META)		+= nft_meta.o
+ obj-$(CONFIG_NFT_CT)		+= nft_ct.o
+ obj-$(CONFIG_NFT_LIMIT)		+= nft_limit.o
+ obj-$(CONFIG_NFT_NAT)		+= nft_nat.o
+ obj-$(CONFIG_NFT_QUEUE)		+= nft_queue.o
+ obj-$(CONFIG_NFT_REJECT) 	+= nft_reject.o
+ obj-$(CONFIG_NFT_RBTREE)	+= nft_rbtree.o
+ obj-$(CONFIG_NFT_HASH)		+= nft_hash.o
+ obj-$(CONFIG_NFT_COUNTER)	+= nft_counter.o
+ obj-$(CONFIG_NFT_LOG)		+= nft_log.o
+ 
++>>>>>>> 1d49144c0aaa (netfilter: nf_tables: add "inet" table for IPv4/IPv6)
  # generic X tables 
  obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
  
* Unmerged path include/net/netfilter/nf_tables_ipv4.h
* Unmerged path include/net/netfilter/nf_tables_ipv6.h
* Unmerged path include/net/netns/nftables.h
* Unmerged path net/ipv4/netfilter/nf_tables_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_tables_ipv6.c
* Unmerged path include/net/netfilter/nf_tables_ipv4.h
* Unmerged path include/net/netfilter/nf_tables_ipv6.h
* Unmerged path include/net/netns/nftables.h
diff --git a/include/uapi/linux/netfilter.h b/include/uapi/linux/netfilter.h
index f7dc0ebeeba5..ef1b1f88ca18 100644
--- a/include/uapi/linux/netfilter.h
+++ b/include/uapi/linux/netfilter.h
@@ -53,6 +53,7 @@ enum nf_inet_hooks {
 
 enum {
 	NFPROTO_UNSPEC =  0,
+	NFPROTO_INET   =  1,
 	NFPROTO_IPV4   =  2,
 	NFPROTO_ARP    =  3,
 	NFPROTO_BRIDGE =  7,
* Unmerged path net/ipv4/netfilter/nf_tables_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_tables_ipv6.c
* Unmerged path net/netfilter/Kconfig
* Unmerged path net/netfilter/Makefile
diff --git a/net/netfilter/nf_tables_inet.c b/net/netfilter/nf_tables_inet.c
new file mode 100644
index 000000000000..ac0edcb549de
--- /dev/null
+++ b/net/netfilter/nf_tables_inet.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2012-2014 Patrick McHardy <kaber@trash.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv6.h>
+#include <net/netfilter/nf_tables.h>
+#include <net/netfilter/nf_tables_ipv4.h>
+#include <net/netfilter/nf_tables_ipv6.h>
+#include <net/ip.h>
+
+static void nft_inet_hook_ops_init(struct nf_hook_ops *ops, unsigned int n)
+{
+	struct nft_af_info *afi;
+
+	if (n == 1)
+		afi = &nft_af_ipv4;
+	else
+		afi = &nft_af_ipv6;
+
+	ops->pf = afi->family;
+	if (afi->hooks[ops->hooknum])
+		ops->hook = afi->hooks[ops->hooknum];
+}
+
+static struct nft_af_info nft_af_inet __read_mostly = {
+	.family		= NFPROTO_INET,
+	.nhooks		= NF_INET_NUMHOOKS,
+	.owner		= THIS_MODULE,
+	.nops		= 2,
+	.hook_ops_init	= nft_inet_hook_ops_init,
+};
+
+static int __net_init nf_tables_inet_init_net(struct net *net)
+{
+	net->nft.inet = kmalloc(sizeof(struct nft_af_info), GFP_KERNEL);
+	if (net->nft.inet == NULL)
+		return -ENOMEM;
+	memcpy(net->nft.inet, &nft_af_inet, sizeof(nft_af_inet));
+
+	if (nft_register_afinfo(net, net->nft.inet) < 0)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(net->nft.inet);
+	return -ENOMEM;
+}
+
+static void __net_exit nf_tables_inet_exit_net(struct net *net)
+{
+	nft_unregister_afinfo(net->nft.inet);
+	kfree(net->nft.inet);
+}
+
+static struct pernet_operations nf_tables_inet_net_ops = {
+	.init	= nf_tables_inet_init_net,
+	.exit	= nf_tables_inet_exit_net,
+};
+
+static struct nf_chain_type filter_inet = {
+	.family		= NFPROTO_INET,
+	.name		= "filter",
+	.type		= NFT_CHAIN_T_DEFAULT,
+	.hook_mask	= (1 << NF_INET_LOCAL_IN) |
+			  (1 << NF_INET_LOCAL_OUT) |
+			  (1 << NF_INET_FORWARD) |
+			  (1 << NF_INET_PRE_ROUTING) |
+			  (1 << NF_INET_POST_ROUTING),
+};
+
+static int __init nf_tables_inet_init(void)
+{
+	nft_register_chain_type(&filter_inet);
+	return register_pernet_subsys(&nf_tables_inet_net_ops);
+}
+
+static void __exit nf_tables_inet_exit(void)
+{
+	unregister_pernet_subsys(&nf_tables_inet_net_ops);
+	nft_unregister_chain_type(&filter_inet);
+}
+
+module_init(nf_tables_inet_init);
+module_exit(nf_tables_inet_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
+MODULE_ALIAS_NFT_FAMILY(1);
