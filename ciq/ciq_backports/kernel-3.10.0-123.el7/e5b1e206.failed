USB: serial: make minor allocation dynamic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [usb] serial: make minor allocation dynamic (Don Zickus) [895641]
Rebuild_FUZZ: 93.67%
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit e5b1e2062e0535e8ffef79bb34d857e21380d101
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/e5b1e206.failed

This moves the allocation of minor device numbers from a static array to
be dynamic, using the idr interface.  This means that you could
potentially get "gaps" in a minor number range for a single USB serial
device with multiple ports, but all should still work properly.

We remove the 'minor' field from the usb_serial structure, as it no
longer makes any sense for it (use the field in the usb_serial_port
structure if you really want to know this number), and take the fact
that we were overloading a number in this field to determine if we had
initialized the minor numbers or not, and just use a flag variable
instead.

Note, we still have the limitation of 255 USB to serial devices in the
system, as that is all we are registering with the TTY layer at this
point in time.

	Tested-by: Tobias Winter <tobias@linuxdingsda.de>
	Reviewed-by: Johan Hovold <jhovold@gmail.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit e5b1e2062e0535e8ffef79bb34d857e21380d101)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/serqt_usb2/serqt_usb2.c
#	drivers/usb/serial/ark3116.c
#	drivers/usb/serial/f81232.c
#	drivers/usb/serial/io_edgeport.c
#	drivers/usb/serial/io_ti.c
#	drivers/usb/serial/mos7720.c
#	drivers/usb/serial/mos7840.c
#	drivers/usb/serial/pl2303.c
#	drivers/usb/serial/ti_usb_3410_5052.c
#	drivers/usb/serial/usb-serial.c
#	drivers/usb/serial/usb_wwan.c
#	drivers/usb/serial/whiteheat.c
diff --cc drivers/staging/serqt_usb2/serqt_usb2.c
index 8a6e5ea476e1,880f5c0011f2..000000000000
--- a/drivers/staging/serqt_usb2/serqt_usb2.c
+++ b/drivers/staging/serqt_usb2/serqt_usb2.c
@@@ -906,8 -906,7 +906,12 @@@ static int qt_open(struct tty_struct *t
  			qt_submit_urb_from_open(serial, port);
  	}
  
++<<<<<<< HEAD
 +	dev_dbg(&port->dev, "port number is %d\n", port->number);
 +	dev_dbg(&port->dev, "serial number is %d\n", port->serial->minor);
++=======
+ 	dev_dbg(&port->dev, "minor number is %d\n", port->minor);
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	dev_dbg(&port->dev,
  		"Bulkin endpoint is %d\n", port->bulk_in_endpointAddress);
  	dev_dbg(&port->dev,
diff --cc drivers/usb/serial/ark3116.c
index 40e7fd94646f,bc77e955cbef..000000000000
--- a/drivers/usb/serial/ark3116.c
+++ b/drivers/usb/serial/ark3116.c
@@@ -413,8 -413,8 +413,13 @@@ static int ark3116_ioctl(struct tty_str
  		/* XXX: Some of these values are probably wrong. */
  		memset(&serstruct, 0, sizeof(serstruct));
  		serstruct.type = PORT_16654;
++<<<<<<< HEAD
 +		serstruct.line = port->serial->minor;
 +		serstruct.port = port->number;
++=======
+ 		serstruct.line = port->minor;
+ 		serstruct.port = port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  		serstruct.custom_divisor = 0;
  		serstruct.baud_base = 460800;
  
diff --cc drivers/usb/serial/f81232.c
index 7d8dd5aad236,75e85cbf9e8b..000000000000
--- a/drivers/usb/serial/f81232.c
+++ b/drivers/usb/serial/f81232.c
@@@ -295,8 -294,8 +295,13 @@@ static int f81232_ioctl(struct tty_stru
  	case TIOCGSERIAL:
  		memset(&ser, 0, sizeof ser);
  		ser.type = PORT_16654;
++<<<<<<< HEAD
 +		ser.line = port->serial->minor;
 +		ser.port = port->number;
++=======
+ 		ser.line = port->minor;
+ 		ser.port = port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  		ser.baud_base = 460800;
  
  		if (copy_to_user((void __user *)arg, &ser, sizeof ser))
diff --cc drivers/usb/serial/io_edgeport.c
index 1477e8593476,dc2803b5eb09..000000000000
--- a/drivers/usb/serial/io_edgeport.c
+++ b/drivers/usb/serial/io_edgeport.c
@@@ -1575,8 -1569,8 +1575,13 @@@ static int get_serial_info(struct edgep
  	memset(&tmp, 0, sizeof(tmp));
  
  	tmp.type		= PORT_16550A;
++<<<<<<< HEAD
 +	tmp.line		= edge_port->port->serial->minor;
 +	tmp.port		= edge_port->port->number;
++=======
+ 	tmp.line		= edge_port->port->minor;
+ 	tmp.port		= edge_port->port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	tmp.irq			= 0;
  	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
  	tmp.xmit_fifo_size	= edge_port->maxTxCredits;
diff --cc drivers/usb/serial/io_ti.c
index 1be6ba7bee27,60054e72b75b..000000000000
--- a/drivers/usb/serial/io_ti.c
+++ b/drivers/usb/serial/io_ti.c
@@@ -2366,8 -2363,8 +2366,13 @@@ static int get_serial_info(struct edgep
  	memset(&tmp, 0, sizeof(tmp));
  
  	tmp.type		= PORT_16550A;
++<<<<<<< HEAD
 +	tmp.line		= edge_port->port->serial->minor;
 +	tmp.port		= edge_port->port->number;
++=======
+ 	tmp.line		= edge_port->port->minor;
+ 	tmp.port		= edge_port->port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	tmp.irq			= 0;
  	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
  	tmp.xmit_fifo_size	= edge_port->port->bulk_out_size;
diff --cc drivers/usb/serial/mos7720.c
index f27c621a9297,51da424327b0..000000000000
--- a/drivers/usb/serial/mos7720.c
+++ b/drivers/usb/serial/mos7720.c
@@@ -1855,8 -1854,8 +1855,13 @@@ static int get_serial_info(struct mosch
  	memset(&tmp, 0, sizeof(tmp));
  
  	tmp.type		= PORT_16550A;
++<<<<<<< HEAD
 +	tmp.line		= mos7720_port->port->serial->minor;
 +	tmp.port		= mos7720_port->port->number;
++=======
+ 	tmp.line		= mos7720_port->port->minor;
+ 	tmp.port		= mos7720_port->port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	tmp.irq			= 0;
  	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
  	tmp.xmit_fifo_size	= NUM_URBS * URB_TRANSFER_BUFFER_SIZE;
diff --cc drivers/usb/serial/mos7840.c
index 7e998081e1cd,0a818b238508..000000000000
--- a/drivers/usb/serial/mos7840.c
+++ b/drivers/usb/serial/mos7840.c
@@@ -1065,8 -1056,8 +1065,13 @@@ static int mos7840_open(struct tty_stru
  	 * (can't set it up in mos7840_startup as the  *
  	 * structures were not set up at that time.)   */
  
++<<<<<<< HEAD
 +	dev_dbg(&port->dev, "port number is %d\n", port->number);
 +	dev_dbg(&port->dev, "serial number is %d\n", port->serial->minor);
++=======
+ 	dev_dbg(&port->dev, "port number is %d\n", port->port_number);
+ 	dev_dbg(&port->dev, "minor number is %d\n", port->minor);
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	dev_dbg(&port->dev, "Bulkin endpoint is %d\n", port->bulk_in_endpointAddress);
  	dev_dbg(&port->dev, "BulkOut endpoint is %d\n", port->bulk_out_endpointAddress);
  	dev_dbg(&port->dev, "Interrupt endpoint is %d\n", port->interrupt_in_endpointAddress);
@@@ -2083,8 -2068,8 +2088,13 @@@ static int mos7840_get_serial_info(stru
  	memset(&tmp, 0, sizeof(tmp));
  
  	tmp.type = PORT_16550A;
++<<<<<<< HEAD
 +	tmp.line = mos7840_port->port->serial->minor;
 +	tmp.port = mos7840_port->port->number;
++=======
+ 	tmp.line = mos7840_port->port->minor;
+ 	tmp.port = mos7840_port->port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	tmp.irq = 0;
  	tmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
  	tmp.xmit_fifo_size = NUM_URBS * URB_TRANSFER_BUFFER_SIZE;
@@@ -2261,10 -2246,8 +2271,13 @@@ static int mos7840_port_probe(struct us
  	 * usb-serial.c:get_free_serial() and cannot therefore be used
  	 * to index device instances */
  	mos7840_port->port_num = pnum + 1;
++<<<<<<< HEAD
 +	dev_dbg(&port->dev, "port->number = %d\n", port->number);
 +	dev_dbg(&port->dev, "port->serial->minor = %d\n", port->serial->minor);
++=======
+ 	dev_dbg(&port->dev, "port->minor = %d\n", port->minor);
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	dev_dbg(&port->dev, "mos7840_port->port_num = %d\n", mos7840_port->port_num);
- 	dev_dbg(&port->dev, "serial->minor = %d\n", serial->minor);
  
  	if (mos7840_port->port_num == 1) {
  		mos7840_port->SpRegOffset = 0x0;
diff --cc drivers/usb/serial/pl2303.c
index ef063edb8ed2,cb6bbed374f2..000000000000
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@@ -639,8 -639,8 +639,13 @@@ static int pl2303_ioctl(struct tty_stru
  	case TIOCGSERIAL:
  		memset(&ser, 0, sizeof ser);
  		ser.type = PORT_16654;
++<<<<<<< HEAD
 +		ser.line = port->serial->minor;
 +		ser.port = port->number;
++=======
+ 		ser.line = port->minor;
+ 		ser.port = port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  		ser.baud_base = 460800;
  
  		if (copy_to_user((void __user *)arg, &ser, sizeof ser))
diff --cc drivers/usb/serial/ti_usb_3410_5052.c
index e581c2549a57,c9c46d6f8c80..000000000000
--- a/drivers/usb/serial/ti_usb_3410_5052.c
+++ b/drivers/usb/serial/ti_usb_3410_5052.c
@@@ -1309,8 -1308,8 +1309,13 @@@ static int ti_get_serial_info(struct ti
  	memset(&ret_serial, 0, sizeof(ret_serial));
  
  	ret_serial.type = PORT_16550A;
++<<<<<<< HEAD
 +	ret_serial.line = port->serial->minor;
 +	ret_serial.port = port->number - port->serial->minor;
++=======
+ 	ret_serial.line = port->minor;
+ 	ret_serial.port = port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	ret_serial.flags = tport->tp_flags;
  	ret_serial.xmit_fifo_size = TI_WRITE_BUF_SIZE;
  	ret_serial.baud_base = tport->tp_tdev->td_is_3410 ? 921600 : 460800;
diff --cc drivers/usb/serial/usb-serial.c
index 5f6b1ff9d29e,e2e131f85002..000000000000
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@@ -86,37 -90,27 +90,53 @@@ static int allocate_minors(struct usb_s
  
  	dev_dbg(&serial->interface->dev, "%s %d\n", __func__, num_ports);
  
- 	*minor = 0;
  	mutex_lock(&table_lock);
++<<<<<<< HEAD
 +	for (i = 0; i < SERIAL_TTY_MINORS; ++i) {
 +		if (serial_table[i])
 +			continue;
 +
 +		good_spot = 1;
 +		for (j = 1; j <= num_ports-1; ++j)
 +			if ((i+j >= SERIAL_TTY_MINORS) || (serial_table[i+j])) {
 +				good_spot = 0;
 +				i += j;
 +				break;
 +			}
 +		if (good_spot == 0)
 +			continue;
 +
 +		*minor = i;
 +		j = 0;
 +		dev_dbg(&serial->interface->dev, "%s - minor base = %d\n", __func__, *minor);
 +		for (i = *minor; (i < (*minor + num_ports)) && (i < SERIAL_TTY_MINORS); ++i) {
 +			serial_table[i] = serial;
 +			serial->port[j++]->number = i;
 +		}
 +		mutex_unlock(&table_lock);
 +		return serial;
++=======
+ 	for (i = 0; i < num_ports; ++i) {
+ 		port = serial->port[i];
+ 		minor = idr_alloc(&serial_minors, port, 0, 0, GFP_KERNEL);
+ 		if (minor < 0)
+ 			goto error;
+ 		port->minor = minor;
+ 		port->port_number = i;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	}
+ 	serial->minors_reserved = 1;
  	mutex_unlock(&table_lock);
- 	return NULL;
+ 	return 0;
+ error:
+ 	/* unwind the already allocated minors */
+ 	for (j = 0; j < i; ++j)
+ 		idr_remove(&serial_minors, serial->port[j]->minor);
+ 	mutex_unlock(&table_lock);
+ 	return minor;
  }
  
- static void return_serial(struct usb_serial *serial)
+ static void release_minors(struct usb_serial *serial)
  {
  	int i;
  
diff --cc drivers/usb/serial/usb_wwan.c
index ece326ef63a0,8257d30c4072..000000000000
--- a/drivers/usb/serial/usb_wwan.c
+++ b/drivers/usb/serial/usb_wwan.c
@@@ -124,8 -124,8 +124,13 @@@ static int get_serial_info(struct usb_s
  		return -EFAULT;
  
  	memset(&tmp, 0, sizeof(tmp));
++<<<<<<< HEAD
 +	tmp.line            = port->serial->minor;
 +	tmp.port            = port->number;
++=======
+ 	tmp.line            = port->minor;
+ 	tmp.port            = port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  	tmp.baud_base       = tty_get_baud_rate(port->port.tty);
  	tmp.close_delay	    = port->port.close_delay / 10;
  	tmp.closing_wait    = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
diff --cc drivers/usb/serial/whiteheat.c
index 347caad47a12,36a7740e827c..000000000000
--- a/drivers/usb/serial/whiteheat.c
+++ b/drivers/usb/serial/whiteheat.c
@@@ -461,8 -461,8 +461,13 @@@ static int whiteheat_ioctl(struct tty_s
  	case TIOCGSERIAL:
  		memset(&serstruct, 0, sizeof(serstruct));
  		serstruct.type = PORT_16654;
++<<<<<<< HEAD
 +		serstruct.line = port->serial->minor;
 +		serstruct.port = port->number;
++=======
+ 		serstruct.line = port->minor;
+ 		serstruct.port = port->port_number;
++>>>>>>> e5b1e2062e05 (USB: serial: make minor allocation dynamic)
  		serstruct.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
  		serstruct.xmit_fifo_size = kfifo_size(&port->write_fifo);
  		serstruct.custom_divisor = 0;
* Unmerged path drivers/staging/serqt_usb2/serqt_usb2.c
* Unmerged path drivers/usb/serial/ark3116.c
diff --git a/drivers/usb/serial/console.c b/drivers/usb/serial/console.c
index 5f3bcd31e204..9a1101c715c7 100644
--- a/drivers/usb/serial/console.c
+++ b/drivers/usb/serial/console.c
@@ -108,18 +108,18 @@ static int usb_console_setup(struct console *co, char *options)
 	 * no need to check the index here: if the index is wrong, console
 	 * code won't call us
 	 */
-	serial = usb_serial_get_by_index(co->index);
-	if (serial == NULL) {
+	port = usb_serial_port_get_by_minor(co->index);
+	if (port == NULL) {
 		/* no device is connected yet, sorry :( */
 		pr_err("No USB device connected to ttyUSB%i\n", co->index);
 		return -ENODEV;
 	}
+	serial = port->serial;
 
 	retval = usb_autopm_get_interface(serial->interface);
 	if (retval)
 		goto error_get_interface;
 
-	port = serial->port[co->index - serial->minor];
 	tty_port_tty_set(&port->port, NULL);
 
 	info->port = port;
* Unmerged path drivers/usb/serial/f81232.c
* Unmerged path drivers/usb/serial/io_edgeport.c
* Unmerged path drivers/usb/serial/io_ti.c
* Unmerged path drivers/usb/serial/mos7720.c
* Unmerged path drivers/usb/serial/mos7840.c
diff --git a/drivers/usb/serial/opticon.c b/drivers/usb/serial/opticon.c
index 5f4b0cd0f6e9..d5d733f5aecb 100644
--- a/drivers/usb/serial/opticon.c
+++ b/drivers/usb/serial/opticon.c
@@ -348,7 +348,7 @@ static int get_serial_info(struct usb_serial_port *port,
 
 	/* fake emulate a 16550 uart to make userspace code happy */
 	tmp.type		= PORT_16550A;
-	tmp.line		= port->serial->minor;
+	tmp.line		= port->minor;
 	tmp.port		= 0;
 	tmp.irq			= 0;
 	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
* Unmerged path drivers/usb/serial/pl2303.c
diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c
index b0a9478a8c9e..f20877f0f9ec 100644
--- a/drivers/usb/serial/quatech2.c
+++ b/drivers/usb/serial/quatech2.c
@@ -466,7 +466,7 @@ static int get_serial_info(struct usb_serial_port *port,
 		return -EFAULT;
 
 	memset(&tmp, 0, sizeof(tmp));
-	tmp.line		= port->serial->minor;
+	tmp.line		= port->minor;
 	tmp.port		= 0;
 	tmp.irq			= 0;
 	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 5b62dbbdf996..e5750be49054 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -323,7 +323,7 @@ static int get_serial_info(struct usb_serial_port *port,
 		return -EFAULT;
 
 	memset(&tmp, 0, sizeof(tmp));
-	tmp.line		= port->serial->minor;
+	tmp.line		= port->minor;
 	tmp.port		= 0;
 	tmp.irq			= 0;
 	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
* Unmerged path drivers/usb/serial/ti_usb_3410_5052.c
* Unmerged path drivers/usb/serial/usb-serial.c
* Unmerged path drivers/usb/serial/usb_wwan.c
* Unmerged path drivers/usb/serial/whiteheat.c
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 302ddf55d2da..604eab7672b9 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -21,7 +21,6 @@
 
 #define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
 #define SERIAL_TTY_MINORS	254	/* loads of devices :) */
-#define SERIAL_TTY_NO_MINOR	255	/* No minor was assigned */
 
 /* The maximum number of ports one device can grab at once */
 #define MAX_NUM_PORTS		8
@@ -140,7 +139,6 @@ static inline void usb_set_serial_port_data(struct usb_serial_port *port,
  * @dev: pointer to the struct usb_device for this device
  * @type: pointer to the struct usb_serial_driver for this device
  * @interface: pointer to the struct usb_interface for this device
- * @minor: the starting minor number for this device
  * @num_ports: the number of ports this device has
  * @num_interrupt_in: number of interrupt in endpoints we have
  * @num_interrupt_out: number of interrupt out endpoints we have
@@ -159,7 +157,7 @@ struct usb_serial {
 	unsigned char			disconnected:1;
 	unsigned char			suspending:1;
 	unsigned char			attached:1;
-	unsigned char			minor;
+	unsigned char			minors_reserved:1;
 	unsigned char			num_ports;
 	unsigned char			num_port_pointers;
 	char				num_interrupt_in;
@@ -319,7 +317,7 @@ static inline void usb_serial_console_disconnect(struct usb_serial *serial) {}
 #endif
 
 /* Functions needed by other parts of the usbserial core */
-extern struct usb_serial *usb_serial_get_by_index(unsigned int minor);
+extern struct usb_serial_port *usb_serial_port_get_by_minor(unsigned int minor);
 extern void usb_serial_put(struct usb_serial *serial);
 extern int usb_serial_generic_open(struct tty_struct *tty,
 	struct usb_serial_port *port);
