NFSv4: Fix a slot leak in nfs40_sequence_done

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [fs] nfs: Fix a slot leak in nfs40_sequence_done (Steve Dickson) [1059241 919382]
Rebuild_FUZZ: 97.73%
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit cab92c19821a814ecf5a5279e2699bf28e66caee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/cab92c19.failed

The check for whether or not we sent an RPC call in nfs40_sequence_done
is insufficient to decide whether or not we are holding a session slot,
and thus should not be used to decide when to free that slot.

This patch replaces the RPC_WAS_SENT() test with the correct test for
whether or not slot == NULL.

	Cc: Chuck Lever <chuck.lever@oracle.com>
	Cc: stable@vger.kernel.org # 3.12+
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit cab92c19821a814ecf5a5279e2699bf28e66caee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 3b432af281d9,493e9cce1f11..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -412,6 -477,82 +412,85 @@@ struct nfs4_call_sync_data 
  	struct nfs4_sequence_res *seq_res;
  };
  
++<<<<<<< HEAD
++=======
+ static void nfs4_init_sequence(struct nfs4_sequence_args *args,
+ 			       struct nfs4_sequence_res *res, int cache_reply)
+ {
+ 	args->sa_slot = NULL;
+ 	args->sa_cache_this = cache_reply;
+ 	args->sa_privileged = 0;
+ 
+ 	res->sr_slot = NULL;
+ }
+ 
+ static void nfs4_set_sequence_privileged(struct nfs4_sequence_args *args)
+ {
+ 	args->sa_privileged = 1;
+ }
+ 
+ static int nfs40_setup_sequence(const struct nfs_server *server,
+ 				struct nfs4_sequence_args *args,
+ 				struct nfs4_sequence_res *res,
+ 				struct rpc_task *task)
+ {
+ 	struct nfs4_slot_table *tbl = server->nfs_client->cl_slot_tbl;
+ 	struct nfs4_slot *slot;
+ 
+ 	/* slot already allocated? */
+ 	if (res->sr_slot != NULL)
+ 		goto out_start;
+ 
+ 	spin_lock(&tbl->slot_tbl_lock);
+ 	if (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)
+ 		goto out_sleep;
+ 
+ 	slot = nfs4_alloc_slot(tbl);
+ 	if (IS_ERR(slot)) {
+ 		if (slot == ERR_PTR(-ENOMEM))
+ 			task->tk_timeout = HZ >> 2;
+ 		goto out_sleep;
+ 	}
+ 	spin_unlock(&tbl->slot_tbl_lock);
+ 
+ 	args->sa_slot = slot;
+ 	res->sr_slot = slot;
+ 
+ out_start:
+ 	rpc_call_start(task);
+ 	return 0;
+ 
+ out_sleep:
+ 	if (args->sa_privileged)
+ 		rpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,
+ 				NULL, RPC_PRIORITY_PRIVILEGED);
+ 	else
+ 		rpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);
+ 	spin_unlock(&tbl->slot_tbl_lock);
+ 	return -EAGAIN;
+ }
+ 
+ static int nfs40_sequence_done(struct rpc_task *task,
+ 			       struct nfs4_sequence_res *res)
+ {
+ 	struct nfs4_slot *slot = res->sr_slot;
+ 	struct nfs4_slot_table *tbl;
+ 
+ 	if (slot == NULL)
+ 		goto out;
+ 
+ 	tbl = slot->table;
+ 	spin_lock(&tbl->slot_tbl_lock);
+ 	if (!nfs41_wake_and_assign_slot(tbl, slot))
+ 		nfs4_free_slot(tbl, slot);
+ 	spin_unlock(&tbl->slot_tbl_lock);
+ 
+ 	res->sr_slot = NULL;
+ out:
+ 	return 1;
+ }
+ 
++>>>>>>> cab92c19821a (NFSv4: Fix a slot leak in nfs40_sequence_done)
  #if defined(CONFIG_NFS_V4_1)
  
  static void nfs41_sequence_free_slot(struct nfs4_sequence_res *res)
* Unmerged path fs/nfs/nfs4proc.c
