vxlan: fix sparse warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 5692d7ea4183b8dd5a49d73d6a4436aa22929b7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/5692d7ea.failed

Sparse reports false positives for the header manipulation inlines. Annotate
them correctly.

Tested by sparse on a little endian and big endian machine.

Fixes: 54bfd872bf16d ("vxlan: keep flags and vni in network byte order")
	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5692d7ea4183b8dd5a49d73d6a4436aa22929b7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/vxlan.h
diff --cc include/net/vxlan.h
index 5ff7e403dc19,73ed2e951c02..000000000000
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@@ -21,20 -131,211 +21,167 @@@ struct vxlan_sock 
  	struct rcu_head	  rcu;
  	struct hlist_head vni_list[VNI_HASH_SIZE];
  	atomic_t	  refcnt;
 -	struct udp_offload udp_offloads;
 -	u32		  flags;
  };
  
 -union vxlan_addr {
 -	struct sockaddr_in sin;
 -	struct sockaddr_in6 sin6;
 -	struct sockaddr sa;
 -};
 +struct vxlan_sock *vxlan_sock_add(struct net *net, __be16 port,
 +				  vxlan_rcv_t *rcv, void *data,
 +				  bool no_share, bool ipv6);
  
 -struct vxlan_rdst {
 -	union vxlan_addr	 remote_ip;
 -	__be16			 remote_port;
 -	__be32			 remote_vni;
 -	u32			 remote_ifindex;
 -	struct list_head	 list;
 -	struct rcu_head		 rcu;
 -	struct dst_cache	 dst_cache;
 -};
 +void vxlan_sock_release(struct vxlan_sock *vs);
  
 -struct vxlan_config {
 -	union vxlan_addr	remote_ip;
 -	union vxlan_addr	saddr;
 -	__be32			vni;
 -	int			remote_ifindex;
 -	int			mtu;
 -	__be16			dst_port;
 -	u16			port_min;
 -	u16			port_max;
 -	u8			tos;
 -	u8			ttl;
 -	__be32			label;
 -	u32			flags;
 -	unsigned long		age_interval;
 -	unsigned int		addrmax;
 -	bool			no_share;
 -};
 +int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
 +		   struct rtable *rt, struct sk_buff *skb,
 +		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
 +		   __be16 src_port, __be16 dst_port, __be32 vni);
  
 -/* Pseudo network device */
 -struct vxlan_dev {
 -	struct hlist_node hlist;	/* vni hash table */
 -	struct list_head  next;		/* vxlan's per namespace list */
 -	struct vxlan_sock *vn4_sock;	/* listening socket for IPv4 */
 -#if IS_ENABLED(CONFIG_IPV6)
 -	struct vxlan_sock *vn6_sock;	/* listening socket for IPv6 */
 -#endif
 -	struct net_device *dev;
 -	struct net	  *net;		/* netns for packet i/o */
 -	struct vxlan_rdst default_dst;	/* default destination */
 -	u32		  flags;	/* VXLAN_F_* in vxlan.h */
 +__be16 vxlan_src_port(__u16 port_min, __u16 port_max, struct sk_buff *skb);
  
++<<<<<<< HEAD
++=======
+ 	struct timer_list age_timer;
+ 	spinlock_t	  hash_lock;
+ 	unsigned int	  addrcnt;
+ 	struct gro_cells  gro_cells;
+ 
+ 	struct vxlan_config	cfg;
+ 
+ 	struct hlist_head fdb_head[FDB_HASH_SIZE];
+ };
+ 
+ #define VXLAN_F_LEARN			0x01
+ #define VXLAN_F_PROXY			0x02
+ #define VXLAN_F_RSC			0x04
+ #define VXLAN_F_L2MISS			0x08
+ #define VXLAN_F_L3MISS			0x10
+ #define VXLAN_F_IPV6			0x20
+ #define VXLAN_F_UDP_ZERO_CSUM_TX	0x40
+ #define VXLAN_F_UDP_ZERO_CSUM6_TX	0x80
+ #define VXLAN_F_UDP_ZERO_CSUM6_RX	0x100
+ #define VXLAN_F_REMCSUM_TX		0x200
+ #define VXLAN_F_REMCSUM_RX		0x400
+ #define VXLAN_F_GBP			0x800
+ #define VXLAN_F_REMCSUM_NOPARTIAL	0x1000
+ #define VXLAN_F_COLLECT_METADATA	0x2000
+ 
+ /* Flags that are used in the receive path. These flags must match in
+  * order for a socket to be shareable
+  */
+ #define VXLAN_F_RCV_FLAGS		(VXLAN_F_GBP |			\
+ 					 VXLAN_F_UDP_ZERO_CSUM6_RX |	\
+ 					 VXLAN_F_REMCSUM_RX |		\
+ 					 VXLAN_F_REMCSUM_NOPARTIAL |	\
+ 					 VXLAN_F_COLLECT_METADATA)
+ 
+ struct net_device *vxlan_dev_create(struct net *net, const char *name,
+ 				    u8 name_assign_type, struct vxlan_config *conf);
+ 
+ static inline __be16 vxlan_dev_dst_port(struct vxlan_dev *vxlan,
+ 					unsigned short family)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (family == AF_INET6)
+ 		return inet_sk(vxlan->vn6_sock->sock->sk)->inet_sport;
+ #endif
+ 	return inet_sk(vxlan->vn4_sock->sock->sk)->inet_sport;
+ }
+ 
+ static inline netdev_features_t vxlan_features_check(struct sk_buff *skb,
+ 						     netdev_features_t features)
+ {
+ 	u8 l4_hdr = 0;
+ 
+ 	if (!skb->encapsulation)
+ 		return features;
+ 
+ 	switch (vlan_get_protocol(skb)) {
+ 	case htons(ETH_P_IP):
+ 		l4_hdr = ip_hdr(skb)->protocol;
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		l4_hdr = ipv6_hdr(skb)->nexthdr;
+ 		break;
+ 	default:
+ 		return features;;
+ 	}
+ 
+ 	if ((l4_hdr == IPPROTO_UDP) &&
+ 	    (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||
+ 	     skb->inner_protocol != htons(ETH_P_TEB) ||
+ 	     (skb_inner_mac_header(skb) - skb_transport_header(skb) !=
+ 	      sizeof(struct udphdr) + sizeof(struct vxlanhdr))))
+ 		return features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
+ 
+ 	return features;
+ }
+ 
+ /* IP header + UDP + VXLAN + Ethernet header */
+ #define VXLAN_HEADROOM (20 + 8 + 8 + 14)
+ /* IPv6 header + UDP + VXLAN + Ethernet header */
+ #define VXLAN6_HEADROOM (40 + 8 + 8 + 14)
+ 
+ static inline struct vxlanhdr *vxlan_hdr(struct sk_buff *skb)
+ {
+ 	return (struct vxlanhdr *)(udp_hdr(skb) + 1);
+ }
+ 
+ static inline __be32 vxlan_vni(__be32 vni_field)
+ {
+ #if defined(__BIG_ENDIAN)
+ 	return (__force __be32)((__force u32)vni_field >> 8);
+ #else
+ 	return (__force __be32)((__force u32)(vni_field & VXLAN_VNI_MASK) << 8);
+ #endif
+ }
+ 
+ static inline __be32 vxlan_vni_field(__be32 vni)
+ {
+ #if defined(__BIG_ENDIAN)
+ 	return (__force __be32)((__force u32)vni << 8);
+ #else
+ 	return (__force __be32)((__force u32)vni >> 8);
+ #endif
+ }
+ 
+ static inline __be32 vxlan_tun_id_to_vni(__be64 tun_id)
+ {
+ #if defined(__BIG_ENDIAN)
+ 	return (__force __be32)tun_id;
+ #else
+ 	return (__force __be32)((__force u64)tun_id >> 32);
+ #endif
+ }
+ 
+ static inline __be64 vxlan_vni_to_tun_id(__be32 vni)
+ {
+ #if defined(__BIG_ENDIAN)
+ 	return (__force __be64)vni;
+ #else
+ 	return (__force __be64)((u64)(__force u32)vni << 32);
+ #endif
+ }
+ 
+ static inline size_t vxlan_rco_start(__be32 vni_field)
+ {
+ 	return be32_to_cpu(vni_field & VXLAN_RCO_MASK) << VXLAN_RCO_SHIFT;
+ }
+ 
+ static inline size_t vxlan_rco_offset(__be32 vni_field)
+ {
+ 	return (vni_field & VXLAN_RCO_UDP) ?
+ 		offsetof(struct udphdr, check) :
+ 		offsetof(struct tcphdr, check);
+ }
+ 
+ static inline __be32 vxlan_compute_rco(unsigned int start, unsigned int offset)
+ {
+ 	__be32 vni_field = cpu_to_be32(start >> VXLAN_RCO_SHIFT);
+ 
+ 	if (offset == offsetof(struct udphdr, check))
+ 		vni_field |= VXLAN_RCO_UDP;
+ 	return vni_field;
+ }
+ 
+ #if IS_ENABLED(CONFIG_VXLAN)
++>>>>>>> 5692d7ea4183 (vxlan: fix sparse warnings)
  void vxlan_get_rx_port(struct net_device *netdev);
 -#else
 -static inline void vxlan_get_rx_port(struct net_device *netdev)
 -{
 -}
 -#endif
 -
 -static inline unsigned short vxlan_get_sk_family(struct vxlan_sock *vs)
 -{
 -	return vs->sock->sk->sk_family;
 -}
 -
  #endif
* Unmerged path include/net/vxlan.h
