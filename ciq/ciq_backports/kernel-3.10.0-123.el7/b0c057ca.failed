vhost: fix a theoretical race in device cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [virt] vhost/net: fix a theoretical race in device cleanup ("Michael S. Tsirkin") [1065878]
Rebuild_FUZZ: 95.92%
commit-author Michael S. Tsirkin <mst@redhat.com>
commit b0c057ca7e835b36c6050c7627634b664796c1d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/b0c057ca.failed

vhost_zerocopy_callback accesses VQ right after it drops a ubuf
reference.  In theory, this could race with device removal which waits
on the ubuf kref, and crash on use after free.

Do all accesses within rcu read side critical section, and synchronize
on release.

Since callbacks are always invoked from bh, synchronize_rcu_bh seems
enough and will help release complete a bit faster.

	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Acked-by: Jason Wang <jasowang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b0c057ca7e835b36c6050c7627634b664796c1d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vhost/net.c
diff --cc drivers/vhost/net.c
index a9810f379445,a0fa5de210cf..000000000000
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@@ -305,7 -306,14 +305,18 @@@ static void vhost_zerocopy_callback(str
  {
  	struct vhost_net_ubuf_ref *ubufs = ubuf->ctx;
  	struct vhost_virtqueue *vq = ubufs->vq;
++<<<<<<< HEAD
 +	int cnt = atomic_read(&ubufs->kref.refcount);
++=======
+ 	int cnt;
+ 
+ 	rcu_read_lock_bh();
+ 
+ 	/* set len to mark this desc buffers done DMA */
+ 	vq->heads[ubuf->desc].len = success ?
+ 		VHOST_DMA_DONE_LEN : VHOST_DMA_FAILED_LEN;
+ 	cnt = vhost_net_ubuf_put(ubufs);
++>>>>>>> b0c057ca7e83 (vhost: fix a theoretical race in device cleanup)
  
  	/*
  	 * Trigger polling thread if guest stopped submitting new buffers:
@@@ -315,12 -322,10 +326,17 @@@
  	 * (the value 16 here is more or less arbitrary, it's tuned to trigger
  	 * less than 10% of times).
  	 */
 -	if (cnt <= 1 || !(cnt % 16))
 +	if (cnt <= 2 || !(cnt % 16))
  		vhost_poll_queue(&vq->poll);
++<<<<<<< HEAD
 +	/* set len to mark this desc buffers done DMA */
 +	vq->heads[ubuf->desc].len = success ?
 +		VHOST_DMA_DONE_LEN : VHOST_DMA_FAILED_LEN;
 +	vhost_net_ubuf_put(ubufs);
++=======
+ 
+ 	rcu_read_unlock_bh();
++>>>>>>> b0c057ca7e83 (vhost: fix a theoretical race in device cleanup)
  }
  
  /* Expects to be always run from workqueue - which acts as
* Unmerged path drivers/vhost/net.c
