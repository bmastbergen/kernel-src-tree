NFSv4: encode_attrs should not backfill the bitmap and attribute length

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [fs] nfs: encode_attrs should not backfill the bitmap and attribute length (Jeff Layton) [1009119]
Rebuild_FUZZ: 98.57%
commit-author Trond Myklebust <Trond.Myklebust@netapp.com>
commit d7067b2db78aab1a76f9c443b1fcf81c3e35dd50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/d7067b2d.failed

The attribute length is already calculated in advance. There is no
reason why we cannot calculate the bitmap in advance too so that
we don't have to play pointer games.

	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit d7067b2db78aab1a76f9c443b1fcf81c3e35dd50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4xdr.c
diff --cc fs/nfs/nfs4xdr.c
index 3fb919abdbe7,1a4a3bd415ed..000000000000
--- a/fs/nfs/nfs4xdr.c
+++ b/fs/nfs/nfs4xdr.c
@@@ -1023,84 -1039,72 +1023,75 @@@ static void encode_attrs(struct xdr_str
  			owner_grouplen = sizeof("nobody") - 1;
  			/* goto out; */
  		}
+ 		bmval[1] |= FATTR4_WORD1_OWNER_GROUP;
  		len += 4 + (XDR_QUADLEN(owner_grouplen) << 2);
  	}
- 	if (iap->ia_valid & ATTR_ATIME_SET)
+ 	if (iap->ia_valid & ATTR_ATIME_SET) {
+ 		bmval[1] |= FATTR4_WORD1_TIME_ACCESS_SET;
  		len += 16;
- 	else if (iap->ia_valid & ATTR_ATIME)
+ 	} else if (iap->ia_valid & ATTR_ATIME) {
+ 		bmval[1] |= FATTR4_WORD1_TIME_ACCESS_SET;
  		len += 4;
- 	if (iap->ia_valid & ATTR_MTIME_SET)
+ 	}
+ 	if (iap->ia_valid & ATTR_MTIME_SET) {
+ 		bmval[1] |= FATTR4_WORD1_TIME_MODIFY_SET;
  		len += 16;
- 	else if (iap->ia_valid & ATTR_MTIME)
+ 	} else if (iap->ia_valid & ATTR_MTIME) {
+ 		bmval[1] |= FATTR4_WORD1_TIME_MODIFY_SET;
  		len += 4;
+ 	}
++<<<<<<< HEAD
++=======
  	if (label) {
  		len += 4 + 4 + 4 + (XDR_QUADLEN(label->len) << 2);
- 		bmval_len = 3;
+ 		bmval[2] |= FATTR4_WORD2_SECURITY_LABEL;
  	}
  
- 	len += bmval_len << 2;
- 	p = reserve_space(xdr, len);
+ 	if (bmval[2] != 0)
+ 		bmval_len = 3;
+ 	else if (bmval[1] != 0)
+ 		bmval_len = 2;
+ 	else
+ 		bmval_len = 1;
+ 
+ 	p = reserve_space(xdr, 4 + (bmval_len << 2) + 4 + len);
  
- 	/*
- 	 * We write the bitmap length now, but leave the bitmap and the attribute
- 	 * buffer length to be backfilled at the end of this routine.
- 	 */
  	*p++ = cpu_to_be32(bmval_len);
- 	q = p;
- 	/* Skip bitmap entries + attrlen */
- 	p += bmval_len + 1;
+ 	for (i = 0; i < bmval_len; i++)
+ 		*p++ = cpu_to_be32(bmval[i]);
+ 	*p++ = cpu_to_be32(len);
  
- 	if (iap->ia_valid & ATTR_SIZE) {
- 		bmval0 |= FATTR4_WORD0_SIZE;
+ 	if (bmval[0] & FATTR4_WORD0_SIZE)
  		p = xdr_encode_hyper(p, iap->ia_size);
- 	}
- 	if (iap->ia_valid & ATTR_MODE) {
- 		bmval1 |= FATTR4_WORD1_MODE;
+ 	if (bmval[1] & FATTR4_WORD1_MODE)
  		*p++ = cpu_to_be32(iap->ia_mode & S_IALLUGO);
- 	}
- 	if (iap->ia_valid & ATTR_UID) {
- 		bmval1 |= FATTR4_WORD1_OWNER;
+ 	if (bmval[1] & FATTR4_WORD1_OWNER)
  		p = xdr_encode_opaque(p, owner_name, owner_namelen);
- 	}
- 	if (iap->ia_valid & ATTR_GID) {
- 		bmval1 |= FATTR4_WORD1_OWNER_GROUP;
+ 	if (bmval[1] & FATTR4_WORD1_OWNER_GROUP)
  		p = xdr_encode_opaque(p, owner_group, owner_grouplen);
+ 	if (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {
+ 		if (iap->ia_valid & ATTR_ATIME_SET) {
+ 			*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);
+ 			p = xdr_encode_hyper(p, (s64)iap->ia_atime.tv_sec);
+ 			*p++ = cpu_to_be32(iap->ia_atime.tv_nsec);
+ 		} else
+ 			*p++ = cpu_to_be32(NFS4_SET_TO_SERVER_TIME);
  	}
- 	if (iap->ia_valid & ATTR_ATIME_SET) {
- 		bmval1 |= FATTR4_WORD1_TIME_ACCESS_SET;
- 		*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);
- 		p = xdr_encode_hyper(p, (s64)iap->ia_atime.tv_sec);
- 		*p++ = cpu_to_be32(iap->ia_atime.tv_nsec);
- 	}
- 	else if (iap->ia_valid & ATTR_ATIME) {
- 		bmval1 |= FATTR4_WORD1_TIME_ACCESS_SET;
- 		*p++ = cpu_to_be32(NFS4_SET_TO_SERVER_TIME);
- 	}
- 	if (iap->ia_valid & ATTR_MTIME_SET) {
- 		bmval1 |= FATTR4_WORD1_TIME_MODIFY_SET;
- 		*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);
- 		p = xdr_encode_hyper(p, (s64)iap->ia_mtime.tv_sec);
- 		*p++ = cpu_to_be32(iap->ia_mtime.tv_nsec);
- 	}
- 	else if (iap->ia_valid & ATTR_MTIME) {
- 		bmval1 |= FATTR4_WORD1_TIME_MODIFY_SET;
- 		*p++ = cpu_to_be32(NFS4_SET_TO_SERVER_TIME);
+ 	if (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {
+ 		if (iap->ia_valid & ATTR_MTIME_SET) {
+ 			*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);
+ 			p = xdr_encode_hyper(p, (s64)iap->ia_mtime.tv_sec);
+ 			*p++ = cpu_to_be32(iap->ia_mtime.tv_nsec);
+ 		} else
+ 			*p++ = cpu_to_be32(NFS4_SET_TO_SERVER_TIME);
  	}
- 
- 	/*
- 	 * Now we backfill the bitmap and the attribute buffer length.
- 	 */
- 	if (len != ((char *)p - (char *)q) + 4) {
- 		printk(KERN_ERR "NFS: Attr length error, %u != %Zu\n",
- 				len, ((char *)p - (char *)q) + 4);
- 		BUG();
+ 	if (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {
+ 		*p++ = cpu_to_be32(label->lfs);
+ 		*p++ = cpu_to_be32(label->pi);
+ 		*p++ = cpu_to_be32(label->len);
+ 		p = xdr_encode_opaque_fixed(p, label->label, label->len);
  	}
- 	*q++ = htonl(bmval0);
- 	*q++ = htonl(bmval1);
- 	if (bmval_len == 3)
- 		*q++ = htonl(bmval2);
- 	len = (char *)p - (char *)(q + 1);
- 	*q = htonl(len);
++>>>>>>> d7067b2db78a (NFSv4: encode_attrs should not backfill the bitmap and attribute length)
  
  /* out: */
  }
* Unmerged path fs/nfs/nfs4xdr.c
