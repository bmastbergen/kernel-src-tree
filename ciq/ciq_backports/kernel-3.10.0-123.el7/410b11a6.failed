xfs: use tr_qm_dqalloc log reservation for dquot alloc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 410b11a675dca827e893f07c3155691eda3b5887
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/410b11a6.failed

The dquot allocation path in xfs_qm_dqread() currently uses the
attribute set log reservation, which appears to be incorrect. We
have reports of transaction reservation overruns with the current
code. E.g., a repeated run of xfstests test generic/270 on a 512b
block size fs occassionally produces the following in dmesg:

	XFS (sdN): xlog_write: reservation summary:
	  trans type  = QM_DQALLOC (30)
	  unit res    = 7080 bytes
	  current res = -632 bytes
	  total reg   = 0 bytes (o/flow = 0 bytes)
	  ophdrs      = 0 (ophdr space = 0 bytes)
	  ophdr + reg = 0 bytes
	  num regions = 0

	XFS (sdN): xlog_write: reservation ran out. Need to up reservation

The dquot allocation case should consist of a write reservation
(i.e., we are allocating a range of the internal quota file) plus
the size of the actual dquots. We already have a log reservation
definition for this operation (tr_qm_dqalloc). Use it in
xfs_qm_dqread() and update the log reservation calculation function
to use the write res. calculation function rather than reading the
assumed to be pre-calculated value directly.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Jie Liu <jeff.liu@oracle.com>
	Reviewed-by: Ben Myers <bpm@sgi.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 410b11a675dca827e893f07c3155691eda3b5887)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_dquot.c
#	fs/xfs/xfs_trans_resv.c
diff --cc fs/xfs/xfs_dquot.c
index 13f80f48887c,868b19f096bf..000000000000
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@@ -727,10 -615,8 +727,15 @@@ xfs_qm_dqread
  
  	if (flags & XFS_QMOPT_DQALLOC) {
  		tp = xfs_trans_alloc(mp, XFS_TRANS_QM_DQALLOC);
++<<<<<<< HEAD
 +		error = xfs_trans_reserve(tp, XFS_QM_DQALLOC_SPACE_RES(mp),
 +					  XFS_QM_DQALLOC_LOG_RES(mp), 0,
 +					  XFS_TRANS_PERM_LOG_RES,
 +					  XFS_WRITE_LOG_COUNT);
++=======
+ 		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_dqalloc,
+ 					  XFS_QM_DQALLOC_SPACE_RES(mp), 0);
++>>>>>>> 410b11a675dc (xfs: use tr_qm_dqalloc log reservation for dquot alloc)
  		if (error)
  			goto error1;
  		cancelflags = XFS_TRANS_RELEASE_LOG_RES;
diff --cc fs/xfs/xfs_trans_resv.c
index 9da7df08b814,8515b0449dc8..000000000000
--- a/fs/xfs/xfs_trans_resv.c
+++ b/fs/xfs/xfs_trans_resv.c
@@@ -620,14 -644,14 +620,22 @@@ xfs_calc_qm_setqlim_reservation
  
  /*
   * Allocating quota on disk if needed.
++<<<<<<< HEAD
 + *	the write transaction log space: XFS_WRITE_LOG_RES(mp)
++=======
+  *	the write transaction log space for quota file extent allocation
++>>>>>>> 410b11a675dc (xfs: use tr_qm_dqalloc log reservation for dquot alloc)
   *	the unit of quota allocation: one system block size
   */
  STATIC uint
  xfs_calc_qm_dqalloc_reservation(
  	struct xfs_mount	*mp)
  {
++<<<<<<< HEAD
 +	return XFS_WRITE_LOG_RES(mp) +
++=======
+ 	return xfs_calc_write_reservation(mp) +
++>>>>>>> 410b11a675dc (xfs: use tr_qm_dqalloc log reservation for dquot alloc)
  		xfs_calc_buf_res(1,
  			XFS_FSB_TO_B(mp, XFS_DQUOT_CLUSTER_SIZE_FSB) - 1);
  }
* Unmerged path fs/xfs/xfs_dquot.c
* Unmerged path fs/xfs/xfs_trans_resv.c
