netfilter: nft: add queue module

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Eric Leblond <eric@regit.org>
commit 0aff078d58e1c69139189e45ba5e929c030e8056
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/0aff078d.failed

This patch adds a new nft module named "nft_queue" which provides
a new nftables expression that allows you to enqueue packets to
userspace via the nfnetlink_queue subsystem. It provides the same
level of functionality as NFQUEUE and it shares some code with it.

	Signed-off-by: Eric Leblond <eric@regit.org>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 0aff078d58e1c69139189e45ba5e929c030e8056)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/netfilter/nf_tables.h
#	net/netfilter/Kconfig
#	net/netfilter/Makefile
diff --cc net/netfilter/Kconfig
index 112ddfea8c1a,4371c9819d97..000000000000
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@@ -408,8 -408,72 +408,72 @@@ config NF_NAT_TFT
  	depends on NF_CONNTRACK && NF_NAT
  	default NF_NAT && NF_CONNTRACK_TFTP
  
 -config NETFILTER_SYNPROXY
 -	tristate
 -
  endif # NF_CONNTRACK
  
++<<<<<<< HEAD
++=======
+ config NF_TABLES
+ 	depends on NETFILTER_NETLINK
+ 	tristate "Netfilter nf_tables support"
+ 
+ config NFT_EXTHDR
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables IPv6 exthdr module"
+ 
+ config NFT_META
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables meta module"
+ 
+ config NFT_CT
+ 	depends on NF_TABLES
+ 	depends on NF_CONNTRACK
+ 	tristate "Netfilter nf_tables conntrack module"
+ 
+ config NFT_RBTREE
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables rbtree set module"
+ 
+ config NFT_HASH
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables hash set module"
+ 
+ config NFT_COUNTER
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables counter module"
+ 
+ config NFT_LOG
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables log module"
+ 
+ config NFT_LIMIT
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables limit module"
+ 
+ config NFT_NAT
+ 	depends on NF_TABLES
+ 	depends on NF_CONNTRACK
+ 	depends on NF_NAT
+ 	tristate "Netfilter nf_tables nat module"
+ 
+ config NFT_QUEUE
+ 	depends on NF_TABLES
+ 	depends on NETFILTER_XTABLES
+ 	depends on NETFILTER_NETLINK_QUEUE
+ 	tristate "Netfilter nf_tables queue module"
+ 	help
+ 	  This is required if you intend to use the userspace queueing
+ 	  infrastructure (also known as NFQUEUE) from nftables.
+ 
+ config NFT_COMPAT
+ 	depends on NF_TABLES
+ 	depends on NETFILTER_XTABLES
+ 	tristate "Netfilter x_tables over nf_tables module"
+ 	help
+ 	  This is required if you intend to use any of existing
+ 	  x_tables match/target extensions over the nf_tables
+ 	  framework.
+ 
++>>>>>>> 0aff078d58e1 (netfilter: nft: add queue module)
  config NETFILTER_XTABLES
  	tristate "Netfilter Xtables support (required for ip_tables)"
  	default m if NETFILTER_ADVANCED=n
diff --cc net/netfilter/Makefile
index ebfa7dc747cd,e7637463226e..000000000000
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@@ -61,6 -61,28 +61,31 @@@ obj-$(CONFIG_NF_NAT_IRC) += nf_nat_irc.
  obj-$(CONFIG_NF_NAT_SIP) += nf_nat_sip.o
  obj-$(CONFIG_NF_NAT_TFTP) += nf_nat_tftp.o
  
++<<<<<<< HEAD
++=======
+ # SYNPROXY
+ obj-$(CONFIG_NETFILTER_SYNPROXY) += nf_synproxy_core.o
+ 
+ # nf_tables
+ nf_tables-objs += nf_tables_core.o nf_tables_api.o
+ nf_tables-objs += nft_immediate.o nft_cmp.o nft_lookup.o
+ nf_tables-objs += nft_bitwise.o nft_byteorder.o nft_payload.o
+ 
+ obj-$(CONFIG_NF_TABLES)		+= nf_tables.o
+ obj-$(CONFIG_NFT_COMPAT)	+= nft_compat.o
+ obj-$(CONFIG_NFT_EXTHDR)	+= nft_exthdr.o
+ obj-$(CONFIG_NFT_META)		+= nft_meta.o
+ obj-$(CONFIG_NFT_CT)		+= nft_ct.o
+ obj-$(CONFIG_NFT_LIMIT)		+= nft_limit.o
+ obj-$(CONFIG_NFT_NAT)		+= nft_nat.o
+ obj-$(CONFIG_NFT_QUEUE)		+= nft_queue.o
+ #nf_tables-objs			+= nft_meta_target.o
+ obj-$(CONFIG_NFT_RBTREE)	+= nft_rbtree.o
+ obj-$(CONFIG_NFT_HASH)		+= nft_hash.o
+ obj-$(CONFIG_NFT_COUNTER)	+= nft_counter.o
+ obj-$(CONFIG_NFT_LOG)		+= nft_log.o
+ 
++>>>>>>> 0aff078d58e1 (netfilter: nft: add queue module)
  # generic X tables 
  obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
  
* Unmerged path include/uapi/linux/netfilter/nf_tables.h
* Unmerged path include/uapi/linux/netfilter/nf_tables.h
* Unmerged path net/netfilter/Kconfig
* Unmerged path net/netfilter/Makefile
diff --git a/net/netfilter/nft_queue.c b/net/netfilter/nft_queue.c
new file mode 100644
index 000000000000..cbea473d69e9
--- /dev/null
+++ b/net/netfilter/nft_queue.c
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2013 Eric Leblond <eric@regit.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Development of this code partly funded by OISF
+ * (http://www.openinfosecfoundation.org/)
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <linux/jhash.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/nf_tables.h>
+#include <net/netfilter/nf_tables.h>
+#include <net/netfilter/nf_queue.h>
+
+static u32 jhash_initval __read_mostly;
+
+struct nft_queue {
+	u16	queuenum;
+	u16	queues_total;
+	u16	flags;
+	u8	family;
+};
+
+static void nft_queue_eval(const struct nft_expr *expr,
+			   struct nft_data data[NFT_REG_MAX + 1],
+			   const struct nft_pktinfo *pkt)
+{
+	struct nft_queue *priv = nft_expr_priv(expr);
+	u32 queue = priv->queuenum;
+	u32 ret;
+
+	if (priv->queues_total > 1) {
+		if (priv->flags & NFT_QUEUE_FLAG_CPU_FANOUT) {
+			int cpu = smp_processor_id();
+
+			queue = priv->queuenum + cpu % priv->queues_total;
+		} else {
+			queue = nfqueue_hash(pkt->skb, queue,
+					     priv->queues_total, priv->family,
+					     jhash_initval);
+		}
+	}
+
+	ret = NF_QUEUE_NR(queue);
+	if (priv->flags & NFT_QUEUE_FLAG_BYPASS)
+		ret |= NF_VERDICT_FLAG_QUEUE_BYPASS;
+
+	data[NFT_REG_VERDICT].verdict = ret;
+}
+
+static const struct nla_policy nft_queue_policy[NFTA_QUEUE_MAX + 1] = {
+	[NFTA_QUEUE_NUM]	= { .type = NLA_U16 },
+	[NFTA_QUEUE_TOTAL]	= { .type = NLA_U16 },
+	[NFTA_QUEUE_FLAGS]	= { .type = NLA_U16 },
+};
+
+static int nft_queue_init(const struct nft_ctx *ctx,
+			   const struct nft_expr *expr,
+			   const struct nlattr * const tb[])
+{
+	struct nft_queue *priv = nft_expr_priv(expr);
+
+	if (tb[NFTA_QUEUE_NUM] == NULL)
+		return -EINVAL;
+
+	init_hashrandom(&jhash_initval);
+	priv->family = ctx->afi->family;
+	priv->queuenum = ntohs(nla_get_be16(tb[NFTA_QUEUE_NUM]));
+
+	if (tb[NFTA_QUEUE_TOTAL] != NULL)
+		priv->queues_total = ntohs(nla_get_be16(tb[NFTA_QUEUE_TOTAL]));
+	if (tb[NFTA_QUEUE_FLAGS] != NULL) {
+		priv->flags = ntohs(nla_get_be16(tb[NFTA_QUEUE_FLAGS]));
+		if (priv->flags & ~NFT_QUEUE_FLAG_MASK)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int nft_queue_dump(struct sk_buff *skb, const struct nft_expr *expr)
+{
+	const struct nft_queue *priv = nft_expr_priv(expr);
+
+	if (nla_put_be16(skb, NFTA_QUEUE_NUM, htons(priv->queuenum)) ||
+	    nla_put_be16(skb, NFTA_QUEUE_TOTAL, htons(priv->queues_total)) ||
+	    nla_put_be16(skb, NFTA_QUEUE_FLAGS, htons(priv->flags)))
+		goto nla_put_failure;
+
+	return 0;
+
+nla_put_failure:
+	return -1;
+}
+
+static struct nft_expr_type nft_queue_type;
+static const struct nft_expr_ops nft_queue_ops = {
+	.type		= &nft_queue_type,
+	.size		= NFT_EXPR_SIZE(sizeof(struct nft_queue)),
+	.eval		= nft_queue_eval,
+	.init		= nft_queue_init,
+	.dump		= nft_queue_dump,
+};
+
+static struct nft_expr_type nft_queue_type __read_mostly = {
+	.name		= "queue",
+	.ops		= &nft_queue_ops,
+	.policy		= nft_queue_policy,
+	.maxattr	= NFTA_QUEUE_MAX,
+	.owner		= THIS_MODULE,
+};
+
+static int __init nft_queue_module_init(void)
+{
+	return nft_register_expr(&nft_queue_type);
+}
+
+static void __exit nft_queue_module_exit(void)
+{
+	nft_unregister_expr(&nft_queue_type);
+}
+
+module_init(nft_queue_module_init);
+module_exit(nft_queue_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Eric Leblond <eric@regit.org>");
+MODULE_ALIAS_NFT_EXPR("queue");
