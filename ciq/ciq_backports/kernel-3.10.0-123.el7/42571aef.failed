drm/i915: Add support for pipe_bpp readout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [drm] i915: Add support for pipe_bpp readout (Rob Clark) [1054409]
Rebuild_FUZZ: 95.00%
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 42571aefafb1d330ef84eb29418832f72e7dfb4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/42571aef.failed

On CTG+ read out the pipe bpp setting from hardware and fill it into
pipe config. Also check it appropriately.

v2: Don't do the pipe_bpp extraction inside the PCH only code block on
    ILK+.
    Avoid the PIPECONF read as we already have read it for the
    PIPECONF_EANBLE check.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
	Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
(cherry picked from commit 42571aefafb1d330ef84eb29418832f72e7dfb4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
#	drivers/gpu/drm/i915/intel_display.c
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index fb961bb81903,d5215e2db42c..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -1472,6 -1249,44 +1472,47 @@@ static void intel_ddi_hot_plug(struct i
  		intel_dp_check_link_status(intel_dp);
  }
  
++<<<<<<< HEAD
++=======
+ static void intel_ddi_get_config(struct intel_encoder *encoder,
+ 				 struct intel_crtc_config *pipe_config)
+ {
+ 	struct drm_i915_private *dev_priv = encoder->base.dev->dev_private;
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);
+ 	enum transcoder cpu_transcoder = intel_crtc->config.cpu_transcoder;
+ 	u32 temp, flags = 0;
+ 
+ 	temp = I915_READ(TRANS_DDI_FUNC_CTL(cpu_transcoder));
+ 	if (temp & TRANS_DDI_PHSYNC)
+ 		flags |= DRM_MODE_FLAG_PHSYNC;
+ 	else
+ 		flags |= DRM_MODE_FLAG_NHSYNC;
+ 	if (temp & TRANS_DDI_PVSYNC)
+ 		flags |= DRM_MODE_FLAG_PVSYNC;
+ 	else
+ 		flags |= DRM_MODE_FLAG_NVSYNC;
+ 
+ 	pipe_config->adjusted_mode.flags |= flags;
+ 
+ 	switch (temp & TRANS_DDI_BPC_MASK) {
+ 	case TRANS_DDI_BPC_6:
+ 		pipe_config->pipe_bpp = 18;
+ 		break;
+ 	case TRANS_DDI_BPC_8:
+ 		pipe_config->pipe_bpp = 24;
+ 		break;
+ 	case TRANS_DDI_BPC_10:
+ 		pipe_config->pipe_bpp = 30;
+ 		break;
+ 	case TRANS_DDI_BPC_12:
+ 		pipe_config->pipe_bpp = 36;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 42571aefafb1 (drm/i915: Add support for pipe_bpp readout)
  static void intel_ddi_destroy(struct drm_encoder *encoder)
  {
  	/* HDMI has nothing special to destroy, so we can go with this. */
diff --cc drivers/gpu/drm/i915/intel_display.c
index 56746dcac40f,1f280cc7b1e3..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -4768,6 -4997,54 +4768,57 @@@ static bool i9xx_get_pipe_config(struc
  	if (!(tmp & PIPECONF_ENABLE))
  		return false;
  
++<<<<<<< HEAD
++=======
+ 	if (IS_G4X(dev) || IS_VALLEYVIEW(dev)) {
+ 		switch (tmp & PIPECONF_BPC_MASK) {
+ 		case PIPECONF_6BPC:
+ 			pipe_config->pipe_bpp = 18;
+ 			break;
+ 		case PIPECONF_8BPC:
+ 			pipe_config->pipe_bpp = 24;
+ 			break;
+ 		case PIPECONF_10BPC:
+ 			pipe_config->pipe_bpp = 30;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	intel_get_pipe_timings(crtc, pipe_config);
+ 
+ 	i9xx_get_pfit_config(crtc, pipe_config);
+ 
+ 	if (INTEL_INFO(dev)->gen >= 4) {
+ 		tmp = I915_READ(DPLL_MD(crtc->pipe));
+ 		pipe_config->pixel_multiplier =
+ 			((tmp & DPLL_MD_UDI_MULTIPLIER_MASK)
+ 			 >> DPLL_MD_UDI_MULTIPLIER_SHIFT) + 1;
+ 		pipe_config->dpll_hw_state.dpll_md = tmp;
+ 	} else if (IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev)) {
+ 		tmp = I915_READ(DPLL(crtc->pipe));
+ 		pipe_config->pixel_multiplier =
+ 			((tmp & SDVO_MULTIPLIER_MASK)
+ 			 >> SDVO_MULTIPLIER_SHIFT_HIRES) + 1;
+ 	} else {
+ 		/* Note that on i915G/GM the pixel multiplier is in the sdvo
+ 		 * port and will be fixed up in the encoder->get_config
+ 		 * function. */
+ 		pipe_config->pixel_multiplier = 1;
+ 	}
+ 	pipe_config->dpll_hw_state.dpll = I915_READ(DPLL(crtc->pipe));
+ 	if (!IS_VALLEYVIEW(dev)) {
+ 		pipe_config->dpll_hw_state.fp0 = I915_READ(FP0(crtc->pipe));
+ 		pipe_config->dpll_hw_state.fp1 = I915_READ(FP1(crtc->pipe));
+ 	} else {
+ 		/* Mask out read-only status bits. */
+ 		pipe_config->dpll_hw_state.dpll &= ~(DPLL_LOCK_VLV |
+ 						     DPLL_PORTC_READY_MASK |
+ 						     DPLL_PORTB_READY_MASK);
+ 	}
+ 
++>>>>>>> 42571aefafb1 (drm/i915: Add support for pipe_bpp readout)
  	return true;
  }
  
@@@ -5675,77 -5827,446 +5726,100 @@@ static int ironlake_crtc_mode_set(struc
  	if (intel_crtc->config.has_dp_encoder)
  		intel_dp_set_m_n(intel_crtc);
  
 -	if (is_lvds && has_reduced_clock && i915_powersave)
 -		intel_crtc->lowfreq_avail = true;
 -	else
 -		intel_crtc->lowfreq_avail = false;
 -
 -	if (intel_crtc->config.has_pch_encoder) {
 -		pll = intel_crtc_to_shared_dpll(intel_crtc);
 -
 -	}
 -
 -	intel_set_pipe_timings(intel_crtc);
 -
 -	if (intel_crtc->config.has_pch_encoder) {
 -		intel_cpu_transcoder_set_m_n(intel_crtc,
 -					     &intel_crtc->config.fdi_m_n);
 -	}
 -
 -	if (IS_IVYBRIDGE(dev))
 -		ivybridge_update_fdi_bc_bifurcation(intel_crtc);
 -
 -	ironlake_set_pipeconf(crtc);
 -
 -	/* Set up the display plane register */
 -	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE);
 -	POSTING_READ(DSPCNTR(plane));
 -
 -	ret = intel_pipe_set_base(crtc, x, y, fb);
 -
 -	return ret;
 -}
 -
 -static void ironlake_get_fdi_m_n_config(struct intel_crtc *crtc,
 -					struct intel_crtc_config *pipe_config)
 -{
 -	struct drm_device *dev = crtc->base.dev;
 -	struct drm_i915_private *dev_priv = dev->dev_private;
 -	enum transcoder transcoder = pipe_config->cpu_transcoder;
 -
 -	pipe_config->fdi_m_n.link_m = I915_READ(PIPE_LINK_M1(transcoder));
 -	pipe_config->fdi_m_n.link_n = I915_READ(PIPE_LINK_N1(transcoder));
 -	pipe_config->fdi_m_n.gmch_m = I915_READ(PIPE_DATA_M1(transcoder))
 -					& ~TU_SIZE_MASK;
 -	pipe_config->fdi_m_n.gmch_n = I915_READ(PIPE_DATA_N1(transcoder));
 -	pipe_config->fdi_m_n.tu = ((I915_READ(PIPE_DATA_M1(transcoder))
 -				   & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
 -}
 -
 -static void ironlake_get_pfit_config(struct intel_crtc *crtc,
 -				     struct intel_crtc_config *pipe_config)
 -{
 -	struct drm_device *dev = crtc->base.dev;
 -	struct drm_i915_private *dev_priv = dev->dev_private;
 -	uint32_t tmp;
 -
 -	tmp = I915_READ(PF_CTL(crtc->pipe));
 -
 -	if (tmp & PF_ENABLE) {
 -		pipe_config->pch_pfit.pos = I915_READ(PF_WIN_POS(crtc->pipe));
 -		pipe_config->pch_pfit.size = I915_READ(PF_WIN_SZ(crtc->pipe));
 -
 -		/* We currently do not free assignements of panel fitters on
 -		 * ivb/hsw (since we don't use the higher upscaling modes which
 -		 * differentiates them) so just WARN about this case for now. */
 -		if (IS_GEN7(dev)) {
 -			WARN_ON((tmp & PF_PIPE_SEL_MASK_IVB) !=
 -				PF_PIPE_SEL_IVB(crtc->pipe));
 -		}
 -	}
 -}
 -
 -static bool ironlake_get_pipe_config(struct intel_crtc *crtc,
 -				     struct intel_crtc_config *pipe_config)
 -{
 -	struct drm_device *dev = crtc->base.dev;
 -	struct drm_i915_private *dev_priv = dev->dev_private;
 -	uint32_t tmp;
 +	for_each_encoder_on_crtc(dev, crtc, encoder)
 +		if (encoder->pre_pll_enable)
 +			encoder->pre_pll_enable(encoder);
  
 -	pipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;
 -	pipe_config->shared_dpll = DPLL_ID_PRIVATE;
 +	if (intel_crtc->pch_pll) {
 +		I915_WRITE(intel_crtc->pch_pll->pll_reg, dpll);
  
 -	tmp = I915_READ(PIPECONF(crtc->pipe));
 -	if (!(tmp & PIPECONF_ENABLE))
 -		return false;
 +		/* Wait for the clocks to stabilize. */
 +		POSTING_READ(intel_crtc->pch_pll->pll_reg);
 +		udelay(150);
  
 -	switch (tmp & PIPECONF_BPC_MASK) {
 -	case PIPECONF_6BPC:
 -		pipe_config->pipe_bpp = 18;
 -		break;
 -	case PIPECONF_8BPC:
 -		pipe_config->pipe_bpp = 24;
 -		break;
 -	case PIPECONF_10BPC:
 -		pipe_config->pipe_bpp = 30;
 -		break;
 -	case PIPECONF_12BPC:
 -		pipe_config->pipe_bpp = 36;
 -		break;
 -	default:
 -		break;
 +		/* The pixel multiplier can only be updated once the
 +		 * DPLL is enabled and the clocks are stable.
 +		 *
 +		 * So write it again.
 +		 */
 +		I915_WRITE(intel_crtc->pch_pll->pll_reg, dpll);
  	}
  
 -	if (I915_READ(PCH_TRANSCONF(crtc->pipe)) & TRANS_ENABLE) {
 -		struct intel_shared_dpll *pll;
 -
 -		pipe_config->has_pch_encoder = true;
 -
 -		tmp = I915_READ(FDI_RX_CTL(crtc->pipe));
 -		pipe_config->fdi_lanes = ((FDI_DP_PORT_WIDTH_MASK & tmp) >>
 -					  FDI_DP_PORT_WIDTH_SHIFT) + 1;
 -
 -		ironlake_get_fdi_m_n_config(crtc, pipe_config);
 -
 -		if (HAS_PCH_IBX(dev_priv->dev)) {
 -			pipe_config->shared_dpll =
 -				(enum intel_dpll_id) crtc->pipe;
 +	intel_crtc->lowfreq_avail = false;
 +	if (intel_crtc->pch_pll) {
 +		if (is_lvds && has_reduced_clock && i915_powersave) {
 +			I915_WRITE(intel_crtc->pch_pll->fp1_reg, fp2);
 +			intel_crtc->lowfreq_avail = true;
  		} else {
 -			tmp = I915_READ(PCH_DPLL_SEL);
 -			if (tmp & TRANS_DPLLB_SEL(crtc->pipe))
 -				pipe_config->shared_dpll = DPLL_ID_PCH_PLL_B;
 -			else
 -				pipe_config->shared_dpll = DPLL_ID_PCH_PLL_A;
 +			I915_WRITE(intel_crtc->pch_pll->fp1_reg, fp);
  		}
 -
 -		pll = &dev_priv->shared_dplls[pipe_config->shared_dpll];
 -
 -		WARN_ON(!pll->get_hw_state(dev_priv, pll,
 -					   &pipe_config->dpll_hw_state));
 -
 -		tmp = pipe_config->dpll_hw_state.dpll;
 -		pipe_config->pixel_multiplier =
 -			((tmp & PLL_REF_SDVO_HDMI_MULTIPLIER_MASK)
 -			 >> PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT) + 1;
 -	} else {
 -		pipe_config->pixel_multiplier = 1;
 -	}
 -
 -	intel_get_pipe_timings(crtc, pipe_config);
 -
 -	ironlake_get_pfit_config(crtc, pipe_config);
 -
 -	return true;
 -}
 -
 -static void assert_can_disable_lcpll(struct drm_i915_private *dev_priv)
 -{
 -	struct drm_device *dev = dev_priv->dev;
 -	struct intel_ddi_plls *plls = &dev_priv->ddi_plls;
 -	struct intel_crtc *crtc;
 -	unsigned long irqflags;
 -	uint32_t val;
 -
 -	list_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head)
 -		WARN(crtc->base.enabled, "CRTC for pipe %c enabled\n",
 -		     pipe_name(crtc->pipe));
 -
 -	WARN(I915_READ(HSW_PWR_WELL_DRIVER), "Power well on\n");
 -	WARN(plls->spll_refcount, "SPLL enabled\n");
 -	WARN(plls->wrpll1_refcount, "WRPLL1 enabled\n");
 -	WARN(plls->wrpll2_refcount, "WRPLL2 enabled\n");
 -	WARN(I915_READ(PCH_PP_STATUS) & PP_ON, "Panel power on\n");
 -	WARN(I915_READ(BLC_PWM_CPU_CTL2) & BLM_PWM_ENABLE,
 -	     "CPU PWM1 enabled\n");
 -	WARN(I915_READ(HSW_BLC_PWM2_CTL) & BLM_PWM_ENABLE,
 -	     "CPU PWM2 enabled\n");
 -	WARN(I915_READ(BLC_PWM_PCH_CTL1) & BLM_PCH_PWM_ENABLE,
 -	     "PCH PWM1 enabled\n");
 -	WARN(I915_READ(UTIL_PIN_CTL) & UTIL_PIN_ENABLE,
 -	     "Utility pin enabled\n");
 -	WARN(I915_READ(PCH_GTC_CTL) & PCH_GTC_ENABLE, "PCH GTC enabled\n");
 -
 -	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
 -	val = I915_READ(DEIMR);
 -	WARN((val & ~DE_PCH_EVENT_IVB) != val,
 -	     "Unexpected DEIMR bits enabled: 0x%x\n", val);
 -	val = I915_READ(SDEIMR);
 -	WARN((val | SDE_HOTPLUG_MASK_CPT) != 0xffffffff,
 -	     "Unexpected SDEIMR bits enabled: 0x%x\n", val);
 -	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
 -}
 -
 -/*
 - * This function implements pieces of two sequences from BSpec:
 - * - Sequence for display software to disable LCPLL
 - * - Sequence for display software to allow package C8+
 - * The steps implemented here are just the steps that actually touch the LCPLL
 - * register. Callers should take care of disabling all the display engine
 - * functions, doing the mode unset, fixing interrupts, etc.
 - */
 -void hsw_disable_lcpll(struct drm_i915_private *dev_priv,
 -		       bool switch_to_fclk, bool allow_power_down)
 -{
 -	uint32_t val;
 -
 -	assert_can_disable_lcpll(dev_priv);
 -
 -	val = I915_READ(LCPLL_CTL);
 -
 -	if (switch_to_fclk) {
 -		val |= LCPLL_CD_SOURCE_FCLK;
 -		I915_WRITE(LCPLL_CTL, val);
 -
 -		if (wait_for_atomic_us(I915_READ(LCPLL_CTL) &
 -				       LCPLL_CD_SOURCE_FCLK_DONE, 1))
 -			DRM_ERROR("Switching to FCLK failed\n");
 -
 -		val = I915_READ(LCPLL_CTL);
  	}
  
 -	val |= LCPLL_PLL_DISABLE;
 -	I915_WRITE(LCPLL_CTL, val);
 -	POSTING_READ(LCPLL_CTL);
 +	intel_set_pipe_timings(intel_crtc, mode, adjusted_mode);
  
 -	if (wait_for((I915_READ(LCPLL_CTL) & LCPLL_PLL_LOCK) == 0, 1))
 -		DRM_ERROR("LCPLL still locked\n");
 -
 -	val = I915_READ(D_COMP);
 -	val |= D_COMP_COMP_DISABLE;
 -	I915_WRITE(D_COMP, val);
 -	POSTING_READ(D_COMP);
 -	ndelay(100);
 -
 -	if (wait_for((I915_READ(D_COMP) & D_COMP_RCOMP_IN_PROGRESS) == 0, 1))
 -		DRM_ERROR("D_COMP RCOMP still in progress\n");
 -
 -	if (allow_power_down) {
 -		val = I915_READ(LCPLL_CTL);
 -		val |= LCPLL_POWER_DOWN_ALLOW;
 -		I915_WRITE(LCPLL_CTL, val);
 -		POSTING_READ(LCPLL_CTL);
 -	}
 -}
 -
 -/*
 - * Fully restores LCPLL, disallowing power down and switching back to LCPLL
 - * source.
 - */
 -void hsw_restore_lcpll(struct drm_i915_private *dev_priv)
 -{
 -	uint32_t val;
 -
 -	val = I915_READ(LCPLL_CTL);
 -
 -	if ((val & (LCPLL_PLL_LOCK | LCPLL_PLL_DISABLE | LCPLL_CD_SOURCE_FCLK |
 -		    LCPLL_POWER_DOWN_ALLOW)) == LCPLL_PLL_LOCK)
 -		return;
 -
 -	/* Make sure we're not on PC8 state before disabling PC8, otherwise
 -	 * we'll hang the machine! */
 -	dev_priv->uncore.funcs.force_wake_get(dev_priv);
 -
 -	if (val & LCPLL_POWER_DOWN_ALLOW) {
 -		val &= ~LCPLL_POWER_DOWN_ALLOW;
 -		I915_WRITE(LCPLL_CTL, val);
 -		POSTING_READ(LCPLL_CTL);
 -	}
 -
 -	val = I915_READ(D_COMP);
 -	val |= D_COMP_COMP_FORCE;
 -	val &= ~D_COMP_COMP_DISABLE;
 -	I915_WRITE(D_COMP, val);
 -	POSTING_READ(D_COMP);
 -
 -	val = I915_READ(LCPLL_CTL);
 -	val &= ~LCPLL_PLL_DISABLE;
 -	I915_WRITE(LCPLL_CTL, val);
 -
 -	if (wait_for(I915_READ(LCPLL_CTL) & LCPLL_PLL_LOCK, 5))
 -		DRM_ERROR("LCPLL not locked yet\n");
 -
 -	if (val & LCPLL_CD_SOURCE_FCLK) {
 -		val = I915_READ(LCPLL_CTL);
 -		val &= ~LCPLL_CD_SOURCE_FCLK;
 -		I915_WRITE(LCPLL_CTL, val);
 -
 -		if (wait_for_atomic_us((I915_READ(LCPLL_CTL) &
 -					LCPLL_CD_SOURCE_FCLK_DONE) == 0, 1))
 -			DRM_ERROR("Switching back to LCPLL failed\n");
 -	}
 -
 -	dev_priv->uncore.funcs.force_wake_put(dev_priv);
 -}
 -
 -void hsw_enable_pc8_work(struct work_struct *__work)
 -{
 -	struct drm_i915_private *dev_priv =
 -		container_of(to_delayed_work(__work), struct drm_i915_private,
 -			     pc8.enable_work);
 -	struct drm_device *dev = dev_priv->dev;
 -	uint32_t val;
 -
 -	if (dev_priv->pc8.enabled)
 -		return;
 -
 -	DRM_DEBUG_KMS("Enabling package C8+\n");
 -
 -	dev_priv->pc8.enabled = true;
 -
 -	if (dev_priv->pch_id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
 -		val = I915_READ(SOUTH_DSPCLK_GATE_D);
 -		val &= ~PCH_LP_PARTITION_LEVEL_DISABLE;
 -		I915_WRITE(SOUTH_DSPCLK_GATE_D, val);
 -	}
 -
 -	lpt_disable_clkout_dp(dev);
 -	hsw_pc8_disable_interrupts(dev);
 -	hsw_disable_lcpll(dev_priv, true, true);
 -}
 -
 -static void __hsw_enable_package_c8(struct drm_i915_private *dev_priv)
 -{
 -	WARN_ON(!mutex_is_locked(&dev_priv->pc8.lock));
 -	WARN(dev_priv->pc8.disable_count < 1,
 -	     "pc8.disable_count: %d\n", dev_priv->pc8.disable_count);
 -
 -	dev_priv->pc8.disable_count--;
 -	if (dev_priv->pc8.disable_count != 0)
 -		return;
 -
 -	schedule_delayed_work(&dev_priv->pc8.enable_work,
 -			      msecs_to_jiffies(i915_pc8_timeout));
 -}
 -
 -static void __hsw_disable_package_c8(struct drm_i915_private *dev_priv)
 -{
 -	struct drm_device *dev = dev_priv->dev;
 -	uint32_t val;
 -
 -	WARN_ON(!mutex_is_locked(&dev_priv->pc8.lock));
 -	WARN(dev_priv->pc8.disable_count < 0,
 -	     "pc8.disable_count: %d\n", dev_priv->pc8.disable_count);
 -
 -	dev_priv->pc8.disable_count++;
 -	if (dev_priv->pc8.disable_count != 1)
 -		return;
 -
 -	cancel_delayed_work_sync(&dev_priv->pc8.enable_work);
 -	if (!dev_priv->pc8.enabled)
 -		return;
 -
 -	DRM_DEBUG_KMS("Disabling package C8+\n");
 -
 -	hsw_restore_lcpll(dev_priv);
 -	hsw_pc8_restore_interrupts(dev);
 -	lpt_init_pch_refclk(dev);
 -
 -	if (dev_priv->pch_id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
 -		val = I915_READ(SOUTH_DSPCLK_GATE_D);
 -		val |= PCH_LP_PARTITION_LEVEL_DISABLE;
 -		I915_WRITE(SOUTH_DSPCLK_GATE_D, val);
 -	}
 -
 -	intel_prepare_ddi(dev);
 -	i915_gem_init_swizzling(dev);
 -	mutex_lock(&dev_priv->rps.hw_lock);
 -	gen6_update_ring_freq(dev);
 -	mutex_unlock(&dev_priv->rps.hw_lock);
 -	dev_priv->pc8.enabled = false;
 -}
 -
 -void hsw_enable_package_c8(struct drm_i915_private *dev_priv)
 -{
 -	mutex_lock(&dev_priv->pc8.lock);
 -	__hsw_enable_package_c8(dev_priv);
 -	mutex_unlock(&dev_priv->pc8.lock);
 -}
 -
 -void hsw_disable_package_c8(struct drm_i915_private *dev_priv)
 -{
 -	mutex_lock(&dev_priv->pc8.lock);
 -	__hsw_disable_package_c8(dev_priv);
 -	mutex_unlock(&dev_priv->pc8.lock);
 -}
 -
 -static bool hsw_can_enable_package_c8(struct drm_i915_private *dev_priv)
 -{
 -	struct drm_device *dev = dev_priv->dev;
 -	struct intel_crtc *crtc;
 -	uint32_t val;
 -
 -	list_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head)
 -		if (crtc->base.enabled)
 -			return false;
 -
 -	/* This case is still possible since we have the i915.disable_power_well
 -	 * parameter and also the KVMr or something else might be requesting the
 -	 * power well. */
 -	val = I915_READ(HSW_PWR_WELL_DRIVER);
 -	if (val != 0) {
 -		DRM_DEBUG_KMS("Not enabling PC8: power well on\n");
 -		return false;
 -	}
 -
 -	return true;
 -}
 +	/* Note, this also computes intel_crtc->fdi_lanes which is used below in
 +	 * ironlake_check_fdi_lanes. */
 +	intel_crtc->fdi_lanes = 0;
 +	if (intel_crtc->config.has_pch_encoder)
 +		ironlake_fdi_set_m_n(crtc);
  
 -/* Since we're called from modeset_global_resources there's no way to
 - * symmetrically increase and decrease the refcount, so we use
 - * dev_priv->pc8.requirements_met to track whether we already have the refcount
 - * or not.
 - */
 -static void hsw_update_package_c8(struct drm_device *dev)
 -{
 -	struct drm_i915_private *dev_priv = dev->dev_private;
 -	bool allow;
 +	fdi_config_ok = ironlake_check_fdi_lanes(intel_crtc);
  
 -	if (!i915_enable_pc8)
 -		return;
 +	ironlake_set_pipeconf(crtc, adjusted_mode, dither);
  
 -	mutex_lock(&dev_priv->pc8.lock);
 +	intel_wait_for_vblank(dev, pipe);
  
 -	allow = hsw_can_enable_package_c8(dev_priv);
 +	/* Set up the display plane register */
 +	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE);
 +	POSTING_READ(DSPCNTR(plane));
  
 -	if (allow == dev_priv->pc8.requirements_met)
 -		goto done;
 +	ret = intel_pipe_set_base(crtc, x, y, fb);
  
 -	dev_priv->pc8.requirements_met = allow;
 +	intel_update_watermarks(dev);
  
 -	if (allow)
 -		__hsw_enable_package_c8(dev_priv);
 -	else
 -		__hsw_disable_package_c8(dev_priv);
 +	intel_update_linetime_watermarks(dev, pipe, adjusted_mode);
  
 -done:
 -	mutex_unlock(&dev_priv->pc8.lock);
 +	return fdi_config_ok ? ret : -EINVAL;
  }
  
 -static void hsw_package_c8_gpu_idle(struct drm_i915_private *dev_priv)
 +static bool ironlake_get_pipe_config(struct intel_crtc *crtc,
 +				     struct intel_crtc_config *pipe_config)
  {
 -	if (!dev_priv->pc8.gpu_idle) {
 -		dev_priv->pc8.gpu_idle = true;
 -		hsw_enable_package_c8(dev_priv);
 -	}
 -}
 +	struct drm_device *dev = crtc->base.dev;
 +	struct drm_i915_private *dev_priv = dev->dev_private;
 +	uint32_t tmp;
  
 -static void hsw_package_c8_gpu_busy(struct drm_i915_private *dev_priv)
 -{
 -	if (dev_priv->pc8.gpu_idle) {
 -		dev_priv->pc8.gpu_idle = false;
 -		hsw_disable_package_c8(dev_priv);
 +	tmp = I915_READ(PIPECONF(crtc->pipe));
 +	if (!(tmp & PIPECONF_ENABLE))
 +		return false;
 +
++<<<<<<< HEAD
 +	if (I915_READ(TRANSCONF(crtc->pipe)) & TRANS_ENABLE)
++=======
++	switch (tmp & PIPECONF_BPC_MASK) {
++	case PIPECONF_6BPC:
++		pipe_config->pipe_bpp = 18;
++		break;
++	case PIPECONF_8BPC:
++		pipe_config->pipe_bpp = 24;
++		break;
++	case PIPECONF_10BPC:
++		pipe_config->pipe_bpp = 30;
++		break;
++	case PIPECONF_12BPC:
++		pipe_config->pipe_bpp = 36;
++		break;
++	default:
++		break;
+ 	}
++
++	if (I915_READ(PCH_TRANSCONF(crtc->pipe)) & TRANS_ENABLE) {
++		struct intel_shared_dpll *pll;
++
++>>>>>>> 42571aefafb1 (drm/i915: Add support for pipe_bpp readout)
 +		pipe_config->has_pch_encoder = true;
 +
 +	return true;
  }
  
  static void haswell_modeset_global_resources(struct drm_device *dev)
@@@ -7821,18 -8561,117 +7895,125 @@@ intel_modeset_update_state(struct drm_d
  	list_for_each_entry((intel_crtc), \
  			    &(dev)->mode_config.crtc_list, \
  			    base.head) \
 -		if (mask & (1 <<(intel_crtc)->pipe))
 +		if (mask & (1 <<(intel_crtc)->pipe)) \
  
  static bool
 -intel_pipe_config_compare(struct drm_device *dev,
 -			  struct intel_crtc_config *current_config,
 +intel_pipe_config_compare(struct intel_crtc_config *current_config,
  			  struct intel_crtc_config *pipe_config)
  {
++<<<<<<< HEAD
 +	if (current_config->has_pch_encoder != pipe_config->has_pch_encoder) {
 +		DRM_ERROR("mismatch in has_pch_encoder "
 +			  "(expected %i, found %i)\n",
 +			  current_config->has_pch_encoder,
 +			  pipe_config->has_pch_encoder);
 +		return false;
++=======
+ #define PIPE_CONF_CHECK_X(name)	\
+ 	if (current_config->name != pipe_config->name) { \
+ 		DRM_ERROR("mismatch in " #name " " \
+ 			  "(expected 0x%08x, found 0x%08x)\n", \
+ 			  current_config->name, \
+ 			  pipe_config->name); \
+ 		return false; \
+ 	}
+ 
+ #define PIPE_CONF_CHECK_I(name)	\
+ 	if (current_config->name != pipe_config->name) { \
+ 		DRM_ERROR("mismatch in " #name " " \
+ 			  "(expected %i, found %i)\n", \
+ 			  current_config->name, \
+ 			  pipe_config->name); \
+ 		return false; \
+ 	}
+ 
+ #define PIPE_CONF_CHECK_FLAGS(name, mask)	\
+ 	if ((current_config->name ^ pipe_config->name) & (mask)) { \
+ 		DRM_ERROR("mismatch in " #name "(" #mask ") "	   \
+ 			  "(expected %i, found %i)\n", \
+ 			  current_config->name & (mask), \
+ 			  pipe_config->name & (mask)); \
+ 		return false; \
+ 	}
+ 
+ #define PIPE_CONF_QUIRK(quirk)	\
+ 	((current_config->quirks | pipe_config->quirks) & (quirk))
+ 
+ 	PIPE_CONF_CHECK_I(cpu_transcoder);
+ 
+ 	PIPE_CONF_CHECK_I(has_pch_encoder);
+ 	PIPE_CONF_CHECK_I(fdi_lanes);
+ 	PIPE_CONF_CHECK_I(fdi_m_n.gmch_m);
+ 	PIPE_CONF_CHECK_I(fdi_m_n.gmch_n);
+ 	PIPE_CONF_CHECK_I(fdi_m_n.link_m);
+ 	PIPE_CONF_CHECK_I(fdi_m_n.link_n);
+ 	PIPE_CONF_CHECK_I(fdi_m_n.tu);
+ 
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hdisplay);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_htotal);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hblank_start);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hblank_end);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hsync_start);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hsync_end);
+ 
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vdisplay);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vtotal);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vblank_start);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vblank_end);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vsync_start);
+ 	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vsync_end);
+ 
+ 	PIPE_CONF_CHECK_I(pixel_multiplier);
+ 
+ 	PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
+ 			      DRM_MODE_FLAG_INTERLACE);
+ 
+ 	if (!PIPE_CONF_QUIRK(PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS)) {
+ 		PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
+ 				      DRM_MODE_FLAG_PHSYNC);
+ 		PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
+ 				      DRM_MODE_FLAG_NHSYNC);
+ 		PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
+ 				      DRM_MODE_FLAG_PVSYNC);
+ 		PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
+ 				      DRM_MODE_FLAG_NVSYNC);
+ 	}
+ 
+ 	PIPE_CONF_CHECK_I(requested_mode.hdisplay);
+ 	PIPE_CONF_CHECK_I(requested_mode.vdisplay);
+ 
+ 	PIPE_CONF_CHECK_I(gmch_pfit.control);
+ 	/* pfit ratios are autocomputed by the hw on gen4+ */
+ 	if (INTEL_INFO(dev)->gen < 4)
+ 		PIPE_CONF_CHECK_I(gmch_pfit.pgm_ratios);
+ 	PIPE_CONF_CHECK_I(gmch_pfit.lvds_border_bits);
+ 	PIPE_CONF_CHECK_I(pch_pfit.pos);
+ 	PIPE_CONF_CHECK_I(pch_pfit.size);
+ 
+ 	PIPE_CONF_CHECK_I(ips_enabled);
+ 
+ 	PIPE_CONF_CHECK_I(shared_dpll);
+ 	PIPE_CONF_CHECK_X(dpll_hw_state.dpll);
+ 	PIPE_CONF_CHECK_X(dpll_hw_state.dpll_md);
+ 	PIPE_CONF_CHECK_X(dpll_hw_state.fp0);
+ 	PIPE_CONF_CHECK_X(dpll_hw_state.fp1);
+ 
+ 	if (IS_G4X(dev) || INTEL_INFO(dev)->gen >= 5)
+ 		PIPE_CONF_CHECK_I(pipe_bpp);
+ 
+ #undef PIPE_CONF_CHECK_X
+ #undef PIPE_CONF_CHECK_I
+ #undef PIPE_CONF_CHECK_FLAGS
+ #undef PIPE_CONF_QUIRK
+ 
+ 	if (!IS_HASWELL(dev)) {
+ 		if (!intel_fuzzy_clock_check(current_config, pipe_config)) {
+ 			DRM_ERROR("mismatch in clock (expected %d, found %d)\n",
+ 				  current_config->adjusted_mode.clock,
+ 				  pipe_config->adjusted_mode.clock);
+ 			return false;
+ 		}
++>>>>>>> 42571aefafb1 (drm/i915: Add support for pipe_bpp readout)
  	}
  
  	return true;
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
* Unmerged path drivers/gpu/drm/i915/intel_display.c
