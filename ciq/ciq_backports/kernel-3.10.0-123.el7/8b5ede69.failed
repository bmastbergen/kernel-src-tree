powerpc/irq: Don't switch to irq stack from softirq stack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [powerpc] irq: Don't switch to irq stack from softirq stack (Steve Best) [1016454]
Rebuild_FUZZ: 92.45%
commit-author Benjamin Herrenschmidt <benh@kernel.crashing.org>
commit 8b5ede69d24db939f52b47effff2f6fe1e83e08b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/8b5ede69.failed

irq_exit() is now called on the irq stack, which can trigger a switch to
the softirq stack from the irq stack.  If an interrupt happens at that
point, we will not properly detect the re-entrancy and clobber the
original return context on the irq stack.

This fixes it.  The side effect is to prevent all nesting from softirq
stack to irq stack even in the "safe" case but it's simpler that way and
matches what x86_64 does.

	Reported-by: Cédric Le Goater <clg@fr.ibm.com>
	Tested-by: Cédric Le Goater <clg@fr.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8b5ede69d24db939f52b47effff2f6fe1e83e08b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/irq.c
diff --cc arch/powerpc/kernel/irq.c
index 6145f6319788,c7cb8c232d2f..000000000000
--- a/arch/powerpc/kernel/irq.c
+++ b/arch/powerpc/kernel/irq.c
@@@ -497,8 -495,7 +497,12 @@@ void __do_irq(struct pt_regs *regs
  void do_IRQ(struct pt_regs *regs)
  {
  	struct pt_regs *old_regs = set_irq_regs(regs);
++<<<<<<< HEAD
 +	struct thread_info *curtp, *irqtp;
 +	unsigned long saved_sp_limit;
++=======
+ 	struct thread_info *curtp, *irqtp, *sirqtp;
++>>>>>>> 8b5ede69d24d (powerpc/irq: Don't switch to irq stack from softirq stack)
  
  	/* Switch to the irq stack to handle this */
  	curtp = current_thread_info();
* Unmerged path arch/powerpc/kernel/irq.c
