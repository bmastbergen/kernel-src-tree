s390/pci: update function handle after resume from hibernate

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [s390] pci: update function handle after resume from hibernate (Hendrik Brueckner) [1005896]
Rebuild_FUZZ: 95.65%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit 57b5918c33a0797930c3791fb602a8a9d46ef80c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/57b5918c.failed

Function handles may change while the system was in hibernation
use list pci functions and update the function handles.

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 57b5918c33a0797930c3791fb602a8a9d46ef80c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pci.h
#	arch/s390/pci/pci.c
#	arch/s390/pci/pci_clp.c
diff --cc arch/s390/include/asm/pci.h
index 6e577ba0e5da,c290f13d1c47..000000000000
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@@ -146,7 -136,9 +147,13 @@@ int zpci_register_ioat(struct zpci_dev 
  int zpci_unregister_ioat(struct zpci_dev *, u8);
  
  /* CLP */
++<<<<<<< HEAD
 +int clp_find_pci_devices(void);
++=======
+ int clp_scan_pci_devices(void);
+ int clp_rescan_pci_devices(void);
+ int clp_rescan_pci_devices_simple(void);
++>>>>>>> 57b5918c33a0 (s390/pci: update function handle after resume from hibernate)
  int clp_add_pci_device(u32, u32, int);
  int clp_enable_fh(struct zpci_dev *, u8);
  int clp_disable_fh(struct zpci_dev *);
@@@ -166,8 -151,20 +174,9 @@@ void zpci_rescan(void)
  #else /* CONFIG_PCI */
  static inline void zpci_event_error(void *e) {}
  static inline void zpci_event_availability(void *e) {}
+ static inline void zpci_rescan(void) {}
  #endif /* CONFIG_PCI */
  
 -#ifdef CONFIG_HOTPLUG_PCI_S390
 -int zpci_init_slot(struct zpci_dev *);
 -void zpci_exit_slot(struct zpci_dev *);
 -#else /* CONFIG_HOTPLUG_PCI_S390 */
 -static inline int zpci_init_slot(struct zpci_dev *zdev)
 -{
 -	return 0;
 -}
 -static inline void zpci_exit_slot(struct zpci_dev *zdev) {}
 -#endif /* CONFIG_HOTPLUG_PCI_S390 */
 -
  /* Helpers */
  struct zpci_dev *get_zdev(struct pci_dev *);
  struct zpci_dev *get_zdev_by_fid(u32);
diff --cc arch/s390/pci/pci.c
index 7fd6f6f6124f,f17a8343e360..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -46,12 -45,17 +46,17 @@@
  #define ZPCI_NR_DEVICES			CONFIG_PCI_NR_FUNCTIONS
  
  /* list of all detected zpci devices */
++<<<<<<< HEAD
 +LIST_HEAD(zpci_list);
 +EXPORT_SYMBOL_GPL(zpci_list);
 +DEFINE_MUTEX(zpci_list_lock);
 +EXPORT_SYMBOL_GPL(zpci_list_lock);
++=======
+ static LIST_HEAD(zpci_list);
+ static DEFINE_SPINLOCK(zpci_list_lock);
++>>>>>>> 57b5918c33a0 (s390/pci: update function handle after resume from hibernate)
  
 -static void zpci_enable_irq(struct irq_data *data);
 -static void zpci_disable_irq(struct irq_data *data);
 -
 -static struct irq_chip zpci_irq_chip = {
 -	.name = "zPCI",
 -	.irq_unmask = zpci_enable_irq,
 -	.irq_mask = zpci_disable_irq,
 -};
 +static struct pci_hp_callback_ops *hotplug_ops;
  
  static DECLARE_BITMAP(zpci_domain, ZPCI_NR_DEVICES);
  static DEFINE_SPINLOCK(zpci_domain_lock);
@@@ -938,11 -821,11 +943,15 @@@ int zpci_create_device(struct zpci_dev 
  	if (rc)
  		goto out_disable;
  
- 	mutex_lock(&zpci_list_lock);
+ 	spin_lock(&zpci_list_lock);
  	list_add_tail(&zdev->entry, &zpci_list);
++<<<<<<< HEAD
 +	if (hotplug_ops)
 +		hotplug_ops->create_slot(zdev);
 +	mutex_unlock(&zpci_list_lock);
++=======
+ 	spin_unlock(&zpci_list_lock);
 -
 -	zpci_init_slot(zdev);
++>>>>>>> 57b5918c33a0 (s390/pci: update function handle after resume from hibernate)
  
  	return 0;
  
@@@ -1083,6 -935,12 +1092,15 @@@ out_hash
  	zpci_mem_exit();
  out_mem:
  	zpci_debug_exit();
 -out:
  	return rc;
  }
++<<<<<<< HEAD
 +subsys_initcall(pci_base_init);
++=======
+ subsys_initcall_sync(pci_base_init);
+ 
+ void zpci_rescan(void)
+ {
+ 	clp_rescan_pci_devices_simple();
+ }
++>>>>>>> 57b5918c33a0 (s390/pci: update function handle after resume from hibernate)
diff --cc arch/s390/pci/pci_clp.c
index 6876a6ce96b8,475563c3d1e4..000000000000
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@@ -322,6 -285,95 +322,98 @@@ int clp_find_pci_devices(void
  	pr_debug("Maximum number of supported PCI functions: %u\n",
  		rrb->response.max_fn);
  out:
++<<<<<<< HEAD
++=======
+ 	return rc;
+ }
+ 
+ static void __clp_add(struct clp_fh_list_entry *entry)
+ {
+ 	if (!entry->vendor_id)
+ 		return;
+ 
+ 	clp_add_pci_device(entry->fid, entry->fh, entry->config_state);
+ }
+ 
+ static void __clp_rescan(struct clp_fh_list_entry *entry)
+ {
+ 	struct zpci_dev *zdev;
+ 
+ 	if (!entry->vendor_id)
+ 		return;
+ 
+ 	zdev = get_zdev_by_fid(entry->fid);
+ 	if (!zdev) {
+ 		clp_add_pci_device(entry->fid, entry->fh, entry->config_state);
+ 		return;
+ 	}
+ 
+ 	if (!entry->config_state) {
+ 		/*
+ 		 * The handle is already disabled, that means no iota/irq freeing via
+ 		 * the firmware interfaces anymore. Need to free resources manually
+ 		 * (DMA memory, debug, sysfs)...
+ 		 */
+ 		zpci_stop_device(zdev);
+ 	}
+ }
+ 
+ static void __clp_update(struct clp_fh_list_entry *entry)
+ {
+ 	struct zpci_dev *zdev;
+ 
+ 	if (!entry->vendor_id)
+ 		return;
+ 
+ 	zdev = get_zdev_by_fid(entry->fid);
+ 	if (!zdev)
+ 		return;
+ 
+ 	zdev->fh = entry->fh;
+ }
+ 
+ int clp_scan_pci_devices(void)
+ {
+ 	struct clp_req_rsp_list_pci *rrb;
+ 	int rc;
+ 
+ 	rrb = clp_alloc_block(GFP_KERNEL);
+ 	if (!rrb)
+ 		return -ENOMEM;
+ 
+ 	rc = clp_list_pci(rrb, __clp_add);
+ 
+ 	clp_free_block(rrb);
+ 	return rc;
+ }
+ 
+ int clp_rescan_pci_devices(void)
+ {
+ 	struct clp_req_rsp_list_pci *rrb;
+ 	int rc;
+ 
+ 	rrb = clp_alloc_block(GFP_KERNEL);
+ 	if (!rrb)
+ 		return -ENOMEM;
+ 
+ 	rc = clp_list_pci(rrb, __clp_rescan);
+ 
++>>>>>>> 57b5918c33a0 (s390/pci: update function handle after resume from hibernate)
+ 	clp_free_block(rrb);
+ 	return rc;
+ }
+ 
+ int clp_rescan_pci_devices_simple(void)
+ {
+ 	struct clp_req_rsp_list_pci *rrb;
+ 	int rc;
+ 
+ 	rrb = clp_alloc_block(GFP_NOWAIT);
+ 	if (!rrb)
+ 		return -ENOMEM;
+ 
+ 	rc = clp_list_pci(rrb, __clp_update);
+ 
  	clp_free_block(rrb);
  	return rc;
  }
* Unmerged path arch/s390/include/asm/pci.h
diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c
index eebab9f83f1d..737bff38e3ee 100644
--- a/arch/s390/kernel/suspend.c
+++ b/arch/s390/kernel/suspend.c
@@ -12,6 +12,7 @@
 #include <asm/ctl_reg.h>
 #include <asm/ipl.h>
 #include <asm/cio.h>
+#include <asm/pci.h>
 
 /*
  * References to section boundaries
@@ -219,4 +220,5 @@ void s390_early_resume(void)
 {
 	lgr_info_log();
 	channel_subsystem_reinit();
+	zpci_rescan();
 }
* Unmerged path arch/s390/pci/pci.c
* Unmerged path arch/s390/pci/pci_clp.c
