RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] sunrpc: RPCSEC_GSS, Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches (Jeff Layton) [1002576]
Rebuild_FUZZ: 93.83%
commit-author Trond Myklebust <Trond.Myklebust@netapp.com>
commit 414a629598409497c05f2387c22c77dee143b4ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/414a6295.failed

Ensure that if an rpc_clnt owns more than one RPCSEC_GSS-based authentication
mechanism, then those caches will share the same 'gssd' upcall pipe.

	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit 414a629598409497c05f2387c22c77dee143b4ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/auth_gss/auth_gss.c
diff --cc net/sunrpc/auth_gss/auth_gss.c
index 5f322fd964f7,5ec15bb43e83..000000000000
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@@ -71,6 -71,14 +71,17 @@@ static unsigned int gss_expired_cred_re
   * using integrity (two 4-byte integers): */
  #define GSS_VERF_SLACK		100
  
++<<<<<<< HEAD
++=======
+ struct gss_pipe {
+ 	struct rpc_pipe_dir_object pdo;
+ 	struct rpc_pipe *pipe;
+ 	struct rpc_clnt *clnt;
+ 	const char *name;
+ 	struct kref kref;
+ };
+ 
++>>>>>>> 414a62959840 (RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches)
  struct gss_auth {
  	struct kref kref;
  	struct rpc_auth rpc_auth;
@@@ -805,66 -811,129 +816,167 @@@ static void gss_pipes_dentries_destroy(
  	}
  }
  
 -static int gss_pipe_dentry_create(struct dentry *dir,
 -		struct rpc_pipe_dir_object *pdo)
 +static int gss_pipes_dentries_create(struct rpc_auth *auth)
  {
 -	struct gss_pipe *p = pdo->pdo_data;
 +	int err;
 +	struct gss_auth *gss_auth;
 +	struct rpc_clnt *clnt;
  	struct dentry *dentry;
  
 -	dentry = rpc_mkpipe_dentry(dir, p->name, p->clnt, p->pipe);
 -	if (IS_ERR(dentry))
 -		return PTR_ERR(dentry);
 -	p->pipe->dentry = dentry;
 -	return 0;
 -}
 +	gss_auth = container_of(auth, struct gss_auth, rpc_auth);
 +	clnt = gss_auth->client;
  
++<<<<<<< HEAD
 +	dentry = rpc_mkpipe_dentry(clnt->cl_dentry, "gssd",
 +			clnt, gss_auth->pipe[1]);
 +	if (IS_ERR(dentry)) {
 +		err = PTR_ERR(dentry);
++=======
+ static const struct rpc_pipe_dir_object_ops gss_pipe_dir_object_ops = {
+ 	.create = gss_pipe_dentry_create,
+ 	.destroy = gss_pipe_dentry_destroy,
+ };
+ 
+ static struct gss_pipe *gss_pipe_alloc(struct rpc_clnt *clnt,
+ 		const char *name,
+ 		const struct rpc_pipe_ops *upcall_ops)
+ {
+ 	struct gss_pipe *p;
+ 	int err = -ENOMEM;
+ 
+ 	p = kmalloc(sizeof(*p), GFP_KERNEL);
+ 	if (p == NULL)
++>>>>>>> 414a62959840 (RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches)
  		goto err;
 -	p->pipe = rpc_mkpipe_data(upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);
 -	if (IS_ERR(p->pipe)) {
 -		err = PTR_ERR(p->pipe);
 -		goto err_free_gss_pipe;
  	}
++<<<<<<< HEAD
 +	gss_auth->pipe[1]->dentry = dentry;
 +	dentry = rpc_mkpipe_dentry(clnt->cl_dentry, gss_auth->mech->gm_name,
 +			clnt, gss_auth->pipe[0]);
 +	if (IS_ERR(dentry)) {
 +		err = PTR_ERR(dentry);
 +		goto err_unlink_pipe_1;
 +	}
 +	return 0;
 +
 +err_unlink_pipe_1:
 +	rpc_unlink(gss_auth->pipe[1]->dentry);
 +	gss_auth->pipe[1]->dentry = NULL;
++=======
+ 	p->name = name;
+ 	p->clnt = clnt;
+ 	kref_init(&p->kref);
+ 	rpc_init_pipe_dir_object(&p->pdo,
+ 			&gss_pipe_dir_object_ops,
+ 			p);
+ 	return p;
+ err_free_gss_pipe:
+ 	kfree(p);
++>>>>>>> 414a62959840 (RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches)
  err:
 -	return ERR_PTR(err);
 +	return err;
  }
  
++<<<<<<< HEAD
 +static void gss_pipes_dentries_destroy_net(struct rpc_clnt *clnt,
 +					   struct rpc_auth *auth)
++=======
+ struct gss_alloc_pdo {
+ 	struct rpc_clnt *clnt;
+ 	const char *name;
+ 	const struct rpc_pipe_ops *upcall_ops;
+ };
+ 
+ static int gss_pipe_match_pdo(struct rpc_pipe_dir_object *pdo, void *data)
+ {
+ 	struct gss_pipe *gss_pipe;
+ 	struct gss_alloc_pdo *args = data;
+ 
+ 	if (pdo->pdo_ops != &gss_pipe_dir_object_ops)
+ 		return 0;
+ 	gss_pipe = container_of(pdo, struct gss_pipe, pdo);
+ 	if (strcmp(gss_pipe->name, args->name) != 0)
+ 		return 0;
+ 	if (!kref_get_unless_zero(&gss_pipe->kref))
+ 		return 0;
+ 	return 1;
+ }
+ 
+ static struct rpc_pipe_dir_object *gss_pipe_alloc_pdo(void *data)
+ {
+ 	struct gss_pipe *gss_pipe;
+ 	struct gss_alloc_pdo *args = data;
+ 
+ 	gss_pipe = gss_pipe_alloc(args->clnt, args->name, args->upcall_ops);
+ 	if (!IS_ERR(gss_pipe))
+ 		return &gss_pipe->pdo;
+ 	return NULL;
+ }
+ 
+ static struct gss_pipe *gss_pipe_get(struct rpc_clnt *clnt,
+ 		const char *name,
+ 		const struct rpc_pipe_ops *upcall_ops)
+ {
+ 	struct net *net = rpc_net_ns(clnt);
+ 	struct rpc_pipe_dir_object *pdo;
+ 	struct gss_alloc_pdo args = {
+ 		.clnt = clnt,
+ 		.name = name,
+ 		.upcall_ops = upcall_ops,
+ 	};
+ 
+ 	pdo = rpc_find_or_alloc_pipe_dir_object(net,
+ 			&clnt->cl_pipedir_objects,
+ 			gss_pipe_match_pdo,
+ 			gss_pipe_alloc_pdo,
+ 			&args);
+ 	if (pdo != NULL)
+ 		return container_of(pdo, struct gss_pipe, pdo);
+ 	return ERR_PTR(-ENOMEM);
+ }
+ 
+ static void __gss_pipe_free(struct gss_pipe *p)
++>>>>>>> 414a62959840 (RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches)
  {
 -	struct rpc_clnt *clnt = p->clnt;
  	struct net *net = rpc_net_ns(clnt);
 +	struct super_block *sb;
  
 -	rpc_remove_pipe_dir_object(net,
 -			&clnt->cl_pipedir_objects,
 -			&p->pdo);
 -	rpc_destroy_pipe_data(p->pipe);
 -	kfree(p);
 +	sb = rpc_get_sb_net(net);
 +	if (sb) {
 +		if (clnt->cl_dentry)
 +			gss_pipes_dentries_destroy(auth);
 +		rpc_put_sb_net(net);
 +	}
  }
  
++<<<<<<< HEAD
 +static int gss_pipes_dentries_create_net(struct rpc_clnt *clnt,
 +					 struct rpc_auth *auth)
 +{
 +	struct net *net = rpc_net_ns(clnt);
 +	struct super_block *sb;
 +	int err = 0;
 +
 +	sb = rpc_get_sb_net(net);
 +	if (sb) {
 +		if (clnt->cl_dentry)
 +			err = gss_pipes_dentries_create(auth);
 +		rpc_put_sb_net(net);
 +	}
 +	return err;
++=======
+ static void __gss_pipe_release(struct kref *kref)
+ {
+ 	struct gss_pipe *p = container_of(kref, struct gss_pipe, kref);
+ 
+ 	__gss_pipe_free(p);
+ }
+ 
+ static void gss_pipe_free(struct gss_pipe *p)
+ {
+ 	if (p != NULL)
+ 		kref_put(&p->kref, __gss_pipe_release);
++>>>>>>> 414a62959840 (RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches)
  }
  
  /*
@@@ -915,35 -989,30 +1027,55 @@@ gss_create(struct rpc_auth_create_args 
  	 * that we supported only the old pipe.  So we instead create
  	 * the new pipe first.
  	 */
++<<<<<<< HEAD
 +	gss_auth->pipe[1] = rpc_mkpipe_data(&gss_upcall_ops_v1,
 +					    RPC_PIPE_WAIT_FOR_OPEN);
 +	if (IS_ERR(gss_auth->pipe[1])) {
 +		err = PTR_ERR(gss_auth->pipe[1]);
 +		goto err_put_mech;
++=======
+ 	gss_pipe = gss_pipe_get(clnt, "gssd", &gss_upcall_ops_v1);
+ 	if (IS_ERR(gss_pipe)) {
+ 		err = PTR_ERR(gss_pipe);
+ 		goto err_destroy_credcache;
++>>>>>>> 414a62959840 (RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches)
  	}
 -	gss_auth->gss_pipe[1] = gss_pipe;
  
++<<<<<<< HEAD
 +	gss_auth->pipe[0] = rpc_mkpipe_data(&gss_upcall_ops_v0,
 +					    RPC_PIPE_WAIT_FOR_OPEN);
 +	if (IS_ERR(gss_auth->pipe[0])) {
 +		err = PTR_ERR(gss_auth->pipe[0]);
++=======
+ 	gss_pipe = gss_pipe_get(clnt, gss_auth->mech->gm_name,
+ 			&gss_upcall_ops_v0);
+ 	if (IS_ERR(gss_pipe)) {
+ 		err = PTR_ERR(gss_pipe);
++>>>>>>> 414a62959840 (RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches)
  		goto err_destroy_pipe_1;
  	}
 -	gss_auth->gss_pipe[0] = gss_pipe;
 +	err = gss_pipes_dentries_create_net(clnt, auth);
 +	if (err)
 +		goto err_destroy_pipe_0;
 +	err = rpcauth_init_credcache(auth);
 +	if (err)
 +		goto err_unlink_pipes;
  
  	return auth;
 +err_unlink_pipes:
 +	gss_pipes_dentries_destroy_net(clnt, auth);
 +err_destroy_pipe_0:
 +	rpc_destroy_pipe_data(gss_auth->pipe[0]);
  err_destroy_pipe_1:
++<<<<<<< HEAD
 +	rpc_destroy_pipe_data(gss_auth->pipe[1]);
++=======
+ 	gss_pipe_free(gss_auth->gss_pipe[1]);
+ err_destroy_credcache:
+ 	rpcauth_destroy_credcache(auth);
++>>>>>>> 414a62959840 (RPCSEC_GSS: Share rpc_pipes when an rpc_clnt owns multiple rpcsec auth caches)
  err_put_mech:
  	gss_mech_put(gss_auth->mech);
 -err_put_net:
 -	put_net(gss_auth->net);
  err_free:
  	kfree(gss_auth->target_name);
  	kfree(gss_auth);
* Unmerged path net/sunrpc/auth_gss/auth_gss.c
