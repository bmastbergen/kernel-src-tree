xfs: format logged extents directly into the CIL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Christoph Hellwig <hch@infradead.org>
commit da7765031de15273d370d18a5354e1d8001ce2a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/da776503.failed

With the new iop_format scheme there is no need to have a temporary buffer
to format logged extents into, we can do so directly into the CIL.  This
also allows to remove the shortcut for big endian systems that probably
hasn't gotten a lot of test coverage for a long time.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit da7765031de15273d370d18a5354e1d8001ce2a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode_item.c
diff --cc fs/xfs/xfs_inode_item.c
index f86ec16592fa,45224d28049e..000000000000
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@@ -145,41 -146,6 +145,44 @@@ xfs_inode_item_size
  }
  
  /*
++<<<<<<< HEAD
 + * xfs_inode_item_format_extents - convert in-core extents to on-disk form
 + *
 + * For either the data or attr fork in extent format, we need to endian convert
 + * the in-core extent as we place them into the on-disk inode. In this case, we
 + * need to do this conversion before we write the extents into the log. Because
 + * we don't have the disk inode to write into here, we allocate a buffer and
 + * format the extents into it via xfs_iextents_copy(). We free the buffer in
 + * the unlock routine after the copy for the log has been made.
 + *
 + * In the case of the data fork, the in-core and on-disk fork sizes can be
 + * different due to delayed allocation extents. We only log on-disk extents
 + * here, so always use the physical fork size to determine the size of the
 + * buffer we need to allocate.
 + */
 +STATIC void
 +xfs_inode_item_format_extents(
 +	struct xfs_inode	*ip,
 +	struct xfs_log_iovec	*vecp,
 +	int			whichfork,
 +	int			type)
 +{
 +	xfs_bmbt_rec_t		*ext_buffer;
 +
 +	ext_buffer = kmem_alloc(XFS_IFORK_SIZE(ip, whichfork), KM_SLEEP);
 +	if (whichfork == XFS_DATA_FORK)
 +		ip->i_itemp->ili_extents_buf = ext_buffer;
 +	else
 +		ip->i_itemp->ili_aextents_buf = ext_buffer;
 +
 +	vecp->i_addr = ext_buffer;
 +	vecp->i_len = xfs_iextents_copy(ip, ext_buffer, whichfork);
 +	vecp->i_type = type;
 +}
 +
 +/*
++=======
++>>>>>>> da7765031de1 (xfs: format logged extents directly into the CIL)
   * If this is a v1 format inode, then we need to log it as such.  This means
   * that we have to copy the link count from the new field to the old.  We
   * don't have to worry about the new fields, because nothing trusts them as
@@@ -225,31 -192,19 +228,43 @@@ xfs_inode_item_format_data_fork
  		if ((iip->ili_fields & XFS_ILOG_DEXT) &&
  		    ip->i_d.di_nextents > 0 &&
  		    ip->i_df.if_bytes > 0) {
+ 			struct xfs_bmbt_rec *p;
+ 
  			ASSERT(ip->i_df.if_u1.if_extents != NULL);
  			ASSERT(ip->i_df.if_bytes / sizeof(xfs_bmbt_rec_t) > 0);
- 			ASSERT(iip->ili_extents_buf == NULL);
  
++<<<<<<< HEAD
 +#ifdef XFS_NATIVE_HOST
 +                       if (ip->i_d.di_nextents == ip->i_df.if_bytes /
 +                                               (uint)sizeof(xfs_bmbt_rec_t)) {
 +				/*
 +				 * There are no delayed allocation
 +				 * extents, so just point to the
 +				 * real extents array.
 +				 */
 +				vecp->i_addr = ip->i_df.if_u1.if_extents;
 +				vecp->i_len = ip->i_df.if_bytes;
 +				vecp->i_type = XLOG_REG_TYPE_IEXT;
 +			} else
 +#endif
 +			{
 +				xfs_inode_item_format_extents(ip, vecp,
 +					XFS_DATA_FORK, XLOG_REG_TYPE_IEXT);
 +			}
 +			ASSERT(vecp->i_len <= ip->i_df.if_bytes);
 +			iip->ili_format.ilf_dsize = vecp->i_len;
 +			vecp++;
 +			(*nvecs)++;
++=======
+ 			p = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IEXT);
+ 			data_bytes = xfs_iextents_copy(ip, p, XFS_DATA_FORK);
+ 			xlog_finish_iovec(lv, *vecp, data_bytes);
+ 
+ 			ASSERT(data_bytes <= ip->i_df.if_bytes);
+ 
+ 			ilf->ilf_dsize = data_bytes;
+ 			ilf->ilf_size++;
++>>>>>>> da7765031de1 (xfs: format logged extents directly into the CIL)
  		} else {
  			iip->ili_fields &= ~XFS_ILOG_DEXT;
  		}
@@@ -347,22 -295,13 +364,32 @@@ xfs_inode_item_format_attr_fork
  			ASSERT(ip->i_afp->if_bytes / sizeof(xfs_bmbt_rec_t) ==
  				ip->i_d.di_anextents);
  			ASSERT(ip->i_afp->if_u1.if_extents != NULL);
++<<<<<<< HEAD
 +#ifdef XFS_NATIVE_HOST
 +			/*
 +			 * There are not delayed allocation extents
 +			 * for attributes, so just point at the array.
 +			 */
 +			vecp->i_addr = ip->i_afp->if_u1.if_extents;
 +			vecp->i_len = ip->i_afp->if_bytes;
 +			vecp->i_type = XLOG_REG_TYPE_IATTR_EXT;
 +#else
 +			ASSERT(iip->ili_aextents_buf == NULL);
 +			xfs_inode_item_format_extents(ip, vecp,
 +					XFS_ATTR_FORK, XLOG_REG_TYPE_IATTR_EXT);
 +#endif
 +			iip->ili_format.ilf_asize = vecp->i_len;
 +			vecp++;
 +			(*nvecs)++;
++=======
+ 
+ 			p = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_EXT);
+ 			data_bytes = xfs_iextents_copy(ip, p, XFS_ATTR_FORK);
+ 			xlog_finish_iovec(lv, *vecp, data_bytes);
+ 
+ 			ilf->ilf_asize = data_bytes;
+ 			ilf->ilf_size++;
++>>>>>>> da7765031de1 (xfs: format logged extents directly into the CIL)
  		} else {
  			iip->ili_fields &= ~XFS_ILOG_AEXT;
  		}
diff --git a/fs/xfs/xfs_inode_fork.c b/fs/xfs/xfs_inode_fork.c
index 0c3655013070..a245d6b7cacb 100644
--- a/fs/xfs/xfs_inode_fork.c
+++ b/fs/xfs/xfs_inode_fork.c
@@ -733,15 +733,16 @@ xfs_idestroy_fork(
 }
 
 /*
- * xfs_iextents_copy()
+ * Convert in-core extents to on-disk form
  *
- * This is called to copy the REAL extents (as opposed to the delayed
- * allocation extents) from the inode into the given buffer.  It
- * returns the number of bytes copied into the buffer.
+ * For either the data or attr fork in extent format, we need to endian convert
+ * the in-core extent as we place them into the on-disk inode.
  *
- * If there are no delayed allocation extents, then we can just
- * memcpy() the extents into the buffer.  Otherwise, we need to
- * examine each extent in turn and skip those which are delayed.
+ * In the case of the data fork, the in-core and on-disk fork sizes can be
+ * different due to delayed allocation extents. We only copy on-disk extents
+ * here, so callers must always use the physical fork size to determine the
+ * size of the buffer passed to this routine.  We will return the size actually
+ * used.
  */
 int
 xfs_iextents_copy(
* Unmerged path fs/xfs/xfs_inode_item.c
diff --git a/fs/xfs/xfs_inode_item.h b/fs/xfs/xfs_inode_item.h
index dce4d656768c..29b5f2b6533a 100644
--- a/fs/xfs/xfs_inode_item.h
+++ b/fs/xfs/xfs_inode_item.h
@@ -34,10 +34,6 @@ typedef struct xfs_inode_log_item {
 	unsigned short		ili_logged;	   /* flushed logged data */
 	unsigned int		ili_last_fields;   /* fields when flushed */
 	unsigned int		ili_fields;	   /* fields to be logged */
-	struct xfs_bmbt_rec	*ili_extents_buf;  /* array of logged
-						      data exts */
-	struct xfs_bmbt_rec	*ili_aextents_buf; /* array of logged
-						      attr exts */
 	xfs_inode_log_format_t	ili_format;	   /* logged structure */
 } xfs_inode_log_item_t;
 
