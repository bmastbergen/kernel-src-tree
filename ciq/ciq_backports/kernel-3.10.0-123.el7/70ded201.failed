NFS: Add tracepoints for debugging NFS rename and sillyrename issues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Trond Myklebust <Trond.Myklebust@netapp.com>
commit 70ded2017072ae16aeaa7fb2a15a879a475161a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/70ded201.failed

	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit 70ded2017072ae16aeaa7fb2a15a879a475161a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfstrace.h
diff --cc fs/nfs/nfstrace.h
index 73c8e1edeef4,a20f0d147cf2..000000000000
--- a/fs/nfs/nfstrace.h
+++ b/fs/nfs/nfstrace.h
@@@ -157,6 -157,499 +157,502 @@@ DEFINE_NFS_INODE_EVENT_DONE(nfs_fsync_e
  DEFINE_NFS_INODE_EVENT(nfs_access_enter);
  DEFINE_NFS_INODE_EVENT_DONE(nfs_access_exit);
  
++<<<<<<< HEAD
++=======
+ #define show_lookup_flags(flags) \
+ 	__print_flags((unsigned long)flags, "|", \
+ 			{ LOOKUP_AUTOMOUNT, "AUTOMOUNT" }, \
+ 			{ LOOKUP_DIRECTORY, "DIRECTORY" }, \
+ 			{ LOOKUP_OPEN, "OPEN" }, \
+ 			{ LOOKUP_CREATE, "CREATE" }, \
+ 			{ LOOKUP_EXCL, "EXCL" })
+ 
+ DECLARE_EVENT_CLASS(nfs_lookup_event,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			unsigned int flags
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, flags),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(unsigned int, flags)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"flags=%u (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->flags,
+ 			show_lookup_flags(__entry->flags),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS_LOOKUP_EVENT(name) \
+ 	DEFINE_EVENT(nfs_lookup_event, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct dentry *dentry, \
+ 				unsigned int flags \
+ 			), \
+ 			TP_ARGS(dir, dentry, flags))
+ 
+ DECLARE_EVENT_CLASS(nfs_lookup_event_done,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			unsigned int flags,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, flags, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(int, error)
+ 			__field(unsigned int, flags)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->error = error;
+ 			__entry->flags = flags;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d flags=%u (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			__entry->flags,
+ 			show_lookup_flags(__entry->flags),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS_LOOKUP_EVENT_DONE(name) \
+ 	DEFINE_EVENT(nfs_lookup_event_done, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct dentry *dentry, \
+ 				unsigned int flags, \
+ 				int error \
+ 			), \
+ 			TP_ARGS(dir, dentry, flags, error))
+ 
+ DEFINE_NFS_LOOKUP_EVENT(nfs_lookup_enter);
+ DEFINE_NFS_LOOKUP_EVENT_DONE(nfs_lookup_exit);
+ DEFINE_NFS_LOOKUP_EVENT(nfs_lookup_revalidate_enter);
+ DEFINE_NFS_LOOKUP_EVENT_DONE(nfs_lookup_revalidate_exit);
+ 
+ #define show_open_flags(flags) \
+ 	__print_flags((unsigned long)flags, "|", \
+ 		{ O_CREAT, "O_CREAT" }, \
+ 		{ O_EXCL, "O_EXCL" }, \
+ 		{ O_TRUNC, "O_TRUNC" }, \
+ 		{ O_APPEND, "O_APPEND" }, \
+ 		{ O_DSYNC, "O_DSYNC" }, \
+ 		{ O_DIRECT, "O_DIRECT" }, \
+ 		{ O_DIRECTORY, "O_DIRECTORY" })
+ 
+ #define show_fmode_flags(mode) \
+ 	__print_flags(mode, "|", \
+ 		{ ((__force unsigned long)FMODE_READ), "READ" }, \
+ 		{ ((__force unsigned long)FMODE_WRITE), "WRITE" }, \
+ 		{ ((__force unsigned long)FMODE_EXEC), "EXEC" })
+ 
+ TRACE_EVENT(nfs_atomic_open_enter,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct nfs_open_context *ctx,
+ 			unsigned int flags
+ 		),
+ 
+ 		TP_ARGS(dir, ctx, flags),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(unsigned int, flags)
+ 			__field(unsigned int, fmode)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, ctx->dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__entry->fmode = (__force unsigned int)ctx->mode;
+ 			__assign_str(name, ctx->dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"flags=%u (%s) fmode=%s name=%02x:%02x:%llu/%s",
+ 			__entry->flags,
+ 			show_open_flags(__entry->flags),
+ 			show_fmode_flags(__entry->fmode),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ TRACE_EVENT(nfs_atomic_open_exit,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct nfs_open_context *ctx,
+ 			unsigned int flags,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, ctx, flags, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(int, error)
+ 			__field(unsigned int, flags)
+ 			__field(unsigned int, fmode)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, ctx->dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->error = error;
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__entry->fmode = (__force unsigned int)ctx->mode;
+ 			__assign_str(name, ctx->dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d flags=%u (%s) fmode=%s "
+ 			"name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			__entry->flags,
+ 			show_open_flags(__entry->flags),
+ 			show_fmode_flags(__entry->fmode),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ TRACE_EVENT(nfs_create_enter,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			unsigned int flags
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, flags),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(unsigned int, flags)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"flags=%u (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->flags,
+ 			show_open_flags(__entry->flags),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ TRACE_EVENT(nfs_create_exit,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			unsigned int flags,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, flags, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(int, error)
+ 			__field(unsigned int, flags)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->error = error;
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d flags=%u (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			__entry->flags,
+ 			show_open_flags(__entry->flags),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ DECLARE_EVENT_CLASS(nfs_directory_event,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry
+ 		),
+ 
+ 		TP_ARGS(dir, dentry),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"name=%02x:%02x:%llu/%s",
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS_DIRECTORY_EVENT(name) \
+ 	DEFINE_EVENT(nfs_directory_event, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct dentry *dentry \
+ 			), \
+ 			TP_ARGS(dir, dentry))
+ 
+ DECLARE_EVENT_CLASS(nfs_directory_event_done,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(int, error)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->error = error;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS_DIRECTORY_EVENT_DONE(name) \
+ 	DEFINE_EVENT(nfs_directory_event_done, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct dentry *dentry, \
+ 				int error \
+ 			), \
+ 			TP_ARGS(dir, dentry, error))
+ 
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_mknod_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_mknod_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_mkdir_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_mkdir_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_rmdir_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_rmdir_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_remove_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_remove_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_unlink_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_unlink_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_symlink_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_symlink_exit);
+ 
+ DECLARE_EVENT_CLASS(nfs_rename_event,
+ 		TP_PROTO(
+ 			const struct inode *old_dir,
+ 			const struct dentry *old_dentry,
+ 			const struct inode *new_dir,
+ 			const struct dentry *new_dentry
+ 		),
+ 
+ 		TP_ARGS(old_dir, old_dentry, new_dir, new_dentry),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(u64, old_dir)
+ 			__field(u64, new_dir)
+ 			__string(old_name, old_dentry->d_name.name)
+ 			__string(new_name, new_dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = old_dir->i_sb->s_dev;
+ 			__entry->old_dir = NFS_FILEID(old_dir);
+ 			__entry->new_dir = NFS_FILEID(new_dir);
+ 			__assign_str(old_name, old_dentry->d_name.name);
+ 			__assign_str(new_name, new_dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"old_name=%02x:%02x:%llu/%s new_name=%02x:%02x:%llu/%s",
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->old_dir,
+ 			__get_str(old_name),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->new_dir,
+ 			__get_str(new_name)
+ 		)
+ );
+ #define DEFINE_NFS_RENAME_EVENT(name) \
+ 	DEFINE_EVENT(nfs_rename_event, name, \
+ 			TP_PROTO( \
+ 				const struct inode *old_dir, \
+ 				const struct dentry *old_dentry, \
+ 				const struct inode *new_dir, \
+ 				const struct dentry *new_dentry \
+ 			), \
+ 			TP_ARGS(old_dir, old_dentry, new_dir, new_dentry))
+ 
+ DECLARE_EVENT_CLASS(nfs_rename_event_done,
+ 		TP_PROTO(
+ 			const struct inode *old_dir,
+ 			const struct dentry *old_dentry,
+ 			const struct inode *new_dir,
+ 			const struct dentry *new_dentry,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(old_dir, old_dentry, new_dir, new_dentry, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(int, error)
+ 			__field(u64, old_dir)
+ 			__string(old_name, old_dentry->d_name.name)
+ 			__field(u64, new_dir)
+ 			__string(new_name, new_dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = old_dir->i_sb->s_dev;
+ 			__entry->old_dir = NFS_FILEID(old_dir);
+ 			__entry->new_dir = NFS_FILEID(new_dir);
+ 			__entry->error = error;
+ 			__assign_str(old_name, old_dentry->d_name.name);
+ 			__assign_str(new_name, new_dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d old_name=%02x:%02x:%llu/%s "
+ 			"new_name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->old_dir,
+ 			__get_str(old_name),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->new_dir,
+ 			__get_str(new_name)
+ 		)
+ );
+ #define DEFINE_NFS_RENAME_EVENT_DONE(name) \
+ 	DEFINE_EVENT(nfs_rename_event_done, name, \
+ 			TP_PROTO( \
+ 				const struct inode *old_dir, \
+ 				const struct dentry *old_dentry, \
+ 				const struct inode *new_dir, \
+ 				const struct dentry *new_dentry, \
+ 				int error \
+ 			), \
+ 			TP_ARGS(old_dir, old_dentry, new_dir, \
+ 				new_dentry, error))
+ 
+ DEFINE_NFS_RENAME_EVENT(nfs_rename_enter);
+ DEFINE_NFS_RENAME_EVENT_DONE(nfs_rename_exit);
+ 
+ DEFINE_NFS_RENAME_EVENT_DONE(nfs_sillyrename_rename);
+ 
+ TRACE_EVENT(nfs_sillyrename_unlink,
+ 		TP_PROTO(
+ 			const struct nfs_unlinkdata *data,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(data, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(int, error)
+ 			__field(u64, dir)
+ 			__dynamic_array(char, name, data->args.name.len + 1)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			struct inode *dir = data->dir;
+ 			size_t len = data->args.name.len;
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->error = error;
+ 			memcpy(__get_dynamic_array(name),
+ 				data->args.name.name, len);
+ 			((char *)__get_dynamic_array(name))[len] = 0;
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
++>>>>>>> 70ded2017072 (NFS: Add tracepoints for debugging NFS rename and sillyrename issues)
  #endif /* _TRACE_NFS_H */
  
  #undef TRACE_INCLUDE_PATH
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 5b465aec0f11..8c6c122a9224 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -1860,6 +1860,7 @@ int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		 new_dentry->d_parent->d_name.name, new_dentry->d_name.name,
 		 new_dentry->d_count);
 
+	trace_nfs_rename_enter(old_dir, old_dentry, new_dir, new_dentry);
 	/*
 	 * For non-directories, check whether the target is busy and if so,
 	 * make a copy of the dentry and then do a silly-rename. If the
@@ -1906,6 +1907,8 @@ int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 out:
 	if (rehash)
 		d_rehash(rehash);
+	trace_nfs_rename_exit(old_dir, old_dentry,
+			new_dir, new_dentry, error);
 	if (!error) {
 		if (new_inode != NULL)
 			nfs_drop_nlink(new_inode);
* Unmerged path fs/nfs/nfstrace.h
diff --git a/fs/nfs/unlink.c b/fs/nfs/unlink.c
index 0d9d2fdb24f6..876a7312a12f 100644
--- a/fs/nfs/unlink.c
+++ b/fs/nfs/unlink.c
@@ -20,6 +20,8 @@
 #include "iostat.h"
 #include "delegation.h"
 
+#include "nfstrace.h"
+
 /**
  * nfs_free_unlinkdata - release data from a sillydelete operation.
  * @data: pointer to unlink structure.
@@ -77,6 +79,7 @@ static void nfs_async_unlink_done(struct rpc_task *task, void *calldata)
 	struct nfs_unlinkdata *data = calldata;
 	struct inode *dir = data->dir;
 
+	trace_nfs_sillyrename_unlink(data, task->tk_status);
 	if (!NFS_PROTO(dir)->unlink_done(task, dir))
 		rpc_restart_call_prepare(task);
 }
@@ -336,6 +339,8 @@ static void nfs_async_rename_done(struct rpc_task *task, void *calldata)
 	struct inode *new_dir = data->new_dir;
 	struct dentry *old_dentry = data->old_dentry;
 
+	trace_nfs_sillyrename_rename(old_dir, old_dentry,
+			new_dir, data->new_dentry, task->tk_status);
 	if (!NFS_PROTO(old_dir)->rename_done(task, old_dir, new_dir)) {
 		rpc_restart_call_prepare(task);
 		return;
