xfs: convert directory vector functions to constants

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 24dd0f546c366da68f33bbf2ecef2306f8c2281d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/24dd0f54.failed

Next step in the vectorisation process is the directory free block
encode/decode operations. There are relatively few of these, though
there are quite a number of calls to them.

Binary sizes:

   text    data     bss     dec     hex filename
 794490   96802    1096  892388   d9de4 fs/xfs/xfs.o.orig
 792986   96802    1096  890884   d9804 fs/xfs/xfs.o.p1
 792350   96802    1096  890248   d9588 fs/xfs/xfs.o.p2
 789293   96802    1096  887191   d8997 fs/xfs/xfs.o.p3
 789005   96802    1096  886903   d8997 fs/xfs/xfs.o.p4
 789061   96802    1096  886959   d88af fs/xfs/xfs.o.p5
 789733   96802    1096  887631   d8b4f fs/xfs/xfs.o.p6
 791421   96802    1096  889319   d91e7 fs/xfs/xfs.o.p7
 791701   96802    1096  889599   d92ff fs/xfs/xfs.o.p8

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Ben Myers <bpm@sgi.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 24dd0f546c366da68f33bbf2ecef2306f8c2281d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_da_format.c
#	fs/xfs/xfs_dir2.h
#	fs/xfs/xfs_dir2_format.h
#	fs/xfs/xfs_dir2_node.c
diff --cc fs/xfs/xfs_dir2.h
index e937d9991c18,4264cb9199f8..000000000000
--- a/fs/xfs/xfs_dir2.h
+++ b/fs/xfs/xfs_dir2.h
@@@ -27,6 -32,83 +27,86 @@@ struct xfs_trans
  extern struct xfs_name	xfs_name_dotdot;
  
  /*
++<<<<<<< HEAD
++=======
+  * directory operations vector for encode/decode routines
+  */
+ struct xfs_dir_ops {
+ 	int	(*sf_entsize)(struct xfs_dir2_sf_hdr *hdr, int len);
+ 	struct xfs_dir2_sf_entry *
+ 		(*sf_nextentry)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	__uint8_t (*sf_get_ftype)(struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ftype)(struct xfs_dir2_sf_entry *sfep,
+ 				__uint8_t ftype);
+ 	xfs_ino_t (*sf_get_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 			      struct xfs_dir2_sf_entry *sfep,
+ 			      xfs_ino_t ino);
+ 	xfs_ino_t (*sf_get_parent_ino)(struct xfs_dir2_sf_hdr *hdr);
+ 	void	(*sf_put_parent_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				     xfs_ino_t ino);
+ 
+ 	int	(*data_entsize)(int len);
+ 	__uint8_t (*data_get_ftype)(struct xfs_dir2_data_entry *dep);
+ 	void	(*data_put_ftype)(struct xfs_dir2_data_entry *dep,
+ 				__uint8_t ftype);
+ 	__be16 * (*data_entry_tag_p)(struct xfs_dir2_data_entry *dep);
+ 	struct xfs_dir2_data_free *
+ 		(*data_bestfree_p)(struct xfs_dir2_data_hdr *hdr);
+ 
+ 	xfs_dir2_data_aoff_t (*data_dot_offset)(void);
+ 	xfs_dir2_data_aoff_t (*data_dotdot_offset)(void);
+ 	xfs_dir2_data_aoff_t (*data_first_offset)(void);
+ 	size_t	(*data_entry_offset)(void);
+ 
+ 	struct xfs_dir2_data_entry *
+ 		(*data_dot_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_dotdot_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_first_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_unused *
+ 		(*data_unused_p)(struct xfs_dir2_data_hdr *hdr);
+ 
+ 	int	(*leaf_hdr_size)(void);
+ 	void	(*leaf_hdr_to_disk)(struct xfs_dir2_leaf *to,
+ 				    struct xfs_dir3_icleaf_hdr *from);
+ 	void	(*leaf_hdr_from_disk)(struct xfs_dir3_icleaf_hdr *to,
+ 				      struct xfs_dir2_leaf *from);
+ 	int	(*leaf_max_ents)(struct xfs_mount *mp);
+ 	struct xfs_dir2_leaf_entry *
+ 		(*leaf_ents_p)(struct xfs_dir2_leaf *lp);
+ 
+ 	int	(*node_hdr_size)(void);
+ 	void	(*node_hdr_to_disk)(struct xfs_da_intnode *to,
+ 				    struct xfs_da3_icnode_hdr *from);
+ 	void	(*node_hdr_from_disk)(struct xfs_da3_icnode_hdr *to,
+ 				      struct xfs_da_intnode *from);
+ 	struct xfs_da_node_entry *
+ 		(*node_tree_p)(struct xfs_da_intnode *dap);
+ 
+ 	int	(*free_hdr_size)(void);
+ 	void	(*free_hdr_to_disk)(struct xfs_dir2_free *to,
+ 				    struct xfs_dir3_icfree_hdr *from);
+ 	void	(*free_hdr_from_disk)(struct xfs_dir3_icfree_hdr *to,
+ 				      struct xfs_dir2_free *from);
+ 	int	(*free_max_bests)(struct xfs_mount *mp);
+ 	__be16 * (*free_bests_p)(struct xfs_dir2_free *free);
+ 	xfs_dir2_db_t (*db_to_fdb)(struct xfs_mount *mp, xfs_dir2_db_t db);
+ 	int	(*db_to_fdindex)(struct xfs_mount *mp, xfs_dir2_db_t db);
+ };
+ 
+ extern const struct xfs_dir_ops *
+ 	xfs_dir_get_ops(struct xfs_mount *mp, struct xfs_inode *dp);
+ extern const struct xfs_dir_ops *
+ 	xfs_nondir_get_ops(struct xfs_mount *mp, struct xfs_inode *dp);
+ 
+ /*
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
   * Generic directory interface routines
   */
  extern void xfs_dir_startup(void);
diff --cc fs/xfs/xfs_dir2_format.h
index 2095e17b75cb,a19d3f8f639c..000000000000
--- a/fs/xfs/xfs_dir2_format.h
+++ b/fs/xfs/xfs_dir2_format.h
@@@ -743,48 -704,6 +743,51 @@@ struct xfs_dir3_icfree_hdr 
  
  };
  
++<<<<<<< HEAD:fs/xfs/xfs_dir2_format.h
 +void xfs_dir3_free_hdr_from_disk(struct xfs_dir3_icfree_hdr *to,
 +				 struct xfs_dir2_free *from);
 +
 +static inline int
 +xfs_dir3_free_hdr_size(struct xfs_mount *mp)
 +{
 +	if (xfs_sb_version_hascrc(&mp->m_sb))
 +		return sizeof(struct xfs_dir3_free_hdr);
 +	return sizeof(struct xfs_dir2_free_hdr);
 +}
 +
 +static inline int
 +xfs_dir3_free_max_bests(struct xfs_mount *mp)
 +{
 +	return (mp->m_dirblksize - xfs_dir3_free_hdr_size(mp)) /
 +		sizeof(xfs_dir2_data_off_t);
 +}
 +
 +static inline __be16 *
 +xfs_dir3_free_bests_p(struct xfs_mount *mp, struct xfs_dir2_free *free)
 +{
 +	return (__be16 *)((char *)free + xfs_dir3_free_hdr_size(mp));
 +}
 +
 +/*
 + * Convert data space db to the corresponding free db.
 + */
 +static inline xfs_dir2_db_t
 +xfs_dir2_db_to_fdb(struct xfs_mount *mp, xfs_dir2_db_t db)
 +{
 +	return XFS_DIR2_FREE_FIRSTDB(mp) + db / xfs_dir3_free_max_bests(mp);
 +}
 +
 +/*
 + * Convert data space db to the corresponding index in a free db.
 + */
 +static inline int
 +xfs_dir2_db_to_fdindex(struct xfs_mount *mp, xfs_dir2_db_t db)
 +{
 +	return db % xfs_dir3_free_max_bests(mp);
 +}
 +
++=======
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants):fs/xfs/xfs_da_format.h
  /*
   * Single block format.
   *
diff --cc fs/xfs/xfs_dir2_node.c
index cae73a62bfcc,853798519ae9..000000000000
--- a/fs/xfs/xfs_dir2_node.c
+++ b/fs/xfs/xfs_dir2_node.c
@@@ -392,9 -347,9 +394,15 @@@ xfs_dir2_leaf_to_node
  	freehdr.nused = n;
  	freehdr.nvalid = be32_to_cpu(ltp->bestcount);
  
++<<<<<<< HEAD
 +	xfs_dir3_free_hdr_to_disk(fbp->b_addr, &freehdr);
 +	xfs_dir2_free_log_bests(tp, fbp, 0, freehdr.nvalid - 1);
 +	xfs_dir2_free_log_header(tp, fbp);
++=======
+ 	dp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);
+ 	xfs_dir2_free_log_bests(tp, dp, fbp, 0, freehdr.nvalid - 1);
+ 	xfs_dir2_free_log_header(tp, dp, fbp);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  
  	/*
  	 * Converting the leaf to a leafnode is just a matter of changing the
@@@ -513,9 -468,9 +521,13 @@@ xfs_dir2_free_hdr_check
  {
  	struct xfs_dir3_icfree_hdr hdr;
  
 -	dp->d_ops->free_hdr_from_disk(&hdr, bp->b_addr);
 +	xfs_dir3_free_hdr_from_disk(&hdr, bp->b_addr);
  
++<<<<<<< HEAD
 +	ASSERT((hdr.firstdb % xfs_dir3_free_max_bests(mp)) == 0);
++=======
+ 	ASSERT((hdr.firstdb % dp->d_ops->free_max_bests(dp->i_mount)) == 0);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  	ASSERT(hdr.firstdb <= db);
  	ASSERT(db < hdr.firstdb + hdr.nvalid);
  }
@@@ -1118,10 -1079,10 +1130,15 @@@ xfs_dir3_data_block_free
  	int			logfree = 0;
  	__be16			*bests;
  	struct xfs_dir3_icfree_hdr freehdr;
 -	struct xfs_inode	*dp = args->dp;
  
++<<<<<<< HEAD
 +	xfs_dir3_free_hdr_from_disk(&freehdr, free);
 +
 +	bests = xfs_dir3_free_bests_p(tp->t_mountp, free);
++=======
+ 	dp->d_ops->free_hdr_from_disk(&freehdr, free);
+ 	bests = dp->d_ops->free_bests_p(free);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  	if (hdr) {
  		/*
  		 * Data block is not empty, just set the free entry to the new
@@@ -1155,8 -1116,8 +1172,13 @@@
  		logfree = 1;
  	}
  
++<<<<<<< HEAD
 +	xfs_dir3_free_hdr_to_disk(free, &freehdr);
 +	xfs_dir2_free_log_header(tp, fbp);
++=======
+ 	dp->d_ops->free_hdr_to_disk(free, &freehdr);
+ 	xfs_dir2_free_log_header(tp, dp, fbp);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  
  	/*
  	 * If there are no useful entries left in the block, get rid of the
@@@ -1292,8 -1253,8 +1314,13 @@@ xfs_dir2_leafn_remove
  #ifdef DEBUG
  	{
  		struct xfs_dir3_icfree_hdr freehdr;
++<<<<<<< HEAD
 +		xfs_dir3_free_hdr_from_disk(&freehdr, free);
 +		ASSERT(freehdr.firstdb == xfs_dir3_free_max_bests(mp) *
++=======
+ 		dp->d_ops->free_hdr_from_disk(&freehdr, free);
+ 		ASSERT(freehdr.firstdb == dp->d_ops->free_max_bests(mp) *
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  					  (fdb - XFS_DIR2_FREE_FIRSTDB(mp)));
  	}
  #endif
@@@ -1724,8 -1689,8 +1751,13 @@@ xfs_dir2_node_addname_int
  		ifbno = fblk->blkno;
  		free = fbp->b_addr;
  		findex = fblk->index;
++<<<<<<< HEAD
 +		bests = xfs_dir3_free_bests_p(mp, free);
 +		xfs_dir3_free_hdr_from_disk(&freehdr, free);
++=======
+ 		bests = dp->d_ops->free_bests_p(free);
+ 		dp->d_ops->free_hdr_from_disk(&freehdr, free);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  
  		/*
  		 * This means the free entry showed that the data block had
@@@ -1817,8 -1782,8 +1849,13 @@@
  		 * and the freehdr are actually initialised if they are placed
  		 * there, so we have to do it here to avoid warnings. Blech.
  		 */
++<<<<<<< HEAD
 +		bests = xfs_dir3_free_bests_p(mp, free);
 +		xfs_dir3_free_hdr_from_disk(&freehdr, free);
++=======
+ 		bests = dp->d_ops->free_bests_p(free);
+ 		dp->d_ops->free_hdr_from_disk(&freehdr, free);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  		if (be16_to_cpu(bests[findex]) != NULLDATAOFF &&
  		    be16_to_cpu(bests[findex]) >= length)
  			dbno = freehdr.firstdb + findex;
@@@ -1916,18 -1881,18 +1953,28 @@@
  			if (error)
  				return error;
  			free = fbp->b_addr;
++<<<<<<< HEAD
 +			bests = xfs_dir3_free_bests_p(mp, free);
 +			xfs_dir3_free_hdr_from_disk(&freehdr, free);
++=======
+ 			bests = dp->d_ops->free_bests_p(free);
+ 			dp->d_ops->free_hdr_from_disk(&freehdr, free);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  
  			/*
  			 * Remember the first slot as our empty slot.
  			 */
  			freehdr.firstdb = (fbno - XFS_DIR2_FREE_FIRSTDB(mp)) *
- 					xfs_dir3_free_max_bests(mp);
+ 					dp->d_ops->free_max_bests(mp);
  		} else {
  			free = fbp->b_addr;
++<<<<<<< HEAD
 +			bests = xfs_dir3_free_bests_p(mp, free);
 +			xfs_dir3_free_hdr_from_disk(&freehdr, free);
++=======
+ 			bests = dp->d_ops->free_bests_p(free);
+ 			dp->d_ops->free_hdr_from_disk(&freehdr, free);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  		}
  
  		/*
@@@ -1952,8 -1917,8 +1999,13 @@@
  		 */
  		if (bests[findex] == cpu_to_be16(NULLDATAOFF)) {
  			freehdr.nused++;
++<<<<<<< HEAD
 +			xfs_dir3_free_hdr_to_disk(fbp->b_addr, &freehdr);
 +			xfs_dir2_free_log_header(tp, fbp);
++=======
+ 			dp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);
+ 			xfs_dir2_free_log_header(tp, dp, fbp);
++>>>>>>> 24dd0f546c36 (xfs: convert directory vector functions to constants)
  		}
  		/*
  		 * Update the real value in the table.
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_dir2.h
* Unmerged path fs/xfs/xfs_dir2_format.h
diff --git a/fs/xfs/xfs_dir2_leaf.c b/fs/xfs/xfs_dir2_leaf.c
index 2dedee56777d..c28905290861 100644
--- a/fs/xfs/xfs_dir2_leaf.c
+++ b/fs/xfs/xfs_dir2_leaf.c
@@ -2216,7 +2216,7 @@ xfs_dir2_node_to_leaf(
 	/*
 	 * Set up the leaf bests table.
 	 */
-	memcpy(xfs_dir2_leaf_bests_p(ltp), xfs_dir3_free_bests_p(mp, free),
+	memcpy(xfs_dir2_leaf_bests_p(ltp), dp->d_ops->free_bests_p(free),
 		freehdr.nvalid * sizeof(xfs_dir2_data_off_t));
 
 	xfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);
* Unmerged path fs/xfs/xfs_dir2_node.c
