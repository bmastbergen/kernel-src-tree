NFSv4: Honour the 'opened' parameter in the atomic_open() filesystem method

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [fs] nfs: Honour the 'opened' parameter in the atomic_open() filesystem method (Jeff Layton) [1009119]
Rebuild_FUZZ: 98.65%
commit-author Trond Myklebust <Trond.Myklebust@netapp.com>
commit 5bc2afc2b53fc73f154e6344cd898585628e6d27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/5bc2afc2.failed

Determine if we've created a new file by examining the directory change
attribute and/or the O_EXCL flag.

This fixes a regression when doing a non-exclusive create of a new file.
If the FILE_CREATED flag is not set, the atomic_open() command will
perform full file access permissions checks instead of just checking
for MAY_OPEN.

	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit 5bc2afc2b53fc73f154e6344cd898585628e6d27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 41189a249935,488ef9b5c51a..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -2034,7 -2196,9 +2040,13 @@@ out
  static int _nfs4_do_open(struct inode *dir,
  			struct nfs_open_context *ctx,
  			int flags,
++<<<<<<< HEAD
 +			struct iattr *sattr)
++=======
+ 			struct iattr *sattr,
+ 			struct nfs4_label *label,
+ 			int *opened)
++>>>>>>> 5bc2afc2b53f (NFSv4: Honour the 'opened' parameter in the atomic_open() filesystem method)
  {
  	struct nfs4_state_owner  *sp;
  	struct nfs4_state     *state = NULL;
@@@ -2088,11 -2261,15 +2100,13 @@@
  		nfs_fattr_init(opendata->o_res.f_attr);
  		status = nfs4_do_setattr(state->inode, cred,
  				opendata->o_res.f_attr, sattr,
 -				state, label, olabel);
 -		if (status == 0) {
 +				state);
 +		if (status == 0)
  			nfs_setattr_update_inode(state->inode, sattr);
 -			nfs_post_op_update_inode(state->inode, opendata->o_res.f_attr);
 -			nfs_setsecurity(state->inode, opendata->o_res.f_attr, olabel);
 -		}
 +		nfs_post_op_update_inode(state->inode, opendata->o_res.f_attr);
  	}
+ 	if (opendata->file_created)
+ 		*opened |= FILE_CREATED;
  
  	if (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server))
  		*ctx_th = opendata->f_attr.mdsthreshold;
@@@ -2116,7 -2297,9 +2130,13 @@@ out_err
  static struct nfs4_state *nfs4_do_open(struct inode *dir,
  					struct nfs_open_context *ctx,
  					int flags,
++<<<<<<< HEAD
 +					struct iattr *sattr)
++=======
+ 					struct iattr *sattr,
+ 					struct nfs4_label *label,
+ 					int *opened)
++>>>>>>> 5bc2afc2b53f (NFSv4: Honour the 'opened' parameter in the atomic_open() filesystem method)
  {
  	struct nfs_server *server = NFS_SERVER(dir);
  	struct nfs4_exception exception = { };
@@@ -2124,7 -2307,7 +2144,11 @@@
  	int status;
  
  	do {
++<<<<<<< HEAD
 +		status = _nfs4_do_open(dir, ctx, flags, sattr);
++=======
+ 		status = _nfs4_do_open(dir, ctx, flags, sattr, label, opened);
++>>>>>>> 5bc2afc2b53f (NFSv4: Honour the 'opened' parameter in the atomic_open() filesystem method)
  		res = ctx->state;
  		trace_nfs4_open_file(ctx, flags, status);
  		if (status == 0)
@@@ -2477,12 -2669,19 +2501,20 @@@ out
  }
  
  static struct inode *
- nfs4_atomic_open(struct inode *dir, struct nfs_open_context *ctx, int open_flags, struct iattr *attr)
+ nfs4_atomic_open(struct inode *dir, struct nfs_open_context *ctx,
+ 		int open_flags, struct iattr *attr, int *opened)
  {
  	struct nfs4_state *state;
 -	struct nfs4_label l = {0, 0, 0, NULL}, *label = NULL;
 -
 -	label = nfs4_label_init_security(dir, ctx->dentry, attr, &l);
  
  	/* Protect against concurrent sillydeletes */
++<<<<<<< HEAD
 +	state = nfs4_do_open(dir, ctx, open_flags, attr);
++=======
+ 	state = nfs4_do_open(dir, ctx, open_flags, attr, label, opened);
+ 
+ 	nfs4_label_release_security(label);
+ 
++>>>>>>> 5bc2afc2b53f (NFSv4: Honour the 'opened' parameter in the atomic_open() filesystem method)
  	if (IS_ERR(state))
  		return ERR_CAST(state);
  	return state->inode;
@@@ -3095,16 -3340,20 +3127,21 @@@ static in
  nfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,
  		 int flags)
  {
 -	struct nfs4_label l, *ilabel = NULL;
  	struct nfs_open_context *ctx;
  	struct nfs4_state *state;
+ 	int opened = 0;
  	int status = 0;
  
  	ctx = alloc_nfs_open_context(dentry, FMODE_READ);
  	if (IS_ERR(ctx))
  		return PTR_ERR(ctx);
  
 -	ilabel = nfs4_label_init_security(dir, dentry, sattr, &l);
 -
  	sattr->ia_mode &= ~current_umask();
++<<<<<<< HEAD
 +	state = nfs4_do_open(dir, ctx, flags, sattr);
++=======
+ 	state = nfs4_do_open(dir, ctx, flags, sattr, ilabel, &opened);
++>>>>>>> 5bc2afc2b53f (NFSv4: Honour the 'opened' parameter in the atomic_open() filesystem method)
  	if (IS_ERR(state)) {
  		status = PTR_ERR(state);
  		goto out;
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 5b465aec0f11..4e9b492cdb67 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -1422,7 +1422,7 @@ int nfs_atomic_open(struct inode *dir, struct dentry *dentry,
 		goto out;
 
 	nfs_block_sillyrename(dentry->d_parent);
-	inode = NFS_PROTO(dir)->open_context(dir, ctx, open_flags, &attr);
+	inode = NFS_PROTO(dir)->open_context(dir, ctx, open_flags, &attr, opened);
 	nfs_unblock_sillyrename(dentry->d_parent);
 	if (IS_ERR(inode)) {
 		put_nfs_open_context(ctx);
diff --git a/fs/nfs/nfs4file.c b/fs/nfs/nfs4file.c
index e5b804dd944c..77efaf15ec90 100644
--- a/fs/nfs/nfs4file.c
+++ b/fs/nfs/nfs4file.c
@@ -19,6 +19,7 @@ nfs4_file_open(struct inode *inode, struct file *filp)
 	struct inode *dir;
 	unsigned openflags = filp->f_flags;
 	struct iattr attr;
+	int opened = 0;
 	int err;
 
 	/*
@@ -55,7 +56,7 @@ nfs4_file_open(struct inode *inode, struct file *filp)
 		nfs_wb_all(inode);
 	}
 
-	inode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr);
+	inode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, &opened);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
 		switch (err) {
* Unmerged path fs/nfs/nfs4proc.c
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 99dc96aaa00c..596af6aba54c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1454,7 +1454,8 @@ struct nfs_rpc_ops {
 	struct inode * (*open_context) (struct inode *dir,
 				struct nfs_open_context *ctx,
 				int open_flags,
-				struct iattr *iattr);
+				struct iattr *iattr,
+				int *);
 	int (*have_delegation)(struct inode *, fmode_t);
 	int (*return_delegation)(struct inode *);
 	struct nfs_client *(*alloc_client) (const struct nfs_client_initdata *);
