KVM: ioapic: reinject pending interrupts on KVM_SET_IRQCHIP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [virt] kvm/ioapic: reinject pending interrupts on KVM_SET_IRQCHIP (Paolo Bonzini) [1036478]
Rebuild_FUZZ: 97.44%
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 673f7b4257a1fe7b181e1a1182ecc2b6b2b795f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/673f7b42.failed

After the previous patches, an interrupt whose bit is set in the IRR
register will never be in the LAPIC's IRR and has never been injected
on the migration source.  So inject it on the destination.

This fixes migration of Windows guests without HPET (they use the RTC
to trigger the scheduler tick, and lose it after migration).

	Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 673f7b4257a1fe7b181e1a1182ecc2b6b2b795f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/ioapic.c
diff --cc virt/kvm/ioapic.c
index 28f38c197b52,d4b601547f1f..000000000000
--- a/virt/kvm/ioapic.c
+++ b/virt/kvm/ioapic.c
@@@ -163,6 -163,67 +163,70 @@@ static bool rtc_irq_check_coalesced(str
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,
+ 		int irq_level, bool line_status)
+ {
+ 	union kvm_ioapic_redirect_entry entry;
+ 	u32 mask = 1 << irq;
+ 	u32 old_irr;
+ 	int edge, ret;
+ 
+ 	entry = ioapic->redirtbl[irq];
+ 	edge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);
+ 
+ 	if (!irq_level) {
+ 		ioapic->irr &= ~mask;
+ 		ret = 1;
+ 		goto out;
+ 	}
+ 
+ 	/*
+ 	 * Return 0 for coalesced interrupts; for edge-triggered interrupts,
+ 	 * this only happens if a previous edge has not been delivered due
+ 	 * do masking.  For level interrupts, the remote_irr field tells
+ 	 * us if the interrupt is waiting for an EOI.
+ 	 *
+ 	 * RTC is special: it is edge-triggered, but userspace likes to know
+ 	 * if it has been already ack-ed via EOI because coalesced RTC
+ 	 * interrupts lead to time drift in Windows guests.  So we track
+ 	 * EOI manually for the RTC interrupt.
+ 	 */
+ 	if (irq == RTC_GSI && line_status &&
+ 		rtc_irq_check_coalesced(ioapic)) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 
+ 	old_irr = ioapic->irr;
+ 	ioapic->irr |= mask;
+ 	if ((edge && old_irr == ioapic->irr) ||
+ 	    (!edge && entry.fields.remote_irr)) {
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 
+ 	ret = ioapic_service(ioapic, irq, line_status);
+ 
+ out:
+ 	trace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);
+ 	return ret;
+ }
+ 
+ static void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)
+ {
+ 	u32 idx;
+ 
+ 	rtc_irq_eoi_tracking_reset(ioapic);
+ 	for_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)
+ 		ioapic_set_irq(ioapic, idx, 1, true);
+ 
+ 	kvm_rtc_eoi_tracking_restore_all(ioapic);
+ }
+ 
+ 
++>>>>>>> 673f7b4257a1 (KVM: ioapic: reinject pending interrupts on KVM_SET_IRQCHIP)
  static void update_handled_vectors(struct kvm_ioapic *ioapic)
  {
  	DECLARE_BITMAP(handled_vectors, 256);
* Unmerged path virt/kvm/ioapic.c
