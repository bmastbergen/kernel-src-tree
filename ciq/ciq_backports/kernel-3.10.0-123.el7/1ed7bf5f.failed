xen, pvticketlock: Allow interrupts to be enabled while blocking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [virt] pvticketlock: Allow interrupts to be enabled while blocking (Andrew Jones) [981581]
Rebuild_FUZZ: 95.93%
commit-author Jeremy Fitzhardinge <jeremy@goop.org>
commit 1ed7bf5f5227169b661c619636f754b98001ec30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/1ed7bf5f.failed

If interrupts were enabled when taking the spinlock, we can leave them
enabled while blocking to get the lock.

If we can enable interrupts while waiting for the lock to become
available, and we take an interrupt before entering the poll,
and the handler takes a spinlock which ends up going into
the slow state (invalidating the per-cpu "lock" and "want" values),
then when the interrupt handler returns the event channel will
remain pending so the poll will return immediately, causing it to
return out to the main spinlock loop.

	Signed-off-by: Jeremy Fitzhardinge <jeremy@goop.org>
Link: http://lkml.kernel.org/r/1376058122-8248-12-git-send-email-raghavendra.kt@linux.vnet.ibm.com
	Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Signed-off-by: Raghavendra K T <raghavendra.kt@linux.vnet.ibm.com>
	Acked-by: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
(cherry picked from commit 1ed7bf5f5227169b661c619636f754b98001ec30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/xen/spinlock.c
diff --cc arch/x86/xen/spinlock.c
index b41872b0db81,0438b9324a72..000000000000
--- a/arch/x86/xen/spinlock.c
+++ b/arch/x86/xen/spinlock.c
@@@ -157,8 -170,16 +170,21 @@@ static void xen_lock_spinning(struct ar
  	/* Only check lock once pending cleared */
  	barrier();
  
++<<<<<<< HEAD
 +	/* check again make sure it didn't become free while
 +	   we weren't looking  */
++=======
+ 	/*
+ 	 * Mark entry to slowpath before doing the pickup test to make
+ 	 * sure we don't deadlock with an unlocker.
+ 	 */
+ 	__ticket_enter_slowpath(lock);
+ 
+ 	/*
+ 	 * check again make sure it didn't become free while
+ 	 * we weren't looking
+ 	 */
++>>>>>>> 1ed7bf5f5227 (xen, pvticketlock: Allow interrupts to be enabled while blocking)
  	if (ACCESS_ONCE(lock->tickets.head) == want) {
  		add_stats(TAKEN_SLOW_PICKUP, 1);
  		goto out;
* Unmerged path arch/x86/xen/spinlock.c
