aio: checking for NULL instead of IS_ERR

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit 7f62656be8a8ef14c168db2d98021fb9c8cc1076
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/7f62656b.failed

alloc_anon_inode() returns an ERR_PTR(), it doesn't return NULL.

Fixes: 71ad7490c1f3 ('rework aio migrate pages to use aio fs')
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 7f62656be8a8ef14c168db2d98021fb9c8cc1076)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/aio.c
diff --cc fs/aio.c
index 1b3cd6476d3b,823efcbb6ccd..000000000000
--- a/fs/aio.c
+++ b/fs/aio.c
@@@ -123,6 -152,52 +123,55 @@@ unsigned long aio_max_nr = 0x10000; /* 
  static struct kmem_cache	*kiocb_cachep;
  static struct kmem_cache	*kioctx_cachep;
  
++<<<<<<< HEAD
++=======
+ static struct vfsmount *aio_mnt;
+ 
+ static const struct file_operations aio_ring_fops;
+ static const struct address_space_operations aio_ctx_aops;
+ 
+ static struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)
+ {
+ 	struct qstr this = QSTR_INIT("[aio]", 5);
+ 	struct file *file;
+ 	struct path path;
+ 	struct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);
+ 	if (IS_ERR(inode))
+ 		return ERR_CAST(inode);
+ 
+ 	inode->i_mapping->a_ops = &aio_ctx_aops;
+ 	inode->i_mapping->private_data = ctx;
+ 	inode->i_size = PAGE_SIZE * nr_pages;
+ 
+ 	path.dentry = d_alloc_pseudo(aio_mnt->mnt_sb, &this);
+ 	if (!path.dentry) {
+ 		iput(inode);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 	path.mnt = mntget(aio_mnt);
+ 
+ 	d_instantiate(path.dentry, inode);
+ 	file = alloc_file(&path, FMODE_READ | FMODE_WRITE, &aio_ring_fops);
+ 	if (IS_ERR(file)) {
+ 		path_put(&path);
+ 		return file;
+ 	}
+ 
+ 	file->f_flags = O_RDWR;
+ 	file->private_data = ctx;
+ 	return file;
+ }
+ 
+ static struct dentry *aio_mount(struct file_system_type *fs_type,
+ 				int flags, const char *dev_name, void *data)
+ {
+ 	static const struct dentry_operations ops = {
+ 		.d_dname	= simple_dname,
+ 	};
+ 	return mount_pseudo(fs_type, "aio:", NULL, &ops, 0xa10a10a1);
+ }
+ 
++>>>>>>> 7f62656be8a8 (aio: checking for NULL instead of IS_ERR)
  /* aio_setup
   *	Creates the slab caches used by the aio routines, panic on
   *	failure as this is done early during the boot sequence.
* Unmerged path fs/aio.c
