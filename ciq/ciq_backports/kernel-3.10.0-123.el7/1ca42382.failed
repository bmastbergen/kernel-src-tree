NFS: Add tracepoints for debugging directory changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Trond Myklebust <Trond.Myklebust@netapp.com>
commit 1ca42382afd67bf58523d36b00fb4ff487d8173b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/1ca42382.failed

Add tracepoints for mknod, mkdir, rmdir, remove (unlink) and symlink.

	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit 1ca42382afd67bf58523d36b00fb4ff487d8173b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfstrace.h
diff --cc fs/nfs/nfstrace.h
index 73c8e1edeef4,58279063b9a1..000000000000
--- a/fs/nfs/nfstrace.h
+++ b/fs/nfs/nfstrace.h
@@@ -157,6 -157,361 +157,364 @@@ DEFINE_NFS_INODE_EVENT_DONE(nfs_fsync_e
  DEFINE_NFS_INODE_EVENT(nfs_access_enter);
  DEFINE_NFS_INODE_EVENT_DONE(nfs_access_exit);
  
++<<<<<<< HEAD
++=======
+ #define show_lookup_flags(flags) \
+ 	__print_flags((unsigned long)flags, "|", \
+ 			{ LOOKUP_AUTOMOUNT, "AUTOMOUNT" }, \
+ 			{ LOOKUP_DIRECTORY, "DIRECTORY" }, \
+ 			{ LOOKUP_OPEN, "OPEN" }, \
+ 			{ LOOKUP_CREATE, "CREATE" }, \
+ 			{ LOOKUP_EXCL, "EXCL" })
+ 
+ DECLARE_EVENT_CLASS(nfs_lookup_event,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			unsigned int flags
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, flags),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(unsigned int, flags)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"flags=%u (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->flags,
+ 			show_lookup_flags(__entry->flags),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS_LOOKUP_EVENT(name) \
+ 	DEFINE_EVENT(nfs_lookup_event, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct dentry *dentry, \
+ 				unsigned int flags \
+ 			), \
+ 			TP_ARGS(dir, dentry, flags))
+ 
+ DECLARE_EVENT_CLASS(nfs_lookup_event_done,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			unsigned int flags,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, flags, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(int, error)
+ 			__field(unsigned int, flags)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->error = error;
+ 			__entry->flags = flags;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d flags=%u (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			__entry->flags,
+ 			show_lookup_flags(__entry->flags),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS_LOOKUP_EVENT_DONE(name) \
+ 	DEFINE_EVENT(nfs_lookup_event_done, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct dentry *dentry, \
+ 				unsigned int flags, \
+ 				int error \
+ 			), \
+ 			TP_ARGS(dir, dentry, flags, error))
+ 
+ DEFINE_NFS_LOOKUP_EVENT(nfs_lookup_enter);
+ DEFINE_NFS_LOOKUP_EVENT_DONE(nfs_lookup_exit);
+ DEFINE_NFS_LOOKUP_EVENT(nfs_lookup_revalidate_enter);
+ DEFINE_NFS_LOOKUP_EVENT_DONE(nfs_lookup_revalidate_exit);
+ 
+ #define show_open_flags(flags) \
+ 	__print_flags((unsigned long)flags, "|", \
+ 		{ O_CREAT, "O_CREAT" }, \
+ 		{ O_EXCL, "O_EXCL" }, \
+ 		{ O_TRUNC, "O_TRUNC" }, \
+ 		{ O_APPEND, "O_APPEND" }, \
+ 		{ O_DSYNC, "O_DSYNC" }, \
+ 		{ O_DIRECT, "O_DIRECT" }, \
+ 		{ O_DIRECTORY, "O_DIRECTORY" })
+ 
+ #define show_fmode_flags(mode) \
+ 	__print_flags(mode, "|", \
+ 		{ ((__force unsigned long)FMODE_READ), "READ" }, \
+ 		{ ((__force unsigned long)FMODE_WRITE), "WRITE" }, \
+ 		{ ((__force unsigned long)FMODE_EXEC), "EXEC" })
+ 
+ TRACE_EVENT(nfs_atomic_open_enter,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct nfs_open_context *ctx,
+ 			unsigned int flags
+ 		),
+ 
+ 		TP_ARGS(dir, ctx, flags),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(unsigned int, flags)
+ 			__field(unsigned int, fmode)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, ctx->dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__entry->fmode = (__force unsigned int)ctx->mode;
+ 			__assign_str(name, ctx->dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"flags=%u (%s) fmode=%s name=%02x:%02x:%llu/%s",
+ 			__entry->flags,
+ 			show_open_flags(__entry->flags),
+ 			show_fmode_flags(__entry->fmode),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ TRACE_EVENT(nfs_atomic_open_exit,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct nfs_open_context *ctx,
+ 			unsigned int flags,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, ctx, flags, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(int, error)
+ 			__field(unsigned int, flags)
+ 			__field(unsigned int, fmode)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, ctx->dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->error = error;
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__entry->fmode = (__force unsigned int)ctx->mode;
+ 			__assign_str(name, ctx->dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d flags=%u (%s) fmode=%s "
+ 			"name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			__entry->flags,
+ 			show_open_flags(__entry->flags),
+ 			show_fmode_flags(__entry->fmode),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ TRACE_EVENT(nfs_create_enter,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			unsigned int flags
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, flags),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(unsigned int, flags)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"flags=%u (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->flags,
+ 			show_open_flags(__entry->flags),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ TRACE_EVENT(nfs_create_exit,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			unsigned int flags,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, flags, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(int, error)
+ 			__field(unsigned int, flags)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->error = error;
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->flags = flags;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d flags=%u (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			__entry->flags,
+ 			show_open_flags(__entry->flags),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ DECLARE_EVENT_CLASS(nfs_directory_event,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry
+ 		),
+ 
+ 		TP_ARGS(dir, dentry),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"name=%02x:%02x:%llu/%s",
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS_DIRECTORY_EVENT(name) \
+ 	DEFINE_EVENT(nfs_directory_event, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct dentry *dentry \
+ 			), \
+ 			TP_ARGS(dir, dentry))
+ 
+ DECLARE_EVENT_CLASS(nfs_directory_event_done,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct dentry *dentry,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, dentry, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(int, error)
+ 			__field(dev_t, dev)
+ 			__field(u64, dir)
+ 			__string(name, dentry->d_name.name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->error = error;
+ 			__assign_str(name, dentry->d_name.name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS_DIRECTORY_EVENT_DONE(name) \
+ 	DEFINE_EVENT(nfs_directory_event_done, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct dentry *dentry, \
+ 				int error \
+ 			), \
+ 			TP_ARGS(dir, dentry, error))
+ 
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_mknod_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_mknod_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_mkdir_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_mkdir_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_rmdir_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_rmdir_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_remove_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_remove_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_unlink_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_unlink_exit);
+ DEFINE_NFS_DIRECTORY_EVENT(nfs_symlink_enter);
+ DEFINE_NFS_DIRECTORY_EVENT_DONE(nfs_symlink_exit);
+ 
++>>>>>>> 1ca42382afd6 (NFS: Add tracepoints for debugging directory changes)
  #endif /* _TRACE_NFS_H */
  
  #undef TRACE_INCLUDE_PATH
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 5b465aec0f11..5c266f93b2d5 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -1602,7 +1602,9 @@ nfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)
 	attr.ia_mode = mode;
 	attr.ia_valid = ATTR_MODE;
 
+	trace_nfs_mknod_enter(dir, dentry);
 	status = NFS_PROTO(dir)->mknod(dir, dentry, &attr, rdev);
+	trace_nfs_mknod_exit(dir, dentry, status);
 	if (status != 0)
 		goto out_err;
 	return 0;
@@ -1626,7 +1628,9 @@ int nfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 	attr.ia_valid = ATTR_MODE;
 	attr.ia_mode = mode | S_IFDIR;
 
+	trace_nfs_mkdir_enter(dir, dentry);
 	error = NFS_PROTO(dir)->mkdir(dir, dentry, &attr);
+	trace_nfs_mkdir_exit(dir, dentry, error);
 	if (error != 0)
 		goto out_err;
 	return 0;
@@ -1649,12 +1653,14 @@ int nfs_rmdir(struct inode *dir, struct dentry *dentry)
 	dfprintk(VFS, "NFS: rmdir(%s/%ld), %s\n",
 			dir->i_sb->s_id, dir->i_ino, dentry->d_name.name);
 
+	trace_nfs_rmdir_enter(dir, dentry);
 	error = NFS_PROTO(dir)->rmdir(dir, &dentry->d_name);
 	/* Ensure the VFS deletes this inode */
 	if (error == 0 && dentry->d_inode != NULL)
 		clear_nlink(dentry->d_inode);
 	else if (error == -ENOENT)
 		nfs_dentry_handle_enoent(dentry);
+	trace_nfs_rmdir_exit(dir, dentry, error);
 
 	return error;
 }
@@ -1682,6 +1688,7 @@ static int nfs_safe_remove(struct dentry *dentry)
 		goto out;
 	}
 
+	trace_nfs_remove_enter(dir, dentry);
 	if (inode != NULL) {
 		NFS_PROTO(inode)->return_delegation(inode);
 		error = NFS_PROTO(dir)->remove(dir, &dentry->d_name);
@@ -1691,6 +1698,7 @@ static int nfs_safe_remove(struct dentry *dentry)
 		error = NFS_PROTO(dir)->remove(dir, &dentry->d_name);
 	if (error == -ENOENT)
 		nfs_dentry_handle_enoent(dentry);
+	trace_nfs_remove_exit(dir, dentry, error);
 out:
 	return error;
 }
@@ -1708,13 +1716,14 @@ int nfs_unlink(struct inode *dir, struct dentry *dentry)
 	dfprintk(VFS, "NFS: unlink(%s/%ld, %s)\n", dir->i_sb->s_id,
 		dir->i_ino, dentry->d_name.name);
 
+	trace_nfs_unlink_enter(dir, dentry);
 	spin_lock(&dentry->d_lock);
 	if (dentry->d_count > 1) {
 		spin_unlock(&dentry->d_lock);
 		/* Start asynchronous writeout of the inode */
 		write_inode_now(dentry->d_inode, 0);
 		error = nfs_sillyrename(dir, dentry);
-		return error;
+		goto out;
 	}
 	if (!d_unhashed(dentry)) {
 		__d_drop(dentry);
@@ -1726,6 +1735,8 @@ int nfs_unlink(struct inode *dir, struct dentry *dentry)
 		nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
 	} else if (need_rehash)
 		d_rehash(dentry);
+out:
+	trace_nfs_unlink_exit(dir, dentry, error);
 	return error;
 }
 EXPORT_SYMBOL_GPL(nfs_unlink);
@@ -1773,7 +1784,9 @@ int nfs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
 		memset(kaddr + pathlen, 0, PAGE_SIZE - pathlen);
 	kunmap_atomic(kaddr);
 
+	trace_nfs_symlink_enter(dir, dentry);
 	error = NFS_PROTO(dir)->symlink(dir, dentry, page, pathlen, &attr);
+	trace_nfs_symlink_exit(dir, dentry, error);
 	if (error != 0) {
 		dfprintk(VFS, "NFS: symlink(%s/%ld, %s, %s) error %d\n",
 			dir->i_sb->s_id, dir->i_ino,
* Unmerged path fs/nfs/nfstrace.h
