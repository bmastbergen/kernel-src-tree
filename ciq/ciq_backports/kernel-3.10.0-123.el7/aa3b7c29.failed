s390/pci: prevent inadvertently triggered bus scans

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [s390] pci: prevent inadvertently triggered bus scans (Hendrik Brueckner) [1059247]
Rebuild_FUZZ: 94.85%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit aa3b7c296732b4351dfdbfe70be6b38a0882be14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/aa3b7c29.failed

Initialization and scanning of the pci bus is omitted on older
machines without pci support or if pci=off was specified. Remember
the fact that we ran without pci support and prevent further bus
scans during resume from hibernate or after receiving hotplug
notifications.

	Reported-by: Stefan Haberland <stefan.haberland@de.ibm.com>
	Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit aa3b7c296732b4351dfdbfe70be6b38a0882be14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pci.h
#	arch/s390/pci/pci.c
#	arch/s390/pci/pci_event.c
diff --cc arch/s390/include/asm/pci.h
index 0345813206c1,2583466f576b..000000000000
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@@ -161,6 -143,8 +161,11 @@@ void zpci_msihash_exit(void)
  /* Error handling and recovery */
  void zpci_event_error(void *);
  void zpci_event_availability(void *);
++<<<<<<< HEAD
++=======
+ void zpci_rescan(void);
+ bool zpci_is_enabled(void);
++>>>>>>> aa3b7c296732 (s390/pci: prevent inadvertently triggered bus scans)
  #else /* CONFIG_PCI */
  static inline void zpci_event_error(void *e) {}
  static inline void zpci_event_availability(void *e) {}
diff --cc arch/s390/pci/pci.c
index f2309f4d83d8,e3265b50f3ae..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -1007,24 -919,8 +1007,29 @@@ static void zpci_mem_exit(void
  	kmem_cache_destroy(zdev_fmb_cache);
  }
  
++<<<<<<< HEAD
 +void zpci_register_hp_ops(struct pci_hp_callback_ops *ops)
 +{
 +	mutex_lock(&zpci_list_lock);
 +	hotplug_ops = ops;
 +	mutex_unlock(&zpci_list_lock);
 +}
 +EXPORT_SYMBOL_GPL(zpci_register_hp_ops);
 +
 +void zpci_deregister_hp_ops(void)
 +{
 +	mutex_lock(&zpci_list_lock);
 +	hotplug_ops = NULL;
 +	mutex_unlock(&zpci_list_lock);
 +}
 +EXPORT_SYMBOL_GPL(zpci_deregister_hp_ops);
 +
 +unsigned int s390_pci_probe;
 +EXPORT_SYMBOL_GPL(s390_pci_probe);
++=======
+ static unsigned int s390_pci_probe;
+ static unsigned int s390_pci_initialized;
++>>>>>>> aa3b7c296732 (s390/pci: prevent inadvertently triggered bus scans)
  
  char * __init pcibios_setup(char *str)
  {
@@@ -1082,6 -978,13 +1093,16 @@@ out_hash
  	zpci_mem_exit();
  out_mem:
  	zpci_debug_exit();
 -out:
  	return rc;
  }
++<<<<<<< HEAD
 +subsys_initcall(pci_base_init);
++=======
+ subsys_initcall_sync(pci_base_init);
+ 
+ void zpci_rescan(void)
+ {
+ 	if (zpci_is_enabled())
+ 		clp_rescan_pci_devices_simple();
+ }
++>>>>>>> aa3b7c296732 (s390/pci: prevent inadvertently triggered bus scans)
diff --cc arch/s390/pci/pci_event.c
index bbbed1e7538f,228787a3630a..000000000000
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@@ -42,34 -43,8 +42,37 @@@ struct zpci_ccdf_avail 
  	u16 pec;			/* PCI event code */
  } __packed;
  
++<<<<<<< HEAD
 +static void zpci_event_log_avail(struct zpci_ccdf_avail *ccdf)
 +{
 +	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
 +	struct pci_dev *pdev = zdev ? zdev->pdev : NULL;
 +
 +	pr_info("%s: Event 0x%x reconfigured PCI function 0x%x\n",
 +		pdev ? pci_name(pdev) : "n/a", ccdf->pec, ccdf->fid);
 +	zpci_err("avail CCDF:\n");
 +	zpci_err_hex(ccdf, sizeof(*ccdf));
 +
 +	switch (ccdf->pec) {
 +	case 0x0301:
 +		zpci_enable_device(zdev);
 +		break;
 +	case 0x0302:
 +		clp_add_pci_device(ccdf->fid, ccdf->fh, 0);
 +		break;
 +	case 0x0306:
 +		clp_find_pci_devices();
 +		break;
 +	default:
 +		break;
 +	}
 +}
 +
 +void zpci_event_error(void *data)
++=======
+ static void __zpci_event_error(struct zpci_ccdf_err *ccdf)
++>>>>>>> aa3b7c296732 (s390/pci: prevent inadvertently triggered bus scans)
  {
- 	struct zpci_ccdf_err *ccdf = data;
  	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
  
  	zpci_err("error CCDF:\n");
@@@ -82,7 -57,71 +85,75 @@@
  	       pci_name(zdev->pdev), ccdf->pec, ccdf->fid);
  }
  
- void zpci_event_availability(void *data)
+ void zpci_event_error(void *data)
+ {
+ 	if (zpci_is_enabled())
+ 		__zpci_event_error(data);
+ }
+ 
+ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
  {
++<<<<<<< HEAD
 +	zpci_event_log_avail(data);
++=======
+ 	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
+ 	struct pci_dev *pdev = zdev ? zdev->pdev : NULL;
+ 	int ret;
+ 
+ 	pr_info("%s: Event 0x%x reconfigured PCI function 0x%x\n",
+ 		pdev ? pci_name(pdev) : "n/a", ccdf->pec, ccdf->fid);
+ 	zpci_err("avail CCDF:\n");
+ 	zpci_err_hex(ccdf, sizeof(*ccdf));
+ 
+ 	switch (ccdf->pec) {
+ 	case 0x0301: /* Standby -> Configured */
+ 		if (!zdev || zdev->state == ZPCI_FN_STATE_CONFIGURED)
+ 			break;
+ 		zdev->state = ZPCI_FN_STATE_CONFIGURED;
+ 		ret = zpci_enable_device(zdev);
+ 		if (ret)
+ 			break;
+ 		pci_rescan_bus(zdev->bus);
+ 		break;
+ 	case 0x0302: /* Reserved -> Standby */
+ 		clp_add_pci_device(ccdf->fid, ccdf->fh, 0);
+ 		break;
+ 	case 0x0303: /* Deconfiguration requested */
+ 		if (pdev)
+ 			pci_stop_and_remove_bus_device(pdev);
+ 
+ 		ret = zpci_disable_device(zdev);
+ 		if (ret)
+ 			break;
+ 
+ 		ret = sclp_pci_deconfigure(zdev->fid);
+ 		zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, ret);
+ 		if (!ret)
+ 			zdev->state = ZPCI_FN_STATE_STANDBY;
+ 
+ 		break;
+ 	case 0x0304: /* Configured -> Standby */
+ 		if (pdev)
+ 			pci_stop_and_remove_bus_device(pdev);
+ 
+ 		zpci_disable_device(zdev);
+ 		zdev->state = ZPCI_FN_STATE_STANDBY;
+ 		break;
+ 	case 0x0306: /* 0x308 or 0x302 for multiple devices */
+ 		clp_rescan_pci_devices();
+ 		break;
+ 	case 0x0308: /* Standby -> Reserved */
+ 		pci_stop_root_bus(zdev->bus);
+ 		pci_remove_root_bus(zdev->bus);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> aa3b7c296732 (s390/pci: prevent inadvertently triggered bus scans)
+ }
+ 
+ void zpci_event_availability(void *data)
+ {
+ 	if (zpci_is_enabled())
+ 		__zpci_event_availability(data);
  }
* Unmerged path arch/s390/include/asm/pci.h
* Unmerged path arch/s390/pci/pci.c
* Unmerged path arch/s390/pci/pci_event.c
