s390/compat,signal: change return values to -EFAULT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [s390] compat, signal: change return values to -EFAULT (Hendrik Brueckner) [1029602]
Rebuild_FUZZ: 93.88%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit f8544ec4f49ffb9cb93419e41f0d8c0fb39eb78f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/f8544ec4.failed

Instead of returnin the number of bytes not copied and/or -EFAULT let the
signal handler helper functions always return -EFAULT if a user space
access failed.
This doesn't fix a bug in the current code, but makes is harder to get it
wrong in the future.
Also "smatch" won't complain anymore about the fact that the number of
remaining bytes gets returned instead of -EFAULT.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit f8544ec4f49ffb9cb93419e41f0d8c0fb39eb78f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/signal.c
diff --cc arch/s390/kernel/signal.c
index c45becf82e01,5c0ce019a8ae..000000000000
--- a/arch/s390/kernel/signal.c
+++ b/arch/s390/kernel/signal.c
@@@ -82,10 -82,9 +82,16 @@@ static int restore_sigregs(struct pt_re
  	/* Alwys make any pending restarted system call return -EINTR */
  	current_thread_info()->restart_block.fn = do_no_restart_syscall;
  
++<<<<<<< HEAD
 +	err = __copy_from_user(&user_sregs, sregs, sizeof(_sigregs));
 +	if (err)
 +		return err;
 +	/* Use regs->psw.mask instead of psw_user_bits to preserve PER bit. */
++=======
+ 	if (__copy_from_user(&user_sregs, sregs, sizeof(_sigregs)))
+ 		return -EFAULT;
+ 	/* Use regs->psw.mask instead of PSW_USER_BITS to preserve PER bit. */
++>>>>>>> f8544ec4f49f (s390/compat,signal: change return values to -EFAULT)
  	regs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |
  		(user_sregs.regs.psw.mask & PSW_MASK_USER);
  	/* Check for invalid user address space control. */
diff --git a/arch/s390/kernel/compat_signal.c b/arch/s390/kernel/compat_signal.c
index c439ac9ced09..1b635e106b65 100644
--- a/arch/s390/kernel/compat_signal.c
+++ b/arch/s390/kernel/compat_signal.c
@@ -166,11 +166,14 @@ static int save_sigregs32(struct pt_regs *regs, _sigregs32 __user *sregs)
 	memcpy(regs32.acrs, current->thread.acrs, sizeof(regs32.acrs));
 	err = __copy_to_user(&sregs->regs, &regs32, sizeof(regs32));
 	if (err)
-		return err;
+		return -EFAULT;
 	save_fp_regs(&current->thread.fp_regs);
 	/* s390_fp_regs and _s390_fp_regs32 are the same ! */
-	return __copy_to_user(&sregs->fpregs, &current->thread.fp_regs,
-			      sizeof(_s390_fp_regs32));
+	err = __copy_to_user(&sregs->fpregs, &current->thread.fp_regs,
+			     sizeof(_s390_fp_regs32));
+	if (err)
+		return -EFAULT;
+	return 0;
 }
 
 static int restore_sigregs32(struct pt_regs *regs,_sigregs32 __user *sregs)
@@ -183,7 +186,7 @@ static int restore_sigregs32(struct pt_regs *regs,_sigregs32 __user *sregs)
 
 	err = __copy_from_user(&regs32, &sregs->regs, sizeof(regs32));
 	if (err)
-		return err;
+		return -EFAULT;
 	regs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |
 		(__u64)(regs32.psw.mask & PSW32_MASK_USER) << 32 |
 		(__u64)(regs32.psw.addr & PSW32_ADDR_AMODE);
@@ -201,7 +204,7 @@ static int restore_sigregs32(struct pt_regs *regs,_sigregs32 __user *sregs)
 			       sizeof(_s390_fp_regs32));
 	current->thread.fp_regs.fpc &= FPC_VALID_MASK;
 	if (err)
-		return err;
+		return -EFAULT;
 
 	restore_fp_regs(&current->thread.fp_regs);
 	clear_thread_flag(TIF_SYSCALL);	/* No longer in a system call */
@@ -215,18 +218,18 @@ static int save_sigregs_gprs_high(struct pt_regs *regs, __u32 __user *uregs)
 
 	for (i = 0; i < NUM_GPRS; i++)
 		gprs_high[i] = regs->gprs[i] >> 32;
-
-	return __copy_to_user(uregs, &gprs_high, sizeof(gprs_high));
+	if (__copy_to_user(uregs, &gprs_high, sizeof(gprs_high)))
+		return -EFAULT;
+	return 0;
 }
 
 static int restore_sigregs_gprs_high(struct pt_regs *regs, __u32 __user *uregs)
 {
 	__u32 gprs_high[NUM_GPRS];
-	int err, i;
+	int i;
 
-	err = __copy_from_user(&gprs_high, uregs, sizeof(gprs_high));
-	if (err)
-		return err;
+	if (__copy_from_user(&gprs_high, uregs, sizeof(gprs_high)))
+		return -EFAULT;
 	for (i = 0; i < NUM_GPRS; i++)
 		*(__u32 *)&regs->gprs[i] = gprs_high[i];
 	return 0;
* Unmerged path arch/s390/kernel/signal.c
