PCI/ACPI: Skip _OSC control tests if _OSC support call failed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [acpi] Skip _OSC control tests if _OSC support call failed (Myron Stowe) [1033834]
Rebuild_FUZZ: 91.07%
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit 65afe91622c456560e20d57a779b807c20822e81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/65afe916.failed

If the _OSC support notification fails, we will never request control
(because "support == OSC_PCI_SEGMENT_GROUPS_SUPPORT", which doesn't include
all the features in ACPI_PCIE_REQ_SUPPORT), so we can return early to
simplify the code.

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 65afe91622c456560e20d57a779b807c20822e81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/pci_root.c
diff --cc drivers/acpi/pci_root.c
index ed36e22817d8,67cc43a134ad..000000000000
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@@ -360,6 -360,86 +360,89 @@@ out
  }
  EXPORT_SYMBOL(acpi_pci_osc_control_set);
  
++<<<<<<< HEAD
++=======
+ static void negotiate_os_control(struct acpi_pci_root *root, int *no_aspm,
+ 				 int *clear_aspm)
+ {
+ 	u32 support, control;
+ 	acpi_status status;
+ 	struct acpi_device *device = root->device;
+ 	acpi_handle handle = device->handle;
+ 
+ 	/*
+ 	 * All supported architectures that use ACPI have support for
+ 	 * PCI domains, so we indicate this in _OSC support capabilities.
+ 	 */
+ 	support = OSC_PCI_SEGMENT_GROUPS_SUPPORT;
+ 	if (pci_ext_cfg_avail())
+ 		support |= OSC_PCI_EXT_CONFIG_SUPPORT;
+ 	if (pcie_aspm_support_enabled())
+ 		support |= OSC_PCI_ASPM_SUPPORT | OSC_PCI_CLOCK_PM_SUPPORT;
+ 	if (pci_msi_enabled())
+ 		support |= OSC_PCI_MSI_SUPPORT;
+ 	status = acpi_pci_osc_support(root, support);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_info(&device->dev, "_OSC failed (%s); disabling ASPM\n",
+ 			 acpi_format_exception(status));
+ 		*no_aspm = 1;
+ 		return;
+ 	}
+ 
+ 	if (!pcie_ports_disabled
+ 	    && (support & ACPI_PCIE_REQ_SUPPORT) == ACPI_PCIE_REQ_SUPPORT) {
+ 		control = OSC_PCI_EXPRESS_CAPABILITY_CONTROL
+ 			| OSC_PCI_EXPRESS_NATIVE_HP_CONTROL
+ 			| OSC_PCI_EXPRESS_PME_CONTROL;
+ 
+ 		if (pci_aer_available()) {
+ 			if (aer_acpi_firmware_first())
+ 				dev_dbg(&device->dev,
+ 					"PCIe errors handled by BIOS.\n");
+ 			else
+ 				control |= OSC_PCI_EXPRESS_AER_CONTROL;
+ 		}
+ 
+ 		dev_info(&device->dev,
+ 			"Requesting ACPI _OSC control (0x%02x)\n", control);
+ 
+ 		status = acpi_pci_osc_control_set(handle, &control,
+ 				       OSC_PCI_EXPRESS_CAPABILITY_CONTROL);
+ 		if (ACPI_SUCCESS(status)) {
+ 			dev_info(&device->dev,
+ 				"ACPI _OSC control (0x%02x) granted\n",
+ 				control);
+ 			if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {
+ 				/*
+ 				 * We have ASPM control, but the FADT indicates
+ 				 * that it's unsupported. Clear it.
+ 				 */
+ 				*clear_aspm = 1;
+ 			}
+ 		} else {
+ 			dev_info(&device->dev,
+ 				"ACPI _OSC request failed (%s), "
+ 				"returned control mask: 0x%02x\n",
+ 				acpi_format_exception(status), control);
+ 			dev_info(&device->dev,
+ 				 "ACPI _OSC control for PCIe not granted, disabling ASPM\n");
+ 			/*
+ 			 * We want to disable ASPM here, but aspm_disabled
+ 			 * needs to remain in its state from boot so that we
+ 			 * properly handle PCIe 1.1 devices.  So we set this
+ 			 * flag here, to defer the action until after the ACPI
+ 			 * root scan.
+ 			 */
+ 			*no_aspm = 1;
+ 		}
+ 	} else {
+ 		dev_info(&device->dev,
+ 			 "Unable to request _OSC control "
+ 			 "(_OSC support mask: 0x%02x)\n", support);
+ 	}
+ }
+ 
++>>>>>>> 65afe91622c4 (PCI/ACPI: Skip _OSC control tests if _OSC support call failed)
  static int acpi_pci_root_add(struct acpi_device *device,
  			     const struct acpi_device_id *not_used)
  {
* Unmerged path drivers/acpi/pci_root.c
