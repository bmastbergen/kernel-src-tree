xfs: push down inactive transaction mgmt for remote symlinks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 36b21dde6e899d2f25077b7c239d2d6bcff17d73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/36b21dde.failed

Push down the transaction management for remote symlinks from
xfs_inactive() down to xfs_inactive_symlink_rmt(). The latter is
cleaned up to avoid transaction management intended for the
calling context (i.e., trans duplication, reservation, item
attachment).

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 36b21dde6e899d2f25077b7c239d2d6bcff17d73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_symlink.c
diff --cc fs/xfs/xfs_inode.c
index da3cfa9c9058,c26990b50941..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -771,6 -1574,272 +771,275 @@@ out_bmap_cancel
  	goto out;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ xfs_release(
+ 	xfs_inode_t	*ip)
+ {
+ 	xfs_mount_t	*mp = ip->i_mount;
+ 	int		error;
+ 
+ 	if (!S_ISREG(ip->i_d.di_mode) || (ip->i_d.di_mode == 0))
+ 		return 0;
+ 
+ 	/* If this is a read-only mount, don't do this (would generate I/O) */
+ 	if (mp->m_flags & XFS_MOUNT_RDONLY)
+ 		return 0;
+ 
+ 	if (!XFS_FORCED_SHUTDOWN(mp)) {
+ 		int truncated;
+ 
+ 		/*
+ 		 * If we are using filestreams, and we have an unlinked
+ 		 * file that we are processing the last close on, then nothing
+ 		 * will be able to reopen and write to this file. Purge this
+ 		 * inode from the filestreams cache so that it doesn't delay
+ 		 * teardown of the inode.
+ 		 */
+ 		if ((ip->i_d.di_nlink == 0) && xfs_inode_is_filestream(ip))
+ 			xfs_filestream_deassociate(ip);
+ 
+ 		/*
+ 		 * If we previously truncated this file and removed old data
+ 		 * in the process, we want to initiate "early" writeout on
+ 		 * the last close.  This is an attempt to combat the notorious
+ 		 * NULL files problem which is particularly noticeable from a
+ 		 * truncate down, buffered (re-)write (delalloc), followed by
+ 		 * a crash.  What we are effectively doing here is
+ 		 * significantly reducing the time window where we'd otherwise
+ 		 * be exposed to that problem.
+ 		 */
+ 		truncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);
+ 		if (truncated) {
+ 			xfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);
+ 			if (VN_DIRTY(VFS_I(ip)) && ip->i_delayed_blks > 0) {
+ 				error = -filemap_flush(VFS_I(ip)->i_mapping);
+ 				if (error)
+ 					return error;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (ip->i_d.di_nlink == 0)
+ 		return 0;
+ 
+ 	if (xfs_can_free_eofblocks(ip, false)) {
+ 
+ 		/*
+ 		 * If we can't get the iolock just skip truncating the blocks
+ 		 * past EOF because we could deadlock with the mmap_sem
+ 		 * otherwise.  We'll get another chance to drop them once the
+ 		 * last reference to the inode is dropped, so we'll never leak
+ 		 * blocks permanently.
+ 		 *
+ 		 * Further, check if the inode is being opened, written and
+ 		 * closed frequently and we have delayed allocation blocks
+ 		 * outstanding (e.g. streaming writes from the NFS server),
+ 		 * truncating the blocks past EOF will cause fragmentation to
+ 		 * occur.
+ 		 *
+ 		 * In this case don't do the truncation, either, but we have to
+ 		 * be careful how we detect this case. Blocks beyond EOF show
+ 		 * up as i_delayed_blks even when the inode is clean, so we
+ 		 * need to truncate them away first before checking for a dirty
+ 		 * release. Hence on the first dirty close we will still remove
+ 		 * the speculative allocation, but after that we will leave it
+ 		 * in place.
+ 		 */
+ 		if (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))
+ 			return 0;
+ 
+ 		error = xfs_free_eofblocks(mp, ip, true);
+ 		if (error && error != EAGAIN)
+ 			return error;
+ 
+ 		/* delalloc blocks after truncation means it really is dirty */
+ 		if (ip->i_delayed_blks)
+ 			xfs_iflags_set(ip, XFS_IDIRTY_RELEASE);
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * xfs_inactive
+  *
+  * This is called when the vnode reference count for the vnode
+  * goes to zero.  If the file has been unlinked, then it must
+  * now be truncated.  Also, we clear all of the read-ahead state
+  * kept for the inode here since the file is now closed.
+  */
+ int
+ xfs_inactive(
+ 	xfs_inode_t	*ip)
+ {
+ 	xfs_bmap_free_t		free_list;
+ 	xfs_fsblock_t		first_block;
+ 	int			committed;
+ 	struct xfs_trans	*tp;
+ 	struct xfs_mount	*mp;
+ 	struct xfs_trans_res	*resp;
+ 	int			error;
+ 	int			truncate = 0;
+ 
+ 	/*
+ 	 * If the inode is already free, then there can be nothing
+ 	 * to clean up here.
+ 	 */
+ 	if (ip->i_d.di_mode == 0) {
+ 		ASSERT(ip->i_df.if_real_bytes == 0);
+ 		ASSERT(ip->i_df.if_broot_bytes == 0);
+ 		return VN_INACTIVE_CACHE;
+ 	}
+ 
+ 	mp = ip->i_mount;
+ 
+ 	error = 0;
+ 
+ 	/* If this is a read-only mount, don't do this (would generate I/O) */
+ 	if (mp->m_flags & XFS_MOUNT_RDONLY)
+ 		goto out;
+ 
+ 	if (ip->i_d.di_nlink != 0) {
+ 		/*
+ 		 * force is true because we are evicting an inode from the
+ 		 * cache. Post-eof blocks must be freed, lest we end up with
+ 		 * broken free space accounting.
+ 		 */
+ 		if (xfs_can_free_eofblocks(ip, true)) {
+ 			error = xfs_free_eofblocks(mp, ip, false);
+ 			if (error)
+ 				return VN_INACTIVE_CACHE;
+ 		}
+ 		goto out;
+ 	}
+ 
+ 	if (S_ISREG(ip->i_d.di_mode) &&
+ 	    (ip->i_d.di_size != 0 || XFS_ISIZE(ip) != 0 ||
+ 	     ip->i_d.di_nextents > 0 || ip->i_delayed_blks > 0))
+ 		truncate = 1;
+ 
+ 	error = xfs_qm_dqattach(ip, 0);
+ 	if (error)
+ 		return VN_INACTIVE_CACHE;
+ 
+ 	if (S_ISLNK(ip->i_d.di_mode)) {
+ 		error = xfs_inactive_symlink(ip);
+ 		if (error)
+ 			goto out;
+ 	}
+ 
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);
+ 	resp = truncate ? &M_RES(mp)->tr_itruncate : &M_RES(mp)->tr_ifree;
+ 
+ 	error = xfs_trans_reserve(tp, resp, 0, 0);
+ 	if (error) {
+ 		ASSERT(XFS_FORCED_SHUTDOWN(mp));
+ 		xfs_trans_cancel(tp, 0);
+ 		return VN_INACTIVE_CACHE;
+ 	}
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, 0);
+ 
+ 	if (truncate) {
+ 		ip->i_d.di_size = 0;
+ 		xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
+ 
+ 		error = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);
+ 		if (error)
+ 			goto out_cancel;
+ 
+ 		ASSERT(ip->i_d.di_nextents == 0);
+ 	}
+ 
+ 	/*
+ 	 * If there are attributes associated with the file then blow them away
+ 	 * now.  The code calls a routine that recursively deconstructs the
+ 	 * attribute fork.  We need to just commit the current transaction
+ 	 * because we can't use it for xfs_attr_inactive().
+ 	 */
+ 	if (ip->i_d.di_anextents > 0) {
+ 		ASSERT(ip->i_d.di_forkoff != 0);
+ 
+ 		error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 		if (error)
+ 			goto out_unlock;
+ 
+ 		xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ 
+ 		error = xfs_attr_inactive(ip);
+ 		if (error)
+ 			goto out;
+ 
+ 		tp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);
+ 		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ifree, 0, 0);
+ 		if (error) {
+ 			xfs_trans_cancel(tp, 0);
+ 			goto out;
+ 		}
+ 
+ 		xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 		xfs_trans_ijoin(tp, ip, 0);
+ 	}
+ 
+ 	if (ip->i_afp)
+ 		xfs_idestroy_fork(ip, XFS_ATTR_FORK);
+ 
+ 	ASSERT(ip->i_d.di_anextents == 0);
+ 
+ 	/*
+ 	 * Free the inode.
+ 	 */
+ 	xfs_bmap_init(&free_list, &first_block);
+ 	error = xfs_ifree(tp, ip, &free_list);
+ 	if (error) {
+ 		/*
+ 		 * If we fail to free the inode, shut down.  The cancel
+ 		 * might do that, we need to make sure.  Otherwise the
+ 		 * inode might be lost for a long time or forever.
+ 		 */
+ 		if (!XFS_FORCED_SHUTDOWN(mp)) {
+ 			xfs_notice(mp, "%s: xfs_ifree returned error %d",
+ 				__func__, error);
+ 			xfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);
+ 		}
+ 		xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);
+ 	} else {
+ 		/*
+ 		 * Credit the quota account(s). The inode is gone.
+ 		 */
+ 		xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);
+ 
+ 		/*
+ 		 * Just ignore errors at this point.  There is nothing we can
+ 		 * do except to try to keep going. Make sure it's not a silent
+ 		 * error.
+ 		 */
+ 		error = xfs_bmap_finish(&tp,  &free_list, &committed);
+ 		if (error)
+ 			xfs_notice(mp, "%s: xfs_bmap_finish returned error %d",
+ 				__func__, error);
+ 		error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 		if (error)
+ 			xfs_notice(mp, "%s: xfs_trans_commit returned error %d",
+ 				__func__, error);
+ 	}
+ 
+ 	/*
+ 	 * Release the dquots held by inode, if any.
+ 	 */
+ 	xfs_qm_dqdetach(ip);
+ out_unlock:
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ out:
+ 	return VN_INACTIVE_CACHE;
+ out_cancel:
+ 	xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);
+ 	goto out_unlock;
+ }
+ 
++>>>>>>> 36b21dde6e89 (xfs: push down inactive transaction mgmt for remote symlinks)
  /*
   * This is called when the inode's link count goes to 0.
   * We place the on-disk inode on a list in the AGI.  It
diff --cc fs/xfs/xfs_symlink.c
index ce735e73f20d,ded282b10bc2..000000000000
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@@ -537,23 -534,16 +533,28 @@@ xfs_inactive_symlink_rmt
  	if (ip->i_df.if_bytes)
  		xfs_idata_realloc(ip, -ip->i_df.if_bytes, XFS_DATA_FORK);
  	ASSERT(ip->i_df.if_bytes == 0);
++<<<<<<< HEAD
 +	/*
 +	 * Put an itruncate log reservation in the new transaction
 +	 * for our caller.
 +	 */
 +	if ((error = xfs_trans_reserve(tp, 0, XFS_ITRUNCATE_LOG_RES(mp), 0,
 +			XFS_TRANS_PERM_LOG_RES, XFS_ITRUNCATE_LOG_COUNT))) {
 +		ASSERT(XFS_FORCED_SHUTDOWN(mp));
 +		goto error0;
 +	}
++=======
++>>>>>>> 36b21dde6e89 (xfs: push down inactive transaction mgmt for remote symlinks)
  
- 	xfs_trans_ijoin(tp, ip, 0);
- 	*tpp = tp;
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
  	return 0;
  
-  error1:
+ error_bmap_cancel:
  	xfs_bmap_cancel(&free_list);
-  error0:
+ error_trans_cancel:
+ 	xfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);
+ error_unlock:
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
  	return error;
  }
  
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_symlink.c
diff --git a/fs/xfs/xfs_symlink.h b/fs/xfs/xfs_symlink.h
index 99338ba666ac..e75245d09116 100644
--- a/fs/xfs/xfs_symlink.h
+++ b/fs/xfs/xfs_symlink.h
@@ -22,6 +22,6 @@
 int xfs_symlink(struct xfs_inode *dp, struct xfs_name *link_name,
 		const char *target_path, umode_t mode, struct xfs_inode **ipp);
 int xfs_readlink(struct xfs_inode *ip, char *link);
-int xfs_inactive_symlink(struct xfs_inode *ip, struct xfs_trans **tpp);
+int xfs_inactive_symlink(struct xfs_inode *ip);
 
 #endif /* __XFS_SYMLINK_H */
