IB/mlx4: Build the port IBoE GID table properly under bonding

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [infiniband] mlx4: Build the port IBoE GID table properly under bonding (Doug Ledford) [1061729]
Rebuild_FUZZ: 97.48%
commit-author Moni Shoua <monis@mellanox.co.il>
commit ad4885d279b63c65347220236d07669a2f59634b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/ad4885d2.failed

When scanning netdevices we need to check a few more conditions and
cases to build the IBoE GID table properly.  For example, under
bonding we must make sure that when a port is down, the bond IP
address isn't programmed as a GID, since doing so will cause failure
with IB core flows that selects ports by GID.

	Signed-off-by: Moni Shoua <monis@mellanox.co.il>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit ad4885d279b63c65347220236d07669a2f59634b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx4/main.c
diff --cc drivers/infiniband/hw/mlx4/main.c
index 3163ef43b43e,fdb5c7c9e127..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -1407,125 -1435,331 +1407,210 @@@ static void update_gids_task(struct wor
  	kfree(gw);
  }
  
 -static int update_gid_table(struct mlx4_ib_dev *dev, int port,
 -			    union ib_gid *gid, int clear,
 -			    int default_gid)
 +static int update_ipv6_gids(struct mlx4_ib_dev *dev, int port, int clear)
  {
 +	struct net_device *ndev = dev->iboe.netdevs[port - 1];
  	struct update_gid_work *work;
 +	struct net_device *tmp;
  	int i;
 +	u8 *hits;
 +	int ret;
 +	union ib_gid gid;
 +	int free;
 +	int found;
  	int need_update = 0;
 -	int free = -1;
 -	int found = -1;
 -	int max_gids;
 +	u16 vid;
  
 -	if (default_gid) {
 -		free = 0;
 -	} else {
 -		max_gids = dev->dev->caps.gid_table_len[port];
 -		for (i = 1; i < max_gids; ++i) {
 -			if (!memcmp(&dev->iboe.gid_table[port - 1][i], gid,
 -				    sizeof(*gid)))
 -				found = i;
 -
 -			if (clear) {
 -				if (found >= 0) {
 -					need_update = 1;
 -					dev->iboe.gid_table[port - 1][found] =
 -						zgid;
 -					break;
 -				}
 -			} else {
 -				if (found >= 0)
 -					break;
 +	work = kzalloc(sizeof *work, GFP_ATOMIC);
 +	if (!work)
 +		return -ENOMEM;
  
 +	hits = kzalloc(128, GFP_ATOMIC);
 +	if (!hits) {
 +		ret = -ENOMEM;
 +		goto out;
 +	}
 +
 +	rcu_read_lock();
 +	for_each_netdev_rcu(&init_net, tmp) {
 +		if (ndev && (tmp == ndev || rdma_vlan_dev_real_dev(tmp) == ndev)) {
 +			gid.global.subnet_prefix = cpu_to_be64(0xfe80000000000000LL);
 +			vid = rdma_vlan_dev_vlan_id(tmp);
 +			mlx4_addrconf_ifid_eui48(&gid.raw[8], vid, ndev);
 +			found = 0;
 +			free = -1;
 +			for (i = 0; i < 128; ++i) {
  				if (free < 0 &&
 -				    !memcmp(&dev->iboe.gid_table[port - 1][i],
 -					    &zgid, sizeof(*gid)))
 +				    !memcmp(&dev->iboe.gid_table[port - 1][i], &zgid, sizeof zgid))
  					free = i;
 +				if (!memcmp(&dev->iboe.gid_table[port - 1][i], &gid, sizeof gid)) {
 +					hits[i] = 1;
 +					found = 1;
 +					break;
 +				}
  			}
 -		}
 -	}
  
 -	if (found == -1 && !clear && free >= 0) {
 -		dev->iboe.gid_table[port - 1][free] = *gid;
 -		need_update = 1;
 +			if (!found) {
 +				if (tmp == ndev &&
 +				    (memcmp(&dev->iboe.gid_table[port - 1][0],
 +					    &gid, sizeof gid) ||
 +				     !memcmp(&dev->iboe.gid_table[port - 1][0],
 +					     &zgid, sizeof gid))) {
 +					dev->iboe.gid_table[port - 1][0] = gid;
 +					++need_update;
 +					hits[0] = 1;
 +				} else if (free >= 0) {
 +					dev->iboe.gid_table[port - 1][free] = gid;
 +					hits[free] = 1;
 +					++need_update;
 +				}
 +			}
 +		}
  	}
 +	rcu_read_unlock();
  
 -	if (!need_update)
 -		return 0;
 -
 -	work = kzalloc(sizeof(*work), GFP_ATOMIC);
 -	if (!work)
 -		return -ENOMEM;
 +	for (i = 0; i < 128; ++i)
 +		if (!hits[i]) {
 +			if (memcmp(&dev->iboe.gid_table[port - 1][i], &zgid, sizeof zgid))
 +				++need_update;
 +			dev->iboe.gid_table[port - 1][i] = zgid;
 +		}
  
 -	memcpy(work->gids, dev->iboe.gid_table[port - 1], sizeof(work->gids));
 -	INIT_WORK(&work->work, update_gids_task);
 -	work->port = port;
 -	work->dev = dev;
 -	queue_work(wq, &work->work);
 +	if (need_update) {
 +		memcpy(work->gids, dev->iboe.gid_table[port - 1], sizeof work->gids);
 +		INIT_WORK(&work->work, update_gids_task);
 +		work->port = port;
 +		work->dev = dev;
 +		queue_work(wq, &work->work);
 +	} else
 +		kfree(work);
  
 +	kfree(hits);
  	return 0;
 +
 +out:
 +	kfree(work);
 +	return ret;
  }
  
 -static void mlx4_make_default_gid(struct  net_device *dev, union ib_gid *gid)
 +static void handle_en_event(struct mlx4_ib_dev *dev, int port, unsigned long event)
  {
 -	gid->global.subnet_prefix = cpu_to_be64(0xfe80000000000000LL);
 -	mlx4_addrconf_ifid_eui48(&gid->raw[8], 0xffff, dev);
 +	switch (event) {
 +	case NETDEV_UP:
 +	case NETDEV_CHANGEADDR:
 +		update_ipv6_gids(dev, port, 0);
 +		break;
 +
 +	case NETDEV_DOWN:
 +		update_ipv6_gids(dev, port, 1);
 +		dev->iboe.netdevs[port - 1] = NULL;
 +	}
  }
  
 +static void netdev_added(struct mlx4_ib_dev *dev, int port)
 +{
 +	update_ipv6_gids(dev, port, 0);
 +}
  
 -static int reset_gid_table(struct mlx4_ib_dev *dev, u8 port)
 +static void netdev_removed(struct mlx4_ib_dev *dev, int port)
  {
++<<<<<<< HEAD
 +	update_ipv6_gids(dev, port, 1);
++=======
+ 	struct update_gid_work *work;
+ 
+ 	work = kzalloc(sizeof(*work), GFP_ATOMIC);
+ 	if (!work)
+ 		return -ENOMEM;
+ 
+ 	memset(dev->iboe.gid_table[port - 1], 0, sizeof(work->gids));
+ 	memset(work->gids, 0, sizeof(work->gids));
+ 	INIT_WORK(&work->work, reset_gids_task);
+ 	work->dev = dev;
+ 	work->port = port;
+ 	queue_work(wq, &work->work);
+ 	return 0;
++>>>>>>> ad4885d279b6 (IB/mlx4: Build the port IBoE GID table properly under bonding)
  }
  
 -static int mlx4_ib_addr_event(int event, struct net_device *event_netdev,
 -			      struct mlx4_ib_dev *ibdev, union ib_gid *gid)
 -{
 -	struct mlx4_ib_iboe *iboe;
 -	int port = 0;
 -	struct net_device *real_dev = rdma_vlan_dev_real_dev(event_netdev) ?
 -				rdma_vlan_dev_real_dev(event_netdev) :
 -				event_netdev;
 -	union ib_gid default_gid;
 -
 -	mlx4_make_default_gid(real_dev, &default_gid);
 -
 -	if (!memcmp(gid, &default_gid, sizeof(*gid)))
 -		return 0;
 -
 -	if (event != NETDEV_DOWN && event != NETDEV_UP)
 -		return 0;
 -
 -	if ((real_dev != event_netdev) &&
 -	    (event == NETDEV_DOWN) &&
 -	    rdma_link_local_addr((struct in6_addr *)gid))
 -		return 0;
 -
 -	iboe = &ibdev->iboe;
 -	spin_lock(&iboe->lock);
 -
 -	for (port = 1; port <= MLX4_MAX_PORTS; ++port)
 -		if ((netif_is_bond_master(real_dev) &&
 -		     (real_dev == iboe->masters[port - 1])) ||
 -		     (!netif_is_bond_master(real_dev) &&
 -		     (real_dev == iboe->netdevs[port - 1])))
 -			update_gid_table(ibdev, port, gid,
 -					 event == NETDEV_DOWN, 0);
 -
 -	spin_unlock(&iboe->lock);
 -	return 0;
 -
 -}
 -
 -static u8 mlx4_ib_get_dev_port(struct net_device *dev,
 -			       struct mlx4_ib_dev *ibdev)
 -{
 -	u8 port = 0;
 -	struct mlx4_ib_iboe *iboe;
 -	struct net_device *real_dev = rdma_vlan_dev_real_dev(dev) ?
 -				rdma_vlan_dev_real_dev(dev) : dev;
 -
 -	iboe = &ibdev->iboe;
 -
 -	for (port = 1; port <= MLX4_MAX_PORTS; ++port)
 -		if ((netif_is_bond_master(real_dev) &&
 -		     (real_dev == iboe->masters[port - 1])) ||
 -		     (!netif_is_bond_master(real_dev) &&
 -		     (real_dev == iboe->netdevs[port - 1])))
 -			break;
 -
 -	if ((port == 0) || (port > MLX4_MAX_PORTS))
 -		return 0;
 -	else
 -		return port;
 -}
 -
 -static int mlx4_ib_inet_event(struct notifier_block *this, unsigned long event,
 -				void *ptr)
 -{
 -	struct mlx4_ib_dev *ibdev;
 -	struct in_ifaddr *ifa = ptr;
 -	union ib_gid gid;
 -	struct net_device *event_netdev = ifa->ifa_dev->dev;
 -
 -	ipv6_addr_set_v4mapped(ifa->ifa_address, (struct in6_addr *)&gid);
 -
 -	ibdev = container_of(this, struct mlx4_ib_dev, iboe.nb_inet);
 -
 -	mlx4_ib_addr_event(event, event_netdev, ibdev, &gid);
 -	return NOTIFY_DONE;
 -}
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -static int mlx4_ib_inet6_event(struct notifier_block *this, unsigned long event,
 +static int mlx4_ib_netdev_event(struct notifier_block *this, unsigned long event,
  				void *ptr)
  {
 +	struct net_device *dev = ptr;
  	struct mlx4_ib_dev *ibdev;
 -	struct inet6_ifaddr *ifa = ptr;
 -	union  ib_gid *gid = (union ib_gid *)&ifa->addr;
 -	struct net_device *event_netdev = ifa->idev->dev;
 -
 -	ibdev = container_of(this, struct mlx4_ib_dev, iboe.nb_inet6);
 -
 -	mlx4_ib_addr_event(event, event_netdev, ibdev, gid);
 -	return NOTIFY_DONE;
 -}
 -#endif
 -
 -static void mlx4_ib_get_dev_addr(struct net_device *dev,
 -				 struct mlx4_ib_dev *ibdev, u8 port)
 -{
 -	struct in_device *in_dev;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	struct inet6_dev *in6_dev;
 -	union ib_gid  *pgid;
 -	struct inet6_ifaddr *ifp;
 -#endif
 -	union ib_gid gid;
 -
 -
 -	if ((port == 0) || (port > MLX4_MAX_PORTS))
 -		return;
 -
 -	/* IPv4 gids */
 -	in_dev = in_dev_get(dev);
 -	if (in_dev) {
 -		for_ifa(in_dev) {
 -			/*ifa->ifa_address;*/
 -			ipv6_addr_set_v4mapped(ifa->ifa_address,
 -					       (struct in6_addr *)&gid);
 -			update_gid_table(ibdev, port, &gid, 0, 0);
 -		}
 -		endfor_ifa(in_dev);
 -		in_dev_put(in_dev);
 -	}
 -#if IS_ENABLED(CONFIG_IPV6)
 -	/* IPv6 gids */
 -	in6_dev = in6_dev_get(dev);
 -	if (in6_dev) {
 -		read_lock_bh(&in6_dev->lock);
 -		list_for_each_entry(ifp, &in6_dev->addr_list, if_list) {
 -			pgid = (union ib_gid *)&ifp->addr;
 -			update_gid_table(ibdev, port, pgid, 0, 0);
 -		}
 -		read_unlock_bh(&in6_dev->lock);
 -		in6_dev_put(in6_dev);
 -	}
 -#endif
 -}
 -
 -static void mlx4_ib_set_default_gid(struct mlx4_ib_dev *ibdev,
 -				 struct  net_device *dev, u8 port)
 -{
 -	union ib_gid gid;
 -	mlx4_make_default_gid(dev, &gid);
 -	update_gid_table(ibdev, port, &gid, 0, 1);
 -}
 -
 -static int mlx4_ib_init_gid_table(struct mlx4_ib_dev *ibdev)
 -{
 -	struct	net_device *dev;
 -	struct mlx4_ib_iboe *iboe = &ibdev->iboe;
 -	int i;
 -
 -	for (i = 1; i <= ibdev->num_ports; ++i)
 -		if (reset_gid_table(ibdev, i))
 -			return -1;
 -
 -	read_lock(&dev_base_lock);
 -	spin_lock(&iboe->lock);
 -
 -	for_each_netdev(&init_net, dev) {
 -		u8 port = mlx4_ib_get_dev_port(dev, ibdev);
 -		if (port)
 -			mlx4_ib_get_dev_addr(dev, ibdev, port);
 -	}
 -
 -	spin_unlock(&iboe->lock);
 -	read_unlock(&dev_base_lock);
 -
 -	return 0;
 -}
 -
 -static void mlx4_ib_scan_netdevs(struct mlx4_ib_dev *ibdev)
 -{
 +	struct net_device *oldnd;
  	struct mlx4_ib_iboe *iboe;
  	int port;
  
++<<<<<<< HEAD
++=======
+ 	iboe = &ibdev->iboe;
+ 
+ 	spin_lock(&iboe->lock);
+ 	mlx4_foreach_ib_transport_port(port, ibdev->dev) {
+ 		enum ib_port_state	port_state = IB_PORT_NOP;
+ 		struct net_device *old_master = iboe->masters[port - 1];
+ 		struct net_device *curr_netdev;
+ 		struct net_device *curr_master;
+ 
+ 		iboe->netdevs[port - 1] =
+ 			mlx4_get_protocol_dev(ibdev->dev, MLX4_PROT_ETH, port);
+ 		if (iboe->netdevs[port - 1])
+ 			mlx4_ib_set_default_gid(ibdev,
+ 						iboe->netdevs[port - 1], port);
+ 		curr_netdev = iboe->netdevs[port - 1];
+ 
+ 		if (iboe->netdevs[port - 1] &&
+ 		    netif_is_bond_slave(iboe->netdevs[port - 1])) {
+ 			iboe->masters[port - 1] = netdev_master_upper_dev_get(
+ 				iboe->netdevs[port - 1]);
+ 		} else {
+ 			iboe->masters[port - 1] = NULL;
+ 		}
+ 		curr_master = iboe->masters[port - 1];
+ 
+ 		if (curr_netdev) {
+ 			port_state = (netif_running(curr_netdev) && netif_carrier_ok(curr_netdev)) ?
+ 						IB_PORT_ACTIVE : IB_PORT_DOWN;
+ 			mlx4_ib_set_default_gid(ibdev, curr_netdev, port);
+ 		} else {
+ 			reset_gid_table(ibdev, port);
+ 		}
+ 		/* if using bonding/team and a slave port is down, we don't the bond IP
+ 		 * based gids in the table since flows that select port by gid may get
+ 		 * the down port.
+ 		 */
+ 		if (curr_master && (port_state == IB_PORT_DOWN)) {
+ 			reset_gid_table(ibdev, port);
+ 			mlx4_ib_set_default_gid(ibdev, curr_netdev, port);
+ 		}
+ 		/* if bonding is used it is possible that we add it to masters
+ 		 * only after IP address is assigned to the net bonding
+ 		 * interface.
+ 		*/
+ 		if (curr_master && (old_master != curr_master)) {
+ 			reset_gid_table(ibdev, port);
+ 			mlx4_ib_set_default_gid(ibdev, curr_netdev, port);
+ 			mlx4_ib_get_dev_addr(curr_master, ibdev, port);
+ 		}
+ 
+ 		if (!curr_master && (old_master != curr_master)) {
+ 			reset_gid_table(ibdev, port);
+ 			mlx4_ib_set_default_gid(ibdev, curr_netdev, port);
+ 			mlx4_ib_get_dev_addr(curr_netdev, ibdev, port);
+ 		}
+ 	}
+ 
+ 	spin_unlock(&iboe->lock);
+ }
+ 
+ static int mlx4_ib_netdev_event(struct notifier_block *this,
+ 				unsigned long event, void *ptr)
+ {
+ 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+ 	struct mlx4_ib_dev *ibdev;
+ 
++>>>>>>> ad4885d279b6 (IB/mlx4: Build the port IBoE GID table properly under bonding)
  	if (!net_eq(dev_net(dev), &init_net))
  		return NOTIFY_DONE;
  
@@@ -1886,11 -2103,39 +1971,47 @@@ static void *mlx4_ib_add(struct mlx4_de
  	if (mlx4_ib_init_sriov(ibdev))
  		goto err_mad;
  
++<<<<<<< HEAD
 +	if (dev->caps.flags & MLX4_DEV_CAP_FLAG_IBOE && !iboe->nb.notifier_call) {
 +		iboe->nb.notifier_call = mlx4_ib_netdev_event;
 +		err = register_netdevice_notifier(&iboe->nb);
 +		if (err)
 +			goto err_sriov;
++=======
+ 	if (dev->caps.flags & MLX4_DEV_CAP_FLAG_IBOE) {
+ 		if (!iboe->nb.notifier_call) {
+ 			iboe->nb.notifier_call = mlx4_ib_netdev_event;
+ 			err = register_netdevice_notifier(&iboe->nb);
+ 			if (err) {
+ 				iboe->nb.notifier_call = NULL;
+ 				goto err_notif;
+ 			}
+ 		}
+ 		if (!iboe->nb_inet.notifier_call) {
+ 			iboe->nb_inet.notifier_call = mlx4_ib_inet_event;
+ 			err = register_inetaddr_notifier(&iboe->nb_inet);
+ 			if (err) {
+ 				iboe->nb_inet.notifier_call = NULL;
+ 				goto err_notif;
+ 			}
+ 		}
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		if (!iboe->nb_inet6.notifier_call) {
+ 			iboe->nb_inet6.notifier_call = mlx4_ib_inet6_event;
+ 			err = register_inet6addr_notifier(&iboe->nb_inet6);
+ 			if (err) {
+ 				iboe->nb_inet6.notifier_call = NULL;
+ 				goto err_notif;
+ 			}
+ 		}
+ #endif
+ 		for (i = 1 ; i <= ibdev->num_ports ; ++i)
+ 			reset_gid_table(ibdev, i);
+ 		rtnl_lock();
+ 		mlx4_ib_scan_netdevs(ibdev);
+ 		rtnl_unlock();
+ 		mlx4_ib_init_gid_table(ibdev);
++>>>>>>> ad4885d279b6 (IB/mlx4: Build the port IBoE GID table properly under bonding)
  	}
  
  	for (j = 0; j < ARRAY_SIZE(mlx4_class_attributes); ++j) {
* Unmerged path drivers/infiniband/hw/mlx4/main.c
