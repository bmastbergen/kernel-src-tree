vfs: improve i_op->atomic_open() documentation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 0854d450e229e37102a76e3ccf065d8e8137846f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/0854d450.failed

Fix documentation of ->atomic_open() and related functions: finish_open()
and finish_no_open().  Also add details that seem to be unclear and a
source of bugs (some of which are fixed in the following series).

Cc-ing maintainers of all filesystems implementing ->atomic_open().

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Cc: Eric Van Hensbergen <ericvh@gmail.com>
	Cc: Sage Weil <sage@inktank.com>
	Cc: Steve French <sfrench@samba.org>
	Cc: Steven Whitehouse <swhiteho@redhat.com>
	Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 0854d450e229e37102a76e3ccf065d8e8137846f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/filesystems/vfs.txt
diff --cc Documentation/filesystems/vfs.txt
index 94087989be0b,deb48b5fd883..000000000000
--- a/Documentation/filesystems/vfs.txt
+++ b/Documentation/filesystems/vfs.txt
@@@ -359,9 -359,9 +359,15 @@@ struct inode_operations 
  	ssize_t (*listxattr) (struct dentry *, char *, size_t);
  	int (*removexattr) (struct dentry *, const char *);
  	void (*update_time)(struct inode *, struct timespec *, int);
++<<<<<<< HEAD
 +	int (*atomic_open)(struct inode *, struct dentry *,
 +				struct file *, unsigned open_flag,
 +				umode_t create_mode, int *opened);
++=======
+ 	int (*atomic_open)(struct inode *, struct dentry *, struct file *,
+ 			unsigned open_flag, umode_t create_mode, int *opened);
+ 	int (*tmpfile) (struct inode *, struct dentry *, umode_t);
++>>>>>>> 0854d450e229 (vfs: improve i_op->atomic_open() documentation)
  };
  
  Again, all methods are called without any locks being held, unless
@@@ -468,10 -468,15 +474,12 @@@ otherwise noted
    	method the filesystem can look up, possibly create and open the file in
    	one atomic operation.  If it cannot perform this (e.g. the file type
    	turned out to be wrong) it may signal this by returning 1 instead of
-   	usual 0 or -ve .  This method is only called if the last
-   	component is negative or needs lookup.  Cached positive dentries are
-   	still handled by f_op->open().
+ 	usual 0 or -ve .  This method is only called if the last component is
+ 	negative or needs lookup.  Cached positive dentries are still handled by
+ 	f_op->open().  If the file was created, the FILE_CREATED flag should be
+ 	set in "opened".  In case of O_EXCL the method must only succeed if the
+ 	file didn't exist and hence FILE_CREATED shall always be set on success.
  
 -  tmpfile: called in the end of O_TMPFILE open().  Optional, equivalent to
 -	atomically creating, opening and unlinking a file in given directory.
 -
  The Address Space Object
  ========================
  
* Unmerged path Documentation/filesystems/vfs.txt
diff --git a/fs/open.c b/fs/open.c
index 8c741002f947..fe8936b7e403 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -745,14 +745,24 @@ cleanup_file:
 
 /**
  * finish_open - finish opening a file
- * @od: opaque open data
+ * @file: file pointer
  * @dentry: pointer to dentry
  * @open: open callback
+ * @opened: state of open
  *
  * This can be used to finish opening a file passed to i_op->atomic_open().
  *
  * If the open callback is set to NULL, then the standard f_op->open()
  * filesystem callback is substituted.
+ *
+ * NB: the dentry reference is _not_ consumed.  If, for example, the dentry is
+ * the return value of d_splice_alias(), then the caller needs to perform dput()
+ * on it after finish_open().
+ *
+ * On successful return @file is a fully instantiated open file.  After this, if
+ * an error occurs in ->atomic_open(), it needs to clean up with fput().
+ *
+ * Returns zero on success or -errno if the open failed.
  */
 int finish_open(struct file *file, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *),
@@ -773,11 +783,16 @@ EXPORT_SYMBOL(finish_open);
 /**
  * finish_no_open - finish ->atomic_open() without opening the file
  *
- * @od: opaque open data
+ * @file: file pointer
  * @dentry: dentry or NULL (as returned from ->lookup())
  *
  * This can be used to set the result of a successful lookup in ->atomic_open().
- * The filesystem's atomic_open() method shall return NULL after calling this.
+ *
+ * NB: unlike finish_open() this function does consume the dentry reference and
+ * the caller need not dput() it.
+ *
+ * Returns "1" which must be the return value of ->atomic_open() after having
+ * called this function.
  */
 int finish_no_open(struct file *file, struct dentry *dentry)
 {
