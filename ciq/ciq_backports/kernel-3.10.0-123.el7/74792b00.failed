KEYS: Fix a race between negating a key and reading the error set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author David Howells <dhowells@redhat.com>
commit 74792b0001ee85b845dc82c1a716c6052c2db9de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/74792b00.failed

key_reject_and_link() marking a key as negative and setting the error with
which it was negated races with keyring searches and other things that read
that error.

The fix is to switch the order in which the assignments are done in
key_reject_and_link() and to use memory barriers.

Kudos to Dave Wysochanski <dwysocha@redhat.com> and Scott Mayhew
<smayhew@redhat.com> for tracking this down.

This may be the cause of:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000070
IP: [<ffffffff81219011>] wait_for_key_construction+0x31/0x80
PGD c6b2c3067 PUD c59879067 PMD 0
Oops: 0000 [#1] SMP
last sysfs file: /sys/devices/system/cpu/cpu3/cache/index2/shared_cpu_map
CPU 0
Modules linked in: ...

Pid: 13359, comm: amqzxma0 Not tainted 2.6.32-358.20.1.el6.x86_64 #1 IBM System x3650 M3 -[7945PSJ]-/00J6159
RIP: 0010:[<ffffffff81219011>] wait_for_key_construction+0x31/0x80
RSP: 0018:ffff880c6ab33758  EFLAGS: 00010246
RAX: ffffffff81219080 RBX: 0000000000000000 RCX: 0000000000000002
RDX: ffffffff81219060 RSI: 0000000000000000 RDI: 0000000000000000
RBP: ffff880c6ab33768 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000000 R12: ffff880adfcbce40
R13: ffffffffa03afb84 R14: ffff880adfcbce40 R15: ffff880adfcbce43
FS:  00007f29b8042700(0000) GS:ffff880028200000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000070 CR3: 0000000c613dc000 CR4: 00000000000007f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
Process amqzxma0 (pid: 13359, threadinfo ffff880c6ab32000, task ffff880c610deae0)
Stack:
 ffff880adfcbce40 0000000000000000 ffff880c6ab337b8 ffffffff81219695
<d> 0000000000000000 ffff880a000000d0 ffff880c6ab337a8 000000000000000f
<d> ffffffffa03afb93 000000000000000f ffff88186c7882c0 0000000000000014
Call Trace:
 [<ffffffff81219695>] request_key+0x65/0xa0
 [<ffffffffa03a0885>] nfs_idmap_request_key+0xc5/0x170 [nfs]
 [<ffffffffa03a0eb4>] nfs_idmap_lookup_id+0x34/0x80 [nfs]
 [<ffffffffa03a1255>] nfs_map_group_to_gid+0x75/0xa0 [nfs]
 [<ffffffffa039a9ad>] decode_getfattr_attrs+0xbdd/0xfb0 [nfs]
 [<ffffffff81057310>] ? __dequeue_entity+0x30/0x50
 [<ffffffff8100988e>] ? __switch_to+0x26e/0x320
 [<ffffffffa039ae03>] decode_getfattr+0x83/0xe0 [nfs]
 [<ffffffffa039b610>] ? nfs4_xdr_dec_getattr+0x0/0xa0 [nfs]
 [<ffffffffa039b69f>] nfs4_xdr_dec_getattr+0x8f/0xa0 [nfs]
 [<ffffffffa02dada4>] rpcauth_unwrap_resp+0x84/0xb0 [sunrpc]
 [<ffffffffa039b610>] ? nfs4_xdr_dec_getattr+0x0/0xa0 [nfs]
 [<ffffffffa02cf923>] call_decode+0x1b3/0x800 [sunrpc]
 [<ffffffff81096de0>] ? wake_bit_function+0x0/0x50
 [<ffffffffa02cf770>] ? call_decode+0x0/0x800 [sunrpc]
 [<ffffffffa02d99a7>] __rpc_execute+0x77/0x350 [sunrpc]
 [<ffffffff81096c67>] ? bit_waitqueue+0x17/0xd0
 [<ffffffffa02d9ce1>] rpc_execute+0x61/0xa0 [sunrpc]
 [<ffffffffa02d03a5>] rpc_run_task+0x75/0x90 [sunrpc]
 [<ffffffffa02d04c2>] rpc_call_sync+0x42/0x70 [sunrpc]
 [<ffffffffa038ff80>] _nfs4_call_sync+0x30/0x40 [nfs]
 [<ffffffffa038836c>] _nfs4_proc_getattr+0xac/0xc0 [nfs]
 [<ffffffff810aac87>] ? futex_wait+0x227/0x380
 [<ffffffffa038b856>] nfs4_proc_getattr+0x56/0x80 [nfs]
 [<ffffffffa0371403>] __nfs_revalidate_inode+0xe3/0x220 [nfs]
 [<ffffffffa037158e>] nfs_revalidate_mapping+0x4e/0x170 [nfs]
 [<ffffffffa036f147>] nfs_file_read+0x77/0x130 [nfs]
 [<ffffffff811811aa>] do_sync_read+0xfa/0x140
 [<ffffffff81096da0>] ? autoremove_wake_function+0x0/0x40
 [<ffffffff8100bb8e>] ? apic_timer_interrupt+0xe/0x20
 [<ffffffff8100b9ce>] ? common_interrupt+0xe/0x13
 [<ffffffff81228ffb>] ? selinux_file_permission+0xfb/0x150
 [<ffffffff8121bed6>] ? security_file_permission+0x16/0x20
 [<ffffffff81181a95>] vfs_read+0xb5/0x1a0
 [<ffffffff81181bd1>] sys_read+0x51/0x90
 [<ffffffff810dc685>] ? __audit_syscall_exit+0x265/0x290
 [<ffffffff8100b072>] system_call_fastpath+0x16/0x1b

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Dave Wysochanski <dwysocha@redhat.com>
cc: Scott Mayhew <smayhew@redhat.com>
(cherry picked from commit 74792b0001ee85b845dc82c1a716c6052c2db9de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/keys/keyring.c
diff --cc security/keys/keyring.c
index eeef1a073db4,8c05ebd7203d..000000000000
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@@ -277,6 -500,301 +277,304 @@@ struct key *keyring_alloc(const char *d
  }
  EXPORT_SYMBOL(keyring_alloc);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Iteration function to consider each key found.
+  */
+ static int keyring_search_iterator(const void *object, void *iterator_data)
+ {
+ 	struct keyring_search_context *ctx = iterator_data;
+ 	const struct key *key = keyring_ptr_to_key(object);
+ 	unsigned long kflags = key->flags;
+ 
+ 	kenter("{%d}", key->serial);
+ 
+ 	/* ignore keys not of this type */
+ 	if (key->type != ctx->index_key.type) {
+ 		kleave(" = 0 [!type]");
+ 		return 0;
+ 	}
+ 
+ 	/* skip invalidated, revoked and expired keys */
+ 	if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {
+ 		if (kflags & ((1 << KEY_FLAG_INVALIDATED) |
+ 			      (1 << KEY_FLAG_REVOKED))) {
+ 			ctx->result = ERR_PTR(-EKEYREVOKED);
+ 			kleave(" = %d [invrev]", ctx->skipped_ret);
+ 			goto skipped;
+ 		}
+ 
+ 		if (key->expiry && ctx->now.tv_sec >= key->expiry) {
+ 			ctx->result = ERR_PTR(-EKEYEXPIRED);
+ 			kleave(" = %d [expire]", ctx->skipped_ret);
+ 			goto skipped;
+ 		}
+ 	}
+ 
+ 	/* keys that don't match */
+ 	if (!ctx->match(key, ctx->match_data)) {
+ 		kleave(" = 0 [!match]");
+ 		return 0;
+ 	}
+ 
+ 	/* key must have search permissions */
+ 	if (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&
+ 	    key_task_permission(make_key_ref(key, ctx->possessed),
+ 				ctx->cred, KEY_SEARCH) < 0) {
+ 		ctx->result = ERR_PTR(-EACCES);
+ 		kleave(" = %d [!perm]", ctx->skipped_ret);
+ 		goto skipped;
+ 	}
+ 
+ 	if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {
+ 		/* we set a different error code if we pass a negative key */
+ 		if (kflags & (1 << KEY_FLAG_NEGATIVE)) {
+ 			smp_rmb();
+ 			ctx->result = ERR_PTR(key->type_data.reject_error);
+ 			kleave(" = %d [neg]", ctx->skipped_ret);
+ 			goto skipped;
+ 		}
+ 	}
+ 
+ 	/* Found */
+ 	ctx->result = make_key_ref(key, ctx->possessed);
+ 	kleave(" = 1 [found]");
+ 	return 1;
+ 
+ skipped:
+ 	return ctx->skipped_ret;
+ }
+ 
+ /*
+  * Search inside a keyring for a key.  We can search by walking to it
+  * directly based on its index-key or we can iterate over the entire
+  * tree looking for it, based on the match function.
+  */
+ static int search_keyring(struct key *keyring, struct keyring_search_context *ctx)
+ {
+ 	if ((ctx->flags & KEYRING_SEARCH_LOOKUP_TYPE) ==
+ 	    KEYRING_SEARCH_LOOKUP_DIRECT) {
+ 		const void *object;
+ 
+ 		object = assoc_array_find(&keyring->keys,
+ 					  &keyring_assoc_array_ops,
+ 					  &ctx->index_key);
+ 		return object ? ctx->iterator(object, ctx) : 0;
+ 	}
+ 	return assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);
+ }
+ 
+ /*
+  * Search a tree of keyrings that point to other keyrings up to the maximum
+  * depth.
+  */
+ static bool search_nested_keyrings(struct key *keyring,
+ 				   struct keyring_search_context *ctx)
+ {
+ 	struct {
+ 		struct key *keyring;
+ 		struct assoc_array_node *node;
+ 		int slot;
+ 	} stack[KEYRING_SEARCH_MAX_DEPTH];
+ 
+ 	struct assoc_array_shortcut *shortcut;
+ 	struct assoc_array_node *node;
+ 	struct assoc_array_ptr *ptr;
+ 	struct key *key;
+ 	int sp = 0, slot;
+ 
+ 	kenter("{%d},{%s,%s}",
+ 	       keyring->serial,
+ 	       ctx->index_key.type->name,
+ 	       ctx->index_key.description);
+ 
+ 	if (ctx->index_key.description)
+ 		ctx->index_key.desc_len = strlen(ctx->index_key.description);
+ 
+ 	/* Check to see if this top-level keyring is what we are looking for
+ 	 * and whether it is valid or not.
+ 	 */
+ 	if (ctx->flags & KEYRING_SEARCH_LOOKUP_ITERATE ||
+ 	    keyring_compare_object(keyring, &ctx->index_key)) {
+ 		ctx->skipped_ret = 2;
+ 		ctx->flags |= KEYRING_SEARCH_DO_STATE_CHECK;
+ 		switch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {
+ 		case 1:
+ 			goto found;
+ 		case 2:
+ 			return false;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	ctx->skipped_ret = 0;
+ 	if (ctx->flags & KEYRING_SEARCH_NO_STATE_CHECK)
+ 		ctx->flags &= ~KEYRING_SEARCH_DO_STATE_CHECK;
+ 
+ 	/* Start processing a new keyring */
+ descend_to_keyring:
+ 	kdebug("descend to %d", keyring->serial);
+ 	if (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |
+ 			      (1 << KEY_FLAG_REVOKED)))
+ 		goto not_this_keyring;
+ 
+ 	/* Search through the keys in this keyring before its searching its
+ 	 * subtrees.
+ 	 */
+ 	if (search_keyring(keyring, ctx))
+ 		goto found;
+ 
+ 	/* Then manually iterate through the keyrings nested in this one.
+ 	 *
+ 	 * Start from the root node of the index tree.  Because of the way the
+ 	 * hash function has been set up, keyrings cluster on the leftmost
+ 	 * branch of the root node (root slot 0) or in the root node itself.
+ 	 * Non-keyrings avoid the leftmost branch of the root entirely (root
+ 	 * slots 1-15).
+ 	 */
+ 	ptr = ACCESS_ONCE(keyring->keys.root);
+ 	if (!ptr)
+ 		goto not_this_keyring;
+ 
+ 	if (assoc_array_ptr_is_shortcut(ptr)) {
+ 		/* If the root is a shortcut, either the keyring only contains
+ 		 * keyring pointers (everything clusters behind root slot 0) or
+ 		 * doesn't contain any keyring pointers.
+ 		 */
+ 		shortcut = assoc_array_ptr_to_shortcut(ptr);
+ 		smp_read_barrier_depends();
+ 		if ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)
+ 			goto not_this_keyring;
+ 
+ 		ptr = ACCESS_ONCE(shortcut->next_node);
+ 		node = assoc_array_ptr_to_node(ptr);
+ 		goto begin_node;
+ 	}
+ 
+ 	node = assoc_array_ptr_to_node(ptr);
+ 	smp_read_barrier_depends();
+ 
+ 	ptr = node->slots[0];
+ 	if (!assoc_array_ptr_is_meta(ptr))
+ 		goto begin_node;
+ 
+ descend_to_node:
+ 	/* Descend to a more distal node in this keyring's content tree and go
+ 	 * through that.
+ 	 */
+ 	kdebug("descend");
+ 	if (assoc_array_ptr_is_shortcut(ptr)) {
+ 		shortcut = assoc_array_ptr_to_shortcut(ptr);
+ 		smp_read_barrier_depends();
+ 		ptr = ACCESS_ONCE(shortcut->next_node);
+ 		BUG_ON(!assoc_array_ptr_is_node(ptr));
+ 		node = assoc_array_ptr_to_node(ptr);
+ 	}
+ 
+ begin_node:
+ 	kdebug("begin_node");
+ 	smp_read_barrier_depends();
+ 	slot = 0;
+ ascend_to_node:
+ 	/* Go through the slots in a node */
+ 	for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {
+ 		ptr = ACCESS_ONCE(node->slots[slot]);
+ 
+ 		if (assoc_array_ptr_is_meta(ptr) && node->back_pointer)
+ 			goto descend_to_node;
+ 
+ 		if (!keyring_ptr_is_keyring(ptr))
+ 			continue;
+ 
+ 		key = keyring_ptr_to_key(ptr);
+ 
+ 		if (sp >= KEYRING_SEARCH_MAX_DEPTH) {
+ 			if (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {
+ 				ctx->result = ERR_PTR(-ELOOP);
+ 				return false;
+ 			}
+ 			goto not_this_keyring;
+ 		}
+ 
+ 		/* Search a nested keyring */
+ 		if (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&
+ 		    key_task_permission(make_key_ref(key, ctx->possessed),
+ 					ctx->cred, KEY_SEARCH) < 0)
+ 			continue;
+ 
+ 		/* stack the current position */
+ 		stack[sp].keyring = keyring;
+ 		stack[sp].node = node;
+ 		stack[sp].slot = slot;
+ 		sp++;
+ 
+ 		/* begin again with the new keyring */
+ 		keyring = key;
+ 		goto descend_to_keyring;
+ 	}
+ 
+ 	/* We've dealt with all the slots in the current node, so now we need
+ 	 * to ascend to the parent and continue processing there.
+ 	 */
+ 	ptr = ACCESS_ONCE(node->back_pointer);
+ 	slot = node->parent_slot;
+ 
+ 	if (ptr && assoc_array_ptr_is_shortcut(ptr)) {
+ 		shortcut = assoc_array_ptr_to_shortcut(ptr);
+ 		smp_read_barrier_depends();
+ 		ptr = ACCESS_ONCE(shortcut->back_pointer);
+ 		slot = shortcut->parent_slot;
+ 	}
+ 	if (!ptr)
+ 		goto not_this_keyring;
+ 	node = assoc_array_ptr_to_node(ptr);
+ 	smp_read_barrier_depends();
+ 	slot++;
+ 
+ 	/* If we've ascended to the root (zero backpointer), we must have just
+ 	 * finished processing the leftmost branch rather than the root slots -
+ 	 * so there can't be any more keyrings for us to find.
+ 	 */
+ 	if (node->back_pointer) {
+ 		kdebug("ascend %d", slot);
+ 		goto ascend_to_node;
+ 	}
+ 
+ 	/* The keyring we're looking at was disqualified or didn't contain a
+ 	 * matching key.
+ 	 */
+ not_this_keyring:
+ 	kdebug("not_this_keyring %d", sp);
+ 	if (sp <= 0) {
+ 		kleave(" = false");
+ 		return false;
+ 	}
+ 
+ 	/* Resume the processing of a keyring higher up in the tree */
+ 	sp--;
+ 	keyring = stack[sp].keyring;
+ 	node = stack[sp].node;
+ 	slot = stack[sp].slot + 1;
+ 	kdebug("ascend to %d [%d]", keyring->serial, slot);
+ 	goto ascend_to_node;
+ 
+ 	/* We found a viable match */
+ found:
+ 	key = key_ref_to_ptr(ctx->result);
+ 	key_check(key);
+ 	if (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {
+ 		key->last_used_at = ctx->now.tv_sec;
+ 		keyring->last_used_at = ctx->now.tv_sec;
+ 		while (sp > 0)
+ 			stack[--sp].keyring->last_used_at = ctx->now.tv_sec;
+ 	}
+ 	kleave(" = true");
+ 	return true;
+ }
+ 
++>>>>>>> 74792b0001ee (KEYS: Fix a race between negating a key and reading the error set)
  /**
   * keyring_search_aux - Search a keyring tree for a key matching some criteria
   * @keyring_ref: A pointer to the keyring with possession indicator.
diff --git a/security/keys/key.c b/security/keys/key.c
index 7d716b82a61e..f79a1187b14a 100644
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@ -556,9 +556,10 @@ int key_reject_and_link(struct key *key,
 	if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
 		/* mark the key as being negatively instantiated */
 		atomic_inc(&key->user->nikeys);
+		key->type_data.reject_error = -error;
+		smp_wmb();
 		set_bit(KEY_FLAG_NEGATIVE, &key->flags);
 		set_bit(KEY_FLAG_INSTANTIATED, &key->flags);
-		key->type_data.reject_error = -error;
 		now = current_kernel_time();
 		key->expiry = now.tv_sec + timeout;
 		key_schedule_gc(key->expiry + key_gc_delay);
* Unmerged path security/keys/keyring.c
diff --git a/security/keys/request_key.c b/security/keys/request_key.c
index ab75df4745af..586d28c47c85 100644
--- a/security/keys/request_key.c
+++ b/security/keys/request_key.c
@@ -596,8 +596,10 @@ int wait_for_key_construction(struct key *key, bool intr)
 			  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);
 	if (ret < 0)
 		return ret;
-	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
+		smp_rmb();
 		return key->type_data.reject_error;
+	}
 	return key_validate(key);
 }
 EXPORT_SYMBOL(wait_for_key_construction);
