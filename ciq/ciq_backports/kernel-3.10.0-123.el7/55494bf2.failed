dm snapshot: use dm-bufio

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [md] dm-snapshot: use dm-bufio (Mike Snitzer) [1057197]
Rebuild_FUZZ: 96.00%
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 55494bf2947dccdf2d98b62374fea7365dfead84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/55494bf2.failed

Use dm-bufio for initial loading of the exceptions.
Introduce a new function dm_bufio_forget that frees the given buffer.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 55494bf2947dccdf2d98b62374fea7365dfead84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-snap-persistent.c
diff --cc drivers/md/dm-snap-persistent.c
index 2ccf2ffda715,169275050c0b..000000000000
--- a/drivers/md/dm-snap-persistent.c
+++ b/drivers/md/dm-snap-persistent.c
@@@ -505,7 -533,14 +525,18 @@@ static int read_exceptions(struct pstor
  
  	ps->current_area--;
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	skip_metadata(ps);
+ 
+ 	r = 0;
+ 
+ ret_destroy_bufio:
+ 	dm_bufio_client_destroy(client);
+ 
+ 	return r;
++>>>>>>> 55494bf2947d (dm snapshot: use dm-bufio)
  }
  
  static struct pstore *get_info(struct dm_exception_store *store)
diff --git a/drivers/md/Kconfig b/drivers/md/Kconfig
index fafbc69b351c..1dfd2dd21e56 100644
--- a/drivers/md/Kconfig
+++ b/drivers/md/Kconfig
@@ -238,6 +238,7 @@ config DM_CRYPT
 config DM_SNAPSHOT
        tristate "Snapshot target"
        depends on BLK_DEV_DM
+       select DM_BUFIO
        ---help---
          Allow volume managers to take writable snapshots of a device.
 
diff --git a/drivers/md/dm-bufio.c b/drivers/md/dm-bufio.c
index dcb867c9eb3b..5b2a2fe78303 100644
--- a/drivers/md/dm-bufio.c
+++ b/drivers/md/dm-bufio.c
@@ -1350,6 +1350,28 @@ retry:
 }
 EXPORT_SYMBOL_GPL(dm_bufio_release_move);
 
+/*
+ * Free the given buffer.
+ *
+ * This is just a hint, if the buffer is in use or dirty, this function
+ * does nothing.
+ */
+void dm_bufio_forget(struct dm_bufio_client *c, sector_t block)
+{
+	struct dm_buffer *b;
+
+	dm_bufio_lock(c);
+
+	b = __find(c, block);
+	if (b && likely(!b->hold_count) && likely(!b->state)) {
+		__unlink_buffer(b);
+		__free_buffer_wake(b);
+	}
+
+	dm_bufio_unlock(c);
+}
+EXPORT_SYMBOL(dm_bufio_forget);
+
 unsigned dm_bufio_get_block_size(struct dm_bufio_client *c)
 {
 	return c->block_size;
diff --git a/drivers/md/dm-bufio.h b/drivers/md/dm-bufio.h
index b142946a9e32..3dac37627ba4 100644
--- a/drivers/md/dm-bufio.h
+++ b/drivers/md/dm-bufio.h
@@ -108,6 +108,13 @@ int dm_bufio_issue_flush(struct dm_bufio_client *c);
  */
 void dm_bufio_release_move(struct dm_buffer *b, sector_t new_block);
 
+/*
+ * Free the given buffer.
+ * This is just a hint, if the buffer is in use or dirty, this function
+ * does nothing.
+ */
+void dm_bufio_forget(struct dm_bufio_client *c, sector_t block);
+
 unsigned dm_bufio_get_block_size(struct dm_bufio_client *c);
 sector_t dm_bufio_get_device_size(struct dm_bufio_client *c);
 sector_t dm_bufio_get_block_number(struct dm_buffer *b);
* Unmerged path drivers/md/dm-snap-persistent.c
