neigh: ipv6: respect default values set before an address is assigned to device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit bba24896f022d4d239494bebf18e713cd8aec7a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/bba24896.failed

Make the behaviour similar to ipv4. This will allow user to set sysctl
default neigh param values and these values will be respected even by
devices registered before (that ones what do not have address set yet).

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bba24896f022d4d239494bebf18e713cd8aec7a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/addrconf.h
#	net/core/neighbour.c
diff --cc include/net/addrconf.h
index c7b181cb47a6,66c4a44d8f5c..000000000000
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@@ -240,7 -248,14 +240,18 @@@ static inline struct inet6_dev *in6_dev
  	return idev;
  }
  
++<<<<<<< HEAD
 +extern void in6_dev_finish_destroy(struct inet6_dev *idev);
++=======
+ static inline struct neigh_parms *__in6_dev_nd_parms_get_rcu(const struct net_device *dev)
+ {
+ 	struct inet6_dev *idev = __in6_dev_get(dev);
+ 
+ 	return idev ? idev->nd_parms : NULL;
+ }
+ 
+ void in6_dev_finish_destroy(struct inet6_dev *idev);
++>>>>>>> bba24896f022 (neigh: ipv6: respect default values set before an address is assigned to device)
  
  static inline void in6_dev_put(struct inet6_dev *idev)
  {
diff --cc net/core/neighbour.c
index 05242ae7bdcf,ce2b77515a9e..000000000000
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@@ -38,6 -38,8 +38,11 @@@
  #include <linux/random.h>
  #include <linux/string.h>
  #include <linux/log2.h>
++<<<<<<< HEAD
++=======
+ #include <linux/inetdevice.h>
+ #include <net/addrconf.h>
++>>>>>>> bba24896f022 (neigh: ipv6: respect default values set before an address is assigned to device)
  
  #define DEBUG
  #define NEIGH_DEBUG 1
@@@ -2782,28 -2817,146 +2787,171 @@@ static int proc_unres_qlen(ctl_table *c
  	return ret;
  }
  
++<<<<<<< HEAD
 +enum {
 +	NEIGH_VAR_MCAST_PROBE,
 +	NEIGH_VAR_UCAST_PROBE,
 +	NEIGH_VAR_APP_PROBE,
 +	NEIGH_VAR_RETRANS_TIME,
 +	NEIGH_VAR_BASE_REACHABLE_TIME,
 +	NEIGH_VAR_DELAY_PROBE_TIME,
 +	NEIGH_VAR_GC_STALETIME,
 +	NEIGH_VAR_QUEUE_LEN,
 +	NEIGH_VAR_QUEUE_LEN_BYTES,
 +	NEIGH_VAR_PROXY_QLEN,
 +	NEIGH_VAR_ANYCAST_DELAY,
 +	NEIGH_VAR_PROXY_DELAY,
 +	NEIGH_VAR_LOCKTIME,
 +	NEIGH_VAR_RETRANS_TIME_MS,
 +	NEIGH_VAR_BASE_REACHABLE_TIME_MS,
 +	NEIGH_VAR_GC_INTERVAL,
 +	NEIGH_VAR_GC_THRESH1,
 +	NEIGH_VAR_GC_THRESH2,
 +	NEIGH_VAR_GC_THRESH3,
 +	NEIGH_VAR_MAX
 +};
++=======
+ static struct neigh_parms *neigh_get_dev_parms_rcu(struct net_device *dev,
+ 						   int family)
+ {
+ 	switch (family) {
+ 	case AF_INET:
+ 		return __in_dev_arp_parms_get_rcu(dev);
+ 	case AF_INET6:
+ 		return __in6_dev_nd_parms_get_rcu(dev);
+ 	}
+ 	return NULL;
+ }
+ 
+ static void neigh_copy_dflt_parms(struct net *net, struct neigh_parms *p,
+ 				  int index)
+ {
+ 	struct net_device *dev;
+ 	int family = neigh_parms_family(p);
+ 
+ 	rcu_read_lock();
+ 	for_each_netdev_rcu(net, dev) {
+ 		struct neigh_parms *dst_p =
+ 				neigh_get_dev_parms_rcu(dev, family);
+ 
+ 		if (dst_p && !test_bit(index, dst_p->data_state))
+ 			dst_p->data[index] = p->data[index];
+ 	}
+ 	rcu_read_unlock();
+ }
+ 
+ static void neigh_proc_update(struct ctl_table *ctl, int write)
+ {
+ 	struct net_device *dev = ctl->extra1;
+ 	struct neigh_parms *p = ctl->extra2;
+ 	struct net *net = p->net;
+ 	int index = (int *) ctl->data - p->data;
+ 
+ 	if (!write)
+ 		return;
+ 
+ 	set_bit(index, p->data_state);
+ 	if (!dev) /* NULL dev means this is default value */
+ 		neigh_copy_dflt_parms(net, p, index);
+ }
+ 
+ static int neigh_proc_dointvec_zero_intmax(struct ctl_table *ctl, int write,
+ 					   void __user *buffer,
+ 					   size_t *lenp, loff_t *ppos)
+ {
+ 	struct ctl_table tmp = *ctl;
+ 	int ret;
+ 
+ 	tmp.extra1 = &zero;
+ 	tmp.extra2 = &int_max;
+ 
+ 	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ 
+ int neigh_proc_dointvec(struct ctl_table *ctl, int write,
+ 			void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec);
+ 
+ int neigh_proc_dointvec_jiffies(struct ctl_table *ctl, int write,
+ 				void __user *buffer,
+ 				size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_dointvec_jiffies(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec_jiffies);
+ 
+ static int neigh_proc_dointvec_userhz_jiffies(struct ctl_table *ctl, int write,
+ 					      void __user *buffer,
+ 					      size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_dointvec_userhz_jiffies(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ 
+ int neigh_proc_dointvec_ms_jiffies(struct ctl_table *ctl, int write,
+ 				   void __user *buffer,
+ 				   size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_dointvec_ms_jiffies(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec_ms_jiffies);
+ 
+ static int neigh_proc_dointvec_unres_qlen(struct ctl_table *ctl, int write,
+ 					  void __user *buffer,
+ 					  size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_unres_qlen(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ 
+ #define NEIGH_PARMS_DATA_OFFSET(index)	\
+ 	(&((struct neigh_parms *) 0)->data[index])
+ 
+ #define NEIGH_SYSCTL_ENTRY(attr, data_attr, name, mval, proc) \
+ 	[NEIGH_VAR_ ## attr] = { \
+ 		.procname	= name, \
+ 		.data		= NEIGH_PARMS_DATA_OFFSET(NEIGH_VAR_ ## data_attr), \
+ 		.maxlen		= sizeof(int), \
+ 		.mode		= mval, \
+ 		.proc_handler	= proc, \
+ 	}
+ 
+ #define NEIGH_SYSCTL_ZERO_INTMAX_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_zero_intmax)
+ 
+ #define NEIGH_SYSCTL_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_jiffies)
+ 
+ #define NEIGH_SYSCTL_USERHZ_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_userhz_jiffies)
+ 
+ #define NEIGH_SYSCTL_MS_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_ms_jiffies)
+ 
+ #define NEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(attr, data_attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, data_attr, name, 0644, neigh_proc_dointvec_ms_jiffies)
+ 
+ #define NEIGH_SYSCTL_UNRES_QLEN_REUSED_ENTRY(attr, data_attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, data_attr, name, 0644, neigh_proc_dointvec_unres_qlen)
++>>>>>>> bba24896f022 (neigh: ipv6: respect default values set before an address is assigned to device)
  
  static struct neigh_sysctl_table {
  	struct ctl_table_header *sysctl_header;
* Unmerged path include/net/addrconf.h
* Unmerged path net/core/neighbour.c
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index fa7269638000..8dbe7be07f6a 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -857,6 +857,8 @@ ipv6_add_addr(struct inet6_dev *idev, const struct in6_addr *addr,
 		goto out;
 	}
 
+	neigh_parms_data_state_setall(idev->nd_parms);
+
 	ifa->addr = *addr;
 	if (peer_addr)
 		ifa->peer_addr = *peer_addr;
