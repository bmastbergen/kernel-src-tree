PCI: acpiphp: Convert to dynamic debug

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [pci] acpiphp: Convert to dynamic debug (Myron Stowe) [1033834]
Rebuild_FUZZ: 92.96%
commit-author Lan Tianyu <tianyu.lan@intel.com>
commit bd950799d9510cac994fad2ea020767fe878b84b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/bd950799.failed

This patch is to use pr_debug/info/warn/err to replace acpiphp debug
functions and remove module's debug param.

User interface change: before this patch, boot with the "acpiphp.debug"
kernel parameter to turn on debug.  After this patch, set
CONFIG_DYNAMIC_DEBUG=y and boot with "acpiphp.dyndebug=+p" instead.
See Documentation/dynamic-debug-howto.txt.

[bhelgaas: changelog]
	Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit bd950799d9510cac994fad2ea020767fe878b84b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp.h
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp.h
index 6fdd49c6f0b9,26100f510b10..000000000000
--- a/drivers/pci/hotplug/acpiphp.h
+++ b/drivers/pci/hotplug/acpiphp.h
@@@ -39,16 -39,7 +39,20 @@@
  #include <linux/mutex.h>
  #include <linux/pci_hotplug.h>
  
++<<<<<<< HEAD
 +#define dbg(format, arg...)					\
 +	do {							\
 +		if (acpiphp_debug)				\
 +			printk(KERN_DEBUG "%s: " format,	\
 +				MY_NAME , ## arg);		\
 +	} while (0)
 +#define err(format, arg...) printk(KERN_ERR "%s: " format, MY_NAME , ## arg)
 +#define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
 +#define warn(format, arg...) printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
 +
++=======
+ struct acpiphp_context;
++>>>>>>> bd950799d951 (PCI: acpiphp: Convert to dynamic debug)
  struct acpiphp_bridge;
  struct acpiphp_slot;
  
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 59df8575a48c,6557702a0592..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -55,28 -58,80 +57,32 @@@
  
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
 -static DEFINE_MUTEX(acpiphp_context_lock);
  
++<<<<<<< HEAD
 +#define MY_NAME "acpiphp_glue"
 +
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
++=======
+ static void handle_hotplug_event(acpi_handle handle, u32 type, void *data);
++>>>>>>> bd950799d951 (PCI: acpiphp: Convert to dynamic debug)
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
 -static void hotplug_event(acpi_handle handle, u32 type, void *data);
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
  static void free_bridge(struct kref *kref);
  
 -static void acpiphp_context_handler(acpi_handle handle, void *context)
 -{
 -	/* Intentionally empty. */
 -}
 -
 -/**
 - * acpiphp_init_context - Create hotplug context and grab a reference to it.
 - * @handle: ACPI object handle to create the context for.
 - *
 - * Call under acpiphp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_init_context(acpi_handle handle)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	struct acpiphp_context *context;
 -	acpi_status status;
 -
 -	context = kzalloc(sizeof(*context), GFP_KERNEL);
 -	if (!context)
 -		return NULL;
 +	int *count = (int *)context;
  
 -	context->handle = handle;
 -	context->refcount = 1;
 -	status = acpi_attach_data(handle, acpiphp_context_handler, context);
 -	if (ACPI_FAILURE(status)) {
 -		kfree(context);
 -		return NULL;
 -	}
 -	return context;
 -}
 -
 -/**
 - * acpiphp_get_context - Get hotplug context and grab a reference to it.
 - * @handle: ACPI object handle to get the context for.
 - *
 - * Call under acpiphp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_get_context(acpi_handle handle)
 -{
 -	struct acpiphp_context *context = NULL;
 -	acpi_status status;
 -	void *data;
 -
 -	status = acpi_get_data(handle, acpiphp_context_handler, &data);
 -	if (ACPI_SUCCESS(status)) {
 -		context = data;
 -		context->refcount++;
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
  	}
 -	return context;
 -}
 -
 -/**
 - * acpiphp_put_context - Drop a reference to ACPI hotplug context.
 - * @handle: ACPI object handle to put the context for.
 - *
 - * The context object is removed if there are no more references to it.
 - *
 - * Call under acpiphp_context_lock.
 - */
 -static void acpiphp_put_context(struct acpiphp_context *context)
 -{
 -	if (--context->refcount)
 -		return;
 -
 -	WARN_ON(context->bridge);
 -	acpi_detach_data(context->handle, acpiphp_context_handler);
 -	kfree(context);
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
@@@ -221,86 -286,75 +227,98 @@@ register_slot(acpi_handle handle, u32 l
  	device = (adr >> 16) & 0xffff;
  	function = adr & 0xffff;
  
 -	mutex_lock(&acpiphp_context_lock);
 -	context = acpiphp_init_context(handle);
 -	if (!context) {
 -		mutex_unlock(&acpiphp_context_lock);
 -		acpi_handle_err(handle, "No hotplug context\n");
 -		return AE_NOT_EXIST;
 -	}
 -	newfunc = &context->func;
 +	pdev = bridge->pci_dev;
 +	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +		return AE_OK;
 +
 +	newfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);
 +	if (!newfunc)
 +		return AE_NO_MEMORY;
 +
 +	newfunc->handle = handle;
  	newfunc->function = function;
 -	newfunc->parent = bridge;
 -	mutex_unlock(&acpiphp_context_lock);
  
 -	if (acpi_has_method(handle, "_EJ0"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	if (acpi_has_method(handle, "_DCK"))
 -		newfunc->flags |= FUNC_HAS_DCK;
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS0;
  
 -	/* search for objects that share the same slot */
 -	list_for_each_entry(slot, &bridge->slots, node)
 -		if (slot->device == device)
 -			goto slot_found;
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS3;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
 +		newfunc->flags |= FUNC_HAS_DCK;
  
 -	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 -	if (!slot) {
 -		status = AE_NO_MEMORY;
 -		goto err;
 +	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * use the count of the number of slots we've found
 +		 * for the number of the slot
 +		 */
 +		sun = bridge->nr_slots+1;
  	}
  
 -	slot->bus = bridge->pci_bus;
 -	slot->device = device;
 -	INIT_LIST_HEAD(&slot->funcs);
 -	mutex_init(&slot->crit_sect);
 +	/* search for objects that share the same slot */
 +	list_for_each_entry(slot, &bridge->slots, node)
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
  
 -	list_add_tail(&slot->node, &bridge->slots);
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
  
 -	/* Register slots for ejectable funtions only. */
 -	if (acpi_pci_check_ejectable(pbus, handle)  || is_dock_device(handle)) {
 -		unsigned long long sun;
 -		int retval;
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
  
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
  		bridge->nr_slots++;
 -		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 -		if (ACPI_FAILURE(status))
 -			sun = bridge->nr_slots;
  
++<<<<<<< HEAD
 +		dbg("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
++=======
+ 		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
+ 		    sun, pci_domain_nr(pbus), pbus->number, device);
+ 
+ 		retval = acpiphp_register_hotplug_slot(slot, sun);
++>>>>>>> bd950799d951 (PCI: acpiphp: Convert to dynamic debug)
  		if (retval) {
 -			slot->slot = NULL;
 -			bridge->nr_slots--;
  			if (retval == -EBUSY)
++<<<<<<< HEAD
 +				warn("Slot %llu already registered by another "
 +					"hotplug driver\n", slot->sun);
++=======
+ 				pr_warn("Slot %llu already registered by another "
+ 					"hotplug driver\n", sun);
++>>>>>>> bd950799d951 (PCI: acpiphp: Convert to dynamic debug)
  			else
- 				warn("acpiphp_register_hotplug_slot failed "
+ 				pr_warn("acpiphp_register_hotplug_slot failed "
  					"(err code = 0x%x)\n", retval);
 +			goto err_exit;
  		}
 -		/* Even if the slot registration fails, we can still use it. */
  	}
  
 - slot_found:
  	newfunc->slot = slot;
 +	mutex_lock(&bridge_mutex);
  	list_add_tail(&newfunc->sibling, &slot->funcs);
 +	mutex_unlock(&bridge_mutex);
  
  	if (pci_bus_read_dev_vendor_id(pbus, PCI_DEVFN(device, function),
  				       &val, 60*1000))
@@@ -313,17 -367,9 +331,21 @@@
  		 */
  		newfunc->flags &= ~FUNC_HAS_EJ0;
  		if (register_hotplug_dock_device(handle,
 -			&acpiphp_dock_ops, context,
 +			&acpiphp_dock_ops, newfunc,
  			acpiphp_dock_init, acpiphp_dock_release))
++<<<<<<< HEAD
 +			dbg("failed to register dock device\n");
 +
 +		/* we need to be notified when dock events happen
 +		 * outside of the hotplug operation, since we may
 +		 * need to do fixups before we can hotplug.
 +		 */
 +		newfunc->nb.notifier_call = post_dock_fixups;
 +		if (register_dock_notifier(&newfunc->nb))
 +			dbg("failed to register a dock notifier");
++=======
+ 			pr_debug("failed to register dock device\n");
++>>>>>>> bd950799d951 (PCI: acpiphp: Convert to dynamic debug)
  	}
  
  	/* install notify handler */
@@@ -450,40 -414,24 +472,40 @@@ static void cleanup_bridge(struct acpip
  	struct acpiphp_slot *slot;
  	struct acpiphp_func *func;
  	acpi_status status;
 +	acpi_handle handle = bridge->handle;
  
 -	list_for_each_entry(slot, &bridge->slots, node) {
 -		list_for_each_entry(func, &slot->funcs, sibling) {
 -			acpi_handle handle = func_to_handle(func);
 +	if (!pci_is_root_bus(bridge->pci_bus)) {
 +		status = acpi_remove_notify_handler(handle,
 +					    ACPI_SYSTEM_NOTIFY,
 +					    handle_hotplug_event_bridge);
 +		if (ACPI_FAILURE(status))
 +			err("failed to remove notify handler\n");
 +	}
  
 -			if (is_dock_device(handle))
 -				unregister_hotplug_dock_device(handle);
 +	if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +		status = acpi_install_notify_handler(bridge->func->handle,
 +						ACPI_SYSTEM_NOTIFY,
 +						handle_hotplug_event_func,
 +						bridge->func);
 +		if (ACPI_FAILURE(status))
 +			err("failed to install interrupt notify handler\n");
 +	}
  
 +	list_for_each_entry(slot, &bridge->slots, node) {
 +		list_for_each_entry(func, &slot->funcs, sibling) {
 +			if (is_dock_device(func->handle)) {
 +				unregister_hotplug_dock_device(func->handle);
 +				unregister_dock_notifier(&func->nb);
 +			}
  			if (!(func->flags & FUNC_HAS_DCK)) {
 -				status = acpi_remove_notify_handler(handle,
 -							ACPI_SYSTEM_NOTIFY,
 -							handle_hotplug_event);
 +				status = acpi_remove_notify_handler(func->handle,
 +						ACPI_SYSTEM_NOTIFY,
 +						handle_hotplug_event_func);
  				if (ACPI_FAILURE(status))
- 					err("failed to remove notify handler\n");
+ 					pr_err("failed to remove notify handler\n");
  			}
  		}
 -		if (slot->slot)
 -			acpiphp_unregister_hotplug_slot(slot);
 +		acpiphp_unregister_hotplug_slot(slot);
  	}
  
  	mutex_lock(&bridge_mutex);
@@@ -1005,58 -830,68 +1027,87 @@@ static void _handle_hotplug_event_bridg
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
  		/* bus re-enumerate */
++<<<<<<< HEAD
 +		dbg("%s: Bus check notify on %s\n", __func__, objname);
 +		dbg("%s: re-enumerating slots under %s\n", __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +			ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
++=======
+ 		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
+ 		pr_debug("%s: re-enumerating slots under %s\n",
+ 			 __func__, objname);
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 		} else {
+ 			struct acpiphp_slot *slot = func->slot;
+ 
+ 			mutex_lock(&slot->crit_sect);
+ 			enable_slot(slot);
+ 			mutex_unlock(&slot->crit_sect);
+ 		}
++>>>>>>> bd950799d951 (PCI: acpiphp: Convert to dynamic debug)
  		break;
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
  		/* device check */
++<<<<<<< HEAD
 +		dbg("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		break;
++=======
+ 		pr_debug("%s: Device check notify on %s\n", __func__, objname);
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 		} else {
+ 			struct acpiphp_slot *slot = func->slot;
+ 			int ret;
++>>>>>>> bd950799d951 (PCI: acpiphp: Convert to dynamic debug)
  
 -			/*
 -			 * Check if anything has changed in the slot and rescan
 -			 * from the parent if that's the case.
 -			 */
 -			mutex_lock(&slot->crit_sect);
 -			ret = acpiphp_rescan_slot(slot);
 -			mutex_unlock(&slot->crit_sect);
 -			if (ret)
 -				acpiphp_check_bridge(func->parent);
 -		}
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		dbg("%s: Device wake notify on %s\n", __func__, objname);
  		break;
  
  	case ACPI_NOTIFY_EJECT_REQUEST:
  		/* request device eject */
 -		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 -		acpiphp_disable_and_eject_slot(func->slot);
++<<<<<<< HEAD
 +		dbg("%s: Device eject notify on %s\n", __func__, objname);
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			struct acpiphp_slot *slot;
 +			slot = bridge->func->slot;
 +			if (!acpiphp_disable_slot(slot))
 +				acpiphp_eject_slot(slot);
 +		}
  		break;
 -	}
  
 -	if (bridge)
 -		put_bridge(bridge);
 -}
 +	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a frequency mismatch\n", objname);
 +		break;
  
 -static void hotplug_event_work(struct work_struct *work)
 -{
 -	struct acpiphp_context *context;
 -	struct acpi_hp_work *hp_work;
 +	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a bus mode mismatch\n", objname);
 +		break;
  
 -	hp_work = container_of(work, struct acpi_hp_work, work);
 -	context = hp_work->context;
 -	acpi_scan_lock_acquire();
 +	case ACPI_NOTIFY_POWER_FAULT:
 +		printk(KERN_ERR "Device %s has suffered a power fault\n",
 +				objname);
 +		break;
  
 -	hotplug_event(hp_work->handle, hp_work->type, context);
 +	default:
 +		warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
++=======
++		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
++		acpiphp_disable_and_eject_slot(func->slot);
++>>>>>>> bd950799d951 (PCI: acpiphp: Convert to dynamic debug)
 +		break;
 +	}
  
  	acpi_scan_lock_release();
 -	acpi_evaluate_hotplug_ost(hp_work->handle, hp_work->type,
 -				  ACPI_OST_SC_SUCCESS, NULL);
 -	kfree(hp_work); /* allocated in handle_hotplug_event() */
 -	put_bridge(context->func.parent);
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp.h
diff --git a/drivers/pci/hotplug/acpiphp_core.c b/drivers/pci/hotplug/acpiphp_core.c
index ca8127950fcd..2e97ab003321 100644
--- a/drivers/pci/hotplug/acpiphp_core.c
+++ b/drivers/pci/hotplug/acpiphp_core.c
@@ -31,6 +31,8 @@
  *
  */
 
+#define pr_fmt(fmt) "acpiphp: " fmt
+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -43,12 +45,9 @@
 #include <linux/smp.h>
 #include "acpiphp.h"
 
-#define MY_NAME	"acpiphp"
-
 /* name size which is used for entries in pcihpfs */
 #define SLOT_NAME_SIZE  21              /* {_SUN} */
 
-bool acpiphp_debug;
 bool acpiphp_disabled;
 
 /* local variables */
@@ -61,9 +60,7 @@ static struct acpiphp_attention_info *attention_info;
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
-MODULE_PARM_DESC(debug, "Debugging mode enabled or not");
 MODULE_PARM_DESC(disable, "disable acpiphp driver");
-module_param_named(debug, acpiphp_debug, bool, 0644);
 module_param_named(disable, acpiphp_disabled, bool, 0444);
 
 /* export the attention callback registration methods */
@@ -139,7 +136,7 @@ static int enable_slot(struct hotplug_slot *hotplug_slot)
 {
 	struct slot *slot = hotplug_slot->private;
 
-	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));
+	pr_debug("%s - physical_slot = %s\n", __func__, slot_name(slot));
 
 	/* enable the specified slot */
 	return acpiphp_enable_slot(slot->acpi_slot);
@@ -157,7 +154,7 @@ static int disable_slot(struct hotplug_slot *hotplug_slot)
 	struct slot *slot = hotplug_slot->private;
 	int retval;
 
-	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));
+	pr_debug("%s - physical_slot = %s\n", __func__, slot_name(slot));
 
 	/* disable the specified slot */
 	retval = acpiphp_disable_slot(slot->acpi_slot);
@@ -180,8 +177,9 @@ static int disable_slot(struct hotplug_slot *hotplug_slot)
  {
 	int retval = -ENODEV;
 
-	dbg("%s - physical_slot = %s\n", __func__, hotplug_slot_name(hotplug_slot));
- 
+	pr_debug("%s - physical_slot = %s\n", __func__,
+		hotplug_slot_name(hotplug_slot));
+
 	if (attention_info && try_module_get(attention_info->owner)) {
 		retval = attention_info->set_attn(hotplug_slot, status);
 		module_put(attention_info->owner);
@@ -203,7 +201,7 @@ static int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)
 {
 	struct slot *slot = hotplug_slot->private;
 
-	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));
+	pr_debug("%s - physical_slot = %s\n", __func__, slot_name(slot));
 
 	*value = acpiphp_get_power_status(slot->acpi_slot);
 
@@ -225,7 +223,8 @@ static int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)
 {
 	int retval = -EINVAL;
 
-	dbg("%s - physical_slot = %s\n", __func__, hotplug_slot_name(hotplug_slot));
+	pr_debug("%s - physical_slot = %s\n", __func__,
+		hotplug_slot_name(hotplug_slot));
 
 	if (attention_info && try_module_get(attention_info->owner)) {
 		retval = attention_info->get_attn(hotplug_slot, value);
@@ -248,7 +247,7 @@ static int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)
 {
 	struct slot *slot = hotplug_slot->private;
 
-	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));
+	pr_debug("%s - physical_slot = %s\n", __func__, slot_name(slot));
 
 	*value = acpiphp_get_latch_status(slot->acpi_slot);
 
@@ -268,7 +267,7 @@ static int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)
 {
 	struct slot *slot = hotplug_slot->private;
 
-	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));
+	pr_debug("%s - physical_slot = %s\n", __func__, slot_name(slot));
 
 	*value = acpiphp_get_adapter_status(slot->acpi_slot);
 
@@ -283,7 +282,7 @@ static void release_slot(struct hotplug_slot *hotplug_slot)
 {
 	struct slot *slot = hotplug_slot->private;
 
-	dbg("%s - physical_slot = %s\n", __func__, slot_name(slot));
+	pr_debug("%s - physical_slot = %s\n", __func__, slot_name(slot));
 
 	kfree(slot->hotplug_slot);
 	kfree(slot);
@@ -326,11 +325,11 @@ int acpiphp_register_hotplug_slot(struct acpiphp_slot *acpiphp_slot)
 	if (retval == -EBUSY)
 		goto error_hpslot;
 	if (retval) {
-		err("pci_hp_register failed with error %d\n", retval);
+		pr_err("pci_hp_register failed with error %d\n", retval);
 		goto error_hpslot;
  	}
 
-	info("Slot [%s] registered\n", slot_name(slot));
+	pr_info("Slot [%s] registered\n", slot_name(slot));
 
 	return 0;
 error_hpslot:
@@ -347,17 +346,17 @@ void acpiphp_unregister_hotplug_slot(struct acpiphp_slot *acpiphp_slot)
 	struct slot *slot = acpiphp_slot->slot;
 	int retval = 0;
 
-	info("Slot [%s] unregistered\n", slot_name(slot));
+	pr_info("Slot [%s] unregistered\n", slot_name(slot));
 
 	retval = pci_hp_deregister(slot->hotplug_slot);
 	if (retval)
-		err("pci_hp_deregister failed with error %d\n", retval);
+		pr_err("pci_hp_deregister failed with error %d\n", retval);
 }
 
 
 void __init acpiphp_init(void)
 {
-	info(DRIVER_DESC " version: " DRIVER_VERSION "%s\n",
+	pr_info(DRIVER_DESC " version: " DRIVER_VERSION "%s\n",
 		acpiphp_disabled ? ", disabled by user; please report a bug"
 				 : "");
 }
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
