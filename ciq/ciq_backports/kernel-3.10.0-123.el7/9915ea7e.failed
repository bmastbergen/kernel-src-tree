NFS: Add RPC callouts to start NFSv4.0 synchronous requests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 9915ea7e0a83c0a4b94d0c5e05a9bb690fce809f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/9915ea7e.failed

Refactor nfs4_call_sync_sequence() so it is used for NFSv4.0 now.
The RPC callouts will house transport blocking logic similar to
NFSv4.1 sessions.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit 9915ea7e0a83c0a4b94d0c5e05a9bb690fce809f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index dab2586d3338,2fbf4824187e..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -674,6 -741,41 +674,51 @@@ static const struct rpc_call_ops nfs41_
  	.rpc_call_done = nfs41_call_sync_done,
  };
  
+ #else
++static
++void nfs41_init_sequence(struct nfs4_sequence_args *args,
++		struct nfs4_sequence_res *res, int cache_reply)
++{
++}
++
++static void nfs4_set_sequence_privileged(struct nfs4_sequence_args *args)
++{
++}
++
+ static int nfs4_setup_sequence(const struct nfs_server *server,
+ 			       struct nfs4_sequence_args *args,
+ 			       struct nfs4_sequence_res *res,
+ 			       struct rpc_task *task)
+ {
+ 	rpc_call_start(task);
+ 	return 0;
+ }
+ 
+ static int nfs4_sequence_done(struct rpc_task *task,
+ 			       struct nfs4_sequence_res *res)
+ {
+ 	return 1;
+ }
+ #endif /* CONFIG_NFS_V4_1 */
+ 
+ static void nfs40_call_sync_prepare(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs4_call_sync_data *data = calldata;
+ 	nfs4_setup_sequence(data->seq_server,
+ 				data->seq_args, data->seq_res, task);
+ }
+ 
+ static void nfs40_call_sync_done(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs4_call_sync_data *data = calldata;
+ 	nfs4_sequence_done(task, data->seq_res);
+ }
+ 
+ static const struct rpc_call_ops nfs40_call_sync_ops = {
+ 	.rpc_call_prepare = nfs40_call_sync_prepare,
+ 	.rpc_call_done = nfs40_call_sync_done,
+ };
+ 
  static int nfs4_call_sync_sequence(struct rpc_clnt *clnt,
  				   struct nfs_server *server,
  				   struct rpc_message *msg,
@@@ -749,9 -825,8 +768,14 @@@ int nfs4_call_sync(struct rpc_clnt *cln
  		   struct nfs4_sequence_res *res,
  		   int cache_reply)
  {
++<<<<<<< HEAD
 +	nfs41_init_sequence(args, res, cache_reply);
 +	return server->nfs_client->cl_mvops->call_sync(clnt, server, msg,
 +						args, res);
++=======
+ 	nfs4_init_sequence(args, res, cache_reply);
+ 	return nfs4_call_sync_sequence(clnt, server, msg, args, res);
++>>>>>>> 9915ea7e0a83 (NFS: Add RPC callouts to start NFSv4.0 synchronous requests)
  }
  
  static void update_changeattr(struct inode *dir, struct nfs4_change_info *cinfo)
diff --git a/fs/nfs/nfs4_fs.h b/fs/nfs/nfs4_fs.h
index 0feb23815e38..bf2184e65867 100644
--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@ -49,6 +49,7 @@ struct nfs4_minor_version_ops {
 			struct nfs_fsinfo *);
 	int	(*free_lock_state)(struct nfs_server *,
 			struct nfs4_lock_state *);
+	const struct rpc_call_ops *call_sync_ops;
 	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
 	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
 	const struct nfs4_state_maintenance_ops *state_renewal_ops;
* Unmerged path fs/nfs/nfs4proc.c
