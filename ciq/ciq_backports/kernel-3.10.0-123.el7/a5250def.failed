NFSv4: use the mach cred for SECINFO w/ integrity

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [fs] nfs: use the mach cred for SECINFO w/ integrity (Jeff Layton) [1009119]
Rebuild_FUZZ: 97.92%
commit-author Weston Andros Adamson <dros@netapp.com>
commit a5250def7c4549a6a1cd8257900bef9c12ffc2fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/a5250def.failed

Commit 5ec16a8500d339b0e7a0cc76b785d18daad354d4 introduced a regression
that causes SECINFO to fail without actualy sending an RPC if:

 1) the nfs_client's rpc_client was using KRB5i/p (now tried by default)
 2) the current user doesn't have valid kerberos credentials

This situation is quite common - as of now a sec=sys mount would use
krb5i for the nfs_client's rpc_client and a user would hardly be faulted
for not having run kinit.

The solution is to use the machine cred when trying to use an integrity
protected auth flavor for SECINFO.

Older servers may not support using the machine cred or an integrity
protected auth flavor for SECINFO in every circumstance, so we fall back
to using the user's cred and the filesystem's auth flavor in this case.

We run into another problem when running against linux nfs servers -
they return NFS4ERR_WRONGSEC when using integrity auth flavor (unless the
mount is also that flavor) even though that is not a valid error for
SECINFO*.  Even though it's against spec, handle WRONGSEC errors on SECINFO
by falling back to using the user cred and the filesystem's auth flavor.

	Signed-off-by: Weston Andros Adamson <dros@netapp.com>
	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit a5250def7c4549a6a1cd8257900bef9c12ffc2fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 58769a1cc3e7,85b190643e30..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -5501,8 -5901,23 +5528,28 @@@ int nfs4_proc_secinfo(struct inode *dir
  	struct nfs4_exception exception = { };
  	int err;
  	do {
++<<<<<<< HEAD
 +		err = nfs4_handle_exception(NFS_SERVER(dir),
 +				_nfs4_proc_secinfo(dir, name, flavors),
++=======
+ 		err = -NFS4ERR_WRONGSEC;
+ 
+ 		/* try to use integrity protection with machine cred */
+ 		if (_nfs4_is_integrity_protected(NFS_SERVER(dir)->nfs_client))
+ 			err = _nfs4_proc_secinfo(dir, name, flavors, true);
+ 
+ 		/*
+ 		 * if unable to use integrity protection, or SECINFO with
+ 		 * integrity protection returns NFS4ERR_WRONGSEC (which is
+ 		 * disallowed by spec, but exists in deployed servers) use
+ 		 * the current filesystem's rpc_client and the user cred.
+ 		 */
+ 		if (err == -NFS4ERR_WRONGSEC)
+ 			err = _nfs4_proc_secinfo(dir, name, flavors, false);
+ 
+ 		trace_nfs4_secinfo(dir, name, err);
+ 		err = nfs4_handle_exception(NFS_SERVER(dir), err,
++>>>>>>> a5250def7c45 (NFSv4: use the mach cred for SECINFO w/ integrity)
  				&exception);
  	} while (exception.retry);
  	return err;
* Unmerged path fs/nfs/nfs4proc.c
