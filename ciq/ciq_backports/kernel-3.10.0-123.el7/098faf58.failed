percpu_counter: make APIs irq safe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Shaohua Li <shli@fusionio.com>
commit 098faf5805c80f951ce5e8b4a6842382ad793c38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/098faf58.failed

In my usage, sometimes the percpu APIs are called with irq locked,
sometimes not. lockdep complains there is potential deadlock. Let's
always use percpucounter lock in irq safe way. There should be no
performance penality, as all those are slow code path.

	Cc: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Shaohua Li <shli@fusionio.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 098faf5805c80f951ce5e8b4a6842382ad793c38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/percpu_counter.c
diff --cc lib/percpu_counter.c
index ba6085d9c741,7473ee3b4ee7..000000000000
--- a/lib/percpu_counter.c
+++ b/lib/percpu_counter.c
@@@ -78,10 -79,11 +79,15 @@@ void __percpu_counter_add(struct percpu
  	preempt_disable();
  	count = __this_cpu_read(*fbc->counters) + amount;
  	if (count >= batch || count <= -batch) {
- 		raw_spin_lock(&fbc->lock);
+ 		unsigned long flags;
+ 		raw_spin_lock_irqsave(&fbc->lock, flags);
  		fbc->count += count;
++<<<<<<< HEAD
++=======
+ 		raw_spin_unlock_irqrestore(&fbc->lock, flags);
++>>>>>>> 098faf5805c8 (percpu_counter: make APIs irq safe)
  		__this_cpu_write(*fbc->counters, 0);
 +		raw_spin_unlock(&fbc->lock);
  	} else {
  		__this_cpu_write(*fbc->counters, count);
  	}
* Unmerged path lib/percpu_counter.c
