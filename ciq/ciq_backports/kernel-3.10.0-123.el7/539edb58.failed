mm: properly separate the bloated ptl from the regular case

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [mm] properly separate the bloated ptl from the regular case (Rik van Riel) [1058896]
Rebuild_FUZZ: 96.49%
commit-author Peter Zijlstra <peterz@infradead.org>
commit 539edb5846c740d78a8b6c2e43a99ca4323df68f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/539edb58.failed

Use kernel/bounds.c to convert build-time spinlock_t size check into a
preprocessor symbol and apply that to properly separate the page::ptl
situation.

	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Ingo Molnar <mingo@elte.hu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 539edb5846c740d78a8b6c2e43a99ca4323df68f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bounds.c
diff --cc kernel/bounds.c
index 0c9b862292b2,578782ef6ae1..000000000000
--- a/kernel/bounds.c
+++ b/kernel/bounds.c
@@@ -10,6 -10,8 +10,11 @@@
  #include <linux/mmzone.h>
  #include <linux/kbuild.h>
  #include <linux/page_cgroup.h>
++<<<<<<< HEAD
++=======
+ #include <linux/log2.h>
+ #include <linux/spinlock.h>
++>>>>>>> 539edb5846c7 (mm: properly separate the bloated ptl from the regular case)
  
  void foo(void)
  {
@@@ -17,5 -19,9 +22,12 @@@
  	DEFINE(NR_PAGEFLAGS, __NR_PAGEFLAGS);
  	DEFINE(MAX_NR_ZONES, __MAX_NR_ZONES);
  	DEFINE(NR_PCG_FLAGS, __NR_PCG_FLAGS);
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_SMP
+ 	DEFINE(NR_CPUS_BITS, ilog2(CONFIG_NR_CPUS));
+ #endif
+ 	DEFINE(BLOATED_SPINLOCKS, sizeof(spinlock_t) > sizeof(int));
++>>>>>>> 539edb5846c7 (mm: properly separate the bloated ptl from the regular case)
  	/* End of constants */
  }
diff --git a/include/linux/mm.h b/include/linux/mm.h
index f57f68add466..b0adfa5ebe6a 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1235,27 +1235,29 @@ static inline pmd_t *pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long a
 #endif /* CONFIG_MMU && !__ARCH_HAS_4LEVEL_HACK */
 
 #if USE_SPLIT_PTE_PTLOCKS
-bool __ptlock_alloc(struct page *page);
-void __ptlock_free(struct page *page);
+#if BLOATED_SPINLOCKS
+extern bool ptlock_alloc(struct page *page);
+extern void ptlock_free(struct page *page);
+
+static inline spinlock_t *ptlock_ptr(struct page *page)
+{
+	return page->ptl;
+}
+#else /* BLOATED_SPINLOCKS */
 static inline bool ptlock_alloc(struct page *page)
 {
-	if (sizeof(spinlock_t) > sizeof(page->ptl))
-		return __ptlock_alloc(page);
 	return true;
 }
+
 static inline void ptlock_free(struct page *page)
 {
-	if (sizeof(spinlock_t) > sizeof(page->ptl))
-		__ptlock_free(page);
 }
 
 static inline spinlock_t *ptlock_ptr(struct page *page)
 {
-	if (sizeof(spinlock_t) > sizeof(page->ptl))
-		return (spinlock_t *) page->ptl;
-	else
-		return (spinlock_t *) &page->ptl;
+	return &page->ptl;
 }
+#endif /* BLOATED_SPINLOCKS */
 
 static inline spinlock_t *pte_lockptr(struct mm_struct *mm, pmd_t *pmd)
 {
@@ -1272,7 +1274,7 @@ static inline bool ptlock_init(struct page *page)
 	 * slab code uses page->slab_cache and page->first_page (for tail
 	 * pages), which share storage with page->ptl.
 	 */
-	VM_BUG_ON(page->ptl);
+	VM_BUG_ON(*(unsigned long *)&page->ptl);
 	if (!ptlock_alloc(page))
 		return false;
 	spin_lock_init(ptlock_ptr(page));
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index da76de466d9c..b671bbb93705 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -147,10 +147,11 @@ struct page {
 						 * system if PG_buddy is set.
 						 */
 #if USE_SPLIT_PTE_PTLOCKS
-		unsigned long ptl; /* It's spinlock_t if it fits to long,
-				    * otherwise it's pointer to dynamicaly
-				    * allocated spinlock_t.
-				    */
+#if BLOATED_SPINLOCKS
+		spinlock_t *ptl;
+#else
+		spinlock_t ptl;
+#endif
 #endif
 		struct kmem_cache *slab_cache;	/* SL[AU]B: Pointer to slab */
 		struct page *first_page;	/* Compound tail pages */
* Unmerged path kernel/bounds.c
diff --git a/mm/memory.c b/mm/memory.c
index c8aa666d98dc..153bcbeeb1c1 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -4287,21 +4287,20 @@ void copy_user_huge_page(struct page *dst, struct page *src,
 }
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */
 
-#if USE_SPLIT_PTE_PTLOCKS
-bool __ptlock_alloc(struct page *page)
+#if USE_SPLIT_PTE_PTLOCKS && BLOATED_SPINLOCKS
+bool ptlock_alloc(struct page *page)
 {
 	spinlock_t *ptl;
 
 	ptl = kmalloc(sizeof(spinlock_t), GFP_KERNEL);
 	if (!ptl)
 		return false;
-	page->ptl = (unsigned long)ptl;
+	page->ptl = ptl;
 	return true;
 }
 
-void __ptlock_free(struct page *page)
+void ptlock_free(struct page *page)
 {
-	if (sizeof(spinlock_t) > sizeof(page->ptl))
-		kfree((spinlock_t *)page->ptl);
+	kfree(page->ptl);
 }
 #endif
