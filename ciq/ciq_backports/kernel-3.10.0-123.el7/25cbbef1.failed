mm: numa: Trap pmd hinting faults only if we would otherwise trap PTE faults

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [mm] numa: Trap pmd hinting faults only if we would otherwise trap PTE faults (Rik van Riel) [683513]
Rebuild_FUZZ: 97.30%
commit-author Mel Gorman <mgorman@suse.de>
commit 25cbbef1924299249756bc4030fcb2436c019813
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/25cbbef1.failed

Base page PMD faulting is meant to batch handle NUMA hinting faults from
PTEs. However, even is no PTE faults would ever be handled within a
range the kernel still traps PMD hinting faults. This patch avoids the
overhead.

	Signed-off-by: Mel Gorman <mgorman@suse.de>
	Reviewed-by: Rik van Riel <riel@redhat.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1381141781-10992-37-git-send-email-mgorman@suse.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 25cbbef1924299249756bc4030fcb2436c019813)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mprotect.c
diff --cc mm/mprotect.c
index 41e02923fcd9,5aae39017d6d..000000000000
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@@ -157,8 -167,9 +159,14 @@@ static inline unsigned long change_pmd_
  		}
  		if (pmd_none_or_clear_bad(pmd))
  			continue;
++<<<<<<< HEAD
 +		pages += change_pte_range(vma, pmd, addr, next, newprot,
 +				 dirty_accountable, prot_numa, &all_same_node);
++=======
+ 		this_pages = change_pte_range(vma, pmd, addr, next, newprot,
+ 				 dirty_accountable, prot_numa, &all_same_nidpid);
+ 		pages += this_pages;
++>>>>>>> 25cbbef19242 (mm: numa: Trap pmd hinting faults only if we would otherwise trap PTE faults)
  
  		/*
  		 * If we are changing protections for NUMA hinting faults then
@@@ -166,7 -177,7 +174,11 @@@
  		 * node. This allows a regular PMD to be handled as one fault
  		 * and effectively batches the taking of the PTL
  		 */
++<<<<<<< HEAD
 +		if (prot_numa && all_same_node)
++=======
+ 		if (prot_numa && this_pages && all_same_nidpid)
++>>>>>>> 25cbbef19242 (mm: numa: Trap pmd hinting faults only if we would otherwise trap PTE faults)
  			change_pmd_protnuma(vma->vm_mm, addr, pmd);
  	} while (pmd++, addr = next, addr != end);
  
* Unmerged path mm/mprotect.c
