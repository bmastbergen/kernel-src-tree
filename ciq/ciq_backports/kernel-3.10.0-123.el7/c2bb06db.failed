net: fix build errors if ipv6 is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] fix build errors if ipv6 is disabled (Jesper Brouer) [1059721]
Rebuild_FUZZ: 93.51%
commit-author Eric Dumazet <edumazet@google.com>
commit c2bb06db59eaf92eb5ca9c6faed590597c6ceccb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/c2bb06db.failed

CONFIG_IPV6=n is still a valid choice ;)

It appears we can remove dead code.

	Reported-by: Wu Fengguang <fengguang.wu@intel.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c2bb06db59eaf92eb5ca9c6faed590597c6ceccb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ping.c
diff --cc net/ipv4/ping.c
index 0226310cdb8f,9afbdb19f4a2..000000000000
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@@ -285,8 -415,13 +285,18 @@@ static int ping_bind(struct sock *sk, s
  		 (int)sk->sk_bound_dev_if);
  
  	err = 0;
++<<<<<<< HEAD
 +	if (isk->inet_rcv_saddr)
 +		sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
++=======
+ 	if (sk->sk_family == AF_INET && isk->inet_rcv_saddr)
+ 		sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))
+ 		sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
+ #endif
+ 
++>>>>>>> c2bb06db59ea (net: fix build errors if ipv6 is disabled)
  	if (snum)
  		sk->sk_userlocks |= SOCK_BINDPORT_LOCK;
  	isk->inet_sport = htons(isk->inet_num);
diff --git a/include/net/ip6_checksum.h b/include/net/ip6_checksum.h
index 7686e3f5033d..cb6e2a911478 100644
--- a/include/net/ip6_checksum.h
+++ b/include/net/ip6_checksum.h
@@ -66,12 +66,14 @@ static inline void __tcp_v6_send_check(struct sk_buff *skb,
 	}
 }
 
+#if IS_ENABLED(CONFIG_IPV6)
 static inline void tcp_v6_send_check(struct sock *sk, struct sk_buff *skb)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
 
 	__tcp_v6_send_check(skb, &np->saddr, &np->daddr);
 }
+#endif
 
 int udp6_csum_init(struct sk_buff *skb, struct udphdr *uh, int proto);
 #endif
* Unmerged path net/ipv4/ping.c
diff --git a/net/ipv4/tcp_metrics.c b/net/ipv4/tcp_metrics.c
index f6a005c485a9..9eb9c2db4415 100644
--- a/net/ipv4/tcp_metrics.c
+++ b/net/ipv4/tcp_metrics.c
@@ -252,11 +252,13 @@ static struct tcp_metrics_block *__tcp_get_metrics_tw(struct inet_timewait_sock
 		addr.addr.a4 = tw->tw_daddr;
 		hash = (__force unsigned int) addr.addr.a4;
 		break;
+#if IS_ENABLED(CONFIG_IPV6)
 	case AF_INET6:
 		tw6 = inet6_twsk((struct sock *)tw);
 		*(struct in6_addr *)addr.addr.a6 = tw6->tw_v6_daddr;
 		hash = ipv6_addr_hash(&tw6->tw_v6_daddr);
 		break;
+#endif
 	default:
 		return NULL;
 	}
@@ -288,10 +290,12 @@ static struct tcp_metrics_block *tcp_get_metrics(struct sock *sk,
 		addr.addr.a4 = inet_sk(sk)->inet_daddr;
 		hash = (__force unsigned int) addr.addr.a4;
 		break;
+#if IS_ENABLED(CONFIG_IPV6)
 	case AF_INET6:
 		*(struct in6_addr *)addr.addr.a6 = inet6_sk(sk)->daddr;
 		hash = ipv6_addr_hash(&inet6_sk(sk)->daddr);
 		break;
+#endif
 	default:
 		return NULL;
 	}
diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 305374d4fb98..2d847d3348f1 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -291,12 +291,14 @@ static int svc_one_sock_name(struct svc_sock *svsk, char *buf, int remaining)
 				&inet_sk(sk)->inet_rcv_saddr,
 				inet_sk(sk)->inet_num);
 		break;
+#if IS_ENABLED(CONFIG_IPV6)
 	case PF_INET6:
 		len = snprintf(buf, remaining, "ipv6 %s %pI6 %d\n",
 				proto_name,
 				&inet6_sk(sk)->rcv_saddr,
 				inet_sk(sk)->inet_num);
 		break;
+#endif
 	default:
 		len = snprintf(buf, remaining, "*unknown-%d*\n",
 				sk->sk_family);
diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index b0f249d1a1ef..af48450fd996 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -302,6 +302,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 						"faddr", "fport");
 				break;
 			}
+#if IS_ENABLED(CONFIG_IPV6)
 			case AF_INET6: {
 				struct inet_sock *inet = inet_sk(sk);
 				struct ipv6_pinfo *inet6 = inet6_sk(sk);
@@ -314,6 +315,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 						"faddr", "fport");
 				break;
 			}
+#endif
 			case AF_UNIX:
 				u = unix_sk(sk);
 				if (u->path.dentry) {
