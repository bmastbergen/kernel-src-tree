net: add and use skb_gso_transport_seglen()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] add and use skb_gso_transport_seglen() (Florian Westphal) [1065299]
Rebuild_FUZZ: 93.83%
commit-author Florian Westphal <fw@strlen.de>
commit de960aa9ab4decc3304959f69533eef64d05d8e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/de960aa9.failed

This moves part of Eric Dumazets skb_gso_seglen helper from tbf sched to
skbuff core so it may be reused by upcoming ip forwarding path patch.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit de960aa9ab4decc3304959f69533eef64d05d8e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/sched/sch_tbf.c
diff --cc include/linux/skbuff.h
index 68e9d4dbcf3b,f589c9af8cbf..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2334,56 -2421,53 +2334,96 @@@ static inline void skb_frag_add_head(st
  #define skb_walk_frags(skb, iter)	\
  	for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)
  
++<<<<<<< HEAD
 +extern struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
 +					   int *peeked, int *off, int *err);
 +extern struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags,
 +					 int noblock, int *err);
 +extern unsigned int    datagram_poll(struct file *file, struct socket *sock,
 +				     struct poll_table_struct *wait);
 +extern int	       skb_copy_datagram_iovec(const struct sk_buff *from,
 +					       int offset, struct iovec *to,
 +					       int size);
 +extern int	       skb_copy_and_csum_datagram_iovec(struct sk_buff *skb,
 +							int hlen,
 +							struct iovec *iov);
 +extern int	       skb_copy_datagram_from_iovec(struct sk_buff *skb,
 +						    int offset,
 +						    const struct iovec *from,
 +						    int from_offset,
 +						    int len);
 +extern int	       skb_copy_datagram_const_iovec(const struct sk_buff *from,
 +						     int offset,
 +						     const struct iovec *to,
 +						     int to_offset,
 +						     int size);
 +extern void	       skb_free_datagram(struct sock *sk, struct sk_buff *skb);
 +extern void	       skb_free_datagram_locked(struct sock *sk,
 +						struct sk_buff *skb);
 +extern int	       skb_kill_datagram(struct sock *sk, struct sk_buff *skb,
 +					 unsigned int flags);
 +extern __wsum	       skb_checksum(const struct sk_buff *skb, int offset,
 +				    int len, __wsum csum);
 +extern int	       skb_copy_bits(const struct sk_buff *skb, int offset,
 +				     void *to, int len);
 +extern int	       skb_store_bits(struct sk_buff *skb, int offset,
 +				      const void *from, int len);
 +extern __wsum	       skb_copy_and_csum_bits(const struct sk_buff *skb,
 +					      int offset, u8 *to, int len,
 +					      __wsum csum);
 +extern int             skb_splice_bits(struct sk_buff *skb,
 +						unsigned int offset,
 +						struct pipe_inode_info *pipe,
 +						unsigned int len,
 +						unsigned int flags);
 +extern void	       skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
 +extern void	       skb_split(struct sk_buff *skb,
 +				 struct sk_buff *skb1, const u32 len);
 +extern int	       skb_shift(struct sk_buff *tgt, struct sk_buff *skb,
 +				 int shiftlen);
 +extern void	       skb_scrub_packet(struct sk_buff *skb);
++=======
+ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
+ 				    int *peeked, int *off, int *err);
+ struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags, int noblock,
+ 				  int *err);
+ unsigned int datagram_poll(struct file *file, struct socket *sock,
+ 			   struct poll_table_struct *wait);
+ int skb_copy_datagram_iovec(const struct sk_buff *from, int offset,
+ 			    struct iovec *to, int size);
+ int skb_copy_and_csum_datagram_iovec(struct sk_buff *skb, int hlen,
+ 				     struct iovec *iov);
+ int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
+ 				 const struct iovec *from, int from_offset,
+ 				 int len);
+ int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *frm,
+ 			   int offset, size_t count);
+ int skb_copy_datagram_const_iovec(const struct sk_buff *from, int offset,
+ 				  const struct iovec *to, int to_offset,
+ 				  int size);
+ void skb_free_datagram(struct sock *sk, struct sk_buff *skb);
+ void skb_free_datagram_locked(struct sock *sk, struct sk_buff *skb);
+ int skb_kill_datagram(struct sock *sk, struct sk_buff *skb, unsigned int flags);
+ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len);
+ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len);
+ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset, u8 *to,
+ 			      int len, __wsum csum);
+ int skb_splice_bits(struct sk_buff *skb, unsigned int offset,
+ 		    struct pipe_inode_info *pipe, unsigned int len,
+ 		    unsigned int flags);
+ void skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
+ unsigned int skb_zerocopy_headlen(const struct sk_buff *from);
+ void skb_zerocopy(struct sk_buff *to, const struct sk_buff *from,
+ 		  int len, int hlen);
+ void skb_split(struct sk_buff *skb, struct sk_buff *skb1, const u32 len);
+ int skb_shift(struct sk_buff *tgt, struct sk_buff *skb, int shiftlen);
+ void skb_scrub_packet(struct sk_buff *skb, bool xnet);
+ unsigned int skb_gso_transport_seglen(const struct sk_buff *skb);
+ struct sk_buff *skb_segment(struct sk_buff *skb, netdev_features_t features);
++>>>>>>> de960aa9ab4d (net: add and use skb_gso_transport_seglen())
  
 -struct skb_checksum_ops {
 -	__wsum (*update)(const void *mem, int len, __wsum wsum);
 -	__wsum (*combine)(__wsum csum, __wsum csum2, int offset, int len);
 -};
 -
 -__wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
 -		      __wsum csum, const struct skb_checksum_ops *ops);
 -__wsum skb_checksum(const struct sk_buff *skb, int offset, int len,
 -		    __wsum csum);
 +extern struct sk_buff *skb_segment(struct sk_buff *skb,
 +				   netdev_features_t features);
  
  static inline void *skb_header_pointer(const struct sk_buff *skb, int offset,
  				       int len, void *buffer)
diff --cc net/sched/sch_tbf.c
index e478d316602b,1cb413fead89..000000000000
--- a/net/sched/sch_tbf.c
+++ b/net/sched/sch_tbf.c
@@@ -116,14 -116,89 +116,96 @@@ struct tbf_sched_data 
  	struct qdisc_watchdog watchdog;	/* Watchdog timer */
  };
  
++<<<<<<< HEAD
++=======
+ 
+ /* Time to Length, convert time in ns to length in bytes
+  * to determinate how many bytes can be sent in given time.
+  */
+ static u64 psched_ns_t2l(const struct psched_ratecfg *r,
+ 			 u64 time_in_ns)
+ {
+ 	/* The formula is :
+ 	 * len = (time_in_ns * r->rate_bytes_ps) / NSEC_PER_SEC
+ 	 */
+ 	u64 len = time_in_ns * r->rate_bytes_ps;
+ 
+ 	do_div(len, NSEC_PER_SEC);
+ 
+ 	if (unlikely(r->linklayer == TC_LINKLAYER_ATM)) {
+ 		do_div(len, 53);
+ 		len = len * 48;
+ 	}
+ 
+ 	if (len > r->overhead)
+ 		len -= r->overhead;
+ 	else
+ 		len = 0;
+ 
+ 	return len;
+ }
+ 
+ /*
+  * Return length of individual segments of a gso packet,
+  * including all headers (MAC, IP, TCP/UDP)
+  */
+ static unsigned int skb_gso_mac_seglen(const struct sk_buff *skb)
+ {
+ 	unsigned int hdr_len = skb_transport_header(skb) - skb_mac_header(skb);
+ 	return hdr_len + skb_gso_transport_seglen(skb);
+ }
+ 
+ /* GSO packet is too big, segment it so that tbf can transmit
+  * each segment in time
+  */
+ static int tbf_segment(struct sk_buff *skb, struct Qdisc *sch)
+ {
+ 	struct tbf_sched_data *q = qdisc_priv(sch);
+ 	struct sk_buff *segs, *nskb;
+ 	netdev_features_t features = netif_skb_features(skb);
+ 	int ret, nb;
+ 
+ 	segs = skb_gso_segment(skb, features & ~NETIF_F_GSO_MASK);
+ 
+ 	if (IS_ERR_OR_NULL(segs))
+ 		return qdisc_reshape_fail(skb, sch);
+ 
+ 	nb = 0;
+ 	while (segs) {
+ 		nskb = segs->next;
+ 		segs->next = NULL;
+ 		qdisc_skb_cb(segs)->pkt_len = segs->len;
+ 		ret = qdisc_enqueue(segs, q->qdisc);
+ 		if (ret != NET_XMIT_SUCCESS) {
+ 			if (net_xmit_drop_count(ret))
+ 				sch->qstats.drops++;
+ 		} else {
+ 			nb++;
+ 		}
+ 		segs = nskb;
+ 	}
+ 	sch->q.qlen += nb;
+ 	if (nb > 1)
+ 		qdisc_tree_decrease_qlen(sch, 1 - nb);
+ 	consume_skb(skb);
+ 	return nb > 0 ? NET_XMIT_SUCCESS : NET_XMIT_DROP;
+ }
+ 
++>>>>>>> de960aa9ab4d (net: add and use skb_gso_transport_seglen())
  static int tbf_enqueue(struct sk_buff *skb, struct Qdisc *sch)
  {
  	struct tbf_sched_data *q = qdisc_priv(sch);
  	int ret;
  
++<<<<<<< HEAD
 +	if (qdisc_pkt_len(skb) > q->max_size)
++=======
+ 	if (qdisc_pkt_len(skb) > q->max_size) {
+ 		if (skb_is_gso(skb) && skb_gso_mac_seglen(skb) <= q->max_size)
+ 			return tbf_segment(skb, sch);
++>>>>>>> de960aa9ab4d (net: add and use skb_gso_transport_seglen())
  		return qdisc_reshape_fail(skb, sch);
 -	}
 +
  	ret = qdisc_enqueue(skb, q->qdisc);
  	if (ret != NET_XMIT_SUCCESS) {
  		if (net_xmit_drop_count(ret))
* Unmerged path include/linux/skbuff.h
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 297f9134ef13..4bb65150c6b8 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -47,6 +47,8 @@
 #include <linux/in.h>
 #include <linux/inet.h>
 #include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
 #include <linux/netdevice.h>
 #ifdef CONFIG_NET_CLS_ACT
 #include <net/pkt_sched.h>
@@ -3533,3 +3535,26 @@ void skb_scrub_packet(struct sk_buff *skb)
 	nf_reset_trace(skb);
 }
 EXPORT_SYMBOL_GPL(skb_scrub_packet);
+
+/**
+ * skb_gso_transport_seglen - Return length of individual segments of a gso packet
+ *
+ * @skb: GSO skb
+ *
+ * skb_gso_transport_seglen is used to determine the real size of the
+ * individual segments, including Layer4 headers (TCP/UDP).
+ *
+ * The MAC/L2 or network (IP, IPv6) headers are not accounted for.
+ */
+unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
+{
+	const struct skb_shared_info *shinfo = skb_shinfo(skb);
+	unsigned int hdr_len;
+
+	if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
+		hdr_len = tcp_hdrlen(skb);
+	else
+		hdr_len = sizeof(struct udphdr);
+	return hdr_len + shinfo->gso_size;
+}
+EXPORT_SYMBOL_GPL(skb_gso_transport_seglen);
* Unmerged path net/sched/sch_tbf.c
