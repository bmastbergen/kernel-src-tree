drm/i915/vlv: add VLV specific clock_get function v3

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [drm] i915/vlv: add VLV specific clock_get function v3 (Rob Clark) [1054409]
Rebuild_FUZZ: 96.00%
commit-author Jesse Barnes <jbarnes@virtuousgeek.org>
commit acbec814a27f233b5ddb88a1bcaa2ac20daf64e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/acbec814.failed

Calculation is a little different than other platforms.

v2: update to use port_clock instead
    rebase on top of Ville's changes
v3: update to new port_clock semantics - don't divide by
    pixel_multiplier (Ville)

References: https://bugs.freedesktop.org/show_bug.cgi?id=67345
	Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
	Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
(cherry picked from commit acbec814a27f233b5ddb88a1bcaa2ac20daf64e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_display.c
diff --cc drivers/gpu/drm/i915/intel_display.c
index bcc9e0539bc8,5b52ab0ccaff..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -4757,6 -5049,61 +4757,64 @@@ static int i9xx_crtc_mode_set(struct dr
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void i9xx_get_pfit_config(struct intel_crtc *crtc,
+ 				 struct intel_crtc_config *pipe_config)
+ {
+ 	struct drm_device *dev = crtc->base.dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	uint32_t tmp;
+ 
+ 	tmp = I915_READ(PFIT_CONTROL);
+ 	if (!(tmp & PFIT_ENABLE))
+ 		return;
+ 
+ 	/* Check whether the pfit is attached to our pipe. */
+ 	if (INTEL_INFO(dev)->gen < 4) {
+ 		if (crtc->pipe != PIPE_B)
+ 			return;
+ 	} else {
+ 		if ((tmp & PFIT_PIPE_MASK) != (crtc->pipe << PFIT_PIPE_SHIFT))
+ 			return;
+ 	}
+ 
+ 	pipe_config->gmch_pfit.control = tmp;
+ 	pipe_config->gmch_pfit.pgm_ratios = I915_READ(PFIT_PGM_RATIOS);
+ 	if (INTEL_INFO(dev)->gen < 5)
+ 		pipe_config->gmch_pfit.lvds_border_bits =
+ 			I915_READ(LVDS) & LVDS_BORDER_ENABLE;
+ }
+ 
+ static void vlv_crtc_clock_get(struct intel_crtc *crtc,
+ 			       struct intel_crtc_config *pipe_config)
+ {
+ 	struct drm_device *dev = crtc->base.dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	int pipe = pipe_config->cpu_transcoder;
+ 	intel_clock_t clock;
+ 	u32 mdiv;
+ 	int refclk = 100000, fastclk, update_rate;
+ 
+ 	mutex_lock(&dev_priv->dpio_lock);
+ 	mdiv = vlv_dpio_read(dev_priv, pipe, DPIO_DIV(pipe));
+ 	mutex_unlock(&dev_priv->dpio_lock);
+ 
+ 	clock.m1 = (mdiv >> DPIO_M1DIV_SHIFT) & 7;
+ 	clock.m2 = mdiv & DPIO_M2DIV_MASK;
+ 	clock.n = (mdiv >> DPIO_N_SHIFT) & 0xf;
+ 	clock.p1 = (mdiv >> DPIO_P1_SHIFT) & 7;
+ 	clock.p2 = (mdiv >> DPIO_P2_SHIFT) & 0x1f;
+ 
+ 	update_rate = refclk / clock.n;
+ 	clock.vco = update_rate * clock.m1 * clock.m2;
+ 	fastclk = clock.vco / clock.p1 / clock.p2;
+ 	clock.dot = (2 * fastclk);
+ 
+ 	pipe_config->port_clock = clock.dot / 10;
+ }
+ 
++>>>>>>> acbec814a27f (drm/i915/vlv: add VLV specific clock_get function v3)
  static bool i9xx_get_pipe_config(struct intel_crtc *crtc,
  				 struct intel_crtc_config *pipe_config)
  {
@@@ -4768,6 -5118,62 +4826,65 @@@
  	if (!(tmp & PIPECONF_ENABLE))
  		return false;
  
++<<<<<<< HEAD
++=======
+ 	if (IS_G4X(dev) || IS_VALLEYVIEW(dev)) {
+ 		switch (tmp & PIPECONF_BPC_MASK) {
+ 		case PIPECONF_6BPC:
+ 			pipe_config->pipe_bpp = 18;
+ 			break;
+ 		case PIPECONF_8BPC:
+ 			pipe_config->pipe_bpp = 24;
+ 			break;
+ 		case PIPECONF_10BPC:
+ 			pipe_config->pipe_bpp = 30;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (INTEL_INFO(dev)->gen < 4)
+ 		pipe_config->double_wide = tmp & PIPECONF_DOUBLE_WIDE;
+ 
+ 	intel_get_pipe_timings(crtc, pipe_config);
+ 
+ 	i9xx_get_pfit_config(crtc, pipe_config);
+ 
+ 	if (INTEL_INFO(dev)->gen >= 4) {
+ 		tmp = I915_READ(DPLL_MD(crtc->pipe));
+ 		pipe_config->pixel_multiplier =
+ 			((tmp & DPLL_MD_UDI_MULTIPLIER_MASK)
+ 			 >> DPLL_MD_UDI_MULTIPLIER_SHIFT) + 1;
+ 		pipe_config->dpll_hw_state.dpll_md = tmp;
+ 	} else if (IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev)) {
+ 		tmp = I915_READ(DPLL(crtc->pipe));
+ 		pipe_config->pixel_multiplier =
+ 			((tmp & SDVO_MULTIPLIER_MASK)
+ 			 >> SDVO_MULTIPLIER_SHIFT_HIRES) + 1;
+ 	} else {
+ 		/* Note that on i915G/GM the pixel multiplier is in the sdvo
+ 		 * port and will be fixed up in the encoder->get_config
+ 		 * function. */
+ 		pipe_config->pixel_multiplier = 1;
+ 	}
+ 	pipe_config->dpll_hw_state.dpll = I915_READ(DPLL(crtc->pipe));
+ 	if (!IS_VALLEYVIEW(dev)) {
+ 		pipe_config->dpll_hw_state.fp0 = I915_READ(FP0(crtc->pipe));
+ 		pipe_config->dpll_hw_state.fp1 = I915_READ(FP1(crtc->pipe));
+ 	} else {
+ 		/* Mask out read-only status bits. */
+ 		pipe_config->dpll_hw_state.dpll &= ~(DPLL_LOCK_VLV |
+ 						     DPLL_PORTC_READY_MASK |
+ 						     DPLL_PORTB_READY_MASK);
+ 	}
+ 
+ 	if (IS_VALLEYVIEW(dev))
+ 		vlv_crtc_clock_get(crtc, pipe_config);
+ 	else
+ 		i9xx_crtc_clock_get(crtc, pipe_config);
+ 
++>>>>>>> acbec814a27f (drm/i915/vlv: add VLV specific clock_get function v3)
  	return true;
  }
  
* Unmerged path drivers/gpu/drm/i915/intel_display.c
