... and kill anon_inode_getfile_private()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [fs] kill anon_inode_getfile_private() (Motohiro Kosaki) [995323]
Rebuild_FUZZ: 89.19%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 078d8e624c1837aa8ad65e58054a4a40d7ac46d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/078d8e62.failed

it's a seriously misguided API, now fortunately without users.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 078d8e624c1837aa8ad65e58054a4a40d7ac46d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/anon_inodes.c
diff --cc fs/anon_inodes.c
index 85c961849953,24084732b1d0..000000000000
--- a/fs/anon_inodes.c
+++ b/fs/anon_inodes.c
@@@ -109,72 -63,6 +109,75 @@@ static struct file_system_type anon_ino
  };
  
  /**
++<<<<<<< HEAD
 + * anon_inode_getfile_private - creates a new file instance by hooking it up to an
 + *                      anonymous inode, and a dentry that describe the "class"
 + *                      of the file
 + *
 + * @name:    [in]    name of the "class" of the new file
 + * @fops:    [in]    file operations for the new file
 + * @priv:    [in]    private data for the new file (will be file's private_data)
 + * @flags:   [in]    flags
 + *
 + *
 + * Similar to anon_inode_getfile, but each file holds a single inode.
 + *
 + */
 +struct file *anon_inode_getfile_private(const char *name,
 +					const struct file_operations *fops,
 +					void *priv, int flags)
 +{
 +	struct qstr this;
 +	struct path path;
 +	struct file *file;
 +	struct inode *inode;
 +
 +	if (fops->owner && !try_module_get(fops->owner))
 +		return ERR_PTR(-ENOENT);
 +
 +	inode = anon_inode_mkinode(anon_inode_mnt->mnt_sb);
 +	if (IS_ERR(inode)) {
 +		file = ERR_PTR(-ENOMEM);
 +		goto err_module;
 +	}
 +
 +	/*
 +	 * Link the inode to a directory entry by creating a unique name
 +	 * using the inode sequence number.
 +	 */
 +	file = ERR_PTR(-ENOMEM);
 +	this.name = name;
 +	this.len = strlen(name);
 +	this.hash = 0;
 +	path.dentry = d_alloc_pseudo(anon_inode_mnt->mnt_sb, &this);
 +	if (!path.dentry)
 +		goto err_module;
 +
 +	path.mnt = mntget(anon_inode_mnt);
 +
 +	d_instantiate(path.dentry, inode);
 +
 +	file = alloc_file(&path, OPEN_FMODE(flags), fops);
 +	if (IS_ERR(file))
 +		goto err_dput;
 +
 +	file->f_mapping = inode->i_mapping;
 +	file->f_flags = flags & (O_ACCMODE | O_NONBLOCK);
 +	file->private_data = priv;
 +
 +	return file;
 +
 +err_dput:
 +	path_put(&path);
 +err_module:
 +	module_put(fops->owner);
 +	return file;
 +}
 +EXPORT_SYMBOL_GPL(anon_inode_getfile_private);
 +
 +/**
++=======
++>>>>>>> 078d8e624c18 (... and kill anon_inode_getfile_private())
   * anon_inode_getfile - creates a new file instance by hooking it up to an
   *                      anonymous inode, and a dentry that describe the "class"
   *                      of the file
* Unmerged path fs/anon_inodes.c
diff --git a/include/linux/anon_inodes.h b/include/linux/anon_inodes.h
index cf573c22b81e..8013a45242fe 100644
--- a/include/linux/anon_inodes.h
+++ b/include/linux/anon_inodes.h
@@ -13,9 +13,6 @@ struct file_operations;
 struct file *anon_inode_getfile(const char *name,
 				const struct file_operations *fops,
 				void *priv, int flags);
-struct file *anon_inode_getfile_private(const char *name,
-				const struct file_operations *fops,
-				void *priv, int flags);
 int anon_inode_getfd(const char *name, const struct file_operations *fops,
 		     void *priv, int flags);
 
