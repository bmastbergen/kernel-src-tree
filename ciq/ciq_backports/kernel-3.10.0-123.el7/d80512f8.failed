s390/smp: improve setup of possible cpu mask

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [s390] smp: improve setup of possible cpu mask (Hendrik Brueckner) [1052906]
Rebuild_FUZZ: 93.98%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit d80512f87474f2dfd67ef931737659acce20fe69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/d80512f8.failed

Since under z/VM we cannot have more than 64 cpus, make sure the
cpu_possible_mask does not contain more bits.
This avoids wasting memory for dynamic per-cpu allocations if
CONFIG_NR_CPUS is larger than 64.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit d80512f87474f2dfd67ef931737659acce20fe69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/Kconfig
diff --cc arch/s390/Kconfig
index c9d6fa9c61b7,e9f312532526..000000000000
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@@ -133,15 -135,13 +133,18 @@@ config S39
  	select HAVE_SYSCALL_TRACEPOINTS
  	select HAVE_UID16 if 32BIT
  	select HAVE_VIRT_CPU_ACCOUNTING
++<<<<<<< HEAD
 +	select VIRT_TO_BUS
 +	select INIT_ALL_POSSIBLE
++=======
++>>>>>>> d80512f87474 (s390/smp: improve setup of possible cpu mask)
  	select KTIME_SCALAR if 32BIT
  	select MODULES_USE_ELF_RELA
 -	select OLD_SIGACTION
  	select OLD_SIGSUSPEND3
 +	select OLD_SIGACTION
  	select SYSCTL_EXCEPTION_TRACE
 +	select USE_GENERIC_SMP_HELPERS if SMP
  	select VIRT_CPU_ACCOUNTING
 -	select VIRT_TO_BUS
  
  config SCHED_OMIT_FRAME_POINTER
  	def_bool y
* Unmerged path arch/s390/Kconfig
diff --git a/arch/s390/include/asm/smp.h b/arch/s390/include/asm/smp.h
index b64f15c3b4cc..21de5331f23a 100644
--- a/arch/s390/include/asm/smp.h
+++ b/arch/s390/include/asm/smp.h
@@ -32,6 +32,7 @@ extern void smp_yield(void);
 extern void smp_stop_cpu(void);
 extern void smp_cpu_set_polarization(int cpu, int val);
 extern int smp_cpu_get_polarization(int cpu);
+extern void smp_fill_possible_mask(void);
 
 #else /* CONFIG_SMP */
 
@@ -51,6 +52,7 @@ static inline int smp_vcpu_scheduled(int cpu) { return 1; }
 static inline void smp_yield_cpu(int cpu) { }
 static inline void smp_yield(void) { }
 static inline void smp_stop_cpu(void) { }
+static inline void smp_fill_possible_mask(void) { }
 
 #endif /* CONFIG_SMP */
 
diff --git a/arch/s390/kernel/setup.c b/arch/s390/kernel/setup.c
index 0a49095104c9..3930daa493c4 100644
--- a/arch/s390/kernel/setup.c
+++ b/arch/s390/kernel/setup.c
@@ -1064,6 +1064,7 @@ void __init setup_arch(char **cmdline_p)
 	setup_vmcoreinfo();
 	setup_lowcore();
 
+	smp_fill_possible_mask();
         cpu_init();
 	s390_init_cpu_topology();
 
diff --git a/arch/s390/kernel/smp.c b/arch/s390/kernel/smp.c
index 14647fe09d0c..1ae477a97bd4 100644
--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@ -734,18 +734,14 @@ int __cpuinit __cpu_up(unsigned int cpu, struct task_struct *tidle)
 	return 0;
 }
 
-static int __init setup_possible_cpus(char *s)
-{
-	int max, cpu;
+static unsigned int setup_possible_cpus __initdata;
 
-	if (kstrtoint(s, 0, &max) < 0)
-		return 0;
-	init_cpu_possible(cpumask_of(0));
-	for (cpu = 1; cpu < max && cpu < nr_cpu_ids; cpu++)
-		set_cpu_possible(cpu, true);
+static int __init _setup_possible_cpus(char *s)
+{
+	get_option(&s, &setup_possible_cpus);
 	return 0;
 }
-early_param("possible_cpus", setup_possible_cpus);
+early_param("possible_cpus", _setup_possible_cpus);
 
 #ifdef CONFIG_HOTPLUG_CPU
 
@@ -788,6 +784,17 @@ void __noreturn cpu_die(void)
 
 #endif /* CONFIG_HOTPLUG_CPU */
 
+void __init smp_fill_possible_mask(void)
+{
+	unsigned int possible, cpu;
+
+	possible = setup_possible_cpus;
+	if (!possible)
+		possible = MACHINE_IS_VM ? 64 : nr_cpu_ids;
+	for (cpu = 0; cpu < possible && cpu < nr_cpu_ids; cpu++)
+		set_cpu_possible(cpu, true);
+}
+
 void __init smp_prepare_cpus(unsigned int max_cpus)
 {
 	/* request the 0x1201 emergency signal external interrupt */
