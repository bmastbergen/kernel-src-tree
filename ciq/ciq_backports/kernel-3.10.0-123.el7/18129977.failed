dcache: get/release read lock in read_seqbegin_or_lock() & friend

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Waiman Long <Waiman.Long@hp.com>
commit 1812997720ab90d029548778c55d7315555e1fef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/18129977.failed

This patch modifies read_seqbegin_or_lock() and need_seqretry() to use
newly introduced read_seqlock_excl() and read_sequnlock_excl()
primitives so that they won't change the sequence number even if they
fall back to take the lock.  This is OK as no change to the protected
data structure is being made.

It will prevent one fallback to lock taking from cascading into a series
of lock taking reducing performance because of the sequence number
change.  It will also allow other sequence readers to go forward while
an exclusive reader lock is taken.

This patch also updates some of the inaccurate comments in the code.

	Signed-off-by: Waiman Long <Waiman.Long@hp.com>
To: Alexander Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1812997720ab90d029548778c55d7315555e1fef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dcache.c
diff --cc fs/dcache.c
index c1d239fbff60,f3dcc6351a16..000000000000
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@@ -88,6 -88,35 +88,38 @@@ EXPORT_SYMBOL(rename_lock)
  
  static struct kmem_cache *dentry_cache __read_mostly;
  
++<<<<<<< HEAD
++=======
+ /**
+  * read_seqbegin_or_lock - begin a sequence number check or locking block
+  * @lock: sequence lock
+  * @seq : sequence number to be checked
+  *
+  * First try it once optimistically without taking the lock. If that fails,
+  * take the lock. The sequence number is also used as a marker for deciding
+  * whether to be a reader (even) or writer (odd).
+  * N.B. seq must be initialized to an even number to begin with.
+  */
+ static inline void read_seqbegin_or_lock(seqlock_t *lock, int *seq)
+ {
+ 	if (!(*seq & 1))	/* Even */
+ 		*seq = read_seqbegin(lock);
+ 	else			/* Odd */
+ 		read_seqlock_excl(lock);
+ }
+ 
+ static inline int need_seqretry(seqlock_t *lock, int seq)
+ {
+ 	return !(seq & 1) && read_seqretry(lock, seq);
+ }
+ 
+ static inline void done_seqretry(seqlock_t *lock, int seq)
+ {
+ 	if (seq & 1)
+ 		read_sequnlock_excl(lock);
+ }
+ 
++>>>>>>> 1812997720ab (dcache: get/release read lock in read_seqbegin_or_lock() & friend)
  /*
   * This is the single most critical data structure when it comes
   * to the dcache: the hashtable for lookups. Somebody should try
@@@ -2612,9 -2671,39 +2644,27 @@@ static int prepend(char **buffer, int *
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * prepend_name - prepend a pathname in front of current buffer pointer
+  * @buffer: buffer pointer
+  * @buflen: allocated length of the buffer
+  * @name:   name string and length qstr structure
+  *
+  * With RCU path tracing, it may race with d_move(). Use ACCESS_ONCE() to
+  * make sure that either the old or the new name pointer and length are
+  * fetched. However, there may be mismatch between length and pointer.
+  * The length cannot be trusted, we need to copy it byte-by-byte until
+  * the length is reached or a null byte is found. It also prepends "/" at
+  * the beginning of the name. The sequence number check at the caller will
+  * retry it again when a d_move() does happen. So any garbage in the buffer
+  * due to mismatched pointer and length will be discarded.
+  */
++>>>>>>> 1812997720ab (dcache: get/release read lock in read_seqbegin_or_lock() & friend)
  static int prepend_name(char **buffer, int *buflen, struct qstr *name)
  {
 -	const char *dname = ACCESS_ONCE(name->name);
 -	u32 dlen = ACCESS_ONCE(name->len);
 -	char *p;
 -
 -	if (*buflen < dlen + 1)
 -		return -ENAMETOOLONG;
 -	*buflen -= dlen + 1;
 -	p = *buffer -= dlen + 1;
 -	*p++ = '/';
 -	while (dlen--) {
 -		char c = *dname++;
 -		if (!c)
 -			break;
 -		*p++ = c;
 -	}
 -	return 0;
 +	return prepend(buffer, buflen, name->name, name->len);
  }
  
  /**
@@@ -2624,7 -2713,15 +2674,19 @@@
   * @buffer: pointer to the end of the buffer
   * @buflen: pointer to buffer length
   *
++<<<<<<< HEAD
 + * Caller holds the rename_lock.
++=======
+  * The function will first try to write out the pathname without taking any
+  * lock other than the RCU read lock to make sure that dentries won't go away.
+  * It only checks the sequence number of the global rename_lock as any change
+  * in the dentry's d_seq will be preceded by changes in the rename_lock
+  * sequence number. If the sequence number had been changed, it will restart
+  * the whole pathname back-tracing sequence again by taking the rename_lock.
+  * In this case, there is no need to take the RCU read lock as the recursive
+  * parent pointer references will keep the dentry chain alive as long as no
+  * rename operation is performed.
++>>>>>>> 1812997720ab (dcache: get/release read lock in read_seqbegin_or_lock() & friend)
   */
  static int prepend_path(const struct path *path,
  			const struct path *root,
* Unmerged path fs/dcache.c
