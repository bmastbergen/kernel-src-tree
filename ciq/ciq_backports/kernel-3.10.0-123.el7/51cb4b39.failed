drm/nouveau/core: convert event handler apis to split create/enable semantics

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [drm] nouveau: convert event handler apis to split create/enable semantics (Rob Clark) [1018414]
Rebuild_FUZZ: 93.79%
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 51cb4b392a307a8293b4f1f300ab803d7ad3b036
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/51cb4b39.failed

This is a necessary step towards being able to work with the insane locking
requirements of the DRM core's vblank routines, and a nice cleanup as a
side-effect.

This is similar in spirit to the interfaces that Peter Hurley arrived at
with his nouveau_event rcu conversion series.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 51cb4b392a307a8293b4f1f300ab803d7ad3b036)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/core/engine/software/nv50.c
#	drivers/gpu/drm/nouveau/core/engine/software/nv50.h
#	drivers/gpu/drm/nouveau/nouveau_display.c
diff --cc drivers/gpu/drm/nouveau/core/engine/software/nv50.c
index b79e6c54e372,b574dd4bb828..000000000000
--- a/drivers/gpu/drm/nouveau/core/engine/software/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/engine/software/nv50.c
@@@ -147,22 -145,51 +145,62 @@@ nv50_software_vblsem_release(void *data
  	return NVKM_EVENT_DROP;
  }
  
++<<<<<<< HEAD
 +static int
++=======
+ void
+ nv50_software_context_dtor(struct nouveau_object *object)
+ {
+ 	struct nv50_software_chan *chan = (void *)object;
+ 	int i;
+ 
+ 	if (chan->vblank.event) {
+ 		for (i = 0; i < chan->vblank.nr_event; i++)
+ 			nouveau_event_ref(NULL, &chan->vblank.event[i]);
+ 		kfree(chan->vblank.event);
+ 	}
+ 
+ 	nouveau_software_context_destroy(&chan->base);
+ }
+ 
+ int
++>>>>>>> 51cb4b392a30 (drm/nouveau/core: convert event handler apis to split create/enable semantics)
  nv50_software_context_ctor(struct nouveau_object *parent,
  			   struct nouveau_object *engine,
  			   struct nouveau_oclass *oclass, void *data, u32 size,
  			   struct nouveau_object **pobject)
  {
++<<<<<<< HEAD
++=======
+ 	struct nouveau_disp *pdisp = nouveau_disp(parent);
+ 	struct nv50_software_cclass *pclass = (void *)oclass;
++>>>>>>> 51cb4b392a30 (drm/nouveau/core: convert event handler apis to split create/enable semantics)
  	struct nv50_software_chan *chan;
- 	int ret;
+ 	int ret, i;
  
  	ret = nouveau_software_context_create(parent, engine, oclass, &chan);
  	*pobject = nv_object(chan);
  	if (ret)
  		return ret;
  
+ 	chan->vblank.nr_event = pdisp->vblank->index_nr;
+ 	chan->vblank.event = kzalloc(chan->vblank.nr_event *
+ 				     sizeof(*chan->vblank.event), GFP_KERNEL);
+ 	if (!chan->vblank.event)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < chan->vblank.nr_event; i++) {
+ 		ret = nouveau_event_new(pdisp->vblank, i, pclass->vblank,
+ 					chan, &chan->vblank.event[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
  	chan->vblank.channel = nv_gpuobj(parent->parent)->addr >> 12;
++<<<<<<< HEAD
 +	chan->vblank.event.func = nv50_software_vblsem_release;
++=======
++>>>>>>> 51cb4b392a30 (drm/nouveau/core: convert event handler apis to split create/enable semantics)
  	return 0;
  }
  
diff --cc drivers/gpu/drm/nouveau/core/engine/software/nv50.h
index cbdcab3f4f63,2de370c21279..000000000000
--- a/drivers/gpu/drm/nouveau/core/engine/software/nv50.h
+++ b/drivers/gpu/drm/nouveau/core/engine/software/nv50.h
@@@ -7,6 -13,15 +7,18 @@@ struct nv50_software_priv 
  	struct nouveau_software base;
  };
  
++<<<<<<< HEAD
++=======
+ int  nv50_software_ctor(struct nouveau_object *, struct nouveau_object *,
+ 			struct nouveau_oclass *, void *, u32,
+ 			struct nouveau_object **);
+ 
+ struct nv50_software_cclass {
+ 	struct nouveau_oclass base;
+ 	int (*vblank)(void *, int);
+ };
+ 
++>>>>>>> 51cb4b392a30 (drm/nouveau/core: convert event handler apis to split create/enable semantics)
  struct nv50_software_chan {
  	struct nouveau_software_chan base;
  	struct {
@@@ -18,4 -34,14 +31,17 @@@
  	} vblank;
  };
  
++<<<<<<< HEAD
++=======
+ int  nv50_software_context_ctor(struct nouveau_object *,
+ 				struct nouveau_object *,
+ 				struct nouveau_oclass *, void *, u32,
+ 				struct nouveau_object **);
+ void nv50_software_context_dtor(struct nouveau_object *);
+ 
+ int nv50_software_mthd_vblsem_value(struct nouveau_object *, u32, void *, u32);
+ int nv50_software_mthd_vblsem_release(struct nouveau_object *, u32, void *, u32);
+ int nv50_software_mthd_flip(struct nouveau_object *, u32, void *, u32);
+ 
++>>>>>>> 51cb4b392a30 (drm/nouveau/core: convert event handler apis to split create/enable semantics)
  #endif
diff --cc drivers/gpu/drm/nouveau/nouveau_display.c
index f17dc2ab03ec,510d13ee1a04..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_display.c
+++ b/drivers/gpu/drm/nouveau/nouveau_display.c
@@@ -336,18 -407,20 +399,30 @@@ nouveau_display_create(struct drm_devic
  			ret = nv04_display_create(dev);
  		else
  			ret = nv50_display_create(dev);
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		ret = 0;
+ 	}
+ 
+ 	if (ret)
+ 		goto disp_create_err;
+ 
+ 	if (dev->mode_config.num_crtc) {
+ 		ret = nouveau_display_vblank_init(dev);
++>>>>>>> 51cb4b392a30 (drm/nouveau/core: convert event handler apis to split create/enable semantics)
  		if (ret)
 -			goto vblank_err;
 +			goto disp_create_err;
 +
 +		if (dev->mode_config.num_crtc) {
 +			ret = drm_vblank_init(dev, dev->mode_config.num_crtc);
 +			if (ret)
 +				goto vblank_err;
 +		}
 +
 +		nouveau_backlight_init(dev);
  	}
  
 -	nouveau_backlight_init(dev);
  	return 0;
  
  vblank_err:
diff --git a/drivers/gpu/drm/nouveau/core/core/event.c b/drivers/gpu/drm/nouveau/core/core/event.c
index 9393c37b71c9..313afcc65e0f 100644
--- a/drivers/gpu/drm/nouveau/core/core/event.c
+++ b/drivers/gpu/drm/nouveau/core/core/event.c
@@ -37,39 +37,82 @@ nouveau_event_put_locked(struct nouveau_event *event, int index,
 }
 
 void
-nouveau_event_put(struct nouveau_event *event, int index,
-		  struct nouveau_eventh *handler)
+nouveau_event_put(struct nouveau_eventh *handler)
 {
+	struct nouveau_event *event = handler->event;
 	unsigned long flags;
-
-	if (index >= event->index_nr)
-		return;
-
 	spin_lock_irqsave(&event->lock, flags);
-	nouveau_event_put_locked(event, index, handler);
+	nouveau_event_put_locked(handler->event, handler->index, handler);
 	spin_unlock_irqrestore(&event->lock, flags);
 }
 
 void
-nouveau_event_get(struct nouveau_event *event, int index,
-		  struct nouveau_eventh *handler)
+nouveau_event_get(struct nouveau_eventh *handler)
 {
+	struct nouveau_event *event = handler->event;
 	unsigned long flags;
 
-	if (index >= event->index_nr)
-		return;
-
 	spin_lock_irqsave(&event->lock, flags);
 	if (!__test_and_set_bit(NVKM_EVENT_ENABLE, &handler->flags)) {
-		list_add(&handler->head, &event->index[index].list);
-		if (!event->index[index].refs++) {
+		list_add(&handler->head, &event->index[handler->index].list);
+		if (!event->index[handler->index].refs++) {
 			if (event->enable)
-				event->enable(event, index);
+				event->enable(event, handler->index);
 		}
 	}
 	spin_unlock_irqrestore(&event->lock, flags);
 }
 
+static void
+nouveau_event_fini(struct nouveau_eventh *handler)
+{
+	nouveau_event_put(handler);
+}
+
+static int
+nouveau_event_init(struct nouveau_event *event, int index,
+		   int (*func)(void *, int), void *priv,
+		   struct nouveau_eventh *handler)
+{
+	if (index >= event->index_nr)
+		return -EINVAL;
+	handler->event = event;
+	handler->flags = 0;
+	handler->index = index;
+	handler->func = func;
+	handler->priv = priv;
+	return 0;
+}
+
+int
+nouveau_event_new(struct nouveau_event *event, int index,
+		  int (*func)(void *, int), void *priv,
+		  struct nouveau_eventh **phandler)
+{
+	struct nouveau_eventh *handler;
+	int ret = -ENOMEM;
+
+	handler = *phandler = kmalloc(sizeof(*handler), GFP_KERNEL);
+	if (handler) {
+		ret = nouveau_event_init(event, index, func, priv, handler);
+		if (ret)
+			kfree(handler);
+	}
+
+	return ret;
+}
+
+void
+nouveau_event_ref(struct nouveau_eventh *handler, struct nouveau_eventh **ref)
+{
+	BUG_ON(handler != NULL);
+	if (*ref) {
+		nouveau_event_fini(*ref);
+		kfree(*ref);
+	}
+	*ref = handler;
+}
+
 void
 nouveau_event_trigger(struct nouveau_event *event, int index)
 {
@@ -81,7 +124,7 @@ nouveau_event_trigger(struct nouveau_event *event, int index)
 
 	spin_lock_irqsave(&event->lock, flags);
 	list_for_each_entry_safe(handler, temp, &event->index[index].list, head) {
-		if (handler->func(handler, index) == NVKM_EVENT_DROP) {
+		if (handler->func(handler->priv, index) == NVKM_EVENT_DROP) {
 			nouveau_event_put_locked(event, index, handler);
 		}
 	}
* Unmerged path drivers/gpu/drm/nouveau/core/engine/software/nv50.c
* Unmerged path drivers/gpu/drm/nouveau/core/engine/software/nv50.h
diff --git a/drivers/gpu/drm/nouveau/core/engine/software/nvc0.c b/drivers/gpu/drm/nouveau/core/engine/software/nvc0.c
index 6eaf08e68a09..78ffc90fba53 100644
--- a/drivers/gpu/drm/nouveau/core/engine/software/nvc0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/software/nvc0.c
@@ -54,40 +54,6 @@ nvc0_software_mthd_vblsem_offset(struct nouveau_object *object, u32 mthd,
 	return 0;
 }
 
-static int
-nvc0_software_mthd_vblsem_value(struct nouveau_object *object, u32 mthd,
-				void *args, u32 size)
-{
-	struct nv50_software_chan *chan = (void *)nv_engctx(object->parent);
-	chan->vblank.value = *(u32 *)args;
-	return 0;
-}
-
-static int
-nvc0_software_mthd_vblsem_release(struct nouveau_object *object, u32 mthd,
-				  void *args, u32 size)
-{
-	struct nv50_software_chan *chan = (void *)nv_engctx(object->parent);
-	struct nouveau_disp *disp = nouveau_disp(object);
-	u32 crtc = *(u32 *)args;
-
-	if ((nv_device(object)->card_type < NV_E0 && crtc > 1) || crtc > 3)
-		return -EINVAL;
-
-	nouveau_event_get(disp->vblank, crtc, &chan->vblank.event);
-	return 0;
-}
-
-static int
-nvc0_software_mthd_flip(struct nouveau_object *object, u32 mthd,
-			void *args, u32 size)
-{
-	struct nv50_software_chan *chan = (void *)nv_engctx(object->parent);
-	if (chan->base.flip)
-		return chan->base.flip(chan->base.flip_data);
-	return -EINVAL;
-}
-
 static int
 nvc0_software_mthd_mp_control(struct nouveau_object *object, u32 mthd,
                               void *args, u32 size)
@@ -118,9 +84,9 @@ static struct nouveau_omthds
 nvc0_software_omthds[] = {
 	{ 0x0400, 0x0400, nvc0_software_mthd_vblsem_offset },
 	{ 0x0404, 0x0404, nvc0_software_mthd_vblsem_offset },
-	{ 0x0408, 0x0408, nvc0_software_mthd_vblsem_value },
-	{ 0x040c, 0x040c, nvc0_software_mthd_vblsem_release },
-	{ 0x0500, 0x0500, nvc0_software_mthd_flip },
+	{ 0x0408, 0x0408, nv50_software_mthd_vblsem_value },
+	{ 0x040c, 0x040c, nv50_software_mthd_vblsem_release },
+	{ 0x0500, 0x0500, nv50_software_mthd_flip },
 	{ 0x0600, 0x0600, nvc0_software_mthd_mp_control },
 	{ 0x0644, 0x0644, nvc0_software_mthd_mp_control },
 	{ 0x06ac, 0x06ac, nvc0_software_mthd_mp_control },
@@ -138,10 +104,9 @@ nvc0_software_sclass[] = {
  ******************************************************************************/
 
 static int
-nvc0_software_vblsem_release(struct nouveau_eventh *event, int head)
+nvc0_software_vblsem_release(void *data, int head)
 {
-	struct nv50_software_chan *chan =
-		container_of(event, typeof(*chan), vblank.event);
+	struct nv50_software_chan *chan = data;
 	struct nv50_software_priv *priv = (void *)nv_object(chan)->engine;
 	struct nouveau_bar *bar = nouveau_bar(priv);
 
diff --git a/drivers/gpu/drm/nouveau/core/include/core/event.h b/drivers/gpu/drm/nouveau/core/include/core/event.h
index cb2f632cb3a5..b649c75d7198 100644
--- a/drivers/gpu/drm/nouveau/core/include/core/event.h
+++ b/drivers/gpu/drm/nouveau/core/include/core/event.h
@@ -9,10 +9,12 @@
 #define NVKM_EVENT_ENABLE 0
 
 struct nouveau_eventh {
+	struct nouveau_event *event;
 	struct list_head head;
 	unsigned long flags;
+	int index;
+	int (*func)(void *, int);
 	void *priv;
-	int (*func)(struct nouveau_eventh *, int index);
 };
 
 struct nouveau_event {
@@ -33,9 +35,11 @@ int  nouveau_event_create(int index_nr, struct nouveau_event **);
 void nouveau_event_destroy(struct nouveau_event **);
 void nouveau_event_trigger(struct nouveau_event *, int index);
 
-void nouveau_event_get(struct nouveau_event *, int index,
-		       struct nouveau_eventh *);
-void nouveau_event_put(struct nouveau_event *, int index,
-		       struct nouveau_eventh *);
+int  nouveau_event_new(struct nouveau_event *, int index,
+		       int (*func)(void *, int), void *,
+		       struct nouveau_eventh **);
+void nouveau_event_ref(struct nouveau_eventh *, struct nouveau_eventh **);
+void nouveau_event_get(struct nouveau_eventh *);
+void nouveau_event_put(struct nouveau_eventh *);
 
 #endif
diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.c b/drivers/gpu/drm/nouveau/nouveau_connector.c
index 4da776f344d7..854076faf70e 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.c
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.c
@@ -98,6 +98,7 @@ static void
 nouveau_connector_destroy(struct drm_connector *connector)
 {
 	struct nouveau_connector *nv_connector = nouveau_connector(connector);
+	nouveau_event_ref(NULL, &nv_connector->hpd_func);
 	kfree(nv_connector->edid);
 	drm_sysfs_connector_remove(connector);
 	drm_connector_cleanup(connector);
@@ -915,10 +916,9 @@ nouveau_connector_hotplug_work(struct work_struct *work)
 }
 
 static int
-nouveau_connector_hotplug(struct nouveau_eventh *event, int index)
+nouveau_connector_hotplug(void *data, int index)
 {
-	struct nouveau_connector *nv_connector =
-		container_of(event, struct nouveau_connector, hpd_func);
+	struct nouveau_connector *nv_connector = data;
 	schedule_work(&nv_connector->hpd_work);
 	return NVKM_EVENT_KEEP;
 }
@@ -990,10 +990,16 @@ nouveau_connector_create(struct drm_device *dev, int index)
 
 		ret = gpio->find(gpio, 0, hpd[ffs((entry & 0x07033000) >> 12)],
 				 DCB_GPIO_UNUSED, &nv_connector->hpd);
-		nv_connector->hpd_func.func = nouveau_connector_hotplug;
 		if (ret)
 			nv_connector->hpd.func = DCB_GPIO_UNUSED;
 
+		if (nv_connector->hpd.func != DCB_GPIO_UNUSED) {
+			nouveau_event_new(gpio->events, nv_connector->hpd.line,
+					  nouveau_connector_hotplug,
+					  nv_connector,
+					 &nv_connector->hpd_func);
+		}
+
 		nv_connector->type = nv_connector->dcb[0];
 		if (drm_conntype_from_dcb(nv_connector->type) ==
 					  DRM_MODE_CONNECTOR_Unknown) {
diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 6e399aad491a..27c2be68810e 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -69,7 +69,7 @@ struct nouveau_connector {
 
 	struct dcb_gpio_func hpd;
 	struct work_struct hpd_work;
-	struct nouveau_eventh hpd_func;
+	struct nouveau_eventh *hpd_func;
 
 	int dithering_mode;
 	int dithering_depth;
* Unmerged path drivers/gpu/drm/nouveau/nouveau_display.c
diff --git a/drivers/gpu/drm/nouveau/nouveau_display.h b/drivers/gpu/drm/nouveau/nouveau_display.h
index 1ea3e4734b62..0a46f6b9e454 100644
--- a/drivers/gpu/drm/nouveau/nouveau_display.h
+++ b/drivers/gpu/drm/nouveau/nouveau_display.h
@@ -36,6 +36,8 @@ struct nouveau_display {
 	int  (*init)(struct drm_device *);
 	void (*fini)(struct drm_device *);
 
+	struct nouveau_eventh **vblank;
+
 	struct drm_property *dithering_mode;
 	struct drm_property *dithering_depth;
 	struct drm_property *underscan_property;
@@ -58,6 +60,8 @@ int  nouveau_display_init(struct drm_device *dev);
 void nouveau_display_fini(struct drm_device *dev);
 int  nouveau_display_suspend(struct drm_device *dev);
 void nouveau_display_resume(struct drm_device *dev);
+int  nouveau_display_vblank_enable(struct drm_device *, int);
+void nouveau_display_vblank_disable(struct drm_device *, int);
 
 int  nouveau_crtc_page_flip(struct drm_crtc *crtc, struct drm_framebuffer *fb,
 			    struct drm_pending_vblank_event *event);
diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c
index 2850ed0cc755..fb458fd64ff7 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c
@@ -71,37 +71,6 @@ module_param_named(modeset, nouveau_modeset, int, 0400);
 
 static struct drm_driver driver;
 
-static int
-nouveau_drm_vblank_handler(struct nouveau_eventh *event, int head)
-{
-	struct nouveau_drm *drm =
-		container_of(event, struct nouveau_drm, vblank[head]);
-	drm_handle_vblank(drm->dev, head);
-	return NVKM_EVENT_KEEP;
-}
-
-static int
-nouveau_drm_vblank_enable(struct drm_device *dev, int head)
-{
-	struct nouveau_drm *drm = nouveau_drm(dev);
-	struct nouveau_disp *pdisp = nouveau_disp(drm->device);
-
-	if (WARN_ON_ONCE(head >= ARRAY_SIZE(drm->vblank)))
-		return -EIO;
-	drm->vblank[head].func = nouveau_drm_vblank_handler;
-	nouveau_event_get(pdisp->vblank, head, &drm->vblank[head]);
-	return 0;
-}
-
-static void
-nouveau_drm_vblank_disable(struct drm_device *dev, int head)
-{
-	struct nouveau_drm *drm = nouveau_drm(dev);
-	struct nouveau_disp *pdisp = nouveau_disp(drm->device);
-
-	nouveau_event_put(pdisp->vblank, head, &drm->vblank[head]);
-}
-
 static u64
 nouveau_name(struct pci_dev *pdev)
 {
@@ -687,8 +656,8 @@ driver = {
 #endif
 
 	.get_vblank_counter = drm_vblank_count,
-	.enable_vblank = nouveau_drm_vblank_enable,
-	.disable_vblank = nouveau_drm_vblank_disable,
+	.enable_vblank = nouveau_display_vblank_enable,
+	.disable_vblank = nouveau_display_vblank_disable,
 
 	.ioctls = nouveau_ioctls,
 	.fops = &nouveau_driver_fops,
diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.h b/drivers/gpu/drm/nouveau/nouveau_drm.h
index f2b30f89dee0..df31f71733c8 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drm.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drm.h
@@ -124,7 +124,6 @@ struct nouveau_drm {
 	struct nvbios vbios;
 	struct nouveau_display *display;
 	struct backlight_device *backlight;
-	struct nouveau_eventh vblank[4];
 
 	/* power management */
 	struct nouveau_pm *pm;
diff --git a/drivers/gpu/drm/nouveau/nouveau_fence.c b/drivers/gpu/drm/nouveau/nouveau_fence.c
index d7d4a9a45d4b..cd87ae9fe19f 100644
--- a/drivers/gpu/drm/nouveau/nouveau_fence.c
+++ b/drivers/gpu/drm/nouveau/nouveau_fence.c
@@ -104,9 +104,9 @@ nouveau_fence_done(struct nouveau_fence *fence)
 }
 
 static int
-nouveau_fence_wait_uevent_handler(struct nouveau_eventh *handler, int index)
+nouveau_fence_wait_uevent_handler(void *data, int index)
 {
-	struct nouveau_fence_priv *priv = handler->priv;
+	struct nouveau_fence_priv *priv = data;
 	wake_up_all(&priv->waiting);
 	return NVKM_EVENT_KEEP;
 }
@@ -118,13 +118,16 @@ nouveau_fence_wait_uevent(struct nouveau_fence *fence, bool intr)
 	struct nouveau_channel *chan = fence->channel;
 	struct nouveau_fifo *pfifo = nouveau_fifo(chan->drm->device);
 	struct nouveau_fence_priv *priv = chan->drm->fence;
-	struct nouveau_eventh handler = {
-		.func = nouveau_fence_wait_uevent_handler,
-		.priv = priv,
-	};
+	struct nouveau_eventh *handler;
 	int ret = 0;
 
-	nouveau_event_get(pfifo->uevent, 0, &handler);
+	ret = nouveau_event_new(pfifo->uevent, 0,
+				nouveau_fence_wait_uevent_handler,
+				priv, &handler);
+	if (ret)
+		return ret;
+
+	nouveau_event_get(handler);
 
 	if (fence->timeout) {
 		unsigned long timeout = fence->timeout - jiffies;
@@ -156,7 +159,7 @@ nouveau_fence_wait_uevent(struct nouveau_fence *fence, bool intr)
 		}
 	}
 
-	nouveau_event_put(pfifo->uevent, 0, &handler);
+	nouveau_event_ref(NULL, &handler);
 	if (unlikely(ret < 0))
 		return ret;
 
