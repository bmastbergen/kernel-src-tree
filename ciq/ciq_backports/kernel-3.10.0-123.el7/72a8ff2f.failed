ipc: change kern_ipc_perm.deleted type to bool

jira LE-1907
cve CVE-2013-7026
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [ipc] change kern_ipc_perm.deleted type to bool (Phillip Lougher) [1043807] {CVE-2013-7026}
Rebuild_FUZZ: 94.25%
commit-author Rafael Aquini <aquini@redhat.com>
commit 72a8ff2f9245128c254387c58f948f1f0152ea46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/72a8ff2f.failed

struct kern_ipc_perm.deleted is meant to be used as a boolean toggle, and
the changes introduced by this patch are just to make the case explicit.

	Signed-off-by: Rafael Aquini <aquini@redhat.com>
	Reviewed-by: Rik van Riel <riel@redhat.com>
	Cc: Greg Thelen <gthelen@google.com>
	Acked-by: Davidlohr Bueso <davidlohr@hp.com>
	Cc: Manfred Spraul <manfred@colorfullife.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 72a8ff2f9245128c254387c58f948f1f0152ea46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	ipc/util.h
diff --cc ipc/util.h
index 2b0bdd5d92ce,a1cbc3aaf25a..000000000000
--- a/ipc/util.h
+++ b/ipc/util.h
@@@ -176,7 -169,35 +176,39 @@@ static inline void ipc_lock_object(stru
  	spin_lock(&perm->lock);
  }
  
++<<<<<<< HEAD
 +struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
++=======
+ static inline void ipc_unlock_object(struct kern_ipc_perm *perm)
+ {
+ 	spin_unlock(&perm->lock);
+ }
+ 
+ static inline void ipc_assert_locked_object(struct kern_ipc_perm *perm)
+ {
+ 	assert_spin_locked(&perm->lock);
+ }
+ 
+ static inline void ipc_unlock(struct kern_ipc_perm *perm)
+ {
+ 	ipc_unlock_object(perm);
+ 	rcu_read_unlock();
+ }
+ 
+ /*
+  * ipc_valid_object() - helper to sort out IPC_RMID races for codepaths
+  * where the respective ipc_ids.rwsem is not being held down.
+  * Checks whether the ipc object is still around or if it's gone already, as
+  * ipc_rmid() may have already freed the ID while the ipc lock was spinning.
+  * Needs to be called with kern_ipc_perm.lock held -- exception made for one
+  * checkpoint case at sys_semtimedop() as noted in code commentary.
+  */
+ static inline bool ipc_valid_object(struct kern_ipc_perm *perm)
+ {
+ 	return !perm->deleted;
+ }
+ 
++>>>>>>> 72a8ff2f9245 (ipc: change kern_ipc_perm.deleted type to bool)
  struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);
  int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
  			struct ipc_ops *ops, struct ipc_params *params);
diff --git a/include/linux/ipc.h b/include/linux/ipc.h
index 8d861b2651f7..9d84942ae2e5 100644
--- a/include/linux/ipc.h
+++ b/include/linux/ipc.h
@@ -11,7 +11,7 @@
 struct kern_ipc_perm
 {
 	spinlock_t	lock;
-	int		deleted;
+	bool		deleted;
 	int		id;
 	key_t		key;
 	kuid_t		uid;
diff --git a/ipc/sem.c b/ipc/sem.c
index 6230dd5963de..9bfdc50a68f0 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -294,7 +294,7 @@ static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns,
 	/* ipc_rmid() may have already freed the ID while sem_lock
 	 * was spinning: verify that the structure is still valid
 	 */
-	if (!ipcp->deleted)
+	if (ipc_valid_object(ipcp))
 		return container_of(ipcp, struct sem_array, sem_perm);
 
 	sem_unlock(sma, *locknum);
diff --git a/ipc/util.c b/ipc/util.c
index 809ec5ec8122..b6ab37019235 100644
--- a/ipc/util.c
+++ b/ipc/util.c
@@ -265,7 +265,7 @@ int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)
 	idr_preload(GFP_KERNEL);
 
 	spin_lock_init(&new->lock);
-	new->deleted = 0;
+	new->deleted = false;
 	rcu_read_lock();
 	spin_lock(&new->lock);
 
@@ -426,7 +426,7 @@ void ipc_rmid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp)
 
 	ids->in_use--;
 
-	ipcp->deleted = 1;
+	ipcp->deleted = true;
 
 	return;
 }
@@ -644,7 +644,7 @@ struct kern_ipc_perm *ipc_lock(struct ipc_ids *ids, int id)
 	/* ipc_rmid() may have already freed the ID while ipc_lock
 	 * was spinning: here verify that the structure is still valid
 	 */
-	if (!out->deleted)
+	if (ipc_valid_object(out))
 		return out;
 
 	spin_unlock(&out->lock);
* Unmerged path ipc/util.h
