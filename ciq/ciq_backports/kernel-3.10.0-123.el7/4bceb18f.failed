xfs: vectorise DA btree operations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dave Chinner <david@fromorbit.com>
commit 4bceb18f1551c8c047eeb54d48cda9f5453dc12f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/4bceb18f.failed

The remaining non-vectorised code for the directory structure is the
node format blocks. This is shared with the attribute tree, and so
is slightly more complex to vectorise.

Introduce a "non-directory" directory ops structure that is attached
to all non-directory inodes so that attribute operations can be
vectorised for all inodes.

Once we do this, we can vectorise all the da btree operations.
Because this patch adds more infrastructure than it removes the
binary size does not decrease:

   text    data     bss     dec     hex filename
 794490   96802    1096  892388   d9de4 fs/xfs/xfs.o.orig
 792986   96802    1096  890884   d9804 fs/xfs/xfs.o.p1
 792350   96802    1096  890248   d9588 fs/xfs/xfs.o.p2
 789293   96802    1096  887191   d8997 fs/xfs/xfs.o.p3
 789005   96802    1096  886903   d8997 fs/xfs/xfs.o.p4
 789061   96802    1096  886959   d88af fs/xfs/xfs.o.p5
 789733   96802    1096  887631   d8b4f fs/xfs/xfs.o.p6

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Ben Myers <bpm@sgi.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 4bceb18f1551c8c047eeb54d48cda9f5453dc12f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_attr_inactive.c
#	fs/xfs/xfs_attr_leaf.c
#	fs/xfs/xfs_attr_list.c
#	fs/xfs/xfs_da_btree.c
#	fs/xfs/xfs_da_format.c
#	fs/xfs/xfs_dir2.c
#	fs/xfs/xfs_dir2.h
#	fs/xfs/xfs_dir2_format.h
#	fs/xfs/xfs_mount.h
diff --cc fs/xfs/xfs_attr_inactive.c
index 9a4e42599cd7,4855085f8c6b..000000000000
--- a/fs/xfs/xfs_attr_inactive.c
+++ b/fs/xfs/xfs_attr_inactive.c
@@@ -42,7 -39,8 +42,12 @@@
  #include "xfs_error.h"
  #include "xfs_quota.h"
  #include "xfs_trace.h"
++<<<<<<< HEAD
 +#include "xfs_trans_priv.h"
++=======
+ #include "xfs_dinode.h"
+ #include "xfs_dir2.h"
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
  
  /*
   * Look at all the extents for this logical region,
diff --cc fs/xfs/xfs_attr_leaf.c
index 86db20a9cc02,82f1354c77b6..000000000000
--- a/fs/xfs/xfs_attr_leaf.c
+++ b/fs/xfs/xfs_attr_leaf.c
@@@ -44,6 -40,8 +44,11 @@@
  #include "xfs_trace.h"
  #include "xfs_buf_item.h"
  #include "xfs_cksum.h"
++<<<<<<< HEAD
++=======
+ #include "xfs_dinode.h"
+ #include "xfs_dir2.h"
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
  
  
  /*
diff --cc fs/xfs/xfs_attr_list.c
index cbc80d485177,ea1c4c46c24f..000000000000
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@@ -43,6 -39,8 +43,11 @@@
  #include "xfs_trace.h"
  #include "xfs_buf_item.h"
  #include "xfs_cksum.h"
++<<<<<<< HEAD
++=======
+ #include "xfs_dinode.h"
+ #include "xfs_dir2.h"
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
  
  STATIC int
  xfs_attr_shortform_compare(const void *a, const void *b)
diff --cc fs/xfs/xfs_da_btree.c
index 6a2a7bb089e3,26dfc42a28f9..000000000000
--- a/fs/xfs/xfs_da_btree.c
+++ b/fs/xfs/xfs_da_btree.c
@@@ -1319,7 -1324,7 +1324,11 @@@ xfs_da3_fixhashpath
  			return;
  		break;
  	case XFS_DIR2_LEAFN_MAGIC:
++<<<<<<< HEAD
 +		lasthash = xfs_dir2_leafn_lasthash(blk->bp, &count);
++=======
+ 		lasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
  		if (count == 0)
  			return;
  		break;
@@@ -1702,10 -1713,10 +1716,14 @@@ xfs_da3_blk_link
  		before = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);
  		break;
  	case XFS_DIR2_LEAFN_MAGIC:
++<<<<<<< HEAD
 +		before = xfs_dir2_leafn_order(old_blk->bp, new_blk->bp);
++=======
+ 		before = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
  		break;
  	case XFS_DA_NODE_MAGIC:
- 		before = xfs_da3_node_order(old_blk->bp, new_blk->bp);
+ 		before = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);
  		break;
  	}
  
@@@ -2223,7 -2234,7 +2242,11 @@@ xfs_da3_swap_lastblock
  
  		dead_leaf2 = (xfs_dir2_leaf_t *)dead_info;
  		xfs_dir3_leaf_hdr_from_disk(&leafhdr, dead_leaf2);
++<<<<<<< HEAD
 +		ents = xfs_dir3_leaf_ents_p(dead_leaf2);
++=======
+ 		ents = dp->d_ops->leaf_ents_p(dead_leaf2);
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
  		dead_level = 0;
  		dead_hash = be32_to_cpu(ents[leafhdr.count - 1].hashval);
  	} else {
diff --cc fs/xfs/xfs_dir2.c
index ade24b4a3e65,1b44e83924b7..000000000000
--- a/fs/xfs/xfs_dir2.c
+++ b/fs/xfs/xfs_dir2.c
@@@ -113,6 -116,7 +117,10 @@@ xfs_dir_mount
  		mp->m_dirnameops = &xfs_ascii_ci_nameops;
  	else
  		mp->m_dirnameops = &xfs_default_nameops;
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
  }
  
  /*
diff --cc fs/xfs/xfs_dir2.h
index e937d9991c18,c5cad9d9239d..000000000000
--- a/fs/xfs/xfs_dir2.h
+++ b/fs/xfs/xfs_dir2.h
@@@ -27,6 -32,65 +27,68 @@@ struct xfs_trans
  extern struct xfs_name	xfs_name_dotdot;
  
  /*
++<<<<<<< HEAD
++=======
+  * directory operations vector for encode/decode routines
+  */
+ struct xfs_dir_ops {
+ 	int	(*sf_entsize)(struct xfs_dir2_sf_hdr *hdr, int len);
+ 	struct xfs_dir2_sf_entry *
+ 		(*sf_nextentry)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	__uint8_t (*sf_get_ftype)(struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ftype)(struct xfs_dir2_sf_entry *sfep,
+ 				__uint8_t ftype);
+ 	xfs_ino_t (*sf_get_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 			      struct xfs_dir2_sf_entry *sfep,
+ 			      xfs_ino_t ino);
+ 	xfs_ino_t (*sf_get_parent_ino)(struct xfs_dir2_sf_hdr *hdr);
+ 	void	(*sf_put_parent_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				     xfs_ino_t ino);
+ 
+ 	int	(*data_entsize)(int len);
+ 	__uint8_t (*data_get_ftype)(struct xfs_dir2_data_entry *dep);
+ 	void	(*data_put_ftype)(struct xfs_dir2_data_entry *dep,
+ 				__uint8_t ftype);
+ 	__be16 * (*data_entry_tag_p)(struct xfs_dir2_data_entry *dep);
+ 	struct xfs_dir2_data_free *
+ 		(*data_bestfree_p)(struct xfs_dir2_data_hdr *hdr);
+ 
+ 	xfs_dir2_data_aoff_t (*data_dot_offset)(void);
+ 	xfs_dir2_data_aoff_t (*data_dotdot_offset)(void);
+ 	xfs_dir2_data_aoff_t (*data_first_offset)(void);
+ 	size_t	(*data_entry_offset)(void);
+ 
+ 	struct xfs_dir2_data_entry *
+ 		(*data_dot_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_dotdot_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_first_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_unused *
+ 		(*data_unused_p)(struct xfs_dir2_data_hdr *hdr);
+ 
+ 	int	(*leaf_hdr_size)(void);
+ 	int	(*leaf_max_ents)(struct xfs_mount *mp);
+ 	struct xfs_dir2_leaf_entry *
+ 		(*leaf_ents_p)(struct xfs_dir2_leaf *lp);
+ 
+ 	int	(*node_hdr_size)(void);
+ 	struct xfs_da_node_entry *
+ 		(*node_tree_p)(struct xfs_da_intnode *dap);
+ };
+ 
+ extern const struct xfs_dir_ops *
+ 	xfs_dir_get_ops(struct xfs_mount *mp, struct xfs_inode *dp);
+ extern const struct xfs_dir_ops *
+ 	xfs_nondir_get_ops(struct xfs_mount *mp, struct xfs_inode *dp);
+ 
+ /*
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
   * Generic directory interface routines
   */
  extern void xfs_dir_startup(void);
diff --cc fs/xfs/xfs_dir2_format.h
index 2095e17b75cb,69b4c6e1c52e..000000000000
--- a/fs/xfs/xfs_dir2_format.h
+++ b/fs/xfs/xfs_dir2_format.h
@@@ -16,8 -16,123 +16,128 @@@
   * along with this program; if not, write the Free Software Foundation,
   * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   */
++<<<<<<< HEAD:fs/xfs/xfs_dir2_format.h
 +#ifndef __XFS_DIR2_FORMAT_H__
 +#define __XFS_DIR2_FORMAT_H__
++=======
+ #ifndef __XFS_DA_FORMAT_H__
+ #define __XFS_DA_FORMAT_H__
+ 
+ /*========================================================================
+  * Directory Structure when greater than XFS_LBSIZE(mp) bytes.
+  *========================================================================*/
+ 
+ /*
+  * This structure is common to both leaf nodes and non-leaf nodes in the Btree.
+  *
+  * It is used to manage a doubly linked list of all blocks at the same
+  * level in the Btree, and to identify which type of block this is.
+  */
+ #define XFS_DA_NODE_MAGIC	0xfebe	/* magic number: non-leaf blocks */
+ #define XFS_ATTR_LEAF_MAGIC	0xfbee	/* magic number: attribute leaf blks */
+ #define	XFS_DIR2_LEAF1_MAGIC	0xd2f1	/* magic number: v2 dirlf single blks */
+ #define	XFS_DIR2_LEAFN_MAGIC	0xd2ff	/* magic number: v2 dirlf multi blks */
+ 
+ typedef struct xfs_da_blkinfo {
+ 	__be32		forw;			/* previous block in list */
+ 	__be32		back;			/* following block in list */
+ 	__be16		magic;			/* validity check on block */
+ 	__be16		pad;			/* unused */
+ } xfs_da_blkinfo_t;
+ 
+ /*
+  * CRC enabled directory structure types
+  *
+  * The headers change size for the additional verification information, but
+  * otherwise the tree layouts and contents are unchanged. Hence the da btree
+  * code can use the struct xfs_da_blkinfo for manipulating the tree links and
+  * magic numbers without modification for both v2 and v3 nodes.
+  */
+ #define XFS_DA3_NODE_MAGIC	0x3ebe	/* magic number: non-leaf blocks */
+ #define XFS_ATTR3_LEAF_MAGIC	0x3bee	/* magic number: attribute leaf blks */
+ #define	XFS_DIR3_LEAF1_MAGIC	0x3df1	/* magic number: v2 dirlf single blks */
+ #define	XFS_DIR3_LEAFN_MAGIC	0x3dff	/* magic number: v2 dirlf multi blks */
+ 
+ struct xfs_da3_blkinfo {
+ 	/*
+ 	 * the node link manipulation code relies on the fact that the first
+ 	 * element of this structure is the struct xfs_da_blkinfo so it can
+ 	 * ignore the differences in the rest of the structures.
+ 	 */
+ 	struct xfs_da_blkinfo	hdr;
+ 	__be32			crc;	/* CRC of block */
+ 	__be64			blkno;	/* first block of the buffer */
+ 	__be64			lsn;	/* sequence number of last write */
+ 	uuid_t			uuid;	/* filesystem we belong to */
+ 	__be64			owner;	/* inode that owns the block */
+ };
+ 
+ /*
+  * This is the structure of the root and intermediate nodes in the Btree.
+  * The leaf nodes are defined above.
+  *
+  * Entries are not packed.
+  *
+  * Since we have duplicate keys, use a binary search but always follow
+  * all match in the block, not just the first match found.
+  */
+ #define	XFS_DA_NODE_MAXDEPTH	5	/* max depth of Btree */
+ 
+ typedef struct xfs_da_node_hdr {
+ 	struct xfs_da_blkinfo	info;	/* block type, links, etc. */
+ 	__be16			__count; /* count of active entries */
+ 	__be16			__level; /* level above leaves (leaf == 0) */
+ } xfs_da_node_hdr_t;
+ 
+ struct xfs_da3_node_hdr {
+ 	struct xfs_da3_blkinfo	info;	/* block type, links, etc. */
+ 	__be16			__count; /* count of active entries */
+ 	__be16			__level; /* level above leaves (leaf == 0) */
+ 	__be32			__pad32;
+ };
+ 
+ #define XFS_DA3_NODE_CRC_OFF	(offsetof(struct xfs_da3_node_hdr, info.crc))
+ 
+ typedef struct xfs_da_node_entry {
+ 	__be32	hashval;	/* hash value for this descendant */
+ 	__be32	before;		/* Btree block before this key */
+ } xfs_da_node_entry_t;
+ 
+ typedef struct xfs_da_intnode {
+ 	struct xfs_da_node_hdr	hdr;
+ 	struct xfs_da_node_entry __btree[];
+ } xfs_da_intnode_t;
+ 
+ struct xfs_da3_intnode {
+ 	struct xfs_da3_node_hdr	hdr;
+ 	struct xfs_da_node_entry __btree[];
+ };
+ 
+ /*
+  * In-core version of the node header to abstract the differences in the v2 and
+  * v3 disk format of the headers. Callers need to convert to/from disk format as
+  * appropriate.
+  */
+ struct xfs_da3_icnode_hdr {
+ 	__uint32_t	forw;
+ 	__uint32_t	back;
+ 	__uint16_t	magic;
+ 	__uint16_t	count;
+ 	__uint16_t	level;
+ };
+ 
+ extern void xfs_da3_node_hdr_from_disk(struct xfs_da3_icnode_hdr *to,
+ 				       struct xfs_da_intnode *from);
+ extern void xfs_da3_node_hdr_to_disk(struct xfs_da_intnode *to,
+ 				     struct xfs_da3_icnode_hdr *from);
+ 
+ extern void xfs_da3_intnode_from_disk(struct xfs_da3_icnode_hdr *to,
+ 				      struct xfs_da_intnode *from);
+ extern void xfs_da3_intnode_to_disk(struct xfs_da_intnode *to,
+ 				    struct xfs_da3_icnode_hdr *from);
+ 
+ #define	XFS_LBSIZE(mp)	(mp)->m_sb.sb_blocksize
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations):fs/xfs/xfs_da_format.h
  
  /*
   * Directory version 2.
diff --cc fs/xfs/xfs_mount.h
index 53dc3341b959,1d8101a10d8e..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -148,6 -149,8 +148,11 @@@ typedef struct xfs_mount 
  	int			m_dir_magicpct;	/* 37% of the dir blocksize */
  	__uint8_t		m_sectbb_log;	/* sectlog - BBSHIFT */
  	const struct xfs_nameops *m_dirnameops;	/* vector of dir name ops */
++<<<<<<< HEAD
++=======
+ 	const struct xfs_dir_ops *m_dir_inode_ops; /* vector of dir inode ops */
+ 	const struct xfs_dir_ops *m_nondir_inode_ops; /* !dir inode ops */
++>>>>>>> 4bceb18f1551 (xfs: vectorise DA btree operations)
  	int			m_dirblksize;	/* directory block sz--bytes */
  	int			m_dirblkfsbs;	/* directory block sz--fsbs */
  	xfs_dablk_t		m_dirdatablk;	/* blockno of dir data v2 */
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_attr_inactive.c
* Unmerged path fs/xfs/xfs_attr_leaf.c
* Unmerged path fs/xfs/xfs_attr_list.c
* Unmerged path fs/xfs/xfs_da_btree.c
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_dir2.c
* Unmerged path fs/xfs/xfs_dir2.h
* Unmerged path fs/xfs/xfs_dir2_format.h
diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c
index 39cd46efea14..a4b8ec744d65 100644
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@ -1201,6 +1201,7 @@ xfs_setup_inode(
 	inode->i_ctime.tv_nsec	= ip->i_d.di_ctime.t_nsec;
 	xfs_diflags_to_iflags(inode, ip);
 
+	ip->d_ops = ip->i_mount->m_nondir_inode_ops;
 	switch (inode->i_mode & S_IFMT) {
 	case S_IFREG:
 		inode->i_op = &xfs_inode_operations;
* Unmerged path fs/xfs/xfs_mount.h
