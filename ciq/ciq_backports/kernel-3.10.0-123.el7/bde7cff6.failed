xfs: format log items write directly into the linear CIL buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Christoph Hellwig <hch@infradead.org>
commit bde7cff67c39227c6ad503394e19e58debdbc5e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/bde7cff6.failed

Instead of setting up pointers to memory locations in iop_format which then
get copied into the CIL linear buffer after return move the copy into
the individual inode items.  This avoids the need to always have a memory
block in the exact same layout that gets written into the log around, and
allow the log items to be much more flexible in their in-memory layouts.

The only caveat is that we need to properly align the data for each
iovec so that don't have structures misaligned in subsequent iovecs.

Note that all log item format routines now need to be careful to modify
the copy of the item that was placed into the CIL after calls to
xlog_copy_iovec instead of the in-memory copy.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit bde7cff67c39227c6ad503394e19e58debdbc5e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_buf_item.c
#	fs/xfs/xfs_dquot_item.c
#	fs/xfs/xfs_extfree_item.c
#	fs/xfs/xfs_icreate_item.c
#	fs/xfs/xfs_inode_item.c
#	fs/xfs/xfs_log.h
diff --cc fs/xfs/xfs_buf_item.c
index 0b8551a96aee,764117305438..000000000000
--- a/fs/xfs/xfs_buf_item.c
+++ b/fs/xfs/xfs_buf_item.c
@@@ -181,20 -182,19 +181,31 @@@ xfs_buf_item_size
  	trace_xfs_buf_item_size(bip);
  }
  
 -static inline void
 +static inline struct xfs_log_iovec *
  xfs_buf_item_copy_iovec(
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*vecp,
++=======
+ 	struct xfs_log_vec	*lv,
+ 	struct xfs_log_iovec	**vecp,
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  	struct xfs_buf		*bp,
  	uint			offset,
  	int			first_bit,
  	uint			nbits)
  {
  	offset += first_bit * XFS_BLF_CHUNK;
++<<<<<<< HEAD
 +
 +	vecp->i_type = XLOG_REG_TYPE_BCHUNK;
 +	vecp->i_addr = xfs_buf_offset(bp, offset);
 +	vecp->i_len = nbits * XFS_BLF_CHUNK;
 +	return vecp + 1;
++=======
+ 	xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BCHUNK,
+ 			xfs_buf_offset(bp, offset),
+ 			nbits * XFS_BLF_CHUNK);
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  }
  
  static inline bool
@@@ -209,10 -209,11 +220,15 @@@ xfs_buf_item_straddle
  		 XFS_BLF_CHUNK);
  }
  
 -static void
 +static struct xfs_log_iovec *
  xfs_buf_item_format_segment(
  	struct xfs_buf_log_item	*bip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*vecp,
++=======
+ 	struct xfs_log_vec	*lv,
+ 	struct xfs_log_iovec	**vecp,
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  	uint			offset,
  	struct xfs_buf_log_format *blfp)
  {
@@@ -241,14 -240,11 +255,19 @@@
  		 * If the map is not be dirty in the transaction, mark
  		 * the size as zero and do not advance the vector pointer.
  		 */
- 		goto out;
+ 		return;
  	}
  
++<<<<<<< HEAD
 +	vecp->i_addr = blfp;
 +	vecp->i_len = base_size;
 +	vecp->i_type = XLOG_REG_TYPE_BFORMAT;
 +	vecp++;
 +	nvecs = 1;
++=======
+ 	blfp = xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_BFORMAT, blfp, base_size);
+ 	blfp->blf_size = 1;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  
  	if (bip->bli_flags & XFS_BLI_STALE) {
  		/*
@@@ -290,9 -286,9 +309,15 @@@
  			break;
  		} else if (next_bit != last_bit + 1 ||
  		           xfs_buf_item_straddle(bp, offset, next_bit, last_bit)) {
++<<<<<<< HEAD
 +			vecp = xfs_buf_item_copy_iovec(vecp, bp, offset,
 +						       first_bit, nbits);
 +			nvecs++;
++=======
+ 			xfs_buf_item_copy_iovec(lv, vecp, bp, offset,
+ 						first_bit, nbits);
+ 			blfp->blf_size++;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  			first_bit = next_bit;
  			last_bit = next_bit;
  			nbits = 1;
@@@ -301,9 -297,6 +326,12 @@@
  			nbits++;
  		}
  	}
++<<<<<<< HEAD
 +out:
 +	blfp->blf_size = nvecs;
 +	return vecp;
++=======
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  }
  
  /*
@@@ -359,8 -353,8 +388,13 @@@ xfs_buf_item_format
  	}
  
  	for (i = 0; i < bip->bli_format_count; i++) {
++<<<<<<< HEAD
 +		vecp = xfs_buf_item_format_segment(bip, vecp, offset,
 +						&bip->bli_formats[i]);
++=======
+ 		xfs_buf_item_format_segment(bip, lv, &vecp, offset,
+ 					    &bip->bli_formats[i]);
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  		offset += bp->b_maps[i].bm_len;
  	}
  
diff --cc fs/xfs/xfs_dquot_item.c
index e838d84b4e85,946d588070b0..000000000000
--- a/fs/xfs/xfs_dquot_item.c
+++ b/fs/xfs/xfs_dquot_item.c
@@@ -61,20 -57,19 +61,36 @@@ xfs_qm_dquot_logitem_size
  STATIC void
  xfs_qm_dquot_logitem_format(
  	struct xfs_log_item	*lip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*logvec)
 +{
 +	struct xfs_dq_logitem	*qlip = DQUOT_ITEM(lip);
 +
 +	logvec->i_addr = &qlip->qli_format;
 +	logvec->i_len  = sizeof(xfs_dq_logformat_t);
 +	logvec->i_type = XLOG_REG_TYPE_QFORMAT;
 +	logvec++;
 +	logvec->i_addr = &qlip->qli_dquot->q_core;
 +	logvec->i_len  = sizeof(xfs_disk_dquot_t);
 +	logvec->i_type = XLOG_REG_TYPE_DQUOT;
 +
 +	qlip->qli_format.qlf_size = 2;
 +
++=======
+ 	struct xfs_log_vec	*lv)
+ {
+ 	struct xfs_dq_logitem	*qlip = DQUOT_ITEM(lip);
+ 	struct xfs_log_iovec	*vecp = NULL;
+ 
+ 	qlip->qli_format.qlf_size = 2;
+ 
+ 	xlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_QFORMAT,
+ 			&qlip->qli_format,
+ 			sizeof(struct xfs_dq_logformat));
+ 	xlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_DQUOT,
+ 			&qlip->qli_dquot->q_core,
+ 			sizeof(struct xfs_disk_dquot));
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  }
  
  /*
@@@ -308,16 -303,17 +324,28 @@@ xfs_qm_qoff_logitem_size
  STATIC void
  xfs_qm_qoff_logitem_format(
  	struct xfs_log_item	*lip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*log_vector)
++=======
+ 	struct xfs_log_vec	*lv)
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  {
  	struct xfs_qoff_logitem	*qflip = QOFF_ITEM(lip);
+ 	struct xfs_log_iovec	*vecp = NULL;
  
  	ASSERT(qflip->qql_format.qf_type == XFS_LI_QUOTAOFF);
+ 	qflip->qql_format.qf_size = 1;
  
++<<<<<<< HEAD
 +	log_vector->i_addr = &qflip->qql_format;
 +	log_vector->i_len = sizeof(xfs_qoff_logitem_t);
 +	log_vector->i_type = XLOG_REG_TYPE_QUOTAOFF;
 +	qflip->qql_format.qf_size = 1;
++=======
+ 	xlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_QUOTAOFF,
+ 			&qflip->qql_format,
+ 			sizeof(struct xfs_qoff_logitem));
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  }
  
  /*
diff --cc fs/xfs/xfs_extfree_item.c
index dc53e8febbbe,fb7a4c1ce1c5..000000000000
--- a/fs/xfs/xfs_extfree_item.c
+++ b/fs/xfs/xfs_extfree_item.c
@@@ -101,9 -102,10 +101,14 @@@ xfs_efi_item_size
  STATIC void
  xfs_efi_item_format(
  	struct xfs_log_item	*lip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*log_vector)
++=======
+ 	struct xfs_log_vec	*lv)
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  {
  	struct xfs_efi_log_item	*efip = EFI_ITEM(lip);
+ 	struct xfs_log_iovec	*vecp = NULL;
  
  	ASSERT(atomic_read(&efip->efi_next_extent) ==
  				efip->efi_format.efi_nextents);
@@@ -111,10 -113,9 +116,16 @@@
  	efip->efi_format.efi_type = XFS_LI_EFI;
  	efip->efi_format.efi_size = 1;
  
++<<<<<<< HEAD
 +	log_vector->i_addr = &efip->efi_format;
 +	log_vector->i_len = xfs_efi_item_sizeof(efip);
 +	log_vector->i_type = XLOG_REG_TYPE_EFI_FORMAT;
 +	ASSERT(log_vector->i_len >= sizeof(xfs_efi_log_format_t));
++=======
+ 	xlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_EFI_FORMAT,
+ 			&efip->efi_format,
+ 			xfs_efi_item_sizeof(efip));
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  }
  
  
@@@ -368,19 -369,19 +379,30 @@@ xfs_efd_item_size
  STATIC void
  xfs_efd_item_format(
  	struct xfs_log_item	*lip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*log_vector)
++=======
+ 	struct xfs_log_vec	*lv)
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  {
  	struct xfs_efd_log_item	*efdp = EFD_ITEM(lip);
+ 	struct xfs_log_iovec	*vecp = NULL;
  
  	ASSERT(efdp->efd_next_extent == efdp->efd_format.efd_nextents);
  
  	efdp->efd_format.efd_type = XFS_LI_EFD;
  	efdp->efd_format.efd_size = 1;
  
++<<<<<<< HEAD
 +	log_vector->i_addr = &efdp->efd_format;
 +	log_vector->i_len = xfs_efd_item_sizeof(efdp);
 +	log_vector->i_type = XLOG_REG_TYPE_EFD_FORMAT;
 +	ASSERT(log_vector->i_len >= sizeof(xfs_efd_log_format_t));
++=======
+ 	xlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_EFD_FORMAT,
+ 			&efdp->efd_format,
+ 			xfs_efd_item_sizeof(efdp));
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  }
  
  /*
diff --cc fs/xfs/xfs_icreate_item.c
index d08ed2f5644f,7e4549233251..000000000000
--- a/fs/xfs/xfs_icreate_item.c
+++ b/fs/xfs/xfs_icreate_item.c
@@@ -69,13 -59,14 +69,24 @@@ xfs_icreate_item_size
  STATIC void
  xfs_icreate_item_format(
  	struct xfs_log_item	*lip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*log_vector)
++=======
+ 	struct xfs_log_vec	*lv)
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  {
  	struct xfs_icreate_item	*icp = ICR_ITEM(lip);
+ 	struct xfs_log_iovec	*vecp = NULL;
  
++<<<<<<< HEAD
 +	log_vector->i_addr = (xfs_caddr_t)&icp->ic_format;
 +	log_vector->i_len  = sizeof(struct xfs_icreate_log);
 +	log_vector->i_type = XLOG_REG_TYPE_ICREATE;
++=======
+ 	xlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_ICREATE,
+ 			&icp->ic_format,
+ 			sizeof(struct xfs_icreate_log));
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  }
  
  
diff --cc fs/xfs/xfs_inode_item.c
index f86ec16592fa,6ab318f80c96..000000000000
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@@ -159,10 -160,11 +159,15 @@@ xfs_inode_item_size
   * here, so always use the physical fork size to determine the size of the
   * buffer we need to allocate.
   */
 -STATIC int
 +STATIC void
  xfs_inode_item_format_extents(
  	struct xfs_inode	*ip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*vecp,
++=======
+ 	struct xfs_log_vec	*lv,
+ 	struct xfs_log_iovec	**vecp,
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  	int			whichfork,
  	int			type)
  {
@@@ -174,9 -177,9 +179,15 @@@
  	else
  		ip->i_itemp->ili_aextents_buf = ext_buffer;
  
++<<<<<<< HEAD
 +	vecp->i_addr = ext_buffer;
 +	vecp->i_len = xfs_iextents_copy(ip, ext_buffer, whichfork);
 +	vecp->i_type = type;
++=======
+ 	len = xfs_iextents_copy(ip, ext_buffer, whichfork);
+ 	xlog_copy_iovec(lv, vecp, type, ext_buffer, len);
+ 	return len;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  }
  
  /*
@@@ -207,11 -210,12 +218,17 @@@ xfs_inode_item_format_v1_inode
  	}
  }
  
 -STATIC void
 +STATIC struct xfs_log_iovec *
  xfs_inode_item_format_data_fork(
  	struct xfs_inode_log_item *iip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*vecp,
 +	int			*nvecs)
++=======
+ 	struct xfs_inode_log_format *ilf,
+ 	struct xfs_log_vec	*lv,
+ 	struct xfs_log_iovec	**vecp)
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  {
  	struct xfs_inode	*ip = iip->ili_inode;
  	size_t			data_bytes;
@@@ -237,19 -241,19 +254,35 @@@
  				 * extents, so just point to the
  				 * real extents array.
  				 */
++<<<<<<< HEAD
 +				vecp->i_addr = ip->i_df.if_u1.if_extents;
 +				vecp->i_len = ip->i_df.if_bytes;
 +				vecp->i_type = XLOG_REG_TYPE_IEXT;
 +			} else
 +#endif
 +			{
 +				xfs_inode_item_format_extents(ip, vecp,
 +					XFS_DATA_FORK, XLOG_REG_TYPE_IEXT);
 +			}
 +			ASSERT(vecp->i_len <= ip->i_df.if_bytes);
 +			iip->ili_format.ilf_dsize = vecp->i_len;
 +			vecp++;
 +			(*nvecs)++;
++=======
+ 				xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IEXT,
+ 						ip->i_df.if_u1.if_extents,
+ 						ip->i_df.if_bytes);
+ 				ilf->ilf_dsize = ip->i_df.if_bytes;
+ 			} else
+ #endif
+ 			{
+ 				ilf->ilf_dsize =
+ 					xfs_inode_item_format_extents(ip, lv, vecp,
+ 						XFS_DATA_FORK, XLOG_REG_TYPE_IEXT);
+ 				ASSERT(iip->ili_format.ilf_dsize <= ip->i_df.if_bytes);
+ 			}
+ 			ilf->ilf_size++;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  		} else {
  			iip->ili_fields &= ~XFS_ILOG_DEXT;
  		}
@@@ -262,12 -266,11 +295,20 @@@
  		if ((iip->ili_fields & XFS_ILOG_DBROOT) &&
  		    ip->i_df.if_broot_bytes > 0) {
  			ASSERT(ip->i_df.if_broot != NULL);
++<<<<<<< HEAD
 +			vecp->i_addr = ip->i_df.if_broot;
 +			vecp->i_len = ip->i_df.if_broot_bytes;
 +			vecp->i_type = XLOG_REG_TYPE_IBROOT;
 +			vecp++;
 +			(*nvecs)++;
 +			iip->ili_format.ilf_dsize = ip->i_df.if_broot_bytes;
++=======
+ 			xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IBROOT,
+ 					ip->i_df.if_broot,
+ 					ip->i_df.if_broot_bytes);
+ 			ilf->ilf_dsize = ip->i_df.if_broot_bytes;
+ 			ilf->ilf_size++;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  		} else {
  			ASSERT(!(iip->ili_fields &
  				 XFS_ILOG_DBROOT));
@@@ -290,13 -289,14 +331,24 @@@
  			 * to be there by xfs_idata_realloc().
  			 */
  			data_bytes = roundup(ip->i_df.if_bytes, 4);
++<<<<<<< HEAD
 +			ASSERT((ip->i_df.if_real_bytes == 0) ||
 +			       (ip->i_df.if_real_bytes == data_bytes));
 +			vecp->i_len = (int)data_bytes;
 +			vecp->i_type = XLOG_REG_TYPE_ILOCAL;
 +			vecp++;
 +			(*nvecs)++;
 +			iip->ili_format.ilf_dsize = (unsigned)data_bytes;
++=======
+ 			ASSERT(ip->i_df.if_real_bytes == 0 ||
+ 			       ip->i_df.if_real_bytes == data_bytes);
+ 			ASSERT(ip->i_df.if_u1.if_data != NULL);
+ 			ASSERT(ip->i_d.di_size > 0);
+ 			xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_ILOCAL,
+ 					ip->i_df.if_u1.if_data, data_bytes);
+ 			ilf->ilf_dsize = (unsigned)data_bytes;
+ 			ilf->ilf_size++;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  		} else {
  			iip->ili_fields &= ~XFS_ILOG_DDATA;
  		}
@@@ -323,15 -319,14 +371,21 @@@
  		ASSERT(0);
  		break;
  	}
 +
 +	return vecp;
  }
  
 -STATIC void
 +STATIC struct xfs_log_iovec *
  xfs_inode_item_format_attr_fork(
  	struct xfs_inode_log_item *iip,
++<<<<<<< HEAD
 +	struct xfs_log_iovec	*vecp,
 +	int			*nvecs)
++=======
+ 	struct xfs_inode_log_format *ilf,
+ 	struct xfs_log_vec	*lv,
+ 	struct xfs_log_iovec	**vecp)
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  {
  	struct xfs_inode	*ip = iip->ili_inode;
  	size_t			data_bytes;
@@@ -352,17 -347,17 +406,31 @@@
  			 * There are not delayed allocation extents
  			 * for attributes, so just point at the array.
  			 */
++<<<<<<< HEAD
 +			vecp->i_addr = ip->i_afp->if_u1.if_extents;
 +			vecp->i_len = ip->i_afp->if_bytes;
 +			vecp->i_type = XLOG_REG_TYPE_IATTR_EXT;
 +#else
 +			ASSERT(iip->ili_aextents_buf == NULL);
 +			xfs_inode_item_format_extents(ip, vecp,
 +					XFS_ATTR_FORK, XLOG_REG_TYPE_IATTR_EXT);
 +#endif
 +			iip->ili_format.ilf_asize = vecp->i_len;
 +			vecp++;
 +			(*nvecs)++;
++=======
+ 			xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_EXT,
+ 					ip->i_afp->if_u1.if_extents,
+ 					ip->i_afp->if_bytes);
+ 			ilf->ilf_asize = ip->i_afp->if_bytes;
+ #else
+ 			ASSERT(iip->ili_aextents_buf == NULL);
+ 			ilf->ilf_asize =
+ 				xfs_inode_item_format_extents(ip, lv, vecp,
+ 					XFS_ATTR_FORK, XLOG_REG_TYPE_IATTR_EXT);
+ #endif
+ 			ilf->ilf_size++;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  		} else {
  			iip->ili_fields &= ~XFS_ILOG_AEXT;
  		}
@@@ -375,12 -370,11 +443,20 @@@
  		    ip->i_afp->if_broot_bytes > 0) {
  			ASSERT(ip->i_afp->if_broot != NULL);
  
++<<<<<<< HEAD
 +			vecp->i_addr = ip->i_afp->if_broot;
 +			vecp->i_len = ip->i_afp->if_broot_bytes;
 +			vecp->i_type = XLOG_REG_TYPE_IATTR_BROOT;
 +			vecp++;
 +			(*nvecs)++;
 +			iip->ili_format.ilf_asize = ip->i_afp->if_broot_bytes;
++=======
+ 			xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_BROOT,
+ 					ip->i_afp->if_broot,
+ 					ip->i_afp->if_broot_bytes);
+ 			ilf->ilf_asize = ip->i_afp->if_broot_bytes;
+ 			ilf->ilf_size++;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  		} else {
  			iip->ili_fields &= ~XFS_ILOG_ABROOT;
  		}
@@@ -400,13 -391,14 +476,24 @@@
  			 * to be there by xfs_idata_realloc().
  			 */
  			data_bytes = roundup(ip->i_afp->if_bytes, 4);
++<<<<<<< HEAD
 +			ASSERT((ip->i_afp->if_real_bytes == 0) ||
 +			       (ip->i_afp->if_real_bytes == data_bytes));
 +			vecp->i_len = (int)data_bytes;
 +			vecp->i_type = XLOG_REG_TYPE_IATTR_LOCAL;
 +			vecp++;
 +			(*nvecs)++;
 +			iip->ili_format.ilf_asize = (unsigned)data_bytes;
++=======
+ 			ASSERT(ip->i_afp->if_real_bytes == 0 ||
+ 			       ip->i_afp->if_real_bytes == data_bytes);
+ 			ASSERT(ip->i_afp->if_u1.if_data != NULL);
+ 			xlog_copy_iovec(lv, vecp, XLOG_REG_TYPE_IATTR_LOCAL,
+ 					ip->i_afp->if_u1.if_data,
+ 					data_bytes);
+ 			ilf->ilf_asize = (unsigned)data_bytes;
+ 			ilf->ilf_size++;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  		} else {
  			iip->ili_fields &= ~XFS_ILOG_ADATA;
  		}
@@@ -433,26 -423,24 +520,44 @@@ xfs_inode_item_format
  {
  	struct xfs_inode_log_item *iip = INODE_ITEM(lip);
  	struct xfs_inode	*ip = iip->ili_inode;
- 	uint			nvecs;
+ 	struct xfs_inode_log_format *ilf;
+ 	struct xfs_log_iovec	*vecp = NULL;
  
++<<<<<<< HEAD
 +	vecp->i_addr = &iip->ili_format;
 +	vecp->i_len  = sizeof(xfs_inode_log_format_t);
 +	vecp->i_type = XLOG_REG_TYPE_IFORMAT;
 +	vecp++;
 +	nvecs	     = 1;
 +
 +	vecp->i_addr = &ip->i_d;
 +	vecp->i_len  = xfs_icdinode_size(ip->i_d.di_version);
 +	vecp->i_type = XLOG_REG_TYPE_ICORE;
 +	vecp++;
 +	nvecs++;
++=======
+ 	ilf = xlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_IFORMAT,
+ 			&iip->ili_format,
+ 			sizeof(struct xfs_inode_log_format));
+ 	ilf->ilf_size = 1;
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  
  	if (ip->i_d.di_version == 1)
  		xfs_inode_item_format_v1_inode(ip);
+ 	xlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_ICORE,
+ 			&ip->i_d,
+ 			xfs_icdinode_size(ip->i_d.di_version));
+ 	ilf->ilf_size++;
  
++<<<<<<< HEAD
 +	vecp = xfs_inode_item_format_data_fork(iip, vecp, &nvecs);
 +	if (XFS_IFORK_Q(ip)) {
 +		vecp = xfs_inode_item_format_attr_fork(iip, vecp, &nvecs);
++=======
+ 	xfs_inode_item_format_data_fork(iip, ilf, lv, &vecp);
+ 	if (XFS_IFORK_Q(ip)) {
+ 		xfs_inode_item_format_attr_fork(iip, ilf, lv, &vecp);
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  	} else {
  		iip->ili_fields &=
  			~(XFS_ILOG_ADATA | XFS_ILOG_ABROOT | XFS_ILOG_AEXT);
diff --cc fs/xfs/xfs_log.h
index 1c458487f000,b0f4ef77fa70..000000000000
--- a/fs/xfs/xfs_log.h
+++ b/fs/xfs/xfs_log.h
@@@ -32,6 -30,52 +32,55 @@@ struct xfs_log_vec 
  
  #define XFS_LOG_VEC_ORDERED	(-1)
  
++<<<<<<< HEAD
++=======
+ static inline void *
+ xlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,
+ 		uint type)
+ {
+ 	struct xfs_log_iovec *vec = *vecp;
+ 
+ 	if (vec) {
+ 		ASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);
+ 		vec++;
+ 	} else {
+ 		vec = &lv->lv_iovecp[0];
+ 	}
+ 
+ 	vec->i_type = type;
+ 	vec->i_addr = lv->lv_buf + lv->lv_buf_len;
+ 
+ 	ASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));
+ 
+ 	*vecp = vec;
+ 	return vec->i_addr;
+ }
+ 
+ static inline void
+ xlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)
+ {
+ 	/*
+ 	 * We need to make sure the next buffer is naturally aligned for the
+ 	 * biggest basic data type we put into it.  We already accounted for
+ 	 * this when sizing the buffer.
+ 	 */
+ 	lv->lv_buf_len += round_up(len, sizeof(uint64_t));
+ 	vec->i_len = len;
+ }
+ 
+ static inline void *
+ xlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,
+ 		uint type, void *data, int len)
+ {
+ 	void *buf;
+ 
+ 	buf = xlog_prepare_iovec(lv, vecp, type);
+ 	memcpy(buf, data, len);
+ 	xlog_finish_iovec(lv, *vecp, len);
+ 	return buf;
+ }
+ 
++>>>>>>> bde7cff67c39 (xfs: format log items write directly into the linear CIL buffer)
  /*
   * Structure used to pass callback function and the function's argument
   * to the log manager.
* Unmerged path fs/xfs/xfs_buf_item.c
* Unmerged path fs/xfs/xfs_dquot_item.c
* Unmerged path fs/xfs/xfs_extfree_item.c
* Unmerged path fs/xfs/xfs_icreate_item.c
* Unmerged path fs/xfs/xfs_inode_item.c
* Unmerged path fs/xfs/xfs_log.h
diff --git a/fs/xfs/xfs_log_cil.c b/fs/xfs/xfs_log_cil.c
index 8f8ebbeaf187..7383b35c8ac1 100644
--- a/fs/xfs/xfs_log_cil.c
+++ b/fs/xfs/xfs_log_cil.c
@@ -80,36 +80,6 @@ xlog_cil_init_post_recovery(
 								log->l_curr_block);
 }
 
-STATIC int
-xlog_cil_lv_item_format(
-	struct xfs_log_item	*lip,
-	struct xfs_log_vec	*lv)
-{
-	int	index;
-	char	*ptr;
-
-	/* format new vectors into array */
-	lip->li_ops->iop_format(lip, lv->lv_iovecp);
-
-	/* copy data into existing array */
-	ptr = lv->lv_buf;
-	for (index = 0; index < lv->lv_niovecs; index++) {
-		struct xfs_log_iovec *vec = &lv->lv_iovecp[index];
-
-		memcpy(ptr, vec->i_addr, vec->i_len);
-		vec->i_addr = ptr;
-		ptr += vec->i_len;
-	}
-
-	/*
-	 * some size calculations for log vectors over-estimate, so the caller
-	 * doesn't know the amount of space actually used by the item. Return
-	 * the byte count to the caller so they can check and store it
-	 * appropriately.
-	 */
-	return ptr - lv->lv_buf;
-}
-
 /*
  * Prepare the log item for insertion into the CIL. Calculate the difference in
  * log space and vectors it will consume, and if it is a new item pin it as
@@ -230,6 +200,13 @@ xlog_cil_insert_format_items(
 			nbytes = 0;
 		}
 
+		/*
+		 * We 64-bit align the length of each iovec so that the start
+		 * of the next one is naturally aligned.  We'll need to
+		 * account for that slack space here.
+		 */
+		nbytes += niovecs * sizeof(uint64_t);
+
 		/* grab the old item if it exists for reservation accounting */
 		old_lv = lip->li_lv;
 
@@ -270,9 +247,9 @@ xlog_cil_insert_format_items(
 		lv->lv_niovecs = niovecs;
 
 		/* The allocated data region lies beyond the iovec region */
+		lv->lv_buf_len = 0;
 		lv->lv_buf = (char *)lv + buf_size - nbytes;
-
-		lv->lv_buf_len = xlog_cil_lv_item_format(lip, lv);
+		lip->li_ops->iop_format(lip, lv);
 insert:
 		ASSERT(lv->lv_buf_len <= nbytes);
 		xfs_cil_prepare_item(log, lv, old_lv, diff_len, diff_iovecs);
diff --git a/fs/xfs/xfs_trans.h b/fs/xfs/xfs_trans.h
index 58c870e38e9e..71cde5c48ecd 100644
--- a/fs/xfs/xfs_trans.h
+++ b/fs/xfs/xfs_trans.h
@@ -67,7 +67,7 @@ typedef struct xfs_log_item {
 
 struct xfs_item_ops {
 	void (*iop_size)(xfs_log_item_t *, int *, int *);
-	void (*iop_format)(xfs_log_item_t *, struct xfs_log_iovec *);
+	void (*iop_format)(xfs_log_item_t *, struct xfs_log_vec *);
 	void (*iop_pin)(xfs_log_item_t *);
 	void (*iop_unpin)(xfs_log_item_t *, int remove);
 	uint (*iop_push)(struct xfs_log_item *, struct list_head *);
