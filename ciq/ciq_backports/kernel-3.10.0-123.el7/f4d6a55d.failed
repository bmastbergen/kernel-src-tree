ALSA: hda - Clean up async codec PM using standard async infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [alsa] hda: Clean up async codec PM using standard async infrastructure (Jaroslav Kysela) [1044022]
Rebuild_FUZZ: 93.33%
commit-author Takashi Iwai <tiwai@suse.de>
commit f4d6a55d7be3f5b944c17e6aafb84d96c4dd09d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/f4d6a55d.failed

This simplifies lots of codes indeed.

	Tested-by: Mengdong Lin <mengdong.lin@intel.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit f4d6a55d7be3f5b944c17e6aafb84d96c4dd09d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_codec.c
diff --cc sound/pci/hda/hda_codec.c
index 09f3c4676162,2e090c8d7144..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -831,6 -840,7 +832,10 @@@ static int snd_hda_bus_free(struct hda_
  		bus->ops.private_free(bus);
  	if (bus->workq)
  		destroy_workqueue(bus->workq);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> f4d6a55d7be3 (ALSA: hda - Clean up async codec PM using standard async infrastructure)
  	kfree(bus);
  	return 0;
  }
@@@ -1466,6 -1473,8 +1471,11 @@@ int snd_hda_codec_new(struct hda_bus *b
  	}
  
  	list_add_tail(&codec->list, &bus->codec_list);
++<<<<<<< HEAD
++=======
+ 	bus->num_codecs++;
+ 
++>>>>>>> f4d6a55d7be3 (ALSA: hda - Clean up async codec PM using standard async infrastructure)
  	bus->caddr_tbl[codec_addr] = codec;
  
  	codec->vendor_id = snd_hda_param_read(codec, AC_NODE_ROOT,
@@@ -5663,9 -5683,18 +5685,24 @@@ int snd_hda_suspend(struct hda_bus *bus
  
  	list_for_each_entry(codec, &bus->codec_list, list) {
  		cancel_delayed_work_sync(&codec->jackpoll_work);
++<<<<<<< HEAD
 +		if (hda_codec_is_power_on(codec))
 +			hda_call_codec_suspend(codec, false);
 +	}
++=======
+ 		if (hda_codec_is_power_on(codec)) {
+ 			if (bus->num_codecs > 1)
+ 				async_schedule_domain(hda_async_suspend, codec,
+ 						      &domain);
+ 			else
+ 				hda_call_codec_suspend(codec, false);
+ 		}
+ 	}
+ 
+ 	if (bus->num_codecs > 1)
+ 		async_synchronize_full_domain(&domain);
+ 
++>>>>>>> f4d6a55d7be3 (ALSA: hda - Clean up async codec PM using standard async infrastructure)
  	return 0;
  }
  EXPORT_SYMBOL_HDA(snd_hda_suspend);
@@@ -5679,10 -5708,18 +5716,23 @@@
  int snd_hda_resume(struct hda_bus *bus)
  {
  	struct hda_codec *codec;
+ 	ASYNC_DOMAIN_EXCLUSIVE(domain);
  
  	list_for_each_entry(codec, &bus->codec_list, list) {
++<<<<<<< HEAD
 +		hda_call_codec_resume(codec);
 +	}
++=======
+ 		if (bus->num_codecs > 1)
+ 			async_schedule_domain(hda_async_resume, codec, &domain);
+ 		else
+ 			hda_call_codec_resume(codec);
+ 	}
+ 
+ 	if (bus->num_codecs > 1)
+ 		async_synchronize_full_domain(&domain);
+ 
++>>>>>>> f4d6a55d7be3 (ALSA: hda - Clean up async codec PM using standard async infrastructure)
  	return 0;
  }
  EXPORT_SYMBOL_HDA(snd_hda_resume);
* Unmerged path sound/pci/hda/hda_codec.c
