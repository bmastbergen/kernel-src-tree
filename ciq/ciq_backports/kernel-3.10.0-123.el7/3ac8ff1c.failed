powerpc: Fix transactional FP/VMX/VSX unavailable handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [powerpc] Fix transactional FP/VMX/VSX unavailable handlers (Steve Best) [1052083]
Rebuild_FUZZ: 91.59%
commit-author Paul Mackerras <paulus@samba.org>
commit 3ac8ff1c475bda7174fce63230c0932454287cd5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/3ac8ff1c.failed

Currently, if a process starts a transaction and then takes an
exception because the FPU, VMX or VSX unit is unavailable to it,
we end up corrupting any FP/VMX/VSX state that was valid before
the interrupt.  For example, if the process starts a transaction
with the FPU available to it but VMX unavailable, and then does
a VMX instruction inside the transaction, the FP state gets
corrupted.

Loading up the desired state generally involves doing a reclaim
and a recheckpoint.  To avoid corrupting already-valid state, we have
to be careful not to reload that state from the thread_struct
between the reclaim and the recheckpoint (since the thread_struct
values are stale by now), and we have to reload that state from
the transact_fp/vr arrays after the recheckpoint to get back the
current transactional values saved there by the reclaim.

	Signed-off-by: Paul Mackerras <paulus@samba.org>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 3ac8ff1c475bda7174fce63230c0932454287cd5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/traps.c
diff --cc arch/powerpc/kernel/traps.c
index cba93ca12ca7,33cd7a0b8e73..000000000000
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@@ -1368,13 -1416,19 +1368,25 @@@ void fp_unavailable_tm(struct pt_regs *
  	/* This loads and recheckpoints the FP registers from
  	 * thread.fpr[].  They will remain in registers after the
  	 * checkpoint so we don't need to reload them after.
+ 	 * If VMX is in use, the VRs now hold checkpointed values,
+ 	 * so we don't want to load the VRs from the thread_struct.
  	 */
- 	tm_recheckpoint(&current->thread, regs->msr);
+ 	tm_recheckpoint(&current->thread, MSR_FP);
+ 
+ 	/* If VMX is in use, get the transactional values back */
+ 	if (regs->msr & MSR_VEC) {
+ 		do_load_up_transact_altivec(&current->thread);
+ 		/* At this point all the VSX state is loaded, so enable it */
+ 		regs->msr |= MSR_VSX;
+ 	}
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_ALTIVEC
 +extern void do_load_up_altivec(struct pt_regs *regs);
 +
++=======
++>>>>>>> 3ac8ff1c475b (powerpc: Fix transactional FP/VMX/VSX unavailable handlers)
  void altivec_unavailable_tm(struct pt_regs *regs)
  {
  	/* See the comments in fp_unavailable_tm().  This function operates
@@@ -1384,18 -1438,21 +1396,23 @@@
  	TM_DEBUG("Vector Unavailable trap whilst transactional at 0x%lx,"
  		 "MSR=%lx\n",
  		 regs->nip, regs->msr);
 -	tm_reclaim_current(TM_CAUSE_FAC_UNAV);
 +	tm_enable();
 +	tm_reclaim(&current->thread, current->thread.regs->msr,
 +		   TM_CAUSE_FAC_UNAV);
  	regs->msr |= MSR_VEC;
- 	tm_recheckpoint(&current->thread, regs->msr);
+ 	tm_recheckpoint(&current->thread, MSR_VEC);
  	current->thread.used_vr = 1;
+ 
+ 	if (regs->msr & MSR_FP) {
+ 		do_load_up_transact_fpu(&current->thread);
+ 		regs->msr |= MSR_VSX;
+ 	}
  }
- #endif
  
- #ifdef CONFIG_VSX
  void vsx_unavailable_tm(struct pt_regs *regs)
  {
+ 	unsigned long orig_msr = regs->msr;
+ 
  	/* See the comments in fp_unavailable_tm().  This works similarly,
  	 * though we're loading both FP and VEC registers in here.
  	 *
@@@ -1407,10 -1464,16 +1424,21 @@@
  		 "MSR=%lx\n",
  		 regs->nip, regs->msr);
  
++<<<<<<< HEAD
 +	tm_enable();
++=======
+ 	current->thread.used_vsr = 1;
+ 
+ 	/* If FP and VMX are already loaded, we have all the state we need */
+ 	if ((orig_msr & (MSR_FP | MSR_VEC)) == (MSR_FP | MSR_VEC)) {
+ 		regs->msr |= MSR_VSX;
+ 		return;
+ 	}
+ 
++>>>>>>> 3ac8ff1c475b (powerpc: Fix transactional FP/VMX/VSX unavailable handlers)
  	/* This reclaims FP and/or VR regs if they're already enabled */
 -	tm_reclaim_current(TM_CAUSE_FAC_UNAV);
 +	tm_reclaim(&current->thread, current->thread.regs->msr,
 +		   TM_CAUSE_FAC_UNAV);
  
  	regs->msr |= MSR_VEC | MSR_FP | current->thread.fpexc_mode |
  		MSR_VSX;
* Unmerged path arch/powerpc/kernel/traps.c
