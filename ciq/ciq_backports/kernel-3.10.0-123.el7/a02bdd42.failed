qlcnic: Fix bug in Tx completion path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Shahed Shaikh <shahed.shaikh@qlogic.com>
commit a02bdd423d844f5beb3196922f07c85c2f7691b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/a02bdd42.failed

o Driver is using common tx_clean_lock for all Tx queues. This patch
  adds per queue tx_clean_lock.
o Driver is not updating sw_consumer while processing Tx completion
  when interface is going down. Fixed in this patch.

	Signed-off-by: Shahed Shaikh <shahed.shaikh@qlogic.com>
	Signed-off-by: Manish Chopra <manish.chopra@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a02bdd423d844f5beb3196922f07c85c2f7691b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
index b80d62b77802,ad1531ae3aa8..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
@@@ -783,6 -782,9 +783,12 @@@ static int qlcnic_process_cmd_ring(stru
  	struct net_device *netdev = adapter->netdev;
  	struct qlcnic_skb_frag *frag;
  
++<<<<<<< HEAD
++=======
+ 	if (!spin_trylock(&tx_ring->tx_clean_lock))
+ 		return 1;
+ 
++>>>>>>> a02bdd423d84 (qlcnic: Fix bug in Tx completion path)
  	sw_consumer = tx_ring->sw_consumer;
  	hw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));
  
@@@ -838,6 -839,8 +845,11 @@@
  	 */
  	hw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));
  	done = (sw_consumer == hw_consumer);
++<<<<<<< HEAD
++=======
+ 
+ 	spin_unlock(&tx_ring->tx_clean_lock);
++>>>>>>> a02bdd423d84 (qlcnic: Fix bug in Tx completion path)
  
  	return done;
  }
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h b/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
index 9d8f80e227b7..82deeeb5b300 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
@@ -558,6 +558,8 @@ struct qlcnic_host_tx_ring {
 	dma_addr_t phys_addr;
 	dma_addr_t hw_cons_phys_addr;
 	struct netdev_queue *txq;
+	/* Lock to protect Tx descriptors cleanup */
+	spinlock_t tx_clean_lock;
 } ____cacheline_internodealigned_in_smp;
 
 /*
@@ -1067,7 +1069,6 @@ struct qlcnic_adapter {
 	struct qlcnic_filter_hash rx_fhash;
 	struct list_head vf_mc_list;
 
-	spinlock_t tx_clean_lock;
 	spinlock_t mac_learn_lock;
 	/* spinlock for catching rcv filters for eswitch traffic */
 	spinlock_t rx_mac_learn_lock;
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c
index 66c26cf7a2b8..e98104241ddf 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c
@@ -134,6 +134,8 @@ void qlcnic_release_tx_buffers(struct qlcnic_adapter *adapter,
 	struct qlcnic_skb_frag *buffrag;
 	int i, j;
 
+	spin_lock(&tx_ring->tx_clean_lock);
+
 	cmd_buf = tx_ring->cmd_buf_arr;
 	for (i = 0; i < tx_ring->num_desc; i++) {
 		buffrag = cmd_buf->frag_array;
@@ -157,6 +159,8 @@ void qlcnic_release_tx_buffers(struct qlcnic_adapter *adapter,
 		}
 		cmd_buf++;
 	}
+
+	spin_unlock(&tx_ring->tx_clean_lock);
 }
 
 void qlcnic_free_sw_resources(struct qlcnic_adapter *adapter)
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 9736bb28f194..f85c6bb69e48 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -2086,6 +2086,7 @@ int qlcnic_alloc_tx_rings(struct qlcnic_adapter *adapter,
 		}
 		memset(cmd_buf_arr, 0, TX_BUFF_RINGSIZE(tx_ring));
 		tx_ring->cmd_buf_arr = cmd_buf_arr;
+		spin_lock_init(&tx_ring->tx_clean_lock);
 	}
 
 	if (qlcnic_83xx_check(adapter) ||
