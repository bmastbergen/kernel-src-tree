context_tracking: Optimize guest APIs off case with static key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Frederic Weisbecker <fweisbec@gmail.com>
commit 48d6a816a8bf36e2a197c322697323003bdc1cfe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/48d6a816.failed

Optimize guest entry/exit APIs with static keys. This minimize
the overhead for those who enable CONFIG_NO_HZ_FULL without
always using it. Having no range passed to nohz_full= should
result in the probes overhead to be minimized.

	Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Li Zhong <zhong@linux.vnet.ibm.com>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Kevin Hilman <khilman@linaro.org>
(cherry picked from commit 48d6a816a8bf36e2a197c322697323003bdc1cfe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/context_tracking.c
diff --cc kernel/context_tracking.c
index 93939ff36b59,b6a186c4b886..000000000000
--- a/kernel/context_tracking.c
+++ b/kernel/context_tracking.c
@@@ -20,11 -20,11 +20,19 @@@
  #include <linux/hardirq.h>
  #include <linux/export.h>
  
++<<<<<<< HEAD
 +DEFINE_PER_CPU(struct context_tracking, context_tracking) = {
 +#ifdef CONFIG_CONTEXT_TRACKING_FORCE
 +	.active = true,
 +#endif
 +};
++=======
+ struct static_key context_tracking_enabled = STATIC_KEY_INIT_FALSE;
+ EXPORT_SYMBOL_GPL(context_tracking_enabled);
+ 
+ DEFINE_PER_CPU(struct context_tracking, context_tracking);
+ EXPORT_SYMBOL_GPL(context_tracking);
++>>>>>>> 48d6a816a8bf (context_tracking: Optimize guest APIs off case with static key)
  
  void context_tracking_cpu_set(int cpu)
  {
diff --git a/include/linux/context_tracking.h b/include/linux/context_tracking.h
index da2a20a1e54f..ad6b935f5107 100644
--- a/include/linux/context_tracking.h
+++ b/include/linux/context_tracking.h
@@ -85,8 +85,23 @@ static inline void context_tracking_task_switch(struct task_struct *prev,
 #endif /* !CONFIG_CONTEXT_TRACKING */
 
 #ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
-extern void guest_enter(void);
-extern void guest_exit(void);
+static inline void guest_enter(void)
+{
+	if (static_key_false(&context_tracking_enabled) &&
+	    vtime_accounting_enabled())
+		vtime_guest_enter(current);
+	else
+		current->flags |= PF_VCPU;
+}
+
+static inline void guest_exit(void)
+{
+	if (static_key_false(&context_tracking_enabled) &&
+	    vtime_accounting_enabled())
+		vtime_guest_exit(current);
+	else
+		current->flags &= ~PF_VCPU;
+}
 #else
 static inline void guest_enter(void)
 {
* Unmerged path kernel/context_tracking.c
diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c
index 4f5bc236c50f..17080acac377 100644
--- a/kernel/sched/cputime.c
+++ b/kernel/sched/cputime.c
@@ -725,6 +725,7 @@ void vtime_guest_enter(struct task_struct *tsk)
 	current->flags |= PF_VCPU;
 	write_sequnlock(&tsk->vtime_seqlock);
 }
+EXPORT_SYMBOL_GPL(vtime_guest_enter);
 
 void vtime_guest_exit(struct task_struct *tsk)
 {
@@ -733,6 +734,7 @@ void vtime_guest_exit(struct task_struct *tsk)
 	current->flags &= ~PF_VCPU;
 	write_sequnlock(&tsk->vtime_seqlock);
 }
+EXPORT_SYMBOL_GPL(vtime_guest_exit);
 
 void vtime_account_idle(struct task_struct *tsk)
 {
