locks: break delegations on link

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author J. Bruce Fields <bfields@redhat.com>
commit 146a8595c6399ee6ab4b5cc34c0d28aa4835fdc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/146a8595.failed

	Cc: Tyler Hicks <tyhicks@canonical.com>
	Cc: Dustin Kirkland <dustin.kirkland@gazzang.com>
	Acked-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 146a8595c6399ee6ab4b5cc34c0d28aa4835fdc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index 9dbedede9069,251178a1e383..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -3821,8 -3874,17 +3840,22 @@@ int vfs_link(struct dentry *old_dentry
  		error =  -ENOENT;
  	else if (max_links && inode->i_nlink >= max_links)
  		error = -EMLINK;
++<<<<<<< HEAD
 +	else
 +		error = dir->i_op->link(old_dentry, dir, new_dentry);
++=======
+ 	else {
+ 		error = try_break_deleg(inode, delegated_inode);
+ 		if (!error)
+ 			error = dir->i_op->link(old_dentry, dir, new_dentry);
+ 	}
+ 
+ 	if (!error && (inode->i_state & I_LINKABLE)) {
+ 		spin_lock(&inode->i_lock);
+ 		inode->i_state &= ~I_LINKABLE;
+ 		spin_unlock(&inode->i_lock);
+ 	}
++>>>>>>> 146a8595c639 (locks: break delegations on link)
  	mutex_unlock(&inode->i_mutex);
  	if (!error)
  		fsnotify_link(dir, inode, new_dentry);
diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c
index 8def88af9e64..2b4b207909a3 100644
--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -475,7 +475,7 @@ static int ecryptfs_link(struct dentry *old_dentry, struct inode *dir,
 	dget(lower_new_dentry);
 	lower_dir_dentry = lock_parent(lower_new_dentry);
 	rc = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
-		      lower_new_dentry);
+		      lower_new_dentry, NULL);
 	if (rc || !lower_new_dentry->d_inode)
 		goto out_lock;
 	rc = ecryptfs_interpose(lower_new_dentry, new_dentry, dir->i_sb);
* Unmerged path fs/namei.c
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 17d9a13c7263..dff67347bf90 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1737,7 +1737,7 @@ nfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,
 		err = nfserrno(host_err);
 		goto out_dput;
 	}
-	host_err = vfs_link(dold, dirp, dnew);
+	host_err = vfs_link(dold, dirp, dnew, NULL);
 	if (!host_err) {
 		err = nfserrno(commit_metadata(ffhp));
 		if (!err)
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 202fa9761812..bb58e3a48bd3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1465,7 +1465,7 @@ extern int vfs_create(struct inode *, struct dentry *, umode_t, bool);
 extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
 extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, const char *);
-extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
+extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
 extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
