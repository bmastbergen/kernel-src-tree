xfs: validity check the directory block leaf entry count

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit a62936210525da2f46ae264e0bf9680eafac176e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/a6293621.failed

The directory block format verifier fails to check that the leaf
entry count is in a valid range, and so if it is corrupted then it
can lead to derefencing a pointer outside the block buffer. While we
can't exactly validate the count without first walking the directory
block, we can ensure the count lands in the valid area within the
directory block and hence avoid out-of-block references.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Ben Myers <bpm@sgi.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit a62936210525da2f46ae264e0bf9680eafac176e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_dir2_data.c
diff --cc fs/xfs/xfs_dir2_data.c
index e4ce4801d4ae,70acff4ee173..000000000000
--- a/fs/xfs/xfs_dir2_data.c
+++ b/fs/xfs/xfs_dir2_data.c
@@@ -65,11 -62,18 +65,23 @@@ __xfs_dir3_data_check
  	char			*p;		/* current data position */
  	int			stale;		/* count of stale leaves */
  	struct xfs_name		name;
 -	const struct xfs_dir_ops *ops;
  
  	mp = bp->b_target->bt_mount;
++<<<<<<< HEAD
 +	hdr = bp->b_addr;
 +	bf = xfs_dir3_data_bestfree_p(hdr);
 +	p = (char *)xfs_dir3_data_entry_p(hdr);
++=======
+ 
+ 	/*
+ 	 * We can be passed a null dp here from a verifier, so we need to go the
+ 	 * hard way to get them.
+ 	 */
+ 	ops = xfs_dir_get_ops(mp, dp);
++>>>>>>> a62936210525 (xfs: validity check the directory block leaf entry count)
+ 
+ 	hdr = bp->b_addr;
+ 	p = (char *)ops->data_entry_p(hdr);
  
  	switch (hdr->magic) {
  	case cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):
* Unmerged path fs/xfs/xfs_dir2_data.c
