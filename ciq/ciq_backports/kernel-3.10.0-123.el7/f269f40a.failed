ipc/sem.c: always use only one queue for alter operations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [ipc] sem: always use only one queue for alter operations (Rik van Riel) [881820]
Rebuild_FUZZ: 94.44%
commit-author Manfred Spraul <manfred@colorfullife.com>
commit f269f40ad5aeee229ed70044926f44318abe41ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/f269f40a.failed

There are two places that can contain alter operations:
 - the global queue: sma->pending_alter
 - the per-semaphore queues: sma->sem_base[].pending_alter.

Since one of the queues must be processed first, this causes an odd
priorization of the wakeups: complex operations have priority over
simple ops.

The patch restores the behavior of linux <=3.0.9: The longest waiting
operation has the highest priority.

This is done by using only one queue:
 - if there are complex ops, then sma->pending_alter is used.
 - otherwise, the per-semaphore queues are used.

As a side effect, do_smart_update_queue() becomes much simpler: no more
goto logic.

	Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Davidlohr Bueso <davidlohr.bueso@hp.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f269f40ad5aeee229ed70044926f44318abe41ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	ipc/sem.c
diff --cc ipc/sem.c
index e659bff82f2d,6291257ee049..000000000000
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@@ -262,7 -309,8 +309,12 @@@ static inline int sem_lock(struct sem_a
  static inline void sem_unlock(struct sem_array *sma, int locknum)
  {
  	if (locknum == -1) {
++<<<<<<< HEAD
 +		spin_unlock(&sma->sem_perm.lock);
++=======
+ 		unmerge_queues(sma);
+ 		ipc_unlock_object(&sma->sem_perm);
++>>>>>>> f269f40ad5ae (ipc/sem.c: always use only one queue for alter operations)
  	} else {
  		struct sem *sem = sma->sem_base + locknum;
  		spin_unlock(&sem->lock);
* Unmerged path ipc/sem.c
