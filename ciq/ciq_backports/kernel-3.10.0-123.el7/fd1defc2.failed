NFS: Do not set NFS_INO_INVALID_LABEL unless server supports labeled NFS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit fd1defc257e2b12ab69bc0b379105c00eca4e112
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/fd1defc2.failed

Commit aa9c2669626c (NFS: Client implementation of Labeled-NFS) introduces
a performance regression. When nfs_zap_caches_locked is called, it sets
the NFS_INO_INVALID_LABEL flag irrespectively of whether or not the
NFS server supports security labels. Since that flag is never cleared,
it means that all calls to nfs_revalidate_inode() will now trigger
an on-the-wire GETATTR call.

This patch ensures that we never set the NFS_INO_INVALID_LABEL unless the
server advertises support for labeled NFS.
It also causes nfs_setsecurity() to clear NFS_INO_INVALID_LABEL when it
has successfully set the security label for the inode.
Finally it gets rid of the NFS_INO_INVALID_LABEL cruft from nfs_update_inode,
which has nothing to do with labeled NFS.

	Reported-by: Neil Brown <neilb@suse.de>
	Cc: stable@vger.kernel.org # 3.11+
	Tested-by: Neil Brown <neilb@suse.de>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit fd1defc257e2b12ab69bc0b379105c00eca4e112)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/inode.c
diff --cc fs/nfs/inode.c
index dcdf46080f86,360114ae8b82..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -162,11 -162,18 +162,25 @@@ static void nfs_zap_caches_locked(struc
  
  	memset(NFS_I(inode)->cookieverf, 0, sizeof(NFS_I(inode)->cookieverf));
  	if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) {
 +		nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;
  		nfs_fscache_invalidate(inode);
++<<<<<<< HEAD
 +	} else {
 +		nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;
 +	}
++=======
+ 		nfsi->cache_validity |= NFS_INO_INVALID_ATTR
+ 					| NFS_INO_INVALID_DATA
+ 					| NFS_INO_INVALID_ACCESS
+ 					| NFS_INO_INVALID_ACL
+ 					| NFS_INO_REVAL_PAGECACHE;
+ 	} else
+ 		nfsi->cache_validity |= NFS_INO_INVALID_ATTR
+ 					| NFS_INO_INVALID_ACCESS
+ 					| NFS_INO_INVALID_ACL
+ 					| NFS_INO_REVAL_PAGECACHE;
+ 	nfs_zap_label_cache_locked(nfsi);
++>>>>>>> fd1defc257e2 (NFS: Do not set NFS_INO_INVALID_LABEL unless server supports labeled NFS)
  }
  
  void nfs_zap_caches(struct inode *inode)
@@@ -258,6 -265,34 +272,37 @@@ nfs_init_locked(struct inode *inode, vo
  }
  
  #ifdef CONFIG_NFS_V4_SECURITY_LABEL
++<<<<<<< HEAD
++=======
+ static void nfs_clear_label_invalid(struct inode *inode)
+ {
+ 	spin_lock(&inode->i_lock);
+ 	NFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_LABEL;
+ 	spin_unlock(&inode->i_lock);
+ }
+ 
+ void nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr,
+ 					struct nfs4_label *label)
+ {
+ 	int error;
+ 
+ 	if (label == NULL)
+ 		return;
+ 
+ 	if ((fattr->valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL) && inode->i_security) {
+ 		error = security_inode_notifysecctx(inode, label->label,
+ 				label->len);
+ 		if (error)
+ 			printk(KERN_ERR "%s() %s %d "
+ 					"security_inode_notifysecctx() %d\n",
+ 					__func__,
+ 					(char *)label->label,
+ 					label->len, error);
+ 		nfs_clear_label_invalid(inode);
+ 	}
+ }
+ 
++>>>>>>> fd1defc257e2 (NFS: Do not set NFS_INO_INVALID_LABEL unless server supports labeled NFS)
  struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)
  {
  	struct nfs4_label *label = NULL;
* Unmerged path fs/nfs/inode.c
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f0d5c699e877..12d9b6de5a5e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -279,9 +279,18 @@ static inline void nfs4_label_free(struct nfs4_label *label)
 	}
 	return;
 }
+
+static inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)
+{
+	if (nfs_server_capable(&nfsi->vfs_inode, NFS_CAP_SECURITY_LABEL))
+		nfsi->cache_validity |= NFS_INO_INVALID_LABEL;
+}
 #else
 static inline struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags) { return NULL; }
 static inline void nfs4_label_free(void *label) {}
+static inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)
+{
+}
 #endif /* CONFIG_NFS_V4_SECURITY_LABEL */
 
 /* proc.c */
