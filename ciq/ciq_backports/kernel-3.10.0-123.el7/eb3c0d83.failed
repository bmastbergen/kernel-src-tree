net: unify skb_udp_tunnel_segment() and skb_udp6_tunnel_segment()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] udp: unify skb_udp_tunnel_segment() and skb_udp6_tunnel_segment() (Amerigo Wang) [970585]
Rebuild_FUZZ: 95.38%
commit-author Cong Wang <amwang@redhat.com>
commit eb3c0d83cc78361a28e52e514a7095fdbf771e7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/eb3c0d83.failed

As suggested by Pravin, we can unify the code in case of duplicated
code.

	Cc: Pravin Shelar <pshelar@nicira.com>
	Signed-off-by: Cong Wang <amwang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eb3c0d83cc78361a28e52e514a7095fdbf771e7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
diff --cc net/ipv4/udp.c
index 10d9853d1d5e,74d2c95db57f..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -2342,8 -2348,18 +2342,22 @@@ struct sk_buff *skb_udp_tunnel_segment(
  			if (uh->check == 0)
  				uh->check = CSUM_MANGLED_0;
  
+ 		} else if (protocol == htons(ETH_P_IPV6)) {
+ 			struct ipv6hdr *ipv6h = ipv6_hdr(skb);
+ 			u32 len = skb->len - udp_offset;
+ 
+ 			uh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,
+ 						     len, IPPROTO_UDP, 0);
+ 			uh->check = csum_fold(skb_checksum(skb, udp_offset, len, 0));
+ 			if (uh->check == 0)
+ 				uh->check = CSUM_MANGLED_0;
+ 			skb->ip_summed = CHECKSUM_NONE;
  		}
++<<<<<<< HEAD
 +		skb->ip_summed = CHECKSUM_NONE;
++=======
+ 
++>>>>>>> eb3c0d83cc78 (net: unify skb_udp_tunnel_segment() and skb_udp6_tunnel_segment())
  		skb->protocol = protocol;
  	} while ((skb = skb->next));
  out:
* Unmerged path net/ipv4/udp.c
diff --git a/net/ipv6/udp_offload.c b/net/ipv6/udp_offload.c
index 7e5e5acc9619..60559511bd9c 100644
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@ -38,60 +38,6 @@ static int udp6_ufo_send_check(struct sk_buff *skb)
 	return 0;
 }
 
-static struct sk_buff *skb_udp6_tunnel_segment(struct sk_buff *skb,
-					       netdev_features_t features)
-{
-	struct sk_buff *segs = ERR_PTR(-EINVAL);
-	int mac_len = skb->mac_len;
-	int tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);
-	int outer_hlen;
-	netdev_features_t enc_features;
-
-	if (unlikely(!pskb_may_pull(skb, tnl_hlen)))
-		goto out;
-
-	skb->encapsulation = 0;
-	__skb_pull(skb, tnl_hlen);
-	skb_reset_mac_header(skb);
-	skb_set_network_header(skb, skb_inner_network_offset(skb));
-	skb->mac_len = skb_inner_network_offset(skb);
-
-	/* segment inner packet. */
-	enc_features = skb->dev->hw_enc_features & netif_skb_features(skb);
-	segs = skb_mac_gso_segment(skb, enc_features);
-	if (!segs || IS_ERR(segs))
-		goto out;
-
-	outer_hlen = skb_tnl_header_len(skb);
-	skb = segs;
-	do {
-		struct udphdr *uh;
-		struct ipv6hdr *ipv6h;
-		int udp_offset = outer_hlen - tnl_hlen;
-		u32 len;
-
-		skb->mac_len = mac_len;
-
-		skb_push(skb, outer_hlen);
-		skb_reset_mac_header(skb);
-		skb_set_network_header(skb, mac_len);
-		skb_set_transport_header(skb, udp_offset);
-		uh = udp_hdr(skb);
-		uh->len = htons(skb->len - udp_offset);
-		ipv6h = ipv6_hdr(skb);
-		len = skb->len - udp_offset;
-
-		uh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,
-					     len, IPPROTO_UDP, 0);
-		uh->check = csum_fold(skb_checksum(skb, udp_offset, len, 0));
-		if (uh->check == 0)
-			uh->check = CSUM_MANGLED_0;
-		skb->ip_summed = CHECKSUM_NONE;
-	} while ((skb = skb->next));
-out:
-	return segs;
-}
-
 static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
 					 netdev_features_t features)
 {
@@ -129,7 +75,7 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
 	}
 
 	if (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)
-		segs = skb_udp6_tunnel_segment(skb, features);
+		segs = skb_udp_tunnel_segment(skb, features);
 	else {
 		/* Do software UFO. Complete and fill in the UDP checksum as HW cannot
 		 * do checksum of UDP packets sent as multiple IP fragments.
