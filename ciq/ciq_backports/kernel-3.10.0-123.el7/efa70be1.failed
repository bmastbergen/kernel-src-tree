xfs: add xfs_ilock_attr_map_shared

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Christoph Hellwig <hch@infradead.org>
commit efa70be165497826f674846f681e6e2364af906c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/efa70be1.failed

Equivalent to xfs_ilock_data_map_shared, except for the attribute fork.

Make xfs_getbmap use it if called for the attribute fork instead of
xfs_ilock_data_map_shared.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ben Myers <bpm@sgi.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>


(cherry picked from commit efa70be165497826f674846f681e6e2364af906c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_inode.h
diff --cc fs/xfs/xfs_bmap_util.c
index e877b47203d1,374ba050942f..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -620,17 -623,21 +621,25 @@@ xfs_getbmap
  			error = -filemap_write_and_wait(VFS_I(ip)->i_mapping);
  			if (error)
  				goto out_unlock_iolock;
- 		}
- 		/*
- 		 * even after flushing the inode, there can still be delalloc
- 		 * blocks on the inode beyond EOF due to speculative
- 		 * preallocation. These are not removed until the release
- 		 * function is called or the inode is inactivated. Hence we
- 		 * cannot assert here that ip->i_delayed_blks == 0.
- 		 */
- 	}
  
++<<<<<<< HEAD
 +	lock = xfs_ilock_map_shared(ip);
++=======
+ 			/*
+ 			 * Even after flushing the inode, there can still be
+ 			 * delalloc blocks on the inode beyond EOF due to
+ 			 * speculative preallocation.  These are not removed
+ 			 * until the release function is called or the inode
+ 			 * is inactivated.  Hence we cannot assert here that
+ 			 * ip->i_delayed_blks == 0.
+ 			 */
+ 		}
+ 
+ 		lock = xfs_ilock_data_map_shared(ip);
+ 	} else {
+ 		lock = xfs_ilock_attr_map_shared(ip);
+ 	}
++>>>>>>> efa70be16549 (xfs: add xfs_ilock_attr_map_shared)
  
  	/*
  	 * Don't let nex be bigger than the number of extents
diff --cc fs/xfs/xfs_inode.c
index a18b684cea27,e655bb07e8bb..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -75,50 -77,46 +75,69 @@@ xfs_get_extsz_hint
  }
  
  /*
-  * This is a wrapper routine around the xfs_ilock() routine used to centralize
-  * some grungy code.  It is used in places that wish to lock the inode solely
-  * for reading the extents.  The reason these places can't just call
-  * xfs_ilock(SHARED) is that the inode lock also guards to bringing in of the
-  * extents from disk for a file in b-tree format.  If the inode is in b-tree
-  * format, then we need to lock the inode exclusively until the extents are read
-  * in.  Locking it exclusively all the time would limit our parallelism
-  * unnecessarily, though.  What we do instead is check to see if the extents
-  * have been read in yet, and only lock the inode exclusively if they have not.
+  * These two are wrapper routines around the xfs_ilock() routine used to
+  * centralize some grungy code.  They are used in places that wish to lock the
+  * inode solely for reading the extents.  The reason these places can't just
+  * call xfs_ilock(ip, XFS_ILOCK_SHARED) is that the inode lock also guards to
+  * bringing in of the extents from disk for a file in b-tree format.  If the
+  * inode is in b-tree format, then we need to lock the inode exclusively until
+  * the extents are read in.  Locking it exclusively all the time would limit
+  * our parallelism unnecessarily, though.  What we do instead is check to see
+  * if the extents have been read in yet, and only lock the inode exclusively
+  * if they have not.
   *
++<<<<<<< HEAD
 + * The function returns a value which should be given to the corresponding
 + * xfs_iunlock_map_shared().  This value is the mode in which the lock was
 + * actually taken.
++=======
+  * The functions return a value which should be given to the corresponding
+  * xfs_iunlock() call.
++>>>>>>> efa70be16549 (xfs: add xfs_ilock_attr_map_shared)
   */
  uint
 -xfs_ilock_data_map_shared(
 -	struct xfs_inode	*ip)
 +xfs_ilock_map_shared(
 +	xfs_inode_t	*ip)
  {
 -	uint			lock_mode = XFS_ILOCK_SHARED;
 +	uint	lock_mode;
  
 -	if (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&
 -	    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)
 +	if ((ip->i_d.di_format == XFS_DINODE_FMT_BTREE) &&
 +	    ((ip->i_df.if_flags & XFS_IFEXTENTS) == 0)) {
  		lock_mode = XFS_ILOCK_EXCL;
 +	} else {
 +		lock_mode = XFS_ILOCK_SHARED;
 +	}
 +
  	xfs_ilock(ip, lock_mode);
 +
  	return lock_mode;
  }
  
+ uint
+ xfs_ilock_attr_map_shared(
+ 	struct xfs_inode	*ip)
+ {
+ 	uint			lock_mode = XFS_ILOCK_SHARED;
+ 
+ 	if (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&
+ 	    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)
+ 		lock_mode = XFS_ILOCK_EXCL;
+ 	xfs_ilock(ip, lock_mode);
+ 	return lock_mode;
+ }
+ 
 +/*
 + * This is simply the unlock routine to go with xfs_ilock_map_shared().
 + * All it does is call xfs_iunlock() with the given lock_mode.
 + */
 +void
 +xfs_iunlock_map_shared(
 +	xfs_inode_t	*ip,
 +	unsigned int	lock_mode)
 +{
 +	xfs_iunlock(ip, lock_mode);
 +}
 +
  /*
   * The xfs inode contains 2 locks: a multi-reader lock called the
   * i_iolock and a multi-reader lock called the i_lock.  This routine
diff --cc fs/xfs/xfs_inode.h
index 8f775ed722a9,65e2350f449c..000000000000
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@@ -323,8 -337,8 +323,13 @@@ int		xfs_ilock_nowait(xfs_inode_t *, ui
  void		xfs_iunlock(xfs_inode_t *, uint);
  void		xfs_ilock_demote(xfs_inode_t *, uint);
  int		xfs_isilocked(xfs_inode_t *, uint);
++<<<<<<< HEAD
 +uint		xfs_ilock_map_shared(xfs_inode_t *);
 +void		xfs_iunlock_map_shared(xfs_inode_t *, uint);
++=======
+ uint		xfs_ilock_data_map_shared(struct xfs_inode *);
+ uint		xfs_ilock_attr_map_shared(struct xfs_inode *);
++>>>>>>> efa70be16549 (xfs: add xfs_ilock_attr_map_shared)
  int		xfs_ialloc(struct xfs_trans *, xfs_inode_t *, umode_t,
  			   xfs_nlink_t, xfs_dev_t, prid_t, int,
  			   struct xfs_buf **, xfs_inode_t **);
* Unmerged path fs/xfs/xfs_bmap_util.c
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_inode.h
