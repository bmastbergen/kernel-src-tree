powerpc: Add debug checks to catch invalid cpu-to-node mappings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [powerpc] Add debug checks to catch invalid cpu-to-node mappings (Steve Best) [1042526]
Rebuild_FUZZ: 92.31%
commit-author Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
commit 68fb18aacb410aff26c24a3d73d27ad496f0a548
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/68fb18aa.failed

There have been some weird bugs in the past where the kernel tried to associate
threads of the same core to different NUMA nodes, and things went haywire after
that point (as expected).

But unfortunately, root-causing such issues have been quite challenging, due to
the lack of appropriate debug checks in the kernel. These bugs usually lead to
some odd soft-lockups in the scheduler's build-sched-domain code in the CPU
hotplug path, which makes it very hard to trace it back to the incorrect
cpu-to-node mappings.

So add appropriate debug checks to catch such invalid cpu-to-node mappings
as early as possible.

	Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 68fb18aacb410aff26c24a3d73d27ad496f0a548)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/mm/numa.c
diff --cc arch/powerpc/mm/numa.c
index 0fedfb0da741,4f50c6a9e68f..000000000000
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@@ -566,8 -570,28 +566,33 @@@ out
  	return nid;
  }
  
++<<<<<<< HEAD
 +static int __cpuinit cpu_numa_callback(struct notifier_block *nfb,
 +			     unsigned long action,
++=======
+ static void verify_cpu_node_mapping(int cpu, int node)
+ {
+ 	int base, sibling, i;
+ 
+ 	/* Verify that all the threads in the core belong to the same node */
+ 	base = cpu_first_thread_sibling(cpu);
+ 
+ 	for (i = 0; i < threads_per_core; i++) {
+ 		sibling = base + i;
+ 
+ 		if (sibling == cpu || cpu_is_offline(sibling))
+ 			continue;
+ 
+ 		if (cpu_to_node(sibling) != node) {
+ 			WARN(1, "CPU thread siblings %d and %d don't belong"
+ 				" to the same node!\n", cpu, sibling);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static int cpu_numa_callback(struct notifier_block *nfb, unsigned long action,
++>>>>>>> 68fb18aacb41 (powerpc: Add debug checks to catch invalid cpu-to-node mappings)
  			     void *hcpu)
  {
  	unsigned long lcpu = (unsigned long)hcpu;
* Unmerged path arch/powerpc/mm/numa.c
