net/ipv4: Use proper RCU APIs for writer-side in udp_offload.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [net] ipv4: Use proper RCU APIs for writer-side in udp_offload.c (Thomas Graf) [1051111]
Rebuild_FUZZ: 96.67%
commit-author Shlomo Pongratz <shlomop@mellanox.com>
commit a664a4f7aa4f01ca8728e3ec43618327416fc8ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/a664a4f7.failed

RCU writer side should use rcu_dereference_protected() and not
rcu_dereference(), fix that. This also removes the "suspicious RCU usage"
warning seen when running with CONFIG_PROVE_RCU.

Also, don't use rcu_assign_pointer/rcu_dereference for pointers
which are invisible beyond the udp offload code.

Fixes: b582ef0 ('net: Add GRO support for UDP encapsulating protocols')
	Reported-by: Eric Dumazet <edumazet@google.com>
	Cc: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Shlomo Pongratz <shlomop@mellanox.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a664a4f7aa4f01ca8728e3ec43618327416fc8ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp_offload.c
diff --cc net/ipv4/udp_offload.c
index f35eccaa855e,88b4023ecfcf..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -14,6 -14,17 +14,20 @@@
  #include <net/udp.h>
  #include <net/protocol.h>
  
++<<<<<<< HEAD
++=======
+ static DEFINE_SPINLOCK(udp_offload_lock);
+ static struct udp_offload_priv __rcu *udp_offload_base __read_mostly;
+ 
+ #define udp_deref_protected(X) rcu_dereference_protected(X, lockdep_is_held(&udp_offload_lock))
+ 
+ struct udp_offload_priv {
+ 	struct udp_offload	*offload;
+ 	struct rcu_head		rcu;
+ 	struct udp_offload_priv __rcu *next;
+ };
+ 
++>>>>>>> a664a4f7aa4f (net/ipv4: Use proper RCU APIs for writer-side in udp_offload.c)
  static int udp4_ufo_send_check(struct sk_buff *skb)
  {
  	if (!pskb_may_pull(skb, sizeof(struct udphdr)))
@@@ -87,6 -100,137 +101,140 @@@ out
  	return segs;
  }
  
++<<<<<<< HEAD
++=======
+ int udp_add_offload(struct udp_offload *uo)
+ {
+ 	struct udp_offload_priv *new_offload = kzalloc(sizeof(*new_offload), GFP_ATOMIC);
+ 
+ 	if (!new_offload)
+ 		return -ENOMEM;
+ 
+ 	new_offload->offload = uo;
+ 
+ 	spin_lock(&udp_offload_lock);
+ 	new_offload->next = udp_offload_base;
+ 	rcu_assign_pointer(udp_offload_base, new_offload);
+ 	spin_unlock(&udp_offload_lock);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(udp_add_offload);
+ 
+ static void udp_offload_free_routine(struct rcu_head *head)
+ {
+ 	struct udp_offload_priv *ou_priv = container_of(head, struct udp_offload_priv, rcu);
+ 	kfree(ou_priv);
+ }
+ 
+ void udp_del_offload(struct udp_offload *uo)
+ {
+ 	struct udp_offload_priv __rcu **head = &udp_offload_base;
+ 	struct udp_offload_priv *uo_priv;
+ 
+ 	spin_lock(&udp_offload_lock);
+ 
+ 	uo_priv = udp_deref_protected(*head);
+ 	for (; uo_priv != NULL;
+ 	     uo_priv = udp_deref_protected(*head)) {
+ 		if (uo_priv->offload == uo) {
+ 			rcu_assign_pointer(*head,
+ 					   udp_deref_protected(uo_priv->next));
+ 			goto unlock;
+ 		}
+ 		head = &uo_priv->next;
+ 	}
+ 	pr_warn("udp_del_offload: didn't find offload for port %d\n", ntohs(uo->port));
+ unlock:
+ 	spin_unlock(&udp_offload_lock);
+ 	if (uo_priv != NULL)
+ 		call_rcu(&uo_priv->rcu, udp_offload_free_routine);
+ }
+ EXPORT_SYMBOL(udp_del_offload);
+ 
+ static struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb)
+ {
+ 	struct udp_offload_priv *uo_priv;
+ 	struct sk_buff *p, **pp = NULL;
+ 	struct udphdr *uh, *uh2;
+ 	unsigned int hlen, off;
+ 	int flush = 1;
+ 
+ 	if (NAPI_GRO_CB(skb)->udp_mark ||
+ 	    (!skb->encapsulation && skb->ip_summed != CHECKSUM_COMPLETE))
+ 		goto out;
+ 
+ 	/* mark that this skb passed once through the udp gro layer */
+ 	NAPI_GRO_CB(skb)->udp_mark = 1;
+ 
+ 	off  = skb_gro_offset(skb);
+ 	hlen = off + sizeof(*uh);
+ 	uh   = skb_gro_header_fast(skb, off);
+ 	if (skb_gro_header_hard(skb, hlen)) {
+ 		uh = skb_gro_header_slow(skb, hlen, off);
+ 		if (unlikely(!uh))
+ 			goto out;
+ 	}
+ 
+ 	rcu_read_lock();
+ 	uo_priv = rcu_dereference(udp_offload_base);
+ 	for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
+ 		if (uo_priv->offload->port == uh->dest &&
+ 		    uo_priv->offload->callbacks.gro_receive)
+ 			goto unflush;
+ 	}
+ 	goto out_unlock;
+ 
+ unflush:
+ 	flush = 0;
+ 
+ 	for (p = *head; p; p = p->next) {
+ 		if (!NAPI_GRO_CB(p)->same_flow)
+ 			continue;
+ 
+ 		uh2 = (struct udphdr   *)(p->data + off);
+ 		if ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {
+ 			NAPI_GRO_CB(p)->same_flow = 0;
+ 			continue;
+ 		}
+ 	}
+ 
+ 	skb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */
+ 	pp = uo_priv->offload->callbacks.gro_receive(head, skb);
+ 
+ out_unlock:
+ 	rcu_read_unlock();
+ out:
+ 	NAPI_GRO_CB(skb)->flush |= flush;
+ 	return pp;
+ }
+ 
+ static int udp_gro_complete(struct sk_buff *skb, int nhoff)
+ {
+ 	struct udp_offload_priv *uo_priv;
+ 	__be16 newlen = htons(skb->len - nhoff);
+ 	struct udphdr *uh = (struct udphdr *)(skb->data + nhoff);
+ 	int err = -ENOSYS;
+ 
+ 	uh->len = newlen;
+ 
+ 	rcu_read_lock();
+ 
+ 	uo_priv = rcu_dereference(udp_offload_base);
+ 	for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
+ 		if (uo_priv->offload->port == uh->dest &&
+ 		    uo_priv->offload->callbacks.gro_complete)
+ 			break;
+ 	}
+ 
+ 	if (uo_priv != NULL)
+ 		err = uo_priv->offload->callbacks.gro_complete(skb, nhoff + sizeof(struct udphdr));
+ 
+ 	rcu_read_unlock();
+ 	return err;
+ }
+ 
++>>>>>>> a664a4f7aa4f (net/ipv4: Use proper RCU APIs for writer-side in udp_offload.c)
  static const struct net_offload udpv4_offload = {
  	.callbacks = {
  		.gso_send_check = udp4_ufo_send_check,
* Unmerged path net/ipv4/udp_offload.c
