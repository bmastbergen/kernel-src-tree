null_blk: use blk_complete_request and blk_mq_complete_request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Christoph Hellwig <hch@infradead.org>
commit ce2c350b2cfe5b5ca5023a6b1ec4d21821d39add
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/ce2c350b.failed

Use the block layer helpers for CPU-local completions instead of
reimplementing them locally.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit ce2c350b2cfe5b5ca5023a6b1ec4d21821d39add)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/null_blk.c
diff --cc drivers/block/null_blk.c
index ab36a0ebc2c2,091b9ea14feb..000000000000
--- a/drivers/block/null_blk.c
+++ b/drivers/block/null_blk.c
@@@ -222,49 -226,9 +226,52 @@@ static void null_cmd_end_timer(struct n
  
  static void null_softirq_done_fn(struct request *rq)
  {
- 	blk_end_request_all(rq, 0);
+ 	end_cmd(rq->special);
  }
  
++<<<<<<< HEAD
 +#if defined(CONFIG_SMP) && defined(CONFIG_USE_GENERIC_SMP_HELPERS)
 +
 +static void null_ipi_cmd_end_io(void *data)
 +{
 +	struct completion_queue *cq;
 +	struct llist_node *entry, *next;
 +	struct nullb_cmd *cmd;
 +
 +	cq = &per_cpu(completion_queues, smp_processor_id());
 +
 +	entry = llist_del_all(&cq->list);
 +	entry = llist_reverse_order(entry);
 +
 +	while (entry) {
 +		next = entry->next;
 +		cmd = llist_entry(entry, struct nullb_cmd, ll_list);
 +		end_cmd(cmd);
 +		entry = next;
 +	}
 +}
 +
 +static void null_cmd_end_ipi(struct nullb_cmd *cmd)
 +{
 +	struct call_single_data *data = &cmd->csd;
 +	int cpu = get_cpu();
 +	struct completion_queue *cq = &per_cpu(completion_queues, cpu);
 +
 +	cmd->ll_list.next = NULL;
 +
 +	if (llist_add(&cmd->ll_list, &cq->list)) {
 +		data->func = null_ipi_cmd_end_io;
 +		data->flags = 0;
 +		__smp_call_function_single(cpu, data, 0);
 +	}
 +
 +	put_cpu();
 +}
 +
 +#endif /* CONFIG_SMP && CONFIG_USE_GENERIC_SMP_HELPERS */
 +
++=======
++>>>>>>> ce2c350b2cfe (null_blk: use blk_complete_request and blk_mq_complete_request)
  static inline void null_handle_cmd(struct nullb_cmd *cmd)
  {
  	/* Complete IO by inline, softirq or timer */
@@@ -272,13 -252,6 +295,16 @@@
  	case NULL_IRQ_NONE:
  		end_cmd(cmd);
  		break;
++<<<<<<< HEAD
 +	case NULL_IRQ_SOFTIRQ:
 +#if defined(CONFIG_SMP) && defined(CONFIG_USE_GENERIC_SMP_HELPERS)
 +		null_cmd_end_ipi(cmd);
 +#else
 +		end_cmd(cmd);
 +#endif
 +		break;
++=======
++>>>>>>> ce2c350b2cfe (null_blk: use blk_complete_request and blk_mq_complete_request)
  	case NULL_IRQ_TIMER:
  		null_cmd_end_timer(cmd);
  		break;
@@@ -608,13 -585,6 +635,16 @@@ static int __init null_init(void
  {
  	unsigned int i;
  
++<<<<<<< HEAD
 +#if !defined(CONFIG_SMP) || !defined(CONFIG_USE_GENERIC_SMP_HELPERS)
 +	if (irqmode == NULL_IRQ_SOFTIRQ) {
 +		pr_warn("null_blk: softirq completions not available.\n");
 +		pr_warn("null_blk: using direct completions.\n");
 +		irqmode = NULL_IRQ_NONE;
 +	}
 +#endif
++=======
++>>>>>>> ce2c350b2cfe (null_blk: use blk_complete_request and blk_mq_complete_request)
  	if (bs > PAGE_SIZE) {
  		pr_warn("null_blk: invalid block size\n");
  		pr_warn("null_blk: defaults block size to %lu\n", PAGE_SIZE);
* Unmerged path drivers/block/null_blk.c
