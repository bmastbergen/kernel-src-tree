vxlan: add ipv6 route short circuit support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Cong Wang <amwang@redhat.com>
commit e15a00aafa4b7953ad717d3cb1ad7acf4ff76945
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/e15a00aa.failed

route short circuit only has IPv4 part, this patch adds
the IPv6 part. nd_tbl will be needed.

	Cc: David S. Miller <davem@davemloft.net>
	Cc: David Stevens <dlstevens@us.ibm.com>
	Signed-off-by: Cong Wang <amwang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e15a00aafa4b7953ad717d3cb1ad7acf4ff76945)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/addrconf.h
#	net/ipv6/af_inet6.c
diff --cc include/net/addrconf.h
index c7b181cb47a6,bcf957341b62..000000000000
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@@ -134,31 -118,45 +134,53 @@@ extern u32			ipv6_addr_label(struct ne
  /*
   *	multicast prototypes (mcast.c)
   */
 -int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 -		      const struct in6_addr *addr);
 -int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
 -		      const struct in6_addr *addr);
 -void ipv6_sock_mc_close(struct sock *sk);
 -bool inet6_mc_check(struct sock *sk, const struct in6_addr *mc_addr,
 -		    const struct in6_addr *src_addr);
 -
 -int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
 -int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 -int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
 -void ipv6_mc_up(struct inet6_dev *idev);
 -void ipv6_mc_down(struct inet6_dev *idev);
 -void ipv6_mc_unmap(struct inet6_dev *idev);
 -void ipv6_mc_remap(struct inet6_dev *idev);
 -void ipv6_mc_init_dev(struct inet6_dev *idev);
 -void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 -void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 -
 +extern int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 +			     const struct in6_addr *addr);
 +extern int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
 +			     const struct in6_addr *addr);
 +extern void ipv6_sock_mc_close(struct sock *sk);
 +extern bool inet6_mc_check(struct sock *sk,
 +			   const struct in6_addr *mc_addr,
 +			   const struct in6_addr *src_addr);
 +
 +extern int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
 +extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 +extern int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
 +extern void ipv6_mc_up(struct inet6_dev *idev);
 +extern void ipv6_mc_down(struct inet6_dev *idev);
 +extern void ipv6_mc_unmap(struct inet6_dev *idev);
 +extern void ipv6_mc_remap(struct inet6_dev *idev);
 +extern void ipv6_mc_init_dev(struct inet6_dev *idev);
 +extern void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 +extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 +
++<<<<<<< HEAD
 +extern bool ipv6_chk_mcast_addr(struct net_device *dev,
 +				const struct in6_addr *group,
 +				const struct in6_addr *src_addr);
++=======
+ bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,
+ 			 const struct in6_addr *src_addr);
+ 
+ void ipv6_mc_dad_complete(struct inet6_dev *idev);
+ 
+ /* A stub used by vxlan module. This is ugly, ideally these
+  * symbols should be built into the core kernel.
+  */
+ struct ipv6_stub {
+ 	int (*ipv6_sock_mc_join)(struct sock *sk, int ifindex,
+ 				 const struct in6_addr *addr);
+ 	int (*ipv6_sock_mc_drop)(struct sock *sk, int ifindex,
+ 				 const struct in6_addr *addr);
+ 	int (*ipv6_dst_lookup)(struct sock *sk, struct dst_entry **dst,
+ 				struct flowi6 *fl6);
+ 	void (*udpv6_encap_enable)(void);
+ 	struct neigh_table *nd_tbl;
+ };
+ extern const struct ipv6_stub *ipv6_stub __read_mostly;
++>>>>>>> e15a00aafa4b (vxlan: add ipv6 route short circuit support)
  
 +extern void ipv6_mc_dad_complete(struct inet6_dev *idev);
  /*
   * identify MLD packets for MLD filter exceptions
   */
diff --cc net/ipv6/af_inet6.c
index ab5c7ad482cd,1996a7c34f73..000000000000
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@@ -808,6 -810,14 +808,17 @@@ static struct pernet_operations inet6_n
  	.exit = inet6_net_exit,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct ipv6_stub ipv6_stub_impl = {
+ 	.ipv6_sock_mc_join = ipv6_sock_mc_join,
+ 	.ipv6_sock_mc_drop = ipv6_sock_mc_drop,
+ 	.ipv6_dst_lookup = ip6_dst_lookup,
+ 	.udpv6_encap_enable = udpv6_encap_enable,
+ 	.nd_tbl	= &nd_tbl,
+ };
+ 
++>>>>>>> e15a00aafa4b (vxlan: add ipv6 route short circuit support)
  static int __init inet6_init(void)
  {
  	struct list_head *r;
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index 260932cfcfd3..3e857c036bef 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -1206,7 +1206,6 @@ static bool route_shortcircuit(struct net_device *dev, struct sk_buff *skb)
 {
 	struct vxlan_dev *vxlan = netdev_priv(dev);
 	struct neighbour *n;
-	struct iphdr *pip;
 
 	if (is_multicast_ether_addr(eth_hdr(skb)->h_dest))
 		return false;
@@ -1214,6 +1213,9 @@ static bool route_shortcircuit(struct net_device *dev, struct sk_buff *skb)
 	n = NULL;
 	switch (ntohs(eth_hdr(skb)->h_proto)) {
 	case ETH_P_IP:
+	{
+		struct iphdr *pip;
+
 		if (!pskb_may_pull(skb, sizeof(struct iphdr)))
 			return false;
 		pip = ip_hdr(skb);
@@ -1229,6 +1231,29 @@ static bool route_shortcircuit(struct net_device *dev, struct sk_buff *skb)
 		}
 
 		break;
+	}
+#if IS_ENABLED(CONFIG_IPV6)
+	case ETH_P_IPV6:
+	{
+		struct ipv6hdr *pip6;
+
+		if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
+			return false;
+		pip6 = ipv6_hdr(skb);
+		n = neigh_lookup(ipv6_stub->nd_tbl, &pip6->daddr, dev);
+		if (!n && (vxlan->flags & VXLAN_F_L3MISS)) {
+			union vxlan_addr ipa = {
+				.sin6.sin6_addr = pip6->daddr,
+				.sa.sa_family = AF_INET6,
+			};
+
+			vxlan_ip_miss(dev, &ipa);
+			return false;
+		}
+
+		break;
+	}
+#endif
 	default:
 		return false;
 	}
@@ -1665,7 +1690,8 @@ static netdev_tx_t vxlan_xmit(struct sk_buff *skb, struct net_device *dev)
 	did_rsc = false;
 
 	if (f && (f->flags & NTF_ROUTER) && (vxlan->flags & VXLAN_F_RSC) &&
-	    ntohs(eth->h_proto) == ETH_P_IP) {
+	    (ntohs(eth->h_proto) == ETH_P_IP ||
+	     ntohs(eth->h_proto) == ETH_P_IPV6)) {
 		did_rsc = route_shortcircuit(dev, skb);
 		if (did_rsc)
 			f = vxlan_find_mac(vxlan, eth->h_dest);
* Unmerged path include/net/addrconf.h
* Unmerged path net/ipv6/af_inet6.c
