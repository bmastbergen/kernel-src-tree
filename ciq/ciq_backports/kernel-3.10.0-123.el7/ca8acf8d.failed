NFSv4: Add tracepoints for debugging delegations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [fs] nfs: Add tracepoints for debugging delegations (Jeff Layton) [1009119]
Rebuild_FUZZ: 97.87%
commit-author Trond Myklebust <Trond.Myklebust@netapp.com>
commit ca8acf8d84029b395ade8d4562dae2108bb00c17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/ca8acf8d.failed

Set up tracepoints to track when delegations are set, reclaimed,
returned by the client, or recalled by the server.

	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit ca8acf8d84029b395ade8d4562dae2108bb00c17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4trace.h
diff --cc fs/nfs/nfs4trace.h
index 3f124dbcd60a,900f233ee4dc..000000000000
--- a/fs/nfs/nfs4trace.h
+++ b/fs/nfs/nfs4trace.h
@@@ -411,6 -411,222 +411,225 @@@ DEFINE_NFS4_LOCK_EVENT(nfs4_lock_reclai
  DEFINE_NFS4_LOCK_EVENT(nfs4_lock_expired);
  DEFINE_NFS4_LOCK_EVENT(nfs4_unlock);
  
++<<<<<<< HEAD
++=======
+ DECLARE_EVENT_CLASS(nfs4_set_delegation_event,
+ 		TP_PROTO(
+ 			const struct inode *inode,
+ 			fmode_t fmode
+ 		),
+ 
+ 		TP_ARGS(inode, fmode),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(u32, fhandle)
+ 			__field(u64, fileid)
+ 			__field(unsigned int, fmode)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = inode->i_sb->s_dev;
+ 			__entry->fileid = NFS_FILEID(inode);
+ 			__entry->fhandle = nfs_fhandle_hash(NFS_FH(inode));
+ 			__entry->fmode = (__force unsigned int)fmode;
+ 		),
+ 
+ 		TP_printk(
+ 			"fmode=%s fileid=%02x:%02x:%llu fhandle=0x%08x",
+ 			show_fmode_flags(__entry->fmode),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->fileid,
+ 			__entry->fhandle
+ 		)
+ );
+ #define DEFINE_NFS4_SET_DELEGATION_EVENT(name) \
+ 	DEFINE_EVENT(nfs4_set_delegation_event, name, \
+ 			TP_PROTO( \
+ 				const struct inode *inode, \
+ 				fmode_t fmode \
+ 			), \
+ 			TP_ARGS(inode, fmode))
+ DEFINE_NFS4_SET_DELEGATION_EVENT(nfs4_set_delegation);
+ DEFINE_NFS4_SET_DELEGATION_EVENT(nfs4_reclaim_delegation);
+ 
+ TRACE_EVENT(nfs4_delegreturn_exit,
+ 		TP_PROTO(
+ 			const struct nfs4_delegreturnargs *args,
+ 			const struct nfs4_delegreturnres *res,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(args, res, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(u32, fhandle)
+ 			__field(int, error)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = res->server->s_dev;
+ 			__entry->fhandle = nfs_fhandle_hash(args->fhandle);
+ 			__entry->error = error;
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d (%s) dev=%02x:%02x fhandle=0x%08x",
+ 			__entry->error,
+ 			show_nfsv4_errors(__entry->error),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			__entry->fhandle
+ 		)
+ );
+ 
+ DECLARE_EVENT_CLASS(nfs4_lookup_event,
+ 		TP_PROTO(
+ 			const struct inode *dir,
+ 			const struct qstr *name,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(dir, name, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(int, error)
+ 			__field(u64, dir)
+ 			__string(name, name->name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = dir->i_sb->s_dev;
+ 			__entry->dir = NFS_FILEID(dir);
+ 			__entry->error = error;
+ 			__assign_str(name, name->name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d (%s) name=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			show_nfsv4_errors(__entry->error),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->dir,
+ 			__get_str(name)
+ 		)
+ );
+ 
+ #define DEFINE_NFS4_LOOKUP_EVENT(name) \
+ 	DEFINE_EVENT(nfs4_lookup_event, name, \
+ 			TP_PROTO( \
+ 				const struct inode *dir, \
+ 				const struct qstr *name, \
+ 				int error \
+ 			), \
+ 			TP_ARGS(dir, name, error))
+ 
+ DEFINE_NFS4_LOOKUP_EVENT(nfs4_lookup);
+ DEFINE_NFS4_LOOKUP_EVENT(nfs4_symlink);
+ DEFINE_NFS4_LOOKUP_EVENT(nfs4_mkdir);
+ DEFINE_NFS4_LOOKUP_EVENT(nfs4_mknod);
+ DEFINE_NFS4_LOOKUP_EVENT(nfs4_remove);
+ DEFINE_NFS4_LOOKUP_EVENT(nfs4_get_fs_locations);
+ DEFINE_NFS4_LOOKUP_EVENT(nfs4_secinfo);
+ 
+ TRACE_EVENT(nfs4_rename,
+ 		TP_PROTO(
+ 			const struct inode *olddir,
+ 			const struct qstr *oldname,
+ 			const struct inode *newdir,
+ 			const struct qstr *newname,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(olddir, oldname, newdir, newname, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(int, error)
+ 			__field(u64, olddir)
+ 			__string(oldname, oldname->name)
+ 			__field(u64, newdir)
+ 			__string(newname, newname->name)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = olddir->i_sb->s_dev;
+ 			__entry->olddir = NFS_FILEID(olddir);
+ 			__entry->newdir = NFS_FILEID(newdir);
+ 			__entry->error = error;
+ 			__assign_str(oldname, oldname->name);
+ 			__assign_str(newname, newname->name);
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d (%s) oldname=%02x:%02x:%llu/%s "
+ 			"newname=%02x:%02x:%llu/%s",
+ 			__entry->error,
+ 			show_nfsv4_errors(__entry->error),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->olddir,
+ 			__get_str(oldname),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->newdir,
+ 			__get_str(newname)
+ 		)
+ );
+ 
+ DECLARE_EVENT_CLASS(nfs4_inode_event,
+ 		TP_PROTO(
+ 			const struct inode *inode,
+ 			int error
+ 		),
+ 
+ 		TP_ARGS(inode, error),
+ 
+ 		TP_STRUCT__entry(
+ 			__field(dev_t, dev)
+ 			__field(u32, fhandle)
+ 			__field(u64, fileid)
+ 			__field(int, error)
+ 		),
+ 
+ 		TP_fast_assign(
+ 			__entry->dev = inode->i_sb->s_dev;
+ 			__entry->fileid = NFS_FILEID(inode);
+ 			__entry->fhandle = nfs_fhandle_hash(NFS_FH(inode));
+ 			__entry->error = error;
+ 		),
+ 
+ 		TP_printk(
+ 			"error=%d (%s) fileid=%02x:%02x:%llu fhandle=0x%08x",
+ 			__entry->error,
+ 			show_nfsv4_errors(__entry->error),
+ 			MAJOR(__entry->dev), MINOR(__entry->dev),
+ 			(unsigned long long)__entry->fileid,
+ 			__entry->fhandle
+ 		)
+ );
+ 
+ #define DEFINE_NFS4_INODE_EVENT(name) \
+ 	DEFINE_EVENT(nfs4_inode_event, name, \
+ 			TP_PROTO( \
+ 				const struct inode *inode, \
+ 				int error \
+ 			), \
+ 			TP_ARGS(inode, error))
+ 
+ DEFINE_NFS4_INODE_EVENT(nfs4_setattr);
+ DEFINE_NFS4_INODE_EVENT(nfs4_access);
+ DEFINE_NFS4_INODE_EVENT(nfs4_readlink);
+ DEFINE_NFS4_INODE_EVENT(nfs4_readdir);
+ DEFINE_NFS4_INODE_EVENT(nfs4_get_acl);
+ DEFINE_NFS4_INODE_EVENT(nfs4_set_acl);
+ #ifdef CONFIG_NFS_V4_SECURITY_LABEL
+ DEFINE_NFS4_INODE_EVENT(nfs4_get_security_label);
+ DEFINE_NFS4_INODE_EVENT(nfs4_set_security_label);
+ #endif /* CONFIG_NFS_V4_SECURITY_LABEL */
+ DEFINE_NFS4_INODE_EVENT(nfs4_recall_delegation);
+ DEFINE_NFS4_INODE_EVENT(nfs4_delegreturn);
+ 
++>>>>>>> ca8acf8d8402 (NFSv4: Add tracepoints for debugging delegations)
  #endif /* _TRACE_NFS4_H */
  
  #undef TRACE_INCLUDE_PATH
diff --git a/fs/nfs/callback_proc.c b/fs/nfs/callback_proc.c
index e6ebc4c38c81..c0749305189b 100644
--- a/fs/nfs/callback_proc.c
+++ b/fs/nfs/callback_proc.c
@@ -15,6 +15,7 @@
 #include "internal.h"
 #include "pnfs.h"
 #include "nfs4session.h"
+#include "nfs4trace.h"
 
 #ifdef NFS_DEBUG
 #define NFSDBG_FACILITY NFSDBG_CALLBACK
@@ -93,6 +94,7 @@ __be32 nfs4_callback_recall(struct cb_recallargs *args, void *dummy,
 	default:
 		res = htonl(NFS4ERR_RESOURCE);
 	}
+	trace_nfs4_recall_delegation(inode, -ntohl(res));
 	iput(inode);
 out:
 	dprintk("%s: exit with status = %d\n", __func__, ntohl(res));
diff --git a/fs/nfs/delegation.c b/fs/nfs/delegation.c
index 7ec4814e298d..ef792f29f831 100644
--- a/fs/nfs/delegation.c
+++ b/fs/nfs/delegation.c
@@ -20,6 +20,7 @@
 #include "nfs4_fs.h"
 #include "delegation.h"
 #include "internal.h"
+#include "nfs4trace.h"
 
 static void nfs_free_delegation(struct nfs_delegation *delegation)
 {
@@ -160,6 +161,7 @@ void nfs_inode_reclaim_delegation(struct inode *inode, struct rpc_cred *cred,
 			spin_unlock(&delegation->lock);
 			put_rpccred(oldcred);
 			rcu_read_unlock();
+			trace_nfs4_reclaim_delegation(inode, res->delegation_type);
 		} else {
 			/* We appear to have raced with a delegation return. */
 			spin_unlock(&delegation->lock);
@@ -344,6 +346,7 @@ int nfs_inode_set_delegation(struct inode *inode, struct rpc_cred *cred, struct
 	spin_lock(&inode->i_lock);
 	nfsi->cache_validity |= NFS_INO_REVAL_FORCED;
 	spin_unlock(&inode->i_lock);
+	trace_nfs4_set_delegation(inode, res->delegation_type);
 
 out:
 	spin_unlock(&clp->cl_lock);
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index c7f16576f4bc..5eadb6022143 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -4445,6 +4445,7 @@ static void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)
 	if (!nfs4_sequence_done(task, &data->res.seq_res))
 		return;
 
+	trace_nfs4_delegreturn_exit(&data->args, &data->res, task->tk_status);
 	switch (task->tk_status) {
 	case -NFS4ERR_STALE_STATEID:
 	case -NFS4ERR_EXPIRED:
@@ -4548,6 +4549,7 @@ int nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4
 	int err;
 	do {
 		err = _nfs4_proc_delegreturn(inode, cred, stateid, issync);
+		trace_nfs4_delegreturn(inode, err);
 		switch (err) {
 			case -NFS4ERR_STALE_STATEID:
 			case -NFS4ERR_EXPIRED:
* Unmerged path fs/nfs/nfs4trace.h
