neigh: restore old behaviour of default parms values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit 1d4c8c29841b9991cdf3c7cc4ba7f96a94f104ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/1d4c8c29.failed

Previously inet devices were only constructed when addresses are added.
Therefore the default neigh parms values they get are the ones at the
time of these operations.

Now that we're creating inet devices earlier, this changes the behaviour
of default neigh parms values in an incompatible way (see bug #8519).

This patch creates a compromise by setting the default values at the
same point as before but only for those that have not been explicitly
set by the user since the inet device's creation.

Introduced by:
commit 8030f54499925d073a88c09f30d5d844fb1b3190
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Feb 22 01:53:47 2007 +0900

    [IPV4] devinet: Register inetdev earlier.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1d4c8c29841b9991cdf3c7cc4ba7f96a94f104ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/inetdevice.h
#	include/net/neighbour.h
#	net/core/neighbour.c
diff --cc include/linux/inetdevice.h
index d63403360f1c,ae174ca565c9..000000000000
--- a/include/linux/inetdevice.h
+++ b/include/linux/inetdevice.h
@@@ -245,7 -220,14 +245,18 @@@ static inline struct in_device *__in_de
  	return rtnl_dereference(dev->ip_ptr);
  }
  
++<<<<<<< HEAD
 +extern void in_dev_finish_destroy(struct in_device *idev);
++=======
+ static inline struct neigh_parms *__in_dev_arp_parms_get_rcu(const struct net_device *dev)
+ {
+ 	struct in_device *in_dev = __in_dev_get_rcu(dev);
+ 
+ 	return in_dev ? in_dev->arp_parms : NULL;
+ }
+ 
+ void in_dev_finish_destroy(struct in_device *idev);
++>>>>>>> 1d4c8c29841b (neigh: restore old behaviour of default parms values)
  
  static inline void in_dev_put(struct in_device *idev)
  {
diff --cc include/net/neighbour.h
index 7e748ad8b50c,41b1ce6c96a8..000000000000
--- a/include/net/neighbour.h
+++ b/include/net/neighbour.h
@@@ -53,22 -80,30 +54,48 @@@ struct neigh_parms 
  	atomic_t refcnt;
  	struct rcu_head rcu_head;
  
 +	int	base_reachable_time;
 +	int	retrans_time;
 +	int	gc_staletime;
  	int	reachable_time;
++<<<<<<< HEAD
 +	int	delay_probe_time;
 +
 +	int	queue_len_bytes;
 +	int	ucast_probes;
 +	int	app_probes;
 +	int	mcast_probes;
 +	int	anycast_delay;
 +	int	proxy_delay;
 +	int	proxy_qlen;
 +	int	locktime;
 +};
 +
++=======
+ 	int	data[NEIGH_VAR_DATA_MAX];
+ 	DECLARE_BITMAP(data_state, NEIGH_VAR_DATA_MAX);
+ };
+ 
+ static inline void neigh_var_set(struct neigh_parms *p, int index, int val)
+ {
+ 	set_bit(index, p->data_state);
+ 	p->data[index] = val;
+ }
+ 
+ #define NEIGH_VAR(p, attr) ((p)->data[NEIGH_VAR_ ## attr])
+ #define NEIGH_VAR_SET(p, attr, val) neigh_var_set(p, NEIGH_VAR_ ## attr, val)
+ 
+ static inline void neigh_parms_data_state_setall(struct neigh_parms *p)
+ {
+ 	bitmap_fill(p->data_state, NEIGH_VAR_DATA_MAX);
+ }
+ 
+ static inline void neigh_parms_data_state_cleanall(struct neigh_parms *p)
+ {
+ 	bitmap_zero(p->data_state, NEIGH_VAR_DATA_MAX);
+ }
+ 
++>>>>>>> 1d4c8c29841b (neigh: restore old behaviour of default parms values)
  struct neigh_statistics {
  	unsigned long allocs;		/* number of allocated neighs */
  	unsigned long destroys;		/* number of destroyed neighs */
diff --cc net/core/neighbour.c
index 05242ae7bdcf,c4a7879bfb15..000000000000
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@@ -2782,28 -2816,142 +2785,167 @@@ static int proc_unres_qlen(ctl_table *c
  	return ret;
  }
  
++<<<<<<< HEAD
 +enum {
 +	NEIGH_VAR_MCAST_PROBE,
 +	NEIGH_VAR_UCAST_PROBE,
 +	NEIGH_VAR_APP_PROBE,
 +	NEIGH_VAR_RETRANS_TIME,
 +	NEIGH_VAR_BASE_REACHABLE_TIME,
 +	NEIGH_VAR_DELAY_PROBE_TIME,
 +	NEIGH_VAR_GC_STALETIME,
 +	NEIGH_VAR_QUEUE_LEN,
 +	NEIGH_VAR_QUEUE_LEN_BYTES,
 +	NEIGH_VAR_PROXY_QLEN,
 +	NEIGH_VAR_ANYCAST_DELAY,
 +	NEIGH_VAR_PROXY_DELAY,
 +	NEIGH_VAR_LOCKTIME,
 +	NEIGH_VAR_RETRANS_TIME_MS,
 +	NEIGH_VAR_BASE_REACHABLE_TIME_MS,
 +	NEIGH_VAR_GC_INTERVAL,
 +	NEIGH_VAR_GC_THRESH1,
 +	NEIGH_VAR_GC_THRESH2,
 +	NEIGH_VAR_GC_THRESH3,
 +	NEIGH_VAR_MAX
 +};
++=======
+ static struct neigh_parms *neigh_get_dev_parms_rcu(struct net_device *dev,
+ 						   int family)
+ {
+ 	if (family == AF_INET)
+ 		return __in_dev_arp_parms_get_rcu(dev);
+ 	return NULL;
+ }
+ 
+ static void neigh_copy_dflt_parms(struct net *net, struct neigh_parms *p,
+ 				  int index)
+ {
+ 	struct net_device *dev;
+ 	int family = neigh_parms_family(p);
+ 
+ 	rcu_read_lock();
+ 	for_each_netdev_rcu(net, dev) {
+ 		struct neigh_parms *dst_p =
+ 				neigh_get_dev_parms_rcu(dev, family);
+ 
+ 		if (dst_p && !test_bit(index, dst_p->data_state))
+ 			dst_p->data[index] = p->data[index];
+ 	}
+ 	rcu_read_unlock();
+ }
+ 
+ static void neigh_proc_update(struct ctl_table *ctl, int write)
+ {
+ 	struct net_device *dev = ctl->extra1;
+ 	struct neigh_parms *p = ctl->extra2;
+ 	struct net *net = p->net;
+ 	int index = (int *) ctl->data - p->data;
+ 
+ 	if (!write)
+ 		return;
+ 
+ 	set_bit(index, p->data_state);
+ 	if (!dev) /* NULL dev means this is default value */
+ 		neigh_copy_dflt_parms(net, p, index);
+ }
+ 
+ static int neigh_proc_dointvec_zero_intmax(struct ctl_table *ctl, int write,
+ 					   void __user *buffer,
+ 					   size_t *lenp, loff_t *ppos)
+ {
+ 	struct ctl_table tmp = *ctl;
+ 	int ret;
+ 
+ 	tmp.extra1 = &zero;
+ 	tmp.extra2 = &int_max;
+ 
+ 	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ 
+ int neigh_proc_dointvec(struct ctl_table *ctl, int write,
+ 			void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec);
+ 
+ int neigh_proc_dointvec_jiffies(struct ctl_table *ctl, int write,
+ 				void __user *buffer,
+ 				size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_dointvec_jiffies(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec_jiffies);
+ 
+ static int neigh_proc_dointvec_userhz_jiffies(struct ctl_table *ctl, int write,
+ 					      void __user *buffer,
+ 					      size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_dointvec_userhz_jiffies(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ 
+ int neigh_proc_dointvec_ms_jiffies(struct ctl_table *ctl, int write,
+ 				   void __user *buffer,
+ 				   size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_dointvec_ms_jiffies(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(neigh_proc_dointvec_ms_jiffies);
+ 
+ static int neigh_proc_dointvec_unres_qlen(struct ctl_table *ctl, int write,
+ 					  void __user *buffer,
+ 					  size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = proc_unres_qlen(ctl, write, buffer, lenp, ppos);
+ 
+ 	neigh_proc_update(ctl, write);
+ 	return ret;
+ }
+ 
+ #define NEIGH_PARMS_DATA_OFFSET(index)	\
+ 	(&((struct neigh_parms *) 0)->data[index])
+ 
+ #define NEIGH_SYSCTL_ENTRY(attr, data_attr, name, mval, proc) \
+ 	[NEIGH_VAR_ ## attr] = { \
+ 		.procname	= name, \
+ 		.data		= NEIGH_PARMS_DATA_OFFSET(NEIGH_VAR_ ## data_attr), \
+ 		.maxlen		= sizeof(int), \
+ 		.mode		= mval, \
+ 		.proc_handler	= proc, \
+ 	}
+ 
+ #define NEIGH_SYSCTL_ZERO_INTMAX_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_zero_intmax)
+ 
+ #define NEIGH_SYSCTL_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_jiffies)
+ 
+ #define NEIGH_SYSCTL_USERHZ_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_userhz_jiffies)
+ 
+ #define NEIGH_SYSCTL_MS_JIFFIES_ENTRY(attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, attr, name, 0644, neigh_proc_dointvec_ms_jiffies)
+ 
+ #define NEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(attr, data_attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, data_attr, name, 0644, neigh_proc_dointvec_ms_jiffies)
+ 
+ #define NEIGH_SYSCTL_UNRES_QLEN_REUSED_ENTRY(attr, data_attr, name) \
+ 	NEIGH_SYSCTL_ENTRY(attr, data_attr, name, 0644, neigh_proc_dointvec_unres_qlen)
++>>>>>>> 1d4c8c29841b (neigh: restore old behaviour of default parms values)
  
  static struct neigh_sysctl_table {
  	struct ctl_table_header *sysctl_header;
@@@ -2954,21 -3020,11 +3096,29 @@@ int neigh_sysctl_register(struct net_de
  	if (!t)
  		goto err;
  
++<<<<<<< HEAD
 +	t->neigh_vars[NEIGH_VAR_MCAST_PROBE].data  = &p->mcast_probes;
 +	t->neigh_vars[NEIGH_VAR_UCAST_PROBE].data  = &p->ucast_probes;
 +	t->neigh_vars[NEIGH_VAR_APP_PROBE].data  = &p->app_probes;
 +	t->neigh_vars[NEIGH_VAR_RETRANS_TIME].data  = &p->retrans_time;
 +	t->neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME].data  = &p->base_reachable_time;
 +	t->neigh_vars[NEIGH_VAR_DELAY_PROBE_TIME].data  = &p->delay_probe_time;
 +	t->neigh_vars[NEIGH_VAR_GC_STALETIME].data  = &p->gc_staletime;
 +	t->neigh_vars[NEIGH_VAR_QUEUE_LEN].data  = &p->queue_len_bytes;
 +	t->neigh_vars[NEIGH_VAR_QUEUE_LEN_BYTES].data  = &p->queue_len_bytes;
 +	t->neigh_vars[NEIGH_VAR_PROXY_QLEN].data  = &p->proxy_qlen;
 +	t->neigh_vars[NEIGH_VAR_ANYCAST_DELAY].data  = &p->anycast_delay;
 +	t->neigh_vars[NEIGH_VAR_PROXY_DELAY].data = &p->proxy_delay;
 +	t->neigh_vars[NEIGH_VAR_LOCKTIME].data = &p->locktime;
 +	t->neigh_vars[NEIGH_VAR_RETRANS_TIME_MS].data  = &p->retrans_time;
 +	t->neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME_MS].data  = &p->base_reachable_time;
++=======
+ 	for (i = 0; i < ARRAY_SIZE(t->neigh_vars); i++) {
+ 		t->neigh_vars[i].data += (long) p;
+ 		t->neigh_vars[i].extra1 = dev;
+ 		t->neigh_vars[i].extra2 = p;
+ 	}
++>>>>>>> 1d4c8c29841b (neigh: restore old behaviour of default parms values)
  
  	if (dev) {
  		dev_name_source = dev->name;
* Unmerged path include/linux/inetdevice.h
* Unmerged path include/net/neighbour.h
* Unmerged path net/core/neighbour.c
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index 6638cd21577f..b4e2bed3f761 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -496,6 +496,7 @@ static int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)
 		return -ENOBUFS;
 	}
 	ipv4_devconf_setall(in_dev);
+	neigh_parms_data_state_setall(in_dev->arp_parms);
 	if (ifa->ifa_dev != in_dev) {
 		WARN_ON(ifa->ifa_dev);
 		in_dev_hold(in_dev);
@@ -743,6 +744,7 @@ static struct in_ifaddr *rtm_to_ifaddr(struct net *net, struct nlmsghdr *nlh,
 		goto errout;
 
 	ipv4_devconf_setall(in_dev);
+	neigh_parms_data_state_setall(in_dev->arp_parms);
 	in_dev_hold(in_dev);
 
 	if (tb[IFA_ADDRESS] == NULL)
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 9d9610ae7855..09c262d86e62 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -425,6 +425,7 @@ struct net_device *ipmr_new_tunnel(struct net *net, struct vifctl *v)
 				goto failure;
 
 			ipv4_devconf_setall(in_dev);
+			neigh_parms_data_state_setall(in_dev->arp_parms);
 			IPV4_DEVCONF(in_dev->cnf, RP_FILTER) = 0;
 
 			if (dev_open(dev))
@@ -517,6 +518,7 @@ static struct net_device *ipmr_reg_vif(struct net *net, struct mr_table *mrt)
 	}
 
 	ipv4_devconf_setall(in_dev);
+	neigh_parms_data_state_setall(in_dev->arp_parms);
 	IPV4_DEVCONF(in_dev->cnf, RP_FILTER) = 0;
 	rcu_read_unlock();
 
