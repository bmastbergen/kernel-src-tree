blk-throttle: implement sq_to_tg(), sq_to_td() and throtl_log()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [block] blk-throttle: move bio_lists[], implement sq_to_tg(), sq_to_td() and throtl_log() (Vivek Goyal) [1015648]
Rebuild_FUZZ: 87.50%
commit-author Tejun Heo <tj@kernel.org>
commit fda6f272c77a7acd798bb247fadc4791574e698b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/fda6f272.failed

Now that both throtl_data and throtl_grp embed throtl_service_queue,
we can unify throtl_log() and throtl_log_tg().

* sq_to_tg() is added.  This returns the throtl_grp a service_queue is
  embedded in.  If the service_queue is the top-level one embedded in
  throtl_data, NULL is returned.

* sq_to_td() is added.  A service_queue is always associated with a
  throtl_data.  This function finds the associated td and returns it.

* throtl_log() is updated to take throtl_service_queue instead of
  throtl_data.  If the service_queue is one embedded in throtl_grp, it
  prints the same header as throtl_log_tg() did.  If it's one embedded
  in throtl_data, it behaves the same as before.  This renders
  throtl_log_tg() unnecessary.  Removed.

This change is necessary for hierarchy support as we're gonna be using
the same code paths to dispatch bios to intermediate service_queues
embedded in throtl_grps and the top-level service_queue embedded in
throtl_data.

This patch doesn't make any behavior changes.

v2: throtl_log() didn't print a space after blkg path.  Updated so
    that it prints a space after throtl_grp path.  Spotted by Vivek.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Acked-by: Vivek Goyal <vgoyal@redhat.com>
(cherry picked from commit fda6f272c77a7acd798bb247fadc4791574e698b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-throttle.c
diff --cc block/blk-throttle.c
index e65e45a33372,2875ff66e1b9..000000000000
--- a/block/blk-throttle.c
+++ b/block/blk-throttle.c
@@@ -857,10 -908,15 +909,20 @@@ void blk_throtl_dispatch_work_fn(struc
  		   td->nr_queued[READ] + td->nr_queued[WRITE],
  		   td->nr_queued[READ], td->nr_queued[WRITE]);
  
 -	nr_disp = throtl_select_dispatch(sq);
 +	nr_disp = throtl_select_dispatch(&td->service_queue, &bio_list_on_stack);
  
++<<<<<<< HEAD
 +	if (nr_disp)
 +		throtl_log(td, "bios disp=%u", nr_disp);
++=======
+ 	if (nr_disp) {
+ 		for (rw = READ; rw <= WRITE; rw++) {
+ 			bio_list_merge(&bio_list_on_stack, &sq->bio_lists[rw]);
+ 			bio_list_init(&sq->bio_lists[rw]);
+ 		}
+ 		throtl_log(sq, "bios disp=%u", nr_disp);
+ 	}
++>>>>>>> fda6f272c77a (blk-throttle: implement sq_to_tg(), sq_to_td() and throtl_log())
  
  	throtl_schedule_next_dispatch(td);
  
@@@ -1127,15 -1184,14 +1190,14 @@@ bool blk_throtl_bio(struct request_queu
  	}
  
  queue_bio:
- 	throtl_log_tg(tg, "[%c] bio. bdisp=%llu sz=%u bps=%llu"
- 			" iodisp=%u iops=%u queued=%d/%d",
- 			rw == READ ? 'R' : 'W',
- 			tg->bytes_disp[rw], bio->bi_size, tg->bps[rw],
- 			tg->io_disp[rw], tg->iops[rw],
- 			sq->nr_queued[READ], sq->nr_queued[WRITE]);
+ 	throtl_log(sq, "[%c] bio. bdisp=%llu sz=%u bps=%llu iodisp=%u iops=%u queued=%d/%d",
+ 		   rw == READ ? 'R' : 'W',
+ 		   tg->bytes_disp[rw], bio->bi_size, tg->bps[rw],
+ 		   tg->io_disp[rw], tg->iops[rw],
+ 		   sq->nr_queued[READ], sq->nr_queued[WRITE]);
  
  	bio_associate_current(bio);
 -	throtl_add_bio_tg(bio, tg);
 +	throtl_add_bio_tg(bio, tg, &q->td->service_queue);
  	throttled = true;
  
  	/* update @tg's dispatch time if @tg was empty before @bio */
* Unmerged path block/blk-throttle.c
