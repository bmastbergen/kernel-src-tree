mm: keep page cache radix tree nodes in check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [mm] keep page cache radix tree nodes in check (Johannes Weiner) [1062372]
Rebuild_FUZZ: 95.35%
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 449dd6984d0e47643c04c807f609dd56d48d5bcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/449dd698.failed

Previously, page cache radix tree nodes were freed after reclaim emptied
out their page pointers.  But now reclaim stores shadow entries in their
place, which are only reclaimed when the inodes themselves are
reclaimed.  This is problematic for bigger files that are still in use
after they have a significant amount of their cache reclaimed, without
any of those pages actually refaulting.  The shadow entries will just
sit there and waste memory.  In the worst case, the shadow entries will
accumulate until the machine runs out of memory.

To get this under control, the VM will track radix tree nodes
exclusively containing shadow entries on a per-NUMA node list.  Per-NUMA
rather than global because we expect the radix tree nodes themselves to
be allocated node-locally and we want to reduce cross-node references of
otherwise independent cache workloads.  A simple shrinker will then
reclaim these nodes on memory pressure.

A few things need to be stored in the radix tree node to implement the
shadow node LRU and allow tree deletions coming from the list:

1. There is no index available that would describe the reverse path
   from the node up to the tree root, which is needed to perform a
   deletion.  To solve this, encode in each node its offset inside the
   parent.  This can be stored in the unused upper bits of the same
   member that stores the node's height at no extra space cost.

2. The number of shadow entries needs to be counted in addition to the
   regular entries, to quickly detect when the node is ready to go to
   the shadow node LRU list.  The current entry count is an unsigned
   int but the maximum number of entries is 64, so a shadow counter
   can easily be stored in the unused upper bits.

3. Tree modification needs tree lock and tree root, which are located
   in the address space, so store an address_space backpointer in the
   node.  The parent pointer of the node is in a union with the 2-word
   rcu_head, so the backpointer comes at no extra cost as well.

4. The node needs to be linked to an LRU list, which requires a list
   head inside the node.  This does increase the size of the node, but
   it does not change the number of objects that fit into a slab page.

[akpm@linux-foundation.org: export the right function]
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Reviewed-by: Rik van Riel <riel@redhat.com>
	Reviewed-by: Minchan Kim <minchan@kernel.org>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Bob Liu <bob.liu@oracle.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Greg Thelen <gthelen@google.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Jan Kara <jack@suse.cz>
	Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
	Cc: Luigi Semenzato <semenzato@google.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Metin Doslu <metin@citusdata.com>
	Cc: Michel Lespinasse <walken@google.com>
	Cc: Ozgun Erdogan <ozgun@citusdata.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Roman Gushchin <klamm@yandex-team.ru>
	Cc: Ryan Mallon <rmallon@gmail.com>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 449dd6984d0e47643c04c807f609dd56d48d5bcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/list_lru.h
#	include/linux/mmzone.h
#	include/linux/swap.h
#	lib/radix-tree.c
#	mm/filemap.c
#	mm/list_lru.c
#	mm/truncate.c
#	mm/vmstat.c
#	mm/workingset.c
diff --cc include/linux/mmzone.h
index 493d0844aa75,fac5509c18f0..000000000000
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@@ -142,6 -142,9 +142,12 @@@ enum zone_stat_item 
  	NUMA_LOCAL,		/* allocation from local node */
  	NUMA_OTHER,		/* allocation from other node */
  #endif
++<<<<<<< HEAD
++=======
+ 	WORKINGSET_REFAULT,
+ 	WORKINGSET_ACTIVATE,
+ 	WORKINGSET_NODERECLAIM,
++>>>>>>> 449dd6984d0e (mm: keep page cache radix tree nodes in check)
  	NR_ANON_TRANSPARENT_HUGEPAGES,
  	NR_FREE_CMA_PAGES,
  	NR_VM_ZONE_STAT_ITEMS };
diff --cc include/linux/swap.h
index 85d74373002c,350711560753..000000000000
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@@ -222,6 -260,42 +222,45 @@@ struct swap_list_t 
  	int next;	/* swapfile to be used next */
  };
  
++<<<<<<< HEAD
++=======
+ /* linux/mm/workingset.c */
+ void *workingset_eviction(struct address_space *mapping, struct page *page);
+ bool workingset_refault(void *shadow);
+ void workingset_activation(struct page *page);
+ extern struct list_lru workingset_shadow_nodes;
+ 
+ static inline unsigned int workingset_node_pages(struct radix_tree_node *node)
+ {
+ 	return node->count & RADIX_TREE_COUNT_MASK;
+ }
+ 
+ static inline void workingset_node_pages_inc(struct radix_tree_node *node)
+ {
+ 	node->count++;
+ }
+ 
+ static inline void workingset_node_pages_dec(struct radix_tree_node *node)
+ {
+ 	node->count--;
+ }
+ 
+ static inline unsigned int workingset_node_shadows(struct radix_tree_node *node)
+ {
+ 	return node->count >> RADIX_TREE_COUNT_SHIFT;
+ }
+ 
+ static inline void workingset_node_shadows_inc(struct radix_tree_node *node)
+ {
+ 	node->count += 1U << RADIX_TREE_COUNT_SHIFT;
+ }
+ 
+ static inline void workingset_node_shadows_dec(struct radix_tree_node *node)
+ {
+ 	node->count -= 1U << RADIX_TREE_COUNT_SHIFT;
+ }
+ 
++>>>>>>> 449dd6984d0e (mm: keep page cache radix tree nodes in check)
  /* linux/mm/page_alloc.c */
  extern unsigned long totalram_pages;
  extern unsigned long totalreserve_pages;
diff --cc lib/radix-tree.c
index 8f3c6282e1d3,9599aa72d7a0..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -1168,9 -1208,12 +1171,16 @@@ unsigned long radix_tree_locate_item(st
  		}
  
  		node = indirect_to_ptr(node);
++<<<<<<< HEAD
 +		max_index = radix_tree_maxindex(node->height);
 +		if (cur_index > max_index)
++=======
+ 		max_index = radix_tree_maxindex(node->path &
+ 						RADIX_TREE_HEIGHT_MASK);
+ 		if (cur_index > max_index) {
+ 			rcu_read_unlock();
++>>>>>>> 449dd6984d0e (mm: keep page cache radix tree nodes in check)
  			break;
 -		}
  
  		cur_index = __locate(node, item, cur_index, &found_index);
  		rcu_read_unlock();
diff --cc mm/filemap.c
index 844f5d8d25f6,d6df3bacb0fb..000000000000
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@@ -107,6 -107,69 +107,72 @@@
   *   ->tasklist_lock            (memory_failure, collect_procs_ao)
   */
  
++<<<<<<< HEAD
++=======
+ static void page_cache_tree_delete(struct address_space *mapping,
+ 				   struct page *page, void *shadow)
+ {
+ 	struct radix_tree_node *node;
+ 	unsigned long index;
+ 	unsigned int offset;
+ 	unsigned int tag;
+ 	void **slot;
+ 
+ 	VM_BUG_ON(!PageLocked(page));
+ 
+ 	__radix_tree_lookup(&mapping->page_tree, page->index, &node, &slot);
+ 
+ 	if (shadow) {
+ 		mapping->nrshadows++;
+ 		/*
+ 		 * Make sure the nrshadows update is committed before
+ 		 * the nrpages update so that final truncate racing
+ 		 * with reclaim does not see both counters 0 at the
+ 		 * same time and miss a shadow entry.
+ 		 */
+ 		smp_wmb();
+ 	}
+ 	mapping->nrpages--;
+ 
+ 	if (!node) {
+ 		/* Clear direct pointer tags in root node */
+ 		mapping->page_tree.gfp_mask &= __GFP_BITS_MASK;
+ 		radix_tree_replace_slot(slot, shadow);
+ 		return;
+ 	}
+ 
+ 	/* Clear tree tags for the removed page */
+ 	index = page->index;
+ 	offset = index & RADIX_TREE_MAP_MASK;
+ 	for (tag = 0; tag < RADIX_TREE_MAX_TAGS; tag++) {
+ 		if (test_bit(offset, node->tags[tag]))
+ 			radix_tree_tag_clear(&mapping->page_tree, index, tag);
+ 	}
+ 
+ 	/* Delete page, swap shadow entry */
+ 	radix_tree_replace_slot(slot, shadow);
+ 	workingset_node_pages_dec(node);
+ 	if (shadow)
+ 		workingset_node_shadows_inc(node);
+ 	else
+ 		if (__radix_tree_delete_node(&mapping->page_tree, node))
+ 			return;
+ 
+ 	/*
+ 	 * Track node that only contains shadow entries.
+ 	 *
+ 	 * Avoid acquiring the list_lru lock if already tracked.  The
+ 	 * list_empty() test is safe as node->private_list is
+ 	 * protected by mapping->tree_lock.
+ 	 */
+ 	if (!workingset_node_pages(node) &&
+ 	    list_empty(&node->private_list)) {
+ 		node->private_data = mapping;
+ 		list_lru_add(&workingset_shadow_nodes, &node->private_list);
+ 	}
+ }
+ 
++>>>>>>> 449dd6984d0e (mm: keep page cache radix tree nodes in check)
  /*
   * Delete a page from the page cache and free it. Caller has to make
   * sure the page is locked and that nobody else uses it - or that usage
@@@ -446,6 -510,91 +512,94 @@@ int replace_page_cache_page(struct pag
  }
  EXPORT_SYMBOL_GPL(replace_page_cache_page);
  
++<<<<<<< HEAD
++=======
+ static int page_cache_tree_insert(struct address_space *mapping,
+ 				  struct page *page, void **shadowp)
+ {
+ 	struct radix_tree_node *node;
+ 	void **slot;
+ 	int error;
+ 
+ 	error = __radix_tree_create(&mapping->page_tree, page->index,
+ 				    &node, &slot);
+ 	if (error)
+ 		return error;
+ 	if (*slot) {
+ 		void *p;
+ 
+ 		p = radix_tree_deref_slot_protected(slot, &mapping->tree_lock);
+ 		if (!radix_tree_exceptional_entry(p))
+ 			return -EEXIST;
+ 		if (shadowp)
+ 			*shadowp = p;
+ 		mapping->nrshadows--;
+ 		if (node)
+ 			workingset_node_shadows_dec(node);
+ 	}
+ 	radix_tree_replace_slot(slot, page);
+ 	mapping->nrpages++;
+ 	if (node) {
+ 		workingset_node_pages_inc(node);
+ 		/*
+ 		 * Don't track node that contains actual pages.
+ 		 *
+ 		 * Avoid acquiring the list_lru lock if already
+ 		 * untracked.  The list_empty() test is safe as
+ 		 * node->private_list is protected by
+ 		 * mapping->tree_lock.
+ 		 */
+ 		if (!list_empty(&node->private_list))
+ 			list_lru_del(&workingset_shadow_nodes,
+ 				     &node->private_list);
+ 	}
+ 	return 0;
+ }
+ 
+ static int __add_to_page_cache_locked(struct page *page,
+ 				      struct address_space *mapping,
+ 				      pgoff_t offset, gfp_t gfp_mask,
+ 				      void **shadowp)
+ {
+ 	int error;
+ 
+ 	VM_BUG_ON_PAGE(!PageLocked(page), page);
+ 	VM_BUG_ON_PAGE(PageSwapBacked(page), page);
+ 
+ 	error = mem_cgroup_cache_charge(page, current->mm,
+ 					gfp_mask & GFP_RECLAIM_MASK);
+ 	if (error)
+ 		return error;
+ 
+ 	error = radix_tree_maybe_preload(gfp_mask & ~__GFP_HIGHMEM);
+ 	if (error) {
+ 		mem_cgroup_uncharge_cache_page(page);
+ 		return error;
+ 	}
+ 
+ 	page_cache_get(page);
+ 	page->mapping = mapping;
+ 	page->index = offset;
+ 
+ 	spin_lock_irq(&mapping->tree_lock);
+ 	error = page_cache_tree_insert(mapping, page, shadowp);
+ 	radix_tree_preload_end();
+ 	if (unlikely(error))
+ 		goto err_insert;
+ 	__inc_zone_page_state(page, NR_FILE_PAGES);
+ 	spin_unlock_irq(&mapping->tree_lock);
+ 	trace_mm_filemap_add_to_page_cache(page);
+ 	return 0;
+ err_insert:
+ 	page->mapping = NULL;
+ 	/* Leave page->index set: truncation relies upon it */
+ 	spin_unlock_irq(&mapping->tree_lock);
+ 	mem_cgroup_uncharge_cache_page(page);
+ 	page_cache_release(page);
+ 	return error;
+ }
+ 
++>>>>>>> 449dd6984d0e (mm: keep page cache radix tree nodes in check)
  /**
   * add_to_page_cache_locked - add a locked page to the pagecache
   * @page:	page to add
diff --cc mm/truncate.c
index c75b736e54b7,e5cc39ab0751..000000000000
--- a/mm/truncate.c
+++ b/mm/truncate.c
@@@ -22,6 -22,45 +22,48 @@@
  #include <linux/cleancache.h>
  #include "internal.h"
  
++<<<<<<< HEAD
++=======
+ static void clear_exceptional_entry(struct address_space *mapping,
+ 				    pgoff_t index, void *entry)
+ {
+ 	struct radix_tree_node *node;
+ 	void **slot;
+ 
+ 	/* Handled by shmem itself */
+ 	if (shmem_mapping(mapping))
+ 		return;
+ 
+ 	spin_lock_irq(&mapping->tree_lock);
+ 	/*
+ 	 * Regular page slots are stabilized by the page lock even
+ 	 * without the tree itself locked.  These unlocked entries
+ 	 * need verification under the tree lock.
+ 	 */
+ 	if (!__radix_tree_lookup(&mapping->page_tree, index, &node, &slot))
+ 		goto unlock;
+ 	if (*slot != entry)
+ 		goto unlock;
+ 	radix_tree_replace_slot(slot, NULL);
+ 	mapping->nrshadows--;
+ 	if (!node)
+ 		goto unlock;
+ 	workingset_node_shadows_dec(node);
+ 	/*
+ 	 * Don't track node without shadow entries.
+ 	 *
+ 	 * Avoid acquiring the list_lru lock if already untracked.
+ 	 * The list_empty() test is safe as node->private_list is
+ 	 * protected by mapping->tree_lock.
+ 	 */
+ 	if (!workingset_node_shadows(node) &&
+ 	    !list_empty(&node->private_list))
+ 		list_lru_del(&workingset_shadow_nodes, &node->private_list);
+ 	__radix_tree_delete_node(&mapping->page_tree, node);
+ unlock:
+ 	spin_unlock_irq(&mapping->tree_lock);
+ }
++>>>>>>> 449dd6984d0e (mm: keep page cache radix tree nodes in check)
  
  /**
   * do_invalidatepage - invalidate part or all of a page
diff --cc mm/vmstat.c
index 4a69ef011d72,f3155d51acfd..000000000000
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@@ -738,6 -770,9 +738,12 @@@ const char * const vmstat_text[] = 
  	"numa_local",
  	"numa_other",
  #endif
++<<<<<<< HEAD
++=======
+ 	"workingset_refault",
+ 	"workingset_activate",
+ 	"workingset_nodereclaim",
++>>>>>>> 449dd6984d0e (mm: keep page cache radix tree nodes in check)
  	"nr_anon_transparent_hugepages",
  	"nr_free_cma",
  	"nr_dirty_threshold",
* Unmerged path include/linux/list_lru.h
* Unmerged path mm/list_lru.c
* Unmerged path mm/workingset.c
* Unmerged path include/linux/list_lru.h
* Unmerged path include/linux/mmzone.h
diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h
index 9c5234ed7ebc..914457384ab1 100644
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@ -72,21 +72,37 @@ static inline int radix_tree_is_indirect_ptr(void *ptr)
 #define RADIX_TREE_TAG_LONGS	\
 	((RADIX_TREE_MAP_SIZE + BITS_PER_LONG - 1) / BITS_PER_LONG)
 
+#define RADIX_TREE_INDEX_BITS  (8 /* CHAR_BIT */ * sizeof(unsigned long))
+#define RADIX_TREE_MAX_PATH (DIV_ROUND_UP(RADIX_TREE_INDEX_BITS, \
+					  RADIX_TREE_MAP_SHIFT))
+
+/* Height component in node->path */
+#define RADIX_TREE_HEIGHT_SHIFT	(RADIX_TREE_MAX_PATH + 1)
+#define RADIX_TREE_HEIGHT_MASK	((1UL << RADIX_TREE_HEIGHT_SHIFT) - 1)
+
+/* Internally used bits of node->count */
+#define RADIX_TREE_COUNT_SHIFT	(RADIX_TREE_MAP_SHIFT + 1)
+#define RADIX_TREE_COUNT_MASK	((1UL << RADIX_TREE_COUNT_SHIFT) - 1)
+
 struct radix_tree_node {
-	unsigned int	height;		/* Height from the bottom */
+	unsigned int	path;	/* Offset in parent & height from the bottom */
 	unsigned int	count;
 	union {
-		struct radix_tree_node *parent;	/* Used when ascending tree */
-		struct rcu_head	rcu_head;	/* Used when freeing node */
+		struct {
+			/* Used when ascending tree */
+			struct radix_tree_node *parent;
+			/* For tree user */
+			void *private_data;
+		};
+		/* Used when freeing node */
+		struct rcu_head	rcu_head;
 	};
+	/* For tree user */
+	struct list_head private_list;
 	void __rcu	*slots[RADIX_TREE_MAP_SIZE];
 	unsigned long	tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];
 };
 
-#define RADIX_TREE_INDEX_BITS  (8 /* CHAR_BIT */ * sizeof(unsigned long))
-#define RADIX_TREE_MAX_PATH (DIV_ROUND_UP(RADIX_TREE_INDEX_BITS, \
-					  RADIX_TREE_MAP_SHIFT))
-
 /* root tags are stored in gfp_mask, shifted by __GFP_BITS_SHIFT */
 struct radix_tree_root {
 	unsigned int		height;
@@ -251,7 +267,7 @@ void *__radix_tree_lookup(struct radix_tree_root *root, unsigned long index,
 			  struct radix_tree_node **nodep, void ***slotp);
 void *radix_tree_lookup(struct radix_tree_root *, unsigned long);
 void **radix_tree_lookup_slot(struct radix_tree_root *, unsigned long);
-bool __radix_tree_delete_node(struct radix_tree_root *root, unsigned long index,
+bool __radix_tree_delete_node(struct radix_tree_root *root,
 			      struct radix_tree_node *node);
 void *radix_tree_delete_item(struct radix_tree_root *, unsigned long, void *);
 void *radix_tree_delete(struct radix_tree_root *, unsigned long);
* Unmerged path include/linux/swap.h
* Unmerged path lib/radix-tree.c
* Unmerged path mm/filemap.c
* Unmerged path mm/list_lru.c
* Unmerged path mm/truncate.c
* Unmerged path mm/vmstat.c
* Unmerged path mm/workingset.c
