btrfs: don't loop on large offsets in readdir

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Zach Brown <zab@redhat.com>
commit db62efbbf883c099d44b0fafe18f8ad8f0396892
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/db62efbb.failed

When btrfs readdir() hits the last entry it sets the readdir offset to a
huge value to stop buggy apps from breaking when the same name is
returned by readdir() with concurrent rename()s.

But unconditionally setting the offset to INT_MAX causes readdir() to
loop returning any entries with offsets past INT_MAX.  It only takes a
few hours of constant file creation and removal to create entries past
INT_MAX.

So let's set the huge offset to LLONG_MAX if the last entry has already
overflowed 32bit loff_t.   Without large offsets behaviour is identical.
With large offsets 64bit apps will work and 32bit apps will be no more
broken than they currently are if they see large offsets.

	Signed-off-by: Zach Brown <zab@redhat.com>
	Signed-off-by: Josef Bacik <jbacik@fusionio.com>
	Signed-off-by: Chris Mason <chris.mason@fusionio.com>
(cherry picked from commit db62efbbf883c099d44b0fafe18f8ad8f0396892)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/inode.c
diff --cc fs/btrfs/inode.c
index 2ffa09f678db,021694c08181..000000000000
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@@ -5187,14 -5170,31 +5187,42 @@@ next
  	}
  
  	/* Reached end of directory/root. Bump pos past the last item. */
++<<<<<<< HEAD
 +	if (key_type == BTRFS_DIR_INDEX_KEY)
 +		/*
 +		 * 32-bit glibc will use getdents64, but then strtol -
 +		 * so the last number we can serve is this.
 +		 */
 +		filp->f_pos = 0x7fffffff;
 +	else
 +		filp->f_pos++;
++=======
+ 	ctx->pos++;
+ 
+ 	/*
+ 	 * Stop new entries from being returned after we return the last
+ 	 * entry.
+ 	 *
+ 	 * New directory entries are assigned a strictly increasing
+ 	 * offset.  This means that new entries created during readdir
+ 	 * are *guaranteed* to be seen in the future by that readdir.
+ 	 * This has broken buggy programs which operate on names as
+ 	 * they're returned by readdir.  Until we re-use freed offsets
+ 	 * we have this hack to stop new entries from being returned
+ 	 * under the assumption that they'll never reach this huge
+ 	 * offset.
+ 	 *
+ 	 * This is being careful not to overflow 32bit loff_t unless the
+ 	 * last entry requires it because doing so has broken 32bit apps
+ 	 * in the past.
+ 	 */
+ 	if (key_type == BTRFS_DIR_INDEX_KEY) {
+ 		if (ctx->pos >= INT_MAX)
+ 			ctx->pos = LLONG_MAX;
+ 		else
+ 			ctx->pos = INT_MAX;
+ 	}
++>>>>>>> db62efbbf883 (btrfs: don't loop on large offsets in readdir)
  nopos:
  	ret = 0;
  err:
* Unmerged path fs/btrfs/inode.c
