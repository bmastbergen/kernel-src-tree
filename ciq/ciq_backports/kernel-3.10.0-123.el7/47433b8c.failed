x86: xen: Sync the CMOS RTC as well as the Xen wallclock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [virt] x86/xen: Sync the CMOS RTC as well as the Xen wallclock (Radim Krcmar) [1003683]
Rebuild_FUZZ: 97.30%
commit-author David Vrabel <david.vrabel@citrix.com>
commit 47433b8c9d7480a3eebd99df38e857ce85a37cee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/47433b8c.failed

Adjustments to Xen's persistent clock via update_persistent_clock()
don't actually persist, as the Xen wallclock is a software only clock
and modifications to it do not modify the underlying CMOS RTC.

The x86_platform.set_wallclock hook is there to keep the hardware RTC
synchronized. On a guest this is pointless.

On Dom0 we can use the native implementaion which actually updates the
hardware RTC, but we still need to keep the software emulation of RTC
for the guests up to date. The subscription to the pvclock_notifier
allows us to emulate this easily. The notifier is called at every tick
and when the clock was set.

Right now we only use that notifier when the clock was set, but due to
the fact that it is called periodically from the timekeeping update
code, we can utilize it to emulate the NTP driven drift compensation
of update_persistant_clock() for the Xen wall (software) clock.

Add a 11 minutes periodic update to the pvclock_gtod notifier callback
to achieve that. The static variable 'next' which maintains that 11
minutes update cycle is protected by the core code serialization so
there is no need to add a Xen specific serialization mechanism.

[ tglx: Massaged changelog and added a few comments ]

	Signed-off-by: David Vrabel <david.vrabel@citrix.com>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: John Stultz <john.stultz@linaro.org>
	Cc: <xen-devel@lists.xen.org>
Link: http://lkml.kernel.org/r/1372329348-20841-6-git-send-email-david.vrabel@citrix.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 47433b8c9d7480a3eebd99df38e857ce85a37cee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/xen/time.c
diff --cc arch/x86/xen/time.c
index 005718656483,7a5671b4fec6..000000000000
--- a/arch/x86/xen/time.c
+++ b/arch/x86/xen/time.c
@@@ -186,20 -199,49 +186,52 @@@ static void xen_get_wallclock(struct ti
  
  static int xen_set_wallclock(const struct timespec *now)
  {
+ 	return -1;
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int xen_pvclock_gtod_notify(struct notifier_block *nb,
+ 				   unsigned long was_set, void *priv)
+ {
+ 	/* Protected by the calling core code serialization */
+ 	static struct timespec next_sync;
+ 
  	struct xen_platform_op op;
+ 	struct timespec now;
  
- 	/* do nothing for domU */
- 	if (!xen_initial_domain())
- 		return -1;
+ 	now = __current_kernel_time();
+ 
+ 	/*
+ 	 * We only take the expensive HV call when the clock was set
+ 	 * or when the 11 minutes RTC synchronization time elapsed.
+ 	 */
+ 	if (!was_set && timespec_compare(&now, &next_sync) < 0)
+ 		return NOTIFY_OK;
  
  	op.cmd = XENPF_settime;
- 	op.u.settime.secs = now->tv_sec;
- 	op.u.settime.nsecs = now->tv_nsec;
+ 	op.u.settime.secs = now.tv_sec;
+ 	op.u.settime.nsecs = now.tv_nsec;
  	op.u.settime.system_time = xen_clocksource_read();
  
- 	return HYPERVISOR_dom0_op(&op);
+ 	(void)HYPERVISOR_dom0_op(&op);
+ 
+ 	/*
+ 	 * Move the next drift compensation time 11 minutes
+ 	 * ahead. That's emulating the sync_cmos_clock() update for
+ 	 * the hardware RTC.
+ 	 */
+ 	next_sync = now;
+ 	next_sync.tv_sec += 11 * 60;
+ 
+ 	return NOTIFY_OK;
  }
  
+ static struct notifier_block xen_pvclock_gtod_notifier = {
+ 	.notifier_call = xen_pvclock_gtod_notify,
+ };
+ 
++>>>>>>> 47433b8c9d74 (x86: xen: Sync the CMOS RTC as well as the Xen wallclock)
  static struct clocksource xen_clocksource __read_mostly = {
  	.name = "xen",
  	.rating = 400,
* Unmerged path arch/x86/xen/time.c
