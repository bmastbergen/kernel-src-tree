xfs: dirent dtype presence is dependent on directory magic numbers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 367993e7c6428cb7617ab7653d61dca54e2fdede
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/367993e7.failed

The determination of whether a directory entry contains a dtype
field originally was dependent on the filesystem having CRCs
enabled. This meant that the format for dtype beign enabled could be
determined by checking the directory block magic number rather than
doing a feature bit check. This was useful in that it meant that we
didn't need to pass a struct xfs_mount around to functions that
were already supplied with a directory block header.

Unfortunately, the introduction of dtype fields into the v4
structure via a feature bit meant this "use the directory block
magic number" method of discriminating the dirent entry sizes is
broken. Hence we need to convert the places that use magic number
checks to use feature bit checks so that they work correctly and not
by chance.

The current code works on v4 filesystems only because the dirent
size roundup covers the extra byte needed by the dtype field in the
places where this problem occurs.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Ben Myers <bpm@sgi.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 367993e7c6428cb7617ab7653d61dca54e2fdede)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_dir2_format.h
#	fs/xfs/xfs_dir2_readdir.c
#	fs/xfs/xfs_dir2_sf.c
diff --cc fs/xfs/xfs_dir2_format.h
index 2095e17b75cb,9cf67381adf6..000000000000
--- a/fs/xfs/xfs_dir2_format.h
+++ b/fs/xfs/xfs_dir2_format.h
@@@ -370,35 -497,28 +370,52 @@@ xfs_dir3_data_unused_p(struct xfs_dir2_
  /*
   * Offsets of . and .. in data space (always block 0)
   *
++<<<<<<< HEAD
 + * The macros are used for shortform directories as they have no headers to read
 + * the magic number out of. Shortform directories need to know the size of the
 + * data block header because the sfe embeds the block offset of the entry into
 + * it so that it doesn't change when format conversion occurs. Bad Things Happen
 + * if we don't follow this rule.
 + */
 +#define	XFS_DIR3_DATA_DOT_OFFSET(mp)	\
 +	xfs_dir3_data_hdr_size(xfs_sb_version_hascrc(&(mp)->m_sb))
 +#define	XFS_DIR3_DATA_DOTDOT_OFFSET(mp)	\
 +	(XFS_DIR3_DATA_DOT_OFFSET(mp) + xfs_dir2_data_entsize(1))
 +#define	XFS_DIR3_DATA_FIRST_OFFSET(mp)		\
 +	(XFS_DIR3_DATA_DOTDOT_OFFSET(mp) + xfs_dir2_data_entsize(2))
 +
++=======
+  * XXX: there is scope for significant optimisation of the logic here. Right
+  * now we are checking for "dir3 format" over and over again. Ideally we should
+  * only do it once for each operation.
+  */
++>>>>>>> 367993e7c642 (xfs: dirent dtype presence is dependent on directory magic numbers)
  static inline xfs_dir2_data_aoff_t
- xfs_dir3_data_dot_offset(struct xfs_dir2_data_hdr *hdr)
+ xfs_dir3_data_dot_offset(struct xfs_mount *mp)
  {
- 	return xfs_dir3_data_entry_offset(hdr);
+ 	return xfs_dir3_data_hdr_size(xfs_sb_version_hascrc(&mp->m_sb));
  }
  
  static inline xfs_dir2_data_aoff_t
- xfs_dir3_data_dotdot_offset(struct xfs_dir2_data_hdr *hdr)
+ xfs_dir3_data_dotdot_offset(struct xfs_mount *mp)
  {
++<<<<<<< HEAD
 +	return xfs_dir3_data_dot_offset(hdr) + xfs_dir2_data_entsize(1);
++=======
+ 	return xfs_dir3_data_dot_offset(mp) +
+ 		xfs_dir3_data_entsize(mp, 1);
++>>>>>>> 367993e7c642 (xfs: dirent dtype presence is dependent on directory magic numbers)
  }
  
  static inline xfs_dir2_data_aoff_t
- xfs_dir3_data_first_offset(struct xfs_dir2_data_hdr *hdr)
+ xfs_dir3_data_first_offset(struct xfs_mount *mp)
  {
++<<<<<<< HEAD
 +	return xfs_dir3_data_dotdot_offset(hdr) + xfs_dir2_data_entsize(2);
++=======
+ 	return xfs_dir3_data_dotdot_offset(mp) +
+ 		xfs_dir3_data_entsize(mp, 2);
++>>>>>>> 367993e7c642 (xfs: dirent dtype presence is dependent on directory magic numbers)
  }
  
  /*
diff --cc fs/xfs/xfs_dir2_sf.c
index 6157424dbf8f,3ef6d402084c..000000000000
--- a/fs/xfs/xfs_dir2_sf.c
+++ b/fs/xfs/xfs_dir2_sf.c
@@@ -535,13 -557,13 +535,17 @@@ xfs_dir2_sf_addname_hard
  	 * to insert the new entry.
  	 * If it's going to end up at the end then oldsfep will point there.
  	 */
++<<<<<<< HEAD
 +	for (offset = XFS_DIR3_DATA_FIRST_OFFSET(dp->i_mount),
++=======
+ 	for (offset = xfs_dir3_data_first_offset(mp),
++>>>>>>> 367993e7c642 (xfs: dirent dtype presence is dependent on directory magic numbers)
  	      oldsfep = xfs_dir2_sf_firstentry(oldsfp),
 -	      add_datasize = xfs_dir3_data_entsize(mp, args->namelen),
 +	      add_datasize = xfs_dir2_data_entsize(args->namelen),
  	      eof = (char *)oldsfep == &buf[old_isize];
  	     !eof;
 -	     offset = new_offset + xfs_dir3_data_entsize(mp, oldsfep->namelen),
 -	      oldsfep = xfs_dir3_sf_nextentry(mp, oldsfp, oldsfep),
 +	     offset = new_offset + xfs_dir2_data_entsize(oldsfep->namelen),
 +	      oldsfep = xfs_dir2_sf_nextentry(oldsfp, oldsfep),
  	      eof = (char *)oldsfep == &buf[old_isize]) {
  		new_offset = xfs_dir2_sf_get_offset(oldsfep);
  		if (offset + add_datasize <= new_offset)
@@@ -616,8 -639,8 +620,13 @@@ xfs_dir2_sf_addname_pick
  	mp = dp->i_mount;
  
  	sfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;
++<<<<<<< HEAD
 +	size = xfs_dir2_data_entsize(args->namelen);
 +	offset = XFS_DIR3_DATA_FIRST_OFFSET(mp);
++=======
+ 	size = xfs_dir3_data_entsize(mp, args->namelen);
+ 	offset = xfs_dir3_data_first_offset(mp);
++>>>>>>> 367993e7c642 (xfs: dirent dtype presence is dependent on directory magic numbers)
  	sfep = xfs_dir2_sf_firstentry(sfp);
  	holefit = 0;
  	/*
@@@ -684,11 -707,13 +693,15 @@@ xfs_dir2_sf_check
  	int			offset;		/* data offset */
  	xfs_dir2_sf_entry_t	*sfep;		/* shortform dir entry */
  	xfs_dir2_sf_hdr_t	*sfp;		/* shortform structure */
 -	struct xfs_mount	*mp;
  
  	dp = args->dp;
 -	mp = dp->i_mount;
  
  	sfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;
++<<<<<<< HEAD
 +	offset = XFS_DIR3_DATA_FIRST_OFFSET(dp->i_mount);
++=======
+ 	offset = xfs_dir3_data_first_offset(mp);
++>>>>>>> 367993e7c642 (xfs: dirent dtype presence is dependent on directory magic numbers)
  	ino = xfs_dir2_sf_get_parent_ino(sfp);
  	i8count = ino > XFS_DIR2_MAX_SHORT_INUM;
  
* Unmerged path fs/xfs/xfs_dir2_readdir.c
diff --git a/fs/xfs/xfs_dir2_block.c b/fs/xfs/xfs_dir2_block.c
index 53b9aa26d567..7b134d2dff6d 100644
--- a/fs/xfs/xfs_dir2_block.c
+++ b/fs/xfs/xfs_dir2_block.c
@@ -1253,7 +1253,7 @@ xfs_dir2_sf_to_block(
 	/*
 	 * Create entry for .
 	 */
-	dep = xfs_dir3_data_dot_entry_p(hdr);
+	dep = xfs_dir3_data_dot_entry_p(mp, hdr);
 	dep->inumber = cpu_to_be64(dp->i_ino);
 	dep->namelen = 1;
 	dep->name[0] = '.';
@@ -1266,7 +1266,7 @@ xfs_dir2_sf_to_block(
 	/*
 	 * Create entry for ..
 	 */
-	dep = xfs_dir3_data_dotdot_entry_p(hdr);
+	dep = xfs_dir3_data_dotdot_entry_p(mp, hdr);
 	dep->inumber = cpu_to_be64(xfs_dir2_sf_get_parent_ino(sfp));
 	dep->namelen = 2;
 	dep->name[0] = dep->name[1] = '.';
@@ -1276,7 +1276,7 @@ xfs_dir2_sf_to_block(
 	blp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);
 	blp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(mp,
 				(char *)dep - (char *)hdr));
-	offset = xfs_dir3_data_first_offset(hdr);
+	offset = xfs_dir3_data_first_offset(mp);
 	/*
 	 * Loop over existing entries, stuff them in.
 	 */
* Unmerged path fs/xfs/xfs_dir2_format.h
* Unmerged path fs/xfs/xfs_dir2_readdir.c
* Unmerged path fs/xfs/xfs_dir2_sf.c
