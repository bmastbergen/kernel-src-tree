drm/radeon/dpm: fix incompatible casting on big endian

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [drm] radeon/dpm: fix incompatible casting on big endian (Rob Clark) [1054409]
Rebuild_FUZZ: 96.15%
commit-author Alex Deucher <alexander.deucher@amd.com>
commit cdf6e8058415ba4d808537e30a0a6be9fb29e95a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/cdf6e805.failed

We use u16 for voltage values throughout the driver so switch
the table values to a u16 as well.  Fixes an incompatible
cast error in ci_patch_clock_voltage_limits_with_vddc_leakage()
picked up by coverity.

	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit cdf6e8058415ba4d808537e30a0a6be9fb29e95a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/radeon/radeon.h
diff --cc drivers/gpu/drm/radeon/radeon.h
index 142ce6cc69f5,24f4960f59ee..000000000000
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@@ -1075,6 -1218,251 +1075,254 @@@ struct radeon_power_state 
   */
  #define RADEON_MODE_OVERCLOCK_MARGIN 500 /* 5 MHz */
  
++<<<<<<< HEAD
++=======
+ enum radeon_dpm_auto_throttle_src {
+ 	RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL,
+ 	RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL
+ };
+ 
+ enum radeon_dpm_event_src {
+ 	RADEON_DPM_EVENT_SRC_ANALOG = 0,
+ 	RADEON_DPM_EVENT_SRC_EXTERNAL = 1,
+ 	RADEON_DPM_EVENT_SRC_DIGITAL = 2,
+ 	RADEON_DPM_EVENT_SRC_ANALOG_OR_EXTERNAL = 3,
+ 	RADEON_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL = 4
+ };
+ 
+ struct radeon_ps {
+ 	u32 caps; /* vbios flags */
+ 	u32 class; /* vbios flags */
+ 	u32 class2; /* vbios flags */
+ 	/* UVD clocks */
+ 	u32 vclk;
+ 	u32 dclk;
+ 	/* VCE clocks */
+ 	u32 evclk;
+ 	u32 ecclk;
+ 	/* asic priv */
+ 	void *ps_priv;
+ };
+ 
+ struct radeon_dpm_thermal {
+ 	/* thermal interrupt work */
+ 	struct work_struct work;
+ 	/* low temperature threshold */
+ 	int                min_temp;
+ 	/* high temperature threshold */
+ 	int                max_temp;
+ 	/* was interrupt low to high or high to low */
+ 	bool               high_to_low;
+ };
+ 
+ enum radeon_clk_action
+ {
+ 	RADEON_SCLK_UP = 1,
+ 	RADEON_SCLK_DOWN
+ };
+ 
+ struct radeon_blacklist_clocks
+ {
+ 	u32 sclk;
+ 	u32 mclk;
+ 	enum radeon_clk_action action;
+ };
+ 
+ struct radeon_clock_and_voltage_limits {
+ 	u32 sclk;
+ 	u32 mclk;
+ 	u16 vddc;
+ 	u16 vddci;
+ };
+ 
+ struct radeon_clock_array {
+ 	u32 count;
+ 	u32 *values;
+ };
+ 
+ struct radeon_clock_voltage_dependency_entry {
+ 	u32 clk;
+ 	u16 v;
+ };
+ 
+ struct radeon_clock_voltage_dependency_table {
+ 	u32 count;
+ 	struct radeon_clock_voltage_dependency_entry *entries;
+ };
+ 
+ union radeon_cac_leakage_entry {
+ 	struct {
+ 		u16 vddc;
+ 		u32 leakage;
+ 	};
+ 	struct {
+ 		u16 vddc1;
+ 		u16 vddc2;
+ 		u16 vddc3;
+ 	};
+ };
+ 
+ struct radeon_cac_leakage_table {
+ 	u32 count;
+ 	union radeon_cac_leakage_entry *entries;
+ };
+ 
+ struct radeon_phase_shedding_limits_entry {
+ 	u16 voltage;
+ 	u32 sclk;
+ 	u32 mclk;
+ };
+ 
+ struct radeon_phase_shedding_limits_table {
+ 	u32 count;
+ 	struct radeon_phase_shedding_limits_entry *entries;
+ };
+ 
+ struct radeon_uvd_clock_voltage_dependency_entry {
+ 	u32 vclk;
+ 	u32 dclk;
+ 	u16 v;
+ };
+ 
+ struct radeon_uvd_clock_voltage_dependency_table {
+ 	u8 count;
+ 	struct radeon_uvd_clock_voltage_dependency_entry *entries;
+ };
+ 
+ struct radeon_vce_clock_voltage_dependency_entry {
+ 	u32 ecclk;
+ 	u32 evclk;
+ 	u16 v;
+ };
+ 
+ struct radeon_vce_clock_voltage_dependency_table {
+ 	u8 count;
+ 	struct radeon_vce_clock_voltage_dependency_entry *entries;
+ };
+ 
+ struct radeon_ppm_table {
+ 	u8 ppm_design;
+ 	u16 cpu_core_number;
+ 	u32 platform_tdp;
+ 	u32 small_ac_platform_tdp;
+ 	u32 platform_tdc;
+ 	u32 small_ac_platform_tdc;
+ 	u32 apu_tdp;
+ 	u32 dgpu_tdp;
+ 	u32 dgpu_ulv_power;
+ 	u32 tj_max;
+ };
+ 
+ struct radeon_cac_tdp_table {
+ 	u16 tdp;
+ 	u16 configurable_tdp;
+ 	u16 tdc;
+ 	u16 battery_power_limit;
+ 	u16 small_power_limit;
+ 	u16 low_cac_leakage;
+ 	u16 high_cac_leakage;
+ 	u16 maximum_power_delivery_limit;
+ };
+ 
+ struct radeon_dpm_dynamic_state {
+ 	struct radeon_clock_voltage_dependency_table vddc_dependency_on_sclk;
+ 	struct radeon_clock_voltage_dependency_table vddci_dependency_on_mclk;
+ 	struct radeon_clock_voltage_dependency_table vddc_dependency_on_mclk;
+ 	struct radeon_clock_voltage_dependency_table mvdd_dependency_on_mclk;
+ 	struct radeon_clock_voltage_dependency_table vddc_dependency_on_dispclk;
+ 	struct radeon_uvd_clock_voltage_dependency_table uvd_clock_voltage_dependency_table;
+ 	struct radeon_vce_clock_voltage_dependency_table vce_clock_voltage_dependency_table;
+ 	struct radeon_clock_voltage_dependency_table samu_clock_voltage_dependency_table;
+ 	struct radeon_clock_voltage_dependency_table acp_clock_voltage_dependency_table;
+ 	struct radeon_clock_array valid_sclk_values;
+ 	struct radeon_clock_array valid_mclk_values;
+ 	struct radeon_clock_and_voltage_limits max_clock_voltage_on_dc;
+ 	struct radeon_clock_and_voltage_limits max_clock_voltage_on_ac;
+ 	u32 mclk_sclk_ratio;
+ 	u32 sclk_mclk_delta;
+ 	u16 vddc_vddci_delta;
+ 	u16 min_vddc_for_pcie_gen2;
+ 	struct radeon_cac_leakage_table cac_leakage_table;
+ 	struct radeon_phase_shedding_limits_table phase_shedding_limits_table;
+ 	struct radeon_ppm_table *ppm_table;
+ 	struct radeon_cac_tdp_table *cac_tdp_table;
+ };
+ 
+ struct radeon_dpm_fan {
+ 	u16 t_min;
+ 	u16 t_med;
+ 	u16 t_high;
+ 	u16 pwm_min;
+ 	u16 pwm_med;
+ 	u16 pwm_high;
+ 	u8 t_hyst;
+ 	u32 cycle_delay;
+ 	u16 t_max;
+ 	bool ucode_fan_control;
+ };
+ 
+ enum radeon_pcie_gen {
+ 	RADEON_PCIE_GEN1 = 0,
+ 	RADEON_PCIE_GEN2 = 1,
+ 	RADEON_PCIE_GEN3 = 2,
+ 	RADEON_PCIE_GEN_INVALID = 0xffff
+ };
+ 
+ enum radeon_dpm_forced_level {
+ 	RADEON_DPM_FORCED_LEVEL_AUTO = 0,
+ 	RADEON_DPM_FORCED_LEVEL_LOW = 1,
+ 	RADEON_DPM_FORCED_LEVEL_HIGH = 2,
+ };
+ 
+ struct radeon_dpm {
+ 	struct radeon_ps        *ps;
+ 	/* number of valid power states */
+ 	int                     num_ps;
+ 	/* current power state that is active */
+ 	struct radeon_ps        *current_ps;
+ 	/* requested power state */
+ 	struct radeon_ps        *requested_ps;
+ 	/* boot up power state */
+ 	struct radeon_ps        *boot_ps;
+ 	/* default uvd power state */
+ 	struct radeon_ps        *uvd_ps;
+ 	enum radeon_pm_state_type state;
+ 	enum radeon_pm_state_type user_state;
+ 	u32                     platform_caps;
+ 	u32                     voltage_response_time;
+ 	u32                     backbias_response_time;
+ 	void                    *priv;
+ 	u32			new_active_crtcs;
+ 	int			new_active_crtc_count;
+ 	u32			current_active_crtcs;
+ 	int			current_active_crtc_count;
+ 	struct radeon_dpm_dynamic_state dyn_state;
+ 	struct radeon_dpm_fan fan;
+ 	u32 tdp_limit;
+ 	u32 near_tdp_limit;
+ 	u32 near_tdp_limit_adjusted;
+ 	u32 sq_ramping_threshold;
+ 	u32 cac_leakage;
+ 	u16 tdp_od_limit;
+ 	u32 tdp_adjustment;
+ 	u16 load_line_slope;
+ 	bool power_control;
+ 	bool ac_power;
+ 	/* special states active */
+ 	bool                    thermal_active;
+ 	bool                    uvd_active;
+ 	/* thermal handling */
+ 	struct radeon_dpm_thermal thermal;
+ 	/* forced levels */
+ 	enum radeon_dpm_forced_level forced_level;
+ 	/* track UVD streams */
+ 	unsigned sd;
+ 	unsigned hd;
+ };
+ 
+ void radeon_dpm_enable_uvd(struct radeon_device *rdev, bool enable);
+ 
++>>>>>>> cdf6e8058415 (drm/radeon/dpm: fix incompatible casting on big endian)
  struct radeon_pm {
  	struct mutex		mutex;
  	/* write locked while reprogramming mclk */
* Unmerged path drivers/gpu/drm/radeon/radeon.h
