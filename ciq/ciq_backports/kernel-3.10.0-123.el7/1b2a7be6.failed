PCI/ACPI: Run _OSC only once for OSPM feature support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [acpi] Run _OSC only once for OSPM feature support (Myron Stowe) [1033834]
Rebuild_FUZZ: 89.58%
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit 1b2a7be60eaaf17bc88368d748471dd70e40befd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/1b2a7be6.failed

Previously, we ran _OSC once to tell the platform that we support
PCI Segment Groups, then we ran it again if we supported any additional
features (ASPM, MSI, or extended config space).  I don't think it's
necessary to run it twice, since we can easily build the complete
mask of features we support before running _OSC the first time.

We run _OSC again later when requesting control of PCIe features;
that's unaffected by this change.

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1b2a7be60eaaf17bc88368d748471dd70e40befd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/pci_root.c
diff --cc drivers/acpi/pci_root.c
index ed36e22817d8,0e2004100c44..000000000000
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@@ -360,6 -360,86 +360,89 @@@ out
  }
  EXPORT_SYMBOL(acpi_pci_osc_control_set);
  
++<<<<<<< HEAD
++=======
+ static void negotiate_os_control(struct acpi_pci_root *root, int *no_aspm,
+ 				 int *clear_aspm)
+ {
+ 	u32 support, base_support, control;
+ 	acpi_status status;
+ 	struct acpi_device *device = root->device;
+ 	acpi_handle handle = device->handle;
+ 
+ 	/*
+ 	 * All supported architectures that use ACPI have support for
+ 	 * PCI domains, so we indicate this in _OSC support capabilities.
+ 	 */
+ 	support = base_support = OSC_PCI_SEGMENT_GROUPS_SUPPORT;
+ 	if (pci_ext_cfg_avail())
+ 		support |= OSC_PCI_EXT_CONFIG_SUPPORT;
+ 	if (pcie_aspm_support_enabled())
+ 		support |= OSC_PCI_ASPM_SUPPORT | OSC_PCI_CLOCK_PM_SUPPORT;
+ 	if (pci_msi_enabled())
+ 		support |= OSC_PCI_MSI_SUPPORT;
+ 	status = acpi_pci_osc_support(root, support);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_info(&device->dev, "ACPI _OSC support "
+ 			"notification failed, disabling PCIe ASPM\n");
+ 		*no_aspm = 1;
+ 		support = base_support;
+ 	}
+ 
+ 	if (!pcie_ports_disabled
+ 	    && (support & ACPI_PCIE_REQ_SUPPORT) == ACPI_PCIE_REQ_SUPPORT) {
+ 		control = OSC_PCI_EXPRESS_CAPABILITY_CONTROL
+ 			| OSC_PCI_EXPRESS_NATIVE_HP_CONTROL
+ 			| OSC_PCI_EXPRESS_PME_CONTROL;
+ 
+ 		if (pci_aer_available()) {
+ 			if (aer_acpi_firmware_first())
+ 				dev_dbg(&device->dev,
+ 					"PCIe errors handled by BIOS.\n");
+ 			else
+ 				control |= OSC_PCI_EXPRESS_AER_CONTROL;
+ 		}
+ 
+ 		dev_info(&device->dev,
+ 			"Requesting ACPI _OSC control (0x%02x)\n", control);
+ 
+ 		status = acpi_pci_osc_control_set(handle, &control,
+ 				       OSC_PCI_EXPRESS_CAPABILITY_CONTROL);
+ 		if (ACPI_SUCCESS(status)) {
+ 			dev_info(&device->dev,
+ 				"ACPI _OSC control (0x%02x) granted\n",
+ 				control);
+ 			if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {
+ 				/*
+ 				 * We have ASPM control, but the FADT indicates
+ 				 * that it's unsupported. Clear it.
+ 				 */
+ 				*clear_aspm = 1;
+ 			}
+ 		} else {
+ 			dev_info(&device->dev,
+ 				"ACPI _OSC request failed (%s), "
+ 				"returned control mask: 0x%02x\n",
+ 				acpi_format_exception(status), control);
+ 			dev_info(&device->dev,
+ 				 "ACPI _OSC control for PCIe not granted, disabling ASPM\n");
+ 			/*
+ 			 * We want to disable ASPM here, but aspm_disabled
+ 			 * needs to remain in its state from boot so that we
+ 			 * properly handle PCIe 1.1 devices.  So we set this
+ 			 * flag here, to defer the action until after the ACPI
+ 			 * root scan.
+ 			 */
+ 			*no_aspm = 1;
+ 		}
+ 	} else {
+ 		dev_info(&device->dev,
+ 			 "Unable to request _OSC control "
+ 			 "(_OSC support mask: 0x%02x)\n", support);
+ 	}
+ }
+ 
++>>>>>>> 1b2a7be60eaa (PCI/ACPI: Run _OSC only once for OSPM feature support)
  static int acpi_pci_root_add(struct acpi_device *device,
  			     const struct acpi_device_id *not_used)
  {
* Unmerged path drivers/acpi/pci_root.c
