vxlan: add ipv6 proxy support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Cong Wang <amwang@redhat.com>
commit f564f45c451809aa3b74f577754528520d315ac1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/f564f45c.failed

This patch adds the IPv6 version of "arp_reduce", ndisc_send_na()
will be needed.

	Cc: David S. Miller <davem@davemloft.net>
	Cc: David Stevens <dlstevens@us.ibm.com>
	Signed-off-by: Cong Wang <amwang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f564f45c451809aa3b74f577754528520d315ac1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/addrconf.h
#	net/ipv6/af_inet6.c
diff --cc include/net/addrconf.h
index c7b181cb47a6,fb314de2b61b..000000000000
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@@ -134,31 -118,49 +134,57 @@@ extern u32			ipv6_addr_label(struct ne
  /*
   *	multicast prototypes (mcast.c)
   */
 -int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 -		      const struct in6_addr *addr);
 -int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
 -		      const struct in6_addr *addr);
 -void ipv6_sock_mc_close(struct sock *sk);
 -bool inet6_mc_check(struct sock *sk, const struct in6_addr *mc_addr,
 -		    const struct in6_addr *src_addr);
 -
 -int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
 -int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 -int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
 -void ipv6_mc_up(struct inet6_dev *idev);
 -void ipv6_mc_down(struct inet6_dev *idev);
 -void ipv6_mc_unmap(struct inet6_dev *idev);
 -void ipv6_mc_remap(struct inet6_dev *idev);
 -void ipv6_mc_init_dev(struct inet6_dev *idev);
 -void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 -void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 -
 +extern int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 +			     const struct in6_addr *addr);
 +extern int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
 +			     const struct in6_addr *addr);
 +extern void ipv6_sock_mc_close(struct sock *sk);
 +extern bool inet6_mc_check(struct sock *sk,
 +			   const struct in6_addr *mc_addr,
 +			   const struct in6_addr *src_addr);
 +
 +extern int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
 +extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 +extern int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
 +extern void ipv6_mc_up(struct inet6_dev *idev);
 +extern void ipv6_mc_down(struct inet6_dev *idev);
 +extern void ipv6_mc_unmap(struct inet6_dev *idev);
 +extern void ipv6_mc_remap(struct inet6_dev *idev);
 +extern void ipv6_mc_init_dev(struct inet6_dev *idev);
 +extern void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 +extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 +
++<<<<<<< HEAD
 +extern bool ipv6_chk_mcast_addr(struct net_device *dev,
 +				const struct in6_addr *group,
 +				const struct in6_addr *src_addr);
++=======
+ bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,
+ 			 const struct in6_addr *src_addr);
+ 
+ void ipv6_mc_dad_complete(struct inet6_dev *idev);
+ 
+ /* A stub used by vxlan module. This is ugly, ideally these
+  * symbols should be built into the core kernel.
+  */
+ struct ipv6_stub {
+ 	int (*ipv6_sock_mc_join)(struct sock *sk, int ifindex,
+ 				 const struct in6_addr *addr);
+ 	int (*ipv6_sock_mc_drop)(struct sock *sk, int ifindex,
+ 				 const struct in6_addr *addr);
+ 	int (*ipv6_dst_lookup)(struct sock *sk, struct dst_entry **dst,
+ 				struct flowi6 *fl6);
+ 	void (*udpv6_encap_enable)(void);
+ 	void (*ndisc_send_na)(struct net_device *dev, struct neighbour *neigh,
+ 			      const struct in6_addr *daddr,
+ 			      const struct in6_addr *solicited_addr,
+ 			      bool router, bool solicited, bool override, bool inc_opt);
+ 	struct neigh_table *nd_tbl;
+ };
+ extern const struct ipv6_stub *ipv6_stub __read_mostly;
++>>>>>>> f564f45c4518 (vxlan: add ipv6 proxy support)
  
 +extern void ipv6_mc_dad_complete(struct inet6_dev *idev);
  /*
   * identify MLD packets for MLD filter exceptions
   */
diff --cc net/ipv6/af_inet6.c
index ab5c7ad482cd,136fe55c1a47..000000000000
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@@ -808,6 -811,15 +809,18 @@@ static struct pernet_operations inet6_n
  	.exit = inet6_net_exit,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct ipv6_stub ipv6_stub_impl = {
+ 	.ipv6_sock_mc_join = ipv6_sock_mc_join,
+ 	.ipv6_sock_mc_drop = ipv6_sock_mc_drop,
+ 	.ipv6_dst_lookup = ip6_dst_lookup,
+ 	.udpv6_encap_enable = udpv6_encap_enable,
+ 	.ndisc_send_na = ndisc_send_na,
+ 	.nd_tbl	= &nd_tbl,
+ };
+ 
++>>>>>>> f564f45c4518 (vxlan: add ipv6 proxy support)
  static int __init inet6_init(void)
  {
  	struct list_head *r;
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index 260932cfcfd3..22eb5345afd5 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -1202,6 +1202,70 @@ out:
 	return NETDEV_TX_OK;
 }
 
+#if IS_ENABLED(CONFIG_IPV6)
+static int neigh_reduce(struct net_device *dev, struct sk_buff *skb)
+{
+	struct vxlan_dev *vxlan = netdev_priv(dev);
+	struct neighbour *n;
+	union vxlan_addr ipa;
+	const struct ipv6hdr *iphdr;
+	const struct in6_addr *saddr, *daddr;
+	struct nd_msg *msg;
+	struct inet6_dev *in6_dev = NULL;
+
+	in6_dev = __in6_dev_get(dev);
+	if (!in6_dev)
+		goto out;
+
+	if (!pskb_may_pull(skb, skb->len))
+		goto out;
+
+	iphdr = ipv6_hdr(skb);
+	saddr = &iphdr->saddr;
+	daddr = &iphdr->daddr;
+
+	if (ipv6_addr_loopback(daddr) ||
+	    ipv6_addr_is_multicast(daddr))
+		goto out;
+
+	msg = (struct nd_msg *)skb_transport_header(skb);
+	if (msg->icmph.icmp6_code != 0 ||
+	    msg->icmph.icmp6_type != NDISC_NEIGHBOUR_SOLICITATION)
+		goto out;
+
+	n = neigh_lookup(ipv6_stub->nd_tbl, daddr, dev);
+
+	if (n) {
+		struct vxlan_fdb *f;
+
+		if (!(n->nud_state & NUD_CONNECTED)) {
+			neigh_release(n);
+			goto out;
+		}
+
+		f = vxlan_find_mac(vxlan, n->ha);
+		if (f && vxlan_addr_any(&(first_remote_rcu(f)->remote_ip))) {
+			/* bridge-local neighbor */
+			neigh_release(n);
+			goto out;
+		}
+
+		ipv6_stub->ndisc_send_na(dev, n, saddr, &msg->target,
+					 !!in6_dev->cnf.forwarding,
+					 true, false, false);
+		neigh_release(n);
+	} else if (vxlan->flags & VXLAN_F_L3MISS) {
+		ipa.sin6.sin6_addr = *daddr;
+		ipa.sa.sa_family = AF_INET6;
+		vxlan_ip_miss(dev, &ipa);
+	}
+
+out:
+	consume_skb(skb);
+	return NETDEV_TX_OK;
+}
+#endif
+
 static bool route_shortcircuit(struct net_device *dev, struct sk_buff *skb)
 {
 	struct vxlan_dev *vxlan = netdev_priv(dev);
@@ -1658,8 +1722,22 @@ static netdev_tx_t vxlan_xmit(struct sk_buff *skb, struct net_device *dev)
 	skb_reset_mac_header(skb);
 	eth = eth_hdr(skb);
 
-	if ((vxlan->flags & VXLAN_F_PROXY) && ntohs(eth->h_proto) == ETH_P_ARP)
-		return arp_reduce(dev, skb);
+	if ((vxlan->flags & VXLAN_F_PROXY)) {
+		if (ntohs(eth->h_proto) == ETH_P_ARP)
+			return arp_reduce(dev, skb);
+#if IS_ENABLED(CONFIG_IPV6)
+		else if (ntohs(eth->h_proto) == ETH_P_IPV6 &&
+			 skb->len >= sizeof(struct ipv6hdr) + sizeof(struct nd_msg) &&
+			 ipv6_hdr(skb)->nexthdr == IPPROTO_ICMPV6) {
+				struct nd_msg *msg;
+
+				msg = (struct nd_msg *)skb_transport_header(skb);
+				if (msg->icmph.icmp6_code == 0 &&
+				    msg->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)
+					return neigh_reduce(dev, skb);
+		}
+#endif
+	}
 
 	f = vxlan_find_mac(vxlan, eth->h_dest);
 	did_rsc = false;
* Unmerged path include/net/addrconf.h
diff --git a/include/net/ndisc.h b/include/net/ndisc.h
index 745bf741e029..ec2da5641064 100644
--- a/include/net/ndisc.h
+++ b/include/net/ndisc.h
@@ -204,6 +204,11 @@ extern void			ndisc_send_ns(struct net_device *dev,
 extern void			ndisc_send_rs(struct net_device *dev,
 					      const struct in6_addr *saddr,
 					      const struct in6_addr *daddr);
+extern void			ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
+					      const struct in6_addr *daddr,
+					      const struct in6_addr *solicited_addr,
+					      bool router, bool solicited, bool override,
+					      bool inc_opt);
 
 extern void			ndisc_send_redirect(struct sk_buff *skb,
 						    const struct in6_addr *target);
* Unmerged path net/ipv6/af_inet6.c
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 215da7de70d2..8ead24ecc024 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -462,10 +462,10 @@ static void ndisc_send_skb(struct sk_buff *skb,
 	rcu_read_unlock();
 }
 
-static void ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
-			  const struct in6_addr *daddr,
-			  const struct in6_addr *solicited_addr,
-			  bool router, bool solicited, bool override, bool inc_opt)
+void ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
+		   const struct in6_addr *daddr,
+		   const struct in6_addr *solicited_addr,
+		   bool router, bool solicited, bool override, bool inc_opt)
 {
 	struct sk_buff *skb;
 	struct in6_addr tmpaddr;
