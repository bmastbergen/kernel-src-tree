sunrpc: replace sunrpc_net->gssd_running flag with a more reliable check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Jeff Layton <jlayton@redhat.com>
commit 89f842435c630f8426f414e6030bc2ffea0d6f81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/89f84243.failed

Now that we have a more reliable method to tell if gssd is running, we
can replace the sn->gssd_running flag with a function that will query to
see if it's up and running.

There's also no need to attempt an upcall that we know will fail, so
just return -EACCES if gssd isn't running. Finally, fix the warn_gss()
message not to claim that that the upcall timed out since we don't
necesarily perform one now when gssd isn't running, and remove the
extraneous newline from the message.

	Signed-off-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
(cherry picked from commit 89f842435c630f8426f414e6030bc2ffea0d6f81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/auth_gss/auth_gss.c
diff --cc net/sunrpc/auth_gss/auth_gss.c
index 9d6dde2ceede,0a2aee060f9f..000000000000
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@@ -575,17 -606,16 +573,24 @@@ gss_create_upcall(struct gss_auth *gss_
  		__func__, from_kuid(&init_user_ns, cred->cr_uid));
  retry:
  	err = 0;
++<<<<<<< HEAD
 +	/* Default timeout is 15s unless we know that gssd is not running */
 +	timeout = 15 * HZ;
 +	if (!sn->gssd_running)
 +		timeout = HZ >> 2;
 +	gss_msg = gss_setup_upcall(gss_auth->client, gss_auth, cred);
++=======
+ 	/* if gssd is down, just skip upcalling altogether */
+ 	if (!gssd_running(net)) {
+ 		warn_gssd();
+ 		return -EACCES;
+ 	}
+ 	gss_msg = gss_setup_upcall(gss_auth, cred);
++>>>>>>> 89f842435c63 (sunrpc: replace sunrpc_net->gssd_running flag with a more reliable check)
  	if (PTR_ERR(gss_msg) == -EAGAIN) {
  		err = wait_event_interruptible_timeout(pipe_version_waitqueue,
- 				sn->pipe_version >= 0, timeout);
+ 				sn->pipe_version >= 0, 15 * HZ);
  		if (sn->pipe_version < 0) {
- 			if (err == 0)
- 				sn->gssd_running = 0;
  			warn_gssd();
  			err = -EACCES;
  		}
diff --git a/include/linux/sunrpc/rpc_pipe_fs.h b/include/linux/sunrpc/rpc_pipe_fs.h
index 85f13424647c..7f490bef9e99 100644
--- a/include/linux/sunrpc/rpc_pipe_fs.h
+++ b/include/linux/sunrpc/rpc_pipe_fs.h
@@ -131,5 +131,7 @@ extern int rpc_unlink(struct dentry *);
 extern int register_rpc_pipefs(void);
 extern void unregister_rpc_pipefs(void);
 
+extern bool gssd_running(struct net *net);
+
 #endif
 #endif
* Unmerged path net/sunrpc/auth_gss/auth_gss.c
diff --git a/net/sunrpc/netns.h b/net/sunrpc/netns.h
index 8a8e841d1547..94e506f9d72b 100644
--- a/net/sunrpc/netns.h
+++ b/net/sunrpc/netns.h
@@ -33,8 +33,6 @@ struct sunrpc_net {
 	int pipe_version;
 	atomic_t pipe_users;
 	struct proc_dir_entry *use_gssp_proc;
-
-	unsigned int gssd_running;
 };
 
 extern int sunrpc_net_id;
diff --git a/net/sunrpc/rpc_pipe.c b/net/sunrpc/rpc_pipe.c
index 40aef18151aa..ad444f39696b 100644
--- a/net/sunrpc/rpc_pipe.c
+++ b/net/sunrpc/rpc_pipe.c
@@ -216,14 +216,11 @@ rpc_destroy_inode(struct inode *inode)
 static int
 rpc_pipe_open(struct inode *inode, struct file *filp)
 {
-	struct net *net = inode->i_sb->s_fs_info;
-	struct sunrpc_net *sn = net_generic(net, sunrpc_net_id);
 	struct rpc_pipe *pipe;
 	int first_open;
 	int res = -ENXIO;
 
 	mutex_lock(&inode->i_mutex);
-	sn->gssd_running = 1;
 	pipe = RPC_I(inode)->pipe;
 	if (pipe == NULL)
 		goto out;
@@ -1231,7 +1228,6 @@ int rpc_pipefs_init_net(struct net *net)
 		return PTR_ERR(sn->gssd_dummy);
 
 	mutex_init(&sn->pipefs_sb_lock);
-	sn->gssd_running = 1;
 	sn->pipe_version = -1;
 	return 0;
 }
@@ -1385,6 +1381,16 @@ err_depopulate:
 	return err;
 }
 
+bool
+gssd_running(struct net *net)
+{
+	struct sunrpc_net *sn = net_generic(net, sunrpc_net_id);
+	struct rpc_pipe *pipe = sn->gssd_dummy;
+
+	return pipe->nreaders || pipe->nwriters;
+}
+EXPORT_SYMBOL_GPL(gssd_running);
+
 static struct dentry *
 rpc_mount(struct file_system_type *fs_type,
 		int flags, const char *dev_name, void *data)
