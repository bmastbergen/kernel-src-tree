rtnl: make ifla_policy static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit f7b12606b5de323a2bb5ca1696558efde8f25441
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/f7b12606.failed

The only place this is used outside rtnetlink.c is veth. So provide
wrapper function for this usage.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f7b12606b5de323a2bb5ca1696558efde8f25441)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/rtnetlink.h
#	net/core/rtnetlink.c
diff --cc include/net/rtnetlink.h
index 702664833a53,72240e5ac2c4..000000000000
--- a/include/net/rtnetlink.h
+++ b/include/net/rtnetlink.h
@@@ -117,19 -129,18 +117,23 @@@ struct rtnl_af_ops 
  					       const struct nlattr *attr);
  };
  
 -void __rtnl_af_unregister(struct rtnl_af_ops *ops);
 +extern int	__rtnl_af_register(struct rtnl_af_ops *ops);
 +extern void	__rtnl_af_unregister(struct rtnl_af_ops *ops);
  
 -void rtnl_af_register(struct rtnl_af_ops *ops);
 -void rtnl_af_unregister(struct rtnl_af_ops *ops);
 +extern int	rtnl_af_register(struct rtnl_af_ops *ops);
 +extern void	rtnl_af_unregister(struct rtnl_af_ops *ops);
  
 -struct net *rtnl_link_get_net(struct net *src_net, struct nlattr *tb[]);
 -struct net_device *rtnl_create_link(struct net *net, char *ifname,
 -				    const struct rtnl_link_ops *ops,
 -				    struct nlattr *tb[]);
 -int rtnl_configure_link(struct net_device *dev, const struct ifinfomsg *ifm);
  
++<<<<<<< HEAD
 +extern struct net *rtnl_link_get_net(struct net *src_net, struct nlattr *tb[]);
 +extern struct net_device *rtnl_create_link(struct net *net,
 +	char *ifname, const struct rtnl_link_ops *ops, struct nlattr *tb[]);
 +extern int rtnl_configure_link(struct net_device *dev,
 +			       const struct ifinfomsg *ifm);
 +extern const struct nla_policy ifla_policy[IFLA_MAX+1];
++=======
+ int rtnl_nla_parse_ifla(struct nlattr **tb, const struct nlattr *head, int len);
++>>>>>>> f7b12606b5de (rtnl: make ifla_policy static)
  
  #define MODULE_ALIAS_RTNL_LINK(kind) MODULE_ALIAS("rtnl-link-" kind)
  
diff --cc net/core/rtnetlink.c
index 45706a441af0,7b2ad564b303..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1110,68 -1234,11 +1174,76 @@@ out
  	return skb->len;
  }
  
++<<<<<<< HEAD
 +const struct nla_policy ifla_policy[IFLA_MAX+1] = {
 +	[IFLA_IFNAME]		= { .type = NLA_STRING, .len = IFNAMSIZ-1 },
 +	[IFLA_ADDRESS]		= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },
 +	[IFLA_BROADCAST]	= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },
 +	[IFLA_MAP]		= { .len = sizeof(struct rtnl_link_ifmap) },
 +	[IFLA_MTU]		= { .type = NLA_U32 },
 +	[IFLA_LINK]		= { .type = NLA_U32 },
 +	[IFLA_MASTER]		= { .type = NLA_U32 },
 +	[IFLA_CARRIER]		= { .type = NLA_U8 },
 +	[IFLA_TXQLEN]		= { .type = NLA_U32 },
 +	[IFLA_WEIGHT]		= { .type = NLA_U32 },
 +	[IFLA_OPERSTATE]	= { .type = NLA_U8 },
 +	[IFLA_LINKMODE]		= { .type = NLA_U8 },
 +	[IFLA_LINKINFO]		= { .type = NLA_NESTED },
 +	[IFLA_NET_NS_PID]	= { .type = NLA_U32 },
 +	[IFLA_NET_NS_FD]	= { .type = NLA_U32 },
 +	[IFLA_IFALIAS]	        = { .type = NLA_STRING, .len = IFALIASZ-1 },
 +	[IFLA_VFINFO_LIST]	= {. type = NLA_NESTED },
 +	[IFLA_VF_PORTS]		= { .type = NLA_NESTED },
 +	[IFLA_PORT_SELF]	= { .type = NLA_NESTED },
 +	[IFLA_AF_SPEC]		= { .type = NLA_NESTED },
 +	[IFLA_EXT_MASK]		= { .type = NLA_U32 },
 +	[IFLA_PROMISCUITY]	= { .type = NLA_U32 },
 +	[IFLA_NUM_TX_QUEUES]	= { .type = NLA_U32 },
 +	[IFLA_NUM_RX_QUEUES]	= { .type = NLA_U32 },
 +	[IFLA_PHYS_PORT_ID]	= { .type = NLA_BINARY, .len = MAX_PHYS_PORT_ID_LEN },
 +};
 +EXPORT_SYMBOL(ifla_policy);
 +
 +static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
 +	[IFLA_INFO_KIND]	= { .type = NLA_STRING },
 +	[IFLA_INFO_DATA]	= { .type = NLA_NESTED },
 +};
 +
 +static const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {
 +	[IFLA_VF_INFO]		= { .type = NLA_NESTED },
 +};
 +
 +static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
 +	[IFLA_VF_MAC]		= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_mac) },
 +	[IFLA_VF_VLAN]		= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_vlan) },
 +	[IFLA_VF_TX_RATE]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_tx_rate) },
 +	[IFLA_VF_SPOOFCHK]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_spoofchk) },
 +};
 +
 +static const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {
 +	[IFLA_PORT_VF]		= { .type = NLA_U32 },
 +	[IFLA_PORT_PROFILE]	= { .type = NLA_STRING,
 +				    .len = PORT_PROFILE_MAX },
 +	[IFLA_PORT_VSI_TYPE]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_port_vsi)},
 +	[IFLA_PORT_INSTANCE_UUID] = { .type = NLA_BINARY,
 +				      .len = PORT_UUID_MAX },
 +	[IFLA_PORT_HOST_UUID]	= { .type = NLA_STRING,
 +				    .len = PORT_UUID_MAX },
 +	[IFLA_PORT_REQUEST]	= { .type = NLA_U8, },
 +	[IFLA_PORT_RESPONSE]	= { .type = NLA_U16, },
 +};
++=======
+ int rtnl_nla_parse_ifla(struct nlattr **tb, const struct nlattr *head, int len)
+ {
+ 	return nla_parse(tb, IFLA_MAX, head, len, ifla_policy);
+ }
+ EXPORT_SYMBOL(rtnl_nla_parse_ifla);
++>>>>>>> f7b12606b5de (rtnl: make ifla_policy static)
  
  struct net *rtnl_link_get_net(struct net *src_net, struct nlattr *tb[])
  {
diff --git a/drivers/net/veth.c b/drivers/net/veth.c
index 177f911f5946..63107f8657ac 100644
--- a/drivers/net/veth.c
+++ b/drivers/net/veth.c
@@ -14,6 +14,7 @@
 #include <linux/etherdevice.h>
 #include <linux/u64_stats_sync.h>
 
+#include <net/rtnetlink.h>
 #include <net/dst.h>
 #include <net/xfrm.h>
 #include <linux/veth.h>
@@ -314,10 +315,9 @@ static int veth_newlink(struct net *src_net, struct net_device *dev,
 
 		nla_peer = data[VETH_INFO_PEER];
 		ifmp = nla_data(nla_peer);
-		err = nla_parse(peer_tb, IFLA_MAX,
-				nla_data(nla_peer) + sizeof(struct ifinfomsg),
-				nla_len(nla_peer) - sizeof(struct ifinfomsg),
-				ifla_policy);
+		err = rtnl_nla_parse_ifla(peer_tb,
+					  nla_data(nla_peer) + sizeof(struct ifinfomsg),
+					  nla_len(nla_peer) - sizeof(struct ifinfomsg));
 		if (err < 0)
 			return err;
 
* Unmerged path include/net/rtnetlink.h
* Unmerged path net/core/rtnetlink.c
