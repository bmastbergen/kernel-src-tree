inet: fix addr_len/msg->msg_namelen assignment in recv_error and rxpmtu functions

jira LE-1907
cve CVE-2013-6405
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 85fbaa75037d0b6b786ff18658ddf0b4014ce2a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/85fbaa75.failed

Commit bceaa90240b6019ed73b49965eac7d167610be69 ("inet: prevent leakage
of uninitialized memory to user in recv syscalls") conditionally updated
addr_len if the msg_name is written to. The recv_error and rxpmtu
functions relied on the recvmsg functions to set up addr_len before.

As this does not happen any more we have to pass addr_len to those
functions as well and set it to the size of the corresponding sockaddr
length.

This broke traceroute and such.

Fixes: bceaa90240b6 ("inet: prevent leakage of uninitialized memory to user in recv syscalls")
	Reported-by: Brad Spengler <spender@grsecurity.net>
	Reported-by: Tom Labanowski
	Cc: mpb <mpb.mail@gmail.com>
	Cc: David S. Miller <davem@davemloft.net>
	Cc: Eric Dumazet <eric.dumazet@gmail.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 85fbaa75037d0b6b786ff18658ddf0b4014ce2a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
#	include/net/ipv6.h
#	include/net/ping.h
#	net/ipv4/ping.c
#	net/ipv6/ping.c
diff --cc include/net/ip.h
index 48f55979d842,5a25f36fe3a7..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -448,26 -459,28 +448,34 @@@ extern int ip_options_rcv_srr(struct sk
   *	Functions provided by ip_sockglue.c
   */
  
 -void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb);
 -void ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb);
 -int ip_cmsg_send(struct net *net, struct msghdr *msg, struct ipcm_cookie *ipc);
 -int ip_setsockopt(struct sock *sk, int level, int optname, char __user *optval,
 -		  unsigned int optlen);
 -int ip_getsockopt(struct sock *sk, int level, int optname, char __user *optval,
 -		  int __user *optlen);
 -int compat_ip_setsockopt(struct sock *sk, int level, int optname,
 -			 char __user *optval, unsigned int optlen);
 -int compat_ip_getsockopt(struct sock *sk, int level, int optname,
 -			 char __user *optval, int __user *optlen);
 -int ip_ra_control(struct sock *sk, unsigned char on,
 -		  void (*destructor)(struct sock *));
 -
 +extern void	ipv4_pktinfo_prepare(struct sk_buff *skb);
 +extern void	ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb);
 +extern int	ip_cmsg_send(struct net *net,
 +			     struct msghdr *msg, struct ipcm_cookie *ipc);
 +extern int	ip_setsockopt(struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen);
 +extern int	ip_getsockopt(struct sock *sk, int level, int optname, char __user *optval, int __user *optlen);
 +extern int	compat_ip_setsockopt(struct sock *sk, int level,
 +			int optname, char __user *optval, unsigned int optlen);
 +extern int	compat_ip_getsockopt(struct sock *sk, int level,
 +			int optname, char __user *optval, int __user *optlen);
 +extern int	ip_ra_control(struct sock *sk, unsigned char on, void (*destructor)(struct sock *));
 +
++<<<<<<< HEAD
 +extern int 	ip_recv_error(struct sock *sk, struct msghdr *msg, int len);
 +extern void	ip_icmp_error(struct sock *sk, struct sk_buff *skb, int err, 
 +			      __be16 port, u32 info, u8 *payload);
 +extern void	ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 dport,
 +			       u32 info);
++=======
+ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len);
+ void ip_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,
+ 		   u32 info, u8 *payload);
+ void ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 dport,
+ 		    u32 info);
++>>>>>>> 85fbaa75037d (inet: fix addr_len/msg->msg_namelen assignment in recv_error and rxpmtu functions)
  
  #ifdef CONFIG_PROC_FS
 -int ip_misc_proc_init(void);
 +extern int ip_misc_proc_init(void);
  #endif
  
  #endif	/* _IP_H */
diff --cc include/net/ipv6.h
index e6b71dd022cb,eb198acaac1d..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -774,44 -765,33 +774,55 @@@ extern struct in6_addr *fl6_update_dst(
   *	socket options (ipv6_sockglue.c)
   */
  
 -int ipv6_setsockopt(struct sock *sk, int level, int optname,
 -		    char __user *optval, unsigned int optlen);
 -int ipv6_getsockopt(struct sock *sk, int level, int optname,
 -		    char __user *optval, int __user *optlen);
 -int compat_ipv6_setsockopt(struct sock *sk, int level, int optname,
 -			   char __user *optval, unsigned int optlen);
 -int compat_ipv6_getsockopt(struct sock *sk, int level, int optname,
 -			   char __user *optval, int __user *optlen);
 -
 -int ip6_datagram_connect(struct sock *sk, struct sockaddr *addr, int addr_len);
 -
 +extern int			ipv6_setsockopt(struct sock *sk, int level, 
 +						int optname,
 +						char __user *optval, 
 +						unsigned int optlen);
 +extern int			ipv6_getsockopt(struct sock *sk, int level, 
 +						int optname,
 +						char __user *optval, 
 +						int __user *optlen);
 +extern int			compat_ipv6_setsockopt(struct sock *sk,
 +						int level,
 +						int optname,
 +						char __user *optval,
 +						unsigned int optlen);
 +extern int			compat_ipv6_getsockopt(struct sock *sk,
 +						int level,
 +						int optname,
 +						char __user *optval,
 +						int __user *optlen);
 +
 +extern int			ip6_datagram_connect(struct sock *sk, 
 +						     struct sockaddr *addr, int addr_len);
 +
++<<<<<<< HEAD
 +extern int 			ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len);
 +extern int 			ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len);
 +extern void			ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,
 +						u32 info, u8 *payload);
 +extern void			ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info);
 +extern void			ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu);
++=======
+ int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,
+ 		    int *addr_len);
+ int ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,
+ 		     int *addr_len);
+ void ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,
+ 		     u32 info, u8 *payload);
+ void ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info);
+ void ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu);
++>>>>>>> 85fbaa75037d (inet: fix addr_len/msg->msg_namelen assignment in recv_error and rxpmtu functions)
  
 -int inet6_release(struct socket *sock);
 -int inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len);
 -int inet6_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len,
 -		  int peer);
 -int inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 +extern int inet6_release(struct socket *sock);
 +extern int inet6_bind(struct socket *sock, struct sockaddr *uaddr, 
 +		      int addr_len);
 +extern int inet6_getname(struct socket *sock, struct sockaddr *uaddr,
 +			 int *uaddr_len, int peer);
 +extern int inet6_ioctl(struct socket *sock, unsigned int cmd, 
 +		       unsigned long arg);
  
 -int inet6_hash_connect(struct inet_timewait_death_row *death_row,
 +extern int inet6_hash_connect(struct inet_timewait_death_row *death_row,
  			      struct sock *sk);
  
  /*
diff --cc include/net/ping.h
index 682b5ae9af51,90f48417b03d..000000000000
--- a/include/net/ping.h
+++ b/include/net/ping.h
@@@ -28,6 -29,19 +28,22 @@@
   */
  #define GID_T_MAX (((gid_t)~0U) >> 1)
  
++<<<<<<< HEAD
++=======
+ /* Compatibility glue so we can support IPv6 when it's compiled as a module */
+ struct pingv6_ops {
+ 	int (*ipv6_recv_error)(struct sock *sk, struct msghdr *msg, int len,
+ 			       int *addr_len);
+ 	int (*ip6_datagram_recv_ctl)(struct sock *sk, struct msghdr *msg,
+ 				     struct sk_buff *skb);
+ 	int (*icmpv6_err_convert)(u8 type, u8 code, int *err);
+ 	void (*ipv6_icmp_error)(struct sock *sk, struct sk_buff *skb, int err,
+ 				__be16 port, u32 info, u8 *payload);
+ 	int (*ipv6_chk_addr)(struct net *net, const struct in6_addr *addr,
+ 			     const struct net_device *dev, int strict);
+ };
+ 
++>>>>>>> 85fbaa75037d (inet: fix addr_len/msg->msg_namelen assignment in recv_error and rxpmtu functions)
  struct ping_table {
  	struct hlist_nulls_head	hash[PING_HTABLE_SIZE];
  	rwlock_t		lock;
diff --cc net/ipv4/ping.c
index 7d93d62cd5fd,840cf1b9e6ee..000000000000
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@@ -636,11 -839,16 +636,24 @@@ static int ping_recvmsg(struct kiocb *i
  	if (flags & MSG_OOB)
  		goto out;
  
++<<<<<<< HEAD
 +	if (addr_len)
 +		*addr_len = sizeof(*sin);
 +
 +	if (flags & MSG_ERRQUEUE)
 +		return ip_recv_error(sk, msg, len);
++=======
+ 	if (flags & MSG_ERRQUEUE) {
+ 		if (family == AF_INET) {
+ 			return ip_recv_error(sk, msg, len, addr_len);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		} else if (family == AF_INET6) {
+ 			return pingv6_ops.ipv6_recv_error(sk, msg, len,
+ 							  addr_len);
+ #endif
+ 		}
+ 	}
++>>>>>>> 85fbaa75037d (inet: fix addr_len/msg->msg_namelen assignment in recv_error and rxpmtu functions)
  
  	skb = skb_recv_datagram(sk, flags, noblock, &err);
  	if (!skb)
* Unmerged path net/ipv6/ping.c
* Unmerged path include/net/ip.h
* Unmerged path include/net/ipv6.h
* Unmerged path include/net/ping.h
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index d9c4f113d709..23e6ab0a2dc0 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -368,7 +368,7 @@ void ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 port, u32 inf
 /*
  *	Handle MSG_ERRQUEUE
  */
-int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)
+int ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
 {
 	struct sock_exterr_skb *serr;
 	struct sk_buff *skb, *skb2;
@@ -405,6 +405,7 @@ int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)
 						   serr->addr_offset);
 		sin->sin_port = serr->port;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		*addr_len = sizeof(*sin);
 	}
 
 	memcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));
* Unmerged path net/ipv4/ping.c
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index dd44e0ab600c..8502af9a4b9b 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -695,7 +695,7 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		*addr_len = sizeof(*sin);
 
 	if (flags & MSG_ERRQUEUE) {
-		err = ip_recv_error(sk, msg, len);
+		err = ip_recv_error(sk, msg, len, addr_len);
 		goto out;
 	}
 
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 10d9853d1d5e..9698cc3f6d5f 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1215,7 +1215,7 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		*addr_len = sizeof(*sin);
 
 	if (flags & MSG_ERRQUEUE)
-		return ip_recv_error(sk, msg, len);
+		return ip_recv_error(sk, msg, len, addr_len);
 
 try_again:
 	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index 197e6f4a2b74..a5ca9bf9d38d 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -318,7 +318,7 @@ void ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu)
 /*
  *	Handle MSG_ERRQUEUE
  */
-int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len)
+int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sock_exterr_skb *serr;
@@ -369,6 +369,7 @@ int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len)
 					       &sin->sin6_addr);
 			sin->sin6_scope_id = 0;
 		}
+		*addr_len = sizeof(*sin);
 	}
 
 	memcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));
@@ -423,7 +424,8 @@ EXPORT_SYMBOL_GPL(ipv6_recv_error);
 /*
  *	Handle IPV6_RECVPATHMTU
  */
-int ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len)
+int ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,
+		     int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sk_buff *skb;
@@ -457,6 +459,7 @@ int ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len)
 		sin->sin6_port = 0;
 		sin->sin6_scope_id = mtu_info.ip6m_addr.sin6_scope_id;
 		sin->sin6_addr = mtu_info.ip6m_addr.sin6_addr;
+		*addr_len = sizeof(*sin);
 	}
 
 	put_cmsg(msg, SOL_IPV6, IPV6_PATHMTU, sizeof(mtu_info), &mtu_info);
* Unmerged path net/ipv6/ping.c
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index c45f7a5c36e9..ef1a70080127 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -463,10 +463,10 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,
 		*addr_len=sizeof(*sin6);
 
 	if (flags & MSG_ERRQUEUE)
-		return ipv6_recv_error(sk, msg, len);
+		return ipv6_recv_error(sk, msg, len, addr_len);
 
 	if (np->rxpmtu && np->rxopt.bits.rxpmtu)
-		return ipv6_recv_rxpmtu(sk, msg, len);
+		return ipv6_recv_rxpmtu(sk, msg, len, addr_len);
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index cb330ff1db0d..b71c4d1bfbf6 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -378,10 +378,10 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,
 		*addr_len = sizeof(struct sockaddr_in6);
 
 	if (flags & MSG_ERRQUEUE)
-		return ipv6_recv_error(sk, msg, len);
+		return ipv6_recv_error(sk, msg, len, addr_len);
 
 	if (np->rxpmtu && np->rxopt.bits.rxpmtu)
-		return ipv6_recv_rxpmtu(sk, msg, len);
+		return ipv6_recv_rxpmtu(sk, msg, len, addr_len);
 
 try_again:
 	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c
index b8a6039314e8..e6e8408c9e36 100644
--- a/net/l2tp/l2tp_ip6.c
+++ b/net/l2tp/l2tp_ip6.c
@@ -665,7 +665,7 @@ static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
 		*addr_len = sizeof(*lsa);
 
 	if (flags & MSG_ERRQUEUE)
-		return ipv6_recv_error(sk, msg, len);
+		return ipv6_recv_error(sk, msg, len, addr_len);
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
