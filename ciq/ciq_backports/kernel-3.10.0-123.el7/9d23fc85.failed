xfs: vectorise directory data operations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 9d23fc8575de7012b8853bd6fefe10534665de2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/9d23fc85.failed

Following from the initial patches to vectorise the shortform
directory encode/decode operations, convert half the data block
operations to use the vector. The rest will be done in a second
patch.

This further reduces the size of the built binary:

   text    data     bss     dec     hex filename
 794490   96802    1096  892388   d9de4 fs/xfs/xfs.o.orig
 792986   96802    1096  890884   d9804 fs/xfs/xfs.o.p1
 792350   96802    1096  890248   d9588 fs/xfs/xfs.o.p2
 789293   96802    1096  887191   d8997 fs/xfs/xfs.o.p3

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 9d23fc8575de7012b8853bd6fefe10534665de2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_da_format.c
#	fs/xfs/xfs_dir2.h
#	fs/xfs/xfs_dir2_block.c
#	fs/xfs/xfs_dir2_data.c
#	fs/xfs/xfs_dir2_format.h
#	fs/xfs/xfs_dir2_leaf.c
#	fs/xfs/xfs_dir2_node.c
#	fs/xfs/xfs_dir2_readdir.c
#	fs/xfs/xfs_dir2_sf.c
diff --cc fs/xfs/xfs_dir2.h
index e937d9991c18,c0a45923cce0..000000000000
--- a/fs/xfs/xfs_dir2.h
+++ b/fs/xfs/xfs_dir2.h
@@@ -27,6 -32,47 +27,50 @@@ struct xfs_trans
  extern struct xfs_name	xfs_name_dotdot;
  
  /*
++<<<<<<< HEAD
++=======
+  * directory operations vector for encode/decode routines
+  */
+ struct xfs_dir_ops {
+ 	int	(*sf_entsize)(struct xfs_dir2_sf_hdr *hdr, int len);
+ 	struct xfs_dir2_sf_entry *
+ 		(*sf_nextentry)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	__uint8_t (*sf_get_ftype)(struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ftype)(struct xfs_dir2_sf_entry *sfep,
+ 				__uint8_t ftype);
+ 	xfs_ino_t (*sf_get_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				struct xfs_dir2_sf_entry *sfep);
+ 	void	(*sf_put_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 			      struct xfs_dir2_sf_entry *sfep,
+ 			      xfs_ino_t ino);
+ 	xfs_ino_t (*sf_get_parent_ino)(struct xfs_dir2_sf_hdr *hdr);
+ 	void	(*sf_put_parent_ino)(struct xfs_dir2_sf_hdr *hdr,
+ 				     xfs_ino_t ino);
+ 
+ 	int	(*data_entsize)(int len);
+ 	__uint8_t (*data_get_ftype)(struct xfs_dir2_data_entry *dep);
+ 	void	(*data_put_ftype)(struct xfs_dir2_data_entry *dep,
+ 				__uint8_t ftype);
+ 	__be16 * (*data_entry_tag_p)(struct xfs_dir2_data_entry *dep);
+ 
+ 	xfs_dir2_data_aoff_t (*data_dot_offset)(void);
+ 	xfs_dir2_data_aoff_t (*data_dotdot_offset)(void);
+ 	xfs_dir2_data_aoff_t (*data_first_offset)(void);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_dot_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_dotdot_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ 	struct xfs_dir2_data_entry *
+ 		(*data_first_entry_p)(struct xfs_dir2_data_hdr *hdr);
+ };
+ 
+ extern const struct xfs_dir_ops xfs_dir2_ops;
+ extern const struct xfs_dir_ops xfs_dir2_ftype_ops;
+ extern const struct xfs_dir_ops xfs_dir3_ops;
+ 
+ /*
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
   * Generic directory interface routines
   */
  extern void xfs_dir_startup(void);
@@@ -57,4 -103,36 +101,39 @@@ extern int xfs_dir_canenter(struct xfs_
   */
  extern int xfs_dir2_sf_to_block(struct xfs_da_args *args);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Interface routines used by userspace utilities
+  */
+ extern int xfs_dir2_isblock(struct xfs_trans *tp, struct xfs_inode *dp, int *r);
+ extern int xfs_dir2_isleaf(struct xfs_trans *tp, struct xfs_inode *dp, int *r);
+ extern int xfs_dir2_shrink_inode(struct xfs_da_args *args, xfs_dir2_db_t db,
+ 				struct xfs_buf *bp);
+ 
+ extern void xfs_dir2_data_freescan(struct xfs_inode *dp,
+ 		struct xfs_dir2_data_hdr *hdr, int *loghead);
+ extern void xfs_dir2_data_log_entry(struct xfs_trans *tp, struct xfs_inode *dp,
+ 		struct xfs_buf *bp, struct xfs_dir2_data_entry *dep);
+ extern void xfs_dir2_data_log_header(struct xfs_trans *tp,
+ 		struct xfs_buf *bp);
+ extern void xfs_dir2_data_log_unused(struct xfs_trans *tp, struct xfs_buf *bp,
+ 		struct xfs_dir2_data_unused *dup);
+ extern void xfs_dir2_data_make_free(struct xfs_trans *tp, struct xfs_buf *bp,
+ 		xfs_dir2_data_aoff_t offset, xfs_dir2_data_aoff_t len,
+ 		int *needlogp, int *needscanp);
+ extern void xfs_dir2_data_use_free(struct xfs_trans *tp, struct xfs_buf *bp,
+ 		struct xfs_dir2_data_unused *dup, xfs_dir2_data_aoff_t offset,
+ 		xfs_dir2_data_aoff_t len, int *needlogp, int *needscanp);
+ 
+ extern struct xfs_dir2_data_free *xfs_dir2_data_freefind(
+ 		struct xfs_dir2_data_hdr *hdr, struct xfs_dir2_data_unused *dup);
+ 
+ extern const struct xfs_buf_ops xfs_dir3_block_buf_ops;
+ extern const struct xfs_buf_ops xfs_dir3_leafn_buf_ops;
+ extern const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops;
+ extern const struct xfs_buf_ops xfs_dir3_free_buf_ops;
+ extern const struct xfs_buf_ops xfs_dir3_data_buf_ops;
+ 
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  #endif	/* __XFS_DIR2_H__ */
diff --cc fs/xfs/xfs_dir2_block.c
index 53b9aa26d567,507ef6a7d1f9..000000000000
--- a/fs/xfs/xfs_dir2_block.c
+++ b/fs/xfs/xfs_dir2_block.c
@@@ -369,7 -370,7 +370,11 @@@ xfs_dir2_block_addname
  	if (error)
  		return error;
  
++<<<<<<< HEAD
 +	len = xfs_dir2_data_entsize(args->namelen);
++=======
+ 	len = dp->d_ops->data_entsize(args->namelen);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  
  	/*
  	 * Set up pointers to parts of the block.
@@@ -549,7 -550,8 +554,12 @@@
  	dep->inumber = cpu_to_be64(args->inumber);
  	dep->namelen = args->namelen;
  	memcpy(dep->name, args->name, args->namelen);
++<<<<<<< HEAD
 +	tagp = xfs_dir2_data_entry_tag_p(dep);
++=======
+ 	dp->d_ops->data_put_ftype(dep, args->filetype);
+ 	tagp = dp->d_ops->data_entry_tag_p(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	*tagp = cpu_to_be16((char *)dep - (char *)hdr);
  	/*
  	 * Clean up the bestfree array and log the header, tail, and entry.
@@@ -739,6 -643,7 +749,10 @@@ xfs_dir2_block_lookup
  	 * Fill in inode number, CI name if appropriate, release the block.
  	 */
  	args->inumber = be64_to_cpu(dep->inumber);
++<<<<<<< HEAD
++=======
+ 	args->filetype = dp->d_ops->data_get_ftype(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	error = xfs_dir_cilookup_result(args, dep->name, dep->namelen);
  	xfs_trans_brelse(args->trans, bp);
  	return XFS_ERROR(error);
@@@ -897,7 -802,7 +911,11 @@@ xfs_dir2_block_removename
  	needlog = needscan = 0;
  	xfs_dir2_data_make_free(tp, bp,
  		(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),
++<<<<<<< HEAD
 +		xfs_dir2_data_entsize(dep->namelen), &needlog, &needscan);
++=======
+ 		dp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	/*
  	 * Fix up the block tail.
  	 */
@@@ -971,7 -876,8 +989,12 @@@ xfs_dir2_block_replace
  	 * Change the inode number to the new value.
  	 */
  	dep->inumber = cpu_to_be64(args->inumber);
++<<<<<<< HEAD
 +	xfs_dir2_data_log_entry(args->trans, bp, dep);
++=======
+ 	dp->d_ops->data_put_ftype(dep, args->filetype);
+ 	xfs_dir2_data_log_entry(args->trans, dp, bp, dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	xfs_dir3_data_check(dp, bp);
  	return 0;
  }
@@@ -1253,30 -1159,32 +1276,52 @@@ xfs_dir2_sf_to_block
  	/*
  	 * Create entry for .
  	 */
++<<<<<<< HEAD
 +	dep = xfs_dir3_data_dot_entry_p(hdr);
 +	dep->inumber = cpu_to_be64(dp->i_ino);
 +	dep->namelen = 1;
 +	dep->name[0] = '.';
 +	tagp = xfs_dir2_data_entry_tag_p(dep);
++=======
+ 	dep = dp->d_ops->data_dot_entry_p(hdr);
+ 	dep->inumber = cpu_to_be64(dp->i_ino);
+ 	dep->namelen = 1;
+ 	dep->name[0] = '.';
+ 	dp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);
+ 	tagp = dp->d_ops->data_entry_tag_p(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	*tagp = cpu_to_be16((char *)dep - (char *)hdr);
- 	xfs_dir2_data_log_entry(tp, bp, dep);
+ 	xfs_dir2_data_log_entry(tp, dp, bp, dep);
  	blp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);
  	blp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(mp,
  				(char *)dep - (char *)hdr));
  	/*
  	 * Create entry for ..
  	 */
++<<<<<<< HEAD
 +	dep = xfs_dir3_data_dotdot_entry_p(hdr);
 +	dep->inumber = cpu_to_be64(xfs_dir2_sf_get_parent_ino(sfp));
 +	dep->namelen = 2;
 +	dep->name[0] = dep->name[1] = '.';
 +	tagp = xfs_dir2_data_entry_tag_p(dep);
++=======
+ 	dep = dp->d_ops->data_dotdot_entry_p(hdr);
+ 	dep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));
+ 	dep->namelen = 2;
+ 	dep->name[0] = dep->name[1] = '.';
+ 	dp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);
+ 	tagp = dp->d_ops->data_entry_tag_p(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	*tagp = cpu_to_be16((char *)dep - (char *)hdr);
- 	xfs_dir2_data_log_entry(tp, bp, dep);
+ 	xfs_dir2_data_log_entry(tp, dp, bp, dep);
  	blp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);
  	blp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(mp,
  				(char *)dep - (char *)hdr));
++<<<<<<< HEAD
 +	offset = xfs_dir3_data_first_offset(hdr);
++=======
+ 	offset = dp->d_ops->data_first_offset();
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	/*
  	 * Loop over existing entries, stuff them in.
  	 */
@@@ -1315,12 -1223,13 +1360,18 @@@
  		 * Copy a real entry.
  		 */
  		dep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);
 -		dep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));
 +		dep->inumber = cpu_to_be64(xfs_dir2_sfe_get_ino(sfp, sfep));
  		dep->namelen = sfep->namelen;
++<<<<<<< HEAD
 +		memcpy(dep->name, sfep->name, dep->namelen);
 +		tagp = xfs_dir2_data_entry_tag_p(dep);
++=======
+ 		dp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));
+ 		memcpy(dep->name, sfep->name, dep->namelen);
+ 		tagp = dp->d_ops->data_entry_tag_p(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  		*tagp = cpu_to_be16((char *)dep - (char *)hdr);
- 		xfs_dir2_data_log_entry(tp, bp, dep);
+ 		xfs_dir2_data_log_entry(tp, dp, bp, dep);
  		name.name = sfep->name;
  		name.len = sfep->namelen;
  		blp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->
diff --cc fs/xfs/xfs_dir2_data.c
index e4ce4801d4ae,00006b3db054..000000000000
--- a/fs/xfs/xfs_dir2_data.c
+++ b/fs/xfs/xfs_dir2_data.c
@@@ -149,8 -160,10 +163,15 @@@ __xfs_dir3_data_check
  		XFS_WANT_CORRUPTED_RETURN(
  			!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));
  		XFS_WANT_CORRUPTED_RETURN(
++<<<<<<< HEAD
 +			be16_to_cpu(*xfs_dir2_data_entry_tag_p(dep)) ==
 +					       (char *)dep - (char *)hdr);
++=======
+ 			be16_to_cpu(*ops->data_entry_tag_p(dep)) ==
+ 					       (char *)dep - (char *)hdr);
+ 		XFS_WANT_CORRUPTED_RETURN(
+ 				ops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  		count++;
  		lastfree = 0;
  		if (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||
@@@ -168,7 -181,7 +189,11 @@@
  			}
  			XFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));
  		}
++<<<<<<< HEAD
 +		p += xfs_dir2_data_entsize(dep->namelen);
++=======
+ 		p += ops->data_entsize(dep->namelen);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	}
  	/*
  	 * Need to have seen all the entries and all the bestfree slots.
@@@ -538,8 -551,8 +563,13 @@@ xfs_dir2_data_freescan
  		else {
  			dep = (xfs_dir2_data_entry_t *)p;
  			ASSERT((char *)dep - (char *)hdr ==
++<<<<<<< HEAD
 +			       be16_to_cpu(*xfs_dir2_data_entry_tag_p(dep)));
 +			p += xfs_dir2_data_entsize(dep->namelen);
++=======
+ 			       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));
+ 			p += dp->d_ops->data_entsize(dep->namelen);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  		}
  	}
  }
@@@ -629,7 -643,7 +660,11 @@@ xfs_dir2_data_log_entry
  	struct xfs_buf		*bp,
  	xfs_dir2_data_entry_t	*dep)		/* data entry pointer */
  {
++<<<<<<< HEAD
 +	xfs_dir2_data_hdr_t	*hdr = bp->b_addr;
++=======
+ 	struct xfs_dir2_data_hdr *hdr = bp->b_addr;
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  
  	ASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||
  	       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||
@@@ -637,7 -651,7 +672,11 @@@
  	       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));
  
  	xfs_trans_log_buf(tp, bp, (uint)((char *)dep - (char *)hdr),
++<<<<<<< HEAD
 +		(uint)((char *)(xfs_dir2_data_entry_tag_p(dep) + 1) -
++=======
+ 		(uint)((char *)(dp->d_ops->data_entry_tag_p(dep) + 1) -
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  		       (char *)hdr - 1));
  }
  
diff --cc fs/xfs/xfs_dir2_format.h
index 2095e17b75cb,5b72dd2f8a69..000000000000
--- a/fs/xfs/xfs_dir2_format.h
+++ b/fs/xfs/xfs_dir2_format.h
@@@ -309,25 -456,6 +309,28 @@@ typedef struct xfs_dir2_data_unused 
  } xfs_dir2_data_unused_t;
  
  /*
++<<<<<<< HEAD:fs/xfs/xfs_dir2_format.h
 + * Size of a data entry.
 + */
 +static inline int xfs_dir2_data_entsize(int n)
 +{
 +	return (int)roundup(offsetof(struct xfs_dir2_data_entry, name[0]) + n +
 +		 (uint)sizeof(xfs_dir2_data_off_t), XFS_DIR2_DATA_ALIGN);
 +}
 +
 +/*
 + * Pointer to an entry's tag word.
 + */
 +static inline __be16 *
 +xfs_dir2_data_entry_tag_p(struct xfs_dir2_data_entry *dep)
 +{
 +	return (__be16 *)((char *)dep +
 +		xfs_dir2_data_entsize(dep->namelen) - sizeof(__be16));
 +}
 +
 +/*
++=======
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations):fs/xfs/xfs_da_format.h
   * Pointer to a freespace's tag word.
   */
  static inline __be16 *
@@@ -368,64 -496,6 +371,67 @@@ xfs_dir3_data_unused_p(struct xfs_dir2_
  }
  
  /*
++<<<<<<< HEAD:fs/xfs/xfs_dir2_format.h
 + * Offsets of . and .. in data space (always block 0)
 + *
 + * The macros are used for shortform directories as they have no headers to read
 + * the magic number out of. Shortform directories need to know the size of the
 + * data block header because the sfe embeds the block offset of the entry into
 + * it so that it doesn't change when format conversion occurs. Bad Things Happen
 + * if we don't follow this rule.
 + */
 +#define	XFS_DIR3_DATA_DOT_OFFSET(mp)	\
 +	xfs_dir3_data_hdr_size(xfs_sb_version_hascrc(&(mp)->m_sb))
 +#define	XFS_DIR3_DATA_DOTDOT_OFFSET(mp)	\
 +	(XFS_DIR3_DATA_DOT_OFFSET(mp) + xfs_dir2_data_entsize(1))
 +#define	XFS_DIR3_DATA_FIRST_OFFSET(mp)		\
 +	(XFS_DIR3_DATA_DOTDOT_OFFSET(mp) + xfs_dir2_data_entsize(2))
 +
 +static inline xfs_dir2_data_aoff_t
 +xfs_dir3_data_dot_offset(struct xfs_dir2_data_hdr *hdr)
 +{
 +	return xfs_dir3_data_entry_offset(hdr);
 +}
 +
 +static inline xfs_dir2_data_aoff_t
 +xfs_dir3_data_dotdot_offset(struct xfs_dir2_data_hdr *hdr)
 +{
 +	return xfs_dir3_data_dot_offset(hdr) + xfs_dir2_data_entsize(1);
 +}
 +
 +static inline xfs_dir2_data_aoff_t
 +xfs_dir3_data_first_offset(struct xfs_dir2_data_hdr *hdr)
 +{
 +	return xfs_dir3_data_dotdot_offset(hdr) + xfs_dir2_data_entsize(2);
 +}
 +
 +/*
 + * location of . and .. in data space (always block 0)
 + */
 +static inline struct xfs_dir2_data_entry *
 +xfs_dir3_data_dot_entry_p(struct xfs_dir2_data_hdr *hdr)
 +{
 +	return (struct xfs_dir2_data_entry *)
 +		((char *)hdr + xfs_dir3_data_dot_offset(hdr));
 +}
 +
 +static inline struct xfs_dir2_data_entry *
 +xfs_dir3_data_dotdot_entry_p(struct xfs_dir2_data_hdr *hdr)
 +{
 +	return (struct xfs_dir2_data_entry *)
 +		((char *)hdr + xfs_dir3_data_dotdot_offset(hdr));
 +}
 +
 +static inline struct xfs_dir2_data_entry *
 +xfs_dir3_data_first_entry_p(struct xfs_dir2_data_hdr *hdr)
 +{
 +	return (struct xfs_dir2_data_entry *)
 +		((char *)hdr + xfs_dir3_data_first_offset(hdr));
 +}
 +
 +/*
++=======
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations):fs/xfs/xfs_da_format.h
   * Leaf block structures.
   *
   * A pure leaf block looks like the following drawing on disk:
diff --cc fs/xfs/xfs_dir2_leaf.c
index 2dedee56777d,dd195363ccf2..000000000000
--- a/fs/xfs/xfs_dir2_leaf.c
+++ b/fs/xfs/xfs_dir2_leaf.c
@@@ -701,7 -700,7 +701,11 @@@ xfs_dir2_leaf_addname
  	ents = xfs_dir3_leaf_ents_p(leaf);
  	xfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);
  	bestsp = xfs_dir2_leaf_bests_p(ltp);
++<<<<<<< HEAD
 +	length = xfs_dir2_data_entsize(args->namelen);
++=======
+ 	length = dp->d_ops->data_entsize(args->namelen);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  
  	/*
  	 * See if there are any entries with the same hash value
@@@ -902,7 -901,8 +906,12 @@@
  	dep->inumber = cpu_to_be64(args->inumber);
  	dep->namelen = args->namelen;
  	memcpy(dep->name, args->name, dep->namelen);
++<<<<<<< HEAD
 +	tagp = xfs_dir2_data_entry_tag_p(dep);
++=======
+ 	dp->d_ops->data_put_ftype(dep, args->filetype);
+ 	tagp = dp->d_ops->data_entry_tag_p(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	*tagp = cpu_to_be16((char *)dep - (char *)hdr);
  	/*
  	 * Need to scan fix up the bestfree table.
@@@ -1622,6 -1230,7 +1631,10 @@@ xfs_dir2_leaf_lookup
  	 * Return the found inode number & CI name if appropriate
  	 */
  	args->inumber = be64_to_cpu(dep->inumber);
++<<<<<<< HEAD
++=======
+ 	args->filetype = dp->d_ops->data_get_ftype(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	error = xfs_dir_cilookup_result(args, dep->name, dep->namelen);
  	xfs_trans_brelse(tp, dbp);
  	xfs_trans_brelse(tp, lbp);
@@@ -1824,7 -1433,7 +1837,11 @@@ xfs_dir2_leaf_removename
  	 */
  	xfs_dir2_data_make_free(tp, dbp,
  		(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),
++<<<<<<< HEAD
 +		xfs_dir2_data_entsize(dep->namelen), &needlog, &needscan);
++=======
+ 		dp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	/*
  	 * We just mark the leaf entry stale by putting a null in it.
  	 */
@@@ -1952,8 -1561,9 +1969,12 @@@ xfs_dir2_leaf_replace
  	 * Put the new inode number in, log it.
  	 */
  	dep->inumber = cpu_to_be64(args->inumber);
++<<<<<<< HEAD
++=======
+ 	dp->d_ops->data_put_ftype(dep, args->filetype);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	tp = args->trans;
- 	xfs_dir2_data_log_entry(tp, dbp, dep);
+ 	xfs_dir2_data_log_entry(tp, dp, dbp, dep);
  	xfs_dir3_leaf_check(dp->i_mount, lbp);
  	xfs_trans_brelse(tp, lbp);
  	return 0;
diff --cc fs/xfs/xfs_dir2_node.c
index cae73a62bfcc,a1d133981c14..000000000000
--- a/fs/xfs/xfs_dir2_node.c
+++ b/fs/xfs/xfs_dir2_node.c
@@@ -604,7 -604,7 +604,11 @@@ xfs_dir2_leafn_lookup_for_addname
  		ASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||
  		       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));
  	}
++<<<<<<< HEAD
 +	length = xfs_dir2_data_entsize(args->namelen);
++=======
+ 	length = dp->d_ops->data_entsize(args->namelen);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	/*
  	 * Loop over leaf entries with the right hash value.
  	 */
@@@ -815,6 -815,7 +819,10 @@@ xfs_dir2_leafn_lookup_for_entry
  				xfs_trans_brelse(tp, state->extrablk.bp);
  			args->cmpresult = cmp;
  			args->inumber = be64_to_cpu(dep->inumber);
++<<<<<<< HEAD
++=======
+ 			args->filetype = dp->d_ops->data_get_ftype(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  			*indexp = index;
  			state->extravalid = 1;
  			state->extrablk.bp = curbp;
@@@ -1258,7 -1259,7 +1266,11 @@@ xfs_dir2_leafn_remove
  	longest = be16_to_cpu(bf[0].length);
  	needlog = needscan = 0;
  	xfs_dir2_data_make_free(tp, dbp, off,
++<<<<<<< HEAD
 +		xfs_dir2_data_entsize(dep->namelen), &needlog, &needscan);
++=======
+ 		dp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	/*
  	 * Rescan the data block freespaces for bestfree.
  	 * Log the data block header if needed.
@@@ -1710,7 -1711,7 +1722,11 @@@ xfs_dir2_node_addname_int
  	dp = args->dp;
  	mp = dp->i_mount;
  	tp = args->trans;
++<<<<<<< HEAD
 +	length = xfs_dir2_data_entsize(args->namelen);
++=======
+ 	length = dp->d_ops->data_entsize(args->namelen);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	/*
  	 * If we came in with a freespace block that means that lookup
  	 * found an entry with our hash value.  This is the freespace
@@@ -2006,9 -2007,10 +2022,14 @@@
  	dep->inumber = cpu_to_be64(args->inumber);
  	dep->namelen = args->namelen;
  	memcpy(dep->name, args->name, dep->namelen);
++<<<<<<< HEAD
 +	tagp = xfs_dir2_data_entry_tag_p(dep);
++=======
+ 	dp->d_ops->data_put_ftype(dep, args->filetype);
+ 	tagp = dp->d_ops->data_entry_tag_p(dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	*tagp = cpu_to_be16((char *)dep - (char *)hdr);
- 	xfs_dir2_data_log_entry(tp, dbp, dep);
+ 	xfs_dir2_data_log_entry(tp, dp, dbp, dep);
  	/*
  	 * Rescan the block for bestfree if needed.
  	 */
@@@ -2226,7 -2228,9 +2247,13 @@@ xfs_dir2_node_replace
  		 * Fill in the new inode number and log the entry.
  		 */
  		dep->inumber = cpu_to_be64(inum);
++<<<<<<< HEAD
 +		xfs_dir2_data_log_entry(args->trans, state->extrablk.bp, dep);
++=======
+ 		args->dp->d_ops->data_put_ftype(dep, args->filetype);
+ 		xfs_dir2_data_log_entry(args->trans, args->dp,
+ 					state->extrablk.bp, dep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  		rval = 0;
  	}
  	/*
diff --cc fs/xfs/xfs_dir2_sf.c
index 6157424dbf8f,953e19479151..000000000000
--- a/fs/xfs/xfs_dir2_sf.c
+++ b/fs/xfs/xfs_dir2_sf.c
@@@ -316,12 -248,14 +316,23 @@@ xfs_dir2_block_to_sf
  				(xfs_dir2_data_aoff_t)
  				((char *)dep - (char *)hdr));
  			memcpy(sfep->name, dep->name, dep->namelen);
++<<<<<<< HEAD
 +			xfs_dir2_sfe_put_ino(sfp, sfep,
 +					     be64_to_cpu(dep->inumber));
++=======
+ 			dp->d_ops->sf_put_ino(sfp, sfep,
+ 					      be64_to_cpu(dep->inumber));
+ 			dp->d_ops->sf_put_ftype(sfep,
+ 					dp->d_ops->data_get_ftype(dep));
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  
 -			sfep = dp->d_ops->sf_nextentry(sfp, sfep);
 +			sfep = xfs_dir2_sf_nextentry(sfp, sfep);
  		}
++<<<<<<< HEAD
 +		ptr += xfs_dir2_data_entsize(dep->namelen);
++=======
+ 		ptr += dp->d_ops->data_entsize(dep->namelen);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	}
  	ASSERT((char *)sfep - (char *)sfp == size);
  	xfs_dir2_sf_check(args);
@@@ -535,13 -473,13 +546,23 @@@ xfs_dir2_sf_addname_hard
  	 * to insert the new entry.
  	 * If it's going to end up at the end then oldsfep will point there.
  	 */
++<<<<<<< HEAD
 +	for (offset = XFS_DIR3_DATA_FIRST_OFFSET(dp->i_mount),
 +	      oldsfep = xfs_dir2_sf_firstentry(oldsfp),
 +	      add_datasize = xfs_dir2_data_entsize(args->namelen),
 +	      eof = (char *)oldsfep == &buf[old_isize];
 +	     !eof;
 +	     offset = new_offset + xfs_dir2_data_entsize(oldsfep->namelen),
 +	      oldsfep = xfs_dir2_sf_nextentry(oldsfp, oldsfep),
++=======
+ 	for (offset = dp->d_ops->data_first_offset(),
+ 	      oldsfep = xfs_dir2_sf_firstentry(oldsfp),
+ 	      add_datasize = dp->d_ops->data_entsize(args->namelen),
+ 	      eof = (char *)oldsfep == &buf[old_isize];
+ 	     !eof;
+ 	     offset = new_offset + dp->d_ops->data_entsize(oldsfep->namelen),
+ 	      oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep),
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	      eof = (char *)oldsfep == &buf[old_isize]) {
  		new_offset = xfs_dir2_sf_get_offset(oldsfep);
  		if (offset + add_datasize <= new_offset)
@@@ -616,8 -555,8 +637,13 @@@ xfs_dir2_sf_addname_pick
  	mp = dp->i_mount;
  
  	sfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;
++<<<<<<< HEAD
 +	size = xfs_dir2_data_entsize(args->namelen);
 +	offset = XFS_DIR3_DATA_FIRST_OFFSET(mp);
++=======
+ 	size = dp->d_ops->data_entsize(args->namelen);
+ 	offset = dp->d_ops->data_first_offset();
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	sfep = xfs_dir2_sf_firstentry(sfp);
  	holefit = 0;
  	/*
@@@ -629,8 -568,8 +655,13 @@@
  		if (!holefit)
  			holefit = offset + size <= xfs_dir2_sf_get_offset(sfep);
  		offset = xfs_dir2_sf_get_offset(sfep) +
++<<<<<<< HEAD
 +			 xfs_dir2_data_entsize(sfep->namelen);
 +		sfep = xfs_dir2_sf_nextentry(sfp, sfep);
++=======
+ 			 dp->d_ops->data_entsize(sfep->namelen);
+ 		sfep = dp->d_ops->sf_nextentry(sfp, sfep);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	}
  	/*
  	 * Calculate data bytes used excluding the new entry, if this
@@@ -684,12 -623,14 +715,17 @@@ xfs_dir2_sf_check
  	int			offset;		/* data offset */
  	xfs_dir2_sf_entry_t	*sfep;		/* shortform dir entry */
  	xfs_dir2_sf_hdr_t	*sfp;		/* shortform structure */
 -	struct xfs_mount	*mp;
  
  	dp = args->dp;
 -	mp = dp->i_mount;
  
  	sfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;
++<<<<<<< HEAD
 +	offset = XFS_DIR3_DATA_FIRST_OFFSET(dp->i_mount);
 +	ino = xfs_dir2_sf_get_parent_ino(sfp);
++=======
+ 	offset = dp->d_ops->data_first_offset();
+ 	ino = dp->d_ops->sf_get_parent_ino(sfp);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	i8count = ino > XFS_DIR2_MAX_SHORT_INUM;
  
  	for (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);
@@@ -700,7 -641,8 +736,12 @@@
  		i8count += ino > XFS_DIR2_MAX_SHORT_INUM;
  		offset =
  			xfs_dir2_sf_get_offset(sfep) +
++<<<<<<< HEAD
 +			xfs_dir2_data_entsize(sfep->namelen);
++=======
+ 			dp->d_ops->data_entsize(sfep->namelen);
+ 		ASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);
++>>>>>>> 9d23fc8575de (xfs: vectorise directory data operations)
  	}
  	ASSERT(i8count == sfp->i8count);
  	ASSERT(XFS_BIG_INUMS || i8count == 0);
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_dir2_readdir.c
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_dir2.h
* Unmerged path fs/xfs/xfs_dir2_block.c
* Unmerged path fs/xfs/xfs_dir2_data.c
* Unmerged path fs/xfs/xfs_dir2_format.h
* Unmerged path fs/xfs/xfs_dir2_leaf.c
* Unmerged path fs/xfs/xfs_dir2_node.c
* Unmerged path fs/xfs/xfs_dir2_readdir.c
* Unmerged path fs/xfs/xfs_dir2_sf.c
