inet: prevent leakage of uninitialized memory to user in recv syscalls

jira LE-1907
cve CVE-2013-6405
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit bceaa90240b6019ed73b49965eac7d167610be69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/bceaa902.failed

Only update *addr_len when we actually fill in sockaddr, otherwise we
can return uninitialized memory from the stack to the caller in the
recvfrom, recvmmsg and recvmsg syscalls. Drop the the (addr_len == NULL)
checks because we only get called with a valid addr_len pointer either
from sock_common_recvmsg or inet_recvmsg.

If a blocking read waits on a socket which is concurrently shut down we
now return zero and set msg_msgnamelen to 0.

	Reported-by: mpb <mpb.mail@gmail.com>
	Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bceaa90240b6019ed73b49965eac7d167610be69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ping.c
diff --cc net/ipv4/ping.c
index 7d93d62cd5fd,aacefa0caa36..000000000000
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@@ -622,11 -825,11 +622,15 @@@ do_confirm
  	goto out;
  }
  
 -int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 -		 size_t len, int noblock, int flags, int *addr_len)
 +static int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 +			size_t len, int noblock, int flags, int *addr_len)
  {
  	struct inet_sock *isk = inet_sk(sk);
++<<<<<<< HEAD
 +	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
++=======
+ 	int family = sk->sk_family;
++>>>>>>> bceaa90240b6 (inet: prevent leakage of uninitialized memory to user in recv syscalls)
  	struct sk_buff *skb;
  	int copied, err;
  
@@@ -636,11 -839,15 +640,23 @@@
  	if (flags & MSG_OOB)
  		goto out;
  
++<<<<<<< HEAD
 +	if (addr_len)
 +		*addr_len = sizeof(*sin);
 +
 +	if (flags & MSG_ERRQUEUE)
 +		return ip_recv_error(sk, msg, len);
++=======
+ 	if (flags & MSG_ERRQUEUE) {
+ 		if (family == AF_INET) {
+ 			return ip_recv_error(sk, msg, len);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		} else if (family == AF_INET6) {
+ 			return pingv6_ops.ipv6_recv_error(sk, msg, len);
+ #endif
+ 		}
+ 	}
++>>>>>>> bceaa90240b6 (inet: prevent leakage of uninitialized memory to user in recv syscalls)
  
  	skb = skb_recv_datagram(sk, flags, noblock, &err);
  	if (!skb)
@@@ -659,15 -866,44 +675,53 @@@
  
  	sock_recv_timestamp(msg, sk, skb);
  
++<<<<<<< HEAD
 +	/* Copy the address. */
 +	if (sin) {
++=======
+ 	/* Copy the address and add cmsg data. */
+ 	if (family == AF_INET) {
+ 		struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
+ 
++>>>>>>> bceaa90240b6 (inet: prevent leakage of uninitialized memory to user in recv syscalls)
  		sin->sin_family = AF_INET;
  		sin->sin_port = 0 /* skb->h.uh->source */;
  		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
  		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
++<<<<<<< HEAD
++=======
+ 		*addr_len = sizeof(*sin);
+ 
+ 		if (isk->cmsg_flags)
+ 			ip_cmsg_recv(msg, skb);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (family == AF_INET6) {
+ 		struct ipv6_pinfo *np = inet6_sk(sk);
+ 		struct ipv6hdr *ip6 = ipv6_hdr(skb);
+ 		struct sockaddr_in6 *sin6 =
+ 			(struct sockaddr_in6 *)msg->msg_name;
+ 
+ 		sin6->sin6_family = AF_INET6;
+ 		sin6->sin6_port = 0;
+ 		sin6->sin6_addr = ip6->saddr;
+ 		sin6->sin6_flowinfo = 0;
+ 		if (np->sndflow)
+ 			sin6->sin6_flowinfo = ip6_flowinfo(ip6);
+ 
+ 		sin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,
+ 							  IP6CB(skb)->iif);
+ 		*addr_len = sizeof(*sin6);
+ 
+ 		if (inet6_sk(sk)->rxopt.all)
+ 			pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);
+ #endif
+ 	} else {
+ 		BUG();
++>>>>>>> bceaa90240b6 (inet: prevent leakage of uninitialized memory to user in recv syscalls)
  	}
 -
 +	if (isk->cmsg_flags)
 +		ip_cmsg_recv(msg, skb);
  	err = copied;
  
  done:
diff --git a/net/ieee802154/dgram.c b/net/ieee802154/dgram.c
index 581a59504bd5..1865fdf5a5a5 100644
--- a/net/ieee802154/dgram.c
+++ b/net/ieee802154/dgram.c
@@ -315,9 +315,8 @@ static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
 	if (saddr) {
 		saddr->family = AF_IEEE802154;
 		saddr->addr = mac_cb(skb)->sa;
-	}
-	if (addr_len)
 		*addr_len = sizeof(*saddr);
+	}
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;
* Unmerged path net/ipv4/ping.c
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index dd44e0ab600c..2102dd4ce461 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -691,9 +691,6 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 	if (flags & MSG_OOB)
 		goto out;
 
-	if (addr_len)
-		*addr_len = sizeof(*sin);
-
 	if (flags & MSG_ERRQUEUE) {
 		err = ip_recv_error(sk, msg, len);
 		goto out;
@@ -721,6 +718,7 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		*addr_len = sizeof(*sin);
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 10d9853d1d5e..339039e0ec07 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1208,12 +1208,6 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 	int is_udplite = IS_UDPLITE(sk);
 	bool slow;
 
-	/*
-	 *	Check any passed addresses
-	 */
-	if (addr_len)
-		*addr_len = sizeof(*sin);
-
 	if (flags & MSG_ERRQUEUE)
 		return ip_recv_error(sk, msg, len);
 
@@ -1275,6 +1269,7 @@ try_again:
 		sin->sin_port = udp_hdr(skb)->source;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+		*addr_len = sizeof(*sin);
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index c45f7a5c36e9..368de6b661fa 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -459,9 +459,6 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,
 	if (flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
-	if (addr_len)
-		*addr_len=sizeof(*sin6);
-
 	if (flags & MSG_ERRQUEUE)
 		return ipv6_recv_error(sk, msg, len);
 
@@ -500,6 +497,7 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,
 		sin6->sin6_flowinfo = 0;
 		sin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,
 							  IP6CB(skb)->iif);
+		*addr_len = sizeof(*sin6);
 	}
 
 	sock_recv_ts_and_drops(msg, sk, skb);
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index cb330ff1db0d..53a35a19aa16 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -374,9 +374,6 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,
 	int is_udp4;
 	bool slow;
 
-	if (addr_len)
-		*addr_len = sizeof(struct sockaddr_in6);
-
 	if (flags & MSG_ERRQUEUE)
 		return ipv6_recv_error(sk, msg, len);
 
@@ -462,7 +459,7 @@ try_again:
 				ipv6_iface_scope_id(&sin6->sin6_addr,
 						    IP6CB(skb)->iif);
 		}
-
+		*addr_len = sizeof(*sin6);
 	}
 	if (is_udp4) {
 		if (inet->cmsg_flags)
diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c
index 571db8dd2292..da1a1cee1a08 100644
--- a/net/l2tp/l2tp_ip.c
+++ b/net/l2tp/l2tp_ip.c
@@ -518,9 +518,6 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m
 	if (flags & MSG_OOB)
 		goto out;
 
-	if (addr_len)
-		*addr_len = sizeof(*sin);
-
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;
@@ -543,6 +540,7 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		*addr_len = sizeof(*sin);
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
diff --git a/net/phonet/datagram.c b/net/phonet/datagram.c
index 12c30f3e643e..38946b26e471 100644
--- a/net/phonet/datagram.c
+++ b/net/phonet/datagram.c
@@ -139,9 +139,6 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
-	if (addr_len)
-		*addr_len = sizeof(sa);
-
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;
@@ -162,8 +159,10 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
 
 	rval = (flags & MSG_TRUNC) ? skb->len : copylen;
 
-	if (msg->msg_name != NULL)
-		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));
+	if (msg->msg_name != NULL) {
+		memcpy(msg->msg_name, &sa, sizeof(sa));
+		*addr_len = sizeof(sa);
+	}
 
 out:
 	skb_free_datagram(sk, skb);
