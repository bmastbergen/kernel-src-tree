md: Remove unneeded semicolon

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [alsa] hdspm: remove unneeded semicolon (Jaroslav Kysela) [1044022]
Rebuild_FUZZ: 91.80%
commit-author Yang Li <yang.lee@linux.alibaba.com>
commit ae720670b9fc5ef3588efd5b95e6a0f59a36dec0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/ae720670.failed

./drivers/md/md.c:630:21-22: Unneeded semicolon

	Reported-by: Abaci Robot <abaci@linux.alibaba.com>
Closes: https://bugzilla.openanolis.cn/show_bug.cgi?id=9344
	Signed-off-by: Yang Li <yang.lee@linux.alibaba.com>
	Signed-off-by: Song Liu <song@kernel.org>
Link: https://lore.kernel.org/r/20240618010759.85416-1-yang.lee@linux.alibaba.com
(cherry picked from commit ae720670b9fc5ef3588efd5b95e6a0f59a36dec0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 4e4145ca2c70,149be072546a..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -433,29 -601,88 +433,45 @@@ static void md_submit_flush_data(struc
  	struct mddev *mddev = container_of(ws, struct mddev, flush_work);
  	struct bio *bio = mddev->flush_bio;
  
 -	/*
 -	 * must reset flush_bio before calling into md_handle_request to avoid a
 -	 * deadlock, because other bios passed md_handle_request suspend check
 -	 * could wait for this and below md_handle_request could wait for those
 -	 * bios because of suspend check
 -	 */
 -	spin_lock_irq(&mddev->lock);
 -	mddev->prev_flush_start = mddev->start_flush;
 -	mddev->flush_bio = NULL;
 -	spin_unlock_irq(&mddev->lock);
 -	wake_up(&mddev->sb_wait);
 -
 -	if (bio->bi_iter.bi_size == 0) {
 +	if (bio->bi_size == 0)
  		/* an empty barrier - all done */
++<<<<<<< HEAD
 +		bio_endio(bio, 0);
 +	else {
 +		bio->bi_rw &= ~REQ_FLUSH;
 +		mddev->pers->make_request(mddev, bio);
++=======
+ 		bio_endio(bio);
+ 	} else {
+ 		bio->bi_opf &= ~REQ_PREFLUSH;
+ 
+ 		/*
+ 		 * make_requst() will never return error here, it only
+ 		 * returns error in raid5_make_request() by dm-raid.
+ 		 * Since dm always splits data and flush operation into
+ 		 * two separate io, io size of flush submitted by dm
+ 		 * always is 0, make_request() will not be called here.
+ 		 */
+ 		if (WARN_ON_ONCE(!mddev->pers->make_request(mddev, bio)))
+ 			bio_io_error(bio);
++>>>>>>> ae720670b9fc (md: Remove unneeded semicolon)
  	}
  
 -	/* The pair is percpu_ref_get() from md_flush_request() */
 -	percpu_ref_put(&mddev->active_io);
 +	mddev->flush_bio = NULL;
 +	wake_up(&mddev->sb_wait);
  }
  
 -/*
 - * Manages consolidation of flushes and submitting any flushes needed for
 - * a bio with REQ_PREFLUSH.  Returns true if the bio is finished or is
 - * being finished in another context.  Returns false if the flushing is
 - * complete but still needs the I/O portion of the bio to be processed.
 - */
 -bool md_flush_request(struct mddev *mddev, struct bio *bio)
 +void md_flush_request(struct mddev *mddev, struct bio *bio)
  {
 -	ktime_t req_start = ktime_get_boottime();
 -	spin_lock_irq(&mddev->lock);
 -	/* flush requests wait until ongoing flush completes,
 -	 * hence coalescing all the pending requests.
 -	 */
 +	spin_lock_irq(&mddev->write_lock);
  	wait_event_lock_irq(mddev->sb_wait,
 -			    !mddev->flush_bio ||
 -			    ktime_before(req_start, mddev->prev_flush_start),
 -			    mddev->lock);
 -	/* new request after previous flush is completed */
 -	if (ktime_after(req_start, mddev->prev_flush_start)) {
 -		WARN_ON(mddev->flush_bio);
 -		/*
 -		 * Grab a reference to make sure mddev_suspend() will wait for
 -		 * this flush to be done.
 -		 *
 -		 * md_flush_reqeust() is called under md_handle_request() and
 -		 * 'active_io' is already grabbed, hence percpu_ref_is_zero()
 -		 * won't pass, percpu_ref_tryget_live() can't be used because
 -		 * percpu_ref_kill() can be called by mddev_suspend()
 -		 * concurrently.
 -		 */
 -		WARN_ON(percpu_ref_is_zero(&mddev->active_io));
 -		percpu_ref_get(&mddev->active_io);
 -		mddev->flush_bio = bio;
 -		spin_unlock_irq(&mddev->lock);
 -		INIT_WORK(&mddev->flush_work, submit_flushes);
 -		queue_work(md_wq, &mddev->flush_work);
 -		return true;
 -	}
 -
 -	/* flush was performed for some other bio while we waited. */
 -	spin_unlock_irq(&mddev->lock);
 -	if (bio->bi_iter.bi_size == 0) {
 -		/* pure flush without data - all done */
 -		bio_endio(bio);
 -		return true;
 -	}
 +			    !mddev->flush_bio,
 +			    mddev->write_lock);
 +	mddev->flush_bio = bio;
 +	spin_unlock_irq(&mddev->write_lock);
  
 -	bio->bi_opf &= ~REQ_PREFLUSH;
 -	return false;
 +	INIT_WORK(&mddev->flush_work, submit_flushes);
 +	queue_work(md_wq, &mddev->flush_work);
  }
  EXPORT_SYMBOL(md_flush_request);
  
* Unmerged path drivers/md/md.c
