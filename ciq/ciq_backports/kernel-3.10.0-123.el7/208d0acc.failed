nfsd4: break only delegations when appropriate

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author J. Bruce Fields <bfields@redhat.com>
commit 208d0acc49cbf22a71d32b40a69e199717a76687
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/208d0acc.failed

As a temporary fix, nfsd was breaking all leases on unlink, link,
rename, and setattr.

Now that we can distinguish between leases and delegations, we can be
nicer and break only the delegations, and not bother lease-holders with
operations they don't care about.

And we get to delete some code while we're at it.

Note that in the presence of delegations the vfs calls here all return
-EWOULDBLOCK instead of blocking, so nfsd threads will not get stuck
waiting for delegation returns.

	Acked-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 208d0acc49cbf22a71d32b40a69e199717a76687)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/vfs.c
diff --cc fs/nfsd/vfs.c
index ef9fecd97de8,e85b463fac4a..000000000000
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@@ -1761,12 -1746,7 +1748,16 @@@ nfsd_link(struct svc_rqst *rqstp, struc
  	err = nfserr_noent;
  	if (!dold->d_inode)
  		goto out_dput;
++<<<<<<< HEAD
 +	host_err = nfsd_break_lease(dold->d_inode);
 +	if (host_err) {
 +		err = nfserrno(host_err);
 +		goto out_dput;
 +	}
 +	host_err = vfs_link(dold, dirp, dnew);
++=======
+ 	host_err = vfs_link(dold, dirp, dnew, NULL);
++>>>>>>> 208d0acc49cb (nfsd4: break only delegations when appropriate)
  	if (!host_err) {
  		err = nfserrno(commit_metadata(ffhp));
  		if (!err)
@@@ -1859,15 -1839,7 +1850,19 @@@ nfsd_rename(struct svc_rqst *rqstp, str
  	if (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)
  		goto out_dput_new;
  
++<<<<<<< HEAD
 +	host_err = nfsd_break_lease(odentry->d_inode);
 +	if (host_err)
 +		goto out_dput_new;
 +	if (ndentry->d_inode) {
 +		host_err = nfsd_break_lease(ndentry->d_inode);
 +		if (host_err)
 +			goto out_dput_new;
 +	}
 +	host_err = vfs_rename(fdir, odentry, tdir, ndentry);
++=======
+ 	host_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL);
++>>>>>>> 208d0acc49cb (nfsd4: break only delegations when appropriate)
  	if (!host_err) {
  		host_err = commit_metadata(tfhp);
  		if (!host_err)
* Unmerged path fs/nfsd/vfs.c
