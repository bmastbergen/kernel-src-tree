vfs: restructure d_genocide()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 01ddc4ede5f09cdaed015d49ab66eec179085a2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/01ddc4ed.failed

It shouldn't matter when we decrement the refcount during the walk as long
as we do it exactly once.

Restructure d_genocide() to do the killing on entering the dentry instead
of when leaving it.  This helps creating a common helper for tree walking.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 01ddc4ede5f09cdaed015d49ab66eec179085a2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dcache.c
diff --cc fs/dcache.c
index 2f8b2937383a,f792e9f20eca..000000000000
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@@ -2928,18 -2963,10 +2932,24 @@@ resume
  			spin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);
  			goto repeat;
  		}
++<<<<<<< HEAD
 +		if (!(dentry->d_flags & DCACHE_GENOCIDE)) {
 +			dentry->d_flags |= DCACHE_GENOCIDE;
 +			dentry->d_count--;
 +		}
++=======
++>>>>>>> 01ddc4ede5f0 (vfs: restructure d_genocide())
  		spin_unlock(&dentry->d_lock);
  	}
  	if (this_parent != root) {
  		struct dentry *child = this_parent;
++<<<<<<< HEAD
 +		if (!(this_parent->d_flags & DCACHE_GENOCIDE)) {
 +			this_parent->d_flags |= DCACHE_GENOCIDE;
 +			this_parent->d_count--;
 +		}
++=======
++>>>>>>> 01ddc4ede5f0 (vfs: restructure d_genocide())
  		this_parent = try_to_ascend(this_parent, locked, seq);
  		if (!this_parent)
  			goto rename_retry;
* Unmerged path fs/dcache.c
