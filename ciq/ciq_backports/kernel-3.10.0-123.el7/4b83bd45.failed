powerpc/eeh: Don't use pci_dev during BAR restore

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [powerpc] eeh: Don't use pci_dev during BAR restore (Steve Best) [1033086]
Rebuild_FUZZ: 91.11%
commit-author Gavin Shan <shangw@linux.vnet.ibm.com>
commit 4b83bd452f17582c8d1c916568fd28a237a2eb46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/4b83bd45.failed

While restoring BARs for one specific PCI device, the pci_dev
instance should have been released. So it's not reliable to use
the pci_dev instance on restoring BARs. However, we still need
some information (e.g. PCIe capability position, header type) from
the pci_dev instance. So we have to store those information to
EEH device in advance.

	Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 4b83bd452f17582c8d1c916568fd28a237a2eb46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/eeh.h
#	arch/powerpc/kernel/eeh_pe.c
#	arch/powerpc/platforms/powernv/eeh-powernv.c
diff --cc arch/powerpc/include/asm/eeh.h
index f2d19467c123,4199d9943277..000000000000
--- a/arch/powerpc/include/asm/eeh.h
+++ b/arch/powerpc/include/asm/eeh.h
@@@ -81,7 -84,11 +81,15 @@@ struct eeh_pe 
   * another tree except the currently existing tree of PCI
   * buses and PCI devices
   */
++<<<<<<< HEAD
 +#define EEH_DEV_IRQ_DISABLED	(1<<0)	/* Interrupt disabled		*/
++=======
+ #define EEH_DEV_BRIDGE		(1 << 0)	/* PCI bridge		*/
+ #define EEH_DEV_ROOT_PORT	(1 << 1)	/* PCIe root port	*/
+ #define EEH_DEV_DS_PORT		(1 << 2)	/* Downstream port	*/
+ #define EEH_DEV_IRQ_DISABLED	(1 << 3)	/* Interrupt disabled	*/
+ #define EEH_DEV_DISCONNECTED	(1 << 4)	/* Removing from PE	*/
++>>>>>>> 4b83bd452f17 (powerpc/eeh: Don't use pci_dev during BAR restore)
  
  struct eeh_dev {
  	int mode;			/* EEH mode			*/
diff --cc arch/powerpc/kernel/eeh_pe.c
index 6ab3eb589ca3,f9450537e335..000000000000
--- a/arch/powerpc/kernel/eeh_pe.c
+++ b/arch/powerpc/kernel/eeh_pe.c
@@@ -746,15 -731,9 +746,21 @@@ static void *eeh_restore_one_device_bar
  	struct eeh_dev *edev = (struct eeh_dev *)data;
  	struct device_node *dn = eeh_dev_to_of_node(edev);
  
++<<<<<<< HEAD
 +	/* Trace the PCI bridge */
 +	if (eeh_probe_mode_dev()) {
 +		pdev = eeh_dev_to_pci_dev(edev);
 +		if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE)
 +                        pdev = NULL;
 +        }
 +
 +	if (pdev)
 +		eeh_restore_bridge_bars(pdev, edev, dn);
++=======
+ 	/* Do special restore for bridges */
+ 	if (edev->mode & EEH_DEV_BRIDGE)
+ 		eeh_restore_bridge_bars(edev, dn);
++>>>>>>> 4b83bd452f17 (powerpc/eeh: Don't use pci_dev during BAR restore)
  	else
  		eeh_restore_device_bars(edev, dn);
  
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
* Unmerged path arch/powerpc/include/asm/eeh.h
* Unmerged path arch/powerpc/kernel/eeh_pe.c
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
diff --git a/arch/powerpc/platforms/pseries/eeh_pseries.c b/arch/powerpc/platforms/pseries/eeh_pseries.c
index b456b157d33d..2eb95a89cc31 100644
--- a/arch/powerpc/platforms/pseries/eeh_pseries.c
+++ b/arch/powerpc/platforms/pseries/eeh_pseries.c
@@ -133,6 +133,48 @@ static int pseries_eeh_init(void)
 	return 0;
 }
 
+static int pseries_eeh_cap_start(struct device_node *dn)
+{
+	struct pci_dn *pdn = PCI_DN(dn);
+	u32 status;
+
+	if (!pdn)
+		return 0;
+
+	rtas_read_config(pdn, PCI_STATUS, 2, &status);
+	if (!(status & PCI_STATUS_CAP_LIST))
+		return 0;
+
+	return PCI_CAPABILITY_LIST;
+}
+
+
+static int pseries_eeh_find_cap(struct device_node *dn, int cap)
+{
+	struct pci_dn *pdn = PCI_DN(dn);
+	int pos = pseries_eeh_cap_start(dn);
+	int cnt = 48;	/* Maximal number of capabilities */
+	u32 id;
+
+	if (!pos)
+		return 0;
+
+        while (cnt--) {
+		rtas_read_config(pdn, pos, 1, &pos);
+		if (pos < 0x40)
+			break;
+		pos &= ~3;
+		rtas_read_config(pdn, pos + PCI_CAP_LIST_ID, 1, &id);
+		if (id == 0xff)
+			break;
+		if (id == cap)
+			return pos;
+		pos += PCI_CAP_LIST_NEXT;
+	}
+
+	return 0;
+}
+
 /**
  * pseries_eeh_of_probe - EEH probe on the given device
  * @dn: OF node
@@ -146,8 +188,10 @@ static void *pseries_eeh_of_probe(struct device_node *dn, void *flag)
 {
 	struct eeh_dev *edev;
 	struct eeh_pe pe;
+	struct pci_dn *pdn = PCI_DN(dn);
 	const u32 *class_code, *vendor_id, *device_id;
 	const u32 *regs;
+	u32 pcie_flags;
 	int enable = 0;
 	int ret;
 
@@ -167,9 +211,26 @@ static void *pseries_eeh_of_probe(struct device_node *dn, void *flag)
 	if (dn->type && !strcmp(dn->type, "isa"))
 		return NULL;
 
-	/* Update class code and mode of eeh device */
+	/*
+	 * Update class code and mode of eeh device. We need
+	 * correctly reflects that current device is root port
+	 * or PCIe switch downstream port.
+	 */
 	edev->class_code = *class_code;
+	edev->pcie_cap = pseries_eeh_find_cap(dn, PCI_CAP_ID_EXP);
 	edev->mode = 0;
+	if ((edev->class_code >> 8) == PCI_CLASS_BRIDGE_PCI) {
+		edev->mode |= EEH_DEV_BRIDGE;
+		if (edev->pcie_cap) {
+			rtas_read_config(pdn, edev->pcie_cap + PCI_EXP_FLAGS,
+					 2, &pcie_flags);
+			pcie_flags = (pcie_flags & PCI_EXP_FLAGS_TYPE) >> 4;
+			if (pcie_flags == PCI_EXP_TYPE_ROOT_PORT)
+				edev->mode |= EEH_DEV_ROOT_PORT;
+			else if (pcie_flags == PCI_EXP_TYPE_DOWNSTREAM)
+				edev->mode |= EEH_DEV_DS_PORT;
+		}
+	}
 
 	/* Retrieve the device address */
 	regs = of_get_property(dn, "reg", NULL);
