vfs: make sure we don't have a stale root path if unlazy_walk() fails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit d0d272771035a36a7839bb70ab6ebae3f4f4960b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/d0d27277.failed

When I moved the RCU walk termination into unlazy_walk(), I didn't copy
quite all of it: for the successful RCU termination we properly add the
necessary reference counts to our temporary copy of the root path, but
for the failure case we need to make sure that any temporary root path
information is cleared out (since it does _not_ have the proper
reference counts from the RCU lookup).

We could clean up this mess by just always dropping the temporary root
information, but Al points out that that would mean that a single lookup
through symlinks could see multiple different root entries if it races
with another thread doing chroot.  Not that I think we should really
care (we had that before too, back before we had a copy of the root path
in the nameidata).

Al says he has a cunning plan.  In the meantime, this is the minimal fix
for the problem, even if it's not all that pretty.

	Reported-by: Mace Moneta <moneta.mace@gmail.com>
	Acked-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d0d272771035a36a7839bb70ab6ebae3f4f4960b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index b8c893be1266,5e6aaadc1dcd..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -545,19 -565,21 +545,33 @@@ static int unlazy_walk(struct nameidat
  		path_get(&nd->root);
  		spin_unlock(&fs->lock);
  	}
 +	mntget(nd->path.mnt);
  
  	unlock_rcu_walk();
 +	nd->flags &= ~LOOKUP_RCU;
  	return 0;
  
++<<<<<<< HEAD
 +err_child:
 +	spin_unlock(&dentry->d_lock);
 +err_parent:
 +	spin_unlock(&parent->d_lock);
 +err_root:
 +	if (want_root)
 +		spin_unlock(&fs->lock);
++=======
+ unlock_and_drop_dentry:
+ 	spin_unlock(&fs->lock);
+ drop_dentry:
+ 	unlock_rcu_walk();
+ 	dput(dentry);
+ 	goto drop_root_mnt;
+ out:
+ 	unlock_rcu_walk();
+ drop_root_mnt:
+ 	if (!(nd->flags & LOOKUP_ROOT))
+ 		nd->root.mnt = NULL;
++>>>>>>> d0d272771035 (vfs: make sure we don't have a stale root path if unlazy_walk() fails)
  	return -ECHILD;
  }
  
* Unmerged path fs/namei.c
