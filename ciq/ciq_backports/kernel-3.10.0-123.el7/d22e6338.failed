Fix mountpoint reference leakage in linkat

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Oleg Drokin <green@linuxhacker.ru>
commit d22e6338db7f613dd4f6095c190682fcc519e4b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/d22e6338.failed

Recent changes to retry on ESTALE in linkat
(commit 442e31ca5a49e398351b2954b51f578353fdf210)
introduced a mountpoint reference leak and a small memory
leak in case a filesystem link operation returns ESTALE
which is pretty normal for distributed filesystems like
lustre, nfs and so on.
Free old_path in such a case.

[AV: there was another missing path_put() nearby - on the previous
goto retry]

	Signed-off-by: Oleg Drokin: <green@linuxhacker.ru>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit d22e6338db7f613dd4f6095c190682fcc519e4b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index 9dbedede9069,d580df2e6804..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -3881,10 -3921,18 +3881,21 @@@ retry
  	error = security_path_link(old_path.dentry, &new_path, new_dentry);
  	if (error)
  		goto out_dput;
 -	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);
 +	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry);
  out_dput:
  	done_path_create(&new_path, new_dentry);
++<<<<<<< HEAD
++=======
+ 	if (delegated_inode) {
+ 		error = break_deleg_wait(&delegated_inode);
+ 		if (!error) {
+ 			path_put(&old_path);
+ 			goto retry;
+ 		}
+ 	}
++>>>>>>> d22e6338db7f (Fix mountpoint reference leakage in linkat)
  	if (retry_estale(error, how)) {
+ 		path_put(&old_path);
  		how |= LOOKUP_REVAL;
  		goto retry;
  	}
* Unmerged path fs/namei.c
