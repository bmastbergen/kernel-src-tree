powerpc/powernv: Use dev-node in PCI config accessors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [powerpc] powernv: Use dev-node in PCI config accessors (Steve Best) [1033086]
Rebuild_FUZZ: 91.84%
commit-author Gavin Shan <shangw@linux.vnet.ibm.com>
commit 9bf41be6737327b7c06cd3f210a0cb599f4aa790
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/9bf41be6.failed

Currently, we're using the combo (PCI bus + devfn) in the PCI
config accessors and PCI config accessors in EEH depends on them.
However, it's not safe to refer the PCI bus which might have been
removed during hotplug. So we're using device node in the PCI
config accessors and the corresponding backends just reuse them.

The patch also fix one potential risk: We possiblly have frozen
PE during the early PCI probe time, but we haven't setup the PE
mapping yet. So the errors should be counted to PE#0.

	Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 9bf41be6737327b7c06cd3f210a0cb599f4aa790)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/eeh-powernv.c
#	arch/powerpc/platforms/powernv/pci.c
diff --cc arch/powerpc/platforms/powernv/pci.c
index 6d9a506b541a,a28d3b5e6393..000000000000
--- a/arch/powerpc/platforms/powernv/pci.c
+++ b/arch/powerpc/platforms/powernv/pci.c
@@@ -308,22 -312,15 +311,29 @@@ int pnv_pci_cfg_read(struct device_nod
  	if (phb_pe && (phb_pe->state & EEH_PE_ISOLATED))
  		return PCIBIOS_SUCCESSFUL;
  
++<<<<<<< HEAD
 +	if (phb->eeh_enabled) {
 +		if (*val == EEH_IO_ERROR_VALUE(size)) {
 +			busdn = pci_bus_to_OF_node(bus);
 +			for (dn = busdn->child; dn; dn = dn->sibling) {
 +				struct pci_dn *pdn = PCI_DN(dn);
 +
 +				if (pdn && pdn->devfn == devfn &&
 +				    eeh_dev_check_failure(of_node_to_eeh_dev(dn)))
 +					return PCIBIOS_DEVICE_NOT_FOUND;
 +			}
 +		}
++=======
+ 	if (phb->eeh_state & PNV_EEH_STATE_ENABLED) {
+ 		if (*val == EEH_IO_ERROR_VALUE(size) &&
+ 		    eeh_dev_check_failure(of_node_to_eeh_dev(dn)))
+ 			return PCIBIOS_DEVICE_NOT_FOUND;
++>>>>>>> 9bf41be67373 (powerpc/powernv: Use dev-node in PCI config accessors)
  	} else {
- 		pnv_pci_config_check_eeh(phb, bus, bdfn);
+ 		pnv_pci_config_check_eeh(phb, dn);
  	}
  #else
- 	pnv_pci_config_check_eeh(phb, bus, bdfn);
+ 	pnv_pci_config_check_eeh(phb, dn);
  #endif
  
  	return PCIBIOS_SUCCESSFUL;
@@@ -358,10 -351,10 +364,15 @@@ int pnv_pci_cfg_write(struct device_nod
  
  	/* Check if the PHB got frozen due to an error (no response) */
  #ifdef CONFIG_EEH
++<<<<<<< HEAD
 +	if (!phb->eeh_enabled)
 +		pnv_pci_config_check_eeh(phb, bus, bdfn);
++=======
+ 	if (!(phb->eeh_state & PNV_EEH_STATE_ENABLED))
+ 		pnv_pci_config_check_eeh(phb, dn);
++>>>>>>> 9bf41be67373 (powerpc/powernv: Use dev-node in PCI config accessors)
  #else
- 	pnv_pci_config_check_eeh(phb, bus, bdfn);
+ 	pnv_pci_config_check_eeh(phb, dn);
  #endif
  
  	return PCIBIOS_SUCCESSFUL;
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
* Unmerged path arch/powerpc/platforms/powernv/pci.c
diff --git a/arch/powerpc/platforms/powernv/pci.h b/arch/powerpc/platforms/powernv/pci.h
index 25d76c4df50b..cfd68aed1764 100644
--- a/arch/powerpc/platforms/powernv/pci.h
+++ b/arch/powerpc/platforms/powernv/pci.h
@@ -151,6 +151,10 @@ struct pnv_phb {
 
 extern struct pci_ops pnv_pci_ops;
 
+int pnv_pci_cfg_read(struct device_node *dn,
+		     int where, int size, u32 *val);
+int pnv_pci_cfg_write(struct device_node *dn,
+		      int where, int size, u32 val);
 extern void pnv_pci_setup_iommu_table(struct iommu_table *tbl,
 				      void *tce_mem, u64 tce_size,
 				      u64 dma_offset);
