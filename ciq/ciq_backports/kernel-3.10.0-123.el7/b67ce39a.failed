drm/radeon: check for 0 count in speaker allocation and SAD code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
Rebuild_CHGLOG: - [drm] radeon: check for 0 count in speaker allocation and SAD code (Rob Clark) [1054409]
Rebuild_FUZZ: 96.77%
commit-author Alex Deucher <alexander.deucher@amd.com>
commit b67ce39a30976171e7b96b30a94a0216ab89df97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/b67ce39a.failed

If there is no speaker allocation block or SAD block, bail
early.

bug:
https://bugs.freedesktop.org/show_bug.cgi?id=72283

	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
	Cc: stable@vger.kernel.org
(cherry picked from commit b67ce39a30976171e7b96b30a94a0216ab89df97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/radeon/dce6_afmt.c
#	drivers/gpu/drm/radeon/evergreen_hdmi.c
diff --cc drivers/gpu/drm/radeon/evergreen_hdmi.c
index ed7c8a768092,0c6d5cef4cf1..000000000000
--- a/drivers/gpu/drm/radeon/evergreen_hdmi.c
+++ b/drivers/gpu/drm/radeon/evergreen_hdmi.c
@@@ -54,6 -60,83 +54,86 @@@ static void evergreen_hdmi_update_ACR(s
  	WREG32(HDMI_ACR_48_1 + offset, acr.n_48khz);
  }
  
++<<<<<<< HEAD
++=======
+ static void dce4_afmt_write_latency_fields(struct drm_encoder *encoder,
+ 					   struct drm_display_mode *mode)
+ {
+ 	struct radeon_device *rdev = encoder->dev->dev_private;
+ 	struct drm_connector *connector;
+ 	struct radeon_connector *radeon_connector = NULL;
+ 	u32 tmp = 0;
+ 
+ 	list_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {
+ 		if (connector->encoder == encoder) {
+ 			radeon_connector = to_radeon_connector(connector);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!radeon_connector) {
+ 		DRM_ERROR("Couldn't find encoder's connector\n");
+ 		return;
+ 	}
+ 
+ 	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+ 		if (connector->latency_present[1])
+ 			tmp = VIDEO_LIPSYNC(connector->video_latency[1]) |
+ 				AUDIO_LIPSYNC(connector->audio_latency[1]);
+ 		else
+ 			tmp = VIDEO_LIPSYNC(255) | AUDIO_LIPSYNC(255);
+ 	} else {
+ 		if (connector->latency_present[0])
+ 			tmp = VIDEO_LIPSYNC(connector->video_latency[0]) |
+ 				AUDIO_LIPSYNC(connector->audio_latency[0]);
+ 		else
+ 			tmp = VIDEO_LIPSYNC(255) | AUDIO_LIPSYNC(255);
+ 	}
+ 	WREG32(AZ_F0_CODEC_PIN0_CONTROL_RESPONSE_LIPSYNC, tmp);
+ }
+ 
+ static void dce4_afmt_write_speaker_allocation(struct drm_encoder *encoder)
+ {
+ 	struct radeon_device *rdev = encoder->dev->dev_private;
+ 	struct drm_connector *connector;
+ 	struct radeon_connector *radeon_connector = NULL;
+ 	u32 tmp;
+ 	u8 *sadb;
+ 	int sad_count;
+ 
+ 	list_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {
+ 		if (connector->encoder == encoder) {
+ 			radeon_connector = to_radeon_connector(connector);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!radeon_connector) {
+ 		DRM_ERROR("Couldn't find encoder's connector\n");
+ 		return;
+ 	}
+ 
+ 	sad_count = drm_edid_to_speaker_allocation(radeon_connector->edid, &sadb);
+ 	if (sad_count <= 0) {
+ 		DRM_ERROR("Couldn't read Speaker Allocation Data Block: %d\n", sad_count);
+ 		return;
+ 	}
+ 
+ 	/* program the speaker allocation */
+ 	tmp = RREG32(AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);
+ 	tmp &= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);
+ 	/* set HDMI mode */
+ 	tmp |= HDMI_CONNECTION;
+ 	if (sad_count)
+ 		tmp |= SPEAKER_ALLOCATION(sadb[0]);
+ 	else
+ 		tmp |= SPEAKER_ALLOCATION(5); /* stereo */
+ 	WREG32(AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);
+ 
+ 	kfree(sadb);
+ }
+ 
++>>>>>>> b67ce39a3097 (drm/radeon: check for 0 count in speaker allocation and SAD code)
  static void evergreen_hdmi_write_sad_regs(struct drm_encoder *encoder)
  {
  	struct radeon_device *rdev = encoder->dev->dev_private;
* Unmerged path drivers/gpu/drm/radeon/dce6_afmt.c
* Unmerged path drivers/gpu/drm/radeon/dce6_afmt.c
* Unmerged path drivers/gpu/drm/radeon/evergreen_hdmi.c
