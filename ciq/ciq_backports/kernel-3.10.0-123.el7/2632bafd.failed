be2net: fix adaptive interrupt coalescing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Sathya Perla <sathya.perla@emulex.com>
commit 2632bafd74ae7d058ae52be80e6393139fd29f23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/2632bafd.failed

The current EQ delay calculation for AIC is based only on RX packet rate.
This fails to be effective when there's only TX and no RX.
This patch inclues:
- Calculating EQ-delay based on both RX and TX pps.
- Modifying EQ-delay of all EQs via one cmd, instead of issuing a separate
  cmd for each EQ.
- A new structure to store interrupt coalescing parameters, in a separate
  cache-line from the EQ-obj.

	Signed-off-by: Sathya Perla <sathya.perla@emulex.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2632bafd74ae7d058ae52be80e6393139fd29f23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be.h
#	drivers/net/ethernet/emulex/benet/be_cmds.h
diff --cc drivers/net/ethernet/emulex/benet/be.h
index a8d470fb999d,e7cbc56a0c8f..000000000000
--- a/drivers/net/ethernet/emulex/benet/be.h
+++ b/drivers/net/ethernet/emulex/benet/be.h
@@@ -88,8 -88,7 +88,12 @@@ static inline char *nic_name(struct pci
  #define BE_MIN_MTU		256
  
  #define BE_NUM_VLANS_SUPPORTED	64
++<<<<<<< HEAD
 +#define BE_UMC_NUM_VLANS_SUPPORTED	15
 +#define BE_MAX_EQD		96u
++=======
+ #define BE_MAX_EQD		128u
++>>>>>>> 2632bafd74ae (be2net: fix adaptive interrupt coalescing)
  #define	BE_MAX_TX_FRAG_COUNT	30
  
  #define EVNT_Q_LEN		1024
diff --cc drivers/net/ethernet/emulex/benet/be_cmds.h
index 108ca8abf0af,70c3017288d5..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_cmds.h
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.h
@@@ -1865,130 -1865,114 +1867,223 @@@ struct be_cmd_resp_get_iface_list 
  	struct be_if_desc if_desc;
  };
  
++<<<<<<< HEAD
 +extern int be_pci_fnum_get(struct be_adapter *adapter);
 +extern int be_fw_wait_ready(struct be_adapter *adapter);
 +extern int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
 +				 bool permanent, u32 if_handle, u32 pmac_id);
 +extern int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,
 +			u32 if_id, u32 *pmac_id, u32 domain);
 +extern int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id,
 +			int pmac_id, u32 domain);
 +extern int be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags,
 +			    u32 en_flags, u32 *if_handle, u32 domain);
 +extern int be_cmd_if_destroy(struct be_adapter *adapter, int if_handle,
++=======
+ int be_pci_fnum_get(struct be_adapter *adapter);
+ int be_fw_wait_ready(struct be_adapter *adapter);
+ int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
+ 			  bool permanent, u32 if_handle, u32 pmac_id);
+ int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr, u32 if_id,
+ 		    u32 *pmac_id, u32 domain);
+ int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id, int pmac_id,
+ 		    u32 domain);
+ int be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags, u32 en_flags,
+ 		     u32 *if_handle, u32 domain);
+ int be_cmd_if_destroy(struct be_adapter *adapter, int if_handle, u32 domain);
+ int be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo);
+ int be_cmd_cq_create(struct be_adapter *adapter, struct be_queue_info *cq,
+ 		     struct be_queue_info *eq, bool no_delay,
+ 		     int num_cqe_dma_coalesce);
+ int be_cmd_mccq_create(struct be_adapter *adapter, struct be_queue_info *mccq,
+ 		       struct be_queue_info *cq);
+ int be_cmd_txq_create(struct be_adapter *adapter, struct be_tx_obj *txo);
+ int be_cmd_rxq_create(struct be_adapter *adapter, struct be_queue_info *rxq,
+ 		      u16 cq_id, u16 frag_size, u32 if_id, u32 rss, u8 *rss_id);
+ int be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,
+ 		     int type);
+ int be_cmd_rxq_destroy(struct be_adapter *adapter, struct be_queue_info *q);
+ int be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,
+ 			     u8 *link_status, u32 dom);
+ int be_cmd_reset(struct be_adapter *adapter);
+ int be_cmd_get_stats(struct be_adapter *adapter, struct be_dma_mem *nonemb_cmd);
+ int lancer_cmd_get_pport_stats(struct be_adapter *adapter,
+ 			       struct be_dma_mem *nonemb_cmd);
+ int be_cmd_get_fw_ver(struct be_adapter *adapter, char *fw_ver,
+ 		      char *fw_on_flash);
+ int be_cmd_modify_eqd(struct be_adapter *adapter, struct be_set_eqd *, int num);
+ int be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id, u16 *vtag_array,
+ 		       u32 num, bool untagged, bool promiscuous);
+ int be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 status);
+ int be_cmd_set_flow_control(struct be_adapter *adapter, u32 tx_fc, u32 rx_fc);
+ int be_cmd_get_flow_control(struct be_adapter *adapter, u32 *tx_fc, u32 *rx_fc);
+ int be_cmd_query_fw_cfg(struct be_adapter *adapter, u32 *port_num,
+ 			u32 *function_mode, u32 *function_caps, u16 *asic_rev);
+ int be_cmd_reset_function(struct be_adapter *adapter);
+ int be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,
+ 		      u32 rss_hash_opts, u16 table_size);
+ int be_process_mcc(struct be_adapter *adapter);
+ int be_cmd_set_beacon_state(struct be_adapter *adapter, u8 port_num, u8 beacon,
+ 			    u8 status, u8 state);
+ int be_cmd_get_beacon_state(struct be_adapter *adapter, u8 port_num,
+ 			    u32 *state);
+ int be_cmd_write_flashrom(struct be_adapter *adapter, struct be_dma_mem *cmd,
+ 			  u32 flash_oper, u32 flash_opcode, u32 buf_size);
+ int lancer_cmd_write_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
+ 			    u32 data_size, u32 data_offset,
+ 			    const char *obj_name, u32 *data_written,
+ 			    u8 *change_status, u8 *addn_status);
+ int lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
+ 			   u32 data_size, u32 data_offset, const char *obj_name,
+ 			   u32 *data_read, u32 *eof, u8 *addn_status);
+ int be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,
+ 			 int offset);
+ int be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,
+ 			    struct be_dma_mem *nonemb_cmd);
+ int be_cmd_fw_init(struct be_adapter *adapter);
+ int be_cmd_fw_clean(struct be_adapter *adapter);
+ void be_async_mcc_enable(struct be_adapter *adapter);
+ void be_async_mcc_disable(struct be_adapter *adapter);
+ int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,
+ 			 u32 loopback_type, u32 pkt_size, u32 num_pkts,
+ 			 u64 pattern);
+ int be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern, u32 byte_cnt,
+ 			struct be_dma_mem *cmd);
+ int be_cmd_get_seeprom_data(struct be_adapter *adapter,
+ 			    struct be_dma_mem *nonemb_cmd);
+ int be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,
+ 			u8 loopback_type, u8 enable);
+ int be_cmd_get_phy_info(struct be_adapter *adapter);
+ int be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain);
+ void be_detect_error(struct be_adapter *adapter);
+ int be_cmd_get_die_temperature(struct be_adapter *adapter);
+ int be_cmd_get_cntl_attributes(struct be_adapter *adapter);
+ int be_cmd_req_native_mode(struct be_adapter *adapter);
+ int be_cmd_get_reg_len(struct be_adapter *adapter, u32 *log_size);
+ void be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf);
+ int be_cmd_get_fn_privileges(struct be_adapter *adapter, u32 *privilege,
+ 			     u32 domain);
+ int be_cmd_set_fn_privileges(struct be_adapter *adapter, u32 privileges,
+ 			     u32 vf_num);
+ int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
+ 			     bool *pmac_id_active, u32 *pmac_id, u8 domain);
+ int be_cmd_get_active_mac(struct be_adapter *adapter, u32 pmac_id, u8 *mac);
+ int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac);
+ int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array, u8 mac_count,
++>>>>>>> 2632bafd74ae (be2net: fix adaptive interrupt coalescing)
  			u32 domain);
 -int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id, u32 dom);
 -int be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid, u32 domain,
 -			  u16 intf_id, u16 hsw_mode);
 -int be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid, u32 domain,
 -			  u16 intf_id, u8 *mode);
 -int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter);
 -int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
 -				   struct be_dma_mem *cmd);
 -int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,
 +extern int be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo);
 +extern int be_cmd_cq_create(struct be_adapter *adapter,
 +			struct be_queue_info *cq, struct be_queue_info *eq,
 +			bool no_delay, int num_cqe_dma_coalesce);
 +extern int be_cmd_mccq_create(struct be_adapter *adapter,
 +			struct be_queue_info *mccq,
 +			struct be_queue_info *cq);
 +extern int be_cmd_txq_create(struct be_adapter *adapter,
 +			struct be_tx_obj *txo);
 +extern int be_cmd_rxq_create(struct be_adapter *adapter,
 +			struct be_queue_info *rxq, u16 cq_id,
 +			u16 frag_size, u32 if_id, u32 rss, u8 *rss_id);
 +extern int be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,
 +			int type);
 +extern int be_cmd_rxq_destroy(struct be_adapter *adapter,
 +			struct be_queue_info *q);
 +extern int be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,
 +				    u8 *link_status, u32 dom);
 +extern int be_cmd_reset(struct be_adapter *adapter);
 +extern int be_cmd_get_stats(struct be_adapter *adapter,
 +			struct be_dma_mem *nonemb_cmd);
 +extern int lancer_cmd_get_pport_stats(struct be_adapter *adapter,
 +			struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_get_fw_ver(struct be_adapter *adapter, char *fw_ver,
 +		char *fw_on_flash);
 +
 +extern int be_cmd_modify_eqd(struct be_adapter *adapter, u32 eq_id, u32 eqd);
 +extern int be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id,
 +			u16 *vtag_array, u32 num, bool untagged,
 +			bool promiscuous);
 +extern int be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 status);
 +extern int be_cmd_set_flow_control(struct be_adapter *adapter,
 +			u32 tx_fc, u32 rx_fc);
 +extern int be_cmd_get_flow_control(struct be_adapter *adapter,
 +			u32 *tx_fc, u32 *rx_fc);
 +extern int be_cmd_query_fw_cfg(struct be_adapter *adapter, u32 *port_num,
 +			u32 *function_mode, u32 *function_caps, u16 *asic_rev);
 +extern int be_cmd_reset_function(struct be_adapter *adapter);
 +extern int be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,
 +			     u32 rss_hash_opts, u16 table_size);
 +extern int be_process_mcc(struct be_adapter *adapter);
 +extern int be_cmd_set_beacon_state(struct be_adapter *adapter,
 +			u8 port_num, u8 beacon, u8 status, u8 state);
 +extern int be_cmd_get_beacon_state(struct be_adapter *adapter,
 +			u8 port_num, u32 *state);
 +extern int be_cmd_write_flashrom(struct be_adapter *adapter,
 +			struct be_dma_mem *cmd, u32 flash_oper,
 +			u32 flash_opcode, u32 buf_size);
 +extern int lancer_cmd_write_object(struct be_adapter *adapter,
  				   struct be_dma_mem *cmd,
 -				   struct be_fat_conf_params *cfgs);
 -int lancer_wait_ready(struct be_adapter *adapter);
 -int lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask);
 -int lancer_initiate_dump(struct be_adapter *adapter);
 -bool dump_present(struct be_adapter *adapter);
 -int lancer_test_and_set_rdy_state(struct be_adapter *adapter);
 -int be_cmd_query_port_name(struct be_adapter *adapter, u8 *port_name);
 +				   u32 data_size, u32 data_offset,
 +				   const char *obj_name,
 +				   u32 *data_written, u8 *change_status,
 +				   u8 *addn_status);
 +int lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,
 +		u32 data_size, u32 data_offset, const char *obj_name,
 +		u32 *data_read, u32 *eof, u8 *addn_status);
 +int be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,
 +				int offset);
 +extern int be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,
 +				struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_fw_init(struct be_adapter *adapter);
 +extern int be_cmd_fw_clean(struct be_adapter *adapter);
 +extern void be_async_mcc_enable(struct be_adapter *adapter);
 +extern void be_async_mcc_disable(struct be_adapter *adapter);
 +extern int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,
 +				u32 loopback_type, u32 pkt_size,
 +				u32 num_pkts, u64 pattern);
 +extern int be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern,
 +			u32 byte_cnt, struct be_dma_mem *cmd);
 +extern int be_cmd_get_seeprom_data(struct be_adapter *adapter,
 +				struct be_dma_mem *nonemb_cmd);
 +extern int be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,
 +				u8 loopback_type, u8 enable);
 +extern int be_cmd_get_phy_info(struct be_adapter *adapter);
 +extern int be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain);
 +extern void be_detect_error(struct be_adapter *adapter);
 +extern int be_cmd_get_die_temperature(struct be_adapter *adapter);
 +extern int be_cmd_get_cntl_attributes(struct be_adapter *adapter);
 +extern int be_cmd_req_native_mode(struct be_adapter *adapter);
 +extern int be_cmd_get_reg_len(struct be_adapter *adapter, u32 *log_size);
 +extern void be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf);
 +extern int be_cmd_get_fn_privileges(struct be_adapter *adapter,
 +				    u32 *privilege, u32 domain);
 +extern int be_cmd_set_fn_privileges(struct be_adapter *adapter,
 +				    u32 privileges, u32 vf_num);
 +extern int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,
 +				    bool *pmac_id_active, u32 *pmac_id,
 +				    u8 domain);
 +extern int be_cmd_get_active_mac(struct be_adapter *adapter, u32 pmac_id,
 +				 u8 *mac);
 +extern int be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac);
 +extern int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,
 +						u8 mac_count, u32 domain);
 +extern int be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id,
 +			  u32 dom);
 +extern int be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid,
 +				 u32 domain, u16 intf_id, u16 hsw_mode);
 +extern int be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid,
 +				 u32 domain, u16 intf_id, u8 *mode);
 +extern int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter);
 +extern int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,
 +					  struct be_dma_mem *cmd);
 +extern int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,
 +					  struct be_dma_mem *cmd,
 +					  struct be_fat_conf_params *cfgs);
 +extern int lancer_wait_ready(struct be_adapter *adapter);
 +extern int lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask);
 +extern int lancer_initiate_dump(struct be_adapter *adapter);
 +extern bool dump_present(struct be_adapter *adapter);
 +extern int lancer_test_and_set_rdy_state(struct be_adapter *adapter);
 +extern int be_cmd_query_port_name(struct be_adapter *adapter, u8 *port_name);
  int be_cmd_get_func_config(struct be_adapter *adapter,
  			   struct be_resources *res);
  int be_cmd_get_profile_config(struct be_adapter *adapter,
* Unmerged path drivers/net/ethernet/emulex/benet/be.h
diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c
index 9d7f2a00703b..787bce8c5246 100644
--- a/drivers/net/ethernet/emulex/benet/be_cmds.c
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c
@@ -1719,11 +1719,12 @@ err:
 /* set the EQ delay interval of an EQ to specified value
  * Uses async mcc
  */
-int be_cmd_modify_eqd(struct be_adapter *adapter, u32 eq_id, u32 eqd)
+int be_cmd_modify_eqd(struct be_adapter *adapter, struct be_set_eqd *set_eqd,
+		      int num)
 {
 	struct be_mcc_wrb *wrb;
 	struct be_cmd_req_modify_eq_delay *req;
-	int status = 0;
+	int status = 0, i;
 
 	spin_lock_bh(&adapter->mcc_lock);
 
@@ -1737,13 +1738,15 @@ int be_cmd_modify_eqd(struct be_adapter *adapter, u32 eq_id, u32 eqd)
 	be_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
 		OPCODE_COMMON_MODIFY_EQ_DELAY, sizeof(*req), wrb, NULL);
 
-	req->num_eq = cpu_to_le32(1);
-	req->delay[0].eq_id = cpu_to_le32(eq_id);
-	req->delay[0].phase = 0;
-	req->delay[0].delay_multiplier = cpu_to_le32(eqd);
+	req->num_eq = cpu_to_le32(num);
+	for (i = 0; i < num; i++) {
+		req->set_eqd[i].eq_id = cpu_to_le32(set_eqd[i].eq_id);
+		req->set_eqd[i].phase = 0;
+		req->set_eqd[i].delay_multiplier =
+				cpu_to_le32(set_eqd[i].delay_multiplier);
+	}
 
 	be_mcc_notify(adapter);
-
 err:
 	spin_unlock_bh(&adapter->mcc_lock);
 	return status;
* Unmerged path drivers/net/ethernet/emulex/benet/be_cmds.h
diff --git a/drivers/net/ethernet/emulex/benet/be_ethtool.c b/drivers/net/ethernet/emulex/benet/be_ethtool.c
index b440a1fac77b..a08783c7456e 100644
--- a/drivers/net/ethernet/emulex/benet/be_ethtool.c
+++ b/drivers/net/ethernet/emulex/benet/be_ethtool.c
@@ -290,19 +290,19 @@ static int be_get_coalesce(struct net_device *netdev,
 			   struct ethtool_coalesce *et)
 {
 	struct be_adapter *adapter = netdev_priv(netdev);
-	struct be_eq_obj *eqo = &adapter->eq_obj[0];
+	struct be_aic_obj *aic = &adapter->aic_obj[0];
 
 
-	et->rx_coalesce_usecs = eqo->cur_eqd;
-	et->rx_coalesce_usecs_high = eqo->max_eqd;
-	et->rx_coalesce_usecs_low = eqo->min_eqd;
+	et->rx_coalesce_usecs = aic->prev_eqd;
+	et->rx_coalesce_usecs_high = aic->max_eqd;
+	et->rx_coalesce_usecs_low = aic->min_eqd;
 
-	et->tx_coalesce_usecs = eqo->cur_eqd;
-	et->tx_coalesce_usecs_high = eqo->max_eqd;
-	et->tx_coalesce_usecs_low = eqo->min_eqd;
+	et->tx_coalesce_usecs = aic->prev_eqd;
+	et->tx_coalesce_usecs_high = aic->max_eqd;
+	et->tx_coalesce_usecs_low = aic->min_eqd;
 
-	et->use_adaptive_rx_coalesce = eqo->enable_aic;
-	et->use_adaptive_tx_coalesce = eqo->enable_aic;
+	et->use_adaptive_rx_coalesce = aic->enable;
+	et->use_adaptive_tx_coalesce = aic->enable;
 
 	return 0;
 }
@@ -314,14 +314,17 @@ static int be_set_coalesce(struct net_device *netdev,
 			   struct ethtool_coalesce *et)
 {
 	struct be_adapter *adapter = netdev_priv(netdev);
+	struct be_aic_obj *aic = &adapter->aic_obj[0];
 	struct be_eq_obj *eqo;
 	int i;
 
 	for_all_evt_queues(adapter, eqo, i) {
-		eqo->enable_aic = et->use_adaptive_rx_coalesce;
-		eqo->max_eqd = min(et->rx_coalesce_usecs_high, BE_MAX_EQD);
-		eqo->min_eqd = min(et->rx_coalesce_usecs_low, eqo->max_eqd);
-		eqo->eqd = et->rx_coalesce_usecs;
+		aic->enable = et->use_adaptive_rx_coalesce;
+		aic->max_eqd = min(et->rx_coalesce_usecs_high, BE_MAX_EQD);
+		aic->min_eqd = min(et->rx_coalesce_usecs_low, aic->max_eqd);
+		aic->et_eqd = min(et->rx_coalesce_usecs, aic->max_eqd);
+		aic->et_eqd = max(aic->et_eqd, aic->min_eqd);
+		aic++;
 	}
 
 	return 0;
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index 0d276a68abd9..978eb2aa6369 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -1275,53 +1275,79 @@ static int be_set_vf_tx_rate(struct net_device *netdev,
 	return status;
 }
 
-static void be_eqd_update(struct be_adapter *adapter, struct be_eq_obj *eqo)
+static void be_aic_update(struct be_aic_obj *aic, u64 rx_pkts, u64 tx_pkts,
+			  ulong now)
 {
-	struct be_rx_stats *stats = rx_stats(&adapter->rx_obj[eqo->idx]);
-	ulong now = jiffies;
-	ulong delta = now - stats->rx_jiffies;
-	u64 pkts;
-	unsigned int start, eqd;
+	aic->rx_pkts_prev = rx_pkts;
+	aic->tx_reqs_prev = tx_pkts;
+	aic->jiffies = now;
+}
 
-	if (!eqo->enable_aic) {
-		eqd = eqo->eqd;
-		goto modify_eqd;
-	}
+static void be_eqd_update(struct be_adapter *adapter)
+{
+	struct be_set_eqd set_eqd[MAX_EVT_QS];
+	int eqd, i, num = 0, start;
+	struct be_aic_obj *aic;
+	struct be_eq_obj *eqo;
+	struct be_rx_obj *rxo;
+	struct be_tx_obj *txo;
+	u64 rx_pkts, tx_pkts;
+	ulong now;
+	u32 pps, delta;
 
-	if (eqo->idx >= adapter->num_rx_qs)
-		return;
+	for_all_evt_queues(adapter, eqo, i) {
+		aic = &adapter->aic_obj[eqo->idx];
+		if (!aic->enable) {
+			if (aic->jiffies)
+				aic->jiffies = 0;
+			eqd = aic->et_eqd;
+			goto modify_eqd;
+		}
 
-	stats = rx_stats(&adapter->rx_obj[eqo->idx]);
+		rxo = &adapter->rx_obj[eqo->idx];
+		do {
+			start = u64_stats_fetch_begin_bh(&rxo->stats.sync);
+			rx_pkts = rxo->stats.rx_pkts;
+		} while (u64_stats_fetch_retry_bh(&rxo->stats.sync, start));
 
-	/* Wrapped around */
-	if (time_before(now, stats->rx_jiffies)) {
-		stats->rx_jiffies = now;
-		return;
-	}
+		txo = &adapter->tx_obj[eqo->idx];
+		do {
+			start = u64_stats_fetch_begin_bh(&txo->stats.sync);
+			tx_pkts = txo->stats.tx_reqs;
+		} while (u64_stats_fetch_retry_bh(&txo->stats.sync, start));
 
-	/* Update once a second */
-	if (delta < HZ)
-		return;
 
-	do {
-		start = u64_stats_fetch_begin_bh(&stats->sync);
-		pkts = stats->rx_pkts;
-	} while (u64_stats_fetch_retry_bh(&stats->sync, start));
-
-	stats->rx_pps = (unsigned long)(pkts - stats->rx_pkts_prev) / (delta / HZ);
-	stats->rx_pkts_prev = pkts;
-	stats->rx_jiffies = now;
-	eqd = (stats->rx_pps / 110000) << 3;
-	eqd = min(eqd, eqo->max_eqd);
-	eqd = max(eqd, eqo->min_eqd);
-	if (eqd < 10)
-		eqd = 0;
+		/* Skip, if wrapped around or first calculation */
+		now = jiffies;
+		if (!aic->jiffies || time_before(now, aic->jiffies) ||
+		    rx_pkts < aic->rx_pkts_prev ||
+		    tx_pkts < aic->tx_reqs_prev) {
+			be_aic_update(aic, rx_pkts, tx_pkts, now);
+			continue;
+		}
+
+		delta = jiffies_to_msecs(now - aic->jiffies);
+		pps = (((u32)(rx_pkts - aic->rx_pkts_prev) * 1000) / delta) +
+			(((u32)(tx_pkts - aic->tx_reqs_prev) * 1000) / delta);
+		eqd = (pps / 15000) << 2;
 
+		if (eqd < 8)
+			eqd = 0;
+		eqd = min_t(u32, eqd, aic->max_eqd);
+		eqd = max_t(u32, eqd, aic->min_eqd);
+
+		be_aic_update(aic, rx_pkts, tx_pkts, now);
 modify_eqd:
-	if (eqd != eqo->cur_eqd) {
-		be_cmd_modify_eqd(adapter, eqo->q.id, eqd);
-		eqo->cur_eqd = eqd;
+		if (eqd != aic->prev_eqd) {
+			set_eqd[num].delay_multiplier = (eqd * 65)/100;
+			set_eqd[num].eq_id = eqo->q.id;
+			aic->prev_eqd = eqd;
+			num++;
+		}
 	}
+
+	if (num)
+		be_cmd_modify_eqd(adapter, set_eqd, num);
 }
 
 static void be_rx_stats_update(struct be_rx_obj *rxo,
@@ -1938,6 +1964,7 @@ static int be_evt_queues_create(struct be_adapter *adapter)
 {
 	struct be_queue_info *eq;
 	struct be_eq_obj *eqo;
+	struct be_aic_obj *aic;
 	int i, rc;
 
 	adapter->num_evt_qs = min_t(u16, num_irqs(adapter),
@@ -1946,11 +1973,12 @@ static int be_evt_queues_create(struct be_adapter *adapter)
 	for_all_evt_queues(adapter, eqo, i) {
 		netif_napi_add(adapter->netdev, &eqo->napi, be_poll,
 			       BE_NAPI_WEIGHT);
+		aic = &adapter->aic_obj[i];
 		eqo->adapter = adapter;
 		eqo->tx_budget = BE_TX_BUDGET;
 		eqo->idx = i;
-		eqo->max_eqd = BE_MAX_EQD;
-		eqo->enable_aic = true;
+		aic->max_eqd = BE_MAX_EQD;
+		aic->enable = true;
 
 		eq = &eqo->q;
 		rc = be_queue_alloc(adapter, eq, EVNT_Q_LEN,
@@ -4256,7 +4284,6 @@ static void be_worker(struct work_struct *work)
 	struct be_adapter *adapter =
 		container_of(work, struct be_adapter, work.work);
 	struct be_rx_obj *rxo;
-	struct be_eq_obj *eqo;
 	int i;
 
 	/* when interrupts are not yet enabled, just reap any pending
@@ -4287,8 +4314,7 @@ static void be_worker(struct work_struct *work)
 		}
 	}
 
-	for_all_evt_queues(adapter, eqo, i)
-		be_eqd_update(adapter, eqo);
+	be_eqd_update(adapter);
 
 reschedule:
 	adapter->work_counter++;
