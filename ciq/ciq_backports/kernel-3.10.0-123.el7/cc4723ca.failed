netfilter: nft_reject: split up reject module into IPv4 and IPv6 specifc parts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Patrick McHardy <kaber@trash.net>
commit cc4723ca316742891954efa346298e7c747c0d17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/cc4723ca.failed

Currently the nft_reject module depends on symbols from ipv6. This is
wrong since no generic module should force IPv6 support to be loaded.
Split up the module into AF-specific and a generic part.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit cc4723ca316742891954efa346298e7c747c0d17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/Kconfig
#	net/ipv4/netfilter/Makefile
#	net/ipv6/netfilter/Kconfig
#	net/ipv6/netfilter/Makefile
#	net/netfilter/Kconfig
#	net/netfilter/nft_reject.c
diff --cc net/ipv4/netfilter/Kconfig
index e7916c193932,a26ce035e3fa..000000000000
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@@ -36,6 -36,42 +36,45 @@@ config NF_CONNTRACK_PROC_COMPA
  
  	  If unsure, say Y.
  
++<<<<<<< HEAD
++=======
+ config NF_TABLES_IPV4
+ 	depends on NF_TABLES
+ 	tristate "IPv4 nf_tables support"
+ 	help
+ 	  This option enables the IPv4 support for nf_tables.
+ 
+ config NFT_CHAIN_ROUTE_IPV4
+ 	depends on NF_TABLES_IPV4
+ 	tristate "IPv4 nf_tables route chain support"
+ 	help
+ 	  This option enables the "route" chain for IPv4 in nf_tables. This
+ 	  chain type is used to force packet re-routing after mangling header
+ 	  fields such as the source, destination, type of service and
+ 	  the packet mark.
+ 
+ config NFT_CHAIN_NAT_IPV4
+ 	depends on NF_TABLES_IPV4
+ 	depends on NF_NAT_IPV4 && NFT_NAT
+ 	tristate "IPv4 nf_tables nat chain support"
+ 	help
+ 	  This option enables the "nat" chain for IPv4 in nf_tables. This
+ 	  chain type is used to perform Network Address Translation (NAT)
+ 	  packet transformations such as the source, destination address and
+ 	  source and destination ports.
+ 
+ config NFT_REJECT_IPV4
+ 	depends on NF_TABLES_IPV4
+ 	default NFT_REJECT
+ 	tristate
+ 
+ config NF_TABLES_ARP
+ 	depends on NF_TABLES
+ 	tristate "ARP nf_tables support"
+ 	help
+ 	  This option enables the ARP support for nf_tables.
+ 
++>>>>>>> cc4723ca3167 (netfilter: nft_reject: split up reject module into IPv4 and IPv6 specifc parts)
  config IP_NF_IPTABLES
  	tristate "IP tables support (required for filtering/masq/NAT)"
  	default m if NETFILTER_ADVANCED=n
diff --cc net/ipv4/netfilter/Makefile
index 007b128eecc9,90b82405331e..000000000000
--- a/net/ipv4/netfilter/Makefile
+++ b/net/ipv4/netfilter/Makefile
@@@ -27,6 -27,12 +27,15 @@@ obj-$(CONFIG_NF_NAT_SNMP_BASIC) += nf_n
  # NAT protocols (nf_nat)
  obj-$(CONFIG_NF_NAT_PROTO_GRE) += nf_nat_proto_gre.o
  
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_NF_TABLES_IPV4) += nf_tables_ipv4.o
+ obj-$(CONFIG_NFT_CHAIN_ROUTE_IPV4) += nft_chain_route_ipv4.o
+ obj-$(CONFIG_NFT_CHAIN_NAT_IPV4) += nft_chain_nat_ipv4.o
+ obj-$(CONFIG_NFT_REJECT_IPV4) += nft_reject_ipv4.o
+ obj-$(CONFIG_NF_TABLES_ARP) += nf_tables_arp.o
+ 
++>>>>>>> cc4723ca3167 (netfilter: nft_reject: split up reject module into IPv4 and IPv6 specifc parts)
  # generic IP tables 
  obj-$(CONFIG_IP_NF_IPTABLES) += ip_tables.o
  
diff --cc net/ipv6/netfilter/Kconfig
index a7f842b29b67,4bff1f297e39..000000000000
--- a/net/ipv6/netfilter/Kconfig
+++ b/net/ipv6/netfilter/Kconfig
@@@ -25,6 -25,36 +25,39 @@@ config NF_CONNTRACK_IPV
  
  	  To compile it as a module, choose M here.  If unsure, say N.
  
++<<<<<<< HEAD
++=======
+ config NF_TABLES_IPV6
+ 	depends on NF_TABLES
+ 	tristate "IPv6 nf_tables support"
+ 	help
+ 	  This option enables the IPv6 support for nf_tables.
+ 
+ config NFT_CHAIN_ROUTE_IPV6
+ 	depends on NF_TABLES_IPV6
+ 	tristate "IPv6 nf_tables route chain support"
+ 	help
+ 	  This option enables the "route" chain for IPv6 in nf_tables. This
+ 	  chain type is used to force packet re-routing after mangling header
+ 	  fields such as the source, destination, flowlabel, hop-limit and
+ 	  the packet mark.
+ 
+ config NFT_CHAIN_NAT_IPV6
+ 	depends on NF_TABLES_IPV6
+ 	depends on NF_NAT_IPV6 && NFT_NAT
+ 	tristate "IPv6 nf_tables nat chain support"
+ 	help
+ 	  This option enables the "nat" chain for IPv6 in nf_tables. This
+ 	  chain type is used to perform Network Address Translation (NAT)
+ 	  packet transformations such as the source, destination address and
+ 	  source and destination ports.
+ 
+ config NFT_REJECT_IPV6
+ 	depends on NF_TABLES_IPV6
+ 	default NFT_REJECT
+ 	tristate
+ 
++>>>>>>> cc4723ca3167 (netfilter: nft_reject: split up reject module into IPv4 and IPv6 specifc parts)
  config IP6_NF_IPTABLES
  	tristate "IP6 tables support (required for filtering)"
  	depends on INET && IPV6
diff --cc net/ipv6/netfilter/Makefile
index 2b53738f798c,70d3dd66f2cd..000000000000
--- a/net/ipv6/netfilter/Makefile
+++ b/net/ipv6/netfilter/Makefile
@@@ -23,6 -23,12 +23,15 @@@ obj-$(CONFIG_NF_NAT_IPV6) += nf_nat_ipv
  nf_defrag_ipv6-y := nf_defrag_ipv6_hooks.o nf_conntrack_reasm.o
  obj-$(CONFIG_NF_DEFRAG_IPV6) += nf_defrag_ipv6.o
  
++<<<<<<< HEAD
++=======
+ # nf_tables
+ obj-$(CONFIG_NF_TABLES_IPV6) += nf_tables_ipv6.o
+ obj-$(CONFIG_NFT_CHAIN_ROUTE_IPV6) += nft_chain_route_ipv6.o
+ obj-$(CONFIG_NFT_CHAIN_NAT_IPV6) += nft_chain_nat_ipv6.o
+ obj-$(CONFIG_NFT_REJECT_IPV6) += nft_reject_ipv6.o
+ 
++>>>>>>> cc4723ca3167 (netfilter: nft_reject: split up reject module into IPv4 and IPv6 specifc parts)
  # matches
  obj-$(CONFIG_IP6_NF_MATCH_AH) += ip6t_ah.o
  obj-$(CONFIG_IP6_NF_MATCH_EUI64) += ip6t_eui64.o
diff --cc net/netfilter/Kconfig
index 112ddfea8c1a,ed8b50e62276..000000000000
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@@ -408,8 -408,127 +408,127 @@@ config NF_NAT_TFT
  	depends on NF_CONNTRACK && NF_NAT
  	default NF_NAT && NF_CONNTRACK_TFTP
  
 -config NETFILTER_SYNPROXY
 -	tristate
 -
  endif # NF_CONNTRACK
  
++<<<<<<< HEAD
++=======
+ config NF_TABLES
+ 	select NETFILTER_NETLINK
+ 	tristate "Netfilter nf_tables support"
+ 	help
+ 	  nftables is the new packet classification framework that intends to
+ 	  replace the existing {ip,ip6,arp,eb}_tables infrastructure. It
+ 	  provides a pseudo-state machine with an extensible instruction-set
+ 	  (also known as expressions) that the userspace 'nft' utility
+ 	  (http://www.netfilter.org/projects/nftables) uses to build the
+ 	  rule-set. It also comes with the generic set infrastructure that
+ 	  allows you to construct mappings between matchings and actions
+ 	  for performance lookups.
+ 
+ 	  To compile it as a module, choose M here.
+ 
+ config NF_TABLES_INET
+ 	depends on NF_TABLES && IPV6
+ 	select NF_TABLES_IPV4
+ 	select NF_TABLES_IPV6
+ 	tristate "Netfilter nf_tables mixed IPv4/IPv6 tables support"
+ 	help
+ 	  This option enables support for a mixed IPv4/IPv6 "inet" table.
+ 
+ config NFT_EXTHDR
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables IPv6 exthdr module"
+ 	help
+ 	  This option adds the "exthdr" expression that you can use to match
+ 	  IPv6 extension headers.
+ 
+ config NFT_META
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables meta module"
+ 	help
+ 	  This option adds the "meta" expression that you can use to match and
+ 	  to set packet metainformation such as the packet mark.
+ 
+ config NFT_CT
+ 	depends on NF_TABLES
+ 	depends on NF_CONNTRACK
+ 	tristate "Netfilter nf_tables conntrack module"
+ 	help
+ 	  This option adds the "meta" expression that you can use to match
+ 	  connection tracking information such as the flow state.
+ 
+ config NFT_RBTREE
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables rbtree set module"
+ 	help
+ 	  This option adds the "rbtree" set type (Red Black tree) that is used
+ 	  to build interval-based sets.
+ 
+ config NFT_HASH
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables hash set module"
+ 	help
+ 	  This option adds the "hash" set type that is used to build one-way
+ 	  mappings between matchings and actions.
+ 
+ config NFT_COUNTER
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables counter module"
+ 	help
+ 	  This option adds the "counter" expression that you can use to
+ 	  include packet and byte counters in a rule.
+ 
+ config NFT_LOG
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables log module"
+ 	help
+ 	  This option adds the "log" expression that you can use to log
+ 	  packets matching some criteria.
+ 
+ config NFT_LIMIT
+ 	depends on NF_TABLES
+ 	tristate "Netfilter nf_tables limit module"
+ 	help
+ 	  This option adds the "limit" expression that you can use to
+ 	  ratelimit rule matchings.
+ 
+ config NFT_NAT
+ 	depends on NF_TABLES
+ 	depends on NF_CONNTRACK
+ 	depends on NF_NAT
+ 	tristate "Netfilter nf_tables nat module"
+ 	help
+ 	  This option adds the "nat" expression that you can use to perform
+ 	  typical Network Address Translation (NAT) packet transformations.
+ 
+ config NFT_QUEUE
+ 	depends on NF_TABLES
+ 	depends on NETFILTER_XTABLES
+ 	depends on NETFILTER_NETLINK_QUEUE
+ 	tristate "Netfilter nf_tables queue module"
+ 	help
+ 	  This is required if you intend to use the userspace queueing
+ 	  infrastructure (also known as NFQUEUE) from nftables.
+ 
+ config NFT_REJECT
+ 	depends on NF_TABLES
+ 	default m if NETFILTER_ADVANCED=n
+ 	tristate "Netfilter nf_tables reject support"
+ 	help
+ 	  This option adds the "reject" expression that you can use to
+ 	  explicitly deny and notify via TCP reset/ICMP informational errors
+ 	  unallowed traffic.
+ 
+ config NFT_COMPAT
+ 	depends on NF_TABLES
+ 	depends on NETFILTER_XTABLES
+ 	tristate "Netfilter x_tables over nf_tables module"
+ 	help
+ 	  This is required if you intend to use any of existing
+ 	  x_tables match/target extensions over the nf_tables
+ 	  framework.
+ 
++>>>>>>> cc4723ca3167 (netfilter: nft_reject: split up reject module into IPv4 and IPv6 specifc parts)
  config NETFILTER_XTABLES
  	tristate "Netfilter Xtables support (required for ip_tables)"
  	default m if NETFILTER_ADVANCED=n
* Unmerged path net/netfilter/nft_reject.c
diff --git a/include/net/netfilter/nft_reject.h b/include/net/netfilter/nft_reject.h
new file mode 100644
index 000000000000..ecda75945e77
--- /dev/null
+++ b/include/net/netfilter/nft_reject.h
@@ -0,0 +1,17 @@
+#ifndef _NFT_REJECT_H_
+#define _NFT_REJECT_H_
+
+struct nft_reject {
+	enum nft_reject_types	type:8;
+	u8			icmp_code;
+};
+
+extern const struct nla_policy nft_reject_policy[];
+
+int nft_reject_init(const struct nft_ctx *ctx,
+		    const struct nft_expr *expr,
+		    const struct nlattr * const tb[]);
+
+int nft_reject_dump(struct sk_buff *skb, const struct nft_expr *expr);
+
+#endif
* Unmerged path net/ipv4/netfilter/Kconfig
* Unmerged path net/ipv4/netfilter/Makefile
diff --git a/net/ipv4/netfilter/nft_reject_ipv4.c b/net/ipv4/netfilter/nft_reject_ipv4.c
new file mode 100644
index 000000000000..e935d8de1182
--- /dev/null
+++ b/net/ipv4/netfilter/nft_reject_ipv4.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2008-2009 Patrick McHardy <kaber@trash.net>
+ * Copyright (c) 2013 Eric Leblond <eric@regit.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Development of this code funded by Astaro AG (http://www.astaro.com/)
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/nf_tables.h>
+#include <net/netfilter/nf_tables.h>
+#include <net/icmp.h>
+#include <net/netfilter/ipv4/nf_reject.h>
+#include <net/netfilter/nft_reject.h>
+
+static void nft_reject_ipv4_eval(const struct nft_expr *expr,
+				 struct nft_data data[NFT_REG_MAX + 1],
+				 const struct nft_pktinfo *pkt)
+{
+	struct nft_reject *priv = nft_expr_priv(expr);
+
+	switch (priv->type) {
+	case NFT_REJECT_ICMP_UNREACH:
+		nf_send_unreach(pkt->skb, priv->icmp_code);
+		break;
+	case NFT_REJECT_TCP_RST:
+		nf_send_reset(pkt->skb, pkt->ops->hooknum);
+		break;
+	}
+
+	data[NFT_REG_VERDICT].verdict = NF_DROP;
+}
+
+static struct nft_expr_type nft_reject_ipv4_type;
+static const struct nft_expr_ops nft_reject_ipv4_ops = {
+	.type		= &nft_reject_ipv4_type,
+	.size		= NFT_EXPR_SIZE(sizeof(struct nft_reject)),
+	.eval		= nft_reject_ipv4_eval,
+	.init		= nft_reject_init,
+	.dump		= nft_reject_dump,
+};
+
+static struct nft_expr_type nft_reject_ipv4_type __read_mostly = {
+	.family		= NFPROTO_IPV4,
+	.name		= "reject",
+	.ops		= &nft_reject_ipv4_ops,
+	.policy		= nft_reject_policy,
+	.maxattr	= NFTA_REJECT_MAX,
+	.owner		= THIS_MODULE,
+};
+
+static int __init nft_reject_ipv4_module_init(void)
+{
+	return nft_register_expr(&nft_reject_ipv4_type);
+}
+
+static void __exit nft_reject_ipv4_module_exit(void)
+{
+	nft_unregister_expr(&nft_reject_ipv4_type);
+}
+
+module_init(nft_reject_ipv4_module_init);
+module_exit(nft_reject_ipv4_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
+MODULE_ALIAS_NFT_AF_EXPR(AF_INET, "reject");
* Unmerged path net/ipv6/netfilter/Kconfig
* Unmerged path net/ipv6/netfilter/Makefile
diff --git a/net/ipv6/netfilter/nft_reject_ipv6.c b/net/ipv6/netfilter/nft_reject_ipv6.c
new file mode 100644
index 000000000000..f73285924144
--- /dev/null
+++ b/net/ipv6/netfilter/nft_reject_ipv6.c
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2008-2009 Patrick McHardy <kaber@trash.net>
+ * Copyright (c) 2013 Eric Leblond <eric@regit.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Development of this code funded by Astaro AG (http://www.astaro.com/)
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/nf_tables.h>
+#include <net/netfilter/nf_tables.h>
+#include <net/netfilter/nft_reject.h>
+#include <net/netfilter/ipv6/nf_reject.h>
+
+static void nft_reject_ipv6_eval(const struct nft_expr *expr,
+				 struct nft_data data[NFT_REG_MAX + 1],
+				 const struct nft_pktinfo *pkt)
+{
+	struct nft_reject *priv = nft_expr_priv(expr);
+	struct net *net = dev_net((pkt->in != NULL) ? pkt->in : pkt->out);
+
+	switch (priv->type) {
+	case NFT_REJECT_ICMP_UNREACH:
+		nf_send_unreach6(net, pkt->skb, priv->icmp_code,
+				 pkt->ops->hooknum);
+		break;
+	case NFT_REJECT_TCP_RST:
+		nf_send_reset6(net, pkt->skb, pkt->ops->hooknum);
+		break;
+	}
+
+	data[NFT_REG_VERDICT].verdict = NF_DROP;
+}
+
+static struct nft_expr_type nft_reject_ipv6_type;
+static const struct nft_expr_ops nft_reject_ipv6_ops = {
+	.type		= &nft_reject_ipv6_type,
+	.size		= NFT_EXPR_SIZE(sizeof(struct nft_reject)),
+	.eval		= nft_reject_ipv6_eval,
+	.init		= nft_reject_init,
+	.dump		= nft_reject_dump,
+};
+
+static struct nft_expr_type nft_reject_ipv6_type __read_mostly = {
+	.family		= NFPROTO_IPV6,
+	.name		= "reject",
+	.ops		= &nft_reject_ipv6_ops,
+	.policy		= nft_reject_policy,
+	.maxattr	= NFTA_REJECT_MAX,
+	.owner		= THIS_MODULE,
+};
+
+static int __init nft_reject_ipv6_module_init(void)
+{
+	return nft_register_expr(&nft_reject_ipv6_type);
+}
+
+static void __exit nft_reject_ipv6_module_exit(void)
+{
+	nft_unregister_expr(&nft_reject_ipv6_type);
+}
+
+module_init(nft_reject_ipv6_module_init);
+module_exit(nft_reject_ipv6_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
+MODULE_ALIAS_NFT_AF_EXPR(AF_INET6, "reject");
* Unmerged path net/netfilter/Kconfig
* Unmerged path net/netfilter/nft_reject.c
