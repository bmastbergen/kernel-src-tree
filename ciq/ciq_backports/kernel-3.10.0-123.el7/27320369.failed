xfs: xfs_remove deadlocks due to inverted AGF vs AGI lock ordering

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-123.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 273203699f82667296e1f14344c5a5a6c4600470
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-123.el7/27320369.failed

Removing an inode from the namespace involves removing the directory
entry and dropping the link count on the inode. Removing the
directory entry can result in locking an AGF (directory blocks were
freed) and removing a link count can result in placing the inode on
an unlinked list which results in locking an AGI.

The big problem here is that we have an ordering constraint on AGF
and AGI locking - inode allocation locks the AGI, then can allocate
a new extent for new inodes, locking the AGF after the AGI.
Similarly, freeing the inode removes the inode from the unlinked
list, requiring that we lock the AGI first, and then freeing the
inode can result in an inode chunk being freed and hence freeing
disk space requiring that we lock an AGF.

Hence the ordering that is imposed by other parts of the code is AGI
before AGF. This means we cannot remove the directory entry before
we drop the inode reference count and put it on the unlinked list as
this results in a lock order of AGF then AGI, and this can deadlock
against inode allocation and freeing. Therefore we must drop the
link counts before we remove the directory entry.

This is still safe from a transactional point of view - it is not
until we get to xfs_bmap_finish() that we have the possibility of
multiple transactions in this operation. Hence as long as we remove
the directory entry and drop the link count in the first transaction
of the remove operation, there are no transactional constraints on
the ordering here.

Change the ordering of the operations in the xfs_remove() function
to align the ordering of AGI and AGF locking to match that of the
rest of the code.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Ben Myers <bpm@sgi.com>
	Signed-off-by: Ben Myers <bpm@sgi.com>

(cherry picked from commit 273203699f82667296e1f14344c5a5a6c4600470)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index a18b684cea27,001aa893ed59..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -1303,6 -2404,489 +1303,492 @@@ xfs_iunpin_wait
  		__xfs_iunpin_wait(ip);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Removing an inode from the namespace involves removing the directory entry
+  * and dropping the link count on the inode. Removing the directory entry can
+  * result in locking an AGF (directory blocks were freed) and removing a link
+  * count can result in placing the inode on an unlinked list which results in
+  * locking an AGI.
+  *
+  * The big problem here is that we have an ordering constraint on AGF and AGI
+  * locking - inode allocation locks the AGI, then can allocate a new extent for
+  * new inodes, locking the AGF after the AGI. Similarly, freeing the inode
+  * removes the inode from the unlinked list, requiring that we lock the AGI
+  * first, and then freeing the inode can result in an inode chunk being freed
+  * and hence freeing disk space requiring that we lock an AGF.
+  *
+  * Hence the ordering that is imposed by other parts of the code is AGI before
+  * AGF. This means we cannot remove the directory entry before we drop the inode
+  * reference count and put it on the unlinked list as this results in a lock
+  * order of AGF then AGI, and this can deadlock against inode allocation and
+  * freeing. Therefore we must drop the link counts before we remove the
+  * directory entry.
+  *
+  * This is still safe from a transactional point of view - it is not until we
+  * get to xfs_bmap_finish() that we have the possibility of multiple
+  * transactions in this operation. Hence as long as we remove the directory
+  * entry and drop the link count in the first transaction of the remove
+  * operation, there are no transactional constraints on the ordering here.
+  */
+ int
+ xfs_remove(
+ 	xfs_inode_t             *dp,
+ 	struct xfs_name		*name,
+ 	xfs_inode_t		*ip)
+ {
+ 	xfs_mount_t		*mp = dp->i_mount;
+ 	xfs_trans_t             *tp = NULL;
+ 	int			is_dir = S_ISDIR(ip->i_d.di_mode);
+ 	int                     error = 0;
+ 	xfs_bmap_free_t         free_list;
+ 	xfs_fsblock_t           first_block;
+ 	int			cancel_flags;
+ 	int			committed;
+ 	int			link_zero;
+ 	uint			resblks;
+ 	uint			log_count;
+ 
+ 	trace_xfs_remove(dp, name);
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return XFS_ERROR(EIO);
+ 
+ 	error = xfs_qm_dqattach(dp, 0);
+ 	if (error)
+ 		goto std_return;
+ 
+ 	error = xfs_qm_dqattach(ip, 0);
+ 	if (error)
+ 		goto std_return;
+ 
+ 	if (is_dir) {
+ 		tp = xfs_trans_alloc(mp, XFS_TRANS_RMDIR);
+ 		log_count = XFS_DEFAULT_LOG_COUNT;
+ 	} else {
+ 		tp = xfs_trans_alloc(mp, XFS_TRANS_REMOVE);
+ 		log_count = XFS_REMOVE_LOG_COUNT;
+ 	}
+ 	cancel_flags = XFS_TRANS_RELEASE_LOG_RES;
+ 
+ 	/*
+ 	 * We try to get the real space reservation first,
+ 	 * allowing for directory btree deletion(s) implying
+ 	 * possible bmap insert(s).  If we can't get the space
+ 	 * reservation then we use 0 instead, and avoid the bmap
+ 	 * btree insert(s) in the directory code by, if the bmap
+ 	 * insert tries to happen, instead trimming the LAST
+ 	 * block from the directory.
+ 	 */
+ 	resblks = XFS_REMOVE_SPACE_RES(mp);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, resblks, 0);
+ 	if (error == ENOSPC) {
+ 		resblks = 0;
+ 		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, 0, 0);
+ 	}
+ 	if (error) {
+ 		ASSERT(error != ENOSPC);
+ 		cancel_flags = 0;
+ 		goto out_trans_cancel;
+ 	}
+ 
+ 	xfs_lock_two_inodes(dp, ip, XFS_ILOCK_EXCL);
+ 
+ 	xfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 
+ 	/*
+ 	 * If we're removing a directory perform some additional validation.
+ 	 */
+ 	cancel_flags |= XFS_TRANS_ABORT;
+ 	if (is_dir) {
+ 		ASSERT(ip->i_d.di_nlink >= 2);
+ 		if (ip->i_d.di_nlink != 2) {
+ 			error = XFS_ERROR(ENOTEMPTY);
+ 			goto out_trans_cancel;
+ 		}
+ 		if (!xfs_dir_isempty(ip)) {
+ 			error = XFS_ERROR(ENOTEMPTY);
+ 			goto out_trans_cancel;
+ 		}
+ 
+ 		/* Drop the link from ip's "..".  */
+ 		error = xfs_droplink(tp, dp);
+ 		if (error)
+ 			goto out_trans_cancel;
+ 
+ 		/* Drop the "." link from ip to self.  */
+ 		error = xfs_droplink(tp, ip);
+ 		if (error)
+ 			goto out_trans_cancel;
+ 	} else {
+ 		/*
+ 		 * When removing a non-directory we need to log the parent
+ 		 * inode here.  For a directory this is done implicitly
+ 		 * by the xfs_droplink call for the ".." entry.
+ 		 */
+ 		xfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);
+ 	}
+ 	xfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
+ 
+ 	/* Drop the link from dp to ip. */
+ 	error = xfs_droplink(tp, ip);
+ 	if (error)
+ 		goto out_trans_cancel;
+ 
+ 	/* Determine if this is the last link while the inode is locked */
+ 	link_zero = (ip->i_d.di_nlink == 0);
+ 
+ 	xfs_bmap_init(&free_list, &first_block);
+ 	error = xfs_dir_removename(tp, dp, name, ip->i_ino,
+ 					&first_block, &free_list, resblks);
+ 	if (error) {
+ 		ASSERT(error != ENOENT);
+ 		goto out_bmap_cancel;
+ 	}
+ 
+ 	/*
+ 	 * If this is a synchronous mount, make sure that the
+ 	 * remove transaction goes to disk before returning to
+ 	 * the user.
+ 	 */
+ 	if (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
+ 		xfs_trans_set_sync(tp);
+ 
+ 	error = xfs_bmap_finish(&tp, &free_list, &committed);
+ 	if (error)
+ 		goto out_bmap_cancel;
+ 
+ 	error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 	if (error)
+ 		goto std_return;
+ 
+ 	/*
+ 	 * If we are using filestreams, kill the stream association.
+ 	 * If the file is still open it may get a new one but that
+ 	 * will get killed on last close in xfs_close() so we don't
+ 	 * have to worry about that.
+ 	 */
+ 	if (!is_dir && link_zero && xfs_inode_is_filestream(ip))
+ 		xfs_filestream_deassociate(ip);
+ 
+ 	return 0;
+ 
+  out_bmap_cancel:
+ 	xfs_bmap_cancel(&free_list);
+  out_trans_cancel:
+ 	xfs_trans_cancel(tp, cancel_flags);
+  std_return:
+ 	return error;
+ }
+ 
+ /*
+  * Enter all inodes for a rename transaction into a sorted array.
+  */
+ STATIC void
+ xfs_sort_for_rename(
+ 	xfs_inode_t	*dp1,	/* in: old (source) directory inode */
+ 	xfs_inode_t	*dp2,	/* in: new (target) directory inode */
+ 	xfs_inode_t	*ip1,	/* in: inode of old entry */
+ 	xfs_inode_t	*ip2,	/* in: inode of new entry, if it
+ 				   already exists, NULL otherwise. */
+ 	xfs_inode_t	**i_tab,/* out: array of inode returned, sorted */
+ 	int		*num_inodes)  /* out: number of inodes in array */
+ {
+ 	xfs_inode_t		*temp;
+ 	int			i, j;
+ 
+ 	/*
+ 	 * i_tab contains a list of pointers to inodes.  We initialize
+ 	 * the table here & we'll sort it.  We will then use it to
+ 	 * order the acquisition of the inode locks.
+ 	 *
+ 	 * Note that the table may contain duplicates.  e.g., dp1 == dp2.
+ 	 */
+ 	i_tab[0] = dp1;
+ 	i_tab[1] = dp2;
+ 	i_tab[2] = ip1;
+ 	if (ip2) {
+ 		*num_inodes = 4;
+ 		i_tab[3] = ip2;
+ 	} else {
+ 		*num_inodes = 3;
+ 		i_tab[3] = NULL;
+ 	}
+ 
+ 	/*
+ 	 * Sort the elements via bubble sort.  (Remember, there are at
+ 	 * most 4 elements to sort, so this is adequate.)
+ 	 */
+ 	for (i = 0; i < *num_inodes; i++) {
+ 		for (j = 1; j < *num_inodes; j++) {
+ 			if (i_tab[j]->i_ino < i_tab[j-1]->i_ino) {
+ 				temp = i_tab[j];
+ 				i_tab[j] = i_tab[j-1];
+ 				i_tab[j-1] = temp;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ /*
+  * xfs_rename
+  */
+ int
+ xfs_rename(
+ 	xfs_inode_t	*src_dp,
+ 	struct xfs_name	*src_name,
+ 	xfs_inode_t	*src_ip,
+ 	xfs_inode_t	*target_dp,
+ 	struct xfs_name	*target_name,
+ 	xfs_inode_t	*target_ip)
+ {
+ 	xfs_trans_t	*tp = NULL;
+ 	xfs_mount_t	*mp = src_dp->i_mount;
+ 	int		new_parent;		/* moving to a new dir */
+ 	int		src_is_directory;	/* src_name is a directory */
+ 	int		error;
+ 	xfs_bmap_free_t free_list;
+ 	xfs_fsblock_t   first_block;
+ 	int		cancel_flags;
+ 	int		committed;
+ 	xfs_inode_t	*inodes[4];
+ 	int		spaceres;
+ 	int		num_inodes;
+ 
+ 	trace_xfs_rename(src_dp, target_dp, src_name, target_name);
+ 
+ 	new_parent = (src_dp != target_dp);
+ 	src_is_directory = S_ISDIR(src_ip->i_d.di_mode);
+ 
+ 	xfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip,
+ 				inodes, &num_inodes);
+ 
+ 	xfs_bmap_init(&free_list, &first_block);
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_RENAME);
+ 	cancel_flags = XFS_TRANS_RELEASE_LOG_RES;
+ 	spaceres = XFS_RENAME_SPACE_RES(mp, target_name->len);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, spaceres, 0);
+ 	if (error == ENOSPC) {
+ 		spaceres = 0;
+ 		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, 0, 0);
+ 	}
+ 	if (error) {
+ 		xfs_trans_cancel(tp, 0);
+ 		goto std_return;
+ 	}
+ 
+ 	/*
+ 	 * Attach the dquots to the inodes
+ 	 */
+ 	error = xfs_qm_vop_rename_dqattach(inodes);
+ 	if (error) {
+ 		xfs_trans_cancel(tp, cancel_flags);
+ 		goto std_return;
+ 	}
+ 
+ 	/*
+ 	 * Lock all the participating inodes. Depending upon whether
+ 	 * the target_name exists in the target directory, and
+ 	 * whether the target directory is the same as the source
+ 	 * directory, we can lock from 2 to 4 inodes.
+ 	 */
+ 	xfs_lock_inodes(inodes, num_inodes, XFS_ILOCK_EXCL);
+ 
+ 	/*
+ 	 * Join all the inodes to the transaction. From this point on,
+ 	 * we can rely on either trans_commit or trans_cancel to unlock
+ 	 * them.
+ 	 */
+ 	xfs_trans_ijoin(tp, src_dp, XFS_ILOCK_EXCL);
+ 	if (new_parent)
+ 		xfs_trans_ijoin(tp, target_dp, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, src_ip, XFS_ILOCK_EXCL);
+ 	if (target_ip)
+ 		xfs_trans_ijoin(tp, target_ip, XFS_ILOCK_EXCL);
+ 
+ 	/*
+ 	 * If we are using project inheritance, we only allow renames
+ 	 * into our tree when the project IDs are the same; else the
+ 	 * tree quota mechanism would be circumvented.
+ 	 */
+ 	if (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&
+ 		     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {
+ 		error = XFS_ERROR(EXDEV);
+ 		goto error_return;
+ 	}
+ 
+ 	/*
+ 	 * Set up the target.
+ 	 */
+ 	if (target_ip == NULL) {
+ 		/*
+ 		 * If there's no space reservation, check the entry will
+ 		 * fit before actually inserting it.
+ 		 */
+ 		error = xfs_dir_canenter(tp, target_dp, target_name, spaceres);
+ 		if (error)
+ 			goto error_return;
+ 		/*
+ 		 * If target does not exist and the rename crosses
+ 		 * directories, adjust the target directory link count
+ 		 * to account for the ".." reference from the new entry.
+ 		 */
+ 		error = xfs_dir_createname(tp, target_dp, target_name,
+ 						src_ip->i_ino, &first_block,
+ 						&free_list, spaceres);
+ 		if (error == ENOSPC)
+ 			goto error_return;
+ 		if (error)
+ 			goto abort_return;
+ 
+ 		xfs_trans_ichgtime(tp, target_dp,
+ 					XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
+ 
+ 		if (new_parent && src_is_directory) {
+ 			error = xfs_bumplink(tp, target_dp);
+ 			if (error)
+ 				goto abort_return;
+ 		}
+ 	} else { /* target_ip != NULL */
+ 		/*
+ 		 * If target exists and it's a directory, check that both
+ 		 * target and source are directories and that target can be
+ 		 * destroyed, or that neither is a directory.
+ 		 */
+ 		if (S_ISDIR(target_ip->i_d.di_mode)) {
+ 			/*
+ 			 * Make sure target dir is empty.
+ 			 */
+ 			if (!(xfs_dir_isempty(target_ip)) ||
+ 			    (target_ip->i_d.di_nlink > 2)) {
+ 				error = XFS_ERROR(EEXIST);
+ 				goto error_return;
+ 			}
+ 		}
+ 
+ 		/*
+ 		 * Link the source inode under the target name.
+ 		 * If the source inode is a directory and we are moving
+ 		 * it across directories, its ".." entry will be
+ 		 * inconsistent until we replace that down below.
+ 		 *
+ 		 * In case there is already an entry with the same
+ 		 * name at the destination directory, remove it first.
+ 		 */
+ 		error = xfs_dir_replace(tp, target_dp, target_name,
+ 					src_ip->i_ino,
+ 					&first_block, &free_list, spaceres);
+ 		if (error)
+ 			goto abort_return;
+ 
+ 		xfs_trans_ichgtime(tp, target_dp,
+ 					XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
+ 
+ 		/*
+ 		 * Decrement the link count on the target since the target
+ 		 * dir no longer points to it.
+ 		 */
+ 		error = xfs_droplink(tp, target_ip);
+ 		if (error)
+ 			goto abort_return;
+ 
+ 		if (src_is_directory) {
+ 			/*
+ 			 * Drop the link from the old "." entry.
+ 			 */
+ 			error = xfs_droplink(tp, target_ip);
+ 			if (error)
+ 				goto abort_return;
+ 		}
+ 	} /* target_ip != NULL */
+ 
+ 	/*
+ 	 * Remove the source.
+ 	 */
+ 	if (new_parent && src_is_directory) {
+ 		/*
+ 		 * Rewrite the ".." entry to point to the new
+ 		 * directory.
+ 		 */
+ 		error = xfs_dir_replace(tp, src_ip, &xfs_name_dotdot,
+ 					target_dp->i_ino,
+ 					&first_block, &free_list, spaceres);
+ 		ASSERT(error != EEXIST);
+ 		if (error)
+ 			goto abort_return;
+ 	}
+ 
+ 	/*
+ 	 * We always want to hit the ctime on the source inode.
+ 	 *
+ 	 * This isn't strictly required by the standards since the source
+ 	 * inode isn't really being changed, but old unix file systems did
+ 	 * it and some incremental backup programs won't work without it.
+ 	 */
+ 	xfs_trans_ichgtime(tp, src_ip, XFS_ICHGTIME_CHG);
+ 	xfs_trans_log_inode(tp, src_ip, XFS_ILOG_CORE);
+ 
+ 	/*
+ 	 * Adjust the link count on src_dp.  This is necessary when
+ 	 * renaming a directory, either within one parent when
+ 	 * the target existed, or across two parent directories.
+ 	 */
+ 	if (src_is_directory && (new_parent || target_ip != NULL)) {
+ 
+ 		/*
+ 		 * Decrement link count on src_directory since the
+ 		 * entry that's moved no longer points to it.
+ 		 */
+ 		error = xfs_droplink(tp, src_dp);
+ 		if (error)
+ 			goto abort_return;
+ 	}
+ 
+ 	error = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,
+ 					&first_block, &free_list, spaceres);
+ 	if (error)
+ 		goto abort_return;
+ 
+ 	xfs_trans_ichgtime(tp, src_dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
+ 	xfs_trans_log_inode(tp, src_dp, XFS_ILOG_CORE);
+ 	if (new_parent)
+ 		xfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);
+ 
+ 	/*
+ 	 * If this is a synchronous mount, make sure that the
+ 	 * rename transaction goes to disk before returning to
+ 	 * the user.
+ 	 */
+ 	if (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {
+ 		xfs_trans_set_sync(tp);
+ 	}
+ 
+ 	error = xfs_bmap_finish(&tp, &free_list, &committed);
+ 	if (error) {
+ 		xfs_bmap_cancel(&free_list);
+ 		xfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES |
+ 				 XFS_TRANS_ABORT));
+ 		goto std_return;
+ 	}
+ 
+ 	/*
+ 	 * trans_commit will unlock src_ip, target_ip & decrement
+ 	 * the vnode references.
+ 	 */
+ 	return xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);
+ 
+  abort_return:
+ 	cancel_flags |= XFS_TRANS_ABORT;
+  error_return:
+ 	xfs_bmap_cancel(&free_list);
+ 	xfs_trans_cancel(tp, cancel_flags);
+  std_return:
+ 	return error;
+ }
+ 
++>>>>>>> 273203699f82 (xfs: xfs_remove deadlocks due to inverted AGF vs AGI lock ordering)
  STATIC int
  xfs_iflush_cluster(
  	xfs_inode_t	*ip,
* Unmerged path fs/xfs/xfs_inode.c
