selinux: regularize Opt_... names a bit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit da3d76abb2e74c07b1cd620ee5e3b31227846c7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/da3d76ab.failed

	Reviewed-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit da3d76abb2e74c07b1cd620ee5e3b31227846c7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 42145010da10,9b350070ed9e..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -441,20 -458,42 +441,38 @@@ enum 
  	Opt_fscontext = 2,
  	Opt_defcontext = 3,
  	Opt_rootcontext = 4,
++<<<<<<< HEAD
 +	Opt_labelsupport = 5,
 +	Opt_nextmntopt = 6,
 +};
 +
 +#define NUM_SEL_MNT_OPTS	(Opt_nextmntopt - 1)
 +
 +static const match_table_t tokens = {
 +	{Opt_context, CONTEXT_STR "%s"},
 +	{Opt_fscontext, FSCONTEXT_STR "%s"},
 +	{Opt_defcontext, DEFCONTEXT_STR "%s"},
 +	{Opt_rootcontext, ROOTCONTEXT_STR "%s"},
 +	{Opt_labelsupport, LABELSUPP_STR},
 +	{Opt_error, NULL},
++=======
+ 	Opt_seclabel = 5,
+ };
+ 
+ #define A(s, has_arg) {#s, sizeof(#s) - 1, Opt_##s, has_arg}
+ static struct {
+ 	const char *name;
+ 	int len;
+ 	int opt;
+ 	bool has_arg;
+ } tokens[] = {
+ 	A(context, true),
+ 	A(fscontext, true),
+ 	A(defcontext, true),
+ 	A(rootcontext, true),
+ 	A(seclabel, false),
++>>>>>>> da3d76abb2e7 (selinux: regularize Opt_... names a bit)
  };
 -#undef A
 -
 -static int match_opt_prefix(char *s, int l, char **arg)
 -{
 -	int i;
 -
 -	for (i = 0; i < ARRAY_SIZE(tokens); i++) {
 -		size_t len = tokens[i].len;
 -		if (len > l || memcmp(s, tokens[i].name, len))
 -			continue;
 -		if (tokens[i].has_arg) {
 -			if (len == l || s[len] != '=')
 -				continue;
 -			*arg = s + len + 1;
 -		} else if (len != l)
 -			continue;
 -		return tokens[i].opt;
 -	}
 -	return Opt_error;
 -}
  
  #define SEL_MOUNT_FAIL_MSG "SELinux:  duplicate or incompatible mount options\n"
  
@@@ -1013,125 -1006,83 +1031,171 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int selinux_add_opt(int token, const char *s, void **mnt_opts)
+ {
+ 	struct selinux_mnt_opts *opts = *mnt_opts;
+ 
+ 	if (token == Opt_seclabel)	/* eaten and completely ignored */
+ 		return 0;
+ 
+ 	if (!opts) {
+ 		opts = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);
+ 		if (!opts)
+ 			return -ENOMEM;
+ 		*mnt_opts = opts;
+ 	}
+ 	if (!s)
+ 		return -ENOMEM;
+ 	switch (token) {
+ 	case Opt_context:
+ 		if (opts->context || opts->defcontext)
+ 			goto Einval;
+ 		opts->context = s;
+ 		break;
+ 	case Opt_fscontext:
+ 		if (opts->fscontext)
+ 			goto Einval;
+ 		opts->fscontext = s;
+ 		break;
+ 	case Opt_rootcontext:
+ 		if (opts->rootcontext)
+ 			goto Einval;
+ 		opts->rootcontext = s;
+ 		break;
+ 	case Opt_defcontext:
+ 		if (opts->context || opts->defcontext)
+ 			goto Einval;
+ 		opts->defcontext = s;
+ 		break;
+ 	}
+ 	return 0;
+ Einval:
+ 	pr_warn(SEL_MOUNT_FAIL_MSG);
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> da3d76abb2e7 (selinux: regularize Opt_... names a bit)
  static int selinux_parse_opts_str(char *options,
 -				  void **mnt_opts)
 +				  struct security_mnt_opts *opts)
  {
 -	char *p = options, *next;
 -	int rc;
 +	char *p;
 +	char *context = NULL, *defcontext = NULL;
 +	char *fscontext = NULL, *rootcontext = NULL;
 +	int rc, num_mnt_opts = 0;
  
 -	/* Standard string-based options. */
 -	for (p = options; *p; p = next) {
 -		int token, len;
 -		char *arg = NULL;
 +	opts->num_mnt_opts = 0;
  
 -		next = strchr(p, '|');
 -		if (next) {
 -			len = next++ - p;
 -		} else {
 -			len = strlen(p);
 -			next = p + len;
 -		}
 +	/* Standard string-based options. */
 +	while ((p = strsep(&options, "|")) != NULL) {
 +		int token;
 +		substring_t args[MAX_OPT_ARGS];
  
 -		if (!len)
 +		if (!*p)
  			continue;
  
 -		token = match_opt_prefix(p, len, &arg);
 -		if (arg)
 -			arg = kmemdup_nul(arg, p + len - arg, GFP_KERNEL);
 -		rc = selinux_add_opt(token, arg, mnt_opts);
 -		if (rc) {
 -			kfree(arg);
 -			selinux_free_mnt_opts(*mnt_opts);
 -			*mnt_opts = NULL;
 -			return rc;
 +		token = match_token(p, tokens, args);
 +
 +		switch (token) {
 +		case Opt_context:
 +			if (context || defcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			context = match_strdup(&args[0]);
 +			if (!context) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_fscontext:
 +			if (fscontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			fscontext = match_strdup(&args[0]);
 +			if (!fscontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_rootcontext:
 +			if (rootcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			rootcontext = match_strdup(&args[0]);
 +			if (!rootcontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_defcontext:
 +			if (context || defcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			defcontext = match_strdup(&args[0]);
 +			if (!defcontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +		case Opt_labelsupport:
 +			break;
 +		default:
 +			rc = -EINVAL;
 +			pr_warn("SELinux:  unknown mount option\n");
 +			goto out_err;
 +
  		}
  	}
 +
 +	rc = -ENOMEM;
 +	opts->mnt_opts = kcalloc(NUM_SEL_MNT_OPTS, sizeof(char *), GFP_KERNEL);
 +	if (!opts->mnt_opts)
 +		goto out_err;
 +
 +	opts->mnt_opts_flags = kcalloc(NUM_SEL_MNT_OPTS, sizeof(int),
 +				       GFP_KERNEL);
 +	if (!opts->mnt_opts_flags)
 +		goto out_err;
 +
 +	if (fscontext) {
 +		opts->mnt_opts[num_mnt_opts] = fscontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = FSCONTEXT_MNT;
 +	}
 +	if (context) {
 +		opts->mnt_opts[num_mnt_opts] = context;
 +		opts->mnt_opts_flags[num_mnt_opts++] = CONTEXT_MNT;
 +	}
 +	if (rootcontext) {
 +		opts->mnt_opts[num_mnt_opts] = rootcontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = ROOTCONTEXT_MNT;
 +	}
 +	if (defcontext) {
 +		opts->mnt_opts[num_mnt_opts] = defcontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = DEFCONTEXT_MNT;
 +	}
 +
 +	opts->num_mnt_opts = num_mnt_opts;
  	return 0;
 +
 +out_err:
 +	security_free_mnt_opts(opts);
 +	kfree(context);
 +	kfree(defcontext);
 +	kfree(fscontext);
 +	kfree(rootcontext);
 +	return rc;
  }
  
  static int show_sid(struct seq_file *m, u32 sid)
* Unmerged path security/selinux/hooks.c
