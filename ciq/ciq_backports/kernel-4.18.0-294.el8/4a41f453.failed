tcp: change pingpong threshold to 3

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Wei Wang <weiwan@google.com>
commit 4a41f453bedfd5e9cd040bad509d9da49feb3e2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4a41f453.failed

In order to be more confident about an on-going interactive session, we
increment pingpong count by 1 for every interactive transaction and we
adjust TCP_PINGPONG_THRESH to 3.
This means, we only consider a session in pingpong mode after we see 3
interactive transactions, and start to activate delayed acks in quick
ack mode.
And in order to not over-count the credits, we only increase pingpong
count for the first packet sent in response for the previous received
packet.
This is mainly to prevent delaying the ack immediately after some
handshake protocol but no real interactive traffic pattern afterwards.

	Signed-off-by: Wei Wang <weiwan@google.com>
	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4a41f453bedfd5e9cd040bad509d9da49feb3e2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/inet_connection_sock.h
#	net/ipv4/tcp_output.c
diff --cc include/net/inet_connection_sock.h
index bcfefea637b6,ff40e1d08157..000000000000
--- a/include/net/inet_connection_sock.h
+++ b/include/net/inet_connection_sock.h
@@@ -321,9 -315,28 +321,35 @@@ int inet_csk_compat_setsockopt(struct s
  
  struct dst_entry *inet_csk_update_pmtu(struct sock *sk, u32 mtu);
  
++<<<<<<< HEAD
 +static inline bool inet_csk_has_ulp(struct sock *sk)
++=======
+ #define TCP_PINGPONG_THRESH	3
+ 
+ static inline void inet_csk_enter_pingpong_mode(struct sock *sk)
++>>>>>>> 4a41f453bedf (tcp: change pingpong threshold to 3)
  {
 -	inet_csk(sk)->icsk_ack.pingpong = TCP_PINGPONG_THRESH;
 +	return inet_sk(sk)->is_icsk && !!inet_csk(sk)->icsk_ulp_ops;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void inet_csk_exit_pingpong_mode(struct sock *sk)
+ {
+ 	inet_csk(sk)->icsk_ack.pingpong = 0;
+ }
+ 
+ static inline bool inet_csk_in_pingpong_mode(struct sock *sk)
+ {
+ 	return inet_csk(sk)->icsk_ack.pingpong >= TCP_PINGPONG_THRESH;
+ }
+ 
+ static inline void inet_csk_inc_pingpong_cnt(struct sock *sk)
+ {
+ 	struct inet_connection_sock *icsk = inet_csk(sk);
+ 
+ 	if (icsk->icsk_ack.pingpong < U8_MAX)
+ 		icsk->icsk_ack.pingpong++;
+ }
++>>>>>>> 4a41f453bedf (tcp: change pingpong threshold to 3)
  #endif /* _INET_CONNECTION_SOCK_H */
diff --cc net/ipv4/tcp_output.c
index d91789f2fcaa,96bdb8eae9bb..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -154,13 -165,16 +154,21 @@@ static void tcp_event_data_sent(struct 
  	if (tcp_packets_in_flight(tp) == 0)
  		tcp_ca_event(sk, CA_EVENT_TX_START);
  
- 	tp->lsndtime = now;
- 
- 	/* If it is a reply for ato after last received
- 	 * packet, enter pingpong mode.
+ 	/* If this is the first data packet sent in response to the
+ 	 * previous received data,
+ 	 * and it is a reply for ato after last received packet,
+ 	 * increase pingpong count.
  	 */
++<<<<<<< HEAD
 +	if ((u32)(now - icsk->icsk_ack.lrcvtime) < icsk->icsk_ack.ato)
 +		icsk->icsk_ack.pingpong = 1;
++=======
+ 	if (before(tp->lsndtime, icsk->icsk_ack.lrcvtime) &&
+ 	    (u32)(now - icsk->icsk_ack.lrcvtime) < icsk->icsk_ack.ato)
+ 		inet_csk_inc_pingpong_cnt(sk);
+ 
+ 	tp->lsndtime = now;
++>>>>>>> 4a41f453bedf (tcp: change pingpong threshold to 3)
  }
  
  /* Account for an ACK we sent. */
* Unmerged path include/net/inet_connection_sock.h
* Unmerged path net/ipv4/tcp_output.c
