x86/msi: Only use high bits of MSI address for DMAR unit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] msi: Only use high bits of MSI address for DMAR unit (Vitaly Kuznetsov) [1903823]
Rebuild_FUZZ: 96.30%
commit-author David Woodhouse <dwmw@amazon.co.uk>
commit 47bea873cf809f490cfac0c4e88533fd7fed6064
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/47bea873.failed

The Intel IOMMU has an MSI-like configuration for its interrupt, but it
isn't really MSI. So it gets to abuse the high 32 bits of the address, and
puts the high 24 bits of the extended APIC ID there.

This isn't something that can be used in the general case for real MSIs,
since external devices using the high bits of the address would be
performing writes to actual memory space above 4GiB, not targeted at the
APIC.

Factor the hack out and allow it only to be used when appropriate, adding a
WARN_ON_ONCE() if other MSIs are targeted at an unreachable APIC ID. That
should never happen since the compatibility MSI messages are not used when
Interrupt Remapping is enabled.

The x2apic_enabled() check isn't needed because Linux won't bring up CPUs
with higher APIC IDs unless IR and x2apic are enabled anyway.

	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20201024213535.443185-3-dwmw2@infradead.org

(cherry picked from commit 47bea873cf809f490cfac0c4e88533fd7fed6064)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/msi.c
diff --cc arch/x86/kernel/apic/msi.c
index b97f36407a88,516df47bde73..000000000000
--- a/arch/x86/kernel/apic/msi.c
+++ b/arch/x86/kernel/apic/msi.c
@@@ -24,9 -21,10 +24,10 @@@
  #include <asm/apic.h>
  #include <asm/irq_remapping.h>
  
 -struct irq_domain *x86_pci_msi_default_domain __ro_after_init;
 +static struct irq_domain *msi_default_domain;
  
- static void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg)
+ static void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg,
+ 				  bool dmar)
  {
  	msg->address_hi = MSI_ADDR_BASE_HI;
  
@@@ -46,11 -41,22 +44,22 @@@
  		MSI_DATA_LEVEL_ASSERT |
  		MSI_DATA_DELIVERY_FIXED |
  		MSI_DATA_VECTOR(cfg->vector);
+ 
+ 	/*
+ 	 * Only the IOMMU itself can use the trick of putting destination
+ 	 * APIC ID into the high bits of the address. Anything else would
+ 	 * just be writing to memory if it tried that, and needs IR to
+ 	 * address higher APIC IDs.
+ 	 */
+ 	if (dmar)
+ 		msg->address_hi |= MSI_ADDR_EXT_DEST_ID(cfg->dest_apicid);
+ 	else
+ 		WARN_ON_ONCE(MSI_ADDR_EXT_DEST_ID(cfg->dest_apicid));
  }
  
 -void x86_vector_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
 +static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
  {
- 	__irq_msi_compose_msg(irqd_cfg(data), msg);
+ 	__irq_msi_compose_msg(irqd_cfg(data), msg, false);
  }
  
  static void irq_msi_update_msg(struct irq_data *irqd, struct irq_cfg *cfg)
@@@ -321,7 -308,7 +341,11 @@@ static struct irq_chip dmar_msi_control
  	.irq_ack		= irq_chip_ack_parent,
  	.irq_set_affinity	= msi_domain_set_affinity,
  	.irq_retrigger		= irq_chip_retrigger_hierarchy,
++<<<<<<< HEAD
 +	.irq_compose_msi_msg	= irq_msi_compose_msg,
++=======
+ 	.irq_compose_msi_msg	= dmar_msi_compose_msg,
++>>>>>>> 47bea873cf80 (x86/msi: Only use high bits of MSI address for DMAR unit)
  	.irq_write_msi_msg	= dmar_msi_write_msg,
  	.flags			= IRQCHIP_SKIP_SET_WAKE,
  };
* Unmerged path arch/x86/kernel/apic/msi.c
