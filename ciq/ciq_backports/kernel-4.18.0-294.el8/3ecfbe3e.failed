mptcp: emit tcp reset when a join request fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Florian Westphal <fw@strlen.de>
commit 3ecfbe3e820997033beb4181c95d80d5c9ac6f85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3ecfbe3e.failed

RFC 8684 says:
 If the token is unknown or the host wants to refuse subflow establishment
 (for example, due to a limit on the number of subflows it will permit),
 the receiver will send back a reset (RST) signal, analogous to an unknown
 port in TCP, containing an MP_TCPRST option (Section 3.6) with an
 "MPTCP specific error" reason code.

mptcp-next doesn't support MP_TCPRST yet, this can be added in another
change.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 3ecfbe3e820997033beb4181c95d80d5c9ac6f85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/subflow.c
diff --cc net/mptcp/subflow.c
index 7eeb71b1861e,5f5815a1665f..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -173,7 -144,26 +178,30 @@@ static int subflow_init_req(struct requ
  	}
  
  	if (mp_opt.mp_capable && listener->request_mptcp) {
++<<<<<<< HEAD
 +		int err;
++=======
+ 		int err, retries = 4;
+ 
+ 		subflow_req->ssn_offset = TCP_SKB_CB(skb)->seq;
+ again:
+ 		do {
+ 			get_random_bytes(&subflow_req->local_key, sizeof(subflow_req->local_key));
+ 		} while (subflow_req->local_key == 0);
+ 
+ 		if (unlikely(req->syncookie)) {
+ 			mptcp_crypto_key_sha(subflow_req->local_key,
+ 					     &subflow_req->token,
+ 					     &subflow_req->idsn);
+ 			if (mptcp_token_exists(subflow_req->token)) {
+ 				if (retries-- > 0)
+ 					goto again;
+ 			} else {
+ 				subflow_req->mp_capable = 1;
+ 			}
+ 			return 0;
+ 		}
++>>>>>>> 3ecfbe3e8209 (mptcp: emit tcp reset when a join request fails)
  
  		err = mptcp_token_new_request(req);
  		if (err == 0)
@@@ -188,32 -179,113 +216,125 @@@
  		subflow_req->token = mp_opt.token;
  		subflow_req->remote_nonce = mp_opt.nonce;
  		subflow_req->msk = subflow_token_join_request(req, skb);
++<<<<<<< HEAD
++=======
+ 
+ 		/* Can't fall back to TCP in this case. */
+ 		if (!subflow_req->msk)
+ 			return -EPERM;
+ 
+ 		if (unlikely(req->syncookie)) {
+ 			if (mptcp_can_accept_new_subflow(subflow_req->msk))
+ 				subflow_init_req_cookie_join_save(subflow_req, skb);
+ 		}
+ 
++>>>>>>> 3ecfbe3e8209 (mptcp: emit tcp reset when a join request fails)
  		pr_debug("token=%u, remote_nonce=%u msk=%p", subflow_req->token,
  			 subflow_req->remote_nonce, subflow_req->msk);
  	}
+ 
+ 	return 0;
  }
  
 -int mptcp_subflow_init_cookie_req(struct request_sock *req,
 -				  const struct sock *sk_listener,
 -				  struct sk_buff *skb)
 +static void subflow_v4_init_req(struct request_sock *req,
 +				const struct sock *sk_listener,
 +				struct sk_buff *skb)
  {
++<<<<<<< HEAD
++=======
+ 	struct mptcp_subflow_context *listener = mptcp_subflow_ctx(sk_listener);
+ 	struct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);
+ 	struct mptcp_options_received mp_opt;
+ 	int err;
+ 
+ 	err = __subflow_init_req(req, sk_listener);
+ 	if (err)
+ 		return err;
+ 
+ 	mptcp_get_options(skb, &mp_opt);
+ 
+ 	if (mp_opt.mp_capable && mp_opt.mp_join)
+ 		return -EINVAL;
+ 
+ 	if (mp_opt.mp_capable && listener->request_mptcp) {
+ 		if (mp_opt.sndr_key == 0)
+ 			return -EINVAL;
+ 
+ 		subflow_req->local_key = mp_opt.rcvr_key;
+ 		err = mptcp_token_new_request(req);
+ 		if (err)
+ 			return err;
+ 
+ 		subflow_req->mp_capable = 1;
+ 		subflow_req->ssn_offset = TCP_SKB_CB(skb)->seq - 1;
+ 	} else if (mp_opt.mp_join && listener->request_mptcp) {
+ 		if (!mptcp_token_join_cookie_init_state(subflow_req, skb))
+ 			return -EINVAL;
+ 
+ 		if (mptcp_can_accept_new_subflow(subflow_req->msk))
+ 			subflow_req->mp_join = 1;
+ 
+ 		subflow_req->ssn_offset = TCP_SKB_CB(skb)->seq - 1;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(mptcp_subflow_init_cookie_req);
+ 
+ static struct dst_entry *subflow_v4_route_req(const struct sock *sk,
+ 					      struct sk_buff *skb,
+ 					      struct flowi *fl,
+ 					      struct request_sock *req)
+ {
+ 	struct dst_entry *dst;
+ 	int err;
+ 
++>>>>>>> 3ecfbe3e8209 (mptcp: emit tcp reset when a join request fails)
  	tcp_rsk(req)->is_mptcp = 1;
  
 -	dst = tcp_request_sock_ipv4_ops.route_req(sk, skb, fl, req);
 -	if (!dst)
 -		return NULL;
 +	tcp_request_sock_ipv4_ops.init_req(req, sk_listener, skb);
  
++<<<<<<< HEAD
 +	subflow_init_req(req, sk_listener, skb);
++=======
+ 	err = subflow_init_req(req, sk, skb);
+ 	if (err == 0)
+ 		return dst;
+ 
+ 	dst_release(dst);
+ 	if (!req->syncookie)
+ 		tcp_request_sock_ops.send_reset(sk, skb);
+ 	return NULL;
++>>>>>>> 3ecfbe3e8209 (mptcp: emit tcp reset when a join request fails)
  }
  
  #if IS_ENABLED(CONFIG_MPTCP_IPV6)
 -static struct dst_entry *subflow_v6_route_req(const struct sock *sk,
 -					      struct sk_buff *skb,
 -					      struct flowi *fl,
 -					      struct request_sock *req)
 +static void subflow_v6_init_req(struct request_sock *req,
 +				const struct sock *sk_listener,
 +				struct sk_buff *skb)
  {
++<<<<<<< HEAD
++=======
+ 	struct dst_entry *dst;
+ 	int err;
+ 
++>>>>>>> 3ecfbe3e8209 (mptcp: emit tcp reset when a join request fails)
  	tcp_rsk(req)->is_mptcp = 1;
  
 -	dst = tcp_request_sock_ipv6_ops.route_req(sk, skb, fl, req);
 -	if (!dst)
 -		return NULL;
 +	tcp_request_sock_ipv6_ops.init_req(req, sk_listener, skb);
  
++<<<<<<< HEAD
 +	subflow_init_req(req, sk_listener, skb);
++=======
+ 	err = subflow_init_req(req, sk, skb);
+ 	if (err == 0)
+ 		return dst;
+ 
+ 	dst_release(dst);
+ 	if (!req->syncookie)
+ 		tcp6_request_sock_ops.send_reset(sk, skb);
+ 	return NULL;
++>>>>>>> 3ecfbe3e8209 (mptcp: emit tcp reset when a join request fails)
  }
  #endif
  
* Unmerged path net/mptcp/subflow.c
