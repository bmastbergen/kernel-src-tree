powerpc/mm/book3s64/radix: Off-load TLB invalidations to host when !GTSE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Nicholas Piggin <npiggin@gmail.com>
commit dd3d9aa5589c52efaec12ffeb84f0f5f8208fbc3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dd3d9aa5.failed

When platform doesn't support GTSE, let TLB invalidation requests
for radix guests be off-loaded to the host using H_RPT_INVALIDATE
hcall.

	[hcall wrapper, error path handling and renames]

	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Bharata B Rao <bharata@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200703053608.12884-4-bharata@linux.ibm.com
(cherry picked from commit dd3d9aa5589c52efaec12ffeb84f0f5f8208fbc3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/plpar_wrappers.h
#	arch/powerpc/mm/book3s64/radix_tlb.c
diff --cc arch/powerpc/include/asm/plpar_wrappers.h
index cff5a411e595,4293c5d2ddf4..000000000000
--- a/arch/powerpc/include/asm/plpar_wrappers.h
+++ b/arch/powerpc/include/asm/plpar_wrappers.h
@@@ -340,6 -385,19 +385,22 @@@ static inline long plpar_set_ciabr(unsi
  {
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline long plpar_pte_read_4(unsigned long flags, unsigned long ptex,
+ 				    unsigned long *ptes)
+ {
+ 	return 0;
+ }
+ 
+ static inline long pseries_rpt_invalidate(u32 pid, u64 target, u64 type,
+ 					  u64 page_sizes, u64 start, u64 end)
+ {
+ 	return 0;
+ }
+ 
++>>>>>>> dd3d9aa5589c (powerpc/mm/book3s64/radix: Off-load TLB invalidations to host when !GTSE)
  #endif /* CONFIG_PPC_PSERIES */
  
  #endif /* _ASM_POWERPC_PLPAR_WRAPPERS_H */
diff --cc arch/powerpc/mm/book3s64/radix_tlb.c
index 35a168bbe137,0d233763441f..000000000000
--- a/arch/powerpc/mm/book3s64/radix_tlb.c
+++ b/arch/powerpc/mm/book3s64/radix_tlb.c
@@@ -651,10 -695,21 +652,28 @@@ void radix__flush_tlb_mm(struct mm_stru
  			goto local;
  		}
  
++<<<<<<< HEAD
 +		if (mm_needs_flush_escalation(mm))
 +			_tlbie_pid(pid, RIC_FLUSH_ALL);
 +		else
 +			_tlbie_pid(pid, RIC_FLUSH_TLB);
++=======
+ 		if (!mmu_has_feature(MMU_FTR_GTSE)) {
+ 			unsigned long tgt = H_RPTI_TARGET_CMMU;
+ 
+ 			if (atomic_read(&mm->context.copros) > 0)
+ 				tgt |= H_RPTI_TARGET_NMMU;
+ 			pseries_rpt_invalidate(pid, tgt, H_RPTI_TYPE_TLB,
+ 					       H_RPTI_PAGE_ALL, 0, -1UL);
+ 		} else if (cputlb_use_tlbie()) {
+ 			if (mm_needs_flush_escalation(mm))
+ 				_tlbie_pid(pid, RIC_FLUSH_ALL);
+ 			else
+ 				_tlbie_pid(pid, RIC_FLUSH_TLB);
+ 		} else {
+ 			_tlbiel_pid_multicast(mm, pid, RIC_FLUSH_TLB);
+ 		}
++>>>>>>> dd3d9aa5589c (powerpc/mm/book3s64/radix: Off-load TLB invalidations to host when !GTSE)
  	} else {
  local:
  		_tlbiel_pid(pid, RIC_FLUSH_TLB);
@@@ -680,7 -735,19 +699,23 @@@ static void __flush_all_mm(struct mm_st
  				goto local;
  			}
  		}
++<<<<<<< HEAD
 +		_tlbie_pid(pid, RIC_FLUSH_ALL);
++=======
+ 		if (!mmu_has_feature(MMU_FTR_GTSE)) {
+ 			unsigned long tgt = H_RPTI_TARGET_CMMU;
+ 			unsigned long type = H_RPTI_TYPE_TLB | H_RPTI_TYPE_PWC |
+ 					     H_RPTI_TYPE_PRT;
+ 
+ 			if (atomic_read(&mm->context.copros) > 0)
+ 				tgt |= H_RPTI_TARGET_NMMU;
+ 			pseries_rpt_invalidate(pid, tgt, type,
+ 					       H_RPTI_PAGE_ALL, 0, -1UL);
+ 		} else if (cputlb_use_tlbie())
+ 			_tlbie_pid(pid, RIC_FLUSH_ALL);
+ 		else
+ 			_tlbiel_pid_multicast(mm, pid, RIC_FLUSH_ALL);
++>>>>>>> dd3d9aa5589c (powerpc/mm/book3s64/radix: Off-load TLB invalidations to host when !GTSE)
  	} else {
  local:
  		_tlbiel_pid(pid, RIC_FLUSH_ALL);
@@@ -715,7 -777,22 +750,26 @@@ void radix__flush_tlb_page_psize(struc
  			exit_flush_lazy_tlbs(mm);
  			goto local;
  		}
++<<<<<<< HEAD
 +		_tlbie_va(vmaddr, pid, psize, RIC_FLUSH_TLB);
++=======
+ 		if (!mmu_has_feature(MMU_FTR_GTSE)) {
+ 			unsigned long tgt, pg_sizes, size;
+ 
+ 			tgt = H_RPTI_TARGET_CMMU;
+ 			pg_sizes = psize_to_rpti_pgsize(psize);
+ 			size = 1UL << mmu_psize_to_shift(psize);
+ 
+ 			if (atomic_read(&mm->context.copros) > 0)
+ 				tgt |= H_RPTI_TARGET_NMMU;
+ 			pseries_rpt_invalidate(pid, tgt, H_RPTI_TYPE_TLB,
+ 					       pg_sizes, vmaddr,
+ 					       vmaddr + size);
+ 		} else if (cputlb_use_tlbie())
+ 			_tlbie_va(vmaddr, pid, psize, RIC_FLUSH_TLB);
+ 		else
+ 			_tlbiel_va_multicast(mm, vmaddr, pid, psize, RIC_FLUSH_TLB);
++>>>>>>> dd3d9aa5589c (powerpc/mm/book3s64/radix: Off-load TLB invalidations to host when !GTSE)
  	} else {
  local:
  		_tlbiel_va(vmaddr, pid, psize, RIC_FLUSH_TLB);
@@@ -734,12 -811,45 +788,26 @@@ void radix__flush_tlb_page(struct vm_ar
  EXPORT_SYMBOL(radix__flush_tlb_page);
  
  #else /* CONFIG_SMP */
 -static inline void exit_flush_lazy_tlbs(struct mm_struct *mm) { }
 +#define radix__flush_all_mm radix__local_flush_all_mm
  #endif /* CONFIG_SMP */
  
 -static void do_tlbiel_kernel(void *info)
 -{
 -	_tlbiel_pid(0, RIC_FLUSH_ALL);
 -}
 -
 -static inline void _tlbiel_kernel_broadcast(void)
 -{
 -	on_each_cpu(do_tlbiel_kernel, NULL, 1);
 -	if (tlbie_capable) {
 -		/*
 -		 * Coherent accelerators don't refcount kernel memory mappings,
 -		 * so have to always issue a tlbie for them. This is quite a
 -		 * slow path anyway.
 -		 */
 -		_tlbie_pid(0, RIC_FLUSH_ALL);
 -	}
 -}
 -
 -/*
 - * If kernel TLBIs ever become local rather than global, then
 - * drivers/misc/ocxl/link.c:ocxl_link_add_pe will need some work, as it
 - * assumes kernel TLBIs are global.
 - */
  void radix__flush_tlb_kernel_range(unsigned long start, unsigned long end)
  {
++<<<<<<< HEAD
 +	_tlbie_pid(0, RIC_FLUSH_ALL);
++=======
+ 	if (!mmu_has_feature(MMU_FTR_GTSE)) {
+ 		unsigned long tgt = H_RPTI_TARGET_CMMU | H_RPTI_TARGET_NMMU;
+ 		unsigned long type = H_RPTI_TYPE_TLB | H_RPTI_TYPE_PWC |
+ 				     H_RPTI_TYPE_PRT;
+ 
+ 		pseries_rpt_invalidate(0, tgt, type, H_RPTI_PAGE_ALL,
+ 				       start, end);
+ 	} else if (cputlb_use_tlbie())
+ 		_tlbie_pid(0, RIC_FLUSH_ALL);
+ 	else
+ 		_tlbiel_kernel_broadcast();
++>>>>>>> dd3d9aa5589c (powerpc/mm/book3s64/radix: Off-load TLB invalidations to host when !GTSE)
  }
  EXPORT_SYMBOL(radix__flush_tlb_kernel_range);
  
@@@ -1083,8 -1167,23 +1171,28 @@@ void radix__flush_tlb_collapsed_pmd(str
  			exit_flush_lazy_tlbs(mm);
  			goto local;
  		}
++<<<<<<< HEAD
 +		_tlbie_va_range(addr, end, pid, PAGE_SIZE, mmu_virtual_psize, true);
 +		goto local;
++=======
+ 		if (!mmu_has_feature(MMU_FTR_GTSE)) {
+ 			unsigned long tgt, type, pg_sizes;
+ 
+ 			tgt = H_RPTI_TARGET_CMMU;
+ 			type = H_RPTI_TYPE_TLB | H_RPTI_TYPE_PWC |
+ 			       H_RPTI_TYPE_PRT;
+ 			pg_sizes = psize_to_rpti_pgsize(mmu_virtual_psize);
+ 
+ 			if (atomic_read(&mm->context.copros) > 0)
+ 				tgt |= H_RPTI_TARGET_NMMU;
+ 			pseries_rpt_invalidate(pid, tgt, type, pg_sizes,
+ 					       addr, end);
+ 		} else if (cputlb_use_tlbie())
+ 			_tlbie_va_range(addr, end, pid, PAGE_SIZE, mmu_virtual_psize, true);
+ 		else
+ 			_tlbiel_va_range_multicast(mm,
+ 					addr, end, pid, PAGE_SIZE, mmu_virtual_psize, true);
++>>>>>>> dd3d9aa5589c (powerpc/mm/book3s64/radix: Off-load TLB invalidations to host when !GTSE)
  	} else {
  local:
  		_tlbiel_va_range(addr, end, pid, PAGE_SIZE, mmu_virtual_psize, true);
diff --git a/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h b/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h
index 671316f9e95d..ac05f4edce29 100644
--- a/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h
+++ b/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h
@@ -2,10 +2,25 @@
 #ifndef _ASM_POWERPC_TLBFLUSH_RADIX_H
 #define _ASM_POWERPC_TLBFLUSH_RADIX_H
 
+#include <asm/hvcall.h>
+
 struct vm_area_struct;
 struct mm_struct;
 struct mmu_gather;
 
+static inline u64 psize_to_rpti_pgsize(unsigned long psize)
+{
+	if (psize == MMU_PAGE_4K)
+		return H_RPTI_PAGE_4K;
+	if (psize == MMU_PAGE_64K)
+		return H_RPTI_PAGE_64K;
+	if (psize == MMU_PAGE_2M)
+		return H_RPTI_PAGE_2M;
+	if (psize == MMU_PAGE_1G)
+		return H_RPTI_PAGE_1G;
+	return H_RPTI_PAGE_ALL;
+}
+
 static inline int mmu_get_ap(int psize)
 {
 	return mmu_psize_defs[psize].ap;
diff --git a/arch/powerpc/include/asm/hvcall.h b/arch/powerpc/include/asm/hvcall.h
index 455e11aed516..71023fe41681 100644
--- a/arch/powerpc/include/asm/hvcall.h
+++ b/arch/powerpc/include/asm/hvcall.h
@@ -305,7 +305,8 @@
 #define H_SCM_UNBIND_ALL        0x3FC
 #define H_SCM_HEALTH            0x400
 #define H_SCM_PERFORMANCE_STATS 0x418
-#define MAX_HCALL_OPCODE	H_SCM_PERFORMANCE_STATS
+#define H_RPT_INVALIDATE	0x448
+#define MAX_HCALL_OPCODE	H_RPT_INVALIDATE
 
 /* Scope args for H_SCM_UNBIND_ALL */
 #define H_UNBIND_SCOPE_ALL (0x1)
@@ -391,6 +392,37 @@
 #define PROC_TABLE_RADIX	0x04
 #define PROC_TABLE_GTSE		0x01
 
+/*
+ * Defines for
+ * H_RPT_INVALIDATE - Invalidate RPT translation lookaside information.
+ */
+
+/* Type of translation to invalidate (type) */
+#define H_RPTI_TYPE_NESTED	0x0001	/* Invalidate nested guest partition-scope */
+#define H_RPTI_TYPE_TLB		0x0002	/* Invalidate TLB */
+#define H_RPTI_TYPE_PWC		0x0004	/* Invalidate Page Walk Cache */
+/* Invalidate Process Table Entries if H_RPTI_TYPE_NESTED is clear */
+#define H_RPTI_TYPE_PRT		0x0008
+/* Invalidate Partition Table Entries if H_RPTI_TYPE_NESTED is set */
+#define H_RPTI_TYPE_PAT		0x0008
+#define H_RPTI_TYPE_ALL		(H_RPTI_TYPE_TLB | H_RPTI_TYPE_PWC | \
+				 H_RPTI_TYPE_PRT)
+#define H_RPTI_TYPE_NESTED_ALL	(H_RPTI_TYPE_TLB | H_RPTI_TYPE_PWC | \
+				 H_RPTI_TYPE_PAT)
+
+/* Invalidation targets (target) */
+#define H_RPTI_TARGET_CMMU		0x01 /* All virtual processors in the partition */
+#define H_RPTI_TARGET_CMMU_LOCAL	0x02 /* Current virtual processor */
+/* All nest/accelerator agents in use by the partition */
+#define H_RPTI_TARGET_NMMU		0x04
+
+/* Page size mask (page sizes) */
+#define H_RPTI_PAGE_4K	0x01
+#define H_RPTI_PAGE_64K	0x02
+#define H_RPTI_PAGE_2M	0x04
+#define H_RPTI_PAGE_1G	0x08
+#define H_RPTI_PAGE_ALL (-1UL)
+
 #ifndef __ASSEMBLY__
 #include <linux/types.h>
 
* Unmerged path arch/powerpc/include/asm/plpar_wrappers.h
* Unmerged path arch/powerpc/mm/book3s64/radix_tlb.c
