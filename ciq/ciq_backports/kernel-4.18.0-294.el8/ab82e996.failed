mptcp: hold mptcp socket before calling tcp_done

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Florian Westphal <fw@strlen.de>
commit ab82e996a1fa1b9ae514fa357d9ce8df62321157
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ab82e996.failed

When processing options from tcp reset path its possible that
tcp_done(ssk) drops the last reference on the mptcp socket which
results in use-after-free.

	Reviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit ab82e996a1fa1b9ae514fa357d9ce8df62321157)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/subflow.c
diff --cc net/mptcp/subflow.c
index 8dfa18e07548,73e66a406d99..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -236,6 -308,24 +236,27 @@@ static bool subflow_thmac_valid(struct 
  	return thmac == subflow->thmac;
  }
  
++<<<<<<< HEAD
++=======
+ void mptcp_subflow_reset(struct sock *ssk)
+ {
+ 	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);
+ 	struct sock *sk = subflow->conn;
+ 
+ 	/* must hold: tcp_done() could drop last reference on parent */
+ 	sock_hold(sk);
+ 
+ 	tcp_set_state(ssk, TCP_CLOSE);
+ 	tcp_send_active_reset(ssk, GFP_ATOMIC);
+ 	tcp_done(ssk);
+ 	if (!test_and_set_bit(MPTCP_WORK_CLOSE_SUBFLOW, &mptcp_sk(sk)->flags) &&
+ 	    schedule_work(&mptcp_sk(sk)->work))
+ 		return; /* worker will put sk for us */
+ 
+ 	sock_put(sk);
+ }
+ 
++>>>>>>> ab82e996a1fa (mptcp: hold mptcp socket before calling tcp_done)
  static void subflow_finish_connect(struct sock *sk, const struct sk_buff *skb)
  {
  	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);
* Unmerged path net/mptcp/subflow.c
