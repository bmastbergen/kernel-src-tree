mm, compaction: rework compact_should_abort as compact_check_resched

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mel Gorman <mgorman@techsingularity.net>
commit cb810ad294d3c3a454e51b12fbb483bbb7096b98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cb810ad2.failed

With incremental changes, compact_should_abort no longer makes any
documented sense.  Rename to compact_check_resched and update the
associated comments.  There is no benefit other than reducing redundant
code and making the intent slightly clearer.  It could potentially be
merged with earlier patches but it just makes the review slightly
harder.

Link: http://lkml.kernel.org/r/20190118175136.31341-17-mgorman@techsingularity.net
	Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Dan Carpenter <dan.carpenter@oracle.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: YueHaibing <yuehaibing@huawei.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit cb810ad294d3c3a454e51b12fbb483bbb7096b98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/compaction.c
diff --cc mm/compaction.c
index 79db11f23bf2,68e3c214bcbd..000000000000
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@@ -391,37 -447,7 +406,41 @@@ static bool compact_unlock_should_abort
  		return true;
  	}
  
++<<<<<<< HEAD
 +	if (need_resched()) {
 +		if (cc->mode == MIGRATE_ASYNC) {
 +			cc->contended = true;
 +			return true;
 +		}
 +		cond_resched();
 +	}
 +
 +	return false;
 +}
 +
 +/*
 + * Aside from avoiding lock contention, compaction also periodically checks
 + * need_resched() and either schedules in sync compaction or aborts async
 + * compaction. This is similar to what compact_unlock_should_abort() does, but
 + * is used where no lock is concerned.
 + *
 + * Returns false when no scheduling was needed, or sync compaction scheduled.
 + * Returns true when async compaction should abort.
 + */
 +static inline bool compact_should_abort(struct compact_control *cc)
 +{
 +	/* async compaction aborts if contended */
 +	if (need_resched()) {
 +		if (cc->mode == MIGRATE_ASYNC) {
 +			cc->contended = true;
 +			return true;
 +		}
 +
 +		cond_resched();
 +	}
++=======
+ 	compact_check_resched(cc);
++>>>>>>> cb810ad294d3 (mm, compaction: rework compact_should_abort as compact_check_resched)
  
  	return false;
  }
* Unmerged path mm/compaction.c
