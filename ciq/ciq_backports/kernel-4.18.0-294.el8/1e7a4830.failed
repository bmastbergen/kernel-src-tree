KVM: VMX: Rename "__find_msr_index" to "__vmx_find_uret_msr"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 1e7a483037e8fa884c688f2213c8af10f2e8e96a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1e7a4830.failed

Rename "__find_msr_index" to scope it to VMX, associate it with
guest_uret_msrs, and to avoid conflating "MSR's ECX index" with "MSR's
array index".  Similarly, don't use "slot" in the name so as to avoid
colliding the common x86's half of "user_return_msrs" (the slot in
kvm_user_return_msrs is not the same slot in guest_uret_msrs).

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200923180409.32255-9-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 1e7a483037e8fa884c688f2213c8af10f2e8e96a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 985a4bfb7517,ae3c01cde79d..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -625,9 -625,9 +625,9 @@@ struct shared_msr_entry *find_msr_entry
  {
  	int i;
  
- 	i = __find_msr_index(vmx, msr);
+ 	i = __vmx_find_uret_msr(vmx, msr);
  	if (i >= 0)
 -		return &vmx->guest_uret_msrs[i];
 +		return &vmx->guest_msrs[i];
  	return NULL;
  }
  
@@@ -1644,29 -1637,29 +1644,45 @@@ static void setup_msrs(struct vcpu_vmx 
  	 * when EFER.SCE is set.
  	 */
  	if (is_long_mode(&vmx->vcpu) && (vmx->vcpu.arch.efer & EFER_SCE)) {
- 		index = __find_msr_index(vmx, MSR_STAR);
+ 		index = __vmx_find_uret_msr(vmx, MSR_STAR);
  		if (index >= 0)
++<<<<<<< HEAD
 +			move_msr_up(vmx, index, save_nmsrs++);
 +		index = __find_msr_index(vmx, MSR_LSTAR);
 +		if (index >= 0)
 +			move_msr_up(vmx, index, save_nmsrs++);
 +		index = __find_msr_index(vmx, MSR_SYSCALL_MASK);
++=======
+ 			move_msr_up(vmx, index, nr_active_uret_msrs++);
+ 		index = __vmx_find_uret_msr(vmx, MSR_LSTAR);
+ 		if (index >= 0)
+ 			move_msr_up(vmx, index, nr_active_uret_msrs++);
+ 		index = __vmx_find_uret_msr(vmx, MSR_SYSCALL_MASK);
++>>>>>>> 1e7a483037e8 (KVM: VMX: Rename "__find_msr_index" to "__vmx_find_uret_msr")
  		if (index >= 0)
 -			move_msr_up(vmx, index, nr_active_uret_msrs++);
 +			move_msr_up(vmx, index, save_nmsrs++);
  	}
  #endif
- 	index = __find_msr_index(vmx, MSR_EFER);
+ 	index = __vmx_find_uret_msr(vmx, MSR_EFER);
  	if (index >= 0 && update_transition_efer(vmx, index))
++<<<<<<< HEAD
 +		move_msr_up(vmx, index, save_nmsrs++);
 +	index = __find_msr_index(vmx, MSR_TSC_AUX);
 +	if (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))
 +		move_msr_up(vmx, index, save_nmsrs++);
 +	index = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);
++=======
+ 		move_msr_up(vmx, index, nr_active_uret_msrs++);
+ 	index = __vmx_find_uret_msr(vmx, MSR_TSC_AUX);
+ 	if (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))
+ 		move_msr_up(vmx, index, nr_active_uret_msrs++);
+ 	index = __vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);
++>>>>>>> 1e7a483037e8 (KVM: VMX: Rename "__find_msr_index" to "__vmx_find_uret_msr")
  	if (index >= 0)
 -		move_msr_up(vmx, index, nr_active_uret_msrs++);
 +		move_msr_up(vmx, index, save_nmsrs++);
  
 -	vmx->nr_active_uret_msrs = nr_active_uret_msrs;
 -	vmx->guest_uret_msrs_loaded = false;
 +	vmx->save_nmsrs = save_nmsrs;
 +	vmx->guest_msrs_ready = false;
  
  	if (cpu_has_vmx_msr_bitmap())
  		vmx_update_msr_bitmap(&vmx->vcpu);
* Unmerged path arch/x86/kvm/vmx/vmx.c
