net-sysfs: take the rtnl lock when accessing xps_rxqs_map and num_tc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Antoine Tenart <atenart@kernel.org>
commit 4ae2bb81649dc03dfc95875f02126b14b773f7ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4ae2bb81.failed

Accesses to dev->xps_rxqs_map (when using dev->num_tc) should be
protected by the rtnl lock, like we do for netif_set_xps_queue. I didn't
see an actual bug being triggered, but let's be safe here and take the
rtnl lock while accessing the map in sysfs.

Fixes: 8af2c06ff4b1 ("net-sysfs: Add interface for Rx queue(s) map per Tx queue")
	Signed-off-by: Antoine Tenart <atenart@kernel.org>
	Reviewed-by: Alexander Duyck <alexanderduyck@fb.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 4ae2bb81649dc03dfc95875f02126b14b773f7ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/net-sysfs.c
diff --cc net/core/net-sysfs.c
index 24e8d9a116b2,daf502c13d6d..000000000000
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@@ -1353,13 -1442,16 +1356,23 @@@ static ssize_t xps_rxqs_show(struct net
  	if (dev->num_tc) {
  		num_tc = dev->num_tc;
  		tc = netdev_txq_to_tc(dev, index);
- 		if (tc < 0)
- 			return -EINVAL;
+ 		if (tc < 0) {
+ 			ret = -EINVAL;
+ 			goto err_rtnl_unlock;
+ 		}
  	}
++<<<<<<< HEAD
 +	mask = kcalloc(BITS_TO_LONGS(dev->num_rx_queues), sizeof(long),
 +		       GFP_KERNEL);
 +	if (!mask)
 +		return -ENOMEM;
++=======
+ 	mask = bitmap_zalloc(dev->num_rx_queues, GFP_KERNEL);
+ 	if (!mask) {
+ 		ret = -ENOMEM;
+ 		goto err_rtnl_unlock;
+ 	}
++>>>>>>> 4ae2bb81649d (net-sysfs: take the rtnl lock when accessing xps_rxqs_map and num_tc)
  
  	rcu_read_lock();
  	dev_maps = rcu_dereference(dev->xps_rxqs_map);
@@@ -1385,10 -1477,16 +1398,16 @@@
  out_no_maps:
  	rcu_read_unlock();
  
+ 	rtnl_unlock();
+ 
  	len = bitmap_print_to_pagebuf(false, buf, mask, dev->num_rx_queues);
 -	bitmap_free(mask);
 +	kfree(mask);
  
  	return len < PAGE_SIZE ? len : -EINVAL;
+ 
+ err_rtnl_unlock:
+ 	rtnl_unlock();
+ 	return ret;
  }
  
  static ssize_t xps_rxqs_store(struct netdev_queue *queue, const char *buf,
* Unmerged path net/core/net-sysfs.c
