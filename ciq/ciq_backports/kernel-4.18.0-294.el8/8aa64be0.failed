RDMA/core: Fix unsafe linked list traversal after failing to allocate CQ

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Xi Wang <wangxi11@huawei.com>
commit 8aa64be019567c4f90d45c5082a4b6f22e182d00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8aa64be0.failed

It's not safe to access the next CQ in list_for_each_entry() after
invoking ib_free_cq(), because the CQ has already been freed in current
iteration.  It should be replaced by list_for_each_entry_safe().

Fixes: c7ff819aefea ("RDMA/core: Introduce shared CQ pool API")
Link: https://lore.kernel.org/r/1598963935-32335-1-git-send-email-liweihang@huawei.com
	Signed-off-by: Xi Wang <wangxi11@huawei.com>
	Signed-off-by: Weihang Li <liweihang@huawei.com>
	Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 8aa64be019567c4f90d45c5082a4b6f22e182d00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cq.c
diff --cc drivers/infiniband/core/cq.c
index 6bb62d04030a,a92fc3f90bb5..000000000000
--- a/drivers/infiniband/core/cq.c
+++ b/drivers/infiniband/core/cq.c
@@@ -342,3 -349,169 +342,172 @@@ void ib_free_cq_user(struct ib_cq *cq, 
  	kfree(cq);
  }
  EXPORT_SYMBOL(ib_free_cq_user);
++<<<<<<< HEAD
++=======
+ 
+ void ib_cq_pool_init(struct ib_device *dev)
+ {
+ 	unsigned int i;
+ 
+ 	spin_lock_init(&dev->cq_pools_lock);
+ 	for (i = 0; i < ARRAY_SIZE(dev->cq_pools); i++)
+ 		INIT_LIST_HEAD(&dev->cq_pools[i]);
+ }
+ 
+ void ib_cq_pool_destroy(struct ib_device *dev)
+ {
+ 	struct ib_cq *cq, *n;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dev->cq_pools); i++) {
+ 		list_for_each_entry_safe(cq, n, &dev->cq_pools[i],
+ 					 pool_entry) {
+ 			WARN_ON(cq->cqe_used);
+ 			cq->shared = false;
+ 			ib_free_cq(cq);
+ 		}
+ 	}
+ }
+ 
+ static int ib_alloc_cqs(struct ib_device *dev, unsigned int nr_cqes,
+ 			enum ib_poll_context poll_ctx)
+ {
+ 	LIST_HEAD(tmp_list);
+ 	unsigned int nr_cqs, i;
+ 	struct ib_cq *cq, *n;
+ 	int ret;
+ 
+ 	if (poll_ctx > IB_POLL_LAST_POOL_TYPE) {
+ 		WARN_ON_ONCE(poll_ctx > IB_POLL_LAST_POOL_TYPE);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * Allocate at least as many CQEs as requested, and otherwise
+ 	 * a reasonable batch size so that we can share CQs between
+ 	 * multiple users instead of allocating a larger number of CQs.
+ 	 */
+ 	nr_cqes = min_t(unsigned int, dev->attrs.max_cqe,
+ 			max(nr_cqes, IB_MAX_SHARED_CQ_SZ));
+ 	nr_cqs = min_t(unsigned int, dev->num_comp_vectors, num_online_cpus());
+ 	for (i = 0; i < nr_cqs; i++) {
+ 		cq = ib_alloc_cq(dev, NULL, nr_cqes, i, poll_ctx);
+ 		if (IS_ERR(cq)) {
+ 			ret = PTR_ERR(cq);
+ 			goto out_free_cqs;
+ 		}
+ 		cq->shared = true;
+ 		list_add_tail(&cq->pool_entry, &tmp_list);
+ 	}
+ 
+ 	spin_lock_irq(&dev->cq_pools_lock);
+ 	list_splice(&tmp_list, &dev->cq_pools[poll_ctx]);
+ 	spin_unlock_irq(&dev->cq_pools_lock);
+ 
+ 	return 0;
+ 
+ out_free_cqs:
+ 	list_for_each_entry_safe(cq, n, &tmp_list, pool_entry) {
+ 		cq->shared = false;
+ 		ib_free_cq(cq);
+ 	}
+ 	return ret;
+ }
+ 
+ /**
+  * ib_cq_pool_get() - Find the least used completion queue that matches
+  *   a given cpu hint (or least used for wild card affinity) and fits
+  *   nr_cqe.
+  * @dev: rdma device
+  * @nr_cqe: number of needed cqe entries
+  * @comp_vector_hint: completion vector hint (-1) for the driver to assign
+  *   a comp vector based on internal counter
+  * @poll_ctx: cq polling context
+  *
+  * Finds a cq that satisfies @comp_vector_hint and @nr_cqe requirements and
+  * claim entries in it for us.  In case there is no available cq, allocate
+  * a new cq with the requirements and add it to the device pool.
+  * IB_POLL_DIRECT cannot be used for shared cqs so it is not a valid value
+  * for @poll_ctx.
+  */
+ struct ib_cq *ib_cq_pool_get(struct ib_device *dev, unsigned int nr_cqe,
+ 			     int comp_vector_hint,
+ 			     enum ib_poll_context poll_ctx)
+ {
+ 	static unsigned int default_comp_vector;
+ 	unsigned int vector, num_comp_vectors;
+ 	struct ib_cq *cq, *found = NULL;
+ 	int ret;
+ 
+ 	if (poll_ctx > IB_POLL_LAST_POOL_TYPE) {
+ 		WARN_ON_ONCE(poll_ctx > IB_POLL_LAST_POOL_TYPE);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	num_comp_vectors =
+ 		min_t(unsigned int, dev->num_comp_vectors, num_online_cpus());
+ 	/* Project the affinty to the device completion vector range */
+ 	if (comp_vector_hint < 0) {
+ 		comp_vector_hint =
+ 			(READ_ONCE(default_comp_vector) + 1) % num_comp_vectors;
+ 		WRITE_ONCE(default_comp_vector, comp_vector_hint);
+ 	}
+ 	vector = comp_vector_hint % num_comp_vectors;
+ 
+ 	/*
+ 	 * Find the least used CQ with correct affinity and
+ 	 * enough free CQ entries
+ 	 */
+ 	while (!found) {
+ 		spin_lock_irq(&dev->cq_pools_lock);
+ 		list_for_each_entry(cq, &dev->cq_pools[poll_ctx],
+ 				    pool_entry) {
+ 			/*
+ 			 * Check to see if we have found a CQ with the
+ 			 * correct completion vector
+ 			 */
+ 			if (vector != cq->comp_vector)
+ 				continue;
+ 			if (cq->cqe_used + nr_cqe > cq->cqe)
+ 				continue;
+ 			found = cq;
+ 			break;
+ 		}
+ 
+ 		if (found) {
+ 			found->cqe_used += nr_cqe;
+ 			spin_unlock_irq(&dev->cq_pools_lock);
+ 
+ 			return found;
+ 		}
+ 		spin_unlock_irq(&dev->cq_pools_lock);
+ 
+ 		/*
+ 		 * Didn't find a match or ran out of CQs in the device
+ 		 * pool, allocate a new array of CQs.
+ 		 */
+ 		ret = ib_alloc_cqs(dev, nr_cqe, poll_ctx);
+ 		if (ret)
+ 			return ERR_PTR(ret);
+ 	}
+ 
+ 	return found;
+ }
+ EXPORT_SYMBOL(ib_cq_pool_get);
+ 
+ /**
+  * ib_cq_pool_put - Return a CQ taken from a shared pool.
+  * @cq: The CQ to return.
+  * @nr_cqe: The max number of cqes that the user had requested.
+  */
+ void ib_cq_pool_put(struct ib_cq *cq, unsigned int nr_cqe)
+ {
+ 	if (WARN_ON_ONCE(nr_cqe > cq->cqe_used))
+ 		return;
+ 
+ 	spin_lock_irq(&cq->device->cq_pools_lock);
+ 	cq->cqe_used -= nr_cqe;
+ 	spin_unlock_irq(&cq->device->cq_pools_lock);
+ }
+ EXPORT_SYMBOL(ib_cq_pool_put);
++>>>>>>> 8aa64be01956 (RDMA/core: Fix unsafe linked list traversal after failing to allocate CQ)
* Unmerged path drivers/infiniband/core/cq.c
