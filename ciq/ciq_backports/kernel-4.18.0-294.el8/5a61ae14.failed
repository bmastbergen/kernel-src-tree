gfs2: Make sure we don't miss any delayed withdraws

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 5a61ae1402f15276ee4e003e198aab816958ca69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5a61ae14.failed

Commit ca399c96e96e changes gfs2_log_flush to not withdraw the
filesystem while holding the log flush lock, but it fails to check if
the filesystem needs to be withdrawn once the log flush lock has been
released.  Likewise, commit f05b86db314d depends on gfs2_log_flush to
trigger for delayed withdraws.  Add that and clean up the code flow
somewhat.

In gfs2_put_super, add a check for delayed withdraws that have been
missed to prevent these kinds of bugs in the future.

Fixes: ca399c96e96e ("gfs2: flesh out delayed withdraw for gfs2_log_flush")
Fixes: f05b86db314d ("gfs2: Prepare to withdraw as soon as an IO error occurs in log write")
	Cc: stable@vger.kernel.org # v5.7+: 462582b99b607: gfs2: add some much needed cleanup for log flushes that fail
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 5a61ae1402f15276ee4e003e198aab816958ca69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
diff --cc fs/gfs2/log.c
index 031e207360df,93032feb5159..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -928,14 -1016,9 +926,14 @@@ void gfs2_log_flush(struct gfs2_sbd *sd
  
  	if (!(flags & GFS2_LOG_HEAD_FLUSH_NORMAL)) {
  		if (!sdp->sd_log_idle) {
 -			empty_ail1_list(sdp);
 +			for (;;) {
 +				gfs2_ail1_start(sdp);
 +				gfs2_ail1_wait(sdp);
 +				if (gfs2_ail1_empty(sdp, 0))
 +					break;
 +			}
  			if (gfs2_withdrawn(sdp))
- 				goto out;
+ 				goto out_withdraw;
  			atomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */
  			trace_gfs2_log_blocks(sdp, -1);
  			log_write_header(sdp, flags);
@@@ -948,26 -1031,30 +946,54 @@@
  			atomic_set(&sdp->sd_freeze_state, SFS_FROZEN);
  	}
  
++<<<<<<< HEAD
 +out:
 +	if (gfs2_withdrawn(sdp)) {
 +		/**
 +		 * If the tr_list is empty, we're withdrawing during a log
 +		 * flush that targets a transaction, but the transaction was
 +		 * never queued onto any of the ail lists. Here we add it to
 +		 * ail1 just so that ail_drain() will find and free it.
 +		 */
 +		spin_lock(&sdp->sd_ail_lock);
 +		if (tr && list_empty(&tr->tr_list))
 +			list_add(&tr->tr_list, &sdp->sd_ail1_list);
 +		spin_unlock(&sdp->sd_ail_lock);
 +		ail_drain(sdp); /* frees all transactions */
 +		tr = NULL;
 +	}
 +
++=======
+ out_end:
++>>>>>>> 5a61ae1402f1 (gfs2: Make sure we don't miss any delayed withdraws)
  	trace_gfs2_log_flush(sdp, 0, flags);
+ out:
  	up_write(&sdp->sd_log_flush_lock);
++<<<<<<< HEAD
 +
 +	kfree(tr);
++=======
+ 	gfs2_trans_free(sdp, tr);
+ 	if (gfs2_withdrawing(sdp))
+ 		gfs2_withdraw(sdp);
+ 	return;
+ 
+ out_withdraw:
+ 	trans_drain(tr);
+ 	/**
+ 	 * If the tr_list is empty, we're withdrawing during a log
+ 	 * flush that targets a transaction, but the transaction was
+ 	 * never queued onto any of the ail lists. Here we add it to
+ 	 * ail1 just so that ail_drain() will find and free it.
+ 	 */
+ 	spin_lock(&sdp->sd_ail_lock);
+ 	if (tr && list_empty(&tr->tr_list))
+ 		list_add(&tr->tr_list, &sdp->sd_ail1_list);
+ 	spin_unlock(&sdp->sd_ail_lock);
+ 	ail_drain(sdp); /* frees all transactions */
+ 	tr = NULL;
+ 	goto out_end;
++>>>>>>> 5a61ae1402f1 (gfs2: Make sure we don't miss any delayed withdraws)
  }
  
  /**
* Unmerged path fs/gfs2/log.c
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 1e74c3daebf7..778325ec8af6 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -701,6 +701,8 @@ static void gfs2_put_super(struct super_block *sb)
 		if (error)
 			gfs2_io_error(sdp);
 	}
+	WARN_ON(gfs2_withdrawing(sdp));
+
 	/*  At this point, we're through modifying the disk  */
 
 	/*  Release stuff  */
diff --git a/fs/gfs2/util.h b/fs/gfs2/util.h
index 004837a6a593..ea01c860102c 100644
--- a/fs/gfs2/util.h
+++ b/fs/gfs2/util.h
@@ -207,6 +207,16 @@ static inline bool gfs2_withdrawn(struct gfs2_sbd *sdp)
 		test_bit(SDF_WITHDRAWING, &sdp->sd_flags);
 }
 
+/**
+ * gfs2_withdrawing - check if a withdraw is pending
+ * @sdp: the superblock
+ */
+static inline bool gfs2_withdrawing(struct gfs2_sbd *sdp)
+{
+	return test_bit(SDF_WITHDRAWING, &sdp->sd_flags) &&
+	       !test_bit(SDF_WITHDRAWN, &sdp->sd_flags);
+}
+
 #define gfs2_tune_get(sdp, field) \
 gfs2_tune_get_i(&(sdp)->sd_tune, &(sdp)->sd_tune.field)
 
