vfs: subtype handling moved to fuse

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit c7eb6869632a5d33b41d0a00d683b8395392b7ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c7eb6869.failed

The unused vfs code can be removed.  Don't pass empty subtype (same as if
->parse callback isn't called).

The bits that are left involve determining whether it's permitted to split the
filesystem type string passed in to mount(2).  Consequently, this means that we
cannot get rid of the FS_HAS_SUBTYPE flag unless we define that a type string
with a dot in it always indicates a subtype specification.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit c7eb6869632a5d33b41d0a00d683b8395392b7ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs_context.c
#	fs/fuse/inode.c
#	include/linux/fs_context.h
diff --cc fs/fuse/inode.c
index 10b75246113a,2183967261a4..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -452,111 -463,109 +452,126 @@@ enum 
  	OPT_ERR
  };
  
++<<<<<<< HEAD
 +static const match_table_t tokens = {
 +	{OPT_FD,			"fd=%u"},
 +	{OPT_ROOTMODE,			"rootmode=%o"},
 +	{OPT_USER_ID,			"user_id=%u"},
 +	{OPT_GROUP_ID,			"group_id=%u"},
 +	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
 +	{OPT_ALLOW_OTHER,		"allow_other"},
 +	{OPT_MAX_READ,			"max_read=%u"},
 +	{OPT_BLKSIZE,			"blksize=%u"},
 +	{OPT_ERR,			NULL}
++=======
+ static const struct fs_parameter_spec fuse_param_specs[] = {
+ 	fsparam_string	("source",		OPT_SOURCE),
+ 	fsparam_u32	("fd",			OPT_FD),
+ 	fsparam_u32oct	("rootmode",		OPT_ROOTMODE),
+ 	fsparam_u32	("user_id",		OPT_USER_ID),
+ 	fsparam_u32	("group_id",		OPT_GROUP_ID),
+ 	fsparam_flag	("default_permissions",	OPT_DEFAULT_PERMISSIONS),
+ 	fsparam_flag	("allow_other",		OPT_ALLOW_OTHER),
+ 	fsparam_u32	("max_read",		OPT_MAX_READ),
+ 	fsparam_u32	("blksize",		OPT_BLKSIZE),
+ 	fsparam_string	("subtype",		OPT_SUBTYPE),
+ 	{}
++>>>>>>> c7eb6869632a (vfs: subtype handling moved to fuse)
  };
  
 -static const struct fs_parameter_description fuse_fs_parameters = {
 -	.name		= "fuse",
 -	.specs		= fuse_param_specs,
 -};
 -
 -static int fuse_parse_param(struct fs_context *fc, struct fs_parameter *param)
 +static int fuse_match_uint(substring_t *s, unsigned int *res)
  {
 -	struct fs_parse_result result;
 -	struct fuse_fs_context *ctx = fc->fs_private;
 -	int opt;
 -
 -	opt = fs_parse(fc, &fuse_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case OPT_SOURCE:
 -		if (fc->source)
 -			return invalf(fc, "fuse: Multiple sources specified");
 -		fc->source = param->string;
 -		param->string = NULL;
 -		break;
 -
 -	case OPT_SUBTYPE:
 -		if (ctx->subtype)
 -			return invalf(fc, "fuse: Multiple subtypes specified");
 -		ctx->subtype = param->string;
 -		param->string = NULL;
 -		return 0;
 -
 -	case OPT_FD:
 -		ctx->fd = result.uint_32;
 -		ctx->fd_present = 1;
 -		break;
 -
 -	case OPT_ROOTMODE:
 -		if (!fuse_valid_type(result.uint_32))
 -			return invalf(fc, "fuse: Invalid rootmode");
 -		ctx->rootmode = result.uint_32;
 -		ctx->rootmode_present = 1;
 -		break;
 -
 -	case OPT_USER_ID:
 -		ctx->user_id = make_kuid(fc->user_ns, result.uint_32);
 -		if (!uid_valid(ctx->user_id))
 -			return invalf(fc, "fuse: Invalid user_id");
 -		ctx->user_id_present = 1;
 -		break;
 -
 -	case OPT_GROUP_ID:
 -		ctx->group_id = make_kgid(fc->user_ns, result.uint_32);
 -		if (!gid_valid(ctx->group_id))
 -			return invalf(fc, "fuse: Invalid group_id");
 -		ctx->group_id_present = 1;
 -		break;
 -
 -	case OPT_DEFAULT_PERMISSIONS:
 -		ctx->default_permissions = 1;
 -		break;
 -
 -	case OPT_ALLOW_OTHER:
 -		ctx->allow_other = 1;
 -		break;
 -
 -	case OPT_MAX_READ:
 -		ctx->max_read = result.uint_32;
 -		break;
 -
 -	case OPT_BLKSIZE:
 -		if (!ctx->is_bdev)
 -			return invalf(fc, "fuse: blksize only supported for fuseblk");
 -		ctx->blksize = result.uint_32;
 -		break;
 -
 -	default:
 -		return -EINVAL;
 +	int err = -ENOMEM;
 +	char *buf = match_strdup(s);
 +	if (buf) {
 +		err = kstrtouint(buf, 10, res);
 +		kfree(buf);
  	}
 -
 -	return 0;
 +	return err;
  }
  
 -static void fuse_free_fc(struct fs_context *fc)
 +static int parse_fuse_opt(char *opt, struct fuse_fs_context *d, int is_bdev,
 +			  struct user_namespace *user_ns)
  {
 -	struct fuse_fs_context *ctx = fc->fs_private;
 -
 -	if (ctx) {
 -		kfree(ctx->subtype);
 -		kfree(ctx);
 +	char *p;
 +	memset(d, 0, sizeof(struct fuse_fs_context));
 +	d->max_read = ~0;
 +	d->blksize = FUSE_DEFAULT_BLKSIZE;
 +
 +	while ((p = strsep(&opt, ",")) != NULL) {
 +		int token;
 +		int value;
 +		unsigned uv;
 +		substring_t args[MAX_OPT_ARGS];
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case OPT_FD:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->fd = value;
 +			d->fd_present = 1;
 +			break;
 +
 +		case OPT_ROOTMODE:
 +			if (match_octal(&args[0], &value))
 +				return 0;
 +			if (!fuse_valid_type(value))
 +				return 0;
 +			d->rootmode = value;
 +			d->rootmode_present = 1;
 +			break;
 +
 +		case OPT_USER_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->user_id = make_kuid(user_ns, uv);
 +			if (!uid_valid(d->user_id))
 +				return 0;
 +			d->user_id_present = 1;
 +			break;
 +
 +		case OPT_GROUP_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->group_id = make_kgid(user_ns, uv);
 +			if (!gid_valid(d->group_id))
 +				return 0;
 +			d->group_id_present = 1;
 +			break;
 +
 +		case OPT_DEFAULT_PERMISSIONS:
 +			d->default_permissions = 1;
 +			break;
 +
 +		case OPT_ALLOW_OTHER:
 +			d->allow_other = 1;
 +			break;
 +
 +		case OPT_MAX_READ:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->max_read = value;
 +			break;
 +
 +		case OPT_BLKSIZE:
 +			if (!is_bdev || match_int(&args[0], &value))
 +				return 0;
 +			d->blksize = value;
 +			break;
 +
 +		default:
 +			return 0;
 +		}
  	}
 +
 +	if (!d->fd_present || !d->rootmode_present ||
 +	    !d->user_id_present || !d->group_id_present)
 +		return 0;
 +
 +	return 1;
  }
  
  static int fuse_show_options(struct seq_file *m, struct dentry *root)
* Unmerged path fs/fs_context.c
* Unmerged path include/linux/fs_context.h
* Unmerged path fs/fs_context.c
* Unmerged path fs/fuse/inode.c
diff --git a/fs/namespace.c b/fs/namespace.c
index 8454c0d888ea..3380ee6ce8d3 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -2578,8 +2578,6 @@ static int do_new_mount(struct path *path, const char *fstype, int sb_flags,
 				put_filesystem(type);
 				return -EINVAL;
 			}
-		} else {
-			subtype = "";
 		}
 	}
 
diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c
index 969f9c8fbdc0..e4d70c0dffe9 100644
--- a/fs/proc_namespace.c
+++ b/fs/proc_namespace.c
@@ -88,7 +88,7 @@ static inline void mangle(struct seq_file *m, const char *s)
 static void show_type(struct seq_file *m, struct super_block *sb)
 {
 	mangle(m, sb->s_type->name);
-	if (sb->s_subtype && sb->s_subtype[0]) {
+	if (sb->s_subtype) {
 		seq_putc(m, '.');
 		mangle(m, sb->s_subtype);
 	}
diff --git a/fs/super.c b/fs/super.c
index 308bc64e0894..a6e0426e2953 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -1263,11 +1263,6 @@ mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
 	BUG_ON(!sb);
 	WARN_ON(!sb->s_bdi);
 
-	if (fc->subtype && !sb->s_subtype) {
-		sb->s_subtype = fc->subtype;
-		fc->subtype = NULL;
-	}
-
 	/*
 	 * Write barrier is for super_cache_count(). We place it before setting
 	 * SB_BORN as the data dependency between the two functions is the
* Unmerged path include/linux/fs_context.h
