usb: roles: Provide the switch drivers handle to the switch in the API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit bce3052f0c165685a074e50136e4d341bcd59f4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/bce3052f.failed

The USB role callback functions had a parameter pointing to
the parent device (struct device) of the switch. The
assumption was that the switch parent is always the
controller. Firstly, that may not be true in every case, and
secondly, it prevents us from supporting devices that supply
multiple muxes.

Changing the first parameter of usb_role_switch_set_t and
usb_role_switch_get_t from struct device to struct
usb_role_switch.

	Cc: Peter Chen <Peter.Chen@nxp.com>
	Cc: Felipe Balbi <balbi@kernel.org>
	Cc: Chunfeng Yun <chunfeng.yun@mediatek.com>
	Cc: Bin Liu <b-liu@ti.com>
	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Link: https://lore.kernel.org/r/20200302135353.56659-6-heikki.krogerus@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit bce3052f0c165685a074e50136e4d341bcd59f4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/cdns3/core.c
#	drivers/usb/chipidea/core.c
#	drivers/usb/gadget/udc/tegra-xudc.c
#	drivers/usb/mtu3/mtu3_dr.c
#	drivers/usb/musb/mediatek.c
#	drivers/usb/roles/intel-xhci-usb-role-switch.c
diff --cc drivers/usb/chipidea/core.c
index 36c964cd40a3,ae0bdc036464..000000000000
--- a/drivers/usb/chipidea/core.c
+++ b/drivers/usb/chipidea/core.c
@@@ -600,6 -600,74 +600,77 @@@ static int ci_cable_notifier(struct not
  	return NOTIFY_DONE;
  }
  
++<<<<<<< HEAD
++=======
+ static enum usb_role ci_usb_role_switch_get(struct usb_role_switch *sw)
+ {
+ 	struct ci_hdrc *ci = usb_role_switch_get_drvdata(sw);
+ 	enum usb_role role;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&ci->lock, flags);
+ 	role = ci_role_to_usb_role(ci);
+ 	spin_unlock_irqrestore(&ci->lock, flags);
+ 
+ 	return role;
+ }
+ 
+ static int ci_usb_role_switch_set(struct usb_role_switch *sw,
+ 				  enum usb_role role)
+ {
+ 	struct ci_hdrc *ci = usb_role_switch_get_drvdata(sw);
+ 	struct ci_hdrc_cable *cable = NULL;
+ 	enum usb_role current_role = ci_role_to_usb_role(ci);
+ 	enum ci_role ci_role = usb_role_to_ci_role(role);
+ 	unsigned long flags;
+ 
+ 	if ((ci_role != CI_ROLE_END && !ci->roles[ci_role]) ||
+ 	    (current_role == role))
+ 		return 0;
+ 
+ 	pm_runtime_get_sync(ci->dev);
+ 	/* Stop current role */
+ 	spin_lock_irqsave(&ci->lock, flags);
+ 	if (current_role == USB_ROLE_DEVICE)
+ 		cable = &ci->platdata->vbus_extcon;
+ 	else if (current_role == USB_ROLE_HOST)
+ 		cable = &ci->platdata->id_extcon;
+ 
+ 	if (cable) {
+ 		cable->changed = true;
+ 		cable->connected = false;
+ 		ci_irq(ci->irq, ci);
+ 		spin_unlock_irqrestore(&ci->lock, flags);
+ 		if (ci->wq && role != USB_ROLE_NONE)
+ 			flush_workqueue(ci->wq);
+ 		spin_lock_irqsave(&ci->lock, flags);
+ 	}
+ 
+ 	cable = NULL;
+ 
+ 	/* Start target role */
+ 	if (role == USB_ROLE_DEVICE)
+ 		cable = &ci->platdata->vbus_extcon;
+ 	else if (role == USB_ROLE_HOST)
+ 		cable = &ci->platdata->id_extcon;
+ 
+ 	if (cable) {
+ 		cable->changed = true;
+ 		cable->connected = true;
+ 		ci_irq(ci->irq, ci);
+ 	}
+ 	spin_unlock_irqrestore(&ci->lock, flags);
+ 	pm_runtime_put_sync(ci->dev);
+ 
+ 	return 0;
+ }
+ 
+ static struct usb_role_switch_desc ci_role_switch = {
+ 	.set = ci_usb_role_switch_set,
+ 	.get = ci_usb_role_switch_get,
+ };
+ 
++>>>>>>> bce3052f0c16 (usb: roles: Provide the switch drivers handle to the switch in the API)
  static int ci_get_platdata(struct device *dev,
  		struct ci_hdrc_platform_data *platdata)
  {
@@@ -1050,6 -1118,16 +1121,19 @@@ static int ci_hdrc_probe(struct platfor
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (ci_role_switch.fwnode) {
+ 		ci_role_switch.driver_data = ci;
+ 		ci->role_switch = usb_role_switch_register(dev,
+ 					&ci_role_switch);
+ 		if (IS_ERR(ci->role_switch)) {
+ 			ret = PTR_ERR(ci->role_switch);
+ 			goto deinit_otg;
+ 		}
+ 	}
+ 
++>>>>>>> bce3052f0c16 (usb: roles: Provide the switch drivers handle to the switch in the API)
  	if (ci->roles[CI_ROLE_HOST] && ci->roles[CI_ROLE_GADGET]) {
  		if (ci->is_otg) {
  			ci->role = ci_otg_role(ci);
diff --cc drivers/usb/mtu3/mtu3_dr.c
index 5fcb71af875a,04f666e85731..000000000000
--- a/drivers/usb/mtu3/mtu3_dr.c
+++ b/drivers/usb/mtu3/mtu3_dr.c
@@@ -318,6 -320,48 +318,51 @@@ void ssusb_set_force_mode(struct ssusb_
  	mtu3_writel(ssusb->ippc_base, SSUSB_U2_CTRL(0), value);
  }
  
++<<<<<<< HEAD
++=======
+ static int ssusb_role_sw_set(struct usb_role_switch *sw, enum usb_role role)
+ {
+ 	struct ssusb_mtk *ssusb = usb_role_switch_get_drvdata(sw);
+ 	bool to_host = false;
+ 
+ 	if (role == USB_ROLE_HOST)
+ 		to_host = true;
+ 
+ 	if (to_host ^ ssusb->is_host)
+ 		ssusb_mode_switch(ssusb, to_host);
+ 
+ 	return 0;
+ }
+ 
+ static enum usb_role ssusb_role_sw_get(struct usb_role_switch *sw)
+ {
+ 	struct ssusb_mtk *ssusb = usb_role_switch_get_drvdata(sw);
+ 	enum usb_role role;
+ 
+ 	role = ssusb->is_host ? USB_ROLE_HOST : USB_ROLE_DEVICE;
+ 
+ 	return role;
+ }
+ 
+ static int ssusb_role_sw_register(struct otg_switch_mtk *otg_sx)
+ {
+ 	struct usb_role_switch_desc role_sx_desc = { 0 };
+ 	struct ssusb_mtk *ssusb =
+ 		container_of(otg_sx, struct ssusb_mtk, otg_switch);
+ 
+ 	if (!otg_sx->role_sw_used)
+ 		return 0;
+ 
+ 	role_sx_desc.set = ssusb_role_sw_set;
+ 	role_sx_desc.get = ssusb_role_sw_get;
+ 	role_sx_desc.fwnode = dev_fwnode(ssusb->dev);
+ 	role_sx_desc.driver_data = ssusb;
+ 	otg_sx->role_sw = usb_role_switch_register(ssusb->dev, &role_sx_desc);
+ 
+ 	return PTR_ERR_OR_ZERO(otg_sx->role_sw);
+ }
+ 
++>>>>>>> bce3052f0c16 (usb: roles: Provide the switch drivers handle to the switch in the API)
  int ssusb_otg_switch_init(struct ssusb_mtk *ssusb)
  {
  	struct otg_switch_mtk *otg_sx = &ssusb->otg_switch;
diff --cc drivers/usb/roles/intel-xhci-usb-role-switch.c
index 7325a84dd1c8,5c96e929acea..000000000000
--- a/drivers/usb/roles/intel-xhci-usb-role-switch.c
+++ b/drivers/usb/roles/intel-xhci-usb-role-switch.c
@@@ -35,8 -42,10 +35,9 @@@
  #define DRV_NAME			"intel_xhci_usb_sw"
  
  struct intel_xhci_usb_data {
+ 	struct device *dev;
  	struct usb_role_switch *role_sw;
  	void __iomem *base;
 -	bool enable_sw_switch;
  };
  
  static const struct software_node intel_xhci_usb_node = {
@@@ -61,9 -72,14 +63,9 @@@ static int intel_xhci_usb_set_role(stru
  		return -EIO;
  	}
  
- 	pm_runtime_get_sync(dev);
+ 	pm_runtime_get_sync(data->dev);
  
 -	/*
 -	 * Set idpin value as requested.
 -	 * Since some devices rely on firmware setting DRD_CONFIG and
 -	 * SW_SWITCH_EN bits to be zero for role switch,
 -	 * do not set these bits for those devices.
 -	 */
 +	/* Set idpin value as requested */
  	val = readl(data->base + DUAL_ROLE_CFG0);
  	switch (role) {
  	case USB_ROLE_NONE:
@@@ -155,7 -177,12 +157,15 @@@ static int intel_xhci_usb_probe(struct 
  	sw_desc.get = intel_xhci_usb_get_role,
  	sw_desc.allow_userspace_control = true,
  	sw_desc.fwnode = software_node_fwnode(&intel_xhci_usb_node);
+ 	sw_desc.driver_data = data;
  
++<<<<<<< HEAD
++=======
+ 	data->dev = dev;
+ 	data->enable_sw_switch = !device_property_read_bool(dev,
+ 						"sw_switch_disable");
+ 
++>>>>>>> bce3052f0c16 (usb: roles: Provide the switch drivers handle to the switch in the API)
  	data->role_sw = usb_role_switch_register(dev, &sw_desc);
  	if (IS_ERR(data->role_sw)) {
  		fwnode_handle_put(sw_desc.fwnode);
* Unmerged path drivers/usb/cdns3/core.c
* Unmerged path drivers/usb/gadget/udc/tegra-xudc.c
* Unmerged path drivers/usb/musb/mediatek.c
* Unmerged path drivers/usb/cdns3/core.c
* Unmerged path drivers/usb/chipidea/core.c
diff --git a/drivers/usb/dwc3/dwc3-meson-g12a.c b/drivers/usb/dwc3/dwc3-meson-g12a.c
index bca7e92a10e9..cc000d851153 100644
--- a/drivers/usb/dwc3/dwc3-meson-g12a.c
+++ b/drivers/usb/dwc3/dwc3-meson-g12a.c
@@ -321,9 +321,10 @@ static int dwc3_meson_g12a_otg_mode_set(struct dwc3_meson_g12a *priv,
 	return 0;
 }
 
-static int dwc3_meson_g12a_role_set(struct device *dev, enum usb_role role)
+static int dwc3_meson_g12a_role_set(struct usb_role_switch *sw,
+				    enum usb_role role)
 {
-	struct dwc3_meson_g12a *priv = dev_get_drvdata(dev);
+	struct dwc3_meson_g12a *priv = usb_role_switch_get_drvdata(sw);
 	enum phy_mode mode;
 
 	if (role == USB_ROLE_NONE)
@@ -338,9 +339,9 @@ static int dwc3_meson_g12a_role_set(struct device *dev, enum usb_role role)
 	return dwc3_meson_g12a_otg_mode_set(priv, mode);
 }
 
-static enum usb_role dwc3_meson_g12a_role_get(struct device *dev)
+static enum usb_role dwc3_meson_g12a_role_get(struct usb_role_switch *sw)
 {
-	struct dwc3_meson_g12a *priv = dev_get_drvdata(dev);
+	struct dwc3_meson_g12a *priv = usb_role_switch_get_drvdata(sw);
 
 	return priv->otg_phy_mode == PHY_MODE_USB_HOST ?
 		USB_ROLE_HOST : USB_ROLE_DEVICE;
@@ -501,6 +502,7 @@ static int dwc3_meson_g12a_probe(struct platform_device *pdev)
 	priv->switch_desc.allow_userspace_control = true;
 	priv->switch_desc.set = dwc3_meson_g12a_role_set;
 	priv->switch_desc.get = dwc3_meson_g12a_role_get;
+	priv->switch_desc.driver_data = priv;
 
 	priv->role_switch = usb_role_switch_register(dev, &priv->switch_desc);
 	if (IS_ERR(priv->role_switch))
diff --git a/drivers/usb/gadget/udc/renesas_usb3.c b/drivers/usb/gadget/udc/renesas_usb3.c
index e098f16c01cb..562033663b4d 100644
--- a/drivers/usb/gadget/udc/renesas_usb3.c
+++ b/drivers/usb/gadget/udc/renesas_usb3.c
@@ -2339,14 +2339,14 @@ static const struct usb_gadget_ops renesas_usb3_gadget_ops = {
 	.set_selfpowered	= renesas_usb3_set_selfpowered,
 };
 
-static enum usb_role renesas_usb3_role_switch_get(struct device *dev)
+static enum usb_role renesas_usb3_role_switch_get(struct usb_role_switch *sw)
 {
-	struct renesas_usb3 *usb3 = dev_get_drvdata(dev);
+	struct renesas_usb3 *usb3 = usb_role_switch_get_drvdata(sw);
 	enum usb_role cur_role;
 
-	pm_runtime_get_sync(dev);
+	pm_runtime_get_sync(usb3_to_dev(usb3));
 	cur_role = usb3_is_host(usb3) ? USB_ROLE_HOST : USB_ROLE_DEVICE;
-	pm_runtime_put(dev);
+	pm_runtime_put(usb3_to_dev(usb3));
 
 	return cur_role;
 }
@@ -2356,7 +2356,7 @@ static void handle_ext_role_switch_states(struct device *dev,
 {
 	struct renesas_usb3 *usb3 = dev_get_drvdata(dev);
 	struct device *host = usb3->host_dev;
-	enum usb_role cur_role = renesas_usb3_role_switch_get(dev);
+	enum usb_role cur_role = renesas_usb3_role_switch_get(usb3->role_sw);
 
 	switch (role) {
 	case USB_ROLE_NONE:
@@ -2408,7 +2408,7 @@ static void handle_role_switch_states(struct device *dev,
 {
 	struct renesas_usb3 *usb3 = dev_get_drvdata(dev);
 	struct device *host = usb3->host_dev;
-	enum usb_role cur_role = renesas_usb3_role_switch_get(dev);
+	enum usb_role cur_role = renesas_usb3_role_switch_get(usb3->role_sw);
 
 	if (cur_role == USB_ROLE_HOST && role == USB_ROLE_DEVICE) {
 		device_release_driver(host);
@@ -2422,19 +2422,19 @@ static void handle_role_switch_states(struct device *dev,
 	}
 }
 
-static int renesas_usb3_role_switch_set(struct device *dev,
+static int renesas_usb3_role_switch_set(struct usb_role_switch *sw,
 					enum usb_role role)
 {
-	struct renesas_usb3 *usb3 = dev_get_drvdata(dev);
+	struct renesas_usb3 *usb3 = usb_role_switch_get_drvdata(sw);
 
-	pm_runtime_get_sync(dev);
+	pm_runtime_get_sync(usb3_to_dev(usb3));
 
 	if (usb3->role_sw_by_connector)
-		handle_ext_role_switch_states(dev, role);
+		handle_ext_role_switch_states(usb3_to_dev(usb3), role);
 	else
-		handle_role_switch_states(dev, role);
+		handle_role_switch_states(usb3_to_dev(usb3), role);
 
-	pm_runtime_put(dev);
+	pm_runtime_put(usb3_to_dev(usb3));
 
 	return 0;
 }
@@ -2817,6 +2817,8 @@ static int renesas_usb3_probe(struct platform_device *pdev)
 		renesas_usb3_role_switch_desc.fwnode = dev_fwnode(&pdev->dev);
 	}
 
+	renesas_usb3_role_switch_desc.driver_data = usb3;
+
 	INIT_WORK(&usb3->role_work, renesas_usb3_role_work);
 	usb3->role_sw = usb_role_switch_register(&pdev->dev,
 					&renesas_usb3_role_switch_desc);
* Unmerged path drivers/usb/gadget/udc/tegra-xudc.c
* Unmerged path drivers/usb/mtu3/mtu3_dr.c
* Unmerged path drivers/usb/musb/mediatek.c
diff --git a/drivers/usb/roles/class.c b/drivers/usb/roles/class.c
index ac8c94a6d442..d49a19db27a8 100644
--- a/drivers/usb/roles/class.c
+++ b/drivers/usb/roles/class.c
@@ -48,7 +48,7 @@ int usb_role_switch_set_role(struct usb_role_switch *sw, enum usb_role role)
 
 	mutex_lock(&sw->lock);
 
-	ret = sw->set(sw->dev.parent, role);
+	ret = sw->set(sw, role);
 	if (!ret)
 		sw->role = role;
 
@@ -75,7 +75,7 @@ enum usb_role usb_role_switch_get_role(struct usb_role_switch *sw)
 	mutex_lock(&sw->lock);
 
 	if (sw->get)
-		role = sw->get(sw->dev.parent);
+		role = sw->get(sw);
 	else
 		role = sw->role;
 
* Unmerged path drivers/usb/roles/intel-xhci-usb-role-switch.c
diff --git a/include/linux/usb/role.h b/include/linux/usb/role.h
index 02dae936cebd..c028ba8029ad 100644
--- a/include/linux/usb/role.h
+++ b/include/linux/usb/role.h
@@ -13,8 +13,9 @@ enum usb_role {
 	USB_ROLE_DEVICE,
 };
 
-typedef int (*usb_role_switch_set_t)(struct device *dev, enum usb_role role);
-typedef enum usb_role (*usb_role_switch_get_t)(struct device *dev);
+typedef int (*usb_role_switch_set_t)(struct usb_role_switch *sw,
+				     enum usb_role role);
+typedef enum usb_role (*usb_role_switch_get_t)(struct usb_role_switch *sw);
 
 /**
  * struct usb_role_switch_desc - USB Role Switch Descriptor
