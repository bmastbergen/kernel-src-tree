rcu/tree: Repeat the monitor if any free channel is busy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Uladzislau Rezki (Sony) <urezki@gmail.com>
commit 594aa5975b9b5cfe9edaec06170e43b8c0607377
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/594aa597.failed

It is possible that one of the channels cannot be detached
because its free channel is busy and previously queued data
has not been processed yet. On the other hand, another
channel can be successfully detached causing the monitor
work to stop.

Prevent that by rescheduling the monitor work if there are
any channels in the pending state after a detach attempt.

Fixes: 34c881745549e ("rcu: Support kfree_bulk() interface in kfree_rcu()")
	Acked-by: Joel Fernandes (Google) <joel@joelfernandes.org>
	Signed-off-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
(cherry picked from commit 594aa5975b9b5cfe9edaec06170e43b8c0607377)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 4aa7b6bbcde6,5151fe4e1429..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -2757,26 -3104,53 +2757,76 @@@ static void kfree_rcu_work(struct work_
   */
  static inline bool queue_kfree_rcu_work(struct kfree_rcu_cpu *krcp)
  {
++<<<<<<< HEAD
++=======
+ 	struct kfree_rcu_cpu_work *krwp;
+ 	bool repeat = false;
++>>>>>>> 594aa5975b9b (rcu/tree: Repeat the monitor if any free channel is busy)
  	int i;
 +	struct kfree_rcu_cpu_work *krwp = NULL;
  
  	lockdep_assert_held(&krcp->lock);
++<<<<<<< HEAD
 +	for (i = 0; i < KFREE_N_BATCHES; i++)
 +		if (!krcp->krw_arr[i].head_free) {
 +			krwp = &(krcp->krw_arr[i]);
 +			break;
 +		}
 +
 +	// If a previous RCU batch is in progress, we cannot immediately
 +	// queue another one, so return false to tell caller to retry.
 +	if (!krwp)
 +		return false;
 +
 +	krwp->head_free = krcp->head;
 +	krcp->head = NULL;
 +	INIT_RCU_WORK(&krwp->rcu_work, kfree_rcu_work);
 +	queue_rcu_work(system_wq, &krwp->rcu_work);
 +	return true;
++=======
+ 
+ 	for (i = 0; i < KFREE_N_BATCHES; i++) {
+ 		krwp = &(krcp->krw_arr[i]);
+ 
+ 		/*
+ 		 * Try to detach bhead or head and attach it over any
+ 		 * available corresponding free channel. It can be that
+ 		 * a previous RCU batch is in progress, it means that
+ 		 * immediately to queue another one is not possible so
+ 		 * return false to tell caller to retry.
+ 		 */
+ 		if ((krcp->bhead && !krwp->bhead_free) ||
+ 				(krcp->head && !krwp->head_free)) {
+ 			/* Channel 1. */
+ 			if (!krwp->bhead_free) {
+ 				krwp->bhead_free = krcp->bhead;
+ 				krcp->bhead = NULL;
+ 			}
+ 
+ 			/* Channel 2. */
+ 			if (!krwp->head_free) {
+ 				krwp->head_free = krcp->head;
+ 				krcp->head = NULL;
+ 			}
+ 
+ 			WRITE_ONCE(krcp->count, 0);
+ 
+ 			/*
+ 			 * One work is per one batch, so there are two "free channels",
+ 			 * "bhead_free" and "head_free" the batch can handle. It can be
+ 			 * that the work is in the pending state when two channels have
+ 			 * been detached following each other, one by one.
+ 			 */
+ 			queue_rcu_work(system_wq, &krwp->rcu_work);
+ 		}
+ 
+ 		/* Repeat if any "free" corresponding channel is still busy. */
+ 		if (krcp->bhead || krcp->head)
+ 			repeat = true;
+ 	}
+ 
+ 	return !repeat;
++>>>>>>> 594aa5975b9b (rcu/tree: Repeat the monitor if any free channel is busy)
  }
  
  static inline void kfree_rcu_drain_unlock(struct kfree_rcu_cpu *krcp,
* Unmerged path kernel/rcu/tree.c
