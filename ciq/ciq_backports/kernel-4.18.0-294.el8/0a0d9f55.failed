gfs2: simplify the logic in gfs2_evict_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit 0a0d9f55c211d7a03b8ec5ad2d8f5b3062b4387c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0a0d9f55.failed

Now that we've factored out the deleted and undeleted dinode cases
in gfs2_evict_inode, we can greatly simplify the logic. Now the
function is easy to read and understand.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 0a0d9f55c211d7a03b8ec5ad2d8f5b3062b4387c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index 7ef6d48f35a7,3d9daac44e1c..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1350,7 -1339,7 +1350,8 @@@ static void gfs2_evict_inode(struct ino
  	}
  
  	if (test_bit(GIF_DEFERRED_DELETE, &ip->i_flags))
 -		return SHOULD_DEFER_EVICTION;
 +		goto out;
++<<<<<<< HEAD
  
  	/* Deletes should never happen under memory pressure anymore.  */
  	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC))
@@@ -1441,9 -1452,55 +1442,16 @@@ out_truncate
  	truncate_inode_pages(&inode->i_data, 0);
  	truncate_inode_pages(metamapping, 0);
  	gfs2_trans_end(sdp);
 -	return 0;
 -}
 -
 -/**
 - * gfs2_evict_inode - Remove an inode from cache
 - * @inode: The inode to evict
 - *
 - * There are three cases to consider:
 - * 1. i_nlink == 0, we are final opener (and must deallocate)
 - * 2. i_nlink == 0, we are not the final opener (and cannot deallocate)
 - * 3. i_nlink > 0
 - *
 - * If the fs is read only, then we have to treat all cases as per #3
 - * since we are unable to do any deallocation. The inode will be
 - * deallocated by the next read/write node to attempt an allocation
 - * in the same resource group
 - *
 - * We have to (at the moment) hold the inodes main lock to cover
 - * the gap between unlocking the shared lock on the iopen lock and
 - * taking the exclusive lock. I'd rather do a shared -> exclusive
 - * conversion on the iopen lock, but we can change that later. This
 - * is safe, just less efficient.
 - */
  
 -static void gfs2_evict_inode(struct inode *inode)
 -{
 -	struct super_block *sb = inode->i_sb;
 -	struct gfs2_sbd *sdp = sb->s_fs_info;
 -	struct gfs2_inode *ip = GFS2_I(inode);
 -	struct gfs2_holder gh;
 -	int ret;
 -
 -	if (test_bit(GIF_FREE_VFS_INODE, &ip->i_flags)) {
 -		clear_inode(inode);
 -		return;
 -	}
 -
 -	if (inode->i_nlink || sb_rdonly(sb))
 -		goto out;
 -
 -	gfs2_holder_mark_uninitialized(&gh);
 -	ret = evict_should_delete(inode, &gh);
 -	if (ret == SHOULD_DEFER_EVICTION)
 -		goto out;
 +out_unlock:
 +	/* Error path for case 1 */
++=======
+ 	if (ret == SHOULD_DELETE_DINODE)
+ 		ret = evict_unlinked_inode(inode);
+ 	else
+ 		ret = evict_linked_inode(inode);
+ 
++>>>>>>> 0a0d9f55c211 (gfs2: simplify the logic in gfs2_evict_inode)
  	if (gfs2_rs_active(&ip->i_res))
  		gfs2_rs_deltree(&ip->i_res);
  
* Unmerged path fs/gfs2/super.c
