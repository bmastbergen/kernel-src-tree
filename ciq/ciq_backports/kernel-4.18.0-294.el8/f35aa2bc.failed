tmpfs: switch to use of invalfc()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit f35aa2bc809eacc44c3cee41b52cef1c451d4a89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f35aa2bc.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit f35aa2bc809eacc44c3cee41b52cef1c451d4a89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/shmem.c
diff --cc mm/shmem.c
index 02e9c145ac0a,c8f7540ef048..000000000000
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@@ -3330,11 -3370,119 +3330,92 @@@ static const struct export_operations s
  	.fh_to_dentry	= shmem_fh_to_dentry,
  };
  
 -enum shmem_param {
 -	Opt_gid,
 -	Opt_huge,
 -	Opt_mode,
 -	Opt_mpol,
 -	Opt_nr_blocks,
 -	Opt_nr_inodes,
 -	Opt_size,
 -	Opt_uid,
 -};
 -
 -static const struct constant_table shmem_param_enums_huge[] = {
 -	{"never",	SHMEM_HUGE_NEVER },
 -	{"always",	SHMEM_HUGE_ALWAYS },
 -	{"within_size",	SHMEM_HUGE_WITHIN_SIZE },
 -	{"advise",	SHMEM_HUGE_ADVISE },
 -	{"deny",	SHMEM_HUGE_DENY },
 -	{"force",	SHMEM_HUGE_FORCE },
 -	{}
 -};
 -
 -const struct fs_parameter_spec shmem_fs_parameters[] = {
 -	fsparam_u32   ("gid",		Opt_gid),
 -	fsparam_enum  ("huge",		Opt_huge,  shmem_param_enums_huge),
 -	fsparam_u32oct("mode",		Opt_mode),
 -	fsparam_string("mpol",		Opt_mpol),
 -	fsparam_string("nr_blocks",	Opt_nr_blocks),
 -	fsparam_string("nr_inodes",	Opt_nr_inodes),
 -	fsparam_string("size",		Opt_size),
 -	fsparam_u32   ("uid",		Opt_uid),
 -	{}
 -};
 -
 -static int shmem_parse_one(struct fs_context *fc, struct fs_parameter *param)
 +static int shmem_parse_options(char *options, struct shmem_options *ctx)
  {
++<<<<<<< HEAD
 +	char *this_char, *value, *rest;
 +	uid_t uid;
 +	gid_t gid;
++=======
+ 	struct shmem_options *ctx = fc->fs_private;
+ 	struct fs_parse_result result;
+ 	unsigned long long size;
+ 	char *rest;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, shmem_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_size:
+ 		size = memparse(param->string, &rest);
+ 		if (*rest == '%') {
+ 			size <<= PAGE_SHIFT;
+ 			size *= totalram_pages();
+ 			do_div(size, 100);
+ 			rest++;
+ 		}
+ 		if (*rest)
+ 			goto bad_value;
+ 		ctx->blocks = DIV_ROUND_UP(size, PAGE_SIZE);
+ 		ctx->seen |= SHMEM_SEEN_BLOCKS;
+ 		break;
+ 	case Opt_nr_blocks:
+ 		ctx->blocks = memparse(param->string, &rest);
+ 		if (*rest)
+ 			goto bad_value;
+ 		ctx->seen |= SHMEM_SEEN_BLOCKS;
+ 		break;
+ 	case Opt_nr_inodes:
+ 		ctx->inodes = memparse(param->string, &rest);
+ 		if (*rest)
+ 			goto bad_value;
+ 		ctx->seen |= SHMEM_SEEN_INODES;
+ 		break;
+ 	case Opt_mode:
+ 		ctx->mode = result.uint_32 & 07777;
+ 		break;
+ 	case Opt_uid:
+ 		ctx->uid = make_kuid(current_user_ns(), result.uint_32);
+ 		if (!uid_valid(ctx->uid))
+ 			goto bad_value;
+ 		break;
+ 	case Opt_gid:
+ 		ctx->gid = make_kgid(current_user_ns(), result.uint_32);
+ 		if (!gid_valid(ctx->gid))
+ 			goto bad_value;
+ 		break;
+ 	case Opt_huge:
+ 		ctx->huge = result.uint_32;
+ 		if (ctx->huge != SHMEM_HUGE_NEVER &&
+ 		    !(IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&
+ 		      has_transparent_hugepage()))
+ 			goto unsupported_parameter;
+ 		ctx->seen |= SHMEM_SEEN_HUGE;
+ 		break;
+ 	case Opt_mpol:
+ 		if (IS_ENABLED(CONFIG_NUMA)) {
+ 			mpol_put(ctx->mpol);
+ 			ctx->mpol = NULL;
+ 			if (mpol_parse_str(param->string, &ctx->mpol))
+ 				goto bad_value;
+ 			break;
+ 		}
+ 		goto unsupported_parameter;
+ 	}
+ 	return 0;
+ 
+ unsupported_parameter:
+ 	return invalfc(fc, "Unsupported parameter '%s'", param->key);
+ bad_value:
+ 	return invalfc(fc, "Bad value for '%s'", param->key);
+ }
+ 
+ static int shmem_parse_options(struct fs_context *fc, void *data)
+ {
+ 	char *options = data;
++>>>>>>> f35aa2bc809e (tmpfs: switch to use of invalfc())
  
  	if (options) {
  		int err = security_sb_eat_lsm_opts(options, &fc->security);
@@@ -3490,13 -3574,16 +3571,17 @@@ static int shmem_remount_fs(struct supe
  	/*
  	 * Preserve previous mempolicy unless mpol remount option was specified.
  	 */
 -	if (ctx->mpol) {
 +	if (ctx.mpol) {
  		mpol_put(sbinfo->mpol);
 -		sbinfo->mpol = ctx->mpol;	/* transfers initial ref */
 -		ctx->mpol = NULL;
 +		sbinfo->mpol = ctx.mpol;	/* transfers initial ref */
  	}
 -	spin_unlock(&sbinfo->stat_lock);
 -	return 0;
  out:
  	spin_unlock(&sbinfo->stat_lock);
++<<<<<<< HEAD
 +	return error;
++=======
+ 	return invalfc(fc, "%s", err);
++>>>>>>> f35aa2bc809e (tmpfs: switch to use of invalfc())
  }
  
  static int shmem_show_options(struct seq_file *seq, struct dentry *root)
* Unmerged path mm/shmem.c
