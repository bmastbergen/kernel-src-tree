gfs2: fix O_SYNC write handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 6e5e41e2dc4e4413296d5a4af54ac92d7cd52317
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6e5e41e2.failed

In gfs2_file_write_iter, for direct writes, the error checking in the buffered
write fallback case is incomplete.  This can cause inode write errors to go
undetected.  Fix and clean up gfs2_file_write_iter along the way.

Based on a proposed fix by Christoph Hellwig <hch@lst.de>.

Fixes: 967bcc91b044 ("gfs2: iomap direct I/O support")
	Cc: stable@vger.kernel.org # v4.19+
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 6e5e41e2dc4e4413296d5a4af54ac92d7cd52317)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index 31149ac3715f,cb26be6f4351..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -787,8 -847,12 +787,8 @@@ static ssize_t gfs2_file_write_iter(str
  	struct file *file = iocb->ki_filp;
  	struct inode *inode = file_inode(file);
  	struct gfs2_inode *ip = GFS2_I(inode);
- 	ssize_t written = 0, ret;
+ 	ssize_t ret;
  
 -	ret = gfs2_rsqa_alloc(ip);
 -	if (ret)
 -		return ret;
 -
  	gfs2_size_hint(file, iocb->ki_pos, iov_iter_count(from));
  
  	if (iocb->ki_flags & IOCB_APPEND) {
@@@ -818,53 -879,46 +818,62 @@@
  
  	if (iocb->ki_flags & IOCB_DIRECT) {
  		struct address_space *mapping = file->f_mapping;
- 		loff_t pos, endbyte;
- 		ssize_t buffered;
+ 		ssize_t buffered, ret2;
  
++<<<<<<< HEAD
 +		written = gfs2_file_direct_write(iocb, from);
 +		if (written < 0 || !iov_iter_count(from))
 +			goto out2;
 +
 +		ret = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);
 +		if (unlikely(ret < 0))
 +			goto out2;
 +		buffered = ret;
++=======
+ 		ret = gfs2_file_direct_write(iocb, from);
+ 		if (ret < 0 || !iov_iter_count(from))
+ 			goto out_unlock;
+ 
+ 		iocb->ki_flags |= IOCB_DSYNC;
+ 		current->backing_dev_info = inode_to_bdi(inode);
+ 		buffered = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);
+ 		current->backing_dev_info = NULL;
+ 		if (unlikely(buffered <= 0))
+ 			goto out_unlock;
++>>>>>>> 6e5e41e2dc4e (gfs2: fix O_SYNC write handling)
  
  		/*
  		 * We need to ensure that the page cache pages are written to
  		 * disk and invalidated to preserve the expected O_DIRECT
- 		 * semantics.
+ 		 * semantics.  If the writeback or invalidate fails, only report
+ 		 * the direct I/O range as we don't know if the buffered pages
+ 		 * made it to disk.
  		 */
- 		pos = iocb->ki_pos;
- 		endbyte = pos + buffered - 1;
- 		ret = filemap_write_and_wait_range(mapping, pos, endbyte);
- 		if (!ret) {
- 			iocb->ki_pos += buffered;
- 			written += buffered;
- 			invalidate_mapping_pages(mapping,
- 						 pos >> PAGE_SHIFT,
- 						 endbyte >> PAGE_SHIFT);
- 		} else {
- 			/*
- 			 * We don't know how much we wrote, so just return
- 			 * the number of bytes which were direct-written
- 			 */
- 		}
+ 		iocb->ki_pos += buffered;
+ 		ret2 = generic_write_sync(iocb, buffered);
+ 		invalidate_mapping_pages(mapping,
+ 				(iocb->ki_pos - buffered) >> PAGE_SHIFT,
+ 				(iocb->ki_pos - 1) >> PAGE_SHIFT);
+ 		if (!ret || ret2 > 0)
+ 			ret += ret2;
  	} else {
 -		current->backing_dev_info = inode_to_bdi(inode);
  		ret = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);
++<<<<<<< HEAD
 +		if (likely(ret > 0))
++=======
+ 		current->backing_dev_info = NULL;
+ 		if (likely(ret > 0)) {
++>>>>>>> 6e5e41e2dc4e (gfs2: fix O_SYNC write handling)
  			iocb->ki_pos += ret;
+ 			ret = generic_write_sync(iocb, ret);
+ 		}
  	}
  
 +out2:
 +	current->backing_dev_info = NULL;
  out_unlock:
  	inode_unlock(inode);
- 	if (likely(ret > 0)) {
- 		/* Handle various SYNC-type writes */
- 		ret = generic_write_sync(iocb, ret);
- 	}
- 	return written ? written : ret;
+ 	return ret;
  }
  
  static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,
* Unmerged path fs/gfs2/file.c
