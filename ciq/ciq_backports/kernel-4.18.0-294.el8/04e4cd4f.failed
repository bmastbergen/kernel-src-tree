mptcp: cleanup mptcp_subflow_discard_data()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 04e4cd4f7ca4600409a898fe0abc318372c4c1ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/04e4cd4f.failed

There is no need to use the tcp_read_sock(), we can
simply drop the skb. Additionally try to look at the
next buffer for in order data.

This both simplifies the code and avoid unneeded indirect
calls.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 04e4cd4f7ca4600409a898fe0abc318372c4c1ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.h
#	net/mptcp/subflow.c
diff --cc net/mptcp/protocol.h
index 223e4fb33f77,26f5f81f3f4c..000000000000
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@@ -348,7 -355,7 +348,11 @@@ int mptcp_is_enabled(struct net *net)
  void mptcp_subflow_fully_established(struct mptcp_subflow_context *subflow,
  				     struct mptcp_options_received *mp_opt);
  bool mptcp_subflow_data_available(struct sock *sk);
++<<<<<<< HEAD
 +void mptcp_subflow_init(void);
++=======
+ void __init mptcp_subflow_init(void);
++>>>>>>> 04e4cd4f7ca4 (mptcp: cleanup mptcp_subflow_discard_data())
  
  /* called with sk socket lock held */
  int __mptcp_subflow_connect(struct sock *sk, int ifindex,
diff --cc net/mptcp/subflow.c
index 750f1161d6e1,6eb2fc0a8ebb..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -768,16 -805,22 +768,35 @@@ validate_seq
  	return MAPPING_OK;
  }
  
++<<<<<<< HEAD
 +static int subflow_read_actor(read_descriptor_t *desc,
 +			      struct sk_buff *skb,
 +			      unsigned int offset, size_t len)
 +{
 +	size_t copy_len = min(desc->count, len);
 +
 +	desc->count -= copy_len;
 +
 +	pr_debug("flushed %zu bytes, %zu left", copy_len, desc->count);
 +	return copy_len;
++=======
+ static void mptcp_subflow_discard_data(struct sock *ssk, struct sk_buff *skb,
+ 				       unsigned int limit)
+ {
+ 	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);
+ 	bool fin = TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN;
+ 	u32 incr;
+ 
+ 	incr = limit >= skb->len ? skb->len + fin : limit;
+ 
+ 	pr_debug("discarding=%d len=%d seq=%d", incr, skb->len,
+ 		 subflow->map_subflow_seq);
+ 	tcp_sk(ssk)->copied_seq += incr;
+ 	if (!before(tcp_sk(ssk)->copied_seq, TCP_SKB_CB(skb)->end_seq))
+ 		sk_eat_skb(ssk, skb);
+ 	if (mptcp_subflow_get_map_offset(subflow) >= subflow->map_data_len)
+ 		subflow->map_valid = 0;
++>>>>>>> 04e4cd4f7ca4 (mptcp: cleanup mptcp_subflow_discard_data())
  }
  
  static bool subflow_check_data_avail(struct sock *ssk)
@@@ -849,38 -893,9 +868,42 @@@
  		}
  
  		/* only accept in-sequence mapping. Old values are spurious
 -		 * retransmission
 +		 * retransmission; we can hit "future" values on active backup
 +		 * subflow switch, we relay on retransmissions to get
 +		 * in-sequence data.
 +		 * Cuncurrent subflows support will require subflow data
 +		 * reordering
  		 */
++<<<<<<< HEAD
 +		map_remaining = subflow->map_data_len -
 +				mptcp_subflow_get_map_offset(subflow);
 +		if (before64(ack_seq, old_ack))
 +			delta = min_t(size_t, old_ack - ack_seq, map_remaining);
 +		else
 +			delta = min_t(size_t, ack_seq - old_ack, map_remaining);
 +
 +		/* discard mapped data */
 +		pr_debug("discarding %zu bytes, current map len=%d", delta,
 +			 map_remaining);
 +		if (delta) {
 +			read_descriptor_t desc = {
 +				.count = delta,
 +			};
 +			int ret;
 +
 +			ret = tcp_read_sock(ssk, &desc, subflow_read_actor);
 +			if (ret < 0) {
 +				ssk->sk_err = -ret;
 +				goto fatal;
 +			}
 +			if (ret < delta)
 +				return false;
 +			if (delta == map_remaining)
 +				subflow->map_valid = 0;
 +		}
++=======
+ 		mptcp_subflow_discard_data(ssk, skb, old_ack - ack_seq);
++>>>>>>> 04e4cd4f7ca4 (mptcp: cleanup mptcp_subflow_discard_data())
  	}
  	return true;
  
* Unmerged path net/mptcp/protocol.h
* Unmerged path net/mptcp/subflow.c
