mptcp: add the outgoing ADD_ADDR port support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 4a2777a83406cc87edf08b5c71887d896f628525
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4a2777a8.failed

This patch added a new add_addr_signal type named MPTCP_ADD_ADDR_PORT,
to identify it is an address with port to be added.

It also added a new parameter 'port' for both mptcp_add_addr_len and
mptcp_pm_add_addr_signal.

In mptcp_established_options_add_addr, we check whether the announced
address is added with port. If it is, we put this port number to
mptcp_out_options's port field.

	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4a2777a83406cc87edf08b5c71887d896f628525)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/options.c
#	net/mptcp/pm.c
#	net/mptcp/protocol.h
diff --cc net/mptcp/options.c
index af3f2e566740,faae58cc7330..000000000000
--- a/net/mptcp/options.c
+++ b/net/mptcp/options.c
@@@ -579,19 -583,35 +579,33 @@@ static bool mptcp_established_options_a
  {
  	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);
  	struct mptcp_sock *msk = mptcp_sk(subflow->conn);
 -	bool drop_other_suboptions = false;
 -	unsigned int opt_size = *size;
  	struct mptcp_addr_info saddr;
++<<<<<<< HEAD
++=======
+ 	bool echo;
+ 	bool port;
++>>>>>>> 4a2777a83406 (mptcp: add the outgoing ADD_ADDR port support)
  	int len;
  
 -	if (mptcp_pm_should_add_signal_ipv6(msk) &&
 -	    skb && skb_is_tcp_pure_ack(skb)) {
 -		pr_debug("drop other suboptions");
 -		opts->suboptions = 0;
 -		remaining += opt_size;
 -		drop_other_suboptions = true;
 -	}
 -
  	if (!mptcp_pm_should_add_signal(msk) ||
++<<<<<<< HEAD
 +	    !(mptcp_pm_add_addr_signal(msk, remaining, &saddr)))
 +		return false;
 +
 +	len = mptcp_add_addr_len(saddr.family);
++=======
+ 	    !(mptcp_pm_add_addr_signal(msk, remaining, &saddr, &echo, &port)))
+ 		return false;
+ 
+ 	len = mptcp_add_addr_len(saddr.family, echo, port);
++>>>>>>> 4a2777a83406 (mptcp: add the outgoing ADD_ADDR port support)
  	if (remaining < len)
  		return false;
  
  	*size = len;
 -	if (drop_other_suboptions)
 -		*size -= opt_size;
  	opts->addr_id = saddr.id;
+ 	if (port)
+ 		opts->port = ntohs(saddr.port);
  	if (saddr.family == AF_INET) {
  		opts->suboptions |= OPTION_MPTCP_ADD_ADDR;
  		opts->addr = saddr.addr;
@@@ -604,13 -626,41 +618,43 @@@
  	else if (saddr.family == AF_INET6) {
  		opts->suboptions |= OPTION_MPTCP_ADD_ADDR6;
  		opts->addr6 = saddr.addr6;
 -		if (!echo) {
 -			opts->ahmac = add_addr6_generate_hmac(msk->local_key,
 -							      msk->remote_key,
 -							      opts->addr_id,
 -							      &opts->addr6);
 -		}
 +		opts->ahmac = add_addr6_generate_hmac(msk->local_key,
 +						      msk->remote_key,
 +						      opts->addr_id,
 +						      &opts->addr6);
  	}
  #endif
++<<<<<<< HEAD
 +	pr_debug("addr_id=%d, ahmac=%llu", opts->addr_id, opts->ahmac);
++=======
+ 	pr_debug("addr_id=%d, ahmac=%llu, echo=%d, port=%d",
+ 		 opts->addr_id, opts->ahmac, echo, opts->port);
+ 
+ 	return true;
+ }
+ 
+ static bool mptcp_established_options_rm_addr(struct sock *sk,
+ 					      unsigned int *size,
+ 					      unsigned int remaining,
+ 					      struct mptcp_out_options *opts)
+ {
+ 	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);
+ 	struct mptcp_sock *msk = mptcp_sk(subflow->conn);
+ 	u8 rm_id;
+ 
+ 	if (!mptcp_pm_should_rm_signal(msk) ||
+ 	    !(mptcp_pm_rm_addr_signal(msk, remaining, &rm_id)))
+ 		return false;
+ 
+ 	if (remaining < TCPOLEN_MPTCP_RM_ADDR_BASE)
+ 		return false;
+ 
+ 	*size = TCPOLEN_MPTCP_RM_ADDR_BASE;
+ 	opts->suboptions |= OPTION_MPTCP_RM_ADDR;
+ 	opts->rm_id = rm_id;
+ 
+ 	pr_debug("rm_id=%d", opts->rm_id);
++>>>>>>> 4a2777a83406 (mptcp: add the outgoing ADD_ADDR port support)
  
  	return true;
  }
diff --cc net/mptcp/pm.c
index a78fc80f9b51,6d4be02681fa..000000000000
--- a/net/mptcp/pm.c
+++ b/net/mptcp/pm.c
@@@ -156,7 -188,7 +156,11 @@@ void mptcp_pm_add_addr_received(struct 
  /* path manager helpers */
  
  bool mptcp_pm_add_addr_signal(struct mptcp_sock *msk, unsigned int remaining,
++<<<<<<< HEAD
 +			      struct mptcp_addr_info *saddr)
++=======
+ 			      struct mptcp_addr_info *saddr, bool *echo, bool *port)
++>>>>>>> 4a2777a83406 (mptcp: add the outgoing ADD_ADDR port support)
  {
  	int ret = false;
  
@@@ -166,7 -198,10 +170,14 @@@
  	if (!mptcp_pm_should_add_signal(msk))
  		goto out_unlock;
  
++<<<<<<< HEAD
 +	if (remaining < mptcp_add_addr_len(msk->pm.local.family))
++=======
+ 	*echo = mptcp_pm_should_add_signal_echo(msk);
+ 	*port = mptcp_pm_should_add_signal_port(msk);
+ 
+ 	if (remaining < mptcp_add_addr_len(msk->pm.local.family, *echo, *port))
++>>>>>>> 4a2777a83406 (mptcp: add the outgoing ADD_ADDR port support)
  		goto out_unlock;
  
  	*saddr = msk->pm.local;
diff --cc net/mptcp/protocol.h
index ec3d81e5cc62,d69b4fc918cf..000000000000
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@@ -161,6 -168,13 +161,16 @@@ enum mptcp_pm_status 
  	MPTCP_PM_SUBFLOW_ESTABLISHED,
  };
  
++<<<<<<< HEAD
++=======
+ enum mptcp_add_addr_status {
+ 	MPTCP_ADD_ADDR_SIGNAL,
+ 	MPTCP_ADD_ADDR_ECHO,
+ 	MPTCP_ADD_ADDR_IPV6,
+ 	MPTCP_ADD_ADDR_PORT,
+ };
+ 
++>>>>>>> 4a2777a83406 (mptcp: add the outgoing ADD_ADDR port support)
  struct mptcp_pm_data {
  	struct mptcp_addr_info local;
  	struct mptcp_addr_info remote;
@@@ -447,21 -558,50 +457,60 @@@ int mptcp_pm_remove_subflow(struct mptc
  
  static inline bool mptcp_pm_should_add_signal(struct mptcp_sock *msk)
  {
 -	return READ_ONCE(msk->pm.add_addr_signal) & BIT(MPTCP_ADD_ADDR_SIGNAL);
 +	return READ_ONCE(msk->pm.add_addr_signal);
  }
  
 -static inline bool mptcp_pm_should_add_signal_echo(struct mptcp_sock *msk)
 +static inline unsigned int mptcp_add_addr_len(int family)
  {
++<<<<<<< HEAD
 +	if (family == AF_INET)
 +		return TCPOLEN_MPTCP_ADD_ADDR;
 +	return TCPOLEN_MPTCP_ADD_ADDR6;
 +}
 +
 +bool mptcp_pm_add_addr_signal(struct mptcp_sock *msk, unsigned int remaining,
 +			      struct mptcp_addr_info *saddr);
++=======
+ 	return READ_ONCE(msk->pm.add_addr_signal) & BIT(MPTCP_ADD_ADDR_ECHO);
+ }
+ 
+ static inline bool mptcp_pm_should_add_signal_ipv6(struct mptcp_sock *msk)
+ {
+ 	return READ_ONCE(msk->pm.add_addr_signal) & BIT(MPTCP_ADD_ADDR_IPV6);
+ }
+ 
+ static inline bool mptcp_pm_should_add_signal_port(struct mptcp_sock *msk)
+ {
+ 	return READ_ONCE(msk->pm.add_addr_signal) & BIT(MPTCP_ADD_ADDR_PORT);
+ }
+ 
+ static inline bool mptcp_pm_should_rm_signal(struct mptcp_sock *msk)
+ {
+ 	return READ_ONCE(msk->pm.rm_addr_signal);
+ }
+ 
+ static inline unsigned int mptcp_add_addr_len(int family, bool echo, bool port)
+ {
+ 	u8 len = TCPOLEN_MPTCP_ADD_ADDR_BASE;
+ 
+ 	if (family == AF_INET6)
+ 		len = TCPOLEN_MPTCP_ADD_ADDR6_BASE;
+ 	if (!echo)
+ 		len += MPTCPOPT_THMAC_LEN;
+ 	if (port)
+ 		len += TCPOLEN_MPTCP_PORT_LEN;
+ 
+ 	return len;
+ }
+ 
+ bool mptcp_pm_add_addr_signal(struct mptcp_sock *msk, unsigned int remaining,
+ 			      struct mptcp_addr_info *saddr, bool *echo, bool *port);
+ bool mptcp_pm_rm_addr_signal(struct mptcp_sock *msk, unsigned int remaining,
+ 			     u8 *rm_id);
++>>>>>>> 4a2777a83406 (mptcp: add the outgoing ADD_ADDR port support)
  int mptcp_pm_get_local_id(struct mptcp_sock *msk, struct sock_common *skc);
  
 -void __init mptcp_pm_nl_init(void);
 +void mptcp_pm_nl_init(void);
  void mptcp_pm_nl_data_init(struct mptcp_sock *msk);
  void mptcp_pm_nl_fully_established(struct mptcp_sock *msk);
  void mptcp_pm_nl_subflow_established(struct mptcp_sock *msk);
* Unmerged path net/mptcp/options.c
* Unmerged path net/mptcp/pm.c
* Unmerged path net/mptcp/protocol.h
