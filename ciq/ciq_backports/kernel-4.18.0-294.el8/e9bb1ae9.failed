KVM: VMX: Rename vcpu_vmx's "save_nmsrs" to "nr_active_uret_msrs"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit e9bb1ae92d62bd55b8093918fdec91f6fc3d3a56
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e9bb1ae9.failed

Add "uret" into the name of "save_nmsrs" to explicitly associate it with
the guest_uret_msrs array, and replace "save" with "active" (for lack of
a better word) to better describe what is being tracked.  While "save"
is more or less accurate when viewed as a literal description of the
field, e.g. it holds the number of MSRs that were saved into the array
the last time setup_msrs() was invoked, it can easily be misinterpreted
by the reader, e.g. as meaning the number of MSRs that were saved from
hardware at some point in the past, or as the number of MSRs that need
to be saved at some point in the future, both of which are wrong.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200923180409.32255-7-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e9bb1ae92d62bd55b8093918fdec91f6fc3d3a56)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/vmx/vmx.h
diff --cc arch/x86/kvm/vmx/vmx.c
index 985a4bfb7517,24087abf6077..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -637,7 -637,7 +637,11 @@@ static int vmx_set_guest_msr(struct vcp
  
  	u64 old_msr_data = msr->data;
  	msr->data = data;
++<<<<<<< HEAD
 +	if (msr - vmx->guest_msrs < vmx->save_nmsrs) {
++=======
+ 	if (msr - vmx->guest_uret_msrs < vmx->nr_active_uret_msrs) {
++>>>>>>> e9bb1ae92d62 (KVM: VMX: Rename vcpu_vmx's "save_nmsrs" to "nr_active_uret_msrs")
  		preempt_disable();
  		ret = kvm_set_user_return_msr(msr->index, msr->data, msr->mask);
  		preempt_enable();
@@@ -1148,10 -1136,10 +1152,17 @@@ void vmx_prepare_switch_to_guest(struc
  	 */
  	if (!vmx->guest_msrs_ready) {
  		vmx->guest_msrs_ready = true;
++<<<<<<< HEAD
 +		for (i = 0; i < vmx->save_nmsrs; ++i)
 +			kvm_set_user_return_msr(vmx->guest_msrs[i].index,
 +						vmx->guest_msrs[i].data,
 +						vmx->guest_msrs[i].mask);
++=======
+ 		for (i = 0; i < vmx->nr_active_uret_msrs; ++i)
+ 			kvm_set_user_return_msr(vmx->guest_uret_msrs[i].index,
+ 						vmx->guest_uret_msrs[i].data,
+ 						vmx->guest_uret_msrs[i].mask);
++>>>>>>> e9bb1ae92d62 (KVM: VMX: Rename vcpu_vmx's "save_nmsrs" to "nr_active_uret_msrs")
  
  	}
  
diff --cc arch/x86/kvm/vmx/vmx.h
index 131d638ba270,3928992de023..000000000000
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@@ -195,9 -196,9 +195,15 @@@ struct vcpu_vmx 
  	u32                   idt_vectoring_info;
  	ulong                 rflags;
  
++<<<<<<< HEAD
 +	struct shared_msr_entry guest_msrs[MAX_NR_SHARED_MSRS];
 +	int                   nmsrs;
 +	int                   save_nmsrs;
++=======
+ 	struct vmx_uret_msr   guest_uret_msrs[MAX_NR_USER_RETURN_MSRS];
+ 	int                   nr_uret_msrs;
+ 	int                   nr_active_uret_msrs;
++>>>>>>> e9bb1ae92d62 (KVM: VMX: Rename vcpu_vmx's "save_nmsrs" to "nr_active_uret_msrs")
  	bool                  guest_msrs_ready;
  #ifdef CONFIG_X86_64
  	u64		      msr_host_kernel_gs_base;
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
