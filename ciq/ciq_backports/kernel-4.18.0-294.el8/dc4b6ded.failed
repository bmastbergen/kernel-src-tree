s390/ap: rename and clarify ap state machine related stuff

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit dc4b6ded3c17ebe1d7532943192b2308c031c43b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dc4b6ded.failed

There is a state machine held for each ap queue device.
The states and functions related to this where somethimes
noted with _sm_ somethimes without. This patch clarifies
and renames all the ap queue state machine related functions,
enums and defines to have a _sm_ in the name.

There is no functional change coming with this patch - it's
only beautifying code.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
(cherry picked from commit dc4b6ded3c17ebe1d7532943192b2308c031c43b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
#	drivers/s390/crypto/ap_bus.h
#	drivers/s390/crypto/ap_queue.c
diff --cc drivers/s390/crypto/ap_bus.c
index 70b945ce5806,64fa66788194..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -362,8 -355,8 +362,13 @@@ void ap_wait(enum ap_sm_wait wait
  			wake_up(&ap_poll_wait);
  			break;
  		}
++<<<<<<< HEAD
 +		/* Fall through */
 +	case AP_WAIT_TIMEOUT:
++=======
+ 		fallthrough;
+ 	case AP_SM_WAIT_TIMEOUT:
++>>>>>>> dc4b6ded3c17 (s390/ap: rename and clarify ap state machine related stuff)
  		spin_lock_bh(&ap_poll_timer_lock);
  		if (!hrtimer_is_queued(&ap_poll_timer)) {
  			hr_time = poll_timeout;
@@@ -388,10 -381,8 +393,10 @@@ void ap_request_timeout(struct timer_li
  {
  	struct ap_queue *aq = from_timer(aq, t, timeout);
  
 +	if (ap_suspend_flag)
 +		return;
  	spin_lock_bh(&aq->lock);
- 	ap_wait(ap_sm_event(aq, AP_EVENT_TIMEOUT));
+ 	ap_wait(ap_sm_event(aq, AP_SM_EVENT_TIMEOUT));
  	spin_unlock_bh(&aq->lock);
  }
  
diff --cc drivers/s390/crypto/ap_bus.h
index 0a20eede0143,1a1d5e3c8d45..000000000000
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@@ -83,20 -83,19 +83,34 @@@ static inline int ap_test_bit(unsigned 
  #define AP_INTR_ENABLED		1	/* AP interrupt enabled */
  
  /*
-  * AP device states
+  * AP queue state machine states
   */
++<<<<<<< HEAD
 +enum ap_state {
 +	AP_STATE_RESET_START,
 +	AP_STATE_RESET_WAIT,
 +	AP_STATE_SETIRQ_WAIT,
 +	AP_STATE_IDLE,
 +	AP_STATE_WORKING,
 +	AP_STATE_QUEUE_FULL,
 +	AP_STATE_SUSPEND_WAIT,
 +	AP_STATE_REMOVE,	/* about to be removed from driver */
 +	AP_STATE_UNBOUND,	/* momentary not bound to a driver */
 +	AP_STATE_BORKED,	/* broken */
 +	NR_AP_STATES
++=======
+ enum ap_sm_state {
+ 	AP_SM_STATE_RESET_START,
+ 	AP_SM_STATE_RESET_WAIT,
+ 	AP_SM_STATE_SETIRQ_WAIT,
+ 	AP_SM_STATE_IDLE,
+ 	AP_SM_STATE_WORKING,
+ 	AP_SM_STATE_QUEUE_FULL,
+ 	AP_SM_STATE_REMOVE,	/* about to be removed from driver */
+ 	AP_SM_STATE_UNBOUND,	/* momentary not bound to a driver */
+ 	AP_SM_STATE_BORKED,	/* broken */
+ 	NR_AP_SM_STATES
++>>>>>>> dc4b6ded3c17 (s390/ap: rename and clarify ap state machine related stuff)
  };
  
  /*
diff --cc drivers/s390/crypto/ap_queue.c
index 7bd5294989aa,688ebebbf98c..000000000000
--- a/drivers/s390/crypto/ap_queue.c
+++ b/drivers/s390/crypto/ap_queue.c
@@@ -252,16 -227,16 +252,16 @@@ static enum ap_sm_wait ap_sm_write(stru
  		aq->requestq_count--;
  		aq->pendingq_count++;
  		if (aq->queue_count < aq->card->queue_depth) {
- 			aq->state = AP_STATE_WORKING;
- 			return AP_WAIT_AGAIN;
+ 			aq->sm_state = AP_SM_STATE_WORKING;
+ 			return AP_SM_WAIT_AGAIN;
  		}
 -		fallthrough;
 +		/* fall through */
  	case AP_RESPONSE_Q_FULL:
- 		aq->state = AP_STATE_QUEUE_FULL;
- 		return AP_WAIT_INTERRUPT;
+ 		aq->sm_state = AP_SM_STATE_QUEUE_FULL;
+ 		return AP_SM_WAIT_INTERRUPT;
  	case AP_RESPONSE_RESET_IN_PROGRESS:
- 		aq->state = AP_STATE_RESET_WAIT;
- 		return AP_WAIT_TIMEOUT;
+ 		aq->sm_state = AP_SM_STATE_RESET_WAIT;
+ 		return AP_SM_WAIT_TIMEOUT;
  	case AP_RESPONSE_MESSAGE_TOO_BIG:
  	case AP_RESPONSE_REQ_FAC_NOT_INST:
  		list_del_init(&ap_msg->list);
@@@ -380,59 -355,55 +380,70 @@@ static enum ap_sm_wait ap_sm_setirq_wai
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  		if (aq->queue_count > 0)
++<<<<<<< HEAD
 +			return AP_WAIT_AGAIN;
 +		/* fallthrough */
++=======
+ 			return AP_SM_WAIT_AGAIN;
+ 		fallthrough;
++>>>>>>> dc4b6ded3c17 (s390/ap: rename and clarify ap state machine related stuff)
  	case AP_RESPONSE_NO_PENDING_REPLY:
- 		return AP_WAIT_TIMEOUT;
+ 		return AP_SM_WAIT_TIMEOUT;
  	default:
- 		aq->state = AP_STATE_BORKED;
- 		return AP_WAIT_NONE;
+ 		aq->sm_state = AP_SM_STATE_BORKED;
+ 		return AP_SM_WAIT_NONE;
  	}
  }
  
  /*
   * AP state machine jump table
   */
- static ap_func_t *ap_jumptable[NR_AP_STATES][NR_AP_EVENTS] = {
- 	[AP_STATE_RESET_START] = {
- 		[AP_EVENT_POLL] = ap_sm_reset,
- 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ static ap_func_t *ap_jumptable[NR_AP_SM_STATES][NR_AP_SM_EVENTS] = {
+ 	[AP_SM_STATE_RESET_START] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_reset,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
  	},
- 	[AP_STATE_RESET_WAIT] = {
- 		[AP_EVENT_POLL] = ap_sm_reset_wait,
- 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	[AP_SM_STATE_RESET_WAIT] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_reset_wait,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
  	},
- 	[AP_STATE_SETIRQ_WAIT] = {
- 		[AP_EVENT_POLL] = ap_sm_setirq_wait,
- 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	[AP_SM_STATE_SETIRQ_WAIT] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_setirq_wait,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
  	},
- 	[AP_STATE_IDLE] = {
- 		[AP_EVENT_POLL] = ap_sm_write,
- 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	[AP_SM_STATE_IDLE] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_write,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
  	},
- 	[AP_STATE_WORKING] = {
- 		[AP_EVENT_POLL] = ap_sm_read_write,
- 		[AP_EVENT_TIMEOUT] = ap_sm_reset,
+ 	[AP_SM_STATE_WORKING] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_read_write,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,
  	},
- 	[AP_STATE_QUEUE_FULL] = {
- 		[AP_EVENT_POLL] = ap_sm_read,
- 		[AP_EVENT_TIMEOUT] = ap_sm_reset,
+ 	[AP_SM_STATE_QUEUE_FULL] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_read,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,
  	},
++<<<<<<< HEAD
 +	[AP_STATE_SUSPEND_WAIT] = {
 +		[AP_EVENT_POLL] = ap_sm_suspend_read,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
 +	},
 +	[AP_STATE_REMOVE] = {
 +		[AP_EVENT_POLL] = ap_sm_nop,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
++=======
+ 	[AP_SM_STATE_REMOVE] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_nop,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
++>>>>>>> dc4b6ded3c17 (s390/ap: rename and clarify ap state machine related stuff)
  	},
- 	[AP_STATE_UNBOUND] = {
- 		[AP_EVENT_POLL] = ap_sm_nop,
- 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	[AP_SM_STATE_UNBOUND] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_nop,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
  	},
- 	[AP_STATE_BORKED] = {
- 		[AP_EVENT_POLL] = ap_sm_nop,
- 		[AP_EVENT_TIMEOUT] = ap_sm_nop,
+ 	[AP_SM_STATE_BORKED] = {
+ 		[AP_SM_EVENT_POLL] = ap_sm_nop,
+ 		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
  	},
  };
  
* Unmerged path drivers/s390/crypto/ap_bus.c
* Unmerged path drivers/s390/crypto/ap_bus.h
* Unmerged path drivers/s390/crypto/ap_queue.c
