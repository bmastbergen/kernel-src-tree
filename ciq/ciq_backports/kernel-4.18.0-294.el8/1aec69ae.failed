x86/platform/uv: Fix missing OEM_TABLE_ID

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mike Travis <mike.travis@hpe.com>
commit 1aec69ae56be28b5fd3c9daead5f3840c30153c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1aec69ae.failed

Testing shows a problem in that the OEM_TABLE_ID was missing for
hubless systems.  This is used to determine the APIC type (legacy or
extended).  Add the OEM_TABLE_ID to the early hubless processing.

Fixes: 1e61f5a95f191 ("Add and decode Arch Type in UVsystab")
	Signed-off-by: Mike Travis <mike.travis@hpe.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20201105222741.157029-2-mike.travis@hpe.com
(cherry picked from commit 1aec69ae56be28b5fd3c9daead5f3840c30153c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index a0164b2ab643,a5794794ea59..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -309,14 -292,98 +309,92 @@@ static void __init uv_stringify(int len
  	strncpy(to, from, len-1);
  }
  
++<<<<<<< HEAD
 +static int __init uv_set_system_type(char *_oem_id)
++=======
+ /* Find UV arch type entry in UVsystab */
+ static unsigned long __init early_find_archtype(struct uv_systab *st)
+ {
+ 	int i;
+ 
+ 	for (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {
+ 		unsigned long ptr = st->entry[i].offset;
+ 
+ 		if (!ptr)
+ 			continue;
+ 		ptr += (unsigned long)st;
+ 		if (st->entry[i].type == UV_SYSTAB_TYPE_ARCH_TYPE)
+ 			return ptr;
+ 	}
+ 	return 0;
+ }
+ 
+ /* Validate UV arch type field in UVsystab */
+ static int __init decode_arch_type(unsigned long ptr)
+ {
+ 	struct uv_arch_type_entry *uv_ate = (struct uv_arch_type_entry *)ptr;
+ 	int n = strlen(uv_ate->archtype);
+ 
+ 	if (n > 0 && n < sizeof(uv_ate->archtype)) {
+ 		pr_info("UV: UVarchtype received from BIOS\n");
+ 		uv_stringify(UV_AT_SIZE, uv_archtype, uv_ate->archtype);
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ /* Determine if UV arch type entry might exist in UVsystab */
+ static int __init early_get_arch_type(void)
+ {
+ 	unsigned long uvst_physaddr, uvst_size, ptr;
+ 	struct uv_systab *st;
+ 	u32 rev;
+ 	int ret;
+ 
+ 	uvst_physaddr = get_uv_systab_phys(0);
+ 	if (!uvst_physaddr)
+ 		return 0;
+ 
+ 	st = early_memremap_ro(uvst_physaddr, sizeof(struct uv_systab));
+ 	if (!st) {
+ 		pr_err("UV: Cannot access UVsystab, remap failed\n");
+ 		return 0;
+ 	}
+ 
+ 	rev = st->revision;
+ 	if (rev < UV_SYSTAB_VERSION_UV5) {
+ 		early_memunmap(st, sizeof(struct uv_systab));
+ 		return 0;
+ 	}
+ 
+ 	uvst_size = st->size;
+ 	early_memunmap(st, sizeof(struct uv_systab));
+ 	st = early_memremap_ro(uvst_physaddr, uvst_size);
+ 	if (!st) {
+ 		pr_err("UV: Cannot access UVarchtype, remap failed\n");
+ 		return 0;
+ 	}
+ 
+ 	ptr = early_find_archtype(st);
+ 	if (!ptr) {
+ 		early_memunmap(st, uvst_size);
+ 		return 0;
+ 	}
+ 
+ 	ret = decode_arch_type(ptr);
+ 	early_memunmap(st, uvst_size);
+ 	return ret;
+ }
+ 
+ static int __init uv_set_system_type(char *_oem_id, char *_oem_table_id)
++>>>>>>> 1aec69ae56be (x86/platform/uv: Fix missing OEM_TABLE_ID)
  {
 -	/* Save OEM_ID passed from ACPI MADT */
 +	/* Save OEM ID */
  	uv_stringify(sizeof(oem_id), oem_id, _oem_id);
  
 -	/* Check if BIOS sent us a UVarchtype */
 -	if (!early_get_arch_type())
 -
 -		/* If not use OEM ID for UVarchtype */
 -		uv_stringify(UV_AT_SIZE, uv_archtype, _oem_id);
 -
 -	/* Check if not hubbed */
 -	if (strncmp(uv_archtype, "SGI", 3) != 0) {
 -
 -		/* (Not hubbed), check if not hubless */
 -		if (strncmp(uv_archtype, "NSGI", 4) != 0)
 -
 -			/* (Not hubless), not a UV */
 +	/* Set hubless type if true */
 +	if (strncmp(oem_id, "SGI", 3) != 0) {
 +		if (strncmp(oem_id, "NSGI", 4) != 0)
  			return 0;
  
  		/* UV4 Hubless: CH */
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
