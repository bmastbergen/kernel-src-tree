Bluetooth: btusb: Helper function to download firmware to Intel adapters

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Kiran K <kiran.k@intel.com>
commit 3f43a37838d5b5d00419b167a22b9b0dc4c33732
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3f43a378.failed

Define a helper function to download firmware for new generation Intel
controllers

	Signed-off-by: Kiran K <kiran.k@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 3f43a37838d5b5d00419b167a22b9b0dc4c33732)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btusb.c
diff --cc drivers/bluetooth/btusb.c
index 16b4132259d9,f8966284d8e6..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -2187,38 -2385,194 +2187,221 @@@ static bool btusb_setup_intel_new_get_f
  	return true;
  }
  
 -static void btusb_setup_intel_newgen_get_fw_name(const struct intel_version_tlv *ver_tlv,
 -						 char *fw_name, size_t len,
 -						 const char *suffix)
 +static int btusb_setup_intel_new(struct hci_dev *hdev)
  {
++<<<<<<< HEAD
++=======
+ 	/* The firmware file name for new generation controllers will be
+ 	 * ibt-<cnvi_top type+cnvi_top step>-<cnvr_top type+cnvr_top step>
+ 	 */
+ 	snprintf(fw_name, len, "intel/ibt-%04x-%04x.%s",
+ 		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvi_top),
+ 					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvi_top)),
+ 		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvr_top),
+ 					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvr_top)),
+ 		 suffix);
+ }
+ 
+ static int btusb_intel_download_firmware_newgen(struct hci_dev *hdev,
+ 						struct intel_version_tlv *ver,
+ 						u32 *boot_param)
+ {
+ 	const struct firmware *fw;
+ 	char fwname[64];
+ 	int err;
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 
+ 	if (!ver || !boot_param)
+ 		return -EINVAL;
+ 
+ 	/* The hardware platform number has a fixed value of 0x37 and
+ 	 * for now only accept this single value.
+ 	 */
+ 	if (INTEL_HW_PLATFORM(ver->cnvi_bt) != 0x37) {
+ 		bt_dev_err(hdev, "Unsupported Intel hardware platform (0x%2x)",
+ 			   INTEL_HW_PLATFORM(ver->cnvi_bt));
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* The firmware variant determines if the device is in bootloader
+ 	 * mode or is running operational firmware. The value 0x03 identifies
+ 	 * the bootloader and the value 0x23 identifies the operational
+ 	 * firmware.
+ 	 *
+ 	 * When the operational firmware is already present, then only
+ 	 * the check for valid Bluetooth device address is needed. This
+ 	 * determines if the device will be added as configured or
+ 	 * unconfigured controller.
+ 	 *
+ 	 * It is not possible to use the Secure Boot Parameters in this
+ 	 * case since that command is only available in bootloader mode.
+ 	 */
+ 	if (ver->img_type == 0x03) {
+ 		clear_bit(BTUSB_BOOTLOADER, &data->flags);
+ 		btintel_check_bdaddr(hdev);
+ 		return 0;
+ 	}
+ 
+ 	/* Check for supported iBT hardware variants of this firmware
+ 	 * loading method.
+ 	 *
+ 	 * This check has been put in place to ensure correct forward
+ 	 * compatibility options when newer hardware variants come along.
+ 	 */
+ 	switch (INTEL_HW_VARIANT(ver->cnvi_bt)) {
+ 	case 0x17:	/* TyP */
+ 	case 0x18:	/* Slr */
+ 	case 0x19:	/* Slr-F */
+ 		break;
+ 	default:
+ 		bt_dev_err(hdev, "Unsupported Intel hardware variant (0x%x)",
+ 			   INTEL_HW_VARIANT(ver->cnvi_bt));
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If the device is not in bootloader mode, then the only possible
+ 	 * choice is to return an error and abort the device initialization.
+ 	 */
+ 	if (ver->img_type != 0x01) {
+ 		bt_dev_err(hdev, "Unsupported Intel firmware variant (0x%x)",
+ 			   ver->img_type);
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* It is required that every single firmware fragment is acknowledged
+ 	 * with a command complete event. If the boot parameters indicate
+ 	 * that this bootloader does not send them, then abort the setup.
+ 	 */
+ 	if (ver->limited_cce != 0x00) {
+ 		bt_dev_err(hdev, "Unsupported Intel firmware loading method (0x%x)",
+ 			   ver->limited_cce);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Secure boot engine type should be either 1 (ECDSA) or 0 (RSA) */
+ 	if (ver->sbe_type > 0x01) {
+ 		bt_dev_err(hdev, "Unsupported Intel secure boot engine type (0x%x)",
+ 			   ver->sbe_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If the OTP has no valid Bluetooth device address, then there will
+ 	 * also be no valid address for the operational firmware.
+ 	 */
+ 	if (!bacmp(&ver->otp_bd_addr, BDADDR_ANY)) {
+ 		bt_dev_info(hdev, "No device address configured");
+ 		set_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);
+ 	}
+ 
+ 	btusb_setup_intel_newgen_get_fw_name(ver, fwname, sizeof(fwname), "sfi");
+ 	err = request_firmware(&fw, fwname, &hdev->dev);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to load Intel firmware file (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	bt_dev_info(hdev, "Found device firmware: %s", fwname);
+ 
+ 	if (fw->size < 644) {
+ 		bt_dev_err(hdev, "Invalid size of firmware file (%zu)",
+ 			   fw->size);
+ 		err = -EBADF;
+ 		goto done;
+ 	}
+ 
+ 	set_bit(BTUSB_DOWNLOADING, &data->flags);
+ 
+ 	/* Start firmware downloading and get boot parameter */
+ 	err = btintel_download_firmware_newgen(hdev, fw, boot_param,
+ 					       INTEL_HW_VARIANT(ver->cnvi_bt),
+ 					       ver->sbe_type);
+ 	if (err < 0) {
+ 		/* When FW download fails, send Intel Reset to retry
+ 		 * FW download.
+ 		 */
+ 		btintel_reset_to_bootloader(hdev);
+ 		goto done;
+ 	}
+ 	set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
+ 
+ 	bt_dev_info(hdev, "Waiting for firmware download to complete");
+ 
+ 	/* Before switching the device into operational mode and with that
+ 	 * booting the loaded firmware, wait for the bootloader notification
+ 	 * that all fragments have been successfully received.
+ 	 *
+ 	 * When the event processing receives the notification, then the
+ 	 * BTUSB_DOWNLOADING flag will be cleared.
+ 	 *
+ 	 * The firmware loading should not take longer than 5 seconds
+ 	 * and thus just timeout if that happens and fail the setup
+ 	 * of this device.
+ 	 */
+ 	err = wait_on_bit_timeout(&data->flags, BTUSB_DOWNLOADING,
+ 				  TASK_INTERRUPTIBLE,
+ 				  msecs_to_jiffies(5000));
+ 	if (err == -EINTR) {
+ 		bt_dev_err(hdev, "Firmware loading interrupted");
+ 		goto done;
+ 	}
+ 
+ 	if (err) {
+ 		bt_dev_err(hdev, "Firmware loading timeout");
+ 		err = -ETIMEDOUT;
+ 		btintel_reset_to_bootloader(hdev);
+ 		goto done;
+ 	}
+ 
+ 	if (test_bit(BTUSB_FIRMWARE_FAILED, &data->flags)) {
+ 		bt_dev_err(hdev, "Firmware loading failed");
+ 		err = -ENOEXEC;
+ 		goto done;
+ 	}
+ 
+ done:
+ 	release_firmware(fw);
+ 	return err;
+ }
+ 
+ static int btusb_intel_download_firmware(struct hci_dev *hdev,
+ 					 struct intel_version *ver,
+ 					 struct intel_boot_params *params,
+ 					 u32 *boot_param)
+ {
+ 	const struct firmware *fw;
+ 	char fwname[64];
+ 	int err;
++>>>>>>> 3f43a37838d5 (Bluetooth: btusb: Helper function to download firmware to Intel adapters)
  	struct btusb_data *data = hci_get_drvdata(hdev);
 +	struct intel_version ver;
 +	struct intel_boot_params params;
 +	const struct firmware *fw;
 +	u32 boot_param;
 +	char fwname[64];
 +	ktime_t calltime, delta, rettime;
 +	unsigned long long duration;
 +	int err;
  
 -	if (!ver || !params)
 -		return -EINVAL;
 +	BT_DBG("%s", hdev->name);
 +
 +	/* Set the default boot parameter to 0x0 and it is updated to
 +	 * SKU specific boot parameter after reading Intel_Write_Boot_Params
 +	 * command while downloading the firmware.
 +	 */
 +	boot_param = 0x00000000;
 +
 +	calltime = ktime_get();
 +
 +	/* Read the Intel version information to determine if the device
 +	 * is in bootloader mode or if it already has operational firmware
 +	 * loaded.
 +	 */
 +	err = btintel_read_version(hdev, &ver);
 +	if (err) {
 +		bt_dev_err(hdev, "Intel Read version failed (%d)", err);
 +		btintel_reset_to_bootloader(hdev);
 +		return err;
 +	}
  
  	/* The hardware platform number has a fixed value of 0x37 and
  	 * for now only accept this single value.
@@@ -2487,6 -2895,134 +2670,137 @@@ finish
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int btusb_setup_intel_newgen(struct hci_dev *hdev)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	u32 boot_param;
+ 	char ddcname[64];
+ 	ktime_t calltime, delta, rettime;
+ 	unsigned long long duration;
+ 	int err;
+ 	struct intel_debug_features features;
+ 	struct intel_version_tlv version;
+ 
+ 	bt_dev_dbg(hdev, "");
+ 
+ 	/* Set the default boot parameter to 0x0 and it is updated to
+ 	 * SKU specific boot parameter after reading Intel_Write_Boot_Params
+ 	 * command while downloading the firmware.
+ 	 */
+ 	boot_param = 0x00000000;
+ 
+ 	calltime = ktime_get();
+ 
+ 	/* Read the Intel version information to determine if the device
+ 	 * is in bootloader mode or if it already has operational firmware
+ 	 * loaded.
+ 	 */
+ 	err = btintel_read_version_tlv(hdev, &version);
+ 	if (err) {
+ 		bt_dev_err(hdev, "Intel Read version failed (%d)", err);
+ 		btintel_reset_to_bootloader(hdev);
+ 		return err;
+ 	}
+ 
+ 	btintel_version_info_tlv(hdev, &version);
+ 
+ 	err = btusb_intel_download_firmware_newgen(hdev, &version, &boot_param);
+ 	if (err)
+ 		return err;
+ 
+ 	/* check if controller is already having an operational firmware */
+ 	if (version.img_type == 0x03)
+ 		goto finish;
+ 
+ 	rettime = ktime_get();
+ 	delta = ktime_sub(rettime, calltime);
+ 	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
+ 
+ 	bt_dev_info(hdev, "Firmware loaded in %llu usecs", duration);
+ 
+ 	calltime = ktime_get();
+ 
+ 	set_bit(BTUSB_BOOTING, &data->flags);
+ 
+ 	err = btintel_send_intel_reset(hdev, boot_param);
+ 	if (err) {
+ 		bt_dev_err(hdev, "Intel Soft Reset failed (%d)", err);
+ 		btintel_reset_to_bootloader(hdev);
+ 		return err;
+ 	}
+ 
+ 	/* The bootloader will not indicate when the device is ready. This
+ 	 * is done by the operational firmware sending bootup notification.
+ 	 *
+ 	 * Booting into operational firmware should not take longer than
+ 	 * 1 second. However if that happens, then just fail the setup
+ 	 * since something went wrong.
+ 	 */
+ 	bt_dev_info(hdev, "Waiting for device to boot");
+ 
+ 	err = wait_on_bit_timeout(&data->flags, BTUSB_BOOTING,
+ 				  TASK_INTERRUPTIBLE,
+ 				  msecs_to_jiffies(1000));
+ 
+ 	if (err == -EINTR) {
+ 		bt_dev_err(hdev, "Device boot interrupted");
+ 		return -EINTR;
+ 	}
+ 
+ 	if (err) {
+ 		bt_dev_err(hdev, "Device boot timeout");
+ 		btintel_reset_to_bootloader(hdev);
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	rettime = ktime_get();
+ 	delta = ktime_sub(rettime, calltime);
+ 	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
+ 
+ 	bt_dev_info(hdev, "Device booted in %llu usecs", duration);
+ 
+ 	clear_bit(BTUSB_BOOTLOADER, &data->flags);
+ 
+ 	btusb_setup_intel_newgen_get_fw_name(&version, ddcname, sizeof(ddcname),
+ 					     "ddc");
+ 	/* Once the device is running in operational mode, it needs to
+ 	 * apply the device configuration (DDC) parameters.
+ 	 *
+ 	 * The device can work without DDC parameters, so even if it
+ 	 * fails to load the file, no need to fail the setup.
+ 	 */
+ 	btintel_load_ddc_config(hdev, ddcname);
+ 
+ 	/* Read the Intel supported features and if new exception formats
+ 	 * supported, need to load the additional DDC config to enable.
+ 	 */
+ 	btintel_read_debug_features(hdev, &features);
+ 
+ 	/* Set DDC mask for available debug features */
+ 	btintel_set_debug_features(hdev, &features);
+ 
+ 	/* Read the Intel version information after loading the FW  */
+ 	err = btintel_read_version_tlv(hdev, &version);
+ 	if (err)
+ 		return err;
+ 
+ 	btintel_version_info_tlv(hdev, &version);
+ 
+ finish:
+ 	/* Set the event mask for Intel specific vendor events. This enables
+ 	 * a few extra events that are useful during general operation. It
+ 	 * does not enable any debugging related events.
+ 	 *
+ 	 * The device will function correctly without these events enabled
+ 	 * and thus no need to fail the setup.
+ 	 */
+ 	btintel_set_event_mask(hdev, false);
+ 
+ 	return 0;
+ }
++>>>>>>> 3f43a37838d5 (Bluetooth: btusb: Helper function to download firmware to Intel adapters)
  static int btusb_shutdown_intel(struct hci_dev *hdev)
  {
  	struct sk_buff *skb;
* Unmerged path drivers/bluetooth/btusb.c
