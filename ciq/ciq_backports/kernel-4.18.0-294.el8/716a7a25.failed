driver core: fw_devlink: Add support for batching fwnode parsing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 716a7a25969003d82ab738179c3f1068a120ed11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/716a7a25.failed

The amount of time spent parsing fwnodes of devices can become really
high if the devices are added in an non-ideal order. Worst case can be
O(N^2) when N devices are added. But this can be optimized to O(N) by
adding all the devices and then parsing all their fwnodes in one batch.

This commit adds fw_devlink_pause() and fw_devlink_resume() to allow
doing this.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20200515053500.215929-4-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 716a7a25969003d82ab738179c3f1068a120ed11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/fwnode.h
diff --cc drivers/base/core.c
index a7a93bf98225,84c569726d75..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -44,6 -45,13 +44,16 @@@ early_param("sysfs.deprecated", sysfs_d
  #endif
  
  /* Device links support. */
++<<<<<<< HEAD
++=======
+ static LIST_HEAD(wait_for_suppliers);
+ static DEFINE_MUTEX(wfs_lock);
+ static LIST_HEAD(deferred_sync);
+ static unsigned int defer_sync_state_count = 1;
+ static unsigned int defer_fw_devlink_count;
+ static DEFINE_MUTEX(defer_fw_devlink_lock);
+ static bool fw_devlink_is_permissive(void);
++>>>>>>> 716a7a259690 (driver core: fw_devlink: Add support for batching fwnode parsing)
  
  #ifdef CONFIG_SRCU
  static DEFINE_MUTEX(device_links_lock);
@@@ -448,6 -468,74 +458,77 @@@ reorder
  }
  EXPORT_SYMBOL_GPL(device_link_add);
  
++<<<<<<< HEAD
++=======
+ /**
+  * device_link_wait_for_supplier - Add device to wait_for_suppliers list
+  * @consumer: Consumer device
+  *
+  * Marks the @consumer device as waiting for suppliers to become available by
+  * adding it to the wait_for_suppliers list. The consumer device will never be
+  * probed until it's removed from the wait_for_suppliers list.
+  *
+  * The caller is responsible for adding the links to the supplier devices once
+  * they are available and removing the @consumer device from the
+  * wait_for_suppliers list once links to all the suppliers have been created.
+  *
+  * This function is NOT meant to be called from the probe function of the
+  * consumer but rather from code that creates/adds the consumer device.
+  */
+ static void device_link_wait_for_supplier(struct device *consumer,
+ 					  bool need_for_probe)
+ {
+ 	mutex_lock(&wfs_lock);
+ 	list_add_tail(&consumer->links.needs_suppliers, &wait_for_suppliers);
+ 	consumer->links.need_for_probe = need_for_probe;
+ 	mutex_unlock(&wfs_lock);
+ }
+ 
+ static void device_link_wait_for_mandatory_supplier(struct device *consumer)
+ {
+ 	device_link_wait_for_supplier(consumer, true);
+ }
+ 
+ static void device_link_wait_for_optional_supplier(struct device *consumer)
+ {
+ 	device_link_wait_for_supplier(consumer, false);
+ }
+ 
+ /**
+  * device_link_add_missing_supplier_links - Add links from consumer devices to
+  *					    supplier devices, leaving any
+  *					    consumer with inactive suppliers on
+  *					    the wait_for_suppliers list
+  *
+  * Loops through all consumers waiting on suppliers and tries to add all their
+  * supplier links. If that succeeds, the consumer device is removed from
+  * wait_for_suppliers list. Otherwise, they are left in the wait_for_suppliers
+  * list.  Devices left on the wait_for_suppliers list will not be probed.
+  *
+  * The fwnode add_links callback is expected to return 0 if it has found and
+  * added all the supplier links for the consumer device. It should return an
+  * error if it isn't able to do so.
+  *
+  * The caller of device_link_wait_for_supplier() is expected to call this once
+  * it's aware of potential suppliers becoming available.
+  */
+ static void device_link_add_missing_supplier_links(void)
+ {
+ 	struct device *dev, *tmp;
+ 
+ 	mutex_lock(&wfs_lock);
+ 	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
+ 				 links.needs_suppliers) {
+ 		int ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+ 		if (!ret)
+ 			list_del_init(&dev->links.needs_suppliers);
+ 		else if (ret != -ENODEV || fw_devlink_is_permissive())
+ 			dev->links.need_for_probe = false;
+ 	}
+ 	mutex_unlock(&wfs_lock);
+ }
+ 
++>>>>>>> 716a7a259690 (driver core: fw_devlink: Add support for batching fwnode parsing)
  static void device_link_free(struct device_link *link)
  {
  	while (refcount_dec_not_one(&link->rpm_active))
@@@ -918,6 -1176,120 +999,123 @@@ static bool fw_devlink_is_permissive(vo
  	return fw_devlink_flags == DL_FLAG_SYNC_STATE_ONLY;
  }
  
++<<<<<<< HEAD
++=======
+ static void fw_devlink_link_device(struct device *dev)
+ {
+ 	int fw_ret;
+ 
+ 	if (!fw_devlink_flags)
+ 		return;
+ 
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	if (!defer_fw_devlink_count)
+ 		device_link_add_missing_supplier_links();
+ 
+ 	/*
+ 	 * The device's fwnode not having add_links() doesn't affect if other
+ 	 * consumers can find this device as a supplier.  So, this check is
+ 	 * intentionally placed after device_link_add_missing_supplier_links().
+ 	 */
+ 	if (!fwnode_has_op(dev->fwnode, add_links))
+ 		goto out;
+ 
+ 	/*
+ 	 * If fw_devlink is being deferred, assume all devices have mandatory
+ 	 * suppliers they need to link to later. Then, when the fw_devlink is
+ 	 * resumed, all these devices will get a chance to try and link to any
+ 	 * suppliers they have.
+ 	 */
+ 	if (!defer_fw_devlink_count) {
+ 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+ 		if (fw_ret == -ENODEV && fw_devlink_is_permissive())
+ 			fw_ret = -EAGAIN;
+ 	} else {
+ 		fw_ret = -ENODEV;
+ 	}
+ 
+ 	if (fw_ret == -ENODEV)
+ 		device_link_wait_for_mandatory_supplier(dev);
+ 	else if (fw_ret)
+ 		device_link_wait_for_optional_supplier(dev);
+ 
+ out:
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ }
+ 
+ /**
+  * fw_devlink_pause - Pause parsing of fwnode to create device links
+  *
+  * Calling this function defers any fwnode parsing to create device links until
+  * fw_devlink_resume() is called. Both these functions are ref counted and the
+  * caller needs to match the calls.
+  *
+  * While fw_devlink is paused:
+  * - Any device that is added won't have its fwnode parsed to create device
+  *   links.
+  * - The probe of the device will also be deferred during this period.
+  * - Any devices that were already added, but waiting for suppliers won't be
+  *   able to link to newly added devices.
+  *
+  * Once fw_devlink_resume():
+  * - All the fwnodes that was not parsed will be parsed.
+  * - All the devices that were deferred probing will be reattempted if they
+  *   aren't waiting for any more suppliers.
+  *
+  * This pair of functions, is mainly meant to optimize the parsing of fwnodes
+  * when a lot of devices that need to link to each other are added in a short
+  * interval of time. For example, adding all the top level devices in a system.
+  *
+  * For example, if N devices are added and:
+  * - All the consumers are added before their suppliers
+  * - All the suppliers of the N devices are part of the N devices
+  *
+  * Then:
+  *
+  * - With the use of fw_devlink_pause() and fw_devlink_resume(), each device
+  *   will only need one parsing of its fwnode because it is guaranteed to find
+  *   all the supplier devices already registered and ready to link to. It won't
+  *   have to do another pass later to find one or more suppliers it couldn't
+  *   find in the first parse of the fwnode. So, we'll only need O(N) fwnode
+  *   parses.
+  *
+  * - Without the use of fw_devlink_pause() and fw_devlink_resume(), we would
+  *   end up doing O(N^2) parses of fwnodes because every device that's added is
+  *   guaranteed to trigger a parse of the fwnode of every device added before
+  *   it. This O(N^2) parse is made worse by the fact that when a fwnode of a
+  *   device is parsed, all it descendant devices might need to have their
+  *   fwnodes parsed too (even if the devices themselves aren't added).
+  */
+ void fw_devlink_pause(void)
+ {
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	defer_fw_devlink_count++;
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ }
+ 
+ /** fw_devlink_resume - Resume parsing of fwnode to create device links
+  *
+  * This function is used in conjunction with fw_devlink_pause() and is ref
+  * counted. See documentation for fw_devlink_pause() for more details.
+  */
+ void fw_devlink_resume(void)
+ {
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	if (!defer_fw_devlink_count) {
+ 		WARN(true, "Unmatched fw_devlink pause/resume!");
+ 		goto out;
+ 	}
+ 
+ 	defer_fw_devlink_count--;
+ 	if (defer_fw_devlink_count)
+ 		goto out;
+ 
+ 	device_link_add_missing_supplier_links();
+ 	driver_deferred_probe_force_trigger();
+ out:
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ }
++>>>>>>> 716a7a259690 (driver core: fw_devlink: Add support for batching fwnode parsing)
  /* Device links support end. */
  
  int (*platform_notify)(struct device *dev) = NULL;
diff --cc include/linux/fwnode.h
index ba3d4116da4f,9506f8ec0974..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -132,4 -170,8 +132,11 @@@ struct fwnode_operations 
  	} while (false)
  #define get_dev_from_fwnode(fwnode)	get_device((fwnode)->dev)
  
++<<<<<<< HEAD
++=======
+ extern u32 fw_devlink_get_flags(void);
+ void fw_devlink_pause(void);
+ void fw_devlink_resume(void);
+ 
++>>>>>>> 716a7a259690 (driver core: fw_devlink: Add support for batching fwnode parsing)
  #endif
diff --git a/drivers/base/base.h b/drivers/base/base.h
index 2c986e1a3b4f..7c6dc08a457d 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -141,6 +141,7 @@ extern char *make_class_name(const char *name, struct kobject *kobj);
 extern int devres_release_all(struct device *dev);
 extern void device_block_probing(void);
 extern void device_unblock_probing(void);
+extern void driver_deferred_probe_force_trigger(void);
 
 /* /sys/devices directory */
 extern struct kset *devices_kset;
* Unmerged path drivers/base/core.c
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index bce69e9be50e..97020f0f1774 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -180,6 +180,14 @@ static bool driver_deferred_probe_enable = false;
  * again.
  */
 static void driver_deferred_probe_trigger(void)
+{
+	if (!driver_deferred_probe_enable)
+		return;
+
+	driver_deferred_probe_force_trigger();
+}
+
+void driver_deferred_probe_force_trigger(void)
 {
 	if (!driver_deferred_probe_enable)
 		return;
* Unmerged path include/linux/fwnode.h
