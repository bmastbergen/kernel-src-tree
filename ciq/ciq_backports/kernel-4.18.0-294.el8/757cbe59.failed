LSM: new method: ->sb_add_mnt_opt()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 757cbe597fe8490c7c0a9650ebe5d60195f151d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/757cbe59.failed

Adding options to growing mnt_opts.  NFS kludge with passing
context= down into non-text-options mount switched to it, and
with that the last use of ->sb_parse_opts_str() is gone.

	Reviewed-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 757cbe597fe8490c7c0a9650ebe5d60195f151d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/lsm_hooks.h
#	include/linux/security.h
#	security/security.c
#	security/selinux/hooks.c
diff --cc include/linux/lsm_hooks.h
index b8d4d4fd9a29,9a0bdf91e646..000000000000
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@@ -1490,7 -1479,8 +1490,12 @@@ union security_list_options 
  					struct super_block *newsb,
  					unsigned long kern_flags,
  					unsigned long *set_kern_flags);
++<<<<<<< HEAD
 +	int (*sb_parse_opts_str)(char *options, struct security_mnt_opts *opts);
++=======
+ 	int (*sb_add_mnt_opt)(const char *option, const char *val, int len,
+ 			      void **mnt_opts);
++>>>>>>> 757cbe597fe8 (LSM: new method: ->sb_add_mnt_opt())
  	int (*dentry_init_security)(struct dentry *dentry, int mode,
  					const struct qstr *name, void **ctx,
  					u32 *ctxlen);
diff --cc include/linux/security.h
index ff5f27403021,dbfb5a66babb..000000000000
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@@ -264,7 -240,8 +264,12 @@@ int security_sb_clone_mnt_opts(const st
  				struct super_block *newsb,
  				unsigned long kern_flags,
  				unsigned long *set_kern_flags);
++<<<<<<< HEAD
 +int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts);
++=======
+ int security_add_mnt_opt(const char *option, const char *val,
+ 				int len, void **mnt_opts);
++>>>>>>> 757cbe597fe8 (LSM: new method: ->sb_add_mnt_opt())
  int security_dentry_init_security(struct dentry *dentry, int mode,
  					const struct qstr *name, void **ctx,
  					u32 *ctxlen);
@@@ -614,7 -587,8 +619,12 @@@ static inline int security_sb_clone_mnt
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)
++=======
+ static inline int security_add_mnt_opt(const char *option, const char *val,
+ 					int len, void **mnt_opts)
++>>>>>>> 757cbe597fe8 (LSM: new method: ->sb_add_mnt_opt())
  {
  	return 0;
  }
diff --cc security/security.c
index 7eaa4e984e36,c251278b0297..000000000000
--- a/security/security.c
+++ b/security/security.c
@@@ -441,11 -458,13 +441,19 @@@ int security_sb_clone_mnt_opts(const st
  }
  EXPORT_SYMBOL(security_sb_clone_mnt_opts);
  
++<<<<<<< HEAD
 +int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)
 +{
 +	return call_int_hook(sb_parse_opts_str, 0, options, opts);
++=======
+ int security_add_mnt_opt(const char *option, const char *val, int len,
+ 			 void **mnt_opts)
+ {
+ 	return call_int_hook(sb_add_mnt_opt, -EINVAL,
+ 					option, val, len, mnt_opts);
++>>>>>>> 757cbe597fe8 (LSM: new method: ->sb_add_mnt_opt())
  }
- EXPORT_SYMBOL(security_sb_parse_opts_str);
+ EXPORT_SYMBOL(security_add_mnt_opt);
  
  int security_inode_alloc(struct inode *inode)
  {
diff --cc security/selinux/hooks.c
index 42145010da10,5bc230327bc0..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -1013,124 -1006,75 +1013,196 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +static int selinux_parse_opts_str(char *options,
 +				  struct security_mnt_opts *opts)
 +{
 +	char *p;
 +	char *context = NULL, *defcontext = NULL;
 +	char *fscontext = NULL, *rootcontext = NULL;
 +	int rc, num_mnt_opts = 0;
 +
 +	opts->num_mnt_opts = 0;
 +
 +	/* Standard string-based options. */
 +	while ((p = strsep(&options, "|")) != NULL) {
 +		int token;
 +		substring_t args[MAX_OPT_ARGS];
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +
 +		switch (token) {
 +		case Opt_context:
 +			if (context || defcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			context = match_strdup(&args[0]);
 +			if (!context) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_fscontext:
 +			if (fscontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			fscontext = match_strdup(&args[0]);
 +			if (!fscontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_rootcontext:
 +			if (rootcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			rootcontext = match_strdup(&args[0]);
 +			if (!rootcontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_defcontext:
 +			if (context || defcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			defcontext = match_strdup(&args[0]);
 +			if (!defcontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +		case Opt_labelsupport:
 +			break;
 +		default:
 +			rc = -EINVAL;
 +			pr_warn("SELinux:  unknown mount option\n");
 +			goto out_err;
 +
 +		}
 +	}
 +
 +	rc = -ENOMEM;
 +	opts->mnt_opts = kcalloc(NUM_SEL_MNT_OPTS, sizeof(char *), GFP_KERNEL);
 +	if (!opts->mnt_opts)
 +		goto out_err;
 +
 +	opts->mnt_opts_flags = kcalloc(NUM_SEL_MNT_OPTS, sizeof(int),
 +				       GFP_KERNEL);
 +	if (!opts->mnt_opts_flags)
 +		goto out_err;
 +
 +	if (fscontext) {
 +		opts->mnt_opts[num_mnt_opts] = fscontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = FSCONTEXT_MNT;
 +	}
 +	if (context) {
 +		opts->mnt_opts[num_mnt_opts] = context;
 +		opts->mnt_opts_flags[num_mnt_opts++] = CONTEXT_MNT;
 +	}
 +	if (rootcontext) {
 +		opts->mnt_opts[num_mnt_opts] = rootcontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = ROOTCONTEXT_MNT;
 +	}
 +	if (defcontext) {
 +		opts->mnt_opts[num_mnt_opts] = defcontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = DEFCONTEXT_MNT;
 +	}
 +
 +	opts->num_mnt_opts = num_mnt_opts;
 +	return 0;
 +
 +out_err:
 +	security_free_mnt_opts(opts);
 +	kfree(context);
 +	kfree(defcontext);
 +	kfree(fscontext);
 +	kfree(rootcontext);
++=======
+ static int selinux_add_opt(int token, const char *s, void **mnt_opts)
+ {
+ 	struct selinux_mnt_opts *opts = *mnt_opts;
+ 
+ 	if (token == Opt_seclabel)	/* eaten and completely ignored */
+ 		return 0;
+ 
+ 	if (!opts) {
+ 		opts = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);
+ 		if (!opts)
+ 			return -ENOMEM;
+ 		*mnt_opts = opts;
+ 	}
+ 	if (!s)
+ 		return -ENOMEM;
+ 	switch (token) {
+ 	case Opt_context:
+ 		if (opts->context || opts->defcontext)
+ 			goto Einval;
+ 		opts->context = s;
+ 		break;
+ 	case Opt_fscontext:
+ 		if (opts->fscontext)
+ 			goto Einval;
+ 		opts->fscontext = s;
+ 		break;
+ 	case Opt_rootcontext:
+ 		if (opts->rootcontext)
+ 			goto Einval;
+ 		opts->rootcontext = s;
+ 		break;
+ 	case Opt_defcontext:
+ 		if (opts->context || opts->defcontext)
+ 			goto Einval;
+ 		opts->defcontext = s;
+ 		break;
+ 	}
+ 	return 0;
+ Einval:
+ 	pr_warn(SEL_MOUNT_FAIL_MSG);
+ 	return -EINVAL;
+ }
+ 
+ static int selinux_add_mnt_opt(const char *option, const char *val, int len,
+ 			       void **mnt_opts)
+ {
+ 	int token = Opt_error;
+ 	int rc, i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(tokens); i++) {
+ 		if (strcmp(option, tokens[i].name) == 0) {
+ 			token = tokens[i].opt;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (token == Opt_error)
+ 		return -EINVAL;
+ 
+ 	if (token != Opt_seclabel)
+ 		val = kmemdup_nul(val, len, GFP_KERNEL);
+ 	rc = selinux_add_opt(token, val, mnt_opts);
+ 	if (unlikely(rc)) {
+ 		kfree(val);
+ 		if (*mnt_opts) {
+ 			selinux_free_mnt_opts(*mnt_opts);
+ 			*mnt_opts = NULL;
+ 		}
+ 	}
++>>>>>>> 757cbe597fe8 (LSM: new method: ->sb_add_mnt_opt())
  	return rc;
  }
  
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index 155ae97b9aeb..724e3e544917 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -2106,14 +2106,9 @@ static int nfs23_validate_mount_data(void *options,
 		if (data->context[0]){
 #ifdef CONFIG_SECURITY_SELINUX
 			int rc;
-			char *opts_str = kmalloc(sizeof(data->context) + 8, GFP_KERNEL);
-			if (!opts_str)
-				return -ENOMEM;
-			strcpy(opts_str, "context=");
 			data->context[NFS_MAX_CONTEXT_LEN] = '\0';
-			strcat(opts_str, &data->context[0]);
-			rc = security_sb_parse_opts_str(opts_str, &args->lsm_opts);
-			kfree(opts_str);
+			rc = security_add_mnt_opt("context", data->context,
+					strlen(data->context), &args->lsm_opts);
 			if (rc)
 				return rc;
 #else
* Unmerged path include/linux/lsm_hooks.h
* Unmerged path include/linux/security.h
* Unmerged path security/security.c
* Unmerged path security/selinux/hooks.c
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index 77b0bfb018e5..357d03b8e9d8 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -4635,7 +4635,6 @@ static struct security_hook_list smack_hooks[] __lsm_ro_after_init = {
 	LSM_HOOK_INIT(sb_kern_mount, smack_sb_kern_mount),
 	LSM_HOOK_INIT(sb_statfs, smack_sb_statfs),
 	LSM_HOOK_INIT(sb_set_mnt_opts, smack_set_mnt_opts),
-	LSM_HOOK_INIT(sb_parse_opts_str, smack_parse_opts_str),
 
 	LSM_HOOK_INIT(bprm_set_creds, smack_bprm_set_creds),
 
