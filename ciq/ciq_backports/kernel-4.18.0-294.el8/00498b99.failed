libceph: introduce connection modes and ms_mode option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 00498b994113a871a556f7ff24a4cf8a00611700
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/00498b99.failed

msgr2 supports two connection modes: crc (plain) and secure (on-wire
encryption).  Connection mode is picked by server based on input from
client.

Introduce ms_mode option:

  ms_mode=legacy        - msgr1 (default)
  ms_mode=crc           - crc mode, if denied fail
  ms_mode=secure        - secure mode, if denied fail
  ms_mode=prefer-crc    - crc mode, if denied agree to secure mode
  ms_mode=prefer-secure - secure mode, if denied agree to crc mode

ms_mode affects all connections, we don't separate connections to mons
like it's done in userspace with ms_client_mode vs ms_mon_client_mode.

For now the default is legacy, to be flipped to prefer-crc after some
time.

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 00498b994113a871a556f7ff24a4cf8a00611700)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/ceph_common.c
diff --cc net/ceph/ceph_common.c
index 47dc7ae211b5,271287c5ec12..000000000000
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@@ -266,50 -265,100 +266,135 @@@ enum 
  	Opt_ip,
  	Opt_crush_location,
  	Opt_read_from_replica,
++<<<<<<< HEAD
 +	Opt_last_string,
++=======
+ 	Opt_ms_mode,
++>>>>>>> 00498b994113 (libceph: introduce connection modes and ms_mode option)
  	/* string args above */
  	Opt_share,
 +	Opt_noshare,
  	Opt_crc,
 +	Opt_nocrc,
  	Opt_cephx_require_signatures,
 +	Opt_nocephx_require_signatures,
  	Opt_cephx_sign_messages,
 +	Opt_nocephx_sign_messages,
  	Opt_tcp_nodelay,
 +	Opt_notcp_nodelay,
  	Opt_abort_on_full,
  };
  
 -enum {
 -	Opt_read_from_replica_no,
 -	Opt_read_from_replica_balance,
 -	Opt_read_from_replica_localize,
 +static match_table_t opt_tokens = {
 +	{Opt_osdtimeout, "osdtimeout=%d"},
 +	{Opt_osdkeepalivetimeout, "osdkeepalive=%d"},
 +	{Opt_mount_timeout, "mount_timeout=%d"},
 +	{Opt_osd_idle_ttl, "osd_idle_ttl=%d"},
 +	{Opt_osd_request_timeout, "osd_request_timeout=%d"},
 +	/* int args above */
 +	{Opt_fsid, "fsid=%s"},
 +	{Opt_name, "name=%s"},
 +	{Opt_secret, "secret=%s"},
 +	{Opt_key, "key=%s"},
 +	{Opt_ip, "ip=%s"},
 +	{Opt_crush_location, "crush_location=%s"},
 +	{Opt_read_from_replica, "read_from_replica=%s"},
 +	/* string args above */
 +	{Opt_share, "share"},
 +	{Opt_noshare, "noshare"},
 +	{Opt_crc, "crc"},
 +	{Opt_nocrc, "nocrc"},
 +	{Opt_cephx_require_signatures, "cephx_require_signatures"},
 +	{Opt_nocephx_require_signatures, "nocephx_require_signatures"},
 +	{Opt_cephx_sign_messages, "cephx_sign_messages"},
 +	{Opt_nocephx_sign_messages, "nocephx_sign_messages"},
 +	{Opt_tcp_nodelay, "tcp_nodelay"},
 +	{Opt_notcp_nodelay, "notcp_nodelay"},
 +	{Opt_abort_on_full, "abort_on_full"},
 +	{-1, NULL}
  };
  
++<<<<<<< HEAD
++=======
+ static const struct constant_table ceph_param_read_from_replica[] = {
+ 	{"no",		Opt_read_from_replica_no},
+ 	{"balance",	Opt_read_from_replica_balance},
+ 	{"localize",	Opt_read_from_replica_localize},
+ 	{}
+ };
+ 
+ enum ceph_ms_mode {
+ 	Opt_ms_mode_legacy,
+ 	Opt_ms_mode_crc,
+ 	Opt_ms_mode_secure,
+ 	Opt_ms_mode_prefer_crc,
+ 	Opt_ms_mode_prefer_secure
+ };
+ 
+ static const struct constant_table ceph_param_ms_mode[] = {
+ 	{"legacy",		Opt_ms_mode_legacy},
+ 	{"crc",			Opt_ms_mode_crc},
+ 	{"secure",		Opt_ms_mode_secure},
+ 	{"prefer-crc",		Opt_ms_mode_prefer_crc},
+ 	{"prefer-secure",	Opt_ms_mode_prefer_secure},
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec ceph_parameters[] = {
+ 	fsparam_flag	("abort_on_full",		Opt_abort_on_full),
+ 	fsparam_flag_no ("cephx_require_signatures",	Opt_cephx_require_signatures),
+ 	fsparam_flag_no ("cephx_sign_messages",		Opt_cephx_sign_messages),
+ 	fsparam_flag_no ("crc",				Opt_crc),
+ 	fsparam_string	("crush_location",		Opt_crush_location),
+ 	fsparam_string	("fsid",			Opt_fsid),
+ 	fsparam_string	("ip",				Opt_ip),
+ 	fsparam_string	("key",				Opt_key),
+ 	fsparam_u32	("mount_timeout",		Opt_mount_timeout),
+ 	fsparam_string	("name",			Opt_name),
+ 	fsparam_u32	("osd_idle_ttl",		Opt_osd_idle_ttl),
+ 	fsparam_u32	("osd_request_timeout",		Opt_osd_request_timeout),
+ 	fsparam_u32	("osdkeepalive",		Opt_osdkeepalivetimeout),
+ 	__fsparam	(fs_param_is_s32, "osdtimeout", Opt_osdtimeout,
+ 			 fs_param_deprecated, NULL),
+ 	fsparam_enum	("read_from_replica",		Opt_read_from_replica,
+ 			 ceph_param_read_from_replica),
+ 	fsparam_enum	("ms_mode",			Opt_ms_mode,
+ 			 ceph_param_ms_mode),
+ 	fsparam_string	("secret",			Opt_secret),
+ 	fsparam_flag_no ("share",			Opt_share),
+ 	fsparam_flag_no ("tcp_nodelay",			Opt_tcp_nodelay),
+ 	{}
+ };
+ 
+ struct ceph_options *ceph_alloc_options(void)
+ {
+ 	struct ceph_options *opt;
+ 
+ 	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
+ 	if (!opt)
+ 		return NULL;
+ 
+ 	opt->crush_locs = RB_ROOT;
+ 	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
+ 				GFP_KERNEL);
+ 	if (!opt->mon_addr) {
+ 		kfree(opt);
+ 		return NULL;
+ 	}
+ 
+ 	opt->flags = CEPH_OPT_DEFAULT;
+ 	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
+ 	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
+ 	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
+ 	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
+ 	opt->read_from_replica = CEPH_READ_FROM_REPLICA_DEFAULT;
+ 	opt->con_modes[0] = CEPH_CON_MODE_UNKNOWN;
+ 	opt->con_modes[1] = CEPH_CON_MODE_UNKNOWN;
+ 	return opt;
+ }
+ EXPORT_SYMBOL(ceph_alloc_options);
+ 
++>>>>>>> 00498b994113 (libceph: introduce connection modes and ms_mode option)
  void ceph_destroy_options(struct ceph_options *opt)
  {
  	dout("destroy_options %p\n", opt);
@@@ -370,242 -423,210 +455,281 @@@ out
  	return err;
  }
  
 -int ceph_parse_mon_ips(const char *buf, size_t len, struct ceph_options *opt,
 -		       struct fc_log *l)
 +struct ceph_options *
 +ceph_parse_options(char *options, const char *dev_name,
 +			const char *dev_name_end,
 +			int (*parse_extra_token)(char *c, void *private),
 +			void *private)
  {
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -	int ret;
 +	struct ceph_options *opt;
 +	const char *c;
 +	int err = -ENOMEM;
 +	substring_t argstr[MAX_OPT_ARGS];
  
 -	/* ip1[:port1][,ip2[:port2]...] */
 -	ret = ceph_parse_ips(buf, buf + len, opt->mon_addr, CEPH_MAX_MON,
 -			     &opt->num_mon);
 -	if (ret) {
 -		error_plog(&log, "Failed to parse monitor IPs: %d", ret);
 -		return ret;
 -	}
 +	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
 +	if (!opt)
 +		return ERR_PTR(-ENOMEM);
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(ceph_parse_mon_ips);
 +	opt->crush_locs = RB_ROOT;
 +	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
 +				GFP_KERNEL);
 +	if (!opt->mon_addr)
 +		goto out;
  
 -int ceph_parse_param(struct fs_parameter *param, struct ceph_options *opt,
 -		     struct fc_log *l)
 -{
 -	struct fs_parse_result result;
 -	int token, err;
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -
 -	token = __fs_parse(&log, ceph_parameters, param, &result);
 -	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
 -	if (token < 0)
 -		return token;
 -
 -	switch (token) {
 -	case Opt_ip:
 -		err = ceph_parse_ips(param->string,
 -				     param->string + param->size,
 -				     &opt->my_addr,
 -				     1, NULL);
 -		if (err) {
 -			error_plog(&log, "Failed to parse ip: %d", err);
 -			return err;
 -		}
 -		opt->flags |= CEPH_OPT_MYIP;
 -		break;
 +	dout("parse_options %p options '%s' dev_name '%s'\n", opt, options,
 +	     dev_name);
  
 -	case Opt_fsid:
 -		err = parse_fsid(param->string, &opt->fsid);
 -		if (err) {
 -			error_plog(&log, "Failed to parse fsid: %d", err);
 -			return err;
 -		}
 -		opt->flags |= CEPH_OPT_FSID;
 -		break;
 -	case Opt_name:
 -		kfree(opt->name);
 -		opt->name = param->string;
 -		param->string = NULL;
 -		break;
 -	case Opt_secret:
 -		ceph_crypto_key_destroy(opt->key);
 -		kfree(opt->key);
 +	/* start with defaults */
 +	opt->flags = CEPH_OPT_DEFAULT;
 +	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
 +	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
 +	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
 +	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
 +	opt->read_from_replica = CEPH_READ_FROM_REPLICA_DEFAULT;
  
 -		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 -		if (!opt->key)
 -			return -ENOMEM;
 -		err = ceph_crypto_key_unarmor(opt->key, param->string);
 -		if (err) {
 -			error_plog(&log, "Failed to parse secret: %d", err);
 -			return err;
 -		}
 -		break;
 -	case Opt_key:
 -		ceph_crypto_key_destroy(opt->key);
 -		kfree(opt->key);
 +	/* get mon ip(s) */
 +	/* ip1[:port1][,ip2[:port2]...] */
 +	err = ceph_parse_ips(dev_name, dev_name_end, opt->mon_addr,
 +			     CEPH_MAX_MON, &opt->num_mon);
 +	if (err < 0)
 +		goto out;
  
 -		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 -		if (!opt->key)
 -			return -ENOMEM;
 -		return get_secret(opt->key, param->string, &log);
 -	case Opt_crush_location:
 -		ceph_clear_crush_locs(&opt->crush_locs);
 -		err = ceph_parse_crush_location(param->string,
 -						&opt->crush_locs);
 -		if (err) {
 -			error_plog(&log, "Failed to parse CRUSH location: %d",
 -				   err);
 -			return err;
 +	/* parse mount options */
 +	while ((c = strsep(&options, ",")) != NULL) {
 +		int token, intval;
 +		if (!*c)
 +			continue;
 +		err = -EINVAL;
 +		token = match_token((char *)c, opt_tokens, argstr);
 +		if (token < 0 && parse_extra_token) {
 +			/* extra? */
 +			err = parse_extra_token((char *)c, private);
 +			if (err < 0) {
 +				pr_err("bad option at '%s'\n", c);
 +				goto out;
 +			}
 +			continue;
  		}
 -		break;
 -	case Opt_read_from_replica:
 -		switch (result.uint_32) {
 -		case Opt_read_from_replica_no:
 -			opt->read_from_replica = 0;
 +		if (token < Opt_last_int) {
 +			err = match_int(&argstr[0], &intval);
 +			if (err < 0) {
 +				pr_err("bad option arg (not int) at '%s'\n", c);
 +				goto out;
 +			}
 +			dout("got int token %d val %d\n", token, intval);
 +		} else if (token > Opt_last_int && token < Opt_last_string) {
 +			dout("got string token %d val %s\n", token,
 +			     argstr[0].from);
 +		} else {
 +			dout("got token %d\n", token);
 +		}
 +		switch (token) {
 +		case Opt_ip:
 +			err = ceph_parse_ips(argstr[0].from,
 +					     argstr[0].to,
 +					     &opt->my_addr,
 +					     1, NULL);
 +			if (err < 0)
 +				goto out;
 +			opt->flags |= CEPH_OPT_MYIP;
  			break;
++<<<<<<< HEAD
++=======
+ 		case Opt_read_from_replica_balance:
+ 			opt->read_from_replica = CEPH_OSD_FLAG_BALANCE_READS;
+ 			break;
+ 		case Opt_read_from_replica_localize:
+ 			opt->read_from_replica = CEPH_OSD_FLAG_LOCALIZE_READS;
+ 			break;
+ 		default:
+ 			BUG();
+ 		}
+ 		break;
+ 	case Opt_ms_mode:
+ 		switch (result.uint_32) {
+ 		case Opt_ms_mode_legacy:
+ 			opt->con_modes[0] = CEPH_CON_MODE_UNKNOWN;
+ 			opt->con_modes[1] = CEPH_CON_MODE_UNKNOWN;
+ 			break;
+ 		case Opt_ms_mode_crc:
+ 			opt->con_modes[0] = CEPH_CON_MODE_CRC;
+ 			opt->con_modes[1] = CEPH_CON_MODE_UNKNOWN;
+ 			break;
+ 		case Opt_ms_mode_secure:
+ 			opt->con_modes[0] = CEPH_CON_MODE_SECURE;
+ 			opt->con_modes[1] = CEPH_CON_MODE_UNKNOWN;
+ 			break;
+ 		case Opt_ms_mode_prefer_crc:
+ 			opt->con_modes[0] = CEPH_CON_MODE_CRC;
+ 			opt->con_modes[1] = CEPH_CON_MODE_SECURE;
+ 			break;
+ 		case Opt_ms_mode_prefer_secure:
+ 			opt->con_modes[0] = CEPH_CON_MODE_SECURE;
+ 			opt->con_modes[1] = CEPH_CON_MODE_CRC;
+ 			break;
+ 		default:
+ 			BUG();
+ 		}
+ 		break;
++>>>>>>> 00498b994113 (libceph: introduce connection modes and ms_mode option)
  
 -	case Opt_osdtimeout:
 -		warn_plog(&log, "Ignoring osdtimeout");
 -		break;
 -	case Opt_osdkeepalivetimeout:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_keepalive_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_idle_ttl:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_idle_ttl = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_mount_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->mount_timeout = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_request_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_request_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 +		case Opt_fsid:
 +			err = parse_fsid(argstr[0].from, &opt->fsid);
 +			if (err == 0)
 +				opt->flags |= CEPH_OPT_FSID;
 +			break;
 +		case Opt_name:
 +			kfree(opt->name);
 +			opt->name = kstrndup(argstr[0].from,
 +					      argstr[0].to-argstr[0].from,
 +					      GFP_KERNEL);
 +			if (!opt->name) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			break;
 +		case Opt_secret:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
 +
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = ceph_crypto_key_unarmor(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
 +		case Opt_key:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
 +
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = get_secret(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
 +		case Opt_crush_location:
 +			ceph_clear_crush_locs(&opt->crush_locs);
 +			err = ceph_parse_crush_location(argstr[0].from,
 +							&opt->crush_locs);
 +			if (err) {
 +				pr_err("failed to parse CRUSH location: %d\n",
 +				       err);
 +				goto out;
 +			}
 +			break;
 +		case Opt_read_from_replica:
 +			if (!strcmp(argstr[0].from, "no")) {
 +				opt->read_from_replica = 0;
 +			} else if (!strcmp(argstr[0].from, "balance")) {
 +				opt->read_from_replica = CEPH_OSD_FLAG_BALANCE_READS;
 +			} else if (!strcmp(argstr[0].from, "localize")) {
 +				opt->read_from_replica = CEPH_OSD_FLAG_LOCALIZE_READS;
 +			} else {
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			break;
  
 -	case Opt_share:
 -		if (!result.negated)
 +			/* misc */
 +		case Opt_osdtimeout:
 +			pr_warn("ignoring deprecated osdtimeout option\n");
 +			break;
 +		case Opt_osdkeepalivetimeout:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osdkeepalive out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_keepalive_timeout =
 +					msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_idle_ttl:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osd_idle_ttl out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_idle_ttl = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_mount_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("mount_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->mount_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_request_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("osd_request_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_request_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
 +
 +		case Opt_share:
  			opt->flags &= ~CEPH_OPT_NOSHARE;
 -		else
 +			break;
 +		case Opt_noshare:
  			opt->flags |= CEPH_OPT_NOSHARE;
 -		break;
 -	case Opt_crc:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_crc:
  			opt->flags &= ~CEPH_OPT_NOCRC;
 -		else
 +			break;
 +		case Opt_nocrc:
  			opt->flags |= CEPH_OPT_NOCRC;
 -		break;
 -	case Opt_cephx_require_signatures:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_cephx_require_signatures:
  			opt->flags &= ~CEPH_OPT_NOMSGAUTH;
 -		else
 +			break;
 +		case Opt_nocephx_require_signatures:
  			opt->flags |= CEPH_OPT_NOMSGAUTH;
 -		break;
 -	case Opt_cephx_sign_messages:
 -		if (!result.negated)
 +			break;
 +		case Opt_cephx_sign_messages:
  			opt->flags &= ~CEPH_OPT_NOMSGSIGN;
 -		else
 +			break;
 +		case Opt_nocephx_sign_messages:
  			opt->flags |= CEPH_OPT_NOMSGSIGN;
 -		break;
 -	case Opt_tcp_nodelay:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_tcp_nodelay:
  			opt->flags |= CEPH_OPT_TCP_NODELAY;
 -		else
 +			break;
 +		case Opt_notcp_nodelay:
  			opt->flags &= ~CEPH_OPT_TCP_NODELAY;
 -		break;
 +			break;
  
 -	case Opt_abort_on_full:
 -		opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 -		break;
 +		case Opt_abort_on_full:
 +			opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 +			break;
  
 -	default:
 -		BUG();
 +		default:
 +			BUG_ON(token);
 +		}
  	}
  
 -	return 0;
 +	/* success */
 +	return opt;
  
 -out_of_range:
 -	return inval_plog(&log, "%s out of range", param->key);
 +out:
 +	ceph_destroy_options(opt);
 +	return ERR_PTR(err);
  }
 -EXPORT_SYMBOL(ceph_parse_param);
 +EXPORT_SYMBOL(ceph_parse_options);
  
  int ceph_print_client_options(struct seq_file *m, struct ceph_client *client,
  			      bool show_all)
diff --git a/include/linux/ceph/auth.h b/include/linux/ceph/auth.h
index 5f64f66309fa..6fc058fe9efa 100644
--- a/include/linux/ceph/auth.h
+++ b/include/linux/ceph/auth.h
@@ -98,11 +98,15 @@ struct ceph_auth_client {
 	const struct ceph_crypto_key *key;     /* our secret key */
 	unsigned want_keys;     /* which services we want */
 
+	int preferred_mode;	/* CEPH_CON_MODE_* */
+	int fallback_mode;	/* ditto */
+
 	struct mutex mutex;
 };
 
-extern struct ceph_auth_client *ceph_auth_init(const char *name,
-					       const struct ceph_crypto_key *key);
+struct ceph_auth_client *ceph_auth_init(const char *name,
+					const struct ceph_crypto_key *key,
+					const int *con_modes);
 extern void ceph_auth_destroy(struct ceph_auth_client *ac);
 
 extern void ceph_auth_reset(struct ceph_auth_client *ac);
diff --git a/include/linux/ceph/ceph_fs.h b/include/linux/ceph/ceph_fs.h
index 6d986e52000b..ce22d5469670 100644
--- a/include/linux/ceph/ceph_fs.h
+++ b/include/linux/ceph/ceph_fs.h
@@ -93,9 +93,15 @@ struct ceph_dir_layout {
 #define CEPH_AUTH_NONE	 	0x1
 #define CEPH_AUTH_CEPHX	 	0x2
 
+/* msgr2 protocol modes */
+#define CEPH_CON_MODE_UNKNOWN	0x0
+#define CEPH_CON_MODE_CRC	0x1
+#define CEPH_CON_MODE_SECURE	0x2
+
 #define CEPH_AUTH_UID_DEFAULT ((__u64) -1)
 
 const char *ceph_auth_proto_name(int proto);
+const char *ceph_con_mode_name(int mode);
 
 /*********************************************
  * message layer
diff --git a/include/linux/ceph/libceph.h b/include/linux/ceph/libceph.h
index 9446446ac5bf..01d2daf15dfb 100644
--- a/include/linux/ceph/libceph.h
+++ b/include/linux/ceph/libceph.h
@@ -53,6 +53,7 @@ struct ceph_options {
 	unsigned long osd_keepalive_timeout;	/* jiffies */
 	unsigned long osd_request_timeout;	/* jiffies */
 	u32 read_from_replica;  /* CEPH_OSD_FLAG_BALANCE/LOCALIZE_READS */
+	int con_modes[2];  /* CEPH_CON_MODE_* */
 
 	/*
 	 * any type that can't be simply compared or doesn't need
diff --git a/net/ceph/auth.c b/net/ceph/auth.c
index deaf267f8942..4a0f32b32cc6 100644
--- a/net/ceph/auth.c
+++ b/net/ceph/auth.c
@@ -39,13 +39,13 @@ static int init_protocol(struct ceph_auth_client *ac, int proto)
 /*
  * setup, teardown.
  */
-struct ceph_auth_client *ceph_auth_init(const char *name, const struct ceph_crypto_key *key)
+struct ceph_auth_client *ceph_auth_init(const char *name,
+					const struct ceph_crypto_key *key,
+					const int *con_modes)
 {
 	struct ceph_auth_client *ac;
 	int ret;
 
-	dout("auth_init name '%s'\n", name);
-
 	ret = -ENOMEM;
 	ac = kzalloc(sizeof(*ac), GFP_NOFS);
 	if (!ac)
@@ -57,8 +57,12 @@ struct ceph_auth_client *ceph_auth_init(const char *name, const struct ceph_cryp
 		ac->name = name;
 	else
 		ac->name = CEPH_AUTH_NAME_DEFAULT;
-	dout("auth_init name %s\n", ac->name);
 	ac->key = key;
+	ac->preferred_mode = con_modes[0];
+	ac->fallback_mode = con_modes[1];
+
+	dout("%s name '%s' preferred_mode %d fallback_mode %d\n", __func__,
+	     ac->name, ac->preferred_mode, ac->fallback_mode);
 	return ac;
 
 out:
* Unmerged path net/ceph/ceph_common.c
diff --git a/net/ceph/ceph_strings.c b/net/ceph/ceph_strings.c
index 69cd391e02a6..355fea272120 100644
--- a/net/ceph/ceph_strings.c
+++ b/net/ceph/ceph_strings.c
@@ -32,6 +32,20 @@ const char *ceph_auth_proto_name(int proto)
 	}
 }
 
+const char *ceph_con_mode_name(int mode)
+{
+	switch (mode) {
+	case CEPH_CON_MODE_UNKNOWN:
+		return "unknown";
+	case CEPH_CON_MODE_CRC:
+		return "crc";
+	case CEPH_CON_MODE_SECURE:
+		return "secure";
+	default:
+		return "???";
+	}
+}
+
 const char *ceph_osd_op_name(int op)
 {
 	switch (op) {
diff --git a/net/ceph/mon_client.c b/net/ceph/mon_client.c
index 686b4ecff175..ae312c9b14f9 100644
--- a/net/ceph/mon_client.c
+++ b/net/ceph/mon_client.c
@@ -1119,8 +1119,8 @@ int ceph_monc_init(struct ceph_mon_client *monc, struct ceph_client *cl)
 
 	/* connection */
 	/* authentication */
-	monc->auth = ceph_auth_init(cl->options->name,
-				    cl->options->key);
+	monc->auth = ceph_auth_init(cl->options->name, cl->options->key,
+				    cl->options->con_modes);
 	if (IS_ERR(monc->auth)) {
 		err = PTR_ERR(monc->auth);
 		goto out_monmap;
