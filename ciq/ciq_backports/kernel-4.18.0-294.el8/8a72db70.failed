scsi: zfcp: implicitly refresh config-data diagnostics when reading sysfs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Benjamin Block <bblock@linux.ibm.com>
commit 8a72db70b5ca3c3feb3ca25519e8a9516cc60cfe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8a72db70.failed

Adds implicit updates of cached diagnostics via Exchange Config Data when
reading sysfs attributes interfacing them. Right now this only affects the
new B2B-Credit diagnostic attribute.

This uses the same mechanism previously also used for cached diagnostics
of Exchange Port Data.

Link: https://lore.kernel.org/r/60a94f55f2630b74b468fed5f39880208abb2679.1572018132.git.bblock@linux.ibm.com
	Reviewed-by: Steffen Maier <maier@linux.ibm.com>
	Signed-off-by: Benjamin Block <bblock@linux.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8a72db70b5ca3c3feb3ca25519e8a9516cc60cfe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/scsi/zfcp_diag.c
#	drivers/s390/scsi/zfcp_diag.h
#	drivers/s390/scsi/zfcp_sysfs.c
diff --cc drivers/s390/scsi/zfcp_diag.c
index d7d2db85b32e,5ef7b3288c6f..000000000000
--- a/drivers/s390/scsi/zfcp_diag.c
+++ b/drivers/s390/scsi/zfcp_diag.c
@@@ -101,3 -145,160 +101,163 @@@ void zfcp_diag_update_xdata(struct zfcp
  out:
  	spin_unlock_irqrestore(&hdr->access_lock, flags);
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * zfcp_diag_update_port_data_buffer() - Implementation of
+  *					 &typedef zfcp_diag_update_buffer_func
+  *					 to collect and update Port Data.
+  * @adapter: Adapter to collect Port Data from.
+  *
+  * This call is SYNCHRONOUS ! It blocks till the respective command has
+  * finished completely, or has failed in some way.
+  *
+  * Return:
+  * * 0		- Successfully retrieved new Diagnostics and Updated the buffer;
+  *		  this also includes cases where data was retrieved, but
+  *		  incomplete; you'll have to check the flag ``incomplete``
+  *		  of &struct zfcp_diag_header.
+  * * see zfcp_fsf_exchange_port_data_sync() for possible error-codes (
+  *   excluding -EAGAIN)
+  */
+ int zfcp_diag_update_port_data_buffer(struct zfcp_adapter *const adapter)
+ {
+ 	int rc;
+ 
+ 	rc = zfcp_fsf_exchange_port_data_sync(adapter->qdio, NULL);
+ 	if (rc == -EAGAIN)
+ 		rc = 0; /* signaling incomplete via struct zfcp_diag_header */
+ 
+ 	/* buffer-data was updated in zfcp_fsf_exchange_port_data_handler() */
+ 
+ 	return rc;
+ }
+ 
+ /**
+  * zfcp_diag_update_config_data_buffer() - Implementation of
+  *					   &typedef zfcp_diag_update_buffer_func
+  *					   to collect and update Config Data.
+  * @adapter: Adapter to collect Config Data from.
+  *
+  * This call is SYNCHRONOUS ! It blocks till the respective command has
+  * finished completely, or has failed in some way.
+  *
+  * Return:
+  * * 0		- Successfully retrieved new Diagnostics and Updated the buffer;
+  *		  this also includes cases where data was retrieved, but
+  *		  incomplete; you'll have to check the flag ``incomplete``
+  *		  of &struct zfcp_diag_header.
+  * * see zfcp_fsf_exchange_config_data_sync() for possible error-codes (
+  *   excluding -EAGAIN)
+  */
+ int zfcp_diag_update_config_data_buffer(struct zfcp_adapter *const adapter)
+ {
+ 	int rc;
+ 
+ 	rc = zfcp_fsf_exchange_config_data_sync(adapter->qdio, NULL);
+ 	if (rc == -EAGAIN)
+ 		rc = 0; /* signaling incomplete via struct zfcp_diag_header */
+ 
+ 	/* buffer-data was updated in zfcp_fsf_exchange_config_data_handler() */
+ 
+ 	return rc;
+ }
+ 
+ static int __zfcp_diag_update_buffer(struct zfcp_adapter *const adapter,
+ 				     struct zfcp_diag_header *const hdr,
+ 				     zfcp_diag_update_buffer_func buffer_update,
+ 				     unsigned long *const flags)
+ 	__must_hold(hdr->access_lock)
+ {
+ 	int rc;
+ 
+ 	if (hdr->updating == 1) {
+ 		rc = wait_event_interruptible_lock_irq(__zfcp_diag_publish_wait,
+ 						       hdr->updating == 0,
+ 						       hdr->access_lock);
+ 		rc = (rc == 0 ? -EAGAIN : -EINTR);
+ 	} else {
+ 		hdr->updating = 1;
+ 		spin_unlock_irqrestore(&hdr->access_lock, *flags);
+ 
+ 		/* unlocked, because update function sleeps */
+ 		rc = buffer_update(adapter);
+ 
+ 		spin_lock_irqsave(&hdr->access_lock, *flags);
+ 		hdr->updating = 0;
+ 
+ 		/*
+ 		 * every thread waiting here went via an interruptible wait,
+ 		 * so its fine to only wake those
+ 		 */
+ 		wake_up_interruptible_all(&__zfcp_diag_publish_wait);
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ static bool
+ __zfcp_diag_test_buffer_age_isfresh(const struct zfcp_diag_header *const hdr)
+ 	__must_hold(hdr->access_lock)
+ {
+ 	const unsigned long now = jiffies;
+ 
+ 	/*
+ 	 * Should not happen (data is from the future).. if it does, still
+ 	 * signal that it needs refresh
+ 	 */
+ 	if (!time_after_eq(now, hdr->timestamp))
+ 		return false;
+ 
+ 	if (jiffies_to_msecs(now - hdr->timestamp) >= ZFCP_DIAG_MAX_AGE)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /**
+  * zfcp_diag_update_buffer_limited() - Collect diagnostics and update a
+  *				       diagnostics buffer rate limited.
+  * @adapter: Adapter to collect the diagnostics from.
+  * @hdr: buffer-header for which to update with the collected diagnostics.
+  * @buffer_update: Specific implementation for collecting and updating.
+  *
+  * This function will cause an update of the given @hdr by calling the also
+  * given @buffer_update function. If called by multiple sources at the same
+  * time, it will synchornize the update by only allowing one source to call
+  * @buffer_update and the others to wait for that source to complete instead
+  * (the wait is interruptible).
+  *
+  * Additionally this version is rate-limited and will only exit if either the
+  * buffer is fresh enough (within the limit) - it will do nothing if the buffer
+  * is fresh enough to begin with -, or if the source/thread that started this
+  * update is the one that made the update (to prevent endless loops).
+  *
+  * Return:
+  * * 0		- If the update was successfully published and/or the buffer is
+  *		  fresh enough
+  * * -EINTR	- If the thread went into the wait-state and was interrupted
+  * * whatever @buffer_update returns
+  */
+ int zfcp_diag_update_buffer_limited(struct zfcp_adapter *const adapter,
+ 				    struct zfcp_diag_header *const hdr,
+ 				    zfcp_diag_update_buffer_func buffer_update)
+ {
+ 	unsigned long flags;
+ 	int rc;
+ 
+ 	spin_lock_irqsave(&hdr->access_lock, flags);
+ 
+ 	for (rc = 0; !__zfcp_diag_test_buffer_age_isfresh(hdr); rc = 0) {
+ 		rc = __zfcp_diag_update_buffer(adapter, hdr, buffer_update,
+ 					       &flags);
+ 		if (rc != -EAGAIN)
+ 			break;
+ 	}
+ 
+ 	spin_unlock_irqrestore(&hdr->access_lock, flags);
+ 
+ 	return rc;
+ }
++>>>>>>> 8a72db70b5ca (scsi: zfcp: implicitly refresh config-data diagnostics when reading sysfs)
diff --cc drivers/s390/scsi/zfcp_diag.h
index f354c8bd6f04,cf2947cd8c8f..000000000000
--- a/drivers/s390/scsi/zfcp_diag.h
+++ b/drivers/s390/scsi/zfcp_diag.h
@@@ -64,4 -68,30 +64,30 @@@ void zfcp_diag_adapter_free(struct zfcp
  void zfcp_diag_update_xdata(struct zfcp_diag_header *const hdr,
  			    const void *const data, const bool incomplete);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Function-Type used in zfcp_diag_update_buffer_limited() for the function
+  * that does the buffer-implementation dependent work.
+  */
+ typedef int (*zfcp_diag_update_buffer_func)(struct zfcp_adapter *const adapter);
+ 
+ int zfcp_diag_update_config_data_buffer(struct zfcp_adapter *const adapter);
+ int zfcp_diag_update_port_data_buffer(struct zfcp_adapter *const adapter);
+ int zfcp_diag_update_buffer_limited(struct zfcp_adapter *const adapter,
+ 				    struct zfcp_diag_header *const hdr,
+ 				    zfcp_diag_update_buffer_func buffer_update);
+ 
+ /**
+  * zfcp_diag_support_sfp() - Return %true if the @adapter supports reporting
+  *			     SFP Data.
+  * @adapter: adapter to test the availability of SFP Data reporting for.
+  */
+ static inline bool
+ zfcp_diag_support_sfp(const struct zfcp_adapter *const adapter)
+ {
+ 	return !!(adapter->adapter_features & FSF_FEATURE_REPORT_SFP_DATA);
+ }
+ 
++>>>>>>> 8a72db70b5ca (scsi: zfcp: implicitly refresh config-data diagnostics when reading sysfs)
  #endif /* ZFCP_DIAG_H */
diff --cc drivers/s390/scsi/zfcp_sysfs.c
index 432e4f59b575,ae8e9137f448..000000000000
--- a/drivers/s390/scsi/zfcp_sysfs.c
+++ b/drivers/s390/scsi/zfcp_sysfs.c
@@@ -744,3 -665,123 +744,126 @@@ struct device_attribute *zfcp_sysfs_sho
  	&dev_attr_queue_full,
  	NULL
  };
++<<<<<<< HEAD
++=======
+ 
+ static ssize_t zfcp_sysfs_adapter_diag_b2b_credit_show(
+ 	struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));
+ 	struct zfcp_diag_header *diag_hdr;
+ 	struct fc_els_flogi *nsp;
+ 	ssize_t rc = -ENOLINK;
+ 	unsigned long flags;
+ 	unsigned int status;
+ 
+ 	if (!adapter)
+ 		return -ENODEV;
+ 
+ 	status = atomic_read(&adapter->status);
+ 	if (0 == (status & ZFCP_STATUS_COMMON_OPEN) ||
+ 	    0 == (status & ZFCP_STATUS_COMMON_UNBLOCKED) ||
+ 	    0 != (status & ZFCP_STATUS_COMMON_ERP_FAILED))
+ 		goto out;
+ 
+ 	diag_hdr = &adapter->diagnostics->config_data.header;
+ 
+ 	rc = zfcp_diag_update_buffer_limited(
+ 		adapter, diag_hdr, zfcp_diag_update_config_data_buffer);
+ 	if (rc != 0)
+ 		goto out;
+ 
+ 	spin_lock_irqsave(&diag_hdr->access_lock, flags);
+ 	/* nport_serv_param doesn't contain the ELS_Command code */
+ 	nsp = (struct fc_els_flogi *)((unsigned long)
+ 					      adapter->diagnostics->config_data
+ 						      .data.nport_serv_param -
+ 				      sizeof(u32));
+ 
+ 	rc = scnprintf(buf, 5 + 2, "%hu\n",
+ 		       be16_to_cpu(nsp->fl_csp.sp_bb_cred));
+ 	spin_unlock_irqrestore(&diag_hdr->access_lock, flags);
+ 
+ out:
+ 	zfcp_ccw_adapter_put(adapter);
+ 	return rc;
+ }
+ static ZFCP_DEV_ATTR(adapter_diag, b2b_credit, 0400,
+ 		     zfcp_sysfs_adapter_diag_b2b_credit_show, NULL);
+ 
+ #define ZFCP_DEFINE_DIAG_SFP_ATTR(_name, _qtcb_member, _prtsize, _prtfmt)      \
+ 	static ssize_t zfcp_sysfs_adapter_diag_sfp_##_name##_show(	       \
+ 		struct device *dev, struct device_attribute *attr, char *buf)  \
+ 	{								       \
+ 		struct zfcp_adapter *const adapter =			       \
+ 			zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));	       \
+ 		struct zfcp_diag_header *diag_hdr;			       \
+ 		ssize_t rc = -ENOLINK;					       \
+ 		unsigned long flags;					       \
+ 		unsigned int status;					       \
+ 									       \
+ 		if (!adapter)						       \
+ 			return -ENODEV;					       \
+ 									       \
+ 		status = atomic_read(&adapter->status);			       \
+ 		if (0 == (status & ZFCP_STATUS_COMMON_OPEN) ||		       \
+ 		    0 == (status & ZFCP_STATUS_COMMON_UNBLOCKED) ||	       \
+ 		    0 != (status & ZFCP_STATUS_COMMON_ERP_FAILED))	       \
+ 			goto out;					       \
+ 									       \
+ 		if (!zfcp_diag_support_sfp(adapter)) {			       \
+ 			rc = -EOPNOTSUPP;				       \
+ 			goto out;					       \
+ 		}							       \
+ 									       \
+ 		diag_hdr = &adapter->diagnostics->port_data.header;	       \
+ 									       \
+ 		rc = zfcp_diag_update_buffer_limited(			       \
+ 			adapter, diag_hdr, zfcp_diag_update_port_data_buffer); \
+ 		if (rc != 0)						       \
+ 			goto out;					       \
+ 									       \
+ 		spin_lock_irqsave(&diag_hdr->access_lock, flags);	       \
+ 		rc = scnprintf(						       \
+ 			buf, (_prtsize) + 2, _prtfmt "\n",		       \
+ 			adapter->diagnostics->port_data.data._qtcb_member);    \
+ 		spin_unlock_irqrestore(&diag_hdr->access_lock, flags);	       \
+ 									       \
+ 	out:								       \
+ 		zfcp_ccw_adapter_put(adapter);				       \
+ 		return rc;						       \
+ 	}								       \
+ 	static ZFCP_DEV_ATTR(adapter_diag_sfp, _name, 0400,		       \
+ 			     zfcp_sysfs_adapter_diag_sfp_##_name##_show, NULL)
+ 
+ ZFCP_DEFINE_DIAG_SFP_ATTR(temperature, temperature, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(vcc, vcc, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(tx_bias, tx_bias, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(tx_power, tx_power, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(rx_power, rx_power, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(port_tx_type, sfp_flags.port_tx_type, 2, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(optical_port, sfp_flags.optical_port, 1, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(sfp_invalid, sfp_flags.sfp_invalid, 1, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(connector_type, sfp_flags.connector_type, 1, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(fec_active, sfp_flags.fec_active, 1, "%hu");
+ 
+ static struct attribute *zfcp_sysfs_diag_attrs[] = {
+ 	&dev_attr_adapter_diag_sfp_temperature.attr,
+ 	&dev_attr_adapter_diag_sfp_vcc.attr,
+ 	&dev_attr_adapter_diag_sfp_tx_bias.attr,
+ 	&dev_attr_adapter_diag_sfp_tx_power.attr,
+ 	&dev_attr_adapter_diag_sfp_rx_power.attr,
+ 	&dev_attr_adapter_diag_sfp_port_tx_type.attr,
+ 	&dev_attr_adapter_diag_sfp_optical_port.attr,
+ 	&dev_attr_adapter_diag_sfp_sfp_invalid.attr,
+ 	&dev_attr_adapter_diag_sfp_connector_type.attr,
+ 	&dev_attr_adapter_diag_sfp_fec_active.attr,
+ 	&dev_attr_adapter_diag_b2b_credit.attr,
+ 	NULL,
+ };
+ 
+ const struct attribute_group zfcp_sysfs_diag_attr_group = {
+ 	.name = "diagnostics",
+ 	.attrs = zfcp_sysfs_diag_attrs,
+ };
++>>>>>>> 8a72db70b5ca (scsi: zfcp: implicitly refresh config-data diagnostics when reading sysfs)
* Unmerged path drivers/s390/scsi/zfcp_diag.c
* Unmerged path drivers/s390/scsi/zfcp_diag.h
* Unmerged path drivers/s390/scsi/zfcp_sysfs.c
