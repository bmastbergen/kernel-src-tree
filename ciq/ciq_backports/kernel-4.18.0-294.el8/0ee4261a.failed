mptcp: implement mptcp_pm_remove_subflow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 0ee4261a36817c441d26ee90ad96f9cc30d678ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0ee4261a.failed

This patch implemented the local subflow removing function,
mptcp_pm_remove_subflow, it simply called mptcp_pm_nl_rm_subflow_received
under the PM spin lock.

We use mptcp_pm_remove_subflow to remove a local subflow, so change it's
argument from remote_id to local_id.

We check subflow->local_id in mptcp_pm_nl_rm_subflow_received to remove
a subflow.

	Suggested-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Suggested-by: Paolo Abeni <pabeni@redhat.com>
	Suggested-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0ee4261a36817c441d26ee90ad96f9cc30d678ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.h
diff --cc net/mptcp/protocol.h
index 68e02bf1a169,df6cc94df1f7..000000000000
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@@ -418,11 -441,14 +418,11 @@@ void mptcp_pm_subflow_established(struc
  void mptcp_pm_subflow_closed(struct mptcp_sock *msk, u8 id);
  void mptcp_pm_add_addr_received(struct mptcp_sock *msk,
  				const struct mptcp_addr_info *addr);
 -void mptcp_pm_rm_addr_received(struct mptcp_sock *msk, u8 rm_id);
 -void mptcp_pm_free_anno_list(struct mptcp_sock *msk);
  
  int mptcp_pm_announce_addr(struct mptcp_sock *msk,
 -			   const struct mptcp_addr_info *addr,
 -			   bool echo);
 +			   const struct mptcp_addr_info *addr);
  int mptcp_pm_remove_addr(struct mptcp_sock *msk, u8 local_id);
- int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 remote_id);
+ int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 local_id);
  
  static inline bool mptcp_pm_should_add_signal(struct mptcp_sock *msk)
  {
@@@ -445,6 -478,8 +445,11 @@@ void mptcp_pm_nl_data_init(struct mptcp
  void mptcp_pm_nl_fully_established(struct mptcp_sock *msk);
  void mptcp_pm_nl_subflow_established(struct mptcp_sock *msk);
  void mptcp_pm_nl_add_addr_received(struct mptcp_sock *msk);
++<<<<<<< HEAD
++=======
+ void mptcp_pm_nl_rm_addr_received(struct mptcp_sock *msk);
+ void mptcp_pm_nl_rm_subflow_received(struct mptcp_sock *msk, u8 rm_id);
++>>>>>>> 0ee4261a3681 (mptcp: implement mptcp_pm_remove_subflow)
  int mptcp_pm_nl_get_local_id(struct mptcp_sock *msk, struct sock_common *skc);
  
  static inline struct mptcp_ext *mptcp_get_ext(struct sk_buff *skb)
diff --git a/net/mptcp/pm.c b/net/mptcp/pm.c
index a78fc80f9b51..574a39a93f6b 100644
--- a/net/mptcp/pm.c
+++ b/net/mptcp/pm.c
@@ -29,9 +29,14 @@ int mptcp_pm_remove_addr(struct mptcp_sock *msk, u8 local_id)
 	return -ENOTSUPP;
 }
 
-int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 remote_id)
+int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 local_id)
 {
-	return -ENOTSUPP;
+	pr_debug("msk=%p, local_id=%d", msk, local_id);
+
+	spin_lock_bh(&msk->pm.lock);
+	mptcp_pm_nl_rm_subflow_received(msk, local_id);
+	spin_unlock_bh(&msk->pm.lock);
+	return 0;
 }
 
 /* path manager event handlers */
diff --git a/net/mptcp/pm_netlink.c b/net/mptcp/pm_netlink.c
index 6f3bf9fdbbbc..d14043047d49 100644
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@ -271,6 +271,39 @@ void mptcp_pm_nl_add_addr_received(struct mptcp_sock *msk)
 	spin_lock_bh(&msk->pm.lock);
 }
 
+void mptcp_pm_nl_rm_subflow_received(struct mptcp_sock *msk, u8 rm_id)
+{
+	struct mptcp_subflow_context *subflow, *tmp;
+	struct sock *sk = (struct sock *)msk;
+
+	pr_debug("subflow rm_id %d", rm_id);
+
+	if (!rm_id)
+		return;
+
+	if (list_empty(&msk->conn_list))
+		return;
+
+	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+		long timeout = 0;
+
+		if (rm_id != subflow->local_id)
+			continue;
+
+		spin_unlock_bh(&msk->pm.lock);
+		mptcp_subflow_shutdown(sk, ssk, how);
+		__mptcp_close_ssk(sk, ssk, subflow, timeout);
+		spin_lock_bh(&msk->pm.lock);
+
+		msk->pm.local_addr_used--;
+		msk->pm.subflows--;
+
+		break;
+	}
+}
+
 static bool address_use_port(struct mptcp_pm_addr_entry *entry)
 {
 	return (entry->flags &
* Unmerged path net/mptcp/protocol.h
