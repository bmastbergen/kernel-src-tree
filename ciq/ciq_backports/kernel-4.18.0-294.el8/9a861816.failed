xfs: move xfs_parseargs() validation to a helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ian Kent <raven@themaw.net>
commit 9a861816a02653dcec7a97d4f639f04b0bcf09c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9a861816.failed

Move the validation code of xfs_parseargs() into a helper for later
use within the mount context methods.

	Signed-off-by: Ian Kent <raven@themaw.net>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 9a861816a02653dcec7a97d4f639f04b0bcf09c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index 1d294035379f,4b570ba3456a..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -141,191 -143,175 +141,363 @@@ suffix_kstrtoint(const substring_t *s, 
  	return ret;
  }
  
++<<<<<<< HEAD
 +/*
 + * This function fills in xfs_mount_t fields based on mount args.
 + * Note: the superblock has _not_ yet been read in.
 + *
 + * Note that this function leaks the various device name allocations on
 + * failure.  The caller takes care of them.
 + *
 + * *sb is const because this is also used to test options on the remount
 + * path, and we don't want this to have any side effects at remount time.
 + * Today this function does not change *sb, but just to future-proof...
 + */
 +STATIC int
 +xfs_parseargs(
 +	struct xfs_mount	*mp,
 +	char			*options)
 +{
 +	const struct super_block *sb = mp->m_super;
 +	char			*p;
 +	substring_t		args[MAX_OPT_ARGS];
 +	int			iosize = 0;
 +	uint8_t			iosizelog = 0;
 +
 +	/*
 +	 * Copy binary VFS mount flags we are interested in.
 +	 */
 +	if (sb_rdonly(sb))
 +		mp->m_flags |= XFS_MOUNT_RDONLY;
 +	if (sb->s_flags & SB_DIRSYNC)
 +		mp->m_flags |= XFS_MOUNT_DIRSYNC;
 +	if (sb->s_flags & SB_SYNCHRONOUS)
 +		mp->m_flags |= XFS_MOUNT_WSYNC;
 +
 +	/*
 +	 * These can be overridden by the mount option parsing.
 +	 */
 +	mp->m_logbufs = -1;
 +	mp->m_logbsize = -1;
 +
 +	if (!options)
 +		return 0;
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int		token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_logbufs:
 +			if (match_int(args, &mp->m_logbufs))
 +				return -EINVAL;
 +			break;
 +		case Opt_logbsize:
 +			if (suffix_kstrtoint(args, 10, &mp->m_logbsize))
 +				return -EINVAL;
 +			break;
 +		case Opt_logdev:
 +			kfree(mp->m_logname);
 +			mp->m_logname = match_strdup(args);
 +			if (!mp->m_logname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_rtdev:
 +			kfree(mp->m_rtname);
 +			mp->m_rtname = match_strdup(args);
 +			if (!mp->m_rtname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_allocsize:
 +		case Opt_biosize:
 +			if (suffix_kstrtoint(args, 10, &iosize))
 +				return -EINVAL;
 +			iosizelog = ffs(iosize) - 1;
 +			break;
 +		case Opt_grpid:
 +		case Opt_bsdgroups:
 +			mp->m_flags |= XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_nogrpid:
 +		case Opt_sysvgroups:
 +			mp->m_flags &= ~XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_wsync:
 +			mp->m_flags |= XFS_MOUNT_WSYNC;
 +			break;
 +		case Opt_norecovery:
 +			mp->m_flags |= XFS_MOUNT_NORECOVERY;
 +			break;
 +		case Opt_noalign:
 +			mp->m_flags |= XFS_MOUNT_NOALIGN;
 +			break;
 +		case Opt_swalloc:
 +			mp->m_flags |= XFS_MOUNT_SWALLOC;
 +			break;
 +		case Opt_sunit:
 +			if (match_int(args, &mp->m_dalign))
 +				return -EINVAL;
 +			break;
 +		case Opt_swidth:
 +			if (match_int(args, &mp->m_swidth))
 +				return -EINVAL;
 +			break;
 +		case Opt_inode32:
 +			mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_inode64:
 +			mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_nouuid:
 +			mp->m_flags |= XFS_MOUNT_NOUUID;
 +			break;
 +		case Opt_ikeep:
 +			mp->m_flags |= XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_noikeep:
 +			mp->m_flags &= ~XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_largeio:
 +			mp->m_flags |= XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_nolargeio:
 +			mp->m_flags &= ~XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_attr2:
 +			mp->m_flags |= XFS_MOUNT_ATTR2;
 +			break;
 +		case Opt_noattr2:
 +			mp->m_flags &= ~XFS_MOUNT_ATTR2;
 +			mp->m_flags |= XFS_MOUNT_NOATTR2;
 +			break;
 +		case Opt_filestreams:
 +			mp->m_flags |= XFS_MOUNT_FILESTREAMS;
 +			break;
 +		case Opt_noquota:
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
 +			break;
 +		case Opt_quota:
 +		case Opt_uquota:
 +		case Opt_usrquota:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
 +					 XFS_UQUOTA_ENFD);
 +			break;
 +		case Opt_qnoenforce:
 +		case Opt_uqnoenforce:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_UQUOTA_ENFD;
 +			break;
 +		case Opt_pquota:
 +		case Opt_prjquota:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
 +					 XFS_PQUOTA_ENFD);
 +			break;
 +		case Opt_pqnoenforce:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_PQUOTA_ENFD;
 +			break;
 +		case Opt_gquota:
 +		case Opt_grpquota:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
 +					 XFS_GQUOTA_ENFD);
 +			break;
 +		case Opt_gqnoenforce:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_GQUOTA_ENFD;
 +			break;
 +		case Opt_discard:
 +			mp->m_flags |= XFS_MOUNT_DISCARD;
 +			break;
 +		case Opt_nodiscard:
 +			mp->m_flags &= ~XFS_MOUNT_DISCARD;
 +			break;
 +#ifdef CONFIG_FS_DAX
 +		case Opt_dax:
 +			mp->m_flags |= XFS_MOUNT_DAX;
 +			break;
 +#endif
 +		default:
 +			xfs_warn(mp, "unknown mount option [%s].", p);
 +			return -EINVAL;
 +		}
 +	}
 +
++=======
+ static int
+ match_kstrtoint(
+ 	const substring_t	*s,
+ 	unsigned int		base,
+ 	int			*res)
+ {
+ 	const char		*value;
+ 	int			ret;
+ 
+ 	value = match_strdup(s);
+ 	if (!value)
+ 		return -ENOMEM;
+ 	ret = suffix_kstrtoint(value, base, res);
+ 	kfree(value);
+ 	return ret;
+ }
+ 
+ static int
+ xfs_fc_parse_param(
+ 	int			token,
+ 	char			*p,
+ 	substring_t		*args,
+ 	struct xfs_mount	*mp)
+ {
+ 	int			size = 0;
+ 
+ 	switch (token) {
+ 	case Opt_logbufs:
+ 		if (match_int(args, &mp->m_logbufs))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_logbsize:
+ 		if (match_kstrtoint(args, 10, &mp->m_logbsize))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_logdev:
+ 		kfree(mp->m_logname);
+ 		mp->m_logname = match_strdup(args);
+ 		if (!mp->m_logname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_rtdev:
+ 		kfree(mp->m_rtname);
+ 		mp->m_rtname = match_strdup(args);
+ 		if (!mp->m_rtname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_allocsize:
+ 		if (match_kstrtoint(args, 10, &size))
+ 			return -EINVAL;
+ 		mp->m_allocsize_log = ffs(size) - 1;
+ 		mp->m_flags |= XFS_MOUNT_ALLOCSIZE;
+ 		return 0;
+ 	case Opt_grpid:
+ 	case Opt_bsdgroups:
+ 		mp->m_flags |= XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_nogrpid:
+ 	case Opt_sysvgroups:
+ 		mp->m_flags &= ~XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_wsync:
+ 		mp->m_flags |= XFS_MOUNT_WSYNC;
+ 		return 0;
+ 	case Opt_norecovery:
+ 		mp->m_flags |= XFS_MOUNT_NORECOVERY;
+ 		return 0;
+ 	case Opt_noalign:
+ 		mp->m_flags |= XFS_MOUNT_NOALIGN;
+ 		return 0;
+ 	case Opt_swalloc:
+ 		mp->m_flags |= XFS_MOUNT_SWALLOC;
+ 		return 0;
+ 	case Opt_sunit:
+ 		if (match_int(args, &mp->m_dalign))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_swidth:
+ 		if (match_int(args, &mp->m_swidth))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_inode32:
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_inode64:
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_nouuid:
+ 		mp->m_flags |= XFS_MOUNT_NOUUID;
+ 		return 0;
+ 	case Opt_ikeep:
+ 		mp->m_flags |= XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_noikeep:
+ 		mp->m_flags &= ~XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_largeio:
+ 		mp->m_flags |= XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_nolargeio:
+ 		mp->m_flags &= ~XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_attr2:
+ 		mp->m_flags |= XFS_MOUNT_ATTR2;
+ 		return 0;
+ 	case Opt_noattr2:
+ 		mp->m_flags &= ~XFS_MOUNT_ATTR2;
+ 		mp->m_flags |= XFS_MOUNT_NOATTR2;
+ 		return 0;
+ 	case Opt_filestreams:
+ 		mp->m_flags |= XFS_MOUNT_FILESTREAMS;
+ 		return 0;
+ 	case Opt_noquota:
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
+ 		return 0;
+ 	case Opt_quota:
+ 	case Opt_uquota:
+ 	case Opt_usrquota:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
+ 				 XFS_UQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_qnoenforce:
+ 	case Opt_uqnoenforce:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_UQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_pquota:
+ 	case Opt_prjquota:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
+ 				 XFS_PQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_pqnoenforce:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_PQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_gquota:
+ 	case Opt_grpquota:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
+ 				 XFS_GQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_gqnoenforce:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_GQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_discard:
+ 		mp->m_flags |= XFS_MOUNT_DISCARD;
+ 		return 0;
+ 	case Opt_nodiscard:
+ 		mp->m_flags &= ~XFS_MOUNT_DISCARD;
+ 		return 0;
+ #ifdef CONFIG_FS_DAX
+ 	case Opt_dax:
+ 		mp->m_flags |= XFS_MOUNT_DAX;
+ 		return 0;
+ #endif
+ 	default:
+ 		xfs_warn(mp, "unknown mount option [%s].", p);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_fc_validate_params(
+ 	struct xfs_mount	*mp)
+ {
++>>>>>>> 9a861816a026 (xfs: move xfs_parseargs() validation to a helper)
  	/*
  	 * no recovery flag requires a read-only mount
  	 */
* Unmerged path fs/xfs/xfs_super.c
