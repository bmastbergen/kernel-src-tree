powerpc/watchpoint: Convert thread_struct->hw_brk to an array

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ravi Bangoria <ravi.bangoria@linux.ibm.com>
commit 303e6a9ddcdc168e92253c78cdb4bbe1e10d78b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/303e6a9d.failed

So far powerpc hw supported only one watchpoint. But Power10 is
introducing 2nd DAWR. Convert thread_struct->hw_brk into an array.

	Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
	Reviewed-by: Michael Neuling <mikey@neuling.org>
Link: https://lore.kernel.org/r/20200514111741.97993-10-ravi.bangoria@linux.ibm.com
(cherry picked from commit 303e6a9ddcdc168e92253c78cdb4bbe1e10d78b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/process.c
#	arch/powerpc/kernel/ptrace/ptrace-noadv.c
#	arch/powerpc/kernel/signal.c
diff --cc arch/powerpc/kernel/process.c
index 6ca2453dede4,d94d8925711c..000000000000
--- a/arch/powerpc/kernel/process.c
+++ b/arch/powerpc/kernel/process.c
@@@ -699,19 -711,49 +699,60 @@@ void switch_booke_debug_regs(struct deb
  EXPORT_SYMBOL_GPL(switch_booke_debug_regs);
  #else	/* !CONFIG_PPC_ADV_DEBUG_REGS */
  #ifndef CONFIG_HAVE_HW_BREAKPOINT
- static void set_breakpoint(struct arch_hw_breakpoint *brk)
+ static void set_breakpoint(int i, struct arch_hw_breakpoint *brk)
  {
  	preempt_disable();
++<<<<<<< HEAD
 +	__set_breakpoint(brk);
++=======
+ 	__set_breakpoint(i, brk);
++>>>>>>> 303e6a9ddcdc (powerpc/watchpoint: Convert thread_struct->hw_brk to an array)
  	preempt_enable();
  }
  
  static void set_debug_reg_defaults(struct thread_struct *thread)
  {
++<<<<<<< HEAD
 +	thread->hw_brk.address = 0;
 +	thread->hw_brk.type = 0;
 +	if (ppc_breakpoint_available())
 +		set_breakpoint(&thread->hw_brk);
++=======
+ 	int i;
+ 	struct arch_hw_breakpoint null_brk = {0};
+ 
+ 	for (i = 0; i < nr_wp_slots(); i++) {
+ 		thread->hw_brk[i] = null_brk;
+ 		if (ppc_breakpoint_available())
+ 			set_breakpoint(i, &thread->hw_brk[i]);
+ 	}
+ }
+ 
+ static inline bool hw_brk_match(struct arch_hw_breakpoint *a,
+ 				struct arch_hw_breakpoint *b)
+ {
+ 	if (a->address != b->address)
+ 		return false;
+ 	if (a->type != b->type)
+ 		return false;
+ 	if (a->len != b->len)
+ 		return false;
+ 	/* no need to check hw_len. it's calculated from address and len */
+ 	return true;
+ }
+ 
+ static void switch_hw_breakpoint(struct task_struct *new)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < nr_wp_slots(); i++) {
+ 		if (likely(hw_brk_match(this_cpu_ptr(&current_brk[i]),
+ 					&new->thread.hw_brk[i])))
+ 			continue;
+ 
+ 		__set_breakpoint(i, &new->thread.hw_brk[i]);
+ 	}
++>>>>>>> 303e6a9ddcdc (powerpc/watchpoint: Convert thread_struct->hw_brk to an array)
  }
  #endif /* !CONFIG_HAVE_HW_BREAKPOINT */
  #endif	/* CONFIG_PPC_ADV_DEBUG_REGS */
@@@ -830,18 -857,6 +871,21 @@@ bool ppc_breakpoint_available(void
  }
  EXPORT_SYMBOL_GPL(ppc_breakpoint_available);
  
++<<<<<<< HEAD
 +static inline bool hw_brk_match(struct arch_hw_breakpoint *a,
 +			      struct arch_hw_breakpoint *b)
 +{
 +	if (a->address != b->address)
 +		return false;
 +	if (a->type != b->type)
 +		return false;
 +	if (a->len != b->len)
 +		return false;
 +	return true;
 +}
 +
++=======
++>>>>>>> 303e6a9ddcdc (powerpc/watchpoint: Convert thread_struct->hw_brk to an array)
  #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
  
  static inline bool tm_enabled(struct task_struct *tsk)
@@@ -1180,8 -1189,7 +1224,12 @@@ struct task_struct *__switch_to(struct 
   * schedule DABR
   */
  #ifndef CONFIG_HAVE_HW_BREAKPOINT
++<<<<<<< HEAD
 +	if (unlikely(!hw_brk_match(this_cpu_ptr(&current_brk), &new->thread.hw_brk)))
 +		__set_breakpoint(&new->thread.hw_brk);
++=======
+ 	switch_hw_breakpoint(new);
++>>>>>>> 303e6a9ddcdc (powerpc/watchpoint: Convert thread_struct->hw_brk to an array)
  #endif /* CONFIG_HAVE_HW_BREAKPOINT */
  #endif
  
diff --cc arch/powerpc/kernel/signal.c
index d215f9554553,b4143b6ff093..000000000000
--- a/arch/powerpc/kernel/signal.c
+++ b/arch/powerpc/kernel/signal.c
@@@ -128,9 -270,15 +127,21 @@@ static void do_signal(struct task_struc
  	 * user space. The DABR will have been cleared if it
  	 * triggered inside the kernel.
  	 */
++<<<<<<< HEAD
 +	if (tsk->thread.hw_brk.address && tsk->thread.hw_brk.type)
 +		__set_breakpoint(&tsk->thread.hw_brk);
 +#endif
++=======
+ 	if (!IS_ENABLED(CONFIG_PPC_ADV_DEBUG_REGS)) {
+ 		int i;
+ 
+ 		for (i = 0; i < nr_wp_slots(); i++) {
+ 			if (tsk->thread.hw_brk[i].address && tsk->thread.hw_brk[i].type)
+ 				__set_breakpoint(i, &tsk->thread.hw_brk[i]);
+ 		}
+ 	}
+ 
++>>>>>>> 303e6a9ddcdc (powerpc/watchpoint: Convert thread_struct->hw_brk to an array)
  	/* Re-enable the breakpoints for the signal stack */
  	thread_change_pc(tsk, tsk->thread.regs);
  
* Unmerged path arch/powerpc/kernel/ptrace/ptrace-noadv.c
diff --git a/arch/powerpc/include/asm/processor.h b/arch/powerpc/include/asm/processor.h
index 8a9d505a7540..31adb74df810 100644
--- a/arch/powerpc/include/asm/processor.h
+++ b/arch/powerpc/include/asm/processor.h
@@ -183,7 +183,7 @@ struct thread_struct {
 	 */
 	struct perf_event *last_hit_ubp;
 #endif /* CONFIG_HAVE_HW_BREAKPOINT */
-	struct arch_hw_breakpoint hw_brk; /* info on the hardware breakpoint */
+	struct arch_hw_breakpoint hw_brk[HBP_NUM_MAX]; /* hardware breakpoint info */
 	unsigned long	trap_nr;	/* last trap # on this thread */
 	u8 load_fp;
 #ifdef CONFIG_ALTIVEC
* Unmerged path arch/powerpc/kernel/process.c
* Unmerged path arch/powerpc/kernel/ptrace/ptrace-noadv.c
diff --git a/arch/powerpc/kernel/ptrace32.c b/arch/powerpc/kernel/ptrace32.c
index 7976ddf29c0e..7589a9665ffb 100644
--- a/arch/powerpc/kernel/ptrace32.c
+++ b/arch/powerpc/kernel/ptrace32.c
@@ -259,8 +259,8 @@ long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
 		ret = put_user(child->thread.debug.dac1, (u32 __user *)data);
 #else
 		dabr_fake = (
-			(child->thread.hw_brk.address & (~HW_BRK_TYPE_DABR)) |
-			(child->thread.hw_brk.type & HW_BRK_TYPE_DABR));
+			(child->thread.hw_brk[0].address & (~HW_BRK_TYPE_DABR)) |
+			(child->thread.hw_brk[0].type & HW_BRK_TYPE_DABR));
 		ret = put_user(dabr_fake, (u32 __user *)data);
 #endif
 		break;
* Unmerged path arch/powerpc/kernel/signal.c
