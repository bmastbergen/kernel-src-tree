vfs: Use sget_fc() for pseudo-filesystems

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit db2c246a091efe2e49aeb3fe0cf6ed2affbddf37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/db2c246a.failed

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: linux-fsdevel@vger.kernel.org
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit db2c246a091efe2e49aeb3fe0cf6ed2affbddf37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/libfs.c
diff --cc fs/libfs.c
index df5499c95c24,7e6811ba4edd..000000000000
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@@ -241,19 -237,40 +241,53 @@@ static const struct super_operations si
  	.statfs		= simple_statfs,
  };
  
- static int pseudo_fs_get_tree(struct fs_context *fc)
+ static int pseudo_fs_fill_super(struct super_block *s, struct fs_context *fc)
  {
  	struct pseudo_fs_context *ctx = fc->fs_private;
++<<<<<<< HEAD
 +	struct dentry *root;
 +
 +	root = mount_pseudo_xattr(fc->fs_type,
 +				  ctx->ops, ctx->xattr,
 +			          ctx->dops, ctx->magic);
 +	if (IS_ERR(root))
 +		return PTR_ERR(root);
 +
 +	fc->root = root;
 +	return 0;
++=======
+ 	struct inode *root;
+ 
+ 	s->s_maxbytes = MAX_LFS_FILESIZE;
+ 	s->s_blocksize = PAGE_SIZE;
+ 	s->s_blocksize_bits = PAGE_SHIFT;
+ 	s->s_magic = ctx->magic;
+ 	s->s_op = ctx->ops ?: &simple_super_operations;
+ 	s->s_xattr = ctx->xattr;
+ 	s->s_time_gran = 1;
+ 	root = new_inode(s);
+ 	if (!root)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * since this is the first inode, make it number 1. New inodes created
+ 	 * after this must take care not to collide with it (by passing
+ 	 * max_reserved of 1 to iunique).
+ 	 */
+ 	root->i_ino = 1;
+ 	root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
+ 	root->i_atime = root->i_mtime = root->i_ctime = current_time(root);
+ 	s->s_root = d_make_root(root);
+ 	if (!s->s_root)
+ 		return -ENOMEM;
+ 	s->s_d_op = ctx->dops;
+ 	return 0;
+ }
+ 
+ static int pseudo_fs_get_tree(struct fs_context *fc)
+ {
+ 	return vfs_get_super(fc, vfs_get_independent_super, pseudo_fs_fill_super);
++>>>>>>> db2c246a091e (vfs: Use sget_fc() for pseudo-filesystems)
  }
  
  static void pseudo_fs_free(struct fs_context *fc)
* Unmerged path fs/libfs.c
