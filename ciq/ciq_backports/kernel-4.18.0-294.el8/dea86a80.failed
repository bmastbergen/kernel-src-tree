arm64: Use arch_timer_read_counter instead of arch_counter_get_cntvct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Marc Zyngier <marc.zyngier@arm.com>
commit dea86a80033f8b0fb25a805f46dde9f3b1a7c23a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dea86a80.failed

Only arch_timer_read_counter will guarantee that workarounds are
applied. So let's use this one instead of arch_counter_get_cntvct.

	Acked-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit dea86a80033f8b0fb25a805f46dde9f3b1a7c23a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/traps.c
diff --cc arch/arm64/kernel/traps.c
index ae6247d29f31,6190a60388cf..000000000000
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@@ -543,6 -554,173 +543,164 @@@ static struct sys64_hook sys64_hooks[] 
  	{},
  };
  
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_COMPAT
+ #define PSTATE_IT_1_0_SHIFT	25
+ #define PSTATE_IT_1_0_MASK	(0x3 << PSTATE_IT_1_0_SHIFT)
+ #define PSTATE_IT_7_2_SHIFT	10
+ #define PSTATE_IT_7_2_MASK	(0x3f << PSTATE_IT_7_2_SHIFT)
+ 
+ static u32 compat_get_it_state(struct pt_regs *regs)
+ {
+ 	u32 it, pstate = regs->pstate;
+ 
+ 	it  = (pstate & PSTATE_IT_1_0_MASK) >> PSTATE_IT_1_0_SHIFT;
+ 	it |= ((pstate & PSTATE_IT_7_2_MASK) >> PSTATE_IT_7_2_SHIFT) << 2;
+ 
+ 	return it;
+ }
+ 
+ static void compat_set_it_state(struct pt_regs *regs, u32 it)
+ {
+ 	u32 pstate_it;
+ 
+ 	pstate_it  = (it << PSTATE_IT_1_0_SHIFT) & PSTATE_IT_1_0_MASK;
+ 	pstate_it |= ((it >> 2) << PSTATE_IT_7_2_SHIFT) & PSTATE_IT_7_2_MASK;
+ 
+ 	regs->pstate &= ~PSR_AA32_IT_MASK;
+ 	regs->pstate |= pstate_it;
+ }
+ 
+ static bool cp15_cond_valid(unsigned int esr, struct pt_regs *regs)
+ {
+ 	int cond;
+ 
+ 	/* Only a T32 instruction can trap without CV being set */
+ 	if (!(esr & ESR_ELx_CV)) {
+ 		u32 it;
+ 
+ 		it = compat_get_it_state(regs);
+ 		if (!it)
+ 			return true;
+ 
+ 		cond = it >> 4;
+ 	} else {
+ 		cond = (esr & ESR_ELx_COND_MASK) >> ESR_ELx_COND_SHIFT;
+ 	}
+ 
+ 	return aarch32_opcode_cond_checks[cond](regs->pstate);
+ }
+ 
+ static void advance_itstate(struct pt_regs *regs)
+ {
+ 	u32 it;
+ 
+ 	/* ARM mode */
+ 	if (!(regs->pstate & PSR_AA32_T_BIT) ||
+ 	    !(regs->pstate & PSR_AA32_IT_MASK))
+ 		return;
+ 
+ 	it  = compat_get_it_state(regs);
+ 
+ 	/*
+ 	 * If this is the last instruction of the block, wipe the IT
+ 	 * state. Otherwise advance it.
+ 	 */
+ 	if (!(it & 7))
+ 		it = 0;
+ 	else
+ 		it = (it & 0xe0) | ((it << 1) & 0x1f);
+ 
+ 	compat_set_it_state(regs, it);
+ }
+ 
+ static void arm64_compat_skip_faulting_instruction(struct pt_regs *regs,
+ 						   unsigned int sz)
+ {
+ 	advance_itstate(regs);
+ 	arm64_skip_faulting_instruction(regs, sz);
+ }
+ 
+ static void compat_cntfrq_read_handler(unsigned int esr, struct pt_regs *regs)
+ {
+ 	int reg = (esr & ESR_ELx_CP15_32_ISS_RT_MASK) >> ESR_ELx_CP15_32_ISS_RT_SHIFT;
+ 
+ 	pt_regs_write_reg(regs, reg, arch_timer_get_rate());
+ 	arm64_compat_skip_faulting_instruction(regs, 4);
+ }
+ 
+ static struct sys64_hook cp15_32_hooks[] = {
+ 	{
+ 		.esr_mask = ESR_ELx_CP15_32_ISS_SYS_MASK,
+ 		.esr_val = ESR_ELx_CP15_32_ISS_SYS_CNTFRQ,
+ 		.handler = compat_cntfrq_read_handler,
+ 	},
+ 	{},
+ };
+ 
+ static void compat_cntvct_read_handler(unsigned int esr, struct pt_regs *regs)
+ {
+ 	int rt = (esr & ESR_ELx_CP15_64_ISS_RT_MASK) >> ESR_ELx_CP15_64_ISS_RT_SHIFT;
+ 	int rt2 = (esr & ESR_ELx_CP15_64_ISS_RT2_MASK) >> ESR_ELx_CP15_64_ISS_RT2_SHIFT;
+ 	u64 val = arch_timer_read_counter();
+ 
+ 	pt_regs_write_reg(regs, rt, lower_32_bits(val));
+ 	pt_regs_write_reg(regs, rt2, upper_32_bits(val));
+ 	arm64_compat_skip_faulting_instruction(regs, 4);
+ }
+ 
+ static struct sys64_hook cp15_64_hooks[] = {
+ 	{
+ 		.esr_mask = ESR_ELx_CP15_64_ISS_SYS_MASK,
+ 		.esr_val = ESR_ELx_CP15_64_ISS_SYS_CNTVCT,
+ 		.handler = compat_cntvct_read_handler,
+ 	},
+ 	{},
+ };
+ 
+ asmlinkage void __exception do_cp15instr(unsigned int esr, struct pt_regs *regs)
+ {
+ 	struct sys64_hook *hook, *hook_base;
+ 
+ 	if (!cp15_cond_valid(esr, regs)) {
+ 		/*
+ 		 * There is no T16 variant of a CP access, so we
+ 		 * always advance PC by 4 bytes.
+ 		 */
+ 		arm64_compat_skip_faulting_instruction(regs, 4);
+ 		return;
+ 	}
+ 
+ 	switch (ESR_ELx_EC(esr)) {
+ 	case ESR_ELx_EC_CP15_32:
+ 		hook_base = cp15_32_hooks;
+ 		break;
+ 	case ESR_ELx_EC_CP15_64:
+ 		hook_base = cp15_64_hooks;
+ 		break;
+ 	default:
+ 		do_undefinstr(regs);
+ 		return;
+ 	}
+ 
+ 	for (hook = hook_base; hook->handler; hook++)
+ 		if ((hook->esr_mask & esr) == hook->esr_val) {
+ 			hook->handler(esr, regs);
+ 			return;
+ 		}
+ 
+ 	/*
+ 	 * New cp15 instructions may previously have been undefined at
+ 	 * EL0. Fall back to our usual undefined instruction handler
+ 	 * so that we handle these consistently.
+ 	 */
+ 	do_undefinstr(regs);
+ }
+ #endif
+ 
++>>>>>>> dea86a80033f (arm64: Use arch_timer_read_counter instead of arch_counter_get_cntvct)
  asmlinkage void __exception do_sysinstr(unsigned int esr, struct pt_regs *regs)
  {
  	struct sys64_hook *hook;
* Unmerged path arch/arm64/kernel/traps.c
