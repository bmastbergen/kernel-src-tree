x86/resctrl: Support CPUID enumeration of MBM counter width

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Reinette Chatre <reinette.chatre@intel.com>
commit f3d44f18b0662327c42128b9d3604489bdb6e36f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f3d44f18.failed

The original Memory Bandwidth Monitoring (MBM) architectural
definition defines counters of up to 62 bits in the
IA32_QM_CTR MSR while the first-generation MBM implementation
uses statically defined 24 bit counters.

Expand the MBM CPUID enumeration properties to include the MBM
counter width. The previously undefined EAX output register contains,
in bits [7:0], the MBM counter width encoded as an offset from
24 bits. Enumerating this property is only specified for Intel
CPUs.

	Suggested-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Reinette Chatre <reinette.chatre@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/afa3af2f753f6bc301fb743bc8944e749cb24afa.1588715690.git.reinette.chatre@intel.com
(cherry picked from commit f3d44f18b0662327c42128b9d3604489bdb6e36f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/resctrl/core.c
diff --cc arch/x86/kernel/cpu/resctrl/core.c
index ff244480fe94,12f967c6b603..000000000000
--- a/arch/x86/kernel/cpu/resctrl/core.c
+++ b/arch/x86/kernel/cpu/resctrl/core.c
@@@ -966,6 -958,36 +966,39 @@@ static __init void rdt_init_res_defs(vo
  
  static enum cpuhp_state rdt_online;
  
++<<<<<<< HEAD
++=======
+ /* Runs once on the BSP during boot. */
+ void resctrl_cpu_detect(struct cpuinfo_x86 *c)
+ {
+ 	if (!cpu_has(c, X86_FEATURE_CQM_LLC)) {
+ 		c->x86_cache_max_rmid  = -1;
+ 		c->x86_cache_occ_scale = -1;
+ 		c->x86_cache_mbm_width_offset = -1;
+ 		return;
+ 	}
+ 
+ 	/* will be overridden if occupancy monitoring exists */
+ 	c->x86_cache_max_rmid = cpuid_ebx(0xf);
+ 
+ 	if (cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC) ||
+ 	    cpu_has(c, X86_FEATURE_CQM_MBM_TOTAL) ||
+ 	    cpu_has(c, X86_FEATURE_CQM_MBM_LOCAL)) {
+ 		u32 eax, ebx, ecx, edx;
+ 
+ 		/* QoS sub-leaf, EAX=0Fh, ECX=1 */
+ 		cpuid_count(0xf, 1, &eax, &ebx, &ecx, &edx);
+ 
+ 		c->x86_cache_max_rmid  = ecx;
+ 		c->x86_cache_occ_scale = ebx;
+ 		if (c->x86_vendor == X86_VENDOR_INTEL)
+ 			c->x86_cache_mbm_width_offset = eax & 0xff;
+ 		else
+ 			c->x86_cache_mbm_width_offset = -1;
+ 	}
+ }
+ 
++>>>>>>> f3d44f18b066 (x86/resctrl: Support CPUID enumeration of MBM counter width)
  static int __init resctrl_late_init(void)
  {
  	struct rdt_resource *r;
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index bb72d1a49158..16699a8aa505 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -122,9 +122,10 @@ struct cpuinfo_x86 {
 	/* in KB - valid for CPUS which support this call: */
 	unsigned int		x86_cache_size;
 	int			x86_cache_alignment;	/* In bytes */
-	/* Cache QoS architectural values: */
+	/* Cache QoS architectural values, valid only on the BSP: */
 	int			x86_cache_max_rmid;	/* max index */
 	int			x86_cache_occ_scale;	/* scale to bytes */
+	int			x86_cache_mbm_width_offset;
 	int			x86_power;
 	unsigned long		loops_per_jiffy;
 	/* cpuid returned max cores value: */
* Unmerged path arch/x86/kernel/cpu/resctrl/core.c
