scsi: qla2xxx: Add SLER and PI control support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saurav Kashyap <skashyap@marvell.com>
commit cf3c54fb49a4eb5b5b83ddab0b25df47b2e958af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cf3c54fb.failed

BIT_13 of extended FW attribute informs about NVMe-2 support.  Set BIT_15
of special feature control block for enabling SLER in FW.  Set bit 8 (SLER
supported) to 1 for the service parameter information when sending NVMe
PRLI request.  Set BIT_14 of special feature control block for enabling PI
Control in FW.  Driver should set bit 9 (PI Control supported) to 1 for the
service parameter information when sending NVMe PRLI request.  Set BIT_13
for NVMe Async events.

Link: https://lore.kernel.org/r/20200904045128.23631-13-njavali@marvell.com
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Signed-off-by: Saurav Kashyap <skashyap@marvell.com>
	Signed-off-by: Nilesh Javali <njavali@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit cf3c54fb49a4eb5b5b83ddab0b25df47b2e958af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_nvme.h
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index ecba6f991af8,fa31301528bd..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -4100,6 -4305,13 +4102,16 @@@ struct qla_hw_data 
  #define FW_ATTR_H_NVME		BIT_10
  #define FW_ATTR_H_NVME_UPDATED  BIT_14
  
++<<<<<<< HEAD
++=======
+ 	/* About firmware SCM support */
+ #define FW_ATTR_EXT0_SCM_SUPPORTED	BIT_12
+ 	/* Brocade fabric attached */
+ #define FW_ATTR_EXT0_SCM_BROCADE	0x00001000
+ 	/* Cisco fabric attached */
+ #define FW_ATTR_EXT0_SCM_CISCO		0x00002000
+ #define FW_ATTR_EXT0_NVME2	BIT_13
++>>>>>>> cf3c54fb49a4 (scsi: qla2xxx: Add SLER and PI control support)
  	uint16_t	fw_attributes_ext[2];
  	uint32_t	fw_memory_size;
  	uint32_t	fw_transfer_size;
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index cf655f3a6e69,310db7e4e233..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2344,9 -2374,18 +2344,22 @@@ qla24xx_prli_iocb(srb_t *sp, struct log
  	logio->entry_type = LOGINOUT_PORT_IOCB_TYPE;
  	logio->control_flags = cpu_to_le16(LCF_COMMAND_PRLI);
  	if (lio->u.logio.flags & SRB_LOGIN_NVME_PRLI) {
 -		logio->control_flags |= cpu_to_le16(LCF_NVME_PRLI);
 +		logio->control_flags |= LCF_NVME_PRLI;
  		if (sp->vha->flags.nvme_first_burst)
++<<<<<<< HEAD
 +			logio->io_parameter[0] = NVME_PRLI_SP_FIRST_BURST;
++=======
+ 			logio->io_parameter[0] =
+ 				cpu_to_le32(NVME_PRLI_SP_FIRST_BURST);
+ 		if (sp->vha->flags.nvme2_enabled) {
+ 			/* Set service parameter BIT_8 for SLER support */
+ 			logio->io_parameter[0] |=
+ 				cpu_to_le32(NVME_PRLI_SP_SLER);
+ 			/* Set service parameter BIT_9 for PI control support */
+ 			logio->io_parameter[0] |=
+ 				cpu_to_le32(NVME_PRLI_SP_PI_CTRL);
+ 		}
++>>>>>>> cf3c54fb49a4 (scsi: qla2xxx: Add SLER and PI control support)
  	}
  
  	logio->nport_handle = cpu_to_le16(sp->fcport->loop_id);
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 6c0553957232,597617b59fbb..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -1118,6 -1126,22 +1126,25 @@@ qla2x00_get_fw_version(scsi_qla_host_t 
  			    (ha->flags.secure_fw) ? "Supported" :
  			    "Not Supported");
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		if (ha->flags.scm_supported_a &&
+ 		    (ha->fw_attributes_ext[0] & FW_ATTR_EXT0_SCM_SUPPORTED)) {
+ 			ha->flags.scm_supported_f = 1;
+ 			ha->sf_init_cb->flags |= BIT_13;
+ 		}
+ 		ql_log(ql_log_info, vha, 0x11a3, "SCM in FW: %s\n",
+ 		       (ha->flags.scm_supported_f) ? "Supported" :
+ 		       "Not Supported");
+ 
+ 		if (vha->flags.nvme2_enabled) {
+ 			/* set BIT_15 of special feature control block for SLER */
+ 			ha->sf_init_cb->flags |= BIT_15;
+ 			/* set BIT_14 of special feature control block for PI CTRL*/
+ 			ha->sf_init_cb->flags |= BIT_14;
+ 		}
++>>>>>>> cf3c54fb49a4 (scsi: qla2xxx: Add SLER and PI control support)
  	}
  
  failed:
@@@ -1795,6 -1836,17 +1822,20 @@@ qla2x00_init_firmware(scsi_qla_host_t *
  		mcp->mb[14] = sizeof(*ha->ex_init_cb);
  		mcp->out_mb |= MBX_14|MBX_13|MBX_12|MBX_11|MBX_10;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (ha->flags.scm_supported_f || vha->flags.nvme2_enabled) {
+ 		mcp->mb[1] |= BIT_1;
+ 		mcp->mb[16] = MSW(ha->sf_init_cb_dma);
+ 		mcp->mb[17] = LSW(ha->sf_init_cb_dma);
+ 		mcp->mb[18] = MSW(MSD(ha->sf_init_cb_dma));
+ 		mcp->mb[19] = LSW(MSD(ha->sf_init_cb_dma));
+ 		mcp->mb[15] = sizeof(*ha->sf_init_cb);
+ 		mcp->out_mb |= MBX_19|MBX_18|MBX_17|MBX_16|MBX_15;
+ 	}
+ 
++>>>>>>> cf3c54fb49a4 (scsi: qla2xxx: Add SLER and PI control support)
  	/* 1 and 2 should normally be captured. */
  	mcp->in_mb = MBX_2|MBX_1|MBX_0;
  	if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
diff --cc drivers/scsi/qla2xxx/qla_nvme.h
index 500e8bfa01fb,5d5f115a77c3..000000000000
--- a/drivers/scsi/qla2xxx/qla_nvme.h
+++ b/drivers/scsi/qla2xxx/qla_nvme.h
@@@ -53,7 -53,8 +53,12 @@@ struct cmd_nvme 
  
  	uint64_t rsvd;
  
++<<<<<<< HEAD
 +	uint16_t control_flags;         /* Control Flags */
++=======
+ 	__le16	control_flags;		/* Control Flags */
+ #define CF_ADMIN_ASYNC_EVENT		BIT_13
++>>>>>>> cf3c54fb49a4 (scsi: qla2xxx: Add SLER and PI control support)
  #define CF_NVME_FIRST_BURST_ENABLE	BIT_11
  #define CF_DIF_SEG_DESCR_ENABLE         BIT_3
  #define CF_DATA_SEG_DESCR_ENABLE        BIT_2
diff --cc drivers/scsi/qla2xxx/qla_os.c
index e7ddfc48259e,c7e3d8b485b4..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -4071,6 -4225,17 +4071,20 @@@ qla2x00_mem_alloc(struct qla_hw_data *h
  		    "ex_init_cb=%p.\n", ha->ex_init_cb);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Get consistent memory allocated for Special Features-CB. */
+ 	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
+ 		ha->sf_init_cb = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,
+ 						&ha->sf_init_cb_dma);
+ 		if (!ha->sf_init_cb)
+ 			goto fail_sf_init_cb;
+ 		memset(ha->sf_init_cb, 0, sizeof(struct init_sf_cb));
+ 		ql_dbg_pci(ql_dbg_init, ha->pdev, 0x0199,
+ 			   "sf_init_cb=%p.\n", ha->sf_init_cb);
+ 	}
+ 
++>>>>>>> cf3c54fb49a4 (scsi: qla2xxx: Add SLER and PI control support)
  	INIT_LIST_HEAD(&ha->gbl_dsd_list);
  
  	/* Get consistent memory allocated for Async Port-Database. */
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index fbd8cb5647b6..22aa206c0a27 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -18,7 +18,7 @@
  * | Device Discovery             |       0x2134       | 0x210e-0x2116  |
  * |				  | 		       | 0x211a         |
  * |                              |                    | 0x211c-0x2128  |
- * |                              |                    | 0x212a-0x2134  |
+ * |                              |                    | 0x212c-0x2134  |
  * | Queue Command and IO tracing |       0x3074       | 0x300b         |
  * |                              |                    | 0x3027-0x3028  |
  * |                              |                    | 0x303d-0x3041  |
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
diff --git a/drivers/scsi/qla2xxx/qla_nvme.c b/drivers/scsi/qla2xxx/qla_nvme.c
index 4145485a75ec..c3422e8ef5eb 100644
--- a/drivers/scsi/qla2xxx/qla_nvme.c
+++ b/drivers/scsi/qla2xxx/qla_nvme.c
@@ -69,6 +69,14 @@ int qla_nvme_register_remote(struct scsi_qla_host *vha, struct fc_port *fcport)
 		return ret;
 	}
 
+	if (fcport->nvme_prli_service_param & NVME_PRLI_SP_SLER)
+		ql_log(ql_log_info, vha, 0x212a,
+		       "PortID:%06x Supports SLER\n", req.port_id);
+
+	if (fcport->nvme_prli_service_param & NVME_PRLI_SP_PI_CTRL)
+		ql_log(ql_log_info, vha, 0x212b,
+		       "PortID:%06x Supports PI control\n", req.port_id);
+
 	rport = fcport->nvme_remote_port->private;
 	rport->fcport = fcport;
 
@@ -367,6 +375,7 @@ static inline int qla2x00_start_nvme_mq(srb_t *sp)
 	struct srb_iocb *nvme = &sp->u.iocb_cmd;
 	struct scatterlist *sgl, *sg;
 	struct nvmefc_fcp_req *fd = nvme->u.nvme.desc;
+	struct nvme_fc_cmd_iu *cmd = fd->cmdaddr;
 	uint32_t        rval = QLA_SUCCESS;
 
 	/* Setup qpair pointers */
@@ -398,8 +407,6 @@ static inline int qla2x00_start_nvme_mq(srb_t *sp)
 	}
 
 	if (unlikely(!fd->sqid)) {
-		struct nvme_fc_cmd_iu *cmd = fd->cmdaddr;
-
 		if (cmd->sqe.common.opcode == nvme_admin_async_event) {
 			nvme->u.nvme.aen_op = 1;
 			atomic_inc(&ha->nvme_active_aen_cnt);
@@ -445,6 +452,11 @@ static inline int qla2x00_start_nvme_mq(srb_t *sp)
 	} else if (fd->io_dir == 0) {
 		cmd_pkt->control_flags = 0;
 	}
+	/* Set BIT_13 of control flags for Async event */
+	if (vha->flags.nvme2_enabled &&
+	    cmd->sqe.common.opcode == nvme_admin_async_event) {
+		cmd_pkt->control_flags |= cpu_to_le16(CF_ADMIN_ASYNC_EVENT);
+	}
 
 	/* Set NPORT-ID */
 	cmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.h
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
