NFS: Fix listxattr receive buffer size

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 6c2190b3fcbc92cb79e39cc7e7531656b341e463
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6c2190b3.failed

Certain NFSv4.2/RDMA tests fail with v5.9-rc1.

rpcrdma_convert_kvec() runs off the end of the rl_segments array
because rq_rcv_buf.tail[0].iov_len holds a very large positive
value. The resultant kernel memory corruption is enough to crash
the client system.

Callers of rpc_prepare_reply_pages() must reserve an extra XDR_UNIT
in the maximum decode size for a possible XDR pad of the contents
of the xdr_buf's pages. That guarantees the allocated receive buffer
will be large enough to accommodate the usual contents plus that XDR
pad word.

encode_op_hdr() cannot add that extra word. If it does,
xdr_inline_pages() underruns the length of the tail iovec.

Fixes: 3e1f02123fba ("NFSv4.2: add client side XDR handling for extended attributes")
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 6c2190b3fcbc92cb79e39cc7e7531656b341e463)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42xdr.c
diff --cc fs/nfs/nfs42xdr.c
index aed865a84629,6e060a88f98c..000000000000
--- a/fs/nfs/nfs42xdr.c
+++ b/fs/nfs/nfs42xdr.c
@@@ -150,6 -186,78 +150,81 @@@
  					 decode_clone_maxsz + \
  					 decode_getattr_maxsz)
  
++<<<<<<< HEAD
++=======
+ /* Not limited by NFS itself, limited by the generic xattr code */
+ #define nfs4_xattr_name_maxsz   XDR_QUADLEN(XATTR_NAME_MAX)
+ 
+ #define encode_getxattr_maxsz   (op_encode_hdr_maxsz + 1 + \
+ 				 nfs4_xattr_name_maxsz)
+ #define decode_getxattr_maxsz   (op_decode_hdr_maxsz + 1 + 1)
+ #define encode_setxattr_maxsz   (op_encode_hdr_maxsz + \
+ 				 1 + nfs4_xattr_name_maxsz + 1)
+ #define decode_setxattr_maxsz   (op_decode_hdr_maxsz + decode_change_info_maxsz)
+ #define encode_listxattrs_maxsz  (op_encode_hdr_maxsz + 2 + 1)
+ #define decode_listxattrs_maxsz  (op_decode_hdr_maxsz + 2 + 1 + 1 + 1)
+ #define encode_removexattr_maxsz (op_encode_hdr_maxsz + 1 + \
+ 				  nfs4_xattr_name_maxsz)
+ #define decode_removexattr_maxsz (op_decode_hdr_maxsz + \
+ 				  decode_change_info_maxsz)
+ 
+ #define NFS4_enc_getxattr_sz	(compound_encode_hdr_maxsz + \
+ 				encode_sequence_maxsz + \
+ 				encode_putfh_maxsz + \
+ 				encode_getxattr_maxsz)
+ #define NFS4_dec_getxattr_sz	(compound_decode_hdr_maxsz + \
+ 				decode_sequence_maxsz + \
+ 				decode_putfh_maxsz + \
+ 				decode_getxattr_maxsz)
+ #define NFS4_enc_setxattr_sz	(compound_encode_hdr_maxsz + \
+ 				encode_sequence_maxsz + \
+ 				encode_putfh_maxsz + \
+ 				encode_setxattr_maxsz)
+ #define NFS4_dec_setxattr_sz	(compound_decode_hdr_maxsz + \
+ 				decode_sequence_maxsz + \
+ 				decode_putfh_maxsz + \
+ 				decode_setxattr_maxsz)
+ #define NFS4_enc_listxattrs_sz	(compound_encode_hdr_maxsz + \
+ 				encode_sequence_maxsz + \
+ 				encode_putfh_maxsz + \
+ 				encode_listxattrs_maxsz)
+ #define NFS4_dec_listxattrs_sz	(compound_decode_hdr_maxsz + \
+ 				decode_sequence_maxsz + \
+ 				decode_putfh_maxsz + \
+ 				decode_listxattrs_maxsz)
+ #define NFS4_enc_removexattr_sz	(compound_encode_hdr_maxsz + \
+ 				encode_sequence_maxsz + \
+ 				encode_putfh_maxsz + \
+ 				encode_removexattr_maxsz)
+ #define NFS4_dec_removexattr_sz	(compound_decode_hdr_maxsz + \
+ 				decode_sequence_maxsz + \
+ 				decode_putfh_maxsz + \
+ 				decode_removexattr_maxsz)
+ 
+ /*
+  * These values specify the maximum amount of data that is not
+  * associated with the extended attribute name or extended
+  * attribute list in the SETXATTR, GETXATTR and LISTXATTR
+  * respectively.
+  */
+ const u32 nfs42_maxsetxattr_overhead = ((RPC_MAX_HEADER_WITH_AUTH +
+ 					compound_encode_hdr_maxsz +
+ 					encode_sequence_maxsz +
+ 					encode_putfh_maxsz + 1 +
+ 					nfs4_xattr_name_maxsz)
+ 					* XDR_UNIT);
+ 
+ const u32 nfs42_maxgetxattr_overhead = ((RPC_MAX_HEADER_WITH_AUTH +
+ 					compound_decode_hdr_maxsz +
+ 					decode_sequence_maxsz +
+ 					decode_putfh_maxsz + 1) * XDR_UNIT);
+ 
+ const u32 nfs42_maxlistxattrs_overhead = ((RPC_MAX_HEADER_WITH_AUTH +
+ 					compound_decode_hdr_maxsz +
+ 					decode_sequence_maxsz +
+ 					decode_putfh_maxsz + 3) * XDR_UNIT);
+ 
++>>>>>>> 6c2190b3fcbc (NFS: Fix listxattr receive buffer size)
  static void encode_fallocate(struct xdr_stream *xdr,
  			     const struct nfs42_falloc_args *args)
  {
@@@ -280,6 -432,210 +355,213 @@@ static void encode_layouterror(struct x
  	encode_device_error(xdr, &args->errors[0]);
  }
  
++<<<<<<< HEAD
++=======
+ static void encode_setxattr(struct xdr_stream *xdr,
+ 			    const struct nfs42_setxattrargs *arg,
+ 			    struct compound_hdr *hdr)
+ {
+ 	__be32 *p;
+ 
+ 	BUILD_BUG_ON(XATTR_CREATE != SETXATTR4_CREATE);
+ 	BUILD_BUG_ON(XATTR_REPLACE != SETXATTR4_REPLACE);
+ 
+ 	encode_op_hdr(xdr, OP_SETXATTR, decode_setxattr_maxsz, hdr);
+ 	p = reserve_space(xdr, 4);
+ 	*p = cpu_to_be32(arg->xattr_flags);
+ 	encode_string(xdr, strlen(arg->xattr_name), arg->xattr_name);
+ 	p = reserve_space(xdr, 4);
+ 	*p = cpu_to_be32(arg->xattr_len);
+ 	if (arg->xattr_len)
+ 		xdr_write_pages(xdr, arg->xattr_pages, 0, arg->xattr_len);
+ }
+ 
+ static int decode_setxattr(struct xdr_stream *xdr,
+ 			   struct nfs4_change_info *cinfo)
+ {
+ 	int status;
+ 
+ 	status = decode_op_hdr(xdr, OP_SETXATTR);
+ 	if (status)
+ 		goto out;
+ 	status = decode_change_info(xdr, cinfo);
+ out:
+ 	return status;
+ }
+ 
+ 
+ static void encode_getxattr(struct xdr_stream *xdr, const char *name,
+ 			    struct compound_hdr *hdr)
+ {
+ 	encode_op_hdr(xdr, OP_GETXATTR, decode_getxattr_maxsz, hdr);
+ 	encode_string(xdr, strlen(name), name);
+ }
+ 
+ static int decode_getxattr(struct xdr_stream *xdr,
+ 			   struct nfs42_getxattrres *res,
+ 			   struct rpc_rqst *req)
+ {
+ 	int status;
+ 	__be32 *p;
+ 	u32 len, rdlen;
+ 
+ 	status = decode_op_hdr(xdr, OP_GETXATTR);
+ 	if (status)
+ 		return status;
+ 
+ 	p = xdr_inline_decode(xdr, 4);
+ 	if (unlikely(!p))
+ 		return -EIO;
+ 
+ 	len = be32_to_cpup(p);
+ 	if (len > req->rq_rcv_buf.page_len)
+ 		return -ERANGE;
+ 
+ 	res->xattr_len = len;
+ 
+ 	if (len > 0) {
+ 		rdlen = xdr_read_pages(xdr, len);
+ 		if (rdlen < len)
+ 			return -EIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void encode_removexattr(struct xdr_stream *xdr, const char *name,
+ 			       struct compound_hdr *hdr)
+ {
+ 	encode_op_hdr(xdr, OP_REMOVEXATTR, decode_removexattr_maxsz, hdr);
+ 	encode_string(xdr, strlen(name), name);
+ }
+ 
+ 
+ static int decode_removexattr(struct xdr_stream *xdr,
+ 			   struct nfs4_change_info *cinfo)
+ {
+ 	int status;
+ 
+ 	status = decode_op_hdr(xdr, OP_REMOVEXATTR);
+ 	if (status)
+ 		goto out;
+ 
+ 	status = decode_change_info(xdr, cinfo);
+ out:
+ 	return status;
+ }
+ 
+ static void encode_listxattrs(struct xdr_stream *xdr,
+ 			     const struct nfs42_listxattrsargs *arg,
+ 			     struct compound_hdr *hdr)
+ {
+ 	__be32 *p;
+ 
+ 	encode_op_hdr(xdr, OP_LISTXATTRS, decode_listxattrs_maxsz, hdr);
+ 
+ 	p = reserve_space(xdr, 12);
+ 	if (unlikely(!p))
+ 		return;
+ 
+ 	p = xdr_encode_hyper(p, arg->cookie);
+ 	/*
+ 	 * RFC 8276 says to specify the full max length of the LISTXATTRS
+ 	 * XDR reply. Count is set to the XDR length of the names array
+ 	 * plus the EOF marker. So, add the cookie and the names count.
+ 	 */
+ 	*p = cpu_to_be32(arg->count + 8 + 4);
+ }
+ 
+ static int decode_listxattrs(struct xdr_stream *xdr,
+ 			    struct nfs42_listxattrsres *res)
+ {
+ 	int status;
+ 	__be32 *p;
+ 	u32 count, len, ulen;
+ 	size_t left, copied;
+ 	char *buf;
+ 
+ 	status = decode_op_hdr(xdr, OP_LISTXATTRS);
+ 	if (status) {
+ 		/*
+ 		 * Special case: for LISTXATTRS, NFS4ERR_TOOSMALL
+ 		 * should be translated to ERANGE.
+ 		 */
+ 		if (status == -ETOOSMALL)
+ 			status = -ERANGE;
+ 		goto out;
+ 	}
+ 
+ 	p = xdr_inline_decode(xdr, 8);
+ 	if (unlikely(!p))
+ 		return -EIO;
+ 
+ 	xdr_decode_hyper(p, &res->cookie);
+ 
+ 	p = xdr_inline_decode(xdr, 4);
+ 	if (unlikely(!p))
+ 		return -EIO;
+ 
+ 	left = res->xattr_len;
+ 	buf = res->xattr_buf;
+ 
+ 	count = be32_to_cpup(p);
+ 	copied = 0;
+ 
+ 	/*
+ 	 * We have asked for enough room to encode the maximum number
+ 	 * of possible attribute names, so everything should fit.
+ 	 *
+ 	 * But, don't rely on that assumption. Just decode entries
+ 	 * until they don't fit anymore, just in case the server did
+ 	 * something odd.
+ 	 */
+ 	while (count--) {
+ 		p = xdr_inline_decode(xdr, 4);
+ 		if (unlikely(!p))
+ 			return -EIO;
+ 
+ 		len = be32_to_cpup(p);
+ 		if (len > (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN)) {
+ 			status = -ERANGE;
+ 			goto out;
+ 		}
+ 
+ 		p = xdr_inline_decode(xdr, len);
+ 		if (unlikely(!p))
+ 			return -EIO;
+ 
+ 		ulen = len + XATTR_USER_PREFIX_LEN + 1;
+ 		if (buf) {
+ 			if (ulen > left) {
+ 				status = -ERANGE;
+ 				goto out;
+ 			}
+ 
+ 			memcpy(buf, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);
+ 			memcpy(buf + XATTR_USER_PREFIX_LEN, p, len);
+ 
+ 			buf[ulen - 1] = 0;
+ 			buf += ulen;
+ 			left -= ulen;
+ 		}
+ 		copied += ulen;
+ 	}
+ 
+ 	p = xdr_inline_decode(xdr, 4);
+ 	if (unlikely(!p))
+ 		return -EIO;
+ 
+ 	res->eof = be32_to_cpup(p);
+ 	res->copied = copied;
+ 
+ out:
+ 	if (status == -ERANGE && res->xattr_len == XATTR_LIST_MAX)
+ 		status = -E2BIG;
+ 
+ 	return status;
+ }
+ 
++>>>>>>> 6c2190b3fcbc (NFS: Fix listxattr receive buffer size)
  /*
   * Encode ALLOCATE request
   */
* Unmerged path fs/nfs/nfs42xdr.c
