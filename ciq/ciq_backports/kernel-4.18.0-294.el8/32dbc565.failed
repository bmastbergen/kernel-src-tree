fs/xfs: Create function xfs_inode_should_enable_dax()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit 32dbc5655f1ccb3bffa5785523146f60fa4bf905
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/32dbc565.failed

xfs_inode_supports_dax() should reflect if the inode can support DAX not
that it is enabled for DAX.

Change the use of xfs_inode_supports_dax() to reflect only if the inode
and underlying storage support dax.

Add a new function xfs_inode_should_enable_dax() which reflects if the
inode should be enabled for DAX.

	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 32dbc5655f1ccb3bffa5785523146f60fa4bf905)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_iops.c
diff --cc fs/xfs/xfs_iops.c
index 841eb213b84c,6b9a29a05217..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -1241,13 -1238,12 +1241,18 @@@ xfs_inode_supports_dax
  {
  	struct xfs_mount	*mp = ip->i_mount;
  
- 	/* Only supported on non-reflinked files. */
- 	if (!S_ISREG(VFS_I(ip)->i_mode) || xfs_is_reflink_inode(ip))
+ 	/* Only supported on regular files. */
+ 	if (!S_ISREG(VFS_I(ip)->i_mode))
  		return false;
  
++<<<<<<< HEAD
 +	/* DAX mount option or DAX iflag must be set. */
 +	if (!(mp->m_flags & XFS_MOUNT_DAX) &&
 +	    !(ip->i_d.di_flags2 & XFS_DIFLAG2_DAX))
++=======
+ 	/* Only supported on non-reflinked files. */
+ 	if (xfs_is_reflink_inode(ip))
++>>>>>>> 32dbc5655f1c (fs/xfs: Create function xfs_inode_should_enable_dax())
  		return false;
  
  	/* Block size must match page size */
@@@ -1255,9 -1251,26 +1260,26 @@@
  		return false;
  
  	/* Device has to support DAX too. */
 -	return xfs_inode_buftarg(ip)->bt_daxdev != NULL;
 +	return xfs_find_daxdev_for_inode(VFS_I(ip)) != NULL;
  }
  
+ static bool
+ xfs_inode_should_enable_dax(
+ 	struct xfs_inode *ip)
+ {
+ 	if (!IS_ENABLED(CONFIG_FS_DAX))
+ 		return false;
+ 	if (ip->i_mount->m_flags & XFS_MOUNT_DAX_NEVER)
+ 		return false;
+ 	if (!xfs_inode_supports_dax(ip))
+ 		return false;
+ 	if (ip->i_mount->m_flags & XFS_MOUNT_DAX_ALWAYS)
+ 		return true;
+ 	if (ip->i_d.di_flags2 & XFS_DIFLAG2_DAX)
+ 		return true;
+ 	return false;
+ }
+ 
  STATIC void
  xfs_diflags_to_iflags(
  	struct inode		*inode,
* Unmerged path fs/xfs/xfs_iops.c
