x86/entry/64: Correct the comment over SAVE_AND_SET_GSBASE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Borislav Petkov <bp@suse.de>
commit 0b2c605fa4ee3117c00b97b7af67791576b28f88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0b2c605f.failed

Add the proper explanation why an LFENCE is not needed in the FSGSBASE
case.

Fixes: c82965f9e530 ("x86/entry/64: Handle FSGSBASE enabled paranoid entry/exit")
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20200821090710.GE12181@zn.tnic
(cherry picked from commit 0b2c605fa4ee3117c00b97b7af67791576b28f88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/entry_64.S
diff --cc arch/x86/entry/entry_64.S
index 955c9ec809bc,bf78de4de7f0..000000000000
--- a/arch/x86/entry/entry_64.S
+++ b/arch/x86/entry/entry_64.S
@@@ -1206,7 -807,53 +1206,52 @@@ ENTRY(paranoid_entry
  	cld
  	PUSH_AND_CLEAR_REGS save_ret=1
  	ENCODE_FRAME_POINTER 8
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Always stash CR3 in %r14.  This value will be restored,
+ 	 * verbatim, at exit.  Needed if paranoid_entry interrupted
+ 	 * another entry that already switched to the user CR3 value
+ 	 * but has not yet returned to userspace.
+ 	 *
+ 	 * This is also why CS (stashed in the "iret frame" by the
+ 	 * hardware at entry) can not be used: this may be a return
+ 	 * to kernel code, but with a user CR3 value.
+ 	 *
+ 	 * Switching CR3 does not depend on kernel GSBASE so it can
+ 	 * be done before switching to the kernel GSBASE. This is
+ 	 * required for FSGSBASE because the kernel GSBASE has to
+ 	 * be retrieved from a kernel internal table.
+ 	 */
+ 	SAVE_AND_SWITCH_TO_KERNEL_CR3 scratch_reg=%rax save_reg=%r14
+ 
+ 	/*
+ 	 * Handling GSBASE depends on the availability of FSGSBASE.
+ 	 *
+ 	 * Without FSGSBASE the kernel enforces that negative GSBASE
+ 	 * values indicate kernel GSBASE. With FSGSBASE no assumptions
+ 	 * can be made about the GSBASE value when entering from user
+ 	 * space.
+ 	 */
+ 	ALTERNATIVE "jmp .Lparanoid_entry_checkgs", "", X86_FEATURE_FSGSBASE
+ 
+ 	/*
+ 	 * Read the current GSBASE and store it in %rbx unconditionally,
+ 	 * retrieve and set the current CPUs kernel GSBASE. The stored value
+ 	 * has to be restored in paranoid_exit unconditionally.
+ 	 *
+ 	 * The unconditional write to GS base below ensures that no subsequent
+ 	 * loads based on a mispredicted GS base can happen, therefore no LFENCE
+ 	 * is needed here.
+ 	 */
+ 	SAVE_AND_SET_GSBASE scratch_reg=%rax save_reg=%rbx
+ 	ret
+ 
+ .Lparanoid_entry_checkgs:
+ 	/* EBX = 1 -> kernel GSBASE active, no restore required */
++>>>>>>> 0b2c605fa4ee (x86/entry/64: Correct the comment over SAVE_AND_SET_GSBASE)
  	movl	$1, %ebx
 -	/*
 -	 * The kernel-enforced convention is a negative GSBASE indicates
 -	 * a kernel value. No SWAPGS needed on entry and exit.
 -	 */
  	movl	$MSR_GS_BASE, %ecx
  	rdmsr
  	testl	%edx, %edx
* Unmerged path arch/x86/entry/entry_64.S
