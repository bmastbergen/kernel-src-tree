iwlwifi: remove sw_csum_tx

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Emmanuel Grumbach <emmanuel.grumbach@intel.com>
commit 59fa61f3fd4ee5315190d4233ac3e6ca1a411556
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/59fa61f3.failed

This was a hack done to test the data path of devices that
didn't support well CSUM offload in Tx. This is not needed
anymore.

	Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Link: https://lore.kernel.org/r/iwlwifi.20201209231352.6c9fc9fb48d5.I2aaebf90e6fe81860105d049a8d35746fa8d86c2@changeid
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit 59fa61f3fd4ee5315190d4233ac3e6ca1a411556)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/pcie/tx.c
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/tx.c
index 10f21cd31aff,cc8c76aea4e8..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
@@@ -2050,70 -1497,6 +2050,73 @@@ static int iwl_fill_data_tbs(struct iwl
  }
  
  #ifdef CONFIG_INET
++<<<<<<< HEAD
 +struct iwl_tso_hdr_page *get_page_hdr(struct iwl_trans *trans, size_t len,
 +				      struct sk_buff *skb)
 +{
 +	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 +	struct iwl_tso_hdr_page *p = this_cpu_ptr(trans_pcie->tso_hdr_page);
 +	struct page **page_ptr;
 +
 +	page_ptr = (void *)((u8 *)skb->cb + trans->txqs.page_offs);
 +
 +	if (WARN_ON(*page_ptr))
 +		return NULL;
 +
 +	if (!p->page)
 +		goto alloc;
 +
 +	/*
 +	 * Check if there's enough room on this page
 +	 *
 +	 * Note that we put a page chaining pointer *last* in the
 +	 * page - we need it somewhere, and if it's there then we
 +	 * avoid DMA mapping the last bits of the page which may
 +	 * trigger the 32-bit boundary hardware bug.
 +	 *
 +	 * (see also get_workaround_page() in tx-gen2.c)
 +	 */
 +	if (p->pos + len < (u8 *)page_address(p->page) + PAGE_SIZE -
 +			   sizeof(void *))
 +		goto out;
 +
 +	/* We don't have enough room on this page, get a new one. */
 +	__free_page(p->page);
 +
 +alloc:
 +	p->page = alloc_page(GFP_ATOMIC);
 +	if (!p->page)
 +		return NULL;
 +	p->pos = page_address(p->page);
 +	/* set the chaining pointer to NULL */
 +	*(void **)(page_address(p->page) + PAGE_SIZE - sizeof(void *)) = NULL;
 +out:
 +	*page_ptr = p->page;
 +	get_page(p->page);
 +	return p;
 +}
 +
 +static void iwl_compute_pseudo_hdr_csum(void *iph, struct tcphdr *tcph,
 +					bool ipv6, unsigned int len)
 +{
 +	if (ipv6) {
 +		struct ipv6hdr *iphv6 = iph;
 +
 +		tcph->check = ~csum_ipv6_magic(&iphv6->saddr, &iphv6->daddr,
 +					       len + tcph->doff * 4,
 +					       IPPROTO_TCP, 0);
 +	} else {
 +		struct iphdr *iphv4 = iph;
 +
 +		ip_send_check(iphv4);
 +		tcph->check = ~csum_tcpudp_magic(iphv4->saddr, iphv4->daddr,
 +						 len + tcph->doff * 4,
 +						 IPPROTO_TCP, 0);
 +	}
 +}
 +
++=======
++>>>>>>> 59fa61f3fd4e (iwlwifi: remove sw_csum_tx)
  static int iwl_fill_data_tbs_amsdu(struct iwl_trans *trans, struct sk_buff *skb,
  				   struct iwl_txq *txq, u8 hdr_len,
  				   struct iwl_cmd_meta *out_meta,
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.h b/drivers/net/wireless/intel/iwlwifi/iwl-trans.h
index c9a8ac1c0f28..d41d1a0e74e4 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.h
@@ -431,7 +431,6 @@ struct iwl_hcmd_arr {
  * @bc_table_dword: set to true if the BC table expects the byte count to be
  *	in DWORD (as opposed to bytes)
  * @scd_set_active: should the transport configure the SCD for HCMD queue
- * @sw_csum_tx: transport should compute the TCP checksum
  * @command_groups: array of command groups, each member is an array of the
  *	commands in the group; for debugging only
  * @command_groups_size: number of command groups, to avoid illegal access
@@ -450,7 +449,6 @@ struct iwl_trans_config {
 	enum iwl_amsdu_size rx_buf_size;
 	bool bc_table_dword;
 	bool scd_set_active;
-	bool sw_csum_tx;
 	const struct iwl_hcmd_arr *command_groups;
 	int command_groups_size;
 
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/constants.h b/drivers/net/wireless/intel/iwlwifi/mvm/constants.h
index b4eeb4be3ac7..7fde457e1183 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/constants.h
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/constants.h
@@ -107,7 +107,6 @@
 #define IWL_MVM_RS_RSSI_BASED_INIT_RATE         0
 #define IWL_MVM_RS_80_20_FAR_RANGE_TWEAK	1
 #define IWL_MVM_TOF_IS_RESPONDER		0
-#define IWL_MVM_SW_TX_CSUM_OFFLOAD		0
 #define IWL_MVM_HW_CSUM_DISABLE			0
 #define IWL_MVM_PARSE_NVM			0
 #define IWL_MVM_ADWELL_ENABLE			1
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
index c7d527d22fdb..665345335fc9 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
@@ -754,13 +754,9 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 	}
 
 	hw->netdev_features |= mvm->cfg->features;
-	if (!iwl_mvm_is_csum_supported(mvm)) {
+	if (!iwl_mvm_is_csum_supported(mvm))
 		hw->netdev_features &= ~(IWL_TX_CSUM_NETIF_FLAGS |
 					 NETIF_F_RXCSUM);
-		/* We may support SW TX CSUM */
-		if (IWL_MVM_SW_TX_CSUM_OFFLOAD)
-			hw->netdev_features |= IWL_TX_CSUM_NETIF_FLAGS;
-	}
 
 	if (mvm->cfg->vht_mu_mimo_supported)
 		wiphy_ext_feature_set(hw->wiphy,
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c
index abd353c94f9c..3e90cae95b48 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c
@@ -795,8 +795,6 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	trans_cfg.cb_data_offs = offsetof(struct ieee80211_tx_info,
 					  driver_data[2]);
 
-	trans_cfg.sw_csum_tx = IWL_MVM_SW_TX_CSUM_OFFLOAD;
-
 	/* Set a short watchdog for the command queue */
 	trans_cfg.cmd_q_wdg_timeout =
 		iwl_mvm_get_wd_timeout(mvm, NULL, false, true);
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
index fe1c538cd718..0ce5850dddc4 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
@@ -105,11 +105,8 @@ static u16 iwl_mvm_tx_csum(struct iwl_mvm *mvm, struct sk_buff *skb,
 	u16 mh_len = ieee80211_hdrlen(hdr->frame_control);
 	u8 protocol = 0;
 
-	/*
-	 * Do not compute checksum if already computed or if transport will
-	 * compute it
-	 */
-	if (skb->ip_summed != CHECKSUM_PARTIAL || IWL_MVM_SW_TX_CSUM_OFFLOAD)
+	/* Do not compute checksum if already computed */
+	if (skb->ip_summed != CHECKSUM_PARTIAL)
 		goto out;
 
 	/* We do not expect to be requested to csum stuff we do not support */
diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/internal.h b/drivers/net/wireless/intel/iwlwifi/pcie/internal.h
index a594bca89be6..2fb16a1f392b 100644
--- a/drivers/net/wireless/intel/iwlwifi/pcie/internal.h
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/internal.h
@@ -380,8 +380,6 @@ struct cont_rec {
  * @def_rx_queue - default rx queue number
  * @rx_buf_size: Rx buffer size
  * @scd_set_active: should the transport configure the SCD for HCMD queue
- * @sw_csum_tx: if true, then the transport will compute the csum of the TXed
- *	frame.
  * @rx_page_order: page order for receive buffer size
  * @rx_buf_bytes: RX buffer (RB) size in bytes
  * @reg_lock: protect hw register access
@@ -467,7 +465,6 @@ struct iwl_trans_pcie {
 
 	enum iwl_amsdu_size rx_buf_size;
 	bool scd_set_active;
-	bool sw_csum_tx;
 	bool pcie_dbg_dumped_once;
 	u32 rx_page_order;
 	u32 rx_buf_bytes;
diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
index ab1239f5a60e..e9742bb1c119 100644
--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@ -1934,7 +1934,6 @@ static void iwl_trans_pcie_configure(struct iwl_trans *trans,
 
 	trans->txqs.bc_table_dword = trans_cfg->bc_table_dword;
 	trans_pcie->scd_set_active = trans_cfg->scd_set_active;
-	trans_pcie->sw_csum_tx = trans_cfg->sw_csum_tx;
 
 	trans->command_groups = trans_cfg->command_groups;
 	trans->command_groups_size = trans_cfg->command_groups_size;
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/tx.c
