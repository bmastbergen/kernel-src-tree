mptcp: add a new sysctl add_addr_timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 93f323b9cccc1fc77660de49faefd11fdfd55017
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/93f323b9.failed

This patch added a new sysctl, named add_addr_timeout, to control the
timeout value (in seconds) of the ADD_ADDR retransmission.

	Suggested-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Suggested-by: Paolo Abeni <pabeni@redhat.com>
	Acked-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 93f323b9cccc1fc77660de49faefd11fdfd55017)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/ctrl.c
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/ctrl.c
index e161873cfb7f,96ba616f59bf..000000000000
--- a/net/mptcp/ctrl.c
+++ b/net/mptcp/ctrl.c
@@@ -45,7 -57,8 +57,12 @@@ static struct ctl_table mptcp_sysctl_ta
  
  static void mptcp_pernet_set_defaults(struct mptcp_pernet *pernet)
  {
++<<<<<<< HEAD
 +	pernet->mptcp_enabled = 0;
++=======
+ 	pernet->mptcp_enabled = 1;
+ 	pernet->add_addr_timeout = TCP_RTO_MAX;
++>>>>>>> 93f323b9cccc (mptcp: add a new sysctl add_addr_timeout)
  }
  
  static int mptcp_pernet_new_table(struct net *net, struct mptcp_pernet *pernet)
diff --cc net/mptcp/pm_netlink.c
index 6f3bf9fdbbbc,ed60538df7b2..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -179,11 -187,130 +179,133 @@@ static void check_work_pending(struct m
  		WRITE_ONCE(msk->pm.work_pending, false);
  }
  
++<<<<<<< HEAD
++=======
+ static struct mptcp_pm_add_entry *
+ lookup_anno_list_by_saddr(struct mptcp_sock *msk,
+ 			  struct mptcp_addr_info *addr)
+ {
+ 	struct mptcp_pm_add_entry *entry;
+ 
+ 	list_for_each_entry(entry, &msk->pm.anno_list, list) {
+ 		if (addresses_equal(&entry->addr, addr, false))
+ 			return entry;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void mptcp_pm_add_timer(struct timer_list *timer)
+ {
+ 	struct mptcp_pm_add_entry *entry = from_timer(entry, timer, add_timer);
+ 	struct mptcp_sock *msk = entry->sock;
+ 	struct sock *sk = (struct sock *)msk;
+ 	struct net *net = sock_net(sk);
+ 
+ 	pr_debug("msk=%p", msk);
+ 
+ 	if (!msk)
+ 		return;
+ 
+ 	if (inet_sk_state_load(sk) == TCP_CLOSE)
+ 		return;
+ 
+ 	if (!entry->addr.id)
+ 		return;
+ 
+ 	if (mptcp_pm_should_add_signal(msk)) {
+ 		sk_reset_timer(sk, timer, jiffies + TCP_RTO_MAX / 8);
+ 		goto out;
+ 	}
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 
+ 	if (!mptcp_pm_should_add_signal(msk)) {
+ 		pr_debug("retransmit ADD_ADDR id=%d", entry->addr.id);
+ 		mptcp_pm_announce_addr(msk, &entry->addr, false);
+ 		entry->retrans_times++;
+ 	}
+ 
+ 	if (entry->retrans_times < ADD_ADDR_RETRANS_MAX)
+ 		sk_reset_timer(sk, timer,
+ 			       jiffies + mptcp_get_add_addr_timeout(net));
+ 
+ 	spin_unlock_bh(&msk->pm.lock);
+ 
+ out:
+ 	__sock_put(sk);
+ }
+ 
+ struct mptcp_pm_add_entry *
+ mptcp_pm_del_add_timer(struct mptcp_sock *msk,
+ 		       struct mptcp_addr_info *addr)
+ {
+ 	struct mptcp_pm_add_entry *entry;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 	entry = lookup_anno_list_by_saddr(msk, addr);
+ 	if (entry)
+ 		entry->retrans_times = ADD_ADDR_RETRANS_MAX;
+ 	spin_unlock_bh(&msk->pm.lock);
+ 
+ 	if (entry)
+ 		sk_stop_timer_sync(sk, &entry->add_timer);
+ 
+ 	return entry;
+ }
+ 
+ static bool mptcp_pm_alloc_anno_list(struct mptcp_sock *msk,
+ 				     struct mptcp_pm_addr_entry *entry)
+ {
+ 	struct mptcp_pm_add_entry *add_entry = NULL;
+ 	struct sock *sk = (struct sock *)msk;
+ 	struct net *net = sock_net(sk);
+ 
+ 	if (lookup_anno_list_by_saddr(msk, &entry->addr))
+ 		return false;
+ 
+ 	add_entry = kmalloc(sizeof(*add_entry), GFP_ATOMIC);
+ 	if (!add_entry)
+ 		return false;
+ 
+ 	list_add(&add_entry->list, &msk->pm.anno_list);
+ 
+ 	add_entry->addr = entry->addr;
+ 	add_entry->sock = msk;
+ 	add_entry->retrans_times = 0;
+ 
+ 	timer_setup(&add_entry->add_timer, mptcp_pm_add_timer, 0);
+ 	sk_reset_timer(sk, &add_entry->add_timer,
+ 		       jiffies + mptcp_get_add_addr_timeout(net));
+ 
+ 	return true;
+ }
+ 
+ void mptcp_pm_free_anno_list(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_pm_add_entry *entry, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 	LIST_HEAD(free_list);
+ 
+ 	pr_debug("msk=%p", msk);
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 	list_splice_init(&msk->pm.anno_list, &free_list);
+ 	spin_unlock_bh(&msk->pm.lock);
+ 
+ 	list_for_each_entry_safe(entry, tmp, &free_list, list) {
+ 		sk_stop_timer_sync(sk, &entry->add_timer);
+ 		kfree(entry);
+ 	}
+ }
+ 
++>>>>>>> 93f323b9cccc (mptcp: add a new sysctl add_addr_timeout)
  static void mptcp_pm_create_subflow_or_signal_addr(struct mptcp_sock *msk)
  {
 -	struct mptcp_addr_info remote = { 0 };
  	struct sock *sk = (struct sock *)msk;
  	struct mptcp_pm_addr_entry *local;
 +	struct mptcp_addr_info remote;
  	struct pm_nl_pernet *pernet;
  
  	pernet = net_generic(sock_net((struct sock *)msk), pm_nl_pernet_id);
* Unmerged path net/mptcp/ctrl.c
* Unmerged path net/mptcp/pm_netlink.c
diff --git a/net/mptcp/protocol.h b/net/mptcp/protocol.h
index 35072e9204c8..d21e43dbba15 100644
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@ -345,6 +345,7 @@ mptcp_subflow_get_mapped_dsn(const struct mptcp_subflow_context *subflow)
 }
 
 int mptcp_is_enabled(struct net *net);
+unsigned int mptcp_get_add_addr_timeout(struct net *net);
 void mptcp_subflow_fully_established(struct mptcp_subflow_context *subflow,
 				     struct mptcp_options_received *mp_opt);
 bool mptcp_subflow_data_available(struct sock *sk);
