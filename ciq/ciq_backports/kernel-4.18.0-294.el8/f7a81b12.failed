rcu/nocb: Print no-CBs diagnostics when rcutorture writer unduly delayed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paul E. McKenney <paulmck@linux.ibm.com>
commit f7a81b12d6af42a9d09be1e5f041169f04b0b67a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f7a81b12.failed

This commit causes locking, sleeping, and callback state to be printed
for no-CBs CPUs when the rcutorture writer is delayed sufficiently for
rcutorture to complain.

	Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>
(cherry picked from commit f7a81b12d6af42a9d09be1e5f041169f04b0b67a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.h
#	kernel/rcu/tree_plugin.h
diff --cc kernel/rcu/tree.h
index 2c3e9068671c,c612f306fe89..000000000000
--- a/kernel/rcu/tree.h
+++ b/kernel/rcu/tree.h
@@@ -203,8 -203,20 +203,17 @@@ struct rcu_data 
  
  	/* The following fields are used by GP kthread, hence own cacheline. */
  	raw_spinlock_t nocb_gp_lock ____cacheline_internodealigned_in_smp;
++<<<<<<< HEAD
 +	bool nocb_gp_sleep;
 +					/* Is the nocb GP thread asleep? */
++=======
+ 	struct timer_list nocb_bypass_timer; /* Force nocb_bypass flush. */
+ 	u8 nocb_gp_sleep;		/* Is the nocb GP thread asleep? */
+ 	u8 nocb_gp_bypass;		/* Found a bypass on last scan? */
+ 	u8 nocb_gp_gp;			/* GP to wait for on last scan? */
+ 	unsigned long nocb_gp_seq;	/*  If so, ->gp_seq to wait for. */
+ 	unsigned long nocb_gp_loops;	/* # passes through wait code. */
++>>>>>>> f7a81b12d6af (rcu/nocb: Print no-CBs diagnostics when rcutorture writer unduly delayed)
  	struct swait_queue_head nocb_gp_wq; /* For nocb kthreads to sleep on. */
  	bool nocb_cb_sleep;		/* Is the nocb CB thread asleep? */
  	struct task_struct *nocb_cb_kthread;
diff --cc kernel/rcu/tree_plugin.h
index 3b5216d51a54,25a53742ca68..000000000000
--- a/kernel/rcu/tree_plugin.h
+++ b/kernel/rcu/tree_plugin.h
@@@ -1749,6 -2021,16 +1749,19 @@@ static void nocb_gp_wait(struct rcu_dat
  			rcu_gp_kthread_wake();
  	}
  
++<<<<<<< HEAD
++=======
+ 	my_rdp->nocb_gp_bypass = bypass;
+ 	my_rdp->nocb_gp_gp = needwait_gp;
+ 	my_rdp->nocb_gp_seq = needwait_gp ? wait_gp_seq : 0;
+ 	if (bypass && !rcu_nocb_poll) {
+ 		// At least one child with non-empty ->nocb_bypass, so set
+ 		// timer in order to avoid stranding its callbacks.
+ 		raw_spin_lock_irqsave(&my_rdp->nocb_gp_lock, flags);
+ 		mod_timer(&my_rdp->nocb_bypass_timer, j + 2);
+ 		raw_spin_unlock_irqrestore(&my_rdp->nocb_gp_lock, flags);
+ 	}
++>>>>>>> f7a81b12d6af (rcu/nocb: Print no-CBs diagnostics when rcutorture writer unduly delayed)
  	if (rcu_nocb_poll) {
  		/* Polling, so trace if first poll in the series. */
  		if (gotcbs)
diff --git a/kernel/rcu/rcutorture.c b/kernel/rcu/rcutorture.c
index 38154feed8b2..501d8754a620 100644
--- a/kernel/rcu/rcutorture.c
+++ b/kernel/rcu/rcutorture.c
@@ -2189,6 +2189,7 @@ rcu_torture_cleanup(void)
 		return;
 	}
 
+	show_rcu_gp_kthreads();
 	rcu_torture_barrier_cleanup();
 	torture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_task);
 	torture_stop_kthread(rcu_torture_stall, stall_task);
* Unmerged path kernel/rcu/tree.h
* Unmerged path kernel/rcu/tree_plugin.h
diff --git a/kernel/rcu/tree_stall.h b/kernel/rcu/tree_stall.h
index fc404ed9f75d..c0b8c458d8a6 100644
--- a/kernel/rcu/tree_stall.h
+++ b/kernel/rcu/tree_stall.h
@@ -589,6 +589,11 @@ void show_rcu_gp_kthreads(void)
 				cpu, (long)rdp->gp_seq_needed);
 		}
 	}
+	for_each_possible_cpu(cpu) {
+		rdp = per_cpu_ptr(&rcu_data, cpu);
+		if (rcu_segcblist_is_offloaded(&rdp->cblist))
+			show_rcu_nocb_state(rdp);
+	}
 	/* sched_show_task(rcu_state.gp_kthread); */
 }
 EXPORT_SYMBOL_GPL(show_rcu_gp_kthreads);
