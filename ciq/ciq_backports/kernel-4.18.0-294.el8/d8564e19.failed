s390/qdio: allow for non-contiguous SBAL array in init_data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit d8564e19da8c8b31c7fc160942f95b113f554211
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d8564e19.failed

Upper-layer drivers allocate their SBALs by calling qdio_alloc_buffers()
for each individual queue. But when later passing the SBAL addresses to
qdio_establish(), they need to be in a single array of pointers.
So if the driver uses multiple Input or Output queues, it needs to
allocate a temporary array just to present all its SBAL pointers in this
layout.

This patch slightly changes the format of the QDIO initialization data,
so that drivers can pass a per-queue array where each element points to
a queue's SBAL array.
zfcp doesn't use multiple queues, so the impact there is trivial.
For qeth this brings a nice reduction in complexity, and removes
a page-sized allocation.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit d8564e19da8c8b31c7fc160942f95b113f554211)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core.h
index 062051ee4668,e0b26310ecab..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -185,6 -185,9 +185,12 @@@ struct qeth_vnicc_info 
  #define QETH_IQD_MIN_TXQ	2	/* One for ucast, one for mcast. */
  #define QETH_IQD_MCAST_TXQ	0
  #define QETH_IQD_MIN_UCAST_TXQ	1
++<<<<<<< HEAD
++=======
+ 
+ #define QETH_MAX_IN_QUEUES	2
+ #define QETH_RX_COPYBREAK      (PAGE_SIZE >> 1)
++>>>>>>> d8564e19da8c (s390/qdio: allow for non-contiguous SBAL array in init_data)
  #define QETH_IN_BUF_SIZE_DEFAULT 65536
  #define QETH_IN_BUF_COUNT_DEFAULT 64
  #define QETH_IN_BUF_COUNT_HSDEFAULT 128
diff --cc drivers/s390/net/qeth_core_main.c
index 6d04ed532c2b,4f90f11942b1..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -4818,34 -4812,13 +4818,43 @@@ out
  	return;
  }
  
++<<<<<<< HEAD
 +static void qeth_qdio_establish_cq(struct qeth_card *card,
 +				   struct qdio_buffer **in_sbal_ptrs,
 +				   void (**queue_start_poll)
 +					(struct ccw_device *, int,
 +					 unsigned long))
 +{
 +	int i;
 +
 +	if (card->options.cq == QETH_CQ_ENABLED) {
 +		int offset = QDIO_MAX_BUFFERS_PER_Q *
 +			     (card->qdio.no_in_queues - 1);
 +
 +		for (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; i++)
 +			in_sbal_ptrs[offset + i] =
 +				card->qdio.c_q->bufs[i].buffer;
 +
 +		queue_start_poll[card->qdio.no_in_queues - 1] = NULL;
 +	}
 +}
 +
++=======
++>>>>>>> d8564e19da8c (s390/qdio: allow for non-contiguous SBAL array in init_data)
  static int qeth_qdio_establish(struct qeth_card *card)
  {
+ 	struct qdio_buffer **out_sbal_ptrs[QETH_MAX_OUT_QUEUES];
+ 	struct qdio_buffer **in_sbal_ptrs[QETH_MAX_IN_QUEUES];
  	struct qdio_initialize init_data;
  	char *qib_param_field;
++<<<<<<< HEAD
 +	struct qdio_buffer **in_sbal_ptrs;
 +	void (**queue_start_poll) (struct ccw_device *, int, unsigned long);
 +	struct qdio_buffer **out_sbal_ptrs;
 +	int i, j, k;
++=======
+ 	unsigned int i;
++>>>>>>> d8564e19da8c (s390/qdio: allow for non-contiguous SBAL array in init_data)
  	int rc = 0;
  
  	QETH_CARD_TEXT(card, 2, "qdioest");
@@@ -4859,41 -4832,12 +4868,42 @@@
  	qeth_create_qib_param_field(card, qib_param_field);
  	qeth_create_qib_param_field_blkt(card, qib_param_field);
  
- 	in_sbal_ptrs = kcalloc(card->qdio.no_in_queues * QDIO_MAX_BUFFERS_PER_Q,
- 			       sizeof(void *),
- 			       GFP_KERNEL);
- 	if (!in_sbal_ptrs) {
- 		rc = -ENOMEM;
- 		goto out_free_qib_param;
- 	}
+ 	in_sbal_ptrs[0] = card->qdio.in_q->qdio_bufs;
+ 	if (card->options.cq == QETH_CQ_ENABLED)
+ 		in_sbal_ptrs[1] = card->qdio.c_q->qdio_bufs;
  
++<<<<<<< HEAD
 +	for (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; i++)
 +		in_sbal_ptrs[i] = card->qdio.in_q->bufs[i].buffer;
 +
 +	queue_start_poll = kcalloc(card->qdio.no_in_queues, sizeof(void *),
 +				   GFP_KERNEL);
 +	if (!queue_start_poll) {
 +		rc = -ENOMEM;
 +		goto out_free_in_sbals;
 +	}
 +	for (i = 0; i < card->qdio.no_in_queues; ++i)
 +		queue_start_poll[i] = qeth_qdio_start_poll;
 +
 +	qeth_qdio_establish_cq(card, in_sbal_ptrs, queue_start_poll);
 +
 +	out_sbal_ptrs =
 +		kcalloc(card->qdio.no_out_queues * QDIO_MAX_BUFFERS_PER_Q,
 +			sizeof(void *),
 +			GFP_KERNEL);
 +	if (!out_sbal_ptrs) {
 +		rc = -ENOMEM;
 +		goto out_free_queue_start_poll;
 +	}
 +
 +	for (i = 0, k = 0; i < card->qdio.no_out_queues; ++i)
 +		for (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; j++, k++)
 +			out_sbal_ptrs[k] =
 +				card->qdio.out_qs[i]->bufs[j]->buffer;
++=======
+ 	for (i = 0; i < card->qdio.no_out_queues; i++)
+ 		out_sbal_ptrs[i] = card->qdio.out_qs[i]->qdio_bufs;
++>>>>>>> d8564e19da8c (s390/qdio: allow for non-contiguous SBAL array in init_data)
  
  	memset(&init_data, 0, sizeof(struct qdio_initialize));
  	init_data.cdev                   = CARD_DDEV(card);
@@@ -4938,12 -4882,6 +4948,15 @@@
  		break;
  	}
  out:
++<<<<<<< HEAD
 +	kfree(out_sbal_ptrs);
 +out_free_queue_start_poll:
 +	kfree(queue_start_poll);
 +out_free_in_sbals:
 +	kfree(in_sbal_ptrs);
 +out_free_qib_param:
++=======
++>>>>>>> d8564e19da8c (s390/qdio: allow for non-contiguous SBAL array in init_data)
  	kfree(qib_param_field);
  out_free_nothing:
  	return rc;
@@@ -5743,17 -5945,19 +5756,26 @@@ static struct net_device *qeth_alloc_ne
  
  	switch (card->info.type) {
  	case QETH_CARD_TYPE_IQD:
++<<<<<<< HEAD
 +		dev = alloc_netdev_mqs(0, "hsi%d", NET_NAME_UNKNOWN,
 +				       ether_setup, QETH_MAX_QUEUES, 1);
++=======
+ 		dev = alloc_netdev_mqs(sizeof(*priv), "hsi%d", NET_NAME_UNKNOWN,
+ 				       ether_setup, QETH_MAX_OUT_QUEUES, 1);
++>>>>>>> d8564e19da8c (s390/qdio: allow for non-contiguous SBAL array in init_data)
  		break;
  	case QETH_CARD_TYPE_OSM:
 -		dev = alloc_etherdev(sizeof(*priv));
 +		dev = alloc_etherdev(0);
  		break;
  	case QETH_CARD_TYPE_OSN:
 -		dev = alloc_netdev(sizeof(*priv), "osn%d", NET_NAME_UNKNOWN,
 -				   ether_setup);
 +		dev = alloc_netdev(0, "osn%d", NET_NAME_UNKNOWN, ether_setup);
  		break;
  	default:
++<<<<<<< HEAD
 +		dev = alloc_etherdev_mqs(0, QETH_MAX_QUEUES, 1);
++=======
+ 		dev = alloc_etherdev_mqs(sizeof(*priv), QETH_MAX_OUT_QUEUES, 1);
++>>>>>>> d8564e19da8c (s390/qdio: allow for non-contiguous SBAL array in init_data)
  	}
  
  	if (!dev)
diff --git a/arch/s390/include/asm/qdio.h b/arch/s390/include/asm/qdio.h
index 8bda4c28a38d..3cab5cfe4c6b 100644
--- a/arch/s390/include/asm/qdio.h
+++ b/arch/s390/include/asm/qdio.h
@@ -341,8 +341,8 @@ typedef void qdio_handler_t(struct ccw_device *, unsigned int, int,
  * @queue_start_poll_array: polling handlers (one per input queue or NULL)
  * @scan_threshold: # of in-use buffers that triggers scan on output queue
  * @int_parm: interruption parameter
- * @input_sbal_addr_array:  address of no_input_qs * 128 pointers
- * @output_sbal_addr_array: address of no_output_qs * 128 pointers
+ * @input_sbal_addr_array:  per-queue array, each element points to 128 SBALs
+ * @output_sbal_addr_array: per-queue array, each element points to 128 SBALs
  * @output_sbal_state_array: no_output_qs * 128 state info (for CQ or NULL)
  */
 struct qdio_initialize {
@@ -363,8 +363,8 @@ struct qdio_initialize {
 					  unsigned long);
 	unsigned int scan_threshold;
 	unsigned long int_parm;
-	struct qdio_buffer **input_sbal_addr_array;
-	struct qdio_buffer **output_sbal_addr_array;
+	struct qdio_buffer ***input_sbal_addr_array;
+	struct qdio_buffer ***output_sbal_addr_array;
 	struct qdio_outbuf_state *output_sbal_state_array;
 };
 
diff --git a/drivers/s390/cio/qdio_setup.c b/drivers/s390/cio/qdio_setup.c
index 018c5b18f140..02fd15400594 100644
--- a/drivers/s390/cio/qdio_setup.c
+++ b/drivers/s390/cio/qdio_setup.c
@@ -213,8 +213,6 @@ static void setup_queues(struct qdio_irq *irq_ptr,
 			 struct qdio_initialize *qdio_init)
 {
 	struct qdio_q *q;
-	struct qdio_buffer **input_sbal_array = qdio_init->input_sbal_addr_array;
-	struct qdio_buffer **output_sbal_array = qdio_init->output_sbal_addr_array;
 	struct qdio_outbuf_state *output_sbal_state_array =
 				  qdio_init->output_sbal_state_array;
 	int i;
@@ -234,8 +232,8 @@ static void setup_queues(struct qdio_irq *irq_ptr,
 			q->u.in.queue_start_poll = NULL;
 		}
 
-		setup_storage_lists(q, irq_ptr, input_sbal_array, i);
-		input_sbal_array += QDIO_MAX_BUFFERS_PER_Q;
+		setup_storage_lists(q, irq_ptr,
+				    qdio_init->input_sbal_addr_array[i], i);
 
 		if (is_thinint_irq(irq_ptr)) {
 			tasklet_init(&q->tasklet, tiqdio_inbound_processing,
@@ -254,8 +252,8 @@ static void setup_queues(struct qdio_irq *irq_ptr,
 		output_sbal_state_array += QDIO_MAX_BUFFERS_PER_Q;
 
 		q->is_input_q = 0;
-		setup_storage_lists(q, irq_ptr, output_sbal_array, i);
-		output_sbal_array += QDIO_MAX_BUFFERS_PER_Q;
+		setup_storage_lists(q, irq_ptr,
+				    qdio_init->output_sbal_addr_array[i], i);
 
 		tasklet_init(&q->tasklet, qdio_outbound_processing,
 			     (unsigned long) q);
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_core_main.c
diff --git a/drivers/s390/scsi/zfcp_qdio.c b/drivers/s390/scsi/zfcp_qdio.c
index af484e5cd6c4..039df862d60c 100644
--- a/drivers/s390/scsi/zfcp_qdio.c
+++ b/drivers/s390/scsi/zfcp_qdio.c
@@ -365,6 +365,8 @@ void zfcp_qdio_shost_update(struct zfcp_adapter *const adapter,
  */
 int zfcp_qdio_open(struct zfcp_qdio *qdio)
 {
+	struct qdio_buffer **input_sbals[1] = {qdio->res_q};
+	struct qdio_buffer **output_sbals[1] = {qdio->req_q};
 	struct qdio_buffer_element *sbale;
 	struct qdio_initialize init_data = {0};
 	struct zfcp_adapter *adapter = qdio->adapter;
@@ -390,8 +392,8 @@ int zfcp_qdio_open(struct zfcp_qdio *qdio)
 	init_data.input_handler = zfcp_qdio_int_resp;
 	init_data.output_handler = zfcp_qdio_int_req;
 	init_data.int_parm = (unsigned long) qdio;
-	init_data.input_sbal_addr_array = qdio->res_q;
-	init_data.output_sbal_addr_array = qdio->req_q;
+	init_data.input_sbal_addr_array = input_sbals;
+	init_data.output_sbal_addr_array = output_sbals;
 	init_data.scan_threshold =
 		QDIO_MAX_BUFFERS_PER_Q - ZFCP_QDIO_MAX_SBALS_PER_REQ * 2;
 
