powerpc/watchpoint: Fix ptrace code that muck around with address/len

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ravi Bangoria <ravi.bangoria@linux.ibm.com>
commit c3f68b0478e7c07769394d17ebde0626600a7e1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c3f68b04.failed

ptrace_set_debugreg() does not consider new length while overwriting
the watchpoint. Fix that. ppc_set_hwdebug() aligns watchpoint address
to doubleword boundary but does not change the length. If address
range is crossing doubleword boundary and length is less then 8, we
will lose samples from second doubleword. So fix that as well.

	Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20191017093204.7511-4-ravi.bangoria@linux.ibm.com
(cherry picked from commit c3f68b0478e7c07769394d17ebde0626600a7e1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/hw_breakpoint.h
diff --cc arch/powerpc/include/asm/hw_breakpoint.h
index 27d6e3c8fde9,27ac6f5d2891..000000000000
--- a/arch/powerpc/include/asm/hw_breakpoint.h
+++ b/arch/powerpc/include/asm/hw_breakpoint.h
@@@ -47,6 -34,11 +47,14 @@@ struct arch_hw_breakpoint 
  #define HW_BRK_TYPE_PRIV_ALL	(HW_BRK_TYPE_USER | HW_BRK_TYPE_KERNEL | \
  				 HW_BRK_TYPE_HYP)
  
++<<<<<<< HEAD
++=======
+ #define HW_BREAKPOINT_ALIGN 0x7
+ 
+ #define DABR_MAX_LEN	8
+ #define DAWR_MAX_LEN	512
+ 
++>>>>>>> c3f68b0478e7 (powerpc/watchpoint: Fix ptrace code that muck around with address/len)
  #ifdef CONFIG_HAVE_HW_BREAKPOINT
  #include <linux/kdebug.h>
  #include <asm/reg.h>
@@@ -56,9 -48,8 +64,7 @@@ struct perf_event_attr
  struct perf_event;
  struct pmu;
  struct perf_sample_data;
 -struct task_struct;
  
- #define HW_BREAKPOINT_ALIGN 0x7
- 
  extern int hw_breakpoint_slots(int type);
  extern int arch_bp_generic_fields(int type, int *gen_bp_type);
  extern int arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw);
* Unmerged path arch/powerpc/include/asm/hw_breakpoint.h
diff --git a/arch/powerpc/kernel/ptrace.c b/arch/powerpc/kernel/ptrace.c
index 88ba14cb80a6..8e3b533f3e3e 100644
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@ -2432,6 +2432,7 @@ static int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,
 	if (bp) {
 		attr = bp->attr;
 		attr.bp_addr = hw_brk.address;
+		attr.bp_len = DABR_MAX_LEN;
 		arch_bp_generic_fields(hw_brk.type, &attr.bp_type);
 
 		/* Enable breakpoint */
@@ -2873,7 +2874,7 @@ static long ppc_set_hwdebug(struct task_struct *child,
 	if ((unsigned long)bp_info->addr >= TASK_SIZE)
 		return -EIO;
 
-	brk.address = bp_info->addr & ~7UL;
+	brk.address = bp_info->addr & ~HW_BREAKPOINT_ALIGN;
 	brk.type = HW_BRK_TYPE_TRANSLATE;
 	brk.len = 8;
 	if (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)
@@ -2881,10 +2882,6 @@ static long ppc_set_hwdebug(struct task_struct *child,
 	if (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)
 		brk.type |= HW_BRK_TYPE_WRITE;
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
-	/*
-	 * Check if the request is for 'range' breakpoints. We can
-	 * support it if range < 8 bytes.
-	 */
 	if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)
 		len = bp_info->addr2 - bp_info->addr;
 	else if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)
@@ -2897,7 +2894,7 @@ static long ppc_set_hwdebug(struct task_struct *child,
 
 	/* Create a new breakpoint request if one doesn't exist already */
 	hw_breakpoint_init(&attr);
-	attr.bp_addr = (unsigned long)bp_info->addr & ~HW_BREAKPOINT_ALIGN;
+	attr.bp_addr = (unsigned long)bp_info->addr;
 	attr.bp_len = len;
 	arch_bp_generic_fields(brk.type, &attr.bp_type);
 
