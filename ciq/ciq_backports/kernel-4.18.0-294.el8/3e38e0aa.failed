mm: memcg: charge memcg percpu memory to the parent cgroup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Roman Gushchin <guro@fb.com>
commit 3e38e0aaca9eafb12b1c4b731d1c10975cbe7974
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3e38e0aa.failed

Memory cgroups are using large chunks of percpu memory to store vmstat
data.  Yet this memory is not accounted at all, so in the case when there
are many (dying) cgroups, it's not exactly clear where all the memory is.

Because the size of memory cgroup internal structures can dramatically
exceed the size of object or page which is pinning it in the memory, it's
not a good idea to simply ignore it.  It actually breaks the isolation
between cgroups.

Let's account the consumed percpu memory to the parent cgroup.

[guro@fb.com: add WARN_ON_ONCE()s, per Johannes]
  Link: http://lkml.kernel.org/r/20200811170611.GB1507044@carbon.DHCP.thefacebook.com

	Signed-off-by: Roman Gushchin <guro@fb.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Acked-by: Dennis Zhou <dennis@kernel.org>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Tobin C. Harding <tobin@kernel.org>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Bixuan Cui <cuibixuan@huawei.com>
	Cc: Michal Koutn√Ω <mkoutny@suse.com>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
Link: http://lkml.kernel.org/r/20200623184515.4132564-5-guro@fb.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3e38e0aaca9eafb12b1c4b731d1c10975cbe7974)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 406972ba9675,f1fd265b9f9e..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -4965,10 -5211,16 +4970,14 @@@ static struct mem_cgroup *mem_cgroup_al
  	memcg->id.id = idr_alloc(&mem_cgroup_idr, NULL,
  				 1, MEM_CGROUP_ID_MAX,
  				 GFP_KERNEL);
 -	if (memcg->id.id < 0) {
 -		error = memcg->id.id;
 +	if (memcg->id.id < 0)
  		goto fail;
 -	}
  
- 	memcg->vmstats_local = alloc_percpu(struct memcg_vmstats_percpu);
+ 	/* We charge the parent cgroup, never the current task */
+ 	WARN_ON_ONCE(!current->active_memcg);
+ 
+ 	memcg->vmstats_local = alloc_percpu_gfp(struct memcg_vmstats_percpu,
+ 						GFP_KERNEL_ACCOUNT);
  	if (!memcg->vmstats_local)
  		goto fail;
  
@@@ -5012,9 -5274,11 +5022,16 @@@ mem_cgroup_css_alloc(struct cgroup_subs
  	struct mem_cgroup *memcg;
  	long error = -ENOMEM;
  
+ 	memalloc_use_memcg(parent);
  	memcg = mem_cgroup_alloc();
++<<<<<<< HEAD
 +	if (!memcg)
 +		return ERR_PTR(error);
++=======
+ 	memalloc_unuse_memcg();
+ 	if (IS_ERR(memcg))
+ 		return ERR_CAST(memcg);
++>>>>>>> 3e38e0aaca9e (mm: memcg: charge memcg percpu memory to the parent cgroup)
  
  	page_counter_set_high(&memcg->memory, PAGE_COUNTER_MAX);
  	memcg->soft_limit = PAGE_COUNTER_MAX;
* Unmerged path mm/memcontrol.c
