net/mlx5: E-Switch, Refactor unload all reps per rep type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Bodong Wang <bodong@mellanox.com>
commit 4110fc59eafb4fcb462ea847f00ff8c83774672e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4110fc59.failed

Following introduction of per vport configuration of vport and rep,
unload all reps per rep type is still needed as IB reps can be
unloaded individually. However, a few internal functions exist purely
for this purpose, merge them to a single function.

This patch doesn't change any existing functionality.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 4110fc59eafb4fcb462ea847f00ff8c83774672e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 43ed228c4d29,aedbb026ed99..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1635,79 -1656,23 +1639,83 @@@ static void __unload_reps_all_vport(str
  	__esw_offloads_unload_rep(esw, rep, rep_type);
  }
  
++<<<<<<< HEAD
 +static void __unload_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
 +				   u8 rep_type)
 +{
 +	struct mlx5_eswitch_rep *rep;
 +	int i;
 +
 +	mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvports)
 +		__esw_offloads_unload_rep(esw, rep, rep_type);
 +}
 +
 +static void esw_offloads_unload_vf_reps(struct mlx5_eswitch *esw, int nvports)
 +{
 +	u8 rep_type = NUM_REP_TYPES;
 +
 +	while (rep_type-- > 0)
 +		__unload_reps_vf_vport(esw, nvports, rep_type);
 +}
 +
 +static void __unload_reps_all_vport(struct mlx5_eswitch *esw, u8 rep_type)
 +{
 +	__unload_reps_vf_vport(esw, esw->esw_funcs.num_vfs, rep_type);
 +
 +	/* Special vports must be the last to unload. */
 +	__unload_reps_special_vport(esw, rep_type);
 +}
 +
 +static void esw_offloads_unload_all_reps(struct mlx5_eswitch *esw)
++=======
+ int esw_offloads_load_rep(struct mlx5_eswitch *esw, u16 vport_num)
++>>>>>>> 4110fc59eafb (net/mlx5: E-Switch, Refactor unload all reps per rep type)
 +{
 +	u8 rep_type = NUM_REP_TYPES;
 +
 +	while (rep_type-- > 0)
 +		__unload_reps_all_vport(esw, rep_type);
 +}
 +
 +static int __esw_offloads_load_rep(struct mlx5_eswitch *esw,
 +				   struct mlx5_eswitch_rep *rep, u8 rep_type)
 +{
 +	int err = 0;
 +
 +	if (atomic_cmpxchg(&rep->rep_data[rep_type].state,
 +			   REP_REGISTERED, REP_LOADED) == REP_REGISTERED) {
 +		err = esw->offloads.rep_ops[rep_type]->load(esw->dev, rep);
 +		if (err)
 +			atomic_set(&rep->rep_data[rep_type].state,
 +				   REP_REGISTERED);
 +	}
 +
 +	return err;
 +}
 +
 +static int __load_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
  {
  	struct mlx5_eswitch_rep *rep;
 -	int rep_type;
  	int err;
  
 -	if (esw->mode != MLX5_ESWITCH_OFFLOADS)
 -		return 0;
 +	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 +	err = __esw_offloads_load_rep(esw, rep, rep_type);
 +	if (err)
 +		return err;
  
 -	rep = mlx5_eswitch_get_rep(esw, vport_num);
 -	for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++)
 -		if (atomic_cmpxchg(&rep->rep_data[rep_type].state,
 -				   REP_REGISTERED, REP_LOADED) == REP_REGISTERED) {
 -			err = esw->offloads.rep_ops[rep_type]->load(esw->dev, rep);
 -			if (err)
 -				goto err_reps;
 -		}
 +	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 +		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
 +		err = __esw_offloads_load_rep(esw, rep, rep_type);
 +		if (err)
 +			goto err_pf;
 +	}
 +
 +	if (mlx5_ecpf_vport_exists(esw->dev)) {
 +		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_ECPF);
 +		err = __esw_offloads_load_rep(esw, rep, rep_type);
 +		if (err)
 +			goto err_ecpf;
 +	}
  
  	return 0;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
