iommu/vt-d: Report page request faults for guest SVA

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit eb8d93ea3c1d35b0baf693dd0b7c87ec62358fc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/eb8d93ea.failed

A pasid might be bound to a page table from a VM guest via the iommu
ops.sva_bind_gpasid. In this case, when a DMA page fault is detected
on the physical IOMMU, we need to inject the page fault request into
the guest. After the guest completes handling the page fault, a page
response need to be sent back via the iommu ops.page_response().

This adds support to report a page request fault. Any external module
which is interested in handling this fault should regiester a notifier
with iommu_register_device_fault_handler().

Co-developed-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
Co-developed-by: Liu Yi L <yi.l.liu@intel.com>
	Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Liu Yi L <yi.l.liu@intel.com>
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Reviewed-by: Kevin Tian <kevin.tian@intel.com>
Link: https://lore.kernel.org/r/20200724014925.15523-11-baolu.lu@linux.intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit eb8d93ea3c1d35b0baf693dd0b7c87ec62358fc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-svm.c
diff --cc drivers/iommu/intel-svm.c
index 6891e2c5c734,140114ab1375..000000000000
--- a/drivers/iommu/intel-svm.c
+++ b/drivers/iommu/intel-svm.c
@@@ -896,24 -967,11 +975,16 @@@ static irqreturn_t prq_event_thread(in
  			goto invalid;
  
  		result = QI_RESP_SUCCESS;
++<<<<<<< HEAD:drivers/iommu/intel-svm.c
 +	invalid:
 +		up_read(&svm->mm->mmap_sem);
++=======
+ invalid:
+ 		mmap_read_unlock(svm->mm);
++>>>>>>> eb8d93ea3c1d (iommu/vt-d: Report page request faults for guest SVA):drivers/iommu/intel/svm.c
  		mmput(svm->mm);
- 	bad_req:
- 		/* Accounting for major/minor faults? */
- 		rcu_read_lock();
- 		list_for_each_entry_rcu(sdev, &svm->devs, list) {
- 			if (sdev->sid == req->rid)
- 				break;
- 		}
- 		/* Other devices can go away, but the drivers are not permitted
- 		 * to unbind while any page faults might be in flight. So it's
- 		 * OK to drop the 'lock' here now we have it. */
- 		rcu_read_unlock();
- 
- 		if (WARN_ON(&sdev->list == &svm->devs))
- 			sdev = NULL;
- 
+ bad_req:
+ 		WARN_ON(!sdev);
  		if (sdev && sdev->ops && sdev->ops->fault_cb) {
  			int rwxp = (req->rd_req << 3) | (req->wr_req << 2) |
  				(req->exe_req << 1) | (req->pm_req);
* Unmerged path drivers/iommu/intel-svm.c
