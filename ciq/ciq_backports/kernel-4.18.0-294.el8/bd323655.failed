selinux: switch to private struct selinux_mnt_opts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit bd3236557bb256d6491df125e5e9d0393c70e4d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/bd323655.failed

none of the convolutions needed, just 4 strings, TYVM...

	Reviewed-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit bd3236557bb256d6491df125e5e9d0393c70e4d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 42145010da10,238907d69e8b..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -430,6 -433,20 +430,23 @@@ static void superblock_free_security(st
  	kfree(sbsec);
  }
  
++<<<<<<< HEAD
++=======
+ struct selinux_mnt_opts {
+ 	const char *fscontext, *context, *rootcontext, *defcontext;
+ };
+ 
+ static void selinux_free_mnt_opts(void *mnt_opts)
+ {
+ 	struct selinux_mnt_opts *opts = mnt_opts;
+ 	kfree(opts->fscontext);
+ 	kfree(opts->context);
+ 	kfree(opts->rootcontext);
+ 	kfree(opts->defcontext);
+ 	kfree(opts);
+ }
+ 
++>>>>>>> bd3236557bb2 (selinux: switch to private struct selinux_mnt_opts)
  static inline int inode_doinit(struct inode *inode)
  {
  	return inode_doinit_with_dentry(inode, NULL);
@@@ -650,14 -652,12 +677,23 @@@ static int selinux_set_mnt_opts(struct 
  	struct inode_security_struct *root_isec;
  	u32 fscontext_sid = 0, context_sid = 0, rootcontext_sid = 0;
  	u32 defcontext_sid = 0;
++<<<<<<< HEAD
 +	char **mount_options = opts->mnt_opts;
 +	int *flags = opts->mnt_opts_flags;
 +	int num_opts = opts->num_mnt_opts;
 +
 +	mutex_lock(&sbsec->lock);
 +
 +	if (!selinux_initialized(&selinux_state)) {
 +		if (!num_opts) {
++=======
+ 	int rc = 0;
+ 
+ 	mutex_lock(&sbsec->lock);
+ 
+ 	if (!selinux_state.initialized) {
+ 		if (!opts) {
++>>>>>>> bd3236557bb2 (selinux: switch to private struct selinux_mnt_opts)
  			/* Defer initialization until selinux_complete_init,
  			   after the initial policy is loaded and the security
  			   server is ready to handle calls. */
@@@ -1014,14 -985,11 +1031,19 @@@ out
  }
  
  static int selinux_parse_opts_str(char *options,
 -				  void **mnt_opts)
 +				  struct security_mnt_opts *opts)
  {
+ 	struct selinux_mnt_opts *opts = *mnt_opts;
  	char *p;
++<<<<<<< HEAD
 +	char *context = NULL, *defcontext = NULL;
 +	char *fscontext = NULL, *rootcontext = NULL;
 +	int rc, num_mnt_opts = 0;
 +
 +	opts->num_mnt_opts = 0;
++=======
+ 	int rc;
++>>>>>>> bd3236557bb2 (selinux: switch to private struct selinux_mnt_opts)
  
  	/* Standard string-based options. */
  	while ((p = strsep(&options, "|")) != NULL) {
@@@ -1126,11 -1072,8 +1126,16 @@@
  	return 0;
  
  out_err:
++<<<<<<< HEAD
 +	security_free_mnt_opts(opts);
 +	kfree(context);
 +	kfree(defcontext);
 +	kfree(fscontext);
 +	kfree(rootcontext);
++=======
+ 	if (opts)
+ 		selinux_free_mnt_opts(opts);
++>>>>>>> bd3236557bb2 (selinux: switch to private struct selinux_mnt_opts)
  	return rc;
  }
  
@@@ -2761,58 -2689,62 +2766,87 @@@ out
  	return rc;
  }
  
 -static int selinux_sb_eat_lsm_opts(char *options, void **mnt_opts)
 +static int selinux_sb_remount(struct super_block *sb,
 +			      struct security_mnt_opts *opts)
  {
++<<<<<<< HEAD
 +	int i, *flags;
 +	char **mount_options;
++=======
+ 	char *s = (char *)get_zeroed_page(GFP_KERNEL);
+ 	int err;
+ 
+ 	if (!s)
+ 		return -ENOMEM;
+ 	err = selinux_sb_copy_data(options, s);
+ 	if (!err)
+ 		err = selinux_parse_opts_str(s, mnt_opts);
+ 	free_page((unsigned long)s);
+ 	return err;
+ }
+ 
+ static int selinux_sb_remount(struct super_block *sb, void *mnt_opts)
+ {
+ 	struct selinux_mnt_opts *opts = mnt_opts;
++>>>>>>> bd3236557bb2 (selinux: switch to private struct selinux_mnt_opts)
  	struct superblock_security_struct *sbsec = sb->s_security;
+ 	u32 sid;
+ 	int rc;
  
  	if (!(sbsec->flags & SE_SBINITIALIZED))
  		return 0;
  
++<<<<<<< HEAD
 +	mount_options = opts->mnt_opts;
 +	flags = opts->mnt_opts_flags;
 +
 +	for (i = 0; i < opts->num_mnt_opts; i++) {
 +		u32 sid;
 +		int rc;
 +
 +		if (flags[i] == SBLABEL_MNT)
 +			continue;
 +		rc = security_context_str_to_sid(&selinux_state,
 +						 mount_options[i], &sid,
 +						 GFP_KERNEL);
 +		if (rc) {
 +			pr_warn("SELinux: security_context_str_to_sid"
 +			       "(%s) failed for (dev %s, type %s) errno=%d\n",
 +			       mount_options[i], sb->s_id, sb->s_type->name, rc);
- 			return rc;
- 		}
- 		switch (flags[i]) {
- 		case FSCONTEXT_MNT:
- 			if (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid, sid))
- 				goto out_bad_option;
- 			break;
- 		case CONTEXT_MNT:
- 			if (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid, sid))
- 				goto out_bad_option;
- 			break;
- 		case ROOTCONTEXT_MNT: {
- 			struct inode_security_struct *root_isec;
- 			root_isec = backing_inode_security(sb->s_root);
++=======
+ 	if (!opts)
+ 		return 0;
  
- 			if (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))
- 				goto out_bad_option;
- 			break;
- 		}
- 		case DEFCONTEXT_MNT:
- 			if (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid, sid))
- 				goto out_bad_option;
- 			break;
- 		default:
- 			return -EINVAL;
- 		}
+ 	if (opts->fscontext) {
+ 		rc = parse_sid(sb, opts->fscontext, &sid);
+ 		if (rc)
++>>>>>>> bd3236557bb2 (selinux: switch to private struct selinux_mnt_opts)
+ 			return rc;
+ 		if (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid, sid))
+ 			goto out_bad_option;
+ 	}
+ 	if (opts->context) {
+ 		rc = parse_sid(sb, opts->context, &sid);
+ 		if (rc)
+ 			return rc;
+ 		if (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid, sid))
+ 			goto out_bad_option;
+ 	}
+ 	if (opts->rootcontext) {
+ 		struct inode_security_struct *root_isec;
+ 		root_isec = backing_inode_security(sb->s_root);
+ 		rc = parse_sid(sb, opts->rootcontext, &sid);
+ 		if (rc)
+ 			return rc;
+ 		if (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))
+ 			goto out_bad_option;
+ 	}
+ 	if (opts->defcontext) {
+ 		rc = parse_sid(sb, opts->defcontext, &sid);
+ 		if (rc)
+ 			return rc;
+ 		if (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid, sid))
+ 			goto out_bad_option;
  	}
  	return 0;
  
* Unmerged path security/selinux/hooks.c
