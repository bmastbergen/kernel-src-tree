dma-direct: re-encrypt memory if dma_direct_alloc_pages() fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Rientjes <rientjes@google.com>
commit 96a539fa3bb71f443ae08e57b9f63d6e5bb2207c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/96a539fa.failed

If arch_dma_set_uncached() fails after memory has been decrypted, it needs
to be re-encrypted before freeing.

Fixes: fa7e2247c572 ("dma-direct: make uncached_kernel_address more general")
	Signed-off-by: David Rientjes <rientjes@google.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 96a539fa3bb71f443ae08e57b9f63d6e5bb2207c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index 50772983c03a,80d33f215a2e..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -181,10 -215,12 +181,16 @@@ void *dma_direct_alloc_pages(struct dev
  
  	memset(ret, 0, size);
  
 -	if (IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED) &&
 +	if (IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
  	    dma_alloc_need_uncached(dev, attrs)) {
  		arch_dma_prep_coherent(page, size);
++<<<<<<< HEAD
 +		ret = uncached_kernel_address(ret);
++=======
+ 		ret = arch_dma_set_uncached(ret, size);
+ 		if (IS_ERR(ret))
+ 			goto out_encrypt_pages;
++>>>>>>> 96a539fa3bb7 (dma-direct: re-encrypt memory if dma_direct_alloc_pages() fails)
  	}
  done:
  	if (force_dma_unencrypted(dev))
* Unmerged path kernel/dma/direct.c
