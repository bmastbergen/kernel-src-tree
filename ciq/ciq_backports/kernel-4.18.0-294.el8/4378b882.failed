net: atlantic: put ptp code under IS_REACHABLE check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Igor Russkikh <irusskikh@marvell.com>
commit 4378b882bf03f2e0471b7d92fa97a7227ff3a126
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4378b882.failed

A1 requires additional processing for both egress and ingress to support
PTP.
And it makes sense to get rid of this processing altogether (via ifdef),
if PTP clock is disabled globally.

This patch puts the PTP code under the corresponding IS_REACHABLE check.

	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4378b882bf03f2e0471b7d92fa97a7227ff3a126)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
#	drivers/net/ethernet/aquantia/atlantic/aq_main.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
index a64230722f5c,a8f0fbbbd91a..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
@@@ -369,7 -583,38 +369,42 @@@ static int aq_ethtool_set_wol(struct ne
  	return err;
  }
  
++<<<<<<< HEAD
 +static enum hw_atl_fw2x_rate eee_mask_to_ethtool_mask(u32 speed)
++=======
+ static int aq_ethtool_get_ts_info(struct net_device *ndev,
+ 				  struct ethtool_ts_info *info)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 
+ 	ethtool_op_get_ts_info(ndev, info);
+ 
+ 	if (!aq_nic->aq_ptp)
+ 		return 0;
+ 
+ 	info->so_timestamping |=
+ 		SOF_TIMESTAMPING_TX_HARDWARE |
+ 		SOF_TIMESTAMPING_RX_HARDWARE |
+ 		SOF_TIMESTAMPING_RAW_HARDWARE;
+ 
+ 	info->tx_types = BIT(HWTSTAMP_TX_OFF) |
+ 			 BIT(HWTSTAMP_TX_ON);
+ 
+ 	info->rx_filters = BIT(HWTSTAMP_FILTER_NONE);
+ 
+ 	info->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+ 			    BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |
+ 			    BIT(HWTSTAMP_FILTER_PTP_V2_EVENT);
+ 
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 	info->phc_index = ptp_clock_index(aq_ptp_get_ptp_clock(aq_nic->aq_ptp));
+ #endif
+ 
+ 	return 0;
+ }
+ 
+ static u32 eee_mask_to_ethtool_mask(u32 speed)
++>>>>>>> 4378b882bf03 (net: atlantic: put ptp code under IS_REACHABLE check)
  {
  	u32 rate = 0;
  
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_main.c
index 25a59894105a,dfb29b933eb7..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_main.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_main.c
@@@ -1,10 -1,8 +1,18 @@@
++<<<<<<< HEAD
 +/*
 + * aQuantia Corporation Network Driver
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+ // SPDX-License-Identifier: GPL-2.0-only
+ /* Atlantic Network Driver
+  *
+  * Copyright (C) 2014-2019 aQuantia Corporation
+  * Copyright (C) 2019-2020 Marvell International Ltd.
++>>>>>>> 4378b882bf03 (net: atlantic: put ptp code under IS_REACHABLE check)
   */
  
  /* File aq_main.c: Main file for aQuantia Linux driver. */
@@@ -96,6 -99,26 +104,29 @@@ static int aq_ndev_start_xmit(struct sk
  {
  	struct aq_nic_s *aq_nic = netdev_priv(ndev);
  
++<<<<<<< HEAD
++=======
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 	if (unlikely(aq_utils_obj_test(&aq_nic->flags, AQ_NIC_PTP_DPATH_UP))) {
+ 		/* Hardware adds the Timestamp for PTPv2 802.AS1
+ 		 * and PTPv2 IPv4 UDP.
+ 		 * We have to push even general 320 port messages to the ptp
+ 		 * queue explicitly. This is a limitation of current firmware
+ 		 * and hardware PTP design of the chip. Otherwise ptp stream
+ 		 * will fail to sync
+ 		 */
+ 		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) ||
+ 		    unlikely((ip_hdr(skb)->version == 4) &&
+ 			     (ip_hdr(skb)->protocol == IPPROTO_UDP) &&
+ 			     ((udp_hdr(skb)->dest == htons(319)) ||
+ 			      (udp_hdr(skb)->dest == htons(320)))) ||
+ 		    unlikely(eth_hdr(skb)->h_proto == htons(ETH_P_1588)))
+ 			return aq_ptp_xmit(aq_nic, skb);
+ 	}
+ #endif
+ 
+ 	skb_tx_timestamp(skb);
++>>>>>>> 4378b882bf03 (net: atlantic: put ptp code under IS_REACHABLE check)
  	return aq_nic_xmit(aq_nic, skb);
  }
  
@@@ -200,6 -225,96 +231,99 @@@ static void aq_ndev_set_multicast_setti
  	(void)aq_nic_set_multicast_list(aq_nic, ndev);
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ static int aq_ndev_config_hwtstamp(struct aq_nic_s *aq_nic,
+ 				   struct hwtstamp_config *config)
+ {
+ 	if (config->flags)
+ 		return -EINVAL;
+ 
+ 	switch (config->tx_type) {
+ 	case HWTSTAMP_TX_OFF:
+ 	case HWTSTAMP_TX_ON:
+ 		break;
+ 	default:
+ 		return -ERANGE;
+ 	}
+ 
+ 	switch (config->rx_filter) {
+ 	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+ 	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+ 	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+ 	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+ 	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+ 	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+ 	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+ 	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+ 		config->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
+ 		break;
+ 	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+ 	case HWTSTAMP_FILTER_NONE:
+ 		break;
+ 	default:
+ 		return -ERANGE;
+ 	}
+ 
+ 	return aq_ptp_hwtstamp_config_set(aq_nic->aq_ptp, config);
+ }
+ #endif
+ 
+ static int aq_ndev_hwtstamp_set(struct aq_nic_s *aq_nic, struct ifreq *ifr)
+ {
+ 	struct hwtstamp_config config;
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 	int ret_val;
+ #endif
+ 
+ 	if (!aq_nic->aq_ptp)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+ 		return -EFAULT;
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 	ret_val = aq_ndev_config_hwtstamp(aq_nic, &config);
+ 	if (ret_val)
+ 		return ret_val;
+ #endif
+ 
+ 	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+ 	       -EFAULT : 0;
+ }
+ 
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ static int aq_ndev_hwtstamp_get(struct aq_nic_s *aq_nic, struct ifreq *ifr)
+ {
+ 	struct hwtstamp_config config;
+ 
+ 	if (!aq_nic->aq_ptp)
+ 		return -EOPNOTSUPP;
+ 
+ 	aq_ptp_hwtstamp_config_get(aq_nic->aq_ptp, &config);
+ 	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+ 	       -EFAULT : 0;
+ }
+ #endif
+ 
+ static int aq_ndev_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(netdev);
+ 
+ 	switch (cmd) {
+ 	case SIOCSHWTSTAMP:
+ 		return aq_ndev_hwtstamp_set(aq_nic, ifr);
+ 
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 	case SIOCGHWTSTAMP:
+ 		return aq_ndev_hwtstamp_get(aq_nic, ifr);
+ #endif
+ 	}
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
++>>>>>>> 4378b882bf03 (net: atlantic: put ptp code under IS_REACHABLE check)
  static int aq_ndo_vlan_rx_add_vid(struct net_device *ndev, __be16 proto,
  				  u16 vid)
  {
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.c
index 26476a262015,8dd59e9fc3aa..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
@@@ -436,6 -488,23 +436,26 @@@ err_exit
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ void aq_ring_hwts_rx_clean(struct aq_ring_s *self, struct aq_nic_s *aq_nic)
+ {
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 	while (self->sw_head != self->hw_head) {
+ 		u64 ns;
+ 
+ 		aq_nic->aq_hw_ops->extract_hwts(aq_nic->aq_hw,
+ 						self->dx_ring +
+ 						(self->sw_head * self->dx_size),
+ 						self->dx_size, &ns);
+ 		aq_ptp_tx_hwtstamp(aq_nic, ns);
+ 
+ 		self->sw_head = aq_ring_next_dx(self, self->sw_head);
+ 	}
+ #endif
+ }
+ 
++>>>>>>> 4378b882bf03 (net: atlantic: put ptp code under IS_REACHABLE check)
  int aq_ring_rx_fill(struct aq_ring_s *self)
  {
  	unsigned int page_order = self->page_order;
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_main.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.c
