s390/zcrypt: move ap_msg param one level up the call chain

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 3730f5300b450bc89306c3ab79c254e6039d9197
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3730f530.failed

Move the creating and disposal of the struct ap_message one
level up the call chain. The ap message was constructed in the
calling functions in msgtype50 and msgtype6 but only for the
ica rsa messages. For CCA and EP11 CPRBs the ap message struct
is created in the zcrypt api functions.

This patch moves the construction of the ap message struct into
the functions zcrypt_rsa_modexpo and zcrypt_rsa_crt. So now all
the 4 zcrypt api functions zcrypt_rsa_modexpo, zcrypt_rsa_crt,
zcrypt_send_cprb and zcrypt_send_ep11_cprb appear and act
similar.

There are no functional changes coming with this patch.
However, the availability of the ap_message struct has
advantages which will be needed by a follow up patch.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 3730f5300b450bc89306c3ab79c254e6039d9197)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/zcrypt_api.c
#	drivers/s390/crypto/zcrypt_api.h
#	drivers/s390/crypto/zcrypt_msgtype50.c
#	drivers/s390/crypto/zcrypt_msgtype6.c
diff --cc drivers/s390/crypto/zcrypt_api.c
index 1d27c6c62e02,d642be65a3a0..000000000000
--- a/drivers/s390/crypto/zcrypt_api.c
+++ b/drivers/s390/crypto/zcrypt_api.c
@@@ -644,9 -635,10 +644,14 @@@ static long zcrypt_rsa_modexpo(struct a
  {
  	struct zcrypt_card *zc, *pref_zc;
  	struct zcrypt_queue *zq, *pref_zq;
++<<<<<<< HEAD
 +	unsigned int weight = 0, pref_weight = 0;
++=======
+ 	struct ap_message ap_msg;
+ 	unsigned int wgt = 0, pref_wgt = 0;
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	unsigned int func_code;
 -	int cpen, qpen, qid = 0, rc = -ENODEV;
 +	int qid = 0, rc = -ENODEV;
  	struct module *mod;
  
  	trace_s390_zcrypt_req(mex, TP_ICARSAMODEXPO);
@@@ -711,13 -715,18 +718,21 @@@
  	}
  
  	qid = pref_zq->queue->qid;
- 	rc = pref_zq->ops->rsa_modexpo(pref_zq, mex);
+ 	rc = pref_zq->ops->rsa_modexpo(pref_zq, mex, &ap_msg);
  
  	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);
 +	zcrypt_drop_queue(pref_zc, pref_zq, mod, weight);
  	spin_unlock(&zcrypt_list_lock);
  
  out:
++<<<<<<< HEAD
++=======
+ 	ap_release_message(&ap_msg);
+ 	if (tr) {
+ 		tr->last_rc = rc;
+ 		tr->last_qid = qid;
+ 	}
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	trace_s390_zcrypt_rep(mex, func_code, rc,
  			      AP_QID_CARD(qid), AP_QID_QUEUE(qid));
  	return rc;
@@@ -728,9 -738,10 +743,14 @@@ static long zcrypt_rsa_crt(struct ap_pe
  {
  	struct zcrypt_card *zc, *pref_zc;
  	struct zcrypt_queue *zq, *pref_zq;
++<<<<<<< HEAD
 +	unsigned int weight = 0, pref_weight = 0;
++=======
+ 	struct ap_message ap_msg;
+ 	unsigned int wgt = 0, pref_wgt = 0;
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	unsigned int func_code;
 -	int cpen, qpen, qid = 0, rc = -ENODEV;
 +	int qid = 0, rc = -ENODEV;
  	struct module *mod;
  
  	trace_s390_zcrypt_req(crt, TP_ICARSACRT);
@@@ -795,13 -818,18 +817,21 @@@
  	}
  
  	qid = pref_zq->queue->qid;
- 	rc = pref_zq->ops->rsa_modexpo_crt(pref_zq, crt);
+ 	rc = pref_zq->ops->rsa_modexpo_crt(pref_zq, crt, &ap_msg);
  
  	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);
 +	zcrypt_drop_queue(pref_zc, pref_zq, mod, weight);
  	spin_unlock(&zcrypt_list_lock);
  
  out:
++<<<<<<< HEAD
++=======
+ 	ap_release_message(&ap_msg);
+ 	if (tr) {
+ 		tr->last_rc = rc;
+ 		tr->last_qid = qid;
+ 	}
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	trace_s390_zcrypt_rep(crt, func_code, rc,
  			      AP_QID_CARD(qid), AP_QID_QUEUE(qid));
  	return rc;
diff --cc drivers/s390/crypto/zcrypt_api.h
index 599e68bf53f7,03804f03b5d0..000000000000
--- a/drivers/s390/crypto/zcrypt_api.h
+++ b/drivers/s390/crypto/zcrypt_api.h
@@@ -55,13 -55,27 +55,20 @@@ enum crypto_ops 
  
  struct zcrypt_queue;
  
 -/* struct to hold tracking information for a userspace request/response */
 -struct zcrypt_track {
 -	int again_counter;		/* retry attempts counter */
 -	int last_qid;			/* last qid used */
 -	int last_rc;			/* last return code */
 -};
 -
 -/* defines related to message tracking */
 -#define TRACK_AGAIN_MAX 10
 -#define TRACK_AGAIN_CARD_WEIGHT_PENALTY  1000
 -#define TRACK_AGAIN_QUEUE_WEIGHT_PENALTY 10000
 -
  struct zcrypt_ops {
- 	long (*rsa_modexpo)(struct zcrypt_queue *, struct ica_rsa_modexpo *);
+ 	long (*rsa_modexpo)(struct zcrypt_queue *, struct ica_rsa_modexpo *,
+ 			    struct ap_message *);
  	long (*rsa_modexpo_crt)(struct zcrypt_queue *,
++<<<<<<< HEAD
 +				struct ica_rsa_modexpo_crt *);
 +	long (*send_cprb)(struct zcrypt_queue *, struct ica_xcRB *,
++=======
+ 				struct ica_rsa_modexpo_crt *,
+ 				struct ap_message *);
+ 	long (*send_cprb)(bool userspace, struct zcrypt_queue *, struct ica_xcRB *,
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  			  struct ap_message *);
 -	long (*send_ep11_cprb)(bool userspace, struct zcrypt_queue *, struct ep11_urb *,
 +	long (*send_ep11_cprb)(struct zcrypt_queue *, struct ep11_urb *,
  			       struct ap_message *);
  	long (*rng)(struct zcrypt_queue *, char *, struct ap_message *);
  	struct list_head list;		/* zcrypt ops list. */
diff --cc drivers/s390/crypto/zcrypt_msgtype50.c
index 7aedc338b445,c543b5959509..000000000000
--- a/drivers/s390/crypto/zcrypt_msgtype50.c
+++ b/drivers/s390/crypto/zcrypt_msgtype50.c
@@@ -455,34 -456,35 +456,44 @@@ static long zcrypt_cex2a_modexpo(struc
  	struct completion work;
  	int rc;
  
- 	ap_init_message(&ap_msg);
  	if (zq->zcard->user_space_type == ZCRYPT_CEX2A)
- 		ap_msg.msg = kmalloc(MSGTYPE50_CRB2_MAX_MSG_SIZE, GFP_KERNEL);
+ 		ap_msg->msg = kmalloc(MSGTYPE50_CRB2_MAX_MSG_SIZE, GFP_KERNEL);
  	else
- 		ap_msg.msg = kmalloc(MSGTYPE50_CRB3_MAX_MSG_SIZE, GFP_KERNEL);
- 	if (!ap_msg.msg)
+ 		ap_msg->msg = kmalloc(MSGTYPE50_CRB3_MAX_MSG_SIZE, GFP_KERNEL);
+ 	if (!ap_msg->msg)
  		return -ENOMEM;
- 	ap_msg.receive = zcrypt_cex2a_receive;
- 	ap_msg.psmid = (((unsigned long long) current->pid) << 32) +
- 				atomic_inc_return(&zcrypt_step);
- 	ap_msg.private = &work;
- 	rc = ICAMEX_msg_to_type50MEX_msg(zq, &ap_msg, mex);
+ 	ap_msg->receive = zcrypt_cex2a_receive;
+ 	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+ 		atomic_inc_return(&zcrypt_step);
+ 	ap_msg->private = &work;
+ 	rc = ICAMEX_msg_to_type50MEX_msg(zq, ap_msg, mex);
  	if (rc)
- 		goto out_free;
+ 		goto out;
  	init_completion(&work);
++<<<<<<< HEAD
 +	ap_queue_message(zq->queue, &ap_msg);
++=======
+ 	rc = ap_queue_message(zq->queue, ap_msg);
+ 	if (rc)
+ 		goto out;
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	rc = wait_for_completion_interruptible(&work);
  	if (rc == 0) {
- 		rc = ap_msg.rc;
+ 		rc = ap_msg->rc;
  		if (rc == 0)
++<<<<<<< HEAD
 +			rc = convert_response(zq, &ap_msg, mex->outputdata,
 +					      mex->outputdatalength);
++=======
+ 			rc = convert_response_cex2a(zq, ap_msg,
+ 						    mex->outputdata,
+ 						    mex->outputdatalength);
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	} else
  		/* Signal pending. */
- 		ap_cancel_message(zq->queue, &ap_msg);
- out_free:
- 	kfree(ap_msg.msg);
+ 		ap_cancel_message(zq->queue, ap_msg);
+ out:
+ 	ap_msg->private = NULL;
  	return rc;
  }
  
@@@ -499,34 -502,35 +511,44 @@@ static long zcrypt_cex2a_modexpo_crt(st
  	struct completion work;
  	int rc;
  
- 	ap_init_message(&ap_msg);
  	if (zq->zcard->user_space_type == ZCRYPT_CEX2A)
- 		ap_msg.msg = kmalloc(MSGTYPE50_CRB2_MAX_MSG_SIZE, GFP_KERNEL);
+ 		ap_msg->msg = kmalloc(MSGTYPE50_CRB2_MAX_MSG_SIZE, GFP_KERNEL);
  	else
- 		ap_msg.msg = kmalloc(MSGTYPE50_CRB3_MAX_MSG_SIZE, GFP_KERNEL);
- 	if (!ap_msg.msg)
+ 		ap_msg->msg = kmalloc(MSGTYPE50_CRB3_MAX_MSG_SIZE, GFP_KERNEL);
+ 	if (!ap_msg->msg)
  		return -ENOMEM;
- 	ap_msg.receive = zcrypt_cex2a_receive;
- 	ap_msg.psmid = (((unsigned long long) current->pid) << 32) +
- 				atomic_inc_return(&zcrypt_step);
- 	ap_msg.private = &work;
- 	rc = ICACRT_msg_to_type50CRT_msg(zq, &ap_msg, crt);
+ 	ap_msg->receive = zcrypt_cex2a_receive;
+ 	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+ 		atomic_inc_return(&zcrypt_step);
+ 	ap_msg->private = &work;
+ 	rc = ICACRT_msg_to_type50CRT_msg(zq, ap_msg, crt);
  	if (rc)
- 		goto out_free;
+ 		goto out;
  	init_completion(&work);
++<<<<<<< HEAD
 +	ap_queue_message(zq->queue, &ap_msg);
++=======
+ 	rc = ap_queue_message(zq->queue, ap_msg);
+ 	if (rc)
+ 		goto out;
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	rc = wait_for_completion_interruptible(&work);
  	if (rc == 0) {
- 		rc = ap_msg.rc;
+ 		rc = ap_msg->rc;
  		if (rc == 0)
++<<<<<<< HEAD
 +			rc = convert_response(zq, &ap_msg, crt->outputdata,
 +					      crt->outputdatalength);
++=======
+ 			rc = convert_response_cex2a(zq, ap_msg,
+ 						    crt->outputdata,
+ 						    crt->outputdatalength);
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	} else
  		/* Signal pending. */
- 		ap_cancel_message(zq->queue, &ap_msg);
- out_free:
- 	kfree(ap_msg.msg);
+ 		ap_cancel_message(zq->queue, ap_msg);
+ out:
+ 	ap_msg->private = NULL;
  	return rc;
  }
  
diff --cc drivers/s390/crypto/zcrypt_msgtype6.c
index 3c73516880c9,aab7f0692035..000000000000
--- a/drivers/s390/crypto/zcrypt_msgtype6.c
+++ b/drivers/s390/crypto/zcrypt_msgtype6.c
@@@ -1027,12 -1026,14 +1026,18 @@@ static long zcrypt_msgtype6_modexpo(str
  	if (rc)
  		goto out_free;
  	init_completion(&resp_type.work);
++<<<<<<< HEAD
 +	ap_queue_message(zq->queue, &ap_msg);
++=======
+ 	rc = ap_queue_message(zq->queue, ap_msg);
+ 	if (rc)
+ 		goto out_free;
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	rc = wait_for_completion_interruptible(&resp_type.work);
  	if (rc == 0) {
- 		rc = ap_msg.rc;
+ 		rc = ap_msg->rc;
  		if (rc == 0)
- 			rc = convert_response_ica(zq, &ap_msg,
+ 			rc = convert_response_ica(zq, ap_msg,
  						  mex->outputdata,
  						  mex->outputdatalength);
  	} else
@@@ -1071,12 -1073,14 +1077,18 @@@ static long zcrypt_msgtype6_modexpo_crt
  	if (rc)
  		goto out_free;
  	init_completion(&resp_type.work);
++<<<<<<< HEAD
 +	ap_queue_message(zq->queue, &ap_msg);
++=======
+ 	rc = ap_queue_message(zq->queue, ap_msg);
+ 	if (rc)
+ 		goto out_free;
++>>>>>>> 3730f5300b45 (s390/zcrypt: move ap_msg param one level up the call chain)
  	rc = wait_for_completion_interruptible(&resp_type.work);
  	if (rc == 0) {
- 		rc = ap_msg.rc;
+ 		rc = ap_msg->rc;
  		if (rc == 0)
- 			rc = convert_response_ica(zq, &ap_msg,
+ 			rc = convert_response_ica(zq, ap_msg,
  						  crt->outputdata,
  						  crt->outputdatalength);
  	} else {
* Unmerged path drivers/s390/crypto/zcrypt_api.c
* Unmerged path drivers/s390/crypto/zcrypt_api.h
* Unmerged path drivers/s390/crypto/zcrypt_msgtype50.c
* Unmerged path drivers/s390/crypto/zcrypt_msgtype6.c
