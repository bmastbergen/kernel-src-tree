net: flow_offload: Fix memory leak for indirect flow block

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] flow_offload: Fix memory leak for indirect flow block (Guillaume Nault) [1917953]
Rebuild_FUZZ: 95.50%
commit-author Chris Mi <cmi@nvidia.com>
commit 5137d303659d8c324e67814b1cc2e1bc0c0d9836
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5137d303.failed

The offending commit introduces a cleanup callback that is invoked
when the driver module is removed to clean up the tunnel device
flow block. But it returns on the first iteration of the for loop.
The remaining indirect flow blocks will never be freed.

Fixes: 1fac52da5942 ("net: flow_offload: consolidate indirect flow_block infrastructure")
CC: Pablo Neira Ayuso <pablo@netfilter.org>
	Signed-off-by: Chris Mi <cmi@nvidia.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
(cherry picked from commit 5137d303659d8c324e67814b1cc2e1bc0c0d9836)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_offload.c
diff --cc net/core/flow_offload.c
index 5e5f0e36f351,715b67f6c62f..000000000000
--- a/net/core/flow_offload.c
+++ b/net/core/flow_offload.c
@@@ -379,11 -380,9 +379,14 @@@ static void __flow_block_indr_cleanup(f
  	struct flow_block_cb *this, *next;
  
  	list_for_each_entry_safe(this, next, &flow_block_indr_list, indr.list) {
++<<<<<<< HEAD
 +		if (this->cb == setup_cb &&
 +		    this->cb_priv == cb_priv) {
++=======
+ 		if (this->release == release &&
+ 		    this->indr.cb_priv == cb_priv)
++>>>>>>> 5137d303659d (net: flow_offload: Fix memory leak for indirect flow block)
  			list_move(&this->indr.list, cleanup_list);
- 			return;
- 		}
  	}
  }
  
* Unmerged path net/core/flow_offload.c
