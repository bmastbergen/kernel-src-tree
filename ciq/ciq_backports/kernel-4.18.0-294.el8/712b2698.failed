fs/stat: Define DAX statx attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit 712b2698e4c024b561694cbcc1abba13eb0fd9ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/712b2698.failed

In order for users to determine if a file is currently operating in DAX
state (effective DAX).  Define a statx attribute value and set that
attribute if the effective DAX flag is set.

To go along with this we propose the following addition to the statx man
page:

STATX_ATTR_DAX

	The file is in the DAX (cpu direct access) state.  DAX state
	attempts to minimize software cache effects for both I/O and
	memory mappings of this file.  It requires a file system which
	has been configured to support DAX.

	DAX generally assumes all accesses are via cpu load / store
	instructions which can minimize overhead for small accesses, but
	may adversely affect cpu utilization for large transfers.

	File I/O is done directly to/from user-space buffers and memory
	mapped I/O may be performed with direct memory mappings that
	bypass kernel page cache.

	While the DAX property tends to result in data being transferred
	synchronously, it does not give the same guarantees of O_SYNC
	where data and the necessary metadata are transferred together.

	A DAX file may support being mapped with the MAP_SYNC flag,
	which enables a program to use CPU cache flush instructions to
	persist CPU store operations without an explicit fsync(2).  See
	mmap(2) for more information.

	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 712b2698e4c024b561694cbcc1abba13eb0fd9ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/stat.c
#	include/uapi/linux/stat.h
diff --cc fs/stat.c
index 46dfe0df1a71,894699c74dde..000000000000
--- a/fs/stat.c
+++ b/fs/stat.c
@@@ -77,6 -72,16 +77,19 @@@ int vfs_getattr_nosec(const struct pat
  	stat->result_mask |= STATX_BASIC_STATS;
  	request_mask &= STATX_ALL;
  	query_flags &= KSTAT_QUERY_FLAGS;
++<<<<<<< HEAD
++=======
+ 
+ 	/* allow the fs to override these if it really wants to */
+ 	if (IS_NOATIME(inode))
+ 		stat->result_mask &= ~STATX_ATIME;
+ 	if (IS_AUTOMOUNT(inode))
+ 		stat->attributes |= STATX_ATTR_AUTOMOUNT;
+ 
+ 	if (IS_DAX(inode))
+ 		stat->attributes |= STATX_ATTR_DAX;
+ 
++>>>>>>> 712b2698e4c0 (fs/stat: Define DAX statx attribute)
  	if (inode->i_op->getattr)
  		return inode->i_op->getattr(path, stat, request_mask,
  					    query_flags);
diff --cc include/uapi/linux/stat.h
index 7b35e98d3c58,e5f9d5517f6b..000000000000
--- a/include/uapi/linux/stat.h
+++ b/include/uapi/linux/stat.h
@@@ -167,8 -167,9 +167,13 @@@ struct statx 
  #define STATX_ATTR_APPEND		0x00000020 /* [I] File is append-only */
  #define STATX_ATTR_NODUMP		0x00000040 /* [I] File is not to be dumped */
  #define STATX_ATTR_ENCRYPTED		0x00000800 /* [I] File requires key to decrypt in fs */
 +
  #define STATX_ATTR_AUTOMOUNT		0x00001000 /* Dir: Automount trigger */
++<<<<<<< HEAD
++=======
+ #define STATX_ATTR_VERITY		0x00100000 /* [I] Verity protected file */
+ #define STATX_ATTR_DAX			0x00002000 /* [I] File is DAX */
++>>>>>>> 712b2698e4c0 (fs/stat: Define DAX statx attribute)
  
  
  #endif /* _UAPI_LINUX_STAT_H */
* Unmerged path fs/stat.c
* Unmerged path include/uapi/linux/stat.h
