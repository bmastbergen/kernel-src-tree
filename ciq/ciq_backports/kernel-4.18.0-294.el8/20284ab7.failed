switch mount_capable() to fs_context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 20284ab7427ffac514faf44fd9eb50e5745f4474
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/20284ab7.failed

	now both callers of mount_capable() have access to fs_context;
the only difference is that for sget_fc() we have the possibility
of fc->global being true, while for legacy_get_tree() it's guaranteed
to be impossible.  Unify to more generic variant...

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 20284ab7427ffac514faf44fd9eb50e5745f4474)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs_context.c
#	fs/internal.h
#	fs/super.c
diff --cc fs/internal.h
index 172c0652a6e5,b089a489da1f..000000000000
--- a/fs/internal.h
+++ b/fs/internal.h
@@@ -99,11 -111,10 +99,15 @@@ extern struct file *alloc_empty_file_no
  /*
   * super.c
   */
 -extern int reconfigure_super(struct fs_context *);
 +extern int do_remount_sb(struct super_block *, int, void *, int);
  extern bool trylock_super(struct super_block *sb);
 +extern struct dentry *mount_fs(struct file_system_type *,
 +			       int, const char *, void *);
  extern struct super_block *user_get_super(dev_t);
++<<<<<<< HEAD
++=======
+ extern bool mount_capable(struct fs_context *);
++>>>>>>> 20284ab7427f (switch mount_capable() to fs_context)
  
  /*
   * open.c
diff --cc fs/super.c
index 72596c26684f,d1e2f46bad7e..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -478,6 -476,97 +478,100 @@@ void generic_shutdown_super(struct supe
  
  EXPORT_SYMBOL(generic_shutdown_super);
  
++<<<<<<< HEAD
++=======
+ bool mount_capable(struct fs_context *fc)
+ {
+ 	struct user_namespace *user_ns = fc->global ? &init_user_ns
+ 						    : fc->user_ns;
+ 
+ 	if (!(fc->fs_type->fs_flags & FS_USERNS_MOUNT))
+ 		return capable(CAP_SYS_ADMIN);
+ 	else
+ 		return ns_capable(user_ns, CAP_SYS_ADMIN);
+ }
+ 
+ /**
+  * sget_fc - Find or create a superblock
+  * @fc:	Filesystem context.
+  * @test: Comparison callback
+  * @set: Setup callback
+  *
+  * Find or create a superblock using the parameters stored in the filesystem
+  * context and the two callback functions.
+  *
+  * If an extant superblock is matched, then that will be returned with an
+  * elevated reference count that the caller must transfer or discard.
+  *
+  * If no match is made, a new superblock will be allocated and basic
+  * initialisation will be performed (s_type, s_fs_info and s_id will be set and
+  * the set() callback will be invoked), the superblock will be published and it
+  * will be returned in a partially constructed state with SB_BORN and SB_ACTIVE
+  * as yet unset.
+  */
+ struct super_block *sget_fc(struct fs_context *fc,
+ 			    int (*test)(struct super_block *, struct fs_context *),
+ 			    int (*set)(struct super_block *, struct fs_context *))
+ {
+ 	struct super_block *s = NULL;
+ 	struct super_block *old;
+ 	struct user_namespace *user_ns = fc->global ? &init_user_ns : fc->user_ns;
+ 	int err;
+ 
+ 	if (!(fc->sb_flags & SB_KERNMOUNT) &&
+ 	    fc->purpose != FS_CONTEXT_FOR_SUBMOUNT) {
+ 		if (!mount_capable(fc))
+ 			return ERR_PTR(-EPERM);
+ 	}
+ 
+ retry:
+ 	spin_lock(&sb_lock);
+ 	if (test) {
+ 		hlist_for_each_entry(old, &fc->fs_type->fs_supers, s_instances) {
+ 			if (test(old, fc))
+ 				goto share_extant_sb;
+ 		}
+ 	}
+ 	if (!s) {
+ 		spin_unlock(&sb_lock);
+ 		s = alloc_super(fc->fs_type, fc->sb_flags, user_ns);
+ 		if (!s)
+ 			return ERR_PTR(-ENOMEM);
+ 		goto retry;
+ 	}
+ 
+ 	s->s_fs_info = fc->s_fs_info;
+ 	err = set(s, fc);
+ 	if (err) {
+ 		s->s_fs_info = NULL;
+ 		spin_unlock(&sb_lock);
+ 		destroy_unused_super(s);
+ 		return ERR_PTR(err);
+ 	}
+ 	fc->s_fs_info = NULL;
+ 	s->s_type = fc->fs_type;
+ 	strlcpy(s->s_id, s->s_type->name, sizeof(s->s_id));
+ 	list_add_tail(&s->s_list, &super_blocks);
+ 	hlist_add_head(&s->s_instances, &s->s_type->fs_supers);
+ 	spin_unlock(&sb_lock);
+ 	get_filesystem(s->s_type);
+ 	register_shrinker_prepared(&s->s_shrink);
+ 	return s;
+ 
+ share_extant_sb:
+ 	if (user_ns != old->s_user_ns) {
+ 		spin_unlock(&sb_lock);
+ 		destroy_unused_super(s);
+ 		return ERR_PTR(-EBUSY);
+ 	}
+ 	if (!grab_super(old))
+ 		goto retry;
+ 	destroy_unused_super(s);
+ 	return old;
+ }
+ EXPORT_SYMBOL(sget_fc);
+ 
++>>>>>>> 20284ab7427f (switch mount_capable() to fs_context)
  /**
   *	sget_userns -	find or create a superblock
   *	@type:	filesystem type superblock should belong to
* Unmerged path fs/fs_context.c
* Unmerged path fs/fs_context.c
* Unmerged path fs/internal.h
* Unmerged path fs/super.c
