iwlwifi: move reclaim flows to the queue file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mordechay Goodstein <mordechay.goodstein@intel.com>
commit a4450980589522880b1429448a10db38fee2e26e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a4450980.failed

Reclaim flows are bus-independent TX functions so we move
it to the common place handling bus-independent tx operations

used spatch rule

@@
@@
(
-iwl_trans_pcie_freeze_txq_timer
+iwl_trans_txq_freeze_timer
|
-iwl_trans_pcie_set_q_ptrs
+iwl_trans_txq_set_q_ptrs
|
-iwl_pcie_txq_free_tfd
+iwl_txq_free_tfd
|
-iwl_pcie_txq_progress
+iwl_txq_progress
|
-iwl_trans_pcie_reclaim
+iwl_trans_txq_reclaim
)

	Signed-off-by: Mordechay Goodstein <mordechay.goodstein@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Link: https://lore.kernel.org/r/iwlwifi.20201209231352.40723e92b6bf.I83cf71d9c6d989ec42f52b353f1d33f32540db59@changeid
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit a4450980589522880b1429448a10db38fee2e26e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/pcie/internal.h
#	drivers/net/wireless/intel/iwlwifi/pcie/trans.c
#	drivers/net/wireless/intel/iwlwifi/pcie/tx.c
#	drivers/net/wireless/intel/iwlwifi/queue/tx.c
#	drivers/net/wireless/intel/iwlwifi/queue/tx.h
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/internal.h
index a594bca89be6,acbf367aea4c..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/internal.h
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/internal.h
@@@ -598,31 -549,10 +598,28 @@@ int iwl_trans_pcie_tx(struct iwl_trans 
  		      struct iwl_device_tx_cmd *dev_cmd, int txq_id);
  void iwl_pcie_txq_check_wrptrs(struct iwl_trans *trans);
  int iwl_trans_pcie_send_hcmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd);
 +void iwl_pcie_gen2_txq_inc_wr_ptr(struct iwl_trans *trans,
 +				  struct iwl_txq *txq);
  void iwl_pcie_hcmd_complete(struct iwl_trans *trans,
  			    struct iwl_rx_cmd_buffer *rxb);
- void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
- 			    struct sk_buff_head *skbs);
- void iwl_trans_pcie_set_q_ptrs(struct iwl_trans *trans, int txq_id, int ptr);
  void iwl_trans_pcie_tx_reset(struct iwl_trans *trans);
  
 +static inline u16 iwl_pcie_tfd_tb_get_len(struct iwl_trans *trans, void *_tfd,
 +					  u8 idx)
 +{
 +	if (trans->trans_cfg->use_tfh) {
 +		struct iwl_tfh_tfd *tfd = _tfd;
 +		struct iwl_tfh_tb *tb = &tfd->tbs[idx];
 +
 +		return le16_to_cpu(tb->tb_len);
 +	} else {
 +		struct iwl_tfd *tfd = _tfd;
 +		struct iwl_tfd_tb *tb = &tfd->tbs[idx];
 +
 +		return le16_to_cpu(tb->hi_n_len) >> 4;
 +	}
 +}
 +
  /*****************************************************
  * Error handling
  ******************************************************/
@@@ -951,14 -836,8 +948,17 @@@ void iwl_pcie_synchronize_irqs(struct i
  bool iwl_pcie_check_hw_rf_kill(struct iwl_trans *trans);
  void iwl_trans_pcie_handle_stop_rfkill(struct iwl_trans *trans,
  				       bool was_in_rfkill);
++<<<<<<< HEAD
 +void iwl_pcie_txq_free_tfd(struct iwl_trans *trans, struct iwl_txq *txq);
 +int iwl_queue_space(struct iwl_trans *trans, const struct iwl_txq *q);
++=======
++>>>>>>> a44509805895 (iwlwifi: move reclaim flows to the queue file)
  void iwl_pcie_apm_stop_master(struct iwl_trans *trans);
  void iwl_pcie_conf_msix_hw(struct iwl_trans_pcie *trans_pcie);
 +int iwl_pcie_txq_init(struct iwl_trans *trans, struct iwl_txq *txq,
 +		      int slots_num, bool cmd_queue);
 +int iwl_pcie_txq_alloc(struct iwl_trans *trans,
 +		       struct iwl_txq *txq, int slots_num,  bool cmd_queue);
  int iwl_pcie_alloc_dma_ptr(struct iwl_trans *trans,
  			   struct iwl_dma_ptr *ptr, size_t size);
  void iwl_pcie_free_dma_ptr(struct iwl_trans *trans, struct iwl_dma_ptr *ptr);
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/trans.c
index b4cbc98db20e,431e1a00d8de..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@@ -3502,13 -3415,13 +3449,18 @@@ static const struct iwl_trans_ops trans
  
  	.send_cmd = iwl_trans_pcie_gen2_send_hcmd,
  
++<<<<<<< HEAD
 +	.tx = iwl_trans_pcie_gen2_tx,
 +	.reclaim = iwl_trans_pcie_reclaim,
++=======
+ 	.tx = iwl_txq_gen2_tx,
+ 	.reclaim = iwl_txq_reclaim,
++>>>>>>> a44509805895 (iwlwifi: move reclaim flows to the queue file)
  
- 	.set_q_ptrs = iwl_trans_pcie_set_q_ptrs,
+ 	.set_q_ptrs = iwl_txq_set_q_ptrs,
  
 -	.txq_alloc = iwl_txq_dyn_alloc,
 -	.txq_free = iwl_txq_dyn_free,
 +	.txq_alloc = iwl_trans_pcie_dyn_txq_alloc,
 +	.txq_free = iwl_trans_pcie_dyn_txq_free,
  	.wait_txq_empty = iwl_trans_pcie_wait_txq_empty,
  	.rxq_dma_data = iwl_trans_pcie_rxq_dma_data,
  	.set_pnvm = iwl_trans_pcie_ctx_info_gen3_set_pnvm,
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/tx.c
index 10f21cd31aff,2beaf3c01552..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
@@@ -384,107 -205,6 +384,110 @@@ static inline void iwl_pcie_tfd_set_tb(
  	tfd_fh->num_tbs = idx + 1;
  }
  
++<<<<<<< HEAD
 +static inline u8 iwl_pcie_tfd_get_num_tbs(struct iwl_trans *trans, void *_tfd)
 +{
 +	if (trans->trans_cfg->use_tfh) {
 +		struct iwl_tfh_tfd *tfd = _tfd;
 +
 +		return le16_to_cpu(tfd->num_tbs) & 0x1f;
 +	} else {
 +		struct iwl_tfd *tfd = _tfd;
 +
 +		return tfd->num_tbs & 0x1f;
 +	}
 +}
 +
 +static void iwl_pcie_tfd_unmap(struct iwl_trans *trans,
 +			       struct iwl_cmd_meta *meta,
 +			       struct iwl_txq *txq, int index)
 +{
 +	int i, num_tbs;
 +	void *tfd = iwl_pcie_get_tfd(trans, txq, index);
 +
 +	/* Sanity check on number of chunks */
 +	num_tbs = iwl_pcie_tfd_get_num_tbs(trans, tfd);
 +
 +	if (num_tbs > trans->txqs.tfd.max_tbs) {
 +		IWL_ERR(trans, "Too many chunks: %i\n", num_tbs);
 +		/* @todo issue fatal error, it is quite serious situation */
 +		return;
 +	}
 +
 +	/* first TB is never freed - it's the bidirectional DMA data */
 +
 +	for (i = 1; i < num_tbs; i++) {
 +		if (meta->tbs & BIT(i))
 +			dma_unmap_page(trans->dev,
 +				       iwl_pcie_tfd_tb_get_addr(trans, tfd, i),
 +				       iwl_pcie_tfd_tb_get_len(trans, tfd, i),
 +				       DMA_TO_DEVICE);
 +		else
 +			dma_unmap_single(trans->dev,
 +					 iwl_pcie_tfd_tb_get_addr(trans, tfd,
 +								  i),
 +					 iwl_pcie_tfd_tb_get_len(trans, tfd,
 +								 i),
 +					 DMA_TO_DEVICE);
 +	}
 +
 +	meta->tbs = 0;
 +
 +	if (trans->trans_cfg->use_tfh) {
 +		struct iwl_tfh_tfd *tfd_fh = (void *)tfd;
 +
 +		tfd_fh->num_tbs = 0;
 +	} else {
 +		struct iwl_tfd *tfd_fh = (void *)tfd;
 +
 +		tfd_fh->num_tbs = 0;
 +	}
 +
 +}
 +
 +/*
 + * iwl_pcie_txq_free_tfd - Free all chunks referenced by TFD [txq->q.read_ptr]
 + * @trans - transport private data
 + * @txq - tx queue
 + * @dma_dir - the direction of the DMA mapping
 + *
 + * Does NOT advance any TFD circular buffer read/write indexes
 + * Does NOT free the TFD itself (which is within circular buffer)
 + */
 +void iwl_pcie_txq_free_tfd(struct iwl_trans *trans, struct iwl_txq *txq)
 +{
 +	/* rd_ptr is bounded by TFD_QUEUE_SIZE_MAX and
 +	 * idx is bounded by n_window
 +	 */
 +	int rd_ptr = txq->read_ptr;
 +	int idx = iwl_pcie_get_cmd_index(txq, rd_ptr);
 +
 +	lockdep_assert_held(&txq->lock);
 +
 +	/* We have only q->n_window txq->entries, but we use
 +	 * TFD_QUEUE_SIZE_MAX tfds
 +	 */
 +	iwl_pcie_tfd_unmap(trans, &txq->entries[idx].meta, txq, rd_ptr);
 +
 +	/* free SKB */
 +	if (txq->entries) {
 +		struct sk_buff *skb;
 +
 +		skb = txq->entries[idx].skb;
 +
 +		/* Can be called from irqs-disabled context
 +		 * If skb is not NULL, it means that the whole queue is being
 +		 * freed and that the queue is not empty - free the skb
 +		 */
 +		if (skb) {
 +			iwl_op_mode_free_skb(trans->op_mode, skb);
 +			txq->entries[idx].skb = NULL;
 +		}
 +	}
 +}
 +
++=======
++>>>>>>> a44509805895 (iwlwifi: move reclaim flows to the queue file)
  static int iwl_pcie_txq_build_tfd(struct iwl_trans *trans, struct iwl_txq *txq,
  				  dma_addr_t addr, u16 len, bool reset)
  {
@@@ -668,10 -269,10 +671,15 @@@ static void iwl_pcie_txq_unmap(struct i
  			if (WARN_ON_ONCE(!skb))
  				continue;
  
 -			iwl_txq_free_tso_page(trans, skb);
 +			iwl_pcie_free_tso_page(trans, skb);
  		}
++<<<<<<< HEAD
 +		iwl_pcie_txq_free_tfd(trans, txq);
 +		txq->read_ptr = iwl_queue_inc_wrap(trans, txq->read_ptr);
++=======
+ 		iwl_txq_free_tfd(trans, txq);
+ 		txq->read_ptr = iwl_txq_inc_wrap(trans, txq->read_ptr);
++>>>>>>> a44509805895 (iwlwifi: move reclaim flows to the queue file)
  
  		if (txq->read_ptr == txq->write_ptr) {
  			unsigned long flags;
@@@ -1079,160 -680,6 +1087,163 @@@ error
  	return ret;
  }
  
++<<<<<<< HEAD
 +static inline void iwl_pcie_txq_progress(struct iwl_txq *txq)
 +{
 +	lockdep_assert_held(&txq->lock);
 +
 +	if (!txq->wd_timeout)
 +		return;
 +
 +	/*
 +	 * station is asleep and we send data - that must
 +	 * be uAPSD or PS-Poll. Don't rearm the timer.
 +	 */
 +	if (txq->frozen)
 +		return;
 +
 +	/*
 +	 * if empty delete timer, otherwise move timer forward
 +	 * since we're making progress on this queue
 +	 */
 +	if (txq->read_ptr == txq->write_ptr)
 +		del_timer(&txq->stuck_timer);
 +	else
 +		mod_timer(&txq->stuck_timer, jiffies + txq->wd_timeout);
 +}
 +
 +/* Frees buffers until index _not_ inclusive */
 +void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
 +			    struct sk_buff_head *skbs)
 +{
 +	struct iwl_txq *txq = trans->txqs.txq[txq_id];
 +	int tfd_num = iwl_pcie_get_cmd_index(txq, ssn);
 +	int read_ptr = iwl_pcie_get_cmd_index(txq, txq->read_ptr);
 +	int last_to_free;
 +
 +	/* This function is not meant to release cmd queue*/
 +	if (WARN_ON(txq_id == trans->txqs.cmd.q_id))
 +		return;
 +
 +	spin_lock_bh(&txq->lock);
 +
 +	if (!test_bit(txq_id, trans->txqs.queue_used)) {
 +		IWL_DEBUG_TX_QUEUES(trans, "Q %d inactive - ignoring idx %d\n",
 +				    txq_id, ssn);
 +		goto out;
 +	}
 +
 +	if (read_ptr == tfd_num)
 +		goto out;
 +
 +	IWL_DEBUG_TX_REPLY(trans, "[Q %d] %d -> %d (%d)\n",
 +			   txq_id, txq->read_ptr, tfd_num, ssn);
 +
 +	/*Since we free until index _not_ inclusive, the one before index is
 +	 * the last we will free. This one must be used */
 +	last_to_free = iwl_queue_dec_wrap(trans, tfd_num);
 +
 +	if (!iwl_queue_used(txq, last_to_free)) {
 +		IWL_ERR(trans,
 +			"%s: Read index for txq id (%d), last_to_free %d is out of range [0-%d] %d %d.\n",
 +			__func__, txq_id, last_to_free,
 +			trans->trans_cfg->base_params->max_tfd_queue_size,
 +			txq->write_ptr, txq->read_ptr);
 +		goto out;
 +	}
 +
 +	if (WARN_ON(!skb_queue_empty(skbs)))
 +		goto out;
 +
 +	for (;
 +	     read_ptr != tfd_num;
 +	     txq->read_ptr = iwl_queue_inc_wrap(trans, txq->read_ptr),
 +	     read_ptr = iwl_pcie_get_cmd_index(txq, txq->read_ptr)) {
 +		struct sk_buff *skb = txq->entries[read_ptr].skb;
 +
 +		if (WARN_ON_ONCE(!skb))
 +			continue;
 +
 +		iwl_pcie_free_tso_page(trans, skb);
 +
 +		__skb_queue_tail(skbs, skb);
 +
 +		txq->entries[read_ptr].skb = NULL;
 +
 +		if (!trans->trans_cfg->use_tfh)
 +			iwl_pcie_txq_inval_byte_cnt_tbl(trans, txq);
 +
 +		iwl_pcie_txq_free_tfd(trans, txq);
 +	}
 +
 +	iwl_pcie_txq_progress(txq);
 +
 +	if (iwl_queue_space(trans, txq) > txq->low_mark &&
 +	    test_bit(txq_id, trans->txqs.queue_stopped)) {
 +		struct sk_buff_head overflow_skbs;
 +
 +		__skb_queue_head_init(&overflow_skbs);
 +		skb_queue_splice_init(&txq->overflow_q, &overflow_skbs);
 +
 +		/*
 +		 * We are going to transmit from the overflow queue.
 +		 * Remember this state so that wait_for_txq_empty will know we
 +		 * are adding more packets to the TFD queue. It cannot rely on
 +		 * the state of &txq->overflow_q, as we just emptied it, but
 +		 * haven't TXed the content yet.
 +		 */
 +		txq->overflow_tx = true;
 +
 +		/*
 +		 * This is tricky: we are in reclaim path which is non
 +		 * re-entrant, so noone will try to take the access the
 +		 * txq data from that path. We stopped tx, so we can't
 +		 * have tx as well. Bottom line, we can unlock and re-lock
 +		 * later.
 +		 */
 +		spin_unlock_bh(&txq->lock);
 +
 +		while (!skb_queue_empty(&overflow_skbs)) {
 +			struct sk_buff *skb = __skb_dequeue(&overflow_skbs);
 +			struct iwl_device_tx_cmd *dev_cmd_ptr;
 +
 +			dev_cmd_ptr = *(void **)((u8 *)skb->cb +
 +						 trans->txqs.dev_cmd_offs);
 +
 +			/*
 +			 * Note that we can very well be overflowing again.
 +			 * In that case, iwl_queue_space will be small again
 +			 * and we won't wake mac80211's queue.
 +			 */
 +			iwl_trans_tx(trans, skb, dev_cmd_ptr, txq_id);
 +		}
 +
 +		if (iwl_queue_space(trans, txq) > txq->low_mark)
 +			iwl_wake_queue(trans, txq);
 +
 +		spin_lock_bh(&txq->lock);
 +		txq->overflow_tx = false;
 +	}
 +
 +out:
 +	spin_unlock_bh(&txq->lock);
 +}
 +
 +/* Set wr_ptr of specific device and txq  */
 +void iwl_trans_pcie_set_q_ptrs(struct iwl_trans *trans, int txq_id, int ptr)
 +{
 +	struct iwl_txq *txq = trans->txqs.txq[txq_id];
 +
 +	spin_lock_bh(&txq->lock);
 +
 +	txq->write_ptr = ptr;
 +	txq->read_ptr = txq->write_ptr;
 +
 +	spin_unlock_bh(&txq->lock);
 +}
 +
++=======
++>>>>>>> a44509805895 (iwlwifi: move reclaim flows to the queue file)
  static int iwl_pcie_set_cmd_in_flight(struct iwl_trans *trans,
  				      const struct iwl_host_cmd *cmd)
  {
* Unmerged path drivers/net/wireless/intel/iwlwifi/queue/tx.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/queue/tx.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/internal.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/trans.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/tx.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/queue/tx.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/queue/tx.h
