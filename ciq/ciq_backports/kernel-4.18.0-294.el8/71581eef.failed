x86/fpu/xstate: Introduce XSAVES supervisor states

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yu-cheng Yu <yu-cheng.yu@intel.com>
commit 71581eefd7a0a81b1af7d7c93641925a01d70a9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/71581eef.failed

Enable XSAVES supervisor states by setting MSR_IA32_XSS bits according
to CPUID enumeration results. Also revise comments at various places.

Co-developed-by: Fenghua Yu <fenghua.yu@intel.com>
	Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
	Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
Link: https://lkml.kernel.org/r/20200512145444.15483-5-yu-cheng.yu@intel.com
(cherry picked from commit 71581eefd7a0a81b1af7d7c93641925a01d70a9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/xstate.c
diff --cc arch/x86/kernel/fpu/xstate.c
index 59e66b3b5b95,a68213ed5be6..000000000000
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@@ -217,23 -214,31 +217,42 @@@ void fpu__init_cpu_xstate(void
  	 * Unsupported supervisor xstates should not be found in
  	 * the xfeatures mask.
  	 */
 -	unsup_bits = xfeatures_mask_all & XFEATURE_MASK_SUPERVISOR_UNSUPPORTED;
 -	WARN_ONCE(unsup_bits, "x86/fpu: Found unsupported supervisor xstates: 0x%llx\n",
 -		  unsup_bits);
 +	WARN_ONCE((xfeatures_mask & XFEATURE_MASK_SUPERVISOR_UNSUPPORTED),
 +		  "x86/fpu: Found unsupported supervisor xstates.\n");
  
 -	xfeatures_mask_all &= ~XFEATURE_MASK_SUPERVISOR_UNSUPPORTED;
 +	xfeatures_mask &= ~XFEATURE_MASK_SUPERVISOR_UNSUPPORTED;
  
  	cr4_set_bits(X86_CR4_OSXSAVE);
++<<<<<<< HEAD
 +	xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask);
 +}
 +
 +/*
 + * Note that in the future we will likely need a pair of
 + * functions here: one for user xstates and the other for
 + * system xstates.  For now, they are the same.
 + */
 +static int xfeature_enabled(enum xfeature xfeature)
++=======
+ 
+ 	/*
+ 	 * XCR_XFEATURE_ENABLED_MASK (aka. XCR0) sets user features
+ 	 * managed by XSAVE{C, OPT, S} and XRSTOR{S}.  Only XSAVE user
+ 	 * states can be set here.
+ 	 */
+ 	xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask_user());
+ 
+ 	/*
+ 	 * MSR_IA32_XSS sets supervisor states managed by XSAVES.
+ 	 */
+ 	if (boot_cpu_has(X86_FEATURE_XSAVES))
+ 		wrmsrl(MSR_IA32_XSS, xfeatures_mask_supervisor());
+ }
+ 
+ static bool xfeature_enabled(enum xfeature xfeature)
++>>>>>>> 71581eefd7a0 (x86/fpu/xstate: Introduce XSAVES supervisor states)
  {
 -	return xfeatures_mask_all & BIT_ULL(xfeature);
 +	return !!(xfeatures_mask & (1UL << xfeature));
  }
  
  /*
@@@ -740,10 -742,19 +756,20 @@@ void __init fpu__init_system_xstate(voi
  		return;
  	}
  
 -	/*
 -	 * Find user xstates supported by the processor.
 -	 */
  	cpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);
 -	xfeatures_mask_all = eax + ((u64)edx << 32);
 +	xfeatures_mask = eax + ((u64)edx << 32);
  
++<<<<<<< HEAD
 +	if ((xfeatures_mask & XFEATURE_MASK_FPSSE) != XFEATURE_MASK_FPSSE) {
++=======
+ 	/*
+ 	 * Find supervisor xstates supported by the processor.
+ 	 */
+ 	cpuid_count(XSTATE_CPUID, 1, &eax, &ebx, &ecx, &edx);
+ 	xfeatures_mask_all |= ecx + ((u64)edx << 32);
+ 
+ 	if ((xfeatures_mask_user() & XFEATURE_MASK_FPSSE) != XFEATURE_MASK_FPSSE) {
++>>>>>>> 71581eefd7a0 (x86/fpu/xstate: Introduce XSAVES supervisor states)
  		/*
  		 * This indicates that something really unexpected happened
  		 * with the enumeration.  Disable XSAVE and try to continue
@@@ -801,7 -812,14 +827,18 @@@ void fpu__resume_cpu(void
  	 * Restore XCR0 on xsave capable CPUs:
  	 */
  	if (boot_cpu_has(X86_FEATURE_XSAVE))
++<<<<<<< HEAD
 +		xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask);
++=======
+ 		xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask_user());
+ 
+ 	/*
+ 	 * Restore IA32_XSS. The same CPUID bit enumerates support
+ 	 * of XSAVES and MSR_IA32_XSS.
+ 	 */
+ 	if (boot_cpu_has(X86_FEATURE_XSAVES))
+ 		wrmsrl(MSR_IA32_XSS, xfeatures_mask_supervisor());
++>>>>>>> 71581eefd7a0 (x86/fpu/xstate: Introduce XSAVES supervisor states)
  }
  
  /*
* Unmerged path arch/x86/kernel/fpu/xstate.c
