xfrm: bail early on slave pass over skb

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jarod Wilson <jarod@redhat.com>
commit 272c2330adc9c68284cb0066719160c24bfe605f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/272c2330.failed

This is prep work for initial support of bonding hardware encryption
pass-through support. The bonding driver will fill in the slave_dev
pointer, and we use that to know not to skb_push() again on a given
skb that was already processed on the bond device.

CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Veaceslav Falico <vfalico@gmail.com>
CC: Andy Gospodarek <andy@greyhouse.net>
CC: "David S. Miller" <davem@davemloft.net>
CC: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
CC: Jakub Kicinski <kuba@kernel.org>
CC: Steffen Klassert <steffen.klassert@secunet.com>
CC: Herbert Xu <herbert@gondor.apana.org.au>
CC: netdev@vger.kernel.org
CC: intel-wired-lan@lists.osuosl.org
	Signed-off-by: Jarod Wilson <jarod@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 272c2330adc9c68284cb0066719160c24bfe605f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_device.c
diff --cc net/xfrm/xfrm_device.c
index d74b15b58f38,b8918fc5248b..000000000000
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@@ -107,11 -103,13 +107,16 @@@ struct sk_buff *validate_xmit_xfrm(stru
  	unsigned long flags;
  	struct xfrm_state *x;
  	struct softnet_data *sd;
 -	struct sk_buff *skb2, *nskb, *pskb = NULL;
 +	struct sk_buff *skb2, *pskb = NULL;
  	netdev_features_t esp_features = features;
  	struct xfrm_offload *xo = xfrm_offload(skb);
++<<<<<<< HEAD
++=======
+ 	struct net_device *dev = skb->dev;
+ 	struct sec_path *sp;
++>>>>>>> 272c2330adc9 (xfrm: bail early on slave pass over skb)
  
 -	if (!xo)
 +	if (!xo || (xo->flags & XFRM_XMIT))
  		return skb;
  
  	if (!(features & NETIF_F_HW_ESP))
@@@ -131,27 -134,20 +140,27 @@@
  		return skb;
  	}
  
++<<<<<<< HEAD
 +	xo->flags |= XFRM_XMIT;
 +
 +	if (skb_is_gso(skb)) {
 +		struct net_device *dev = skb->dev;
++=======
+ 	if (skb_is_gso(skb) && unlikely(x->xso.dev != dev)) {
+ 		struct sk_buff *segs;
++>>>>>>> 272c2330adc9 (xfrm: bail early on slave pass over skb)
  
- 		if (unlikely(x->xso.dev != dev)) {
- 			struct sk_buff *segs;
- 
- 			/* Packet got rerouted, fixup features and segment it. */
- 			esp_features = esp_features & ~(NETIF_F_HW_ESP
- 							| NETIF_F_GSO_ESP);
+ 		/* Packet got rerouted, fixup features and segment it. */
+ 		esp_features = esp_features & ~(NETIF_F_HW_ESP | NETIF_F_GSO_ESP);
  
- 			segs = skb_gso_segment(skb, esp_features);
- 			if (IS_ERR(segs)) {
- 				kfree_skb(skb);
- 				atomic_long_inc(&dev->tx_dropped);
- 				return NULL;
- 			} else {
- 				consume_skb(skb);
- 				skb = segs;
- 			}
+ 		segs = skb_gso_segment(skb, esp_features);
+ 		if (IS_ERR(segs)) {
+ 			kfree_skb(skb);
+ 			atomic_long_inc(&dev->tx_dropped);
+ 			return NULL;
+ 		} else {
+ 			consume_skb(skb);
+ 			skb = segs;
  		}
  	}
  
diff --git a/include/net/xfrm.h b/include/net/xfrm.h
index e8f972e90d6f..3974b128051a 100644
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -132,6 +132,7 @@ struct xfrm_state_walk {
 
 struct xfrm_state_offload {
 	struct net_device	*dev;
+	struct net_device	*slave_dev;
 	unsigned long		offload_handle;
 	unsigned int		num_exthdrs;
 	u8			flags;
* Unmerged path net/xfrm/xfrm_device.c
