net/mlx5: E-Switch, Update VF vports config when num of VFs changed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Bodong Wang <bodong@mellanox.com>
commit 23bb50cf7399b4b702a34edb08f29c702cc54eb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/23bb50cf.failed

Currently, ECPF eswitch manager does one-time only configuration for
VF vports when device switches to offloads mode. However, when num of
VFs changed from host side, driver doesn't update VF vports
configurations.

Hence, perform VFs vport configuration update whenever num_vfs change
event occurs.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 23bb50cf7399b4b702a34edb08f29c702cc54eb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index e71c3e6ef4cd,1de2472a72e7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1943,6 -1953,59 +1943,62 @@@ static void mlx5_eswitch_clear_vf_vport
  /* Public E-Switch API */
  #define ESW_ALLOWED(esw) ((esw) && MLX5_ESWITCH_MANAGER((esw)->dev))
  
++<<<<<<< HEAD
++=======
+ int mlx5_eswitch_load_vport(struct mlx5_eswitch *esw, u16 vport_num,
+ 			    enum mlx5_eswitch_vport_event enabled_events)
+ {
+ 	int err;
+ 
+ 	err = esw_enable_vport(esw, vport_num, enabled_events);
+ 	if (err)
+ 		return err;
+ 
+ 	err = esw_offloads_load_rep(esw, vport_num);
+ 	if (err)
+ 		goto err_rep;
+ 
+ 	return err;
+ 
+ err_rep:
+ 	esw_disable_vport(esw, vport_num);
+ 	return err;
+ }
+ 
+ void mlx5_eswitch_unload_vport(struct mlx5_eswitch *esw, u16 vport_num)
+ {
+ 	esw_offloads_unload_rep(esw, vport_num);
+ 	esw_disable_vport(esw, vport_num);
+ }
+ 
+ void mlx5_eswitch_unload_vf_vports(struct mlx5_eswitch *esw, u16 num_vfs)
+ {
+ 	int i;
+ 
+ 	mlx5_esw_for_each_vf_vport_num_reverse(esw, i, num_vfs)
+ 		mlx5_eswitch_unload_vport(esw, i);
+ }
+ 
+ int mlx5_eswitch_load_vf_vports(struct mlx5_eswitch *esw, u16 num_vfs,
+ 				enum mlx5_eswitch_vport_event enabled_events)
+ {
+ 	int err;
+ 	int i;
+ 
+ 	mlx5_esw_for_each_vf_vport_num(esw, i, num_vfs) {
+ 		err = mlx5_eswitch_load_vport(esw, i, enabled_events);
+ 		if (err)
+ 			goto vf_err;
+ 	}
+ 
+ 	return 0;
+ 
+ vf_err:
+ 	mlx5_eswitch_unload_vf_vports(esw, i - 1);
+ 	return err;
+ }
+ 
++>>>>>>> 23bb50cf7399 (net/mlx5: E-Switch, Update VF vports config when num of VFs changed)
  /* mlx5_eswitch_enable_pf_vf_vports() enables vports of PF, ECPF and VFs
   * whichever are present on the eswitch.
   */
@@@ -1950,14 -2013,10 +2006,16 @@@ in
  mlx5_eswitch_enable_pf_vf_vports(struct mlx5_eswitch *esw,
  				 enum mlx5_eswitch_vport_event enabled_events)
  {
++<<<<<<< HEAD
 +	struct mlx5_vport *vport;
 +	int num_vfs;
++=======
++>>>>>>> 23bb50cf7399 (net/mlx5: E-Switch, Update VF vports config when num of VFs changed)
  	int ret;
- 	int i;
  
  	/* Enable PF vport */
 -	ret = mlx5_eswitch_load_vport(esw, MLX5_VPORT_PF, enabled_events);
 +	vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_PF);
 +	ret = esw_enable_vport(esw, vport, enabled_events);
  	if (ret)
  		return ret;
  
@@@ -1970,26 -2028,18 +2028,38 @@@
  	}
  
  	/* Enable VF vports */
++<<<<<<< HEAD
 +	mlx5_esw_for_each_vf_vport(esw, i, vport, esw->esw_funcs.num_vfs) {
 +		ret = esw_enable_vport(esw, vport, enabled_events);
 +		if (ret)
 +			goto vf_err;
 +	}
 +	return 0;
 +
 +vf_err:
 +	num_vfs = i - 1;
 +	mlx5_esw_for_each_vf_vport_reverse(esw, i, vport, num_vfs)
 +		esw_disable_vport(esw, vport);
 +
 +	if (mlx5_ecpf_vport_exists(esw->dev)) {
 +		vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_ECPF);
 +		esw_disable_vport(esw, vport);
 +	}
++=======
+ 	ret = mlx5_eswitch_load_vf_vports(esw, esw->esw_funcs.num_vfs,
+ 					  enabled_events);
+ 	if (ret)
+ 		goto vf_err;
+ 	return 0;
+ 
+ vf_err:
+ 	if (mlx5_ecpf_vport_exists(esw->dev))
+ 		mlx5_eswitch_unload_vport(esw, MLX5_VPORT_ECPF);
++>>>>>>> 23bb50cf7399 (net/mlx5: E-Switch, Update VF vports config when num of VFs changed)
  
  ecpf_err:
 -	mlx5_eswitch_unload_vport(esw, MLX5_VPORT_PF);
 +	vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_PF);
 +	esw_disable_vport(esw, vport);
  	return ret;
  }
  
@@@ -1998,11 -2048,12 +2068,20 @@@
   */
  void mlx5_eswitch_disable_pf_vf_vports(struct mlx5_eswitch *esw)
  {
++<<<<<<< HEAD
 +	struct mlx5_vport *vport;
 +	int i;
 +
 +	mlx5_esw_for_all_vports_reverse(esw, i, vport)
 +		esw_disable_vport(esw, vport);
++=======
+ 	mlx5_eswitch_unload_vf_vports(esw, esw->esw_funcs.num_vfs);
+ 
+ 	if (mlx5_ecpf_vport_exists(esw->dev))
+ 		mlx5_eswitch_unload_vport(esw, MLX5_VPORT_ECPF);
+ 
+ 	mlx5_eswitch_unload_vport(esw, MLX5_VPORT_PF);
++>>>>>>> 23bb50cf7399 (net/mlx5: E-Switch, Update VF vports config when num of VFs changed)
  }
  
  static void mlx5_eswitch_get_devlink_param(struct mlx5_eswitch *esw)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 0750ccdd712d,91b2aedcf52b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -650,6 -651,17 +650,20 @@@ esw_add_restore_rule(struct mlx5_eswitc
  u32
  esw_get_max_restore_tag(struct mlx5_eswitch *esw);
  
++<<<<<<< HEAD
++=======
+ int esw_offloads_load_rep(struct mlx5_eswitch *esw, u16 vport_num);
+ void esw_offloads_unload_rep(struct mlx5_eswitch *esw, u16 vport_num);
+ 
+ int mlx5_eswitch_load_vport(struct mlx5_eswitch *esw, u16 vport_num,
+ 			    enum mlx5_eswitch_vport_event enabled_events);
+ void mlx5_eswitch_unload_vport(struct mlx5_eswitch *esw, u16 vport_num);
+ 
+ int mlx5_eswitch_load_vf_vports(struct mlx5_eswitch *esw, u16 num_vfs,
+ 				enum mlx5_eswitch_vport_event enabled_events);
+ void mlx5_eswitch_unload_vf_vports(struct mlx5_eswitch *esw, u16 num_vfs);
+ 
++>>>>>>> 23bb50cf7399 (net/mlx5: E-Switch, Update VF vports config when num of VFs changed)
  #else  /* CONFIG_MLX5_ESWITCH */
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 43ed228c4d29,badae90206ac..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1661,53 -1670,23 +1653,54 @@@ static void __unload_reps_all_vport(str
  	__unload_reps_special_vport(esw, rep_type);
  }
  
 -int esw_offloads_load_rep(struct mlx5_eswitch *esw, u16 vport_num)
++<<<<<<< HEAD
 +static void esw_offloads_unload_all_reps(struct mlx5_eswitch *esw)
 +{
 +	u8 rep_type = NUM_REP_TYPES;
 +
 +	while (rep_type-- > 0)
 +		__unload_reps_all_vport(esw, rep_type);
 +}
 +
 +static int __esw_offloads_load_rep(struct mlx5_eswitch *esw,
 +				   struct mlx5_eswitch_rep *rep, u8 rep_type)
 +{
 +	int err = 0;
 +
 +	if (atomic_cmpxchg(&rep->rep_data[rep_type].state,
 +			   REP_REGISTERED, REP_LOADED) == REP_REGISTERED) {
 +		err = esw->offloads.rep_ops[rep_type]->load(esw->dev, rep);
 +		if (err)
 +			atomic_set(&rep->rep_data[rep_type].state,
 +				   REP_REGISTERED);
 +	}
 +
 +	return err;
 +}
 +
 +static int __load_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
  {
  	struct mlx5_eswitch_rep *rep;
 -	int rep_type;
  	int err;
  
 -	if (esw->mode != MLX5_ESWITCH_OFFLOADS)
 -		return 0;
 +	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 +	err = __esw_offloads_load_rep(esw, rep, rep_type);
 +	if (err)
 +		return err;
  
 -	rep = mlx5_eswitch_get_rep(esw, vport_num);
 -	for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++)
 -		if (atomic_cmpxchg(&rep->rep_data[rep_type].state,
 -				   REP_REGISTERED, REP_LOADED) == REP_REGISTERED) {
 -			err = esw->offloads.rep_ops[rep_type]->load(esw->dev, rep);
 -			if (err)
 -				goto err_reps;
 -		}
 +	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 +		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
 +		err = __esw_offloads_load_rep(esw, rep, rep_type);
 +		if (err)
 +			goto err_pf;
 +	}
 +
 +	if (mlx5_ecpf_vport_exists(esw->dev)) {
 +		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_ECPF);
 +		err = __esw_offloads_load_rep(esw, rep, rep_type);
 +		if (err)
 +			goto err_ecpf;
 +	}
  
  	return 0;
  
@@@ -1723,81 -1697,17 +1716,84 @@@ err_pf
  	return err;
  }
  
 -void esw_offloads_unload_rep(struct mlx5_eswitch *esw, u16 vport_num)
 +static int __load_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
 +				u8 rep_type)
  {
  	struct mlx5_eswitch_rep *rep;
 -	int rep_type;
 +	int err, i;
  
 -	if (esw->mode != MLX5_ESWITCH_OFFLOADS)
 -		return;
 +	mlx5_esw_for_each_vf_rep(esw, i, rep, nvports) {
 +		err = __esw_offloads_load_rep(esw, rep, rep_type);
 +		if (err)
 +			goto err_vf;
 +	}
  
 -	rep = mlx5_eswitch_get_rep(esw, vport_num);
 -	for (rep_type = NUM_REP_TYPES - 1; rep_type >= 0; rep_type--)
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 +	return 0;
 +
 +err_vf:
 +	__unload_reps_vf_vport(esw, --i, rep_type);
 +	return err;
 +}
 +
 +static int __load_reps_all_vport(struct mlx5_eswitch *esw, u8 rep_type)
 +{
 +	int err;
 +
 +	/* Special vports must be loaded first, uplink rep creates mdev resource. */
 +	err = __load_reps_special_vport(esw, rep_type);
 +	if (err)
 +		return err;
 +
 +	err = __load_reps_vf_vport(esw, esw->esw_funcs.num_vfs, rep_type);
 +	if (err)
 +		goto err_vfs;
 +
 +	return 0;
 +
 +err_vfs:
 +	__unload_reps_special_vport(esw, rep_type);
 +	return err;
 +}
 +
 +static int esw_offloads_load_vf_reps(struct mlx5_eswitch *esw, int nvports)
 +{
 +	u8 rep_type = 0;
 +	int err;
 +
 +	for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++) {
 +		err = __load_reps_vf_vport(esw, nvports, rep_type);
 +		if (err)
 +			goto err_reps;
 +	}
 +
 +	return err;
 +
 +err_reps:
 +	while (rep_type-- > 0)
 +		__unload_reps_vf_vport(esw, nvports, rep_type);
 +	return err;
 +}
 +
 +static int esw_offloads_load_all_reps(struct mlx5_eswitch *esw)
++=======
++int esw_offloads_load_rep(struct mlx5_eswitch *esw, u16 vport_num)
++>>>>>>> 23bb50cf7399 (net/mlx5: E-Switch, Update VF vports config when num of VFs changed)
 +{
 +	u8 rep_type = 0;
 +	int err;
 +
 +	for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++) {
 +		err = __load_reps_all_vport(esw, rep_type);
 +		if (err)
 +			goto err_reps;
 +	}
 +
 +	return err;
 +
 +err_reps:
 +	while (rep_type-- > 0)
 +		__unload_reps_all_vport(esw, rep_type);
 +	return err;
  }
  
  #define ESW_OFFLOADS_DEVCOM_PAIR	(0)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
