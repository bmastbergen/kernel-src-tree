x86/msi: Provide msi message shadow structs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] msi: Provide msi message shadow structs (Vitaly Kuznetsov) [1903823]
Rebuild_FUZZ: 95.12%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 6285aa507366729c618d5295fb540b24a956088a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6285aa50.failed

Create shadow structs with named bitfields for msi_msg data, address_lo and
address_hi and use them in the MSI message composer.

Provide a function to retrieve the destination ID. This could be inline,
but that'd create a circular header dependency.

[dwmw2: fix bitfields not all to be a union]

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20201024213535.443185-13-dwmw2@infradead.org

(cherry picked from commit 6285aa507366729c618d5295fb540b24a956088a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/msi.h
#	arch/x86/kernel/apic/apic.c
diff --cc arch/x86/include/asm/msi.h
index 25ddd0916bb2,322fd905da9c..000000000000
--- a/arch/x86/include/asm/msi.h
+++ b/arch/x86/include/asm/msi.h
@@@ -9,6 -9,53 +9,57 @@@ typedef struct irq_alloc_info msi_alloc
  int pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
  		    msi_alloc_info_t *arg);
  
++<<<<<<< HEAD
 +void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc);
++=======
+ /* Structs and defines for the X86 specific MSI message format */
+ 
+ typedef struct x86_msi_data {
+ 	u32	vector			:  8,
+ 		delivery_mode		:  3,
+ 		dest_mode_logical	:  1,
+ 		reserved		:  2,
+ 		active_low		:  1,
+ 		is_level		:  1;
+ 
+ 	u32	dmar_subhandle;
+ } __attribute__ ((packed)) arch_msi_msg_data_t;
+ #define arch_msi_msg_data	x86_msi_data
+ 
+ typedef struct x86_msi_addr_lo {
+ 	union {
+ 		struct {
+ 			u32	reserved_0		:  2,
+ 				dest_mode_logical	:  1,
+ 				redirect_hint		:  1,
+ 				reserved_1		:  8,
+ 				destid_0_7		:  8,
+ 				base_address		: 12;
+ 		};
+ 		struct {
+ 			u32	dmar_reserved_0		:  2,
+ 				dmar_index_15		:  1,
+ 				dmar_subhandle_valid	:  1,
+ 				dmar_format		:  1,
+ 				dmar_index_0_14		: 15,
+ 				dmar_base_address	: 12;
+ 		};
+ 	};
+ } __attribute__ ((packed)) arch_msi_msg_addr_lo_t;
+ #define arch_msi_msg_addr_lo	x86_msi_addr_lo
+ 
+ #define X86_MSI_BASE_ADDRESS_LOW	(0xfee00000 >> 20)
+ 
+ typedef struct x86_msi_addr_hi {
+ 	u32	reserved		:  8,
+ 		destid_8_31		: 24;
+ } __attribute__ ((packed)) arch_msi_msg_addr_hi_t;
+ #define arch_msi_msg_addr_hi	x86_msi_addr_hi
+ 
+ #define X86_MSI_BASE_ADDRESS_HIGH	(0)
+ 
+ struct msi_msg;
+ u32 x86_msi_msg_get_destid(struct msi_msg *msg, bool extid);
++>>>>>>> 6285aa507366 (x86/msi: Provide msi message shadow structs)
  
  #endif /* _ASM_X86_MSI_H */
diff --cc arch/x86/kernel/apic/apic.c
index fa2b1841198c,f7196ee0f005..000000000000
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@@ -2419,6 -2480,41 +2419,44 @@@ int hard_smp_processor_id(void
  	return read_apic_id();
  }
  
++<<<<<<< HEAD
++=======
+ void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg,
+ 			   bool dmar)
+ {
+ 	memset(msg, 0, sizeof(*msg));
+ 
+ 	msg->arch_addr_lo.base_address = X86_MSI_BASE_ADDRESS_LOW;
+ 	msg->arch_addr_lo.dest_mode_logical = apic->dest_mode_logical;
+ 	msg->arch_addr_lo.destid_0_7 = cfg->dest_apicid & 0xFF;
+ 
+ 	msg->arch_data.delivery_mode = APIC_DELIVERY_MODE_FIXED;
+ 	msg->arch_data.vector = cfg->vector;
+ 
+ 	msg->address_hi = X86_MSI_BASE_ADDRESS_HIGH;
+ 	/*
+ 	 * Only the IOMMU itself can use the trick of putting destination
+ 	 * APIC ID into the high bits of the address. Anything else would
+ 	 * just be writing to memory if it tried that, and needs IR to
+ 	 * address higher APIC IDs.
+ 	 */
+ 	if (dmar)
+ 		msg->arch_addr_hi.destid_8_31 = cfg->dest_apicid >> 8;
+ 	else
+ 		WARN_ON_ONCE(cfg->dest_apicid > 0xFF);
+ }
+ 
+ u32 x86_msi_msg_get_destid(struct msi_msg *msg, bool extid)
+ {
+ 	u32 dest = msg->arch_addr_lo.destid_0_7;
+ 
+ 	if (extid)
+ 		dest |= msg->arch_addr_hi.destid_8_31 << 8;
+ 	return dest;
+ }
+ EXPORT_SYMBOL_GPL(x86_msi_msg_get_destid);
+ 
++>>>>>>> 6285aa507366 (x86/msi: Provide msi message shadow structs)
  /*
   * Override the generic EOI implementation with an optimized version.
   * Only called during early boot when only one CPU is active and with
* Unmerged path arch/x86/include/asm/msi.h
* Unmerged path arch/x86/kernel/apic/apic.c
