net/mlx5: Enable QP number request when creating IPoIB underlay QP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michael Guralnik <michaelgur@mellanox.com>
commit 4dca650991e4175b8d5bae7ff6f1637a0c42be4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4dca6509.failed

If in the process of creating the underlay QP for an IPoIB interface
the user has set the address and specifically the 1st-3rd bytes
representing the QP number, use the requested QP number when creating
the underlay QP.

For a user to be able to request a QP number on QP creation, the MKEY_BY_NAME
NVCONFIG should be set. As mkey_by_name and qp_by_name are coupled in FW.
This requires driver to query the mkey_by_name max cap during initialization
and set the current cap if it was enabled in FW.

	Signed-off-by: Michael Guralnik <michaelgur@mellanox.com>
	Reviewed-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 4dca650991e4175b8d5bae7ff6f1637a0c42be4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index 2a89a07ac11c,d1266d8fed97..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@@ -225,18 -224,21 +225,33 @@@ void mlx5i_uninit_underlay_qp(struct ml
  
  #define MLX5_QP_ENHANCED_ULP_STATELESS_MODE 2
  
 -int mlx5i_create_underlay_qp(struct mlx5e_priv *priv)
 +int mlx5i_create_underlay_qp(struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp)
  {
++<<<<<<< HEAD
 +	u32 *in = NULL;
++=======
+ 	unsigned char *dev_addr = priv->netdev->dev_addr;
+ 	u32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};
+ 	u32 in[MLX5_ST_SZ_DW(create_qp_in)] = {};
+ 	struct mlx5i_priv *ipriv = priv->ppriv;
++>>>>>>> 4dca650991e4 (net/mlx5: Enable QP number request when creating IPoIB underlay QP)
  	void *addr_path;
+ 	int qpn = 0;
  	int ret = 0;
 +	int inlen;
  	void *qpc;
  
++<<<<<<< HEAD
 +	inlen = MLX5_ST_SZ_BYTES(create_qp_in);
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
++=======
+ 	if (MLX5_CAP_GEN(priv->mdev, mkey_by_name)) {
+ 		qpn = (dev_addr[1] << 16) + (dev_addr[2] << 8) + dev_addr[3];
+ 		MLX5_SET(create_qp_in, in, input_qpn, qpn);
+ 	}
++>>>>>>> 4dca650991e4 (net/mlx5: Enable QP number request when creating IPoIB underlay QP)
  
  	qpc = MLX5_ADDR_OF(create_qp_in, in, qpc);
  	MLX5_SET(qpc, qpc, st, MLX5_QP_ST_UD);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index 47898bcc6b8f..410f4a11bd77 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -557,6 +557,9 @@ static int handle_hca_cap(struct mlx5_core_dev *dev, void *set_ctx)
 	if (MLX5_CAP_GEN_MAX(dev, release_all_pages))
 		MLX5_SET(cmd_hca_cap, set_hca_cap, release_all_pages, 1);
 
+	if (MLX5_CAP_GEN_MAX(dev, mkey_by_name))
+		MLX5_SET(cmd_hca_cap, set_hca_cap, mkey_by_name, 1);
+
 	return set_caps(dev, set_ctx, MLX5_SET_HCA_CAP_OP_MOD_GENERAL_DEVICE);
 }
 
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index 70fdbd1f796a..9238f4155dd6 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -1390,7 +1390,10 @@ struct mlx5_ifc_cmd_hca_cap_bits {
 	u8         bf[0x1];
 	u8         driver_version[0x1];
 	u8         pad_tx_eth_packet[0x1];
-	u8         reserved_at_263[0x8];
+	u8         reserved_at_263[0x3];
+	u8         mkey_by_name[0x1];
+	u8         reserved_at_267[0x4];
+
 	u8         log_bf_reg_size[0x5];
 
 	u8         reserved_at_270[0x8];
@@ -7710,8 +7713,10 @@ struct mlx5_ifc_create_qp_in_bits {
 	u8         reserved_at_20[0x10];
 	u8         op_mod[0x10];
 
-	u8         reserved_at_40[0x40];
+	u8         reserved_at_40[0x8];
+	u8         input_qpn[0x18];
 
+	u8         reserved_at_60[0x20];
 	u8         opt_param_mask[0x20];
 
 	u8         ece[0x20];
