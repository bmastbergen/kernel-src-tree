xfs: switch to use the new mount-api

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ian Kent <raven@themaw.net>
commit 73e5fff98b6446de1490a8d7809121b0108d49f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/73e5fff9.failed

Define the struct fs_parameter_spec table that's used by the new
mount-api for options parsing.

Create the various fs context operations methods and define the
fs_context_operations struct.

Create the fs context initialization method and update the struct
file_system_type to utilize it. The initialization function is
responsible for working storage initialization, allocation and
initialization of file system private information storage and for
setting the operations in the fs context.

Also set struct file_system_type .parameters to the newly defined
struct fs_parameter_spec options parsing table for use by the fs
context methods and remove unused code.

[darrick: add a comment pointing out the one place where mp->m_super is
null]

	Signed-off-by: Ian Kent <raven@themaw.net>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 73e5fff98b6446de1490a8d7809121b0108d49f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index 9024b0a4c895,8dee362041f3..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -58,65 -59,69 +59,114 @@@ enum 
  	Opt_filestreams, Opt_quota, Opt_noquota, Opt_usrquota, Opt_grpquota,
  	Opt_prjquota, Opt_uquota, Opt_gquota, Opt_pquota,
  	Opt_uqnoenforce, Opt_gqnoenforce, Opt_pqnoenforce, Opt_qnoenforce,
- 	Opt_discard, Opt_nodiscard, Opt_dax, Opt_err,
+ 	Opt_discard, Opt_nodiscard, Opt_dax,
  };
  
++<<<<<<< HEAD
 +static const match_table_t tokens = {
 +	{Opt_logbufs,	"logbufs=%u"},	/* number of XFS log buffers */
 +	{Opt_logbsize,	"logbsize=%s"},	/* size of XFS log buffers */
 +	{Opt_logdev,	"logdev=%s"},	/* log device */
 +	{Opt_rtdev,	"rtdev=%s"},	/* realtime I/O device */
 +	{Opt_biosize,	"biosize=%u"},	/* log2 of preferred buffered io size */
 +	{Opt_wsync,	"wsync"},	/* safe-mode nfs compatible mount */
 +	{Opt_noalign,	"noalign"},	/* turn off stripe alignment */
 +	{Opt_swalloc,	"swalloc"},	/* turn on stripe width allocation */
 +	{Opt_sunit,	"sunit=%u"},	/* data volume stripe unit */
 +	{Opt_swidth,	"swidth=%u"},	/* data volume stripe width */
 +	{Opt_nouuid,	"nouuid"},	/* ignore filesystem UUID */
 +	{Opt_grpid,	"grpid"},	/* group-ID from parent directory */
 +	{Opt_nogrpid,	"nogrpid"},	/* group-ID from current process */
 +	{Opt_bsdgroups,	"bsdgroups"},	/* group-ID from parent directory */
 +	{Opt_sysvgroups,"sysvgroups"},	/* group-ID from current process */
 +	{Opt_allocsize,	"allocsize=%s"},/* preferred allocation size */
 +	{Opt_norecovery,"norecovery"},	/* don't run XFS recovery */
 +	{Opt_inode64,	"inode64"},	/* inodes can be allocated anywhere */
 +	{Opt_inode32,   "inode32"},	/* inode allocation limited to
 +					 * XFS_MAXINUMBER_32 */
 +	{Opt_ikeep,	"ikeep"},	/* do not free empty inode clusters */
 +	{Opt_noikeep,	"noikeep"},	/* free empty inode clusters */
 +	{Opt_largeio,	"largeio"},	/* report large I/O sizes in stat() */
 +	{Opt_nolargeio,	"nolargeio"},	/* do not report large I/O sizes
 +					 * in stat(). */
 +	{Opt_attr2,	"attr2"},	/* do use attr2 attribute format */
 +	{Opt_noattr2,	"noattr2"},	/* do not use attr2 attribute format */
 +	{Opt_filestreams,"filestreams"},/* use filestreams allocator */
 +	{Opt_quota,	"quota"},	/* disk quotas (user) */
 +	{Opt_noquota,	"noquota"},	/* no quotas */
 +	{Opt_usrquota,	"usrquota"},	/* user quota enabled */
 +	{Opt_grpquota,	"grpquota"},	/* group quota enabled */
 +	{Opt_prjquota,	"prjquota"},	/* project quota enabled */
 +	{Opt_uquota,	"uquota"},	/* user quota (IRIX variant) */
 +	{Opt_gquota,	"gquota"},	/* group quota (IRIX variant) */
 +	{Opt_pquota,	"pquota"},	/* project quota (IRIX variant) */
 +	{Opt_uqnoenforce,"uqnoenforce"},/* user quota limit enforcement */
 +	{Opt_gqnoenforce,"gqnoenforce"},/* group quota limit enforcement */
 +	{Opt_pqnoenforce,"pqnoenforce"},/* project quota limit enforcement */
 +	{Opt_qnoenforce, "qnoenforce"},	/* same as uqnoenforce */
 +	{Opt_discard,	"discard"},	/* Discard unused blocks */
 +	{Opt_nodiscard,	"nodiscard"},	/* Do not discard unused blocks */
 +	{Opt_dax,	"dax"},		/* Enable direct access to bdev pages */
 +	{Opt_err,	NULL},
++=======
+ static const struct fs_parameter_spec xfs_param_specs[] = {
+ 	fsparam_u32("logbufs",		Opt_logbufs),
+ 	fsparam_string("logbsize",	Opt_logbsize),
+ 	fsparam_string("logdev",	Opt_logdev),
+ 	fsparam_string("rtdev",		Opt_rtdev),
+ 	fsparam_flag("wsync",		Opt_wsync),
+ 	fsparam_flag("noalign",		Opt_noalign),
+ 	fsparam_flag("swalloc",		Opt_swalloc),
+ 	fsparam_u32("sunit",		Opt_sunit),
+ 	fsparam_u32("swidth",		Opt_swidth),
+ 	fsparam_flag("nouuid",		Opt_nouuid),
+ 	fsparam_flag("grpid",		Opt_grpid),
+ 	fsparam_flag("nogrpid",		Opt_nogrpid),
+ 	fsparam_flag("bsdgroups",	Opt_bsdgroups),
+ 	fsparam_flag("sysvgroups",	Opt_sysvgroups),
+ 	fsparam_string("allocsize",	Opt_allocsize),
+ 	fsparam_flag("norecovery",	Opt_norecovery),
+ 	fsparam_flag("inode64",		Opt_inode64),
+ 	fsparam_flag("inode32",		Opt_inode32),
+ 	fsparam_flag("ikeep",		Opt_ikeep),
+ 	fsparam_flag("noikeep",		Opt_noikeep),
+ 	fsparam_flag("largeio",		Opt_largeio),
+ 	fsparam_flag("nolargeio",	Opt_nolargeio),
+ 	fsparam_flag("attr2",		Opt_attr2),
+ 	fsparam_flag("noattr2",		Opt_noattr2),
+ 	fsparam_flag("filestreams",	Opt_filestreams),
+ 	fsparam_flag("quota",		Opt_quota),
+ 	fsparam_flag("noquota",		Opt_noquota),
+ 	fsparam_flag("usrquota",	Opt_usrquota),
+ 	fsparam_flag("grpquota",	Opt_grpquota),
+ 	fsparam_flag("prjquota",	Opt_prjquota),
+ 	fsparam_flag("uquota",		Opt_uquota),
+ 	fsparam_flag("gquota",		Opt_gquota),
+ 	fsparam_flag("pquota",		Opt_pquota),
+ 	fsparam_flag("uqnoenforce",	Opt_uqnoenforce),
+ 	fsparam_flag("gqnoenforce",	Opt_gqnoenforce),
+ 	fsparam_flag("pqnoenforce",	Opt_pqnoenforce),
+ 	fsparam_flag("qnoenforce",	Opt_qnoenforce),
+ 	fsparam_flag("discard",		Opt_discard),
+ 	fsparam_flag("nodiscard",	Opt_nodiscard),
+ 	fsparam_flag("dax",		Opt_dax),
+ 	{}
++>>>>>>> 73e5fff98b64 (xfs: switch to use the new mount-api)
  };
  
+ static const struct fs_parameter_description xfs_fs_parameters = {
+ 	.name		= "xfs",
+ 	.specs		= xfs_param_specs,
+ };
  
 -static int
 -suffix_kstrtoint(
 -	const char	*s,
 -	unsigned int	base,
 -	int		*res)
 +STATIC int
 +suffix_kstrtoint(const substring_t *s, unsigned int base, int *res)
  {
 -	int		last, shift_left_factor = 0, _res;
 -	char		*value;
 -	int		ret = 0;
 +	int	last, shift_left_factor = 0, _res;
 +	char	*value;
 +	int	ret = 0;
  
 -	value = kstrdup(s, GFP_KERNEL);
 +	value = match_strdup(s);
  	if (!value)
  		return -ENOMEM;
  
@@@ -142,190 -147,164 +192,341 @@@
  }
  
  /*
++<<<<<<< HEAD
 + * This function fills in xfs_mount_t fields based on mount args.
 + * Note: the superblock has _not_ yet been read in.
 + *
 + * Note that this function leaks the various device name allocations on
 + * failure.  The caller takes care of them.
 + *
 + * *sb is const because this is also used to test options on the remount
 + * path, and we don't want this to have any side effects at remount time.
 + * Today this function does not change *sb, but just to future-proof...
 + */
 +STATIC int
 +xfs_parseargs(
 +	struct xfs_mount	*mp,
 +	char			*options)
 +{
 +	const struct super_block *sb = mp->m_super;
 +	char			*p;
 +	substring_t		args[MAX_OPT_ARGS];
 +	int			iosize = 0;
 +	uint8_t			iosizelog = 0;
 +
 +	/*
 +	 * Copy binary VFS mount flags we are interested in.
 +	 */
 +	if (sb_rdonly(sb))
 +		mp->m_flags |= XFS_MOUNT_RDONLY;
 +	if (sb->s_flags & SB_DIRSYNC)
 +		mp->m_flags |= XFS_MOUNT_DIRSYNC;
 +	if (sb->s_flags & SB_SYNCHRONOUS)
++=======
+  * Set mount state from a mount option.
+  *
+  * NOTE: mp->m_super is NULL here!
+  */
+ static int
+ xfs_fc_parse_param(
+ 	struct fs_context	*fc,
+ 	struct fs_parameter	*param)
+ {
+ 	struct xfs_mount	*mp = fc->s_fs_info;
+ 	struct fs_parse_result	result;
+ 	int			size = 0;
+ 	int			opt;
+ 
+ 	opt = fs_parse(fc, &xfs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_logbufs:
+ 		mp->m_logbufs = result.uint_32;
+ 		return 0;
+ 	case Opt_logbsize:
+ 		if (suffix_kstrtoint(param->string, 10, &mp->m_logbsize))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_logdev:
+ 		kfree(mp->m_logname);
+ 		mp->m_logname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_logname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_rtdev:
+ 		kfree(mp->m_rtname);
+ 		mp->m_rtname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_rtname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_allocsize:
+ 		if (suffix_kstrtoint(param->string, 10, &size))
+ 			return -EINVAL;
+ 		mp->m_allocsize_log = ffs(size) - 1;
+ 		mp->m_flags |= XFS_MOUNT_ALLOCSIZE;
+ 		return 0;
+ 	case Opt_grpid:
+ 	case Opt_bsdgroups:
+ 		mp->m_flags |= XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_nogrpid:
+ 	case Opt_sysvgroups:
+ 		mp->m_flags &= ~XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_wsync:
++>>>>>>> 73e5fff98b64 (xfs: switch to use the new mount-api)
  		mp->m_flags |= XFS_MOUNT_WSYNC;
 +
 +	/*
 +	 * These can be overridden by the mount option parsing.
 +	 */
 +	mp->m_logbufs = -1;
 +	mp->m_logbsize = -1;
 +
 +	if (!options)
  		return 0;
++<<<<<<< HEAD
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int		token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_logbufs:
 +			if (match_int(args, &mp->m_logbufs))
 +				return -EINVAL;
 +			break;
 +		case Opt_logbsize:
 +			if (suffix_kstrtoint(args, 10, &mp->m_logbsize))
 +				return -EINVAL;
 +			break;
 +		case Opt_logdev:
 +			kfree(mp->m_logname);
 +			mp->m_logname = match_strdup(args);
 +			if (!mp->m_logname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_rtdev:
 +			kfree(mp->m_rtname);
 +			mp->m_rtname = match_strdup(args);
 +			if (!mp->m_rtname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_allocsize:
 +		case Opt_biosize:
 +			if (suffix_kstrtoint(args, 10, &iosize))
 +				return -EINVAL;
 +			iosizelog = ffs(iosize) - 1;
 +			break;
 +		case Opt_grpid:
 +		case Opt_bsdgroups:
 +			mp->m_flags |= XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_nogrpid:
 +		case Opt_sysvgroups:
 +			mp->m_flags &= ~XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_wsync:
 +			mp->m_flags |= XFS_MOUNT_WSYNC;
 +			break;
 +		case Opt_norecovery:
 +			mp->m_flags |= XFS_MOUNT_NORECOVERY;
 +			break;
 +		case Opt_noalign:
 +			mp->m_flags |= XFS_MOUNT_NOALIGN;
 +			break;
 +		case Opt_swalloc:
 +			mp->m_flags |= XFS_MOUNT_SWALLOC;
 +			break;
 +		case Opt_sunit:
 +			if (match_int(args, &mp->m_dalign))
 +				return -EINVAL;
 +			break;
 +		case Opt_swidth:
 +			if (match_int(args, &mp->m_swidth))
 +				return -EINVAL;
 +			break;
 +		case Opt_inode32:
 +			mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_inode64:
 +			mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_nouuid:
 +			mp->m_flags |= XFS_MOUNT_NOUUID;
 +			break;
 +		case Opt_ikeep:
 +			mp->m_flags |= XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_noikeep:
 +			mp->m_flags &= ~XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_largeio:
 +			mp->m_flags |= XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_nolargeio:
 +			mp->m_flags &= ~XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_attr2:
 +			mp->m_flags |= XFS_MOUNT_ATTR2;
 +			break;
 +		case Opt_noattr2:
 +			mp->m_flags &= ~XFS_MOUNT_ATTR2;
 +			mp->m_flags |= XFS_MOUNT_NOATTR2;
 +			break;
 +		case Opt_filestreams:
 +			mp->m_flags |= XFS_MOUNT_FILESTREAMS;
 +			break;
 +		case Opt_noquota:
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
 +			break;
 +		case Opt_quota:
 +		case Opt_uquota:
 +		case Opt_usrquota:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
 +					 XFS_UQUOTA_ENFD);
 +			break;
 +		case Opt_qnoenforce:
 +		case Opt_uqnoenforce:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_UQUOTA_ENFD;
 +			break;
 +		case Opt_pquota:
 +		case Opt_prjquota:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
 +					 XFS_PQUOTA_ENFD);
 +			break;
 +		case Opt_pqnoenforce:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_PQUOTA_ENFD;
 +			break;
 +		case Opt_gquota:
 +		case Opt_grpquota:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
 +					 XFS_GQUOTA_ENFD);
 +			break;
 +		case Opt_gqnoenforce:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_GQUOTA_ENFD;
 +			break;
 +		case Opt_discard:
 +			mp->m_flags |= XFS_MOUNT_DISCARD;
 +			break;
 +		case Opt_nodiscard:
 +			mp->m_flags &= ~XFS_MOUNT_DISCARD;
 +			break;
++=======
+ 	case Opt_norecovery:
+ 		mp->m_flags |= XFS_MOUNT_NORECOVERY;
+ 		return 0;
+ 	case Opt_noalign:
+ 		mp->m_flags |= XFS_MOUNT_NOALIGN;
+ 		return 0;
+ 	case Opt_swalloc:
+ 		mp->m_flags |= XFS_MOUNT_SWALLOC;
+ 		return 0;
+ 	case Opt_sunit:
+ 		mp->m_dalign = result.uint_32;
+ 		return 0;
+ 	case Opt_swidth:
+ 		mp->m_swidth = result.uint_32;
+ 		return 0;
+ 	case Opt_inode32:
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_inode64:
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_nouuid:
+ 		mp->m_flags |= XFS_MOUNT_NOUUID;
+ 		return 0;
+ 	case Opt_ikeep:
+ 		mp->m_flags |= XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_noikeep:
+ 		mp->m_flags &= ~XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_largeio:
+ 		mp->m_flags |= XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_nolargeio:
+ 		mp->m_flags &= ~XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_attr2:
+ 		mp->m_flags |= XFS_MOUNT_ATTR2;
+ 		return 0;
+ 	case Opt_noattr2:
+ 		mp->m_flags &= ~XFS_MOUNT_ATTR2;
+ 		mp->m_flags |= XFS_MOUNT_NOATTR2;
+ 		return 0;
+ 	case Opt_filestreams:
+ 		mp->m_flags |= XFS_MOUNT_FILESTREAMS;
+ 		return 0;
+ 	case Opt_noquota:
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
+ 		return 0;
+ 	case Opt_quota:
+ 	case Opt_uquota:
+ 	case Opt_usrquota:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
+ 				 XFS_UQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_qnoenforce:
+ 	case Opt_uqnoenforce:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_UQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_pquota:
+ 	case Opt_prjquota:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
+ 				 XFS_PQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_pqnoenforce:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_PQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_gquota:
+ 	case Opt_grpquota:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
+ 				 XFS_GQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_gqnoenforce:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_GQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_discard:
+ 		mp->m_flags |= XFS_MOUNT_DISCARD;
+ 		return 0;
+ 	case Opt_nodiscard:
+ 		mp->m_flags &= ~XFS_MOUNT_DISCARD;
+ 		return 0;
++>>>>>>> 73e5fff98b64 (xfs: switch to use the new mount-api)
  #ifdef CONFIG_FS_DAX
 -	case Opt_dax:
 -		mp->m_flags |= XFS_MOUNT_DAX;
 -		return 0;
 +		case Opt_dax:
 +			mp->m_flags |= XFS_MOUNT_DAX;
 +			break;
  #endif
++<<<<<<< HEAD
 +		default:
 +			xfs_warn(mp, "unknown mount option [%s].", p);
 +			return -EINVAL;
 +		}
++=======
+ 	default:
+ 		xfs_warn(mp, "unknown mount option [%s].", param->key);
+ 		return -EINVAL;
++>>>>>>> 73e5fff98b64 (xfs: switch to use the new mount-api)
  	}
  
 -	return 0;
 -}
 -
 -static int
 -xfs_fc_validate_params(
 -	struct xfs_mount	*mp)
 -{
  	/*
  	 * no recovery flag requires a read-only mount
  	 */
* Unmerged path fs/xfs/xfs_super.c
