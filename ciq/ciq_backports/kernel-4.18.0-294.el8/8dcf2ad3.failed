net: atlantic: add hwmon getter for MAC temperature

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mark Starovoytov <mstarovoitov@marvell.com>
commit 8dcf2ad39fdb2d183b7bd4307c837713e3150b9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8dcf2ad3.failed

This patch adds the possibility to obtain MAC temperature via hwmon.
On A1 there are two separate temperature sensors.
On A2 there's only one temperature sensor, which is used for reporting
both MAC and PHY temperature.

	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8dcf2ad39fdb2d183b7bd4307c837713e3150b9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_hw.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_utils_fw.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 46eaf70c5ccb,95ee1336ac79..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@@ -243,7 -300,41 +243,14 @@@ struct aq_hw_ops 
  	int (*hw_set_offload)(struct aq_hw_s *self,
  			      struct aq_nic_cfg_s *aq_nic_cfg);
  
 -	int (*hw_ring_hwts_rx_fill)(struct aq_hw_s *self,
 -				    struct aq_ring_s *aq_ring);
 -
 -	int (*hw_ring_hwts_rx_receive)(struct aq_hw_s *self,
 -				       struct aq_ring_s *ring);
 -
 -	void (*hw_get_ptp_ts)(struct aq_hw_s *self, u64 *stamp);
 -
 -	int (*hw_adj_clock_freq)(struct aq_hw_s *self, s32 delta);
 -
 -	int (*hw_adj_sys_clock)(struct aq_hw_s *self, s64 delta);
 -
 -	int (*hw_set_sys_clock)(struct aq_hw_s *self, u64 time, u64 ts);
 -
 -	int (*hw_ts_to_sys_clock)(struct aq_hw_s *self, u64 ts, u64 *time);
 -
 -	int (*hw_gpio_pulse)(struct aq_hw_s *self, u32 index, u64 start,
 -			     u32 period);
 -
 -	int (*hw_extts_gpio_enable)(struct aq_hw_s *self, u32 index,
 -				    u32 enable);
 -
 -	int (*hw_get_sync_ts)(struct aq_hw_s *self, u64 *ts);
 -
 -	u16 (*rx_extract_ts)(struct aq_hw_s *self, u8 *p, unsigned int len,
 -			     u64 *timestamp);
 -
 -	int (*extract_hwts)(struct aq_hw_s *self, u8 *p, unsigned int len,
 -			    u64 *timestamp);
 -
  	int (*hw_set_fc)(struct aq_hw_s *self, u32 fc, u32 tc);
++<<<<<<< HEAD
++=======
+ 
+ 	int (*hw_set_loopback)(struct aq_hw_s *self, u32 mode, bool enable);
+ 
+ 	int (*hw_get_mac_temp)(struct aq_hw_s *self, u32 *temp);
++>>>>>>> 8dcf2ad39fdb (net: atlantic: add hwmon getter for MAC temperature)
  };
  
  struct aq_fw_ops {
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index b7e5ce0d7af5,34626eef2909..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -1114,6 -1556,73 +1114,76 @@@ static int hw_atl_b0_hw_vlan_ctrl(struc
  	return aq_hw_err_from_flags(self);
  }
  
++<<<<<<< HEAD
++=======
+ int hw_atl_b0_set_loopback(struct aq_hw_s *self, u32 mode, bool enable)
+ {
+ 	switch (mode) {
+ 	case AQ_HW_LOOPBACK_DMA_SYS:
+ 		hw_atl_tpb_tx_dma_sys_lbk_en_set(self, enable);
+ 		hw_atl_rpb_dma_sys_lbk_set(self, enable);
+ 		break;
+ 	case AQ_HW_LOOPBACK_PKT_SYS:
+ 		hw_atl_tpo_tx_pkt_sys_lbk_en_set(self, enable);
+ 		hw_atl_rpf_tpo_to_rpf_sys_lbk_set(self, enable);
+ 		break;
+ 	case AQ_HW_LOOPBACK_DMA_NET:
+ 		hw_atl_rpf_vlan_prom_mode_en_set(self, enable);
+ 		hw_atl_rpfl2promiscuous_mode_en_set(self, enable);
+ 		hw_atl_tpb_tx_tx_clk_gate_en_set(self, !enable);
+ 		hw_atl_tpb_tx_dma_net_lbk_en_set(self, enable);
+ 		hw_atl_rpb_dma_net_lbk_set(self, enable);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 hw_atl_b0_ts_ready_and_latch_high_get(struct aq_hw_s *self)
+ {
+ 	if (hw_atl_ts_ready_get(self) && hw_atl_ts_ready_latch_high_get(self))
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ static int hw_atl_b0_get_mac_temp(struct aq_hw_s *self, u32 *temp)
+ {
+ 	bool ts_disabled;
+ 	int err;
+ 	u32 val;
+ 	u32 ts;
+ 
+ 	ts_disabled = (hw_atl_ts_power_down_get(self) == 1U);
+ 
+ 	if (ts_disabled) {
+ 		// Set AFE Temperature Sensor to on (off by default)
+ 		hw_atl_ts_power_down_set(self, 0U);
+ 
+ 		// Reset internal capacitors, biasing, and counters
+ 		hw_atl_ts_reset_set(self, 1);
+ 		hw_atl_ts_reset_set(self, 0);
+ 	}
+ 
+ 	err = readx_poll_timeout_atomic(hw_atl_b0_ts_ready_and_latch_high_get,
+ 					self, val, val == 1, 10000U, 500000U);
+ 	if (err)
+ 		return err;
+ 
+ 	ts = hw_atl_ts_data_get(self);
+ 	*temp = ts * ts * 16 / 100000 + 60 * ts - 83410;
+ 
+ 	if (ts_disabled) {
+ 		// Set AFE Temperature Sensor back to off
+ 		hw_atl_ts_power_down_set(self, 1U);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 8dcf2ad39fdb (net: atlantic: add hwmon getter for MAC temperature)
  const struct aq_hw_ops hw_atl_ops_b0 = {
  	.hw_soft_reset        = hw_atl_utils_soft_reset,
  	.hw_prepare           = hw_atl_utils_initfw,
@@@ -1152,6 -1661,24 +1222,28 @@@
  	.hw_get_regs                 = hw_atl_utils_hw_get_regs,
  	.hw_get_hw_stats             = hw_atl_utils_get_hw_stats,
  	.hw_get_fw_version           = hw_atl_utils_get_fw_version,
++<<<<<<< HEAD
 +	.hw_set_offload              = hw_atl_b0_hw_offload_set,
 +	.hw_set_fc                   = hw_atl_b0_set_fc,
++=======
+ 
+ 	.hw_ring_hwts_rx_fill        = hw_atl_b0_hw_ring_hwts_rx_fill,
+ 	.hw_ring_hwts_rx_receive     = hw_atl_b0_hw_ring_hwts_rx_receive,
+ 
+ 	.hw_get_ptp_ts           = hw_atl_b0_get_ptp_ts,
+ 	.hw_adj_sys_clock        = hw_atl_b0_adj_sys_clock,
+ 	.hw_set_sys_clock        = hw_atl_b0_set_sys_clock,
+ 	.hw_ts_to_sys_clock      = hw_atl_b0_ts_to_sys_clock,
+ 	.hw_adj_clock_freq       = hw_atl_b0_adj_clock_freq,
+ 	.hw_gpio_pulse           = hw_atl_b0_gpio_pulse,
+ 	.hw_extts_gpio_enable    = hw_atl_b0_extts_gpio_enable,
+ 	.hw_get_sync_ts          = hw_atl_b0_get_sync_ts,
+ 	.rx_extract_ts           = hw_atl_b0_rx_extract_ts,
+ 	.extract_hwts            = hw_atl_b0_extract_hwts,
+ 	.hw_set_offload          = hw_atl_b0_hw_offload_set,
+ 	.hw_set_loopback         = hw_atl_b0_set_loopback,
+ 	.hw_set_fc               = hw_atl_b0_set_fc,
+ 
+ 	.hw_get_mac_temp         = hw_atl_b0_get_mac_temp,
++>>>>>>> 8dcf2ad39fdb (net: atlantic: add hwmon getter for MAC temperature)
  };
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
index 103608a7664f,93c06dfa6c55..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
@@@ -536,20 -612,87 +536,38 @@@ static u32 aq_fw2x_state2_get(struct aq
  	return aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR);
  }
  
 -static u32 aq_fw2x_get_link_capabilities(struct aq_hw_s *self)
 -{
 -	int err = 0;
 -	u32 offset;
 -	u32 val;
 -
 -	offset = self->mbox_addr +
 -		 offsetof(struct hw_atl_utils_mbox, info.caps_lo);
 -
 -	err = hw_atl_utils_fw_downld_dwords(self, offset, &val, 1);
 -
 -	if (err)
 -		return 0;
 -
 -	return val;
 -}
 -
 -static int aq_fw2x_send_macsec_req(struct aq_hw_s *hw,
 -				   struct macsec_msg_fw_request *req,
 -				   struct macsec_msg_fw_response *response)
 -{
 -	u32 low_status, low_req = 0;
 -	u32 dword_cnt;
 -	u32 caps_lo;
 -	u32 offset;
 -	int err;
 -
 -	if (!req || !response)
 -		return -EINVAL;
 -
 -	caps_lo = aq_fw2x_get_link_capabilities(hw);
 -	if (!(caps_lo & BIT(CAPS_LO_MACSEC)))
 -		return -EOPNOTSUPP;
 -
 -	/* Write macsec request to cfg memory */
 -	dword_cnt = (sizeof(*req) + sizeof(u32) - 1) / sizeof(u32);
 -	err = hw_atl_write_fwcfg_dwords(hw, (void *)req, dword_cnt);
 -	if (err < 0)
 -		return err;
 -
 -	/* Toggle 0x368.CAPS_LO_MACSEC bit */
 -	low_req = aq_hw_read_reg(hw, HW_ATL_FW2X_MPI_CONTROL_ADDR);
 -	low_req ^= HW_ATL_FW2X_CAP_MACSEC;
 -	aq_hw_write_reg(hw, HW_ATL_FW2X_MPI_CONTROL_ADDR, low_req);
 -
 -	/* Wait FW to report back */
 -	err = readx_poll_timeout_atomic(aq_fw2x_state_get, hw, low_status,
 -		low_req != (low_status & BIT(CAPS_LO_MACSEC)), 1U, 10000U);
 -	if (err)
 -		return -EIO;
 -
 -	/* Read status of write operation */
 -	offset = hw->rpc_addr + sizeof(u32);
 -	err = hw_atl_utils_fw_downld_dwords(hw, offset, (u32 *)(void *)response,
 -					    sizeof(*response) / sizeof(u32));
 -
 -	return err;
 -}
 -
  const struct aq_fw_ops aq_fw_2x_ops = {
 -	.init               = aq_fw2x_init,
 -	.deinit             = aq_fw2x_deinit,
 -	.reset              = NULL,
 -	.renegotiate        = aq_fw2x_renegotiate,
 -	.get_mac_permanent  = aq_fw2x_get_mac_permanent,
 -	.set_link_speed     = aq_fw2x_set_link_speed,
 -	.set_state          = aq_fw2x_set_state,
 +	.init = aq_fw2x_init,
 +	.deinit = aq_fw2x_deinit,
 +	.reset = NULL,
 +	.renegotiate = aq_fw2x_renegotiate,
 +	.get_mac_permanent = aq_fw2x_get_mac_permanent,
 +	.set_link_speed = aq_fw2x_set_link_speed,
 +	.set_state = aq_fw2x_set_state,
  	.update_link_status = aq_fw2x_update_link_status,
++<<<<<<< HEAD
 +	.update_stats = aq_fw2x_update_stats,
 +	.get_phy_temp = aq_fw2x_get_phy_temp,
 +	.set_power = aq_fw2x_set_power,
 +	.set_eee_rate = aq_fw2x_set_eee_rate,
 +	.get_eee_rate = aq_fw2x_get_eee_rate,
 +	.set_flow_control = aq_fw2x_set_flow_control,
 +	.get_flow_control = aq_fw2x_get_flow_control
++=======
+ 	.update_stats       = aq_fw2x_update_stats,
+ 	.get_mac_temp       = NULL,
+ 	.get_phy_temp       = aq_fw2x_get_phy_temp,
+ 	.set_power          = aq_fw2x_set_power,
+ 	.set_eee_rate       = aq_fw2x_set_eee_rate,
+ 	.get_eee_rate       = aq_fw2x_get_eee_rate,
+ 	.set_flow_control   = aq_fw2x_set_flow_control,
+ 	.get_flow_control   = aq_fw2x_get_flow_control,
+ 	.send_fw_request    = aq_fw2x_send_fw_request,
+ 	.enable_ptp         = aq_fw3x_enable_ptp,
+ 	.led_control        = aq_fw2x_led_control,
+ 	.set_phyloopback    = aq_fw2x_set_phyloopback,
+ 	.adjust_ptp         = aq_fw3x_adjust_ptp,
+ 	.get_link_capabilities = aq_fw2x_get_link_capabilities,
+ 	.send_macsec_req    = aq_fw2x_send_macsec_req,
++>>>>>>> 8dcf2ad39fdb (net: atlantic: add hwmon getter for MAC temperature)
  };
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_utils_fw.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
index 6da65099047d..d3526cd38f3d 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
@@ -1,5 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0-only
-/* Copyright (C) 2014-2019 aQuantia Corporation. */
+/* Atlantic Network Driver
+ *
+ * Copyright (C) 2014-2019 aQuantia Corporation
+ * Copyright (C) 2019-2020 Marvell International Ltd.
+ */
 
 /* File aq_drvinfo.c: Definition of common code for firmware info in sys.*/
 
@@ -12,32 +16,51 @@
 #include <linux/uaccess.h>
 
 #include "aq_drvinfo.h"
+#include "aq_nic.h"
 
 #if IS_REACHABLE(CONFIG_HWMON)
+static const char * const atl_temp_label[] = {
+	"PHY Temperature",
+	"MAC Temperature",
+};
+
 static int aq_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 			 u32 attr, int channel, long *value)
 {
 	struct aq_nic_s *aq_nic = dev_get_drvdata(dev);
+	int err = 0;
 	int temp;
-	int err;
 
 	if (!aq_nic)
 		return -EIO;
 
-	if (type != hwmon_temp)
+	if (type != hwmon_temp || attr != hwmon_temp_input)
 		return -EOPNOTSUPP;
 
-	if (!aq_nic->aq_fw_ops->get_phy_temp)
-		return -EOPNOTSUPP;
+	switch (channel) {
+	case 0:
+		if (!aq_nic->aq_fw_ops->get_phy_temp)
+			return -EOPNOTSUPP;
 
-	switch (attr) {
-	case hwmon_temp_input:
 		err = aq_nic->aq_fw_ops->get_phy_temp(aq_nic->aq_hw, &temp);
 		*value = temp;
-		return err;
+		break;
+	case 1:
+		if (!aq_nic->aq_fw_ops->get_mac_temp &&
+		    !aq_nic->aq_hw_ops->hw_get_mac_temp)
+			return -EOPNOTSUPP;
+
+		if (aq_nic->aq_fw_ops->get_mac_temp)
+			err = aq_nic->aq_fw_ops->get_mac_temp(aq_nic->aq_hw, &temp);
+		else
+			err = aq_nic->aq_hw_ops->hw_get_mac_temp(aq_nic->aq_hw, &temp);
+		*value = temp;
+		break;
 	default:
 		return -EOPNOTSUPP;
 	}
+
+	return err;
 }
 
 static int aq_hwmon_read_string(struct device *dev,
@@ -49,28 +72,32 @@ static int aq_hwmon_read_string(struct device *dev,
 	if (!aq_nic)
 		return -EIO;
 
-	if (type != hwmon_temp)
+	if (type != hwmon_temp || attr != hwmon_temp_label)
 		return -EOPNOTSUPP;
 
-	if (!aq_nic->aq_fw_ops->get_phy_temp)
+	if (channel < ARRAY_SIZE(atl_temp_label))
+		*str = atl_temp_label[channel];
+	else
 		return -EOPNOTSUPP;
 
-	switch (attr) {
-	case hwmon_temp_label:
-		*str = "PHY Temperature";
-		return 0;
-	default:
-		return -EOPNOTSUPP;
-	}
+	return 0;
 }
 
 static umode_t aq_hwmon_is_visible(const void *data,
 				   enum hwmon_sensor_types type,
 				   u32 attr, int channel)
 {
+	const struct aq_nic_s *nic = data;
+
 	if (type != hwmon_temp)
 		return 0;
 
+	if (channel == 0 && !nic->aq_fw_ops->get_phy_temp)
+		return 0;
+	else if (channel == 1 && !nic->aq_fw_ops->get_mac_temp &&
+		 !nic->aq_hw_ops->hw_get_mac_temp)
+		return 0;
+
 	switch (attr) {
 	case hwmon_temp_input:
 	case hwmon_temp_label:
@@ -87,6 +114,7 @@ static const struct hwmon_ops aq_hwmon_ops = {
 };
 
 static u32 aq_hwmon_temp_config[] = {
+	HWMON_T_INPUT | HWMON_T_LABEL,
 	HWMON_T_INPUT | HWMON_T_LABEL,
 	0,
 };
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.h b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.h
index 23a0487893a7..59113a20622a 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.h
@@ -1,14 +1,16 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
-/* Copyright (C) 2014-2017 aQuantia Corporation. */
+/* Atlantic Network Driver
+ *
+ * Copyright (C) 2014-2019 aQuantia Corporation
+ * Copyright (C) 2019-2020 Marvell International Ltd.
+ */
 
 /* File aq_drvinfo.h: Declaration of common code for firmware info in sys.*/
 
 #ifndef AQ_DRVINFO_H
 #define AQ_DRVINFO_H
 
-#include "aq_nic.h"
-#include "aq_hw.h"
-#include "hw_atl/hw_atl_utils.h"
+struct net_device;
 
 int aq_drvinfo_init(struct net_device *ndev);
 
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_hw.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
index 961b9b69649f..825faa9a98ab 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
@@ -15,6 +15,50 @@
 #include "hw_atl_llh_internal.h"
 #include "../aq_hw_utils.h"
 
+void hw_atl_ts_reset_set(struct aq_hw_s *aq_hw, u32 val)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TS_RESET_ADR,
+			    HW_ATL_TS_RESET_MSK,
+			    HW_ATL_TS_RESET_SHIFT,
+			    val);
+}
+
+void hw_atl_ts_power_down_set(struct aq_hw_s *aq_hw, u32 val)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TS_POWER_DOWN_ADR,
+			    HW_ATL_TS_POWER_DOWN_MSK,
+			    HW_ATL_TS_POWER_DOWN_SHIFT,
+			    val);
+}
+
+u32 hw_atl_ts_power_down_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_TS_POWER_DOWN_ADR,
+				  HW_ATL_TS_POWER_DOWN_MSK,
+				  HW_ATL_TS_POWER_DOWN_SHIFT);
+}
+
+u32 hw_atl_ts_ready_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_TS_READY_ADR,
+				  HW_ATL_TS_READY_MSK,
+				  HW_ATL_TS_READY_SHIFT);
+}
+
+u32 hw_atl_ts_ready_latch_high_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_TS_READY_LATCH_HIGH_ADR,
+				  HW_ATL_TS_READY_LATCH_HIGH_MSK,
+				  HW_ATL_TS_READY_LATCH_HIGH_SHIFT);
+}
+
+u32 hw_atl_ts_data_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_TS_DATA_OUT_ADR,
+				  HW_ATL_TS_DATA_OUT_MSK,
+				  HW_ATL_TS_DATA_OUT_SHIFT);
+}
+
 /* global */
 void hw_atl_reg_glb_cpu_sem_set(struct aq_hw_s *aq_hw, u32 glb_cpu_sem,
 				u32 semaphore)
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
index 1dc201492ec7..e50af3b95f17 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
@@ -18,6 +18,24 @@
 
 struct aq_hw_s;
 
+/* set temperature sense reset */
+void hw_atl_ts_reset_set(struct aq_hw_s *aq_hw, u32 val);
+
+/* set temperature sense power down */
+void hw_atl_ts_power_down_set(struct aq_hw_s *aq_hw, u32 val);
+
+/* get temperature sense power down */
+u32 hw_atl_ts_power_down_get(struct aq_hw_s *aq_hw);
+
+/* get temperature sense ready */
+u32 hw_atl_ts_ready_get(struct aq_hw_s *aq_hw);
+
+/* get temperature sense ready latch high */
+u32 hw_atl_ts_ready_latch_high_get(struct aq_hw_s *aq_hw);
+
+/* get temperature sense data */
+u32 hw_atl_ts_data_get(struct aq_hw_s *aq_hw);
+
 /* global */
 
 /* set global microprocessor semaphore */
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
index 5ddaed96cf74..b18689c05cf0 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
@@ -14,6 +14,36 @@
 #ifndef HW_ATL_LLH_INTERNAL_H
 #define HW_ATL_LLH_INTERNAL_H
 
+/* COM Temperature Sense Reset Bitfield Definitions */
+#define HW_ATL_TS_RESET_ADR 0x00003100
+#define HW_ATL_TS_RESET_MSK 0x00000004
+#define HW_ATL_TS_RESET_SHIFT 2
+#define HW_ATL_TS_RESET_WIDTH 1
+
+/* COM Temperature Sense Power Down Bitfield Definitions */
+#define HW_ATL_TS_POWER_DOWN_ADR 0x00003100
+#define HW_ATL_TS_POWER_DOWN_MSK 0x00000001
+#define HW_ATL_TS_POWER_DOWN_SHIFT 0
+#define HW_ATL_TS_POWER_DOWN_WIDTH 1
+
+/* COM Temperature Sense Ready Bitfield Definitions */
+#define HW_ATL_TS_READY_ADR 0x00003120
+#define HW_ATL_TS_READY_MSK 0x80000000
+#define HW_ATL_TS_READY_SHIFT 31
+#define HW_ATL_TS_READY_WIDTH 1
+
+/*  COM Temperature Sense Ready Latch High Bitfield Definitions */
+#define HW_ATL_TS_READY_LATCH_HIGH_ADR 0x00003120
+#define HW_ATL_TS_READY_LATCH_HIGH_MSK 0x40000000
+#define HW_ATL_TS_READY_LATCH_HIGH_SHIFT 30
+#define HW_ATL_TS_READY_LATCH_HIGH_WIDTH 1
+
+/* COM Temperature Sense Data Out [B:0] Bitfield Definitions */
+#define HW_ATL_TS_DATA_OUT_ADR 0x00003120
+#define HW_ATL_TS_DATA_OUT_MSK 0x00000FFF
+#define HW_ATL_TS_DATA_OUT_SHIFT 0
+#define HW_ATL_TS_DATA_OUT_WIDTH 12
+
 /* global microprocessor semaphore  definitions
  * base address: 0x000003a0
  * parameter: semaphore {s} | stride size 0x4 | range [0, 15]
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 38915aa0fd19..4038bfcd396e 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@ -973,6 +973,7 @@ const struct aq_fw_ops aq_fw_1x_ops = {
 	.set_state = hw_atl_utils_mpi_set_state,
 	.update_link_status = hw_atl_utils_mpi_get_link_status,
 	.update_stats = hw_atl_utils_update_stats,
+	.get_mac_temp = NULL,
 	.get_phy_temp = NULL,
 	.set_power = aq_fw1x_set_power,
 	.set_eee_rate = NULL,
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_utils_fw.c
