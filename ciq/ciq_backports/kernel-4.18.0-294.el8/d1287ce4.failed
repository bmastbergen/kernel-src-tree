net: atlantic: adding ethtool physical identification

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Nikita Danilov <ndanilov@marvell.com>
commit d1287ce4ffa1d1f121571ce90ed7ebd410e31a21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d1287ce4.failed

`ethtool -p eth0` will blink leds helping identify
physical port.

	Signed-off-by: Nikita Danilov <ndanilov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d1287ce4ffa1d1f121571ce90ed7ebd410e31a21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_hw.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 5c8995ae94b5,c2725a58f050..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@@ -118,6 -117,11 +118,14 @@@ struct aq_stats_s 
  #define AQ_HW_TXD_MULTIPLE 8U
  #define AQ_HW_RXD_MULTIPLE 8U
  
++<<<<<<< HEAD
++=======
+ #define AQ_HW_MULTICAST_ADDRESS_MAX     32U
+ 
+ #define AQ_HW_LED_BLINK    0x2U
+ #define AQ_HW_LED_DEFAULT  0x0U
+ 
++>>>>>>> d1287ce4ffa1 (net: atlantic: adding ethtool physical identification)
  struct aq_hw_s {
  	atomic_t flags;
  	u8 rbl_enabled:1;
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 3fc41da39a0a,fc82ede18b20..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@@ -967,4 -968,7 +967,10 @@@ const struct aq_fw_ops aq_fw_1x_ops = 
  	.set_eee_rate = NULL,
  	.get_eee_rate = NULL,
  	.set_flow_control = NULL,
++<<<<<<< HEAD
++=======
+ 	.send_fw_request = NULL,
+ 	.enable_ptp = NULL,
+ 	.led_control = NULL,
++>>>>>>> d1287ce4ffa1 (net: atlantic: adding ethtool physical identification)
  };
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
index 103608a7664f,4eab51b5b400..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
@@@ -20,14 -17,18 +20,19 @@@
  #include "hw_atl_utils.h"
  #include "hw_atl_llh.h"
  
++<<<<<<< HEAD
 +#define HW_ATL_FW2X_MPI_RPC_ADDR        0x334
++=======
+ #define HW_ATL_FW2X_MPI_LED_ADDR         0x31c
+ #define HW_ATL_FW2X_MPI_RPC_ADDR         0x334
++>>>>>>> d1287ce4ffa1 (net: atlantic: adding ethtool physical identification)
  
 -#define HW_ATL_FW2X_MPI_MBOX_ADDR        0x360
 -#define HW_ATL_FW2X_MPI_EFUSE_ADDR       0x364
 -#define HW_ATL_FW2X_MPI_CONTROL_ADDR     0x368
 -#define HW_ATL_FW2X_MPI_CONTROL2_ADDR    0x36C
 -#define HW_ATL_FW2X_MPI_STATE_ADDR       0x370
 -#define HW_ATL_FW2X_MPI_STATE2_ADDR      0x374
 -
 -#define HW_ATL_FW3X_EXT_CONTROL_ADDR     0x378
 -#define HW_ATL_FW3X_EXT_STATE_ADDR       0x37c
 +#define HW_ATL_FW2X_MPI_MBOX_ADDR       0x360
 +#define HW_ATL_FW2X_MPI_EFUSE_ADDR	0x364
 +#define HW_ATL_FW2X_MPI_CONTROL_ADDR	0x368
 +#define HW_ATL_FW2X_MPI_CONTROL2_ADDR	0x36C
 +#define HW_ATL_FW2X_MPI_STATE_ADDR	0x370
 +#define HW_ATL_FW2X_MPI_STATE2_ADDR     0x374
  
  #define HW_ATL_FW2X_CAP_PAUSE            BIT(CAPS_HI_PAUSE)
  #define HW_ATL_FW2X_CAP_ASYM_PAUSE       BIT(CAPS_HI_ASYMMETRIC_PAUSE)
@@@ -431,22 -439,30 +438,49 @@@ err_exit
  	return err;
  }
  
 +static int aq_fw2x_set_power(struct aq_hw_s *self, unsigned int power_state,
 +			     u8 *mac)
 +{
 +	int err = 0;
 +
 +	if (self->aq_nic_cfg->wol & AQ_NIC_WOL_ENABLED) {
 +		err = aq_fw2x_set_sleep_proxy(self, mac);
 +		if (err < 0)
 +			goto err_exit;
 +		err = aq_fw2x_set_wol_params(self, mac);
 +	}
 +
 +err_exit:
 +	return err;
 +}
 +
++<<<<<<< HEAD
++=======
+ static void aq_fw3x_enable_ptp(struct aq_hw_s *self, int enable)
+ {
+ 	u32 ptp_opts = aq_hw_read_reg(self, HW_ATL_FW3X_EXT_STATE_ADDR);
+ 	u32 all_ptp_features = BIT(CAPS_EX_PHY_PTP_EN) |
+ 						   BIT(CAPS_EX_PTP_GPIO_EN);
+ 
+ 	if (enable)
+ 		ptp_opts |= all_ptp_features;
+ 	else
+ 		ptp_opts &= ~all_ptp_features;
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW3X_EXT_CONTROL_ADDR, ptp_opts);
+ }
+ 
+ static int aq_fw2x_led_control(struct aq_hw_s *self, u32 mode)
+ {
+ 	if (self->fw_ver_actual < HW_ATL_FW_VER_LED)
+ 		return -EOPNOTSUPP;
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_LED_ADDR, mode);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d1287ce4ffa1 (net: atlantic: adding ethtool physical identification)
  static int aq_fw2x_set_eee_rate(struct aq_hw_s *self, u32 speed)
  {
  	u32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
@@@ -537,19 -553,22 +571,32 @@@ static u32 aq_fw2x_state2_get(struct aq
  }
  
  const struct aq_fw_ops aq_fw_2x_ops = {
 -	.init               = aq_fw2x_init,
 -	.deinit             = aq_fw2x_deinit,
 -	.reset              = NULL,
 -	.renegotiate        = aq_fw2x_renegotiate,
 -	.get_mac_permanent  = aq_fw2x_get_mac_permanent,
 -	.set_link_speed     = aq_fw2x_set_link_speed,
 -	.set_state          = aq_fw2x_set_state,
 +	.init = aq_fw2x_init,
 +	.deinit = aq_fw2x_deinit,
 +	.reset = NULL,
 +	.renegotiate = aq_fw2x_renegotiate,
 +	.get_mac_permanent = aq_fw2x_get_mac_permanent,
 +	.set_link_speed = aq_fw2x_set_link_speed,
 +	.set_state = aq_fw2x_set_state,
  	.update_link_status = aq_fw2x_update_link_status,
++<<<<<<< HEAD
 +	.update_stats = aq_fw2x_update_stats,
 +	.get_phy_temp = aq_fw2x_get_phy_temp,
 +	.set_power = aq_fw2x_set_power,
 +	.set_eee_rate = aq_fw2x_set_eee_rate,
 +	.get_eee_rate = aq_fw2x_get_eee_rate,
 +	.set_flow_control = aq_fw2x_set_flow_control,
 +	.get_flow_control = aq_fw2x_get_flow_control
++=======
+ 	.update_stats       = aq_fw2x_update_stats,
+ 	.get_phy_temp       = aq_fw2x_get_phy_temp,
+ 	.set_power          = aq_fw2x_set_power,
+ 	.set_eee_rate       = aq_fw2x_set_eee_rate,
+ 	.get_eee_rate       = aq_fw2x_get_eee_rate,
+ 	.set_flow_control   = aq_fw2x_set_flow_control,
+ 	.get_flow_control   = aq_fw2x_get_flow_control,
+ 	.send_fw_request    = aq_fw2x_send_fw_request,
+ 	.enable_ptp         = aq_fw3x_enable_ptp,
+ 	.led_control        = aq_fw2x_led_control,
++>>>>>>> d1287ce4ffa1 (net: atlantic: adding ethtool physical identification)
  };
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
index 3b9a73191efa..2d2eebd4bde8 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
@@ -153,6 +153,35 @@ static void aq_ethtool_get_strings(struct net_device *ndev,
 	}
 }
 
+static int aq_ethtool_set_phys_id(struct net_device *ndev,
+				  enum ethtool_phys_id_state state)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_hw_s *hw = aq_nic->aq_hw;
+	int ret = 0;
+
+	if (!aq_nic->aq_fw_ops->led_control)
+		return -EOPNOTSUPP;
+
+	mutex_lock(&aq_nic->fwreq_mutex);
+
+	switch (state) {
+	case ETHTOOL_ID_ACTIVE:
+		ret = aq_nic->aq_fw_ops->led_control(hw, AQ_HW_LED_BLINK |
+				 AQ_HW_LED_BLINK << 2 | AQ_HW_LED_BLINK << 4);
+		break;
+	case ETHTOOL_ID_INACTIVE:
+		ret = aq_nic->aq_fw_ops->led_control(hw, AQ_HW_LED_DEFAULT);
+		break;
+	default:
+		break;
+	}
+
+	mutex_unlock(&aq_nic->fwreq_mutex);
+
+	return ret;
+}
+
 static int aq_ethtool_get_sset_count(struct net_device *ndev, int stringset)
 {
 	int ret = 0;
@@ -600,6 +629,7 @@ const struct ethtool_ops aq_ethtool_ops = {
 	.get_regs            = aq_ethtool_get_regs,
 	.get_drvinfo         = aq_ethtool_get_drvinfo,
 	.get_strings         = aq_ethtool_get_strings,
+	.set_phys_id         = aq_ethtool_set_phys_id,
 	.get_rxfh_indir_size = aq_ethtool_get_rss_indir_size,
 	.get_wol             = aq_ethtool_get_wol,
 	.set_wol             = aq_ethtool_set_wol,
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_hw.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
