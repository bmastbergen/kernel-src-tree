nvme-tcp: avoid repeated request completion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 0a8a2c85b83589a5c10bc5564b796836bf4b4984
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0a8a2c85.failed

The request may be executed asynchronously, and rq->state may be
changed to IDLE. To avoid repeated request completion, only
MQ_RQ_COMPLETE of rq->state is checked in nvme_tcp_complete_timed_out.
It is not safe, so need adding check IDLE for rq->state.

	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Chao Leng <lengchao@huawei.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 0a8a2c85b83589a5c10bc5564b796836bf4b4984)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/tcp.c
diff --cc drivers/nvme/host/tcp.c
index bf1c3e2bb6ff,c0c33320fe65..000000000000
--- a/drivers/nvme/host/tcp.c
+++ b/drivers/nvme/host/tcp.c
@@@ -2187,6 -2162,18 +2187,21 @@@ static void nvme_tcp_submit_async_event
  	nvme_tcp_queue_request(&ctrl->async_req, true, true);
  }
  
++<<<<<<< HEAD
++=======
+ static void nvme_tcp_complete_timed_out(struct request *rq)
+ {
+ 	struct nvme_tcp_request *req = blk_mq_rq_to_pdu(rq);
+ 	struct nvme_ctrl *ctrl = &req->queue->ctrl->ctrl;
+ 
+ 	nvme_tcp_stop_queue(ctrl, nvme_tcp_queue_id(req->queue));
+ 	if (blk_mq_request_started(rq) && !blk_mq_request_completed(rq)) {
+ 		nvme_req(rq)->status = NVME_SC_HOST_ABORTED_CMD;
+ 		blk_mq_complete_request(rq);
+ 	}
+ }
+ 
++>>>>>>> 0a8a2c85b835 (nvme-tcp: avoid repeated request completion)
  static enum blk_eh_timer_return
  nvme_tcp_timeout(struct request *rq, bool reserved)
  {
* Unmerged path drivers/nvme/host/tcp.c
