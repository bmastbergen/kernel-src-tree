s390/qeth: don't use restricted offloads for local traffic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit c619e9a6f52f87b405053edc5abb55d3e36a8e7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c619e9a6.failed

Current OSA models don't support TSO for traffic to local next-hops, and
some old models didn't offer TX CSO for such packets either.

So as part of .ndo_features_check, check if a packet's next-hop resides
on the same OSA Adapter. Opt out from affected HW offloads accordingly.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c619e9a6f52f87b405053edc5abb55d3e36a8e7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index bbfd33ac1bd5,1f18b38047a0..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -816,6 -806,76 +816,79 @@@ static void qeth_del_local_addrs6(struc
  	spin_unlock(&card->local_addrs6_lock);
  }
  
++<<<<<<< HEAD
++=======
+ static bool qeth_next_hop_is_local_v4(struct qeth_card *card,
+ 				      struct sk_buff *skb)
+ {
+ 	struct qeth_local_addr *tmp;
+ 	bool is_local = false;
+ 	unsigned int key;
+ 	__be32 next_hop;
+ 
+ 	if (hash_empty(card->local_addrs4))
+ 		return false;
+ 
+ 	rcu_read_lock();
+ 	next_hop = qeth_next_hop_v4_rcu(skb, qeth_dst_check_rcu(skb, 4));
+ 	key = ipv4_addr_hash(next_hop);
+ 
+ 	hash_for_each_possible_rcu(card->local_addrs4, tmp, hnode, key) {
+ 		if (tmp->addr.s6_addr32[3] == next_hop) {
+ 			is_local = true;
+ 			break;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return is_local;
+ }
+ 
+ static bool qeth_next_hop_is_local_v6(struct qeth_card *card,
+ 				      struct sk_buff *skb)
+ {
+ 	struct qeth_local_addr *tmp;
+ 	struct in6_addr *next_hop;
+ 	bool is_local = false;
+ 	u32 key;
+ 
+ 	if (hash_empty(card->local_addrs6))
+ 		return false;
+ 
+ 	rcu_read_lock();
+ 	next_hop = qeth_next_hop_v6_rcu(skb, qeth_dst_check_rcu(skb, 6));
+ 	key = ipv6_addr_hash(next_hop);
+ 
+ 	hash_for_each_possible_rcu(card->local_addrs6, tmp, hnode, key) {
+ 		if (ipv6_addr_equal(&tmp->addr, next_hop)) {
+ 			is_local = true;
+ 			break;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return is_local;
+ }
+ 
+ static int qeth_debugfs_local_addr_show(struct seq_file *m, void *v)
+ {
+ 	struct qeth_card *card = m->private;
+ 	struct qeth_local_addr *tmp;
+ 	unsigned int i;
+ 
+ 	rcu_read_lock();
+ 	hash_for_each_rcu(card->local_addrs4, i, tmp, hnode)
+ 		seq_printf(m, "%pI4\n", &tmp->addr.s6_addr32[3]);
+ 	hash_for_each_rcu(card->local_addrs6, i, tmp, hnode)
+ 		seq_printf(m, "%pI6c\n", &tmp->addr);
+ 	rcu_read_unlock();
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_SHOW_ATTRIBUTE(qeth_debugfs_local_addr);
+ 
++>>>>>>> c619e9a6f52f (s390/qeth: don't use restricted offloads for local traffic)
  static void qeth_issue_ipa_msg(struct qeth_ipa_cmd *cmd, int rc,
  		struct qeth_card *card)
  {
* Unmerged path drivers/s390/net/qeth_core_main.c
diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c
index 2d1ba3fc4c4c..32e910791698 100644
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -751,6 +751,7 @@ static int qeth_l2_setup_netdev(struct qeth_card *card)
 
 	if (card->dev->hw_features & (NETIF_F_TSO | NETIF_F_TSO6)) {
 		card->dev->needed_headroom = sizeof(struct qeth_hdr_tso);
+		netif_keep_dst(card->dev);
 		netif_set_gso_max_size(card->dev,
 				       PAGE_SIZE * (QDIO_MAX_ELEMENTS_PER_BUFFER - 1));
 	}
