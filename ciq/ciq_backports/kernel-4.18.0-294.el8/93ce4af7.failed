NFS: Clean up process of marking inode stale.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [fs] NFS: Clean up process of marking inode stale (Scott Mayhew) [1872310]
Rebuild_FUZZ: 98.88%
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 93ce4af774bc3d8a72ce2271d03241c96383629d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/93ce4af7.failed

Instead of the various open coded calls to set the NFS_INO_STALE bit
and call nfs_zap_caches(), consolidate them into a single function
nfs_set_inode_stale().

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 93ce4af774bc3d8a72ce2271d03241c96383629d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/inode.c
diff --cc fs/nfs/inode.c
index 0c07687e5465,b9d0921cb4fe..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -1155,10 -1163,17 +1162,22 @@@ __nfs_revalidate_inode(struct nfs_serve
  		dfprintk(PAGECACHE, "nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\n",
  			 inode->i_sb->s_id,
  			 (unsigned long long)NFS_FILEID(inode), status);
++<<<<<<< HEAD
 +		if (status == -ESTALE) {
 +			nfs_zap_caches(inode);
++=======
+ 		switch (status) {
+ 		case -ETIMEDOUT:
+ 			/* A soft timeout occurred. Use cached information? */
+ 			if (server->flags & NFS_MOUNT_SOFTREVAL)
+ 				status = 0;
+ 			break;
+ 		case -ESTALE:
++>>>>>>> 93ce4af774bc (NFS: Clean up process of marking inode stale.)
  			if (!S_ISDIR(inode->i_mode))
- 				set_bit(NFS_INO_STALE, &NFS_I(inode)->flags);
+ 				nfs_set_inode_stale(inode);
+ 			else
+ 				nfs_zap_caches(inode);
  		}
  		goto err_out;
  	}
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index abd8dc43875a..70a923ad6028 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -2659,9 +2659,10 @@ static int nfs_do_access(struct inode *inode, const struct cred *cred, int mask)
 	status = NFS_PROTO(inode)->access(inode, &cache);
 	if (status != 0) {
 		if (status == -ESTALE) {
-			nfs_zap_caches(inode);
 			if (!S_ISDIR(inode->i_mode))
-				set_bit(NFS_INO_STALE, &NFS_I(inode)->flags);
+				nfs_set_inode_stale(inode);
+			else
+				nfs_zap_caches(inode);
 		}
 		goto out;
 	}
* Unmerged path fs/nfs/inode.c
diff --git a/fs/nfs/nfstrace.h b/fs/nfs/nfstrace.h
index 6355f871ecb0..d8a288a9a3d6 100644
--- a/fs/nfs/nfstrace.h
+++ b/fs/nfs/nfstrace.h
@@ -139,6 +139,7 @@ DECLARE_EVENT_CLASS(nfs_inode_event_done,
 				int error \
 			), \
 			TP_ARGS(inode, error))
+DEFINE_NFS_INODE_EVENT(nfs_set_inode_stale);
 DEFINE_NFS_INODE_EVENT(nfs_refresh_inode_enter);
 DEFINE_NFS_INODE_EVENT_DONE(nfs_refresh_inode_exit);
 DEFINE_NFS_INODE_EVENT(nfs_revalidate_inode_enter);
diff --git a/fs/nfs/read.c b/fs/nfs/read.c
index 5ab5f2e3471b..5662c9c10bf0 100644
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@ -249,7 +249,7 @@ static int nfs_readpage_done(struct rpc_task *task,
 	trace_nfs_readpage_done(task, hdr);
 
 	if (task->tk_status == -ESTALE) {
-		set_bit(NFS_INO_STALE, &NFS_I(inode)->flags);
+		nfs_set_inode_stale(inode);
 		nfs_mark_for_revalidate(inode);
 	}
 	return 0;
diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
index 2346cf1097b1..3b0b6ea99a6f 100644
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -352,6 +352,7 @@ static inline unsigned long nfs_save_change_attribute(struct inode *dir)
 extern int nfs_sync_mapping(struct address_space *mapping);
 extern void nfs_zap_mapping(struct inode *inode, struct address_space *mapping);
 extern void nfs_zap_caches(struct inode *);
+extern void nfs_set_inode_stale(struct inode *inode);
 extern void nfs_invalidate_atime(struct inode *);
 extern struct inode *nfs_fhget(struct super_block *, struct nfs_fh *,
 				struct nfs_fattr *, struct nfs4_label *);
