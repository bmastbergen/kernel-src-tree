cgroup_do_mount(): massage calling conventions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 71d883c37e8d4484207708af56685abb39703b04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/71d883c3.failed

pass it fs_context instead of fs_type/flags/root triple, have
it return int instead of dentry and make it deal with setting
fc->root.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 71d883c37e8d4484207708af56685abb39703b04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cgroup/cgroup-v1.c
#	kernel/cgroup/cgroup.c
diff --cc kernel/cgroup/cgroup-v1.c
index dd94e2a4c22e,05f05d773adf..000000000000
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@@ -1079,16 -1135,18 +1079,15 @@@ struct kernfs_syscall_ops cgroup1_kf_sy
  	.show_path		= cgroup_show_path,
  };
  
 -int cgroup1_get_tree(struct fs_context *fc)
 +struct dentry *cgroup1_mount(struct file_system_type *fs_type, int flags,
 +			     void *data, unsigned long magic,
 +			     struct cgroup_namespace *ns)
  {
 -	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 +	struct cgroup_sb_opts opts;
  	struct cgroup_root *root;
  	struct cgroup_subsys *ss;
- 	struct dentry *dentry;
  	int i, ret;
  
 -	/* Check if the caller has permission to mount. */
 -	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
 -		return -EPERM;
 -
  	cgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);
  
  	/* First find the desired set of subsystems */
@@@ -1190,23 -1249,18 +1189,34 @@@ out_unlock
  	}
  	mutex_unlock(&cgroup_mutex);
  out_free:
 +	kfree(opts.release_agent);
 +	kfree(opts.name);
 +
  	if (ret)
 -		return ret;
 +		return ERR_PTR(ret);
 +
++<<<<<<< HEAD
 +	dentry = cgroup_do_mount(&cgroup_fs_type, flags, root,
 +				 CGROUP_SUPER_MAGIC, ns);
  
 +	if (!IS_ERR(dentry) && percpu_ref_is_dying(&root->cgrp.self.refcnt)) {
 +		struct super_block *sb = dentry->d_sb;
 +		dput(dentry);
++=======
+ 	ret = cgroup_do_mount(fc, CGROUP_SUPER_MAGIC, ns);
+ 	if (!ret && percpu_ref_is_dying(&root->cgrp.self.refcnt)) {
+ 		struct super_block *sb = fc->root->d_sb;
+ 		dput(fc->root);
++>>>>>>> 71d883c37e8d (cgroup_do_mount(): massage calling conventions)
  		deactivate_locked_super(sb);
  		msleep(10);
 -		return restart_syscall();
 +		dentry = ERR_PTR(restart_syscall());
  	}
++<<<<<<< HEAD
 +	return dentry;
++=======
+ 	return ret;
++>>>>>>> 71d883c37e8d (cgroup_do_mount(): massage calling conventions)
  }
  
  static int __init cgroup1_wq_init(void)
diff --cc kernel/cgroup/cgroup.c
index 9e08519ae6db,64360a46d4df..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -2045,50 -2075,81 +2050,102 @@@ int cgroup_do_mount(struct fs_context *
  	}
  
  	if (!new_sb)
- 		cgroup_put(&root->cgrp);
+ 		cgroup_put(&ctx->root->cgrp);
  
- 	return dentry;
+ 	return ret;
  }
  
 -/*
 - * Destroy a cgroup filesystem context.
 - */
 -static void cgroup_fs_context_free(struct fs_context *fc)
 -{
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 -
 -	kfree(ctx->name);
 -	kfree(ctx->release_agent);
 -	kfree(ctx);
 -}
 -
 -static int cgroup_get_tree(struct fs_context *fc)
 +static struct dentry *cgroup_mount(struct file_system_type *fs_type,
 +			 int flags, const char *unused_dev_name,
 +			 void *data)
  {
  	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
++<<<<<<< HEAD
 +	struct dentry *dentry;
 +	int ret;
 +
 +	get_cgroup_ns(ns);
++=======
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 	int ret;
++>>>>>>> 71d883c37e8d (cgroup_do_mount(): massage calling conventions)
  
  	/* Check if the caller has permission to mount. */
 -	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
 -		return -EPERM;
 +	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN)) {
 +		put_cgroup_ns(ns);
 +		return ERR_PTR(-EPERM);
 +	}
  
 -	cgrp_dfl_visible = true;
 -	cgroup_get_live(&cgrp_dfl_root.cgrp);
 -	ctx->root = &cgrp_dfl_root;
 +	if (fs_type == &cgroup2_fs_type) {
 +		unsigned int root_flags;
  
++<<<<<<< HEAD
 +		ret = parse_cgroup_root_flags(data, &root_flags);
 +		if (ret) {
 +			put_cgroup_ns(ns);
 +			return ERR_PTR(ret);
 +		}
 +
 +		cgrp_dfl_visible = true;
 +		cgroup_get_live(&cgrp_dfl_root.cgrp);
 +
 +		dentry = cgroup_do_mount(&cgroup2_fs_type, flags, &cgrp_dfl_root,
 +					 CGROUP2_SUPER_MAGIC, ns);
 +		if (!IS_ERR(dentry))
 +			apply_cgroup_root_flags(root_flags);
 +	} else {
 +		dentry = cgroup1_mount(&cgroup_fs_type, flags, data,
 +				       CGROUP_SUPER_MAGIC, ns);
 +	}
 +
 +	put_cgroup_ns(ns);
 +	return dentry;
++=======
+ 	ret = cgroup_do_mount(fc, CGROUP2_SUPER_MAGIC, ns);
+ 	if (!ret)
+ 		apply_cgroup_root_flags(ctx->flags);
+ 	return ret;
+ }
+ 
+ static const struct fs_context_operations cgroup_fs_context_ops = {
+ 	.free		= cgroup_fs_context_free,
+ 	.parse_param	= cgroup2_parse_param,
+ 	.get_tree	= cgroup_get_tree,
+ 	.reconfigure	= cgroup_reconfigure,
+ };
+ 
+ static const struct fs_context_operations cgroup1_fs_context_ops = {
+ 	.free		= cgroup_fs_context_free,
+ 	.parse_param	= cgroup1_parse_param,
+ 	.get_tree	= cgroup1_get_tree,
+ 	.reconfigure	= cgroup1_reconfigure,
+ };
+ 
+ /*
+  * Initialise the cgroup filesystem creation/reconfiguration context.
+  */
+ static int cgroup_init_fs_context(struct fs_context *fc)
+ {
+ 	struct cgroup_fs_context *ctx;
+ 
+ 	ctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * The first time anyone tries to mount a cgroup, enable the list
+ 	 * linking each css_set to its tasks and fix up all existing tasks.
+ 	 */
+ 	if (!use_task_css_set_links)
+ 		cgroup_enable_task_cg_lists();
+ 
+ 	fc->fs_private = ctx;
+ 	if (fc->fs_type == &cgroup2_fs_type)
+ 		fc->ops = &cgroup_fs_context_ops;
+ 	else
+ 		fc->ops = &cgroup1_fs_context_ops;
+ 	return 0;
++>>>>>>> 71d883c37e8d (cgroup_do_mount(): massage calling conventions)
  }
  
  static void cgroup_kill_sb(struct super_block *sb)
diff --git a/kernel/cgroup/cgroup-internal.h b/kernel/cgroup/cgroup-internal.h
index ce1c1553c696..8fa954c725f3 100644
--- a/kernel/cgroup/cgroup-internal.h
+++ b/kernel/cgroup/cgroup-internal.h
@@ -203,8 +203,7 @@ void cgroup_free_root(struct cgroup_root *root);
 void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts);
 int cgroup_setup_root(struct cgroup_root *root, u16 ss_mask);
 int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask);
-struct dentry *cgroup_do_mount(struct file_system_type *fs_type, int flags,
-			       struct cgroup_root *root, unsigned long magic,
+int cgroup_do_mount(struct fs_context *fc, unsigned long magic,
 			       struct cgroup_namespace *ns);
 
 int cgroup_migrate_vet_dst(struct cgroup *dst_cgrp);
* Unmerged path kernel/cgroup/cgroup-v1.c
* Unmerged path kernel/cgroup/cgroup.c
