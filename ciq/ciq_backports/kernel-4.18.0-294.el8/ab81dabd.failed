fix sysfs_init_fs_context() in !CONFIG_NET_NS case

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit ab81dabda1d4edc1728173be6c6a279455f220e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ab81dabd.failed

Permission checks on current's netns should be done only when
netns are enabled.

	Reported-by: Dominik Brodowski <linux@dominikbrodowski.net>
Fixes: 23bf1b6be9c2
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit ab81dabda1d4edc1728173be6c6a279455f220e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/mount.c
diff --cc fs/sysfs/mount.c
index 92682fcc41f6,1b56686ab178..000000000000
--- a/fs/sysfs/mount.c
+++ b/fs/sysfs/mount.c
@@@ -20,27 -23,61 +20,42 @@@
  static struct kernfs_root *sysfs_root;
  struct kernfs_node *sysfs_root_kn;
  
 -static int sysfs_get_tree(struct fs_context *fc)
 +static struct dentry *sysfs_mount(struct file_system_type *fs_type,
 +	int flags, const char *dev_name, void *data)
  {
 -	struct kernfs_fs_context *kfc = fc->fs_private;
 -	int ret;
 +	struct dentry *root;
 +	void *ns;
 +	bool new_sb = false;
  
 -	ret = kernfs_get_tree(fc);
 -	if (ret)
 -		return ret;
 -
 -	if (kfc->new_sb_created)
 -		fc->root->d_sb->s_iflags |= SB_I_USERNS_VISIBLE;
 -	return 0;
 -}
 -
 -static void sysfs_fs_context_free(struct fs_context *fc)
 -{
 -	struct kernfs_fs_context *kfc = fc->fs_private;
 -
 -	if (kfc->ns_tag)
 -		kobj_ns_drop(KOBJ_NS_TYPE_NET, kfc->ns_tag);
 -	kernfs_free_fs_context(fc);
 -	kfree(kfc);
 -}
 -
 -static const struct fs_context_operations sysfs_fs_context_ops = {
 -	.free		= sysfs_fs_context_free,
 -	.get_tree	= sysfs_get_tree,
 -};
 -
 -static int sysfs_init_fs_context(struct fs_context *fc)
 -{
 -	struct kernfs_fs_context *kfc;
 -	struct net *netns;
 -
 -	if (!(fc->sb_flags & SB_KERNMOUNT)) {
 +	if (!(flags & SB_KERNMOUNT)) {
  		if (!kobj_ns_current_may_mount(KOBJ_NS_TYPE_NET))
 -			return -EPERM;
 +			return ERR_PTR(-EPERM);
  	}
  
 -	kfc = kzalloc(sizeof(struct kernfs_fs_context), GFP_KERNEL);
 -	if (!kfc)
 -		return -ENOMEM;
 -
 +	ns = kobj_ns_grab_current(KOBJ_NS_TYPE_NET);
 +	root = kernfs_mount_ns(fs_type, flags, sysfs_root,
 +				SYSFS_MAGIC, &new_sb, ns);
 +	if (!new_sb)
 +		kobj_ns_drop(KOBJ_NS_TYPE_NET, ns);
 +	else if (!IS_ERR(root))
 +		root->d_sb->s_iflags |= SB_I_USERNS_VISIBLE;
 +
++<<<<<<< HEAD
 +	return root;
++=======
+ 	kfc->ns_tag = netns = kobj_ns_grab_current(KOBJ_NS_TYPE_NET);
+ 	kfc->root = sysfs_root;
+ 	kfc->magic = SYSFS_MAGIC;
+ 	fc->fs_private = kfc;
+ 	fc->ops = &sysfs_fs_context_ops;
+ 	if (netns) {
+ 		if (fc->user_ns)
+ 			put_user_ns(fc->user_ns);
+ 		fc->user_ns = get_user_ns(netns->user_ns);
+ 	}
+ 	fc->global = true;
+ 	return 0;
++>>>>>>> ab81dabda1d4 (fix sysfs_init_fs_context() in !CONFIG_NET_NS case)
  }
  
  static void sysfs_kill_sb(struct super_block *sb)
* Unmerged path fs/sysfs/mount.c
