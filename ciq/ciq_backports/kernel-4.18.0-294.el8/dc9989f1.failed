net: phy: bcm54140: use phy_package_shared

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michael Walle <michael@walle.cc>
commit dc9989f173289f376d06cb289ae0bd46c6ac8017
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dc9989f1.failed

Use the new phy_package_shared common storage to ease the package
initialization and to access the global registers.

	Signed-off-by: Michael Walle <michael@walle.cc>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dc9989f173289f376d06cb289ae0bd46c6ac8017)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/bcm54140.c
diff --cc drivers/net/phy/bcm54140.c
index 72bf4d45c10b,9ef37a3bc2bb..000000000000
--- a/drivers/net/phy/bcm54140.c
+++ b/drivers/net/phy/bcm54140.c
@@@ -67,16 -131,305 +67,310 @@@
  struct bcm54140_priv {
  	int port;
  	int base_addr;
++<<<<<<< HEAD
 +};
 +
- static int bcm54140_base_read_rdb(struct phy_device *phydev, u16 rdb)
++=======
+ #if IS_ENABLED(CONFIG_HWMON)
+ 	/* protect the alarm bits */
+ 	struct mutex alarm_lock;
+ 	u16 alarm;
+ #endif
+ };
+ 
+ #if IS_ENABLED(CONFIG_HWMON)
+ static umode_t bcm54140_hwmon_is_visible(const void *data,
+ 					 enum hwmon_sensor_types type,
+ 					 u32 attr, int channel)
+ {
+ 	switch (type) {
+ 	case hwmon_in:
+ 		switch (attr) {
+ 		case hwmon_in_min:
+ 		case hwmon_in_max:
+ 			return 0644;
+ 		case hwmon_in_label:
+ 		case hwmon_in_input:
+ 		case hwmon_in_alarm:
+ 			return 0444;
+ 		default:
+ 			return 0;
+ 		}
+ 	case hwmon_temp:
+ 		switch (attr) {
+ 		case hwmon_temp_min:
+ 		case hwmon_temp_max:
+ 			return 0644;
+ 		case hwmon_temp_input:
+ 		case hwmon_temp_alarm:
+ 			return 0444;
+ 		default:
+ 			return 0;
+ 		}
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static int bcm54140_hwmon_read_alarm(struct device *dev, unsigned int bit,
+ 				     long *val)
  {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
  	struct bcm54140_priv *priv = phydev->priv;
- 	struct mii_bus *bus = phydev->mdio.bus;
+ 	int tmp, ret = 0;
+ 
+ 	mutex_lock(&priv->alarm_lock);
+ 
+ 	/* latch any alarm bits */
+ 	tmp = bcm_phy_read_rdb(phydev, BCM54140_RDB_MON_ISR);
+ 	if (tmp < 0) {
+ 		ret = tmp;
+ 		goto out;
+ 	}
+ 	priv->alarm |= tmp;
+ 
+ 	*val = !!(priv->alarm & bit);
+ 	priv->alarm &= ~bit;
+ 
+ out:
+ 	mutex_unlock(&priv->alarm_lock);
+ 	return ret;
+ }
+ 
+ static int bcm54140_hwmon_read_temp(struct device *dev, u32 attr, long *val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	u16 reg;
+ 	int tmp;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_input:
+ 		reg = BCM54140_RDB_MON_TEMP_VAL;
+ 		break;
+ 	case hwmon_temp_min:
+ 		reg = BCM54140_RDB_MON_TEMP_MIN;
+ 		break;
+ 	case hwmon_temp_max:
+ 		reg = BCM54140_RDB_MON_TEMP_MAX;
+ 		break;
+ 	case hwmon_temp_alarm:
+ 		return bcm54140_hwmon_read_alarm(dev,
+ 						 BCM54140_RDB_MON_ISR_TEMP,
+ 						 val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	tmp = bcm_phy_read_rdb(phydev, reg);
+ 	if (tmp < 0)
+ 		return tmp;
+ 
+ 	*val = BCM54140_HWMON_TO_TEMP(tmp & BCM54140_RDB_MON_TEMP_DATA_MASK);
+ 
+ 	return 0;
+ }
+ 
+ static int bcm54140_hwmon_read_in(struct device *dev, u32 attr,
+ 				  int channel, long *val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	u16 bit, reg;
+ 	int tmp;
+ 
+ 	switch (attr) {
+ 	case hwmon_in_input:
+ 		reg = BCM54140_HWMON_IN_VAL_REG(channel);
+ 		break;
+ 	case hwmon_in_min:
+ 		reg = BCM54140_HWMON_IN_MIN_REG(channel);
+ 		break;
+ 	case hwmon_in_max:
+ 		reg = BCM54140_HWMON_IN_MAX_REG(channel);
+ 		break;
+ 	case hwmon_in_alarm:
+ 		bit = BCM54140_HWMON_IN_ALARM_BIT(channel);
+ 		return bcm54140_hwmon_read_alarm(dev, bit, val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	tmp = bcm_phy_read_rdb(phydev, reg);
+ 	if (tmp < 0)
+ 		return tmp;
+ 
+ 	tmp &= BCM54140_HWMON_IN_MASK(channel);
+ 	*val = BCM54140_HWMON_TO_IN(channel, tmp);
+ 
+ 	return 0;
+ }
+ 
+ static int bcm54140_hwmon_read(struct device *dev,
+ 			       enum hwmon_sensor_types type, u32 attr,
+ 			       int channel, long *val)
+ {
+ 	switch (type) {
+ 	case hwmon_temp:
+ 		return bcm54140_hwmon_read_temp(dev, attr, val);
+ 	case hwmon_in:
+ 		return bcm54140_hwmon_read_in(dev, attr, channel, val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static const char *const bcm54140_hwmon_in_labels[] = {
+ 	"AVDDL",
+ 	"AVDDH",
+ };
+ 
+ static int bcm54140_hwmon_read_string(struct device *dev,
+ 				      enum hwmon_sensor_types type, u32 attr,
+ 				      int channel, const char **str)
+ {
+ 	switch (type) {
+ 	case hwmon_in:
+ 		switch (attr) {
+ 		case hwmon_in_label:
+ 			*str = bcm54140_hwmon_in_labels[channel];
+ 			return 0;
+ 		default:
+ 			return -EOPNOTSUPP;
+ 		}
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int bcm54140_hwmon_write_temp(struct device *dev, u32 attr,
+ 				     int channel, long val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	u16 mask = BCM54140_RDB_MON_TEMP_DATA_MASK;
+ 	u16 reg;
+ 
+ 	val = clamp_val(val, BCM54140_HWMON_TO_TEMP(mask),
+ 			BCM54140_HWMON_TO_TEMP(0));
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_min:
+ 		reg = BCM54140_RDB_MON_TEMP_MIN;
+ 		break;
+ 	case hwmon_temp_max:
+ 		reg = BCM54140_RDB_MON_TEMP_MAX;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return bcm_phy_modify_rdb(phydev, reg, mask,
+ 				  BCM54140_HWMON_FROM_TEMP(val));
+ }
+ 
+ static int bcm54140_hwmon_write_in(struct device *dev, u32 attr,
+ 				   int channel, long val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	u16 mask = BCM54140_HWMON_IN_MASK(channel);
+ 	u16 reg;
+ 
+ 	val = clamp_val(val, 0, BCM54140_HWMON_TO_IN(channel, mask));
+ 
+ 	switch (attr) {
+ 	case hwmon_in_min:
+ 		reg = BCM54140_HWMON_IN_MIN_REG(channel);
+ 		break;
+ 	case hwmon_in_max:
+ 		reg = BCM54140_HWMON_IN_MAX_REG(channel);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return bcm_phy_modify_rdb(phydev, reg, mask,
+ 				  BCM54140_HWMON_FROM_IN(channel, val));
+ }
+ 
+ static int bcm54140_hwmon_write(struct device *dev,
+ 				enum hwmon_sensor_types type, u32 attr,
+ 				int channel, long val)
+ {
+ 	switch (type) {
+ 	case hwmon_temp:
+ 		return bcm54140_hwmon_write_temp(dev, attr, channel, val);
+ 	case hwmon_in:
+ 		return bcm54140_hwmon_write_in(dev, attr, channel, val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static const struct hwmon_channel_info *bcm54140_hwmon_info[] = {
+ 	HWMON_CHANNEL_INFO(temp,
+ 			   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |
+ 			   HWMON_T_ALARM),
+ 	HWMON_CHANNEL_INFO(in,
+ 			   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |
+ 			   HWMON_I_ALARM | HWMON_I_LABEL,
+ 			   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |
+ 			   HWMON_I_ALARM | HWMON_I_LABEL),
+ 	NULL
+ };
+ 
+ static const struct hwmon_ops bcm54140_hwmon_ops = {
+ 	.is_visible = bcm54140_hwmon_is_visible,
+ 	.read = bcm54140_hwmon_read,
+ 	.read_string = bcm54140_hwmon_read_string,
+ 	.write = bcm54140_hwmon_write,
+ };
+ 
+ static const struct hwmon_chip_info bcm54140_chip_info = {
+ 	.ops = &bcm54140_hwmon_ops,
+ 	.info = bcm54140_hwmon_info,
+ };
+ 
+ static int bcm54140_enable_monitoring(struct phy_device *phydev)
+ {
+ 	u16 mask, set;
+ 
+ 	/* 3.3V voltage mode */
+ 	set = BCM54140_RDB_MON_CTRL_V_MODE;
+ 
+ 	/* select round-robin */
+ 	mask = BCM54140_RDB_MON_CTRL_SEL_MASK;
+ 	set |= FIELD_PREP(BCM54140_RDB_MON_CTRL_SEL_MASK,
+ 			  BCM54140_RDB_MON_CTRL_SEL_RR);
+ 
+ 	/* remove power-down bit */
+ 	mask |= BCM54140_RDB_MON_CTRL_PWR_DOWN;
+ 
+ 	return bcm_phy_modify_rdb(phydev, BCM54140_RDB_MON_CTRL, mask, set);
+ }
+ 
+ static int bcm54140_probe_once(struct phy_device *phydev)
+ {
+ 	struct device *hwmon;
  	int ret;
  
- 	mutex_lock(&bus->mdio_lock);
- 	ret = __mdiobus_write(bus, priv->base_addr, MII_BCM54XX_RDB_ADDR, rdb);
+ 	/* enable hardware monitoring */
+ 	ret = bcm54140_enable_monitoring(phydev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	hwmon = devm_hwmon_device_register_with_info(&phydev->mdio.dev,
+ 						     "BCM54140", phydev,
+ 						     &bcm54140_chip_info,
+ 						     NULL);
+ 	return PTR_ERR_OR_ZERO(hwmon);
+ }
+ #endif
+ 
++>>>>>>> dc9989f17328 (net: phy: bcm54140: use phy_package_shared)
+ static int bcm54140_base_read_rdb(struct phy_device *phydev, u16 rdb)
+ {
+ 	int ret;
+ 
+ 	phy_lock_mdio_bus(phydev);
+ 	ret = __phy_package_write(phydev, MII_BCM54XX_RDB_ADDR, rdb);
  	if (ret < 0)
  		goto out;
  
@@@ -232,6 -583,18 +524,21 @@@ static int bcm54140_probe(struct phy_de
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
++=======
+ 	devm_phy_package_join(&phydev->mdio.dev, phydev, priv->base_addr, 0);
+ 
+ #if IS_ENABLED(CONFIG_HWMON)
+ 	mutex_init(&priv->alarm_lock);
+ 
+ 	if (phy_package_init_once(phydev)) {
+ 		ret = bcm54140_probe_once(phydev);
+ 		if (ret)
+ 			return ret;
+ 	}
+ #endif
+ 
++>>>>>>> dc9989f17328 (net: phy: bcm54140: use phy_package_shared)
  	phydev_dbg(phydev, "probed (port %d, base PHY address %d)\n",
  		   priv->port, priv->base_addr);
  
* Unmerged path drivers/net/phy/bcm54140.c
