tcp: fix SO_RCVLOWAT possible hangs under high mem pressure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Eric Dumazet <edumazet@google.com>
commit ba3bb0e76ccd464bb66665a1941fabe55dadb3ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ba3bb0e7.failed

Whenever tcp_try_rmem_schedule() returns an error, we are under
trouble and should make sure to wakeup readers so that they
can drain socket queues and eventually make room.

Fixes: 03f45c883c6f ("tcp: avoid extra wakeups for SO_RCVLOWAT users")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ba3bb0e76ccd464bb66665a1941fabe55dadb3ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index 436a249d5eb9,9615e72656d1..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -4803,11 -4827,13 +4804,17 @@@ static void tcp_data_queue(struct sock 
  queue_and_out:
  		if (skb_queue_len(&sk->sk_receive_queue) == 0)
  			sk_forced_mem_schedule(sk, skb->truesize);
++<<<<<<< HEAD
 +		else if (tcp_try_rmem_schedule(sk, skb, skb->truesize))
++=======
+ 		else if (tcp_try_rmem_schedule(sk, skb, skb->truesize)) {
+ 			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);
+ 			sk->sk_data_ready(sk);
++>>>>>>> ba3bb0e76ccd (tcp: fix SO_RCVLOWAT possible hangs under high mem pressure)
  			goto drop;
 -		}
  
 -		eaten = tcp_queue_rcv(sk, skb, &fragstolen);
 +		eaten = tcp_queue_rcv(sk, skb, 0, &fragstolen);
 +		tcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);
  		if (skb->len)
  			tcp_event_data_recv(sk, skb);
  		if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)
* Unmerged path net/ipv4/tcp_input.c
