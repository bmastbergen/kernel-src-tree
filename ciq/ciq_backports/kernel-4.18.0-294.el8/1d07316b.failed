x86/entry/64: Switch CR3 before SWAPGS in paranoid entry

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chang S. Bae <chang.seok.bae@intel.com>
commit 1d07316b1363a004ed548c3759584f8e8b1e24e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1d07316b.failed

When FSGSBASE is enabled, the GSBASE handling in paranoid entry will need
to retrieve the kernel GSBASE which requires that the kernel page table is
active.

As the CR3 switch to the kernel page tables (PTI is active) does not depend
on kernel GSBASE, move the CR3 switch in front of the GSBASE handling.

Comment the EBX content while at it.

No functional change.

[ tglx: Rewrote changelog and comments ]

	Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: "H . Peter Anvin" <hpa@zytor.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Ravi Shankar <ravi.v.shankar@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
Link: https://lkml.kernel.org/r/1557309753-24073-11-git-send-email-chang.seok.bae@intel.com

(cherry picked from commit 1d07316b1363a004ed548c3759584f8e8b1e24e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/entry_64.S
diff --cc arch/x86/entry/entry_64.S
index 955c9ec809bc,aaa846f8850a..000000000000
--- a/arch/x86/entry/entry_64.S
+++ b/arch/x86/entry/entry_64.S
@@@ -1206,25 -1173,41 +1206,52 @@@ ENTRY(paranoid_entry
  	cld
  	PUSH_AND_CLEAR_REGS save_ret=1
  	ENCODE_FRAME_POINTER 8
- 	movl	$1, %ebx
- 	movl	$MSR_GS_BASE, %ecx
- 	rdmsr
- 	testl	%edx, %edx
- 	js	1f				/* negative -> in kernel */
- 	SWAPGS
- 	xorl	%ebx, %ebx
  
  1:
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Always stash CR3 in %r14.  This value will be restored,
+ 	 * verbatim, at exit.  Needed if paranoid_entry interrupted
+ 	 * another entry that already switched to the user CR3 value
+ 	 * but has not yet returned to userspace.
+ 	 *
+ 	 * This is also why CS (stashed in the "iret frame" by the
+ 	 * hardware at entry) can not be used: this may be a return
+ 	 * to kernel code, but with a user CR3 value.
+ 	 *
+ 	 * Switching CR3 does not depend on kernel GSBASE so it can
+ 	 * be done before switching to the kernel GSBASE. This is
+ 	 * required for FSGSBASE because the kernel GSBASE has to
+ 	 * be retrieved from a kernel internal table.
+ 	 */
++>>>>>>> 1d07316b1363 (x86/entry/64: Switch CR3 before SWAPGS in paranoid entry)
  	SAVE_AND_SWITCH_TO_KERNEL_CR3 scratch_reg=%rax save_reg=%r14
 +	IBRS_ENTRY_SAVE_AND_CLOBBER  save_reg=%r13d
 +
 +	/*
 +	 * The above SAVE_AND_SWITCH_TO_KERNEL_CR3 macro doesn't do an
 +	 * unconditional CR3 write, even in the PTI case.  So do an lfence
 +	 * to prevent GS speculation, regardless of whether PTI is enabled.
 +	 */
 +	FENCE_SWAPGS_KERNEL_ENTRY
  
+ 	/* EBX = 1 -> kernel GSBASE active, no restore required */
+ 	movl	$1, %ebx
+ 	/*
+ 	 * The kernel-enforced convention is a negative GSBASE indicates
+ 	 * a kernel value. No SWAPGS needed on entry and exit.
+ 	 */
+ 	movl	$MSR_GS_BASE, %ecx
+ 	rdmsr
+ 	testl	%edx, %edx
+ 	jns	.Lparanoid_entry_swapgs
+ 	ret
+ 
+ .Lparanoid_entry_swapgs:
+ 	SWAPGS
+ 	/* EBX = 0 -> SWAPGS required on exit */
+ 	xorl	%ebx, %ebx
  	ret
  END(paranoid_entry)
  
@@@ -1244,10 -1227,11 +1271,15 @@@ ENTRY(paranoid_exit
  	UNWIND_HINT_REGS
  	DISABLE_INTERRUPTS(CLBR_ANY)
  	TRACE_IRQS_OFF_DEBUG
++<<<<<<< HEAD
 +	IBRS_EXIT_RESTORE_CLOBBER save_reg=%r13d
 +	testl	%ebx, %ebx			/* swapgs needed? */
++=======
+ 	/* If EBX is 0, SWAPGS is required */
+ 	testl	%ebx, %ebx
++>>>>>>> 1d07316b1363 (x86/entry/64: Switch CR3 before SWAPGS in paranoid entry)
  	jnz	.Lparanoid_exit_no_swapgs
  	TRACE_IRQS_IRETQ
 -	/* Always restore stashed CR3 value (see paranoid_entry) */
  	RESTORE_CR3	scratch_reg=%rbx save_reg=%r14
  	SWAPGS_UNSAFE_STACK
  	jmp	.Lparanoid_exit_restore
* Unmerged path arch/x86/entry/entry_64.S
