KVM: x86: interrupt based APF 'page ready' event delivery

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 2635b5c4a0e407b84f68e188c719f28ba0e9ae1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2635b5c4.failed

Concerns were expressed around APF delivery via synthetic #PF exception as
in some cases such delivery may collide with real page fault. For 'page
ready' notifications we can easily switch to using an interrupt instead.
Introduce new MSR_KVM_ASYNC_PF_INT mechanism and deprecate the legacy one.

One notable difference between the two mechanisms is that interrupt may not
get handled immediately so whenever we would like to deliver next event
(regardless of its type) we must be sure the guest had read and cleared
previous event in the slot.

While on it, get rid on 'type 1/type 2' names for APF events in the
documentation as they are causing confusion. Use 'page not present'
and 'page ready' everywhere instead.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20200525144125.143875-6-vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 2635b5c4a0e407b84f68e188c719f28ba0e9ae1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/uapi/asm/kvm_para.h
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/uapi/asm/kvm_para.h
index 2a8e0b6b9805,1d37d616b1fc..000000000000
--- a/arch/x86/include/uapi/asm/kvm_para.h
+++ b/arch/x86/include/uapi/asm/kvm_para.h
@@@ -112,8 -118,13 +118,18 @@@ struct kvm_mmu_op_release_pt 
  #define KVM_PV_REASON_PAGE_READY 2
  
  struct kvm_vcpu_pv_apf_data {
++<<<<<<< HEAD
 +	__u32 reason;
 +	__u8 pad[60];
++=======
+ 	/* Used for 'page not present' events delivered via #PF */
+ 	__u32 flags;
+ 
+ 	/* Used for 'page ready' events delivered via interrupt notification */
+ 	__u32 token;
+ 
+ 	__u8 pad[56];
++>>>>>>> 2635b5c4a0e4 (KVM: x86: interrupt based APF 'page ready' event delivery)
  	__u32 enabled;
  };
  
diff --cc arch/x86/kvm/x86.c
index acc910a907d8,e6f3ec5193b2..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -10391,11 -10453,32 +10424,35 @@@ static void kvm_del_async_pf_gfn(struc
  	}
  }
  
 -static inline int apf_put_user_notpresent(struct kvm_vcpu *vcpu)
 +static int apf_put_user(struct kvm_vcpu *vcpu, u32 val)
  {
++<<<<<<< HEAD
++=======
+ 	u32 reason = KVM_PV_REASON_PAGE_NOT_PRESENT;
+ 
+ 	return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &reason,
+ 				      sizeof(reason));
+ }
+ 
+ static inline int apf_put_user_ready(struct kvm_vcpu *vcpu, u32 token)
+ {
+ 	unsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);
++>>>>>>> 2635b5c4a0e4 (KVM: x86: interrupt based APF 'page ready' event delivery)
+ 
+ 	return kvm_write_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,
+ 					     &token, offset, sizeof(token));
+ }
+ 
+ static inline bool apf_pageready_slot_free(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);
+ 	u32 val;
+ 
+ 	if (kvm_read_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,
+ 					 &val, offset, sizeof(val)))
+ 		return false;
  
- 	return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,
- 				      sizeof(val));
+ 	return !val;
  }
  
  static bool kvm_can_deliver_async_pf(struct kvm_vcpu *vcpu)
@@@ -10471,17 -10554,10 +10530,24 @@@ void kvm_arch_async_page_present(struc
  		kvm_del_async_pf_gfn(vcpu, work->arch.gfn);
  	trace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);
  
++<<<<<<< HEAD
 +	if ((work->wakeup_all || work->notpresent_injected) &&
 +	    vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED &&
 +	    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {
 +			fault.vector = PF_VECTOR;
 +			fault.error_code_valid = true;
 +			fault.error_code = 0;
 +			fault.nested_page_fault = false;
 +			fault.address = work->arch.token;
 +			fault.async_page_fault = true;
 +			kvm_inject_page_fault(vcpu, &fault);
 +	}
++=======
+ 	if (kvm_pv_async_pf_enabled(vcpu) &&
+ 	    !apf_put_user_ready(vcpu, work->arch.token))
+ 		kvm_apic_set_irq(vcpu, &irq, NULL);
+ 
++>>>>>>> 2635b5c4a0e4 (KVM: x86: interrupt based APF 'page ready' event delivery)
  	vcpu->arch.apf.halted = false;
  	vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;
  }
diff --git a/Documentation/virt/kvm/msr.rst b/Documentation/virt/kvm/msr.rst
index 33892036672d..be08df12f31a 100644
--- a/Documentation/virt/kvm/msr.rst
+++ b/Documentation/virt/kvm/msr.rst
@@ -190,41 +190,68 @@ MSR_KVM_ASYNC_PF_EN:
 	0x4b564d02
 
 data:
-	Bits 63-6 hold 64-byte aligned physical address of a
-	64 byte memory area which must be in guest RAM and must be
-	zeroed. Bits 5-3 are reserved and should be zero. Bit 0 is 1
-	when asynchronous page faults are enabled on the vcpu 0 when
-	disabled. Bit 1 is 1 if asynchronous page faults can be injected
-	when vcpu is in cpl == 0. Bit 2 is 1 if asynchronous page faults
-	are delivered to L1 as #PF vmexits.  Bit 2 can be set only if
-	KVM_FEATURE_ASYNC_PF_VMEXIT is present in CPUID.
-
-	First 4 byte of 64 byte memory location will be written to by
-	the hypervisor at the time of asynchronous page fault (APF)
-	injection to indicate type of asynchronous page fault. Value
-	of 1 means that the page referred to by the page fault is not
-	present. Value 2 means that the page is now available. Disabling
-	interrupt inhibits APFs. Guest must not enable interrupt
-	before the reason is read, or it may be overwritten by another
-	APF. Since APF uses the same exception vector as regular page
-	fault guest must reset the reason to 0 before it does
-	something that can generate normal page fault.  If during page
-	fault APF reason is 0 it means that this is regular page
-	fault.
-
-	During delivery of type 1 APF cr2 contains a token that will
-	be used to notify a guest when missing page becomes
-	available. When page becomes available type 2 APF is sent with
-	cr2 set to the token associated with the page. There is special
-	kind of token 0xffffffff which tells vcpu that it should wake
-	up all processes waiting for APFs and no individual type 2 APFs
-	will be sent.
+	Asynchronous page fault (APF) control MSR.
+
+	Bits 63-6 hold 64-byte aligned physical address of a 64 byte memory area
+	which must be in guest RAM and must be zeroed. This memory is expected
+	to hold a copy of the following structure::
+
+	  struct kvm_vcpu_pv_apf_data {
+		/* Used for 'page not present' events delivered via #PF */
+		__u32 flags;
+
+		/* Used for 'page ready' events delivered via interrupt notification */
+		__u32 token;
+
+		__u8 pad[56];
+		__u32 enabled;
+	  };
+
+	Bits 5-4 of the MSR are reserved and should be zero. Bit 0 is set to 1
+	when asynchronous page faults are enabled on the vcpu, 0 when disabled.
+	Bit 1 is 1 if asynchronous page faults can be injected when vcpu is in
+	cpl == 0. Bit 2 is 1 if asynchronous page faults are delivered to L1 as
+	#PF vmexits.  Bit 2 can be set only if KVM_FEATURE_ASYNC_PF_VMEXIT is
+	present in CPUID. Bit 3 enables interrupt based delivery of 'page ready'
+	events.
+
+	'Page not present' events are currently always delivered as synthetic
+	#PF exception. During delivery of these events APF CR2 register contains
+	a token that will be used to notify the guest when missing page becomes
+	available. Also, to make it possible to distinguish between real #PF and
+	APF, first 4 bytes of 64 byte memory location ('flags') will be written
+	to by the hypervisor at the time of injection. Only first bit of 'flags'
+	is currently supported, when set, it indicates that the guest is dealing
+	with asynchronous 'page not present' event. If during a page fault APF
+	'flags' is '0' it means that this is regular page fault. Guest is
+	supposed to clear 'flags' when it is done handling #PF exception so the
+	next event can be delivered.
+
+	Note, since APF 'page not present' events use the same exception vector
+	as regular page fault, guest must reset 'flags' to '0' before it does
+	something that can generate normal page fault.
+
+	Bytes 5-7 of 64 byte memory location ('token') will be written to by the
+	hypervisor at the time of APF 'page ready' event injection. The content
+	of these bytes is a token which was previously delivered as 'page not
+	present' event. The event indicates the page in now available. Guest is
+	supposed to write '0' to 'token' when it is done handling 'page ready'
+	event so the next one can be delivered.
+
+	Note, MSR_KVM_ASYNC_PF_INT MSR specifying the interrupt vector for 'page
+	ready' APF delivery needs to be written to before enabling APF mechanism
+	in MSR_KVM_ASYNC_PF_EN or interrupt #0 can get injected.
+
+	Note, previously, 'page ready' events were delivered via the same #PF
+	exception as 'page not present' events but this is now deprecated. If
+	bit 3 (interrupt based delivery) is not set APF events are not delivered.
 
 	If APF is disabled while there are outstanding APFs, they will
 	not be delivered.
 
-	Currently type 2 APF will be always delivered on the same vcpu as
-	type 1 was, but guest should not rely on that.
+	Currently 'page ready' APF events will be always delivered on the
+	same vcpu as 'page not present' event was, but guest should not rely on
+	that.
 
 MSR_KVM_STEAL_TIME:
 	0x4b564d03
@@ -319,3 +346,16 @@ data:
 
 	KVM guests can request the host not to poll on HLT, for example if
 	they are performing polling themselves.
+
+MSR_KVM_ASYNC_PF_INT:
+	0x4b564d06
+
+data:
+	Second asynchronous page fault (APF) control MSR.
+
+	Bits 0-7: APIC vector for delivery of 'page ready' APF events.
+	Bits 8-63: Reserved
+
+	Interrupt vector for asynchnonous 'page ready' notifications delivery.
+	The vector has to be set up before asynchronous page fault mechanism
+	is enabled in MSR_KVM_ASYNC_PF_EN.
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 5e5db7bc5e26..b214aeea2705 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -770,7 +770,9 @@ struct kvm_vcpu_arch {
 		bool halted;
 		gfn_t gfns[ASYNC_PF_PER_VCPU];
 		struct gfn_to_hva_cache data;
-		u64 msr_val;
+		u64 msr_en_val; /* MSR_KVM_ASYNC_PF_EN */
+		u64 msr_int_val; /* MSR_KVM_ASYNC_PF_INT */
+		u16 vec;
 		u32 id;
 		bool send_user_only;
 		u32 host_apf_reason;
* Unmerged path arch/x86/include/uapi/asm/kvm_para.h
* Unmerged path arch/x86/kvm/x86.c
