net: stmmac_tc: use 64-bit arithmetic instead of 32-bit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Gustavo A. R. Silva <gustavo@embeddedor.com>
commit c18a9c096683dd30300686ffc755443816893968
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c18a9c09.failed

Add suffix UL to constant 1024 in order to give the compiler complete
information about the proper arithmetic to use. Notice that this
constant is used in a context that expects an expression of type
u64 (64 bits, unsigned) and  following expressions are currently
being evaluated using 32-bit arithmetic:

qopt->idleslope * 1024 * ptr
qopt->hicredit * 1024 * 8
qopt->locredit * 1024 * 8

Addresses-Coverity-ID: 1470246 ("Unintentional integer overflow")
Addresses-Coverity-ID: 1470248 ("Unintentional integer overflow")
Addresses-Coverity-ID: 1470249 ("Unintentional integer overflow")
	Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
	Acked-by: Jose Abreu <joabreu@synopsys.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c18a9c096683dd30300686ffc755443816893968)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
index 225c833b2291,8fedc288d138..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
@@@ -288,6 -289,67 +288,70 @@@ static int tc_init(struct stmmac_priv *
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int tc_setup_cbs(struct stmmac_priv *priv,
+ 			struct tc_cbs_qopt_offload *qopt)
+ {
+ 	u32 tx_queues_count = priv->plat->tx_queues_to_use;
+ 	u32 queue = qopt->queue;
+ 	u32 ptr, speed_div;
+ 	u32 mode_to_use;
+ 	u64 value;
+ 	int ret;
+ 
+ 	/* Queue 0 is not AVB capable */
+ 	if (queue <= 0 || queue >= tx_queues_count)
+ 		return -EINVAL;
+ 	if (priv->speed != SPEED_100 && priv->speed != SPEED_1000)
+ 		return -EOPNOTSUPP;
+ 
+ 	mode_to_use = priv->plat->tx_queues_cfg[queue].mode_to_use;
+ 	if (mode_to_use == MTL_QUEUE_DCB && qopt->enable) {
+ 		ret = stmmac_dma_qmode(priv, priv->ioaddr, queue, MTL_QUEUE_AVB);
+ 		if (ret)
+ 			return ret;
+ 
+ 		priv->plat->tx_queues_cfg[queue].mode_to_use = MTL_QUEUE_AVB;
+ 	} else if (!qopt->enable) {
+ 		return stmmac_dma_qmode(priv, priv->ioaddr, queue, MTL_QUEUE_DCB);
+ 	}
+ 
+ 	/* Port Transmit Rate and Speed Divider */
+ 	ptr = (priv->speed == SPEED_100) ? 4 : 8;
+ 	speed_div = (priv->speed == SPEED_100) ? 100000 : 1000000;
+ 
+ 	/* Final adjustments for HW */
+ 	value = qopt->idleslope * 1024UL * ptr;
+ 	do_div(value, speed_div);
+ 	priv->plat->tx_queues_cfg[queue].idle_slope = value & GENMASK(31, 0);
+ 
+ 	value = -qopt->sendslope * 1024UL * ptr;
+ 	do_div(value, speed_div);
+ 	priv->plat->tx_queues_cfg[queue].send_slope = value & GENMASK(31, 0);
+ 
+ 	value = qopt->hicredit * 1024UL * 8;
+ 	priv->plat->tx_queues_cfg[queue].high_credit = value & GENMASK(31, 0);
+ 
+ 	value = qopt->locredit * 1024UL * 8;
+ 	priv->plat->tx_queues_cfg[queue].low_credit = value & GENMASK(31, 0);
+ 
+ 	ret = stmmac_config_cbs(priv, priv->hw,
+ 				priv->plat->tx_queues_cfg[queue].send_slope,
+ 				priv->plat->tx_queues_cfg[queue].idle_slope,
+ 				priv->plat->tx_queues_cfg[queue].high_credit,
+ 				priv->plat->tx_queues_cfg[queue].low_credit,
+ 				queue);
+ 	if (ret)
+ 		return ret;
+ 
+ 	dev_info(priv->device, "CBS queue %d: send %d, idle %d, hi %d, lo %d\n",
+ 			queue, qopt->sendslope, qopt->idleslope,
+ 			qopt->hicredit, qopt->locredit);
+ 	return 0;
+ }
+ 
++>>>>>>> c18a9c096683 (net: stmmac_tc: use 64-bit arithmetic instead of 32-bit)
  const struct stmmac_tc_ops dwmac510_tc_ops = {
  	.init = tc_init,
  	.setup_cls_u32 = tc_setup_cls_u32,
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
