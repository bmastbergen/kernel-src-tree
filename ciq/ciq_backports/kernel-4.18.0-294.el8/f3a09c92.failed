introduce fs_context methods

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit f3a09c92018a91ad0981146a4ac59414f814d801
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f3a09c92.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit f3a09c92018a91ad0981146a4ac59414f814d801)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs_context.c
#	fs/internal.h
#	fs/super.c
#	include/linux/fs_context.h
diff --cc fs/internal.h
index 172c0652a6e5,8f8d07cc433f..000000000000
--- a/fs/internal.h
+++ b/fs/internal.h
@@@ -50,10 -53,14 +50,19 @@@ extern int __block_write_begin_int(stru
  extern void __init chrdev_init(void);
  
  /*
++<<<<<<< HEAD
++=======
+  * fs_context.c
+  */
+ extern int parse_monolithic_mount_data(struct fs_context *, void *);
+ extern void fc_drop_locked(struct fs_context *);
+ 
+ /*
++>>>>>>> f3a09c92018a (introduce fs_context methods)
   * namei.c
   */
 +extern int filename_lookup(int dfd, struct filename *name, unsigned flags,
 +			   struct path *path, struct path *root);
  extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
  extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
  			   const char *, unsigned int, struct path *);
diff --cc fs/super.c
index 9be3be2154ec,76b3181c782d..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -888,8 -894,8 +888,13 @@@ int do_remount_sb(struct super_block *s
  		}
  	}
  
++<<<<<<< HEAD
 +	if (sb->s_op->remount_fs) {
 +		retval = sb->s_op->remount_fs(sb, &sb_flags, data);
++=======
+ 	if (fc->ops->reconfigure) {
+ 		retval = fc->ops->reconfigure(fc);
++>>>>>>> f3a09c92018a (introduce fs_context methods)
  		if (retval) {
  			if (!force)
  				goto cancel_readonly;
@@@ -1244,29 -1283,42 +1249,55 @@@ struct dentry *mount_single(struct file
  }
  EXPORT_SYMBOL(mount_single);
  
 -/**
 - * vfs_get_tree - Get the mountable root
 - * @fc: The superblock configuration context.
 - *
 - * The filesystem is invoked to get or create a superblock which can then later
 - * be used for mounting.  The filesystem places a pointer to the root to be
 - * used for mounting in @fc->root.
 - */
 -int vfs_get_tree(struct fs_context *fc)
 +struct dentry *
 +mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
  {
 +	struct dentry *root;
  	struct super_block *sb;
 -	int error;
 +	int error = -ENOMEM;
 +	struct security_mnt_opts opts;
 +
++<<<<<<< HEAD
 +	security_init_mnt_opts(&opts);
  
 +	if (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {
 +		error = security_sb_eat_lsm_opts(data, &opts);
 +		if (error)
 +			return ERR_PTR(error);
 +	}
 +
 +	root = type->mount(type, flags, name, data);
 +	if (IS_ERR(root)) {
 +		error = PTR_ERR(root);
 +		goto out_free_secdata;
 +	}
 +	sb = root->d_sb;
 +	BUG_ON(!sb);
++=======
+ 	if (fc->fs_type->fs_flags & FS_REQUIRES_DEV && !fc->source)
+ 		return -ENOENT;
+ 
+ 	if (fc->root)
+ 		return -EBUSY;
+ 
+ 	/* Get the mountable root in fc->root, with a ref on the root and a ref
+ 	 * on the superblock.
+ 	 */
+ 	error = fc->ops->get_tree(fc);
+ 	if (error < 0)
+ 		return error;
+ 
+ 	if (!fc->root) {
+ 		pr_err("Filesystem %s get_tree() didn't set fc->root\n",
+ 		       fc->fs_type->name);
+ 		/* We don't know what the locking state of the superblock is -
+ 		 * if there is a superblock.
+ 		 */
+ 		BUG();
+ 	}
+ 
+ 	sb = fc->root->d_sb;
++>>>>>>> f3a09c92018a (introduce fs_context methods)
  	WARN_ON(!sb->s_bdi);
  
  	if (fc->subtype && !sb->s_subtype) {
* Unmerged path fs/fs_context.c
* Unmerged path include/linux/fs_context.h
* Unmerged path fs/fs_context.c
* Unmerged path fs/internal.h
* Unmerged path fs/super.c
diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc0bba4da9f8..0928cd76615b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -65,6 +65,7 @@ struct workqueue_struct;
 struct iov_iter;
 struct fscrypt_info;
 struct fscrypt_operations;
+struct fs_context;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -2209,6 +2210,7 @@ struct file_system_type {
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
+	int (*init_fs_context)(struct fs_context *);
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
 	void (*kill_sb) (struct super_block *);
* Unmerged path include/linux/fs_context.h
