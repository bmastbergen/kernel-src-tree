KVM: VMX: Rename "find_msr_entry" to "vmx_find_uret_msr"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit d85a8034c016a1f50e879124bc5839c986d87a0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d85a8034.failed

Rename "find_msr_entry" to scope it to VMX and to associate it with
guest_uret_msrs.  Drop the "entry" so that the function name pairs with
the existing __vmx_find_uret_msr(), which intentionally uses a double
underscore prefix instead of appending "index" or "slot" as those names
are already claimed by other pieces of the user return MSR stack.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200923180409.32255-13-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit d85a8034c016a1f50e879124bc5839c986d87a0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/vmx/vmx.h
diff --cc arch/x86/kvm/vmx/vmx.c
index 985a4bfb7517,4cf1ccdb99ce..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -621,7 -621,7 +621,11 @@@ static inline int __find_msr_index(stru
  	return -1;
  }
  
++<<<<<<< HEAD
 +struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)
++=======
+ struct vmx_uret_msr *vmx_find_uret_msr(struct vcpu_vmx *vmx, u32 msr)
++>>>>>>> d85a8034c016 (KVM: VMX: Rename "find_msr_entry" to "vmx_find_uret_msr")
  {
  	int i;
  
@@@ -1864,10 -1853,10 +1868,15 @@@ static int vmx_get_msr(struct kvm_vcpu 
  		if (!msr_info->host_initiated &&
  		    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP))
  			return 1;
 -		goto find_uret_msr;
 +		goto find_shared_msr;
  	default:
++<<<<<<< HEAD
 +	find_shared_msr:
 +		msr = find_msr_entry(vmx, msr_info->index);
++=======
+ 	find_uret_msr:
+ 		msr = vmx_find_uret_msr(vmx, msr_info->index);
++>>>>>>> d85a8034c016 (KVM: VMX: Rename "find_msr_entry" to "vmx_find_uret_msr")
  		if (msr) {
  			msr_info->data = msr->data;
  			break;
@@@ -2137,11 -2126,11 +2146,16 @@@ static int vmx_set_msr(struct kvm_vcpu 
  		/* Check reserved bit, higher 32 bits should be zero */
  		if ((data >> 32) != 0)
  			return 1;
 -		goto find_uret_msr;
 +		goto find_shared_msr;
  
  	default:
++<<<<<<< HEAD
 +	find_shared_msr:
 +		msr = find_msr_entry(vmx, msr_index);
++=======
+ 	find_uret_msr:
+ 		msr = vmx_find_uret_msr(vmx, msr_index);
++>>>>>>> d85a8034c016 (KVM: VMX: Rename "find_msr_entry" to "vmx_find_uret_msr")
  		if (msr)
  			ret = vmx_set_guest_msr(vmx, msr, data);
  		else
@@@ -2774,7 -2763,7 +2788,11 @@@ static void enter_rmode(struct kvm_vcp
  void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)
  {
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
++<<<<<<< HEAD
 +	struct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);
++=======
+ 	struct vmx_uret_msr *msr = vmx_find_uret_msr(vmx, MSR_EFER);
++>>>>>>> d85a8034c016 (KVM: VMX: Rename "find_msr_entry" to "vmx_find_uret_msr")
  
  	if (!msr)
  		return;
@@@ -7167,8 -7107,8 +7185,13 @@@ static void vmx_vcpu_after_set_cpuid(st
  		update_intel_pt_cfg(vcpu);
  
  	if (boot_cpu_has(X86_FEATURE_RTM)) {
++<<<<<<< HEAD
 +		struct shared_msr_entry *msr;
 +		msr = find_msr_entry(vmx, MSR_IA32_TSX_CTRL);
++=======
+ 		struct vmx_uret_msr *msr;
+ 		msr = vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);
++>>>>>>> d85a8034c016 (KVM: VMX: Rename "find_msr_entry" to "vmx_find_uret_msr")
  		if (msr) {
  			bool enabled = guest_cpuid_has(vcpu, X86_FEATURE_RTM);
  			vmx_set_guest_msr(vmx, msr, enabled ? 0 : TSX_CTRL_RTM_DISABLE);
diff --cc arch/x86/kvm/vmx/vmx.h
index 131d638ba270,45c33ffae344..000000000000
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@@ -331,7 -329,7 +331,11 @@@ bool vmx_interrupt_blocked(struct kvm_v
  bool vmx_get_nmi_mask(struct kvm_vcpu *vcpu);
  void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked);
  void vmx_set_virtual_apic_mode(struct kvm_vcpu *vcpu);
++<<<<<<< HEAD
 +struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr);
++=======
+ struct vmx_uret_msr *vmx_find_uret_msr(struct vcpu_vmx *vmx, u32 msr);
++>>>>>>> d85a8034c016 (KVM: VMX: Rename "find_msr_entry" to "vmx_find_uret_msr")
  void pt_update_intercept_for_msr(struct vcpu_vmx *vmx);
  void vmx_update_host_rsp(struct vcpu_vmx *vmx, unsigned long host_rsp);
  int vmx_find_loadstore_msr_slot(struct vmx_msrs *m, u32 msr);
diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.c
index 581b2cd25413..0a0d71933f2a 100644
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@ -4287,7 +4287,7 @@ static inline u64 nested_vmx_get_vmcs01_guest_efer(struct vcpu_vmx *vmx)
 			return vmx->msr_autoload.guest.val[i].value;
 	}
 
-	efer_msr = find_msr_entry(vmx, MSR_EFER);
+	efer_msr = vmx_find_uret_msr(vmx, MSR_EFER);
 	if (efer_msr)
 		return efer_msr->data;
 
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
