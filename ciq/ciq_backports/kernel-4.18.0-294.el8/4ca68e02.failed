x86/sev-es: Handle NMI State

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] sev-es: Handle NMI State (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 92.31%
commit-author Joerg Roedel <jroedel@suse.de>
commit 4ca68e023b11e4d5908bf9ee326fab01111d77d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4ca68e02.failed

When running under SEV-ES, the kernel has to tell the hypervisor when to
open the NMI window again after an NMI was injected. This is done with
an NMI-complete message to the hypervisor.

Add code to the kernel's NMI handler to send this message right at the
beginning of do_nmi(). This always allows nesting NMIs.

 [ bp: Mark __sev_es_nmi_complete() noinstr:
   vmlinux.o: warning: objtool: exc_nmi()+0x17: call to __sev_es_nmi_complete()
	leaves .noinstr.text section
   While at it, use __pa_nodebug() for the same reason due to
   CONFIG_DEBUG_VIRTUAL=y:
   vmlinux.o: warning: objtool: __sev_es_nmi_complete()+0xd9: call to __phys_addr()
   	leaves .noinstr.text section ]

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20200907131613.12703-71-joro@8bytes.org
(cherry picked from commit 4ca68e023b11e4d5908bf9ee326fab01111d77d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/sev-es.h
#	arch/x86/include/uapi/asm/svm.h
#	arch/x86/kernel/nmi.c
#	arch/x86/kernel/sev-es.c
diff --cc arch/x86/include/uapi/asm/svm.h
index 522d42dfc28c,a7a3403645e5..000000000000
--- a/arch/x86/include/uapi/asm/svm.h
+++ b/arch/x86/include/uapi/asm/svm.h
@@@ -81,6 -81,16 +81,19 @@@
  #define SVM_EXIT_AVIC_INCOMPLETE_IPI		0x401
  #define SVM_EXIT_AVIC_UNACCELERATED_ACCESS	0x402
  
++<<<<<<< HEAD
++=======
+ /* SEV-ES software-defined VMGEXIT events */
+ #define SVM_VMGEXIT_MMIO_READ			0x80000001
+ #define SVM_VMGEXIT_MMIO_WRITE			0x80000002
+ #define SVM_VMGEXIT_NMI_COMPLETE		0x80000003
+ #define SVM_VMGEXIT_AP_HLT_LOOP			0x80000004
+ #define SVM_VMGEXIT_AP_JUMP_TABLE		0x80000005
+ #define SVM_VMGEXIT_SET_AP_JUMP_TABLE		0
+ #define SVM_VMGEXIT_GET_AP_JUMP_TABLE		1
+ #define SVM_VMGEXIT_UNSUPPORTED_EVENT		0x8000ffff
+ 
++>>>>>>> 4ca68e023b11 (x86/sev-es: Handle NMI State)
  #define SVM_EXIT_ERR           -1
  
  #define SVM_EXIT_REASONS \
diff --cc arch/x86/kernel/nmi.c
index 086cf1d1d71d,56b64d779856..000000000000
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@@ -471,28 -472,21 +471,42 @@@ enum nmi_states 
  };
  static DEFINE_PER_CPU(enum nmi_states, nmi_state);
  static DEFINE_PER_CPU(unsigned long, nmi_cr2);
 -static DEFINE_PER_CPU(unsigned long, nmi_dr7);
  
 -DEFINE_IDTENTRY_RAW(exc_nmi)
 +#ifdef CONFIG_X86_64
 +/*
 + * In x86_64, we need to handle breakpoint -> NMI -> breakpoint.  Without
 + * some care, the inner breakpoint will clobber the outer breakpoint's
 + * stack.
 + *
 + * If a breakpoint is being processed, and the debug stack is being
 + * used, if an NMI comes in and also hits a breakpoint, the stack
 + * pointer will be set to the same fixed address as the breakpoint that
 + * was interrupted, causing that stack to be corrupted. To handle this
 + * case, check if the stack that was interrupted is the debug stack, and
 + * if so, change the IDT so that new breakpoints will use the current
 + * stack and not switch to the fixed address. On return of the NMI,
 + * switch back to the original IDT.
 + */
 +static DEFINE_PER_CPU(int, update_debug_stack);
 +#endif
 +
 +dotraplinkage notrace void
 +do_nmi(struct pt_regs *regs, long error_code)
  {
++<<<<<<< HEAD
++=======
+ 	bool irq_state;
+ 
+ 	/*
+ 	 * Re-enable NMIs right here when running as an SEV-ES guest. This might
+ 	 * cause nested NMIs, but those can be handled safely.
+ 	 */
+ 	sev_es_nmi_complete();
+ 
+ 	if (IS_ENABLED(CONFIG_SMP) && arch_cpu_is_offline(smp_processor_id()))
+ 		return;
+ 
++>>>>>>> 4ca68e023b11 (x86/sev-es: Handle NMI State)
  	if (this_cpu_read(nmi_state) != NMI_NOT_RUNNING) {
  		this_cpu_write(nmi_state, NMI_LATCHED);
  		return;
* Unmerged path arch/x86/include/asm/sev-es.h
* Unmerged path arch/x86/kernel/sev-es.c
* Unmerged path arch/x86/include/asm/sev-es.h
* Unmerged path arch/x86/include/uapi/asm/svm.h
* Unmerged path arch/x86/kernel/nmi.c
* Unmerged path arch/x86/kernel/sev-es.c
