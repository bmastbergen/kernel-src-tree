net/mlx5: Remove extra indirection while storing QPN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit f93f4f4f31492468d5c6903e35cc0e31a9cb2c48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f93f4f4f.failed

The FPGA, SW steering and IPoIB need to have only QPN from the
mlx5_core_qp struct, so reduce memory footprint by storing QPN
directly.

	Reviewed-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit f93f4f4f31492468d5c6903e35cc0e31a9cb2c48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
#	drivers/net/ethernet/mellanox/mlx5/core/steering/dr_send.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c
index a6f08ed18ce9,182d3ac3e73f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c
@@@ -604,8 -588,8 +604,13 @@@ static int mlx5_fpga_conn_create_qp(str
  	if (err)
  		goto err_sq_bufs;
  
++<<<<<<< HEAD
 +	conn->qp.mqp.event = mlx5_fpga_conn_event;
 +	mlx5_fpga_dbg(fdev, "Created QP #0x%x\n", conn->qp.mqp.qpn);
++=======
+ 	conn->qp.qpn = MLX5_GET(create_qp_out, out, qpn);
+ 	mlx5_fpga_dbg(fdev, "Created QP #0x%x\n", conn->qp.qpn);
++>>>>>>> f93f4f4f3149 (net/mlx5: Remove extra indirection while storing QPN)
  
  	goto out;
  
@@@ -658,7 -642,13 +663,17 @@@ static void mlx5_fpga_conn_flush_send_b
  
  static void mlx5_fpga_conn_destroy_qp(struct mlx5_fpga_conn *conn)
  {
++<<<<<<< HEAD
 +	mlx5_core_destroy_qp(conn->fdev->mdev, &conn->qp.mqp);
++=======
+ 	struct mlx5_core_dev *dev = conn->fdev->mdev;
+ 	u32 in[MLX5_ST_SZ_DW(destroy_qp_in)] = {};
+ 
+ 	MLX5_SET(destroy_qp_in, in, opcode, MLX5_CMD_OP_DESTROY_QP);
+ 	MLX5_SET(destroy_qp_in, in, qpn, conn->qp.qpn);
+ 	mlx5_cmd_exec_in(dev, destroy_qp, in);
+ 
++>>>>>>> f93f4f4f3149 (net/mlx5: Remove extra indirection while storing QPN)
  	mlx5_fpga_conn_free_recv_bufs(conn);
  	mlx5_fpga_conn_flush_send_bufs(conn);
  	kvfree(conn->qp.sq.bufs);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index c46202bc634d,068578be00f1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@@ -225,19 -224,15 +224,25 @@@ void mlx5i_uninit_underlay_qp(struct ml
  
  #define MLX5_QP_ENHANCED_ULP_STATELESS_MODE 2
  
- int mlx5i_create_underlay_qp(struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp)
+ int mlx5i_create_underlay_qp(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	u32 *in = NULL;
++=======
+ 	u32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};
+ 	u32 in[MLX5_ST_SZ_DW(create_qp_in)] = {};
+ 	struct mlx5i_priv *ipriv = priv->ppriv;
++>>>>>>> f93f4f4f3149 (net/mlx5: Remove extra indirection while storing QPN)
  	void *addr_path;
  	int ret = 0;
 +	int inlen;
  	void *qpc;
  
 +	inlen = MLX5_ST_SZ_BYTES(create_qp_in);
 +	in = kvzalloc(inlen, GFP_KERNEL);
 +	if (!in)
 +		return -ENOMEM;
 +
  	qpc = MLX5_ADDR_OF(create_qp_in, in, qpc);
  	MLX5_SET(qpc, qpc, st, MLX5_QP_ST_UD);
  	MLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);
@@@ -248,25 -243,23 +253,42 @@@
  	MLX5_SET(ads, addr_path, vhca_port_num, 1);
  	MLX5_SET(ads, addr_path, grh, 1);
  
++<<<<<<< HEAD
 +	ret = mlx5_core_create_qp(mdev, qp, in, inlen);
 +	if (ret) {
 +		mlx5_core_err(mdev, "Failed creating IPoIB QP err : %d\n", ret);
 +		goto out;
 +	}
 +
 +out:
 +	kvfree(in);
 +	return ret;
++=======
+ 	MLX5_SET(create_qp_in, in, opcode, MLX5_CMD_OP_CREATE_QP);
+ 	ret = mlx5_cmd_exec_inout(priv->mdev, create_qp, in, out);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ipriv->qpn = MLX5_GET(create_qp_out, out, qpn);
+ 
+ 	return 0;
++>>>>>>> f93f4f4f3149 (net/mlx5: Remove extra indirection while storing QPN)
  }
  
- void mlx5i_destroy_underlay_qp(struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp)
+ void mlx5i_destroy_underlay_qp(struct mlx5_core_dev *mdev, u32 qpn)
  {
 -	u32 in[MLX5_ST_SZ_DW(destroy_qp_in)] = {};
 +	mlx5_core_destroy_qp(mdev, qp);
 +}
  
++<<<<<<< HEAD
 +int mlx5i_update_nic_rx(struct mlx5e_priv *priv)
 +{
 +	return mlx5e_refresh_tirs(priv, true, true);
++=======
+ 	MLX5_SET(destroy_qp_in, in, opcode, MLX5_CMD_OP_DESTROY_QP);
+ 	MLX5_SET(destroy_qp_in, in, qpn, qpn);
+ 	mlx5_cmd_exec_in(mdev, destroy_qp, in);
++>>>>>>> f93f4f4f3149 (net/mlx5: Remove extra indirection while storing QPN)
  }
  
  int mlx5i_create_tis(struct mlx5_core_dev *mdev, u32 underlay_qpn, u32 *tisn)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/steering/dr_send.c
index 4edd918c616f,c4ed25bb9ac8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_send.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_send.c
@@@ -180,14 -176,12 +180,22 @@@ static struct mlx5dr_qp *dr_create_rc_q
  				  (__be64 *)MLX5_ADDR_OF(create_qp_in,
  							 in, pas));
  
++<<<<<<< HEAD
 +	err = mlx5_core_create_qp(mdev, &dr_qp->mqp, in, inlen);
 +	kvfree(in);
 +
 +	if (err) {
 +		mlx5_core_warn(mdev, " Can't create QP\n");
++=======
+ 	MLX5_SET(create_qp_in, in, opcode, MLX5_CMD_OP_CREATE_QP);
+ 	err = mlx5_cmd_exec(mdev, in, inlen, out, sizeof(out));
+ 	dr_qp->qpn = MLX5_GET(create_qp_out, out, qpn);
+ 	kfree(in);
+ 	if (err)
++>>>>>>> f93f4f4f3149 (net/mlx5: Remove extra indirection while storing QPN)
  		goto err_in;
 +	}
 +	dr_qp->mqp.event = dr_qp_event;
  	dr_qp->uar = attr->uar;
  
  	return dr_qp;
@@@ -204,7 -198,12 +212,16 @@@ err_wq
  static void dr_destroy_qp(struct mlx5_core_dev *mdev,
  			  struct mlx5dr_qp *dr_qp)
  {
++<<<<<<< HEAD
 +	mlx5_core_destroy_qp(mdev, &dr_qp->mqp);
++=======
+ 	u32 in[MLX5_ST_SZ_DW(destroy_qp_in)] = {};
+ 
+ 	MLX5_SET(destroy_qp_in, in, opcode, MLX5_CMD_OP_DESTROY_QP);
+ 	MLX5_SET(destroy_qp_in, in, qpn, dr_qp->qpn);
+ 	mlx5_cmd_exec_in(mdev, destroy_qp, in);
+ 
++>>>>>>> f93f4f4f3149 (net/mlx5: Remove extra indirection while storing QPN)
  	kfree(dr_qp->sq.wqe_head);
  	mlx5_wq_destroy(&dr_qp->wq_ctrl);
  	kfree(dr_qp);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.h b/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.h
index 634ae10e287b..5116e869a6e4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.h
@@ -65,7 +65,7 @@ struct mlx5_fpga_conn {
 		int sgid_index;
 		struct mlx5_wq_qp wq;
 		struct mlx5_wq_ctrl wq_ctrl;
-		struct mlx5_core_qp mqp;
+		u32 qpn;
 		struct {
 			spinlock_t lock; /* Protects all SQ state */
 			unsigned int pc;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.h b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.h
index 2b5615dae634..d693d08b50e0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.h
@@ -51,7 +51,7 @@ extern const struct ethtool_ops mlx5i_pkey_ethtool_ops;
 /* ipoib rdma netdev's private data structure */
 struct mlx5i_priv {
 	struct rdma_netdev rn; /* keep this first */
-	struct mlx5_core_qp qp;
+	u32 qpn;
 	bool   sub_interface;
 	u32    qkey;
 	u16    pkey_index;
@@ -62,8 +62,8 @@ struct mlx5i_priv {
 int mlx5i_create_tis(struct mlx5_core_dev *mdev, u32 underlay_qpn, u32 *tisn);
 
 /* Underlay QP create/destroy functions */
-int mlx5i_create_underlay_qp(struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp);
-void mlx5i_destroy_underlay_qp(struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp);
+int mlx5i_create_underlay_qp(struct mlx5e_priv *priv);
+void mlx5i_destroy_underlay_qp(struct mlx5_core_dev *mdev, u32 qpn);
 
 /* Underlay QP state modification init/uninit functions */
 int mlx5i_init_underlay_qp(struct mlx5e_priv *priv);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib_vlan.c b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib_vlan.c
index 1a25ef296021..f70367018862 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib_vlan.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib_vlan.c
@@ -204,13 +204,13 @@ static int mlx5i_pkey_open(struct net_device *netdev)
 		goto err_release_lock;
 	}
 
-	err = mlx5_fs_add_rx_underlay_qpn(mdev, ipriv->qp.qpn);
+	err = mlx5_fs_add_rx_underlay_qpn(mdev, ipriv->qpn);
 	if (err) {
 		mlx5_core_warn(mdev, "attach child underlay qp to ft failed, %d\n", err);
 		goto err_unint_underlay_qp;
 	}
 
-	err = mlx5i_create_tis(mdev, ipriv->qp.qpn, &epriv->tisn[0][0]);
+	err = mlx5i_create_tis(mdev, ipriv->qpn, &epriv->tisn[0][0]);
 	if (err) {
 		mlx5_core_warn(mdev, "create child tis failed, %d\n", err);
 		goto err_remove_rx_uderlay_qp;
@@ -230,7 +230,7 @@ static int mlx5i_pkey_open(struct net_device *netdev)
 err_clear_state_opened_flag:
 	mlx5e_destroy_tis(mdev, epriv->tisn[0][0]);
 err_remove_rx_uderlay_qp:
-	mlx5_fs_remove_rx_underlay_qpn(mdev, ipriv->qp.qpn);
+	mlx5_fs_remove_rx_underlay_qpn(mdev, ipriv->qpn);
 err_unint_underlay_qp:
 	mlx5i_uninit_underlay_qp(epriv);
 err_release_lock:
@@ -253,7 +253,7 @@ static int mlx5i_pkey_close(struct net_device *netdev)
 	clear_bit(MLX5E_STATE_OPENED, &priv->state);
 
 	netif_carrier_off(priv->netdev);
-	mlx5_fs_remove_rx_underlay_qpn(mdev, ipriv->qp.qpn);
+	mlx5_fs_remove_rx_underlay_qpn(mdev, ipriv->qpn);
 	mlx5i_uninit_underlay_qp(priv);
 	mlx5e_deactivate_priv_channels(priv);
 	mlx5e_close_channels(&priv->channels);
@@ -307,23 +307,20 @@ static void mlx5i_pkey_cleanup(struct mlx5e_priv *priv)
 
 static int mlx5i_pkey_init_tx(struct mlx5e_priv *priv)
 {
-	struct mlx5i_priv *ipriv = priv->ppriv;
 	int err;
 
-	err = mlx5i_create_underlay_qp(priv->mdev, &ipriv->qp);
-	if (err) {
+	err = mlx5i_create_underlay_qp(priv);
+	if (err)
 		mlx5_core_warn(priv->mdev, "create child underlay QP failed, %d\n", err);
-		return err;
-	}
 
-	return 0;
+	return err;
 }
 
 static void mlx5i_pkey_cleanup_tx(struct mlx5e_priv *priv)
 {
 	struct mlx5i_priv *ipriv = priv->ppriv;
 
-	mlx5i_destroy_underlay_qp(priv->mdev, &ipriv->qp);
+	mlx5i_destroy_underlay_qp(priv->mdev, ipriv->qpn);
 }
 
 static int mlx5i_pkey_init_rx(struct mlx5e_priv *priv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/steering/dr_send.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h
index bc14aa959ec5..c6d5a81d138b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h
@@ -1012,7 +1012,7 @@ struct mlx5dr_qp {
 	struct mlx5_wq_qp wq;
 	struct mlx5_uars_page *uar;
 	struct mlx5_wq_ctrl wq_ctrl;
-	struct mlx5_core_qp mqp;
+	u32 qpn;
 	struct {
 		unsigned int pc;
 		unsigned int cc;
