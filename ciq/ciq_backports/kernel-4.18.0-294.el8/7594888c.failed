net: add sock_bindtoindex

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] add sock_bindtoindex (Jiri Benc) [1882708]
Rebuild_FUZZ: 88.89%
commit-author Christoph Hellwig <hch@lst.de>
commit 7594888c782e735f8a7b110094307a4dbe7b3f03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7594888c.failed

Add a helper to directly set the SO_BINDTOIFINDEX sockopt from kernel
space without going through a fake uaccess.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7594888c782e735f8a7b110094307a4dbe7b3f03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/sock.c
#	net/ipv4/udp_tunnel.c
#	net/ipv6/ip6_udp_tunnel.c
diff --cc net/core/sock.c
index d5f0115da4aa,23f80880fbb2..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -566,6 -566,46 +566,49 @@@ struct dst_entry *sk_dst_check(struct s
  }
  EXPORT_SYMBOL(sk_dst_check);
  
++<<<<<<< HEAD
++=======
+ static int sock_bindtoindex_locked(struct sock *sk, int ifindex)
+ {
+ 	int ret = -ENOPROTOOPT;
+ #ifdef CONFIG_NETDEVICES
+ 	struct net *net = sock_net(sk);
+ 
+ 	/* Sorry... */
+ 	ret = -EPERM;
+ 	if (sk->sk_bound_dev_if && !ns_capable(net->user_ns, CAP_NET_RAW))
+ 		goto out;
+ 
+ 	ret = -EINVAL;
+ 	if (ifindex < 0)
+ 		goto out;
+ 
+ 	sk->sk_bound_dev_if = ifindex;
+ 	if (sk->sk_prot->rehash)
+ 		sk->sk_prot->rehash(sk);
+ 	sk_dst_reset(sk);
+ 
+ 	ret = 0;
+ 
+ out:
+ #endif
+ 
+ 	return ret;
+ }
+ 
+ int sock_bindtoindex(struct sock *sk, int ifindex)
+ {
+ 	int ret;
+ 
+ 	lock_sock(sk);
+ 	ret = sock_bindtoindex_locked(sk, ifindex);
+ 	release_sock(sk);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(sock_bindtoindex);
+ 
++>>>>>>> 7594888c782e (net: add sock_bindtoindex)
  static int sock_setbindtodevice(struct sock *sk, char __user *optval,
  				int optlen)
  {
@@@ -611,13 -646,7 +654,17 @@@
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	lock_sock(sk);
 +	sk->sk_bound_dev_if = index;
 +	sk_dst_reset(sk);
 +	release_sock(sk);
 +
 +	ret = 0;
 +
++=======
+ 	return sock_bindtoindex(sk, index);
++>>>>>>> 7594888c782e (net: add sock_bindtoindex)
  out:
  #endif
  
@@@ -1123,16 -1202,30 +1170,37 @@@ set_rcvbuf
  		} else if (copy_from_user(&sk_txtime, optval,
  			   sizeof(struct sock_txtime))) {
  			ret = -EFAULT;
 -			break;
  		} else if (sk_txtime.flags & ~SOF_TXTIME_FLAGS_MASK) {
  			ret = -EINVAL;
 -			break;
 +		} else {
 +			sock_valbool_flag(sk, SOCK_TXTIME, true);
 +			sk->sk_clockid = sk_txtime.clockid;
 +			sk->sk_txtime_deadline_mode =
 +				!!(sk_txtime.flags & SOF_TXTIME_DEADLINE_MODE);
 +			sk->sk_txtime_report_errors =
 +				!!(sk_txtime.flags & SOF_TXTIME_REPORT_ERRORS);
  		}
++<<<<<<< HEAD
++=======
+ 		/* CLOCK_MONOTONIC is only used by sch_fq, and this packet
+ 		 * scheduler has enough safe guards.
+ 		 */
+ 		if (sk_txtime.clockid != CLOCK_MONOTONIC &&
+ 		    !ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)) {
+ 			ret = -EPERM;
+ 			break;
+ 		}
+ 		sock_valbool_flag(sk, SOCK_TXTIME, true);
+ 		sk->sk_clockid = sk_txtime.clockid;
+ 		sk->sk_txtime_deadline_mode =
+ 			!!(sk_txtime.flags & SOF_TXTIME_DEADLINE_MODE);
+ 		sk->sk_txtime_report_errors =
+ 			!!(sk_txtime.flags & SOF_TXTIME_REPORT_ERRORS);
+ 		break;
+ 
+ 	case SO_BINDTOIFINDEX:
+ 		ret = sock_bindtoindex_locked(sk, val);
++>>>>>>> 7594888c782e (net: add sock_bindtoindex)
  		break;
  
  	default:
diff --cc net/ipv4/udp_tunnel.c
index d0c412fc56ad,2158e8bddf41..000000000000
--- a/net/ipv4/udp_tunnel.c
+++ b/net/ipv4/udp_tunnel.c
@@@ -20,6 -21,12 +20,15 @@@ int udp_sock_create4(struct net *net, s
  	if (err < 0)
  		goto error;
  
++<<<<<<< HEAD
++=======
+ 	if (cfg->bind_ifindex) {
+ 		err = sock_bindtoindex(sock->sk, cfg->bind_ifindex);
+ 		if (err < 0)
+ 			goto error;
+ 	}
+ 
++>>>>>>> 7594888c782e (net: add sock_bindtoindex)
  	udp_addr.sin_family = AF_INET;
  	udp_addr.sin_addr = cfg->local_ip;
  	udp_addr.sin_port = cfg->local_udp_port;
diff --cc net/ipv6/ip6_udp_tunnel.c
index caad40d6e74d,6523609516d2..000000000000
--- a/net/ipv6/ip6_udp_tunnel.c
+++ b/net/ipv6/ip6_udp_tunnel.c
@@@ -31,6 -32,11 +31,14 @@@ int udp_sock_create6(struct net *net, s
  		if (err < 0)
  			goto error;
  	}
++<<<<<<< HEAD
++=======
+ 	if (cfg->bind_ifindex) {
+ 		err = sock_bindtoindex(sock->sk, cfg->bind_ifindex);
+ 		if (err < 0)
+ 			goto error;
+ 	}
++>>>>>>> 7594888c782e (net: add sock_bindtoindex)
  
  	udp6_addr.sin6_family = AF_INET6;
  	memcpy(&udp6_addr.sin6_addr, &cfg->local_ip6,
diff --git a/include/net/sock.h b/include/net/sock.h
index 50c624432ded..14302c240b29 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -2630,6 +2630,7 @@ static inline bool sk_dev_equal_l3scope(struct sock *sk, int dif)
 
 void sock_def_readable(struct sock *sk);
 
+int sock_bindtoindex(struct sock *sk, int ifindex);
 void sock_no_linger(struct sock *sk);
 void sock_set_reuseaddr(struct sock *sk);
 
* Unmerged path net/core/sock.c
* Unmerged path net/ipv4/udp_tunnel.c
* Unmerged path net/ipv6/ip6_udp_tunnel.c
