NFS: Additional refactoring for fs_context conversion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Scott Mayhew <smayhew@redhat.com>
commit 62a55d088cd87d480a6fd67b0d63b14ccae80838
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/62a55d08.failed

Split out from commit "NFS: Add fs_context support."

This patch adds additional refactoring for the conversion of NFS to use
fs_context, namely:

 (*) Merge nfs_mount_info and nfs_clone_mount into nfs_fs_context.
     nfs_clone_mount has had several fields removed, and nfs_mount_info
     has been removed altogether.
 (*) Various functions now take an fs_context as an argument instead
     of nfs_mount_info, nfs_fs_context, etc.

	Signed-off-by: Scott Mayhew <smayhew@redhat.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 62a55d088cd87d480a6fd67b0d63b14ccae80838)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/client.c
#	fs/nfs/fs_context.c
#	fs/nfs/getroot.c
#	fs/nfs/internal.h
#	fs/nfs/namespace.c
#	fs/nfs/nfs4client.c
#	fs/nfs/nfs4namespace.c
#	fs/nfs/nfs4super.c
#	fs/nfs/super.c
diff --cc fs/nfs/client.c
index 1c6787d82fc3,8f760f23748c..000000000000
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@@ -663,20 -658,20 +663,34 @@@ EXPORT_SYMBOL_GPL(nfs_init_client)
   * Create a version 2 or 3 client
   */
  static int nfs_init_server(struct nfs_server *server,
++<<<<<<< HEAD
 +			   const struct nfs_parsed_mount_data *data,
 +			   struct nfs_subversion *nfs_mod)
++=======
+ 			   const struct fs_context *fc)
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  {
+ 	const struct nfs_fs_context *ctx = nfs_fc2context(fc);
  	struct rpc_timeout timeparms;
  	struct nfs_client_initdata cl_init = {
++<<<<<<< HEAD
 +		.hostname = data->nfs_server.hostname,
 +		.addr = (const struct sockaddr *)&data->nfs_server.address,
 +		.addrlen = data->nfs_server.addrlen,
 +		.nfs_mod = nfs_mod,
 +		.proto = data->nfs_server.protocol,
 +		.net = data->net,
++=======
+ 		.hostname = ctx->nfs_server.hostname,
+ 		.addr = (const struct sockaddr *)&ctx->nfs_server.address,
+ 		.addrlen = ctx->nfs_server.addrlen,
+ 		.nfs_mod = ctx->nfs_mod,
+ 		.proto = ctx->nfs_server.protocol,
+ 		.net = fc->net_ns,
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  		.timeparms = &timeparms,
  		.cred = server->cred,
 -		.nconnect = ctx->nfs_server.nconnect,
 +		.nconnect = data->nfs_server.nconnect,
  		.init_flags = (1UL << NFS_CS_REUSEPORT),
  	};
  	struct nfs_client *clp;
@@@ -975,7 -970,7 +989,11 @@@ struct nfs_server *nfs_create_server(st
  		goto error;
  
  	/* Get a client representation */
++<<<<<<< HEAD
 +	error = nfs_init_server(server, mount_info->parsed, nfs_mod);
++=======
+ 	error = nfs_init_server(server, fc);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	if (error < 0)
  		goto error;
  
@@@ -986,7 -981,7 +1004,11 @@@
  	if (server->nfs_client->rpc_ops->version == 3) {
  		if (server->namelen == 0 || server->namelen > NFS3_MAXNAMLEN)
  			server->namelen = NFS3_MAXNAMLEN;
++<<<<<<< HEAD
 +		if (!(mount_info->parsed->flags & NFS_MOUNT_NORDIRPLUS))
++=======
+ 		if (!(ctx->flags & NFS_MOUNT_NORDIRPLUS))
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  			server->caps |= NFS_CAP_READDIRPLUS;
  	} else {
  		if (server->namelen == 0 || server->namelen > NFS2_MAXNAMLEN)
diff --cc fs/nfs/getroot.c
index 92c05a76348e,ab45496d23a6..000000000000
--- a/fs/nfs/getroot.c
+++ b/fs/nfs/getroot.c
@@@ -68,88 -64,68 +68,129 @@@ static int nfs_superblock_set_dummy_roo
  /*
   * get an NFS2/NFS3 root dentry from the root filehandle
   */
++<<<<<<< HEAD
 +struct dentry *nfs_get_root(struct super_block *sb,
 +			    struct nfs_mount_info *mount_info,
 +			    const char *devname)
 +{
 +	struct nfs_server *server = NFS_SB(sb);
 +	struct nfs_fh *mntfh = mount_info->mntfh;
++=======
+ int nfs_get_root(struct super_block *s, struct fs_context *fc)
+ {
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+ 	struct nfs_server *server = NFS_SB(s);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	struct nfs_fsinfo fsinfo;
- 	struct dentry *ret;
+ 	struct dentry *root;
  	struct inode *inode;
- 	void *name = kstrdup(devname, GFP_KERNEL);
- 	int error;
+ 	char *name;
+ 	int error = -ENOMEM;
  
+ 	name = kstrdup(fc->source, GFP_KERNEL);
  	if (!name)
- 		return ERR_PTR(-ENOMEM);
+ 		goto out;
  
  	/* get the actual root for this mount */
  	fsinfo.fattr = nfs_alloc_fattr();
- 	if (fsinfo.fattr == NULL) {
- 		kfree(name);
- 		return ERR_PTR(-ENOMEM);
- 	}
+ 	if (fsinfo.fattr == NULL)
+ 		goto out_name;
  
++<<<<<<< HEAD
 +	fsinfo.fattr->label = nfs4_label_alloc(server, GFP_KERNEL);
 +	if (IS_ERR(fsinfo.fattr->label)) {
 +		ret = ERR_CAST(fsinfo.fattr->label);
 +		goto out;
 +	}
 +
 +	error = server->nfs_client->rpc_ops->getroot(server, mntfh, &fsinfo);
 +	if (error < 0) {
 +		dprintk("nfs_get_root: getattr error = %d\n", -error);
 +		ret = ERR_PTR(error);
 +		goto out_label;
++=======
+ 	error = server->nfs_client->rpc_ops->getroot(server, ctx->mntfh, &fsinfo);
+ 	if (error < 0) {
+ 		dprintk("nfs_get_root: getattr error = %d\n", -error);
+ 		goto out_fattr;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	}
  
- 	inode = nfs_fhget(sb, mntfh, fsinfo.fattr, NULL);
+ 	inode = nfs_fhget(s, ctx->mntfh, fsinfo.fattr, NULL);
  	if (IS_ERR(inode)) {
  		dprintk("nfs_get_root: get root inode failed\n");
++<<<<<<< HEAD
 +		ret = ERR_CAST(inode);
 +		goto out_label;
 +	}
 +
 +	error = nfs_superblock_set_dummy_root(sb, inode);
 +	if (error != 0) {
 +		ret = ERR_PTR(error);
 +		goto out_label;
 +	}
++=======
+ 		error = PTR_ERR(inode);
+ 		goto out_fattr;
+ 	}
+ 
+ 	error = nfs_superblock_set_dummy_root(s, inode);
+ 	if (error != 0)
+ 		goto out_fattr;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  
  	/* root dentries normally start off anonymous and get spliced in later
  	 * if the dentry tree reaches them; however if the dentry already
  	 * exists, we'll pick it up at this point and use it as the root
  	 */
- 	ret = d_obtain_root(inode);
- 	if (IS_ERR(ret)) {
+ 	root = d_obtain_root(inode);
+ 	if (IS_ERR(root)) {
  		dprintk("nfs_get_root: get root dentry failed\n");
++<<<<<<< HEAD
 +		goto out_label;
++=======
+ 		error = PTR_ERR(root);
+ 		goto out_fattr;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	}
  
- 	security_d_instantiate(ret, inode);
- 	spin_lock(&ret->d_lock);
- 	if (IS_ROOT(ret) && !ret->d_fsdata &&
- 	    !(ret->d_flags & DCACHE_NFSFS_RENAMED)) {
- 		ret->d_fsdata = name;
+ 	security_d_instantiate(root, inode);
+ 	spin_lock(&root->d_lock);
+ 	if (IS_ROOT(root) && !root->d_fsdata &&
+ 	    !(root->d_flags & DCACHE_NFSFS_RENAMED)) {
+ 		root->d_fsdata = name;
  		name = NULL;
  	}
++<<<<<<< HEAD
 +	spin_unlock(&ret->d_lock);
 +
 +	error = mount_info->set_security(sb, ret, mount_info);
 +	if (error)
 +		goto error_splat_root;
 +
 +	nfs_setsecurity(inode, fsinfo.fattr, fsinfo.fattr->label);
 +
 +out_label:
 +	nfs4_label_free(fsinfo.fattr->label);
 +out:
 +	kfree(name);
 +	nfs_free_fattr(fsinfo.fattr);
 +	return ret;
 +
 +error_splat_root:
 +	dput(ret);
 +	ret = ERR_PTR(error);
 +	goto out_label;
++=======
+ 	spin_unlock(&root->d_lock);
+ 	fc->root = root;
+ 	error = 0;
+ 
+ out_fattr:
+ 	nfs_free_fattr(fsinfo.fattr);
+ out_name:
+ 	kfree(name);
+ out:
+ 	return error;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  }
diff --cc fs/nfs/internal.h
index feae10c2f600,a1fd4c3ebc4e..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -31,16 -33,6 +31,19 @@@ static inline int nfs_attr_use_mounted_
  	return 1;
  }
  
++<<<<<<< HEAD
 +struct nfs_clone_mount {
 +	const struct super_block *sb;
 +	const struct dentry *dentry;
 +	char *hostname;
 +	char *mnt_path;
 +	struct sockaddr *addr;
 +	size_t addrlen;
 +	rpc_authflavor_t authflavor;
 +};
 +
++=======
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  /*
   * Note: RFC 1813 doesn't limit the number of auth flavors that
   * a server can return, so make something up.
@@@ -114,12 -117,27 +117,26 @@@ struct nfs_parsed_mount_data 
  		int			port;
  		unsigned short		protocol;
  		unsigned short		nconnect;
 -		unsigned short		export_path_len;
  	} nfs_server;
  
++<<<<<<< HEAD
 +	struct security_mnt_opts lsm_opts;
 +	struct net		*net;
++=======
+ 	struct nfs_fh		*mntfh;
+ 	struct nfs_server	*server;
+ 	struct nfs_subversion	*nfs_mod;
+ 
+ 	/* Information for a cloned mount. */
+ 	struct nfs_clone_mount {
+ 		struct super_block	*sb;
+ 		struct dentry		*dentry;
+ 		struct nfs_fattr	*fattr;
+ 		unsigned int		inherited_bsize;
+ 	} clone_data;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  };
  
 -static inline struct nfs_fs_context *nfs_fc2context(const struct fs_context *fc)
 -{
 -	return fc->fs_private;
 -}
 -
  /* mount_clnt.c */
  struct nfs_mount_request {
  	struct sockaddr		*sap;
@@@ -421,18 -423,12 +437,19 @@@ static inline bool nfs_file_io_is_buffe
  extern char *nfs_path(char **p, struct dentry *dentry,
  		      char *buffer, ssize_t buflen, unsigned flags);
  extern struct vfsmount *nfs_d_automount(struct path *path);
 -int nfs_submount(struct fs_context *, struct nfs_server *);
 -int nfs_do_submount(struct fs_context *);
 +struct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,
 +			      struct nfs_fh *, struct nfs_fattr *);
 +struct vfsmount *nfs_do_submount(struct dentry *, struct nfs_fh *,
 +				 struct nfs_fattr *, rpc_authflavor_t);
  
  /* getroot.c */
++<<<<<<< HEAD
 +extern struct dentry *nfs_get_root(struct super_block *, struct nfs_mount_info *,
 +				   const char *);
++=======
+ extern int nfs_get_root(struct super_block *s, struct fs_context *fc);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  #if IS_ENABLED(CONFIG_NFS_V4)
- extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
- 				    const char *);
- 
  extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh, bool);
  #endif
  
diff --cc fs/nfs/namespace.c
index 0dbf0e798502,d537350c1fb7..000000000000
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@@ -148,26 -150,55 +148,59 @@@ struct vfsmount *nfs_d_automount(struc
  	if (IS_ROOT(path->dentry))
  		return ERR_PTR(-ESTALE);
  
 -	/* Open a new filesystem context, transferring parameters from the
 -	 * parent superblock, including the network namespace.
 -	 */
 -	fc = fs_context_for_submount(&nfs_fs_type, path->dentry);
 -	if (IS_ERR(fc))
 -		return ERR_CAST(fc);
 +	mnt = ERR_PTR(-ENOMEM);
 +	fh = nfs_alloc_fhandle();
 +	fattr = nfs_alloc_fattr();
 +	if (fh == NULL || fattr == NULL)
 +		goto out;
  
++<<<<<<< HEAD
 +	mnt = server->nfs_client->rpc_ops->submount(server, path->dentry, fh, fattr);
++=======
+ 	ctx = nfs_fc2context(fc);
+ 	ctx->clone_data.dentry	= path->dentry;
+ 	ctx->clone_data.sb	= path->dentry->d_sb;
+ 	ctx->clone_data.fattr	= nfs_alloc_fattr();
+ 	if (!ctx->clone_data.fattr)
+ 		goto out_fc;
+ 
+ 	if (fc->net_ns != client->cl_net) {
+ 		put_net(fc->net_ns);
+ 		fc->net_ns = get_net(client->cl_net);
+ 	}
+ 
+ 	/* for submounts we want the same server; referrals will reassign */
+ 	memcpy(&ctx->nfs_server.address, &client->cl_addr, client->cl_addrlen);
+ 	ctx->nfs_server.addrlen	= client->cl_addrlen;
+ 	ctx->nfs_server.port	= server->port;
+ 
+ 	ctx->version		= client->rpc_ops->version;
+ 	ctx->minorversion	= client->cl_minorversion;
+ 	ctx->nfs_mod		= client->cl_nfs_mod;
+ 	__module_get(ctx->nfs_mod->owner);
+ 
+ 	ret = client->rpc_ops->submount(fc, server);
+ 	if (ret < 0) {
+ 		mnt = ERR_PTR(ret);
+ 		goto out_fc;
+ 	}
+ 
+ 	up_write(&fc->root->d_sb->s_umount);
+ 	mnt = vfs_create_mount(fc);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	if (IS_ERR(mnt))
 -		goto out_fc;
 -
 -	if (nfs_mountpoint_expiry_timeout < 0)
 -		goto out_fc;
 +		goto out;
  
  	mntget(mnt); /* prevent immediate expiration */
 +	if (timeout <= 0)
 +		goto out;
 +
  	mnt_set_expiry(mnt, &nfs_automount_list);
 -	schedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);
 +	schedule_delayed_work(&nfs_automount_task, timeout);
  
 -out_fc:
 -	put_fs_context(fc);
 +out:
 +	nfs_free_fattr(fattr);
 +	nfs_free_fhandle(fh);
  	return mnt;
  }
  
@@@ -223,62 -253,62 +256,97 @@@ void nfs_release_automount_timer(void
   * @authflavor: security flavor to use when performing the mount
   *
   */
 -int nfs_do_submount(struct fs_context *fc)
 +struct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,
 +				 struct nfs_fattr *fattr, rpc_authflavor_t authflavor)
  {
 -	struct nfs_fs_context *ctx = nfs_fc2context(fc);
 -	struct dentry *dentry = ctx->clone_data.dentry;
 +	struct super_block *sb = dentry->d_sb;
 +	struct nfs_clone_mount mountdata = {
 +		.sb = sb,
 +		.dentry = dentry,
 +		.authflavor = authflavor,
 +	};
 +	struct nfs_mount_info mount_info = {
 +		.inherited_bsize = sb->s_blocksize_bits,
 +		.set_security = nfs_clone_sb_security,
 +		.cloned = &mountdata,
 +		.mntfh = fh,
 +		.nfs_mod = NFS_SB(sb)->nfs_client->cl_nfs_mod,
 +	};
  	struct nfs_server *server;
 -	char *buffer, *p;
 -	int ret;
 -
 +	struct vfsmount *mnt;
 +	char *page = (char *) __get_free_page(GFP_USER);
 +	char *devname;
 +
++<<<<<<< HEAD
 +	if (page == NULL)
 +		return ERR_PTR(-ENOMEM);
++=======
+ 	/* create a new volume representation */
+ 	server = ctx->nfs_mod->rpc_ops->clone_server(NFS_SB(ctx->clone_data.sb),
+ 						     ctx->mntfh,
+ 						     ctx->clone_data.fattr,
+ 						     ctx->selected_flavor);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  
 +	server = mount_info.nfs_mod->rpc_ops->clone_server(NFS_SB(sb), fh,
 +							   fattr, authflavor);
  	if (IS_ERR(server))
 -		return PTR_ERR(server);
 +		return ERR_CAST(server);
  
++<<<<<<< HEAD
 +	mount_info.server = server;
++=======
+ 	ctx->server = server;
 -
 -	buffer = kmalloc(4096, GFP_USER);
 -	if (!buffer)
 -		return -ENOMEM;
 -
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
 +
 +	devname = nfs_devname(dentry, page, PAGE_SIZE);
 +	if (IS_ERR(devname))
 +		mnt = ERR_CAST(devname);
 +	else
 +		mnt = vfs_submount(dentry, &nfs_prepared_fs_type, devname, &mount_info);
 +
++<<<<<<< HEAD
 +	if (mount_info.server)
 +		nfs_free_server(mount_info.server);
 +	free_page((unsigned long)page);
 +	return mnt;
++=======
+ 	ctx->internal		= true;
+ 	ctx->clone_data.inherited_bsize = ctx->clone_data.sb->s_blocksize_bits;
+ 
+ 	p = nfs_devname(dentry, buffer, 4096);
+ 	if (IS_ERR(p)) {
+ 		dprintk("NFS: Couldn't determine submount pathname\n");
+ 		ret = PTR_ERR(p);
+ 	} else {
+ 		ret = vfs_parse_fs_string(fc, "source", p, buffer + 4096 - p);
+ 		if (!ret)
+ 			ret = vfs_get_tree(fc);
+ 	}
+ 	kfree(buffer);
+ 	return ret;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  }
  EXPORT_SYMBOL_GPL(nfs_do_submount);
  
 -int nfs_submount(struct fs_context *fc, struct nfs_server *server)
 +struct vfsmount *nfs_submount(struct nfs_server *server, struct dentry *dentry,
 +			      struct nfs_fh *fh, struct nfs_fattr *fattr)
  {
 -	struct nfs_fs_context *ctx = nfs_fc2context(fc);
 -	struct dentry *dentry = ctx->clone_data.dentry;
 -	struct dentry *parent = dget_parent(dentry);
  	int err;
 +	struct dentry *parent = dget_parent(dentry);
  
  	/* Look it up again to get its attributes */
++<<<<<<< HEAD
 +	err = server->nfs_client->rpc_ops->lookup(d_inode(parent), &dentry->d_name, fh, fattr, NULL);
++=======
+ 	err = server->nfs_client->rpc_ops->lookup(d_inode(parent), &dentry->d_name,
+ 						  ctx->mntfh, ctx->clone_data.fattr,
+ 						  NULL);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	dput(parent);
  	if (err != 0)
 -		return err;
 +		return ERR_PTR(err);
  
 -	ctx->selected_flavor = server->client->cl_auth->au_flavor;
 -	return nfs_do_submount(fc);
 +	return nfs_do_submount(dentry, fh, fattr, server->client->cl_auth->au_flavor);
  }
  EXPORT_SYMBOL_GPL(nfs_submount);
diff --cc fs/nfs/nfs4client.c
index 8e928f9e596a,0cd767e5c977..000000000000
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@@ -1053,9 -1055,9 +1053,14 @@@ out
  /*
   * Create a version 4 volume record
   */
++<<<<<<< HEAD
 +static int nfs4_init_server(struct nfs_server *server,
 +		struct nfs_parsed_mount_data *data)
++=======
+ static int nfs4_init_server(struct nfs_server *server, struct fs_context *fc)
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  {
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
  	struct rpc_timeout timeparms;
  	int error;
  
@@@ -1077,15 -1079,15 +1082,27 @@@
  
  	/* Get a client record */
  	error = nfs4_set_client(server,
++<<<<<<< HEAD
 +			data->nfs_server.hostname,
 +			(const struct sockaddr *)&data->nfs_server.address,
 +			data->nfs_server.addrlen,
 +			data->client_address,
 +			data->nfs_server.protocol,
 +			&timeparms,
 +			data->minorversion,
 +			data->nfs_server.nconnect,
 +			data->net);
++=======
+ 				ctx->nfs_server.hostname,
+ 				&ctx->nfs_server.address,
+ 				ctx->nfs_server.addrlen,
+ 				ctx->client_address,
+ 				ctx->nfs_server.protocol,
+ 				&timeparms,
+ 				ctx->minorversion,
+ 				ctx->nfs_server.nconnect,
+ 				fc->net_ns);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	if (error < 0)
  		return error;
  
@@@ -1108,10 -1110,9 +1125,15 @@@
   * Create a version 4 volume record
   * - keyed on server and FSID
   */
++<<<<<<< HEAD
 +/*struct nfs_server *nfs4_create_server(const struct nfs_parsed_mount_data *data,
 +				      struct nfs_fh *mntfh)*/
 +struct nfs_server *nfs4_create_server(struct nfs_mount_info *mount_info)
++=======
+ struct nfs_server *nfs4_create_server(struct fs_context *fc)
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  {
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
  	struct nfs_server *server;
  	bool auth_probe;
  	int error;
@@@ -1122,10 -1123,10 +1144,17 @@@
  
  	server->cred = get_cred(current_cred());
  
++<<<<<<< HEAD
 +	auth_probe = mount_info->parsed->auth_info.flavor_len < 1;
 +
 +	/* set up the general RPC client */
 +	error = nfs4_init_server(server, mount_info->parsed);
++=======
+ 	auth_probe = ctx->auth_info.flavor_len < 1;
+ 
+ 	/* set up the general RPC client */
+ 	error = nfs4_init_server(server, fc);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	if (error < 0)
  		goto error;
  
diff --cc fs/nfs/nfs4namespace.c
index 0bb0ca4692b7,10e9e1887841..000000000000
--- a/fs/nfs/nfs4namespace.c
+++ b/fs/nfs/nfs4namespace.c
@@@ -100,21 -128,33 +100,29 @@@ static char *nfs4_path(struct dentry *d
   */
  static int nfs4_validate_fspath(struct dentry *dentry,
  				const struct nfs4_fs_locations *locations,
 -				struct nfs_fs_context *ctx)
 +				char *page, char *page2)
  {
++<<<<<<< HEAD
 +	const char *path, *fs_path;
++=======
+ 	const char *path;
+ 	char *fs_path;
+ 	unsigned short len;
+ 	char *buf;
+ 	int n;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  
 -	buf = kmalloc(4096, GFP_KERNEL);
 -	path = nfs4_path(dentry, buf, 4096);
 -	if (IS_ERR(path)) {
 -		kfree(buf);
 +	path = nfs4_path(dentry, page, PAGE_SIZE);
 +	if (IS_ERR(path))
  		return PTR_ERR(path);
 -	}
  
 -	fs_path = nfs4_pathname_string(&locations->fs_path, &len);
 -	if (IS_ERR(fs_path)) {
 -		kfree(buf);
 +	fs_path = nfs4_pathname_string(&locations->fs_path, page2, PAGE_SIZE);
 +	if (IS_ERR(fs_path))
  		return PTR_ERR(fs_path);
 -	}
  
 -	n = strncmp(path, fs_path, len);
 -	kfree(buf);
 -	kfree(fs_path);
 -	if (n != 0) {
 +	if (strncmp(path, fs_path, strlen(fs_path)) != 0) {
  		dprintk("%s: path %s does not begin with fsroot %s\n",
 -			__func__, path, ctx->nfs_server.export_path);
 +			__func__, path, fs_path);
  		return -ENOENT;
  	}
  
@@@ -236,55 -276,77 +244,101 @@@ out
  	return new;
  }
  
 -static int try_location(struct fs_context *fc,
 -			const struct nfs4_fs_location *location)
 +static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,
 +				     char *page, char *page2,
 +				     const struct nfs4_fs_location *location)
  {
++<<<<<<< HEAD
 +	const size_t addr_bufsize = sizeof(struct sockaddr_storage);
 +	struct net *net = rpc_net_ns(NFS_SB(mountdata->sb)->client);
 +	struct vfsmount *mnt = ERR_PTR(-ENOENT);
 +	char *mnt_path;
 +	unsigned int maxbuflen;
 +	unsigned int s;
 +
 +	mnt_path = nfs4_pathname_string(&location->rootpath, page2, PAGE_SIZE);
 +	if (IS_ERR(mnt_path))
 +		return ERR_CAST(mnt_path);
 +	mountdata->mnt_path = mnt_path;
 +	maxbuflen = mnt_path - 1 - page2;
 +
 +	mountdata->addr = kmalloc(addr_bufsize, GFP_KERNEL);
 +	if (mountdata->addr == NULL)
 +		return ERR_PTR(-ENOMEM);
++=======
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+ 	unsigned int len, s;
+ 	char *export_path, *source, *p;
+ 	int ret = -ENOENT;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  
 -	/* Allocate a buffer big enough to hold any of the hostnames plus a
 -	 * terminating char and also a buffer big enough to hold the hostname
 -	 * plus a colon plus the path.
 -	 */
 -	len = 0;
  	for (s = 0; s < location->nservers; s++) {
  		const struct nfs4_string *buf = &location->servers[s];
 -		if (buf->len > len)
 -			len = buf->len;
 -	}
  
++<<<<<<< HEAD
 +		if (buf->len <= 0 || buf->len >= maxbuflen)
 +			continue;
++=======
+ 	kfree(ctx->nfs_server.hostname);
+ 	ctx->nfs_server.hostname = kmalloc(len + 1, GFP_KERNEL);
+ 	if (!ctx->nfs_server.hostname)
+ 		return -ENOMEM;
+ 
+ 	export_path = nfs4_pathname_string(&location->rootpath,
+ 					   &ctx->nfs_server.export_path_len);
+ 	if (IS_ERR(export_path))
+ 		return PTR_ERR(export_path);
+ 
+ 	ctx->nfs_server.export_path = export_path;
+ 
+ 	source = kmalloc(len + 1 + ctx->nfs_server.export_path_len + 1,
+ 			 GFP_KERNEL);
+ 	if (!source)
+ 		return -ENOMEM;
+ 
+ 	kfree(fc->source);
+ 	fc->source = source;
+ 	for (s = 0; s < location->nservers; s++) {
+ 		const struct nfs4_string *buf = &location->servers[s];
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  
  		if (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))
  			continue;
  
++<<<<<<< HEAD
 +		mountdata->addrlen = nfs_parse_server_name(buf->data, buf->len,
 +				mountdata->addr, addr_bufsize, net);
 +		if (mountdata->addrlen == 0)
 +			continue;
 +
 +		memcpy(page2, buf->data, buf->len);
 +		page2[buf->len] = '\0';
 +		mountdata->hostname = page2;
 +
 +		snprintf(page, PAGE_SIZE, "%s:%s",
 +				mountdata->hostname,
 +				mountdata->mnt_path);
++=======
+ 		ctx->nfs_server.addrlen =
+ 			nfs_parse_server_name(buf->data, buf->len,
+ 					      &ctx->nfs_server.address,
+ 					      sizeof(ctx->nfs_server._address),
+ 					      fc->net_ns);
+ 		if (ctx->nfs_server.addrlen == 0)
+ 			continue;
+ 
+ 		rpc_set_port(&ctx->nfs_server.address, NFS_PORT);
+ 
+ 		memcpy(ctx->nfs_server.hostname, buf->data, buf->len);
+ 		ctx->nfs_server.hostname[buf->len] = '\0';
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  
 -		p = source;
 -		memcpy(p, buf->data, buf->len);
 -		p += buf->len;
 -		*p++ = ':';
 -		memcpy(p, ctx->nfs_server.export_path, ctx->nfs_server.export_path_len);
 -		p += ctx->nfs_server.export_path_len;
 -		*p = 0;
 -
 -		ret = nfs4_get_referral_tree(fc);
 -		if (ret == 0)
 -			return 0;
 +		mnt = vfs_submount(mountdata->dentry, &nfs4_referral_fs_type, page, mountdata);
 +		if (!IS_ERR(mnt))
 +			break;
  	}
 -
 -	return ret;
 +	kfree(mountdata->addr);
 +	return mnt;
  }
  
  /**
@@@ -394,25 -441,24 +448,30 @@@ struct vfsmount *nfs4_submount(struct n
  	struct inode *dir = d_inode(parent);
  	const struct qstr *name = &dentry->d_name;
  	struct rpc_clnt *client;
 -	int ret;
 +	struct vfsmount *mnt;
  
  	/* Look it up again to get its attributes and sec flavor */
++<<<<<<< HEAD
 +	client = nfs4_proc_lookup_mountpoint(dir, name, fh, fattr);
++=======
+ 	client = nfs4_proc_lookup_mountpoint(dir, name, ctx->mntfh,
+ 					     ctx->clone_data.fattr);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	dput(parent);
  	if (IS_ERR(client))
 -		return PTR_ERR(client);
 +		return ERR_CAST(client);
  
 -	ctx->selected_flavor = client->cl_auth->au_flavor;
 -	if (ctx->clone_data.fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {
 -		ret = nfs_do_refmount(fc, client);
 -	} else {
 -		ret = nfs_do_submount(fc);
 +	if (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {
 +		mnt = nfs_do_refmount(client, dentry);
 +		goto out;
  	}
  
 +	if (client->cl_auth->au_flavor != flavor)
 +		flavor = client->cl_auth->au_flavor;
 +	mnt = nfs_do_submount(dentry, fh, fattr, flavor);
 +out:
  	rpc_shutdown_client(client);
 -	return ret;
 +	return mnt;
  }
  
  /*
diff --cc fs/nfs/nfs4super.c
index b5c4630cd799,7d5ed37633d8..000000000000
--- a/fs/nfs/nfs4super.c
+++ b/fs/nfs/nfs4super.c
@@@ -146,25 -137,45 +146,42 @@@ static void nfs_referral_loop_unprotect
  	kfree(p);
  }
  
 -static int do_nfs4_mount(struct nfs_server *server,
 -			 struct fs_context *fc,
 -			 const char *hostname,
 -			 const char *export_path)
 +static struct dentry *do_nfs4_mount(struct nfs_server *server, int flags,
 +				    struct nfs_mount_info *info,
 +				    const char *hostname,
 +				    const char *export_path)
  {
 -	struct nfs_fs_context *root_ctx;
 -	struct fs_context *root_fc;
  	struct vfsmount *root_mnt;
  	struct dentry *dentry;
 +	char *root_devname;
 +	int err;
  	size_t len;
 -	int ret;
 -
 -	struct fs_parameter param = {
 -		.key	= "source",
 -		.type	= fs_value_is_string,
 -		.dirfd	= -1,
 -	};
  
  	if (IS_ERR(server))
++<<<<<<< HEAD
 +		return ERR_CAST(server);
++=======
+ 		return PTR_ERR(server);
+ 
+ 	root_fc = vfs_dup_fs_context(fc);
+ 	if (IS_ERR(root_fc)) {
+ 		nfs_free_server(server);
+ 		return PTR_ERR(root_fc);
+ 	}
+ 	kfree(root_fc->source);
+ 	root_fc->source = NULL;
+ 
+ 	root_ctx = nfs_fc2context(root_fc);
+ 	root_ctx->internal = true;
+ 	root_ctx->server = server;
+ 	/* We leave export_path unset as it's not used to find the root. */
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  
  	len = strlen(hostname) + 5;
 -	param.string = kmalloc(len, GFP_KERNEL);
 -	if (param.string == NULL) {
 -		put_fs_context(root_fc);
 -		return -ENOMEM;
 +	root_devname = kmalloc(len, GFP_KERNEL);
 +	if (root_devname == NULL) {
 +		nfs_free_server(server);
 +		return ERR_PTR(-ENOMEM);
  	}
  
  	/* Does hostname needs to be enclosed in brackets? */
@@@ -191,28 -204,32 +208,43 @@@
  	dentry = mount_subtree(root_mnt, export_path);
  	nfs_referral_loop_unprotect();
  
 -	if (IS_ERR(dentry))
 -		return PTR_ERR(dentry);
 -
 -	fc->root = dentry;
 -	return 0;
 +	return dentry;
  }
  
 -int nfs4_try_get_tree(struct fs_context *fc)
 +struct dentry *nfs4_try_mount(int flags, const char *dev_name,
 +			      struct nfs_mount_info *mount_info)
  {
 -	struct nfs_fs_context *ctx = nfs_fc2context(fc);
 -	int err;
 +	struct nfs_parsed_mount_data *data = mount_info->parsed;
 +	struct dentry *res;
 +
 +	mount_info->set_security = nfs_set_sb_security;
  
 -	dfprintk(MOUNT, "--> nfs4_try_get_tree()\n");
++<<<<<<< HEAD
 +	dfprintk(MOUNT, "--> nfs4_try_mount()\n");
  
 +	res = do_nfs4_mount(nfs4_create_server(mount_info),
 +			    flags, mount_info,
 +			    data->nfs_server.hostname,
 +			    data->nfs_server.export_path);
 +
 +	dfprintk(MOUNT, "<-- nfs4_try_mount() = %d%s\n",
 +		 PTR_ERR_OR_ZERO(res),
 +		 IS_ERR(res) ? " [error]" : "");
 +	return res;
++=======
+ 	/* We create a mount for the server's root, walk to the requested
+ 	 * location and then create another mount for that.
+ 	 */
+ 	err= do_nfs4_mount(nfs4_create_server(fc),
+ 			   fc, ctx->nfs_server.hostname,
+ 			   ctx->nfs_server.export_path);
+ 	if (err) {
+ 		dfprintk(MOUNT, "<-- nfs4_try_get_tree() = %d [error]\n", err);
+ 	} else {
+ 		dfprintk(MOUNT, "<-- nfs4_try_get_tree() = 0\n");
+ 	}
+ 	return err;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  }
  
  /*
@@@ -231,23 -242,18 +263,35 @@@ static struct dentry *nfs4_referral_mou
  
  	dprintk("--> nfs4_referral_mount()\n");
  
++<<<<<<< HEAD
 +	mount_info.mntfh = nfs_alloc_fhandle();
 +	if (!mount_info.mntfh)
 +		return ERR_PTR(-ENOMEM);
 +
 +	res = do_nfs4_mount(nfs4_create_referral_server(mount_info.cloned,
 +							mount_info.mntfh),
 +			    flags, &mount_info, data->hostname, data->mnt_path);
 +
 +	dprintk("<-- nfs4_referral_mount() = %d%s\n",
 +		PTR_ERR_OR_ZERO(res),
 +		IS_ERR(res) ? " [error]" : "");
 +
 +	nfs_free_fhandle(mount_info.mntfh);
 +	return res;
++=======
+ 	/* create a new volume representation */
+ 	err = do_nfs4_mount(nfs4_create_referral_server(fc),
+ 			    fc, ctx->nfs_server.hostname,
+ 			    ctx->nfs_server.export_path);
+ 	if (err) {
+ 		dfprintk(MOUNT, "<-- nfs4_get_referral_tree() = %d [error]\n", err);
+ 	} else {
+ 		dfprintk(MOUNT, "<-- nfs4_get_referral_tree() = 0\n");
+ 	}
+ 	return err;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  }
  
- 
  static int __init init_nfs_v4(void)
  {
  	int err;
diff --cc fs/nfs/super.c
index 5a0a0d311ce8,ed0290d5ebf3..000000000000
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@@ -1760,21 -745,22 +1760,30 @@@ out
   * Use the remote server's MOUNT service to request the NFS file handle
   * corresponding to the provided path.
   */
++<<<<<<< HEAD
 +static int nfs_request_mount(struct nfs_parsed_mount_data *args,
++=======
+ static int nfs_request_mount(struct fs_context *fc,
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  			     struct nfs_fh *root_fh,
  			     rpc_authflavor_t *server_authlist,
  			     unsigned int *server_authlist_len)
  {
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
  	struct nfs_mount_request request = {
  		.sap		= (struct sockaddr *)
 -						&ctx->mount_server.address,
 -		.dirpath	= ctx->nfs_server.export_path,
 -		.protocol	= ctx->mount_server.protocol,
 +						&args->mount_server.address,
 +		.dirpath	= args->nfs_server.export_path,
 +		.protocol	= args->mount_server.protocol,
  		.fh		= root_fh,
 -		.noresvport	= ctx->flags & NFS_MOUNT_NORESVPORT,
 +		.noresvport	= args->flags & NFS_MOUNT_NORESVPORT,
  		.auth_flav_len	= server_authlist_len,
  		.auth_flavs	= server_authlist,
++<<<<<<< HEAD
 +		.net		= args->net,
++=======
+ 		.net		= fc->net_ns,
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	};
  	int status;
  
@@@ -1826,13 -813,10 +1836,19 @@@ static struct nfs_server *nfs_try_mount
  	bool tried_auth_unix = false;
  	bool auth_null_in_list = false;
  	struct nfs_server *server = ERR_PTR(-EACCES);
++<<<<<<< HEAD
 +	struct nfs_parsed_mount_data *args = mount_info->parsed;
++=======
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	rpc_authflavor_t authlist[NFS_MAX_SECFLAVORS];
  	unsigned int authlist_len = ARRAY_SIZE(authlist);
- 	struct nfs_subversion *nfs_mod = mount_info->nfs_mod;
  
++<<<<<<< HEAD
 +	status = nfs_request_mount(args, mount_info->mntfh, authlist,
 +					&authlist_len);
++=======
+ 	status = nfs_request_mount(fc, ctx->mntfh, authlist, &authlist_len);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	if (status)
  		return ERR_PTR(status);
  
@@@ -1840,13 -824,13 +1856,13 @@@
  	 * Was a sec= authflavor specified in the options? First, verify
  	 * whether the server supports it, and then just try to use it if so.
  	 */
 -	if (ctx->auth_info.flavor_len > 0) {
 -		status = nfs_verify_authflavors(ctx, authlist, authlist_len);
 +	if (args->auth_info.flavor_len > 0) {
 +		status = nfs_verify_authflavors(args, authlist, authlist_len);
  		dfprintk(MOUNT, "NFS: using auth flavor %u\n",
 -			 ctx->selected_flavor);
 +			 args->selected_flavor);
  		if (status)
  			return ERR_PTR(status);
- 		return nfs_mod->rpc_ops->create_server(mount_info);
+ 		return ctx->nfs_mod->rpc_ops->create_server(fc);
  	}
  
  	/*
@@@ -1872,8 -856,8 +1888,13 @@@
  			/* Fallthrough */
  		}
  		dfprintk(MOUNT, "NFS: attempting to use auth flavor %u\n", flavor);
++<<<<<<< HEAD
 +		args->selected_flavor = flavor;
 +		server = nfs_mod->rpc_ops->create_server(mount_info);
++=======
+ 		ctx->selected_flavor = flavor;
+ 		server = ctx->nfs_mod->rpc_ops->create_server(fc);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  		if (!IS_ERR(server))
  			return server;
  	}
@@@ -1888,350 -872,23 +1909,364 @@@
  
  	/* Last chance! Try AUTH_UNIX */
  	dfprintk(MOUNT, "NFS: attempting to use auth flavor %u\n", RPC_AUTH_UNIX);
++<<<<<<< HEAD
 +	args->selected_flavor = RPC_AUTH_UNIX;
 +	return nfs_mod->rpc_ops->create_server(mount_info);
++=======
+ 	ctx->selected_flavor = RPC_AUTH_UNIX;
+ 	return ctx->nfs_mod->rpc_ops->create_server(fc);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  }
  
 -int nfs_try_get_tree(struct fs_context *fc)
 +static struct dentry *nfs_fs_mount_common(int, const char *, struct nfs_mount_info *);
 +
 +struct dentry *nfs_try_mount(int flags, const char *dev_name,
 +			     struct nfs_mount_info *mount_info)
  {
++<<<<<<< HEAD
 +	struct nfs_subversion *nfs_mod = mount_info->nfs_mod;
 +	if (mount_info->parsed->need_mount)
 +		mount_info->server = nfs_try_mount_request(mount_info);
 +	else
 +		mount_info->server = nfs_mod->rpc_ops->create_server(mount_info);
++=======
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+ 
+ 	if (ctx->need_mount)
+ 		ctx->server = nfs_try_mount_request(fc);
+ 	else
+ 		ctx->server = ctx->nfs_mod->rpc_ops->create_server(fc);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
 +
 +	return nfs_fs_mount_common(flags, dev_name, mount_info);
 +}
 +EXPORT_SYMBOL_GPL(nfs_try_mount);
 +
 +/*
 + * Split "dev_name" into "hostname:export_path".
 + *
 + * The leftmost colon demarks the split between the server's hostname
 + * and the export path.  If the hostname starts with a left square
 + * bracket, then it may contain colons.
 + *
 + * Note: caller frees hostname and export path, even on error.
 + */
 +static int nfs_parse_devname(const char *dev_name,
 +			     char **hostname, size_t maxnamlen,
 +			     char **export_path, size_t maxpathlen)
 +{
 +	size_t len;
 +	char *end;
 +
 +	if (unlikely(!dev_name || !*dev_name)) {
 +		dfprintk(MOUNT, "NFS: device name not specified\n");
 +		return -EINVAL;
 +	}
 +
 +	/* Is the host name protected with square brakcets? */
 +	if (*dev_name == '[') {
 +		end = strchr(++dev_name, ']');
 +		if (end == NULL || end[1] != ':')
 +			goto out_bad_devname;
  
 -	return nfs_get_tree_common(fc);
 +		len = end - dev_name;
 +		end++;
 +	} else {
 +		char *comma;
 +
 +		end = strchr(dev_name, ':');
 +		if (end == NULL)
 +			goto out_bad_devname;
 +		len = end - dev_name;
 +
 +		/* kill possible hostname list: not supported */
 +		comma = strchr(dev_name, ',');
 +		if (comma != NULL && comma < end)
 +			len = comma - dev_name;
 +	}
 +
 +	if (len > maxnamlen)
 +		goto out_hostname;
 +
 +	/* N.B. caller will free nfs_server.hostname in all cases */
 +	*hostname = kstrndup(dev_name, len, GFP_KERNEL);
 +	if (*hostname == NULL)
 +		goto out_nomem;
 +	len = strlen(++end);
 +	if (len > maxpathlen)
 +		goto out_path;
 +	*export_path = kstrndup(end, len, GFP_KERNEL);
 +	if (!*export_path)
 +		goto out_nomem;
 +
 +	dfprintk(MOUNT, "NFS: MNTPATH: '%s'\n", *export_path);
 +	return 0;
 +
 +out_bad_devname:
 +	dfprintk(MOUNT, "NFS: device name not in host:path format\n");
 +	return -EINVAL;
 +
 +out_nomem:
 +	dfprintk(MOUNT, "NFS: not enough memory to parse device name\n");
 +	return -ENOMEM;
 +
 +out_hostname:
 +	dfprintk(MOUNT, "NFS: server hostname too long\n");
 +	return -ENAMETOOLONG;
 +
 +out_path:
 +	dfprintk(MOUNT, "NFS: export pathname too long\n");
 +	return -ENAMETOOLONG;
  }
 -EXPORT_SYMBOL_GPL(nfs_try_get_tree);
  
 +/*
 + * Validate the NFS2/NFS3 mount data
 + * - fills in the mount root filehandle
 + *
 + * For option strings, user space handles the following behaviors:
 + *
 + * + DNS: mapping server host name to IP address ("addr=" option)
 + *
 + * + failure mode: how to behave if a mount request can't be handled
 + *   immediately ("fg/bg" option)
 + *
 + * + retry: how often to retry a mount request ("retry=" option)
 + *
 + * + breaking back: trying proto=udp after proto=tcp, v2 after v3,
 + *   mountproto=tcp after mountproto=udp, and so on
 + */
 +static int nfs23_validate_mount_data(void *options,
 +				     struct nfs_parsed_mount_data *args,
 +				     struct nfs_fh *mntfh,
 +				     const char *dev_name)
 +{
 +	struct nfs_mount_data *data = (struct nfs_mount_data *)options;
 +	struct sockaddr *sap = (struct sockaddr *)&args->nfs_server.address;
 +	int extra_flags = NFS_MOUNT_LEGACY_INTERFACE;
 +
 +	if (data == NULL)
 +		goto out_no_data;
 +
 +	args->version = NFS_DEFAULT_VERSION;
 +	switch (data->version) {
 +	case 1:
 +		data->namlen = 0; /* fall through */
 +	case 2:
 +		data->bsize = 0; /* fall through */
 +	case 3:
 +		if (data->flags & NFS_MOUNT_VER3)
 +			goto out_no_v3;
 +		data->root.size = NFS2_FHSIZE;
 +		memcpy(data->root.data, data->old_root.data, NFS2_FHSIZE);
 +		/* Turn off security negotiation */
 +		extra_flags |= NFS_MOUNT_SECFLAVOUR;
 +		/* fall through */
 +	case 4:
 +		if (data->flags & NFS_MOUNT_SECFLAVOUR)
 +			goto out_no_sec;
 +		/* fall through */
 +	case 5:
 +		memset(data->context, 0, sizeof(data->context));
 +		/* fall through */
 +	case 6:
 +		if (data->flags & NFS_MOUNT_VER3) {
 +			if (data->root.size > NFS3_FHSIZE || data->root.size == 0)
 +				goto out_invalid_fh;
 +			mntfh->size = data->root.size;
 +			args->version = 3;
 +		} else {
 +			mntfh->size = NFS2_FHSIZE;
 +			args->version = 2;
 +		}
 +
 +
 +		memcpy(mntfh->data, data->root.data, mntfh->size);
 +		if (mntfh->size < sizeof(mntfh->data))
 +			memset(mntfh->data + mntfh->size, 0,
 +			       sizeof(mntfh->data) - mntfh->size);
 +
 +		/*
 +		 * Translate to nfs_parsed_mount_data, which nfs_fill_super
 +		 * can deal with.
 +		 */
 +		args->flags		= data->flags & NFS_MOUNT_FLAGMASK;
 +		args->flags		|= extra_flags;
 +		args->rsize		= data->rsize;
 +		args->wsize		= data->wsize;
 +		args->timeo		= data->timeo;
 +		args->retrans		= data->retrans;
 +		args->acregmin		= data->acregmin;
 +		args->acregmax		= data->acregmax;
 +		args->acdirmin		= data->acdirmin;
 +		args->acdirmax		= data->acdirmax;
 +		args->need_mount	= false;
 +
 +		memcpy(sap, &data->addr, sizeof(data->addr));
 +		args->nfs_server.addrlen = sizeof(data->addr);
 +		args->nfs_server.port = ntohs(data->addr.sin_port);
 +		if (sap->sa_family != AF_INET ||
 +		    !nfs_verify_server_address(sap))
 +			goto out_no_address;
 +
 +		if (!(data->flags & NFS_MOUNT_TCP))
 +			args->nfs_server.protocol = XPRT_TRANSPORT_UDP;
 +		/* N.B. caller will free nfs_server.hostname in all cases */
 +		args->nfs_server.hostname = kstrdup(data->hostname, GFP_KERNEL);
 +		args->namlen		= data->namlen;
 +		args->bsize		= data->bsize;
 +
 +		if (data->flags & NFS_MOUNT_SECFLAVOUR)
 +			args->selected_flavor = data->pseudoflavor;
 +		else
 +			args->selected_flavor = RPC_AUTH_UNIX;
 +		if (!args->nfs_server.hostname)
 +			goto out_nomem;
 +
 +		if (!(data->flags & NFS_MOUNT_NONLM))
 +			args->flags &= ~(NFS_MOUNT_LOCAL_FLOCK|
 +					 NFS_MOUNT_LOCAL_FCNTL);
 +		else
 +			args->flags |= (NFS_MOUNT_LOCAL_FLOCK|
 +					NFS_MOUNT_LOCAL_FCNTL);
 +		/*
 +		 * The legacy version 6 binary mount data from userspace has a
 +		 * field used only to transport selinux information into the
 +		 * the kernel.  To continue to support that functionality we
 +		 * have a touch of selinux knowledge here in the NFS code. The
 +		 * userspace code converted context=blah to just blah so we are
 +		 * converting back to the full string selinux understands.
 +		 */
 +		if (data->context[0]){
 +#ifdef CONFIG_SECURITY_SELINUX
 +			int rc;
 +			char *opts_str = kmalloc(sizeof(data->context) + 8, GFP_KERNEL);
 +			if (!opts_str)
 +				return -ENOMEM;
 +			strcpy(opts_str, "context=");
 +			data->context[NFS_MAX_CONTEXT_LEN] = '\0';
 +			strcat(opts_str, &data->context[0]);
 +			rc = security_sb_parse_opts_str(opts_str, &args->lsm_opts);
 +			kfree(opts_str);
 +			if (rc)
 +				return rc;
 +#else
 +			return -EINVAL;
 +#endif
 +		}
 +
 +		break;
 +	default:
 +		return NFS_TEXT_DATA;
 +	}
 +
 +	return 0;
 +
 +out_no_data:
 +	dfprintk(MOUNT, "NFS: mount program didn't pass any mount data\n");
 +	return -EINVAL;
 +
 +out_no_v3:
 +	dfprintk(MOUNT, "NFS: nfs_mount_data version %d does not support v3\n",
 +		 data->version);
 +	return -EINVAL;
 +
 +out_no_sec:
 +	dfprintk(MOUNT, "NFS: nfs_mount_data version supports only AUTH_SYS\n");
 +	return -EINVAL;
 +
 +out_nomem:
 +	dfprintk(MOUNT, "NFS: not enough memory to handle mount options\n");
 +	return -ENOMEM;
 +
 +out_no_address:
 +	dfprintk(MOUNT, "NFS: mount program didn't pass remote address\n");
 +	return -EINVAL;
 +
 +out_invalid_fh:
 +	dfprintk(MOUNT, "NFS: invalid root filehandle\n");
 +	return -EINVAL;
 +}
 +
 +#if IS_ENABLED(CONFIG_NFS_V4)
 +static int nfs_validate_mount_data(struct file_system_type *fs_type,
 +				   void *options,
 +				   struct nfs_parsed_mount_data *args,
 +				   struct nfs_fh *mntfh,
 +				   const char *dev_name)
 +{
 +	if (fs_type == &nfs_fs_type)
 +		return nfs23_validate_mount_data(options, args, mntfh, dev_name);
 +	return nfs4_validate_mount_data(options, args, dev_name);
 +}
 +#else
 +static int nfs_validate_mount_data(struct file_system_type *fs_type,
 +				   void *options,
 +				   struct nfs_parsed_mount_data *args,
 +				   struct nfs_fh *mntfh,
 +				   const char *dev_name)
 +{
 +	return nfs23_validate_mount_data(options, args, mntfh, dev_name);
 +}
 +#endif
 +
 +static int nfs_validate_text_mount_data(void *options,
 +					struct nfs_parsed_mount_data *args,
 +					const char *dev_name)
 +{
 +	int port = 0;
 +	int max_namelen = PAGE_SIZE;
 +	int max_pathlen = NFS_MAXPATHLEN;
 +	struct sockaddr *sap = (struct sockaddr *)&args->nfs_server.address;
 +
 +	if (nfs_parse_mount_options((char *)options, args) == 0)
 +		return -EINVAL;
 +
 +	if (!nfs_verify_server_address(sap))
 +		goto out_no_address;
 +
 +	if (args->version == 4) {
 +#if IS_ENABLED(CONFIG_NFS_V4)
 +		if (args->nfs_server.protocol == XPRT_TRANSPORT_RDMA)
 +			port = NFS_RDMA_PORT;
 +		else
 +			port = NFS_PORT;
 +		max_namelen = NFS4_MAXNAMLEN;
 +		max_pathlen = NFS4_MAXPATHLEN;
 +		nfs_validate_transport_protocol(args);
 +		if (args->nfs_server.protocol == XPRT_TRANSPORT_UDP)
 +			goto out_invalid_transport_udp;
 +		nfs4_validate_mount_flags(args);
 +#else
 +		goto out_v4_not_compiled;
 +#endif /* CONFIG_NFS_V4 */
 +	} else {
 +		nfs_set_mount_transport_protocol(args);
 +		if (args->nfs_server.protocol == XPRT_TRANSPORT_RDMA)
 +			port = NFS_RDMA_PORT;
 +	}
 +
 +	nfs_set_port(sap, &args->nfs_server.port, port);
 +
 +	return nfs_parse_devname(dev_name,
 +				   &args->nfs_server.hostname,
 +				   max_namelen,
 +				   &args->nfs_server.export_path,
 +				   max_pathlen);
 +
 +#if !IS_ENABLED(CONFIG_NFS_V4)
 +out_v4_not_compiled:
 +	dfprintk(MOUNT, "NFS: NFSv4 is not compiled into kernel\n");
 +	return -EPROTONOSUPPORT;
 +#else
 +out_invalid_transport_udp:
 +	dfprintk(MOUNT, "NFSv4: Unsupported transport protocol udp\n");
 +	return -EINVAL;
 +#endif /* !CONFIG_NFS_V4 */
 +
 +out_no_address:
 +	dfprintk(MOUNT, "NFS: mount program didn't pass remote address\n");
 +	return -EINVAL;
 +}
  
  #define NFS_REMOUNT_CMP_FLAGMASK ~(NFS_MOUNT_INTR \
  		| NFS_MOUNT_SECURE \
@@@ -2345,9 -965,8 +2380,12 @@@ EXPORT_SYMBOL_GPL(nfs_remount)
  /*
   * Finish setting up an NFS superblock
   */
- static void nfs_fill_super(struct super_block *sb, struct nfs_mount_info *mount_info)
+ static void nfs_fill_super(struct super_block *sb, struct nfs_fs_context *ctx)
  {
++<<<<<<< HEAD
 +	struct nfs_parsed_mount_data *data = mount_info->parsed;
++=======
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	struct nfs_server *server = NFS_SB(sb);
  
  	sb->s_blocksize_bits = 0;
@@@ -2511,7 -1121,7 +2550,11 @@@ static int nfs_compare_super(struct sup
  		return 0;
  	if (!nfs_compare_userns(old, server))
  		return 0;
++<<<<<<< HEAD
 +	return nfs_compare_mount_options(sb, server, mntflags);
++=======
+ 	return nfs_compare_mount_options(sb, server, fc);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  }
  
  #ifdef CONFIG_NFS_FSCACHE
@@@ -2607,22 -1172,18 +2650,31 @@@ static void nfs_set_readahead(struct ba
  	bdi->io_pages = iomax_pages;
  }
  
 -int nfs_get_tree_common(struct fs_context *fc)
 +static struct dentry *nfs_fs_mount_common(int flags, const char *dev_name,
 +				   struct nfs_mount_info *mount_info)
  {
 -	struct nfs_fs_context *ctx = nfs_fc2context(fc);
  	struct super_block *s;
++<<<<<<< HEAD
 +	struct dentry *mntroot = ERR_PTR(-ENOMEM);
 +	int (*compare_super)(struct super_block *, void *) = nfs_compare_super;
 +	struct nfs_server *server = mount_info->server;
 +	struct nfs_sb_mountdata sb_mntdata = {
 +		.mntflags = flags,
 +		.server = server,
 +	};
 +	int error;
 +
 +	mount_info->server = NULL;
++=======
+ 	int (*compare_super)(struct super_block *, struct fs_context *) = nfs_compare_super;
+ 	struct nfs_server *server = ctx->server;
+ 	unsigned long kflags = 0, kflags_out = 0;
+ 	int error;
+ 
+ 	ctx->server = NULL;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  	if (IS_ERR(server))
 -		return PTR_ERR(server);
 +		return ERR_CAST(server);
  
  	if (server->flags & NFS_MOUNT_UNSHARED)
  		compare_super = NULL;
@@@ -2658,26 -1222,47 +2710,60 @@@
  	}
  
  	if (!s->s_root) {
++<<<<<<< HEAD
 +		unsigned bsize = mount_info->inherited_bsize;
 +		/* initial superblock/root creation */
 +		nfs_fill_super(s, mount_info);
++=======
+ 		unsigned bsize = ctx->clone_data.inherited_bsize;
+ 		/* initial superblock/root creation */
+ 		nfs_fill_super(s, ctx);
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  		if (bsize) {
  			s->s_blocksize_bits = bsize;
  			s->s_blocksize = 1U << bsize;
  		}
 -		nfs_get_cache_cookie(s, ctx);
 +		nfs_get_cache_cookie(s, mount_info->parsed, mount_info->cloned);
 +		if (!(server->flags & NFS_MOUNT_UNSHARED))
 +			s->s_iflags |= SB_I_MULTIROOT;
  	}
  
++<<<<<<< HEAD
 +	mntroot = nfs_get_root(s, mount_info, dev_name);
 +	if (IS_ERR(mntroot))
 +		goto error_splat_super;
++=======
+ 	error = nfs_get_root(s, fc);
+ 	if (error < 0) {
+ 		dfprintk(MOUNT, "NFS: Couldn't get root dentry\n");
+ 		goto error_splat_super;
+ 	}
+ 
+ 	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL)
+ 		kflags |= SECURITY_LSM_NATIVE_LABELS;
+ 	if (ctx->clone_data.sb) {
+ 		if (d_inode(fc->root)->i_fop != &nfs_dir_operations) {
+ 			error = -ESTALE;
+ 			goto error_splat_root;
+ 		}
+ 		/* clone any lsm security options from the parent to the new sb */
+ 		error = security_sb_clone_mnt_opts(ctx->clone_data.sb, s, kflags,
+ 				&kflags_out);
+ 	} else {
+ 		error = security_sb_set_mnt_opts(s, fc->security,
+ 							kflags, &kflags_out);
+ 	}
+ 	if (error)
+ 		goto error_splat_root;
+ 	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL &&
+ 		!(kflags_out & SECURITY_LSM_NATIVE_LABELS))
+ 		NFS_SB(s)->caps &= ~NFS_CAP_SECURITY_LABEL;
++>>>>>>> 62a55d088cd8 (NFS: Additional refactoring for fs_context conversion)
  
  	s->s_flags |= SB_ACTIVE;
 -	error = 0;
  
  out:
 -	return error;
 +	return mntroot;
  
  out_err_nosb:
  	nfs_free_server(server);
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/nfs/client.c
* Unmerged path fs/nfs/fs_context.c
diff --git a/fs/nfs/fscache.c b/fs/nfs/fscache.c
index 7dfa45a38088..6dad119f7681 100644
--- a/fs/nfs/fscache.c
+++ b/fs/nfs/fscache.c
@@ -134,7 +134,7 @@ void nfs_fscache_get_super_cookie(struct super_block *sb, const char *uniq, int
 		return;
 
 	key->nfs_client = nfss->nfs_client;
-	key->key.super.s_flags = sb->s_flags & NFS_MS_MASK;
+	key->key.super.s_flags = sb->s_flags & NFS_SB_MASK;
 	key->key.nfs_server.flags = nfss->flags;
 	key->key.nfs_server.rsize = nfss->rsize;
 	key->key.nfs_server.wsize = nfss->wsize;
* Unmerged path fs/nfs/getroot.c
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/namespace.c
diff --git a/fs/nfs/nfs3_fs.h b/fs/nfs/nfs3_fs.h
index 09602dc1889f..1b950b66b3bb 100644
--- a/fs/nfs/nfs3_fs.h
+++ b/fs/nfs/nfs3_fs.h
@@ -27,7 +27,7 @@ static inline int nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,
 #endif /* CONFIG_NFS_V3_ACL */
 
 /* nfs3client.c */
-struct nfs_server *nfs3_create_server(struct nfs_mount_info *);
+struct nfs_server *nfs3_create_server(struct fs_context *);
 struct nfs_server *nfs3_clone_server(struct nfs_server *, struct nfs_fh *,
 				     struct nfs_fattr *, rpc_authflavor_t);
 
diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index b10069ef7505..88bd93b05eeb 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -45,9 +45,10 @@ static inline void nfs_init_server_aclclient(struct nfs_server *server)
 }
 #endif
 
-struct nfs_server *nfs3_create_server(struct nfs_mount_info *mount_info)
+struct nfs_server *nfs3_create_server(struct fs_context *fc)
 {
-	struct nfs_server *server = nfs_create_server(mount_info);
+	struct nfs_server *server = nfs_create_server(fc);
+
 	/* Create a client RPC handle for the NFS v3 ACL management interface */
 	if (!IS_ERR(server))
 		nfs_init_server_aclclient(server);
* Unmerged path fs/nfs/nfs4client.c
* Unmerged path fs/nfs/nfs4namespace.c
* Unmerged path fs/nfs/nfs4super.c
* Unmerged path fs/nfs/super.c
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7d64057940d1..df8c1ee72a73 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1698,7 +1698,7 @@ struct nfs_rpc_ops {
 	struct nfs_client *(*init_client) (struct nfs_client *,
 				const struct nfs_client_initdata *);
 	void	(*free_client) (struct nfs_client *);
-	struct nfs_server *(*create_server)(struct nfs_mount_info *);
+	struct nfs_server *(*create_server)(struct fs_context *);
 	struct nfs_server *(*clone_server)(struct nfs_server *, struct nfs_fh *,
 					   struct nfs_fattr *, rpc_authflavor_t);
 };
