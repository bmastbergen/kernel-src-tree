net_sched: add tracepoints for qdisc_reset() and qdisc_destroy()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] sched: add tracepoints for qdisc_reset() and qdisc_destroy() (Ivan Vecera) [1874071]
Rebuild_FUZZ: 96.77%
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit a34dac0b9055202cf9c64e08d8d8dc5e23029d3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a34dac0b.failed

Add two tracepoints for qdisc_reset() and qdisc_destroy() to track
qdisc resetting and destroying.

Sample output:

  tc-756   [000] ...3   138.355662: qdisc_reset: dev=ens3 kind=pfifo_fast parent=ffff:ffff handle=0:0
  tc-756   [000] ...1   138.355720: qdisc_reset: dev=ens3 kind=pfifo_fast parent=ffff:ffff handle=0:0
  tc-756   [000] ...1   138.355867: qdisc_reset: dev=ens3 kind=pfifo_fast parent=ffff:ffff handle=0:0
  tc-756   [000] ...1   138.355930: qdisc_destroy: dev=ens3 kind=pfifo_fast parent=ffff:ffff handle=0:0
  tc-757   [000] ...2   143.073780: qdisc_reset: dev=ens3 kind=fq_codel parent=ffff:ffff handle=8001:0
  tc-757   [000] ...1   143.073878: qdisc_reset: dev=ens3 kind=fq_codel parent=ffff:ffff handle=8001:0
  tc-757   [000] ...1   143.074114: qdisc_reset: dev=ens3 kind=fq_codel parent=ffff:ffff handle=8001:0
  tc-757   [000] ...1   143.074228: qdisc_destroy: dev=ens3 kind=fq_codel parent=ffff:ffff handle=8001:0

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a34dac0b9055202cf9c64e08d8d8dc5e23029d3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/qdisc.h
diff --cc include/trace/events/qdisc.h
index 60d0d8bd336d,2b948801afa3..000000000000
--- a/include/trace/events/qdisc.h
+++ b/include/trace/events/qdisc.h
@@@ -44,7 -46,57 +46,61 @@@ TRACE_EVENT(qdisc_dequeue
  		  __entry->txq_state, __entry->packets, __entry->skbaddr )
  );
  
++<<<<<<< HEAD
 +#endif /* _TRACE_QDISC_H_ */
++=======
+ TRACE_EVENT(qdisc_reset,
+ 
+ 	TP_PROTO(struct Qdisc *q),
+ 
+ 	TP_ARGS(q),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(	dev,		qdisc_dev(q)	)
+ 		__string(	kind,		q->ops->id	)
+ 		__field(	u32,		parent		)
+ 		__field(	u32,		handle		)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(dev, qdisc_dev(q));
+ 		__assign_str(kind, q->ops->id);
+ 		__entry->parent = q->parent;
+ 		__entry->handle = q->handle;
+ 	),
+ 
+ 	TP_printk("dev=%s kind=%s parent=%x:%x handle=%x:%x", __get_str(dev),
+ 		  __get_str(kind), TC_H_MAJ(__entry->parent) >> 16, TC_H_MIN(__entry->parent),
+ 		  TC_H_MAJ(__entry->handle) >> 16, TC_H_MIN(__entry->handle))
+ );
+ 
+ TRACE_EVENT(qdisc_destroy,
+ 
+ 	TP_PROTO(struct Qdisc *q),
+ 
+ 	TP_ARGS(q),
+ 
+ 	TP_STRUCT__entry(
+ 		__string(	dev,		qdisc_dev(q)	)
+ 		__string(	kind,		q->ops->id	)
+ 		__field(	u32,		parent		)
+ 		__field(	u32,		handle		)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__assign_str(dev, qdisc_dev(q));
+ 		__assign_str(kind, q->ops->id);
+ 		__entry->parent = q->parent;
+ 		__entry->handle = q->handle;
+ 	),
+ 
+ 	TP_printk("dev=%s kind=%s parent=%x:%x handle=%x:%x", __get_str(dev),
+ 		  __get_str(kind), TC_H_MAJ(__entry->parent) >> 16, TC_H_MIN(__entry->parent),
+ 		  TC_H_MAJ(__entry->handle) >> 16, TC_H_MIN(__entry->handle))
+ );
+ 
+ #endif /* _TRACE_QDISC_H */
++>>>>>>> a34dac0b9055 (net_sched: add tracepoints for qdisc_reset() and qdisc_destroy())
  
  /* This part must be outside protection */
  #include <trace/define_trace.h>
* Unmerged path include/trace/events/qdisc.h
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 6655107e7cf9..3e3ebc9221cc 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -910,6 +910,8 @@ void qdisc_reset(struct Qdisc *qdisc)
 	const struct Qdisc_ops *ops = qdisc->ops;
 	struct sk_buff *skb, *tmp;
 
+	trace_qdisc_reset(qdisc);
+
 	if (ops->reset)
 		ops->reset(qdisc);
 
@@ -964,6 +966,8 @@ static void qdisc_destroy(struct Qdisc *qdisc)
 	module_put(ops->owner);
 	dev_put(qdisc_dev(qdisc));
 
+	trace_qdisc_destroy(qdisc);
+
 	call_rcu(&qdisc->rcu, qdisc_free_cb);
 }
 
