bpf: Fail PERF_EVENT_IOC_SET_BPF when bpf_get_[stack|stackid] cannot work

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] bpf: Fail PERF_EVENT_IOC_SET_BPF when bpf_get_cannot work (Yauheni Kaliuta) [1874005]
Rebuild_FUZZ: 87.69%
commit-author Song Liu <songliubraving@fb.com>
commit 5d99cb2c86775b4780c02a339a9578bf9471ead9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5d99cb2c.failed

bpf_get_[stack|stackid] on perf_events with precise_ip uses callchain
attached to perf_sample_data. If this callchain is not presented, do not
allow attaching BPF program that calls bpf_get_[stack|stackid] to this
event.

In the error case, -EPROTO is returned so that libbpf can identify this
error and print proper hint message.

	Signed-off-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200723180648.1429892-3-songliubraving@fb.com
(cherry picked from commit 5d99cb2c86775b4780c02a339a9578bf9471ead9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/filter.h
diff --cc include/linux/filter.h
index dc3bd64e26c3,0a355b005bf4..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -536,12 -532,9 +536,17 @@@ struct bpf_prog 
  				blinded:1,	/* Was blinded */
  				is_func:1,	/* program is a bpf function */
  				kprobe_override:1, /* Do we override a kprobe? */
 +#ifdef __GENKSYMS__
 +				has_callchain_buf:1; /* callchain buffer allocated? */
 +#else
  				has_callchain_buf:1, /* callchain buffer allocated? */
++<<<<<<< HEAD
 +				enforce_expected_attach_type:1; /* Enforce expected_attach_type checking at attach time */
 +#endif
++=======
+ 				enforce_expected_attach_type:1, /* Enforce expected_attach_type checking at attach time */
+ 				call_get_stack:1; /* Do we call bpf_get_stack() or bpf_get_stackid() */
++>>>>>>> 5d99cb2c8677 (bpf: Fail PERF_EVENT_IOC_SET_BPF when bpf_get_[stack|stackid] cannot work)
  	enum bpf_prog_type	type;		/* Type of BPF program */
  	enum bpf_attach_type	expected_attach_type; /* For some prog types */
  	u32			len;		/* Number of filter blocks */
* Unmerged path include/linux/filter.h
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index b8aec186e303..d6b6ccd58cad 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -4710,6 +4710,9 @@ static int check_helper_call(struct bpf_verifier_env *env, int func_id, int insn
 		env->prog->has_callchain_buf = true;
 	}
 
+	if (func_id == BPF_FUNC_get_stackid || func_id == BPF_FUNC_get_stack)
+		env->prog->call_get_stack = true;
+
 	if (changes_data)
 		clear_all_pkt_pointers(env);
 	return 0;
diff --git a/kernel/events/core.c b/kernel/events/core.c
index a7f0cfe4e850..01c49795943d 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -9544,6 +9544,24 @@ static int perf_event_set_bpf_handler(struct perf_event *event, u32 prog_fd)
 	if (IS_ERR(prog))
 		return PTR_ERR(prog);
 
+	if (event->attr.precise_ip &&
+	    prog->call_get_stack &&
+	    (!(event->attr.sample_type & __PERF_SAMPLE_CALLCHAIN_EARLY) ||
+	     event->attr.exclude_callchain_kernel ||
+	     event->attr.exclude_callchain_user)) {
+		/*
+		 * On perf_event with precise_ip, calling bpf_get_stack()
+		 * may trigger unwinder warnings and occasional crashes.
+		 * bpf_get_[stack|stackid] works around this issue by using
+		 * callchain attached to perf_sample_data. If the
+		 * perf_event does not full (kernel and user) callchain
+		 * attached to perf_sample_data, do not allow attaching BPF
+		 * program that calls bpf_get_[stack|stackid].
+		 */
+		bpf_prog_put(prog);
+		return -EPROTO;
+	}
+
 	event->prog = prog;
 	event->orig_overflow_handler = READ_ONCE(event->overflow_handler);
 	WRITE_ONCE(event->overflow_handler, bpf_overflow_handler);
