mptcp: Consistently use READ_ONCE/WRITE_ONCE with msk->ack_seq

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mat Martineau <mathew.j.martineau@linux.intel.com>
commit 917944da3bfc7cb5ac3af26725af3371d3a12db0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/917944da.failed

The msk->ack_seq value is sometimes read without the msk lock held, so
make proper use of READ_ONCE and WRITE_ONCE.

	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 917944da3bfc7cb5ac3af26725af3371d3a12db0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 691a71ca323f,5d747c6a610e..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -156,12 -123,20 +156,16 @@@ static void __mptcp_move_skb(struct mpt
  
  	skb_ext_reset(skb);
  	skb_orphan(skb);
++<<<<<<< HEAD
 +	MPTCP_SKB_CB(skb)->offset = offset;
 +	msk->ack_seq += copy_len;
++=======
+ 	WRITE_ONCE(msk->ack_seq, msk->ack_seq + copy_len);
++>>>>>>> 917944da3bfc (mptcp: Consistently use READ_ONCE/WRITE_ONCE with msk->ack_seq)
  
  	tail = skb_peek_tail(&sk->sk_receive_queue);
 -	if (offset == 0 && tail) {
 -		bool fragstolen;
 -		int delta;
 -
 -		if (skb_try_coalesce(tail, skb, &fragstolen, &delta)) {
 -			kfree_skb_partial(skb, fragstolen);
 -			atomic_add(delta, &sk->sk_rmem_alloc);
 -			sk_mem_charge(sk, delta);
 -			return;
 -		}
 -	}
 +	if (tail && mptcp_try_coalesce(sk, tail, skb))
 +		return;
  
  	skb_set_owner_r(skb, sk);
  	__skb_queue_tail(&sk->sk_receive_queue, skb);
diff --git a/net/mptcp/options.c b/net/mptcp/options.c
index 03f892be02de..a60ff13c43cb 100644
--- a/net/mptcp/options.c
+++ b/net/mptcp/options.c
@@ -519,11 +519,11 @@ static bool mptcp_established_options_dss(struct sock *sk, struct sk_buff *skb,
 
 	if (subflow->use_64bit_ack) {
 		ack_size = TCPOLEN_MPTCP_DSS_ACK64;
-		opts->ext_copy.data_ack = msk->ack_seq;
+		opts->ext_copy.data_ack = READ_ONCE(msk->ack_seq);
 		opts->ext_copy.ack64 = 1;
 	} else {
 		ack_size = TCPOLEN_MPTCP_DSS_ACK32;
-		opts->ext_copy.data_ack32 = (uint32_t)(msk->ack_seq);
+		opts->ext_copy.data_ack32 = (uint32_t)READ_ONCE(msk->ack_seq);
 		opts->ext_copy.ack64 = 0;
 	}
 	opts->ext_copy.use_ack = 1;
* Unmerged path net/mptcp/protocol.c
