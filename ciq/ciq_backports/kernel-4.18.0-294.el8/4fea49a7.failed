s390/cio: Add new Operation Code OC3 to PNSO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Alexandra Winter <wintera@linux.ibm.com>
commit 4fea49a79ece30f27ce3bb8fa9dd2a19e354e750
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4fea49a7.failed

Add support for operation code 3 (OC3) of the
Perform-Network-Subchannel-Operations (PNSO) function
of the Channel-Subsystem-Call (CHSC) instruction.

PNSO provides 2 operation codes:
OC0 - BRIDGE_INFO
OC3 - ADDR_INFO (new)

Extend the function calls to *pnso* to pass the OC and
add new response code 0108.

Support for OC3 is indicated by a flag in the css_general_characteristics.

	Signed-off-by: Alexandra Winter <wintera@linux.ibm.com>
	Reviewed-by: Julian Wiedmann <jwi@linux.ibm.com>
	Reviewed-by: Peter Oberparleiter <oberpar@linux.ibm.com>
	Reviewed-by: Vineeth Vijayan <vneethv@linux.ibm.com>
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Acked-by: Heiko Carstens <hca@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4fea49a79ece30f27ce3bb8fa9dd2a19e354e750)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/ccwdev.h
#	arch/s390/include/asm/chsc.h
#	drivers/s390/cio/chsc.c
#	drivers/s390/cio/chsc.h
#	drivers/s390/cio/device_ops.c
#	drivers/s390/net/qeth_l2_main.c
diff --cc arch/s390/include/asm/ccwdev.h
index 865ce1cb86d5,9739a00e2190..000000000000
--- a/arch/s390/include/asm/ccwdev.h
+++ b/arch/s390/include/asm/ccwdev.h
@@@ -236,4 -237,7 +236,10 @@@ extern void ccw_device_get_schid(struc
  
  struct channel_path_desc_fmt0 *ccw_device_get_chp_desc(struct ccw_device *, int);
  u8 *ccw_device_get_util_str(struct ccw_device *cdev, int chp_idx);
++<<<<<<< HEAD
++=======
+ int ccw_device_pnso(struct ccw_device *cdev,
+ 		    struct chsc_pnso_area *pnso_area, u8 oc,
+ 		    struct chsc_pnso_resume_token resume_token, int cnc);
++>>>>>>> 4fea49a79ece (s390/cio: Add new Operation Code OC3 to PNSO)
  #endif /* _S390_CCWDEV_H_ */
diff --cc drivers/s390/cio/chsc.c
index 76f5a6900b5d,8f764a295a51..000000000000
--- a/drivers/s390/cio/chsc.c
+++ b/drivers/s390/cio/chsc.c
@@@ -1336,9 -1339,10 +1338,14 @@@ out
  EXPORT_SYMBOL_GPL(chsc_scm_info);
  
  /**
 - * chsc_pnso() - Perform Network-Subchannel Operation
 + * chsc_pnso_brinfo() - Perform Network-Subchannel Operation, Bridge Info.
   * @schid:		id of the subchannel on which PNSO is performed
++<<<<<<< HEAD
 + * @brinfo_area:	request and response block for the operation
++=======
+  * @pnso_area:		request and response block for the operation
+  * @oc:			Operation Code
++>>>>>>> 4fea49a79ece (s390/cio: Add new Operation Code OC3 to PNSO)
   * @resume_token:	resume token for multiblock response
   * @cnc:		Boolean change-notification control
   *
@@@ -1346,26 -1350,23 +1353,43 @@@
   *
   * Returns 0 on success.
   */
++<<<<<<< HEAD
 +int chsc_pnso_brinfo(struct subchannel_id schid,
 +		struct chsc_pnso_area *brinfo_area,
 +		struct chsc_brinfo_resume_token resume_token,
 +		int cnc)
 +{
 +	memset(brinfo_area, 0, sizeof(*brinfo_area));
 +	brinfo_area->request.length = 0x0030;
 +	brinfo_area->request.code = 0x003d; /* network-subchannel operation */
 +	brinfo_area->m	   = schid.m;
 +	brinfo_area->ssid  = schid.ssid;
 +	brinfo_area->sch   = schid.sch_no;
 +	brinfo_area->cssid = schid.cssid;
 +	brinfo_area->oc    = 0; /* Store-network-bridging-information list */
 +	brinfo_area->resume_token = resume_token;
 +	brinfo_area->n	   = (cnc != 0);
 +	if (chsc(brinfo_area))
++=======
+ int chsc_pnso(struct subchannel_id schid, struct chsc_pnso_area *pnso_area,
+ 	      u8 oc, struct chsc_pnso_resume_token resume_token, int cnc)
+ {
+ 	memset(pnso_area, 0, sizeof(*pnso_area));
+ 	pnso_area->request.length = 0x0030;
+ 	pnso_area->request.code = 0x003d; /* network-subchannel operation */
+ 	pnso_area->m	   = schid.m;
+ 	pnso_area->ssid  = schid.ssid;
+ 	pnso_area->sch	 = schid.sch_no;
+ 	pnso_area->cssid = schid.cssid;
+ 	pnso_area->oc	 = oc;
+ 	pnso_area->resume_token = resume_token;
+ 	pnso_area->n	   = (cnc != 0);
+ 	if (chsc(pnso_area))
++>>>>>>> 4fea49a79ece (s390/cio: Add new Operation Code OC3 to PNSO)
  		return -EIO;
 -	return chsc_error_from_response(pnso_area->response.code);
 +	return chsc_error_from_response(brinfo_area->response.code);
  }
 +EXPORT_SYMBOL_GPL(chsc_pnso_brinfo);
  
  int chsc_sgib(u32 origin)
  {
diff --cc drivers/s390/cio/chsc.h
index ac346787e7ba,7416957ba9f4..000000000000
--- a/drivers/s390/cio/chsc.h
+++ b/drivers/s390/cio/chsc.h
@@@ -205,52 -205,8 +205,57 @@@ struct chsc_scm_info 
  
  int chsc_scm_info(struct chsc_scm_info *scm_area, u64 token);
  
++<<<<<<< HEAD
 +struct chsc_brinfo_resume_token {
 +	u64 t1;
 +	u64 t2;
 +} __packed;
 +
 +struct chsc_brinfo_naihdr {
 +	struct chsc_brinfo_resume_token resume_token;
 +	u32:32;
 +	u32 instance;
 +	u32:24;
 +	u8 naids;
 +	u32 reserved[3];
 +} __packed;
 +
 +struct chsc_pnso_area {
 +	struct chsc_header request;
 +	u8:2;
 +	u8 m:1;
 +	u8:5;
 +	u8:2;
 +	u8 ssid:2;
 +	u8 fmt:4;
 +	u16 sch;
 +	u8:8;
 +	u8 cssid;
 +	u16:16;
 +	u8 oc;
 +	u32:24;
 +	struct chsc_brinfo_resume_token resume_token;
 +	u32 n:1;
 +	u32:31;
 +	u32 reserved[3];
 +	struct chsc_header response;
 +	u32:32;
 +	struct chsc_brinfo_naihdr naihdr;
 +	union {
 +		struct qdio_brinfo_entry_l3_ipv6 l3_ipv6[0];
 +		struct qdio_brinfo_entry_l3_ipv4 l3_ipv4[0];
 +		struct qdio_brinfo_entry_l2	 l2[0];
 +	} entries;
 +} __packed;
 +
 +int chsc_pnso_brinfo(struct subchannel_id schid,
 +		struct chsc_pnso_area *brinfo_area,
 +		struct chsc_brinfo_resume_token resume_token,
 +		int cnc);
++=======
+ int chsc_pnso(struct subchannel_id schid, struct chsc_pnso_area *pnso_area,
+ 	      u8 oc, struct chsc_pnso_resume_token resume_token, int cnc);
++>>>>>>> 4fea49a79ece (s390/cio: Add new Operation Code OC3 to PNSO)
  
  int __init chsc_get_cssid(int idx);
  
diff --cc drivers/s390/cio/device_ops.c
index d843285a6428,cdf44f398957..000000000000
--- a/drivers/s390/cio/device_ops.c
+++ b/drivers/s390/cio/device_ops.c
@@@ -699,6 -710,29 +699,32 @@@ void ccw_device_get_schid(struct ccw_de
  }
  EXPORT_SYMBOL_GPL(ccw_device_get_schid);
  
++<<<<<<< HEAD
++=======
+ /**
+  * ccw_device_pnso() - Perform Network-Subchannel Operation
+  * @cdev:		device on which PNSO is performed
+  * @pnso_area:		request and response block for the operation
+  * @oc:			Operation Code
+  * @resume_token:	resume token for multiblock response
+  * @cnc:		Boolean change-notification control
+  *
+  * pnso_area must be allocated by the caller with get_zeroed_page(GFP_KERNEL)
+  *
+  * Returns 0 on success.
+  */
+ int ccw_device_pnso(struct ccw_device *cdev,
+ 		    struct chsc_pnso_area *pnso_area, u8 oc,
+ 		    struct chsc_pnso_resume_token resume_token, int cnc)
+ {
+ 	struct subchannel_id schid;
+ 
+ 	ccw_device_get_schid(cdev, &schid);
+ 	return chsc_pnso(schid, pnso_area, oc, resume_token, cnc);
+ }
+ EXPORT_SYMBOL_GPL(ccw_device_pnso);
+ 
++>>>>>>> 4fea49a79ece (s390/cio: Add new Operation Code OC3 to PNSO)
  /*
   * Allocate zeroed dma coherent 31 bit addressable memory using
   * the subchannels dma pool. Maximal size of allocation supported
diff --cc drivers/s390/net/qeth_l2_main.c
index 88261c8e41f6,2ab130d5c42d..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -669,6 -639,74 +669,77 @@@ static void qeth_l2_set_rx_mode(struct 
  	schedule_work(&card->rx_mode_work);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  *	qeth_l2_pnso() - perform network subchannel operation
+  *	@card: qeth_card structure pointer
+  *	@oc: Operation Code
+  *	@cnc: Boolean Change-Notification Control
+  *	@cb: Callback function will be executed for each element
+  *		of the address list
+  *	@priv: Pointer to pass to the callback function.
+  *
+  *	Collects network information in a network address list and calls the
+  *	callback function for every entry in the list. If "change-notification-
+  *	control" is set, further changes in the address list will be reported
+  *	via the IPA command.
+  */
+ static int qeth_l2_pnso(struct qeth_card *card, u8 oc, int cnc,
+ 			void (*cb)(void *priv, struct chsc_pnso_naid_l2 *entry),
+ 			void *priv)
+ {
+ 	struct ccw_device *ddev = CARD_DDEV(card);
+ 	struct chsc_pnso_area *rr;
+ 	u32 prev_instance = 0;
+ 	int isfirstblock = 1;
+ 	int i, size, elems;
+ 	int rc;
+ 
+ 	rr = (struct chsc_pnso_area *)get_zeroed_page(GFP_KERNEL);
+ 	if (rr == NULL)
+ 		return -ENOMEM;
+ 	do {
+ 		QETH_CARD_TEXT(card, 2, "PNSO");
+ 		/* on the first iteration, naihdr.resume_token will be zero */
+ 		rc = ccw_device_pnso(ddev, rr, oc, rr->naihdr.resume_token,
+ 				     cnc);
+ 		if (rc)
+ 			continue;
+ 		if (cb == NULL)
+ 			continue;
+ 
+ 		size = rr->naihdr.naids;
+ 		if (size != sizeof(struct chsc_pnso_naid_l2)) {
+ 			WARN_ON_ONCE(1);
+ 			continue;
+ 		}
+ 
+ 		elems = (rr->response.length - sizeof(struct chsc_header) -
+ 			 sizeof(struct chsc_pnso_naihdr)) / size;
+ 
+ 		if (!isfirstblock && (rr->naihdr.instance != prev_instance)) {
+ 			/* Inform the caller that they need to scrap */
+ 			/* the data that was already reported via cb */
+ 			rc = -EAGAIN;
+ 			break;
+ 		}
+ 		isfirstblock = 0;
+ 		prev_instance = rr->naihdr.instance;
+ 		for (i = 0; i < elems; i++)
+ 			(*cb)(priv, &rr->entries[i]);
+ 	} while ((rc == -EBUSY) || (!rc && /* list stored */
+ 		   /* resume token is non-zero => list incomplete */
+ 		   (rr->naihdr.resume_token.t1 || rr->naihdr.resume_token.t2)));
+ 
+ 	if (rc)
+ 		QETH_CARD_TEXT_(card, 2, "PNrp%04x", rr->response.code);
+ 
+ 	free_page((unsigned long)rr);
+ 	return rc;
+ }
+ 
++>>>>>>> 4fea49a79ece (s390/cio: Add new Operation Code OC3 to PNSO)
  static const struct net_device_ops qeth_l2_netdev_ops = {
  	.ndo_open		= qeth_open,
  	.ndo_stop		= qeth_stop,
@@@ -1643,11 -1579,16 +1714,24 @@@ int qeth_bridgeport_an_set(struct qeth_
  
  	if (enable) {
  		qeth_bridge_emit_host_event(card, anev_reset, 0, NULL, NULL);
++<<<<<<< HEAD
 +		rc = qdio_pnso_brinfo(schid, 1, &response,
 +			qeth_bridgeport_an_set_cb, card);
 +	} else
 +		rc = qdio_pnso_brinfo(schid, 0, &response, NULL, NULL);
 +	return qeth_anset_makerc(card, rc, response);
++=======
+ 		qeth_l2_set_pnso_mode(card, QETH_PNSO_BRIDGEPORT);
+ 		rc = qeth_l2_pnso(card, PNSO_OC_NET_BRIDGE_INFO, 1,
+ 				  qeth_bridgeport_an_set_cb, card);
+ 		if (rc)
+ 			qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
+ 	} else {
+ 		rc = qeth_l2_pnso(card, PNSO_OC_NET_BRIDGE_INFO, 0, NULL, NULL);
+ 		qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
+ 	}
+ 	return rc;
++>>>>>>> 4fea49a79ece (s390/cio: Add new Operation Code OC3 to PNSO)
  }
  
  static bool qeth_bridgeport_is_in_use(struct qeth_card *card)
* Unmerged path arch/s390/include/asm/chsc.h
* Unmerged path arch/s390/include/asm/ccwdev.h
* Unmerged path arch/s390/include/asm/chsc.h
diff --git a/arch/s390/include/asm/css_chars.h b/arch/s390/include/asm/css_chars.h
index 480bb02ccacd..638137d46c85 100644
--- a/arch/s390/include/asm/css_chars.h
+++ b/arch/s390/include/asm/css_chars.h
@@ -36,7 +36,9 @@ struct css_general_char {
 	u64 alt_ssi : 1; /* bit 108 */
 	u64 : 1;
 	u64 narf : 1;	 /* bit 110 */
-	u64 : 12;
+	u64 : 5;
+	u64 enarf: 1;	 /* bit 116 */
+	u64 : 6;
 	u64 util_str : 1;/* bit 123 */
 } __packed;
 
* Unmerged path drivers/s390/cio/chsc.c
* Unmerged path drivers/s390/cio/chsc.h
* Unmerged path drivers/s390/cio/device_ops.c
* Unmerged path drivers/s390/net/qeth_l2_main.c
