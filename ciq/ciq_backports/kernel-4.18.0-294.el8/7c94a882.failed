s390/qeth: integrate RX refill worker with NAPI

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 7c94a88295008f66e9a0efc1c15d8511f73a0366
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7c94a882.failed

Running a RX refill outside of NAPI context is inherently racy, even
though the worker is only started for an entirely idle RX ring.
>From the moment that the worker has replenished parts of the RX ring,
the HW can use those RX buffers, raise an IRQ and cause our NAPI code to
run concurrently to the RX refill worker.

Instead let the worker schedule our NAPI instance, and refill the RX
ring from there. Keeping accurate count of how many buffers still need
to be refilled also removes some quirky arithmetic from the low-level
code.

Fixes: b333293058aa ("qeth: add support for af_iucv HiperSockets transport")
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7c94a88295008f66e9a0efc1c15d8511f73a0366)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index 245ab75ddf53,c2e44853ac1a..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -5486,26 -5714,43 +5485,31 @@@ walk_packet
  	if (!skb)
  		goto next_packet;
  
 -	*element_no = element - &buffer->element[0];
 +	*__element = element;
  	*__offset = offset;
 -
 -	qeth_receive_skb(card, skb, hdr, uses_frags);
 -	return 0;
 -}
 -
 -static unsigned int qeth_extract_skbs(struct qeth_card *card, int budget,
 -				      struct qeth_qdio_buffer *buf, bool *done)
 -{
 -	unsigned int work_done = 0;
 -
 -	while (budget) {
 -		if (qeth_extract_skb(card, buf, &card->rx.buf_element,
 -				     &card->rx.e_offset)) {
 -			*done = true;
 -			break;
 -		}
 -
 -		work_done++;
 -		budget--;
 +	if (use_rx_sg) {
 +		QETH_CARD_STAT_INC(card, rx_sg_skbs);
 +		QETH_CARD_STAT_ADD(card, rx_sg_frags,
 +				   skb_shinfo(skb)->nr_frags);
  	}
 -
 -	return work_done;
 +	return skb;
  }
 +EXPORT_SYMBOL_GPL(qeth_core_get_next_skb);
  
 -static unsigned int qeth_rx_poll(struct qeth_card *card, int budget)
 +int qeth_poll(struct napi_struct *napi, int budget)
  {
++<<<<<<< HEAD
 +	struct qeth_card *card = container_of(napi, struct qeth_card, napi);
 +	int work_done = 0;
 +	struct qeth_qdio_buffer *buffer;
 +	int done;
 +	int new_budget = budget;
++=======
+ 	struct qeth_rx *ctx = &card->rx;
+ 	unsigned int work_done = 0;
++>>>>>>> 7c94a8829500 (s390/qeth: integrate RX refill worker with NAPI)
  
 -	while (budget > 0) {
 -		struct qeth_qdio_buffer *buffer;
 -		unsigned int skbs_done = 0;
 -		bool done = false;
 -
 -		/* Fetch completed RX buffers: */
 +	while (1) {
  		if (!card->rx.b_count) {
  			card->rx.qdio_err = 0;
  			card->rx.b_count = qdio_get_next_buffers(
@@@ -5515,51 -5760,83 +5519,126 @@@
  				card->rx.b_count = 0;
  				break;
  			}
++<<<<<<< HEAD
 +			card->rx.b_element =
 +				&card->qdio.in_q->bufs[card->rx.b_index]
 +				.buffer->element[0];
++=======
+ 		}
+ 
+ 		/* Process one completed RX buffer: */
+ 		buffer = &card->qdio.in_q->bufs[card->rx.b_index];
+ 		if (!(card->rx.qdio_err &&
+ 		      qeth_check_qdio_errors(card, buffer->buffer,
+ 					     card->rx.qdio_err, "qinerr")))
+ 			skbs_done = qeth_extract_skbs(card, budget, buffer,
+ 						      &done);
+ 		else
+ 			done = true;
+ 
+ 		work_done += skbs_done;
+ 		budget -= skbs_done;
+ 
+ 		if (done) {
+ 			QETH_CARD_STAT_INC(card, rx_bufs);
+ 			qeth_put_buffer_pool_entry(card, buffer->pool_entry);
+ 			buffer->pool_entry = NULL;
+ 			card->rx.b_count--;
+ 			ctx->bufs_refill++;
+ 			ctx->bufs_refill -= qeth_rx_refill_queue(card,
+ 								 ctx->bufs_refill);
+ 
+ 			/* Step forward to next buffer: */
+ 			card->rx.b_index = QDIO_BUFNR(card->rx.b_index + 1);
+ 			card->rx.buf_element = 0;
++>>>>>>> 7c94a8829500 (s390/qeth: integrate RX refill worker with NAPI)
  			card->rx.e_offset = 0;
  		}
 +
 +		while (card->rx.b_count) {
 +			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
 +			if (!(card->rx.qdio_err &&
 +			    qeth_check_qdio_errors(card, buffer->buffer,
 +			    card->rx.qdio_err, "qinerr")))
 +				work_done +=
 +					card->discipline->process_rx_buffer(
 +						card, new_budget, &done);
 +			else
 +				done = 1;
 +
 +			if (done) {
 +				QETH_CARD_STAT_INC(card, rx_bufs);
 +				qeth_put_buffer_pool_entry(card,
 +					buffer->pool_entry);
 +				qeth_queue_input_buffer(card, card->rx.b_index);
 +				card->rx.b_count--;
 +				if (card->rx.b_count) {
 +					card->rx.b_index =
 +						QDIO_BUFNR(card->rx.b_index + 1);
 +					card->rx.b_element =
 +						&card->qdio.in_q
 +						->bufs[card->rx.b_index]
 +						.buffer->element[0];
 +					card->rx.e_offset = 0;
 +				}
 +			}
 +
 +			if (work_done >= budget)
 +				goto out;
 +			else
 +				new_budget = budget - work_done;
 +		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	return work_done;
+ }
+ 
+ static void qeth_cq_poll(struct qeth_card *card)
+ {
+ 	unsigned int work_done = 0;
+ 
+ 	while (work_done < QDIO_MAX_BUFFERS_PER_Q) {
+ 		unsigned int start, error;
+ 		int completed;
+ 
+ 		completed = qdio_inspect_queue(CARD_DDEV(card), 1, true, &start,
+ 					       &error);
+ 		if (completed <= 0)
+ 			return;
+ 
+ 		qeth_qdio_cq_handler(card, error, 1, start, completed);
+ 		work_done += completed;
+ 	}
+ }
+ 
+ int qeth_poll(struct napi_struct *napi, int budget)
+ {
+ 	struct qeth_card *card = container_of(napi, struct qeth_card, napi);
+ 	unsigned int work_done;
+ 
+ 	work_done = qeth_rx_poll(card, budget);
+ 
+ 	if (card->options.cq == QETH_CQ_ENABLED)
+ 		qeth_cq_poll(card);
+ 
+ 	if (budget) {
+ 		struct qeth_rx *ctx = &card->rx;
+ 
+ 		/* Process any substantial refill backlog: */
+ 		ctx->bufs_refill -= qeth_rx_refill_queue(card, ctx->bufs_refill);
+ 
+ 		/* Exhausted the RX budget. Keep IRQ disabled, we get called again. */
+ 		if (work_done >= budget)
+ 			return work_done;
+ 	}
+ 
++>>>>>>> 7c94a8829500 (s390/qeth: integrate RX refill worker with NAPI)
  	if (napi_complete_done(napi, work_done) &&
 -	    qdio_start_irq(CARD_DDEV(card)))
 +	    qdio_start_irq(CARD_DDEV(card), 0))
  		napi_schedule(napi);
 -
 +out:
  	return work_done;
  }
  EXPORT_SYMBOL_GPL(qeth_poll);
@@@ -6692,7 -7018,8 +6771,12 @@@ int qeth_stop(struct net_device *dev
  	}
  
  	napi_disable(&card->napi);
++<<<<<<< HEAD
 +	qdio_stop_irq(CARD_DDEV(card), 0);
++=======
+ 	cancel_delayed_work_sync(&card->buffer_reclaim_work);
+ 	qdio_stop_irq(CARD_DDEV(card));
++>>>>>>> 7c94a8829500 (s390/qeth: integrate RX refill worker with NAPI)
  
  	return 0;
  }
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index e0914cfc0b39..ab015550685a 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -768,6 +768,7 @@ struct qeth_rx {
 	struct qdio_buffer_element *b_element;
 	int e_offset;
 	int qdio_err;
+	u8 bufs_refill;
 };
 
 struct carrier_info {
@@ -832,7 +833,6 @@ struct qeth_card {
 	struct napi_struct napi;
 	struct qeth_rx rx;
 	struct delayed_work buffer_reclaim_work;
-	int reclaim_index;
 	struct work_struct close_dev_work;
 };
 
* Unmerged path drivers/s390/net/qeth_core_main.c
diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c
index 5cada1eb5d2e..7ae10a89cf34 100644
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -288,7 +288,6 @@ static void qeth_l2_stop_card(struct qeth_card *card)
 	}
 	if (card->state == CARD_STATE_HARDSETUP) {
 		qeth_drain_output_queues(card);
-		cancel_delayed_work_sync(&card->buffer_reclaim_work);
 		card->state = CARD_STATE_DOWN;
 	}
 
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index d28d6a60ea7e..d3ffa62b9ec7 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -1265,7 +1265,6 @@ static void qeth_l3_stop_card(struct qeth_card *card)
 	}
 	if (card->state == CARD_STATE_HARDSETUP) {
 		qeth_drain_output_queues(card);
-		cancel_delayed_work_sync(&card->buffer_reclaim_work);
 		card->state = CARD_STATE_DOWN;
 	}
 
