mm: memcontrol: prepare uncharging for removal of private page type counters

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 9f762dbe19b9f16d5df5603d4b93bad391c302bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9f762dbe.failed

The uncharge batching code adds up the anon, file, kmem counts to
determine the total number of pages to uncharge and references to drop.
But the next patches will remove the anon and file counters.

Maintain an aggregate nr_pages in the uncharge_gather struct.

	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Alex Shi <alex.shi@linux.alibaba.com>
	Reviewed-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Balbir Singh <bsingharora@gmail.com>
Link: http://lkml.kernel.org/r/20200508183105.225460-7-hannes@cmpxchg.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9f762dbe19b9f16d5df5603d4b93bad391c302bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index ef707fd00e25,ff45bef46ffe..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -6450,8 -6637,36 +6450,9 @@@ void mem_cgroup_cancel_charge(struct pa
  	cancel_charge(memcg, nr_pages);
  }
  
 -/**
 - * mem_cgroup_charge - charge a newly allocated page to a cgroup
 - * @page: page to charge
 - * @mm: mm context of the victim
 - * @gfp_mask: reclaim mode
 - * @lrucare: page might be on the LRU already
 - *
 - * Try to charge @page to the memcg that @mm belongs to, reclaiming
 - * pages according to @gfp_mask if necessary.
 - *
 - * Returns 0 on success. Otherwise, an error code is returned.
 - */
 -int mem_cgroup_charge(struct page *page, struct mm_struct *mm, gfp_t gfp_mask,
 -		      bool lrucare)
 -{
 -	struct mem_cgroup *memcg;
 -	int ret;
 -
 -	VM_BUG_ON_PAGE(!page->mapping, page);
 -
 -	ret = mem_cgroup_try_charge(page, mm, gfp_mask, &memcg);
 -	if (ret)
 -		return ret;
 -	mem_cgroup_commit_charge(page, memcg, lrucare);
 -	return 0;
 -}
 -
  struct uncharge_gather {
  	struct mem_cgroup *memcg;
+ 	unsigned long nr_pages;
  	unsigned long pgpgout;
  	unsigned long nr_anon;
  	unsigned long nr_file;
@@@ -6496,9 -6710,9 +6496,11 @@@ static void uncharge_batch(const struc
  
  static void uncharge_page(struct page *page, struct uncharge_gather *ug)
  {
+ 	unsigned long nr_pages;
+ 
  	VM_BUG_ON_PAGE(PageLRU(page), page);
 +	VM_BUG_ON_PAGE(page_count(page) && !is_zone_device_page(page) &&
 +			!PageHWPoison(page) , page);
  
  	if (!page->mem_cgroup)
  		return;
@@@ -6517,13 -6731,12 +6519,17 @@@
  		ug->memcg = page->mem_cgroup;
  	}
  
- 	if (!PageKmemcg(page)) {
- 		unsigned int nr_pages = 1;
+ 	nr_pages = compound_nr(page);
+ 	ug->nr_pages += nr_pages;
  
++<<<<<<< HEAD
 +		if (PageTransHuge(page)) {
 +			nr_pages <<= compound_order(page);
++=======
+ 	if (!PageKmemcg(page)) {
+ 		if (PageTransHuge(page))
++>>>>>>> 9f762dbe19b9 (mm: memcontrol: prepare uncharging for removal of private page type counters)
  			ug->nr_huge += nr_pages;
- 		}
  		if (PageAnon(page))
  			ug->nr_anon += nr_pages;
  		else {
@@@ -6533,7 -6746,7 +6539,11 @@@
  		}
  		ug->pgpgout++;
  	} else {
++<<<<<<< HEAD
 +		ug->nr_kmem += 1 << compound_order(page);
++=======
+ 		ug->nr_kmem += nr_pages;
++>>>>>>> 9f762dbe19b9 (mm: memcontrol: prepare uncharging for removal of private page type counters)
  		__ClearPageKmemcg(page);
  	}
  
* Unmerged path mm/memcontrol.c
