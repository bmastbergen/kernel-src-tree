device connection: Remove struct device_connection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit f5514c91e9f72b719bfec64af6acac5ad41df7b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f5514c91.failed

Since the connection descriptors can't be stored into the
list anymore, there is no need for the data structure.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Link: https://lore.kernel.org/r/20200904125123.83725-4-heikki.krogerus@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit f5514c91e9f72b719bfec64af6acac5ad41df7b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/roles/class.c
#	drivers/usb/typec/mux.c
#	include/linux/device.h
diff --cc drivers/usb/roles/class.c
index b56d36bfbaaf,97f37077b7f9..000000000000
--- a/drivers/usb/roles/class.c
+++ b/drivers/usb/roles/class.c
@@@ -85,25 -87,15 +85,32 @@@ enum usb_role usb_role_switch_get_role(
  }
  EXPORT_SYMBOL_GPL(usb_role_switch_get_role);
  
++<<<<<<< HEAD
 +static int switch_fwnode_match(struct device *dev, const void *fwnode)
 +{
 +	return dev_fwnode(dev) == fwnode;
 +}
 +
 +static void *usb_role_switch_match(struct device_connection *con, int ep,
++=======
+ static void *usb_role_switch_match(struct fwnode_handle *fwnode, const char *id,
++>>>>>>> f5514c91e9f7 (device connection: Remove struct device_connection)
  				   void *data)
  {
  	struct device *dev;
  
- 	if (con->fwnode) {
- 		if (con->id && !fwnode_property_present(con->fwnode, con->id))
- 			return NULL;
+ 	if (id && !fwnode_property_present(fwnode, id))
+ 		return NULL;
  
++<<<<<<< HEAD
 +		dev = class_find_device(role_class, NULL, con->fwnode,
 +					switch_fwnode_match);
 +	} else {
 +		dev = class_find_device_by_name(role_class, con->endpoint[ep]);
 +	}
++=======
+ 	dev = class_find_device_by_fwnode(role_class, fwnode);
++>>>>>>> f5514c91e9f7 (device connection: Remove struct device_connection)
  
  	return dev ? to_role_switch(dev) : ERR_PTR(-EPROBE_DEFER);
  }
diff --cc drivers/usb/typec/mux.c
index 405d14dbac99,b069a5122aaa..000000000000
--- a/drivers/usb/typec/mux.c
+++ b/drivers/usb/typec/mux.c
@@@ -15,35 -15,37 +15,43 @@@
  #include <linux/slab.h>
  #include <linux/usb/typec_mux.h>
  
 -#include "bus.h"
 -
 -static bool dev_name_ends_with(struct device *dev, const char *suffix)
 -{
 -	const char *name = dev_name(dev);
 -	const int name_len = strlen(name);
 -	const int suffix_len = strlen(suffix);
 -
 -	if (suffix_len > name_len)
 -		return false;
 -
 -	return strcmp(name + (name_len - suffix_len), suffix) == 0;
 -}
 -
 -static int switch_fwnode_match(struct device *dev, const void *fwnode)
 -{
 -	return dev_fwnode(dev) == fwnode && dev_name_ends_with(dev, "-switch");
 -}
 +static DEFINE_MUTEX(switch_lock);
 +static DEFINE_MUTEX(mux_lock);
 +static LIST_HEAD(switch_list);
 +static LIST_HEAD(mux_list);
  
- static void *typec_switch_match(struct device_connection *con, int ep,
+ static void *typec_switch_match(struct fwnode_handle *fwnode, const char *id,
  				void *data)
  {
 -	struct device *dev;
 +	struct typec_switch *sw;
  
++<<<<<<< HEAD
 +	if (!con->fwnode) {
 +		list_for_each_entry(sw, &switch_list, entry)
 +			if (!strcmp(con->endpoint[ep], dev_name(sw->dev)))
 +				return sw;
 +		return ERR_PTR(-EPROBE_DEFER);
 +	}
 +
 +	/*
 +	 * With OF graph the mux node must have a boolean device property named
 +	 * "orientation-switch".
 +	 */
 +	if (con->id && !fwnode_property_present(con->fwnode, con->id))
 +		return NULL;
 +
 +	list_for_each_entry(sw, &switch_list, entry)
 +		if (dev_fwnode(sw->dev) == con->fwnode)
 +			return sw;
++=======
+ 	if (id && !fwnode_property_present(fwnode, id))
+ 		return NULL;
+ 
+ 	dev = class_find_device(&typec_mux_class, NULL, fwnode,
+ 				switch_fwnode_match);
++>>>>>>> f5514c91e9f7 (device connection: Remove struct device_connection)
  
 -	return dev ? to_typec_switch(dev) : ERR_PTR(-EPROBE_DEFER);
 +	return con->id ? ERR_PTR(-EPROBE_DEFER) : NULL;
  }
  
  /**
@@@ -120,14 -164,32 +128,24 @@@ void typec_switch_unregister(struct typ
  }
  EXPORT_SYMBOL_GPL(typec_switch_unregister);
  
 -void typec_switch_set_drvdata(struct typec_switch *sw, void *data)
 -{
 -	dev_set_drvdata(&sw->dev, data);
 -}
 -EXPORT_SYMBOL_GPL(typec_switch_set_drvdata);
 -
 -void *typec_switch_get_drvdata(struct typec_switch *sw)
 -{
 -	return dev_get_drvdata(&sw->dev);
 -}
 -EXPORT_SYMBOL_GPL(typec_switch_get_drvdata);
 -
  /* ------------------------------------------------------------------------- */
  
++<<<<<<< HEAD
 +static void *typec_mux_match(struct device_connection *con, int ep, void *data)
++=======
+ static int mux_fwnode_match(struct device *dev, const void *fwnode)
+ {
+ 	return dev_fwnode(dev) == fwnode && dev_name_ends_with(dev, "-mux");
+ }
+ 
+ static void *typec_mux_match(struct fwnode_handle *fwnode, const char *id,
+ 			     void *data)
++>>>>>>> f5514c91e9f7 (device connection: Remove struct device_connection)
  {
  	const struct typec_altmode_desc *desc = data;
 -	struct device *dev;
 -	bool match;
 +	struct typec_mux *mux;
  	int nval;
 +	bool match;
  	u16 *val;
  	int i;
  
@@@ -180,11 -235,10 +198,16 @@@
  	return NULL;
  
  find_mux:
++<<<<<<< HEAD
 +	list_for_each_entry(mux, &mux_list, entry)
 +		if (dev_fwnode(mux->dev) == con->fwnode)
 +			return mux;
++=======
+ 	dev = class_find_device(&typec_mux_class, NULL, fwnode,
+ 				mux_fwnode_match);
++>>>>>>> f5514c91e9f7 (device connection: Remove struct device_connection)
  
 -	return dev ? to_typec_switch(dev) : ERR_PTR(-EPROBE_DEFER);
 +	return ERR_PTR(-EPROBE_DEFER);
  }
  
  /**
diff --cc include/linux/device.h
index 00d8e9c254e7,d4612efaab82..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -920,25 -292,7 +920,29 @@@ struct device_dma_parameters 
  	unsigned long segment_boundary_mask;
  };
  
++<<<<<<< HEAD
 +/**
 + * struct device_connection - Device Connection Descriptor
 + * @fwnode: The device node of the connected device
 + * @endpoint: The names of the two devices connected together
 + * @id: Unique identifier for the connection
 + * @list: List head, private, for internal use only
 + *
 + * NOTE: @fwnode is not used together with @endpoint. @fwnode is used when
 + * platform firmware defines the connection. When the connection is registered
 + * with device_connection_add() @endpoint is used instead.
 + */
 +struct device_connection {
 +	struct fwnode_handle	*fwnode;
 +	const char		*endpoint[2];
 +	const char		*id;
 +	struct list_head	list;
 +};
 +
 +typedef void *(*devcon_match_fn_t)(struct device_connection *con, int ep,
++=======
+ typedef void *(*devcon_match_fn_t)(struct fwnode_handle *fwnode, const char *id,
++>>>>>>> f5514c91e9f7 (device connection: Remove struct device_connection)
  				   void *data);
  
  void *fwnode_connection_find_match(struct fwnode_handle *fwnode,
diff --git a/drivers/base/devcon.c b/drivers/base/devcon.c
index 5bf9537bd738..0f2b28bc7199 100644
--- a/drivers/base/devcon.c
+++ b/drivers/base/devcon.c
@@ -16,17 +16,17 @@ static void *
 fwnode_graph_devcon_match(struct fwnode_handle *fwnode, const char *con_id,
 			  void *data, devcon_match_fn_t match)
 {
-	struct device_connection con = { .id = con_id };
+	struct fwnode_handle *node;
 	struct fwnode_handle *ep;
 	void *ret;
 
 	fwnode_graph_for_each_endpoint(fwnode, ep) {
-		con.fwnode = fwnode_graph_get_remote_port_parent(ep);
-		if (!fwnode_device_is_available(con.fwnode))
+		node = fwnode_graph_get_remote_port_parent(ep);
+		if (!fwnode_device_is_available(node))
 			continue;
 
-		ret = match(&con, -1, data);
-		fwnode_handle_put(con.fwnode);
+		ret = match(node, con_id, data);
+		fwnode_handle_put(node);
 		if (ret) {
 			fwnode_handle_put(ep);
 			return ret;
@@ -39,17 +39,17 @@ static void *
 fwnode_devcon_match(struct fwnode_handle *fwnode, const char *con_id,
 		    void *data, devcon_match_fn_t match)
 {
-	struct device_connection con = { };
+	struct fwnode_handle *node;
 	void *ret;
 	int i;
 
 	for (i = 0; ; i++) {
-		con.fwnode = fwnode_find_reference(fwnode, con_id, i);
-		if (IS_ERR(con.fwnode))
+		node = fwnode_find_reference(fwnode, con_id, i);
+		if (IS_ERR(node))
 			break;
 
-		ret = match(&con, -1, data);
-		fwnode_handle_put(con.fwnode);
+		ret = match(node, NULL, data);
+		fwnode_handle_put(node);
 		if (ret)
 			return ret;
 	}
* Unmerged path drivers/usb/roles/class.c
* Unmerged path drivers/usb/typec/mux.c
* Unmerged path include/linux/device.h
