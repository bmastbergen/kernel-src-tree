powerpc/watchpoint: Fix handling of vector instructions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ravi Bangoria <ravi.bangoria@linux.ibm.com>
commit 4441eb02333a9b46a0d919aa7a6d3b137b5f2562
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4441eb02.failed

Vector load/store instructions are special because they are always
aligned. Thus unaligned EA needs to be aligned down before comparing
it with watch ranges. Otherwise we might consider valid event as
invalid.

Fixes: 74c6881019b7 ("powerpc/watchpoint: Prepare handler to handle more than one watchpoint")
	Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200902042945.129369-3-ravi.bangoria@linux.ibm.com
(cherry picked from commit 4441eb02333a9b46a0d919aa7a6d3b137b5f2562)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/hw_breakpoint.c
diff --cc arch/powerpc/kernel/hw_breakpoint.c
index 90c5c77a5704,f6b24838ca3c..000000000000
--- a/arch/powerpc/kernel/hw_breakpoint.c
+++ b/arch/powerpc/kernel/hw_breakpoint.c
@@@ -444,35 -536,148 +444,44 @@@ dar_range_overlaps(unsigned long dar, i
  }
  
  /*
 - * If hw has multiple DAWR registers, we also need to check all
 - * dawrx constraint bits to confirm this is _really_ a valid event.
 - * If type is UNKNOWN, but privilege level matches, consider it as
 - * a positive match.
 - */
 -static bool check_dawrx_constraints(struct pt_regs *regs, int type,
 -				    struct arch_hw_breakpoint *info)
 -{
 -	if (OP_IS_LOAD(type) && !(info->type & HW_BRK_TYPE_READ))
 -		return false;
 -
 -	/*
 -	 * The Cache Management instructions other than dcbz never
 -	 * cause a match. i.e. if type is CACHEOP, the instruction
 -	 * is dcbz, and dcbz is treated as Store.
 -	 */
 -	if ((OP_IS_STORE(type) || type == CACHEOP) && !(info->type & HW_BRK_TYPE_WRITE))
 -		return false;
 -
 -	if (is_kernel_addr(regs->nip) && !(info->type & HW_BRK_TYPE_KERNEL))
 -		return false;
 -
 -	if (user_mode(regs) && !(info->type & HW_BRK_TYPE_USER))
 -		return false;
 -
 -	return true;
 -}
 -
 -/*
 - * Return true if the event is valid wrt dawr configuration,
 - * including extraneous exception. Otherwise return false.
 + * Handle debug exception notifications.
   */
 -static bool check_constraints(struct pt_regs *regs, struct ppc_inst instr,
 -			      unsigned long ea, int type, int size,
 -			      struct arch_hw_breakpoint *info)
 -{
 -	bool in_user_range = dar_in_user_range(regs->dar, info);
 -	bool dawrx_constraints;
 -
 -	/*
 -	 * 8xx supports only one breakpoint and thus we can
 -	 * unconditionally return true.
 -	 */
 -	if (IS_ENABLED(CONFIG_PPC_8xx)) {
 -		if (!in_user_range)
 -			info->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;
 -		return true;
 -	}
 -
 -	if (unlikely(ppc_inst_equal(instr, ppc_inst(0)))) {
 -		if (cpu_has_feature(CPU_FTR_ARCH_31) &&
 -		    !dar_in_hw_range(regs->dar, info))
 -			return false;
 -
 -		return true;
 -	}
 -
 -	dawrx_constraints = check_dawrx_constraints(regs, type, info);
 -
 -	if (type == UNKNOWN) {
 -		if (cpu_has_feature(CPU_FTR_ARCH_31) &&
 -		    !dar_in_hw_range(regs->dar, info))
 -			return false;
 -
 -		return dawrx_constraints;
 -	}
 -
 -	if (ea_user_range_overlaps(ea, size, info))
 -		return dawrx_constraints;
 -
 -	if (ea_hw_range_overlaps(ea, size, info)) {
 -		if (dawrx_constraints) {
 -			info->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;
 -			return true;
 -		}
 -	}
 -	return false;
 -}
 -
 -static int cache_op_size(void)
 -{
 -#ifdef __powerpc64__
 -	return ppc64_caches.l1d.block_size;
 -#else
 -	return L1_CACHE_BYTES;
 -#endif
 -}
 -
 -static void get_instr_detail(struct pt_regs *regs, struct ppc_inst *instr,
 -			     int *type, int *size, unsigned long *ea)
 +static bool stepping_handler(struct pt_regs *regs, struct perf_event *bp,
 +			     struct arch_hw_breakpoint *info)
  {
 +	unsigned int instr = 0;
 +	int ret, type, size;
  	struct instruction_op op;
 +	unsigned long addr = info->address;
  
 -	if (__get_user_instr_inatomic(*instr, (void __user *)regs->nip))
 -		return;
 +	if (__get_user_inatomic(instr, (unsigned int *)regs->nip))
 +		goto fail;
  
 -	analyse_instr(&op, regs, *instr);
 -	*type = GETTYPE(op.type);
 -	*ea = op.ea;
 -#ifdef __powerpc64__
 -	if (!(regs->msr & MSR_64BIT))
 -		*ea &= 0xffffffffUL;
 -#endif
 +	ret = analyse_instr(&op, regs, instr);
 +	type = GETTYPE(op.type);
 +	size = GETSIZE(op.type);
  
++<<<<<<< HEAD
 +	if (!ret && (type == LARX || type == STCX)) {
 +		printk_ratelimited("Breakpoint hit on instruction that can't be emulated."
 +				   " Breakpoint at 0x%lx will be disabled.\n", addr);
 +		goto disable;
++=======
+ 	*size = GETSIZE(op.type);
+ 	if (*type == CACHEOP) {
+ 		*size = cache_op_size();
+ 		*ea &= ~(*size - 1);
+ 	} else if (*type == LOAD_VMX || *type == STORE_VMX) {
+ 		*ea &= ~(*size - 1);
++>>>>>>> 4441eb02333a (powerpc/watchpoint: Fix handling of vector instructions)
  	}
 -}
 -
 -static bool is_larx_stcx_instr(int type)
 -{
 -	return type == LARX || type == STCX;
 -}
 -
 -/*
 - * We've failed in reliably handling the hw-breakpoint. Unregister
 - * it and throw a warning message to let the user know about it.
 - */
 -static void handler_error(struct perf_event *bp, struct arch_hw_breakpoint *info)
 -{
 -	WARN(1, "Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.",
 -	     info->address);
 -	perf_event_disable_inatomic(bp);
 -}
 -
 -static void larx_stcx_err(struct perf_event *bp, struct arch_hw_breakpoint *info)
 -{
 -	printk_ratelimited("Breakpoint hit on instruction that can't be emulated. Breakpoint at 0x%lx will be disabled.\n",
 -			   info->address);
 -	perf_event_disable_inatomic(bp);
 -}
  
 -static bool stepping_handler(struct pt_regs *regs, struct perf_event **bp,
 -			     struct arch_hw_breakpoint **info, int *hit,
 -			     struct ppc_inst instr)
 -{
 -	int i;
 -	int stepped;
 +	/*
 +	 * If it's extraneous event, we still need to emulate/single-
 +	 * step the instruction, but we don't generate an event.
 +	 */
 +	if (size && !dar_range_overlaps(regs->dar, size, info))
 +		info->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;
  
  	/* Do not emulate user-space instructions, instead single-step them */
  	if (user_mode(regs)) {
* Unmerged path arch/powerpc/kernel/hw_breakpoint.c
