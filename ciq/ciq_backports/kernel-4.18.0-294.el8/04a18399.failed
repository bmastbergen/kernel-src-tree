net: aquantia: implement data PTP datapath

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Egor Pomozov <epomozov@marvell.com>
commit 04a1839950d92ab6519479bc95710e89ae6cbc77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/04a18399.failed

Here we do alloc/free IRQs for PTP rings.
We also implement processing of PTP packets on TX and RX sides.

	Signed-off-by: Egor Pomozov <epomozov@marvell.com>
Co-developed-by: Sergey Samoilenko <sergey.samoilenko@aquantia.com>
	Signed-off-by: Sergey Samoilenko <sergey.samoilenko@aquantia.com>
Co-developed-by: Dmitry Bezrukov <dmitry.bezrukov@aquantia.com>
	Signed-off-by: Dmitry Bezrukov <dmitry.bezrukov@aquantia.com>
	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 04a1839950d92ab6519479bc95710e89ae6cbc77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_cfg.h
#	drivers/net/ethernet/aquantia/atlantic/aq_hw.h
#	drivers/net/ethernet/aquantia/atlantic/aq_main.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_cfg.h
index d890c36d302b,8c633caf79d2..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_cfg.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_cfg.h
@@@ -1,10 -1,7 +1,14 @@@
 -/* SPDX-License-Identifier: GPL-2.0-only */
  /*
   * aQuantia Corporation Network Driver
++<<<<<<< HEAD
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+  * Copyright (C) 2014-2019 aQuantia Corporation. All rights reserved
++>>>>>>> 04a1839950d9 (net: aquantia: implement data PTP datapath)
   */
  
  /* File aq_cfg.h: Definition of configuration parameters and constants. */
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 5c8995ae94b5,5b0f42818033..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@@ -238,6 -240,30 +238,33 @@@ struct aq_hw_ops 
  	int (*hw_set_offload)(struct aq_hw_s *self,
  			      struct aq_nic_cfg_s *aq_nic_cfg);
  
++<<<<<<< HEAD
++=======
+ 	int (*hw_tx_tc_mode_get)(struct aq_hw_s *self, u32 *tc_mode);
+ 
+ 	int (*hw_rx_tc_mode_get)(struct aq_hw_s *self, u32 *tc_mode);
+ 
+ 	int (*hw_ring_hwts_rx_fill)(struct aq_hw_s *self,
+ 				    struct aq_ring_s *aq_ring);
+ 
+ 	int (*hw_ring_hwts_rx_receive)(struct aq_hw_s *self,
+ 				       struct aq_ring_s *ring);
+ 
+ 	void (*hw_get_ptp_ts)(struct aq_hw_s *self, u64 *stamp);
+ 
+ 	int (*hw_adj_clock_freq)(struct aq_hw_s *self, s32 delta);
+ 
+ 	int (*hw_adj_sys_clock)(struct aq_hw_s *self, s64 delta);
+ 
+ 	int (*hw_set_sys_clock)(struct aq_hw_s *self, u64 time, u64 ts);
+ 
+ 	u16 (*rx_extract_ts)(struct aq_hw_s *self, u8 *p, unsigned int len,
+ 			     u64 *timestamp);
+ 
+ 	int (*extract_hwts)(struct aq_hw_s *self, u8 *p, unsigned int len,
+ 			    u64 *timestamp);
+ 
++>>>>>>> 04a1839950d9 (net: aquantia: implement data PTP datapath)
  	int (*hw_set_fc)(struct aq_hw_s *self, u32 fc, u32 tc);
  };
  
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_main.c
index 25a59894105a,f630032af8e1..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_main.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_main.c
@@@ -1,10 -1,7 +1,14 @@@
 -// SPDX-License-Identifier: GPL-2.0-only
  /*
   * aQuantia Corporation Network Driver
++<<<<<<< HEAD
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+  * Copyright (C) 2014-2019 aQuantia Corporation. All rights reserved
++>>>>>>> 04a1839950d9 (net: aquantia: implement data PTP datapath)
   */
  
  /* File aq_main.c: Main file for aQuantia Linux driver. */
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index 0035792b0cff,65384f45805f..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -146,6 -146,12 +146,15 @@@ static int aq_nic_update_link_status(st
  			self->aq_hw->aq_link_status.mbps);
  		aq_nic_update_interrupt_moderation_settings(self);
  
++<<<<<<< HEAD
++=======
+ 		if (self->aq_ptp) {
+ 			aq_ptp_clock_init(self);
+ 			aq_ptp_tm_offset_set(self,
+ 					     self->aq_hw->aq_link_status.mbps);
+ 		}
+ 
++>>>>>>> 04a1839950d9 (net: aquantia: implement data PTP datapath)
  		/* Driver has to update flow control settings on RX block
  		 * on any link event.
  		 * We should query FW whether it negotiated FC.
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
index 9cb0864d6d8d,e82c96b50373..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
@@@ -1,10 -1,7 +1,14 @@@
 -// SPDX-License-Identifier: GPL-2.0-only
  /*
   * aQuantia Corporation Network Driver
++<<<<<<< HEAD
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+  * Copyright (C) 2014-2019 aQuantia Corporation. All rights reserved
++>>>>>>> 04a1839950d9 (net: aquantia: implement data PTP datapath)
   */
  
  /* File aq_pci_func.c: Definition of PCI functions. */
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.h
index cfffc301e746,be3702a4dcc9..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
@@@ -174,4 -174,9 +174,12 @@@ int aq_ring_rx_clean(struct aq_ring_s *
  		     int budget);
  int aq_ring_rx_fill(struct aq_ring_s *self);
  
++<<<<<<< HEAD
++=======
+ struct aq_ring_s *aq_ring_hwts_rx_alloc(struct aq_ring_s *self,
+ 		struct aq_nic_s *aq_nic, unsigned int idx,
+ 		unsigned int size, unsigned int dx_size);
+ void aq_ring_hwts_rx_clean(struct aq_ring_s *self, struct aq_nic_s *aq_nic);
+ 
++>>>>>>> 04a1839950d9 (net: aquantia: implement data PTP datapath)
  #endif /* AQ_RING_H */
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index 42fdeb412b12,bd9e5a598657..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -978,6 -1063,171 +1018,174 @@@ static int hw_atl_b0_hw_ring_rx_stop(st
  	return aq_hw_err_from_flags(self);
  }
  
++<<<<<<< HEAD
++=======
+ static int hw_atl_b0_tx_tc_mode_get(struct aq_hw_s *self, u32 *tc_mode)
+ {
+ 	*tc_mode = hw_atl_rpb_tps_tx_tc_mode_get(self);
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
+ static int hw_atl_b0_rx_tc_mode_get(struct aq_hw_s *self, u32 *tc_mode)
+ {
+ 	*tc_mode = hw_atl_rpb_rpf_rx_traf_class_mode_get(self);
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
+ #define get_ptp_ts_val_u64(self, indx) \
+ 	((u64)(hw_atl_pcs_ptp_clock_get(self, indx) & 0xffff))
+ 
+ static void hw_atl_b0_get_ptp_ts(struct aq_hw_s *self, u64 *stamp)
+ {
+ 	u64 ns;
+ 
+ 	hw_atl_pcs_ptp_clock_read_enable(self, 1);
+ 	hw_atl_pcs_ptp_clock_read_enable(self, 0);
+ 	ns = (get_ptp_ts_val_u64(self, 0) +
+ 	      (get_ptp_ts_val_u64(self, 1) << 16)) * NSEC_PER_SEC +
+ 	     (get_ptp_ts_val_u64(self, 3) +
+ 	      (get_ptp_ts_val_u64(self, 4) << 16));
+ 
+ 	*stamp = ns + self->ptp_clk_offset;
+ }
+ 
+ static void hw_atl_b0_adj_params_get(u64 freq, s64 adj, u32 *ns, u32 *fns)
+ {
+ 	/* For accuracy, the digit is extended */
+ 	s64 base_ns = ((adj + NSEC_PER_SEC) * NSEC_PER_SEC);
+ 	u64 nsi_frac = 0;
+ 	u64 nsi;
+ 
+ 	base_ns = div64_s64(base_ns, freq);
+ 	nsi = div64_u64(base_ns, NSEC_PER_SEC);
+ 
+ 	if (base_ns != nsi * NSEC_PER_SEC) {
+ 		s64 divisor = div64_s64((s64)NSEC_PER_SEC * NSEC_PER_SEC,
+ 					base_ns - nsi * NSEC_PER_SEC);
+ 		nsi_frac = div64_s64(FRAC_PER_NS * NSEC_PER_SEC, divisor);
+ 	}
+ 
+ 	*ns = (u32)nsi;
+ 	*fns = (u32)nsi_frac;
+ }
+ 
+ static void
+ hw_atl_b0_mac_adj_param_calc(struct hw_fw_request_ptp_adj_freq *ptp_adj_freq,
+ 			     u64 phyfreq, u64 macfreq)
+ {
+ 	s64 adj_fns_val;
+ 	s64 fns_in_sec_phy = phyfreq * (ptp_adj_freq->fns_phy +
+ 					FRAC_PER_NS * ptp_adj_freq->ns_phy);
+ 	s64 fns_in_sec_mac = macfreq * (ptp_adj_freq->fns_mac +
+ 					FRAC_PER_NS * ptp_adj_freq->ns_mac);
+ 	s64 fault_in_sec_phy = FRAC_PER_NS * NSEC_PER_SEC - fns_in_sec_phy;
+ 	s64 fault_in_sec_mac = FRAC_PER_NS * NSEC_PER_SEC - fns_in_sec_mac;
+ 	/* MAC MCP counter freq is macfreq / 4 */
+ 	s64 diff_in_mcp_overflow = (fault_in_sec_mac - fault_in_sec_phy) *
+ 				   4 * FRAC_PER_NS;
+ 
+ 	diff_in_mcp_overflow = div64_s64(diff_in_mcp_overflow,
+ 					 AQ_HW_MAC_COUNTER_HZ);
+ 	adj_fns_val = (ptp_adj_freq->fns_mac + FRAC_PER_NS *
+ 		       ptp_adj_freq->ns_mac) + diff_in_mcp_overflow;
+ 
+ 	ptp_adj_freq->mac_ns_adj = div64_s64(adj_fns_val, FRAC_PER_NS);
+ 	ptp_adj_freq->mac_fns_adj = adj_fns_val - ptp_adj_freq->mac_ns_adj *
+ 				    FRAC_PER_NS;
+ }
+ 
+ static int hw_atl_b0_adj_sys_clock(struct aq_hw_s *self, s64 delta)
+ {
+ 	self->ptp_clk_offset += delta;
+ 
+ 	return 0;
+ }
+ 
+ static int hw_atl_b0_set_sys_clock(struct aq_hw_s *self, u64 time, u64 ts)
+ {
+ 	s64 delta = time - (self->ptp_clk_offset + ts);
+ 
+ 	return hw_atl_b0_adj_sys_clock(self, delta);
+ }
+ 
+ static int hw_atl_b0_adj_clock_freq(struct aq_hw_s *self, s32 ppb)
+ {
+ 	struct hw_fw_request_iface fwreq;
+ 	size_t size;
+ 
+ 	memset(&fwreq, 0, sizeof(fwreq));
+ 
+ 	fwreq.msg_id = HW_AQ_FW_REQUEST_PTP_ADJ_FREQ;
+ 	hw_atl_b0_adj_params_get(AQ_HW_MAC_COUNTER_HZ, ppb,
+ 				 &fwreq.ptp_adj_freq.ns_mac,
+ 				 &fwreq.ptp_adj_freq.fns_mac);
+ 	hw_atl_b0_adj_params_get(AQ_HW_PHY_COUNTER_HZ, ppb,
+ 				 &fwreq.ptp_adj_freq.ns_phy,
+ 				 &fwreq.ptp_adj_freq.fns_phy);
+ 	hw_atl_b0_mac_adj_param_calc(&fwreq.ptp_adj_freq,
+ 				     AQ_HW_PHY_COUNTER_HZ,
+ 				     AQ_HW_MAC_COUNTER_HZ);
+ 
+ 	size = sizeof(fwreq.msg_id) + sizeof(fwreq.ptp_adj_freq);
+ 	return self->aq_fw_ops->send_fw_request(self, &fwreq, size);
+ }
+ 
+ static u16 hw_atl_b0_rx_extract_ts(struct aq_hw_s *self, u8 *p,
+ 				   unsigned int len, u64 *timestamp)
+ {
+ 	unsigned int offset = 14;
+ 	struct ethhdr *eth;
+ 	u64 sec;
+ 	u8 *ptr;
+ 	u32 ns;
+ 
+ 	if (len <= offset || !timestamp)
+ 		return 0;
+ 
+ 	/* The TIMESTAMP in the end of package has following format:
+ 	 * (big-endian)
+ 	 *   struct {
+ 	 *     uint64_t sec;
+ 	 *     uint32_t ns;
+ 	 *     uint16_t stream_id;
+ 	 *   };
+ 	 */
+ 	ptr = p + (len - offset);
+ 	memcpy(&sec, ptr, sizeof(sec));
+ 	ptr += sizeof(sec);
+ 	memcpy(&ns, ptr, sizeof(ns));
+ 
+ 	sec = be64_to_cpu(sec) & 0xffffffffffffllu;
+ 	ns = be32_to_cpu(ns);
+ 	*timestamp = sec * NSEC_PER_SEC + ns + self->ptp_clk_offset;
+ 
+ 	eth = (struct ethhdr *)p;
+ 
+ 	return (eth->h_proto == htons(ETH_P_1588)) ? 12 : 14;
+ }
+ 
+ static int hw_atl_b0_extract_hwts(struct aq_hw_s *self, u8 *p, unsigned int len,
+ 				  u64 *timestamp)
+ {
+ 	struct hw_atl_rxd_hwts_wb_s *hwts_wb = (struct hw_atl_rxd_hwts_wb_s *)p;
+ 	u64 tmp, sec, ns;
+ 
+ 	sec = 0;
+ 	tmp = (hwts_wb->sec_lw0 >> 2) & 0x3ff;
+ 	sec += tmp;
+ 	tmp = (u64)((hwts_wb->sec_lw1 >> 16) & 0xffff) << 10;
+ 	sec += tmp;
+ 	tmp = (u64)(hwts_wb->sec_hw & 0xfff) << 26;
+ 	sec += tmp;
+ 	tmp = (u64)((hwts_wb->sec_hw >> 22) & 0x3ff) << 38;
+ 	sec += tmp;
+ 	ns = sec * NSEC_PER_SEC + hwts_wb->ns;
+ 	if (timestamp)
+ 		*timestamp = ns + self->ptp_clk_offset;
+ 	return 0;
+ }
+ 
++>>>>>>> 04a1839950d9 (net: aquantia: implement data PTP datapath)
  static int hw_atl_b0_hw_fl3l4_clear(struct aq_hw_s *self,
  				    struct aq_rx_filter_l3l4 *data)
  {
@@@ -1150,6 -1400,20 +1358,24 @@@ const struct aq_hw_ops hw_atl_ops_b0 = 
  	.hw_get_regs                 = hw_atl_utils_hw_get_regs,
  	.hw_get_hw_stats             = hw_atl_utils_get_hw_stats,
  	.hw_get_fw_version           = hw_atl_utils_get_fw_version,
++<<<<<<< HEAD
 +	.hw_set_offload              = hw_atl_b0_hw_offload_set,
++=======
+ 
+ 	.hw_tx_tc_mode_get       = hw_atl_b0_tx_tc_mode_get,
+ 	.hw_rx_tc_mode_get       = hw_atl_b0_rx_tc_mode_get,
+ 
+ 	.hw_ring_hwts_rx_fill        = hw_atl_b0_hw_ring_hwts_rx_fill,
+ 	.hw_ring_hwts_rx_receive     = hw_atl_b0_hw_ring_hwts_rx_receive,
+ 
+ 	.hw_get_ptp_ts           = hw_atl_b0_get_ptp_ts,
+ 	.hw_adj_sys_clock        = hw_atl_b0_adj_sys_clock,
+ 	.hw_set_sys_clock        = hw_atl_b0_set_sys_clock,
+ 	.hw_adj_clock_freq       = hw_atl_b0_adj_clock_freq,
+ 
+ 	.rx_extract_ts           = hw_atl_b0_rx_extract_ts,
+ 	.extract_hwts            = hw_atl_b0_extract_hwts,
+ 	.hw_set_offload          = hw_atl_b0_hw_offload_set,
++>>>>>>> 04a1839950d9 (net: aquantia: implement data PTP datapath)
  	.hw_set_fc                   = hw_atl_b0_set_fc,
  };
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_cfg.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_hw.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_main.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
index c80d38f5e889..bae69b6c7f86 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
@@ -54,6 +54,7 @@ struct aq_nic_cfg_s {
 #define AQ_NIC_FLAG_STOPPING    0x00000008U
 #define AQ_NIC_FLAG_RESETTING   0x00000010U
 #define AQ_NIC_FLAG_CLOSING     0x00000020U
+#define AQ_NIC_PTP_DPATH_UP     0x02000000U
 #define AQ_NIC_LINK_DOWN        0x04000000U
 #define AQ_NIC_FLAG_ERR_UNPLUG  0x40000000U
 #define AQ_NIC_FLAG_ERR_HW      0x80000000U
@@ -127,6 +128,8 @@ void aq_nic_cfg_start(struct aq_nic_s *self);
 int aq_nic_ndev_register(struct aq_nic_s *self);
 void aq_nic_ndev_free(struct aq_nic_s *self);
 int aq_nic_start(struct aq_nic_s *self);
+unsigned int aq_nic_map_skb(struct aq_nic_s *self, struct sk_buff *skb,
+			    struct aq_ring_s *ring);
 int aq_nic_xmit(struct aq_nic_s *self, struct sk_buff *skb);
 int aq_nic_get_regs(struct aq_nic_s *self, struct ethtool_regs *regs, void *p);
 int aq_nic_get_regs_count(struct aq_nic_s *self);
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_ring.c b/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
index 976b4177b47c..26e3f5a7995d 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
@@ -13,6 +13,7 @@
 #include "aq_nic.h"
 #include "aq_hw.h"
 #include "aq_hw_utils.h"
+#include "aq_ptp.h"
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -293,6 +294,7 @@ int aq_ring_rx_clean(struct aq_ring_s *self,
 		self->sw_head = aq_ring_next_dx(self, self->sw_head),
 		--budget, ++(*work_done)) {
 		struct aq_ring_buff_s *buff = &self->buff_ring[self->sw_head];
+		bool is_ptp_ring = aq_ptp_ring(self->aq_nic, self);
 		struct aq_ring_buff_s *buff_ = NULL;
 		struct sk_buff *skb = NULL;
 		unsigned int next_ = 0U;
@@ -357,6 +359,11 @@ int aq_ring_rx_clean(struct aq_ring_s *self,
 				err = -ENOMEM;
 				goto err_exit;
 			}
+			if (is_ptp_ring)
+				buff->len -=
+					aq_ptp_extract_ts(self->aq_nic, skb,
+						aq_buf_vaddr(&buff->rxdata),
+						buff->len);
 			skb_put(skb, buff->len);
 			page_ref_inc(buff->rxdata.page);
 		} else {
@@ -365,6 +372,11 @@ int aq_ring_rx_clean(struct aq_ring_s *self,
 				err = -ENOMEM;
 				goto err_exit;
 			}
+			if (is_ptp_ring)
+				buff->len -=
+					aq_ptp_extract_ts(self->aq_nic, skb,
+						aq_buf_vaddr(&buff->rxdata),
+						buff->len);
 
 			hdr_len = buff->len;
 			if (hdr_len > AQ_CFG_RX_HDR_SIZE)
@@ -420,8 +432,8 @@ int aq_ring_rx_clean(struct aq_ring_s *self,
 		skb_set_hash(skb, buff->rss_hash,
 			     buff->is_hash_l4 ? PKT_HASH_TYPE_L4 :
 			     PKT_HASH_TYPE_NONE);
-
-		skb_record_rx_queue(skb, self->idx);
+		/* Send all PTP traffic to 0 queue */
+		skb_record_rx_queue(skb, is_ptp_ring ? 0 : self->idx);
 
 		++self->stats.rx.packets;
 		self->stats.rx.bytes += skb->len;
@@ -433,6 +445,21 @@ int aq_ring_rx_clean(struct aq_ring_s *self,
 	return err;
 }
 
+void aq_ring_hwts_rx_clean(struct aq_ring_s *self, struct aq_nic_s *aq_nic)
+{
+	while (self->sw_head != self->hw_head) {
+		u64 ns;
+
+		aq_nic->aq_hw_ops->extract_hwts(aq_nic->aq_hw,
+						self->dx_ring +
+						(self->sw_head * self->dx_size),
+						self->dx_size, &ns);
+		aq_ptp_tx_hwtstamp(aq_nic, ns);
+
+		self->sw_head = aq_ring_next_dx(self, self->sw_head);
+	}
+}
+
 int aq_ring_rx_fill(struct aq_ring_s *self)
 {
 	unsigned int page_order = self->page_order;
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
