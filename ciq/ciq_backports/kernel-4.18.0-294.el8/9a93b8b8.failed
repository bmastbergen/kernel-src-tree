Bluetooth: btusb: Define a function to construct firmware filename

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Kiran K <kiran.k@intel.com>
commit 9a93b8b8eee4ac971a1ac120a2be7a66b7fa5b68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9a93b8b8.failed

Define a new function to construct firmware/ddc filename for new
generation Intel controllers

	Signed-off-by: Kiran K <kiran.k@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 9a93b8b8eee4ac971a1ac120a2be7a66b7fa5b68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btintel.h
#	drivers/bluetooth/btusb.c
diff --cc drivers/bluetooth/btintel.h
index ed9afc24dfa4,6511b091caf5..000000000000
--- a/drivers/bluetooth/btintel.h
+++ b/drivers/bluetooth/btintel.h
@@@ -143,6 -128,16 +143,19 @@@ struct intel_reset 
  	__le32   boot_param;
  } __packed;
  
++<<<<<<< HEAD
++=======
+ struct intel_debug_features {
+ 	__u8    page1[16];
+ } __packed;
+ 
+ #define INTEL_HW_PLATFORM(cnvx_bt)	((u8)(((cnvx_bt) & 0x0000ff00) >> 8))
+ #define INTEL_HW_VARIANT(cnvx_bt)	((u8)(((cnvx_bt) & 0x003f0000) >> 16))
+ #define INTEL_CNVX_TOP_TYPE(cnvx_top)	((cnvx_top) & 0x00000fff)
+ #define INTEL_CNVX_TOP_STEP(cnvx_top)	(((cnvx_top) & 0x0f000000) >> 24)
+ #define INTEL_CNVX_TOP_PACK_SWAB(t, s)	__swab16(((__u16)(((t) << 4) | (s))))
+ 
++>>>>>>> 9a93b8b8eee4 (Bluetooth: btusb: Define a function to construct firmware filename)
  #if IS_ENABLED(CONFIG_BT_INTEL)
  
  int btintel_check_bdaddr(struct hci_dev *hdev);
diff --cc drivers/bluetooth/btusb.c
index 16b4132259d9,3864db1c6cd5..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -2187,38 -2385,33 +2187,60 @@@ static bool btusb_setup_intel_new_get_f
  	return true;
  }
  
++<<<<<<< HEAD
 +static int btusb_setup_intel_new(struct hci_dev *hdev)
++=======
+ static void btusb_setup_intel_newgen_get_fw_name(const struct intel_version_tlv *ver_tlv,
+ 						 char *fw_name, size_t len,
+ 						 const char *suffix)
+ {
+ 	/* The firmware file name for new generation controllers will be
+ 	 * ibt-<cnvi_top type+cnvi_top step>-<cnvr_top type+cnvr_top step>
+ 	 */
+ 	snprintf(fw_name, len, "intel/ibt-%04x-%04x.%s",
+ 		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvi_top),
+ 					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvi_top)),
+ 		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvr_top),
+ 					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvr_top)),
+ 		 suffix);
+ }
+ 
+ static int btusb_intel_download_firmware(struct hci_dev *hdev,
+ 					 struct intel_version *ver,
+ 					 struct intel_boot_params *params,
+ 					 u32 *boot_param)
++>>>>>>> 9a93b8b8eee4 (Bluetooth: btusb: Define a function to construct firmware filename)
  {
 +	struct btusb_data *data = hci_get_drvdata(hdev);
 +	struct intel_version ver;
 +	struct intel_boot_params params;
  	const struct firmware *fw;
 +	u32 boot_param;
  	char fwname[64];
 +	ktime_t calltime, delta, rettime;
 +	unsigned long long duration;
  	int err;
 -	struct btusb_data *data = hci_get_drvdata(hdev);
  
 -	if (!ver || !params)
 -		return -EINVAL;
 +	BT_DBG("%s", hdev->name);
 +
 +	/* Set the default boot parameter to 0x0 and it is updated to
 +	 * SKU specific boot parameter after reading Intel_Write_Boot_Params
 +	 * command while downloading the firmware.
 +	 */
 +	boot_param = 0x00000000;
 +
 +	calltime = ktime_get();
 +
 +	/* Read the Intel version information to determine if the device
 +	 * is in bootloader mode or if it already has operational firmware
 +	 * loaded.
 +	 */
 +	err = btintel_read_version(hdev, &ver);
 +	if (err) {
 +		bt_dev_err(hdev, "Intel Read version failed (%d)", err);
 +		btintel_reset_to_bootloader(hdev);
 +		return err;
 +	}
  
  	/* The hardware platform number has a fixed value of 0x37 and
  	 * for now only accept this single value.
@@@ -2487,6 -2734,130 +2509,133 @@@ finish
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int btusb_setup_intel_newgen(struct hci_dev *hdev)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	u32 boot_param;
+ 	char ddcname[64];
+ 	ktime_t calltime, delta, rettime;
+ 	unsigned long long duration;
+ 	int err;
+ 	struct intel_debug_features features;
+ 	struct intel_version_tlv version;
+ 
+ 	bt_dev_dbg(hdev, "");
+ 
+ 	/* Set the default boot parameter to 0x0 and it is updated to
+ 	 * SKU specific boot parameter after reading Intel_Write_Boot_Params
+ 	 * command while downloading the firmware.
+ 	 */
+ 	boot_param = 0x00000000;
+ 
+ 	calltime = ktime_get();
+ 
+ 	/* Read the Intel version information to determine if the device
+ 	 * is in bootloader mode or if it already has operational firmware
+ 	 * loaded.
+ 	 */
+ 	err = btintel_read_version_tlv(hdev, &version);
+ 	if (err) {
+ 		bt_dev_err(hdev, "Intel Read version failed (%d)", err);
+ 		btintel_reset_to_bootloader(hdev);
+ 		return err;
+ 	}
+ 
+ 	btintel_version_info_tlv(hdev, &version);
+ 
+ 	/* check if controller is already having an operational firmware */
+ 	if (version.img_type == 0x03)
+ 		goto finish;
+ 
+ 	rettime = ktime_get();
+ 	delta = ktime_sub(rettime, calltime);
+ 	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
+ 
+ 	bt_dev_info(hdev, "Firmware loaded in %llu usecs", duration);
+ 
+ 	calltime = ktime_get();
+ 
+ 	set_bit(BTUSB_BOOTING, &data->flags);
+ 
+ 	err = btintel_send_intel_reset(hdev, boot_param);
+ 	if (err) {
+ 		bt_dev_err(hdev, "Intel Soft Reset failed (%d)", err);
+ 		btintel_reset_to_bootloader(hdev);
+ 		return err;
+ 	}
+ 
+ 	/* The bootloader will not indicate when the device is ready. This
+ 	 * is done by the operational firmware sending bootup notification.
+ 	 *
+ 	 * Booting into operational firmware should not take longer than
+ 	 * 1 second. However if that happens, then just fail the setup
+ 	 * since something went wrong.
+ 	 */
+ 	bt_dev_info(hdev, "Waiting for device to boot");
+ 
+ 	err = wait_on_bit_timeout(&data->flags, BTUSB_BOOTING,
+ 				  TASK_INTERRUPTIBLE,
+ 				  msecs_to_jiffies(1000));
+ 
+ 	if (err == -EINTR) {
+ 		bt_dev_err(hdev, "Device boot interrupted");
+ 		return -EINTR;
+ 	}
+ 
+ 	if (err) {
+ 		bt_dev_err(hdev, "Device boot timeout");
+ 		btintel_reset_to_bootloader(hdev);
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	rettime = ktime_get();
+ 	delta = ktime_sub(rettime, calltime);
+ 	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
+ 
+ 	bt_dev_info(hdev, "Device booted in %llu usecs", duration);
+ 
+ 	clear_bit(BTUSB_BOOTLOADER, &data->flags);
+ 
+ 	btusb_setup_intel_newgen_get_fw_name(&version, ddcname, sizeof(ddcname),
+ 					     "ddc");
+ 	/* Once the device is running in operational mode, it needs to
+ 	 * apply the device configuration (DDC) parameters.
+ 	 *
+ 	 * The device can work without DDC parameters, so even if it
+ 	 * fails to load the file, no need to fail the setup.
+ 	 */
+ 	btintel_load_ddc_config(hdev, ddcname);
+ 
+ 	/* Read the Intel supported features and if new exception formats
+ 	 * supported, need to load the additional DDC config to enable.
+ 	 */
+ 	btintel_read_debug_features(hdev, &features);
+ 
+ 	/* Set DDC mask for available debug features */
+ 	btintel_set_debug_features(hdev, &features);
+ 
+ 	/* Read the Intel version information after loading the FW  */
+ 	err = btintel_read_version_tlv(hdev, &version);
+ 	if (err)
+ 		return err;
+ 
+ 	btintel_version_info_tlv(hdev, &version);
+ 
+ finish:
+ 	/* Set the event mask for Intel specific vendor events. This enables
+ 	 * a few extra events that are useful during general operation. It
+ 	 * does not enable any debugging related events.
+ 	 *
+ 	 * The device will function correctly without these events enabled
+ 	 * and thus no need to fail the setup.
+ 	 */
+ 	btintel_set_event_mask(hdev, false);
+ 
+ 	return 0;
+ }
++>>>>>>> 9a93b8b8eee4 (Bluetooth: btusb: Define a function to construct firmware filename)
  static int btusb_shutdown_intel(struct hci_dev *hdev)
  {
  	struct sk_buff *skb;
* Unmerged path drivers/bluetooth/btintel.h
* Unmerged path drivers/bluetooth/btusb.c
