net: atlantic: split rx and tx per-queue stats

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mark Starovoytov <mstarovoitov@marvell.com>
commit 508f2e3dce454843ffd689bb2cf0739a954dd1e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/508f2e3d.failed

This patch splits rx and tx per-queue stats.
This change simplifies the follow-up introduction of PTP stats and
u64_stats_update_* usage.

	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 508f2e3dce454843ffd689bb2cf0739a954dd1e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.h
#	drivers/net/ethernet/aquantia/atlantic/aq_vec.c
#	drivers/net/ethernet/aquantia/atlantic/aq_vec.h
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
index a64230722f5c,98ba8355a0f0..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
@@@ -83,15 -89,106 +83,118 @@@ static const char aq_ethtool_stat_names
  	"InDroppedDma",
  };
  
++<<<<<<< HEAD
 +static const char aq_ethtool_queue_stat_names[][ETH_GSTRING_LEN] = {
 +	"Queue[%d] InPackets",
 +	"Queue[%d] OutPackets",
 +	"Queue[%d] Restarts",
 +	"Queue[%d] InJumboPackets",
 +	"Queue[%d] InLroPackets",
 +	"Queue[%d] InErrors",
 +};
 +
++=======
+ static const char * const aq_ethtool_queue_rx_stat_names[] = {
+ 	"%sQueue[%d] InPackets",
+ 	"%sQueue[%d] InJumboPackets",
+ 	"%sQueue[%d] InLroPackets",
+ 	"%sQueue[%d] InErrors",
+ };
+ 
+ static const char * const aq_ethtool_queue_tx_stat_names[] = {
+ 	"%sQueue[%d] OutPackets",
+ 	"%sQueue[%d] Restarts",
+ };
+ 
+ #if IS_ENABLED(CONFIG_MACSEC)
+ static const char aq_macsec_stat_names[][ETH_GSTRING_LEN] = {
+ 	"MACSec InCtlPackets",
+ 	"MACSec InTaggedMissPackets",
+ 	"MACSec InUntaggedMissPackets",
+ 	"MACSec InNotagPackets",
+ 	"MACSec InUntaggedPackets",
+ 	"MACSec InBadTagPackets",
+ 	"MACSec InNoSciPackets",
+ 	"MACSec InUnknownSciPackets",
+ 	"MACSec InCtrlPortPassPackets",
+ 	"MACSec InUnctrlPortPassPackets",
+ 	"MACSec InCtrlPortFailPackets",
+ 	"MACSec InUnctrlPortFailPackets",
+ 	"MACSec InTooLongPackets",
+ 	"MACSec InIgpocCtlPackets",
+ 	"MACSec InEccErrorPackets",
+ 	"MACSec InUnctrlHitDropRedir",
+ 	"MACSec OutCtlPackets",
+ 	"MACSec OutUnknownSaPackets",
+ 	"MACSec OutUntaggedPackets",
+ 	"MACSec OutTooLong",
+ 	"MACSec OutEccErrorPackets",
+ 	"MACSec OutUnctrlHitDropRedir",
+ };
+ 
+ static const char * const aq_macsec_txsc_stat_names[] = {
+ 	"MACSecTXSC%d ProtectedPkts",
+ 	"MACSecTXSC%d EncryptedPkts",
+ 	"MACSecTXSC%d ProtectedOctets",
+ 	"MACSecTXSC%d EncryptedOctets",
+ };
+ 
+ static const char * const aq_macsec_txsa_stat_names[] = {
+ 	"MACSecTXSC%dSA%d HitDropRedirect",
+ 	"MACSecTXSC%dSA%d Protected2Pkts",
+ 	"MACSecTXSC%dSA%d ProtectedPkts",
+ 	"MACSecTXSC%dSA%d EncryptedPkts",
+ };
+ 
+ static const char * const aq_macsec_rxsa_stat_names[] = {
+ 	"MACSecRXSC%dSA%d UntaggedHitPkts",
+ 	"MACSecRXSC%dSA%d CtrlHitDrpRedir",
+ 	"MACSecRXSC%dSA%d NotUsingSa",
+ 	"MACSecRXSC%dSA%d UnusedSa",
+ 	"MACSecRXSC%dSA%d NotValidPkts",
+ 	"MACSecRXSC%dSA%d InvalidPkts",
+ 	"MACSecRXSC%dSA%d OkPkts",
+ 	"MACSecRXSC%dSA%d LatePkts",
+ 	"MACSecRXSC%dSA%d DelayedPkts",
+ 	"MACSecRXSC%dSA%d UncheckedPkts",
+ 	"MACSecRXSC%dSA%d ValidatedOctets",
+ 	"MACSecRXSC%dSA%d DecryptedOctets",
+ };
+ #endif
+ 
+ static const char aq_ethtool_priv_flag_names[][ETH_GSTRING_LEN] = {
+ 	"DMASystemLoopback",
+ 	"PKTSystemLoopback",
+ 	"DMANetworkLoopback",
+ 	"PHYInternalLoopback",
+ 	"PHYExternalLoopback",
+ };
+ 
+ static u32 aq_ethtool_n_stats(struct net_device *ndev)
+ {
+ 	const int rx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_rx_stat_names);
+ 	const int tx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_tx_stat_names);
+ 	struct aq_nic_s *nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(nic);
+ 	u32 n_stats = ARRAY_SIZE(aq_ethtool_stat_names) +
+ 		      (rx_stat_cnt + tx_stat_cnt) * cfg->vecs * cfg->tcs;
+ 
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 	if (nic->macsec_cfg) {
+ 		n_stats += ARRAY_SIZE(aq_macsec_stat_names) +
+ 			   ARRAY_SIZE(aq_macsec_txsc_stat_names) *
+ 				   aq_macsec_tx_sc_cnt(nic) +
+ 			   ARRAY_SIZE(aq_macsec_txsa_stat_names) *
+ 				   aq_macsec_tx_sa_cnt(nic) +
+ 			   ARRAY_SIZE(aq_macsec_rxsa_stat_names) *
+ 				   aq_macsec_rx_sa_cnt(nic);
+ 	}
+ #endif
+ 
+ 	return n_stats;
+ }
+ 
++>>>>>>> 508f2e3dce45 (net: atlantic: split rx and tx per-queue stats)
  static void aq_ethtool_stats(struct net_device *ndev,
  			     struct ethtool_stats *stats, u64 *data)
  {
@@@ -132,24 -229,109 +235,74 @@@ static void aq_ethtool_get_drvinfo(stru
  static void aq_ethtool_get_strings(struct net_device *ndev,
  				   u32 stringset, u8 *data)
  {
 -	struct aq_nic_s *nic = netdev_priv(ndev);
 -	struct aq_nic_cfg_s *cfg;
 -	u8 *p = data;
  	int i, si;
 -#if IS_ENABLED(CONFIG_MACSEC)
 -	int sa;
 -#endif
 +	struct aq_nic_s *aq_nic = netdev_priv(ndev);
 +	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
 +	u8 *p = data;
  
++<<<<<<< HEAD
 +	if (stringset == ETH_SS_STATS) {
 +		memcpy(p, aq_ethtool_stat_names,
 +		       sizeof(aq_ethtool_stat_names));
 +		p = p + sizeof(aq_ethtool_stat_names);
 +		for (i = 0; i < cfg->vecs; i++) {
++=======
+ 	cfg = aq_nic_get_cfg(nic);
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS: {
+ 		const int rx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_rx_stat_names);
+ 		const int tx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_tx_stat_names);
+ 		char tc_string[8];
+ 		int tc;
+ 
+ 		memset(tc_string, 0, sizeof(tc_string));
+ 		memcpy(p, aq_ethtool_stat_names,
+ 		       sizeof(aq_ethtool_stat_names));
+ 		p = p + sizeof(aq_ethtool_stat_names);
+ 
+ 		for (tc = 0; tc < cfg->tcs; tc++) {
+ 			if (cfg->is_qos)
+ 				snprintf(tc_string, 8, "TC%d ", tc);
+ 
+ 			for (i = 0; i < cfg->vecs; i++) {
+ 				for (si = 0; si < rx_stat_cnt; si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 					     aq_ethtool_queue_rx_stat_names[si],
+ 					     tc_string,
+ 					     AQ_NIC_CFG_TCVEC2RING(cfg, tc, i));
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 				for (si = 0; si < tx_stat_cnt; si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 					     aq_ethtool_queue_tx_stat_names[si],
+ 					     tc_string,
+ 					     AQ_NIC_CFG_TCVEC2RING(cfg, tc, i));
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 			}
+ 		}
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 		if (!nic->macsec_cfg)
+ 			break;
+ 
+ 		memcpy(p, aq_macsec_stat_names, sizeof(aq_macsec_stat_names));
+ 		p = p + sizeof(aq_macsec_stat_names);
+ 		for (i = 0; i < AQ_MACSEC_MAX_SC; i++) {
+ 			struct aq_macsec_txsc *aq_txsc;
+ 
+ 			if (!(test_bit(i, &nic->macsec_cfg->txsc_idx_busy)))
+ 				continue;
+ 
++>>>>>>> 508f2e3dce45 (net: atlantic: split rx and tx per-queue stats)
  			for (si = 0;
 -				si < ARRAY_SIZE(aq_macsec_txsc_stat_names);
 +				si < ARRAY_SIZE(aq_ethtool_queue_stat_names);
  				si++) {
  				snprintf(p, ETH_GSTRING_LEN,
 -					 aq_macsec_txsc_stat_names[si], i);
 +					 aq_ethtool_queue_stat_names[si], i);
  				p += ETH_GSTRING_LEN;
  			}
 -			aq_txsc = &nic->macsec_cfg->aq_txsc[i];
 -			for (sa = 0; sa < MACSEC_NUM_AN; sa++) {
 -				if (!(test_bit(sa, &aq_txsc->tx_sa_idx_busy)))
 -					continue;
 -				for (si = 0;
 -				     si < ARRAY_SIZE(aq_macsec_txsa_stat_names);
 -				     si++) {
 -					snprintf(p, ETH_GSTRING_LEN,
 -						 aq_macsec_txsa_stat_names[si],
 -						 i, sa);
 -					p += ETH_GSTRING_LEN;
 -				}
 -			}
 -		}
 -		for (i = 0; i < AQ_MACSEC_MAX_SC; i++) {
 -			struct aq_macsec_rxsc *aq_rxsc;
 -
 -			if (!(test_bit(i, &nic->macsec_cfg->rxsc_idx_busy)))
 -				continue;
 -
 -			aq_rxsc = &nic->macsec_cfg->aq_rxsc[i];
 -			for (sa = 0; sa < MACSEC_NUM_AN; sa++) {
 -				if (!(test_bit(sa, &aq_rxsc->rx_sa_idx_busy)))
 -					continue;
 -				for (si = 0;
 -				     si < ARRAY_SIZE(aq_macsec_rxsa_stat_names);
 -				     si++) {
 -					snprintf(p, ETH_GSTRING_LEN,
 -						 aq_macsec_rxsa_stat_names[si],
 -						 i, sa);
 -					p += ETH_GSTRING_LEN;
 -				}
 -			}
  		}
 -#endif
 -		break;
 -	}
 -	case ETH_SS_PRIV_FLAGS:
 -		memcpy(p, aq_ethtool_priv_flag_names,
 -		       sizeof(aq_ethtool_priv_flag_names));
 -		break;
  	}
  }
  
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.c
index 26476a262015,fc4e10b064fd..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
@@@ -185,6 -211,8 +185,11 @@@ int aq_ring_init(struct aq_ring_s *self
  	self->hw_head = 0;
  	self->sw_head = 0;
  	self->sw_tail = 0;
++<<<<<<< HEAD
++=======
+ 	self->ring_type = ring_type;
+ 
++>>>>>>> 508f2e3dce45 (net: atlantic: split rx and tx per-queue stats)
  	return 0;
  }
  
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.h
index cfffc301e746,0cd761ba47a3..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
@@@ -174,4 -182,11 +180,14 @@@ int aq_ring_rx_clean(struct aq_ring_s *
  		     int budget);
  int aq_ring_rx_fill(struct aq_ring_s *self);
  
++<<<<<<< HEAD
++=======
+ struct aq_ring_s *aq_ring_hwts_rx_alloc(struct aq_ring_s *self,
+ 		struct aq_nic_s *aq_nic, unsigned int idx,
+ 		unsigned int size, unsigned int dx_size);
+ void aq_ring_hwts_rx_clean(struct aq_ring_s *self, struct aq_nic_s *aq_nic);
+ 
+ unsigned int aq_ring_fill_stats_data(struct aq_ring_s *self, u64 *data);
+ 
++>>>>>>> 508f2e3dce45 (net: atlantic: split rx and tx per-queue stats)
  #endif /* AQ_RING_H */
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_vec.c
index e9e3905626ba,b008d12e923a..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_vec.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_vec.c
@@@ -334,55 -350,23 +334,76 @@@ cpumask_t *aq_vec_get_affinity_mask(str
  	return &self->aq_ring_param.affinity_mask;
  }
  
++<<<<<<< HEAD
 +void aq_vec_add_stats(struct aq_vec_s *self,
 +		      struct aq_ring_stats_rx_s *stats_rx,
 +		      struct aq_ring_stats_tx_s *stats_tx)
 +{
 +	struct aq_ring_s *ring = NULL;
 +	unsigned int r = 0U;
 +
 +	for (r = 0U, ring = self->ring[0];
 +		self->tx_rings > r; ++r, ring = self->ring[r]) {
 +		struct aq_ring_stats_tx_s *tx = &ring[AQ_VEC_TX_ID].stats.tx;
 +		struct aq_ring_stats_rx_s *rx = &ring[AQ_VEC_RX_ID].stats.rx;
 +
 +		stats_rx->packets += rx->packets;
 +		stats_rx->bytes += rx->bytes;
 +		stats_rx->errors += rx->errors;
 +		stats_rx->jumbo_packets += rx->jumbo_packets;
 +		stats_rx->lro_packets += rx->lro_packets;
 +		stats_rx->pg_losts += rx->pg_losts;
 +		stats_rx->pg_flips += rx->pg_flips;
 +		stats_rx->pg_reuses += rx->pg_reuses;
 +
 +		stats_tx->packets += tx->packets;
 +		stats_tx->bytes += tx->bytes;
 +		stats_tx->errors += tx->errors;
 +		stats_tx->queue_restarts += tx->queue_restarts;
 +	}
++=======
+ bool aq_vec_is_valid_tc(struct aq_vec_s *self, const unsigned int tc)
+ {
+ 	return tc < self->rx_rings && tc < self->tx_rings;
++>>>>>>> 508f2e3dce45 (net: atlantic: split rx and tx per-queue stats)
  }
  
 -unsigned int aq_vec_get_sw_stats(struct aq_vec_s *self, const unsigned int tc, u64 *data)
 +int aq_vec_get_sw_stats(struct aq_vec_s *self, u64 *data, unsigned int *p_count)
  {
++<<<<<<< HEAD
 +	unsigned int count = 0U;
 +	struct aq_ring_stats_rx_s stats_rx;
 +	struct aq_ring_stats_tx_s stats_tx;
 +
 +	memset(&stats_rx, 0U, sizeof(struct aq_ring_stats_rx_s));
 +	memset(&stats_tx, 0U, sizeof(struct aq_ring_stats_tx_s));
 +	aq_vec_add_stats(self, &stats_rx, &stats_tx);
 +
 +	/* This data should mimic aq_ethtool_queue_stat_names structure
 +	 */
 +	data[count] += stats_rx.packets;
 +	data[++count] += stats_tx.packets;
 +	data[++count] += stats_tx.queue_restarts;
 +	data[++count] += stats_rx.jumbo_packets;
 +	data[++count] += stats_rx.lro_packets;
 +	data[++count] += stats_rx.errors;
 +
 +	if (p_count)
 +		*p_count = ++count;
 +
 +	return 0;
++=======
+ 	unsigned int count;
+ 
+ 	WARN_ONCE(!aq_vec_is_valid_tc(self, tc),
+ 		  "Invalid tc %u (#rx=%u, #tx=%u)\n",
+ 		  tc, self->rx_rings, self->tx_rings);
+ 	if (!aq_vec_is_valid_tc(self, tc))
+ 		return 0;
+ 
+ 	count = aq_ring_fill_stats_data(&self->ring[tc][AQ_VEC_RX_ID], data);
+ 	count += aq_ring_fill_stats_data(&self->ring[tc][AQ_VEC_TX_ID], data + count);
+ 
+ 	return count;
++>>>>>>> 508f2e3dce45 (net: atlantic: split rx and tx per-queue stats)
  }
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_vec.h
index 8bdf60bb3f63,567f3d4b79a2..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_vec.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_vec.h
@@@ -35,10 -35,8 +35,15 @@@ void aq_vec_free(struct aq_vec_s *self)
  int aq_vec_start(struct aq_vec_s *self);
  void aq_vec_stop(struct aq_vec_s *self);
  cpumask_t *aq_vec_get_affinity_mask(struct aq_vec_s *self);
++<<<<<<< HEAD
 +int aq_vec_get_sw_stats(struct aq_vec_s *self, u64 *data,
 +			unsigned int *p_count);
 +void aq_vec_add_stats(struct aq_vec_s *self,
 +		      struct aq_ring_stats_rx_s *stats_rx,
 +		      struct aq_ring_stats_tx_s *stats_tx);
++=======
+ bool aq_vec_is_valid_tc(struct aq_vec_s *self, const unsigned int tc);
+ unsigned int aq_vec_get_sw_stats(struct aq_vec_s *self, const unsigned int tc, u64 *data);
++>>>>>>> 508f2e3dce45 (net: atlantic: split rx and tx per-queue stats)
  
  #endif /* AQ_VEC_H */
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_vec.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_vec.h
