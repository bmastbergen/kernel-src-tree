dmaengine: idxd: reset states after device disable or reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit df841b17e809f48f740cd2dd8b63543073c91a02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/df841b17.failed

The state for WQs should be reset to disabled when a device is reset or
disabled.

Fixes: da32b28c95a7 ("dmaengine: idxd: cleanup workqueue config after disabling")
	Reported-by: Mona Hossain <mona.hossain@intel.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/159586777684.27150.17589406415773568534.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit df841b17e809f48f740cd2dd8b63543073c91a02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/device.c
#	drivers/dma/idxd/irq.c
diff --cc drivers/dma/idxd/device.c
index 09da3c4fa12f,b75d699160bf..000000000000
--- a/drivers/dma/idxd/device.c
+++ b/drivers/dma/idxd/device.c
@@@ -399,10 -429,9 +415,11 @@@ void idxd_device_wqs_clear_state(struc
  int idxd_device_disable(struct idxd_device *idxd)
  {
  	struct device *dev = &idxd->pdev->dev;
 +	int rc;
  	u32 status;
+ 	unsigned long flags;
  
 +	lockdep_assert_held(&idxd->dev_lock);
  	if (!idxd_is_enabled(idxd)) {
  		dev_dbg(dev, "Device is not enabled\n");
  		return 0;
@@@ -419,38 -443,25 +436,51 @@@
  	if (status != IDXD_CMDSTS_SUCCESS &&
  	    !(status & IDXD_CMDSTS_ERR_DIS_DEV_EN)) {
  		dev_dbg(dev, "%s: err_code: %#x\n", __func__, status);
 -		return -ENXIO;
 +		rc = -ENXIO;
 +		return rc;
  	}
  
+ 	spin_lock_irqsave(&idxd->dev_lock, flags);
+ 	idxd_device_wqs_clear_state(idxd);
  	idxd->state = IDXD_DEV_CONF_READY;
+ 	spin_unlock_irqrestore(&idxd->dev_lock, flags);
  	return 0;
  }
  
 -void idxd_device_reset(struct idxd_device *idxd)
 +int __idxd_device_reset(struct idxd_device *idxd)
  {
++<<<<<<< HEAD
 +	u32 status;
 +	int rc;
 +
 +	rc = idxd_cmd_send(idxd, IDXD_CMD_RESET_DEVICE, 0);
 +	if (rc < 0)
 +		return rc;
 +	rc = idxd_cmd_wait(idxd, &status, IDXD_REG_TIMEOUT);
 +	if (rc < 0)
 +		return rc;
 +
 +	return 0;
 +}
 +
 +int idxd_device_reset(struct idxd_device *idxd)
 +{
 +	unsigned long flags;
 +	int rc;
 +
 +	spin_lock_irqsave(&idxd->dev_lock, flags);
 +	rc = __idxd_device_reset(idxd);
 +	spin_unlock_irqrestore(&idxd->dev_lock, flags);
 +	return rc;
++=======
+ 	unsigned long flags;
+ 
+ 	idxd_cmd_exec(idxd, IDXD_CMD_RESET_DEVICE, 0, NULL);
+ 	spin_lock_irqsave(&idxd->dev_lock, flags);
+ 	idxd_device_wqs_clear_state(idxd);
+ 	idxd->state = IDXD_DEV_CONF_READY;
+ 	spin_unlock_irqrestore(&idxd->dev_lock, flags);
++>>>>>>> df841b17e809 (dmaengine: idxd: reset states after device disable or reset)
  }
  
  /* Device configuration bits */
diff --cc drivers/dma/idxd/irq.c
index a517f8b99398,1e9e6991f543..000000000000
--- a/drivers/dma/idxd/irq.c
+++ b/drivers/dma/idxd/irq.c
@@@ -11,28 -11,13 +11,32 @@@
  #include "idxd.h"
  #include "registers.h"
  
++<<<<<<< HEAD
 +void idxd_device_wqs_clear_state(struct idxd_device *idxd)
 +{
 +	int i;
 +
 +	lockdep_assert_held(&idxd->dev_lock);
 +	for (i = 0; i < idxd->max_wqs; i++) {
 +		struct idxd_wq *wq = &idxd->wqs[i];
 +
 +		wq->state = IDXD_WQ_DISABLED;
 +	}
 +}
 +
 +static int idxd_restart(struct idxd_device *idxd)
++=======
+ static void idxd_device_reinit(struct work_struct *work)
++>>>>>>> df841b17e809 (dmaengine: idxd: reset states after device disable or reset)
  {
 -	struct idxd_device *idxd = container_of(work, struct idxd_device, work);
 -	struct device *dev = &idxd->pdev->dev;
 -	int rc, i;
 +	int i, rc;
 +
 +	lockdep_assert_held(&idxd->dev_lock);
 +
 +	rc = __idxd_device_reset(idxd);
 +	if (rc < 0)
 +		goto out;
  
 -	idxd_device_reset(idxd);
  	rc = idxd_device_config(idxd);
  	if (rc < 0)
  		goto out;
* Unmerged path drivers/dma/idxd/device.c
* Unmerged path drivers/dma/idxd/irq.c
