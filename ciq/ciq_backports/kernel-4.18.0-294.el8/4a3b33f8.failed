libbpf: Add BTF writing APIs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 4a3b33f8579af182ebcf9c7e9304effce505500e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4a3b33f8.failed

Add APIs for appending new BTF types at the end of BTF object.

Each BTF kind has either one API of the form btf__add_<kind>(). For types
that have variable amount of additional items (struct/union, enum, func_proto,
datasec), additional API is provided to emit each such item. E.g., for
emitting a struct, one would use the following sequence of API calls:

btf__add_struct(...);
btf__add_field(...);
...
btf__add_field(...);

Each btf__add_field() will ensure that the last BTF type is of STRUCT or
UNION kind and will automatically increment that type's vlen field.

All the strings are provided as C strings (const char *), not a string offset.
This significantly improves usability of BTF writer APIs. All such strings
will be automatically appended to string section or existing string will be
re-used, if such string was already added previously.

Each API attempts to do all the reasonable validations, like enforcing
non-empty names for entities with required names, proper value bounds, various
bit offset restrictions, etc.

Type ID validation is minimal because it's possible to emit a type that refers
to type that will be emitted later, so libbpf has no way to enforce such
cases. User must be careful to properly emit all the necessary types and
specify type IDs that will be valid in the finally generated BTF.

Each of btf__add_<kind>() APIs return new type ID on success or negative
value on error. APIs like btf__add_field() that emit additional items
return zero on success and negative value on error.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/20200929020533.711288-2-andriin@fb.com
(cherry picked from commit 4a3b33f8579af182ebcf9c7e9304effce505500e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/btf.c
#	tools/lib/bpf/btf.h
#	tools/lib/bpf/libbpf.map
diff --cc tools/lib/bpf/btf.c
index 9ca048005e04,7533088b2524..000000000000
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@@ -849,6 -1168,962 +849,965 @@@ int btf__get_map_kv_tids(const struct b
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static size_t strs_hash_fn(const void *key, void *ctx)
+ {
+ 	struct btf *btf = ctx;
+ 	const char *str = btf->strs_data + (long)key;
+ 
+ 	return str_hash(str);
+ }
+ 
+ static bool strs_hash_equal_fn(const void *key1, const void *key2, void *ctx)
+ {
+ 	struct btf *btf = ctx;
+ 	const char *str1 = btf->strs_data + (long)key1;
+ 	const char *str2 = btf->strs_data + (long)key2;
+ 
+ 	return strcmp(str1, str2) == 0;
+ }
+ 
+ /* Ensure BTF is ready to be modified (by splitting into a three memory
+  * regions for header, types, and strings). Also invalidate cached
+  * raw_data, if any.
+  */
+ static int btf_ensure_modifiable(struct btf *btf)
+ {
+ 	void *hdr, *types, *strs, *strs_end, *s;
+ 	struct hashmap *hash = NULL;
+ 	long off;
+ 	int err;
+ 
+ 	if (btf_is_modifiable(btf)) {
+ 		/* any BTF modification invalidates raw_data */
+ 		if (btf->raw_data) {
+ 			free(btf->raw_data);
+ 			btf->raw_data = NULL;
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	/* split raw data into three memory regions */
+ 	hdr = malloc(btf->hdr->hdr_len);
+ 	types = malloc(btf->hdr->type_len);
+ 	strs = malloc(btf->hdr->str_len);
+ 	if (!hdr || !types || !strs)
+ 		goto err_out;
+ 
+ 	memcpy(hdr, btf->hdr, btf->hdr->hdr_len);
+ 	memcpy(types, btf->types_data, btf->hdr->type_len);
+ 	memcpy(strs, btf->strs_data, btf->hdr->str_len);
+ 
+ 	/* build lookup index for all strings */
+ 	hash = hashmap__new(strs_hash_fn, strs_hash_equal_fn, btf);
+ 	if (IS_ERR(hash)) {
+ 		err = PTR_ERR(hash);
+ 		hash = NULL;
+ 		goto err_out;
+ 	}
+ 
+ 	strs_end = strs + btf->hdr->str_len;
+ 	for (off = 0, s = strs; s < strs_end; off += strlen(s) + 1, s = strs + off) {
+ 		/* hashmap__add() returns EEXIST if string with the same
+ 		 * content already is in the hash map
+ 		 */
+ 		err = hashmap__add(hash, (void *)off, (void *)off);
+ 		if (err == -EEXIST)
+ 			continue; /* duplicate */
+ 		if (err)
+ 			goto err_out;
+ 	}
+ 
+ 	/* only when everything was successful, update internal state */
+ 	btf->hdr = hdr;
+ 	btf->types_data = types;
+ 	btf->types_data_cap = btf->hdr->type_len;
+ 	btf->strs_data = strs;
+ 	btf->strs_data_cap = btf->hdr->str_len;
+ 	btf->strs_hash = hash;
+ 	/* if BTF was created from scratch, all strings are guaranteed to be
+ 	 * unique and deduplicated
+ 	 */
+ 	btf->strs_deduped = btf->hdr->str_len <= 1;
+ 
+ 	/* invalidate raw_data representation */
+ 	free(btf->raw_data);
+ 	btf->raw_data = NULL;
+ 
+ 	return 0;
+ 
+ err_out:
+ 	hashmap__free(hash);
+ 	free(hdr);
+ 	free(types);
+ 	free(strs);
+ 	return -ENOMEM;
+ }
+ 
+ static void *btf_add_str_mem(struct btf *btf, size_t add_sz)
+ {
+ 	return btf_add_mem(&btf->strs_data, &btf->strs_data_cap, 1,
+ 			   btf->hdr->str_len, BTF_MAX_STR_OFFSET, add_sz);
+ }
+ 
+ /* Find an offset in BTF string section that corresponds to a given string *s*.
+  * Returns:
+  *   - >0 offset into string section, if string is found;
+  *   - -ENOENT, if string is not in the string section;
+  *   - <0, on any other error.
+  */
+ int btf__find_str(struct btf *btf, const char *s)
+ {
+ 	long old_off, new_off, len;
+ 	void *p;
+ 
+ 	/* BTF needs to be in a modifiable state to build string lookup index */
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	/* see btf__add_str() for why we do this */
+ 	len = strlen(s) + 1;
+ 	p = btf_add_str_mem(btf, len);
+ 	if (!p)
+ 		return -ENOMEM;
+ 
+ 	new_off = btf->hdr->str_len;
+ 	memcpy(p, s, len);
+ 
+ 	if (hashmap__find(btf->strs_hash, (void *)new_off, (void **)&old_off))
+ 		return old_off;
+ 
+ 	return -ENOENT;
+ }
+ 
+ /* Add a string s to the BTF string section.
+  * Returns:
+  *   - > 0 offset into string section, on success;
+  *   - < 0, on error.
+  */
+ int btf__add_str(struct btf *btf, const char *s)
+ {
+ 	long old_off, new_off, len;
+ 	void *p;
+ 	int err;
+ 
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	/* Hashmap keys are always offsets within btf->strs_data, so to even
+ 	 * look up some string from the "outside", we need to first append it
+ 	 * at the end, so that it can be addressed with an offset. Luckily,
+ 	 * until btf->hdr->str_len is incremented, that string is just a piece
+ 	 * of garbage for the rest of BTF code, so no harm, no foul. On the
+ 	 * other hand, if the string is unique, it's already appended and
+ 	 * ready to be used, only a simple btf->hdr->str_len increment away.
+ 	 */
+ 	len = strlen(s) + 1;
+ 	p = btf_add_str_mem(btf, len);
+ 	if (!p)
+ 		return -ENOMEM;
+ 
+ 	new_off = btf->hdr->str_len;
+ 	memcpy(p, s, len);
+ 
+ 	/* Now attempt to add the string, but only if the string with the same
+ 	 * contents doesn't exist already (HASHMAP_ADD strategy). If such
+ 	 * string exists, we'll get its offset in old_off (that's old_key).
+ 	 */
+ 	err = hashmap__insert(btf->strs_hash, (void *)new_off, (void *)new_off,
+ 			      HASHMAP_ADD, (const void **)&old_off, NULL);
+ 	if (err == -EEXIST)
+ 		return old_off; /* duplicated string, return existing offset */
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->str_len += len; /* new unique string, adjust data length */
+ 	return new_off;
+ }
+ 
+ static void *btf_add_type_mem(struct btf *btf, size_t add_sz)
+ {
+ 	return btf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
+ 			   btf->hdr->type_len, UINT_MAX, add_sz);
+ }
+ 
+ static __u32 btf_type_info(int kind, int vlen, int kflag)
+ {
+ 	return (kflag << 31) | (kind << 24) | vlen;
+ }
+ 
+ static void btf_type_inc_vlen(struct btf_type *t)
+ {
+ 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
+ }
+ 
+ /*
+  * Append new BTF_KIND_INT type with:
+  *   - *name* - non-empty, non-NULL type name;
+  *   - *sz* - power-of-2 (1, 2, 4, ..) size of the type, in bytes;
+  *   - encoding is a combination of BTF_INT_SIGNED, BTF_INT_CHAR, BTF_INT_BOOL.
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_int(struct btf *btf, const char *name, size_t byte_sz, int encoding)
+ {
+ 	struct btf_type *t;
+ 	int sz, err, name_off;
+ 
+ 	/* non-empty name */
+ 	if (!name || !name[0])
+ 		return -EINVAL;
+ 	/* byte_sz must be power of 2 */
+ 	if (!byte_sz || (byte_sz & (byte_sz - 1)) || byte_sz > 16)
+ 		return -EINVAL;
+ 	if (encoding & ~(BTF_INT_SIGNED | BTF_INT_CHAR | BTF_INT_BOOL))
+ 		return -EINVAL;
+ 
+ 	/* deconstruct BTF, if necessary, and invalidate raw_data */
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_type) + sizeof(int);
+ 	t = btf_add_type_mem(btf, sz);
+ 	if (!t)
+ 		return -ENOMEM;
+ 
+ 	/* if something goes wrong later, we might end up with an extra string,
+ 	 * but that shouldn't be a problem, because BTF can't be constructed
+ 	 * completely anyway and will most probably be just discarded
+ 	 */
+ 	name_off = btf__add_str(btf, name);
+ 	if (name_off < 0)
+ 		return name_off;
+ 
+ 	t->name_off = name_off;
+ 	t->info = btf_type_info(BTF_KIND_INT, 0, 0);
+ 	t->size = byte_sz;
+ 	/* set INT info, we don't allow setting legacy bit offset/size */
+ 	*(__u32 *)(t + 1) = (encoding << 24) | (byte_sz * 8);
+ 
+ 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	btf->nr_types++;
+ 	return btf->nr_types;
+ }
+ 
+ /* it's completely legal to append BTF types with type IDs pointing forward to
+  * types that haven't been appended yet, so we only make sure that id looks
+  * sane, we can't guarantee that ID will always be valid
+  */
+ static int validate_type_id(int id)
+ {
+ 	if (id < 0 || id > BTF_MAX_NR_TYPES)
+ 		return -EINVAL;
+ 	return 0;
+ }
+ 
+ /* generic append function for PTR, TYPEDEF, CONST/VOLATILE/RESTRICT */
+ static int btf_add_ref_kind(struct btf *btf, int kind, const char *name, int ref_type_id)
+ {
+ 	struct btf_type *t;
+ 	int sz, name_off = 0, err;
+ 
+ 	if (validate_type_id(ref_type_id))
+ 		return -EINVAL;
+ 
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_type);
+ 	t = btf_add_type_mem(btf, sz);
+ 	if (!t)
+ 		return -ENOMEM;
+ 
+ 	if (name && name[0]) {
+ 		name_off = btf__add_str(btf, name);
+ 		if (name_off < 0)
+ 			return name_off;
+ 	}
+ 
+ 	t->name_off = name_off;
+ 	t->info = btf_type_info(kind, 0, 0);
+ 	t->type = ref_type_id;
+ 
+ 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	btf->nr_types++;
+ 	return btf->nr_types;
+ }
+ 
+ /*
+  * Append new BTF_KIND_PTR type with:
+  *   - *ref_type_id* - referenced type ID, it might not exist yet;
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_ptr(struct btf *btf, int ref_type_id)
+ {
+ 	return btf_add_ref_kind(btf, BTF_KIND_PTR, NULL, ref_type_id);
+ }
+ 
+ /*
+  * Append new BTF_KIND_ARRAY type with:
+  *   - *index_type_id* - type ID of the type describing array index;
+  *   - *elem_type_id* - type ID of the type describing array element;
+  *   - *nr_elems* - the size of the array;
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_array(struct btf *btf, int index_type_id, int elem_type_id, __u32 nr_elems)
+ {
+ 	struct btf_type *t;
+ 	struct btf_array *a;
+ 	int sz, err;
+ 
+ 	if (validate_type_id(index_type_id) || validate_type_id(elem_type_id))
+ 		return -EINVAL;
+ 
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_type) + sizeof(struct btf_array);
+ 	t = btf_add_type_mem(btf, sz);
+ 	if (!t)
+ 		return -ENOMEM;
+ 
+ 	t->name_off = 0;
+ 	t->info = btf_type_info(BTF_KIND_ARRAY, 0, 0);
+ 	t->size = 0;
+ 
+ 	a = btf_array(t);
+ 	a->type = elem_type_id;
+ 	a->index_type = index_type_id;
+ 	a->nelems = nr_elems;
+ 
+ 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	btf->nr_types++;
+ 	return btf->nr_types;
+ }
+ 
+ /* generic STRUCT/UNION append function */
+ static int btf_add_composite(struct btf *btf, int kind, const char *name, __u32 bytes_sz)
+ {
+ 	struct btf_type *t;
+ 	int sz, err, name_off = 0;
+ 
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_type);
+ 	t = btf_add_type_mem(btf, sz);
+ 	if (!t)
+ 		return -ENOMEM;
+ 
+ 	if (name && name[0]) {
+ 		name_off = btf__add_str(btf, name);
+ 		if (name_off < 0)
+ 			return name_off;
+ 	}
+ 
+ 	/* start out with vlen=0 and no kflag; this will be adjusted when
+ 	 * adding each member
+ 	 */
+ 	t->name_off = name_off;
+ 	t->info = btf_type_info(kind, 0, 0);
+ 	t->size = bytes_sz;
+ 
+ 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	btf->nr_types++;
+ 	return btf->nr_types;
+ }
+ 
+ /*
+  * Append new BTF_KIND_STRUCT type with:
+  *   - *name* - name of the struct, can be NULL or empty for anonymous structs;
+  *   - *byte_sz* - size of the struct, in bytes;
+  *
+  * Struct initially has no fields in it. Fields can be added by
+  * btf__add_field() right after btf__add_struct() succeeds. 
+  *
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_struct(struct btf *btf, const char *name, __u32 byte_sz)
+ {
+ 	return btf_add_composite(btf, BTF_KIND_STRUCT, name, byte_sz);
+ }
+ 
+ /*
+  * Append new BTF_KIND_UNION type with:
+  *   - *name* - name of the union, can be NULL or empty for anonymous union;
+  *   - *byte_sz* - size of the union, in bytes;
+  *
+  * Union initially has no fields in it. Fields can be added by
+  * btf__add_field() right after btf__add_union() succeeds. All fields
+  * should have *bit_offset* of 0.
+  *
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_union(struct btf *btf, const char *name, __u32 byte_sz)
+ {
+ 	return btf_add_composite(btf, BTF_KIND_UNION, name, byte_sz);
+ }
+ 
+ /*
+  * Append new field for the current STRUCT/UNION type with:
+  *   - *name* - name of the field, can be NULL or empty for anonymous field;
+  *   - *type_id* - type ID for the type describing field type;
+  *   - *bit_offset* - bit offset of the start of the field within struct/union;
+  *   - *bit_size* - bit size of a bitfield, 0 for non-bitfield fields;
+  * Returns:
+  *   -  0, on success;
+  *   - <0, on error.
+  */
+ int btf__add_field(struct btf *btf, const char *name, int type_id,
+ 		   __u32 bit_offset, __u32 bit_size)
+ {
+ 	struct btf_type *t;
+ 	struct btf_member *m;
+ 	bool is_bitfield;
+ 	int sz, name_off = 0;
+ 
+ 	/* last type should be union/struct */
+ 	if (btf->nr_types == 0)
+ 		return -EINVAL;
+ 	t = btf_type_by_id(btf, btf->nr_types);
+ 	if (!btf_is_composite(t))
+ 		return -EINVAL;
+ 
+ 	if (validate_type_id(type_id))
+ 		return -EINVAL;
+ 	/* best-effort bit field offset/size enforcement */
+ 	is_bitfield = bit_size || (bit_offset % 8 != 0);
+ 	if (is_bitfield && (bit_size == 0 || bit_size > 255 || bit_offset > 0xffffff))
+ 		return -EINVAL;
+ 
+ 	/* only offset 0 is allowed for unions */
+ 	if (btf_is_union(t) && bit_offset)
+ 		return -EINVAL;
+ 
+ 	/* decompose and invalidate raw data */
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_member);
+ 	m = btf_add_type_mem(btf, sz);
+ 	if (!m)
+ 		return -ENOMEM;
+ 
+ 	if (name && name[0]) {
+ 		name_off = btf__add_str(btf, name);
+ 		if (name_off < 0)
+ 			return name_off;
+ 	}
+ 
+ 	m->name_off = name_off;
+ 	m->type = type_id;
+ 	m->offset = bit_offset | (bit_size << 24);
+ 
+ 	/* btf_add_type_mem can invalidate t pointer */
+ 	t = btf_type_by_id(btf, btf->nr_types);
+ 	/* update parent type's vlen and kflag */
+ 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, is_bitfield || btf_kflag(t));
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	return 0;
+ }
+ 
+ /*
+  * Append new BTF_KIND_ENUM type with:
+  *   - *name* - name of the enum, can be NULL or empty for anonymous enums;
+  *   - *byte_sz* - size of the enum, in bytes.
+  *
+  * Enum initially has no enum values in it (and corresponds to enum forward
+  * declaration). Enumerator values can be added by btf__add_enum_value()
+  * immediately after btf__add_enum() succeeds.
+  *
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_enum(struct btf *btf, const char *name, __u32 byte_sz)
+ {
+ 	struct btf_type *t;
+ 	int sz, err, name_off = 0;
+ 
+ 	/* byte_sz must be power of 2 */
+ 	if (!byte_sz || (byte_sz & (byte_sz - 1)) || byte_sz > 8)
+ 		return -EINVAL;
+ 
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_type);
+ 	t = btf_add_type_mem(btf, sz);
+ 	if (!t)
+ 		return -ENOMEM;
+ 
+ 	if (name && name[0]) {
+ 		name_off = btf__add_str(btf, name);
+ 		if (name_off < 0)
+ 			return name_off;
+ 	}
+ 
+ 	/* start out with vlen=0; it will be adjusted when adding enum values */
+ 	t->name_off = name_off;
+ 	t->info = btf_type_info(BTF_KIND_ENUM, 0, 0);
+ 	t->size = byte_sz;
+ 
+ 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	btf->nr_types++;
+ 	return btf->nr_types;
+ }
+ 
+ /*
+  * Append new enum value for the current ENUM type with:
+  *   - *name* - name of the enumerator value, can't be NULL or empty;
+  *   - *value* - integer value corresponding to enum value *name*;
+  * Returns:
+  *   -  0, on success;
+  *   - <0, on error.
+  */
+ int btf__add_enum_value(struct btf *btf, const char *name, __s64 value)
+ {
+ 	struct btf_type *t;
+ 	struct btf_enum *v;
+ 	int sz, name_off;
+ 
+ 	/* last type should be BTF_KIND_ENUM */
+ 	if (btf->nr_types == 0)
+ 		return -EINVAL;
+ 	t = btf_type_by_id(btf, btf->nr_types);
+ 	if (!btf_is_enum(t))
+ 		return -EINVAL;
+ 
+ 	/* non-empty name */
+ 	if (!name || !name[0])
+ 		return -EINVAL;
+ 	if (value < INT_MIN || value > UINT_MAX)
+ 		return -E2BIG;
+ 
+ 	/* decompose and invalidate raw data */
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_enum);
+ 	v = btf_add_type_mem(btf, sz);
+ 	if (!v)
+ 		return -ENOMEM;
+ 
+ 	name_off = btf__add_str(btf, name);
+ 	if (name_off < 0)
+ 		return name_off;
+ 
+ 	v->name_off = name_off;
+ 	v->val = value;
+ 
+ 	/* update parent type's vlen */
+ 	t = btf_type_by_id(btf, btf->nr_types);
+ 	btf_type_inc_vlen(t);
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	return 0;
+ }
+ 
+ /*
+  * Append new BTF_KIND_FWD type with:
+  *   - *name*, non-empty/non-NULL name;
+  *   - *fwd_kind*, kind of forward declaration, one of BTF_FWD_STRUCT,
+  *     BTF_FWD_UNION, or BTF_FWD_ENUM;
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_fwd(struct btf *btf, const char *name, enum btf_fwd_kind fwd_kind)
+ {
+ 	if (!name || !name[0])
+ 		return -EINVAL;
+ 
+ 	switch (fwd_kind) {
+ 	case BTF_FWD_STRUCT:
+ 	case BTF_FWD_UNION: {
+ 		struct btf_type *t;
+ 		int id;
+ 
+ 		id = btf_add_ref_kind(btf, BTF_KIND_FWD, name, 0);
+ 		if (id <= 0)
+ 			return id;
+ 		t = btf_type_by_id(btf, id);
+ 		t->info = btf_type_info(BTF_KIND_FWD, 0, fwd_kind == BTF_FWD_UNION);
+ 		return id;
+ 	}
+ 	case BTF_FWD_ENUM:
+ 		/* enum forward in BTF currently is just an enum with no enum
+ 		 * values; we also assume a standard 4-byte size for it
+ 		 */
+ 		return btf__add_enum(btf, name, sizeof(int));
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ /*
+  * Append new BTF_KING_TYPEDEF type with:
+  *   - *name*, non-empty/non-NULL name;
+  *   - *ref_type_id* - referenced type ID, it might not exist yet;
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_typedef(struct btf *btf, const char *name, int ref_type_id)
+ {
+ 	if (!name || !name[0])
+ 		return -EINVAL;
+ 
+ 	return btf_add_ref_kind(btf, BTF_KIND_TYPEDEF, name, ref_type_id);
+ }
+ 
+ /*
+  * Append new BTF_KIND_VOLATILE type with:
+  *   - *ref_type_id* - referenced type ID, it might not exist yet;
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_volatile(struct btf *btf, int ref_type_id)
+ {
+ 	return btf_add_ref_kind(btf, BTF_KIND_VOLATILE, NULL, ref_type_id);
+ }
+ 
+ /*
+  * Append new BTF_KIND_CONST type with:
+  *   - *ref_type_id* - referenced type ID, it might not exist yet;
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_const(struct btf *btf, int ref_type_id)
+ {
+ 	return btf_add_ref_kind(btf, BTF_KIND_CONST, NULL, ref_type_id);
+ }
+ 
+ /*
+  * Append new BTF_KIND_RESTRICT type with:
+  *   - *ref_type_id* - referenced type ID, it might not exist yet;
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_restrict(struct btf *btf, int ref_type_id)
+ {
+ 	return btf_add_ref_kind(btf, BTF_KIND_RESTRICT, NULL, ref_type_id);
+ }
+ 
+ /*
+  * Append new BTF_KIND_FUNC type with:
+  *   - *name*, non-empty/non-NULL name;
+  *   - *proto_type_id* - FUNC_PROTO's type ID, it might not exist yet;
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_func(struct btf *btf, const char *name,
+ 		  enum btf_func_linkage linkage, int proto_type_id)
+ {
+ 	int id;
+ 
+ 	if (!name || !name[0])
+ 		return -EINVAL;
+ 	if (linkage != BTF_FUNC_STATIC && linkage != BTF_FUNC_GLOBAL &&
+ 	    linkage != BTF_FUNC_EXTERN)
+ 		return -EINVAL;
+ 
+ 	id = btf_add_ref_kind(btf, BTF_KIND_FUNC, name, proto_type_id);
+ 	if (id > 0) {
+ 		struct btf_type *t = btf_type_by_id(btf, id);
+ 
+ 		t->info = btf_type_info(BTF_KIND_FUNC, linkage, 0);
+ 	}
+ 	return id;
+ }
+ 
+ /*
+  * Append new BTF_KIND_FUNC_PROTO with:
+  *   - *ret_type_id* - type ID for return result of a function.
+  *
+  * Function prototype initially has no arguments, but they can be added by
+  * btf__add_func_param() one by one, immediately after
+  * btf__add_func_proto() succeeded.
+  *
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_func_proto(struct btf *btf, int ret_type_id)
+ {
+ 	struct btf_type *t;
+ 	int sz, err;
+ 
+ 	if (validate_type_id(ret_type_id))
+ 		return -EINVAL;
+ 
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_type);
+ 	t = btf_add_type_mem(btf, sz);
+ 	if (!t)
+ 		return -ENOMEM;
+ 
+ 	/* start out with vlen=0; this will be adjusted when adding enum
+ 	 * values, if necessary
+ 	 */
+ 	t->name_off = 0;
+ 	t->info = btf_type_info(BTF_KIND_FUNC_PROTO, 0, 0);
+ 	t->type = ret_type_id;
+ 
+ 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	btf->nr_types++;
+ 	return btf->nr_types;
+ }
+ 
+ /*
+  * Append new function parameter for current FUNC_PROTO type with:
+  *   - *name* - parameter name, can be NULL or empty;
+  *   - *type_id* - type ID describing the type of the parameter.
+  * Returns:
+  *   -  0, on success;
+  *   - <0, on error.
+  */
+ int btf__add_func_param(struct btf *btf, const char *name, int type_id)
+ {
+ 	struct btf_type *t;
+ 	struct btf_param *p;
+ 	int sz, name_off = 0;
+ 
+ 	if (validate_type_id(type_id))
+ 		return -EINVAL;
+ 
+ 	/* last type should be BTF_KIND_FUNC_PROTO */
+ 	if (btf->nr_types == 0)
+ 		return -EINVAL;
+ 	t = btf_type_by_id(btf, btf->nr_types);
+ 	if (!btf_is_func_proto(t))
+ 		return -EINVAL;
+ 
+ 	/* decompose and invalidate raw data */
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_param);
+ 	p = btf_add_type_mem(btf, sz);
+ 	if (!p)
+ 		return -ENOMEM;
+ 
+ 	if (name && name[0]) {
+ 		name_off = btf__add_str(btf, name);
+ 		if (name_off < 0)
+ 			return name_off;
+ 	}
+ 
+ 	p->name_off = name_off;
+ 	p->type = type_id;
+ 
+ 	/* update parent type's vlen */
+ 	t = btf_type_by_id(btf, btf->nr_types);
+ 	btf_type_inc_vlen(t);
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	return 0;
+ }
+ 
+ /*
+  * Append new BTF_KIND_VAR type with:
+  *   - *name* - non-empty/non-NULL name;
+  *   - *linkage* - variable linkage, one of BTF_VAR_STATIC,
+  *     BTF_VAR_GLOBAL_ALLOCATED, or BTF_VAR_GLOBAL_EXTERN;
+  *   - *type_id* - type ID of the type describing the type of the variable.
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_var(struct btf *btf, const char *name, int linkage, int type_id)
+ {
+ 	struct btf_type *t;
+ 	struct btf_var *v;
+ 	int sz, err, name_off;
+ 
+ 	/* non-empty name */
+ 	if (!name || !name[0])
+ 		return -EINVAL;
+ 	if (linkage != BTF_VAR_STATIC && linkage != BTF_VAR_GLOBAL_ALLOCATED &&
+ 	    linkage != BTF_VAR_GLOBAL_EXTERN)
+ 		return -EINVAL;
+ 	if (validate_type_id(type_id))
+ 		return -EINVAL;
+ 
+ 	/* deconstruct BTF, if necessary, and invalidate raw_data */
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_type) + sizeof(struct btf_var);
+ 	t = btf_add_type_mem(btf, sz);
+ 	if (!t)
+ 		return -ENOMEM;
+ 
+ 	name_off = btf__add_str(btf, name);
+ 	if (name_off < 0)
+ 		return name_off;
+ 
+ 	t->name_off = name_off;
+ 	t->info = btf_type_info(BTF_KIND_VAR, 0, 0);
+ 	t->type = type_id;
+ 
+ 	v = btf_var(t);
+ 	v->linkage = linkage;
+ 
+ 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	btf->nr_types++;
+ 	return btf->nr_types;
+ }
+ 
+ /*
+  * Append new BTF_KIND_DATASEC type with:
+  *   - *name* - non-empty/non-NULL name;
+  *   - *byte_sz* - data section size, in bytes.
+  *
+  * Data section is initially empty. Variables info can be added with
+  * btf__add_datasec_var_info() calls, after btf__add_datasec() succeeds.
+  *
+  * Returns:
+  *   - >0, type ID of newly added BTF type;
+  *   - <0, on error.
+  */
+ int btf__add_datasec(struct btf *btf, const char *name, __u32 byte_sz)
+ {
+ 	struct btf_type *t;
+ 	int sz, err, name_off;
+ 
+ 	/* non-empty name */
+ 	if (!name || !name[0])
+ 		return -EINVAL;
+ 
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_type);
+ 	t = btf_add_type_mem(btf, sz);
+ 	if (!t)
+ 		return -ENOMEM;
+ 
+ 	name_off = btf__add_str(btf, name);
+ 	if (name_off < 0)
+ 		return name_off;
+ 
+ 	/* start with vlen=0, which will be update as var_secinfos are added */
+ 	t->name_off = name_off;
+ 	t->info = btf_type_info(BTF_KIND_DATASEC, 0, 0);
+ 	t->size = byte_sz;
+ 
+ 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
+ 	if (err)
+ 		return err;
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	btf->nr_types++;
+ 	return btf->nr_types;
+ }
+ 
+ /*
+  * Append new data section variable information entry for current DATASEC type:
+  *   - *var_type_id* - type ID, describing type of the variable;
+  *   - *offset* - variable offset within data section, in bytes;
+  *   - *byte_sz* - variable size, in bytes.
+  *
+  * Returns:
+  *   -  0, on success;
+  *   - <0, on error.
+  */
+ int btf__add_datasec_var_info(struct btf *btf, int var_type_id, __u32 offset, __u32 byte_sz)
+ {
+ 	struct btf_type *t;
+ 	struct btf_var_secinfo *v;
+ 	int sz;
+ 
+ 	/* last type should be BTF_KIND_DATASEC */
+ 	if (btf->nr_types == 0)
+ 		return -EINVAL;
+ 	t = btf_type_by_id(btf, btf->nr_types);
+ 	if (!btf_is_datasec(t))
+ 		return -EINVAL;
+ 
+ 	if (validate_type_id(var_type_id))
+ 		return -EINVAL;
+ 
+ 	/* decompose and invalidate raw data */
+ 	if (btf_ensure_modifiable(btf))
+ 		return -ENOMEM;
+ 
+ 	sz = sizeof(struct btf_var_secinfo);
+ 	v = btf_add_type_mem(btf, sz);
+ 	if (!v)
+ 		return -ENOMEM;
+ 
+ 	v->type = var_type_id;
+ 	v->offset = offset;
+ 	v->size = byte_sz;
+ 
+ 	/* update parent type's vlen */
+ 	t = btf_type_by_id(btf, btf->nr_types);
+ 	btf_type_inc_vlen(t);
+ 
+ 	btf->hdr->type_len += sz;
+ 	btf->hdr->str_off += sz;
+ 	return 0;
+ }
+ 
++>>>>>>> 4a3b33f8579a (libbpf: Add BTF writing APIs)
  struct btf_ext_sec_setup_param {
  	__u32 off;
  	__u32 len;
diff --cc tools/lib/bpf/btf.h
index d511de1e95f1,d6629a2e8ebf..000000000000
--- a/tools/lib/bpf/btf.h
+++ b/tools/lib/bpf/btf.h
@@@ -66,6 -74,47 +66,50 @@@ LIBBPF_API __u32 btf_ext__line_info_rec
  
  LIBBPF_API struct btf *libbpf_find_kernel_btf(void);
  
++<<<<<<< HEAD
++=======
+ LIBBPF_API int btf__find_str(struct btf *btf, const char *s);
+ LIBBPF_API int btf__add_str(struct btf *btf, const char *s);
+ 
+ LIBBPF_API int btf__add_int(struct btf *btf, const char *name, size_t byte_sz, int encoding);
+ LIBBPF_API int btf__add_ptr(struct btf *btf, int ref_type_id);
+ LIBBPF_API int btf__add_array(struct btf *btf,
+ 			      int index_type_id, int elem_type_id, __u32 nr_elems);
+ /* struct/union construction APIs */
+ LIBBPF_API int btf__add_struct(struct btf *btf, const char *name, __u32 sz);
+ LIBBPF_API int btf__add_union(struct btf *btf, const char *name, __u32 sz);
+ LIBBPF_API int btf__add_field(struct btf *btf, const char *name, int field_type_id,
+ 			      __u32 bit_offset, __u32 bit_size);
+ 
+ /* enum construction APIs */
+ LIBBPF_API int btf__add_enum(struct btf *btf, const char *name, __u32 bytes_sz);
+ LIBBPF_API int btf__add_enum_value(struct btf *btf, const char *name, __s64 value);
+ 
+ enum btf_fwd_kind {
+ 	BTF_FWD_STRUCT = 0,
+ 	BTF_FWD_UNION = 1,
+ 	BTF_FWD_ENUM = 2,
+ };
+ 
+ LIBBPF_API int btf__add_fwd(struct btf *btf, const char *name, enum btf_fwd_kind fwd_kind);
+ LIBBPF_API int btf__add_typedef(struct btf *btf, const char *name, int ref_type_id);
+ LIBBPF_API int btf__add_volatile(struct btf *btf, int ref_type_id);
+ LIBBPF_API int btf__add_const(struct btf *btf, int ref_type_id);
+ LIBBPF_API int btf__add_restrict(struct btf *btf, int ref_type_id);
+ 
+ /* func and func_proto construction APIs */
+ LIBBPF_API int btf__add_func(struct btf *btf, const char *name,
+ 			     enum btf_func_linkage linkage, int proto_type_id);
+ LIBBPF_API int btf__add_func_proto(struct btf *btf, int ret_type_id);
+ LIBBPF_API int btf__add_func_param(struct btf *btf, const char *name, int type_id);
+ 
+ /* var & datasec construction APIs */
+ LIBBPF_API int btf__add_var(struct btf *btf, const char *name, int linkage, int type_id);
+ LIBBPF_API int btf__add_datasec(struct btf *btf, const char *name, __u32 byte_sz);
+ LIBBPF_API int btf__add_datasec_var_info(struct btf *btf, int var_type_id,
+ 					 __u32 offset, __u32 byte_sz);
+ 
++>>>>>>> 4a3b33f8579a (libbpf: Add BTF writing APIs)
  struct btf_dedup_opts {
  	unsigned int dedup_table_size;
  	bool dont_resolve_fwds;
diff --cc tools/lib/bpf/libbpf.map
index 69599528ddbe,0216ee6fdc2b..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -286,3 -254,82 +286,85 @@@ LIBBPF_0.0.8 
  		bpf_program__set_lsm;
  		bpf_set_link_xdp_fd_opts;
  } LIBBPF_0.0.7;
++<<<<<<< HEAD
++=======
+ 
+ LIBBPF_0.0.9 {
+ 	global:
+ 		bpf_enable_stats;
+ 		bpf_iter_create;
+ 		bpf_link_get_fd_by_id;
+ 		bpf_link_get_next_id;
+ 		bpf_program__attach_iter;
+ 		bpf_program__attach_netns;
+ 		perf_buffer__consume;
+ 		ring_buffer__add;
+ 		ring_buffer__consume;
+ 		ring_buffer__free;
+ 		ring_buffer__new;
+ 		ring_buffer__poll;
+ } LIBBPF_0.0.8;
+ 
+ LIBBPF_0.1.0 {
+ 	global:
+ 		bpf_link__detach;
+ 		bpf_link_detach;
+ 		bpf_map__ifindex;
+ 		bpf_map__key_size;
+ 		bpf_map__map_flags;
+ 		bpf_map__max_entries;
+ 		bpf_map__numa_node;
+ 		bpf_map__set_key_size;
+ 		bpf_map__set_map_flags;
+ 		bpf_map__set_max_entries;
+ 		bpf_map__set_numa_node;
+ 		bpf_map__set_type;
+ 		bpf_map__set_value_size;
+ 		bpf_map__type;
+ 		bpf_map__value_size;
+ 		bpf_program__attach_xdp;
+ 		bpf_program__autoload;
+ 		bpf_program__is_sk_lookup;
+ 		bpf_program__set_autoload;
+ 		bpf_program__set_sk_lookup;
+ 		btf__parse;
+ 		btf__parse_raw;
+ 		btf__pointer_size;
+ 		btf__set_fd;
+ 		btf__set_pointer_size;
+ } LIBBPF_0.0.9;
+ 
+ LIBBPF_0.2.0 {
+ 	global:
+ 		bpf_prog_bind_map;
+ 		bpf_prog_test_run_opts;
+ 		bpf_program__section_name;
+ 		btf__add_array;
+ 		btf__add_const;
+ 		btf__add_enum;
+ 		btf__add_enum_value;
+ 		btf__add_datasec;
+ 		btf__add_datasec_var_info;
+ 		btf__add_field;
+ 		btf__add_func;
+ 		btf__add_func_param;
+ 		btf__add_func_proto;
+ 		btf__add_fwd;
+ 		btf__add_int;
+ 		btf__add_ptr;
+ 		btf__add_restrict;
+ 		btf__add_str;
+ 		btf__add_struct;
+ 		btf__add_typedef;
+ 		btf__add_union;
+ 		btf__add_var;
+ 		btf__add_volatile;
+ 		btf__find_str;
+ 		btf__new_empty;
+ 		perf_buffer__buffer_cnt;
+ 		perf_buffer__buffer_fd;
+ 		perf_buffer__epoll_fd;
+ 		perf_buffer__consume_buffer;
+ 		xsk_socket__create_shared;
+ } LIBBPF_0.1.0;
++>>>>>>> 4a3b33f8579a (libbpf: Add BTF writing APIs)
* Unmerged path tools/lib/bpf/btf.c
* Unmerged path tools/lib/bpf/btf.h
* Unmerged path tools/lib/bpf/libbpf.map
