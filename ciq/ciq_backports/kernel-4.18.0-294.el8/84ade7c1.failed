mm: migrate: move migrate_page_lock_buffers()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jan Kara <jack@suse.cz>
commit 84ade7c15ccfb46f852f4e2469b007a33651904d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/84ade7c1.failed

buffer_migrate_page() is the only caller of migrate_page_lock_buffers()
move it close to it and also drop the now unused stub for !CONFIG_BLOCK.

Link: http://lkml.kernel.org/r/20181211172143.7358-4-jack@suse.cz
	Signed-off-by: Jan Kara <jack@suse.cz>
	Acked-by: Mel Gorman <mgorman@suse.de>
	Cc: Michal Hocko <mhocko@suse.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 84ade7c15ccfb46f852f4e2469b007a33651904d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/migrate.c
diff --cc mm/migrate.c
index 60059875287d,8392140fb298..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -372,57 -374,7 +372,61 @@@ unlock
  }
  #endif
  
++<<<<<<< HEAD
 +#ifdef CONFIG_BLOCK
 +/* Returns true if all buffers are successfully locked */
 +static bool buffer_migrate_lock_buffers(struct buffer_head *head,
 +							enum migrate_mode mode)
 +{
 +	struct buffer_head *bh = head;
 +
 +	/* Simple case, sync compaction */
 +	if (mode != MIGRATE_ASYNC) {
 +		do {
 +			get_bh(bh);
 +			lock_buffer(bh);
 +			bh = bh->b_this_page;
 +
 +		} while (bh != head);
 +
 +		return true;
 +	}
 +
 +	/* async case, we cannot block on lock_buffer so use trylock_buffer */
 +	do {
 +		get_bh(bh);
 +		if (!trylock_buffer(bh)) {
 +			/*
 +			 * We failed to lock the buffer and cannot stall in
 +			 * async migration. Release the taken locks
 +			 */
 +			struct buffer_head *failed_bh = bh;
 +			put_bh(failed_bh);
 +			bh = head;
 +			while (bh != failed_bh) {
 +				unlock_buffer(bh);
 +				put_bh(bh);
 +				bh = bh->b_this_page;
 +			}
 +			return false;
 +		}
 +
 +		bh = bh->b_this_page;
 +	} while (bh != head);
 +	return true;
 +}
 +#else
 +static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,
 +							enum migrate_mode mode)
 +{
 +	return true;
 +}
 +#endif /* CONFIG_BLOCK */
 +
 +static int expected_page_refs(struct address_space *mapping, struct page *page)
++=======
+ static int expected_page_refs(struct page *page)
++>>>>>>> 84ade7c15ccf (mm: migrate: move migrate_page_lock_buffers())
  {
  	int expected_count = 1;
  
* Unmerged path mm/migrate.c
