powerpc/xmon: Restrict when kernel is locked down

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christopher M. Riedl <cmr@informatik.wtf>
commit 69393cb03ccdf29f3b452d3482ef918469d1c098
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/69393cb0.failed

Xmon should be either fully or partially disabled depending on the
kernel lockdown state.

Put xmon into read-only mode for lockdown=integrity and prevent user
entry into xmon when lockdown=confidentiality. Xmon checks the lockdown
state on every attempted entry:

 (1) during early xmon'ing

 (2) when triggered via sysrq

 (3) when toggled via debugfs

 (4) when triggered via a previously enabled breakpoint

The following lockdown state transitions are handled:

 (1) lockdown=none -> lockdown=integrity
     set xmon read-only mode

 (2) lockdown=none -> lockdown=confidentiality
     clear all breakpoints, set xmon read-only mode,
     prevent user re-entry into xmon

 (3) lockdown=integrity -> lockdown=confidentiality
     clear all breakpoints, set xmon read-only mode,
     prevent user re-entry into xmon

	Suggested-by: Andrew Donnellan <ajd@linux.ibm.com>
	Signed-off-by: Christopher M. Riedl <cmr@informatik.wtf>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20190907061124.1947-3-cmr@informatik.wtf
(cherry picked from commit 69393cb03ccdf29f3b452d3482ef918469d1c098)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/xmon/xmon.c
#	include/linux/security.h
#	security/lockdown/lockdown.c
diff --cc arch/powerpc/xmon/xmon.c
index 1e20234c1e36,0a438b51dbb5..000000000000
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@@ -460,8 -500,12 +495,17 @@@ static int xmon_core(struct pt_regs *re
  	local_irq_save(flags);
  	hard_irq_disable();
  
++<<<<<<< HEAD
 +	tracing_enabled = tracing_is_on();
 +	tracing_off();
++=======
+ 	locked_down = xmon_is_locked_down();
+ 
+ 	if (!fromipi) {
+ 		tracing_enabled = tracing_is_on();
+ 		tracing_off();
+ 	}
++>>>>>>> 69393cb03ccd (powerpc/xmon: Restrict when kernel is locked down)
  
  	bp = in_breakpoint_table(regs->nip, &offset);
  	if (bp != NULL) {
diff --cc include/linux/security.h
index ea494663ce29,79567eacb834..000000000000
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@@ -77,6 -77,56 +77,59 @@@ enum lsm_event 
  	LSM_POLICY_CHANGE,
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * These are reasons that can be passed to the security_locked_down()
+  * LSM hook. Lockdown reasons that protect kernel integrity (ie, the
+  * ability for userland to modify kernel code) are placed before
+  * LOCKDOWN_INTEGRITY_MAX.  Lockdown reasons that protect kernel
+  * confidentiality (ie, the ability for userland to extract
+  * information from the running kernel that would otherwise be
+  * restricted) are placed before LOCKDOWN_CONFIDENTIALITY_MAX.
+  *
+  * LSM authors should note that the semantics of any given lockdown
+  * reason are not guaranteed to be stable - the same reason may block
+  * one set of features in one kernel release, and a slightly different
+  * set of features in a later kernel release. LSMs that seek to expose
+  * lockdown policy at any level of granularity other than "none",
+  * "integrity" or "confidentiality" are responsible for either
+  * ensuring that they expose a consistent level of functionality to
+  * userland, or ensuring that userland is aware that this is
+  * potentially a moving target. It is easy to misuse this information
+  * in a way that could break userspace. Please be careful not to do
+  * so.
+  *
+  * If you add to this, remember to extend lockdown_reasons in
+  * security/lockdown/lockdown.c.
+  */
+ enum lockdown_reason {
+ 	LOCKDOWN_NONE,
+ 	LOCKDOWN_MODULE_SIGNATURE,
+ 	LOCKDOWN_DEV_MEM,
+ 	LOCKDOWN_KEXEC,
+ 	LOCKDOWN_HIBERNATION,
+ 	LOCKDOWN_PCI_ACCESS,
+ 	LOCKDOWN_IOPORT,
+ 	LOCKDOWN_MSR,
+ 	LOCKDOWN_ACPI_TABLES,
+ 	LOCKDOWN_PCMCIA_CIS,
+ 	LOCKDOWN_TIOCSSERIAL,
+ 	LOCKDOWN_MODULE_PARAMETERS,
+ 	LOCKDOWN_MMIOTRACE,
+ 	LOCKDOWN_DEBUGFS,
+ 	LOCKDOWN_XMON_WR,
+ 	LOCKDOWN_INTEGRITY_MAX,
+ 	LOCKDOWN_KCORE,
+ 	LOCKDOWN_KPROBES,
+ 	LOCKDOWN_BPF_READ,
+ 	LOCKDOWN_PERF,
+ 	LOCKDOWN_TRACEFS,
+ 	LOCKDOWN_XMON_RW,
+ 	LOCKDOWN_CONFIDENTIALITY_MAX,
+ };
+ 
++>>>>>>> 69393cb03ccd (powerpc/xmon: Restrict when kernel is locked down)
  /* These functions are in security/commoncap.c */
  extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
  		       int cap, unsigned int opts);
* Unmerged path security/lockdown/lockdown.c
* Unmerged path arch/powerpc/xmon/xmon.c
* Unmerged path include/linux/security.h
* Unmerged path security/lockdown/lockdown.c
