intel_idle: Customize IceLake server support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chen Yu <yu.c.chen@intel.com>
commit a472ad2bcea479ba068880125d7273fc95c14b70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a472ad2b.failed

On ICX platform, the C1E auto-promotion is enabled by default.
As a result, the CPU might fall into C1E more offen than previous
platforms. Besides, the C1E is not exposed to sysfs on ICX, which
is inconsistent with previous server platforms.

So disable C1E auto-promotion and expose C1E as a separate idle
state, so the C1E and C6 can be disabled via sysfs when necessary.

Beside C1 and C1E, the exit latency of C6 was measured
by a dedicated tool. However the exit latency(41us) exposed
by _CST is much smaller than the one we measured(128us). This
is probably due to the _CST uses the exit latency when woken
up from PC0+C6, rather than PC6+C6 when C6 was measured. Choose
the latter as we need the longest latency in theory.

	Reported-by: kernel test robot <lkp@intel.com>
	Tested-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
	Acked-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
	Reviewed-by: Zhang Rui <rui.zhang@intel.com>
	Signed-off-by: Chen Yu <yu.c.chen@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit a472ad2bcea479ba068880125d7273fc95c14b70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/idle/intel_idle.c
diff --cc drivers/idle/intel_idle.c
index 0c5221d5504f,fd0fa9e7900b..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -691,7 -752,36 +691,40 @@@ static struct cpuidle_state skx_cstates
  		.enter = NULL }
  };
  
++<<<<<<< HEAD
 +static struct cpuidle_state atom_cstates[] = {
++=======
+ static struct cpuidle_state icx_cstates[] __initdata = {
+ 	{
+ 		.name = "C1",
+ 		.desc = "MWAIT 0x00",
+ 		.flags = MWAIT2flg(0x00),
+ 		.exit_latency = 1,
+ 		.target_residency = 1,
+ 		.enter = &intel_idle,
+ 		.enter_s2idle = intel_idle_s2idle, },
+ 	{
+ 		.name = "C1E",
+ 		.desc = "MWAIT 0x01",
+ 		.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,
+ 		.exit_latency = 4,
+ 		.target_residency = 4,
+ 		.enter = &intel_idle,
+ 		.enter_s2idle = intel_idle_s2idle, },
+ 	{
+ 		.name = "C6",
+ 		.desc = "MWAIT 0x20",
+ 		.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,
+ 		.exit_latency = 128,
+ 		.target_residency = 384,
+ 		.enter = &intel_idle,
+ 		.enter_s2idle = intel_idle_s2idle, },
+ 	{
+ 		.enter = NULL }
+ };
+ 
+ static struct cpuidle_state atom_cstates[] __initdata = {
++>>>>>>> a472ad2bcea4 (intel_idle: Customize IceLake server support)
  	{
  		.name = "C1E",
  		.desc = "MWAIT 0x00",
@@@ -1103,7 -1085,13 +1136,17 @@@ static const struct idle_cpu idle_cpu_s
  	.use_acpi = true,
  };
  
++<<<<<<< HEAD
 +static const struct idle_cpu idle_cpu_avn = {
++=======
+ static const struct idle_cpu idle_cpu_icx __initconst = {
+ 	.state_table = icx_cstates,
+ 	.disable_promotion_to_c1e = true,
+ 	.use_acpi = true,
+ };
+ 
+ static const struct idle_cpu idle_cpu_avn __initconst = {
++>>>>>>> a472ad2bcea4 (intel_idle: Customize IceLake server support)
  	.state_table = avn_cstates,
  	.disable_promotion_to_c1e = true,
  	.use_acpi = true,
* Unmerged path drivers/idle/intel_idle.c
