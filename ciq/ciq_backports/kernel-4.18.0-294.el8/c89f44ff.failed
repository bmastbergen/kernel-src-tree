net: stmmac: Add support for VLAN promiscuous mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chuah, Kim Tatt <kim.tatt.chuah@intel.com>
commit c89f44ff10fd4cdcfbebf4854aa1282fdad8de5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c89f44ff.failed

For dwmac4, enable VLAN promiscuity when MAC controller is requested to
enter promiscuous mode.

	Signed-off-by: Chuah, Kim Tatt <kim.tatt.chuah@intel.com>
	Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
	Signed-off-by: Tan, Tee Min <tee.min.tan@intel.com>
	Signed-off-by: Wong Vee Khee <vee.khee.wong@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c89f44ff10fd4cdcfbebf4854aa1282fdad8de5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/common.h
#	drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
diff --cc drivers/net/ethernet/stmicro/stmmac/common.h
index 41eb39add60e,127f75862962..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@@ -458,6 -470,10 +458,13 @@@ struct mac_device_info 
  	unsigned int pcs;
  	unsigned int pmt;
  	unsigned int ps;
++<<<<<<< HEAD
++=======
+ 	unsigned int xlgmac;
+ 	unsigned int num_vlan;
+ 	u32 vlan_filter[32];
+ 	unsigned int promisc;
++>>>>>>> c89f44ff10fd (net: stmmac: Add support for VLAN promiscuous mode)
  };
  
  struct stmmac_rx_routing {
diff --cc drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
index bbfc7674bde1,ecd834e0e121..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
@@@ -397,6 -394,211 +397,214 @@@ static void dwmac4_set_eee_timer(struc
  	writel(value, ioaddr + GMAC4_LPI_TIMER_CTRL);
  }
  
++<<<<<<< HEAD
++=======
+ static void dwmac4_write_single_vlan(struct net_device *dev, u16 vid)
+ {
+ 	void __iomem *ioaddr = (void __iomem *)dev->base_addr;
+ 	u32 val;
+ 
+ 	val = readl(ioaddr + GMAC_VLAN_TAG);
+ 	val &= ~GMAC_VLAN_TAG_VID;
+ 	val |= GMAC_VLAN_TAG_ETV | vid;
+ 
+ 	writel(val, ioaddr + GMAC_VLAN_TAG);
+ }
+ 
+ static int dwmac4_write_vlan_filter(struct net_device *dev,
+ 				    struct mac_device_info *hw,
+ 				    u8 index, u32 data)
+ {
+ 	void __iomem *ioaddr = (void __iomem *)dev->base_addr;
+ 	int i, timeout = 10;
+ 	u32 val;
+ 
+ 	if (index >= hw->num_vlan)
+ 		return -EINVAL;
+ 
+ 	writel(data, ioaddr + GMAC_VLAN_TAG_DATA);
+ 
+ 	val = readl(ioaddr + GMAC_VLAN_TAG);
+ 	val &= ~(GMAC_VLAN_TAG_CTRL_OFS_MASK |
+ 		GMAC_VLAN_TAG_CTRL_CT |
+ 		GMAC_VLAN_TAG_CTRL_OB);
+ 	val |= (index << GMAC_VLAN_TAG_CTRL_OFS_SHIFT) | GMAC_VLAN_TAG_CTRL_OB;
+ 
+ 	writel(val, ioaddr + GMAC_VLAN_TAG);
+ 
+ 	for (i = 0; i < timeout; i++) {
+ 		val = readl(ioaddr + GMAC_VLAN_TAG);
+ 		if (!(val & GMAC_VLAN_TAG_CTRL_OB))
+ 			return 0;
+ 		udelay(1);
+ 	}
+ 
+ 	netdev_err(dev, "Timeout accessing MAC_VLAN_Tag_Filter\n");
+ 
+ 	return -EBUSY;
+ }
+ 
+ static int dwmac4_add_hw_vlan_rx_fltr(struct net_device *dev,
+ 				      struct mac_device_info *hw,
+ 				      __be16 proto, u16 vid)
+ {
+ 	int index = -1;
+ 	u32 val = 0;
+ 	int i, ret;
+ 
+ 	if (vid > 4095)
+ 		return -EINVAL;
+ 
+ 	if (hw->promisc) {
+ 		netdev_err(dev,
+ 			   "Adding VLAN in promisc mode not supported\n");
+ 		return -EPERM;
+ 	}
+ 
+ 	/* Single Rx VLAN Filter */
+ 	if (hw->num_vlan == 1) {
+ 		/* For single VLAN filter, VID 0 means VLAN promiscuous */
+ 		if (vid == 0) {
+ 			netdev_warn(dev, "Adding VLAN ID 0 is not supported\n");
+ 			return -EPERM;
+ 		}
+ 
+ 		if (hw->vlan_filter[0] & GMAC_VLAN_TAG_VID) {
+ 			netdev_err(dev, "Only single VLAN ID supported\n");
+ 			return -EPERM;
+ 		}
+ 
+ 		hw->vlan_filter[0] = vid;
+ 		dwmac4_write_single_vlan(dev, vid);
+ 
+ 		return 0;
+ 	}
+ 
+ 	/* Extended Rx VLAN Filter Enable */
+ 	val |= GMAC_VLAN_TAG_DATA_ETV | GMAC_VLAN_TAG_DATA_VEN | vid;
+ 
+ 	for (i = 0; i < hw->num_vlan; i++) {
+ 		if (hw->vlan_filter[i] == val)
+ 			return 0;
+ 		else if (!(hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VEN))
+ 			index = i;
+ 	}
+ 
+ 	if (index == -1) {
+ 		netdev_err(dev, "MAC_VLAN_Tag_Filter full (size: %0u)\n",
+ 			   hw->num_vlan);
+ 		return -EPERM;
+ 	}
+ 
+ 	ret = dwmac4_write_vlan_filter(dev, hw, index, val);
+ 
+ 	if (!ret)
+ 		hw->vlan_filter[index] = val;
+ 
+ 	return ret;
+ }
+ 
+ static int dwmac4_del_hw_vlan_rx_fltr(struct net_device *dev,
+ 				      struct mac_device_info *hw,
+ 				      __be16 proto, u16 vid)
+ {
+ 	int i, ret = 0;
+ 
+ 	if (hw->promisc) {
+ 		netdev_err(dev,
+ 			   "Deleting VLAN in promisc mode not supported\n");
+ 		return -EPERM;
+ 	}
+ 
+ 	/* Single Rx VLAN Filter */
+ 	if (hw->num_vlan == 1) {
+ 		if ((hw->vlan_filter[0] & GMAC_VLAN_TAG_VID) == vid) {
+ 			hw->vlan_filter[0] = 0;
+ 			dwmac4_write_single_vlan(dev, 0);
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	/* Extended Rx VLAN Filter Enable */
+ 	for (i = 0; i < hw->num_vlan; i++) {
+ 		if ((hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VID) == vid) {
+ 			ret = dwmac4_write_vlan_filter(dev, hw, i, 0);
+ 
+ 			if (!ret)
+ 				hw->vlan_filter[i] = 0;
+ 			else
+ 				return ret;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void dwmac4_vlan_promisc_enable(struct net_device *dev,
+ 				       struct mac_device_info *hw)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	u32 hash;
+ 	u32 val;
+ 	int i;
+ 
+ 	/* Single Rx VLAN Filter */
+ 	if (hw->num_vlan == 1) {
+ 		dwmac4_write_single_vlan(dev, 0);
+ 		return;
+ 	}
+ 
+ 	/* Extended Rx VLAN Filter Enable */
+ 	for (i = 0; i < hw->num_vlan; i++) {
+ 		if (hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VEN) {
+ 			val = hw->vlan_filter[i] & ~GMAC_VLAN_TAG_DATA_VEN;
+ 			dwmac4_write_vlan_filter(dev, hw, i, val);
+ 		}
+ 	}
+ 
+ 	hash = readl(ioaddr + GMAC_VLAN_HASH_TABLE);
+ 	if (hash & GMAC_VLAN_VLHT) {
+ 		value = readl(ioaddr + GMAC_VLAN_TAG);
+ 		if (value & GMAC_VLAN_VTHM) {
+ 			value &= ~GMAC_VLAN_VTHM;
+ 			writel(value, ioaddr + GMAC_VLAN_TAG);
+ 		}
+ 	}
+ }
+ 
+ static void dwmac4_restore_hw_vlan_rx_fltr(struct net_device *dev,
+ 					   struct mac_device_info *hw)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	u32 hash;
+ 	u32 val;
+ 	int i;
+ 
+ 	/* Single Rx VLAN Filter */
+ 	if (hw->num_vlan == 1) {
+ 		dwmac4_write_single_vlan(dev, hw->vlan_filter[0]);
+ 		return;
+ 	}
+ 
+ 	/* Extended Rx VLAN Filter Enable */
+ 	for (i = 0; i < hw->num_vlan; i++) {
+ 		if (hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VEN) {
+ 			val = hw->vlan_filter[i];
+ 			dwmac4_write_vlan_filter(dev, hw, i, val);
+ 		}
+ 	}
+ 
+ 	hash = readl(ioaddr + GMAC_VLAN_HASH_TABLE);
+ 	if (hash & GMAC_VLAN_VLHT) {
+ 		value = readl(ioaddr + GMAC_VLAN_TAG);
+ 		value |= GMAC_VLAN_VTHM;
+ 		writel(value, ioaddr + GMAC_VLAN_TAG);
+ 	}
+ }
+ 
++>>>>>>> c89f44ff10fd (net: stmmac: Add support for VLAN promiscuous mode)
  static void dwmac4_set_filter(struct mac_device_info *hw,
  			      struct net_device *dev)
  {
@@@ -472,7 -674,23 +680,19 @@@
  		}
  	}
  
 -	/* VLAN filtering */
 -	if (dev->features & NETIF_F_HW_VLAN_CTAG_FILTER)
 -		value |= GMAC_PACKET_FILTER_VTFE;
 -
  	writel(value, ioaddr + GMAC_PACKET_FILTER);
+ 
+ 	if (dev->flags & IFF_PROMISC) {
+ 		if (!hw->promisc) {
+ 			hw->promisc = 1;
+ 			dwmac4_vlan_promisc_enable(dev, hw);
+ 		}
+ 	} else {
+ 		if (hw->promisc) {
+ 			hw->promisc = 0;
+ 			dwmac4_restore_hw_vlan_rx_fltr(dev, hw);
+ 		}
+ 	}
  }
  
  static void dwmac4_flow_ctrl(struct mac_device_info *hw, unsigned int duplex,
* Unmerged path drivers/net/ethernet/stmicro/stmmac/common.h
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4.h b/drivers/net/ethernet/stmicro/stmmac/dwmac4.h
index 20baf870a602..51c1fa03c172 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4.h
@@ -90,6 +90,7 @@
 #define GMAC_VLAN_CSVL			BIT(19)
 #define GMAC_VLAN_VLC			GENMASK(17, 16)
 #define GMAC_VLAN_VLC_SHIFT		16
+#define GMAC_VLAN_VLHT			GENMASK(15, 0)
 
 /* MAC RX Queue Enable */
 #define GMAC_RX_QUEUE_CLEAR(queue)	~(GENMASK(1, 0) << ((queue) * 2))
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
