Revert "block: Fix a lockdep complaint triggered by request queue flushing"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 7aa390ec2d9db0cd6677d95d0b8f307f9c086770
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7aa390ec.failed

This reverts commit b3c6a59975415bde29cfd76ff1ab008edbf614a9.

Now we can avoid nvme-loop lockdep warning of 'lockdep possible recursive locking'
by nvme-loop's lock class, no need to apply dynamically allocated lock class key,
so revert commit b3c6a5997541("block: Fix a lockdep complaint triggered by request
queue flushing").

This way fixes horrible SCSI probe delay issue on megaraid_sas, and it is reported
the whole probe may take more than half an hour.

	Tested-by: Kashyap Desai <kashyap.desai@broadcom.com>
	Reported-by: Qian Cai <cai@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Cc: Sumit Saxena <sumit.saxena@broadcom.com>
	Cc: John Garry <john.garry@huawei.com>
	Cc: Kashyap Desai <kashyap.desai@broadcom.com>
	Cc: Bart Van Assche <bvanassche@acm.org>
	Cc: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 7aa390ec2d9db0cd6677d95d0b8f307f9c086770)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-flush.c
#	block/blk.h
diff --cc block/blk-flush.c
index 683374e4d084,996d5d03dade..000000000000
--- a/block/blk-flush.c
+++ b/block/blk-flush.c
@@@ -494,7 -482,31 +490,11 @@@ void blk_free_flush_queue(struct blk_fl
  	if (!fq)
  		return;
  
++<<<<<<< HEAD
 +	lockdep_unregister_key(&fq->key);
 +	kfree((void *)fq->flush_rq - sizeof(struct request_aux));
++=======
+ 	kfree(fq->flush_rq);
++>>>>>>> 7aa390ec2d9d (Revert "block: Fix a lockdep complaint triggered by request queue flushing")
  	kfree(fq);
  }
 -
 -/*
 - * Allow driver to set its own lock class to fq->mq_flush_lock for
 - * avoiding lockdep complaint.
 - *
 - * flush_end_io() may be called recursively from some driver, such as
 - * nvme-loop, so lockdep may complain 'possible recursive locking' because
 - * all 'struct blk_flush_queue' instance share same mq_flush_lock lock class
 - * key. We need to assign different lock class for these driver's
 - * fq->mq_flush_lock for avoiding the lockdep warning.
 - *
 - * Use dynamically allocated lock class key for each 'blk_flush_queue'
 - * instance is over-kill, and more worse it introduces horrible boot delay
 - * issue because synchronize_rcu() is implied in lockdep_unregister_key which
 - * is called for each hctx release. SCSI probing may synchronously create and
 - * destroy lots of MQ request_queues for non-existent devices, and some robot
 - * test kernel always enable lockdep option. It is observed that more than half
 - * an hour is taken during SCSI MQ probe with per-fq lock class.
 - */
 -void blk_mq_hctx_set_fq_lock_class(struct blk_mq_hw_ctx *hctx,
 -		struct lock_class_key *key)
 -{
 -	lockdep_set_class(&hctx->fq->mq_flush_lock, key);
 -}
 -EXPORT_SYMBOL_GPL(blk_mq_hctx_set_fq_lock_class);
diff --cc block/blk.h
index dcc1b6ac09cc,d23d018fd2cd..000000000000
--- a/block/blk.h
+++ b/block/blk.h
@@@ -23,14 -25,7 +23,17 @@@ struct blk_flush_queue 
  	struct list_head	flush_data_in_flight;
  	struct request		*flush_rq;
  
++<<<<<<< HEAD
 +	/*
 +	 * flush_rq shares tag with this rq, both can't be active
 +	 * at the same time
 +	 */
 +	struct request		*orig_rq;
++=======
++>>>>>>> 7aa390ec2d9d (Revert "block: Fix a lockdep complaint triggered by request queue flushing")
  	spinlock_t		mq_flush_lock;
 +	RH_KABI_EXTEND(blk_status_t 		rq_status)
 +	RH_KABI_EXTEND(struct lock_class_key	key)
  };
  
  extern struct kmem_cache *blk_requestq_cachep;
* Unmerged path block/blk-flush.c
* Unmerged path block/blk.h
