x86/traps: Move pf error codes to <asm/trap_pf.h>

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] traps: Move pf error codes to <asm/trap_pf.h> (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 95.74%
commit-author Joerg Roedel <jroedel@suse.de>
commit 05a2fdf3230306daee1def019b8f52cd06bd2e48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/05a2fdf3.failed

Move the definition of the x86 page-fault error code bits to a new
header file asm/trap_pf.h. This makes it easier to include them into
pre-decompression boot code. No functional changes.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20200907131613.12703-7-joro@8bytes.org
(cherry picked from commit 05a2fdf3230306daee1def019b8f52cd06bd2e48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/traps.h
diff --cc arch/x86/include/asm/traps.h
index 0ae298ea01a1,6a308355ea29..000000000000
--- a/arch/x86/include/asm/traps.h
+++ b/arch/x86/include/asm/traps.h
@@@ -6,75 -6,11 +6,76 @@@
  #include <linux/kprobes.h>
  
  #include <asm/debugreg.h>
 -#include <asm/idtentry.h>
  #include <asm/siginfo.h>			/* TRAP_TRACE, ... */
+ #include <asm/trap_pf.h>
  
 +#define dotraplinkage __visible
 +
 +asmlinkage void divide_error(void);
 +asmlinkage void debug(void);
 +asmlinkage void nmi(void);
 +asmlinkage void int3(void);
 +asmlinkage void overflow(void);
 +asmlinkage void bounds(void);
 +asmlinkage void invalid_op(void);
 +asmlinkage void device_not_available(void);
 +#ifdef CONFIG_X86_64
 +asmlinkage void double_fault(void);
 +#endif
 +asmlinkage void coprocessor_segment_overrun(void);
 +asmlinkage void invalid_TSS(void);
 +asmlinkage void segment_not_present(void);
 +asmlinkage void stack_segment(void);
 +asmlinkage void general_protection(void);
 +asmlinkage void page_fault(void);
 +asmlinkage void async_page_fault(void);
 +asmlinkage void spurious_interrupt_bug(void);
 +asmlinkage void coprocessor_error(void);
 +asmlinkage void alignment_check(void);
 +#ifdef CONFIG_X86_MCE
 +asmlinkage void machine_check(void);
 +#endif /* CONFIG_X86_MCE */
 +asmlinkage void simd_coprocessor_error(void);
 +
 +#if defined(CONFIG_X86_64) && defined(CONFIG_XEN_PV)
 +asmlinkage void xen_divide_error(void);
 +asmlinkage void xen_xennmi(void);
 +asmlinkage void xen_xendebug(void);
 +asmlinkage void xen_xenint3(void);
 +asmlinkage void xen_overflow(void);
 +asmlinkage void xen_bounds(void);
 +asmlinkage void xen_invalid_op(void);
 +asmlinkage void xen_device_not_available(void);
 +asmlinkage void xen_double_fault(void);
 +asmlinkage void xen_coprocessor_segment_overrun(void);
 +asmlinkage void xen_invalid_TSS(void);
 +asmlinkage void xen_segment_not_present(void);
 +asmlinkage void xen_stack_segment(void);
 +asmlinkage void xen_general_protection(void);
 +asmlinkage void xen_page_fault(void);
 +asmlinkage void xen_spurious_interrupt_bug(void);
 +asmlinkage void xen_coprocessor_error(void);
 +asmlinkage void xen_alignment_check(void);
 +#ifdef CONFIG_X86_MCE
 +asmlinkage void xen_machine_check(void);
 +#endif /* CONFIG_X86_MCE */
 +asmlinkage void xen_simd_coprocessor_error(void);
 +#endif
 +
 +dotraplinkage void do_divide_error(struct pt_regs *, long);
 +dotraplinkage void do_debug(struct pt_regs *, long);
 +dotraplinkage void do_nmi(struct pt_regs *, long);
 +dotraplinkage void do_int3(struct pt_regs *, long);
 +dotraplinkage void do_overflow(struct pt_regs *, long);
 +dotraplinkage void do_bounds(struct pt_regs *, long);
 +dotraplinkage void do_invalid_op(struct pt_regs *, long);
 +dotraplinkage void do_device_not_available(struct pt_regs *, long);
 +dotraplinkage void do_coprocessor_segment_overrun(struct pt_regs *, long);
 +dotraplinkage void do_invalid_TSS(struct pt_regs *, long);
 +dotraplinkage void do_segment_not_present(struct pt_regs *, long);
 +dotraplinkage void do_stack_segment(struct pt_regs *, long);
  #ifdef CONFIG_X86_64
 +dotraplinkage void do_double_fault(struct pt_regs *, long);
  asmlinkage __visible notrace struct pt_regs *sync_regs(struct pt_regs *eregs);
  asmlinkage __visible notrace
  struct bad_iret_stack *fixup_bad_iret(struct bad_iret_stack *s);
@@@ -124,47 -42,4 +125,50 @@@ void __noreturn handle_stack_overflow(c
  				      unsigned long fault_address);
  #endif
  
++<<<<<<< HEAD
 +/* Interrupts/Exceptions */
 +enum {
 +	X86_TRAP_DE = 0,	/*  0, Divide-by-zero */
 +	X86_TRAP_DB,		/*  1, Debug */
 +	X86_TRAP_NMI,		/*  2, Non-maskable Interrupt */
 +	X86_TRAP_BP,		/*  3, Breakpoint */
 +	X86_TRAP_OF,		/*  4, Overflow */
 +	X86_TRAP_BR,		/*  5, Bound Range Exceeded */
 +	X86_TRAP_UD,		/*  6, Invalid Opcode */
 +	X86_TRAP_NM,		/*  7, Device Not Available */
 +	X86_TRAP_DF,		/*  8, Double Fault */
 +	X86_TRAP_OLD_MF,	/*  9, Coprocessor Segment Overrun */
 +	X86_TRAP_TS,		/* 10, Invalid TSS */
 +	X86_TRAP_NP,		/* 11, Segment Not Present */
 +	X86_TRAP_SS,		/* 12, Stack Segment Fault */
 +	X86_TRAP_GP,		/* 13, General Protection Fault */
 +	X86_TRAP_PF,		/* 14, Page Fault */
 +	X86_TRAP_SPURIOUS,	/* 15, Spurious Interrupt */
 +	X86_TRAP_MF,		/* 16, x87 Floating-Point Exception */
 +	X86_TRAP_AC,		/* 17, Alignment Check */
 +	X86_TRAP_MC,		/* 18, Machine Check */
 +	X86_TRAP_XF,		/* 19, SIMD Floating-Point Exception */
 +	X86_TRAP_IRET = 32,	/* 32, IRET Exception */
 +};
 +
 +/*
 + * Page fault error code bits:
 + *
 + *   bit 0 ==	 0: no page found	1: protection fault
 + *   bit 1 ==	 0: read access		1: write access
 + *   bit 2 ==	 0: kernel-mode access	1: user-mode access
 + *   bit 3 ==				1: use of reserved bit detected
 + *   bit 4 ==				1: fault was an instruction fetch
 + *   bit 5 ==				1: protection keys block access
 + */
 +enum x86_pf_error_code {
 +	X86_PF_PROT	=		1 << 0,
 +	X86_PF_WRITE	=		1 << 1,
 +	X86_PF_USER	=		1 << 2,
 +	X86_PF_RSVD	=		1 << 3,
 +	X86_PF_INSTR	=		1 << 4,
 +	X86_PF_PK	=		1 << 5,
 +};
++=======
++>>>>>>> 05a2fdf32303 (x86/traps: Move pf error codes to <asm/trap_pf.h>)
  #endif /* _ASM_X86_TRAPS_H */
diff --git a/arch/x86/include/asm/trap_pf.h b/arch/x86/include/asm/trap_pf.h
new file mode 100644
index 000000000000..305bc1214aef
--- /dev/null
+++ b/arch/x86/include/asm/trap_pf.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_X86_TRAP_PF_H
+#define _ASM_X86_TRAP_PF_H
+
+/*
+ * Page fault error code bits:
+ *
+ *   bit 0 ==	 0: no page found	1: protection fault
+ *   bit 1 ==	 0: read access		1: write access
+ *   bit 2 ==	 0: kernel-mode access	1: user-mode access
+ *   bit 3 ==				1: use of reserved bit detected
+ *   bit 4 ==				1: fault was an instruction fetch
+ *   bit 5 ==				1: protection keys block access
+ */
+enum x86_pf_error_code {
+	X86_PF_PROT	=		1 << 0,
+	X86_PF_WRITE	=		1 << 1,
+	X86_PF_USER	=		1 << 2,
+	X86_PF_RSVD	=		1 << 3,
+	X86_PF_INSTR	=		1 << 4,
+	X86_PF_PK	=		1 << 5,
+};
+
+#endif /* _ASM_X86_TRAP_PF_H */
* Unmerged path arch/x86/include/asm/traps.h
