cpuidle: Allow cpuidle drivers to take over RCU-idle

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 8747f2022fe8d8029193707ee86ff5c792cbef9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8747f202.failed

Some drivers have to do significant work, some of which relies on RCU
still being active. Instead of using RCU_NONIDLE in the drivers and
flipping RCU back on, allow drivers to take over RCU-idle duty.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 8747f2022fe8d8029193707ee86ff5c792cbef9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpuidle.h
diff --cc include/linux/cpuidle.h
index 57c6cc62bebc,6175c77bf25e..000000000000
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@@ -107,12 -75,14 +107,23 @@@ struct cpuidle_state 
  };
  
  /* Idle State Flags */
++<<<<<<< HEAD
 +#define CPUIDLE_FLAG_NONE       (0x00)
 +#define CPUIDLE_FLAG_POLLING	BIT(0) /* polling state */
 +#define CPUIDLE_FLAG_COUPLED	BIT(1) /* state applies to multiple cpus */
 +#define CPUIDLE_FLAG_TIMER_STOP BIT(2) /* timer is stopped on this state */
 +#define CPUIDLE_FLAG_UNUSABLE	BIT(3) /* avoid using this state */
 +#define CPUIDLE_FLAG_OFF	BIT(4) /* disable this state by default */
++=======
+ #define CPUIDLE_FLAG_NONE       	(0x00)
+ #define CPUIDLE_FLAG_POLLING		BIT(0) /* polling state */
+ #define CPUIDLE_FLAG_COUPLED		BIT(1) /* state applies to multiple cpus */
+ #define CPUIDLE_FLAG_TIMER_STOP 	BIT(2) /* timer is stopped on this state */
+ #define CPUIDLE_FLAG_UNUSABLE		BIT(3) /* avoid using this state */
+ #define CPUIDLE_FLAG_OFF		BIT(4) /* disable this state by default */
+ #define CPUIDLE_FLAG_TLB_FLUSHED	BIT(5) /* idle-state flushes TLBs */
+ #define CPUIDLE_FLAG_RCU_IDLE		BIT(6) /* idle-state takes care of RCU */
++>>>>>>> 8747f2022fe8 (cpuidle: Allow cpuidle drivers to take over RCU-idle)
  
  struct cpuidle_device_kobj;
  struct cpuidle_state_kobj;
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 7b9da773160e..21a1079449a6 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -135,6 +135,7 @@ static void enter_s2idle_proper(struct cpuidle_driver *drv,
 				struct cpuidle_device *dev, int index)
 {
 	ktime_t time_start, time_end;
+	struct cpuidle_state *target_state = &drv->states[index];
 
 	time_start = ns_to_ktime(local_clock());
 
@@ -150,8 +151,9 @@ static void enter_s2idle_proper(struct cpuidle_driver *drv,
 	 * suspended is generally unsafe.
 	 */
 	stop_critical_timings();
-	rcu_idle_enter();
-	drv->states[index].enter_s2idle(dev, drv, index);
+	if (!(target_state->flags & CPUIDLE_FLAG_RCU_IDLE))
+		rcu_idle_enter();
+	target_state->enter_s2idle(dev, drv, index);
 	if (WARN_ON_ONCE(!irqs_disabled()))
 		local_irq_disable();
 	/*
@@ -159,7 +161,8 @@ static void enter_s2idle_proper(struct cpuidle_driver *drv,
 	 * first CPU executing it calls functions containing RCU read-side
 	 * critical sections, so tell RCU about that.
 	 */
-	rcu_idle_exit();
+	if (!(target_state->flags & CPUIDLE_FLAG_RCU_IDLE))
+		rcu_idle_exit();
 	tick_unfreeze();
 	start_critical_timings();
 
@@ -233,9 +236,11 @@ int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,
 	time_start = ns_to_ktime(local_clock());
 
 	stop_critical_timings();
-	rcu_idle_enter();
+	if (!(target_state->flags & CPUIDLE_FLAG_RCU_IDLE))
+		rcu_idle_enter();
 	entered_state = target_state->enter(dev, drv, index);
-	rcu_idle_exit();
+	if (!(target_state->flags & CPUIDLE_FLAG_RCU_IDLE))
+		rcu_idle_exit();
 	start_critical_timings();
 
 	sched_clock_idle_wakeup_event();
* Unmerged path include/linux/cpuidle.h
