cgroup: store a reference to cgroup_ns into cgroup_fs_context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit cca8f32714d3a8bb4d109c9d7d790fd705b734e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cca8f327.failed

... and trim cgroup_do_mount() arguments (renaming it to cgroup_do_get_tree())

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit cca8f32714d3a8bb4d109c9d7d790fd705b734e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cgroup/cgroup-internal.h
#	kernel/cgroup/cgroup-v1.c
#	kernel/cgroup/cgroup.c
diff --cc kernel/cgroup/cgroup-internal.h
index ce1c1553c696,37cf709b7a0e..000000000000
--- a/kernel/cgroup/cgroup-internal.h
+++ b/kernel/cgroup/cgroup-internal.h
@@@ -40,6 -38,28 +40,31 @@@ extern void __init enable_debug_cgroup(
  	} while (0)
  
  /*
++<<<<<<< HEAD
++=======
+  * The cgroup filesystem superblock creation/mount context.
+  */
+ struct cgroup_fs_context {
+ 	struct cgroup_root	*root;
+ 	struct cgroup_namespace	*ns;
+ 	unsigned int	flags;			/* CGRP_ROOT_* flags */
+ 
+ 	/* cgroup1 bits */
+ 	bool		cpuset_clone_children;
+ 	bool		none;			/* User explicitly requested empty subsystem */
+ 	bool		all_ss;			/* Seen 'all' option */
+ 	u16		subsys_mask;		/* Selected subsystems */
+ 	char		*name;			/* Hierarchy name */
+ 	char		*release_agent;		/* Path for release notifications */
+ };
+ 
+ static inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)
+ {
+ 	return fc->fs_private;
+ }
+ 
+ /*
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
   * A cgroup can be associated with multiple css_sets as different tasks may
   * belong to different cgroups on different hierarchies.  In the other
   * direction, a css_set is naturally associated with multiple cgroups.
@@@ -200,12 -210,10 +225,16 @@@ int cgroup_path_ns_locked(struct cgrou
  			  struct cgroup_namespace *ns);
  
  void cgroup_free_root(struct cgroup_root *root);
 -void init_cgroup_root(struct cgroup_fs_context *ctx);
 +void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts);
  int cgroup_setup_root(struct cgroup_root *root, u16 ss_mask);
  int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask);
++<<<<<<< HEAD
 +struct dentry *cgroup_do_mount(struct file_system_type *fs_type, int flags,
 +			       struct cgroup_root *root, unsigned long magic,
 +			       struct cgroup_namespace *ns);
++=======
+ int cgroup_do_get_tree(struct fs_context *fc);
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  
  int cgroup_migrate_vet_dst(struct cgroup *dst_cgrp);
  void cgroup_migrate_finish(struct cgroup_mgctx *mgctx);
diff --cc kernel/cgroup/cgroup-v1.c
index dd94e2a4c22e,571ef3447426..000000000000
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@@ -1079,22 -1135,25 +1079,26 @@@ struct kernfs_syscall_ops cgroup1_kf_sy
  	.show_path		= cgroup_show_path,
  };
  
 -/*
 - * The guts of cgroup1 mount - find or create cgroup_root to use.
 - * Called with cgroup_mutex held; returns 0 on success, -E... on
 - * error and positive - in case when the candidate is busy dying.
 - * On success it stashes a reference to cgroup_root into given
 - * cgroup_fs_context; that reference is *NOT* counting towards the
 - * cgroup_root refcount.
 - */
 -static int cgroup1_root_to_use(struct fs_context *fc)
 +struct dentry *cgroup1_mount(struct file_system_type *fs_type, int flags,
 +			     void *data, unsigned long magic,
 +			     struct cgroup_namespace *ns)
  {
++<<<<<<< HEAD
 +	struct cgroup_sb_opts opts;
++=======
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  	struct cgroup_root *root;
  	struct cgroup_subsys *ss;
 +	struct dentry *dentry;
  	int i, ret;
  
 +	cgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);
 +
  	/* First find the desired set of subsystems */
 -	ret = check_cgroupfs_options(fc);
 +	ret = parse_cgroupfs_options(data, &opts);
  	if (ret)
 -		return ret;
 +		goto out_unlock;
  
  	/*
  	 * Destruction of cgroup root is asynchronous, so subsystems may
@@@ -1158,55 -1212,58 +1162,91 @@@
  	 * specification is allowed for already existing hierarchies but we
  	 * can't create new one without subsys specification.
  	 */
 -	if (!ctx->subsys_mask && !ctx->none)
 -		return cg_invalf(fc, "cgroup1: No subsys list or none specified");
 +	if (!opts.subsys_mask && !opts.none) {
 +		ret = -EINVAL;
 +		goto out_unlock;
 +	}
  
  	/* Hierarchies may only be created in the initial cgroup namespace. */
++<<<<<<< HEAD
 +	if (ns != &init_cgroup_ns) {
 +		ret = -EPERM;
 +		goto out_unlock;
 +	}
++=======
+ 	if (ctx->ns != &init_cgroup_ns)
+ 		return -EPERM;
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  
  	root = kzalloc(sizeof(*root), GFP_KERNEL);
 -	if (!root)
 -		return -ENOMEM;
 +	if (!root) {
 +		ret = -ENOMEM;
 +		goto out_unlock;
 +	}
  
 -	ctx->root = root;
 -	init_cgroup_root(ctx);
 +	init_cgroup_root(root, &opts);
  
 -	ret = cgroup_setup_root(root, ctx->subsys_mask);
 +	ret = cgroup_setup_root(root, opts.subsys_mask);
  	if (ret)
  		cgroup_free_root(root);
 -	return ret;
 -}
  
++<<<<<<< HEAD
 +out_unlock:
 +	if (!ret && !percpu_ref_tryget_live(&root->cgrp.self.refcnt)) {
 +		mutex_unlock(&cgroup_mutex);
++=======
+ int cgroup1_get_tree(struct fs_context *fc)
+ {
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 	int ret;
+ 
+ 	/* Check if the caller has permission to mount. */
+ 	if (!ns_capable(ctx->ns->user_ns, CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	cgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);
+ 
+ 	ret = cgroup1_root_to_use(fc);
+ 	if (!ret && !percpu_ref_tryget_live(&ctx->root->cgrp.self.refcnt))
+ 		ret = 1;	/* restart */
+ 
+ 	mutex_unlock(&cgroup_mutex);
+ 
+ 	if (!ret)
+ 		ret = cgroup_do_get_tree(fc);
+ 
+ 	if (!ret && percpu_ref_is_dying(&ctx->root->cgrp.self.refcnt)) {
+ 		struct super_block *sb = fc->root->d_sb;
+ 		dput(fc->root);
+ 		deactivate_locked_super(sb);
+ 		ret = 1;
+ 	}
+ 
+ 	if (unlikely(ret > 0)) {
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  		msleep(10);
 -		return restart_syscall();
 +		ret = restart_syscall();
 +		goto out_free;
  	}
 -	return ret;
 +	mutex_unlock(&cgroup_mutex);
 +out_free:
 +	kfree(opts.release_agent);
 +	kfree(opts.name);
 +
 +	if (ret)
 +		return ERR_PTR(ret);
 +
 +	dentry = cgroup_do_mount(&cgroup_fs_type, flags, root,
 +				 CGROUP_SUPER_MAGIC, ns);
 +
 +	if (!IS_ERR(dentry) && percpu_ref_is_dying(&root->cgrp.self.refcnt)) {
 +		struct super_block *sb = dentry->d_sb;
 +		dput(dentry);
 +		deactivate_locked_super(sb);
 +		msleep(10);
 +		dentry = ERR_PTR(restart_syscall());
 +	}
 +	return dentry;
  }
  
  static int __init cgroup1_wq_init(void)
diff --cc kernel/cgroup/cgroup.c
index 9e08519ae6db,0c6bef234a7c..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -2011,28 -2036,35 +2011,54 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +struct dentry *cgroup_do_mount(struct file_system_type *fs_type, int flags,
 +			       struct cgroup_root *root, unsigned long magic,
 +			       struct cgroup_namespace *ns)
++=======
+ int cgroup_do_get_tree(struct fs_context *fc)
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  {
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 +	struct dentry *dentry;
  	bool new_sb = false;
++<<<<<<< HEAD
 +
 +	dentry = kernfs_mount(fs_type, flags, root->kf_root, magic, &new_sb);
++=======
+ 	unsigned long magic;
+ 	int ret = 0;
+ 
+ 	if (fc->fs_type == &cgroup2_fs_type)
+ 		magic = CGROUP2_SUPER_MAGIC;
+ 	else
+ 		magic = CGROUP_SUPER_MAGIC;
+ 	fc->root = kernfs_mount(fc->fs_type, fc->sb_flags, ctx->root->kf_root,
+ 				magic, &new_sb);
+ 	if (IS_ERR(fc->root))
+ 		ret = PTR_ERR(fc->root);
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  
  	/*
  	 * In non-init cgroup namespace, instead of root cgroup's dentry,
  	 * we return the dentry corresponding to the cgroupns->root_cgrp.
  	 */
++<<<<<<< HEAD
 +	if (!IS_ERR(dentry) && ns != &init_cgroup_ns) {
++=======
+ 	if (!ret && ctx->ns != &init_cgroup_ns) {
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  		struct dentry *nsdentry;
 -		struct super_block *sb = fc->root->d_sb;
 +		struct super_block *sb = dentry->d_sb;
  		struct cgroup *cgrp;
  
  		mutex_lock(&cgroup_mutex);
  		spin_lock_irq(&css_set_lock);
  
++<<<<<<< HEAD
 +		cgrp = cset_cgroup_from_root(ns->root_cset, root);
++=======
+ 		cgrp = cset_cgroup_from_root(ctx->ns->root_cset, ctx->root);
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  
  		spin_unlock_irq(&css_set_lock);
  		mutex_unlock(&cgroup_mutex);
@@@ -2045,50 -2079,84 +2071,104 @@@
  	}
  
  	if (!new_sb)
 -		cgroup_put(&ctx->root->cgrp);
 +		cgroup_put(&root->cgrp);
  
 -	return ret;
 +	return dentry;
  }
  
++<<<<<<< HEAD
 +static struct dentry *cgroup_mount(struct file_system_type *fs_type,
 +			 int flags, const char *unused_dev_name,
 +			 void *data)
++=======
+ /*
+  * Destroy a cgroup filesystem context.
+  */
+ static void cgroup_fs_context_free(struct fs_context *fc)
+ {
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 
+ 	kfree(ctx->name);
+ 	kfree(ctx->release_agent);
+ 	put_cgroup_ns(ctx->ns);
+ 	kfree(ctx);
+ }
+ 
+ static int cgroup_get_tree(struct fs_context *fc)
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  {
  	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 +	struct dentry *dentry;
  	int ret;
  
 +	get_cgroup_ns(ns);
 +
  	/* Check if the caller has permission to mount. */
 -	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
 -		return -EPERM;
 +	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN)) {
 +		put_cgroup_ns(ns);
 +		return ERR_PTR(-EPERM);
 +	}
  
 -	cgrp_dfl_visible = true;
 -	cgroup_get_live(&cgrp_dfl_root.cgrp);
 -	ctx->root = &cgrp_dfl_root;
 +	if (fs_type == &cgroup2_fs_type) {
 +		unsigned int root_flags;
  
++<<<<<<< HEAD
 +		ret = parse_cgroup_root_flags(data, &root_flags);
 +		if (ret) {
 +			put_cgroup_ns(ns);
 +			return ERR_PTR(ret);
 +		}
++=======
+ 	ret = cgroup_do_get_tree(fc);
+ 	if (!ret)
+ 		apply_cgroup_root_flags(ctx->flags);
+ 	return ret;
+ }
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  
 -static const struct fs_context_operations cgroup_fs_context_ops = {
 -	.free		= cgroup_fs_context_free,
 -	.parse_param	= cgroup2_parse_param,
 -	.get_tree	= cgroup_get_tree,
 -	.reconfigure	= cgroup_reconfigure,
 -};
 +		cgrp_dfl_visible = true;
 +		cgroup_get_live(&cgrp_dfl_root.cgrp);
  
 -static const struct fs_context_operations cgroup1_fs_context_ops = {
 -	.free		= cgroup_fs_context_free,
 -	.parse_param	= cgroup1_parse_param,
 -	.get_tree	= cgroup1_get_tree,
 -	.reconfigure	= cgroup1_reconfigure,
 -};
 +		dentry = cgroup_do_mount(&cgroup2_fs_type, flags, &cgrp_dfl_root,
 +					 CGROUP2_SUPER_MAGIC, ns);
 +		if (!IS_ERR(dentry))
 +			apply_cgroup_root_flags(root_flags);
 +	} else {
 +		dentry = cgroup1_mount(&cgroup_fs_type, flags, data,
 +				       CGROUP_SUPER_MAGIC, ns);
 +	}
  
++<<<<<<< HEAD
 +	put_cgroup_ns(ns);
 +	return dentry;
++=======
+ /*
+  * Initialise the cgroup filesystem creation/reconfiguration context.
+  */
+ static int cgroup_init_fs_context(struct fs_context *fc)
+ {
+ 	struct cgroup_fs_context *ctx;
+ 
+ 	ctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * The first time anyone tries to mount a cgroup, enable the list
+ 	 * linking each css_set to its tasks and fix up all existing tasks.
+ 	 */
+ 	if (!use_task_css_set_links)
+ 		cgroup_enable_task_cg_lists();
+ 
+ 	ctx->ns = current->nsproxy->cgroup_ns;
+ 	get_cgroup_ns(ctx->ns);
+ 	fc->fs_private = ctx;
+ 	if (fc->fs_type == &cgroup2_fs_type)
+ 		fc->ops = &cgroup_fs_context_ops;
+ 	else
+ 		fc->ops = &cgroup1_fs_context_ops;
+ 	return 0;
++>>>>>>> cca8f32714d3 (cgroup: store a reference to cgroup_ns into cgroup_fs_context)
  }
  
  static void cgroup_kill_sb(struct super_block *sb)
* Unmerged path kernel/cgroup/cgroup-internal.h
* Unmerged path kernel/cgroup/cgroup-v1.c
* Unmerged path kernel/cgroup/cgroup.c
