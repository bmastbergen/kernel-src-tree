x86/ptrace: Prevent ptrace from clearing the FS/GS selector

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chang S. Bae <chang.seok.bae@intel.com>
commit 48f5e52e916b55fb73754833efbacc7f8081a159
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/48f5e52e.failed

When a ptracer writes a ptracee's FS/GSBASE with a different value, the
selector is also cleared. This behavior is not correct as the selector
should be preserved.

Update only the base value and leave the selector intact. To simplify the
code further remove the conditional checking for the same value as this
code is not performance critical.

The only recognizable downside of this change is when the selector is
already nonzero on write. The base will be reloaded according to the
selector. But the case is highly unexpected in real usages.

[ tglx: Massage changelog ]

	Suggested-by: Andy Lutomirski <luto@kernel.org>
	Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: "H . Peter Anvin" <hpa@zytor.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
Link: https://lkml.kernel.org/r/9040CFCD-74BD-4C17-9A01-B9B713CF6B10@intel.com

(cherry picked from commit 48f5e52e916b55fb73754833efbacc7f8081a159)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/ptrace.c
diff --cc arch/x86/kernel/ptrace.c
index d2dd84a32cde,3108cdc00b29..000000000000
--- a/arch/x86/kernel/ptrace.c
+++ b/arch/x86/kernel/ptrace.c
@@@ -382,25 -397,12 +382,25 @@@ static int putreg(struct task_struct *c
  	case offsetof(struct user_regs_struct,fs_base):
  		if (value >= TASK_SIZE_MAX)
  			return -EIO;
++<<<<<<< HEAD
 +		/*
 +		 * When changing the FS base, use do_arch_prctl_64()
 +		 * to set the index to zero and to set the base
 +		 * as requested.
 +		 *
 +		 * NB: This behavior is nonsensical and likely needs to
 +		 * change when FSGSBASE support is added.
 +		 */
 +		if (child->thread.fsbase != value)
 +			return do_arch_prctl_64(child, ARCH_SET_FS, value);
++=======
+ 		x86_fsbase_write_task(child, value);
++>>>>>>> 48f5e52e916b (x86/ptrace: Prevent ptrace from clearing the FS/GS selector)
  		return 0;
  	case offsetof(struct user_regs_struct,gs_base):
- 		/*
- 		 * Exactly the same here as the %fs handling above.
- 		 */
  		if (value >= TASK_SIZE_MAX)
  			return -EIO;
- 		if (child->thread.gsbase != value)
- 			return do_arch_prctl_64(child, ARCH_SET_GS, value);
+ 		x86_gsbase_write_task(child, value);
  		return 0;
  #endif
  	}
* Unmerged path arch/x86/kernel/ptrace.c
