mm: workingset: add vmstat counter for shadow nodes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 68d48e6a2df575b935edd420396c3cb8b6aa6ad3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/68d48e6a.failed

Make it easier to catch bugs in the shadow node shrinker by adding a
counter for the shadow nodes in circulation.

[akpm@linux-foundation.org: assert that irqs are disabled, for __inc_lruvec_page_state()]
[akpm@linux-foundation.org: s/WARN_ON_ONCE/VM_WARN_ON_ONCE/, per Johannes]
Link: http://lkml.kernel.org/r/20181009184732.762-4-hannes@cmpxchg.org
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 68d48e6a2df575b935edd420396c3cb8b6aa6ad3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/workingset.c
diff --cc mm/workingset.c
index c53506c3624d,7e6ef312cea5..000000000000
--- a/mm/workingset.c
+++ b/mm/workingset.c
@@@ -412,12 -377,20 +412,25 @@@ void workingset_update_node(struct xa_n
  	 * already where they should be. The list_empty() test is safe
  	 * as node->private_list is protected by the i_pages lock.
  	 */
++<<<<<<< HEAD
 +	if (node->count && node->count == node->nr_values) {
 +		if (list_empty(&node->private_list))
++=======
+ 	VM_WARN_ON_ONCE(!irqs_disabled());  /* For __inc_lruvec_page_state */
+ 
+ 	if (node->count && node->count == node->exceptional) {
+ 		if (list_empty(&node->private_list)) {
++>>>>>>> 68d48e6a2df5 (mm: workingset: add vmstat counter for shadow nodes)
  			list_lru_add(&shadow_nodes, &node->private_list);
+ 			__inc_lruvec_page_state(virt_to_page(node),
+ 						WORKINGSET_NODES);
+ 		}
  	} else {
- 		if (!list_empty(&node->private_list))
+ 		if (!list_empty(&node->private_list)) {
  			list_lru_del(&shadow_nodes, &node->private_list);
+ 			__dec_lruvec_page_state(virt_to_page(node),
+ 						WORKINGSET_NODES);
+ 		}
  	}
  }
  
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index ce2990f782e1..5bda1f3e6a57 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -221,6 +221,7 @@ enum node_stat_item {
 	NR_SLAB_UNRECLAIMABLE,
 	NR_ISOLATED_ANON,	/* Temporary isolated pages from anon lru */
 	NR_ISOLATED_FILE,	/* Temporary isolated pages from file lru */
+	WORKINGSET_NODES,
 	WORKINGSET_REFAULT,
 	WORKINGSET_ACTIVATE,
 	WORKINGSET_NODERECLAIM,
diff --git a/mm/vmstat.c b/mm/vmstat.c
index 8285022e8e12..3b02ec35e35c 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -1144,6 +1144,7 @@ const char * const vmstat_text[] = {
 	"nr_slab_unreclaimable",
 	"nr_isolated_anon",
 	"nr_isolated_file",
+	"workingset_nodes",
 	"workingset_refault",
 	"workingset_activate",
 	"workingset_restore",
* Unmerged path mm/workingset.c
