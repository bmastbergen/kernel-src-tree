mm, compaction: fix wrong pfn handling in __reset_isolation_pfn()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vlastimil Babka <vbabka@suse.cz>
commit a2e9a5afce080226edbf1882d63d99bf32070e9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a2e9a5af.failed

Florian and Dave reported [1] a NULL pointer dereference in
__reset_isolation_pfn().  While the exact cause is unclear, staring at
the code revealed two bugs, which might be related.

One bug is that if zone starts in the middle of pageblock, block_page
might correspond to different pfn than block_pfn, and then the
pfn_valid_within() checks will check different pfn's than those accessed
via struct page.  This might result in acessing an unitialized page in
CONFIG_HOLES_IN_ZONE configs.

The other bug is that end_page refers to the first page of next
pageblock and not last page of current pageblock.  The online and valid
check is then wrong and with sections, the while (page < end_page) loop
might wander off actual struct page arrays.

[1] https://lore.kernel.org/linux-xfs/87o8z1fvqu.fsf@mid.deneb.enyo.de/

Link: http://lkml.kernel.org/r/20191008152915.24704-1-vbabka@suse.cz
Fixes: 6b0868c820ff ("mm/compaction.c: correct zone boundary handling when resetting pageblock skip hints")
	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
	Reported-by: Florian Weimer <fw@deneb.enyo.de>
	Reported-by: Dave Chinner <david@fromorbit.com>
	Acked-by: Mel Gorman <mgorman@techsingularity.net>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a2e9a5afce080226edbf1882d63d99bf32070e9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/compaction.c
diff --cc mm/compaction.c
index 79db11f23bf2,672d3c78c6ab..000000000000
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@@ -237,6 -237,78 +237,81 @@@ static bool pageblock_skip_persistent(s
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ __reset_isolation_pfn(struct zone *zone, unsigned long pfn, bool check_source,
+ 							bool check_target)
+ {
+ 	struct page *page = pfn_to_online_page(pfn);
+ 	struct page *block_page;
+ 	struct page *end_page;
+ 	unsigned long block_pfn;
+ 
+ 	if (!page)
+ 		return false;
+ 	if (zone != page_zone(page))
+ 		return false;
+ 	if (pageblock_skip_persistent(page))
+ 		return false;
+ 
+ 	/*
+ 	 * If skip is already cleared do no further checking once the
+ 	 * restart points have been set.
+ 	 */
+ 	if (check_source && check_target && !get_pageblock_skip(page))
+ 		return true;
+ 
+ 	/*
+ 	 * If clearing skip for the target scanner, do not select a
+ 	 * non-movable pageblock as the starting point.
+ 	 */
+ 	if (!check_source && check_target &&
+ 	    get_pageblock_migratetype(page) != MIGRATE_MOVABLE)
+ 		return false;
+ 
+ 	/* Ensure the start of the pageblock or zone is online and valid */
+ 	block_pfn = pageblock_start_pfn(pfn);
+ 	block_pfn = max(block_pfn, zone->zone_start_pfn);
+ 	block_page = pfn_to_online_page(block_pfn);
+ 	if (block_page) {
+ 		page = block_page;
+ 		pfn = block_pfn;
+ 	}
+ 
+ 	/* Ensure the end of the pageblock or zone is online and valid */
+ 	block_pfn = pageblock_end_pfn(pfn) - 1;
+ 	block_pfn = min(block_pfn, zone_end_pfn(zone) - 1);
+ 	end_page = pfn_to_online_page(block_pfn);
+ 	if (!end_page)
+ 		return false;
+ 
+ 	/*
+ 	 * Only clear the hint if a sample indicates there is either a
+ 	 * free page or an LRU page in the block. One or other condition
+ 	 * is necessary for the block to be a migration source/target.
+ 	 */
+ 	do {
+ 		if (pfn_valid_within(pfn)) {
+ 			if (check_source && PageLRU(page)) {
+ 				clear_pageblock_skip(page);
+ 				return true;
+ 			}
+ 
+ 			if (check_target && PageBuddy(page)) {
+ 				clear_pageblock_skip(page);
+ 				return true;
+ 			}
+ 		}
+ 
+ 		page += (1 << PAGE_ALLOC_COSTLY_ORDER);
+ 		pfn += (1 << PAGE_ALLOC_COSTLY_ORDER);
+ 	} while (page <= end_page);
+ 
+ 	return false;
+ }
+ 
++>>>>>>> a2e9a5afce08 (mm, compaction: fix wrong pfn handling in __reset_isolation_pfn())
  /*
   * This function is called to clear all cached information on pageblocks that
   * should be skipped for page isolation when the migrate and free page scanner
* Unmerged path mm/compaction.c
