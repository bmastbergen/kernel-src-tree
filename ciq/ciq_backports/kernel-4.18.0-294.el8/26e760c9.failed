rcu: kasan: record and print call_rcu() call stack

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Walter Wu <walter-zh.wu@mediatek.com>
commit 26e760c9a7c8ec31fa1a6bfbbce3f63f189ccef0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/26e760c9.failed

Patch series "kasan: memorize and print call_rcu stack", v8.

This patchset improves KASAN reports by making them to have call_rcu()
call stack information.  It is useful for programmers to solve
use-after-free or double-free memory issue.

The KASAN report was as follows(cleaned up slightly):

BUG: KASAN: use-after-free in kasan_rcu_reclaim+0x58/0x60

Freed by task 0:
 kasan_save_stack+0x24/0x50
 kasan_set_track+0x24/0x38
 kasan_set_free_info+0x18/0x20
 __kasan_slab_free+0x10c/0x170
 kasan_slab_free+0x10/0x18
 kfree+0x98/0x270
 kasan_rcu_reclaim+0x1c/0x60

Last call_rcu():
 kasan_save_stack+0x24/0x50
 kasan_record_aux_stack+0xbc/0xd0
 call_rcu+0x8c/0x580
 kasan_rcu_uaf+0xf4/0xf8

Generic KASAN will record the last two call_rcu() call stacks and print up
to 2 call_rcu() call stacks in KASAN report.  it is only suitable for
generic KASAN.

This feature considers the size of struct kasan_alloc_meta and
kasan_free_meta, we try to optimize the structure layout and size, lets it
get better memory consumption.

[1]https://bugzilla.kernel.org/show_bug.cgi?id=198437
[2]https://groups.google.com/forum/#!searchin/kasan-dev/better$20stack$20traces$20for$20rcu%7Csort:date/kasan-dev/KQsjT_88hDE/7rNUZprRBgAJ

This patch (of 4):

This feature will record the last two call_rcu() call stacks and prints up
to 2 call_rcu() call stacks in KASAN report.

When call_rcu() is called, we store the call_rcu() call stack into slub
alloc meta-data, so that the KASAN report can print rcu stack.

[1]https://bugzilla.kernel.org/show_bug.cgi?id=198437
[2]https://groups.google.com/forum/#!searchin/kasan-dev/better$20stack$20traces$20for$20rcu%7Csort:date/kasan-dev/KQsjT_88hDE/7rNUZprRBgAJ

[walter-zh.wu@mediatek.com: build fix]
  Link: http://lkml.kernel.org/r/20200710162401.23816-1-walter-zh.wu@mediatek.com

	Suggested-by: Dmitry Vyukov <dvyukov@google.com>
	Signed-off-by: Walter Wu <walter-zh.wu@mediatek.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Dmitry Vyukov <dvyukov@google.com>
	Reviewed-by: Dmitry Vyukov <dvyukov@google.com>
	Reviewed-by: Andrey Konovalov <andreyknvl@google.com>
	Acked-by: Paul E. McKenney <paulmck@kernel.org>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Josh Triplett <josh@joshtriplett.org>
	Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: Lai Jiangshan <jiangshanlai@gmail.com>
	Cc: Joel Fernandes <joel@joelfernandes.org>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Matthias Brugger <matthias.bgg@gmail.com>
Link: http://lkml.kernel.org/r/20200710162123.23713-1-walter-zh.wu@mediatek.com
Link: http://lkml.kernel.org/r/20200601050847.1096-1-walter-zh.wu@mediatek.com
Link: http://lkml.kernel.org/r/20200601050927.1153-1-walter-zh.wu@mediatek.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 26e760c9a7c8ec31fa1a6bfbbce3f63f189ccef0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kasan.h
#	kernel/rcu/tree.c
#	mm/kasan/common.c
#	mm/kasan/generic.c
#	mm/kasan/kasan.h
#	mm/kasan/report.c
diff --cc include/linux/kasan.h
index 1e5ac58e377c,18452e35e7b2..000000000000
--- a/include/linux/kasan.h
+++ b/include/linux/kasan.h
@@@ -159,4 -168,72 +159,75 @@@ static inline size_t kasan_metadata_siz
  
  #endif /* CONFIG_KASAN */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KASAN_GENERIC
+ 
+ #define KASAN_SHADOW_INIT 0
+ 
+ void kasan_cache_shrink(struct kmem_cache *cache);
+ void kasan_cache_shutdown(struct kmem_cache *cache);
+ void kasan_record_aux_stack(void *ptr);
+ 
+ #else /* CONFIG_KASAN_GENERIC */
+ 
+ static inline void kasan_cache_shrink(struct kmem_cache *cache) {}
+ static inline void kasan_cache_shutdown(struct kmem_cache *cache) {}
+ static inline void kasan_record_aux_stack(void *ptr) {}
+ 
+ #endif /* CONFIG_KASAN_GENERIC */
+ 
+ #ifdef CONFIG_KASAN_SW_TAGS
+ 
+ #define KASAN_SHADOW_INIT 0xFF
+ 
+ void kasan_init_tags(void);
+ 
+ void *kasan_reset_tag(const void *addr);
+ 
+ bool kasan_report(unsigned long addr, size_t size,
+ 		bool is_write, unsigned long ip);
+ 
+ #else /* CONFIG_KASAN_SW_TAGS */
+ 
+ static inline void kasan_init_tags(void) { }
+ 
+ static inline void *kasan_reset_tag(const void *addr)
+ {
+ 	return (void *)addr;
+ }
+ 
+ #endif /* CONFIG_KASAN_SW_TAGS */
+ 
+ #ifdef CONFIG_KASAN_VMALLOC
+ int kasan_populate_vmalloc(unsigned long addr, unsigned long size);
+ void kasan_poison_vmalloc(const void *start, unsigned long size);
+ void kasan_unpoison_vmalloc(const void *start, unsigned long size);
+ void kasan_release_vmalloc(unsigned long start, unsigned long end,
+ 			   unsigned long free_region_start,
+ 			   unsigned long free_region_end);
+ #else
+ static inline int kasan_populate_vmalloc(unsigned long start,
+ 					unsigned long size)
+ {
+ 	return 0;
+ }
+ 
+ static inline void kasan_poison_vmalloc(const void *start, unsigned long size)
+ { }
+ static inline void kasan_unpoison_vmalloc(const void *start, unsigned long size)
+ { }
+ static inline void kasan_release_vmalloc(unsigned long start,
+ 					 unsigned long end,
+ 					 unsigned long free_region_start,
+ 					 unsigned long free_region_end) {}
+ #endif
+ 
+ #ifdef CONFIG_KASAN_INLINE
+ void kasan_non_canonical_hook(unsigned long addr);
+ #else /* CONFIG_KASAN_INLINE */
+ static inline void kasan_non_canonical_hook(unsigned long addr) { }
+ #endif /* CONFIG_KASAN_INLINE */
+ 
++>>>>>>> 26e760c9a7c8 (rcu: kasan: record and print call_rcu() call stack)
  #endif /* LINUX_KASAN_H */
diff --cc kernel/rcu/tree.c
index 4aa7b6bbcde6,8ce77d9ac716..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -54,8 -54,12 +54,14 @@@
  #include <linux/oom.h>
  #include <linux/smpboot.h>
  #include <linux/jiffies.h>
 -#include <linux/slab.h>
  #include <linux/sched/isolation.h>
  #include <linux/sched/clock.h>
++<<<<<<< HEAD
++=======
+ #include <linux/vmalloc.h>
+ #include <linux/mm.h>
+ #include <linux/kasan.h>
++>>>>>>> 26e760c9a7c8 (rcu: kasan: record and print call_rcu() call stack)
  #include "../time/tick-internal.h"
  
  #include "tree.h"
diff --cc mm/kasan/kasan.h
index d4667fb5a8f3,f89a195e336a..000000000000
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@@ -79,9 -96,26 +79,24 @@@ struct kasan_track 
  	depot_stack_handle_t stack;
  };
  
 -#ifdef CONFIG_KASAN_SW_TAGS_IDENTIFY
 -#define KASAN_NR_FREE_STACKS 5
 -#else
 -#define KASAN_NR_FREE_STACKS 1
 -#endif
 -
  struct kasan_alloc_meta {
  	struct kasan_track alloc_track;
++<<<<<<< HEAD
 +	struct kasan_track free_track;
++=======
+ #ifdef CONFIG_KASAN_GENERIC
+ 	/*
+ 	 * call_rcu() call stack is stored into struct kasan_alloc_meta.
+ 	 * The free stack is stored into struct kasan_free_meta.
+ 	 */
+ 	depot_stack_handle_t aux_stack[2];
+ #endif
+ 	struct kasan_track free_track[KASAN_NR_FREE_STACKS];
+ #ifdef CONFIG_KASAN_SW_TAGS_IDENTIFY
+ 	u8 free_pointer_tag[KASAN_NR_FREE_STACKS];
+ 	u8 free_track_idx;
+ #endif
++>>>>>>> 26e760c9a7c8 (rcu: kasan: record and print call_rcu() call stack)
  };
  
  struct qlist_node {
@@@ -109,7 -164,12 +124,16 @@@ void kasan_report(unsigned long addr, s
  		bool is_write, unsigned long ip);
  void kasan_report_invalid_free(void *object, unsigned long ip);
  
++<<<<<<< HEAD
 +#if defined(CONFIG_SLAB) || defined(CONFIG_SLUB)
++=======
+ struct page *kasan_addr_to_page(const void *addr);
+ 
+ depot_stack_handle_t kasan_save_stack(gfp_t flags);
+ 
+ #if defined(CONFIG_KASAN_GENERIC) && \
+ 	(defined(CONFIG_SLAB) || defined(CONFIG_SLUB))
++>>>>>>> 26e760c9a7c8 (rcu: kasan: record and print call_rcu() call stack)
  void quarantine_put(struct kasan_free_meta *info, struct kmem_cache *cache);
  void quarantine_reduce(void);
  void quarantine_remove_cache(struct kmem_cache *cache);
diff --cc mm/kasan/report.c
index 4694bf3eb077,445a9d56eb13..000000000000
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@@ -193,10 -119,7 +202,14 @@@ static void print_track(struct kasan_tr
  {
  	pr_err("%s by task %u:\n", prefix, track->pid);
  	if (track->stack) {
++<<<<<<< HEAD
 +		struct stack_trace trace;
 +
 +		depot_fetch_stack(track->stack, &trace);
 +		print_stack_trace(&trace, 0);
++=======
+ 		print_stack(track->stack);
++>>>>>>> 26e760c9a7c8 (rcu: kasan: record and print call_rcu() call stack)
  	} else {
  		pr_err("(stack is not available)\n");
  	}
@@@ -248,10 -191,26 +261,23 @@@ static void describe_object(struct kmem
  	struct kasan_alloc_meta *alloc_info = get_alloc_info(cache, object);
  
  	if (cache->flags & SLAB_KASAN) {
 -		struct kasan_track *free_track;
 -
  		print_track(&alloc_info->alloc_track, "Allocated");
  		pr_err("\n");
 -		free_track = kasan_get_free_track(cache, object, tag);
 -		print_track(free_track, "Freed");
 +		print_track(&alloc_info->free_track, "Freed");
  		pr_err("\n");
+ 
+ #ifdef CONFIG_KASAN_GENERIC
+ 		if (alloc_info->aux_stack[0]) {
+ 			pr_err("Last call_rcu():\n");
+ 			print_stack(alloc_info->aux_stack[0]);
+ 			pr_err("\n");
+ 		}
+ 		if (alloc_info->aux_stack[1]) {
+ 			pr_err("Second to last call_rcu():\n");
+ 			print_stack(alloc_info->aux_stack[1]);
+ 			pr_err("\n");
+ 		}
+ #endif
  	}
  
  	describe_object_addr(cache, object, addr);
* Unmerged path mm/kasan/common.c
* Unmerged path mm/kasan/generic.c
* Unmerged path include/linux/kasan.h
* Unmerged path kernel/rcu/tree.c
* Unmerged path mm/kasan/common.c
* Unmerged path mm/kasan/generic.c
* Unmerged path mm/kasan/kasan.h
* Unmerged path mm/kasan/report.c
