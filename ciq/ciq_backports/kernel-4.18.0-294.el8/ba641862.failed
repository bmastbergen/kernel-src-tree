selinux: new helper - selinux_add_opt()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit ba6418623385abf19a6c15cf0b1cfaacfdf9afc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ba641862.failed

the guts of the loop in selinux_parse_opts_str() - takes one
(already recognized) option and adds it to growing selinux_mnt_opts.

	Reviewed-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit ba6418623385abf19a6c15cf0b1cfaacfdf9afc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 42145010da10,26ec7d67e15d..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -1013,15 -984,51 +1013,59 @@@ out
  	return rc;
  }
  
+ static int selinux_add_opt(int token, const char *s, void **mnt_opts)
+ {
+ 	struct selinux_mnt_opts *opts = *mnt_opts;
+ 
+ 	if (!opts) {
+ 		opts = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);
+ 		if (!opts)
+ 			return -ENOMEM;
+ 		*mnt_opts = opts;
+ 	}
+ 	if (!s)
+ 		return -ENOMEM;
+ 	switch (token) {
+ 	case Opt_context:
+ 		if (opts->context || opts->defcontext)
+ 			goto Einval;
+ 		opts->context = s;
+ 		break;
+ 	case Opt_fscontext:
+ 		if (opts->fscontext)
+ 			goto Einval;
+ 		opts->fscontext = s;
+ 		break;
+ 	case Opt_rootcontext:
+ 		if (opts->rootcontext)
+ 			goto Einval;
+ 		opts->rootcontext = s;
+ 		break;
+ 	case Opt_defcontext:
+ 		if (opts->context || opts->defcontext)
+ 			goto Einval;
+ 		opts->defcontext = s;
+ 		break;
+ 	}
+ 	return 0;
+ Einval:
+ 	pr_warn(SEL_MOUNT_FAIL_MSG);
+ 	kfree(s);
+ 	return -EINVAL;
+ }
+ 
  static int selinux_parse_opts_str(char *options,
 -				  void **mnt_opts)
 +				  struct security_mnt_opts *opts)
  {
  	char *p;
++<<<<<<< HEAD
 +	char *context = NULL, *defcontext = NULL;
 +	char *fscontext = NULL, *rootcontext = NULL;
 +	int rc, num_mnt_opts = 0;
 +
 +	opts->num_mnt_opts = 0;
++=======
++>>>>>>> ba6418623385 (selinux: new helper - selinux_add_opt())
  
  	/* Standard string-based options. */
  	while ((p = strsep(&options, "|")) != NULL) {
@@@ -1033,105 -1041,20 +1078,122 @@@
  
  		token = match_token(p, tokens, args);
  
++<<<<<<< HEAD
 +		switch (token) {
 +		case Opt_context:
 +			if (context || defcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			context = match_strdup(&args[0]);
 +			if (!context) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_fscontext:
 +			if (fscontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			fscontext = match_strdup(&args[0]);
 +			if (!fscontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_rootcontext:
 +			if (rootcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			rootcontext = match_strdup(&args[0]);
 +			if (!rootcontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_defcontext:
 +			if (context || defcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			defcontext = match_strdup(&args[0]);
 +			if (!defcontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +		case Opt_labelsupport:
 +			break;
 +		default:
 +			rc = -EINVAL;
 +			pr_warn("SELinux:  unknown mount option\n");
 +			goto out_err;
 +
 +		}
 +	}
 +
 +	rc = -ENOMEM;
 +	opts->mnt_opts = kcalloc(NUM_SEL_MNT_OPTS, sizeof(char *), GFP_KERNEL);
 +	if (!opts->mnt_opts)
 +		goto out_err;
 +
 +	opts->mnt_opts_flags = kcalloc(NUM_SEL_MNT_OPTS, sizeof(int),
 +				       GFP_KERNEL);
 +	if (!opts->mnt_opts_flags)
 +		goto out_err;
 +
 +	if (fscontext) {
 +		opts->mnt_opts[num_mnt_opts] = fscontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = FSCONTEXT_MNT;
 +	}
 +	if (context) {
 +		opts->mnt_opts[num_mnt_opts] = context;
 +		opts->mnt_opts_flags[num_mnt_opts++] = CONTEXT_MNT;
 +	}
 +	if (rootcontext) {
 +		opts->mnt_opts[num_mnt_opts] = rootcontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = ROOTCONTEXT_MNT;
 +	}
 +	if (defcontext) {
 +		opts->mnt_opts[num_mnt_opts] = defcontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = DEFCONTEXT_MNT;
 +	}
 +
 +	opts->num_mnt_opts = num_mnt_opts;
 +	return 0;
 +
 +out_err:
 +	security_free_mnt_opts(opts);
 +	kfree(context);
 +	kfree(defcontext);
 +	kfree(fscontext);
 +	kfree(rootcontext);
 +	return rc;
++=======
+ 		if (token == Opt_labelsupport)	/* eaten and completely ignored */
+ 			continue;
+ 		arg = match_strdup(&args[0]);
+ 		rc = selinux_add_opt(token, arg, mnt_opts);
+ 		if (unlikely(rc)) {
+ 			kfree(arg);
+ 			if (*mnt_opts) {
+ 				selinux_free_mnt_opts(*mnt_opts);
+ 				*mnt_opts = NULL;
+ 			}
+ 			return rc;
+ 		}
+ 	}
+ 	return 0;
++>>>>>>> ba6418623385 (selinux: new helper - selinux_add_opt())
  }
  
  static int show_sid(struct seq_file *m, u32 sid)
* Unmerged path security/selinux/hooks.c
