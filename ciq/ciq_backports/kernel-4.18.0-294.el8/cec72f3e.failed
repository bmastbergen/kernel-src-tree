driver core: Don't do deferred probe in parallel with kernel_init thread

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit cec72f3efc6272420c2c2c699607f03d09b93e41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cec72f3e.failed

The current deferred probe implementation can mess up suspend/resume
ordering if deferred probe thread is kicked off in parallel with the
main initcall thread (kernel_init thread) [1].

For example:

Say device-B is a consumer of device-A.

Initcall thread					Deferred probe thread
===============					=====================
1. device-A is added.
2. device-B is added.
3. dpm_list is now [device-A, device-B].
4. driver-A defers probe of device-A.
						5. device-A is moved to
						   end of dpm_list
						6. dpm_list is now
						   [device-B, device-A]
7. driver-B is registereed and probes device-B.
8. dpm_list stays as [device-B, device-A].

The reverse order of dpm_list is used for suspend. So in this case
device-A would incorrectly get suspended before device-B.

Commit 716a7a259690 ("driver core: fw_devlink: Add support for batching
fwnode parsing") kicked off the deferred probe thread early during boot
to run in parallel with the initcall thread and caused suspend/resume
regressions.  This patch removes the parallel run of the deferred probe
thread to avoid the suspend/resume regressions.

[1] - https://lore.kernel.org/lkml/CAGETcx8W96KAw-d_siTX4qHB_-7ddk0miYRDQeHE6E0_8qx-6Q@mail.gmail.com/

Fixes: 716a7a259690 ("driver core: fw_devlink: Add support for batching fwnode parsing")
	Signed-off-by: Saravana Kannan <saravanak@google.com>
	Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
Link: https://lore.kernel.org/r/20200701194259.3337652-2-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit cec72f3efc6272420c2c2c699607f03d09b93e41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
diff --cc drivers/base/core.c
index 7ffd5023ca95,35cc9896eb9e..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -936,6 -1213,119 +936,122 @@@ static bool fw_devlink_is_permissive(vo
  	return fw_devlink_flags == DL_FLAG_SYNC_STATE_ONLY;
  }
  
++<<<<<<< HEAD
++=======
+ static void fw_devlink_link_device(struct device *dev)
+ {
+ 	int fw_ret;
+ 
+ 	if (!fw_devlink_flags)
+ 		return;
+ 
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	if (!defer_fw_devlink_count)
+ 		device_link_add_missing_supplier_links();
+ 
+ 	/*
+ 	 * The device's fwnode not having add_links() doesn't affect if other
+ 	 * consumers can find this device as a supplier.  So, this check is
+ 	 * intentionally placed after device_link_add_missing_supplier_links().
+ 	 */
+ 	if (!fwnode_has_op(dev->fwnode, add_links))
+ 		goto out;
+ 
+ 	/*
+ 	 * If fw_devlink is being deferred, assume all devices have mandatory
+ 	 * suppliers they need to link to later. Then, when the fw_devlink is
+ 	 * resumed, all these devices will get a chance to try and link to any
+ 	 * suppliers they have.
+ 	 */
+ 	if (!defer_fw_devlink_count) {
+ 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+ 		if (fw_ret == -ENODEV && fw_devlink_is_permissive())
+ 			fw_ret = -EAGAIN;
+ 	} else {
+ 		fw_ret = -ENODEV;
+ 	}
+ 
+ 	if (fw_ret == -ENODEV)
+ 		device_link_wait_for_mandatory_supplier(dev);
+ 	else if (fw_ret)
+ 		device_link_wait_for_optional_supplier(dev);
+ 
+ out:
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ }
+ 
+ /**
+  * fw_devlink_pause - Pause parsing of fwnode to create device links
+  *
+  * Calling this function defers any fwnode parsing to create device links until
+  * fw_devlink_resume() is called. Both these functions are ref counted and the
+  * caller needs to match the calls.
+  *
+  * While fw_devlink is paused:
+  * - Any device that is added won't have its fwnode parsed to create device
+  *   links.
+  * - The probe of the device will also be deferred during this period.
+  * - Any devices that were already added, but waiting for suppliers won't be
+  *   able to link to newly added devices.
+  *
+  * Once fw_devlink_resume():
+  * - All the fwnodes that was not parsed will be parsed.
+  * - All the devices that were deferred probing will be reattempted if they
+  *   aren't waiting for any more suppliers.
+  *
+  * This pair of functions, is mainly meant to optimize the parsing of fwnodes
+  * when a lot of devices that need to link to each other are added in a short
+  * interval of time. For example, adding all the top level devices in a system.
+  *
+  * For example, if N devices are added and:
+  * - All the consumers are added before their suppliers
+  * - All the suppliers of the N devices are part of the N devices
+  *
+  * Then:
+  *
+  * - With the use of fw_devlink_pause() and fw_devlink_resume(), each device
+  *   will only need one parsing of its fwnode because it is guaranteed to find
+  *   all the supplier devices already registered and ready to link to. It won't
+  *   have to do another pass later to find one or more suppliers it couldn't
+  *   find in the first parse of the fwnode. So, we'll only need O(N) fwnode
+  *   parses.
+  *
+  * - Without the use of fw_devlink_pause() and fw_devlink_resume(), we would
+  *   end up doing O(N^2) parses of fwnodes because every device that's added is
+  *   guaranteed to trigger a parse of the fwnode of every device added before
+  *   it. This O(N^2) parse is made worse by the fact that when a fwnode of a
+  *   device is parsed, all it descendant devices might need to have their
+  *   fwnodes parsed too (even if the devices themselves aren't added).
+  */
+ void fw_devlink_pause(void)
+ {
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	defer_fw_devlink_count++;
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ }
+ 
+ /** fw_devlink_resume - Resume parsing of fwnode to create device links
+  *
+  * This function is used in conjunction with fw_devlink_pause() and is ref
+  * counted. See documentation for fw_devlink_pause() for more details.
+  */
+ void fw_devlink_resume(void)
+ {
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	if (!defer_fw_devlink_count) {
+ 		WARN(true, "Unmatched fw_devlink pause/resume!");
+ 		goto out;
+ 	}
+ 
+ 	defer_fw_devlink_count--;
+ 	if (defer_fw_devlink_count)
+ 		goto out;
+ 
+ 	device_link_add_missing_supplier_links();
+ out:
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ }
++>>>>>>> cec72f3efc62 (driver core: Don't do deferred probe in parallel with kernel_init thread)
  /* Device links support end. */
  
  int (*platform_notify)(struct device *dev) = NULL;
* Unmerged path drivers/base/core.c
