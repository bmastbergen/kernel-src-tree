netfilter: nft_meta: use socket user_ns to retrieve skuid and skgid

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 0c92411bb81de9bc516d6924f50289d8d5f880e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0c92411b.failed

... instead of using init_user_ns.

Fixes: 96518518cc41 ("netfilter: add nftables")
	Tested-by: Phil Sutter <phil@nwl.cc>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 0c92411bb81de9bc516d6924f50289d8d5f880e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_meta.c
diff --cc net/netfilter/nft_meta.c
index c22e0a3c6e99,b37bd02448d8..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -38,13 -34,285 +38,156 @@@ struct nft_meta 
  
  static DEFINE_PER_CPU(struct rnd_state, nft_prandom_state);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_NF_TABLES_BRIDGE
 +#include "../bridge/br_private.h"
++=======
+ static u8 nft_meta_weekday(void)
+ {
+ 	time64_t secs = ktime_get_real_seconds();
+ 	unsigned int dse;
+ 	u8 wday;
+ 
+ 	secs -= NFT_META_SECS_PER_MINUTE * sys_tz.tz_minuteswest;
+ 	dse = div_u64(secs, NFT_META_SECS_PER_DAY);
+ 	wday = (4 + dse) % NFT_META_DAYS_PER_WEEK;
+ 
+ 	return wday;
+ }
+ 
+ static u32 nft_meta_hour(time64_t secs)
+ {
+ 	struct tm tm;
+ 
+ 	time64_to_tm(secs, 0, &tm);
+ 
+ 	return tm.tm_hour * NFT_META_SECS_PER_HOUR
+ 		+ tm.tm_min * NFT_META_SECS_PER_MINUTE
+ 		+ tm.tm_sec;
+ }
+ 
+ static noinline_for_stack void
+ nft_meta_get_eval_time(enum nft_meta_keys key,
+ 		       u32 *dest)
+ {
+ 	switch (key) {
+ 	case NFT_META_TIME_NS:
+ 		nft_reg_store64(dest, ktime_get_real_ns());
+ 		break;
+ 	case NFT_META_TIME_DAY:
+ 		nft_reg_store8(dest, nft_meta_weekday());
+ 		break;
+ 	case NFT_META_TIME_HOUR:
+ 		*dest = nft_meta_hour(ktime_get_real_seconds());
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static noinline bool
+ nft_meta_get_eval_pkttype_lo(const struct nft_pktinfo *pkt,
+ 			     u32 *dest)
+ {
+ 	const struct sk_buff *skb = pkt->skb;
+ 
+ 	switch (nft_pf(pkt)) {
+ 	case NFPROTO_IPV4:
+ 		if (ipv4_is_multicast(ip_hdr(skb)->daddr))
+ 			nft_reg_store8(dest, PACKET_MULTICAST);
+ 		else
+ 			nft_reg_store8(dest, PACKET_BROADCAST);
+ 		break;
+ 	case NFPROTO_IPV6:
+ 		nft_reg_store8(dest, PACKET_MULTICAST);
+ 		break;
+ 	case NFPROTO_NETDEV:
+ 		switch (skb->protocol) {
+ 		case htons(ETH_P_IP): {
+ 			int noff = skb_network_offset(skb);
+ 			struct iphdr *iph, _iph;
+ 
+ 			iph = skb_header_pointer(skb, noff,
+ 						 sizeof(_iph), &_iph);
+ 			if (!iph)
+ 				return false;
+ 
+ 			if (ipv4_is_multicast(iph->daddr))
+ 				nft_reg_store8(dest, PACKET_MULTICAST);
+ 			else
+ 				nft_reg_store8(dest, PACKET_BROADCAST);
+ 
+ 			break;
+ 		}
+ 		case htons(ETH_P_IPV6):
+ 			nft_reg_store8(dest, PACKET_MULTICAST);
+ 			break;
+ 		default:
+ 			WARN_ON_ONCE(1);
+ 			return false;
+ 		}
+ 		break;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static noinline bool
+ nft_meta_get_eval_skugid(enum nft_meta_keys key,
+ 			 u32 *dest,
+ 			 const struct nft_pktinfo *pkt)
+ {
+ 	struct sock *sk = skb_to_full_sk(pkt->skb);
+ 	struct socket *sock;
+ 
+ 	if (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))
+ 		return false;
+ 
+ 	read_lock_bh(&sk->sk_callback_lock);
+ 	sock = sk->sk_socket;
+ 	if (!sock || !sock->file) {
+ 		read_unlock_bh(&sk->sk_callback_lock);
+ 		return false;
+ 	}
+ 
+ 	switch (key) {
+ 	case NFT_META_SKUID:
+ 		*dest = from_kuid_munged(sock_net(sk)->user_ns,
+ 					 sock->file->f_cred->fsuid);
+ 		break;
+ 	case NFT_META_SKGID:
+ 		*dest =	from_kgid_munged(sock_net(sk)->user_ns,
+ 					 sock->file->f_cred->fsgid);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	read_unlock_bh(&sk->sk_callback_lock);
+ 	return true;
+ }
+ 
+ #ifdef CONFIG_CGROUP_NET_CLASSID
+ static noinline bool
+ nft_meta_get_eval_cgroup(u32 *dest, const struct nft_pktinfo *pkt)
+ {
+ 	struct sock *sk = skb_to_full_sk(pkt->skb);
+ 
+ 	if (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))
+ 		return false;
+ 
+ 	*dest = sock_cgroup_classid(&sk->sk_cgrp_data);
+ 	return true;
+ }
++>>>>>>> 0c92411bb81d (netfilter: nft_meta: use socket user_ns to retrieve skuid and skgid)
  #endif
  
 -static noinline bool nft_meta_get_eval_kind(enum nft_meta_keys key,
 -					    u32 *dest,
 -					    const struct nft_pktinfo *pkt)
 -{
 -	const struct net_device *in = nft_in(pkt), *out = nft_out(pkt);
 -
 -	switch (key) {
 -	case NFT_META_IIFKIND:
 -		if (!in || !in->rtnl_link_ops)
 -			return false;
 -		strncpy((char *)dest, in->rtnl_link_ops->kind, IFNAMSIZ);
 -		break;
 -	case NFT_META_OIFKIND:
 -		if (!out || !out->rtnl_link_ops)
 -			return false;
 -		strncpy((char *)dest, out->rtnl_link_ops->kind, IFNAMSIZ);
 -		break;
 -	default:
 -		return false;
 -	}
 -
 -	return true;
 -}
 -
 -static void nft_meta_store_ifindex(u32 *dest, const struct net_device *dev)
 -{
 -	*dest = dev ? dev->ifindex : 0;
 -}
 -
 -static void nft_meta_store_ifname(u32 *dest, const struct net_device *dev)
 -{
 -	strncpy((char *)dest, dev ? dev->name : "", IFNAMSIZ);
 -}
 -
 -static bool nft_meta_store_iftype(u32 *dest, const struct net_device *dev)
 -{
 -	if (!dev)
 -		return false;
 -
 -	nft_reg_store16(dest, dev->type);
 -	return true;
 -}
 -
 -static bool nft_meta_store_ifgroup(u32 *dest, const struct net_device *dev)
 -{
 -	if (!dev)
 -		return false;
 -
 -	*dest = dev->group;
 -	return true;
 -}
 -
 -static bool nft_meta_get_eval_ifname(enum nft_meta_keys key, u32 *dest,
 -				     const struct nft_pktinfo *pkt)
 -{
 -	switch (key) {
 -	case NFT_META_IIFNAME:
 -		nft_meta_store_ifname(dest, nft_in(pkt));
 -		break;
 -	case NFT_META_OIFNAME:
 -		nft_meta_store_ifname(dest, nft_out(pkt));
 -		break;
 -	case NFT_META_IIF:
 -		nft_meta_store_ifindex(dest, nft_in(pkt));
 -		break;
 -	case NFT_META_OIF:
 -		nft_meta_store_ifindex(dest, nft_out(pkt));
 -		break;
 -	case NFT_META_IIFTYPE:
 -		if (!nft_meta_store_iftype(dest, nft_in(pkt)))
 -			return false;
 -		break;
 -	case NFT_META_OIFTYPE:
 -		if (!nft_meta_store_iftype(dest, nft_out(pkt)))
 -			return false;
 -		break;
 -	case NFT_META_IIFGROUP:
 -		if (!nft_meta_store_ifgroup(dest, nft_in(pkt)))
 -			return false;
 -		break;
 -	case NFT_META_OIFGROUP:
 -		if (!nft_meta_store_ifgroup(dest, nft_out(pkt)))
 -			return false;
 -		break;
 -	default:
 -		return false;
 -	}
 -
 -	return true;
 -}
 -
 -static noinline u32 nft_prandom_u32(void)
 -{
 -	struct rnd_state *state = this_cpu_ptr(&nft_prandom_state);
 -
 -	return prandom_u32_state(state);
 -}
 -
 -#ifdef CONFIG_IP_ROUTE_CLASSID
 -static noinline bool
 -nft_meta_get_eval_rtclassid(const struct sk_buff *skb, u32 *dest)
 -{
 -	const struct dst_entry *dst = skb_dst(skb);
 -
 -	if (!dst)
 -		return false;
 -
 -	*dest = dst->tclassid;
 -	return true;
 -}
 -#endif
 -
 -static noinline u32 nft_meta_get_eval_sdif(const struct nft_pktinfo *pkt)
 -{
 -	switch (nft_pf(pkt)) {
 -	case NFPROTO_IPV4:
 -		return inet_sdif(pkt->skb);
 -	case NFPROTO_IPV6:
 -		return inet6_sdif(pkt->skb);
 -	}
 -
 -	return 0;
 -}
 -
 -static noinline void
 -nft_meta_get_eval_sdifname(u32 *dest, const struct nft_pktinfo *pkt)
 -{
 -	u32 sdif = nft_meta_get_eval_sdif(pkt);
 -	const struct net_device *dev;
 -
 -	dev = sdif ? dev_get_by_index_rcu(nft_net(pkt), sdif) : NULL;
 -	nft_meta_store_ifname(dest, dev);
 -}
 -
 -void nft_meta_get_eval(const struct nft_expr *expr,
 -		       struct nft_regs *regs,
 -		       const struct nft_pktinfo *pkt)
 +static void nft_meta_get_eval(const struct nft_expr *expr,
 +			      struct nft_regs *regs,
 +			      const struct nft_pktinfo *pkt)
  {
  	const struct nft_meta *priv = nft_expr_priv(expr);
  	const struct sk_buff *skb = pkt->skb;
* Unmerged path net/netfilter/nft_meta.c
