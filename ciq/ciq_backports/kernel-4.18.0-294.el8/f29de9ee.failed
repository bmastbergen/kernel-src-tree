RDMA/mlx5: Add support for drop action in DV steering

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Daria Velikovsky <daria@mellanox.com>
commit f29de9eee78253d9ae57cd58a6b21eed021742c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f29de9ee.failed

When drop action is used the matching packet will stop processing in
steering and will be dropped. This functionality will allow users to drop
matching packets.

Link: https://lore.kernel.org/r/20200504054227.271486-1-leon@kernel.org
	Signed-off-by: Daria Velikovsky <daria@mellanox.com>
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit f29de9eee78253d9ae57cd58a6b21eed021742c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/flow.c
#	include/uapi/rdma/mlx5_user_ioctl_cmds.h
diff --cc drivers/infiniband/hw/mlx5/flow.c
index 69cb7e6e8955,6fa1a510c5d7..000000000000
--- a/drivers/infiniband/hw/mlx5/flow.c
+++ b/drivers/infiniband/hw/mlx5/flow.c
@@@ -67,46 -67,41 +67,78 @@@ static const struct uverbs_attr_spec ml
  	},
  };
  
++<<<<<<< HEAD
 +#define MLX5_IB_CREATE_FLOW_MAX_FLOW_ACTIONS 2
 +static int UVERBS_HANDLER(MLX5_IB_METHOD_CREATE_FLOW)(
 +	struct uverbs_attr_bundle *attrs)
++=======
+ static int get_dests(struct uverbs_attr_bundle *attrs,
+ 		     struct mlx5_ib_flow_matcher *fs_matcher, int *dest_id,
+ 		     int *dest_type, struct ib_qp **qp, u32 *flags)
++>>>>>>> f29de9eee782 (RDMA/mlx5: Add support for drop action in DV steering)
  {
 -	bool dest_devx, dest_qp;
 +	struct mlx5_flow_context flow_context = {.flow_tag = MLX5_FS_DEFAULT_FLOW_TAG};
 +	struct mlx5_ib_flow_handler *flow_handler;
 +	struct mlx5_ib_flow_matcher *fs_matcher;
 +	struct ib_uobject **arr_flow_actions;
 +	struct ib_uflow_resources *uflow_res;
 +	struct mlx5_flow_act flow_act = {};
  	void *devx_obj;
++<<<<<<< HEAD
 +	int dest_id, dest_type;
 +	void *cmd_in;
 +	int inlen;
 +	bool dest_devx, dest_qp;
 +	struct ib_qp *qp = NULL;
 +	struct ib_uobject *uobj =
 +		uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_CREATE_FLOW_HANDLE);
 +	struct mlx5_ib_dev *dev = mlx5_udata_to_mdev(&attrs->driver_udata);
 +	int len, ret, i;
 +	u32 counter_id = 0;
 +	u32 *offset_attr;
 +	u32 offset = 0;
++=======
+ 	int err;
++>>>>>>> f29de9eee782 (RDMA/mlx5: Add support for drop action in DV steering)
 +
 +	if (!capable(CAP_NET_RAW))
 +		return -EPERM;
  
 -	dest_devx = uverbs_attr_is_valid(attrs,
 -					 MLX5_IB_ATTR_CREATE_FLOW_DEST_DEVX);
 +	dest_devx =
 +		uverbs_attr_is_valid(attrs, MLX5_IB_ATTR_CREATE_FLOW_DEST_DEVX);
  	dest_qp = uverbs_attr_is_valid(attrs,
  				       MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);
  
++<<<<<<< HEAD
 +	fs_matcher = uverbs_attr_get_obj(attrs,
 +					 MLX5_IB_ATTR_CREATE_FLOW_MATCHER);
 +	if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_BYPASS &&
 +	    ((dest_devx && dest_qp) || (!dest_devx && !dest_qp)))
 +		return -EINVAL;
++=======
+ 	*flags = 0;
+ 	err = uverbs_get_flags32(flags, attrs, MLX5_IB_ATTR_CREATE_FLOW_FLAGS,
+ 				 MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS |
+ 					 MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP);
+ 	if (err)
+ 		return err;
  
- 	/* Allow only DEVX object as dest when inserting to FDB */
- 	if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_FDB && !dest_devx)
+ 	/* Both flags are not allowed */
+ 	if (*flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS &&
+ 	    *flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP)
+ 		return -EINVAL;
+ 
+ 	if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_BYPASS) {
+ 		if (dest_devx && (dest_qp || *flags))
+ 			return -EINVAL;
+ 		else if (dest_qp && *flags)
+ 			return -EINVAL;
+ 	}
++>>>>>>> f29de9eee782 (RDMA/mlx5: Add support for drop action in DV steering)
+ 
+ 	/* Allow only DEVX object, drop as dest for FDB */
+ 	if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_FDB && !(dest_devx ||
+ 	     (*flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP)))
  		return -EINVAL;
  
  	/* Allow only DEVX object or QP as dest when inserting to RDMA_RX */
@@@ -133,24 -128,67 +165,70 @@@
  	} else if (dest_qp) {
  		struct mlx5_ib_qp *mqp;
  
 -		*qp = uverbs_attr_get_obj(attrs,
 -					  MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);
 -		if (IS_ERR(*qp))
 -			return PTR_ERR(*qp);
 +		qp = uverbs_attr_get_obj(attrs,
 +					 MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);
 +		if (IS_ERR(qp))
 +			return PTR_ERR(qp);
  
 -		if ((*qp)->qp_type != IB_QPT_RAW_PACKET)
 +		if (qp->qp_type != IB_QPT_RAW_PACKET)
  			return -EINVAL;
  
 -		mqp = to_mqp(*qp);
 -		if (mqp->is_rss)
 -			*dest_id = mqp->rss_qp.tirn;
 +		mqp = to_mqp(qp);
 +		if (mqp->flags & MLX5_IB_QP_RSS)
 +			dest_id = mqp->rss_qp.tirn;
  		else
 -			*dest_id = mqp->raw_packet_qp.rq.tirn;
 -		*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 -	} else if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_EGRESS) {
 -		*dest_type = MLX5_FLOW_DESTINATION_TYPE_PORT;
 +			dest_id = mqp->raw_packet_qp.rq.tirn;
 +		dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 +	} else {
 +		dest_type = MLX5_FLOW_DESTINATION_TYPE_PORT;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (*dest_type == MLX5_FLOW_DESTINATION_TYPE_TIR &&
+ 	    fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_EGRESS)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ #define MLX5_IB_CREATE_FLOW_MAX_FLOW_ACTIONS 2
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_CREATE_FLOW)(
+ 	struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_flow_context flow_context = {.flow_tag =
+ 		MLX5_FS_DEFAULT_FLOW_TAG};
+ 	u32 *offset_attr, offset = 0, counter_id = 0;
+ 	int dest_id, dest_type, inlen, len, ret, i;
+ 	struct mlx5_ib_flow_handler *flow_handler;
+ 	struct mlx5_ib_flow_matcher *fs_matcher;
+ 	struct ib_uobject **arr_flow_actions;
+ 	struct ib_uflow_resources *uflow_res;
+ 	struct mlx5_flow_act flow_act = {};
+ 	struct ib_qp *qp = NULL;
+ 	void *devx_obj, *cmd_in;
+ 	struct ib_uobject *uobj;
+ 	struct mlx5_ib_dev *dev;
+ 	u32 flags;
+ 
+ 	if (!capable(CAP_NET_RAW))
+ 		return -EPERM;
+ 
+ 	fs_matcher = uverbs_attr_get_obj(attrs,
+ 					 MLX5_IB_ATTR_CREATE_FLOW_MATCHER);
+ 	uobj =  uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_CREATE_FLOW_HANDLE);
+ 	dev = mlx5_udata_to_mdev(&attrs->driver_udata);
+ 
+ 	if (get_dests(attrs, fs_matcher, &dest_id, &dest_type, &qp, &flags))
+ 		return -EINVAL;
+ 
+ 	if (flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS)
+ 		flow_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_NS;
+ 
+ 	if (flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP)
+ 		flow_act.action |= MLX5_FLOW_CONTEXT_ACTION_DROP;
+ 
++>>>>>>> f29de9eee782 (RDMA/mlx5: Add support for drop action in DV steering)
  	len = uverbs_attr_get_uobjs_arr(attrs,
  		MLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX, &arr_flow_actions);
  	if (len) {
diff --cc include/uapi/rdma/mlx5_user_ioctl_cmds.h
index 24f3388c3182,8e316ef896b5..000000000000
--- a/include/uapi/rdma/mlx5_user_ioctl_cmds.h
+++ b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
@@@ -241,6 -241,11 +241,14 @@@ enum mlx5_ib_flow_type 
  	MLX5_IB_FLOW_TYPE_MC_DEFAULT,
  };
  
++<<<<<<< HEAD
++=======
+ enum mlx5_ib_create_flow_flags {
+ 	MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS = 1 << 0,
+ 	MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP = 1 << 1,
+ };
+ 
++>>>>>>> f29de9eee782 (RDMA/mlx5: Add support for drop action in DV steering)
  enum mlx5_ib_create_flow_attrs {
  	MLX5_IB_ATTR_CREATE_FLOW_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
  	MLX5_IB_ATTR_CREATE_FLOW_MATCH_VALUE,
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path include/uapi/rdma/mlx5_user_ioctl_cmds.h
