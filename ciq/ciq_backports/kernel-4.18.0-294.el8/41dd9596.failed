security: add const qualifier to struct sock in various places

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Florian Westphal <fw@strlen.de>
commit 41dd9596d6b239a125c3d19f9d0ca90bdbfbf876
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/41dd9596.failed

A followup change to tcp_request_sock_op would have to drop the 'const'
qualifier from the 'route_req' function as the
'security_inet_conn_request' call is moved there - and that function
expects a 'struct sock *'.

However, it turns out its also possible to add a const qualifier to
security_inet_conn_request instead.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: James Morris <jamorris@linux.microsoft.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 41dd9596d6b239a125c3d19f9d0ca90bdbfbf876)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/lsm_hook_defs.h
#	security/apparmor/include/net.h
#	security/apparmor/lsm.c
#	security/apparmor/net.c
#	security/smack/smack_lsm.c
diff --cc security/apparmor/include/net.h
index ec7228e857a9,aadb4b29fb66..000000000000
--- a/security/apparmor/include/net.h
+++ b/security/apparmor/include/net.h
@@@ -103,4 -106,7 +103,10 @@@ int aa_sk_perm(const char *op, u32 requ
  int aa_sock_file_perm(struct aa_label *label, const char *op, u32 request,
  		      struct socket *sock);
  
++<<<<<<< HEAD
++=======
+ int apparmor_secmark_check(struct aa_label *label, char *op, u32 request,
+ 			   u32 secid, const struct sock *sk);
+ 
++>>>>>>> 41dd9596d6b2 (security: add const qualifier to struct sock in various places)
  #endif /* __AA_NET_H */
diff --cc security/apparmor/lsm.c
index 0a8ab968076b,1b0aba8eb723..000000000000
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@@ -1126,6 -1146,29 +1126,32 @@@ static void apparmor_sock_graft(struct 
  		ctx->label = aa_get_current_label();
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NETWORK_SECMARK
+ static int apparmor_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
+ 				      struct request_sock *req)
+ {
+ 	struct aa_sk_ctx *ctx = SK_CTX(sk);
+ 
+ 	if (!skb->secmark)
+ 		return 0;
+ 
+ 	return apparmor_secmark_check(ctx->label, OP_CONNECT, AA_MAY_CONNECT,
+ 				      skb->secmark, sk);
+ }
+ #endif
+ 
+ /*
+  * The cred blob is a pointer to, not an instance of, an aa_task_ctx.
+  */
+ struct lsm_blob_sizes apparmor_blob_sizes __lsm_ro_after_init = {
+ 	.lbs_cred = sizeof(struct aa_task_ctx *),
+ 	.lbs_file = sizeof(struct aa_file_ctx),
+ 	.lbs_task = sizeof(struct aa_task_ctx),
+ };
+ 
++>>>>>>> 41dd9596d6b2 (security: add const qualifier to struct sock in various places)
  static struct security_hook_list apparmor_hooks[] __lsm_ro_after_init = {
  	LSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),
  	LSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),
diff --cc security/apparmor/net.c
index bb24cfa0a164,e0c1b50d6edd..000000000000
--- a/security/apparmor/net.c
+++ b/security/apparmor/net.c
@@@ -185,3 -187,70 +185,73 @@@ int aa_sock_file_perm(struct aa_label *
  
  	return aa_label_sk_perm(label, op, request, sock->sk);
  }
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_NETWORK_SECMARK
+ static int apparmor_secmark_init(struct aa_secmark *secmark)
+ {
+ 	struct aa_label *label;
+ 
+ 	if (secmark->label[0] == '*') {
+ 		secmark->secid = AA_SECID_WILDCARD;
+ 		return 0;
+ 	}
+ 
+ 	label = aa_label_strn_parse(&root_ns->unconfined->label,
+ 				    secmark->label, strlen(secmark->label),
+ 				    GFP_ATOMIC, false, false);
+ 
+ 	if (IS_ERR(label))
+ 		return PTR_ERR(label);
+ 
+ 	secmark->secid = label->secid;
+ 
+ 	return 0;
+ }
+ 
+ static int aa_secmark_perm(struct aa_profile *profile, u32 request, u32 secid,
+ 			   struct common_audit_data *sa)
+ {
+ 	int i, ret;
+ 	struct aa_perms perms = { };
+ 
+ 	if (profile->secmark_count == 0)
+ 		return 0;
+ 
+ 	for (i = 0; i < profile->secmark_count; i++) {
+ 		if (!profile->secmark[i].secid) {
+ 			ret = apparmor_secmark_init(&profile->secmark[i]);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
+ 		if (profile->secmark[i].secid == secid ||
+ 		    profile->secmark[i].secid == AA_SECID_WILDCARD) {
+ 			if (profile->secmark[i].deny)
+ 				perms.deny = ALL_PERMS_MASK;
+ 			else
+ 				perms.allow = ALL_PERMS_MASK;
+ 
+ 			if (profile->secmark[i].audit)
+ 				perms.audit = ALL_PERMS_MASK;
+ 		}
+ 	}
+ 
+ 	aa_apply_modes_to_perms(profile, &perms);
+ 
+ 	return aa_check_perms(profile, &perms, request, sa, audit_net_cb);
+ }
+ 
+ int apparmor_secmark_check(struct aa_label *label, char *op, u32 request,
+ 			   u32 secid, const struct sock *sk)
+ {
+ 	struct aa_profile *profile;
+ 	DEFINE_AUDIT_SK(sa, op, sk);
+ 
+ 	return fn_for_each_confined(label, profile,
+ 				    aa_secmark_perm(profile, request, secid,
+ 						    &sa));
+ }
+ #endif
++>>>>>>> 41dd9596d6b2 (security: add const qualifier to struct sock in various places)
diff --cc security/smack/smack_lsm.c
index 77b0bfb018e5,3a62d6aa74a6..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -3894,6 -3833,62 +3894,65 @@@ static int smk_skb_to_addr_ipv6(struct 
  #endif /* CONFIG_IPV6 */
  
  /**
++<<<<<<< HEAD
++=======
+  * smack_from_skb - Smack data from the secmark in an skb
+  * @skb: packet
+  *
+  * Returns smack_known of the secmark or NULL if that won't work.
+  */
+ #ifdef CONFIG_NETWORK_SECMARK
+ static struct smack_known *smack_from_skb(struct sk_buff *skb)
+ {
+ 	if (skb == NULL || skb->secmark == 0)
+ 		return NULL;
+ 
+ 	return smack_from_secid(skb->secmark);
+ }
+ #else
+ static inline struct smack_known *smack_from_skb(struct sk_buff *skb)
+ {
+ 	return NULL;
+ }
+ #endif
+ 
+ /**
+  * smack_from_netlbl - Smack data from the IP options in an skb
+  * @sk: socket data came in on
+  * @family: address family
+  * @skb: packet
+  *
+  * Find the Smack label in the IP options. If it hasn't been
+  * added to the netlabel cache, add it here.
+  *
+  * Returns smack_known of the IP options or NULL if that won't work.
+  */
+ static struct smack_known *smack_from_netlbl(const struct sock *sk, u16 family,
+ 					     struct sk_buff *skb)
+ {
+ 	struct netlbl_lsm_secattr secattr;
+ 	struct socket_smack *ssp = NULL;
+ 	struct smack_known *skp = NULL;
+ 	int rc;
+ 
+ 	netlbl_secattr_init(&secattr);
+ 
+ 	if (sk)
+ 		ssp = sk->sk_security;
+ 
+ 	if (netlbl_skbuff_getattr(skb, family, &secattr) == 0) {
+ 		skp = smack_from_secattr(&secattr, ssp);
+ 		if (secattr.flags & NETLBL_SECATTR_CACHEABLE)
+ 			rc = netlbl_cache_add(skb, family, &skp->smk_netlabel);
+ 	}
+ 
+ 	netlbl_secattr_destroy(&secattr);
+ 
+ 	return skp;
+ }
+ 
+ /**
++>>>>>>> 41dd9596d6b2 (security: add const qualifier to struct sock in various places)
   * smack_socket_sock_rcv_skb - Smack packet delivery access check
   * @sk: socket
   * @skb: packet
* Unmerged path include/linux/lsm_hook_defs.h
diff --git a/include/linux/lsm_audit.h b/include/linux/lsm_audit.h
index 915330abf6e5..fa08d893d8db 100644
--- a/include/linux/lsm_audit.h
+++ b/include/linux/lsm_audit.h
@@ -26,7 +26,7 @@
 
 struct lsm_network_audit {
 	int netif;
-	struct sock *sk;
+	const struct sock *sk;
 	u16 family;
 	__be16 dport;
 	__be16 sport;
* Unmerged path include/linux/lsm_hook_defs.h
diff --git a/include/linux/security.h b/include/linux/security.h
index ea494663ce29..17963f037490 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1241,7 +1241,7 @@ void security_sk_clone(const struct sock *sk, struct sock *newsk);
 void security_sk_classify_flow(struct sock *sk, struct flowi *fl);
 void security_req_classify_flow(const struct request_sock *req, struct flowi *fl);
 void security_sock_graft(struct sock*sk, struct socket *parent);
-int security_inet_conn_request(struct sock *sk,
+int security_inet_conn_request(const struct sock *sk,
 			struct sk_buff *skb, struct request_sock *req);
 void security_inet_csk_clone(struct sock *newsk,
 			const struct request_sock *req);
@@ -1402,7 +1402,7 @@ static inline void security_sock_graft(struct sock *sk, struct socket *parent)
 {
 }
 
-static inline int security_inet_conn_request(struct sock *sk,
+static inline int security_inet_conn_request(const struct sock *sk,
 			struct sk_buff *skb, struct request_sock *req)
 {
 	return 0;
* Unmerged path security/apparmor/include/net.h
* Unmerged path security/apparmor/lsm.c
* Unmerged path security/apparmor/net.c
diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index d0b569f4647d..802f39389509 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -185,7 +185,7 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 
 
 static inline void print_ipv6_addr(struct audit_buffer *ab,
-				   struct in6_addr *addr, __be16 port,
+				   const struct in6_addr *addr, __be16 port,
 				   char *name1, char *name2)
 {
 	if (!ipv6_addr_any(addr))
@@ -324,7 +324,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	}
 	case LSM_AUDIT_DATA_NET:
 		if (a->u.net->sk) {
-			struct sock *sk = a->u.net->sk;
+			const struct sock *sk = a->u.net->sk;
 			struct unix_sock *u;
 			struct unix_address *addr;
 			int len = 0;
diff --git a/security/security.c b/security/security.c
index def81deae1f8..d15f4c6cda49 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1506,7 +1506,7 @@ void security_sock_graft(struct sock *sk, struct socket *parent)
 }
 EXPORT_SYMBOL(security_sock_graft);
 
-int security_inet_conn_request(struct sock *sk,
+int security_inet_conn_request(const struct sock *sk,
 			struct sk_buff *skb, struct request_sock *req)
 {
 	return call_int_hook(inet_conn_request, 0, sk, skb, req);
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 59c8121e387c..7ed9a15294b3 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -5404,7 +5404,7 @@ static void selinux_sctp_sk_clone(struct sctp_endpoint *ep, struct sock *sk,
 	selinux_netlbl_sctp_sk_clone(sk, newsk);
 }
 
-static int selinux_inet_conn_request(struct sock *sk, struct sk_buff *skb,
+static int selinux_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 				     struct request_sock *req)
 {
 	struct sk_security_struct *sksec = sk->sk_security;
* Unmerged path security/smack/smack_lsm.c
