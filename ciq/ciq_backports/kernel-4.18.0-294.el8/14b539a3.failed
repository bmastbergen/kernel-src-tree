net: atlantic: PTP statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Pavel Belous <pbelous@marvell.com>
commit 14b539a3490102750c86a63a8f27a69935e6a84e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/14b539a3.failed

This patch adds PTP rings statistics. Before that
these were missing from overall stats, hardening debugging
and analysis.

	Signed-off-by: Pavel Belous <pbelous@marvell.com>
	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 14b539a3490102750c86a63a8f27a69935e6a84e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
index a64230722f5c,1ab5314c4c1b..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
@@@ -83,25 -89,127 +83,137 @@@ static const char aq_ethtool_stat_names
  	"InDroppedDma",
  };
  
 -static const char * const aq_ethtool_queue_rx_stat_names[] = {
 -	"%sQueue[%d] InPackets",
 -	"%sQueue[%d] InJumboPackets",
 -	"%sQueue[%d] InLroPackets",
 -	"%sQueue[%d] InErrors",
 -	"%sQueue[%d] AllocFails",
 -	"%sQueue[%d] SkbAllocFails",
 -	"%sQueue[%d] Polls",
 +static const char aq_ethtool_queue_stat_names[][ETH_GSTRING_LEN] = {
 +	"Queue[%d] InPackets",
 +	"Queue[%d] OutPackets",
 +	"Queue[%d] Restarts",
 +	"Queue[%d] InJumboPackets",
 +	"Queue[%d] InLroPackets",
 +	"Queue[%d] InErrors",
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const aq_ethtool_queue_tx_stat_names[] = {
+ 	"%sQueue[%d] OutPackets",
+ 	"%sQueue[%d] Restarts",
+ };
+ 
+ #if IS_ENABLED(CONFIG_MACSEC)
+ static const char aq_macsec_stat_names[][ETH_GSTRING_LEN] = {
+ 	"MACSec InCtlPackets",
+ 	"MACSec InTaggedMissPackets",
+ 	"MACSec InUntaggedMissPackets",
+ 	"MACSec InNotagPackets",
+ 	"MACSec InUntaggedPackets",
+ 	"MACSec InBadTagPackets",
+ 	"MACSec InNoSciPackets",
+ 	"MACSec InUnknownSciPackets",
+ 	"MACSec InCtrlPortPassPackets",
+ 	"MACSec InUnctrlPortPassPackets",
+ 	"MACSec InCtrlPortFailPackets",
+ 	"MACSec InUnctrlPortFailPackets",
+ 	"MACSec InTooLongPackets",
+ 	"MACSec InIgpocCtlPackets",
+ 	"MACSec InEccErrorPackets",
+ 	"MACSec InUnctrlHitDropRedir",
+ 	"MACSec OutCtlPackets",
+ 	"MACSec OutUnknownSaPackets",
+ 	"MACSec OutUntaggedPackets",
+ 	"MACSec OutTooLong",
+ 	"MACSec OutEccErrorPackets",
+ 	"MACSec OutUnctrlHitDropRedir",
+ };
+ 
+ static const char * const aq_macsec_txsc_stat_names[] = {
+ 	"MACSecTXSC%d ProtectedPkts",
+ 	"MACSecTXSC%d EncryptedPkts",
+ 	"MACSecTXSC%d ProtectedOctets",
+ 	"MACSecTXSC%d EncryptedOctets",
+ };
+ 
+ static const char * const aq_macsec_txsa_stat_names[] = {
+ 	"MACSecTXSC%dSA%d HitDropRedirect",
+ 	"MACSecTXSC%dSA%d Protected2Pkts",
+ 	"MACSecTXSC%dSA%d ProtectedPkts",
+ 	"MACSecTXSC%dSA%d EncryptedPkts",
+ };
+ 
+ static const char * const aq_macsec_rxsa_stat_names[] = {
+ 	"MACSecRXSC%dSA%d UntaggedHitPkts",
+ 	"MACSecRXSC%dSA%d CtrlHitDrpRedir",
+ 	"MACSecRXSC%dSA%d NotUsingSa",
+ 	"MACSecRXSC%dSA%d UnusedSa",
+ 	"MACSecRXSC%dSA%d NotValidPkts",
+ 	"MACSecRXSC%dSA%d InvalidPkts",
+ 	"MACSecRXSC%dSA%d OkPkts",
+ 	"MACSecRXSC%dSA%d LatePkts",
+ 	"MACSecRXSC%dSA%d DelayedPkts",
+ 	"MACSecRXSC%dSA%d UncheckedPkts",
+ 	"MACSecRXSC%dSA%d ValidatedOctets",
+ 	"MACSecRXSC%dSA%d DecryptedOctets",
+ };
+ #endif
+ 
+ static const char aq_ethtool_priv_flag_names[][ETH_GSTRING_LEN] = {
+ 	"DMASystemLoopback",
+ 	"PKTSystemLoopback",
+ 	"DMANetworkLoopback",
+ 	"PHYInternalLoopback",
+ 	"PHYExternalLoopback",
+ };
+ 
+ static u32 aq_ethtool_n_stats(struct net_device *ndev)
+ {
+ 	const int rx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_rx_stat_names);
+ 	const int tx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_tx_stat_names);
+ 	struct aq_nic_s *nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(nic);
+ 	u32 n_stats = ARRAY_SIZE(aq_ethtool_stat_names) +
+ 		      (rx_stat_cnt + tx_stat_cnt) * cfg->vecs * cfg->tcs;
+ 
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 	n_stats += rx_stat_cnt * aq_ptp_get_ring_cnt(nic, ATL_RING_RX) +
+ 		   tx_stat_cnt * aq_ptp_get_ring_cnt(nic, ATL_RING_TX);
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 	if (nic->macsec_cfg) {
+ 		n_stats += ARRAY_SIZE(aq_macsec_stat_names) +
+ 			   ARRAY_SIZE(aq_macsec_txsc_stat_names) *
+ 				   aq_macsec_tx_sc_cnt(nic) +
+ 			   ARRAY_SIZE(aq_macsec_txsa_stat_names) *
+ 				   aq_macsec_tx_sa_cnt(nic) +
+ 			   ARRAY_SIZE(aq_macsec_rxsa_stat_names) *
+ 				   aq_macsec_rx_sa_cnt(nic);
+ 	}
+ #endif
+ 
+ 	return n_stats;
+ }
+ 
++>>>>>>> 14b539a34901 (net: atlantic: PTP statistics)
  static void aq_ethtool_stats(struct net_device *ndev,
  			     struct ethtool_stats *stats, u64 *data)
  {
  	struct aq_nic_s *aq_nic = netdev_priv(ndev);
 -
 +	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
 +
++<<<<<<< HEAD
 +	memset(data, 0, (ARRAY_SIZE(aq_ethtool_stat_names) +
 +			 ARRAY_SIZE(aq_ethtool_queue_stat_names) *
 +			 cfg->vecs) * sizeof(u64));
 +	aq_nic_get_stats(aq_nic, data);
++=======
+ 	memset(data, 0, aq_ethtool_n_stats(ndev) * sizeof(u64));
+ 	data = aq_nic_get_stats(aq_nic, data);
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 	data = aq_ptp_get_stats(aq_nic, data);
+ #endif
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 	data = aq_macsec_get_stats(aq_nic, data);
+ #endif
++>>>>>>> 14b539a34901 (net: atlantic: PTP statistics)
  }
  
  static void aq_ethtool_get_drvinfo(struct net_device *ndev,
@@@ -141,15 -261,117 +253,81 @@@ static void aq_ethtool_get_strings(stru
  		memcpy(p, aq_ethtool_stat_names,
  		       sizeof(aq_ethtool_stat_names));
  		p = p + sizeof(aq_ethtool_stat_names);
++<<<<<<< HEAD
 +		for (i = 0; i < cfg->vecs; i++) {
++=======
+ 
+ 		for (tc = 0; tc < cfg->tcs; tc++) {
+ 			if (cfg->is_qos)
+ 				snprintf(tc_string, 8, "TC%d ", tc);
+ 
+ 			for (i = 0; i < cfg->vecs; i++) {
+ 				for (si = 0; si < rx_stat_cnt; si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 					     aq_ethtool_queue_rx_stat_names[si],
+ 					     tc_string,
+ 					     AQ_NIC_CFG_TCVEC2RING(cfg, tc, i));
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 				for (si = 0; si < tx_stat_cnt; si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 					     aq_ethtool_queue_tx_stat_names[si],
+ 					     tc_string,
+ 					     AQ_NIC_CFG_TCVEC2RING(cfg, tc, i));
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 			}
+ 		}
+ #if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)
+ 		if (nic->aq_ptp) {
+ 			const int rx_ring_cnt = aq_ptp_get_ring_cnt(nic, ATL_RING_RX);
+ 			const int tx_ring_cnt = aq_ptp_get_ring_cnt(nic, ATL_RING_TX);
+ 			unsigned int ptp_ring_idx =
+ 				aq_ptp_ring_idx(nic->aq_nic_cfg.tc_mode);
+ 
+ 			snprintf(tc_string, 8, "PTP ");
+ 
+ 			for (i = 0; i < max(rx_ring_cnt, tx_ring_cnt); i++) {
+ 				for (si = 0; si < rx_stat_cnt; si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 						 aq_ethtool_queue_rx_stat_names[si],
+ 						 tc_string,
+ 						 i ? PTP_HWST_RING_IDX : ptp_ring_idx);
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 				if (i >= tx_ring_cnt)
+ 					continue;
+ 				for (si = 0; si < tx_stat_cnt; si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 						 aq_ethtool_queue_tx_stat_names[si],
+ 						 tc_string,
+ 						 i ? PTP_HWST_RING_IDX : ptp_ring_idx);
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 			}
+ 		}
+ #endif
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 		if (!nic->macsec_cfg)
+ 			break;
+ 
+ 		memcpy(p, aq_macsec_stat_names, sizeof(aq_macsec_stat_names));
+ 		p = p + sizeof(aq_macsec_stat_names);
+ 		for (i = 0; i < AQ_MACSEC_MAX_SC; i++) {
+ 			struct aq_macsec_txsc *aq_txsc;
+ 
+ 			if (!(test_bit(i, &nic->macsec_cfg->txsc_idx_busy)))
+ 				continue;
+ 
++>>>>>>> 14b539a34901 (net: atlantic: PTP statistics)
  			for (si = 0;
 -				si < ARRAY_SIZE(aq_macsec_txsc_stat_names);
 +				si < ARRAY_SIZE(aq_ethtool_queue_stat_names);
  				si++) {
  				snprintf(p, ETH_GSTRING_LEN,
 -					 aq_macsec_txsc_stat_names[si], i);
 +					 aq_ethtool_queue_stat_names[si], i);
  				p += ETH_GSTRING_LEN;
  			}
 -			aq_txsc = &nic->macsec_cfg->aq_txsc[i];
 -			for (sa = 0; sa < MACSEC_NUM_AN; sa++) {
 -				if (!(test_bit(sa, &aq_txsc->tx_sa_idx_busy)))
 -					continue;
 -				for (si = 0;
 -				     si < ARRAY_SIZE(aq_macsec_txsa_stat_names);
 -				     si++) {
 -					snprintf(p, ETH_GSTRING_LEN,
 -						 aq_macsec_txsa_stat_names[si],
 -						 i, sa);
 -					p += ETH_GSTRING_LEN;
 -				}
 -			}
 -		}
 -		for (i = 0; i < AQ_MACSEC_MAX_SC; i++) {
 -			struct aq_macsec_rxsc *aq_rxsc;
 -
 -			if (!(test_bit(i, &nic->macsec_cfg->rxsc_idx_busy)))
 -				continue;
 -
 -			aq_rxsc = &nic->macsec_cfg->aq_rxsc[i];
 -			for (sa = 0; sa < MACSEC_NUM_AN; sa++) {
 -				if (!(test_bit(sa, &aq_rxsc->rx_sa_idx_busy)))
 -					continue;
 -				for (si = 0;
 -				     si < ARRAY_SIZE(aq_macsec_rxsa_stat_names);
 -				     si++) {
 -					snprintf(p, ETH_GSTRING_LEN,
 -						 aq_macsec_rxsa_stat_names[si],
 -						 i, sa);
 -					p += ETH_GSTRING_LEN;
 -				}
 -			}
  		}
 -#endif
 -		break;
 -	}
 -	case ETH_SS_PRIV_FLAGS:
 -		memcpy(p, aq_ethtool_priv_flag_names,
 -		       sizeof(aq_ethtool_priv_flag_names));
 -		break;
  	}
  }
  
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
