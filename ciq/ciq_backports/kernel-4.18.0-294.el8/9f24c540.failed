lib/vdso: Update coarse timekeeper unconditionally

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 9f24c540f7f8eb3a981528da9a9a636a5bdf5987
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9f24c540.failed

The low resolution parts of the VDSO, i.e.:

  clock_gettime(CLOCK_*_COARSE), clock_getres(), time()

can be used even if there is no VDSO capable clocksource.

But if an architecture opts out of the VDSO data update then this
information becomes stale. This affects ARM when there is no architected
timer available. The lack of update causes userspace to use stale data
forever.

Make the update of the low resolution parts unconditional and only skip
the update of the high resolution parts if the architecture requests it.

Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20200114185946.765577901@linutronix.de

(cherry picked from commit 9f24c540f7f8eb3a981528da9a9a636a5bdf5987)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/vsyscall.c
diff --cc kernel/time/vsyscall.c
index 4bc37ac3bb05,9577c89179cd..000000000000
--- a/kernel/time/vsyscall.c
+++ b/kernel/time/vsyscall.c
@@@ -84,14 -73,6 +73,17 @@@ void update_vsyscall(struct timekeeper 
  	struct vdso_timestamp *vdso_ts;
  	u64 nsec;
  
++<<<<<<< HEAD
 +	if (__arch_update_vdso_data()) {
 +		/*
 +		 * Some architectures might want to skip the update of the
 +		 * data page.
 +		 */
 +		return;
 +	}
 +
++=======
++>>>>>>> 9f24c540f7f8 (lib/vdso: Update coarse timekeeper unconditionally)
  	/* copy vsyscall data */
  	vdso_write_begin(vdata);
  
@@@ -110,7 -96,17 +107,21 @@@
  	nsec		= nsec + tk->wall_to_monotonic.tv_nsec;
  	vdso_ts->sec	+= __iter_div_u64_rem(nsec, NSEC_PER_SEC, &vdso_ts->nsec);
  
++<<<<<<< HEAD
 +	if (__arch_use_vsyscall(vdata))
++=======
+ 	/*
+ 	 * Read without the seqlock held by clock_getres().
+ 	 * Note: No need to have a second copy.
+ 	 */
+ 	WRITE_ONCE(vdata[CS_HRES_COARSE].hrtimer_res, hrtimer_resolution);
+ 
+ 	/*
+ 	 * Architectures can opt out of updating the high resolution part
+ 	 * of the VDSO.
+ 	 */
+ 	if (__arch_update_vdso_data())
++>>>>>>> 9f24c540f7f8 (lib/vdso: Update coarse timekeeper unconditionally)
  		update_vdso_data(vdata, tk);
  
  	__arch_update_vsyscall(vdata, tk);
* Unmerged path kernel/time/vsyscall.c
