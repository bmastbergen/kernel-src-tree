powerpc: Introduce a function for reporting instruction length

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jordan Niethe <jniethe5@gmail.com>
commit 622cf6f436a12338bbcfbb3474629755547fd112
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/622cf6f4.failed

Currently all instructions have the same length, but in preparation for
prefixed instructions introduce a function for returning instruction
length.

	Signed-off-by: Jordan Niethe <jniethe5@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
	Reviewed-by: Alistair Popple <alistair@popple.id.au>
Link: https://lore.kernel.org/r/20200506034050.24806-18-jniethe5@gmail.com
(cherry picked from commit 622cf6f436a12338bbcfbb3474629755547fd112)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/inst.h
#	arch/powerpc/lib/feature-fixups.c
diff --cc arch/powerpc/lib/feature-fixups.c
index e613b02bb2f0,0c9ffdef8096..000000000000
--- a/arch/powerpc/lib/feature-fixups.c
+++ b/arch/powerpc/lib/feature-fixups.c
@@@ -369,20 -392,20 +369,36 @@@ void do_lwsync_fixups(unsigned long val
  static void do_final_fixups(void)
  {
  #if defined(CONFIG_PPC64) && defined(CONFIG_RELOCATABLE)
++<<<<<<< HEAD
 +	int *src, *dest;
 +	unsigned long length;
++=======
+ 	struct ppc_inst inst, *src, *dest, *end;
++>>>>>>> 622cf6f436a1 (powerpc: Introduce a function for reporting instruction length)
  
  	if (PHYSICAL_START == 0)
  		return;
  
++<<<<<<< HEAD
 +	src = (int *)(KERNELBASE + PHYSICAL_START);
 +	dest = (int *)KERNELBASE;
 +	length = (__end_interrupts - _stext) / sizeof(int);
 +
 +	while (length--) {
 +		raw_patch_instruction(dest, *src);
 +		src++;
 +		dest++;
++=======
+ 	src = (struct ppc_inst *)(KERNELBASE + PHYSICAL_START);
+ 	dest = (struct ppc_inst *)KERNELBASE;
+ 	end = (void *)src + (__end_interrupts - _stext);
+ 
+ 	while (src < end) {
+ 		inst = ppc_inst_read(src);
+ 		raw_patch_instruction(dest, inst);
+ 		src = (void *)src + ppc_inst_len(inst);
+ 		dest = (void *)dest + ppc_inst_len(inst);
++>>>>>>> 622cf6f436a1 (powerpc: Introduce a function for reporting instruction length)
  	}
  #endif
  }
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/include/asm/inst.h
diff --git a/arch/powerpc/kernel/kprobes.c b/arch/powerpc/kernel/kprobes.c
index e4c5bf33970b..91315c66e004 100644
--- a/arch/powerpc/kernel/kprobes.c
+++ b/arch/powerpc/kernel/kprobes.c
@@ -495,14 +495,16 @@ NOKPROBE_SYMBOL(trampoline_probe_handler);
  */
 int kprobe_post_handler(struct pt_regs *regs)
 {
+	int len;
 	struct kprobe *cur = kprobe_running();
 	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
 
 	if (!cur || user_mode(regs))
 		return 0;
 
+	len = ppc_inst_len(ppc_inst_read((struct ppc_inst *)cur->ainsn.insn));
 	/* make sure we got here for instruction we have a kprobe on */
-	if (((unsigned long)cur->ainsn.insn + 4) != regs->nip)
+	if (((unsigned long)cur->ainsn.insn + len) != regs->nip)
 		return 0;
 
 	if ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {
@@ -511,7 +513,7 @@ int kprobe_post_handler(struct pt_regs *regs)
 	}
 
 	/* Adjust nip to after the single-stepped instruction */
-	regs->nip = (unsigned long)cur->addr + 4;
+	regs->nip = (unsigned long)cur->addr + len;
 	regs->msr |= kcb->kprobe_saved_msr;
 
 	/*Restore back the original saved kprobes variables and continue. */
diff --git a/arch/powerpc/kernel/uprobes.c b/arch/powerpc/kernel/uprobes.c
index 5d105b8eeece..da977f136ae7 100644
--- a/arch/powerpc/kernel/uprobes.c
+++ b/arch/powerpc/kernel/uprobes.c
@@ -124,7 +124,7 @@ int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 	 * support doesn't exist and have to fix-up the next instruction
 	 * to be executed.
 	 */
-	regs->nip = utask->vaddr + MAX_UINSN_BYTES;
+	regs->nip = utask->vaddr + ppc_inst_len(ppc_inst_read(&auprobe->insn));
 
 	user_disable_single_step(current);
 	return 0;
* Unmerged path arch/powerpc/lib/feature-fixups.c
