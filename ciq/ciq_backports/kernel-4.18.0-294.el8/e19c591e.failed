ethtool: set device channel counts with CHANNELS_SET request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michal Kubecek <mkubecek@suse.cz>
commit e19c591eafad4d723a2eed385e253eca0506cc25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e19c591e.failed

Implement CHANNELS_SET netlink request to set channel counts of a network
device. These are traditionally set with ETHTOOL_SCHANNELS ioctl request.

Like the ioctl implementation, the generic ethtool code checks if supplied
values do not exceed driver defined limits; if they do, first offending
attribute is reported using extack. Checks preventing removing channels
used for RX indirection table or zerocopy AF_XDP socket are also
implemented.

Move ethtool_get_max_rxfh_channel() helper into common.c so that it can be
used by both ioctl and netlink code.

v2:
  - fix netdev reference leak in error path (found by Jakub Kicinsky)

	Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
	Reviewed-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e19c591eafad4d723a2eed385e253eca0506cc25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/ethtool-netlink.rst
#	include/uapi/linux/ethtool_netlink.h
#	net/ethtool/channels.c
#	net/ethtool/common.c
#	net/ethtool/common.h
#	net/ethtool/netlink.c
#	net/ethtool/netlink.h
diff --cc net/ethtool/common.c
index 0a8728565356,0b22741b2f8f..000000000000
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@@ -167,5 -168,124 +167,126 @@@ const char link_mode_names[][ETH_GSTRIN
  	__DEFINE_LINK_MODE_NAME(400000, LR8_ER8_FR8, Full),
  	__DEFINE_LINK_MODE_NAME(400000, DR8, Full),
  	__DEFINE_LINK_MODE_NAME(400000, CR8, Full),
 -	__DEFINE_SPECIAL_MODE_NAME(FEC_LLRS, "LLRS"),
  };
  static_assert(ARRAY_SIZE(link_mode_names) == __ETHTOOL_LINK_MODE_MASK_NBITS);
++<<<<<<< HEAD
++=======
+ 
+ const char netif_msg_class_names[][ETH_GSTRING_LEN] = {
+ 	[NETIF_MSG_DRV_BIT]		= "drv",
+ 	[NETIF_MSG_PROBE_BIT]		= "probe",
+ 	[NETIF_MSG_LINK_BIT]		= "link",
+ 	[NETIF_MSG_TIMER_BIT]		= "timer",
+ 	[NETIF_MSG_IFDOWN_BIT]		= "ifdown",
+ 	[NETIF_MSG_IFUP_BIT]		= "ifup",
+ 	[NETIF_MSG_RX_ERR_BIT]		= "rx_err",
+ 	[NETIF_MSG_TX_ERR_BIT]		= "tx_err",
+ 	[NETIF_MSG_TX_QUEUED_BIT]	= "tx_queued",
+ 	[NETIF_MSG_INTR_BIT]		= "intr",
+ 	[NETIF_MSG_TX_DONE_BIT]		= "tx_done",
+ 	[NETIF_MSG_RX_STATUS_BIT]	= "rx_status",
+ 	[NETIF_MSG_PKTDATA_BIT]		= "pktdata",
+ 	[NETIF_MSG_HW_BIT]		= "hw",
+ 	[NETIF_MSG_WOL_BIT]		= "wol",
+ };
+ static_assert(ARRAY_SIZE(netif_msg_class_names) == NETIF_MSG_CLASS_COUNT);
+ 
+ const char wol_mode_names[][ETH_GSTRING_LEN] = {
+ 	[const_ilog2(WAKE_PHY)]		= "phy",
+ 	[const_ilog2(WAKE_UCAST)]	= "ucast",
+ 	[const_ilog2(WAKE_MCAST)]	= "mcast",
+ 	[const_ilog2(WAKE_BCAST)]	= "bcast",
+ 	[const_ilog2(WAKE_ARP)]		= "arp",
+ 	[const_ilog2(WAKE_MAGIC)]	= "magic",
+ 	[const_ilog2(WAKE_MAGICSECURE)]	= "magicsecure",
+ 	[const_ilog2(WAKE_FILTER)]	= "filter",
+ };
+ static_assert(ARRAY_SIZE(wol_mode_names) == WOL_MODE_COUNT);
+ 
+ /* return false if legacy contained non-0 deprecated fields
+  * maxtxpkt/maxrxpkt. rest of ksettings always updated
+  */
+ bool
+ convert_legacy_settings_to_link_ksettings(
+ 	struct ethtool_link_ksettings *link_ksettings,
+ 	const struct ethtool_cmd *legacy_settings)
+ {
+ 	bool retval = true;
+ 
+ 	memset(link_ksettings, 0, sizeof(*link_ksettings));
+ 
+ 	/* This is used to tell users that driver is still using these
+ 	 * deprecated legacy fields, and they should not use
+ 	 * %ETHTOOL_GLINKSETTINGS/%ETHTOOL_SLINKSETTINGS
+ 	 */
+ 	if (legacy_settings->maxtxpkt ||
+ 	    legacy_settings->maxrxpkt)
+ 		retval = false;
+ 
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.supported,
+ 		legacy_settings->supported);
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.advertising,
+ 		legacy_settings->advertising);
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.lp_advertising,
+ 		legacy_settings->lp_advertising);
+ 	link_ksettings->base.speed
+ 		= ethtool_cmd_speed(legacy_settings);
+ 	link_ksettings->base.duplex
+ 		= legacy_settings->duplex;
+ 	link_ksettings->base.port
+ 		= legacy_settings->port;
+ 	link_ksettings->base.phy_address
+ 		= legacy_settings->phy_address;
+ 	link_ksettings->base.autoneg
+ 		= legacy_settings->autoneg;
+ 	link_ksettings->base.mdio_support
+ 		= legacy_settings->mdio_support;
+ 	link_ksettings->base.eth_tp_mdix
+ 		= legacy_settings->eth_tp_mdix;
+ 	link_ksettings->base.eth_tp_mdix_ctrl
+ 		= legacy_settings->eth_tp_mdix_ctrl;
+ 	return retval;
+ }
+ 
+ int __ethtool_get_link(struct net_device *dev)
+ {
+ 	if (!dev->ethtool_ops->get_link)
+ 		return -EOPNOTSUPP;
+ 
+ 	return netif_running(dev) && dev->ethtool_ops->get_link(dev);
+ }
+ 
+ int ethtool_get_max_rxfh_channel(struct net_device *dev, u32 *max)
+ {
+ 	u32 dev_size, current_max = 0;
+ 	u32 *indir;
+ 	int ret;
+ 
+ 	if (!dev->ethtool_ops->get_rxfh_indir_size ||
+ 	    !dev->ethtool_ops->get_rxfh)
+ 		return -EOPNOTSUPP;
+ 	dev_size = dev->ethtool_ops->get_rxfh_indir_size(dev);
+ 	if (dev_size == 0)
+ 		return -EOPNOTSUPP;
+ 
+ 	indir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);
+ 	if (!indir)
+ 		return -ENOMEM;
+ 
+ 	ret = dev->ethtool_ops->get_rxfh(dev, indir, NULL, NULL);
+ 	if (ret)
+ 		goto out;
+ 
+ 	while (dev_size--)
+ 		current_max = max(current_max, indir[dev_size]);
+ 
+ 	*max = current_max;
+ 
+ out:
+ 	kfree(indir);
+ 	return ret;
+ }
++>>>>>>> e19c591eafad (ethtool: set device channel counts with CHANNELS_SET request)
diff --cc net/ethtool/common.h
index bbb788908cb1,03946e16e623..000000000000
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@@ -18,5 -21,14 +18,17 @@@ tunable_strings[__ETHTOOL_TUNABLE_COUNT
  extern const char
  phy_tunable_strings[__ETHTOOL_PHY_TUNABLE_COUNT][ETH_GSTRING_LEN];
  extern const char link_mode_names[][ETH_GSTRING_LEN];
++<<<<<<< HEAD
++=======
+ extern const char netif_msg_class_names[][ETH_GSTRING_LEN];
+ extern const char wol_mode_names[][ETH_GSTRING_LEN];
+ 
+ int __ethtool_get_link(struct net_device *dev);
+ 
+ bool convert_legacy_settings_to_link_ksettings(
+ 	struct ethtool_link_ksettings *link_ksettings,
+ 	const struct ethtool_cmd *legacy_settings);
+ int ethtool_get_max_rxfh_channel(struct net_device *dev, u32 *max);
++>>>>>>> e19c591eafad (ethtool: set device channel counts with CHANNELS_SET request)
  
  #endif /* _ETHTOOL_COMMON_H */
* Unmerged path Documentation/networking/ethtool-netlink.rst
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/channels.c
* Unmerged path net/ethtool/netlink.c
* Unmerged path net/ethtool/netlink.h
* Unmerged path Documentation/networking/ethtool-netlink.rst
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/channels.c
* Unmerged path net/ethtool/common.c
* Unmerged path net/ethtool/common.h
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 093ecc4fca15..9fff1891c3ea 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -1186,37 +1186,6 @@ void netdev_rss_key_fill(void *buffer, size_t len)
 }
 EXPORT_SYMBOL(netdev_rss_key_fill);
 
-static int ethtool_get_max_rxfh_channel(struct net_device *dev, u32 *max)
-{
-	u32 dev_size, current_max = 0;
-	u32 *indir;
-	int ret;
-
-	if (!dev->ethtool_ops->get_rxfh_indir_size ||
-	    !dev->ethtool_ops->get_rxfh)
-		return -EOPNOTSUPP;
-	dev_size = dev->ethtool_ops->get_rxfh_indir_size(dev);
-	if (dev_size == 0)
-		return -EOPNOTSUPP;
-
-	indir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);
-	if (!indir)
-		return -ENOMEM;
-
-	ret = dev->ethtool_ops->get_rxfh(dev, indir, NULL, NULL);
-	if (ret)
-		goto out;
-
-	while (dev_size--)
-		current_max = max(current_max, indir[dev_size]);
-
-	*max = current_max;
-
-out:
-	kfree(indir);
-	return ret;
-}
-
 static noinline_for_stack int ethtool_get_rxfh_indir(struct net_device *dev,
 						     void __user *useraddr)
 {
* Unmerged path net/ethtool/netlink.c
* Unmerged path net/ethtool/netlink.h
