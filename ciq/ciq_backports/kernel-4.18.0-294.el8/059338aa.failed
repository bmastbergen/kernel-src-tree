move mount_capable() calls to vfs_get_tree()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 059338aae33165179352a26b58d815801072c87d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/059338aa.failed

sget_fc() is called only from ->get_tree() instances and
the only instance not calling it is legacy_get_tree(),
which calls mount_capable() directly.

In all sget_fc() callers the checks could be moved to the
very beginning of ->get_tree() - ->user_ns is not changed
in between.  So lifting the checks to the only caller of
->get_tree() is OK.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 059338aae33165179352a26b58d815801072c87d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs_context.c
#	fs/super.c
diff --cc fs/super.c
index 72596c26684f,2c38541cd89f..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -478,6 -476,91 +478,94 @@@ void generic_shutdown_super(struct supe
  
  EXPORT_SYMBOL(generic_shutdown_super);
  
++<<<<<<< HEAD
++=======
+ bool mount_capable(struct fs_context *fc)
+ {
+ 	struct user_namespace *user_ns = fc->global ? &init_user_ns
+ 						    : fc->user_ns;
+ 
+ 	if (!(fc->fs_type->fs_flags & FS_USERNS_MOUNT))
+ 		return capable(CAP_SYS_ADMIN);
+ 	else
+ 		return ns_capable(user_ns, CAP_SYS_ADMIN);
+ }
+ 
+ /**
+  * sget_fc - Find or create a superblock
+  * @fc:	Filesystem context.
+  * @test: Comparison callback
+  * @set: Setup callback
+  *
+  * Find or create a superblock using the parameters stored in the filesystem
+  * context and the two callback functions.
+  *
+  * If an extant superblock is matched, then that will be returned with an
+  * elevated reference count that the caller must transfer or discard.
+  *
+  * If no match is made, a new superblock will be allocated and basic
+  * initialisation will be performed (s_type, s_fs_info and s_id will be set and
+  * the set() callback will be invoked), the superblock will be published and it
+  * will be returned in a partially constructed state with SB_BORN and SB_ACTIVE
+  * as yet unset.
+  */
+ struct super_block *sget_fc(struct fs_context *fc,
+ 			    int (*test)(struct super_block *, struct fs_context *),
+ 			    int (*set)(struct super_block *, struct fs_context *))
+ {
+ 	struct super_block *s = NULL;
+ 	struct super_block *old;
+ 	struct user_namespace *user_ns = fc->global ? &init_user_ns : fc->user_ns;
+ 	int err;
+ 
+ retry:
+ 	spin_lock(&sb_lock);
+ 	if (test) {
+ 		hlist_for_each_entry(old, &fc->fs_type->fs_supers, s_instances) {
+ 			if (test(old, fc))
+ 				goto share_extant_sb;
+ 		}
+ 	}
+ 	if (!s) {
+ 		spin_unlock(&sb_lock);
+ 		s = alloc_super(fc->fs_type, fc->sb_flags, user_ns);
+ 		if (!s)
+ 			return ERR_PTR(-ENOMEM);
+ 		goto retry;
+ 	}
+ 
+ 	s->s_fs_info = fc->s_fs_info;
+ 	err = set(s, fc);
+ 	if (err) {
+ 		s->s_fs_info = NULL;
+ 		spin_unlock(&sb_lock);
+ 		destroy_unused_super(s);
+ 		return ERR_PTR(err);
+ 	}
+ 	fc->s_fs_info = NULL;
+ 	s->s_type = fc->fs_type;
+ 	strlcpy(s->s_id, s->s_type->name, sizeof(s->s_id));
+ 	list_add_tail(&s->s_list, &super_blocks);
+ 	hlist_add_head(&s->s_instances, &s->s_type->fs_supers);
+ 	spin_unlock(&sb_lock);
+ 	get_filesystem(s->s_type);
+ 	register_shrinker_prepared(&s->s_shrink);
+ 	return s;
+ 
+ share_extant_sb:
+ 	if (user_ns != old->s_user_ns) {
+ 		spin_unlock(&sb_lock);
+ 		destroy_unused_super(s);
+ 		return ERR_PTR(-EBUSY);
+ 	}
+ 	if (!grab_super(old))
+ 		goto retry;
+ 	destroy_unused_super(s);
+ 	return old;
+ }
+ EXPORT_SYMBOL(sget_fc);
+ 
++>>>>>>> 059338aae331 (move mount_capable() calls to vfs_get_tree())
  /**
   *	sget_userns -	find or create a superblock
   *	@type:	filesystem type superblock should belong to
@@@ -1238,29 -1399,45 +1326,52 @@@ struct dentry *mount_single(struct file
  }
  EXPORT_SYMBOL(mount_single);
  
 -/**
 - * vfs_get_tree - Get the mountable root
 - * @fc: The superblock configuration context.
 - *
 - * The filesystem is invoked to get or create a superblock which can then later
 - * be used for mounting.  The filesystem places a pointer to the root to be
 - * used for mounting in @fc->root.
 - */
 -int vfs_get_tree(struct fs_context *fc)
 +struct dentry *
 +mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
  {
 +	struct dentry *root;
  	struct super_block *sb;
 -	int error;
 +	int error = -ENOMEM;
 +	struct security_mnt_opts opts;
  
 -	if (fc->root)
 -		return -EBUSY;
 +	security_init_mnt_opts(&opts);
  
++<<<<<<< HEAD
 +	if (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {
 +		error = security_sb_eat_lsm_opts(data, &opts);
 +		if (error)
 +			return ERR_PTR(error);
++=======
+ 	if (!(fc->sb_flags & SB_KERNMOUNT) &&
+ 	    fc->purpose != FS_CONTEXT_FOR_SUBMOUNT) {
+ 		if (!mount_capable(fc))
+ 			return -EPERM;
+ 	}
+ 
+ 	/* Get the mountable root in fc->root, with a ref on the root and a ref
+ 	 * on the superblock.
+ 	 */
+ 	error = fc->ops->get_tree(fc);
+ 	if (error < 0)
+ 		return error;
+ 
+ 	if (!fc->root) {
+ 		pr_err("Filesystem %s get_tree() didn't set fc->root\n",
+ 		       fc->fs_type->name);
+ 		/* We don't know what the locking state of the superblock is -
+ 		 * if there is a superblock.
+ 		 */
+ 		BUG();
++>>>>>>> 059338aae331 (move mount_capable() calls to vfs_get_tree())
  	}
  
 -	sb = fc->root->d_sb;
 +	root = type->mount(type, flags, name, data);
 +	if (IS_ERR(root)) {
 +		error = PTR_ERR(root);
 +		goto out_free_secdata;
 +	}
 +	sb = root->d_sb;
 +	BUG_ON(!sb);
  	WARN_ON(!sb->s_bdi);
  
  	if (fc->subtype && !sb->s_subtype) {
* Unmerged path fs/fs_context.c
* Unmerged path fs/fs_context.c
* Unmerged path fs/super.c
