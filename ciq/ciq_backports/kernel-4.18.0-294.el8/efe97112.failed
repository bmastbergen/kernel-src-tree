cpuidle: change enter_s2idle() prototype

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Neal Liu <neal.liu@mediatek.com>
commit efe9711214e6138a5a2a46ca4068bfce50c03444
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/efe97112.failed

Control Flow Integrity(CFI) is a security mechanism that disallows
changes to the original control flow graph of a compiled binary,
making it significantly harder to perform such attacks.

init_state_node() assign same function callback to different
function pointer declarations.

static int init_state_node(struct cpuidle_state *idle_state,
                           const struct of_device_id *matches,
                           struct device_node *state_node) { ...
        idle_state->enter = match_id->data; ...
        idle_state->enter_s2idle = match_id->data; }

Function declarations:

struct cpuidle_state { ...
        int (*enter) (struct cpuidle_device *dev,
                      struct cpuidle_driver *drv,
                      int index);

        void (*enter_s2idle) (struct cpuidle_device *dev,
                              struct cpuidle_driver *drv,
                              int index); };

In this case, either enter() or enter_s2idle() would cause CFI check
failed since they use same callee.

Align function prototype of enter() since it needs return value for
some use cases. The return value of enter_s2idle() is no
need currently.

	Signed-off-by: Neal Liu <neal.liu@mediatek.com>
	Reviewed-by: Sami Tolvanen <samitolvanen@google.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit efe9711214e6138a5a2a46ca4068bfce50c03444)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/cpuidle-tegra.c
#	drivers/idle/intel_idle.c
#	include/linux/cpuidle.h
diff --cc drivers/idle/intel_idle.c
index 0c5221d5504f,3f86f36dab2b..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -123,6 -107,83 +123,86 @@@ static struct cpuidle_state *cpuidle_st
  #define flg2MWAIT(flags) (((flags) >> 24) & 0xFF)
  #define MWAIT2flg(eax) ((eax & 0xFF) << 24)
  
++<<<<<<< HEAD
++=======
+ /**
+  * intel_idle - Ask the processor to enter the given idle state.
+  * @dev: cpuidle device of the target CPU.
+  * @drv: cpuidle driver (assumed to point to intel_idle_driver).
+  * @index: Target idle state index.
+  *
+  * Use the MWAIT instruction to notify the processor that the CPU represented by
+  * @dev is idle and it can try to enter the idle state corresponding to @index.
+  *
+  * If the local APIC timer is not known to be reliable in the target idle state,
+  * enable one-shot tick broadcasting for the target CPU before executing MWAIT.
+  *
+  * Optionally call leave_mm() for the target CPU upfront to avoid wakeups due to
+  * flushing user TLBs.
+  *
+  * Must be called under local_irq_disable().
+  */
+ static __cpuidle int intel_idle(struct cpuidle_device *dev,
+ 				struct cpuidle_driver *drv, int index)
+ {
+ 	struct cpuidle_state *state = &drv->states[index];
+ 	unsigned long eax = flg2MWAIT(state->flags);
+ 	unsigned long ecx = 1; /* break on interrupt flag */
+ 	bool uninitialized_var(tick);
+ 	int cpu = smp_processor_id();
+ 
+ 	/*
+ 	 * leave_mm() to avoid costly and often unnecessary wakeups
+ 	 * for flushing the user TLB's associated with the active mm.
+ 	 */
+ 	if (state->flags & CPUIDLE_FLAG_TLB_FLUSHED)
+ 		leave_mm(cpu);
+ 
+ 	if (!static_cpu_has(X86_FEATURE_ARAT)) {
+ 		/*
+ 		 * Switch over to one-shot tick broadcast if the target C-state
+ 		 * is deeper than C1.
+ 		 */
+ 		if ((eax >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) {
+ 			tick = true;
+ 			tick_broadcast_enter();
+ 		} else {
+ 			tick = false;
+ 		}
+ 	}
+ 
+ 	mwait_idle_with_hints(eax, ecx);
+ 
+ 	if (!static_cpu_has(X86_FEATURE_ARAT) && tick)
+ 		tick_broadcast_exit();
+ 
+ 	return index;
+ }
+ 
+ /**
+  * intel_idle_s2idle - Ask the processor to enter the given idle state.
+  * @dev: cpuidle device of the target CPU.
+  * @drv: cpuidle driver (assumed to point to intel_idle_driver).
+  * @index: Target idle state index.
+  *
+  * Use the MWAIT instruction to notify the processor that the CPU represented by
+  * @dev is idle and it can try to enter the idle state corresponding to @index.
+  *
+  * Invoked as a suspend-to-idle callback routine with frozen user space, frozen
+  * scheduler tick and suspended scheduler clock on the target CPU.
+  */
+ static __cpuidle int intel_idle_s2idle(struct cpuidle_device *dev,
+ 				       struct cpuidle_driver *drv, int index)
+ {
+ 	unsigned long eax = flg2MWAIT(drv->states[index].flags);
+ 	unsigned long ecx = 1; /* break on interrupt flag */
+ 
+ 	mwait_idle_with_hints(eax, ecx);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> efe9711214e6 (cpuidle: change enter_s2idle() prototype)
  /*
   * States are indexed by the cstate number,
   * which is also the index into the MWAIT hint array.
diff --cc include/linux/cpuidle.h
index 57c6cc62bebc,b65909ae4e20..000000000000
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@@ -98,12 -65,13 +98,21 @@@ struct cpuidle_state 
  	 * CPUs execute ->enter_s2idle with the local tick or entire timekeeping
  	 * suspended, so it must not re-enable interrupts at any point (even
  	 * temporarily) or attempt to change states of clock event devices.
+ 	 *
+ 	 * This callback may point to the same function as ->enter if all of
+ 	 * the above requirements are met by it.
  	 */
++<<<<<<< HEAD
 +	void (*enter_s2idle) (struct cpuidle_device *dev,
 +			      struct cpuidle_driver *drv,
 +			      int index);
 +	RH_KABI_EXTEND(u64		exit_latency_ns)
 +	RH_KABI_EXTEND(u64		target_residency_ns)
++=======
+ 	int (*enter_s2idle)(struct cpuidle_device *dev,
+ 			    struct cpuidle_driver *drv,
+ 			    int index);
++>>>>>>> efe9711214e6 (cpuidle: change enter_s2idle() prototype)
  };
  
  /* Idle State Flags */
* Unmerged path drivers/cpuidle/cpuidle-tegra.c
diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index 344859467df1..3994f8235ad3 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -671,8 +671,8 @@ static int acpi_idle_enter(struct cpuidle_device *dev,
 	return index;
 }
 
-static void acpi_idle_enter_s2idle(struct cpuidle_device *dev,
-				   struct cpuidle_driver *drv, int index)
+static int acpi_idle_enter_s2idle(struct cpuidle_device *dev,
+				  struct cpuidle_driver *drv, int index)
 {
 	struct acpi_processor_cx *cx = per_cpu(acpi_cstate[index], dev->cpu);
 
@@ -690,6 +690,8 @@ static void acpi_idle_enter_s2idle(struct cpuidle_device *dev,
 		}
 	}
 	acpi_idle_do_entry(cx);
+
+	return 0;
 }
 
 static int acpi_processor_setup_cpuidle_cx(struct acpi_processor *pr,
* Unmerged path drivers/cpuidle/cpuidle-tegra.c
* Unmerged path drivers/idle/intel_idle.c
* Unmerged path include/linux/cpuidle.h
