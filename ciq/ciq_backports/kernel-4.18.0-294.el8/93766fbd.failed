vfs: syscall: Add fsmount() to create a mount for a superblock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 93766fbd2696c2c4453dd8e1070977e9cd4e6b6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/93766fbd.failed

Provide a system call by which a filesystem opened with fsopen() and
configured by a series of fsconfig() calls can have a detached mount object
created for it.  This mount object can then be attached to the VFS mount
hierarchy using move_mount() by passing the returned file descriptor as the
from directory fd.

The system call looks like:

	int mfd = fsmount(int fsfd, unsigned int flags,
			  unsigned int attr_flags);

where fsfd is the file descriptor returned by fsopen().  flags can be 0 or
FSMOUNT_CLOEXEC.  attr_flags is a bitwise-OR of the following flags:

	MOUNT_ATTR_RDONLY	Mount read-only
	MOUNT_ATTR_NOSUID	Ignore suid and sgid bits
	MOUNT_ATTR_NODEV	Disallow access to device special files
	MOUNT_ATTR_NOEXEC	Disallow program execution
	MOUNT_ATTR__ATIME	Setting on how atime should be updated
	MOUNT_ATTR_RELATIME	- Update atime relative to mtime/ctime
	MOUNT_ATTR_NOATIME	- Do not update access times
	MOUNT_ATTR_STRICTATIME	- Always perform atime updates
	MOUNT_ATTR_NODIRATIME	Do not update directory access times

In the event that fsmount() fails, it may be possible to get an error
message by calling read() on fsfd.  If no message is available, ENODATA
will be reported.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: linux-api@vger.kernel.org
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 93766fbd2696c2c4453dd8e1070977e9cd4e6b6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/syscalls/syscall_32.tbl
#	arch/x86/entry/syscalls/syscall_64.tbl
#	fs/namespace.c
#	include/linux/syscalls.h
#	include/uapi/linux/mount.h
diff --cc arch/x86/entry/syscalls/syscall_32.tbl
index 2eefd2a7c1ce,5b5c9189c507..000000000000
--- a/arch/x86/entry/syscalls/syscall_32.tbl
+++ b/arch/x86/entry/syscalls/syscall_32.tbl
@@@ -396,8 -396,45 +396,48 @@@
  382	i386	pkey_free		sys_pkey_free			__ia32_sys_pkey_free
  383	i386	statx			sys_statx			__ia32_sys_statx
  384	i386	arch_prctl		sys_arch_prctl			__ia32_compat_sys_arch_prctl
 -385	i386	io_pgetevents		sys_io_pgetevents_time32	__ia32_compat_sys_io_pgetevents
 +385	i386	io_pgetevents		sys_io_pgetevents		__ia32_compat_sys_io_pgetevents
  386	i386	rseq			sys_rseq			__ia32_sys_rseq
++<<<<<<< HEAD
++=======
+ 387	i386	open_tree		sys_open_tree			__ia32_sys_open_tree
+ 388	i386	move_mount		sys_move_mount			__ia32_sys_move_mount
+ 389	i386	fsopen			sys_fsopen			__ia32_sys_fsopen
+ 390	i386	fsconfig		sys_fsconfig			__ia32_sys_fsconfig
+ 391	i386	fsmount			sys_fsmount			__ia32_sys_fsmount
+ # don't use number 392, add new calls at the end
+ 393	i386	semget			sys_semget    			__ia32_sys_semget
+ 394	i386	semctl			sys_semctl    			__ia32_compat_sys_semctl
+ 395	i386	shmget			sys_shmget    			__ia32_sys_shmget
+ 396	i386	shmctl			sys_shmctl    			__ia32_compat_sys_shmctl
+ 397	i386	shmat			sys_shmat     			__ia32_compat_sys_shmat
+ 398	i386	shmdt			sys_shmdt     			__ia32_sys_shmdt
+ 399	i386	msgget			sys_msgget    			__ia32_sys_msgget
+ 400	i386	msgsnd			sys_msgsnd    			__ia32_compat_sys_msgsnd
+ 401	i386	msgrcv			sys_msgrcv    			__ia32_compat_sys_msgrcv
+ 402	i386	msgctl			sys_msgctl    			__ia32_compat_sys_msgctl
+ 403	i386	clock_gettime64		sys_clock_gettime		__ia32_sys_clock_gettime
+ 404	i386	clock_settime64		sys_clock_settime		__ia32_sys_clock_settime
+ 405	i386	clock_adjtime64		sys_clock_adjtime		__ia32_sys_clock_adjtime
+ 406	i386	clock_getres_time64	sys_clock_getres		__ia32_sys_clock_getres
+ 407	i386	clock_nanosleep_time64	sys_clock_nanosleep		__ia32_sys_clock_nanosleep
+ 408	i386	timer_gettime64		sys_timer_gettime		__ia32_sys_timer_gettime
+ 409	i386	timer_settime64		sys_timer_settime		__ia32_sys_timer_settime
+ 410	i386	timerfd_gettime64	sys_timerfd_gettime		__ia32_sys_timerfd_gettime
+ 411	i386	timerfd_settime64	sys_timerfd_settime		__ia32_sys_timerfd_settime
+ 412	i386	utimensat_time64	sys_utimensat			__ia32_sys_utimensat
+ 413	i386	pselect6_time64		sys_pselect6			__ia32_compat_sys_pselect6_time64
+ 414	i386	ppoll_time64		sys_ppoll			__ia32_compat_sys_ppoll_time64
+ 416	i386	io_pgetevents_time64	sys_io_pgetevents		__ia32_sys_io_pgetevents
+ 417	i386	recvmmsg_time64		sys_recvmmsg			__ia32_compat_sys_recvmmsg_time64
+ 418	i386	mq_timedsend_time64	sys_mq_timedsend		__ia32_sys_mq_timedsend
+ 419	i386	mq_timedreceive_time64	sys_mq_timedreceive		__ia32_sys_mq_timedreceive
+ 420	i386	semtimedop_time64	sys_semtimedop			__ia32_sys_semtimedop
+ 421	i386	rt_sigtimedwait_time64	sys_rt_sigtimedwait		__ia32_compat_sys_rt_sigtimedwait_time64
+ 422	i386	futex_time64		sys_futex			__ia32_sys_futex
+ 423	i386	sched_rr_get_interval_time64	sys_sched_rr_get_interval	__ia32_sys_sched_rr_get_interval
+ 424	i386	pidfd_send_signal	sys_pidfd_send_signal		__ia32_sys_pidfd_send_signal
++>>>>>>> 93766fbd2696 (vfs: syscall: Add fsmount() to create a mount for a superblock)
  425	i386	io_uring_setup		sys_io_uring_setup		__ia32_sys_io_uring_setup
  426	i386	io_uring_enter		sys_io_uring_enter		__ia32_sys_io_uring_enter
  427	i386	io_uring_register	sys_io_uring_register		__ia32_sys_io_uring_register
diff --cc arch/x86/entry/syscalls/syscall_64.tbl
index 65c026185e61,984ad594bb2b..000000000000
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@@ -343,6 -343,14 +343,17 @@@
  332	common	statx			__x64_sys_statx
  333	common	io_pgetevents		__x64_sys_io_pgetevents
  334	common	rseq			__x64_sys_rseq
++<<<<<<< HEAD
++=======
+ 335	common	open_tree		__x64_sys_open_tree
+ 336	common	move_mount		__x64_sys_move_mount
+ 337	common	fsopen			__x64_sys_fsopen
+ 338	common	fsconfig		__x64_sys_fsconfig
+ 339	common	fsmount			__x64_sys_fsmount
+ # don't use numbers 387 through 423, add new calls after the last
+ # 'common' entry
+ 424	common	pidfd_send_signal	__x64_sys_pidfd_send_signal
++>>>>>>> 93766fbd2696 (vfs: syscall: Add fsmount() to create a mount for a superblock)
  425	common	io_uring_setup		__x64_sys_io_uring_setup
  426	common	io_uring_enter		__x64_sys_io_uring_enter
  427	common	io_uring_register	__x64_sys_io_uring_register
diff --cc fs/namespace.c
index f136970f49f7,3357c3d65475..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -3094,6 -3334,203 +3094,206 @@@ SYSCALL_DEFINE5(mount, char __user *, d
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Create a kernel mount representation for a new, prepared superblock
+  * (specified by fs_fd) and attach to an open_tree-like file descriptor.
+  */
+ SYSCALL_DEFINE3(fsmount, int, fs_fd, unsigned int, flags,
+ 		unsigned int, attr_flags)
+ {
+ 	struct mnt_namespace *ns;
+ 	struct fs_context *fc;
+ 	struct file *file;
+ 	struct path newmount;
+ 	struct mount *mnt;
+ 	struct fd f;
+ 	unsigned int mnt_flags = 0;
+ 	long ret;
+ 
+ 	if (!may_mount())
+ 		return -EPERM;
+ 
+ 	if ((flags & ~(FSMOUNT_CLOEXEC)) != 0)
+ 		return -EINVAL;
+ 
+ 	if (attr_flags & ~(MOUNT_ATTR_RDONLY |
+ 			   MOUNT_ATTR_NOSUID |
+ 			   MOUNT_ATTR_NODEV |
+ 			   MOUNT_ATTR_NOEXEC |
+ 			   MOUNT_ATTR__ATIME |
+ 			   MOUNT_ATTR_NODIRATIME))
+ 		return -EINVAL;
+ 
+ 	if (attr_flags & MOUNT_ATTR_RDONLY)
+ 		mnt_flags |= MNT_READONLY;
+ 	if (attr_flags & MOUNT_ATTR_NOSUID)
+ 		mnt_flags |= MNT_NOSUID;
+ 	if (attr_flags & MOUNT_ATTR_NODEV)
+ 		mnt_flags |= MNT_NODEV;
+ 	if (attr_flags & MOUNT_ATTR_NOEXEC)
+ 		mnt_flags |= MNT_NOEXEC;
+ 	if (attr_flags & MOUNT_ATTR_NODIRATIME)
+ 		mnt_flags |= MNT_NODIRATIME;
+ 
+ 	switch (attr_flags & MOUNT_ATTR__ATIME) {
+ 	case MOUNT_ATTR_STRICTATIME:
+ 		break;
+ 	case MOUNT_ATTR_NOATIME:
+ 		mnt_flags |= MNT_NOATIME;
+ 		break;
+ 	case MOUNT_ATTR_RELATIME:
+ 		mnt_flags |= MNT_RELATIME;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	f = fdget(fs_fd);
+ 	if (!f.file)
+ 		return -EBADF;
+ 
+ 	ret = -EINVAL;
+ 	if (f.file->f_op != &fscontext_fops)
+ 		goto err_fsfd;
+ 
+ 	fc = f.file->private_data;
+ 
+ 	ret = mutex_lock_interruptible(&fc->uapi_mutex);
+ 	if (ret < 0)
+ 		goto err_fsfd;
+ 
+ 	/* There must be a valid superblock or we can't mount it */
+ 	ret = -EINVAL;
+ 	if (!fc->root)
+ 		goto err_unlock;
+ 
+ 	ret = -EPERM;
+ 	if (mount_too_revealing(fc->root->d_sb, &mnt_flags)) {
+ 		pr_warn("VFS: Mount too revealing\n");
+ 		goto err_unlock;
+ 	}
+ 
+ 	ret = -EBUSY;
+ 	if (fc->phase != FS_CONTEXT_AWAITING_MOUNT)
+ 		goto err_unlock;
+ 
+ 	ret = -EPERM;
+ 	if ((fc->sb_flags & SB_MANDLOCK) && !may_mandlock())
+ 		goto err_unlock;
+ 
+ 	newmount.mnt = vfs_create_mount(fc);
+ 	if (IS_ERR(newmount.mnt)) {
+ 		ret = PTR_ERR(newmount.mnt);
+ 		goto err_unlock;
+ 	}
+ 	newmount.dentry = dget(fc->root);
+ 	newmount.mnt->mnt_flags = mnt_flags;
+ 
+ 	/* We've done the mount bit - now move the file context into more or
+ 	 * less the same state as if we'd done an fspick().  We don't want to
+ 	 * do any memory allocation or anything like that at this point as we
+ 	 * don't want to have to handle any errors incurred.
+ 	 */
+ 	vfs_clean_context(fc);
+ 
+ 	ns = alloc_mnt_ns(current->nsproxy->mnt_ns->user_ns, true);
+ 	if (IS_ERR(ns)) {
+ 		ret = PTR_ERR(ns);
+ 		goto err_path;
+ 	}
+ 	mnt = real_mount(newmount.mnt);
+ 	mnt->mnt_ns = ns;
+ 	ns->root = mnt;
+ 	ns->mounts = 1;
+ 	list_add(&mnt->mnt_list, &ns->list);
+ 
+ 	/* Attach to an apparent O_PATH fd with a note that we need to unmount
+ 	 * it, not just simply put it.
+ 	 */
+ 	file = dentry_open(&newmount, O_PATH, fc->cred);
+ 	if (IS_ERR(file)) {
+ 		dissolve_on_fput(newmount.mnt);
+ 		ret = PTR_ERR(file);
+ 		goto err_path;
+ 	}
+ 	file->f_mode |= FMODE_NEED_UNMOUNT;
+ 
+ 	ret = get_unused_fd_flags((flags & FSMOUNT_CLOEXEC) ? O_CLOEXEC : 0);
+ 	if (ret >= 0)
+ 		fd_install(ret, file);
+ 	else
+ 		fput(file);
+ 
+ err_path:
+ 	path_put(&newmount);
+ err_unlock:
+ 	mutex_unlock(&fc->uapi_mutex);
+ err_fsfd:
+ 	fdput(f);
+ 	return ret;
+ }
+ 
+ /*
+  * Move a mount from one place to another.  In combination with
+  * fsopen()/fsmount() this is used to install a new mount and in combination
+  * with open_tree(OPEN_TREE_CLONE [| AT_RECURSIVE]) it can be used to copy
+  * a mount subtree.
+  *
+  * Note the flags value is a combination of MOVE_MOUNT_* flags.
+  */
+ SYSCALL_DEFINE5(move_mount,
+ 		int, from_dfd, const char *, from_pathname,
+ 		int, to_dfd, const char *, to_pathname,
+ 		unsigned int, flags)
+ {
+ 	struct path from_path, to_path;
+ 	unsigned int lflags;
+ 	int ret = 0;
+ 
+ 	if (!may_mount())
+ 		return -EPERM;
+ 
+ 	if (flags & ~MOVE_MOUNT__MASK)
+ 		return -EINVAL;
+ 
+ 	/* If someone gives a pathname, they aren't permitted to move
+ 	 * from an fd that requires unmount as we can't get at the flag
+ 	 * to clear it afterwards.
+ 	 */
+ 	lflags = 0;
+ 	if (flags & MOVE_MOUNT_F_SYMLINKS)	lflags |= LOOKUP_FOLLOW;
+ 	if (flags & MOVE_MOUNT_F_AUTOMOUNTS)	lflags |= LOOKUP_AUTOMOUNT;
+ 	if (flags & MOVE_MOUNT_F_EMPTY_PATH)	lflags |= LOOKUP_EMPTY;
+ 
+ 	ret = user_path_at(from_dfd, from_pathname, lflags, &from_path);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	lflags = 0;
+ 	if (flags & MOVE_MOUNT_T_SYMLINKS)	lflags |= LOOKUP_FOLLOW;
+ 	if (flags & MOVE_MOUNT_T_AUTOMOUNTS)	lflags |= LOOKUP_AUTOMOUNT;
+ 	if (flags & MOVE_MOUNT_T_EMPTY_PATH)	lflags |= LOOKUP_EMPTY;
+ 
+ 	ret = user_path_at(to_dfd, to_pathname, lflags, &to_path);
+ 	if (ret < 0)
+ 		goto out_from;
+ 
+ 	ret = security_move_mount(&from_path, &to_path);
+ 	if (ret < 0)
+ 		goto out_to;
+ 
+ 	ret = do_move_mount(&from_path, &to_path);
+ 
+ out_to:
+ 	path_put(&to_path);
+ out_from:
+ 	path_put(&from_path);
+ 	return ret;
+ }
+ 
+ /*
++>>>>>>> 93766fbd2696 (vfs: syscall: Add fsmount() to create a mount for a superblock)
   * Return true if path is reachable from root
   *
   * namespace_sem or mount_lock is held
diff --cc include/linux/syscalls.h
index ed03cace6180,0e697f595278..000000000000
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@@ -914,6 -985,17 +914,20 @@@ asmlinkage long sys_statx(int dfd, cons
  			  unsigned mask, struct statx __user *buffer);
  asmlinkage long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len,
  			 int flags, uint32_t sig);
++<<<<<<< HEAD
++=======
+ asmlinkage long sys_open_tree(int dfd, const char __user *path, unsigned flags);
+ asmlinkage long sys_move_mount(int from_dfd, const char __user *from_path,
+ 			       int to_dfd, const char __user *to_path,
+ 			       unsigned int ms_flags);
+ asmlinkage long sys_fsopen(const char __user *fs_name, unsigned int flags);
+ asmlinkage long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key,
+ 			     const void __user *value, int aux);
+ asmlinkage long sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);
+ asmlinkage long sys_pidfd_send_signal(int pidfd, int sig,
+ 				       siginfo_t __user *info,
+ 				       unsigned int flags);
++>>>>>>> 93766fbd2696 (vfs: syscall: Add fsmount() to create a mount for a superblock)
  
  /*
   * Architecture-specific system calls
* Unmerged path include/uapi/linux/mount.h
* Unmerged path arch/x86/entry/syscalls/syscall_32.tbl
* Unmerged path arch/x86/entry/syscalls/syscall_64.tbl
* Unmerged path fs/namespace.c
* Unmerged path include/linux/syscalls.h
* Unmerged path include/uapi/linux/mount.h
