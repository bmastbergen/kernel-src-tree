ibmvnic: Ensure that device queue memory is cache-line aligned

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Dwip N. Banerjee <dnbanerg@us.ibm.com>
commit 9a87c3fca2372af3177cb454c7aa381c7080307f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9a87c3fc.failed

PCI bus slowdowns were observed on IBM VNIC devices as a result
of partial cache line writes and non-cache aligned full cache line writes.
Ensure that packet data buffers are cache-line aligned to avoid these
slowdowns.

	Signed-off-by: Dwip N. Banerjee <dnbanerg@us.ibm.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 9a87c3fca2372af3177cb454c7aa381c7080307f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 3e289ed5bc66,85df91c9861b..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -511,9 -496,9 +511,13 @@@ static int reset_rx_pools(struct ibmvni
  
  		netdev_dbg(adapter->netdev, "Re-setting rx_pool[%d]\n", i);
  
 -		if (rx_pool->buff_size != buff_size) {
 +		if (rx_pool->buff_size != be64_to_cpu(size_array[i])) {
  			free_long_term_buff(adapter, &rx_pool->long_term_buff);
++<<<<<<< HEAD
 +			rx_pool->buff_size = be64_to_cpu(size_array[i]);
++=======
+ 			rx_pool->buff_size = ALIGN(buff_size, L1_CACHE_BYTES);
++>>>>>>> 9a87c3fca237 (ibmvnic: Ensure that device queue memory is cache-line aligned)
  			rc = alloc_long_term_buff(adapter,
  						  &rx_pool->long_term_buff,
  						  rx_pool->size *
@@@ -609,7 -592,7 +613,11 @@@ static int init_rx_pools(struct net_dev
  
  		rx_pool->size = adapter->req_rx_add_entries_per_subcrq;
  		rx_pool->index = i;
++<<<<<<< HEAD
 +		rx_pool->buff_size = be64_to_cpu(size_array[i]);
++=======
+ 		rx_pool->buff_size = ALIGN(buff_size, L1_CACHE_BYTES);
++>>>>>>> 9a87c3fca237 (ibmvnic: Ensure that device queue memory is cache-line aligned)
  		rx_pool->active = 1;
  
  		rx_pool->free_map = kcalloc(rx_pool->size, sizeof(int),
@@@ -762,9 -745,10 +770,10 @@@ static int init_tx_pools(struct net_dev
  {
  	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
  	int tx_subcrqs;
+ 	u64 buff_size;
  	int i, rc;
  
 -	tx_subcrqs = adapter->num_active_tx_scrqs;
 +	tx_subcrqs = be32_to_cpu(adapter->login_rsp_buf->num_txsubm_subcrqs);
  	adapter->tx_pool = kcalloc(tx_subcrqs,
  				   sizeof(struct ibmvnic_tx_pool), GFP_KERNEL);
  	if (!adapter->tx_pool)
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
diff --git a/drivers/net/ethernet/ibm/ibmvnic.h b/drivers/net/ethernet/ibm/ibmvnic.h
index d5d2bbccb162..d6010a817ddf 100644
--- a/drivers/net/ethernet/ibm/ibmvnic.h
+++ b/drivers/net/ethernet/ibm/ibmvnic.h
@@ -894,7 +894,7 @@ struct ibmvnic_sub_crq_queue {
 	atomic_t used;
 	char name[32];
 	u64 handle;
-};
+} ____cacheline_aligned;
 
 struct ibmvnic_long_term_buff {
 	unsigned char *buff;
@@ -918,7 +918,7 @@ struct ibmvnic_tx_pool {
 	struct ibmvnic_long_term_buff long_term_buff;
 	int num_buffers;
 	int buf_size;
-};
+} ____cacheline_aligned;
 
 struct ibmvnic_rx_buff {
 	struct sk_buff *skb;
@@ -939,7 +939,7 @@ struct ibmvnic_rx_pool {
 	int next_alloc;
 	int active;
 	struct ibmvnic_long_term_buff long_term_buff;
-};
+} ____cacheline_aligned;
 
 struct ibmvnic_vpd {
 	unsigned char *buff;
@@ -1026,8 +1026,8 @@ struct ibmvnic_adapter {
 	atomic_t running_cap_crqs;
 	bool wait_capability;
 
-	struct ibmvnic_sub_crq_queue **tx_scrq;
-	struct ibmvnic_sub_crq_queue **rx_scrq;
+	struct ibmvnic_sub_crq_queue **tx_scrq ____cacheline_aligned;
+	struct ibmvnic_sub_crq_queue **rx_scrq ____cacheline_aligned;
 
 	/* rx structs */
 	struct napi_struct *napi;
