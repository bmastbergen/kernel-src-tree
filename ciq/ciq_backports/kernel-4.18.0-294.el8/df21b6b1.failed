nvme: create helper function to obtain command effects

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Logan Gunthorpe <logang@deltatee.com>
commit df21b6b1934e89c2cc2bb1332146ed6c2df1321c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/df21b6b1.failed

Separate the code to obtain command effects from the code
to start a passthru request and move the nvme_passthru_start() and
nvme_passthru_end() functions up above nvme_submit_user_cmd() in order
that they may be used in a new helper a subsequent patch.

The new helper function will be necessary for nvmet passthru
code to determine if we need to change out of interrupt context
to handle the effects. It is exported in the NVME_TARGET_PASSTHRU
namespace.

	Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
	Reviewed-by: Keith Busch <kbusch@kernel.org>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit df21b6b1934e89c2cc2bb1332146ed6c2df1321c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index f58cc90f5be8,ab040eef83e7..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1396,89 -1494,6 +1496,92 @@@ static int nvme_submit_io(struct nvme_n
  			metadata, meta_len, lower_32_bits(io.slba), NULL, 0);
  }
  
++<<<<<<< HEAD
 +static u32 nvme_known_admin_effects(u8 opcode)
 +{
 +	switch (opcode) {
 +	case nvme_admin_format_nvm:
 +		return NVME_CMD_EFFECTS_CSUPP | NVME_CMD_EFFECTS_LBCC |
 +					NVME_CMD_EFFECTS_CSE_MASK;
 +	case nvme_admin_sanitize_nvm:
 +		return NVME_CMD_EFFECTS_CSE_MASK;
 +	default:
 +		break;
 +	}
 +	return 0;
 +}
 +
 +static u32 nvme_passthru_start(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
 +								u8 opcode)
 +{
 +	u32 effects = 0;
 +
 +	if (ns) {
 +		if (ns->head->effects)
 +			effects = le32_to_cpu(ns->head->effects->iocs[opcode]);
 +		if (effects & ~(NVME_CMD_EFFECTS_CSUPP | NVME_CMD_EFFECTS_LBCC))
 +			dev_warn(ctrl->device,
 +				 "IO command:%02x has unhandled effects:%08x\n",
 +				 opcode, effects);
 +		return 0;
 +	}
 +
 +	if (ctrl->effects)
 +		effects = le32_to_cpu(ctrl->effects->acs[opcode]);
 +	effects |= nvme_known_admin_effects(opcode);
 +
 +	/*
 +	 * For simplicity, IO to all namespaces is quiesced even if the command
 +	 * effects say only one namespace is affected.
 +	 */
 +	if (effects & (NVME_CMD_EFFECTS_LBCC | NVME_CMD_EFFECTS_CSE_MASK)) {
 +		mutex_lock(&ctrl->scan_lock);
 +		mutex_lock(&ctrl->subsys->lock);
 +		nvme_mpath_start_freeze(ctrl->subsys);
 +		nvme_mpath_wait_freeze(ctrl->subsys);
 +		nvme_start_freeze(ctrl);
 +		nvme_wait_freeze(ctrl);
 +	}
 +	return effects;
 +}
 +
 +static void nvme_update_formats(struct nvme_ctrl *ctrl)
 +{
 +	struct nvme_ns *ns;
 +
 +	down_read(&ctrl->namespaces_rwsem);
 +	list_for_each_entry(ns, &ctrl->namespaces, list)
 +		if (ns->disk && nvme_revalidate_disk(ns->disk))
 +			nvme_set_queue_dying(ns);
 +	up_read(&ctrl->namespaces_rwsem);
 +}
 +
 +static void nvme_passthru_end(struct nvme_ctrl *ctrl, u32 effects)
 +{
 +	/*
 +	 * Revalidate LBA changes prior to unfreezing. This is necessary to
 +	 * prevent memory corruption if a logical block size was changed by
 +	 * this command.
 +	 */
 +	if (effects & NVME_CMD_EFFECTS_LBCC)
 +		nvme_update_formats(ctrl);
 +	if (effects & (NVME_CMD_EFFECTS_LBCC | NVME_CMD_EFFECTS_CSE_MASK)) {
 +		nvme_unfreeze(ctrl);
 +		nvme_mpath_unfreeze(ctrl->subsys);
 +		mutex_unlock(&ctrl->subsys->lock);
 +		nvme_remove_invalid_namespaces(ctrl, NVME_NSID_ALL);
 +		mutex_unlock(&ctrl->scan_lock);
 +	}
 +	if (effects & NVME_CMD_EFFECTS_CCC)
 +		nvme_init_identify(ctrl);
 +	if (effects & (NVME_CMD_EFFECTS_NIC | NVME_CMD_EFFECTS_NCC)) {
 +		nvme_queue_scan(ctrl);
 +		flush_work(&ctrl->scan_work);
 +	}
 +}
 +
++=======
++>>>>>>> df21b6b1934e (nvme: create helper function to obtain command effects)
  static int nvme_user_cmd(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
  			struct nvme_passthru_cmd __user *ucmd)
  {
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index f0db86ea8aa0..05ab52219b1e 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -778,4 +778,7 @@ void nvme_hwmon_init(struct nvme_ctrl *ctrl);
 static inline void nvme_hwmon_init(struct nvme_ctrl *ctrl) { }
 #endif
 
+u32 nvme_command_effects(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
+			 u8 opcode);
+
 #endif /* _NVME_H */
