kunit: add support for named resources

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Alan Maguire <alan.maguire@oracle.com>
commit 725aca9585956676687c4cb803e88f770b0df2b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/725aca95.failed

The kunit resources API allows for custom initialization and
cleanup code (init/fini); here a new resource add function sets
the "struct kunit_resource" "name" field, and calls the standard
add function.  Having a simple way to name resources is
useful in cases such as multithreaded tests where a set of
resources are shared among threads; a pointer to the
"struct kunit *" test state then is all that is needed to
retrieve and use named resources.  Support is provided to add,
find and destroy named resources; the latter two are simply
wrappers that use a "match-by-name" callback.

If an attempt to add a resource with a name that already exists
is made kunit_add_named_resource() will return -EEXIST.

	Signed-off-by: Alan Maguire <alan.maguire@oracle.com>
	Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
	Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
(cherry picked from commit 725aca9585956676687c4cb803e88f770b0df2b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/kunit/test.h
#	lib/kunit/test-test.c
diff --cc include/kunit/test.h
index dba48304b3bd,59f3144f009a..000000000000
--- a/include/kunit/test.h
+++ b/include/kunit/test.h
@@@ -62,19 -69,22 +62,29 @@@ typedef void (*kunit_resource_free_t)(s
   *		params.size = size;
   *		params.gfp = gfp;
   *
 - *		return kunit_alloc_resource(test, kunit_kmalloc_init,
 + *		res = kunit_alloc_resource(test, kunit_kmalloc_init,
   *			kunit_kmalloc_free, &params);
 + *		if (res)
 + *			return res->allocation;
 + *
 + *		return NULL;
   *	}
+  *
+  * Resources can also be named, with lookup/removal done on a name
+  * basis also.  kunit_add_named_resource(), kunit_find_named_resource()
+  * and kunit_destroy_named_resource().  Resource names must be
+  * unique within the test instance.
   */
  struct kunit_resource {
++<<<<<<< HEAD
 +	void *allocation;
 +	kunit_resource_free_t free;
++=======
+ 	void *data;
+ 	const char *name;		/* optional name */
++>>>>>>> 725aca958595 (kunit: add support for named resources)
  
  	/* private: internal use only. */
 -	kunit_resource_free_t free;
 -	struct kref refcount;
  	struct list_head node;
  };
  
@@@ -234,6 -293,79 +244,82 @@@ struct kunit_resource *kunit_alloc_and_
  						    void *context);
  
  /**
++<<<<<<< HEAD
++=======
+  * kunit_get_resource() - Hold resource for use.  Should not need to be used
+  *			  by most users as we automatically get resources
+  *			  retrieved by kunit_find_resource*().
+  * @res: resource
+  */
+ static inline void kunit_get_resource(struct kunit_resource *res)
+ {
+ 	kref_get(&res->refcount);
+ }
+ 
+ /*
+  * Called when refcount reaches zero via kunit_put_resources();
+  * should not be called directly.
+  */
+ static inline void kunit_release_resource(struct kref *kref)
+ {
+ 	struct kunit_resource *res = container_of(kref, struct kunit_resource,
+ 						  refcount);
+ 
+ 	/* If free function is defined, resource was dynamically allocated. */
+ 	if (res->free) {
+ 		res->free(res);
+ 		kfree(res);
+ 	}
+ }
+ 
+ /**
+  * kunit_put_resource() - When caller is done with retrieved resource,
+  *			  kunit_put_resource() should be called to drop
+  *			  reference count.  The resource list maintains
+  *			  a reference count on resources, so if no users
+  *			  are utilizing a resource and it is removed from
+  *			  the resource list, it will be freed via the
+  *			  associated free function (if any).  Only
+  *			  needs to be used if we alloc_and_get() or
+  *			  find() resource.
+  * @res: resource
+  */
+ static inline void kunit_put_resource(struct kunit_resource *res)
+ {
+ 	kref_put(&res->refcount, kunit_release_resource);
+ }
+ 
+ /**
+  * kunit_add_resource() - Add a *test managed resource*.
+  * @test: The test context object.
+  * @init: a user-supplied function to initialize the result (if needed).  If
+  *        none is supplied, the resource data value is simply set to @data.
+  *	  If an init function is supplied, @data is passed to it instead.
+  * @free: a user-supplied function to free the resource (if needed).
+  * @data: value to pass to init function or set in resource data field.
+  */
+ int kunit_add_resource(struct kunit *test,
+ 		       kunit_resource_init_t init,
+ 		       kunit_resource_free_t free,
+ 		       struct kunit_resource *res,
+ 		       void *data);
+ 
+ /**
+  * kunit_add_named_resource() - Add a named *test managed resource*.
+  * @test: The test context object.
+  * @init: a user-supplied function to initialize the resource data, if needed.
+  * @free: a user-supplied function to free the resource data, if needed.
+  * @name_data: name and data to be set for resource.
+  */
+ int kunit_add_named_resource(struct kunit *test,
+ 			     kunit_resource_init_t init,
+ 			     kunit_resource_free_t free,
+ 			     struct kunit_resource *res,
+ 			     const char *name,
+ 			     void *data);
+ 
+ /**
++>>>>>>> 725aca958595 (kunit: add support for named resources)
   * kunit_alloc_resource() - Allocates a *test managed resource*.
   * @test: The test context object.
   * @init: a user supplied function to initialize the resource.
@@@ -287,24 -420,91 +373,89 @@@ static inline bool kunit_resource_insta
  }
  
  /**
++<<<<<<< HEAD
 + * kunit_resource_destroy() - Find a kunit_resource and destroy it.
++=======
+  * kunit_resource_name_match() - Match a resource with the same name.
+  * @test: Test case to which the resource belongs.
+  * @res: The resource.
+  * @match_name: The name to match against.
+  */
+ static inline bool kunit_resource_name_match(struct kunit *test,
+ 					     struct kunit_resource *res,
+ 					     void *match_name)
+ {
+ 	return res->name && strcmp(res->name, match_name) == 0;
+ }
+ 
+ /**
+  * kunit_find_resource() - Find a resource using match function/data.
+  * @test: Test case to which the resource belongs.
+  * @match: match function to be applied to resources/match data.
+  * @match_data: data to be used in matching.
+  */
+ static inline struct kunit_resource *
+ kunit_find_resource(struct kunit *test,
+ 		    kunit_resource_match_t match,
+ 		    void *match_data)
+ {
+ 	struct kunit_resource *res, *found = NULL;
+ 
+ 	spin_lock(&test->lock);
+ 
+ 	list_for_each_entry_reverse(res, &test->resources, node) {
+ 		if (match(test, res, (void *)match_data)) {
+ 			found = res;
+ 			kunit_get_resource(found);
+ 			break;
+ 		}
+ 	}
+ 
+ 	spin_unlock(&test->lock);
+ 
+ 	return found;
+ }
+ 
+ /**
+  * kunit_find_named_resource() - Find a resource using match name.
+  * @test: Test case to which the resource belongs.
+  * @name: match name.
+  */
+ static inline struct kunit_resource *
+ kunit_find_named_resource(struct kunit *test,
+ 			  const char *name)
+ {
+ 	return kunit_find_resource(test, kunit_resource_name_match,
+ 				   (void *)name);
+ }
+ 
+ /**
+  * kunit_destroy_resource() - Find a kunit_resource and destroy it.
++>>>>>>> 725aca958595 (kunit: add support for named resources)
   * @test: Test case to which the resource belongs.
   * @match: Match function. Returns whether a given resource matches @match_data.
 + * @free: Must match free on the kunit_resource to free.
   * @match_data: Data passed into @match.
   *
 + * Free the latest kunit_resource of @test for which @free matches the
 + * kunit_resource_free_t associated with the resource and for which @match
 + * returns true.
 + *
   * RETURNS:
   * 0 if kunit_resource is found and freed, -ENOENT if not found.
   */
 -int kunit_destroy_resource(struct kunit *test,
 +int kunit_resource_destroy(struct kunit *test,
  			   kunit_resource_match_t match,
 +			   kunit_resource_free_t free,
  			   void *match_data);
  
+ static inline int kunit_destroy_named_resource(struct kunit *test,
+ 					       const char *name)
+ {
+ 	return kunit_destroy_resource(test, kunit_resource_name_match,
+ 				      (void *)name);
+ }
+ 
 -/**
 - * kunit_remove_resource: remove resource from resource list associated with
 - *			  test.
 - * @test: The test context object.
 - * @res: The resource to be removed.
 - *
 - * Note that the resource will not be immediately freed since it is likely
 - * the caller has a reference to it via alloc_and_get() or find();
 - * in this case a final call to kunit_put_resource() is required.
 - */
 -void kunit_remove_resource(struct kunit *test, struct kunit_resource *res);
 -
  /**
   * kunit_kmalloc() - Like kmalloc() except the allocation is *test managed*.
   * @test: The test context object.
diff --cc lib/kunit/test-test.c
index 5a6cc0484eda,69f902440a0e..000000000000
--- a/lib/kunit/test-test.c
+++ b/lib/kunit/test-test.c
@@@ -293,6 -310,57 +293,60 @@@ static void kunit_resource_test_proper_
  	KUNIT_EXPECT_EQ(test, ctx->free_order[1], 2);
  }
  
++<<<<<<< HEAD:lib/kunit/test-test.c
++=======
+ static void kunit_resource_test_static(struct kunit *test)
+ {
+ 	struct kunit_test_resource_context ctx;
+ 	struct kunit_resource res;
+ 
+ 	KUNIT_EXPECT_EQ(test, kunit_add_resource(test, NULL, NULL, &res, &ctx),
+ 			0);
+ 
+ 	KUNIT_EXPECT_PTR_EQ(test, res.data, (void *)&ctx);
+ 
+ 	kunit_cleanup(test);
+ 
+ 	KUNIT_EXPECT_TRUE(test, list_empty(&test->resources));
+ }
+ 
+ static void kunit_resource_test_named(struct kunit *test)
+ {
+ 	struct kunit_resource res1, res2, *found = NULL;
+ 	struct kunit_test_resource_context ctx;
+ 
+ 	KUNIT_EXPECT_EQ(test,
+ 			kunit_add_named_resource(test, NULL, NULL, &res1,
+ 						 "resource_1", &ctx),
+ 			0);
+ 	KUNIT_EXPECT_PTR_EQ(test, res1.data, (void *)&ctx);
+ 
+ 	KUNIT_EXPECT_EQ(test,
+ 			kunit_add_named_resource(test, NULL, NULL, &res1,
+ 						 "resource_1", &ctx),
+ 			-EEXIST);
+ 
+ 	KUNIT_EXPECT_EQ(test,
+ 			kunit_add_named_resource(test, NULL, NULL, &res2,
+ 						 "resource_2", &ctx),
+ 			0);
+ 
+ 	found = kunit_find_named_resource(test, "resource_1");
+ 
+ 	KUNIT_EXPECT_PTR_EQ(test, found, &res1);
+ 
+ 	if (found)
+ 		kunit_put_resource(&res1);
+ 
+ 	KUNIT_EXPECT_EQ(test, kunit_destroy_named_resource(test, "resource_2"),
+ 			0);
+ 
+ 	kunit_cleanup(test);
+ 
+ 	KUNIT_EXPECT_TRUE(test, list_empty(&test->resources));
+ }
+ 
++>>>>>>> 725aca958595 (kunit: add support for named resources):lib/kunit/kunit-test.c
  static int kunit_resource_test_init(struct kunit *test)
  {
  	struct kunit_test_resource_context *ctx =
@@@ -321,6 -389,8 +375,11 @@@ static struct kunit_case kunit_resource
  	KUNIT_CASE(kunit_resource_test_destroy_resource),
  	KUNIT_CASE(kunit_resource_test_cleanup_resources),
  	KUNIT_CASE(kunit_resource_test_proper_free_ordering),
++<<<<<<< HEAD:lib/kunit/test-test.c
++=======
+ 	KUNIT_CASE(kunit_resource_test_static),
+ 	KUNIT_CASE(kunit_resource_test_named),
++>>>>>>> 725aca958595 (kunit: add support for named resources):lib/kunit/kunit-test.c
  	{}
  };
  
* Unmerged path include/kunit/test.h
* Unmerged path lib/kunit/test-test.c
diff --git a/lib/kunit/test.c b/lib/kunit/test.c
index 58a6227bb12c..396894a61382 100644
--- a/lib/kunit/test.c
+++ b/lib/kunit/test.c
@@ -320,6 +320,30 @@ int kunit_run_tests(struct kunit_suite *suite)
 	return 0;
 }
 
+int kunit_add_named_resource(struct kunit *test,
+			     kunit_resource_init_t init,
+			     kunit_resource_free_t free,
+			     struct kunit_resource *res,
+			     const char *name,
+			     void *data)
+{
+	struct kunit_resource *existing;
+
+	if (!name)
+		return -EINVAL;
+
+	existing = kunit_find_named_resource(test, name);
+	if (existing) {
+		kunit_put_resource(existing);
+		return -EEXIST;
+	}
+
+	res->name = name;
+
+	return kunit_add_resource(test, init, free, res, data);
+}
+EXPORT_SYMBOL_GPL(kunit_add_named_resource);
+
 struct kunit_resource *kunit_alloc_and_get_resource(struct kunit *test,
 						    kunit_resource_init_t init,
 						    kunit_resource_free_t free,
