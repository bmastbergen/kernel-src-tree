NFS: Don't hard-code the fs_type when submounting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Scott Mayhew <smayhew@redhat.com>
commit 1821b26a1fed8fca57a96ef87bac7a6a48e78815
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1821b26a.failed

Hard-coding the fstype causes "nfs4" mounts to appear as "nfs",
which breaks scripts that do "umount -at nfs4".

	Reported-by: Patrick Steinhardt <ps@pks.im>
Fixes: f2aedb713c28 ("NFS: Add fs_context support.")
	Signed-off-by: Scott Mayhew <smayhew@redhat.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 1821b26a1fed8fca57a96ef87bac7a6a48e78815)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/namespace.c
diff --cc fs/nfs/namespace.c
index 0dbf0e798502,f3ece8ed3203..000000000000
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@@ -148,26 -150,55 +148,35 @@@ struct vfsmount *nfs_d_automount(struc
  	if (IS_ROOT(path->dentry))
  		return ERR_PTR(-ESTALE);
  
++<<<<<<< HEAD
 +	mnt = ERR_PTR(-ENOMEM);
 +	fh = nfs_alloc_fhandle();
 +	fattr = nfs_alloc_fattr();
 +	if (fh == NULL || fattr == NULL)
 +		goto out;
++=======
+ 	/* Open a new filesystem context, transferring parameters from the
+ 	 * parent superblock, including the network namespace.
+ 	 */
+ 	fc = fs_context_for_submount(path->mnt->mnt_sb->s_type, path->dentry);
+ 	if (IS_ERR(fc))
+ 		return ERR_CAST(fc);
++>>>>>>> 1821b26a1fed (NFS: Don't hard-code the fs_type when submounting)
  
 -	ctx = nfs_fc2context(fc);
 -	ctx->clone_data.dentry	= path->dentry;
 -	ctx->clone_data.sb	= path->dentry->d_sb;
 -	ctx->clone_data.fattr	= nfs_alloc_fattr();
 -	if (!ctx->clone_data.fattr)
 -		goto out_fc;
 -
 -	if (fc->net_ns != client->cl_net) {
 -		put_net(fc->net_ns);
 -		fc->net_ns = get_net(client->cl_net);
 -	}
 -
 -	/* for submounts we want the same server; referrals will reassign */
 -	memcpy(&ctx->nfs_server.address, &client->cl_addr, client->cl_addrlen);
 -	ctx->nfs_server.addrlen	= client->cl_addrlen;
 -	ctx->nfs_server.port	= server->port;
 -
 -	ctx->version		= client->rpc_ops->version;
 -	ctx->minorversion	= client->cl_minorversion;
 -	ctx->nfs_mod		= client->cl_nfs_mod;
 -	__module_get(ctx->nfs_mod->owner);
 -
 -	ret = client->rpc_ops->submount(fc, server);
 -	if (ret < 0) {
 -		mnt = ERR_PTR(ret);
 -		goto out_fc;
 -	}
 -
 -	up_write(&fc->root->d_sb->s_umount);
 -	mnt = vfs_create_mount(fc);
 +	mnt = server->nfs_client->rpc_ops->submount(server, path->dentry, fh, fattr);
  	if (IS_ERR(mnt))
 -		goto out_fc;
 -
 -	if (nfs_mountpoint_expiry_timeout < 0)
 -		goto out_fc;
 +		goto out;
  
  	mntget(mnt); /* prevent immediate expiration */
 +	if (timeout <= 0)
 +		goto out;
 +
  	mnt_set_expiry(mnt, &nfs_automount_list);
 -	schedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);
 +	schedule_delayed_work(&nfs_automount_task, timeout);
  
 -out_fc:
 -	put_fs_context(fc);
 +out:
 +	nfs_free_fattr(fattr);
 +	nfs_free_fhandle(fh);
  	return mnt;
  }
  
* Unmerged path fs/nfs/namespace.c
