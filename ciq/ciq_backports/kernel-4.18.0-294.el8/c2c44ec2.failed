Unbreak mount_capable()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit c2c44ec20a8496f7a3b3401c092afe96908eced1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c2c44ec2.failed

In "consolidate the capability checks in sget_{fc,userns}())" the
wrong argument had been passed to mount_capable() by sget_fc().
That mistake had been further obscured later, when switching
mount_capable() to fs_context has moved the calculation of
bogus argument from sget_fc() to mount_capable() itself.  It
should've been fc->user_ns all along.

Screwed-up-by: Al Viro <viro@zeniv.linux.org.uk>
	Reported-by: Christian Brauner <christian@brauner.io>
	Tested-by: Christian Brauner <christian@brauner.io>
	Reviewed-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit c2c44ec20a8496f7a3b3401c092afe96908eced1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/super.c
diff --cc fs/super.c
index 308bc64e0894,5960578a4076..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -478,20 -476,35 +478,31 @@@ void generic_shutdown_super(struct supe
  
  EXPORT_SYMBOL(generic_shutdown_super);
  
++<<<<<<< HEAD
++=======
+ bool mount_capable(struct fs_context *fc)
+ {
+ 	if (!(fc->fs_type->fs_flags & FS_USERNS_MOUNT))
+ 		return capable(CAP_SYS_ADMIN);
+ 	else
+ 		return ns_capable(fc->user_ns, CAP_SYS_ADMIN);
+ }
+ 
++>>>>>>> c2c44ec20a84 (Unbreak mount_capable())
  /**
 - * sget_fc - Find or create a superblock
 - * @fc:	Filesystem context.
 - * @test: Comparison callback
 - * @set: Setup callback
 - *
 - * Find or create a superblock using the parameters stored in the filesystem
 - * context and the two callback functions.
 - *
 - * If an extant superblock is matched, then that will be returned with an
 - * elevated reference count that the caller must transfer or discard.
 - *
 - * If no match is made, a new superblock will be allocated and basic
 - * initialisation will be performed (s_type, s_fs_info and s_id will be set and
 - * the set() callback will be invoked), the superblock will be published and it
 - * will be returned in a partially constructed state with SB_BORN and SB_ACTIVE
 - * as yet unset.
 + *	sget_userns -	find or create a superblock
 + *	@type:	filesystem type superblock should belong to
 + *	@test:	comparison callback
 + *	@set:	setup callback
 + *	@flags:	mount flags
 + *	@user_ns: User namespace for the super_block
 + *	@data:	argument to each of them
   */
 -struct super_block *sget_fc(struct fs_context *fc,
 -			    int (*test)(struct super_block *, struct fs_context *),
 -			    int (*set)(struct super_block *, struct fs_context *))
 +struct super_block *sget_userns(struct file_system_type *type,
 +			int (*test)(struct super_block *,void *),
 +			int (*set)(struct super_block *,void *),
 +			int flags, struct user_namespace *user_ns,
 +			void *data)
  {
  	struct super_block *s = NULL;
  	struct super_block *old;
* Unmerged path fs/super.c
