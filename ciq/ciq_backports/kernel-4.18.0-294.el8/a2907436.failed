net/mlx5e: kTLS, Improve rx handler function call

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Tariq Toukan <tariqt@mellanox.com>
commit a29074367b347af9e19d36522f7ad9a7db4b9c28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a2907436.failed

Prior to this patch mlx5e tls rx handler was called unconditionally on
all rx frames and the decision whether a frame is a valid tls record
is done inside that function.  A function call can be expensive especially
for regular rx packet rate.  To avoid this, check the tls validity before
jumping into the tls rx handler.

While at it, split between kTLS device offload rx handler and FPGA tls rx
handler using a similar method.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
(cherry picked from commit a29074367b347af9e19d36522f7ad9a7db4b9c28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.c
index 4d796fea906d,b0c31d49ff8d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.c
@@@ -354,15 -355,13 +354,24 @@@ out
  	return 0;
  }
  
++<<<<<<< HEAD
 +void mlx5e_tls_handle_rx_skb(struct net_device *netdev, struct sk_buff *skb,
 +			     u32 *cqe_bcnt)
++=======
+ /* FPGA tls rx handler */
+ void mlx5e_tls_handle_rx_skb_metadata(struct mlx5e_rq *rq, struct sk_buff *skb,
+ 				      u32 *cqe_bcnt)
++>>>>>>> a29074367b34 (net/mlx5e: kTLS, Improve rx handler function call)
  {
  	struct mlx5e_tls_metadata *mdata;
  	struct mlx5e_priv *priv;
  
++<<<<<<< HEAD
 +	if (!is_metadata_hdr_valid(skb))
 +		return;
 +
++=======
++>>>>>>> a29074367b34 (net/mlx5e: kTLS, Improve rx handler function call)
  	/* Use the metadata */
  	mdata = (struct mlx5e_tls_metadata *)(skb->data + ETH_HLEN);
  	switch (mdata->content.recv.syndrome) {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.h
index 2a7b98531539,5f162ad2ee8f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.h
@@@ -49,8 -50,19 +50,24 @@@ bool mlx5e_tls_handle_tx_skb(struct net
  void mlx5e_tls_handle_tx_wqe(struct mlx5e_txqsq *sq, struct mlx5_wqe_ctrl_seg *cseg,
  			     struct mlx5e_accel_tx_tls_state *state);
  
++<<<<<<< HEAD
 +void mlx5e_tls_handle_rx_skb(struct net_device *netdev, struct sk_buff *skb,
 +			     u32 *cqe_bcnt);
++=======
+ void mlx5e_tls_handle_rx_skb_metadata(struct mlx5e_rq *rq, struct sk_buff *skb,
+ 				      u32 *cqe_bcnt);
+ 
+ static inline void
+ mlx5e_tls_handle_rx_skb(struct mlx5e_rq *rq, struct sk_buff *skb,
+ 			struct mlx5_cqe64 *cqe, u32 *cqe_bcnt)
+ {
+ 	if (unlikely(get_cqe_tls_offload(cqe))) /* cqe bit indicates a TLS device */
+ 		return mlx5e_ktls_handle_rx_skb(rq, skb, cqe, cqe_bcnt);
+ 
+ 	if (unlikely(test_bit(MLX5E_RQ_STATE_FPGA_TLS, &rq->state) && is_metadata_hdr_valid(skb)))
+ 		return mlx5e_tls_handle_rx_skb_metadata(rq, skb, cqe_bcnt);
+ }
++>>>>>>> a29074367b34 (net/mlx5e: kTLS, Improve rx handler function call)
  
  #else
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index 81cdab92765f,8b42f729a4f7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@@ -978,12 -1019,7 +978,16 @@@ static inline void mlx5e_build_rx_skb(s
  
  	skb->mac_len = ETH_HLEN;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_MLX5_EN_TLS
 +	mlx5e_tls_handle_rx_skb(netdev, skb, &cqe_bcnt);
 +#endif
++=======
+ 	mlx5e_tls_handle_rx_skb(rq, skb, cqe, &cqe_bcnt);
++>>>>>>> a29074367b34 (net/mlx5e: kTLS, Improve rx handler function call)
 +
 +	if (unlikely(mlx5_ipsec_is_rx_flow(cqe)))
 +		mlx5e_ipsec_offload_handle_rx_skb(netdev, skb, cqe);
  
  	if (lro_num_seg > 1) {
  		mlx5e_lro_update_hdr(skb, cqe, cqe_bcnt);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 7220dce1dd10..abff2ce4357c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -269,6 +269,7 @@ enum {
 	MLX5E_RQ_STATE_AM,
 	MLX5E_RQ_STATE_NO_CSUM_COMPLETE,
 	MLX5E_RQ_STATE_CSUM_FULL, /* cqe_csum_full hw bit is set */
+	MLX5E_RQ_STATE_FPGA_TLS, /* FPGA TLS enabled */
 };
 
 struct mlx5e_cq {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/ktls_rx.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.h b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.h
index 9015f3f7792d..57680f470d60 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.h
@@ -86,6 +86,11 @@ mlx5e_get_tls_rx_context(struct tls_context *tls_ctx)
 			    base);
 }
 
+static inline bool mlx5e_is_tls_on(struct mlx5e_priv *priv)
+{
+	return priv->tls;
+}
+
 void mlx5e_tls_build_netdev(struct mlx5e_priv *priv);
 int mlx5e_tls_init(struct mlx5e_priv *priv);
 void mlx5e_tls_cleanup(struct mlx5e_priv *priv);
@@ -102,6 +107,7 @@ static inline void mlx5e_tls_build_netdev(struct mlx5e_priv *priv)
 		mlx5e_ktls_build_netdev(priv);
 }
 
+static inline bool mlx5e_is_tls_on(struct mlx5e_priv *priv) { return false; }
 static inline int mlx5e_tls_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tls_cleanup(struct mlx5e_priv *priv) { }
 static inline int mlx5e_tls_get_count(struct mlx5e_priv *priv) { return 0; }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls_rxtx.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 699ee34dbb3e..c1874288b200 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -940,6 +940,9 @@ int mlx5e_open_rq(struct mlx5e_channel *c, struct mlx5e_params *params,
 	if (err)
 		goto err_destroy_rq;
 
+	if (mlx5e_is_tls_on(c->priv) && !mlx5_accel_is_ktls_device(c->mdev))
+		__set_bit(MLX5E_RQ_STATE_FPGA_TLS, &c->rq.state); /* must be FPGA */
+
 	if (MLX5_CAP_ETH(c->mdev, cqe_checksum_full))
 		__set_bit(MLX5E_RQ_STATE_CSUM_FULL, &c->rq.state);
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
