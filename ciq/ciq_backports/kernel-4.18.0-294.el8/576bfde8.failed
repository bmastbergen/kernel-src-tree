scsi: qla2xxx: Add deferred queue for processing ABTS and RDP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Joe Carnuccio <joe.carnuccio@cavium.com>
commit 576bfde80b28232a1dfcf0466986ed2934146d0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/576bfde8.failed

This patch adds deferred queue for processing aborts and RDP in the driver.

Link: https://lore.kernel.org/r/20200212214436.25532-14-hmadhani@marvell.com
	Signed-off-by: Joe Carnuccio <joe.carnuccio@cavium.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 576bfde80b28232a1dfcf0466986ed2934146d0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_fw.h
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 1bb1c1480f00,17367639953c..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -4545,6 -4673,11 +4554,14 @@@ typedef struct scsi_qla_host 
  	uint16_t ql2xexchoffld;
  	uint16_t ql2xiniexchg;
  
++<<<<<<< HEAD
++=======
+ 	struct purex_list {
+ 		struct list_head head;
+ 		spinlock_t lock;
+ 	} purex_list;
+ 
++>>>>>>> 576bfde80b28 (scsi: qla2xxx: Add deferred queue for processing ABTS and RDP)
  	struct name_list_extended gnl;
  	/* Count of active session/fcport */
  	int fcport_count;
diff --cc drivers/scsi/qla2xxx/qla_fw.h
index 1a0aa2966d36,8af5bc4e2cc6..000000000000
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@@ -724,6 -724,48 +724,51 @@@ struct ct_entry_24xx 
  };
  
  /*
++<<<<<<< HEAD
++=======
+  * ISP queue - PUREX IOCB entry structure definition
+  */
+ #define PUREX_IOCB_TYPE		0x51	/* CT Pass Through IOCB entry */
+ struct purex_entry_24xx {
+ 	uint8_t entry_type;		/* Entry type. */
+ 	uint8_t entry_count;		/* Entry count. */
+ 	uint8_t sys_define;		/* System defined. */
+ 	uint8_t entry_status;		/* Entry Status. */
+ 
+ 	uint16_t reserved1;
+ 	uint8_t vp_idx;
+ 	uint8_t reserved2;
+ 
+ 	uint16_t status_flags;
+ 	uint16_t nport_handle;
+ 
+ 	uint16_t frame_size;
+ 	uint16_t trunc_frame_size;
+ 
+ 	uint32_t rx_xchg_addr;
+ 
+ 	uint8_t d_id[3];
+ 	uint8_t r_ctl;
+ 
+ 	uint8_t s_id[3];
+ 	uint8_t cs_ctl;
+ 
+ 	uint8_t f_ctl[3];
+ 	uint8_t type;
+ 
+ 	uint16_t seq_cnt;
+ 	uint8_t df_ctl;
+ 	uint8_t seq_id;
+ 
+ 	uint16_t rx_id;
+ 	uint16_t ox_id;
+ 	uint32_t param;
+ 
+ 	uint8_t els_frame_payload[20];
+ };
+ 
+ /*
++>>>>>>> 576bfde80b28 (scsi: qla2xxx: Add deferred queue for processing ABTS and RDP)
   * ISP queue - ELS Pass-Through entry structure definition.
   */
  #define ELS_IOCB_TYPE		0x53	/* ELS Pass-Through IOCB entry */
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 99385974dab1,cb40261158c9..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -31,6 -31,144 +31,147 @@@ const char *const port_state_str[] = 
  	"ONLINE"
  };
  
++<<<<<<< HEAD
++=======
+ static void qla24xx_purex_iocb(scsi_qla_host_t *vha, void *pkt,
+ 	void (*process_item)(struct scsi_qla_host *vha, void *pkt))
+ {
+ 	struct purex_list *list = &vha->purex_list;
+ 	struct purex_item *item;
+ 	ulong flags;
+ 
+ 	item = kzalloc(sizeof(*item), GFP_KERNEL);
+ 	if (!item) {
+ 		ql_log(ql_log_warn, vha, 0x5092,
+ 		    ">> Failed allocate purex list item.\n");
+ 		return;
+ 	}
+ 
+ 	item->vha = vha;
+ 	item->process_item = process_item;
+ 	memcpy(&item->iocb, pkt, sizeof(item->iocb));
+ 
+ 	spin_lock_irqsave(&list->lock, flags);
+ 	list_add_tail(&item->list, &list->head);
+ 	spin_unlock_irqrestore(&list->lock, flags);
+ 
+ 	set_bit(PROCESS_PUREX_IOCB, &vha->dpc_flags);
+ }
+ 
+ static void
+ qla24xx_process_abts(struct scsi_qla_host *vha, void *pkt)
+ {
+ 	struct abts_entry_24xx *abts = pkt;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct els_entry_24xx *rsp_els;
+ 	struct abts_entry_24xx *abts_rsp;
+ 	dma_addr_t dma;
+ 	uint32_t fctl;
+ 	int rval;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0286, "%s: entered.\n", __func__);
+ 
+ 	ql_log(ql_log_warn, vha, 0x0287,
+ 	    "Processing ABTS xchg=%#x oxid=%#x rxid=%#x seqid=%#x seqcnt=%#x\n",
+ 	    abts->rx_xch_addr_to_abort, abts->ox_id, abts->rx_id,
+ 	    abts->seq_id, abts->seq_cnt);
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0287,
+ 	    "-------- ABTS RCV -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0287,
+ 	    (uint8_t *)abts, sizeof(*abts));
+ 
+ 	rsp_els = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_els), &dma,
+ 	    GFP_KERNEL);
+ 	if (!rsp_els) {
+ 		ql_log(ql_log_warn, vha, 0x0287,
+ 		    "Failed allocate dma buffer ABTS/ELS RSP.\n");
+ 		return;
+ 	}
+ 
+ 	/* terminate exchange */
+ 	memset(rsp_els, 0, sizeof(*rsp_els));
+ 	rsp_els->entry_type = ELS_IOCB_TYPE;
+ 	rsp_els->entry_count = 1;
+ 	rsp_els->nport_handle = ~0;
+ 	rsp_els->rx_xchg_address = abts->rx_xch_addr_to_abort;
+ 	rsp_els->control_flags = EPD_RX_XCHG;
+ 	ql_dbg(ql_dbg_init, vha, 0x0283,
+ 	    "Sending ELS Response to terminate exchange %#x...\n",
+ 	    abts->rx_xch_addr_to_abort);
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0283,
+ 	    "-------- ELS RSP -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0283,
+ 	    (uint8_t *)rsp_els, sizeof(*rsp_els));
+ 	rval = qla2x00_issue_iocb(vha, rsp_els, dma, 0);
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x0288,
+ 		    "%s: iocb failed to execute -> %x\n", __func__, rval);
+ 	} else if (rsp_els->comp_status) {
+ 		ql_log(ql_log_warn, vha, 0x0289,
+ 		    "%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\n",
+ 		    __func__, rsp_els->comp_status,
+ 		    rsp_els->error_subcode_1, rsp_els->error_subcode_2);
+ 	} else {
+ 		ql_dbg(ql_dbg_init, vha, 0x028a,
+ 		    "%s: abort exchange done.\n", __func__);
+ 	}
+ 
+ 	/* send ABTS response */
+ 	abts_rsp = (void *)rsp_els;
+ 	memset(abts_rsp, 0, sizeof(*abts_rsp));
+ 	abts_rsp->entry_type = ABTS_RSP_TYPE;
+ 	abts_rsp->entry_count = 1;
+ 	abts_rsp->nport_handle = abts->nport_handle;
+ 	abts_rsp->vp_idx = abts->vp_idx;
+ 	abts_rsp->sof_type = abts->sof_type & 0xf0;
+ 	abts_rsp->rx_xch_addr = abts->rx_xch_addr;
+ 	abts_rsp->d_id[0] = abts->s_id[0];
+ 	abts_rsp->d_id[1] = abts->s_id[1];
+ 	abts_rsp->d_id[2] = abts->s_id[2];
+ 	abts_rsp->r_ctl = FC_ROUTING_BLD | FC_R_CTL_BLD_BA_ACC;
+ 	abts_rsp->s_id[0] = abts->d_id[0];
+ 	abts_rsp->s_id[1] = abts->d_id[1];
+ 	abts_rsp->s_id[2] = abts->d_id[2];
+ 	abts_rsp->cs_ctl = abts->cs_ctl;
+ 	/* include flipping bit23 in fctl */
+ 	fctl = ~(abts->f_ctl[2] | 0x7F) << 16 |
+ 	    FC_F_CTL_LAST_SEQ | FC_F_CTL_END_SEQ | FC_F_CTL_SEQ_INIT;
+ 	abts_rsp->f_ctl[0] = fctl >> 0 & 0xff;
+ 	abts_rsp->f_ctl[1] = fctl >> 8 & 0xff;
+ 	abts_rsp->f_ctl[2] = fctl >> 16 & 0xff;
+ 	abts_rsp->type = FC_TYPE_BLD;
+ 	abts_rsp->rx_id = abts->rx_id;
+ 	abts_rsp->ox_id = abts->ox_id;
+ 	abts_rsp->payload.ba_acc.aborted_rx_id = abts->rx_id;
+ 	abts_rsp->payload.ba_acc.aborted_ox_id = abts->ox_id;
+ 	abts_rsp->payload.ba_acc.high_seq_cnt = ~0;
+ 	abts_rsp->rx_xch_addr_to_abort = abts->rx_xch_addr_to_abort;
+ 	ql_dbg(ql_dbg_init, vha, 0x028b,
+ 	    "Sending BA ACC response to ABTS %#x...\n",
+ 	    abts->rx_xch_addr_to_abort);
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x028b,
+ 	    "-------- ELS RSP -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x028b,
+ 	    (uint8_t *)abts_rsp, sizeof(*abts_rsp));
+ 	rval = qla2x00_issue_iocb(vha, abts_rsp, dma, 0);
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x028c,
+ 		    "%s: iocb failed to execute -> %x\n", __func__, rval);
+ 	} else if (abts_rsp->comp_status) {
+ 		ql_log(ql_log_warn, vha, 0x028d,
+ 		    "%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\n",
+ 		    __func__, abts_rsp->comp_status,
+ 		    abts_rsp->payload.error.subcode1,
+ 		    abts_rsp->payload.error.subcode2);
+ 	} else {
+ 		ql_dbg(ql_dbg_init, vha, 0x028ea,
+ 		    "%s: done.\n", __func__);
+ 	}
+ 
+ 	dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_els), rsp_els, dma);
+ }
+ 
++>>>>>>> 576bfde80b28 (scsi: qla2xxx: Add deferred queue for processing ABTS and RDP)
  /**
   * qla2100_intr_handler() - Process interrupts for the ISP2100 and ISP2200.
   * @irq: interrupt number
@@@ -3197,6 -3277,19 +3343,22 @@@ process_err
  			qla_ctrlvp_completed(vha, rsp->req,
  			    (struct vp_ctrl_entry_24xx *)pkt);
  			break;
++<<<<<<< HEAD
++=======
+ 		case PUREX_IOCB_TYPE:
+ 		{
+ 			struct purex_entry_24xx *purex = (void *)pkt;
+ 
+ 			if (purex->els_frame_payload[3] != ELS_COMMAND_RDP) {
+ 				ql_dbg(ql_dbg_init, vha, 0x5091,
+ 				    "Discarding ELS Request opcode %#x...\n",
+ 				    purex->els_frame_payload[3]);
+ 				break;
+ 			}
+ 			qla24xx_purex_iocb(vha, pkt, qla24xx_process_purex_rdp);
+ 			break;
+ 		}
++>>>>>>> 576bfde80b28 (scsi: qla2xxx: Add deferred queue for processing ABTS and RDP)
  		default:
  			/* Type Not Supported. */
  			ql_dbg(ql_dbg_async, vha, 0x5042,
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 39ebd7a7f7ff,7ab32977ea96..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -3345,6 -3461,19 +3345,15 @@@ skip_dpc
  	return 0;
  
  probe_failed:
++<<<<<<< HEAD
++=======
+ 	if (base_vha->gnl.l) {
+ 		dma_free_coherent(&ha->pdev->dev, base_vha->gnl.size,
+ 				base_vha->gnl.l, base_vha->gnl.ldma);
+ 		base_vha->gnl.l = NULL;
+ 	}
+ 
++>>>>>>> 576bfde80b28 (scsi: qla2xxx: Add deferred queue for processing ABTS and RDP)
  	if (base_vha->timer_active)
  		qla2x00_stop_timer(base_vha);
  	base_vha->flags.online = 0;
@@@ -5615,6 -5769,568 +5643,571 @@@ retry_lock
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ static uint
+ qla25xx_rdp_port_speed_capability(struct qla_hw_data *ha)
+ {
+ 	if (IS_CNA_CAPABLE(ha))
+ 		return RDP_PORT_SPEED_10GB;
+ 
+ 	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
+ 		unsigned int speeds = 0;
+ 
+ 		if (ha->max_supported_speed == 2) {
+ 			if (ha->min_supported_speed <= 6)
+ 				speeds |= RDP_PORT_SPEED_64GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 2 ||
+ 		    ha->max_supported_speed == 1) {
+ 			if (ha->min_supported_speed <= 5)
+ 				speeds |= RDP_PORT_SPEED_32GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 2 ||
+ 		    ha->max_supported_speed == 1 ||
+ 		    ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 4)
+ 				speeds |= RDP_PORT_SPEED_16GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 1 ||
+ 		    ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 3)
+ 				speeds |= RDP_PORT_SPEED_8GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 2)
+ 				speeds |= RDP_PORT_SPEED_4GB;
+ 		}
+ 
+ 		return speeds;
+ 	}
+ 
+ 	if (IS_QLA2031(ha))
+ 		return RDP_PORT_SPEED_16GB|RDP_PORT_SPEED_8GB|
+ 		       RDP_PORT_SPEED_4GB;
+ 
+ 	if (IS_QLA25XX(ha))
+ 		return RDP_PORT_SPEED_8GB|RDP_PORT_SPEED_4GB|
+ 		       RDP_PORT_SPEED_2GB|RDP_PORT_SPEED_1GB;
+ 
+ 	if (IS_QLA24XX_TYPE(ha))
+ 		return RDP_PORT_SPEED_4GB|RDP_PORT_SPEED_2GB|
+ 		       RDP_PORT_SPEED_1GB;
+ 
+ 	if (IS_QLA23XX(ha))
+ 		return RDP_PORT_SPEED_2GB|RDP_PORT_SPEED_1GB;
+ 
+ 	return RDP_PORT_SPEED_1GB;
+ }
+ 
+ static uint
+ qla25xx_rdp_port_speed_currently(struct qla_hw_data *ha)
+ {
+ 	switch (ha->link_data_rate) {
+ 	case PORT_SPEED_1GB:
+ 		return RDP_PORT_SPEED_1GB;
+ 
+ 	case PORT_SPEED_2GB:
+ 		return RDP_PORT_SPEED_2GB;
+ 
+ 	case PORT_SPEED_4GB:
+ 		return RDP_PORT_SPEED_4GB;
+ 
+ 	case PORT_SPEED_8GB:
+ 		return RDP_PORT_SPEED_8GB;
+ 
+ 	case PORT_SPEED_10GB:
+ 		return RDP_PORT_SPEED_10GB;
+ 
+ 	case PORT_SPEED_16GB:
+ 		return RDP_PORT_SPEED_16GB;
+ 
+ 	case PORT_SPEED_32GB:
+ 		return RDP_PORT_SPEED_32GB;
+ 
+ 	case PORT_SPEED_64GB:
+ 		return RDP_PORT_SPEED_64GB;
+ 
+ 	default:
+ 		return RDP_PORT_SPEED_UNKNOWN;
+ 	}
+ }
+ 
+ /*
+  * Function Name: qla24xx_process_purex_iocb
+  *
+  * Description:
+  * Prepare a RDP response and send to Fabric switch
+  *
+  * PARAMETERS:
+  * vha:	SCSI qla host
+  * purex: RDP request received by HBA
+  */
+ void qla24xx_process_purex_rdp(struct scsi_qla_host *vha, void *pkt)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct purex_entry_24xx *purex = pkt;
+ 	struct port_database_24xx *pdb = NULL;
+ 	dma_addr_t rsp_els_dma;
+ 	dma_addr_t rsp_payload_dma;
+ 	dma_addr_t stat_dma;
+ 	dma_addr_t bbc_dma;
+ 	dma_addr_t sfp_dma;
+ 	struct els_entry_24xx *rsp_els = NULL;
+ 	struct rdp_rsp_payload *rsp_payload = NULL;
+ 	struct link_statistics *stat = NULL;
+ 	struct buffer_credit_24xx *bbc = NULL;
+ 	uint8_t *sfp = NULL;
+ 	uint16_t sfp_flags = 0;
+ 	int rval;
+ 
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0180,
+ 	    "%s: Enter\n", __func__);
+ 
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0181,
+ 	    "-------- ELS REQ -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0182,
+ 	    (void *)purex, sizeof(*purex));
+ 
+ 	rsp_els = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_els),
+ 	    &rsp_els_dma, GFP_KERNEL);
+ 	if (!rsp_els) {
+ 		ql_log(ql_log_warn, vha, 0x0183,
+ 		    "Failed allocate dma buffer ELS RSP.\n");
+ 		goto dealloc;
+ 	}
+ 
+ 	rsp_payload = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_payload),
+ 	    &rsp_payload_dma, GFP_KERNEL);
+ 	if (!rsp_payload) {
+ 		ql_log(ql_log_warn, vha, 0x0184,
+ 		    "Failed allocate dma buffer ELS RSP payload.\n");
+ 		goto dealloc;
+ 	}
+ 
+ 	sfp = dma_alloc_coherent(&ha->pdev->dev, SFP_RTDI_LEN,
+ 	    &sfp_dma, GFP_KERNEL);
+ 
+ 	stat = dma_alloc_coherent(&ha->pdev->dev, sizeof(*stat),
+ 	    &stat_dma, GFP_KERNEL);
+ 
+ 	bbc = dma_alloc_coherent(&ha->pdev->dev, sizeof(*bbc),
+ 	    &bbc_dma, GFP_KERNEL);
+ 
+ 	/* Prepare Response IOCB */
+ 	memset(rsp_els, 0, sizeof(*rsp_els));
+ 	rsp_els->entry_type = ELS_IOCB_TYPE;
+ 	rsp_els->entry_count = 1;
+ 	rsp_els->sys_define = 0;
+ 	rsp_els->entry_status = 0;
+ 	rsp_els->handle = 0;
+ 	rsp_els->nport_handle = purex->nport_handle;
+ 	rsp_els->tx_dsd_count = 1;
+ 	rsp_els->vp_index = purex->vp_idx;
+ 	rsp_els->sof_type = EST_SOFI3;
+ 	rsp_els->rx_xchg_address = purex->rx_xchg_addr;
+ 	rsp_els->rx_dsd_count = 0;
+ 	rsp_els->opcode = purex->els_frame_payload[0];
+ 
+ 	rsp_els->d_id[0] = purex->s_id[0];
+ 	rsp_els->d_id[1] = purex->s_id[1];
+ 	rsp_els->d_id[2] = purex->s_id[2];
+ 
+ 	rsp_els->control_flags = EPD_ELS_ACC;
+ 	rsp_els->rx_byte_count = 0;
+ 	rsp_els->tx_byte_count = cpu_to_le32(sizeof(*rsp_payload));
+ 
+ 	put_unaligned_le64(rsp_payload_dma, &rsp_els->tx_address);
+ 	rsp_els->tx_len = rsp_els->tx_byte_count;
+ 
+ 	rsp_els->rx_address = 0;
+ 	rsp_els->rx_len = 0;
+ 
+ 	if (sizeof(*rsp_payload) <= 0x100)
+ 		goto accept;
+ 
+ 	pdb = kzalloc(sizeof(*pdb), GFP_KERNEL);
+ 	if (!pdb)
+ 		goto reduce;
+ 
+ 	rval = qla24xx_get_port_database(vha, purex->nport_handle, pdb);
+ 	if (rval)
+ 		goto reduce;
+ 
+ 	if (pdb->port_id[0] != purex->s_id[2] ||
+ 	    pdb->port_id[1] != purex->s_id[1] ||
+ 	    pdb->port_id[2] != purex->s_id[0])
+ 		goto reduce;
+ 
+ 	if (pdb->current_login_state == PDS_PLOGI_COMPLETE ||
+ 	    pdb->current_login_state == PDS_PRLI_COMPLETE)
+ 		goto accept;
+ 
+ reduce:
+ 	ql_dbg(ql_dbg_init, vha, 0x016e, "Requesting port is not logged in.\n");
+ 	rsp_els->tx_byte_count = rsp_els->tx_len =
+ 	    offsetof(struct rdp_rsp_payload, buffer_credit_desc);
+ 	ql_dbg(ql_dbg_init, vha, 0x016f, "Reduced response payload size %u.\n",
+ 	    rsp_els->tx_byte_count);
+ 
+ accept:
+ 	/* Prepare Response Payload */
+ 	rsp_payload->hdr.cmd = cpu_to_be32(0x2 << 24); /* LS_ACC */
+ 	rsp_payload->hdr.len = cpu_to_be32(
+ 	    rsp_els->tx_byte_count - sizeof(rsp_payload->hdr));
+ 
+ 	/* Link service Request Info Descriptor */
+ 	rsp_payload->ls_req_info_desc.desc_tag = cpu_to_be32(0x1);
+ 	rsp_payload->ls_req_info_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc));
+ 	rsp_payload->ls_req_info_desc.req_payload_word_0 =
+ 	    cpu_to_be32p((uint32_t *)purex->els_frame_payload);
+ 
+ 	/* Link service Request Info Descriptor 2 */
+ 	rsp_payload->ls_req_info_desc2.desc_tag = cpu_to_be32(0x1);
+ 	rsp_payload->ls_req_info_desc2.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc2));
+ 	rsp_payload->ls_req_info_desc2.req_payload_word_0 =
+ 	    cpu_to_be32p((uint32_t *)purex->els_frame_payload);
+ 
+ 	if (sfp) {
+ 		/* SFP Flags */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x7, 2, 0);
+ 		if (!rval) {
+ 			/* SFP Flags bits 3-0: Port Tx Laser Type */
+ 			if (sfp[0] & BIT_2 || sfp[1] & (BIT_6|BIT_5))
+ 				sfp_flags |= BIT_0; /* short wave */
+ 			else if (sfp[0] & BIT_1)
+ 				sfp_flags |= BIT_1; /* long wave 1310nm */
+ 			else if (sfp[1] & BIT_4)
+ 				sfp_flags |= BIT_1|BIT_0; /* long wave 1550nm */
+ 		}
+ 
+ 		/* SFP Type */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x0, 1, 0);
+ 		if (!rval) {
+ 			sfp_flags |= BIT_4; /* optical */
+ 			if (sfp[0] == 0x3)
+ 				sfp_flags |= BIT_6; /* sfp+ */
+ 		}
+ 
+ 		/* SFP Diagnostics */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0x60, 10, 0);
+ 		if (!rval && sfp_flags) {
+ 			uint16_t *trx = (void *)sfp; /* already be16 */
+ 
+ 			rsp_payload->sfp_diag_desc.desc_tag =
+ 			    cpu_to_be32(0x10000);
+ 			rsp_payload->sfp_diag_desc.desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(rsp_payload->sfp_diag_desc));
+ 			rsp_payload->sfp_diag_desc.temperature = trx[0];
+ 			rsp_payload->sfp_diag_desc.vcc = trx[1];
+ 			rsp_payload->sfp_diag_desc.tx_bias = trx[2];
+ 			rsp_payload->sfp_diag_desc.tx_power = trx[3];
+ 			rsp_payload->sfp_diag_desc.rx_power = trx[4];
+ 			rsp_payload->sfp_diag_desc.sfp_flags =
+ 			    cpu_to_be16(sfp_flags);
+ 		}
+ 	}
+ 
+ 	/* Port Speed Descriptor */
+ 	rsp_payload->port_speed_desc.desc_tag = cpu_to_be32(0x10001);
+ 	rsp_payload->port_speed_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_speed_desc));
+ 	rsp_payload->port_speed_desc.speed_capab = cpu_to_be16(
+ 	    qla25xx_rdp_port_speed_capability(ha));
+ 	rsp_payload->port_speed_desc.operating_speed = cpu_to_be16(
+ 	    qla25xx_rdp_port_speed_currently(ha));
+ 
+ 	if (stat) {
+ 		rval = qla24xx_get_isp_stats(vha, stat, stat_dma, 0);
+ 		if (!rval) {
+ 			/* Link Error Status Descriptor */
+ 			rsp_payload->ls_err_desc.desc_tag =
+ 			    cpu_to_be32(0x10002);
+ 			rsp_payload->ls_err_desc.desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_err_desc));
+ 			rsp_payload->ls_err_desc.link_fail_cnt =
+ 			    cpu_to_be32(stat->link_fail_cnt);
+ 			rsp_payload->ls_err_desc.loss_sync_cnt =
+ 			    cpu_to_be32(stat->loss_sync_cnt);
+ 			rsp_payload->ls_err_desc.loss_sig_cnt =
+ 			    cpu_to_be32(stat->loss_sig_cnt);
+ 			rsp_payload->ls_err_desc.prim_seq_err_cnt =
+ 			    cpu_to_be32(stat->prim_seq_err_cnt);
+ 			rsp_payload->ls_err_desc.inval_xmit_word_cnt =
+ 			    cpu_to_be32(stat->inval_xmit_word_cnt);
+ 			rsp_payload->ls_err_desc.inval_crc_cnt =
+ 			    cpu_to_be32(stat->inval_crc_cnt);
+ 			rsp_payload->ls_err_desc.pn_port_phy_type |= BIT_6;
+ 		}
+ 	}
+ 
+ 	/* Portname Descriptor */
+ 	rsp_payload->port_name_diag_desc.desc_tag = cpu_to_be32(0x10003);
+ 	rsp_payload->port_name_diag_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_diag_desc));
+ 	memcpy(rsp_payload->port_name_diag_desc.WWNN,
+ 	    vha->node_name,
+ 	    sizeof(rsp_payload->port_name_diag_desc.WWNN));
+ 	memcpy(rsp_payload->port_name_diag_desc.WWPN,
+ 	    vha->port_name,
+ 	    sizeof(rsp_payload->port_name_diag_desc.WWPN));
+ 
+ 	/* F-Port Portname Descriptor */
+ 	rsp_payload->port_name_direct_desc.desc_tag = cpu_to_be32(0x10003);
+ 	rsp_payload->port_name_direct_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_direct_desc));
+ 	memcpy(rsp_payload->port_name_direct_desc.WWNN,
+ 	    vha->fabric_node_name,
+ 	    sizeof(rsp_payload->port_name_direct_desc.WWNN));
+ 	memcpy(rsp_payload->port_name_direct_desc.WWPN,
+ 	    vha->fabric_port_name,
+ 	    sizeof(rsp_payload->port_name_direct_desc.WWPN));
+ 
+ 	if (rsp_els->tx_byte_count < sizeof(*rsp_payload))
+ 		goto send;
+ 
+ 	if (bbc) {
+ 		memset(bbc, 0, sizeof(*bbc));
+ 		rval = qla24xx_get_buffer_credits(vha, bbc, bbc_dma);
+ 		if (!rval) {
+ 			/* Bufer Credit Descriptor */
+ 			rsp_payload->buffer_credit_desc.desc_tag =
+ 			    cpu_to_be32(0x10006);
+ 			rsp_payload->buffer_credit_desc.desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(
+ 				rsp_payload->buffer_credit_desc));
+ 			rsp_payload->buffer_credit_desc.fcport_b2b =
+ 			    cpu_to_be32(LSW(bbc->parameter[0]));
+ 			rsp_payload->buffer_credit_desc.attached_fcport_b2b =
+ 			    cpu_to_be32(0);
+ 			rsp_payload->buffer_credit_desc.fcport_rtt =
+ 			    cpu_to_be32(0);
+ 		}
+ 	}
+ 
+ 	if (sfp) {
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0, 64, 0);
+ 		if (!rval) {
+ 			uint16_t *trx = (void *)sfp; /* already be16 */
+ 
+ 			/* Optical Element Descriptor, Temperature */
+ 			rsp_payload->optical_elmt_desc[0].desc_tag =
+ 			    cpu_to_be32(0x10007);
+ 			rsp_payload->optical_elmt_desc[0].desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(
+ 				*rsp_payload->optical_elmt_desc));
+ 			rsp_payload->optical_elmt_desc[0].high_alarm = trx[0];
+ 			rsp_payload->optical_elmt_desc[0].low_alarm = trx[1];
+ 			rsp_payload->optical_elmt_desc[0].high_warn = trx[2];
+ 			rsp_payload->optical_elmt_desc[0].low_warn = trx[3];
+ 			rsp_payload->optical_elmt_desc[0].element_flags =
+ 			    cpu_to_be32(1 << 28);
+ 
+ 			/* Optical Element Descriptor, Voltage */
+ 			rsp_payload->optical_elmt_desc[1].desc_tag =
+ 			    cpu_to_be32(0x10007);
+ 			rsp_payload->optical_elmt_desc[1].desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(
+ 				*rsp_payload->optical_elmt_desc));
+ 			rsp_payload->optical_elmt_desc[1].high_alarm = trx[4];
+ 			rsp_payload->optical_elmt_desc[1].low_alarm = trx[5];
+ 			rsp_payload->optical_elmt_desc[1].high_warn = trx[6];
+ 			rsp_payload->optical_elmt_desc[1].low_warn = trx[7];
+ 			rsp_payload->optical_elmt_desc[1].element_flags =
+ 			    cpu_to_be32(2 << 28);
+ 
+ 			/* Optical Element Descriptor, Tx Bias Current */
+ 			rsp_payload->optical_elmt_desc[2].desc_tag =
+ 			    cpu_to_be32(0x10007);
+ 			rsp_payload->optical_elmt_desc[2].desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(
+ 				*rsp_payload->optical_elmt_desc));
+ 			rsp_payload->optical_elmt_desc[2].high_alarm = trx[8];
+ 			rsp_payload->optical_elmt_desc[2].low_alarm = trx[9];
+ 			rsp_payload->optical_elmt_desc[2].high_warn = trx[10];
+ 			rsp_payload->optical_elmt_desc[2].low_warn = trx[11];
+ 			rsp_payload->optical_elmt_desc[2].element_flags =
+ 			    cpu_to_be32(3 << 28);
+ 
+ 			/* Optical Element Descriptor, Tx Power */
+ 			rsp_payload->optical_elmt_desc[3].desc_tag =
+ 			    cpu_to_be32(0x10007);
+ 			rsp_payload->optical_elmt_desc[3].desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(
+ 				*rsp_payload->optical_elmt_desc));
+ 			rsp_payload->optical_elmt_desc[3].high_alarm = trx[12];
+ 			rsp_payload->optical_elmt_desc[3].low_alarm = trx[13];
+ 			rsp_payload->optical_elmt_desc[3].high_warn = trx[14];
+ 			rsp_payload->optical_elmt_desc[3].low_warn = trx[15];
+ 			rsp_payload->optical_elmt_desc[3].element_flags =
+ 			    cpu_to_be32(4 << 28);
+ 
+ 			/* Optical Element Descriptor, Rx Power */
+ 			rsp_payload->optical_elmt_desc[4].desc_tag =
+ 			    cpu_to_be32(0x10007);
+ 			rsp_payload->optical_elmt_desc[4].desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(
+ 				*rsp_payload->optical_elmt_desc));
+ 			rsp_payload->optical_elmt_desc[4].high_alarm = trx[16];
+ 			rsp_payload->optical_elmt_desc[4].low_alarm = trx[17];
+ 			rsp_payload->optical_elmt_desc[4].high_warn = trx[18];
+ 			rsp_payload->optical_elmt_desc[4].low_warn = trx[19];
+ 			rsp_payload->optical_elmt_desc[4].element_flags =
+ 			    cpu_to_be32(5 << 28);
+ 		}
+ 
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 112, 64, 0);
+ 		if (!rval) {
+ 			/* Temperature high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[0].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 7 & 1) << 3 |
+ 				(sfp[0] >> 6 & 1) << 2 |
+ 				(sfp[4] >> 7 & 1) << 1 |
+ 				(sfp[4] >> 6 & 1) << 0);
+ 
+ 			/* Voltage high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[1].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 5 & 1) << 3 |
+ 				(sfp[0] >> 4 & 1) << 2 |
+ 				(sfp[4] >> 5 & 1) << 1 |
+ 				(sfp[4] >> 4 & 1) << 0);
+ 
+ 			/* Tx Bias Current high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[2].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 3 & 1) << 3 |
+ 				(sfp[0] >> 2 & 1) << 2 |
+ 				(sfp[4] >> 3 & 1) << 1 |
+ 				(sfp[4] >> 2 & 1) << 0);
+ 
+ 			/* Tx Power high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[3].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 1 & 1) << 3 |
+ 				(sfp[0] >> 0 & 1) << 2 |
+ 				(sfp[4] >> 1 & 1) << 1 |
+ 				(sfp[4] >> 0 & 1) << 0);
+ 
+ 			/* Rx Power high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[4].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[1] >> 7 & 1) << 3 |
+ 				(sfp[1] >> 6 & 1) << 2 |
+ 				(sfp[5] >> 7 & 1) << 1 |
+ 				(sfp[5] >> 6 & 1) << 0);
+ 		}
+ 	}
+ 
+ 	if (sfp) {
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 20, 64, 0);
+ 		if (!rval) {
+ 			/* Optical Product Data Descriptor */
+ 			rsp_payload->optical_prod_desc.desc_tag =
+ 			    cpu_to_be32(0x10008);
+ 			rsp_payload->optical_prod_desc.desc_len =
+ 			    cpu_to_be32(RDP_DESC_LEN(
+ 				rsp_payload->optical_prod_desc));
+ 			memcpy(rsp_payload->optical_prod_desc.vendor_name,
+ 			    sfp + 0,
+ 			    sizeof(rsp_payload->optical_prod_desc.vendor_name));
+ 			memcpy(rsp_payload->optical_prod_desc.part_number,
+ 			    sfp + 20,
+ 			    sizeof(rsp_payload->optical_prod_desc.part_number));
+ 			memcpy(rsp_payload->optical_prod_desc.revision,
+ 			    sfp + 36,
+ 			    sizeof(rsp_payload->optical_prod_desc.revision));
+ 			memcpy(rsp_payload->optical_prod_desc.serial_number,
+ 			    sfp + 48,
+ 			    sizeof(rsp_payload->optical_prod_desc.serial_number));
+ 		}
+ 
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 84, 8, 0);
+ 		if (!rval) {
+ 			memcpy(rsp_payload->optical_prod_desc.date,
+ 			    sfp + 0,
+ 			    sizeof(rsp_payload->optical_prod_desc.date));
+ 		}
+ 	}
+ 
+ send:
+ 	ql_dbg(ql_dbg_init, vha, 0x0183,
+ 	    "Sending ELS Response to RDP Request...\n");
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0184,
+ 	    "-------- ELS RSP -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0185,
+ 	    (void *)rsp_els, sizeof(*rsp_els));
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0186,
+ 	    "-------- ELS RSP PAYLOAD -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0187,
+ 	    (void *)rsp_payload, rsp_els->tx_byte_count);
+ 
+ 	rval = qla2x00_issue_iocb(vha, rsp_els, rsp_els_dma, 0);
+ 
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x0188,
+ 		    "%s: iocb failed to execute -> %x\n", __func__, rval);
+ 	} else if (rsp_els->comp_status) {
+ 		ql_log(ql_log_warn, vha, 0x0189,
+ 		    "%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\n",
+ 		    __func__, rsp_els->comp_status,
+ 		    rsp_els->error_subcode_1, rsp_els->error_subcode_2);
+ 	} else {
+ 		ql_dbg(ql_dbg_init, vha, 0x018a, "%s: done.\n", __func__);
+ 	}
+ 
+ dealloc:
+ 	kfree(pdb);
+ 
+ 	if (bbc)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*bbc),
+ 		    bbc, bbc_dma);
+ 	if (stat)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*stat),
+ 		    stat, stat_dma);
+ 	if (sfp)
+ 		dma_free_coherent(&ha->pdev->dev, SFP_RTDI_LEN,
+ 		    sfp, sfp_dma);
+ 	if (rsp_payload)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_payload),
+ 		    rsp_payload, rsp_payload_dma);
+ 	if (rsp_els)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_els),
+ 		    rsp_els, rsp_els_dma);
+ }
+ 
+ void qla24xx_process_purex_list(struct purex_list *list)
+ {
+ 	struct list_head head = LIST_HEAD_INIT(head);
+ 	struct purex_item *item, *next;
+ 	ulong flags;
+ 
+ 	spin_lock_irqsave(&list->lock, flags);
+ 	list_splice_init(&list->head, &head);
+ 	spin_unlock_irqrestore(&list->lock, flags);
+ 
+ 	list_for_each_entry_safe(item, next, &head, list) {
+ 		list_del(&item->list);
+ 		item->process_item(item->vha, &item->iocb);
+ 		kfree(item);
+ 	}
+ }
+ 
++>>>>>>> 576bfde80b28 (scsi: qla2xxx: Add deferred queue for processing ABTS and RDP)
  void
  qla83xx_idc_unlock(scsi_qla_host_t *base_vha, uint16_t requester_id)
  {
@@@ -6186,6 -6901,15 +6779,18 @@@ qla2x00_do_dpc(void *data
  			}
  		}
  
++<<<<<<< HEAD
++=======
+ 		if (test_bit(PROCESS_PUREX_IOCB, &base_vha->dpc_flags)) {
+ 			if (atomic_read(&base_vha->loop_state) == LOOP_READY) {
+ 				qla24xx_process_purex_list
+ 					(&base_vha->purex_list);
+ 				clear_bit(PROCESS_PUREX_IOCB,
+ 				    &base_vha->dpc_flags);
+ 			}
+ 		}
+ 
++>>>>>>> 576bfde80b28 (scsi: qla2xxx: Add deferred queue for processing ABTS and RDP)
  		if (test_and_clear_bit(FCPORT_UPDATE_NEEDED,
  		    &base_vha->dpc_flags)) {
  			qla2x00_update_fcports(base_vha);
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_fw.h
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index 793e4bf50456..facf2fa4ffc4 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -230,6 +230,7 @@ void qla2x00_handle_login_done_event(struct scsi_qla_host *, fc_port_t *,
 int qla24xx_post_gnl_work(struct scsi_qla_host *, fc_port_t *);
 int qla24xx_post_relogin_work(struct scsi_qla_host *vha);
 void qla2x00_wait_for_sess_deletion(scsi_qla_host_t *);
+void qla24xx_process_purex_rdp(struct scsi_qla_host *vha, void *pkt);
 
 /*
  * Global Functions in qla_mid.c source file.
@@ -927,6 +928,7 @@ void qlt_remove_target_resources(struct qla_hw_data *);
 void qlt_clr_qp_table(struct scsi_qla_host *vha);
 void qlt_set_mode(struct scsi_qla_host *);
 int qla2x00_set_data_rate(scsi_qla_host_t *vha, uint16_t mode);
+extern void qla24xx_process_purex_list(struct purex_list *);
 
 /* nvme.c */
 void qla_nvme_unregister_remote_port(struct fc_port *fcport);
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index a4a57323104f..d82e92da529a 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -361,6 +361,13 @@ qla2x00_do_dpc_vp(scsi_qla_host_t *vha)
 		}
 	}
 
+	if (test_bit(PROCESS_PUREX_IOCB, &vha->dpc_flags)) {
+		if (atomic_read(&vha->loop_state) == LOOP_READY) {
+			qla24xx_process_purex_list(&vha->purex_list);
+			clear_bit(PROCESS_PUREX_IOCB, &vha->dpc_flags);
+		}
+	}
+
 	if (test_bit(FCPORT_UPDATE_NEEDED, &vha->dpc_flags)) {
 		ql_dbg(ql_dbg_dpc, vha, 0x4016,
 		    "FCPort update scheduled.\n");
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
