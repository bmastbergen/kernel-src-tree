consolidate the capability checks in sget_{fc,userns}()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [fs] consolidate the capability checks in sget_{fc, userns}() (Scott Mayhew) [1622041]
Rebuild_FUZZ: 99.10%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 0ce0cf12fc4c6a089717ff613d76457052cf4303
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0ce0cf12.failed

... into a common helper - mount_capable(type, userns)

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 0ce0cf12fc4c6a089717ff613d76457052cf4303)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/super.c
diff --cc fs/super.c
index 72596c26684f,3ba91d70c2a8..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -478,7 -476,95 +478,98 @@@ void generic_shutdown_super(struct supe
  
  EXPORT_SYMBOL(generic_shutdown_super);
  
+ bool mount_capable(struct file_system_type *type, struct user_namespace *userns)
+ {
+ 	if (!(type->fs_flags & FS_USERNS_MOUNT))
+ 		return capable(CAP_SYS_ADMIN);
+ 	else
+ 		return ns_capable(userns, CAP_SYS_ADMIN);
+ }
+ 
+ /**
++<<<<<<< HEAD
++=======
+  * sget_fc - Find or create a superblock
+  * @fc:	Filesystem context.
+  * @test: Comparison callback
+  * @set: Setup callback
+  *
+  * Find or create a superblock using the parameters stored in the filesystem
+  * context and the two callback functions.
+  *
+  * If an extant superblock is matched, then that will be returned with an
+  * elevated reference count that the caller must transfer or discard.
+  *
+  * If no match is made, a new superblock will be allocated and basic
+  * initialisation will be performed (s_type, s_fs_info and s_id will be set and
+  * the set() callback will be invoked), the superblock will be published and it
+  * will be returned in a partially constructed state with SB_BORN and SB_ACTIVE
+  * as yet unset.
+  */
+ struct super_block *sget_fc(struct fs_context *fc,
+ 			    int (*test)(struct super_block *, struct fs_context *),
+ 			    int (*set)(struct super_block *, struct fs_context *))
+ {
+ 	struct super_block *s = NULL;
+ 	struct super_block *old;
+ 	struct user_namespace *user_ns = fc->global ? &init_user_ns : fc->user_ns;
+ 	int err;
+ 
+ 	if (!(fc->sb_flags & SB_KERNMOUNT) &&
+ 	    fc->purpose != FS_CONTEXT_FOR_SUBMOUNT) {
+ 		if (!mount_capable(fc->fs_type, user_ns))
+ 			return ERR_PTR(-EPERM);
+ 	}
+ 
+ retry:
+ 	spin_lock(&sb_lock);
+ 	if (test) {
+ 		hlist_for_each_entry(old, &fc->fs_type->fs_supers, s_instances) {
+ 			if (test(old, fc))
+ 				goto share_extant_sb;
+ 		}
+ 	}
+ 	if (!s) {
+ 		spin_unlock(&sb_lock);
+ 		s = alloc_super(fc->fs_type, fc->sb_flags, user_ns);
+ 		if (!s)
+ 			return ERR_PTR(-ENOMEM);
+ 		goto retry;
+ 	}
+ 
+ 	s->s_fs_info = fc->s_fs_info;
+ 	err = set(s, fc);
+ 	if (err) {
+ 		s->s_fs_info = NULL;
+ 		spin_unlock(&sb_lock);
+ 		destroy_unused_super(s);
+ 		return ERR_PTR(err);
+ 	}
+ 	fc->s_fs_info = NULL;
+ 	s->s_type = fc->fs_type;
+ 	strlcpy(s->s_id, s->s_type->name, sizeof(s->s_id));
+ 	list_add_tail(&s->s_list, &super_blocks);
+ 	hlist_add_head(&s->s_instances, &s->s_type->fs_supers);
+ 	spin_unlock(&sb_lock);
+ 	get_filesystem(s->s_type);
+ 	register_shrinker_prepared(&s->s_shrink);
+ 	return s;
+ 
+ share_extant_sb:
+ 	if (user_ns != old->s_user_ns) {
+ 		spin_unlock(&sb_lock);
+ 		destroy_unused_super(s);
+ 		return ERR_PTR(-EBUSY);
+ 	}
+ 	if (!grab_super(old))
+ 		goto retry;
+ 	destroy_unused_super(s);
+ 	return old;
+ }
+ EXPORT_SYMBOL(sget_fc);
+ 
  /**
++>>>>>>> 0ce0cf12fc4c (consolidate the capability checks in sget_{fc,userns}())
   *	sget_userns -	find or create a superblock
   *	@type:	filesystem type superblock should belong to
   *	@test:	comparison callback
* Unmerged path fs/super.c
