xdp: Remove the xdp_attachment_flags_ok() callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Toke Høiland-Jørgensen <toke@redhat.com>
commit 998f17296234aa8d3676b4a13962eb39f4ad24e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/998f1729.failed

Since commit 7f0a838254bd ("bpf, xdp: Maintain info on attached XDP BPF
programs in net_device"), the XDP program attachment info is now maintained
in the core code. This interacts badly with the xdp_attachment_flags_ok()
check that prevents unloading an XDP program with different load flags than
it was loaded with. In practice, two kinds of failures are seen:

- An XDP program loaded without specifying a mode (and which then ends up
  in driver mode) cannot be unloaded if the program mode is specified on
  unload.

- The dev_xdp_uninstall() hook always calls the driver callback with the
  mode set to the type of the program but an empty flags argument, which
  means the flags_ok() check prevents the program from being removed,
  leading to bpf prog reference leaks.

The original reason this check was added was to avoid ambiguity when
multiple programs were loaded. With the way the checks are done in the core
now, this is quite simple to enforce in the core code, so let's add a check
there and get rid of the xdp_attachment_flags_ok() callback entirely.

Fixes: 7f0a838254bd ("bpf, xdp: Maintain info on attached XDP BPF programs in net_device")
	Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Jakub Kicinski <kuba@kernel.org>
Link: https://lore.kernel.org/bpf/160752225751.110217.10267659521308669050.stgit@toke.dk
(cherry picked from commit 998f17296234aa8d3676b4a13962eb39f4ad24e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ti/cpsw_priv.c
#	include/net/xdp.h
#	net/core/dev.c
#	net/core/xdp.c
diff --cc include/net/xdp.h
index 6368152dc76c,9dab2bc6f187..000000000000
--- a/include/net/xdp.h
+++ b/include/net/xdp.h
@@@ -216,10 -240,6 +216,13 @@@ struct xdp_attachment_info 
  };
  
  struct netdev_bpf;
++<<<<<<< HEAD
 +int xdp_attachment_query(struct xdp_attachment_info *info,
 +			 struct netdev_bpf *bpf);
 +bool xdp_attachment_flags_ok(struct xdp_attachment_info *info,
 +			     struct netdev_bpf *bpf);
++=======
++>>>>>>> 998f17296234 (xdp: Remove the xdp_attachment_flags_ok() callback)
  void xdp_attachment_setup(struct xdp_attachment_info *info,
  			  struct netdev_bpf *bpf);
  
diff --cc net/core/dev.c
index 2b8d3ed7a4a2,38412e70f761..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -8232,29 -8827,132 +8232,96 @@@ int dev_change_proto_down(struct net_de
  }
  EXPORT_SYMBOL(dev_change_proto_down);
  
 -/**
 - *	dev_change_proto_down_generic - generic implementation for
 - * 	ndo_change_proto_down that sets carrier according to
 - * 	proto_down.
 - *
 - *	@dev: device
 - *	@proto_down: new value
 - */
 -int dev_change_proto_down_generic(struct net_device *dev, bool proto_down)
 +u32 __dev_xdp_query(struct net_device *dev, bpf_op_t bpf_op,
 +		    enum bpf_netdev_command cmd)
  {
 -	if (proto_down)
 -		netif_carrier_off(dev);
 -	else
 -		netif_carrier_on(dev);
 -	dev->proto_down = proto_down;
 -	return 0;
 -}
 -EXPORT_SYMBOL(dev_change_proto_down_generic);
 +	struct netdev_bpf xdp;
  
 -/**
 - *	dev_change_proto_down_reason - proto down reason
 - *
 - *	@dev: device
 - *	@mask: proto down mask
 - *	@value: proto down value
 - */
 -void dev_change_proto_down_reason(struct net_device *dev, unsigned long mask,
 -				  u32 value)
 -{
 -	int b;
 +	if (!bpf_op)
 +		return 0;
  
 -	if (!mask) {
 -		dev->proto_down_reason = value;
 -	} else {
 -		for_each_set_bit(b, &mask, 32) {
 -			if (value & (1 << b))
 -				dev->proto_down_reason |= BIT(b);
 -			else
 -				dev->proto_down_reason &= ~BIT(b);
 -		}
 -	}
 -}
 -EXPORT_SYMBOL(dev_change_proto_down_reason);
 +	memset(&xdp, 0, sizeof(xdp));
 +	xdp.command = cmd;
  
 -struct bpf_xdp_link {
 -	struct bpf_link link;
 -	struct net_device *dev; /* protected by rtnl_lock, no refcnt held */
 -	int flags;
 -};
 +	/* Query must always succeed. */
 +	WARN_ON(bpf_op(dev, &xdp) < 0 && cmd == XDP_QUERY_PROG);
  
 -static enum bpf_xdp_mode dev_xdp_mode(struct net_device *dev, u32 flags)
 -{
 -	if (flags & XDP_FLAGS_HW_MODE)
 -		return XDP_MODE_HW;
 -	if (flags & XDP_FLAGS_DRV_MODE)
 -		return XDP_MODE_DRV;
 -	if (flags & XDP_FLAGS_SKB_MODE)
 -		return XDP_MODE_SKB;
 -	return dev->netdev_ops->ndo_bpf ? XDP_MODE_DRV : XDP_MODE_SKB;
 +	return xdp.prog_id;
  }
  
++<<<<<<< HEAD
 +static int dev_xdp_install(struct net_device *dev, bpf_op_t bpf_op,
 +			   struct netlink_ext_ack *extack, u32 flags,
 +			   struct bpf_prog *prog)
++=======
+ static bpf_op_t dev_xdp_bpf_op(struct net_device *dev, enum bpf_xdp_mode mode)
+ {
+ 	switch (mode) {
+ 	case XDP_MODE_SKB:
+ 		return generic_xdp_install;
+ 	case XDP_MODE_DRV:
+ 	case XDP_MODE_HW:
+ 		return dev->netdev_ops->ndo_bpf;
+ 	default:
+ 		return NULL;
+ 	};
+ }
+ 
+ static struct bpf_xdp_link *dev_xdp_link(struct net_device *dev,
+ 					 enum bpf_xdp_mode mode)
+ {
+ 	return dev->xdp_state[mode].link;
+ }
+ 
+ static struct bpf_prog *dev_xdp_prog(struct net_device *dev,
+ 				     enum bpf_xdp_mode mode)
+ {
+ 	struct bpf_xdp_link *link = dev_xdp_link(dev, mode);
+ 
+ 	if (link)
+ 		return link->link.prog;
+ 	return dev->xdp_state[mode].prog;
+ }
+ 
+ static u8 dev_xdp_prog_count(struct net_device *dev)
+ {
+ 	u8 count = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < __MAX_XDP_MODE; i++)
+ 		if (dev->xdp_state[i].prog || dev->xdp_state[i].link)
+ 			count++;
+ 	return count;
+ }
+ 
+ u32 dev_xdp_prog_id(struct net_device *dev, enum bpf_xdp_mode mode)
+ {
+ 	struct bpf_prog *prog = dev_xdp_prog(dev, mode);
+ 
+ 	return prog ? prog->aux->id : 0;
+ }
+ 
+ static void dev_xdp_set_link(struct net_device *dev, enum bpf_xdp_mode mode,
+ 			     struct bpf_xdp_link *link)
+ {
+ 	dev->xdp_state[mode].link = link;
+ 	dev->xdp_state[mode].prog = NULL;
+ }
+ 
+ static void dev_xdp_set_prog(struct net_device *dev, enum bpf_xdp_mode mode,
+ 			     struct bpf_prog *prog)
+ {
+ 	dev->xdp_state[mode].link = NULL;
+ 	dev->xdp_state[mode].prog = prog;
+ }
+ 
+ static int dev_xdp_install(struct net_device *dev, enum bpf_xdp_mode mode,
+ 			   bpf_op_t bpf_op, struct netlink_ext_ack *extack,
+ 			   u32 flags, struct bpf_prog *prog)
++>>>>>>> 998f17296234 (xdp: Remove the xdp_attachment_flags_ok() callback)
  {
 +	bool non_hw = !(flags & XDP_FLAGS_HW_MODE);
 +	struct bpf_prog *prev_prog = NULL;
  	struct netdev_bpf xdp;
  	int err;
  
@@@ -8286,30 -8985,325 +8353,336 @@@
  
  static void dev_xdp_uninstall(struct net_device *dev)
  {
 -	struct bpf_xdp_link *link;
 -	struct bpf_prog *prog;
 -	enum bpf_xdp_mode mode;
 -	bpf_op_t bpf_op;
 +	struct netdev_bpf xdp;
 +	bpf_op_t ndo_bpf;
  
 -	ASSERT_RTNL();
 +	/* Remove generic XDP */
 +	WARN_ON(dev_xdp_install(dev, generic_xdp_install, NULL, 0, NULL));
  
 -	for (mode = XDP_MODE_SKB; mode < __MAX_XDP_MODE; mode++) {
 -		prog = dev_xdp_prog(dev, mode);
 -		if (!prog)
 -			continue;
 -
 -		bpf_op = dev_xdp_bpf_op(dev, mode);
 -		if (!bpf_op)
 -			continue;
 +	/* Remove from the driver */
 +	ndo_bpf = dev->netdev_ops->ndo_bpf;
 +	if (!ndo_bpf)
 +		return;
  
 +	memset(&xdp, 0, sizeof(xdp));
 +	xdp.command = XDP_QUERY_PROG;
 +	WARN_ON(ndo_bpf(dev, &xdp));
 +	if (xdp.prog_id)
 +		WARN_ON(dev_xdp_install(dev, ndo_bpf, NULL, xdp.prog_flags,
 +					NULL));
 +
++<<<<<<< HEAD
 +	/* Remove HW offload */
 +	memset(&xdp, 0, sizeof(xdp));
 +	xdp.command = XDP_QUERY_PROG_HW;
 +	if (!ndo_bpf(dev, &xdp) && xdp.prog_id)
 +		WARN_ON(dev_xdp_install(dev, ndo_bpf, NULL, xdp.prog_flags,
 +					NULL));
++=======
+ 		WARN_ON(dev_xdp_install(dev, mode, bpf_op, NULL, 0, NULL));
+ 
+ 		/* auto-detach link from net device */
+ 		link = dev_xdp_link(dev, mode);
+ 		if (link)
+ 			link->dev = NULL;
+ 		else
+ 			bpf_prog_put(prog);
+ 
+ 		dev_xdp_set_link(dev, mode, NULL);
+ 	}
+ }
+ 
+ static int dev_xdp_attach(struct net_device *dev, struct netlink_ext_ack *extack,
+ 			  struct bpf_xdp_link *link, struct bpf_prog *new_prog,
+ 			  struct bpf_prog *old_prog, u32 flags)
+ {
+ 	unsigned int num_modes = hweight32(flags & XDP_FLAGS_MODES);
+ 	struct bpf_prog *cur_prog;
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 	int err;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	/* either link or prog attachment, never both */
+ 	if (link && (new_prog || old_prog))
+ 		return -EINVAL;
+ 	/* link supports only XDP mode flags */
+ 	if (link && (flags & ~XDP_FLAGS_MODES)) {
+ 		NL_SET_ERR_MSG(extack, "Invalid XDP flags for BPF link attachment");
+ 		return -EINVAL;
+ 	}
+ 	/* just one XDP mode bit should be set, zero defaults to drv/skb mode */
+ 	if (num_modes > 1) {
+ 		NL_SET_ERR_MSG(extack, "Only one XDP mode flag can be set");
+ 		return -EINVAL;
+ 	}
+ 	/* avoid ambiguity if offload + drv/skb mode progs are both loaded */
+ 	if (!num_modes && dev_xdp_prog_count(dev) > 1) {
+ 		NL_SET_ERR_MSG(extack,
+ 			       "More than one program loaded, unset mode is ambiguous");
+ 		return -EINVAL;
+ 	}
+ 	/* old_prog != NULL implies XDP_FLAGS_REPLACE is set */
+ 	if (old_prog && !(flags & XDP_FLAGS_REPLACE)) {
+ 		NL_SET_ERR_MSG(extack, "XDP_FLAGS_REPLACE is not specified");
+ 		return -EINVAL;
+ 	}
+ 
+ 	mode = dev_xdp_mode(dev, flags);
+ 	/* can't replace attached link */
+ 	if (dev_xdp_link(dev, mode)) {
+ 		NL_SET_ERR_MSG(extack, "Can't replace active BPF XDP link");
+ 		return -EBUSY;
+ 	}
+ 
+ 	cur_prog = dev_xdp_prog(dev, mode);
+ 	/* can't replace attached prog with link */
+ 	if (link && cur_prog) {
+ 		NL_SET_ERR_MSG(extack, "Can't replace active XDP program with BPF link");
+ 		return -EBUSY;
+ 	}
+ 	if ((flags & XDP_FLAGS_REPLACE) && cur_prog != old_prog) {
+ 		NL_SET_ERR_MSG(extack, "Active program does not match expected");
+ 		return -EEXIST;
+ 	}
+ 
+ 	/* put effective new program into new_prog */
+ 	if (link)
+ 		new_prog = link->link.prog;
+ 
+ 	if (new_prog) {
+ 		bool offload = mode == XDP_MODE_HW;
+ 		enum bpf_xdp_mode other_mode = mode == XDP_MODE_SKB
+ 					       ? XDP_MODE_DRV : XDP_MODE_SKB;
+ 
+ 		if ((flags & XDP_FLAGS_UPDATE_IF_NOEXIST) && cur_prog) {
+ 			NL_SET_ERR_MSG(extack, "XDP program already attached");
+ 			return -EBUSY;
+ 		}
+ 		if (!offload && dev_xdp_prog(dev, other_mode)) {
+ 			NL_SET_ERR_MSG(extack, "Native and generic XDP can't be active at the same time");
+ 			return -EEXIST;
+ 		}
+ 		if (!offload && bpf_prog_is_dev_bound(new_prog->aux)) {
+ 			NL_SET_ERR_MSG(extack, "Using device-bound program without HW_MODE flag is not supported");
+ 			return -EINVAL;
+ 		}
+ 		if (new_prog->expected_attach_type == BPF_XDP_DEVMAP) {
+ 			NL_SET_ERR_MSG(extack, "BPF_XDP_DEVMAP programs can not be attached to a device");
+ 			return -EINVAL;
+ 		}
+ 		if (new_prog->expected_attach_type == BPF_XDP_CPUMAP) {
+ 			NL_SET_ERR_MSG(extack, "BPF_XDP_CPUMAP programs can not be attached to a device");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/* don't call drivers if the effective program didn't change */
+ 	if (new_prog != cur_prog) {
+ 		bpf_op = dev_xdp_bpf_op(dev, mode);
+ 		if (!bpf_op) {
+ 			NL_SET_ERR_MSG(extack, "Underlying driver does not support XDP in native mode");
+ 			return -EOPNOTSUPP;
+ 		}
+ 
+ 		err = dev_xdp_install(dev, mode, bpf_op, extack, flags, new_prog);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (link)
+ 		dev_xdp_set_link(dev, mode, link);
+ 	else
+ 		dev_xdp_set_prog(dev, mode, new_prog);
+ 	if (cur_prog)
+ 		bpf_prog_put(cur_prog);
+ 
+ 	return 0;
+ }
+ 
+ static int dev_xdp_attach_link(struct net_device *dev,
+ 			       struct netlink_ext_ack *extack,
+ 			       struct bpf_xdp_link *link)
+ {
+ 	return dev_xdp_attach(dev, extack, link, NULL, NULL, link->flags);
+ }
+ 
+ static int dev_xdp_detach_link(struct net_device *dev,
+ 			       struct netlink_ext_ack *extack,
+ 			       struct bpf_xdp_link *link)
+ {
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	mode = dev_xdp_mode(dev, link->flags);
+ 	if (dev_xdp_link(dev, mode) != link)
+ 		return -EINVAL;
+ 
+ 	bpf_op = dev_xdp_bpf_op(dev, mode);
+ 	WARN_ON(dev_xdp_install(dev, mode, bpf_op, NULL, 0, NULL));
+ 	dev_xdp_set_link(dev, mode, NULL);
+ 	return 0;
+ }
+ 
+ static void bpf_xdp_link_release(struct bpf_link *link)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 
+ 	rtnl_lock();
+ 
+ 	/* if racing with net_device's tear down, xdp_link->dev might be
+ 	 * already NULL, in which case link was already auto-detached
+ 	 */
+ 	if (xdp_link->dev) {
+ 		WARN_ON(dev_xdp_detach_link(xdp_link->dev, NULL, xdp_link));
+ 		xdp_link->dev = NULL;
+ 	}
+ 
+ 	rtnl_unlock();
+ }
+ 
+ static int bpf_xdp_link_detach(struct bpf_link *link)
+ {
+ 	bpf_xdp_link_release(link);
+ 	return 0;
+ }
+ 
+ static void bpf_xdp_link_dealloc(struct bpf_link *link)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 
+ 	kfree(xdp_link);
+ }
+ 
+ static void bpf_xdp_link_show_fdinfo(const struct bpf_link *link,
+ 				     struct seq_file *seq)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	u32 ifindex = 0;
+ 
+ 	rtnl_lock();
+ 	if (xdp_link->dev)
+ 		ifindex = xdp_link->dev->ifindex;
+ 	rtnl_unlock();
+ 
+ 	seq_printf(seq, "ifindex:\t%u\n", ifindex);
+ }
+ 
+ static int bpf_xdp_link_fill_link_info(const struct bpf_link *link,
+ 				       struct bpf_link_info *info)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	u32 ifindex = 0;
+ 
+ 	rtnl_lock();
+ 	if (xdp_link->dev)
+ 		ifindex = xdp_link->dev->ifindex;
+ 	rtnl_unlock();
+ 
+ 	info->xdp.ifindex = ifindex;
+ 	return 0;
+ }
+ 
+ static int bpf_xdp_link_update(struct bpf_link *link, struct bpf_prog *new_prog,
+ 			       struct bpf_prog *old_prog)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 	int err = 0;
+ 
+ 	rtnl_lock();
+ 
+ 	/* link might have been auto-released already, so fail */
+ 	if (!xdp_link->dev) {
+ 		err = -ENOLINK;
+ 		goto out_unlock;
+ 	}
+ 
+ 	if (old_prog && link->prog != old_prog) {
+ 		err = -EPERM;
+ 		goto out_unlock;
+ 	}
+ 	old_prog = link->prog;
+ 	if (old_prog == new_prog) {
+ 		/* no-op, don't disturb drivers */
+ 		bpf_prog_put(new_prog);
+ 		goto out_unlock;
+ 	}
+ 
+ 	mode = dev_xdp_mode(xdp_link->dev, xdp_link->flags);
+ 	bpf_op = dev_xdp_bpf_op(xdp_link->dev, mode);
+ 	err = dev_xdp_install(xdp_link->dev, mode, bpf_op, NULL,
+ 			      xdp_link->flags, new_prog);
+ 	if (err)
+ 		goto out_unlock;
+ 
+ 	old_prog = xchg(&link->prog, new_prog);
+ 	bpf_prog_put(old_prog);
+ 
+ out_unlock:
+ 	rtnl_unlock();
+ 	return err;
+ }
+ 
+ static const struct bpf_link_ops bpf_xdp_link_lops = {
+ 	.release = bpf_xdp_link_release,
+ 	.dealloc = bpf_xdp_link_dealloc,
+ 	.detach = bpf_xdp_link_detach,
+ 	.show_fdinfo = bpf_xdp_link_show_fdinfo,
+ 	.fill_link_info = bpf_xdp_link_fill_link_info,
+ 	.update_prog = bpf_xdp_link_update,
+ };
+ 
+ int bpf_xdp_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)
+ {
+ 	struct net *net = current->nsproxy->net_ns;
+ 	struct bpf_link_primer link_primer;
+ 	struct bpf_xdp_link *link;
+ 	struct net_device *dev;
+ 	int err, fd;
+ 
+ 	dev = dev_get_by_index(net, attr->link_create.target_ifindex);
+ 	if (!dev)
+ 		return -EINVAL;
+ 
+ 	link = kzalloc(sizeof(*link), GFP_USER);
+ 	if (!link) {
+ 		err = -ENOMEM;
+ 		goto out_put_dev;
+ 	}
+ 
+ 	bpf_link_init(&link->link, BPF_LINK_TYPE_XDP, &bpf_xdp_link_lops, prog);
+ 	link->dev = dev;
+ 	link->flags = attr->link_create.flags;
+ 
+ 	err = bpf_link_prime(&link->link, &link_primer);
+ 	if (err) {
+ 		kfree(link);
+ 		goto out_put_dev;
+ 	}
+ 
+ 	rtnl_lock();
+ 	err = dev_xdp_attach_link(dev, NULL, link);
+ 	rtnl_unlock();
+ 
+ 	if (err) {
+ 		bpf_link_cleanup(&link_primer);
+ 		goto out_put_dev;
+ 	}
+ 
+ 	fd = bpf_link_settle(&link_primer);
+ 	/* link itself doesn't hold dev's refcnt to not complicate shutdown */
+ 	dev_put(dev);
+ 	return fd;
+ 
+ out_put_dev:
+ 	dev_put(dev);
+ 	return err;
++>>>>>>> 998f17296234 (xdp: Remove the xdp_attachment_flags_ok() callback)
  }
  
  /**
diff --cc net/core/xdp.c
index d97e4dbfd1ca,d900cebc0acd..000000000000
--- a/net/core/xdp.c
+++ b/net/core/xdp.c
@@@ -429,27 -403,6 +429,30 @@@ void __xdp_release_frame(void *data, st
  }
  EXPORT_SYMBOL_GPL(__xdp_release_frame);
  
++<<<<<<< HEAD
 +int xdp_attachment_query(struct xdp_attachment_info *info,
 +			 struct netdev_bpf *bpf)
 +{
 +	bpf->prog_id = info->prog ? info->prog->aux->id : 0;
 +	bpf->prog_flags = info->prog ? info->flags : 0;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(xdp_attachment_query);
 +
 +bool xdp_attachment_flags_ok(struct xdp_attachment_info *info,
 +			     struct netdev_bpf *bpf)
 +{
 +	if (info->prog && (bpf->flags ^ info->flags) & XDP_FLAGS_MODES) {
 +		NL_SET_ERR_MSG(bpf->extack,
 +			       "program loaded with different flags");
 +		return false;
 +	}
 +	return true;
 +}
 +EXPORT_SYMBOL_GPL(xdp_attachment_flags_ok);
 +
++=======
++>>>>>>> 998f17296234 (xdp: Remove the xdp_attachment_flags_ok() callback)
  void xdp_attachment_setup(struct xdp_attachment_info *info,
  			  struct netdev_bpf *bpf)
  {
* Unmerged path drivers/net/ethernet/ti/cpsw_priv.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index ba2f2be90a1b..845d875eea94 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@ -3643,9 +3643,6 @@ static int nfp_net_xdp_setup_drv(struct nfp_net *nn, struct netdev_bpf *bpf)
 	struct nfp_net_dp *dp;
 	int err;
 
-	if (!xdp_attachment_flags_ok(&nn->xdp, bpf))
-		return -EBUSY;
-
 	if (!prog == !nn->dp.xdp_prog) {
 		WRITE_ONCE(nn->dp.xdp_prog, prog);
 		xdp_attachment_setup(&nn->xdp, bpf);
@@ -3674,9 +3671,6 @@ static int nfp_net_xdp_setup_hw(struct nfp_net *nn, struct netdev_bpf *bpf)
 {
 	int err;
 
-	if (!xdp_attachment_flags_ok(&nn->xdp_hw, bpf))
-		return -EBUSY;
-
 	err = nfp_app_xdp_offload(nn->app, nn, bpf->prog, bpf->extack);
 	if (err)
 		return err;
* Unmerged path drivers/net/ethernet/ti/cpsw_priv.c
diff --git a/drivers/net/netdevsim/bpf.c b/drivers/net/netdevsim/bpf.c
index 0b362b8dac17..f599c0a5dafb 100644
--- a/drivers/net/netdevsim/bpf.c
+++ b/drivers/net/netdevsim/bpf.c
@@ -190,9 +190,6 @@ nsim_xdp_set_prog(struct netdevsim *ns, struct netdev_bpf *bpf,
 {
 	int err;
 
-	if (!xdp_attachment_flags_ok(xdp, bpf))
-		return -EBUSY;
-
 	if (bpf->command == XDP_SETUP_PROG && !ns->bpf_xdpdrv_accept) {
 		NSIM_EA(bpf->extack, "driver XDP disabled in DebugFS");
 		return -EOPNOTSUPP;
* Unmerged path include/net/xdp.h
* Unmerged path net/core/dev.c
* Unmerged path net/core/xdp.c
