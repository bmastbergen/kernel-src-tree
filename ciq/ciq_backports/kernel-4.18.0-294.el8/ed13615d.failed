s390/qeth: simplify RX buffer tracking

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit ed13615dd32690ca2a9d1f730a596f950eafd905
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ed13615d.failed

Since RX buffers may contain multiple packets, qeth's NAPI poll code can
exhaust its budget in the middle of an RX buffer. Thus we keep track of
our current position within the active RX buffer, so we can resume
processing here in the next NAPI poll period.

Clean up that code by tracking the index of the active buffer element,
instead of a pointer to it.
Also simplify the code that advances to the next RX buffer when the
current buffer has been fully processed.

v2: - remove QDIO_ELEMENT_NO() macro (davem)

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed13615dd32690ca2a9d1f730a596f950eafd905)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index 7c95b272c820,4f33e4ee49d7..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -5141,14 -5331,16 +5141,25 @@@ static inline int qeth_is_last_sbale(st
  	return (sbale->eflags & SBAL_EFLAGS_LAST_ENTRY);
  }
  
++<<<<<<< HEAD
 +struct sk_buff *qeth_core_get_next_skb(struct qeth_card *card,
 +		struct qeth_qdio_buffer *qethbuffer,
 +		struct qdio_buffer_element **__element, int *__offset,
 +		struct qeth_hdr **hdr)
 +{
 +	struct qdio_buffer_element *element = *__element;
 +	struct qdio_buffer *buffer = qethbuffer->buffer;
++=======
+ static int qeth_extract_skb(struct qeth_card *card,
+ 			    struct qeth_qdio_buffer *qethbuffer, u8 *element_no,
+ 			    int *__offset)
+ {
+ 	struct qeth_priv *priv = netdev_priv(card->dev);
+ 	struct qdio_buffer *buffer = qethbuffer->buffer;
+ 	struct napi_struct *napi = &card->napi;
+ 	struct qdio_buffer_element *element;
++>>>>>>> ed13615dd326 (s390/qeth: simplify RX buffer tracking)
  	unsigned int linear_len = 0;
 -	bool uses_frags = false;
  	int offset = *__offset;
  	bool use_rx_sg = false;
  	unsigned int headroom;
@@@ -5285,16 -5505,33 +5298,40 @@@ walk_packet
  	if (!skb)
  		goto next_packet;
  
- 	*__element = element;
+ 	*element_no = element - &buffer->element[0];
  	*__offset = offset;
++<<<<<<< HEAD
 +	if (use_rx_sg) {
 +		QETH_CARD_STAT_INC(card, rx_sg_skbs);
 +		QETH_CARD_STAT_ADD(card, rx_sg_frags,
 +				   skb_shinfo(skb)->nr_frags);
++=======
+ 
+ 	qeth_receive_skb(card, skb, hdr, uses_frags);
+ 	return 0;
+ }
+ 
+ static int qeth_extract_skbs(struct qeth_card *card, int budget,
+ 			     struct qeth_qdio_buffer *buf, bool *done)
+ {
+ 	int work_done = 0;
+ 
+ 	*done = false;
+ 
+ 	while (budget) {
+ 		if (qeth_extract_skb(card, buf, &card->rx.buf_element,
+ 				     &card->rx.e_offset)) {
+ 			*done = true;
+ 			break;
+ 		}
+ 
+ 		work_done++;
+ 		budget--;
++>>>>>>> ed13615dd326 (s390/qeth: simplify RX buffer tracking)
  	}
 -
 -	return work_done;
 +	return skb;
  }
 +EXPORT_SYMBOL_GPL(qeth_core_get_next_skb);
  
  int qeth_poll(struct napi_struct *napi, int budget)
  {
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index ba2750907b1e..01157eb865c4 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -758,7 +758,7 @@ enum qeth_addr_disposition {
 struct qeth_rx {
 	int b_count;
 	int b_index;
-	struct qdio_buffer_element *b_element;
+	u8 buf_element;
 	int e_offset;
 	int qdio_err;
 };
* Unmerged path drivers/s390/net/qeth_core_main.c
