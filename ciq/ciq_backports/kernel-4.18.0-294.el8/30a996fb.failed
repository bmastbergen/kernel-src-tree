intel_idle: Relocate definitions of cpuidle callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 30a996fbb359ed53536a055af84a54223beabf91
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/30a996fb.failed

Move the definitions of intel_idle() and intel_idle_s2idle() before
the definitions of cpuidle_state structures referring to them to
avoid having to use additional declarations of them (and drop those
declarations).

No functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 30a996fbb359ed53536a055af84a54223beabf91)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/idle/intel_idle.c
diff --cc drivers/idle/intel_idle.c
index adafee3bbdac,e0332d567735..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -902,114 -962,6 +973,117 @@@ static struct cpuidle_state dnv_cstates
  		.enter = NULL }
  };
  
++<<<<<<< HEAD
 +/**
 + * intel_idle - Ask the processor to enter the given idle state.
 + * @dev: cpuidle device of the target CPU.
 + * @drv: cpuidle driver (assumed to point to intel_idle_driver).
 + * @index: Target idle state index.
 + *
 + * Use the MWAIT instruction to notify the processor that the CPU represented by
 + * @dev is idle and it can try to enter the idle state corresponding to @index.
 + *
 + * If the local APIC timer is not known to be reliable in the target idle state,
 + * enable one-shot tick broadcasting for the target CPU before executing MWAIT.
 + *
 + * Optionally call leave_mm() for the target CPU upfront to avoid wakeups due to
 + * flushing user TLBs.
 + *
 + * Must be called under local_irq_disable().
 + */
 +static __cpuidle int intel_idle(struct cpuidle_device *dev,
 +				struct cpuidle_driver *drv, int index)
 +{
 +	struct cpuidle_state *state = &drv->states[index];
 +	unsigned long eax = flg2MWAIT(state->flags);
 +	unsigned long ecx = 1; /* break on interrupt flag */
 +	bool uninitialized_var(tick);
 +	int cpu = smp_processor_id();
 +
 +	/*
 +	 * leave_mm() to avoid costly and often unnecessary wakeups
 +	 * for flushing the user TLB's associated with the active mm.
 +	 */
 +	if (state->flags & CPUIDLE_FLAG_TLB_FLUSHED)
 +		leave_mm(cpu);
 +
 +	if (!static_cpu_has(X86_FEATURE_ARAT) && !lapic_timer_always_reliable) {
 +		/*
 +		 * Switch over to one-shot tick broadcast if the target C-state
 +		 * is deeper than C1.
 +		 */
 +		if ((eax >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) {
 +			tick = true;
 +			tick_broadcast_enter();
 +		} else {
 +			tick = false;
 +		}
 +	}
 +
 +	mwait_idle_with_hints(eax, ecx);
 +
 +	if (!static_cpu_has(X86_FEATURE_ARAT) && tick)
 +		tick_broadcast_exit();
 +
 +	return index;
 +}
 +
 +/**
 + * intel_idle_s2idle - Ask the processor to enter the given idle state.
 + * @dev: cpuidle device of the target CPU.
 + * @drv: cpuidle driver (assumed to point to intel_idle_driver).
 + * @index: Target idle state index.
 + *
 + * Use the MWAIT instruction to notify the processor that the CPU represented by
 + * @dev is idle and it can try to enter the idle state corresponding to @index.
 + *
 + * Invoked as a suspend-to-idle callback routine with frozen user space, frozen
 + * scheduler tick and suspended scheduler clock on the target CPU.
 + */
 +static __cpuidle void intel_idle_s2idle(struct cpuidle_device *dev,
 +					struct cpuidle_driver *drv, int index)
 +{
 +	unsigned long eax = flg2MWAIT(drv->states[index].flags);
 +	unsigned long ecx = 1; /* break on interrupt flag */
 +
 +	mwait_idle_with_hints(eax, ecx);
 +}
 +
 +static bool intel_idle_verify_cstate(unsigned int mwait_hint)
 +{
 +	unsigned int mwait_cstate = MWAIT_HINT2CSTATE(mwait_hint) + 1;
 +	unsigned int num_substates = (mwait_substates >> mwait_cstate * 4) &
 +					MWAIT_SUBSTATE_MASK;
 +
 +	/* Ignore the C-state if there are NO sub-states in CPUID for it. */
 +	if (num_substates == 0)
 +		return false;
 +
 +	if (mwait_cstate > 2 && !boot_cpu_has(X86_FEATURE_NONSTOP_TSC))
 +		mark_tsc_unstable("TSC halts in idle states deeper than C2");
 +
 +	return true;
 +}
 +
 +static void auto_demotion_disable(void)
 +{
 +	unsigned long long msr_bits;
 +
 +	rdmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);
 +	msr_bits &= ~(icpu->auto_demotion_disable_flags);
 +	wrmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);
 +}
 +static void c1e_promotion_disable(void)
 +{
 +	unsigned long long msr_bits;
 +
 +	rdmsrl(MSR_IA32_POWER_CTL, msr_bits);
 +	msr_bits &= ~0x2;
 +	wrmsrl(MSR_IA32_POWER_CTL, msr_bits);
 +}
 +
++=======
++>>>>>>> 30a996fbb359 (intel_idle: Relocate definitions of cpuidle callbacks)
  static const struct idle_cpu idle_cpu_nehalem = {
  	.state_table = nehalem_cstates,
  	.auto_demotion_disable_flags = NHM_C1_AUTO_DEMOTE | NHM_C3_AUTO_DEMOTE,
* Unmerged path drivers/idle/intel_idle.c
