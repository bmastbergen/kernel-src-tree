x86/sgx: Add ptrace() support for the SGX driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jarkko Sakkinen <jarkko@kernel.org>
commit 947c6e11fa4310b31c10016ae9816cdca3f1694e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/947c6e11.failed

Enclave memory is normally inaccessible from outside the enclave. This
makes enclaves hard to debug. However, enclaves can be put in a debug
mode when they are being built. In that mode, enclave data *can* be read
and/or written by using the ENCLS[EDBGRD] and ENCLS[EDBGWR] functions.

This is obviously only for debugging and destroys all the protections
present with normal enclaves. But, enclaves know their own debug status
and can adjust their behavior appropriately.

Add a vm_ops->access() implementation which can be used to read and write
memory inside debug enclaves.  This is typically used via ptrace() APIs.

 [ bp: Massage. ]

	Signed-off-by: Jarkko Sakkinen <jarkko@kernel.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Tested-by: Jethro Beekman <jethro@fortanix.com>
Link: https://lkml.kernel.org/r/20201112220135.165028-23-jarkko@kernel.org
(cherry picked from commit 947c6e11fa4310b31c10016ae9816cdca3f1694e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/sgx/encl.c
diff --cc arch/x86/kernel/cpu/sgx/encl.c
index b9d445db7ff1,ee50a5010277..000000000000
--- a/arch/x86/kernel/cpu/sgx/encl.c
+++ b/arch/x86/kernel/cpu/sgx/encl.c
@@@ -143,4 -385,356 +253,9 @@@ out
  const struct vm_operations_struct sgx_vm_ops = {
  	.fault = sgx_vma_fault,
  	.mprotect = sgx_vma_mprotect,
++<<<<<<< HEAD
++=======
+ 	.open = sgx_vma_open,
+ 	.access = sgx_vma_access,
++>>>>>>> 947c6e11fa43 (x86/sgx: Add ptrace() support for the SGX driver)
  };
 -
 -/**
 - * sgx_encl_release - Destroy an enclave instance
 - * @kref:	address of a kref inside &sgx_encl
 - *
 - * Used together with kref_put(). Frees all the resources associated with the
 - * enclave and the instance itself.
 - */
 -void sgx_encl_release(struct kref *ref)
 -{
 -	struct sgx_encl *encl = container_of(ref, struct sgx_encl, refcount);
 -	struct sgx_va_page *va_page;
 -	struct sgx_encl_page *entry;
 -	unsigned long index;
 -
 -	xa_for_each(&encl->page_array, index, entry) {
 -		if (entry->epc_page) {
 -			/*
 -			 * The page and its radix tree entry cannot be freed
 -			 * if the page is being held by the reclaimer.
 -			 */
 -			if (sgx_unmark_page_reclaimable(entry->epc_page))
 -				continue;
 -
 -			sgx_free_epc_page(entry->epc_page);
 -			encl->secs_child_cnt--;
 -			entry->epc_page = NULL;
 -		}
 -
 -		kfree(entry);
 -	}
 -
 -	xa_destroy(&encl->page_array);
 -
 -	if (!encl->secs_child_cnt && encl->secs.epc_page) {
 -		sgx_free_epc_page(encl->secs.epc_page);
 -		encl->secs.epc_page = NULL;
 -	}
 -
 -	while (!list_empty(&encl->va_pages)) {
 -		va_page = list_first_entry(&encl->va_pages, struct sgx_va_page,
 -					   list);
 -		list_del(&va_page->list);
 -		sgx_free_epc_page(va_page->epc_page);
 -		kfree(va_page);
 -	}
 -
 -	if (encl->backing)
 -		fput(encl->backing);
 -
 -	cleanup_srcu_struct(&encl->srcu);
 -
 -	WARN_ON_ONCE(!list_empty(&encl->mm_list));
 -
 -	/* Detect EPC page leak's. */
 -	WARN_ON_ONCE(encl->secs_child_cnt);
 -	WARN_ON_ONCE(encl->secs.epc_page);
 -
 -	kfree(encl);
 -}
 -
 -/*
 - * 'mm' is exiting and no longer needs mmu notifications.
 - */
 -static void sgx_mmu_notifier_release(struct mmu_notifier *mn,
 -				     struct mm_struct *mm)
 -{
 -	struct sgx_encl_mm *encl_mm = container_of(mn, struct sgx_encl_mm, mmu_notifier);
 -	struct sgx_encl_mm *tmp = NULL;
 -
 -	/*
 -	 * The enclave itself can remove encl_mm.  Note, objects can't be moved
 -	 * off an RCU protected list, but deletion is ok.
 -	 */
 -	spin_lock(&encl_mm->encl->mm_lock);
 -	list_for_each_entry(tmp, &encl_mm->encl->mm_list, list) {
 -		if (tmp == encl_mm) {
 -			list_del_rcu(&encl_mm->list);
 -			break;
 -		}
 -	}
 -	spin_unlock(&encl_mm->encl->mm_lock);
 -
 -	if (tmp == encl_mm) {
 -		synchronize_srcu(&encl_mm->encl->srcu);
 -		mmu_notifier_put(mn);
 -	}
 -}
 -
 -static void sgx_mmu_notifier_free(struct mmu_notifier *mn)
 -{
 -	struct sgx_encl_mm *encl_mm = container_of(mn, struct sgx_encl_mm, mmu_notifier);
 -
 -	kfree(encl_mm);
 -}
 -
 -static const struct mmu_notifier_ops sgx_mmu_notifier_ops = {
 -	.release		= sgx_mmu_notifier_release,
 -	.free_notifier		= sgx_mmu_notifier_free,
 -};
 -
 -static struct sgx_encl_mm *sgx_encl_find_mm(struct sgx_encl *encl,
 -					    struct mm_struct *mm)
 -{
 -	struct sgx_encl_mm *encl_mm = NULL;
 -	struct sgx_encl_mm *tmp;
 -	int idx;
 -
 -	idx = srcu_read_lock(&encl->srcu);
 -
 -	list_for_each_entry_rcu(tmp, &encl->mm_list, list) {
 -		if (tmp->mm == mm) {
 -			encl_mm = tmp;
 -			break;
 -		}
 -	}
 -
 -	srcu_read_unlock(&encl->srcu, idx);
 -
 -	return encl_mm;
 -}
 -
 -int sgx_encl_mm_add(struct sgx_encl *encl, struct mm_struct *mm)
 -{
 -	struct sgx_encl_mm *encl_mm;
 -	int ret;
 -
 -	/*
 -	 * Even though a single enclave may be mapped into an mm more than once,
 -	 * each 'mm' only appears once on encl->mm_list. This is guaranteed by
 -	 * holding the mm's mmap lock for write before an mm can be added or
 -	 * remove to an encl->mm_list.
 -	 */
 -	mmap_assert_write_locked(mm);
 -
 -	/*
 -	 * It's possible that an entry already exists in the mm_list, because it
 -	 * is removed only on VFS release or process exit.
 -	 */
 -	if (sgx_encl_find_mm(encl, mm))
 -		return 0;
 -
 -	encl_mm = kzalloc(sizeof(*encl_mm), GFP_KERNEL);
 -	if (!encl_mm)
 -		return -ENOMEM;
 -
 -	encl_mm->encl = encl;
 -	encl_mm->mm = mm;
 -	encl_mm->mmu_notifier.ops = &sgx_mmu_notifier_ops;
 -
 -	ret = __mmu_notifier_register(&encl_mm->mmu_notifier, mm);
 -	if (ret) {
 -		kfree(encl_mm);
 -		return ret;
 -	}
 -
 -	spin_lock(&encl->mm_lock);
 -	list_add_rcu(&encl_mm->list, &encl->mm_list);
 -	/* Pairs with smp_rmb() in sgx_reclaimer_block(). */
 -	smp_wmb();
 -	encl->mm_list_version++;
 -	spin_unlock(&encl->mm_lock);
 -
 -	return 0;
 -}
 -
 -static struct page *sgx_encl_get_backing_page(struct sgx_encl *encl,
 -					      pgoff_t index)
 -{
 -	struct inode *inode = encl->backing->f_path.dentry->d_inode;
 -	struct address_space *mapping = inode->i_mapping;
 -	gfp_t gfpmask = mapping_gfp_mask(mapping);
 -
 -	return shmem_read_mapping_page_gfp(mapping, index, gfpmask);
 -}
 -
 -/**
 - * sgx_encl_get_backing() - Pin the backing storage
 - * @encl:	an enclave pointer
 - * @page_index:	enclave page index
 - * @backing:	data for accessing backing storage for the page
 - *
 - * Pin the backing storage pages for storing the encrypted contents and Paging
 - * Crypto MetaData (PCMD) of an enclave page.
 - *
 - * Return:
 - *   0 on success,
 - *   -errno otherwise.
 - */
 -int sgx_encl_get_backing(struct sgx_encl *encl, unsigned long page_index,
 -			 struct sgx_backing *backing)
 -{
 -	pgoff_t pcmd_index = PFN_DOWN(encl->size) + 1 + (page_index >> 5);
 -	struct page *contents;
 -	struct page *pcmd;
 -
 -	contents = sgx_encl_get_backing_page(encl, page_index);
 -	if (IS_ERR(contents))
 -		return PTR_ERR(contents);
 -
 -	pcmd = sgx_encl_get_backing_page(encl, pcmd_index);
 -	if (IS_ERR(pcmd)) {
 -		put_page(contents);
 -		return PTR_ERR(pcmd);
 -	}
 -
 -	backing->page_index = page_index;
 -	backing->contents = contents;
 -	backing->pcmd = pcmd;
 -	backing->pcmd_offset =
 -		(page_index & (PAGE_SIZE / sizeof(struct sgx_pcmd) - 1)) *
 -		sizeof(struct sgx_pcmd);
 -
 -	return 0;
 -}
 -
 -/**
 - * sgx_encl_put_backing() - Unpin the backing storage
 - * @backing:	data for accessing backing storage for the page
 - * @do_write:	mark pages dirty
 - */
 -void sgx_encl_put_backing(struct sgx_backing *backing, bool do_write)
 -{
 -	if (do_write) {
 -		set_page_dirty(backing->pcmd);
 -		set_page_dirty(backing->contents);
 -	}
 -
 -	put_page(backing->pcmd);
 -	put_page(backing->contents);
 -}
 -
 -static int sgx_encl_test_and_clear_young_cb(pte_t *ptep, unsigned long addr,
 -					    void *data)
 -{
 -	pte_t pte;
 -	int ret;
 -
 -	ret = pte_young(*ptep);
 -	if (ret) {
 -		pte = pte_mkold(*ptep);
 -		set_pte_at((struct mm_struct *)data, addr, ptep, pte);
 -	}
 -
 -	return ret;
 -}
 -
 -/**
 - * sgx_encl_test_and_clear_young() - Test and reset the accessed bit
 - * @mm:		mm_struct that is checked
 - * @page:	enclave page to be tested for recent access
 - *
 - * Checks the Access (A) bit from the PTE corresponding to the enclave page and
 - * clears it.
 - *
 - * Return: 1 if the page has been recently accessed and 0 if not.
 - */
 -int sgx_encl_test_and_clear_young(struct mm_struct *mm,
 -				  struct sgx_encl_page *page)
 -{
 -	unsigned long addr = page->desc & PAGE_MASK;
 -	struct sgx_encl *encl = page->encl;
 -	struct vm_area_struct *vma;
 -	int ret;
 -
 -	ret = sgx_encl_find(mm, addr, &vma);
 -	if (ret)
 -		return 0;
 -
 -	if (encl != vma->vm_private_data)
 -		return 0;
 -
 -	ret = apply_to_page_range(vma->vm_mm, addr, PAGE_SIZE,
 -				  sgx_encl_test_and_clear_young_cb, vma->vm_mm);
 -	if (ret < 0)
 -		return 0;
 -
 -	return ret;
 -}
 -
 -/**
 - * sgx_alloc_va_page() - Allocate a Version Array (VA) page
 - *
 - * Allocate a free EPC page and convert it to a Version Array (VA) page.
 - *
 - * Return:
 - *   a VA page,
 - *   -errno otherwise
 - */
 -struct sgx_epc_page *sgx_alloc_va_page(void)
 -{
 -	struct sgx_epc_page *epc_page;
 -	int ret;
 -
 -	epc_page = sgx_alloc_epc_page(NULL, true);
 -	if (IS_ERR(epc_page))
 -		return ERR_CAST(epc_page);
 -
 -	ret = __epa(sgx_get_epc_virt_addr(epc_page));
 -	if (ret) {
 -		WARN_ONCE(1, "EPA returned %d (0x%x)", ret, ret);
 -		sgx_free_epc_page(epc_page);
 -		return ERR_PTR(-EFAULT);
 -	}
 -
 -	return epc_page;
 -}
 -
 -/**
 - * sgx_alloc_va_slot - allocate a VA slot
 - * @va_page:	a &struct sgx_va_page instance
 - *
 - * Allocates a slot from a &struct sgx_va_page instance.
 - *
 - * Return: offset of the slot inside the VA page
 - */
 -unsigned int sgx_alloc_va_slot(struct sgx_va_page *va_page)
 -{
 -	int slot = find_first_zero_bit(va_page->slots, SGX_VA_SLOT_COUNT);
 -
 -	if (slot < SGX_VA_SLOT_COUNT)
 -		set_bit(slot, va_page->slots);
 -
 -	return slot << 3;
 -}
 -
 -/**
 - * sgx_free_va_slot - free a VA slot
 - * @va_page:	a &struct sgx_va_page instance
 - * @offset:	offset of the slot inside the VA page
 - *
 - * Frees a slot from a &struct sgx_va_page instance.
 - */
 -void sgx_free_va_slot(struct sgx_va_page *va_page, unsigned int offset)
 -{
 -	clear_bit(offset >> 3, va_page->slots);
 -}
 -
 -/**
 - * sgx_va_page_full - is the VA page full?
 - * @va_page:	a &struct sgx_va_page instance
 - *
 - * Return: true if all slots have been taken
 - */
 -bool sgx_va_page_full(struct sgx_va_page *va_page)
 -{
 -	int slot = find_first_zero_bit(va_page->slots, SGX_VA_SLOT_COUNT);
 -
 -	return slot == SGX_VA_SLOT_COUNT;
 -}
* Unmerged path arch/x86/kernel/cpu/sgx/encl.c
