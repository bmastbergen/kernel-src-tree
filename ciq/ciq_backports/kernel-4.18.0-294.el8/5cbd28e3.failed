block: move disk_name and related helpers out of partition-generic.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 5cbd28e3cef14b43b2a8271d36b75fc61c13bb8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5cbd28e3.failed

Thes functions aren't really related to partition support, so move them
to a more suitable place.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 5cbd28e3cef14b43b2a8271d36b75fc61c13bb8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/bio.c
diff --cc block/bio.c
index 79cc1ab17bc5,209715765a7a..000000000000
--- a/block/bio.c
+++ b/block/bio.c
@@@ -702,8 -680,49 +702,52 @@@ struct bio *bio_clone_fast(struct bio *
  }
  EXPORT_SYMBOL(bio_clone_fast);
  
++<<<<<<< HEAD
++=======
+ const char *bio_devname(struct bio *bio, char *buf)
+ {
+ 	return disk_name(bio->bi_disk, bio->bi_partno, buf);
+ }
+ EXPORT_SYMBOL(bio_devname);
+ 
+ static inline bool page_is_mergeable(const struct bio_vec *bv,
+ 		struct page *page, unsigned int len, unsigned int off,
+ 		bool *same_page)
+ {
+ 	phys_addr_t vec_end_addr = page_to_phys(bv->bv_page) +
+ 		bv->bv_offset + bv->bv_len - 1;
+ 	phys_addr_t page_addr = page_to_phys(page);
+ 
+ 	if (vec_end_addr + 1 != page_addr + off)
+ 		return false;
+ 	if (xen_domain() && !xen_biovec_phys_mergeable(bv, page))
+ 		return false;
+ 
+ 	*same_page = ((vec_end_addr & PAGE_MASK) == page_addr);
+ 	if (!*same_page && pfn_to_page(PFN_DOWN(vec_end_addr)) + 1 != page)
+ 		return false;
+ 	return true;
+ }
+ 
+ static bool bio_try_merge_pc_page(struct request_queue *q, struct bio *bio,
+ 		struct page *page, unsigned len, unsigned offset,
+ 		bool *same_page)
+ {
+ 	struct bio_vec *bv = &bio->bi_io_vec[bio->bi_vcnt - 1];
+ 	unsigned long mask = queue_segment_boundary(q);
+ 	phys_addr_t addr1 = page_to_phys(bv->bv_page) + bv->bv_offset;
+ 	phys_addr_t addr2 = page_to_phys(page) + offset + len - 1;
+ 
+ 	if ((addr1 | mask) != (addr2 | mask))
+ 		return false;
+ 	if (bv->bv_len + len > queue_max_segment_size(q))
+ 		return false;
+ 	return __bio_try_merge_page(bio, page, len, offset, same_page);
+ }
+ 
++>>>>>>> 5cbd28e3cef1 (block: move disk_name and related helpers out of partition-generic.c)
  /**
 - *	__bio_add_pc_page	- attempt to add page to passthrough bio
 + *	bio_add_pc_page	-	attempt to add page to bio
   *	@q: the target queue
   *	@bio: destination bio
   *	@page: page to add
* Unmerged path block/bio.c
diff --git a/block/genhd.c b/block/genhd.c
index b777d4d99066..680b3866f73e 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -68,6 +68,27 @@ void set_capacity_revalidate_and_notify(struct gendisk *disk, sector_t size,
 
 EXPORT_SYMBOL_GPL(set_capacity_revalidate_and_notify);
 
+/*
+ * Format the device name of the indicated disk into the supplied buffer and
+ * return a pointer to that same buffer for convenience.
+ */
+char *disk_name(struct gendisk *hd, int partno, char *buf)
+{
+	if (!partno)
+		snprintf(buf, BDEVNAME_SIZE, "%s", hd->disk_name);
+	else if (isdigit(hd->disk_name[strlen(hd->disk_name)-1]))
+		snprintf(buf, BDEVNAME_SIZE, "%sp%d", hd->disk_name, partno);
+	else
+		snprintf(buf, BDEVNAME_SIZE, "%s%d", hd->disk_name, partno);
+
+	return buf;
+}
+
+const char *bdevname(struct block_device *bdev, char *buf)
+{
+	return disk_name(bdev->bd_disk, bdev->bd_part->partno, buf);
+}
+EXPORT_SYMBOL(bdevname);
 
 void part_inc_in_flight(struct request_queue *q, struct hd_struct *part, int rw)
 {
diff --git a/block/partition-generic.c b/block/partition-generic.c
index 4fc72fc8f250..4b33ee7df639 100644
--- a/block/partition-generic.c
+++ b/block/partition-generic.c
@@ -25,38 +25,6 @@
 extern void md_autodetect_dev(dev_t dev);
 #endif
  
-/*
- * disk_name() is used by partition check code and the genhd driver.
- * It formats the devicename of the indicated disk into
- * the supplied buffer (of size at least 32), and returns
- * a pointer to that same buffer (for convenience).
- */
-
-char *disk_name(struct gendisk *hd, int partno, char *buf)
-{
-	if (!partno)
-		snprintf(buf, BDEVNAME_SIZE, "%s", hd->disk_name);
-	else if (isdigit(hd->disk_name[strlen(hd->disk_name)-1]))
-		snprintf(buf, BDEVNAME_SIZE, "%sp%d", hd->disk_name, partno);
-	else
-		snprintf(buf, BDEVNAME_SIZE, "%s%d", hd->disk_name, partno);
-
-	return buf;
-}
-
-const char *bdevname(struct block_device *bdev, char *buf)
-{
-	return disk_name(bdev->bd_disk, bdev->bd_part->partno, buf);
-}
-
-EXPORT_SYMBOL(bdevname);
-
-const char *bio_devname(struct bio *bio, char *buf)
-{
-	return disk_name(bio->bi_disk, bio->bi_partno, buf);
-}
-EXPORT_SYMBOL(bio_devname);
-
 static ssize_t part_partition_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
