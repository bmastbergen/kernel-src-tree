bpf: Implement BPF XDP link-specific introspection APIs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit c1931c9784ebb5787c0784c112fb8baa5e8455b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c1931c97.failed

Implement XDP link-specific show_fdinfo and link_info to emit ifindex.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200722064603.3350758-7-andriin@fb.com
(cherry picked from commit c1931c9784ebb5787c0784c112fb8baa5e8455b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	net/core/dev.c
diff --cc include/uapi/linux/bpf.h
index 55fe65639ff2,e1ba4ae6a916..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -3735,6 -4065,13 +3735,16 @@@ struct bpf_link_info 
  			__u64 cgroup_id;
  			__u32 attach_type;
  		} cgroup;
++<<<<<<< HEAD
++=======
+ 		struct  {
+ 			__u32 netns_ino;
+ 			__u32 attach_type;
+ 		} netns;
+ 		struct {
+ 			__u32 ifindex;
+ 		} xdp;
++>>>>>>> c1931c9784eb (bpf: Implement BPF XDP link-specific introspection APIs)
  	};
  } __attribute__((aligned(8)));
  
diff --cc net/core/dev.c
index 2404a0d99788,82ce0920b172..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -8284,30 -8817,309 +8284,320 @@@ static int dev_xdp_install(struct net_d
  
  static void dev_xdp_uninstall(struct net_device *dev)
  {
 -	struct bpf_xdp_link *link;
 -	struct bpf_prog *prog;
 -	enum bpf_xdp_mode mode;
 -	bpf_op_t bpf_op;
 +	struct netdev_bpf xdp;
 +	bpf_op_t ndo_bpf;
  
 -	ASSERT_RTNL();
 +	/* Remove generic XDP */
 +	WARN_ON(dev_xdp_install(dev, generic_xdp_install, NULL, 0, NULL));
  
 -	for (mode = XDP_MODE_SKB; mode < __MAX_XDP_MODE; mode++) {
 -		prog = dev_xdp_prog(dev, mode);
 -		if (!prog)
 -			continue;
 -
 -		bpf_op = dev_xdp_bpf_op(dev, mode);
 -		if (!bpf_op)
 -			continue;
 +	/* Remove from the driver */
 +	ndo_bpf = dev->netdev_ops->ndo_bpf;
 +	if (!ndo_bpf)
 +		return;
  
 +	memset(&xdp, 0, sizeof(xdp));
 +	xdp.command = XDP_QUERY_PROG;
 +	WARN_ON(ndo_bpf(dev, &xdp));
 +	if (xdp.prog_id)
 +		WARN_ON(dev_xdp_install(dev, ndo_bpf, NULL, xdp.prog_flags,
 +					NULL));
 +
++<<<<<<< HEAD
 +	/* Remove HW offload */
 +	memset(&xdp, 0, sizeof(xdp));
 +	xdp.command = XDP_QUERY_PROG_HW;
 +	if (!ndo_bpf(dev, &xdp) && xdp.prog_id)
 +		WARN_ON(dev_xdp_install(dev, ndo_bpf, NULL, xdp.prog_flags,
 +					NULL));
++=======
+ 		WARN_ON(dev_xdp_install(dev, mode, bpf_op, NULL, 0, NULL));
+ 
+ 		/* auto-detach link from net device */
+ 		link = dev_xdp_link(dev, mode);
+ 		if (link)
+ 			link->dev = NULL;
+ 		else
+ 			bpf_prog_put(prog);
+ 
+ 		dev_xdp_set_link(dev, mode, NULL);
+ 	}
+ }
+ 
+ static int dev_xdp_attach(struct net_device *dev, struct netlink_ext_ack *extack,
+ 			  struct bpf_xdp_link *link, struct bpf_prog *new_prog,
+ 			  struct bpf_prog *old_prog, u32 flags)
+ {
+ 	struct bpf_prog *cur_prog;
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 	int err;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	/* either link or prog attachment, never both */
+ 	if (link && (new_prog || old_prog))
+ 		return -EINVAL;
+ 	/* link supports only XDP mode flags */
+ 	if (link && (flags & ~XDP_FLAGS_MODES)) {
+ 		NL_SET_ERR_MSG(extack, "Invalid XDP flags for BPF link attachment");
+ 		return -EINVAL;
+ 	}
+ 	/* just one XDP mode bit should be set, zero defaults to SKB mode */
+ 	if (hweight32(flags & XDP_FLAGS_MODES) > 1) {
+ 		NL_SET_ERR_MSG(extack, "Only one XDP mode flag can be set");
+ 		return -EINVAL;
+ 	}
+ 	/* old_prog != NULL implies XDP_FLAGS_REPLACE is set */
+ 	if (old_prog && !(flags & XDP_FLAGS_REPLACE)) {
+ 		NL_SET_ERR_MSG(extack, "XDP_FLAGS_REPLACE is not specified");
+ 		return -EINVAL;
+ 	}
+ 
+ 	mode = dev_xdp_mode(flags);
+ 	/* can't replace attached link */
+ 	if (dev_xdp_link(dev, mode)) {
+ 		NL_SET_ERR_MSG(extack, "Can't replace active BPF XDP link");
+ 		return -EBUSY;
+ 	}
+ 
+ 	cur_prog = dev_xdp_prog(dev, mode);
+ 	/* can't replace attached prog with link */
+ 	if (link && cur_prog) {
+ 		NL_SET_ERR_MSG(extack, "Can't replace active XDP program with BPF link");
+ 		return -EBUSY;
+ 	}
+ 	if ((flags & XDP_FLAGS_REPLACE) && cur_prog != old_prog) {
+ 		NL_SET_ERR_MSG(extack, "Active program does not match expected");
+ 		return -EEXIST;
+ 	}
+ 	if ((flags & XDP_FLAGS_UPDATE_IF_NOEXIST) && cur_prog) {
+ 		NL_SET_ERR_MSG(extack, "XDP program already attached");
+ 		return -EBUSY;
+ 	}
+ 
+ 	/* put effective new program into new_prog */
+ 	if (link)
+ 		new_prog = link->link.prog;
+ 
+ 	if (new_prog) {
+ 		bool offload = mode == XDP_MODE_HW;
+ 		enum bpf_xdp_mode other_mode = mode == XDP_MODE_SKB
+ 					       ? XDP_MODE_DRV : XDP_MODE_SKB;
+ 
+ 		if (!offload && dev_xdp_prog(dev, other_mode)) {
+ 			NL_SET_ERR_MSG(extack, "Native and generic XDP can't be active at the same time");
+ 			return -EEXIST;
+ 		}
+ 		if (!offload && bpf_prog_is_dev_bound(new_prog->aux)) {
+ 			NL_SET_ERR_MSG(extack, "Using device-bound program without HW_MODE flag is not supported");
+ 			return -EINVAL;
+ 		}
+ 		if (new_prog->expected_attach_type == BPF_XDP_DEVMAP) {
+ 			NL_SET_ERR_MSG(extack, "BPF_XDP_DEVMAP programs can not be attached to a device");
+ 			return -EINVAL;
+ 		}
+ 		if (new_prog->expected_attach_type == BPF_XDP_CPUMAP) {
+ 			NL_SET_ERR_MSG(extack, "BPF_XDP_CPUMAP programs can not be attached to a device");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/* don't call drivers if the effective program didn't change */
+ 	if (new_prog != cur_prog) {
+ 		bpf_op = dev_xdp_bpf_op(dev, mode);
+ 		if (!bpf_op) {
+ 			NL_SET_ERR_MSG(extack, "Underlying driver does not support XDP in native mode");
+ 			return -EOPNOTSUPP;
+ 		}
+ 
+ 		err = dev_xdp_install(dev, mode, bpf_op, extack, flags, new_prog);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (link)
+ 		dev_xdp_set_link(dev, mode, link);
+ 	else
+ 		dev_xdp_set_prog(dev, mode, new_prog);
+ 	if (cur_prog)
+ 		bpf_prog_put(cur_prog);
+ 
+ 	return 0;
+ }
+ 
+ static int dev_xdp_attach_link(struct net_device *dev,
+ 			       struct netlink_ext_ack *extack,
+ 			       struct bpf_xdp_link *link)
+ {
+ 	return dev_xdp_attach(dev, extack, link, NULL, NULL, link->flags);
+ }
+ 
+ static int dev_xdp_detach_link(struct net_device *dev,
+ 			       struct netlink_ext_ack *extack,
+ 			       struct bpf_xdp_link *link)
+ {
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	mode = dev_xdp_mode(link->flags);
+ 	if (dev_xdp_link(dev, mode) != link)
+ 		return -EINVAL;
+ 
+ 	bpf_op = dev_xdp_bpf_op(dev, mode);
+ 	WARN_ON(dev_xdp_install(dev, mode, bpf_op, NULL, 0, NULL));
+ 	dev_xdp_set_link(dev, mode, NULL);
+ 	return 0;
+ }
+ 
+ static void bpf_xdp_link_release(struct bpf_link *link)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 
+ 	rtnl_lock();
+ 
+ 	/* if racing with net_device's tear down, xdp_link->dev might be
+ 	 * already NULL, in which case link was already auto-detached
+ 	 */
+ 	if (xdp_link->dev)
+ 		WARN_ON(dev_xdp_detach_link(xdp_link->dev, NULL, xdp_link));
+ 
+ 	rtnl_unlock();
+ }
+ 
+ static void bpf_xdp_link_dealloc(struct bpf_link *link)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 
+ 	kfree(xdp_link);
+ }
+ 
+ static void bpf_xdp_link_show_fdinfo(const struct bpf_link *link,
+ 				     struct seq_file *seq)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	u32 ifindex = 0;
+ 
+ 	rtnl_lock();
+ 	if (xdp_link->dev)
+ 		ifindex = xdp_link->dev->ifindex;
+ 	rtnl_unlock();
+ 
+ 	seq_printf(seq, "ifindex:\t%u\n", ifindex);
+ }
+ 
+ static int bpf_xdp_link_fill_link_info(const struct bpf_link *link,
+ 				       struct bpf_link_info *info)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	u32 ifindex = 0;
+ 
+ 	rtnl_lock();
+ 	if (xdp_link->dev)
+ 		ifindex = xdp_link->dev->ifindex;
+ 	rtnl_unlock();
+ 
+ 	info->xdp.ifindex = ifindex;
+ 	return 0;
+ }
+ 
+ static int bpf_xdp_link_update(struct bpf_link *link, struct bpf_prog *new_prog,
+ 			       struct bpf_prog *old_prog)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 	int err = 0;
+ 
+ 	rtnl_lock();
+ 
+ 	/* link might have been auto-released already, so fail */
+ 	if (!xdp_link->dev) {
+ 		err = -ENOLINK;
+ 		goto out_unlock;
+ 	}
+ 
+ 	if (old_prog && link->prog != old_prog) {
+ 		err = -EPERM;
+ 		goto out_unlock;
+ 	}
+ 	old_prog = link->prog;
+ 	if (old_prog == new_prog) {
+ 		/* no-op, don't disturb drivers */
+ 		bpf_prog_put(new_prog);
+ 		goto out_unlock;
+ 	}
+ 
+ 	mode = dev_xdp_mode(xdp_link->flags);
+ 	bpf_op = dev_xdp_bpf_op(xdp_link->dev, mode);
+ 	err = dev_xdp_install(xdp_link->dev, mode, bpf_op, NULL,
+ 			      xdp_link->flags, new_prog);
+ 	if (err)
+ 		goto out_unlock;
+ 
+ 	old_prog = xchg(&link->prog, new_prog);
+ 	bpf_prog_put(old_prog);
+ 
+ out_unlock:
+ 	rtnl_unlock();
+ 	return err;
+ }
+ 
+ static const struct bpf_link_ops bpf_xdp_link_lops = {
+ 	.release = bpf_xdp_link_release,
+ 	.dealloc = bpf_xdp_link_dealloc,
+ 	.show_fdinfo = bpf_xdp_link_show_fdinfo,
+ 	.fill_link_info = bpf_xdp_link_fill_link_info,
+ 	.update_prog = bpf_xdp_link_update,
+ };
+ 
+ int bpf_xdp_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)
+ {
+ 	struct net *net = current->nsproxy->net_ns;
+ 	struct bpf_link_primer link_primer;
+ 	struct bpf_xdp_link *link;
+ 	struct net_device *dev;
+ 	int err, fd;
+ 
+ 	dev = dev_get_by_index(net, attr->link_create.target_ifindex);
+ 	if (!dev)
+ 		return -EINVAL;
+ 
+ 	link = kzalloc(sizeof(*link), GFP_USER);
+ 	if (!link) {
+ 		err = -ENOMEM;
+ 		goto out_put_dev;
+ 	}
+ 
+ 	bpf_link_init(&link->link, BPF_LINK_TYPE_XDP, &bpf_xdp_link_lops, prog);
+ 	link->dev = dev;
+ 	link->flags = attr->link_create.flags;
+ 
+ 	err = bpf_link_prime(&link->link, &link_primer);
+ 	if (err) {
+ 		kfree(link);
+ 		goto out_put_dev;
+ 	}
+ 
+ 	rtnl_lock();
+ 	err = dev_xdp_attach_link(dev, NULL, link);
+ 	rtnl_unlock();
+ 
+ 	if (err) {
+ 		bpf_link_cleanup(&link_primer);
+ 		goto out_put_dev;
+ 	}
+ 
+ 	fd = bpf_link_settle(&link_primer);
+ 	/* link itself doesn't hold dev's refcnt to not complicate shutdown */
+ 	dev_put(dev);
+ 	return fd;
+ 
+ out_put_dev:
+ 	dev_put(dev);
+ 	return err;
++>>>>>>> c1931c9784eb (bpf: Implement BPF XDP link-specific introspection APIs)
  }
  
  /**
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path net/core/dev.c
