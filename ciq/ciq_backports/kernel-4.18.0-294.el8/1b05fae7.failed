libceph: switch to the new "osd blocklist add" command

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 1b05fae7f29db4c41864aed903865086e070fa89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1b05fae7.failed

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 1b05fae7f29db4c41864aed903865086e070fa89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/mon_client.c
diff --cc net/ceph/mon_client.c
index 3d8c8015e976,c4cf2529d08b..000000000000
--- a/net/ceph/mon_client.c
+++ b/net/ceph/mon_client.c
@@@ -896,8 -896,9 +896,14 @@@ bad
  	ceph_msg_dump(msg);
  }
  
++<<<<<<< HEAD
 +int ceph_monc_blacklist_add(struct ceph_mon_client *monc,
 +			    struct ceph_entity_addr *client_addr)
++=======
+ static __printf(2, 0)
+ int do_mon_command_vargs(struct ceph_mon_client *monc, const char *fmt,
+ 			 va_list ap)
++>>>>>>> 1b05fae7f29d (libceph: switch to the new "osd blocklist add" command)
  {
  	struct ceph_mon_generic_request *req;
  	struct ceph_mon_command *h;
@@@ -934,20 -932,59 +937,75 @@@
  	mutex_unlock(&monc->mutex);
  
  	ret = wait_generic_request(req);
++<<<<<<< HEAD
 +	if (!ret)
 +		/*
 +		 * Make sure we have the osdmap that includes the blacklist
 +		 * entry.  This is needed to ensure that the OSDs pick up the
 +		 * new blacklist before processing any future requests from
 +		 * this client.
 +		 */
 +		ret = ceph_wait_for_latest_osdmap(monc->client, 0);
 +
++=======
++>>>>>>> 1b05fae7f29d (libceph: switch to the new "osd blocklist add" command)
  out:
  	put_generic_request(req);
  	return ret;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(ceph_monc_blacklist_add);
++=======
+ 
+ static __printf(2, 3)
+ int do_mon_command(struct ceph_mon_client *monc, const char *fmt, ...)
+ {
+ 	va_list ap;
+ 	int ret;
+ 
+ 	va_start(ap, fmt);
+ 	ret = do_mon_command_vargs(monc, fmt, ap);
+ 	va_end(ap);
+ 	return ret;
+ }
+ 
+ int ceph_monc_blocklist_add(struct ceph_mon_client *monc,
+ 			    struct ceph_entity_addr *client_addr)
+ {
+ 	int ret;
+ 
+ 	ret = do_mon_command(monc,
+ 			     "{ \"prefix\": \"osd blocklist\", \
+ 				\"blocklistop\": \"add\", \
+ 				\"addr\": \"%pISpc/%u\" }",
+ 			     &client_addr->in_addr,
+ 			     le32_to_cpu(client_addr->nonce));
+ 	if (ret == -EINVAL) {
+ 		/*
+ 		 * The monitor returns EINVAL on an unrecognized command.
+ 		 * Try the legacy command -- it is exactly the same except
+ 		 * for the name.
+ 		 */
+ 		ret = do_mon_command(monc,
+ 				     "{ \"prefix\": \"osd blacklist\", \
+ 					\"blacklistop\": \"add\", \
+ 					\"addr\": \"%pISpc/%u\" }",
+ 				     &client_addr->in_addr,
+ 				     le32_to_cpu(client_addr->nonce));
+ 	}
+ 	if (ret)
+ 		return ret;
+ 
+ 	/*
+ 	 * Make sure we have the osdmap that includes the blocklist
+ 	 * entry.  This is needed to ensure that the OSDs pick up the
+ 	 * new blocklist before processing any future requests from
+ 	 * this client.
+ 	 */
+ 	return ceph_wait_for_latest_osdmap(monc->client, 0);
+ }
+ EXPORT_SYMBOL(ceph_monc_blocklist_add);
++>>>>>>> 1b05fae7f29d (libceph: switch to the new "osd blocklist add" command)
  
  /*
   * Resend pending generic requests.
* Unmerged path net/ceph/mon_client.c
