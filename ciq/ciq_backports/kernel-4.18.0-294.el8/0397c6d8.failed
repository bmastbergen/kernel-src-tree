mptcp: keep unaccepted MPC subflow into join list

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 0397c6d85f9c6f81f6dc3a0a166331b2475b325c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0397c6d8.failed

This will simplify all operation dealing with subflows
before accept time (e.g. data fin processing, add_addr).

The join list is already flushed by mptcp_stream_accept()
before returning the newly created msk to the user space.

This also fixes an potential bug present into the old code:
conn_list was manipulated without helding the msk lock
in mptcp_stream_accept().

	Tested-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0397c6d85f9c6f81f6dc3a0a166331b2475b325c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
#	net/mptcp/subflow.c
diff --cc net/mptcp/protocol.c
index 75ee5f9fd199,212be3bef66e..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -1843,21 -2357,8 +1842,19 @@@ static struct sock *mptcp_accept(struc
  
  		/* acquire the 2nd reference for the owning socket */
  		sock_hold(new_mptcp_sock);
- 
- 		local_bh_disable();
- 		bh_lock_sock(new_mptcp_sock);
- 		msk = mptcp_sk(new_mptcp_sock);
- 		msk->first = newsk;
- 
  		newsk = new_mptcp_sock;
++<<<<<<< HEAD
 +		mptcp_copy_inaddrs(newsk, ssk);
 +		list_add(&subflow->node, &msk->conn_list);
 +
 +		mptcp_rcv_space_init(msk, ssk);
 +		bh_unlock_sock(new_mptcp_sock);
 +
 +		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPCAPABLEPASSIVEACK);
 +		local_bh_enable();
++=======
+ 		MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPCAPABLEPASSIVEACK);
++>>>>>>> 0397c6d85f9c (mptcp: keep unaccepted MPC subflow into join list)
  	} else {
  		MPTCP_INC_STATS(sock_net(sk),
  				MPTCP_MIB_MPCAPABLEPASSIVEFALLBACK);
diff --cc net/mptcp/subflow.c
index dcdd522ad5a5,d3c6b3a5ad55..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -1079,10 -1128,7 +1083,14 @@@ int __mptcp_subflow_connect(struct soc
  	if (err && err != -EINPROGRESS)
  		goto failed;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&msk->join_list_lock);
 +	list_add_tail(&subflow->node, &msk->join_list);
 +	spin_unlock_bh(&msk->join_list_lock);
 +
++=======
+ 	mptcp_add_pending_subflow(msk, subflow);
++>>>>>>> 0397c6d85f9c (mptcp: keep unaccepted MPC subflow into join list)
  	return err;
  
  failed:
* Unmerged path net/mptcp/protocol.c
diff --git a/net/mptcp/protocol.h b/net/mptcp/protocol.h
index a60ec79c4e54..8117ae48b9b9 100644
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@ -352,6 +352,15 @@ mptcp_subflow_get_mapped_dsn(const struct mptcp_subflow_context *subflow)
 	return subflow->map_seq + mptcp_subflow_get_map_offset(subflow);
 }
 
+static inline void mptcp_add_pending_subflow(struct mptcp_sock *msk,
+					     struct mptcp_subflow_context *subflow)
+{
+	sock_hold(mptcp_subflow_tcp_sock(subflow));
+	spin_lock_bh(&msk->join_list_lock);
+	list_add_tail(&subflow->node, &msk->join_list);
+	spin_unlock_bh(&msk->join_list_lock);
+}
+
 int mptcp_is_enabled(struct net *net);
 void mptcp_subflow_fully_established(struct mptcp_subflow_context *subflow,
 				     struct mptcp_options_received *mp_opt);
* Unmerged path net/mptcp/subflow.c
