libbpf: Fix uninitialized variable in btf_parse_type_sec

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 33433913459a6bfbfa808c202d6f5490aa43d7a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/33433913.failed

Fix obvious unitialized variable use that wasn't reported by compiler. libbpf
Makefile changes to catch such errors are added separately.

Fixes: 3289959b97ca ("libbpf: Support BTF loading and raw data output in both endianness")
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20200929220604.833631-1-andriin@fb.com
(cherry picked from commit 33433913459a6bfbfa808c202d6f5490aa43d7a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/btf.c
diff --cc tools/lib/bpf/btf.c
index 9ca048005e04,398b1f345b3c..000000000000
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@@ -187,22 -274,117 +187,28 @@@ static int btf_type_size(struct btf_typ
  static int btf_parse_type_sec(struct btf *btf)
  {
  	struct btf_header *hdr = btf->hdr;
++<<<<<<< HEAD
 +	void *nohdr_data = btf->nohdr_data;
 +	void *next_type = nohdr_data + hdr->type_off;
 +	void *end_type = nohdr_data + hdr->str_off;
++=======
+ 	void *next_type = btf->types_data;
+ 	void *end_type = next_type + hdr->type_len;
+ 	int err, i = 0, type_size;
++>>>>>>> 33433913459a (libbpf: Fix uninitialized variable in btf_parse_type_sec)
  
 -	/* VOID (type_id == 0) is specially handled by btf__get_type_by_id(),
 -	 * so ensure we can never properly use its offset from index by
 -	 * setting it to a large value
 -	 */
 -	err = btf_add_type_idx_entry(btf, UINT_MAX);
 -	if (err)
 -		return err;
 -
 -	while (next_type + sizeof(struct btf_type) <= end_type) {
 -		i++;
 -
 -		if (btf->swapped_endian)
 -			btf_bswap_type_base(next_type);
 +	while (next_type < end_type) {
 +		struct btf_type *t = next_type;
 +		int type_size;
 +		int err;
  
 -		type_size = btf_type_size(next_type);
 +		type_size = btf_type_size(t);
  		if (type_size < 0)
  			return type_size;
 -		if (next_type + type_size > end_type) {
 -			pr_warn("BTF type [%d] is malformed\n", i);
 -			return -EINVAL;
 -		}
 -
 -		if (btf->swapped_endian && btf_bswap_type_rest(next_type))
 -			return -EINVAL;
 -
 -		err = btf_add_type_idx_entry(btf, next_type - btf->types_data);
 +		next_type += type_size;
 +		err = btf_add_type(btf, t);
  		if (err)
  			return err;
 -
 -		next_type += type_size;
 -		btf->nr_types++;
 -	}
 -
 -	if (next_type != end_type) {
 -		pr_warn("BTF types data is malformed\n");
 -		return -EINVAL;
  	}
  
  	return 0;
* Unmerged path tools/lib/bpf/btf.c
