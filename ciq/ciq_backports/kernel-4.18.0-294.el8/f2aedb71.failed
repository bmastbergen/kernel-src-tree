NFS: Add fs_context support.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [fs] NFS: Add fs_context support (Scott Mayhew) [1622041]
Rebuild_FUZZ: 98.18%
commit-author David Howells <dhowells@redhat.com>
commit f2aedb713c284429987dc66c7aaf38decfc8da2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f2aedb71.failed

Add filesystem context support to NFS, parsing the options in advance and
attaching the information to struct nfs_fs_context.  The highlights are:

 (*) Merge nfs_mount_info and nfs_clone_mount into nfs_fs_context.  This
     structure represents NFS's superblock config.

 (*) Make use of the VFS's parsing support to split comma-separated lists

 (*) Pin the NFS protocol module in the nfs_fs_context.

 (*) Attach supplementary error information to fs_context.  This has the
     downside that these strings must be static and can't be formatted.

 (*) Remove the auxiliary file_system_type structs since the information
     necessary can be conveyed in the nfs_fs_context struct instead.

 (*) Root mounts are made by duplicating the config for the requested mount
     so as to have the same parameters.  Submounts pick up their parameters
     from the parent superblock.

[AV -- retrans is u32, not string]
[SM -- Renamed cfg to ctx in a few functions in an earlier patch]
[SM -- Moved fs_context mount option parsing to an earlier patch]
[SM -- Moved fs_context error logging to a later patch]
[SM -- Fixed printks in nfs4_try_get_tree() and nfs4_get_referral_tree()]
[SM -- Added is_remount_fc() helper]
[SM -- Deferred some refactoring to a later patch]
[SM -- Fixed referral mounts, which were broken in the original patch]
[SM -- Fixed leak of nfs_fattr when fs_context is freed]

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Scott Mayhew <smayhew@redhat.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit f2aedb713c284429987dc66c7aaf38decfc8da2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/fs_context.c
#	fs/nfs/internal.h
#	fs/nfs/namespace.c
#	fs/nfs/nfs4super.c
#	fs/nfs/super.c
diff --cc fs/nfs/internal.h
index feae10c2f600,1cd09df9e0b5..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -4,9 -4,10 +4,9 @@@
   */
  
  #include "nfs4_fs.h"
- #include <linux/mount.h>
+ #include <linux/fs_context.h>
  #include <linux/security.h>
  #include <linux/crc32.h>
 -#include <linux/sunrpc/addr.h>
  #include <linux/nfs_page.h>
  #include <linux/wait_bit.h>
  
@@@ -80,12 -92,16 +91,21 @@@ struct nfs_mount_info 
  /*
   * In-kernel mount arguments
   */
++<<<<<<< HEAD
 +struct nfs_parsed_mount_data {
 +	int			flags;
++=======
+ struct nfs_fs_context {
+ 	bool			internal;
+ 	bool			skip_reconfig_option_check;
+ 	bool			need_mount;
+ 	bool			sloppy;
+ 	unsigned int		flags;		/* NFS{,4}_MOUNT_* flags */
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  	unsigned int		rsize, wsize;
  	unsigned int		timeo, retrans;
 -	unsigned int		acregmin, acregmax;
 -	unsigned int		acdirmin, acdirmax;
 +	unsigned int		acregmin, acregmax,
 +				acdirmin, acdirmax;
  	unsigned int		namlen;
  	unsigned int		options;
  	unsigned int		bsize;
@@@ -95,10 -111,14 +115,15 @@@
  	unsigned int		version;
  	unsigned int		minorversion;
  	char			*fscache_uniq;
++<<<<<<< HEAD
 +	bool			need_mount;
++=======
+ 	unsigned short		protofamily;
+ 	unsigned short		mountfamily;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  
  	struct {
 -		union {
 -			struct sockaddr	address;
 -			struct sockaddr_storage	_address;
 -		};
 +		struct sockaddr_storage	address;
  		size_t			addrlen;
  		char			*hostname;
  		u32			version;
@@@ -114,12 -137,23 +139,26 @@@
  		int			port;
  		unsigned short		protocol;
  		unsigned short		nconnect;
+ 		unsigned short		export_path_len;
  	} nfs_server;
  
 -	void			*lsm_opts;
 +	struct security_mnt_opts lsm_opts;
  	struct net		*net;
++<<<<<<< HEAD
++=======
+ 
+ 	char			buf[32];	/* Parse buffer */
+ 
+ 	struct nfs_mount_info	mount_info;
+ 	struct nfs_clone_mount	clone_data;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  };
  
+ static inline struct nfs_fs_context *nfs_fc2context(const struct fs_context *fc)
+ {
+ 	return fc->fs_private;
+ }
+ 
  /* mount_clnt.c */
  struct nfs_mount_request {
  	struct sockaddr		*sap;
@@@ -135,16 -169,6 +174,19 @@@
  	struct net		*net;
  };
  
++<<<<<<< HEAD
 +struct nfs_mount_info {
 +	unsigned int inherited_bsize;
 +	int (*set_security)(struct super_block *, struct dentry *, struct nfs_mount_info *);
 +	struct nfs_parsed_mount_data *parsed;
 +	struct nfs_clone_mount *cloned;
 +	struct nfs_server *server;
 +	struct nfs_fh *mntfh;
 +	struct nfs_subversion *nfs_mod;
 +};
 +
++=======
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  extern int nfs_mount(struct nfs_mount_request *info);
  extern void nfs_umount(const struct nfs_mount_request *info);
  
@@@ -224,7 -248,9 +266,13 @@@ static inline void nfs_fs_proc_exit(voi
  extern const struct svc_version nfs4_callback_version1;
  extern const struct svc_version nfs4_callback_version4;
  
++<<<<<<< HEAD
 +struct nfs_pageio_descriptor;
++=======
+ /* fs_context.c */
+ extern struct file_system_type nfs_fs_type;
+ 
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  /* pagelist.c */
  extern int __init nfs_init_nfspagecache(void);
  extern void nfs_destroy_nfspagecache(void);
@@@ -384,16 -410,9 +432,16 @@@ extern int nfs_wait_atomic_killable(ato
  
  /* super.c */
  extern const struct super_operations nfs_sops;
- extern struct file_system_type nfs_fs_type;
- extern struct file_system_type nfs_prepared_fs_type;
- #if IS_ENABLED(CONFIG_NFS_V4)
- extern struct file_system_type nfs4_referral_fs_type;
- #endif
  bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);
++<<<<<<< HEAD
 +struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *);
 +int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 +int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 +struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
++=======
+ int nfs_try_get_tree(struct fs_context *);
+ int nfs_get_tree_common(struct fs_context *);
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  void nfs_kill_super(struct super_block *);
  
  extern struct rpc_stat nfs_rpcstat;
@@@ -421,13 -440,11 +469,11 @@@ static inline bool nfs_file_io_is_buffe
  extern char *nfs_path(char **p, struct dentry *dentry,
  		      char *buffer, ssize_t buflen, unsigned flags);
  extern struct vfsmount *nfs_d_automount(struct path *path);
- struct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,
- 			      struct nfs_fh *, struct nfs_fattr *);
- struct vfsmount *nfs_do_submount(struct dentry *, struct nfs_fh *,
- 				 struct nfs_fattr *, rpc_authflavor_t);
+ int nfs_submount(struct fs_context *, struct nfs_server *);
+ int nfs_do_submount(struct fs_context *);
  
  /* getroot.c */
 -extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,
 +extern struct dentry *nfs_get_root(struct super_block *, struct nfs_mount_info *,
  				   const char *);
  #if IS_ENABLED(CONFIG_NFS_V4)
  extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
diff --cc fs/nfs/namespace.c
index 0dbf0e798502,9b344fcd23b0..000000000000
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@@ -139,35 -140,65 +139,76 @@@ EXPORT_SYMBOL_GPL(nfs_path)
   */
  struct vfsmount *nfs_d_automount(struct path *path)
  {
- 	struct vfsmount *mnt;
+ 	struct nfs_fs_context *ctx;
+ 	struct fs_context *fc;
+ 	struct vfsmount *mnt = ERR_PTR(-ENOMEM);
  	struct nfs_server *server = NFS_SERVER(d_inode(path->dentry));
++<<<<<<< HEAD
 +	int timeout = READ_ONCE(nfs_mountpoint_expiry_timeout);
 +	struct nfs_fh *fh = NULL;
 +	struct nfs_fattr *fattr = NULL;
++=======
+ 	struct nfs_client *client = server->nfs_client;
+ 	int ret;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  
  	if (IS_ROOT(path->dentry))
  		return ERR_PTR(-ESTALE);
  
- 	mnt = ERR_PTR(-ENOMEM);
- 	fh = nfs_alloc_fhandle();
- 	fattr = nfs_alloc_fattr();
- 	if (fh == NULL || fattr == NULL)
- 		goto out;
+ 	/* Open a new filesystem context, transferring parameters from the
+ 	 * parent superblock, including the network namespace.
+ 	 */
+ 	fc = fs_context_for_submount(&nfs_fs_type, path->dentry);
+ 	if (IS_ERR(fc))
+ 		return ERR_CAST(fc);
+ 
+ 	ctx = nfs_fc2context(fc);
+ 	ctx->clone_data.dentry	= path->dentry;
+ 	ctx->clone_data.sb	= path->dentry->d_sb;
+ 	ctx->clone_data.fattr	= nfs_alloc_fattr();
+ 	if (!ctx->clone_data.fattr)
+ 		goto out_fc;
+ 
+ 	if (fc->net_ns != client->cl_net) {
+ 		put_net(fc->net_ns);
+ 		fc->net_ns = get_net(client->cl_net);
+ 	}
+ 
+ 	/* for submounts we want the same server; referrals will reassign */
+ 	memcpy(&ctx->nfs_server.address, &client->cl_addr, client->cl_addrlen);
+ 	ctx->nfs_server.addrlen	= client->cl_addrlen;
+ 	ctx->nfs_server.port	= server->port;
+ 
+ 	ctx->version		= client->rpc_ops->version;
+ 	ctx->minorversion	= client->cl_minorversion;
+ 	ctx->mount_info.nfs_mod	= client->cl_nfs_mod;
+ 	__module_get(ctx->mount_info.nfs_mod->owner);
+ 
+ 	ret = client->rpc_ops->submount(fc, server);
+ 	if (ret < 0) {
+ 		mnt = ERR_PTR(ret);
+ 		goto out_fc;
+ 	}
  
- 	mnt = server->nfs_client->rpc_ops->submount(server, path->dentry, fh, fattr);
+ 	up_write(&fc->root->d_sb->s_umount);
+ 	mnt = vfs_create_mount(fc);
  	if (IS_ERR(mnt))
- 		goto out;
+ 		goto out_fc;
  
++<<<<<<< HEAD
 +	mntget(mnt); /* prevent immediate expiration */
 +	if (timeout <= 0)
 +		goto out;
++=======
+ 	if (nfs_mountpoint_expiry_timeout < 0)
+ 		goto out_fc;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  
 -	mntget(mnt); /* prevent immediate expiration */
  	mnt_set_expiry(mnt, &nfs_automount_list);
 -	schedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);
 +	schedule_delayed_work(&nfs_automount_task, timeout);
  
- out:
- 	nfs_free_fattr(fattr);
- 	nfs_free_fhandle(fh);
+ out_fc:
+ 	put_fs_context(fc);
  	return mnt;
  }
  
@@@ -223,47 -253,43 +264,59 @@@ void nfs_release_automount_timer(void
   * @authflavor: security flavor to use when performing the mount
   *
   */
- struct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,
- 				 struct nfs_fattr *fattr, rpc_authflavor_t authflavor)
+ int nfs_do_submount(struct fs_context *fc)
  {
++<<<<<<< HEAD
 +	struct super_block *sb = dentry->d_sb;
 +	struct nfs_clone_mount mountdata = {
 +		.sb = sb,
 +		.dentry = dentry,
 +		.authflavor = authflavor,
 +	};
 +	struct nfs_mount_info mount_info = {
 +		.inherited_bsize = sb->s_blocksize_bits,
 +		.set_security = nfs_clone_sb_security,
 +		.cloned = &mountdata,
 +		.mntfh = fh,
 +		.nfs_mod = NFS_SB(sb)->nfs_client->cl_nfs_mod,
 +	};
++=======
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+ 	struct dentry *dentry = ctx->clone_data.dentry;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  	struct nfs_server *server;
- 	struct vfsmount *mnt;
- 	char *page = (char *) __get_free_page(GFP_USER);
- 	char *devname;
+ 	char *buffer, *p;
+ 	int ret;
  
- 	if (page == NULL)
- 		return ERR_PTR(-ENOMEM);
+ 	/* create a new volume representation */
+ 	server = ctx->mount_info.nfs_mod->rpc_ops->clone_server(NFS_SB(ctx->clone_data.sb),
+ 						     ctx->mount_info.mntfh,
+ 						     ctx->clone_data.fattr,
+ 						     ctx->selected_flavor);
  
- 	server = mount_info.nfs_mod->rpc_ops->clone_server(NFS_SB(sb), fh,
- 							   fattr, authflavor);
  	if (IS_ERR(server))
- 		return ERR_CAST(server);
+ 		return PTR_ERR(server);
  
- 	mount_info.server = server;
+ 	ctx->mount_info.server = server;
  
- 	devname = nfs_devname(dentry, page, PAGE_SIZE);
- 	if (IS_ERR(devname))
- 		mnt = ERR_CAST(devname);
- 	else
- 		mnt = vfs_submount(dentry, &nfs_prepared_fs_type, devname, &mount_info);
+ 	buffer = kmalloc(4096, GFP_USER);
+ 	if (!buffer)
+ 		return -ENOMEM;
  
- 	if (mount_info.server)
- 		nfs_free_server(mount_info.server);
- 	free_page((unsigned long)page);
- 	return mnt;
+ 	ctx->internal		= true;
+ 	ctx->mount_info.inherited_bsize = ctx->clone_data.sb->s_blocksize_bits;
+ 
+ 	p = nfs_devname(dentry, buffer, 4096);
+ 	if (IS_ERR(p)) {
+ 		dprintk("NFS: Couldn't determine submount pathname\n");
+ 		ret = PTR_ERR(p);
+ 	} else {
+ 		ret = vfs_parse_fs_string(fc, "source", p, buffer + 4096 - p);
+ 		if (!ret)
+ 			ret = vfs_get_tree(fc);
+ 	}
+ 	kfree(buffer);
+ 	return ret;
  }
  EXPORT_SYMBOL_GPL(nfs_do_submount);
  
diff --cc fs/nfs/nfs4super.c
index b5c4630cd799,469726410c5c..000000000000
--- a/fs/nfs/nfs4super.c
+++ b/fs/nfs/nfs4super.c
@@@ -191,43 -204,41 +203,70 @@@ static int do_nfs4_mount(struct nfs_ser
  	dentry = mount_subtree(root_mnt, export_path);
  	nfs_referral_loop_unprotect();
  
- 	return dentry;
+ 	if (IS_ERR(dentry))
+ 		return PTR_ERR(dentry);
+ 
+ 	fc->root = dentry;
+ 	return 0;
  }
  
- struct dentry *nfs4_try_mount(int flags, const char *dev_name,
- 			      struct nfs_mount_info *mount_info)
+ int nfs4_try_get_tree(struct fs_context *fc)
  {
++<<<<<<< HEAD
 +	struct nfs_parsed_mount_data *data = mount_info->parsed;
 +	struct dentry *res;
 +
 +	mount_info->set_security = nfs_set_sb_security;
 +
 +	dfprintk(MOUNT, "--> nfs4_try_mount()\n");
 +
 +	res = do_nfs4_mount(nfs4_create_server(mount_info),
 +			    flags, mount_info,
 +			    data->nfs_server.hostname,
 +			    data->nfs_server.export_path);
 +
 +	dfprintk(MOUNT, "<-- nfs4_try_mount() = %d%s\n",
 +		 PTR_ERR_OR_ZERO(res),
 +		 IS_ERR(res) ? " [error]" : "");
 +	return res;
++=======
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+ 	int err;
+ 
+ 	dfprintk(MOUNT, "--> nfs4_try_get_tree()\n");
+ 
+ 	/* We create a mount for the server's root, walk to the requested
+ 	 * location and then create another mount for that.
+ 	 */
+ 	err= do_nfs4_mount(nfs4_create_server(&ctx->mount_info),
+ 			   fc, ctx->nfs_server.hostname,
+ 			   ctx->nfs_server.export_path);
+ 	if (err) {
+ 		dfprintk(MOUNT, "<-- nfs4_try_get_tree() = %d [error]\n", err);
+ 	} else {
+ 		dfprintk(MOUNT, "<-- nfs4_try_get_tree() = 0\n");
+ 	}
+ 	return err;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  }
  
  /*
   * Create an NFS4 server record on referral traversal
   */
- static struct dentry *nfs4_referral_mount(struct file_system_type *fs_type,
- 		int flags, const char *dev_name, void *raw_data)
+ int nfs4_get_referral_tree(struct fs_context *fc)
  {
++<<<<<<< HEAD
 +	struct nfs_clone_mount *data = raw_data;
 +	struct nfs_mount_info mount_info = {
 +		.set_security = nfs_clone_sb_security,
 +		.cloned = data,
 +		.nfs_mod = &nfs_v4,
 +	};
 +	struct dentry *res;
++=======
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+ 	int err;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  
  	dprintk("--> nfs4_referral_mount()\n");
  
diff --cc fs/nfs/super.c
index 5a0a0d311ce8,6ff99da978a8..000000000000
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@@ -68,255 -69,10 +68,233 @@@
  #include "nfs.h"
  
  #define NFSDBG_FACILITY		NFSDBG_VFS
 +#define NFS_TEXT_DATA		1
 +
 +#if IS_ENABLED(CONFIG_NFS_V3)
 +#define NFS_DEFAULT_VERSION 3
 +#else
 +#define NFS_DEFAULT_VERSION 2
 +#endif
 +
 +#define NFS_MAX_CONNECTIONS 16
 +
 +enum {
 +	/* Mount options that take no arguments */
 +	Opt_soft, Opt_softerr, Opt_hard,
 +	Opt_posix, Opt_noposix,
 +	Opt_cto, Opt_nocto,
 +	Opt_ac, Opt_noac,
 +	Opt_lock, Opt_nolock,
 +	Opt_udp, Opt_tcp, Opt_rdma,
 +	Opt_acl, Opt_noacl,
 +	Opt_rdirplus, Opt_nordirplus,
 +	Opt_sharecache, Opt_nosharecache,
 +	Opt_resvport, Opt_noresvport,
 +	Opt_fscache, Opt_nofscache,
 +	Opt_migration, Opt_nomigration,
 +
 +	/* Mount options that take integer arguments */
 +	Opt_port,
 +	Opt_rsize, Opt_wsize, Opt_bsize,
 +	Opt_timeo, Opt_retrans,
 +	Opt_acregmin, Opt_acregmax,
 +	Opt_acdirmin, Opt_acdirmax,
 +	Opt_actimeo,
 +	Opt_namelen,
 +	Opt_mountport,
 +	Opt_mountvers,
 +	Opt_minorversion,
 +
 +	/* Mount options that take string arguments */
 +	Opt_nfsvers,
 +	Opt_sec, Opt_proto, Opt_mountproto, Opt_mounthost,
 +	Opt_addr, Opt_mountaddr, Opt_clientaddr,
 +	Opt_nconnect,
 +	Opt_lookupcache,
 +	Opt_fscache_uniq,
 +	Opt_local_lock,
 +
 +	/* Special mount options */
 +	Opt_userspace, Opt_deprecated, Opt_sloppy,
 +
 +	Opt_err
 +};
 +
 +static const match_table_t nfs_mount_option_tokens = {
 +	{ Opt_userspace, "bg" },
 +	{ Opt_userspace, "fg" },
 +	{ Opt_userspace, "retry=%s" },
 +
 +	{ Opt_sloppy, "sloppy" },
 +
 +	{ Opt_soft, "soft" },
 +	{ Opt_softerr, "softerr" },
 +	{ Opt_hard, "hard" },
 +	{ Opt_deprecated, "intr" },
 +	{ Opt_deprecated, "nointr" },
 +	{ Opt_posix, "posix" },
 +	{ Opt_noposix, "noposix" },
 +	{ Opt_cto, "cto" },
 +	{ Opt_nocto, "nocto" },
 +	{ Opt_ac, "ac" },
 +	{ Opt_noac, "noac" },
 +	{ Opt_lock, "lock" },
 +	{ Opt_nolock, "nolock" },
 +	{ Opt_udp, "udp" },
 +	{ Opt_tcp, "tcp" },
 +	{ Opt_rdma, "rdma" },
 +	{ Opt_acl, "acl" },
 +	{ Opt_noacl, "noacl" },
 +	{ Opt_rdirplus, "rdirplus" },
 +	{ Opt_nordirplus, "nordirplus" },
 +	{ Opt_sharecache, "sharecache" },
 +	{ Opt_nosharecache, "nosharecache" },
 +	{ Opt_resvport, "resvport" },
 +	{ Opt_noresvport, "noresvport" },
 +	{ Opt_fscache, "fsc" },
 +	{ Opt_nofscache, "nofsc" },
 +	{ Opt_migration, "migration" },
 +	{ Opt_nomigration, "nomigration" },
 +
 +	{ Opt_port, "port=%s" },
 +	{ Opt_rsize, "rsize=%s" },
 +	{ Opt_wsize, "wsize=%s" },
 +	{ Opt_bsize, "bsize=%s" },
 +	{ Opt_timeo, "timeo=%s" },
 +	{ Opt_retrans, "retrans=%s" },
 +	{ Opt_acregmin, "acregmin=%s" },
 +	{ Opt_acregmax, "acregmax=%s" },
 +	{ Opt_acdirmin, "acdirmin=%s" },
 +	{ Opt_acdirmax, "acdirmax=%s" },
 +	{ Opt_actimeo, "actimeo=%s" },
 +	{ Opt_namelen, "namlen=%s" },
 +	{ Opt_mountport, "mountport=%s" },
 +	{ Opt_mountvers, "mountvers=%s" },
 +	{ Opt_minorversion, "minorversion=%s" },
 +
 +	{ Opt_nfsvers, "nfsvers=%s" },
 +	{ Opt_nfsvers, "vers=%s" },
 +
 +	{ Opt_sec, "sec=%s" },
 +	{ Opt_proto, "proto=%s" },
 +	{ Opt_mountproto, "mountproto=%s" },
 +	{ Opt_addr, "addr=%s" },
 +	{ Opt_clientaddr, "clientaddr=%s" },
 +	{ Opt_mounthost, "mounthost=%s" },
 +	{ Opt_mountaddr, "mountaddr=%s" },
 +
 +	{ Opt_nconnect, "nconnect=%s" },
 +
 +	{ Opt_lookupcache, "lookupcache=%s" },
 +	{ Opt_fscache_uniq, "fsc=%s" },
 +	{ Opt_local_lock, "local_lock=%s" },
 +
 +	/* The following needs to be listed after all other options */
 +	{ Opt_nfsvers, "v%s" },
 +
 +	{ Opt_err, NULL }
 +};
 +
 +enum {
 +	Opt_xprt_udp, Opt_xprt_udp6, Opt_xprt_tcp, Opt_xprt_tcp6, Opt_xprt_rdma,
 +	Opt_xprt_rdma6,
 +
 +	Opt_xprt_err
 +};
 +
 +static const match_table_t nfs_xprt_protocol_tokens = {
 +	{ Opt_xprt_udp, "udp" },
 +	{ Opt_xprt_udp6, "udp6" },
 +	{ Opt_xprt_tcp, "tcp" },
 +	{ Opt_xprt_tcp6, "tcp6" },
 +	{ Opt_xprt_rdma, "rdma" },
 +	{ Opt_xprt_rdma6, "rdma6" },
 +
 +	{ Opt_xprt_err, NULL }
 +};
 +
 +enum {
 +	Opt_sec_none, Opt_sec_sys,
 +	Opt_sec_krb5, Opt_sec_krb5i, Opt_sec_krb5p,
 +	Opt_sec_lkey, Opt_sec_lkeyi, Opt_sec_lkeyp,
 +	Opt_sec_spkm, Opt_sec_spkmi, Opt_sec_spkmp,
 +
 +	Opt_sec_err
 +};
 +
 +static const match_table_t nfs_secflavor_tokens = {
 +	{ Opt_sec_none, "none" },
 +	{ Opt_sec_none, "null" },
 +	{ Opt_sec_sys, "sys" },
 +
 +	{ Opt_sec_krb5, "krb5" },
 +	{ Opt_sec_krb5i, "krb5i" },
 +	{ Opt_sec_krb5p, "krb5p" },
 +
 +	{ Opt_sec_lkey, "lkey" },
 +	{ Opt_sec_lkeyi, "lkeyi" },
 +	{ Opt_sec_lkeyp, "lkeyp" },
 +
 +	{ Opt_sec_spkm, "spkm3" },
 +	{ Opt_sec_spkmi, "spkm3i" },
 +	{ Opt_sec_spkmp, "spkm3p" },
 +
 +	{ Opt_sec_err, NULL }
 +};
 +
 +enum {
 +	Opt_lookupcache_all, Opt_lookupcache_positive,
 +	Opt_lookupcache_none,
 +
 +	Opt_lookupcache_err
 +};
 +
 +static match_table_t nfs_lookupcache_tokens = {
 +	{ Opt_lookupcache_all, "all" },
 +	{ Opt_lookupcache_positive, "pos" },
 +	{ Opt_lookupcache_positive, "positive" },
 +	{ Opt_lookupcache_none, "none" },
 +
 +	{ Opt_lookupcache_err, NULL }
 +};
 +
 +enum {
 +	Opt_local_lock_all, Opt_local_lock_flock, Opt_local_lock_posix,
 +	Opt_local_lock_none,
 +
 +	Opt_local_lock_err
 +};
 +
 +static match_table_t nfs_local_lock_tokens = {
 +	{ Opt_local_lock_all, "all" },
 +	{ Opt_local_lock_flock, "flock" },
 +	{ Opt_local_lock_posix, "posix" },
 +	{ Opt_local_lock_none, "none" },
 +
 +	{ Opt_local_lock_err, NULL }
 +};
 +
 +enum {
 +	Opt_vers_2, Opt_vers_3, Opt_vers_4, Opt_vers_4_0,
 +	Opt_vers_4_1, Opt_vers_4_2,
 +
 +	Opt_vers_err
 +};
 +
 +static match_table_t nfs_vers_tokens = {
 +	{ Opt_vers_2, "2" },
 +	{ Opt_vers_3, "3" },
 +	{ Opt_vers_4, "4" },
 +	{ Opt_vers_4_0, "4.0" },
 +	{ Opt_vers_4_1, "4.1" },
 +	{ Opt_vers_4_2, "4.2" },
 +
 +	{ Opt_vers_err, NULL }
 +};
  
- static struct dentry *nfs_prepared_mount(struct file_system_type *fs_type,
- 		int flags, const char *dev_name, void *raw_data);
- 
- struct file_system_type nfs_fs_type = {
- 	.owner		= THIS_MODULE,
- 	.name		= "nfs",
- 	.mount		= nfs_fs_mount,
- 	.kill_sb	= nfs_kill_super,
- 	.fs_flags	= FS_RENAME_DOES_D_MOVE|FS_BINARY_MOUNTDATA,
- };
- MODULE_ALIAS_FS("nfs");
- EXPORT_SYMBOL_GPL(nfs_fs_type);
- 
- struct file_system_type nfs_prepared_fs_type = {
- 	.owner		= THIS_MODULE,
- 	.name		= "nfs",
- 	.mount		= nfs_prepared_mount,
- 	.kill_sb	= nfs_kill_super,
- 	.fs_flags	= FS_RENAME_DOES_D_MOVE|FS_BINARY_MOUNTDATA,
- };
- EXPORT_SYMBOL_GPL(nfs_prepared_fs_type);
- 
  const struct super_operations nfs_sops = {
  	.alloc_inode	= nfs_alloc_inode,
 -	.free_inode	= nfs_free_inode,
 +	.destroy_inode	= nfs_destroy_inode,
  	.write_inode	= nfs_write_inode,
  	.drop_inode	= nfs_drop_inode,
  	.statfs		= nfs_statfs,
@@@ -331,21 -86,6 +308,24 @@@
  EXPORT_SYMBOL_GPL(nfs_sops);
  
  #if IS_ENABLED(CONFIG_NFS_V4)
++<<<<<<< HEAD
 +static void nfs4_validate_mount_flags(struct nfs_parsed_mount_data *);
 +static int nfs4_validate_mount_data(void *options,
 +	struct nfs_parsed_mount_data *args, const char *dev_name);
 +
 +struct file_system_type nfs4_fs_type = {
 +	.owner		= THIS_MODULE,
 +	.name		= "nfs4",
 +	.mount		= nfs_fs_mount,
 +	.kill_sb	= nfs_kill_super,
 +	.fs_flags	= FS_RENAME_DOES_D_MOVE|FS_BINARY_MOUNTDATA,
 +};
 +MODULE_ALIAS_FS("nfs4");
 +MODULE_ALIAS("nfs4");
 +EXPORT_SYMBOL_GPL(nfs4_fs_type);
 +
++=======
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  static int __init register_nfs4_fs(void)
  {
  	return register_filesystem(&nfs4_fs_type);
@@@ -1892,347 -877,20 +1872,354 @@@ static struct nfs_server *nfs_try_mount
  	return nfs_mod->rpc_ops->create_server(mount_info);
  }
  
- static struct dentry *nfs_fs_mount_common(int, const char *, struct nfs_mount_info *);
- 
- struct dentry *nfs_try_mount(int flags, const char *dev_name,
- 			     struct nfs_mount_info *mount_info)
+ int nfs_try_get_tree(struct fs_context *fc)
  {
++<<<<<<< HEAD
 +	struct nfs_subversion *nfs_mod = mount_info->nfs_mod;
 +	if (mount_info->parsed->need_mount)
 +		mount_info->server = nfs_try_mount_request(mount_info);
 +	else
 +		mount_info->server = nfs_mod->rpc_ops->create_server(mount_info);
++=======
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  
- 	return nfs_fs_mount_common(flags, dev_name, mount_info);
+ 	if (ctx->need_mount)
+ 		ctx->mount_info.server = nfs_try_mount_request(&ctx->mount_info);
+ 	else
+ 		ctx->mount_info.server = ctx->mount_info.nfs_mod->rpc_ops->create_server(&ctx->mount_info);
+ 
+ 	return nfs_get_tree_common(fc);
  }
- EXPORT_SYMBOL_GPL(nfs_try_mount);
+ EXPORT_SYMBOL_GPL(nfs_try_get_tree);
+ 
  
 +/*
 + * Split "dev_name" into "hostname:export_path".
 + *
 + * The leftmost colon demarks the split between the server's hostname
 + * and the export path.  If the hostname starts with a left square
 + * bracket, then it may contain colons.
 + *
 + * Note: caller frees hostname and export path, even on error.
 + */
 +static int nfs_parse_devname(const char *dev_name,
 +			     char **hostname, size_t maxnamlen,
 +			     char **export_path, size_t maxpathlen)
 +{
 +	size_t len;
 +	char *end;
 +
 +	if (unlikely(!dev_name || !*dev_name)) {
 +		dfprintk(MOUNT, "NFS: device name not specified\n");
 +		return -EINVAL;
 +	}
 +
 +	/* Is the host name protected with square brakcets? */
 +	if (*dev_name == '[') {
 +		end = strchr(++dev_name, ']');
 +		if (end == NULL || end[1] != ':')
 +			goto out_bad_devname;
 +
 +		len = end - dev_name;
 +		end++;
 +	} else {
 +		char *comma;
 +
 +		end = strchr(dev_name, ':');
 +		if (end == NULL)
 +			goto out_bad_devname;
 +		len = end - dev_name;
 +
 +		/* kill possible hostname list: not supported */
 +		comma = strchr(dev_name, ',');
 +		if (comma != NULL && comma < end)
 +			len = comma - dev_name;
 +	}
 +
 +	if (len > maxnamlen)
 +		goto out_hostname;
 +
 +	/* N.B. caller will free nfs_server.hostname in all cases */
 +	*hostname = kstrndup(dev_name, len, GFP_KERNEL);
 +	if (*hostname == NULL)
 +		goto out_nomem;
 +	len = strlen(++end);
 +	if (len > maxpathlen)
 +		goto out_path;
 +	*export_path = kstrndup(end, len, GFP_KERNEL);
 +	if (!*export_path)
 +		goto out_nomem;
 +
 +	dfprintk(MOUNT, "NFS: MNTPATH: '%s'\n", *export_path);
 +	return 0;
 +
 +out_bad_devname:
 +	dfprintk(MOUNT, "NFS: device name not in host:path format\n");
 +	return -EINVAL;
 +
 +out_nomem:
 +	dfprintk(MOUNT, "NFS: not enough memory to parse device name\n");
 +	return -ENOMEM;
 +
 +out_hostname:
 +	dfprintk(MOUNT, "NFS: server hostname too long\n");
 +	return -ENAMETOOLONG;
 +
 +out_path:
 +	dfprintk(MOUNT, "NFS: export pathname too long\n");
 +	return -ENAMETOOLONG;
 +}
 +
 +/*
 + * Validate the NFS2/NFS3 mount data
 + * - fills in the mount root filehandle
 + *
 + * For option strings, user space handles the following behaviors:
 + *
 + * + DNS: mapping server host name to IP address ("addr=" option)
 + *
 + * + failure mode: how to behave if a mount request can't be handled
 + *   immediately ("fg/bg" option)
 + *
 + * + retry: how often to retry a mount request ("retry=" option)
 + *
 + * + breaking back: trying proto=udp after proto=tcp, v2 after v3,
 + *   mountproto=tcp after mountproto=udp, and so on
 + */
 +static int nfs23_validate_mount_data(void *options,
 +				     struct nfs_parsed_mount_data *args,
 +				     struct nfs_fh *mntfh,
 +				     const char *dev_name)
 +{
 +	struct nfs_mount_data *data = (struct nfs_mount_data *)options;
 +	struct sockaddr *sap = (struct sockaddr *)&args->nfs_server.address;
 +	int extra_flags = NFS_MOUNT_LEGACY_INTERFACE;
 +
 +	if (data == NULL)
 +		goto out_no_data;
 +
 +	args->version = NFS_DEFAULT_VERSION;
 +	switch (data->version) {
 +	case 1:
 +		data->namlen = 0; /* fall through */
 +	case 2:
 +		data->bsize = 0; /* fall through */
 +	case 3:
 +		if (data->flags & NFS_MOUNT_VER3)
 +			goto out_no_v3;
 +		data->root.size = NFS2_FHSIZE;
 +		memcpy(data->root.data, data->old_root.data, NFS2_FHSIZE);
 +		/* Turn off security negotiation */
 +		extra_flags |= NFS_MOUNT_SECFLAVOUR;
 +		/* fall through */
 +	case 4:
 +		if (data->flags & NFS_MOUNT_SECFLAVOUR)
 +			goto out_no_sec;
 +		/* fall through */
 +	case 5:
 +		memset(data->context, 0, sizeof(data->context));
 +		/* fall through */
 +	case 6:
 +		if (data->flags & NFS_MOUNT_VER3) {
 +			if (data->root.size > NFS3_FHSIZE || data->root.size == 0)
 +				goto out_invalid_fh;
 +			mntfh->size = data->root.size;
 +			args->version = 3;
 +		} else {
 +			mntfh->size = NFS2_FHSIZE;
 +			args->version = 2;
 +		}
 +
 +
 +		memcpy(mntfh->data, data->root.data, mntfh->size);
 +		if (mntfh->size < sizeof(mntfh->data))
 +			memset(mntfh->data + mntfh->size, 0,
 +			       sizeof(mntfh->data) - mntfh->size);
 +
 +		/*
 +		 * Translate to nfs_parsed_mount_data, which nfs_fill_super
 +		 * can deal with.
 +		 */
 +		args->flags		= data->flags & NFS_MOUNT_FLAGMASK;
 +		args->flags		|= extra_flags;
 +		args->rsize		= data->rsize;
 +		args->wsize		= data->wsize;
 +		args->timeo		= data->timeo;
 +		args->retrans		= data->retrans;
 +		args->acregmin		= data->acregmin;
 +		args->acregmax		= data->acregmax;
 +		args->acdirmin		= data->acdirmin;
 +		args->acdirmax		= data->acdirmax;
 +		args->need_mount	= false;
 +
 +		memcpy(sap, &data->addr, sizeof(data->addr));
 +		args->nfs_server.addrlen = sizeof(data->addr);
 +		args->nfs_server.port = ntohs(data->addr.sin_port);
 +		if (sap->sa_family != AF_INET ||
 +		    !nfs_verify_server_address(sap))
 +			goto out_no_address;
 +
 +		if (!(data->flags & NFS_MOUNT_TCP))
 +			args->nfs_server.protocol = XPRT_TRANSPORT_UDP;
 +		/* N.B. caller will free nfs_server.hostname in all cases */
 +		args->nfs_server.hostname = kstrdup(data->hostname, GFP_KERNEL);
 +		args->namlen		= data->namlen;
 +		args->bsize		= data->bsize;
 +
 +		if (data->flags & NFS_MOUNT_SECFLAVOUR)
 +			args->selected_flavor = data->pseudoflavor;
 +		else
 +			args->selected_flavor = RPC_AUTH_UNIX;
 +		if (!args->nfs_server.hostname)
 +			goto out_nomem;
 +
 +		if (!(data->flags & NFS_MOUNT_NONLM))
 +			args->flags &= ~(NFS_MOUNT_LOCAL_FLOCK|
 +					 NFS_MOUNT_LOCAL_FCNTL);
 +		else
 +			args->flags |= (NFS_MOUNT_LOCAL_FLOCK|
 +					NFS_MOUNT_LOCAL_FCNTL);
 +		/*
 +		 * The legacy version 6 binary mount data from userspace has a
 +		 * field used only to transport selinux information into the
 +		 * the kernel.  To continue to support that functionality we
 +		 * have a touch of selinux knowledge here in the NFS code. The
 +		 * userspace code converted context=blah to just blah so we are
 +		 * converting back to the full string selinux understands.
 +		 */
 +		if (data->context[0]){
 +#ifdef CONFIG_SECURITY_SELINUX
 +			int rc;
 +			char *opts_str = kmalloc(sizeof(data->context) + 8, GFP_KERNEL);
 +			if (!opts_str)
 +				return -ENOMEM;
 +			strcpy(opts_str, "context=");
 +			data->context[NFS_MAX_CONTEXT_LEN] = '\0';
 +			strcat(opts_str, &data->context[0]);
 +			rc = security_sb_parse_opts_str(opts_str, &args->lsm_opts);
 +			kfree(opts_str);
 +			if (rc)
 +				return rc;
 +#else
 +			return -EINVAL;
 +#endif
 +		}
 +
 +		break;
 +	default:
 +		return NFS_TEXT_DATA;
 +	}
 +
 +	return 0;
 +
 +out_no_data:
 +	dfprintk(MOUNT, "NFS: mount program didn't pass any mount data\n");
 +	return -EINVAL;
 +
 +out_no_v3:
 +	dfprintk(MOUNT, "NFS: nfs_mount_data version %d does not support v3\n",
 +		 data->version);
 +	return -EINVAL;
 +
 +out_no_sec:
 +	dfprintk(MOUNT, "NFS: nfs_mount_data version supports only AUTH_SYS\n");
 +	return -EINVAL;
 +
 +out_nomem:
 +	dfprintk(MOUNT, "NFS: not enough memory to handle mount options\n");
 +	return -ENOMEM;
 +
 +out_no_address:
 +	dfprintk(MOUNT, "NFS: mount program didn't pass remote address\n");
 +	return -EINVAL;
 +
 +out_invalid_fh:
 +	dfprintk(MOUNT, "NFS: invalid root filehandle\n");
 +	return -EINVAL;
 +}
 +
 +#if IS_ENABLED(CONFIG_NFS_V4)
 +static int nfs_validate_mount_data(struct file_system_type *fs_type,
 +				   void *options,
 +				   struct nfs_parsed_mount_data *args,
 +				   struct nfs_fh *mntfh,
 +				   const char *dev_name)
 +{
 +	if (fs_type == &nfs_fs_type)
 +		return nfs23_validate_mount_data(options, args, mntfh, dev_name);
 +	return nfs4_validate_mount_data(options, args, dev_name);
 +}
 +#else
 +static int nfs_validate_mount_data(struct file_system_type *fs_type,
 +				   void *options,
 +				   struct nfs_parsed_mount_data *args,
 +				   struct nfs_fh *mntfh,
 +				   const char *dev_name)
 +{
 +	return nfs23_validate_mount_data(options, args, mntfh, dev_name);
 +}
 +#endif
 +
 +static int nfs_validate_text_mount_data(void *options,
 +					struct nfs_parsed_mount_data *args,
 +					const char *dev_name)
 +{
 +	int port = 0;
 +	int max_namelen = PAGE_SIZE;
 +	int max_pathlen = NFS_MAXPATHLEN;
 +	struct sockaddr *sap = (struct sockaddr *)&args->nfs_server.address;
 +
 +	if (nfs_parse_mount_options((char *)options, args) == 0)
 +		return -EINVAL;
 +
 +	if (!nfs_verify_server_address(sap))
 +		goto out_no_address;
 +
 +	if (args->version == 4) {
 +#if IS_ENABLED(CONFIG_NFS_V4)
 +		if (args->nfs_server.protocol == XPRT_TRANSPORT_RDMA)
 +			port = NFS_RDMA_PORT;
 +		else
 +			port = NFS_PORT;
 +		max_namelen = NFS4_MAXNAMLEN;
 +		max_pathlen = NFS4_MAXPATHLEN;
 +		nfs_validate_transport_protocol(args);
 +		if (args->nfs_server.protocol == XPRT_TRANSPORT_UDP)
 +			goto out_invalid_transport_udp;
 +		nfs4_validate_mount_flags(args);
 +#else
 +		goto out_v4_not_compiled;
 +#endif /* CONFIG_NFS_V4 */
 +	} else {
 +		nfs_set_mount_transport_protocol(args);
 +		if (args->nfs_server.protocol == XPRT_TRANSPORT_RDMA)
 +			port = NFS_RDMA_PORT;
 +	}
 +
 +	nfs_set_port(sap, &args->nfs_server.port, port);
 +
 +	return nfs_parse_devname(dev_name,
 +				   &args->nfs_server.hostname,
 +				   max_namelen,
 +				   &args->nfs_server.export_path,
 +				   max_pathlen);
 +
 +#if !IS_ENABLED(CONFIG_NFS_V4)
 +out_v4_not_compiled:
 +	dfprintk(MOUNT, "NFS: NFSv4 is not compiled into kernel\n");
 +	return -EPROTONOSUPPORT;
 +#else
 +out_invalid_transport_udp:
 +	dfprintk(MOUNT, "NFSv4: Unsupported transport protocol udp\n");
 +	return -EINVAL;
 +#endif /* !CONFIG_NFS_V4 */
 +
 +out_no_address:
 +	dfprintk(MOUNT, "NFS: mount program didn't pass remote address\n");
 +	return -EINVAL;
 +}
 +
  #define NFS_REMOUNT_CMP_FLAGMASK ~(NFS_MOUNT_INTR \
  		| NFS_MOUNT_SECURE \
  		| NFS_MOUNT_TCP \
@@@ -2272,15 -930,11 +2259,18 @@@ nfs_compare_remount_data(struct nfs_ser
  	return 0;
  }
  
- int
- nfs_remount(struct super_block *sb, int *flags, char *raw_data)
+ int nfs_reconfigure(struct fs_context *fc)
  {
- 	int error;
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+ 	struct super_block *sb = fc->root->d_sb;
  	struct nfs_server *nfss = sb->s_fs_info;
++<<<<<<< HEAD
 +	struct nfs_parsed_mount_data *data;
 +	struct nfs_mount_data *options = (struct nfs_mount_data *)raw_data;
 +	struct nfs4_mount_data *options4 = (struct nfs4_mount_data *)raw_data;
 +	u32 nfsvers = nfss->nfs_client->rpc_ops->version;
++=======
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  
  	sync_filesystem(sb);
  
@@@ -2290,57 -944,24 +2280,68 @@@
  	 * ones were explicitly specified. Fall back to legacy behavior and
  	 * just return success.
  	 */
- 	if ((nfsvers == 4 && (!options4 || options4->version == 1)) ||
- 	    (nfsvers <= 3 && (!options || (options->version >= 1 &&
- 					   options->version <= 6))))
+ 	if (ctx->skip_reconfig_option_check)
  		return 0;
  
++<<<<<<< HEAD
 +	data = nfs_alloc_parsed_mount_data();
 +	if (data == NULL)
 +		return -ENOMEM;
 +
 +	/* fill out struct with values from existing mount */
 +	data->flags = nfss->flags;
 +	data->rsize = nfss->rsize;
 +	data->wsize = nfss->wsize;
 +	data->retrans = nfss->client->cl_timeout->to_retries;
 +	data->selected_flavor = nfss->client->cl_auth->au_flavor;
 +	data->acregmin = nfss->acregmin / HZ;
 +	data->acregmax = nfss->acregmax / HZ;
 +	data->acdirmin = nfss->acdirmin / HZ;
 +	data->acdirmax = nfss->acdirmax / HZ;
 +	data->timeo = 10U * nfss->client->cl_timeout->to_initval / HZ;
 +	data->nfs_server.port = nfss->port;
 +	data->nfs_server.addrlen = nfss->nfs_client->cl_addrlen;
 +	data->version = nfsvers;
 +	data->minorversion = nfss->nfs_client->cl_minorversion;
 +	data->net = current->nsproxy->net_ns;
 +	memcpy(&data->nfs_server.address, &nfss->nfs_client->cl_addr,
 +		data->nfs_server.addrlen);
 +
 +	/* overwrite those values with any that were specified */
 +	error = -EINVAL;
 +	if (!nfs_parse_mount_options((char *)options, data))
 +		goto out;
 +
++=======
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  	/*
  	 * noac is a special case. It implies -o sync, but that's not
- 	 * necessarily reflected in the mtab options. do_remount_sb
+ 	 * necessarily reflected in the mtab options. reconfigure_super
  	 * will clear SB_SYNCHRONOUS if -o sync wasn't specified in the
  	 * remount options, so we have to explicitly reset it.
  	 */
++<<<<<<< HEAD
 +	if (data->flags & NFS_MOUNT_NOAC)
 +		*flags |= SB_SYNCHRONOUS;
 +
 +	/* compare new mount options with old ones */
 +	error = nfs_compare_remount_data(nfss, data);
 +	if (!error)
 +		error = security_sb_remount(sb, &data->lsm_opts);
 +out:
 +	nfs_free_parsed_mount_data(data);
 +	return error;
++=======
+ 	if (ctx->flags & NFS_MOUNT_NOAC) {
+ 		fc->sb_flags |= SB_SYNCHRONOUS;
+ 		fc->sb_flags_mask |= SB_SYNCHRONOUS;
+ 	}
+ 
+ 	/* compare new mount options with old ones */
+ 	return nfs_compare_remount_data(nfss, ctx);
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  }
- EXPORT_SYMBOL_GPL(nfs_remount);
+ EXPORT_SYMBOL_GPL(nfs_reconfigure);
  
  /*
   * Finish setting up an NFS superblock
@@@ -2516,8 -1127,7 +2507,12 @@@ static int nfs_compare_super(struct sup
  
  #ifdef CONFIG_NFS_FSCACHE
  static void nfs_get_cache_cookie(struct super_block *sb,
++<<<<<<< HEAD
 +				 struct nfs_parsed_mount_data *parsed,
 +				 struct nfs_clone_mount *cloned)
++=======
+ 				 struct nfs_fs_context *ctx)
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  {
  	struct nfs_server *nfss = NFS_SB(sb);
  	char *uniq = NULL;
@@@ -2526,15 -1136,11 +2521,23 @@@
  	nfss->fscache_key = NULL;
  	nfss->fscache = NULL;
  
++<<<<<<< HEAD
 +	if (parsed) {
 +		if (!(parsed->options & NFS_OPTION_FSCACHE))
 +			return;
 +		if (parsed->fscache_uniq) {
 +			uniq = parsed->fscache_uniq;
 +			ulen = strlen(parsed->fscache_uniq);
 +		}
 +	} else if (cloned) {
 +		struct nfs_server *mnt_s = NFS_SB(cloned->sb);
++=======
+ 	if (!ctx)
+ 		return;
+ 
+ 	if (ctx->clone_data.sb) {
+ 		struct nfs_server *mnt_s = NFS_SB(ctx->clone_data.sb);
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  		if (!(mnt_s->options & NFS_OPTION_FSCACHE))
  			return;
  		if (mnt_s->fscache_key) {
@@@ -2548,8 -1161,7 +2558,12 @@@
  }
  #else
  static void nfs_get_cache_cookie(struct super_block *sb,
++<<<<<<< HEAD
 +				 struct nfs_parsed_mount_data *parsed,
 +				 struct nfs_clone_mount *cloned)
++=======
+ 				 struct nfs_fs_context *ctx)
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  {
  }
  #endif
@@@ -2607,22 -1173,19 +2621,28 @@@ static void nfs_set_readahead(struct ba
  	bdi->io_pages = iomax_pages;
  }
  
- static struct dentry *nfs_fs_mount_common(int flags, const char *dev_name,
- 				   struct nfs_mount_info *mount_info)
+ int nfs_get_tree_common(struct fs_context *fc)
  {
+ 	struct nfs_fs_context *ctx = nfs_fc2context(fc);
  	struct super_block *s;
  	struct dentry *mntroot = ERR_PTR(-ENOMEM);
++<<<<<<< HEAD
 +	int (*compare_super)(struct super_block *, void *) = nfs_compare_super;
 +	struct nfs_server *server = mount_info->server;
 +	struct nfs_sb_mountdata sb_mntdata = {
 +		.mntflags = flags,
 +		.server = server,
 +	};
++=======
+ 	int (*compare_super)(struct super_block *, struct fs_context *) = nfs_compare_super;
+ 	struct nfs_server *server = ctx->mount_info.server;
+ 	unsigned long kflags = 0, kflags_out = 0;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  	int error;
  
- 	mount_info->server = NULL;
+ 	ctx->mount_info.server = NULL;
  	if (IS_ERR(server))
- 		return ERR_CAST(server);
+ 		return PTR_ERR(server);
  
  	if (server->flags & NFS_MOUNT_UNSHARED)
  		compare_super = NULL;
@@@ -2665,70 -1231,55 +2688,113 @@@
  			s->s_blocksize_bits = bsize;
  			s->s_blocksize = 1U << bsize;
  		}
++<<<<<<< HEAD
 +		nfs_get_cache_cookie(s, mount_info->parsed, mount_info->cloned);
 +		if (!(server->flags & NFS_MOUNT_UNSHARED))
 +			s->s_iflags |= SB_I_MULTIROOT;
 +	}
 +
 +	mntroot = nfs_get_root(s, mount_info, dev_name);
 +	if (IS_ERR(mntroot))
 +		goto error_splat_super;
++=======
+ 		nfs_get_cache_cookie(s, ctx);
+ 	}
+ 
+ 	mntroot = nfs_get_root(s, ctx->mount_info.mntfh, fc->source);
+ 	if (IS_ERR(mntroot)) {
+ 		error = PTR_ERR(mntroot);
+ 		dfprintk(MOUNT, "NFS: Couldn't get root dentry\n");
+ 		goto error_splat_super;
+ 	}
+ 	fc->root = mntroot;
+ 
+ 	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL)
+ 		kflags |= SECURITY_LSM_NATIVE_LABELS;
+ 	if (ctx->clone_data.sb) {
+ 		if (d_inode(fc->root)->i_fop != &nfs_dir_operations) {
+ 			error = -ESTALE;
+ 			goto error_splat_root;
+ 		}
+ 		/* clone any lsm security options from the parent to the new sb */
+ 		error = security_sb_clone_mnt_opts(ctx->clone_data.sb, s, kflags,
+ 				&kflags_out);
+ 	} else {
+ 		error = security_sb_set_mnt_opts(s, fc->security,
+ 							kflags, &kflags_out);
+ 	}
+ 	if (error)
+ 		goto error_splat_root;
+ 	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL &&
+ 		!(kflags_out & SECURITY_LSM_NATIVE_LABELS))
+ 		NFS_SB(s)->caps &= ~NFS_CAP_SECURITY_LABEL;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  
  	s->s_flags |= SB_ACTIVE;
+ 	error = 0;
  
  out:
- 	return mntroot;
+ 	return error;
  
  out_err_nosb:
  	nfs_free_server(server);
  	goto out;
  
++<<<<<<< HEAD
++=======
+ error_splat_root:
+ 	dput(fc->root);
+ 	fc->root = NULL;
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  error_splat_super:
  	deactivate_locked_super(s);
  	goto out;
  }
  
++<<<<<<< HEAD
 +struct dentry *nfs_fs_mount(struct file_system_type *fs_type,
 +	int flags, const char *dev_name, void *raw_data)
 +{
 +	struct nfs_mount_info mount_info = {
 +		.set_security = nfs_set_sb_security,
 +	};
 +	struct dentry *mntroot = ERR_PTR(-ENOMEM);
 +	struct nfs_subversion *nfs_mod;
 +	int error;
 +
 +	mount_info.parsed = nfs_alloc_parsed_mount_data();
 +	mount_info.mntfh = nfs_alloc_fhandle();
 +	if (mount_info.parsed == NULL || mount_info.mntfh == NULL)
 +		goto out;
 +
 +	/* Validate the mount data */
 +	error = nfs_validate_mount_data(fs_type, raw_data, mount_info.parsed, mount_info.mntfh, dev_name);
 +	if (error == NFS_TEXT_DATA)
 +		error = nfs_validate_text_mount_data(raw_data, mount_info.parsed, dev_name);
 +	if (error < 0) {
 +		mntroot = ERR_PTR(error);
 +		goto out;
 +	}
 +
 +	nfs_mod = get_nfs_version(mount_info.parsed->version);
 +	if (IS_ERR(nfs_mod)) {
 +		mntroot = ERR_CAST(nfs_mod);
 +		goto out;
 +	}
 +	mount_info.nfs_mod = nfs_mod;
 +
 +	mntroot = nfs_mod->rpc_ops->try_mount(flags, dev_name, &mount_info);
 +
 +	put_nfs_version(nfs_mod);
 +out:
 +	nfs_free_parsed_mount_data(mount_info.parsed);
 +	nfs_free_fhandle(mount_info.mntfh);
 +	return mntroot;
 +}
 +EXPORT_SYMBOL_GPL(nfs_fs_mount);
 +
++=======
++>>>>>>> f2aedb713c28 (NFS: Add fs_context support.)
  /*
   * Destroy an NFS2/3 superblock
   */
@@@ -2746,126 -1297,8 +2812,115 @@@ void nfs_kill_super(struct super_block 
  }
  EXPORT_SYMBOL_GPL(nfs_kill_super);
  
- /*
-  * Internal use only: mount_info is already set up by caller.
-  * Used for mountpoint crossings and for nfs4 root.
-  */
- static struct dentry *
- nfs_prepared_mount(struct file_system_type *fs_type, int flags,
- 		   const char *dev_name, void *raw_data)
- {
- 	return nfs_fs_mount_common(flags, dev_name, raw_data);
- }
- 
  #if IS_ENABLED(CONFIG_NFS_V4)
  
 +static void nfs4_validate_mount_flags(struct nfs_parsed_mount_data *args)
 +{
 +	args->flags &= ~(NFS_MOUNT_NONLM|NFS_MOUNT_NOACL|NFS_MOUNT_VER3|
 +			 NFS_MOUNT_LOCAL_FLOCK|NFS_MOUNT_LOCAL_FCNTL);
 +}
 +
 +/*
 + * Validate NFSv4 mount options
 + */
 +static int nfs4_validate_mount_data(void *options,
 +				    struct nfs_parsed_mount_data *args,
 +				    const char *dev_name)
 +{
 +	struct sockaddr *sap = (struct sockaddr *)&args->nfs_server.address;
 +	struct nfs4_mount_data *data = (struct nfs4_mount_data *)options;
 +	char *c;
 +
 +	if (data == NULL)
 +		goto out_no_data;
 +
 +	args->version = 4;
 +
 +	switch (data->version) {
 +	case 1:
 +		if (data->host_addrlen > sizeof(args->nfs_server.address))
 +			goto out_no_address;
 +		if (data->host_addrlen == 0)
 +			goto out_no_address;
 +		args->nfs_server.addrlen = data->host_addrlen;
 +		if (copy_from_user(sap, data->host_addr, data->host_addrlen))
 +			return -EFAULT;
 +		if (!nfs_verify_server_address(sap))
 +			goto out_no_address;
 +		args->nfs_server.port = ntohs(((struct sockaddr_in *)sap)->sin_port);
 +
 +		if (data->auth_flavourlen) {
 +			rpc_authflavor_t pseudoflavor;
 +			if (data->auth_flavourlen > 1)
 +				goto out_inval_auth;
 +			if (copy_from_user(&pseudoflavor,
 +					   data->auth_flavours,
 +					   sizeof(pseudoflavor)))
 +				return -EFAULT;
 +			args->selected_flavor = pseudoflavor;
 +		} else
 +			args->selected_flavor = RPC_AUTH_UNIX;
 +
 +		c = strndup_user(data->hostname.data, NFS4_MAXNAMLEN);
 +		if (IS_ERR(c))
 +			return PTR_ERR(c);
 +		args->nfs_server.hostname = c;
 +
 +		c = strndup_user(data->mnt_path.data, NFS4_MAXPATHLEN);
 +		if (IS_ERR(c))
 +			return PTR_ERR(c);
 +		args->nfs_server.export_path = c;
 +		dfprintk(MOUNT, "NFS: MNTPATH: '%s'\n", c);
 +
 +		c = strndup_user(data->client_addr.data, 16);
 +		if (IS_ERR(c))
 +			return PTR_ERR(c);
 +		args->client_address = c;
 +
 +		/*
 +		 * Translate to nfs_parsed_mount_data, which nfs4_fill_super
 +		 * can deal with.
 +		 */
 +
 +		args->flags	= data->flags & NFS4_MOUNT_FLAGMASK;
 +		args->rsize	= data->rsize;
 +		args->wsize	= data->wsize;
 +		args->timeo	= data->timeo;
 +		args->retrans	= data->retrans;
 +		args->acregmin	= data->acregmin;
 +		args->acregmax	= data->acregmax;
 +		args->acdirmin	= data->acdirmin;
 +		args->acdirmax	= data->acdirmax;
 +		args->nfs_server.protocol = data->proto;
 +		nfs_validate_transport_protocol(args);
 +		if (args->nfs_server.protocol == XPRT_TRANSPORT_UDP)
 +			goto out_invalid_transport_udp;
 +
 +		break;
 +	default:
 +		return NFS_TEXT_DATA;
 +	}
 +
 +	return 0;
 +
 +out_no_data:
 +	dfprintk(MOUNT, "NFS4: mount program didn't pass any mount data\n");
 +	return -EINVAL;
 +
 +out_inval_auth:
 +	dfprintk(MOUNT, "NFS4: Invalid number of RPC auth flavours %d\n",
 +		 data->auth_flavourlen);
 +	return -EINVAL;
 +
 +out_no_address:
 +	dfprintk(MOUNT, "NFS4: mount program didn't pass remote address\n");
 +	return -EINVAL;
 +
 +out_invalid_transport_udp:
 +	dfprintk(MOUNT, "NFSv4: Unsupported transport protocol udp\n");
 +	return -EINVAL;
 +}
 +
  /*
   * NFS v4 module parameters need to stay in the
   * NFS client for backwards compatibility
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/namespace.c
diff --git a/fs/nfs/nfs3proc.c b/fs/nfs/nfs3proc.c
index 9446eff223cd..19823cba436e 100644
--- a/fs/nfs/nfs3proc.c
+++ b/fs/nfs/nfs3proc.c
@@ -990,7 +990,7 @@ const struct nfs_rpc_ops nfs_v3_clientops = {
 	.nlmclnt_ops	= &nlmclnt_fl_close_lock_ops,
 	.getroot	= nfs3_proc_get_root,
 	.submount	= nfs_submount,
-	.try_mount	= nfs_try_mount,
+	.try_get_tree	= nfs_try_get_tree,
 	.getattr	= nfs3_proc_getattr,
 	.setattr	= nfs3_proc_setattr,
 	.lookup		= nfs3_proc_lookup,
diff --git a/fs/nfs/nfs4_fs.h b/fs/nfs/nfs4_fs.h
index 8d9310e292ed..efa4b4d9ccca 100644
--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@ -268,14 +268,13 @@ extern const struct dentry_operations nfs4_dentry_operations;
 int nfs_atomic_open(struct inode *, struct dentry *, struct file *,
 		    unsigned, umode_t, int *);
 
-/* super.c */
+/* fs_context.c */
 extern struct file_system_type nfs4_fs_type;
 
 /* nfs4namespace.c */
 struct rpc_clnt *nfs4_negotiate_security(struct rpc_clnt *, struct inode *,
 					 const struct qstr *);
-struct vfsmount *nfs4_submount(struct nfs_server *, struct dentry *,
-			       struct nfs_fh *, struct nfs_fattr *);
+int nfs4_submount(struct fs_context *, struct nfs_server *);
 int nfs4_replace_transport(struct nfs_server *server,
 				const struct nfs4_fs_locations *locations);
 
@@ -517,7 +516,6 @@ extern const nfs4_stateid invalid_stateid;
 /* nfs4super.c */
 struct nfs_mount_info;
 extern struct nfs_subversion nfs_v4;
-struct dentry *nfs4_try_mount(int, const char *, struct nfs_mount_info *);
 extern bool nfs4_disable_idmapping;
 extern unsigned short max_session_slots;
 extern unsigned short max_session_cb_slots;
@@ -527,6 +525,9 @@ extern bool recover_lost_locks;
 #define NFS4_CLIENT_ID_UNIQ_LEN		(64)
 extern char nfs4_client_id_uniquifier[NFS4_CLIENT_ID_UNIQ_LEN];
 
+extern int nfs4_try_get_tree(struct fs_context *);
+extern int nfs4_get_referral_tree(struct fs_context *);
+
 /* nfs4sysctl.c */
 #ifdef CONFIG_SYSCTL
 int nfs4_register_sysctl(void);
diff --git a/fs/nfs/nfs4file.c b/fs/nfs/nfs4file.c
index 55ef07c395f4..a916a1ea818c 100644
--- a/fs/nfs/nfs4file.c
+++ b/fs/nfs/nfs4file.c
@@ -7,6 +7,7 @@
 #include <linux/fs.h>
 #include <linux/file.h>
 #include <linux/falloc.h>
+#include <linux/mount.h>
 #include <linux/nfs_fs.h>
 #include "delegation.h"
 #include "internal.h"
diff --git a/fs/nfs/nfs4namespace.c b/fs/nfs/nfs4namespace.c
index 0bb0ca4692b7..813edfbedb29 100644
--- a/fs/nfs/nfs4namespace.c
+++ b/fs/nfs/nfs4namespace.c
@@ -8,6 +8,7 @@
  * NFSv4 namespace
  */
 
+#include <linux/module.h>
 #include <linux/dcache.h>
 #include <linux/mount.h>
 #include <linux/namei.h>
@@ -21,37 +22,64 @@
 #include <linux/inet.h>
 #include "internal.h"
 #include "nfs4_fs.h"
+#include "nfs.h"
 #include "dns_resolve.h"
 
 #define NFSDBG_FACILITY		NFSDBG_VFS
 
+/*
+ * Work out the length that an NFSv4 path would render to as a standard posix
+ * path, with a leading slash but no terminating slash.
+ */
+static ssize_t nfs4_pathname_len(const struct nfs4_pathname *pathname)
+{
+	ssize_t len = 0;
+	int i;
+
+	for (i = 0; i < pathname->ncomponents; i++) {
+		const struct nfs4_string *component = &pathname->components[i];
+
+		if (component->len > NAME_MAX)
+			goto too_long;
+		len += 1 + component->len; /* Adding "/foo" */
+		if (len > PATH_MAX)
+			goto too_long;
+	}
+	return len;
+
+too_long:
+	return -ENAMETOOLONG;
+}
+
 /*
  * Convert the NFSv4 pathname components into a standard posix path.
- *
- * Note that the resulting string will be placed at the end of the buffer
  */
-static inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,
-					 char *buffer, ssize_t buflen)
+static char *nfs4_pathname_string(const struct nfs4_pathname *pathname,
+				  unsigned short *_len)
 {
-	char *end = buffer + buflen;
-	int n;
+	ssize_t len;
+	char *buf, *p;
+	int i;
+
+	len = nfs4_pathname_len(pathname);
+	if (len < 0)
+		return ERR_PTR(len);
+	*_len = len;
+
+	p = buf = kmalloc(len + 1, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < pathname->ncomponents; i++) {
+		const struct nfs4_string *component = &pathname->components[i];
 
-	*--end = '\0';
-	buflen--;
-
-	n = pathname->ncomponents;
-	while (--n >= 0) {
-		const struct nfs4_string *component = &pathname->components[n];
-		buflen -= component->len + 1;
-		if (buflen < 0)
-			goto Elong;
-		end -= component->len;
-		memcpy(end, component->data, component->len);
-		*--end = '/';
+		*p++ = '/';
+		memcpy(p, component->data, component->len);
+		p += component->len;
 	}
-	return end;
-Elong:
-	return ERR_PTR(-ENAMETOOLONG);
+
+	*p = 0;
+	return buf;
 }
 
 /*
@@ -100,21 +128,32 @@ static char *nfs4_path(struct dentry *dentry, char *buffer, ssize_t buflen)
  */
 static int nfs4_validate_fspath(struct dentry *dentry,
 				const struct nfs4_fs_locations *locations,
-				char *page, char *page2)
+				struct nfs_fs_context *ctx)
 {
 	const char *path, *fs_path;
+	char *buf;
+	unsigned short len;
+	int n;
 
-	path = nfs4_path(dentry, page, PAGE_SIZE);
-	if (IS_ERR(path))
+	buf = kmalloc(4096, GFP_KERNEL);
+	path = nfs4_path(dentry, buf, 4096);
+	if (IS_ERR(path)) {
+		kfree(buf);
 		return PTR_ERR(path);
+	}
 
-	fs_path = nfs4_pathname_string(&locations->fs_path, page2, PAGE_SIZE);
-	if (IS_ERR(fs_path))
+	fs_path = nfs4_pathname_string(&locations->fs_path, &len);
+	if (IS_ERR(fs_path)) {
+		kfree(buf);
 		return PTR_ERR(fs_path);
+	}
 
-	if (strncmp(path, fs_path, strlen(fs_path)) != 0) {
+	n = strncmp(path, fs_path, len);
+	kfree(buf);
+	kfree(fs_path);
+	if (n != 0) {
 		dprintk("%s: path %s does not begin with fsroot %s\n",
-			__func__, path, fs_path);
+			__func__, path, ctx->nfs_server.export_path);
 		return -ENOENT;
 	}
 
@@ -236,55 +275,83 @@ nfs4_negotiate_security(struct rpc_clnt *clnt, struct inode *inode,
 	return new;
 }
 
-static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,
-				     char *page, char *page2,
-				     const struct nfs4_fs_location *location)
+static int try_location(struct fs_context *fc,
+			const struct nfs4_fs_location *location)
 {
 	const size_t addr_bufsize = sizeof(struct sockaddr_storage);
-	struct net *net = rpc_net_ns(NFS_SB(mountdata->sb)->client);
-	struct vfsmount *mnt = ERR_PTR(-ENOENT);
-	char *mnt_path;
-	unsigned int maxbuflen;
-	unsigned int s;
+	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+	unsigned int len, s;
+	char *export_path, *source, *p;
+	int ret = -ENOENT;
+
+	/* Allocate a buffer big enough to hold any of the hostnames plus a
+	 * terminating char and also a buffer big enough to hold the hostname
+	 * plus a colon plus the path.
+	 */
+	len = 0;
+	for (s = 0; s < location->nservers; s++) {
+		const struct nfs4_string *buf = &location->servers[s];
+		if (buf->len > len)
+			len = buf->len;
+	}
 
-	mnt_path = nfs4_pathname_string(&location->rootpath, page2, PAGE_SIZE);
-	if (IS_ERR(mnt_path))
-		return ERR_CAST(mnt_path);
-	mountdata->mnt_path = mnt_path;
-	maxbuflen = mnt_path - 1 - page2;
+	kfree(ctx->nfs_server.hostname);
+	ctx->nfs_server.hostname = kmalloc(len + 1, GFP_KERNEL);
+	if (!ctx->nfs_server.hostname)
+		return -ENOMEM;
 
-	mountdata->addr = kmalloc(addr_bufsize, GFP_KERNEL);
-	if (mountdata->addr == NULL)
-		return ERR_PTR(-ENOMEM);
+	export_path = nfs4_pathname_string(&location->rootpath,
+					   &ctx->nfs_server.export_path_len);
+	if (IS_ERR(export_path))
+		return PTR_ERR(export_path);
 
+	ctx->nfs_server.export_path = export_path;
+
+	source = kmalloc(len + 1 + ctx->nfs_server.export_path_len + 1,
+			 GFP_KERNEL);
+	if (!source)
+		return -ENOMEM;
+
+	kfree(fc->source);
+	fc->source = source;
+
+	ctx->clone_data.addr = kmalloc(addr_bufsize, GFP_KERNEL);
+	if (ctx->clone_data.addr == NULL)
+		return -ENOMEM;
 	for (s = 0; s < location->nservers; s++) {
 		const struct nfs4_string *buf = &location->servers[s];
 
-		if (buf->len <= 0 || buf->len >= maxbuflen)
-			continue;
-
 		if (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))
 			continue;
 
-		mountdata->addrlen = nfs_parse_server_name(buf->data, buf->len,
-				mountdata->addr, addr_bufsize, net);
-		if (mountdata->addrlen == 0)
+		ctx->clone_data.addrlen =
+			nfs_parse_server_name(buf->data, buf->len,
+					      ctx->clone_data.addr,
+					      addr_bufsize,
+					      fc->net_ns);
+		if (ctx->clone_data.addrlen == 0)
 			continue;
 
-		memcpy(page2, buf->data, buf->len);
-		page2[buf->len] = '\0';
-		mountdata->hostname = page2;
+		rpc_set_port(ctx->clone_data.addr, NFS_PORT);
 
-		snprintf(page, PAGE_SIZE, "%s:%s",
-				mountdata->hostname,
-				mountdata->mnt_path);
+		memcpy(ctx->nfs_server.hostname, buf->data, buf->len);
+		ctx->nfs_server.hostname[buf->len] = '\0';
+		ctx->clone_data.hostname = ctx->nfs_server.hostname;
 
-		mnt = vfs_submount(mountdata->dentry, &nfs4_referral_fs_type, page, mountdata);
-		if (!IS_ERR(mnt))
-			break;
+		p = source;
+		memcpy(p, buf->data, buf->len);
+		p += buf->len;
+		*p++ = ':';
+		memcpy(p, ctx->nfs_server.export_path, ctx->nfs_server.export_path_len);
+		p += ctx->nfs_server.export_path_len;
+		*p = 0;
+
+		ret = nfs4_get_referral_tree(fc);
+		if (ret == 0)
+			return 0;
 	}
-	kfree(mountdata->addr);
-	return mnt;
+
+	return ret;
 }
 
 /**
@@ -293,38 +360,23 @@ static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,
  * @locations: array of NFSv4 server location information
  *
  */
-static struct vfsmount *nfs_follow_referral(struct dentry *dentry,
-					    const struct nfs4_fs_locations *locations)
+static int nfs_follow_referral(struct fs_context *fc,
+			       const struct nfs4_fs_locations *locations)
 {
-	struct vfsmount *mnt = ERR_PTR(-ENOENT);
-	struct nfs_clone_mount mountdata = {
-		.sb = dentry->d_sb,
-		.dentry = dentry,
-		.authflavor = NFS_SB(dentry->d_sb)->client->cl_auth->au_flavor,
-	};
-	char *page = NULL, *page2 = NULL;
+	struct nfs_fs_context *ctx = nfs_fc2context(fc);
 	int loc, error;
 
 	if (locations == NULL || locations->nlocations <= 0)
-		goto out;
-
-	dprintk("%s: referral at %pd2\n", __func__, dentry);
-
-	page = (char *) __get_free_page(GFP_USER);
-	if (!page)
-		goto out;
+		return -ENOENT;
 
-	page2 = (char *) __get_free_page(GFP_USER);
-	if (!page2)
-		goto out;
+	dprintk("%s: referral at %pd2\n", __func__, ctx->clone_data.dentry);
 
 	/* Ensure fs path is a prefix of current dentry path */
-	error = nfs4_validate_fspath(dentry, locations, page, page2);
-	if (error < 0) {
-		mnt = ERR_PTR(error);
-		goto out;
-	}
+	error = nfs4_validate_fspath(ctx->clone_data.dentry, locations, ctx);
+	if (error < 0)
+		return error;
 
+	error = -ENOENT;
 	for (loc = 0; loc < locations->nlocations; loc++) {
 		const struct nfs4_fs_location *location = &locations->locations[loc];
 
@@ -332,15 +384,12 @@ static struct vfsmount *nfs_follow_referral(struct dentry *dentry,
 		    location->rootpath.ncomponents == 0)
 			continue;
 
-		mnt = try_location(&mountdata, page, page2, location);
-		if (!IS_ERR(mnt))
-			break;
+		error = try_location(fc, location);
+		if (error == 0)
+			return 0;
 	}
 
-out:
-	free_page((unsigned long) page);
-	free_page((unsigned long) page2);
-	return mnt;
+	return error;
 }
 
 /*
@@ -348,71 +397,73 @@ static struct vfsmount *nfs_follow_referral(struct dentry *dentry,
  * @dentry - dentry of referral
  *
  */
-static struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)
+static int nfs_do_refmount(struct fs_context *fc, struct rpc_clnt *client)
 {
-	struct vfsmount *mnt = ERR_PTR(-ENOMEM);
-	struct dentry *parent;
+	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+	struct dentry *dentry, *parent;
 	struct nfs4_fs_locations *fs_locations = NULL;
 	struct page *page;
-	int err;
+	int err = -ENOMEM;
 
 	/* BUG_ON(IS_ROOT(dentry)); */
 	page = alloc_page(GFP_KERNEL);
-	if (page == NULL)
-		return mnt;
+	if (!page)
+		return -ENOMEM;
 
 	fs_locations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);
-	if (fs_locations == NULL)
+	if (!fs_locations)
 		goto out_free;
 
 	/* Get locations */
-	mnt = ERR_PTR(-ENOENT);
-
+	dentry = ctx->clone_data.dentry;
 	parent = dget_parent(dentry);
 	dprintk("%s: getting locations for %pd2\n",
 		__func__, dentry);
 
 	err = nfs4_proc_fs_locations(client, d_inode(parent), &dentry->d_name, fs_locations, page);
 	dput(parent);
-	if (err != 0 ||
-	    fs_locations->nlocations <= 0 ||
+	if (err != 0)
+		goto out_free_2;
+
+	err = -ENOENT;
+	if (fs_locations->nlocations <= 0 ||
 	    fs_locations->fs_path.ncomponents <= 0)
-		goto out_free;
+		goto out_free_2;
 
-	mnt = nfs_follow_referral(dentry, fs_locations);
+	err = nfs_follow_referral(fc, fs_locations);
+out_free_2:
+	kfree(fs_locations);
 out_free:
 	__free_page(page);
-	kfree(fs_locations);
-	return mnt;
+	return err;
 }
 
-struct vfsmount *nfs4_submount(struct nfs_server *server, struct dentry *dentry,
-			       struct nfs_fh *fh, struct nfs_fattr *fattr)
+int nfs4_submount(struct fs_context *fc, struct nfs_server *server)
 {
-	rpc_authflavor_t flavor = server->client->cl_auth->au_flavor;
+	struct nfs_fs_context *ctx = nfs_fc2context(fc);
+	struct dentry *dentry = ctx->clone_data.dentry;
 	struct dentry *parent = dget_parent(dentry);
 	struct inode *dir = d_inode(parent);
 	const struct qstr *name = &dentry->d_name;
 	struct rpc_clnt *client;
-	struct vfsmount *mnt;
+	int ret;
 
 	/* Look it up again to get its attributes and sec flavor */
-	client = nfs4_proc_lookup_mountpoint(dir, name, fh, fattr);
+	client = nfs4_proc_lookup_mountpoint(dir, name, ctx->mount_info.mntfh,
+					     ctx->clone_data.fattr);
 	dput(parent);
 	if (IS_ERR(client))
-		return ERR_CAST(client);
+		return PTR_ERR(client);
 
-	if (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {
-		mnt = nfs_do_refmount(client, dentry);
-		goto out;
+	ctx->selected_flavor = client->cl_auth->au_flavor;
+	if (ctx->clone_data.fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {
+		ret = nfs_do_refmount(fc, client);
+	} else {
+		ret = nfs_do_submount(fc);
 	}
 
-	if (client->cl_auth->au_flavor != flavor)
-		flavor = client->cl_auth->au_flavor;
-	mnt = nfs_do_submount(dentry, fh, fattr, flavor);
-out:
 	rpc_shutdown_client(client);
-	return mnt;
+	return ret;
 }
 
 /*
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index a49eac0b6d31..11c37b5c8e94 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -9962,7 +9962,7 @@ const struct nfs_rpc_ops nfs_v4_clientops = {
 	.file_ops	= &nfs4_file_operations,
 	.getroot	= nfs4_proc_get_root,
 	.submount	= nfs4_submount,
-	.try_mount	= nfs4_try_mount,
+	.try_get_tree	= nfs4_try_get_tree,
 	.getattr	= nfs4_proc_getattr,
 	.setattr	= nfs4_proc_setattr,
 	.lookup		= nfs4_proc_lookup,
* Unmerged path fs/nfs/nfs4super.c
diff --git a/fs/nfs/proc.c b/fs/nfs/proc.c
index 0f7288b94633..44a15523bf40 100644
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@ -710,7 +710,7 @@ const struct nfs_rpc_ops nfs_v2_clientops = {
 	.file_ops	= &nfs_file_operations,
 	.getroot	= nfs_proc_get_root,
 	.submount	= nfs_submount,
-	.try_mount	= nfs_try_mount,
+	.try_get_tree	= nfs_try_get_tree,
 	.getattr	= nfs_proc_getattr,
 	.setattr	= nfs_proc_setattr,
 	.lookup		= nfs_proc_lookup,
* Unmerged path fs/nfs/super.c
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7d64057940d1..863d79a5307d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1615,6 +1615,7 @@ struct nfs_subversion;
 struct nfs_mount_info;
 struct nfs_client_initdata;
 struct nfs_pageio_descriptor;
+struct fs_context;
 
 /*
  * RPC procedure vector for NFSv2/NFSv3 demuxing
@@ -1629,9 +1630,8 @@ struct nfs_rpc_ops {
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);
-	struct vfsmount *(*submount) (struct nfs_server *, struct dentry *,
-				      struct nfs_fh *, struct nfs_fattr *);
-	struct dentry *(*try_mount) (int, const char *, struct nfs_mount_info *);
+	int	(*submount) (struct fs_context *, struct nfs_server *);
+	int	(*try_get_tree) (struct fs_context *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fattr *, struct nfs4_label *,
 			    struct inode *);
