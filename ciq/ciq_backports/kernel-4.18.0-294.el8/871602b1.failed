s390/qeth: only handle IRQs while device is online

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 871602b1079234b2a9279062eaeadb3aad7bc863
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/871602b1.failed

A qeth device that's offline should not be receiving any IRQs - all
pending IOs have been terminated, and we avoid starting any new ones.

So rather than immediately registering the IRQ handler when the device
is probed, only register it while the device is online.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 871602b1079234b2a9279062eaeadb3aad7bc863)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index 2e0e72b477e9,3d2374801308..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -1257,29 -1183,17 +1255,43 @@@ void qeth_drain_output_queues(struct qe
  }
  EXPORT_SYMBOL_GPL(qeth_drain_output_queues);
  
++<<<<<<< HEAD
 +static void qeth_clean_channel(struct qeth_channel *channel)
 +{
 +	struct ccw_device *cdev = channel->ccwdev;
 +
 +	QETH_DBF_TEXT(SETUP, 2, "freech");
 +
 +	spin_lock_irq(get_ccwdev_lock(cdev));
 +	cdev->handler = NULL;
 +	spin_unlock_irq(get_ccwdev_lock(cdev));
 +}
 +
 +static void qeth_setup_channel(struct qeth_channel *channel)
 +{
 +	struct ccw_device *cdev = channel->ccwdev;
 +
 +	QETH_DBF_TEXT(SETUP, 2, "setupch");
 +
 +	channel->state = CH_STATE_DOWN;
 +	atomic_set(&channel->irq_pending, 0);
 +
 +	spin_lock_irq(get_ccwdev_lock(cdev));
 +	cdev->handler = qeth_irq;
 +	spin_unlock_irq(get_ccwdev_lock(cdev));
++=======
+ static void qeth_free_buffer_pool(struct qeth_card *card)
+ {
+ 	struct qeth_buffer_pool_entry *pool_entry, *tmp;
+ 	int i = 0;
+ 	list_for_each_entry_safe(pool_entry, tmp,
+ 				 &card->qdio.init_pool.entry_list, init_list){
+ 		for (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i)
+ 			free_page((unsigned long)pool_entry->elements[i]);
+ 		list_del(&pool_entry->init_list);
+ 		kfree(pool_entry);
+ 	}
++>>>>>>> 871602b10792 (s390/qeth: only handle IRQs while device is online)
  }
  
  static int qeth_osa_set_output_queues(struct qeth_card *card, bool single)
* Unmerged path drivers/s390/net/qeth_core_main.c
