mm: remove "count" parameter from has_unmovable_pages()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Hildenbrand <david@redhat.com>
commit fe4c86c916d9151113372369f322e7436167e6f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fe4c86c9.failed

Now that the memory isolate notifier is gone, the parameter is always 0.
Drop it and cleanup has_unmovable_pages().

Link: http://lkml.kernel.org/r/20191114131911.11783-3-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Anshuman Khandual <anshuman.khandual@arm.com>
	Cc: Qian Cai <cai@lca.pw>
	Cc: Pingfan Liu <kernelfans@gmail.com>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Cc: Wei Yang <richardw.yang@linux.intel.com>
	Cc: Alexander Duyck <alexander.h.duyck@linux.intel.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Arun KS <arunks@codeaurora.org>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit fe4c86c916d9151113372369f322e7436167e6f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/page-isolation.h
#	mm/memory_hotplug.c
#	mm/page_alloc.c
#	mm/page_isolation.c
diff --cc include/linux/page-isolation.h
index 6e9e72274b0d,148e65a9c606..000000000000
--- a/include/linux/page-isolation.h
+++ b/include/linux/page-isolation.h
@@@ -30,8 -30,11 +30,16 @@@ static inline bool is_migrate_isolate(i
  }
  #endif
  
++<<<<<<< HEAD
 +bool has_unmovable_pages(struct zone *zone, struct page *page, int count,
 +			 int migratetype, bool skip_hwpoisoned_pages);
++=======
+ #define MEMORY_OFFLINE	0x1
+ #define REPORT_FAILURE	0x2
+ 
+ bool has_unmovable_pages(struct zone *zone, struct page *page, int migratetype,
+ 			 int flags);
++>>>>>>> fe4c86c916d9 (mm: remove "count" parameter from has_unmovable_pages())
  void set_pageblock_migratetype(struct page *page, int migratetype);
  int move_freepages_block(struct zone *zone, struct page *page,
  				int migratetype, int *num_movable);
diff --cc mm/memory_hotplug.c
index 8eef7031f6d9,c3dc6b27fd6d..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1168,7 -1182,8 +1168,12 @@@ static bool is_pageblock_removable_nolo
  	if (!zone_spans_pfn(zone, pfn))
  		return false;
  
++<<<<<<< HEAD
 +	return !has_unmovable_pages(zone, page, 0, MIGRATE_MOVABLE, true);
++=======
+ 	return !has_unmovable_pages(zone, page, MIGRATE_MOVABLE,
+ 				    MEMORY_OFFLINE);
++>>>>>>> fe4c86c916d9 (mm: remove "count" parameter from has_unmovable_pages())
  }
  
  /* Checks if this range of memory is likely to be hot-removable. */
diff --cc mm/page_alloc.c
index 501b0fde7415,3aec60ddd6d6..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -7838,11 -8186,12 +7837,20 @@@ void *__init alloc_large_system_hash(co
   * check without lock_page also may miss some movable non-lru pages at
   * race condition. So you can't expect this function should be exact.
   */
++<<<<<<< HEAD
 +bool has_unmovable_pages(struct zone *zone, struct page *page, int count,
 +			 int migratetype,
 +			 bool skip_hwpoisoned_pages)
 +{
 +	unsigned long pfn, iter, found;
++=======
+ bool has_unmovable_pages(struct zone *zone, struct page *page, int migratetype,
+ 			 int flags)
+ {
+ 	unsigned long iter = 0;
+ 	unsigned long pfn = page_to_pfn(page);
+ 	const char *reason = "unmovable page";
++>>>>>>> fe4c86c916d9 (mm: remove "count" parameter from has_unmovable_pages())
  
  	/*
  	 * TODO we could make this much more efficient by not checking every
@@@ -7852,23 -8201,24 +7860,32 @@@
  	 * can still lead to having bootmem allocations in zone_movable.
  	 */
  
 -	if (is_migrate_cma_page(page)) {
 -		/*
 -		 * CMA allocations (alloc_contig_range) really need to mark
 -		 * isolate CMA pageblocks even when they are not movable in fact
 -		 * so consider them movable here.
 -		 */
 -		if (is_migrate_cma(migratetype))
 -			return false;
 +	/*
 +	 * CMA allocations (alloc_contig_range) really need to mark isolate
 +	 * CMA pageblocks even when they are not movable in fact so consider
 +	 * them movable here.
 +	 */
 +	if (is_migrate_cma(migratetype) &&
 +			is_migrate_cma(get_pageblock_migratetype(page)))
 +		return false;
 +
++<<<<<<< HEAD
 +	pfn = page_to_pfn(page);
 +	for (found = 0, iter = 0; iter < pageblock_nr_pages; iter++) {
 +		unsigned long check = pfn + iter;
  
 +		if (!pfn_valid_within(check))
++=======
+ 		reason = "CMA page";
+ 		goto unmovable;
+ 	}
+ 
+ 	for (; iter < pageblock_nr_pages; iter++) {
+ 		if (!pfn_valid_within(pfn + iter))
++>>>>>>> fe4c86c916d9 (mm: remove "count" parameter from has_unmovable_pages())
  			continue;
  
- 		page = pfn_to_page(check);
+ 		page = pfn_to_page(pfn + iter);
  
  		if (PageReserved(page))
  			goto unmovable;
@@@ -7914,14 -8264,12 +7931,12 @@@
  		 * The HWPoisoned page may be not in buddy system, and
  		 * page_count() is not 0.
  		 */
 -		if ((flags & MEMORY_OFFLINE) && PageHWPoison(page))
 +		if (skip_hwpoisoned_pages && PageHWPoison(page))
  			continue;
  
- 		if (__PageMovable(page))
+ 		if (__PageMovable(page) || PageLRU(page))
  			continue;
  
- 		if (!PageLRU(page))
- 			found++;
  		/*
  		 * If there are RECLAIMABLE pages, we need to check
  		 * it.  But now, memory offline itself doesn't call
diff --cc mm/page_isolation.c
index 4be9ddcdf5eb,1f8b9dfecbe8..000000000000
--- a/mm/page_isolation.c
+++ b/mm/page_isolation.c
@@@ -60,17 -37,7 +60,21 @@@ static int set_migratetype_isolate(stru
  	 * FIXME: Now, memory hotplug doesn't call shrink_slab() by itself.
  	 * We just check MOVABLE pages.
  	 */
++<<<<<<< HEAD
 +	if (!has_unmovable_pages(zone, page, arg.pages_found, migratetype,
 +				 skip_hwpoisoned_pages))
 +		ret = 0;
 +
 +	/*
 +	 * immobile means "not-on-lru" pages. If immobile is larger than
 +	 * removable-by-driver pages reported by notifier, we'll fail.
 +	 */
 +
 +out:
 +	if (!ret) {
++=======
+ 	if (!has_unmovable_pages(zone, page, migratetype, isol_flags)) {
++>>>>>>> fe4c86c916d9 (mm: remove "count" parameter from has_unmovable_pages())
  		unsigned long nr_pages;
  		int mt = get_pageblock_migratetype(page);
  
* Unmerged path include/linux/page-isolation.h
* Unmerged path mm/memory_hotplug.c
* Unmerged path mm/page_alloc.c
* Unmerged path mm/page_isolation.c
