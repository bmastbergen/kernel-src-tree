iommu/arm-smmu: Rework cb_base handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Robin Murphy <robin.murphy@arm.com>
commit 490325e0c123b2f1f393a679805c580ee69cd2f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/490325e0.failed

To keep register-access quirks manageable, we want to structure things
to avoid needing too many individual overrides. It seems fairly clean to
have a single interface which handles both global and context registers
in terms of the architectural pages, so the first preparatory step is to
rework cb_base into a page number rather than an absolute address.

	Signed-off-by: Robin Murphy <robin.murphy@arm.com>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit 490325e0c123b2f1f393a679805c580ee69cd2f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/arm-smmu.c
diff --cc drivers/iommu/arm-smmu.c
index 6374a0f18d9a,19126230c780..000000000000
--- a/drivers/iommu/arm-smmu.c
+++ b/drivers/iommu/arm-smmu.c
@@@ -1968,15 -1924,16 +1968,22 @@@ static int arm_smmu_device_cfg_probe(st
  	smmu->pgshift = (id & ID1_PAGESIZE) ? 16 : 12;
  
  	/* Check for size mismatch of SMMU address space from mapped region */
++<<<<<<< HEAD
 +	size = 1 << (((id >> ID1_NUMPAGENDXB_SHIFT) & ID1_NUMPAGENDXB_MASK) + 1);
 +	size <<= smmu->pgshift;
 +	if (smmu->cb_base != gr0_base + size)
++=======
+ 	size = 1 << (FIELD_GET(ID1_NUMPAGENDXB, id) + 1);
+ 	if (smmu->numpage != 2 * size << smmu->pgshift)
++>>>>>>> 490325e0c123 (iommu/arm-smmu: Rework cb_base handling)
  		dev_warn(smmu->dev,
- 			"SMMU address space size (0x%lx) differs from mapped region size (0x%tx)!\n",
- 			size * 2, (smmu->cb_base - gr0_base) * 2);
+ 			"SMMU address space size (0x%x) differs from mapped region size (0x%x)!\n",
+ 			2 * size << smmu->pgshift, smmu->numpage);
+ 	/* Now properly encode NUMPAGE to subsequently derive SMMU_CB_BASE */
+ 	smmu->numpage = size;
  
 -	smmu->num_s2_context_banks = FIELD_GET(ID1_NUMS2CB, id);
 -	smmu->num_context_banks = FIELD_GET(ID1_NUMCB, id);
 +	smmu->num_s2_context_banks = (id >> ID1_NUMS2CB_SHIFT) & ID1_NUMS2CB_MASK;
 +	smmu->num_context_banks = (id >> ID1_NUMCB_SHIFT) & ID1_NUMCB_MASK;
  	if (smmu->num_s2_context_banks > smmu->num_context_banks) {
  		dev_err(smmu->dev, "impossible number of S2 context banks!\n");
  		return -ENODEV;
* Unmerged path drivers/iommu/arm-smmu.c
