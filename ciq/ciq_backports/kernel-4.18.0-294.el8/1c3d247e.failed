RDMA/mlx5: Remove mlx5_ib_mr->npages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit 1c3d247eee746016f268a3e7f6b4a11cfa205e8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1c3d247e.failed

This is the same value as ib_umem_num_pages(mr->umem), use that instead.

Link: https://lore.kernel.org/r/20201026131936.1335664-4-leon@kernel.org
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 1c3d247eee746016f268a3e7f6b4a11cfa205e8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/mr.c
diff --cc drivers/infiniband/hw/mlx5/mr.c
index 0ba952308926,b6d9419e05a4..000000000000
--- a/drivers/infiniband/hw/mlx5/mr.c
+++ b/drivers/infiniband/hw/mlx5/mr.c
@@@ -1406,17 -1417,19 +1406,22 @@@ struct ib_mr *mlx5_ib_reg_user_mr(struc
  	mlx5_ib_dbg(dev, "mkey 0x%x\n", mr->mmkey.key);
  
  	mr->umem = umem;
++<<<<<<< HEAD
 +	set_mr_fields(dev, mr, npages, length, access_flags);
++=======
+ 	atomic_add(ib_umem_num_pages(mr->umem), &dev->mdev->priv.reg_pages);
+ 	set_mr_fields(dev, mr, length, access_flags);
++>>>>>>> 1c3d247eee74 (RDMA/mlx5: Remove mlx5_ib_mr->npages)
  
 -	if (xlt_with_umr && !(access_flags & IB_ACCESS_ON_DEMAND)) {
 -		/*
 -		 * If the MR was created with reg_create then it will be
 -		 * configured properly but left disabled. It is safe to go ahead
 -		 * and configure it again via UMR while enabling it.
 -		 */
 +	if (use_umr) {
  		int update_xlt_flags = MLX5_IB_UPD_XLT_ENABLE;
  
 +		if (access_flags & IB_ACCESS_ON_DEMAND)
 +			update_xlt_flags |= MLX5_IB_UPD_XLT_ZAP;
 +
  		err = mlx5_ib_update_xlt(mr, 0, ncont, page_shift,
  					 update_xlt_flags);
 +
  		if (err) {
  			dereg_mr(dev, mr);
  			return ERR_PTR(err);
@@@ -1533,17 -1550,24 +1538,27 @@@ int mlx5_ib_rereg_user_mr(struct ib_mr 
  		 * used.
  		 */
  		flags |= IB_MR_REREG_TRANS;
++<<<<<<< HEAD
++=======
+ 		atomic_sub(ib_umem_num_pages(mr->umem),
+ 			   &dev->mdev->priv.reg_pages);
++>>>>>>> 1c3d247eee74 (RDMA/mlx5: Remove mlx5_ib_mr->npages)
  		ib_umem_release(mr->umem);
  		mr->umem = NULL;
 -
 -		err = mr_umem_get(dev, addr, len, access_flags, &mr->umem,
 -				  &npages, &page_shift, &ncont, &order);
 +		err = mr_umem_get(dev, udata, addr, len, access_flags,
 +				  &mr->umem, &npages, &page_shift, &ncont,
 +				  &order);
  		if (err)
  			goto err;
++<<<<<<< HEAD
++=======
+ 		atomic_add(ib_umem_num_pages(mr->umem),
+ 			   &dev->mdev->priv.reg_pages);
++>>>>>>> 1c3d247eee74 (RDMA/mlx5: Remove mlx5_ib_mr->npages)
  	}
  
 -	if (!mlx5_ib_can_reconfig_with_umr(dev, mr->access_flags,
 -					   access_flags) ||
 -	    !mlx5_ib_can_load_pas_with_umr(dev, len) ||
 -	    (flags & IB_MR_REREG_TRANS &&
 -	     !mlx5_ib_pas_fits_in_mr(mr, addr, len))) {
 +	if (!mlx5_ib_can_use_umr(dev, true, access_flags) ||
 +	    (flags & IB_MR_REREG_TRANS && !use_umr_mtt_update(mr, addr, len))) {
  		/*
  		 * UMR can't be used - MKey needs to be replaced.
  		 */
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index be99598f2e37..47789b0cc5d5 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -608,7 +608,6 @@ struct mlx5_ib_mr {
 	struct list_head	list;
 	unsigned int		order;
 	struct mlx5_cache_ent  *cache_ent;
-	int			npages;
 	struct mlx5_ib_dev     *dev;
 	u32 out[MLX5_ST_SZ_DW(create_mkey_out)];
 	struct mlx5_core_sig_ctx    *sig;
* Unmerged path drivers/infiniband/hw/mlx5/mr.c
