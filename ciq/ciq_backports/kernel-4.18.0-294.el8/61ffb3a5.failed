KVM: arm64: Drop @max param from mmu_topup_memory_cache()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 61ffb3a50c4402e17ead1257914ee98fd8c6f2f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/61ffb3a5.failed

Replace the @max param in mmu_topup_memory_cache() and instead use
ARRAY_SIZE() to terminate the loop to fill the cache.  This removes a
BUG_ON() and sets the stage for moving arm64 to the common memory cache
implementation.

No functional change intended.

	Tested-by: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200703023545.8771-17-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 61ffb3a50c4402e17ead1257914ee98fd8c6f2f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/mmu.c
diff --cc arch/arm64/kvm/mmu.c
index e122989f9bf3,f78aa3e269e9..000000000000
--- a/arch/arm64/kvm/mmu.c
+++ b/arch/arm64/kvm/mmu.c
@@@ -141,11 -128,10 +140,15 @@@ static int mmu_topup_memory_cache(struc
  {
  	void *page;
  
- 	BUG_ON(max > KVM_NR_MEM_OBJS);
  	if (cache->nobjs >= min)
  		return 0;
++<<<<<<< HEAD
 +	while (cache->nobjs < max) {
 +		page = (void *)__get_free_page(PGALLOC_GFP);
++=======
+ 	while (cache->nobjs < ARRAY_SIZE(cache->objects)) {
+ 		page = (void *)__get_free_page(GFP_PGTABLE_USER);
++>>>>>>> 61ffb3a50c44 (KVM: arm64: Drop @max param from mmu_topup_memory_cache())
  		if (!page)
  			return -ENOMEM;
  		cache->objects[cache->nobjs++] = page;
@@@ -1747,11 -1876,10 +1749,10 @@@ static int user_mem_abort(struct kvm_vc
  	if (vma_pagesize == PMD_SIZE ||
  	    (vma_pagesize == PUD_SIZE && kvm_stage2_has_pmd(kvm)))
  		gfn = (fault_ipa & huge_page_mask(hstate_vma(vma))) >> PAGE_SHIFT;
 -	mmap_read_unlock(current->mm);
 +	up_read(&current->mm->mmap_sem);
  
  	/* We need minimum second+third level pages */
- 	ret = mmu_topup_memory_cache(memcache, kvm_mmu_cache_min_pages(kvm),
- 				     KVM_NR_MEM_OBJS);
+ 	ret = mmu_topup_memory_cache(memcache, kvm_mmu_cache_min_pages(kvm));
  	if (ret)
  		return ret;
  
* Unmerged path arch/arm64/kvm/mmu.c
