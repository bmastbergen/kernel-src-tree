net: aquantia: add PTP rings infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Egor Pomozov <epomozov@marvell.com>
commit 94ad94558b0fbf18dd6fb0987540af1693157556
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/94ad9455.failed

Add implementations of PTP rings alloc/free.

PTP desing on this device uses two separate rings on a separate traffic
class for traffic rx/tx.

Third ring (hwts) is not a traffic ring, but is used only to receive timestamps
of the transmitted packets.

	Signed-off-by: Egor Pomozov <epomozov@marvell.com>
Co-developed-by: Sergey Samoilenko <sergey.samoilenko@aquantia.com>
	Signed-off-by: Sergey Samoilenko <sergey.samoilenko@aquantia.com>
Co-developed-by: Dmitry Bezrukov <dmitry.bezrukov@aquantia.com>
	Signed-off-by: Dmitry Bezrukov <dmitry.bezrukov@aquantia.com>
	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 94ad94558b0fbf18dd6fb0987540af1693157556)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_hw.h
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0_internal.h
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 5c8995ae94b5,edc7d83ef5e1..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@@ -238,6 -240,18 +238,21 @@@ struct aq_hw_ops 
  	int (*hw_set_offload)(struct aq_hw_s *self,
  			      struct aq_nic_cfg_s *aq_nic_cfg);
  
++<<<<<<< HEAD
++=======
+ 	int (*hw_tx_tc_mode_get)(struct aq_hw_s *self, u32 *tc_mode);
+ 
+ 	int (*hw_rx_tc_mode_get)(struct aq_hw_s *self, u32 *tc_mode);
+ 
+ 	void (*hw_get_ptp_ts)(struct aq_hw_s *self, u64 *stamp);
+ 
+ 	int (*hw_adj_clock_freq)(struct aq_hw_s *self, s32 delta);
+ 
+ 	int (*hw_adj_sys_clock)(struct aq_hw_s *self, s64 delta);
+ 
+ 	int (*hw_set_sys_clock)(struct aq_hw_s *self, u64 time, u64 ts);
+ 
++>>>>>>> 94ad94558b0f (net: aquantia: add PTP rings infrastructure)
  	int (*hw_set_fc)(struct aq_hw_s *self, u32 fc, u32 tc);
  };
  
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index 0035792b0cff,ecca2c4cf140..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -331,6 -335,18 +331,21 @@@ int aq_nic_init(struct aq_nic_s *self
  		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
  		aq_vec_init(aq_vec, self->aq_hw_ops, self->aq_hw);
  
++<<<<<<< HEAD
++=======
+ 	err = aq_ptp_init(self, self->irqvecs - 1);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	err = aq_ptp_ring_alloc(self);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	err = aq_ptp_ring_init(self);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
++>>>>>>> 94ad94558b0f (net: aquantia: add PTP rings infrastructure)
  	netif_carrier_off(self->ndev);
  
  err_exit:
@@@ -961,6 -994,11 +982,14 @@@ void aq_nic_deinit(struct aq_nic_s *sel
  		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
  		aq_vec_deinit(aq_vec);
  
++<<<<<<< HEAD
++=======
+ 	aq_ptp_unregister(self);
+ 	aq_ptp_ring_deinit(self);
+ 	aq_ptp_ring_free(self);
+ 	aq_ptp_free(self);
+ 
++>>>>>>> 94ad94558b0f (net: aquantia: add PTP rings infrastructure)
  	if (likely(self->aq_fw_ops->deinit)) {
  		mutex_lock(&self->fwreq_mutex);
  		self->aq_fw_ops->deinit(self->aq_hw);
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.c
index 976b4177b47c,8e84ff6eefe3..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
@@@ -1,10 -1,7 +1,14 @@@
 -// SPDX-License-Identifier: GPL-2.0-only
  /*
   * aQuantia Corporation Network Driver
++<<<<<<< HEAD
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+  * Copyright (C) 2014-2019 aQuantia Corporation. All rights reserved
++>>>>>>> 94ad94558b0f (net: aquantia: add PTP rings infrastructure)
   */
  
  /* File aq_ring.c: Definition of functions for Rx/Tx rings. */
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.h
index cfffc301e746,068689f44bc9..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
@@@ -1,10 -1,7 +1,14 @@@
 -/* SPDX-License-Identifier: GPL-2.0-only */
  /*
   * aQuantia Corporation Network Driver
++<<<<<<< HEAD
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+  * Copyright (C) 2014-2019 aQuantia Corporation. All rights reserved
++>>>>>>> 94ad94558b0f (net: aquantia: add PTP rings infrastructure)
   */
  
  /* File aq_ring.h: Declaration of functions for Rx/Tx rings. */
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index 42fdeb412b12,55c7f9985692..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -978,6 -1023,116 +994,119 @@@ static int hw_atl_b0_hw_ring_rx_stop(st
  	return aq_hw_err_from_flags(self);
  }
  
++<<<<<<< HEAD
++=======
+ static int hw_atl_b0_tx_tc_mode_get(struct aq_hw_s *self, u32 *tc_mode)
+ {
+ 	*tc_mode = hw_atl_rpb_tps_tx_tc_mode_get(self);
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
+ static int hw_atl_b0_rx_tc_mode_get(struct aq_hw_s *self, u32 *tc_mode)
+ {
+ 	*tc_mode = hw_atl_rpb_rpf_rx_traf_class_mode_get(self);
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
+ #define get_ptp_ts_val_u64(self, indx) \
+ 	((u64)(hw_atl_pcs_ptp_clock_get(self, indx) & 0xffff))
+ 
+ static void hw_atl_b0_get_ptp_ts(struct aq_hw_s *self, u64 *stamp)
+ {
+ 	u64 ns;
+ 
+ 	hw_atl_pcs_ptp_clock_read_enable(self, 1);
+ 	hw_atl_pcs_ptp_clock_read_enable(self, 0);
+ 	ns = (get_ptp_ts_val_u64(self, 0) +
+ 	      (get_ptp_ts_val_u64(self, 1) << 16)) * NSEC_PER_SEC +
+ 	     (get_ptp_ts_val_u64(self, 3) +
+ 	      (get_ptp_ts_val_u64(self, 4) << 16));
+ 
+ 	*stamp = ns + self->ptp_clk_offset;
+ }
+ 
+ static void hw_atl_b0_adj_params_get(u64 freq, s64 adj, u32 *ns, u32 *fns)
+ {
+ 	/* For accuracy, the digit is extended */
+ 	s64 base_ns = ((adj + NSEC_PER_SEC) * NSEC_PER_SEC);
+ 	u64 nsi_frac = 0;
+ 	u64 nsi;
+ 
+ 	base_ns = div64_s64(base_ns, freq);
+ 	nsi = div64_u64(base_ns, NSEC_PER_SEC);
+ 
+ 	if (base_ns != nsi * NSEC_PER_SEC) {
+ 		s64 divisor = div64_s64((s64)NSEC_PER_SEC * NSEC_PER_SEC,
+ 					base_ns - nsi * NSEC_PER_SEC);
+ 		nsi_frac = div64_s64(FRAC_PER_NS * NSEC_PER_SEC, divisor);
+ 	}
+ 
+ 	*ns = (u32)nsi;
+ 	*fns = (u32)nsi_frac;
+ }
+ 
+ static void
+ hw_atl_b0_mac_adj_param_calc(struct hw_fw_request_ptp_adj_freq *ptp_adj_freq,
+ 			     u64 phyfreq, u64 macfreq)
+ {
+ 	s64 adj_fns_val;
+ 	s64 fns_in_sec_phy = phyfreq * (ptp_adj_freq->fns_phy +
+ 					FRAC_PER_NS * ptp_adj_freq->ns_phy);
+ 	s64 fns_in_sec_mac = macfreq * (ptp_adj_freq->fns_mac +
+ 					FRAC_PER_NS * ptp_adj_freq->ns_mac);
+ 	s64 fault_in_sec_phy = FRAC_PER_NS * NSEC_PER_SEC - fns_in_sec_phy;
+ 	s64 fault_in_sec_mac = FRAC_PER_NS * NSEC_PER_SEC - fns_in_sec_mac;
+ 	/* MAC MCP counter freq is macfreq / 4 */
+ 	s64 diff_in_mcp_overflow = (fault_in_sec_mac - fault_in_sec_phy) *
+ 				   4 * FRAC_PER_NS;
+ 
+ 	diff_in_mcp_overflow = div64_s64(diff_in_mcp_overflow,
+ 					 AQ_HW_MAC_COUNTER_HZ);
+ 	adj_fns_val = (ptp_adj_freq->fns_mac + FRAC_PER_NS *
+ 		       ptp_adj_freq->ns_mac) + diff_in_mcp_overflow;
+ 
+ 	ptp_adj_freq->mac_ns_adj = div64_s64(adj_fns_val, FRAC_PER_NS);
+ 	ptp_adj_freq->mac_fns_adj = adj_fns_val - ptp_adj_freq->mac_ns_adj *
+ 				    FRAC_PER_NS;
+ }
+ 
+ static int hw_atl_b0_adj_sys_clock(struct aq_hw_s *self, s64 delta)
+ {
+ 	self->ptp_clk_offset += delta;
+ 
+ 	return 0;
+ }
+ 
+ static int hw_atl_b0_set_sys_clock(struct aq_hw_s *self, u64 time, u64 ts)
+ {
+ 	s64 delta = time - (self->ptp_clk_offset + ts);
+ 
+ 	return hw_atl_b0_adj_sys_clock(self, delta);
+ }
+ 
+ static int hw_atl_b0_adj_clock_freq(struct aq_hw_s *self, s32 ppb)
+ {
+ 	struct hw_fw_request_iface fwreq;
+ 	size_t size;
+ 
+ 	memset(&fwreq, 0, sizeof(fwreq));
+ 
+ 	fwreq.msg_id = HW_AQ_FW_REQUEST_PTP_ADJ_FREQ;
+ 	hw_atl_b0_adj_params_get(AQ_HW_MAC_COUNTER_HZ, ppb,
+ 				 &fwreq.ptp_adj_freq.ns_mac,
+ 				 &fwreq.ptp_adj_freq.fns_mac);
+ 	hw_atl_b0_adj_params_get(AQ_HW_PHY_COUNTER_HZ, ppb,
+ 				 &fwreq.ptp_adj_freq.ns_phy,
+ 				 &fwreq.ptp_adj_freq.fns_phy);
+ 	hw_atl_b0_mac_adj_param_calc(&fwreq.ptp_adj_freq,
+ 				     AQ_HW_PHY_COUNTER_HZ,
+ 				     AQ_HW_MAC_COUNTER_HZ);
+ 
+ 	size = sizeof(fwreq.msg_id) + sizeof(fwreq.ptp_adj_freq);
+ 	return self->aq_fw_ops->send_fw_request(self, &fwreq, size);
+ }
+ 
++>>>>>>> 94ad94558b0f (net: aquantia: add PTP rings infrastructure)
  static int hw_atl_b0_hw_fl3l4_clear(struct aq_hw_s *self,
  				    struct aq_rx_filter_l3l4 *data)
  {
@@@ -1150,6 -1305,15 +1279,19 @@@ const struct aq_hw_ops hw_atl_ops_b0 = 
  	.hw_get_regs                 = hw_atl_utils_hw_get_regs,
  	.hw_get_hw_stats             = hw_atl_utils_get_hw_stats,
  	.hw_get_fw_version           = hw_atl_utils_get_fw_version,
++<<<<<<< HEAD
 +	.hw_set_offload              = hw_atl_b0_hw_offload_set,
++=======
+ 
+ 	.hw_tx_tc_mode_get       = hw_atl_b0_tx_tc_mode_get,
+ 	.hw_rx_tc_mode_get       = hw_atl_b0_rx_tc_mode_get,
+ 
+ 	.hw_get_ptp_ts           = hw_atl_b0_get_ptp_ts,
+ 	.hw_adj_sys_clock        = hw_atl_b0_adj_sys_clock,
+ 	.hw_set_sys_clock        = hw_atl_b0_set_sys_clock,
+ 	.hw_adj_clock_freq       = hw_atl_b0_adj_clock_freq,
+ 
+ 	.hw_set_offload          = hw_atl_b0_hw_offload_set,
++>>>>>>> 94ad94558b0f (net: aquantia: add PTP rings infrastructure)
  	.hw_set_fc                   = hw_atl_b0_set_fc,
  };
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0_internal.h
index 89d8ee68dea9,7ab23a1751d3..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0_internal.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0_internal.h
@@@ -1,10 -1,7 +1,14 @@@
 -/* SPDX-License-Identifier: GPL-2.0-only */
  /*
   * aQuantia Corporation Network Driver
++<<<<<<< HEAD
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+  * Copyright (C) 2014-2019 aQuantia Corporation. All rights reserved
++>>>>>>> 94ad94558b0f (net: aquantia: add PTP rings infrastructure)
   */
  
  /* File hw_atl_b0_internal.h: Definition of Atlantic B0 chip specific
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_hw.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ptp.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0_internal.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
index 782e2c1c6058..7b6aa623a554 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
@@ -575,6 +575,13 @@ void hw_atl_rpb_rpf_rx_traf_class_mode_set(struct aq_hw_s *aq_hw,
 			    rx_traf_class_mode);
 }
 
+u32 hw_atl_rpb_rpf_rx_traf_class_mode_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_RPB_RPF_RX_TC_MODE_ADR,
+			HW_ATL_RPB_RPF_RX_TC_MODE_MSK,
+			HW_ATL_RPB_RPF_RX_TC_MODE_SHIFT);
+}
+
 void hw_atl_rpb_rx_buff_en_set(struct aq_hw_s *aq_hw, u32 rx_buff_en)
 {
 	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_RX_BUF_EN_ADR,
@@ -1293,6 +1300,13 @@ void hw_atl_tpb_tx_buff_en_set(struct aq_hw_s *aq_hw, u32 tx_buff_en)
 			    HW_ATL_TPB_TX_BUF_EN_SHIFT, tx_buff_en);
 }
 
+u32 hw_atl_rpb_tps_tx_tc_mode_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_TPB_TX_TC_MODE_ADDR,
+			HW_ATL_TPB_TX_TC_MODE_MSK,
+			HW_ATL_TPB_TX_TC_MODE_SHIFT);
+}
+
 void hw_atl_rpb_tps_tx_tc_mode_set(struct aq_hw_s *aq_hw,
 				   u32 tx_traf_class_mode)
 {
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
index 7c6eb27c2fad..2bf036efad8e 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
@@ -295,6 +295,9 @@ void hw_atl_rpb_dma_sys_lbk_set(struct aq_hw_s *aq_hw, u32 dma_sys_lbk);
 void hw_atl_rpb_rpf_rx_traf_class_mode_set(struct aq_hw_s *aq_hw,
 					   u32 rx_traf_class_mode);
 
+/* get rx traffic class mode */
+u32 hw_atl_rpb_rpf_rx_traf_class_mode_get(struct aq_hw_s *aq_hw);
+
 /* set rx buffer enable */
 void hw_atl_rpb_rx_buff_en_set(struct aq_hw_s *aq_hw, u32 rx_buff_en);
 
@@ -608,6 +611,9 @@ void hw_atl_thm_lso_tcp_flag_of_middle_pkt_set(struct aq_hw_s *aq_hw,
 void hw_atl_rpb_tps_tx_tc_mode_set(struct aq_hw_s *aq_hw,
 				   u32 tx_traf_class_mode);
 
+/* get TX Traffic Class Mode */
+u32 hw_atl_rpb_tps_tx_tc_mode_get(struct aq_hw_s *aq_hw);
+
 /* set tx buffer enable */
 void hw_atl_tpb_tx_buff_en_set(struct aq_hw_s *aq_hw, u32 tx_buff_en);
 
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
index 48278e333462..b65ef4cbab11 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
@@ -47,6 +47,14 @@ struct __packed hw_atl_rxd_wb_s {
 	u16 vlan;
 };
 
+/* Hardware rx HW TIMESTAMP writeback */
+struct __packed hw_atl_rxd_hwts_wb_s {
+	u32 sec_hw;
+	u32 ns;
+	u32 sec_lw0;
+	u32 sec_lw1;
+};
+
 struct __packed hw_atl_stats_s {
 	u32 uprc;
 	u32 mprc;
