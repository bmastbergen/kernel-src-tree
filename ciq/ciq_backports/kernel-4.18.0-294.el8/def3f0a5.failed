ALSA: hda/ca0132 - Add quirk output selection structures.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [sound] ALSA: hda/ca0132 - Add quirk output selection structures (Jaroslav Kysela) [1869536]
Rebuild_FUZZ: 99.12%
commit-author Connor McAdams <conmanx360@gmail.com>
commit def3f0a5c7007c899a9a4d4034130e9d175d952d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/def3f0a5.failed

Add structures containing the changes that need to happen on output
selection for each quirk. This should streamline the addition of new
quirks.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
Link: https://lore.kernel.org/r/20200825201040.30339-9-conmanx360@gmail.com
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit def3f0a5c7007c899a9a4d4034130e9d175d952d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 5743bdd7cc88,ab84ea397552..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -4346,88 -4452,108 +4484,111 @@@ static int ca0132_alt_surround_set_bass
   * These are the commands needed to setup output on each of the different card
   * types.
   */
- static void ca0132_alt_select_out_quirk_handler(struct hda_codec *codec)
+ static void ca0132_alt_select_out_get_quirk_data(struct hda_codec *codec,
+ 		const struct ca0132_alt_out_set_quirk_data **quirk_data)
  {
  	struct ca0132_spec *spec = codec->spec;
- 	unsigned int tmp;
+ 	int quirk = ca0132_quirk(spec);
+ 	unsigned int i;
  
- 	switch (spec->cur_out_type) {
- 	case SPEAKER_OUT:
- 		switch (ca0132_quirk(spec)) {
- 		case QUIRK_SBZ:
- 			ca0113_mmio_gpio_set(codec, 7, false);
- 			ca0113_mmio_gpio_set(codec, 4, true);
- 			ca0113_mmio_gpio_set(codec, 1, true);
- 			chipio_set_control_param(codec, 0x0d, 0x18);
- 			break;
- 		case QUIRK_ZXR:
- 			ca0113_mmio_gpio_set(codec, 2, true);
- 			ca0113_mmio_gpio_set(codec, 3, true);
- 			ca0113_mmio_gpio_set(codec, 5, false);
- 			zxr_headphone_gain_set(codec, 0);
- 			chipio_set_control_param(codec, 0x0d, 0x24);
- 			break;
- 		case QUIRK_R3DI:
- 			chipio_set_control_param(codec, 0x0d, 0x24);
- 			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
- 			break;
- 		case QUIRK_R3D:
- 			chipio_set_control_param(codec, 0x0d, 0x24);
- 			ca0113_mmio_gpio_set(codec, 1, true);
- 			break;
- 		case QUIRK_AE5:
- 			ae5_mmio_select_out(codec);
- 			ae5_headphone_gain_set(codec, 2);
- 			tmp = FLOAT_ZERO;
- 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
- 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
- 			chipio_set_control_param(codec, 0x0d, 0xa4);
- 			chipio_write(codec, 0x18b03c, 0x00000012);
- 			break;
- 		default:
- 			break;
+ 	*quirk_data = NULL;
+ 	for (i = 0; i < ARRAY_SIZE(quirk_out_set_data); i++) {
+ 		if (quirk_out_set_data[i].quirk_id == quirk) {
+ 			*quirk_data = &quirk_out_set_data[i];
+ 			return;
  		}
- 		break;
- 	case HEADPHONE_OUT:
- 		switch (ca0132_quirk(spec)) {
- 		case QUIRK_SBZ:
- 			ca0113_mmio_gpio_set(codec, 7, true);
- 			ca0113_mmio_gpio_set(codec, 4, true);
- 			ca0113_mmio_gpio_set(codec, 1, false);
- 			chipio_set_control_param(codec, 0x0d, 0x12);
- 			break;
- 		case QUIRK_ZXR:
- 			ca0113_mmio_gpio_set(codec, 2, false);
- 			ca0113_mmio_gpio_set(codec, 3, false);
- 			ca0113_mmio_gpio_set(codec, 5, true);
- 			zxr_headphone_gain_set(codec, spec->zxr_gain_set);
- 			chipio_set_control_param(codec, 0x0d, 0x21);
- 			break;
- 		case QUIRK_R3DI:
- 			chipio_set_control_param(codec, 0x0d, 0x21);
- 			r3di_gpio_out_set(codec, R3DI_HEADPHONE_OUT);
- 			break;
- 		case QUIRK_R3D:
- 			chipio_set_control_param(codec, 0x0d, 0x21);
- 			ca0113_mmio_gpio_set(codec, 0x1, false);
- 			break;
- 		case QUIRK_AE5:
- 			ae5_mmio_select_out(codec);
- 			ae5_headphone_gain_set(codec,
- 					spec->ae5_headphone_gain_val);
- 			tmp = FLOAT_ONE;
- 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
- 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
- 			chipio_set_control_param(codec, 0x0d, 0xa1);
- 			chipio_write(codec, 0x18b03c, 0x00000012);
- 			break;
- 		default:
- 			break;
+ 	}
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int ca0132_alt_select_out_quirk_set(struct hda_codec *codec)
+ {
+ 	const struct ca0132_alt_out_set_quirk_data *quirk_data;
+ 	const struct ca0132_alt_out_set_info *out_info;
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int i, gpio_data;
+ 	int err;
+ 
+ 	ca0132_alt_select_out_get_quirk_data(codec, &quirk_data);
+ 	if (!quirk_data)
+ 		return 0;
+ 
+ 	out_info = &quirk_data->out_set_info[spec->cur_out_type];
+ 	if (quirk_data->is_ae_series)
+ 		ae5_mmio_select_out(codec);
+ 
+ 	if (out_info->has_hda_gpio) {
+ 		gpio_data = snd_hda_codec_read(codec, codec->core.afg, 0,
+ 				AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 		if (out_info->hda_gpio_set)
+ 			gpio_data |= (1 << out_info->hda_gpio_pin);
+ 		else
+ 			gpio_data &= ~(1 << out_info->hda_gpio_pin);
+ 
+ 		snd_hda_codec_write(codec, codec->core.afg, 0,
+ 				    AC_VERB_SET_GPIO_DATA, gpio_data);
+ 	}
+ 
+ 	if (out_info->mmio_gpio_count) {
+ 		for (i = 0; i < out_info->mmio_gpio_count; i++) {
+ 			ca0113_mmio_gpio_set(codec, out_info->mmio_gpio_pin[i],
+ 					out_info->mmio_gpio_set[i]);
  		}
- 		break;
  	}
+ 
+ 	if (out_info->scp_cmds_count) {
+ 		for (i = 0; i < out_info->scp_cmds_count; i++) {
+ 			err = dspio_set_uint_param(codec,
+ 					out_info->scp_cmd_mid[i],
+ 					out_info->scp_cmd_req[i],
+ 					out_info->scp_cmd_val[i]);
+ 			if (err < 0)
+ 				return err;
+ 		}
+ 	}
+ 
+ 	chipio_set_control_param(codec, 0x0d, out_info->dac2port);
+ 
+ 	if (out_info->has_chipio_write) {
+ 		chipio_write(codec, out_info->chipio_write_addr,
+ 				out_info->chipio_write_data);
+ 	}
+ 
+ 	if (quirk_data->has_headphone_gain) {
+ 		if (spec->cur_out_type != HEADPHONE_OUT) {
+ 			if (quirk_data->is_ae_series)
+ 				ae5_headphone_gain_set(codec, 2);
+ 			else
+ 				zxr_headphone_gain_set(codec, 0);
+ 		} else {
+ 			if (quirk_data->is_ae_series)
+ 				ae5_headphone_gain_set(codec,
+ 						spec->ae5_headphone_gain_val);
+ 			else
+ 				zxr_headphone_gain_set(codec,
+ 						spec->zxr_gain_set);
+ 		}
+ 	}
+ 
+ 	return 0;
  }
  
+ static void ca0132_set_out_node_pincfg(struct hda_codec *codec, hda_nid_t nid,
+ 		bool out_enable, bool hp_enable)
+ {
+ 	unsigned int pin_ctl;
+ 
+ 	pin_ctl = snd_hda_codec_read(codec, nid, 0,
+ 			AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 
+ 	pin_ctl = hp_enable ? pin_ctl | PIN_HP_AMP : pin_ctl & ~PIN_HP_AMP;
+ 	pin_ctl = out_enable ? pin_ctl | PIN_OUT : pin_ctl & ~PIN_OUT;
+ 	snd_hda_set_pin_ctl(codec, nid, pin_ctl);
+ }
+ 
++>>>>>>> def3f0a5c700 (ALSA: hda/ca0132 - Add quirk output selection structures.)
  /*
   * This function behaves similarly to the ca0132_select_out funciton above,
   * except with a few differences. It adds the ability to select the current
* Unmerged path sound/pci/hda/patch_ca0132.c
