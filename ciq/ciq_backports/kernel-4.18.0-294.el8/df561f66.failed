treewide: Use fallthrough pseudo-keyword

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Gustavo A. R. Silva <gustavoars@kernel.org>
commit df561f6688fef775baa341a0f5d960becd248b11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/df561f66.failed

Replace the existing /* fall through */ comments and its variants with
the new pseudo-keyword macro fallthrough[1]. Also, remove unnecessary
fall-through markings when it is the case.

[1] https://www.kernel.org/doc/html/v5.7/process/deprecated.html?highlight=fallthrough#implicit-switch-case-fall-through

	Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
(cherry picked from commit df561f6688fef775baa341a0f5d960becd248b11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arc/kernel/unwind.c
#	arch/arm/kernel/hw_breakpoint.c
#	arch/arm/kernel/signal.c
#	arch/arm/mach-ep93xx/crunch.c
#	arch/arm/mach-rpc/riscpc.c
#	arch/arm/mach-tegra/reset.c
#	arch/arm/mm/alignment.c
#	arch/arm/plat-omap/dma.c
#	arch/arm/probes/kprobes/core.c
#	arch/arm64/kernel/acpi.c
#	arch/arm64/kernel/cpufeature.c
#	arch/arm64/kernel/hw_breakpoint.c
#	arch/arm64/kernel/module.c
#	arch/arm64/kernel/smp.c
#	arch/csky/kernel/signal.c
#	arch/ia64/kernel/signal.c
#	arch/ia64/kernel/unaligned.c
#	arch/mips/include/asm/unroll.h
#	arch/nds32/kernel/fpu.c
#	arch/nds32/kernel/signal.c
#	arch/parisc/mm/fault.c
#	arch/riscv/net/bpf_jit_comp32.c
#	arch/sh/drivers/platform_early.c
#	arch/sh/kernel/disassemble.c
#	arch/sh/kernel/kgdb.c
#	arch/sparc/kernel/kgdb_32.c
#	arch/sparc/kernel/kgdb_64.c
#	arch/sparc/kernel/signal32.c
#	arch/sparc/kernel/signal_32.c
#	arch/sparc/kernel/signal_64.c
#	arch/x86/boot/compressed/kaslr.c
#	arch/x86/kernel/apic/io_apic.c
#	arch/x86/kernel/apic/probe_32.c
#	arch/x86/kernel/cpu/cacheinfo.c
#	arch/x86/kernel/cpu/mtrr/cyrix.c
#	arch/x86/kernel/hw_breakpoint.c
#	arch/x86/kernel/kgdb.c
#	arch/x86/kernel/ptrace.c
#	arch/x86/kernel/uprobes.c
#	arch/x86/lib/insn-eval.c
#	arch/x86/math-emu/errors.c
#	arch/x86/math-emu/fpu_trig.c
#	crypto/tcrypt.c
#	drivers/ata/ahci_brcm.c
#	drivers/ata/libata-eh.c
#	drivers/ata/sata_mv.c
#	drivers/block/ataflop.c
#	drivers/block/drbd/drbd_int.h
#	drivers/block/drbd/drbd_receiver.c
#	drivers/block/drbd/drbd_req.c
#	drivers/block/floppy.c
#	drivers/block/pktcdvd.c
#	drivers/block/rsxx/core.c
#	drivers/bus/ti-sysc.c
#	drivers/char/lp.c
#	drivers/char/mem.c
#	drivers/char/nvram.c
#	drivers/cpufreq/ti-cpufreq.c
#	drivers/crypto/marvell/octeontx/otx_cptvf_reqmgr.c
#	drivers/crypto/ux500/cryp/cryp.c
#	drivers/dma/fsldma.c
#	drivers/dma/imx-dma.c
#	drivers/dma/nbpfaxi.c
#	drivers/dma/pl330.c
#	drivers/edac/amd64_edac.c
#	drivers/firewire/core-device.c
#	drivers/firewire/core-iso.c
#	drivers/firewire/core-topology.c
#	drivers/gpio/gpio-aspeed-sgpio.c
#	drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v10_3.c
#	drivers/gpu/drm/arm/malidp_hw.c
#	drivers/gpu/drm/bridge/nwl-dsi.c
#	drivers/gpu/drm/bridge/ti-sn65dsi86.c
#	drivers/gpu/drm/i915/display/intel_bios.c
#	drivers/gpu/drm/i915/display/intel_cdclk.c
#	drivers/gpu/drm/i915/display/intel_display.c
#	drivers/gpu/drm/i915/display/intel_dpll_mgr.c
#	drivers/gpu/drm/i915/display/intel_panel.c
#	drivers/gpu/drm/i915/display/intel_sdvo.c
#	drivers/gpu/drm/meson/meson_osd_afbcd.c
#	drivers/gpu/drm/meson/meson_overlay.c
#	drivers/gpu/drm/msm/adreno/a5xx_gpu.c
#	drivers/gpu/drm/msm/adreno/a6xx_gmu.c
#	drivers/gpu/drm/msm/adreno/a6xx_gpu.c
#	drivers/gpu/drm/msm/adreno/adreno_gpu.c
#	drivers/gpu/drm/omapdrm/dss/venc.c
#	drivers/gpu/drm/savage/savage_state.c
#	drivers/gpu/drm/sti/sti_hdmi.c
#	drivers/gpu/drm/sun4i/sun4i_tcon.c
#	drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
#	drivers/gpu/drm/via/via_dmablit.c
#	drivers/hsi/clients/ssi_protocol.c
#	drivers/hwmon/adt7462.c
#	drivers/hwmon/emc1403.c
#	drivers/hwmon/f71882fg.c
#	drivers/hwmon/ina3221.c
#	drivers/hwmon/nct6775.c
#	drivers/hwmon/occ/common.c
#	drivers/hwtracing/coresight/coresight-etm4x.c
#	drivers/hwtracing/coresight/coresight-tmc.c
#	drivers/i3c/master/dw-i3c-master.c
#	drivers/ide/hpt366.c
#	drivers/ide/ide-floppy.c
#	drivers/ide/ide-probe.c
#	drivers/ide/ide-taskfile.c
#	drivers/ide/sis5513.c
#	drivers/iio/accel/mma8452.c
#	drivers/iio/adc/ab8500-gpadc.c
#	drivers/iio/chemical/sps30.c
#	drivers/iio/dac/dpot-dac.c
#	drivers/iio/health/max30102.c
#	drivers/iio/imu/adis.c
#	drivers/iio/industrialio-core.c
#	drivers/input/joystick/fsia6b.c
#	drivers/input/touchscreen/atmel_mxt_ts.c
#	drivers/iommu/arm-smmu-v3.c
#	drivers/iommu/virtio-iommu.c
#	drivers/irqchip/irq-imx-gpcv2.c
#	drivers/isdn/hardware/mISDN/avmfritz.c
#	drivers/isdn/hardware/mISDN/hfcpci.c
#	drivers/isdn/hardware/mISDN/mISDNinfineon.c
#	drivers/isdn/hardware/mISDN/mISDNisar.c
#	drivers/isdn/mISDN/stack.c
#	drivers/lightnvm/pblk-core.c
#	drivers/macintosh/smu.c
#	drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
#	drivers/media/dvb-frontends/drx39xyj/drxj.c
#	drivers/media/dvb-frontends/drxd_hard.c
#	drivers/media/dvb-frontends/drxk_hard.c
#	drivers/media/dvb-frontends/mxl5xx.c
#	drivers/memstick/host/jmb38x_ms.c
#	drivers/memstick/host/tifm_ms.c
#	drivers/message/fusion/mptbase.c
#	drivers/message/fusion/mptsas.c
#	drivers/message/fusion/mptscsih.c
#	drivers/mfd/db8500-prcmu.c
#	drivers/mfd/iqs62x.c
#	drivers/mfd/mxs-lradc.c
#	drivers/mfd/omap-usb-host.c
#	drivers/misc/eeprom/at25.c
#	drivers/misc/mic/scif/scif_api.c
#	drivers/misc/mic/scif/scif_rma.c
#	drivers/misc/sgi-gru/grukservices.c
#	drivers/misc/sgi-xp/xpc_partition.c
#	drivers/misc/sgi-xp/xpc_uv.c
#	drivers/mmc/core/host.c
#	drivers/mmc/host/atmel-mci.c
#	drivers/mmc/host/jz4740_mmc.c
#	drivers/mmc/host/meson-mx-sdio.c
#	drivers/mmc/host/sdhci-s3c.c
#	drivers/mmc/host/sdhci-sprd.c
#	drivers/mmc/host/sdhci-xenon-phy.c
#	drivers/mmc/host/tifm_sd.c
#	drivers/mmc/host/usdhi6rol0.c
#	drivers/mux/adgs1408.c
#	drivers/net/appletalk/cops.c
#	drivers/net/arcnet/arc-rimi.c
#	drivers/net/arcnet/com20020-isa.c
#	drivers/net/arcnet/com90io.c
#	drivers/net/arcnet/com90xx.c
#	drivers/net/dsa/b53/b53_serdes.c
#	drivers/net/dsa/microchip/ksz9477.c
#	drivers/net/dsa/mt7530.c
#	drivers/net/ethernet/3com/3c509.c
#	drivers/net/ethernet/8390/axnet_cs.c
#	drivers/net/ethernet/alteon/acenic.c
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c
#	drivers/net/ethernet/broadcom/genet/bcmmii.c
#	drivers/net/ethernet/brocade/bna/bfa_ioc.c
#	drivers/net/ethernet/cadence/macb_ptp.c
#	drivers/net/ethernet/cavium/liquidio/lio_main.c
#	drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
#	drivers/net/ethernet/cavium/thunder/nicvf_ethtool.c
#	drivers/net/ethernet/chelsio/cxgb3/l2t.c
#	drivers/net/ethernet/davicom/dm9000.c
#	drivers/net/ethernet/dec/tulip/de4x5.c
#	drivers/net/ethernet/dec/tulip/tulip_core.c
#	drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
#	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
#	drivers/net/ethernet/ibm/ehea/ehea_main.c
#	drivers/net/ethernet/intel/e1000e/netdev.c
#	drivers/net/ethernet/intel/igb/igb_main.c
#	drivers/net/ethernet/marvell/mvneta.c
#	drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c
#	drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
#	drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
#	drivers/net/ethernet/mediatek/mtk_eth_soc.c
#	drivers/net/ethernet/microchip/lan743x_ethtool.c
#	drivers/net/ethernet/mscc/ocelot.c
#	drivers/net/ethernet/neterion/vxge/vxge-config.c
#	drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
#	drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c
#	drivers/net/ethernet/sfc/falcon/ethtool.c
#	drivers/net/ethernet/smsc/smc911x.c
#	drivers/net/ethernet/socionext/netsec.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
#	drivers/net/ethernet/ti/cpsw_priv.c
#	drivers/net/ethernet/ti/tlan.c
#	drivers/net/ethernet/toshiba/spider_net.c
#	drivers/net/fddi/skfp/pcmplc.c
#	drivers/net/hamradio/baycom_epp.c
#	drivers/net/phy/phy_device.c
#	drivers/net/usb/r8152.c
#	drivers/net/virtio_net.c
#	drivers/net/wan/sdla.c
#	drivers/net/wimax/i2400m/control.c
#	drivers/net/wimax/i2400m/usb-fw.c
#	drivers/net/wimax/i2400m/usb-tx.c
#	drivers/net/wimax/i2400m/usb.c
#	drivers/net/xen-netback/xenbus.c
#	drivers/net/xen-netfront.c
#	drivers/nfc/pn533/pn533.c
#	drivers/nfc/st21nfca/dep.c
#	drivers/parport/ieee1284.c
#	drivers/parport/parport_pc.c
#	drivers/pci/controller/dwc/pci-imx6.c
#	drivers/pci/controller/pci-rcar-gen2.c
#	drivers/pcmcia/db1xxx_ss.c
#	drivers/phy/qualcomm/phy-qcom-usb-hs.c
#	drivers/platform/olpc/olpc-xo175-ec.c
#	drivers/platform/x86/acer-wmi.c
#	drivers/platform/x86/dell-laptop.c
#	drivers/platform/x86/thinkpad_acpi.c
#	drivers/power/supply/ab8500_charger.c
#	drivers/power/supply/axp20x_usb_power.c
#	drivers/power/supply/cros_usbpd-charger.c
#	drivers/power/supply/max8925_power.c
#	drivers/power/supply/wm8350_power.c
#	drivers/rapidio/devices/rio_mport_cdev.c
#	drivers/regulator/axp20x-regulator.c
#	drivers/regulator/slg51000-regulator.c
#	drivers/remoteproc/omap_remoteproc.c
#	drivers/reset/reset-imx7.c
#	drivers/rtc/rtc-m41t80.c
#	drivers/rtc/rtc-pcf85063.c
#	drivers/rtc/rtc-pcf8523.c
#	drivers/scsi/BusLogic.c
#	drivers/scsi/NCR5380.c
#	drivers/scsi/aacraid/aachba.c
#	drivers/scsi/aacraid/linit.c
#	drivers/scsi/aic7xxx/aic79xx_core.c
#	drivers/scsi/aic7xxx/aic7xxx_core.c
#	drivers/scsi/aic94xx/aic94xx_scb.c
#	drivers/scsi/arm/fas216.c
#	drivers/scsi/bfa/bfa_fcpim.c
#	drivers/scsi/bfa/bfa_fcs_lport.c
#	drivers/scsi/bfa/bfa_fcs_rport.c
#	drivers/scsi/bfa/bfa_ioc.c
#	drivers/scsi/csiostor/csio_wr.c
#	drivers/scsi/cxlflash/main.c
#	drivers/scsi/esas2r/esas2r_init.c
#	drivers/scsi/ibmvscsi/ibmvfc.c
#	drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
#	drivers/scsi/imm.c
#	drivers/scsi/isci/phy.c
#	drivers/scsi/isci/remote_device.c
#	drivers/scsi/isci/remote_node_context.c
#	drivers/scsi/isci/request.c
#	drivers/scsi/lpfc/lpfc_sli.c
#	drivers/scsi/myrb.c
#	drivers/scsi/ncr53c8xx.c
#	drivers/scsi/ppa.c
#	drivers/scsi/qla4xxx/ql4_os.c
#	drivers/scsi/qlogicpti.c
#	drivers/scsi/sun3_scsi.c
#	drivers/scsi/sym53c8xx_2/sym_hipd.c
#	drivers/scsi/sym53c8xx_2/sym_nvram.c
#	drivers/scsi/ufs/ufs_bsg.c
#	drivers/scsi/ufs/ufshcd.c
#	drivers/scsi/wd33c93.c
#	drivers/scsi/xen-scsifront.c
#	drivers/soc/qcom/socinfo.c
#	drivers/soc/tegra/pmc.c
#	drivers/spi/spi-sprd-adi.c
#	drivers/ssb/driver_chipcommon.c
#	drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
#	drivers/staging/media/atomisp/pci/atomisp_cmd.c
#	drivers/staging/media/atomisp/pci/atomisp_compat_css20.c
#	drivers/staging/media/atomisp/pci/atomisp_ioctl.c
#	drivers/staging/media/atomisp/pci/atomisp_v4l2.c
#	drivers/staging/media/atomisp/pci/hmm/hmm_bo.c
#	drivers/staging/media/atomisp/pci/sh_css.c
#	drivers/staging/media/hantro/hantro_g1_mpeg2_dec.c
#	drivers/staging/media/hantro/rk3399_vpu_hw_mpeg2_dec.c
#	drivers/staging/media/imx/imx-media-csi.c
#	drivers/thermal/qcom/tsens-v0_1.c
#	drivers/thermal/qcom/tsens-v1.c
#	drivers/tty/hvc/hvc_xen.c
#	drivers/tty/mips_ejtag_fdc.c
#	drivers/tty/n_gsm.c
#	drivers/tty/n_hdlc.c
#	drivers/tty/serial/atmel_serial.c
#	drivers/tty/serial/rda-uart.c
#	drivers/tty/serial/serial-tegra.c
#	drivers/tty/vt/vt.c
#	drivers/usb/gadget/function/f_mass_storage.c
#	drivers/usb/gadget/udc/atmel_usba_udc.c
#	drivers/usb/musb/omap2430.c
#	drivers/video/backlight/adp8860_bl.c
#	drivers/video/fbdev/acornfb.c
#	drivers/video/fbdev/arcfb.c
#	drivers/video/fbdev/controlfb.c
#	drivers/video/fbdev/core/fbmem.c
#	drivers/video/fbdev/fsl-diu-fb.c
#	drivers/video/fbdev/i740fb.c
#	drivers/video/fbdev/offb.c
#	drivers/video/fbdev/omap/omapfb_main.c
#	drivers/video/fbdev/omap2/omapfb/dss/dispc.c
#	drivers/video/fbdev/omap2/omapfb/omapfb-main.c
#	drivers/video/fbdev/pm2fb.c
#	drivers/video/fbdev/s3c-fb.c
#	drivers/video/fbdev/sh_mobile_lcdcfb.c
#	drivers/video/fbdev/stifb.c
#	drivers/video/fbdev/tdfxfb.c
#	drivers/video/fbdev/via/lcd.c
#	drivers/video/fbdev/xen-fbfront.c
#	drivers/watchdog/sc1200wdt.c
#	drivers/xen/xen-pciback/xenbus.c
#	drivers/xen/xen-scsiback.c
#	fs/9p/vfs_file.c
#	fs/adfs/dir_f.c
#	fs/afs/cmservice.c
#	fs/afs/file.c
#	fs/afs/flock.c
#	fs/afs/fsclient.c
#	fs/afs/misc.c
#	fs/afs/rotate.c
#	fs/afs/rxrpc.c
#	fs/afs/vlclient.c
#	fs/afs/yfsclient.c
#	fs/erofs/zmap.c
#	fs/ext2/inode.c
#	fs/f2fs/f2fs.h
#	fs/fcntl.c
#	fs/fs_context.c
#	fs/fsopen.c
#	fs/nfs/fs_context.c
#	fs/pstore/zone.c
#	fs/ubifs/lprops.c
#	fs/vboxsf/utils.c
#	include/linux/compat.h
#	include/linux/mm.h
#	include/linux/signal.h
#	include/linux/skbuff.h
#	include/math-emu/op-common.h
#	ipc/sem.c
#	kernel/bpf/cpumap.c
#	kernel/capability.c
#	kernel/compat.c
#	kernel/debug/gdbstub.c
#	kernel/debug/kdb/kdb_keyboard.c
#	kernel/debug/kdb/kdb_support.c
#	kernel/irq/handle.c
#	kernel/irq/manage.c
#	kernel/power/hibernate.c
#	kernel/signal.c
#	kernel/sys.c
#	kernel/time/hrtimer.c
#	kernel/time/tick-broadcast.c
#	kernel/time/timer.c
#	kernel/trace/trace_events_filter.c
#	lib/asn1_decoder.c
#	lib/assoc_array.c
#	lib/bootconfig.c
#	lib/cmdline.c
#	lib/siphash.c
#	lib/zstd/bitstream.h
#	lib/zstd/compress.c
#	lib/zstd/decompress.c
#	lib/zstd/huf_compress.c
#	net/9p/trans_xen.c
#	net/can/j1939/socket.c
#	net/can/j1939/transport.c
#	net/core/pktgen.c
#	net/core/sock.c
#	net/decnet/dn_nsp_in.c
#	net/iucv/af_iucv.c
#	net/rxrpc/af_rxrpc.c
#	net/rxrpc/input.c
#	net/rxrpc/local_object.c
#	net/rxrpc/peer_event.c
#	net/rxrpc/recvmsg.c
#	net/tipc/bearer.c
#	net/xfrm/xfrm_policy.c
#	security/apparmor/domain.c
#	security/integrity/ima/ima_policy.c
#	security/integrity/ima/ima_template_lib.c
#	security/keys/process_keys.c
#	security/keys/request_key.c
#	security/smack/smack_lsm.c
#	security/tomoyo/common.c
diff --cc arch/arc/kernel/unwind.c
index d34f69eb1a95,74ad4256022e..000000000000
--- a/arch/arc/kernel/unwind.c
+++ b/arch/arc/kernel/unwind.c
@@@ -577,6 -572,7 +577,10 @@@ static unsigned long read_pointer(cons
  #else
  		BUILD_BUG_ON(sizeof(u32) != sizeof(value));
  #endif
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case DW_EH_PE_native:
  		if (end < (const void *)(ptr.pul + 1))
  			return 0;
@@@ -831,7 -827,7 +835,11 @@@ static int processCFI(const u8 *start, 
  			case DW_CFA_def_cfa:
  				state->cfa.reg = get_uleb128(&ptr.p8, end);
  				unw_debug("cfa_def_cfa: r%lu ", state->cfa.reg);
++<<<<<<< HEAD
 +				/*nobreak*/
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case DW_CFA_def_cfa_offset:
  				state->cfa.offs = get_uleb128(&ptr.p8, end);
  				unw_debug("cfa_def_cfa_offset: 0x%lx ",
@@@ -839,7 -835,7 +847,11 @@@
  				break;
  			case DW_CFA_def_cfa_sf:
  				state->cfa.reg = get_uleb128(&ptr.p8, end);
++<<<<<<< HEAD
 +				/*nobreak */
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case DW_CFA_def_cfa_offset_sf:
  				state->cfa.offs = get_sleb128(&ptr.p8, end)
  				    * state->dataAlign;
diff --cc arch/arm/kernel/hw_breakpoint.c
index 1d5fbf1d1c67,7a4853b1213a..000000000000
--- a/arch/arm/kernel/hw_breakpoint.c
+++ b/arch/arm/kernel/hw_breakpoint.c
@@@ -555,6 -547,7 +555,10 @@@ static int arch_build_bp_info(struct pe
  		if ((hw->ctrl.type != ARM_BREAKPOINT_EXECUTE)
  			&& max_watchpoint_len >= 8)
  			break;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return -EINVAL;
  	}
@@@ -619,10 -612,12 +623,18 @@@ int hw_breakpoint_arch_parse(struct per
  		/* Allow halfword watchpoints and breakpoints. */
  		if (hw->ctrl.len == ARM_BREAKPOINT_LEN_2)
  			break;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 3:
  		/* Allow single byte watchpoint. */
  		if (hw->ctrl.len == ARM_BREAKPOINT_LEN_1)
  			break;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		ret = -EINVAL;
  		goto out;
@@@ -872,6 -884,7 +884,10 @@@ static int hw_breakpoint_pending(unsign
  		break;
  	case ARM_ENTRY_ASYNC_WATCHPOINT:
  		WARN(1, "Asynchronous watchpoint exception taken. Debugging results may be unreliable\n");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ARM_ENTRY_SYNC_WATCHPOINT:
  		watchpoint_handler(addr, fsr, regs);
  		break;
@@@ -920,6 -933,7 +936,10 @@@ static bool core_has_os_save_restore(vo
  		ARM_DBG_READ(c1, c1, 4, oslsr);
  		if (oslsr & ARM_OSLSR_OSLM0)
  			return true;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return false;
  	}
diff --cc arch/arm/kernel/signal.c
index 39994201837c,c1892f733f20..000000000000
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@@ -592,6 -596,7 +592,10 @@@ static int do_signal(struct pt_regs *re
  		switch (retval) {
  		case -ERESTART_RESTARTBLOCK:
  			restart -= 2;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case -ERESTARTNOHAND:
  		case -ERESTARTSYS:
  		case -ERESTARTNOINTR:
diff --cc arch/arm/mach-ep93xx/crunch.c
index a4a2ab9648c9,757032d82f63..000000000000
--- a/arch/arm/mach-ep93xx/crunch.c
+++ b/arch/arm/mach-ep93xx/crunch.c
@@@ -52,6 -49,7 +52,10 @@@ static int crunch_do(struct notifier_bl
  		 * FALLTHROUGH: Ensure we don't try to overwrite our newly
  		 * initialised state information on the first fault.
  		 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case THREAD_NOTIFY_EXIT:
  		crunch_task_release(thread);
diff --cc arch/arm/mach-rpc/riscpc.c
index 09d602b10d57,d23970bd638d..000000000000
--- a/arch/arm/mach-rpc/riscpc.c
+++ b/arch/arm/mach-rpc/riscpc.c
@@@ -49,6 -46,7 +49,10 @@@ static int __init parse_tag_acorn(cons
  	switch (tag->u.acorn.vram_pages) {
  	case 512:
  		vram_size += PAGE_SIZE * 256;
++<<<<<<< HEAD
++=======
+ 		fallthrough;	/* ??? */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 256:
  		vram_size += PAGE_SIZE * 256;
  	default:
diff --cc arch/arm/mach-tegra/reset.c
index dc558892753c,d5c805adf7a8..000000000000
--- a/arch/arm/mach-tegra/reset.c
+++ b/arch/arm/mach-tegra/reset.c
@@@ -77,7 -70,7 +77,11 @@@ static void __init tegra_cpu_reset_hand
  	switch (err) {
  	case -ENOSYS:
  		tegra_cpu_reset_handler_set(reset_address);
++<<<<<<< HEAD
 +		/* pass-through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0:
  		is_enabled = true;
  		break;
diff --cc arch/arm/mm/alignment.c
index b54f8f8def36,ea81e89e7740..000000000000
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@@ -698,7 -694,7 +698,11 @@@ thumb2arm(u16 tinstr
  			return subset[(L<<1) | ((tinstr & (1<<8)) >> 8)] |
  			    (tinstr & 255);		/* register_list */
  		}
++<<<<<<< HEAD
 +		/* Else fall through for illegal instruction case */
++=======
+ 		fallthrough;	/* for illegal instruction case */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		return BAD_INSTR;
@@@ -754,6 -750,8 +758,11 @@@ do_alignment_t32_to_handler(unsigned lo
  	case 0xe8e0:
  	case 0xe9e0:
  		poffset->un = (tinst2 & 0xff) << 2;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0xe940:
  	case 0xe9c0:
  		return do_alignment_ldrdstrd;
diff --cc arch/arm/plat-omap/dma.c
index d4012d6c0dcb,1eb59003bdec..000000000000
--- a/arch/arm/plat-omap/dma.c
+++ b/arch/arm/plat-omap/dma.c
@@@ -392,17 -308,15 +392,26 @@@ void omap_set_dma_src_burst_mode(int lc
  		/*
  		 * not supported by current hardware on OMAP1
  		 * w |= (0x03 << 7);
 +		 * fall through
  		 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case OMAP_DMA_DATA_BURST_16:
  		if (dma_omap2plus()) {
  			burst = 0x3;
  			break;
  		}
++<<<<<<< HEAD
 +		/*
 +		 * OMAP1 don't support burst 16
 +		 * fall through
 +		 */
++=======
+ 		/* OMAP1 don't support burst 16 */
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		BUG();
  	}
@@@ -478,10 -392,8 +487,15 @@@ void omap_set_dma_dest_burst_mode(int l
  			burst = 0x3;
  			break;
  		}
++<<<<<<< HEAD
 +		/*
 +		 * OMAP1 don't support burst 16
 +		 * fall through
 +		 */
++=======
+ 		/* OMAP1 don't support burst 16 */
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		printk(KERN_ERR "Invalid DMA burst mode\n");
  		BUG();
diff --cc arch/arm/probes/kprobes/core.c
index e90cc8a08186,feefa2055eba..000000000000
--- a/arch/arm/probes/kprobes/core.c
+++ b/arch/arm/probes/kprobes/core.c
@@@ -289,9 -278,9 +289,15 @@@ void __kprobes kprobe_handler(struct pt
  				break;
  			case KPROBE_REENTER:
  				/* A nested probe was hit in FIQ, it is a BUG */
++<<<<<<< HEAD
 +				pr_warn("Unrecoverable kprobe detected at %p.\n",
 +					p->addr);
 +				/* fall through */
++=======
+ 				pr_warn("Unrecoverable kprobe detected.\n");
+ 				dump_kprobe(p);
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			default:
  				/* impossible cases */
  				BUG();
diff --cc arch/arm64/kernel/acpi.c
index 55869d464c00,a85174d05473..000000000000
--- a/arch/arm64/kernel/acpi.c
+++ b/arch/arm64/kernel/acpi.c
@@@ -259,6 -261,81 +259,84 @@@ pgprot_t __acpi_get_mem_attribute(phys_
  	return __pgprot(PROT_DEVICE_nGnRnE);
  }
  
++<<<<<<< HEAD
++=======
+ void __iomem *acpi_os_ioremap(acpi_physical_address phys, acpi_size size)
+ {
+ 	efi_memory_desc_t *md, *region = NULL;
+ 	pgprot_t prot;
+ 
+ 	if (WARN_ON_ONCE(!efi_enabled(EFI_MEMMAP)))
+ 		return NULL;
+ 
+ 	for_each_efi_memory_desc(md) {
+ 		u64 end = md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT);
+ 
+ 		if (phys < md->phys_addr || phys >= end)
+ 			continue;
+ 
+ 		if (phys + size > end) {
+ 			pr_warn(FW_BUG "requested region covers multiple EFI memory regions\n");
+ 			return NULL;
+ 		}
+ 		region = md;
+ 		break;
+ 	}
+ 
+ 	/*
+ 	 * It is fine for AML to remap regions that are not represented in the
+ 	 * EFI memory map at all, as it only describes normal memory, and MMIO
+ 	 * regions that require a virtual mapping to make them accessible to
+ 	 * the EFI runtime services.
+ 	 */
+ 	prot = __pgprot(PROT_DEVICE_nGnRnE);
+ 	if (region) {
+ 		switch (region->type) {
+ 		case EFI_LOADER_CODE:
+ 		case EFI_LOADER_DATA:
+ 		case EFI_BOOT_SERVICES_CODE:
+ 		case EFI_BOOT_SERVICES_DATA:
+ 		case EFI_CONVENTIONAL_MEMORY:
+ 		case EFI_PERSISTENT_MEMORY:
+ 			pr_warn(FW_BUG "requested region covers kernel memory @ %pa\n", &phys);
+ 			return NULL;
+ 
+ 		case EFI_RUNTIME_SERVICES_CODE:
+ 			/*
+ 			 * This would be unusual, but not problematic per se,
+ 			 * as long as we take care not to create a writable
+ 			 * mapping for executable code.
+ 			 */
+ 			prot = PAGE_KERNEL_RO;
+ 			break;
+ 
+ 		case EFI_ACPI_RECLAIM_MEMORY:
+ 			/*
+ 			 * ACPI reclaim memory is used to pass firmware tables
+ 			 * and other data that is intended for consumption by
+ 			 * the OS only, which may decide it wants to reclaim
+ 			 * that memory and use it for something else. We never
+ 			 * do that, but we usually add it to the linear map
+ 			 * anyway, in which case we should use the existing
+ 			 * mapping.
+ 			 */
+ 			if (memblock_is_map_memory(phys))
+ 				return (void __iomem *)__phys_to_virt(phys);
+ 			fallthrough;
+ 
+ 		default:
+ 			if (region->attribute & EFI_MEMORY_WB)
+ 				prot = PAGE_KERNEL;
+ 			else if (region->attribute & EFI_MEMORY_WT)
+ 				prot = __pgprot(PROT_NORMAL_WT);
+ 			else if (region->attribute & EFI_MEMORY_WC)
+ 				prot = __pgprot(PROT_NORMAL_NC);
+ 		}
+ 	}
+ 	return __ioremap(phys, size, prot);
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  /*
   * Claim Synchronous External Aborts as a firmware first notification.
   *
diff --cc arch/arm64/kernel/cpufeature.c
index c4f31f30b2c0,6424584be01e..000000000000
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@@ -490,6 -683,10 +490,13 @@@ static s64 arm64_ftr_safe_value(const s
  	case FTR_LOWER_SAFE:
  		ret = new < cur ? new : cur;
  		break;
++<<<<<<< HEAD
++=======
+ 	case FTR_HIGHER_OR_ZERO_SAFE:
+ 		if (!cur || !new)
+ 			break;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FTR_HIGHER_SAFE:
  		ret = new > cur ? new : cur;
  		break;
diff --cc arch/arm64/kernel/hw_breakpoint.c
index 8c9644376326,712e97c03e54..000000000000
--- a/arch/arm64/kernel/hw_breakpoint.c
+++ b/arch/arm64/kernel/hw_breakpoint.c
@@@ -554,6 -540,14 +554,17 @@@ int hw_breakpoint_arch_parse(struct per
  			/* Allow halfword watchpoints and breakpoints. */
  			if (hw->ctrl.len == ARM_BREAKPOINT_LEN_2)
  				break;
++<<<<<<< HEAD
++=======
+ 
+ 			fallthrough;
+ 		case 3:
+ 			/* Allow single byte watchpoint. */
+ 			if (hw->ctrl.len == ARM_BREAKPOINT_LEN_1)
+ 				break;
+ 
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			return -EINVAL;
  		}
diff --cc arch/arm64/kernel/module.c
index f0f27aeefb73,2a1ad95d9b2c..000000000000
--- a/arch/arm64/kernel/module.c
+++ b/arch/arm64/kernel/module.c
@@@ -288,18 -315,21 +288,30 @@@ int apply_relocate_add(Elf64_Shdr *sech
  		/* MOVW instruction relocations. */
  		case R_AARCH64_MOVW_UABS_G0_NC:
  			overflow_check = false;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case R_AARCH64_MOVW_UABS_G0:
  			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 0,
  					      AARCH64_INSN_IMM_MOVKZ);
  			break;
  		case R_AARCH64_MOVW_UABS_G1_NC:
  			overflow_check = false;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case R_AARCH64_MOVW_UABS_G1:
  			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 16,
  					      AARCH64_INSN_IMM_MOVKZ);
  			break;
  		case R_AARCH64_MOVW_UABS_G2_NC:
  			overflow_check = false;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case R_AARCH64_MOVW_UABS_G2:
  			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 32,
  					      AARCH64_INSN_IMM_MOVKZ);
@@@ -367,8 -397,9 +379,12 @@@
  			break;
  		case R_AARCH64_ADR_PREL_PG_HI21_NC:
  			overflow_check = false;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case R_AARCH64_ADR_PREL_PG_HI21:
 -			ovf = reloc_insn_adrp(me, sechdrs, loc, val);
 +			ovf = reloc_insn_adrp(me, loc, val);
  			if (ovf && ovf != -ERANGE)
  				return ovf;
  			break;
diff --cc arch/arm64/kernel/smp.c
index 879dd1a8ab13,355ee9eed4dd..000000000000
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@@ -127,60 -115,58 +127,77 @@@ int __cpu_up(unsigned int cpu, struct t
  	update_cpu_boot_status(CPU_MMU_OFF);
  	__flush_dcache_area(&secondary_data, sizeof(secondary_data));
  
 -	/* Now bring the CPU into our world */
 +	/*
 +	 * Now bring the CPU into our world.
 +	 */
  	ret = boot_secondary(cpu, idle);
 -	if (ret) {
 +	if (ret == 0) {
 +		/*
 +		 * CPU was successfully started, wait for it to come online or
 +		 * time out.
 +		 */
 +		wait_for_completion_timeout(&cpu_running,
 +					    msecs_to_jiffies(5000));
 +
 +		if (!cpu_online(cpu)) {
 +			pr_crit("CPU%u: failed to come online\n", cpu);
 +
 +			if (IS_ENABLED(CONFIG_ARM64_USER_VA_BITS_52) && va52mismatch)
 +				pr_crit("CPU%u: does not support 52-bit VAs\n", cpu);
 +
 +			ret = -EIO;
 +		}
 +	} else {
  		pr_err("CPU%u: failed to boot: %d\n", cpu, ret);
 -		return ret;
  	}
  
 -	/*
 -	 * CPU was successfully started, wait for it to come online or
 -	 * time out.
 -	 */
 -	wait_for_completion_timeout(&cpu_running,
 -				    msecs_to_jiffies(5000));
 -	if (cpu_online(cpu))
 -		return 0;
 -
 -	pr_crit("CPU%u: failed to come online\n", cpu);
  	secondary_data.task = NULL;
  	secondary_data.stack = NULL;
 -	__flush_dcache_area(&secondary_data, sizeof(secondary_data));
  	status = READ_ONCE(secondary_data.status);
 -	if (status == CPU_MMU_OFF)
 -		status = READ_ONCE(__early_cpu_boot_status);
 +	if (ret && status) {
  
 -	switch (status & CPU_BOOT_STATUS_MASK) {
 -	default:
 -		pr_err("CPU%u: failed in unknown state : 0x%lx\n",
 -		       cpu, status);
 -		cpus_stuck_in_kernel++;
 -		break;
 -	case CPU_KILL_ME:
 -		if (!op_cpu_kill(cpu)) {
 -			pr_crit("CPU%u: died during early boot\n", cpu);
 +		if (status == CPU_MMU_OFF)
 +			status = READ_ONCE(__early_cpu_boot_status);
 +
 +		switch (status) {
 +		default:
 +			pr_err("CPU%u: failed in unknown state : 0x%lx\n",
 +					cpu, status);
  			break;
 +		case CPU_KILL_ME:
 +			if (!op_cpu_kill(cpu)) {
 +				pr_crit("CPU%u: died during early boot\n", cpu);
 +				break;
 +			}
 +			/* Fall through */
 +			pr_crit("CPU%u: may not have shut down cleanly\n", cpu);
 +		case CPU_STUCK_IN_KERNEL:
 +			pr_crit("CPU%u: is stuck in kernel\n", cpu);
 +			cpus_stuck_in_kernel++;
 +			break;
 +		case CPU_PANIC_KERNEL:
 +			panic("CPU%u detected unsupported configuration\n", cpu);
  		}
++<<<<<<< HEAD
++=======
+ 		pr_crit("CPU%u: may not have shut down cleanly\n", cpu);
+ 		fallthrough;
+ 	case CPU_STUCK_IN_KERNEL:
+ 		pr_crit("CPU%u: is stuck in kernel\n", cpu);
+ 		if (status & CPU_STUCK_REASON_52_BIT_VA)
+ 			pr_crit("CPU%u: does not support 52-bit VAs\n", cpu);
+ 		if (status & CPU_STUCK_REASON_NO_GRAN) {
+ 			pr_crit("CPU%u: does not support %luK granule\n",
+ 				cpu, PAGE_SIZE / SZ_1K);
+ 		}
+ 		cpus_stuck_in_kernel++;
+ 		break;
+ 	case CPU_PANIC_KERNEL:
+ 		panic("CPU%u detected unsupported configuration\n", cpu);
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	}
  
 -	return -EIO;
 +	return ret;
  }
  
  static void init_gic_priority_masking(void)
diff --cc arch/ia64/kernel/signal.c
index b08f6c2e2455,e67b22fc3c60..000000000000
--- a/arch/ia64/kernel/signal.c
+++ b/arch/ia64/kernel/signal.c
@@@ -409,7 -374,8 +409,12 @@@ ia64_do_signal (struct sigscratch *scr
  					/* note: scr->pt.r10 is already -1 */
  					break;
  				}
++<<<<<<< HEAD
 +			      case ERESTARTNOINTR:
++=======
+ 				fallthrough;
+ 			case ERESTARTNOINTR:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  				ia64_decrement_ip(&scr->pt);
  				restart = 0; /* don't restart twice if handle_signal() fails... */
  			}
diff --cc arch/ia64/kernel/unaligned.c
index e309f9859acc,6c1a8951dfbb..000000000000
--- a/arch/ia64/kernel/unaligned.c
+++ b/arch/ia64/kernel/unaligned.c
@@@ -1432,7 -1431,7 +1432,11 @@@ ia64_handle_unaligned (unsigned long if
  		if (u.insn.x)
  			/* oops, really a semaphore op (cmpxchg, etc) */
  			goto failure;
++<<<<<<< HEAD
 +		/* no break */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	      case LDS_IMM_OP:
  	      case LDSA_IMM_OP:
  	      case LDFS_OP:
@@@ -1460,7 -1459,7 +1464,11 @@@
  		if (u.insn.x)
  			/* oops, really a semaphore op (cmpxchg, etc) */
  			goto failure;
++<<<<<<< HEAD
 +		/* no break */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	      case LD_IMM_OP:
  	      case LDA_IMM_OP:
  	      case LDBIAS_IMM_OP:
@@@ -1476,7 -1475,7 +1484,11 @@@
  		if (u.insn.x)
  			/* oops, really a semaphore op (cmpxchg, etc) */
  			goto failure;
++<<<<<<< HEAD
 +		/* no break */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	      case ST_IMM_OP:
  	      case STREL_IMM_OP:
  		ret = emulate_store_int(ifa, u.insn, regs);
diff --cc arch/nds32/kernel/signal.c
index 4fccf9f2d436,36e25a410bb0..000000000000
--- a/arch/nds32/kernel/signal.c
+++ b/arch/nds32/kernel/signal.c
@@@ -256,6 -316,7 +256,10 @@@ static void handle_signal(struct ksigna
  				regs->uregs[0] = -EINTR;
  				break;
  			}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case -ERESTARTNOINTR:
  			regs->uregs[0] = regs->orig_r0;
  			regs->ipc -= 4;
@@@ -300,6 -361,7 +304,10 @@@ static void do_signal(struct pt_regs *r
  		switch (regs->uregs[0]) {
  		case -ERESTART_RESTARTBLOCK:
  			regs->uregs[15] = __NR_restart_syscall;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case -ERESTARTNOHAND:
  		case -ERESTARTSYS:
  		case -ERESTARTNOINTR:
diff --cc arch/parisc/mm/fault.c
index f1725498f102,716960f5d92e..000000000000
--- a/arch/parisc/mm/fault.c
+++ b/arch/parisc/mm/fault.c
@@@ -66,6 -67,7 +66,10 @@@ parisc_acctyp(unsigned long code, unsig
  	case 0x30000000: /* coproc2 */
  		if (bit22set(inst))
  			return VM_WRITE;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case 0x0: /* indexed/memory management */
  		if (bit22set(inst)) {
diff --cc arch/sh/kernel/disassemble.c
index 015fee58014b,34e25a439c81..000000000000
--- a/arch/sh/kernel/disassemble.c
+++ b/arch/sh/kernel/disassemble.c
@@@ -488,20 -483,21 +488,28 @@@ static void print_sh_insn(u32 memaddr, 
  				break;
  			case DX_REG_N:
  				if (rn & 1) {
 -					pr_cont("xd%d", rn & ~1);
 +					printk("xd%d", rn & ~1);
  					break;
  				}
++<<<<<<< HEAD
 +			d_reg_n:
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case D_REG_N:
 -				pr_cont("dr%d", rn);
 +				printk("dr%d", rn);
  				break;
  			case DX_REG_M:
  				if (rm & 1) {
 -					pr_cont("xd%d", rm & ~1);
 +					printk("xd%d", rm & ~1);
  					break;
  				}
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case D_REG_M:
 -				pr_cont("dr%d", rm);
 +				printk("dr%d", rm);
  				break;
  			case FPSCR_M:
  			case FPSCR_N:
diff --cc arch/sh/kernel/kgdb.c
index 4f04c6638a4d,e4147efa9ec6..000000000000
--- a/arch/sh/kernel/kgdb.c
+++ b/arch/sh/kernel/kgdb.c
@@@ -269,6 -266,7 +269,10 @@@ int kgdb_arch_handle_exception(int e_ve
  		ptr = &remcomInBuffer[1];
  		if (kgdb_hex2long(&ptr, &addr))
  			linux_regs->pc = addr;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 'D':
  	case 'k':
  		atomic_set(&kgdb_cpu_doing_single_step, -1);
diff --cc arch/sparc/kernel/kgdb_32.c
index 5868fc333ea8,58ad3f7de1fb..000000000000
--- a/arch/sparc/kernel/kgdb_32.c
+++ b/arch/sparc/kernel/kgdb_32.c
@@@ -122,7 -122,7 +122,11 @@@ int kgdb_arch_handle_exception(int e_ve
  			linux_regs->pc = addr;
  			linux_regs->npc = addr + 4;
  		}
++<<<<<<< HEAD
 +		/* fallthru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case 'D':
  	case 'k':
diff --cc arch/sparc/kernel/kgdb_64.c
index d5f7dc6323d5,177746ae2c81..000000000000
--- a/arch/sparc/kernel/kgdb_64.c
+++ b/arch/sparc/kernel/kgdb_64.c
@@@ -148,7 -148,7 +148,11 @@@ int kgdb_arch_handle_exception(int e_ve
  			linux_regs->tpc = addr;
  			linux_regs->tnpc = addr + 4;
  		}
++<<<<<<< HEAD
 +		/* fallthru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case 'D':
  	case 'k':
diff --cc arch/sparc/kernel/signal32.c
index 44d379db3f64,e9695a06492f..000000000000
--- a/arch/sparc/kernel/signal32.c
+++ b/arch/sparc/kernel/signal32.c
@@@ -675,6 -686,7 +675,10 @@@ void do_signal32(struct pt_regs * regs
  				regs->tpc -= 4;
  				regs->tnpc -= 4;
  				pt_regs_clear_syscall(regs);
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case ERESTART_RESTARTBLOCK:
  				regs->u_regs[UREG_G1] = __NR_restart_syscall;
  				regs->tpc -= 4;
diff --cc arch/sparc/kernel/signal_32.c
index 5665261cee37,d0e0025ee3ba..000000000000
--- a/arch/sparc/kernel/signal_32.c
+++ b/arch/sparc/kernel/signal_32.c
@@@ -508,6 -506,7 +508,10 @@@ static void do_signal(struct pt_regs *r
  				regs->pc -= 4;
  				regs->npc -= 4;
  				pt_regs_clear_syscall(regs);
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case ERESTART_RESTARTBLOCK:
  				regs->u_regs[UREG_G1] = __NR_restart_syscall;
  				regs->pc -= 4;
diff --cc arch/sparc/kernel/signal_64.c
index 48366e5eb5b2,255264bcb46a..000000000000
--- a/arch/sparc/kernel/signal_64.c
+++ b/arch/sparc/kernel/signal_64.c
@@@ -529,6 -532,7 +529,10 @@@ static void do_signal(struct pt_regs *r
  				regs->tpc -= 4;
  				regs->tnpc -= 4;
  				pt_regs_clear_syscall(regs);
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case ERESTART_RESTARTBLOCK:
  				regs->u_regs[UREG_G1] = __NR_restart_syscall;
  				regs->tpc -= 4;
diff --cc arch/x86/boot/compressed/kaslr.c
index d375b8f0f703,dde7cb3724df..000000000000
--- a/arch/x86/boot/compressed/kaslr.c
+++ b/arch/x86/boot/compressed/kaslr.c
@@@ -159,9 -155,30 +159,36 @@@ parse_memmap(char *p, unsigned long lon
  		*start = memparse(p + 1, &p);
  		return 0;
  	case '@':
++<<<<<<< HEAD
 +		/* memmap=nn@ss specifies usable region, should be skipped */
 +		*size = 0;
 +		/* Fall through */
++=======
+ 		if (mode == PARSE_MEMMAP) {
+ 			/*
+ 			 * memmap=nn@ss specifies usable region, should
+ 			 * be skipped
+ 			 */
+ 			*size = 0;
+ 		} else {
+ 			unsigned long long flags;
+ 
+ 			/*
+ 			 * efi_fake_mem=nn@ss:attr the attr specifies
+ 			 * flags that might imply a soft-reservation.
+ 			 */
+ 			*start = memparse(p + 1, &p);
+ 			if (p && *p == ':') {
+ 				p++;
+ 				if (kstrtoull(p, 0, &flags) < 0)
+ 					*size = 0;
+ 				else if (flags & EFI_MEMORY_SP)
+ 					return 0;
+ 			}
+ 			*size = 0;
+ 		}
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		/*
  		 * If w/o offset, only size specified, memmap=nn[KMG] has the
diff --cc arch/x86/kernel/apic/io_apic.c
index fbac72520919,779a89e31c4c..000000000000
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@@ -813,6 -800,7 +813,10 @@@ static int irq_polarity(int idx
  		return IOAPIC_POL_HIGH;
  	case MP_IRQPOL_RESERVED:
  		pr_warn("IOAPIC: Invalid polarity: 2, defaulting to low\n");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MP_IRQPOL_ACTIVE_LOW:
  	default: /* Pointless default required due to do gcc stupidity */
  		return IOAPIC_POL_LOW;
@@@ -860,6 -848,7 +864,10 @@@ static int irq_trigger(int idx
  		return IOAPIC_EDGE;
  	case MP_IRQTRIG_RESERVED:
  		pr_warn("IOAPIC: Invalid trigger mode 2 defaulting to level\n");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MP_IRQTRIG_LEVEL:
  	default: /* Pointless default required due to do gcc stupidity */
  		return IOAPIC_LEVEL;
diff --cc arch/x86/kernel/apic/probe_32.c
index fe7cbbef63ef,99ee61c9ba54..000000000000
--- a/arch/x86/kernel/apic/probe_32.c
+++ b/arch/x86/kernel/apic/probe_32.c
@@@ -184,7 -148,9 +184,13 @@@ void __init default_setup_apic_routing(
  				def_to_bigsmp = 0;
  				break;
  			}
++<<<<<<< HEAD
 +			/* If P4 and above fall through */
++=======
+ 			/* P4 and above */
+ 			fallthrough;
+ 		case X86_VENDOR_HYGON:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case X86_VENDOR_AMD:
  			def_to_bigsmp = 1;
  		}
diff --cc arch/x86/kernel/cpu/cacheinfo.c
index 0c5fcbd998cf,57074cf3ad7c..000000000000
--- a/arch/x86/kernel/cpu/cacheinfo.c
+++ b/arch/x86/kernel/cpu/cacheinfo.c
@@@ -247,6 -248,7 +247,10 @@@ amd_cpuid4(int leaf, union _cpuid4_leaf
  	switch (leaf) {
  	case 1:
  		l1 = &l1i;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0:
  		if (!l1->val)
  			return;
diff --cc arch/x86/kernel/cpu/mtrr/cyrix.c
index 4296c702a3f7,ca670919b561..000000000000
--- a/arch/x86/kernel/cpu/mtrr/cyrix.c
+++ b/arch/x86/kernel/cpu/mtrr/cyrix.c
@@@ -98,6 -98,7 +98,10 @@@ cyrix_get_free_region(unsigned long bas
  	case 7:
  		if (size < 0x40)
  			break;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 6:
  	case 5:
  	case 4:
diff --cc arch/x86/kernel/hw_breakpoint.c
index 34a5c1715148,b98ff620ba77..000000000000
--- a/arch/x86/kernel/hw_breakpoint.c
+++ b/arch/x86/kernel/hw_breakpoint.c
@@@ -279,6 -349,7 +279,10 @@@ static int arch_build_bp_info(struct pe
  			hw->len = X86_BREAKPOINT_LEN_X;
  			return 0;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return -EINVAL;
  	}
diff --cc arch/x86/kernel/kgdb.c
index a25edfbf6f42,c2f02f308ecf..000000000000
--- a/arch/x86/kernel/kgdb.c
+++ b/arch/x86/kernel/kgdb.c
@@@ -464,6 -450,7 +464,10 @@@ int kgdb_arch_handle_exception(int e_ve
  		ptr = &remcomInBuffer[1];
  		if (kgdb_hex2long(&ptr, &addr))
  			linux_regs->ip = addr;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 'D':
  	case 'k':
  		/* clear the trace bit */
diff --cc arch/x86/kernel/ptrace.c
index 419c61bd968e,e7537c5440bb..000000000000
--- a/arch/x86/kernel/ptrace.c
+++ b/arch/x86/kernel/ptrace.c
@@@ -199,6 -204,7 +199,10 @@@ static int set_segment_reg(struct task_
  	case offsetof(struct user_regs_struct, ss):
  		if (unlikely(value == 0))
  			return -EIO;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		*pt_regs_access(task_pt_regs(task), offset) = value;
diff --cc arch/x86/kernel/uprobes.c
index ae9e806a11de,3fdaa042823d..000000000000
--- a/arch/x86/kernel/uprobes.c
+++ b/arch/x86/kernel/uprobes.c
@@@ -750,6 -735,7 +750,10 @@@ static int branch_setup_xol_ops(struct 
  		 * OPCODE1() of the "short" jmp which checks the same condition.
  		 */
  		opc1 = OPCODE2(insn) - 0x10;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		if (!is_cond_jmp_opcode(opc1))
  			return -ENOSYS;
diff --cc arch/x86/lib/insn-eval.c
index 4506b13d97c5,5e69603ff63f..000000000000
--- a/arch/x86/lib/insn-eval.c
+++ b/arch/x86/lib/insn-eval.c
@@@ -204,6 -179,8 +204,11 @@@ static int resolve_default_seg(struct i
  		if (insn->addr_bytes == 2)
  			return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 		fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case -EDOM:
  	case offsetof(struct pt_regs, bx):
  	case offsetof(struct pt_regs, si):
diff --cc arch/x86/math-emu/errors.c
index 6b468517ab71,ec071cbb0804..000000000000
--- a/arch/x86/math-emu/errors.c
+++ b/arch/x86/math-emu/errors.c
@@@ -181,10 -181,12 +181,14 @@@ void FPU_printall(void
  		switch (tagi) {
  		case TAG_Empty:
  			continue;
 +			break;
  		case TAG_Zero:
  		case TAG_Special:
 -			/* Update tagi for the printk below */
  			tagi = FPU_Special(r);
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case TAG_Valid:
  			printk("st(%d)  %c .%04lx %04lx %04lx %04lx e%+-6d ", i,
  			       getsign(r) ? '-' : '+',
diff --cc arch/x86/math-emu/fpu_trig.c
index 783c509f957a,4a9887851ad8..000000000000
--- a/arch/x86/math-emu/fpu_trig.c
+++ b/arch/x86/math-emu/fpu_trig.c
@@@ -1352,7 -1352,7 +1352,11 @@@ static void fyl2xp1(FPU_REG *st0_ptr, u
  		case TW_Denormal:
  			if (denormal_operand() < 0)
  				return;
++<<<<<<< HEAD
 +
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case TAG_Zero:
  		case TAG_Valid:
  			setsign(st0_ptr, getsign(st0_ptr) ^ getsign(st1_ptr));
diff --cc crypto/tcrypt.c
index ca398fbe1280,12e82a61b896..000000000000
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@@ -2384,7 -2452,17 +2384,21 @@@ static int do_test(const char *alg, u3
  	case 326:
  		test_hash_speed("sm3", sec, generic_hash_speed_template);
  		if (mode > 300 && mode < 400) break;
++<<<<<<< HEAD
 +		/* fall through */
++=======
+ 		fallthrough;
+ 	case 327:
+ 		test_hash_speed("streebog256", sec,
+ 				generic_hash_speed_template);
+ 		if (mode > 300 && mode < 400) break;
+ 		fallthrough;
+ 	case 328:
+ 		test_hash_speed("streebog512", sec,
+ 				generic_hash_speed_template);
+ 		if (mode > 300 && mode < 400) break;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 399:
  		break;
  
@@@ -2497,7 -2575,17 +2511,21 @@@
  		test_mb_ahash_speed("sm3", sec, generic_hash_speed_template,
  				    num_mb);
  		if (mode > 400 && mode < 500) break;
++<<<<<<< HEAD
 +		/* fall through */
++=======
+ 		fallthrough;
+ 	case 426:
+ 		test_mb_ahash_speed("streebog256", sec,
+ 				    generic_hash_speed_template, num_mb);
+ 		if (mode > 400 && mode < 500) break;
+ 		fallthrough;
+ 	case 427:
+ 		test_mb_ahash_speed("streebog512", sec,
+ 				    generic_hash_speed_template, num_mb);
+ 		if (mode > 400 && mode < 500) break;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 499:
  		break;
  
diff --cc drivers/ata/ahci_brcm.c
index ea430819c80b,49f7acbfcf01..000000000000
--- a/drivers/ata/ahci_brcm.c
+++ b/drivers/ata/ahci_brcm.c
@@@ -411,35 -450,66 +411,61 @@@ static int brcm_ahci_probe(struct platf
  	if (IS_ERR(priv->top_ctrl))
  		return PTR_ERR(priv->top_ctrl);
  
++<<<<<<< HEAD
 +	if ((priv->version == BRCM_SATA_BCM7425) ||
 +		(priv->version == BRCM_SATA_NSP)) {
 +		priv->quirks |= BRCM_AHCI_QUIRK_NO_NCQ;
++=======
+ 	/* Reset is optional depending on platform and named differently */
+ 	if (priv->version == BRCM_SATA_BCM7216)
+ 		reset_name = "rescal";
+ 	else
+ 		reset_name = "ahci";
+ 
+ 	priv->rcdev = devm_reset_control_get_optional(&pdev->dev, reset_name);
+ 	if (IS_ERR(priv->rcdev))
+ 		return PTR_ERR(priv->rcdev);
+ 
+ 	hpriv = ahci_platform_get_resources(pdev, 0);
+ 	if (IS_ERR(hpriv))
+ 		return PTR_ERR(hpriv);
+ 
+ 	hpriv->plat_data = priv;
+ 	hpriv->flags = AHCI_HFLAG_WAKE_BEFORE_STOP | AHCI_HFLAG_NO_WRITE_TO_RO;
+ 
+ 	switch (priv->version) {
+ 	case BRCM_SATA_BCM7425:
+ 		hpriv->flags |= AHCI_HFLAG_DELAY_ENGINE;
+ 		fallthrough;
+ 	case BRCM_SATA_NSP:
+ 		hpriv->flags |= AHCI_HFLAG_NO_NCQ;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		priv->quirks |= BRCM_AHCI_QUIRK_SKIP_PHY_ENABLE;
 -		break;
 -	default:
 -		break;
  	}
  
 -	if (priv->version == BRCM_SATA_BCM7216)
 -		ret = reset_control_reset(priv->rcdev);
 -	else
 -		ret = reset_control_deassert(priv->rcdev);
 -	if (ret)
 -		return ret;
 -
 -	ret = ahci_platform_enable_clks(hpriv);
 -	if (ret)
 -		goto out_reset;
 -
 -	/* Must be first so as to configure endianness including that
 -	 * of the standard AHCI register space.
 -	 */
  	brcm_sata_init(priv);
  
 -	/* Initializes priv->port_mask which is used below */
 -	priv->port_mask = brcm_ahci_get_portmask(hpriv, priv);
 -	if (!priv->port_mask) {
 -		ret = -ENODEV;
 -		goto out_disable_clks;
 -	}
 +	priv->port_mask = brcm_ahci_get_portmask(pdev, priv);
 +	if (!priv->port_mask)
 +		return -ENODEV;
  
 -	/* Must be done before ahci_platform_enable_phys() */
  	brcm_sata_phys_enable(priv);
  
 +	hpriv = ahci_platform_get_resources(pdev);
 +	if (IS_ERR(hpriv))
 +		return PTR_ERR(hpriv);
 +	hpriv->plat_data = priv;
 +	hpriv->flags = AHCI_HFLAG_WAKE_BEFORE_STOP;
 +
  	brcm_sata_alpm_init(hpriv);
  
 -	ret = ahci_platform_enable_phys(hpriv);
 +	ret = ahci_platform_enable_resources(hpriv);
  	if (ret)
 -		goto out_disable_phys;
 +		return ret;
 +
 +	if (priv->quirks & BRCM_AHCI_QUIRK_NO_NCQ)
 +		hpriv->flags |= AHCI_HFLAG_NO_NCQ;
 +	hpriv->flags |= AHCI_HFLAG_NO_WRITE_TO_RO;
  
  	ret = ahci_platform_init_host(pdev, hpriv, &ahci_brcm_port_info,
  				      &ahci_platform_sht);
diff --cc drivers/ata/libata-eh.c
index 938ed513b070,d912eaa65c94..000000000000
--- a/drivers/ata/libata-eh.c
+++ b/drivers/ata/libata-eh.c
@@@ -1791,6 -1576,8 +1791,11 @@@ static unsigned int ata_eh_analyze_tf(s
  	case ATA_DEV_ZAC:
  		if (stat & ATA_SENSE)
  			ata_eh_request_sense(qc, qc->scsicmd);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
+ 	case ATA_DEV_ATA:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		if (err & ATA_ICRC)
  			qc->err_mask |= AC_ERR_ATA_BUS;
  		if (err & (ATA_UNC | ATA_AMNF))
diff --cc drivers/ata/sata_mv.c
index 73ba8e134ca9,664ef658a955..000000000000
--- a/drivers/ata/sata_mv.c
+++ b/drivers/ata/sata_mv.c
@@@ -2056,8 -2043,8 +2056,13 @@@ static void mv_qc_prep(struct ata_queue
  	switch (tf->protocol) {
  	case ATA_PROT_DMA:
  		if (tf->command == ATA_CMD_DSM)
++<<<<<<< HEAD
 +			return;
 +		/* fall-thru */
++=======
+ 			return AC_ERR_OK;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ATA_PROT_NCQ:
  		break;	/* continue below */
  	case ATA_PROT_PIO:
diff --cc drivers/block/ataflop.c
index 98a122bc90db,a50e13af0305..000000000000
--- a/drivers/block/ataflop.c
+++ b/drivers/block/ataflop.c
@@@ -1725,6 -1726,7 +1725,10 @@@ static int fd_locked_ioctl(struct block
  		/* MSch: invalidate default_params */
  		default_params[drive].blocks  = 0;
  		set_capacity(floppy->disk, MAX_DISK_SIZE * 2);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FDFMTEND:
  	case FDFLUSH:
  		/* invalidate the buffer track to force a reread */
diff --cc drivers/block/drbd/drbd_int.h
index 55e41d696f90,740e93bad21f..000000000000
--- a/drivers/block/drbd/drbd_int.h
+++ b/drivers/block/drbd/drbd_int.h
@@@ -1771,7 -1733,7 +1771,11 @@@ static inline void __drbd_chk_io_error_
  				_drbd_set_state(_NS(device, disk, D_INCONSISTENT), CS_HARD, NULL);
  			break;
  		}
++<<<<<<< HEAD
 +		/* NOTE fall through for DRBD_META_IO_ERROR or DRBD_FORCE_DETACH */
++=======
+ 		fallthrough;	/* for DRBD_META_IO_ERROR or DRBD_FORCE_DETACH */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case EP_DETACH:
  	case EP_CALL_HELPER:
  		/* Remember whether we saw a READ or WRITE error.
diff --cc drivers/block/drbd/drbd_receiver.c
index 0051af57f9ee,422363daa618..000000000000
--- a/drivers/block/drbd/drbd_receiver.c
+++ b/drivers/block/drbd/drbd_receiver.c
@@@ -2955,7 -3083,7 +2955,11 @@@ static int drbd_asb_recover_0p(struct d
  			rv =  1;
  			break;
  		}
++<<<<<<< HEAD
 +		/* Else fall through to one of the other strategies... */
++=======
+ 		fallthrough;	/* to one of the other strategies */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ASB_DISCARD_OLDER_PRI:
  		if (self == 0 && peer == 1) {
  			rv = 1;
@@@ -2980,7 -3108,7 +2984,11 @@@
  		}
  		if (after_sb_0p == ASB_DISCARD_ZERO_CHG)
  			break;
++<<<<<<< HEAD
 +		/* else: fall through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ASB_DISCARD_LEAST_CHG:
  		if	(ch_self < ch_peer)
  			rv = -1;
diff --cc drivers/block/drbd/drbd_req.c
index 8d72bdb0213d,5c975af9c15f..000000000000
--- a/drivers/block/drbd/drbd_req.c
+++ b/drivers/block/drbd/drbd_req.c
@@@ -848,7 -836,7 +848,11 @@@ int __req_mod(struct drbd_request *req
  			} /* else: FIXME can this happen? */
  			break;
  		}
++<<<<<<< HEAD
 +		/* else, fall through to BARRIER_ACKED */
++=======
+ 		fallthrough;	/* to BARRIER_ACKED */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case BARRIER_ACKED:
  		/* barrier ack for READ requests does not make sense */
diff --cc drivers/block/floppy.c
index 13bb61fa1225,a563b023458a..000000000000
--- a/drivers/block/floppy.c
+++ b/drivers/block/floppy.c
@@@ -1641,12 -1674,13 +1641,19 @@@ static void recal_interrupt(void
  			 * not to move at recalibration is to
  			 * be already at track 0.) Clear the
  			 * new change flag */
 -			debug_dcl(drive_params[current_drive].flags,
 +			debug_dcl(DP->flags,
  				  "clearing NEWCHANGE flag because of second recalibrate\n");
  
++<<<<<<< HEAD
 +			clear_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);
 +			DRS->select_date = jiffies;
 +			/* fall through */
++=======
+ 			clear_bit(FD_DISK_NEWCHANGE_BIT,
+ 				  &drive_state[current_drive].flags);
+ 			drive_state[current_drive].select_date = jiffies;
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			debugt(__func__, "default");
  			/* Recalibrate moves the head by at
@@@ -3511,9 -3592,9 +3518,9 @@@ static int fd_locked_ioctl(struct block
  		if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)
  			return -EINTR;
  		process_fd_request();
- 		/* fall through */
+ 		fallthrough;
  	case FDGETDRVSTAT:
 -		outparam = &drive_state[drive];
 +		outparam = UDRS;
  		break;
  	case FDRESET:
  		return user_reset_fdc(drive, (int)param, true);
diff --cc drivers/block/pktcdvd.c
index 9216626957fd,1034e445680c..000000000000
--- a/drivers/block/pktcdvd.c
+++ b/drivers/block/pktcdvd.c
@@@ -2642,7 -2641,7 +2642,11 @@@ static int pkt_ioctl(struct block_devic
  		 */
  		if (pd->refcnt == 1)
  			pkt_lock_door(pd, 0);
++<<<<<<< HEAD
 +		/* fallthru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	/*
  	 * forward selected CDROM ioctls to CD-ROM, for UDF
  	 */
diff --cc drivers/block/rsxx/core.c
index c092f5e3da1f,8799e3bab067..000000000000
--- a/drivers/block/rsxx/core.c
+++ b/drivers/block/rsxx/core.c
@@@ -439,6 -425,7 +439,10 @@@ static void card_state_change(struct rs
  		 * Fall through so the DMA devices can be attached and
  		 * the user can attempt to pull off their data.
  		 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case CARD_STATE_GOOD:
  		st = rsxx_get_card_size8(card, &card->size8);
  		if (st)
diff --cc drivers/bus/ti-sysc.c
index 80d60f43db56,efb088df1276..000000000000
--- a/drivers/bus/ti-sysc.c
+++ b/drivers/bus/ti-sysc.c
@@@ -943,30 -1544,462 +943,423 @@@ static void sysc_init_revision_quirks(s
  	}
  }
  
++<<<<<<< HEAD
 +/* At this point the module is configured enough to read the revision */
++=======
+ /*
+  * DSS needs dispc outputs disabled to reset modules. Returns mask of
+  * enabled DSS interrupts. Eventually we may be able to do this on
+  * dispc init rather than top-level DSS init.
+  */
+ static u32 sysc_quirk_dispc(struct sysc *ddata, int dispc_offset,
+ 			    bool disable)
+ {
+ 	bool lcd_en, digit_en, lcd2_en = false, lcd3_en = false;
+ 	const int lcd_en_mask = BIT(0), digit_en_mask = BIT(1);
+ 	int manager_count;
+ 	bool framedonetv_irq = true;
+ 	u32 val, irq_mask = 0;
+ 
+ 	switch (sysc_soc->soc) {
+ 	case SOC_2420 ... SOC_3630:
+ 		manager_count = 2;
+ 		framedonetv_irq = false;
+ 		break;
+ 	case SOC_4430 ... SOC_4470:
+ 		manager_count = 3;
+ 		break;
+ 	case SOC_5430:
+ 	case SOC_DRA7:
+ 		manager_count = 4;
+ 		break;
+ 	case SOC_AM4:
+ 		manager_count = 1;
+ 		framedonetv_irq = false;
+ 		break;
+ 	case SOC_UNKNOWN:
+ 	default:
+ 		return 0;
+ 	};
+ 
+ 	/* Remap the whole module range to be able to reset dispc outputs */
+ 	devm_iounmap(ddata->dev, ddata->module_va);
+ 	ddata->module_va = devm_ioremap(ddata->dev,
+ 					ddata->module_pa,
+ 					ddata->module_size);
+ 	if (!ddata->module_va)
+ 		return -EIO;
+ 
+ 	/* DISP_CONTROL */
+ 	val = sysc_read(ddata, dispc_offset + 0x40);
+ 	lcd_en = val & lcd_en_mask;
+ 	digit_en = val & digit_en_mask;
+ 	if (lcd_en)
+ 		irq_mask |= BIT(0);			/* FRAMEDONE */
+ 	if (digit_en) {
+ 		if (framedonetv_irq)
+ 			irq_mask |= BIT(24);		/* FRAMEDONETV */
+ 		else
+ 			irq_mask |= BIT(2) | BIT(3);	/* EVSYNC bits */
+ 	}
+ 	if (disable & (lcd_en | digit_en))
+ 		sysc_write(ddata, dispc_offset + 0x40,
+ 			   val & ~(lcd_en_mask | digit_en_mask));
+ 
+ 	if (manager_count <= 2)
+ 		return irq_mask;
+ 
+ 	/* DISPC_CONTROL2 */
+ 	val = sysc_read(ddata, dispc_offset + 0x238);
+ 	lcd2_en = val & lcd_en_mask;
+ 	if (lcd2_en)
+ 		irq_mask |= BIT(22);			/* FRAMEDONE2 */
+ 	if (disable && lcd2_en)
+ 		sysc_write(ddata, dispc_offset + 0x238,
+ 			   val & ~lcd_en_mask);
+ 
+ 	if (manager_count <= 3)
+ 		return irq_mask;
+ 
+ 	/* DISPC_CONTROL3 */
+ 	val = sysc_read(ddata, dispc_offset + 0x848);
+ 	lcd3_en = val & lcd_en_mask;
+ 	if (lcd3_en)
+ 		irq_mask |= BIT(30);			/* FRAMEDONE3 */
+ 	if (disable && lcd3_en)
+ 		sysc_write(ddata, dispc_offset + 0x848,
+ 			   val & ~lcd_en_mask);
+ 
+ 	return irq_mask;
+ }
+ 
+ /* DSS needs child outputs disabled and SDI registers cleared for reset */
+ static void sysc_pre_reset_quirk_dss(struct sysc *ddata)
+ {
+ 	const int dispc_offset = 0x1000;
+ 	int error;
+ 	u32 irq_mask, val;
+ 
+ 	/* Get enabled outputs */
+ 	irq_mask = sysc_quirk_dispc(ddata, dispc_offset, false);
+ 	if (!irq_mask)
+ 		return;
+ 
+ 	/* Clear IRQSTATUS */
+ 	sysc_write(ddata, dispc_offset + 0x18, irq_mask);
+ 
+ 	/* Disable outputs */
+ 	val = sysc_quirk_dispc(ddata, dispc_offset, true);
+ 
+ 	/* Poll IRQSTATUS */
+ 	error = readl_poll_timeout(ddata->module_va + dispc_offset + 0x18,
+ 				   val, val != irq_mask, 100, 50);
+ 	if (error)
+ 		dev_warn(ddata->dev, "%s: timed out %08x !+ %08x\n",
+ 			 __func__, val, irq_mask);
+ 
+ 	if (sysc_soc->soc == SOC_3430) {
+ 		/* Clear DSS_SDI_CONTROL */
+ 		sysc_write(ddata, 0x44, 0);
+ 
+ 		/* Clear DSS_PLL_CONTROL */
+ 		sysc_write(ddata, 0x48, 0);
+ 	}
+ 
+ 	/* Clear DSS_CONTROL to switch DSS clock sources to PRCM if not */
+ 	sysc_write(ddata, 0x40, 0);
+ }
+ 
+ /* 1-wire needs module's internal clocks enabled for reset */
+ static void sysc_pre_reset_quirk_hdq1w(struct sysc *ddata)
+ {
+ 	int offset = 0x0c;	/* HDQ_CTRL_STATUS */
+ 	u16 val;
+ 
+ 	val = sysc_read(ddata, offset);
+ 	val |= BIT(5);
+ 	sysc_write(ddata, offset, val);
+ }
+ 
+ /* AESS (Audio Engine SubSystem) needs autogating set after enable */
+ static void sysc_module_enable_quirk_aess(struct sysc *ddata)
+ {
+ 	int offset = 0x7c;	/* AESS_AUTO_GATING_ENABLE */
+ 
+ 	sysc_write(ddata, offset, 1);
+ }
+ 
+ /* I2C needs to be disabled for reset */
+ static void sysc_clk_quirk_i2c(struct sysc *ddata, bool enable)
+ {
+ 	int offset;
+ 	u16 val;
+ 
+ 	/* I2C_CON, omap2/3 is different from omap4 and later */
+ 	if ((ddata->revision & 0xffffff00) == 0x001f0000)
+ 		offset = 0x24;
+ 	else
+ 		offset = 0xa4;
+ 
+ 	/* I2C_EN */
+ 	val = sysc_read(ddata, offset);
+ 	if (enable)
+ 		val |= BIT(15);
+ 	else
+ 		val &= ~BIT(15);
+ 	sysc_write(ddata, offset, val);
+ }
+ 
+ static void sysc_pre_reset_quirk_i2c(struct sysc *ddata)
+ {
+ 	sysc_clk_quirk_i2c(ddata, false);
+ }
+ 
+ static void sysc_post_reset_quirk_i2c(struct sysc *ddata)
+ {
+ 	sysc_clk_quirk_i2c(ddata, true);
+ }
+ 
+ /* RTC on am3 and 4 needs to be unlocked and locked for sysconfig */
+ static void sysc_quirk_rtc(struct sysc *ddata, bool lock)
+ {
+ 	u32 val, kick0_val = 0, kick1_val = 0;
+ 	unsigned long flags;
+ 	int error;
+ 
+ 	if (!lock) {
+ 		kick0_val = 0x83e70b13;
+ 		kick1_val = 0x95a4f1e0;
+ 	}
+ 
+ 	local_irq_save(flags);
+ 	/* RTC_STATUS BUSY bit may stay active for 1/32768 seconds (~30 usec) */
+ 	error = readl_poll_timeout_atomic(ddata->module_va + 0x44, val,
+ 					  !(val & BIT(0)), 100, 50);
+ 	if (error)
+ 		dev_warn(ddata->dev, "rtc busy timeout\n");
+ 	/* Now we have ~15 microseconds to read/write various registers */
+ 	sysc_write(ddata, 0x6c, kick0_val);
+ 	sysc_write(ddata, 0x70, kick1_val);
+ 	local_irq_restore(flags);
+ }
+ 
+ static void sysc_module_unlock_quirk_rtc(struct sysc *ddata)
+ {
+ 	sysc_quirk_rtc(ddata, false);
+ }
+ 
+ static void sysc_module_lock_quirk_rtc(struct sysc *ddata)
+ {
+ 	sysc_quirk_rtc(ddata, true);
+ }
+ 
+ /* 36xx SGX needs a quirk for to bypass OCP IPG interrupt logic */
+ static void sysc_module_enable_quirk_sgx(struct sysc *ddata)
+ {
+ 	int offset = 0xff08;	/* OCP_DEBUG_CONFIG */
+ 	u32 val = BIT(31);	/* THALIA_INT_BYPASS */
+ 
+ 	sysc_write(ddata, offset, val);
+ }
+ 
+ /* Watchdog timer needs a disable sequence after reset */
+ static void sysc_reset_done_quirk_wdt(struct sysc *ddata)
+ {
+ 	int wps, spr, error;
+ 	u32 val;
+ 
+ 	wps = 0x34;
+ 	spr = 0x48;
+ 
+ 	sysc_write(ddata, spr, 0xaaaa);
+ 	error = readl_poll_timeout(ddata->module_va + wps, val,
+ 				   !(val & 0x10), 100,
+ 				   MAX_MODULE_SOFTRESET_WAIT);
+ 	if (error)
+ 		dev_warn(ddata->dev, "wdt disable step1 failed\n");
+ 
+ 	sysc_write(ddata, spr, 0x5555);
+ 	error = readl_poll_timeout(ddata->module_va + wps, val,
+ 				   !(val & 0x10), 100,
+ 				   MAX_MODULE_SOFTRESET_WAIT);
+ 	if (error)
+ 		dev_warn(ddata->dev, "wdt disable step2 failed\n");
+ }
+ 
+ /* PRUSS needs to set MSTANDBY_INIT inorder to idle properly */
+ static void sysc_module_disable_quirk_pruss(struct sysc *ddata)
+ {
+ 	u32 reg;
+ 
+ 	reg = sysc_read(ddata, ddata->offsets[SYSC_SYSCONFIG]);
+ 	reg |= SYSC_PRUSS_STANDBY_INIT;
+ 	sysc_write(ddata, ddata->offsets[SYSC_SYSCONFIG], reg);
+ }
+ 
+ static void sysc_init_module_quirks(struct sysc *ddata)
+ {
+ 	if (ddata->legacy_mode || !ddata->name)
+ 		return;
+ 
+ 	if (ddata->cfg.quirks & SYSC_MODULE_QUIRK_HDQ1W) {
+ 		ddata->pre_reset_quirk = sysc_pre_reset_quirk_hdq1w;
+ 
+ 		return;
+ 	}
+ 
+ 	if (ddata->cfg.quirks & SYSC_MODULE_QUIRK_I2C) {
+ 		ddata->pre_reset_quirk = sysc_pre_reset_quirk_i2c;
+ 		ddata->post_reset_quirk = sysc_post_reset_quirk_i2c;
+ 
+ 		return;
+ 	}
+ 
+ 	if (ddata->cfg.quirks & SYSC_MODULE_QUIRK_AESS)
+ 		ddata->module_enable_quirk = sysc_module_enable_quirk_aess;
+ 
+ 	if (ddata->cfg.quirks & SYSC_MODULE_QUIRK_DSS_RESET)
+ 		ddata->pre_reset_quirk = sysc_pre_reset_quirk_dss;
+ 
+ 	if (ddata->cfg.quirks & SYSC_MODULE_QUIRK_RTC_UNLOCK) {
+ 		ddata->module_unlock_quirk = sysc_module_unlock_quirk_rtc;
+ 		ddata->module_lock_quirk = sysc_module_lock_quirk_rtc;
+ 
+ 		return;
+ 	}
+ 
+ 	if (ddata->cfg.quirks & SYSC_MODULE_QUIRK_SGX)
+ 		ddata->module_enable_quirk = sysc_module_enable_quirk_sgx;
+ 
+ 	if (ddata->cfg.quirks & SYSC_MODULE_QUIRK_WDT) {
+ 		ddata->reset_done_quirk = sysc_reset_done_quirk_wdt;
+ 		ddata->module_disable_quirk = sysc_reset_done_quirk_wdt;
+ 	}
+ 
+ 	if (ddata->cfg.quirks & SYSC_MODULE_QUIRK_PRUSS)
+ 		ddata->module_disable_quirk = sysc_module_disable_quirk_pruss;
+ }
+ 
+ static int sysc_clockdomain_init(struct sysc *ddata)
+ {
+ 	struct ti_sysc_platform_data *pdata = dev_get_platdata(ddata->dev);
+ 	struct clk *fck = NULL, *ick = NULL;
+ 	int error;
+ 
+ 	if (!pdata || !pdata->init_clockdomain)
+ 		return 0;
+ 
+ 	switch (ddata->nr_clocks) {
+ 	case 2:
+ 		ick = ddata->clocks[SYSC_ICK];
+ 		fallthrough;
+ 	case 1:
+ 		fck = ddata->clocks[SYSC_FCK];
+ 		break;
+ 	case 0:
+ 		return 0;
+ 	}
+ 
+ 	error = pdata->init_clockdomain(ddata->dev, fck, ick, &ddata->cookie);
+ 	if (!error || error == -ENODEV)
+ 		return 0;
+ 
+ 	return error;
+ }
+ 
+ /*
+  * Note that pdata->init_module() typically does a reset first. After
+  * pdata->init_module() is done, PM runtime can be used for the interconnect
+  * target module.
+  */
+ static int sysc_legacy_init(struct sysc *ddata)
+ {
+ 	struct ti_sysc_platform_data *pdata = dev_get_platdata(ddata->dev);
+ 	int error;
+ 
+ 	if (!pdata || !pdata->init_module)
+ 		return 0;
+ 
+ 	error = pdata->init_module(ddata->dev, ddata->mdata, &ddata->cookie);
+ 	if (error == -EEXIST)
+ 		error = 0;
+ 
+ 	return error;
+ }
+ 
+ /*
+  * Note that the caller must ensure the interconnect target module is enabled
+  * before calling reset. Otherwise reset will not complete.
+  */
+ static int sysc_reset(struct sysc *ddata)
+ {
+ 	int sysc_offset, sysc_val, error;
+ 	u32 sysc_mask;
+ 
+ 	sysc_offset = ddata->offsets[SYSC_SYSCONFIG];
+ 
+ 	if (ddata->legacy_mode ||
+ 	    ddata->cap->regbits->srst_shift < 0 ||
+ 	    ddata->cfg.quirks & SYSC_QUIRK_NO_RESET_ON_INIT)
+ 		return 0;
+ 
+ 	sysc_mask = BIT(ddata->cap->regbits->srst_shift);
+ 
+ 	if (ddata->pre_reset_quirk)
+ 		ddata->pre_reset_quirk(ddata);
+ 
+ 	if (sysc_offset >= 0) {
+ 		sysc_val = sysc_read_sysconfig(ddata);
+ 		sysc_val |= sysc_mask;
+ 		sysc_write(ddata, sysc_offset, sysc_val);
+ 	}
+ 
+ 	if (ddata->cfg.srst_udelay)
+ 		usleep_range(ddata->cfg.srst_udelay,
+ 			     ddata->cfg.srst_udelay * 2);
+ 
+ 	if (ddata->post_reset_quirk)
+ 		ddata->post_reset_quirk(ddata);
+ 
+ 	error = sysc_wait_softreset(ddata);
+ 	if (error)
+ 		dev_warn(ddata->dev, "OCP softreset timed out\n");
+ 
+ 	if (ddata->reset_done_quirk)
+ 		ddata->reset_done_quirk(ddata);
+ 
+ 	return error;
+ }
+ 
+ /*
+  * At this point the module is configured enough to read the revision but
+  * module may not be completely configured yet to use PM runtime. Enable
+  * all clocks directly during init to configure the quirks needed for PM
+  * runtime based on the revision register.
+  */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static int sysc_init_module(struct sysc *ddata)
  {
 -	int error = 0;
 -
 -	error = sysc_clockdomain_init(ddata);
 -	if (error)
 -		return error;
 -
 -	sysc_clkdm_deny_idle(ddata);
 -
 -	/*
 -	 * Always enable clocks. The bootloader may or may not have enabled
 -	 * the related clocks.
 -	 */
 -	error = sysc_enable_opt_clocks(ddata);
 -	if (error)
 -		return error;
 -
 -	error = sysc_enable_main_clocks(ddata);
 -	if (error)
 -		goto err_opt_clocks;
 +	int error;
  
 -	if (!(ddata->cfg.quirks & SYSC_QUIRK_NO_RESET_ON_INIT)) {
 -		error = reset_control_deassert(ddata->rsts);
 -		if (error)
 -			goto err_main_clocks;
 +	if (ddata->cfg.quirks & SYSC_QUIRK_NO_IDLE_ON_INIT) {
 +		ddata->revision = sysc_read_revision(ddata);
 +		goto rev_quirks;
  	}
  
 -	ddata->revision = sysc_read_revision(ddata);
 -	sysc_init_revision_quirks(ddata);
 -	sysc_init_module_quirks(ddata);
 -
 -	if (ddata->legacy_mode) {
 -		error = sysc_legacy_init(ddata);
 -		if (error)
 -			goto err_reset;
 -	}
 +	error = pm_runtime_get_sync(ddata->dev);
 +	if (error < 0) {
 +		pm_runtime_put_noidle(ddata->dev);
  
 -	if (!ddata->legacy_mode) {
 -		error = sysc_enable_module(ddata->dev);
 -		if (error)
 -			goto err_reset;
 +		return 0;
  	}
  
 -	error = sysc_reset(ddata);
 -	if (error)
 -		dev_err(ddata->dev, "Reset failed with %d\n", error);
 -
 -	if (error && !ddata->legacy_mode)
 -		sysc_disable_module(ddata->dev);
 -
 -err_reset:
 -	if (error && !(ddata->cfg.quirks & SYSC_QUIRK_NO_RESET_ON_INIT))
 -		reset_control_assert(ddata->rsts);
 +	ddata->revision = sysc_read_revision(ddata);
 +	pm_runtime_put_sync(ddata->dev);
  
 -err_main_clocks:
 -	if (error)
 -		sysc_disable_main_clocks(ddata);
 -err_opt_clocks:
 -	/* No re-enable of clockdomain autoidle to prevent module autoidle */
 -	if (error) {
 -		sysc_disable_opt_clocks(ddata);
 -		sysc_clkdm_allow_idle(ddata);
 -	}
 +rev_quirks:
 +	sysc_init_revision_quirks(ddata);
  
 -	return error;
 +	return 0;
  }
  
  static int sysc_init_sysc_mask(struct sysc *ddata)
diff --cc drivers/char/lp.c
index 8c4dd1a3bb6a,45932f05fd67..000000000000
--- a/drivers/char/lp.c
+++ b/drivers/char/lp.c
@@@ -725,7 -734,7 +725,11 @@@ static long lp_ioctl(struct file *file
  			ret = lp_set_timeout32(minor, (void __user *)arg);
  			break;
  		}
++<<<<<<< HEAD
 +		/* fallthrough for 64-bit */
++=======
+ 		fallthrough;	/* for 64-bit */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case LPSETTIMEOUT_NEW:
  		ret = lp_set_timeout64(minor, (void __user *)arg);
  		break;
@@@ -753,7 -762,7 +757,11 @@@ static long lp_compat_ioctl(struct fil
  			ret = lp_set_timeout32(minor, (void __user *)arg);
  			break;
  		}
++<<<<<<< HEAD
 +		/* fallthrough for x32 mode */
++=======
+ 		fallthrough;	/* for x32 mode */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case LPSETTIMEOUT_NEW:
  		ret = lp_set_timeout64(minor, (void __user *)arg);
  		break;
diff --cc drivers/char/mem.c
index 8916c5faa8f9,abd4ffdc8cde..000000000000
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@@ -778,6 -791,7 +778,10 @@@ static loff_t memory_lseek(struct file 
  	switch (orig) {
  	case SEEK_CUR:
  		offset += file->f_pos;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SEEK_SET:
  		/* to avoid userland mistaking f_pos=-9 as -EBADF=-9 */
  		if ((unsigned long long)offset >= -MAX_ERRNO) {
diff --cc drivers/char/nvram.c
index 25264d65e716,e9f694b36871..000000000000
--- a/drivers/char/nvram.c
+++ b/drivers/char/nvram.c
@@@ -172,127 -111,214 +172,139 @@@ void nvram_write_byte(unsigned char c, 
  	__nvram_write_byte(c, i);
  	spin_unlock_irqrestore(&rtc_lock, flags);
  }
 +EXPORT_SYMBOL(nvram_write_byte);
  
 -/* On PCs, the checksum is built only over bytes 2..31 */
 -#define PC_CKS_RANGE_START	2
 -#define PC_CKS_RANGE_END	31
 -#define PC_CKS_LOC		32
 -
 -static int __nvram_check_checksum(void)
 +int __nvram_check_checksum(void)
  {
 -	int i;
 -	unsigned short sum = 0;
 -	unsigned short expect;
 -
 -	for (i = PC_CKS_RANGE_START; i <= PC_CKS_RANGE_END; ++i)
 -		sum += __nvram_read_byte(i);
 -	expect = __nvram_read_byte(PC_CKS_LOC)<<8 |
 -	    __nvram_read_byte(PC_CKS_LOC+1);
 -	return (sum & 0xffff) == expect;
 +	return mach_check_checksum();
  }
 +EXPORT_SYMBOL(__nvram_check_checksum);
  
 -static void __nvram_set_checksum(void)
 +int nvram_check_checksum(void)
  {
 -	int i;
 -	unsigned short sum = 0;
 +	unsigned long flags;
 +	int rv;
  
 -	for (i = PC_CKS_RANGE_START; i <= PC_CKS_RANGE_END; ++i)
 -		sum += __nvram_read_byte(i);
 -	__nvram_write_byte(sum >> 8, PC_CKS_LOC);
 -	__nvram_write_byte(sum & 0xff, PC_CKS_LOC + 1);
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	rv = __nvram_check_checksum();
 +	spin_unlock_irqrestore(&rtc_lock, flags);
 +	return rv;
  }
 +EXPORT_SYMBOL(nvram_check_checksum);
  
 -static long pc_nvram_set_checksum(void)
 +static void __nvram_set_checksum(void)
  {
 -	spin_lock_irq(&rtc_lock);
 -	__nvram_set_checksum();
 -	spin_unlock_irq(&rtc_lock);
 -	return 0;
 +	mach_set_checksum();
  }
  
 -static long pc_nvram_initialize(void)
 +#if 0
 +void nvram_set_checksum(void)
  {
 -	ssize_t i;
 +	unsigned long flags;
  
 -	spin_lock_irq(&rtc_lock);
 -	for (i = 0; i < NVRAM_BYTES; ++i)
 -		__nvram_write_byte(0, i);
 +	spin_lock_irqsave(&rtc_lock, flags);
  	__nvram_set_checksum();
 -	spin_unlock_irq(&rtc_lock);
 -	return 0;
 +	spin_unlock_irqrestore(&rtc_lock, flags);
  }
 +#endif  /*  0  */
 +
 +/*
 + * The are the file operation function for user access to /dev/nvram
 + */
  
 -static ssize_t pc_nvram_get_size(void)
 +static loff_t nvram_llseek(struct file *file, loff_t offset, int origin)
  {
 -	return NVRAM_BYTES;
 +	return generic_file_llseek_size(file, offset, origin, MAX_LFS_FILESIZE,
 +					NVRAM_BYTES);
  }
  
 -static ssize_t pc_nvram_read(char *buf, size_t count, loff_t *ppos)
 +static ssize_t nvram_read(struct file *file, char __user *buf,
 +						size_t count, loff_t *ppos)
  {
 -	char *p = buf;
 -	loff_t i;
 +	unsigned char contents[NVRAM_BYTES];
 +	unsigned i = *ppos;
 +	unsigned char *tmp;
  
  	spin_lock_irq(&rtc_lock);
 -	if (!__nvram_check_checksum()) {
 -		spin_unlock_irq(&rtc_lock);
 -		return -EIO;
 -	}
 -	for (i = *ppos; count > 0 && i < NVRAM_BYTES; --count, ++i, ++p)
 -		*p = __nvram_read_byte(i);
 -	spin_unlock_irq(&rtc_lock);
  
 -	*ppos = i;
 -	return p - buf;
 -}
 +	if (!__nvram_check_checksum())
 +		goto checksum_err;
  
 -static ssize_t pc_nvram_write(char *buf, size_t count, loff_t *ppos)
 -{
 -	char *p = buf;
 -	loff_t i;
 +	for (tmp = contents; count-- > 0 && i < NVRAM_BYTES; ++i, ++tmp)
 +		*tmp = __nvram_read_byte(i);
  
 -	spin_lock_irq(&rtc_lock);
 -	if (!__nvram_check_checksum()) {
 -		spin_unlock_irq(&rtc_lock);
 -		return -EIO;
 -	}
 -	for (i = *ppos; count > 0 && i < NVRAM_BYTES; --count, ++i, ++p)
 -		__nvram_write_byte(*p, i);
 -	__nvram_set_checksum();
  	spin_unlock_irq(&rtc_lock);
  
 +	if (copy_to_user(buf, contents, tmp - contents))
 +		return -EFAULT;
 +
  	*ppos = i;
 -	return p - buf;
 -}
  
 -const struct nvram_ops arch_nvram_ops = {
 -	.read           = pc_nvram_read,
 -	.write          = pc_nvram_write,
 -	.read_byte      = pc_nvram_read_byte,
 -	.write_byte     = pc_nvram_write_byte,
 -	.get_size       = pc_nvram_get_size,
 -	.set_checksum   = pc_nvram_set_checksum,
 -	.initialize     = pc_nvram_initialize,
 -};
 -EXPORT_SYMBOL(arch_nvram_ops);
 -#endif /* CONFIG_X86 */
 +	return tmp - contents;
  
 -/*
 - * The are the file operation function for user access to /dev/nvram
 - */
 -
 -static loff_t nvram_misc_llseek(struct file *file, loff_t offset, int origin)
 -{
 -	return generic_file_llseek_size(file, offset, origin, MAX_LFS_FILESIZE,
 -					nvram_size);
 +checksum_err:
 +	spin_unlock_irq(&rtc_lock);
 +	return -EIO;
  }
  
 -static ssize_t nvram_misc_read(struct file *file, char __user *buf,
 -			       size_t count, loff_t *ppos)
 +static ssize_t nvram_write(struct file *file, const char __user *buf,
 +						size_t count, loff_t *ppos)
  {
 -	char *tmp;
 -	ssize_t ret;
 -
 +	unsigned char contents[NVRAM_BYTES];
 +	unsigned i = *ppos;
 +	unsigned char *tmp;
  
 -	if (*ppos >= nvram_size)
 -		return 0;
 +	if (i >= NVRAM_BYTES)
 +		return 0;	/* Past EOF */
  
 -	count = min_t(size_t, count, nvram_size - *ppos);
 -	count = min_t(size_t, count, PAGE_SIZE);
 +	if (count > NVRAM_BYTES - i)
 +		count = NVRAM_BYTES - i;
 +	if (count > NVRAM_BYTES)
 +		return -EFAULT;	/* Can't happen, but prove it to gcc */
  
 -	tmp = kmalloc(count, GFP_KERNEL);
 -	if (!tmp)
 -		return -ENOMEM;
 +	if (copy_from_user(contents, buf, count))
 +		return -EFAULT;
  
 -	ret = nvram_read(tmp, count, ppos);
 -	if (ret <= 0)
 -		goto out;
 +	spin_lock_irq(&rtc_lock);
  
 -	if (copy_to_user(buf, tmp, ret)) {
 -		*ppos -= ret;
 -		ret = -EFAULT;
 -	}
 +	if (!__nvram_check_checksum())
 +		goto checksum_err;
  
 -out:
 -	kfree(tmp);
 -	return ret;
 -}
 +	for (tmp = contents; count--; ++i, ++tmp)
 +		__nvram_write_byte(*tmp, i);
  
 -static ssize_t nvram_misc_write(struct file *file, const char __user *buf,
 -				size_t count, loff_t *ppos)
 -{
 -	char *tmp;
 -	ssize_t ret;
 +	__nvram_set_checksum();
  
 -	if (*ppos >= nvram_size)
 -		return 0;
 +	spin_unlock_irq(&rtc_lock);
  
 -	count = min_t(size_t, count, nvram_size - *ppos);
 -	count = min_t(size_t, count, PAGE_SIZE);
 +	*ppos = i;
  
 -	tmp = memdup_user(buf, count);
 -	if (IS_ERR(tmp))
 -		return PTR_ERR(tmp);
 +	return tmp - contents;
  
 -	ret = nvram_write(tmp, count, ppos);
 -	kfree(tmp);
 -	return ret;
 +checksum_err:
 +	spin_unlock_irq(&rtc_lock);
 +	return -EIO;
  }
  
 -static long nvram_misc_ioctl(struct file *file, unsigned int cmd,
 -			     unsigned long arg)
 +static long nvram_ioctl(struct file *file, unsigned int cmd,
 +			unsigned long arg)
  {
 -	long ret = -ENOTTY;
 +	int i;
  
  	switch (cmd) {
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PPC
+ 	case OBSOLETE_PMAC_NVRAM_GET_OFFSET:
+ 		pr_warn("nvram: Using obsolete PMAC_NVRAM_GET_OFFSET ioctl\n");
+ 		fallthrough;
+ 	case IOC_NVRAM_GET_OFFSET:
+ 		ret = -EINVAL;
+ #ifdef CONFIG_PPC_PMAC
+ 		if (machine_is(powermac)) {
+ 			int part, offset;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -			if (copy_from_user(&part, (void __user *)arg,
 -					   sizeof(part)) != 0)
 -				return -EFAULT;
 -			if (part < pmac_nvram_OF || part > pmac_nvram_NR)
 -				return -EINVAL;
 -			offset = pmac_get_partition(part);
 -			if (offset < 0)
 -				return -EINVAL;
 -			if (copy_to_user((void __user *)arg,
 -					 &offset, sizeof(offset)) != 0)
 -				return -EFAULT;
 -			ret = 0;
 -		}
 -#endif
 -		break;
 -#ifdef CONFIG_PPC32
 -	case IOC_NVRAM_SYNC:
 -		if (ppc_md.nvram_sync != NULL) {
 -			mutex_lock(&nvram_mutex);
 -			ppc_md.nvram_sync();
 -			mutex_unlock(&nvram_mutex);
 -		}
 -		ret = 0;
 -		break;
 -#endif
 -#elif defined(CONFIG_X86) || defined(CONFIG_M68K)
  	case NVRAM_INIT:
  		/* initialize NVRAM contents and checksum */
  		if (!capable(CAP_SYS_ADMIN))
diff --cc drivers/cpufreq/ti-cpufreq.c
index 2b4f7bfb5557,8f9fdd864391..000000000000
--- a/drivers/cpufreq/ti-cpufreq.c
+++ b/drivers/cpufreq/ti-cpufreq.c
@@@ -97,6 -90,7 +97,10 @@@ static unsigned long dra7_efuse_xlate(s
  	case DRA7_EFUSE_HAS_ALL_MPU_OPP:
  	case DRA7_EFUSE_HAS_HIGH_MPU_OPP:
  		calculated_efuse |= DRA7_EFUSE_HIGH_MPU_OPP;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case DRA7_EFUSE_HAS_OD_MPU_OPP:
  		calculated_efuse |= DRA7_EFUSE_OD_MPU_OPP;
  	}
diff --cc drivers/crypto/ux500/cryp/cryp.c
index 00a16ab601cb,9866c2a5e9a7..000000000000
--- a/drivers/crypto/ux500/cryp/cryp.c
+++ b/drivers/crypto/ux500/cryp/cryp.c
@@@ -314,14 -314,17 +314,26 @@@ void cryp_save_device_context(struct cr
  	case CRYP_KEY_SIZE_256:
  		ctx->key_4_l = readl_relaxed(&src_reg->key_4_l);
  		ctx->key_4_r = readl_relaxed(&src_reg->key_4_r);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case CRYP_KEY_SIZE_192:
  		ctx->key_3_l = readl_relaxed(&src_reg->key_3_l);
  		ctx->key_3_r = readl_relaxed(&src_reg->key_3_r);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case CRYP_KEY_SIZE_128:
  		ctx->key_2_l = readl_relaxed(&src_reg->key_2_l);
  		ctx->key_2_r = readl_relaxed(&src_reg->key_2_r);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		ctx->key_1_l = readl_relaxed(&src_reg->key_1_l);
@@@ -361,14 -364,17 +373,26 @@@ void cryp_restore_device_context(struc
  	case CRYP_KEY_SIZE_256:
  		writel_relaxed(ctx->key_4_l, &reg->key_4_l);
  		writel_relaxed(ctx->key_4_r, &reg->key_4_r);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case CRYP_KEY_SIZE_192:
  		writel_relaxed(ctx->key_3_l, &reg->key_3_l);
  		writel_relaxed(ctx->key_3_r, &reg->key_3_r);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case CRYP_KEY_SIZE_128:
  		writel_relaxed(ctx->key_2_l, &reg->key_2_l);
  		writel_relaxed(ctx->key_2_r, &reg->key_2_r);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		writel_relaxed(ctx->key_1_l, &reg->key_1_l);
diff --cc drivers/dma/fsldma.c
index 1117b5123a6f,e342cf52d296..000000000000
--- a/drivers/dma/fsldma.c
+++ b/drivers/dma/fsldma.c
@@@ -1168,6 -1163,7 +1168,10 @@@ static int fsl_dma_chan_probe(struct fs
  	switch (chan->feature & FSL_DMA_IP_MASK) {
  	case FSL_DMA_IP_85XX:
  		chan->toggle_ext_pause = fsl_chan_toggle_ext_pause;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FSL_DMA_IP_83XX:
  		chan->toggle_ext_start = fsl_chan_toggle_ext_start;
  		chan->set_src_loop_size = fsl_chan_set_src_loop_size;
diff --cc drivers/dma/imx-dma.c
index 75b6ff0415ee,88717506c1f6..000000000000
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@@ -557,6 -556,7 +557,10 @@@ static int imxdma_xfer_desc(struct imxd
  		 * We fall-through here intentionally, since a 2D transfer is
  		 * similar to MEMCPY just adding the 2D slot configuration.
  		 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IMXDMA_DESC_MEMCPY:
  		imx_dmav1_writel(imxdma, d->src, DMA_SAR(imxdmac->channel));
  		imx_dmav1_writel(imxdma, d->dest, DMA_DAR(imxdmac->channel));
diff --cc drivers/dma/nbpfaxi.c
index 2f9974ddfbb2,ca4e0930207a..000000000000
--- a/drivers/dma/nbpfaxi.c
+++ b/drivers/dma/nbpfaxi.c
@@@ -479,6 -483,7 +479,10 @@@ static size_t nbpf_xfer_size(struct nbp
  
  	default:
  		pr_warn("%s(): invalid bus width %u\n", __func__, width);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case DMA_SLAVE_BUSWIDTH_1_BYTE:
  		size = burst;
  	}
diff --cc drivers/dma/pl330.c
index de0957fe9668,9b69716172a4..000000000000
--- a/drivers/dma/pl330.c
+++ b/drivers/dma/pl330.c
@@@ -1046,13 -1061,16 +1046,25 @@@ static bool _start(struct pl330_thread 
  
  		if (_state(thrd) == PL330_STATE_KILLING)
  			UNTIL(thrd, PL330_STATE_STOPPED)
++<<<<<<< HEAD
 +
 +	case PL330_STATE_FAULTING:
 +		_stop(thrd);
++=======
+ 		fallthrough;
+ 
+ 	case PL330_STATE_FAULTING:
+ 		_stop(thrd);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case PL330_STATE_KILLING:
  	case PL330_STATE_COMPLETING:
  		UNTIL(thrd, PL330_STATE_STOPPED)
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case PL330_STATE_STOPPED:
  		return _trigger(thrd);
@@@ -1196,9 -1209,11 +1206,8 @@@ static int _bursts(struct pl330_dmac *p
  	int off = 0;
  	enum pl330_cond cond = BRST_LEN(pxs->ccr) > 1 ? BURST : SINGLE;
  
 -	if (pl330->quirks & PL330_QUIRK_PERIPH_BURST)
 -		cond = BURST;
 -
  	switch (pxs->desc->rqtype) {
  	case DMA_MEM_TO_DEV:
- 		/* fall through */
  	case DMA_DEV_TO_MEM:
  		off += _ldst_peripheral(pl330, dry_run, &buf[off], pxs, cyc,
  			cond);
@@@ -1230,12 -1246,27 +1239,11 @@@ static int _dregs(struct pl330_dmac *pl
  	if (transfer_length == 0)
  		return off;
  
 -	/*
 -	 * dregs_len = (total bytes - BURST_TO_BYTE(bursts, ccr)) /
 -	 *             BRST_SIZE(ccr)
 -	 * the dregs len must be smaller than burst len,
 -	 * so, for higher efficiency, we can modify CCR
 -	 * to use a reduced size burst len for the dregs.
 -	 */
 -	dregs_ccr = pxs->ccr;
 -	dregs_ccr &= ~((0xf << CC_SRCBRSTLEN_SHFT) |
 -		(0xf << CC_DSTBRSTLEN_SHFT));
 -	dregs_ccr |= (((transfer_length - 1) & 0xf) <<
 -		CC_SRCBRSTLEN_SHFT);
 -	dregs_ccr |= (((transfer_length - 1) & 0xf) <<
 -		CC_DSTBRSTLEN_SHFT);
 -
  	switch (pxs->desc->rqtype) {
  	case DMA_MEM_TO_DEV:
- 		/* fall through */
  	case DMA_DEV_TO_MEM:
 -		off += _emit_MOV(dry_run, &buf[off], CCR, dregs_ccr);
 -		off += _ldst_peripheral(pl330, dry_run, &buf[off], pxs, 1,
 -					BURST);
 +		off += _ldst_peripheral(pl330, dry_run, &buf[off], pxs,
 +			transfer_length, SINGLE);
  		break;
  
  	case DMA_MEM_TO_MEM:
diff --cc drivers/edac/amd64_edac.c
index f926de9d3ca2,fcc08bbf6945..000000000000
--- a/drivers/edac/amd64_edac.c
+++ b/drivers/edac/amd64_edac.c
@@@ -3363,9 -3366,22 +3363,14 @@@ static struct amd64_family_type *per_fa
  			fam_type = &family_types[F17_M30H_CPUS];
  			pvt->ops = &family_types[F17_M30H_CPUS].ops;
  			break;
 -		} else if (pvt->model >= 0x60 && pvt->model <= 0x6f) {
 -			fam_type = &family_types[F17_M60H_CPUS];
 -			pvt->ops = &family_types[F17_M60H_CPUS].ops;
 -			break;
 -		} else if (pvt->model >= 0x70 && pvt->model <= 0x7f) {
 -			fam_type = &family_types[F17_M70H_CPUS];
 -			pvt->ops = &family_types[F17_M70H_CPUS].ops;
 -			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
+ 	case 0x18:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		fam_type	= &family_types[F17_CPUS];
  		pvt->ops	= &family_types[F17_CPUS].ops;
 -
 -		if (pvt->fam == 0x18)
 -			family_types[F17_CPUS].ctl_name = "F18h";
  		break;
  
  	case 0x19:
diff --cc drivers/firewire/core-device.c
index 7c2eed76011e,80db43a22069..000000000000
--- a/drivers/firewire/core-device.c
+++ b/drivers/firewire/core-device.c
@@@ -970,7 -957,7 +970,11 @@@ static void set_broadcast_channel(struc
  				device->bc_implemented = BC_IMPLEMENTED;
  				break;
  			}
++<<<<<<< HEAD
 +			/* else fall through to case address error */
++=======
+ 			fallthrough;	/* to case address error */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case RCODE_ADDRESS_ERROR:
  			device->bc_implemented = BC_UNIMPLEMENTED;
  		}
diff --cc drivers/firewire/core-iso.c
index 051327a951b1,af70e74f9a7e..000000000000
--- a/drivers/firewire/core-iso.c
+++ b/drivers/firewire/core-iso.c
@@@ -308,7 -277,7 +308,11 @@@ static int manage_channel(struct fw_car
  			if ((data[0] & bit) == (data[1] & bit))
  				continue;
  
++<<<<<<< HEAD
 +			/* 1394-1995 IRM, fall through to retry. */
++=======
+ 			fallthrough;	/* It's a 1394-1995 IRM, retry */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			if (retry) {
  				retry--;
diff --cc drivers/firewire/core-topology.c
index 7db234d3fbdd,ec68ed27b0a5..000000000000
--- a/drivers/firewire/core-topology.c
+++ b/drivers/firewire/core-topology.c
@@@ -67,6 -54,7 +67,10 @@@ static u32 *count_ports(u32 *sid, int *
  		switch (port_type) {
  		case SELFID_PORT_CHILD:
  			(*child_port_count)++;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case SELFID_PORT_PARENT:
  		case SELFID_PORT_NCONN:
  			(*total_port_count)++;
diff --cc drivers/gpu/drm/arm/malidp_hw.c
index 069783e715f1,e9de542f9b7c..000000000000
--- a/drivers/gpu/drm/arm/malidp_hw.c
+++ b/drivers/gpu/drm/arm/malidp_hw.c
@@@ -368,6 -509,66 +368,69 @@@ static long malidp500_se_calc_mclk(stru
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int malidp500_enable_memwrite(struct malidp_hw_device *hwdev,
+ 				     dma_addr_t *addrs, s32 *pitches,
+ 				     int num_planes, u16 w, u16 h, u32 fmt_id,
+ 				     const s16 *rgb2yuv_coeffs)
+ {
+ 	u32 base = MALIDP500_SE_MEMWRITE_BASE;
+ 	u32 de_base = malidp_get_block_base(hwdev, MALIDP_DE_BLOCK);
+ 
+ 	/* enable the scaling engine block */
+ 	malidp_hw_setbits(hwdev, MALIDP_SCALE_ENGINE_EN, de_base + MALIDP_DE_DISPLAY_FUNC);
+ 
+ 	/* restart the writeback if already enabled */
+ 	if (hwdev->mw_state != MW_NOT_ENABLED)
+ 		hwdev->mw_state = MW_RESTART;
+ 	else
+ 		hwdev->mw_state = MW_START;
+ 
+ 	malidp_hw_write(hwdev, fmt_id, base + MALIDP_MW_FORMAT);
+ 	switch (num_planes) {
+ 	case 2:
+ 		malidp_hw_write(hwdev, lower_32_bits(addrs[1]), base + MALIDP_MW_P2_PTR_LOW);
+ 		malidp_hw_write(hwdev, upper_32_bits(addrs[1]), base + MALIDP_MW_P2_PTR_HIGH);
+ 		malidp_hw_write(hwdev, pitches[1], base + MALIDP_MW_P2_STRIDE);
+ 		fallthrough;
+ 	case 1:
+ 		malidp_hw_write(hwdev, lower_32_bits(addrs[0]), base + MALIDP_MW_P1_PTR_LOW);
+ 		malidp_hw_write(hwdev, upper_32_bits(addrs[0]), base + MALIDP_MW_P1_PTR_HIGH);
+ 		malidp_hw_write(hwdev, pitches[0], base + MALIDP_MW_P1_STRIDE);
+ 		break;
+ 	default:
+ 		WARN(1, "Invalid number of planes");
+ 	}
+ 
+ 	malidp_hw_write(hwdev, MALIDP_DE_H_ACTIVE(w) | MALIDP_DE_V_ACTIVE(h),
+ 			MALIDP500_SE_MEMWRITE_OUT_SIZE);
+ 
+ 	if (rgb2yuv_coeffs) {
+ 		int i;
+ 
+ 		for (i = 0; i < MALIDP_COLORADJ_NUM_COEFFS; i++) {
+ 			malidp_hw_write(hwdev, rgb2yuv_coeffs[i],
+ 					MALIDP500_SE_RGB_YUV_COEFFS + i * 4);
+ 		}
+ 	}
+ 
+ 	malidp_hw_setbits(hwdev, MALIDP_SE_MEMWRITE_EN, MALIDP500_SE_CONTROL);
+ 
+ 	return 0;
+ }
+ 
+ static void malidp500_disable_memwrite(struct malidp_hw_device *hwdev)
+ {
+ 	u32 base = malidp_get_block_base(hwdev, MALIDP_DE_BLOCK);
+ 
+ 	if (hwdev->mw_state == MW_START || hwdev->mw_state == MW_RESTART)
+ 		hwdev->mw_state = MW_STOP;
+ 	malidp_hw_clearbits(hwdev, MALIDP_SE_MEMWRITE_EN, MALIDP500_SE_CONTROL);
+ 	malidp_hw_clearbits(hwdev, MALIDP_SCALE_ENGINE_EN, base + MALIDP_DE_DISPLAY_FUNC);
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static int malidp550_query_hw(struct malidp_hw_device *hwdev)
  {
  	u32 conf = malidp_hw_read(hwdev, MALIDP550_CONFIG_ID);
@@@ -588,6 -850,61 +651,64 @@@ static long malidp550_se_calc_mclk(stru
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int malidp550_enable_memwrite(struct malidp_hw_device *hwdev,
+ 				     dma_addr_t *addrs, s32 *pitches,
+ 				     int num_planes, u16 w, u16 h, u32 fmt_id,
+ 				     const s16 *rgb2yuv_coeffs)
+ {
+ 	u32 base = MALIDP550_SE_MEMWRITE_BASE;
+ 	u32 de_base = malidp_get_block_base(hwdev, MALIDP_DE_BLOCK);
+ 
+ 	/* enable the scaling engine block */
+ 	malidp_hw_setbits(hwdev, MALIDP_SCALE_ENGINE_EN, de_base + MALIDP_DE_DISPLAY_FUNC);
+ 
+ 	hwdev->mw_state = MW_ONESHOT;
+ 
+ 	malidp_hw_write(hwdev, fmt_id, base + MALIDP_MW_FORMAT);
+ 	switch (num_planes) {
+ 	case 2:
+ 		malidp_hw_write(hwdev, lower_32_bits(addrs[1]), base + MALIDP_MW_P2_PTR_LOW);
+ 		malidp_hw_write(hwdev, upper_32_bits(addrs[1]), base + MALIDP_MW_P2_PTR_HIGH);
+ 		malidp_hw_write(hwdev, pitches[1], base + MALIDP_MW_P2_STRIDE);
+ 		fallthrough;
+ 	case 1:
+ 		malidp_hw_write(hwdev, lower_32_bits(addrs[0]), base + MALIDP_MW_P1_PTR_LOW);
+ 		malidp_hw_write(hwdev, upper_32_bits(addrs[0]), base + MALIDP_MW_P1_PTR_HIGH);
+ 		malidp_hw_write(hwdev, pitches[0], base + MALIDP_MW_P1_STRIDE);
+ 		break;
+ 	default:
+ 		WARN(1, "Invalid number of planes");
+ 	}
+ 
+ 	malidp_hw_write(hwdev, MALIDP_DE_H_ACTIVE(w) | MALIDP_DE_V_ACTIVE(h),
+ 			MALIDP550_SE_MEMWRITE_OUT_SIZE);
+ 	malidp_hw_setbits(hwdev, MALIDP550_SE_MEMWRITE_ONESHOT | MALIDP_SE_MEMWRITE_EN,
+ 			  MALIDP550_SE_CONTROL);
+ 
+ 	if (rgb2yuv_coeffs) {
+ 		int i;
+ 
+ 		for (i = 0; i < MALIDP_COLORADJ_NUM_COEFFS; i++) {
+ 			malidp_hw_write(hwdev, rgb2yuv_coeffs[i],
+ 					MALIDP550_SE_RGB_YUV_COEFFS + i * 4);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void malidp550_disable_memwrite(struct malidp_hw_device *hwdev)
+ {
+ 	u32 base = malidp_get_block_base(hwdev, MALIDP_DE_BLOCK);
+ 
+ 	malidp_hw_clearbits(hwdev, MALIDP550_SE_MEMWRITE_ONESHOT | MALIDP_SE_MEMWRITE_EN,
+ 			    MALIDP550_SE_CONTROL);
+ 	malidp_hw_clearbits(hwdev, MALIDP_SCALE_ENGINE_EN, base + MALIDP_DE_DISPLAY_FUNC);
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static int malidp650_query_hw(struct malidp_hw_device *hwdev)
  {
  	u32 conf = malidp_hw_read(hwdev, MALIDP550_CONFIG_ID);
@@@ -879,13 -1301,45 +1000,45 @@@ static irqreturn_t malidp_se_irq(int ir
  		return IRQ_NONE;
  
  	status = malidp_hw_read(hwdev, hw->map.se_base + MALIDP_REG_STATUS);
 -	if (!(status & (se->irq_mask | se->err_mask)))
 +	if (!(status & se->irq_mask))
  		return IRQ_NONE;
  
 -#ifdef CONFIG_DEBUG_FS
 -	if (status & se->err_mask)
 -		malidp_error(malidp, &malidp->se_errors, status,
 -			     drm_crtc_vblank_count(&malidp->crtc));
 -#endif
  	mask = malidp_hw_read(hwdev, hw->map.se_base + MALIDP_REG_MASKIRQ);
 +	status = malidp_hw_read(hwdev, hw->map.se_base + MALIDP_REG_STATUS);
  	status &= mask;
++<<<<<<< HEAD
 +	/* ToDo: status decoding and firing up of VSYNC and page flip events */
++=======
+ 
+ 	if (status & se->vsync_irq) {
+ 		switch (hwdev->mw_state) {
+ 		case MW_ONESHOT:
+ 			drm_writeback_signal_completion(&malidp->mw_connector, 0);
+ 			break;
+ 		case MW_STOP:
+ 			drm_writeback_signal_completion(&malidp->mw_connector, 0);
+ 			/* disable writeback after stop */
+ 			hwdev->mw_state = MW_NOT_ENABLED;
+ 			break;
+ 		case MW_RESTART:
+ 			drm_writeback_signal_completion(&malidp->mw_connector, 0);
+ 			fallthrough;	/* to a new start */
+ 		case MW_START:
+ 			/* writeback started, need to emulate one-shot mode */
+ 			hw->disable_memwrite(hwdev);
+ 			/*
+ 			 * only set config_valid HW bit if there is no other update
+ 			 * in progress or if we raced ahead of the DE IRQ handler
+ 			 * and config_valid flag will not be update until later
+ 			 */
+ 			status = malidp_hw_read(hwdev, hw->map.dc_base + MALIDP_REG_STATUS);
+ 			if ((atomic_read(&malidp->config_valid) != MALIDP_CONFIG_START) ||
+ 			    (status & hw->map.dc_irq_map.vsync_irq))
+ 				hw->set_config_valid(hwdev, 1);
+ 			break;
+ 		}
+ 	}
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	malidp_hw_clear_irq(hwdev, MALIDP_SE_BLOCK, status);
  
diff --cc drivers/gpu/drm/bridge/ti-sn65dsi86.c
index 9a2dd986afa5,5b6e19ecbc84..000000000000
--- a/drivers/gpu/drm/bridge/ti-sn65dsi86.c
+++ b/drivers/gpu/drm/bridge/ti-sn65dsi86.c
@@@ -433,25 -522,99 +433,110 @@@ static void ti_sn_bridge_set_dsi_dp_rat
  	struct drm_display_mode *mode =
  		&pdata->bridge.encoder->crtc->state->adjusted_mode;
  
 -	/* Calculate minimum bit rate based on our pixel clock. */
 -	bit_rate_khz = mode->clock * ti_sn_bridge_get_bpp(pdata);
 +	/* set DSIA clk frequency */
 +	bit_rate_mhz = (mode->clock / 1000) *
 +			mipi_dsi_pixel_format_to_bpp(pdata->dsi->format);
 +	clk_freq_mhz = bit_rate_mhz / (pdata->dsi->lanes * 2);
  
 -	/* Calculate minimum DP data rate, taking 80% as per DP spec */
 -	dp_rate_mhz = DIV_ROUND_UP(bit_rate_khz * DP_CLK_FUDGE_NUM,
 -				   1000 * pdata->dp_lanes * DP_CLK_FUDGE_DEN);
 +	/* for each increment in val, frequency increases by 5MHz */
 +	val = (MIN_DSI_CLK_FREQ_MHZ / 5) +
 +		(((clk_freq_mhz - MIN_DSI_CLK_FREQ_MHZ) / 5) & 0xFF);
 +	regmap_write(pdata->regmap, SN_DSIA_CLK_FREQ_REG, val);
  
 -	for (i = 1; i < ARRAY_SIZE(ti_sn_bridge_dp_rate_lut) - 1; i++)
 -		if (ti_sn_bridge_dp_rate_lut[i] >= dp_rate_mhz)
 +	/* set DP data rate */
 +	dp_rate_mhz = ((bit_rate_mhz / pdata->dsi->lanes) * DP_CLK_FUDGE_NUM) /
 +							DP_CLK_FUDGE_DEN;
 +	for (i = 0; i < ARRAY_SIZE(ti_sn_bridge_dp_rate_lut) - 1; i++)
 +		if (ti_sn_bridge_dp_rate_lut[i] > dp_rate_mhz)
  			break;
  
++<<<<<<< HEAD
 +	regmap_update_bits(pdata->regmap, SN_DATARATE_CONFIG_REG,
 +			   DP_DATARATE_MASK, DP_DATARATE(i));
++=======
+ 	return i;
+ }
+ 
+ static void ti_sn_bridge_read_valid_rates(struct ti_sn_bridge *pdata,
+ 					  bool rate_valid[])
+ {
+ 	unsigned int rate_per_200khz;
+ 	unsigned int rate_mhz;
+ 	u8 dpcd_val;
+ 	int ret;
+ 	int i, j;
+ 
+ 	ret = drm_dp_dpcd_readb(&pdata->aux, DP_EDP_DPCD_REV, &dpcd_val);
+ 	if (ret != 1) {
+ 		DRM_DEV_ERROR(pdata->dev,
+ 			      "Can't read eDP rev (%d), assuming 1.1\n", ret);
+ 		dpcd_val = DP_EDP_11;
+ 	}
+ 
+ 	if (dpcd_val >= DP_EDP_14) {
+ 		/* eDP 1.4 devices must provide a custom table */
+ 		__le16 sink_rates[DP_MAX_SUPPORTED_RATES];
+ 
+ 		ret = drm_dp_dpcd_read(&pdata->aux, DP_SUPPORTED_LINK_RATES,
+ 				       sink_rates, sizeof(sink_rates));
+ 
+ 		if (ret != sizeof(sink_rates)) {
+ 			DRM_DEV_ERROR(pdata->dev,
+ 				"Can't read supported rate table (%d)\n", ret);
+ 
+ 			/* By zeroing we'll fall back to DP_MAX_LINK_RATE. */
+ 			memset(sink_rates, 0, sizeof(sink_rates));
+ 		}
+ 
+ 		for (i = 0; i < ARRAY_SIZE(sink_rates); i++) {
+ 			rate_per_200khz = le16_to_cpu(sink_rates[i]);
+ 
+ 			if (!rate_per_200khz)
+ 				break;
+ 
+ 			rate_mhz = rate_per_200khz * 200 / 1000;
+ 			for (j = 0;
+ 			     j < ARRAY_SIZE(ti_sn_bridge_dp_rate_lut);
+ 			     j++) {
+ 				if (ti_sn_bridge_dp_rate_lut[j] == rate_mhz)
+ 					rate_valid[j] = true;
+ 			}
+ 		}
+ 
+ 		for (i = 0; i < ARRAY_SIZE(ti_sn_bridge_dp_rate_lut); i++) {
+ 			if (rate_valid[i])
+ 				return;
+ 		}
+ 		DRM_DEV_ERROR(pdata->dev,
+ 			      "No matching eDP rates in table; falling back\n");
+ 	}
+ 
+ 	/* On older versions best we can do is use DP_MAX_LINK_RATE */
+ 	ret = drm_dp_dpcd_readb(&pdata->aux, DP_MAX_LINK_RATE, &dpcd_val);
+ 	if (ret != 1) {
+ 		DRM_DEV_ERROR(pdata->dev,
+ 			      "Can't read max rate (%d); assuming 5.4 GHz\n",
+ 			      ret);
+ 		dpcd_val = DP_LINK_BW_5_4;
+ 	}
+ 
+ 	switch (dpcd_val) {
+ 	default:
+ 		DRM_DEV_ERROR(pdata->dev,
+ 			      "Unexpected max rate (%#x); assuming 5.4 GHz\n",
+ 			      (int)dpcd_val);
+ 		fallthrough;
+ 	case DP_LINK_BW_5_4:
+ 		rate_valid[7] = 1;
+ 		fallthrough;
+ 	case DP_LINK_BW_2_7:
+ 		rate_valid[4] = 1;
+ 		fallthrough;
+ 	case DP_LINK_BW_1_62:
+ 		rate_valid[1] = 1;
+ 		break;
+ 	}
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  }
  
  static void ti_sn_bridge_set_video_timings(struct ti_sn_bridge *pdata)
diff --cc drivers/gpu/drm/i915/display/intel_bios.c
index ef4017a1baba,a0a41ec5c341..000000000000
--- a/drivers/gpu/drm/i915/display/intel_bios.c
+++ b/drivers/gpu/drm/i915/display/intel_bios.c
@@@ -874,9 -902,10 +874,16 @@@ parse_psr(struct drm_i915_private *dev_
  			dev_priv->vbt.psr.tp1_wakeup_time_us = 0;
  			break;
  		default:
++<<<<<<< HEAD
 +			DRM_DEBUG_KMS("VBT tp1 wakeup time value %d is outside range[0-3], defaulting to max value 2500us\n",
 +					psr_table->tp1_wakeup_time);
 +			/* fallthrough */
++=======
+ 			drm_dbg_kms(&dev_priv->drm,
+ 				    "VBT tp1 wakeup time value %d is outside range[0-3], defaulting to max value 2500us\n",
+ 				    psr_table->tp1_wakeup_time);
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 2:
  			dev_priv->vbt.psr.tp1_wakeup_time_us = 2500;
  			break;
@@@ -893,9 -922,10 +900,16 @@@
  			dev_priv->vbt.psr.tp2_tp3_wakeup_time_us = 0;
  			break;
  		default:
++<<<<<<< HEAD
 +			DRM_DEBUG_KMS("VBT tp2_tp3 wakeup time value %d is outside range[0-3], defaulting to max value 2500us\n",
 +					psr_table->tp2_tp3_wakeup_time);
 +			/* fallthrough */
++=======
+ 			drm_dbg_kms(&dev_priv->drm,
+ 				    "VBT tp2_tp3 wakeup time value %d is outside range[0-3], defaulting to max value 2500us\n",
+ 				    psr_table->tp2_tp3_wakeup_time);
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 2:
  			dev_priv->vbt.psr.tp2_tp3_wakeup_time_us = 2500;
  		break;
diff --cc drivers/gpu/drm/i915/display/intel_cdclk.c
index 0ce5926006ca,91a8161e7c05..000000000000
--- a/drivers/gpu/drm/i915/display/intel_cdclk.c
+++ b/drivers/gpu/drm/i915/display/intel_cdclk.c
@@@ -307,25 -312,26 +307,31 @@@ static void pnv_get_cdclk(struct drm_i9
  
  	switch (gcfgc & GC_DISPLAY_CLOCK_MASK) {
  	case GC_DISPLAY_CLOCK_267_MHZ_PNV:
 -		cdclk_config->cdclk = 266667;
 +		cdclk_state->cdclk = 266667;
  		break;
  	case GC_DISPLAY_CLOCK_333_MHZ_PNV:
 -		cdclk_config->cdclk = 333333;
 +		cdclk_state->cdclk = 333333;
  		break;
  	case GC_DISPLAY_CLOCK_444_MHZ_PNV:
 -		cdclk_config->cdclk = 444444;
 +		cdclk_state->cdclk = 444444;
  		break;
  	case GC_DISPLAY_CLOCK_200_MHZ_PNV:
 -		cdclk_config->cdclk = 200000;
 +		cdclk_state->cdclk = 200000;
  		break;
  	default:
++<<<<<<< HEAD
 +		DRM_ERROR("Unknown pnv display core clock 0x%04x\n", gcfgc);
 +		/* fall through */
++=======
+ 		drm_err(&dev_priv->drm,
+ 			"Unknown pnv display core clock 0x%04x\n", gcfgc);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case GC_DISPLAY_CLOCK_133_MHZ_PNV:
 -		cdclk_config->cdclk = 133333;
 +		cdclk_state->cdclk = 133333;
  		break;
  	case GC_DISPLAY_CLOCK_167_MHZ_PNV:
 -		cdclk_config->cdclk = 166667;
 +		cdclk_state->cdclk = 166667;
  		break;
  	}
  }
@@@ -1020,9 -1039,10 +1026,16 @@@ static void skl_set_cdclk(struct drm_i9
  	/* Choose frequency for this cdclk */
  	switch (cdclk) {
  	default:
++<<<<<<< HEAD
 +		WARN_ON(cdclk != dev_priv->cdclk.hw.bypass);
 +		WARN_ON(vco != 0);
 +		/* fall through */
++=======
+ 		drm_WARN_ON(&dev_priv->drm,
+ 			    cdclk != dev_priv->cdclk.hw.bypass);
+ 		drm_WARN_ON(&dev_priv->drm, vco != 0);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 308571:
  	case 337500:
  		freq_select = CDCLK_FREQ_337_308;
@@@ -1300,15 -1333,15 +1313,15 @@@ static void icl_readout_refclk(struct d
  	switch (dssm) {
  	default:
  		MISSING_CASE(dssm);
- 		/* fall through */
+ 		fallthrough;
  	case ICL_DSSM_CDCLK_PLL_REFCLK_24MHz:
 -		cdclk_config->ref = 24000;
 +		cdclk_state->ref = 24000;
  		break;
  	case ICL_DSSM_CDCLK_PLL_REFCLK_19_2MHz:
 -		cdclk_config->ref = 19200;
 +		cdclk_state->ref = 19200;
  		break;
  	case ICL_DSSM_CDCLK_PLL_REFCLK_38_4MHz:
 -		cdclk_config->ref = 38400;
 +		cdclk_state->ref = 38400;
  		break;
  	}
  }
@@@ -1520,9 -1558,10 +1533,16 @@@ static void bxt_set_cdclk(struct drm_i9
  	/* cdclk = vco / 2 / div{1,1.5,2,4} */
  	switch (DIV_ROUND_CLOSEST(vco, cdclk)) {
  	default:
++<<<<<<< HEAD
 +		WARN_ON(cdclk != dev_priv->cdclk.hw.bypass);
 +		WARN_ON(vco != 0);
 +		/* fall through */
++=======
+ 		drm_WARN_ON(&dev_priv->drm,
+ 			    cdclk != dev_priv->cdclk.hw.bypass);
+ 		drm_WARN_ON(&dev_priv->drm, vco != 0);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		divider = BXT_CDCLK_CD2X_DIV_SEL_1;
  		break;
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index 9dcc1d7d87b5,68325678f5ef..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -6126,11 -6211,12 +6126,11 @@@ static int skl_update_scaler_plane(stru
  	case DRM_FORMAT_ARGB16161616F:
  		if (INTEL_GEN(dev_priv) >= 11)
  			break;
- 		/* fall through */
+ 		fallthrough;
  	default:
 -		drm_dbg_kms(&dev_priv->drm,
 -			    "[PLANE:%d:%s] FB:%d unsupported scaling format 0x%x\n",
 -			    intel_plane->base.base.id, intel_plane->base.name,
 -			    fb->base.id, fb->format->format);
 +		DRM_DEBUG_KMS("[PLANE:%d:%s] FB:%d unsupported scaling format 0x%x\n",
 +			      intel_plane->base.base.id, intel_plane->base.name,
 +			      fb->base.id, fb->format->format);
  		return -EINVAL;
  	}
  
@@@ -10748,12 -10953,13 +10748,19 @@@ static bool hsw_get_transcoder_state(st
  
  		switch (tmp & TRANS_DDI_EDP_INPUT_MASK) {
  		default:
++<<<<<<< HEAD
 +			WARN(1, "unknown pipe linked to transcoder %s\n",
 +			     transcoder_name(panel_transcoder));
 +			/* fall through */
++=======
+ 			drm_WARN(dev, 1,
+ 				 "unknown pipe linked to transcoder %s\n",
+ 				 transcoder_name(panel_transcoder));
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case TRANS_DDI_EDP_INPUT_A_ONOFF:
  			force_thru = true;
- 			/* fall through */
+ 			fallthrough;
  		case TRANS_DDI_EDP_INPUT_A_ON:
  			trans_pipe = PIPE_A;
  			break;
@@@ -12967,14 -13177,13 +12974,14 @@@ static bool check_digital_port_conflict
  
  		encoder = to_intel_encoder(connector_state->best_encoder);
  
 -		drm_WARN_ON(dev, !connector_state->crtc);
 +		WARN_ON(!connector_state->crtc);
  
  		switch (encoder->type) {
 +			unsigned int port_mask;
  		case INTEL_OUTPUT_DDI:
 -			if (drm_WARN_ON(dev, !HAS_DDI(to_i915(dev))))
 +			if (WARN_ON(!HAS_DDI(to_i915(dev))))
  				break;
- 			/* else, fall through */
+ 			fallthrough;
  		case INTEL_OUTPUT_DP:
  		case INTEL_OUTPUT_HDMI:
  		case INTEL_OUTPUT_EDP:
diff --cc drivers/gpu/drm/i915/display/intel_dpll_mgr.c
index c75e34d87111,afa7a378b31d..000000000000
--- a/drivers/gpu/drm/i915/display/intel_dpll_mgr.c
+++ b/drivers/gpu/drm/i915/display/intel_dpll_mgr.c
@@@ -839,8 -878,47 +839,50 @@@ hsw_ddi_hdmi_get_dpll(struct intel_atom
  	return pll;
  }
  
++<<<<<<< HEAD
++=======
+ static int hsw_ddi_wrpll_get_freq(struct drm_i915_private *dev_priv,
+ 				  const struct intel_shared_dpll *pll)
+ {
+ 	int refclk;
+ 	int n, p, r;
+ 	u32 wrpll = pll->state.hw_state.wrpll;
+ 
+ 	switch (wrpll & WRPLL_REF_MASK) {
+ 	case WRPLL_REF_SPECIAL_HSW:
+ 		/* Muxed-SSC for BDW, non-SSC for non-ULT HSW. */
+ 		if (IS_HASWELL(dev_priv) && !IS_HSW_ULT(dev_priv)) {
+ 			refclk = dev_priv->dpll.ref_clks.nssc;
+ 			break;
+ 		}
+ 		fallthrough;
+ 	case WRPLL_REF_PCH_SSC:
+ 		/*
+ 		 * We could calculate spread here, but our checking
+ 		 * code only cares about 5% accuracy, and spread is a max of
+ 		 * 0.5% downspread.
+ 		 */
+ 		refclk = dev_priv->dpll.ref_clks.ssc;
+ 		break;
+ 	case WRPLL_REF_LCPLL:
+ 		refclk = 2700000;
+ 		break;
+ 	default:
+ 		MISSING_CASE(wrpll);
+ 		return 0;
+ 	}
+ 
+ 	r = wrpll & WRPLL_DIVIDER_REF_MASK;
+ 	p = (wrpll & WRPLL_DIVIDER_POST_MASK) >> WRPLL_DIVIDER_POST_SHIFT;
+ 	n = (wrpll & WRPLL_DIVIDER_FB_MASK) >> WRPLL_DIVIDER_FB_SHIFT;
+ 
+ 	/* Convert to KHz, p & r have a fixed point portion */
+ 	return (refclk * n / 10) / (p * r) * 2;
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static struct intel_shared_dpll *
 -hsw_ddi_lcpll_get_dpll(struct intel_crtc_state *crtc_state)
 +hsw_ddi_dp_get_dpll(struct intel_crtc_state *crtc_state)
  {
  	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
  	struct intel_shared_dpll *pll;
@@@ -2578,23 -2974,25 +2620,33 @@@ static bool icl_calc_tbt_pll(struct int
  	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
  
  	if (INTEL_GEN(dev_priv) >= 12) {
 -		switch (dev_priv->dpll.ref_clks.nssc) {
 +		switch (dev_priv->cdclk.hw.ref) {
  		default:
++<<<<<<< HEAD
 +			MISSING_CASE(dev_priv->cdclk.hw.ref);
 +			/* fall-through */
++=======
+ 			MISSING_CASE(dev_priv->dpll.ref_clks.nssc);
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 19200:
 +		case 38400:
  			*pll_params = tgl_tbt_pll_19_2MHz_values;
  			break;
  		case 24000:
  			*pll_params = tgl_tbt_pll_24MHz_values;
  			break;
 -		case 38400:
 -			*pll_params = tgl_tbt_pll_38_4MHz_values;
 -			break;
  		}
  	} else {
 -		switch (dev_priv->dpll.ref_clks.nssc) {
 +		switch (dev_priv->cdclk.hw.ref) {
  		default:
++<<<<<<< HEAD
 +			MISSING_CASE(dev_priv->cdclk.hw.ref);
 +			/* fall-through */
++=======
+ 			MISSING_CASE(dev_priv->dpll.ref_clks.nssc);
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 19200:
  		case 38400:
  			*pll_params = icl_tbt_pll_19_2MHz_values;
diff --cc drivers/gpu/drm/i915/display/intel_panel.c
index 7b3ec6eb3382,4072d7062efd..000000000000
--- a/drivers/gpu/drm/i915/display/intel_panel.c
+++ b/drivers/gpu/drm/i915/display/intel_panel.c
@@@ -224,6 -226,10 +224,13 @@@ intel_pch_panel_fitting(struct intel_cr
  		}
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case DRM_MODE_SCALE_NONE:
+ 		WARN_ON(adjusted_mode->crtc_hdisplay != crtc_state->pipe_src_w);
+ 		WARN_ON(adjusted_mode->crtc_vdisplay != crtc_state->pipe_src_h);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case DRM_MODE_SCALE_FULLSCREEN:
  		x = y = 0;
  		width = adjusted_mode->crtc_hdisplay;
diff --cc drivers/gpu/drm/i915/display/intel_sdvo.c
index 06c1f9a91c75,5e9fb349c829..000000000000
--- a/drivers/gpu/drm/i915/display/intel_sdvo.c
+++ b/drivers/gpu/drm/i915/display/intel_sdvo.c
@@@ -1499,8 -1529,9 +1499,14 @@@ static void intel_sdvo_pre_enable(struc
  
  	switch (crtc_state->pixel_multiplier) {
  	default:
++<<<<<<< HEAD
 +		WARN(1, "unknown pixel multiplier specified\n");
 +		/* fall through */
++=======
+ 		drm_WARN(&dev_priv->drm, 1,
+ 			 "unknown pixel multiplier specified\n");
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1: rate = SDVO_CLOCK_RATE_MULT_1X; break;
  	case 2: rate = SDVO_CLOCK_RATE_MULT_2X; break;
  	case 4: rate = SDVO_CLOCK_RATE_MULT_4X; break;
diff --cc drivers/gpu/drm/msm/adreno/a5xx_gpu.c
index d39400e5bc42,84a5d9c1f2a2..000000000000
--- a/drivers/gpu/drm/msm/adreno/a5xx_gpu.c
+++ b/drivers/gpu/drm/msm/adreno/a5xx_gpu.c
@@@ -156,6 -59,7 +156,10 @@@ static void a5xx_submit_in_rb(struct ms
  		case MSM_SUBMIT_CMD_CTX_RESTORE_BUF:
  			if (priv->lastctx == ctx)
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case MSM_SUBMIT_CMD_BUF:
  			/* copy commands into RB: */
  			obj = submit->bos[submit->cmd[i].idx].obj;
@@@ -246,6 -150,7 +250,10 @@@ static void a5xx_submit(struct msm_gpu 
  		case MSM_SUBMIT_CMD_CTX_RESTORE_BUF:
  			if (priv->lastctx == ctx)
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case MSM_SUBMIT_CMD_BUF:
  			OUT_PKT7(ring, CP_INDIRECT_BUFFER_PFE, 3);
  			OUT_RING(ring, lower_32_bits(submit->cmd[i].iova));
diff --cc drivers/gpu/drm/msm/adreno/adreno_gpu.c
index 17d0506d058c,bb0b09790157..000000000000
--- a/drivers/gpu/drm/msm/adreno/adreno_gpu.c
+++ b/drivers/gpu/drm/msm/adreno/adreno_gpu.c
@@@ -288,8 -474,9 +288,12 @@@ void adreno_submit(struct msm_gpu *gpu
  			/* ignore if there has not been a ctx switch: */
  			if (priv->lastctx == ctx)
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case MSM_SUBMIT_CMD_BUF:
 -			OUT_PKT3(ring, adreno_is_a4xx(adreno_gpu) ?
 +			OUT_PKT3(ring, adreno_is_a430(adreno_gpu) ?
  				CP_INDIRECT_BUFFER_PFE : CP_INDIRECT_BUFFER_PFD, 2);
  			OUT_RING(ring, lower_32_bits(submit->cmd[i].iova));
  			OUT_RING(ring, submit->cmd[i].size);
diff --cc drivers/gpu/drm/omapdrm/dss/venc.c
index 24d1ced210bd,bd12eae0cb31..000000000000
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@@ -760,13 -530,164 +760,162 @@@ static int venc_get_clocks(struct venc_
  	return 0;
  }
  
 -/* -----------------------------------------------------------------------------
 - * DRM Bridge Operations
 - */
 -
 -static int venc_bridge_attach(struct drm_bridge *bridge,
 -			      enum drm_bridge_attach_flags flags)
 +static int venc_connect(struct omap_dss_device *dssdev,
 +		struct omap_dss_device *dst)
  {
++<<<<<<< HEAD
 +	struct venc_device *venc = dssdev_to_venc(dssdev);
++=======
+ 	struct venc_device *venc = drm_bridge_to_venc(bridge);
+ 
+ 	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))
+ 		return -EINVAL;
+ 
+ 	return drm_bridge_attach(bridge->encoder, venc->output.next_bridge,
+ 				 bridge, flags);
+ }
+ 
+ static enum drm_mode_status
+ venc_bridge_mode_valid(struct drm_bridge *bridge,
+ 		       const struct drm_display_info *info,
+ 		       const struct drm_display_mode *mode)
+ {
+ 	switch (venc_get_videomode(mode)) {
+ 	case VENC_MODE_PAL:
+ 	case VENC_MODE_NTSC:
+ 		return MODE_OK;
+ 
+ 	default:
+ 		return MODE_BAD;
+ 	}
+ }
+ 
+ static bool venc_bridge_mode_fixup(struct drm_bridge *bridge,
+ 				   const struct drm_display_mode *mode,
+ 				   struct drm_display_mode *adjusted_mode)
+ {
+ 	const struct drm_display_mode *venc_mode;
+ 
+ 	switch (venc_get_videomode(adjusted_mode)) {
+ 	case VENC_MODE_PAL:
+ 		venc_mode = &omap_dss_pal_mode;
+ 		break;
+ 
+ 	case VENC_MODE_NTSC:
+ 		venc_mode = &omap_dss_ntsc_mode;
+ 		break;
+ 
+ 	default:
+ 		return false;
+ 	}
+ 
+ 	drm_mode_copy(adjusted_mode, venc_mode);
+ 	drm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);
+ 	drm_mode_set_name(adjusted_mode);
+ 
+ 	return true;
+ }
+ 
+ static void venc_bridge_mode_set(struct drm_bridge *bridge,
+ 				 const struct drm_display_mode *mode,
+ 				 const struct drm_display_mode *adjusted_mode)
+ {
+ 	struct venc_device *venc = drm_bridge_to_venc(bridge);
+ 	enum venc_videomode venc_mode = venc_get_videomode(adjusted_mode);
+ 
+ 	switch (venc_mode) {
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		fallthrough;
+ 	case VENC_MODE_PAL:
+ 		venc->config = &venc_config_pal_trm;
+ 		break;
+ 
+ 	case VENC_MODE_NTSC:
+ 		venc->config = &venc_config_ntsc_trm;
+ 		break;
+ 	}
+ 
+ 	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
+ }
+ 
+ static void venc_bridge_enable(struct drm_bridge *bridge)
+ {
+ 	struct venc_device *venc = drm_bridge_to_venc(bridge);
+ 
+ 	venc_power_on(venc);
+ }
+ 
+ static void venc_bridge_disable(struct drm_bridge *bridge)
+ {
+ 	struct venc_device *venc = drm_bridge_to_venc(bridge);
+ 
+ 	venc_power_off(venc);
+ }
+ 
+ static int venc_bridge_get_modes(struct drm_bridge *bridge,
+ 				 struct drm_connector *connector)
+ {
+ 	static const struct drm_display_mode *modes[] = {
+ 		&omap_dss_pal_mode,
+ 		&omap_dss_ntsc_mode,
+ 	};
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(modes); ++i) {
+ 		struct drm_display_mode *mode;
+ 
+ 		mode = drm_mode_duplicate(connector->dev, modes[i]);
+ 		if (!mode)
+ 			return i;
+ 
+ 		mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+ 		drm_mode_set_name(mode);
+ 		drm_mode_probed_add(connector, mode);
+ 	}
+ 
+ 	return ARRAY_SIZE(modes);
+ }
+ 
+ static const struct drm_bridge_funcs venc_bridge_funcs = {
+ 	.attach = venc_bridge_attach,
+ 	.mode_valid = venc_bridge_mode_valid,
+ 	.mode_fixup = venc_bridge_mode_fixup,
+ 	.mode_set = venc_bridge_mode_set,
+ 	.enable = venc_bridge_enable,
+ 	.disable = venc_bridge_disable,
+ 	.get_modes = venc_bridge_get_modes,
+ };
+ 
+ static void venc_bridge_init(struct venc_device *venc)
+ {
+ 	venc->bridge.funcs = &venc_bridge_funcs;
+ 	venc->bridge.of_node = venc->pdev->dev.of_node;
+ 	venc->bridge.ops = DRM_BRIDGE_OP_MODES;
+ 	venc->bridge.type = DRM_MODE_CONNECTOR_SVIDEO;
+ 	venc->bridge.interlace_allowed = true;
+ 
+ 	drm_bridge_add(&venc->bridge);
+ }
+ 
+ static void venc_bridge_cleanup(struct venc_device *venc)
+ {
+ 	drm_bridge_remove(&venc->bridge);
+ }
+ 
+ /* -----------------------------------------------------------------------------
+  * Component Bind & Unbind
+  */
+ 
+ static int venc_bind(struct device *dev, struct device *master, void *data)
+ {
+ 	struct dss_device *dss = dss_get_device(master);
+ 	struct venc_device *venc = dev_get_drvdata(dev);
+ 	u8 rev_id;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	int r;
  
 -	venc->dss = dss;
 -
 -	r = venc_runtime_get(venc);
 +	r = venc_init_regulator(venc);
  	if (r)
  		return r;
  
diff --cc drivers/gpu/drm/savage/savage_state.c
index 2db89bed52e8,e0d40ae67d54..000000000000
--- a/drivers/gpu/drm/savage/savage_state.c
+++ b/drivers/gpu/drm/savage/savage_state.c
@@@ -299,6 -306,7 +299,10 @@@ static int savage_dispatch_dma_prim(drm
  	case SAVAGE_PRIM_TRILIST_201:
  		reorder = 1;
  		prim = SAVAGE_PRIM_TRILIST;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SAVAGE_PRIM_TRILIST:
  		if (n % 3 != 0) {
  			DRM_ERROR("wrong number of vertices %u in TRILIST\n",
@@@ -436,6 -444,7 +440,10 @@@ static int savage_dispatch_vb_prim(drm_
  	case SAVAGE_PRIM_TRILIST_201:
  		reorder = 1;
  		prim = SAVAGE_PRIM_TRILIST;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SAVAGE_PRIM_TRILIST:
  		if (n % 3 != 0) {
  			DRM_ERROR("wrong number of vertices %u in TRILIST\n",
@@@ -557,6 -566,7 +565,10 @@@ static int savage_dispatch_dma_idx(drm_
  	case SAVAGE_PRIM_TRILIST_201:
  		reorder = 1;
  		prim = SAVAGE_PRIM_TRILIST;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SAVAGE_PRIM_TRILIST:
  		if (n % 3 != 0) {
  			DRM_ERROR("wrong number of indices %u in TRILIST\n", n);
@@@ -695,6 -705,7 +707,10 @@@ static int savage_dispatch_vb_idx(drm_s
  	case SAVAGE_PRIM_TRILIST_201:
  		reorder = 1;
  		prim = SAVAGE_PRIM_TRILIST;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SAVAGE_PRIM_TRILIST:
  		if (n % 3 != 0) {
  			DRM_ERROR("wrong number of indices %u in TRILIST\n", n);
diff --cc drivers/gpu/drm/sti/sti_hdmi.c
index 58f431102512,38a558768e53..000000000000
--- a/drivers/gpu/drm/sti/sti_hdmi.c
+++ b/drivers/gpu/drm/sti/sti_hdmi.c
@@@ -845,10 -850,13 +845,20 @@@ static int hdmi_audio_configure(struct 
  	switch (info->channels) {
  	case 8:
  		audio_cfg |= HDMI_AUD_CFG_CH78_VALID;
++<<<<<<< HEAD
 +	case 6:
 +		audio_cfg |= HDMI_AUD_CFG_CH56_VALID;
 +	case 4:
 +		audio_cfg |= HDMI_AUD_CFG_CH34_VALID | HDMI_AUD_CFG_8CH;
++=======
+ 		fallthrough;
+ 	case 6:
+ 		audio_cfg |= HDMI_AUD_CFG_CH56_VALID;
+ 		fallthrough;
+ 	case 4:
+ 		audio_cfg |= HDMI_AUD_CFG_CH34_VALID | HDMI_AUD_CFG_8CH;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		audio_cfg |= HDMI_AUD_CFG_CH12_VALID;
  		break;
diff --cc drivers/gpu/drm/sun4i/sun4i_tcon.c
index 8232b39e16ca,ced9a8287dd8..000000000000
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c
@@@ -275,10 -302,65 +275,65 @@@ static void sun4i_tcon0_mode_set_common
  		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
  }
  
++<<<<<<< HEAD
++=======
+ static void sun4i_tcon0_mode_set_dithering(struct sun4i_tcon *tcon,
+ 					   const struct drm_connector *connector)
+ {
+ 	u32 bus_format = 0;
+ 	u32 val = 0;
+ 
+ 	/* XXX Would this ever happen? */
+ 	if (!connector)
+ 		return;
+ 
+ 	/*
+ 	 * FIXME: Undocumented bits
+ 	 *
+ 	 * The whole dithering process and these parameters are not
+ 	 * explained in the vendor documents or BSP kernel code.
+ 	 */
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_PR_REG, 0x11111111);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_PG_REG, 0x11111111);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_PB_REG, 0x11111111);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_LR_REG, 0x11111111);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_LG_REG, 0x11111111);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_SEED_LB_REG, 0x11111111);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_TBL0_REG, 0x01010000);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_TBL1_REG, 0x15151111);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_TBL2_REG, 0x57575555);
+ 	regmap_write(tcon->regs, SUN4I_TCON0_FRM_TBL3_REG, 0x7f7f7777);
+ 
+ 	/* Do dithering if panel only supports 6 bits per color */
+ 	if (connector->display_info.bpc == 6)
+ 		val |= SUN4I_TCON0_FRM_CTL_EN;
+ 
+ 	if (connector->display_info.num_bus_formats == 1)
+ 		bus_format = connector->display_info.bus_formats[0];
+ 
+ 	/* Check the connection format */
+ 	switch (bus_format) {
+ 	case MEDIA_BUS_FMT_RGB565_1X16:
+ 		/* R and B components are only 5 bits deep */
+ 		val |= SUN4I_TCON0_FRM_CTL_MODE_R;
+ 		val |= SUN4I_TCON0_FRM_CTL_MODE_B;
+ 		fallthrough;
+ 	case MEDIA_BUS_FMT_RGB666_1X18:
+ 	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:
+ 		/* Fall through: enable dithering */
+ 		val |= SUN4I_TCON0_FRM_CTL_EN;
+ 		break;
+ 	}
+ 
+ 	/* Write dithering settings */
+ 	regmap_write(tcon->regs, SUN4I_TCON_FRM_CTL_REG, val);
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 -				     const struct drm_encoder *encoder,
 +				     struct mipi_dsi_device *device,
  				     const struct drm_display_mode *mode)
  {
 -	/* TODO support normal CPU interface modes */
 -	struct sun6i_dsi *dsi = encoder_to_sun6i_dsi(encoder);
 -	struct mipi_dsi_device *device = dsi->device;
  	u8 bpp = mipi_dsi_pixel_format_to_bpp(device->format);
  	u8 lanes = device->lanes;
  	u32 block_space, start_delay;
diff --cc drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
index bfbf761f0c1d,7f13f4d715bf..000000000000
--- a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
+++ b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
@@@ -861,6 -1027,7 +861,10 @@@ static ssize_t sun6i_dsi_transfer(struc
  			ret = sun6i_dsi_dcs_read(dsi, msg);
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		ret = -EINVAL;
diff --cc drivers/gpu/drm/via/via_dmablit.c
index 84cc4fe82e28,5771bb53ce6a..000000000000
--- a/drivers/gpu/drm/via/via_dmablit.c
+++ b/drivers/gpu/drm/via/via_dmablit.c
@@@ -183,14 -186,14 +183,20 @@@ via_free_sg_info(struct pci_dev *pdev, 
  				free_page((unsigned long)vsg->desc_pages[i]);
  		}
  		kfree(vsg->desc_pages);
- 		/* fall through */
+ 		fallthrough;
  	case dr_via_pages_locked:
++<<<<<<< HEAD
 +		put_user_pages_dirty_lock(vsg->pages, vsg->num_pages,
 +					  (vsg->direction == DMA_FROM_DEVICE));
 +		/* fall through */
++=======
+ 		unpin_user_pages_dirty_lock(vsg->pages, vsg->num_pages,
+ 					   (vsg->direction == DMA_FROM_DEVICE));
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case dr_via_pages_alloc:
  		vfree(vsg->pages);
- 		/* fall through */
+ 		fallthrough;
  	default:
  		vsg->state = dr_via_sg_init;
  	}
diff --cc drivers/hsi/clients/ssi_protocol.c
index 561abf7bdf1f,96d0eccca3aa..000000000000
--- a/drivers/hsi/clients/ssi_protocol.c
+++ b/drivers/hsi/clients/ssi_protocol.c
@@@ -303,7 -291,7 +303,11 @@@ static void ssip_set_rxstate(struct ssi
  		/* CMT speech workaround */
  		if (atomic_read(&ssi->tx_usecnt))
  			break;
++<<<<<<< HEAD
 +		/* Otherwise fall through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case RECEIVING:
  		mod_timer(&ssi->keep_alive, jiffies +
  						msecs_to_jiffies(SSIP_KATOUT));
@@@ -478,9 -466,10 +482,13 @@@ static void ssip_keep_alive(struct time
  		case SEND_READY:
  			if (atomic_read(&ssi->tx_usecnt) == 0)
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			/*
 -			 * Workaround for cmt-speech in that case
 -			 * we relay on audio timers.
 +			 * Fall through. Workaround for cmt-speech
 +			 * in that case we relay on audio timers.
  			 */
  		case SEND_IDLE:
  			spin_unlock(&ssi->lock);
diff --cc drivers/hwmon/adt7462.c
index 19f2a6d48bac,208813158bb4..000000000000
--- a/drivers/hwmon/adt7462.c
+++ b/drivers/hwmon/adt7462.c
@@@ -448,6 -435,7 +448,10 @@@ static const char *voltage_label(struc
  		case 3:
  			return "+1.5V";
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		if (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))
  			return "+12V3";
@@@ -505,6 -493,7 +509,10 @@@
  		case 3:
  			return "+1.5";
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 11:
  		if (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==
  					ADT7462_PIN28_VOLT &&
@@@ -542,6 -531,7 +550,10 @@@ static int voltage_multiplier(struct ad
  		case 3:
  			return 7800;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		if (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))
  			return 62500;
@@@ -599,6 -589,7 +611,10 @@@
  		case 3:
  			return 7800;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 11:
  	case 12:
  		if (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==
diff --cc drivers/hwmon/emc1403.c
index 1ea7ca510f84,e9c0bbc2caa9..000000000000
--- a/drivers/hwmon/emc1403.c
+++ b/drivers/hwmon/emc1403.c
@@@ -443,8 -406,10 +443,15 @@@ static int emc1403_probe(struct i2c_cli
  	switch (id->driver_data) {
  	case emc1404:
  		data->groups[2] = &emc1404_group;
++<<<<<<< HEAD
 +	case emc1403:
 +		data->groups[1] = &emc1403_group;
++=======
+ 		fallthrough;
+ 	case emc1403:
+ 		data->groups[1] = &emc1403_group;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case emc1402:
  		data->groups[0] = &emc1402_group;
  	}
diff --cc drivers/hwmon/f71882fg.c
index ca54ce5c8e10,4dec793fd07d..000000000000
--- a/drivers/hwmon/f71882fg.c
+++ b/drivers/hwmon/f71882fg.c
@@@ -2455,7 -2442,7 +2455,11 @@@ static int f71882fg_probe(struct platfo
  		case f71869a:
  			/* These always have signed auto point temps */
  			data->auto_point_temp_signed = 1;
++<<<<<<< HEAD
 +			/* Fall through to select correct fan/pwm reg bank! */
++=======
+ 			fallthrough;	/* to select correct fan/pwm reg bank! */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case f71889fg:
  		case f71889ed:
  		case f71889a:
diff --cc drivers/hwmon/ina3221.c
index e6b49500c52a,81e155692aba..000000000000
--- a/drivers/hwmon/ina3221.c
+++ b/drivers/hwmon/ina3221.c
@@@ -113,78 -238,214 +113,121 @@@ static int ina3221_read_value(struct in
  	return 0;
  }
  
 -static const u8 ina3221_in_reg[] = {
 -	INA3221_BUS1,
 -	INA3221_BUS2,
 -	INA3221_BUS3,
 -	INA3221_SHUNT1,
 -	INA3221_SHUNT2,
 -	INA3221_SHUNT3,
 -	INA3221_SHUNT_SUM,
 -};
 -
 -static int ina3221_read_chip(struct device *dev, u32 attr, long *val)
 +static ssize_t ina3221_show_bus_voltage(struct device *dev,
 +					struct device_attribute *attr,
 +					char *buf)
  {
 +	struct sensor_device_attribute *sd_attr = to_sensor_dev_attr(attr);
  	struct ina3221_data *ina = dev_get_drvdata(dev);
 -	int regval;
 +	unsigned int reg = sd_attr->index;
 +	int val, voltage_mv, ret;
  
 -	switch (attr) {
 -	case hwmon_chip_samples:
 -		regval = INA3221_CONFIG_AVG(ina->reg_config);
 -		*val = ina3221_avg_samples[regval];
 -		return 0;
 -	case hwmon_chip_update_interval:
 -		/* Return in msec */
 -		*val = ina3221_reg_to_interval_us(ina->reg_config);
 -		*val = DIV_ROUND_CLOSEST(*val, 1000);
 -		return 0;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 +	ret = ina3221_read_value(ina, reg, &val);
 +	if (ret)
 +		return ret;
 +
 +	voltage_mv = val * 8;
 +
 +	return snprintf(buf, PAGE_SIZE, "%d\n", voltage_mv);
  }
  
 -static int ina3221_read_in(struct device *dev, u32 attr, int channel, long *val)
 +static ssize_t ina3221_show_shunt_voltage(struct device *dev,
 +					  struct device_attribute *attr,
 +					  char *buf)
  {
 -	const bool is_shunt = channel > INA3221_CHANNEL3;
 +	struct sensor_device_attribute *sd_attr = to_sensor_dev_attr(attr);
  	struct ina3221_data *ina = dev_get_drvdata(dev);
 -	u8 reg = ina3221_in_reg[channel];
 -	int regval, ret;
 -
 -	/*
 -	 * Translate shunt channel index to sensor channel index except
 -	 * the 7th channel (6 since being 0-aligned) is for summation.
 -	 */
 -	if (channel != 6)
 -		channel %= INA3221_NUM_CHANNELS;
 -
 -	switch (attr) {
 -	case hwmon_in_input:
 -		if (!ina3221_is_enabled(ina, channel))
 -			return -ENODATA;
 +	unsigned int reg = sd_attr->index;
 +	int val, voltage_uv, ret;
  
 -		/* Write CONFIG register to trigger a single-shot measurement */
 -		if (ina->single_shot)
 -			regmap_write(ina->regmap, INA3221_CONFIG,
 -				     ina->reg_config);
 -
 -		ret = ina3221_wait_for_data(ina);
 -		if (ret)
 -			return ret;
 -
 -		ret = ina3221_read_value(ina, reg, &regval);
 -		if (ret)
 -			return ret;
 +	ret = ina3221_read_value(ina, reg, &val);
 +	if (ret)
 +		return ret;
 +	voltage_uv = val * 40;
  
 -		/*
 -		 * Scale of shunt voltage (uV): LSB is 40uV
 -		 * Scale of bus voltage (mV): LSB is 8mV
 -		 */
 -		*val = regval * (is_shunt ? 40 : 8);
 -		return 0;
 -	case hwmon_in_enable:
 -		*val = ina3221_is_enabled(ina, channel);
 -		return 0;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 +	return snprintf(buf, PAGE_SIZE, "%d\n", voltage_uv);
  }
  
 -static const u8 ina3221_curr_reg[][INA3221_NUM_CHANNELS + 1] = {
 -	[hwmon_curr_input] = { INA3221_SHUNT1, INA3221_SHUNT2,
 -			       INA3221_SHUNT3, INA3221_SHUNT_SUM },
 -	[hwmon_curr_max] = { INA3221_WARN1, INA3221_WARN2, INA3221_WARN3, 0 },
 -	[hwmon_curr_crit] = { INA3221_CRIT1, INA3221_CRIT2,
 -			      INA3221_CRIT3, INA3221_CRIT_SUM },
 -	[hwmon_curr_max_alarm] = { F_WF1, F_WF2, F_WF3, 0 },
 -	[hwmon_curr_crit_alarm] = { F_CF1, F_CF2, F_CF3, F_SF },
 -};
 -
 -static int ina3221_read_curr(struct device *dev, u32 attr,
 -			     int channel, long *val)
 +static ssize_t ina3221_show_current(struct device *dev,
 +				    struct device_attribute *attr, char *buf)
  {
 +	struct sensor_device_attribute *sd_attr = to_sensor_dev_attr(attr);
  	struct ina3221_data *ina = dev_get_drvdata(dev);
 -	struct ina3221_input *input = ina->inputs;
 -	u8 reg = ina3221_curr_reg[attr][channel];
 -	int resistance_uo, voltage_nv;
 -	int regval, ret;
 -
 -	if (channel > INA3221_CHANNEL3)
 -		resistance_uo = ina->summation_shunt_resistor;
 -	else
 -		resistance_uo = input[channel].shunt_resistor;
 -
 -	switch (attr) {
 -	case hwmon_curr_input:
 -		if (!ina3221_is_enabled(ina, channel))
 -			return -ENODATA;
 +	unsigned int reg = sd_attr->index;
 +	unsigned int channel = register_channel[reg];
 +	int resistance_uo = ina->shunt_resistors[channel];
 +	int val, current_ma, voltage_nv, ret;
  
 +	ret = ina3221_read_value(ina, reg, &val);
 +	if (ret)
 +		return ret;
 +	voltage_nv = val * 40000;
 +
 +	current_ma = DIV_ROUND_CLOSEST(voltage_nv, resistance_uo);
 +
++<<<<<<< HEAD
 +	return snprintf(buf, PAGE_SIZE, "%d\n", current_ma);
++=======
+ 		/* Write CONFIG register to trigger a single-shot measurement */
+ 		if (ina->single_shot)
+ 			regmap_write(ina->regmap, INA3221_CONFIG,
+ 				     ina->reg_config);
+ 
+ 		ret = ina3221_wait_for_data(ina);
+ 		if (ret)
+ 			return ret;
+ 
+ 		fallthrough;
+ 	case hwmon_curr_crit:
+ 	case hwmon_curr_max:
+ 		if (!resistance_uo)
+ 			return -ENODATA;
+ 
+ 		ret = ina3221_read_value(ina, reg, &regval);
+ 		if (ret)
+ 			return ret;
+ 
+ 		/* Scale of shunt voltage: LSB is 40uV (40000nV) */
+ 		voltage_nv = regval * 40000;
+ 		/* Return current in mA */
+ 		*val = DIV_ROUND_CLOSEST(voltage_nv, resistance_uo);
+ 		return 0;
+ 	case hwmon_curr_crit_alarm:
+ 	case hwmon_curr_max_alarm:
+ 		/* No actual register read if channel is disabled */
+ 		if (!ina3221_is_enabled(ina, channel)) {
+ 			/* Return 0 for alert flags */
+ 			*val = 0;
+ 			return 0;
+ 		}
+ 		ret = regmap_field_read(ina->fields[reg], &regval);
+ 		if (ret)
+ 			return ret;
+ 		*val = regval;
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  }
  
 -static int ina3221_write_chip(struct device *dev, u32 attr, long val)
 -{
 -	struct ina3221_data *ina = dev_get_drvdata(dev);
 -	int ret, idx;
 -	u32 tmp;
 -
 -	switch (attr) {
 -	case hwmon_chip_samples:
 -		idx = find_closest(val, ina3221_avg_samples,
 -				   ARRAY_SIZE(ina3221_avg_samples));
 -
 -		tmp = (ina->reg_config & ~INA3221_CONFIG_AVG_MASK) |
 -		      (idx << INA3221_CONFIG_AVG_SHIFT);
 -		ret = regmap_write(ina->regmap, INA3221_CONFIG, tmp);
 -		if (ret)
 -			return ret;
 -
 -		/* Update reg_config accordingly */
 -		ina->reg_config = tmp;
 -		return 0;
 -	case hwmon_chip_update_interval:
 -		tmp = ina3221_interval_ms_to_conv_time(ina->reg_config, val);
 -		idx = find_closest(tmp, ina3221_conv_time,
 -				   ARRAY_SIZE(ina3221_conv_time));
 -
 -		/* Update Bus and Shunt voltage conversion times */
 -		tmp = INA3221_CONFIG_VBUS_CT_MASK | INA3221_CONFIG_VSH_CT_MASK;
 -		tmp = (ina->reg_config & ~tmp) |
 -		      (idx << INA3221_CONFIG_VBUS_CT_SHIFT) |
 -		      (idx << INA3221_CONFIG_VSH_CT_SHIFT);
 -		ret = regmap_write(ina->regmap, INA3221_CONFIG, tmp);
 -		if (ret)
 -			return ret;
 -
 -		/* Update reg_config accordingly */
 -		ina->reg_config = tmp;
 -		return 0;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -}
 -
 -static int ina3221_write_curr(struct device *dev, u32 attr,
 -			      int channel, long val)
 +static ssize_t ina3221_set_current(struct device *dev,
 +				   struct device_attribute *attr,
 +				   const char *buf, size_t count)
  {
 +	struct sensor_device_attribute *sd_attr = to_sensor_dev_attr(attr);
  	struct ina3221_data *ina = dev_get_drvdata(dev);
 -	struct ina3221_input *input = ina->inputs;
 -	u8 reg = ina3221_curr_reg[attr][channel];
 -	int resistance_uo, current_ma, voltage_uv;
 -	int regval;
 -
 -	if (channel > INA3221_CHANNEL3)
 -		resistance_uo = ina->summation_shunt_resistor;
 -	else
 -		resistance_uo = input[channel].shunt_resistor;
 +	unsigned int reg = sd_attr->index;
 +	unsigned int channel = register_channel[reg];
 +	int resistance_uo = ina->shunt_resistors[channel];
 +	int val, current_ma, voltage_uv, ret;
  
 -	if (!resistance_uo)
 -		return -EOPNOTSUPP;
 +	ret = kstrtoint(buf, 0, &current_ma);
 +	if (ret)
 +		return ret;
  
  	/* clamp current */
 -	current_ma = clamp_val(val,
 +	current_ma = clamp_val(current_ma,
  			       INT_MIN / resistance_uo,
  			       INT_MAX / resistance_uo);
  
diff --cc drivers/hwmon/nct6775.c
index b89e8379d898,5bd15622a85f..000000000000
--- a/drivers/hwmon/nct6775.c
+++ b/drivers/hwmon/nct6775.c
@@@ -2542,7 -2669,7 +2542,11 @@@ static void pwm_update_registers(struc
  	case thermal_cruise:
  		nct6775_write_value(data, data->REG_TARGET[nr],
  				    data->target_temp[nr]);
++<<<<<<< HEAD
 +		/* intentional */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		reg = nct6775_read_value(data, data->REG_FAN_MODE[nr]);
  		reg = (reg & ~data->tolerance_mask) |
diff --cc drivers/hwtracing/coresight/coresight-etm4x.c
index 5717bc0c0441,96425e818fc2..000000000000
--- a/drivers/hwtracing/coresight/coresight-etm4x.c
+++ b/drivers/hwtracing/coresight/coresight-etm4x.c
@@@ -948,6 -1131,325 +948,328 @@@ static void etm4_init_trace_id(struct e
  	drvdata->trcid = coresight_get_trace_id(drvdata->cpu);
  }
  
++<<<<<<< HEAD
++=======
+ static int etm4_cpu_save(struct etmv4_drvdata *drvdata)
+ {
+ 	int i, ret = 0;
+ 	struct etmv4_save_state *state;
+ 	struct device *etm_dev = &drvdata->csdev->dev;
+ 
+ 	/*
+ 	 * As recommended by 3.4.1 ("The procedure when powering down the PE")
+ 	 * of ARM IHI 0064D
+ 	 */
+ 	dsb(sy);
+ 	isb();
+ 
+ 	CS_UNLOCK(drvdata->base);
+ 
+ 	/* Lock the OS lock to disable trace and external debugger access */
+ 	etm4_os_lock(drvdata);
+ 
+ 	/* wait for TRCSTATR.PMSTABLE to go up */
+ 	if (coresight_timeout(drvdata->base, TRCSTATR,
+ 			      TRCSTATR_PMSTABLE_BIT, 1)) {
+ 		dev_err(etm_dev,
+ 			"timeout while waiting for PM Stable Status\n");
+ 		etm4_os_unlock(drvdata);
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	state = drvdata->save_state;
+ 
+ 	state->trcprgctlr = readl(drvdata->base + TRCPRGCTLR);
+ 	state->trcprocselr = readl(drvdata->base + TRCPROCSELR);
+ 	state->trcconfigr = readl(drvdata->base + TRCCONFIGR);
+ 	state->trcauxctlr = readl(drvdata->base + TRCAUXCTLR);
+ 	state->trceventctl0r = readl(drvdata->base + TRCEVENTCTL0R);
+ 	state->trceventctl1r = readl(drvdata->base + TRCEVENTCTL1R);
+ 	state->trcstallctlr = readl(drvdata->base + TRCSTALLCTLR);
+ 	state->trctsctlr = readl(drvdata->base + TRCTSCTLR);
+ 	state->trcsyncpr = readl(drvdata->base + TRCSYNCPR);
+ 	state->trcccctlr = readl(drvdata->base + TRCCCCTLR);
+ 	state->trcbbctlr = readl(drvdata->base + TRCBBCTLR);
+ 	state->trctraceidr = readl(drvdata->base + TRCTRACEIDR);
+ 	state->trcqctlr = readl(drvdata->base + TRCQCTLR);
+ 
+ 	state->trcvictlr = readl(drvdata->base + TRCVICTLR);
+ 	state->trcviiectlr = readl(drvdata->base + TRCVIIECTLR);
+ 	state->trcvissctlr = readl(drvdata->base + TRCVISSCTLR);
+ 	state->trcvipcssctlr = readl(drvdata->base + TRCVIPCSSCTLR);
+ 	state->trcvdctlr = readl(drvdata->base + TRCVDCTLR);
+ 	state->trcvdsacctlr = readl(drvdata->base + TRCVDSACCTLR);
+ 	state->trcvdarcctlr = readl(drvdata->base + TRCVDARCCTLR);
+ 
+ 	for (i = 0; i < drvdata->nrseqstate; i++)
+ 		state->trcseqevr[i] = readl(drvdata->base + TRCSEQEVRn(i));
+ 
+ 	state->trcseqrstevr = readl(drvdata->base + TRCSEQRSTEVR);
+ 	state->trcseqstr = readl(drvdata->base + TRCSEQSTR);
+ 	state->trcextinselr = readl(drvdata->base + TRCEXTINSELR);
+ 
+ 	for (i = 0; i < drvdata->nr_cntr; i++) {
+ 		state->trccntrldvr[i] = readl(drvdata->base + TRCCNTRLDVRn(i));
+ 		state->trccntctlr[i] = readl(drvdata->base + TRCCNTCTLRn(i));
+ 		state->trccntvr[i] = readl(drvdata->base + TRCCNTVRn(i));
+ 	}
+ 
+ 	for (i = 0; i < drvdata->nr_resource * 2; i++)
+ 		state->trcrsctlr[i] = readl(drvdata->base + TRCRSCTLRn(i));
+ 
+ 	for (i = 0; i < drvdata->nr_ss_cmp; i++) {
+ 		state->trcssccr[i] = readl(drvdata->base + TRCSSCCRn(i));
+ 		state->trcsscsr[i] = readl(drvdata->base + TRCSSCSRn(i));
+ 		state->trcsspcicr[i] = readl(drvdata->base + TRCSSPCICRn(i));
+ 	}
+ 
+ 	for (i = 0; i < drvdata->nr_addr_cmp * 2; i++) {
+ 		state->trcacvr[i] = readq(drvdata->base + TRCACVRn(i));
+ 		state->trcacatr[i] = readq(drvdata->base + TRCACATRn(i));
+ 	}
+ 
+ 	/*
+ 	 * Data trace stream is architecturally prohibited for A profile cores
+ 	 * so we don't save (or later restore) trcdvcvr and trcdvcmr - As per
+ 	 * section 1.3.4 ("Possible functional configurations of an ETMv4 trace
+ 	 * unit") of ARM IHI 0064D.
+ 	 */
+ 
+ 	for (i = 0; i < drvdata->numcidc; i++)
+ 		state->trccidcvr[i] = readq(drvdata->base + TRCCIDCVRn(i));
+ 
+ 	for (i = 0; i < drvdata->numvmidc; i++)
+ 		state->trcvmidcvr[i] = readq(drvdata->base + TRCVMIDCVRn(i));
+ 
+ 	state->trccidcctlr0 = readl(drvdata->base + TRCCIDCCTLR0);
+ 	state->trccidcctlr1 = readl(drvdata->base + TRCCIDCCTLR1);
+ 
+ 	state->trcvmidcctlr0 = readl(drvdata->base + TRCVMIDCCTLR0);
+ 	state->trcvmidcctlr0 = readl(drvdata->base + TRCVMIDCCTLR1);
+ 
+ 	state->trcclaimset = readl(drvdata->base + TRCCLAIMCLR);
+ 
+ 	state->trcpdcr = readl(drvdata->base + TRCPDCR);
+ 
+ 	/* wait for TRCSTATR.IDLE to go up */
+ 	if (coresight_timeout(drvdata->base, TRCSTATR, TRCSTATR_IDLE_BIT, 1)) {
+ 		dev_err(etm_dev,
+ 			"timeout while waiting for Idle Trace Status\n");
+ 		etm4_os_unlock(drvdata);
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	drvdata->state_needs_restore = true;
+ 
+ 	/*
+ 	 * Power can be removed from the trace unit now. We do this to
+ 	 * potentially save power on systems that respect the TRCPDCR_PU
+ 	 * despite requesting software to save/restore state.
+ 	 */
+ 	writel_relaxed((state->trcpdcr & ~TRCPDCR_PU),
+ 			drvdata->base + TRCPDCR);
+ 
+ out:
+ 	CS_LOCK(drvdata->base);
+ 	return ret;
+ }
+ 
+ static void etm4_cpu_restore(struct etmv4_drvdata *drvdata)
+ {
+ 	int i;
+ 	struct etmv4_save_state *state = drvdata->save_state;
+ 
+ 	CS_UNLOCK(drvdata->base);
+ 
+ 	writel_relaxed(state->trcclaimset, drvdata->base + TRCCLAIMSET);
+ 
+ 	writel_relaxed(state->trcprgctlr, drvdata->base + TRCPRGCTLR);
+ 	writel_relaxed(state->trcprocselr, drvdata->base + TRCPROCSELR);
+ 	writel_relaxed(state->trcconfigr, drvdata->base + TRCCONFIGR);
+ 	writel_relaxed(state->trcauxctlr, drvdata->base + TRCAUXCTLR);
+ 	writel_relaxed(state->trceventctl0r, drvdata->base + TRCEVENTCTL0R);
+ 	writel_relaxed(state->trceventctl1r, drvdata->base + TRCEVENTCTL1R);
+ 	writel_relaxed(state->trcstallctlr, drvdata->base + TRCSTALLCTLR);
+ 	writel_relaxed(state->trctsctlr, drvdata->base + TRCTSCTLR);
+ 	writel_relaxed(state->trcsyncpr, drvdata->base + TRCSYNCPR);
+ 	writel_relaxed(state->trcccctlr, drvdata->base + TRCCCCTLR);
+ 	writel_relaxed(state->trcbbctlr, drvdata->base + TRCBBCTLR);
+ 	writel_relaxed(state->trctraceidr, drvdata->base + TRCTRACEIDR);
+ 	writel_relaxed(state->trcqctlr, drvdata->base + TRCQCTLR);
+ 
+ 	writel_relaxed(state->trcvictlr, drvdata->base + TRCVICTLR);
+ 	writel_relaxed(state->trcviiectlr, drvdata->base + TRCVIIECTLR);
+ 	writel_relaxed(state->trcvissctlr, drvdata->base + TRCVISSCTLR);
+ 	writel_relaxed(state->trcvipcssctlr, drvdata->base + TRCVIPCSSCTLR);
+ 	writel_relaxed(state->trcvdctlr, drvdata->base + TRCVDCTLR);
+ 	writel_relaxed(state->trcvdsacctlr, drvdata->base + TRCVDSACCTLR);
+ 	writel_relaxed(state->trcvdarcctlr, drvdata->base + TRCVDARCCTLR);
+ 
+ 	for (i = 0; i < drvdata->nrseqstate; i++)
+ 		writel_relaxed(state->trcseqevr[i],
+ 			       drvdata->base + TRCSEQEVRn(i));
+ 
+ 	writel_relaxed(state->trcseqrstevr, drvdata->base + TRCSEQRSTEVR);
+ 	writel_relaxed(state->trcseqstr, drvdata->base + TRCSEQSTR);
+ 	writel_relaxed(state->trcextinselr, drvdata->base + TRCEXTINSELR);
+ 
+ 	for (i = 0; i < drvdata->nr_cntr; i++) {
+ 		writel_relaxed(state->trccntrldvr[i],
+ 			       drvdata->base + TRCCNTRLDVRn(i));
+ 		writel_relaxed(state->trccntctlr[i],
+ 			       drvdata->base + TRCCNTCTLRn(i));
+ 		writel_relaxed(state->trccntvr[i],
+ 			       drvdata->base + TRCCNTVRn(i));
+ 	}
+ 
+ 	for (i = 0; i < drvdata->nr_resource * 2; i++)
+ 		writel_relaxed(state->trcrsctlr[i],
+ 			       drvdata->base + TRCRSCTLRn(i));
+ 
+ 	for (i = 0; i < drvdata->nr_ss_cmp; i++) {
+ 		writel_relaxed(state->trcssccr[i],
+ 			       drvdata->base + TRCSSCCRn(i));
+ 		writel_relaxed(state->trcsscsr[i],
+ 			       drvdata->base + TRCSSCSRn(i));
+ 		writel_relaxed(state->trcsspcicr[i],
+ 			       drvdata->base + TRCSSPCICRn(i));
+ 	}
+ 
+ 	for (i = 0; i < drvdata->nr_addr_cmp * 2; i++) {
+ 		writeq_relaxed(state->trcacvr[i],
+ 			       drvdata->base + TRCACVRn(i));
+ 		writeq_relaxed(state->trcacatr[i],
+ 			       drvdata->base + TRCACATRn(i));
+ 	}
+ 
+ 	for (i = 0; i < drvdata->numcidc; i++)
+ 		writeq_relaxed(state->trccidcvr[i],
+ 			       drvdata->base + TRCCIDCVRn(i));
+ 
+ 	for (i = 0; i < drvdata->numvmidc; i++)
+ 		writeq_relaxed(state->trcvmidcvr[i],
+ 			       drvdata->base + TRCVMIDCVRn(i));
+ 
+ 	writel_relaxed(state->trccidcctlr0, drvdata->base + TRCCIDCCTLR0);
+ 	writel_relaxed(state->trccidcctlr1, drvdata->base + TRCCIDCCTLR1);
+ 
+ 	writel_relaxed(state->trcvmidcctlr0, drvdata->base + TRCVMIDCCTLR0);
+ 	writel_relaxed(state->trcvmidcctlr0, drvdata->base + TRCVMIDCCTLR1);
+ 
+ 	writel_relaxed(state->trcclaimset, drvdata->base + TRCCLAIMSET);
+ 
+ 	writel_relaxed(state->trcpdcr, drvdata->base + TRCPDCR);
+ 
+ 	drvdata->state_needs_restore = false;
+ 
+ 	/*
+ 	 * As recommended by section 4.3.7 ("Synchronization when using the
+ 	 * memory-mapped interface") of ARM IHI 0064D
+ 	 */
+ 	dsb(sy);
+ 	isb();
+ 
+ 	/* Unlock the OS lock to re-enable trace and external debug access */
+ 	etm4_os_unlock(drvdata);
+ 	CS_LOCK(drvdata->base);
+ }
+ 
+ static int etm4_cpu_pm_notify(struct notifier_block *nb, unsigned long cmd,
+ 			      void *v)
+ {
+ 	struct etmv4_drvdata *drvdata;
+ 	unsigned int cpu = smp_processor_id();
+ 
+ 	if (!etmdrvdata[cpu])
+ 		return NOTIFY_OK;
+ 
+ 	drvdata = etmdrvdata[cpu];
+ 
+ 	if (!drvdata->save_state)
+ 		return NOTIFY_OK;
+ 
+ 	if (WARN_ON_ONCE(drvdata->cpu != cpu))
+ 		return NOTIFY_BAD;
+ 
+ 	switch (cmd) {
+ 	case CPU_PM_ENTER:
+ 		/* save the state if self-hosted coresight is in use */
+ 		if (local_read(&drvdata->mode))
+ 			if (etm4_cpu_save(drvdata))
+ 				return NOTIFY_BAD;
+ 		break;
+ 	case CPU_PM_EXIT:
+ 	case CPU_PM_ENTER_FAILED:
+ 		if (drvdata->state_needs_restore)
+ 			etm4_cpu_restore(drvdata);
+ 		break;
+ 	default:
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static struct notifier_block etm4_cpu_pm_nb = {
+ 	.notifier_call = etm4_cpu_pm_notify,
+ };
+ 
+ /* Setup PM. Called with cpus locked. Deals with error conditions and counts */
+ static int etm4_pm_setup_cpuslocked(void)
+ {
+ 	int ret;
+ 
+ 	if (etm4_count++)
+ 		return 0;
+ 
+ 	ret = cpu_pm_register_notifier(&etm4_cpu_pm_nb);
+ 	if (ret)
+ 		goto reduce_count;
+ 
+ 	ret = cpuhp_setup_state_nocalls_cpuslocked(CPUHP_AP_ARM_CORESIGHT_STARTING,
+ 						   "arm/coresight4:starting",
+ 						   etm4_starting_cpu, etm4_dying_cpu);
+ 
+ 	if (ret)
+ 		goto unregister_notifier;
+ 
+ 	ret = cpuhp_setup_state_nocalls_cpuslocked(CPUHP_AP_ONLINE_DYN,
+ 						   "arm/coresight4:online",
+ 						   etm4_online_cpu, NULL);
+ 
+ 	/* HP dyn state ID returned in ret on success */
+ 	if (ret > 0) {
+ 		hp_online = ret;
+ 		return 0;
+ 	}
+ 
+ 	/* failed dyn state - remove others */
+ 	cpuhp_remove_state_nocalls_cpuslocked(CPUHP_AP_ARM_CORESIGHT_STARTING);
+ 
+ unregister_notifier:
+ 	cpu_pm_unregister_notifier(&etm4_cpu_pm_nb);
+ 
+ reduce_count:
+ 	--etm4_count;
+ 	return ret;
+ }
+ 
+ static void etm4_pm_clear(void)
+ {
+ 	if (--etm4_count != 0)
+ 		return;
+ 
+ 	cpu_pm_unregister_notifier(&etm4_cpu_pm_nb);
+ 	cpuhp_remove_state_nocalls(CPUHP_AP_ARM_CORESIGHT_STARTING);
+ 	if (hp_online) {
+ 		cpuhp_remove_state_nocalls(hp_online);
+ 		hp_online = 0;
+ 	}
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static int etm4_probe(struct amba_device *adev, const struct amba_id *id)
  {
  	int ret;
diff --cc drivers/hwtracing/coresight/coresight-tmc.c
index 456f122df74f,9ca3aaafcfbc..000000000000
--- a/drivers/hwtracing/coresight/coresight-tmc.c
+++ b/drivers/hwtracing/coresight/coresight-tmc.c
@@@ -63,6 -70,32 +63,35 @@@ void tmc_disable_hw(struct tmc_drvdata 
  	writel_relaxed(0x0, drvdata->base + TMC_CTL);
  }
  
++<<<<<<< HEAD
++=======
+ u32 tmc_get_memwidth_mask(struct tmc_drvdata *drvdata)
+ {
+ 	u32 mask = 0;
+ 
+ 	/*
+ 	 * When moving RRP or an offset address forward, the new values must
+ 	 * be byte-address aligned to the width of the trace memory databus
+ 	 * _and_ to a frame boundary (16 byte), whichever is the biggest. For
+ 	 * example, for 32-bit, 64-bit and 128-bit wide trace memory, the four
+ 	 * LSBs must be 0s. For 256-bit wide trace memory, the five LSBs must
+ 	 * be 0s.
+ 	 */
+ 	switch (drvdata->memwidth) {
+ 	case TMC_MEM_INTF_WIDTH_32BITS:
+ 	case TMC_MEM_INTF_WIDTH_64BITS:
+ 	case TMC_MEM_INTF_WIDTH_128BITS:
+ 		mask = GENMASK(31, 4);
+ 		break;
+ 	case TMC_MEM_INTF_WIDTH_256BITS:
+ 		mask = GENMASK(31, 5);
+ 		break;
+ 	}
+ 
+ 	return mask;
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static int tmc_read_prepare(struct tmc_drvdata *drvdata)
  {
  	int ret = 0;
diff --cc drivers/ide/hpt366.c
index e52c58c29d9a,50c9a41467c8..000000000000
--- a/drivers/ide/hpt366.c
+++ b/drivers/ide/hpt366.c
@@@ -574,13 -575,14 +574,21 @@@ static u8 hpt3xx_udma_filter(ide_drive_
  		if (!HPT370_ALLOW_ATA100_5 ||
  		    check_in_drive_list(drive, bad_ata100_5))
  			return ATA_UDMA4;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case HPT372 :
  	case HPT372A:
  	case HPT372N:
  	case HPT374 :
  		if (ata_id_is_sata(drive->id))
  			mask &= ~0x0e;
++<<<<<<< HEAD
 +		/* Fall thru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return mask;
  	}
@@@ -600,7 -602,7 +608,11 @@@ static u8 hpt3xx_mdma_filter(ide_drive_
  	case HPT374 :
  		if (ata_id_is_sata(drive->id))
  			return 0x00;
++<<<<<<< HEAD
 +		/* Fall thru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return 0x07;
  	}
diff --cc drivers/ide/ide-floppy.c
index 5c54cb030199,af7503b47dbe..000000000000
--- a/drivers/ide/ide-floppy.c
+++ b/drivers/ide/ide-floppy.c
@@@ -427,6 -428,7 +427,10 @@@ static int ide_floppy_get_capacity(ide_
  				 * (maintains previous driver behaviour)
  				 */
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case CAPACITY_CURRENT:
  			/* Normal Zip/LS-120 disks */
  			if (memcmp(cap_desc, &floppy->cap_desc, 8))
diff --cc drivers/ide/ide-probe.c
index 00714f846b74,1ddc45a04418..000000000000
--- a/drivers/ide/ide-probe.c
+++ b/drivers/ide/ide-probe.c
@@@ -142,6 -143,7 +142,10 @@@ static void ide_classify_atapi_dev(ide_
  		}
  		/* Early cdrom models used zero */
  		type = ide_cdrom;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ide_cdrom:
  		drive->dev_flags |= IDE_DFLAG_REMOVABLE;
  #ifdef CONFIG_PPC
diff --cc drivers/ide/ide-taskfile.c
index 3a49545daaa4,d016cbe68cba..000000000000
--- a/drivers/ide/ide-taskfile.c
+++ b/drivers/ide/ide-taskfile.c
@@@ -128,7 -129,7 +128,11 @@@ ide_startstop_t do_rw_taskfile(ide_driv
  			return pre_task_out_intr(drive, cmd);
  		}
  		handler = task_pio_intr;
++<<<<<<< HEAD
 +		/* fall-through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ATA_PROT_NODATA:
  		if (handler == NULL)
  			handler = task_no_data_intr;
@@@ -140,6 -141,7 +144,10 @@@
  		hwif->expiry = dma_ops->dma_timer_expiry;
  		ide_execute_command(drive, cmd, ide_dma_intr, 2 * WAIT_CMD);
  		dma_ops->dma_start(drive);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return ide_started;
  	}
diff --cc drivers/ide/sis5513.c
index c3062b53056f,1a700bef6c56..000000000000
--- a/drivers/ide/sis5513.c
+++ b/drivers/ide/sis5513.c
@@@ -494,6 -494,7 +494,10 @@@ static int init_chipset_sis5513(struct 
  		pci_read_config_byte(dev, 0x09, &reg);
  		if ((reg & 0x0f) != 0x00)
  			pci_write_config_byte(dev, 0x09, reg&0xf0);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ATA_16:
  		/* force per drive recovery and active timings
  		   needed on ATA_33 and below chips */
diff --cc drivers/iio/accel/mma8452.c
index c149c9c360fc,4e6e70250048..000000000000
--- a/drivers/iio/accel/mma8452.c
+++ b/drivers/iio/accel/mma8452.c
@@@ -1547,8 -1580,10 +1547,12 @@@ static int mma8452_probe(struct i2c_cli
  	case FXLS8471_DEVICE_ID:
  		if (ret == data->chip_info->chip_id)
  			break;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
 -		ret = -ENODEV;
 -		goto disable_regulators;
 +		return -ENODEV;
  	}
  
  	dev_info(&client->dev, "registering %s accelerometer; ID 0x%x\n",
diff --cc drivers/iio/dac/dpot-dac.c
index aaa2103d7c2b,be61c3b01e8b..000000000000
--- a/drivers/iio/dac/dpot-dac.c
+++ b/drivers/iio/dac/dpot-dac.c
@@@ -81,7 -78,7 +81,11 @@@ static int dpot_dac_read_raw(struct iio
  			 */
  			*val2 = 1;
  			ret = IIO_VAL_FRACTIONAL;
++<<<<<<< HEAD
 +			/* ...and fall through. */
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case IIO_VAL_FRACTIONAL:
  			*val *= regulator_get_voltage(dac->vref) / 1000;
  			*val2 *= dac->max_ohms;
diff --cc drivers/iio/health/max30102.c
index 15ccadc74891,d9b2ed80882a..000000000000
--- a/drivers/iio/health/max30102.c
+++ b/drivers/iio/health/max30102.c
@@@ -282,9 -273,11 +282,17 @@@ static int max30102_read_measurement(st
  	switch (measurements) {
  	case 3:
  		MAX30102_COPY_DATA(2);
++<<<<<<< HEAD
 +	case 2: /* fall-through */
 +		MAX30102_COPY_DATA(1);
 +	case 1: /* fall-through */
++=======
+ 		fallthrough;
+ 	case 2:
+ 		MAX30102_COPY_DATA(1);
+ 		fallthrough;
+ 	case 1:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		MAX30102_COPY_DATA(0);
  		break;
  	default:
diff --cc drivers/iio/imu/adis.c
index ad6f91d06185,319b64b2fd88..000000000000
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@@ -81,9 -97,11 +81,17 @@@ int adis_write_reg(struct adis *adis, u
  		adis->tx[9] = (value >> 24) & 0xff;
  		adis->tx[6] = ADIS_WRITE_REG(reg + 2);
  		adis->tx[7] = (value >> 16) & 0xff;
++<<<<<<< HEAD
 +	case 2:
 +		adis->tx[4] = ADIS_WRITE_REG(reg + 1);
 +		adis->tx[5] = (value >> 8) & 0xff;
++=======
+ 		fallthrough;
+ 	case 2:
+ 		adis->tx[4] = ADIS_WRITE_REG(reg + 1);
+ 		adis->tx[5] = (value >> 8) & 0xff;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		adis->tx[2] = ADIS_WRITE_REG(reg);
  		adis->tx[3] = value & 0xff;
@@@ -167,6 -191,7 +175,10 @@@ int adis_read_reg(struct adis *adis, un
  		adis->tx[2] = ADIS_READ_REG(reg + 2);
  		adis->tx[3] = 0;
  		spi_message_add_tail(&xfers[1], &msg);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		adis->tx[4] = ADIS_READ_REG(reg);
  		adis->tx[5] = 0;
diff --cc drivers/iio/industrialio-core.c
index eee38cc07268,cdcd16f19500..000000000000
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@@ -585,16 -596,16 +585,16 @@@ static ssize_t __iio_format_value(char 
  
  	switch (type) {
  	case IIO_VAL_INT:
 -		return scnprintf(buf, len, "%d", vals[0]);
 +		return snprintf(buf, len, "%d", vals[0]);
  	case IIO_VAL_INT_PLUS_MICRO_DB:
  		scale_db = true;
- 		/* fall through */
+ 		fallthrough;
  	case IIO_VAL_INT_PLUS_MICRO:
  		if (vals[1] < 0)
 -			return scnprintf(buf, len, "-%d.%06u%s", abs(vals[0]),
 +			return snprintf(buf, len, "-%d.%06u%s", abs(vals[0]),
  					-vals[1], scale_db ? " dB" : "");
  		else
 -			return scnprintf(buf, len, "%d.%06u%s", vals[0], vals[1],
 +			return snprintf(buf, len, "%d.%06u%s", vals[0], vals[1],
  					scale_db ? " dB" : "");
  	case IIO_VAL_INT_PLUS_NANO:
  		if (vals[1] < 0)
@@@ -876,6 -916,9 +876,12 @@@ static ssize_t iio_write_channel_info(s
  		case IIO_VAL_INT:
  			fract_mult = 0;
  			break;
++<<<<<<< HEAD
++=======
+ 		case IIO_VAL_INT_PLUS_MICRO_DB:
+ 			scale_db = true;
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case IIO_VAL_INT_PLUS_MICRO:
  			fract_mult = 100000;
  			break;
diff --cc drivers/input/touchscreen/atmel_mxt_ts.c
index e13a5780713b,98f17fa3a892..000000000000
--- a/drivers/input/touchscreen/atmel_mxt_ts.c
+++ b/drivers/input/touchscreen/atmel_mxt_ts.c
@@@ -468,7 -477,7 +468,11 @@@ static int mxt_lookup_bootloader_addres
  			bootloader = appmode - 0x24;
  			break;
  		}
++<<<<<<< HEAD
 +		/* Fall through for normal case */
++=======
+ 		fallthrough;	/* for normal case */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0x4c:
  	case 0x4d:
  	case 0x5a:
diff --cc drivers/iommu/arm-smmu-v3.c
index d076622e2dd4,c192544e874b..000000000000
--- a/drivers/iommu/arm-smmu-v3.c
+++ b/drivers/iommu/arm-smmu-v3.c
@@@ -854,6 -901,9 +854,12 @@@ static int arm_smmu_cmdq_build_cmd(u64 
  		cmd[1] |= FIELD_PREP(CMDQ_PREFETCH_1_SIZE, ent->prefetch.size);
  		cmd[1] |= ent->prefetch.addr & CMDQ_PREFETCH_1_ADDR_MASK;
  		break;
++<<<<<<< HEAD:drivers/iommu/arm-smmu-v3.c
++=======
+ 	case CMDQ_OP_CFGI_CD:
+ 		cmd[0] |= FIELD_PREP(CMDQ_CFGI_0_SSID, ent->cfgi.ssid);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword):drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
  	case CMDQ_OP_CFGI_STE:
  		cmd[0] |= FIELD_PREP(CMDQ_CFGI_0_SID, ent->cfgi.sid);
  		cmd[1] |= FIELD_PREP(CMDQ_CFGI_1_LEAF, ent->cfgi.leaf);
diff --cc drivers/irqchip/irq-imx-gpcv2.c
index 4760307ab43f,7031ef44de4f..000000000000
--- a/drivers/irqchip/irq-imx-gpcv2.c
+++ b/drivers/irqchip/irq-imx-gpcv2.c
@@@ -236,8 -253,17 +236,22 @@@ static int __init imx_gpcv2_irqchip_ini
  
  	/* Initially mask all interrupts */
  	for (i = 0; i < IMR_NUM; i++) {
++<<<<<<< HEAD
 +		writel_relaxed(~0, cd->gpc_base + GPC_IMR1_CORE0 + i * 4);
 +		writel_relaxed(~0, cd->gpc_base + GPC_IMR1_CORE1 + i * 4);
++=======
+ 		void __iomem *reg = cd->gpc_base + i * 4;
+ 
+ 		switch (core_num) {
+ 		case 4:
+ 			writel_relaxed(~0, reg + GPC_IMR1_CORE2);
+ 			writel_relaxed(~0, reg + GPC_IMR1_CORE3);
+ 			fallthrough;
+ 		case 2:
+ 			writel_relaxed(~0, reg + GPC_IMR1_CORE0);
+ 			writel_relaxed(~0, reg + GPC_IMR1_CORE1);
+ 		}
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		cd->wakeup_sources[i] = ~0;
  	}
  
diff --cc drivers/isdn/hardware/mISDN/avmfritz.c
index ae2b2669af1b,f68569bfef7a..000000000000
--- a/drivers/isdn/hardware/mISDN/avmfritz.c
+++ b/drivers/isdn/hardware/mISDN/avmfritz.c
@@@ -361,6 -348,7 +361,10 @@@ modehdlc(struct bchannel *bch, int prot
  	switch (protocol) {
  	case -1: /* used for init */
  		bch->state = -1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ISDN_P_NONE:
  		if (bch->state == ISDN_P_NONE)
  			break;
diff --cc drivers/isdn/hardware/mISDN/hfcpci.c
index 34c93874af23,56bd2e9db6ed..000000000000
--- a/drivers/isdn/hardware/mISDN/hfcpci.c
+++ b/drivers/isdn/hardware/mISDN/hfcpci.c
@@@ -1296,6 -1280,7 +1296,10 @@@ mode_hfcpci(struct bchannel *bch, int b
  	case (-1): /* used for init */
  		bch->state = -1;
  		bch->nr = bc;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case (ISDN_P_NONE):
  		if (bch->state == ISDN_P_NONE)
  			return 0;
diff --cc drivers/isdn/hardware/mISDN/mISDNinfineon.c
index 1fc290659e94,a16c7a2a7f3d..000000000000
--- a/drivers/isdn/hardware/mISDN/mISDNinfineon.c
+++ b/drivers/isdn/hardware/mISDN/mISDNinfineon.c
@@@ -887,6 -875,7 +887,10 @@@ release_card(struct inf_hw *card) 
  				release_card(card->sc[i]);
  			card->sc[i] = NULL;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		pci_disable_device(card->pdev);
  		pci_set_drvdata(card->pdev, NULL);
diff --cc drivers/isdn/hardware/mISDN/mISDNisar.c
index b791688d0228,56943409b60d..000000000000
--- a/drivers/isdn/hardware/mISDN/mISDNisar.c
+++ b/drivers/isdn/hardware/mISDN/mISDNisar.c
@@@ -972,6 -957,7 +972,10 @@@ isar_pump_statev_fax(struct isar_ch *ch
  				break;
  			case PCTRL_CMD_FTM:
  				p1 = 2;
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case PCTRL_CMD_FTH:
  				send_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,
  					  PCTRL_CMD_SILON, 1, &p1);
@@@ -1177,6 -1163,7 +1181,10 @@@ setup_pump(struct isar_ch *ch) 
  			send_mbox(ch->is, dps | ISAR_HIS_PUMPCFG,
  				  PMOD_DTMF, 1, param);
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ISDN_P_B_MODEM_ASYNC:
  		ctrl = PMOD_DATAMODEM;
  		if (test_bit(FLG_ORIGIN, &ch->bch.Flags)) {
@@@ -1268,6 -1255,7 +1276,10 @@@ setup_iom2(struct isar_ch *ch) 
  	case ISDN_P_B_MODEM_ASYNC:
  	case ISDN_P_B_T30_FAX:
  		cmsb |= IOM_CTRL_RCV;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ISDN_P_B_L2DTMF:
  		if (test_bit(FLG_DTMFSEND, &ch->bch.Flags))
  			cmsb |= IOM_CTRL_RCV;
@@@ -1560,6 -1548,7 +1572,10 @@@ isar_l2l1(struct mISDNchannel *ch, stru
  				ich->is->name, hh->id);
  			ret = -EINVAL;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		pr_info("%s: %s unknown prim(%x,%x)\n",
  			ich->is->name, __func__, hh->prim, hh->id);
diff --cc drivers/isdn/mISDN/stack.c
index 422dced7c90a,c2f76f398613..000000000000
--- a/drivers/isdn/mISDN/stack.c
+++ b/drivers/isdn/mISDN/stack.c
@@@ -539,6 -528,7 +539,10 @@@ create_l2entity(struct mISDNdevice *dev
  		rq.protocol = ISDN_P_NT_S0;
  		if (dev->Dprotocols & (1 << ISDN_P_NT_E1))
  			rq.protocol = ISDN_P_NT_E1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ISDN_P_LAPD_TE:
  		ch->recv = mISDN_queue_message;
  		ch->peer = &dev->D.st->own;
diff --cc drivers/lightnvm/pblk-core.c
index ed9cc977c8b3,97c68731406b..000000000000
--- a/drivers/lightnvm/pblk-core.c
+++ b/drivers/lightnvm/pblk-core.c
@@@ -264,6 -301,7 +264,10 @@@ void pblk_free_rqd(struct pblk *pblk, s
  	switch (type) {
  	case PBLK_WRITE:
  		kfree(((struct pblk_c_ctx *)nvm_rq_to_pdu(rqd))->lun_bitmap);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case PBLK_WRITE_INT:
  		pool = &pblk->w_rq_pool;
  		break;
diff --cc drivers/macintosh/smu.c
index 3f0da2cc7a34,96684581a25d..000000000000
--- a/drivers/macintosh/smu.c
+++ b/drivers/macintosh/smu.c
@@@ -850,6 -852,7 +850,10 @@@ int smu_queue_i2c(struct smu_i2c_cmd *c
  		break;
  	case SMU_I2C_TRANSFER_COMBINED:
  		cmd->info.devaddr &= 0xfe;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SMU_I2C_TRANSFER_STDSUB:
  		if (cmd->info.sublen > 3)
  			return -EINVAL;
diff --cc drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
index abd4c788dffd,7607b516a7c4..000000000000
--- a/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
+++ b/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
@@@ -1218,6 -1281,27 +1218,30 @@@ static void gen_twopix(struct tpg_data 
  		buf[0][offset] = (g_u_s << 4) | b_v;
  		buf[0][offset + 1] = (alpha & 0xf0) | r_y_h;
  		break;
++<<<<<<< HEAD
++=======
+ 	case V4L2_PIX_FMT_RGBX444:
+ 		alpha = 0;
+ 		fallthrough;
+ 	case V4L2_PIX_FMT_RGBA444:
+ 		buf[0][offset] = (b_v << 4) | (alpha >> 4);
+ 		buf[0][offset + 1] = (r_y_h << 4) | g_u_s;
+ 		break;
+ 	case V4L2_PIX_FMT_XBGR444:
+ 		alpha = 0;
+ 		fallthrough;
+ 	case V4L2_PIX_FMT_ABGR444:
+ 		buf[0][offset] = (g_u_s << 4) | r_y_h;
+ 		buf[0][offset + 1] = (alpha & 0xf0) | b_v;
+ 		break;
+ 	case V4L2_PIX_FMT_BGRX444:
+ 		alpha = 0;
+ 		fallthrough;
+ 	case V4L2_PIX_FMT_BGRA444:
+ 		buf[0][offset] = (r_y_h << 4) | (alpha >> 4);
+ 		buf[0][offset + 1] = (b_v << 4) | g_u_s;
+ 		break;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case V4L2_PIX_FMT_RGB555:
  	case V4L2_PIX_FMT_XRGB555:
  		alpha = 0;
@@@ -1228,6 -1312,30 +1252,33 @@@
  		buf[0][offset + 1] = (alpha & 0x80) | (r_y_h << 2)
  						    | (g_u_s >> 3);
  		break;
++<<<<<<< HEAD
++=======
+ 	case V4L2_PIX_FMT_RGBX555:
+ 		alpha = 0;
+ 		fallthrough;
+ 	case V4L2_PIX_FMT_RGBA555:
+ 		buf[0][offset] = (g_u_s << 6) | (b_v << 1) |
+ 				 ((alpha & 0x80) >> 7);
+ 		buf[0][offset + 1] = (r_y_h << 3) | (g_u_s >> 2);
+ 		break;
+ 	case V4L2_PIX_FMT_XBGR555:
+ 		alpha = 0;
+ 		fallthrough;
+ 	case V4L2_PIX_FMT_ABGR555:
+ 		buf[0][offset] = (g_u_s << 5) | r_y_h;
+ 		buf[0][offset + 1] = (alpha & 0x80) | (b_v << 2)
+ 						    | (g_u_s >> 3);
+ 		break;
+ 	case V4L2_PIX_FMT_BGRX555:
+ 		alpha = 0;
+ 		fallthrough;
+ 	case V4L2_PIX_FMT_BGRA555:
+ 		buf[0][offset] = (g_u_s << 6) | (r_y_h << 1) |
+ 				 ((alpha & 0x80) >> 7);
+ 		buf[0][offset + 1] = (b_v << 3) | (g_u_s >> 2);
+ 		break;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case V4L2_PIX_FMT_RGB555X:
  	case V4L2_PIX_FMT_XRGB555X:
  		alpha = 0;
@@@ -1256,25 -1364,47 +1307,49 @@@
  	case V4L2_PIX_FMT_RGB32:
  	case V4L2_PIX_FMT_XRGB32:
  	case V4L2_PIX_FMT_HSV32:
 -	case V4L2_PIX_FMT_XYUV32:
  		alpha = 0;
- 		/* fall through */
+ 		fallthrough;
  	case V4L2_PIX_FMT_YUV32:
  	case V4L2_PIX_FMT_ARGB32:
 -	case V4L2_PIX_FMT_AYUV32:
  		buf[0][offset] = alpha;
  		buf[0][offset + 1] = r_y_h;
  		buf[0][offset + 2] = g_u_s;
  		buf[0][offset + 3] = b_v;
  		break;
++<<<<<<< HEAD
++=======
+ 	case V4L2_PIX_FMT_RGBX32:
+ 		alpha = 0;
+ 		fallthrough;
+ 	case V4L2_PIX_FMT_RGBA32:
+ 		buf[0][offset] = r_y_h;
+ 		buf[0][offset + 1] = g_u_s;
+ 		buf[0][offset + 2] = b_v;
+ 		buf[0][offset + 3] = alpha;
+ 		break;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case V4L2_PIX_FMT_BGR32:
  	case V4L2_PIX_FMT_XBGR32:
 -	case V4L2_PIX_FMT_VUYX32:
  		alpha = 0;
- 		/* fall through */
+ 		fallthrough;
  	case V4L2_PIX_FMT_ABGR32:
 -	case V4L2_PIX_FMT_VUYA32:
  		buf[0][offset] = b_v;
  		buf[0][offset + 1] = g_u_s;
  		buf[0][offset + 2] = r_y_h;
  		buf[0][offset + 3] = alpha;
  		break;
++<<<<<<< HEAD
++=======
+ 	case V4L2_PIX_FMT_BGRX32:
+ 		alpha = 0;
+ 		fallthrough;
+ 	case V4L2_PIX_FMT_BGRA32:
+ 		buf[0][offset] = alpha;
+ 		buf[0][offset + 1] = b_v;
+ 		buf[0][offset + 2] = g_u_s;
+ 		buf[0][offset + 3] = r_y_h;
+ 		break;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case V4L2_PIX_FMT_SBGGR8:
  		buf[0][offset] = odd ? g_u_s : b_v;
  		buf[1][offset] = odd ? r_y_h : g_u_s;
diff --cc drivers/media/dvb-frontends/drx39xyj/drxj.c
index 5706898e84cc,237b9d04c076..000000000000
--- a/drivers/media/dvb-frontends/drx39xyj/drxj.c
+++ b/drivers/media/dvb-frontends/drx39xyj/drxj.c
@@@ -2841,8 -2841,7 +2841,12 @@@ ctrl_set_cfg_mpeg_output(struct drx_dem
  			/* coef = 188/204                          */
  			max_bit_rate =
  			    (ext_attr->curr_symbol_rate / 8) * nr_bits * 188;
++<<<<<<< HEAD
 +			/* pass through as b/c Annex A/c need following settings */
 +			/* fall-through */
++=======
+ 			fallthrough;	/* as b/c Annex A/C need following settings */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case DRX_STANDARD_ITU_B:
  			rc = drxj_dap_write_reg16(dev_addr, FEC_OC_FCT_USAGE__A, FEC_OC_FCT_USAGE__PRE, 0);
  			if (rc != 0) {
@@@ -3556,8 -3555,8 +3560,13 @@@ static int ctrl_set_uio_cfg(struct drx_
  		if (!ext_attr->has_smatx)
  			return -EIO;
  		switch (uio_cfg->mode) {
++<<<<<<< HEAD
 +		case DRX_UIO_MODE_FIRMWARE_SMA:	/* falltrough */
 +		case DRX_UIO_MODE_FIRMWARE_SAW:	/* falltrough */
++=======
+ 		case DRX_UIO_MODE_FIRMWARE_SMA:
+ 		case DRX_UIO_MODE_FIRMWARE_SAW:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case DRX_UIO_MODE_READWRITE:
  			ext_attr->uio_sma_tx_mode = uio_cfg->mode;
  			break;
@@@ -3580,7 -3579,7 +3589,11 @@@
  		if (!ext_attr->has_smarx)
  			return -EIO;
  		switch (uio_cfg->mode) {
++<<<<<<< HEAD
 +		case DRX_UIO_MODE_FIRMWARE0:	/* falltrough */
++=======
+ 		case DRX_UIO_MODE_FIRMWARE0:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case DRX_UIO_MODE_READWRITE:
  			ext_attr->uio_sma_rx_mode = uio_cfg->mode;
  			break;
@@@ -3604,7 -3603,7 +3617,11 @@@
  		if (!ext_attr->has_gpio)
  			return -EIO;
  		switch (uio_cfg->mode) {
++<<<<<<< HEAD
 +		case DRX_UIO_MODE_FIRMWARE0:	/* falltrough */
++=======
+ 		case DRX_UIO_MODE_FIRMWARE0:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case DRX_UIO_MODE_READWRITE:
  			ext_attr->uio_gpio_mode = uio_cfg->mode;
  			break;
@@@ -3640,7 -3639,7 +3657,11 @@@
  			}
  			ext_attr->uio_irqn_mode = uio_cfg->mode;
  			break;
++<<<<<<< HEAD
 +		case DRX_UIO_MODE_FIRMWARE0:	/* falltrough */
++=======
+ 		case DRX_UIO_MODE_FIRMWARE0:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			return -EINVAL;
  			break;
diff --cc drivers/media/dvb-frontends/drxd_hard.c
index 3b7d31a22d82,45f982863904..000000000000
--- a/drivers/media/dvb-frontends/drxd_hard.c
+++ b/drivers/media/dvb-frontends/drxd_hard.c
@@@ -1970,8 -1966,7 +1970,12 @@@ static int DRX_Start(struct drxd_state 
  		switch (p->transmission_mode) {
  		default:	/* Not set, detect it automatically */
  			operationMode |= SC_RA_RAM_OP_AUTO_MODE__M;
++<<<<<<< HEAD
 +			/* try first guess DRX_FFTMODE_8K */
 +			/* fall through */
++=======
+ 			fallthrough;	/* try first guess DRX_FFTMODE_8K */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case TRANSMISSION_MODE_8K:
  			transmissionParams |= SC_RA_RAM_OP_PARAM_MODE_8K;
  			if (state->type_A) {
@@@ -2144,8 -2139,7 +2148,12 @@@
  		switch (p->modulation) {
  		default:
  			operationMode |= SC_RA_RAM_OP_AUTO_CONST__M;
++<<<<<<< HEAD
 +			/* try first guess DRX_CONSTELLATION_QAM64 */
 +			/* fall through */
++=======
+ 			fallthrough;	/* try first guess DRX_CONSTELLATION_QAM64 */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case QAM_64:
  			transmissionParams |= SC_RA_RAM_OP_PARAM_CONST_QAM64;
  			if (state->type_A) {
@@@ -2280,14 -2266,11 +2288,14 @@@
  			break;
  		default:
  			operationMode |= SC_RA_RAM_OP_AUTO_RATE__M;
- 			/* fall through */
+ 			fallthrough;
  		case FEC_2_3:
  			transmissionParams |= SC_RA_RAM_OP_PARAM_RATE_2_3;
 -			if (state->type_A)
 +			if (state->type_A) {
  				status = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C2_3, 0x0000);
 +				if (status < 0)
 +					break;
 +			}
  			break;
  		case FEC_3_4:
  			transmissionParams |= SC_RA_RAM_OP_PARAM_RATE_3_4;
diff --cc drivers/media/dvb-frontends/drxk_hard.c
index 29c36f95d624,32f9346deb3e..000000000000
--- a/drivers/media/dvb-frontends/drxk_hard.c
+++ b/drivers/media/dvb-frontends/drxk_hard.c
@@@ -3270,13 -3249,11 +3270,21 @@@ static int dvbt_sc_command(struct drxk_
  	case OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:
  	case OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:
  		status |= write16(state, OFDM_SC_RA_RAM_PARAM1__A, param1);
++<<<<<<< HEAD
 +		/* All commands using 1 parameters */
 +		/* fall through */
 +	case OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:
 +	case OFDM_SC_RA_RAM_CMD_USER_IO:
 +		status |= write16(state, OFDM_SC_RA_RAM_PARAM0__A, param0);
 +		/* All commands using 0 parameters */
 +		/* fall through */
++=======
+ 		fallthrough;	/* All commands using 1 parameters */
+ 	case OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:
+ 	case OFDM_SC_RA_RAM_CMD_USER_IO:
+ 		status |= write16(state, OFDM_SC_RA_RAM_PARAM0__A, param0);
+ 		fallthrough;	/* All commands using 0 parameters */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:
  	case OFDM_SC_RA_RAM_CMD_NULL:
  		/* Write command */
@@@ -3784,8 -3761,7 +3792,12 @@@ static int set_dvbt(struct drxk_state *
  	case TRANSMISSION_MODE_AUTO:
  	default:
  		operation_mode |= OFDM_SC_RA_RAM_OP_AUTO_MODE__M;
++<<<<<<< HEAD
 +		/* try first guess DRX_FFTMODE_8K */
 +		/* fall through */
++=======
+ 		fallthrough;	/* try first guess DRX_FFTMODE_8K */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case TRANSMISSION_MODE_8K:
  		transmission_params |= OFDM_SC_RA_RAM_OP_PARAM_MODE_8K;
  		break;
@@@ -3799,8 -3775,7 +3811,12 @@@
  	default:
  	case GUARD_INTERVAL_AUTO:
  		operation_mode |= OFDM_SC_RA_RAM_OP_AUTO_GUARD__M;
++<<<<<<< HEAD
 +		/* try first guess DRX_GUARD_1DIV4 */
 +		/* fall through */
++=======
+ 		fallthrough;	/* try first guess DRX_GUARD_1DIV4 */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case GUARD_INTERVAL_1_4:
  		transmission_params |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_4;
  		break;
@@@ -3841,8 -3816,7 +3857,12 @@@
  	case QAM_AUTO:
  	default:
  		operation_mode |= OFDM_SC_RA_RAM_OP_AUTO_CONST__M;
++<<<<<<< HEAD
 +		/* try first guess DRX_CONSTELLATION_QAM64 */
 +		/* fall through */
++=======
+ 		fallthrough;	/* try first guess DRX_CONSTELLATION_QAM64 */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case QAM_64:
  		transmission_params |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM64;
  		break;
@@@ -3885,8 -3859,7 +3905,12 @@@
  	case FEC_AUTO:
  	default:
  		operation_mode |= OFDM_SC_RA_RAM_OP_AUTO_RATE__M;
++<<<<<<< HEAD
 +		/* try first guess DRX_CODERATE_2DIV3 */
 +		/* fall through */
++=======
+ 		fallthrough;	/* try first guess DRX_CODERATE_2DIV3 */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FEC_2_3:
  		transmission_params |= OFDM_SC_RA_RAM_OP_PARAM_RATE_2_3;
  		break;
diff --cc drivers/media/dvb-frontends/mxl5xx.c
index 274d8fca0763,4404ace82981..000000000000
--- a/drivers/media/dvb-frontends/mxl5xx.c
+++ b/drivers/media/dvb-frontends/mxl5xx.c
@@@ -739,6 -739,7 +739,10 @@@ static int get_frontend(struct dvb_fron
  		default:
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SYS_DVBS:
  		switch ((enum MXL_HYDRA_MODULATION_E)
  			reg_data[DMD_MODULATION_SCHEME_ADDR]) {
diff --cc drivers/memstick/host/jmb38x_ms.c
index e3a5af65dbce,e83c3ada9389..000000000000
--- a/drivers/memstick/host/jmb38x_ms.c
+++ b/drivers/memstick/host/jmb38x_ms.c
@@@ -259,9 -255,11 +259,17 @@@ static unsigned int jmb38x_ms_write_dat
  	case 3:
  		host->io_word[0] |= buf[off + 2] << 16;
  		host->io_pos++;
++<<<<<<< HEAD
 +	case 2:
 +		host->io_word[0] |= buf[off + 1] << 8;
 +		host->io_pos++;
++=======
+ 		fallthrough;
+ 	case 2:
+ 		host->io_word[0] |= buf[off + 1] << 8;
+ 		host->io_pos++;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		host->io_word[0] |= buf[off];
  		host->io_pos++;
diff --cc drivers/memstick/host/tifm_ms.c
index bed205849d02,786e46798da2..000000000000
--- a/drivers/memstick/host/tifm_ms.c
+++ b/drivers/memstick/host/tifm_ms.c
@@@ -166,9 -162,11 +166,17 @@@ static unsigned int tifm_ms_write_data(
  	case 3:
  		host->io_word |= buf[off + 2] << 16;
  		host->io_pos++;
++<<<<<<< HEAD
 +	case 2:
 +		host->io_word |= buf[off + 1] << 8;
 +		host->io_pos++;
++=======
+ 		fallthrough;
+ 	case 2:
+ 		host->io_word |= buf[off + 1] << 8;
+ 		host->io_pos++;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		host->io_word |= buf[off];
  		host->io_pos++;
diff --cc drivers/message/fusion/mptbase.c
index a625ac4e2872,9903e9660a38..000000000000
--- a/drivers/message/fusion/mptbase.c
+++ b/drivers/message/fusion/mptbase.c
@@@ -642,6 -642,7 +642,10 @@@ mptbase_reply(MPT_ADAPTER *ioc, MPT_FRA
  			freereq = 0;
  		if (event != MPI_EVENT_EVENT_CHANGE)
  			break;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MPI_FUNCTION_CONFIG:
  	case MPI_FUNCTION_SAS_IO_UNIT_CONTROL:
  		ioc->mptbase_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;
@@@ -1886,6 -1887,7 +1890,10 @@@ mpt_attach(struct pci_dev *pdev, const 
  	case MPI_MANUFACTPAGE_DEVICEID_FC939X:
  	case MPI_MANUFACTPAGE_DEVICEID_FC949X:
  		ioc->errata_flag_1064 = 1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MPI_MANUFACTPAGE_DEVICEID_FC909:
  	case MPI_MANUFACTPAGE_DEVICEID_FC929:
  	case MPI_MANUFACTPAGE_DEVICEID_FC919:
@@@ -1930,6 -1932,7 +1938,10 @@@
  			pcixcmd &= 0x8F;
  			pci_write_config_byte(pdev, 0x6a, pcixcmd);
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case MPI_MANUFACTPAGE_DEVID_1030_53C1035:
  		ioc->bus_type = SPI;
diff --cc drivers/message/fusion/mptsas.c
index 522b85eb91fd,18b91ea1a353..000000000000
--- a/drivers/message/fusion/mptsas.c
+++ b/drivers/message/fusion/mptsas.c
@@@ -4327,6 -4326,7 +4327,10 @@@ mptsas_hotplug_work(MPT_ADAPTER *ioc, s
  			}
  		}
  		mpt_findImVolumes(ioc);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case MPTSAS_ADD_DEVICE:
  		memset(&sas_device, 0, sizeof(struct mptsas_devinfo));
diff --cc drivers/message/fusion/mptscsih.c
index 2af7ae13449d,8543f0324d5a..000000000000
--- a/drivers/message/fusion/mptscsih.c
+++ b/drivers/message/fusion/mptscsih.c
@@@ -784,6 -784,7 +784,10 @@@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_
  			/*
  			 * Allow non-SAS & non-NEXUS_LOSS to drop into below code
  			 */
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
  			/* Linux handles an unsolicited DID_RESET better
@@@ -880,6 -881,7 +884,10 @@@
  
  		case MPI_IOCSTATUS_SCSI_DATA_OVERRUN:		/* 0x0044 */
  			scsi_set_resid(sc, 0);
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:	/* 0x0040 */
  		case MPI_IOCSTATUS_SUCCESS:			/* 0x0000 */
  			sc->result = (DID_OK << 16) | scsi_status;
diff --cc drivers/mfd/db8500-prcmu.c
index 5970b8def548,a5983d515db0..000000000000
--- a/drivers/mfd/db8500-prcmu.c
+++ b/drivers/mfd/db8500-prcmu.c
@@@ -1588,8 -1515,10 +1588,15 @@@ static unsigned long dsiclk_rate(u8 n
  	switch (divsel) {
  	case PRCM_DSI_PLLOUT_SEL_PHI_4:
  		div *= 2;
++<<<<<<< HEAD
 +	case PRCM_DSI_PLLOUT_SEL_PHI_2:
 +		div *= 2;
++=======
+ 		fallthrough;
+ 	case PRCM_DSI_PLLOUT_SEL_PHI_2:
+ 		div *= 2;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case PRCM_DSI_PLLOUT_SEL_PHI:
  		return pll_rate(PRCM_PLLDSI_FREQ, clock_rate(PRCMU_HDMICLK),
  			PLL_RAW) / div;
diff --cc drivers/mfd/mxs-lradc.c
index 98e732a7ae96,111d11fd25aa..000000000000
--- a/drivers/mfd/mxs-lradc.c
+++ b/drivers/mfd/mxs-lradc.c
@@@ -181,7 -172,7 +181,11 @@@ static int mxs_lradc_probe(struct platf
  					MXS_LRADC_TOUCHSCREEN_5WIRE;
  				break;
  			}
++<<<<<<< HEAD
 +			/* fall through to an error message for i.MX23 */
++=======
+ 			fallthrough;	/* to an error message for i.MX23 */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			dev_err(&pdev->dev,
  				"Unsupported number of touchscreen wires (%d)\n"
diff --cc drivers/mfd/omap-usb-host.c
index e11ab12fbdf2,2a3a240b4619..000000000000
--- a/drivers/mfd/omap-usb-host.c
+++ b/drivers/mfd/omap-usb-host.c
@@@ -319,7 -308,7 +319,11 @@@ static int usbhs_runtime_resume(struct 
  					 i, r);
  				}
  			}
++<<<<<<< HEAD
 +		/* Fall through as HSIC mode needs utmi_clk */
++=======
+ 			fallthrough;	/* as HSIC mode needs utmi_clk */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case OMAP_EHCI_PORT_MODE_TLL:
  			if (!IS_ERR(omap->utmi_clk[i])) {
@@@ -355,7 -344,7 +359,11 @@@ static int usbhs_runtime_suspend(struc
  
  			if (!IS_ERR(omap->hsic480m_clk[i]))
  				clk_disable_unprepare(omap->hsic480m_clk[i]);
++<<<<<<< HEAD
 +		/* Fall through as utmi_clks were used in HSIC mode */
++=======
+ 			fallthrough;	/* as utmi_clks were used in HSIC mode */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case OMAP_EHCI_PORT_MODE_TLL:
  			if (!IS_ERR(omap->utmi_clk[i]))
diff --cc drivers/misc/eeprom/at25.c
index 6a7d4a2ad514,ed8d38b09925..000000000000
--- a/drivers/misc/eeprom/at25.c
+++ b/drivers/misc/eeprom/at25.c
@@@ -94,8 -90,10 +94,15 @@@ static int at25_ee_read(void *priv, uns
  	switch (at25->addrlen) {
  	default:	/* case 3 */
  		*cp++ = offset >> 16;
++<<<<<<< HEAD
 +	case 2:
 +		*cp++ = offset >> 8;
++=======
+ 		fallthrough;
+ 	case 2:
+ 		*cp++ = offset >> 8;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  	case 0:	/* can't happen: for better codegen */
  		*cp++ = offset >> 0;
@@@ -180,8 -178,10 +187,15 @@@ static int at25_ee_write(void *priv, un
  		switch (at25->addrlen) {
  		default:	/* case 3 */
  			*cp++ = offset >> 16;
++<<<<<<< HEAD
++		case 2:
++			*cp++ = offset >> 8;
++=======
+ 			fallthrough;
  		case 2:
  			*cp++ = offset >> 8;
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 1:
  		case 0:	/* can't happen: for better codegen */
  			*cp++ = offset >> 0;
diff --cc drivers/misc/mic/scif/scif_api.c
index 7b2dddcdd46d,304d6c833712..000000000000
--- a/drivers/misc/mic/scif/scif_api.c
+++ b/drivers/misc/mic/scif/scif_api.c
@@@ -187,6 -178,7 +187,10 @@@ int scif_close(scif_epd_t epd
  	case SCIFEP_ZOMBIE:
  		dev_err(scif_info.mdev.this_device,
  			"SCIFAPI close: zombie state unexpected\n");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SCIFEP_DISCONNECTED:
  		spin_unlock(&ep->lock);
  		scif_unregister_all_windows(epd);
@@@ -648,14 -639,13 +652,24 @@@ int __scif_connect(scif_epd_t epd, stru
  			err = -EISCONN;
  		break;
  	case SCIFEP_UNBOUND:
++<<<<<<< HEAD
 +		ep->port.port = scif_get_new_port();
 +		if (!ep->port.port) {
 +			err = -ENOSPC;
 +		} else {
 +			ep->port.node = scif_info.nodeid;
 +			ep->conn_async_state = ASYNC_CONN_IDLE;
 +		}
 +		/* Fall through */
++=======
+ 		err = scif_get_new_port();
+ 		if (err < 0)
+ 			break;
+ 		ep->port.port = err;
+ 		ep->port.node = scif_info.nodeid;
+ 		ep->conn_async_state = ASYNC_CONN_IDLE;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SCIFEP_BOUND:
  		/*
  		 * If a non-blocking connect has been already initiated
diff --cc drivers/misc/mic/scif/scif_rma.c
index def13f14c1e9,2da3b474f486..000000000000
--- a/drivers/misc/mic/scif/scif_rma.c
+++ b/drivers/misc/mic/scif/scif_rma.c
@@@ -672,8 -656,8 +672,13 @@@ int scif_unregister_window(struct scif_
  	{
  		window->unreg_state = OP_IN_PROGRESS;
  		send_msg = true;
++<<<<<<< HEAD
 +		/* fall through */
 +	}
++=======
+ 	}
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case OP_IN_PROGRESS:
  	{
  		scif_get_window(window, 1);
diff --cc drivers/misc/sgi-gru/grukservices.c
index 030769018461,0ea923fe6371..000000000000
--- a/drivers/misc/sgi-gru/grukservices.c
+++ b/drivers/misc/sgi-gru/grukservices.c
@@@ -634,7 -622,7 +634,11 @@@ static int send_noop_message(void *cb, 
  			break;
  		case CBSS_PAGE_OVERFLOW:
  			STAT(mesq_noop_page_overflow);
++<<<<<<< HEAD
 +			/* fallthru */
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			BUG();
  		}
@@@ -792,7 -780,7 +796,11 @@@ static int send_message_failure(void *c
  		break;
  	case CBSS_PAGE_OVERFLOW:
  		STAT(mesq_page_overflow);
++<<<<<<< HEAD
 +		/* fallthru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		BUG();
  	}
diff --cc drivers/misc/sgi-xp/xpc_partition.c
index 7284413dabfd,099a53bdbb7d..000000000000
--- a/drivers/misc/sgi-xp/xpc_partition.c
+++ b/drivers/misc/sgi-xp/xpc_partition.c
@@@ -449,8 -441,10 +449,15 @@@ xpc_discovery(void
  		switch (region_size) {
  		case 128:
  			max_regions *= 2;
++<<<<<<< HEAD
 +		case 64:
 +			max_regions *= 2;
++=======
+ 			fallthrough;
+ 		case 64:
+ 			max_regions *= 2;
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 32:
  			max_regions *= 2;
  			region_size = 16;
diff --cc drivers/misc/sgi-xp/xpc_uv.c
index 340b44d9e8cf,7791bde81a36..000000000000
--- a/drivers/misc/sgi-xp/xpc_uv.c
+++ b/drivers/misc/sgi-xp/xpc_uv.c
@@@ -571,6 -574,7 +571,10 @@@ xpc_handle_activate_mq_msg_uv(struct xp
  
  		xpc_wakeup_channel_mgr(part);
  	}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XPC_ACTIVATE_MQ_MSG_MARK_ENGAGED_UV:
  		spin_lock_irqsave(&part_uv->flags_lock, irq_flags);
  		part_uv->flags |= XPC_P_ENGAGED_UV;
diff --cc drivers/mmc/core/host.c
index 869ff2d5f7a4,c8fae6611b73..000000000000
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@@ -192,7 -191,7 +192,11 @@@ int mmc_of_parse(struct mmc_host *host
  	switch (bus_width) {
  	case 8:
  		host->caps |= MMC_CAP_8_BIT_DATA;
++<<<<<<< HEAD
 +		/* Hosts capable of 8-bit transfers can also do 4 bits */
++=======
+ 		fallthrough;	/* Hosts capable of 8-bit can also do 4 bits */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 4:
  		host->caps |= MMC_CAP_4_BIT_DATA;
  		break;
diff --cc drivers/mmc/host/atmel-mci.c
index 5aa2c9404e92,3fc3bbea8536..000000000000
--- a/drivers/mmc/host/atmel-mci.c
+++ b/drivers/mmc/host/atmel-mci.c
@@@ -2454,6 -2418,7 +2454,10 @@@ static void atmci_get_cap(struct atmel_
  	case 0x600:
  	case 0x500:
  		host->caps.has_odd_clk_div = 1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0x400:
  	case 0x300:
  		host->caps.has_dma_conf_reg = 1;
@@@ -2461,13 -2426,16 +2465,25 @@@
  		host->caps.has_cfg_reg = 1;
  		host->caps.has_cstor_reg = 1;
  		host->caps.has_highspeed = 1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0x200:
  		host->caps.has_rwproof = 1;
  		host->caps.need_blksz_mul_4 = 0;
  		host->caps.need_notbusy_for_read_ops = 1;
++<<<<<<< HEAD
 +	case 0x100:
 +		host->caps.has_bad_data_ordering = 0;
 +		host->caps.need_reset_after_xfer = 0;
++=======
+ 		fallthrough;
+ 	case 0x100:
+ 		host->caps.has_bad_data_ordering = 0;
+ 		host->caps.need_reset_after_xfer = 0;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0x0:
  		break;
  	default:
diff --cc drivers/mmc/host/jz4740_mmc.c
index 993386c9ea50,81d71010b474..000000000000
--- a/drivers/mmc/host/jz4740_mmc.c
+++ b/drivers/mmc/host/jz4740_mmc.c
@@@ -752,6 -739,7 +752,10 @@@ static irqreturn_t jz_mmc_irq_worker(in
  			break;
  
  		jz_mmc_prepare_data_transfer(host);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case JZ4740_MMC_STATE_TRANSFER_DATA:
  		if (host->use_dma) {
@@@ -786,6 -774,7 +790,10 @@@
  			break;
  		}
  		jz4740_mmc_write_irq_reg(host, JZ_MMC_IRQ_DATA_TRAN_DONE);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case JZ4740_MMC_STATE_SEND_STOP:
  		if (!req->stop)
diff --cc drivers/mmc/host/meson-mx-sdio.c
index 09cb89645d06,703d5834f9a5..000000000000
--- a/drivers/mmc/host/meson-mx-sdio.c
+++ b/drivers/mmc/host/meson-mx-sdio.c
@@@ -294,7 -294,7 +294,11 @@@ static void meson_mx_mmc_set_ios(struc
  	switch (ios->power_mode) {
  	case MMC_POWER_OFF:
  		vdd = 0;
++<<<<<<< HEAD
 +		/* fall-through: */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MMC_POWER_UP:
  		if (!IS_ERR(mmc->supply.vmmc)) {
  			host->error = mmc_regulator_set_ocr(mmc,
diff --cc drivers/mmc/host/sdhci-s3c.c
index 9ef89d00970e,080ced1e63f0..000000000000
--- a/drivers/mmc/host/sdhci-s3c.c
+++ b/drivers/mmc/host/sdhci-s3c.c
@@@ -614,6 -609,7 +614,10 @@@ static int sdhci_s3c_probe(struct platf
  	switch (pdata->max_width) {
  	case 8:
  		host->mmc->caps |= MMC_CAP_8_BIT_DATA;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 4:
  		host->mmc->caps |= MMC_CAP_4_BIT_DATA;
  		break;
diff --cc drivers/mmc/host/sdhci-xenon-phy.c
index a35804b203a7,03ce57ef4585..000000000000
--- a/drivers/mmc/host/sdhci-xenon-phy.c
+++ b/drivers/mmc/host/sdhci-xenon-phy.c
@@@ -526,6 -527,7 +526,10 @@@ static bool xenon_emmc_phy_slow_mode(st
  			ret = true;
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		reg &= ~XENON_TIMING_ADJUST_SLOW_MODE;
  		ret = false;
diff --cc drivers/mmc/host/tifm_sd.c
index f9033395b5ac,fd8b72d3e02c..000000000000
--- a/drivers/mmc/host/tifm_sd.c
+++ b/drivers/mmc/host/tifm_sd.c
@@@ -336,7 -334,8 +336,12 @@@ static unsigned int tifm_sd_op_flags(st
  		rc |= TIFM_MMCSD_RSP_R0;
  		break;
  	case MMC_RSP_R1B:
++<<<<<<< HEAD
 +		rc |= TIFM_MMCSD_RSP_BUSY; // deliberate fall-through
++=======
+ 		rc |= TIFM_MMCSD_RSP_BUSY;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MMC_RSP_R1:
  		rc |= TIFM_MMCSD_RSP_R1;
  		break;
diff --cc drivers/mmc/host/usdhi6rol0.c
index cdfeb15b6f05,7666c90054ae..000000000000
--- a/drivers/mmc/host/usdhi6rol0.c
+++ b/drivers/mmc/host/usdhi6rol0.c
@@@ -1342,7 -1343,7 +1342,11 @@@ static int usdhi6_stop_cmd(struct usdhi
  			host->wait = USDHI6_WAIT_FOR_STOP;
  			return 0;
  		}
++<<<<<<< HEAD
 +		/* Unsupported STOP command */
++=======
+ 		fallthrough;	/* Unsupported STOP command */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		dev_err(mmc_dev(host->mmc),
  			"unsupported stop CMD%d for CMD%d\n",
@@@ -1690,7 -1691,7 +1694,11 @@@ static void usdhi6_timeout_work(struct 
  	switch (host->wait) {
  	default:
  		dev_err(mmc_dev(host->mmc), "Invalid state %u\n", host->wait);
++<<<<<<< HEAD
 +		/* mrq can be NULL in this actually impossible case */
++=======
+ 		fallthrough;	/* mrq can be NULL, but is impossible */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case USDHI6_WAIT_FOR_CMD:
  		usdhi6_error_code(host);
  		if (mrq)
@@@ -1712,10 -1713,7 +1720,14 @@@
  			host->offset, data->blocks, data->blksz, data->sg_len,
  			sg_dma_len(sg), sg->offset);
  		usdhi6_sg_unmap(host, true);
++<<<<<<< HEAD
 +		/*
 +		 * If USDHI6_WAIT_FOR_DATA_END times out, we have already unmapped
 +		 * the page
 +		 */
++=======
+ 		fallthrough;	/* page unmapped in USDHI6_WAIT_FOR_DATA_END */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case USDHI6_WAIT_FOR_DATA_END:
  		usdhi6_error_code(host);
  		data->error = -ETIMEDOUT;
diff --cc drivers/net/appletalk/cops.c
index 3b90c44c6f49,1c6c27f35ac4..000000000000
--- a/drivers/net/appletalk/cops.c
+++ b/drivers/net/appletalk/cops.c
@@@ -301,7 -301,7 +301,11 @@@ static int __init cops_probe1(struct ne
  			dev->irq = cops_irq(ioaddr, board);
  			if (dev->irq)
  				break;
++<<<<<<< HEAD
 +			/* No IRQ found on this port, fallthrough */
++=======
+ 			fallthrough;	/* Once no IRQ found on this port */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 1:
  			retval = -EINVAL;
  			goto err_out;
diff --cc drivers/net/arcnet/arc-rimi.c
index 11c5bad95226,98df38fe553c..000000000000
--- a/drivers/net/arcnet/arc-rimi.c
+++ b/drivers/net/arcnet/arc-rimi.c
@@@ -363,10 -363,13 +363,20 @@@ static int __init arcrimi_setup(char *s
  	switch (ints[0]) {
  	default:		/* ERROR */
  		pr_err("Too many arguments\n");
++<<<<<<< HEAD
 +	case 3:		/* Node ID */
 +		node = ints[3];
 +	case 2:		/* IRQ */
 +		irq = ints[2];
++=======
+ 		fallthrough;
+ 	case 3:		/* Node ID */
+ 		node = ints[3];
+ 		fallthrough;
+ 	case 2:		/* IRQ */
+ 		irq = ints[2];
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:		/* IO address */
  		io = ints[1];
  	}
diff --cc drivers/net/arcnet/com20020-isa.c
index 28510e33924f,f983c4ce6b07..000000000000
--- a/drivers/net/arcnet/com20020-isa.c
+++ b/drivers/net/arcnet/com20020-isa.c
@@@ -197,16 -197,22 +197,35 @@@ static int __init com20020isa_setup(cha
  	switch (ints[0]) {
  	default:		/* ERROR */
  		pr_info("Too many arguments\n");
++<<<<<<< HEAD
 +	case 6:		/* Timeout */
 +		timeout = ints[6];
 +	case 5:		/* CKP value */
 +		clockp = ints[5];
 +	case 4:		/* Backplane flag */
 +		backplane = ints[4];
 +	case 3:		/* Node ID */
 +		node = ints[3];
 +	case 2:		/* IRQ */
 +		irq = ints[2];
++=======
+ 		fallthrough;
+ 	case 6:		/* Timeout */
+ 		timeout = ints[6];
+ 		fallthrough;
+ 	case 5:		/* CKP value */
+ 		clockp = ints[5];
+ 		fallthrough;
+ 	case 4:		/* Backplane flag */
+ 		backplane = ints[4];
+ 		fallthrough;
+ 	case 3:		/* Node ID */
+ 		node = ints[3];
+ 		fallthrough;
+ 	case 2:		/* IRQ */
+ 		irq = ints[2];
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:		/* IO address */
  		io = ints[1];
  	}
diff --cc drivers/net/arcnet/com90io.c
index 2c546013a980,cf214b730671..000000000000
--- a/drivers/net/arcnet/com90io.c
+++ b/drivers/net/arcnet/com90io.c
@@@ -363,8 -363,10 +363,15 @@@ static int __init com90io_setup(char *s
  	switch (ints[0]) {
  	default:		/* ERROR */
  		pr_err("Too many arguments\n");
++<<<<<<< HEAD
 +	case 2:		/* IRQ */
 +		irq = ints[2];
++=======
+ 		fallthrough;
+ 	case 2:		/* IRQ */
+ 		irq = ints[2];
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:		/* IO address */
  		io = ints[1];
  	}
diff --cc drivers/net/arcnet/com90xx.c
index ca4a57c30bf8,3dc3d533cb19..000000000000
--- a/drivers/net/arcnet/com90xx.c
+++ b/drivers/net/arcnet/com90xx.c
@@@ -693,10 -693,13 +693,20 @@@ static int __init com90xx_setup(char *s
  	switch (ints[0]) {
  	default:		/* ERROR */
  		pr_err("Too many arguments\n");
++<<<<<<< HEAD
 +	case 3:		/* Mem address */
 +		shmem = ints[3];
 +	case 2:		/* IRQ */
 +		irq = ints[2];
++=======
+ 		fallthrough;
+ 	case 3:		/* Mem address */
+ 		shmem = ints[3];
+ 		fallthrough;
+ 	case 2:		/* IRQ */
+ 		irq = ints[2];
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:		/* IO address */
  		io = ints[1];
  	}
diff --cc drivers/net/dsa/mt7530.c
index 74547f43b938,0c37ddb58c1e..000000000000
--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@@ -616,59 -549,75 +616,70 @@@ mt7530_get_sset_count(struct dsa_switc
  	return ARRAY_SIZE(mt7530_mib);
  }
  
 -static void mt7530_setup_port5(struct dsa_switch *ds, phy_interface_t interface)
 +static void mt7530_adjust_link(struct dsa_switch *ds, int port,
 +			       struct phy_device *phydev)
  {
  	struct mt7530_priv *priv = ds->priv;
 -	u8 tx_delay = 0;
 -	int val;
  
 -	mutex_lock(&priv->reg_mutex);
 -
 -	val = mt7530_read(priv, MT7530_MHWTRAP);
 +	if (phy_is_pseudo_fixed_link(phydev)) {
 +		dev_dbg(priv->dev, "phy-mode for master device = %x\n",
 +			phydev->interface);
  
 -	val |= MHWTRAP_MANUAL | MHWTRAP_P5_MAC_SEL | MHWTRAP_P5_DIS;
 -	val &= ~MHWTRAP_P5_RGMII_MODE & ~MHWTRAP_PHY0_SEL;
 +		/* Setup TX circuit incluing relevant PAD and driving */
 +		mt7530_pad_clk_setup(ds, phydev->interface);
  
 +		/* Setup RX circuit, relevant PAD and driving on the host
 +		 * which must be placed after the setup on the device side is
 +		 * all finished.
 +		 */
 +		mt7623_pad_clk_setup(ds);
 +	} else {
 +		u16 lcl_adv = 0, rmt_adv = 0;
 +		u8 flowctrl;
 +		u32 mcr = PMCR_USERP_LINK | PMCR_FORCE_MODE;
 +
++<<<<<<< HEAD
 +		switch (phydev->speed) {
 +		case SPEED_1000:
 +			mcr |= PMCR_FORCE_SPEED_1000;
 +			break;
 +		case SPEED_100:
 +			mcr |= PMCR_FORCE_SPEED_100;
 +			break;
 +		};
++=======
+ 	switch (priv->p5_intf_sel) {
+ 	case P5_INTF_SEL_PHY_P0:
+ 		/* MT7530_P5_MODE_GPHY_P0: 2nd GMAC -> P5 -> P0 */
+ 		val |= MHWTRAP_PHY0_SEL;
+ 		fallthrough;
+ 	case P5_INTF_SEL_PHY_P4:
+ 		/* MT7530_P5_MODE_GPHY_P4: 2nd GMAC -> P5 -> P4 */
+ 		val &= ~MHWTRAP_P5_MAC_SEL & ~MHWTRAP_P5_DIS;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -		/* Setup the MAC by default for the cpu port */
 -		mt7530_write(priv, MT7530_PMCR_P(5), 0x56300);
 -		break;
 -	case P5_INTF_SEL_GMAC5:
 -		/* MT7530_P5_MODE_GMAC: P5 -> External phy or 2nd GMAC */
 -		val &= ~MHWTRAP_P5_DIS;
 -		break;
 -	case P5_DISABLED:
 -		interface = PHY_INTERFACE_MODE_NA;
 -		break;
 -	default:
 -		dev_err(ds->dev, "Unsupported p5_intf_sel %d\n",
 -			priv->p5_intf_sel);
 -		goto unlock_exit;
 -	}
 -
 -	/* Setup RGMII settings */
 -	if (phy_interface_mode_is_rgmii(interface)) {
 -		val |= MHWTRAP_P5_RGMII_MODE;
 +		if (phydev->link)
 +			mcr |= PMCR_FORCE_LNK;
  
 -		/* P5 RGMII RX Clock Control: delay setting for 1000M */
 -		mt7530_write(priv, MT7530_P5RGMIIRXCR, CSR_RGMII_EDGE_ALIGN);
 +		if (phydev->duplex) {
 +			mcr |= PMCR_FORCE_FDX;
  
 -		/* Don't set delay in DSA mode */
 -		if (!dsa_is_dsa_port(priv->ds, 5) &&
 -		    (interface == PHY_INTERFACE_MODE_RGMII_TXID ||
 -		     interface == PHY_INTERFACE_MODE_RGMII_ID))
 -			tx_delay = 4; /* n * 0.5 ns */
 +			if (phydev->pause)
 +				rmt_adv = LPA_PAUSE_CAP;
 +			if (phydev->asym_pause)
 +				rmt_adv |= LPA_PAUSE_ASYM;
  
 -		/* P5 RGMII TX Clock Control: delay x */
 -		mt7530_write(priv, MT7530_P5RGMIITXCR,
 -			     CSR_RGMII_TXC_CFG(0x10 + tx_delay));
 +			lcl_adv = linkmode_adv_to_lcl_adv_t(
 +				phydev->advertising);
 +			flowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);
  
 -		/* reduce P5 RGMII Tx driving, 8mA */
 -		mt7530_write(priv, MT7530_IO_DRV_CR,
 -			     P5_IO_CLK_DRV(1) | P5_IO_DATA_DRV(1));
 +			if (flowctrl & FLOW_CTRL_TX)
 +				mcr |= PMCR_TX_FC_EN;
 +			if (flowctrl & FLOW_CTRL_RX)
 +				mcr |= PMCR_RX_FC_EN;
 +		}
 +		mt7530_write(priv, MT7530_PMCR_P(port), mcr);
  	}
 -
 -	mt7530_write(priv, MT7530_MHWTRAP, val);
 -
 -	dev_dbg(ds->dev, "Setup P5, HWTRAP=0x%x, intf_sel=%s, phy-mode=%s\n",
 -		val, p5_intf_modes(priv->p5_intf_sel), phy_modes(interface));
 -
 -	priv->p5_interface = interface;
 -
 -unlock_exit:
 -	mutex_unlock(&priv->reg_mutex);
  }
  
  static int
diff --cc drivers/net/ethernet/3com/3c509.c
index 2563e54fc58d,667f38c9e4c6..000000000000
--- a/drivers/net/ethernet/3com/3c509.c
+++ b/drivers/net/ethernet/3com/3c509.c
@@@ -1266,12 -1259,14 +1266,20 @@@ el3_up(struct net_device *dev
  					pr_cont("Forcing 3c5x9b full-duplex mode");
  					break;
  				}
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case 8:
  				/* set full-duplex mode based on eeprom config setting */
  				if ((sw_info & 0x000f) && (sw_info & 0x8000)) {
  					pr_cont("Setting 3c5x9b full-duplex mode (from EEPROM configuration bit)");
  					break;
  				}
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			default:
  				/* xcvr=(0 || 4) OR user has an old 3c5x9 non "B" model */
  				pr_cont("Setting 3c5x9/3c5x9B half-duplex mode");
diff --cc drivers/net/ethernet/8390/axnet_cs.c
index 080a5eb42291,a00b36f91d9f..000000000000
--- a/drivers/net/ethernet/8390/axnet_cs.c
+++ b/drivers/net/ethernet/8390/axnet_cs.c
@@@ -610,6 -610,7 +610,10 @@@ static int axnet_ioctl(struct net_devic
      switch (cmd) {
      case SIOCGMIIPHY:
  	data->phy_id = info->phy_id;
++<<<<<<< HEAD
++=======
+ 	fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
      case SIOCGMIIREG:		/* Read MII PHY register. */
  	data->val_out = mdio_read(mii_addr, data->phy_id, data->reg_num & 0x1f);
  	return 0;
diff --cc drivers/net/ethernet/alteon/acenic.c
index 30e03970eb4f,8470c836fa18..000000000000
--- a/drivers/net/ethernet/alteon/acenic.c
+++ b/drivers/net/ethernet/alteon/acenic.c
@@@ -551,6 -547,7 +551,10 @@@ static int acenic_probe_one(struct pci_
  			       ap->name);
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case PCI_VENDOR_ID_SGI:
  		printk(KERN_INFO "%s: SGI AceNIC ", ap->name);
  		break;
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index 724a3a43c70e,4ba75551cb17..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -1613,7 -1538,7 +1613,11 @@@ static int xgbe_set_hwtstamp_settings(s
  	/* PTP v2, UDP, any kind of event packet */
  	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
++<<<<<<< HEAD
 +	/* PTP v1, UDP, any kind of event packet */
++=======
+ 		fallthrough;	/* to PTP v1, UDP, any kind of event packet */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
@@@ -1624,7 -1549,7 +1628,11 @@@
  	/* PTP v2, UDP, Sync packet */
  	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
++<<<<<<< HEAD
 +	/* PTP v1, UDP, Sync packet */
++=======
+ 		fallthrough;	/* to PTP v1, UDP, Sync packet */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
@@@ -1635,7 -1560,7 +1643,11 @@@
  	/* PTP v2, UDP, Delay_req packet */
  	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
++<<<<<<< HEAD
 +	/* PTP v1, UDP, Delay_req packet */
++=======
+ 		fallthrough;	/* to PTP v1, UDP, Delay_req packet */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
  		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c
index 00396b3053d9,4e85e7dbc2be..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c
@@@ -6339,7 -6339,7 +6339,11 @@@ int bnx2x_set_led(struct link_params *p
  		 */
  		if (!vars->link_up)
  			break;
++<<<<<<< HEAD
 +		/* else: fall through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case LED_MODE_ON:
  		if (((params->phy[EXT_PHY1].type ==
  			  PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727) ||
diff --cc drivers/net/ethernet/broadcom/genet/bcmmii.c
index 8f181b3c487c,6fb6c3556285..000000000000
--- a/drivers/net/ethernet/broadcom/genet/bcmmii.c
+++ b/drivers/net/ethernet/broadcom/genet/bcmmii.c
@@@ -180,11 -189,10 +180,16 @@@ int bcmgenet_mii_config(struct net_devi
  	u32 port_ctrl;
  	u32 reg;
  
 +	priv->ext_phy = !priv->internal_phy &&
 +			(priv->phy_interface != PHY_INTERFACE_MODE_MOCA);
 +
  	switch (priv->phy_interface) {
  	case PHY_INTERFACE_MODE_INTERNAL:
++<<<<<<< HEAD
++=======
+ 		phy_name = "internal PHY";
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case PHY_INTERFACE_MODE_MOCA:
  		/* Irrespective of the actually configured PHY speed (100 or
  		 * 1000) GENETv4 only has an internal GPHY so we will just end
diff --cc drivers/net/ethernet/brocade/bna/bfa_ioc.c
index a36e38676640,b9dd06b12945..000000000000
--- a/drivers/net/ethernet/brocade/bna/bfa_ioc.c
+++ b/drivers/net/ethernet/brocade/bna/bfa_ioc.c
@@@ -788,9 -780,8 +788,14 @@@ bfa_iocpf_sm_enabling(struct bfa_iocpf 
  
  	case IOCPF_E_INITFAIL:
  		del_timer(&ioc->iocpf_timer);
++<<<<<<< HEAD
 +		/*
 +		 * !!! fall through !!!
 +		 */
++=======
+ 		fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IOCPF_E_TIMEOUT:
  		bfa_nw_ioc_hw_sem_release(ioc);
  		if (event == IOCPF_E_TIMEOUT)
@@@ -858,9 -849,7 +863,13 @@@ bfa_iocpf_sm_disabling(struct bfa_iocp
  
  	case IOCPF_E_FAIL:
  		del_timer(&ioc->iocpf_timer);
++<<<<<<< HEAD
 +		/*
 +		 * !!! fall through !!!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case IOCPF_E_TIMEOUT:
  		bfa_ioc_set_cur_ioc_fwstate(ioc, BFI_IOC_FAIL);
diff --cc drivers/net/ethernet/cadence/macb_ptp.c
index 678835136bf8,283918aeb741..000000000000
--- a/drivers/net/ethernet/cadence/macb_ptp.c
+++ b/drivers/net/ethernet/cadence/macb_ptp.c
@@@ -466,6 -460,7 +466,10 @@@ int gem_set_hwtst(struct net_device *de
  	case HWTSTAMP_TX_ONESTEP_SYNC:
  		if (gem_ptp_set_one_step_sync(bp, 1) != 0)
  			return -ERANGE;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case HWTSTAMP_TX_ON:
  		tx_bd_control = TSTAMP_ALL_FRAMES;
  		break;
diff --cc drivers/net/ethernet/cavium/liquidio/lio_main.c
index 09d40722ba67,8e0ed01e7f03..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/lio_main.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_main.c
@@@ -1034,8 -984,11 +1033,8 @@@ static void octeon_destroy_resources(st
  		/* Remove any consoles */
  		octeon_remove_consoles(oct);
  
- 		/* fallthrough */
+ 		fallthrough;
  	case OCT_DEV_IO_QUEUES_DONE:
 -		if (lio_wait_for_instr_fetch(oct))
 -			dev_err(&oct->pci_dev->dev, "IQ had pending instructions\n");
 -
  		if (wait_for_pending_requests(oct))
  			dev_err(&oct->pci_dev->dev, "There were pending requests\n");
  
@@@ -1051,7 -1001,32 +1050,36 @@@
  		if (lio_wait_for_oq_pkts(oct))
  			dev_err(&oct->pci_dev->dev, "OQ had pending packets\n");
  
++<<<<<<< HEAD
 +	/* fallthrough */
++=======
+ 		/* Force all requests waiting to be fetched by OCTEON to
+ 		 * complete.
+ 		 */
+ 		for (i = 0; i < MAX_OCTEON_INSTR_QUEUES(oct); i++) {
+ 			struct octeon_instr_queue *iq;
+ 
+ 			if (!(oct->io_qmask.iq & BIT_ULL(i)))
+ 				continue;
+ 			iq = oct->instr_queue[i];
+ 
+ 			if (atomic_read(&iq->instr_pending)) {
+ 				spin_lock_bh(&iq->lock);
+ 				iq->fill_cnt = 0;
+ 				iq->octeon_read_index = iq->host_write_index;
+ 				iq->stats.instr_processed +=
+ 					atomic_read(&iq->instr_pending);
+ 				lio_process_iq_request_list(oct, iq, 0);
+ 				spin_unlock_bh(&iq->lock);
+ 			}
+ 		}
+ 
+ 		lio_process_ordered_list(oct, 1);
+ 		octeon_free_sc_done_list(oct);
+ 		octeon_free_sc_zombie_list(oct);
+ 
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case OCT_DEV_INTR_SET_DONE:
  		/* Disable interrupts  */
  		oct->fn_list.disable_interrupt(oct, OCTEON_ALL_INTR);
@@@ -2208,6 -2167,7 +2236,10 @@@ static int liquidio_ioctl(struct net_de
  	case SIOCSHWTSTAMP:
  		if (lio->oct_dev->ptp_enable)
  			return hwtstamp_ioctl(netdev, ifr);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return -EOPNOTSUPP;
  	}
diff --cc drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
index cc3cf34d9433,8c5879e31240..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
@@@ -467,10 -460,12 +467,9 @@@ static void octeon_destroy_resources(st
  
  		schedule_timeout_uninterruptible(HZ / 10);
  
- 		/* fallthrough */
+ 		fallthrough;
  	case OCT_DEV_HOST_OK:
- 		/* fallthrough */
  	case OCT_DEV_IO_QUEUES_DONE:
 -		if (lio_wait_for_instr_fetch(oct))
 -			dev_err(&oct->pci_dev->dev, "IQ had pending instructions\n");
 -
  		if (wait_for_pending_requests(oct))
  			dev_err(&oct->pci_dev->dev, "There were pending requests\n");
  
@@@ -485,7 -477,33 +484,37 @@@
  
  		if (lio_wait_for_oq_pkts(oct))
  			dev_err(&oct->pci_dev->dev, "OQ had pending packets\n");
++<<<<<<< HEAD
 +		/* fall through */
++=======
+ 
+ 		/* Force all requests waiting to be fetched by OCTEON to
+ 		 * complete.
+ 		 */
+ 		for (i = 0; i < MAX_OCTEON_INSTR_QUEUES(oct); i++) {
+ 			struct octeon_instr_queue *iq;
+ 
+ 			if (!(oct->io_qmask.iq & BIT_ULL(i)))
+ 				continue;
+ 			iq = oct->instr_queue[i];
+ 
+ 			if (atomic_read(&iq->instr_pending)) {
+ 				spin_lock_bh(&iq->lock);
+ 				iq->fill_cnt = 0;
+ 				iq->octeon_read_index = iq->host_write_index;
+ 				iq->stats.instr_processed +=
+ 					atomic_read(&iq->instr_pending);
+ 				lio_process_iq_request_list(oct, iq, 0);
+ 				spin_unlock_bh(&iq->lock);
+ 			}
+ 		}
+ 
+ 		lio_process_ordered_list(oct, 1);
+ 		octeon_free_sc_done_list(oct);
+ 		octeon_free_sc_zombie_list(oct);
+ 
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case OCT_DEV_INTR_SET_DONE:
  		/* Disable interrupts  */
  		oct->fn_list.disable_interrupt(oct, OCTEON_ALL_INTR);
diff --cc drivers/net/ethernet/cavium/thunder/nicvf_ethtool.c
index 5603f5ab1fee,c7bdac79299a..000000000000
--- a/drivers/net/ethernet/cavium/thunder/nicvf_ethtool.c
+++ b/drivers/net/ethernet/cavium/thunder/nicvf_ethtool.c
@@@ -527,6 -522,7 +527,10 @@@ static int nicvf_get_rss_hash_opts(stru
  	case SCTP_V4_FLOW:
  	case SCTP_V6_FLOW:
  		info->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IPV4_FLOW:
  	case IPV6_FLOW:
  		info->data |= RXH_IP_SRC | RXH_IP_DST;
diff --cc drivers/net/ethernet/chelsio/cxgb3/l2t.c
index 248e40c6966c,9749d1239f58..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb3/l2t.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/l2t.c
@@@ -136,6 -136,7 +136,10 @@@ again
  		if (e->state == L2T_STATE_STALE)
  			e->state = L2T_STATE_VALID;
  		spin_unlock_bh(&e->lock);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case L2T_STATE_VALID:	/* fast-path, send the packet on */
  		return cxgb3_ofld_send(dev, skb);
  	case L2T_STATE_RESOLVING:
diff --cc drivers/net/ethernet/davicom/dm9000.c
index 1ea29122e1f2,5c6c8c5ec747..000000000000
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@@ -395,6 -385,7 +395,10 @@@ static void dm9000_set_io(struct board_
  
  	case 3:
  		dev_dbg(db->dev, ": 3 byte IO, falling back to 16bit\n");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		db->dumpblk = dm9000_dumpblk_16bit;
  		db->outblk  = dm9000_outblk_16bit;
diff --cc drivers/net/ethernet/dec/tulip/de4x5.c
index a31b4df3e7ff,f9dd1aa9f2da..000000000000
--- a/drivers/net/ethernet/dec/tulip/de4x5.c
+++ b/drivers/net/ethernet/dec/tulip/de4x5.c
@@@ -3204,6 -3203,8 +3204,11 @@@ srom_map_media(struct net_device *dev
        case SROM_10BASETF:
  	if (!lp->params.fdx) return -1;
  	lp->fdx = true;
++<<<<<<< HEAD
++=======
+ 	fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
        case SROM_10BASET:
  	if (lp->params.fdx && !lp->fdx) return -1;
  	if ((lp->chipset == DC21140) || ((lp->chipset & ~0x00ff) == DC2114x)) {
@@@ -3224,6 -3225,8 +3229,11 @@@
        case SROM_100BASETF:
          if (!lp->params.fdx) return -1;
  	lp->fdx = true;
++<<<<<<< HEAD
++=======
+ 	fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
        case SROM_100BASET:
  	if (lp->params.fdx && !lp->fdx) return -1;
  	lp->media = _100Mb;
@@@ -3236,6 -3239,8 +3246,11 @@@
        case SROM_100BASEFF:
  	if (!lp->params.fdx) return -1;
  	lp->fdx = true;
++<<<<<<< HEAD
++=======
+ 	fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
        case SROM_100BASEF:
  	if (lp->params.fdx && !lp->fdx) return -1;
  	lp->media = _100Mb;
diff --cc drivers/net/ethernet/dec/tulip/tulip_core.c
index 6dc60eec09ae,3a8659c5da06..000000000000
--- a/drivers/net/ethernet/dec/tulip/tulip_core.c
+++ b/drivers/net/ethernet/dec/tulip/tulip_core.c
@@@ -923,6 -911,7 +923,10 @@@ static int private_ioctl (struct net_de
  			data->phy_id = 1;
  		else
  			return -ENODEV;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case SIOCGMIIREG:		/* Read MII PHY register. */
  		if (data->phy_id == 32 && (tp->flags & HAS_NWAY)) {
diff --cc drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
index 669442d0326c,c2ea0348b2f7..000000000000
--- a/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
@@@ -2187,7 -2746,13 +2187,11 @@@ static void hns3_rx_checksum(struct hns
  	case HNS3_OL4_TYPE_MAC_IN_UDP:
  	case HNS3_OL4_TYPE_NVGRE:
  		skb->csum_level = 1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case HNS3_OL4_TYPE_NO_TUN:
 -		l3_type = hnae3_get_field(l234info, HNS3_RXD_L3ID_M,
 -					  HNS3_RXD_L3ID_S);
 -		l4_type = hnae3_get_field(l234info, HNS3_RXD_L4ID_M,
 -					  HNS3_RXD_L4ID_S);
 -
  		/* Can checksum ipv4 or ipv6 + UDP/TCP/SCTP packets */
  		if ((l3_type == HNS3_L3_TYPE_IPV4 ||
  		     l3_type == HNS3_L3_TYPE_IPV6) &&
diff --cc drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
index 9dd91b956462,d553ed7ee64c..000000000000
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@@ -2328,6 -3049,19 +2328,22 @@@ static irqreturn_t hclge_misc_irq_handl
  
  	/* vector 0 interrupt is shared with reset and mailbox source events.*/
  	switch (event_cause) {
++<<<<<<< HEAD
++=======
+ 	case HCLGE_VECTOR0_EVENT_ERR:
+ 		/* we do not know what type of reset is required now. This could
+ 		 * only be decided after we fetch the type of errors which
+ 		 * caused this event. Therefore, we will do below for now:
+ 		 * 1. Assert HNAE3_UNKNOWN_RESET type of reset. This means we
+ 		 *    have defered type of reset to be used.
+ 		 * 2. Schedule the reset serivce task.
+ 		 * 3. When service task receives  HNAE3_UNKNOWN_RESET type it
+ 		 *    will fetch the correct type of reset.  This would be done
+ 		 *    by first decoding the types of errors.
+ 		 */
+ 		set_bit(HNAE3_UNKNOWN_RESET, &hdev->reset_request);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case HCLGE_VECTOR0_EVENT_RST:
  		hclge_reset_task_schedule(hdev);
  		break;
@@@ -2573,38 -3540,292 +2589,297 @@@ static void hclge_clear_reset_cause(str
  	hclge_enable_vector(&hdev->misc_vector, true);
  }
  
++<<<<<<< HEAD
++=======
+ static void hclge_reset_handshake(struct hclge_dev *hdev, bool enable)
+ {
+ 	u32 reg_val;
+ 
+ 	reg_val = hclge_read_dev(&hdev->hw, HCLGE_NIC_CSQ_DEPTH_REG);
+ 	if (enable)
+ 		reg_val |= HCLGE_NIC_SW_RST_RDY;
+ 	else
+ 		reg_val &= ~HCLGE_NIC_SW_RST_RDY;
+ 
+ 	hclge_write_dev(&hdev->hw, HCLGE_NIC_CSQ_DEPTH_REG, reg_val);
+ }
+ 
+ static int hclge_func_reset_notify_vf(struct hclge_dev *hdev)
+ {
+ 	int ret;
+ 
+ 	ret = hclge_set_all_vf_rst(hdev, true);
+ 	if (ret)
+ 		return ret;
+ 
+ 	hclge_func_reset_sync_vf(hdev);
+ 
+ 	return 0;
+ }
+ 
+ static int hclge_reset_prepare_wait(struct hclge_dev *hdev)
+ {
+ 	u32 reg_val;
+ 	int ret = 0;
+ 
+ 	switch (hdev->reset_type) {
+ 	case HNAE3_FUNC_RESET:
+ 		ret = hclge_func_reset_notify_vf(hdev);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = hclge_func_reset_cmd(hdev, 0);
+ 		if (ret) {
+ 			dev_err(&hdev->pdev->dev,
+ 				"asserting function reset fail %d!\n", ret);
+ 			return ret;
+ 		}
+ 
+ 		/* After performaning pf reset, it is not necessary to do the
+ 		 * mailbox handling or send any command to firmware, because
+ 		 * any mailbox handling or command to firmware is only valid
+ 		 * after hclge_cmd_init is called.
+ 		 */
+ 		set_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
+ 		hdev->rst_stats.pf_rst_cnt++;
+ 		break;
+ 	case HNAE3_FLR_RESET:
+ 		ret = hclge_func_reset_notify_vf(hdev);
+ 		if (ret)
+ 			return ret;
+ 		break;
+ 	case HNAE3_IMP_RESET:
+ 		hclge_handle_imp_error(hdev);
+ 		reg_val = hclge_read_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG);
+ 		hclge_write_dev(&hdev->hw, HCLGE_PF_OTHER_INT_REG,
+ 				BIT(HCLGE_VECTOR0_IMP_RESET_INT_B) | reg_val);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	/* inform hardware that preparatory work is done */
+ 	msleep(HCLGE_RESET_SYNC_TIME);
+ 	hclge_reset_handshake(hdev, true);
+ 	dev_info(&hdev->pdev->dev, "prepare wait ok\n");
+ 
+ 	return ret;
+ }
+ 
+ static bool hclge_reset_err_handle(struct hclge_dev *hdev)
+ {
+ #define MAX_RESET_FAIL_CNT 5
+ 
+ 	if (hdev->reset_pending) {
+ 		dev_info(&hdev->pdev->dev, "Reset pending %lu\n",
+ 			 hdev->reset_pending);
+ 		return true;
+ 	} else if (hclge_read_dev(&hdev->hw, HCLGE_MISC_VECTOR_INT_STS) &
+ 		   HCLGE_RESET_INT_M) {
+ 		dev_info(&hdev->pdev->dev,
+ 			 "reset failed because new reset interrupt\n");
+ 		hclge_clear_reset_cause(hdev);
+ 		return false;
+ 	} else if (hdev->rst_stats.reset_fail_cnt < MAX_RESET_FAIL_CNT) {
+ 		hdev->rst_stats.reset_fail_cnt++;
+ 		set_bit(hdev->reset_type, &hdev->reset_pending);
+ 		dev_info(&hdev->pdev->dev,
+ 			 "re-schedule reset task(%u)\n",
+ 			 hdev->rst_stats.reset_fail_cnt);
+ 		return true;
+ 	}
+ 
+ 	hclge_clear_reset_cause(hdev);
+ 
+ 	/* recover the handshake status when reset fail */
+ 	hclge_reset_handshake(hdev, true);
+ 
+ 	dev_err(&hdev->pdev->dev, "Reset fail!\n");
+ 
+ 	hclge_dbg_dump_rst_info(hdev);
+ 
+ 	set_bit(HCLGE_STATE_RST_FAIL, &hdev->state);
+ 
+ 	return false;
+ }
+ 
+ static int hclge_set_rst_done(struct hclge_dev *hdev)
+ {
+ 	struct hclge_pf_rst_done_cmd *req;
+ 	struct hclge_desc desc;
+ 	int ret;
+ 
+ 	req = (struct hclge_pf_rst_done_cmd *)desc.data;
+ 	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PF_RST_DONE, false);
+ 	req->pf_rst_done |= HCLGE_PF_RESET_DONE_BIT;
+ 
+ 	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
+ 	/* To be compatible with the old firmware, which does not support
+ 	 * command HCLGE_OPC_PF_RST_DONE, just print a warning and
+ 	 * return success
+ 	 */
+ 	if (ret == -EOPNOTSUPP) {
+ 		dev_warn(&hdev->pdev->dev,
+ 			 "current firmware does not support command(0x%x)!\n",
+ 			 HCLGE_OPC_PF_RST_DONE);
+ 		return 0;
+ 	} else if (ret) {
+ 		dev_err(&hdev->pdev->dev, "assert PF reset done fail %d!\n",
+ 			ret);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int hclge_reset_prepare_up(struct hclge_dev *hdev)
+ {
+ 	int ret = 0;
+ 
+ 	switch (hdev->reset_type) {
+ 	case HNAE3_FUNC_RESET:
+ 	case HNAE3_FLR_RESET:
+ 		ret = hclge_set_all_vf_rst(hdev, false);
+ 		break;
+ 	case HNAE3_GLOBAL_RESET:
+ 	case HNAE3_IMP_RESET:
+ 		ret = hclge_set_rst_done(hdev);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	/* clear up the handshake status after re-initialize done */
+ 	hclge_reset_handshake(hdev, false);
+ 
+ 	return ret;
+ }
+ 
+ static int hclge_reset_stack(struct hclge_dev *hdev)
+ {
+ 	int ret;
+ 
+ 	ret = hclge_notify_client(hdev, HNAE3_UNINIT_CLIENT);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = hclge_reset_ae_dev(hdev->ae_dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return hclge_notify_client(hdev, HNAE3_INIT_CLIENT);
+ }
+ 
+ static int hclge_reset_prepare(struct hclge_dev *hdev)
+ {
+ 	int ret;
+ 
+ 	hdev->rst_stats.reset_cnt++;
+ 	/* perform reset of the stack & ae device for a client */
+ 	ret = hclge_notify_roce_client(hdev, HNAE3_DOWN_CLIENT);
+ 	if (ret)
+ 		return ret;
+ 
+ 	rtnl_lock();
+ 	ret = hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);
+ 	rtnl_unlock();
+ 	if (ret)
+ 		return ret;
+ 
+ 	return hclge_reset_prepare_wait(hdev);
+ }
+ 
+ static int hclge_reset_rebuild(struct hclge_dev *hdev)
+ {
+ 	struct hnae3_ae_dev *ae_dev = pci_get_drvdata(hdev->pdev);
+ 	enum hnae3_reset_type reset_level;
+ 	int ret;
+ 
+ 	hdev->rst_stats.hw_reset_done_cnt++;
+ 
+ 	ret = hclge_notify_roce_client(hdev, HNAE3_UNINIT_CLIENT);
+ 	if (ret)
+ 		return ret;
+ 
+ 	rtnl_lock();
+ 	ret = hclge_reset_stack(hdev);
+ 	rtnl_unlock();
+ 	if (ret)
+ 		return ret;
+ 
+ 	hclge_clear_reset_cause(hdev);
+ 
+ 	ret = hclge_notify_roce_client(hdev, HNAE3_INIT_CLIENT);
+ 	/* ignore RoCE notify error if it fails HCLGE_RESET_MAX_FAIL_CNT - 1
+ 	 * times
+ 	 */
+ 	if (ret &&
+ 	    hdev->rst_stats.reset_fail_cnt < HCLGE_RESET_MAX_FAIL_CNT - 1)
+ 		return ret;
+ 
+ 	ret = hclge_reset_prepare_up(hdev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	rtnl_lock();
+ 	ret = hclge_notify_client(hdev, HNAE3_UP_CLIENT);
+ 	rtnl_unlock();
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = hclge_notify_roce_client(hdev, HNAE3_UP_CLIENT);
+ 	if (ret)
+ 		return ret;
+ 
+ 	hdev->last_reset_time = jiffies;
+ 	hdev->rst_stats.reset_fail_cnt = 0;
+ 	hdev->rst_stats.reset_done_cnt++;
+ 	clear_bit(HCLGE_STATE_RST_FAIL, &hdev->state);
+ 
+ 	/* if default_reset_request has a higher level reset request,
+ 	 * it should be handled as soon as possible. since some errors
+ 	 * need this kind of reset to fix.
+ 	 */
+ 	reset_level = hclge_get_reset_level(ae_dev,
+ 					    &hdev->default_reset_request);
+ 	if (reset_level != HNAE3_NONE_RESET)
+ 		set_bit(reset_level, &hdev->reset_request);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static void hclge_reset(struct hclge_dev *hdev)
  {
 -	if (hclge_reset_prepare(hdev))
 -		goto err_reset;
 -
 -	if (hclge_reset_wait(hdev))
 -		goto err_reset;
 +	struct hnae3_handle *handle;
  
 -	if (hclge_reset_rebuild(hdev))
 -		goto err_reset;
 +	/* perform reset of the stack & ae device for a client */
 +	handle = &hdev->vport[0].nic;
 +	rtnl_lock();
 +	hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);
  
 -	return;
 +	if (!hclge_reset_wait(hdev)) {
 +		hclge_notify_client(hdev, HNAE3_UNINIT_CLIENT);
 +		hclge_reset_ae_dev(hdev->ae_dev);
 +		hclge_notify_client(hdev, HNAE3_INIT_CLIENT);
  
 -err_reset:
 -	if (hclge_reset_err_handle(hdev))
 +		hclge_clear_reset_cause(hdev);
 +	} else {
 +		/* schedule again to check pending resets later */
 +		set_bit(hdev->reset_type, &hdev->reset_pending);
  		hclge_reset_task_schedule(hdev);
 +	}
 +
 +	hclge_notify_client(hdev, HNAE3_UP_CLIENT);
 +	handle->last_reset_time = jiffies;
 +	rtnl_unlock();
  }
  
 -static void hclge_reset_event(struct pci_dev *pdev, struct hnae3_handle *handle)
 +static void hclge_reset_event(struct hnae3_handle *handle)
  {
 -	struct hnae3_ae_dev *ae_dev = pci_get_drvdata(pdev);
 -	struct hclge_dev *hdev = ae_dev->priv;
 +	struct hclge_vport *vport = hclge_get_vport(handle);
 +	struct hclge_dev *hdev = vport->back;
  
 -	/* We might end up getting called broadly because of 2 below cases:
 -	 * 1. Recoverable error was conveyed through APEI and only way to bring
 -	 *    normalcy is to reset.
 -	 * 2. A new reset request from the stack due to timeout
 -	 *
 -	 * For the first case,error event might not have ae handle available.
 -	 * check if this is a new reset request and we are not here just because
 +	/* check if this is a new reset request and we are not here just because
  	 * last reset attempt did not succeed and watchdog hit us again. We will
  	 * know this if last reset request did not occur very recently (watchdog
  	 * timer = 5*HZ, let us check after sufficiently large time, say 4*5*Hz)
diff --cc drivers/net/ethernet/ibm/ehea/ehea_main.c
index 5e685edea4b4,3153d62cc73e..000000000000
--- a/drivers/net/ethernet/ibm/ehea/ehea_main.c
+++ b/drivers/net/ethernet/ibm/ehea/ehea_main.c
@@@ -3279,7 -3247,7 +3279,11 @@@ static int ehea_mem_notifier(struct not
  	switch (action) {
  	case MEM_CANCEL_OFFLINE:
  		pr_info("memory offlining canceled");
++<<<<<<< HEAD
 +		/* Fall through: re-add canceled memory block */
++=======
+ 		fallthrough;	/* re-add canceled memory block */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case MEM_ONLINE:
  		pr_info("memory is going online");
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index 3a4d0ebb03e3,664e8ccc88d2..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -4086,10 -4079,8 +4086,13 @@@ void e1000e_reset(struct e1000_adapter 
  	case e1000_pch_lpt:
  	case e1000_pch_spt:
  	case e1000_pch_cnp:
++<<<<<<< HEAD
 +		/* fall-through */
++=======
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case e1000_pch_tgp:
  	case e1000_pch_adp:
 +	case e1000_pch_mtp:
  		fc->refresh_time = 0xFFFF;
  		fc->pause_time = 0xFFFF;
  
diff --cc drivers/net/ethernet/intel/igb/igb_main.c
index cac2cc1a3d05,d9c3a6b169f9..000000000000
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@@ -727,7 -718,6 +727,10 @@@ static void igb_cache_ring_register(str
  	case e1000_i354:
  	case e1000_i210:
  	case e1000_i211:
++<<<<<<< HEAD
 +		/* Fall through */
++=======
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		for (; i < adapter->num_rx_queues; i++)
  			adapter->rx_ring[i]->reg_idx = rbase_offset + i;
diff --cc drivers/net/ethernet/marvell/mvneta.c
index f2cdc95883b4,dfcb1767acbb..000000000000
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@@ -1894,11 -1964,374 +1894,377 @@@ static void mvneta_rxq_drop_pkts(struc
  	for (i = 0; i < rxq->size; i++) {
  		struct mvneta_rx_desc *rx_desc = rxq->descs + i;
  		void *data = rxq->buf_virt_addr[i];
 -		if (!data || !(rx_desc->buf_phys_addr))
 -			continue;
  
 -		page_pool_put_full_page(rxq->page_pool, data, false);
 +		dma_unmap_single(pp->dev->dev.parent, rx_desc->buf_phys_addr,
 +				 MVNETA_RX_BUF_SIZE(pp->pkt_size), DMA_FROM_DEVICE);
 +		mvneta_frag_free(pp->frag_size, data);
  	}
++<<<<<<< HEAD
++=======
+ 	if (xdp_rxq_info_is_reg(&rxq->xdp_rxq))
+ 		xdp_rxq_info_unreg(&rxq->xdp_rxq);
+ 	page_pool_destroy(rxq->page_pool);
+ 	rxq->page_pool = NULL;
+ }
+ 
+ static void
+ mvneta_update_stats(struct mvneta_port *pp,
+ 		    struct mvneta_stats *ps)
+ {
+ 	struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
+ 
+ 	u64_stats_update_begin(&stats->syncp);
+ 	stats->es.ps.rx_packets += ps->rx_packets;
+ 	stats->es.ps.rx_bytes += ps->rx_bytes;
+ 	/* xdp */
+ 	stats->es.ps.xdp_redirect += ps->xdp_redirect;
+ 	stats->es.ps.xdp_pass += ps->xdp_pass;
+ 	stats->es.ps.xdp_drop += ps->xdp_drop;
+ 	u64_stats_update_end(&stats->syncp);
+ }
+ 
+ static inline
+ int mvneta_rx_refill_queue(struct mvneta_port *pp, struct mvneta_rx_queue *rxq)
+ {
+ 	struct mvneta_rx_desc *rx_desc;
+ 	int curr_desc = rxq->first_to_refill;
+ 	int i;
+ 
+ 	for (i = 0; (i < rxq->refill_num) && (i < 64); i++) {
+ 		rx_desc = rxq->descs + curr_desc;
+ 		if (!(rx_desc->buf_phys_addr)) {
+ 			if (mvneta_rx_refill(pp, rx_desc, rxq, GFP_ATOMIC)) {
+ 				struct mvneta_pcpu_stats *stats;
+ 
+ 				pr_err("Can't refill queue %d. Done %d from %d\n",
+ 				       rxq->id, i, rxq->refill_num);
+ 
+ 				stats = this_cpu_ptr(pp->stats);
+ 				u64_stats_update_begin(&stats->syncp);
+ 				stats->es.refill_error++;
+ 				u64_stats_update_end(&stats->syncp);
+ 				break;
+ 			}
+ 		}
+ 		curr_desc = MVNETA_QUEUE_NEXT_DESC(rxq, curr_desc);
+ 	}
+ 	rxq->refill_num -= i;
+ 	rxq->first_to_refill = curr_desc;
+ 
+ 	return i;
+ }
+ 
+ static void
+ mvneta_xdp_put_buff(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
+ 		    struct xdp_buff *xdp, int sync_len, bool napi)
+ {
+ 	struct skb_shared_info *sinfo = xdp_get_shared_info_from_buff(xdp);
+ 	int i;
+ 
+ 	page_pool_put_page(rxq->page_pool, virt_to_head_page(xdp->data),
+ 			   sync_len, napi);
+ 	for (i = 0; i < sinfo->nr_frags; i++)
+ 		page_pool_put_full_page(rxq->page_pool,
+ 					skb_frag_page(&sinfo->frags[i]), napi);
+ }
+ 
+ static int
+ mvneta_xdp_submit_frame(struct mvneta_port *pp, struct mvneta_tx_queue *txq,
+ 			struct xdp_frame *xdpf, bool dma_map)
+ {
+ 	struct mvneta_tx_desc *tx_desc;
+ 	struct mvneta_tx_buf *buf;
+ 	dma_addr_t dma_addr;
+ 
+ 	if (txq->count >= txq->tx_stop_threshold)
+ 		return MVNETA_XDP_DROPPED;
+ 
+ 	tx_desc = mvneta_txq_next_desc_get(txq);
+ 
+ 	buf = &txq->buf[txq->txq_put_index];
+ 	if (dma_map) {
+ 		/* ndo_xdp_xmit */
+ 		dma_addr = dma_map_single(pp->dev->dev.parent, xdpf->data,
+ 					  xdpf->len, DMA_TO_DEVICE);
+ 		if (dma_mapping_error(pp->dev->dev.parent, dma_addr)) {
+ 			mvneta_txq_desc_put(txq);
+ 			return MVNETA_XDP_DROPPED;
+ 		}
+ 		buf->type = MVNETA_TYPE_XDP_NDO;
+ 	} else {
+ 		struct page *page = virt_to_page(xdpf->data);
+ 
+ 		dma_addr = page_pool_get_dma_addr(page) +
+ 			   sizeof(*xdpf) + xdpf->headroom;
+ 		dma_sync_single_for_device(pp->dev->dev.parent, dma_addr,
+ 					   xdpf->len, DMA_BIDIRECTIONAL);
+ 		buf->type = MVNETA_TYPE_XDP_TX;
+ 	}
+ 	buf->xdpf = xdpf;
+ 
+ 	tx_desc->command = MVNETA_TXD_FLZ_DESC;
+ 	tx_desc->buf_phys_addr = dma_addr;
+ 	tx_desc->data_size = xdpf->len;
+ 
+ 	mvneta_txq_inc_put(txq);
+ 	txq->pending++;
+ 	txq->count++;
+ 
+ 	return MVNETA_XDP_TX;
+ }
+ 
+ static int
+ mvneta_xdp_xmit_back(struct mvneta_port *pp, struct xdp_buff *xdp)
+ {
+ 	struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
+ 	struct mvneta_tx_queue *txq;
+ 	struct netdev_queue *nq;
+ 	struct xdp_frame *xdpf;
+ 	int cpu;
+ 	u32 ret;
+ 
+ 	xdpf = xdp_convert_buff_to_frame(xdp);
+ 	if (unlikely(!xdpf))
+ 		return MVNETA_XDP_DROPPED;
+ 
+ 	cpu = smp_processor_id();
+ 	txq = &pp->txqs[cpu % txq_number];
+ 	nq = netdev_get_tx_queue(pp->dev, txq->id);
+ 
+ 	__netif_tx_lock(nq, cpu);
+ 	ret = mvneta_xdp_submit_frame(pp, txq, xdpf, false);
+ 	if (ret == MVNETA_XDP_TX) {
+ 		u64_stats_update_begin(&stats->syncp);
+ 		stats->es.ps.tx_bytes += xdpf->len;
+ 		stats->es.ps.tx_packets++;
+ 		stats->es.ps.xdp_tx++;
+ 		u64_stats_update_end(&stats->syncp);
+ 
+ 		mvneta_txq_pend_desc_add(pp, txq, 0);
+ 	} else {
+ 		u64_stats_update_begin(&stats->syncp);
+ 		stats->es.ps.xdp_tx_err++;
+ 		u64_stats_update_end(&stats->syncp);
+ 	}
+ 	__netif_tx_unlock(nq);
+ 
+ 	return ret;
+ }
+ 
+ static int
+ mvneta_xdp_xmit(struct net_device *dev, int num_frame,
+ 		struct xdp_frame **frames, u32 flags)
+ {
+ 	struct mvneta_port *pp = netdev_priv(dev);
+ 	struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
+ 	int i, nxmit_byte = 0, nxmit = num_frame;
+ 	int cpu = smp_processor_id();
+ 	struct mvneta_tx_queue *txq;
+ 	struct netdev_queue *nq;
+ 	u32 ret;
+ 
+ 	if (unlikely(test_bit(__MVNETA_DOWN, &pp->state)))
+ 		return -ENETDOWN;
+ 
+ 	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
+ 		return -EINVAL;
+ 
+ 	txq = &pp->txqs[cpu % txq_number];
+ 	nq = netdev_get_tx_queue(pp->dev, txq->id);
+ 
+ 	__netif_tx_lock(nq, cpu);
+ 	for (i = 0; i < num_frame; i++) {
+ 		ret = mvneta_xdp_submit_frame(pp, txq, frames[i], true);
+ 		if (ret == MVNETA_XDP_TX) {
+ 			nxmit_byte += frames[i]->len;
+ 		} else {
+ 			xdp_return_frame_rx_napi(frames[i]);
+ 			nxmit--;
+ 		}
+ 	}
+ 
+ 	if (unlikely(flags & XDP_XMIT_FLUSH))
+ 		mvneta_txq_pend_desc_add(pp, txq, 0);
+ 	__netif_tx_unlock(nq);
+ 
+ 	u64_stats_update_begin(&stats->syncp);
+ 	stats->es.ps.tx_bytes += nxmit_byte;
+ 	stats->es.ps.tx_packets += nxmit;
+ 	stats->es.ps.xdp_xmit += nxmit;
+ 	stats->es.ps.xdp_xmit_err += num_frame - nxmit;
+ 	u64_stats_update_end(&stats->syncp);
+ 
+ 	return nxmit;
+ }
+ 
+ static int
+ mvneta_run_xdp(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
+ 	       struct bpf_prog *prog, struct xdp_buff *xdp,
+ 	       u32 frame_sz, struct mvneta_stats *stats)
+ {
+ 	unsigned int len, data_len, sync;
+ 	u32 ret, act;
+ 
+ 	len = xdp->data_end - xdp->data_hard_start - pp->rx_offset_correction;
+ 	data_len = xdp->data_end - xdp->data;
+ 	act = bpf_prog_run_xdp(prog, xdp);
+ 
+ 	/* Due xdp_adjust_tail: DMA sync for_device cover max len CPU touch */
+ 	sync = xdp->data_end - xdp->data_hard_start - pp->rx_offset_correction;
+ 	sync = max(sync, len);
+ 
+ 	switch (act) {
+ 	case XDP_PASS:
+ 		stats->xdp_pass++;
+ 		return MVNETA_XDP_PASS;
+ 	case XDP_REDIRECT: {
+ 		int err;
+ 
+ 		err = xdp_do_redirect(pp->dev, xdp, prog);
+ 		if (unlikely(err)) {
+ 			mvneta_xdp_put_buff(pp, rxq, xdp, sync, true);
+ 			ret = MVNETA_XDP_DROPPED;
+ 		} else {
+ 			ret = MVNETA_XDP_REDIR;
+ 			stats->xdp_redirect++;
+ 		}
+ 		break;
+ 	}
+ 	case XDP_TX:
+ 		ret = mvneta_xdp_xmit_back(pp, xdp);
+ 		if (ret != MVNETA_XDP_TX)
+ 			mvneta_xdp_put_buff(pp, rxq, xdp, sync, true);
+ 		break;
+ 	default:
+ 		bpf_warn_invalid_xdp_action(act);
+ 		fallthrough;
+ 	case XDP_ABORTED:
+ 		trace_xdp_exception(pp->dev, prog, act);
+ 		fallthrough;
+ 	case XDP_DROP:
+ 		mvneta_xdp_put_buff(pp, rxq, xdp, sync, true);
+ 		ret = MVNETA_XDP_DROPPED;
+ 		stats->xdp_drop++;
+ 		break;
+ 	}
+ 
+ 	stats->rx_bytes += frame_sz + xdp->data_end - xdp->data - data_len;
+ 	stats->rx_packets++;
+ 
+ 	return ret;
+ }
+ 
+ static void
+ mvneta_swbm_rx_frame(struct mvneta_port *pp,
+ 		     struct mvneta_rx_desc *rx_desc,
+ 		     struct mvneta_rx_queue *rxq,
+ 		     struct xdp_buff *xdp, int *size,
+ 		     struct page *page,
+ 		     struct mvneta_stats *stats)
+ {
+ 	unsigned char *data = page_address(page);
+ 	int data_len = -MVNETA_MH_SIZE, len;
+ 	struct net_device *dev = pp->dev;
+ 	enum dma_data_direction dma_dir;
+ 	struct skb_shared_info *sinfo;
+ 
+ 	if (MVNETA_SKB_SIZE(rx_desc->data_size) > PAGE_SIZE) {
+ 		len = MVNETA_MAX_RX_BUF_SIZE;
+ 		data_len += len;
+ 	} else {
+ 		len = rx_desc->data_size;
+ 		data_len += len - ETH_FCS_LEN;
+ 	}
+ 
+ 	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
+ 	dma_sync_single_for_cpu(dev->dev.parent,
+ 				rx_desc->buf_phys_addr,
+ 				len, dma_dir);
+ 
+ 	/* Prefetch header */
+ 	prefetch(data);
+ 
+ 	xdp->data_hard_start = data;
+ 	xdp->data = data + pp->rx_offset_correction + MVNETA_MH_SIZE;
+ 	xdp->data_end = xdp->data + data_len;
+ 	xdp_set_data_meta_invalid(xdp);
+ 
+ 	sinfo = xdp_get_shared_info_from_buff(xdp);
+ 	sinfo->nr_frags = 0;
+ 
+ 	*size = rx_desc->data_size - len;
+ 	rx_desc->buf_phys_addr = 0;
+ }
+ 
+ static void
+ mvneta_swbm_add_rx_fragment(struct mvneta_port *pp,
+ 			    struct mvneta_rx_desc *rx_desc,
+ 			    struct mvneta_rx_queue *rxq,
+ 			    struct xdp_buff *xdp, int *size,
+ 			    struct page *page)
+ {
+ 	struct skb_shared_info *sinfo = xdp_get_shared_info_from_buff(xdp);
+ 	struct net_device *dev = pp->dev;
+ 	enum dma_data_direction dma_dir;
+ 	int data_len, len;
+ 
+ 	if (*size > MVNETA_MAX_RX_BUF_SIZE) {
+ 		len = MVNETA_MAX_RX_BUF_SIZE;
+ 		data_len = len;
+ 	} else {
+ 		len = *size;
+ 		data_len = len - ETH_FCS_LEN;
+ 	}
+ 	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
+ 	dma_sync_single_for_cpu(dev->dev.parent,
+ 				rx_desc->buf_phys_addr,
+ 				len, dma_dir);
+ 
+ 	if (data_len > 0 && sinfo->nr_frags < MAX_SKB_FRAGS) {
+ 		skb_frag_t *frag = &sinfo->frags[sinfo->nr_frags];
+ 
+ 		skb_frag_off_set(frag, pp->rx_offset_correction);
+ 		skb_frag_size_set(frag, data_len);
+ 		__skb_frag_set_page(frag, page);
+ 		sinfo->nr_frags++;
+ 
+ 		rx_desc->buf_phys_addr = 0;
+ 	}
+ 	*size -= len;
+ }
+ 
+ static struct sk_buff *
+ mvneta_swbm_build_skb(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
+ 		      struct xdp_buff *xdp, u32 desc_status)
+ {
+ 	struct skb_shared_info *sinfo = xdp_get_shared_info_from_buff(xdp);
+ 	int i, num_frags = sinfo->nr_frags;
+ 	skb_frag_t frags[MAX_SKB_FRAGS];
+ 	struct sk_buff *skb;
+ 
+ 	memcpy(frags, sinfo->frags, sizeof(skb_frag_t) * num_frags);
+ 
+ 	skb = build_skb(xdp->data_hard_start, PAGE_SIZE);
+ 	if (!skb)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	page_pool_release_page(rxq->page_pool, virt_to_page(xdp->data));
+ 
+ 	skb_reserve(skb, xdp->data - xdp->data_hard_start);
+ 	skb_put(skb, xdp->data_end - xdp->data);
+ 	mvneta_rx_csum(pp, desc_status, skb);
+ 
+ 	for (i = 0; i < num_frags; i++) {
+ 		struct page *page = skb_frag_page(&frags[i]);
+ 
+ 		skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,
+ 				page, skb_frag_off(&frags[i]),
+ 				skb_frag_size(&frags[i]), PAGE_SIZE);
+ 		page_pool_release_page(rxq->page_pool, page);
+ 	}
+ 
+ 	return skb;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  }
  
  /* Main rx processing when using software buffer management */
diff --cc drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c
index 8581d5b17dd5,41d935d1aaf6..000000000000
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c
@@@ -115,27 -1476,267 +115,219 @@@ void mvpp22_init_rss(struct mvpp2_port 
  	/* Set the table width: replace the whole classifier Rx queue number
  	 * with the ones configured in RSS table entries.
  	 */
 -	mvpp2_write(priv, MVPP22_RSS_INDEX, MVPP22_RSS_INDEX_TABLE(ctx));
 +	mvpp2_write(priv, MVPP22_RSS_INDEX, MVPP22_RSS_INDEX_TABLE(0));
  	mvpp2_write(priv, MVPP22_RSS_WIDTH, 8);
  
 -	mvpp2_write(priv, MVPP22_RSS_INDEX, MVPP22_RSS_INDEX_QUEUE(ctx));
 -	mvpp2_write(priv, MVPP22_RXQ2RSS_TABLE, MVPP22_RSS_TABLE_POINTER(ctx));
 -
 -	return 0;
 -}
 -
 -int mvpp22_port_rss_ctx_create(struct mvpp2_port *port, u32 *port_ctx)
 -{
 -	u32 rss_ctx;
 -	int ret, i;
 -
 -	ret = mvpp22_rss_context_create(port, &rss_ctx);
 -	if (ret)
 -		return ret;
 -
 -	/* Find the first available context number in the port, starting from 1.
 -	 * Context 0 on each port is reserved for the default context.
 +	/* Loop through the classifier Rx Queues and map them to a RSS table.
 +	 * Map them all to the first table (0) by default.
  	 */
 -	for (i = 1; i < MVPP22_N_RSS_TABLES; i++) {
 -		if (port->rss_ctx[i] < 0)
 -			break;
 +	for (i = 0; i < MVPP2_CLS_RX_QUEUES; i++) {
 +		mvpp2_write(priv, MVPP22_RSS_INDEX, MVPP22_RSS_INDEX_QUEUE(i));
 +		mvpp2_write(priv, MVPP22_RSS_TABLE,
 +			    MVPP22_RSS_TABLE_POINTER(0));
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (i == MVPP22_N_RSS_TABLES)
+ 		return -EINVAL;
+ 
+ 	port->rss_ctx[i] = rss_ctx;
+ 	*port_ctx = i;
+ 
+ 	return 0;
+ }
+ 
+ static struct mvpp2_rss_table *mvpp22_rss_table_get(struct mvpp2 *priv,
+ 						    int rss_ctx)
+ {
+ 	if (rss_ctx < 0 || rss_ctx >= MVPP22_N_RSS_TABLES)
+ 		return NULL;
+ 
+ 	return priv->rss_tables[rss_ctx];
+ }
+ 
+ int mvpp22_port_rss_ctx_delete(struct mvpp2_port *port, u32 port_ctx)
+ {
+ 	struct mvpp2 *priv = port->priv;
+ 	struct ethtool_rxnfc *rxnfc;
+ 	int i, rss_ctx, ret;
+ 
+ 	rss_ctx = mvpp22_rss_ctx(port, port_ctx);
+ 
+ 	if (rss_ctx < 0 || rss_ctx >= MVPP22_N_RSS_TABLES)
+ 		return -EINVAL;
+ 
+ 	/* Invalidate any active classification rule that use this context */
+ 	for (i = 0; i < MVPP2_N_RFS_ENTRIES_PER_FLOW; i++) {
+ 		if (!port->rfs_rules[i])
+ 			continue;
+ 
+ 		rxnfc = &port->rfs_rules[i]->rxnfc;
+ 		if (!(rxnfc->fs.flow_type & FLOW_RSS) ||
+ 		    rxnfc->rss_context != port_ctx)
+ 			continue;
+ 
+ 		ret = mvpp2_ethtool_cls_rule_del(port, rxnfc);
+ 		if (ret) {
+ 			netdev_warn(port->dev,
+ 				    "couldn't remove classification rule %d associated to this context",
+ 				    rxnfc->fs.location);
+ 		}
+ 	}
+ 
+ 	kfree(priv->rss_tables[rss_ctx]);
+ 
+ 	priv->rss_tables[rss_ctx] = NULL;
+ 	port->rss_ctx[port_ctx] = -1;
+ 
+ 	return 0;
+ }
+ 
+ int mvpp22_port_rss_ctx_indir_set(struct mvpp2_port *port, u32 port_ctx,
+ 				  const u32 *indir)
+ {
+ 	int rss_ctx = mvpp22_rss_ctx(port, port_ctx);
+ 	struct mvpp2_rss_table *rss_table = mvpp22_rss_table_get(port->priv,
+ 								 rss_ctx);
+ 
+ 	if (!rss_table)
+ 		return -EINVAL;
+ 
+ 	memcpy(rss_table->indir, indir,
+ 	       MVPP22_RSS_TABLE_ENTRIES * sizeof(rss_table->indir[0]));
+ 
+ 	mvpp22_rss_fill_table(port, rss_table, rss_ctx);
+ 
+ 	return 0;
+ }
+ 
+ int mvpp22_port_rss_ctx_indir_get(struct mvpp2_port *port, u32 port_ctx,
+ 				  u32 *indir)
+ {
+ 	int rss_ctx =  mvpp22_rss_ctx(port, port_ctx);
+ 	struct mvpp2_rss_table *rss_table = mvpp22_rss_table_get(port->priv,
+ 								 rss_ctx);
+ 
+ 	if (!rss_table)
+ 		return -EINVAL;
+ 
+ 	memcpy(indir, rss_table->indir,
+ 	       MVPP22_RSS_TABLE_ENTRIES * sizeof(rss_table->indir[0]));
+ 
+ 	return 0;
+ }
+ 
+ int mvpp2_ethtool_rxfh_set(struct mvpp2_port *port, struct ethtool_rxnfc *info)
+ {
+ 	u16 hash_opts = 0;
+ 	u32 flow_type;
+ 
+ 	flow_type = mvpp2_cls_ethtool_flow_to_type(info->flow_type);
+ 
+ 	switch (flow_type) {
+ 	case MVPP22_FLOW_TCP4:
+ 	case MVPP22_FLOW_UDP4:
+ 	case MVPP22_FLOW_TCP6:
+ 	case MVPP22_FLOW_UDP6:
+ 		if (info->data & RXH_L4_B_0_1)
+ 			hash_opts |= MVPP22_CLS_HEK_OPT_L4SIP;
+ 		if (info->data & RXH_L4_B_2_3)
+ 			hash_opts |= MVPP22_CLS_HEK_OPT_L4DIP;
+ 		fallthrough;
+ 	case MVPP22_FLOW_IP4:
+ 	case MVPP22_FLOW_IP6:
+ 		if (info->data & RXH_L2DA)
+ 			hash_opts |= MVPP22_CLS_HEK_OPT_MAC_DA;
+ 		if (info->data & RXH_VLAN)
+ 			hash_opts |= MVPP22_CLS_HEK_OPT_VLAN;
+ 		if (info->data & RXH_L3_PROTO)
+ 			hash_opts |= MVPP22_CLS_HEK_OPT_L3_PROTO;
+ 		if (info->data & RXH_IP_SRC)
+ 			hash_opts |= (MVPP22_CLS_HEK_OPT_IP4SA |
+ 				     MVPP22_CLS_HEK_OPT_IP6SA);
+ 		if (info->data & RXH_IP_DST)
+ 			hash_opts |= (MVPP22_CLS_HEK_OPT_IP4DA |
+ 				     MVPP22_CLS_HEK_OPT_IP6DA);
+ 		break;
+ 	default: return -EOPNOTSUPP;
+ 	}
+ 
+ 	return mvpp2_port_rss_hash_opts_set(port, flow_type, hash_opts);
+ }
+ 
+ int mvpp2_ethtool_rxfh_get(struct mvpp2_port *port, struct ethtool_rxnfc *info)
+ {
+ 	unsigned long hash_opts;
+ 	u32 flow_type;
+ 	int i;
+ 
+ 	flow_type = mvpp2_cls_ethtool_flow_to_type(info->flow_type);
+ 
+ 	hash_opts = mvpp2_port_rss_hash_opts_get(port, flow_type);
+ 	info->data = 0;
+ 
+ 	for_each_set_bit(i, &hash_opts, MVPP22_CLS_HEK_N_FIELDS) {
+ 		switch (BIT(i)) {
+ 		case MVPP22_CLS_HEK_OPT_MAC_DA:
+ 			info->data |= RXH_L2DA;
+ 			break;
+ 		case MVPP22_CLS_HEK_OPT_VLAN:
+ 			info->data |= RXH_VLAN;
+ 			break;
+ 		case MVPP22_CLS_HEK_OPT_L3_PROTO:
+ 			info->data |= RXH_L3_PROTO;
+ 			break;
+ 		case MVPP22_CLS_HEK_OPT_IP4SA:
+ 		case MVPP22_CLS_HEK_OPT_IP6SA:
+ 			info->data |= RXH_IP_SRC;
+ 			break;
+ 		case MVPP22_CLS_HEK_OPT_IP4DA:
+ 		case MVPP22_CLS_HEK_OPT_IP6DA:
+ 			info->data |= RXH_IP_DST;
+ 			break;
+ 		case MVPP22_CLS_HEK_OPT_L4SIP:
+ 			info->data |= RXH_L4_B_0_1;
+ 			break;
+ 		case MVPP22_CLS_HEK_OPT_L4DIP:
+ 			info->data |= RXH_L4_B_2_3;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ int mvpp22_port_rss_init(struct mvpp2_port *port)
+ {
+ 	struct mvpp2_rss_table *table;
+ 	u32 context = 0;
+ 	int i, ret;
+ 
+ 	for (i = 0; i < MVPP22_N_RSS_TABLES; i++)
+ 		port->rss_ctx[i] = -1;
+ 
+ 	ret = mvpp22_rss_context_create(port, &context);
+ 	if (ret)
+ 		return ret;
+ 
+ 	table = mvpp22_rss_table_get(port->priv, context);
+ 	if (!table)
+ 		return -EINVAL;
+ 
+ 	port->rss_ctx[0] = context;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	/* Configure the first table to evenly distribute the packets across
 -	 * real Rx Queues. The table entries map a hash to a port Rx Queue.
 +	 * real Rx Queues. The table entries map a hash to an port Rx Queue.
  	 */
 -	for (i = 0; i < MVPP22_RSS_TABLE_ENTRIES; i++)
 -		table->indir[i] = ethtool_rxfh_indir_default(i, port->nrxqs);
 -
 -	mvpp22_rss_fill_table(port, table, mvpp22_rss_ctx(port, 0));
 +	for (i = 0; i < MVPP22_RSS_TABLE_ENTRIES; i++) {
 +		u32 sel = MVPP22_RSS_INDEX_TABLE(0) |
 +			  MVPP22_RSS_INDEX_TABLE_ENTRY(i);
 +		mvpp2_write(priv, MVPP22_RSS_INDEX, sel);
  
 -	/* Configure default flows */
 -	mvpp2_port_rss_hash_opts_set(port, MVPP22_FLOW_IP4, MVPP22_CLS_HEK_IP4_2T);
 -	mvpp2_port_rss_hash_opts_set(port, MVPP22_FLOW_IP6, MVPP22_CLS_HEK_IP6_2T);
 -	mvpp2_port_rss_hash_opts_set(port, MVPP22_FLOW_TCP4, MVPP22_CLS_HEK_IP4_5T);
 -	mvpp2_port_rss_hash_opts_set(port, MVPP22_FLOW_TCP6, MVPP22_CLS_HEK_IP6_5T);
 -	mvpp2_port_rss_hash_opts_set(port, MVPP22_FLOW_UDP4, MVPP22_CLS_HEK_IP4_5T);
 -	mvpp2_port_rss_hash_opts_set(port, MVPP22_FLOW_UDP6, MVPP22_CLS_HEK_IP6_5T);
 +		mvpp2_write(priv, MVPP22_RSS_TABLE_ENTRY, i % port->nrxqs);
 +	}
  
 -	return 0;
  }
diff --cc drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index ffcc39fb56ba,6e140d1b8967..000000000000
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@@ -4161,26 -5423,50 +4161,57 @@@ static void mvpp2_phylink_validate(stru
  	phylink_set(mask, Asym_Pause);
  
  	switch (state->interface) {
++<<<<<<< HEAD
 +	case PHY_INTERFACE_MODE_10GKR:
 +		phylink_set(mask, 10000baseCR_Full);
 +		phylink_set(mask, 10000baseSR_Full);
 +		phylink_set(mask, 10000baseLR_Full);
 +		phylink_set(mask, 10000baseLRM_Full);
 +		phylink_set(mask, 10000baseER_Full);
 +		phylink_set(mask, 10000baseKR_Full);
 +		/* Fall-through */
 +	default:
++=======
+ 	case PHY_INTERFACE_MODE_10GBASER:
+ 	case PHY_INTERFACE_MODE_XAUI:
+ 	case PHY_INTERFACE_MODE_NA:
+ 		if (mvpp2_port_supports_xlg(port)) {
+ 			phylink_set(mask, 10000baseT_Full);
+ 			phylink_set(mask, 10000baseCR_Full);
+ 			phylink_set(mask, 10000baseSR_Full);
+ 			phylink_set(mask, 10000baseLR_Full);
+ 			phylink_set(mask, 10000baseLRM_Full);
+ 			phylink_set(mask, 10000baseER_Full);
+ 			phylink_set(mask, 10000baseKR_Full);
+ 		}
+ 		if (state->interface != PHY_INTERFACE_MODE_NA)
+ 			break;
+ 		fallthrough;
+ 	case PHY_INTERFACE_MODE_RGMII:
+ 	case PHY_INTERFACE_MODE_RGMII_ID:
+ 	case PHY_INTERFACE_MODE_RGMII_RXID:
+ 	case PHY_INTERFACE_MODE_RGMII_TXID:
+ 	case PHY_INTERFACE_MODE_SGMII:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		phylink_set(mask, 10baseT_Half);
  		phylink_set(mask, 10baseT_Full);
  		phylink_set(mask, 100baseT_Half);
  		phylink_set(mask, 100baseT_Full);
++<<<<<<< HEAD
 +		phylink_set(mask, 10000baseT_Full);
 +		/* Fall-through */
++=======
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseX_Full);
+ 		if (state->interface != PHY_INTERFACE_MODE_NA)
+ 			break;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case PHY_INTERFACE_MODE_1000BASEX:
  	case PHY_INTERFACE_MODE_2500BASEX:
 -		if (port->comphy ||
 -		    state->interface != PHY_INTERFACE_MODE_2500BASEX) {
 -			phylink_set(mask, 1000baseT_Full);
 -			phylink_set(mask, 1000baseX_Full);
 -		}
 -		if (port->comphy ||
 -		    state->interface == PHY_INTERFACE_MODE_2500BASEX) {
 -			phylink_set(mask, 2500baseT_Full);
 -			phylink_set(mask, 2500baseX_Full);
 -		}
 -		break;
 -	default:
 -		goto empty_set;
 +		phylink_set(mask, 1000baseT_Full);
 +		phylink_set(mask, 1000baseX_Full);
 +		phylink_set(mask, 2500baseX_Full);
  	}
  
  	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
diff --cc drivers/net/ethernet/mediatek/mtk_eth_soc.c
index e558deb9449b,6d2d60675ffd..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@@ -165,210 -208,353 +165,293 @@@ static void mtk_gmac0_rgmii_adjust(stru
  	mtk_w32(eth, val, TRGMII_TCK_CTRL);
  }
  
 -static void mtk_mac_config(struct phylink_config *config, unsigned int mode,
 -			   const struct phylink_link_state *state)
 +static void mtk_gmac_sgmii_hw_setup(struct mtk_eth *eth, int mac_id)
  {
 -	struct mtk_mac *mac = container_of(config, struct mtk_mac,
 -					   phylink_config);
 -	struct mtk_eth *eth = mac->hw;
 -	u32 mcr_cur, mcr_new, sid, i;
 -	int val, ge_mode, err;
 +	u32 val;
  
++<<<<<<< HEAD
 +	/* Setup the link timer and QPHY power up inside SGMIISYS */
 +	regmap_write(eth->sgmiisys, SGMSYS_PCS_LINK_TIMER,
 +		     SGMII_LINK_TIMER_DEFAULT);
++=======
+ 	/* MT76x8 has no hardware settings between for the MAC */
+ 	if (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628) &&
+ 	    mac->interface != state->interface) {
+ 		/* Setup soc pin functions */
+ 		switch (state->interface) {
+ 		case PHY_INTERFACE_MODE_TRGMII:
+ 			if (mac->id)
+ 				goto err_phy;
+ 			if (!MTK_HAS_CAPS(mac->hw->soc->caps,
+ 					  MTK_GMAC1_TRGMII))
+ 				goto err_phy;
+ 			fallthrough;
+ 		case PHY_INTERFACE_MODE_RGMII_TXID:
+ 		case PHY_INTERFACE_MODE_RGMII_RXID:
+ 		case PHY_INTERFACE_MODE_RGMII_ID:
+ 		case PHY_INTERFACE_MODE_RGMII:
+ 		case PHY_INTERFACE_MODE_MII:
+ 		case PHY_INTERFACE_MODE_REVMII:
+ 		case PHY_INTERFACE_MODE_RMII:
+ 			if (MTK_HAS_CAPS(eth->soc->caps, MTK_RGMII)) {
+ 				err = mtk_gmac_rgmii_path_setup(eth, mac->id);
+ 				if (err)
+ 					goto init_err;
+ 			}
+ 			break;
+ 		case PHY_INTERFACE_MODE_1000BASEX:
+ 		case PHY_INTERFACE_MODE_2500BASEX:
+ 		case PHY_INTERFACE_MODE_SGMII:
+ 			if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII)) {
+ 				err = mtk_gmac_sgmii_path_setup(eth, mac->id);
+ 				if (err)
+ 					goto init_err;
+ 			}
+ 			break;
+ 		case PHY_INTERFACE_MODE_GMII:
+ 			if (MTK_HAS_CAPS(eth->soc->caps, MTK_GEPHY)) {
+ 				err = mtk_gmac_gephy_path_setup(eth, mac->id);
+ 				if (err)
+ 					goto init_err;
+ 			}
+ 			break;
+ 		default:
+ 			goto err_phy;
+ 		}
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -		/* Setup clock for 1st gmac */
 -		if (!mac->id && state->interface != PHY_INTERFACE_MODE_SGMII &&
 -		    !phy_interface_mode_is_8023z(state->interface) &&
 -		    MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII)) {
 -			if (MTK_HAS_CAPS(mac->hw->soc->caps,
 -					 MTK_TRGMII_MT7621_CLK)) {
 -				if (mt7621_gmac0_rgmii_adjust(mac->hw,
 -							      state->interface))
 -					goto err_phy;
 -			} else {
 -				mtk_gmac0_rgmii_adjust(mac->hw,
 -						       state->interface,
 -						       state->speed);
 -
 -				/* mt7623_pad_clk_setup */
 -				for (i = 0 ; i < NUM_TRGMII_CTRL; i++)
 -					mtk_w32(mac->hw,
 -						TD_DM_DRVP(8) | TD_DM_DRVN(8),
 -						TRGMII_TD_ODT(i));
 -
 -				/* Assert/release MT7623 RXC reset */
 -				mtk_m32(mac->hw, 0, RXC_RST | RXC_DQSISEL,
 -					TRGMII_RCK_CTRL);
 -				mtk_m32(mac->hw, RXC_RST, 0, TRGMII_RCK_CTRL);
 -			}
 -		}
 +	regmap_read(eth->sgmiisys, SGMSYS_SGMII_MODE, &val);
 +	val |= SGMII_REMOTE_FAULT_DIS;
 +	regmap_write(eth->sgmiisys, SGMSYS_SGMII_MODE, val);
  
 -		ge_mode = 0;
 -		switch (state->interface) {
 -		case PHY_INTERFACE_MODE_MII:
 -		case PHY_INTERFACE_MODE_GMII:
 -			ge_mode = 1;
 -			break;
 -		case PHY_INTERFACE_MODE_REVMII:
 -			ge_mode = 2;
 -			break;
 -		case PHY_INTERFACE_MODE_RMII:
 -			if (mac->id)
 -				goto err_phy;
 -			ge_mode = 3;
 -			break;
 -		default:
 -			break;
 -		}
 +	regmap_read(eth->sgmiisys, SGMSYS_PCS_CONTROL_1, &val);
 +	val |= SGMII_AN_RESTART;
 +	regmap_write(eth->sgmiisys, SGMSYS_PCS_CONTROL_1, val);
 +
 +	regmap_read(eth->sgmiisys, SGMSYS_QPHY_PWR_STATE_CTRL, &val);
 +	val &= ~SGMII_PHYA_PWD;
 +	regmap_write(eth->sgmiisys, SGMSYS_QPHY_PWR_STATE_CTRL, val);
  
 -		/* put the gmac into the right mode */
 +	/* Determine MUX for which GMAC uses the SGMII interface */
 +	if (MTK_HAS_CAPS(eth->soc->caps, MTK_DUAL_GMAC_SHARED_SGMII)) {
  		regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 -		val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);
 -		val |= SYSCFG0_GE_MODE(ge_mode, mac->id);
 +		val &= ~SYSCFG0_SGMII_MASK;
 +		val |= !mac_id ? SYSCFG0_SGMII_GMAC1 : SYSCFG0_SGMII_GMAC2;
  		regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
  
 -		mac->interface = state->interface;
 +		dev_info(eth->dev, "setup shared sgmii for gmac=%d\n",
 +			 mac_id);
  	}
  
 -	/* SGMII */
 -	if (state->interface == PHY_INTERFACE_MODE_SGMII ||
 -	    phy_interface_mode_is_8023z(state->interface)) {
 -		/* The path GMAC to SGMII will be enabled once the SGMIISYS is
 -		 * being setup done.
 -		 */
 -		regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 -
 -		regmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,
 -				   SYSCFG0_SGMII_MASK,
 -				   ~(u32)SYSCFG0_SGMII_MASK);
 -
 -		/* Decide how GMAC and SGMIISYS be mapped */
 -		sid = (MTK_HAS_CAPS(eth->soc->caps, MTK_SHARED_SGMII)) ?
 -		       0 : mac->id;
 -
 -		/* Setup SGMIISYS with the determined property */
 -		if (state->interface != PHY_INTERFACE_MODE_SGMII)
 -			err = mtk_sgmii_setup_mode_force(eth->sgmii, sid,
 -							 state);
 -		else if (phylink_autoneg_inband(mode))
 -			err = mtk_sgmii_setup_mode_an(eth->sgmii, sid);
 -
 -		if (err)
 -			goto init_err;
 -
 -		regmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,
 -				   SYSCFG0_SGMII_MASK, val);
 -	} else if (phylink_autoneg_inband(mode)) {
 -		dev_err(eth->dev,
 -			"In-band mode not supported in non SGMII mode!\n");
 -		return;
 +	/* Setup the GMAC1 going through SGMII path when SoC also support
 +	 * ESW on GMAC1
 +	 */
 +	if (MTK_HAS_CAPS(eth->soc->caps, MTK_GMAC1_ESW | MTK_GMAC1_SGMII) &&
 +	    !mac_id) {
 +		mtk_w32(eth, 0, MTK_MAC_MISC);
 +		dev_info(eth->dev, "setup gmac1 going through sgmii");
  	}
 -
 -	/* Setup gmac */
 -	mcr_cur = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
 -	mcr_new = mcr_cur;
 -	mcr_new |= MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |
 -		   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_LINK;
 -
 -	/* Only update control register when needed! */
 -	if (mcr_new != mcr_cur)
 -		mtk_w32(mac->hw, mcr_new, MTK_MAC_MCR(mac->id));
 -
 -	return;
 -
 -err_phy:
 -	dev_err(eth->dev, "%s: GMAC%d mode %s not supported!\n", __func__,
 -		mac->id, phy_modes(state->interface));
 -	return;
 -
 -init_err:
 -	dev_err(eth->dev, "%s: GMAC%d mode %s err: %d!\n", __func__,
 -		mac->id, phy_modes(state->interface), err);
  }
  
 -static void mtk_mac_pcs_get_state(struct phylink_config *config,
 -				  struct phylink_link_state *state)
 +static void mtk_phy_link_adjust(struct net_device *dev)
  {
 -	struct mtk_mac *mac = container_of(config, struct mtk_mac,
 -					   phylink_config);
 -	u32 pmsr = mtk_r32(mac->hw, MTK_MAC_MSR(mac->id));
 +	struct mtk_mac *mac = netdev_priv(dev);
 +	u16 lcl_adv = 0, rmt_adv = 0;
 +	u8 flowctrl;
 +	u32 mcr = MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG |
 +		  MAC_MCR_FORCE_MODE | MAC_MCR_TX_EN |
 +		  MAC_MCR_RX_EN | MAC_MCR_BACKOFF_EN |
 +		  MAC_MCR_BACKPR_EN;
  
 -	state->link = (pmsr & MAC_MSR_LINK);
 -	state->duplex = (pmsr & MAC_MSR_DPX) >> 1;
 +	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
 +		return;
  
 -	switch (pmsr & (MAC_MSR_SPEED_1000 | MAC_MSR_SPEED_100)) {
 -	case 0:
 -		state->speed = SPEED_10;
 -		break;
 -	case MAC_MSR_SPEED_100:
 -		state->speed = SPEED_100;
 -		break;
 -	case MAC_MSR_SPEED_1000:
 -		state->speed = SPEED_1000;
 +	switch (dev->phydev->speed) {
 +	case SPEED_1000:
 +		mcr |= MAC_MCR_SPEED_1000;
  		break;
 -	default:
 -		state->speed = SPEED_UNKNOWN;
 +	case SPEED_100:
 +		mcr |= MAC_MCR_SPEED_100;
  		break;
 -	}
 -
 -	state->pause &= (MLO_PAUSE_RX | MLO_PAUSE_TX);
 -	if (pmsr & MAC_MSR_RX_FC)
 -		state->pause |= MLO_PAUSE_RX;
 -	if (pmsr & MAC_MSR_TX_FC)
 -		state->pause |= MLO_PAUSE_TX;
 -}
 +	};
  
 -static void mtk_mac_an_restart(struct phylink_config *config)
 -{
 -	struct mtk_mac *mac = container_of(config, struct mtk_mac,
 -					   phylink_config);
 +	if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII) &&
 +	    !mac->id && !mac->trgmii)
 +		mtk_gmac0_rgmii_adjust(mac->hw, dev->phydev->speed);
  
 -	mtk_sgmii_restart_an(mac->hw, mac->id);
 -}
 +	if (dev->phydev->link)
 +		mcr |= MAC_MCR_FORCE_LINK;
  
 -static void mtk_mac_link_down(struct phylink_config *config, unsigned int mode,
 -			      phy_interface_t interface)
 -{
 -	struct mtk_mac *mac = container_of(config, struct mtk_mac,
 -					   phylink_config);
 -	u32 mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
 +	if (dev->phydev->duplex) {
 +		mcr |= MAC_MCR_FORCE_DPX;
  
 -	mcr &= ~(MAC_MCR_TX_EN | MAC_MCR_RX_EN);
 -	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
 -}
 +		if (dev->phydev->pause)
 +			rmt_adv = LPA_PAUSE_CAP;
 +		if (dev->phydev->asym_pause)
 +			rmt_adv |= LPA_PAUSE_ASYM;
  
 -static void mtk_mac_link_up(struct phylink_config *config,
 -			    struct phy_device *phy,
 -			    unsigned int mode, phy_interface_t interface,
 -			    int speed, int duplex, bool tx_pause, bool rx_pause)
 -{
 -	struct mtk_mac *mac = container_of(config, struct mtk_mac,
 -					   phylink_config);
 -	u32 mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
 +		lcl_adv = linkmode_adv_to_lcl_adv_t(dev->phydev->advertising);
 +		flowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);
  
 -	mcr &= ~(MAC_MCR_SPEED_100 | MAC_MCR_SPEED_1000 |
 -		 MAC_MCR_FORCE_DPX | MAC_MCR_FORCE_TX_FC |
 -		 MAC_MCR_FORCE_RX_FC);
 +		if (flowctrl & FLOW_CTRL_TX)
 +			mcr |= MAC_MCR_FORCE_TX_FC;
 +		if (flowctrl & FLOW_CTRL_RX)
 +			mcr |= MAC_MCR_FORCE_RX_FC;
  
 -	/* Configure speed */
 -	switch (speed) {
 -	case SPEED_2500:
 -	case SPEED_1000:
 -		mcr |= MAC_MCR_SPEED_1000;
 -		break;
 -	case SPEED_100:
 -		mcr |= MAC_MCR_SPEED_100;
 -		break;
 +		netif_dbg(mac->hw, link, dev, "rx pause %s, tx pause %s\n",
 +			  flowctrl & FLOW_CTRL_RX ? "enabled" : "disabled",
 +			  flowctrl & FLOW_CTRL_TX ? "enabled" : "disabled");
  	}
  
 -	/* Configure duplex */
 -	if (duplex == DUPLEX_FULL)
 -		mcr |= MAC_MCR_FORCE_DPX;
 +	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
  
 -	/* Configure pause modes - phylink will avoid these for half duplex */
 -	if (tx_pause)
 -		mcr |= MAC_MCR_FORCE_TX_FC;
 -	if (rx_pause)
 -		mcr |= MAC_MCR_FORCE_RX_FC;
 +	if (dev->phydev->link)
 +		netif_carrier_on(dev);
 +	else
 +		netif_carrier_off(dev);
  
 -	mcr |= MAC_MCR_TX_EN | MAC_MCR_RX_EN;
 -	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
 +	if (!of_phy_is_fixed_link(mac->of_node))
 +		phy_print_status(dev->phydev);
  }
  
 -static void mtk_validate(struct phylink_config *config,
 -			 unsigned long *supported,
 -			 struct phylink_link_state *state)
 -{
 -	struct mtk_mac *mac = container_of(config, struct mtk_mac,
 -					   phylink_config);
 -	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
 -
 -	if (state->interface != PHY_INTERFACE_MODE_NA &&
 -	    state->interface != PHY_INTERFACE_MODE_MII &&
 -	    state->interface != PHY_INTERFACE_MODE_GMII &&
 -	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_RGMII) &&
 -	      phy_interface_mode_is_rgmii(state->interface)) &&
 -	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_TRGMII) &&
 -	      !mac->id && state->interface == PHY_INTERFACE_MODE_TRGMII) &&
 -	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_SGMII) &&
 -	      (state->interface == PHY_INTERFACE_MODE_SGMII ||
 -	       phy_interface_mode_is_8023z(state->interface)))) {
 -		linkmode_zero(supported);
 -		return;
 +static int mtk_phy_connect_node(struct mtk_eth *eth, struct mtk_mac *mac,
 +				struct device_node *phy_node)
 +{
 +	struct phy_device *phydev;
 +	int phy_mode;
 +
 +	phy_mode = of_get_phy_mode(phy_node);
 +	if (phy_mode < 0) {
 +		dev_err(eth->dev, "incorrect phy-mode %d\n", phy_mode);
 +		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	phydev = of_phy_connect(eth->netdev[mac->id], phy_node,
 +				mtk_phy_link_adjust, 0, phy_mode);
 +	if (!phydev) {
 +		dev_err(eth->dev, "could not connect to PHY\n");
 +		return -ENODEV;
++=======
+ 	phylink_set_port_modes(mask);
+ 	phylink_set(mask, Autoneg);
+ 
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_TRGMII:
+ 		phylink_set(mask, 1000baseT_Full);
+ 		break;
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 	case PHY_INTERFACE_MODE_2500BASEX:
+ 		phylink_set(mask, 1000baseX_Full);
+ 		phylink_set(mask, 2500baseX_Full);
+ 		break;
+ 	case PHY_INTERFACE_MODE_GMII:
+ 	case PHY_INTERFACE_MODE_RGMII:
+ 	case PHY_INTERFACE_MODE_RGMII_ID:
+ 	case PHY_INTERFACE_MODE_RGMII_RXID:
+ 	case PHY_INTERFACE_MODE_RGMII_TXID:
+ 		phylink_set(mask, 1000baseT_Half);
+ 		fallthrough;
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseX_Full);
+ 		fallthrough;
+ 	case PHY_INTERFACE_MODE_MII:
+ 	case PHY_INTERFACE_MODE_RMII:
+ 	case PHY_INTERFACE_MODE_REVMII:
+ 	case PHY_INTERFACE_MODE_NA:
+ 	default:
+ 		phylink_set(mask, 10baseT_Half);
+ 		phylink_set(mask, 10baseT_Full);
+ 		phylink_set(mask, 100baseT_Half);
+ 		phylink_set(mask, 100baseT_Full);
+ 		break;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	}
  
 -	if (state->interface == PHY_INTERFACE_MODE_NA) {
 -		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_SGMII)) {
 -			phylink_set(mask, 1000baseT_Full);
 -			phylink_set(mask, 1000baseX_Full);
 -			phylink_set(mask, 2500baseX_Full);
 -		}
 -		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_RGMII)) {
 -			phylink_set(mask, 1000baseT_Full);
 -			phylink_set(mask, 1000baseT_Half);
 -			phylink_set(mask, 1000baseX_Full);
 -		}
 -		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GEPHY)) {
 -			phylink_set(mask, 1000baseT_Full);
 -			phylink_set(mask, 1000baseT_Half);
 -		}
 +	dev_info(eth->dev,
 +		 "connected mac %d to PHY at %s [uid=%08x, driver=%s]\n",
 +		 mac->id, phydev_name(phydev), phydev->phy_id,
 +		 phydev->drv->name);
 +
 +	return 0;
 +}
 +
 +static int mtk_phy_connect(struct net_device *dev)
 +{
 +	struct mtk_mac *mac = netdev_priv(dev);
 +	struct mtk_eth *eth;
 +	struct device_node *np;
 +	u32 val;
 +
 +	eth = mac->hw;
 +	np = of_parse_phandle(mac->of_node, "phy-handle", 0);
 +	if (!np && of_phy_is_fixed_link(mac->of_node))
 +		if (!of_phy_register_fixed_link(mac->of_node))
 +			np = of_node_get(mac->of_node);
 +	if (!np)
 +		return -ENODEV;
 +
 +	mac->ge_mode = 0;
 +	switch (of_get_phy_mode(np)) {
 +	case PHY_INTERFACE_MODE_TRGMII:
 +		mac->trgmii = true;
 +	case PHY_INTERFACE_MODE_RGMII_TXID:
 +	case PHY_INTERFACE_MODE_RGMII_RXID:
 +	case PHY_INTERFACE_MODE_RGMII_ID:
 +	case PHY_INTERFACE_MODE_RGMII:
 +		break;
 +	case PHY_INTERFACE_MODE_SGMII:
 +		if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII))
 +			mtk_gmac_sgmii_hw_setup(eth, mac->id);
 +		break;
 +	case PHY_INTERFACE_MODE_MII:
 +		mac->ge_mode = 1;
 +		break;
 +	case PHY_INTERFACE_MODE_REVMII:
 +		mac->ge_mode = 2;
 +		break;
 +	case PHY_INTERFACE_MODE_RMII:
 +		if (!mac->id)
 +			goto err_phy;
 +		mac->ge_mode = 3;
 +		break;
 +	default:
 +		goto err_phy;
  	}
  
 -	phylink_set(mask, Pause);
 -	phylink_set(mask, Asym_Pause);
 +	/* put the gmac into the right mode */
 +	regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 +	val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);
 +	val |= SYSCFG0_GE_MODE(mac->ge_mode, mac->id);
 +	regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
  
 -	linkmode_and(supported, supported, mask);
 -	linkmode_and(state->advertising, state->advertising, mask);
 +	/* couple phydev to net_device */
 +	if (mtk_phy_connect_node(eth, mac, np))
 +		goto err_phy;
  
 -	/* We can only operate at 2500BaseX or 1000BaseX. If requested
 -	 * to advertise both, only report advertising at 2500BaseX.
 -	 */
 -	phylink_helper_basex_speed(state);
 -}
 +	dev->phydev->autoneg = AUTONEG_ENABLE;
 +	dev->phydev->speed = 0;
 +	dev->phydev->duplex = 0;
  
 -static const struct phylink_mac_ops mtk_phylink_ops = {
 -	.validate = mtk_validate,
 -	.mac_pcs_get_state = mtk_mac_pcs_get_state,
 -	.mac_an_restart = mtk_mac_an_restart,
 -	.mac_config = mtk_mac_config,
 -	.mac_link_down = mtk_mac_link_down,
 -	.mac_link_up = mtk_mac_link_up,
 -};
 +	phy_set_max_speed(dev->phydev, SPEED_1000);
 +	phy_support_asym_pause(dev->phydev);
 +	linkmode_copy(dev->phydev->advertising, dev->phydev->supported);
 +	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
 +			 dev->phydev->advertising);
 +	phy_start_aneg(dev->phydev);
 +
 +	of_node_put(np);
 +
 +	return 0;
 +
 +err_phy:
 +	if (of_phy_is_fixed_link(mac->of_node))
 +		of_phy_deregister_fixed_link(mac->of_node);
 +	of_node_put(np);
 +	dev_err(eth->dev, "%s: invalid phy\n", __func__);
 +	return -EINVAL;
 +}
  
  static int mtk_mdio_init(struct mtk_eth *eth)
  {
diff --cc drivers/net/ethernet/mscc/ocelot.c
index fb1208bf823d,5abb7d2b0a9e..000000000000
--- a/drivers/net/ethernet/mscc/ocelot.c
+++ b/drivers/net/ethernet/mscc/ocelot.c
@@@ -815,8 -858,8 +815,13 @@@ static int ocelot_port_attr_stp_state_s
  
  	switch (state) {
  	case BR_STATE_FORWARDING:
++<<<<<<< HEAD
 +		ocelot->bridge_fwd_mask |= BIT(ocelot_port->chip_port);
 +		/* Fallthrough */
++=======
+ 		ocelot->bridge_fwd_mask |= BIT(port);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case BR_STATE_LEARNING:
  		port_cfg |= ANA_PORT_PORT_CFG_LEARN_ENA;
  		break;
diff --cc drivers/net/ethernet/neterion/vxge/vxge-config.c
index 358ed6118881,78eba10300ae..000000000000
--- a/drivers/net/ethernet/neterion/vxge/vxge-config.c
+++ b/drivers/net/ethernet/neterion/vxge/vxge-config.c
@@@ -3784,17 -3768,20 +3784,29 @@@ vxge_hw_rts_rth_data0_data1_get(u32 j, 
  			VXGE_HW_RTS_ACCESS_STEER_DATA0_RTH_ITEM0_ENTRY_EN |
  			VXGE_HW_RTS_ACCESS_STEER_DATA0_RTH_ITEM0_BUCKET_DATA(
  			itable[j]);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		*data0 |=
  			VXGE_HW_RTS_ACCESS_STEER_DATA0_RTH_ITEM1_BUCKET_NUM(j)|
  			VXGE_HW_RTS_ACCESS_STEER_DATA0_RTH_ITEM1_ENTRY_EN |
  			VXGE_HW_RTS_ACCESS_STEER_DATA0_RTH_ITEM1_BUCKET_DATA(
  			itable[j]);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 3:
  		*data1 = VXGE_HW_RTS_ACCESS_STEER_DATA1_RTH_ITEM0_BUCKET_NUM(j)|
  			VXGE_HW_RTS_ACCESS_STEER_DATA1_RTH_ITEM0_ENTRY_EN |
  			VXGE_HW_RTS_ACCESS_STEER_DATA1_RTH_ITEM0_BUCKET_DATA(
  			itable[j]);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 4:
  		*data1 |=
  			VXGE_HW_RTS_ACCESS_STEER_DATA1_RTH_ITEM1_BUCKET_NUM(j)|
diff --cc drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c
index 3157f97dd782,c3f50ddbe824..000000000000
--- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c
+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c
@@@ -167,9 -151,9 +167,13 @@@ skip
  	case NETXEN_BRDTYPE_P3_REF_QG:
  	case NETXEN_BRDTYPE_P3_4_GB:
  	case NETXEN_BRDTYPE_P3_4_GB_MM:
 +
  		supported |= SUPPORTED_Autoneg;
  		advertising |= ADVERTISED_Autoneg;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case NETXEN_BRDTYPE_P2_SB31_10G_CX4:
  	case NETXEN_BRDTYPE_P3_10G_CX4:
  	case NETXEN_BRDTYPE_P3_10G_CX4_LP:
@@@ -198,6 -182,7 +202,10 @@@
  		supported |= SUPPORTED_TP;
  		check_sfp_module = netif_running(dev) &&
  			adapter->has_link_events;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case NETXEN_BRDTYPE_P2_SB31_10G:
  	case NETXEN_BRDTYPE_P3_10G_XFP:
  		supported |= SUPPORTED_FIBRE;
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
index 7f7deeaf1cf0,b9894d54469c..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
@@@ -351,9 -351,9 +351,13 @@@ skip
  	case QLCNIC_BRDTYPE_P3P_REF_QG:
  	case QLCNIC_BRDTYPE_P3P_4_GB:
  	case QLCNIC_BRDTYPE_P3P_4_GB_MM:
 +
  		supported |= SUPPORTED_Autoneg;
  		advertising |= ADVERTISED_Autoneg;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case QLCNIC_BRDTYPE_P3P_10G_CX4:
  	case QLCNIC_BRDTYPE_P3P_10G_CX4_LP:
  	case QLCNIC_BRDTYPE_P3P_10000_BASE_T:
@@@ -377,6 -377,7 +381,10 @@@
  		supported |= SUPPORTED_TP;
  		check_sfp_module = netif_running(adapter->netdev) &&
  				   ahw->has_link_events;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case QLCNIC_BRDTYPE_P3P_10G_XFP:
  		supported |= SUPPORTED_FIBRE;
  		advertising |= ADVERTISED_FIBRE;
diff --cc drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c
index 542b67d436df,7f8b10c49660..000000000000
--- a/drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c
+++ b/drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c
@@@ -319,6 -316,7 +319,10 @@@ static int sxgbe_get_rss_hash_opts(stru
  	case TCP_V4_FLOW:
  	case UDP_V4_FLOW:
  		cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SCTP_V4_FLOW:
  	case AH_ESP_V4_FLOW:
  	case AH_V4_FLOW:
@@@ -329,6 -327,7 +333,10 @@@
  	case TCP_V6_FLOW:
  	case UDP_V6_FLOW:
  		cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SCTP_V6_FLOW:
  	case AH_ESP_V6_FLOW:
  	case AH_V6_FLOW:
diff --cc drivers/net/ethernet/sfc/falcon/ethtool.c
index dfd23a88976a,a6bae6a234ba..000000000000
--- a/drivers/net/ethernet/sfc/falcon/ethtool.c
+++ b/drivers/net/ethernet/sfc/falcon/ethtool.c
@@@ -957,6 -957,7 +957,10 @@@ ef4_ethtool_get_rxnfc(struct net_devic
  		switch (info->flow_type) {
  		case TCP_V4_FLOW:
  			info->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case UDP_V4_FLOW:
  		case SCTP_V4_FLOW:
  		case AH_ESP_V4_FLOW:
diff --cc drivers/net/ethernet/smsc/smc911x.c
index 1e178d16d010,01069dfaf75c..000000000000
--- a/drivers/net/ethernet/smsc/smc911x.c
+++ b/drivers/net/ethernet/smsc/smc911x.c
@@@ -724,6 -712,7 +724,10 @@@ static void smc911x_phy_detect(struct n
  					/* Found an external PHY */
  					break;
  			}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			/* Internal media only */
  			SMC_GET_PHY_ID1(lp, 1, id1);
diff --cc drivers/net/ethernet/socionext/netsec.c
index e080d3e7c582,806eb651cea3..000000000000
--- a/drivers/net/ethernet/socionext/netsec.c
+++ b/drivers/net/ethernet/socionext/netsec.c
@@@ -851,6 -809,321 +851,324 @@@ static void netsec_set_tx_de(struct net
  	dring->head = (dring->head + 1) % DESC_NUM;
  }
  
++<<<<<<< HEAD
++=======
+ /* The current driver only supports 1 Txq, this should run under spin_lock() */
+ static u32 netsec_xdp_queue_one(struct netsec_priv *priv,
+ 				struct xdp_frame *xdpf, bool is_ndo)
+ 
+ {
+ 	struct netsec_desc_ring *tx_ring = &priv->desc_ring[NETSEC_RING_TX];
+ 	struct page *page = virt_to_page(xdpf->data);
+ 	struct netsec_tx_pkt_ctrl tx_ctrl = {};
+ 	struct netsec_desc tx_desc;
+ 	dma_addr_t dma_handle;
+ 	u16 filled;
+ 
+ 	if (tx_ring->head >= tx_ring->tail)
+ 		filled = tx_ring->head - tx_ring->tail;
+ 	else
+ 		filled = tx_ring->head + DESC_NUM - tx_ring->tail;
+ 
+ 	if (DESC_NUM - filled <= 1)
+ 		return NETSEC_XDP_CONSUMED;
+ 
+ 	if (is_ndo) {
+ 		/* this is for ndo_xdp_xmit, the buffer needs mapping before
+ 		 * sending
+ 		 */
+ 		dma_handle = dma_map_single(priv->dev, xdpf->data, xdpf->len,
+ 					    DMA_TO_DEVICE);
+ 		if (dma_mapping_error(priv->dev, dma_handle))
+ 			return NETSEC_XDP_CONSUMED;
+ 		tx_desc.buf_type = TYPE_NETSEC_XDP_NDO;
+ 	} else {
+ 		/* This is the device Rx buffer from page_pool. No need to remap
+ 		 * just sync and send it
+ 		 */
+ 		struct netsec_desc_ring *rx_ring =
+ 			&priv->desc_ring[NETSEC_RING_RX];
+ 		enum dma_data_direction dma_dir =
+ 			page_pool_get_dma_dir(rx_ring->page_pool);
+ 
+ 		dma_handle = page_pool_get_dma_addr(page) + xdpf->headroom +
+ 			sizeof(*xdpf);
+ 		dma_sync_single_for_device(priv->dev, dma_handle, xdpf->len,
+ 					   dma_dir);
+ 		tx_desc.buf_type = TYPE_NETSEC_XDP_TX;
+ 	}
+ 
+ 	tx_desc.dma_addr = dma_handle;
+ 	tx_desc.addr = xdpf->data;
+ 	tx_desc.len = xdpf->len;
+ 
+ 	netdev_sent_queue(priv->ndev, xdpf->len);
+ 	netsec_set_tx_de(priv, tx_ring, &tx_ctrl, &tx_desc, xdpf);
+ 
+ 	return NETSEC_XDP_TX;
+ }
+ 
+ static u32 netsec_xdp_xmit_back(struct netsec_priv *priv, struct xdp_buff *xdp)
+ {
+ 	struct netsec_desc_ring *tx_ring = &priv->desc_ring[NETSEC_RING_TX];
+ 	struct xdp_frame *xdpf = xdp_convert_buff_to_frame(xdp);
+ 	u32 ret;
+ 
+ 	if (unlikely(!xdpf))
+ 		return NETSEC_XDP_CONSUMED;
+ 
+ 	spin_lock(&tx_ring->lock);
+ 	ret = netsec_xdp_queue_one(priv, xdpf, false);
+ 	spin_unlock(&tx_ring->lock);
+ 
+ 	return ret;
+ }
+ 
+ static u32 netsec_run_xdp(struct netsec_priv *priv, struct bpf_prog *prog,
+ 			  struct xdp_buff *xdp)
+ {
+ 	struct netsec_desc_ring *dring = &priv->desc_ring[NETSEC_RING_RX];
+ 	unsigned int sync, len = xdp->data_end - xdp->data;
+ 	u32 ret = NETSEC_XDP_PASS;
+ 	struct page *page;
+ 	int err;
+ 	u32 act;
+ 
+ 	act = bpf_prog_run_xdp(prog, xdp);
+ 
+ 	/* Due xdp_adjust_tail: DMA sync for_device cover max len CPU touch */
+ 	sync = xdp->data_end - xdp->data_hard_start - NETSEC_RXBUF_HEADROOM;
+ 	sync = max(sync, len);
+ 
+ 	switch (act) {
+ 	case XDP_PASS:
+ 		ret = NETSEC_XDP_PASS;
+ 		break;
+ 	case XDP_TX:
+ 		ret = netsec_xdp_xmit_back(priv, xdp);
+ 		if (ret != NETSEC_XDP_TX) {
+ 			page = virt_to_head_page(xdp->data);
+ 			page_pool_put_page(dring->page_pool, page, sync, true);
+ 		}
+ 		break;
+ 	case XDP_REDIRECT:
+ 		err = xdp_do_redirect(priv->ndev, xdp, prog);
+ 		if (!err) {
+ 			ret = NETSEC_XDP_REDIR;
+ 		} else {
+ 			ret = NETSEC_XDP_CONSUMED;
+ 			page = virt_to_head_page(xdp->data);
+ 			page_pool_put_page(dring->page_pool, page, sync, true);
+ 		}
+ 		break;
+ 	default:
+ 		bpf_warn_invalid_xdp_action(act);
+ 		fallthrough;
+ 	case XDP_ABORTED:
+ 		trace_xdp_exception(priv->ndev, prog, act);
+ 		fallthrough;	/* handle aborts by dropping packet */
+ 	case XDP_DROP:
+ 		ret = NETSEC_XDP_CONSUMED;
+ 		page = virt_to_head_page(xdp->data);
+ 		page_pool_put_page(dring->page_pool, page, sync, true);
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int netsec_process_rx(struct netsec_priv *priv, int budget)
+ {
+ 	struct netsec_desc_ring *dring = &priv->desc_ring[NETSEC_RING_RX];
+ 	struct net_device *ndev = priv->ndev;
+ 	struct netsec_rx_pkt_info rx_info;
+ 	enum dma_data_direction dma_dir;
+ 	struct bpf_prog *xdp_prog;
+ 	struct xdp_buff xdp;
+ 	u16 xdp_xmit = 0;
+ 	u32 xdp_act = 0;
+ 	int done = 0;
+ 
+ 	xdp.rxq = &dring->xdp_rxq;
+ 	xdp.frame_sz = PAGE_SIZE;
+ 
+ 	rcu_read_lock();
+ 	xdp_prog = READ_ONCE(priv->xdp_prog);
+ 	dma_dir = page_pool_get_dma_dir(dring->page_pool);
+ 
+ 	while (done < budget) {
+ 		u16 idx = dring->tail;
+ 		struct netsec_de *de = dring->vaddr + (DESC_SZ * idx);
+ 		struct netsec_desc *desc = &dring->desc[idx];
+ 		struct page *page = virt_to_page(desc->addr);
+ 		u32 xdp_result = NETSEC_XDP_PASS;
+ 		struct sk_buff *skb = NULL;
+ 		u16 pkt_len, desc_len;
+ 		dma_addr_t dma_handle;
+ 		void *buf_addr;
+ 
+ 		if (de->attr & (1U << NETSEC_RX_PKT_OWN_FIELD)) {
+ 			/* reading the register clears the irq */
+ 			netsec_read(priv, NETSEC_REG_NRM_RX_PKTCNT);
+ 			break;
+ 		}
+ 
+ 		/* This  barrier is needed to keep us from reading
+ 		 * any other fields out of the netsec_de until we have
+ 		 * verified the descriptor has been written back
+ 		 */
+ 		dma_rmb();
+ 		done++;
+ 
+ 		pkt_len = de->buf_len_info >> 16;
+ 		rx_info.err_code = (de->attr >> NETSEC_RX_PKT_ERR_FIELD) &
+ 			NETSEC_RX_PKT_ERR_MASK;
+ 		rx_info.err_flag = (de->attr >> NETSEC_RX_PKT_ER_FIELD) & 1;
+ 		if (rx_info.err_flag) {
+ 			netif_err(priv, drv, priv->ndev,
+ 				  "%s: rx fail err(%d)\n", __func__,
+ 				  rx_info.err_code);
+ 			ndev->stats.rx_dropped++;
+ 			dring->tail = (dring->tail + 1) % DESC_NUM;
+ 			/* reuse buffer page frag */
+ 			netsec_rx_fill(priv, idx, 1);
+ 			continue;
+ 		}
+ 		rx_info.rx_cksum_result =
+ 			(de->attr >> NETSEC_RX_PKT_CO_FIELD) & 3;
+ 
+ 		/* allocate a fresh buffer and map it to the hardware.
+ 		 * This will eventually replace the old buffer in the hardware
+ 		 */
+ 		buf_addr = netsec_alloc_rx_data(priv, &dma_handle, &desc_len);
+ 
+ 		if (unlikely(!buf_addr))
+ 			break;
+ 
+ 		dma_sync_single_for_cpu(priv->dev, desc->dma_addr, pkt_len,
+ 					dma_dir);
+ 		prefetch(desc->addr);
+ 
+ 		xdp.data_hard_start = desc->addr;
+ 		xdp.data = desc->addr + NETSEC_RXBUF_HEADROOM;
+ 		xdp_set_data_meta_invalid(&xdp);
+ 		xdp.data_end = xdp.data + pkt_len;
+ 
+ 		if (xdp_prog) {
+ 			xdp_result = netsec_run_xdp(priv, xdp_prog, &xdp);
+ 			if (xdp_result != NETSEC_XDP_PASS) {
+ 				xdp_act |= xdp_result;
+ 				if (xdp_result == NETSEC_XDP_TX)
+ 					xdp_xmit++;
+ 				goto next;
+ 			}
+ 		}
+ 		skb = build_skb(desc->addr, desc->len + NETSEC_RX_BUF_NON_DATA);
+ 
+ 		if (unlikely(!skb)) {
+ 			/* If skb fails recycle_direct will either unmap and
+ 			 * free the page or refill the cache depending on the
+ 			 * cache state. Since we paid the allocation cost if
+ 			 * building an skb fails try to put the page into cache
+ 			 */
+ 			page_pool_put_page(dring->page_pool, page, pkt_len,
+ 					   true);
+ 			netif_err(priv, drv, priv->ndev,
+ 				  "rx failed to build skb\n");
+ 			break;
+ 		}
+ 		page_pool_release_page(dring->page_pool, page);
+ 
+ 		skb_reserve(skb, xdp.data - xdp.data_hard_start);
+ 		skb_put(skb, xdp.data_end - xdp.data);
+ 		skb->protocol = eth_type_trans(skb, priv->ndev);
+ 
+ 		if (priv->rx_cksum_offload_flag &&
+ 		    rx_info.rx_cksum_result == NETSEC_RX_CKSUM_OK)
+ 			skb->ip_summed = CHECKSUM_UNNECESSARY;
+ 
+ next:
+ 		if (skb)
+ 			napi_gro_receive(&priv->napi, skb);
+ 		if (skb || xdp_result) {
+ 			ndev->stats.rx_packets++;
+ 			ndev->stats.rx_bytes += xdp.data_end - xdp.data;
+ 		}
+ 
+ 		/* Update the descriptor with fresh buffers */
+ 		desc->len = desc_len;
+ 		desc->dma_addr = dma_handle;
+ 		desc->addr = buf_addr;
+ 
+ 		netsec_rx_fill(priv, idx, 1);
+ 		dring->tail = (dring->tail + 1) % DESC_NUM;
+ 	}
+ 	netsec_finalize_xdp_rx(priv, xdp_act, xdp_xmit);
+ 
+ 	rcu_read_unlock();
+ 
+ 	return done;
+ }
+ 
+ static int netsec_napi_poll(struct napi_struct *napi, int budget)
+ {
+ 	struct netsec_priv *priv;
+ 	int done;
+ 
+ 	priv = container_of(napi, struct netsec_priv, napi);
+ 
+ 	netsec_process_tx(priv);
+ 	done = netsec_process_rx(priv, budget);
+ 
+ 	if (done < budget && napi_complete_done(napi, done)) {
+ 		unsigned long flags;
+ 
+ 		spin_lock_irqsave(&priv->reglock, flags);
+ 		netsec_write(priv, NETSEC_REG_INTEN_SET,
+ 			     NETSEC_IRQ_RX | NETSEC_IRQ_TX);
+ 		spin_unlock_irqrestore(&priv->reglock, flags);
+ 	}
+ 
+ 	return done;
+ }
+ 
+ 
+ static int netsec_desc_used(struct netsec_desc_ring *dring)
+ {
+ 	int used;
+ 
+ 	if (dring->head >= dring->tail)
+ 		used = dring->head - dring->tail;
+ 	else
+ 		used = dring->head + DESC_NUM - dring->tail;
+ 
+ 	return used;
+ }
+ 
+ static int netsec_check_stop_tx(struct netsec_priv *priv, int used)
+ {
+ 	struct netsec_desc_ring *dring = &priv->desc_ring[NETSEC_RING_TX];
+ 
+ 	/* keep tail from touching the queue */
+ 	if (DESC_NUM - used < 2) {
+ 		netif_stop_queue(priv->ndev);
+ 
+ 		/* Make sure we read the updated value in case
+ 		 * descriptors got freed
+ 		 */
+ 		smp_rmb();
+ 
+ 		used = netsec_desc_used(dring);
+ 		if (DESC_NUM - used < 2)
+ 			return NETDEV_TX_BUSY;
+ 
+ 		netif_wake_queue(priv->ndev);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static netdev_tx_t netsec_netdev_start_xmit(struct sk_buff *skb,
  					    struct net_device *ndev)
  {
diff --cc drivers/net/ethernet/ti/tlan.c
index 3391b9c933ff,76a342ea3797..000000000000
--- a/drivers/net/ethernet/ti/tlan.c
+++ b/drivers/net/ethernet/ti/tlan.c
@@@ -965,6 -948,7 +965,10 @@@ static int tlan_ioctl(struct net_devic
  	switch (cmd) {
  	case SIOCGMIIPHY:		/* get address of MII PHY in use. */
  		data->phy_id = phy;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  
  	case SIOCGMIIREG:		/* read MII PHY register. */
diff --cc drivers/net/ethernet/toshiba/spider_net.c
index 36649bea232e,5f5b33e6653b..000000000000
--- a/drivers/net/ethernet/toshiba/spider_net.c
+++ b/drivers/net/ethernet/toshiba/spider_net.c
@@@ -801,6 -786,7 +801,10 @@@ spider_net_release_tx_chain(struct spid
  			/* fallthrough, if we release the descriptors
  			 * brutally (then we don't care about
  			 * SPIDER_NET_DESCR_CARDOWNED) */
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case SPIDER_NET_DESCR_RESPONSE_ERROR:
  		case SPIDER_NET_DESCR_PROTECTION_ERROR:
diff --cc drivers/net/fddi/skfp/pcmplc.c
index a9ecf923f63d,554cde8d6073..000000000000
--- a/drivers/net/fddi/skfp/pcmplc.c
+++ b/drivers/net/fddi/skfp/pcmplc.c
@@@ -852,6 -847,7 +852,10 @@@ static void pcm_fsm(struct s_smc *smc, 
  
  	case ACTIONS(PC5_SIGNAL) :
  		ACTIONS_DONE() ;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case PC5_SIGNAL :
  		if ((cmd != PC_SIGNAL) && (cmd != PC_TIMEOUT_LCT))
  			break ;
diff --cc drivers/net/hamradio/baycom_epp.c
index 1e62d00732f2,e4e4981ac1d2..000000000000
--- a/drivers/net/hamradio/baycom_epp.c
+++ b/drivers/net/hamradio/baycom_epp.c
@@@ -515,8 -500,9 +515,12 @@@ static int transmit(struct baycom_stat
  				}
  				break;
  			}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -		default:
 +		default:  /* fall through */
  			if (bc->hdlctx.calibrate <= 0)
  				return 0;
  			i = min_t(int, cnt, bc->hdlctx.calibrate);
diff --cc drivers/net/phy/phy_device.c
index bc108f10d25e,8adfbad0a1e8..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -1827,6 -1964,90 +1827,93 @@@ int genphy_setup_forced(struct phy_devi
  }
  EXPORT_SYMBOL(genphy_setup_forced);
  
++<<<<<<< HEAD
++=======
+ static int genphy_setup_master_slave(struct phy_device *phydev)
+ {
+ 	u16 ctl = 0;
+ 
+ 	if (!phydev->is_gigabit_capable)
+ 		return 0;
+ 
+ 	switch (phydev->master_slave_set) {
+ 	case MASTER_SLAVE_CFG_MASTER_PREFERRED:
+ 		ctl |= CTL1000_PREFER_MASTER;
+ 		break;
+ 	case MASTER_SLAVE_CFG_SLAVE_PREFERRED:
+ 		break;
+ 	case MASTER_SLAVE_CFG_MASTER_FORCE:
+ 		ctl |= CTL1000_AS_MASTER;
+ 		fallthrough;
+ 	case MASTER_SLAVE_CFG_SLAVE_FORCE:
+ 		ctl |= CTL1000_ENABLE_MASTER;
+ 		break;
+ 	case MASTER_SLAVE_CFG_UNKNOWN:
+ 	case MASTER_SLAVE_CFG_UNSUPPORTED:
+ 		return 0;
+ 	default:
+ 		phydev_warn(phydev, "Unsupported Master/Slave mode\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return phy_modify_changed(phydev, MII_CTRL1000,
+ 				  (CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER |
+ 				   CTL1000_PREFER_MASTER), ctl);
+ }
+ 
+ static int genphy_read_master_slave(struct phy_device *phydev)
+ {
+ 	int cfg, state;
+ 	int val;
+ 
+ 	if (!phydev->is_gigabit_capable) {
+ 		phydev->master_slave_get = MASTER_SLAVE_CFG_UNSUPPORTED;
+ 		phydev->master_slave_state = MASTER_SLAVE_STATE_UNSUPPORTED;
+ 		return 0;
+ 	}
+ 
+ 	phydev->master_slave_get = MASTER_SLAVE_CFG_UNKNOWN;
+ 	phydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;
+ 
+ 	val = phy_read(phydev, MII_CTRL1000);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	if (val & CTL1000_ENABLE_MASTER) {
+ 		if (val & CTL1000_AS_MASTER)
+ 			cfg = MASTER_SLAVE_CFG_MASTER_FORCE;
+ 		else
+ 			cfg = MASTER_SLAVE_CFG_SLAVE_FORCE;
+ 	} else {
+ 		if (val & CTL1000_PREFER_MASTER)
+ 			cfg = MASTER_SLAVE_CFG_MASTER_PREFERRED;
+ 		else
+ 			cfg = MASTER_SLAVE_CFG_SLAVE_PREFERRED;
+ 	}
+ 
+ 	val = phy_read(phydev, MII_STAT1000);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	if (val & LPA_1000MSFAIL) {
+ 		state = MASTER_SLAVE_STATE_ERR;
+ 	} else if (phydev->link) {
+ 		/* this bits are valid only for active link */
+ 		if (val & LPA_1000MSRES)
+ 			state = MASTER_SLAVE_STATE_MASTER;
+ 		else
+ 			state = MASTER_SLAVE_STATE_SLAVE;
+ 	} else {
+ 		state = MASTER_SLAVE_STATE_UNKNOWN;
+ 	}
+ 
+ 	phydev->master_slave_get = cfg;
+ 	phydev->master_slave_state = state;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  /**
   * genphy_restart_aneg - Enable and Restart Autonegotiation
   * @phydev: target phy_device struct
diff --cc drivers/net/usb/r8152.c
index d265cfd312ec,b1770489aca5..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -3622,44 -4814,43 +3622,62 @@@ static void rtl8153_disable(struct r815
  	r8153_aldps_en(tp, true);
  }
  
 -static int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u32 speed, u8 duplex,
 -			     u32 advertising)
 +static void rtl8153b_disable(struct r8152 *tp)
 +{
 +	r8153b_aldps_en(tp, false);
 +	rtl_disable(tp);
 +	rtl_reset_bmu(tp);
 +	r8153b_aldps_en(tp, true);
 +}
 +
 +static int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u16 speed, u8 duplex)
  {
 -	u16 bmcr;
 +	u16 bmcr, anar, gbcr;
 +	enum spd_duplex speed_duplex;
  	int ret = 0;
  
 -	if (autoneg == AUTONEG_DISABLE) {
 -		if (duplex != DUPLEX_HALF && duplex != DUPLEX_FULL)
 -			return -EINVAL;
 +	anar = r8152_mdio_read(tp, MII_ADVERTISE);
 +	anar &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
 +		  ADVERTISE_100HALF | ADVERTISE_100FULL);
 +	if (tp->mii.supports_gmii) {
 +		gbcr = r8152_mdio_read(tp, MII_CTRL1000);
 +		gbcr &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);
 +	} else {
 +		gbcr = 0;
 +	}
  
 -		switch (speed) {
 -		case SPEED_10:
 -			bmcr = BMCR_SPEED10;
 -			if (duplex == DUPLEX_FULL) {
 -				bmcr |= BMCR_FULLDPLX;
 -				tp->ups_info.speed_duplex = FORCE_10M_FULL;
 -			} else {
 -				tp->ups_info.speed_duplex = FORCE_10M_HALF;
 -			}
 -			break;
 -		case SPEED_100:
 +	if (autoneg == AUTONEG_DISABLE) {
 +		if (speed == SPEED_10) {
 +			bmcr = 0;
 +			anar |= ADVERTISE_10HALF | ADVERTISE_10FULL;
 +			speed_duplex = FORCE_10M_HALF;
 +		} else if (speed == SPEED_100) {
  			bmcr = BMCR_SPEED100;
++<<<<<<< HEAD
 +			anar |= ADVERTISE_100HALF | ADVERTISE_100FULL;
 +			speed_duplex = FORCE_100M_HALF;
 +		} else if (speed == SPEED_1000 && tp->mii.supports_gmii) {
 +			bmcr = BMCR_SPEED1000;
 +			gbcr |= ADVERTISE_1000FULL | ADVERTISE_1000HALF;
 +			speed_duplex = NWAY_1000M_FULL;
 +		} else {
++=======
+ 			if (duplex == DUPLEX_FULL) {
+ 				bmcr |= BMCR_FULLDPLX;
+ 				tp->ups_info.speed_duplex = FORCE_100M_FULL;
+ 			} else {
+ 				tp->ups_info.speed_duplex = FORCE_100M_HALF;
+ 			}
+ 			break;
+ 		case SPEED_1000:
+ 			if (tp->mii.supports_gmii) {
+ 				bmcr = BMCR_SPEED1000 | BMCR_FULLDPLX;
+ 				tp->ups_info.speed_duplex = NWAY_1000M_FULL;
+ 				break;
+ 			}
+ 			fallthrough;
+ 		default:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			ret = -EINVAL;
  			goto out;
  		}
diff --cc drivers/net/virtio_net.c
index 60ab9b0a1570,263b005981bd..000000000000
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@@ -716,6 -724,7 +716,10 @@@ static struct sk_buff *receive_small(st
  			goto xdp_xmit;
  		default:
  			bpf_warn_invalid_xdp_action(act);
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case XDP_ABORTED:
  			trace_xdp_exception(vi->dev, xdp_prog, act);
  		case XDP_DROP:
@@@ -909,8 -922,10 +913,15 @@@ static struct sk_buff *receive_mergeabl
  			goto xdp_xmit;
  		default:
  			bpf_warn_invalid_xdp_action(act);
++<<<<<<< HEAD
 +		case XDP_ABORTED:
 +			trace_xdp_exception(vi->dev, xdp_prog, act);
++=======
+ 			fallthrough;
+ 		case XDP_ABORTED:
+ 			trace_xdp_exception(vi->dev, xdp_prog, act);
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case XDP_DROP:
  			if (unlikely(xdp_page != page))
  				__free_pages(xdp_page, 0);
diff --cc drivers/net/wan/sdla.c
index 57ed259c8208,bc2c1c7fb1a4..000000000000
--- a/drivers/net/wan/sdla.c
+++ b/drivers/net/wan/sdla.c
@@@ -417,6 -413,7 +417,10 @@@ static void sdla_errors(struct net_devi
  		case SDLA_RET_NO_BUFS:
  			if (cmd == SDLA_INFORMATION_WRITE)
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		default: 
  			netdev_dbg(dev, "Cmd 0x%02X generated return code 0x%02X\n",
diff --cc drivers/net/wimax/i2400m/control.c
index 4c417903e9be,9afed3b133d3..000000000000
--- a/drivers/net/wimax/i2400m/control.c
+++ b/drivers/net/wimax/i2400m/control.c
@@@ -352,6 -352,7 +352,10 @@@ void i2400m_report_tlv_system_state(str
  
  	case I2400M_SS_IDLE:
  		d_printf(1, dev, "entering BS-negotiated idle mode\n");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case I2400M_SS_DISCONNECTING:
  	case I2400M_SS_DATA_PATH_CONNECTED:
  		wimax_state_change(wimax_dev, WIMAX_ST_CONNECTED);
diff --cc drivers/net/wimax/i2400m/usb-fw.c
index 502c346aa790,27ab233650d5..000000000000
--- a/drivers/net/wimax/i2400m/usb-fw.c
+++ b/drivers/net/wimax/i2400m/usb-fw.c
@@@ -136,6 -135,7 +136,10 @@@ retry
  			msleep(10);	/* give the device some time */
  			goto retry;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case -EINVAL:			/* while removing driver */
  	case -ENODEV:			/* dev disconnect ... */
  	case -ENOENT:			/* just ignore it */
diff --cc drivers/net/wimax/i2400m/usb-tx.c
index 99ef81b3d5a5,3ba9d70cca1b..000000000000
--- a/drivers/net/wimax/i2400m/usb-tx.c
+++ b/drivers/net/wimax/i2400m/usb-tx.c
@@@ -137,6 -136,7 +137,10 @@@ retry
  			msleep(10);	/* give the device some time */
  			goto retry;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case -EINVAL:			/* while removing driver */
  	case -ENODEV:			/* dev disconnect ... */
  	case -ENOENT:			/* just ignore it */
diff --cc drivers/net/wimax/i2400m/usb.c
index f8eb66ef2944,b684e97ac976..000000000000
--- a/drivers/net/wimax/i2400m/usb.c
+++ b/drivers/net/wimax/i2400m/usb.c
@@@ -210,6 -195,7 +210,10 @@@ retry
  			msleep(10);	/* give the device some time */
  			goto retry;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case -EINVAL:			/* while removing driver */
  	case -ENODEV:			/* dev disconnect ... */
  	case -ENOENT:			/* just ignore it */
diff --cc drivers/net/xen-netback/xenbus.c
index cd51492ae6c2,f1c1624cec8f..000000000000
--- a/drivers/net/xen-netback/xenbus.c
+++ b/drivers/net/xen-netback/xenbus.c
@@@ -668,7 -448,7 +668,11 @@@ static void frontend_changed(struct xen
  		set_backend_state(be, XenbusStateClosed);
  		if (xenbus_dev_is_online(dev))
  			break;
++<<<<<<< HEAD
 +		/* fall through if not online */
++=======
+ 		fallthrough;	/* if not online */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XenbusStateUnknown:
  		set_backend_state(be, XenbusStateClosed);
  		device_unregister(&dev->dev);
diff --cc drivers/net/xen-netfront.c
index 9407acbd19a9,3e9895bec15f..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -2034,7 -2341,7 +2034,11 @@@ static void netback_changed(struct xenb
  	case XenbusStateClosed:
  		if (dev->state == XenbusStateClosed)
  			break;
++<<<<<<< HEAD
 +		/* Missed the backend's CLOSING state -- fallthrough */
++=======
+ 		fallthrough;	/* Missed the backend's CLOSING state */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XenbusStateClosing:
  		xenbus_frontend_closed(dev);
  		break;
diff --cc drivers/nfc/pn533/pn533.c
index a0cc1cc45292,f7464bd6d57c..000000000000
--- a/drivers/nfc/pn533/pn533.c
+++ b/drivers/nfc/pn533/pn533.c
@@@ -2147,6 -2321,7 +2147,10 @@@ static int pn533_transceive(struct nfc_
  
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		/* jumbo frame ? */
  		if (skb->len > PN533_CMD_DATAEXCH_DATA_MAXLEN) {
@@@ -2273,6 -2448,7 +2277,10 @@@ static void pn533_wq_mi_recv(struct wor
  
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		skb_put_u8(skb, 1); /*TG*/
  
diff --cc drivers/nfc/st21nfca/dep.c
index fd08be2917e6,8874d605b14f..000000000000
--- a/drivers/nfc/st21nfca/dep.c
+++ b/drivers/nfc/st21nfca/dep.c
@@@ -619,6 -611,7 +619,10 @@@ static void st21nfca_im_recv_dep_res_cb
  		switch (ST21NFCA_NFC_DEP_PFB_TYPE(dep_res->pfb)) {
  		case ST21NFCA_NFC_DEP_PFB_ACK_NACK_PDU:
  			pr_err("Received a ACK/NACK PDU\n");
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case ST21NFCA_NFC_DEP_PFB_I_PDU:
  			info->dep_info.curr_nfc_dep_pni =
  			    ST21NFCA_NFC_DEP_PFB_PNI(dep_res->pfb + 1);
diff --cc drivers/parport/ieee1284.c
index 2d1a5c737c6e,4547ac44c8d4..000000000000
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@@ -267,7 -260,7 +267,11 @@@ static void parport_ieee1284_terminate 
  			port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
  		}
  
++<<<<<<< HEAD
 +		/* fall-though.. */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		/* Terminate from all other modes. */
@@@ -615,9 -598,9 +619,13 @@@ ssize_t parport_write (struct parport *
  	case IEEE1284_MODE_NIBBLE:
  	case IEEE1284_MODE_BYTE:
  		parport_negotiate (port, IEEE1284_MODE_COMPAT);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IEEE1284_MODE_COMPAT:
 -		pr_debug("%s: Using compatibility mode\n", port->name);
 +		DPRINTK (KERN_DEBUG "%s: Using compatibility mode\n",
 +			 port->name);
  		fn = port->ops->compat_write_data;
  		break;
  
@@@ -721,9 -702,9 +729,13 @@@ ssize_t parport_read (struct parport *p
  		if (parport_negotiate (port, IEEE1284_MODE_NIBBLE)) {
  			return -EIO;
  		}
++<<<<<<< HEAD
 +		/* fall through to NIBBLE */
++=======
+ 		fallthrough;	/* to NIBBLE */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IEEE1284_MODE_NIBBLE:
 -		pr_debug("%s: Using nibble mode\n", port->name);
 +		DPRINTK (KERN_DEBUG "%s: Using nibble mode\n", port->name);
  		fn = port->ops->nibble_read_data;
  		break;
  
diff --cc drivers/parport/parport_pc.c
index 380916bff9e0,eda4ded4d5e5..000000000000
--- a/drivers/parport/parport_pc.c
+++ b/drivers/parport/parport_pc.c
@@@ -1661,13 -1643,11 +1661,18 @@@ static int parport_ECP_supported(struc
  		break;
  	case 2:
  		pword = 4;
 -		pr_warn("0x%lx: Unsupported pword size!\n", pb->base);
 +		printk(KERN_WARNING "0x%lx: Unsupported pword size!\n",
 +			pb->base);
  		break;
  	default:
++<<<<<<< HEAD
 +		printk(KERN_WARNING "0x%lx: Unknown implementation ID\n",
 +			pb->base);
 +		/* Assume 1 */
++=======
+ 		pr_warn("0x%lx: Unknown implementation ID\n", pb->base);
+ 		fallthrough;	/* Assume 1 */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		pword = 1;
  	}
diff --cc drivers/pci/controller/dwc/pci-imx6.c
index 4a9a673b4777,5fef2613b223..000000000000
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@@ -757,7 -1099,17 +757,17 @@@ static int imx6_pcie_probe(struct platf
  			return PTR_ERR(imx6_pcie->pcie_inbound_axi);
  		}
  		break;
++<<<<<<< HEAD
++=======
+ 	case IMX8MQ:
+ 		imx6_pcie->pcie_aux = devm_clk_get(dev, "pcie_aux");
+ 		if (IS_ERR(imx6_pcie->pcie_aux)) {
+ 			dev_err(dev, "pcie_aux clock source missing or invalid\n");
+ 			return PTR_ERR(imx6_pcie->pcie_aux);
+ 		}
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IMX7D:
 -		if (dbi_base->start == IMX8MQ_PCIE2_BASE_ADDR)
 -			imx6_pcie->controller_id = 1;
 -
  		imx6_pcie->pciephy_reset = devm_reset_control_get_exclusive(dev,
  									    "pciephy");
  		if (IS_ERR(imx6_pcie->pciephy_reset)) {
diff --cc drivers/pci/controller/pci-rcar-gen2.c
index 326171cb1a97,afde4aa8f6dc..000000000000
--- a/drivers/pci/controller/pci-rcar-gen2.c
+++ b/drivers/pci/controller/pci-rcar-gen2.c
@@@ -226,9 -221,9 +226,15 @@@ static int rcar_pci_setup(int nr, struc
  		break;
  	default:
  		pr_warn("unknown window size %ld - defaulting to 256M\n",
++<<<<<<< HEAD
 +			priv->window_size);
 +		priv->window_size = SZ_256M;
 +		/* fall-through */
++=======
+ 			window_size);
+ 		window_size = SZ_256M;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SZ_256M:
  		val |= RCAR_USBCTR_PCIAHB_WIN1_256M;
  		break;
diff --cc drivers/pcmcia/db1xxx_ss.c
index 19e17829f515,a7c7c7cd2326..000000000000
--- a/drivers/pcmcia/db1xxx_ss.c
+++ b/drivers/pcmcia/db1xxx_ss.c
@@@ -254,8 -255,10 +254,15 @@@ static int db1x_pcmcia_configure(struc
  	switch (state->Vcc) {
  	case 50:
  		++v;
++<<<<<<< HEAD
 +	case 33:
 +		++v;
++=======
+ 		fallthrough;
+ 	case 33:
+ 		++v;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0:
  		break;
  	default:
@@@ -266,9 -269,11 +273,17 @@@
  	switch (state->Vpp) {
  	case 12:
  		++p;
++<<<<<<< HEAD
++	case 33:
++	case 50:
++		++p;
++=======
+ 		fallthrough;
  	case 33:
  	case 50:
  		++p;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0:
  		break;
  	default:
diff --cc drivers/phy/qualcomm/phy-qcom-usb-hs.c
index 2d0c70b5589f,327df1a99f77..000000000000
--- a/drivers/phy/qualcomm/phy-qcom-usb-hs.c
+++ b/drivers/phy/qualcomm/phy-qcom-usb-hs.c
@@@ -55,6 -53,7 +55,10 @@@ static int qcom_usb_hs_phy_set_mode(str
  		case PHY_MODE_USB_OTG:
  		case PHY_MODE_USB_HOST:
  			val |= ULPI_INT_IDGRD;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case PHY_MODE_USB_DEVICE:
  			val |= ULPI_INT_SESS_VALID;
  		default:
diff --cc drivers/platform/x86/acer-wmi.c
index 8952173dd380,49f4b73be513..000000000000
--- a/drivers/platform/x86/acer-wmi.c
+++ b/drivers/platform/x86/acer-wmi.c
@@@ -1018,6 -1001,7 +1018,10 @@@ static acpi_status WMID_get_u32(u32 *va
  			*value = tmp & 0x1;
  			return 0;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return AE_ERROR;
  	}
@@@ -1344,6 -1328,7 +1348,10 @@@ static acpi_status get_u32(u32 *value, 
  			status = AMW0_get_u32(value, cap);
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ACER_WMID:
  		status = WMID_get_u32(value, cap);
  		break;
@@@ -1386,6 -1371,7 +1394,10 @@@ static acpi_status set_u32(u32 value, u
  
  				return AMW0_set_u32(value, cap);
  			}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case ACER_WMID:
  			return WMID_set_u32(value, cap);
  		case ACER_WMID_v2:
@@@ -1395,6 -1381,7 +1407,10 @@@
  				return wmid_v2_set_u32(value, cap);
  			else if (wmi_has_guid(WMID_GUID2))
  				return WMID_set_u32(value, cap);
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			return AE_BAD_PARAMETER;
  		}
diff --cc drivers/platform/x86/dell-laptop.c
index 23eaace11440,70edc5bb3a14..000000000000
--- a/drivers/platform/x86/dell-laptop.c
+++ b/drivers/platform/x86/dell-laptop.c
@@@ -1565,8 -1587,10 +1565,15 @@@ static ssize_t kbd_led_timeout_store(st
  		switch (unit) {
  		case KBD_TIMEOUT_DAYS:
  			value *= 24;
++<<<<<<< HEAD
 +		case KBD_TIMEOUT_HOURS:
 +			value *= 60;
++=======
+ 			fallthrough;
+ 		case KBD_TIMEOUT_HOURS:
+ 			value *= 60;
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case KBD_TIMEOUT_MINUTES:
  			value *= 60;
  			unit = KBD_TIMEOUT_SECONDS;
diff --cc drivers/platform/x86/thinkpad_acpi.c
index c7897f7c3e01,9c4df41687a3..000000000000
--- a/drivers/platform/x86/thinkpad_acpi.c
+++ b/drivers/platform/x86/thinkpad_acpi.c
@@@ -4198,7 -4176,7 +4198,11 @@@ static void hotkey_notify(struct ibm_st
  				known_ev = true;
  				break;
  			}
++<<<<<<< HEAD
 +			/* fallthrough to default */
++=======
+ 			fallthrough;	/* to default */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			known_ev = false;
  		}
@@@ -6238,8 -6265,8 +6242,13 @@@ static int thermal_get_sensor(int idx, 
  			t = TP_EC_THERMAL_TMP8;
  			idx -= 8;
  		}
++<<<<<<< HEAD
 +		/* fallthrough */
 +#endif
++=======
+ #endif
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case TPACPI_THERMAL_TPEC_8:
  		if (idx <= 7) {
  			if (!acpi_ec_read(t + idx, &tmp))
diff --cc drivers/power/supply/ab8500_charger.c
index 98b335042ba6,db65be026920..000000000000
--- a/drivers/power/supply/ab8500_charger.c
+++ b/drivers/power/supply/ab8500_charger.c
@@@ -742,6 -748,7 +742,10 @@@ static int ab8500_charger_max_usb_curr(
  						USB_CH_IP_CUR_LVL_1P5;
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case USB_STAT_HM_IDGND:
  		dev_err(di->dev, "USB Type - Charging not allowed\n");
  		di->max_usb_in_curr.usb_type_max = USB_CH_IP_CUR_LVL_0P05;
diff --cc drivers/power/supply/axp20x_usb_power.c
index 44f70dcea61e,0eaa86c52874..000000000000
--- a/drivers/power/supply/axp20x_usb_power.c
+++ b/drivers/power/supply/axp20x_usb_power.c
@@@ -222,6 -349,7 +222,10 @@@ static int axp20x_usb_power_set_current
  	case 100000:
  		if (power->axp20x_id == AXP221_ID)
  			return -EINVAL;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 500000:
  	case 900000:
  		val = (900000 - intval) / 400000;
diff --cc drivers/power/supply/max8925_power.c
index 3b94620ce5c1,8878f9131184..000000000000
--- a/drivers/power/supply/max8925_power.c
+++ b/drivers/power/supply/max8925_power.c
@@@ -124,6 -121,7 +124,10 @@@ static irqreturn_t max8925_charger_hand
  	case MAX8925_IRQ_VCHG_THM_OK_F:
  		/* Battery is not ready yet */
  		dev_dbg(chip->dev, "Battery temperature is out of range\n");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MAX8925_IRQ_VCHG_DC_OVP:
  		dev_dbg(chip->dev, "Error detection\n");
  		__set_charger(info, 0);
diff --cc drivers/power/supply/wm8350_power.c
index a2740cf57ad3,e05cee457471..000000000000
--- a/drivers/power/supply/wm8350_power.c
+++ b/drivers/power/supply/wm8350_power.c
@@@ -230,7 -227,8 +230,12 @@@ static irqreturn_t wm8350_charger_handl
  	case WM8350_IRQ_EXT_USB_FB:
  	case WM8350_IRQ_EXT_WALL_FB:
  		wm8350_charger_config(wm8350, policy);
++<<<<<<< HEAD
 +	case WM8350_IRQ_EXT_BAT_FB:   /* Fall through */
++=======
+ 		fallthrough;
+ 	case WM8350_IRQ_EXT_BAT_FB:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		power_supply_changed(power->battery);
  		power_supply_changed(power->usb);
  		power_supply_changed(power->ac);
diff --cc drivers/rapidio/devices/rio_mport_cdev.c
index 133e893a69d7,a30342942e26..000000000000
--- a/drivers/rapidio/devices/rio_mport_cdev.c
+++ b/drivers/rapidio/devices/rio_mport_cdev.c
@@@ -2153,6 -2150,7 +2153,10 @@@ static void mport_release_mapping(struc
  	switch (map->dir) {
  	case MAP_INBOUND:
  		rio_unmap_inb_region(mport, map->phys_addr);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MAP_DMA:
  		dma_free_coherent(mport->dev.parent, map->size,
  				  map->virt_addr, map->phys_addr);
diff --cc drivers/regulator/axp20x-regulator.c
index 91b8ff8bac15,1bacb37e8a99..000000000000
--- a/drivers/regulator/axp20x-regulator.c
+++ b/drivers/regulator/axp20x-regulator.c
@@@ -128,6 -359,128 +128,131 @@@
  		.ops		= &axp20x_ops_range,				\
  	}
  
++<<<<<<< HEAD
++=======
+ static const int axp209_dcdc2_ldo3_slew_rates[] = {
+ 	1600,
+ 	 800,
+ };
+ 
+ static int axp20x_set_ramp_delay(struct regulator_dev *rdev, int ramp)
+ {
+ 	struct axp20x_dev *axp20x = rdev_get_drvdata(rdev);
+ 	int id = rdev_get_id(rdev);
+ 	u8 reg, mask, enable, cfg = 0xff;
+ 	const int *slew_rates;
+ 	int rate_count = 0;
+ 
+ 	switch (axp20x->variant) {
+ 	case AXP209_ID:
+ 		if (id == AXP20X_DCDC2) {
+ 			slew_rates = axp209_dcdc2_ldo3_slew_rates;
+ 			rate_count = ARRAY_SIZE(axp209_dcdc2_ldo3_slew_rates);
+ 			reg = AXP20X_DCDC2_LDO3_V_RAMP;
+ 			mask = AXP20X_DCDC2_LDO3_V_RAMP_DCDC2_RATE_MASK |
+ 			       AXP20X_DCDC2_LDO3_V_RAMP_DCDC2_EN_MASK;
+ 			enable = (ramp > 0) ?
+ 				 AXP20X_DCDC2_LDO3_V_RAMP_DCDC2_EN : 0;
+ 			break;
+ 		}
+ 
+ 		if (id == AXP20X_LDO3) {
+ 			slew_rates = axp209_dcdc2_ldo3_slew_rates;
+ 			rate_count = ARRAY_SIZE(axp209_dcdc2_ldo3_slew_rates);
+ 			reg = AXP20X_DCDC2_LDO3_V_RAMP;
+ 			mask = AXP20X_DCDC2_LDO3_V_RAMP_LDO3_RATE_MASK |
+ 			       AXP20X_DCDC2_LDO3_V_RAMP_LDO3_EN_MASK;
+ 			enable = (ramp > 0) ?
+ 				 AXP20X_DCDC2_LDO3_V_RAMP_LDO3_EN : 0;
+ 			break;
+ 		}
+ 
+ 		if (rate_count > 0)
+ 			break;
+ 
+ 		fallthrough;
+ 	default:
+ 		/* Not supported for this regulator */
+ 		return -ENOTSUPP;
+ 	}
+ 
+ 	if (ramp == 0) {
+ 		cfg = enable;
+ 	} else {
+ 		int i;
+ 
+ 		for (i = 0; i < rate_count; i++) {
+ 			if (ramp > slew_rates[i])
+ 				break;
+ 
+ 			if (id == AXP20X_DCDC2)
+ 				cfg = AXP20X_DCDC2_LDO3_V_RAMP_DCDC2_RATE(i);
+ 			else
+ 				cfg = AXP20X_DCDC2_LDO3_V_RAMP_LDO3_RATE(i);
+ 		}
+ 
+ 		if (cfg == 0xff) {
+ 			dev_err(axp20x->dev, "unsupported ramp value %d", ramp);
+ 			return -EINVAL;
+ 		}
+ 
+ 		cfg |= enable;
+ 	}
+ 
+ 	return regmap_update_bits(axp20x->regmap, reg, mask, cfg);
+ }
+ 
+ static int axp20x_regulator_enable_regmap(struct regulator_dev *rdev)
+ {
+ 	struct axp20x_dev *axp20x = rdev_get_drvdata(rdev);
+ 	int id = rdev_get_id(rdev);
+ 
+ 	switch (axp20x->variant) {
+ 	case AXP209_ID:
+ 		if ((id == AXP20X_LDO3) &&
+ 		    rdev->constraints && rdev->constraints->soft_start) {
+ 			int v_out;
+ 			int ret;
+ 
+ 			/*
+ 			 * On some boards, the LDO3 can be overloaded when
+ 			 * turning on, causing the entire PMIC to shutdown
+ 			 * without warning. Turning it on at the minimal voltage
+ 			 * and then setting the voltage to the requested value
+ 			 * works reliably.
+ 			 */
+ 			if (regulator_is_enabled_regmap(rdev))
+ 				break;
+ 
+ 			v_out = regulator_get_voltage_sel_regmap(rdev);
+ 			if (v_out < 0)
+ 				return v_out;
+ 
+ 			if (v_out == 0)
+ 				break;
+ 
+ 			ret = regulator_set_voltage_sel_regmap(rdev, 0x00);
+ 			/*
+ 			 * A small pause is needed between
+ 			 * setting the voltage and enabling the LDO to give the
+ 			 * internal state machine time to process the request.
+ 			 */
+ 			usleep_range(1000, 5000);
+ 			ret |= regulator_enable_regmap(rdev);
+ 			ret |= regulator_set_voltage_sel_regmap(rdev, v_out);
+ 
+ 			return ret;
+ 		}
+ 		break;
+ 	default:
+ 		/* No quirks */
+ 		break;
+ 	}
+ 
+ 	return regulator_enable_regmap(rdev);
+ };
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static const struct regulator_ops axp20x_ops_fixed = {
  	.list_voltage		= regulator_list_voltage_linear,
  };
@@@ -513,6 -1022,7 +638,10 @@@ static int axp20x_set_dcdc_freq(struct 
  		 * (See include/linux/mfd/axp20x.h)
  		 */
  		reg = AXP803_DCDC_FREQ_CTRL;
++<<<<<<< HEAD
++=======
+ 		fallthrough;	/* to the check below */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AXP806_ID:
  		/*
  		 * AXP806 also have DCDC work frequency setting register at a
@@@ -520,6 -1030,7 +649,10 @@@
  		 */
  		if (axp20x->variant == AXP806_ID)
  			reg = AXP806_DCDC_FREQ_CTRL;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AXP221_ID:
  	case AXP223_ID:
  	case AXP809_ID:
@@@ -602,12 -1113,12 +735,17 @@@ static int axp20x_set_dcdc_workmode(str
  		break;
  
  	case AXP806_ID:
 +		reg = AXP806_DCDC_MODE_CTRL2;
  		/*
  		 * AXP806 DCDC regulator IDs have the same range as AXP22X.
 +		 * Fall through to the check below.
  		 * (See include/linux/mfd/axp20x.h)
  		 */
++<<<<<<< HEAD
++=======
+ 		reg = AXP806_DCDC_MODE_CTRL2;
+ 		fallthrough;	/* to the check below */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AXP221_ID:
  	case AXP223_ID:
  	case AXP809_ID:
diff --cc drivers/remoteproc/omap_remoteproc.c
index a96ce9083f7f,d94b7391bf9d..000000000000
--- a/drivers/remoteproc/omap_remoteproc.c
+++ b/drivers/remoteproc/omap_remoteproc.c
@@@ -79,7 -510,18 +79,15 @@@ static void omap_rproc_mbox_callback(st
  	case RP_MBOX_ECHO_REPLY:
  		dev_info(dev, "received echo reply from %s\n", name);
  		break;
++<<<<<<< HEAD
++=======
+ 	case RP_MBOX_SUSPEND_ACK:
+ 	case RP_MBOX_SUSPEND_CANCEL:
+ 		oproc->suspend_acked = msg == RP_MBOX_SUSPEND_ACK;
+ 		complete(&oproc->pm_comp);
+ 		break;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
 -		if (msg >= RP_MBOX_READY && msg < RP_MBOX_END_MSG)
 -			return;
 -		if (msg > oproc->rproc->max_notifyid) {
 -			dev_dbg(dev, "dropping unknown message 0x%x", msg);
 -			return;
 -		}
  		/* msg contains the index of the triggered vring */
  		if (rproc_vq_interrupt(oproc->rproc, msg) == IRQ_NONE)
  			dev_dbg(dev, "no message was found in vqid %d\n", msg);
diff --cc drivers/reset/reset-imx7.c
index 4db177bc89bc,e8aa8691deb2..000000000000
--- a/drivers/reset/reset-imx7.c
+++ b/drivers/reset/reset-imx7.c
@@@ -113,9 -125,232 +113,238 @@@ static int imx7_reset_deassert(struct r
  	return imx7_reset_set(rcdev, id, false);
  }
  
++<<<<<<< HEAD
 +static const struct reset_control_ops imx7_reset_ops = {
 +	.assert		= imx7_reset_assert,
 +	.deassert	= imx7_reset_deassert,
++=======
+ static const struct imx7_src_variant variant_imx7 = {
+ 	.signals = imx7_src_signals,
+ 	.signals_num = ARRAY_SIZE(imx7_src_signals),
+ 	.ops = {
+ 		.assert   = imx7_reset_assert,
+ 		.deassert = imx7_reset_deassert,
+ 	},
+ };
+ 
+ enum imx8mq_src_registers {
+ 	SRC_A53RCR0		= 0x0004,
+ 	SRC_HDMI_RCR		= 0x0030,
+ 	SRC_DISP_RCR		= 0x0034,
+ 	SRC_GPU_RCR		= 0x0040,
+ 	SRC_VPU_RCR		= 0x0044,
+ 	SRC_PCIE2_RCR		= 0x0048,
+ 	SRC_MIPIPHY1_RCR	= 0x004c,
+ 	SRC_MIPIPHY2_RCR	= 0x0050,
+ 	SRC_DDRC2_RCR		= 0x1004,
+ };
+ 
+ enum imx8mp_src_registers {
+ 	SRC_SUPERMIX_RCR	= 0x0018,
+ 	SRC_AUDIOMIX_RCR	= 0x001c,
+ 	SRC_MLMIX_RCR		= 0x0028,
+ 	SRC_GPU2D_RCR		= 0x0038,
+ 	SRC_GPU3D_RCR		= 0x003c,
+ 	SRC_VPU_G1_RCR		= 0x0048,
+ 	SRC_VPU_G2_RCR		= 0x004c,
+ 	SRC_VPUVC8KE_RCR	= 0x0050,
+ 	SRC_NOC_RCR		= 0x0054,
+ };
+ 
+ static const struct imx7_src_signal imx8mq_src_signals[IMX8MQ_RESET_NUM] = {
+ 	[IMX8MQ_RESET_A53_CORE_POR_RESET0]	= { SRC_A53RCR0, BIT(0) },
+ 	[IMX8MQ_RESET_A53_CORE_POR_RESET1]	= { SRC_A53RCR0, BIT(1) },
+ 	[IMX8MQ_RESET_A53_CORE_POR_RESET2]	= { SRC_A53RCR0, BIT(2) },
+ 	[IMX8MQ_RESET_A53_CORE_POR_RESET3]	= { SRC_A53RCR0, BIT(3) },
+ 	[IMX8MQ_RESET_A53_CORE_RESET0]		= { SRC_A53RCR0, BIT(4) },
+ 	[IMX8MQ_RESET_A53_CORE_RESET1]		= { SRC_A53RCR0, BIT(5) },
+ 	[IMX8MQ_RESET_A53_CORE_RESET2]		= { SRC_A53RCR0, BIT(6) },
+ 	[IMX8MQ_RESET_A53_CORE_RESET3]		= { SRC_A53RCR0, BIT(7) },
+ 	[IMX8MQ_RESET_A53_DBG_RESET0]		= { SRC_A53RCR0, BIT(8) },
+ 	[IMX8MQ_RESET_A53_DBG_RESET1]		= { SRC_A53RCR0, BIT(9) },
+ 	[IMX8MQ_RESET_A53_DBG_RESET2]		= { SRC_A53RCR0, BIT(10) },
+ 	[IMX8MQ_RESET_A53_DBG_RESET3]		= { SRC_A53RCR0, BIT(11) },
+ 	[IMX8MQ_RESET_A53_ETM_RESET0]		= { SRC_A53RCR0, BIT(12) },
+ 	[IMX8MQ_RESET_A53_ETM_RESET1]		= { SRC_A53RCR0, BIT(13) },
+ 	[IMX8MQ_RESET_A53_ETM_RESET2]		= { SRC_A53RCR0, BIT(14) },
+ 	[IMX8MQ_RESET_A53_ETM_RESET3]		= { SRC_A53RCR0, BIT(15) },
+ 	[IMX8MQ_RESET_A53_SOC_DBG_RESET]	= { SRC_A53RCR0, BIT(20) },
+ 	[IMX8MQ_RESET_A53_L2RESET]		= { SRC_A53RCR0, BIT(21) },
+ 	[IMX8MQ_RESET_SW_NON_SCLR_M4C_RST]	= { SRC_M4RCR, BIT(0) },
+ 	[IMX8MQ_RESET_OTG1_PHY_RESET]		= { SRC_USBOPHY1_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_OTG2_PHY_RESET]		= { SRC_USBOPHY2_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_MIPI_DSI_RESET_BYTE_N]	= { SRC_MIPIPHY_RCR, BIT(1) },
+ 	[IMX8MQ_RESET_MIPI_DSI_RESET_N]		= { SRC_MIPIPHY_RCR, BIT(2) },
+ 	[IMX8MQ_RESET_MIPI_DSI_DPI_RESET_N]	= { SRC_MIPIPHY_RCR, BIT(3) },
+ 	[IMX8MQ_RESET_MIPI_DSI_ESC_RESET_N]	= { SRC_MIPIPHY_RCR, BIT(4) },
+ 	[IMX8MQ_RESET_MIPI_DSI_PCLK_RESET_N]	= { SRC_MIPIPHY_RCR, BIT(5) },
+ 	[IMX8MQ_RESET_PCIEPHY]			= { SRC_PCIEPHY_RCR,
+ 						    BIT(2) | BIT(1) },
+ 	[IMX8MQ_RESET_PCIEPHY_PERST]		= { SRC_PCIEPHY_RCR, BIT(3) },
+ 	[IMX8MQ_RESET_PCIE_CTRL_APPS_EN]	= { SRC_PCIEPHY_RCR, BIT(6) },
+ 	[IMX8MQ_RESET_PCIE_CTRL_APPS_TURNOFF]	= { SRC_PCIEPHY_RCR, BIT(11) },
+ 	[IMX8MQ_RESET_HDMI_PHY_APB_RESET]	= { SRC_HDMI_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_DISP_RESET]		= { SRC_DISP_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_GPU_RESET]		= { SRC_GPU_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_VPU_RESET]		= { SRC_VPU_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_PCIEPHY2]			= { SRC_PCIE2_RCR,
+ 						    BIT(2) | BIT(1) },
+ 	[IMX8MQ_RESET_PCIEPHY2_PERST]		= { SRC_PCIE2_RCR, BIT(3) },
+ 	[IMX8MQ_RESET_PCIE2_CTRL_APPS_EN]	= { SRC_PCIE2_RCR, BIT(6) },
+ 	[IMX8MQ_RESET_PCIE2_CTRL_APPS_TURNOFF]	= { SRC_PCIE2_RCR, BIT(11) },
+ 	[IMX8MQ_RESET_MIPI_CSI1_CORE_RESET]	= { SRC_MIPIPHY1_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_MIPI_CSI1_PHY_REF_RESET]	= { SRC_MIPIPHY1_RCR, BIT(1) },
+ 	[IMX8MQ_RESET_MIPI_CSI1_ESC_RESET]	= { SRC_MIPIPHY1_RCR, BIT(2) },
+ 	[IMX8MQ_RESET_MIPI_CSI2_CORE_RESET]	= { SRC_MIPIPHY2_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_MIPI_CSI2_PHY_REF_RESET]	= { SRC_MIPIPHY2_RCR, BIT(1) },
+ 	[IMX8MQ_RESET_MIPI_CSI2_ESC_RESET]	= { SRC_MIPIPHY2_RCR, BIT(2) },
+ 	[IMX8MQ_RESET_DDRC1_PRST]		= { SRC_DDRC_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_DDRC1_CORE_RESET]		= { SRC_DDRC_RCR, BIT(1) },
+ 	[IMX8MQ_RESET_DDRC1_PHY_RESET]		= { SRC_DDRC_RCR, BIT(2) },
+ 	[IMX8MQ_RESET_DDRC2_PHY_RESET]		= { SRC_DDRC2_RCR, BIT(0) },
+ 	[IMX8MQ_RESET_DDRC2_CORE_RESET]		= { SRC_DDRC2_RCR, BIT(1) },
+ 	[IMX8MQ_RESET_DDRC2_PRST]		= { SRC_DDRC2_RCR, BIT(2) },
+ };
+ 
+ static int imx8mq_reset_set(struct reset_controller_dev *rcdev,
+ 			    unsigned long id, bool assert)
+ {
+ 	struct imx7_src *imx7src = to_imx7_src(rcdev);
+ 	const unsigned int bit = imx7src->signals[id].bit;
+ 	unsigned int value = assert ? bit : 0;
+ 
+ 	switch (id) {
+ 	case IMX8MQ_RESET_PCIEPHY:
+ 	case IMX8MQ_RESET_PCIEPHY2:
+ 		/*
+ 		 * wait for more than 10us to release phy g_rst and
+ 		 * btnrst
+ 		 */
+ 		if (!assert)
+ 			udelay(10);
+ 		break;
+ 
+ 	case IMX8MQ_RESET_PCIE_CTRL_APPS_EN:
+ 	case IMX8MQ_RESET_PCIE2_CTRL_APPS_EN:
+ 	case IMX8MQ_RESET_MIPI_DSI_PCLK_RESET_N:
+ 	case IMX8MQ_RESET_MIPI_DSI_ESC_RESET_N:
+ 	case IMX8MQ_RESET_MIPI_DSI_DPI_RESET_N:
+ 	case IMX8MQ_RESET_MIPI_DSI_RESET_N:
+ 	case IMX8MQ_RESET_MIPI_DSI_RESET_BYTE_N:
+ 		value = assert ? 0 : bit;
+ 		break;
+ 	}
+ 
+ 	return imx7_reset_update(imx7src, id, value);
+ }
+ 
+ static int imx8mq_reset_assert(struct reset_controller_dev *rcdev,
+ 			       unsigned long id)
+ {
+ 	return imx8mq_reset_set(rcdev, id, true);
+ }
+ 
+ static int imx8mq_reset_deassert(struct reset_controller_dev *rcdev,
+ 				 unsigned long id)
+ {
+ 	return imx8mq_reset_set(rcdev, id, false);
+ }
+ 
+ static const struct imx7_src_variant variant_imx8mq = {
+ 	.signals = imx8mq_src_signals,
+ 	.signals_num = ARRAY_SIZE(imx8mq_src_signals),
+ 	.ops = {
+ 		.assert   = imx8mq_reset_assert,
+ 		.deassert = imx8mq_reset_deassert,
+ 	},
+ };
+ 
+ static const struct imx7_src_signal imx8mp_src_signals[IMX8MP_RESET_NUM] = {
+ 	[IMX8MP_RESET_A53_CORE_POR_RESET0]	= { SRC_A53RCR0, BIT(0) },
+ 	[IMX8MP_RESET_A53_CORE_POR_RESET1]	= { SRC_A53RCR0, BIT(1) },
+ 	[IMX8MP_RESET_A53_CORE_POR_RESET2]	= { SRC_A53RCR0, BIT(2) },
+ 	[IMX8MP_RESET_A53_CORE_POR_RESET3]	= { SRC_A53RCR0, BIT(3) },
+ 	[IMX8MP_RESET_A53_CORE_RESET0]		= { SRC_A53RCR0, BIT(4) },
+ 	[IMX8MP_RESET_A53_CORE_RESET1]		= { SRC_A53RCR0, BIT(5) },
+ 	[IMX8MP_RESET_A53_CORE_RESET2]		= { SRC_A53RCR0, BIT(6) },
+ 	[IMX8MP_RESET_A53_CORE_RESET3]		= { SRC_A53RCR0, BIT(7) },
+ 	[IMX8MP_RESET_A53_DBG_RESET0]		= { SRC_A53RCR0, BIT(8) },
+ 	[IMX8MP_RESET_A53_DBG_RESET1]		= { SRC_A53RCR0, BIT(9) },
+ 	[IMX8MP_RESET_A53_DBG_RESET2]		= { SRC_A53RCR0, BIT(10) },
+ 	[IMX8MP_RESET_A53_DBG_RESET3]		= { SRC_A53RCR0, BIT(11) },
+ 	[IMX8MP_RESET_A53_ETM_RESET0]		= { SRC_A53RCR0, BIT(12) },
+ 	[IMX8MP_RESET_A53_ETM_RESET1]		= { SRC_A53RCR0, BIT(13) },
+ 	[IMX8MP_RESET_A53_ETM_RESET2]		= { SRC_A53RCR0, BIT(14) },
+ 	[IMX8MP_RESET_A53_ETM_RESET3]		= { SRC_A53RCR0, BIT(15) },
+ 	[IMX8MP_RESET_A53_SOC_DBG_RESET]	= { SRC_A53RCR0, BIT(20) },
+ 	[IMX8MP_RESET_A53_L2RESET]		= { SRC_A53RCR0, BIT(21) },
+ 	[IMX8MP_RESET_SW_NON_SCLR_M7C_RST]	= { SRC_M4RCR, BIT(0) },
+ 	[IMX8MP_RESET_OTG1_PHY_RESET]		= { SRC_USBOPHY1_RCR, BIT(0) },
+ 	[IMX8MP_RESET_OTG2_PHY_RESET]		= { SRC_USBOPHY2_RCR, BIT(0) },
+ 	[IMX8MP_RESET_SUPERMIX_RESET]		= { SRC_SUPERMIX_RCR, BIT(0) },
+ 	[IMX8MP_RESET_AUDIOMIX_RESET]		= { SRC_AUDIOMIX_RCR, BIT(0) },
+ 	[IMX8MP_RESET_MLMIX_RESET]		= { SRC_MLMIX_RCR, BIT(0) },
+ 	[IMX8MP_RESET_PCIEPHY]			= { SRC_PCIEPHY_RCR, BIT(2) },
+ 	[IMX8MP_RESET_PCIEPHY_PERST]		= { SRC_PCIEPHY_RCR, BIT(3) },
+ 	[IMX8MP_RESET_PCIE_CTRL_APPS_EN]	= { SRC_PCIEPHY_RCR, BIT(6) },
+ 	[IMX8MP_RESET_PCIE_CTRL_APPS_TURNOFF]	= { SRC_PCIEPHY_RCR, BIT(11) },
+ 	[IMX8MP_RESET_HDMI_PHY_APB_RESET]	= { SRC_HDMI_RCR, BIT(0) },
+ 	[IMX8MP_RESET_MEDIA_RESET]		= { SRC_DISP_RCR, BIT(0) },
+ 	[IMX8MP_RESET_GPU2D_RESET]		= { SRC_GPU2D_RCR, BIT(0) },
+ 	[IMX8MP_RESET_GPU3D_RESET]		= { SRC_GPU3D_RCR, BIT(0) },
+ 	[IMX8MP_RESET_GPU_RESET]		= { SRC_GPU_RCR, BIT(0) },
+ 	[IMX8MP_RESET_VPU_RESET]		= { SRC_VPU_RCR, BIT(0) },
+ 	[IMX8MP_RESET_VPU_G1_RESET]		= { SRC_VPU_G1_RCR, BIT(0) },
+ 	[IMX8MP_RESET_VPU_G2_RESET]		= { SRC_VPU_G2_RCR, BIT(0) },
+ 	[IMX8MP_RESET_VPUVC8KE_RESET]		= { SRC_VPUVC8KE_RCR, BIT(0) },
+ 	[IMX8MP_RESET_NOC_RESET]		= { SRC_NOC_RCR, BIT(0) },
+ };
+ 
+ static int imx8mp_reset_set(struct reset_controller_dev *rcdev,
+ 			    unsigned long id, bool assert)
+ {
+ 	struct imx7_src *imx7src = to_imx7_src(rcdev);
+ 	const unsigned int bit = imx7src->signals[id].bit;
+ 	unsigned int value = assert ? bit : 0;
+ 
+ 	switch (id) {
+ 	case IMX8MP_RESET_PCIEPHY:
+ 		/*
+ 		 * wait for more than 10us to release phy g_rst and
+ 		 * btnrst
+ 		 */
+ 		if (!assert)
+ 			udelay(10);
+ 		break;
+ 
+ 	case IMX8MP_RESET_PCIE_CTRL_APPS_EN:
+ 		value = assert ? 0 : bit;
+ 		break;
+ 	}
+ 
+ 	return imx7_reset_update(imx7src, id, value);
+ }
+ 
+ static int imx8mp_reset_assert(struct reset_controller_dev *rcdev,
+ 			       unsigned long id)
+ {
+ 	return imx8mp_reset_set(rcdev, id, true);
+ }
+ 
+ static int imx8mp_reset_deassert(struct reset_controller_dev *rcdev,
+ 				 unsigned long id)
+ {
+ 	return imx8mp_reset_set(rcdev, id, false);
+ }
+ 
+ static const struct imx7_src_variant variant_imx8mp = {
+ 	.signals = imx8mp_src_signals,
+ 	.signals_num = ARRAY_SIZE(imx8mp_src_signals),
+ 	.ops = {
+ 		.assert   = imx8mp_reset_assert,
+ 		.deassert = imx8mp_reset_deassert,
+ 	},
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  };
  
  static int imx7_reset_probe(struct platform_device *pdev)
diff --cc drivers/rtc/rtc-m41t80.c
index ad03e2f12f5d,8a89bc52b0d4..000000000000
--- a/drivers/rtc/rtc-m41t80.c
+++ b/drivers/rtc/rtc-m41t80.c
@@@ -745,7 -740,7 +745,11 @@@ static int wdt_ioctl(struct file *file
  			return -EINVAL;
  		wdt_margin = new_margin;
  		wdt_ping();
++<<<<<<< HEAD
 +		/* Fall */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case WDIOC_GETTIMEOUT:
  		return put_user(wdt_margin, (int __user *)arg);
  
diff --cc drivers/rtc/rtc-pcf85063.c
index 49bcbb3d4a69,f8b99cb72959..000000000000
--- a/drivers/rtc/rtc-pcf85063.c
+++ b/drivers/rtc/rtc-pcf85063.c
@@@ -174,16 -261,295 +174,231 @@@ static int pcf85063_rtc_set_time(struc
  	return 0;
  }
  
 -static int pcf85063_set_offset(struct device *dev, long offset)
 -{
 -	struct pcf85063 *pcf85063 = dev_get_drvdata(dev);
 -	s8 mode0, mode1, reg;
 -	unsigned int error0, error1;
 -
 -	if (offset > PCF85063_OFFSET_STEP0 * 63)
 -		return -ERANGE;
 -	if (offset < PCF85063_OFFSET_STEP0 * -64)
 -		return -ERANGE;
 -
 -	mode0 = DIV_ROUND_CLOSEST(offset, PCF85063_OFFSET_STEP0);
 -	mode1 = DIV_ROUND_CLOSEST(offset, PCF85063_OFFSET_STEP1);
 -
 -	error0 = abs(offset - (mode0 * PCF85063_OFFSET_STEP0));
 -	error1 = abs(offset - (mode1 * PCF85063_OFFSET_STEP1));
 -	if (mode1 > 63 || mode1 < -64 || error0 < error1)
 -		reg = mode0 & ~PCF85063_OFFSET_MODE;
 -	else
 -		reg = mode1 | PCF85063_OFFSET_MODE;
 -
 -	return regmap_write(pcf85063->regmap, PCF85063_REG_OFFSET, reg);
 -}
 -
 -static int pcf85063_ioctl(struct device *dev, unsigned int cmd,
 -			  unsigned long arg)
 -{
 -	struct pcf85063 *pcf85063 = dev_get_drvdata(dev);
 -	int status, ret = 0;
 -
 -	switch (cmd) {
 -	case RTC_VL_READ:
 -		ret = regmap_read(pcf85063->regmap, PCF85063_REG_SC, &status);
 -		if (ret < 0)
 -			return ret;
 -
 -		status = status & PCF85063_REG_SC_OS ? RTC_VL_DATA_INVALID : 0;
 -
 -		return put_user(status, (unsigned int __user *)arg);
 -
 -	default:
 -		return -ENOIOCTLCMD;
 -	}
 -}
 -
  static const struct rtc_class_ops pcf85063_rtc_ops = {
  	.read_time	= pcf85063_rtc_read_time,
 -	.set_time	= pcf85063_rtc_set_time,
 -	.read_offset	= pcf85063_read_offset,
 -	.set_offset	= pcf85063_set_offset,
 -	.ioctl		= pcf85063_ioctl,
 +	.set_time	= pcf85063_rtc_set_time
  };
  
 -static const struct rtc_class_ops pcf85063_rtc_ops_alarm = {
 -	.read_time	= pcf85063_rtc_read_time,
 -	.set_time	= pcf85063_rtc_set_time,
 -	.read_offset	= pcf85063_read_offset,
 -	.set_offset	= pcf85063_set_offset,
 -	.read_alarm	= pcf85063_rtc_read_alarm,
 -	.set_alarm	= pcf85063_rtc_set_alarm,
 -	.alarm_irq_enable = pcf85063_rtc_alarm_irq_enable,
 -	.ioctl		= pcf85063_ioctl,
 -};
 -
 -static int pcf85063_nvmem_read(void *priv, unsigned int offset,
 -			       void *val, size_t bytes)
 +static int pcf85063_probe(struct i2c_client *client,
 +				const struct i2c_device_id *id)
  {
++<<<<<<< HEAD
 +	struct rtc_device *rtc;
++=======
+ 	return regmap_read(priv, PCF85063_REG_RAM, val);
+ }
+ 
+ static int pcf85063_nvmem_write(void *priv, unsigned int offset,
+ 				void *val, size_t bytes)
+ {
+ 	return regmap_write(priv, PCF85063_REG_RAM, *(u8 *)val);
+ }
+ 
+ static int pcf85063_load_capacitance(struct pcf85063 *pcf85063,
+ 				     const struct device_node *np,
+ 				     unsigned int force_cap)
+ {
+ 	u32 load = 7000;
+ 	u8 reg = 0;
+ 
+ 	if (force_cap)
+ 		load = force_cap;
+ 	else
+ 		of_property_read_u32(np, "quartz-load-femtofarads", &load);
+ 
+ 	switch (load) {
+ 	default:
+ 		dev_warn(&pcf85063->rtc->dev, "Unknown quartz-load-femtofarads value: %d. Assuming 7000",
+ 			 load);
+ 		fallthrough;
+ 	case 7000:
+ 		break;
+ 	case 12500:
+ 		reg = PCF85063_REG_CTRL1_CAP_SEL;
+ 		break;
+ 	}
+ 
+ 	return regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL1,
+ 				  PCF85063_REG_CTRL1_CAP_SEL, reg);
+ }
+ 
+ #ifdef CONFIG_COMMON_CLK
+ /*
+  * Handling of the clkout
+  */
+ 
+ #define clkout_hw_to_pcf85063(_hw) container_of(_hw, struct pcf85063, clkout_hw)
+ 
+ static int clkout_rates[] = {
+ 	32768,
+ 	16384,
+ 	8192,
+ 	4096,
+ 	2048,
+ 	1024,
+ 	1,
+ 	0
+ };
+ 
+ static unsigned long pcf85063_clkout_recalc_rate(struct clk_hw *hw,
+ 						 unsigned long parent_rate)
+ {
+ 	struct pcf85063 *pcf85063 = clkout_hw_to_pcf85063(hw);
+ 	unsigned int buf;
+ 	int ret = regmap_read(pcf85063->regmap, PCF85063_REG_CTRL2, &buf);
+ 
+ 	if (ret < 0)
+ 		return 0;
+ 
+ 	buf &= PCF85063_REG_CLKO_F_MASK;
+ 	return clkout_rates[buf];
+ }
+ 
+ static long pcf85063_clkout_round_rate(struct clk_hw *hw, unsigned long rate,
+ 				       unsigned long *prate)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(clkout_rates); i++)
+ 		if (clkout_rates[i] <= rate)
+ 			return clkout_rates[i];
+ 
+ 	return 0;
+ }
+ 
+ static int pcf85063_clkout_set_rate(struct clk_hw *hw, unsigned long rate,
+ 				    unsigned long parent_rate)
+ {
+ 	struct pcf85063 *pcf85063 = clkout_hw_to_pcf85063(hw);
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(clkout_rates); i++)
+ 		if (clkout_rates[i] == rate)
+ 			return regmap_update_bits(pcf85063->regmap,
+ 				PCF85063_REG_CTRL2,
+ 				PCF85063_REG_CLKO_F_MASK, i);
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int pcf85063_clkout_control(struct clk_hw *hw, bool enable)
+ {
+ 	struct pcf85063 *pcf85063 = clkout_hw_to_pcf85063(hw);
+ 	unsigned int buf;
+ 	int ret;
+ 
+ 	ret = regmap_read(pcf85063->regmap, PCF85063_REG_OFFSET, &buf);
+ 	if (ret < 0)
+ 		return ret;
+ 	buf &= PCF85063_REG_CLKO_F_MASK;
+ 
+ 	if (enable) {
+ 		if (buf == PCF85063_REG_CLKO_F_OFF)
+ 			buf = PCF85063_REG_CLKO_F_32768HZ;
+ 		else
+ 			return 0;
+ 	} else {
+ 		if (buf != PCF85063_REG_CLKO_F_OFF)
+ 			buf = PCF85063_REG_CLKO_F_OFF;
+ 		else
+ 			return 0;
+ 	}
+ 
+ 	return regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL2,
+ 					PCF85063_REG_CLKO_F_MASK, buf);
+ }
+ 
+ static int pcf85063_clkout_prepare(struct clk_hw *hw)
+ {
+ 	return pcf85063_clkout_control(hw, 1);
+ }
+ 
+ static void pcf85063_clkout_unprepare(struct clk_hw *hw)
+ {
+ 	pcf85063_clkout_control(hw, 0);
+ }
+ 
+ static int pcf85063_clkout_is_prepared(struct clk_hw *hw)
+ {
+ 	struct pcf85063 *pcf85063 = clkout_hw_to_pcf85063(hw);
+ 	unsigned int buf;
+ 	int ret = regmap_read(pcf85063->regmap, PCF85063_REG_CTRL2, &buf);
+ 
+ 	if (ret < 0)
+ 		return 0;
+ 
+ 	return (buf & PCF85063_REG_CLKO_F_MASK) != PCF85063_REG_CLKO_F_OFF;
+ }
+ 
+ static const struct clk_ops pcf85063_clkout_ops = {
+ 	.prepare = pcf85063_clkout_prepare,
+ 	.unprepare = pcf85063_clkout_unprepare,
+ 	.is_prepared = pcf85063_clkout_is_prepared,
+ 	.recalc_rate = pcf85063_clkout_recalc_rate,
+ 	.round_rate = pcf85063_clkout_round_rate,
+ 	.set_rate = pcf85063_clkout_set_rate,
+ };
+ 
+ static struct clk *pcf85063_clkout_register_clk(struct pcf85063 *pcf85063)
+ {
+ 	struct clk *clk;
+ 	struct clk_init_data init;
+ 
+ 	init.name = "pcf85063-clkout";
+ 	init.ops = &pcf85063_clkout_ops;
+ 	init.flags = 0;
+ 	init.parent_names = NULL;
+ 	init.num_parents = 0;
+ 	pcf85063->clkout_hw.init = &init;
+ 
+ 	/* optional override of the clockname */
+ 	of_property_read_string(pcf85063->rtc->dev.of_node,
+ 				"clock-output-names", &init.name);
+ 
+ 	/* register the clock */
+ 	clk = devm_clk_register(&pcf85063->rtc->dev, &pcf85063->clkout_hw);
+ 
+ 	if (!IS_ERR(clk))
+ 		of_clk_add_provider(pcf85063->rtc->dev.of_node,
+ 				    of_clk_src_simple_get, clk);
+ 
+ 	return clk;
+ }
+ #endif
+ 
+ static const struct pcf85063_config pcf85063a_config = {
+ 	.regmap = {
+ 		.reg_bits = 8,
+ 		.val_bits = 8,
+ 		.max_register = 0x11,
+ 	},
+ 	.has_alarms = 1,
+ };
+ 
+ static const struct pcf85063_config pcf85063tp_config = {
+ 	.regmap = {
+ 		.reg_bits = 8,
+ 		.val_bits = 8,
+ 		.max_register = 0x0a,
+ 	},
+ };
+ 
+ static const struct pcf85063_config rv8263_config = {
+ 	.regmap = {
+ 		.reg_bits = 8,
+ 		.val_bits = 8,
+ 		.max_register = 0x11,
+ 	},
+ 	.has_alarms = 1,
+ 	.force_cap_7000 = 1,
+ };
+ 
+ static int pcf85063_probe(struct i2c_client *client)
+ {
+ 	struct pcf85063 *pcf85063;
+ 	unsigned int tmp;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	int err;
 -	const struct pcf85063_config *config = &pcf85063tp_config;
 -	const void *data = of_device_get_match_data(&client->dev);
 -	struct nvmem_config nvmem_cfg = {
 -		.name = "pcf85063_nvram",
 -		.reg_read = pcf85063_nvmem_read,
 -		.reg_write = pcf85063_nvmem_write,
 -		.type = NVMEM_TYPE_BATTERY_BACKED,
 -		.size = 1,
 -	};
  
  	dev_dbg(&client->dev, "%s\n", __func__);
  
diff --cc drivers/rtc/rtc-pcf8523.c
index 453615f8ac9a,57d351dfe272..000000000000
--- a/drivers/rtc/rtc-pcf8523.c
+++ b/drivers/rtc/rtc-pcf8523.c
@@@ -94,14 -100,24 +94,30 @@@ static int pcf8523_select_capacitance(s
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	if (!high)
++=======
+ 	load = 12500;
+ 	of_property_read_u32(client->dev.of_node, "quartz-load-femtofarads",
+ 			     &load);
+ 
+ 	switch (load) {
+ 	default:
+ 		dev_warn(&client->dev, "Unknown quartz-load-femtofarads value: %d. Assuming 12500",
+ 			 load);
+ 		fallthrough;
+ 	case 12500:
+ 		value |= REG_CONTROL1_CAP_SEL;
+ 		break;
+ 	case 7000:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		value &= ~REG_CONTROL1_CAP_SEL;
 -		break;
 -	}
 +	else
 +		value |= REG_CONTROL1_CAP_SEL;
  
  	err = pcf8523_write(client, REG_CONTROL1, value);
 +	if (err < 0)
 +		return err;
  
  	return err;
  }
diff --cc drivers/scsi/BusLogic.c
index 0d4ffe0ae306,ccb061ab0a0a..000000000000
--- a/drivers/scsi/BusLogic.c
+++ b/drivers/scsi/BusLogic.c
@@@ -2639,6 -2635,7 +2639,10 @@@ static int blogic_resultcode(struct blo
  	case BLOGIC_BAD_CMD_PARAM:
  		blogic_warn("BusLogic Driver Protocol Error 0x%02X\n",
  				adapter, adapter_status);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case BLOGIC_DATA_UNDERRUN:
  	case BLOGIC_DATA_OVERRUN:
  	case BLOGIC_NOEXPECT_BUSFREE:
diff --cc drivers/scsi/NCR5380.c
index 90ea0f5d9bdb,d654a6cc4162..000000000000
--- a/drivers/scsi/NCR5380.c
+++ b/drivers/scsi/NCR5380.c
@@@ -1923,13 -1942,13 +1923,19 @@@ static void NCR5380_information_transfe
  					if (!hostdata->connected)
  						return;
  
++<<<<<<< HEAD
 +					/* Fall through to reject message */
 +
++=======
+ 					/* Reject message */
+ 					fallthrough;
+ 				default:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  					/*
  					 * If we get something weird that we aren't expecting,
 -					 * log it.
 +					 * reject it.
  					 */
 +				default:
  					if (tmp == EXTENDED_MESSAGE)
  						scmd_printk(KERN_INFO, cmd,
  						            "rejecting unknown extended message code %02x, length %d\n",
diff --cc drivers/scsi/aacraid/aachba.c
index a57f3a7d4748,fd6ae5c38086..000000000000
--- a/drivers/scsi/aacraid/aachba.c
+++ b/drivers/scsi/aacraid/aachba.c
@@@ -2894,6 -2809,7 +2894,10 @@@ int aac_scsi_cmd(struct scsi_cmnd * scs
  					    !(dev->raw_io_64) ||
  					    ((scsicmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))
  						break;
++<<<<<<< HEAD
++=======
+ 					fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  				case INQUIRY:
  				case READ_CAPACITY:
  				case TEST_UNIT_READY:
@@@ -2967,6 -2884,7 +2971,10 @@@
  		/* Issue FIB to tell Firmware to flush it's cache */
  		if ((aac_cache & 6) != 2)
  			return aac_synchronize(scsicmd);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case INQUIRY:
  	{
  		struct inquiry_data inq_data;
@@@ -3307,8 -3238,9 +3315,12 @@@
  			       min_t(size_t,
  				     sizeof(dev->fsa_dev[cid].sense_data),
  				     SCSI_SENSE_BUFFERSIZE));
 -			break;
 +		break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case RESERVE:
  	case RELEASE:
  	case REZERO_UNIT:
diff --cc drivers/scsi/aacraid/linit.c
index ab0f6d51b1fe,a3aee146537b..000000000000
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@@ -691,6 -765,7 +691,10 @@@ static int aac_eh_abort(struct scsi_cmn
  			    !(aac->raw_io_64) ||
  			    ((cmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case INQUIRY:
  		case READ_CAPACITY:
  			/*
diff --cc drivers/scsi/aic7xxx/aic79xx_core.c
index 2d82ec85753e,1c617c0d5899..000000000000
--- a/drivers/scsi/aic7xxx/aic79xx_core.c
+++ b/drivers/scsi/aic7xxx/aic79xx_core.c
@@@ -2293,6 -2274,7 +2293,10 @@@ ahd_handle_seqint(struct ahd_softc *ahd
  			switch (scb->hscb->task_management) {
  			case SIU_TASKMGMT_ABORT_TASK:
  				tag = SCB_GET_TAG(scb);
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case SIU_TASKMGMT_ABORT_TASK_SET:
  			case SIU_TASKMGMT_CLEAR_TASK_SET:
  				lun = scb->hscb->lun;
@@@ -2303,6 -2285,7 +2307,10 @@@
  				break;
  			case SIU_TASKMGMT_LUN_RESET:
  				lun = scb->hscb->lun;
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case SIU_TASKMGMT_TARGET_RESET:
  			{
  				struct ahd_devinfo devinfo;
@@@ -6564,8 -6512,8 +6572,12 @@@ ahd_fini_scbdata(struct ahd_softc *ahd
  			kfree(sns_map);
  		}
  		ahd_dma_tag_destroy(ahd, scb_data->sense_dmat);
 +		/* FALLTHROUGH */
  	}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 6:
  	{
  		struct map_node *sg_map;
@@@ -6579,8 -6527,8 +6591,12 @@@
  			kfree(sg_map);
  		}
  		ahd_dma_tag_destroy(ahd, scb_data->sg_dmat);
 +		/* FALLTHROUGH */
  	}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 5:
  	{
  		struct map_node *hscb_map;
@@@ -7253,6 -7171,7 +7269,10 @@@ ahd_init(struct ahd_softc *ahd
  		case FLX_CSTAT_OVER:
  		case FLX_CSTAT_UNDER:
  			warn_user++;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case FLX_CSTAT_INVALID:
  		case FLX_CSTAT_OKAY:
  			if (warn_user == 0 && bootverbose == 0)
@@@ -8457,7 -8376,7 +8477,11 @@@ ahd_search_scb_list(struct ahd_softc *a
  			if ((scb->flags & SCB_ACTIVE) == 0)
  				printk("Inactive SCB in Waiting List\n");
  			ahd_done_with_status(ahd, scb, status);
++<<<<<<< HEAD
 +			/* FALLTHROUGH */
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case SEARCH_REMOVE:
  			ahd_rem_wscb(ahd, scbid, prev, next, tid);
  			*list_tail = prev;
@@@ -8466,6 -8385,7 +8490,10 @@@
  			break;
  		case SEARCH_PRINT:
  			printk("0x%x ", scbid);
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case SEARCH_COUNT:
  			prev = scbid;
  			break;
@@@ -9591,8 -9511,8 +9619,12 @@@ ahd_download_instr(struct ahd_softc *ah
  	{
  		fmt3_ins = &instr.format3;
  		fmt3_ins->address = ahd_resolve_seqaddr(ahd, fmt3_ins->address);
 +		/* FALLTHROUGH */
  	}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AIC_OP_OR:
  	case AIC_OP_AND:
  	case AIC_OP_XOR:
@@@ -9603,7 -9523,7 +9635,11 @@@
  			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
  		}
  		fmt1_ins->parity = 0;
++<<<<<<< HEAD
 +		/* FALLTHROUGH */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AIC_OP_ROL:
  	{
  		int i, count;
diff --cc drivers/scsi/aic7xxx/aic7xxx_core.c
index 915a34f141e4,2231c4afa531..000000000000
--- a/drivers/scsi/aic7xxx/aic7xxx_core.c
+++ b/drivers/scsi/aic7xxx/aic7xxx_core.c
@@@ -4933,24 -4893,30 +4933,47 @@@ ahc_fini_scbdata(struct ahc_softc *ahc
  		}
  		ahc_dma_tag_destroy(ahc, scb_data->sg_dmat);
  	}
++<<<<<<< HEAD
 +	case 6:
 +		ahc_dmamap_unload(ahc, scb_data->sense_dmat,
 +				  scb_data->sense_dmamap);
++=======
+ 		fallthrough;
+ 	case 6:
+ 		ahc_dmamap_unload(ahc, scb_data->sense_dmat,
+ 				  scb_data->sense_dmamap);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 5:
  		ahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,
  				scb_data->sense_dmamap);
  		ahc_dmamap_destroy(ahc, scb_data->sense_dmat,
  				   scb_data->sense_dmamap);
++<<<<<<< HEAD
++	case 4:
++		ahc_dma_tag_destroy(ahc, scb_data->sense_dmat);
++	case 3:
++		ahc_dmamap_unload(ahc, scb_data->hscb_dmat,
++				  scb_data->hscb_dmamap);
++=======
+ 		fallthrough;
  	case 4:
  		ahc_dma_tag_destroy(ahc, scb_data->sense_dmat);
+ 		fallthrough;
  	case 3:
  		ahc_dmamap_unload(ahc, scb_data->hscb_dmat,
  				  scb_data->hscb_dmamap);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		ahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,
  				scb_data->hscb_dmamap);
  		ahc_dmamap_destroy(ahc, scb_data->hscb_dmat,
  				   scb_data->hscb_dmamap);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		ahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);
  		break;
@@@ -6041,8 -5980,8 +6064,12 @@@ ahc_search_qinfifo(struct ahc_softc *ah
  				if ((scb->flags & SCB_ACTIVE) == 0)
  					printk("Inactive SCB in Waiting List\n");
  				ahc_done(ahc, scb);
 +				/* FALLTHROUGH */
  			}
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case SEARCH_REMOVE:
  				next = ahc_rem_wscb(ahc, next, prev);
  				break;
@@@ -7047,8 -6986,8 +7074,12 @@@ ahc_download_instr(struct ahc_softc *ah
  		}
  		address -= address_offset;
  		fmt3_ins->address = address;
 +		/* FALLTHROUGH */
  	}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AIC_OP_OR:
  	case AIC_OP_AND:
  	case AIC_OP_XOR:
@@@ -7074,7 -7013,7 +7105,11 @@@
  			fmt1_ins->opcode = AIC_OP_AND;
  			fmt1_ins->immediate = 0xff;
  		}
++<<<<<<< HEAD
 +		/* FALLTHROUGH */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AIC_OP_ROL:
  		if ((ahc->features & AHC_ULTRA2) != 0) {
  			int i, count;
diff --cc drivers/scsi/aic94xx/aic94xx_scb.c
index 22873ce8bbfa,e2d880a5f391..000000000000
--- a/drivers/scsi/aic94xx/aic94xx_scb.c
+++ b/drivers/scsi/aic94xx/aic94xx_scb.c
@@@ -724,9 -706,11 +724,17 @@@ static void set_speed_mask(u8 *speed_ma
  	switch (pd->max_sas_lrate) {
  	case SAS_LINK_RATE_6_0_GBPS:
  		*speed_mask &= ~SAS_SPEED_60_DIS;
++<<<<<<< HEAD
 +	default:
 +	case SAS_LINK_RATE_3_0_GBPS:
 +		*speed_mask &= ~SAS_SPEED_30_DIS;
++=======
+ 		fallthrough;
+ 	default:
+ 	case SAS_LINK_RATE_3_0_GBPS:
+ 		*speed_mask &= ~SAS_SPEED_30_DIS;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SAS_LINK_RATE_1_5_GBPS:
  		*speed_mask &= ~SAS_SPEED_15_DIS;
  	}
@@@ -734,6 -718,7 +742,10 @@@
  	switch (pd->min_sas_lrate) {
  	case SAS_LINK_RATE_6_0_GBPS:
  		*speed_mask |= SAS_SPEED_30_DIS;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SAS_LINK_RATE_3_0_GBPS:
  		*speed_mask |= SAS_SPEED_15_DIS;
  	default:
@@@ -745,6 -730,7 +757,10 @@@
  	switch (pd->max_sata_lrate) {
  	case SAS_LINK_RATE_3_0_GBPS:
  		*speed_mask &= ~SATA_SPEED_30_DIS;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  	case SAS_LINK_RATE_1_5_GBPS:
  		*speed_mask &= ~SATA_SPEED_15_DIS;
@@@ -803,6 -789,7 +819,10 @@@ void asd_build_control_phy(struct asd_a
  
  		/* link reset retries, this should be nominal */
  		control_phy->link_reset_retries = 10;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case RELEASE_SPINUP_HOLD: /* 0x02 */
  		/* decide the func_mask */
diff --cc drivers/scsi/arm/fas216.c
index 2b6580e02b25,2e687ce60753..000000000000
--- a/drivers/scsi/arm/fas216.c
+++ b/drivers/scsi/arm/fas216.c
@@@ -606,6 -603,7 +606,10 @@@ static void fas216_handlesync(FAS216_In
  		msgqueue_flush(&info->scsi.msgs);
  		msgqueue_addmsg(&info->scsi.msgs, 1, MESSAGE_REJECT);
  		info->scsi.phase = PHASE_MSGOUT_EXPECT;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case async:
  		dev->period = info->ifcfg.asyncperiod / 4;
@@@ -918,6 -916,7 +922,10 @@@ static void fas216_disconnect_intr(FAS2
  			fas216_done(info, DID_ABORT);
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:				/* huh?					*/
  		printk(KERN_ERR "scsi%d.%c: unexpected disconnect in phase %s\n",
@@@ -1414,6 -1413,8 +1422,11 @@@ static void fas216_busservice_intr(FAS2
  	case STATE(STAT_STATUS, PHASE_DATAOUT): /* Data Out     -> Status       */
  	case STATE(STAT_STATUS, PHASE_DATAIN):  /* Data In      -> Status       */
  		fas216_stoptransfer(info);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case STATE(STAT_STATUS, PHASE_SELSTEPS):/* Sel w/ steps -> Status       */
  	case STATE(STAT_STATUS, PHASE_MSGOUT):  /* Message Out  -> Status       */
  	case STATE(STAT_STATUS, PHASE_COMMAND): /* Command      -> Status       */
@@@ -1425,6 -1426,8 +1438,11 @@@
  	case STATE(STAT_MESGIN, PHASE_DATAOUT): /* Data Out     -> Message In   */
  	case STATE(STAT_MESGIN, PHASE_DATAIN):  /* Data In      -> Message In   */
  		fas216_stoptransfer(info);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case STATE(STAT_MESGIN, PHASE_COMMAND):	/* Command	-> Message In	*/
  	case STATE(STAT_MESGIN, PHASE_SELSTEPS):/* Sel w/ steps -> Message In   */
  	case STATE(STAT_MESGIN, PHASE_MSGOUT):  /* Message Out  -> Message In   */
@@@ -1578,6 -1581,7 +1596,10 @@@ static void fas216_funcdone_intr(FAS216
  			fas216_message(info);
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		fas216_log(info, 0, "internal phase %s for function done?"
@@@ -1960,6 -1964,7 +1982,10 @@@ static void fas216_kick(FAS216_Info *in
  	switch (where_from) {
  	case TYPE_QUEUE:
  		fas216_allocate_tag(info, SCpnt);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case TYPE_OTHER:
  		fas216_start_command(info, SCpnt);
  		break;
diff --cc drivers/scsi/bfa/bfa_fcpim.c
index 2c85f5b1f9c1,38d1c453074d..000000000000
--- a/drivers/scsi/bfa/bfa_fcpim.c
+++ b/drivers/scsi/bfa/bfa_fcpim.c
@@@ -2586,6 -2572,7 +2586,10 @@@ bfa_ioim_send_ioreq(struct bfa_ioim_s *
  	case FCP_IODIR_RW:
  		bfa_stats(itnim, input_reqs);
  		bfa_stats(itnim, output_reqs);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		bfi_h2i_set(m->mh, BFI_MC_IOIM_IO, 0, bfa_fn_lpu(ioim->bfa));
  	}
@@@ -2820,6 -2807,7 +2824,10 @@@ bfa_ioim_isr(struct bfa_s *bfa, struct 
  
  	case BFI_IOIM_STS_TIMEDOUT:
  		bfa_stats(ioim->itnim, iocomp_timedout);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case BFI_IOIM_STS_ABORTED:
  		rsp->io_status = BFI_IOIM_STS_ABORTED;
  		bfa_stats(ioim->itnim, iocomp_aborted);
@@@ -3215,9 -3203,7 +3223,13 @@@ bfa_tskim_sm_cleanup_qfull(struct bfa_t
  	switch (event) {
  	case BFA_TSKIM_SM_DONE:
  		bfa_reqq_wcancel(&tskim->reqq_wait);
++<<<<<<< HEAD
 +		/*
 +		 * Fall through !!!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case BFA_TSKIM_SM_QRESUME:
  		bfa_sm_set_state(tskim, bfa_tskim_sm_cleanup);
  		bfa_tskim_send_abort(tskim);
diff --cc drivers/scsi/bfa/bfa_fcs_lport.c
index b4f2c1d8742e,3486e402bfc1..000000000000
--- a/drivers/scsi/bfa/bfa_fcs_lport.c
+++ b/drivers/scsi/bfa/bfa_fcs_lport.c
@@@ -6430,9 -6422,7 +6430,13 @@@ bfa_fcs_vport_sm_logo_for_stop(struct b
  	switch (event) {
  	case BFA_FCS_VPORT_SM_OFFLINE:
  		bfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);
++<<<<<<< HEAD
 +		/*
 +		 * !!! fall through !!!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case BFA_FCS_VPORT_SM_RSP_OK:
  	case BFA_FCS_VPORT_SM_RSP_ERROR:
@@@ -6458,9 -6448,7 +6462,13 @@@ bfa_fcs_vport_sm_logo(struct bfa_fcs_vp
  	switch (event) {
  	case BFA_FCS_VPORT_SM_OFFLINE:
  		bfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);
++<<<<<<< HEAD
 +		/*
 +		 * !!! fall through !!!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case BFA_FCS_VPORT_SM_RSP_OK:
  	case BFA_FCS_VPORT_SM_RSP_ERROR:
diff --cc drivers/scsi/bfa/bfa_fcs_rport.c
index de50349a39ce,c21aa37b8adb..000000000000
--- a/drivers/scsi/bfa/bfa_fcs_rport.c
+++ b/drivers/scsi/bfa/bfa_fcs_rport.c
@@@ -427,17 -419,13 +427,25 @@@ bfa_fcs_rport_sm_plogi(struct bfa_fcs_r
  
  	case RPSM_EVENT_LOGO_RCVD:
  		bfa_fcs_rport_send_logo_acc(rport);
++<<<<<<< HEAD
 +		/*
 +		 * !! fall through !!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case RPSM_EVENT_PRLO_RCVD:
  		if (rport->prlo == BFA_TRUE)
  			bfa_fcs_rport_send_prlo_acc(rport);
  
  		bfa_fcxp_discard(rport->fcxp);
++<<<<<<< HEAD
 +		/*
 +		 * !! fall through !!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case RPSM_EVENT_FAILED:
  		if (rport->plogi_retries < BFA_FCS_RPORT_MAX_RETRIES) {
  			rport->plogi_retries++;
@@@ -868,9 -856,7 +876,13 @@@ bfa_fcs_rport_sm_adisc_online(struct bf
  		 * At least go offline when a PLOGI is received.
  		 */
  		bfa_fcxp_discard(rport->fcxp);
++<<<<<<< HEAD
 +		/*
 +		 * !!! fall through !!!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case RPSM_EVENT_FAILED:
  	case RPSM_EVENT_ADDRESS_CHANGE:
@@@ -1056,6 -1042,7 +1068,10 @@@ bfa_fcs_rport_sm_fc4_logosend(struct bf
  
  	case RPSM_EVENT_LOGO_RCVD:
  		bfa_fcs_rport_send_logo_acc(rport);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case RPSM_EVENT_PRLO_RCVD:
  		if (rport->prlo == BFA_TRUE)
  			bfa_fcs_rport_send_prlo_acc(rport);
@@@ -1144,9 -1131,7 +1160,13 @@@ bfa_fcs_rport_sm_hcb_offline(struct bfa
  			bfa_fcs_rport_send_plogiacc(rport, NULL);
  			break;
  		}
++<<<<<<< HEAD
 +		/*
 +		 * !! fall through !!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case RPSM_EVENT_ADDRESS_CHANGE:
  		if (!bfa_fcs_lport_is_online(rport->port)) {
@@@ -1303,6 -1288,7 +1323,10 @@@ bfa_fcs_rport_sm_hcb_logosend(struct bf
  
  	case RPSM_EVENT_LOGO_RCVD:
  		bfa_fcs_rport_send_logo_acc(rport);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case RPSM_EVENT_PRLO_RCVD:
  		if (rport->prlo == BFA_TRUE)
  			bfa_fcs_rport_send_prlo_acc(rport);
@@@ -1346,6 -1332,7 +1370,10 @@@ bfa_fcs_rport_sm_logo_sending(struct bf
  
  	case RPSM_EVENT_LOGO_RCVD:
  		bfa_fcs_rport_send_logo_acc(rport);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case RPSM_EVENT_PRLO_RCVD:
  		if (rport->prlo == BFA_TRUE)
  			bfa_fcs_rport_send_prlo_acc(rport);
diff --cc drivers/scsi/bfa/bfa_ioc.c
index 16d3aeb0e572,325ad8a592bb..000000000000
--- a/drivers/scsi/bfa/bfa_ioc.c
+++ b/drivers/scsi/bfa/bfa_ioc.c
@@@ -978,9 -969,7 +978,13 @@@ bfa_iocpf_sm_enabling(struct bfa_iocpf_
  
  	case IOCPF_E_INITFAIL:
  		bfa_iocpf_timer_stop(ioc);
++<<<<<<< HEAD
 +		/*
 +		 * !!! fall through !!!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case IOCPF_E_TIMEOUT:
  		writel(1, ioc->ioc_regs.ioc_sem_reg);
@@@ -1056,9 -1045,7 +1060,13 @@@ bfa_iocpf_sm_disabling(struct bfa_iocpf
  
  	case IOCPF_E_FAIL:
  		bfa_iocpf_timer_stop(ioc);
++<<<<<<< HEAD
 +		/*
 +		 * !!! fall through !!!
 +		 */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case IOCPF_E_TIMEOUT:
  		bfa_ioc_set_cur_ioc_fwstate(ioc, BFI_IOC_FAIL);
@@@ -6007,6 -5988,7 +6015,10 @@@ bfa_dconf_sm_final_sync(struct bfa_dcon
  	case BFA_DCONF_SM_IOCDISABLE:
  	case BFA_DCONF_SM_FLASH_COMP:
  		bfa_timer_stop(&dconf->timer);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case BFA_DCONF_SM_TIMEOUT:
  		bfa_sm_set_state(dconf, bfa_dconf_sm_uninit);
  		bfa_fsm_send_event(&dconf->bfa->iocfc, IOCFC_E_DCONF_DONE);
diff --cc drivers/scsi/csiostor/csio_wr.c
index dc12933533d5,9010cb6045dc..000000000000
--- a/drivers/scsi/csiostor/csio_wr.c
+++ b/drivers/scsi/csiostor/csio_wr.c
@@@ -808,6 -808,7 +808,10 @@@ csio_wr_destroy_queues(struct csio_hw *
  
  				csio_q_eqid(hw, i) = CSIO_MAX_QID;
  			}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case CSIO_INGRESS:
  			if (csio_q_iqid(hw, i) != CSIO_MAX_QID) {
  				csio_wr_cleanup_iq_ftr(hw, i);
diff --cc drivers/scsi/cxlflash/main.c
index 724e8ab59f37,e72440d919d2..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -757,13 -748,16 +757,23 @@@ static void term_intr(struct cxlflash_c
  		/* SISL_MSI_ASYNC_ERROR is setup only for the primary HWQ */
  		if (index == PRIMARY_HWQ)
  			cfg->ops->unmap_afu_irq(hwq->ctx_cookie, 3, hwq);
++<<<<<<< HEAD
 +	case UNMAP_TWO:
 +		cfg->ops->unmap_afu_irq(hwq->ctx_cookie, 2, hwq);
 +	case UNMAP_ONE:
 +		cfg->ops->unmap_afu_irq(hwq->ctx_cookie, 1, hwq);
++=======
+ 		fallthrough;
+ 	case UNMAP_TWO:
+ 		cfg->ops->unmap_afu_irq(hwq->ctx_cookie, 2, hwq);
+ 		fallthrough;
+ 	case UNMAP_ONE:
+ 		cfg->ops->unmap_afu_irq(hwq->ctx_cookie, 1, hwq);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FREE_IRQ:
  		cfg->ops->free_afu_irqs(hwq->ctx_cookie);
- 		/* fall through */
+ 		fallthrough;
  	case UNDO_NOOP:
  		/* No action required */
  		break;
@@@ -977,14 -971,18 +987,29 @@@ static void cxlflash_remove(struct pci_
  	switch (cfg->init_state) {
  	case INIT_STATE_CDEV:
  		cxlflash_release_chrdev(cfg);
++<<<<<<< HEAD
 +	case INIT_STATE_SCSI:
 +		cxlflash_term_local_luns(cfg);
 +		scsi_remove_host(cfg->host);
 +	case INIT_STATE_AFU:
 +		term_afu(cfg);
 +	case INIT_STATE_PCI:
 +		cfg->ops->destroy_afu(cfg->afu_cookie);
 +		pci_disable_device(pdev);
++=======
+ 		fallthrough;
+ 	case INIT_STATE_SCSI:
+ 		cxlflash_term_local_luns(cfg);
+ 		scsi_remove_host(cfg->host);
+ 		fallthrough;
+ 	case INIT_STATE_AFU:
+ 		term_afu(cfg);
+ 		fallthrough;
+ 	case INIT_STATE_PCI:
+ 		cfg->ops->destroy_afu(cfg->afu_cookie);
+ 		pci_disable_device(pdev);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case INIT_STATE_NONE:
  		free_mem(cfg);
  		scsi_host_put(cfg->host);
@@@ -2357,11 -2355,11 +2382,19 @@@ retry
  			cxlflash_schedule_async_reset(cfg);
  			break;
  		}
++<<<<<<< HEAD
 +		/* fall through to retry */
 +	case -EAGAIN:
 +		if (++nretry < 2)
 +			goto retry;
 +		/* fall through to exit */
++=======
+ 		fallthrough;	/* to retry */
+ 	case -EAGAIN:
+ 		if (++nretry < 2)
+ 			goto retry;
+ 		fallthrough;	/* to exit */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		break;
  	}
@@@ -3021,6 -3019,7 +3054,10 @@@ retry
  		wait_event(cfg->reset_waitq, cfg->state != STATE_RESET);
  		if (cfg->state == STATE_NORMAL)
  			goto retry;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		/* Ideally should not happen */
  		dev_err(dev, "%s: Device is not ready, state=%d\n",
diff --cc drivers/scsi/esas2r/esas2r_init.c
index bbe77db8938d,09c5c24bf391..000000000000
--- a/drivers/scsi/esas2r/esas2r_init.c
+++ b/drivers/scsi/esas2r/esas2r_init.c
@@@ -1262,6 -1236,7 +1262,10 @@@ static bool esas2r_format_init_msg(stru
  			a->init_msg = ESAS2R_INIT_MSG_GET_INIT;
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case ESAS2R_INIT_MSG_GET_INIT:
  		if (msg == ESAS2R_INIT_MSG_GET_INIT) {
@@@ -1275,7 -1250,7 +1279,11 @@@
  				esas2r_hdebug("FAILED");
  			}
  		}
++<<<<<<< HEAD
 +	/* fall through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		rq->req_stat = RS_SUCCESS;
diff --cc drivers/scsi/ibmvscsi/ibmvfc.c
index 05eb275b637e,ea7c8930592d..000000000000
--- a/drivers/scsi/ibmvscsi/ibmvfc.c
+++ b/drivers/scsi/ibmvscsi/ibmvfc.c
@@@ -1897,6 -1866,7 +1897,10 @@@ static int ibmvfc_bsg_request(struct bs
  		port_id = (bsg_request->rqst_data.h_els.port_id[0] << 16) |
  			(bsg_request->rqst_data.h_els.port_id[1] << 8) |
  			bsg_request->rqst_data.h_els.port_id[2];
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FC_BSG_RPT_ELS:
  		fc_flags = IBMVFC_FC_ELS;
  		break;
@@@ -1905,6 -1875,7 +1909,10 @@@
  		port_id = (bsg_request->rqst_data.h_ct.port_id[0] << 16) |
  			(bsg_request->rqst_data.h_ct.port_id[1] << 8) |
  			bsg_request->rqst_data.h_ct.port_id[2];
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FC_BSG_RPT_CT:
  		fc_flags = IBMVFC_FC_CT_IU;
  		break;
@@@ -4319,6 -4122,7 +4327,10 @@@ static void ibmvfc_npiv_login_done(stru
  		return;
  	case IBMVFC_MAD_CRQ_ERROR:
  		ibmvfc_retry_host_init(vhost);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IBMVFC_MAD_DRIVER_FAILED:
  		ibmvfc_free_event(evt);
  		return;
diff --cc drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
index 2f970d0e921f,cc3908c2d2f9..000000000000
--- a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
+++ b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
@@@ -1590,6 -1581,7 +1590,10 @@@ static long ibmvscsis_adapter_info(stru
  	case H_PERMISSION:
  		if (connection_broken(vscsi))
  			flag_bits = (RESPONSE_Q_DOWN | CLIENT_FAILED);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		dev_err(&vscsi->dev, "adapter_info: h_copy_rdma to client failed, rc %ld\n",
  			rc);
@@@ -2502,8 -2489,10 +2506,15 @@@ static long ibmvscsis_ping_response(str
  		break;
  	case H_CLOSED:
  		vscsi->flags |= CLIENT_FAILED;
++<<<<<<< HEAD
 +	case H_DROPPED:
 +		vscsi->flags |= RESPONSE_Q_DOWN;
++=======
+ 		fallthrough;
+ 	case H_DROPPED:
+ 		vscsi->flags |= RESPONSE_Q_DOWN;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case H_REMOTE_PARM:
  		dev_err(&vscsi->dev, "ping_response: h_send_crq failed, rc %ld\n",
  			rc);
diff --cc drivers/scsi/imm.c
index 8c6627bc8a39,862d35a098cf..000000000000
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@@ -796,21 -797,21 +796,29 @@@ static int imm_engine(imm_struct *dev, 
  			return 0;
  		}
  		return 1;	/* wait until imm_wakeup claims parport */
 -
 -	case 1:		/* Phase 1 - Connected */
 +		/* Phase 1 - Connected */
 +	case 1:
  		imm_connect(dev, CONNECT_EPP_MAYBE);
  		cmd->SCp.phase++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	case 2:		/* Phase 2 - We are now talking to the scsi bus */
 +		/* Phase 2 - We are now talking to the scsi bus */
 +	case 2:
  		if (!imm_select(dev, scmd_id(cmd))) {
  			imm_fail(dev, DID_NO_CONNECT);
  			return 0;
  		}
  		cmd->SCp.phase++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	case 3:		/* Phase 3 - Ready to accept a command */
 +		/* Phase 3 - Ready to accept a command */
 +	case 3:
  		w_ctr(ppb, 0x0c);
  		if (!(r_str(ppb) & 0x80))
  			return 1;
@@@ -818,9 -819,9 +826,13 @@@
  		if (!imm_send_command(cmd))
  			return 0;
  		cmd->SCp.phase++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	case 4:		/* Phase 4 - Setup scatter/gather buffers */
 +		/* Phase 4 - Setup scatter/gather buffers */
 +	case 4:
  		if (scsi_bufflen(cmd)) {
  			cmd->SCp.buffer = scsi_sglist(cmd);
  			cmd->SCp.this_residual = cmd->SCp.buffer->length;
@@@ -834,8 -835,9 +846,14 @@@
  		cmd->SCp.phase++;
  		if (cmd->SCp.this_residual & 0x01)
  			cmd->SCp.this_residual++;
++<<<<<<< HEAD
 +		/* Phase 5 - Pre-Data transfer stage */
 +	case 5:
++=======
+ 		fallthrough;
+ 
+ 	case 5:		/* Phase 5 - Pre-Data transfer stage */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		/* Spin lock for BUSY */
  		w_ctr(ppb, 0x0c);
  		if (!(r_str(ppb) & 0x80))
@@@ -850,9 -852,9 +868,13 @@@
  			if (imm_negotiate(dev))
  				return 0;
  		cmd->SCp.phase++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	case 6:		/* Phase 6 - Data transfer stage */
 +		/* Phase 6 - Data transfer stage */
 +	case 6:
  		/* Spin lock for BUSY */
  		w_ctr(ppb, 0x0c);
  		if (!(r_str(ppb) & 0x80))
@@@ -866,9 -868,9 +888,13 @@@
  				return 1;
  		}
  		cmd->SCp.phase++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	case 7:		/* Phase 7 - Post data transfer stage */
 +		/* Phase 7 - Post data transfer stage */
 +	case 7:
  		if ((dev->dp) && (dev->rd)) {
  			if ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {
  				w_ctr(ppb, 0x4);
@@@ -878,9 -880,9 +904,13 @@@
  			}
  		}
  		cmd->SCp.phase++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	case 8:		/* Phase 8 - Read status/message */
 +		/* Phase 8 - Read status/message */
 +	case 8:
  		/* Check for data overrun */
  		if (imm_wait(dev) != (unsigned char) 0xb8) {
  			imm_fail(dev, DID_ERROR);
diff --cc drivers/scsi/isci/phy.c
index 894d387a9aa3,4cacb800b530..000000000000
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@@ -777,6 -778,7 +777,10 @@@ enum sci_status sci_phy_event_handler(s
  			break;
  		case SCU_EVENT_LINK_FAILURE:
  			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case SCU_EVENT_HARD_RESET_RECEIVED:
  			/* Start the oob/sn state machine over again */
  			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
diff --cc drivers/scsi/isci/remote_device.c
index cc51f38b116d,c3f540b55689..000000000000
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@@ -310,7 -310,7 +310,11 @@@ static void isci_remote_device_not_read
  		/* Kill all outstanding requests for the device. */
  		sci_remote_device_terminate_requests(idev);
  
++<<<<<<< HEAD
 +		/* Fall through into the default case... */
++=======
+ 		fallthrough;	/* into the default case */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		clear_bit(IDEV_IO_READY, &idev->flags);
  		break;
@@@ -593,7 -593,7 +597,11 @@@ enum sci_status sci_remote_device_event
  
  			break;
  		}
++<<<<<<< HEAD
 +	/* Else, fall through and treat as unhandled... */
++=======
+ 		fallthrough;	/* and treat as unhandled */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		dev_dbg(scirdev_to_dev(idev),
  			"%s: device: %p event code: %x: %s\n",
diff --cc drivers/scsi/isci/remote_node_context.c
index e3f2a5359d71,68333f523b35..000000000000
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@@ -601,9 -601,9 +601,15 @@@ enum sci_status sci_remote_node_context
  				 __func__, sci_rnc);
  			return SCI_FAILURE_INVALID_STATE;
  		}
++<<<<<<< HEAD
 +		/* Fall through and handle like SCI_RNC_POSTING */
 +	case SCI_RNC_RESUMING:
 +		/* Fall through and handle like SCI_RNC_POSTING */
++=======
+ 		fallthrough;	/* and handle like SCI_RNC_POSTING */
+ 	case SCI_RNC_RESUMING:
+ 		fallthrough;	/* and handle like SCI_RNC_POSTING */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SCI_RNC_POSTING:
  		/* Set the destination state to AWAIT - this signals the
  		 * entry into the SCI_RNC_READY state that a suspension
diff --cc drivers/scsi/isci/request.c
index ed197bc8e801,6e0817941fa7..000000000000
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@@ -894,7 -894,7 +894,11 @@@ sci_io_request_terminate(struct isci_re
  		 * and don't wait for the task response.
  		 */
  		sci_change_state(&ireq->sm, SCI_REQ_ABORTING);
++<<<<<<< HEAD
 +		/* Fall through and handle like ABORTING... */
++=======
+ 		fallthrough;	/* and handle like ABORTING */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SCI_REQ_ABORTING:
  		if (!isci_remote_device_is_safe_to_abort(ireq->target_device))
  			set_bit(IREQ_PENDING_ABORT, &ireq->flags);
diff --cc drivers/scsi/lpfc/lpfc_sli.c
index 9f61a0deb5a9,e158cd77d387..000000000000
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@@ -9659,6 -9653,7 +9659,10 @@@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phb
  		cmnd = CMD_XMIT_SEQUENCE64_CR;
  		if (phba->link_flag & LS_LOOPBACK_MODE)
  			bf_set(wqe_xo, &wqe->xmit_sequence.wge_ctl, 1);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case CMD_XMIT_SEQUENCE64_CR:
  		/* word3 iocb=io_tag32 wqe=reserved */
  		wqe->xmit_sequence.rsvd3 = 0;
@@@ -13670,8 -13628,9 +13674,12 @@@ lpfc_sli4_sp_handle_rcqe(struct lpfc_hb
  	status = bf_get(lpfc_rcqe_status, rcqe);
  	switch (status) {
  	case FC_STATUS_RQ_BUF_LEN_EXCEEDED:
 -		lpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,
 +		lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
  				"2537 Receive Frame Truncated!!\n");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FC_STATUS_RQ_SUCCESS:
  		spin_lock_irqsave(&phba->hbalock, iflags);
  		lpfc_sli4_rq_release(hrq, drq);
@@@ -14201,9 -14160,9 +14209,13 @@@ lpfc_sli4_nvmet_handle_rcqe(struct lpfc
  	status = bf_get(lpfc_rcqe_status, rcqe);
  	switch (status) {
  	case FC_STATUS_RQ_BUF_LEN_EXCEEDED:
 -		lpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,
 +		lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
  				"6126 Receive Frame Truncated!!\n");
++<<<<<<< HEAD
 +		/* Drop thru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FC_STATUS_RQ_SUCCESS:
  		spin_lock_irqsave(&phba->hbalock, iflags);
  		lpfc_sli4_rq_release(hrq, drq);
@@@ -15279,9 -15238,9 +15291,13 @@@ lpfc_cq_create(struct lpfc_hba *phba, s
  			       LPFC_CQ_CNT_WORD7);
  			break;
  		}
++<<<<<<< HEAD
 +		/* Fall Thru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
 -		lpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,
 +		lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
  				"0361 Unsupported CQ count: "
  				"entry cnt %d sz %d pg cnt %d\n",
  				cq->entry_count, cq->entry_size,
@@@ -15290,7 -15249,7 +15306,11 @@@
  			status = -EINVAL;
  			goto out;
  		}
++<<<<<<< HEAD
 +		/* otherwise default to smallest count (drop through) */
++=======
+ 		fallthrough;	/* otherwise default to smallest count */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 256:
  		bf_set(lpfc_cq_context_count, &cq_create->u.request.context,
  		       LPFC_CQ_CNT_256);
@@@ -15458,16 -15417,16 +15478,24 @@@ lpfc_cq_create_set(struct lpfc_hba *phb
  					       LPFC_CQ_CNT_WORD7);
  					break;
  				}
++<<<<<<< HEAD
 +				/* Fall Thru */
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			default:
 -				lpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,
 +				lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
  						"3118 Bad CQ count. (%d)\n",
  						cq->entry_count);
  				if (cq->entry_count < 256) {
  					status = -EINVAL;
  					goto out;
  				}
++<<<<<<< HEAD
 +				/* otherwise default to smallest (drop thru) */
++=======
+ 				fallthrough;	/* otherwise default to smallest */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case 256:
  				bf_set(lpfc_mbx_cq_create_set_cqe_cnt,
  				       &cq_set->u.request, LPFC_CQ_CNT_256);
@@@ -15743,7 -15702,7 +15771,11 @@@ lpfc_mq_create(struct lpfc_hba *phba, s
  			status = -EINVAL;
  			goto out;
  		}
++<<<<<<< HEAD
 +		/* otherwise default to smallest count (drop through) */
++=======
+ 		fallthrough;	/* otherwise default to smallest count */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 16:
  		bf_set(lpfc_mq_context_ring_size,
  		       &mq_create_ext->u.request.context,
@@@ -16158,7 -16123,7 +16190,11 @@@ lpfc_rq_create(struct lpfc_hba *phba, s
  				status = -EINVAL;
  				goto out;
  			}
++<<<<<<< HEAD
 +			/* otherwise default to smallest count (drop through) */
++=======
+ 			fallthrough;	/* otherwise default to smallest count */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 512:
  			bf_set(lpfc_rq_context_rqe_count,
  			       &rq_create->u.request.context,
@@@ -16295,7 -16260,7 +16331,11 @@@
  				status = -EINVAL;
  				goto out;
  			}
++<<<<<<< HEAD
 +			/* otherwise default to smallest count (drop through) */
++=======
+ 			fallthrough;	/* otherwise default to smallest count */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 512:
  			bf_set(lpfc_rq_context_rqe_count,
  			       &rq_create->u.request.context,
diff --cc drivers/scsi/ncr53c8xx.c
index dc4e801b2cef,03d70138ad58..000000000000
--- a/drivers/scsi/ncr53c8xx.c
+++ b/drivers/scsi/ncr53c8xx.c
@@@ -3922,11 -3910,14 +3922,22 @@@ static void __init ncr_prepare_setting(
  					np->scsi_mode = SMODE_HVD;
  				break;
  			}
++<<<<<<< HEAD
 +		case 3:	/* SYMBIOS controllers report HVD through GPIO3 */
 +			if (INB(nc_gpreg) & 0x08)
 +				break;
 +		case 2:	/* Set HVD unconditionally */
 +			np->scsi_mode = SMODE_HVD;
++=======
+ 			fallthrough;
+ 		case 3:	/* SYMBIOS controllers report HVD through GPIO3 */
+ 			if (INB(nc_gpreg) & 0x08)
+ 				break;
+ 			fallthrough;
+ 		case 2:	/* Set HVD unconditionally */
+ 			np->scsi_mode = SMODE_HVD;
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 1:	/* Trust previous settings for HVD */
  			if (np->sv_stest2 & 0x20)
  				np->scsi_mode = SMODE_HVD;
@@@ -6726,6 -6717,7 +6737,10 @@@ void ncr_int_sir (struct ncb *np
  			OUTL_DSP (scr_to_cpu(tp->lp[0]->jump_ccb[0]));
  			return;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SIR_RESEL_BAD_TARGET:	/* Will send a TARGET RESET message */
  	case SIR_RESEL_BAD_LUN:		/* Will send a TARGET RESET message */
  	case SIR_RESEL_BAD_I_T_L_Q:	/* Will send an ABORT TAG message   */
diff --cc drivers/scsi/ppa.c
index ee86a0c62dbf,aa41f7ac91cb..000000000000
--- a/drivers/scsi/ppa.c
+++ b/drivers/scsi/ppa.c
@@@ -717,6 -717,7 +717,10 @@@ static int ppa_engine(ppa_struct *dev, 
  			}
  			cmd->SCp.phase++;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case 2:		/* Phase 2 - We are now talking to the scsi bus */
  		if (!ppa_select(dev, scmd_id(cmd))) {
diff --cc drivers/scsi/qla4xxx/ql4_os.c
index 9b645394bc90,676778cbc550..000000000000
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@@ -2876,7 -2907,7 +2876,11 @@@ static int qla4xxx_session_get_param(st
  						chap_tbl.secret_len);
  			}
  		}
++<<<<<<< HEAD
 +		/* allow fall-through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return iscsi_session_get_param(cls_sess, param, buf);
  	}
diff --cc drivers/scsi/qlogicpti.c
index 9d09228eee28,48ff7d88af86..000000000000
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@@ -199,10 -200,15 +199,22 @@@ static int qlogicpti_mbox_command(struc
  	/* Write mailbox command registers. */
  	switch (mbox_param[param[0]] >> 4) {
  	case 6: sbus_writew(param[5], qpti->qregs + MBOX5);
++<<<<<<< HEAD
 +	case 5: sbus_writew(param[4], qpti->qregs + MBOX4);
 +	case 4: sbus_writew(param[3], qpti->qregs + MBOX3);
 +	case 3: sbus_writew(param[2], qpti->qregs + MBOX2);
 +	case 2: sbus_writew(param[1], qpti->qregs + MBOX1);
++=======
+ 		fallthrough;
+ 	case 5: sbus_writew(param[4], qpti->qregs + MBOX4);
+ 		fallthrough;
+ 	case 4: sbus_writew(param[3], qpti->qregs + MBOX3);
+ 		fallthrough;
+ 	case 3: sbus_writew(param[2], qpti->qregs + MBOX2);
+ 		fallthrough;
+ 	case 2: sbus_writew(param[1], qpti->qregs + MBOX1);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1: sbus_writew(param[0], qpti->qregs + MBOX0);
  	}
  
@@@ -253,10 -259,15 +265,22 @@@
  	/* Read back output parameters. */
  	switch (mbox_param[param[0]] & 0xf) {
  	case 6: param[5] = sbus_readw(qpti->qregs + MBOX5);
++<<<<<<< HEAD
++	case 5: param[4] = sbus_readw(qpti->qregs + MBOX4);
++	case 4: param[3] = sbus_readw(qpti->qregs + MBOX3);
++	case 3: param[2] = sbus_readw(qpti->qregs + MBOX2);
++	case 2: param[1] = sbus_readw(qpti->qregs + MBOX1);
++=======
+ 		fallthrough;
  	case 5: param[4] = sbus_readw(qpti->qregs + MBOX4);
+ 		fallthrough;
  	case 4: param[3] = sbus_readw(qpti->qregs + MBOX3);
+ 		fallthrough;
  	case 3: param[2] = sbus_readw(qpti->qregs + MBOX2);
+ 		fallthrough;
  	case 2: param[1] = sbus_readw(qpti->qregs + MBOX1);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1: param[0] = sbus_readw(qpti->qregs + MBOX0);
  	}
  
diff --cc drivers/scsi/sun3_scsi.c
index 9492638296c8,2e3fbc2fae97..000000000000
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@@ -396,10 -397,12 +396,18 @@@ static int sun3scsi_dma_finish(int writ
  		case CSR_LEFT_3:
  			*vaddr = (dregs->bpack_lo & 0xff00) >> 8;
  			vaddr--;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case CSR_LEFT_2:
  			*vaddr = (dregs->bpack_hi & 0x00ff);
  			vaddr--;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case CSR_LEFT_1:
  			*vaddr = (dregs->bpack_hi & 0xff00) >> 8;
diff --cc drivers/scsi/sym53c8xx_2/sym_hipd.c
index 226e5c593526,cc11daa1222b..000000000000
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.c
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.c
@@@ -3072,6 -3059,7 +3072,10 @@@ static void sym_sir_bad_scsi_status(str
  			sym_print_addr(cp->cmd, "%s\n",
  			        s_status == S_BUSY ? "BUSY" : "QUEUE FULL\n");
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:	/* S_INT, S_INT_COND_MET, S_CONFLICT */
  		sym_complete_error (np, cp);
  		break;
@@@ -4625,6 -4620,7 +4629,10 @@@ static void sym_int_sir(struct sym_hcb 
  	 *  Negotiation failed.
  	 *  Target does not want answer message.
  	 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SIR_NEGO_PROTO:
  		sym_nego_default(np, tp, cp);
  		goto out;
diff --cc drivers/scsi/sym53c8xx_2/sym_nvram.c
index 5662fbb3ff60,e13d5351f155..000000000000
--- a/drivers/scsi/sym53c8xx_2/sym_nvram.c
+++ b/drivers/scsi/sym53c8xx_2/sym_nvram.c
@@@ -708,6 -695,7 +708,10 @@@ static int sym_read_Tekram_nvram (struc
  					  data, len);
  		if (!x)
  			break;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		x = sym_read_T93C46_nvram(np, nvram);
  		break;
diff --cc drivers/scsi/ufs/ufshcd.c
index 836a3a08daf4,1d157ff58d81..000000000000
--- a/drivers/scsi/ufs/ufshcd.c
+++ b/drivers/scsi/ufs/ufshcd.c
@@@ -1559,6 -1612,7 +1559,10 @@@ start
  		 * currently running. Hence, fall through to cancel gating
  		 * work and to enable clocks.
  		 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case CLKS_OFF:
  		ufshcd_scsi_block_requests(hba);
  		hba->clk_gating.state = REQ_CLKS_ON;
@@@ -1570,6 -1624,7 +1574,10 @@@
  		 * fall through to check if we should wait for this
  		 * work to be done or not.
  		 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case REQ_CLKS_ON:
  		if (async) {
  			rc = -EAGAIN;
@@@ -4641,6 -4737,7 +4649,10 @@@ ufshcd_scsi_cmd_status(struct ufshcd_lr
  	switch (scsi_status) {
  	case SAM_STAT_CHECK_CONDITION:
  		ufshcd_copy_sense_data(lrbp);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case SAM_STAT_GOOD:
  		result |= DID_OK << 16 |
  			  COMMAND_COMPLETE << 8 |
@@@ -5681,6 -6077,247 +5693,250 @@@ static int ufshcd_issue_tm_cmd(struct u
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * ufshcd_issue_tm_cmd - issues task management commands to controller
+  * @hba: per adapter instance
+  * @lun_id: LUN ID to which TM command is sent
+  * @task_id: task ID to which the TM command is applicable
+  * @tm_function: task management function opcode
+  * @tm_response: task management service response return value
+  *
+  * Returns non-zero value on error, zero on success.
+  */
+ static int ufshcd_issue_tm_cmd(struct ufs_hba *hba, int lun_id, int task_id,
+ 		u8 tm_function, u8 *tm_response)
+ {
+ 	struct utp_task_req_desc treq = { { 0 }, };
+ 	int ocs_value, err;
+ 
+ 	/* Configure task request descriptor */
+ 	treq.header.dword_0 = cpu_to_le32(UTP_REQ_DESC_INT_CMD);
+ 	treq.header.dword_2 = cpu_to_le32(OCS_INVALID_COMMAND_STATUS);
+ 
+ 	/* Configure task request UPIU */
+ 	treq.req_header.dword_0 = cpu_to_be32(lun_id << 8) |
+ 				  cpu_to_be32(UPIU_TRANSACTION_TASK_REQ << 24);
+ 	treq.req_header.dword_1 = cpu_to_be32(tm_function << 16);
+ 
+ 	/*
+ 	 * The host shall provide the same value for LUN field in the basic
+ 	 * header and for Input Parameter.
+ 	 */
+ 	treq.input_param1 = cpu_to_be32(lun_id);
+ 	treq.input_param2 = cpu_to_be32(task_id);
+ 
+ 	err = __ufshcd_issue_tm_cmd(hba, &treq, tm_function);
+ 	if (err == -ETIMEDOUT)
+ 		return err;
+ 
+ 	ocs_value = le32_to_cpu(treq.header.dword_2) & MASK_OCS;
+ 	if (ocs_value != OCS_SUCCESS)
+ 		dev_err(hba->dev, "%s: failed, ocs = 0x%x\n",
+ 				__func__, ocs_value);
+ 	else if (tm_response)
+ 		*tm_response = be32_to_cpu(treq.output_param1) &
+ 				MASK_TM_SERVICE_RESP;
+ 	return err;
+ }
+ 
+ /**
+  * ufshcd_issue_devman_upiu_cmd - API for sending "utrd" type requests
+  * @hba:	per-adapter instance
+  * @req_upiu:	upiu request
+  * @rsp_upiu:	upiu reply
+  * @desc_buff:	pointer to descriptor buffer, NULL if NA
+  * @buff_len:	descriptor size, 0 if NA
+  * @cmd_type:	specifies the type (NOP, Query...)
+  * @desc_op:	descriptor operation
+  *
+  * Those type of requests uses UTP Transfer Request Descriptor - utrd.
+  * Therefore, it "rides" the device management infrastructure: uses its tag and
+  * tasks work queues.
+  *
+  * Since there is only one available tag for device management commands,
+  * the caller is expected to hold the hba->dev_cmd.lock mutex.
+  */
+ static int ufshcd_issue_devman_upiu_cmd(struct ufs_hba *hba,
+ 					struct utp_upiu_req *req_upiu,
+ 					struct utp_upiu_req *rsp_upiu,
+ 					u8 *desc_buff, int *buff_len,
+ 					enum dev_cmd_type cmd_type,
+ 					enum query_opcode desc_op)
+ {
+ 	struct request_queue *q = hba->cmd_queue;
+ 	struct request *req;
+ 	struct ufshcd_lrb *lrbp;
+ 	int err = 0;
+ 	int tag;
+ 	struct completion wait;
+ 	unsigned long flags;
+ 	u8 upiu_flags;
+ 
+ 	down_read(&hba->clk_scaling_lock);
+ 
+ 	req = blk_get_request(q, REQ_OP_DRV_OUT, 0);
+ 	if (IS_ERR(req)) {
+ 		err = PTR_ERR(req);
+ 		goto out_unlock;
+ 	}
+ 	tag = req->tag;
+ 	WARN_ON_ONCE(!ufshcd_valid_tag(hba, tag));
+ 
+ 	init_completion(&wait);
+ 	lrbp = &hba->lrb[tag];
+ 	WARN_ON(lrbp->cmd);
+ 
+ 	lrbp->cmd = NULL;
+ 	lrbp->sense_bufflen = 0;
+ 	lrbp->sense_buffer = NULL;
+ 	lrbp->task_tag = tag;
+ 	lrbp->lun = 0;
+ 	lrbp->intr_cmd = true;
+ 	ufshcd_prepare_lrbp_crypto(NULL, lrbp);
+ 	hba->dev_cmd.type = cmd_type;
+ 
+ 	switch (hba->ufs_version) {
+ 	case UFSHCI_VERSION_10:
+ 	case UFSHCI_VERSION_11:
+ 		lrbp->command_type = UTP_CMD_TYPE_DEV_MANAGE;
+ 		break;
+ 	default:
+ 		lrbp->command_type = UTP_CMD_TYPE_UFS_STORAGE;
+ 		break;
+ 	}
+ 
+ 	/* update the task tag in the request upiu */
+ 	req_upiu->header.dword_0 |= cpu_to_be32(tag);
+ 
+ 	ufshcd_prepare_req_desc_hdr(lrbp, &upiu_flags, DMA_NONE);
+ 
+ 	/* just copy the upiu request as it is */
+ 	memcpy(lrbp->ucd_req_ptr, req_upiu, sizeof(*lrbp->ucd_req_ptr));
+ 	if (desc_buff && desc_op == UPIU_QUERY_OPCODE_WRITE_DESC) {
+ 		/* The Data Segment Area is optional depending upon the query
+ 		 * function value. for WRITE DESCRIPTOR, the data segment
+ 		 * follows right after the tsf.
+ 		 */
+ 		memcpy(lrbp->ucd_req_ptr + 1, desc_buff, *buff_len);
+ 		*buff_len = 0;
+ 	}
+ 
+ 	memset(lrbp->ucd_rsp_ptr, 0, sizeof(struct utp_upiu_rsp));
+ 
+ 	hba->dev_cmd.complete = &wait;
+ 
+ 	/* Make sure descriptors are ready before ringing the doorbell */
+ 	wmb();
+ 	spin_lock_irqsave(hba->host->host_lock, flags);
+ 	ufshcd_send_command(hba, tag);
+ 	spin_unlock_irqrestore(hba->host->host_lock, flags);
+ 
+ 	/*
+ 	 * ignore the returning value here - ufshcd_check_query_response is
+ 	 * bound to fail since dev_cmd.query and dev_cmd.type were left empty.
+ 	 * read the response directly ignoring all errors.
+ 	 */
+ 	ufshcd_wait_for_dev_cmd(hba, lrbp, QUERY_REQ_TIMEOUT);
+ 
+ 	/* just copy the upiu response as it is */
+ 	memcpy(rsp_upiu, lrbp->ucd_rsp_ptr, sizeof(*rsp_upiu));
+ 	if (desc_buff && desc_op == UPIU_QUERY_OPCODE_READ_DESC) {
+ 		u8 *descp = (u8 *)lrbp->ucd_rsp_ptr + sizeof(*rsp_upiu);
+ 		u16 resp_len = be32_to_cpu(lrbp->ucd_rsp_ptr->header.dword_2) &
+ 			       MASK_QUERY_DATA_SEG_LEN;
+ 
+ 		if (*buff_len >= resp_len) {
+ 			memcpy(desc_buff, descp, resp_len);
+ 			*buff_len = resp_len;
+ 		} else {
+ 			dev_warn(hba->dev,
+ 				 "%s: rsp size %d is bigger than buffer size %d",
+ 				 __func__, resp_len, *buff_len);
+ 			*buff_len = 0;
+ 			err = -EINVAL;
+ 		}
+ 	}
+ 
+ 	blk_put_request(req);
+ out_unlock:
+ 	up_read(&hba->clk_scaling_lock);
+ 	return err;
+ }
+ 
+ /**
+  * ufshcd_exec_raw_upiu_cmd - API function for sending raw upiu commands
+  * @hba:	per-adapter instance
+  * @req_upiu:	upiu request
+  * @rsp_upiu:	upiu reply - only 8 DW as we do not support scsi commands
+  * @msgcode:	message code, one of UPIU Transaction Codes Initiator to Target
+  * @desc_buff:	pointer to descriptor buffer, NULL if NA
+  * @buff_len:	descriptor size, 0 if NA
+  * @desc_op:	descriptor operation
+  *
+  * Supports UTP Transfer requests (nop and query), and UTP Task
+  * Management requests.
+  * It is up to the caller to fill the upiu conent properly, as it will
+  * be copied without any further input validations.
+  */
+ int ufshcd_exec_raw_upiu_cmd(struct ufs_hba *hba,
+ 			     struct utp_upiu_req *req_upiu,
+ 			     struct utp_upiu_req *rsp_upiu,
+ 			     int msgcode,
+ 			     u8 *desc_buff, int *buff_len,
+ 			     enum query_opcode desc_op)
+ {
+ 	int err;
+ 	enum dev_cmd_type cmd_type = DEV_CMD_TYPE_QUERY;
+ 	struct utp_task_req_desc treq = { { 0 }, };
+ 	int ocs_value;
+ 	u8 tm_f = be32_to_cpu(req_upiu->header.dword_1) >> 16 & MASK_TM_FUNC;
+ 
+ 	switch (msgcode) {
+ 	case UPIU_TRANSACTION_NOP_OUT:
+ 		cmd_type = DEV_CMD_TYPE_NOP;
+ 		fallthrough;
+ 	case UPIU_TRANSACTION_QUERY_REQ:
+ 		ufshcd_hold(hba, false);
+ 		mutex_lock(&hba->dev_cmd.lock);
+ 		err = ufshcd_issue_devman_upiu_cmd(hba, req_upiu, rsp_upiu,
+ 						   desc_buff, buff_len,
+ 						   cmd_type, desc_op);
+ 		mutex_unlock(&hba->dev_cmd.lock);
+ 		ufshcd_release(hba);
+ 
+ 		break;
+ 	case UPIU_TRANSACTION_TASK_REQ:
+ 		treq.header.dword_0 = cpu_to_le32(UTP_REQ_DESC_INT_CMD);
+ 		treq.header.dword_2 = cpu_to_le32(OCS_INVALID_COMMAND_STATUS);
+ 
+ 		memcpy(&treq.req_header, req_upiu, sizeof(*req_upiu));
+ 
+ 		err = __ufshcd_issue_tm_cmd(hba, &treq, tm_f);
+ 		if (err == -ETIMEDOUT)
+ 			break;
+ 
+ 		ocs_value = le32_to_cpu(treq.header.dword_2) & MASK_OCS;
+ 		if (ocs_value != OCS_SUCCESS) {
+ 			dev_err(hba->dev, "%s: failed, ocs = 0x%x\n", __func__,
+ 				ocs_value);
+ 			break;
+ 		}
+ 
+ 		memcpy(rsp_upiu, &treq.rsp_header, sizeof(*rsp_upiu));
+ 
+ 		break;
+ 	default:
+ 		err = -EINVAL;
+ 
+ 		break;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ /**
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
   * ufshcd_eh_device_reset_handler - device reset handler registered to
   *                                    scsi layer.
   * @cmd: SCSI command pointer
diff --cc drivers/scsi/wd33c93.c
index 74be04f2357c,87dafbc942d3..000000000000
--- a/drivers/scsi/wd33c93.c
+++ b/drivers/scsi/wd33c93.c
@@@ -1863,6 -1854,7 +1863,10 @@@ round_4(unsigned int x
  		case 1: --x;
  			break;
  		case 2: ++x;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 3: ++x;
  	}
  	return x;
diff --cc drivers/scsi/xen-scsifront.c
index 61389bdc7926,259fc248d06c..000000000000
--- a/drivers/scsi/xen-scsifront.c
+++ b/drivers/scsi/xen-scsifront.c
@@@ -1112,7 -1111,7 +1112,11 @@@ static void scsifront_backend_changed(s
  	case XenbusStateClosed:
  		if (dev->state == XenbusStateClosed)
  			break;
++<<<<<<< HEAD
 +		/* Missed the backend's Closing state -- fallthrough */
++=======
+ 		fallthrough;	/* Missed the backend's Closing state */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XenbusStateClosing:
  		scsifront_disconnect(info);
  		break;
diff --cc drivers/soc/tegra/pmc.c
index 2d6f3fcf3211,d332e5d9abac..000000000000
--- a/drivers/soc/tegra/pmc.c
+++ b/drivers/soc/tegra/pmc.c
@@@ -1353,6 -1719,782 +1353,785 @@@ out
  	of_node_put(np);
  }
  
++<<<<<<< HEAD
++=======
+ static int tegra_io_pad_pinctrl_get_groups_count(struct pinctrl_dev *pctl_dev)
+ {
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);
+ 
+ 	return pmc->soc->num_io_pads;
+ }
+ 
+ static const char *tegra_io_pad_pinctrl_get_group_name(struct pinctrl_dev *pctl,
+ 						       unsigned int group)
+ {
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl);
+ 
+ 	return pmc->soc->io_pads[group].name;
+ }
+ 
+ static int tegra_io_pad_pinctrl_get_group_pins(struct pinctrl_dev *pctl_dev,
+ 					       unsigned int group,
+ 					       const unsigned int **pins,
+ 					       unsigned int *num_pins)
+ {
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);
+ 
+ 	*pins = &pmc->soc->io_pads[group].id;
+ 	*num_pins = 1;
+ 
+ 	return 0;
+ }
+ 
+ static const struct pinctrl_ops tegra_io_pad_pinctrl_ops = {
+ 	.get_groups_count = tegra_io_pad_pinctrl_get_groups_count,
+ 	.get_group_name = tegra_io_pad_pinctrl_get_group_name,
+ 	.get_group_pins = tegra_io_pad_pinctrl_get_group_pins,
+ 	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+ 	.dt_free_map = pinconf_generic_dt_free_map,
+ };
+ 
+ static int tegra_io_pad_pinconf_get(struct pinctrl_dev *pctl_dev,
+ 				    unsigned int pin, unsigned long *config)
+ {
+ 	enum pin_config_param param = pinconf_to_config_param(*config);
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);
+ 	const struct tegra_io_pad_soc *pad;
+ 	int ret;
+ 	u32 arg;
+ 
+ 	pad = tegra_io_pad_find(pmc, pin);
+ 	if (!pad)
+ 		return -EINVAL;
+ 
+ 	switch (param) {
+ 	case PIN_CONFIG_POWER_SOURCE:
+ 		ret = tegra_io_pad_get_voltage(pmc, pad->id);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		arg = ret;
+ 		break;
+ 
+ 	case PIN_CONFIG_LOW_POWER_MODE:
+ 		ret = tegra_io_pad_is_powered(pmc, pad->id);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		arg = !ret;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	*config = pinconf_to_config_packed(param, arg);
+ 
+ 	return 0;
+ }
+ 
+ static int tegra_io_pad_pinconf_set(struct pinctrl_dev *pctl_dev,
+ 				    unsigned int pin, unsigned long *configs,
+ 				    unsigned int num_configs)
+ {
+ 	struct tegra_pmc *pmc = pinctrl_dev_get_drvdata(pctl_dev);
+ 	const struct tegra_io_pad_soc *pad;
+ 	enum pin_config_param param;
+ 	unsigned int i;
+ 	int err;
+ 	u32 arg;
+ 
+ 	pad = tegra_io_pad_find(pmc, pin);
+ 	if (!pad)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < num_configs; ++i) {
+ 		param = pinconf_to_config_param(configs[i]);
+ 		arg = pinconf_to_config_argument(configs[i]);
+ 
+ 		switch (param) {
+ 		case PIN_CONFIG_LOW_POWER_MODE:
+ 			if (arg)
+ 				err = tegra_io_pad_power_disable(pad->id);
+ 			else
+ 				err = tegra_io_pad_power_enable(pad->id);
+ 			if (err)
+ 				return err;
+ 			break;
+ 		case PIN_CONFIG_POWER_SOURCE:
+ 			if (arg != TEGRA_IO_PAD_VOLTAGE_1V8 &&
+ 			    arg != TEGRA_IO_PAD_VOLTAGE_3V3)
+ 				return -EINVAL;
+ 			err = tegra_io_pad_set_voltage(pmc, pad->id, arg);
+ 			if (err)
+ 				return err;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct pinconf_ops tegra_io_pad_pinconf_ops = {
+ 	.pin_config_get = tegra_io_pad_pinconf_get,
+ 	.pin_config_set = tegra_io_pad_pinconf_set,
+ 	.is_generic = true,
+ };
+ 
+ static struct pinctrl_desc tegra_pmc_pctl_desc = {
+ 	.pctlops = &tegra_io_pad_pinctrl_ops,
+ 	.confops = &tegra_io_pad_pinconf_ops,
+ };
+ 
+ static int tegra_pmc_pinctrl_init(struct tegra_pmc *pmc)
+ {
+ 	int err;
+ 
+ 	if (!pmc->soc->num_pin_descs)
+ 		return 0;
+ 
+ 	tegra_pmc_pctl_desc.name = dev_name(pmc->dev);
+ 	tegra_pmc_pctl_desc.pins = pmc->soc->pin_descs;
+ 	tegra_pmc_pctl_desc.npins = pmc->soc->num_pin_descs;
+ 
+ 	pmc->pctl_dev = devm_pinctrl_register(pmc->dev, &tegra_pmc_pctl_desc,
+ 					      pmc);
+ 	if (IS_ERR(pmc->pctl_dev)) {
+ 		err = PTR_ERR(pmc->pctl_dev);
+ 		dev_err(pmc->dev, "failed to register pin controller: %d\n",
+ 			err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t reset_reason_show(struct device *dev,
+ 				 struct device_attribute *attr, char *buf)
+ {
+ 	u32 value;
+ 
+ 	value = tegra_pmc_readl(pmc, pmc->soc->regs->rst_status);
+ 	value &= pmc->soc->regs->rst_source_mask;
+ 	value >>= pmc->soc->regs->rst_source_shift;
+ 
+ 	if (WARN_ON(value >= pmc->soc->num_reset_sources))
+ 		return sprintf(buf, "%s\n", "UNKNOWN");
+ 
+ 	return sprintf(buf, "%s\n", pmc->soc->reset_sources[value]);
+ }
+ 
+ static DEVICE_ATTR_RO(reset_reason);
+ 
+ static ssize_t reset_level_show(struct device *dev,
+ 				struct device_attribute *attr, char *buf)
+ {
+ 	u32 value;
+ 
+ 	value = tegra_pmc_readl(pmc, pmc->soc->regs->rst_status);
+ 	value &= pmc->soc->regs->rst_level_mask;
+ 	value >>= pmc->soc->regs->rst_level_shift;
+ 
+ 	if (WARN_ON(value >= pmc->soc->num_reset_levels))
+ 		return sprintf(buf, "%s\n", "UNKNOWN");
+ 
+ 	return sprintf(buf, "%s\n", pmc->soc->reset_levels[value]);
+ }
+ 
+ static DEVICE_ATTR_RO(reset_level);
+ 
+ static void tegra_pmc_reset_sysfs_init(struct tegra_pmc *pmc)
+ {
+ 	struct device *dev = pmc->dev;
+ 	int err = 0;
+ 
+ 	if (pmc->soc->reset_sources) {
+ 		err = device_create_file(dev, &dev_attr_reset_reason);
+ 		if (err < 0)
+ 			dev_warn(dev,
+ 				 "failed to create attr \"reset_reason\": %d\n",
+ 				 err);
+ 	}
+ 
+ 	if (pmc->soc->reset_levels) {
+ 		err = device_create_file(dev, &dev_attr_reset_level);
+ 		if (err < 0)
+ 			dev_warn(dev,
+ 				 "failed to create attr \"reset_level\": %d\n",
+ 				 err);
+ 	}
+ }
+ 
+ static int tegra_pmc_irq_translate(struct irq_domain *domain,
+ 				   struct irq_fwspec *fwspec,
+ 				   unsigned long *hwirq,
+ 				   unsigned int *type)
+ {
+ 	if (WARN_ON(fwspec->param_count < 2))
+ 		return -EINVAL;
+ 
+ 	*hwirq = fwspec->param[0];
+ 	*type = fwspec->param[1];
+ 
+ 	return 0;
+ }
+ 
+ static int tegra_pmc_irq_alloc(struct irq_domain *domain, unsigned int virq,
+ 			       unsigned int num_irqs, void *data)
+ {
+ 	struct tegra_pmc *pmc = domain->host_data;
+ 	const struct tegra_pmc_soc *soc = pmc->soc;
+ 	struct irq_fwspec *fwspec = data;
+ 	unsigned int i;
+ 	int err = 0;
+ 
+ 	if (WARN_ON(num_irqs > 1))
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < soc->num_wake_events; i++) {
+ 		const struct tegra_wake_event *event = &soc->wake_events[i];
+ 
+ 		if (fwspec->param_count == 2) {
+ 			struct irq_fwspec spec;
+ 
+ 			if (event->id != fwspec->param[0])
+ 				continue;
+ 
+ 			err = irq_domain_set_hwirq_and_chip(domain, virq,
+ 							    event->id,
+ 							    &pmc->irq, pmc);
+ 			if (err < 0)
+ 				break;
+ 
+ 			spec.fwnode = &pmc->dev->of_node->fwnode;
+ 			spec.param_count = 3;
+ 			spec.param[0] = GIC_SPI;
+ 			spec.param[1] = event->irq;
+ 			spec.param[2] = fwspec->param[1];
+ 
+ 			err = irq_domain_alloc_irqs_parent(domain, virq,
+ 							   num_irqs, &spec);
+ 
+ 			break;
+ 		}
+ 
+ 		if (fwspec->param_count == 3) {
+ 			if (event->gpio.instance != fwspec->param[0] ||
+ 			    event->gpio.pin != fwspec->param[1])
+ 				continue;
+ 
+ 			err = irq_domain_set_hwirq_and_chip(domain, virq,
+ 							    event->id,
+ 							    &pmc->irq, pmc);
+ 
+ 			/*
+ 			 * GPIOs don't have an equivalent interrupt in the
+ 			 * parent controller (GIC). However some code, such
+ 			 * as the one in irq_get_irqchip_state(), require a
+ 			 * valid IRQ chip to be set. Make sure that's the
+ 			 * case by passing NULL here, which will install a
+ 			 * dummy IRQ chip for the interrupt in the parent
+ 			 * domain.
+ 			 */
+ 			if (domain->parent)
+ 				irq_domain_set_hwirq_and_chip(domain->parent,
+ 							      virq, 0, NULL,
+ 							      NULL);
+ 
+ 			break;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * For interrupts that don't have associated wake events, assign a
+ 	 * dummy hardware IRQ number. This is used in the ->irq_set_type()
+ 	 * and ->irq_set_wake() callbacks to return early for these IRQs.
+ 	 */
+ 	if (i == soc->num_wake_events) {
+ 		err = irq_domain_set_hwirq_and_chip(domain, virq, ULONG_MAX,
+ 						    &pmc->irq, pmc);
+ 
+ 		/*
+ 		 * Interrupts without a wake event don't have a corresponding
+ 		 * interrupt in the parent controller (GIC). Pass NULL for the
+ 		 * chip here, which causes a dummy IRQ chip to be installed
+ 		 * for the interrupt in the parent domain, to make this
+ 		 * explicit.
+ 		 */
+ 		if (domain->parent)
+ 			irq_domain_set_hwirq_and_chip(domain->parent, virq, 0,
+ 						      NULL, NULL);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static const struct irq_domain_ops tegra_pmc_irq_domain_ops = {
+ 	.translate = tegra_pmc_irq_translate,
+ 	.alloc = tegra_pmc_irq_alloc,
+ };
+ 
+ static int tegra210_pmc_irq_set_wake(struct irq_data *data, unsigned int on)
+ {
+ 	struct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);
+ 	unsigned int offset, bit;
+ 	u32 value;
+ 
+ 	if (data->hwirq == ULONG_MAX)
+ 		return 0;
+ 
+ 	offset = data->hwirq / 32;
+ 	bit = data->hwirq % 32;
+ 
+ 	/* clear wake status */
+ 	tegra_pmc_writel(pmc, 0, PMC_SW_WAKE_STATUS);
+ 	tegra_pmc_writel(pmc, 0, PMC_SW_WAKE2_STATUS);
+ 
+ 	tegra_pmc_writel(pmc, 0, PMC_WAKE_STATUS);
+ 	tegra_pmc_writel(pmc, 0, PMC_WAKE2_STATUS);
+ 
+ 	/* enable PMC wake */
+ 	if (data->hwirq >= 32)
+ 		offset = PMC_WAKE2_MASK;
+ 	else
+ 		offset = PMC_WAKE_MASK;
+ 
+ 	value = tegra_pmc_readl(pmc, offset);
+ 
+ 	if (on)
+ 		value |= BIT(bit);
+ 	else
+ 		value &= ~BIT(bit);
+ 
+ 	tegra_pmc_writel(pmc, value, offset);
+ 
+ 	return 0;
+ }
+ 
+ static int tegra210_pmc_irq_set_type(struct irq_data *data, unsigned int type)
+ {
+ 	struct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);
+ 	unsigned int offset, bit;
+ 	u32 value;
+ 
+ 	if (data->hwirq == ULONG_MAX)
+ 		return 0;
+ 
+ 	offset = data->hwirq / 32;
+ 	bit = data->hwirq % 32;
+ 
+ 	if (data->hwirq >= 32)
+ 		offset = PMC_WAKE2_LEVEL;
+ 	else
+ 		offset = PMC_WAKE_LEVEL;
+ 
+ 	value = tegra_pmc_readl(pmc, offset);
+ 
+ 	switch (type) {
+ 	case IRQ_TYPE_EDGE_RISING:
+ 	case IRQ_TYPE_LEVEL_HIGH:
+ 		value |= BIT(bit);
+ 		break;
+ 
+ 	case IRQ_TYPE_EDGE_FALLING:
+ 	case IRQ_TYPE_LEVEL_LOW:
+ 		value &= ~BIT(bit);
+ 		break;
+ 
+ 	case IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING:
+ 		value ^= BIT(bit);
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	tegra_pmc_writel(pmc, value, offset);
+ 
+ 	return 0;
+ }
+ 
+ static int tegra186_pmc_irq_set_wake(struct irq_data *data, unsigned int on)
+ {
+ 	struct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);
+ 	unsigned int offset, bit;
+ 	u32 value;
+ 
+ 	/* nothing to do if there's no associated wake event */
+ 	if (WARN_ON(data->hwirq == ULONG_MAX))
+ 		return 0;
+ 
+ 	offset = data->hwirq / 32;
+ 	bit = data->hwirq % 32;
+ 
+ 	/* clear wake status */
+ 	writel(0x1, pmc->wake + WAKE_AOWAKE_STATUS_W(data->hwirq));
+ 
+ 	/* route wake to tier 2 */
+ 	value = readl(pmc->wake + WAKE_AOWAKE_TIER2_ROUTING(offset));
+ 
+ 	if (!on)
+ 		value &= ~(1 << bit);
+ 	else
+ 		value |= 1 << bit;
+ 
+ 	writel(value, pmc->wake + WAKE_AOWAKE_TIER2_ROUTING(offset));
+ 
+ 	/* enable wakeup event */
+ 	writel(!!on, pmc->wake + WAKE_AOWAKE_MASK_W(data->hwirq));
+ 
+ 	return 0;
+ }
+ 
+ static int tegra186_pmc_irq_set_type(struct irq_data *data, unsigned int type)
+ {
+ 	struct tegra_pmc *pmc = irq_data_get_irq_chip_data(data);
+ 	u32 value;
+ 
+ 	/* nothing to do if there's no associated wake event */
+ 	if (data->hwirq == ULONG_MAX)
+ 		return 0;
+ 
+ 	value = readl(pmc->wake + WAKE_AOWAKE_CNTRL(data->hwirq));
+ 
+ 	switch (type) {
+ 	case IRQ_TYPE_EDGE_RISING:
+ 	case IRQ_TYPE_LEVEL_HIGH:
+ 		value |= WAKE_AOWAKE_CNTRL_LEVEL;
+ 		break;
+ 
+ 	case IRQ_TYPE_EDGE_FALLING:
+ 	case IRQ_TYPE_LEVEL_LOW:
+ 		value &= ~WAKE_AOWAKE_CNTRL_LEVEL;
+ 		break;
+ 
+ 	case IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING:
+ 		value ^= WAKE_AOWAKE_CNTRL_LEVEL;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	writel(value, pmc->wake + WAKE_AOWAKE_CNTRL(data->hwirq));
+ 
+ 	return 0;
+ }
+ 
+ static int tegra_pmc_irq_init(struct tegra_pmc *pmc)
+ {
+ 	struct irq_domain *parent = NULL;
+ 	struct device_node *np;
+ 
+ 	np = of_irq_find_parent(pmc->dev->of_node);
+ 	if (np) {
+ 		parent = irq_find_host(np);
+ 		of_node_put(np);
+ 	}
+ 
+ 	if (!parent)
+ 		return 0;
+ 
+ 	pmc->irq.name = dev_name(pmc->dev);
+ 	pmc->irq.irq_mask = irq_chip_mask_parent;
+ 	pmc->irq.irq_unmask = irq_chip_unmask_parent;
+ 	pmc->irq.irq_eoi = irq_chip_eoi_parent;
+ 	pmc->irq.irq_set_affinity = irq_chip_set_affinity_parent;
+ 	pmc->irq.irq_set_type = pmc->soc->irq_set_type;
+ 	pmc->irq.irq_set_wake = pmc->soc->irq_set_wake;
+ 
+ 	pmc->domain = irq_domain_add_hierarchy(parent, 0, 96, pmc->dev->of_node,
+ 					       &tegra_pmc_irq_domain_ops, pmc);
+ 	if (!pmc->domain) {
+ 		dev_err(pmc->dev, "failed to allocate domain\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int tegra_pmc_clk_notify_cb(struct notifier_block *nb,
+ 				   unsigned long action, void *ptr)
+ {
+ 	struct tegra_pmc *pmc = container_of(nb, struct tegra_pmc, clk_nb);
+ 	struct clk_notifier_data *data = ptr;
+ 
+ 	switch (action) {
+ 	case PRE_RATE_CHANGE:
+ 		mutex_lock(&pmc->powergates_lock);
+ 		break;
+ 
+ 	case POST_RATE_CHANGE:
+ 		pmc->rate = data->new_rate;
+ 		fallthrough;
+ 
+ 	case ABORT_RATE_CHANGE:
+ 		mutex_unlock(&pmc->powergates_lock);
+ 		break;
+ 
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return notifier_from_errno(-EINVAL);
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static void pmc_clk_fence_udelay(u32 offset)
+ {
+ 	tegra_pmc_readl(pmc, offset);
+ 	/* pmc clk propagation delay 2 us */
+ 	udelay(2);
+ }
+ 
+ static u8 pmc_clk_mux_get_parent(struct clk_hw *hw)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 	u32 val;
+ 
+ 	val = tegra_pmc_readl(pmc, clk->offs) >> clk->mux_shift;
+ 	val &= PMC_CLK_OUT_MUX_MASK;
+ 
+ 	return val;
+ }
+ 
+ static int pmc_clk_mux_set_parent(struct clk_hw *hw, u8 index)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 	u32 val;
+ 
+ 	val = tegra_pmc_readl(pmc, clk->offs);
+ 	val &= ~(PMC_CLK_OUT_MUX_MASK << clk->mux_shift);
+ 	val |= index << clk->mux_shift;
+ 	tegra_pmc_writel(pmc, val, clk->offs);
+ 	pmc_clk_fence_udelay(clk->offs);
+ 
+ 	return 0;
+ }
+ 
+ static int pmc_clk_is_enabled(struct clk_hw *hw)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 	u32 val;
+ 
+ 	val = tegra_pmc_readl(pmc, clk->offs) & BIT(clk->force_en_shift);
+ 
+ 	return val ? 1 : 0;
+ }
+ 
+ static void pmc_clk_set_state(unsigned long offs, u32 shift, int state)
+ {
+ 	u32 val;
+ 
+ 	val = tegra_pmc_readl(pmc, offs);
+ 	val = state ? (val | BIT(shift)) : (val & ~BIT(shift));
+ 	tegra_pmc_writel(pmc, val, offs);
+ 	pmc_clk_fence_udelay(offs);
+ }
+ 
+ static int pmc_clk_enable(struct clk_hw *hw)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 
+ 	pmc_clk_set_state(clk->offs, clk->force_en_shift, 1);
+ 
+ 	return 0;
+ }
+ 
+ static void pmc_clk_disable(struct clk_hw *hw)
+ {
+ 	struct pmc_clk *clk = to_pmc_clk(hw);
+ 
+ 	pmc_clk_set_state(clk->offs, clk->force_en_shift, 0);
+ }
+ 
+ static const struct clk_ops pmc_clk_ops = {
+ 	.get_parent = pmc_clk_mux_get_parent,
+ 	.set_parent = pmc_clk_mux_set_parent,
+ 	.determine_rate = __clk_mux_determine_rate,
+ 	.is_enabled = pmc_clk_is_enabled,
+ 	.enable = pmc_clk_enable,
+ 	.disable = pmc_clk_disable,
+ };
+ 
+ static struct clk *
+ tegra_pmc_clk_out_register(struct tegra_pmc *pmc,
+ 			   const struct pmc_clk_init_data *data,
+ 			   unsigned long offset)
+ {
+ 	struct clk_init_data init;
+ 	struct pmc_clk *pmc_clk;
+ 
+ 	pmc_clk = devm_kzalloc(pmc->dev, sizeof(*pmc_clk), GFP_KERNEL);
+ 	if (!pmc_clk)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	init.name = data->name;
+ 	init.ops = &pmc_clk_ops;
+ 	init.parent_names = data->parents;
+ 	init.num_parents = data->num_parents;
+ 	init.flags = CLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT |
+ 		     CLK_SET_PARENT_GATE;
+ 
+ 	pmc_clk->hw.init = &init;
+ 	pmc_clk->offs = offset;
+ 	pmc_clk->mux_shift = data->mux_shift;
+ 	pmc_clk->force_en_shift = data->force_en_shift;
+ 
+ 	return clk_register(NULL, &pmc_clk->hw);
+ }
+ 
+ static int pmc_clk_gate_is_enabled(struct clk_hw *hw)
+ {
+ 	struct pmc_clk_gate *gate = to_pmc_clk_gate(hw);
+ 
+ 	return tegra_pmc_readl(pmc, gate->offs) & BIT(gate->shift) ? 1 : 0;
+ }
+ 
+ static int pmc_clk_gate_enable(struct clk_hw *hw)
+ {
+ 	struct pmc_clk_gate *gate = to_pmc_clk_gate(hw);
+ 
+ 	pmc_clk_set_state(gate->offs, gate->shift, 1);
+ 
+ 	return 0;
+ }
+ 
+ static void pmc_clk_gate_disable(struct clk_hw *hw)
+ {
+ 	struct pmc_clk_gate *gate = to_pmc_clk_gate(hw);
+ 
+ 	pmc_clk_set_state(gate->offs, gate->shift, 0);
+ }
+ 
+ static const struct clk_ops pmc_clk_gate_ops = {
+ 	.is_enabled = pmc_clk_gate_is_enabled,
+ 	.enable = pmc_clk_gate_enable,
+ 	.disable = pmc_clk_gate_disable,
+ };
+ 
+ static struct clk *
+ tegra_pmc_clk_gate_register(struct tegra_pmc *pmc, const char *name,
+ 			    const char *parent_name, unsigned long offset,
+ 			    u32 shift)
+ {
+ 	struct clk_init_data init;
+ 	struct pmc_clk_gate *gate;
+ 
+ 	gate = devm_kzalloc(pmc->dev, sizeof(*gate), GFP_KERNEL);
+ 	if (!gate)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	init.name = name;
+ 	init.ops = &pmc_clk_gate_ops;
+ 	init.parent_names = &parent_name;
+ 	init.num_parents = 1;
+ 	init.flags = 0;
+ 
+ 	gate->hw.init = &init;
+ 	gate->offs = offset;
+ 	gate->shift = shift;
+ 
+ 	return clk_register(NULL, &gate->hw);
+ }
+ 
+ static void tegra_pmc_clock_register(struct tegra_pmc *pmc,
+ 				     struct device_node *np)
+ {
+ 	struct clk *clk;
+ 	struct clk_onecell_data *clk_data;
+ 	unsigned int num_clks;
+ 	int i, err;
+ 
+ 	num_clks = pmc->soc->num_pmc_clks;
+ 	if (pmc->soc->has_blink_output)
+ 		num_clks += 1;
+ 
+ 	if (!num_clks)
+ 		return;
+ 
+ 	clk_data = devm_kmalloc(pmc->dev, sizeof(*clk_data), GFP_KERNEL);
+ 	if (!clk_data)
+ 		return;
+ 
+ 	clk_data->clks = devm_kcalloc(pmc->dev, TEGRA_PMC_CLK_MAX,
+ 				      sizeof(*clk_data->clks), GFP_KERNEL);
+ 	if (!clk_data->clks)
+ 		return;
+ 
+ 	clk_data->clk_num = TEGRA_PMC_CLK_MAX;
+ 
+ 	for (i = 0; i < TEGRA_PMC_CLK_MAX; i++)
+ 		clk_data->clks[i] = ERR_PTR(-ENOENT);
+ 
+ 	for (i = 0; i < pmc->soc->num_pmc_clks; i++) {
+ 		const struct pmc_clk_init_data *data;
+ 
+ 		data = pmc->soc->pmc_clks_data + i;
+ 
+ 		clk = tegra_pmc_clk_out_register(pmc, data, PMC_CLK_OUT_CNTRL);
+ 		if (IS_ERR(clk)) {
+ 			dev_warn(pmc->dev, "unable to register clock %s: %d\n",
+ 				 data->name, PTR_ERR_OR_ZERO(clk));
+ 			return;
+ 		}
+ 
+ 		err = clk_register_clkdev(clk, data->name, NULL);
+ 		if (err) {
+ 			dev_warn(pmc->dev,
+ 				 "unable to register %s clock lookup: %d\n",
+ 				 data->name, err);
+ 			return;
+ 		}
+ 
+ 		clk_data->clks[data->clk_id] = clk;
+ 	}
+ 
+ 	if (pmc->soc->has_blink_output) {
+ 		tegra_pmc_writel(pmc, 0x0, PMC_BLINK_TIMER);
+ 		clk = tegra_pmc_clk_gate_register(pmc,
+ 						  "pmc_blink_override",
+ 						  "clk_32k",
+ 						  PMC_DPD_PADS_ORIDE,
+ 						  PMC_DPD_PADS_ORIDE_BLINK);
+ 		if (IS_ERR(clk)) {
+ 			dev_warn(pmc->dev,
+ 				 "unable to register pmc_blink_override: %d\n",
+ 				 PTR_ERR_OR_ZERO(clk));
+ 			return;
+ 		}
+ 
+ 		clk = tegra_pmc_clk_gate_register(pmc, "pmc_blink",
+ 						  "pmc_blink_override",
+ 						  PMC_CNTRL,
+ 						  PMC_CNTRL_BLINK_EN);
+ 		if (IS_ERR(clk)) {
+ 			dev_warn(pmc->dev,
+ 				 "unable to register pmc_blink: %d\n",
+ 				 PTR_ERR_OR_ZERO(clk));
+ 			return;
+ 		}
+ 
+ 		err = clk_register_clkdev(clk, "pmc_blink", NULL);
+ 		if (err) {
+ 			dev_warn(pmc->dev,
+ 				 "unable to register pmc_blink lookup: %d\n",
+ 				 err);
+ 			return;
+ 		}
+ 
+ 		clk_data->clks[TEGRA_PMC_CLK_BLINK] = clk;
+ 	}
+ 
+ 	err = of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+ 	if (err)
+ 		dev_warn(pmc->dev, "failed to add pmc clock provider: %d\n",
+ 			 err);
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  static int tegra_pmc_probe(struct platform_device *pdev)
  {
  	void __iomem *base;
diff --cc drivers/spi/spi-sprd-adi.c
index 197d4b0d81af,127b8bd25831..000000000000
--- a/drivers/spi/spi-sprd-adi.c
+++ b/drivers/spi/spi-sprd-adi.c
@@@ -460,15 -491,25 +460,37 @@@ static int sprd_adi_probe(struct platfo
  	sadi->ctlr = ctlr;
  	sadi->dev = &pdev->dev;
  	ret = of_hwspin_lock_get_id(np, 0);
++<<<<<<< HEAD
 +	if (ret < 0) {
 +		dev_err(&pdev->dev, "can not get the hardware spinlock\n");
 +		goto put_ctlr;
 +	}
 +
 +	sadi->hwlock = hwspin_lock_request_specific(ret);
 +	if (!sadi->hwlock) {
 +		ret = -ENXIO;
 +		goto put_ctlr;
++=======
+ 	if (ret > 0 || (IS_ENABLED(CONFIG_HWSPINLOCK) && ret == 0)) {
+ 		sadi->hwlock =
+ 			devm_hwspin_lock_request_specific(&pdev->dev, ret);
+ 		if (!sadi->hwlock) {
+ 			ret = -ENXIO;
+ 			goto put_ctlr;
+ 		}
+ 	} else {
+ 		switch (ret) {
+ 		case -ENOENT:
+ 			dev_info(&pdev->dev, "no hardware spinlock supplied\n");
+ 			break;
+ 		default:
+ 			dev_err(&pdev->dev,
+ 				"failed to find hwlock id, %d\n", ret);
+ 			fallthrough;
+ 		case -EPROBE_DEFER:
+ 			goto put_ctlr;
+ 		}
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	}
  
  	sprd_adi_hw_init(sadi);
diff --cc drivers/ssb/driver_chipcommon.c
index 7cb7d2c8fd86,a8d2525e7af9..000000000000
--- a/drivers/ssb/driver_chipcommon.c
+++ b/drivers/ssb/driver_chipcommon.c
@@@ -425,7 -425,7 +425,11 @@@ void ssb_chipco_get_clockcontrol(struc
  			*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_M2);
  			break;
  		}
++<<<<<<< HEAD
 +		/* Fallthough */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_SB);
  	}
diff --cc drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
index 396371728aa1,cf5383bb8331..000000000000
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
@@@ -229,6 -201,212 +229,215 @@@ static struct sk_buff *build_frag_skb(s
  	return skb;
  }
  
++<<<<<<< HEAD:drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
++=======
+ /* Free buffers acquired from the buffer pool or which were meant to
+  * be released in the pool
+  */
+ static void free_bufs(struct dpaa2_eth_priv *priv, u64 *buf_array, int count)
+ {
+ 	struct device *dev = priv->net_dev->dev.parent;
+ 	void *vaddr;
+ 	int i;
+ 
+ 	for (i = 0; i < count; i++) {
+ 		vaddr = dpaa2_iova_to_virt(priv->iommu_domain, buf_array[i]);
+ 		dma_unmap_page(dev, buf_array[i], priv->rx_buf_size,
+ 			       DMA_BIDIRECTIONAL);
+ 		free_pages((unsigned long)vaddr, 0);
+ 	}
+ }
+ 
+ static void xdp_release_buf(struct dpaa2_eth_priv *priv,
+ 			    struct dpaa2_eth_channel *ch,
+ 			    dma_addr_t addr)
+ {
+ 	int retries = 0;
+ 	int err;
+ 
+ 	ch->xdp.drop_bufs[ch->xdp.drop_cnt++] = addr;
+ 	if (ch->xdp.drop_cnt < DPAA2_ETH_BUFS_PER_CMD)
+ 		return;
+ 
+ 	while ((err = dpaa2_io_service_release(ch->dpio, priv->bpid,
+ 					       ch->xdp.drop_bufs,
+ 					       ch->xdp.drop_cnt)) == -EBUSY) {
+ 		if (retries++ >= DPAA2_ETH_SWP_BUSY_RETRIES)
+ 			break;
+ 		cpu_relax();
+ 	}
+ 
+ 	if (err) {
+ 		free_bufs(priv, ch->xdp.drop_bufs, ch->xdp.drop_cnt);
+ 		ch->buf_count -= ch->xdp.drop_cnt;
+ 	}
+ 
+ 	ch->xdp.drop_cnt = 0;
+ }
+ 
+ static int dpaa2_eth_xdp_flush(struct dpaa2_eth_priv *priv,
+ 			       struct dpaa2_eth_fq *fq,
+ 			       struct dpaa2_eth_xdp_fds *xdp_fds)
+ {
+ 	int total_enqueued = 0, retries = 0, enqueued;
+ 	struct dpaa2_eth_drv_stats *percpu_extras;
+ 	int num_fds, err, max_retries;
+ 	struct dpaa2_fd *fds;
+ 
+ 	percpu_extras = this_cpu_ptr(priv->percpu_extras);
+ 
+ 	/* try to enqueue all the FDs until the max number of retries is hit */
+ 	fds = xdp_fds->fds;
+ 	num_fds = xdp_fds->num;
+ 	max_retries = num_fds * DPAA2_ETH_ENQUEUE_RETRIES;
+ 	while (total_enqueued < num_fds && retries < max_retries) {
+ 		err = priv->enqueue(priv, fq, &fds[total_enqueued],
+ 				    0, num_fds - total_enqueued, &enqueued);
+ 		if (err == -EBUSY) {
+ 			percpu_extras->tx_portal_busy += ++retries;
+ 			continue;
+ 		}
+ 		total_enqueued += enqueued;
+ 	}
+ 	xdp_fds->num = 0;
+ 
+ 	return total_enqueued;
+ }
+ 
+ static void xdp_tx_flush(struct dpaa2_eth_priv *priv,
+ 			 struct dpaa2_eth_channel *ch,
+ 			 struct dpaa2_eth_fq *fq)
+ {
+ 	struct rtnl_link_stats64 *percpu_stats;
+ 	struct dpaa2_fd *fds;
+ 	int enqueued, i;
+ 
+ 	percpu_stats = this_cpu_ptr(priv->percpu_stats);
+ 
+ 	// enqueue the array of XDP_TX frames
+ 	enqueued = dpaa2_eth_xdp_flush(priv, fq, &fq->xdp_tx_fds);
+ 
+ 	/* update statistics */
+ 	percpu_stats->tx_packets += enqueued;
+ 	fds = fq->xdp_tx_fds.fds;
+ 	for (i = 0; i < enqueued; i++) {
+ 		percpu_stats->tx_bytes += dpaa2_fd_get_len(&fds[i]);
+ 		ch->stats.xdp_tx++;
+ 	}
+ 	for (i = enqueued; i < fq->xdp_tx_fds.num; i++) {
+ 		xdp_release_buf(priv, ch, dpaa2_fd_get_addr(&fds[i]));
+ 		percpu_stats->tx_errors++;
+ 		ch->stats.xdp_tx_err++;
+ 	}
+ 	fq->xdp_tx_fds.num = 0;
+ }
+ 
+ static void xdp_enqueue(struct dpaa2_eth_priv *priv,
+ 			struct dpaa2_eth_channel *ch,
+ 			struct dpaa2_fd *fd,
+ 			void *buf_start, u16 queue_id)
+ {
+ 	struct dpaa2_faead *faead;
+ 	struct dpaa2_fd *dest_fd;
+ 	struct dpaa2_eth_fq *fq;
+ 	u32 ctrl, frc;
+ 
+ 	/* Mark the egress frame hardware annotation area as valid */
+ 	frc = dpaa2_fd_get_frc(fd);
+ 	dpaa2_fd_set_frc(fd, frc | DPAA2_FD_FRC_FAEADV);
+ 	dpaa2_fd_set_ctrl(fd, DPAA2_FD_CTRL_ASAL);
+ 
+ 	/* Instruct hardware to release the FD buffer directly into
+ 	 * the buffer pool once transmission is completed, instead of
+ 	 * sending a Tx confirmation frame to us
+ 	 */
+ 	ctrl = DPAA2_FAEAD_A4V | DPAA2_FAEAD_A2V | DPAA2_FAEAD_EBDDV;
+ 	faead = dpaa2_get_faead(buf_start, false);
+ 	faead->ctrl = cpu_to_le32(ctrl);
+ 	faead->conf_fqid = 0;
+ 
+ 	fq = &priv->fq[queue_id];
+ 	dest_fd = &fq->xdp_tx_fds.fds[fq->xdp_tx_fds.num++];
+ 	memcpy(dest_fd, fd, sizeof(*dest_fd));
+ 
+ 	if (fq->xdp_tx_fds.num < DEV_MAP_BULK_SIZE)
+ 		return;
+ 
+ 	xdp_tx_flush(priv, ch, fq);
+ }
+ 
+ static u32 run_xdp(struct dpaa2_eth_priv *priv,
+ 		   struct dpaa2_eth_channel *ch,
+ 		   struct dpaa2_eth_fq *rx_fq,
+ 		   struct dpaa2_fd *fd, void *vaddr)
+ {
+ 	dma_addr_t addr = dpaa2_fd_get_addr(fd);
+ 	struct bpf_prog *xdp_prog;
+ 	struct xdp_buff xdp;
+ 	u32 xdp_act = XDP_PASS;
+ 	int err;
+ 
+ 	rcu_read_lock();
+ 
+ 	xdp_prog = READ_ONCE(ch->xdp.prog);
+ 	if (!xdp_prog)
+ 		goto out;
+ 
+ 	xdp.data = vaddr + dpaa2_fd_get_offset(fd);
+ 	xdp.data_end = xdp.data + dpaa2_fd_get_len(fd);
+ 	xdp.data_hard_start = xdp.data - XDP_PACKET_HEADROOM;
+ 	xdp_set_data_meta_invalid(&xdp);
+ 	xdp.rxq = &ch->xdp_rxq;
+ 
+ 	xdp.frame_sz = DPAA2_ETH_RX_BUF_RAW_SIZE -
+ 		(dpaa2_fd_get_offset(fd) - XDP_PACKET_HEADROOM);
+ 
+ 	xdp_act = bpf_prog_run_xdp(xdp_prog, &xdp);
+ 
+ 	/* xdp.data pointer may have changed */
+ 	dpaa2_fd_set_offset(fd, xdp.data - vaddr);
+ 	dpaa2_fd_set_len(fd, xdp.data_end - xdp.data);
+ 
+ 	switch (xdp_act) {
+ 	case XDP_PASS:
+ 		break;
+ 	case XDP_TX:
+ 		xdp_enqueue(priv, ch, fd, vaddr, rx_fq->flowid);
+ 		break;
+ 	default:
+ 		bpf_warn_invalid_xdp_action(xdp_act);
+ 		fallthrough;
+ 	case XDP_ABORTED:
+ 		trace_xdp_exception(priv->net_dev, xdp_prog, xdp_act);
+ 		fallthrough;
+ 	case XDP_DROP:
+ 		xdp_release_buf(priv, ch, addr);
+ 		ch->stats.xdp_drop++;
+ 		break;
+ 	case XDP_REDIRECT:
+ 		dma_unmap_page(priv->net_dev->dev.parent, addr,
+ 			       priv->rx_buf_size, DMA_BIDIRECTIONAL);
+ 		ch->buf_count--;
+ 
+ 		/* Allow redirect use of full headroom */
+ 		xdp.data_hard_start = vaddr;
+ 		xdp.frame_sz = DPAA2_ETH_RX_BUF_RAW_SIZE;
+ 
+ 		err = xdp_do_redirect(priv->net_dev, &xdp, xdp_prog);
+ 		if (unlikely(err))
+ 			ch->stats.xdp_drop++;
+ 		else
+ 			ch->stats.xdp_redirect++;
+ 		break;
+ 	}
+ 
+ 	ch->xdp.res |= xdp_act;
+ out:
+ 	rcu_read_unlock();
+ 	return xdp_act;
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword):drivers/net/ethernet/freescale/dpaa2/dpaa2-eth.c
  /* Main Rx frame processing routine */
  static void dpaa2_eth_rx(struct dpaa2_eth_priv *priv,
  			 struct dpaa2_eth_channel *ch,
diff --cc drivers/staging/media/imx/imx-media-csi.c
index 95d7805f3485,21ebf7769696..000000000000
--- a/drivers/staging/media/imx/imx-media-csi.c
+++ b/drivers/staging/media/imx/imx-media-csi.c
@@@ -428,12 -479,18 +428,23 @@@ static int csi_idmac_setup_channel(stru
  	case V4L2_PIX_FMT_UYVY:
  		burst_size = (image.pix.width & 0x1f) ?
  			     ((image.pix.width & 0xf) ? 8 : 16) : 32;
 +		passthrough = is_parallel_16bit_bus(&priv->upstream_ep);
  		passthrough_bits = 16;
  		break;
++<<<<<<< HEAD
++=======
+ 	case V4L2_PIX_FMT_RGB565:
+ 		if (passthrough) {
+ 			burst_size = 16;
+ 			passthrough_bits = 8;
+ 			passthrough_cycles = incc->cycles;
+ 			break;
+ 		}
+ 		fallthrough;	/* non-passthrough RGB565 (CSI-2 bus) */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		burst_size = (image.pix.width & 0xf) ? 8 : 16;
 +		passthrough = is_parallel_16bit_bus(&priv->upstream_ep);
  		passthrough_bits = 16;
  		break;
  	}
diff --cc drivers/tty/hvc/hvc_xen.c
index dc43fa96c3de,92c9a476defc..000000000000
--- a/drivers/tty/hvc/hvc_xen.c
+++ b/drivers/tty/hvc/hvc_xen.c
@@@ -492,7 -492,7 +492,11 @@@ static void xencons_backend_changed(str
  	case XenbusStateClosed:
  		if (dev->state == XenbusStateClosed)
  			break;
++<<<<<<< HEAD
 +		/* Missed the backend's CLOSING state -- fallthrough */
++=======
+ 		fallthrough;	/* Missed the backend's CLOSING state */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XenbusStateClosing:
  		xenbus_frontend_closed(dev);
  		break;
diff --cc drivers/tty/mips_ejtag_fdc.c
index 4c1cd49ae95b,a8e19b4833bf..000000000000
--- a/drivers/tty/mips_ejtag_fdc.c
+++ b/drivers/tty/mips_ejtag_fdc.c
@@@ -243,6 -243,7 +243,10 @@@ done
  		/* Fall back to a 3 byte encoding */
  		word.bytes = 3;
  		word.word &= 0x00ffffff;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 3:
  		/* 3 byte encoding */
  		word.word |= 0x82000000;
diff --cc drivers/tty/n_gsm.c
index f4af82c4f03e,35cf12147e39..000000000000
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@@ -1583,8 -1584,8 +1583,13 @@@ static void gsm_dlci_data(struct gsm_dl
  			gsm_process_modem(tty, dlci, modem, clen);
  			tty_kref_put(tty);
  		}
++<<<<<<< HEAD
 +	/* Line state will go via DLCI 0 controls only */
 +	case 1:
++=======
+ 		fallthrough;
+ 	case 1:		/* Line state will go via DLCI 0 controls only */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		tty_insert_flip_string(port, data, len);
  		tty_flip_buffer_push(port);
@@@ -1979,7 -1986,7 +1984,11 @@@ static void gsm1_receive(struct gsm_mu
  		gsm->address = 0;
  		gsm->state = GSM_ADDRESS;
  		gsm->fcs = INIT_FCS;
++<<<<<<< HEAD
 +		/* Drop through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case GSM_ADDRESS:	/* Address continuation */
  		gsm->fcs = gsm_fcs_add(gsm->fcs, c);
  		if (gsm_read_ea(&gsm->address, c))
diff --cc drivers/tty/n_hdlc.c
index ab2d86c8d730,8e975cb29833..000000000000
--- a/drivers/tty/n_hdlc.c
+++ b/drivers/tty/n_hdlc.c
@@@ -776,7 -602,7 +776,11 @@@ static int n_hdlc_tty_ioctl(struct tty_
  		case TCOFLUSH:
  			flush_tx_queue(tty);
  		}
++<<<<<<< HEAD
 +		/* fall through to default */
++=======
+ 		fallthrough;	/* to default */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  		error = n_tty_ioctl_helper(tty, file, cmd, arg);
diff --cc drivers/tty/serial/atmel_serial.c
index 8e4428725848,bb5fc8bdd57a..000000000000
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@@ -1726,6 -1842,22 +1726,25 @@@ static void atmel_get_ip_name(struct ua
  		atmel_port->has_frac_baudrate = true;
  		atmel_port->has_hw_timer = true;
  		atmel_port->rtor = ATMEL_US_RTOR;
++<<<<<<< HEAD
++=======
+ 		version = atmel_uart_readl(port, ATMEL_US_VERSION);
+ 		switch (version) {
+ 		case 0x814:	/* sama5d2 */
+ 			fallthrough;
+ 		case 0x701:	/* sama5d4 */
+ 			atmel_port->fidi_min = 3;
+ 			atmel_port->fidi_max = 65535;
+ 			break;
+ 		case 0x502:	/* sam9x5, sama5d3 */
+ 			atmel_port->fidi_min = 3;
+ 			atmel_port->fidi_max = 2047;
+ 			break;
+ 		default:
+ 			atmel_port->fidi_min = 1;
+ 			atmel_port->fidi_max = 2047;
+ 		}
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	} else if (name == dbgu_uart) {
  		dev_dbg(port->dev, "Dbgu or uart without hw timer\n");
  	} else {
diff --cc drivers/tty/serial/serial-tegra.c
index af2a29cfbbe9,bd13014a1c53..000000000000
--- a/drivers/tty/serial/serial-tegra.c
+++ b/drivers/tty/serial/serial-tegra.c
@@@ -719,6 -874,17 +719,20 @@@ static irqreturn_t tegra_uart_isr(int i
  					UART_IER_RTOIE | TEGRA_UART_IER_EORD);
  				tup->ier_shadow = ier;
  				tegra_uart_write(tup, ier, UART_IER);
++<<<<<<< HEAD
++=======
+ 				break;
+ 			}
+ 			fallthrough;
+ 		case 2: /* Receive */
+ 			if (!tup->use_rx_pio) {
+ 				is_rx_start = tup->rx_in_progress;
+ 				tup->ier_shadow  &= ~UART_IER_RDI;
+ 				tegra_uart_write(tup, tup->ier_shadow,
+ 						 UART_IER);
+ 			} else {
+ 				do_handle_rx_pio(tup);
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			}
  			break;
  
diff --cc drivers/tty/vt/vt.c
index abeda8b063cf,d8b9363b81c1..000000000000
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@@ -1386,8 -1551,10 +1386,14 @@@ static void csi_J(struct vc_data *vc, i
  			count = ((vc->vc_pos - vc->vc_origin) >> 1) + 1;
  			start = (unsigned short *)vc->vc_origin;
  			break;
++<<<<<<< HEAD
++=======
+ 		case 3: /* include scrollback */
+ 			flush_scrollback(vc);
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 2: /* erase whole display */
 +		case 3: /* (and scrollback buffer later) */
  			vc_uniscr_clear_lines(vc, 0, vc->vc_rows);
  			count = vc->vc_cols * vc->vc_rows;
  			start = (unsigned short *)vc->vc_origin;
@@@ -1995,6 -2167,7 +2001,10 @@@ static void do_con_trol(struct tty_stru
  		lf(vc);
  		if (!is_kbd(vc, lnm))
  			return;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 13:
  		cr(vc);
  		return;
@@@ -2117,9 -2291,22 +2127,24 @@@
  			vc->vc_state=ESfunckey;
  			return;
  		}
 -		switch (c) {
 -		case '?':
 -			vc->vc_priv = EPdec;
 +		vc->vc_ques = (c == '?');
 +		if (vc->vc_ques)
  			return;
++<<<<<<< HEAD
++=======
+ 		case '>':
+ 			vc->vc_priv = EPgt;
+ 			return;
+ 		case '=':
+ 			vc->vc_priv = EPeq;
+ 			return;
+ 		case '<':
+ 			vc->vc_priv = EPlt;
+ 			return;
+ 		}
+ 		vc->vc_priv = EPecma;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ESgetpars:
  		if (c == ';' && vc->vc_npar < NPAR - 1) {
  			vc->vc_npar++;
diff --cc drivers/usb/gadget/function/f_mass_storage.c
index 492f0d70510f,950c9435beec..000000000000
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@@ -2039,7 -2039,6 +2039,10 @@@ static int do_scsi_command(struct fsg_c
  	case RELEASE:
  	case RESERVE:
  	case SEND_DIAGNOSTIC:
++<<<<<<< HEAD
 +		/* Fall through */
++=======
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	default:
  unknown_cmnd:
diff --cc drivers/usb/gadget/udc/atmel_usba_udc.c
index 503d275bc4c4,a6426dd1cfef..000000000000
--- a/drivers/usb/gadget/udc/atmel_usba_udc.c
+++ b/drivers/usb/gadget/udc/atmel_usba_udc.c
@@@ -327,6 -328,7 +327,10 @@@ static int usba_config_fifo_table(struc
  	switch (fifo_mode) {
  	default:
  		fifo_mode = 0;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0:
  		udc->fifo_cfg = NULL;
  		n = 0;
diff --cc drivers/usb/musb/omap2430.c
index a3d2fef67746,4232f1ce3fbf..000000000000
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@@ -151,13 -93,36 +151,41 @@@ static void omap_musb_set_mailbox(struc
  	switch (glue->status) {
  	case MUSB_ID_GROUND:
  		dev_dbg(musb->controller, "ID GND\n");
++<<<<<<< HEAD
 +
 +		musb->xceiv->otg->state = OTG_STATE_A_IDLE;
 +		musb->xceiv->last_event = USB_EVENT_ID;
 +		if (musb->gadget_driver) {
 +			omap_control_usb_set_mode(glue->control_otghs,
 +				USB_MODE_HOST);
 +			omap2430_musb_set_vbus(musb, 1);
++=======
+ 		switch (musb->xceiv->otg->state) {
+ 		case OTG_STATE_A_IDLE:
+ 			error = musb_set_host(musb);
+ 			if (error)
+ 				break;
+ 			musb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;
+ 			fallthrough;
+ 		case OTG_STATE_A_WAIT_VRISE:
+ 		case OTG_STATE_A_WAIT_BCON:
+ 		case OTG_STATE_A_HOST:
+ 			/*
+ 			 * On multiple ID ground interrupts just keep enabling
+ 			 * VBUS. At least cpcap VBUS shuts down otherwise.
+ 			 */
+ 			otg_set_vbus(musb->xceiv->otg, 1);
+ 			break;
+ 		default:
+ 			musb->xceiv->otg->state = OTG_STATE_A_IDLE;
+ 			musb->xceiv->last_event = USB_EVENT_ID;
+ 			if (musb->gadget_driver) {
+ 				omap_control_usb_set_mode(glue->control_otghs,
+ 							  USB_MODE_HOST);
+ 				otg_set_vbus(musb->xceiv->otg, 1);
+ 			}
+ 			break;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		}
  		break;
  
diff --cc drivers/video/backlight/adp8860_bl.c
index 16119bde9750,8ec19425671f..000000000000
--- a/drivers/video/backlight/adp8860_bl.c
+++ b/drivers/video/backlight/adp8860_bl.c
@@@ -690,6 -681,7 +690,10 @@@ static int adp8860_probe(struct i2c_cli
  	switch (ADP8860_MANID(reg_val)) {
  	case ADP8863_MANUFID:
  		data->gdwn_dis = !!pdata->gdwn_dis;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ADP8860_MANUFID:
  		data->en_ambl_sens = !!pdata->en_ambl_sens;
  		break;
diff --cc drivers/video/fbdev/acornfb.c
index 0c325b4da61d,bcc92aecf666..000000000000
--- a/drivers/video/fbdev/acornfb.c
+++ b/drivers/video/fbdev/acornfb.c
@@@ -861,6 -857,7 +861,10 @@@ static void acornfb_parse_dram(char *op
  		case 'M':
  		case 'm':
  			size *= 1024;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 'K':
  		case 'k':
  			size *= 1024;
diff --cc drivers/video/fbdev/arcfb.c
index 7e87d0d61658,ae3d8e8b8d33..000000000000
--- a/drivers/video/fbdev/arcfb.c
+++ b/drivers/video/fbdev/arcfb.c
@@@ -419,6 -419,8 +419,11 @@@ static int arcfb_ioctl(struct fb_info *
  			schedule();
  			finish_wait(&arcfb_waitq, &wait);
  		}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case FBIO_GETCONTROL2:
  		{
  			unsigned char ctl2;
diff --cc drivers/video/fbdev/controlfb.c
index 8d14b29aafea,a88dcb63eeb4..000000000000
--- a/drivers/video/fbdev/controlfb.c
+++ b/drivers/video/fbdev/controlfb.c
@@@ -1034,6 -628,150 +1034,153 @@@ static void control_par_to_var(struct f
  	var->pixclock >>= par->regvals.clock_params[2];
  }
  
++<<<<<<< HEAD
++=======
+ /********************  The functions for controlfb_ops ********************/
+ 
+ /*
+  * Checks a var structure
+  */
+ static int controlfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info)
+ {
+ 	struct fb_par_control par;
+ 	int err;
+ 
+ 	err = control_var_to_par(var, &par, info);
+ 	if (err)
+ 		return err;	
+ 	control_par_to_var(&par, var);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Applies current var to display
+  */
+ static int controlfb_set_par (struct fb_info *info)
+ {
+ 	struct fb_info_control *p =
+ 		container_of(info, struct fb_info_control, info);
+ 	struct fb_par_control par;
+ 	int err;
+ 
+ 	if((err = control_var_to_par(&info->var, &par, info))) {
+ 		printk (KERN_ERR "controlfb_set_par: error calling"
+ 				 " control_var_to_par: %d.\n", err);
+ 		return err;
+ 	}
+ 	
+ 	control_set_hardware(p, &par);
+ 
+ 	info->fix.visual = (p->par.cmode == CMODE_8) ?
+ 		FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;
+ 	info->fix.line_length = p->par.pitch;
+ 	info->fix.xpanstep = 32 >> p->par.cmode;
+ 	info->fix.ypanstep = 1;
+ 
+ 	return 0;
+ }
+ 
+ static int controlfb_pan_display(struct fb_var_screeninfo *var,
+ 				 struct fb_info *info)
+ {
+ 	unsigned int xoffset, hstep;
+ 	struct fb_info_control *p =
+ 		container_of(info, struct fb_info_control, info);
+ 	struct fb_par_control *par = &p->par;
+ 
+ 	/*
+ 	 * make sure start addr will be 32-byte aligned
+ 	 */
+ 	hstep = 0x1f >> par->cmode;
+ 	xoffset = (var->xoffset + hstep) & ~hstep;
+ 
+ 	if (xoffset+par->xres > par->vxres ||
+ 	    var->yoffset+par->yres > par->vyres)
+ 		return -EINVAL;
+ 
+ 	set_screen_start(xoffset, var->yoffset, p);
+ 
+ 	return 0;
+ }
+ 
+ static int controlfb_blank(int blank_mode, struct fb_info *info)
+ {
+ 	struct fb_info_control __maybe_unused *p =
+ 		container_of(info, struct fb_info_control, info);
+ 	unsigned ctrl;
+ 
+ 	ctrl = in_le32(CNTRL_REG(p, ctrl));
+ 	if (blank_mode > 0)
+ 		switch (blank_mode) {
+ 		case FB_BLANK_VSYNC_SUSPEND:
+ 			ctrl &= ~3;
+ 			break;
+ 		case FB_BLANK_HSYNC_SUSPEND:
+ 			ctrl &= ~0x30;
+ 			break;
+ 		case FB_BLANK_POWERDOWN:
+ 			ctrl &= ~0x33;
+ 			fallthrough;
+ 		case FB_BLANK_NORMAL:
+ 			ctrl |= 0x400;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	else {
+ 		ctrl &= ~0x400;
+ 		ctrl |= 0x33;
+ 	}
+ 	out_le32(CNTRL_REG(p,ctrl), ctrl);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Private mmap since we want to have a different caching on the framebuffer
+  * for controlfb.
+  * Note there's no locking in here; it's done in fb_mmap() in fbmem.c.
+  */
+ static int controlfb_mmap(struct fb_info *info,
+                        struct vm_area_struct *vma)
+ {
+ 	unsigned long mmio_pgoff;
+ 	unsigned long start;
+ 	u32 len;
+ 
+ 	start = info->fix.smem_start;
+ 	len = info->fix.smem_len;
+ 	mmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;
+ 	if (vma->vm_pgoff >= mmio_pgoff) {
+ 		if (info->var.accel_flags)
+ 			return -EINVAL;
+ 		vma->vm_pgoff -= mmio_pgoff;
+ 		start = info->fix.mmio_start;
+ 		len = info->fix.mmio_len;
+ 		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+ 	} else {
+ 		/* framebuffer */
+ 		vma->vm_page_prot = pgprot_cached_wthru(vma->vm_page_prot);
+ 	}
+ 
+ 	return vm_iomap_memory(vma, start, len);
+ }
+ 
+ static const struct fb_ops controlfb_ops = {
+ 	.owner		= THIS_MODULE,
+ 	.fb_check_var	= controlfb_check_var,
+ 	.fb_set_par	= controlfb_set_par,
+ 	.fb_setcolreg	= controlfb_setcolreg,
+ 	.fb_pan_display = controlfb_pan_display,
+ 	.fb_blank	= controlfb_blank,
+ 	.fb_mmap	= controlfb_mmap,
+ 	.fb_fillrect	= cfb_fillrect,
+ 	.fb_copyarea	= cfb_copyarea,
+ 	.fb_imageblit	= cfb_imageblit,
+ };
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  /*
   * Set misc info vars for this driver
   */
diff --cc drivers/video/fbdev/core/fbmem.c
index 3cce4843c28d,6815bfb7f572..000000000000
--- a/drivers/video/fbdev/core/fbmem.c
+++ b/drivers/video/fbdev/core/fbmem.c
@@@ -1323,6 -1306,7 +1323,10 @@@ static long fb_compat_ioctl(struct fil
  	case FBIOGET_CON2FBMAP:
  	case FBIOPUT_CON2FBMAP:
  		arg = (unsigned long) compat_ptr(arg);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FBIOBLANK:
  		ret = do_fb_ioctl(info, cmd, arg);
  		break;
diff --cc drivers/video/fbdev/fsl-diu-fb.c
index 1bfd13cbd4e3,a547c21c7e92..000000000000
--- a/drivers/video/fbdev/fsl-diu-fb.c
+++ b/drivers/video/fbdev/fsl-diu-fb.c
@@@ -1289,6 -1287,7 +1289,10 @@@ static int fsl_diu_ioctl(struct fb_inf
  		dev_warn(info->dev,
  			 "MFB_SET_PIXFMT value of 0x%08x is deprecated.\n",
  			 MFB_SET_PIXFMT_OLD);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MFB_SET_PIXFMT:
  		if (copy_from_user(&pix_fmt, buf, sizeof(pix_fmt)))
  			return -EFAULT;
@@@ -1298,6 -1297,7 +1302,10 @@@
  		dev_warn(info->dev,
  			 "MFB_GET_PIXFMT value of 0x%08x is deprecated.\n",
  			 MFB_GET_PIXFMT_OLD);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case MFB_GET_PIXFMT:
  		pix_fmt = ad->pix_fmt;
  		if (copy_to_user(buf, &pix_fmt, sizeof(pix_fmt)))
diff --cc drivers/video/fbdev/i740fb.c
index 7bc5f6056c77,e6f35f8feefc..000000000000
--- a/drivers/video/fbdev/i740fb.c
+++ b/drivers/video/fbdev/i740fb.c
@@@ -429,6 -430,7 +429,10 @@@ static int i740fb_decode_var(const stru
  		break;
  	case 9 ... 15:
  		bpp = 15;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 16:
  		if ((1000000 / var->pixclock) > DACSPEED16) {
  			dev_err(info->device, "requested pixclock %i MHz out of range (max. %i MHz at 15/16bpp)\n",
diff --cc drivers/video/fbdev/offb.c
index 77c0a2f45b3b,4501e848a36f..000000000000
--- a/drivers/video/fbdev/offb.c
+++ b/drivers/video/fbdev/offb.c
@@@ -141,6 -141,7 +141,10 @@@ static int offb_setcolreg(u_int regno, 
  		/* Clear PALETTE_ACCESS_CNTL in DAC_CNTL */
  		out_le32(par->cmap_adr + 0x58,
  			 in_le32(par->cmap_adr + 0x58) & ~0x20);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case cmap_r128:
  		/* Set palette index & data */
  		out_8(par->cmap_adr + 0xb0, regno);
@@@ -210,6 -211,7 +214,10 @@@ static int offb_blank(int blank, struc
  				/* Clear PALETTE_ACCESS_CNTL in DAC_CNTL */
  				out_le32(par->cmap_adr + 0x58,
  					 in_le32(par->cmap_adr + 0x58) & ~0x20);
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			case cmap_r128:
  				/* Set palette index & data */
  				out_8(par->cmap_adr + 0xb0, i);
diff --cc drivers/video/fbdev/omap/omapfb_main.c
index 585f39efcff6,3d090d2d9ed9..000000000000
--- a/drivers/video/fbdev/omap/omapfb_main.c
+++ b/drivers/video/fbdev/omap/omapfb_main.c
@@@ -460,6 -443,7 +460,10 @@@ static int set_color_mode(struct omapfb
  		return 0;
  	case 12:
  		var->bits_per_pixel = 16;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 16:
  		if (plane->fbdev->panel->bpp == 12)
  			plane->color_mode = OMAPFB_COLOR_RGB444;
@@@ -1549,20 -1531,27 +1553,44 @@@ static void omapfb_free_resources(struc
  	case OMAPFB_ACTIVE:
  		for (i = 0; i < fbdev->mem_desc.region_cnt; i++)
  			unregister_framebuffer(fbdev->fb_info[i]);
++<<<<<<< HEAD
 +	case 7:
 +		omapfb_unregister_sysfs(fbdev);
 +	case 6:
 +		if (fbdev->panel->disable)
 +			fbdev->panel->disable(fbdev->panel);
 +	case 5:
 +		omapfb_set_update_mode(fbdev, OMAPFB_UPDATE_DISABLED);
 +	case 4:
 +		planes_cleanup(fbdev);
 +	case 3:
 +		ctrl_cleanup(fbdev);
 +	case 2:
 +		if (fbdev->panel->cleanup)
 +			fbdev->panel->cleanup(fbdev->panel);
++=======
+ 		fallthrough;
+ 	case 7:
+ 		omapfb_unregister_sysfs(fbdev);
+ 		fallthrough;
+ 	case 6:
+ 		if (fbdev->panel->disable)
+ 			fbdev->panel->disable(fbdev->panel);
+ 		fallthrough;
+ 	case 5:
+ 		omapfb_set_update_mode(fbdev, OMAPFB_UPDATE_DISABLED);
+ 		fallthrough;
+ 	case 4:
+ 		planes_cleanup(fbdev);
+ 		fallthrough;
+ 	case 3:
+ 		ctrl_cleanup(fbdev);
+ 		fallthrough;
+ 	case 2:
+ 		if (fbdev->panel->cleanup)
+ 			fbdev->panel->cleanup(fbdev->panel);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		dev_set_drvdata(fbdev->dev, NULL);
  		kfree(fbdev);
diff --cc drivers/video/fbdev/omap2/omapfb/dss/dispc.c
index fb605aefd9b1,b2d6e6df2161..000000000000
--- a/drivers/video/fbdev/omap2/omapfb/dss/dispc.c
+++ b/drivers/video/fbdev/omap2/omapfb/dss/dispc.c
@@@ -1905,6 -1861,7 +1905,10 @@@ static void calc_vrfb_rotation_offset(u
  		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
  			color_mode == OMAP_DSS_COLOR_UYVY)
  			width = width >> 1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case OMAP_DSS_ROT_90:
  	case OMAP_DSS_ROT_270:
  		*offset1 = 0;
@@@ -1927,6 -1884,7 +1931,10 @@@
  		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
  			color_mode == OMAP_DSS_COLOR_UYVY)
  			width = width >> 1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case OMAP_DSS_ROT_90 + 4:
  	case OMAP_DSS_ROT_270 + 4:
  		*offset1 = 0;
diff --cc drivers/video/fbdev/omap2/omapfb/omapfb-main.c
index e08e5664e330,a3decc7fadde..000000000000
--- a/drivers/video/fbdev/omap2/omapfb/omapfb-main.c
+++ b/drivers/video/fbdev/omap2/omapfb/omapfb-main.c
@@@ -893,6 -882,7 +893,10 @@@ int omapfb_setup_overlay(struct fb_inf
  				/ (var->bits_per_pixel >> 2);
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		screen_width = fix->line_length / (var->bits_per_pixel >> 3);
  		break;
diff --cc drivers/video/fbdev/pm2fb.c
index bd6c2f5f6095,0642555289e0..000000000000
--- a/drivers/video/fbdev/pm2fb.c
+++ b/drivers/video/fbdev/pm2fb.c
@@@ -233,8 -233,10 +233,15 @@@ static u32 to3264(u32 timing, int bpp, 
  	switch (bpp) {
  	case 24:
  		timing *= 3;
++<<<<<<< HEAD
 +	case 8:
 +		timing >>= 1;
++=======
+ 		fallthrough;
+ 	case 8:
+ 		timing >>= 1;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 16:
  		timing >>= 1;
  	case 32:
diff --cc drivers/video/fbdev/s3c-fb.c
index 9ec85ccd0ce9,ba316bd56efd..000000000000
--- a/drivers/video/fbdev/s3c-fb.c
+++ b/drivers/video/fbdev/s3c-fb.c
@@@ -287,7 -284,7 +287,11 @@@ static int s3c_fb_check_var(struct fb_v
  		/* 666 with one bit alpha/transparency */
  		var->transp.offset	= 18;
  		var->transp.length	= 1;
++<<<<<<< HEAD
 +		/* drop through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 18:
  		var->bits_per_pixel	= 32;
  
@@@ -315,7 -312,7 +319,11 @@@
  	case 25:
  		var->transp.length	= var->bits_per_pixel - 24;
  		var->transp.offset	= 24;
++<<<<<<< HEAD
 +		/* drop through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 24:
  		/* our 24bpp is unpacked, so 32bpp */
  		var->bits_per_pixel	= 32;
@@@ -812,7 -809,7 +820,11 @@@ static int s3c_fb_blank(int blank_mode
  	case FB_BLANK_POWERDOWN:
  		wincon &= ~WINCONx_ENWIN;
  		sfb->enabled &= ~(1 << index);
++<<<<<<< HEAD
 +		/* fall through to FB_BLANK_NORMAL */
++=======
+ 		fallthrough;	/* to FB_BLANK_NORMAL */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case FB_BLANK_NORMAL:
  		/* disable the DMA and display 0x0 (black) */
diff --cc drivers/video/fbdev/sh_mobile_lcdcfb.c
index dc46be38c970,c1043420dbd3..000000000000
--- a/drivers/video/fbdev/sh_mobile_lcdcfb.c
+++ b/drivers/video/fbdev/sh_mobile_lcdcfb.c
@@@ -1676,6 -1594,7 +1676,10 @@@ sh_mobile_lcdc_overlay_fb_init(struct s
  	case V4L2_PIX_FMT_NV12:
  	case V4L2_PIX_FMT_NV21:
  		info->fix.ypanstep = 2;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case V4L2_PIX_FMT_NV16:
  	case V4L2_PIX_FMT_NV61:
  		info->fix.xpanstep = 2;
@@@ -2177,6 -2085,7 +2181,10 @@@ sh_mobile_lcdc_channel_fb_init(struct s
  	case V4L2_PIX_FMT_NV12:
  	case V4L2_PIX_FMT_NV21:
  		info->fix.ypanstep = 2;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case V4L2_PIX_FMT_NV16:
  	case V4L2_PIX_FMT_NV61:
  		info->fix.xpanstep = 2;
diff --cc drivers/video/fbdev/stifb.c
index 045e8afe398b,265865610edc..000000000000
--- a/drivers/video/fbdev/stifb.c
+++ b/drivers/video/fbdev/stifb.c
@@@ -1157,7 -1157,7 +1157,11 @@@ static int __init stifb_init_fb(struct 
  			dev_name);
  		   goto out_err0;
  		}
++<<<<<<< HEAD
 +		/* fall though */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case S9000_ID_ARTIST:
  	case S9000_ID_HCRX:
  	case S9000_ID_TIMBER:
diff --cc drivers/video/fbdev/tdfxfb.c
index dec1fed9880e,f056d80f6359..000000000000
--- a/drivers/video/fbdev/tdfxfb.c
+++ b/drivers/video/fbdev/tdfxfb.c
@@@ -522,6 -523,7 +522,10 @@@ static int tdfxfb_check_var(struct fb_v
  	case 32:
  		var->transp.offset = 24;
  		var->transp.length = 8;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 24:
  		var->red.offset = 16;
  		var->green.offset = 8;
diff --cc drivers/video/fbdev/via/lcd.c
index 5d21ff436ec8,4a869402d120..000000000000
--- a/drivers/video/fbdev/via/lcd.c
+++ b/drivers/video/fbdev/via/lcd.c
@@@ -758,6 -744,7 +758,10 @@@ static void set_lcd_output_path(int set
  		    viaparinfo->chip_info->gfx_chip_name))
  			viafb_write_reg_mask(CR97, VIACR, 0x84,
  				       BIT7 + BIT2 + BIT1 + BIT0);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case INTERFACE_DVP0:
  	case INTERFACE_DVP1:
  	case INTERFACE_DFP_HIGH:
diff --cc drivers/video/fbdev/xen-fbfront.c
index 6a4bbc9e1fb0,5ec51445bee8..000000000000
--- a/drivers/video/fbdev/xen-fbfront.c
+++ b/drivers/video/fbdev/xen-fbfront.c
@@@ -677,7 -677,7 +677,11 @@@ static void xenfb_backend_changed(struc
  	case XenbusStateClosed:
  		if (dev->state == XenbusStateClosed)
  			break;
++<<<<<<< HEAD
 +		/* Missed the backend's CLOSING state -- fallthrough */
++=======
+ 		fallthrough;	/* Missed the backend's CLOSING state */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XenbusStateClosing:
  		xenbus_frontend_closed(dev);
  		break;
diff --cc drivers/watchdog/sc1200wdt.c
index 8e4e2fc13f87,f22ebe89fe13..000000000000
--- a/drivers/watchdog/sc1200wdt.c
+++ b/drivers/watchdog/sc1200wdt.c
@@@ -239,7 -234,7 +239,11 @@@ static long sc1200wdt_ioctl(struct fil
  			return -EINVAL;
  		timeout = new_timeout;
  		sc1200wdt_write_data(WDTO, timeout);
++<<<<<<< HEAD
 +		/* fall through and return the new timeout */
++=======
+ 		fallthrough;	/* and return the new timeout */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case WDIOC_GETTIMEOUT:
  		return put_user(timeout * 60, p);
diff --cc drivers/xen/xen-pciback/xenbus.c
index 581c4e1a8b82,b500466a6c37..000000000000
--- a/drivers/xen/xen-pciback/xenbus.c
+++ b/drivers/xen/xen-pciback/xenbus.c
@@@ -544,7 -545,7 +544,11 @@@ static void xen_pcibk_frontend_changed(
  		xenbus_switch_state(xdev, XenbusStateClosed);
  		if (xenbus_dev_is_online(xdev))
  			break;
++<<<<<<< HEAD
 +		/* fall through if not online */
++=======
+ 		fallthrough;	/* if not online */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XenbusStateUnknown:
  		dev_dbg(&xdev->dev, "frontend is gone! unregister device\n");
  		device_unregister(&xdev->dev);
diff --cc drivers/xen/xen-scsiback.c
index e59937293a32,1e8cfd80a4e6..000000000000
--- a/drivers/xen/xen-scsiback.c
+++ b/drivers/xen/xen-scsiback.c
@@@ -1184,7 -1185,7 +1184,11 @@@ static void scsiback_frontend_changed(s
  		xenbus_switch_state(dev, XenbusStateClosed);
  		if (xenbus_dev_is_online(dev))
  			break;
++<<<<<<< HEAD
 +		/* fall through if not online */
++=======
+ 		fallthrough;	/* if not online */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XenbusStateUnknown:
  		device_unregister(&dev->dev);
  		break;
diff --cc fs/9p/vfs_file.c
index 03c9e325bfbc,3576123d8299..000000000000
--- a/fs/9p/vfs_file.c
+++ b/fs/9p/vfs_file.c
@@@ -216,7 -213,7 +216,11 @@@ static int v9fs_file_do_lock(struct fil
  		break;
  	default:
  		WARN_ONCE(1, "unknown lock status code: %d\n", status);
++<<<<<<< HEAD
 +		/* fallthough */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case P9_LOCK_ERROR:
  	case P9_LOCK_GRACE:
  		res = -ENOLCK;
diff --cc fs/adfs/dir_f.c
index 0fbfd0b04ae0,05e963402e25..000000000000
--- a/fs/adfs/dir_f.c
+++ b/fs/adfs/dir_f.c
@@@ -24,8 -18,11 +24,16 @@@ static inline unsigned int adfs_readval
  
  	switch (len) {
  	case 4:		val |= p[3] << 24;
++<<<<<<< HEAD
 +	case 3:		val |= p[2] << 16;
 +	case 2:		val |= p[1] << 8;
++=======
+ 		fallthrough;
+ 	case 3:		val |= p[2] << 16;
+ 		fallthrough;
+ 	case 2:		val |= p[1] << 8;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:	val |= p[0];
  	}
  	return val;
@@@ -35,8 -32,11 +43,16 @@@ static inline void adfs_writeval(unsign
  {
  	switch (len) {
  	case 4:		p[3] = val >> 24;
++<<<<<<< HEAD
++	case 3:		p[2] = val >> 16;
++	case 2:		p[1] = val >> 8;
++=======
+ 		fallthrough;
  	case 3:		p[2] = val >> 16;
+ 		fallthrough;
  	case 2:		p[1] = val >> 8;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:	p[0] = val;
  	}
  }
diff --cc fs/afs/cmservice.c
index eb2a3897dd30,a4e9e6e07e93..000000000000
--- a/fs/afs/cmservice.c
+++ b/fs/afs/cmservice.c
@@@ -180,9 -252,10 +180,13 @@@ static int afs_deliver_cb_callback(stru
  		call->unmarshall++;
  
  		/* extract the FID array and its count in two steps */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		_debug("extract FID count");
 -		ret = afs_extract_data(call, true);
 +		ret = afs_extract_data(call, &call->tmp, 4, true);
  		if (ret < 0)
  			return ret;
  
@@@ -195,13 -268,13 +199,17 @@@
  				       GFP_KERNEL);
  		if (!call->buffer)
  			return -ENOMEM;
 -		afs_extract_to_buf(call, call->count * 3 * 4);
 +		call->offset = 0;
  		call->unmarshall++;
  
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
  		_debug("extract FID array");
 -		ret = afs_extract_data(call, true);
 +		ret = afs_extract_data(call, call->buffer,
 +				       call->count * 3 * 4, true);
  		if (ret < 0)
  			return ret;
  
@@@ -225,23 -297,27 +233,31 @@@
  		call->unmarshall++;
  
  		/* extract the callback array and its count in two steps */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 3:
  		_debug("extract CB count");
 -		ret = afs_extract_data(call, true);
 +		ret = afs_extract_data(call, &call->tmp, 4, true);
  		if (ret < 0)
  			return ret;
  
  		call->count2 = ntohl(call->tmp);
  		_debug("CB count: %u", call->count2);
  		if (call->count2 != call->count && call->count2 != 0)
 -			return afs_protocol_error(call, afs_eproto_cb_count);
 -		call->iter = &call->def_iter;
 -		iov_iter_discard(&call->def_iter, READ, call->count2 * 3 * 4);
 +			return afs_protocol_error(call, -EBADMSG);
 +		call->offset = 0;
  		call->unmarshall++;
  
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 4:
 -		_debug("extract discard %zu/%u",
 -		       iov_iter_count(call->iter), call->count2 * 3 * 4);
 -
 -		ret = afs_extract_data(call, false);
 +		_debug("extract CB array");
 +		ret = afs_extract_data(call, call->buffer,
 +				       call->count2 * 3 * 4, false);
  		if (ret < 0)
  			return ret;
  
@@@ -334,12 -388,13 +350,16 @@@ static int afs_deliver_cb_init_call_bac
  		call->buffer = kmalloc_array(11, sizeof(__be32), GFP_KERNEL);
  		if (!call->buffer)
  			return -ENOMEM;
 -		afs_extract_to_buf(call, 11 * sizeof(__be32));
  		call->unmarshall++;
  
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		_debug("extract UUID");
 -		ret = afs_extract_data(call, false);
 +		ret = afs_extract_data(call, call->buffer,
 +				       11 * sizeof(__be32), false);
  		switch (ret) {
  		case 0:		break;
  		case -EAGAIN:	return 0;
@@@ -457,12 -500,13 +477,16 @@@ static int afs_deliver_cb_probe_uuid(st
  		call->buffer = kmalloc_array(11, sizeof(__be32), GFP_KERNEL);
  		if (!call->buffer)
  			return -ENOMEM;
 -		afs_extract_to_buf(call, 11 * sizeof(__be32));
  		call->unmarshall++;
  
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
  		_debug("extract UUID");
 -		ret = afs_extract_data(call, false);
 +		ret = afs_extract_data(call, call->buffer,
 +				       11 * sizeof(__be32), false);
  		switch (ret) {
  		case 0:		break;
  		case -EAGAIN:	return 0;
@@@ -553,7 -596,83 +577,89 @@@ static int afs_deliver_cb_tell_me_about
  		return ret;
  
  	if (!afs_check_call_state(call, AFS_CALL_SV_REPLYING))
++<<<<<<< HEAD
 +		return -EIO;
 +
 +	return afs_queue_call_work(call);
++=======
+ 		return afs_io_error(call, afs_io_error_cm_reply);
+ 	return afs_find_cm_server_by_peer(call);
+ }
+ 
+ /*
+  * deliver request data to a YFS CB.CallBack call
+  */
+ static int afs_deliver_yfs_cb_callback(struct afs_call *call)
+ {
+ 	struct afs_callback_break *cb;
+ 	struct yfs_xdr_YFSFid *bp;
+ 	size_t size;
+ 	int ret, loop;
+ 
+ 	_enter("{%u}", call->unmarshall);
+ 
+ 	switch (call->unmarshall) {
+ 	case 0:
+ 		afs_extract_to_tmp(call);
+ 		call->unmarshall++;
+ 
+ 		/* extract the FID array and its count in two steps */
+ 		fallthrough;
+ 	case 1:
+ 		_debug("extract FID count");
+ 		ret = afs_extract_data(call, true);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		call->count = ntohl(call->tmp);
+ 		_debug("FID count: %u", call->count);
+ 		if (call->count > YFSCBMAX)
+ 			return afs_protocol_error(call, afs_eproto_cb_fid_count);
+ 
+ 		size = array_size(call->count, sizeof(struct yfs_xdr_YFSFid));
+ 		call->buffer = kmalloc(size, GFP_KERNEL);
+ 		if (!call->buffer)
+ 			return -ENOMEM;
+ 		afs_extract_to_buf(call, size);
+ 		call->unmarshall++;
+ 
+ 		fallthrough;
+ 	case 2:
+ 		_debug("extract FID array");
+ 		ret = afs_extract_data(call, false);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		_debug("unmarshall FID array");
+ 		call->request = kcalloc(call->count,
+ 					sizeof(struct afs_callback_break),
+ 					GFP_KERNEL);
+ 		if (!call->request)
+ 			return -ENOMEM;
+ 
+ 		cb = call->request;
+ 		bp = call->buffer;
+ 		for (loop = call->count; loop > 0; loop--, cb++) {
+ 			cb->fid.vid	= xdr_to_u64(bp->volume);
+ 			cb->fid.vnode	= xdr_to_u64(bp->vnode.lo);
+ 			cb->fid.vnode_hi = ntohl(bp->vnode.hi);
+ 			cb->fid.unique	= ntohl(bp->vnode.unique);
+ 			bp++;
+ 		}
+ 
+ 		afs_extract_to_tmp(call);
+ 		call->unmarshall++;
+ 
+ 	case 3:
+ 		break;
+ 	}
+ 
+ 	if (!afs_check_call_state(call, AFS_CALL_SV_REPLYING))
+ 		return afs_io_error(call, afs_io_error_cm_reply);
+ 
+ 	/* We'll need the file server record as that tells us which set of
+ 	 * vnodes to operate upon.
+ 	 */
+ 	return afs_find_cm_server_by_peer(call);
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  }
diff --cc fs/afs/file.c
index 7d4f26198573,371d1488cc54..000000000000
--- a/fs/afs/file.c
+++ b/fs/afs/file.c
@@@ -299,10 -310,11 +299,15 @@@ int afs_page_filler(void *data, struct 
  		/* page will not be cached */
  	case -ENOBUFS:
  		_debug("cache said ENOBUFS");
++<<<<<<< HEAD
++=======
+ 
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  	go_on:
 -		req = kzalloc(struct_size(req, array, 1), GFP_KERNEL);
 +		req = kzalloc(sizeof(struct afs_read) + sizeof(struct page *),
 +			      GFP_KERNEL);
  		if (!req)
  			goto enomem;
  
diff --cc fs/afs/flock.c
index dc62d15a964b,eff82a6839e4..000000000000
--- a/fs/afs/flock.c
+++ b/fs/afs/flock.c
@@@ -247,62 -359,24 +247,66 @@@ again
  		_leave(" [ext]");
  		return;
  
 -	/* If we're waiting for a callback to indicate lock release, we can't
 -	 * actually rely on this, so need to recheck at regular intervals.  The
 -	 * problem is that the server might not notify us if the lock just
 -	 * expires (say because a client died) rather than being explicitly
 -	 * released.
 -	 */
 +		/* If we don't have a granted lock, then we must've been called
 +		 * back by the server, and so if might be possible to get a
 +		 * lock we're currently waiting for.
 +		 */
  	case AFS_VNODE_LOCK_WAITING_FOR_CB:
 -		_debug("retry");
 -		afs_next_locker(vnode, 0);
 -		spin_unlock(&vnode->lock);
 -		return;
 +		_debug("get");
  
 -	case AFS_VNODE_LOCK_DELETED:
 -		afs_kill_lockers_enoent(vnode);
 +		key = key_get(vnode->lock_key);
 +		type = vnode->lock_type;
 +		vnode->lock_state = AFS_VNODE_LOCK_SETTING;
  		spin_unlock(&vnode->lock);
 -		return;
  
++<<<<<<< HEAD
 +		ret = afs_set_lock(vnode, key, type); /* RPC */
 +		key_put(key);
 +
 +		spin_lock(&vnode->lock);
 +		switch (ret) {
 +		case -EWOULDBLOCK:
 +			_debug("blocked");
 +			break;
 +		case 0:
 +			_debug("acquired");
 +			vnode->lock_state = AFS_VNODE_LOCK_GRANTED;
 +			/* Fall through */
 +		default:
 +			/* Pass the lock or the error onto the first locker in
 +			 * the list - if they're looking for this type of lock.
 +			 * If they're not, we assume that whoever asked for it
 +			 * took a signal.
 +			 */
 +			if (list_empty(&vnode->pending_locks)) {
 +				_debug("withdrawn");
 +				vnode->lock_state = AFS_VNODE_LOCK_NEED_UNLOCK;
 +				goto again;
 +			}
 +
 +			fl = list_entry(vnode->pending_locks.next,
 +					struct file_lock, fl_u.afs.link);
 +			type = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;
 +			if (vnode->lock_type != type) {
 +				_debug("changed");
 +				vnode->lock_state = AFS_VNODE_LOCK_NEED_UNLOCK;
 +				goto again;
 +			}
 +
 +			fl->fl_u.afs.state = ret;
 +			if (ret == 0)
 +				afs_grant_locks(vnode, fl);
 +			else
 +				list_del_init(&fl->fl_u.afs.link);
 +			wake_up(&fl->fl_wait);
 +			spin_unlock(&vnode->lock);
 +			_leave(" [granted]");
 +			return;
 +		}
 +
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		/* Looks like a lock request was withdrawn. */
  		spin_unlock(&vnode->lock);
diff --cc fs/afs/fsclient.c
index 50929cb91732,1d95ed9dd86e..000000000000
--- a/fs/afs/fsclient.c
+++ b/fs/afs/fsclient.c
@@@ -478,32 -311,21 +478,36 @@@ static int afs_deliver_fs_fetch_data(st
  	switch (call->unmarshall) {
  	case 0:
  		req->actual_len = 0;
 -		req->index = 0;
 -		req->offset = req->pos & (PAGE_SIZE - 1);
 +		call->offset = 0;
  		call->unmarshall++;
 -		if (call->operation_ID == FSFETCHDATA64) {
 -			afs_extract_to_tmp64(call);
 -		} else {
 -			call->tmp_u = htonl(0);
 -			afs_extract_to_tmp(call);
 +		if (call->operation_ID != FSFETCHDATA64) {
 +			call->unmarshall++;
 +			goto no_msw;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -		/* extract the returned data length */
 +		/* extract the upper part of the returned data length of an
 +		 * FSFETCHDATA64 op (which should always be 0 using this
 +		 * client) */
  	case 1:
 +		_debug("extract data length (MSW)");
 +		ret = afs_extract_data(call, &call->tmp, 4, true);
 +		if (ret < 0)
 +			return ret;
 +
 +		req->actual_len = ntohl(call->tmp);
 +		req->actual_len <<= 32;
 +		call->offset = 0;
 +		call->unmarshall++;
 +
 +	no_msw:
 +		/* extract the returned data length */
 +	case 2:
  		_debug("extract data length");
 -		ret = afs_extract_data(call, true);
 +		ret = afs_extract_data(call, &call->tmp, 4, true);
  		if (ret < 0)
  			return ret;
  
@@@ -519,63 -339,60 +523,84 @@@
  
  	begin_page:
  		ASSERTCMP(req->index, <, req->nr_pages);
 -		if (req->remain > PAGE_SIZE - req->offset)
 -			size = PAGE_SIZE - req->offset;
 +		if (req->remain > PAGE_SIZE - call->offset)
 +			size = PAGE_SIZE - call->offset;
  		else
  			size = req->remain;
++<<<<<<< HEAD
 +		call->count = call->offset + size;
 +		ASSERTCMP(call->count, <=, PAGE_SIZE);
 +		req->remain -= size;
++=======
+ 		call->bvec[0].bv_len = size;
+ 		call->bvec[0].bv_offset = req->offset;
+ 		call->bvec[0].bv_page = req->pages[req->index];
+ 		iov_iter_bvec(&call->def_iter, READ, call->bvec, 1, size);
+ 		ASSERTCMP(size, <=, PAGE_SIZE);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the returned data */
 -	case 2:
 -		_debug("extract data %zu/%llu",
 -		       iov_iter_count(call->iter), req->remain);
 +	case 3:
 +		_debug("extract data %llu/%llu %zu/%u",
 +		       req->remain, req->actual_len, call->offset, call->count);
  
 -		ret = afs_extract_data(call, true);
 +		buffer = kmap(req->pages[req->index]);
 +		ret = afs_extract_data(call, buffer, call->count, true);
 +		kunmap(req->pages[req->index]);
  		if (ret < 0)
  			return ret;
 -		req->remain -= call->bvec[0].bv_len;
 -		req->offset += call->bvec[0].bv_len;
 -		ASSERTCMP(req->offset, <=, PAGE_SIZE);
 -		if (req->offset == PAGE_SIZE) {
 -			req->offset = 0;
 +		if (call->offset == PAGE_SIZE) {
 +			if (req->page_done)
 +				req->page_done(call, req);
  			req->index++;
 -			if (req->remain > 0)
 +			if (req->remain > 0) {
 +				call->offset = 0;
 +				if (req->index >= req->nr_pages) {
 +					call->unmarshall = 4;
 +					goto begin_discard;
 +				}
  				goto begin_page;
 +			}
  		}
 -
 -		ASSERTCMP(req->remain, ==, 0);
 -		if (req->actual_len <= req->len)
 -			goto no_more_data;
 +		goto no_more_data;
  
  		/* Discard any excess data the server gave us */
++<<<<<<< HEAD
 +	begin_discard:
 +	case 4:
 +		size = min_t(loff_t, sizeof(afs_discard_buffer), req->remain);
 +		call->count = size;
 +		_debug("extract discard %llu/%llu %zu/%u",
 +		       req->remain, req->actual_len, call->offset, call->count);
++=======
+ 		afs_extract_discard(call, req->actual_len - req->len);
+ 		call->unmarshall = 3;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	case 3:
 -		_debug("extract discard %zu/%llu",
 -		       iov_iter_count(call->iter), req->actual_len - req->len);
 -
 -		ret = afs_extract_data(call, true);
 +		call->offset = 0;
 +		ret = afs_extract_data(call, afs_discard_buffer, call->count, true);
 +		req->remain -= call->offset;
  		if (ret < 0)
  			return ret;
 +		if (req->remain > 0)
 +			goto begin_discard;
  
  	no_more_data:
++<<<<<<< HEAD
 +		call->offset = 0;
 +		call->unmarshall = 5;
++=======
+ 		call->unmarshall = 4;
+ 		afs_extract_to_buf(call, (21 + 3 + 6) * 4);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the metadata */
 -	case 4:
 -		ret = afs_extract_data(call, false);
 +	case 5:
 +		ret = afs_extract_data(call, call->buffer,
 +				       (21 + 3 + 6) * 4, false);
  		if (ret < 0)
  			return ret;
  
@@@ -1587,8 -1341,9 +1612,13 @@@ static int afs_deliver_fs_get_volume_st
  
  	switch (call->unmarshall) {
  	case 0:
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		afs_extract_to_buf(call, 12 * 4);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the returned status record */
  	case 1:
@@@ -1599,9 -1353,10 +1629,14 @@@
  			return ret;
  
  		bp = call->buffer;
 -		xdr_decode_AFSFetchVolumeStatus(&bp, &op->volstatus.vs);
 +		xdr_decode_AFSFetchVolumeStatus(&bp, call->reply[1]);
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		afs_extract_to_tmp(call);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the volume name length */
  	case 2:
@@@ -1612,115 -1367,79 +1647,135 @@@
  		call->count = ntohl(call->tmp);
  		_debug("volname length: %u", call->count);
  		if (call->count >= AFSNAMEMAX)
 -			return afs_protocol_error(call, afs_eproto_volname_len);
 -		size = (call->count + 3) & ~3; /* It's padded */
 -		afs_extract_to_buf(call, size);
 +			return afs_protocol_error(call, -EBADMSG);
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the volume name */
  	case 3:
  		_debug("extract volname");
 -		ret = afs_extract_data(call, true);
 -		if (ret < 0)
 -			return ret;
 +		if (call->count > 0) {
 +			ret = afs_extract_data(call, call->reply[2],
 +					       call->count, true);
 +			if (ret < 0)
 +				return ret;
 +		}
  
 -		p = call->buffer;
 +		p = call->reply[2];
  		p[call->count] = 0;
  		_debug("volname '%s'", p);
 -		afs_extract_to_tmp(call);
 +
 +		call->offset = 0;
 +		call->unmarshall++;
 +
 +		/* extract the volume name padding */
 +		if ((call->count & 3) == 0) {
 +			call->unmarshall++;
 +			goto no_volname_padding;
 +		}
 +		call->count = 4 - (call->count & 3);
 +
 +	case 4:
 +		ret = afs_extract_data(call, call->buffer,
 +				       call->count, true);
 +		if (ret < 0)
 +			return ret;
 +
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
 +	no_volname_padding:
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the offline message length */
 -	case 4:
 -		ret = afs_extract_data(call, true);
 +	case 5:
 +		ret = afs_extract_data(call, &call->tmp, 4, true);
  		if (ret < 0)
  			return ret;
  
  		call->count = ntohl(call->tmp);
  		_debug("offline msg length: %u", call->count);
  		if (call->count >= AFSNAMEMAX)
 -			return afs_protocol_error(call, afs_eproto_offline_msg_len);
 -		size = (call->count + 3) & ~3; /* It's padded */
 -		afs_extract_to_buf(call, size);
 +			return afs_protocol_error(call, -EBADMSG);
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the offline message */
 -	case 5:
 +	case 6:
  		_debug("extract offline");
 -		ret = afs_extract_data(call, true);
 -		if (ret < 0)
 -			return ret;
 +		if (call->count > 0) {
 +			ret = afs_extract_data(call, call->reply[2],
 +					       call->count, true);
 +			if (ret < 0)
 +				return ret;
 +		}
  
 -		p = call->buffer;
 +		p = call->reply[2];
  		p[call->count] = 0;
  		_debug("offline '%s'", p);
  
 -		afs_extract_to_tmp(call);
 +		call->offset = 0;
 +		call->unmarshall++;
++<<<<<<< HEAD
 +
 +		/* extract the offline message padding */
 +		if ((call->count & 3) == 0) {
 +			call->unmarshall++;
 +			goto no_offline_padding;
 +		}
 +		call->count = 4 - (call->count & 3);
 +
 +	case 7:
 +		ret = afs_extract_data(call, call->buffer,
 +				       call->count, true);
 +		if (ret < 0)
 +			return ret;
 +
 +		call->offset = 0;
  		call->unmarshall++;
 +	no_offline_padding:
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the message of the day length */
 -	case 6:
 -		ret = afs_extract_data(call, true);
 +	case 8:
 +		ret = afs_extract_data(call, &call->tmp, 4, true);
  		if (ret < 0)
  			return ret;
  
  		call->count = ntohl(call->tmp);
  		_debug("motd length: %u", call->count);
  		if (call->count >= AFSNAMEMAX)
 -			return afs_protocol_error(call, afs_eproto_motd_len);
 -		size = (call->count + 3) & ~3; /* It's padded */
 -		afs_extract_to_buf(call, size);
 +			return afs_protocol_error(call, -EBADMSG);
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* extract the message of the day */
 -	case 7:
 +	case 9:
  		_debug("extract motd");
 -		ret = afs_extract_data(call, false);
 -		if (ret < 0)
 -			return ret;
 +		if (call->count > 0) {
 +			ret = afs_extract_data(call, call->reply[2],
 +					       call->count, true);
 +			if (ret < 0)
 +				return ret;
 +		}
  
 -		p = call->buffer;
 +		p = call->reply[2];
  		p[call->count] = 0;
  		_debug("motd '%s'", p);
  
@@@ -2004,13 -1676,13 +2059,17 @@@ static int afs_deliver_fs_get_capabilit
  	u32 count;
  	int ret;
  
 -	_enter("{%u,%zu}", call->unmarshall, iov_iter_count(call->iter));
 +	_enter("{%u,%zu/%u}", call->unmarshall, call->offset, call->count);
  
 +again:
  	switch (call->unmarshall) {
  	case 0:
 -		afs_extract_to_tmp(call);
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* Extract the capabilities word count */
  	case 1:
@@@ -2024,8 -1694,9 +2083,12 @@@
  
  		call->count = count;
  		call->count2 = count;
 -		afs_extract_discard(call, count * sizeof(__be32));
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* Extract capabilities words */
  	case 2:
@@@ -2193,8 -1774,9 +2256,12 @@@ static int afs_deliver_fs_inline_bulk_s
  
  	switch (call->unmarshall) {
  	case 0:
 -		afs_extract_to_tmp(call);
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* Extract the file status count and array in two steps */
  	case 1:
@@@ -2211,7 -1793,8 +2278,12 @@@
  		call->count = 0;
  		call->unmarshall++;
  	more_counts:
++<<<<<<< HEAD
 +		call->offset = 0;
++=======
+ 		afs_extract_to_buf(call, 21 * sizeof(__be32));
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case 2:
  		_debug("extract status array %u", call->count);
@@@ -2232,7 -1823,8 +2304,12 @@@
  
  		call->count = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
 +		call->offset = 0;
++=======
+ 		afs_extract_to_tmp(call);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		/* Extract the callback count and array in two steps */
  	case 3:
@@@ -2248,7 -1840,8 +2325,12 @@@
  		call->count = 0;
  		call->unmarshall++;
  	more_cbs:
++<<<<<<< HEAD
 +		call->offset = 0;
++=======
+ 		afs_extract_to_buf(call, 3 * sizeof(__be32));
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case 4:
  		_debug("extract CB array");
@@@ -2257,23 -1850,30 +2339,27 @@@
  			return ret;
  
  		_debug("unmarshall CB array");
 -		switch (call->count) {
 -		case 0:
 -			scb = &op->file[0].scb;
 -			break;
 -		case 1:
 -			scb = &op->file[1].scb;
 -			break;
 -		default:
 -			scb = &op->more_files[call->count - 2].scb;
 -			break;
 -		}
 -
  		bp = call->buffer;
 -		xdr_decode_AFSCallBack(&bp, call, scb);
 +		callbacks = call->reply[2];
 +		callbacks[call->count].version	= ntohl(bp[0]);
 +		callbacks[call->count].expiry	= ntohl(bp[1]);
 +		callbacks[call->count].type	= ntohl(bp[2]);
 +		statuses = call->reply[1];
 +		if (call->count == 0 && vnode && statuses[0].abort_code == 0)
 +			xdr_decode_AFSCallBack(call, vnode, &bp);
  		call->count++;
 -		if (call->count < op->nr_files)
 +		if (call->count < call->count2)
  			goto more_cbs;
  
 -		afs_extract_to_buf(call, 6 * sizeof(__be32));
 +		call->offset = 0;
  		call->unmarshall++;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case 5:
 -		ret = afs_extract_data(call, false);
 +		ret = afs_extract_data(call, call->buffer, 6 * 4, false);
  		if (ret < 0)
  			return ret;
  
@@@ -2338,15 -1939,168 +2424,169 @@@ int afs_fs_inline_bulk_status(struct af
  	/* marshall the parameters */
  	bp = call->request;
  	*bp++ = htonl(FSINLINEBULKSTATUS);
 -	*bp++ = htonl(op->nr_files);
 -	*bp++ = htonl(dvp->fid.vid);
 -	*bp++ = htonl(dvp->fid.vnode);
 -	*bp++ = htonl(dvp->fid.unique);
 -	*bp++ = htonl(vp->fid.vid);
 -	*bp++ = htonl(vp->fid.vnode);
 -	*bp++ = htonl(vp->fid.unique);
 -	for (i = 0; i < op->nr_files - 2; i++) {
 -		*bp++ = htonl(op->more_files[i].fid.vid);
 -		*bp++ = htonl(op->more_files[i].fid.vnode);
 -		*bp++ = htonl(op->more_files[i].fid.unique);
 +	*bp++ = htonl(nr_fids);
 +	for (i = 0; i < nr_fids; i++) {
 +		*bp++ = htonl(fids[i].vid);
 +		*bp++ = htonl(fids[i].vnode);
 +		*bp++ = htonl(fids[i].unique);
  	}
  
++<<<<<<< HEAD
 +	call->cb_break = fc->cb_break;
 +	afs_use_fs_server(call, fc->cbi);
 +	trace_afs_make_fs_call(call, &fids[0]);
 +	return afs_make_call(&fc->ac, call, GFP_NOFS, false);
++=======
+ 	trace_afs_make_fs_call(call, &vp->fid);
+ 	afs_make_op_call(op, call, GFP_NOFS);
+ }
+ 
+ /*
+  * deliver reply data to an FS.FetchACL
+  */
+ static int afs_deliver_fs_fetch_acl(struct afs_call *call)
+ {
+ 	struct afs_operation *op = call->op;
+ 	struct afs_vnode_param *vp = &op->file[0];
+ 	struct afs_acl *acl;
+ 	const __be32 *bp;
+ 	unsigned int size;
+ 	int ret;
+ 
+ 	_enter("{%u}", call->unmarshall);
+ 
+ 	switch (call->unmarshall) {
+ 	case 0:
+ 		afs_extract_to_tmp(call);
+ 		call->unmarshall++;
+ 		fallthrough;
+ 
+ 		/* extract the returned data length */
+ 	case 1:
+ 		ret = afs_extract_data(call, true);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		size = call->count2 = ntohl(call->tmp);
+ 		size = round_up(size, 4);
+ 
+ 		acl = kmalloc(struct_size(acl, data, size), GFP_KERNEL);
+ 		if (!acl)
+ 			return -ENOMEM;
+ 		op->acl = acl;
+ 		acl->size = call->count2;
+ 		afs_extract_begin(call, acl->data, size);
+ 		call->unmarshall++;
+ 		fallthrough;
+ 
+ 		/* extract the returned data */
+ 	case 2:
+ 		ret = afs_extract_data(call, true);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		afs_extract_to_buf(call, (21 + 6) * 4);
+ 		call->unmarshall++;
+ 		fallthrough;
+ 
+ 		/* extract the metadata */
+ 	case 3:
+ 		ret = afs_extract_data(call, false);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		bp = call->buffer;
+ 		xdr_decode_AFSFetchStatus(&bp, call, &vp->scb);
+ 		xdr_decode_AFSVolSync(&bp, &op->volsync);
+ 
+ 		call->unmarshall++;
+ 
+ 	case 4:
+ 		break;
+ 	}
+ 
+ 	_leave(" = 0 [done]");
+ 	return 0;
+ }
+ 
+ /*
+  * FS.FetchACL operation type
+  */
+ static const struct afs_call_type afs_RXFSFetchACL = {
+ 	.name		= "FS.FetchACL",
+ 	.op		= afs_FS_FetchACL,
+ 	.deliver	= afs_deliver_fs_fetch_acl,
+ };
+ 
+ /*
+  * Fetch the ACL for a file.
+  */
+ void afs_fs_fetch_acl(struct afs_operation *op)
+ {
+ 	struct afs_vnode_param *vp = &op->file[0];
+ 	struct afs_call *call;
+ 	__be32 *bp;
+ 
+ 	_enter(",%x,{%llx:%llu},,",
+ 	       key_serial(op->key), vp->fid.vid, vp->fid.vnode);
+ 
+ 	call = afs_alloc_flat_call(op->net, &afs_RXFSFetchACL, 16, (21 + 6) * 4);
+ 	if (!call)
+ 		return afs_op_nomem(op);
+ 
+ 	/* marshall the parameters */
+ 	bp = call->request;
+ 	bp[0] = htonl(FSFETCHACL);
+ 	bp[1] = htonl(vp->fid.vid);
+ 	bp[2] = htonl(vp->fid.vnode);
+ 	bp[3] = htonl(vp->fid.unique);
+ 
+ 	trace_afs_make_fs_call(call, &vp->fid);
+ 	afs_make_op_call(op, call, GFP_KERNEL);
+ }
+ 
+ /*
+  * FS.StoreACL operation type
+  */
+ static const struct afs_call_type afs_RXFSStoreACL = {
+ 	.name		= "FS.StoreACL",
+ 	.op		= afs_FS_StoreACL,
+ 	.deliver	= afs_deliver_fs_file_status_and_vol,
+ 	.destructor	= afs_flat_call_destructor,
+ };
+ 
+ /*
+  * Fetch the ACL for a file.
+  */
+ void afs_fs_store_acl(struct afs_operation *op)
+ {
+ 	struct afs_vnode_param *vp = &op->file[0];
+ 	struct afs_call *call;
+ 	const struct afs_acl *acl = op->acl;
+ 	size_t size;
+ 	__be32 *bp;
+ 
+ 	_enter(",%x,{%llx:%llu},,",
+ 	       key_serial(op->key), vp->fid.vid, vp->fid.vnode);
+ 
+ 	size = round_up(acl->size, 4);
+ 	call = afs_alloc_flat_call(op->net, &afs_RXFSStoreACL,
+ 				   5 * 4 + size, (21 + 6) * 4);
+ 	if (!call)
+ 		return afs_op_nomem(op);
+ 
+ 	/* marshall the parameters */
+ 	bp = call->request;
+ 	bp[0] = htonl(FSSTOREACL);
+ 	bp[1] = htonl(vp->fid.vid);
+ 	bp[2] = htonl(vp->fid.vnode);
+ 	bp[3] = htonl(vp->fid.unique);
+ 	bp[4] = htonl(acl->size);
+ 	memcpy(&bp[5], acl->data, acl->size);
+ 	if (acl->size != size)
+ 		memset((void *)&bp[5] + acl->size, 0, size - acl->size);
+ 
+ 	trace_afs_make_fs_call(call, &vp->fid);
+ 	afs_make_op_call(op, call, GFP_KERNEL);
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  }
diff --cc fs/afs/misc.c
index 700a5fa7f4ec,1d1a8debe472..000000000000
--- a/fs/afs/misc.c
+++ b/fs/afs/misc.c
@@@ -118,3 -107,64 +118,67 @@@ int afs_abort_to_error(u32 abort_code
  	default:		return -EREMOTEIO;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Select the error to report from a set of errors.
+  */
+ void afs_prioritise_error(struct afs_error *e, int error, u32 abort_code)
+ {
+ 	switch (error) {
+ 	case 0:
+ 		return;
+ 	default:
+ 		if (e->error == -ETIMEDOUT ||
+ 		    e->error == -ETIME)
+ 			return;
+ 		fallthrough;
+ 	case -ETIMEDOUT:
+ 	case -ETIME:
+ 		if (e->error == -ENOMEM ||
+ 		    e->error == -ENONET)
+ 			return;
+ 		fallthrough;
+ 	case -ENOMEM:
+ 	case -ENONET:
+ 		if (e->error == -ERFKILL)
+ 			return;
+ 		fallthrough;
+ 	case -ERFKILL:
+ 		if (e->error == -EADDRNOTAVAIL)
+ 			return;
+ 		fallthrough;
+ 	case -EADDRNOTAVAIL:
+ 		if (e->error == -ENETUNREACH)
+ 			return;
+ 		fallthrough;
+ 	case -ENETUNREACH:
+ 		if (e->error == -EHOSTUNREACH)
+ 			return;
+ 		fallthrough;
+ 	case -EHOSTUNREACH:
+ 		if (e->error == -EHOSTDOWN)
+ 			return;
+ 		fallthrough;
+ 	case -EHOSTDOWN:
+ 		if (e->error == -ECONNREFUSED)
+ 			return;
+ 		fallthrough;
+ 	case -ECONNREFUSED:
+ 		if (e->error == -ECONNRESET)
+ 			return;
+ 		fallthrough;
+ 	case -ECONNRESET: /* Responded, but call expired. */
+ 		if (e->responded)
+ 			return;
+ 		e->error = error;
+ 		return;
+ 
+ 	case -ECONNABORTED:
+ 		e->responded = true;
+ 		e->error = afs_abort_to_error(abort_code);
+ 		return;
+ 	}
+ }
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
diff --cc fs/afs/rotate.c
index 1faef56b12bd,d83f13c44b92..000000000000
--- a/fs/afs/rotate.c
+++ b/fs/afs/rotate.c
@@@ -303,12 -277,19 +303,22 @@@ bool afs_select_fileserver(struct afs_f
  			goto failed;
  		}
  
++<<<<<<< HEAD
++=======
+ 	case -ETIMEDOUT:
+ 	case -ETIME:
+ 		if (op->error != -EDESTADDRREQ)
+ 			goto iterate_address;
+ 		fallthrough;
+ 	case -ERFKILL:
+ 	case -EADDRNOTAVAIL:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case -ENETUNREACH:
  	case -EHOSTUNREACH:
 -	case -EHOSTDOWN:
  	case -ECONNREFUSED:
 +	case -ETIMEDOUT:
 +	case -ETIME:
  		_debug("no conn");
 -		op->error = error;
  		goto iterate_address;
  
  	case -ECONNRESET:
diff --cc fs/afs/rxrpc.c
index a6db33802353,8be709cb8542..000000000000
--- a/fs/afs/rxrpc.c
+++ b/fs/afs/rxrpc.c
@@@ -508,6 -565,10 +508,13 @@@ static void afs_deliver_to_call(struct 
  			rxrpc_kernel_abort_call(call->net->socket, call->rxcall,
  						abort_code, ret, "KIV");
  			goto local_abort;
++<<<<<<< HEAD
++=======
+ 		case -EIO:
+ 			pr_err("kAFS: Call %u in bad state %u\n",
+ 			       call->debug_id, state);
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case -ENODATA:
  		case -EBADMSG:
  		case -EMSGSIZE:
@@@ -607,11 -666,10 +614,18 @@@ static long afs_wait_for_call_to_comple
  	ret = ac->error;
  	switch (ret) {
  	case 0:
++<<<<<<< HEAD
 +		if (call->ret_reply0) {
 +			ret = (long)call->reply[0];
 +			call->reply[0] = NULL;
 +		}
 +		/* Fall through */
++=======
+ 		ret = call->ret0;
+ 		call->ret0 = 0;
+ 
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case -ECONNABORTED:
  		ac->responded = true;
  		break;
@@@ -841,6 -872,7 +855,10 @@@ void afs_send_empty_reply(struct afs_ca
  		_debug("oom");
  		rxrpc_kernel_abort_call(net->socket, call->rxcall,
  					RX_USER_ABORT, -ENOMEM, "KOO");
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		_leave(" [error]");
  		return;
diff --cc fs/afs/vlclient.c
index c3b740813fc7,dc9327332f06..000000000000
--- a/fs/afs/vlclient.c
+++ b/fs/afs/vlclient.c
@@@ -187,19 -185,20 +187,25 @@@ static int afs_deliver_vl_get_addrs_u(s
  	u32 uniquifier, nentries, count;
  	int i, ret;
  
 -	_enter("{%u,%zu/%u}",
 -	       call->unmarshall, iov_iter_count(call->iter), call->count);
 +	_enter("{%u,%zu/%u}", call->unmarshall, call->offset, call->count);
  
 +again:
  	switch (call->unmarshall) {
  	case 0:
 -		afs_extract_to_buf(call,
 -				   sizeof(struct afs_uuid__xdr) + 3 * sizeof(__be32));
 +		call->offset = 0;
  		call->unmarshall++;
  
++<<<<<<< HEAD
 +		/* Extract the returned uuid, uniquifier, nentries and blkaddrs size */
++=======
+ 		/* Extract the returned uuid, uniquifier, nentries and
+ 		 * blkaddrs size */
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
 -		ret = afs_extract_data(call, true);
 +		ret = afs_extract_data(call, call->buffer,
 +				       sizeof(struct afs_uuid__xdr) + 3 * sizeof(__be32),
 +				       true);
  		if (ret < 0)
  			return ret;
  
@@@ -213,18 -212,18 +219,26 @@@
  		if (!alist)
  			return -ENOMEM;
  		alist->version = uniquifier;
 -		call->ret_alist = alist;
 +		call->reply[0] = alist;
  		call->count = count;
  		call->count2 = nentries;
 +		call->offset = 0;
  		call->unmarshall++;
  
++<<<<<<< HEAD
 +		/* Extract entries */
++=======
+ 	more_entries:
+ 		count = min(call->count, 4U);
+ 		afs_extract_to_buf(call, count * sizeof(__be32));
+ 
+ 		fallthrough;	/* and extract entries */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
 -		ret = afs_extract_data(call, call->count > 4);
 +		count = min(call->count, 4U);
 +		ret = afs_extract_data(call, call->buffer,
 +				       count * sizeof(__be32),
 +				       call->count > 4);
  		if (ret < 0)
  			return ret;
  
@@@ -318,35 -316,30 +332,43 @@@ static int afs_deliver_vl_get_capabilit
  	u32 count;
  	int ret;
  
 -	_enter("{%u,%zu/%u}",
 -	       call->unmarshall, iov_iter_count(call->iter), call->count);
 +	_enter("{%u,%zu/%u}", call->unmarshall, call->offset, call->count);
  
 +again:
  	switch (call->unmarshall) {
  	case 0:
 -		afs_extract_to_tmp(call);
 +		call->offset = 0;
  		call->unmarshall++;
  
++<<<<<<< HEAD
 +		/* Extract the capabilities word count */
++=======
+ 		fallthrough;	/* and extract the capabilities word count */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
 -		ret = afs_extract_data(call, true);
 +		ret = afs_extract_data(call, &call->tmp,
 +				       1 * sizeof(__be32),
 +				       true);
  		if (ret < 0)
  			return ret;
  
  		count = ntohl(call->tmp);
 +
  		call->count = count;
  		call->count2 = count;
 -
 +		call->offset = 0;
  		call->unmarshall++;
 -		afs_extract_discard(call, count * sizeof(__be32));
  
++<<<<<<< HEAD
 +		/* Extract capabilities words */
++=======
+ 		fallthrough;	/* and extract capabilities words */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2:
 -		ret = afs_extract_data(call, false);
 +		count = min(call->count, 16U);
 +		ret = afs_extract_data(call, call->buffer,
 +				       count * sizeof(__be32),
 +				       call->count > 16);
  		if (ret < 0)
  			return ret;
  
@@@ -437,11 -436,9 +459,15 @@@ again
  		/* Extract the returned uuid, uniquifier, fsEndpoints count and
  		 * either the first fsEndpoint type or the volEndpoints
  		 * count if there are no fsEndpoints. */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:
 -		ret = afs_extract_data(call, true);
 +		ret = afs_extract_data(call, call->buffer,
 +				       sizeof(uuid_t) +
 +				       3 * sizeof(__be32),
 +				       true);
  		if (ret < 0)
  			return ret;
  
@@@ -479,7 -472,12 +505,16 @@@
  		}
  
  		size += sizeof(__be32);
++<<<<<<< HEAD
 +		ret = afs_extract_data(call, call->buffer, size, true);
++=======
+ 		afs_extract_to_buf(call, size);
+ 		call->unmarshall = 2;
+ 
+ 		fallthrough;	/* and extract fsEndpoints[] entries */
+ 	case 2:
+ 		ret = afs_extract_data(call, true);
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		if (ret < 0)
  			return ret;
  
@@@ -526,8 -526,9 +561,12 @@@
  		 * extract the type of the next endpoint when we extract the
  		 * data of the current one, but this is the first...
  		 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 3:
 -		ret = afs_extract_data(call, true);
 +		ret = afs_extract_data(call, call->buffer, sizeof(__be32), true);
  		if (ret < 0)
  			return ret;
  
@@@ -550,8 -548,13 +589,18 @@@
  		}
  
  		if (call->count > 1)
++<<<<<<< HEAD
 +			size += sizeof(__be32);
 +		ret = afs_extract_data(call, call->buffer, size, true);
++=======
+ 			size += sizeof(__be32); /* Get next type too */
+ 		afs_extract_to_buf(call, size);
+ 		call->unmarshall = 4;
+ 
+ 		fallthrough;	/* and extract volEndpoints[] entries */
+ 	case 4:
+ 		ret = afs_extract_data(call, true);
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		if (ret < 0)
  			return ret;
  
@@@ -574,19 -579,17 +623,23 @@@
  		/* Got either the type of the next entry or the count of
  		 * volEndpoints if no more fsEndpoints.
  		 */
 +		call->offset = 0;
  		call->count--;
 -		if (call->count > 0)
 -			goto next_volendpoint;
 +		if (call->count > 0) {
 +			call->count2 = ntohl(*bp++);
 +			goto again;
 +		}
  
  	end:
 -		afs_extract_discard(call, 0);
  		call->unmarshall = 5;
  
++<<<<<<< HEAD
 +		/* Done */
++=======
+ 		fallthrough;	/* Done */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 5:
 -		ret = afs_extract_data(call, false);
 +		ret = afs_extract_data(call, call->buffer, 0, false);
  		if (ret < 0)
  			return ret;
  		call->unmarshall = 6;
@@@ -646,5 -642,117 +699,121 @@@ struct afs_addr_list *afs_yfsvl_get_end
  	memcpy(bp, uuid, sizeof(*uuid)); /* Type opr_uuid */
  
  	trace_afs_make_vl_call(call);
++<<<<<<< HEAD
 +	return (struct afs_addr_list *)afs_make_call(ac, call, GFP_KERNEL, false);
++=======
+ 	afs_make_call(&vc->ac, call, GFP_KERNEL);
+ 	return (struct afs_addr_list *)afs_wait_for_call_to_complete(call, &vc->ac);
+ }
+ 
+ /*
+  * Deliver reply data to a YFSVL.GetCellName operation.
+  */
+ static int afs_deliver_yfsvl_get_cell_name(struct afs_call *call)
+ {
+ 	char *cell_name;
+ 	u32 namesz, paddedsz;
+ 	int ret;
+ 
+ 	_enter("{%u,%zu/%u}",
+ 	       call->unmarshall, iov_iter_count(call->iter), call->count);
+ 
+ 	switch (call->unmarshall) {
+ 	case 0:
+ 		afs_extract_to_tmp(call);
+ 		call->unmarshall++;
+ 
+ 		fallthrough;	/* and extract the cell name length */
+ 	case 1:
+ 		ret = afs_extract_data(call, true);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		namesz = ntohl(call->tmp);
+ 		if (namesz > AFS_MAXCELLNAME)
+ 			return afs_protocol_error(call, afs_eproto_cellname_len);
+ 		paddedsz = (namesz + 3) & ~3;
+ 		call->count = namesz;
+ 		call->count2 = paddedsz - namesz;
+ 
+ 		cell_name = kmalloc(namesz + 1, GFP_KERNEL);
+ 		if (!cell_name)
+ 			return -ENOMEM;
+ 		cell_name[namesz] = 0;
+ 		call->ret_str = cell_name;
+ 
+ 		afs_extract_begin(call, cell_name, namesz);
+ 		call->unmarshall++;
+ 
+ 		fallthrough;	/* and extract cell name */
+ 	case 2:
+ 		ret = afs_extract_data(call, true);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		afs_extract_discard(call, call->count2);
+ 		call->unmarshall++;
+ 
+ 		fallthrough;	/* and extract padding */
+ 	case 3:
+ 		ret = afs_extract_data(call, false);
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		call->unmarshall++;
+ 		break;
+ 	}
+ 
+ 	_leave(" = 0 [done]");
+ 	return 0;
+ }
+ 
+ static void afs_destroy_yfsvl_get_cell_name(struct afs_call *call)
+ {
+ 	kfree(call->ret_str);
+ 	afs_flat_call_destructor(call);
+ }
+ 
+ /*
+  * VL.GetCapabilities operation type
+  */
+ static const struct afs_call_type afs_YFSVLGetCellName = {
+ 	.name		= "YFSVL.GetCellName",
+ 	.op		= afs_YFSVL_GetCellName,
+ 	.deliver	= afs_deliver_yfsvl_get_cell_name,
+ 	.destructor	= afs_destroy_yfsvl_get_cell_name,
+ };
+ 
+ /*
+  * Probe a volume server for the capabilities that it supports.  This can
+  * return up to 196 words.
+  *
+  * We use this to probe for service upgrade to determine what the server at the
+  * other end supports.
+  */
+ char *afs_yfsvl_get_cell_name(struct afs_vl_cursor *vc)
+ {
+ 	struct afs_call *call;
+ 	struct afs_net *net = vc->cell->net;
+ 	__be32 *bp;
+ 
+ 	_enter("");
+ 
+ 	call = afs_alloc_flat_call(net, &afs_YFSVLGetCellName, 1 * 4, 0);
+ 	if (!call)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	call->key = vc->key;
+ 	call->ret_str = NULL;
+ 	call->max_lifespan = AFS_VL_MAX_LIFESPAN;
+ 
+ 	/* marshall the parameters */
+ 	bp = call->request;
+ 	*bp++ = htonl(YVLGETCELLNAME);
+ 
+ 	/* Can't take a ref on server */
+ 	trace_afs_make_vl_call(call);
+ 	afs_make_call(&vc->ac, call, GFP_KERNEL);
+ 	return (char *)afs_wait_for_call_to_complete(call, &vc->ac);
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  }
diff --cc fs/ext2/inode.c
index 6189c2b96c04,415c21f0e750..000000000000
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@@ -1239,6 -1241,7 +1239,10 @@@ do_indirects
  				mark_inode_dirty(inode);
  				ext2_free_branches(inode, &nr, &nr+1, 1);
  			}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case EXT2_IND_BLOCK:
  			nr = i_data[EXT2_DIND_BLOCK];
  			if (nr) {
@@@ -1246,6 -1249,7 +1250,10 @@@
  				mark_inode_dirty(inode);
  				ext2_free_branches(inode, &nr, &nr+1, 2);
  			}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case EXT2_DIND_BLOCK:
  			nr = i_data[EXT2_TIND_BLOCK];
  			if (nr) {
diff --cc fs/f2fs/f2fs.h
index 0ccb40fea1f2,d9e52a7f3702..000000000000
--- a/fs/f2fs/f2fs.h
+++ b/fs/f2fs/f2fs.h
@@@ -2264,6 -2646,7 +2264,10 @@@ static inline void __mark_inode_dirty_f
  	case FI_NEW_INODE:
  		if (set)
  			return;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case FI_DATA_EXIST:
  	case FI_INLINE_DOTS:
  	case FI_PIN_FILE:
diff --cc fs/fcntl.c
index 6c5cb899957b,19ac5baad50f..000000000000
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@@ -769,7 -770,8 +769,12 @@@ static void send_sigio_to_task(struct t
  			si.si_fd    = fd;
  			if (!do_send_sig_info(signum, &si, p, type))
  				break;
++<<<<<<< HEAD
 +		/* fall-through - fall back on the old plain SIGIO signal */
++=======
+ 		}
+ 			fallthrough;	/* fall back on the old plain SIGIO signal */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 0:
  			do_send_sig_info(SIGIO, SEND_SIG_PRIV, p, type);
  	}
diff --cc fs/ubifs/lprops.c
index f5a46844340c,6d6cd85c2b4c..000000000000
--- a/fs/ubifs/lprops.c
+++ b/fs/ubifs/lprops.c
@@@ -324,8 -312,8 +324,13 @@@ static void ubifs_remove_from_cat(struc
  		break;
  	case LPROPS_FREEABLE:
  		c->freeable_cnt -= 1;
++<<<<<<< HEAD
 +		ubifs_assert(c->freeable_cnt >= 0);
 +		/* Fall through */
++=======
+ 		ubifs_assert(c, c->freeable_cnt >= 0);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case LPROPS_UNCAT:
  	case LPROPS_EMPTY:
  	case LPROPS_FRDI_IDX:
diff --cc include/linux/compat.h
index 540c6aeef3fb,b354ce58966e..000000000000
--- a/include/linux/compat.h
+++ b/include/linux/compat.h
@@@ -501,8 -429,11 +501,16 @@@ put_compat_sigset(compat_sigset_t __use
  	compat_sigset_t v;
  	switch (_NSIG_WORDS) {
  	case 4: v.sig[7] = (set->sig[3] >> 32); v.sig[6] = set->sig[3];
++<<<<<<< HEAD
 +	case 3: v.sig[5] = (set->sig[2] >> 32); v.sig[4] = set->sig[2];
 +	case 2: v.sig[3] = (set->sig[1] >> 32); v.sig[2] = set->sig[1];
++=======
+ 		fallthrough;
+ 	case 3: v.sig[5] = (set->sig[2] >> 32); v.sig[4] = set->sig[2];
+ 		fallthrough;
+ 	case 2: v.sig[3] = (set->sig[1] >> 32); v.sig[2] = set->sig[1];
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1: v.sig[1] = (set->sig[0] >> 32); v.sig[0] = set->sig[0];
  	}
  	return copy_to_user(compat, &v, size) ? -EFAULT : 0;
diff --cc include/linux/mm.h
index a3f718758f21,97c83773b6f0..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -113,10 -134,48 +113,51 @@@ extern int mmap_rnd_compat_bits __read_
  
  /*
   * On some architectures it is expensive to call memset() for small sizes.
 - * If an architecture decides to implement their own version of
 - * mm_zero_struct_page they should wrap the defines below in a #ifndef and
 - * define their own version of this macro in <asm/pgtable.h>
 + * Those architectures should provide their own implementation of "struct page"
 + * zeroing by defining this macro in <asm/pgtable.h>.
   */
++<<<<<<< HEAD
 +#ifndef mm_zero_struct_page
++=======
+ #if BITS_PER_LONG == 64
+ /* This function must be updated when the size of struct page grows above 80
+  * or reduces below 56. The idea that compiler optimizes out switch()
+  * statement, and only leaves move/store instructions. Also the compiler can
+  * combine write statments if they are both assignments and can be reordered,
+  * this can result in several of the writes here being dropped.
+  */
+ #define	mm_zero_struct_page(pp) __mm_zero_struct_page(pp)
+ static inline void __mm_zero_struct_page(struct page *page)
+ {
+ 	unsigned long *_pp = (void *)page;
+ 
+ 	 /* Check that struct page is either 56, 64, 72, or 80 bytes */
+ 	BUILD_BUG_ON(sizeof(struct page) & 7);
+ 	BUILD_BUG_ON(sizeof(struct page) < 56);
+ 	BUILD_BUG_ON(sizeof(struct page) > 80);
+ 
+ 	switch (sizeof(struct page)) {
+ 	case 80:
+ 		_pp[9] = 0;
+ 		fallthrough;
+ 	case 72:
+ 		_pp[8] = 0;
+ 		fallthrough;
+ 	case 64:
+ 		_pp[7] = 0;
+ 		fallthrough;
+ 	case 56:
+ 		_pp[6] = 0;
+ 		_pp[5] = 0;
+ 		_pp[4] = 0;
+ 		_pp[3] = 0;
+ 		_pp[2] = 0;
+ 		_pp[1] = 0;
+ 		_pp[0] = 0;
+ 	}
+ }
+ #else
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  #define mm_zero_struct_page(pp)  ((void)memset((pp), 0, sizeof(struct page)))
  #endif
  
diff --cc include/linux/signal.h
index 008b49e545a8,7bbc0e9cf084..000000000000
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@@ -129,9 -137,11 +129,17 @@@ static inline void name(sigset_t *r, co
  		b3 = b->sig[3]; b2 = b->sig[2];				\
  		r->sig[3] = op(a3, b3);					\
  		r->sig[2] = op(a2, b2);					\
++<<<<<<< HEAD
 +	case 2:								\
 +		a1 = a->sig[1]; b1 = b->sig[1];				\
 +		r->sig[1] = op(a1, b1);					\
++=======
+ 		fallthrough;						\
+ 	case 2:								\
+ 		a1 = a->sig[1]; b1 = b->sig[1];				\
+ 		r->sig[1] = op(a1, b1);					\
+ 		fallthrough;						\
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:								\
  		a0 = a->sig[0]; b0 = b->sig[0];				\
  		r->sig[0] = op(a0, b0);					\
@@@ -161,7 -171,9 +169,13 @@@ static inline void name(sigset_t *set
  	switch (_NSIG_WORDS) {						\
  	case 4:	set->sig[3] = op(set->sig[3]);				\
  		set->sig[2] = op(set->sig[2]);				\
++<<<<<<< HEAD
++	case 2:	set->sig[1] = op(set->sig[1]);				\
++=======
+ 		fallthrough;						\
  	case 2:	set->sig[1] = op(set->sig[1]);				\
+ 		fallthrough;						\
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:	set->sig[0] = op(set->sig[0]);				\
  		    break;						\
  	default:							\
@@@ -182,6 -194,7 +196,10 @@@ static inline void sigemptyset(sigset_
  		memset(set, 0, sizeof(sigset_t));
  		break;
  	case 2: set->sig[1] = 0;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:	set->sig[0] = 0;
  		break;
  	}
@@@ -194,6 -207,7 +212,10 @@@ static inline void sigfillset(sigset_t 
  		memset(set, -1, sizeof(sigset_t));
  		break;
  	case 2: set->sig[1] = -1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1:	set->sig[0] = -1;
  		break;
  	}
diff --cc include/linux/skbuff.h
index 071cbf0b1251,ab57cf787c1f..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3794,13 -3745,19 +3794,29 @@@ static inline bool __skb_metadata_diffe
  #define __it(x, op) (x -= sizeof(u##op))
  #define __it_diff(a, b, op) (*(u##op *)__it(a, op)) ^ (*(u##op *)__it(b, op))
  	case 32: diffs |= __it_diff(a, b, 64);
++<<<<<<< HEAD
 +	case 24: diffs |= __it_diff(a, b, 64);
 +	case 16: diffs |= __it_diff(a, b, 64);
 +	case  8: diffs |= __it_diff(a, b, 64);
 +		break;
 +	case 28: diffs |= __it_diff(a, b, 64);
 +	case 20: diffs |= __it_diff(a, b, 64);
 +	case 12: diffs |= __it_diff(a, b, 64);
++=======
+ 		fallthrough;
+ 	case 24: diffs |= __it_diff(a, b, 64);
+ 		fallthrough;
+ 	case 16: diffs |= __it_diff(a, b, 64);
+ 		fallthrough;
+ 	case  8: diffs |= __it_diff(a, b, 64);
+ 		break;
+ 	case 28: diffs |= __it_diff(a, b, 64);
+ 		fallthrough;
+ 	case 20: diffs |= __it_diff(a, b, 64);
+ 		fallthrough;
+ 	case 12: diffs |= __it_diff(a, b, 64);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case  4: diffs |= __it_diff(a, b, 32);
  		break;
  	}
diff --cc include/math-emu/op-common.h
index 6bdf8c61d221,143568d64b20..000000000000
--- a/include/math-emu/op-common.h
+++ b/include/math-emu/op-common.h
@@@ -308,6 -308,7 +308,10 @@@ do {									     
  									     \
    case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):			     \
      R##_e = X##_e;							     \
++<<<<<<< HEAD
++=======
+ 	fallthrough;							     \
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
    case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):			     \
    case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):				     \
    case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):				     \
@@@ -318,6 -319,7 +322,10 @@@
  									     \
    case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):			     \
      R##_e = Y##_e;							     \
++<<<<<<< HEAD
++=======
+ 	fallthrough;							     \
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
    case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):			     \
    case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):				     \
    case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):				     \
@@@ -415,6 -417,7 +423,10 @@@ do {							
    case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):		\
    case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):		\
      R##_s = X##_s;					\
++<<<<<<< HEAD
++=======
+ 	  fallthrough;					\
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  							\
    case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):		\
    case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):	\
@@@ -428,6 -431,7 +440,10 @@@
    case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):		\
    case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):		\
      R##_s = Y##_s;					\
++<<<<<<< HEAD
++=======
+ 	  fallthrough;					\
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  							\
    case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):	\
    case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):	\
@@@ -493,6 -497,7 +509,10 @@@ do {							
  							\
    case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):	\
      FP_SET_EXCEPTION(FP_EX_DIVZERO);			\
++<<<<<<< HEAD
++=======
+ 	fallthrough;					\
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
    case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):		\
    case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):	\
      R##_c = FP_CLS_INF;					\
diff --cc ipc/sem.c
index 2bf535dd0b93,f6c30a85dadf..000000000000
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@@ -1682,6 -1691,7 +1682,10 @@@ long ksys_semctl(int semid, int semnum
  	case IPC_SET:
  		if (copy_semid_from_user(&semid64, p, version))
  			return -EFAULT;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IPC_RMID:
  		return semctl_down(ns, semid, cmd, &semid64);
  	default:
diff --cc kernel/bpf/cpumap.c
index ec4dcf8c3eef,6386b7bb98f2..000000000000
--- a/kernel/bpf/cpumap.c
+++ b/kernel/bpf/cpumap.c
@@@ -220,6 -228,75 +220,78 @@@ static void put_cpu_map_entry(struct bp
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int cpu_map_bpf_prog_run_xdp(struct bpf_cpu_map_entry *rcpu,
+ 				    void **frames, int n,
+ 				    struct xdp_cpumap_stats *stats)
+ {
+ 	struct xdp_rxq_info rxq;
+ 	struct xdp_buff xdp;
+ 	int i, nframes = 0;
+ 
+ 	if (!rcpu->prog)
+ 		return n;
+ 
+ 	rcu_read_lock_bh();
+ 
+ 	xdp_set_return_frame_no_direct();
+ 	xdp.rxq = &rxq;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		struct xdp_frame *xdpf = frames[i];
+ 		u32 act;
+ 		int err;
+ 
+ 		rxq.dev = xdpf->dev_rx;
+ 		rxq.mem = xdpf->mem;
+ 		/* TODO: report queue_index to xdp_rxq_info */
+ 
+ 		xdp_convert_frame_to_buff(xdpf, &xdp);
+ 
+ 		act = bpf_prog_run_xdp(rcpu->prog, &xdp);
+ 		switch (act) {
+ 		case XDP_PASS:
+ 			err = xdp_update_frame_from_buff(&xdp, xdpf);
+ 			if (err < 0) {
+ 				xdp_return_frame(xdpf);
+ 				stats->drop++;
+ 			} else {
+ 				frames[nframes++] = xdpf;
+ 				stats->pass++;
+ 			}
+ 			break;
+ 		case XDP_REDIRECT:
+ 			err = xdp_do_redirect(xdpf->dev_rx, &xdp,
+ 					      rcpu->prog);
+ 			if (unlikely(err)) {
+ 				xdp_return_frame(xdpf);
+ 				stats->drop++;
+ 			} else {
+ 				stats->redirect++;
+ 			}
+ 			break;
+ 		default:
+ 			bpf_warn_invalid_xdp_action(act);
+ 			fallthrough;
+ 		case XDP_DROP:
+ 			xdp_return_frame(xdpf);
+ 			stats->drop++;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (stats->redirect)
+ 		xdp_do_flush_map();
+ 
+ 	xdp_clear_return_frame_no_direct();
+ 
+ 	rcu_read_unlock_bh(); /* resched point, may call do_softirq() */
+ 
+ 	return nframes;
+ }
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  #define CPUMAP_BATCH 8
  
  static int cpu_map_kthread_run(void *data)
diff --cc kernel/capability.c
index 7718d7dcadc7,7c59b096c98a..000000000000
--- a/kernel/capability.c
+++ b/kernel/capability.c
@@@ -93,9 -93,7 +93,13 @@@ static int cap_validate_magic(cap_user_
  		break;
  	case _LINUX_CAPABILITY_VERSION_2:
  		warn_deprecated_v2();
++<<<<<<< HEAD
 +		/*
 +		 * fall through - v3 is otherwise equivalent to v2.
 +		 */
++=======
+ 		fallthrough;	/* v3 is otherwise equivalent to v2 */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case _LINUX_CAPABILITY_VERSION_3:
  		*tocopy = _LINUX_CAPABILITY_U32S_3;
  		break;
diff --cc kernel/compat.c
index 22f829a589ba,05adfd6fa8bf..000000000000
--- a/kernel/compat.c
+++ b/kernel/compat.c
@@@ -439,8 -255,11 +439,16 @@@ get_compat_sigset(sigset_t *set, const 
  		return -EFAULT;
  	switch (_NSIG_WORDS) {
  	case 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );
++<<<<<<< HEAD
 +	case 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );
 +	case 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );
++=======
+ 		fallthrough;
+ 	case 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );
+ 		fallthrough;
+ 	case 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );
  	}
  #else
diff --cc kernel/debug/gdbstub.c
index 7510dc687c0d,cc3c43dfec44..000000000000
--- a/kernel/debug/gdbstub.c
+++ b/kernel/debug/gdbstub.c
@@@ -1033,13 -1046,14 +1033,21 @@@ int gdb_serial_stub(struct kgdb_state *
  				return DBG_PASS_EVENT;
  			}
  #endif
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 'C': /* Exception passing */
  			tmp = gdb_cmd_exception_pass(ks);
  			if (tmp > 0)
  				goto default_handle;
  			if (tmp == 0)
  				break;
++<<<<<<< HEAD
 +			/* Fall through on tmp < 0 */
++=======
+ 			fallthrough;	/* on tmp < 0 */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 'c': /* Continue packet */
  		case 's': /* Single step packet */
  			if (kgdb_contthread && kgdb_contthread != current) {
@@@ -1048,7 -1062,7 +1056,11 @@@
  				break;
  			}
  			dbg_activate_sw_breakpoints();
++<<<<<<< HEAD
 +			/* Fall through to default processing */
++=======
+ 			fallthrough;	/* to default processing */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  default_handle:
  			error = kgdb_arch_handle_exception(ks->ex_vector,
diff --cc kernel/debug/kdb/kdb_keyboard.c
index 118527aa60ea,f877a0a0d7cf..000000000000
--- a/kernel/debug/kdb/kdb_keyboard.c
+++ b/kernel/debug/kdb/kdb_keyboard.c
@@@ -173,11 -173,11 +173,19 @@@ int kdb_get_kbd_char(void
  	case KT_LATIN:
  		if (isprint(keychar))
  			break;		/* printable characters */
++<<<<<<< HEAD
 +		/* drop through */
 +	case KT_SPEC:
 +		if (keychar == K_ENTER)
 +			break;
 +		/* drop through */
++=======
+ 		fallthrough;
+ 	case KT_SPEC:
+ 		if (keychar == K_ENTER)
+ 			break;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return -1;	/* ignore unprintables */
  	}
diff --cc kernel/debug/kdb/kdb_support.c
index b14b0925c184,6226502ce049..000000000000
--- a/kernel/debug/kdb/kdb_support.c
+++ b/kernel/debug/kdb/kdb_support.c
@@@ -432,7 -432,7 +432,11 @@@ int kdb_getphysword(unsigned long *word
  				*word = w8;
  			break;
  		}
++<<<<<<< HEAD
 +		/* drop through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		diag = KDB_BADWIDTH;
  		kdb_printf("kdb_getphysword: bad width %ld\n", (long) size);
@@@ -481,7 -481,7 +485,11 @@@ int kdb_getword(unsigned long *word, un
  				*word = w8;
  			break;
  		}
++<<<<<<< HEAD
 +		/* drop through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		diag = KDB_BADWIDTH;
  		kdb_printf("kdb_getword: bad width %ld\n", (long) size);
@@@ -525,7 -525,7 +533,11 @@@ int kdb_putword(unsigned long addr, uns
  			diag = kdb_putarea(addr, w8);
  			break;
  		}
++<<<<<<< HEAD
 +		/* drop through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		diag = KDB_BADWIDTH;
  		kdb_printf("kdb_putword: bad width %ld\n", (long) size);
diff --cc kernel/irq/handle.c
index 664e25b0596d,762a928e18f9..000000000000
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@@ -173,7 -173,7 +173,11 @@@ irqreturn_t __handle_irq_event_percpu(s
  
  			__irq_wake_thread(desc, action);
  
++<<<<<<< HEAD
 +			/* Fall through to add to randomness */
++=======
+ 			fallthrough;	/* to add to randomness */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case IRQ_HANDLED:
  			*flags |= action->flags;
  			break;
diff --cc kernel/irq/manage.c
index 27dd6c249c6a,5df903fccb60..000000000000
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@@ -261,6 -271,7 +261,10 @@@ int irq_do_set_affinity(struct irq_dat
  	case IRQ_SET_MASK_OK:
  	case IRQ_SET_MASK_OK_DONE:
  		cpumask_copy(desc->irq_common_data.affinity, mask);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case IRQ_SET_MASK_OK_NOCOPY:
  		irq_validate_effective_affinity(data);
  		irq_set_thread_affinity(desc);
@@@ -825,6 -868,7 +829,10 @@@ int __irq_set_trigger(struct irq_desc *
  	case IRQ_SET_MASK_OK_DONE:
  		irqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);
  		irqd_set(&desc->irq_data, flags);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case IRQ_SET_MASK_OK_NOCOPY:
  		flags = irqd_get_trigger_type(&desc->irq_data);
diff --cc kernel/power/hibernate.c
index d675d1527fc2,e7aa57fb2fdc..000000000000
--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@@ -638,6 -659,7 +638,10 @@@ static void power_down(void
  		break;
  	case HIBERNATION_PLATFORM:
  		hibernation_platform_enter();
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case HIBERNATION_SHUTDOWN:
  		if (pm_power_off)
  			kernel_power_off();
diff --cc kernel/signal.c
index 177cd7f04acb,a38b3edc6851..000000000000
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@@ -843,6 -851,7 +843,10 @@@ static int check_kill_permission(int si
  			 */
  			if (!sid || sid == task_session(current))
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		default:
  			return -EPERM;
  		}
diff --cc kernel/sys.c
index f45ac31ff96d,ab6c409b1159..000000000000
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@@ -1745,6 -1753,7 +1745,10 @@@ void getrusage(struct task_struct *p, i
  
  		if (who == RUSAGE_CHILDREN)
  			break;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case RUSAGE_SELF:
  		thread_group_cputime_adjusted(p, &tgutime, &tgstime);
diff --cc kernel/time/hrtimer.c
index 62e59ad72cb1,95b6a708b040..000000000000
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@@ -387,7 -377,7 +387,11 @@@ static bool hrtimer_fixup_activate(voi
  	switch (state) {
  	case ODEBUG_STATE_ACTIVE:
  		WARN_ON(1);
++<<<<<<< HEAD
 +
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return false;
  	}
diff --cc kernel/time/tick-broadcast.c
index a8fb6832a61d,36d7464c8962..000000000000
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@@ -385,6 -381,7 +385,10 @@@ void tick_broadcast_control(enum tick_b
  	switch (mode) {
  	case TICK_BROADCAST_FORCE:
  		tick_broadcast_forced = 1;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case TICK_BROADCAST_ON:
  		cpumask_set_cpu(cpu, tick_broadcast_on);
  		if (!cpumask_test_and_set_cpu(cpu, tick_broadcast_mask)) {
diff --cc kernel/time/timer.c
index 844aee6c9661,a50364df1054..000000000000
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@@ -666,7 -666,7 +666,11 @@@ static bool timer_fixup_activate(void *
  
  	case ODEBUG_STATE_ACTIVE:
  		WARN_ON(1);
++<<<<<<< HEAD
 +
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		return false;
  	}
diff --cc kernel/trace/trace_events_filter.c
index 4649bff3e8a4,78a678eeb140..000000000000
--- a/kernel/trace/trace_events_filter.c
+++ b/kernel/trace/trace_events_filter.c
@@@ -510,6 -499,7 +510,10 @@@ predicate_parse(const char *str, int nr
  					ptr++;
  					break;
  				}
++<<<<<<< HEAD
++=======
+ 				fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			default:
  				parse_error(pe, FILT_ERR_TOO_MANY_PREDS,
  					    next - str);
diff --cc lib/asn1_decoder.c
index dc14beae2c9a,13da529e2e72..000000000000
--- a/lib/asn1_decoder.c
+++ b/lib/asn1_decoder.c
@@@ -385,6 -381,8 +385,11 @@@ next_op
  	case ASN1_OP_END_SET_ACT:
  		if (unlikely(!(flags & FLAG_MATCHED)))
  			goto tag_mismatch;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ASN1_OP_END_SEQ:
  	case ASN1_OP_END_SET_OF:
  	case ASN1_OP_END_SEQ_OF:
@@@ -450,6 -448,8 +455,11 @@@
  			pc += asn1_op_lengths[op];
  			goto next_op;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case ASN1_OP_ACT:
  		ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
  		if (ret < 0)
diff --cc lib/assoc_array.c
index c6659cb37033,04c98799c3ba..000000000000
--- a/lib/assoc_array.c
+++ b/lib/assoc_array.c
@@@ -1115,6 -1113,7 +1115,10 @@@ struct assoc_array_edit *assoc_array_de
  						index_key))
  				goto found_leaf;
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case assoc_array_walk_tree_empty:
  	case assoc_array_walk_found_wrong_shortcut:
  	default:
diff --cc lib/cmdline.c
index 171c19b6888e,55768b4f3f58..000000000000
--- a/lib/cmdline.c
+++ b/lib/cmdline.c
@@@ -135,18 -132,23 +135,38 @@@ unsigned long long memparse(const char 
  	case 'E':
  	case 'e':
  		ret <<= 10;
++<<<<<<< HEAD
 +	case 'P':
 +	case 'p':
 +		ret <<= 10;
 +	case 'T':
 +	case 't':
 +		ret <<= 10;
 +	case 'G':
 +	case 'g':
 +		ret <<= 10;
 +	case 'M':
 +	case 'm':
 +		ret <<= 10;
++=======
+ 		fallthrough;
+ 	case 'P':
+ 	case 'p':
+ 		ret <<= 10;
+ 		fallthrough;
+ 	case 'T':
+ 	case 't':
+ 		ret <<= 10;
+ 		fallthrough;
+ 	case 'G':
+ 	case 'g':
+ 		ret <<= 10;
+ 		fallthrough;
+ 	case 'M':
+ 	case 'm':
+ 		ret <<= 10;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 'K':
  	case 'k':
  		ret <<= 10;
diff --cc lib/siphash.c
index 3ae58b4edad6,a90112ee72a1..000000000000
--- a/lib/siphash.c
+++ b/lib/siphash.c
@@@ -68,11 -68,11 +68,19 @@@ u64 __siphash_aligned(const void *data
  						  bytemask_from_count(left)));
  #else
  	switch (left) {
++<<<<<<< HEAD
 +	case 7: b |= ((u64)end[6]) << 48;
 +	case 6: b |= ((u64)end[5]) << 40;
 +	case 5: b |= ((u64)end[4]) << 32;
 +	case 4: b |= le32_to_cpup(data); break;
 +	case 3: b |= ((u64)end[2]) << 16;
++=======
+ 	case 7: b |= ((u64)end[6]) << 48; fallthrough;
+ 	case 6: b |= ((u64)end[5]) << 40; fallthrough;
+ 	case 5: b |= ((u64)end[4]) << 32; fallthrough;
+ 	case 4: b |= le32_to_cpup(data); break;
+ 	case 3: b |= ((u64)end[2]) << 16; fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2: b |= le16_to_cpup(data); break;
  	case 1: b |= end[0];
  	}
@@@ -101,11 -101,11 +109,19 @@@ u64 __siphash_unaligned(const void *dat
  						  bytemask_from_count(left)));
  #else
  	switch (left) {
++<<<<<<< HEAD
 +	case 7: b |= ((u64)end[6]) << 48;
 +	case 6: b |= ((u64)end[5]) << 40;
 +	case 5: b |= ((u64)end[4]) << 32;
 +	case 4: b |= get_unaligned_le32(end); break;
 +	case 3: b |= ((u64)end[2]) << 16;
++=======
+ 	case 7: b |= ((u64)end[6]) << 48; fallthrough;
+ 	case 6: b |= ((u64)end[5]) << 40; fallthrough;
+ 	case 5: b |= ((u64)end[4]) << 32; fallthrough;
+ 	case 4: b |= get_unaligned_le32(end); break;
+ 	case 3: b |= ((u64)end[2]) << 16; fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2: b |= get_unaligned_le16(end); break;
  	case 1: b |= end[0];
  	}
@@@ -268,11 -268,11 +284,19 @@@ u32 __hsiphash_aligned(const void *data
  						  bytemask_from_count(left)));
  #else
  	switch (left) {
++<<<<<<< HEAD
 +	case 7: b |= ((u64)end[6]) << 48;
 +	case 6: b |= ((u64)end[5]) << 40;
 +	case 5: b |= ((u64)end[4]) << 32;
 +	case 4: b |= le32_to_cpup(data); break;
 +	case 3: b |= ((u64)end[2]) << 16;
++=======
+ 	case 7: b |= ((u64)end[6]) << 48; fallthrough;
+ 	case 6: b |= ((u64)end[5]) << 40; fallthrough;
+ 	case 5: b |= ((u64)end[4]) << 32; fallthrough;
+ 	case 4: b |= le32_to_cpup(data); break;
+ 	case 3: b |= ((u64)end[2]) << 16; fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2: b |= le16_to_cpup(data); break;
  	case 1: b |= end[0];
  	}
@@@ -301,11 -301,11 +325,19 @@@ u32 __hsiphash_unaligned(const void *da
  						  bytemask_from_count(left)));
  #else
  	switch (left) {
++<<<<<<< HEAD
 +	case 7: b |= ((u64)end[6]) << 48;
 +	case 6: b |= ((u64)end[5]) << 40;
 +	case 5: b |= ((u64)end[4]) << 32;
 +	case 4: b |= get_unaligned_le32(end); break;
 +	case 3: b |= ((u64)end[2]) << 16;
++=======
+ 	case 7: b |= ((u64)end[6]) << 48; fallthrough;
+ 	case 6: b |= ((u64)end[5]) << 40; fallthrough;
+ 	case 5: b |= ((u64)end[4]) << 32; fallthrough;
+ 	case 4: b |= get_unaligned_le32(end); break;
+ 	case 3: b |= ((u64)end[2]) << 16; fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2: b |= get_unaligned_le16(end); break;
  	case 1: b |= end[0];
  	}
@@@ -431,7 -431,7 +463,11 @@@ u32 __hsiphash_aligned(const void *data
  		v0 ^= m;
  	}
  	switch (left) {
++<<<<<<< HEAD
 +	case 3: b |= ((u32)end[2]) << 16;
++=======
+ 	case 3: b |= ((u32)end[2]) << 16; fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2: b |= le16_to_cpup(data); break;
  	case 1: b |= end[0];
  	}
@@@ -454,7 -454,7 +490,11 @@@ u32 __hsiphash_unaligned(const void *da
  		v0 ^= m;
  	}
  	switch (left) {
++<<<<<<< HEAD
 +	case 3: b |= ((u32)end[2]) << 16;
++=======
+ 	case 3: b |= ((u32)end[2]) << 16; fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 2: b |= get_unaligned_le16(end); break;
  	case 1: b |= end[0];
  	}
diff --cc lib/zstd/bitstream.h
index a826b99e1d63,7c65c66e41fd..000000000000
--- a/lib/zstd/bitstream.h
+++ b/lib/zstd/bitstream.h
@@@ -259,10 -259,15 +259,22 @@@ ZSTD_STATIC size_t BIT_initDStream(BIT_
  		bitD->bitContainer = *(const BYTE *)(bitD->start);
  		switch (srcSize) {
  		case 7: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[6]) << (sizeof(bitD->bitContainer) * 8 - 16);
++<<<<<<< HEAD
 +		case 6: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[5]) << (sizeof(bitD->bitContainer) * 8 - 24);
 +		case 5: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[4]) << (sizeof(bitD->bitContainer) * 8 - 32);
 +		case 4: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[3]) << 24;
 +		case 3: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[2]) << 16;
++=======
+ 			fallthrough;
+ 		case 6: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[5]) << (sizeof(bitD->bitContainer) * 8 - 24);
+ 			fallthrough;
+ 		case 5: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[4]) << (sizeof(bitD->bitContainer) * 8 - 32);
+ 			fallthrough;
+ 		case 4: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[3]) << 24;
+ 			fallthrough;
+ 		case 3: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[2]) << 16;
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case 2: bitD->bitContainer += (size_t)(((const BYTE *)(srcBuffer))[1]) << 8;
  		default:;
  		}
diff --cc lib/zstd/compress.c
index f9166cf4f7a9,b080264ed3ad..000000000000
--- a/lib/zstd/compress.c
+++ b/lib/zstd/compress.c
@@@ -3182,6 -3182,7 +3182,10 @@@ static size_t ZSTD_compressStream_gener
  				zcs->outBuffFlushedSize = 0;
  				zcs->stage = zcss_flush; /* pass-through to flush stage */
  			}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case zcss_flush: {
  			size_t const toFlush = zcs->outBuffContentSize - zcs->outBuffFlushedSize;
diff --cc lib/zstd/decompress.c
index b17846725ca0,66cd487a326a..000000000000
--- a/lib/zstd/decompress.c
+++ b/lib/zstd/decompress.c
@@@ -1768,6 -1768,7 +1768,10 @@@ size_t ZSTD_decompressContinue(ZSTD_DCt
  			return 0;
  		}
  		dctx->expected = 0; /* not necessary to copy more */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case ZSTDds_decodeFrameHeader:
  		memcpy(dctx->headerBuffer + ZSTD_frameHeaderSize_prefix, src, dctx->expected);
@@@ -2375,7 -2376,7 +2379,11 @@@ size_t ZSTD_decompressStream(ZSTD_DStre
  			}
  			zds->stage = zdss_read;
  		}
++<<<<<<< HEAD
 +		/* pass-through */
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case zdss_read: {
  			size_t const neededInSize = ZSTD_nextSrcSizeToDecompress(zds->dctx);
@@@ -2404,6 -2405,7 +2412,10 @@@
  			zds->stage = zdss_load;
  			/* pass-through */
  		}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case zdss_load: {
  			size_t const neededInSize = ZSTD_nextSrcSizeToDecompress(zds->dctx);
@@@ -2436,6 -2438,7 +2448,10 @@@
  				/* pass-through */
  			}
  		}
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  		case zdss_flush: {
  			size_t const toFlushSize = zds->outEnd - zds->outStart;
diff --cc lib/zstd/huf_compress.c
index 40055a7016e6,08b4ae80aed4..000000000000
--- a/lib/zstd/huf_compress.c
+++ b/lib/zstd/huf_compress.c
@@@ -556,7 -556,9 +556,13 @@@ size_t HUF_compress1X_usingCTable(void 
  	n = srcSize & ~3; /* join to mod 4 */
  	switch (srcSize & 3) {
  	case 3: HUF_encodeSymbol(&bitC, ip[n + 2], CTable); HUF_FLUSHBITS_2(&bitC);
++<<<<<<< HEAD
 +	case 2: HUF_encodeSymbol(&bitC, ip[n + 1], CTable); HUF_FLUSHBITS_1(&bitC);
++=======
+ 		fallthrough;
+ 	case 2: HUF_encodeSymbol(&bitC, ip[n + 1], CTable); HUF_FLUSHBITS_1(&bitC);
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 1: HUF_encodeSymbol(&bitC, ip[n + 0], CTable); HUF_FLUSHBITS(&bitC);
  	case 0:
  	default:;
diff --cc net/9p/trans_xen.c
index 2e2b8bca54f3,bc8807d9281f..000000000000
--- a/net/9p/trans_xen.c
+++ b/net/9p/trans_xen.c
@@@ -509,7 -520,7 +509,11 @@@ static void xen_9pfs_front_changed(stru
  	case XenbusStateClosed:
  		if (dev->state == XenbusStateClosed)
  			break;
++<<<<<<< HEAD
 +		/* Missed the backend's CLOSING state -- fallthrough */
++=======
+ 		fallthrough;	/* Missed the backend's CLOSING state */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case XenbusStateClosing:
  		xenbus_frontend_closed(dev);
  		break;
diff --cc net/core/pktgen.c
index e52a7afb51ef,95f4c6b8f51a..000000000000
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@@ -3439,7 -3430,7 +3439,11 @@@ xmit_more
  		net_info_ratelimited("%s xmit error: %d\n",
  				     pkt_dev->odevname, ret);
  		pkt_dev->errors++;
++<<<<<<< HEAD
 +		/* fallthru */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case NETDEV_TX_BUSY:
  		/* Retry it next time */
  		refcount_dec(&(pkt_dev->skb->users));
diff --cc net/core/sock.c
index d5f0115da4aa,f8e5ccc45272..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -896,22 -994,22 +896,38 @@@ set_rcvbuf
  			clear_bit(SOCK_PASSCRED, &sock->flags);
  		break;
  
 -	case SO_TIMESTAMP_OLD:
 -		__sock_set_timestamps(sk, valbool, false, false);
 +	case SO_TIMESTAMP:
 +	case SO_TIMESTAMPNS:
 +		if (valbool)  {
 +			if (optname == SO_TIMESTAMP)
 +				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
 +			else
 +				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
 +			sock_set_flag(sk, SOCK_RCVTSTAMP);
 +			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 +		} else {
 +			sock_reset_flag(sk, SOCK_RCVTSTAMP);
 +			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
 +		}
  		break;
++<<<<<<< HEAD
 +
 +	case SO_TIMESTAMPING:
++=======
+ 	case SO_TIMESTAMP_NEW:
+ 		__sock_set_timestamps(sk, valbool, true, false);
+ 		break;
+ 	case SO_TIMESTAMPNS_OLD:
+ 		__sock_set_timestamps(sk, valbool, false, true);
+ 		break;
+ 	case SO_TIMESTAMPNS_NEW:
+ 		__sock_set_timestamps(sk, valbool, true, true);
+ 		break;
+ 	case SO_TIMESTAMPING_NEW:
+ 		sock_set_flag(sk, SOCK_TSTAMP_NEW);
+ 		fallthrough;
+ 	case SO_TIMESTAMPING_OLD:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		if (val & ~SOF_TIMESTAMPING_MASK) {
  			ret = -EINVAL;
  			break;
diff --cc net/decnet/dn_nsp_in.c
index 68705d350c85,c97bdca5ec30..000000000000
--- a/net/decnet/dn_nsp_in.c
+++ b/net/decnet/dn_nsp_in.c
@@@ -491,6 -483,7 +491,10 @@@ static void dn_nsp_disc_conf(struct soc
  		break;
  	case DN_RUN:
  		sk->sk_shutdown |= SHUTDOWN_MASK;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case DN_CC:
  		scp->state = DN_CN;
  	}
diff --cc net/iucv/af_iucv.c
index 3abf9f289b79,a95af62acb52..000000000000
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@@ -512,7 -418,9 +512,13 @@@ static void iucv_sock_close(struct soc
  			sk->sk_state = IUCV_DISCONN;
  			sk->sk_state_change(sk);
  		}
++<<<<<<< HEAD
 +	case IUCV_DISCONN:   /* fall through */
++=======
+ 		fallthrough;
+ 
+ 	case IUCV_DISCONN:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		sk->sk_state = IUCV_CLOSING;
  		sk->sk_state_change(sk);
  
@@@ -525,8 -433,9 +531,12 @@@
  					iucv_sock_in_state(sk, IUCV_CLOSED, 0),
  					timeo);
  		}
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	case IUCV_CLOSING:
 +	case IUCV_CLOSING:   /* fall through */
  		sk->sk_state = IUCV_CLOSED;
  		sk->sk_state_change(sk);
  
@@@ -535,8 -444,9 +545,12 @@@
  
  		skb_queue_purge(&iucv->send_skb_q);
  		skb_queue_purge(&iucv->backlog_skb_q);
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 -	default:
 +	default:   /* fall through */
  		iucv_sever_path(sk, 1);
  	}
  
@@@ -2252,10 -2111,10 +2266,17 @@@ static int afiucv_hs_rcv(struct sk_buf
  			kfree_skb(skb);
  			break;
  		}
++<<<<<<< HEAD
 +		/* fall through and receive non-zero length data */
 +	case (AF_IUCV_FLAG_SHT):
 +		/* shutdown request */
 +		/* fall through and receive zero length data */
++=======
+ 		fallthrough;	/* and receive non-zero length data */
+ 	case (AF_IUCV_FLAG_SHT):
+ 		/* shutdown request */
+ 		fallthrough;	/* and receive zero length data */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case 0:
  		/* plain data frame */
  		IUCV_SKB_CB(skb)->class = trans_hdr->iucv_hdr.class;
diff --cc net/rxrpc/af_rxrpc.c
index 3c39b8805d01,186c8a889b16..000000000000
--- a/net/rxrpc/af_rxrpc.c
+++ b/net/rxrpc/af_rxrpc.c
@@@ -576,10 -544,9 +576,15 @@@ static int rxrpc_sendmsg(struct socket 
  		}
  
  		rx->local = local;
++<<<<<<< HEAD
 +		rx->sk.sk_state = RXRPC_CLIENT_UNBOUND;
 +		/* Fall through */
++=======
+ 		rx->sk.sk_state = RXRPC_CLIENT_BOUND;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
 +	case RXRPC_CLIENT_UNBOUND:
  	case RXRPC_CLIENT_BOUND:
  		if (!m->msg_name &&
  		    test_bit(RXRPC_SOCK_CONNECTED, &rx->flags)) {
diff --cc net/rxrpc/input.c
index 96292c34143b,fbde8b824e23..000000000000
--- a/net/rxrpc/input.c
+++ b/net/rxrpc/input.c
@@@ -1022,7 -1084,7 +1022,11 @@@ static void rxrpc_input_implicit_end_ca
  	switch (READ_ONCE(call->state)) {
  	case RXRPC_CALL_SERVER_AWAIT_ACK:
  		rxrpc_call_completed(call);
++<<<<<<< HEAD
 +		break;
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case RXRPC_CALL_COMPLETE:
  		break;
  	default:
@@@ -1189,16 -1241,50 +1193,27 @@@ void rxrpc_data_ready(struct sock *udp_
  		goto out;
  
  	case RXRPC_PACKET_TYPE_BUSY:
 -		if (rxrpc_to_server(sp))
 +		if (sp->hdr.flags & RXRPC_CLIENT_INITIATED)
  			goto discard;
++<<<<<<< HEAD
 +		/* Fall through */
++=======
+ 		fallthrough;
+ 	case RXRPC_PACKET_TYPE_ACK:
+ 	case RXRPC_PACKET_TYPE_ACKALL:
+ 		if (sp->hdr.callNumber == 0)
+ 			goto bad_message;
+ 		fallthrough;
+ 	case RXRPC_PACKET_TYPE_ABORT:
+ 		break;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  
  	case RXRPC_PACKET_TYPE_DATA:
 -		if (sp->hdr.callNumber == 0 ||
 -		    sp->hdr.seq == 0)
 +		if (sp->hdr.callNumber == 0)
  			goto bad_message;
 -		if (!rxrpc_validate_data(skb))
 +		if (sp->hdr.flags & RXRPC_JUMBO_PACKET &&
 +		    !rxrpc_validate_jumbo(skb))
  			goto bad_message;
 -
 -		/* Unshare the packet so that it can be modified for in-place
 -		 * decryption.
 -		 */
 -		if (sp->hdr.securityIndex != 0) {
 -			struct sk_buff *nskb = skb_unshare(skb, GFP_ATOMIC);
 -			if (!nskb) {
 -				rxrpc_eaten_skb(skb, rxrpc_skb_unshared_nomem);
 -				goto out;
 -			}
 -
 -			if (nskb != skb) {
 -				rxrpc_eaten_skb(skb, rxrpc_skb_received);
 -				skb = nskb;
 -				rxrpc_new_skb(skb, rxrpc_skb_unshared);
 -				sp = rxrpc_skb(skb);
 -			}
 -		}
 -		break;
 -
 -	case RXRPC_PACKET_TYPE_CHALLENGE:
 -		if (rxrpc_to_server(sp))
 -			goto discard;
 -		break;
 -	case RXRPC_PACKET_TYPE_RESPONSE:
 -		if (rxrpc_to_client(sp))
 -			goto discard;
  		break;
  
  		/* Packet types 9-11 should just be ignored. */
diff --cc net/rxrpc/local_object.c
index 777c3ed4cfc0,ede058f9cc15..000000000000
--- a/net/rxrpc/local_object.c
+++ b/net/rxrpc/local_object.c
@@@ -135,44 -155,23 +135,55 @@@ static int rxrpc_open_socket(struct rxr
  	}
  
  	switch (local->srx.transport.family) {
++<<<<<<< HEAD
++=======
+ 	case AF_INET6:
+ 		/* we want to receive ICMPv6 errors */
+ 		ip6_sock_set_recverr(local->socket->sk);
+ 
+ 		/* Fall through and set IPv4 options too otherwise we don't get
+ 		 * errors from IPv4 packets sent through the IPv6 socket.
+ 		 */
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AF_INET:
  		/* we want to receive ICMP errors */
 -		ip_sock_set_recverr(local->socket->sk);
 +		opt = 1;
 +		ret = kernel_setsockopt(local->socket, SOL_IP, IP_RECVERR,
 +					(char *) &opt, sizeof(opt));
 +		if (ret < 0) {
 +			_debug("setsockopt failed");
 +			goto error;
 +		}
  
  		/* we want to set the don't fragment bit */
 -		ip_sock_set_mtu_discover(local->socket->sk, IP_PMTUDISC_DO);
 +		opt = IP_PMTUDISC_DO;
 +		ret = kernel_setsockopt(local->socket, SOL_IP, IP_MTU_DISCOVER,
 +					(char *) &opt, sizeof(opt));
 +		if (ret < 0) {
 +			_debug("setsockopt failed");
 +			goto error;
 +		}
 +		break;
  
 -		/* We want receive timestamps. */
 -		sock_enable_timestamps(local->socket->sk);
 +	case AF_INET6:
 +		/* we want to receive ICMP errors */
 +		opt = 1;
 +		ret = kernel_setsockopt(local->socket, SOL_IPV6, IPV6_RECVERR,
 +					(char *) &opt, sizeof(opt));
 +		if (ret < 0) {
 +			_debug("setsockopt failed");
 +			goto error;
 +		}
 +
 +		/* we want to set the don't fragment bit */
 +		opt = IPV6_PMTUDISC_DO;
 +		ret = kernel_setsockopt(local->socket, SOL_IPV6, IPV6_MTU_DISCOVER,
 +					(char *) &opt, sizeof(opt));
 +		if (ret < 0) {
 +			_debug("setsockopt failed");
 +			goto error;
 +		}
  		break;
  
  	default:
diff --cc net/rxrpc/peer_event.c
index 4f9da2f51c69,be032850ae8c..000000000000
--- a/net/rxrpc/peer_event.c
+++ b/net/rxrpc/peer_event.c
@@@ -259,6 -271,9 +259,12 @@@ static void rxrpc_store_error(struct rx
  		break;
  
  	case SO_EE_ORIGIN_ICMP6:
++<<<<<<< HEAD
++=======
+ 		if (err == EACCES)
+ 			err = EHOSTUNREACH;
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		_proto("Rx Received error report { orig=%u }", ee->ee_origin);
  		break;
diff --cc net/rxrpc/recvmsg.c
index 2dda4912ab83,c4684dde1f16..000000000000
--- a/net/rxrpc/recvmsg.c
+++ b/net/rxrpc/recvmsg.c
@@@ -686,6 -770,17 +686,20 @@@ int rxrpc_kernel_recv_data(struct socke
  read_phase_complete:
  	ret = 1;
  out:
++<<<<<<< HEAD
++=======
+ 	switch (call->ackr_reason) {
+ 	case RXRPC_ACK_IDLE:
+ 		break;
+ 	case RXRPC_ACK_DELAY:
+ 		if (ret != -EAGAIN)
+ 			break;
+ 		fallthrough;
+ 	default:
+ 		rxrpc_send_ack_packet(call, false, NULL);
+ 	}
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	if (_service)
  		*_service = call->service_id;
  	mutex_unlock(&call->user_mutex);
diff --cc net/tipc/bearer.c
index 84425e68b7be,650414110452..000000000000
--- a/net/tipc/bearer.c
+++ b/net/tipc/bearer.c
@@@ -652,7 -652,7 +652,11 @@@ static int tipc_l2_device_event(struct 
  			test_and_set_bit_lock(0, &b->up);
  			break;
  		}
++<<<<<<< HEAD
 +		/* else: fall through */
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case NETDEV_GOING_DOWN:
  		clear_bit_unlock(0, &b->up);
  		tipc_reset_bearer(net, b);
diff --cc net/xfrm/xfrm_policy.c
index 05bce8cb06cc,d622c2548d22..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -3276,6 -3265,214 +3276,217 @@@ xfrm_policy_ok(const struct xfrm_tmpl *
  	return start;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ decode_session4(struct sk_buff *skb, struct flowi *fl, bool reverse)
+ {
+ 	const struct iphdr *iph = ip_hdr(skb);
+ 	int ihl = iph->ihl;
+ 	u8 *xprth = skb_network_header(skb) + ihl * 4;
+ 	struct flowi4 *fl4 = &fl->u.ip4;
+ 	int oif = 0;
+ 
+ 	if (skb_dst(skb) && skb_dst(skb)->dev)
+ 		oif = skb_dst(skb)->dev->ifindex;
+ 
+ 	memset(fl4, 0, sizeof(struct flowi4));
+ 	fl4->flowi4_mark = skb->mark;
+ 	fl4->flowi4_oif = reverse ? skb->skb_iif : oif;
+ 
+ 	fl4->flowi4_proto = iph->protocol;
+ 	fl4->daddr = reverse ? iph->saddr : iph->daddr;
+ 	fl4->saddr = reverse ? iph->daddr : iph->saddr;
+ 	fl4->flowi4_tos = iph->tos;
+ 
+ 	if (!ip_is_fragment(iph)) {
+ 		switch (iph->protocol) {
+ 		case IPPROTO_UDP:
+ 		case IPPROTO_UDPLITE:
+ 		case IPPROTO_TCP:
+ 		case IPPROTO_SCTP:
+ 		case IPPROTO_DCCP:
+ 			if (xprth + 4 < skb->data ||
+ 			    pskb_may_pull(skb, xprth + 4 - skb->data)) {
+ 				__be16 *ports;
+ 
+ 				xprth = skb_network_header(skb) + ihl * 4;
+ 				ports = (__be16 *)xprth;
+ 
+ 				fl4->fl4_sport = ports[!!reverse];
+ 				fl4->fl4_dport = ports[!reverse];
+ 			}
+ 			break;
+ 		case IPPROTO_ICMP:
+ 			if (xprth + 2 < skb->data ||
+ 			    pskb_may_pull(skb, xprth + 2 - skb->data)) {
+ 				u8 *icmp;
+ 
+ 				xprth = skb_network_header(skb) + ihl * 4;
+ 				icmp = xprth;
+ 
+ 				fl4->fl4_icmp_type = icmp[0];
+ 				fl4->fl4_icmp_code = icmp[1];
+ 			}
+ 			break;
+ 		case IPPROTO_ESP:
+ 			if (xprth + 4 < skb->data ||
+ 			    pskb_may_pull(skb, xprth + 4 - skb->data)) {
+ 				__be32 *ehdr;
+ 
+ 				xprth = skb_network_header(skb) + ihl * 4;
+ 				ehdr = (__be32 *)xprth;
+ 
+ 				fl4->fl4_ipsec_spi = ehdr[0];
+ 			}
+ 			break;
+ 		case IPPROTO_AH:
+ 			if (xprth + 8 < skb->data ||
+ 			    pskb_may_pull(skb, xprth + 8 - skb->data)) {
+ 				__be32 *ah_hdr;
+ 
+ 				xprth = skb_network_header(skb) + ihl * 4;
+ 				ah_hdr = (__be32 *)xprth;
+ 
+ 				fl4->fl4_ipsec_spi = ah_hdr[1];
+ 			}
+ 			break;
+ 		case IPPROTO_COMP:
+ 			if (xprth + 4 < skb->data ||
+ 			    pskb_may_pull(skb, xprth + 4 - skb->data)) {
+ 				__be16 *ipcomp_hdr;
+ 
+ 				xprth = skb_network_header(skb) + ihl * 4;
+ 				ipcomp_hdr = (__be16 *)xprth;
+ 
+ 				fl4->fl4_ipsec_spi = htonl(ntohs(ipcomp_hdr[1]));
+ 			}
+ 			break;
+ 		case IPPROTO_GRE:
+ 			if (xprth + 12 < skb->data ||
+ 			    pskb_may_pull(skb, xprth + 12 - skb->data)) {
+ 				__be16 *greflags;
+ 				__be32 *gre_hdr;
+ 
+ 				xprth = skb_network_header(skb) + ihl * 4;
+ 				greflags = (__be16 *)xprth;
+ 				gre_hdr = (__be32 *)xprth;
+ 
+ 				if (greflags[0] & GRE_KEY) {
+ 					if (greflags[0] & GRE_CSUM)
+ 						gre_hdr++;
+ 					fl4->fl4_gre_key = gre_hdr[1];
+ 				}
+ 			}
+ 			break;
+ 		default:
+ 			fl4->fl4_ipsec_spi = 0;
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static void
+ decode_session6(struct sk_buff *skb, struct flowi *fl, bool reverse)
+ {
+ 	struct flowi6 *fl6 = &fl->u.ip6;
+ 	int onlyproto = 0;
+ 	const struct ipv6hdr *hdr = ipv6_hdr(skb);
+ 	u32 offset = sizeof(*hdr);
+ 	struct ipv6_opt_hdr *exthdr;
+ 	const unsigned char *nh = skb_network_header(skb);
+ 	u16 nhoff = IP6CB(skb)->nhoff;
+ 	int oif = 0;
+ 	u8 nexthdr;
+ 
+ 	if (!nhoff)
+ 		nhoff = offsetof(struct ipv6hdr, nexthdr);
+ 
+ 	nexthdr = nh[nhoff];
+ 
+ 	if (skb_dst(skb) && skb_dst(skb)->dev)
+ 		oif = skb_dst(skb)->dev->ifindex;
+ 
+ 	memset(fl6, 0, sizeof(struct flowi6));
+ 	fl6->flowi6_mark = skb->mark;
+ 	fl6->flowi6_oif = reverse ? skb->skb_iif : oif;
+ 
+ 	fl6->daddr = reverse ? hdr->saddr : hdr->daddr;
+ 	fl6->saddr = reverse ? hdr->daddr : hdr->saddr;
+ 
+ 	while (nh + offset + sizeof(*exthdr) < skb->data ||
+ 	       pskb_may_pull(skb, nh + offset + sizeof(*exthdr) - skb->data)) {
+ 		nh = skb_network_header(skb);
+ 		exthdr = (struct ipv6_opt_hdr *)(nh + offset);
+ 
+ 		switch (nexthdr) {
+ 		case NEXTHDR_FRAGMENT:
+ 			onlyproto = 1;
+ 			fallthrough;
+ 		case NEXTHDR_ROUTING:
+ 		case NEXTHDR_HOP:
+ 		case NEXTHDR_DEST:
+ 			offset += ipv6_optlen(exthdr);
+ 			nexthdr = exthdr->nexthdr;
+ 			exthdr = (struct ipv6_opt_hdr *)(nh + offset);
+ 			break;
+ 		case IPPROTO_UDP:
+ 		case IPPROTO_UDPLITE:
+ 		case IPPROTO_TCP:
+ 		case IPPROTO_SCTP:
+ 		case IPPROTO_DCCP:
+ 			if (!onlyproto && (nh + offset + 4 < skb->data ||
+ 			     pskb_may_pull(skb, nh + offset + 4 - skb->data))) {
+ 				__be16 *ports;
+ 
+ 				nh = skb_network_header(skb);
+ 				ports = (__be16 *)(nh + offset);
+ 				fl6->fl6_sport = ports[!!reverse];
+ 				fl6->fl6_dport = ports[!reverse];
+ 			}
+ 			fl6->flowi6_proto = nexthdr;
+ 			return;
+ 		case IPPROTO_ICMPV6:
+ 			if (!onlyproto && (nh + offset + 2 < skb->data ||
+ 			    pskb_may_pull(skb, nh + offset + 2 - skb->data))) {
+ 				u8 *icmp;
+ 
+ 				nh = skb_network_header(skb);
+ 				icmp = (u8 *)(nh + offset);
+ 				fl6->fl6_icmp_type = icmp[0];
+ 				fl6->fl6_icmp_code = icmp[1];
+ 			}
+ 			fl6->flowi6_proto = nexthdr;
+ 			return;
+ #if IS_ENABLED(CONFIG_IPV6_MIP6)
+ 		case IPPROTO_MH:
+ 			offset += ipv6_optlen(exthdr);
+ 			if (!onlyproto && (nh + offset + 3 < skb->data ||
+ 			    pskb_may_pull(skb, nh + offset + 3 - skb->data))) {
+ 				struct ip6_mh *mh;
+ 
+ 				nh = skb_network_header(skb);
+ 				mh = (struct ip6_mh *)(nh + offset);
+ 				fl6->fl6_mh_type = mh->ip6mh_type;
+ 			}
+ 			fl6->flowi6_proto = nexthdr;
+ 			return;
+ #endif
+ 		/* XXX Why are there these headers? */
+ 		case IPPROTO_AH:
+ 		case IPPROTO_ESP:
+ 		case IPPROTO_COMP:
+ 		default:
+ 			fl6->fl6_ipsec_spi = 0;
+ 			fl6->flowi6_proto = nexthdr;
+ 			return;
+ 		}
+ 	}
+ }
+ #endif
+ 
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  int __xfrm_decode_session(struct sk_buff *skb, struct flowi *fl,
  			  unsigned int family, int reverse)
  {
diff --cc security/apparmor/domain.c
index 098d546d8253,f919ebd042fd..000000000000
--- a/security/apparmor/domain.c
+++ b/security/apparmor/domain.c
@@@ -572,7 -577,7 +572,11 @@@ static struct aa_label *x_to_label(stru
  			stack = NULL;
  			break;
  		}
++<<<<<<< HEAD
 +		/* fall through to X_NAME */
++=======
+ 		fallthrough;	/* to X_NAME */
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case AA_X_NAME:
  		if (xindex & AA_X_CHILD)
  			/* released by caller */
diff --cc security/integrity/ima/ima_policy.c
index 2c63d6afc3c9,b4de33074b37..000000000000
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@@ -994,10 -1279,12 +994,18 @@@ static int ima_parse_rule(char *rule, s
  		case Opt_uid_gt:
  		case Opt_euid_gt:
  			entry->uid_op = &uid_gt;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case Opt_uid_lt:
  		case Opt_euid_lt:
  			if ((token == Opt_uid_lt) || (token == Opt_euid_lt))
  				entry->uid_op = &uid_lt;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case Opt_uid_eq:
  		case Opt_euid_eq:
  			uid_token = (token == Opt_uid_eq) ||
@@@ -1026,9 -1313,11 +1034,17 @@@
  			break;
  		case Opt_fowner_gt:
  			entry->fowner_op = &uid_gt;
++<<<<<<< HEAD
 +		case Opt_fowner_lt:
 +			if (token == Opt_fowner_lt)
 +				entry->fowner_op = &uid_lt;
++=======
+ 			fallthrough;
+ 		case Opt_fowner_lt:
+ 			if (token == Opt_fowner_lt)
+ 				entry->fowner_op = &uid_lt;
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case Opt_fowner_eq:
  			ima_log_string_op(ab, "fowner", args[0].from,
  					  entry->fowner_op);
diff --cc security/integrity/ima/ima_template_lib.c
index f931ea41fd97,c022ee9e2a4e..000000000000
--- a/security/integrity/ima/ima_template_lib.c
+++ b/security/integrity/ima/ima_template_lib.c
@@@ -83,6 -77,7 +83,10 @@@ static void ima_show_template_data_asci
  		/* skip ':' and '\0' */
  		buf_ptr += 2;
  		buflen -= buf_ptr - field_data->data;
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	case DATA_FMT_DIGEST:
  	case DATA_FMT_HEX:
  		if (!buflen)
diff --cc security/keys/process_keys.c
index 02c77e928f68,1fe8b934f656..000000000000
--- a/security/keys/process_keys.c
+++ b/security/keys/process_keys.c
@@@ -379,6 -465,7 +379,10 @@@ key_ref_t search_my_process_keyrings(st
  		case -EAGAIN: /* no key */
  			if (ret)
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case -ENOKEY: /* negative key */
  			ret = key_ref;
  			break;
@@@ -403,6 -487,7 +407,10 @@@
  		case -EAGAIN: /* no key */
  			if (ret)
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case -ENOKEY: /* negative key */
  			ret = key_ref;
  			break;
@@@ -423,6 -509,7 +431,10 @@@
  		case -EAGAIN: /* no key */
  			if (ret)
  				break;
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case -ENOKEY: /* negative key */
  			ret = key_ref;
  			break;
diff --cc security/keys/request_key.c
index 301f0e300dbd,2da4404276f0..000000000000
--- a/security/keys/request_key.c
+++ b/security/keys/request_key.c
@@@ -287,28 -295,30 +287,44 @@@ static int construct_get_dest_keyring(s
  				}
  			}
  
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case KEY_REQKEY_DEFL_THREAD_KEYRING:
  			dest_keyring = key_get(cred->thread_keyring);
  			if (dest_keyring)
  				break;
  
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case KEY_REQKEY_DEFL_PROCESS_KEYRING:
  			dest_keyring = key_get(cred->process_keyring);
  			if (dest_keyring)
  				break;
  
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case KEY_REQKEY_DEFL_SESSION_KEYRING:
 -			dest_keyring = key_get(cred->session_keyring);
 +			rcu_read_lock();
 +			dest_keyring = key_get(
 +				rcu_dereference(cred->session_keyring));
 +			rcu_read_unlock();
  
  			if (dest_keyring)
  				break;
  
++<<<<<<< HEAD
++=======
+ 			fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  		case KEY_REQKEY_DEFL_USER_SESSION_KEYRING:
 -			ret = look_up_user_keyrings(NULL, &dest_keyring);
 -			if (ret < 0)
 -				return ret;
 +			dest_keyring =
 +				key_get(cred->user->session_keyring);
  			break;
  
  		case KEY_REQKEY_DEFL_USER_KEYRING:
diff --cc security/smack/smack_lsm.c
index 77b0bfb018e5,8c0893eb5aa8..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -3456,6 -3365,7 +3456,10 @@@ static void smack_d_instantiate(struct 
  		 * to set mount options simulate setting the
  		 * superblock default.
  		 */
++<<<<<<< HEAD
++=======
+ 		fallthrough;
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  	default:
  		/*
  		 * This isn't an understood special case.
diff --cc security/tomoyo/common.c
index e6970a69c20c,4bee32bfe16d..000000000000
--- a/security/tomoyo/common.c
+++ b/security/tomoyo/common.c
@@@ -1599,17 -1637,30 +1599,42 @@@ static void tomoyo_read_domain(struct t
  			for (i = 0; i < TOMOYO_MAX_DOMAIN_INFO_FLAGS; i++)
  				if (domain->flags[i])
  					tomoyo_set_string(head, tomoyo_dif[i]);
++<<<<<<< HEAD
 +			head->r.step++;
 +			tomoyo_set_lf(head);
 +			/* fall through */
 +		case 1:
++=======
+ 			head->r.index = 0;
+ 			head->r.step++;
+ 			fallthrough;
+ 		case 1:
+ 			while (head->r.index < TOMOYO_MAX_ACL_GROUPS) {
+ 				i = head->r.index++;
+ 				if (!test_bit(i, domain->group))
+ 					continue;
+ 				tomoyo_io_printf(head, "use_group %u\n", i);
+ 				if (!tomoyo_flush(head))
+ 					return;
+ 			}
+ 			head->r.index = 0;
+ 			head->r.step++;
+ 			tomoyo_set_lf(head);
+ 			fallthrough;
+ 		case 2:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			if (!tomoyo_read_domain2(head, &domain->acl_info_list))
  				return;
  			head->r.step++;
  			if (!tomoyo_set_lf(head))
  				return;
++<<<<<<< HEAD
 +			/* fall through */
 +		case 2:
++=======
+ 			fallthrough;
+ 		case 3:
++>>>>>>> df561f6688fe (treewide: Use fallthrough pseudo-keyword)
  			head->r.step = 0;
  			if (head->r.print_this_domain_only)
  				goto done;
* Unmerged path arch/csky/kernel/signal.c
* Unmerged path arch/mips/include/asm/unroll.h
* Unmerged path arch/nds32/kernel/fpu.c
* Unmerged path arch/riscv/net/bpf_jit_comp32.c
* Unmerged path arch/sh/drivers/platform_early.c
* Unmerged path drivers/crypto/marvell/octeontx/otx_cptvf_reqmgr.c
* Unmerged path drivers/gpio/gpio-aspeed-sgpio.c
* Unmerged path drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v10_3.c
* Unmerged path drivers/gpu/drm/bridge/nwl-dsi.c
* Unmerged path drivers/gpu/drm/meson/meson_osd_afbcd.c
* Unmerged path drivers/gpu/drm/meson/meson_overlay.c
* Unmerged path drivers/gpu/drm/msm/adreno/a6xx_gmu.c
* Unmerged path drivers/gpu/drm/msm/adreno/a6xx_gpu.c
* Unmerged path drivers/hwmon/occ/common.c
* Unmerged path drivers/i3c/master/dw-i3c-master.c
* Unmerged path drivers/iio/adc/ab8500-gpadc.c
* Unmerged path drivers/iio/chemical/sps30.c
* Unmerged path drivers/input/joystick/fsia6b.c
* Unmerged path drivers/iommu/virtio-iommu.c
* Unmerged path drivers/mfd/iqs62x.c
* Unmerged path drivers/mmc/host/sdhci-sprd.c
* Unmerged path drivers/mux/adgs1408.c
* Unmerged path drivers/net/dsa/b53/b53_serdes.c
* Unmerged path drivers/net/dsa/microchip/ksz9477.c
* Unmerged path drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
* Unmerged path drivers/net/ethernet/microchip/lan743x_ethtool.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
* Unmerged path drivers/net/ethernet/ti/cpsw_priv.c
* Unmerged path drivers/platform/olpc/olpc-xo175-ec.c
* Unmerged path drivers/power/supply/cros_usbpd-charger.c
* Unmerged path drivers/regulator/slg51000-regulator.c
* Unmerged path drivers/scsi/myrb.c
* Unmerged path drivers/scsi/ufs/ufs_bsg.c
* Unmerged path drivers/soc/qcom/socinfo.c
* Unmerged path drivers/staging/media/atomisp/pci/atomisp_cmd.c
* Unmerged path drivers/staging/media/atomisp/pci/atomisp_compat_css20.c
* Unmerged path drivers/staging/media/atomisp/pci/atomisp_ioctl.c
* Unmerged path drivers/staging/media/atomisp/pci/atomisp_v4l2.c
* Unmerged path drivers/staging/media/atomisp/pci/hmm/hmm_bo.c
* Unmerged path drivers/staging/media/atomisp/pci/sh_css.c
* Unmerged path drivers/staging/media/hantro/hantro_g1_mpeg2_dec.c
* Unmerged path drivers/staging/media/hantro/rk3399_vpu_hw_mpeg2_dec.c
* Unmerged path drivers/thermal/qcom/tsens-v0_1.c
* Unmerged path drivers/thermal/qcom/tsens-v1.c
* Unmerged path drivers/tty/serial/rda-uart.c
* Unmerged path fs/afs/yfsclient.c
* Unmerged path fs/erofs/zmap.c
* Unmerged path fs/fs_context.c
* Unmerged path fs/fsopen.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/pstore/zone.c
* Unmerged path fs/vboxsf/utils.c
* Unmerged path lib/bootconfig.c
* Unmerged path net/can/j1939/socket.c
* Unmerged path net/can/j1939/transport.c
diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index 47632fa8c24e..f0b4f9820f54 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -224,7 +224,7 @@ apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab,
 			    STO_ALPHA_STD_GPLOAD)
 				/* Omit the prologue. */
 				value += 8;
-			/* FALLTHRU */
+			fallthrough;
 		case R_ALPHA_BRADDR:
 			value -= (u64)location + 4;
 			if (value & 3)
diff --git a/arch/alpha/kernel/signal.c b/arch/alpha/kernel/signal.c
index 33e904a05881..3fb8bfe8166a 100644
--- a/arch/alpha/kernel/signal.c
+++ b/arch/alpha/kernel/signal.c
@@ -453,7 +453,7 @@ syscall_restart(unsigned long r0, unsigned long r19,
 			regs->r0 = EINTR;
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	case ERESTARTNOINTR:
 		regs->r0 = r0;	/* reset v0 and a3 and replay syscall */
 		regs->r19 = r19;
diff --git a/arch/alpha/kernel/traps.c b/arch/alpha/kernel/traps.c
index bc9627698796..ea5087ba5202 100644
--- a/arch/alpha/kernel/traps.c
+++ b/arch/alpha/kernel/traps.c
@@ -883,7 +883,7 @@ do_entUnaUser(void __user * va, unsigned long opcode,
 
 	case 0x26: /* sts */
 		fake_reg = s_reg_to_mem(alpha_read_fp_reg(reg));
-		/* FALLTHRU */
+		fallthrough;
 
 	case 0x2c: /* stl */
 		__asm__ __volatile__(
@@ -911,7 +911,7 @@ do_entUnaUser(void __user * va, unsigned long opcode,
 
 	case 0x27: /* stt */
 		fake_reg = alpha_read_fp_reg(reg);
-		/* FALLTHRU */
+		fallthrough;
 
 	case 0x2d: /* stq */
 		__asm__ __volatile__(
diff --git a/arch/arc/kernel/disasm.c b/arch/arc/kernel/disasm.c
index 3b7cd4864ba2..45862caf1169 100644
--- a/arch/arc/kernel/disasm.c
+++ b/arch/arc/kernel/disasm.c
@@ -342,7 +342,7 @@ void __kprobes disasm_instr(unsigned long addr, struct disasm_state *state,
 
 	case op_LDWX_S:	/* LDWX_S c, [b, u6] */
 		state->x = 1;
-		/* intentional fall-through */
+		fallthrough;
 
 	case op_LDW_S:	/* LDW_S c, [b, u6] */
 		state->zz = 2;
diff --git a/arch/arc/kernel/signal.c b/arch/arc/kernel/signal.c
index 1bfb7de696bd..1de96539a021 100644
--- a/arch/arc/kernel/signal.c
+++ b/arch/arc/kernel/signal.c
@@ -324,7 +324,7 @@ static void arc_restart_syscall(struct k_sigaction *ka, struct pt_regs *regs)
 			regs->r0 = -EINTR;
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 
 	case -ERESTARTNOINTR:
 		/*
* Unmerged path arch/arc/kernel/unwind.c
diff --git a/arch/arm/include/asm/hardware/iop3xx-adma.h b/arch/arm/include/asm/hardware/iop3xx-adma.h
index 240b29ef17db..4f313f77e27e 100644
--- a/arch/arm/include/asm/hardware/iop3xx-adma.h
+++ b/arch/arm/include/asm/hardware/iop3xx-adma.h
@@ -514,7 +514,7 @@ iop3xx_desc_init_xor(struct iop3xx_desc_aau *hw_desc, int src_cnt,
 		}
 		hw_desc->src_edc[AAU_EDCR2_IDX].e_desc_ctrl = edcr;
 		src_cnt = 24;
-		/* fall through */
+		fallthrough;
 	case 17 ... 24:
 		if (!u_desc_ctrl.field.blk_ctrl) {
 			hw_desc->src_edc[AAU_EDCR2_IDX].e_desc_ctrl = 0;
@@ -528,7 +528,7 @@ iop3xx_desc_init_xor(struct iop3xx_desc_aau *hw_desc, int src_cnt,
 		}
 		hw_desc->src_edc[AAU_EDCR1_IDX].e_desc_ctrl = edcr;
 		src_cnt = 16;
-		/* fall through */
+		fallthrough;
 	case 9 ... 16:
 		if (!u_desc_ctrl.field.blk_ctrl)
 			u_desc_ctrl.field.blk_ctrl = 0x2; /* use EDCR0 */
@@ -540,7 +540,7 @@ iop3xx_desc_init_xor(struct iop3xx_desc_aau *hw_desc, int src_cnt,
 		}
 		hw_desc->src_edc[AAU_EDCR0_IDX].e_desc_ctrl = edcr;
 		src_cnt = 8;
-		/* fall through */
+		fallthrough;
 	case 2 ... 8:
 		shift = 1;
 		for (i = 0; i < src_cnt; i++) {
@@ -620,19 +620,19 @@ iop_desc_init_null_xor(struct iop_adma_desc_slot *desc, int src_cnt,
 	case 25 ... 32:
 		u_desc_ctrl.field.blk_ctrl = 0x3; /* use EDCR[2:0] */
 		hw_desc->src_edc[AAU_EDCR2_IDX].e_desc_ctrl = 0;
-		/* fall through */
+		fallthrough;
 	case 17 ... 24:
 		if (!u_desc_ctrl.field.blk_ctrl) {
 			hw_desc->src_edc[AAU_EDCR2_IDX].e_desc_ctrl = 0;
 			u_desc_ctrl.field.blk_ctrl = 0x3; /* use EDCR[2:0] */
 		}
 		hw_desc->src_edc[AAU_EDCR1_IDX].e_desc_ctrl = 0;
-		/* fall through */
+		fallthrough;
 	case 9 ... 16:
 		if (!u_desc_ctrl.field.blk_ctrl)
 			u_desc_ctrl.field.blk_ctrl = 0x2; /* use EDCR0 */
 		hw_desc->src_edc[AAU_EDCR0_IDX].e_desc_ctrl = 0;
-		/* fall through */
+		fallthrough;
 	case 1 ... 8:
 		if (!u_desc_ctrl.field.blk_ctrl && src_cnt > 4)
 			u_desc_ctrl.field.blk_ctrl = 0x1; /* use mini-desc */
* Unmerged path arch/arm/kernel/hw_breakpoint.c
* Unmerged path arch/arm/kernel/signal.c
* Unmerged path arch/arm/mach-ep93xx/crunch.c
diff --git a/arch/arm/mach-mmp/pm-mmp2.c b/arch/arm/mach-mmp/pm-mmp2.c
index 17699be3bc3d..ca0c45d39651 100644
--- a/arch/arm/mach-mmp/pm-mmp2.c
+++ b/arch/arm/mach-mmp/pm-mmp2.c
@@ -125,19 +125,19 @@ void mmp2_pm_enter_lowpower_mode(int state)
 	case POWER_MODE_SYS_SLEEP:
 		apcr |= MPMU_PCR_PJ_SLPEN;		/* set the SLPEN bit */
 		apcr |= MPMU_PCR_PJ_VCTCXOSD;		/* set VCTCXOSD */
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_CHIP_SLEEP:
 		apcr |= MPMU_PCR_PJ_SLPEN;
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_APPS_SLEEP:
 		apcr |= MPMU_PCR_PJ_APBSD;		/* set APBSD */
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_APPS_IDLE:
 		apcr |= MPMU_PCR_PJ_AXISD;		/* set AXISDD bit */
 		apcr |= MPMU_PCR_PJ_DDRCORSD;		/* set DDRCORSD bit */
 		idle_cfg |= APMU_PJ_IDLE_CFG_PJ_PWRDWN;	/* PJ power down */
 		apcr |= MPMU_PCR_PJ_SPSD;
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_CORE_EXTIDLE:
 		idle_cfg |= APMU_PJ_IDLE_CFG_PJ_IDLE;	/* set the IDLE bit */
 		idle_cfg &= ~APMU_PJ_IDLE_CFG_ISO_MODE_CNTRL_MASK;
diff --git a/arch/arm/mach-mmp/pm-pxa910.c b/arch/arm/mach-mmp/pm-pxa910.c
index 8b47600b3cdf..3c97fc63ffa9 100644
--- a/arch/arm/mach-mmp/pm-pxa910.c
+++ b/arch/arm/mach-mmp/pm-pxa910.c
@@ -147,23 +147,23 @@ void pxa910_pm_enter_lowpower_mode(int state)
 	case POWER_MODE_UDR:
 		/* only shutdown APB in UDR */
 		apcr |= MPMU_APCR_STBYEN | MPMU_APCR_APBSD;
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_SYS_SLEEP:
 		apcr |= MPMU_APCR_SLPEN;		/* set the SLPEN bit */
 		apcr |= MPMU_APCR_VCTCXOSD;		/* set VCTCXOSD */
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_APPS_SLEEP:
 		apcr |= MPMU_APCR_DDRCORSD;		/* set DDRCORSD */
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_APPS_IDLE:
 		apcr |= MPMU_APCR_AXISD;		/* set AXISDD bit */
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_CORE_EXTIDLE:
 		idle_cfg |= APMU_MOH_IDLE_CFG_MOH_IDLE;
 		idle_cfg |= APMU_MOH_IDLE_CFG_MOH_PWRDWN;
 		idle_cfg |= APMU_MOH_IDLE_CFG_MOH_PWR_SW(3)
 			| APMU_MOH_IDLE_CFG_MOH_L2_PWR_SW(3);
-		/* fall through */
+		fallthrough;
 	case POWER_MODE_CORE_INTIDLE:
 		break;
 	}
diff --git a/arch/arm/mach-omap2/id.c b/arch/arm/mach-omap2/id.c
index 68ba5f472f6b..e58f8b70b5c1 100644
--- a/arch/arm/mach-omap2/id.c
+++ b/arch/arm/mach-omap2/id.c
@@ -399,7 +399,6 @@ void __init omap3xxx_check_revision(void)
 			cpu_rev = "3.1";
 			break;
 		case 7:
-		/* FALLTHROUGH */
 		default:
 			/* Use the latest known revision as default */
 			omap_revision = OMAP3430_REV_ES3_1_2;
@@ -419,7 +418,6 @@ void __init omap3xxx_check_revision(void)
 			cpu_rev = "1.0";
 			break;
 		case 1:
-		/* FALLTHROUGH */
 		default:
 			omap_revision = AM35XX_REV_ES1_1;
 			cpu_rev = "1.1";
@@ -438,7 +436,6 @@ void __init omap3xxx_check_revision(void)
 			cpu_rev = "1.1";
 			break;
 		case 2:
-		/* FALLTHROUGH */
 		default:
 			omap_revision = OMAP3630_REV_ES1_2;
 			cpu_rev = "1.2";
@@ -459,7 +456,6 @@ void __init omap3xxx_check_revision(void)
 			cpu_rev = "2.0";
 			break;
 		case 3:
-			/* FALLTHROUGH */
 		default:
 			omap_revision = TI8168_REV_ES2_1;
 			cpu_rev = "2.1";
@@ -476,7 +472,6 @@ void __init omap3xxx_check_revision(void)
 			cpu_rev = "2.0";
 			break;
 		case 2:
-		/* FALLTHROUGH */
 		default:
 			omap_revision = AM335X_REV_ES2_1;
 			cpu_rev = "2.1";
@@ -494,7 +489,6 @@ void __init omap3xxx_check_revision(void)
 			cpu_rev = "1.1";
 			break;
 		case 2:
-		/* FALLTHROUGH */
 		default:
 			omap_revision = AM437X_REV_ES1_2;
 			cpu_rev = "1.2";
@@ -505,7 +499,6 @@ void __init omap3xxx_check_revision(void)
 	case 0xb968:
 		switch (rev) {
 		case 0:
-		/* FALLTHROUGH */
 		case 1:
 			omap_revision = TI8148_REV_ES1_0;
 			cpu_rev = "1.0";
@@ -515,7 +508,6 @@ void __init omap3xxx_check_revision(void)
 			cpu_rev = "2.0";
 			break;
 		case 3:
-		/* FALLTHROUGH */
 		default:
 			omap_revision = TI8148_REV_ES2_1;
 			cpu_rev = "2.1";
diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 41c7b905980a..0f5374a55305 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -249,7 +249,7 @@ static int _omap_device_notifier_call(struct notifier_block *nb,
 		if (pdev->dev.of_node)
 			omap_device_build_from_dt(pdev);
 		omap_auxdata_legacy_init(dev);
-		/* fall through */
+		fallthrough;
 	default:
 		od = to_omap_device(pdev);
 		if (od)
diff --git a/arch/arm/mach-orion5x/dns323-setup.c b/arch/arm/mach-orion5x/dns323-setup.c
index d13344b2ddcd..87cb47220e82 100644
--- a/arch/arm/mach-orion5x/dns323-setup.c
+++ b/arch/arm/mach-orion5x/dns323-setup.c
@@ -624,7 +624,7 @@ static void __init dns323_init(void)
 		 dns323ab_leds[0].active_low = 1;
 		 gpio_request(DNS323_GPIO_LED_POWER1, "Power Led Enable");
 		 gpio_direction_output(DNS323_GPIO_LED_POWER1, 0);
-		/* Fall through */
+		fallthrough;
 	case DNS323_REV_B1:
 		i2c_register_board_info(0, dns323ab_i2c_devices,
 				ARRAY_SIZE(dns323ab_i2c_devices));
* Unmerged path arch/arm/mach-rpc/riscpc.c
* Unmerged path arch/arm/mach-tegra/reset.c
* Unmerged path arch/arm/mm/alignment.c
diff --git a/arch/arm/mm/proc-v7-bugs.c b/arch/arm/mm/proc-v7-bugs.c
index 9c8f6a507d0b..8f44994fb701 100644
--- a/arch/arm/mm/proc-v7-bugs.c
+++ b/arch/arm/mm/proc-v7-bugs.c
@@ -72,7 +72,7 @@ static void cpu_v7_spectre_init(void)
 		/* Other ARM CPUs require no workaround */
 		if (read_cpuid_implementor() == ARM_CPU_IMP_ARM)
 			break;
-		/* fallthrough */
+		fallthrough;
 		/* Cortex A57/A72 require firmware workaround */
 	case ARM_CPU_PART_CORTEX_A57:
 	case ARM_CPU_PART_CORTEX_A72: {
* Unmerged path arch/arm/plat-omap/dma.c
diff --git a/arch/arm/probes/decode.c b/arch/arm/probes/decode.c
index 880ebe0cdf19..d65d3453c4ed 100644
--- a/arch/arm/probes/decode.c
+++ b/arch/arm/probes/decode.c
@@ -310,7 +310,7 @@ static bool __kprobes decode_regs(probes_opcode_t *pinsn, u32 regs, bool modify)
 		case REG_TYPE_NOPCWB:
 			if (!is_writeback(insn))
 				break; /* No writeback, so any register is OK */
-			/* fall through... */
+			fallthrough;
 		case REG_TYPE_NOPC:
 		case REG_TYPE_NOPCX:
 			/* Reject PC (R15) */
* Unmerged path arch/arm/probes/kprobes/core.c
* Unmerged path arch/arm64/kernel/acpi.c
* Unmerged path arch/arm64/kernel/cpufeature.c
diff --git a/arch/arm64/kernel/cpuinfo.c b/arch/arm64/kernel/cpuinfo.c
index 8d646abd3fbe..bd2e90b2d77e 100644
--- a/arch/arm64/kernel/cpuinfo.c
+++ b/arch/arm64/kernel/cpuinfo.c
@@ -316,7 +316,7 @@ static void cpuinfo_detect_icache_policy(struct cpuinfo_arm64 *info)
 		set_bit(ICACHEF_VPIPT, &__icache_flags);
 		break;
 	default:
-		/* Fallthrough */
+		fallthrough;
 	case ICACHE_POLICY_VIPT:
 		/* Assume aliasing */
 		set_bit(ICACHEF_ALIASING, &__icache_flags);
* Unmerged path arch/arm64/kernel/hw_breakpoint.c
* Unmerged path arch/arm64/kernel/module.c
* Unmerged path arch/arm64/kernel/smp.c
diff --git a/arch/arm64/kvm/handle_exit.c b/arch/arm64/kvm/handle_exit.c
index 81bb57bfe9ec..a953083049da 100644
--- a/arch/arm64/kvm/handle_exit.c
+++ b/arch/arm64/kvm/handle_exit.c
@@ -139,7 +139,7 @@ static int kvm_handle_guest_debug(struct kvm_vcpu *vcpu, struct kvm_run *run)
 	switch (ESR_ELx_EC(esr)) {
 	case ESR_ELx_EC_WATCHPT_LOW:
 		run->debug.arch.far = vcpu->arch.fault.far_el2;
-		/* fall through */
+		fallthrough;
 	case ESR_ELx_EC_SOFTSTP_LOW:
 	case ESR_ELx_EC_BREAKPT_LOW:
 	case ESR_ELx_EC_BKPT32:
diff --git a/arch/arm64/kvm/hyp/debug-sr.c b/arch/arm64/kvm/hyp/debug-sr.c
index d825b78b3f10..f93f15c41259 100644
--- a/arch/arm64/kvm/hyp/debug-sr.c
+++ b/arch/arm64/kvm/hyp/debug-sr.c
@@ -29,70 +29,70 @@
 #define save_debug(ptr,reg,nr)						\
 	switch (nr) {							\
 	case 15:	ptr[15] = read_debug(reg, 15);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 14:	ptr[14] = read_debug(reg, 14);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 13:	ptr[13] = read_debug(reg, 13);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 12:	ptr[12] = read_debug(reg, 12);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 11:	ptr[11] = read_debug(reg, 11);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 10:	ptr[10] = read_debug(reg, 10);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 9:		ptr[9] = read_debug(reg, 9);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 8:		ptr[8] = read_debug(reg, 8);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 7:		ptr[7] = read_debug(reg, 7);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 6:		ptr[6] = read_debug(reg, 6);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 5:		ptr[5] = read_debug(reg, 5);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 4:		ptr[4] = read_debug(reg, 4);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 3:		ptr[3] = read_debug(reg, 3);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 2:		ptr[2] = read_debug(reg, 2);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 1:		ptr[1] = read_debug(reg, 1);			\
-			/* Fall through */				\
+			fallthrough;					\
 	default:	ptr[0] = read_debug(reg, 0);			\
 	}
 
 #define restore_debug(ptr,reg,nr)					\
 	switch (nr) {							\
 	case 15:	write_debug(ptr[15], reg, 15);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 14:	write_debug(ptr[14], reg, 14);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 13:	write_debug(ptr[13], reg, 13);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 12:	write_debug(ptr[12], reg, 12);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 11:	write_debug(ptr[11], reg, 11);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 10:	write_debug(ptr[10], reg, 10);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 9:		write_debug(ptr[9], reg, 9);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 8:		write_debug(ptr[8], reg, 8);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 7:		write_debug(ptr[7], reg, 7);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 6:		write_debug(ptr[6], reg, 6);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 5:		write_debug(ptr[5], reg, 5);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 4:		write_debug(ptr[4], reg, 4);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 3:		write_debug(ptr[3], reg, 3);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 2:		write_debug(ptr[2], reg, 2);			\
-			/* Fall through */				\
+			fallthrough;					\
 	case 1:		write_debug(ptr[1], reg, 1);			\
-			/* Fall through */				\
+			fallthrough;					\
 	default:	write_debug(ptr[0], reg, 0);			\
 	}
 
diff --git a/arch/arm64/kvm/hyp/vgic-v3-sr.c b/arch/arm64/kvm/hyp/vgic-v3-sr.c
index ef13c2c1935d..0aed73d6665e 100644
--- a/arch/arm64/kvm/hyp/vgic-v3-sr.c
+++ b/arch/arm64/kvm/hyp/vgic-v3-sr.c
@@ -351,10 +351,10 @@ void __hyp_text __vgic_v3_save_aprs(struct vgic_v3_cpu_if *cpu_if)
 	case 7:
 		cpu_if->vgic_ap0r[3] = __vgic_v3_read_ap0rn(3);
 		cpu_if->vgic_ap0r[2] = __vgic_v3_read_ap0rn(2);
-		/* Fall through */
+		fallthrough;
 	case 6:
 		cpu_if->vgic_ap0r[1] = __vgic_v3_read_ap0rn(1);
-		/* Fall through */
+		fallthrough;
 	default:
 		cpu_if->vgic_ap0r[0] = __vgic_v3_read_ap0rn(0);
 	}
@@ -363,10 +363,10 @@ void __hyp_text __vgic_v3_save_aprs(struct vgic_v3_cpu_if *cpu_if)
 	case 7:
 		cpu_if->vgic_ap1r[3] = __vgic_v3_read_ap1rn(3);
 		cpu_if->vgic_ap1r[2] = __vgic_v3_read_ap1rn(2);
-		/* Fall through */
+		fallthrough;
 	case 6:
 		cpu_if->vgic_ap1r[1] = __vgic_v3_read_ap1rn(1);
-		/* Fall through */
+		fallthrough;
 	default:
 		cpu_if->vgic_ap1r[0] = __vgic_v3_read_ap1rn(0);
 	}
@@ -384,10 +384,10 @@ void __hyp_text __vgic_v3_restore_aprs(struct vgic_v3_cpu_if *cpu_if)
 	case 7:
 		__vgic_v3_write_ap0rn(cpu_if->vgic_ap0r[3], 3);
 		__vgic_v3_write_ap0rn(cpu_if->vgic_ap0r[2], 2);
-		/* Fall through */
+		fallthrough;
 	case 6:
 		__vgic_v3_write_ap0rn(cpu_if->vgic_ap0r[1], 1);
-		/* Fall through */
+		fallthrough;
 	default:
 		__vgic_v3_write_ap0rn(cpu_if->vgic_ap0r[0], 0);
 	}
@@ -396,10 +396,10 @@ void __hyp_text __vgic_v3_restore_aprs(struct vgic_v3_cpu_if *cpu_if)
 	case 7:
 		__vgic_v3_write_ap1rn(cpu_if->vgic_ap1r[3], 3);
 		__vgic_v3_write_ap1rn(cpu_if->vgic_ap1r[2], 2);
-		/* Fall through */
+		fallthrough;
 	case 6:
 		__vgic_v3_write_ap1rn(cpu_if->vgic_ap1r[1], 1);
-		/* Fall through */
+		fallthrough;
 	default:
 		__vgic_v3_write_ap1rn(cpu_if->vgic_ap1r[0], 0);
 	}
diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c
index c9198b350e05..cb8b54f1d5bc 100644
--- a/arch/arm64/mm/context.c
+++ b/arch/arm64/mm/context.c
@@ -62,7 +62,7 @@ static u32 get_cpu_asid_bits(void)
 	default:
 		pr_warn("CPU%d: Unknown ASID size (%d); assuming 8-bit\n",
 					smp_processor_id(),  fld);
-		/* Fallthrough */
+		fallthrough;
 	case 0:
 		asid = 8;
 		break;
diff --git a/arch/c6x/kernel/signal.c b/arch/c6x/kernel/signal.c
index 33b9f69c38f7..5809ee544be8 100644
--- a/arch/c6x/kernel/signal.c
+++ b/arch/c6x/kernel/signal.c
@@ -223,7 +223,7 @@ handle_restart(struct pt_regs *regs, struct k_sigaction *ka, int has_handler)
 			regs->a4 = -EINTR;
 			break;
 		}
-	/* fallthrough */
+		fallthrough;
 	case -ERESTARTNOINTR:
 do_restart:
 		regs->a4 = regs->orig_a4;
@@ -255,7 +255,7 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs,
 				break;
 			}
 
-			/* fallthrough */
+			fallthrough;
 		case -ERESTARTNOINTR:
 			regs->a4 = regs->orig_a4;
 			regs->pc -= 4;
* Unmerged path arch/csky/kernel/signal.c
diff --git a/arch/h8300/kernel/signal.c b/arch/h8300/kernel/signal.c
index e0f2b708e5d9..2ffae0a1f0db 100644
--- a/arch/h8300/kernel/signal.c
+++ b/arch/h8300/kernel/signal.c
@@ -228,7 +228,7 @@ handle_restart(struct pt_regs *regs, struct k_sigaction *ka)
 			regs->er0 = -EINTR;
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	case -ERESTARTNOINTR:
 do_restart:
 		regs->er0 = regs->orig_er0;
diff --git a/arch/hexagon/kernel/module.c b/arch/hexagon/kernel/module.c
index 477d07a5646c..f663a153fadf 100644
--- a/arch/hexagon/kernel/module.c
+++ b/arch/hexagon/kernel/module.c
@@ -133,7 +133,7 @@ int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
 		}
 		case R_HEXAGON_HI16:
 			value = (value>>16) & 0xffff;
-			/* fallthrough */
+			fallthrough;
 		case R_HEXAGON_LO16:
 			*location &= ~0x00c03fff;
 			*location |= value & 0x3fff;
diff --git a/arch/hexagon/kernel/signal.c b/arch/hexagon/kernel/signal.c
index 31e2cf95f189..cbb3860bc3a0 100644
--- a/arch/hexagon/kernel/signal.c
+++ b/arch/hexagon/kernel/signal.c
@@ -168,7 +168,7 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 				regs->r00 = -EINTR;
 				break;
 			}
-			/* Fall through */
+			fallthrough;
 		case -ERESTARTNOINTR:
 			regs->r06 = regs->syscall_nr;
 			pt_set_elr(regs, pt_elr(regs) - 4);
diff --git a/arch/ia64/kernel/crash.c b/arch/ia64/kernel/crash.c
index bec762a9b418..fec70d662d0c 100644
--- a/arch/ia64/kernel/crash.c
+++ b/arch/ia64/kernel/crash.c
@@ -163,7 +163,7 @@ kdump_init_notifier(struct notifier_block *self, unsigned long val, void *data)
 		case DIE_INIT_MONARCH_LEAVE:
 			if (!kdump_freeze_monarch)
 				break;
-			/* fall through */
+			fallthrough;
 		case DIE_INIT_SLAVE_LEAVE:
 		case DIE_INIT_MONARCH_ENTER:
 		case DIE_MCA_RENDZVOUS_LEAVE:
diff --git a/arch/ia64/kernel/module.c b/arch/ia64/kernel/module.c
index 326448f9df16..9da61e59191e 100644
--- a/arch/ia64/kernel/module.c
+++ b/arch/ia64/kernel/module.c
@@ -654,7 +654,7 @@ do_reloc (struct module *mod, uint8_t r_type, Elf64_Sym *sym, uint64_t addend,
 				}
 			} else if (!is_internal(mod, val))
 				val = get_plt(mod, location, val, &ok);
-			/* FALL THROUGH */
+			fallthrough;
 		      default:
 			val -= bundle(location);
 			break;
diff --git a/arch/ia64/kernel/perfmon.c b/arch/ia64/kernel/perfmon.c
index 46bff1661836..d09934a867c3 100644
--- a/arch/ia64/kernel/perfmon.c
+++ b/arch/ia64/kernel/perfmon.c
@@ -3517,7 +3517,7 @@ pfm_restart(pfm_context_t *ctx, void *arg, int count, struct pt_regs *regs)
 			break;
 		case PFM_CTX_LOADED: 
 			if (CTX_HAS_SMPL(ctx) && fmt->fmt_restart_active) break;
-			/* fall through */
+			fallthrough;
 		case PFM_CTX_UNLOADED:
 		case PFM_CTX_ZOMBIE:
 			DPRINT(("invalid state=%d\n", state));
* Unmerged path arch/ia64/kernel/signal.c
* Unmerged path arch/ia64/kernel/unaligned.c
diff --git a/arch/ia64/kernel/unwind.c b/arch/ia64/kernel/unwind.c
index 7601fe0622d2..6bd64c35e691 100644
--- a/arch/ia64/kernel/unwind.c
+++ b/arch/ia64/kernel/unwind.c
@@ -324,7 +324,7 @@ unw_access_gr (struct unw_frame_info *info, int regnum, unsigned long *val, char
 							return 0;
 						}
 					}
-					/* fall through */
+					fallthrough;
 				      case UNW_NAT_NONE:
 					dummy_nat = 0;
 					nat_addr = &dummy_nat;
diff --git a/arch/m68k/atari/atakeyb.c b/arch/m68k/atari/atakeyb.c
index 37091898adb3..5e0e682f9c61 100644
--- a/arch/m68k/atari/atakeyb.c
+++ b/arch/m68k/atari/atakeyb.c
@@ -207,7 +207,7 @@ static irqreturn_t atari_keyboard_interrupt(int irq, void *dummy)
 					self_test_last_rcv = jiffies;
 					break;
 				}
-				/* FALL THROUGH */
+				fallthrough;
 
 			default:
 				break_flag = scancode & BREAK_MASK;
diff --git a/arch/m68k/kernel/signal.c b/arch/m68k/kernel/signal.c
index e2a9421c5797..9f5f7700b2b2 100644
--- a/arch/m68k/kernel/signal.c
+++ b/arch/m68k/kernel/signal.c
@@ -1067,7 +1067,7 @@ handle_restart(struct pt_regs *regs, struct k_sigaction *ka, int has_handler)
 			regs->d0 = -EINTR;
 			break;
 		}
-	/* fallthrough */
+		fallthrough;
 	case -ERESTARTNOINTR:
 	do_restart:
 		regs->d0 = regs->orig_d0;
diff --git a/arch/m68k/mac/config.c b/arch/m68k/mac/config.c
index e522307db47c..4344fc43e9e3 100644
--- a/arch/m68k/mac/config.c
+++ b/arch/m68k/mac/config.c
@@ -1047,7 +1047,7 @@ int __init mac_platform_init(void)
 		 */
 		platform_device_register_simple("mac_scsi", 1,
 			mac_scsi_duo_rsrc, ARRAY_SIZE(mac_scsi_duo_rsrc));
-		/* fall through */
+		fallthrough;
 	case MAC_SCSI_OLD:
 		/* Addresses from Developer Notes for Duo System,
 		 * PowerBook 180 & 160, 140 & 170, Macintosh IIsi
diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index acdabbeecfd2..7c0e048d1679 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -410,7 +410,7 @@ void via_nubus_irq_startup(int irq)
 			/* Allow NuBus slots 9 through F. */
 			via2[vDirA] &= 0x80 | ~(1 << irq_idx);
 		}
-		/* fall through */
+		fallthrough;
 	case MAC_VIA_IICI:
 		via_irq_enable(irq);
 		break;
diff --git a/arch/m68k/mm/fault.c b/arch/m68k/mm/fault.c
index 126051833241..0a031f7ceeaf 100644
--- a/arch/m68k/mm/fault.c
+++ b/arch/m68k/mm/fault.c
@@ -116,7 +116,7 @@ int do_page_fault(struct pt_regs *regs, unsigned long address,
 	pr_debug("do_page_fault: good_area\n");
 	switch (error_code & 3) {
 		default:	/* 3: write, present */
-			/* fall through */
+			fallthrough;
 		case 2:		/* write, not present */
 			if (!(vma->vm_flags & VM_WRITE))
 				goto acc_err;
diff --git a/arch/microblaze/kernel/signal.c b/arch/microblaze/kernel/signal.c
index 0685696349bb..966e48ac956b 100644
--- a/arch/microblaze/kernel/signal.c
+++ b/arch/microblaze/kernel/signal.c
@@ -253,7 +253,7 @@ handle_restart(struct pt_regs *regs, struct k_sigaction *ka, int has_handler)
 			regs->r3 = -EINTR;
 			break;
 	}
-	/* fallthrough */
+		fallthrough;
 	case -ERESTARTNOINTR:
 do_restart:
 		/* offset of 4 bytes to re-execute trap (brki) instruction */
* Unmerged path arch/mips/include/asm/unroll.h
* Unmerged path arch/nds32/kernel/fpu.c
* Unmerged path arch/nds32/kernel/signal.c
diff --git a/arch/openrisc/kernel/signal.c b/arch/openrisc/kernel/signal.c
index 5ac9d3b1d615..f4dbef4b5971 100644
--- a/arch/openrisc/kernel/signal.c
+++ b/arch/openrisc/kernel/signal.c
@@ -248,7 +248,7 @@ int do_signal(struct pt_regs *regs, int syscall)
 		switch (retval) {
 		case -ERESTART_RESTARTBLOCK:
 			restart = -2;
-			/* Fall through */
+			fallthrough;
 		case -ERESTARTNOHAND:
 		case -ERESTARTSYS:
 		case -ERESTARTNOINTR:
diff --git a/arch/parisc/kernel/signal.c b/arch/parisc/kernel/signal.c
index 342073f44d3f..076643039bc0 100644
--- a/arch/parisc/kernel/signal.c
+++ b/arch/parisc/kernel/signal.c
@@ -504,7 +504,7 @@ syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)
 			regs->gr[28] = -EINTR;
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	case -ERESTARTNOINTR:
 		check_syscallno_in_delay_branch(regs);
 		break;
diff --git a/arch/parisc/kernel/traps.c b/arch/parisc/kernel/traps.c
index 4309ad31a874..da8a952e9980 100644
--- a/arch/parisc/kernel/traps.c
+++ b/arch/parisc/kernel/traps.c
@@ -442,7 +442,6 @@ void parisc_terminate(char *msg, struct pt_regs *regs, int code, unsigned long o
 		break;
 
 	default:
-		/* Fall through */
 		break;
 
 	}
@@ -636,12 +635,12 @@ void notrace handle_interruption(int code, struct pt_regs *regs)
 
 	case 15:
 		/* Data TLB miss fault/Data page fault */
-		/* Fall through */
+		fallthrough;
 	case 16:
 		/* Non-access instruction TLB miss fault */
 		/* The instruction TLB entry needed for the target address of the FIC
 		   is absent, and hardware can't find it, so we get to cleanup */
-		/* Fall through */
+		fallthrough;
 	case 17:
 		/* Non-access data TLB miss fault/Non-access data page fault */
 		/* FIXME: 
@@ -665,7 +664,7 @@ void notrace handle_interruption(int code, struct pt_regs *regs)
 			handle_unaligned(regs);
 			return;
 		}
-		/* Fall Through */
+		fallthrough;
 	case 26: 
 		/* PCXL: Data memory access rights trap */
 		fault_address = regs->ior;
@@ -675,7 +674,7 @@ void notrace handle_interruption(int code, struct pt_regs *regs)
 	case 19:
 		/* Data memory break trap */
 		regs->gr[0] |= PSW_X; /* So we can single-step over the trap */
-		/* fall thru */
+		fallthrough;
 	case 21:
 		/* Page reference trap */
 		handle_gdb_break(regs, TRAP_HWBKPT);
@@ -722,7 +721,7 @@ void notrace handle_interruption(int code, struct pt_regs *regs)
 			}
 			up_read(&current->mm->mmap_sem);
 		}
-		/* Fall Through */
+		fallthrough;
 	case 27: 
 		/* Data memory protection ID trap */
 		if (code == 27 && !user_mode(regs) &&
* Unmerged path arch/parisc/mm/fault.c
diff --git a/arch/powerpc/net/bpf_jit_comp.c b/arch/powerpc/net/bpf_jit_comp.c
index 7308b2c609ac..06bcac36d542 100644
--- a/arch/powerpc/net/bpf_jit_comp.c
+++ b/arch/powerpc/net/bpf_jit_comp.c
@@ -481,7 +481,7 @@ static int bpf_jit_build_body(struct bpf_prog *fp, u32 *image,
 		case BPF_JMP | BPF_JSET | BPF_K:
 		case BPF_JMP | BPF_JSET | BPF_X:
 			true_cond = COND_NE;
-			/* Fall through */
+			fallthrough;
 		cond_branch:
 			/* same targets, can avoid doing the test :) */
 			if (filter[i].jt == filter[i].jf) {
diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c
index 587fa414a7fb..e8c2425d2c69 100644
--- a/arch/riscv/kernel/signal.c
+++ b/arch/riscv/kernel/signal.c
@@ -225,7 +225,7 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 				regs->a0 = -EINTR;
 				break;
 			}
-			/* fallthrough */
+			fallthrough;
 		case -ERESTARTNOINTR:
                         regs->a0 = regs->orig_a0;
 			regs->sepc -= 0x4;
* Unmerged path arch/riscv/net/bpf_jit_comp32.c
* Unmerged path arch/sh/drivers/platform_early.c
* Unmerged path arch/sh/kernel/disassemble.c
* Unmerged path arch/sh/kernel/kgdb.c
diff --git a/arch/sh/kernel/signal_32.c b/arch/sh/kernel/signal_32.c
index 2a2121ba8ebe..4ce70b1fee84 100644
--- a/arch/sh/kernel/signal_32.c
+++ b/arch/sh/kernel/signal_32.c
@@ -419,7 +419,7 @@ handle_syscall_restart(unsigned long save_r0, struct pt_regs *regs,
 		case -ERESTARTSYS:
 			if (!(sa->sa_flags & SA_RESTART))
 				goto no_system_call_restart;
-		/* fallthrough */
+			fallthrough;
 		case -ERESTARTNOINTR:
 			regs->regs[0] = save_r0;
 			regs->pc -= instruction_size(__raw_readw(regs->pc - 4));
diff --git a/arch/sparc/kernel/auxio_64.c b/arch/sparc/kernel/auxio_64.c
index 4e8f56c3793c..91a3f101ea3c 100644
--- a/arch/sparc/kernel/auxio_64.c
+++ b/arch/sparc/kernel/auxio_64.c
@@ -87,7 +87,6 @@ void auxio_set_lte(int on)
 		__auxio_sbus_set_lte(on);
 		break;
 	case AUXIO_TYPE_EBUS:
-		/* FALL-THROUGH */
 	default:
 		break;
 	}
diff --git a/arch/sparc/kernel/central.c b/arch/sparc/kernel/central.c
index 38ae4fdc9eb4..1ad55e6da048 100644
--- a/arch/sparc/kernel/central.c
+++ b/arch/sparc/kernel/central.c
@@ -55,7 +55,7 @@ static int clock_board_calc_nslots(struct clock_board *p)
 			else
 				return 5;
 		}
-		/* Fallthrough */
+		fallthrough;
 	default:
 		return 4;
 	}
* Unmerged path arch/sparc/kernel/kgdb_32.c
* Unmerged path arch/sparc/kernel/kgdb_64.c
diff --git a/arch/sparc/kernel/pcr.c b/arch/sparc/kernel/pcr.c
index eb978c77c76a..46c8ee50c2f5 100644
--- a/arch/sparc/kernel/pcr.c
+++ b/arch/sparc/kernel/pcr.c
@@ -358,7 +358,7 @@ int __init pcr_arch_init(void)
 		 * counter overflow interrupt so we can't make use of
 		 * their hardware currently.
 		 */
-		/* fallthrough */
+		fallthrough;
 	default:
 		err = -ENODEV;
 		goto out_unregister;
diff --git a/arch/sparc/kernel/prom_32.c b/arch/sparc/kernel/prom_32.c
index d41e2a749c5d..18fd51070de8 100644
--- a/arch/sparc/kernel/prom_32.c
+++ b/arch/sparc/kernel/prom_32.c
@@ -232,7 +232,7 @@ void __init of_console_init(void)
 
 		case PROMDEV_TTYB:
 			skip = 1;
-			/* FALLTHRU */
+			fallthrough;
 
 		case PROMDEV_TTYA:
 			type = "serial";
* Unmerged path arch/sparc/kernel/signal32.c
* Unmerged path arch/sparc/kernel/signal_32.c
* Unmerged path arch/sparc/kernel/signal_64.c
diff --git a/arch/sparc/math-emu/math_32.c b/arch/sparc/math-emu/math_32.c
index 72e560ef4a09..d5beec856146 100644
--- a/arch/sparc/math-emu/math_32.c
+++ b/arch/sparc/math-emu/math_32.c
@@ -359,7 +359,7 @@ static int do_one_mathemu(u32 insn, unsigned long *pfsr, unsigned long *fregs)
 			*pfsr |= (6 << 14);
 			return 0;			/* simulate invalid_fp_register exception */
 		}
-	/* fall through */
+		fallthrough;
 	case 2:
 		if (freg & 1) {				/* doublewords must have bit 5 zeroed */
 			*pfsr |= (6 << 14);
@@ -380,7 +380,7 @@ static int do_one_mathemu(u32 insn, unsigned long *pfsr, unsigned long *fregs)
 			*pfsr |= (6 << 14);
 			return 0;			/* simulate invalid_fp_register exception */
 		}
-	/* fall through */
+		fallthrough;
 	case 2:
 		if (freg & 1) {				/* doublewords must have bit 5 zeroed */
 			*pfsr |= (6 << 14);
@@ -408,13 +408,13 @@ static int do_one_mathemu(u32 insn, unsigned long *pfsr, unsigned long *fregs)
 			*pfsr |= (6 << 14);
 			return 0;			/* simulate invalid_fp_register exception */
 		}
-	/* fall through */
+		fallthrough;
 	case 2:
 		if (freg & 1) {				/* doublewords must have bit 5 zeroed */
 			*pfsr |= (6 << 14);
 			return 0;
 		}
-	/* fall through */
+		fallthrough;
 	case 1:
 		rd = (void *)&fregs[freg];
 		break;
diff --git a/arch/sparc/net/bpf_jit_comp_32.c b/arch/sparc/net/bpf_jit_comp_32.c
index a5ff88643d5c..9c0a7f99c25e 100644
--- a/arch/sparc/net/bpf_jit_comp_32.c
+++ b/arch/sparc/net/bpf_jit_comp_32.c
@@ -491,7 +491,7 @@ void bpf_jit_compile(struct bpf_prog *fp)
 				} else {
 					emit_loadimm(K, r_A);
 				}
-				/* Fallthrough */
+				fallthrough;
 			case BPF_RET | BPF_A:
 				if (seen_or_pass0) {
 					if (i != flen - 1) {
diff --git a/arch/um/kernel/signal.c b/arch/um/kernel/signal.c
index 57acbd67d85d..4ed7d925589a 100644
--- a/arch/um/kernel/signal.c
+++ b/arch/um/kernel/signal.c
@@ -42,7 +42,7 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 				PT_REGS_SYSCALL_RET(regs) = -EINTR;
 				break;
 			}
-		/* fallthrough */
+			fallthrough;
 		case -ERESTARTNOINTR:
 			PT_REGS_RESTART_SYSCALL(regs);
 			PT_REGS_ORIG_SYSCALL(regs) = PT_REGS_SYSCALL_NR(regs);
diff --git a/arch/x86/boot/cmdline.c b/arch/x86/boot/cmdline.c
index 625d21b0cd3f..e0a1740e17b5 100644
--- a/arch/x86/boot/cmdline.c
+++ b/arch/x86/boot/cmdline.c
@@ -56,7 +56,7 @@ int __cmdline_find_option(unsigned long cmdline_ptr, const char *option, char *b
 			/* else */
 			state = st_wordcmp;
 			opptr = option;
-			/* fall through */
+			fallthrough;
 
 		case st_wordcmp:
 			if (c == '=' && !*opptr) {
@@ -131,7 +131,7 @@ int __cmdline_find_option_bool(unsigned long cmdline_ptr, const char *option)
 			state = st_wordcmp;
 			opptr = option;
 			wstart = pos;
-			/* fall through */
+			fallthrough;
 
 		case st_wordcmp:
 			if (!*opptr)
* Unmerged path arch/x86/boot/compressed/kaslr.c
diff --git a/arch/x86/events/intel/core.c b/arch/x86/events/intel/core.c
index 52499a1a53bf..d8d6234e52ad 100644
--- a/arch/x86/events/intel/core.c
+++ b/arch/x86/events/intel/core.c
@@ -4991,7 +4991,7 @@ __init int intel_pmu_init(void)
 
 	case INTEL_FAM6_CORE2_MEROM:
 		x86_add_quirk(intel_clovertown_quirk);
-		/* fall through */
+		fallthrough;
 
 	case INTEL_FAM6_CORE2_MEROM_L:
 	case INTEL_FAM6_CORE2_PENRYN:
@@ -5372,7 +5372,7 @@ __init int intel_pmu_init(void)
 
 	case INTEL_FAM6_SKYLAKE_X:
 		pmem = true;
-		/* fall through */
+		fallthrough;
 	case INTEL_FAM6_SKYLAKE_L:
 	case INTEL_FAM6_SKYLAKE:
 	case INTEL_FAM6_KABYLAKE_L:
@@ -5424,7 +5424,7 @@ __init int intel_pmu_init(void)
 	case INTEL_FAM6_ICELAKE_X:
 	case INTEL_FAM6_ICELAKE_D:
 		pmem = true;
-		/* fall through */
+		fallthrough;
 	case INTEL_FAM6_ICELAKE_L:
 	case INTEL_FAM6_ICELAKE:
 	case INTEL_FAM6_TIGERLAKE_L:
diff --git a/arch/x86/events/intel/lbr.c b/arch/x86/events/intel/lbr.c
index 3ad528996d1c..8e5c41fd163f 100644
--- a/arch/x86/events/intel/lbr.c
+++ b/arch/x86/events/intel/lbr.c
@@ -1209,7 +1209,7 @@ static int branch_type(unsigned long from, unsigned long to, int abort)
 			ret = X86_BR_ZERO_CALL;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case 0x9a: /* call far absolute */
 		ret = X86_BR_CALL;
 		break;
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index e36ef258e53b..d209ec7b106c 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -231,7 +231,7 @@ void __init arch_init_ideal_nops(void)
 			return;
 		}
 
-		/* fall through */
+		fallthrough;
 
 	default:
 #ifdef CONFIG_X86_64
* Unmerged path arch/x86/kernel/apic/io_apic.c
* Unmerged path arch/x86/kernel/apic/probe_32.c
* Unmerged path arch/x86/kernel/cpu/cacheinfo.c
diff --git a/arch/x86/kernel/cpu/mce/inject.c b/arch/x86/kernel/cpu/mce/inject.c
index 3f82afd0f46f..282acd950a88 100644
--- a/arch/x86/kernel/cpu/mce/inject.c
+++ b/arch/x86/kernel/cpu/mce/inject.c
@@ -206,7 +206,7 @@ static int raise_local(void)
 			 * calling irq_enter, but the necessary
 			 * machinery isn't exported currently.
 			 */
-			/*FALL THROUGH*/
+			fallthrough;
 		case MCJ_CTX_PROCESS:
 			raise_exception(m, NULL);
 			break;
diff --git a/arch/x86/kernel/cpu/mce/intel.c b/arch/x86/kernel/cpu/mce/intel.c
index 214d6a0f0e18..0475eb3fc503 100644
--- a/arch/x86/kernel/cpu/mce/intel.c
+++ b/arch/x86/kernel/cpu/mce/intel.c
@@ -191,7 +191,7 @@ unsigned long cmci_intel_adjust_timer(unsigned long interval)
 		if (!atomic_sub_return(1, &cmci_storm_on_cpus))
 			pr_notice("CMCI storm subsided: switching to interrupt mode\n");
 
-		/* FALLTHROUGH */
+		fallthrough;
 
 	case CMCI_STORM_SUBSIDED:
 		/*
* Unmerged path arch/x86/kernel/cpu/mtrr/cyrix.c
* Unmerged path arch/x86/kernel/hw_breakpoint.c
* Unmerged path arch/x86/kernel/kgdb.c
diff --git a/arch/x86/kernel/mpparse.c b/arch/x86/kernel/mpparse.c
index 1bfe5c6e6cfe..6c3a1ca58852 100644
--- a/arch/x86/kernel/mpparse.c
+++ b/arch/x86/kernel/mpparse.c
@@ -311,7 +311,7 @@ static void __init construct_default_ioirq_mptable(int mpc_default_type)
 		case 2:
 			if (i == 0 || i == 13)
 				continue;	/* IRQ0 & IRQ13 not connected */
-			/* fall through */
+			fallthrough;
 		default:
 			if (i == 2)
 				continue;	/* IRQ2 is never connected */
@@ -355,7 +355,7 @@ static void __init construct_ioapic_table(int mpc_default_type)
 	default:
 		pr_err("???\nUnknown standard configuration %d\n",
 		       mpc_default_type);
-		/* fall through */
+		fallthrough;
 	case 1:
 	case 5:
 		memcpy(bus.bustype, "ISA   ", 6);
* Unmerged path arch/x86/kernel/ptrace.c
diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c
index 725624b6c0c0..01519545e8d8 100644
--- a/arch/x86/kernel/reboot.c
+++ b/arch/x86/kernel/reboot.c
@@ -625,7 +625,7 @@ static void native_machine_emergency_restart(void)
 
 		case BOOT_CF9_FORCE:
 			port_cf9_safe = true;
-			/* Fall through */
+			fallthrough;
 
 		case BOOT_CF9_SAFE:
 			if (port_cf9_safe) {
diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c
index 6f45f795690f..45ac3e0ae092 100644
--- a/arch/x86/kernel/signal.c
+++ b/arch/x86/kernel/signal.c
@@ -728,7 +728,7 @@ handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 				regs->ax = -EINTR;
 				break;
 			}
-		/* fallthrough */
+			fallthrough;
 		case -ERESTARTNOINTR:
 			regs->ax = regs->orig_ax;
 			regs->ip -= 2;
* Unmerged path arch/x86/kernel/uprobes.c
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index 988a070f2448..793b3f2fc71e 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -3027,7 +3027,7 @@ static void string_registers_quirk(struct x86_emulate_ctxt *ctxt)
 	case 0xa4:	/* movsb */
 	case 0xa5:	/* movsd/w */
 		*reg_rmw(ctxt, VCPU_REGS_RSI) &= (u32)-1;
-		/* fall through */
+		fallthrough;
 	case 0xaa:	/* stosb */
 	case 0xab:	/* stosd/w */
 		*reg_rmw(ctxt, VCPU_REGS_RDI) &= (u32)-1;
diff --git a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c
index 738d04ce345a..f4f533f7f4c6 100644
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@ -1790,7 +1790,7 @@ int kvm_hv_hypercall(struct kvm_vcpu *vcpu)
 		ret = kvm_hvcall_signal_event(vcpu, fast, ingpa);
 		if (ret != HV_STATUS_INVALID_PORT_ID)
 			break;
-		/* fall through - maybe userspace knows this conn_id. */
+		fallthrough;	/* maybe userspace knows this conn_id */
 	case HVCALL_POST_MESSAGE:
 		/* don't bother userspace if it has no way to handle it */
 		if (unlikely(rep || !vcpu_to_synic(vcpu)->active)) {
diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c
index c47d2acec529..4aa1c2e00e2a 100644
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@ -285,7 +285,7 @@ int kvm_set_routing_entry(struct kvm *kvm,
 		switch (ue->u.irqchip.irqchip) {
 		case KVM_IRQCHIP_PIC_SLAVE:
 			e->irqchip.pin += PIC_NUM_PINS / 2;
-			/* fall through */
+			fallthrough;
 		case KVM_IRQCHIP_PIC_MASTER:
 			if (ue->u.irqchip.pin >= PIC_NUM_PINS / 2)
 				return -EINVAL;
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 0e402133f329..c84a15eaabc5 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -1065,7 +1065,7 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 	switch (delivery_mode) {
 	case APIC_DM_LOWEST:
 		vcpu->arch.apic_arb_prio++;
-		/* fall through */
+		fallthrough;
 	case APIC_DM_FIXED:
 		if (unlikely(trig_mode && !level))
 			break;
@@ -1353,7 +1353,7 @@ static u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)
 		break;
 	case APIC_TASKPRI:
 		report_tpr_access(apic, false);
-		/* fall thru */
+		fallthrough;
 	default:
 		val = kvm_lapic_get_reg(apic, offset);
 		break;
@@ -2039,7 +2039,7 @@ int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 
 	case APIC_LVT0:
 		apic_manage_nmi_watchdog(apic, val);
-		/* fall through */
+		fallthrough;
 	case APIC_LVTTHMR:
 	case APIC_LVTPC:
 	case APIC_LVT1:
diff --git a/arch/x86/kvm/mmu/mmu.c b/arch/x86/kvm/mmu/mmu.c
index 33b7773753bf..bbdfb7f2fbbe 100644
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@ -4034,7 +4034,7 @@ __reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,
 			rsvd_bits(maxphyaddr, 51);
 		rsvd_check->rsvd_bits_mask[1][4] =
 			rsvd_check->rsvd_bits_mask[0][4];
-		/* fall through */
+		fallthrough;
 	case PT64_ROOT_4LEVEL:
 		rsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |
 			nonleaf_bit8_rsvd | rsvd_bits(7, 7) |
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index 5b32af8b4b0c..667404593247 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -2684,7 +2684,7 @@ static int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)
 	case MSR_IA32_APICBASE:
 		if (kvm_vcpu_apicv_active(vcpu))
 			avic_update_vapic_bar(to_svm(vcpu), data);
-		/* Fall through */
+		fallthrough;
 	default:
 		return kvm_set_msr_common(vcpu, msr);
 	}
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index a895f93794b0..95995d8de689 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -4563,7 +4563,7 @@ static bool rmode_exception(struct kvm_vcpu *vcpu, int vec)
 			vmcs_read32(VM_EXIT_INSTRUCTION_LEN);
 		if (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)
 			return false;
-		/* fall through */
+		fallthrough;
 	case DB_VECTOR:
 		return !(vcpu->guest_debug &
 			(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP));
@@ -4729,7 +4729,7 @@ static int handle_exception_nmi(struct kvm_vcpu *vcpu)
 		}
 		kvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;
 		kvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);
-		/* fall through */
+		fallthrough;
 	case BP_VECTOR:
 		/*
 		 * Update instruction length as we may reinject #BP from
@@ -5160,7 +5160,7 @@ static int handle_task_switch(struct kvm_vcpu *vcpu)
 				error_code =
 					vmcs_read32(IDT_VECTORING_ERROR_CODE);
 			}
-			/* fall through */
+			fallthrough;
 		case INTR_TYPE_SOFT_EXCEPTION:
 			kvm_clear_exception_queue(vcpu);
 			break;
@@ -5484,7 +5484,7 @@ static int handle_invpcid(struct kvm_vcpu *vcpu)
 		 * keeping track of global entries in shadow page tables.
 		 */
 
-		/* fall-through */
+		fallthrough;
 	case INVPCID_TYPE_ALL_INCL_GLOBAL:
 		kvm_mmu_unload(vcpu);
 		return kvm_skip_emulated_instruction(vcpu);
@@ -6454,7 +6454,7 @@ static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,
 		break;
 	case INTR_TYPE_SOFT_EXCEPTION:
 		vcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);
-		/* fall through */
+		fallthrough;
 	case INTR_TYPE_HARD_EXCEPTION:
 		if (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {
 			u32 err = vmcs_read32(error_code_field);
@@ -6464,7 +6464,7 @@ static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,
 		break;
 	case INTR_TYPE_SOFT_INTR:
 		vcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);
-		/* fall through */
+		fallthrough;
 	case INTR_TYPE_EXT_INTR:
 		kvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);
 		break;
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 132c17734241..16546846e230 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -1115,14 +1115,12 @@ static int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)
 			vcpu->arch.eff_db[dr] = val;
 		break;
 	case 4:
-		/* fall through */
 	case 6:
 		if (!kvm_dr6_valid(val))
 			return -1; /* #GP */
 		vcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);
 		break;
 	case 5:
-		/* fall through */
 	default: /* 7 */
 		if (!kvm_dr7_valid(val))
 			return -1; /* #GP */
@@ -1153,12 +1151,10 @@ int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)
 		*val = vcpu->arch.db[array_index_nospec(dr, size)];
 		break;
 	case 4:
-		/* fall through */
 	case 6:
 		*val = vcpu->arch.dr6;
 		break;
 	case 5:
-		/* fall through */
 	default: /* 7 */
 		*val = vcpu->arch.dr7;
 		break;
@@ -3012,7 +3008,8 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 
 	case MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:
 	case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:
-		pr = true; /* fall through */
+		pr = true;
+		fallthrough;
 	case MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:
 	case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:
 		if (kvm_pmu_is_valid_msr(vcpu, msr))
@@ -4322,7 +4319,7 @@ static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,
 	case KVM_CAP_HYPERV_SYNIC2:
 		if (cap->args[0])
 			return -EINVAL;
-		/* fall through */
+		fallthrough;
 
 	case KVM_CAP_HYPERV_SYNIC:
 		if (!irqchip_in_kernel(vcpu->kvm))
@@ -8632,7 +8629,7 @@ static inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)
 		vcpu->arch.pv.pv_unhalted = false;
 		vcpu->arch.mp_state =
 			KVM_MP_STATE_RUNNABLE;
-		/* fall through */
+		fallthrough;
 	case KVM_MP_STATE_RUNNABLE:
 		vcpu->arch.apf.halted = false;
 		break;
diff --git a/arch/x86/lib/cmdline.c b/arch/x86/lib/cmdline.c
index 3261abb21ef4..70560c5f4a4f 100644
--- a/arch/x86/lib/cmdline.c
+++ b/arch/x86/lib/cmdline.c
@@ -59,7 +59,7 @@ __cmdline_find_option_bool(const char *cmdline, int max_cmdline_size,
 			state = st_wordcmp;
 			opptr = option;
 			wstart = pos;
-			/* fall through */
+			fallthrough;
 
 		case st_wordcmp:
 			if (!*opptr) {
@@ -90,7 +90,7 @@ __cmdline_find_option_bool(const char *cmdline, int max_cmdline_size,
 				break;
 			}
 			state = st_wordskip;
-			/* fall through */
+			fallthrough;
 
 		case st_wordskip:
 			if (!c)
@@ -152,7 +152,7 @@ __cmdline_find_option(const char *cmdline, int max_cmdline_size,
 
 			state = st_wordcmp;
 			opptr = option;
-			/* fall through */
+			fallthrough;
 
 		case st_wordcmp:
 			if ((c == '=') && !*opptr) {
@@ -173,7 +173,7 @@ __cmdline_find_option(const char *cmdline, int max_cmdline_size,
 				break;
 			}
 			state = st_wordskip;
-			/* fall through */
+			fallthrough;
 
 		case st_wordskip:
 			if (myisspace(c))
* Unmerged path arch/x86/lib/insn-eval.c
* Unmerged path arch/x86/math-emu/errors.c
* Unmerged path arch/x86/math-emu/fpu_trig.c
diff --git a/arch/x86/mm/ioremap.c b/arch/x86/mm/ioremap.c
index 10972a49a886..000334dca5fd 100644
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@ -564,7 +564,7 @@ static bool memremap_should_map_decrypted(resource_size_t phys_addr,
 		/* For SEV, these areas are encrypted */
 		if (sev_active())
 			break;
-		/* Fallthrough */
+		fallthrough;
 
 	case E820_TYPE_PRAM:
 		return true;
diff --git a/arch/xtensa/kernel/signal.c b/arch/xtensa/kernel/signal.c
index 20c1779f57c7..57e65f16ff71 100644
--- a/arch/xtensa/kernel/signal.c
+++ b/arch/xtensa/kernel/signal.c
@@ -438,7 +438,7 @@ static void do_signal(struct pt_regs *regs)
 						regs->areg[2] = -EINTR;
 						break;
 					}
-					/* fallthrough */
+					fallthrough;
 				case -ERESTARTNOINTR:
 					regs->areg[2] = regs->syscall;
 					regs->pc -= 3;
diff --git a/block/badblocks.c b/block/badblocks.c
index 91f7bcf979d3..a306b03ea901 100644
--- a/block/badblocks.c
+++ b/block/badblocks.c
@@ -533,7 +533,7 @@ ssize_t badblocks_store(struct badblocks *bb, const char *page, size_t len,
 	case 3:
 		if (newline != '\n')
 			return -EINVAL;
-		/* fall through */
+		fallthrough;
 	case 2:
 		if (length <= 0)
 			return -EINVAL;
diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index 014cb3d8ad1b..3d4d4638157a 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -4987,7 +4987,7 @@ bfq_set_next_ioprio_data(struct bfq_queue *bfqq, struct bfq_io_cq *bic)
 		pr_err("bdi %s: bfq: bad prio class %d\n",
 				bdi_dev_name(bfqq->bfqd->queue->backing_dev_info),
 				ioprio_class);
-		/* fall through */
+		fallthrough;
 	case IOPRIO_CLASS_NONE:
 		/*
 		 * No prio set, inherit CPU scheduling settings.
@@ -5119,7 +5119,7 @@ static struct bfq_queue **bfq_async_queue_prio(struct bfq_data *bfqd,
 		return &bfqg->async_bfqq[0][ioprio];
 	case IOPRIO_CLASS_NONE:
 		ioprio = IOPRIO_NORM;
-		/* fall through */
+		fallthrough;
 	case IOPRIO_CLASS_BE:
 		return &bfqg->async_bfqq[1][ioprio];
 	case IOPRIO_CLASS_IDLE:
diff --git a/block/blk-wbt.c b/block/blk-wbt.c
index d6e082b120d5..53e5b39a174f 100644
--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -527,7 +527,7 @@ static inline bool wbt_should_throttle(struct rq_wb *rwb, struct bio *bio)
 		if ((bio->bi_opf & (REQ_SYNC | REQ_IDLE)) ==
 		    (REQ_SYNC | REQ_IDLE))
 			return false;
-		/* fallthrough */
+		fallthrough;
 	case REQ_OP_DISCARD:
 		return true;
 	default:
diff --git a/block/ioprio.c b/block/ioprio.c
index f9821080c92c..1bd65e5280cf 100644
--- a/block/ioprio.c
+++ b/block/ioprio.c
@@ -70,7 +70,7 @@ int ioprio_check_cap(int ioprio)
 		case IOPRIO_CLASS_RT:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EPERM;
-			/* fall through */
+			fallthrough;
 			/* rt has prio field too */
 		case IOPRIO_CLASS_BE:
 			if (data >= IOPRIO_BE_NR || data < 0)
diff --git a/crypto/drbg.c b/crypto/drbg.c
index 662815c3a2ca..b05155cebe3a 100644
--- a/crypto/drbg.c
+++ b/crypto/drbg.c
@@ -1521,7 +1521,7 @@ static int drbg_prepare_hrng(struct drbg_state *drbg)
 
 	case -EALREADY:
 		err = 0;
-		/* fall through */
+		fallthrough;
 
 	default:
 		drbg->random_ready.func = NULL;
* Unmerged path crypto/tcrypt.c
diff --git a/drivers/accessibility/braille/braille_console.c b/drivers/accessibility/braille/braille_console.c
index dc34a5b8bcee..1aee9af5db00 100644
--- a/drivers/accessibility/braille/braille_console.c
+++ b/drivers/accessibility/braille/braille_console.c
@@ -303,7 +303,7 @@ static int vt_notifier_call(struct notifier_block *blk,
 			break;
 		case '\t':
 			c = ' ';
-			/* Fallthrough */
+			fallthrough;
 		default:
 			if (c < 32)
 				/* Ignore other control sequences */
* Unmerged path drivers/ata/ahci_brcm.c
diff --git a/drivers/ata/libahci_platform.c b/drivers/ata/libahci_platform.c
index 2a36e0d15ab0..e24a18ef8d07 100644
--- a/drivers/ata/libahci_platform.c
+++ b/drivers/ata/libahci_platform.c
@@ -295,7 +295,7 @@ static int ahci_platform_get_phy(struct ahci_host_priv *hpriv, u32 port,
 				node->name);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case -ENODEV:
 		/* continue normally */
 		hpriv->phys[port] = NULL;
diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index 278f3db7350b..168e8ecfcd34 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -207,7 +207,7 @@ struct ata_link *ata_link_next(struct ata_link *link, struct ata_port *ap,
 		case ATA_LITER_PMP_FIRST:
 			if (sata_pmp_attached(ap))
 				return ap->pmp_link;
-			/* fall through */
+			fallthrough;
 		case ATA_LITER_HOST_FIRST:
 			return &ap->link;
 		}
@@ -218,11 +218,11 @@ struct ata_link *ata_link_next(struct ata_link *link, struct ata_port *ap,
 		case ATA_LITER_HOST_FIRST:
 			if (sata_pmp_attached(ap))
 				return ap->pmp_link;
-			/* fall through */
+			fallthrough;
 		case ATA_LITER_PMP_FIRST:
 			if (unlikely(ap->slave_link))
 				return ap->slave_link;
-			/* fall through */
+			fallthrough;
 		case ATA_LITER_EDGE:
 			return NULL;
 		}
@@ -532,7 +532,7 @@ int atapi_cmd_type(u8 opcode)
 	case ATA_12:
 		if (atapi_passthru16)
 			return ATAPI_PASS_THRU;
-		/* fall thru */
+		fallthrough;
 	default:
 		return ATAPI_MISC;
 	}
@@ -1870,7 +1870,7 @@ int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 	switch (class) {
 	case ATA_DEV_SEMB:
 		class = ATA_DEV_ATA;	/* some hard drives report SEMB sig */
-		/* fall through */
+		fallthrough;
 	case ATA_DEV_ATA:
 	case ATA_DEV_ZAC:
 		tf.command = ATA_CMD_ID_ATA;
@@ -2970,7 +2970,7 @@ int ata_bus_probe(struct ata_port *ap)
 	case -ENODEV:
 		/* give it just one more chance */
 		tries[dev->devno] = min(tries[dev->devno], 1);
-		/* fall through */
+		fallthrough;
 	case -EIO:
 		if (tries[dev->devno] == 1) {
 			/* This is the last chance, better to slow
@@ -3464,7 +3464,7 @@ int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel)
 
 	case ATA_DNXFER_FORCE_PIO0:
 		pio_mask &= 1;
-		/* fall through */
+		fallthrough;
 	case ATA_DNXFER_FORCE_PIO:
 		mwdma_mask = 0;
 		udma_mask = 0;
@@ -5309,7 +5309,7 @@ void ata_qc_complete(struct ata_queued_cmd *qc)
 			    qc->tf.feature != SETFEATURES_RA_ON &&
 			    qc->tf.feature != SETFEATURES_RA_OFF)
 				break;
-			/* fall through */
+			fallthrough;
 		case ATA_CMD_INIT_DEV_PARAMS: /* CHS translation changed */
 		case ATA_CMD_SET_MULTI: /* multi_count changed */
 			/* revalidate device */
* Unmerged path drivers/ata/libata-eh.c
diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c
index fdc933568a39..9a6c62ee84b7 100644
--- a/drivers/ata/libata-scsi.c
+++ b/drivers/ata/libata-scsi.c
@@ -4447,7 +4447,7 @@ void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd)
 				ata_scsi_rbuf_fill(&args, ata_scsiop_inq_b6);
 				break;
 			}
-			/* Fallthrough */
+			fallthrough;
 		default:
 			ata_scsi_set_invalid_field(dev, cmd, 2, 0xff);
 			break;
@@ -4483,7 +4483,7 @@ void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd)
 	 * turning this into a no-op.
 	 */
 	case SYNCHRONIZE_CACHE:
-		/* fall through */
+		fallthrough;
 
 	/* no-op's, complete with success */
 	case REZERO_UNIT:
diff --git a/drivers/ata/pata_atp867x.c b/drivers/ata/pata_atp867x.c
index 3729e2448eb6..366fd55a7d99 100644
--- a/drivers/ata/pata_atp867x.c
+++ b/drivers/ata/pata_atp867x.c
@@ -171,7 +171,7 @@ static int atp867x_get_active_clocks_shifted(struct ata_port *ap,
 	default:
 		printk(KERN_WARNING "ATP867X: active %dclk is invalid. "
 			"Using 12clk.\n", clk);
-		/* fall through */
+		fallthrough;
 	case 9 ... 12:
 		clocks = 7;	/* 12 clk */
 		break;
@@ -204,7 +204,7 @@ static int atp867x_get_recover_clocks_shifted(unsigned int clk)
 	default:
 		printk(KERN_WARNING "ATP867X: recover %dclk is invalid. "
 			"Using default 12clk.\n", clk);
-		/* fall through */
+		fallthrough;
 	case 12:	/* default 12 clk */
 		clocks = 0;
 		break;
diff --git a/drivers/ata/pata_serverworks.c b/drivers/ata/pata_serverworks.c
index 57de02123c4c..171c848c11ff 100644
--- a/drivers/ata/pata_serverworks.c
+++ b/drivers/ata/pata_serverworks.c
@@ -368,7 +368,7 @@ static int serverworks_fixup(struct pci_dev *pdev)
 		break;
 	case PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:
 		ata_pci_bmdma_clear_simplex(pdev);
-		/* fall through */
+		fallthrough;
 	case PCI_DEVICE_ID_SERVERWORKS_CSB6IDE:
 	case PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2:
 		rc = serverworks_fixup_csb(pdev);
* Unmerged path drivers/ata/sata_mv.c
diff --git a/drivers/ata/sata_promise.c b/drivers/ata/sata_promise.c
index d032bf657f70..064bb17ceeba 100644
--- a/drivers/ata/sata_promise.c
+++ b/drivers/ata/sata_promise.c
@@ -659,7 +659,7 @@ static void pdc_qc_prep(struct ata_queued_cmd *qc)
 	switch (qc->tf.protocol) {
 	case ATA_PROT_DMA:
 		pdc_fill_sg(qc);
-		/*FALLTHROUGH*/
+		fallthrough;
 	case ATA_PROT_NODATA:
 		i = pdc_pkt_header(&qc->tf, qc->ap->bmdma_prd_dma,
 				   qc->dev->devno, pp->pkt);
@@ -674,7 +674,7 @@ static void pdc_qc_prep(struct ata_queued_cmd *qc)
 		break;
 	case ATAPI_PROT_DMA:
 		pdc_fill_sg(qc);
-		/*FALLTHROUGH*/
+		fallthrough;
 	case ATAPI_PROT_NODATA:
 		pdc_atapi_pkt(qc);
 		break;
@@ -1042,11 +1042,11 @@ static unsigned int pdc_qc_issue(struct ata_queued_cmd *qc)
 	case ATAPI_PROT_NODATA:
 		if (qc->dev->flags & ATA_DFLAG_CDB_INTR)
 			break;
-		/*FALLTHROUGH*/
+		fallthrough;
 	case ATA_PROT_NODATA:
 		if (qc->tf.flags & ATA_TFLAG_POLLING)
 			break;
-		/*FALLTHROUGH*/
+		fallthrough;
 	case ATAPI_PROT_DMA:
 	case ATA_PROT_DMA:
 		pdc_packet_start(qc);
diff --git a/drivers/ata/sata_sx4.c b/drivers/ata/sata_sx4.c
index 405e606a234d..3822630d5a01 100644
--- a/drivers/ata/sata_sx4.c
+++ b/drivers/ata/sata_sx4.c
@@ -683,7 +683,7 @@ static unsigned int pdc20621_qc_issue(struct ata_queued_cmd *qc)
 	case ATA_PROT_NODATA:
 		if (qc->tf.flags & ATA_TFLAG_POLLING)
 			break;
-		/*FALLTHROUGH*/
+		fallthrough;
 	case ATA_PROT_DMA:
 		pdc20621_packet_start(qc);
 		return 0;
diff --git a/drivers/atm/firestream.c b/drivers/atm/firestream.c
index 4e46dc9e41ad..f9a560686127 100644
--- a/drivers/atm/firestream.c
+++ b/drivers/atm/firestream.c
@@ -726,7 +726,7 @@ static void process_txdone_queue (struct fs_dev *dev, struct queue *q)
 
 		switch (STATUS_CODE (qe)) {
 		case 0x01: /* This is for AAL0 where we put the chip in streaming mode */
-			/* Fall through */
+			fallthrough;
 		case 0x02:
 			/* Process a real txdone entry. */
 			tmp = qe->p0;
diff --git a/drivers/atm/fore200e.c b/drivers/atm/fore200e.c
index 99a38115b0a8..a5b881295038 100644
--- a/drivers/atm/fore200e.c
+++ b/drivers/atm/fore200e.c
@@ -358,33 +358,33 @@ fore200e_shutdown(struct fore200e* fore200e)
     case FORE200E_STATE_COMPLETE:
 	kfree(fore200e->stats);
 
-	/* fall through */
+	fallthrough;
     case FORE200E_STATE_IRQ:
 	free_irq(fore200e->irq, fore200e->atm_dev);
 
-	/* fall through */
+	fallthrough;
     case FORE200E_STATE_ALLOC_BUF:
 	fore200e_free_rx_buf(fore200e);
 
-	/* fall through */
+	fallthrough;
     case FORE200E_STATE_INIT_BSQ:
 	fore200e_uninit_bs_queue(fore200e);
 
-	/* fall through */
+	fallthrough;
     case FORE200E_STATE_INIT_RXQ:
 	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_rxq.status);
 	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_rxq.rpd);
 
-	/* fall through */
+	fallthrough;
     case FORE200E_STATE_INIT_TXQ:
 	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_txq.status);
 	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_txq.tpd);
 
-	/* fall through */
+	fallthrough;
     case FORE200E_STATE_INIT_CMDQ:
 	fore200e->bus->dma_chunk_free(fore200e, &fore200e->host_cmdq.status);
 
-	/* fall through */
+	fallthrough;
     case FORE200E_STATE_INITIALIZE:
 	/* nothing to do for that state */
 
@@ -397,7 +397,7 @@ fore200e_shutdown(struct fore200e* fore200e)
     case FORE200E_STATE_MAP:
 	fore200e->bus->unmap(fore200e);
 
-	/* fall through */
+	fallthrough;
     case FORE200E_STATE_CONFIGURE:
 	/* nothing to do for that state */
 
diff --git a/drivers/atm/he.c b/drivers/atm/he.c
index 29f102dcfec4..266d85e007b1 100644
--- a/drivers/atm/he.c
+++ b/drivers/atm/he.c
@@ -1945,14 +1945,14 @@ he_tasklet(unsigned long data)
 		switch (type) {
 			case ITYPE_RBRQ_THRESH:
 				HPRINTK("rbrq%d threshold\n", group);
-				/* fall through */
+				fallthrough;
 			case ITYPE_RBRQ_TIMER:
 				if (he_service_rbrq(he_dev, group))
 					he_service_rbpl(he_dev, group);
 				break;
 			case ITYPE_TBRQ_THRESH:
 				HPRINTK("tbrq%d threshold\n", group);
-				/* fall through */
+				fallthrough;
 			case ITYPE_TPD_COMPLETE:
 				he_service_tbrq(he_dev, group);
 				break;
diff --git a/drivers/atm/idt77105.c b/drivers/atm/idt77105.c
index 0a67487c0b1d..9b6853722169 100644
--- a/drivers/atm/idt77105.c
+++ b/drivers/atm/idt77105.c
@@ -191,7 +191,7 @@ static int idt77105_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)
 	switch (cmd) {
 		case IDT77105_GETSTATZ:
 			if (!capable(CAP_NET_ADMIN)) return -EPERM;
-			/* fall through */
+			fallthrough;
 		case IDT77105_GETSTAT:
 			return fetch_stats(dev, arg, cmd == IDT77105_GETSTATZ);
 		case ATM_SETLOOP:
diff --git a/drivers/atm/lanai.c b/drivers/atm/lanai.c
index 5f8e009b2da1..83a0269e79f1 100644
--- a/drivers/atm/lanai.c
+++ b/drivers/atm/lanai.c
@@ -2023,7 +2023,7 @@ static int lanai_normalize_ci(struct lanai_dev *lanai,
 	switch (*vpip) {
 		case ATM_VPI_ANY:
 			*vpip = 0;
-			/* FALLTHROUGH */
+			fallthrough;
 		case 0:
 			break;
 		default:
diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 2c288d1f42bb..aab0f1724155 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1448,7 +1448,7 @@ static int zatm_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)
 	switch (cmd) {
 		case ZATM_GETPOOLZ:
 			if (!capable(CAP_NET_ADMIN)) return -EPERM;
-			/* fall through */
+			fallthrough;
 		case ZATM_GETPOOL:
 			{
 				struct zatm_pool_info info;
diff --git a/drivers/auxdisplay/panel.c b/drivers/auxdisplay/panel.c
index 3b25a643058c..f689af16c9c3 100644
--- a/drivers/auxdisplay/panel.c
+++ b/drivers/auxdisplay/panel.c
@@ -1368,7 +1368,7 @@ static void panel_process_inputs(void)
 				break;
 			input->rise_timer = 0;
 			input->state = INPUT_ST_RISING;
-			/* fall through */
+			fallthrough;
 		case INPUT_ST_RISING:
 			if ((phys_curr & input->mask) != input->value) {
 				input->state = INPUT_ST_LOW;
@@ -1381,11 +1381,11 @@ static void panel_process_inputs(void)
 			}
 			input->high_timer = 0;
 			input->state = INPUT_ST_HIGH;
-			/* fall through */
+			fallthrough;
 		case INPUT_ST_HIGH:
 			if (input_state_high(input))
 				break;
-			/* fall through */
+			fallthrough;
 		case INPUT_ST_FALLING:
 			input_state_falling(input);
 		}
diff --git a/drivers/base/firmware_loader/fallback.c b/drivers/base/firmware_loader/fallback.c
index ccd6212d3b91..7433d5c6e459 100644
--- a/drivers/base/firmware_loader/fallback.c
+++ b/drivers/base/firmware_loader/fallback.c
@@ -311,10 +311,10 @@ static ssize_t firmware_loading_store(struct device *dev,
 			}
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	default:
 		dev_err(dev, "%s: unexpected value (%d)\n", __func__, loading);
-		/* fallthrough */
+		fallthrough;
 	case -1:
 		fw_load_abort(fw_sysfs);
 		break;
diff --git a/drivers/block/aoe/aoecmd.c b/drivers/block/aoe/aoecmd.c
index 3cf9bc5d8d95..6dba41395155 100644
--- a/drivers/block/aoe/aoecmd.c
+++ b/drivers/block/aoe/aoecmd.c
@@ -1135,7 +1135,7 @@ noskb:		if (buf)
 			break;
 		}
 		bvcpy(skb, f->buf->bio, f->iter, n);
-		/* fall through */
+		fallthrough;
 	case ATA_CMD_PIO_WRITE:
 	case ATA_CMD_PIO_WRITE_EXT:
 		spin_lock_irq(&d->lock);
* Unmerged path drivers/block/ataflop.c
* Unmerged path drivers/block/drbd/drbd_int.h
diff --git a/drivers/block/drbd/drbd_main.c b/drivers/block/drbd/drbd_main.c
index c76b666c7573..5596912bc4f6 100644
--- a/drivers/block/drbd/drbd_main.c
+++ b/drivers/block/drbd/drbd_main.c
@@ -441,7 +441,7 @@ int drbd_thread_start(struct drbd_thread *thi)
 		thi->t_state = RESTARTING;
 		drbd_info(resource, "Restarting %s thread (from %s [%d])\n",
 				thi->name, current->comm, current->pid);
-		/* fall through */
+		fallthrough;
 	case RUNNING:
 	case RESTARTING:
 	default:
diff --git a/drivers/block/drbd/drbd_nl.c b/drivers/block/drbd/drbd_nl.c
index 0d6d0d540c3f..7fe41448ae7f 100644
--- a/drivers/block/drbd/drbd_nl.c
+++ b/drivers/block/drbd/drbd_nl.c
@@ -3830,7 +3830,7 @@ static int nla_put_status_info(struct sk_buff *skb, struct drbd_device *device,
 			if (nla_put_u32(skb, T_helper_exit_code,
 					sib->helper_exit_code))
 				goto nla_put_failure;
-			/* fall through */
+			fallthrough;
 		case SIB_HELPER_PRE:
 			if (nla_put_string(skb, T_helper, sib->helper_name))
 				goto nla_put_failure;
* Unmerged path drivers/block/drbd/drbd_receiver.c
* Unmerged path drivers/block/drbd/drbd_req.c
* Unmerged path drivers/block/floppy.c
diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index 9ac022be6aec..2126bde6e2cb 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -1733,7 +1733,7 @@ static int lo_ioctl(struct block_device *bdev, fmode_t mode,
 	case LOOP_SET_BLOCK_SIZE:
 		if (!(mode & FMODE_WRITE) && !capable(CAP_SYS_ADMIN))
 			return -EPERM;
-		/* Fall through */
+		fallthrough;
 	default:
 		err = lo_simple_ioctl(lo, cmd, arg);
 		break;
@@ -1881,7 +1881,7 @@ static int lo_compat_ioctl(struct block_device *bdev, fmode_t mode,
 	case LOOP_SET_STATUS64:
 	case LOOP_CONFIGURE:
 		arg = (unsigned long) compat_ptr(arg);
-		/* fall through */
+		fallthrough;
 	case LOOP_SET_FD:
 	case LOOP_CHANGE_FD:
 	case LOOP_SET_BLOCK_SIZE:
diff --git a/drivers/block/paride/pd.c b/drivers/block/paride/pd.c
index 0ff9b12d0e35..6d26dd5bf5f9 100644
--- a/drivers/block/paride/pd.c
+++ b/drivers/block/paride/pd.c
@@ -440,7 +440,7 @@ static void run_fsm(void)
 				pd_claimed = 1;
 				if (!pi_schedule_claimed(pi_current, run_fsm))
 					return;
-				/* fall through */
+				fallthrough;
 			case 1:
 				pd_claimed = 2;
 				pi_current->proto->connect(pi_current);
@@ -465,7 +465,7 @@ static void run_fsm(void)
 				if (stop)
 					return;
 				}
-				/* fall through */
+				fallthrough;
 			case Hold:
 				schedule_fsm();
 				return;
* Unmerged path drivers/block/pktcdvd.c
diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index d16fcad4775c..d70bc27b5bf8 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -3379,7 +3379,7 @@ static bool rbd_obj_advance_copyup(struct rbd_obj_request *obj_req, int *result)
 	case __RBD_OBJ_COPYUP_OBJECT_MAPS:
 		if (!pending_result_dec(&obj_req->pending, result))
 			return false;
-		/* fall through */
+		fallthrough;
 	case RBD_OBJ_COPYUP_OBJECT_MAPS:
 		if (*result) {
 			rbd_warn(rbd_dev, "snap object map update failed: %d",
@@ -3398,7 +3398,7 @@ static bool rbd_obj_advance_copyup(struct rbd_obj_request *obj_req, int *result)
 	case __RBD_OBJ_COPYUP_WRITE_OBJECT:
 		if (!pending_result_dec(&obj_req->pending, result))
 			return false;
-		/* fall through */
+		fallthrough;
 	case RBD_OBJ_COPYUP_WRITE_OBJECT:
 		return true;
 	default:
@@ -3485,7 +3485,7 @@ static bool rbd_obj_advance_write(struct rbd_obj_request *obj_req, int *result)
 	case __RBD_OBJ_WRITE_COPYUP:
 		if (!rbd_obj_advance_copyup(obj_req, result))
 			return false;
-		/* fall through */
+		fallthrough;
 	case RBD_OBJ_WRITE_COPYUP:
 		if (*result) {
 			rbd_warn(rbd_dev, "copyup failed: %d", *result);
@@ -3678,7 +3678,7 @@ static bool rbd_img_advance(struct rbd_img_request *img_req, int *result)
 	case __RBD_IMG_OBJECT_REQUESTS:
 		if (!pending_result_dec(&img_req->pending, result))
 			return false;
-		/* fall through */
+		fallthrough;
 	case RBD_IMG_OBJECT_REQUESTS:
 		return true;
 	default:
* Unmerged path drivers/block/rsxx/core.c
diff --git a/drivers/block/skd_main.c b/drivers/block/skd_main.c
index 59f10a849288..a79391394d7c 100644
--- a/drivers/block/skd_main.c
+++ b/drivers/block/skd_main.c
@@ -1436,7 +1436,7 @@ static void skd_resolve_req_exception(struct skd_device *skdev,
 			blk_mq_requeue_request(req, true);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 
 	case SKD_CHECK_STATUS_REPORT_ERROR:
 	default:
diff --git a/drivers/block/xen-blkback/blkback.c b/drivers/block/xen-blkback/blkback.c
index b55b245e8052..528c5135128b 100644
--- a/drivers/block/xen-blkback/blkback.c
+++ b/drivers/block/xen-blkback/blkback.c
@@ -1251,7 +1251,7 @@ static int dispatch_rw_block_io(struct xen_blkif_ring *ring,
 		break;
 	case BLKIF_OP_WRITE_BARRIER:
 		drain = true;
-		/* fall through */
+		fallthrough;
 	case BLKIF_OP_FLUSH_DISKCACHE:
 		ring->st_f_req++;
 		operation = REQ_OP_WRITE;
diff --git a/drivers/block/xen-blkback/xenbus.c b/drivers/block/xen-blkback/xenbus.c
index a4bc74e72c39..a937b5abd396 100644
--- a/drivers/block/xen-blkback/xenbus.c
+++ b/drivers/block/xen-blkback/xenbus.c
@@ -817,7 +817,7 @@ static void frontend_changed(struct xenbus_device *dev,
 		xenbus_switch_state(dev, XenbusStateClosed);
 		if (xenbus_dev_is_online(dev))
 			break;
-		/* fall through */
+		fallthrough;
 		/* if not online */
 	case XenbusStateUnknown:
 		/* implies xen_blkif_disconnect() via xen_blkbk_remove() */
diff --git a/drivers/block/xen-blkfront.c b/drivers/block/xen-blkfront.c
index 164c1939ed31..477b8f09e2fe 100644
--- a/drivers/block/xen-blkfront.c
+++ b/drivers/block/xen-blkfront.c
@@ -1389,7 +1389,6 @@ static enum blk_req_status blkif_rsp_to_req_status(int rsp)
 	case BLKIF_RSP_EOPNOTSUPP:
 		return REQ_EOPNOTSUPP;
 	case BLKIF_RSP_ERROR:
-		/* Fallthrough. */
 	default:
 		return REQ_ERROR;
 	}
@@ -1629,7 +1628,7 @@ static irqreturn_t blkif_interrupt(int irq, void *dev_id)
 				info->feature_flush = 0;
 				xlvbd_flush(info);
 			}
-			/* fall through */
+			fallthrough;
 		case BLKIF_OP_READ:
 		case BLKIF_OP_WRITE:
 			if (unlikely(bret->status != BLKIF_RSP_OKAY))
@@ -2454,7 +2453,7 @@ static void blkback_changed(struct xenbus_device *dev,
 	case XenbusStateClosed:
 		if (dev->state == XenbusStateClosed)
 			break;
-		/* fall through */
+		fallthrough;
 	case XenbusStateClosing:
 		if (info)
 			blkfront_closing(info);
* Unmerged path drivers/bus/ti-sysc.c
diff --git a/drivers/char/agp/ali-agp.c b/drivers/char/agp/ali-agp.c
index 89527bae4602..760d9a931289 100644
--- a/drivers/char/agp/ali-agp.c
+++ b/drivers/char/agp/ali-agp.c
@@ -357,7 +357,7 @@ static int agp_ali_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		default:
 			break;
 		}
-		/*FALLTHROUGH*/
+		fallthrough;
 	default:
 		bridge->driver = &ali_generic_bridge;
 	}
diff --git a/drivers/char/ipmi/kcs_bmc.c b/drivers/char/ipmi/kcs_bmc.c
index ed4dc3b1843e..f292e74bd4a5 100644
--- a/drivers/char/ipmi/kcs_bmc.c
+++ b/drivers/char/ipmi/kcs_bmc.c
@@ -99,7 +99,7 @@ static void kcs_bmc_handle_data(struct kcs_bmc *kcs_bmc)
 	switch (kcs_bmc->phase) {
 	case KCS_PHASE_WRITE_START:
 		kcs_bmc->phase = KCS_PHASE_WRITE_DATA;
-		/* fall through */
+		fallthrough;
 
 	case KCS_PHASE_WRITE_DATA:
 		if (kcs_bmc->data_in_idx < KCS_MSG_BUFSIZ) {
* Unmerged path drivers/char/lp.c
* Unmerged path drivers/char/mem.c
* Unmerged path drivers/char/nvram.c
diff --git a/drivers/clocksource/cadence_ttc_timer.c b/drivers/clocksource/cadence_ttc_timer.c
index 29d51755e18b..35900e390ac1 100644
--- a/drivers/clocksource/cadence_ttc_timer.c
+++ b/drivers/clocksource/cadence_ttc_timer.c
@@ -315,7 +315,7 @@ static int ttc_rate_change_clocksource_cb(struct notifier_block *nb,
 		/* restore original register value */
 		writel_relaxed(ttccs->scale_clk_ctrl_reg_old,
 			       ttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);
-		/* fall through */
+		fallthrough;
 	default:
 		return NOTIFY_DONE;
 	}
@@ -398,7 +398,7 @@ static int ttc_rate_change_clockevent_cb(struct notifier_block *nb,
 
 		clockevents_update_freq(&ttcce->ce, ndata->new_rate / PRESCALE);
 
-		/* fall through */
+		fallthrough;
 	case PRE_RATE_CHANGE:
 	case ABORT_RATE_CHANGE:
 	default:
diff --git a/drivers/cpufreq/p4-clockmod.c b/drivers/cpufreq/p4-clockmod.c
index 911206243050..6386722e6d48 100644
--- a/drivers/cpufreq/p4-clockmod.c
+++ b/drivers/cpufreq/p4-clockmod.c
@@ -134,7 +134,7 @@ static unsigned int cpufreq_p4_get_frequency(struct cpuinfo_x86 *c)
 			return speedstep_get_frequency(SPEEDSTEP_CPU_PCORE);
 		case 0x0D: /* Pentium M (Dothan) */
 			p4clockmod_driver.flags |= CPUFREQ_CONST_LOOPS;
-			/* fall through */
+			fallthrough;
 		case 0x09: /* Pentium M (Banias) */
 			return speedstep_get_frequency(SPEEDSTEP_CPU_PM);
 		}
diff --git a/drivers/cpufreq/speedstep-lib.c b/drivers/cpufreq/speedstep-lib.c
index 5c4f8f07c5a6..a13a2d1e444e 100644
--- a/drivers/cpufreq/speedstep-lib.c
+++ b/drivers/cpufreq/speedstep-lib.c
@@ -366,7 +366,7 @@ enum speedstep_processor speedstep_detect_processor(void)
 			} else
 				return SPEEDSTEP_CPU_PIII_C;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		return 0;
 	}
* Unmerged path drivers/cpufreq/ti-cpufreq.c
diff --git a/drivers/crypto/axis/artpec6_crypto.c b/drivers/crypto/axis/artpec6_crypto.c
index 0fb8bbf41a8d..0d292086e138 100644
--- a/drivers/crypto/axis/artpec6_crypto.c
+++ b/drivers/crypto/axis/artpec6_crypto.c
@@ -2310,7 +2310,7 @@ static int artpec6_crypto_prepare_submit_hash(struct ahash_request *req)
 
 	case ARTPEC6_CRYPTO_PREPARE_HASH_NO_START:
 		ret = 0;
-		/* Fallthrough */
+		fallthrough;
 
 	default:
 		artpec6_crypto_common_destroy(&req_ctx->common);
diff --git a/drivers/crypto/cavium/cpt/cptvf_reqmanager.c b/drivers/crypto/cavium/cpt/cptvf_reqmanager.c
index b0ba4331944b..231e445bf8c0 100644
--- a/drivers/crypto/cavium/cpt/cptvf_reqmanager.c
+++ b/drivers/crypto/cavium/cpt/cptvf_reqmanager.c
@@ -92,11 +92,11 @@ static int setup_sgio_components(struct cpt_vf *cptvf, struct buf_ptr *list,
 	case 3:
 		sg_ptr->u.s.len2 = cpu_to_be16(list[i * 4 + 2].size);
 		sg_ptr->ptr2 = cpu_to_be64(list[i * 4 + 2].dma_addr);
-		/* Fall through */
+		fallthrough;
 	case 2:
 		sg_ptr->u.s.len1 = cpu_to_be16(list[i * 4 + 1].size);
 		sg_ptr->ptr1 = cpu_to_be64(list[i * 4 + 1].dma_addr);
-		/* Fall through */
+		fallthrough;
 	case 1:
 		sg_ptr->u.s.len0 = cpu_to_be16(list[i * 4 + 0].size);
 		sg_ptr->ptr0 = cpu_to_be64(list[i * 4 + 0].dma_addr);
diff --git a/drivers/crypto/chelsio/chcr_ktls.c b/drivers/crypto/chelsio/chcr_ktls.c
index 9dda5445dbce..f28772c77161 100644
--- a/drivers/crypto/chelsio/chcr_ktls.c
+++ b/drivers/crypto/chelsio/chcr_ktls.c
@@ -137,7 +137,7 @@ static int chcr_ktls_update_connection_state(struct chcr_ktls_info *tx_info,
 			break;
 		/* update to the next state and also initialize TCB */
 		tx_info->connection_state = new_state;
-		/* FALLTHRU */
+		fallthrough;
 	case KTLS_CONN_ACT_OPEN_RPL:
 		/* if we are stuck in this state, means tcb init might not
 		 * received by HW, try sending it again.
@@ -152,7 +152,7 @@ static int chcr_ktls_update_connection_state(struct chcr_ktls_info *tx_info,
 			break;
 		/* update to the next state and check if l2t_state is valid  */
 		tx_info->connection_state = new_state;
-		/* FALLTHRU */
+		fallthrough;
 	case KTLS_CONN_SET_TCB_RPL:
 		/* Check if l2t state is valid, then move to ready state. */
 		if (cxgb4_check_l2t_valid(tx_info->l2te)) {
* Unmerged path drivers/crypto/marvell/octeontx/otx_cptvf_reqmgr.c
diff --git a/drivers/crypto/qat/qat_common/adf_pf2vf_msg.c b/drivers/crypto/qat/qat_common/adf_pf2vf_msg.c
index 519fd5acf713..8b090b7ae8c6 100644
--- a/drivers/crypto/qat/qat_common/adf_pf2vf_msg.c
+++ b/drivers/crypto/qat/qat_common/adf_pf2vf_msg.c
@@ -340,7 +340,7 @@ static int adf_vf2pf_request_version(struct adf_accel_dev *accel_dev)
 		/* VF is newer than PF and decides whether it is compatible */
 		if (accel_dev->vf.pf_version >= hw_data->min_iov_compat_ver)
 			break;
-		/* fall through */
+		fallthrough;
 	case ADF_PF2VF_VF_INCOMPATIBLE:
 		dev_err(&GET_DEV(accel_dev),
 			"PF (vers %d) and VF (vers %d) are not compatible\n",
diff --git a/drivers/crypto/qat/qat_common/qat_uclo.c b/drivers/crypto/qat/qat_common/qat_uclo.c
index 978d1fce0e74..5d1f28cd6680 100644
--- a/drivers/crypto/qat/qat_common/qat_uclo.c
+++ b/drivers/crypto/qat/qat_common/qat_uclo.c
@@ -753,7 +753,7 @@ static int qat_uclo_init_reg(struct icp_qat_fw_loader_handle *handle,
 	case ICP_GPA_ABS:
 	case ICP_GPB_ABS:
 		ctx_mask = 0;
-		/* fall through */
+		fallthrough;
 	case ICP_GPA_REL:
 	case ICP_GPB_REL:
 		return qat_hal_init_gpr(handle, ae, ctx_mask, reg_type,
@@ -763,7 +763,7 @@ static int qat_uclo_init_reg(struct icp_qat_fw_loader_handle *handle,
 	case ICP_SR_RD_ABS:
 	case ICP_DR_RD_ABS:
 		ctx_mask = 0;
-		/* fall through */
+		fallthrough;
 	case ICP_SR_REL:
 	case ICP_DR_REL:
 	case ICP_SR_RD_REL:
@@ -773,7 +773,7 @@ static int qat_uclo_init_reg(struct icp_qat_fw_loader_handle *handle,
 	case ICP_SR_WR_ABS:
 	case ICP_DR_WR_ABS:
 		ctx_mask = 0;
-		/* fall through */
+		fallthrough;
 	case ICP_SR_WR_REL:
 	case ICP_DR_WR_REL:
 		return qat_hal_init_wr_xfer(handle, ae, ctx_mask, reg_type,
* Unmerged path drivers/crypto/ux500/cryp/cryp.c
diff --git a/drivers/dma/amba-pl08x.c b/drivers/dma/amba-pl08x.c
index 97483df1f82e..abad6b49cd5b 100644
--- a/drivers/dma/amba-pl08x.c
+++ b/drivers/dma/amba-pl08x.c
@@ -1769,7 +1769,7 @@ static u32 pl08x_memcpy_cctl(struct pl08x_driver_data *pl08x)
 	default:
 		dev_err(&pl08x->adev->dev,
 			"illegal burst size for memcpy, set to 1\n");
-		/* Fall through */
+		fallthrough;
 	case PL08X_BURST_SZ_1:
 		cctl |= PL080_BSIZE_1 << PL080_CONTROL_SB_SIZE_SHIFT |
 			PL080_BSIZE_1 << PL080_CONTROL_DB_SIZE_SHIFT;
@@ -1808,7 +1808,7 @@ static u32 pl08x_memcpy_cctl(struct pl08x_driver_data *pl08x)
 	default:
 		dev_err(&pl08x->adev->dev,
 			"illegal bus width for memcpy, set to 8 bits\n");
-		/* Fall through */
+		fallthrough;
 	case PL08X_BUS_WIDTH_8_BITS:
 		cctl |= PL080_WIDTH_8BIT << PL080_CONTROL_SWIDTH_SHIFT |
 			PL080_WIDTH_8BIT << PL080_CONTROL_DWIDTH_SHIFT;
@@ -1852,7 +1852,7 @@ static u32 pl08x_ftdmac020_memcpy_cctl(struct pl08x_driver_data *pl08x)
 	default:
 		dev_err(&pl08x->adev->dev,
 			"illegal bus width for memcpy, set to 8 bits\n");
-		/* Fall through */
+		fallthrough;
 	case PL08X_BUS_WIDTH_8_BITS:
 		cctl |= PL080_WIDTH_8BIT << FTDMAC020_LLI_SRC_WIDTH_SHIFT |
 			PL080_WIDTH_8BIT << FTDMAC020_LLI_DST_WIDTH_SHIFT;
@@ -2625,7 +2625,7 @@ static int pl08x_of_probe(struct amba_device *adev,
 	switch (val) {
 	default:
 		dev_err(&adev->dev, "illegal burst size for memcpy, set to 1\n");
-		/* Fall through */
+		fallthrough;
 	case 1:
 		pd->memcpy_burst_size = PL08X_BURST_SZ_1;
 		break;
@@ -2660,7 +2660,7 @@ static int pl08x_of_probe(struct amba_device *adev,
 	switch (val) {
 	default:
 		dev_err(&adev->dev, "illegal bus width for memcpy, set to 8 bits\n");
-		/* Fall through */
+		fallthrough;
 	case 8:
 		pd->memcpy_bus_width = PL08X_BUS_WIDTH_8_BITS;
 		break;
* Unmerged path drivers/dma/fsldma.c
* Unmerged path drivers/dma/imx-dma.c
* Unmerged path drivers/dma/nbpfaxi.c
* Unmerged path drivers/dma/pl330.c
diff --git a/drivers/dma/sh/shdma-base.c b/drivers/dma/sh/shdma-base.c
index 6b5626e299b2..b3899ff63faf 100644
--- a/drivers/dma/sh/shdma-base.c
+++ b/drivers/dma/sh/shdma-base.c
@@ -386,7 +386,7 @@ static dma_async_tx_callback __ld_cleanup(struct shdma_chan *schan, bool all)
 			switch (desc->mark) {
 			case DESC_COMPLETED:
 				desc->mark = DESC_WAITING;
-				/* Fall through */
+				fallthrough;
 			case DESC_WAITING:
 				if (head_acked)
 					async_tx_ack(&desc->async_tx);
* Unmerged path drivers/edac/amd64_edac.c
diff --git a/drivers/edac/pnd2_edac.c b/drivers/edac/pnd2_edac.c
index 9f80411b8c60..8abc0547d3bb 100644
--- a/drivers/edac/pnd2_edac.c
+++ b/drivers/edac/pnd2_edac.c
@@ -206,7 +206,7 @@ static int apl_rd_reg(int port, int off, int op, void *data, size_t sz, char *na
 	switch (sz) {
 	case 8:
 		ret = _apl_rd_reg(port, off + 4, op, (u32 *)(data + 4));
-		/* fall through */
+		fallthrough;
 	case 4:
 		ret |= _apl_rd_reg(port, off, op, (u32 *)data);
 		pnd2_printk(KERN_DEBUG, "%s=%x%08x ret=%d\n", name,
* Unmerged path drivers/firewire/core-device.c
* Unmerged path drivers/firewire/core-iso.c
* Unmerged path drivers/firewire/core-topology.c
diff --git a/drivers/firewire/core-transaction.c b/drivers/firewire/core-transaction.c
index 4372f9e4b0da..f04aca6bc8ad 100644
--- a/drivers/firewire/core-transaction.c
+++ b/drivers/firewire/core-transaction.c
@@ -1100,14 +1100,14 @@ static void handle_registers(struct fw_card *card, struct fw_request *request,
 			rcode = RCODE_ADDRESS_ERROR;
 			break;
 		}
-		/* else fall through */
+		fallthrough;
 
 	case CSR_NODE_IDS:
 		/*
 		 * per IEEE 1394-2008 8.3.22.3, not IEEE 1394.1-2004 3.2.8
 		 * and 9.6, but interoperable with IEEE 1394.1-2004 bridges
 		 */
-		/* fall through */
+		fallthrough;
 
 	case CSR_STATE_CLEAR:
 	case CSR_STATE_SET:
diff --git a/drivers/firewire/ohci.c b/drivers/firewire/ohci.c
index 7183ab34269e..13c1c8cf238c 100644
--- a/drivers/firewire/ohci.c
+++ b/drivers/firewire/ohci.c
@@ -1508,7 +1508,7 @@ static int handle_at_packet(struct context *context,
 			packet->ack = RCODE_GENERATION;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 
 	default:
 		packet->ack = RCODE_SEND_ERROR;
@@ -3067,7 +3067,7 @@ static int ohci_start_iso(struct fw_iso_context *base,
 
 	case FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL:
 		control |= IR_CONTEXT_BUFFER_FILL|IR_CONTEXT_MULTI_CHANNEL_MODE;
-		/* fall through */
+		fallthrough;
 	case FW_ISO_CONTEXT_RECEIVE:
 		index = ctx - ohci->ir_context_list;
 		match = (tags << 28) | (sync << 8) | ctx->base.channel;
* Unmerged path drivers/gpio/gpio-aspeed-sgpio.c
diff --git a/drivers/gpio/gpio-aspeed.c b/drivers/gpio/gpio-aspeed.c
index b31ae16170e7..e473f1683d4d 100644
--- a/drivers/gpio/gpio-aspeed.c
+++ b/drivers/gpio/gpio-aspeed.c
@@ -422,16 +422,16 @@ static int aspeed_gpio_set_type(struct irq_data *d, unsigned int type)
 	switch (type & IRQ_TYPE_SENSE_MASK) {
 	case IRQ_TYPE_EDGE_BOTH:
 		type2 |= bit;
-		/* fall through */
+		fallthrough;
 	case IRQ_TYPE_EDGE_RISING:
 		type0 |= bit;
-		/* fall through */
+		fallthrough;
 	case IRQ_TYPE_EDGE_FALLING:
 		handler = handle_edge_irq;
 		break;
 	case IRQ_TYPE_LEVEL_HIGH:
 		type0 |= bit;
-		/* fall through */
+		fallthrough;
 	case IRQ_TYPE_LEVEL_LOW:
 		type1 |= bit;
 		handler = handle_level_irq;
diff --git a/drivers/gpio/gpio-ath79.c b/drivers/gpio/gpio-ath79.c
index 684e9d6d6623..2a86c88ec543 100644
--- a/drivers/gpio/gpio-ath79.c
+++ b/drivers/gpio/gpio-ath79.c
@@ -132,7 +132,7 @@ static int ath79_gpio_irq_set_type(struct irq_data *data,
 
 	case IRQ_TYPE_LEVEL_HIGH:
 		polarity |= mask;
-		/* fall through */
+		fallthrough;
 	case IRQ_TYPE_LEVEL_LOW:
 		type |= mask;
 		break;
diff --git a/drivers/gpio/gpio-eic-sprd.c b/drivers/gpio/gpio-eic-sprd.c
index e0d6a0a7bc69..eba387660254 100644
--- a/drivers/gpio/gpio-eic-sprd.c
+++ b/drivers/gpio/gpio-eic-sprd.c
@@ -604,14 +604,12 @@ static int sprd_eic_probe(struct platform_device *pdev)
 		sprd_eic->chip.free = sprd_eic_free;
 		sprd_eic->chip.set_config = sprd_eic_set_config;
 		sprd_eic->chip.set = sprd_eic_set;
-		/* fall-through */
+		fallthrough;
 	case SPRD_EIC_ASYNC:
-		/* fall-through */
 	case SPRD_EIC_SYNC:
 		sprd_eic->chip.get = sprd_eic_get;
 		break;
 	case SPRD_EIC_LATCH:
-		/* fall-through */
 	default:
 		break;
 	}
diff --git a/drivers/gpio/gpio-stmpe.c b/drivers/gpio/gpio-stmpe.c
index 8d6a5a7e612d..af5e7c329da3 100644
--- a/drivers/gpio/gpio-stmpe.c
+++ b/drivers/gpio/gpio-stmpe.c
@@ -305,7 +305,7 @@ static void stmpe_dbg_show_one(struct seq_file *s,
 			if (ret < 0)
 				return;
 			edge_det = !!(ret & mask);
-			/* fall through */
+			fallthrough;
 		case STMPE1801:
 			rise_reg = stmpe->regs[STMPE_IDX_GPRER_LSB + bank];
 			fall_reg = stmpe->regs[STMPE_IDX_GPFER_LSB + bank];
@@ -318,7 +318,7 @@ static void stmpe_dbg_show_one(struct seq_file *s,
 			if (ret < 0)
 				return;
 			fall = !!(ret & mask);
-			/* fall through */
+			fallthrough;
 		case STMPE801:
 		case STMPE1600:
 			irqen_reg = stmpe->regs[STMPE_IDX_IEGPIOR_LSB + bank];
diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 0017367e94ee..f649aeb8ab7e 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -1264,7 +1264,7 @@ static int acpi_gpio_package_count(const union acpi_object *obj)
 		switch (element->type) {
 		case ACPI_TYPE_LOCAL_REFERENCE:
 			element += 3;
-			/* Fallthrough */
+			fallthrough;
 		case ACPI_TYPE_INTEGER:
 			element++;
 			count++;
* Unmerged path drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v10_3.c
diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
index fa245973de12..20fa65cf1617 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
@@ -3235,7 +3235,7 @@ static void gfx_v8_0_tiling_mode_table_init(struct amdgpu_device *adev)
 		dev_warn(adev->dev,
 			 "Unknown chip type (%d) in function gfx_v8_0_tiling_mode_table_init() falling through to CHIP_CARRIZO\n",
 			 adev->asic_type);
-		/* fall through */
+		fallthrough;
 
 	case CHIP_CARRIZO:
 		modearray[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index cc0c273a86f9..2261a41ce64c 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
@@ -1249,7 +1249,7 @@ static void gmc_v9_0_init_golden_registers(struct amdgpu_device *adev)
 	case CHIP_VEGA10:
 		if (amdgpu_sriov_vf(adev))
 			break;
-		/* fall through */
+		fallthrough;
 	case CHIP_VEGA20:
 		soc15_program_register_sequence(adev,
 						golden_settings_mmhub_1_0_0,
diff --git a/drivers/gpu/drm/amd/amdgpu/si_dpm.c b/drivers/gpu/drm/amd/amdgpu/si_dpm.c
index 4cb4c891120b..3189b2079aaa 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_dpm.c
@@ -6217,7 +6217,7 @@ static void si_request_link_speed_change_before_state_change(struct amdgpu_devic
 			si_pi->force_pcie_gen = AMDGPU_PCIE_GEN2;
 			if (current_link_speed == AMDGPU_PCIE_GEN2)
 				break;
-			/* fall through */
+			fallthrough;
 		case AMDGPU_PCIE_GEN2:
 			if (amdgpu_acpi_pcie_performance_request(adev, PCIE_PERF_REQ_PECI_GEN2, false) == 0)
 				break;
* Unmerged path drivers/gpu/drm/arm/malidp_hw.c
diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c
index b79f484e9bd2..9a9ae6f869ea 100644
--- a/drivers/gpu/drm/ast/ast_main.c
+++ b/drivers/gpu/drm/ast/ast_main.c
@@ -248,7 +248,7 @@ static int ast_detect_chip(struct drm_device *dev, bool *need_post)
 					ast->dp501_fw_addr = NULL;
 				}
 			}
-			/* fallthrough */
+			fallthrough;
 		case 0x0c:
 			ast->tx_chip_type = AST_TX_DP501;
 		}
* Unmerged path drivers/gpu/drm/bridge/nwl-dsi.c
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c
index d7e65c869415..9fef6413741d 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c
@@ -61,10 +61,10 @@ static int dw_hdmi_i2s_hw_params(struct device *dev, void *data,
 	switch (hparms->channels) {
 	case 7 ... 8:
 		conf0 |= HDMI_AUD_CONF0_I2S_EN3;
-		/* Fall-thru */
+		fallthrough;
 	case 5 ... 6:
 		conf0 |= HDMI_AUD_CONF0_I2S_EN2;
-		/* Fall-thru */
+		fallthrough;
 	case 3 ... 4:
 		conf0 |= HDMI_AUD_CONF0_I2S_EN1;
 		/* Fall-thru */
* Unmerged path drivers/gpu/drm/bridge/ti-sn65dsi86.c
diff --git a/drivers/gpu/drm/drm_bufs.c b/drivers/gpu/drm/drm_bufs.c
index 8ce9d73fab4f..2a9ded1c37ed 100644
--- a/drivers/gpu/drm/drm_bufs.c
+++ b/drivers/gpu/drm/drm_bufs.c
@@ -536,7 +536,7 @@ int drm_legacy_rmmap_locked(struct drm_device *dev, struct drm_local_map *map)
 	switch (map->type) {
 	case _DRM_REGISTERS:
 		iounmap(map->handle);
-		/* FALLTHROUGH */
+		fallthrough;
 	case _DRM_FRAME_BUFFER:
 		arch_phys_wc_del(map->mtrr);
 		break;
diff --git a/drivers/gpu/drm/drm_dp_helper.c b/drivers/gpu/drm/drm_dp_helper.c
index 8c51a9fa0273..9b592f5f892e 100644
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@ -430,7 +430,7 @@ int drm_dp_downstream_max_bpc(const u8 dpcd[DP_RECEIVER_CAP_SIZE],
 		case DP_DS_16BPC:
 			return 16;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		return 0;
 	}
diff --git a/drivers/gpu/drm/drm_modes.c b/drivers/gpu/drm/drm_modes.c
index d4d64518e11b..a91c04cfbe1d 100644
--- a/drivers/gpu/drm/drm_modes.c
+++ b/drivers/gpu/drm/drm_modes.c
@@ -1967,7 +1967,7 @@ void drm_mode_convert_to_umode(struct drm_mode_modeinfo *out,
 	default:
 		WARN(1, "Invalid aspect ratio (0%x) on mode\n",
 		     in->picture_aspect_ratio);
-		/* fall through */
+		fallthrough;
 	case HDMI_PICTURE_ASPECT_NONE:
 		out->flags |= DRM_MODE_FLAG_PIC_AR_NONE;
 		break;
diff --git a/drivers/gpu/drm/exynos/exynos_drm_dsi.c b/drivers/gpu/drm/exynos/exynos_drm_dsi.c
index 6d29777884f9..deca7eb946d8 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_dsi.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_dsi.c
@@ -984,10 +984,10 @@ static void exynos_dsi_send_to_fifo(struct exynos_dsi *dsi,
 	switch (length) {
 	case 3:
 		reg |= payload[2] << 16;
-		/* Fall through */
+		fallthrough;
 	case 2:
 		reg |= payload[1] << 8;
-		/* Fall through */
+		fallthrough;
 	case 1:
 		reg |= payload[0];
 		exynos_dsi_write(dsi, DSIM_PAYLOAD_REG, reg);
@@ -1035,7 +1035,7 @@ static void exynos_dsi_read_from_fifo(struct exynos_dsi *dsi,
 				payload[1] = reg >> 16;
 				++xfer->rx_done;
 			}
-			/* Fall through */
+			fallthrough;
 		case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:
 		case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:
 			payload[0] = reg >> 8;
@@ -1079,10 +1079,10 @@ static void exynos_dsi_read_from_fifo(struct exynos_dsi *dsi,
 		switch (length) {
 		case 3:
 			payload[2] = (reg >> 16) & 0xff;
-			/* Fall through */
+			fallthrough;
 		case 2:
 			payload[1] = (reg >> 8) & 0xff;
-			/* Fall through */
+			fallthrough;
 		case 1:
 			payload[0] = reg & 0xff;
 		}
diff --git a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c
index 9554b245746e..15f2d659a534 100644
--- a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c
+++ b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c
@@ -105,19 +105,19 @@ static void fsl_dcu_drm_plane_atomic_update(struct drm_plane *plane,
 		break;
 	case DRM_FORMAT_ARGB8888:
 		alpha = DCU_LAYER_AB_WHOLE_FRAME;
-		/* fall-through */
+		fallthrough;
 	case DRM_FORMAT_XRGB8888:
 		bpp = FSL_DCU_ARGB8888;
 		break;
 	case DRM_FORMAT_ARGB4444:
 		alpha = DCU_LAYER_AB_WHOLE_FRAME;
-		/* fall-through */
+		fallthrough;
 	case DRM_FORMAT_XRGB4444:
 		bpp = FSL_DCU_ARGB4444;
 		break;
 	case DRM_FORMAT_ARGB1555:
 		alpha = DCU_LAYER_AB_WHOLE_FRAME;
-		/* fall-through */
+		fallthrough;
 	case DRM_FORMAT_XRGB1555:
 		bpp = FSL_DCU_ARGB1555;
 		break;
diff --git a/drivers/gpu/drm/i915/display/icl_dsi.c b/drivers/gpu/drm/i915/display/icl_dsi.c
index f8e882101396..2ef9fe6b43b3 100644
--- a/drivers/gpu/drm/i915/display/icl_dsi.c
+++ b/drivers/gpu/drm/i915/display/icl_dsi.c
@@ -689,7 +689,7 @@ gen11_dsi_configure_transcoder(struct intel_encoder *encoder,
 			switch (intel_dsi->pixel_format) {
 			default:
 				MISSING_CASE(intel_dsi->pixel_format);
-				/* fallthrough */
+				fallthrough;
 			case MIPI_DSI_FMT_RGB565:
 				tmp |= PIX_FMT_RGB565;
 				break;
@@ -716,7 +716,7 @@ gen11_dsi_configure_transcoder(struct intel_encoder *encoder,
 			switch (intel_dsi->video_mode_format) {
 			default:
 				MISSING_CASE(intel_dsi->video_mode_format);
-				/* fallthrough */
+				fallthrough;
 			case VIDEO_MODE_NON_BURST_WITH_SYNC_EVENTS:
 				tmp |= VIDEO_MODE_SYNC_EVENT;
 				break;
@@ -755,7 +755,7 @@ gen11_dsi_configure_transcoder(struct intel_encoder *encoder,
 		switch (pipe) {
 		default:
 			MISSING_CASE(pipe);
-			/* fallthrough */
+			fallthrough;
 		case PIPE_A:
 			tmp |= TRANS_DDI_EDP_INPUT_A_ON;
 			break;
* Unmerged path drivers/gpu/drm/i915/display/intel_bios.c
* Unmerged path drivers/gpu/drm/i915/display/intel_cdclk.c
diff --git a/drivers/gpu/drm/i915/display/intel_combo_phy.c b/drivers/gpu/drm/i915/display/intel_combo_phy.c
index 44bbc7e74fc3..45ac3c31fed4 100644
--- a/drivers/gpu/drm/i915/display/intel_combo_phy.c
+++ b/drivers/gpu/drm/i915/display/intel_combo_phy.c
@@ -52,7 +52,7 @@ cnl_get_procmon_ref_values(struct drm_i915_private *dev_priv, enum phy phy)
 	switch (val & (PROCESS_INFO_MASK | VOLTAGE_INFO_MASK)) {
 	default:
 		MISSING_CASE(val);
-		/* fall through */
+		fallthrough;
 	case VOLTAGE_INFO_0_85V | PROCESS_INFO_DOT_0:
 		procmon = &cnl_procmon_values[PROCMON_0_85V_DOT_0];
 		break;
@@ -233,7 +233,7 @@ void intel_combo_phy_power_up_lanes(struct drm_i915_private *dev_priv,
 			break;
 		default:
 			MISSING_CASE(lane_count);
-			/* fall-through */
+			fallthrough;
 		case 4:
 			lane_mask = PWR_UP_ALL_LANES;
 			break;
@@ -250,7 +250,7 @@ void intel_combo_phy_power_up_lanes(struct drm_i915_private *dev_priv,
 			break;
 		default:
 			MISSING_CASE(lane_count);
-			/* fall-through */
+			fallthrough;
 		case 4:
 			lane_mask = PWR_UP_ALL_LANES;
 			break;
diff --git a/drivers/gpu/drm/i915/display/intel_ddi.c b/drivers/gpu/drm/i915/display/intel_ddi.c
index b025c05a803f..039d2bce9bf8 100644
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@ -2136,7 +2136,7 @@ static void intel_ddi_get_encoder_pipes(struct intel_encoder *encoder,
 		switch (tmp & TRANS_DDI_EDP_INPUT_MASK) {
 		default:
 			MISSING_CASE(tmp & TRANS_DDI_EDP_INPUT_MASK);
-			/* fallthrough */
+			fallthrough;
 		case TRANS_DDI_EDP_INPUT_A_ON:
 		case TRANS_DDI_EDP_INPUT_A_ONOFF:
 			*pipe_mask = BIT(PIPE_A);
@@ -4370,7 +4370,7 @@ void intel_ddi_get_config(struct intel_encoder *encoder,
 			pipe_config->hdmi_scrambling = true;
 		if (temp & TRANS_DDI_HIGH_TMDS_CHAR_RATE)
 			pipe_config->hdmi_high_tmds_clock_ratio = true;
-		/* fall through */
+		fallthrough;
 	case TRANS_DDI_MODE_SELECT_DVI:
 		pipe_config->output_types |= BIT(INTEL_OUTPUT_HDMI);
 		pipe_config->lane_count = 4;
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
* Unmerged path drivers/gpu/drm/i915/display/intel_dpll_mgr.c
* Unmerged path drivers/gpu/drm/i915/display/intel_panel.c
* Unmerged path drivers/gpu/drm/i915/display/intel_sdvo.c
diff --git a/drivers/gpu/drm/i915/display/intel_sprite.c b/drivers/gpu/drm/i915/display/intel_sprite.c
index f55404a94eba..b23774241b82 100644
--- a/drivers/gpu/drm/i915/display/intel_sprite.c
+++ b/drivers/gpu/drm/i915/display/intel_sprite.c
@@ -2080,7 +2080,7 @@ static int skl_plane_check_fb(const struct intel_crtc_state *crtc_state,
 		case DRM_FORMAT_RGB565:
 			if (INTEL_GEN(dev_priv) >= 11)
 				break;
-			/* fall through */
+			fallthrough;
 		case DRM_FORMAT_C8:
 		case DRM_FORMAT_XRGB16161616F:
 		case DRM_FORMAT_XBGR16161616F:
@@ -2617,7 +2617,7 @@ static bool g4x_sprite_format_mod_supported(struct drm_plane *_plane,
 		if (modifier == DRM_FORMAT_MOD_LINEAR ||
 		    modifier == I915_FORMAT_MOD_X_TILED)
 			return true;
-		/* fall through */
+		fallthrough;
 	default:
 		return false;
 	}
@@ -2648,7 +2648,7 @@ static bool snb_sprite_format_mod_supported(struct drm_plane *_plane,
 		if (modifier == DRM_FORMAT_MOD_LINEAR ||
 		    modifier == I915_FORMAT_MOD_X_TILED)
 			return true;
-		/* fall through */
+		fallthrough;
 	default:
 		return false;
 	}
@@ -2683,7 +2683,7 @@ static bool vlv_sprite_format_mod_supported(struct drm_plane *_plane,
 		if (modifier == DRM_FORMAT_MOD_LINEAR ||
 		    modifier == I915_FORMAT_MOD_X_TILED)
 			return true;
-		/* fall through */
+		fallthrough;
 	default:
 		return false;
 	}
@@ -2716,7 +2716,7 @@ static bool skl_plane_format_mod_supported(struct drm_plane *_plane,
 	case DRM_FORMAT_ABGR8888:
 		if (is_ccs_modifier(modifier))
 			return true;
-		/* fall through */
+		fallthrough;
 	case DRM_FORMAT_RGB565:
 	case DRM_FORMAT_XRGB2101010:
 	case DRM_FORMAT_XBGR2101010:
@@ -2733,7 +2733,7 @@ static bool skl_plane_format_mod_supported(struct drm_plane *_plane,
 	case DRM_FORMAT_XVYU2101010:
 		if (modifier == I915_FORMAT_MOD_Yf_TILED)
 			return true;
-		/* fall through */
+		fallthrough;
 	case DRM_FORMAT_C8:
 	case DRM_FORMAT_XBGR16161616F:
 	case DRM_FORMAT_ABGR16161616F:
@@ -2748,7 +2748,7 @@ static bool skl_plane_format_mod_supported(struct drm_plane *_plane,
 		    modifier == I915_FORMAT_MOD_X_TILED ||
 		    modifier == I915_FORMAT_MOD_Y_TILED)
 			return true;
-		/* fall through */
+		fallthrough;
 	default:
 		return false;
 	}
@@ -2774,7 +2774,7 @@ static bool gen12_plane_format_mod_supported(struct drm_plane *_plane,
 	case I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:
 		if (!gen12_plane_supports_mc_ccs(dev_priv, plane->id))
 			return false;
-		/* fall through */
+		fallthrough;
 	case DRM_FORMAT_MOD_LINEAR:
 	case I915_FORMAT_MOD_X_TILED:
 	case I915_FORMAT_MOD_Y_TILED:
@@ -2791,7 +2791,7 @@ static bool gen12_plane_format_mod_supported(struct drm_plane *_plane,
 	case DRM_FORMAT_ABGR8888:
 		if (is_ccs_modifier(modifier))
 			return true;
-		/* fall through */
+		fallthrough;
 	case DRM_FORMAT_YUYV:
 	case DRM_FORMAT_YVYU:
 	case DRM_FORMAT_UYVY:
@@ -2802,7 +2802,7 @@ static bool gen12_plane_format_mod_supported(struct drm_plane *_plane,
 	case DRM_FORMAT_P016:
 		if (modifier == I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS)
 			return true;
-		/* fall through */
+		fallthrough;
 	case DRM_FORMAT_RGB565:
 	case DRM_FORMAT_XRGB2101010:
 	case DRM_FORMAT_XBGR2101010:
@@ -2823,7 +2823,7 @@ static bool gen12_plane_format_mod_supported(struct drm_plane *_plane,
 		    modifier == I915_FORMAT_MOD_X_TILED ||
 		    modifier == I915_FORMAT_MOD_Y_TILED)
 			return true;
-		/* fall through */
+		fallthrough;
 	default:
 		return false;
 	}
diff --git a/drivers/gpu/drm/i915/display/intel_tc.c b/drivers/gpu/drm/i915/display/intel_tc.c
index 200a93ca61de..1fc4e2d4a3e0 100644
--- a/drivers/gpu/drm/i915/display/intel_tc.c
+++ b/drivers/gpu/drm/i915/display/intel_tc.c
@@ -159,7 +159,7 @@ int intel_tc_port_fia_max_lane_count(struct intel_digital_port *dig_port)
 	switch (lane_mask) {
 	default:
 		MISSING_CASE(lane_mask);
-		/* fall-through */
+		fallthrough;
 	case 0x1:
 	case 0x2:
 	case 0x4:
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_mman.c b/drivers/gpu/drm/i915/gem/i915_gem_mman.c
index 0b6a442108de..fafd2d1fb9fd 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_mman.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_mman.c
@@ -209,7 +209,7 @@ static vm_fault_t i915_error_to_vmf_fault(int err)
 	switch (err) {
 	default:
 		WARN_ONCE(err, "unhandled error in %s: %i\n", __func__, err);
-		/* fallthrough */
+		fallthrough;
 	case -EIO: /* shmemfs failure from swap device */
 	case -EFAULT: /* purged object */
 	case -ENODEV: /* bad object, how did you get here! */
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_pages.c b/drivers/gpu/drm/i915/gem/i915_gem_pages.c
index 54aca5c9101e..0438286c6e9b 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_pages.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_pages.c
@@ -276,7 +276,7 @@ static void *i915_gem_object_map(struct drm_i915_gem_object *obj,
 	switch (type) {
 	default:
 		MISSING_CASE(type);
-		/* fallthrough - to use PAGE_KERNEL anyway */
+		fallthrough;	/* to use PAGE_KERNEL anyway */
 	case I915_MAP_WB:
 		pgprot = PAGE_KERNEL;
 		break;
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_stolen.c b/drivers/gpu/drm/i915/gem/i915_gem_stolen.c
index 451f3078d60d..53392dbc97be 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_stolen.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_stolen.c
@@ -242,7 +242,7 @@ static void vlv_get_stolen_reserved(struct drm_i915_private *i915,
 	switch (reg_val & GEN7_STOLEN_RESERVED_SIZE_MASK) {
 	default:
 		MISSING_CASE(reg_val & GEN7_STOLEN_RESERVED_SIZE_MASK);
-		/* fall through */
+		fallthrough;
 	case GEN7_STOLEN_RESERVED_1M:
 		*size = 1024 * 1024;
 		break;
@@ -409,7 +409,7 @@ static int i915_gem_init_stolen(struct drm_i915_private *i915)
 	case 4:
 		if (!IS_G4X(i915))
 			break;
-		/* fall through */
+		fallthrough;
 	case 5:
 		g4x_get_stolen_reserved(i915, uncore,
 					&reserved_base, &reserved_size);
@@ -438,7 +438,7 @@ static int i915_gem_init_stolen(struct drm_i915_private *i915)
 		break;
 	default:
 		MISSING_CASE(INTEL_GEN(i915));
-		/* fall-through */
+		fallthrough;
 	case 11:
 	case 12:
 		icl_get_stolen_reserved(i915, uncore,
diff --git a/drivers/gpu/drm/i915/gt/intel_engine_cs.c b/drivers/gpu/drm/i915/gt/intel_engine_cs.c
index 18e282b28837..068eb40eec0e 100644
--- a/drivers/gpu/drm/i915/gt/intel_engine_cs.c
+++ b/drivers/gpu/drm/i915/gt/intel_engine_cs.c
@@ -213,7 +213,7 @@ u32 intel_engine_context_size(struct intel_gt *gt, u8 class)
 		break;
 	default:
 		MISSING_CASE(class);
-		/* fall through */
+		fallthrough;
 	case VIDEO_DECODE_CLASS:
 	case VIDEO_ENHANCEMENT_CLASS:
 	case COPY_ENGINE_CLASS:
diff --git a/drivers/gpu/drm/i915/gt/intel_ggtt.c b/drivers/gpu/drm/i915/gt/intel_ggtt.c
index d0d35c55170f..b58e284b0624 100644
--- a/drivers/gpu/drm/i915/gt/intel_ggtt.c
+++ b/drivers/gpu/drm/i915/gt/intel_ggtt.c
@@ -1479,7 +1479,7 @@ i915_get_ggtt_vma_pages(struct i915_vma *vma)
 	switch (vma->ggtt_view.type) {
 	default:
 		GEM_BUG_ON(vma->ggtt_view.type);
-		/* fall through */
+		fallthrough;
 	case I915_GGTT_VIEW_NORMAL:
 		vma->pages = vma->obj->mm.pages;
 		return 0;
diff --git a/drivers/gpu/drm/i915/gt/intel_ring_submission.c b/drivers/gpu/drm/i915/gt/intel_ring_submission.c
index 169c503f27c7..6777402e0730 100644
--- a/drivers/gpu/drm/i915/gt/intel_ring_submission.c
+++ b/drivers/gpu/drm/i915/gt/intel_ring_submission.c
@@ -536,7 +536,7 @@ static void set_hwsp(struct intel_engine_cs *engine, u32 offset)
 		 */
 		default:
 			GEM_BUG_ON(engine->id);
-			/* fallthrough */
+			fallthrough;
 		case RCS0:
 			hwsp = RENDER_HWS_PGA_GEN7;
 			break;
diff --git a/drivers/gpu/drm/i915/gvt/handlers.c b/drivers/gpu/drm/i915/gvt/handlers.c
index 4b2f8d42c646..5ffa899e8927 100644
--- a/drivers/gpu/drm/i915/gvt/handlers.c
+++ b/drivers/gpu/drm/i915/gvt/handlers.c
@@ -1225,7 +1225,7 @@ static int handle_g2v_notification(struct intel_vgpu *vgpu, int notification)
 	switch (notification) {
 	case VGT_G2V_PPGTT_L3_PAGE_TABLE_CREATE:
 		root_entry_type = GTT_TYPE_PPGTT_ROOT_L3_ENTRY;
-		/* fall through */
+		fallthrough;
 	case VGT_G2V_PPGTT_L4_PAGE_TABLE_CREATE:
 		mm = intel_vgpu_get_ppgtt_mm(vgpu, root_entry_type, pdps);
 		return PTR_ERR_OR_ZERO(mm);
diff --git a/drivers/gpu/drm/i915/i915_gpu_error.c b/drivers/gpu/drm/i915/i915_gpu_error.c
index 9e401a5fcae8..8dc132040e63 100644
--- a/drivers/gpu/drm/i915/i915_gpu_error.c
+++ b/drivers/gpu/drm/i915/i915_gpu_error.c
@@ -1137,7 +1137,7 @@ static void engine_record_registers(struct intel_engine_coredump *ee)
 			switch (engine->id) {
 			default:
 				MISSING_CASE(engine->id);
-				/* fall through */
+				fallthrough;
 			case RCS0:
 				mmio = RENDER_HWS_PGA_GEN7;
 				break;
diff --git a/drivers/gpu/drm/i915/i915_pmu.c b/drivers/gpu/drm/i915/i915_pmu.c
index aa729d04abe2..472db6eb274d 100644
--- a/drivers/gpu/drm/i915/i915_pmu.c
+++ b/drivers/gpu/drm/i915/i915_pmu.c
@@ -491,7 +491,7 @@ config_status(struct drm_i915_private *i915, u64 config)
 		if (IS_VALLEYVIEW(i915) || IS_CHERRYVIEW(i915))
 			/* Requires a mutex for sampling! */
 			return -ENODEV;
-		/* Fall-through. */
+		fallthrough;
 	case I915_PMU_REQUESTED_FREQUENCY:
 		if (INTEL_GEN(i915) < 6)
 			return -ENODEV;
diff --git a/drivers/gpu/drm/imx/ipuv3-plane.c b/drivers/gpu/drm/imx/ipuv3-plane.c
index 203f247d4854..c633d0a742b7 100644
--- a/drivers/gpu/drm/imx/ipuv3-plane.c
+++ b/drivers/gpu/drm/imx/ipuv3-plane.c
@@ -448,7 +448,7 @@ static int ipu_plane_atomic_check(struct drm_plane *plane,
 		if (fb->pitches[1] != fb->pitches[2])
 			return -EINVAL;
 
-		/* fall-through */
+		fallthrough;
 	case DRM_FORMAT_NV12:
 	case DRM_FORMAT_NV16:
 		ubo = drm_plane_state_to_ubo(state);
* Unmerged path drivers/gpu/drm/meson/meson_osd_afbcd.c
* Unmerged path drivers/gpu/drm/meson/meson_overlay.c
* Unmerged path drivers/gpu/drm/msm/adreno/a5xx_gpu.c
* Unmerged path drivers/gpu/drm/msm/adreno/a6xx_gmu.c
* Unmerged path drivers/gpu/drm/msm/adreno/a6xx_gpu.c
* Unmerged path drivers/gpu/drm/msm/adreno/adreno_gpu.c
* Unmerged path drivers/gpu/drm/omapdrm/dss/venc.c
diff --git a/drivers/gpu/drm/radeon/ci_dpm.c b/drivers/gpu/drm/radeon/ci_dpm.c
index 30b5a59353c5..7558f4972aa3 100644
--- a/drivers/gpu/drm/radeon/ci_dpm.c
+++ b/drivers/gpu/drm/radeon/ci_dpm.c
@@ -4870,7 +4870,7 @@ static void ci_request_link_speed_change_before_state_change(struct radeon_devic
 			pi->force_pcie_gen = RADEON_PCIE_GEN2;
 			if (current_link_speed == RADEON_PCIE_GEN2)
 				break;
-			/* fall through */
+			fallthrough;
 		case RADEON_PCIE_GEN2:
 			if (radeon_acpi_pcie_performance_request(rdev, PCIE_PERF_REQ_PECI_GEN2, false) == 0)
 				break;
diff --git a/drivers/gpu/drm/radeon/r300.c b/drivers/gpu/drm/radeon/r300.c
index 3b7ead5be5bf..73f67bf222e1 100644
--- a/drivers/gpu/drm/radeon/r300.c
+++ b/drivers/gpu/drm/radeon/r300.c
@@ -820,7 +820,7 @@ static int r300_packet0_check(struct radeon_cs_parser *p,
 					  ((idx_value >> 21) & 0xF));
 				return -EINVAL;
 			}
-			/* Fall through. */
+			fallthrough;
 		case 6:
 			track->cb[i].cpp = 4;
 			break;
@@ -971,7 +971,7 @@ static int r300_packet0_check(struct radeon_cs_parser *p,
 				return -EINVAL;
 			}
 			/* The same rules apply as for DXT3/5. */
-			/* Fall through. */
+			fallthrough;
 		case R300_TX_FORMAT_DXT3:
 		case R300_TX_FORMAT_DXT5:
 			track->textures[i].cpp = 1;
diff --git a/drivers/gpu/drm/radeon/r420.c b/drivers/gpu/drm/radeon/r420.c
index 1d4c04e0a449..50b89b6d9a6c 100644
--- a/drivers/gpu/drm/radeon/r420.c
+++ b/drivers/gpu/drm/radeon/r420.c
@@ -115,7 +115,7 @@ void r420_pipes_init(struct radeon_device *rdev)
 	default:
 		/* force to 1 pipe */
 		num_pipes = 1;
-		/* fall through */
+		fallthrough;
 	case 1:
 		tmp = (0 << 1);
 		break;
diff --git a/drivers/gpu/drm/radeon/r600_cs.c b/drivers/gpu/drm/radeon/r600_cs.c
index 49e8266461f8..390a9621604a 100644
--- a/drivers/gpu/drm/radeon/r600_cs.c
+++ b/drivers/gpu/drm/radeon/r600_cs.c
@@ -487,7 +487,7 @@ static int r600_cs_track_validate_cb(struct radeon_cs_parser *p, int i)
 				return -EINVAL;
 			}
 		}
-		/* fall through */
+		fallthrough;
 	case V_0280A0_CLEAR_ENABLE:
 	{
 		uint32_t block_max = G_028100_CMASK_BLOCK_MAX(track->cb_color_mask[i]);
@@ -1535,7 +1535,7 @@ static int r600_check_texture_resource(struct radeon_cs_parser *p,  u32 idx,
 		break;
 	case V_038000_SQ_TEX_DIM_2D_ARRAY_MSAA:
 		is_array = true;
-		/* fall through */
+		fallthrough;
 	case V_038000_SQ_TEX_DIM_2D_MSAA:
 		array_check.nsamples = 1 << llevel;
 		llevel = 0;
diff --git a/drivers/gpu/drm/radeon/radeon_uvd.c b/drivers/gpu/drm/radeon/radeon_uvd.c
index 1ad5c3b86b64..57fb3eb3a4b4 100644
--- a/drivers/gpu/drm/radeon/radeon_uvd.c
+++ b/drivers/gpu/drm/radeon/radeon_uvd.c
@@ -454,7 +454,7 @@ static int radeon_uvd_validate_codec(struct radeon_cs_parser *p,
 		if (p->rdev->family >= CHIP_PALM)
 			return 0;
 
-		/* fall through */
+		fallthrough;
 	default:
 		DRM_ERROR("UVD codec not supported by hardware %d!\n",
 			  stream_type);
diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c
index 05e8b4d0af3f..9f143df02def 100644
--- a/drivers/gpu/drm/radeon/si_dpm.c
+++ b/drivers/gpu/drm/radeon/si_dpm.c
@@ -5763,7 +5763,7 @@ static void si_request_link_speed_change_before_state_change(struct radeon_devic
 			si_pi->force_pcie_gen = RADEON_PCIE_GEN2;
 			if (current_link_speed == RADEON_PCIE_GEN2)
 				break;
-			/* fall through */
+			fallthrough;
 		case RADEON_PCIE_GEN2:
 			if (radeon_acpi_pcie_performance_request(rdev, PCIE_PERF_REQ_PECI_GEN2, false) == 0)
 				break;
diff --git a/drivers/gpu/drm/radeon/uvd_v1_0.c b/drivers/gpu/drm/radeon/uvd_v1_0.c
index f858d8d06347..800721153d51 100644
--- a/drivers/gpu/drm/radeon/uvd_v1_0.c
+++ b/drivers/gpu/drm/radeon/uvd_v1_0.c
@@ -219,7 +219,7 @@ int uvd_v1_0_init(struct radeon_device *rdev)
 			WREG32(RS_DQ_RD_RET_CONF, 0x3f);
 			WREG32(MC_CONFIG, 0x1f);
 
-			/* fall through */
+			fallthrough;
 		case CHIP_RV670:
 		case CHIP_RV635:
 
* Unmerged path drivers/gpu/drm/savage/savage_state.c
* Unmerged path drivers/gpu/drm/sti/sti_hdmi.c
* Unmerged path drivers/gpu/drm/sun4i/sun4i_tcon.c
* Unmerged path drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
diff --git a/drivers/gpu/drm/tegra/dc.c b/drivers/gpu/drm/tegra/dc.c
index 1aa4a3cd81d7..7bf1c99d2f00 100644
--- a/drivers/gpu/drm/tegra/dc.c
+++ b/drivers/gpu/drm/tegra/dc.c
@@ -130,7 +130,7 @@ static inline u32 compute_dda_inc(unsigned int in, unsigned int out, bool v,
 
 		default:
 			WARN_ON_ONCE(1);
-			/* fallthrough */
+			fallthrough;
 		case 4:
 			max = 4;
 			break;
diff --git a/drivers/gpu/drm/tilcdc/tilcdc_crtc.c b/drivers/gpu/drm/tilcdc/tilcdc_crtc.c
index 1067e702c22c..452f2876c991 100644
--- a/drivers/gpu/drm/tilcdc/tilcdc_crtc.c
+++ b/drivers/gpu/drm/tilcdc/tilcdc_crtc.c
@@ -393,7 +393,7 @@ static void tilcdc_crtc_set_mode(struct drm_crtc *crtc)
 		case DRM_FORMAT_XBGR8888:
 		case DRM_FORMAT_XRGB8888:
 			reg |= LCDC_V2_TFT_24BPP_UNPACK;
-			/* fallthrough */
+			fallthrough;
 		case DRM_FORMAT_BGR888:
 		case DRM_FORMAT_RGB888:
 			reg |= LCDC_V2_TFT_24BPP_MODE;
diff --git a/drivers/gpu/drm/ttm/ttm_bo_vm.c b/drivers/gpu/drm/ttm/ttm_bo_vm.c
index b9e046875d17..d7df5057e1f1 100644
--- a/drivers/gpu/drm/ttm/ttm_bo_vm.c
+++ b/drivers/gpu/drm/ttm/ttm_bo_vm.c
@@ -425,7 +425,7 @@ int ttm_bo_vm_access(struct vm_area_struct *vma, unsigned long addr,
 			if (unlikely(ret != 0))
 				return ret;
 		}
-		/* fall through */
+		fallthrough;
 	case TTM_PL_TT:
 		ret = ttm_bo_vm_access_kmap(bo, offset, buf, len, write);
 		break;
* Unmerged path drivers/gpu/drm/via/via_dmablit.c
diff --git a/drivers/gpu/drm/xen/xen_drm_front.c b/drivers/gpu/drm/xen/xen_drm_front.c
index 4be49c1aef51..5d8783727b56 100644
--- a/drivers/gpu/drm/xen/xen_drm_front.c
+++ b/drivers/gpu/drm/xen/xen_drm_front.c
@@ -649,9 +649,7 @@ static void displback_changed(struct xenbus_device *xb_dev,
 
 	switch (backend_state) {
 	case XenbusStateReconfiguring:
-		/* fall through */
 	case XenbusStateReconfigured:
-		/* fall through */
 	case XenbusStateInitialised:
 		break;
 
@@ -701,7 +699,6 @@ static void displback_changed(struct xenbus_device *xb_dev,
 		break;
 
 	case XenbusStateUnknown:
-		/* fall through */
 	case XenbusStateClosed:
 		if (xb_dev->state == XenbusStateClosed)
 			break;
diff --git a/drivers/gpu/ipu-v3/ipu-dc.c b/drivers/gpu/ipu-v3/ipu-dc.c
index 49bfe6e7d005..ceead3943e23 100644
--- a/drivers/gpu/ipu-v3/ipu-dc.c
+++ b/drivers/gpu/ipu-v3/ipu-dc.c
@@ -150,7 +150,7 @@ static int ipu_bus_format_to_map(u32 fmt)
 	switch (fmt) {
 	default:
 		WARN_ON(1);
-		/* fall-through */
+		fallthrough;
 	case MEDIA_BUS_FMT_RGB888_1X24:
 		return IPU_DC_MAP_RGB24;
 	case MEDIA_BUS_FMT_RGB565_1X16:
diff --git a/drivers/hid/hid-lg-g15.c b/drivers/hid/hid-lg-g15.c
index ef0cbcd7540d..fcaf8466e627 100644
--- a/drivers/hid/hid-lg-g15.c
+++ b/drivers/hid/hid-lg-g15.c
@@ -680,7 +680,7 @@ static int lg_g15_register_led(struct lg_g15_data *g15, int i)
 			 * but it does have a separate power-on (reset) value.
 			 */
 			g15->leds[i].cdev.name = "g15::power_on_backlight_val";
-			/* fall through */
+			fallthrough;
 		case LG_G15_KBD_BRIGHTNESS:
 			g15->leds[i].cdev.brightness_set_blocking =
 				lg_g510_kbd_led_set;
diff --git a/drivers/hid/hid-logitech-dj.c b/drivers/hid/hid-logitech-dj.c
index e8f057d81f35..1cbbcf607ee9 100644
--- a/drivers/hid/hid-logitech-dj.c
+++ b/drivers/hid/hid-logitech-dj.c
@@ -844,7 +844,7 @@ static void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,
 			workitem.type = WORKITEM_TYPE_EMPTY;
 			break;
 		}
-		/* fall-through */
+		fallthrough;
 	case REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:
 		workitem.quad_id_msb =
 			dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB];
diff --git a/drivers/hid/hid-microsoft.c b/drivers/hid/hid-microsoft.c
index 8cb1ca1936e4..071fd093a5f4 100644
--- a/drivers/hid/hid-microsoft.c
+++ b/drivers/hid/hid-microsoft.c
@@ -163,16 +163,13 @@ static int ms_surface_dial_quirk(struct hid_input *hi, struct hid_field *field,
 {
 	switch (usage->hid & HID_USAGE_PAGE) {
 	case 0xff070000:
-		/* fall-through */
 	case HID_UP_DIGITIZER:
 		/* ignore those axis */
 		return -1;
 	case HID_UP_GENDESK:
 		switch (usage->hid) {
 		case HID_GD_X:
-			/* fall-through */
 		case HID_GD_Y:
-			/* fall-through */
 		case HID_GD_RFKILL_BTN:
 			/* ignore those axis */
 			return -1;
diff --git a/drivers/hid/hid-rmi.c b/drivers/hid/hid-rmi.c
index 8cffa84c9650..7f41213d5ae3 100644
--- a/drivers/hid/hid-rmi.c
+++ b/drivers/hid/hid-rmi.c
@@ -428,7 +428,6 @@ static void rmi_report(struct hid_device *hid, struct hid_report *report)
 
 	switch (report->id) {
 	case RMI_READ_DATA_REPORT_ID:
-		/* fall-through */
 	case RMI_ATTN_REPORT_ID:
 		return;
 	}
diff --git a/drivers/hid/hid-roccat-kone.c b/drivers/hid/hid-roccat-kone.c
index 509b9bb1362c..1ca64481145e 100644
--- a/drivers/hid/hid-roccat-kone.c
+++ b/drivers/hid/hid-roccat-kone.c
@@ -789,7 +789,7 @@ static void kone_keep_values_up_to_date(struct kone_device *kone,
 	case kone_mouse_event_switch_profile:
 		kone->actual_dpi = kone->profiles[event->value - 1].
 				startup_dpi;
-		/* fall through */
+		fallthrough;
 	case kone_mouse_event_osd_profile:
 		kone->actual_profile = event->value;
 		break;
diff --git a/drivers/hid/hid-uclogic-params.c b/drivers/hid/hid-uclogic-params.c
index 78a364ae2f68..7d20d1fcf8d2 100644
--- a/drivers/hid/hid-uclogic-params.c
+++ b/drivers/hid/hid-uclogic-params.c
@@ -974,7 +974,7 @@ int uclogic_params_init(struct uclogic_params *params,
 			}
 			break;
 		}
-		/* FALL THROUGH */
+		fallthrough;
 	case VID_PID(USB_VENDOR_ID_HUION,
 		     USB_DEVICE_ID_HUION_TABLET):
 	case VID_PID(USB_VENDOR_ID_HUION,
diff --git a/drivers/hid/hid-wiimote-core.c b/drivers/hid/hid-wiimote-core.c
index 679e142fc850..e484c3618dec 100644
--- a/drivers/hid/hid-wiimote-core.c
+++ b/drivers/hid/hid-wiimote-core.c
@@ -1672,7 +1672,6 @@ static ssize_t wiimote_ext_show(struct device *dev,
 	case WIIMOTE_EXT_GUITAR:
 		return sprintf(buf, "guitar\n");
 	case WIIMOTE_EXT_UNKNOWN:
-		/* fallthrough */
 	default:
 		return sprintf(buf, "unknown\n");
 	}
@@ -1722,7 +1721,6 @@ static ssize_t wiimote_dev_show(struct device *dev,
 	case WIIMOTE_DEV_PENDING:
 		return sprintf(buf, "pending\n");
 	case WIIMOTE_DEV_UNKNOWN:
-		/* fallthrough */
 	default:
 		return sprintf(buf, "unknown\n");
 	}
diff --git a/drivers/hid/usbhid/hiddev.c b/drivers/hid/usbhid/hiddev.c
index 4f97e6c12059..45e0b1c75cb1 100644
--- a/drivers/hid/usbhid/hiddev.c
+++ b/drivers/hid/usbhid/hiddev.c
@@ -785,7 +785,6 @@ static long hiddev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case HIDIOCGUCODE:
-		/* fall through */
 	case HIDIOCGUSAGE:
 	case HIDIOCSUSAGE:
 	case HIDIOCGUSAGES:
diff --git a/drivers/hid/wacom_wac.c b/drivers/hid/wacom_wac.c
index b74acbd5997b..1bd0eb71559c 100644
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@ -341,7 +341,7 @@ static int wacom_graphire_irq(struct wacom_wac *wacom)
 
 			case 2: /* Mouse with wheel */
 				input_report_key(input, BTN_MIDDLE, data[1] & 0x04);
-				/* fall through */
+				fallthrough;
 
 			case 3: /* Mouse without wheel */
 				wacom->tool[0] = BTN_TOOL_MOUSE;
@@ -1201,7 +1201,7 @@ static int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)
 	case 0x04:
 		wacom_intuos_bt_process_data(wacom, data + i);
 		i += 10;
-		/* fall through */
+		fallthrough;
 	case 0x03:
 		wacom_intuos_bt_process_data(wacom, data + i);
 		i += 10;
@@ -2148,7 +2148,7 @@ static void wacom_wac_pad_event(struct hid_device *hdev, struct hid_field *field
 		for (i = 0; i < wacom->led.count; i++)
 			wacom_update_led(wacom, features->numbered_buttons,
 					 value, i);
-		 /* fall through*/
+		fallthrough;
 	default:
 		do_report = true;
 		break;
@@ -3604,14 +3604,14 @@ int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 	switch (features->type) {
 	case GRAPHIRE_BT:
 		__clear_bit(ABS_MISC, input_dev->absbit);
-		/* fall through */
+		fallthrough;
 
 	case WACOM_MO:
 	case WACOM_G4:
 		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 					      features->distance_max,
 					      features->distance_fuzz, 0);
-		/* fall through */
+		fallthrough;
 
 	case GRAPHIRE:
 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
@@ -3651,7 +3651,7 @@ int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 	case INTUOS4S:
 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 		input_abs_set_res(input_dev, ABS_Z, 287);
-		/* fall through */
+		fallthrough;
 
 	case INTUOS:
 		wacom_setup_intuos(wacom_wac);
@@ -3684,7 +3684,7 @@ int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 	case TABLETPC:
 	case TABLETPCE:
 		__clear_bit(ABS_MISC, input_dev->absbit);
-		/* fall through */
+		fallthrough;
 
 	case DTUS:
 	case DTUSX:
@@ -3698,7 +3698,7 @@ int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 
 	case PTU:
 		__set_bit(BTN_STYLUS2, input_dev->keybit);
-		/* fall through */
+		fallthrough;
 
 	case PENPARTNER:
 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
@@ -3801,7 +3801,7 @@ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 		input_abs_set_res(input_dev, ABS_MT_POSITION_X, 40);
 		input_abs_set_res(input_dev, ABS_MT_POSITION_Y, 40);
 
-		/* fall through */
+		fallthrough;
 
 	case INTUOS5:
 	case INTUOS5L:
@@ -3819,7 +3819,7 @@ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
 		input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
-		/* fall through */
+		fallthrough;
 
 	case WACOM_27QHDT:
 		if (wacom_wac->shared->touch->product == 0x32C ||
@@ -3828,14 +3828,14 @@ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 			__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
 			wacom_wac->shared->has_mute_touch_switch = true;
 		}
-		/* fall through */
+		fallthrough;
 
 	case MTSCREEN:
 	case MTTPC:
 	case MTTPC_B:
 	case TABLETPC2FG:
 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
-		/*fall through */
+		fallthrough;
 
 	case TABLETPC:
 	case TABLETPCE:
@@ -3845,7 +3845,7 @@ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 	case INTUOSHT2:
 		input_dev->evbit[0] |= BIT_MASK(EV_SW);
 		__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
-		/* fall through */
+		fallthrough;
 
 	case BAMBOO_PT:
 	case BAMBOO_TOUCH:
@@ -4101,7 +4101,7 @@ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
 
 		__set_bit(KEY_BUTTONCONFIG, input_dev->keybit);
 		__set_bit(KEY_INFO, input_dev->keybit);
-		/* fall through */
+		fallthrough;
 
 	case WACOM_21UX2:
 	case WACOM_BEE:
@@ -4117,7 +4117,7 @@ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
 	case INTUOS3:
 	case INTUOS3L:
 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
-		/* fall through */
+		fallthrough;
 
 	case INTUOS3S:
 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
@@ -4141,7 +4141,7 @@ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
 		 * ID_INPUT_TABLET to be set.
 		 */
 		__set_bit(BTN_STYLUS, input_dev->keybit);
-		/* fall through */
+		fallthrough;
 
 	case INTUOS4:
 	case INTUOS4L:
* Unmerged path drivers/hsi/clients/ssi_protocol.c
diff --git a/drivers/hsi/controllers/omap_ssi_core.c b/drivers/hsi/controllers/omap_ssi_core.c
index 41a09f506803..81a6bc8eff4e 100644
--- a/drivers/hsi/controllers/omap_ssi_core.c
+++ b/drivers/hsi/controllers/omap_ssi_core.c
@@ -330,7 +330,7 @@ static int ssi_clk_event(struct notifier_block *nb, unsigned long event,
 		break;
 	case ABORT_RATE_CHANGE:
 		dev_dbg(&ssi->device, "abort rate change\n");
-		/* Fall through */
+		fallthrough;
 	case POST_RATE_CHANGE:
 		dev_dbg(&ssi->device, "post rate change (%lu -> %lu)\n",
 			clk_data->old_rate, clk_data->new_rate);
diff --git a/drivers/hv/hv_kvp.c b/drivers/hv/hv_kvp.c
index e74b144b8f3d..754d35a25a1c 100644
--- a/drivers/hv/hv_kvp.c
+++ b/drivers/hv/hv_kvp.c
@@ -354,7 +354,7 @@ static void process_ib_ipinfo(void *in_msg, void *out_msg, int op)
 
 		out->body.kvp_ip_val.dhcp_enabled = in->kvp_ip_val.dhcp_enabled;
 
-		/* fallthrough */
+		fallthrough;
 
 	case KVP_OP_GET_IP_INFO:
 		utf16s_to_utf8s((wchar_t *)in->kvp_ip_val.adapter_id,
* Unmerged path drivers/hwmon/adt7462.c
* Unmerged path drivers/hwmon/emc1403.c
* Unmerged path drivers/hwmon/f71882fg.c
diff --git a/drivers/hwmon/hwmon-vid.c b/drivers/hwmon/hwmon-vid.c
index 84e91286fc4f..6c62c7d4a7d9 100644
--- a/drivers/hwmon/hwmon-vid.c
+++ b/drivers/hwmon/hwmon-vid.c
@@ -109,7 +109,7 @@ int vid_from_reg(int val, u8 vrm)
 		val &= 0x1f;
 		if (val == 0x1f)
 			return 0;
-				/* fall through */
+		fallthrough;
 	case 25:		/* AMD NPT 0Fh */
 		val &= 0x3f;
 		return (val < 32) ? 1550 - 25 * val
@@ -135,7 +135,7 @@ int vid_from_reg(int val, u8 vrm)
 
 	case 84:		/* VRM 8.4 */
 		val &= 0x0f;
-				/* fall through */
+		fallthrough;
 	case 82:		/* VRM 8.2 */
 		val &= 0x1f;
 		return val == 0x1f ? 0 :
* Unmerged path drivers/hwmon/ina3221.c
* Unmerged path drivers/hwmon/nct6775.c
* Unmerged path drivers/hwmon/occ/common.c
diff --git a/drivers/hwmon/w83627hf.c b/drivers/hwmon/w83627hf.c
index 8ac89d0781cc..45b9557e7ab4 100644
--- a/drivers/hwmon/w83627hf.c
+++ b/drivers/hwmon/w83627hf.c
@@ -1240,7 +1240,7 @@ store_temp_type(struct device *dev, struct device_attribute *devattr,
 	case W83781D_DEFAULT_BETA:
 		dev_warn(dev, "Sensor type %d is deprecated, please use 4 "
 			 "instead\n", W83781D_DEFAULT_BETA);
-		/* fall through */
+		fallthrough;
 	case 4:		/* thermistor */
 		tmp = w83627hf_read_value(data, W83781D_REG_SCFG1);
 		w83627hf_write_value(data, W83781D_REG_SCFG1,
diff --git a/drivers/hwmon/w83781d.c b/drivers/hwmon/w83781d.c
index 4d46fd51f33e..35dd2ca5618d 100644
--- a/drivers/hwmon/w83781d.c
+++ b/drivers/hwmon/w83781d.c
@@ -827,7 +827,7 @@ store_sensor(struct device *dev, struct device_attribute *da,
 		dev_warn(dev,
 			 "Sensor type %d is deprecated, please use 4 instead\n",
 			 W83781D_DEFAULT_BETA);
-		/* fall through */
+		fallthrough;
 	case 4:		/* thermistor */
 		tmp = w83781d_read_value(data, W83781D_REG_SCFG1);
 		w83781d_write_value(data, W83781D_REG_SCFG1,
diff --git a/drivers/hwmon/w83795.c b/drivers/hwmon/w83795.c
index 49276bbdac3d..303c8ea38aa7 100644
--- a/drivers/hwmon/w83795.c
+++ b/drivers/hwmon/w83795.c
@@ -2140,7 +2140,7 @@ static void w83795_apply_temp_config(struct w83795_data *data, u8 config,
 		if (temp_chan >= 4)
 			break;
 		data->temp_mode |= 1 << temp_chan;
-		/* fall through */
+		fallthrough;
 	case 0x3: /* Thermistor */
 		data->has_temp |= 1 << temp_chan;
 		break;
diff --git a/drivers/hwtracing/coresight/coresight-cpu-debug.c b/drivers/hwtracing/coresight/coresight-cpu-debug.c
index 45b2460f3166..418c614a8cff 100644
--- a/drivers/hwtracing/coresight/coresight-cpu-debug.c
+++ b/drivers/hwtracing/coresight/coresight-cpu-debug.c
@@ -346,10 +346,10 @@ static void debug_init_arch_data(void *info)
 	switch (mode) {
 	case EDDEVID_IMPL_FULL:
 		drvdata->edvidsr_present = true;
-		/* Fall through */
+		fallthrough;
 	case EDDEVID_IMPL_EDPCSR_EDCIDSR:
 		drvdata->edcidsr_present = true;
-		/* Fall through */
+		fallthrough;
 	case EDDEVID_IMPL_EDPCSR:
 		/*
 		 * In ARM DDI 0487A.k, the EDDEVID1.PCSROffset is used to
* Unmerged path drivers/hwtracing/coresight/coresight-etm4x.c
* Unmerged path drivers/hwtracing/coresight/coresight-tmc.c
diff --git a/drivers/hwtracing/intel_th/sth.c b/drivers/hwtracing/intel_th/sth.c
index a1529f571491..9ca8c4e045f8 100644
--- a/drivers/hwtracing/intel_th/sth.c
+++ b/drivers/hwtracing/intel_th/sth.c
@@ -84,11 +84,11 @@ static ssize_t notrace sth_stm_packet(struct stm_data *stm_data,
 	/* Global packets (GERR, XSYNC, TRIG) are sent with register writes */
 	case STP_PACKET_GERR:
 		reg += 4;
-		/* fall through */
+		fallthrough;
 
 	case STP_PACKET_XSYNC:
 		reg += 8;
-		/* fall through */
+		fallthrough;
 
 	case STP_PACKET_TRIG:
 		if (flags & STP_PACKET_TIMESTAMPED)
diff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c
index 65d06a819307..3072bd3861ad 100644
--- a/drivers/i2c/busses/i2c-omap.c
+++ b/drivers/i2c/busses/i2c-omap.c
@@ -1387,7 +1387,6 @@ omap_i2c_probe(struct platform_device *pdev)
 		major = OMAP_I2C_REV_SCHEME_0_MAJOR(omap->rev);
 		break;
 	case OMAP_I2C_SCHEME_1:
-		/* FALLTHROUGH */
 	default:
 		omap->regs = (u8 *)reg_map_ip_v2;
 		rev = (rev << 16) |
diff --git a/drivers/i2c/busses/i2c-opal.c b/drivers/i2c/busses/i2c-opal.c
index dc2a23f4fb52..1ea4fc0c0045 100644
--- a/drivers/i2c/busses/i2c-opal.c
+++ b/drivers/i2c/busses/i2c-opal.c
@@ -137,7 +137,7 @@ static int i2c_opal_smbus_xfer(struct i2c_adapter *adap, u16 addr,
 	case I2C_SMBUS_BYTE:
 		req.buffer_ra = cpu_to_be64(__pa(&data->byte));
 		req.size = cpu_to_be32(1);
-		/* Fall through */
+		fallthrough;
 	case I2C_SMBUS_QUICK:
 		req.type = (read_write == I2C_SMBUS_READ) ?
 			OPAL_I2C_RAW_READ : OPAL_I2C_RAW_WRITE;
* Unmerged path drivers/i3c/master/dw-i3c-master.c
* Unmerged path drivers/ide/hpt366.c
diff --git a/drivers/ide/ide-cd.c b/drivers/ide/ide-cd.c
index c2141c1ada4a..e744dbb0a3d2 100644
--- a/drivers/ide/ide-cd.c
+++ b/drivers/ide/ide-cd.c
@@ -349,7 +349,7 @@ static int cdrom_decode_status(ide_drive_t *drive, u8 stat)
 		 */
 		if (scsi_req(rq)->cmd[0] == GPCMD_START_STOP_UNIT)
 			break;
-		/* fall-through */
+		fallthrough;
 	case DATA_PROTECT:
 		/*
 		 * No point in retrying after an illegal request or data
@@ -749,7 +749,7 @@ static ide_startstop_t cdrom_newpc_intr(ide_drive_t *drive)
 	case REQ_OP_DRV_IN:
 	case REQ_OP_DRV_OUT:
 		expiry = ide_cd_expiry;
-		/*FALLTHRU*/
+		fallthrough;
 	default:
 		timeout = ATAPI_WAIT_PC;
 		break;
* Unmerged path drivers/ide/ide-floppy.c
* Unmerged path drivers/ide/ide-probe.c
* Unmerged path drivers/ide/ide-taskfile.c
* Unmerged path drivers/ide/sis5513.c
* Unmerged path drivers/iio/accel/mma8452.c
* Unmerged path drivers/iio/adc/ab8500-gpadc.c
diff --git a/drivers/iio/adc/cpcap-adc.c b/drivers/iio/adc/cpcap-adc.c
index 9ad60421d360..4d8e2de7828c 100644
--- a/drivers/iio/adc/cpcap-adc.c
+++ b/drivers/iio/adc/cpcap-adc.c
@@ -698,7 +698,7 @@ static void cpcap_adc_phase(struct cpcap_adc_request *req)
 		break;
 	case CPCAP_ADC_BATTI_PI17:
 		index = req->bank_index;
-		/* fallthrough */
+		fallthrough;
 	default:
 		req->result += conv_tbl[index].cal_offset;
 		req->result += conv_tbl[index].align_offset;
* Unmerged path drivers/iio/chemical/sps30.c
diff --git a/drivers/iio/dac/ad5592r-base.c b/drivers/iio/dac/ad5592r-base.c
index 095530c233e4..add7e08d9b38 100644
--- a/drivers/iio/dac/ad5592r-base.c
+++ b/drivers/iio/dac/ad5592r-base.c
@@ -224,7 +224,6 @@ static int ad5592r_set_channel_modes(struct ad5592r_state *st)
 			break;
 
 		case CH_MODE_UNUSED:
-			/* fall-through */
 		default:
 			switch (st->channel_offstate[i]) {
 			case CH_OFFSTATE_OUT_TRISTATE:
@@ -241,7 +240,6 @@ static int ad5592r_set_channel_modes(struct ad5592r_state *st)
 				break;
 
 			case CH_OFFSTATE_PULLDOWN:
-				/* fall-through */
 			default:
 				pulldown |= BIT(i);
 				break;
* Unmerged path drivers/iio/dac/dpot-dac.c
* Unmerged path drivers/iio/health/max30102.c
* Unmerged path drivers/iio/imu/adis.c
* Unmerged path drivers/iio/industrialio-core.c
diff --git a/drivers/iio/light/si1145.c b/drivers/iio/light/si1145.c
index 76f16f9c7616..9d25c587f170 100644
--- a/drivers/iio/light/si1145.c
+++ b/drivers/iio/light/si1145.c
@@ -1046,7 +1046,7 @@ static int si1145_initialize(struct si1145_data *data)
 						SI1145_LED_CURRENT_45mA);
 		if (ret < 0)
 			return ret;
-		/* fallthrough */
+		fallthrough;
 	case 2:
 		ret = i2c_smbus_write_byte_data(client,
 						SI1145_REG_PS_LED21,
diff --git a/drivers/iio/magnetometer/ak8974.c b/drivers/iio/magnetometer/ak8974.c
index 93be1f4c0f27..92e5734fe7b5 100644
--- a/drivers/iio/magnetometer/ak8974.c
+++ b/drivers/iio/magnetometer/ak8974.c
@@ -476,7 +476,7 @@ static int ak8974_detect(struct ak8974 *ak8974)
 	switch (whoami) {
 	case AK8974_WHOAMI_VALUE_AMI306:
 		name = "ami306";
-		/* fall-through */
+		fallthrough;
 	case AK8974_WHOAMI_VALUE_AMI305:
 		ret = regmap_read(ak8974->map, AMI305_VER, &fw);
 		if (ret)
diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c
index b83ae9f96926..36c200100f7d 100644
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@ -3048,7 +3048,7 @@ static int cm_rej_handler(struct cm_work *work)
 	case IB_CM_REP_SENT:
 	case IB_CM_MRA_REP_RCVD:
 		ib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);
-		/* fall through */
+		fallthrough;
 	case IB_CM_REQ_RCVD:
 	case IB_CM_MRA_REQ_SENT:
 		if (IBA_GET(CM_REJ_REASON, rej_msg) == IB_CM_REJ_STALE_CONN)
@@ -3058,7 +3058,7 @@ static int cm_rej_handler(struct cm_work *work)
 		break;
 	case IB_CM_DREQ_SENT:
 		ib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);
-		/* fall through */
+		fallthrough;
 	case IB_CM_REP_RCVD:
 	case IB_CM_MRA_REP_SENT:
 		cm_enter_timewait(cm_id_priv);
@@ -3072,7 +3072,7 @@ static int cm_rej_handler(struct cm_work *work)
 			cm_enter_timewait(cm_id_priv);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		pr_debug("%s: local_id %d, cm_id_priv->id.state: %d\n",
 			 __func__, be32_to_cpu(cm_id_priv->id.local_id),
@@ -3138,7 +3138,7 @@ int ib_send_cm_mra(struct ib_cm_id *cm_id,
 			msg_response = CM_MSG_RESPONSE_OTHER;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		pr_debug("%s: local_id %d, cm_id_priv->id.state: %d\n",
 			 __func__, be32_to_cpu(cm_id_priv->id.local_id),
@@ -3249,7 +3249,7 @@ static int cm_mra_handler(struct cm_work *work)
 	case IB_CM_MRA_REP_RCVD:
 		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_MRA_COUNTER]);
-		/* fall through */
+		fallthrough;
 	default:
 		pr_debug("%s local_id %d, cm_id_priv->id.state: %d\n",
 			 __func__, be32_to_cpu(cm_id_priv->id.local_id),
@@ -4271,7 +4271,7 @@ static int cm_init_qp_rts_attr(struct cm_id_private *cm_id_priv,
 				qp_attr->retry_cnt = cm_id_priv->retry_count;
 				qp_attr->rnr_retry = cm_id_priv->rnr_retry_count;
 				qp_attr->max_rd_atomic = cm_id_priv->initiator_depth;
-				/* fall through */
+				fallthrough;
 			case IB_QPT_XRC_TGT:
 				*qp_attr_mask |= IB_QP_TIMEOUT;
 				qp_attr->timeout = cm_id_priv->av.timeout;
diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c
index abf2fb7b598e..a77e4c3646cc 100644
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@ -1967,7 +1967,8 @@ static int cma_ib_handler(struct ib_cm_id *cm_id,
 		event.event = RDMA_CM_EVENT_ESTABLISHED;
 		break;
 	case IB_CM_DREQ_ERROR:
-		event.status = -ETIMEDOUT; /* fall through */
+		event.status = -ETIMEDOUT;
+		fallthrough;
 	case IB_CM_DREQ_RECEIVED:
 	case IB_CM_DREP_RECEIVED:
 		if (!cma_comp_exch(id_priv, RDMA_CM_CONNECT,
diff --git a/drivers/infiniband/core/rw.c b/drivers/infiniband/core/rw.c
index 614cff89fc71..13f43ab7220b 100644
--- a/drivers/infiniband/core/rw.c
+++ b/drivers/infiniband/core/rw.c
@@ -510,7 +510,6 @@ struct ib_send_wr *rdma_rw_ctx_wrs(struct rdma_rw_ctx *ctx, struct ib_qp *qp,
 	switch (ctx->type) {
 	case RDMA_RW_SIG_MR:
 	case RDMA_RW_MR:
-		/* fallthrough */
 		for (i = 0; i < ctx->nr_ops; i++) {
 			rdma_rw_update_lkey(&ctx->reg[i],
 				ctx->reg[i].wr.wr.opcode !=
diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c
index bd78f0a09a76..26f1e0976433 100644
--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@ -793,7 +793,7 @@ static void ucma_copy_ib_route(struct rdma_ucm_query_route_resp *resp,
 	case 2:
 		ib_copy_path_rec_to_user(&resp->ib_route[1],
 					 &route->path_rec[1]);
-		/* fall through */
+		fallthrough;
 	case 1:
 		ib_copy_path_rec_to_user(&resp->ib_route[0],
 					 &route->path_rec[0]);
@@ -819,7 +819,7 @@ static void ucma_copy_iboe_route(struct rdma_ucm_query_route_resp *resp,
 	case 2:
 		ib_copy_path_rec_to_user(&resp->ib_route[1],
 					 &route->path_rec[1]);
-		/* fall through */
+		fallthrough;
 	case 1:
 		ib_copy_path_rec_to_user(&resp->ib_route[0],
 					 &route->path_rec[0]);
diff --git a/drivers/infiniband/core/uverbs_ioctl.c b/drivers/infiniband/core/uverbs_ioctl.c
index 01442099863d..8c3555f4ee35 100644
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@ -257,7 +257,7 @@ static int uverbs_process_attr(struct bundle_priv *pbundle,
 			return -EOPNOTSUPP;
 
 		e->ptr_attr.enum_id = uattr->attr_data.enum_data.elem_id;
-	/* fall through */
+		fallthrough;
 	case UVERBS_ATTR_TYPE_PTR_IN:
 		/* Ensure that any data provided by userspace beyond the known
 		 * struct is zero. Userspace that knows how to use some future
@@ -269,7 +269,7 @@ static int uverbs_process_attr(struct bundle_priv *pbundle,
 		    !uverbs_is_attr_cleared(uattr, val_spec->u.ptr.len))
 			return -EOPNOTSUPP;
 
-	/* fall through */
+		fallthrough;
 	case UVERBS_ATTR_TYPE_PTR_OUT:
 		if (uattr->len < val_spec->u.ptr.min_len ||
 		    (!val_spec->zero_trailing &&
diff --git a/drivers/infiniband/hw/bnxt_re/ib_verbs.c b/drivers/infiniband/hw/bnxt_re/ib_verbs.c
index 8e4de0f707ce..1f64c246c6e2 100644
--- a/drivers/infiniband/hw/bnxt_re/ib_verbs.c
+++ b/drivers/infiniband/hw/bnxt_re/ib_verbs.c
@@ -2654,7 +2654,7 @@ int bnxt_re_post_send(struct ib_qp *ib_qp, const struct ib_send_wr *wr,
 			default:
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		case IB_WR_SEND_WITH_INV:
 			rc = bnxt_re_build_send_wqe(qp, wr, &wqe);
 			break;
diff --git a/drivers/infiniband/hw/bnxt_re/qplib_fp.c b/drivers/infiniband/hw/bnxt_re/qplib_fp.c
index 9f90cfec4bbb..f78da54a0bc5 100644
--- a/drivers/infiniband/hw/bnxt_re/qplib_fp.c
+++ b/drivers/infiniband/hw/bnxt_re/qplib_fp.c
@@ -1785,7 +1785,7 @@ int bnxt_qplib_post_send(struct bnxt_qplib_qp *qp,
 
 			break;
 		}
-		/* fall thru */
+		fallthrough;
 	case BNXT_QPLIB_SWQE_TYPE_SEND_WITH_IMM:
 	case BNXT_QPLIB_SWQE_TYPE_SEND_WITH_INV:
 	{
diff --git a/drivers/infiniband/hw/cxgb4/cm.c b/drivers/infiniband/hw/cxgb4/cm.c
index bad2e1a33032..126132ade6b3 100644
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@ -2877,7 +2877,7 @@ static int peer_abort(struct c4iw_dev *dev, struct sk_buff *skb)
 	case MORIBUND:
 	case CLOSING:
 		stop_ep_timer(ep);
-		/*FALLTHROUGH*/
+		fallthrough;
 	case FPDU_MODE:
 		if (ep->com.qp && ep->com.qp->srq) {
 			srqidx = ABORT_RSS_SRQIDX_G(
@@ -3745,7 +3745,7 @@ static void active_ofld_conn_reply(struct c4iw_dev *dev, struct sk_buff *skb,
 			send_fw_act_open_req(ep, atid);
 			return;
 		}
-		/* fall through */
+		fallthrough;
 	case FW_EADDRINUSE:
 		set_bit(ACT_RETRY_INUSE, &ep->com.history);
 		if (ep->retry_count++ < ACT_OPEN_RETRY_COUNT) {
diff --git a/drivers/infiniband/hw/cxgb4/qp.c b/drivers/infiniband/hw/cxgb4/qp.c
index 2ecf093f9f43..29099ac6d4c6 100644
--- a/drivers/infiniband/hw/cxgb4/qp.c
+++ b/drivers/infiniband/hw/cxgb4/qp.c
@@ -1165,7 +1165,7 @@ int c4iw_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,
 				break;
 			}
 			fw_flags |= FW_RI_RDMA_WRITE_WITH_IMMEDIATE;
-			/*FALLTHROUGH*/
+			fallthrough;
 		case IB_WR_RDMA_WRITE:
 			fw_opcode = FW_RI_RDMA_WRITE_WR;
 			swsqe->opcode = FW_RI_RDMA_WRITE;
diff --git a/drivers/infiniband/hw/hfi1/pio_copy.c b/drivers/infiniband/hw/hfi1/pio_copy.c
index 03024cec78dd..1331e5d357f7 100644
--- a/drivers/infiniband/hw/hfi1/pio_copy.c
+++ b/drivers/infiniband/hw/hfi1/pio_copy.c
@@ -209,7 +209,6 @@ static inline void jcopy(u8 *dest, const u8 *src, u32 n)
 		/* fall through */
 	case 1:
 		*dest++ = *src++;
-		/* fall through */
 	}
 }
 
diff --git a/drivers/infiniband/hw/i40iw/i40iw_cm.c b/drivers/infiniband/hw/i40iw/i40iw_cm.c
index 69e54773fad1..573940795ae6 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_cm.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_cm.c
@@ -2451,7 +2451,7 @@ static void i40iw_handle_rst_pkt(struct i40iw_cm_node *cm_node,
 	case I40IW_CM_STATE_FIN_WAIT1:
 	case I40IW_CM_STATE_LAST_ACK:
 		cm_node->cm_id->rem_ref(cm_node->cm_id);
-		/* fall through */
+		fallthrough;
 	case I40IW_CM_STATE_TIME_WAIT:
 		cm_node->state = I40IW_CM_STATE_CLOSED;
 		i40iw_rem_ref_cm_node(cm_node);
diff --git a/drivers/infiniband/hw/i40iw/i40iw_ctrl.c b/drivers/infiniband/hw/i40iw/i40iw_ctrl.c
index 688f19667221..86d3f8aff329 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_ctrl.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_ctrl.c
@@ -1964,7 +1964,6 @@ static enum i40iw_status_code i40iw_sc_get_next_aeqe(struct i40iw_sc_aeq *aeq,
 		info->out_rdrsp = true;
 		break;
 	case I40IW_AE_SOURCE_RSVD:
-		/* fallthrough */
 	default:
 		break;
 	}
@@ -3762,14 +3761,14 @@ static enum i40iw_status_code cqp_sds_wqe_fill(struct i40iw_sc_cqp *cqp,
 					LS_64(1, I40IW_CQPSQ_UPESD_ENTRY_VALID)));
 
 		set_64bit_val(wqe, 56, info->entry[2].data);
-		/* fallthrough */
+		fallthrough;
 	case 2:
 		set_64bit_val(wqe, 32,
 			      (LS_64(info->entry[1].cmd, I40IW_CQPSQ_UPESD_SDCMD) |
 					LS_64(1, I40IW_CQPSQ_UPESD_ENTRY_VALID)));
 
 		set_64bit_val(wqe, 40, info->entry[1].data);
-		/* fallthrough */
+		fallthrough;
 	case 1:
 		set_64bit_val(wqe, 0,
 			      LS_64(info->entry[0].cmd, I40IW_CQPSQ_UPESD_SDCMD));
diff --git a/drivers/infiniband/hw/i40iw/i40iw_hw.c b/drivers/infiniband/hw/i40iw/i40iw_hw.c
index 233d44909072..7cee60ea1428 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_hw.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_hw.c
@@ -353,7 +353,6 @@ void i40iw_process_aeq(struct i40iw_device *iwdev)
 				i40iw_cm_disconn(iwqp);
 			break;
 		case I40IW_AE_BAD_CLOSE:
-			/* fall through */
 		case I40IW_AE_RESET_SENT:
 			i40iw_next_iw_state(iwqp, I40IW_QP_STATE_ERROR, 1, 0, 0);
 			i40iw_cm_disconn(iwqp);
@@ -413,7 +412,7 @@ void i40iw_process_aeq(struct i40iw_device *iwdev)
 		case I40IW_AE_UDA_XMIT_DGRAM_TOO_LONG:
 		case I40IW_AE_UDA_XMIT_DGRAM_TOO_SHORT:
 			ctx_info->err_rq_idx_valid = false;
-			/* fall through */
+			fallthrough;
 		default:
 			if (!info->sq && ctx_info->err_rq_idx_valid) {
 				ctx_info->err_rq_idx = info->wqe_idx;
diff --git a/drivers/infiniband/hw/i40iw/i40iw_main.c b/drivers/infiniband/hw/i40iw/i40iw_main.c
index 9c96ece5e7f3..58a433135a03 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_main.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_main.c
@@ -1489,36 +1489,35 @@ static void i40iw_deinit_device(struct i40iw_device *iwdev)
 		iwdev->iw_status = 0;
 		i40iw_port_ibevent(iwdev);
 		i40iw_destroy_rdma_device(iwdev->iwibdev);
-		/* fallthrough */
+		fallthrough;
 	case IP_ADDR_REGISTERED:
 		if (!iwdev->reset)
 			i40iw_del_macip_entry(iwdev, (u8)iwdev->mac_ip_table_idx);
-		/* fallthrough */
-		/* fallthrough */
+		fallthrough;
 	case PBLE_CHUNK_MEM:
 		i40iw_destroy_pble_pool(dev, iwdev->pble_rsrc);
-		/* fallthrough */
+		fallthrough;
 	case CEQ_CREATED:
 		i40iw_dele_ceqs(iwdev);
-		/* fallthrough */
+		fallthrough;
 	case AEQ_CREATED:
 		i40iw_destroy_aeq(iwdev);
-		/* fallthrough */
+		fallthrough;
 	case IEQ_CREATED:
 		i40iw_puda_dele_resources(&iwdev->vsi, I40IW_PUDA_RSRC_TYPE_IEQ, iwdev->reset);
-		/* fallthrough */
+		fallthrough;
 	case ILQ_CREATED:
 		i40iw_puda_dele_resources(&iwdev->vsi, I40IW_PUDA_RSRC_TYPE_ILQ, iwdev->reset);
-		/* fallthrough */
+		fallthrough;
 	case CCQ_CREATED:
 		i40iw_destroy_ccq(iwdev);
-		/* fallthrough */
+		fallthrough;
 	case HMC_OBJS_CREATED:
 		i40iw_del_hmc_objects(dev, dev->hmc_info, true, iwdev->reset);
-		/* fallthrough */
+		fallthrough;
 	case CQP_CREATED:
 		i40iw_destroy_cqp(iwdev, true);
-		/* fallthrough */
+		fallthrough;
 	case INITIAL_STATE:
 		i40iw_cleanup_cm_core(&iwdev->cm_core);
 		if (iwdev->vsi.pestat) {
@@ -1528,7 +1527,6 @@ static void i40iw_deinit_device(struct i40iw_device *iwdev)
 		i40iw_del_init_mem(iwdev);
 		break;
 	case INVALID_STATE:
-		/* fallthrough */
 	default:
 		i40iw_pr_err("bad init_state = %d\n", iwdev->init_state);
 		break;
diff --git a/drivers/infiniband/hw/i40iw/i40iw_puda.c b/drivers/infiniband/hw/i40iw/i40iw_puda.c
index d9c7ae6a7030..924be4b03c9a 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_puda.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_puda.c
@@ -814,13 +814,13 @@ void i40iw_puda_dele_resources(struct i40iw_sc_vsi *vsi,
 	switch (rsrc->completion) {
 	case PUDA_HASH_CRC_COMPLETE:
 		i40iw_free_hash_desc(rsrc->hash_desc);
-		/* fall through */
+		fallthrough;
 	case PUDA_QP_CREATED:
 		if (!reset)
 			i40iw_puda_free_qp(rsrc);
 
 		i40iw_free_dma_mem(dev->hw, &rsrc->qpmem);
-		/* fallthrough */
+		fallthrough;
 	case PUDA_CQ_CREATED:
 		if (!reset)
 			i40iw_puda_free_cq(rsrc);
diff --git a/drivers/infiniband/hw/i40iw/i40iw_utils.c b/drivers/infiniband/hw/i40iw/i40iw_utils.c
index 72db7c1dc299..5e196bd49a58 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_utils.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_utils.c
@@ -190,9 +190,8 @@ int i40iw_inetaddr_event(struct notifier_block *notifier,
 	switch (event) {
 	case NETDEV_DOWN:
 		action = I40IW_ARP_DELETE;
-		/* Fall through */
+		fallthrough;
 	case NETDEV_UP:
-		/* Fall through */
 	case NETDEV_CHANGEADDR:
 
 		/* Just skip if no need to handle ARP cache */
@@ -247,9 +246,8 @@ int i40iw_inet6addr_event(struct notifier_block *notifier,
 	switch (event) {
 	case NETDEV_DOWN:
 		action = I40IW_ARP_DELETE;
-		/* Fall through */
+		fallthrough;
 	case NETDEV_UP:
-		/* Fall through */
 	case NETDEV_CHANGEADDR:
 		i40iw_manage_arp_cache(iwdev,
 				       netdev->dev_addr,
@@ -344,7 +342,7 @@ int i40iw_netdevice_event(struct notifier_block *notifier,
 	switch (event) {
 	case NETDEV_DOWN:
 		iwdev->iw_status = 0;
-		/* Fall through */
+		fallthrough;
 	case NETDEV_UP:
 		i40iw_port_ibevent(iwdev);
 		break;
diff --git a/drivers/infiniband/hw/i40iw/i40iw_verbs.c b/drivers/infiniband/hw/i40iw/i40iw_verbs.c
index e669ddc00695..dab49d0badc3 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_verbs.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_verbs.c
@@ -824,7 +824,7 @@ void i40iw_hw_modify_qp(struct i40iw_device *iwdev, struct i40iw_qp *iwqp,
 	case I40IW_QP_STATE_RTS:
 		if (iwqp->iwarp_state == I40IW_QP_STATE_IDLE)
 			i40iw_send_reset(iwqp->cm_node);
-		/* fall through */
+		fallthrough;
 	case I40IW_QP_STATE_IDLE:
 	case I40IW_QP_STATE_TERMINATE:
 	case I40IW_QP_STATE_CLOSING:
@@ -2159,7 +2159,6 @@ static int i40iw_post_send(struct ib_qp *ibqp,
 
 		switch (ib_wr->opcode) {
 		case IB_WR_SEND:
-			/* fall-through */
 		case IB_WR_SEND_WITH_INV:
 			if (ib_wr->opcode == IB_WR_SEND) {
 				if (ib_wr->send_flags & IB_SEND_SOLICITED)
@@ -2216,7 +2215,7 @@ static int i40iw_post_send(struct ib_qp *ibqp,
 			break;
 		case IB_WR_RDMA_READ_WITH_INV:
 			inv_stag = true;
-			/* fall-through*/
+			fallthrough;
 		case IB_WR_RDMA_READ:
 			if (ib_wr->num_sge > I40IW_MAX_SGE_RD) {
 				err = -EINVAL;
diff --git a/drivers/infiniband/hw/mlx4/cq.c b/drivers/infiniband/hw/mlx4/cq.c
index 72eeb9a85bc5..e5f831bf50c0 100644
--- a/drivers/infiniband/hw/mlx4/cq.c
+++ b/drivers/infiniband/hw/mlx4/cq.c
@@ -765,13 +765,13 @@ static int mlx4_ib_poll_one(struct mlx4_ib_cq *cq,
 		switch (cqe->owner_sr_opcode & MLX4_CQE_OPCODE_MASK) {
 		case MLX4_OPCODE_RDMA_WRITE_IMM:
 			wc->wc_flags |= IB_WC_WITH_IMM;
-			/* fall through */
+			fallthrough;
 		case MLX4_OPCODE_RDMA_WRITE:
 			wc->opcode    = IB_WC_RDMA_WRITE;
 			break;
 		case MLX4_OPCODE_SEND_IMM:
 			wc->wc_flags |= IB_WC_WITH_IMM;
-			/* fall through */
+			fallthrough;
 		case MLX4_OPCODE_SEND:
 		case MLX4_OPCODE_SEND_INVAL:
 			wc->opcode    = IB_WC_SEND;
diff --git a/drivers/infiniband/hw/mlx4/mcg.c b/drivers/infiniband/hw/mlx4/mcg.c
index d844831179cf..5e4ec9786081 100644
--- a/drivers/infiniband/hw/mlx4/mcg.c
+++ b/drivers/infiniband/hw/mlx4/mcg.c
@@ -944,7 +944,7 @@ int mlx4_ib_mcg_multiplex_handler(struct ib_device *ibdev, int port,
 	switch (sa_mad->mad_hdr.method) {
 	case IB_MGMT_METHOD_SET:
 		may_create = 1;
-		/* fall through */
+		fallthrough;
 	case IB_SA_METHOD_DELETE:
 		req = kzalloc(sizeof *req, GFP_KERNEL);
 		if (!req)
diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c
index ab82fe27494e..dc11124324cf 100644
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@ -1577,12 +1577,12 @@ static struct ib_qp *_mlx4_ib_create_qp(struct ib_pd *pd,
 		pd = to_mxrcd(init_attr->xrcd)->pd;
 		xrcdn = to_mxrcd(init_attr->xrcd)->xrcdn;
 		init_attr->send_cq = to_mxrcd(init_attr->xrcd)->cq;
-		/* fall through */
+		fallthrough;
 	case IB_QPT_XRC_INI:
 		if (!(to_mdev(pd->device)->dev->caps.flags & MLX4_DEV_CAP_FLAG_XRC))
 			return ERR_PTR(-ENOSYS);
 		init_attr->recv_cq = init_attr->send_cq;
-		/* fall through */
+		fallthrough;
 	case IB_QPT_RC:
 	case IB_QPT_UC:
 	case IB_QPT_RAW_PACKET:
@@ -1591,7 +1591,7 @@ static struct ib_qp *_mlx4_ib_create_qp(struct ib_pd *pd,
 			return ERR_PTR(-ENOMEM);
 		qp->pri.vid = 0xFFFF;
 		qp->alt.vid = 0xFFFF;
-		/* fall through */
+		fallthrough;
 	case IB_QPT_UD:
 	{
 		err = create_qp_common(pd, init_attr, udata, 0, &qp);
diff --git a/drivers/infiniband/hw/mlx5/cq.c b/drivers/infiniband/hw/mlx5/cq.c
index e9b75fc04c9c..55343e61f2a7 100644
--- a/drivers/infiniband/hw/mlx5/cq.c
+++ b/drivers/infiniband/hw/mlx5/cq.c
@@ -121,13 +121,13 @@ static void handle_good_req(struct ib_wc *wc, struct mlx5_cqe64 *cqe,
 	switch (be32_to_cpu(cqe->sop_drop_qpn) >> 24) {
 	case MLX5_OPCODE_RDMA_WRITE_IMM:
 		wc->wc_flags |= IB_WC_WITH_IMM;
-		/* fall through */
+		fallthrough;
 	case MLX5_OPCODE_RDMA_WRITE:
 		wc->opcode    = IB_WC_RDMA_WRITE;
 		break;
 	case MLX5_OPCODE_SEND_IMM:
 		wc->wc_flags |= IB_WC_WITH_IMM;
-		/* fall through */
+		fallthrough;
 	case MLX5_OPCODE_SEND:
 	case MLX5_OPCODE_SEND_INVAL:
 		wc->opcode    = IB_WC_SEND;
diff --git a/drivers/infiniband/hw/mlx5/mad.c b/drivers/infiniband/hw/mlx5/mad.c
index 454ce5de2de7..9bb9bb058932 100644
--- a/drivers/infiniband/hw/mlx5/mad.c
+++ b/drivers/infiniband/hw/mlx5/mad.c
@@ -250,9 +250,8 @@ int mlx5_ib_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,
 		if (MLX5_CAP_GEN(dev->mdev, vport_counters) &&
 		    method == IB_MGMT_METHOD_GET)
 			return process_pma_cmd(dev, port_num, in, out);
-		/* fallthrough */
+		fallthrough;
 	case MLX5_IB_VENDOR_CLASS1:
-		/* fallthrough */
 	case MLX5_IB_VENDOR_CLASS2:
 	case IB_MGMT_CLASS_CONG_MGMT: {
 		if (method != IB_MGMT_METHOD_GET &&
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index 836dc58c3a11..daf25f661f48 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -4698,7 +4698,7 @@ static void mlx5_ib_handle_event(struct work_struct *_work)
 		break;
 	case MLX5_EVENT_TYPE_GENERAL_EVENT:
 		handle_general_event(ibdev, work->param, &ibev);
-		/* fall through */
+		fallthrough;
 	default:
 		goto out;
 	}
diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c
index 8149bc8e4a26..ab065f81dfad 100644
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@ -431,7 +431,7 @@ static int sq_overhead(struct ib_qp_init_attr *attr)
 	switch (attr->qp_type) {
 	case IB_QPT_XRC_INI:
 		size += sizeof(struct mlx5_wqe_xrc_seg);
-		/* fall through */
+		fallthrough;
 	case IB_QPT_RC:
 		size += sizeof(struct mlx5_wqe_ctrl_seg) +
 			max(sizeof(struct mlx5_wqe_atomic_seg) +
@@ -456,7 +456,7 @@ static int sq_overhead(struct ib_qp_init_attr *attr)
 		if (attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)
 			size += sizeof(struct mlx5_wqe_eth_pad) +
 				sizeof(struct mlx5_wqe_eth_seg);
-		/* fall through */
+		fallthrough;
 	case IB_QPT_SMI:
 	case MLX5_IB_QPT_HW_GSI:
 		size += sizeof(struct mlx5_wqe_ctrl_seg) +
diff --git a/drivers/infiniband/hw/mthca/mthca_av.c b/drivers/infiniband/hw/mthca/mthca_av.c
index 0823c0bc7e73..f051f4e06b53 100644
--- a/drivers/infiniband/hw/mthca/mthca_av.c
+++ b/drivers/infiniband/hw/mthca/mthca_av.c
@@ -115,7 +115,7 @@ static u8 ib_rate_to_memfree(u8 req_rate, u8 cur_rate)
 	switch ((cur_rate - 1) / req_rate) {
 	case 0:	 return MTHCA_RATE_MEMFREE_FULL;
 	case 1:	 return MTHCA_RATE_MEMFREE_HALF;
-	case 2:	 /* fall through */
+	case 2:
 	case 3:	 return MTHCA_RATE_MEMFREE_QUARTER;
 	default: return MTHCA_RATE_MEMFREE_EIGHTH;
 	}
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
index 81119ba280d9..5d717ad458c9 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
@@ -2142,7 +2142,7 @@ int ocrdma_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,
 		case IB_WR_SEND_WITH_IMM:
 			hdr->cw |= (OCRDMA_FLAG_IMM << OCRDMA_WQE_FLAGS_SHIFT);
 			hdr->immdt = ntohl(wr->ex.imm_data);
-			/* fall through */
+			fallthrough;
 		case IB_WR_SEND:
 			hdr->cw |= (OCRDMA_SEND << OCRDMA_WQE_OPCODE_SHIFT);
 			ocrdma_build_send(qp, hdr, wr);
@@ -2156,7 +2156,7 @@ int ocrdma_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,
 		case IB_WR_RDMA_WRITE_WITH_IMM:
 			hdr->cw |= (OCRDMA_FLAG_IMM << OCRDMA_WQE_FLAGS_SHIFT);
 			hdr->immdt = ntohl(wr->ex.imm_data);
-			/* fall through */
+			fallthrough;
 		case IB_WR_RDMA_WRITE:
 			hdr->cw |= (OCRDMA_WRITE << OCRDMA_WQE_OPCODE_SHIFT);
 			status = ocrdma_build_write(qp, hdr, wr);
diff --git a/drivers/infiniband/hw/qedr/verbs.c b/drivers/infiniband/hw/qedr/verbs.c
index a0c1733611c6..f25510360e12 100644
--- a/drivers/infiniband/hw/qedr/verbs.c
+++ b/drivers/infiniband/hw/qedr/verbs.c
@@ -3534,7 +3534,7 @@ static int __qedr_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,
 		break;
 	case IB_WR_RDMA_READ_WITH_INV:
 		SET_FIELD2(wqe->flags, RDMA_SQ_RDMA_WQE_1ST_READ_INV_FLG, 1);
-		/* fallthrough -- same is identical to RDMA READ */
+		fallthrough;	/* same is identical to RDMA READ */
 
 	case IB_WR_RDMA_READ:
 		wqe->req_type = RDMA_SQ_REQ_TYPE_RDMA_RD;
diff --git a/drivers/infiniband/hw/qib/qib_iba6120.c b/drivers/infiniband/hw/qib/qib_iba6120.c
index 531d8a1db2c3..69a70a7d0d6b 100644
--- a/drivers/infiniband/hw/qib/qib_iba6120.c
+++ b/drivers/infiniband/hw/qib/qib_iba6120.c
@@ -2974,11 +2974,11 @@ static u32 qib_6120_iblink_state(u64 ibcs)
 		state = IB_PORT_ARMED;
 		break;
 	case IB_6120_L_STATE_ACTIVE:
-		/* fall through */
 	case IB_6120_L_STATE_ACT_DEFER:
 		state = IB_PORT_ACTIVE;
 		break;
-	default: /* fall through */
+	default:
+		fallthrough;
 	case IB_6120_L_STATE_DOWN:
 		state = IB_PORT_DOWN;
 		break;
diff --git a/drivers/infiniband/hw/qib/qib_iba7220.c b/drivers/infiniband/hw/qib/qib_iba7220.c
index ea3ddb05cbad..0a6f26d4cb31 100644
--- a/drivers/infiniband/hw/qib/qib_iba7220.c
+++ b/drivers/infiniband/hw/qib/qib_iba7220.c
@@ -3586,11 +3586,11 @@ static u32 qib_7220_iblink_state(u64 ibcs)
 		state = IB_PORT_ARMED;
 		break;
 	case IB_7220_L_STATE_ACTIVE:
-		/* fall through */
 	case IB_7220_L_STATE_ACT_DEFER:
 		state = IB_PORT_ACTIVE;
 		break;
-	default: /* fall through */
+	default:
+		fallthrough;
 	case IB_7220_L_STATE_DOWN:
 		state = IB_PORT_DOWN;
 		break;
diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
index ac6a84f11ad0..93ea945f427f 100644
--- a/drivers/infiniband/hw/qib/qib_iba7322.c
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c
@@ -5509,11 +5509,11 @@ static u32 qib_7322_iblink_state(u64 ibcs)
 		state = IB_PORT_ARMED;
 		break;
 	case IB_7322_L_STATE_ACTIVE:
-		/* fall through */
 	case IB_7322_L_STATE_ACT_DEFER:
 		state = IB_PORT_ACTIVE;
 		break;
-	default: /* fall through */
+	default:
+		fallthrough;
 	case IB_7322_L_STATE_DOWN:
 		state = IB_PORT_DOWN;
 		break;
@@ -6534,7 +6534,7 @@ static int qib_init_7322_variables(struct qib_devdata *dd)
 				    "Invalid num_vls %u, using 4 VLs\n",
 				    qib_num_cfg_vls);
 			qib_num_cfg_vls = 4;
-			/* fall through */
+			fallthrough;
 		case 4:
 			ppd->vls_supported = IB_VL_VL0_3;
 			break;
diff --git a/drivers/infiniband/hw/qib/qib_mad.c b/drivers/infiniband/hw/qib/qib_mad.c
index 45f01452873e..3cc3776c1078 100644
--- a/drivers/infiniband/hw/qib/qib_mad.c
+++ b/drivers/infiniband/hw/qib/qib_mad.c
@@ -433,7 +433,7 @@ static int check_mkey(struct qib_ibport *ibp, struct ib_smp *smp, int mad_flags)
 			/* Bad mkey not a violation below level 2 */
 			if (ibp->rvp.mkeyprot < 2)
 				break;
-			/* fall through */
+			fallthrough;
 		case IB_MGMT_METHOD_SET:
 		case IB_MGMT_METHOD_TRAP_REPRESS:
 			if (ibp->rvp.mkey_violations != 0xFFFF)
@@ -828,7 +828,7 @@ static int subn_set_portinfo(struct ib_smp *smp, struct ib_device *ibdev,
 	case IB_PORT_NOP:
 		if (lstate == 0)
 			break;
-		/* FALLTHROUGH */
+		fallthrough;
 	case IB_PORT_DOWN:
 		if (lstate == 0)
 			lstate = QIB_IB_LINKDOWN_ONLY;
@@ -1928,7 +1928,7 @@ static int process_subn(struct ib_device *ibdev, int mad_flags,
 				ret = IB_MAD_RESULT_SUCCESS;
 				goto bail;
 			}
-			/* FALLTHROUGH */
+			fallthrough;
 		default:
 			smp->status |= IB_SMP_UNSUP_METH_ATTR;
 			ret = reply(smp);
@@ -1962,7 +1962,7 @@ static int process_subn(struct ib_device *ibdev, int mad_flags,
 				ret = IB_MAD_RESULT_SUCCESS;
 				goto bail;
 			}
-			/* FALLTHROUGH */
+			fallthrough;
 		default:
 			smp->status |= IB_SMP_UNSUP_METH_ATTR;
 			ret = reply(smp);
@@ -2333,7 +2333,7 @@ static int process_cc(struct ib_device *ibdev, int mad_flags,
 			ret = cc_get_congestion_control_table(ccp, ibdev, port);
 			goto bail;
 
-			/* FALLTHROUGH */
+			fallthrough;
 		default:
 			ccp->status |= IB_SMP_UNSUP_METH_ATTR;
 			ret = reply((struct ib_smp *) ccp);
@@ -2350,7 +2350,7 @@ static int process_cc(struct ib_device *ibdev, int mad_flags,
 			ret = cc_set_congestion_control_table(ccp, ibdev, port);
 			goto bail;
 
-			/* FALLTHROUGH */
+			fallthrough;
 		default:
 			ccp->status |= IB_SMP_UNSUP_METH_ATTR;
 			ret = reply((struct ib_smp *) ccp);
diff --git a/drivers/infiniband/hw/qib/qib_rc.c b/drivers/infiniband/hw/qib/qib_rc.c
index aaf7438258fa..3915e5b4a9bc 100644
--- a/drivers/infiniband/hw/qib/qib_rc.c
+++ b/drivers/infiniband/hw/qib/qib_rc.c
@@ -83,7 +83,7 @@ static int qib_make_rc_ack(struct qib_ibdev *dev, struct rvt_qp *qp,
 			rvt_put_mr(e->rdma_sge.mr);
 			e->rdma_sge.mr = NULL;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(ATOMIC_ACKNOWLEDGE):
 		/*
 		 * We can increment the tail pointer now that the last
@@ -92,7 +92,7 @@ static int qib_make_rc_ack(struct qib_ibdev *dev, struct rvt_qp *qp,
 		 */
 		if (++qp->s_tail_ack_queue > QIB_MAX_RDMA_ATOMIC)
 			qp->s_tail_ack_queue = 0;
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(SEND_ONLY):
 	case OP(ACKNOWLEDGE):
 		/* Check for no next entry in the queue. */
@@ -149,7 +149,7 @@ static int qib_make_rc_ack(struct qib_ibdev *dev, struct rvt_qp *qp,
 
 	case OP(RDMA_READ_RESPONSE_FIRST):
 		qp->s_ack_state = OP(RDMA_READ_RESPONSE_MIDDLE);
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(RDMA_READ_RESPONSE_MIDDLE):
 		qp->s_cur_sge = &qp->s_ack_rdma_sge;
 		qp->s_rdma_mr = qp->s_ack_rdma_sge.sge.mr;
@@ -471,10 +471,10 @@ int qib_make_rc_req(struct rvt_qp *qp, unsigned long *flags)
 		 * See qib_restart_rc().
 		 */
 		qp->s_len = restart_sge(&qp->s_sge, wqe, qp->s_psn, pmtu);
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(SEND_FIRST):
 		qp->s_state = OP(SEND_MIDDLE);
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(SEND_MIDDLE):
 		bth2 = qp->s_psn++ & QIB_PSN_MASK;
 		ss = &qp->s_sge;
@@ -510,10 +510,10 @@ int qib_make_rc_req(struct rvt_qp *qp, unsigned long *flags)
 		 * See qib_restart_rc().
 		 */
 		qp->s_len = restart_sge(&qp->s_sge, wqe, qp->s_psn, pmtu);
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(RDMA_WRITE_FIRST):
 		qp->s_state = OP(RDMA_WRITE_MIDDLE);
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(RDMA_WRITE_MIDDLE):
 		bth2 = qp->s_psn++ & QIB_PSN_MASK;
 		ss = &qp->s_sge;
@@ -1807,7 +1807,7 @@ void qib_rc_rcv(struct qib_ctxtdata *rcd, struct ib_header *hdr,
 		if (!ret)
 			goto rnr_nak;
 		qp->r_rcv_len = 0;
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(SEND_MIDDLE):
 	case OP(RDMA_WRITE_MIDDLE):
 send_middle:
@@ -1839,7 +1839,7 @@ void qib_rc_rcv(struct qib_ctxtdata *rcd, struct ib_header *hdr,
 		qp->r_rcv_len = 0;
 		if (opcode == OP(SEND_ONLY))
 			goto no_immediate_data;
-		/* fall through -- for SEND_ONLY_WITH_IMMEDIATE */
+		fallthrough;	/* for SEND_ONLY_WITH_IMMEDIATE */
 	case OP(SEND_LAST_WITH_IMMEDIATE):
 send_last_imm:
 		wc.ex.imm_data = ohdr->u.imm_data;
diff --git a/drivers/infiniband/hw/qib/qib_sdma.c b/drivers/infiniband/hw/qib/qib_sdma.c
index 99e11c347130..8f8d61736656 100644
--- a/drivers/infiniband/hw/qib/qib_sdma.c
+++ b/drivers/infiniband/hw/qib/qib_sdma.c
@@ -763,7 +763,7 @@ void __qib_sdma_process_event(struct qib_pportdata *ppd,
 			 * bringing the link up with traffic active on
 			 * 7220, e.g. */
 			ss->go_s99_running = 1;
-			/* fall through -- and start dma engine */
+			fallthrough;	/* and start dma engine */
 		case qib_sdma_event_e10_go_hw_start:
 			/* This reference means the state machine is started */
 			sdma_get(&ppd->sdma_state);
diff --git a/drivers/infiniband/hw/qib/qib_uc.c b/drivers/infiniband/hw/qib/qib_uc.c
index e17b91e2c22a..554af4273a13 100644
--- a/drivers/infiniband/hw/qib/qib_uc.c
+++ b/drivers/infiniband/hw/qib/qib_uc.c
@@ -161,7 +161,7 @@ int qib_make_uc_req(struct rvt_qp *qp, unsigned long *flags)
 
 	case OP(SEND_FIRST):
 		qp->s_state = OP(SEND_MIDDLE);
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(SEND_MIDDLE):
 		len = qp->s_len;
 		if (len > pmtu) {
@@ -185,7 +185,7 @@ int qib_make_uc_req(struct rvt_qp *qp, unsigned long *flags)
 
 	case OP(RDMA_WRITE_FIRST):
 		qp->s_state = OP(RDMA_WRITE_MIDDLE);
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(RDMA_WRITE_MIDDLE):
 		len = qp->s_len;
 		if (len > pmtu) {
@@ -351,7 +351,7 @@ void qib_uc_rcv(struct qib_ibport *ibp, struct ib_header *hdr,
 			goto no_immediate_data;
 		else if (opcode == OP(SEND_ONLY_WITH_IMMEDIATE))
 			goto send_last_imm;
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(SEND_MIDDLE):
 		/* Check for invalid length PMTU or posted rwqe len. */
 		if (unlikely(tlen != (hdrsize + pmtu + 4)))
@@ -440,7 +440,7 @@ void qib_uc_rcv(struct qib_ibport *ibp, struct ib_header *hdr,
 			wc.ex.imm_data = ohdr->u.rc.imm_data;
 			goto rdma_last_imm;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case OP(RDMA_WRITE_MIDDLE):
 		/* Check for invalid length PMTU or posted rwqe len. */
 		if (unlikely(tlen != (hdrsize + pmtu + 4)))
diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c
index 5ef93f8f17a1..3ae4146b3d7a 100644
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@ -238,7 +238,7 @@ static void qib_qp_rcv(struct qib_ctxtdata *rcd, struct ib_header *hdr,
 	case IB_QPT_GSI:
 		if (ib_qib_disable_sma)
 			break;
-		/* FALLTHROUGH */
+		fallthrough;
 	case IB_QPT_UD:
 		qib_ud_rcv(ibp, hdr, has_grh, data, tlen, qp);
 		break;
diff --git a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
index f15809c28f67..d9fb365d56a7 100644
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
@@ -238,7 +238,7 @@ struct ib_qp *pvrdma_create_qp(struct ib_pd *pd,
 			ret = -EINVAL;
 			goto err_qp;
 		}
-		/* fall through */
+		fallthrough;
 	case IB_QPT_RC:
 	case IB_QPT_UD:
 		qp = kzalloc(sizeof(*qp), GFP_KERNEL);
diff --git a/drivers/infiniband/sw/rdmavt/qp.c b/drivers/infiniband/sw/rdmavt/qp.c
index b89082caa247..42c3c1ba944b 100644
--- a/drivers/infiniband/sw/rdmavt/qp.c
+++ b/drivers/infiniband/sw/rdmavt/qp.c
@@ -1111,7 +1111,7 @@ struct ib_qp *rvt_create_qp(struct ib_pd *ibpd,
 		if (init_attr->port_num == 0 ||
 		    init_attr->port_num > ibpd->device->phys_port_cnt)
 			return ERR_PTR(-EINVAL);
-		/* fall through */
+		fallthrough;
 	case IB_QPT_UC:
 	case IB_QPT_RC:
 	case IB_QPT_UD:
diff --git a/drivers/infiniband/sw/rxe/rxe_comp.c b/drivers/infiniband/sw/rxe/rxe_comp.c
index 4bc88708b355..7b4df0028388 100644
--- a/drivers/infiniband/sw/rxe/rxe_comp.c
+++ b/drivers/infiniband/sw/rxe/rxe_comp.c
@@ -282,7 +282,7 @@ static inline enum comp_state check_ack(struct rxe_qp *qp,
 		if ((syn & AETH_TYPE_MASK) != AETH_ACK)
 			return COMPST_ERROR;
 
-		/* fall through */
+		fallthrough;
 		/* (IB_OPCODE_RC_RDMA_READ_RESPONSE_MIDDLE doesn't have an AETH)
 		 */
 	case IB_OPCODE_RC_RDMA_READ_RESPONSE_MIDDLE:
diff --git a/drivers/infiniband/sw/rxe/rxe_task.c b/drivers/infiniband/sw/rxe/rxe_task.c
index 08f05ac5f5d5..ecdac3f8fcc9 100644
--- a/drivers/infiniband/sw/rxe/rxe_task.c
+++ b/drivers/infiniband/sw/rxe/rxe_task.c
@@ -71,7 +71,7 @@ void rxe_do_task(unsigned long data)
 
 	case TASK_STATE_BUSY:
 		task->state = TASK_STATE_ARMED;
-		/* fall through */
+		fallthrough;
 	case TASK_STATE_ARMED:
 		spin_unlock_irqrestore(&task->state_lock, flags);
 		return;
diff --git a/drivers/infiniband/sw/rxe/rxe_verbs.c b/drivers/infiniband/sw/rxe/rxe_verbs.c
index de8e8505bfd2..eff4fc1c7874 100644
--- a/drivers/infiniband/sw/rxe/rxe_verbs.c
+++ b/drivers/infiniband/sw/rxe/rxe_verbs.c
@@ -539,7 +539,7 @@ static void init_send_wr(struct rxe_qp *qp, struct rxe_send_wr *wr,
 		switch (wr->opcode) {
 		case IB_WR_RDMA_WRITE_WITH_IMM:
 			wr->ex.imm_data = ibwr->ex.imm_data;
-			/* fall through */
+			fallthrough;
 		case IB_WR_RDMA_READ:
 		case IB_WR_RDMA_WRITE:
 			wr->wr.rdma.remote_addr = rdma_wr(ibwr)->remote_addr;
diff --git a/drivers/infiniband/sw/siw/siw_cm.c b/drivers/infiniband/sw/siw/siw_cm.c
index d1860f3e8740..85089e2be0de 100644
--- a/drivers/infiniband/sw/siw/siw_cm.c
+++ b/drivers/infiniband/sw/siw/siw_cm.c
@@ -1232,12 +1232,10 @@ static void siw_cm_llp_data_ready(struct sock *sk)
 
 	switch (cep->state) {
 	case SIW_EPSTATE_RDMA_MODE:
-		/* fall through */
 	case SIW_EPSTATE_LISTENING:
 		break;
 
 	case SIW_EPSTATE_AWAIT_MPAREQ:
-		/* fall through */
 	case SIW_EPSTATE_AWAIT_MPAREP:
 		siw_cm_queue_work(cep, SIW_CM_WORK_READ_MPAHDR);
 		break;
diff --git a/drivers/infiniband/sw/siw/siw_qp_rx.c b/drivers/infiniband/sw/siw/siw_qp_rx.c
index d9fbe8f7e734..05c21e1fa8a5 100644
--- a/drivers/infiniband/sw/siw/siw_qp_rx.c
+++ b/drivers/infiniband/sw/siw/siw_qp_rx.c
@@ -1223,7 +1223,7 @@ static int siw_rdmap_complete(struct siw_qp *qp, int error)
 	case RDMAP_SEND_SE:
 	case RDMAP_SEND_SE_INVAL:
 		wqe->rqe.flags |= SIW_WQE_SOLICITED;
-		/* Fall through */
+		fallthrough;
 
 	case RDMAP_SEND:
 	case RDMAP_SEND_INVAL:
@@ -1396,7 +1396,7 @@ int siw_tcp_rx_data(read_descriptor_t *rd_desc, struct sk_buff *skb,
 			 * DDP segment.
 			 */
 			qp->rx_fpdu->first_ddp_seg = 0;
-			/* Fall through */
+			fallthrough;
 
 		case SIW_GET_DATA_START:
 			/*
diff --git a/drivers/infiniband/sw/siw/siw_qp_tx.c b/drivers/infiniband/sw/siw/siw_qp_tx.c
index 605f81bfaed8..7989c4043db4 100644
--- a/drivers/infiniband/sw/siw/siw_qp_tx.c
+++ b/drivers/infiniband/sw/siw/siw_qp_tx.c
@@ -1042,7 +1042,7 @@ int siw_qp_sq_process(struct siw_qp *qp)
 		case SIW_OP_SEND_REMOTE_INV:
 		case SIW_OP_WRITE:
 			siw_wqe_put_mem(wqe, tx_type);
-			/* Fall through */
+			fallthrough;
 
 		case SIW_OP_INVAL_STAG:
 		case SIW_OP_REG_MR:
@@ -1128,7 +1128,7 @@ int siw_qp_sq_process(struct siw_qp *qp)
 		case SIW_OP_READ:
 		case SIW_OP_READ_LOCAL_INV:
 			siw_wqe_put_mem(wqe, tx_type);
-			/* Fall through */
+			fallthrough;
 
 		case SIW_OP_INVAL_STAG:
 		case SIW_OP_REG_MR:
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
index 9bf0fa30df28..7c41fb040f7c 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
@@ -512,13 +512,13 @@ static int ipoib_cm_rx_handler(struct ib_cm_id *cm_id,
 		return ipoib_cm_req_handler(cm_id, event);
 	case IB_CM_DREQ_RECEIVED:
 		ib_send_cm_drep(cm_id, NULL, 0);
-		/* Fall through */
+		fallthrough;
 	case IB_CM_REJ_RECEIVED:
 		p = cm_id->context;
 		priv = ipoib_priv(p->dev);
 		if (ib_modify_qp(p->qp, &ipoib_cm_err_attr, IB_QP_STATE))
 			ipoib_warn(priv, "unable to move qp to error state\n");
-		/* Fall through */
+		fallthrough;
 	default:
 		return 0;
 	}
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index 6681ba446551..88f60f644570 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -505,7 +505,7 @@ static struct net_device *ipoib_get_net_dev_by_params(
 	default:
 		dev_warn_ratelimited(&dev->dev,
 				     "duplicate IP address detected\n");
-		/* Fall through */
+		fallthrough;
 	case 1:
 		return net_dev;
 	}
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 699e075ae1b3..2f3ebc0a75d9 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -711,7 +711,7 @@ static int iser_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *eve
 	case RDMA_CM_EVENT_REJECTED:
 		iser_info("Connection rejected: %s\n",
 			 rdma_reject_msg(cma_id, event->status));
-		/* FALLTHROUGH */
+		fallthrough;
 	case RDMA_CM_EVENT_ADDR_ERROR:
 	case RDMA_CM_EVENT_ROUTE_ERROR:
 	case RDMA_CM_EVENT_CONNECT_ERROR:
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index b65530029117..c6ed4d6e1730 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -687,8 +687,8 @@ isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	case RDMA_CM_EVENT_ESTABLISHED:
 		isert_connected_handler(cma_id);
 		break;
-	case RDMA_CM_EVENT_ADDR_CHANGE:    /* FALLTHRU */
-	case RDMA_CM_EVENT_DISCONNECTED:   /* FALLTHRU */
+	case RDMA_CM_EVENT_ADDR_CHANGE:
+	case RDMA_CM_EVENT_DISCONNECTED:
 	case RDMA_CM_EVENT_TIMEWAIT_EXIT:  /* FALLTHRU */
 		ret = isert_disconnected_handler(cma_id, event->event);
 		break;
@@ -707,7 +707,7 @@ isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	case RDMA_CM_EVENT_REJECTED:
 		isert_info("Connection rejected: %s\n",
 			   rdma_reject_msg(cma_id, event->status));
-		/* fall through */
+		fallthrough;
 	case RDMA_CM_EVENT_UNREACHABLE:
 	case RDMA_CM_EVENT_CONNECT_ERROR:
 		ret = isert_connect_error(cma_id);
@@ -1495,7 +1495,7 @@ isert_put_cmd(struct isert_cmd *isert_cmd, bool comp_err)
 			transport_generic_free_cmd(&cmd->se_cmd, 0);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		iscsit_release_cmd(cmd);
 		break;
@@ -1673,7 +1673,7 @@ isert_do_control_comp(struct work_struct *work)
 	switch (cmd->i_state) {
 	case ISTATE_SEND_TASKMGTRSP:
 		iscsit_tmr_post_handler(cmd, cmd->conn);
-		/* fall through */
+		fallthrough;
 	case ISTATE_SEND_REJECT:
 	case ISTATE_SEND_TEXTRSP:
 		cmd->i_state = ISTATE_SENT_STATUS;
diff --git a/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c b/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c
index be5befd92d16..b3720e8a4889 100644
--- a/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c
+++ b/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c
@@ -549,7 +549,6 @@ static void vema_get(struct opa_vnic_vema_port *port,
 		vema_get_mac_entries(port, recvd_mad, rsp_mad);
 		break;
 	case OPA_EM_ATTR_IFACE_UCAST_MACS:
-		/* fall through */
 	case OPA_EM_ATTR_IFACE_MCAST_MACS:
 		vema_get_mac_list(port, recvd_mad, rsp_mad, attr_id);
 		break;
* Unmerged path drivers/input/joystick/fsia6b.c
diff --git a/drivers/input/joystick/gamecon.c b/drivers/input/joystick/gamecon.c
index e0a362be5812..89e4a7f9fc14 100644
--- a/drivers/input/joystick/gamecon.c
+++ b/drivers/input/joystick/gamecon.c
@@ -883,7 +883,6 @@ static int gc_setup_pad(struct gc *gc, int idx, int pad_type)
 		/* fall through */
 	case GC_MULTI:
 		input_set_capability(input_dev, EV_KEY, BTN_TRIGGER);
-		/* fall through */
 		break;
 
 	case GC_PSX:
diff --git a/drivers/input/tablet/wacom_serial4.c b/drivers/input/tablet/wacom_serial4.c
index 959c1d82aa66..1cedb45ba497 100644
--- a/drivers/input/tablet/wacom_serial4.c
+++ b/drivers/input/tablet/wacom_serial4.c
@@ -213,7 +213,7 @@ static void wacom_handle_model_response(struct wacom *wacom)
 		case 0x3731: /* PL-710 */
 			wacom->res_x = 2540;
 			wacom->res_y = 2540;
-			/* fall through */
+			fallthrough;
 		case 0x3535: /* PL-550 */
 		case 0x3830: /* PL-800 */
 			wacom->extra_z_bits = 2;
* Unmerged path drivers/input/touchscreen/atmel_mxt_ts.c
diff --git a/drivers/input/touchscreen/wm831x-ts.c b/drivers/input/touchscreen/wm831x-ts.c
index 607d1aeb595d..bb1699e0d3c7 100644
--- a/drivers/input/touchscreen/wm831x-ts.c
+++ b/drivers/input/touchscreen/wm831x-ts.c
@@ -290,7 +290,7 @@ static int wm831x_ts_probe(struct platform_device *pdev)
 		default:
 			dev_err(&pdev->dev, "Unsupported ISEL setting: %d\n",
 				pdata->isel);
-			/* Fall through */
+			fallthrough;
 		case 200:
 		case 0:
 			wm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_2,
diff --git a/drivers/iommu/amd_iommu_init.c b/drivers/iommu/amd_iommu_init.c
index d39cad3c8c89..51534fcbf683 100644
--- a/drivers/iommu/amd_iommu_init.c
+++ b/drivers/iommu/amd_iommu_init.c
@@ -2243,7 +2243,7 @@ static void iommu_enable_ga(struct amd_iommu *iommu)
 	switch (amd_iommu_guest_ir) {
 	case AMD_IOMMU_GUEST_IR_VAPIC:
 		iommu_feature_enable(iommu, CONTROL_GAM_EN);
-		/* Fall through */
+		fallthrough;
 	case AMD_IOMMU_GUEST_IR_LEGACY_GA:
 		iommu_feature_enable(iommu, CONTROL_GA_EN);
 		iommu->irte_ops = &irte_128_ops;
* Unmerged path drivers/iommu/arm-smmu-v3.c
diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index eb1b9e34254e..f07829850fd1 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -4905,7 +4905,6 @@ static struct iommu_domain *intel_iommu_domain_alloc(unsigned type)
 
 	switch (type) {
 	case IOMMU_DOMAIN_DMA:
-	/* fallthrough */
 	case IOMMU_DOMAIN_UNMANAGED:
 		dmar_domain = alloc_domain(0);
 		if (!dmar_domain) {
* Unmerged path drivers/iommu/virtio-iommu.c
diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index 6aaad9ad3b61..3f9fe180f389 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -2624,7 +2624,7 @@ static bool allocate_vpe_l2_table(int cpu, u32 id)
 	switch (gpsz) {
 	default:
 		WARN_ON(1);
-		/* fall through */
+		fallthrough;
 	case GIC_PAGE_SIZE_4K:
 		psz = SZ_4K;
 		break;
@@ -2719,7 +2719,7 @@ static int allocate_vpe_l1_table(void)
 	switch (gpsz) {
 	default:
 		gpsz = GIC_PAGE_SIZE_4K;
-		/* fall through */
+		fallthrough;
 	case GIC_PAGE_SIZE_4K:
 		psz = SZ_4K;
 		break;
diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c
index f4f7d3b77beb..02f64b2025ca 100644
--- a/drivers/irqchip/irq-gic-v3.c
+++ b/drivers/irqchip/irq-gic-v3.c
@@ -976,10 +976,10 @@ static void gic_cpu_sys_reg_init(void)
 		case 7:
 			write_gicreg(0, ICC_AP0R3_EL1);
 			write_gicreg(0, ICC_AP0R2_EL1);
-		/* Fall through */
+			fallthrough;
 		case 6:
 			write_gicreg(0, ICC_AP0R1_EL1);
-		/* Fall through */
+			fallthrough;
 		case 5:
 		case 4:
 			write_gicreg(0, ICC_AP0R0_EL1);
@@ -993,10 +993,10 @@ static void gic_cpu_sys_reg_init(void)
 	case 7:
 		write_gicreg(0, ICC_AP1R3_EL1);
 		write_gicreg(0, ICC_AP1R2_EL1);
-		/* Fall through */
+		fallthrough;
 	case 6:
 		write_gicreg(0, ICC_AP1R1_EL1);
-		/* Fall through */
+		fallthrough;
 	case 5:
 	case 4:
 		write_gicreg(0, ICC_AP1R0_EL1);
* Unmerged path drivers/irqchip/irq-imx-gpcv2.c
diff --git a/drivers/irqchip/irq-mips-gic.c b/drivers/irqchip/irq-mips-gic.c
index d32268cc1174..edfb9e4d5f92 100644
--- a/drivers/irqchip/irq-mips-gic.c
+++ b/drivers/irqchip/irq-mips-gic.c
@@ -480,7 +480,7 @@ static int gic_irq_domain_map(struct irq_domain *d, unsigned int virq,
 	case GIC_LOCAL_INT_TIMER:
 		/* CONFIG_MIPS_CMP workaround (see __gic_init) */
 		map = GIC_MAP_PIN_MAP_TO_PIN | timer_cpu_pin;
-		/* fall-through */
+		fallthrough;
 	case GIC_LOCAL_INT_PERFCTR:
 	case GIC_LOCAL_INT_FDC:
 		/*
diff --git a/drivers/irqchip/irq-vic.c b/drivers/irqchip/irq-vic.c
index 74192f62dd67..1eadde2628d2 100644
--- a/drivers/irqchip/irq-vic.c
+++ b/drivers/irqchip/irq-vic.c
@@ -465,7 +465,7 @@ void __init __vic_init(void __iomem *base, int parent_irq, int irq_start,
 		return;
 	default:
 		printk(KERN_WARNING "VIC: unknown vendor, continuing anyways\n");
-		/* fall through */
+		fallthrough;
 	case AMBA_VENDOR_ARM:
 		break;
 	}
* Unmerged path drivers/isdn/hardware/mISDN/avmfritz.c
diff --git a/drivers/isdn/hardware/mISDN/hfc_multi_8xx.h b/drivers/isdn/hardware/mISDN/hfc_multi_8xx.h
index b0d772340e16..448ded8f9d24 100644
--- a/drivers/isdn/hardware/mISDN/hfc_multi_8xx.h
+++ b/drivers/isdn/hardware/mISDN/hfc_multi_8xx.h
@@ -121,7 +121,6 @@ setup_embedded(struct hfc_multi *hc, struct hm_map *m)
 	case HFC_IO_MODE_EMBSD:
 		test_and_set_bit(HFC_CHIP_EMBSD, &hc->chip);
 		hc->slots = 128; /* required */
-		/* fall through */
 		hc->HFC_outb = HFC_outb_embsd;
 		hc->HFC_inb = HFC_inb_embsd;
 		hc->HFC_inw = HFC_inw_embsd;
* Unmerged path drivers/isdn/hardware/mISDN/hfcpci.c
diff --git a/drivers/isdn/hardware/mISDN/hfcsusb.c b/drivers/isdn/hardware/mISDN/hfcsusb.c
index 17cc879ad2bb..949f089a87a0 100644
--- a/drivers/isdn/hardware/mISDN/hfcsusb.c
+++ b/drivers/isdn/hardware/mISDN/hfcsusb.c
@@ -708,7 +708,7 @@ hfcsusb_setup_bch(struct bchannel *bch, int protocol)
 	switch (protocol) {
 	case (-1):	/* used for init */
 		bch->state = -1;
-		/* fall through */
+		fallthrough;
 	case (ISDN_P_NONE):
 		if (bch->state == ISDN_P_NONE)
 			return 0; /* already in idle state */
* Unmerged path drivers/isdn/hardware/mISDN/mISDNinfineon.c
* Unmerged path drivers/isdn/hardware/mISDN/mISDNisar.c
diff --git a/drivers/isdn/i4l/isdnhdlc.c b/drivers/isdn/i4l/isdnhdlc.c
index 027d1c590679..41a2a39c5d66 100644
--- a/drivers/isdn/i4l/isdnhdlc.c
+++ b/drivers/isdn/i4l/isdnhdlc.c
@@ -410,7 +410,7 @@ int isdnhdlc_encode(struct isdnhdlc_vars *hdlc, const u8 *src, u16 slen,
 				dsize--;
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		case HDLC_SENDFLAG_ONE:
 			if (hdlc->bit_shift == 8) {
 				hdlc->cbin = hdlc->ffvalue >>
* Unmerged path drivers/isdn/mISDN/stack.c
* Unmerged path drivers/lightnvm/pblk-core.c
diff --git a/drivers/macintosh/adbhid.c b/drivers/macintosh/adbhid.c
index a261892c03b3..fb11daad154a 100644
--- a/drivers/macintosh/adbhid.c
+++ b/drivers/macintosh/adbhid.c
@@ -880,7 +880,7 @@ adbhid_input_register(int id, int default_id, int original_handler_id,
 		}
 		if (hid->name[0])
 			break;
-		/* else fall through */
+		fallthrough;
 
 	default:
 		pr_info("Trying to register unknown ADB device to input layer.\n");
* Unmerged path drivers/macintosh/smu.c
diff --git a/drivers/md/bcache/journal.c b/drivers/md/bcache/journal.c
index 18f1b5239620..025636d895f3 100644
--- a/drivers/md/bcache/journal.c
+++ b/drivers/md/bcache/journal.c
@@ -465,7 +465,7 @@ static void do_journal_discard(struct cache *ca)
 			ca->sb.njournal_buckets;
 
 		atomic_set(&ja->discard_in_flight, DISCARD_READY);
-		/* fallthrough */
+		fallthrough;
 
 	case DISCARD_READY:
 		if (ja->discard_idx == ja->last_idx)
diff --git a/drivers/md/bcache/util.c b/drivers/md/bcache/util.c
index fc479b026d6d..f2d44bd18371 100644
--- a/drivers/md/bcache/util.c
+++ b/drivers/md/bcache/util.c
@@ -32,27 +32,27 @@ int bch_ ## name ## _h(const char *cp, type *res)		\
 	case 'y':						\
 	case 'z':						\
 		u++;						\
-		/* fall through */				\
+		fallthrough;					\
 	case 'e':						\
 		u++;						\
-		/* fall through */				\
+		fallthrough;					\
 	case 'p':						\
 		u++;						\
-		/* fall through */				\
+		fallthrough;					\
 	case 't':						\
 		u++;						\
-		/* fall through */				\
+		fallthrough;					\
 	case 'g':						\
 		u++;						\
-		/* fall through */				\
+		fallthrough;					\
 	case 'm':						\
 		u++;						\
-		/* fall through */				\
+		fallthrough;					\
 	case 'k':						\
 		u++;						\
 		if (e++ == cp)					\
 			return -EINVAL;				\
-		/* fall through */				\
+		fallthrough;					\
 	case '\n':						\
 	case '\0':						\
 		if (*e == '\n')					\
diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index 8db489a72c72..a6a44ca7d6f6 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -1552,7 +1552,7 @@ static blk_status_t crypt_convert(struct crypt_config *cc,
 		case -EBUSY:
 			wait_for_completion(&ctx->restart);
 			reinit_completion(&ctx->restart);
-			/* fall through */
+			fallthrough;
 		/*
 		 * The request is queued and processed asynchronously,
 		 * completion function kcryptd_async_done() will be called.
diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 53d3829f487d..9413e26612c3 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -1559,7 +1559,7 @@ static void pg_init_done(void *data, int errors)
 	case SCSI_DH_RETRY:
 		/* Wait before retrying. */
 		delay_retry = true;
-		/* fall through */
+		fallthrough;
 	case SCSI_DH_IMM_RETRY:
 	case SCSI_DH_RES_TEMP_UNAVAIL:
 		if (pg_init_limit_reached(m, pgpath))
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index a5481d5bf4d3..8b953877fc6d 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -1009,7 +1009,7 @@ static void clone_endio(struct bio *bio)
 		switch (r) {
 		case DM_ENDIO_REQUEUE:
 			error = BLK_STS_DM_REQUEUE;
-			/*FALLTHRU*/
+			fallthrough;
 		case DM_ENDIO_DONE:
 			break;
 		case DM_ENDIO_INCOMPLETE:
diff --git a/drivers/md/md-bitmap.c b/drivers/md/md-bitmap.c
index 06bcf98e1dac..eae8e1113d05 100644
--- a/drivers/md/md-bitmap.c
+++ b/drivers/md/md-bitmap.c
@@ -1436,7 +1436,7 @@ int md_bitmap_startwrite(struct bitmap *bitmap, sector_t offset, unsigned long s
 		case 0:
 			md_bitmap_file_set_bit(bitmap, offset);
 			md_bitmap_count_page(&bitmap->counts, offset, 1);
-			/* fall through */
+			fallthrough;
 		case 1:
 			*bmc = 2;
 		}
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index d82673916262..3f75dc74a945 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -4266,7 +4266,7 @@ static void handle_parity_checks5(struct r5conf *conf, struct stripe_head *sh,
 			break;
 		}
 		dev = &sh->dev[s->failed_num[0]];
-		/* fall through */
+		fallthrough;
 	case check_state_compute_result:
 		sh->check_state = check_state_idle;
 		if (!dev)
@@ -4397,7 +4397,7 @@ static void handle_parity_checks6(struct r5conf *conf, struct stripe_head *sh,
 
 		/* we have 2-disk failure */
 		BUG_ON(s->failed != 2);
-		/* fall through */
+		fallthrough;
 	case check_state_compute_result:
 		sh->check_state = check_state_idle;
 
* Unmerged path drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
diff --git a/drivers/media/dvb-core/dvb_net.c b/drivers/media/dvb-core/dvb_net.c
index 10f78109bb3f..04f0bd05c300 100644
--- a/drivers/media/dvb-core/dvb_net.c
+++ b/drivers/media/dvb-core/dvb_net.c
@@ -557,7 +557,7 @@ static int dvb_net_ule_new_payload(struct dvb_net_ule_handle *h)
 		h->priv->ule_sndu_type_1 = 1;
 		h->ts_remain -= 1;
 		h->from_where += 1;
-		/* fallthrough */
+		fallthrough;
 	case 0:
 		h->new_ts = 1;
 		h->ts += TS_SZ;
diff --git a/drivers/media/dvb-frontends/bcm3510.c b/drivers/media/dvb-frontends/bcm3510.c
index 05df133dc5be..4bb1657bbd16 100644
--- a/drivers/media/dvb-frontends/bcm3510.c
+++ b/drivers/media/dvb-frontends/bcm3510.c
@@ -773,7 +773,7 @@ static int bcm3510_init(struct dvb_frontend* fe)
 			deb_info("attempting to download firmware\n");
 			if ((ret = bcm3510_init_cold(st)) < 0)
 				return ret;
-			/* fall-through */
+			fallthrough;
 		case JDEC_EEPROM_LOAD_WAIT:
 			deb_info("firmware is loaded\n");
 			bcm3510_check_firmware_version(st);
diff --git a/drivers/media/dvb-frontends/dib0090.c b/drivers/media/dvb-frontends/dib0090.c
index ee7af34979ed..64ca2bf8e908 100644
--- a/drivers/media/dvb-frontends/dib0090.c
+++ b/drivers/media/dvb-frontends/dib0090.c
@@ -1705,7 +1705,7 @@ static int dib0090_dc_offset_calibration(struct dib0090_state *state, enum front
 		if (state->identity.p1g)
 			state->dc = dc_p1g_table;
 
-		/* fall through */
+		fallthrough;
 	case CT_TUNER_STEP_0:
 		dprintk("Start/continue DC calibration for %s path\n",
 			(state->dc->i == 1) ? "I" : "Q");
diff --git a/drivers/media/dvb-frontends/dib3000mb.c b/drivers/media/dvb-frontends/dib3000mb.c
index 71754e7c2059..e8eb64978a90 100644
--- a/drivers/media/dvb-frontends/dib3000mb.c
+++ b/drivers/media/dvb-frontends/dib3000mb.c
@@ -224,7 +224,7 @@ static int dib3000mb_set_frontend(struct dvb_frontend *fe, int tuner)
 	switch (c->hierarchy) {
 		case HIERARCHY_NONE:
 			deb_setf("hierarchy: none\n");
-			/* fall through */
+			fallthrough;
 		case HIERARCHY_1:
 			deb_setf("hierarchy: alpha=1\n");
 			wr(DIB3000MB_REG_VIT_ALPHA, DIB3000_ALPHA_1);
diff --git a/drivers/media/dvb-frontends/dib7000p.c b/drivers/media/dvb-frontends/dib7000p.c
index 5a8dbc0b25fb..e5db132e93ba 100644
--- a/drivers/media/dvb-frontends/dib7000p.c
+++ b/drivers/media/dvb-frontends/dib7000p.c
@@ -279,7 +279,7 @@ static int dib7000p_set_power_mode(struct dib7000p_state *state, enum dib7000p_p
 		if (state->version != SOC7090)
 			reg_1280 &= ~((1 << 11));
 		reg_1280 &= ~(1 << 6);
-		/* fall-through */
+		fallthrough;
 	case DIB7000P_POWER_INTERFACE_ONLY:
 		/* just leave power on the control-interfaces: GPIO and (I2C or SDIO) */
 		/* TODO power up either SDIO or I2C */
* Unmerged path drivers/media/dvb-frontends/drx39xyj/drxj.c
* Unmerged path drivers/media/dvb-frontends/drxd_hard.c
* Unmerged path drivers/media/dvb-frontends/drxk_hard.c
diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index 32de824476db..0b03a829eeb2 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -777,7 +777,7 @@ static int lgdt3306a_set_if(struct lgdt3306a_state *state,
 	default:
 		pr_warn("IF=%d KHz is not supported, 3250 assumed\n",
 			if_freq_khz);
-		/* fallthrough */
+		fallthrough;
 	case 3250: /* 3.25Mhz */
 		nco1 = 0x34;
 		nco2 = 0x00;
diff --git a/drivers/media/dvb-frontends/mt352.c b/drivers/media/dvb-frontends/mt352.c
index a440b76444d3..d33e58c515b7 100644
--- a/drivers/media/dvb-frontends/mt352.c
+++ b/drivers/media/dvb-frontends/mt352.c
@@ -211,7 +211,7 @@ static int mt352_set_parameters(struct dvb_frontend *fe)
 			if (op->hierarchy == HIERARCHY_AUTO ||
 			    op->hierarchy == HIERARCHY_NONE)
 				break;
-			/* fall through */
+			fallthrough;
 		default:
 			return -EINVAL;
 	}
* Unmerged path drivers/media/dvb-frontends/mxl5xx.c
diff --git a/drivers/media/dvb-frontends/or51132.c b/drivers/media/dvb-frontends/or51132.c
index b4c9aadcb552..5f9609ad77a1 100644
--- a/drivers/media/dvb-frontends/or51132.c
+++ b/drivers/media/dvb-frontends/or51132.c
@@ -493,7 +493,7 @@ static int or51132_read_snr(struct dvb_frontend* fe, u16* snr)
 	switch (reg&0xff) {
 	case 0x06:
 		if (reg & 0x1000) usK = 3 << 24;
-		/* fall through */
+		fallthrough;
 	case 0x43: /* QAM64 */
 		c = 150204167;
 		break;
diff --git a/drivers/media/dvb-frontends/s5h1411.c b/drivers/media/dvb-frontends/s5h1411.c
index af5962807f2c..db51e62e28b1 100644
--- a/drivers/media/dvb-frontends/s5h1411.c
+++ b/drivers/media/dvb-frontends/s5h1411.c
@@ -410,7 +410,7 @@ static int s5h1411_set_if_freq(struct dvb_frontend *fe, int KHz)
 	default:
 		dprintk("%s(%d KHz) Invalid, defaulting to 5380\n",
 			__func__, KHz);
-		/* fall through */
+		fallthrough;
 	case 5380:
 	case 44000:
 		s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x1be4);
diff --git a/drivers/media/dvb-frontends/zl10353.c b/drivers/media/dvb-frontends/zl10353.c
index c9901f45deb7..e8dbe888874d 100644
--- a/drivers/media/dvb-frontends/zl10353.c
+++ b/drivers/media/dvb-frontends/zl10353.c
@@ -211,7 +211,7 @@ static int zl10353_set_parameters(struct dvb_frontend *fe)
 		break;
 	default:
 		c->bandwidth_hz = 8000000;
-		/* fall through */
+		fallthrough;
 	case 8000000:
 		zl10353_single_write(fe, MCLK_RATIO, 0x75);
 		zl10353_single_write(fe, 0x64, 0x36);
@@ -268,7 +268,7 @@ static int zl10353_set_parameters(struct dvb_frontend *fe)
 		if (c->hierarchy == HIERARCHY_AUTO ||
 		    c->hierarchy == HIERARCHY_NONE)
 			break;
-		/* fall through */
+		fallthrough;
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/media/pci/cx23885/cx23885-cards.c b/drivers/media/pci/cx23885/cx23885-cards.c
index 9f50748fdf56..3cbd2213e72d 100644
--- a/drivers/media/pci/cx23885/cx23885-cards.c
+++ b/drivers/media/pci/cx23885/cx23885-cards.c
@@ -2156,7 +2156,7 @@ void cx23885_card_setup(struct cx23885_dev *dev)
 		ts2->gen_ctrl_val  = 0xc; /* Serial bus + punctured clock */
 		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
 		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
-		/* fall-through */
+		fallthrough;
 	case CX23885_BOARD_DVICO_FUSIONHDTV_5_EXP:
 		ts1->gen_ctrl_val  = 0xc; /* Serial bus + punctured clock */
 		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
@@ -2317,7 +2317,7 @@ void cx23885_card_setup(struct cx23885_dev *dev)
 		/* Currently only enabled for the integrated IR controller */
 		if (!enable_885_ir)
 			break;
-		/* fall-through */
+		fallthrough;
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
 	case CX23885_BOARD_HAUPPAUGE_HVR1800:
 	case CX23885_BOARD_HAUPPAUGE_IMPACTVCBE:
diff --git a/drivers/media/pci/ddbridge/ddbridge-core.c b/drivers/media/pci/ddbridge/ddbridge-core.c
index d5b0d1eaf3ad..5f716211ac6f 100644
--- a/drivers/media/pci/ddbridge/ddbridge-core.c
+++ b/drivers/media/pci/ddbridge/ddbridge-core.c
@@ -1306,7 +1306,7 @@ static void dvb_input_detach(struct ddb_input *input)
 			dvb_unregister_frontend(dvb->fe2);
 		if (dvb->fe)
 			dvb_unregister_frontend(dvb->fe);
-		/* fallthrough */
+		fallthrough;
 	case 0x30:
 		dvb_module_release(dvb->i2c_client[0]);
 		dvb->i2c_client[0] = NULL;
@@ -1317,22 +1317,22 @@ static void dvb_input_detach(struct ddb_input *input)
 			dvb_frontend_detach(dvb->fe);
 		dvb->fe = NULL;
 		dvb->fe2 = NULL;
-		/* fallthrough */
+		fallthrough;
 	case 0x20:
 		dvb_net_release(&dvb->dvbnet);
-		/* fallthrough */
+		fallthrough;
 	case 0x12:
 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
 					      &dvb->hw_frontend);
 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
 					      &dvb->mem_frontend);
-		/* fallthrough */
+		fallthrough;
 	case 0x11:
 		dvb_dmxdev_release(&dvb->dmxdev);
-		/* fallthrough */
+		fallthrough;
 	case 0x10:
 		dvb_dmx_release(&dvb->demux);
-		/* fallthrough */
+		fallthrough;
 	case 0x01:
 		break;
 	}
@@ -1555,7 +1555,7 @@ static int dvb_input_attach(struct ddb_input *input)
 			osc24 = 0;
 		else
 			osc24 = 1;
-		/* fall-through */
+		fallthrough;
 	case DDB_TUNER_DVBCT2_SONY_P:
 	case DDB_TUNER_DVBC2T2_SONY_P:
 	case DDB_TUNER_ISDBT_SONY_P:
@@ -1571,7 +1571,7 @@ static int dvb_input_attach(struct ddb_input *input)
 		break;
 	case DDB_TUNER_DVBC2T2I_SONY:
 		osc24 = 1;
-		/* fall-through */
+		fallthrough;
 	case DDB_TUNER_DVBCT2_SONY:
 	case DDB_TUNER_DVBC2T2_SONY:
 	case DDB_TUNER_ISDBT_SONY:
@@ -2031,7 +2031,7 @@ static int ddb_port_attach(struct ddb_port *port)
 		ret = ddb_ci_attach(port, ci_bitrate);
 		if (ret < 0)
 			break;
-		/* fall-through */
+		fallthrough;
 	case DDB_PORT_LOOP:
 		ret = dvb_register_device(port->dvb[0].adap,
 					  &port->dvb[0].dev,
@@ -2427,7 +2427,8 @@ void ddb_ports_init(struct ddb *dev)
 					ddb_input_init(port, 4 + i, 1, 4 + i);
 					ddb_output_init(port, i);
 					break;
-				} /* fallthrough */
+				}
+				fallthrough;
 			case DDB_OCTOPUS:
 				ddb_input_init(port, 2 * i, 0, 2 * i);
 				ddb_input_init(port, 2 * i + 1, 1, 2 * i + 1);
@@ -3412,7 +3413,7 @@ int ddb_exit_ddbridge(int stage, int error)
 	default:
 	case 2:
 		destroy_workqueue(ddb_wq);
-		/* fall-through */
+		fallthrough;
 	case 1:
 		ddb_class_destroy();
 		break;
diff --git a/drivers/media/pci/meye/meye.c b/drivers/media/pci/meye/meye.c
index 8001d3e9134e..6748a88e6b04 100644
--- a/drivers/media/pci/meye/meye.c
+++ b/drivers/media/pci/meye/meye.c
@@ -961,7 +961,7 @@ static int meyeioc_sync(struct file *file, void *fh, int *i)
 			mutex_unlock(&meye.lock);
 			return -EINTR;
 		}
-		/* fall through */
+		fallthrough;
 	case MEYE_BUF_DONE:
 		meye.grab_buffer[*i].state = MEYE_BUF_UNUSED;
 		if (kfifo_out_locked(&meye.doneq, (unsigned char *)&unused,
diff --git a/drivers/media/pci/ttpci/av7110.c b/drivers/media/pci/ttpci/av7110.c
index 409defc75c05..abb9e332413d 100644
--- a/drivers/media/pci/ttpci/av7110.c
+++ b/drivers/media/pci/ttpci/av7110.c
@@ -654,7 +654,7 @@ static void gpioirq(unsigned long cookie)
 			iwdebi(av7110, DEBINOSWAP, RX_BUFF, 0, 2);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 
 	case DATA_TS_RECORD:
 	case DATA_PES_RECORD:
@@ -2191,7 +2191,7 @@ static int frontend_init(struct av7110 *av7110)
 				break;
 			}
 		}
-		/* fall-thru */
+			fallthrough;
 
 		case 0x0008: // Hauppauge/TT DVB-T
 			// Grundig 29504-401
diff --git a/drivers/media/pci/ttpci/av7110_hw.c b/drivers/media/pci/ttpci/av7110_hw.c
index b2b79bb73917..6e45731be9d7 100644
--- a/drivers/media/pci/ttpci/av7110_hw.c
+++ b/drivers/media/pci/ttpci/av7110_hw.c
@@ -1119,7 +1119,7 @@ int av7110_osd_cmd(struct av7110 *av7110, osd_cmd_t *dc)
 		break;
 	case OSD_SetRow:
 		dc->y1 = dc->y0;
-		/* fall through */
+		fallthrough;
 	case OSD_SetBlock:
 		ret = OSDSetBlock(av7110, dc->x0, dc->y0, dc->x1, dc->y1, dc->color, dc->data);
 		break;
diff --git a/drivers/media/pci/ttpci/av7110_ipack.c b/drivers/media/pci/ttpci/av7110_ipack.c
index ec528fae7333..30330ed01ce8 100644
--- a/drivers/media/pci/ttpci/av7110_ipack.c
+++ b/drivers/media/pci/ttpci/av7110_ipack.c
@@ -182,7 +182,7 @@ int av7110_ipack_instant_repack (const u8 *buf, int count, struct ipack *p)
 			case DSM_CC_STREAM  :
 			case ISO13522_STREAM:
 				p->done = 1;
-				/* fall through */
+				fallthrough;
 			case PRIVATE_STREAM1:
 			case VIDEO_STREAM_S ... VIDEO_STREAM_E:
 			case AUDIO_STREAM_S ... AUDIO_STREAM_E:
diff --git a/drivers/media/pci/ttpci/budget-av.c b/drivers/media/pci/ttpci/budget-av.c
index abc98f1ad26c..b2fdb7ff9d63 100644
--- a/drivers/media/pci/ttpci/budget-av.c
+++ b/drivers/media/pci/ttpci/budget-av.c
@@ -1240,7 +1240,7 @@ static void frontend_init(struct budget_av *budget_av)
 		 * but so far it has been only confirmed for this type
 		 */
 		budget_av->reinitialise_demod = 1;
-		/* fall through */
+		fallthrough;
 	case SUBID_DVBS_KNC1_PLUS:
 	case SUBID_DVBS_EASYWATCH_1:
 		if (saa->pci->subsystem_vendor == 0x1894) {
diff --git a/drivers/media/pci/ttpci/budget.c b/drivers/media/pci/ttpci/budget.c
index f59eadb7a5eb..fa4413a59e05 100644
--- a/drivers/media/pci/ttpci/budget.c
+++ b/drivers/media/pci/ttpci/budget.c
@@ -627,7 +627,7 @@ static void frontend_init(struct budget *budget)
 			break;
 		}
 	}
-	/* fall through */
+		fallthrough;
 	case 0x1018: // TT Budget-S-1401 (philips tda10086/philips tda8262)
 	{
 		struct dvb_frontend *fe;
@@ -652,7 +652,7 @@ static void frontend_init(struct budget *budget)
 			break;
 		}
 	}
-	/* fall through */
+		fallthrough;
 
 	case 0x101c: { /* TT S2-1600 */
 			const struct stv6110x_devctl *ctl;
diff --git a/drivers/media/platform/sh_vou.c b/drivers/media/platform/sh_vou.c
index 3f8f64b2b9db..b5835ccb99f4 100644
--- a/drivers/media/platform/sh_vou.c
+++ b/drivers/media/platform/sh_vou.c
@@ -229,7 +229,7 @@ static void sh_vou_stream_config(struct sh_vou_device *vou_dev)
 		break;
 	case V4L2_PIX_FMT_RGB565:
 		dataswap ^= 1;
-		/* fall through */
+		fallthrough;
 	case V4L2_PIX_FMT_RGB565X:
 		row_coeff = 2;
 		break;
@@ -816,7 +816,7 @@ static u32 sh_vou_ntsc_mode(enum sh_vou_bus_fmt bus_fmt)
 	default:
 		pr_warn("%s(): Invalid bus-format code %d, using default 8-bit\n",
 			__func__, bus_fmt);
-		/* fall through */
+		fallthrough;
 	case SH_VOU_BUS_8BIT:
 		return 1;
 	case SH_VOU_BUS_16BIT:
diff --git a/drivers/media/radio/radio-si476x.c b/drivers/media/radio/radio-si476x.c
index 269971145f88..3275fecb49ea 100644
--- a/drivers/media/radio/radio-si476x.c
+++ b/drivers/media/radio/radio-si476x.c
@@ -114,7 +114,8 @@ static inline enum phase_diversity_modes_idx
 si476x_phase_diversity_mode_to_idx(enum si476x_phase_diversity_mode mode)
 {
 	switch (mode) {
-	default:		/* FALLTHROUGH */
+	default:
+		fallthrough;
 	case SI476X_PHDIV_DISABLED:
 		return SI476X_IDX_PHDIV_DISABLED;
 	case SI476X_PHDIV_PRIMARY_COMBINING:
diff --git a/drivers/media/radio/tea575x.c b/drivers/media/radio/tea575x.c
index f89f83e04741..7cc2a791ee42 100644
--- a/drivers/media/radio/tea575x.c
+++ b/drivers/media/radio/tea575x.c
@@ -264,7 +264,7 @@ int snd_tea575x_enum_freq_bands(struct snd_tea575x *tea,
 			index = BAND_AM;
 			break;
 		}
-		/* Fall through */
+		fallthrough;
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/media/rc/bpf-lirc.c b/drivers/media/rc/bpf-lirc.c
index 91a333032c1f..4dddffa9119a 100644
--- a/drivers/media/rc/bpf-lirc.c
+++ b/drivers/media/rc/bpf-lirc.c
@@ -119,7 +119,7 @@ lirc_mode2_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
 	case BPF_FUNC_trace_printk:
 		if (capable(CAP_SYS_ADMIN))
 			return bpf_get_trace_printk_proto();
-		/* fall through */
+		fallthrough;
 	default:
 		return NULL;
 	}
diff --git a/drivers/media/rc/ir-rc6-decoder.c b/drivers/media/rc/ir-rc6-decoder.c
index 68487ce9f79b..65eae0e3ac83 100644
--- a/drivers/media/rc/ir-rc6-decoder.c
+++ b/drivers/media/rc/ir-rc6-decoder.c
@@ -70,7 +70,7 @@ static enum rc6_mode rc6_mode(struct rc6_dec *data)
 	case 6:
 		if (!data->toggle)
 			return RC6_MODE_6A;
-		/* fall through */
+		fallthrough;
 	default:
 		return RC6_MODE_UNKNOWN;
 	}
diff --git a/drivers/media/rc/ir-sony-decoder.c b/drivers/media/rc/ir-sony-decoder.c
index 5065c081238d..50d9e32edee6 100644
--- a/drivers/media/rc/ir-sony-decoder.c
+++ b/drivers/media/rc/ir-sony-decoder.c
@@ -110,7 +110,7 @@ static int ir_sony_decode(struct rc_dev *dev, struct ir_raw_event ev)
 		}
 
 		data->state = STATE_FINISHED;
-		/* Fall through */
+		fallthrough;
 
 	case STATE_FINISHED:
 		if (ev.pulse)
diff --git a/drivers/media/tuners/xc5000.c b/drivers/media/tuners/xc5000.c
index f7a8d05d1758..912135c57536 100644
--- a/drivers/media/tuners/xc5000.c
+++ b/drivers/media/tuners/xc5000.c
@@ -766,7 +766,7 @@ static int xc5000_set_digital_params(struct dvb_frontend *fe)
 		if (!bw)
 			bw = 6000000;
 		/* fall to OFDM handling */
-		/* fall through */
+		fallthrough;
 	case SYS_DMBTH:
 	case SYS_DVBT:
 	case SYS_DVBT2:
diff --git a/drivers/media/usb/b2c2/flexcop-usb.c b/drivers/media/usb/b2c2/flexcop-usb.c
index 1826ff825c2e..c23b3a8cdd17 100644
--- a/drivers/media/usb/b2c2/flexcop-usb.c
+++ b/drivers/media/usb/b2c2/flexcop-usb.c
@@ -516,7 +516,7 @@ static int flexcop_usb_init(struct flexcop_usb *fc_usb)
 	case USB_SPEED_HIGH:
 		info("running at HIGH speed.");
 		break;
-	case USB_SPEED_UNKNOWN: /* fall through */
+	case USB_SPEED_UNKNOWN:
 	default:
 		err("cannot handle USB speed because it is unknown.");
 		return -ENODEV;
diff --git a/drivers/media/usb/cpia2/cpia2_core.c b/drivers/media/usb/cpia2/cpia2_core.c
index 20c50c2d042e..e747548ab286 100644
--- a/drivers/media/usb/cpia2/cpia2_core.c
+++ b/drivers/media/usb/cpia2/cpia2_core.c
@@ -165,7 +165,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VP_BRIGHTNESS:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VP_BRIGHTNESS:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -176,7 +176,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_CONTRAST:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_CONTRAST:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -184,7 +184,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VP_SATURATION:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VP_SATURATION:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -195,7 +195,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VP_GPIO_DATA:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VP_GPIO_DATA:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -203,7 +203,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VP_GPIO_DIRECTION:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VP_GPIO_DIRECTION:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -211,7 +211,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VC_MP_GPIO_DATA:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VC_MP_GPIO_DATA:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
 		cmd.reg_count = 1;
@@ -219,7 +219,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VC_MP_GPIO_DIRECTION:
 		cmd.buffer.block_data[0] = param;
-		/*fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VC_MP_GPIO_DIRECTION:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
 		cmd.reg_count = 1;
@@ -234,7 +234,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_FLICKER_MODES:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_FLICKER_MODES:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -281,7 +281,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_USER_MODE:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_USER_MODE:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -301,7 +301,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_WAKEUP:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_WAKEUP:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
 		cmd.reg_count = 1;
@@ -309,7 +309,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_PW_CONTROL:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_PW_CONTROL:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
 		cmd.reg_count = 1;
@@ -322,7 +322,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_SYSTEM_CTRL:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_SYSTEM_CTRL:
 		cmd.req_mode =
 		    CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_SYSTEM;
@@ -331,7 +331,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VP_SYSTEM_CTRL:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VP_SYSTEM_CTRL:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -339,7 +339,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VP_EXP_MODES:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VP_EXP_MODES:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -347,7 +347,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_DEVICE_CONFIG:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_DEVICE_CONFIG:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -368,7 +368,7 @@ int cpia2_do_command(struct camera_data *cam,
 		break;
 	case CPIA2_CMD_SET_VC_CONTROL:
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_VC_CONTROL:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VC;
 		cmd.reg_count = 1;
@@ -403,7 +403,7 @@ int cpia2_do_command(struct camera_data *cam,
 					     this register can also affect
 					     flicker modes */
 		cmd.buffer.block_data[0] = param;
-		/* fall through */
+		fallthrough;
 	case CPIA2_CMD_GET_USER_EFFECTS:
 		cmd.req_mode = CAMERAACCESS_TYPE_BLOCK | CAMERAACCESS_VP;
 		cmd.reg_count = 1;
@@ -1751,7 +1751,7 @@ int cpia2_set_fps(struct camera_data *cam, int framerate)
 						    CPIA2_VP_SENSOR_FLAGS_500) {
 				return -EINVAL;
 			}
-			/* Fall through */
+			fallthrough;
 		case CPIA2_VP_FRAMERATE_15:
 		case CPIA2_VP_FRAMERATE_12_5:
 		case CPIA2_VP_FRAMERATE_7_5:
diff --git a/drivers/media/usb/cx231xx/cx231xx-video.c b/drivers/media/usb/cx231xx/cx231xx-video.c
index 82d0fc385e05..19b754dc105b 100644
--- a/drivers/media/usb/cx231xx/cx231xx-video.c
+++ b/drivers/media/usb/cx231xx/cx231xx-video.c
@@ -1122,7 +1122,7 @@ void cx231xx_v4l2_create_entities(struct cx231xx *dev)
 			/* The DVB core will handle it */
 			if (dev->tuner_type == TUNER_ABSENT)
 				continue;
-			/* fall through */
+			fallthrough;
 		default: /* just to shut up a gcc warning */
 			ent->function = MEDIA_ENT_F_CONN_RF;
 			break;
diff --git a/drivers/media/usb/dvb-usb/dib0700_devices.c b/drivers/media/usb/dvb-usb/dib0700_devices.c
index 9311f7d4bba5..41dad2e3f900 100644
--- a/drivers/media/usb/dvb-usb/dib0700_devices.c
+++ b/drivers/media/usb/dvb-usb/dib0700_devices.c
@@ -1663,7 +1663,7 @@ static int dib8096_set_param_override(struct dvb_frontend *fe)
 	switch (band) {
 	default:
 			deb_info("Warning : Rf frequency  (%iHz) is not in the supported range, using VHF switch ", fe->dtv_property_cache.frequency);
-			/* fall through */
+		fallthrough;
 	case BAND_VHF:
 			state->dib8000_ops.set_gpio(fe, 3, 0, 1);
 			break;
diff --git a/drivers/media/usb/dvb-usb/dw2102.c b/drivers/media/usb/dvb-usb/dw2102.c
index eefe2867815c..3cfa38b1b30e 100644
--- a/drivers/media/usb/dvb-usb/dw2102.c
+++ b/drivers/media/usb/dvb-usb/dw2102.c
@@ -1839,12 +1839,12 @@ static int dw2102_load_firmware(struct usb_device *dev,
 		switch (le16_to_cpu(dev->descriptor.idProduct)) {
 		case USB_PID_TEVII_S650:
 			dw2104_properties.rc.core.rc_codes = RC_MAP_TEVII_NEC;
-			/* fall through */
+			fallthrough;
 		case USB_PID_DW2104:
 			reset = 1;
 			dw210x_op_rw(dev, 0xc4, 0x0000, 0, &reset, 1,
 					DW210X_WRITE_MSG);
-			/* fall through */
+			fallthrough;
 		case USB_PID_DW3101:
 			reset = 0;
 			dw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,
@@ -1877,7 +1877,7 @@ static int dw2102_load_firmware(struct usb_device *dev,
 					break;
 				}
 			}
-			/* fall through */
+			fallthrough;
 		case 0x2101:
 			dw210x_op_rw(dev, 0xbc, 0x0030, 0, &reset16[0], 2,
 					DW210X_READ_MSG);
diff --git a/drivers/media/usb/usbvision/usbvision-i2c.c b/drivers/media/usb/usbvision/usbvision-i2c.c
index 6e4df3335b1b..aa3ff67a3cb1 100644
--- a/drivers/media/usb/usbvision/usbvision-i2c.c
+++ b/drivers/media/usb/usbvision/usbvision-i2c.c
@@ -303,13 +303,13 @@ usbvision_i2c_read_max4(struct usb_usbvision *usbvision, unsigned char addr,
 	switch (len) {
 	case 4:
 		buf[3] = usbvision_read_reg(usbvision, USBVISION_SER_DAT4);
-		/* fall through */
+		fallthrough;
 	case 3:
 		buf[2] = usbvision_read_reg(usbvision, USBVISION_SER_DAT3);
-		/* fall through */
+		fallthrough;
 	case 2:
 		buf[1] = usbvision_read_reg(usbvision, USBVISION_SER_DAT2);
-		/* fall through */
+		fallthrough;
 	case 1:
 		buf[0] = usbvision_read_reg(usbvision, USBVISION_SER_DAT1);
 		break;
diff --git a/drivers/media/v4l2-core/v4l2-ctrls.c b/drivers/media/v4l2-core/v4l2-ctrls.c
index 7ae9c9b1ecfa..4e99eb0d146a 100644
--- a/drivers/media/v4l2-core/v4l2-ctrls.c
+++ b/drivers/media/v4l2-core/v4l2-ctrls.c
@@ -1872,7 +1872,7 @@ static int check_range(enum v4l2_ctrl_type type,
 	case V4L2_CTRL_TYPE_BOOLEAN:
 		if (step != 1 || max > 1 || min < 0)
 			return -ERANGE;
-		/* fall through */
+		fallthrough;
 	case V4L2_CTRL_TYPE_U8:
 	case V4L2_CTRL_TYPE_U16:
 	case V4L2_CTRL_TYPE_U32:
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index 110c55b528d1..fa6fe4cea427 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -740,7 +740,6 @@ static void v4l_print_frmsizeenum(const void *arg, bool write_only)
 				p->stepwise.step_height);
 		break;
 	case V4L2_FRMSIZE_TYPE_CONTINUOUS:
-		/* fall through */
 	default:
 		pr_cont("\n");
 		break;
@@ -774,7 +773,6 @@ static void v4l_print_frmivalenum(const void *arg, bool write_only)
 				p->stepwise.step.denominator);
 		break;
 	case V4L2_FRMIVAL_TYPE_CONTINUOUS:
-		/* fall through */
 	default:
 		pr_cont("\n");
 		break;
diff --git a/drivers/media/v4l2-core/videobuf-core.c b/drivers/media/v4l2-core/videobuf-core.c
index 7491b337002c..d62d52d17b23 100644
--- a/drivers/media/v4l2-core/videobuf-core.c
+++ b/drivers/media/v4l2-core/videobuf-core.c
@@ -356,7 +356,7 @@ static void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,
 		break;
 	case VIDEOBUF_ERROR:
 		b->flags |= V4L2_BUF_FLAG_ERROR;
-		/* fall through */
+		fallthrough;
 	case VIDEOBUF_DONE:
 		b->flags |= V4L2_BUF_FLAG_DONE;
 		break;
diff --git a/drivers/memory/omap-gpmc.c b/drivers/memory/omap-gpmc.c
index b9b4f7058b05..59e0a89eeef5 100644
--- a/drivers/memory/omap-gpmc.c
+++ b/drivers/memory/omap-gpmc.c
@@ -314,7 +314,6 @@ static unsigned long gpmc_get_clk_period(int cs, enum gpmc_clk_domain cd)
 		tick_ps *= div;
 		break;
 	case GPMC_CD_FCLK:
-		/* FALL-THROUGH */
 	default:
 		break;
 	}
diff --git a/drivers/memstick/core/ms_block.c b/drivers/memstick/core/ms_block.c
index 82daccc9ea62..cb9bfeb89dda 100644
--- a/drivers/memstick/core/ms_block.c
+++ b/drivers/memstick/core/ms_block.c
@@ -375,7 +375,7 @@ static int h_msb_read_page(struct memstick_dev *card,
 			serial mode), then just fall through */
 		if (msb_read_int_reg(msb, -1))
 			return 0;
-		/* fallthrough */
+		fallthrough;
 
 	case MSB_RP_RECEIVE_INT_REQ_RESULT:
 		intreg = mrq->data[0];
@@ -407,7 +407,7 @@ static int h_msb_read_page(struct memstick_dev *card,
 	case MSB_RP_RECEIVE_STATUS_REG:
 		msb->regs.status = *(struct ms_status_register *)mrq->data;
 		msb->state = MSB_RP_SEND_OOB_READ;
-		/* fallthrough */
+		fallthrough;
 
 	case MSB_RP_SEND_OOB_READ:
 		if (!msb_read_regs(msb,
@@ -422,7 +422,7 @@ static int h_msb_read_page(struct memstick_dev *card,
 		msb->regs.extra_data =
 			*(struct ms_extra_data_register *) mrq->data;
 		msb->state = MSB_RP_SEND_READ_DATA;
-		/* fallthrough */
+		fallthrough;
 
 	case MSB_RP_SEND_READ_DATA:
 		/* Skip that state if we only read the oob */
@@ -522,7 +522,7 @@ static int h_msb_write_block(struct memstick_dev *card,
 		msb->state = MSB_WB_RECEIVE_INT_REQ;
 		if (msb_read_int_reg(msb, -1))
 			return 0;
-		/* fallthrough */
+		fallthrough;
 
 	case MSB_WB_RECEIVE_INT_REQ:
 		intreg = mrq->data[0];
@@ -553,7 +553,7 @@ static int h_msb_write_block(struct memstick_dev *card,
 
 		msb->int_polling = false;
 		msb->state = MSB_WB_SEND_WRITE_DATA;
-		/* fallthrough */
+		fallthrough;
 
 	case MSB_WB_SEND_WRITE_DATA:
 		sg_init_table(sg, ARRAY_SIZE(sg));
@@ -632,7 +632,7 @@ static int h_msb_send_command(struct memstick_dev *card,
 		msb->state = MSB_SC_RECEIVE_INT_REQ;
 		if (msb_read_int_reg(msb, -1))
 			return 0;
-		/* fallthrough */
+		fallthrough;
 
 	case MSB_SC_RECEIVE_INT_REQ:
 		intreg = mrq->data[0];
* Unmerged path drivers/memstick/host/jmb38x_ms.c
* Unmerged path drivers/memstick/host/tifm_ms.c
* Unmerged path drivers/message/fusion/mptbase.c
* Unmerged path drivers/message/fusion/mptsas.c
* Unmerged path drivers/message/fusion/mptscsih.c
* Unmerged path drivers/mfd/db8500-prcmu.c
* Unmerged path drivers/mfd/iqs62x.c
* Unmerged path drivers/mfd/mxs-lradc.c
* Unmerged path drivers/mfd/omap-usb-host.c
diff --git a/drivers/mfd/rave-sp.c b/drivers/mfd/rave-sp.c
index 36dcd98977d6..4601e7876c0d 100644
--- a/drivers/mfd/rave-sp.c
+++ b/drivers/mfd/rave-sp.c
@@ -279,7 +279,7 @@ static void *stuff(unsigned char *dest, const unsigned char *src, size_t n)
 		case RAVE_SP_ETX:
 		case RAVE_SP_DLE:
 			*dest++ = RAVE_SP_DLE;
-			/* FALLTHROUGH */
+			fallthrough;
 		default:
 			*dest++ = byte;
 		}
@@ -550,7 +550,7 @@ static int rave_sp_receive_buf(struct serdev_device *serdev,
 			 * deframer buffer
 			 */
 
-			/* FALLTHROUGH */
+			fallthrough;
 
 		case RAVE_SP_EXPECT_ESCAPED_DATA:
 			if (deframer->length == sizeof(deframer->data)) {
diff --git a/drivers/mfd/syscon.c b/drivers/mfd/syscon.c
index 49e8e243dc66..393c3beb8e84 100644
--- a/drivers/mfd/syscon.c
+++ b/drivers/mfd/syscon.c
@@ -100,7 +100,7 @@ static struct syscon *of_syscon_register(struct device_node *np)
 			break;
 		default:
 			pr_err("Failed to retrieve valid hwlock: %d\n", ret);
-			/* fall-through */
+			fallthrough;
 		case -EPROBE_DEFER:
 			goto err_regmap;
 		}
* Unmerged path drivers/misc/eeprom/at25.c
* Unmerged path drivers/misc/mic/scif/scif_api.c
* Unmerged path drivers/misc/mic/scif/scif_rma.c
* Unmerged path drivers/misc/sgi-gru/grukservices.c
diff --git a/drivers/misc/sgi-xp/xpc_main.c b/drivers/misc/sgi-xp/xpc_main.c
index 83fc748a91a7..9cc58f68f047 100644
--- a/drivers/misc/sgi-xp/xpc_main.c
+++ b/drivers/misc/sgi-xp/xpc_main.c
@@ -1182,7 +1182,7 @@ xpc_system_die(struct notifier_block *nb, unsigned long event, void *_die_args)
 		if (!xpc_kdebug_ignore)
 			break;
 
-		/* fall through */
+		fallthrough;
 	case DIE_MCA_MONARCH_ENTER:
 	case DIE_INIT_MONARCH_ENTER:
 		xpc_arch_ops.offline_heartbeat();
@@ -1193,7 +1193,7 @@ xpc_system_die(struct notifier_block *nb, unsigned long event, void *_die_args)
 		if (!xpc_kdebug_ignore)
 			break;
 
-		/* fall through */
+		fallthrough;
 	case DIE_MCA_MONARCH_LEAVE:
 	case DIE_INIT_MONARCH_LEAVE:
 		xpc_arch_ops.online_heartbeat();
* Unmerged path drivers/misc/sgi-xp/xpc_partition.c
* Unmerged path drivers/misc/sgi-xp/xpc_uv.c
* Unmerged path drivers/mmc/core/host.c
* Unmerged path drivers/mmc/host/atmel-mci.c
diff --git a/drivers/mmc/host/davinci_mmc.c b/drivers/mmc/host/davinci_mmc.c
index 9e68c3645e22..93fffd253153 100644
--- a/drivers/mmc/host/davinci_mmc.c
+++ b/drivers/mmc/host/davinci_mmc.c
@@ -313,7 +313,7 @@ static void mmc_davinci_start_command(struct mmc_davinci_host *host,
 		 * then it's harmless for us to allow it.
 		 */
 		cmd_reg |= MMCCMD_BSYEXP;
-		/* FALLTHROUGH */
+		fallthrough;
 	case MMC_RSP_R1:		/* 48 bits, CRC */
 		cmd_reg |= MMCCMD_RSPFMT_R1456;
 		break;
diff --git a/drivers/mmc/host/dw_mmc-k3.c b/drivers/mmc/host/dw_mmc-k3.c
index 89cdb3d533bb..5eada03f1965 100644
--- a/drivers/mmc/host/dw_mmc-k3.c
+++ b/drivers/mmc/host/dw_mmc-k3.c
@@ -242,7 +242,7 @@ static void dw_mci_hs_set_timing(struct dw_mci *host, int timing,
 		if (smpl_phase >= USE_DLY_MIN_SMPL &&
 				smpl_phase <= USE_DLY_MAX_SMPL)
 			use_smpl_dly = 1;
-			/* fallthrough */
+		fallthrough;
 	case MMC_TIMING_UHS_SDR50:
 		if (smpl_phase >= ENABLE_SHIFT_MIN_SMPL &&
 				smpl_phase <= ENABLE_SHIFT_MAX_SMPL)
diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index 80dc2fd6576c..0a30247e4b4c 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -2056,7 +2056,7 @@ static void dw_mci_tasklet_func(unsigned long priv)
 			}
 
 			prev_state = state = STATE_SENDING_DATA;
-			/* fall through */
+			fallthrough;
 
 		case STATE_SENDING_DATA:
 			/*
@@ -2114,7 +2114,7 @@ static void dw_mci_tasklet_func(unsigned long priv)
 			}
 			prev_state = state = STATE_DATA_BUSY;
 
-			/* fall through */
+			fallthrough;
 
 		case STATE_DATA_BUSY:
 			if (!dw_mci_clear_pending_data_complete(host)) {
@@ -2167,7 +2167,7 @@ static void dw_mci_tasklet_func(unsigned long priv)
 			 */
 			prev_state = state = STATE_SENDING_STOP;
 
-			/* fall through */
+			fallthrough;
 
 		case STATE_SENDING_STOP:
 			if (!dw_mci_clear_pending_cmd_complete(host))
* Unmerged path drivers/mmc/host/jz4740_mmc.c
* Unmerged path drivers/mmc/host/meson-mx-sdio.c
diff --git a/drivers/mmc/host/renesas_sdhi_core.c b/drivers/mmc/host/renesas_sdhi_core.c
index 45c015da2e75..d68b7ad05712 100644
--- a/drivers/mmc/host/renesas_sdhi_core.c
+++ b/drivers/mmc/host/renesas_sdhi_core.c
@@ -421,7 +421,7 @@ static int renesas_sdhi_write16_hook(struct tmio_mmc_host *host, int addr)
 	case HOST_MODE:
 		if (host->pdata->flags & TMIO_MMC_HAVE_CBSY)
 			bit = TMIO_STAT_CMD_BUSY;
-		/* fallthrough */
+		fallthrough;
 	case CTL_SD_CARD_CLK_CTL:
 		return renesas_sdhi_wait_idle(host, bit);
 	}
diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index 4eb3d29ecde1..5fb3cd60587e 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -1223,7 +1223,7 @@ static int sdhci_esdhc_imx_probe_nondt(struct platform_device *pdev,
 				"failed to request card-detect gpio!\n");
 			return err;
 		}
-		/* fall through */
+		fallthrough;
 
 	case ESDHC_CD_CONTROLLER:
 		/* we have a working card_detect back */
* Unmerged path drivers/mmc/host/sdhci-s3c.c
* Unmerged path drivers/mmc/host/sdhci-sprd.c
* Unmerged path drivers/mmc/host/sdhci-xenon-phy.c
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index aa5ef9957341..c183145a92d5 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2286,7 +2286,7 @@ int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 	case MMC_TIMING_UHS_SDR50:
 		if (host->flags & SDHCI_SDR50_NEEDS_TUNING)
 			break;
-		/* FALLTHROUGH */
+		fallthrough;
 
 	default:
 		goto out;
* Unmerged path drivers/mmc/host/tifm_sd.c
* Unmerged path drivers/mmc/host/usdhi6rol0.c
* Unmerged path drivers/mux/adgs1408.c
* Unmerged path drivers/net/appletalk/cops.c
* Unmerged path drivers/net/arcnet/arc-rimi.c
* Unmerged path drivers/net/arcnet/com20020-isa.c
* Unmerged path drivers/net/arcnet/com90io.c
* Unmerged path drivers/net/arcnet/com90xx.c
diff --git a/drivers/net/bonding/bond_3ad.c b/drivers/net/bonding/bond_3ad.c
index cddaa43a9d52..aa001b16765a 100644
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@ -1149,7 +1149,7 @@ static void ad_rx_machine(struct lacpdu *lacpdu, struct port *port)
 			port->actor_oper_port_state &= ~LACP_STATE_EXPIRED;
 			port->sm_rx_state = AD_RX_PORT_DISABLED;
 
-			/* Fall Through */
+			fallthrough;
 		case AD_RX_PORT_DISABLED:
 			port->sm_vars &= ~AD_PORT_MATCHED;
 			break;
@@ -1588,7 +1588,7 @@ static struct aggregator *ad_agg_selection_test(struct aggregator *best,
 		if (__agg_active_ports(curr) < __agg_active_ports(best))
 			return best;
 
-		/*FALLTHROUGH*/
+		fallthrough;
 	case BOND_AD_STABLE:
 	case BOND_AD_BANDWIDTH:
 		if (__get_agg_bandwidth(curr) > __get_agg_bandwidth(best))
diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index de133c33b855..fe93e6107b55 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -2156,7 +2156,7 @@ static int bond_miimon_inspect(struct bonding *bond)
 					     "active " : "backup ") : "",
 					   bond->params.downdelay * bond->params.miimon);
 			}
-			/*FALLTHRU*/
+			fallthrough;
 		case BOND_LINK_FAIL:
 			if (link_state) {
 				/* recovered before downdelay expired */
@@ -2192,7 +2192,7 @@ static int bond_miimon_inspect(struct bonding *bond)
 					   bond->params.updelay *
 					   bond->params.miimon);
 			}
-			/*FALLTHRU*/
+			fallthrough;
 		case BOND_LINK_BACK:
 			if (!link_state) {
 				bond_propose_link_state(slave, BOND_LINK_DOWN);
@@ -3204,7 +3204,7 @@ static int bond_slave_netdev_event(unsigned long event,
 
 		if (BOND_MODE(bond) == BOND_MODE_8023AD)
 			bond_3ad_adapter_speed_duplex_changed(slave);
-		/* Fallthrough */
+		fallthrough;
 	case NETDEV_DOWN:
 		/* Refresh slave-array if applicable!
 		 * If the setup does not use miimon or arpmon (mode-specific!),
@@ -3670,7 +3670,7 @@ static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd
 			return -EINVAL;
 
 		mii->phy_id = 0;
-		/* Fall Through */
+		fallthrough;
 	case SIOCGMIIREG:
 		/* We do this again just in case we were called by SIOCGMIIREG
 		 * instead of SIOCGMIIPHY.
diff --git a/drivers/net/can/at91_can.c b/drivers/net/can/at91_can.c
index 1718c20f9c99..ef356f2b6691 100644
--- a/drivers/net/can/at91_can.c
+++ b/drivers/net/can/at91_can.c
@@ -902,7 +902,7 @@ static void at91_irq_err_state(struct net_device *dev,
 				CAN_ERR_CRTL_TX_WARNING :
 				CAN_ERR_CRTL_RX_WARNING;
 		}
-		/* fall through */
+		fallthrough;
 	case CAN_STATE_ERROR_WARNING:
 		/*
 		 * from: ERROR_ACTIVE, ERROR_WARNING
@@ -952,7 +952,7 @@ static void at91_irq_err_state(struct net_device *dev,
 		netdev_dbg(dev, "Error Active\n");
 		cf->can_id |= CAN_ERR_PROT;
 		cf->data[2] = CAN_ERR_PROT_ACTIVE;
-		/* fall through */
+		fallthrough;
 	case CAN_STATE_ERROR_WARNING:
 		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_BOFF;
 		reg_ier = AT91_IRQ_ERRP;
diff --git a/drivers/net/can/peak_canfd/peak_pciefd_main.c b/drivers/net/can/peak_canfd/peak_pciefd_main.c
index cccf14d4704e..fa406106b237 100644
--- a/drivers/net/can/peak_canfd/peak_pciefd_main.c
+++ b/drivers/net/can/peak_canfd/peak_pciefd_main.c
@@ -668,7 +668,7 @@ static int pciefd_can_probe(struct pciefd_board *pciefd)
 		pciefd_can_writereg(priv, CANFD_CLK_SEL_80MHZ,
 				    PCIEFD_REG_CAN_CLK_SEL);
 
-		/* fall through */
+		fallthrough;
 	case CANFD_CLK_SEL_80MHZ:
 		priv->ucan.can.clock.freq = 80 * 1000 * 1000;
 		break;
diff --git a/drivers/net/can/sja1000/sja1000_platform.c b/drivers/net/can/sja1000/sja1000_platform.c
index dc9c6db96c3c..f48f78debeba 100644
--- a/drivers/net/can/sja1000/sja1000_platform.c
+++ b/drivers/net/can/sja1000/sja1000_platform.c
@@ -161,7 +161,7 @@ static void sp_populate_of(struct sja1000_priv *priv, struct device_node *of)
 		priv->read_reg = sp_read_reg16;
 		priv->write_reg = sp_write_reg16;
 		break;
-	case 1:	/* fallthrough */
+	case 1:
 	default:
 		priv->read_reg = sp_read_reg8;
 		priv->write_reg = sp_write_reg8;
diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c
index b6c05a6b7047..4a86e7decef6 100644
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@ -152,7 +152,7 @@ static void slc_bump(struct slcan *sl)
 	switch (*cmd) {
 	case 'r':
 		cf.can_id = CAN_RTR_FLAG;
-		/* fallthrough */
+		fallthrough;
 	case 't':
 		/* store dlc ASCII value and terminate SFF CAN ID string */
 		cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];
@@ -162,7 +162,7 @@ static void slc_bump(struct slcan *sl)
 		break;
 	case 'R':
 		cf.can_id = CAN_RTR_FLAG;
-		/* fallthrough */
+		fallthrough;
 	case 'T':
 		cf.can_id |= CAN_EFF_FLAG;
 		/* store dlc ASCII value and terminate EFF CAN ID string */
diff --git a/drivers/net/can/spi/mcp251x.c b/drivers/net/can/spi/mcp251x.c
index 17257c73c302..949429ef83bc 100644
--- a/drivers/net/can/spi/mcp251x.c
+++ b/drivers/net/can/spi/mcp251x.c
@@ -875,7 +875,7 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
 			if (new_state >= CAN_STATE_ERROR_WARNING &&
 			    new_state <= CAN_STATE_BUS_OFF)
 				priv->can.can_stats.error_warning++;
-			/* fall through */
+			fallthrough;
 		case CAN_STATE_ERROR_WARNING:
 			if (new_state >= CAN_STATE_ERROR_PASSIVE &&
 			    new_state <= CAN_STATE_BUS_OFF)
diff --git a/drivers/net/can/usb/peak_usb/pcan_usb.c b/drivers/net/can/usb/peak_usb/pcan_usb.c
index eca785532b6b..5ab6a0250198 100644
--- a/drivers/net/can/usb/peak_usb/pcan_usb.c
+++ b/drivers/net/can/usb/peak_usb/pcan_usb.c
@@ -423,7 +423,7 @@ static int pcan_usb_decode_error(struct pcan_usb_msg_context *mc, u8 n,
 			new_state = CAN_STATE_ERROR_WARNING;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 
 	case CAN_STATE_ERROR_WARNING:
 		if (n & PCAN_USB_ERROR_BUS_HEAVY) {
diff --git a/drivers/net/can/usb/peak_usb/pcan_usb_core.c b/drivers/net/can/usb/peak_usb/pcan_usb_core.c
index afc8d978124e..98f452d76841 100644
--- a/drivers/net/can/usb/peak_usb/pcan_usb_core.c
+++ b/drivers/net/can/usb/peak_usb/pcan_usb_core.c
@@ -353,7 +353,7 @@ static netdev_tx_t peak_usb_ndo_start_xmit(struct sk_buff *skb,
 		default:
 			netdev_warn(netdev, "tx urb submitting failed err=%d\n",
 				    err);
-			/* fall through */
+			fallthrough;
 		case -ENOENT:
 			/* cable unplugged */
 			stats->tx_dropped++;
diff --git a/drivers/net/can/usb/peak_usb/pcan_usb_pro.c b/drivers/net/can/usb/peak_usb/pcan_usb_pro.c
index 6387d0f46b32..f62d22d1a0ea 100644
--- a/drivers/net/can/usb/peak_usb/pcan_usb_pro.c
+++ b/drivers/net/can/usb/peak_usb/pcan_usb_pro.c
@@ -141,10 +141,10 @@ static int pcan_msg_add_rec(struct pcan_usb_pro_msg *pm, int id, ...)
 	switch (id) {
 	case PCAN_USBPRO_TXMSG8:
 		i += 4;
-		/* fall through */
+		fallthrough;
 	case PCAN_USBPRO_TXMSG4:
 		i += 4;
-		/* fall through */
+		fallthrough;
 	case PCAN_USBPRO_TXMSG0:
 		*pc++ = va_arg(ap, int);
 		*pc++ = va_arg(ap, int);
diff --git a/drivers/net/dsa/b53/b53_common.c b/drivers/net/dsa/b53/b53_common.c
index d93c790bfbe8..22a4ab6c5dd4 100644
--- a/drivers/net/dsa/b53/b53_common.c
+++ b/drivers/net/dsa/b53/b53_common.c
@@ -967,7 +967,7 @@ static void b53_adjust_link(struct dsa_switch *ds, int port,
 	switch (phydev->speed) {
 	case 2000:
 		reg |= PORT_OVERRIDE_SPEED_2000M;
-		/* fallthrough */
+		fallthrough;
 	case SPEED_1000:
 		reg |= PORT_OVERRIDE_SPEED_1000M;
 		break;
* Unmerged path drivers/net/dsa/b53/b53_serdes.c
diff --git a/drivers/net/dsa/bcm_sf2.c b/drivers/net/dsa/bcm_sf2.c
index 9c7cbf9b574e..5d1964b761a1 100644
--- a/drivers/net/dsa/bcm_sf2.c
+++ b/drivers/net/dsa/bcm_sf2.c
@@ -536,7 +536,7 @@ static void bcm_sf2_sw_mac_config(struct dsa_switch *ds, int port,
 	switch (state->interface) {
 	case PHY_INTERFACE_MODE_RGMII:
 		id_mode_dis = 1;
-		/* fallthrough */
+		fallthrough;
 	case PHY_INTERFACE_MODE_RGMII_TXID:
 		port_mode = EXT_GPHY;
 		break;
* Unmerged path drivers/net/dsa/microchip/ksz9477.c
* Unmerged path drivers/net/dsa/mt7530.c
diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
index bb28c701381a..fab487fcda22 100644
--- a/drivers/net/dsa/mv88e6xxx/chip.c
+++ b/drivers/net/dsa/mv88e6xxx/chip.c
@@ -765,7 +765,7 @@ static uint64_t _mv88e6xxx_get_ethtool_stat(struct mv88e6xxx_chip *chip,
 		break;
 	case STATS_TYPE_BANK1:
 		reg = bank1_select;
-		/* fall through */
+		fallthrough;
 	case STATS_TYPE_BANK0:
 		reg |= s->reg | histogram;
 		mv88e6xxx_g1_stats_read(chip, reg, &low);
* Unmerged path drivers/net/ethernet/3com/3c509.c
diff --git a/drivers/net/ethernet/3com/3c574_cs.c b/drivers/net/ethernet/3com/3c574_cs.c
index ef1c3151fbb2..7237889bc713 100644
--- a/drivers/net/ethernet/3com/3c574_cs.c
+++ b/drivers/net/ethernet/3com/3c574_cs.c
@@ -1046,7 +1046,7 @@ static int el3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	switch(cmd) {
 	case SIOCGMIIPHY:		/* Get the address of the PHY in use. */
 		data->phy_id = phy;
-		/* fall through */
+		fallthrough;
 	case SIOCGMIIREG:		/* Read the specified MII register. */
 		{
 			int saved_window;
* Unmerged path drivers/net/ethernet/8390/axnet_cs.c
diff --git a/drivers/net/ethernet/8390/pcnet_cs.c b/drivers/net/ethernet/8390/pcnet_cs.c
index 61e43802b9a5..164943bb9804 100644
--- a/drivers/net/ethernet/8390/pcnet_cs.c
+++ b/drivers/net/ethernet/8390/pcnet_cs.c
@@ -1103,7 +1103,7 @@ static int ei_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
     switch (cmd) {
     case SIOCGMIIPHY:
 	data->phy_id = info->phy_id;
-	/* fall through */
+	fallthrough;
     case SIOCGMIIREG:		/* Read MII PHY register. */
 	data->val_out = mdio_read(mii_addr, data->phy_id, data->reg_num & 0x1f);
 	return 0;
diff --git a/drivers/net/ethernet/alacritech/slicoss.c b/drivers/net/ethernet/alacritech/slicoss.c
index bae468be5d7d..1f753c029dde 100644
--- a/drivers/net/ethernet/alacritech/slicoss.c
+++ b/drivers/net/ethernet/alacritech/slicoss.c
@@ -1723,13 +1723,13 @@ static bool slic_is_fiber(unsigned short subdev)
 {
 	switch (subdev) {
 	/* Mojave */
-	case PCI_SUBDEVICE_ID_ALACRITECH_1000X1F: /* fallthrough */
-	case PCI_SUBDEVICE_ID_ALACRITECH_SES1001F: /* fallthrough */
+	case PCI_SUBDEVICE_ID_ALACRITECH_1000X1F:
+	case PCI_SUBDEVICE_ID_ALACRITECH_SES1001F: fallthrough;
 	/* Oasis */
-	case PCI_SUBDEVICE_ID_ALACRITECH_SEN2002XF: /* fallthrough */
-	case PCI_SUBDEVICE_ID_ALACRITECH_SEN2001XF: /* fallthrough */
-	case PCI_SUBDEVICE_ID_ALACRITECH_SEN2104EF: /* fallthrough */
-	case PCI_SUBDEVICE_ID_ALACRITECH_SEN2102EF: /* fallthrough */
+	case PCI_SUBDEVICE_ID_ALACRITECH_SEN2002XF:
+	case PCI_SUBDEVICE_ID_ALACRITECH_SEN2001XF:
+	case PCI_SUBDEVICE_ID_ALACRITECH_SEN2104EF:
+	case PCI_SUBDEVICE_ID_ALACRITECH_SEN2102EF:
 		return true;
 	}
 	return false;
* Unmerged path drivers/net/ethernet/alteon/acenic.c
diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 28a8629efeed..8deb6a79c4e5 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1483,7 +1483,7 @@ static int amd8111e_ioctl(struct net_device *dev , struct ifreq *ifr, int cmd)
 	case SIOCGMIIPHY:
 		data->phy_id = lp->ext_phy_addr;
 
-	/* fallthru */
+		fallthrough;
 	case SIOCGMIIREG:
 
 		spin_lock_irq(&lp->lock);
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
diff --git a/drivers/net/ethernet/broadcom/bgmac-bcma.c b/drivers/net/ethernet/broadcom/bgmac-bcma.c
index 6fe074c1588b..939711d1c1e0 100644
--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
+++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
@@ -217,7 +217,7 @@ static int bgmac_probe(struct bcma_device *core)
 	/* BCM 471X/535X family */
 	case BCMA_CHIP_ID_BCM4716:
 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
-		/* fallthrough */
+		fallthrough;
 	case BCMA_CHIP_ID_BCM47162:
 		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL2;
 		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
diff --git a/drivers/net/ethernet/broadcom/bgmac-platform.c b/drivers/net/ethernet/broadcom/bgmac-platform.c
index 894eda5b13cf..cedbbba0c020 100644
--- a/drivers/net/ethernet/broadcom/bgmac-platform.c
+++ b/drivers/net/ethernet/broadcom/bgmac-platform.c
@@ -131,7 +131,7 @@ static void bgmac_nicpm_speed_set(struct net_device *net_dev)
 	switch (bgmac->net_dev->phydev->speed) {
 	default:
 		netdev_err(net_dev, "Unsupported speed. Defaulting to 1000Mb\n");
-		/* fall through */
+		fallthrough;
 	case SPEED_1000:
 		val |= NICPM_IOMUX_CTRL_SPD_1000M << NICPM_IOMUX_CTRL_SPD_SHIFT;
 		break;
diff --git a/drivers/net/ethernet/broadcom/bnx2.c b/drivers/net/ethernet/broadcom/bnx2.c
index 05b92ed39b86..c9a196bec3f9 100644
--- a/drivers/net/ethernet/broadcom/bnx2.c
+++ b/drivers/net/ethernet/broadcom/bnx2.c
@@ -1343,13 +1343,13 @@ bnx2_set_mac_link(struct bnx2 *bp)
 					val |= BNX2_EMAC_MODE_PORT_MII_10M;
 					break;
 				}
-				/* fall through */
+				fallthrough;
 			case SPEED_100:
 				val |= BNX2_EMAC_MODE_PORT_MII;
 				break;
 			case SPEED_2500:
 				val |= BNX2_EMAC_MODE_25G_MODE;
-				/* fall through */
+				fallthrough;
 			case SPEED_1000:
 				val |= BNX2_EMAC_MODE_PORT_GMII;
 				break;
@@ -2001,26 +2001,26 @@ bnx2_remote_phy_event(struct bnx2 *bp)
 		switch (speed) {
 			case BNX2_LINK_STATUS_10HALF:
 				bp->duplex = DUPLEX_HALF;
-				/* fall through */
+				fallthrough;
 			case BNX2_LINK_STATUS_10FULL:
 				bp->line_speed = SPEED_10;
 				break;
 			case BNX2_LINK_STATUS_100HALF:
 				bp->duplex = DUPLEX_HALF;
-				/* fall through */
+				fallthrough;
 			case BNX2_LINK_STATUS_100BASE_T4:
 			case BNX2_LINK_STATUS_100FULL:
 				bp->line_speed = SPEED_100;
 				break;
 			case BNX2_LINK_STATUS_1000HALF:
 				bp->duplex = DUPLEX_HALF;
-				/* fall through */
+				fallthrough;
 			case BNX2_LINK_STATUS_1000FULL:
 				bp->line_speed = SPEED_1000;
 				break;
 			case BNX2_LINK_STATUS_2500HALF:
 				bp->duplex = DUPLEX_HALF;
-				/* fall through */
+				fallthrough;
 			case BNX2_LINK_STATUS_2500FULL:
 				bp->line_speed = SPEED_2500;
 				break;
@@ -7858,7 +7858,7 @@ bnx2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCGMIIPHY:
 		data->phy_id = bp->phy_addr;
 
-		/* fallthru */
+		fallthrough;
 	case SIOCGMIIREG: {
 		u32 mii_regval;
 
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
index 87e01dd6115c..89b86ea1b113 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -8605,11 +8605,11 @@ int bnx2x_set_int_mode(struct bnx2x *bp)
 			       bp->num_queues,
 			       1 + bp->num_cnic_queues);
 
-		/* fall through */
+		fallthrough;
 	case BNX2X_INT_MODE_MSI:
 		bnx2x_enable_msi(bp);
 
-		/* fall through */
+		fallthrough;
 	case BNX2X_INT_MODE_INTX:
 		bp->num_ethernet_queues = 1;
 		bp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
index 80d250a6d048..e26f4da5a6d7 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
@@ -3258,7 +3258,7 @@ static int bnx2x_mcast_validate_e2(struct bnx2x *bp,
 	/* DEL command deletes all currently configured MACs */
 	case BNX2X_MCAST_CMD_DEL:
 		o->set_registry_size(o, 0);
-		/* fall through */
+		fallthrough;
 
 	/* RESTORE command will restore the entire multicast configuration */
 	case BNX2X_MCAST_CMD_RESTORE:
@@ -3592,7 +3592,7 @@ static int bnx2x_mcast_validate_e1(struct bnx2x *bp,
 	/* DEL command deletes all currently configured MACs */
 	case BNX2X_MCAST_CMD_DEL:
 		o->set_registry_size(o, 0);
-		/* fall through */
+		fallthrough;
 
 	/* RESTORE command will restore the entire multicast configuration */
 	case BNX2X_MCAST_CMD_RESTORE:
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
index b4476f44e386..9c2f51f23035 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
@@ -1809,7 +1809,7 @@ int bnx2x_iov_eq_sp_event(struct bnx2x *bp, union event_ring_elem *elem)
 		DP(BNX2X_MSG_IOV, "got VF [%d:%d] RSS update ramrod\n",
 		   vf->abs_vfid, qidx);
 		bnx2x_vf_handle_rss_update_eqe(bp, vf);
-		/* fall through */
+		fallthrough;
 	case EVENT_RING_OPCODE_VF_FLR:
 		/* Do nothing for now */
 		return 0;
@@ -2207,7 +2207,7 @@ int bnx2x_vf_free(struct bnx2x *bp, struct bnx2x_virtf *vf)
 		rc = bnx2x_vf_close(bp, vf);
 		if (rc)
 			goto op_err;
-		/* Fall through - to release resources */
+		fallthrough;	/* to release resources */
 	case VF_ACQUIRED:
 		DP(BNX2X_MSG_IOV, "about to free resources\n");
 		bnx2x_vf_free_resc(bp, vf);
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 63ea110030bb..59224e175c5e 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -1932,7 +1932,7 @@ u32 bnxt_fw_health_readl(struct bnxt *bp, int reg_idx)
 		break;
 	case BNXT_FW_HEALTH_REG_TYPE_GRC:
 		reg_off = fw_health->mapped_regs[reg_idx];
-		/* fall through */
+		fallthrough;
 	case BNXT_FW_HEALTH_REG_TYPE_BAR0:
 		val = readl(bp->bar0 + reg_off);
 		break;
@@ -1975,11 +1975,11 @@ static int bnxt_async_event_process(struct bnxt *bp,
 		}
 		set_bit(BNXT_LINK_SPEED_CHNG_SP_EVENT, &bp->sp_event);
 	}
-	/* fall through */
+		fallthrough;
 	case ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CHANGE:
 	case ASYNC_EVENT_CMPL_EVENT_ID_PORT_PHY_CFG_CHANGE:
 		set_bit(BNXT_LINK_CFG_CHANGE_SP_EVENT, &bp->sp_event);
-		/* fall through */
+		fallthrough;
 	case ASYNC_EVENT_CMPL_EVENT_ID_LINK_STATUS_CHANGE:
 		set_bit(BNXT_LINK_CHNG_SP_EVENT, &bp->sp_event);
 		break;
@@ -9803,7 +9803,7 @@ static int bnxt_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCGMIIPHY:
 		mdio->phy_id = bp->link_info.phy_addr;
 
-		/* fallthru */
+		fallthrough;
 	case SIOCGMIIREG: {
 		u16 mii_regval = 0;
 
@@ -11060,7 +11060,7 @@ static void bnxt_fw_reset_writel(struct bnxt *bp, int reg_idx)
 		writel(reg_off & BNXT_GRC_BASE_MASK,
 		       bp->bar0 + BNXT_GRCPF_REG_WINDOW_BASE_OUT + 4);
 		reg_off = (reg_off & BNXT_GRC_OFFSET_MASK) + 0x2000;
-		/* fall through */
+		fallthrough;
 	case BNXT_FW_HEALTH_REG_TYPE_BAR0:
 		writel(val, bp->bar0 + reg_off);
 		break;
@@ -11173,7 +11173,7 @@ static void bnxt_fw_reset_task(struct work_struct *work)
 		}
 		bp->fw_reset_state = BNXT_FW_RESET_STATE_RESET_FW;
 	}
-	/* fall through */
+		fallthrough;
 	case BNXT_FW_RESET_STATE_RESET_FW:
 		bnxt_reset_all(bp);
 		bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
@@ -11196,7 +11196,7 @@ static void bnxt_fw_reset_task(struct work_struct *work)
 		}
 		pci_set_master(bp->pdev);
 		bp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW;
-		/* fall through */
+		fallthrough;
 	case BNXT_FW_RESET_STATE_POLL_FW:
 		bp->hwrm_cmd_timeout = SHORT_HWRM_CMD_TIMEOUT;
 		rc = __bnxt_hwrm_ver_get(bp, true);
@@ -11211,7 +11211,7 @@ static void bnxt_fw_reset_task(struct work_struct *work)
 		}
 		bp->hwrm_cmd_timeout = DFLT_HWRM_CMD_TIMEOUT;
 		bp->fw_reset_state = BNXT_FW_RESET_STATE_OPENING;
-		/* fall through */
+		fallthrough;
 	case BNXT_FW_RESET_STATE_OPENING:
 		while (!rtnl_trylock()) {
 			bnxt_queue_fw_reset_work(bp, HZ / 10);
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index aed7fbb61f99..99e86f9eebb5 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -1066,7 +1066,7 @@ static int bnxt_grxfh(struct bnxt *bp, struct ethtool_rxnfc *cmd)
 		if (bp->rss_hash_cfg & VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV4)
 			cmd->data |= RXH_IP_SRC | RXH_IP_DST |
 				     RXH_L4_B_0_1 | RXH_L4_B_2_3;
-		/* fall through */
+		fallthrough;
 	case SCTP_V4_FLOW:
 	case AH_ESP_V4_FLOW:
 	case AH_V4_FLOW:
@@ -1085,7 +1085,7 @@ static int bnxt_grxfh(struct bnxt *bp, struct ethtool_rxnfc *cmd)
 		if (bp->rss_hash_cfg & VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV6)
 			cmd->data |= RXH_IP_SRC | RXH_IP_DST |
 				     RXH_L4_B_0_1 | RXH_L4_B_2_3;
-		/* fall through */
+		fallthrough;
 	case SCTP_V6_FLOW:
 	case AH_ESP_V6_FLOW:
 	case AH_V6_FLOW:
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
index 5e3b4a3b69ea..43326dd4561a 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
@@ -201,10 +201,10 @@ bool bnxt_rx_xdp(struct bnxt *bp, struct bnxt_rx_ring_info *rxr, u16 cons,
 		break;
 	default:
 		bpf_warn_invalid_xdp_action(act);
-		/* Fall thru */
+		fallthrough;
 	case XDP_ABORTED:
 		trace_xdp_exception(bp->dev, xdp_prog, act);
-		/* Fall thru */
+		fallthrough;
 	case XDP_DROP:
 		bnxt_reuse_rx_data(rxr, cons, page);
 		break;
diff --git a/drivers/net/ethernet/broadcom/cnic.c b/drivers/net/ethernet/broadcom/cnic.c
index 9915bb5f8f6b..11fb9eeed848 100644
--- a/drivers/net/ethernet/broadcom/cnic.c
+++ b/drivers/net/ethernet/broadcom/cnic.c
@@ -3312,7 +3312,7 @@ static int cnic_ctl(void *data, struct cnic_ctl_info *info)
 	}
 	case CNIC_CTL_FCOE_STATS_GET_CMD:
 		ulp_type = CNIC_ULP_FCOE;
-		/* fall through */
+		fallthrough;
 	case CNIC_CTL_ISCSI_STATS_GET_CMD:
 		cnic_hold(dev);
 		cnic_copy_ulp_stats(dev, ulp_type);
@@ -4045,7 +4045,7 @@ static void cnic_cm_process_kcqe(struct cnic_dev *dev, struct kcqe *kcqe)
 			    l4kcqe->status, l5kcqe->completion_status);
 		opcode = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;
 	}
-		/* Fall through */
+		fallthrough;
 	case L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:
 	case L4_KCQE_OPCODE_VALUE_CLOSE_COMP:
 	case L4_KCQE_OPCODE_VALUE_RESET_COMP:
diff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.c b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
index 9e5b0d45e310..f0e9c8482a69 100644
--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c
+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
@@ -959,10 +959,10 @@ static void bcmgenet_update_mib_counters(struct bcmgenet_priv *priv)
 			continue;
 		case BCMGENET_STAT_RUNT:
 			offset += BCMGENET_STAT_OFFSET;
-			/* fall through */
+			fallthrough;
 		case BCMGENET_STAT_MIB_TX:
 			offset += BCMGENET_STAT_OFFSET;
-			/* fall through */
+			fallthrough;
 		case BCMGENET_STAT_MIB_RX:
 			val = bcmgenet_umac_readl(priv,
 						  UMAC_MIB_START + j + offset);
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmmii.c
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index d829bb8cd3b2..7f1a27c3c132 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -720,7 +720,7 @@ static int tg3_ape_lock(struct tg3 *tp, int locknum)
 	case TG3_APE_LOCK_GPIO:
 		if (tg3_asic_rev(tp) == ASIC_REV_5761)
 			return 0;
-		/* fall through */
+		fallthrough;
 	case TG3_APE_LOCK_GRC:
 	case TG3_APE_LOCK_MEM:
 		if (!tp->pci_fn)
@@ -781,7 +781,7 @@ static void tg3_ape_unlock(struct tg3 *tp, int locknum)
 	case TG3_APE_LOCK_GPIO:
 		if (tg3_asic_rev(tp) == ASIC_REV_5761)
 			return;
-		/* fall through */
+		fallthrough;
 	case TG3_APE_LOCK_GRC:
 	case TG3_APE_LOCK_MEM:
 		if (!tp->pci_fn)
@@ -1591,7 +1591,7 @@ static int tg3_mdio_init(struct tg3 *tp)
 			phydev->dev_flags |= PHY_BRCM_EXT_IBND_RX_ENABLE;
 		if (tg3_flag(tp, RGMII_EXT_IBND_TX_EN))
 			phydev->dev_flags |= PHY_BRCM_EXT_IBND_TX_ENABLE;
-		/* fall through */
+		fallthrough;
 	case PHY_ID_RTL8211C:
 		phydev->interface = PHY_INTERFACE_MODE_RGMII;
 		break;
@@ -2119,7 +2119,7 @@ static int tg3_phy_init(struct tg3 *tp)
 			phy_support_asym_pause(phydev);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case PHY_INTERFACE_MODE_MII:
 		phy_set_max_speed(phydev, SPEED_100);
 		phy_support_asym_pause(phydev);
@@ -4395,7 +4395,7 @@ static int tg3_phy_autoneg_cfg(struct tg3 *tp, u32 advertise, u32 flowctrl)
 				      MII_TG3_DSP_TAP26_RMRXSTO |
 				      MII_TG3_DSP_TAP26_OPCSINPT;
 			tg3_phydsp_write(tp, MII_TG3_DSP_TAP26, val);
-			/* Fall through */
+			fallthrough;
 		case ASIC_REV_5720:
 		case ASIC_REV_5762:
 			if (!tg3_phydsp_read(tp, MII_TG3_DSP_CH34TP2, &val))
@@ -4543,7 +4543,7 @@ static int tg3_phy_pull_config(struct tg3 *tp)
 				tp->link_config.speed = SPEED_1000;
 				break;
 			}
-			/* Fall through */
+			fallthrough;
 		default:
 			goto done;
 		}
@@ -5214,7 +5214,7 @@ static int tg3_fiber_aneg_smachine(struct tg3 *tp,
 		if (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))
 			ap->state = ANEG_STATE_AN_ENABLE;
 
-		/* fall through */
+		fallthrough;
 	case ANEG_STATE_AN_ENABLE:
 		ap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);
 		if (ap->flags & MR_AN_ENABLE) {
@@ -5244,7 +5244,7 @@ static int tg3_fiber_aneg_smachine(struct tg3 *tp,
 		ret = ANEG_TIMER_ENAB;
 		ap->state = ANEG_STATE_RESTART;
 
-		/* fall through */
+		fallthrough;
 	case ANEG_STATE_RESTART:
 		delta = ap->cur_time - ap->link_time;
 		if (delta > ANEG_STATE_SETTLE_TIME)
@@ -5287,7 +5287,7 @@ static int tg3_fiber_aneg_smachine(struct tg3 *tp,
 
 		ap->state = ANEG_STATE_ACK_DETECT;
 
-		/* fall through */
+		fallthrough;
 	case ANEG_STATE_ACK_DETECT:
 		if (ap->ack_match != 0) {
 			if ((ap->rxconfig & ~ANEG_CFG_ACK) ==
@@ -10725,40 +10725,40 @@ static int tg3_reset_hw(struct tg3 *tp, bool reset_phy)
 	switch (limit) {
 	case 16:
 		tw32(MAC_RCV_RULE_15,  0); tw32(MAC_RCV_VALUE_15,  0);
-		/* fall through */
+		fallthrough;
 	case 15:
 		tw32(MAC_RCV_RULE_14,  0); tw32(MAC_RCV_VALUE_14,  0);
-		/* fall through */
+		fallthrough;
 	case 14:
 		tw32(MAC_RCV_RULE_13,  0); tw32(MAC_RCV_VALUE_13,  0);
-		/* fall through */
+		fallthrough;
 	case 13:
 		tw32(MAC_RCV_RULE_12,  0); tw32(MAC_RCV_VALUE_12,  0);
-		/* fall through */
+		fallthrough;
 	case 12:
 		tw32(MAC_RCV_RULE_11,  0); tw32(MAC_RCV_VALUE_11,  0);
-		/* fall through */
+		fallthrough;
 	case 11:
 		tw32(MAC_RCV_RULE_10,  0); tw32(MAC_RCV_VALUE_10,  0);
-		/* fall through */
+		fallthrough;
 	case 10:
 		tw32(MAC_RCV_RULE_9,  0); tw32(MAC_RCV_VALUE_9,  0);
-		/* fall through */
+		fallthrough;
 	case 9:
 		tw32(MAC_RCV_RULE_8,  0); tw32(MAC_RCV_VALUE_8,  0);
-		/* fall through */
+		fallthrough;
 	case 8:
 		tw32(MAC_RCV_RULE_7,  0); tw32(MAC_RCV_VALUE_7,  0);
-		/* fall through */
+		fallthrough;
 	case 7:
 		tw32(MAC_RCV_RULE_6,  0); tw32(MAC_RCV_VALUE_6,  0);
-		/* fall through */
+		fallthrough;
 	case 6:
 		tw32(MAC_RCV_RULE_5,  0); tw32(MAC_RCV_VALUE_5,  0);
-		/* fall through */
+		fallthrough;
 	case 5:
 		tw32(MAC_RCV_RULE_4,  0); tw32(MAC_RCV_VALUE_4,  0);
-		/* fall through */
+		fallthrough;
 	case 4:
 		/* tw32(MAC_RCV_RULE_3,  0); tw32(MAC_RCV_VALUE_3,  0); */
 	case 3:
@@ -14013,7 +14013,7 @@ static int tg3_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCGMIIPHY:
 		data->phy_id = tp->phy_addr;
 
-		/* fall through */
+		fallthrough;
 	case SIOCGMIIREG: {
 		u32 mii_regval;
 
@@ -17151,7 +17151,7 @@ static u32 tg3_calc_dma_bndry(struct tg3 *tp, u32 val)
 				val |= DMA_RWCTRL_WRITE_BNDRY_64_PCIE;
 				break;
 			}
-			/* fallthrough */
+			fallthrough;
 		case 128:
 		default:
 			val &= ~DMA_RWCTRL_WRITE_BNDRY_DISAB_PCIE;
@@ -17166,28 +17166,28 @@ static u32 tg3_calc_dma_bndry(struct tg3 *tp, u32 val)
 					DMA_RWCTRL_WRITE_BNDRY_16);
 				break;
 			}
-			/* fallthrough */
+			fallthrough;
 		case 32:
 			if (goal == BOUNDARY_SINGLE_CACHELINE) {
 				val |= (DMA_RWCTRL_READ_BNDRY_32 |
 					DMA_RWCTRL_WRITE_BNDRY_32);
 				break;
 			}
-			/* fallthrough */
+			fallthrough;
 		case 64:
 			if (goal == BOUNDARY_SINGLE_CACHELINE) {
 				val |= (DMA_RWCTRL_READ_BNDRY_64 |
 					DMA_RWCTRL_WRITE_BNDRY_64);
 				break;
 			}
-			/* fallthrough */
+			fallthrough;
 		case 128:
 			if (goal == BOUNDARY_SINGLE_CACHELINE) {
 				val |= (DMA_RWCTRL_READ_BNDRY_128 |
 					DMA_RWCTRL_WRITE_BNDRY_128);
 				break;
 			}
-			/* fallthrough */
+			fallthrough;
 		case 256:
 			val |= (DMA_RWCTRL_READ_BNDRY_256 |
 				DMA_RWCTRL_WRITE_BNDRY_256);
* Unmerged path drivers/net/ethernet/brocade/bna/bfa_ioc.c
diff --git a/drivers/net/ethernet/brocade/bna/bna_enet.c b/drivers/net/ethernet/brocade/bna/bna_enet.c
index bba81735ce87..ef926bb9d6e4 100644
--- a/drivers/net/ethernet/brocade/bna/bna_enet.c
+++ b/drivers/net/ethernet/brocade/bna/bna_enet.c
@@ -1092,7 +1092,7 @@ bna_enet_sm_cfg_wait(struct bna_enet *enet,
 
 	case ENET_E_CHLD_STOPPED:
 		bna_enet_rx_start(enet);
-		/* Fall through */
+		fallthrough;
 	case ENET_E_FWRESP_PAUSE:
 		if (enet->flags & BNA_ENET_F_PAUSE_CHANGED) {
 			enet->flags &= ~BNA_ENET_F_PAUSE_CHANGED;
diff --git a/drivers/net/ethernet/brocade/bna/bna_tx_rx.c b/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
index 95bc470ae441..bf112790ce44 100644
--- a/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
+++ b/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
@@ -1644,7 +1644,7 @@ bna_bfi_rx_enet_start(struct bna_rx *rx)
 						&q1->qpt);
 			cfg_req->q_cfg[i].qs.rx_buffer_size =
 				htons((u16)q1->buffer_size);
-			/* Fall through */
+			fallthrough;
 
 		case BNA_RXP_SINGLE:
 			/* Large/Single RxQ */
* Unmerged path drivers/net/ethernet/cadence/macb_ptp.c
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_main.c
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
* Unmerged path drivers/net/ethernet/cavium/thunder/nicvf_ethtool.c
diff --git a/drivers/net/ethernet/cavium/thunder/nicvf_main.c b/drivers/net/ethernet/cavium/thunder/nicvf_main.c
index b7a19ffb3c1f..d0312c2f8d9b 100644
--- a/drivers/net/ethernet/cavium/thunder/nicvf_main.c
+++ b/drivers/net/ethernet/cavium/thunder/nicvf_main.c
@@ -591,10 +591,10 @@ static inline bool nicvf_xdp_rx(struct nicvf *nic, struct bpf_prog *prog,
 		return true;
 	default:
 		bpf_warn_invalid_xdp_action(action);
-		/* fall through */
+		fallthrough;
 	case XDP_ABORTED:
 		trace_xdp_exception(nic->netdev, prog, action);
-		/* fall through */
+		fallthrough;
 	case XDP_DROP:
 		/* Check if it's a recycled page, if not
 		 * unmap the DMA mapping.
diff --git a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
index a19172dbe6be..70ee475d4034 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
@@ -2526,7 +2526,7 @@ static int cxgb_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
 		    !(data->phy_id & 0xe0e0))
 			data->phy_id = mdio_phy_id_c45(data->phy_id >> 8,
 						       data->phy_id & 0x1f);
-		/* FALLTHRU */
+		fallthrough;
 	case SIOCGMIIPHY:
 		return mdio_mii_ioctl(&pi->phy.mdio, data, cmd);
 	case SIOCCHIOCTL:
* Unmerged path drivers/net/ethernet/chelsio/cxgb3/l2t.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/l2t.c b/drivers/net/ethernet/chelsio/cxgb4/l2t.c
index b66e0332dbb3..7a94e573c71d 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/l2t.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/l2t.c
@@ -231,7 +231,7 @@ int cxgb4_l2t_send(struct net_device *dev, struct sk_buff *skb,
 		if (e->state == L2T_STATE_STALE)
 			e->state = L2T_STATE_VALID;
 		spin_unlock_bh(&e->lock);
-		/* fall through */
+		fallthrough;
 	case L2T_STATE_VALID:     /* fast-path, send the packet on */
 		return t4_ofld_send(adap, skb);
 	case L2T_STATE_RESOLVING:
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 974eb76d29a1..e2c4252efee3 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -7661,13 +7661,13 @@ int t4_alloc_vi(struct adapter *adap, unsigned int mbox, unsigned int port,
 		switch (nmac) {
 		case 5:
 			memcpy(mac + 24, c.nmac3, sizeof(c.nmac3));
-			/* Fall through */
+			fallthrough;
 		case 4:
 			memcpy(mac + 18, c.nmac2, sizeof(c.nmac2));
-			/* Fall through */
+			fallthrough;
 		case 3:
 			memcpy(mac + 12, c.nmac1, sizeof(c.nmac1));
-			/* Fall through */
+			fallthrough;
 		case 2:
 			memcpy(mac + 6,  c.nmac0, sizeof(c.nmac0));
 		}
diff --git a/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c b/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
index f4d41f968afa..d815bbbe61fb 100644
--- a/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
@@ -519,7 +519,7 @@ static int fwevtq_handler(struct sge_rspq *rspq, const __be64 *rsp,
 		}
 		cpl = (void *)p;
 	}
-		/* Fall through */
+		fallthrough;
 
 	case CPL_SGE_EGR_UPDATE: {
 		/*
diff --git a/drivers/net/ethernet/cisco/enic/enic_main.c b/drivers/net/ethernet/cisco/enic/enic_main.c
index ddf60dc9ad16..f81a990c1e2c 100644
--- a/drivers/net/ethernet/cisco/enic/enic_main.c
+++ b/drivers/net/ethernet/cisco/enic/enic_main.c
@@ -307,7 +307,7 @@ static netdev_features_t enic_features_check(struct sk_buff *skb,
 	case ntohs(ETH_P_IPV6):
 		if (!(enic->vxlan.flags & ENIC_VXLAN_INNER_IPV6))
 			goto out;
-		/* Fall through */
+		fallthrough;
 	case ntohs(ETH_P_IP):
 		break;
 	default:
* Unmerged path drivers/net/ethernet/davicom/dm9000.c
* Unmerged path drivers/net/ethernet/dec/tulip/de4x5.c
* Unmerged path drivers/net/ethernet/dec/tulip/tulip_core.c
diff --git a/drivers/net/ethernet/dec/tulip/winbond-840.c b/drivers/net/ethernet/dec/tulip/winbond-840.c
index 7f136488e67c..8256436fdb7d 100644
--- a/drivers/net/ethernet/dec/tulip/winbond-840.c
+++ b/drivers/net/ethernet/dec/tulip/winbond-840.c
@@ -1454,7 +1454,7 @@ static int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	switch(cmd) {
 	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
 		data->phy_id = ((struct netdev_private *)netdev_priv(dev))->phys[0] & 0x1f;
-		/* Fall Through */
+		fallthrough;
 
 	case SIOCGMIIREG:		/* Read MII PHY register. */
 		spin_lock_irq(&np->lock);
diff --git a/drivers/net/ethernet/emulex/benet/be_ethtool.c b/drivers/net/ethernet/emulex/benet/be_ethtool.c
index 9805e5188bd3..f0c00e342280 100644
--- a/drivers/net/ethernet/emulex/benet/be_ethtool.c
+++ b/drivers/net/ethernet/emulex/benet/be_ethtool.c
@@ -572,7 +572,7 @@ static u32 convert_to_et_setting(struct be_adapter *adapter, u32 if_speeds)
 				break;
 			}
 		}
-		/* fall through */
+		fallthrough;
 	case PHY_TYPE_SFP_PLUS_10GB:
 	case PHY_TYPE_XFP_10GB:
 	case PHY_TYPE_SFP_1GB:
diff --git a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
index 15fe3d780457..f9d9ac1f6853 100644
--- a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
@@ -929,7 +929,7 @@ static void dpaa_fq_setup(struct dpaa_priv *priv,
 			break;
 		case FQ_TYPE_TX_CONF_MQ:
 			priv->conf_fqs[conf_cnt++] = &fq->fq_base;
-			/* fall through */
+			fallthrough;
 		case FQ_TYPE_TX_CONFIRM:
 			dpaa_setup_ingress(priv, fq, &fq_cbs->tx_defq);
 			break;
diff --git a/drivers/net/ethernet/freescale/dpaa/dpaa_ethtool.c b/drivers/net/ethernet/freescale/dpaa/dpaa_ethtool.c
index cc8fe9532885..e50d41c42eb6 100644
--- a/drivers/net/ethernet/freescale/dpaa/dpaa_ethtool.c
+++ b/drivers/net/ethernet/freescale/dpaa/dpaa_ethtool.c
@@ -389,7 +389,7 @@ static int dpaa_get_hash_opts(struct net_device *dev,
 	case UDP_V6_FLOW:
 		if (priv->keygen_in_use)
 			cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
-		/* Fall through */
+		fallthrough;
 	case IPV4_FLOW:
 	case IPV6_FLOW:
 	case SCTP_V4_FLOW:
diff --git a/drivers/net/ethernet/freescale/fman/fman_memac.c b/drivers/net/ethernet/freescale/fman/fman_memac.c
index 446a97b792e3..32675b1244bc 100644
--- a/drivers/net/ethernet/freescale/fman/fman_memac.c
+++ b/drivers/net/ethernet/freescale/fman/fman_memac.c
@@ -528,7 +528,7 @@ static void setup_sgmii_internal_phy(struct fman_mac *memac,
 		case 100:
 			tmp_reg16 |= IF_MODE_SGMII_SPEED_100M;
 		break;
-		case 1000: /* fallthrough */
+		case 1000:
 		default:
 			tmp_reg16 |= IF_MODE_SGMII_SPEED_1G;
 		break;
diff --git a/drivers/net/ethernet/freescale/fman/fman_port.c b/drivers/net/ethernet/freescale/fman/fman_port.c
index ecbf6187e13a..66dd84f57002 100644
--- a/drivers/net/ethernet/freescale/fman/fman_port.c
+++ b/drivers/net/ethernet/freescale/fman/fman_port.c
@@ -1347,10 +1347,10 @@ int fman_port_config(struct fman_port *port, struct fman_port_params *params)
 	switch (port->port_type) {
 	case FMAN_PORT_TYPE_RX:
 		set_rx_dflt_cfg(port, params);
-		/* fall through */
+		fallthrough;
 	case FMAN_PORT_TYPE_TX:
 		set_tx_dflt_cfg(port, params, &port->dts_params);
-		/* fall through */
+		fallthrough;
 	default:
 		set_dflt_cfg(port, params);
 	}
diff --git a/drivers/net/ethernet/freescale/ucc_geth.c b/drivers/net/ethernet/freescale/ucc_geth.c
index 2e8e7a2fde71..5bbc0b107ca9 100644
--- a/drivers/net/ethernet/freescale/ucc_geth.c
+++ b/drivers/net/ethernet/freescale/ucc_geth.c
@@ -1351,7 +1351,7 @@ static int adjust_enet_interface(struct ucc_geth_private *ugeth)
 		switch (ugeth->max_speed) {
 		case SPEED_10:
 			upsmr |= UCC_GETH_UPSMR_R10M;
-			/* FALLTHROUGH */
+			fallthrough;
 		case SPEED_100:
 			if (ugeth->phy_interface != PHY_INTERFACE_MODE_RTBI)
 				upsmr |= UCC_GETH_UPSMR_RMM;
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_ethtool.c b/drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
index ce15d2350db9..91c8ba06bea4 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
@@ -309,7 +309,7 @@ static int __lb_setup(struct net_device *ndev,
 		break;
 	case MAC_LOOP_PHY_NONE:
 		ret = hns_nic_config_phy_loopback(phy_dev, 0x0);
-		/* fall through */
+		fallthrough;
 	case MAC_LOOP_NONE:
 		if (!ret && h->dev->ops->set_loopback) {
 			if (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII)
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
* Unmerged path drivers/net/ethernet/ibm/ehea/ehea_main.c
diff --git a/drivers/net/ethernet/ibm/emac/core.c b/drivers/net/ethernet/ibm/emac/core.c
index 4c848733f562..9255c3b037a8 100644
--- a/drivers/net/ethernet/ibm/emac/core.c
+++ b/drivers/net/ethernet/ibm/emac/core.c
@@ -2300,7 +2300,7 @@ static int emac_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
 	switch (cmd) {
 	case SIOCGMIIPHY:
 		data->phy_id = dev->phy.address;
-		/* Fall through */
+		fallthrough;
 	case SIOCGMIIREG:
 		data->val_out = emac_mdio_read(ndev, dev->phy.address,
 					       data->reg_num);
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
* Unmerged path drivers/net/ethernet/intel/igb/igb_main.c
* Unmerged path drivers/net/ethernet/marvell/mvneta.c
* Unmerged path drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c
* Unmerged path drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
* Unmerged path drivers/net/ethernet/marvell/octeontx2/af/rvu_nix.c
diff --git a/drivers/net/ethernet/marvell/skge.c b/drivers/net/ethernet/marvell/skge.c
index 1e51b402ab51..970e05f3f785 100644
--- a/drivers/net/ethernet/marvell/skge.c
+++ b/drivers/net/ethernet/marvell/skge.c
@@ -2457,7 +2457,7 @@ static int skge_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCGMIIPHY:
 		data->phy_id = hw->phy_addr;
 
-		/* fallthru */
+		fallthrough;
 	case SIOCGMIIREG: {
 		u16 val = 0;
 		spin_lock_bh(&hw->phy_lock);
diff --git a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c
index 8c97c8439230..f600f95bfbda 100644
--- a/drivers/net/ethernet/marvell/sky2.c
+++ b/drivers/net/ethernet/marvell/sky2.c
@@ -1386,7 +1386,7 @@ static int sky2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCGMIIPHY:
 		data->phy_id = PHY_ADDR_MARV;
 
-		/* fallthru */
+		fallthrough;
 	case SIOCGMIIREG: {
 		u16 val = 0;
 
@@ -2777,7 +2777,7 @@ static int sky2_status_intr(struct sky2_hw *hw, int to_do, u16 idx)
 
 		case OP_RXCHKSVLAN:
 			sky2_rx_tag(sky2, length);
-			/* fall through */
+			fallthrough;
 		case OP_RXCHKS:
 			if (likely(dev->features & NETIF_F_RXCSUM))
 				sky2_rx_checksum(sky2, status);
* Unmerged path drivers/net/ethernet/mediatek/mtk_eth_soc.c
diff --git a/drivers/net/ethernet/mellanox/mlxfw/mlxfw_fsm.c b/drivers/net/ethernet/mellanox/mlxfw/mlxfw_fsm.c
index 7a04c626a2aa..bcd166911d44 100644
--- a/drivers/net/ethernet/mellanox/mlxfw/mlxfw_fsm.c
+++ b/drivers/net/ethernet/mellanox/mlxfw/mlxfw_fsm.c
@@ -72,7 +72,7 @@ static int mlxfw_fsm_state_err(struct mlxfw_dev *mlxfw_dev,
 	case MLXFW_FSM_STATE_ERR_BLOCKED_PENDING_RESET:
 		MLXFW_ERR_MSG(mlxfw_dev, extack, "pending reset", err);
 		break;
-	case MLXFW_FSM_STATE_ERR_OK: /* fall through */
+	case MLXFW_FSM_STATE_ERR_OK:
 	case MLXFW_FSM_STATE_ERR_MAX:
 		MLXFW_ERR_MSG(mlxfw_dev, extack, "unknown error", err);
 		break;
@@ -155,7 +155,7 @@ mlxfw_fsm_reactivate_err(struct mlxfw_dev *mlxfw_dev,
 	case MLXFW_FSM_REACTIVATE_STATUS_FW_ALREADY_ACTIVATED:
 		MLXFW_REACT_ERR("fw already activated", err);
 		break;
-	case MLXFW_FSM_REACTIVATE_STATUS_OK: /* fall through */
+	case MLXFW_FSM_REACTIVATE_STATUS_OK:
 	case MLXFW_FSM_REACTIVATE_STATUS_MAX:
 		MLXFW_REACT_ERR("unexpected error", err);
 		break;
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core.c b/drivers/net/ethernet/mellanox/mlxsw/core.c
index 631bb8838d4d..86bba4ee0666 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core.c
@@ -2874,21 +2874,21 @@ int mlxsw_core_module_max_width(struct mlxsw_core *mlxsw_core, u8 module)
 	/* Here we need to get the module width according to the module type. */
 
 	switch (module_type) {
-	case MLXSW_REG_PMTM_MODULE_TYPE_C2C8X: /* fall through */
-	case MLXSW_REG_PMTM_MODULE_TYPE_QSFP_DD: /* fall through */
+	case MLXSW_REG_PMTM_MODULE_TYPE_C2C8X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_QSFP_DD:
 	case MLXSW_REG_PMTM_MODULE_TYPE_OSFP:
 		return 8;
-	case MLXSW_REG_PMTM_MODULE_TYPE_C2C4X: /* fall through */
-	case MLXSW_REG_PMTM_MODULE_TYPE_BP_4X: /* fall through */
+	case MLXSW_REG_PMTM_MODULE_TYPE_C2C4X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_BP_4X:
 	case MLXSW_REG_PMTM_MODULE_TYPE_QSFP:
 		return 4;
-	case MLXSW_REG_PMTM_MODULE_TYPE_C2C2X: /* fall through */
-	case MLXSW_REG_PMTM_MODULE_TYPE_BP_2X: /* fall through */
-	case MLXSW_REG_PMTM_MODULE_TYPE_SFP_DD: /* fall through */
+	case MLXSW_REG_PMTM_MODULE_TYPE_C2C2X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_BP_2X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_SFP_DD:
 	case MLXSW_REG_PMTM_MODULE_TYPE_DSFP:
 		return 2;
-	case MLXSW_REG_PMTM_MODULE_TYPE_C2C1X: /* fall through */
-	case MLXSW_REG_PMTM_MODULE_TYPE_BP_1X: /* fall through */
+	case MLXSW_REG_PMTM_MODULE_TYPE_C2C1X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_BP_1X:
 	case MLXSW_REG_PMTM_MODULE_TYPE_SFP:
 		return 1;
 	default:
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core_env.c b/drivers/net/ethernet/mellanox/mlxsw/core_env.c
index 30597f19fe22..dd26865bd587 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core_env.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_env.c
@@ -42,8 +42,8 @@ static int mlxsw_env_validate_cable_ident(struct mlxsw_core *core, int id,
 	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_SFP:
 		*qsfp = false;
 		break;
-	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP: /* fall-through */
-	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS: /* fall-through */
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP:
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS:
 	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28:
 		*qsfp = true;
 		break;
@@ -217,7 +217,7 @@ int mlxsw_env_get_module_info(struct mlxsw_core *mlxsw_core, int module,
 		modinfo->type       = ETH_MODULE_SFF_8436;
 		modinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;
 		break;
-	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS: /* fall-through */
+	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS:
 	case MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28:
 		if (module_id == MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28 ||
 		    module_rev_id >=
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core_hwmon.c b/drivers/net/ethernet/mellanox/mlxsw/core_hwmon.c
index 01b36ebcb9c1..2196c946698a 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core_hwmon.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_hwmon.c
@@ -288,8 +288,8 @@ static ssize_t mlxsw_hwmon_module_temp_fault_show(struct device *dev,
 		 */
 		fault = 1;
 		break;
-	case MLXSW_REG_MTBR_NO_CONN: /* fall-through */
-	case MLXSW_REG_MTBR_NO_TEMP_SENS: /* fall-through */
+	case MLXSW_REG_MTBR_NO_CONN:
+	case MLXSW_REG_MTBR_NO_TEMP_SENS:
 	case MLXSW_REG_MTBR_INDEX_NA:
 	default:
 		fault = 0;
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index aebc117c5bd9..a73ed95d610c 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@ -248,8 +248,8 @@ enum mlxsw_reg_spms_state mlxsw_sp_stp_spms_state(u8 state)
 		return MLXSW_REG_SPMS_STATE_FORWARDING;
 	case BR_STATE_LEARNING:
 		return MLXSW_REG_SPMS_STATE_LEARNING;
-	case BR_STATE_LISTENING: /* fall-through */
-	case BR_STATE_DISABLED: /* fall-through */
+	case BR_STATE_LISTENING:
+	case BR_STATE_DISABLED:
 	case BR_STATE_BLOCKING:
 		return MLXSW_REG_SPMS_STATE_DISCARDING;
 	default:
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index 93547a849374..8568677fd034 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@ -684,11 +684,11 @@ static inline unsigned int
 mlxsw_sp_kvdl_entry_size(enum mlxsw_sp_kvdl_entry_type type)
 {
 	switch (type) {
-	case MLXSW_SP_KVDL_ENTRY_TYPE_ADJ: /* fall through */
-	case MLXSW_SP_KVDL_ENTRY_TYPE_ACTSET: /* fall through */
-	case MLXSW_SP_KVDL_ENTRY_TYPE_PBS: /* fall through */
-	case MLXSW_SP_KVDL_ENTRY_TYPE_MCRIGR: /* fall through */
-	case MLXSW_SP_KVDL_ENTRY_TYPE_TNUMT: /* fall through */
+	case MLXSW_SP_KVDL_ENTRY_TYPE_ADJ:
+	case MLXSW_SP_KVDL_ENTRY_TYPE_ACTSET:
+	case MLXSW_SP_KVDL_ENTRY_TYPE_PBS:
+	case MLXSW_SP_KVDL_ENTRY_TYPE_MCRIGR:
+	case MLXSW_SP_KVDL_ENTRY_TYPE_TNUMT:
 	default:
 		return 1;
 	}
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index e9a1fa03f78d..7d2252662f86 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@ -1163,7 +1163,7 @@ mlxsw_sp_router_ip2me_fib_entry_find(struct mlxsw_sp *mlxsw_sp, u32 tb_id,
 		addr_len = 4;
 		addr_prefix_len = 32;
 		break;
-	case MLXSW_SP_L3_PROTO_IPV6: /* fall through */
+	case MLXSW_SP_L3_PROTO_IPV6:
 	default:
 		WARN_ON(1);
 		return NULL;
@@ -4547,14 +4547,14 @@ mlxsw_sp_fib4_entry_type_set(struct mlxsw_sp *mlxsw_sp,
 			fib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP;
 			return 0;
 		}
-		/* fall through */
+		fallthrough;
 	case RTN_BROADCAST:
 		fib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;
 		return 0;
 	case RTN_BLACKHOLE:
 		fib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_BLACKHOLE;
 		return 0;
-	case RTN_UNREACHABLE: /* fall through */
+	case RTN_UNREACHABLE:
 	case RTN_PROHIBIT:
 		/* Packets hitting these routes need to be trapped, but
 		 * can do so with a lower priority than packets directed
@@ -5982,7 +5982,7 @@ static void mlxsw_sp_router_fib4_event_work(struct work_struct *work)
 		mlxsw_sp_router_fib4_del(mlxsw_sp, &fib_work->fen_info);
 		fib_info_put(fib_work->fen_info.fi);
 		break;
-	case FIB_EVENT_NH_ADD: /* fall through */
+	case FIB_EVENT_NH_ADD:
 	case FIB_EVENT_NH_DEL:
 		mlxsw_sp_nexthop4_event(mlxsw_sp, fib_work->event,
 					fib_work->fnh_info.fib_nh);
@@ -6042,7 +6042,7 @@ static void mlxsw_sp_router_fibmr_event_work(struct work_struct *work)
 	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	switch (fib_work->event) {
-	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
+	case FIB_EVENT_ENTRY_REPLACE:
 	case FIB_EVENT_ENTRY_ADD:
 		replace = fib_work->event == FIB_EVENT_ENTRY_REPLACE;
 
@@ -6081,7 +6081,7 @@ static void mlxsw_sp_router_fib4_event(struct mlxsw_sp_fib_event_work *fib_work,
 	struct fib_nh_notifier_info *fnh_info;
 
 	switch (fib_work->event) {
-	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
+	case FIB_EVENT_ENTRY_REPLACE:
 	case FIB_EVENT_ENTRY_DEL:
 		fen_info = container_of(info, struct fib_entry_notifier_info,
 					info);
@@ -6091,7 +6091,7 @@ static void mlxsw_sp_router_fib4_event(struct mlxsw_sp_fib_event_work *fib_work,
 		 */
 		fib_info_hold(fib_work->fen_info.fi);
 		break;
-	case FIB_EVENT_NH_ADD: /* fall through */
+	case FIB_EVENT_NH_ADD:
 	case FIB_EVENT_NH_DEL:
 		fnh_info = container_of(info, struct fib_nh_notifier_info,
 					info);
@@ -6108,8 +6108,8 @@ static int mlxsw_sp_router_fib6_event(struct mlxsw_sp_fib_event_work *fib_work,
 	int err;
 
 	switch (fib_work->event) {
-	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
-	case FIB_EVENT_ENTRY_APPEND: /* fall through */
+	case FIB_EVENT_ENTRY_REPLACE:
+	case FIB_EVENT_ENTRY_APPEND:
 	case FIB_EVENT_ENTRY_DEL:
 		fen6_info = container_of(info, struct fib6_entry_notifier_info,
 					 info);
@@ -6128,13 +6128,13 @@ mlxsw_sp_router_fibmr_event(struct mlxsw_sp_fib_event_work *fib_work,
 			    struct fib_notifier_info *info)
 {
 	switch (fib_work->event) {
-	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
-	case FIB_EVENT_ENTRY_ADD: /* fall through */
+	case FIB_EVENT_ENTRY_REPLACE:
+	case FIB_EVENT_ENTRY_ADD:
 	case FIB_EVENT_ENTRY_DEL:
 		memcpy(&fib_work->men_info, info, sizeof(fib_work->men_info));
 		mr_cache_hold(fib_work->men_info.mfc);
 		break;
-	case FIB_EVENT_VIF_ADD: /* fall through */
+	case FIB_EVENT_VIF_ADD:
 	case FIB_EVENT_VIF_DEL:
 		memcpy(&fib_work->ven_info, info, sizeof(fib_work->ven_info));
 		dev_hold(fib_work->ven_info.dev);
@@ -6207,13 +6207,13 @@ static int mlxsw_sp_router_fib_event(struct notifier_block *nb,
 	router = container_of(nb, struct mlxsw_sp_router, fib_nb);
 
 	switch (event) {
-	case FIB_EVENT_RULE_ADD: /* fall through */
+	case FIB_EVENT_RULE_ADD:
 	case FIB_EVENT_RULE_DEL:
 		err = mlxsw_sp_router_fib_rule_event(event, info,
 						     router->mlxsw_sp);
 		return notifier_from_errno(err);
-	case FIB_EVENT_ENTRY_ADD: /* fall through */
-	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
+	case FIB_EVENT_ENTRY_ADD:
+	case FIB_EVENT_ENTRY_REPLACE:
 	case FIB_EVENT_ENTRY_APPEND:
 		if (router->aborted) {
 			NL_SET_ERR_MSG_MOD(info->extack, "FIB offload was aborted. Not configuring route");
@@ -7247,7 +7247,7 @@ int mlxsw_sp_netdevice_router_port_event(struct net_device *dev,
 		goto out;
 
 	switch (event) {
-	case NETDEV_CHANGEMTU: /* fall through */
+	case NETDEV_CHANGEMTU:
 	case NETDEV_CHANGEADDR:
 		err = mlxsw_sp_router_port_change_event(mlxsw_sp, rif);
 		break;
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
index 2d2fb69b6194..f4bf7cda5380 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
@@ -1456,12 +1456,12 @@ mlxsw_sp_span_trigger_ops_set(struct mlxsw_sp_span_trigger_entry *trigger_entry)
 	enum mlxsw_sp_span_trigger_type type;
 
 	switch (trigger_entry->trigger) {
-	case MLXSW_SP_SPAN_TRIGGER_INGRESS: /* fall-through */
+	case MLXSW_SP_SPAN_TRIGGER_INGRESS:
 	case MLXSW_SP_SPAN_TRIGGER_EGRESS:
 		type = MLXSW_SP_SPAN_TRIGGER_TYPE_PORT;
 		break;
-	case MLXSW_SP_SPAN_TRIGGER_TAIL_DROP: /* fall-through */
-	case MLXSW_SP_SPAN_TRIGGER_EARLY_DROP: /* fall-through */
+	case MLXSW_SP_SPAN_TRIGGER_TAIL_DROP:
+	case MLXSW_SP_SPAN_TRIGGER_EARLY_DROP:
 	case MLXSW_SP_SPAN_TRIGGER_ECN:
 		type = MLXSW_SP_SPAN_TRIGGER_TYPE_GLOBAL;
 		break;
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index a26162b08b7d..72912afa6f72 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@ -1297,7 +1297,7 @@ static int mlxsw_sp_port_fdb_tunnel_uc_op(struct mlxsw_sp *mlxsw_sp,
 		uip = be32_to_cpu(addr->addr4);
 		sfd_proto = MLXSW_REG_SFD_UC_TUNNEL_PROTOCOL_IPV4;
 		break;
-	case MLXSW_SP_L3_PROTO_IPV6: /* fall through */
+	case MLXSW_SP_L3_PROTO_IPV6:
 	default:
 		WARN_ON(1);
 		return -EOPNOTSUPP;
@@ -2870,7 +2870,7 @@ static void mlxsw_sp_switchdev_bridge_fdb_event_work(struct work_struct *work)
 		fdb_info = &switchdev_work->fdb_info;
 		mlxsw_sp_port_fdb_set(mlxsw_sp_port, fdb_info, false);
 		break;
-	case SWITCHDEV_FDB_ADD_TO_BRIDGE: /* fall through */
+	case SWITCHDEV_FDB_ADD_TO_BRIDGE:
 	case SWITCHDEV_FDB_DEL_TO_BRIDGE:
 		/* These events are only used to potentially update an existing
 		 * SPAN mirror.
@@ -3116,9 +3116,9 @@ static int mlxsw_sp_switchdev_event(struct notifier_block *unused,
 	switchdev_work->event = event;
 
 	switch (event) {
-	case SWITCHDEV_FDB_ADD_TO_DEVICE: /* fall through */
-	case SWITCHDEV_FDB_DEL_TO_DEVICE: /* fall through */
-	case SWITCHDEV_FDB_ADD_TO_BRIDGE: /* fall through */
+	case SWITCHDEV_FDB_ADD_TO_DEVICE:
+	case SWITCHDEV_FDB_DEL_TO_DEVICE:
+	case SWITCHDEV_FDB_ADD_TO_BRIDGE:
 	case SWITCHDEV_FDB_DEL_TO_BRIDGE:
 		fdb_info = container_of(info,
 					struct switchdev_notifier_fdb_info,
@@ -3138,7 +3138,7 @@ static int mlxsw_sp_switchdev_event(struct notifier_block *unused,
 		 */
 		dev_hold(dev);
 		break;
-	case SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE: /* fall through */
+	case SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE:
 	case SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE:
 		INIT_WORK(&switchdev_work->work,
 			  mlxsw_sp_switchdev_vxlan_fdb_event_work);
* Unmerged path drivers/net/ethernet/microchip/lan743x_ethtool.c
* Unmerged path drivers/net/ethernet/mscc/ocelot.c
diff --git a/drivers/net/ethernet/natsemi/natsemi.c b/drivers/net/ethernet/natsemi/natsemi.c
index 04f2d7b88f15..1fe522891aee 100644
--- a/drivers/net/ethernet/natsemi/natsemi.c
+++ b/drivers/net/ethernet/natsemi/natsemi.c
@@ -3081,7 +3081,7 @@ static int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	switch(cmd) {
 	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
 		data->phy_id = np->phy_addr_external;
-		/* Fall Through */
+		fallthrough;
 
 	case SIOCGMIIREG:		/* Read MII PHY register. */
 		/* The phy_id is not enough to uniquely identify
* Unmerged path drivers/net/ethernet/neterion/vxge/vxge-config.c
diff --git a/drivers/net/ethernet/netronome/nfp/crypto/tls.c b/drivers/net/ethernet/netronome/nfp/crypto/tls.c
index 97eef2999650..d7b689e5f07c 100644
--- a/drivers/net/ethernet/netronome/nfp/crypto/tls.c
+++ b/drivers/net/ethernet/netronome/nfp/crypto/tls.c
@@ -295,7 +295,7 @@ nfp_net_tls_add(struct net_device *netdev, struct sock *sk,
 			break;
 		}
 #endif
-		/* fall through */
+		fallthrough;
 	case AF_INET:
 		req_sz = sizeof(struct nfp_crypto_req_add_v4);
 		ipv6 = false;
diff --git a/drivers/net/ethernet/netronome/nfp/flower/action.c b/drivers/net/ethernet/netronome/nfp/flower/action.c
index ff844e5cc41f..1cbe2c9f3959 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/action.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/action.c
@@ -297,7 +297,7 @@ nfp_fl_get_tun_from_act(struct nfp_app *app,
 	case htons(GENEVE_UDP_PORT):
 		if (priv->flower_ext_feats & NFP_FL_FEATS_GENEVE)
 			return NFP_FL_TUNNEL_GENEVE;
-		/* FALLTHROUGH */
+		fallthrough;
 	default:
 		return NFP_FL_TUNNEL_NONE;
 	}
diff --git a/drivers/net/ethernet/netronome/nfp/flower/cmsg.c b/drivers/net/ethernet/netronome/nfp/flower/cmsg.c
index a050cb898782..f21cf1f40f98 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/cmsg.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/cmsg.c
@@ -289,7 +289,7 @@ nfp_flower_cmsg_process_one_rx(struct nfp_app *app, struct sk_buff *skb)
 			skb_stored = nfp_flower_lag_unprocessed_msg(app, skb);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 err_default:
 		nfp_flower_cmsg_warn(app, "Cannot handle invalid repr control type %u\n",
diff --git a/drivers/net/ethernet/netronome/nfp/flower/offload.c b/drivers/net/ethernet/netronome/nfp/flower/offload.c
index 95c75250c355..18eb828942e8 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@ -784,7 +784,7 @@ nfp_flower_copy_pre_actions(char *act_dst, char *act_src, int len,
 		case NFP_FL_ACTION_OPCODE_PRE_TUNNEL:
 			if (tunnel_act)
 				*tunnel_act = true;
-			/* fall through */
+			fallthrough;
 		case NFP_FL_ACTION_OPCODE_PRE_LAG:
 			memcpy(act_dst + act_off, act_src + act_off, act_len);
 			break;
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_asm.c b/drivers/net/ethernet/netronome/nfp/nfp_asm.c
index b04b83687fe2..2643ea5948f4 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_asm.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_asm.c
@@ -137,7 +137,7 @@ static u16 nfp_swreg_to_unreg(swreg reg, bool is_dst)
 				val;
 		case NN_LM_MOD_DEC:
 			lm_dec = true;
-			/* fall through */
+			fallthrough;
 		case NN_LM_MOD_INC:
 			if (val) {
 				pr_err("LM offset in inc/dev mode\n");
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index ba2f2be90a1b..596dc7e6bf59 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@ -1930,10 +1930,10 @@ static int nfp_net_rx(struct nfp_net_rx_ring *rx_ring, int budget)
 				continue;
 			default:
 				bpf_warn_invalid_xdp_action(act);
-				/* fall through */
+				fallthrough;
 			case XDP_ABORTED:
 				trace_xdp_exception(dp->netdev, xdp_prog, act);
-				/* fall through */
+				fallthrough;
 			case XDP_DROP:
 				nfp_net_rx_give_one(dp, rx_ring, rxbuf->frag,
 						    rxbuf->dma_addr);
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp6000_pcie.c b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp6000_pcie.c
index ed3556da3a21..8c79073e2b6d 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp6000_pcie.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp6000_pcie.c
@@ -340,12 +340,12 @@ static int matching_bar(struct nfp_bar *bar, u32 tgt, u32 act, u32 tok,
 	switch (maptype) {
 	case NFP_PCIE_BAR_PCIE2CPP_MapType_TARGET:
 		bartok = -1;
-		/* FALLTHROUGH */
+		fallthrough;
 	case NFP_PCIE_BAR_PCIE2CPP_MapType_BULK:
 		baract = NFP_CPP_ACTION_RW;
 		if (act == 0)
 			act = NFP_CPP_ACTION_RW;
-		/* FALLTHROUGH */
+		fallthrough;
 	case NFP_PCIE_BAR_PCIE2CPP_MapType_FIXED:
 		break;
 	default:
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
index 75f012444796..2260c2403a83 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
@@ -213,7 +213,7 @@ u64 nfp_rtsym_size(const struct nfp_rtsym *sym)
 		return 0;
 	default:
 		pr_warn("rtsym '%s': unknown type: %d\n", sym->name, sym->type);
-		/* fall through */
+		fallthrough;
 	case NFP_RTSYM_TYPE_OBJECT:
 	case NFP_RTSYM_TYPE_FUNCTION:
 		return sym->size;
diff --git a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_param.c b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_param.c
index e097e6baaac4..4b0da5057eba 100644
--- a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_param.c
+++ b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_param.c
@@ -421,7 +421,7 @@ static void pch_gbe_check_copper_options(struct pch_gbe_adapter *adapter)
 	case SPEED_1000 + HALF_DUPLEX:
 		netdev_dbg(adapter->netdev,
 			   "Half Duplex is not supported at 1000 Mbps\n");
-		/* fall through */
+		fallthrough;
 	case SPEED_1000 + FULL_DUPLEX:
 full_duplex_only:
 		netdev_dbg(adapter->netdev,
diff --git a/drivers/net/ethernet/packetengines/yellowfin.c b/drivers/net/ethernet/packetengines/yellowfin.c
index f68801152128..417fd7707817 100644
--- a/drivers/net/ethernet/packetengines/yellowfin.c
+++ b/drivers/net/ethernet/packetengines/yellowfin.c
@@ -1344,7 +1344,7 @@ static int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	switch(cmd) {
 	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
 		data->phy_id = np->phys[0] & 0x1f;
-		/* Fall Through */
+		fallthrough;
 
 	case SIOCGMIIREG:		/* Read MII PHY register. */
 		data->val_out = mdio_read(ioaddr, data->phy_id & 0x1f, data->reg_num & 0x1f);
* Unmerged path drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_cxt.c b/drivers/net/ethernet/qlogic/qed/qed_cxt.c
index e5304acd5921..81791ed2334f 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_cxt.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_cxt.c
@@ -2046,7 +2046,7 @@ int qed_cxt_set_pf_params(struct qed_hwfn *p_hwfn, u32 rdma_tasks)
 					       rdma_tasks);
 		/* no need for break since RoCE coexist with Ethernet */
 	}
-	/* fall through */
+		fallthrough;
 	case QED_PCI_ETH:
 	{
 		struct qed_eth_pf_params *p_params =
diff --git a/drivers/net/ethernet/qlogic/qed/qed_dev.c b/drivers/net/ethernet/qlogic/qed/qed_dev.c
index 6b952e649584..867a6def45b9 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@ -3109,14 +3109,14 @@ int qed_hw_init(struct qed_dev *cdev, struct qed_hw_init_params *p_params)
 						p_hwfn->hw_info.hw_mode);
 			if (rc)
 				break;
-		/* Fall through */
+			fallthrough;
 		case FW_MSG_CODE_DRV_LOAD_PORT:
 			rc = qed_hw_init_port(p_hwfn, p_hwfn->p_main_ptt,
 					      p_hwfn->hw_info.hw_mode);
 			if (rc)
 				break;
 
-		/* Fall through */
+			fallthrough;
 		case FW_MSG_CODE_DRV_LOAD_FUNCTION:
 			rc = qed_hw_init_pf(p_hwfn, p_hwfn->p_main_ptt,
 					    p_params->p_tunn,
diff --git a/drivers/net/ethernet/qlogic/qed/qed_main.c b/drivers/net/ethernet/qlogic/qed/qed_main.c
index 77257ca15116..f3f0b0321333 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -681,7 +681,7 @@ static int qed_set_int_mode(struct qed_dev *cdev, bool force_mode)
 		kfree(int_params->msix_table);
 		if (force_mode)
 			goto out;
-		/* Fallthrough */
+		fallthrough;
 
 	case QED_INT_MODE_MSI:
 		if (cdev->num_hwfns == 1) {
@@ -695,7 +695,7 @@ static int qed_set_int_mode(struct qed_dev *cdev, bool force_mode)
 			if (force_mode)
 				goto out;
 		}
-		/* Fallthrough */
+		fallthrough;
 
 	case QED_INT_MODE_INTA:
 			int_params->out.int_mode = QED_INT_MODE_INTA;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.c b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 5285783c68cb..cd60690ef553 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@ -1085,7 +1085,7 @@ int qed_mcp_unload_req(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
 		DP_NOTICE(p_hwfn,
 			  "Unknown WoL configuration %02x\n",
 			  p_hwfn->cdev->wol_config);
-		/* Fallthrough */
+		fallthrough;
 	case QED_OV_WOL_DEFAULT:
 		wol_param = DRV_MB_PARAM_UNLOAD_WOL_MCP;
 	}
@@ -1365,7 +1365,7 @@ static void qed_mcp_handle_link_change(struct qed_hwfn *p_hwfn,
 		break;
 	case LINK_STATUS_SPEED_AND_DUPLEX_1000THD:
 		p_link->full_duplex = false;
-	/* Fall-through */
+		fallthrough;
 	case LINK_STATUS_SPEED_AND_DUPLEX_1000TFD:
 		p_link->speed = 1000;
 		break;
@@ -2359,7 +2359,7 @@ qed_mcp_get_shmem_proto(struct qed_hwfn *p_hwfn,
 		break;
 	case FUNC_MF_CFG_PROTOCOL_ROCE:
 		DP_NOTICE(p_hwfn, "RoCE personality is not a valid value!\n");
-	/* Fallthrough */
+		fallthrough;
 	default:
 		rc = -EINVAL;
 	}
@@ -3454,7 +3454,7 @@ qed_mcp_resc_allocation_msg(struct qed_hwfn *p_hwfn,
 	switch (p_in_params->cmd) {
 	case DRV_MSG_SET_RESOURCE_VALUE_MSG:
 		mfw_resc_info.size = p_in_params->resc_max_val;
-		/* Fallthrough */
+		fallthrough;
 	case DRV_MSG_GET_RESOURCE_ALLOC_MSG:
 		break;
 	default:
@@ -3731,7 +3731,7 @@ qed_mcp_resc_unlock(struct qed_hwfn *p_hwfn,
 		DP_INFO(p_hwfn,
 			"Resource unlock request for an already released resource [%d]\n",
 			p_params->resource);
-		/* Fallthrough */
+		fallthrough;
 	case RESOURCE_OPCODE_RELEASED:
 		p_params->b_released = true;
 		break;
diff --git a/drivers/net/ethernet/qlogic/qla3xxx.c b/drivers/net/ethernet/qlogic/qla3xxx.c
index 79b6c48434f3..3b875df71354 100644
--- a/drivers/net/ethernet/qlogic/qla3xxx.c
+++ b/drivers/net/ethernet/qlogic/qla3xxx.c
@@ -1544,7 +1544,7 @@ static void ql_link_state_machine_work(struct work_struct *work)
 		if (test_bit(QL_LINK_MASTER, &qdev->flags))
 			ql_port_start(qdev);
 		qdev->port_link_state = LS_DOWN;
-		/* Fall Through */
+		fallthrough;
 
 	case LS_DOWN:
 		if (curr_link_state == LS_UP) {
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
diff --git a/drivers/net/ethernet/realtek/r8169_main.c b/drivers/net/ethernet/realtek/r8169_main.c
index 49282a0ac9aa..871bb9bb9449 100644
--- a/drivers/net/ethernet/realtek/r8169_main.c
+++ b/drivers/net/ethernet/realtek/r8169_main.c
@@ -5009,7 +5009,7 @@ static int rtl_alloc_irq(struct rtl8169_private *tp)
 		rtl_unlock_config_regs(tp);
 		RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~MSIEnable);
 		rtl_lock_config_regs(tp);
-		/* fall through */
+		fallthrough;
 	case RTL_GIGA_MAC_VER_07 ... RTL_GIGA_MAC_VER_17:
 		flags = PCI_IRQ_LEGACY;
 		break;
@@ -5152,7 +5152,7 @@ static void rtl_hw_initialize(struct rtl8169_private *tp)
 	switch (tp->mac_version) {
 	case RTL_GIGA_MAC_VER_49 ... RTL_GIGA_MAC_VER_52:
 		rtl8168ep_stop_cmac(tp);
-		/* fall through */
+		fallthrough;
 	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_48:
 		rtl_hw_init_8168g(tp);
 		break;
diff --git a/drivers/net/ethernet/rocker/rocker_main.c b/drivers/net/ethernet/rocker/rocker_main.c
index 339d0ac62fdc..81983b1a7757 100644
--- a/drivers/net/ethernet/rocker/rocker_main.c
+++ b/drivers/net/ethernet/rocker/rocker_main.c
@@ -2173,7 +2173,7 @@ static void rocker_router_fib_event_work(struct work_struct *work)
 		rocker_world_fib4_del(rocker, &fib_work->fen_info);
 		fib_info_put(fib_work->fen_info.fi);
 		break;
-	case FIB_EVENT_RULE_ADD: /* fall through */
+	case FIB_EVENT_RULE_ADD:
 	case FIB_EVENT_RULE_DEL:
 		rule = fib_work->fr_info.rule;
 		if (!fib4_rule_default(rule))
@@ -2205,7 +2205,7 @@ static int rocker_router_fib_event(struct notifier_block *nb,
 	fib_work->event = event;
 
 	switch (event) {
-	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
+	case FIB_EVENT_ENTRY_REPLACE:
 	case FIB_EVENT_ENTRY_DEL:
 		memcpy(&fib_work->fen_info, ptr, sizeof(fib_work->fen_info));
 		/* Take referece on fib_info to prevent it from being
@@ -2213,7 +2213,7 @@ static int rocker_router_fib_event(struct notifier_block *nb,
 		 */
 		fib_info_hold(fib_work->fen_info.fi);
 		break;
-	case FIB_EVENT_RULE_ADD: /* fall through */
+	case FIB_EVENT_RULE_ADD:
 	case FIB_EVENT_RULE_DEL:
 		memcpy(&fib_work->fr_info, ptr, sizeof(fib_work->fr_info));
 		fib_rule_get(fib_work->fr_info.rule);
@@ -2800,7 +2800,7 @@ static int rocker_switchdev_event(struct notifier_block *unused,
 	switchdev_work->event = event;
 
 	switch (event) {
-	case SWITCHDEV_FDB_ADD_TO_DEVICE: /* fall through */
+	case SWITCHDEV_FDB_ADD_TO_DEVICE:
 	case SWITCHDEV_FDB_DEL_TO_DEVICE:
 		memcpy(&switchdev_work->fdb_info, ptr,
 		       sizeof(switchdev_work->fdb_info));
* Unmerged path drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c
* Unmerged path drivers/net/ethernet/sfc/falcon/ethtool.c
diff --git a/drivers/net/ethernet/sfc/falcon/farch.c b/drivers/net/ethernet/sfc/falcon/farch.c
index 332183280a45..fa1ade856b10 100644
--- a/drivers/net/ethernet/sfc/falcon/farch.c
+++ b/drivers/net/ethernet/sfc/falcon/farch.c
@@ -1049,10 +1049,10 @@ ef4_farch_handle_rx_event(struct ef4_channel *channel, const ef4_qword_t *event)
 		switch (rx_ev_hdr_type) {
 		case FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP:
 			flags |= EF4_RX_PKT_TCP;
-			/* fall through */
+			fallthrough;
 		case FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP:
 			flags |= EF4_RX_PKT_CSUMMED;
-			/* fall through */
+			fallthrough;
 		case FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_OTHER:
 		case FSE_AZ_RX_EV_HDR_TYPE_OTHER:
 			break;
@@ -1310,7 +1310,7 @@ int ef4_farch_ev_process(struct ef4_channel *channel, int budget)
 			if (efx->type->handle_global_event &&
 			    efx->type->handle_global_event(channel, &event))
 				break;
-			/* else fall through */
+			fallthrough;
 		default:
 			netif_err(channel->efx, hw, channel->efx->net_dev,
 				  "channel %d unknown event type %d (data "
@@ -1983,7 +1983,7 @@ ef4_farch_filter_from_gen_spec(struct ef4_farch_filter_spec *spec,
 	      EF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_LOC_PORT |
 	      EF4_FILTER_MATCH_REM_HOST | EF4_FILTER_MATCH_REM_PORT):
 		is_full = true;
-		/* fall through */
+		fallthrough;
 	case (EF4_FILTER_MATCH_ETHER_TYPE | EF4_FILTER_MATCH_IP_PROTO |
 	      EF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_LOC_PORT): {
 		__be32 rhost, host1, host2;
@@ -2034,7 +2034,7 @@ ef4_farch_filter_from_gen_spec(struct ef4_farch_filter_spec *spec,
 
 	case EF4_FILTER_MATCH_LOC_MAC | EF4_FILTER_MATCH_OUTER_VID:
 		is_full = true;
-		/* fall through */
+		fallthrough;
 	case EF4_FILTER_MATCH_LOC_MAC:
 		spec->type = (is_full ? EF4_FARCH_FILTER_MAC_FULL :
 			      EF4_FARCH_FILTER_MAC_WILD);
@@ -2081,7 +2081,7 @@ ef4_farch_filter_to_gen_spec(struct ef4_filter_spec *gen_spec,
 	case EF4_FARCH_FILTER_TCP_FULL:
 	case EF4_FARCH_FILTER_UDP_FULL:
 		is_full = true;
-		/* fall through */
+		fallthrough;
 	case EF4_FARCH_FILTER_TCP_WILD:
 	case EF4_FARCH_FILTER_UDP_WILD: {
 		__be32 host1, host2;
@@ -2125,7 +2125,7 @@ ef4_farch_filter_to_gen_spec(struct ef4_filter_spec *gen_spec,
 
 	case EF4_FARCH_FILTER_MAC_FULL:
 		is_full = true;
-		/* fall through */
+		fallthrough;
 	case EF4_FARCH_FILTER_MAC_WILD:
 		gen_spec->match_flags = EF4_FILTER_MATCH_LOC_MAC;
 		if (is_full)
diff --git a/drivers/net/ethernet/sfc/farch.c b/drivers/net/ethernet/sfc/farch.c
index d07eeaad9bdf..4002f9a3ae90 100644
--- a/drivers/net/ethernet/sfc/farch.c
+++ b/drivers/net/ethernet/sfc/farch.c
@@ -1038,10 +1038,10 @@ efx_farch_handle_rx_event(struct efx_channel *channel, const efx_qword_t *event)
 		switch (rx_ev_hdr_type) {
 		case FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP:
 			flags |= EFX_RX_PKT_TCP;
-			/* fall through */
+			fallthrough;
 		case FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP:
 			flags |= EFX_RX_PKT_CSUMMED;
-			/* fall through */
+			fallthrough;
 		case FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_OTHER:
 		case FSE_AZ_RX_EV_HDR_TYPE_OTHER:
 			break;
@@ -1316,7 +1316,7 @@ int efx_farch_ev_process(struct efx_channel *channel, int budget)
 			if (efx->type->handle_global_event &&
 			    efx->type->handle_global_event(channel, &event))
 				break;
-			/* else fall through */
+			fallthrough;
 		default:
 			netif_err(channel->efx, hw, channel->efx->net_dev,
 				  "channel %d unknown event type %d (data "
@@ -2043,7 +2043,7 @@ efx_farch_filter_from_gen_spec(struct efx_farch_filter_spec *spec,
 	      EFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_LOC_PORT |
 	      EFX_FILTER_MATCH_REM_HOST | EFX_FILTER_MATCH_REM_PORT):
 		is_full = true;
-		/* fall through */
+		fallthrough;
 	case (EFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_IP_PROTO |
 	      EFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_LOC_PORT): {
 		__be32 rhost, host1, host2;
@@ -2094,7 +2094,7 @@ efx_farch_filter_from_gen_spec(struct efx_farch_filter_spec *spec,
 
 	case EFX_FILTER_MATCH_LOC_MAC | EFX_FILTER_MATCH_OUTER_VID:
 		is_full = true;
-		/* fall through */
+		fallthrough;
 	case EFX_FILTER_MATCH_LOC_MAC:
 		spec->type = (is_full ? EFX_FARCH_FILTER_MAC_FULL :
 			      EFX_FARCH_FILTER_MAC_WILD);
@@ -2141,7 +2141,7 @@ efx_farch_filter_to_gen_spec(struct efx_filter_spec *gen_spec,
 	case EFX_FARCH_FILTER_TCP_FULL:
 	case EFX_FARCH_FILTER_UDP_FULL:
 		is_full = true;
-		/* fall through */
+		fallthrough;
 	case EFX_FARCH_FILTER_TCP_WILD:
 	case EFX_FARCH_FILTER_UDP_WILD: {
 		__be32 host1, host2;
@@ -2185,7 +2185,7 @@ efx_farch_filter_to_gen_spec(struct efx_filter_spec *gen_spec,
 
 	case EFX_FARCH_FILTER_MAC_FULL:
 		is_full = true;
-		/* fall through */
+		fallthrough;
 	case EFX_FARCH_FILTER_MAC_WILD:
 		gen_spec->match_flags = EFX_FILTER_MATCH_LOC_MAC;
 		if (is_full)
diff --git a/drivers/net/ethernet/sfc/mcdi_filters.c b/drivers/net/ethernet/sfc/mcdi_filters.c
index 5a74d880b733..1523be77b9db 100644
--- a/drivers/net/ethernet/sfc/mcdi_filters.c
+++ b/drivers/net/ethernet/sfc/mcdi_filters.c
@@ -140,7 +140,7 @@ efx_mcdi_filter_push_prep_set_match_fields(struct efx_nic *efx,
 		switch (encap_type & EFX_ENCAP_TYPES_MASK) {
 		case EFX_ENCAP_TYPE_VXLAN:
 			vni_type = MC_CMD_FILTER_OP_EXT_IN_VNI_TYPE_VXLAN;
-			/* fallthrough */
+			fallthrough;
 		case EFX_ENCAP_TYPE_GENEVE:
 			COPY_VALUE(ether_type, ETHER_TYPE);
 			outer_ip_proto = IPPROTO_UDP;
diff --git a/drivers/net/ethernet/sfc/mcdi_port_common.c b/drivers/net/ethernet/sfc/mcdi_port_common.c
index 56af8b54a864..714d7f937212 100644
--- a/drivers/net/ethernet/sfc/mcdi_port_common.c
+++ b/drivers/net/ethernet/sfc/mcdi_port_common.c
@@ -282,7 +282,7 @@ void efx_mcdi_phy_decode_link(struct efx_nic *efx,
 		break;
 	default:
 		WARN_ON(1);
-		/* Fall through */
+		fallthrough;
 	case MC_CMD_FCNTL_OFF:
 		link_state->fc = 0;
 		break;
diff --git a/drivers/net/ethernet/sfc/rx.c b/drivers/net/ethernet/sfc/rx.c
index f2fd9daac707..27246dfd95e0 100644
--- a/drivers/net/ethernet/sfc/rx.c
+++ b/drivers/net/ethernet/sfc/rx.c
@@ -358,7 +358,7 @@ static bool efx_do_xdp(struct efx_nic *efx, struct efx_channel *channel,
 
 	case XDP_ABORTED:
 		trace_xdp_exception(efx->net_dev, xdp_prog, xdp_act);
-		/* Fall through */
+		fallthrough;
 	case XDP_DROP:
 		efx_free_rx_buffers(rx_queue, rx_buf, 1);
 		channel->n_rx_xdp_drops++;
diff --git a/drivers/net/ethernet/sis/sis900.c b/drivers/net/ethernet/sis/sis900.c
index c50a8834f80e..3a98f77e86e8 100644
--- a/drivers/net/ethernet/sis/sis900.c
+++ b/drivers/net/ethernet/sis/sis900.c
@@ -2151,7 +2151,7 @@ static int mii_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd)
 	switch(cmd) {
 	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
 		data->phy_id = sis_priv->mii->phy_addr;
-		/* Fall Through */
+		fallthrough;
 
 	case SIOCGMIIREG:		/* Read MII PHY register. */
 		data->val_out = mdio_read(net_dev, data->phy_id & 0x1f, data->reg_num & 0x1f);
* Unmerged path drivers/net/ethernet/smsc/smc911x.c
* Unmerged path drivers/net/ethernet/socionext/netsec.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-anarion.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-anarion.c
index 85ce80c600c7..cc2d2bd83b3e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-anarion.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-anarion.c
@@ -82,9 +82,10 @@ static struct anarion_gmac *anarion_config_dt(struct platform_device *pdev)
 
 	phy_mode = of_get_phy_mode(pdev->dev.of_node);
 	switch (phy_mode) {
-	case PHY_INTERFACE_MODE_RGMII:		/* Fall through */
-	case PHY_INTERFACE_MODE_RGMII_ID	/* Fall through */:
-	case PHY_INTERFACE_MODE_RGMII_RXID:	/* Fall through */
+	case PHY_INTERFACE_MODE_RGMII:
+		fallthrough;
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
 	case PHY_INTERFACE_MODE_RGMII_TXID:
 		gmac->phy_intf_sel = GMAC_CONFIG_INTF_RGMII;
 		break;
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
index 225c833b2291..3cded17a764a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
@@ -228,7 +228,7 @@ static int tc_setup_cls_u32(struct stmmac_priv *priv,
 	switch (cls->command) {
 	case TC_CLSU32_REPLACE_KNODE:
 		tc_unfill_entry(priv, cls);
-		/* Fall through */
+		fallthrough;
 	case TC_CLSU32_NEW_KNODE:
 		return tc_config_knode(priv, cls);
 	case TC_CLSU32_DELETE_KNODE:
diff --git a/drivers/net/ethernet/sun/cassini.c b/drivers/net/ethernet/sun/cassini.c
index ef5ea865fc96..e6550f64a94d 100644
--- a/drivers/net/ethernet/sun/cassini.c
+++ b/drivers/net/ethernet/sun/cassini.c
@@ -4787,7 +4787,7 @@ static int cas_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	switch (cmd) {
 	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
 		data->phy_id = cp->phy_addr;
-		/* Fallthrough... */
+		fallthrough;
 
 	case SIOCGMIIREG:		/* Read MII PHY register. */
 		spin_lock_irqsave(&cp->lock, flags);
diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c
index 120a932ae896..a38681edcdf0 100644
--- a/drivers/net/ethernet/sun/niu.c
+++ b/drivers/net/ethernet/sun/niu.c
@@ -8846,7 +8846,7 @@ static int walk_phys(struct niu *np, struct niu_parent *parent)
 			else
 				goto unknown_vg_1g_port;
 
-			/* fallthru */
+			fallthrough;
 		case 0x22:
 			val = (phy_encode(PORT_TYPE_10G, 0) |
 			       phy_encode(PORT_TYPE_10G, 1) |
@@ -8871,7 +8871,7 @@ static int walk_phys(struct niu *np, struct niu_parent *parent)
 			else
 				goto unknown_vg_1g_port;
 
-			/* fallthru */
+			fallthrough;
 		case 0x13:
 			if ((lowest_10g & 0x7) == 0)
 				val = (phy_encode(PORT_TYPE_10G, 0) |
diff --git a/drivers/net/ethernet/sun/sungem.c b/drivers/net/ethernet/sun/sungem.c
index be0f868a619b..ba6cee6d134b 100644
--- a/drivers/net/ethernet/sun/sungem.c
+++ b/drivers/net/ethernet/sun/sungem.c
@@ -2709,7 +2709,7 @@ static int gem_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	switch (cmd) {
 	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
 		data->phy_id = gp->mii_phy_addr;
-		/* Fallthrough... */
+		fallthrough;
 
 	case SIOCGMIIREG:		/* Read MII PHY register. */
 		data->val_out = __sungem_phy_read(gp, data->phy_id & 0x1f,
diff --git a/drivers/net/ethernet/ti/cpsw-phy-sel.c b/drivers/net/ethernet/ti/cpsw-phy-sel.c
index dba1398a5d2b..54cd88eff36b 100644
--- a/drivers/net/ethernet/ti/cpsw-phy-sel.c
+++ b/drivers/net/ethernet/ti/cpsw-phy-sel.c
@@ -74,7 +74,7 @@ static void cpsw_gmii_sel_am3352(struct cpsw_phy_sel_priv *priv,
 		dev_warn(priv->dev,
 			 "Unsupported PHY mode: \"%s\". Defaulting to MII.\n",
 			phy_modes(phy_mode));
-		/* fallthrough */
+		fallthrough;
 	case PHY_INTERFACE_MODE_MII:
 		mode = AM33XX_GMII_SEL_MODE_MII;
 		break;
@@ -129,7 +129,7 @@ static void cpsw_gmii_sel_dra7xx(struct cpsw_phy_sel_priv *priv,
 		dev_warn(priv->dev,
 			 "Unsupported PHY mode: \"%s\". Defaulting to MII.\n",
 			phy_modes(phy_mode));
-		/* fallthrough */
+		fallthrough;
 	case PHY_INTERFACE_MODE_MII:
 		mode = AM33XX_GMII_SEL_MODE_MII;
 		break;
* Unmerged path drivers/net/ethernet/ti/cpsw_priv.c
* Unmerged path drivers/net/ethernet/ti/tlan.c
diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c
index 302079e22b06..e1464bec6051 100644
--- a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c
@@ -889,7 +889,7 @@ static int gelic_wl_set_auth(struct net_device *netdev,
 	case IW_AUTH_KEY_MGMT:
 		if (param->value & IW_AUTH_KEY_MGMT_PSK)
 			break;
-		/* intentionally fall through */
+		fallthrough;
 	default:
 		ret = -EOPNOTSUPP;
 		break;
* Unmerged path drivers/net/ethernet/toshiba/spider_net.c
diff --git a/drivers/net/ethernet/xircom/xirc2ps_cs.c b/drivers/net/ethernet/xircom/xirc2ps_cs.c
index 480ab7251515..61fd1bbbd3ad 100644
--- a/drivers/net/ethernet/xircom/xirc2ps_cs.c
+++ b/drivers/net/ethernet/xircom/xirc2ps_cs.c
@@ -1434,7 +1434,7 @@ do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
     switch(cmd) {
       case SIOCGMIIPHY:		/* Get the address of the PHY in use. */
 	data->phy_id = 0;	/* we have only this address */
-	/* fall through */
+	fallthrough;
       case SIOCGMIIREG:		/* Read the specified MII register. */
 	data->val_out = mii_rd(ioaddr, data->phy_id & 0x1f,
 			       data->reg_num & 0x1f);
* Unmerged path drivers/net/fddi/skfp/pcmplc.c
diff --git a/drivers/net/fjes/fjes_main.c b/drivers/net/fjes/fjes_main.c
index bcf21dfc6ce9..9f3963fe27d6 100644
--- a/drivers/net/fjes/fjes_main.c
+++ b/drivers/net/fjes/fjes_main.c
@@ -971,7 +971,7 @@ static void fjes_stop_req_irq(struct fjes_adapter *adapter, int src_epid)
 				FJES_RX_STOP_REQ_DONE;
 		spin_unlock_irqrestore(&hw->rx_status_lock, flags);
 		clear_bit(src_epid, &hw->txrx_stop_req_bit);
-		/* fall through */
+		fallthrough;
 	case EP_PARTNER_UNSHARE:
 	case EP_PARTNER_COMPLETE:
 	default:
* Unmerged path drivers/net/hamradio/baycom_epp.c
diff --git a/drivers/net/hamradio/mkiss.c b/drivers/net/hamradio/mkiss.c
index 13e4c1eff353..0a9dcacaf7cd 100644
--- a/drivers/net/hamradio/mkiss.c
+++ b/drivers/net/hamradio/mkiss.c
@@ -492,7 +492,7 @@ static void ax_encaps(struct net_device *dev, unsigned char *icp, int len)
 		case CRC_MODE_SMACK_TEST:
 			ax->crcmode  = CRC_MODE_FLEX_TEST;
 			printk(KERN_INFO "mkiss: %s: Trying crc-smack\n", ax->dev->name);
-			// fall through
+			fallthrough;
 		case CRC_MODE_SMACK:
 			*p |= 0x80;
 			crc = swab16(crc16(0, p, len));
@@ -501,7 +501,7 @@ static void ax_encaps(struct net_device *dev, unsigned char *icp, int len)
 		case CRC_MODE_FLEX_TEST:
 			ax->crcmode = CRC_MODE_NONE;
 			printk(KERN_INFO "mkiss: %s: Trying crc-flexnet\n", ax->dev->name);
-			// fall through
+			fallthrough;
 		case CRC_MODE_FLEX:
 			*p |= 0x20;
 			crc = calc_crc_flex(p, len);
@@ -754,7 +754,6 @@ static int mkiss_open(struct tty_struct *tty)
 		       ax->dev->name);
 		break;
 	case 0:
-		/* fall through */
 	default:
 		crc_force = 0;
 		printk(KERN_INFO "mkiss: %s: crc mode is auto.\n",
diff --git a/drivers/net/macvlan.c b/drivers/net/macvlan.c
index 1646944978a3..7a859c419330 100644
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@ -840,7 +840,7 @@ static int macvlan_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCSHWTSTAMP:
 		if (!net_eq(dev_net(dev), &init_net))
 			break;
-		/* fall through */
+		fallthrough;
 	case SIOCGHWTSTAMP:
 		if (netif_device_present(real_dev) && ops->ndo_do_ioctl)
 			err = ops->ndo_do_ioctl(real_dev, &ifrr, cmd);
diff --git a/drivers/net/mii.c b/drivers/net/mii.c
index 44612122338b..f6a97c859f3a 100644
--- a/drivers/net/mii.c
+++ b/drivers/net/mii.c
@@ -597,7 +597,7 @@ int generic_mii_ioctl(struct mii_if_info *mii_if,
 	switch(cmd) {
 	case SIOCGMIIPHY:
 		mii_data->phy_id = mii_if->phy_id;
-		/* fall through */
+		fallthrough;
 
 	case SIOCGMIIREG:
 		mii_data->val_out =
diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 7971dc4f54f1..0e9511661601 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -193,7 +193,7 @@ new_device_store(struct bus_type *bus, const char *buf, size_t count)
 	switch (err) {
 	case 1:
 		port_count = 1;
-		/* fall through */
+		fallthrough;
 	case 2:
 		if (id > INT_MAX) {
 			pr_err("Value of \"id\" is too big.\n");
diff --git a/drivers/net/netdevsim/fib.c b/drivers/net/netdevsim/fib.c
index fb3f12304ddb..ab046825d711 100644
--- a/drivers/net/netdevsim/fib.c
+++ b/drivers/net/netdevsim/fib.c
@@ -764,14 +764,14 @@ static int nsim_fib_event_nb(struct notifier_block *nb, unsigned long event,
 	spin_lock_bh(&data->fib_lock);
 
 	switch (event) {
-	case FIB_EVENT_RULE_ADD: /* fall through */
+	case FIB_EVENT_RULE_ADD:
 	case FIB_EVENT_RULE_DEL:
 		err = nsim_fib_rule_event(data, info,
 					  event == FIB_EVENT_RULE_ADD);
 		break;
 
-	case FIB_EVENT_ENTRY_REPLACE:  /* fall through */
-	case FIB_EVENT_ENTRY_APPEND:  /* fall through */
+	case FIB_EVENT_ENTRY_REPLACE:
+	case FIB_EVENT_ENTRY_APPEND:
 	case FIB_EVENT_ENTRY_DEL:
 		err = nsim_fib_event(data, info, event);
 		break;
diff --git a/drivers/net/phy/adin.c b/drivers/net/phy/adin.c
index 7471a8b90873..307f0ac1287b 100644
--- a/drivers/net/phy/adin.c
+++ b/drivers/net/phy/adin.c
@@ -366,10 +366,10 @@ static int adin_set_edpd(struct phy_device *phydev, u16 tx_interval)
 
 	switch (tx_interval) {
 	case 1000: /* 1 second */
-		/* fallthrough */
+		fallthrough;
 	case ETHTOOL_PHY_EDPD_DFLT_TX_MSECS:
 		val |= ADIN1300_NRG_PD_TX_EN;
-		/* fallthrough */
+		fallthrough;
 	case ETHTOOL_PHY_EDPD_NO_TX:
 		break;
 	default:
diff --git a/drivers/net/phy/dp83640.c b/drivers/net/phy/dp83640.c
index 50fb7d16b75a..79e67f2fe00a 100644
--- a/drivers/net/phy/dp83640.c
+++ b/drivers/net/phy/dp83640.c
@@ -766,13 +766,13 @@ static int decode_evnt(struct dp83640_private *dp83640,
 	switch (words) {
 	case 3:
 		dp83640->edata.sec_hi = phy_txts->sec_hi;
-		/* fall through */
+		fallthrough;
 	case 2:
 		dp83640->edata.sec_lo = phy_txts->sec_lo;
-		/* fall through */
+		fallthrough;
 	case 1:
 		dp83640->edata.ns_hi = phy_txts->ns_hi;
-		/* fall through */
+		fallthrough;
 	case 0:
 		dp83640->edata.ns_lo = phy_txts->ns_lo;
 	}
@@ -1409,7 +1409,7 @@ static void dp83640_txtstamp(struct mii_timestamper *mii_ts,
 			kfree_skb(skb);
 			return;
 		}
-		/* fall through */
+		fallthrough;
 	case HWTSTAMP_TX_ON:
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
 		skb_info->tmo = jiffies + SKB_TIMESTAMP_TIMEOUT;
diff --git a/drivers/net/phy/fixed_phy.c b/drivers/net/phy/fixed_phy.c
index c4641b1704d6..18d81f43f2a8 100644
--- a/drivers/net/phy/fixed_phy.c
+++ b/drivers/net/phy/fixed_phy.c
@@ -279,13 +279,13 @@ static struct phy_device *__fixed_phy_register(unsigned int irq,
 				 phy->supported);
 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
 				 phy->supported);
-		/* fall through */
+		fallthrough;
 	case SPEED_100:
 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
 				 phy->supported);
 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
 				 phy->supported);
-		/* fall through */
+		fallthrough;
 	case SPEED_10:
 	default:
 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index d101d2df9a09..c8a205eca03f 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -349,7 +349,7 @@ int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd)
 	switch (cmd) {
 	case SIOCGMIIPHY:
 		mii_data->phy_id = phydev->mdio.addr;
-		/* fall through */
+		fallthrough;
 
 	case SIOCGMIIREG:
 		if (mdio_phy_id_is_c45(mii_data->phy_id)) {
@@ -427,7 +427,7 @@ int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd)
 	case SIOCSHWTSTAMP:
 		if (phydev->mii_ts && phydev->mii_ts->hwtstamp)
 			return phydev->mii_ts->hwtstamp(phydev->mii_ts, ifr);
-		/* fall through */
+		fallthrough;
 
 	default:
 		return -EOPNOTSUPP;
* Unmerged path drivers/net/phy/phy_device.c
diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
index ae02f9650b4a..a02e584fca6e 100644
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@ -1744,7 +1744,7 @@ int phylink_mii_ioctl(struct phylink *pl, struct ifreq *ifr, int cmd)
 		switch (cmd) {
 		case SIOCGMIIPHY:
 			mii->phy_id = pl->phydev->mdio.addr;
-			/* fall through */
+			fallthrough;
 
 		case SIOCGMIIREG:
 			ret = phylink_phy_read(pl, mii->phy_id, mii->reg_num);
@@ -1767,7 +1767,7 @@ int phylink_mii_ioctl(struct phylink *pl, struct ifreq *ifr, int cmd)
 		switch (cmd) {
 		case SIOCGMIIPHY:
 			mii->phy_id = 0;
-			/* fall through */
+			fallthrough;
 
 		case SIOCGMIIREG:
 			ret = phylink_mii_read(pl, mii->phy_id, mii->reg_num);
diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
index c757cb89d601..2481c80e76d0 100644
--- a/drivers/net/phy/sfp-bus.c
+++ b/drivers/net/phy/sfp-bus.c
@@ -148,7 +148,7 @@ int sfp_parse_port(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
 			port = PORT_TP;
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	case SFF8024_CONNECTOR_SG: /* guess */
 	case SFF8024_CONNECTOR_HSSDC_II:
 	case SFF8024_CONNECTOR_NOSEPARATE:
@@ -300,7 +300,7 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
 		break;
 	case SFF8024_ECC_100GBASE_CR4:
 		phylink_set(modes, 100000baseCR4_Full);
-		/* fallthrough */
+		fallthrough;
 	case SFF8024_ECC_25GBASE_CR_S:
 	case SFF8024_ECC_25GBASE_CR_N:
 		phylink_set(modes, 25000baseCR_Full);
diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
index 73c2969f11a4..78af49127f3e 100644
--- a/drivers/net/phy/sfp.c
+++ b/drivers/net/phy/sfp.c
@@ -552,7 +552,7 @@ static umode_t sfp_hwmon_is_visible(const void *data,
 		case hwmon_temp_crit:
 			if (!(sfp->id.ext.enhopts & SFP_ENHOPTS_ALARMWARN))
 				return 0;
-			/* fall through */
+			fallthrough;
 		case hwmon_temp_input:
 		case hwmon_temp_label:
 			return 0444;
@@ -571,7 +571,7 @@ static umode_t sfp_hwmon_is_visible(const void *data,
 		case hwmon_in_crit:
 			if (!(sfp->id.ext.enhopts & SFP_ENHOPTS_ALARMWARN))
 				return 0;
-			/* fall through */
+			fallthrough;
 		case hwmon_in_input:
 		case hwmon_in_label:
 			return 0444;
@@ -590,7 +590,7 @@ static umode_t sfp_hwmon_is_visible(const void *data,
 		case hwmon_curr_crit:
 			if (!(sfp->id.ext.enhopts & SFP_ENHOPTS_ALARMWARN))
 				return 0;
-			/* fall through */
+			fallthrough;
 		case hwmon_curr_input:
 		case hwmon_curr_label:
 			return 0444;
@@ -618,7 +618,7 @@ static umode_t sfp_hwmon_is_visible(const void *data,
 		case hwmon_power_crit:
 			if (!(sfp->id.ext.enhopts & SFP_ENHOPTS_ALARMWARN))
 				return 0;
-			/* fall through */
+			fallthrough;
 		case hwmon_power_input:
 		case hwmon_power_label:
 			return 0444;
@@ -1828,7 +1828,7 @@ static void sfp_sm_module(struct sfp *sfp, unsigned int event)
 			dev_warn(sfp->dev, "hwmon probe failed: %d\n", err);
 
 		sfp_sm_mod_next(sfp, SFP_MOD_WAITDEV, 0);
-		/* fall through */
+		fallthrough;
 	case SFP_MOD_WAITDEV:
 		/* Ensure that the device is attached before proceeding */
 		if (sfp->sm_dev_state < SFP_DEV_DOWN)
@@ -1846,7 +1846,7 @@ static void sfp_sm_module(struct sfp *sfp, unsigned int event)
 			goto insert;
 
 		sfp_sm_mod_next(sfp, SFP_MOD_HPOWER, 0);
-		/* fall through */
+		fallthrough;
 	case SFP_MOD_HPOWER:
 		/* Enable high power mode */
 		err = sfp_sm_mod_hpower(sfp, true);
diff --git a/drivers/net/plip/plip.c b/drivers/net/plip/plip.c
index 3e3ac2e496a1..e8df4034c4d3 100644
--- a/drivers/net/plip/plip.c
+++ b/drivers/net/plip/plip.c
@@ -502,7 +502,7 @@ plip_receive(unsigned short nibble_timeout, struct net_device *dev,
 		*data_p = (c0 >> 3) & 0x0f;
 		write_data (dev, 0x10); /* send ACK */
 		*ns_p = PLIP_NB_1;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_NB_1:
 		cx = nibble_timeout;
@@ -598,7 +598,7 @@ plip_receive_packet(struct net_device *dev, struct net_local *nl,
 			printk(KERN_DEBUG "%s: receive start\n", dev->name);
 		rcv->state = PLIP_PK_LENGTH_LSB;
 		rcv->nibble = PLIP_NB_BEGIN;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_LENGTH_LSB:
 		if (snd->state != PLIP_PK_DONE) {
@@ -619,7 +619,7 @@ plip_receive_packet(struct net_device *dev, struct net_local *nl,
 				return TIMEOUT;
 		}
 		rcv->state = PLIP_PK_LENGTH_MSB;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_LENGTH_MSB:
 		if (plip_receive(nibble_timeout, dev,
@@ -642,7 +642,7 @@ plip_receive_packet(struct net_device *dev, struct net_local *nl,
 		rcv->state = PLIP_PK_DATA;
 		rcv->byte = 0;
 		rcv->checksum = 0;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_DATA:
 		lbuf = rcv->skb->data;
@@ -655,7 +655,7 @@ plip_receive_packet(struct net_device *dev, struct net_local *nl,
 			rcv->checksum += lbuf[--rcv->byte];
 		} while (rcv->byte);
 		rcv->state = PLIP_PK_CHECKSUM;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_CHECKSUM:
 		if (plip_receive(nibble_timeout, dev,
@@ -668,7 +668,7 @@ plip_receive_packet(struct net_device *dev, struct net_local *nl,
 			return ERROR;
 		}
 		rcv->state = PLIP_PK_DONE;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_DONE:
 		/* Inform the upper layer for the arrival of a packet. */
@@ -714,7 +714,7 @@ plip_send(unsigned short nibble_timeout, struct net_device *dev,
 	case PLIP_NB_BEGIN:
 		write_data (dev, data & 0x0f);
 		*ns_p = PLIP_NB_1;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_NB_1:
 		write_data (dev, 0x10 | (data & 0x0f));
@@ -729,7 +729,7 @@ plip_send(unsigned short nibble_timeout, struct net_device *dev,
 		}
 		write_data (dev, 0x10 | (data >> 4));
 		*ns_p = PLIP_NB_2;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_NB_2:
 		write_data (dev, (data >> 4));
@@ -818,7 +818,7 @@ plip_send_packet(struct net_device *dev, struct net_local *nl,
 			      &snd->nibble, snd->length.b.lsb))
 			return TIMEOUT;
 		snd->state = PLIP_PK_LENGTH_MSB;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_LENGTH_MSB:
 		if (plip_send(nibble_timeout, dev,
@@ -827,7 +827,7 @@ plip_send_packet(struct net_device *dev, struct net_local *nl,
 		snd->state = PLIP_PK_DATA;
 		snd->byte = 0;
 		snd->checksum = 0;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_DATA:
 		do {
@@ -839,7 +839,7 @@ plip_send_packet(struct net_device *dev, struct net_local *nl,
 			snd->checksum += lbuf[--snd->byte];
 		} while (snd->byte);
 		snd->state = PLIP_PK_CHECKSUM;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_CHECKSUM:
 		if (plip_send(nibble_timeout, dev,
@@ -850,7 +850,7 @@ plip_send_packet(struct net_device *dev, struct net_local *nl,
 		dev_kfree_skb(snd->skb);
 		dev->stats.tx_packets++;
 		snd->state = PLIP_PK_DONE;
-		/* fall through */
+		fallthrough;
 
 	case PLIP_PK_DONE:
 		/* Close the connection */
@@ -939,7 +939,7 @@ plip_interrupt(void *dev_id)
 	switch (nl->connection) {
 	case PLIP_CN_CLOSING:
 		netif_wake_queue (dev);
-		/* fall through */
+		fallthrough;
 	case PLIP_CN_NONE:
 	case PLIP_CN_SEND:
 		rcv->state = PLIP_PK_TRIGGER;
diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 46a36a86564d..8a8b9aebb56a 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1686,10 +1686,10 @@ static int tun_xdp_act(struct tun_struct *tun, struct bpf_prog *xdp_prog,
 		break;
 	default:
 		bpf_warn_invalid_xdp_action(act);
-		/* fall through */
+		fallthrough;
 	case XDP_ABORTED:
 		trace_xdp_exception(tun->dev, xdp_prog, act);
-		/* fall through */
+		fallthrough;
 	case XDP_DROP:
 		this_cpu_inc(tun->pcpu_stats->rx_dropped);
 		break;
@@ -2495,7 +2495,7 @@ static int tun_xdp_one(struct tun_struct *tun,
 		switch (err) {
 		case XDP_REDIRECT:
 			*flush = true;
-			/* fall through */
+			fallthrough;
 		case XDP_TX:
 			return 0;
 		case XDP_PASS:
diff --git a/drivers/net/usb/aqc111.c b/drivers/net/usb/aqc111.c
index 7e44110746dd..0717c18015c9 100644
--- a/drivers/net/usb/aqc111.c
+++ b/drivers/net/usb/aqc111.c
@@ -333,13 +333,13 @@ static void aqc111_set_phy_speed(struct usbnet *dev, u8 autoneg, u16 speed)
 		switch (speed) {
 		case SPEED_5000:
 			aqc111_data->phy_cfg |= AQ_ADV_5G;
-			/* fall-through */
+			fallthrough;
 		case SPEED_2500:
 			aqc111_data->phy_cfg |= AQ_ADV_2G5;
-			/* fall-through */
+			fallthrough;
 		case SPEED_1000:
 			aqc111_data->phy_cfg |= AQ_ADV_1G;
-			/* fall-through */
+			fallthrough;
 		case SPEED_100:
 			aqc111_data->phy_cfg |= AQ_ADV_100M;
 			/* fall-through */
diff --git a/drivers/net/usb/catc.c b/drivers/net/usb/catc.c
index 1bb5a82f05be..6a605c34f976 100644
--- a/drivers/net/usb/catc.c
+++ b/drivers/net/usb/catc.c
@@ -869,7 +869,7 @@ static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
 		default:
 			dev_warn(&intf->dev,
 				 "Couldn't detect memory size, assuming 32k\n");
-			/* fall through */
+			fallthrough;
 		case 0x87654321:
 			catc_set_reg(catc, TxBufCount, 4);
 			catc_set_reg(catc, RxBufCount, 16);
diff --git a/drivers/net/usb/cdc-phonet.c b/drivers/net/usb/cdc-phonet.c
index 63aaae487995..3d92a637289f 100644
--- a/drivers/net/usb/cdc-phonet.c
+++ b/drivers/net/usb/cdc-phonet.c
@@ -110,7 +110,7 @@ static void tx_complete(struct urb *req)
 	case -ECONNRESET:
 	case -ESHUTDOWN:
 		dev->stats.tx_aborted_errors++;
-		/* fall through */
+		fallthrough;
 	default:
 		dev->stats.tx_errors++;
 		dev_dbg(&dev->dev, "TX error (%d)\n", status);
diff --git a/drivers/net/usb/lan78xx.c b/drivers/net/usb/lan78xx.c
index e82baa75103d..d9492b7fd0df 100644
--- a/drivers/net/usb/lan78xx.c
+++ b/drivers/net/usb/lan78xx.c
@@ -3278,7 +3278,7 @@ static void rx_complete(struct urb *urb)
 	case -EPIPE:
 		dev->net->stats.rx_errors++;
 		lan78xx_defer_kevent(dev, EVENT_RX_HALT);
-		/* FALLTHROUGH */
+		fallthrough;
 	case -ECONNRESET:				/* async unlink */
 	case -ESHUTDOWN:				/* hardware gone */
 		netif_dbg(dev, ifdown, dev->net,
@@ -3299,7 +3299,7 @@ static void rx_complete(struct urb *urb)
 	/* data overrun ... flush fifo? */
 	case -EOVERFLOW:
 		dev->net->stats.rx_over_errors++;
-		/* FALLTHROUGH */
+		fallthrough;
 
 	default:
 		state = rx_cleanup;
diff --git a/drivers/net/usb/pegasus.c b/drivers/net/usb/pegasus.c
index 09bed0c449a7..3369e564d1e5 100644
--- a/drivers/net/usb/pegasus.c
+++ b/drivers/net/usb/pegasus.c
@@ -631,7 +631,7 @@ static void write_bulk_callback(struct urb *urb)
 		return;
 	default:
 		netif_info(pegasus, tx_err, net, "TX status %d\n", status);
-		/* FALL THROUGH */
+		fallthrough;
 	case 0:
 		break;
 	}
@@ -1011,7 +1011,7 @@ static int pegasus_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
 	switch (cmd) {
 	case SIOCDEVPRIVATE:
 		data[0] = pegasus->phy;
-		/* fall through */
+		fallthrough;
 	case SIOCDEVPRIVATE + 1:
 		read_mii_word(pegasus, data[0], data[1] & 0x1f, &data[3]);
 		res = 0;
* Unmerged path drivers/net/usb/r8152.c
diff --git a/drivers/net/usb/rtl8150.c b/drivers/net/usb/rtl8150.c
index d0a180411e36..185749f761c9 100644
--- a/drivers/net/usb/rtl8150.c
+++ b/drivers/net/usb/rtl8150.c
@@ -847,7 +847,7 @@ static int rtl8150_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
 	switch (cmd) {
 	case SIOCDEVPRIVATE:
 		data[0] = dev->phy;
-		/* fall through */
+		fallthrough;
 	case SIOCDEVPRIVATE + 1:
 		read_mii_word(dev, dev->phy, (data[1] & 0x1f), &data[3]);
 		break;
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index ff1709d9e1c9..626b6e2960a4 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -117,7 +117,7 @@ int usbnet_get_endpoints(struct usbnet *dev, struct usb_interface *intf)
 				if (!usb_endpoint_dir_in(&e->desc))
 					continue;
 				intr = 1;
-				/* FALLTHROUGH */
+				fallthrough;
 			case USB_ENDPOINT_XFER_BULK:
 				break;
 			default:
@@ -632,7 +632,7 @@ static void rx_complete (struct urb *urb)
 	/* data overrun ... flush fifo? */
 	case -EOVERFLOW:
 		dev->net->stats.rx_over_errors++;
-		// FALLTHROUGH
+		fallthrough;
 
 	default:
 		state = rx_cleanup;
@@ -1533,7 +1533,7 @@ static void usbnet_bh (struct timer_list *t)
 			continue;
 		case tx_done:
 			kfree(entry->urb->sg);
-			/* fall through */
+			fallthrough;
 		case rx_cleanup:
 			usb_free_urb (entry->urb);
 			dev_kfree_skb (skb);
diff --git a/drivers/net/veth.c b/drivers/net/veth.c
index f79981fcbb64..209c1dae96c5 100644
--- a/drivers/net/veth.c
+++ b/drivers/net/veth.c
@@ -630,10 +630,10 @@ static struct sk_buff *veth_xdp_rcv_one(struct veth_rq *rq,
 			goto xdp_xmit;
 		default:
 			bpf_warn_invalid_xdp_action(act);
-			/* fall through */
+			fallthrough;
 		case XDP_ABORTED:
 			trace_xdp_exception(rq->dev, xdp_prog, act);
-			/* fall through */
+			fallthrough;
 		case XDP_DROP:
 			stats->xdp_drops++;
 			goto err_xdp;
@@ -765,10 +765,10 @@ static struct sk_buff *veth_xdp_rcv_skb(struct veth_rq *rq,
 		goto xdp_xmit;
 	default:
 		bpf_warn_invalid_xdp_action(act);
-		/* fall through */
+		fallthrough;
 	case XDP_ABORTED:
 		trace_xdp_exception(rq->dev, xdp_prog, act);
-		/* fall through */
+		fallthrough;
 	case XDP_DROP:
 		stats->xdp_drops++;
 		goto xdp_drop;
* Unmerged path drivers/net/virtio_net.c
diff --git a/drivers/net/vmxnet3/vmxnet3_ethtool.c b/drivers/net/vmxnet3/vmxnet3_ethtool.c
index 358667792004..7ec8652f2c26 100644
--- a/drivers/net/vmxnet3/vmxnet3_ethtool.c
+++ b/drivers/net/vmxnet3/vmxnet3_ethtool.c
@@ -771,7 +771,7 @@ vmxnet3_get_rss_hash_opts(struct vmxnet3_adapter *adapter,
 	case ESP_V4_FLOW:
 		if (rss_fields & VMXNET3_RSS_FIELDS_ESPIP4)
 			info->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
-			/* fallthrough */
+		fallthrough;
 	case SCTP_V4_FLOW:
 	case IPV4_FLOW:
 		info->data |= RXH_IP_SRC | RXH_IP_DST;
diff --git a/drivers/net/wan/lapbether.c b/drivers/net/wan/lapbether.c
index 0e3f8ed84660..da20a6737de8 100644
--- a/drivers/net/wan/lapbether.c
+++ b/drivers/net/wan/lapbether.c
@@ -170,7 +170,7 @@ static netdev_tx_t lapbeth_xmit(struct sk_buff *skb,
 	case X25_IFACE_DISCONNECT:
 		if ((err = lapb_disconnect_request(dev)) != LAPB_OK)
 			pr_err("lapb_disconnect_request err: %d\n", err);
-		/* Fall thru */
+		fallthrough;
 	default:
 		goto drop;
 	}
* Unmerged path drivers/net/wan/sdla.c
diff --git a/drivers/net/wan/x25_asy.c b/drivers/net/wan/x25_asy.c
index cbc39f7b11a1..8a2ddea3fe22 100644
--- a/drivers/net/wan/x25_asy.c
+++ b/drivers/net/wan/x25_asy.c
@@ -324,7 +324,7 @@ static netdev_tx_t x25_asy_xmit(struct sk_buff *skb,
 		if (err != LAPB_OK)
 			netdev_err(dev, "lapb_disconnect_request error: %d\n",
 				   err);
-		/* fall through */
+		fallthrough;
 	default:
 		kfree_skb(skb);
 		return NETDEV_TX_OK;
* Unmerged path drivers/net/wimax/i2400m/control.c
* Unmerged path drivers/net/wimax/i2400m/usb-fw.c
* Unmerged path drivers/net/wimax/i2400m/usb-tx.c
* Unmerged path drivers/net/wimax/i2400m/usb.c
diff --git a/drivers/net/xen-netback/hash.c b/drivers/net/xen-netback/hash.c
index 3c4c58b9fe76..0060d3411d80 100644
--- a/drivers/net/xen-netback/hash.c
+++ b/drivers/net/xen-netback/hash.c
@@ -372,7 +372,7 @@ void xenvif_dump_hash_info(struct xenvif *vif, struct seq_file *m)
 
 	case XEN_NETIF_CTRL_HASH_ALGORITHM_NONE:
 		seq_puts(m, "Hash Algorithm: NONE\n");
-		/* FALLTHRU */
+		fallthrough;
 	default:
 		return;
 	}
* Unmerged path drivers/net/xen-netback/xenbus.c
* Unmerged path drivers/net/xen-netfront.c
* Unmerged path drivers/nfc/pn533/pn533.c
* Unmerged path drivers/nfc/st21nfca/dep.c
diff --git a/drivers/nfc/trf7970a.c b/drivers/nfc/trf7970a.c
index eee5cc1a9220..25b12fa4407a 100644
--- a/drivers/nfc/trf7970a.c
+++ b/drivers/nfc/trf7970a.c
@@ -1156,7 +1156,7 @@ static int trf7970a_switch_rf(struct nfc_digital_dev *ddev, bool on)
 			dev_err(trf->dev, "%s - Invalid request: %d %d\n",
 				__func__, trf->state, on);
 			ret = -EINVAL;
-			/* FALLTHROUGH */
+			fallthrough;
 		case TRF7970A_ST_IDLE:
 		case TRF7970A_ST_IDLE_RX_BLOCKED:
 		case TRF7970A_ST_WAIT_FOR_RX_DATA:
@@ -1963,7 +1963,7 @@ static void trf7970a_shutdown(struct trf7970a *trf)
 	case TRF7970A_ST_WAIT_TO_ISSUE_EOF:
 	case TRF7970A_ST_LISTENING:
 		trf7970a_send_err_upstream(trf, -ECANCELED);
-		/* FALLTHROUGH */
+		fallthrough;
 	case TRF7970A_ST_IDLE:
 	case TRF7970A_ST_IDLE_RX_BLOCKED:
 		trf7970a_switch_rf_off(trf);
diff --git a/drivers/ntb/ntb_transport.c b/drivers/ntb/ntb_transport.c
index e6d1f5b298f3..4a02561cfb96 100644
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@ -1483,7 +1483,7 @@ static void ntb_rx_copy_callback(void *data,
 		case DMA_TRANS_READ_FAILED:
 		case DMA_TRANS_WRITE_FAILED:
 			entry->errors++;
-			/* fall through */
+			fallthrough;
 		case DMA_TRANS_ABORTED:
 		{
 			struct ntb_transport_qp *qp = entry->qp;
@@ -1739,7 +1739,7 @@ static void ntb_tx_copy_callback(void *data,
 		case DMA_TRANS_READ_FAILED:
 		case DMA_TRANS_WRITE_FAILED:
 			entry->errors++;
-			/* fall through */
+			fallthrough;
 		case DMA_TRANS_ABORTED:
 		{
 			void __iomem *offset =
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index 56077bfa2566..37529a0c5905 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -382,7 +382,7 @@ bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
 		case NVME_CTRL_RESETTING:
 		case NVME_CTRL_CONNECTING:
 			changed = true;
-			/* FALLTHRU */
+			fallthrough;
 		default:
 			break;
 		}
@@ -392,7 +392,7 @@ bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
 		case NVME_CTRL_NEW:
 		case NVME_CTRL_LIVE:
 			changed = true;
-			/* FALLTHRU */
+			fallthrough;
 		default:
 			break;
 		}
@@ -402,7 +402,7 @@ bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
 		case NVME_CTRL_NEW:
 		case NVME_CTRL_RESETTING:
 			changed = true;
-			/* FALLTHRU */
+			fallthrough;
 		default:
 			break;
 		}
@@ -413,7 +413,7 @@ bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
 		case NVME_CTRL_RESETTING:
 		case NVME_CTRL_CONNECTING:
 			changed = true;
-			/* FALLTHRU */
+			fallthrough;
 		default:
 			break;
 		}
@@ -423,7 +423,7 @@ bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
 		case NVME_CTRL_DELETING:
 		case NVME_CTRL_DEAD:
 			changed = true;
-			/* FALLTHRU */
+			fallthrough;
 		default:
 			break;
 		}
@@ -432,7 +432,7 @@ bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
 		switch (old_state) {
 		case NVME_CTRL_DELETING:
 			changed = true;
-			/* FALLTHRU */
+			fallthrough;
 		default:
 			break;
 		}
diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index 7f9b2e8eb7eb..217e6cbc09f2 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -1209,7 +1209,7 @@ static enum blk_eh_timer_return nvme_timeout(struct request *req, bool reserved)
 	switch (dev->ctrl.state) {
 	case NVME_CTRL_CONNECTING:
 		nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_DELETING);
-		/* fall through */
+		fallthrough;
 	case NVME_CTRL_DELETING:
 		dev_warn_ratelimited(dev->ctrl.device,
 			 "I/O %d QID %d timeout, disable controller\n",
diff --git a/drivers/nvme/host/rdma.c b/drivers/nvme/host/rdma.c
index b3e2b13b46fe..aac32d89da62 100644
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@ -1938,7 +1938,7 @@ static int nvme_rdma_cm_handler(struct rdma_cm_id *cm_id,
 	case RDMA_CM_EVENT_CONNECT_ERROR:
 	case RDMA_CM_EVENT_UNREACHABLE:
 		nvme_rdma_destroy_queue_ib(queue);
-		/* fall through */
+		fallthrough;
 	case RDMA_CM_EVENT_ADDR_ERROR:
 		dev_dbg(queue->ctrl->ctrl.device,
 			"CM error event %d\n", ev->event);
diff --git a/drivers/nvme/host/tcp.c b/drivers/nvme/host/tcp.c
index bf1c3e2bb6ff..b60448f49588 100644
--- a/drivers/nvme/host/tcp.c
+++ b/drivers/nvme/host/tcp.c
@@ -865,7 +865,6 @@ static void nvme_tcp_state_change(struct sock *sk)
 	case TCP_LAST_ACK:
 	case TCP_FIN_WAIT1:
 	case TCP_FIN_WAIT2:
-		/* fallthrough */
 		nvme_tcp_error_recovery(&queue->ctrl->ctrl);
 		break;
 	default:
diff --git a/drivers/nvme/target/core.c b/drivers/nvme/target/core.c
index e4d90c6fda08..041f14657898 100644
--- a/drivers/nvme/target/core.c
+++ b/drivers/nvme/target/core.c
@@ -81,7 +81,7 @@ inline u16 errno_to_nvme_status(struct nvmet_req *req, int errno)
 		status = NVME_SC_ACCESS_DENIED;
 		break;
 	case -EIO:
-		/* FALLTHRU */
+		fallthrough;
 	default:
 		req->error_loc = offsetof(struct nvme_common_command, opcode);
 		status = NVME_SC_INTERNAL | NVME_SC_DNR;
diff --git a/drivers/nvme/target/fcloop.c b/drivers/nvme/target/fcloop.c
index c885057a8e76..b4abe3e36bb1 100644
--- a/drivers/nvme/target/fcloop.c
+++ b/drivers/nvme/target/fcloop.c
@@ -823,7 +823,7 @@ fcloop_fcp_op(struct nvmet_fc_target_port *tgtport,
 			break;
 
 		/* Fall-Thru to RSP handling */
-		/* FALLTHRU */
+		fallthrough;
 
 	case NVMET_FCOP_RSP:
 		if (fcpreq) {
diff --git a/drivers/nvme/target/io-cmd-bdev.c b/drivers/nvme/target/io-cmd-bdev.c
index e9337b9327ca..e2e09d01c442 100644
--- a/drivers/nvme/target/io-cmd-bdev.c
+++ b/drivers/nvme/target/io-cmd-bdev.c
@@ -147,7 +147,6 @@ static u16 blk_to_nvme_status(struct nvmet_req *req, blk_status_t blk_sts)
 		req->error_loc = offsetof(struct nvme_rw_command, nsid);
 		break;
 	case BLK_STS_IOERR:
-		/* fallthru */
 	default:
 		status = NVME_SC_INTERNAL | NVME_SC_DNR;
 		req->error_loc = offsetof(struct nvme_common_command, opcode);
diff --git a/drivers/nvme/target/rdma.c b/drivers/nvme/target/rdma.c
index 16359fae3927..243f8735060f 100644
--- a/drivers/nvme/target/rdma.c
+++ b/drivers/nvme/target/rdma.c
@@ -1661,7 +1661,7 @@ static int nvmet_rdma_cm_handler(struct rdma_cm_id *cm_id,
 			schedule_delayed_work(&port->repair_work, 0);
 			break;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case RDMA_CM_EVENT_DISCONNECTED:
 	case RDMA_CM_EVENT_TIMEWAIT_EXIT:
 		nvmet_rdma_queue_disconnect(queue);
@@ -1672,7 +1672,7 @@ static int nvmet_rdma_cm_handler(struct rdma_cm_id *cm_id,
 	case RDMA_CM_EVENT_REJECTED:
 		pr_debug("Connection rejected: %s\n",
 			 rdma_reject_msg(cm_id, event->status));
-		/* FALLTHROUGH */
+		fallthrough;
 	case RDMA_CM_EVENT_UNREACHABLE:
 	case RDMA_CM_EVENT_CONNECT_ERROR:
 		nvmet_rdma_queue_connect_fail(cm_id, queue);
* Unmerged path drivers/parport/ieee1284.c
* Unmerged path drivers/parport/parport_pc.c
* Unmerged path drivers/pci/controller/dwc/pci-imx6.c
* Unmerged path drivers/pci/controller/pci-rcar-gen2.c
diff --git a/drivers/pci/hotplug/ibmphp_res.c b/drivers/pci/hotplug/ibmphp_res.c
index 5c93aa14f0de..ae9acc77d14f 100644
--- a/drivers/pci/hotplug/ibmphp_res.c
+++ b/drivers/pci/hotplug/ibmphp_res.c
@@ -1941,7 +1941,7 @@ static int __init update_bridge_ranges(struct bus_node **bus)
 						break;
 					case PCI_HEADER_TYPE_BRIDGE:
 						function = 0x8;
-						/* fall through */
+						fallthrough;
 					case PCI_HEADER_TYPE_MULTIBRIDGE:
 						/* We assume here that only 1 bus behind the bridge
 						   TO DO: add functionality for several:
diff --git a/drivers/pci/hotplug/pciehp_ctrl.c b/drivers/pci/hotplug/pciehp_ctrl.c
index 6503d15effbb..9f85815b4f53 100644
--- a/drivers/pci/hotplug/pciehp_ctrl.c
+++ b/drivers/pci/hotplug/pciehp_ctrl.c
@@ -236,7 +236,7 @@ void pciehp_handle_presence_or_link_change(struct controller *ctrl, u32 events)
 	switch (ctrl->state) {
 	case BLINKINGOFF_STATE:
 		cancel_delayed_work(&ctrl->button_work);
-		/* fall through */
+		fallthrough;
 	case ON_STATE:
 		ctrl->state = POWEROFF_STATE;
 		mutex_unlock(&ctrl->state_lock);
@@ -265,7 +265,7 @@ void pciehp_handle_presence_or_link_change(struct controller *ctrl, u32 events)
 	switch (ctrl->state) {
 	case BLINKINGON_STATE:
 		cancel_delayed_work(&ctrl->button_work);
-		/* fall through */
+		fallthrough;
 	case OFF_STATE:
 		ctrl->state = POWERON_STATE;
 		mutex_unlock(&ctrl->state_lock);
diff --git a/drivers/pci/hotplug/shpchp_ctrl.c b/drivers/pci/hotplug/shpchp_ctrl.c
index afdc52d1cae7..65502e3f7b4f 100644
--- a/drivers/pci/hotplug/shpchp_ctrl.c
+++ b/drivers/pci/hotplug/shpchp_ctrl.c
@@ -642,7 +642,7 @@ int shpchp_sysfs_enable_slot(struct slot *p_slot)
 	switch (p_slot->state) {
 	case BLINKINGON_STATE:
 		cancel_delayed_work(&p_slot->work);
-		/* fall through */
+		fallthrough;
 	case STATIC_STATE:
 		p_slot->state = POWERON_STATE;
 		mutex_unlock(&p_slot->lock);
@@ -678,7 +678,7 @@ int shpchp_sysfs_disable_slot(struct slot *p_slot)
 	switch (p_slot->state) {
 	case BLINKINGOFF_STATE:
 		cancel_delayed_work(&p_slot->work);
-		/* fall through */
+		fallthrough;
 	case STATIC_STATE:
 		p_slot->state = POWEROFF_STATE;
 		mutex_unlock(&p_slot->lock);
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 025336a6e511..96f123839959 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -921,7 +921,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot
 		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
 			need_restore = true;
-		/* Fall-through - force to D0 */
+		fallthrough;	/* force to D0 */
 	default:
 		pmcsr = 0;
 		break;
@@ -2413,7 +2413,7 @@ static pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)
 		case PCI_D2:
 			if (pci_no_d1d2(dev))
 				break;
-			/* else, fall through */
+			fallthrough;
 		default:
 			target_state = state;
 		}
diff --git a/drivers/pci/proc.c b/drivers/pci/proc.c
index 7c96c64519bd..e50121e3d839 100644
--- a/drivers/pci/proc.c
+++ b/drivers/pci/proc.c
@@ -228,7 +228,7 @@ static long proc_bus_pci_ioctl(struct file *file, unsigned int cmd,
 		}
 		/* If arch decided it can't, fall through... */
 #endif /* HAVE_PCI_MMAP */
-		/* fall through */
+		fallthrough;
 	default:
 		ret = -EINVAL;
 		break;
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 0599c88d8388..619f7d93ae43 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -1698,7 +1698,7 @@ static void quirk_jmicron_ata(struct pci_dev *pdev)
 	case PCI_DEVICE_ID_JMICRON_JMB366:
 		/* Redirect IDE second PATA port to the right spot */
 		conf5 |= (1 << 24);
-		/* Fall through */
+		fallthrough;
 	case PCI_DEVICE_ID_JMICRON_JMB361:
 	case PCI_DEVICE_ID_JMICRON_JMB363:
 	case PCI_DEVICE_ID_JMICRON_JMB369:
@@ -2192,7 +2192,7 @@ static void quirk_netmos(struct pci_dev *dev)
 		if (dev->subsystem_vendor == PCI_VENDOR_ID_IBM &&
 				dev->subsystem_device == 0x0299)
 			return;
-		/* else, fall through */
+		fallthrough;
 	case PCI_DEVICE_ID_NETMOS_9735:
 	case PCI_DEVICE_ID_NETMOS_9745:
 	case PCI_DEVICE_ID_NETMOS_9845:
diff --git a/drivers/pci/setup-bus.c b/drivers/pci/setup-bus.c
index 07cd7a3817dc..4ecfe8bbd89c 100644
--- a/drivers/pci/setup-bus.c
+++ b/drivers/pci/setup-bus.c
@@ -1251,7 +1251,7 @@ void __pci_bus_size_bridges(struct pci_bus *bus, struct list_head *realloc_head)
 			additional_mmio_size = pci_hotplug_mmio_size;
 			additional_mmio_pref_size = pci_hotplug_mmio_pref_size;
 		}
-		/* Fall through */
+		fallthrough;
 	default:
 		pbus_size_io(bus, realloc_head ? 0 : additional_io_size,
 			     additional_io_size, realloc_head);
diff --git a/drivers/pci/xen-pcifront.c b/drivers/pci/xen-pcifront.c
index d1b16cf3403f..093ab898341f 100644
--- a/drivers/pci/xen-pcifront.c
+++ b/drivers/pci/xen-pcifront.c
@@ -1103,7 +1103,7 @@ static void __ref pcifront_backend_changed(struct xenbus_device *xdev,
 	case XenbusStateClosed:
 		if (xdev->state == XenbusStateClosed)
 			break;
-		/* fall through - Missed the backend's CLOSING state. */
+		fallthrough;	/* Missed the backend's CLOSING state */
 	case XenbusStateClosing:
 		dev_warn(&xdev->dev, "backend going away!\n");
 		pcifront_try_disconnect(pdev);
* Unmerged path drivers/pcmcia/db1xxx_ss.c
diff --git a/drivers/perf/arm-ccn.c b/drivers/perf/arm-ccn.c
index b416ee18e6bb..8f65a189d8a3 100644
--- a/drivers/perf/arm-ccn.c
+++ b/drivers/perf/arm-ccn.c
@@ -1411,7 +1411,7 @@ static int arm_ccn_init_nodes(struct arm_ccn *ccn, int region,
 		break;
 	case CCN_TYPE_SBAS:
 		ccn->sbas_present = 1;
-		/* Fall-through */
+		fallthrough;
 	default:
 		component = &ccn->node[id];
 		break;
diff --git a/drivers/perf/arm_spe_pmu.c b/drivers/perf/arm_spe_pmu.c
index 4fb65c61c8ea..8633f2b51013 100644
--- a/drivers/perf/arm_spe_pmu.c
+++ b/drivers/perf/arm_spe_pmu.c
@@ -1013,7 +1013,7 @@ static void __arm_spe_pmu_dev_probe(void *info)
 	default:
 		dev_warn(dev, "unknown PMSIDR_EL1.Interval [%d]; assuming 8\n",
 			 fld);
-		/* Fallthrough */
+		fallthrough;
 	case 8:
 		spe_pmu->min_period = 4096;
 	}
@@ -1032,7 +1032,7 @@ static void __arm_spe_pmu_dev_probe(void *info)
 	default:
 		dev_warn(dev, "unknown PMSIDR_EL1.CountSize [%d]; assuming 2\n",
 			 fld);
-		/* Fallthrough */
+		fallthrough;
 	case 2:
 		spe_pmu->counter_sz = 12;
 	}
* Unmerged path drivers/phy/qualcomm/phy-qcom-usb-hs.c
diff --git a/drivers/phy/rockchip/phy-rockchip-inno-usb2.c b/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
index 5049dac79bd0..1f6a7810b19b 100644
--- a/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
+++ b/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
@@ -560,7 +560,7 @@ static void rockchip_usb2phy_otg_sm_work(struct work_struct *work)
 		rport->state = OTG_STATE_B_IDLE;
 		if (!vbus_attach)
 			rockchip_usb2phy_power_off(rport->phy);
-		/* fall through */
+		fallthrough;
 	case OTG_STATE_B_IDLE:
 		if (extcon_get_state(rphy->edev, EXTCON_USB_HOST) > 0) {
 			dev_dbg(&rport->phy->dev, "usb otg host connect\n");
@@ -768,11 +768,11 @@ static void rockchip_chg_detect_work(struct work_struct *work)
 			rphy->chg_type = POWER_SUPPLY_TYPE_USB_DCP;
 		else
 			rphy->chg_type = POWER_SUPPLY_TYPE_USB_CDP;
-		/* fall through */
+		fallthrough;
 	case USB_CHG_STATE_SECONDARY_DONE:
 		rphy->chg_state = USB_CHG_STATE_DETECTED;
 		delay = 0;
-		/* fall through */
+		fallthrough;
 	case USB_CHG_STATE_DETECTED:
 		/* put the controller in normal mode */
 		property_enable(base, &rphy->phy_cfg->chg_det.opmode, true);
@@ -849,7 +849,7 @@ static void rockchip_usb2phy_sm_work(struct work_struct *work)
 			dev_dbg(&rport->phy->dev, "FS/LS online\n");
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case PHY_STATE_CONNECT:
 		if (rport->suspended) {
 			dev_dbg(&rport->phy->dev, "Connected\n");
* Unmerged path drivers/platform/olpc/olpc-xo175-ec.c
* Unmerged path drivers/platform/x86/acer-wmi.c
* Unmerged path drivers/platform/x86/dell-laptop.c
diff --git a/drivers/platform/x86/surfacepro3_button.c b/drivers/platform/x86/surfacepro3_button.c
index 1b491690ce07..f204f65b2173 100644
--- a/drivers/platform/x86/surfacepro3_button.c
+++ b/drivers/platform/x86/surfacepro3_button.c
@@ -82,28 +82,28 @@ static void surface_button_notify(struct acpi_device *device, u32 event)
 	/* Power button press,release handle */
 	case SURFACE_BUTTON_NOTIFY_PRESS_POWER:
 		pressed = true;
-		/*fall through*/
+		fallthrough;
 	case SURFACE_BUTTON_NOTIFY_RELEASE_POWER:
 		key_code = KEY_POWER;
 		break;
 	/* Home button press,release handle */
 	case SURFACE_BUTTON_NOTIFY_PRESS_HOME:
 		pressed = true;
-		/*fall through*/
+		fallthrough;
 	case SURFACE_BUTTON_NOTIFY_RELEASE_HOME:
 		key_code = KEY_LEFTMETA;
 		break;
 	/* Volume up button press,release handle */
 	case SURFACE_BUTTON_NOTIFY_PRESS_VOLUME_UP:
 		pressed = true;
-		/*fall through*/
+		fallthrough;
 	case SURFACE_BUTTON_NOTIFY_RELEASE_VOLUME_UP:
 		key_code = KEY_VOLUMEUP;
 		break;
 	/* Volume down button press,release handle */
 	case SURFACE_BUTTON_NOTIFY_PRESS_VOLUME_DOWN:
 		pressed = true;
-		/*fall through*/
+		fallthrough;
 	case SURFACE_BUTTON_NOTIFY_RELEASE_VOLUME_DOWN:
 		key_code = KEY_VOLUMEDOWN;
 		break;
* Unmerged path drivers/platform/x86/thinkpad_acpi.c
diff --git a/drivers/platform/x86/toshiba_acpi.c b/drivers/platform/x86/toshiba_acpi.c
index eef76bfa5d73..b34c087e5e55 100644
--- a/drivers/platform/x86/toshiba_acpi.c
+++ b/drivers/platform/x86/toshiba_acpi.c
@@ -2763,7 +2763,7 @@ static void toshiba_acpi_process_hotkeys(struct toshiba_acpi_dev *dev)
 				result = hci_write(dev, HCI_SYSTEM_EVENT, 1);
 				if (result == TOS_SUCCESS)
 					pr_notice("Re-enabled hotkeys\n");
-				/* Fall through */
+				fallthrough;
 			default:
 				retries--;
 				break;
* Unmerged path drivers/power/supply/ab8500_charger.c
diff --git a/drivers/power/supply/ab8500_fg.c b/drivers/power/supply/ab8500_fg.c
index d9c6c7bedd85..a391a395be09 100644
--- a/drivers/power/supply/ab8500_fg.c
+++ b/drivers/power/supply/ab8500_fg.c
@@ -1544,7 +1544,7 @@ static void ab8500_fg_algorithm_discharging(struct ab8500_fg *di)
 		ab8500_fg_discharge_state_to(di,
 			AB8500_FG_DISCHARGE_INITMEASURING);
 
-		/* Intentional fallthrough */
+		fallthrough;
 	case AB8500_FG_DISCHARGE_INITMEASURING:
 		/*
 		 * Discard a number of samples during startup.
@@ -1574,7 +1574,7 @@ static void ab8500_fg_algorithm_discharging(struct ab8500_fg *di)
 		ab8500_fg_discharge_state_to(di,
 			AB8500_FG_DISCHARGE_RECOVERY);
 
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case AB8500_FG_DISCHARGE_RECOVERY:
 		sleep_time = di->bm->fg_params->recovery_sleep_timer;
diff --git a/drivers/power/supply/abx500_chargalg.c b/drivers/power/supply/abx500_chargalg.c
index 947709cdd14e..771123fda35a 100644
--- a/drivers/power/supply/abx500_chargalg.c
+++ b/drivers/power/supply/abx500_chargalg.c
@@ -1419,7 +1419,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 		abx500_chargalg_stop_charging(di);
 		di->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;
 		abx500_chargalg_state_to(di, STATE_HANDHELD);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_HANDHELD:
 		break;
@@ -1435,7 +1435,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 		di->maintenance_chg = false;
 		abx500_chargalg_state_to(di, STATE_SUSPENDED);
 		power_supply_changed(di->chargalg_psy);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_SUSPENDED:
 		/* CHARGING is suspended */
@@ -1444,7 +1444,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 	case STATE_BATT_REMOVED_INIT:
 		abx500_chargalg_stop_charging(di);
 		abx500_chargalg_state_to(di, STATE_BATT_REMOVED);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_BATT_REMOVED:
 		if (!di->events.batt_rem)
@@ -1454,7 +1454,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 	case STATE_HW_TEMP_PROTECT_INIT:
 		abx500_chargalg_stop_charging(di);
 		abx500_chargalg_state_to(di, STATE_HW_TEMP_PROTECT);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_HW_TEMP_PROTECT:
 		if (!di->events.main_thermal_prot &&
@@ -1465,7 +1465,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 	case STATE_OVV_PROTECT_INIT:
 		abx500_chargalg_stop_charging(di);
 		abx500_chargalg_state_to(di, STATE_OVV_PROTECT);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_OVV_PROTECT:
 		if (!di->events.vbus_ovv &&
@@ -1479,7 +1479,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 	case STATE_CHG_NOT_OK_INIT:
 		abx500_chargalg_stop_charging(di);
 		abx500_chargalg_state_to(di, STATE_CHG_NOT_OK);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_CHG_NOT_OK:
 		if (!di->events.mainextchnotok &&
@@ -1490,7 +1490,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 	case STATE_SAFETY_TIMER_EXPIRED_INIT:
 		abx500_chargalg_stop_charging(di);
 		abx500_chargalg_state_to(di, STATE_SAFETY_TIMER_EXPIRED);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_SAFETY_TIMER_EXPIRED:
 		/* We exit this state when charger is removed */
@@ -1537,7 +1537,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 	case STATE_WAIT_FOR_RECHARGE_INIT:
 		abx500_chargalg_hold_charging(di);
 		abx500_chargalg_state_to(di, STATE_WAIT_FOR_RECHARGE);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_WAIT_FOR_RECHARGE:
 		if (di->batt_data.percent <=
@@ -1558,7 +1558,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 				di->bm->batt_id].maint_a_cur_lvl);
 		abx500_chargalg_state_to(di, STATE_MAINTENANCE_A);
 		power_supply_changed(di->chargalg_psy);
-		/* Intentional fallthrough*/
+		fallthrough;
 
 	case STATE_MAINTENANCE_A:
 		if (di->events.maintenance_timer_expired) {
@@ -1578,7 +1578,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 				di->bm->batt_id].maint_b_cur_lvl);
 		abx500_chargalg_state_to(di, STATE_MAINTENANCE_B);
 		power_supply_changed(di->chargalg_psy);
-		/* Intentional fallthrough*/
+		fallthrough;
 
 	case STATE_MAINTENANCE_B:
 		if (di->events.maintenance_timer_expired) {
@@ -1597,7 +1597,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 		di->charge_status = POWER_SUPPLY_STATUS_CHARGING;
 		abx500_chargalg_state_to(di, STATE_TEMP_LOWHIGH);
 		power_supply_changed(di->chargalg_psy);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_TEMP_LOWHIGH:
 		if (!di->events.btemp_lowhigh)
@@ -1607,7 +1607,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 	case STATE_WD_EXPIRED_INIT:
 		abx500_chargalg_stop_charging(di);
 		abx500_chargalg_state_to(di, STATE_WD_EXPIRED);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_WD_EXPIRED:
 		if (!di->events.ac_wd_expired &&
@@ -1618,7 +1618,7 @@ static void abx500_chargalg_algorithm(struct abx500_chargalg *di)
 	case STATE_TEMP_UNDEROVER_INIT:
 		abx500_chargalg_stop_charging(di);
 		abx500_chargalg_state_to(di, STATE_TEMP_UNDEROVER);
-		/* Intentional fallthrough */
+		fallthrough;
 
 	case STATE_TEMP_UNDEROVER:
 		if (!di->events.btemp_underover)
* Unmerged path drivers/power/supply/axp20x_usb_power.c
* Unmerged path drivers/power/supply/cros_usbpd-charger.c
* Unmerged path drivers/power/supply/max8925_power.c
diff --git a/drivers/power/supply/wm831x_power.c b/drivers/power/supply/wm831x_power.c
index 927050d4444d..3889ef541bbc 100644
--- a/drivers/power/supply/wm831x_power.c
+++ b/drivers/power/supply/wm831x_power.c
@@ -668,7 +668,7 @@ static int wm831x_power_probe(struct platform_device *pdev)
 		break;
 	default:
 		dev_err(&pdev->dev, "Failed to find USB phy: %d\n", ret);
-		/* fall-through */
+		fallthrough;
 	case -EPROBE_DEFER:
 		goto err_bat_irq;
 		break;
* Unmerged path drivers/power/supply/wm8350_power.c
diff --git a/drivers/ps3/ps3av.c b/drivers/ps3/ps3av.c
index e293606b0334..b7e668b74dc7 100644
--- a/drivers/ps3/ps3av.c
+++ b/drivers/ps3/ps3av.c
@@ -781,7 +781,7 @@ static int ps3av_auto_videomode(struct ps3av_pkt_av_get_hw_conf *av_hw_conf)
 		switch (info->monitor_type) {
 		case PS3AV_MONITOR_TYPE_DVI:
 			dvi = PS3AV_MODE_DVI;
-			/* fall through */
+			fallthrough;
 		case PS3AV_MONITOR_TYPE_HDMI:
 			id = ps3av_hdmi_get_id(info);
 			break;
diff --git a/drivers/ps3/ps3av_cmd.c b/drivers/ps3/ps3av_cmd.c
index f555fedd5073..ff037bb61717 100644
--- a/drivers/ps3/ps3av_cmd.c
+++ b/drivers/ps3/ps3av_cmd.c
@@ -705,11 +705,11 @@ void ps3av_cmd_set_audio_mode(struct ps3av_pkt_audio_mode *audio, u32 avport,
 	switch (ch) {
 	case PS3AV_CMD_AUDIO_NUM_OF_CH_8:
 		audio->audio_enable[3] = 1;
-		/* fall through */
+		fallthrough;
 	case PS3AV_CMD_AUDIO_NUM_OF_CH_6:
 		audio->audio_enable[2] = 1;
 		audio->audio_enable[1] = 1;
-		/* fall through */
+		fallthrough;
 	case PS3AV_CMD_AUDIO_NUM_OF_CH_2:
 	default:
 		audio->audio_enable[0] = 1;
* Unmerged path drivers/rapidio/devices/rio_mport_cdev.c
* Unmerged path drivers/regulator/axp20x-regulator.c
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 35027ec36830..246d9cbcc274 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1688,7 +1688,7 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 		case EXCLUSIVE_GET:
 			dev_warn(dev,
 				 "dummy supplies not allowed for exclusive requests\n");
-			/* fall through */
+			fallthrough;
 
 		default:
 			return ERR_PTR(-ENODEV);
* Unmerged path drivers/regulator/slg51000-regulator.c
diff --git a/drivers/regulator/twl6030-regulator.c b/drivers/regulator/twl6030-regulator.c
index 219cbd910dbf..7dfd698799cb 100644
--- a/drivers/regulator/twl6030-regulator.c
+++ b/drivers/regulator/twl6030-regulator.c
@@ -330,7 +330,7 @@ static int twl6030smps_list_voltage(struct regulator_dev *rdev, unsigned index)
 	switch (info->flags) {
 	case SMPS_OFFSET_EN:
 		voltage = 100000;
-		/* fall through */
+		fallthrough;
 	case 0:
 		switch (index) {
 		case 0:
* Unmerged path drivers/remoteproc/omap_remoteproc.c
* Unmerged path drivers/reset/reset-imx7.c
diff --git a/drivers/rpmsg/qcom_glink_native.c b/drivers/rpmsg/qcom_glink_native.c
index f505f58b797d..241add1e0133 100644
--- a/drivers/rpmsg/qcom_glink_native.c
+++ b/drivers/rpmsg/qcom_glink_native.c
@@ -527,7 +527,7 @@ static void qcom_glink_receive_version(struct qcom_glink *glink,
 		break;
 	case GLINK_VERSION_1:
 		glink->features &= features;
-		/* FALLTHROUGH */
+		fallthrough;
 	default:
 		qcom_glink_send_version_ack(glink);
 		break;
@@ -558,7 +558,7 @@ static void qcom_glink_receive_version_ack(struct qcom_glink *glink,
 			break;
 
 		glink->features &= features;
-		/* FALLTHROUGH */
+		fallthrough;
 	default:
 		qcom_glink_send_version(glink);
 		break;
* Unmerged path drivers/rtc/rtc-m41t80.c
* Unmerged path drivers/rtc/rtc-pcf85063.c
* Unmerged path drivers/rtc/rtc-pcf8523.c
diff --git a/drivers/rtc/rtc-stmp3xxx.c b/drivers/rtc/rtc-stmp3xxx.c
index d578e40d5a50..42d54a61b3a5 100644
--- a/drivers/rtc/rtc-stmp3xxx.c
+++ b/drivers/rtc/rtc-stmp3xxx.c
@@ -329,7 +329,7 @@ static int stmp3xxx_rtc_probe(struct platform_device *pdev)
 	default:
 		dev_warn(&pdev->dev,
 			 "invalid crystal-freq specified in device-tree. Assuming no crystal\n");
-		/* fall-through */
+		fallthrough;
 	case 0:
 		/* keep XTAL on in low-power mode */
 		pers0_set = STMP3XXX_RTC_PERSISTENT0_XTAL24MHZ_PWRUP;
diff --git a/drivers/s390/net/ctcm_fsms.c b/drivers/s390/net/ctcm_fsms.c
index 4a8a5373cb35..2c9a3e3c545c 100644
--- a/drivers/s390/net/ctcm_fsms.c
+++ b/drivers/s390/net/ctcm_fsms.c
@@ -1704,7 +1704,7 @@ static void ctcmpc_chx_attnbusy(fsm_instance *fsm, int event, void *arg)
 			grp->changed_side = 2;
 			break;
 		}
-		/* Else, fall through */
+		fallthrough;
 	case MPCG_STATE_XID0IOWAIX:
 	case MPCG_STATE_XID7INITW:
 	case MPCG_STATE_XID7INITX:
diff --git a/drivers/s390/net/ctcm_mpc.c b/drivers/s390/net/ctcm_mpc.c
index 1534420a0243..ae151bfbdbe4 100644
--- a/drivers/s390/net/ctcm_mpc.c
+++ b/drivers/s390/net/ctcm_mpc.c
@@ -357,7 +357,7 @@ int ctc_mpc_alloc_channel(int port_num, void (*callback)(int, int))
 		/*fsm_newstate(grp->fsm, MPCG_STATE_XID2INITW);*/
 		if (callback)
 			grp->send_qllc_disc = 1;
-		/* Else, fall through */
+		fallthrough;
 	case MPCG_STATE_XID0IOWAIT:
 		fsm_deltimer(&grp->timer);
 		grp->outstanding_xid2 = 0;
@@ -1470,7 +1470,7 @@ static void mpc_action_timeout(fsm_instance *fi, int event, void *arg)
 		if ((fsm_getstate(rch->fsm) == CH_XID0_PENDING) &&
 		   (fsm_getstate(wch->fsm) == CH_XID0_PENDING))
 			break;
-		/* Else, fall through */
+		fallthrough;
 	default:
 		fsm_event(grp->fsm, MPCG_EVENT_INOP, dev);
 	}
@@ -2091,7 +2091,7 @@ static int mpc_send_qllc_discontact(struct net_device *dev)
 			grp->estconnfunc = NULL;
 			break;
 		}
-		/* Else, fall through */
+		fallthrough;
 	case MPCG_STATE_FLOWC:
 	case MPCG_STATE_READY:
 		grp->send_qllc_disc = 2;
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 543f78a58fff..a1c27918b257 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -1006,7 +1006,7 @@ static void qeth_issue_next_read_cb(struct qeth_card *card,
 		break;
 	case -EIO:
 		qeth_schedule_recovery(card);
-		/* fall through */
+		fallthrough;
 	default:
 		qeth_clear_ipacmd_list(card);
 		goto err_idx;
@@ -2814,7 +2814,7 @@ void qeth_print_status_message(struct qeth_card *card)
 				card->info.mcl_level[3]);
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	case QETH_CARD_TYPE_IQD:
 		if (IS_VM_NIC(card) || (card->info.mcl_level[0] & 0x80)) {
 			card->info.mcl_level[0] = (char) _ebcasc[(__u8)
diff --git a/drivers/s390/net/qeth_ethtool.c b/drivers/s390/net/qeth_ethtool.c
index 0bf3125280f6..7e4b6f34fd70 100644
--- a/drivers/s390/net/qeth_ethtool.c
+++ b/drivers/s390/net/qeth_ethtool.c
@@ -217,7 +217,7 @@ static void qeth_set_cmd_adv_sup(struct ethtool_link_ksettings *cmd,
 						     10000baseT_Full);
 		ethtool_link_ksettings_add_link_mode(cmd, advertising,
 						     10000baseT_Full);
-		/* fall through */
+		fallthrough;
 	case SPEED_1000:
 		ethtool_link_ksettings_add_link_mode(cmd, supported,
 						     1000baseT_Full);
@@ -227,7 +227,7 @@ static void qeth_set_cmd_adv_sup(struct ethtool_link_ksettings *cmd,
 						     1000baseT_Half);
 		ethtool_link_ksettings_add_link_mode(cmd, advertising,
 						     1000baseT_Half);
-		/* fall through */
+		fallthrough;
 	case SPEED_100:
 		ethtool_link_ksettings_add_link_mode(cmd, supported,
 						     100baseT_Full);
@@ -237,7 +237,7 @@ static void qeth_set_cmd_adv_sup(struct ethtool_link_ksettings *cmd,
 						     100baseT_Half);
 		ethtool_link_ksettings_add_link_mode(cmd, advertising,
 						     100baseT_Half);
-		/* fall through */
+		fallthrough;
 	case SPEED_10:
 		ethtool_link_ksettings_add_link_mode(cmd, supported,
 						     10baseT_Full);
diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c
index a7ade5374389..3f949312c364 100644
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -531,7 +531,7 @@ static void qeth_l2_rx_mode_work(struct work_struct *work)
 				kfree(mac);
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		default:
 			/* for next call to set_rx_mode(): */
 			mac->disp_flag = QETH_DISP_ADDR_DELETE;
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index fe24844e0953..2ffe0f310114 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -1333,7 +1333,7 @@ static void qeth_l3_rx_mode_work(struct work_struct *work)
 					break;
 				}
 				addr->ref_counter = 1;
-				/* fall through */
+				fallthrough;
 			default:
 				/* for next call to set_rx_mode(): */
 				addr->disp_flag = QETH_DISP_ADDR_DELETE;
diff --git a/drivers/scsi/53c700.c b/drivers/scsi/53c700.c
index 6be77b3aa8a5..e55349ad206b 100644
--- a/drivers/scsi/53c700.c
+++ b/drivers/scsi/53c700.c
@@ -1845,7 +1845,7 @@ NCR_700_queuecommand_lck(struct scsi_cmnd *SCp, void (*done)(struct scsi_cmnd *)
 	case REQUEST_SENSE:
 		/* clear the internal sense magic */
 		SCp->cmnd[6] = 0;
-		/* fall through */
+		fallthrough;
 	default:
 		/* OK, get it from the command */
 		switch(SCp->sc_data_direction) {
* Unmerged path drivers/scsi/BusLogic.c
diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 867b864f5047..6e2e8c599952 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -1034,11 +1034,14 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)
 			temp6 >>= 1;
 			switch (temp & 0x3) {
 			case AUTO_RATE_20:	/* Synchronous, 20 mega-transfers/second */
-				temp6 |= 0x8000;	/* Fall through */
+				temp6 |= 0x8000;
+				fallthrough;
 			case AUTO_RATE_10:	/* Synchronous, 10 mega-transfers/second */
-				temp5 |= 0x8000;	/* Fall through */
+				temp5 |= 0x8000;
+				fallthrough;
 			case AUTO_RATE_05:	/* Synchronous, 5 mega-transfers/second */
-				temp2 |= 0x8000;	/* Fall through */
+				temp2 |= 0x8000;
+				fallthrough;
 			case AUTO_RATE_00:	/* Asynchronous */
 				break;
 			}
* Unmerged path drivers/scsi/NCR5380.c
* Unmerged path drivers/scsi/aacraid/aachba.c
diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c
index d62ddd63f4fe..68dc220c30ea 100644
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -1443,7 +1443,7 @@ static void aac_handle_aif(struct aac_dev * dev, struct fib * fibptr)
 						"enclosure services event");
 				scsi_device_set_state(device, SDEV_RUNNING);
 			}
-			/* FALLTHRU */
+			fallthrough;
 		case CHANGE:
 			if ((channel == CONTAINER_CHANNEL)
 			 && (!dev->fsa_dev[container].valid)) {
* Unmerged path drivers/scsi/aacraid/linit.c
* Unmerged path drivers/scsi/aic7xxx/aic79xx_core.c
diff --git a/drivers/scsi/aic7xxx/aic79xx_osm.c b/drivers/scsi/aic7xxx/aic79xx_osm.c
index d03ad1e36f5e..04dd3ecbd6ca 100644
--- a/drivers/scsi/aic7xxx/aic79xx_osm.c
+++ b/drivers/scsi/aic7xxx/aic79xx_osm.c
@@ -2040,7 +2040,7 @@ ahd_linux_queue_cmd_complete(struct ahd_softc *ahd, struct scsi_cmnd *cmd)
 		break;
 	case CAM_AUTOSENSE_FAIL:
 		new_status = DID_ERROR;
-		/* Fallthrough */
+		fallthrough;
 	case CAM_SCSI_STATUS_ERROR:
 		scsi_status = ahd_cmd_get_scsi_status(cmd);
 
* Unmerged path drivers/scsi/aic7xxx/aic7xxx_core.c
* Unmerged path drivers/scsi/aic94xx/aic94xx_scb.c
diff --git a/drivers/scsi/aic94xx/aic94xx_tmf.c b/drivers/scsi/aic94xx/aic94xx_tmf.c
index 2a01702d5ba7..26d3b0652149 100644
--- a/drivers/scsi/aic94xx/aic94xx_tmf.c
+++ b/drivers/scsi/aic94xx/aic94xx_tmf.c
@@ -508,7 +508,7 @@ int asd_abort_task(struct sas_task *task)
 		switch (tcs.dl_opcode) {
 		default:
 			res = asd_clear_nexus(task);
-			/* fallthrough */
+			fallthrough;
 		case TC_NO_ERROR:
 			break;
 			/* The task hasn't been sent to the device xor
diff --git a/drivers/scsi/arcmsr/arcmsr_hba.c b/drivers/scsi/arcmsr/arcmsr_hba.c
index 6bdc50e13eef..687a3b7d4b03 100644
--- a/drivers/scsi/arcmsr/arcmsr_hba.c
+++ b/drivers/scsi/arcmsr/arcmsr_hba.c
@@ -4371,7 +4371,7 @@ static const char *arcmsr_info(struct Scsi_Host *host)
 	case PCI_DEVICE_ID_ARECA_1202:
 	case PCI_DEVICE_ID_ARECA_1210:
 		raid6 = 0;
-		/*FALLTHRU*/
+		fallthrough;
 	case PCI_DEVICE_ID_ARECA_1120:
 	case PCI_DEVICE_ID_ARECA_1130:
 	case PCI_DEVICE_ID_ARECA_1160:
* Unmerged path drivers/scsi/arm/fas216.c
diff --git a/drivers/scsi/be2iscsi/be_iscsi.c b/drivers/scsi/be2iscsi/be_iscsi.c
index ed1bd369baa0..327dbfbfa0de 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -679,7 +679,7 @@ int beiscsi_set_param(struct iscsi_cls_conn *cls_conn,
 	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
 		if (conn->max_xmit_dlength > 65536)
 			conn->max_xmit_dlength = 65536;
-		/* fall through */
+		fallthrough;
 	default:
 		return 0;
 	}
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index 8537cf78b1d2..d00a7351a764 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -1534,7 +1534,7 @@ beiscsi_hdl_get_handle(struct beiscsi_conn *beiscsi_conn,
 		break;
 	case UNSOL_DATA_DIGEST_ERROR_NOTIFY:
 		error = 1;
-		/* fall through */
+		fallthrough;
 	case UNSOL_DATA_NOTIFY:
 		pasync_handle = pasync_ctx->async_entry[ci].data;
 		break;
* Unmerged path drivers/scsi/bfa/bfa_fcpim.c
* Unmerged path drivers/scsi/bfa/bfa_fcs_lport.c
* Unmerged path drivers/scsi/bfa/bfa_fcs_rport.c
* Unmerged path drivers/scsi/bfa/bfa_ioc.c
diff --git a/drivers/scsi/bfa/bfa_svc.c b/drivers/scsi/bfa/bfa_svc.c
index 6fc34fb20f00..f939d998a9bf 100644
--- a/drivers/scsi/bfa/bfa_svc.c
+++ b/drivers/scsi/bfa/bfa_svc.c
@@ -6408,7 +6408,7 @@ bfa_dport_sm_starting(struct bfa_dport_s *dport, enum bfa_dport_sm_event event)
 			dport->test_state = BFA_DPORT_ST_INP;
 			bfa_dport_result_start(dport, BFA_DPORT_OPMODE_MANU);
 		}
-		/* fall thru */
+		fallthrough;
 
 	case BFA_DPORT_SM_REQFAIL:
 		bfa_sm_set_state(dport, bfa_dport_sm_enabled);
diff --git a/drivers/scsi/bnx2fc/bnx2fc_hwi.c b/drivers/scsi/bnx2fc/bnx2fc_hwi.c
index e65d5b185e34..3eab3bf76426 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_hwi.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_hwi.c
@@ -1410,7 +1410,6 @@ void bnx2fc_indicate_kcqe(void *context, struct kcqe *kcq[],
 			break;
 
 		case FCOE_KCQE_OPCODE_FCOE_ERROR:
-			/* fall thru */
 		default:
 			printk(KERN_ERR PFX "unknown opcode 0x%x\n",
 								kcqe->op_code);
diff --git a/drivers/scsi/csiostor/csio_hw.c b/drivers/scsi/csiostor/csio_hw.c
index e51923886475..0ac62cbd2743 100644
--- a/drivers/scsi/csiostor/csio_hw.c
+++ b/drivers/scsi/csiostor/csio_hw.c
@@ -2939,7 +2939,7 @@ csio_hws_quiescing(struct csio_hw *hw, enum csio_hw_ev evt)
 		case CSIO_HWE_FW_DLOAD:
 			csio_set_state(&hw->sm, csio_hws_resetting);
 			/* Download firmware */
-			/* Fall through */
+			fallthrough;
 
 		case CSIO_HWE_HBA_RESET:
 			csio_set_state(&hw->sm, csio_hws_resetting);
diff --git a/drivers/scsi/csiostor/csio_lnode.c b/drivers/scsi/csiostor/csio_lnode.c
index 66e58f0a75dc..4e951fb9e63e 100644
--- a/drivers/scsi/csiostor/csio_lnode.c
+++ b/drivers/scsi/csiostor/csio_lnode.c
@@ -1184,7 +1184,6 @@ csio_lns_online(struct csio_lnode *ln, enum csio_ln_ev evt)
 		break;
 
 	case CSIO_LNE_LINK_DOWN:
-		/* Fall through */
 	case CSIO_LNE_DOWN_LINK:
 		csio_set_state(&ln->sm, csio_lns_uninit);
 		if (csio_is_phys_ln(ln)) {
* Unmerged path drivers/scsi/csiostor/csio_wr.c
diff --git a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
index acfcfb4a8832..6c2ae41b3cfd 100644
--- a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
+++ b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
@@ -645,7 +645,7 @@ static int abort_status_to_errno(struct cxgbi_sock *csk, int abort_reason,
 				 int *need_rst)
 {
 	switch (abort_reason) {
-	case CPL_ERR_BAD_SYN: /* fall through */
+	case CPL_ERR_BAD_SYN:
 	case CPL_ERR_CONN_RESET:
 		return csk->state > CTP_ESTABLISHED ? -EPIPE : -ECONNRESET;
 	case CPL_ERR_XMIT_TIMEDOUT:
diff --git a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
index 57927ebdd047..cc8078fce537 100644
--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
@@ -1053,7 +1053,7 @@ static int abort_status_to_errno(struct cxgbi_sock *csk, int abort_reason,
 								int *need_rst)
 {
 	switch (abort_reason) {
-	case CPL_ERR_BAD_SYN: /* fall through */
+	case CPL_ERR_BAD_SYN:
 	case CPL_ERR_CONN_RESET:
 		return csk->state > CTP_ESTABLISHED ?
 			-EPIPE : -ECONNRESET;
* Unmerged path drivers/scsi/cxlflash/main.c
diff --git a/drivers/scsi/cxlflash/superpipe.c b/drivers/scsi/cxlflash/superpipe.c
index acac6152f50b..fcbb59d81e98 100644
--- a/drivers/scsi/cxlflash/superpipe.c
+++ b/drivers/scsi/cxlflash/superpipe.c
@@ -379,14 +379,13 @@ static int read_cap16(struct scsi_device *sdev, struct llun_info *lli)
 			switch (sshdr.sense_key) {
 			case NO_SENSE:
 			case RECOVERED_ERROR:
-				/* fall through */
 			case NOT_READY:
 				result &= ~SAM_STAT_CHECK_CONDITION;
 				break;
 			case UNIT_ATTENTION:
 				switch (sshdr.asc) {
 				case 0x29: /* Power on Reset or Device Reset */
-					/* fall through */
+					fallthrough;
 				case 0x2A: /* Device capacity changed */
 				case 0x3F: /* Report LUNs changed */
 					/* Retry the command once more */
@@ -1795,13 +1794,12 @@ static int process_sense(struct scsi_device *sdev,
 	switch (sshdr.sense_key) {
 	case NO_SENSE:
 	case RECOVERED_ERROR:
-		/* fall through */
 	case NOT_READY:
 		break;
 	case UNIT_ATTENTION:
 		switch (sshdr.asc) {
 		case 0x29: /* Power on Reset or Device Reset */
-			/* fall through */
+			fallthrough;
 		case 0x2A: /* Device settings/capacity changed */
 			rc = read_cap16(sdev, lli);
 			if (rc) {
@@ -2161,7 +2159,7 @@ int cxlflash_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 		if (unlikely(rc))
 			goto cxlflash_ioctl_exit;
 
-		/* fall through */
+		fallthrough;
 
 	case DK_CXLFLASH_MANAGE_LUN:
 		known_ioctl = true;
@@ -2172,7 +2170,7 @@ int cxlflash_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 		if (likely(do_ioctl))
 			break;
 
-		/* fall through */
+		fallthrough;
 	default:
 		rc = -EINVAL;
 		goto cxlflash_ioctl_exit;
diff --git a/drivers/scsi/device_handler/scsi_dh_hp_sw.c b/drivers/scsi/device_handler/scsi_dh_hp_sw.c
index 80129b033855..ae802cc64874 100644
--- a/drivers/scsi/device_handler/scsi_dh_hp_sw.c
+++ b/drivers/scsi/device_handler/scsi_dh_hp_sw.c
@@ -73,7 +73,7 @@ static int tur_done(struct scsi_device *sdev, struct hp_sw_dh_data *h,
 			ret = SCSI_DH_OK;
 			break;
 		}
-		/* Fallthrough */
+		fallthrough;
 	default:
 		sdev_printk(KERN_WARNING, sdev,
 			   "%s: sending tur failed, sense %x/%x/%x\n",
@@ -160,7 +160,7 @@ static int hp_sw_start_stop(struct hp_sw_dh_data *h)
 				rc = SCSI_DH_RETRY;
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		default:
 			sdev_printk(KERN_WARNING, sdev,
 				    "%s: sending start_stop_unit failed, "
diff --git a/drivers/scsi/esas2r/esas2r_flash.c b/drivers/scsi/esas2r/esas2r_flash.c
index 7bd376d95ed5..30a9f8c04fdd 100644
--- a/drivers/scsi/esas2r/esas2r_flash.c
+++ b/drivers/scsi/esas2r/esas2r_flash.c
@@ -1499,7 +1499,7 @@ bool esas2r_fm_api(struct esas2r_adapter *a, struct esas2r_flash_img *fi,
 			return complete_fmapi_req(a, rq, FI_STAT_SUCCESS);
 		}
 
-	/* fall through */
+		fallthrough;
 
 	case FI_ACT_UP: /* Upload the components */
 	default:
* Unmerged path drivers/scsi/esas2r/esas2r_init.c
diff --git a/drivers/scsi/esp_scsi.c b/drivers/scsi/esp_scsi.c
index c3fc34b9964d..59d62a3c342d 100644
--- a/drivers/scsi/esp_scsi.c
+++ b/drivers/scsi/esp_scsi.c
@@ -303,7 +303,7 @@ static void esp_reset_esp(struct esp *esp)
 
 	case FASHME:
 		esp->config2 |= (ESP_CONFIG2_HME32 | ESP_CONFIG2_HMEFENAB);
-		/* fallthrough... */
+		fallthrough;
 
 	case FAS236:
 	case PCSCSI:
@@ -1736,7 +1736,7 @@ static int esp_process_event(struct esp *esp)
 
 	case ESP_EVENT_DATA_IN:
 		write = 1;
-		/* fallthru */
+		fallthrough;
 
 	case ESP_EVENT_DATA_OUT: {
 		struct esp_cmd_entry *ent = esp->active_cmd;
diff --git a/drivers/scsi/fcoe/fcoe_ctlr.c b/drivers/scsi/fcoe/fcoe_ctlr.c
index cdaac121e441..0dd98da2879e 100644
--- a/drivers/scsi/fcoe/fcoe_ctlr.c
+++ b/drivers/scsi/fcoe/fcoe_ctlr.c
@@ -447,10 +447,10 @@ void fcoe_ctlr_link_up(struct fcoe_ctlr *fip)
 		switch (fip->mode) {
 		default:
 			LIBFCOE_FIP_DBG(fip, "invalid mode %d\n", fip->mode);
-			/* fall-through */
+			fallthrough;
 		case FIP_MODE_AUTO:
 			LIBFCOE_FIP_DBG(fip, "%s", "setting AUTO mode.\n");
-			/* fall-through */
+			fallthrough;
 		case FIP_MODE_FABRIC:
 		case FIP_MODE_NON_FIP:
 			mutex_unlock(&fip->ctlr_mutex);
@@ -770,7 +770,7 @@ int fcoe_ctlr_els_send(struct fcoe_ctlr *fip, struct fc_lport *lport,
 			fc_fcoe_set_mac(mac, fh->fh_d_id);
 			fip->update_mac(lport, mac);
 		}
-		/* fall through */
+		fallthrough;
 	case ELS_LS_RJT:
 		op = fr_encaps(fp);
 		if (op)
@@ -2436,7 +2436,7 @@ static void fcoe_ctlr_vn_probe_req(struct fcoe_ctlr *fip,
 					  frport->enode_mac, 0);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case FIP_ST_VNMP_START:
 		LIBFCOE_FIP_DBG(fip, "vn_probe_req: "
 				"restart VN2VN negotiation\n");
diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index fc538181f8df..4651db375192 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -339,7 +339,7 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 			break;
 		case BOARD_DTC3181E:
 			hostdata->io_width = 2;	/* 16-bit PDMA */
-			/* fall through */
+			fallthrough;
 		case BOARD_NCR53C400A:
 		case BOARD_HP_C2502:
 			hostdata->c400_ctl_status = 9;
diff --git a/drivers/scsi/hisi_sas/hisi_sas_main.c b/drivers/scsi/hisi_sas/hisi_sas_main.c
index 6c8355f05c73..33329d2fa6e6 100644
--- a/drivers/scsi/hisi_sas/hisi_sas_main.c
+++ b/drivers/scsi/hisi_sas/hisi_sas_main.c
@@ -1172,7 +1172,7 @@ static int hisi_sas_control_phy(struct asd_sas_phy *sas_phy, enum phy_func func,
 			hisi_hba->hw->get_events(hisi_hba, phy_no);
 			break;
 		}
-		/* fallthru */
+		fallthrough;
 	case PHY_FUNC_RELEASE_SPINUP_HOLD:
 	default:
 		return -EOPNOTSUPP;
diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index 8519b821da7b..8bb39dcd6347 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -4669,7 +4669,7 @@ static int fixup_ioaccel_cdb(u8 *cdb, int *cdb_len)
 	case WRITE_6:
 	case WRITE_12:
 		is_write = 1;
-		/* fall through */
+		fallthrough;
 	case READ_6:
 	case READ_12:
 		if (*cdb_len == 6) {
@@ -5119,7 +5119,7 @@ static int hpsa_scsi_ioaccel_raid_map(struct ctlr_info *h,
 	switch (cmd->cmnd[0]) {
 	case WRITE_6:
 		is_write = 1;
-		/* fall through */
+		fallthrough;
 	case READ_6:
 		first_block = (((cmd->cmnd[1] & 0x1F) << 16) |
 				(cmd->cmnd[2] << 8) |
@@ -5130,7 +5130,7 @@ static int hpsa_scsi_ioaccel_raid_map(struct ctlr_info *h,
 		break;
 	case WRITE_10:
 		is_write = 1;
-		/* fall through */
+		fallthrough;
 	case READ_10:
 		first_block =
 			(((u64) cmd->cmnd[2]) << 24) |
@@ -5143,7 +5143,7 @@ static int hpsa_scsi_ioaccel_raid_map(struct ctlr_info *h,
 		break;
 	case WRITE_12:
 		is_write = 1;
-		/* fall through */
+		fallthrough;
 	case READ_12:
 		first_block =
 			(((u64) cmd->cmnd[2]) << 24) |
@@ -5158,7 +5158,7 @@ static int hpsa_scsi_ioaccel_raid_map(struct ctlr_info *h,
 		break;
 	case WRITE_16:
 		is_write = 1;
-		/* fall through */
+		fallthrough;
 	case READ_16:
 		first_block =
 			(((u64) cmd->cmnd[2]) << 56) |
* Unmerged path drivers/scsi/ibmvscsi/ibmvfc.c
* Unmerged path drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
* Unmerged path drivers/scsi/imm.c
* Unmerged path drivers/scsi/isci/phy.c
* Unmerged path drivers/scsi/isci/remote_device.c
* Unmerged path drivers/scsi/isci/remote_node_context.c
* Unmerged path drivers/scsi/isci/request.c
diff --git a/drivers/scsi/libfc/fc_exch.c b/drivers/scsi/libfc/fc_exch.c
index 28f5251edee1..0a6953f2db2f 100644
--- a/drivers/scsi/libfc/fc_exch.c
+++ b/drivers/scsi/libfc/fc_exch.c
@@ -2108,7 +2108,7 @@ static void fc_exch_rrq_resp(struct fc_seq *sp, struct fc_frame *fp, void *arg)
 	switch (op) {
 	case ELS_LS_RJT:
 		FC_EXCH_DBG(aborted_ep, "LS_RJT for RRQ\n");
-		/* fall through */
+		fallthrough;
 	case ELS_LS_ACC:
 		goto cleanup;
 	default:
@@ -2622,7 +2622,7 @@ void fc_exch_recv(struct fc_lport *lport, struct fc_frame *fp)
 	case FC_EOF_T:
 		if (f_ctl & FC_FC_END_SEQ)
 			skb_trim(fp_skb(fp), fr_len(fp) - FC_FC_FILL(f_ctl));
-		/* fall through */
+		fallthrough;
 	case FC_EOF_N:
 		if (fh->fh_type == FC_TYPE_BLS)
 			fc_exch_recv_bls(ema->mp, fp);
diff --git a/drivers/scsi/libfc/fc_fcp.c b/drivers/scsi/libfc/fc_fcp.c
index fe14926bd41e..9028a6486f0c 100644
--- a/drivers/scsi/libfc/fc_fcp.c
+++ b/drivers/scsi/libfc/fc_fcp.c
@@ -752,7 +752,7 @@ static void fc_fcp_abts_resp(struct fc_fcp_pkt *fsp, struct fc_frame *fp)
 		brp = fc_frame_payload_get(fp, sizeof(*brp));
 		if (brp && brp->br_reason == FC_BA_RJT_LOG_ERR)
 			break;
-		/* fall thru */
+		fallthrough;
 	default:
 		/*
 		 * we will let the command timeout
@@ -1536,7 +1536,7 @@ static void fc_fcp_rec_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)
 				   "device %x invalid REC reject %d/%d\n",
 				   fsp->rport->port_id, rjt->er_reason,
 				   rjt->er_explan);
-			/* fall through */
+			fallthrough;
 		case ELS_RJT_UNSUP:
 			FC_FCP_DBG(fsp, "device does not support REC\n");
 			rpriv = fsp->rport->dd_data;
@@ -1668,7 +1668,7 @@ static void fc_fcp_rec_error(struct fc_fcp_pkt *fsp, struct fc_frame *fp)
 		FC_FCP_DBG(fsp, "REC %p fid %6.6x error unexpected error %d\n",
 			   fsp, fsp->rport->port_id, error);
 		fsp->status_code = FC_CMD_PLOGO;
-		/* fall through */
+		fallthrough;
 
 	case -FC_EX_TIMEOUT:
 		/*
@@ -1830,7 +1830,7 @@ static void fc_fcp_srr_error(struct fc_fcp_pkt *fsp, struct fc_frame *fp)
 		break;
 	case -FC_EX_CLOSED:			/* e.g., link failure */
 		FC_FCP_DBG(fsp, "SRR error, exchange closed\n");
-		/* fall through */
+		fallthrough;
 	default:
 		fc_fcp_retry_cmd(fsp, FC_ERROR);
 		break;
diff --git a/drivers/scsi/libfc/fc_lport.c b/drivers/scsi/libfc/fc_lport.c
index 52c8368be619..85f7f5b466cf 100644
--- a/drivers/scsi/libfc/fc_lport.c
+++ b/drivers/scsi/libfc/fc_lport.c
@@ -1578,7 +1578,7 @@ static void fc_lport_timeout(struct work_struct *work)
 	case LPORT_ST_DPRT:
 		FC_LPORT_DBG(lport, "Skipping lport state %s to SCR\n",
 			     fc_lport_state(lport));
-		/* fall thru */
+		fallthrough;
 	case LPORT_ST_SCR:
 		fc_lport_enter_scr(lport);
 		break;
diff --git a/drivers/scsi/libfc/fc_rport.c b/drivers/scsi/libfc/fc_rport.c
index 80f63b763a0c..02d9d25f2da4 100644
--- a/drivers/scsi/libfc/fc_rport.c
+++ b/drivers/scsi/libfc/fc_rport.c
@@ -1723,7 +1723,7 @@ static void fc_rport_recv_els_req(struct fc_lport *lport, struct fc_frame *fp)
 			kref_put(&rdata->kref, fc_rport_destroy);
 			goto busy;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		FC_RPORT_DBG(rdata,
 			     "Reject ELS 0x%02x while in state %s\n",
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 1e7127ca6aec..30ac8ff111b3 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -248,7 +248,7 @@ static int iscsi_check_tmf_restrictions(struct iscsi_task *task, int opcode)
 		hdr_lun = scsilun_to_int(&tmf->lun);
 		if (hdr_lun != task->sc->device->lun)
 			return 0;
-		/* fall through */
+		fallthrough;
 	case ISCSI_TM_FUNC_TARGET_WARM_RESET:
 		/*
 		 * Fail all SCSI cmd PDUs
@@ -1674,7 +1674,7 @@ int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc)
 				sc->result = DID_NO_CONNECT << 16;
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		case ISCSI_STATE_IN_RECOVERY:
 			reason = FAILURE_SESSION_IN_RECOVERY;
 			sc->result = DID_IMM_RETRY << 16;
@@ -2239,7 +2239,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 					      "progress\n");
 			goto success;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		conn->tmf_state = TMF_INITIAL;
 		goto failed;
diff --git a/drivers/scsi/libiscsi_tcp.c b/drivers/scsi/libiscsi_tcp.c
index e0255bb2748f..7246dd78f6ec 100644
--- a/drivers/scsi/libiscsi_tcp.c
+++ b/drivers/scsi/libiscsi_tcp.c
@@ -772,7 +772,7 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 			iscsi_tcp_data_recv_prep(tcp_conn);
 			return 0;
 		}
-	/* fall through */
+		fallthrough;
 	case ISCSI_OP_LOGOUT_RSP:
 	case ISCSI_OP_NOOP_IN:
 	case ISCSI_OP_SCSI_TMFUNC_RSP:
diff --git a/drivers/scsi/libsas/sas_ata.c b/drivers/scsi/libsas/sas_ata.c
index c90b278cc28c..be13d1fdd63b 100644
--- a/drivers/scsi/libsas/sas_ata.c
+++ b/drivers/scsi/libsas/sas_ata.c
@@ -338,7 +338,7 @@ static int smp_ata_check_ready(struct ata_link *link)
 	case SAS_END_DEVICE:
 		if (ex_phy->attached_sata_dev)
 			return sas_ata_clear_pending(dev, ex_phy);
-		/* fall through */
+		fallthrough;
 	default:
 		return -ENODEV;
 	}
diff --git a/drivers/scsi/libsas/sas_discover.c b/drivers/scsi/libsas/sas_discover.c
index 0148ae62a52a..b91a53773ce3 100644
--- a/drivers/scsi/libsas/sas_discover.c
+++ b/drivers/scsi/libsas/sas_discover.c
@@ -115,7 +115,7 @@ static int sas_get_port_device(struct asd_sas_port *port)
 			rphy = NULL;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case SAS_END_DEVICE:
 		rphy = sas_end_device_alloc(port->port);
 		break;
diff --git a/drivers/scsi/libsas/sas_expander.c b/drivers/scsi/libsas/sas_expander.c
index 3fe7a613b983..e058c8b2413b 100644
--- a/drivers/scsi/libsas/sas_expander.c
+++ b/drivers/scsi/libsas/sas_expander.c
@@ -1078,7 +1078,7 @@ static int sas_ex_discover_dev(struct domain_device *dev, int phy_id)
 		} else
 			memcpy(dev->port->disc.fanout_sas_addr,
 			       ex_phy->attached_sas_addr, SAS_ADDR_SIZE);
-		/* fallthrough */
+		fallthrough;
 	case SAS_EDGE_EXPANDER_DEVICE:
 		child = sas_ex_discover_expander(dev, phy_id);
 		break;
diff --git a/drivers/scsi/libsas/sas_scsi_host.c b/drivers/scsi/libsas/sas_scsi_host.c
index 0195b978052d..6474f6dcc982 100644
--- a/drivers/scsi/libsas/sas_scsi_host.c
+++ b/drivers/scsi/libsas/sas_scsi_host.c
@@ -643,7 +643,7 @@ static void sas_eh_handle_sas_errors(struct Scsi_Host *shost, struct list_head *
 				sas_scsi_clear_queue_lu(work_q, cmd);
 				goto Again;
 			}
-			/* fallthrough */
+			fallthrough;
 		case TASK_IS_NOT_AT_LU:
 		case TASK_ABORT_FAILED:
 			SAS_DPRINTK("task 0x%p is not at LU: I_T recover\n",
diff --git a/drivers/scsi/lpfc/lpfc_ct.c b/drivers/scsi/lpfc/lpfc_ct.c
index 4b849f7ccd86..1b0684177a21 100644
--- a/drivers/scsi/lpfc/lpfc_ct.c
+++ b/drivers/scsi/lpfc/lpfc_ct.c
@@ -3537,7 +3537,7 @@ lpfc_fdmi_cmd(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
 	case SLI_MGMT_GHAT:
 	case SLI_MGMT_GRPL:
 		rsp_size = FC_MAX_NS_RSP;
-		/* fall through */
+		fallthrough;
 	case SLI_MGMT_DHBA:
 	case SLI_MGMT_DHAT:
 		pe = (struct lpfc_fdmi_port_entry *)&CtReq->un.PortID;
@@ -3550,7 +3550,7 @@ lpfc_fdmi_cmd(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
 	case SLI_MGMT_GPAT:
 	case SLI_MGMT_GPAS:
 		rsp_size = FC_MAX_NS_RSP;
-		/* fall through */
+		fallthrough;
 	case SLI_MGMT_DPRT:
 	case SLI_MGMT_DPA:
 		pe = (struct lpfc_fdmi_port_entry *)&CtReq->un.PortID;
diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c
index 5addea498ed1..83452f209a6f 100644
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@ -9148,7 +9148,7 @@ lpfc_cmpl_reg_new_vport(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)
 				lpfc_nlp_put(ndlp);
 				return;
 			}
-			/* fall through */
+			fallthrough;
 		default:
 			/* Try to recover from this error */
 			if (phba->sli_rev == LPFC_SLI_REV4)
diff --git a/drivers/scsi/lpfc/lpfc_hbadisc.c b/drivers/scsi/lpfc/lpfc_hbadisc.c
index b53e9acd34f4..050ce13acf76 100644
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -4761,15 +4761,14 @@ lpfc_check_sli_ndlp(struct lpfc_hba *phba,
 		case CMD_GEN_REQUEST64_CR:
 			if (iocb->context_un.ndlp == ndlp)
 				return 1;
-			/* fall through */
+			fallthrough;
 		case CMD_ELS_REQUEST64_CR:
 			if (icmd->un.elsreq64.remoteID == ndlp->nlp_DID)
 				return 1;
-			/* fall through */
+			fallthrough;
 		case CMD_XMIT_ELS_RSP64_CX:
 			if (iocb->context1 == (uint8_t *) ndlp)
 				return 1;
-			/* fall through */
 		}
 	} else if (pring->ringno == LPFC_FCP_RING) {
 		/* Skip match check if waiting to relogin to FCP target */
@@ -6103,7 +6102,7 @@ lpfc_disc_timeout_handler(struct lpfc_vport *vport)
 
 	case LPFC_LINK_UP:
 		lpfc_issue_clear_la(phba, vport);
-		/* fall through */
+		fallthrough;
 	case LPFC_LINK_UNKNOWN:
 	case LPFC_WARM_START:
 	case LPFC_INIT_START:
diff --git a/drivers/scsi/lpfc/lpfc_nportdisc.c b/drivers/scsi/lpfc/lpfc_nportdisc.c
index be51f5532edc..d1815ae64ba5 100644
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c
@@ -464,7 +464,7 @@ lpfc_rcv_plogi(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
 	case  NLP_STE_NPR_NODE:
 		if (!(ndlp->nlp_flag & NLP_NPR_ADISC))
 			break;
-		/* fall through */
+		fallthrough;
 	case  NLP_STE_REG_LOGIN_ISSUE:
 	case  NLP_STE_PRLI_ISSUE:
 	case  NLP_STE_UNMAPPED_NODE:
diff --git a/drivers/scsi/lpfc/lpfc_nvme.c b/drivers/scsi/lpfc/lpfc_nvme.c
index cb0ce1cfc429..06897c8cb1e3 100644
--- a/drivers/scsi/lpfc/lpfc_nvme.c
+++ b/drivers/scsi/lpfc/lpfc_nvme.c
@@ -1165,7 +1165,7 @@ lpfc_nvme_io_cmd_wqe_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *pwqeIn,
 					 lpfc_ncmd, nCmd,
 					 lpfc_ncmd->cur_iocbq.sli4_xritag,
 					 bf_get(lpfc_wcqe_c_xb, wcqe));
-			/* fall through */
+			fallthrough;
 		default:
 out_err:
 			lpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,
diff --git a/drivers/scsi/lpfc/lpfc_scsi.c b/drivers/scsi/lpfc/lpfc_scsi.c
index d51e52c727ea..998188f73620 100644
--- a/drivers/scsi/lpfc/lpfc_scsi.c
+++ b/drivers/scsi/lpfc/lpfc_scsi.c
@@ -1092,7 +1092,7 @@ lpfc_bg_err_inject(struct lpfc_hba *phba, struct scsi_cmnd *sc,
 
 					break;
 				}
-				/* fall through */
+				fallthrough;
 			case SCSI_PROT_WRITE_INSERT:
 				/*
 				 * For WRITE_INSERT, force the error
@@ -1211,7 +1211,7 @@ lpfc_bg_err_inject(struct lpfc_hba *phba, struct scsi_cmnd *sc,
 					rc = BG_ERR_TGT | BG_ERR_CHECK;
 					break;
 				}
-				/* fall through */
+				fallthrough;
 			case SCSI_PROT_WRITE_INSERT:
 				/*
 				 * For WRITE_INSERT, force the
@@ -1293,7 +1293,7 @@ lpfc_bg_err_inject(struct lpfc_hba *phba, struct scsi_cmnd *sc,
 			switch (op) {
 			case SCSI_PROT_WRITE_PASS:
 				rc = BG_ERR_CHECK;
-				/* fall through */
+				fallthrough;
 
 			case SCSI_PROT_WRITE_INSERT:
 				/*
@@ -3977,7 +3977,7 @@ lpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *pIocbIn,
 					lpfc_cmd->cur_iocbq.sli4_lxritag,
 					0, 0);
 			}
-			/* fall through */
+			fallthrough;
 		default:
 			cmd->result = ScsiResult(DID_ERROR, 0);
 			break;
* Unmerged path drivers/scsi/lpfc/lpfc_sli.c
diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 99c599506a3a..cb130fc06236 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -496,9 +496,9 @@ mega_get_ldrv_num(adapter_t *adapter, struct scsi_cmnd *cmd, int channel)
 
 	if (adapter->support_random_del && adapter->read_ldidmap )
 		switch (cmd->cmnd[0]) {
-		case READ_6:	/* fall through */
-		case WRITE_6:	/* fall through */
-		case READ_10:	/* fall through */
+		case READ_6:
+		case WRITE_6:
+		case READ_10:
 		case WRITE_10:
 			ldrv_num += 0x80;
 		}
@@ -858,7 +858,7 @@ mega_build_cmd(adapter_t *adapter, struct scsi_cmnd *cmd, int *busy)
 			return scb;
 
 #if MEGA_HAVE_CLUSTERING
-		case RESERVE:	/* Fall through */
+		case RESERVE:
 		case RELEASE:
 
 			/*
@@ -993,7 +993,7 @@ mega_prepare_passthru(adapter_t *adapter, scb_t *scb, struct scsi_cmnd *cmd,
 
 			adapter->flag |= (1L << cmd->device->channel);
 		}
-		/* Fall through */
+		fallthrough;
 	default:
 		pthru->numsgelements = mega_build_sglist(adapter, scb,
 				&pthru->dataxferaddr, &pthru->dataxferlen);
@@ -1056,7 +1056,7 @@ mega_prepare_extpassthru(adapter_t *adapter, scb_t *scb,
 
 			adapter->flag |= (1L << cmd->device->channel);
 		}
-		/* Fall through */
+		fallthrough;
 	default:
 		epthru->numsgelements = mega_build_sglist(adapter, scb,
 				&epthru->dataxferaddr, &epthru->dataxferlen);
diff --git a/drivers/scsi/megaraid/megaraid_mbox.c b/drivers/scsi/megaraid/megaraid_mbox.c
index f493a62f6f72..61f086395045 100644
--- a/drivers/scsi/megaraid/megaraid_mbox.c
+++ b/drivers/scsi/megaraid/megaraid_mbox.c
@@ -1602,7 +1602,7 @@ megaraid_mbox_build_cmd(adapter_t *adapter, struct scsi_cmnd *scp, int *busy)
 				return NULL;
 			}
 
-			/* Fall through */
+			fallthrough;
 
 		case READ_CAPACITY:
 			/*
diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c
index a70a6ebab3a1..be4ff4db9991 100644
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@ -3516,7 +3516,7 @@ megasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,
 			megasas_complete_int_cmd(instance, cmd);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 
 	case MFI_CMD_LD_READ:
 	case MFI_CMD_LD_WRITE:
diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c
index 04d0732c4a82..c0e2a605f59e 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@ -3546,7 +3546,7 @@ complete_cmd_fusion(struct megasas_instance *instance, u32 MSIxIndex,
 				atomic_dec(&lbinfo->scsi_pending_cmds[cmd_fusion->pd_r1_lb]);
 				cmd_fusion->scmd->SCp.Status &= ~MEGASAS_LOAD_BALANCE_FLAG;
 			}
-			/* Fall through - and complete IO */
+			fallthrough;	/* and complete IO */
 		case MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST: /* LD-IO Path */
 			atomic_dec(&instance->fw_outstanding);
 			if (cmd_fusion->r1_alt_dev_handle == MR_DEVHANDLE_INVALID) {
diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 82e01dbe90af..31fa6da66680 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1453,7 +1453,7 @@ static void cmd_complete(struct mesh_state *ms)
 		/* huh?  we expected a phase mismatch */
 		ms->n_msgin = 0;
 		ms->msgphase = msg_in;
-		/* fall through */
+		fallthrough;
 
 	case msg_in:
 		/* should have some message bytes in fifo */
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c
index a0ab44d520f6..e4cc92bc4d94 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@ -4694,7 +4694,7 @@ _base_update_ioc_page1_inlinewith_perf_mode(struct MPT3SAS_ADAPTER *ioc)
 			ioc_info(ioc, "performance mode: balanced\n");
 			return;
 		}
-		/* Fall through */
+		fallthrough;
 	case MPT_PERF_MODE_LATENCY:
 		/*
 		 * Enable interrupt coalescing on all reply queues
diff --git a/drivers/scsi/mpt3sas/mpt3sas_ctl.c b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
index af2d3e3cc2eb..b21aa55768ae 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@ -1004,7 +1004,7 @@ _ctl_do_mpt_command(struct MPT3SAS_ADAPTER *ioc, struct mpt3_ioctl_command karg,
 		}
 		/* drop to default case for posting the request */
 	}
-		/* fall through */
+		fallthrough;
 	default:
 		ioc->build_sg_mpi(ioc, psge, data_out_dma, data_out_sz,
 		    data_in_dma, data_in_sz);
diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
index 378470a2f366..3f9fd0ae097e 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@ -5837,7 +5837,7 @@ _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)
 
 	case MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:
 		scsi_set_resid(scmd, 0);
-		/* fall through */
+		fallthrough;
 	case MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:
 	case MPI2_IOCSTATUS_SUCCESS:
 		scmd->result = (DID_OK << 16) | scsi_status;
@@ -7568,7 +7568,7 @@ _scsih_sas_topology_change_event(struct MPT3SAS_ADAPTER *ioc,
 			if (!test_bit(handle, ioc->pend_os_device_add))
 				break;
 
-			/* fall through */
+			fallthrough;
 
 		case MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:
 
@@ -8297,7 +8297,7 @@ _scsih_pcie_topology_change_event(struct MPT3SAS_ADAPTER *ioc,
 			event_data->PortEntry[i].PortStatus &= 0xF0;
 			event_data->PortEntry[i].PortStatus |=
 				MPI26_EVENT_PCIE_TOPO_PS_DEV_ADDED;
-			/* fall through */
+			fallthrough;
 		case MPI26_EVENT_PCIE_TOPO_PS_DEV_ADDED:
 			if (ioc->shost_recovery)
 				break;
@@ -11855,7 +11855,7 @@ _scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		case MPI26_MFGPAGE_DEVID_CFG_SEC_3916:
 			dev_info(&pdev->dev,
 			    "HBA is in Configurable Secure mode\n");
-			/* fall through */
+			fallthrough;
 		case MPI26_MFGPAGE_DEVID_HARD_SEC_3816:
 		case MPI26_MFGPAGE_DEVID_HARD_SEC_3916:
 			ioc->is_aero_ioc = ioc->is_gen35_ioc = 1;
* Unmerged path drivers/scsi/myrb.c
* Unmerged path drivers/scsi/ncr53c8xx.c
diff --git a/drivers/scsi/pcmcia/nsp_cs.c b/drivers/scsi/pcmcia/nsp_cs.c
index 2c10af0cb456..822f08de5e28 100644
--- a/drivers/scsi/pcmcia/nsp_cs.c
+++ b/drivers/scsi/pcmcia/nsp_cs.c
@@ -1112,7 +1112,7 @@ static irqreturn_t nspintr(int irq, void *dev_id)
 			nsp_scsi_done(tmpSC);
 			return IRQ_HANDLED;
 		}
-		/* fall thru */
+		fallthrough;
 	default:
 		if ((irq_status & (IRQSTATUS_SCSI | IRQSTATUS_FIFO)) == 0) {
 			return IRQ_HANDLED;
* Unmerged path drivers/scsi/ppa.c
diff --git a/drivers/scsi/qla2xxx/qla_gs.c b/drivers/scsi/qla2xxx/qla_gs.c
index ba7175c4b360..2a4362a9a35a 100644
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@ -175,7 +175,7 @@ qla2x00_chk_ms_status(scsi_qla_host_t *vha, ms_iocb_entry_t *ms_pkt,
 			break;
 		case CS_TIMEOUT:
 			rval = QLA_FUNCTION_TIMEOUT;
-			/* fall through */
+			fallthrough;
 		default:
 			ql_dbg(ql_dbg_disc, vha, 0x2033,
 			    "%s failed, completion status (%x) on port_id: "
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index df6a41cd30f1..c1322e22736b 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -867,7 +867,7 @@ static void qla24xx_handle_gnl_done_event(scsi_qla_host_t *vha,
 					    fcport);
 					break;
 				}
-				/* fall through */
+				fallthrough;
 			default:
 				if (fcport_is_smaller(fcport)) {
 					/* local adapter is bigger */
diff --git a/drivers/scsi/qla2xxx/qla_iocb.c b/drivers/scsi/qla2xxx/qla_iocb.c
index cf655f3a6e69..ba345aef09cc 100644
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@ -2871,7 +2871,7 @@ static void qla2x00_els_dcmd2_sp_done(srb_t *sp, int res)
 					    &vha->dpc_flags);
 					qla2xxx_wake_dpc(vha);
 				}
-				/* fall through */
+				fallthrough;
 			default:
 				ql_dbg(ql_dbg_disc, vha, 0x20eb,
 				    "%s %8phC cmd error fw_status 0x%x 0x%x 0x%x\n",
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index befd2cd72991..205db8b47a73 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -1257,11 +1257,11 @@ qla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)
 				qla2xxx_wake_dpc(vha);
 			}
 		}
-		/* fall through */
+		fallthrough;
 	case MBA_IDC_COMPLETE:
 		if (ha->notify_lb_portup_comp && !vha->vp_idx)
 			complete(&ha->lb_portup_comp);
-		/* Fallthru */
+		fallthrough;
 	case MBA_IDC_TIME_EXT:
 		if (IS_QLA81XX(vha->hw) || IS_QLA8031(vha->hw) ||
 		    IS_QLA8044(ha))
@@ -1881,7 +1881,7 @@ qla24xx_logio_entry(scsi_qla_host_t *vha, struct req_que *req,
 				set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
 			qla2xxx_wake_dpc(vha);
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		data[0] = MBS_COMMAND_ERROR;
 		break;
@@ -2087,7 +2087,7 @@ static void qla24xx_nvme_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,
 	case CS_PORT_UNAVAILABLE:
 	case CS_PORT_LOGGED_OUT:
 		fcport->nvme_flag |= NVME_FLAG_RESETTING;
-		/* fall through */
+		fallthrough;
 	case CS_ABORTED:
 	case CS_PORT_BUSY:
 		fd->transferred_length = 0;
@@ -3192,7 +3192,7 @@ void qla24xx_process_response_queue(struct scsi_qla_host *vha,
 			} else {
 				qlt_24xx_process_atio_queue(vha, 1);
 			}
-			/* fall through */
+			fallthrough;
 		case ABTS_RESP_24XX:
 		case CTIO_TYPE7:
 		case CTIO_CRC2:
diff --git a/drivers/scsi/qla2xxx/qla_sup.c b/drivers/scsi/qla2xxx/qla_sup.c
index 773dbee955c3..a18b3c20c326 100644
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@ -2455,7 +2455,7 @@ qla2x00_write_optrom_data(struct scsi_qla_host *vha, void *buf,
 				sec_mask = 0x10000;
 				break;
 			}
-			/* Fall through... */
+			fallthrough;
 
 		case 0x1f: /* Atmel flash. */
 			/* 512k sector size. */
@@ -2464,7 +2464,7 @@ qla2x00_write_optrom_data(struct scsi_qla_host *vha, void *buf,
 				sec_mask =   0x80000000;
 				break;
 			}
-			/* Fall through... */
+			fallthrough;
 
 		case 0x01: /* AMD flash. */
 			if (flash_id == 0x38 || flash_id == 0x40 ||
@@ -2497,7 +2497,7 @@ qla2x00_write_optrom_data(struct scsi_qla_host *vha, void *buf,
 				sec_mask = 0x1e000;
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		default:
 			/* Default to 16 kb sector size. */
 			rest_addr = 0x3fff;
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 1d1d8f79ee7f..efdb6fc43ad4 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -453,7 +453,7 @@ void qlt_response_pkt_all_vps(struct scsi_qla_host *vha,
 		ql_dbg(ql_dbg_tgt, vha, 0xe073,
 			"qla_target(%d):%s: CRC2 Response pkt\n",
 			vha->vp_idx, __func__);
-		/* fall through */
+		fallthrough;
 	case CTIO_TYPE7:
 	{
 		struct ctio7_from_24xx *entry = (struct ctio7_from_24xx *)pkt;
@@ -4436,7 +4436,7 @@ static int qlt_issue_task_mgmt(struct fc_port *sess, u64 lun,
 	case QLA_TGT_CLEAR_TS:
 	case QLA_TGT_ABORT_TS:
 		abort_cmds_for_lun(vha, lun, a->u.isp24.fcp_hdr.s_id);
-		/* fall through */
+		fallthrough;
 	case QLA_TGT_CLEAR_ACA:
 		h = qlt_find_qphint(vha, mcmd->unpacked_lun);
 		mcmd->qpair = h->qpair;
@@ -5070,7 +5070,7 @@ static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
 			res = 1;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case ELS_LOGO:
 	case ELS_PRLO:
 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
* Unmerged path drivers/scsi/qla4xxx/ql4_os.c
* Unmerged path drivers/scsi/qlogicpti.c
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index f9c7880dffa9..ae95c090ecf8 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -599,7 +599,7 @@ int scsi_check_sense(struct scsi_cmnd *scmd)
 			set_host_byte(scmd, DID_ALLOC_FAILURE);
 			return SUCCESS;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case COPY_ABORTED:
 	case VOLUME_OVERFLOW:
 	case MISCOMPARE:
@@ -621,7 +621,7 @@ int scsi_check_sense(struct scsi_cmnd *scmd)
 			return ADD_TO_MLQUEUE;
 		else
 			set_host_byte(scmd, DID_TARGET_FAILURE);
-		/* FALLTHROUGH */
+		fallthrough;
 
 	case ILLEGAL_REQUEST:
 		if (sshdr.asc == 0x20 || /* Invalid command operation code */
@@ -734,7 +734,7 @@ static int scsi_eh_completed_normally(struct scsi_cmnd *scmd)
 	switch (status_byte(scmd->result)) {
 	case GOOD:
 		scsi_handle_queue_ramp_up(scmd->device);
-		/* FALLTHROUGH */
+		fallthrough;
 	case COMMAND_TERMINATED:
 		return SUCCESS;
 	case CHECK_CONDITION:
@@ -755,7 +755,7 @@ static int scsi_eh_completed_normally(struct scsi_cmnd *scmd)
 		return FAILED;
 	case QUEUE_FULL:
 		scsi_handle_queue_full(scmd->device);
-		/* fall through */
+		fallthrough;
 	case BUSY:
 		return NEEDS_RETRY;
 	default:
@@ -1302,7 +1302,7 @@ static int scsi_eh_tur(struct scsi_cmnd *scmd)
 	case NEEDS_RETRY:
 		if (retry_cnt--)
 			goto retry_tur;
-		/*FALLTHRU*/
+		fallthrough;
 	case SUCCESS:
 		return 0;
 	default:
@@ -1739,7 +1739,7 @@ int scsi_noretry_cmd(struct scsi_cmnd *scmd)
 		if (msg_byte(scmd->result) == COMMAND_COMPLETE &&
 		    status_byte(scmd->result) == RESERVATION_CONFLICT)
 			return 0;
-		/* fall through */
+		fallthrough;
 	case DID_SOFT_ERROR:
 		return (scmd->request->cmd_flags & REQ_FAILFAST_DRIVER);
 	}
@@ -1810,7 +1810,7 @@ int scsi_decide_disposition(struct scsi_cmnd *scmd)
 			set_host_byte(scmd, DID_TIME_OUT);
 			return SUCCESS;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case DID_NO_CONNECT:
 	case DID_BAD_TARGET:
 		/*
@@ -1854,7 +1854,7 @@ int scsi_decide_disposition(struct scsi_cmnd *scmd)
 			 * lower down
 			 */
 			break;
-		/* fallthrough */
+		fallthrough;
 	case DID_BUS_BUSY:
 	case DID_PARITY:
 		goto maybe_retry;
@@ -1892,7 +1892,7 @@ int scsi_decide_disposition(struct scsi_cmnd *scmd)
 		 * the case of trying to send too many commands to a
 		 * tagged queueing device.
 		 */
-		/* FALLTHROUGH */
+		fallthrough;
 	case BUSY:
 		/*
 		 * device can't talk to us at the moment.  Should only
@@ -1905,7 +1905,7 @@ int scsi_decide_disposition(struct scsi_cmnd *scmd)
 		if (scmd->cmnd[0] == REPORT_LUNS)
 			scmd->device->sdev_target->expecting_lun_change = 0;
 		scsi_handle_queue_ramp_up(scmd->device);
-		/* FALLTHROUGH */
+		fallthrough;
 	case COMMAND_TERMINATED:
 		return SUCCESS;
 	case TASK_ABORTED:
@@ -2380,22 +2380,22 @@ scsi_ioctl_reset(struct scsi_device *dev, int __user *arg)
 		rtn = scsi_try_bus_device_reset(scmd);
 		if (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))
 			break;
-		/* FALLTHROUGH */
+		fallthrough;
 	case SG_SCSI_RESET_TARGET:
 		rtn = scsi_try_target_reset(scmd);
 		if (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))
 			break;
-		/* FALLTHROUGH */
+		fallthrough;
 	case SG_SCSI_RESET_BUS:
 		rtn = scsi_try_bus_reset(scmd);
 		if (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))
 			break;
-		/* FALLTHROUGH */
+		fallthrough;
 	case SG_SCSI_RESET_HOST:
 		rtn = scsi_try_host_reset(scmd);
 		if (rtn == SUCCESS)
 			break;
-		/* FALLTHROUGH */
+		fallthrough;
 	default:
 		rtn = FAILED;
 		break;
diff --git a/drivers/scsi/scsi_ioctl.c b/drivers/scsi/scsi_ioctl.c
index 07674ac32a68..3f7a75764a68 100644
--- a/drivers/scsi/scsi_ioctl.c
+++ b/drivers/scsi/scsi_ioctl.c
@@ -117,14 +117,14 @@ static int ioctl_internal_command(struct scsi_device *sdev, char *cmd,
 		case NOT_READY:	/* This happens if there is no disc in drive */
 			if (sdev->removable)
 				break;
-			/* FALLTHROUGH */
+			fallthrough;
 		case UNIT_ATTENTION:
 			if (sdev->removable) {
 				sdev->changed = 1;
 				result = 0;	/* This is no longer considered an error */
 				break;
 			}
-			/* FALLTHROUGH -- for non-removable media */
+			fallthrough;	/* for non-removable media */
 		default:
 			sdev_printk(KERN_INFO, sdev,
 				    "ioctl_internal_command return code = %x\n",
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 8e06bc7fa5a6..fbe640443ac0 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -834,7 +834,7 @@ static void scsi_io_completion_action(struct scsi_cmnd *cmd, int result)
 		}
 		if (!scsi_end_request(req, blk_stat, blk_rq_err_bytes(req)))
 			return;
-		/*FALLTHRU*/
+		fallthrough;
 	case ACTION_REPREP:
 		scsi_io_completion_reprep(cmd, q);
 		break;
diff --git a/drivers/scsi/smartpqi/smartpqi_init.c b/drivers/scsi/smartpqi/smartpqi_init.c
index 786600ed19ed..64280d9be057 100644
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@ -516,7 +516,7 @@ static int pqi_build_raid_path_request(struct pqi_ctrl_info *ctrl_info,
 		break;
 	case BMIC_SENSE_DIAG_OPTIONS:
 		cdb_length = 0;
-		/* fall through */
+		fallthrough;
 	case BMIC_IDENTIFY_CONTROLLER:
 	case BMIC_IDENTIFY_PHYSICAL_DEVICE:
 	case BMIC_SENSE_SUBSYSTEM_INFORMATION:
@@ -527,7 +527,7 @@ static int pqi_build_raid_path_request(struct pqi_ctrl_info *ctrl_info,
 		break;
 	case BMIC_SET_DIAG_OPTIONS:
 		cdb_length = 0;
-		/* fall through */
+		fallthrough;
 	case BMIC_WRITE_HOST_WELLNESS:
 		request->data_direction = SOP_WRITE_FLAG;
 		cdb[0] = BMIC_WRITE;
@@ -2322,7 +2322,7 @@ static int pqi_raid_bypass_submit_scsi_cmd(struct pqi_ctrl_info *ctrl_info,
 	switch (scmd->cmnd[0]) {
 	case WRITE_6:
 		is_write = true;
-		/* fall through */
+		fallthrough;
 	case READ_6:
 		first_block = (u64)(((scmd->cmnd[1] & 0x1f) << 16) |
 			(scmd->cmnd[2] << 8) | scmd->cmnd[3]);
@@ -2332,21 +2332,21 @@ static int pqi_raid_bypass_submit_scsi_cmd(struct pqi_ctrl_info *ctrl_info,
 		break;
 	case WRITE_10:
 		is_write = true;
-		/* fall through */
+		fallthrough;
 	case READ_10:
 		first_block = (u64)get_unaligned_be32(&scmd->cmnd[2]);
 		block_cnt = (u32)get_unaligned_be16(&scmd->cmnd[7]);
 		break;
 	case WRITE_12:
 		is_write = true;
-		/* fall through */
+		fallthrough;
 	case READ_12:
 		first_block = (u64)get_unaligned_be32(&scmd->cmnd[2]);
 		block_cnt = get_unaligned_be32(&scmd->cmnd[6]);
 		break;
 	case WRITE_16:
 		is_write = true;
-		/* fall through */
+		fallthrough;
 	case READ_16:
 		first_block = get_unaligned_be64(&scmd->cmnd[2]);
 		block_cnt = get_unaligned_be32(&scmd->cmnd[10]);
@@ -2968,7 +2968,7 @@ static int pqi_process_io_intr(struct pqi_ctrl_info *ctrl_info, struct pqi_queue
 		case PQI_RESPONSE_IU_AIO_PATH_IO_SUCCESS:
 			if (io_request->scmd)
 				io_request->scmd->result = 0;
-			/* fall through */
+			fallthrough;
 		case PQI_RESPONSE_IU_GENERAL_MANAGEMENT:
 			break;
 		case PQI_RESPONSE_IU_VENDOR_GENERAL:
@@ -3133,12 +3133,11 @@ static void pqi_process_soft_reset(struct pqi_ctrl_info *ctrl_info,
 
 	switch (reset_status) {
 	case RESET_INITIATE_DRIVER:
-		/* fall through */
 	case RESET_TIMEDOUT:
 		dev_info(&ctrl_info->pci_dev->dev,
 			"resetting controller %u\n", ctrl_info->ctrl_id);
 		sis_soft_reset(ctrl_info);
-		/* fall through */
+		fallthrough;
 	case RESET_INITIATE_FIRMWARE:
 		rc = pqi_ofa_ctrl_restart(ctrl_info);
 		pqi_ofa_free_host_buffer(ctrl_info);
diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index cce823d47c2f..9c03548cd326 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -825,10 +825,10 @@ static void get_sectorsize(struct scsi_cd *cd)
 		case 2340:
 		case 2352:
 			sector_size = 2048;
-			/* fall through */
+			fallthrough;
 		case 2048:
 			cd->capacity *= 4;
-			/* fall through */
+			fallthrough;
 		case 512:
 			break;
 		default:
diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c
index 9bb17ae525f5..3e8b39fd8058 100644
--- a/drivers/scsi/st.c
+++ b/drivers/scsi/st.c
@@ -339,14 +339,14 @@ static void st_analyze_sense(struct st_request *SRpnt, struct st_cmdstatus *s)
 		switch (sense[0] & 0x7f) {
 		case 0x71:
 			s->deferred = 1;
-			/* fall through */
+			fallthrough;
 		case 0x70:
 			s->fixed_format = 1;
 			s->flags = sense[2] & 0xe0;
 			break;
 		case 0x73:
 			s->deferred = 1;
-			/* fall through */
+			fallthrough;
 		case 0x72:
 			s->fixed_format = 0;
 			ucp = scsi_sense_desc_find(sense, SCSI_SENSE_BUFFERSIZE, 4);
@@ -2723,7 +2723,7 @@ static int st_int_ioctl(struct scsi_tape *STp, unsigned int cmd_in, unsigned lon
 	switch (cmd_in) {
 	case MTFSFM:
 		chg_eof = 0;	/* Changed from the FSF after this */
-		/* fall through */
+		fallthrough;
 	case MTFSF:
 		cmd[0] = SPACE;
 		cmd[1] = 0x01;	/* Space FileMarks */
@@ -2738,7 +2738,7 @@ static int st_int_ioctl(struct scsi_tape *STp, unsigned int cmd_in, unsigned lon
 		break;
 	case MTBSFM:
 		chg_eof = 0;	/* Changed from the FSF after this */
-		/* fall through */
+		fallthrough;
 	case MTBSF:
 		cmd[0] = SPACE;
 		cmd[1] = 0x01;	/* Space FileMarks */
* Unmerged path drivers/scsi/sun3_scsi.c
diff --git a/drivers/scsi/sym53c8xx_2/sym_fw.c b/drivers/scsi/sym53c8xx_2/sym_fw.c
index 190770bdc194..ba7143026cac 100644
--- a/drivers/scsi/sym53c8xx_2/sym_fw.c
+++ b/drivers/scsi/sym53c8xx_2/sym_fw.c
@@ -540,7 +540,7 @@ void sym_fw_bind_script(struct sym_hcb *np, u32 *start, int len)
 					new = old;
 					break;
 				}
-				/* fall through */
+				fallthrough;
 			default:
 				new = 0;
 				panic("sym_fw_bind_script: "
* Unmerged path drivers/scsi/sym53c8xx_2/sym_hipd.c
* Unmerged path drivers/scsi/sym53c8xx_2/sym_nvram.c
* Unmerged path drivers/scsi/ufs/ufs_bsg.c
* Unmerged path drivers/scsi/ufs/ufshcd.c
diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c
index 108180c1aef2..4423d856062c 100644
--- a/drivers/scsi/virtio_scsi.c
+++ b/drivers/scsi/virtio_scsi.c
@@ -151,7 +151,7 @@ static void virtscsi_complete_cmd(struct virtio_scsi *vscsi, void *buf)
 	default:
 		scmd_printk(KERN_WARNING, sc, "Unknown response %d",
 			    resp->response);
-		/* fall through */
+		fallthrough;
 	case VIRTIO_SCSI_S_FAILURE:
 		set_host_byte(sc, DID_ERROR);
 		break;
diff --git a/drivers/scsi/vmw_pvscsi.c b/drivers/scsi/vmw_pvscsi.c
index 2b4438a478e1..ffa0e3ee9904 100644
--- a/drivers/scsi/vmw_pvscsi.c
+++ b/drivers/scsi/vmw_pvscsi.c
@@ -608,7 +608,7 @@ static void pvscsi_complete_request(struct pvscsi_adapter *adapter,
 		case BTSTAT_TAGREJECT:
 		case BTSTAT_BADMSG:
 			cmd->result = (DRIVER_INVALID << 24);
-			/* fall through */
+			fallthrough;
 
 		case BTSTAT_HAHARDWARE:
 		case BTSTAT_INVPHASE:
* Unmerged path drivers/scsi/wd33c93.c
* Unmerged path drivers/scsi/xen-scsifront.c
* Unmerged path drivers/soc/qcom/socinfo.c
* Unmerged path drivers/soc/tegra/pmc.c
diff --git a/drivers/spi/spi-bcm2835aux.c b/drivers/spi/spi-bcm2835aux.c
index 3094d818cf06..e12d82014b7f 100644
--- a/drivers/spi/spi-bcm2835aux.c
+++ b/drivers/spi/spi-bcm2835aux.c
@@ -128,10 +128,10 @@ static inline void bcm2835aux_rd_fifo(struct bcm2835aux_spi *bs)
 			/* fallthrough */
 		case 3:
 			*bs->rx_buf++ = (data >> 16) & 0xff;
-			/* fallthrough */
+			fallthrough;
 		case 2:
 			*bs->rx_buf++ = (data >> 8) & 0xff;
-			/* fallthrough */
+			fallthrough;
 		case 1:
 			*bs->rx_buf++ = (data >> 0) & 0xff;
 			/* fallthrough - no default */
diff --git a/drivers/spi/spi-fsl-cpm.c b/drivers/spi/spi-fsl-cpm.c
index 8f7b26ec181e..a856477ebb49 100644
--- a/drivers/spi/spi-fsl-cpm.c
+++ b/drivers/spi/spi-fsl-cpm.c
@@ -230,7 +230,7 @@ static void fsl_spi_free_dummy_rx(void)
 	case 1:
 		kfree(fsl_dummy_rx);
 		fsl_dummy_rx = NULL;
-		/* fall through */
+		fallthrough;
 	default:
 		fsl_dummy_rx_refcnt--;
 		break;
@@ -298,7 +298,7 @@ int fsl_spi_cpm_init(struct mpc8xxx_spi *mspi)
 		switch (mspi->subblock) {
 		default:
 			dev_warn(dev, "cell-index unspecified, assuming SPI1\n");
-			/* fall through */
+			fallthrough;
 		case 0:
 			mspi->subblock = QE_CR_SUBBLOCK_SPI1;
 			break;
* Unmerged path drivers/spi/spi-sprd-adi.c
* Unmerged path drivers/ssb/driver_chipcommon.c
diff --git a/drivers/ssb/driver_mipscore.c b/drivers/ssb/driver_mipscore.c
index f87efef42252..05d538fb361c 100644
--- a/drivers/ssb/driver_mipscore.c
+++ b/drivers/ssb/driver_mipscore.c
@@ -341,7 +341,7 @@ void ssb_mipscore_init(struct ssb_mipscore *mcore)
 				set_irq(dev, irq++);
 				break;
 			}
-			/* fallthrough */
+			fallthrough;
 		case SSB_DEV_EXTIF:
 			set_irq(dev, 0);
 			break;
diff --git a/drivers/ssb/scan.c b/drivers/ssb/scan.c
index b9429df583eb..053bfa739711 100644
--- a/drivers/ssb/scan.c
+++ b/drivers/ssb/scan.c
@@ -228,7 +228,7 @@ static void __iomem *ssb_ioremap(struct ssb_bus *bus,
 	switch (bus->bustype) {
 	case SSB_BUSTYPE_SSB:
 		/* Only map the first core for now. */
-		/* fallthrough... */
+		fallthrough;
 	case SSB_BUSTYPE_PCMCIA:
 		mmio = ioremap(baseaddr, SSB_CORE_SIZE);
 		break;
* Unmerged path drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
* Unmerged path drivers/staging/media/atomisp/pci/atomisp_cmd.c
* Unmerged path drivers/staging/media/atomisp/pci/atomisp_compat_css20.c
* Unmerged path drivers/staging/media/atomisp/pci/atomisp_ioctl.c
* Unmerged path drivers/staging/media/atomisp/pci/atomisp_v4l2.c
* Unmerged path drivers/staging/media/atomisp/pci/hmm/hmm_bo.c
* Unmerged path drivers/staging/media/atomisp/pci/sh_css.c
* Unmerged path drivers/staging/media/hantro/hantro_g1_mpeg2_dec.c
* Unmerged path drivers/staging/media/hantro/rk3399_vpu_hw_mpeg2_dec.c
* Unmerged path drivers/staging/media/imx/imx-media-csi.c
diff --git a/drivers/target/iscsi/cxgbit/cxgbit_main.c b/drivers/target/iscsi/cxgbit/cxgbit_main.c
index 4cd63c025dcf..01fab2d6e240 100644
--- a/drivers/target/iscsi/cxgbit/cxgbit_main.c
+++ b/drivers/target/iscsi/cxgbit/cxgbit_main.c
@@ -447,7 +447,7 @@ cxgbit_uld_lro_rx_handler(void *hndl, const __be64 *rsp,
 	case CPL_RX_ISCSI_DDP:
 	case CPL_FW4_ACK:
 		lro_flush = false;
-		/* fall through */
+		fallthrough;
 	case CPL_ABORT_RPL_RSS:
 	case CPL_PASS_ESTABLISH:
 	case CPL_PEER_CLOSE:
diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c
index 067074ef5081..0a4e5816bbe2 100644
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -3761,7 +3761,7 @@ iscsit_response_queue(struct iscsi_conn *conn, struct iscsi_cmd *cmd, int state)
 	case ISTATE_SEND_LOGOUTRSP:
 		if (!iscsit_logout_post_handler(cmd, conn))
 			return -ECONNRESET;
-		/* fall through */
+		fallthrough;
 	case ISTATE_SEND_STATUS:
 	case ISTATE_SEND_ASYNCMSG:
 	case ISTATE_SEND_NOPIN:
diff --git a/drivers/target/target_core_pr.c b/drivers/target/target_core_pr.c
index a798bacc58ae..1cf4cebc00e5 100644
--- a/drivers/target/target_core_pr.c
+++ b/drivers/target/target_core_pr.c
@@ -358,7 +358,7 @@ static int core_scsi3_pr_seq_non_holder(struct se_cmd *cmd, u32 pr_reg_type,
 		break;
 	case PR_TYPE_WRITE_EXCLUSIVE_REGONLY:
 		we = 1;
-		/* fall through */
+		fallthrough;
 	case PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:
 		/*
 		 * Some commands are only allowed for registered I_T Nexuses.
@@ -367,7 +367,7 @@ static int core_scsi3_pr_seq_non_holder(struct se_cmd *cmd, u32 pr_reg_type,
 		break;
 	case PR_TYPE_WRITE_EXCLUSIVE_ALLREG:
 		we = 1;
-		/* fall through */
+		fallthrough;
 	case PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:
 		/*
 		 * Each registered I_T Nexus is a reservation holder.
diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c
index 1ac1f7d2e6c9..39454ab14aff 100644
--- a/drivers/target/target_core_sbc.c
+++ b/drivers/target/target_core_sbc.c
@@ -747,7 +747,7 @@ sbc_check_prot(struct se_device *dev, struct se_cmd *cmd, unsigned char *cdb,
 		}
 		if (!protect)
 			return TCM_NO_SENSE;
-		/* Fallthrough */
+		fallthrough;
 	default:
 		pr_err("Unable to determine pi_prot_type for CDB: 0x%02x "
 		       "PROTECT: 0x%02x\n", cdb[0], protect);
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index db53a0d649da..ea116bf64828 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -2250,7 +2250,7 @@ static void transport_complete_qf(struct se_cmd *cmd)
 			ret = cmd->se_tfo->queue_data_in(cmd);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case DMA_NONE:
 queue_status:
 		trace_target_cmd_complete(cmd);
@@ -2445,7 +2445,7 @@ static void target_complete_ok_work(struct work_struct *work)
 				goto queue_full;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case DMA_NONE:
 queue_status:
 		trace_target_cmd_complete(cmd);
diff --git a/drivers/target/tcm_fc/tfc_cmd.c b/drivers/target/tcm_fc/tfc_cmd.c
index f0529ba58f4c..3ac9f1f400cb 100644
--- a/drivers/target/tcm_fc/tfc_cmd.c
+++ b/drivers/target/tcm_fc/tfc_cmd.c
@@ -549,7 +549,7 @@ static void ft_send_work(struct work_struct *work)
 	case FCP_PTA_ACA:
 		task_attr = TCM_ACA_TAG;
 		break;
-	case FCP_PTA_SIMPLE: /* Fallthrough */
+	case FCP_PTA_SIMPLE:
 	default:
 		task_attr = TCM_SIMPLE_TAG;
 	}
* Unmerged path drivers/thermal/qcom/tsens-v0_1.c
* Unmerged path drivers/thermal/qcom/tsens-v1.c
diff --git a/drivers/thunderbolt/ctl.c b/drivers/thunderbolt/ctl.c
index e3b7ade29ae5..bac08b820015 100644
--- a/drivers/thunderbolt/ctl.c
+++ b/drivers/thunderbolt/ctl.c
@@ -461,7 +461,7 @@ static void tb_ctl_rx_callback(struct tb_ring *ring, struct ring_frame *frame,
 				   "RX: checksum mismatch, dropping packet\n");
 			goto rx;
 		}
-		/* Fall through */
+		fallthrough;
 	case TB_CFG_PKG_ICM_EVENT:
 		if (tb_ctl_handle_event(pkg->ctl, frame->eof, pkg, frame->size))
 			goto rx;
diff --git a/drivers/thunderbolt/switch.c b/drivers/thunderbolt/switch.c
index 49f0a96d70e4..a8572f49d3ad 100644
--- a/drivers/thunderbolt/switch.c
+++ b/drivers/thunderbolt/switch.c
@@ -2158,7 +2158,7 @@ static int tb_switch_add_dma_port(struct tb_switch *sw)
 		if (tb_route(sw))
 			return 0;
 
-		/* fallthrough */
+		fallthrough;
 	case 3:
 	case 4:
 		ret = tb_switch_set_uuid(sw);
diff --git a/drivers/thunderbolt/tunnel.c b/drivers/thunderbolt/tunnel.c
index a86ca013612f..dcdf9c7a9cae 100644
--- a/drivers/thunderbolt/tunnel.c
+++ b/drivers/thunderbolt/tunnel.c
@@ -312,7 +312,7 @@ static inline u32 tb_dp_cap_set_rate(u32 val, u32 rate)
 	switch (rate) {
 	default:
 		WARN(1, "invalid rate %u passed, defaulting to 1620 MB/s\n", rate);
-		/* Fallthrough */
+		fallthrough;
 	case 1620:
 		val |= DP_COMMON_CAP_RATE_RBR << DP_COMMON_CAP_RATE_SHIFT;
 		break;
@@ -352,7 +352,7 @@ static inline u32 tb_dp_cap_set_lanes(u32 val, u32 lanes)
 	default:
 		WARN(1, "invalid number of lanes %u passed, defaulting to 1\n",
 		     lanes);
-		/* Fallthrough */
+		fallthrough;
 	case 1:
 		val |= DP_COMMON_CAP_1_LANE << DP_COMMON_CAP_LANES_SHIFT;
 		break;
* Unmerged path drivers/tty/hvc/hvc_xen.c
* Unmerged path drivers/tty/mips_ejtag_fdc.c
* Unmerged path drivers/tty/n_gsm.c
* Unmerged path drivers/tty/n_hdlc.c
diff --git a/drivers/tty/n_r3964.c b/drivers/tty/n_r3964.c
index dbf1ab36758e..4975fe54f48b 100644
--- a/drivers/tty/n_r3964.c
+++ b/drivers/tty/n_r3964.c
@@ -598,7 +598,6 @@ static void receive_char(struct r3964_info *pInfo, const unsigned char c)
 		}
 		break;
 	case R3964_WAIT_FOR_RX_REPEAT:
-		/* FALLTHROUGH */
 	case R3964_IDLE:
 		if (c == STX) {
 			/* Prevent rx_queue from overflow: */
diff --git a/drivers/tty/serial/8250/8250_em.c b/drivers/tty/serial/8250/8250_em.c
index f6a86f2bc4e5..4428c2b0e771 100644
--- a/drivers/tty/serial/8250/8250_em.c
+++ b/drivers/tty/serial/8250/8250_em.c
@@ -38,7 +38,7 @@ static void serial8250_em_serial_out(struct uart_port *p, int offset, int value)
 		break;
 	case UART_IER: /* IER @ 0x04 */
 		value &= 0x0f; /* only 4 valid bits - not Xscale */
-		/* fall-through */
+		fallthrough;
 	case UART_DLL_EM: /* DLL @ 0x24 (+9) */
 	case UART_DLM_EM: /* DLM @ 0x28 (+9) */
 		writel(value, p->membase + (offset << 2));
diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c
index 79a4958b3f5c..a5fd9ebf27ca 100644
--- a/drivers/tty/serial/8250/8250_fintek.c
+++ b/drivers/tty/serial/8250/8250_fintek.c
@@ -251,7 +251,7 @@ static void fintek_8250_set_irq_mode(struct fintek_8250 *pdata, bool is_level)
 	case CHIP_ID_F81866:
 		sio_write_mask_reg(pdata, F81866_FIFO_CTRL, F81866_IRQ_MODE1,
 				   0);
-		/* fall through */
+		fallthrough;
 	case CHIP_ID_F81865:
 		sio_write_mask_reg(pdata, F81866_IRQ_MODE, F81866_IRQ_SHARE,
 				   F81866_IRQ_SHARE);
diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c
index dedbee19622b..9e2ac3a70251 100644
--- a/drivers/tty/serial/8250/8250_pci.c
+++ b/drivers/tty/serial/8250/8250_pci.c
@@ -616,7 +616,7 @@ pci_timedia_setup(struct serial_private *priv,
 		break;
 	case 3:
 		offset = board->uart_offset;
-		/* FALLTHROUGH */
+		fallthrough;
 	case 4: /* BAR 2 */
 	case 5: /* BAR 3 */
 	case 6: /* BAR 4 */
diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index b32e67c085a6..7c6697236d0d 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -1856,7 +1856,7 @@ static bool handle_rx_dma(struct uart_8250_port *up, unsigned int iir)
 	switch (iir & 0x3f) {
 	case UART_IIR_RX_TIMEOUT:
 		serial8250_rx_dma_flush(up);
-		/* fall-through */
+		fallthrough;
 	case UART_IIR_RLSI:
 		return true;
 	}
diff --git a/drivers/tty/serial/8250/8250_uniphier.c b/drivers/tty/serial/8250/8250_uniphier.c
index 28d88ccf5a0c..afe864e77d2c 100644
--- a/drivers/tty/serial/8250/8250_uniphier.c
+++ b/drivers/tty/serial/8250/8250_uniphier.c
@@ -78,7 +78,7 @@ static unsigned int uniphier_serial_in(struct uart_port *p, int offset)
 		break;
 	case UART_LCR:
 		valshift = 8;
-		/* fall through */
+		fallthrough;
 	case UART_MCR:
 		offset = UNIPHIER_UART_LCR_MCR;
 		break;
@@ -104,7 +104,7 @@ static void uniphier_serial_out(struct uart_port *p, int offset, int value)
 	case UART_SCR:
 		/* No SCR for this hardware.  Use CHAR as a scratch register */
 		valshift = 8;
-		/* fall through */
+		fallthrough;
 	case UART_FCR:
 		offset = UNIPHIER_UART_CHAR_FCR;
 		break;
@@ -112,7 +112,7 @@ static void uniphier_serial_out(struct uart_port *p, int offset, int value)
 		valshift = 8;
 		/* Divisor latch access bit does not exist. */
 		value &= ~UART_LCR_DLAB;
-		/* fall through */
+		fallthrough;
 	case UART_MCR:
 		offset = UNIPHIER_UART_LCR_MCR;
 		break;
* Unmerged path drivers/tty/serial/atmel_serial.c
diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c
index a909bfc275b8..64c775f39fb6 100644
--- a/drivers/tty/serial/omap-serial.c
+++ b/drivers/tty/serial/omap-serial.c
@@ -591,7 +591,6 @@ static irqreturn_t serial_omap_irq(int irq, void *dev_id)
 			transmit_chars(up, lsr);
 			break;
 		case UART_IIR_RX_TIMEOUT:
-			/* FALLTHROUGH */
 		case UART_IIR_RDI:
 			serial_omap_rdi(up, lsr);
 			break;
@@ -602,7 +601,6 @@ static irqreturn_t serial_omap_irq(int irq, void *dev_id)
 			/* simply try again */
 			break;
 		case UART_IIR_XOFF:
-			/* FALLTHROUGH */
 		default:
 			break;
 		}
* Unmerged path drivers/tty/serial/rda-uart.c
* Unmerged path drivers/tty/serial/serial-tegra.c
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 4e20e8a55007..9214fb7e620d 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -2011,7 +2011,7 @@ uart_set_options(struct uart_port *port, struct console *co,
 	switch (parity) {
 	case 'o': case 'O':
 		termios.c_cflag |= PARODD;
-		/*fall through*/
+		fallthrough;
 	case 'e': case 'E':
 		termios.c_cflag |= PARENB;
 		break;
diff --git a/drivers/tty/serial/sunsu.c b/drivers/tty/serial/sunsu.c
index 6cf3e9b0728f..15a25d009ce0 100644
--- a/drivers/tty/serial/sunsu.c
+++ b/drivers/tty/serial/sunsu.c
@@ -518,7 +518,7 @@ static void receive_kbd_ms_chars(struct uart_sunsu_port *up, int is_break)
 			switch (ret) {
 			case 2:
 				sunsu_change_mouse_baud(up);
-				/* fallthru */
+				fallthrough;
 			case 1:
 				break;
 
diff --git a/drivers/tty/serial/sunzilog.c b/drivers/tty/serial/sunzilog.c
index bc7af8b08a72..0bec3a4d7487 100644
--- a/drivers/tty/serial/sunzilog.c
+++ b/drivers/tty/serial/sunzilog.c
@@ -310,7 +310,7 @@ static void sunzilog_kbdms_receive_chars(struct uart_sunzilog_port *up,
 		switch (ret) {
 		case 2:
 			sunzilog_change_mouse_baud(up);
-			/* fallthru */
+			fallthrough;
 		case 1:
 			break;
 
diff --git a/drivers/tty/serial/xilinx_uartps.c b/drivers/tty/serial/xilinx_uartps.c
index 8a3e34234e98..06d448924c8b 100644
--- a/drivers/tty/serial/xilinx_uartps.c
+++ b/drivers/tty/serial/xilinx_uartps.c
@@ -525,7 +525,7 @@ static int cdns_uart_clk_notifier_cb(struct notifier_block *nb,
 
 		cdns_uart->baud = cdns_uart_set_baud_rate(cdns_uart->port,
 				cdns_uart->baud);
-		/* fall through */
+		fallthrough;
 	case ABORT_RATE_CHANGE:
 		if (!locked)
 			spin_lock_irqsave(&cdns_uart->port->lock, flags);
diff --git a/drivers/tty/tty_ioctl.c b/drivers/tty/tty_ioctl.c
index d99fec44036c..d043cc525fdb 100644
--- a/drivers/tty/tty_ioctl.c
+++ b/drivers/tty/tty_ioctl.c
@@ -866,7 +866,7 @@ static int __tty_perform_flush(struct tty_struct *tty, unsigned long arg)
 			ld->ops->flush_buffer(tty);
 			tty_unthrottle(tty);
 		}
-		/* fall through */
+		fallthrough;
 	case TCOFLUSH:
 		tty_driver_flush_buffer(tty);
 		break;
* Unmerged path drivers/tty/vt/vt.c
diff --git a/drivers/usb/c67x00/c67x00-sched.c b/drivers/usb/c67x00/c67x00-sched.c
index 633c52de3bb3..b43bb984d667 100644
--- a/drivers/usb/c67x00/c67x00-sched.c
+++ b/drivers/usb/c67x00/c67x00-sched.c
@@ -710,7 +710,8 @@ static int c67x00_add_ctrl_urb(struct c67x00_hcd *c67x00, struct urb *urb)
 			if (ret)
 				return ret;
 			break;
-		}		/* else fallthrough */
+		}
+		fallthrough;
 	case STATUS_STAGE:
 		pid = !usb_pipeout(urb->pipe) ? USB_PID_OUT : USB_PID_IN;
 		ret = c67x00_create_td(c67x00, urb, NULL, 0, pid, 1,
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6a311e7bf4a1..7e260c808761 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -727,7 +727,7 @@ static void hub_irq(struct urb *urb)
 		if ((++hub->nerrors < 10) || hub->error)
 			goto resubmit;
 		hub->error = status;
-		/* FALL THROUGH */
+		fallthrough;
 
 	/* let hub_wq handle things */
 	case 0:			/* we got data:  port status changed */
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index c2cf757ff11c..2280f8533dfe 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -624,9 +624,8 @@ static int dwc3_phy_setup(struct dwc3 *dwc)
 			if (!(reg & DWC3_GUSB2PHYCFG_ULPI_UTMI))
 				break;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case DWC3_GHWPARAMS3_HSPHY_IFC_ULPI:
-		/* FALLTHROUGH */
 	default:
 		break;
 	}
@@ -1363,7 +1362,7 @@ static void dwc3_check_params(struct dwc3 *dwc)
 	default:
 		dev_err(dev, "invalid maximum_speed parameter %d\n",
 			dwc->maximum_speed);
-		/* fall through */
+		fallthrough;
 	case USB_SPEED_UNKNOWN:
 		/* default to superspeed */
 		dwc->maximum_speed = USB_SPEED_SUPER;
* Unmerged path drivers/usb/gadget/function/f_mass_storage.c
* Unmerged path drivers/usb/gadget/udc/atmel_usba_udc.c
diff --git a/drivers/usb/gadget/udc/fsl_udc_core.c b/drivers/usb/gadget/udc/fsl_udc_core.c
index 20141c3096f6..7babddb73d6d 100644
--- a/drivers/usb/gadget/udc/fsl_udc_core.c
+++ b/drivers/usb/gadget/udc/fsl_udc_core.c
@@ -251,7 +251,7 @@ static int dr_controller_setup(struct fsl_udc *udc)
 		break;
 	case FSL_USB2_PHY_UTMI_WIDE:
 		portctrl |= PORTSCX_PTW_16BIT;
-		/* fall through */
+		fallthrough;
 	case FSL_USB2_PHY_UTMI:
 	case FSL_USB2_PHY_UTMI_DUAL:
 		if (udc->pdata->have_sysif_regs) {
diff --git a/drivers/usb/gadget/udc/pxa25x_udc.c b/drivers/usb/gadget/udc/pxa25x_udc.c
index d4be53559f2e..ed6a003bc1db 100644
--- a/drivers/usb/gadget/udc/pxa25x_udc.c
+++ b/drivers/usb/gadget/udc/pxa25x_udc.c
@@ -2341,12 +2341,12 @@ static int pxa25x_udc_probe(struct platform_device *pdev)
 	case PXA250_A0:
 	case PXA250_A1:
 		/* A0/A1 "not released"; ep 13, 15 unusable */
-		/* fall through */
+		fallthrough;
 	case PXA250_B2: case PXA210_B2:
 	case PXA250_B1: case PXA210_B1:
 	case PXA250_B0: case PXA210_B0:
 		/* OUT-DMA is broken ... */
-		/* fall through */
+		fallthrough;
 	case PXA250_C0: case PXA210_C0:
 		break;
 #elif	defined(CONFIG_ARCH_IXP4XX)
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index a87c0b26279e..3055d9abfec3 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1019,7 +1019,7 @@ static int isp116x_hub_control(struct usb_hcd *hcd,
 			spin_lock_irqsave(&isp116x->lock, flags);
 			isp116x_write_reg32(isp116x, HCRHSTATUS, RH_HS_OCIC);
 			spin_unlock_irqrestore(&isp116x->lock, flags);
-			/* fall through */
+			fallthrough;
 		case C_HUB_LOCAL_POWER:
 			DBG("C_HUB_LOCAL_POWER\n");
 			break;
@@ -1421,10 +1421,10 @@ static int isp116x_bus_suspend(struct usb_hcd *hcd)
 		isp116x_write_reg32(isp116x, HCCONTROL,
 				    (val & ~HCCONTROL_HCFS) |
 				    HCCONTROL_USB_RESET);
-		/* fall through */
+		fallthrough;
 	case HCCONTROL_USB_RESET:
 		ret = -EBUSY;
-		/* fall through */
+		fallthrough;
 	default:		/* HCCONTROL_USB_SUSPEND */
 		spin_unlock_irqrestore(&isp116x->lock, flags);
 		break;
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index e4e4f090f1e7..fba5edf68d30 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -957,7 +957,8 @@ static void quirk_usb_disable_ehci(struct pci_dev *pdev)
 			ehci_bios_handoff(pdev, op_reg_base, cap, offset);
 			break;
 		case 0: /* Illegal reserved cap, set cap=0 so we exit */
-			cap = 0; /* fall through */
+			cap = 0;
+			fallthrough;
 		default:
 			dev_warn(&pdev->dev,
 				 "EHCI: unrecognized capability %02x\n",
diff --git a/drivers/usb/host/xhci-dbgcap.c b/drivers/usb/host/xhci-dbgcap.c
index fcc5ac5ce8b1..ccb0156fcebe 100644
--- a/drivers/usb/host/xhci-dbgcap.c
+++ b/drivers/usb/host/xhci-dbgcap.c
@@ -699,7 +699,7 @@ static void dbc_handle_xfer_event(struct xhci_dbc *dbc, union xhci_trb *event)
 	switch (comp_code) {
 	case COMP_SUCCESS:
 		remain_length = 0;
-	/* FALLTHROUGH */
+		fallthrough;
 	case COMP_SHORT_PACKET:
 		status = 0;
 		break;
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index 50567d24ba1d..674a2cd56929 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -1483,7 +1483,7 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			bus_state->port_c_suspend &= ~(1 << wIndex);
-			/* fall through */
+			fallthrough;
 		case USB_PORT_FEAT_C_RESET:
 		case USB_PORT_FEAT_C_BH_PORT_RESET:
 		case USB_PORT_FEAT_C_CONNECTION:
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 3cd13da2c395..138ba4528dd3 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -1311,7 +1311,7 @@ static unsigned int xhci_get_endpoint_interval(struct usb_device *udev,
 			interval = xhci_parse_microframe_interval(udev, ep);
 			break;
 		}
-		/* Fall through - SS and HS isoc/int have same decoding */
+		fallthrough;	/* SS and HS isoc/int have same decoding */
 
 	case USB_SPEED_SUPER_PLUS:
 	case USB_SPEED_SUPER:
@@ -1331,7 +1331,7 @@ static unsigned int xhci_get_endpoint_interval(struct usb_device *udev,
 		 * since it uses the same rules as low speed interrupt
 		 * endpoints.
 		 */
-		/* fall through */
+		fallthrough;
 
 	case USB_SPEED_LOW:
 		if (usb_endpoint_xfer_int(&ep->desc) ||
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 200082c56dc0..167dae117f73 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2103,7 +2103,7 @@ static int process_ctrl_td(struct xhci_hcd *xhci, struct xhci_td *td,
 			break;
 		xhci_dbg(xhci, "TRB error %u, halted endpoint index = %u\n",
 			 trb_comp_code, ep_index);
-		/* else fall through */
+		fallthrough;
 	case COMP_STALL_ERROR:
 		/* Did we transfer part of the data (middle) phase? */
 		if (trb_type == TRB_DATA || trb_type == TRB_NORMAL)
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index d3d18ddae797..d4a8d0efbbc4 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -4625,7 +4625,7 @@ static unsigned long long xhci_calculate_intel_u1_timeout(
 			break;
 		}
 		/* Otherwise the calculation is the same as isoc eps */
-		/* fall through */
+		fallthrough;
 	case USB_ENDPOINT_XFER_ISOC:
 		timeout_ns = xhci_service_interval_to_ns(desc);
 		timeout_ns = DIV_ROUND_UP_ULL(timeout_ns * 105, 100);
diff --git a/drivers/usb/musb/cppi_dma.c b/drivers/usb/musb/cppi_dma.c
index b4d6d9bb3239..a80d7d718a60 100644
--- a/drivers/usb/musb/cppi_dma.c
+++ b/drivers/usb/musb/cppi_dma.c
@@ -975,7 +975,7 @@ static int cppi_channel_program(struct dma_channel *ch,
 		musb_dbg(musb, "%cX DMA%d not allocated!",
 				cppi_ch->transmit ? 'T' : 'R',
 				cppi_ch->index);
-		/* FALLTHROUGH */
+		fallthrough;
 	case MUSB_DMA_STATUS_FREE:
 		break;
 	}
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 9f5a4819a744..a53a05f59af8 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -711,7 +711,7 @@ static void musb_handle_intr_suspend(struct musb *musb, u8 devctl)
 	case OTG_STATE_B_IDLE:
 		if (!musb->is_active)
 			break;
-		/* fall through */
+		fallthrough;
 	case OTG_STATE_B_PERIPHERAL:
 		musb_g_suspend(musb);
 		musb->is_active = musb->g.b_hnp_enable;
@@ -831,9 +831,8 @@ static void musb_handle_intr_disconnect(struct musb *musb, u8 devctl)
 	case OTG_STATE_A_PERIPHERAL:
 		musb_hnp_stop(musb);
 		musb_root_disconnect(musb);
-		/* FALLTHROUGH */
+		fallthrough;
 	case OTG_STATE_B_WAIT_ACON:
-		/* FALLTHROUGH */
 	case OTG_STATE_B_PERIPHERAL:
 	case OTG_STATE_B_IDLE:
 		musb_g_disconnect(musb);
@@ -868,7 +867,7 @@ static void musb_handle_intr_reset(struct musb *musb)
 		switch (musb->xceiv->otg->state) {
 		case OTG_STATE_A_SUSPEND:
 			musb_g_reset(musb);
-			/* FALLTHROUGH */
+			fallthrough;
 		case OTG_STATE_A_WAIT_BCON:	/* OPT TD.4.7-900ms */
 			/* never use invalid T(a_wait_bcon) */
 			musb_dbg(musb, "HNP: in %s, %d msec timeout",
@@ -889,7 +888,7 @@ static void musb_handle_intr_reset(struct musb *musb)
 			break;
 		case OTG_STATE_B_IDLE:
 			musb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;
-			/* FALLTHROUGH */
+			fallthrough;
 		case OTG_STATE_B_PERIPHERAL:
 			musb_g_reset(musb);
 			break;
@@ -1332,7 +1331,7 @@ static int ep_config_from_table(struct musb *musb)
 	switch (fifo_mode) {
 	default:
 		fifo_mode = 0;
-		/* FALLTHROUGH */
+		fallthrough;
 	case 0:
 		cfg = mode_0_cfg;
 		n = ARRAY_SIZE(mode_0_cfg);
@@ -1874,7 +1873,7 @@ static void musb_pm_runtime_check_session(struct musb *musb)
 			musb->quirk_retries--;
 			return;
 		}
-		/* fall through */
+		fallthrough;
 	case MUSB_QUIRK_A_DISCONNECT_19:
 		if (musb->quirk_retries && !musb->flush_irq_work) {
 			musb_dbg(musb,
diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c
index 327d4f7baaf7..18b38dc577ce 100644
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@ -232,7 +232,7 @@ static int dsps_check_status(struct musb *musb, void *unused)
 			dsps_mod_timer_optional(glue);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 
 	case OTG_STATE_A_WAIT_BCON:
 		/* keep VBUS on for host-only mode */
@@ -242,7 +242,7 @@ static int dsps_check_status(struct musb *musb, void *unused)
 		}
 		musb_writeb(musb->mregs, MUSB_DEVCTL, 0);
 		skip_session = 1;
-		/* fall through */
+		fallthrough;
 
 	case OTG_STATE_A_IDLE:
 	case OTG_STATE_B_IDLE:
@@ -795,7 +795,7 @@ static int dsps_create_musb_pdev(struct dsps_glue *glue,
 	case USB_SPEED_SUPER:
 		dev_warn(dev, "ignore incorrect maximum_speed "
 				"(super-speed) setting in dts");
-		/* fall through */
+		fallthrough;
 	default:
 		config->maximum_speed = USB_SPEED_HIGH;
 	}
diff --git a/drivers/usb/musb/musb_gadget_ep0.c b/drivers/usb/musb/musb_gadget_ep0.c
index 91a5027b5c1f..3a75c30a4b16 100644
--- a/drivers/usb/musb/musb_gadget_ep0.c
+++ b/drivers/usb/musb/musb_gadget_ep0.c
@@ -739,7 +739,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *musb)
 			musb_writeb(mbase, MUSB_TESTMODE,
 					musb->test_mode_nr);
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 
 	case MUSB_EP0_STAGE_STATUSOUT:
 		/* end of sequence #1: write to host (TX state) */
@@ -771,7 +771,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *musb)
 		 */
 		retval = IRQ_HANDLED;
 		musb->ep0_state = MUSB_EP0_STAGE_SETUP;
-		/* FALLTHROUGH */
+		fallthrough;
 
 	case MUSB_EP0_STAGE_SETUP:
 setup:
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 5a44b70372d9..5b135f77a661 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -378,7 +378,7 @@ static void musb_advance_schedule(struct musb *musb, struct urb *urb,
 				qh = first_qh(head);
 				break;
 			}
-			/* fall through */
+			fallthrough;
 
 		case USB_ENDPOINT_XFER_ISOC:
 		case USB_ENDPOINT_XFER_INT:
@@ -1045,7 +1045,7 @@ static bool musb_h_ep0_continue(struct musb *musb, u16 len, struct urb *urb)
 			musb->ep0_stage = MUSB_EP0_OUT;
 			more = true;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case MUSB_EP0_OUT:
 		fifo_count = min_t(size_t, qh->maxpacket,
 				   urb->transfer_buffer_length -
@@ -2249,7 +2249,7 @@ static int musb_urb_enqueue(
 			interval = max_t(u8, epd->bInterval, 1);
 			break;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case USB_ENDPOINT_XFER_ISOC:
 		/* ISO always uses logarithmic encoding */
 		interval = min_t(u8, epd->bInterval, 16);
diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c
index a84ec27c4c12..985f0acdf144 100644
--- a/drivers/usb/musb/musb_virthub.c
+++ b/drivers/usb/musb/musb_virthub.c
@@ -211,7 +211,7 @@ void musb_root_disconnect(struct musb *musb)
 			musb->g.is_a_peripheral = 1;
 			break;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case OTG_STATE_A_HOST:
 		musb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;
 		musb->is_active = 0;
* Unmerged path drivers/usb/musb/omap2430.c
diff --git a/drivers/usb/musb/tusb6010.c b/drivers/usb/musb/tusb6010.c
index 39453287b5c3..4a36c2146973 100644
--- a/drivers/usb/musb/tusb6010.c
+++ b/drivers/usb/musb/tusb6010.c
@@ -464,7 +464,7 @@ static void musb_do_idle(struct timer_list *t)
 			dev_dbg(musb->controller, "Nothing connected %s, turning off VBUS\n",
 					usb_otg_state_string(musb->xceiv->otg->state));
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 	case OTG_STATE_A_IDLE:
 		tusb_musb_set_vbus(musb, 0);
 	default:
diff --git a/drivers/usb/storage/sddr55.c b/drivers/usb/storage/sddr55.c
index b8527c55335b..f630d6f9465c 100644
--- a/drivers/usb/storage/sddr55.c
+++ b/drivers/usb/storage/sddr55.c
@@ -591,7 +591,7 @@ static unsigned long sddr55_get_capacity(struct us_data *us) {
 	case 0x64:
 		info->pageshift = 8;
 		info->smallpageshift = 1;
-		/* fall through */
+		fallthrough;
 	case 0x5d: // 5d is a ROM card with pagesize 512.
 		return 0x00200000;
 
diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c
index fc6c8d598226..b38e2ac3cecd 100644
--- a/drivers/usb/storage/uas.c
+++ b/drivers/usb/storage/uas.c
@@ -687,7 +687,7 @@ static int uas_queuecommand_lck(struct scsi_cmnd *cmnd,
 		break;
 	case DMA_BIDIRECTIONAL:
 		cmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;
-		/* fall through */
+		fallthrough;
 	case DMA_TO_DEVICE:
 		cmdinfo->state |= ALLOC_DATA_OUT_URB | SUBMIT_DATA_OUT_URB;
 	case DMA_NONE:
diff --git a/drivers/usb/typec/tcpm/tcpci.c b/drivers/usb/typec/tcpm/tcpci.c
index bcec6fe26b96..f9f0af64da5f 100644
--- a/drivers/usb/typec/tcpm/tcpci.c
+++ b/drivers/usb/typec/tcpm/tcpci.c
@@ -163,7 +163,7 @@ static enum typec_cc_status tcpci_to_typec_cc(unsigned int cc, bool sink)
 	case 0x3:
 		if (sink)
 			return TYPEC_CC_RP_3_0;
-		/* fall through */
+		fallthrough;
 	case 0x0:
 	default:
 		return TYPEC_CC_OPEN;
diff --git a/drivers/vfio/pci/vfio_pci.c b/drivers/vfio/pci/vfio_pci.c
index 00cc893e8bdd..5e69192ab3f0 100644
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@ -910,7 +910,7 @@ static long vfio_pci_ioctl(void *device_data,
 		case VFIO_PCI_ERR_IRQ_INDEX:
 			if (pci_is_pcie(vdev->pdev))
 				break;
-		/* fall through */
+			fallthrough;
 		default:
 			return -EINVAL;
 		}
diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c
index 7c55ede3733d..fbd9475f54a9 100644
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@ -2463,7 +2463,7 @@ static void *vfio_iommu_type1_open(unsigned long arg)
 		break;
 	case VFIO_TYPE1_NESTING_IOMMU:
 		iommu->nesting = true;
-		/* fall through */
+		fallthrough;
 	case VFIO_TYPE1v2_IOMMU:
 		iommu->v2 = true;
 		break;
* Unmerged path drivers/video/backlight/adp8860_bl.c
* Unmerged path drivers/video/fbdev/acornfb.c
* Unmerged path drivers/video/fbdev/arcfb.c
diff --git a/drivers/video/fbdev/atmel_lcdfb.c b/drivers/video/fbdev/atmel_lcdfb.c
index 076d24afbd72..cdc3a2ddcffa 100644
--- a/drivers/video/fbdev/atmel_lcdfb.c
+++ b/drivers/video/fbdev/atmel_lcdfb.c
@@ -589,7 +589,7 @@ static int atmel_lcdfb_check_var(struct fb_var_screeninfo *var,
 	case 32:
 		var->transp.offset = 24;
 		var->transp.length = 8;
-		/* fall through */
+		fallthrough;
 	case 24:
 		if (pdata->lcd_wiring_mode == ATMEL_LCDC_WIRING_RGB) {
 			/* RGB:888 mode */
@@ -714,7 +714,7 @@ static int atmel_lcdfb_set_par(struct fb_info *info)
 		case 2: value |= ATMEL_LCDC_PIXELSIZE_2; break;
 		case 4: value |= ATMEL_LCDC_PIXELSIZE_4; break;
 		case 8: value |= ATMEL_LCDC_PIXELSIZE_8; break;
-		case 15: /* fall through */
+		case 15:
 		case 16: value |= ATMEL_LCDC_PIXELSIZE_16; break;
 		case 24: value |= ATMEL_LCDC_PIXELSIZE_24; break;
 		case 32: value |= ATMEL_LCDC_PIXELSIZE_32; break;
diff --git a/drivers/video/fbdev/aty/radeon_pm.c b/drivers/video/fbdev/aty/radeon_pm.c
index c03bc77b3658..0d23fbfb5574 100644
--- a/drivers/video/fbdev/aty/radeon_pm.c
+++ b/drivers/video/fbdev/aty/radeon_pm.c
@@ -1208,11 +1208,11 @@ static void radeon_pm_enable_dll_m10(struct radeonfb_info *rinfo)
 	case 1:
 		if (mc & 0x4)
 			break;
-		/* fall through */
+		fallthrough;
 	case 2:
 		dll_sleep_mask |= MDLL_R300_RDCK__MRDCKB_SLEEP;
 		dll_reset_mask |= MDLL_R300_RDCK__MRDCKB_RESET;
-		/* fall through */
+		fallthrough;
 	case 0:
 		dll_sleep_mask |= MDLL_R300_RDCK__MRDCKA_SLEEP;
 		dll_reset_mask |= MDLL_R300_RDCK__MRDCKA_RESET;
@@ -1221,7 +1221,7 @@ static void radeon_pm_enable_dll_m10(struct radeonfb_info *rinfo)
 	case 1:
 		if (!(mc & 0x4))
 			break;
-		/* fall through */
+		fallthrough;
 	case 2:
 		dll_sleep_mask |= MDLL_R300_RDCK__MRDCKD_SLEEP;
 		dll_reset_mask |= MDLL_R300_RDCK__MRDCKD_RESET;
diff --git a/drivers/video/fbdev/cirrusfb.c b/drivers/video/fbdev/cirrusfb.c
index b3be06dd2908..2fb865b99924 100644
--- a/drivers/video/fbdev/cirrusfb.c
+++ b/drivers/video/fbdev/cirrusfb.c
@@ -1477,11 +1477,11 @@ static void init_vgachip(struct fb_info *info)
 		mdelay(100);
 		/* mode */
 		vga_wgfx(cinfo->regbase, CL_GR31, 0x00);
-		/* fall through */
+		fallthrough;
 	case BT_GD5480:
 		/* from Klaus' NetBSD driver: */
 		vga_wgfx(cinfo->regbase, CL_GR2F, 0x00);
-		/* fall through */
+		fallthrough;
 	case BT_ALPINE:
 		/* put blitter into 542x compat */
 		vga_wgfx(cinfo->regbase, CL_GR33, 0x00);
* Unmerged path drivers/video/fbdev/controlfb.c
* Unmerged path drivers/video/fbdev/core/fbmem.c
* Unmerged path drivers/video/fbdev/fsl-diu-fb.c
diff --git a/drivers/video/fbdev/gxt4500.c b/drivers/video/fbdev/gxt4500.c
index f438546290df..8b43712f040f 100644
--- a/drivers/video/fbdev/gxt4500.c
+++ b/drivers/video/fbdev/gxt4500.c
@@ -533,7 +533,7 @@ static int gxt4500_setcolreg(unsigned int reg, unsigned int red,
 			break;
 		case DFA_PIX_32BIT:
 			val |= (reg << 24);
-			/* fall through */
+			fallthrough;
 		case DFA_PIX_24BIT:
 			val |= (reg << 16) | (reg << 8);
 			break;
diff --git a/drivers/video/fbdev/hyperv_fb.c b/drivers/video/fbdev/hyperv_fb.c
index 622a20a4a8b4..08ec98fc75f2 100644
--- a/drivers/video/fbdev/hyperv_fb.c
+++ b/drivers/video/fbdev/hyperv_fb.c
@@ -574,13 +574,13 @@ static int synthvid_connect_vsp(struct hv_device *hdev)
 		ret = synthvid_negotiate_ver(hdev, SYNTHVID_VERSION_WIN10);
 		if (!ret)
 			break;
-		/* Fallthrough */
+		fallthrough;
 	case VERSION_WIN8:
 	case VERSION_WIN8_1:
 		ret = synthvid_negotiate_ver(hdev, SYNTHVID_VERSION_WIN8);
 		if (!ret)
 			break;
-		/* Fallthrough */
+		fallthrough;
 	case VERSION_WS2008:
 	case VERSION_WIN7:
 		ret = synthvid_negotiate_ver(hdev, SYNTHVID_VERSION_WIN7);
* Unmerged path drivers/video/fbdev/i740fb.c
diff --git a/drivers/video/fbdev/mmp/fb/mmpfb.c b/drivers/video/fbdev/mmp/fb/mmpfb.c
index ee212be67dc6..07b8a86c4881 100644
--- a/drivers/video/fbdev/mmp/fb/mmpfb.c
+++ b/drivers/video/fbdev/mmp/fb/mmpfb.c
@@ -103,8 +103,6 @@ static int var_to_pixfmt(struct fb_var_screeninfo *var)
 			else
 				return PIXFMT_BGR888UNPACK;
 		}
-
-		/* fall through */
 	}
 
 	return -EINVAL;
diff --git a/drivers/video/fbdev/nvidia/nv_hw.c b/drivers/video/fbdev/nvidia/nv_hw.c
index 8335da4ca30e..9b0a324bb1b4 100644
--- a/drivers/video/fbdev/nvidia/nv_hw.c
+++ b/drivers/video/fbdev/nvidia/nv_hw.c
@@ -896,7 +896,7 @@ void NVCalcStateExt(struct nvidia_par *par,
 		if (!par->FlatPanel)
 			state->control = NV_RD32(par->PRAMDAC0, 0x0580) &
 				0xeffffeff;
-		/* fallthrough */
+		fallthrough;
 	case NV_ARCH_10:
 	case NV_ARCH_20:
 	case NV_ARCH_30:
* Unmerged path drivers/video/fbdev/offb.c
diff --git a/drivers/video/fbdev/omap/lcdc.c b/drivers/video/fbdev/omap/lcdc.c
index 938cba0d24ae..b4d20edf71f6 100644
--- a/drivers/video/fbdev/omap/lcdc.c
+++ b/drivers/video/fbdev/omap/lcdc.c
@@ -341,13 +341,13 @@ static int omap_lcdc_setup_plane(int plane, int channel_out,
 			lcdc.bpp = 12;
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	case OMAPFB_COLOR_YUV422:
 		if (lcdc.ext_mode) {
 			lcdc.bpp = 16;
 			break;
 		}
-		/* fallthrough */
+		fallthrough;
 	default:
 		/* FIXME: other BPPs.
 		 * bpp1: code  0,     size 256
* Unmerged path drivers/video/fbdev/omap/omapfb_main.c
* Unmerged path drivers/video/fbdev/omap2/omapfb/dss/dispc.c
diff --git a/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c b/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c
index 6ab0a9a178c0..7520b5c9fbeb 100644
--- a/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c
+++ b/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c
@@ -769,7 +769,7 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 			r = -ENODEV;
 			break;
 		}
-		/* FALLTHROUGH */
+		fallthrough;
 
 	case OMAPFB_WAITFORVSYNC:
 		DBG("ioctl WAITFORVSYNC\n");
* Unmerged path drivers/video/fbdev/omap2/omapfb/omapfb-main.c
* Unmerged path drivers/video/fbdev/pm2fb.c
diff --git a/drivers/video/fbdev/pxa168fb.c b/drivers/video/fbdev/pxa168fb.c
index def3a501acd6..0d8e527cb5d6 100644
--- a/drivers/video/fbdev/pxa168fb.c
+++ b/drivers/video/fbdev/pxa168fb.c
@@ -60,8 +60,6 @@ static int determine_best_pix_fmt(struct fb_var_screeninfo *var)
 			else
 				return PIX_FMT_BGR1555;
 		}
-
-		/* fall through */
 	}
 
 	/*
@@ -87,8 +85,6 @@ static int determine_best_pix_fmt(struct fb_var_screeninfo *var)
 			else
 				return PIX_FMT_BGR888UNPACK;
 		}
-
-		/* fall through */
 	}
 
 	return -EINVAL;
diff --git a/drivers/video/fbdev/pxafb.c b/drivers/video/fbdev/pxafb.c
index 76722a59f55e..931f874912c9 100644
--- a/drivers/video/fbdev/pxafb.c
+++ b/drivers/video/fbdev/pxafb.c
@@ -1598,7 +1598,7 @@ static void set_ctrlr_state(struct pxafb_info *fbi, u_int state)
 		 */
 		if (old_state != C_DISABLE_PM)
 			break;
-		/* fall through */
+		fallthrough;
 
 	case C_ENABLE:
 		/*
diff --git a/drivers/video/fbdev/riva/fbdev.c b/drivers/video/fbdev/riva/fbdev.c
index cc242ba057d3..4a2c035c510b 100644
--- a/drivers/video/fbdev/riva/fbdev.c
+++ b/drivers/video/fbdev/riva/fbdev.c
@@ -1097,7 +1097,7 @@ static int rivafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 		break;
 	case 9 ... 15:
 		var->green.length = 5;
-		/* fall through */
+		fallthrough;
 	case 16:
 		var->bits_per_pixel = 16;
 		/* The Riva128 supports RGB555 only */
* Unmerged path drivers/video/fbdev/s3c-fb.c
diff --git a/drivers/video/fbdev/sa1100fb.c b/drivers/video/fbdev/sa1100fb.c
index 15ae50063296..6a67f13ed36f 100644
--- a/drivers/video/fbdev/sa1100fb.c
+++ b/drivers/video/fbdev/sa1100fb.c
@@ -935,7 +935,7 @@ static void set_ctrlr_state(struct sa1100fb_info *fbi, u_int state)
 		 */
 		if (old_state != C_DISABLE_PM)
 			break;
-		/* fall through */
+		fallthrough;
 
 	case C_ENABLE:
 		/*
diff --git a/drivers/video/fbdev/savage/savagefb_driver.c b/drivers/video/fbdev/savage/savagefb_driver.c
index c09d7426cd92..e7b620ceb723 100644
--- a/drivers/video/fbdev/savage/savagefb_driver.c
+++ b/drivers/video/fbdev/savage/savagefb_driver.c
@@ -1861,7 +1861,7 @@ static int savage_init_hw(struct savagefb_par *par)
 		if ((vga_in8(0x3d5, par) & 0xC0) == (0x01 << 6))
 			RamSavage4[1] = 8;
 
-		/*FALLTHROUGH*/
+		fallthrough;
 
 	case S3_SAVAGE2000:
 		videoRam = RamSavage4[(config1 & 0xE0) >> 5] * 1024;
* Unmerged path drivers/video/fbdev/sh_mobile_lcdcfb.c
diff --git a/drivers/video/fbdev/sis/sis_main.c b/drivers/video/fbdev/sis/sis_main.c
index 20aff9005978..1c01d2f1c25c 100644
--- a/drivers/video/fbdev/sis/sis_main.c
+++ b/drivers/video/fbdev/sis/sis_main.c
@@ -1753,7 +1753,7 @@ static int	sisfb_ioctl(struct fb_info *info, unsigned int cmd,
 		if(ivideo->warncount++ < 10)
 			printk(KERN_INFO
 				"sisfb: Deprecated ioctl call received - update your application!\n");
-		/* fall through */
+		fallthrough;
 	   case SISFB_GET_INFO:  /* For communication with X driver */
 		ivideo->sisfb_infoblock.sisfb_id         = SISFB_ID;
 		ivideo->sisfb_infoblock.sisfb_version    = VER_MAJOR;
@@ -1807,7 +1807,7 @@ static int	sisfb_ioctl(struct fb_info *info, unsigned int cmd,
 		if(ivideo->warncount++ < 10)
 			printk(KERN_INFO
 				"sisfb: Deprecated ioctl call received - update your application!\n");
-		/* fall through */
+		fallthrough;
 	   case SISFB_GET_VBRSTATUS:
 		if(sisfb_CheckVBRetrace(ivideo))
 			return put_user((u32)1, argp);
@@ -1818,7 +1818,7 @@ static int	sisfb_ioctl(struct fb_info *info, unsigned int cmd,
 		if(ivideo->warncount++ < 10)
 			printk(KERN_INFO
 				"sisfb: Deprecated ioctl call received - update your application!\n");
-		/* fall through */
+		fallthrough;
 	   case SISFB_GET_AUTOMAXIMIZE:
 		if(ivideo->sisfb_max)
 			return put_user((u32)1, argp);
@@ -1829,7 +1829,7 @@ static int	sisfb_ioctl(struct fb_info *info, unsigned int cmd,
 		if(ivideo->warncount++ < 10)
 			printk(KERN_INFO
 				"sisfb: Deprecated ioctl call received - update your application!\n");
-		/* fall through */
+		fallthrough;
 	   case SISFB_SET_AUTOMAXIMIZE:
 		if(get_user(gpu32, argp))
 			return -EFAULT;
diff --git a/drivers/video/fbdev/sm501fb.c b/drivers/video/fbdev/sm501fb.c
index dde52d027416..3427a9e3f9f6 100644
--- a/drivers/video/fbdev/sm501fb.c
+++ b/drivers/video/fbdev/sm501fb.c
@@ -1008,7 +1008,7 @@ static int sm501fb_blank_crt(int blank_mode, struct fb_info *info)
 	case FB_BLANK_POWERDOWN:
 		ctrl &= ~SM501_DC_CRT_CONTROL_ENABLE;
 		sm501_misc_control(fbi->dev->parent, SM501_MISC_DAC_POWER, 0);
-		/* fall through */
+		fallthrough;
 
 	case FB_BLANK_NORMAL:
 		ctrl |= SM501_DC_CRT_CONTROL_BLANK;
* Unmerged path drivers/video/fbdev/stifb.c
* Unmerged path drivers/video/fbdev/tdfxfb.c
* Unmerged path drivers/video/fbdev/via/lcd.c
* Unmerged path drivers/video/fbdev/xen-fbfront.c
* Unmerged path drivers/watchdog/sc1200wdt.c
diff --git a/drivers/watchdog/wdrtas.c b/drivers/watchdog/wdrtas.c
index 0240c60d14e3..a163a5c5008c 100644
--- a/drivers/watchdog/wdrtas.c
+++ b/drivers/watchdog/wdrtas.c
@@ -345,7 +345,7 @@ static long wdrtas_ioctl(struct file *file, unsigned int cmd,
 			wdrtas_interval = i;
 		else
 			wdrtas_interval = wdrtas_get_interval(i);
-		/* fallthrough */
+		fallthrough;
 
 	case WDIOC_GETTIMEOUT:
 		return put_user(wdrtas_interval, argp);
diff --git a/drivers/xen/pvcalls-front.c b/drivers/xen/pvcalls-front.c
index 2f11ca72a281..3ff658c659bd 100644
--- a/drivers/xen/pvcalls-front.c
+++ b/drivers/xen/pvcalls-front.c
@@ -1227,7 +1227,7 @@ static void pvcalls_front_changed(struct xenbus_device *dev,
 		if (dev->state == XenbusStateClosed)
 			break;
 		/* Missed the backend's CLOSING state */
-		/* fall through */
+		fallthrough;
 	case XenbusStateClosing:
 		xenbus_frontend_closed(dev);
 		break;
diff --git a/drivers/xen/xen-acpi-memhotplug.c b/drivers/xen/xen-acpi-memhotplug.c
index 4fc886cd5586..39c2b28915c2 100644
--- a/drivers/xen/xen-acpi-memhotplug.c
+++ b/drivers/xen/xen-acpi-memhotplug.c
@@ -239,7 +239,7 @@ static void acpi_memory_device_notify(acpi_handle handle, u32 event, void *data)
 	case ACPI_NOTIFY_BUS_CHECK:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			"\nReceived BUS CHECK notification for device\n"));
-		/* Fall Through */
+		fallthrough;
 	case ACPI_NOTIFY_DEVICE_CHECK:
 		if (event == ACPI_NOTIFY_DEVICE_CHECK)
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
* Unmerged path drivers/xen/xen-pciback/xenbus.c
* Unmerged path drivers/xen/xen-scsiback.c
diff --git a/drivers/xen/xenbus/xenbus_probe_frontend.c b/drivers/xen/xenbus/xenbus_probe_frontend.c
index 07896f4b2736..9181a584e6d1 100644
--- a/drivers/xen/xenbus/xenbus_probe_frontend.c
+++ b/drivers/xen/xenbus/xenbus_probe_frontend.c
@@ -379,12 +379,12 @@ static void xenbus_reset_frontend(char *fe, char *be, int be_state)
 	case XenbusStateConnected:
 		xenbus_printf(XBT_NIL, fe, "state", "%d", XenbusStateClosing);
 		xenbus_reset_wait_for_backend(be, XenbusStateClosing);
-		/* fall through */
+		fallthrough;
 
 	case XenbusStateClosing:
 		xenbus_printf(XBT_NIL, fe, "state", "%d", XenbusStateClosed);
 		xenbus_reset_wait_for_backend(be, XenbusStateClosed);
-		/* fall through */
+		fallthrough;
 
 	case XenbusStateClosed:
 		xenbus_printf(XBT_NIL, fe, "state", "%d", XenbusStateInitialising);
* Unmerged path fs/9p/vfs_file.c
* Unmerged path fs/adfs/dir_f.c
diff --git a/fs/affs/inode.c b/fs/affs/inode.c
index 73598bff8506..ec18bb070bf4 100644
--- a/fs/affs/inode.c
+++ b/fs/affs/inode.c
@@ -93,7 +93,7 @@ struct inode *affs_iget(struct super_block *sb, unsigned long ino)
 	case ST_ROOT:
 		inode->i_uid = sbi->s_uid;
 		inode->i_gid = sbi->s_gid;
-		/* fall through */
+		fallthrough;
 	case ST_USERDIR:
 		if (be32_to_cpu(tail->stype) == ST_USERDIR ||
 		    affs_test_opt(sbi->s_flags, SF_SETMODE)) {
diff --git a/fs/affs/super.c b/fs/affs/super.c
index 3accc6daec68..862320b5d944 100644
--- a/fs/affs/super.c
+++ b/fs/affs/super.c
@@ -475,7 +475,7 @@ static int affs_fill_super(struct super_block *sb, void *data, int silent)
 	case MUFS_INTLFFS:
 	case MUFS_DCFFS:
 		affs_set_opt(sbi->s_flags, SF_MUFS);
-		/* fall thru */
+		fallthrough;
 	case FS_INTLFFS:
 	case FS_DCFFS:
 		affs_set_opt(sbi->s_flags, SF_INTL);
@@ -487,7 +487,7 @@ static int affs_fill_super(struct super_block *sb, void *data, int silent)
 		break;
 	case MUFS_OFS:
 		affs_set_opt(sbi->s_flags, SF_MUFS);
-		/* fall through */
+		fallthrough;
 	case FS_OFS:
 		affs_set_opt(sbi->s_flags, SF_OFS);
 		sb->s_flags |= SB_NOEXEC;
@@ -495,7 +495,7 @@ static int affs_fill_super(struct super_block *sb, void *data, int silent)
 	case MUFS_DCOFS:
 	case MUFS_INTLOFS:
 		affs_set_opt(sbi->s_flags, SF_MUFS);
-		/* fall through */
+		fallthrough;
 	case FS_DCOFS:
 	case FS_INTLOFS:
 		affs_set_opt(sbi->s_flags, SF_INTL);
* Unmerged path fs/afs/cmservice.c
* Unmerged path fs/afs/file.c
* Unmerged path fs/afs/flock.c
* Unmerged path fs/afs/fsclient.c
* Unmerged path fs/afs/misc.c
* Unmerged path fs/afs/rotate.c
* Unmerged path fs/afs/rxrpc.c
* Unmerged path fs/afs/vlclient.c
diff --git a/fs/afs/write.c b/fs/afs/write.c
index 8b39e6ebb40b..11ea37b0675e 100644
--- a/fs/afs/write.c
+++ b/fs/afs/write.c
@@ -509,7 +509,7 @@ static int afs_write_back_from_locked_page(struct address_space *mapping,
 
 	default:
 		pr_notice("kAFS: Unexpected error from FS.StoreData %d\n", ret);
-		/* Fall through */
+		fallthrough;
 	case -EACCES:
 	case -EPERM:
 	case -ENOKEY:
* Unmerged path fs/afs/yfsclient.c
diff --git a/fs/aio.c b/fs/aio.c
index 64d7c2f91509..c42985428abd 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1469,7 +1469,7 @@ static inline void aio_rw_done(struct kiocb *req, ssize_t ret)
 		 * may be already running. Just fail this IO with EINTR.
 		 */
 		ret = -EINTR;
-		/*FALLTHRU*/
+		fallthrough;
 	default:
 		aio_complete_rw(req, ret, 0);
 	}
diff --git a/fs/buffer.c b/fs/buffer.c
index 121ff7d3ea55..e176c56bc60d 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -1925,7 +1925,7 @@ iomap_to_bh(struct inode *inode, sector_t block, struct buffer_head *bh,
 		 */
 		set_buffer_new(bh);
 		set_buffer_unwritten(bh);
-		/* FALLTHRU */
+		fallthrough;
 	case IOMAP_MAPPED:
 		if ((iomap->flags & IOMAP_F_NEW) ||
 		    offset >= i_size_read(inode))
diff --git a/fs/ceph/dir.c b/fs/ceph/dir.c
index 07ecac17dbc2..e76806d06efd 100644
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@ -1732,7 +1732,7 @@ static int ceph_d_revalidate(struct dentry *dentry, unsigned int flags)
 			case -ENOENT:
 				if (d_really_is_negative(dentry))
 					valid = 1;
-				/* Fallthrough */
+				fallthrough;
 			default:
 				break;
 			}
diff --git a/fs/ceph/file.c b/fs/ceph/file.c
index f4b24736c425..7cd58b46c292 100644
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -250,7 +250,7 @@ static int ceph_init_file(struct inode *inode, struct file *file, int fmode)
 	case S_IFREG:
 		ceph_fscache_register_inode_cookie(inode);
 		ceph_fscache_file_set_cookie(inode, file);
-		/* fall through */
+		fallthrough;
 	case S_IFDIR:
 		ret = ceph_init_file_info(inode, file, fmode,
 						S_ISDIR(inode->i_mode));
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index dc62e2620cc8..1bb02bce0145 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -691,7 +691,7 @@ should_set_ext_sec_flag(enum securityEnum sectype)
 		if (global_secflags &
 		    (CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP))
 			return true;
-		/* Fallthrough */
+		fallthrough;
 	default:
 		return false;
 	}
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 5e6f0ec47a02..d69b84d9c15f 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -1377,25 +1377,25 @@ static int cifs_parse_security_flavors(char *value,
 		return 1;
 	case Opt_sec_krb5i:
 		vol->sign = true;
-		/* Fallthrough */
+		fallthrough;
 	case Opt_sec_krb5:
 		vol->sectype = Kerberos;
 		break;
 	case Opt_sec_ntlmsspi:
 		vol->sign = true;
-		/* Fallthrough */
+		fallthrough;
 	case Opt_sec_ntlmssp:
 		vol->sectype = RawNTLMSSP;
 		break;
 	case Opt_sec_ntlmi:
 		vol->sign = true;
-		/* Fallthrough */
+		fallthrough;
 	case Opt_ntlm:
 		vol->sectype = NTLM;
 		break;
 	case Opt_sec_ntlmv2i:
 		vol->sign = true;
-		/* Fallthrough */
+		fallthrough;
 	case Opt_sec_ntlmv2:
 		vol->sectype = NTLMv2;
 		break;
@@ -2186,7 +2186,7 @@ cifs_parse_mount_options(const char *mountdata, const char *devname,
 				vol->password = NULL;
 				break;
 			}
-			/* Fallthrough - to Opt_pass below.*/
+			fallthrough;	/* to Opt_pass below */
 		case Opt_pass:
 			/* Obtain the value string */
 			value = strchr(data, '=');
diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c
index 5d05bd2822d2..758d77b5cbca 100644
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@ -798,7 +798,7 @@ cifs_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)
 			if ((server->sec_kerberos || server->sec_mskerberos) &&
 			    (global_secflags & CIFSSEC_MAY_KRB5))
 				return Kerberos;
-			/* Fallthrough */
+			fallthrough;
 		default:
 			return Unspecified;
 		}
@@ -815,7 +815,7 @@ cifs_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)
 		default:
 			break;
 		}
-		/* Fallthrough - to attempt LANMAN authentication next */
+		fallthrough;	/* to attempt LANMAN authentication next */
 	case CIFS_NEGFLAVOR_LANMAN:
 		switch (requested) {
 		case LANMAN:
@@ -823,7 +823,7 @@ cifs_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)
 		case Unspecified:
 			if (global_secflags & CIFSSEC_MAY_LANMAN)
 				return LANMAN;
-			/* Fallthrough */
+			fallthrough;
 		default:
 			return Unspecified;
 		}
diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c
index 2f4cdd290c46..a2fefb112209 100644
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@ -1212,7 +1212,7 @@ smb2_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)
 		if ((server->sec_kerberos || server->sec_mskerberos) &&
 			(global_secflags & CIFSSEC_MAY_KRB5))
 			return Kerberos;
-		/* Fallthrough */
+		fallthrough;
 	default:
 		return Unspecified;
 	}
diff --git a/fs/configfs/dir.c b/fs/configfs/dir.c
index 042122fab0bb..331c6a34bf29 100644
--- a/fs/configfs/dir.c
+++ b/fs/configfs/dir.c
@@ -1690,11 +1690,11 @@ static loff_t configfs_dir_lseek(struct file *file, loff_t offset, int whence)
 	switch (whence) {
 		case 1:
 			offset += file->f_pos;
-			/* fall through */
+			fallthrough;
 		case 0:
 			if (offset >= 0)
 				break;
-			/* fall through */
+			fallthrough;
 		default:
 			return -EINVAL;
 	}
diff --git a/fs/dax.c b/fs/dax.c
index 77f127522b8d..605309a7d772 100644
--- a/fs/dax.c
+++ b/fs/dax.c
@@ -1379,7 +1379,7 @@ static vm_fault_t dax_iomap_pte_fault(struct vm_fault *vmf, pfn_t *pfnp,
 			ret = dax_load_hole(&xas, mapping, &entry, vmf);
 			goto finish_iomap;
 		}
-		/*FALLTHRU*/
+		fallthrough;
 	default:
 		WARN_ON_ONCE(1);
 		error = -EIO;
diff --git a/fs/dlm/lock.c b/fs/dlm/lock.c
index cc91963683de..8f5a6ec47bd8 100644
--- a/fs/dlm/lock.c
+++ b/fs/dlm/lock.c
@@ -5816,7 +5816,7 @@ int dlm_user_request(struct dlm_ls *ls, struct dlm_user_args *ua,
 		break;
 	case -EAGAIN:
 		error = 0;
-		/* fall through */
+		fallthrough;
 	default:
 		__put_lkb(ls, lkb);
 		goto out;
* Unmerged path fs/erofs/zmap.c
* Unmerged path fs/ext2/inode.c
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index 364e2de7bc06..c658b4a955cc 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -605,7 +605,7 @@ static int parse_options(char *options, struct super_block *sb,
 		case Opt_xip:
 			ext2_msg(sb, KERN_INFO, "use dax instead of xip");
 			set_opt(opts->s_mount_opt, XIP);
-			/* Fall through */
+			fallthrough;
 		case Opt_dax:
 #ifdef CONFIG_FS_DAX
 			ext2_msg(sb, KERN_WARNING,
* Unmerged path fs/f2fs/f2fs.h
diff --git a/fs/f2fs/node.c b/fs/f2fs/node.c
index 79192c1112d8..0e031cfbaecc 100644
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@ -517,10 +517,10 @@ pgoff_t f2fs_get_next_page_offset(struct dnode_of_data *dn, pgoff_t pgofs)
 	switch (dn->max_level) {
 	case 3:
 		base += 2 * indirect_blks;
-		/* fall through */
+		fallthrough;
 	case 2:
 		base += 2 * direct_blks;
-		/* fall through */
+		fallthrough;
 	case 1:
 		base += direct_index;
 		break;
* Unmerged path fs/fcntl.c
* Unmerged path fs/fs_context.c
* Unmerged path fs/fsopen.c
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index 850e788ce156..b2be3c54c8fa 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -750,7 +750,7 @@ static int gfs2_iomap_alloc(struct inode *inode, struct iomap *iomap,
 			}
 			if (n == 0)
 				break;
-		/* fall through - To branching from existing tree */
+			fallthrough;	/* To branching from existing tree */
 		case ALLOC_GROW_DEPTH:
 			if (i > 1 && i < mp->mp_fheight)
 				gfs2_trans_add_meta(ip->i_gl, mp->mp_bh[i-1]);
@@ -761,7 +761,7 @@ static int gfs2_iomap_alloc(struct inode *inode, struct iomap *iomap,
 				state = ALLOC_DATA;
 			if (n == 0)
 				break;
-		/* fall through - To tree complete, adding data blocks */
+			fallthrough;	/* To tree complete, adding data blocks */
 		case ALLOC_DATA:
 			BUG_ON(n > dblks);
 			BUG_ON(mp->mp_bh[end_of_metadata] == NULL);
diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index 4c31ba41c81a..1c0b11ba1fb6 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -1602,7 +1602,7 @@ static int gfs2_quota_get_state(struct super_block *sb, struct qc_state *state)
 	case GFS2_QUOTA_ON:
 		state->s_state[USRQUOTA].flags |= QCI_LIMITS_ENFORCED;
 		state->s_state[GRPQUOTA].flags |= QCI_LIMITS_ENFORCED;
-		/*FALLTHRU*/
+		fallthrough;
 	case GFS2_QUOTA_ACCOUNT:
 		state->s_state[USRQUOTA].flags |= QCI_ACCT_ENABLED |
 						  QCI_SYSFILE;
diff --git a/fs/hfsplus/wrapper.c b/fs/hfsplus/wrapper.c
index 61eec628805d..0350dc7821bf 100644
--- a/fs/hfsplus/wrapper.c
+++ b/fs/hfsplus/wrapper.c
@@ -195,7 +195,7 @@ int hfsplus_read_wrapper(struct super_block *sb)
 	switch (sbi->s_vhdr->signature) {
 	case cpu_to_be16(HFSPLUS_VOLHEAD_SIGX):
 		set_bit(HFSPLUS_SB_HFSX, &sbi->flags);
-		/*FALLTHRU*/
+		fallthrough;
 	case cpu_to_be16(HFSPLUS_VOLHEAD_SIG):
 		break;
 	case cpu_to_be16(HFSP_WRAP_MAGIC):
diff --git a/fs/io_uring.c b/fs/io_uring.c
index f8c8b0e1de21..ccab3086aac0 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -2144,7 +2144,7 @@ static inline void io_rw_done(struct kiocb *kiocb, ssize_t ret)
 		 * IO with EINTR.
 		 */
 		ret = -EINTR;
-		/* fall through */
+		fallthrough;
 	default:
 		kiocb->ki_complete(kiocb, ret, 0);
 	}
diff --git a/fs/iomap/seek.c b/fs/iomap/seek.c
index 89f61d93c0bc..107ee80c3568 100644
--- a/fs/iomap/seek.c
+++ b/fs/iomap/seek.c
@@ -127,7 +127,7 @@ iomap_seek_hole_actor(struct inode *inode, loff_t offset, loff_t length,
 						   SEEK_HOLE);
 		if (offset < 0)
 			return length;
-		/* fall through */
+		fallthrough;
 	case IOMAP_HOLE:
 		*(loff_t *)data = offset;
 		return 0;
@@ -175,7 +175,7 @@ iomap_seek_data_actor(struct inode *inode, loff_t offset, loff_t length,
 						   SEEK_DATA);
 		if (offset < 0)
 			return length;
-		/*FALLTHRU*/
+		fallthrough;
 	default:
 		*(loff_t *)data = offset;
 		return 0;
diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c
index 438c8fe07907..d83f2a01c5f1 100644
--- a/fs/jffs2/fs.c
+++ b/fs/jffs2/fs.c
@@ -340,7 +340,7 @@ struct inode *jffs2_iget(struct super_block *sb, unsigned long ino)
 			rdev = old_decode_dev(je16_to_cpu(jdev.old_id));
 		else
 			rdev = new_decode_dev(je32_to_cpu(jdev.new_id));
-		/* fall through */
+		fallthrough;
 
 	case S_IFSOCK:
 	case S_IFIFO:
diff --git a/fs/jffs2/readinode.c b/fs/jffs2/readinode.c
index 389ea53ea487..9d2175f6bf63 100644
--- a/fs/jffs2/readinode.c
+++ b/fs/jffs2/readinode.c
@@ -1273,7 +1273,7 @@ static int jffs2_do_read_inode_internal(struct jffs2_sb_info *c,
 			dbg_readinode("symlink's target '%s' cached\n", f->target);
 		}
 
-		/* fall through... */
+		fallthrough;
 
 	case S_IFBLK:
 	case S_IFCHR:
diff --git a/fs/libfs.c b/fs/libfs.c
index df5499c95c24..919ae728b1af 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -137,11 +137,11 @@ loff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)
 	switch (whence) {
 		case 1:
 			offset += file->f_pos;
-			/* fall through */
+			fallthrough;
 		case 0:
 			if (offset >= 0)
 				break;
-			/* fall through */
+			fallthrough;
 		default:
 			return -EINVAL;
 	}
diff --git a/fs/locks.c b/fs/locks.c
index 184c12e20ec1..af4f6f6ce579 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1352,7 +1352,7 @@ static void lease_clear_pending(struct file_lock *fl, int arg)
 	switch (arg) {
 	case F_UNLCK:
 		fl->fl_flags &= ~FL_UNLOCK_PENDING;
-		/* fall through */
+		fallthrough;
 	case F_RDLCK:
 		fl->fl_flags &= ~FL_DOWNGRADE_PENDING;
 	}
@@ -2302,7 +2302,7 @@ int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,
 		cmd = F_SETLKW;
 		file_lock->fl_flags |= FL_OFDLCK;
 		file_lock->fl_owner = filp;
-		/* Fallthrough */
+		fallthrough;
 	case F_SETLKW:
 		file_lock->fl_flags |= FL_SLEEP;
 	}
@@ -2433,7 +2433,7 @@ int fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,
 		cmd = F_SETLKW64;
 		file_lock->fl_flags |= FL_OFDLCK;
 		file_lock->fl_owner = filp;
-		/* Fallthrough */
+		fallthrough;
 	case F_SETLKW64:
 		file_lock->fl_flags |= FL_SLEEP;
 	}
diff --git a/fs/nfs/blocklayout/blocklayout.c b/fs/nfs/blocklayout/blocklayout.c
index d1a0e2c8b1b4..08108b6d2fa1 100644
--- a/fs/nfs/blocklayout/blocklayout.c
+++ b/fs/nfs/blocklayout/blocklayout.c
@@ -753,7 +753,7 @@ bl_alloc_lseg(struct pnfs_layout_hdr *lo, struct nfs4_layoutget_res *lgr,
 	case -ENODEV:
 		/* Our extent block devices are unavailable */
 		set_bit(NFS_LSEG_UNAVAILABLE, &lseg->pls_flags);
-		/* Fall through */
+		fallthrough;
 	case 0:
 		return lseg;
 	default:
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 50971471f57d..a3d6d3004e84 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -1377,7 +1377,7 @@ int nfs_lookup_verify_inode(struct inode *inode, unsigned int flags)
 			/* A NFSv4 OPEN will revalidate later */
 			if (server->caps & NFS_CAP_ATOMIC_OPEN)
 				goto out;
-			/* Fallthrough */
+			fallthrough;
 		case S_IFDIR:
 			if (server->flags & NFS_MOUNT_NOCTO)
 				break;
diff --git a/fs/nfs/filelayout/filelayout.c b/fs/nfs/filelayout/filelayout.c
index a13e69009f19..7f5aa0403e16 100644
--- a/fs/nfs/filelayout/filelayout.c
+++ b/fs/nfs/filelayout/filelayout.c
@@ -187,7 +187,7 @@ static int filelayout_async_handle_error(struct rpc_task *task,
 		pnfs_error_mark_layout_for_return(inode, lseg);
 		pnfs_set_lo_fail(lseg);
 		rpc_wake_up(&tbl->slot_tbl_waitq);
-		/* fall through */
+		fallthrough;
 	default:
 reset:
 		dprintk("%s Retry through MDS. Error %d\n", __func__,
diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c
index 172bbff13b0c..4a92c9c84627 100644
--- a/fs/nfs/flexfilelayout/flexfilelayout.c
+++ b/fs/nfs/flexfilelayout/flexfilelayout.c
@@ -1133,7 +1133,7 @@ static int ff_layout_async_handle_error_v4(struct rpc_task *task,
 		nfs4_delete_deviceid(devid->ld, devid->nfs_client,
 				&devid->deviceid);
 		rpc_wake_up(&tbl->slot_tbl_waitq);
-		/* fall through */
+		fallthrough;
 	default:
 		if (ff_layout_avoid_mds_available_ds(lseg))
 			return -NFS4ERR_RESET_TO_PNFS;
@@ -1260,7 +1260,7 @@ static void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,
 		 */
 		if (opnum == OP_READ)
 			break;
-		/* Fallthrough */
+		fallthrough;
 	default:
 		pnfs_error_mark_layout_for_return(lseg->pls_layout->plh_inode,
 						  lseg);
* Unmerged path fs/nfs/fs_context.c
diff --git a/fs/nfs/nfs3acl.c b/fs/nfs/nfs3acl.c
index 26c94b32d6f4..c6c863382f37 100644
--- a/fs/nfs/nfs3acl.c
+++ b/fs/nfs/nfs3acl.c
@@ -108,7 +108,7 @@ struct posix_acl *nfs3_get_acl(struct inode *inode, int type)
 		case -EPROTONOSUPPORT:
 			dprintk("NFS_V3_ACL extension not supported; disabling\n");
 			server->caps &= ~NFS_CAP_ACLS;
-			/* fall through */
+			fallthrough;
 		case -ENOTSUPP:
 			status = -EOPNOTSUPP;
 		default:
@@ -228,7 +228,7 @@ static int __nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,
 			dprintk("NFS_V3_ACL SETACL RPC not supported"
 					"(will not retry)\n");
 			server->caps &= ~NFS_CAP_ACLS;
-			/* fall through */
+			fallthrough;
 		case -ENOTSUPP:
 			status = -EOPNOTSUPP;
 	}
diff --git a/fs/nfs/nfs4file.c b/fs/nfs/nfs4file.c
index 534b6fd70ffd..ecb849843454 100644
--- a/fs/nfs/nfs4file.c
+++ b/fs/nfs/nfs4file.c
@@ -169,7 +169,7 @@ static loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)
 		ret = nfs42_proc_llseek(filep, offset, whence);
 		if (ret != -ENOTSUPP)
 			return ret;
-		/* Fall through */
+		fallthrough;
 	default:
 		return nfs_file_llseek(filep, offset, whence);
 	}
diff --git a/fs/nfs/nfs4idmap.c b/fs/nfs/nfs4idmap.c
index 8eda2a35ddea..d5624b071c80 100644
--- a/fs/nfs/nfs4idmap.c
+++ b/fs/nfs/nfs4idmap.c
@@ -519,7 +519,7 @@ static int nfs_idmap_prepare_message(char *desc, struct idmap *idmap,
 	switch (token) {
 	case Opt_find_uid:
 		im->im_type = IDMAP_TYPE_USER;
-		/* Fall through */
+		fallthrough;
 	case Opt_find_gid:
 		im->im_conv = IDMAP_CONV_NAMETOID;
 		ret = match_strlcpy(im->im_name, &substr, IDMAP_NAMESZ);
@@ -527,7 +527,7 @@ static int nfs_idmap_prepare_message(char *desc, struct idmap *idmap,
 
 	case Opt_find_user:
 		im->im_type = IDMAP_TYPE_USER;
-		/* Fall through */
+		fallthrough;
 	case Opt_find_group:
 		im->im_conv = IDMAP_CONV_IDTONAME;
 		ret = match_int(&substr, &im->im_id);
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 11c2afde29b9..3e4232f9a84a 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -487,7 +487,7 @@ static int nfs4_do_handle_exception(struct nfs_server *server,
 						stateid);
 				goto wait_on_recovery;
 			}
-			/* Fall through */
+			fallthrough;
 		case -NFS4ERR_OPENMODE:
 			if (inode) {
 				int err;
@@ -538,10 +538,10 @@ static int nfs4_do_handle_exception(struct nfs_server *server,
 				ret = -EBUSY;
 				break;
 			}
-			/* Fall through */
+			fallthrough;
 		case -NFS4ERR_DELAY:
 			nfs_inc_server_stats(server, NFSIOS_DELAY);
-			/* Fall through */
+			fallthrough;
 		case -NFS4ERR_GRACE:
 		case -NFS4ERR_LAYOUTTRYLATER:
 		case -NFS4ERR_RECALLCONFLICT:
@@ -1497,7 +1497,7 @@ static int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode,
 	case NFS4_OPEN_CLAIM_PREVIOUS:
 		if (!test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))
 			break;
-		/* Fall through */
+		fallthrough;
 	default:
 		return 0;
 	}
@@ -2431,7 +2431,7 @@ static void nfs4_open_prepare(struct rpc_task *task, void *calldata)
 	case NFS4_OPEN_CLAIM_DELEG_CUR_FH:
 	case NFS4_OPEN_CLAIM_DELEG_PREV_FH:
 		data->o_arg.open_bitmap = &nfs4_open_noattr_bitmap[0];
-		/* Fall through */
+		fallthrough;
 	case NFS4_OPEN_CLAIM_FH:
 		task->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];
 	}
@@ -3468,11 +3468,11 @@ static void nfs4_close_done(struct rpc_task *task, void *data)
 			nfs4_free_revoked_stateid(server,
 					&calldata->arg.stateid,
 					task->tk_msg.rpc_cred);
-			/* Fallthrough */
+			fallthrough;
 		case -NFS4ERR_BAD_STATEID:
 			if (calldata->arg.fmode == 0)
 				break;
-			/* Fallthrough */
+			fallthrough;
 		default:
 			task->tk_status = nfs4_async_handle_exception(task,
 					server, task->tk_status, &exception);
@@ -6241,7 +6241,7 @@ static void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)
 		nfs4_free_revoked_stateid(data->res.server,
 				data->args.stateid,
 				task->tk_msg.rpc_cred);
-		/* Fallthrough */
+		fallthrough;
 	case -NFS4ERR_BAD_STATEID:
 	case -NFS4ERR_STALE_STATEID:
 	case -ETIMEDOUT:
@@ -6261,7 +6261,7 @@ static void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)
 			data->res.fattr = NULL;
 			goto out_restart;
 		}
-		/* Fallthrough */
+		fallthrough;
 	default:
 		task->tk_status = nfs4_async_handle_exception(task,
 				data->res.server, task->tk_status,
@@ -6570,13 +6570,13 @@ static void nfs4_locku_done(struct rpc_task *task, void *data)
 			if (nfs4_update_lock_stateid(calldata->lsp,
 					&calldata->res.stateid))
 				break;
-			/* Fall through */
+			fallthrough;
 		case -NFS4ERR_ADMIN_REVOKED:
 		case -NFS4ERR_EXPIRED:
 			nfs4_free_revoked_stateid(calldata->server,
 					&calldata->arg.stateid,
 					task->tk_msg.rpc_cred);
-			/* Fall through */
+			fallthrough;
 		case -NFS4ERR_BAD_STATEID:
 		case -NFS4ERR_STALE_STATEID:
 			if (nfs4_sync_lock_stateid(&calldata->arg.stateid,
@@ -8588,7 +8588,7 @@ static void nfs4_get_lease_time_done(struct rpc_task *task, void *calldata)
 		dprintk("%s Retry: tk_status %d\n", __func__, task->tk_status);
 		rpc_delay(task, NFS4_POLL_RETRY_MIN);
 		task->tk_status = 0;
-		/* fall through */
+		fallthrough;
 	case -NFS4ERR_RETRY_UNCACHED_REP:
 		rpc_restart_call_prepare(task);
 		return;
@@ -9036,13 +9036,13 @@ static int nfs41_reclaim_complete_handle_errors(struct rpc_task *task, struct nf
 	switch(task->tk_status) {
 	case 0:
 		wake_up_all(&clp->cl_lock_waitq);
-		/* Fallthrough */
+		fallthrough;
 	case -NFS4ERR_COMPLETE_ALREADY:
 	case -NFS4ERR_WRONG_CRED: /* What to do here? */
 		break;
 	case -NFS4ERR_DELAY:
 		rpc_delay(task, NFS4_POLL_RETRY_MAX);
-		/* fall through */
+		fallthrough;
 	case -NFS4ERR_RETRY_UNCACHED_REP:
 		return -EAGAIN;
 	case -NFS4ERR_BADSESSION:
@@ -9357,10 +9357,10 @@ static void nfs4_layoutreturn_done(struct rpc_task *task, void *calldata)
 					&lrp->args.range,
 					lrp->args.inode))
 			goto out_restart;
-		/* Fallthrough */
+		fallthrough;
 	default:
 		task->tk_status = 0;
-		/* Fallthrough */
+		fallthrough;
 	case 0:
 		break;
 	case -NFS4ERR_DELAY:
diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c
index afdb1927c551..b168483c96af 100644
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -1542,7 +1542,7 @@ static int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_
 		default:
 			pr_err("NFS: %s: unhandled error %d\n",
 					__func__, status);
-			/* Fall through */
+			fallthrough;
 		case -ENOMEM:
 		case -NFS4ERR_DENIED:
 		case -NFS4ERR_RECLAIM_BAD:
@@ -1653,7 +1653,7 @@ static int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs
 				break;
 			}
 			printk(KERN_ERR "NFS: %s: unhandled error %d\n", __func__, status);
-			/* Fall through */
+			fallthrough;
 		case -ENOENT:
 		case -ENOMEM:
 		case -EACCES:
@@ -1669,7 +1669,7 @@ static int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs
 				set_bit(ops->state_flag_bit, &state->flags);
 				break;
 			}
-			/* Fall through */
+			fallthrough;
 		case -NFS4ERR_ADMIN_REVOKED:
 		case -NFS4ERR_STALE_STATEID:
 		case -NFS4ERR_OLD_STATEID:
@@ -1681,7 +1681,7 @@ static int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs
 		case -NFS4ERR_EXPIRED:
 		case -NFS4ERR_NO_GRACE:
 			nfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);
-			/* Fall through */
+			fallthrough;
 		case -NFS4ERR_STALE_CLIENTID:
 		case -NFS4ERR_BADSESSION:
 		case -NFS4ERR_BADSLOT:
@@ -2255,11 +2255,11 @@ int nfs4_discover_server_trunking(struct nfs_client *clp,
 	case -ETIMEDOUT:
 		if (clnt->cl_softrtry)
 			break;
-		/* Fall through */
+		fallthrough;
 	case -NFS4ERR_DELAY:
 	case -EAGAIN:
 		ssleep(1);
-		/* Fall through */
+		fallthrough;
 	case -NFS4ERR_STALE_CLIENTID:
 		dprintk("NFS: %s after status %d, retrying\n",
 			__func__, status);
@@ -2271,7 +2271,7 @@ int nfs4_discover_server_trunking(struct nfs_client *clp,
 		}
 		if (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX)
 			break;
-		/* Fall through */
+		fallthrough;
 	case -NFS4ERR_CLID_INUSE:
 	case -NFS4ERR_WRONGSEC:
 		/* No point in retrying if we already used RPC_AUTH_UNIX */
diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c
index 5b9348b84fe3..9c5f9a7dca9a 100644
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@ -710,7 +710,7 @@ static void nfs_pgio_rpcsetup(struct nfs_pgio_header *hdr,
 	case FLUSH_COND_STABLE:
 		if (nfs_reqs_to_commit(cinfo))
 			break;
-		/* fall through */
+		fallthrough;
 	default:
 		hdr->args.stable = NFS_FILE_SYNC;
 	}
diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c
index 35bac529e2c4..b46814288c03 100644
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@ -1541,7 +1541,7 @@ void pnfs_roc_release(struct nfs4_layoutreturn_args *args,
 	case 0:
 		if (res->lrs_present)
 			res_stateid = &res->stateid;
-		/* Fallthrough */
+		fallthrough;
 	default:
 		arg_stateid = &args->stateid;
 	}
diff --git a/fs/nfs_common/nfsacl.c b/fs/nfs_common/nfsacl.c
index 538f142935ea..bc335a1c43b9 100644
--- a/fs/nfs_common/nfsacl.c
+++ b/fs/nfs_common/nfsacl.c
@@ -236,7 +236,7 @@ posix_acl_from_nfsacl(struct posix_acl *acl)
 				break;
 			case ACL_MASK:
 				mask = pa;
-				/* fall through */
+				fallthrough;
 			case ACL_OTHER:
 				break;
 		}
diff --git a/fs/nfsd/blocklayout.c b/fs/nfsd/blocklayout.c
index 66d4c55eb48e..346a35f573fc 100644
--- a/fs/nfsd/blocklayout.c
+++ b/fs/nfsd/blocklayout.c
@@ -82,13 +82,13 @@ nfsd4_block_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,
 			bex->soff = iomap.addr;
 			break;
 		}
-		/*FALLTHRU*/
+		fallthrough;
 	case IOMAP_HOLE:
 		if (seg->iomode == IOMODE_READ) {
 			bex->es = PNFS_BLOCK_NONE_DATA;
 			break;
 		}
-		/*FALLTHRU*/
+		fallthrough;
 	case IOMAP_DELALLOC:
 	default:
 		WARN(1, "pnfsd: filesystem returned %d extent\n", iomap.type);
diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 07e0c6f6322f..c9d2ea6ca173 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -1114,7 +1114,7 @@ static bool nfsd4_cb_sequence_done(struct rpc_task *task, struct nfsd4_callback
 		break;
 	case -ESERVERFAULT:
 		++session->se_cb_seq_nr;
-		/* Fall through */
+		fallthrough;
 	case 1:
 	case -NFS4ERR_BADSESSION:
 		nfsd4_mark_cb_fault(cb->cb_clp, cb->cb_seq_status);
diff --git a/fs/nfsd/nfs4layouts.c b/fs/nfsd/nfs4layouts.c
index 8ff07b13f685..c6e7ee7b2916 100644
--- a/fs/nfsd/nfs4layouts.c
+++ b/fs/nfsd/nfs4layouts.c
@@ -681,7 +681,7 @@ nfsd4_cb_layout_done(struct nfsd4_callback *cb, struct rpc_task *task)
 			rpc_delay(task, HZ/100); /* 10 mili-seconds */
 			return 0;
 		}
-		/* Fallthrough */
+		fallthrough;
 	default:
 		/*
 		 * Unknown error or non-responding client, we'll need to fence.
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 6de7984a24bd..d3f3d51d7553 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -427,7 +427,7 @@ nfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 				goto out;
 			open->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;
 			reclaim = true;
-			/* fall through */
+			fallthrough;
 		case NFS4_OPEN_CLAIM_FH:
 		case NFS4_OPEN_CLAIM_DELEG_CUR_FH:
 			status = do_open_fhandle(rqstp, cstate, open);
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 9244d8da11af..5bd800d06bc2 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -3059,7 +3059,7 @@ nfsd4_exchange_id(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		break;
 	default:				/* checked by xdr code */
 		WARN_ON_ONCE(1);
-		/* fall through */
+		fallthrough;
 	case SP4_SSV:
 		status = nfserr_encr_alg_unsupp;
 		goto out_nolock;
@@ -4479,7 +4479,7 @@ static int nfsd4_cb_recall_done(struct nfsd4_callback *cb,
 			rpc_delay(task, 2 * HZ);
 			return 0;
 		}
-		/*FALLTHRU*/
+		fallthrough;
 	default:
 		return 1;
 	}
@@ -5553,7 +5553,7 @@ static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)
 		break;
 	default:
 		printk("unknown stateid type %x\n", s->sc_type);
-		/* Fallthrough */
+		fallthrough;
 	case NFS4_CLOSED_STID:
 	case NFS4_CLOSED_DELEG_STID:
 		status = nfserr_bad_stateid;
@@ -6565,7 +6565,7 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		case NFS4_READW_LT:
 			if (nfsd4_has_session(cstate))
 				fl_flags |= FL_SLEEP;
-			/* Fallthrough */
+			fallthrough;
 		case NFS4_READ_LT:
 			spin_lock(&fp->fi_lock);
 			filp = find_readable_file_locked(fp);
@@ -6577,7 +6577,7 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		case NFS4_WRITEW_LT:
 			if (nfsd4_has_session(cstate))
 				fl_flags |= FL_SLEEP;
-			/* Fallthrough */
+			fallthrough;
 		case NFS4_WRITE_LT:
 			spin_lock(&fp->fi_lock);
 			filp = find_writeable_file_locked(fp);
@@ -6639,7 +6639,7 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		break;
 	case FILE_LOCK_DEFERRED:
 		nbl = NULL;
-		/* Fallthrough */
+		fallthrough;
 	case -EAGAIN:		/* conflock holds conflicting lock */
 		status = nfserr_denied;
 		dprintk("NFSD: nfsd4_lock: conflicting lock found!\n");
diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
index 37bc8f5f4514..c81dbbad8792 100644
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@ -459,7 +459,7 @@ static bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)
 	case FSID_DEV:
 		if (!old_valid_dev(exp_sb(exp)->s_dev))
 			return false;
-		/* FALL THROUGH */
+		fallthrough;
 	case FSID_MAJOR_MINOR:
 	case FSID_ENCODE_DEV:
 		return exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;
@@ -469,7 +469,7 @@ static bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)
 	case FSID_UUID16:
 		if (!is_root_export(exp))
 			return false;
-		/* fall through */
+		fallthrough;
 	case FSID_UUID4_INUM:
 	case FSID_UUID16_INUM:
 		return exp->ex_uuid != NULL;
diff --git a/fs/nfsd/nfsproc.c b/fs/nfsd/nfsproc.c
index b25c90be29fb..aed0e1a94de6 100644
--- a/fs/nfsd/nfsproc.c
+++ b/fs/nfsd/nfsproc.c
@@ -314,7 +314,7 @@ nfsd_proc_create(struct svc_rqst *rqstp)
 					rdev = inode->i_rdev;
 					attr->ia_valid |= ATTR_SIZE;
 
-					/* FALLTHROUGH */
+					fallthrough;
 				case S_IFIFO:
 					/* this is probably a permission check..
 					 * at least IRIX implements perm checking on
diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index 9447c6237803..e28f7b9e0bc6 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -214,7 +214,7 @@ int nfsd_vers(struct nfsd_net *nn, int vers, enum vers_op change)
 	case NFSD_TEST:
 		if (nn->nfsd_versions)
 			return nn->nfsd_versions[vers];
-		/* Fallthrough */
+		fallthrough;
 	case NFSD_AVAIL:
 		return nfsd_support_version(vers);
 	}
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 05101518a82a..d06e6d623289 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1473,7 +1473,7 @@ do_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
 					*created = true;
 				break;
 			}
-			/* fall through */
+			fallthrough;
 		case NFS4_CREATE_EXCLUSIVE4_1:
 			if (   d_inode(dchild)->i_mtime.tv_sec == v_mtime
 			    && d_inode(dchild)->i_atime.tv_sec == v_atime
@@ -1482,7 +1482,7 @@ do_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
 					*created = true;
 				goto set_attr;
 			}
-			/* fall through */
+			fallthrough;
 		case NFS3_CREATE_GUARDED:
 			err = nfserr_exist;
 		}
diff --git a/fs/nilfs2/bmap.c b/fs/nilfs2/bmap.c
index 01fb1831ca25..617c085b4118 100644
--- a/fs/nilfs2/bmap.c
+++ b/fs/nilfs2/bmap.c
@@ -528,7 +528,7 @@ int nilfs_bmap_read(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)
 		break;
 	case NILFS_IFILE_INO:
 		lockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);
-		/* Fall through */
+		fallthrough;
 	default:
 		bmap->b_ptr_type = NILFS_BMAP_PTR_VM;
 		bmap->b_last_allocated_key = 0;
diff --git a/fs/nilfs2/recovery.c b/fs/nilfs2/recovery.c
index 5139efed1888..3a529c335cc5 100644
--- a/fs/nilfs2/recovery.c
+++ b/fs/nilfs2/recovery.c
@@ -635,7 +635,7 @@ static int nilfs_do_roll_forward(struct the_nilfs *nilfs,
 			    !(flags & NILFS_SS_SYNDT))
 				goto try_next_pseg;
 			state = RF_DSYNC_ST;
-			/* Fall through */
+			fallthrough;
 		case RF_DSYNC_ST:
 			if (!(flags & NILFS_SS_SYNDT))
 				goto confused;
diff --git a/fs/nilfs2/segment.c b/fs/nilfs2/segment.c
index 0953635e7d48..8a66b520b00a 100644
--- a/fs/nilfs2/segment.c
+++ b/fs/nilfs2/segment.c
@@ -1147,7 +1147,8 @@ static int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)
 			nilfs_sc_cstage_set(sci, NILFS_ST_DAT);
 			goto dat_stage;
 		}
-		nilfs_sc_cstage_inc(sci);  /* Fall through */
+		nilfs_sc_cstage_inc(sci);
+		fallthrough;
 	case NILFS_ST_GC:
 		if (nilfs_doing_gc()) {
 			head = &sci->sc_gc_inodes;
@@ -1168,7 +1169,8 @@ static int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)
 			}
 			sci->sc_stage.gc_inode_ptr = NULL;
 		}
-		nilfs_sc_cstage_inc(sci);  /* Fall through */
+		nilfs_sc_cstage_inc(sci);
+		fallthrough;
 	case NILFS_ST_FILE:
 		head = &sci->sc_dirty_files;
 		ii = list_prepare_entry(sci->sc_stage.dirty_file_ptr, head,
@@ -1195,7 +1197,7 @@ static int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)
 		}
 		nilfs_sc_cstage_inc(sci);
 		sci->sc_stage.flags |= NILFS_CF_IFILE_STARTED;
-		/* Fall through */
+		fallthrough;
 	case NILFS_ST_IFILE:
 		err = nilfs_segctor_scan_file(sci, sci->sc_root->ifile,
 					      &nilfs_sc_file_ops);
@@ -1206,13 +1208,14 @@ static int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)
 		err = nilfs_segctor_create_checkpoint(sci);
 		if (unlikely(err))
 			break;
-		/* Fall through */
+		fallthrough;
 	case NILFS_ST_CPFILE:
 		err = nilfs_segctor_scan_file(sci, nilfs->ns_cpfile,
 					      &nilfs_sc_file_ops);
 		if (unlikely(err))
 			break;
-		nilfs_sc_cstage_inc(sci);  /* Fall through */
+		nilfs_sc_cstage_inc(sci);
+		fallthrough;
 	case NILFS_ST_SUFILE:
 		err = nilfs_sufile_freev(nilfs->ns_sufile, sci->sc_freesegs,
 					 sci->sc_nfreesegs, &ndone);
@@ -1228,7 +1231,8 @@ static int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)
 					      &nilfs_sc_file_ops);
 		if (unlikely(err))
 			break;
-		nilfs_sc_cstage_inc(sci);  /* Fall through */
+		nilfs_sc_cstage_inc(sci);
+		fallthrough;
 	case NILFS_ST_DAT:
  dat_stage:
 		err = nilfs_segctor_scan_file(sci, nilfs->ns_dat,
@@ -1239,7 +1243,8 @@ static int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)
 			nilfs_sc_cstage_set(sci, NILFS_ST_DONE);
 			return 0;
 		}
-		nilfs_sc_cstage_inc(sci);  /* Fall through */
+		nilfs_sc_cstage_inc(sci);
+		fallthrough;
 	case NILFS_ST_SR:
 		if (mode == SC_LSEG_SR) {
 			/* Appending a super root */
diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
index 48689619c0fd..d6b1c96fafdf 100644
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@ -817,7 +817,7 @@ static int do_fanotify_mark(int fanotify_fd, unsigned int flags, __u64 mask,
 	}
 
 	switch (flags & (FAN_MARK_ADD | FAN_MARK_REMOVE | FAN_MARK_FLUSH)) {
-	case FAN_MARK_ADD:		/* fallthrough */
+	case FAN_MARK_ADD:
 	case FAN_MARK_REMOVE:
 		if (!mask)
 			return -EINVAL;
diff --git a/fs/ocfs2/cluster/quorum.c b/fs/ocfs2/cluster/quorum.c
index 67dcee65fe50..4747aab9213b 100644
--- a/fs/ocfs2/cluster/quorum.c
+++ b/fs/ocfs2/cluster/quorum.c
@@ -81,7 +81,7 @@ static void o2quo_fence_self(void)
 	default:
 		WARN_ON(o2nm_single_cluster->cl_fence_method >=
 			O2NM_FENCE_METHODS);
-		/* fall through */
+		fallthrough;
 	case O2NM_FENCE_RESET:
 		printk(KERN_ERR "*** ocfs2 is very sorry to be fencing this "
 		       "system by restarting ***\n");
* Unmerged path fs/pstore/zone.c
diff --git a/fs/quota/quota.c b/fs/quota/quota.c
index fd5dd806f1b9..280ff1e27816 100644
--- a/fs/quota/quota.c
+++ b/fs/quota/quota.c
@@ -38,7 +38,7 @@ static int check_quotactl_permission(struct super_block *sb, int type, int cmd,
 		if ((type == USRQUOTA && uid_eq(current_euid(), make_kuid(current_user_ns(), id))) ||
 		    (type == GRPQUOTA && in_egroup_p(make_kgid(current_user_ns(), id))))
 			break;
-		/*FALLTHROUGH*/
+		fallthrough;
 	default:
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
diff --git a/fs/seq_file.c b/fs/seq_file.c
index 1600034a929b..2c3b630ee082 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -317,7 +317,7 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 	switch (whence) {
 	case SEEK_CUR:
 		offset += file->f_pos;
-		/* fall through */
+		fallthrough;
 	case SEEK_SET:
 		if (offset < 0)
 			break;
diff --git a/fs/signalfd.c b/fs/signalfd.c
index 44b6845b071c..b95bff2b2264 100644
--- a/fs/signalfd.c
+++ b/fs/signalfd.c
@@ -176,7 +176,7 @@ static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, kernel_siginfo_t *info
 		if (!nonblock)
 			break;
 		ret = -EAGAIN;
-		/* fall through */
+		fallthrough;
 	default:
 		spin_unlock_irq(&current->sighand->siglock);
 		return ret;
* Unmerged path fs/ubifs/lprops.c
diff --git a/fs/udf/symlink.c b/fs/udf/symlink.c
index 6023c97c6da2..25ff91c7e94a 100644
--- a/fs/udf/symlink.c
+++ b/fs/udf/symlink.c
@@ -52,7 +52,7 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
 				elen += pc->lengthComponentIdent;
 				break;
 			}
-			/* Fall through */
+			fallthrough;
 		case 2:
 			if (tolen == 0)
 				return -ENAMETOOLONG;
diff --git a/fs/ufs/util.h b/fs/ufs/util.h
index 891ce6408901..e5d336a90f96 100644
--- a/fs/ufs/util.h
+++ b/fs/ufs/util.h
@@ -42,7 +42,7 @@ ufs_get_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,
 	case UFS_ST_SUNOS:
 		if (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT)
 			return fs32_to_cpu(sb, usb1->fs_u0.fs_sun.fs_state);
-		/* Fall Through - to UFS_ST_SUN */
+		fallthrough;	/* to UFS_ST_SUN */
 	case UFS_ST_SUN:
 		return fs32_to_cpu(sb, usb3->fs_un2.fs_sun.fs_state);
 	case UFS_ST_SUNx86:
@@ -63,7 +63,7 @@ ufs_set_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,
 			usb1->fs_u0.fs_sun.fs_state = cpu_to_fs32(sb, value);
 			break;
 		}
-		/* Fall Through - to UFS_ST_SUN */
+		fallthrough;	/* to UFS_ST_SUN */
 	case UFS_ST_SUN:
 		usb3->fs_un2.fs_sun.fs_state = cpu_to_fs32(sb, value);
 		break;
@@ -197,7 +197,7 @@ ufs_get_inode_uid(struct super_block *sb, struct ufs_inode *inode)
 	case UFS_UID_EFT:
 		if (inode->ui_u1.oldids.ui_suid == 0xFFFF)
 			return fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_uid);
-		/* Fall through */
+		fallthrough;
 	default:
 		return fs16_to_cpu(sb, inode->ui_u1.oldids.ui_suid);
 	}
@@ -215,7 +215,7 @@ ufs_set_inode_uid(struct super_block *sb, struct ufs_inode *inode, u32 value)
 		inode->ui_u3.ui_sun.ui_uid = cpu_to_fs32(sb, value);
 		if (value > 0xFFFF)
 			value = 0xFFFF;
-		/* Fall through */
+		fallthrough;
 	default:
 		inode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);
 		break;
@@ -231,7 +231,7 @@ ufs_get_inode_gid(struct super_block *sb, struct ufs_inode *inode)
 	case UFS_UID_EFT:
 		if (inode->ui_u1.oldids.ui_suid == 0xFFFF)
 			return fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_gid);
-		/* Fall through */
+		fallthrough;
 	default:
 		return fs16_to_cpu(sb, inode->ui_u1.oldids.ui_sgid);
 	}
@@ -249,7 +249,7 @@ ufs_set_inode_gid(struct super_block *sb, struct ufs_inode *inode, u32 value)
 		inode->ui_u3.ui_sun.ui_gid = cpu_to_fs32(sb, value);
 		if (value > 0xFFFF)
 			value = 0xFFFF;
-		/* Fall through */
+		fallthrough;
 	default:
 		inode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);
 		break;
* Unmerged path fs/vboxsf/utils.c
* Unmerged path include/linux/compat.h
diff --git a/include/linux/filter.h b/include/linux/filter.h
index dc3bd64e26c3..9f26c41ee85d 100644
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -1209,7 +1209,7 @@ static inline u16 bpf_anc_helper(const struct sock_filter *ftest)
 		BPF_ANCILLARY(RANDOM);
 		BPF_ANCILLARY(VLAN_TPID);
 		}
-		/* Fallthrough. */
+		fallthrough;
 	default:
 		return ftest->code;
 	}
diff --git a/include/linux/jhash.h b/include/linux/jhash.h
index 8037850f3104..a75ae459374c 100644
--- a/include/linux/jhash.h
+++ b/include/linux/jhash.h
@@ -86,17 +86,17 @@ static inline u32 jhash(const void *key, u32 length, u32 initval)
 	}
 	/* Last block: affect all 32 bits of (c) */
 	switch (length) {
-	case 12: c += (u32)k[11]<<24;	/* fall through */
-	case 11: c += (u32)k[10]<<16;	/* fall through */
-	case 10: c += (u32)k[9]<<8;	/* fall through */
-	case 9:  c += k[8];		/* fall through */
-	case 8:  b += (u32)k[7]<<24;	/* fall through */
-	case 7:  b += (u32)k[6]<<16;	/* fall through */
-	case 6:  b += (u32)k[5]<<8;	/* fall through */
-	case 5:  b += k[4];		/* fall through */
-	case 4:  a += (u32)k[3]<<24;	/* fall through */
-	case 3:  a += (u32)k[2]<<16;	/* fall through */
-	case 2:  a += (u32)k[1]<<8;	/* fall through */
+	case 12: c += (u32)k[11]<<24;	fallthrough;
+	case 11: c += (u32)k[10]<<16;	fallthrough;
+	case 10: c += (u32)k[9]<<8;	fallthrough;
+	case 9:  c += k[8];		fallthrough;
+	case 8:  b += (u32)k[7]<<24;	fallthrough;
+	case 7:  b += (u32)k[6]<<16;	fallthrough;
+	case 6:  b += (u32)k[5]<<8;	fallthrough;
+	case 5:  b += k[4];		fallthrough;
+	case 4:  a += (u32)k[3]<<24;	fallthrough;
+	case 3:  a += (u32)k[2]<<16;	fallthrough;
+	case 2:  a += (u32)k[1]<<8;	fallthrough;
 	case 1:  a += k[0];
 		 __jhash_final(a, b, c);
 	case 0: /* Nothing left to add */
@@ -132,8 +132,8 @@ static inline u32 jhash2(const u32 *k, u32 length, u32 initval)
 
 	/* Handle the last 3 u32's */
 	switch (length) {
-	case 3: c += k[2];	/* fall through */
-	case 2: b += k[1];	/* fall through */
+	case 3: c += k[2];	fallthrough;
+	case 2: b += k[1];	fallthrough;
 	case 1: a += k[0];
 		__jhash_final(a, b, c);
 	case 0:	/* Nothing left to add */
* Unmerged path include/linux/mm.h
* Unmerged path include/linux/signal.h
* Unmerged path include/linux/skbuff.h
* Unmerged path include/math-emu/op-common.h
diff --git a/init/do_mounts_md.c b/init/do_mounts_md.c
index 7d85d172bc7e..0c8a9a25231b 100644
--- a/init/do_mounts_md.c
+++ b/init/do_mounts_md.c
@@ -106,10 +106,10 @@ static int __init md_setup(char *str)
 				pername = "raid0";
 			break;
 		}
-		/* FALL THROUGH */
+		fallthrough;
 	case 1: /* the first device is numeric */
 		str = str1;
-		/* FALL THROUGH */
+		fallthrough;
 	case 0:
 		md_setup_args[ent].level = LEVEL_NONE;
 		pername="super-block";
* Unmerged path ipc/sem.c
diff --git a/ipc/shm.c b/ipc/shm.c
index 7394d05f8c0b..8c97d71a8e8c 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -1181,7 +1181,7 @@ long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf)
 	case IPC_SET:
 		if (copy_shmid_from_user(&sem64, buf, version))
 			return -EFAULT;
-		/* fallthru */
+		fallthrough;
 	case IPC_RMID:
 		return shmctl_down(ns, shmid, cmd, &sem64);
 	case SHM_LOCK:
@@ -1363,7 +1363,7 @@ long compat_ksys_shmctl(int shmid, int cmd, void __user *uptr)
 	case IPC_SET:
 		if (copy_compat_shmid_from_user(&sem64, uptr, version))
 			return -EFAULT;
-		/* fallthru */
+		fallthrough;
 	case IPC_RMID:
 		return shmctl_down(ns, shmid, cmd, &sem64);
 	case SHM_LOCK:
diff --git a/kernel/auditfilter.c b/kernel/auditfilter.c
index c4863eb9679f..355bf40788fe 100644
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@ -698,7 +698,7 @@ static struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)
 				data->values[i] = AUDIT_UID_UNSET;
 				break;
 			}
-			/* fall through - if set */
+			fallthrough;	/* if set */
 		default:
 			data->values[i] = f->val;
 		}
diff --git a/kernel/bpf/cgroup.c b/kernel/bpf/cgroup.c
index b705a035c637..7c772af3cab1 100644
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@ -1785,7 +1785,7 @@ static bool cg_sockopt_is_valid_access(int off, int size,
 			return prog->expected_attach_type ==
 				BPF_CGROUP_GETSOCKOPT;
 		case offsetof(struct bpf_sockopt, optname):
-			/* fallthrough */
+			fallthrough;
 		case offsetof(struct bpf_sockopt, level):
 			if (size != size_default)
 				return false;
* Unmerged path kernel/bpf/cpumap.c
diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c
index 9186e511feb3..3b27039ee938 100644
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@ -2033,7 +2033,7 @@ bpf_prog_load_check_attach(enum bpf_prog_type prog_type,
 	case BPF_PROG_TYPE_EXT:
 		if (expected_attach_type)
 			return -EINVAL;
-		/* fallthrough */
+		fallthrough;
 	default:
 		return 0;
 	}
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index e98b26227300..d74265a2b226 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -4976,7 +4976,7 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,
 				off_reg == dst_reg ? dst : src);
 			return -EACCES;
 		}
-		/* fall-through */
+		fallthrough;
 	default:
 		break;
 	}
@@ -10697,7 +10697,7 @@ static int check_attach_btf_id(struct bpf_verifier_env *env)
 	default:
 		if (!prog_extension)
 			return -EINVAL;
-		/* fallthrough */
+		fallthrough;
 	case BPF_MODIFY_RETURN:
 	case BPF_LSM_MAC:
 	case BPF_TRACE_FENTRY:
* Unmerged path kernel/capability.c
* Unmerged path kernel/compat.c
* Unmerged path kernel/debug/gdbstub.c
* Unmerged path kernel/debug/kdb/kdb_keyboard.c
* Unmerged path kernel/debug/kdb/kdb_support.c
diff --git a/kernel/events/core.c b/kernel/events/core.c
index a7f0cfe4e850..057fb6a7a8ff 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -9919,7 +9919,7 @@ perf_event_parse_addr_filter(struct perf_event *event, char *fstr,
 		case IF_SRC_KERNELADDR:
 		case IF_SRC_KERNEL:
 			kernel = 1;
-			/* fall through */
+			fallthrough;
 
 		case IF_SRC_FILEADDR:
 		case IF_SRC_FILE:
* Unmerged path kernel/irq/handle.c
* Unmerged path kernel/irq/manage.c
diff --git a/kernel/kallsyms.c b/kernel/kallsyms.c
index 496b5a27db97..0a212cca634d 100644
--- a/kernel/kallsyms.c
+++ b/kernel/kallsyms.c
@@ -648,12 +648,12 @@ bool kallsyms_show_value(const struct cred *cred)
 	case 0:
 		if (kallsyms_for_perf())
 			return true;
-	/* fallthrough */
+		fallthrough;
 	case 1:
 		if (security_capable(cred, &init_user_ns, CAP_SYSLOG,
 				     CAP_OPT_NOAUDIT) == 0)
 			return true;
-	/* fallthrough */
+		fallthrough;
 	default:
 		return false;
 	}
* Unmerged path kernel/power/hibernate.c
diff --git a/kernel/power/qos.c b/kernel/power/qos.c
index 1dcedd4613a6..c1e13cb38b77 100644
--- a/kernel/power/qos.c
+++ b/kernel/power/qos.c
@@ -121,7 +121,7 @@ int pm_qos_update_target(struct pm_qos_constraints *c, struct plist_node *node,
 		 * and add, then see if the aggregate has changed.
 		 */
 		plist_del(node, &c->list);
-		/* fall through */
+		fallthrough;
 	case PM_QOS_ADD_REQ:
 		plist_node_init(node, new_value);
 		plist_add(node, &c->list);
@@ -190,7 +190,7 @@ bool pm_qos_update_flags(struct pm_qos_flags *pqf,
 		break;
 	case PM_QOS_UPDATE_REQ:
 		pm_qos_flags_remove_req(pqf, req);
-		/* fall through */
+		fallthrough;
 	case PM_QOS_ADD_REQ:
 		req->flags = val;
 		INIT_LIST_HEAD(&req->node);
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index fb85cef13869..6baf85095fc5 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -1640,7 +1640,7 @@ static int select_fallback_rq(int cpu, struct task_struct *p)
 				state = possible;
 				break;
 			}
-			/* Fall-through */
+			fallthrough;
 		case possible:
 			do_set_cpus_allowed(p, cpu_possible_mask);
 			state = fail;
diff --git a/kernel/sched/topology.c b/kernel/sched/topology.c
index 405598dda4f7..3659677514d8 100644
--- a/kernel/sched/topology.c
+++ b/kernel/sched/topology.c
@@ -1215,13 +1215,13 @@ static void __free_domain_allocs(struct s_data *d, enum s_alloc what,
 	case sa_rootdomain:
 		if (!atomic_read(&d->rd->refcount))
 			free_rootdomain(&d->rd->rcu);
-		/* Fall through */
+		fallthrough;
 	case sa_sd:
 		free_percpu(d->sd);
-		/* Fall through */
+		fallthrough;
 	case sa_sd_storage:
 		__sdt_free(cpu_map);
-		/* Fall through */
+		fallthrough;
 	case sa_none:
 		break;
 	}
* Unmerged path kernel/signal.c
* Unmerged path kernel/sys.c
* Unmerged path kernel/time/hrtimer.c
diff --git a/kernel/time/posix-timers.c b/kernel/time/posix-timers.c
index db5e28ac4dfa..24c9ca2b5ae3 100644
--- a/kernel/time/posix-timers.c
+++ b/kernel/time/posix-timers.c
@@ -451,12 +451,12 @@ static struct pid *good_sigevent(sigevent_t * event)
 		rtn = pid_task(pid, PIDTYPE_PID);
 		if (!rtn || !same_thread_group(rtn, current))
 			return NULL;
-		/* FALLTHRU */
+		fallthrough;
 	case SIGEV_SIGNAL:
 	case SIGEV_THREAD:
 		if (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)
 			return NULL;
-		/* FALLTHRU */
+		fallthrough;
 	case SIGEV_NONE:
 		return pid;
 	default:
* Unmerged path kernel/time/tick-broadcast.c
* Unmerged path kernel/time/timer.c
diff --git a/kernel/trace/blktrace.c b/kernel/trace/blktrace.c
index c53b2838dac9..3c47e2c943f7 100644
--- a/kernel/trace/blktrace.c
+++ b/kernel/trace/blktrace.c
@@ -764,7 +764,7 @@ int blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)
 #endif
 	case BLKTRACESTART:
 		start = 1;
-		/* fall through */
+		fallthrough;
 	case BLKTRACESTOP:
 		ret = __blk_trace_startstop(q, start);
 		break;
* Unmerged path kernel/trace/trace_events_filter.c
* Unmerged path lib/asn1_decoder.c
* Unmerged path lib/assoc_array.c
* Unmerged path lib/bootconfig.c
* Unmerged path lib/cmdline.c
diff --git a/lib/dim/net_dim.c b/lib/dim/net_dim.c
index a4db51c21266..06811d866775 100644
--- a/lib/dim/net_dim.c
+++ b/lib/dim/net_dim.c
@@ -233,7 +233,7 @@ void net_dim(struct dim *dim, struct dim_sample end_sample)
 			schedule_work(&dim->work);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case DIM_START_MEASURE:
 		dim_update_sample(end_sample.event_ctr, end_sample.pkt_ctr,
 				  end_sample.byte_ctr, &dim->start_sample);
diff --git a/lib/dim/rdma_dim.c b/lib/dim/rdma_dim.c
index f7e26c7b4749..15462d54758d 100644
--- a/lib/dim/rdma_dim.c
+++ b/lib/dim/rdma_dim.c
@@ -59,7 +59,7 @@ static bool rdma_dim_decision(struct dim_stats *curr_stats, struct dim *dim)
 			break;
 		case DIM_STATS_WORSE:
 			dim_turn(dim);
-			/* fall through */
+			fallthrough;
 		case DIM_STATS_BETTER:
 			step_res = rdma_dim_step(dim);
 			if (step_res == DIM_ON_EDGE)
@@ -94,7 +94,7 @@ void rdma_dim(struct dim *dim, u64 completions)
 			schedule_work(&dim->work);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case DIM_START_MEASURE:
 		dim->state = DIM_MEASURE_IN_PROGRESS;
 		dim_update_sample_with_comps(curr_sample->event_ctr, 0, 0,
diff --git a/lib/glob.c b/lib/glob.c
index 0ba3ea86b546..85ecbda45cd8 100644
--- a/lib/glob.c
+++ b/lib/glob.c
@@ -102,7 +102,7 @@ bool __pure glob_match(char const *pat, char const *str)
 			break;
 		case '\\':
 			d = *pat++;
-			/*FALLTHROUGH*/
+			fallthrough;
 		default:	/* Literal character */
 literal:
 			if (c == d) {
* Unmerged path lib/siphash.c
diff --git a/lib/ts_fsm.c b/lib/ts_fsm.c
index 69557c74ef9f..d0172c37193c 100644
--- a/lib/ts_fsm.c
+++ b/lib/ts_fsm.c
@@ -197,7 +197,7 @@ static unsigned int fsm_find(struct ts_config *conf, struct ts_state *state)
 				TOKEN_MISMATCH();
 
 			block_idx++;
-			/* fall through */
+			fallthrough;
 
 		case TS_FSM_ANY:
 			if (next == NULL)
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index 60860615721d..eec2b29ef658 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -1225,7 +1225,7 @@ char *mac_address_string(char *buf, char *end, u8 *addr,
 
 	case 'R':
 		reversed = true;
-		/* fall through */
+		fallthrough;
 
 	default:
 		separator = ':';
@@ -1641,7 +1641,8 @@ char *uuid_string(char *buf, char *end, const u8 *addr,
 
 	switch (*(++fmt)) {
 	case 'L':
-		uc = true;		/* fall-through */
+		uc = true;
+		fallthrough;
 	case 'l':
 		index = guid_index;
 		break;
@@ -2140,7 +2141,7 @@ char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 	case 'S':
 	case 's':
 		ptr = dereference_symbol_descriptor(ptr);
-		/* Fallthrough */
+		fallthrough;
 	case 'B':
 		return symbol_string(buf, end, ptr, spec, fmt);
 	case 'R':
@@ -2371,7 +2372,7 @@ int format_decode(const char *fmt, struct printf_spec *spec)
 
 	case 'x':
 		spec->flags |= SMALL;
-		/* fall through */
+		fallthrough;
 
 	case 'X':
 		spec->base = 16;
@@ -2389,7 +2390,7 @@ int format_decode(const char *fmt, struct printf_spec *spec)
 		 * utility, treat it as any other invalid or
 		 * unsupported format specifier.
 		 */
-		/* Fall-through */
+		fallthrough;
 
 	default:
 		WARN_ONCE(1, "Please remove unsupported %%%c in format string\n", *fmt);
@@ -3334,10 +3335,10 @@ int vsscanf(const char *buf, const char *fmt, va_list args)
 			break;
 		case 'i':
 			base = 0;
-			/* fall through */
+			fallthrough;
 		case 'd':
 			is_sign = true;
-			/* fall through */
+			fallthrough;
 		case 'u':
 			break;
 		case '%':
diff --git a/lib/xz/xz_dec_lzma2.c b/lib/xz/xz_dec_lzma2.c
index 08c3c8049998..a1ca3c02e5fb 100644
--- a/lib/xz/xz_dec_lzma2.c
+++ b/lib/xz/xz_dec_lzma2.c
@@ -1043,7 +1043,7 @@ XZ_EXTERN enum xz_ret xz_dec_lzma2_run(struct xz_dec_lzma2 *s,
 
 			s->lzma2.sequence = SEQ_LZMA_PREPARE;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_LZMA_PREPARE:
 			if (s->lzma2.compressed < RC_INIT_BYTES)
@@ -1055,7 +1055,7 @@ XZ_EXTERN enum xz_ret xz_dec_lzma2_run(struct xz_dec_lzma2 *s,
 			s->lzma2.compressed -= RC_INIT_BYTES;
 			s->lzma2.sequence = SEQ_LZMA_RUN;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_LZMA_RUN:
 			/*
diff --git a/lib/xz/xz_dec_stream.c b/lib/xz/xz_dec_stream.c
index bd1d182419d7..fea86deaaa01 100644
--- a/lib/xz/xz_dec_stream.c
+++ b/lib/xz/xz_dec_stream.c
@@ -583,7 +583,7 @@ static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
 			if (ret != XZ_OK)
 				return ret;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_BLOCK_START:
 			/* We need one byte of input to continue. */
@@ -608,7 +608,7 @@ static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
 			s->temp.pos = 0;
 			s->sequence = SEQ_BLOCK_HEADER;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_BLOCK_HEADER:
 			if (!fill_temp(s, b))
@@ -620,7 +620,7 @@ static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
 
 			s->sequence = SEQ_BLOCK_UNCOMPRESS;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_BLOCK_UNCOMPRESS:
 			ret = dec_block(s, b);
@@ -629,7 +629,7 @@ static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
 
 			s->sequence = SEQ_BLOCK_PADDING;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_BLOCK_PADDING:
 			/*
@@ -651,7 +651,7 @@ static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
 
 			s->sequence = SEQ_BLOCK_CHECK;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_BLOCK_CHECK:
 			if (s->check_type == XZ_CHECK_CRC32) {
@@ -675,7 +675,7 @@ static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
 
 			s->sequence = SEQ_INDEX_PADDING;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_INDEX_PADDING:
 			while ((s->index.size + (b->in_pos - s->in_start))
@@ -699,7 +699,7 @@ static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
 
 			s->sequence = SEQ_INDEX_CRC32;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_INDEX_CRC32:
 			ret = crc32_validate(s, b);
@@ -709,7 +709,7 @@ static enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)
 			s->temp.size = STREAM_HEADER_SIZE;
 			s->sequence = SEQ_STREAM_FOOTER;
 
-		/* Fall through */
+			fallthrough;
 
 		case SEQ_STREAM_FOOTER:
 			if (!fill_temp(s, b))
* Unmerged path lib/zstd/bitstream.h
* Unmerged path lib/zstd/compress.c
* Unmerged path lib/zstd/decompress.c
* Unmerged path lib/zstd/huf_compress.c
diff --git a/net/8021q/vlan_dev.c b/net/8021q/vlan_dev.c
index a945ec9bd524..0fb8be3d8793 100644
--- a/net/8021q/vlan_dev.c
+++ b/net/8021q/vlan_dev.c
@@ -369,7 +369,7 @@ static int vlan_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCSHWTSTAMP:
 		if (!net_eq(dev_net(dev), &init_net))
 			break;
-		/* fall through */
+		fallthrough;
 	case SIOCGMIIPHY:
 	case SIOCGMIIREG:
 	case SIOCSMIIREG:
* Unmerged path net/9p/trans_xen.c
diff --git a/net/atm/common.c b/net/atm/common.c
index 6772eddf6ec0..5df4b57a5ca4 100644
--- a/net/atm/common.c
+++ b/net/atm/common.c
@@ -296,7 +296,7 @@ static int adjust_tp(struct atm_trafprm *tp, unsigned char aal)
 		break;
 	default:
 		pr_warn("AAL problems ... (%d)\n", aal);
-		/* fall through */
+		fallthrough;
 	case ATM_AAL5:
 		max_sdu = ATM_MAX_AAL5_PDU;
 	}
@@ -416,7 +416,7 @@ static int __vcc_connect(struct atm_vcc *vcc, struct atm_dev *dev, short vpi,
 	case ATM_NO_AAL:
 		/* ATM_AAL5 is also used in the "0 for default" case */
 		vcc->qos.aal = ATM_AAL5;
-		/* fall through */
+		fallthrough;
 	case ATM_AAL5:
 		error = atm_init_aal5(vcc);
 		vcc->stats = &dev->stats.aal5;
diff --git a/net/atm/lec.c b/net/atm/lec.c
index 1e67398ab914..aaf75b2a418a 100644
--- a/net/atm/lec.c
+++ b/net/atm/lec.c
@@ -379,7 +379,7 @@ static int lec_atm_send(struct atm_vcc *vcc, struct sk_buff *skb)
 
 		if (mesg->content.normal.no_source_le_narp)
 			break;
-		/* FALL THROUGH */
+		fallthrough;
 	case l_arp_update:
 		lec_arp_update(priv, mesg->content.normal.mac_addr,
 			       mesg->content.normal.atm_addr,
diff --git a/net/atm/resources.c b/net/atm/resources.c
index bada395ecdb1..7574770fab1d 100644
--- a/net/atm/resources.c
+++ b/net/atm/resources.c
@@ -310,7 +310,7 @@ int atm_dev_ioctl(unsigned int cmd, void __user *arg, int compat)
 				goto done;
 			}
 	}
-	/* fall through */
+		fallthrough;
 	case ATM_SETESIF:
 	{
 		unsigned char esi[ESI_LEN];
@@ -332,7 +332,7 @@ int atm_dev_ioctl(unsigned int cmd, void __user *arg, int compat)
 			error = -EPERM;
 			goto done;
 		}
-		/* fall through */
+		fallthrough;
 	case ATM_GETSTAT:
 		size = sizeof(struct atm_dev_stats);
 		error = fetch_stats(dev, buf, cmd == ATM_GETSTATZ);
@@ -405,7 +405,7 @@ int atm_dev_ioctl(unsigned int cmd, void __user *arg, int compat)
 			error = -EINVAL;
 			goto done;
 		}
-		/* fall through */
+		fallthrough;
 	case ATM_SETCIRANGE:
 	case SONET_GETSTATZ:
 	case SONET_SETDIAG:
@@ -415,7 +415,7 @@ int atm_dev_ioctl(unsigned int cmd, void __user *arg, int compat)
 			error = -EPERM;
 			goto done;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		if (compat) {
 #ifdef CONFIG_COMPAT
diff --git a/net/bpf/test_run.c b/net/bpf/test_run.c
index bf8b011cc9a9..40fba8059c27 100644
--- a/net/bpf/test_run.c
+++ b/net/bpf/test_run.c
@@ -419,7 +419,7 @@ int bpf_prog_test_run_skb(struct bpf_prog *prog, const union bpf_attr *kattr,
 	case BPF_PROG_TYPE_SCHED_CLS:
 	case BPF_PROG_TYPE_SCHED_ACT:
 		is_l2 = true;
-		/* fall through */
+		fallthrough;
 	case BPF_PROG_TYPE_LWT_IN:
 	case BPF_PROG_TYPE_LWT_OUT:
 	case BPF_PROG_TYPE_LWT_XMIT:
* Unmerged path net/can/j1939/socket.c
* Unmerged path net/can/j1939/transport.c
diff --git a/net/ceph/ceph_hash.c b/net/ceph/ceph_hash.c
index 9a5850f264ed..4bdcf6725555 100644
--- a/net/ceph/ceph_hash.c
+++ b/net/ceph/ceph_hash.c
@@ -50,35 +50,35 @@ unsigned int ceph_str_hash_rjenkins(const char *str, unsigned int length)
 	switch (len) {
 	case 11:
 		c = c + ((__u32)k[10] << 24);
-		/* fall through */
+		fallthrough;
 	case 10:
 		c = c + ((__u32)k[9] << 16);
-		/* fall through */
+		fallthrough;
 	case 9:
 		c = c + ((__u32)k[8] << 8);
 		/* the first byte of c is reserved for the length */
-		/* fall through */
+		fallthrough;
 	case 8:
 		b = b + ((__u32)k[7] << 24);
-		/* fall through */
+		fallthrough;
 	case 7:
 		b = b + ((__u32)k[6] << 16);
-		/* fall through */
+		fallthrough;
 	case 6:
 		b = b + ((__u32)k[5] << 8);
-		/* fall through */
+		fallthrough;
 	case 5:
 		b = b + k[4];
-		/* fall through */
+		fallthrough;
 	case 4:
 		a = a + ((__u32)k[3] << 24);
-		/* fall through */
+		fallthrough;
 	case 3:
 		a = a + ((__u32)k[2] << 16);
-		/* fall through */
+		fallthrough;
 	case 2:
 		a = a + ((__u32)k[1] << 8);
-		/* fall through */
+		fallthrough;
 	case 1:
 		a = a + k[0];
 		/* case 0: nothing left to add */
diff --git a/net/ceph/crush/mapper.c b/net/ceph/crush/mapper.c
index 3f323ed9df52..ba9592f94bf2 100644
--- a/net/ceph/crush/mapper.c
+++ b/net/ceph/crush/mapper.c
@@ -987,7 +987,7 @@ int crush_do_rule(const struct crush_map *map,
 		case CRUSH_RULE_CHOOSELEAF_FIRSTN:
 		case CRUSH_RULE_CHOOSE_FIRSTN:
 			firstn = 1;
-			/* fall through */
+			fallthrough;
 		case CRUSH_RULE_CHOOSELEAF_INDEP:
 		case CRUSH_RULE_CHOOSE_INDEP:
 			if (wsize == 0)
diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c
index 57791275b734..f2a9d4b5d317 100644
--- a/net/ceph/messenger.c
+++ b/net/ceph/messenger.c
@@ -412,7 +412,7 @@ static void ceph_sock_state_change(struct sock *sk)
 	switch (sk->sk_state) {
 	case TCP_CLOSE:
 		dout("%s TCP_CLOSE\n", __func__);
-		/* fall through */
+		fallthrough;
 	case TCP_CLOSE_WAIT:
 		dout("%s TCP_CLOSE_WAIT\n", __func__);
 		con_sock_state_closing(con);
@@ -2759,7 +2759,7 @@ static int try_read(struct ceph_connection *con)
 			switch (ret) {
 			case -EBADMSG:
 				con->error_msg = "bad crc/signature";
-				/* fall through */
+				fallthrough;
 			case -EBADE:
 				ret = -EIO;
 				break;
diff --git a/net/ceph/mon_client.c b/net/ceph/mon_client.c
index 3d8c8015e976..d633a0aeaa55 100644
--- a/net/ceph/mon_client.c
+++ b/net/ceph/mon_client.c
@@ -1307,7 +1307,7 @@ static struct ceph_msg *mon_alloc_msg(struct ceph_connection *con,
 		 * request had a non-zero tid.  Work around this weirdness
 		 * by allocating a new message.
 		 */
-		/* fall through */
+		fallthrough;
 	case CEPH_MSG_MON_MAP:
 	case CEPH_MSG_MDS_MAP:
 	case CEPH_MSG_OSD_MAP:
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index d5bae35fa152..f71c33a037f2 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -3860,7 +3860,7 @@ static void scan_requests(struct ceph_osd *osd,
 			if (!force_resend && !force_resend_writes)
 				break;
 
-			/* fall through */
+			fallthrough;
 		case CALC_TARGET_NEED_RESEND:
 			cancel_linger_map_check(lreq);
 			/*
@@ -3897,7 +3897,7 @@ static void scan_requests(struct ceph_osd *osd,
 			     !force_resend_writes))
 				break;
 
-			/* fall through */
+			fallthrough;
 		case CALC_TARGET_NEED_RESEND:
 			cancel_map_check(req);
 			unlink_request(osd, req);
diff --git a/net/core/dev.c b/net/core/dev.c
index 31b95c630834..bce9660a540e 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -4487,10 +4487,10 @@ static u32 netif_receive_generic_xdp(struct sk_buff *skb,
 		break;
 	default:
 		bpf_warn_invalid_xdp_action(act);
-		/* fall through */
+		fallthrough;
 	case XDP_ABORTED:
 		trace_xdp_exception(skb->dev, xdp_prog, act);
-		/* fall through */
+		fallthrough;
 	case XDP_DROP:
 	do_drop:
 		kfree_skb(skb);
diff --git a/net/core/dev_ioctl.c b/net/core/dev_ioctl.c
index 918132a6d52a..10b8e4913965 100644
--- a/net/core/dev_ioctl.c
+++ b/net/core/dev_ioctl.c
@@ -299,7 +299,7 @@ static int dev_ifsioc(struct net *net, struct ifreq *ifr, unsigned int cmd)
 		err = net_hwtstamp_validate(ifr);
 		if (err)
 			return err;
-		/* fall through */
+		fallthrough;
 
 	/*
 	 *	Unknown or private ioctl
@@ -460,7 +460,7 @@ int dev_ioctl(struct net *net, unsigned int cmd, struct ifreq *ifr, bool *need_c
 	case SIOCSIFTXQLEN:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
-		/* fall through */
+		fallthrough;
 	/*
 	 *	These ioctl calls:
 	 *	- require local superuser power.
@@ -485,7 +485,7 @@ int dev_ioctl(struct net *net, unsigned int cmd, struct ifreq *ifr, bool *need_c
 	case SIOCSHWTSTAMP:
 		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
 			return -EPERM;
-		/* fall through */
+		fallthrough;
 	case SIOCBONDSLAVEINFOQUERY:
 	case SIOCBONDINFOQUERY:
 		dev_load(net, ifr->ifr_name);
diff --git a/net/core/devlink.c b/net/core/devlink.c
index dab89c85e56d..5dcf8c46f0fe 100644
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@ -6255,8 +6255,8 @@ devlink_trap_action_get_from_info(struct genl_info *info,
 
 	val = nla_get_u8(info->attrs[DEVLINK_ATTR_TRAP_ACTION]);
 	switch (val) {
-	case DEVLINK_TRAP_ACTION_DROP: /* fall-through */
-	case DEVLINK_TRAP_ACTION_TRAP: /* fall-through */
+	case DEVLINK_TRAP_ACTION_DROP:
+	case DEVLINK_TRAP_ACTION_TRAP:
 	case DEVLINK_TRAP_ACTION_MIRROR:
 		*p_trap_action = val;
 		break;
diff --git a/net/core/drop_monitor.c b/net/core/drop_monitor.c
index f6d5692d6b78..5802a6a8b65f 100644
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@ -1185,7 +1185,7 @@ static int net_dm_alert_mode_get_from_info(struct genl_info *info,
 	val = nla_get_u8(info->attrs[NET_DM_ATTR_ALERT_MODE]);
 
 	switch (val) {
-	case NET_DM_ALERT_MODE_SUMMARY: /* fall-through */
+	case NET_DM_ALERT_MODE_SUMMARY:
 	case NET_DM_ALERT_MODE_PACKET:
 		*p_alert_mode = val;
 		break;
diff --git a/net/core/filter.c b/net/core/filter.c
index 76aa4a2037db..991889b1dc33 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -9016,7 +9016,7 @@ sk_reuseport_is_valid_access(int off, int size,
 	case bpf_ctx_range(struct sk_reuseport_md, eth_protocol):
 		if (size < FIELD_SIZEOF(struct sk_buff, protocol))
 			return false;
-		/* fall through */
+		fallthrough;
 	case bpf_ctx_range(struct sk_reuseport_md, ip_protocol):
 	case bpf_ctx_range(struct sk_reuseport_md, bind_inany):
 	case bpf_ctx_range(struct sk_reuseport_md, len):
* Unmerged path net/core/pktgen.c
diff --git a/net/core/skmsg.c b/net/core/skmsg.c
index 6a32a1fd34f8..649583158983 100644
--- a/net/core/skmsg.c
+++ b/net/core/skmsg.c
@@ -772,7 +772,6 @@ static void sk_psock_verdict_apply(struct sk_psock *psock,
 		sk_psock_skb_redirect(skb);
 		break;
 	case __SK_DROP:
-		/* fall-through */
 	default:
 out_free:
 		kfree_skb(skb);
* Unmerged path net/core/sock.c
diff --git a/net/dccp/ccids/ccid3.c b/net/dccp/ccids/ccid3.c
index 12877a1514e7..cd4ff8658453 100644
--- a/net/dccp/ccids/ccid3.c
+++ b/net/dccp/ccids/ccid3.c
@@ -621,7 +621,7 @@ static void ccid3_hc_rx_send_feedback(struct sock *sk,
 		 */
 		if (hc->rx_x_recv > 0)
 			break;
-		/* fall through */
+		fallthrough;
 	case CCID3_FBACK_PERIODIC:
 		delta = ktime_us_delta(now, hc->rx_tstamp_last_feedback);
 		if (delta <= 0)
diff --git a/net/dccp/feat.c b/net/dccp/feat.c
index f227f002c73d..2513d3fd9de6 100644
--- a/net/dccp/feat.c
+++ b/net/dccp/feat.c
@@ -1403,7 +1403,8 @@ int dccp_feat_parse_options(struct sock *sk, struct dccp_request_sock *dreq,
 	 *	Negotiation during connection setup
 	 */
 	case DCCP_LISTEN:
-		server = true;			/* fall through */
+		server = true;
+		fallthrough;
 	case DCCP_REQUESTING:
 		switch (opt) {
 		case DCCPO_CHANGE_L:
diff --git a/net/dccp/input.c b/net/dccp/input.c
index 85d6c879383d..765fa9335e3a 100644
--- a/net/dccp/input.c
+++ b/net/dccp/input.c
@@ -68,7 +68,7 @@ static int dccp_rcv_close(struct sock *sk, struct sk_buff *skb)
 		 */
 		if (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT)
 			break;
-		/* fall through */
+		fallthrough;
 	case DCCP_REQUESTING:
 	case DCCP_ACTIVE_CLOSEREQ:
 		dccp_send_reset(sk, DCCP_RESET_CODE_CLOSED);
@@ -80,7 +80,7 @@ static int dccp_rcv_close(struct sock *sk, struct sk_buff *skb)
 		queued = 1;
 		dccp_fin(sk, skb);
 		dccp_set_state(sk, DCCP_PASSIVE_CLOSE);
-		/* fall through */
+		fallthrough;
 	case DCCP_PASSIVE_CLOSE:
 		/*
 		 * Retransmitted Close: we have already enqueued the first one.
@@ -117,7 +117,7 @@ static int dccp_rcv_closereq(struct sock *sk, struct sk_buff *skb)
 		queued = 1;
 		dccp_fin(sk, skb);
 		dccp_set_state(sk, DCCP_PASSIVE_CLOSEREQ);
-		/* fall through */
+		fallthrough;
 	case DCCP_PASSIVE_CLOSEREQ:
 		sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);
 	}
@@ -534,7 +534,7 @@ static int dccp_rcv_respond_partopen_state_process(struct sock *sk,
 	case DCCP_PKT_DATA:
 		if (sk->sk_state == DCCP_RESPOND)
 			break;
-		/* fall through */
+		fallthrough;
 	case DCCP_PKT_DATAACK:
 	case DCCP_PKT_ACK:
 		/*
@@ -688,7 +688,7 @@ int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 		/* Step 8: if using Ack Vectors, mark packet acknowledgeable */
 		dccp_handle_ackvec_processing(sk, skb);
 		dccp_deliver_input_to_ccids(sk, skb);
-		/* fall through */
+		fallthrough;
 	case DCCP_RESPOND:
 		queued = dccp_rcv_respond_partopen_state_process(sk, skb,
 								 dh, len);
diff --git a/net/dccp/options.c b/net/dccp/options.c
index 4e40db017e19..e4368ce27113 100644
--- a/net/dccp/options.c
+++ b/net/dccp/options.c
@@ -228,7 +228,7 @@ int dccp_parse_options(struct sock *sk, struct dccp_request_sock *dreq,
 			 * interested. The RX CCID need not parse Ack Vectors,
 			 * since it is only interested in clearing old state.
 			 */
-			/* fall through */
+			fallthrough;
 		case DCCPO_MIN_TX_CCID_SPECIFIC ... DCCPO_MAX_TX_CCID_SPECIFIC:
 			if (ccid_hc_tx_parse_options(dp->dccps_hc_tx_ccid, sk,
 						     pkt_type, opt, value, len))
diff --git a/net/dccp/output.c b/net/dccp/output.c
index 91a15b3c4915..f3589da75de3 100644
--- a/net/dccp/output.c
+++ b/net/dccp/output.c
@@ -66,7 +66,7 @@ static int dccp_transmit_skb(struct sock *sk, struct sk_buff *skb)
 		switch (dcb->dccpd_type) {
 		case DCCP_PKT_DATA:
 			set_ack = 0;
-			/* fall through */
+			fallthrough;
 		case DCCP_PKT_DATAACK:
 		case DCCP_PKT_RESET:
 			break;
@@ -76,12 +76,12 @@ static int dccp_transmit_skb(struct sock *sk, struct sk_buff *skb)
 			/* Use ISS on the first (non-retransmitted) Request. */
 			if (icsk->icsk_retransmits == 0)
 				dcb->dccpd_seq = dp->dccps_iss;
-			/* fall through */
+			fallthrough;
 
 		case DCCP_PKT_SYNC:
 		case DCCP_PKT_SYNCACK:
 			ackno = dcb->dccpd_ack_seq;
-			/* fall through */
+			fallthrough;
 		default:
 			/*
 			 * Set owner/destructor: some skbs are allocated via
@@ -485,7 +485,7 @@ struct sk_buff *dccp_ctl_make_reset(struct sock *sk, struct sk_buff *rcv_skb)
 	case DCCP_RESET_CODE_PACKET_ERROR:
 		dhr->dccph_reset_data[0] = rxdh->dccph_type;
 		break;
-	case DCCP_RESET_CODE_OPTION_ERROR:	/* fall through */
+	case DCCP_RESET_CODE_OPTION_ERROR:
 	case DCCP_RESET_CODE_MANDATORY_ERROR:
 		memcpy(dhr->dccph_reset_data, dcb->dccpd_reset_data, 3);
 		break;
diff --git a/net/dccp/proto.c b/net/dccp/proto.c
index 8cc6869510b7..7631cf2531af 100644
--- a/net/dccp/proto.c
+++ b/net/dccp/proto.c
@@ -104,7 +104,7 @@ void dccp_set_state(struct sock *sk, const int state)
 		if (inet_csk(sk)->icsk_bind_hash != NULL &&
 		    !(sk->sk_userlocks & SOCK_BINDPORT_LOCK))
 			inet_put_port(sk);
-		/* fall through */
+		fallthrough;
 	default:
 		if (oldstate == DCCP_OPEN)
 			DCCP_DEC_STATS(DCCP_MIB_CURRESTAB);
@@ -856,7 +856,7 @@ int dccp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
 		case DCCP_PKT_CLOSEREQ:
 			if (!(flags & MSG_PEEK))
 				dccp_finish_passive_close(sk);
-			/* fall through */
+			fallthrough;
 		case DCCP_PKT_RESET:
 			dccp_pr_debug("found fin (%s) ok!\n",
 				      dccp_packet_name(dh->dccph_type));
@@ -982,7 +982,7 @@ static void dccp_terminate_connection(struct sock *sk)
 	case DCCP_PARTOPEN:
 		dccp_pr_debug("Stop PARTOPEN timer (%p)\n", sk);
 		inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
-		/* fall through */
+		fallthrough;
 	case DCCP_OPEN:
 		dccp_send_close(sk, 1);
 
@@ -991,7 +991,7 @@ static void dccp_terminate_connection(struct sock *sk)
 			next_state = DCCP_ACTIVE_CLOSEREQ;
 		else
 			next_state = DCCP_CLOSING;
-		/* fall through */
+		fallthrough;
 	default:
 		dccp_set_state(sk, next_state);
 	}
diff --git a/net/decnet/af_decnet.c b/net/decnet/af_decnet.c
index 838f1112b2b1..e98090768359 100644
--- a/net/decnet/af_decnet.c
+++ b/net/decnet/af_decnet.c
@@ -630,12 +630,12 @@ static void dn_destroy_sock(struct sock *sk)
 		goto disc_reject;
 	case DN_RUN:
 		scp->state = DN_DI;
-		/* fall through */
+		fallthrough;
 	case DN_DI:
 	case DN_DR:
 disc_reject:
 		dn_nsp_send_disc(sk, NSP_DISCINIT, 0, sk->sk_allocation);
-		/* fall through */
+		fallthrough;
 	case DN_NC:
 	case DN_NR:
 	case DN_RJ:
@@ -649,7 +649,7 @@ static void dn_destroy_sock(struct sock *sk)
 		break;
 	default:
 		printk(KERN_DEBUG "DECnet: dn_destroy_sock passed socket in invalid state\n");
-		/* fall through */
+		fallthrough;
 	case DN_O:
 		dn_stop_slow_timer(sk);
 
* Unmerged path net/decnet/dn_nsp_in.c
diff --git a/net/decnet/dn_table.c b/net/decnet/dn_table.c
index 33fefb0aebca..4086f9c746af 100644
--- a/net/decnet/dn_table.c
+++ b/net/decnet/dn_table.c
@@ -156,7 +156,7 @@ static void dn_rehash_zone(struct dn_zone *dz)
 	default:
 		printk(KERN_DEBUG "DECnet: dn_rehash_zone: BUG! %d\n",
 		       old_divisor);
-		/* fall through */
+		fallthrough;
 	case 256:
 		new_divisor = 1024;
 		new_hashmask = 0x3FF;
diff --git a/net/decnet/sysctl_net_decnet.c b/net/decnet/sysctl_net_decnet.c
index 55bf64a22b59..c882aa27690b 100644
--- a/net/decnet/sysctl_net_decnet.c
+++ b/net/decnet/sysctl_net_decnet.c
@@ -75,7 +75,7 @@ static void strip_it(char *str)
 		case '\r':
 		case ':':
 			*str = 0;
-			/* Fallthrough */
+			fallthrough;
 		case 0:
 			return;
 		}
diff --git a/net/dsa/slave.c b/net/dsa/slave.c
index 8e382da7c316..2bc8193c19de 100644
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -1526,7 +1526,7 @@ static int dsa_slave_switchdev_event(struct notifier_block *unused,
 	switchdev_work->event = event;
 
 	switch (event) {
-	case SWITCHDEV_FDB_ADD_TO_DEVICE: /* fall through */
+	case SWITCHDEV_FDB_ADD_TO_DEVICE:
 	case SWITCHDEV_FDB_DEL_TO_DEVICE:
 		if (dsa_slave_switchdev_fdb_work_init(switchdev_work, ptr))
 			goto err_fdb_work_init;
diff --git a/net/ieee802154/6lowpan/reassembly.c b/net/ieee802154/6lowpan/reassembly.c
index a0cbc56d1d03..1ed670be980a 100644
--- a/net/ieee802154/6lowpan/reassembly.c
+++ b/net/ieee802154/6lowpan/reassembly.c
@@ -289,7 +289,7 @@ static int lowpan_frag_rx_handlers_result(struct sk_buff *skb,
 		net_warn_ratelimited("%s: received unknown dispatch\n",
 				     __func__);
 
-		/* fall-through */
+		fallthrough;
 	default:
 		/* all others failure */
 		return NET_RX_DROP;
diff --git a/net/ieee802154/6lowpan/rx.c b/net/ieee802154/6lowpan/rx.c
index 649e7d45e88f..4bcbf93ad614 100644
--- a/net/ieee802154/6lowpan/rx.c
+++ b/net/ieee802154/6lowpan/rx.c
@@ -43,11 +43,11 @@ static int lowpan_rx_handlers_result(struct sk_buff *skb, lowpan_rx_result res)
 		net_warn_ratelimited("%s: received unknown dispatch\n",
 				     __func__);
 
-		/* fall-through */
+		fallthrough;
 	case RX_DROP_UNUSABLE:
 		kfree_skb(skb);
 
-		/* fall-through */
+		fallthrough;
 	case RX_DROP:
 		return NET_RX_DROP;
 	case RX_QUEUED:
* Unmerged path net/iucv/af_iucv.c
diff --git a/net/mpls/af_mpls.c b/net/mpls/af_mpls.c
index 6d8199472765..a795728306ed 100644
--- a/net/mpls/af_mpls.c
+++ b/net/mpls/af_mpls.c
@@ -1518,7 +1518,7 @@ static void mpls_ifdown(struct net_device *dev, int event)
 			case NETDEV_DOWN:
 			case NETDEV_UNREGISTER:
 				nh_flags |= RTNH_F_DEAD;
-				/* fall through */
+				fallthrough;
 			case NETDEV_CHANGE:
 				nh_flags |= RTNH_F_LINKDOWN;
 				break;
diff --git a/net/mptcp/protocol.c b/net/mptcp/protocol.c
index 2ecf7fd58ba2..4c43f3ce4219 100644
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@ -217,7 +217,6 @@ static void mptcp_check_data_fin_ack(struct sock *sk)
 			sk->sk_state_change(sk);
 			break;
 		case TCP_CLOSING:
-			fallthrough;
 		case TCP_LAST_ACK:
 			inet_sk_state_store(sk, TCP_CLOSE);
 			sk->sk_state_change(sk);
@@ -1575,7 +1574,7 @@ static void mptcp_subflow_shutdown(struct sock *sk, struct sock *ssk, int how)
 	case TCP_LISTEN:
 		if (!(how & RCV_SHUTDOWN))
 			break;
-		/* fall through */
+		fallthrough;
 	case TCP_SYN_SENT:
 		tcp_disconnect(ssk, O_NONBLOCK);
 		break;
diff --git a/net/ncsi/ncsi-manage.c b/net/ncsi/ncsi-manage.c
index 091284760d21..940e8fc68a3f 100644
--- a/net/ncsi/ncsi-manage.c
+++ b/net/ncsi/ncsi-manage.c
@@ -437,7 +437,7 @@ static void ncsi_suspend_channel(struct ncsi_dev_priv *ndp)
 	switch (nd->state) {
 	case ncsi_dev_state_suspend:
 		nd->state = ncsi_dev_state_suspend_select;
-		/* Fall through */
+		fallthrough;
 	case ncsi_dev_state_suspend_select:
 		ndp->pending_req_num = 1;
 
@@ -995,7 +995,7 @@ static void ncsi_probe_channel(struct ncsi_dev_priv *ndp)
 	switch (nd->state) {
 	case ncsi_dev_state_probe:
 		nd->state = ncsi_dev_state_probe_deselect;
-		/* Fall through */
+		fallthrough;
 	case ncsi_dev_state_probe_deselect:
 		ndp->pending_req_num = 8;
 
diff --git a/net/netfilter/ipvs/ip_vs_proto_tcp.c b/net/netfilter/ipvs/ip_vs_proto_tcp.c
index 80d10ad12a15..14a80da176c1 100644
--- a/net/netfilter/ipvs/ip_vs_proto_tcp.c
+++ b/net/netfilter/ipvs/ip_vs_proto_tcp.c
@@ -315,7 +315,7 @@ tcp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)
 	switch (skb->ip_summed) {
 	case CHECKSUM_NONE:
 		skb->csum = skb_checksum(skb, tcphoff, skb->len - tcphoff, 0);
-		/* fall through */
+		fallthrough;
 	case CHECKSUM_COMPLETE:
 #ifdef CONFIG_IP_VS_IPV6
 		if (af == AF_INET6) {
diff --git a/net/netfilter/ipvs/ip_vs_proto_udp.c b/net/netfilter/ipvs/ip_vs_proto_udp.c
index e0ef11c3691e..cdd356cbbc97 100644
--- a/net/netfilter/ipvs/ip_vs_proto_udp.c
+++ b/net/netfilter/ipvs/ip_vs_proto_udp.c
@@ -319,7 +319,7 @@ udp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)
 		case CHECKSUM_NONE:
 			skb->csum = skb_checksum(skb, udphoff,
 						 skb->len - udphoff, 0);
-			/* fall through */
+			fallthrough;
 		case CHECKSUM_COMPLETE:
 #ifdef CONFIG_IP_VS_IPV6
 			if (af == AF_INET6) {
diff --git a/net/netlink/policy.c b/net/netlink/policy.c
index 2b3e26f7496f..641ffbdd977a 100644
--- a/net/netlink/policy.c
+++ b/net/netlink/policy.c
@@ -188,7 +188,7 @@ int netlink_policy_dump_write(struct sk_buff *skb, unsigned long _state)
 		goto next;
 	case NLA_NESTED:
 		type = NL_ATTR_TYPE_NESTED;
-		/* fall through */
+		fallthrough;
 	case NLA_NESTED_ARRAY:
 		if (pt->type == NLA_NESTED_ARRAY)
 			type = NL_ATTR_TYPE_NESTED_ARRAY;
diff --git a/net/netrom/nr_in.c b/net/netrom/nr_in.c
index fbfdae452ff9..70815a21fc89 100644
--- a/net/netrom/nr_in.c
+++ b/net/netrom/nr_in.c
@@ -125,7 +125,7 @@ static int nr_state2_machine(struct sock *sk, struct sk_buff *skb,
 
 	case NR_DISCREQ:
 		nr_write_internal(sk, NR_DISCACK);
-		/* fall through */
+		fallthrough;
 	case NR_DISCACK:
 		nr_disconnect(sk, 0);
 		break;
diff --git a/net/netrom/nr_route.c b/net/netrom/nr_route.c
index 6485f593e2f0..9b98da811287 100644
--- a/net/netrom/nr_route.c
+++ b/net/netrom/nr_route.c
@@ -265,7 +265,7 @@ static int __must_check nr_add_node(ax25_address *nr, const char *mnemonic,
 	case 3:
 		re_sort_routes(nr_node, 0, 1);
 		re_sort_routes(nr_node, 1, 2);
-		/* fall through */
+		fallthrough;
 	case 2:
 		re_sort_routes(nr_node, 0, 1);
 	case 1:
@@ -358,7 +358,7 @@ static int nr_del_node(ax25_address *callsign, ax25_address *neighbour, struct n
 				switch (i) {
 				case 0:
 					nr_node->routes[0] = nr_node->routes[1];
-					/* fall through */
+					fallthrough;
 				case 1:
 					nr_node->routes[1] = nr_node->routes[2];
 				case 2:
@@ -481,7 +481,7 @@ static int nr_dec_obs(void)
 				switch (i) {
 				case 0:
 					s->routes[0] = s->routes[1];
-					/* Fallthrough */
+					fallthrough;
 				case 1:
 					s->routes[1] = s->routes[2];
 				case 2:
@@ -528,7 +528,7 @@ void nr_rt_device_down(struct net_device *dev)
 						switch (i) {
 						case 0:
 							t->routes[0] = t->routes[1];
-							/* fall through */
+							fallthrough;
 						case 1:
 							t->routes[1] = t->routes[2];
 						case 2:
diff --git a/net/openvswitch/conntrack.c b/net/openvswitch/conntrack.c
index a0686a88634c..577ec8ffd0bd 100644
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@ -786,7 +786,7 @@ static int ovs_ct_nat_execute(struct sk_buff *skb, struct nf_conn *ct,
 			}
 		}
 		/* Non-ICMP, fall thru to initialize if needed. */
-		/* fall through */
+		fallthrough;
 	case IP_CT_NEW:
 		/* Seen it before?  This can happen for loopback, retrans,
 		 * or local packets.
@@ -1552,7 +1552,7 @@ static int parse_ct(const struct nlattr *attr, struct ovs_conntrack_info *info,
 		switch (type) {
 		case OVS_CT_ATTR_FORCE_COMMIT:
 			info->force = true;
-			/* fall through. */
+			fallthrough;
 		case OVS_CT_ATTR_COMMIT:
 			info->commit = true;
 			break;
diff --git a/net/openvswitch/flow.c b/net/openvswitch/flow.c
index 03f856a935ca..42178c61d094 100644
--- a/net/openvswitch/flow.c
+++ b/net/openvswitch/flow.c
@@ -688,7 +688,7 @@ static int key_extract_l3l4(struct sk_buff *skb, struct sw_flow_key *key)
 			case -EINVAL:
 				memset(&key->ip, 0, sizeof(key->ip));
 				memset(&key->ipv6.addr, 0, sizeof(key->ipv6.addr));
-				/* fall-through */
+				fallthrough;
 			case -EPROTO:
 				skb->transport_header = skb->network_header;
 				error = 0;
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index bc5a8075b96e..d33a6f5648e8 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -4035,7 +4035,7 @@ static int packet_notifier(struct notifier_block *this,
 		case NETDEV_UNREGISTER:
 			if (po->mclist)
 				packet_dev_mclist_delete(dev, &po->mclist);
-			/* fallthrough */
+			fallthrough;
 
 		case NETDEV_DOWN:
 			if (dev->ifindex == po->ifindex) {
diff --git a/net/phonet/pep.c b/net/phonet/pep.c
index 9fc76b19cd3c..cca7346d8fc3 100644
--- a/net/phonet/pep.c
+++ b/net/phonet/pep.c
@@ -381,7 +381,7 @@ static int pipe_do_rcv(struct sock *sk, struct sk_buff *skb)
 			err = -EINVAL;
 			goto out;
 		}
-		/* fall through */
+		fallthrough;
 	case PNS_PEP_DISABLE_REQ:
 		atomic_set(&pn->tx_credits, 0);
 		pep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);
@@ -398,7 +398,7 @@ static int pipe_do_rcv(struct sock *sk, struct sk_buff *skb)
 
 	case PNS_PIPE_ALIGNED_DATA:
 		__skb_pull(skb, 1);
-		/* fall through */
+		fallthrough;
 	case PNS_PIPE_DATA:
 		__skb_pull(skb, 3); /* Pipe data header */
 		if (!pn_flow_safe(pn->rx_fc)) {
@@ -430,11 +430,11 @@ static int pipe_do_rcv(struct sock *sk, struct sk_buff *skb)
 		err = pipe_rcv_created(sk, skb);
 		if (err)
 			break;
-		/* fall through */
+		fallthrough;
 	case PNS_PIPE_RESET_IND:
 		if (!pn->init_enable)
 			break;
-		/* fall through */
+		fallthrough;
 	case PNS_PIPE_ENABLED_IND:
 		if (!pn_flow_safe(pn->tx_fc)) {
 			atomic_set(&pn->tx_credits, 1);
@@ -568,7 +568,7 @@ static int pipe_handler_do_rcv(struct sock *sk, struct sk_buff *skb)
 	switch (hdr->message_id) {
 	case PNS_PIPE_ALIGNED_DATA:
 		__skb_pull(skb, 1);
-		/* fall through */
+		fallthrough;
 	case PNS_PIPE_DATA:
 		__skb_pull(skb, 3); /* Pipe data header */
 		if (!pn_flow_safe(pn->rx_fc)) {
diff --git a/net/rds/send.c b/net/rds/send.c
index 59f17a2335f4..9ea613df49c4 100644
--- a/net/rds/send.c
+++ b/net/rds/send.c
@@ -902,7 +902,7 @@ static int rds_rm_size(struct msghdr *msg, int num_sgs)
 
 		case RDS_CMSG_ZCOPY_COOKIE:
 			zcopy_cookie = true;
-			/* fall through */
+			fallthrough;
 
 		case RDS_CMSG_RDMA_DEST:
 		case RDS_CMSG_RDMA_MAP:
diff --git a/net/rose/rose_in.c b/net/rose/rose_in.c
index 9bbbfe325c5a..53a1318a2631 100644
--- a/net/rose/rose_in.c
+++ b/net/rose/rose_in.c
@@ -219,7 +219,7 @@ static int rose_state4_machine(struct sock *sk, struct sk_buff *skb, int framety
 	switch (frametype) {
 	case ROSE_RESET_REQUEST:
 		rose_write_internal(sk, ROSE_RESET_CONFIRMATION);
-		/* fall through */
+		fallthrough;
 	case ROSE_RESET_CONFIRMATION:
 		rose_stop_timer(sk);
 		rose_start_idletimer(sk);
diff --git a/net/rose/rose_route.c b/net/rose/rose_route.c
index 77e9f85a2c92..5f8495166f37 100644
--- a/net/rose/rose_route.c
+++ b/net/rose/rose_route.c
@@ -346,7 +346,7 @@ static int rose_del_node(struct rose_route_struct *rose_route,
 				case 0:
 					rose_node->neighbour[0] =
 						rose_node->neighbour[1];
-					/* fall through */
+					fallthrough;
 				case 1:
 					rose_node->neighbour[1] =
 						rose_node->neighbour[2];
@@ -508,7 +508,7 @@ void rose_rt_device_down(struct net_device *dev)
 				switch (i) {
 				case 0:
 					t->neighbour[0] = t->neighbour[1];
-					/* fall through */
+					fallthrough;
 				case 1:
 					t->neighbour[1] = t->neighbour[2];
 				case 2:
* Unmerged path net/rxrpc/af_rxrpc.c
diff --git a/net/rxrpc/call_accept.c b/net/rxrpc/call_accept.c
index 9d1e298b784c..e004dff5f347 100644
--- a/net/rxrpc/call_accept.c
+++ b/net/rxrpc/call_accept.c
@@ -612,7 +612,7 @@ int rxrpc_reject_call(struct rxrpc_sock *rx)
 	case RXRPC_CALL_SERVER_ACCEPTING:
 		__rxrpc_abort_call("REJ", call, 1, RX_USER_ABORT, -ECONNABORTED);
 		abort = true;
-		/* fall through */
+		fallthrough;
 	case RXRPC_CALL_COMPLETE:
 		ret = call->error;
 		goto out_discard;
diff --git a/net/rxrpc/conn_client.c b/net/rxrpc/conn_client.c
index 5736f643c516..4fae389091a6 100644
--- a/net/rxrpc/conn_client.c
+++ b/net/rxrpc/conn_client.c
@@ -861,7 +861,7 @@ void rxrpc_disconnect_client_call(struct rxrpc_call *call)
 			conn->cache_state = RXRPC_CONN_CLIENT_ACTIVE;
 			rxrpc_activate_channels_locked(conn);
 		}
-		/* fall through */
+		fallthrough;
 	case RXRPC_CONN_CLIENT_ACTIVE:
 		if (list_empty(&conn->waiting_calls)) {
 			rxrpc_deactivate_one_channel(conn, channel);
* Unmerged path net/rxrpc/input.c
* Unmerged path net/rxrpc/local_object.c
* Unmerged path net/rxrpc/peer_event.c
* Unmerged path net/rxrpc/recvmsg.c
diff --git a/net/rxrpc/sendmsg.c b/net/rxrpc/sendmsg.c
index be01f9c5d963..4000e38109ed 100644
--- a/net/rxrpc/sendmsg.c
+++ b/net/rxrpc/sendmsg.c
@@ -207,7 +207,7 @@ static void rxrpc_queue_packet(struct rxrpc_sock *rx, struct rxrpc_call *call,
 			trace_rxrpc_timer(call, rxrpc_timer_init_for_send_reply, now);
 			if (!last)
 				break;
-			/* Fall through */
+			fallthrough;
 		case RXRPC_CALL_SERVER_SEND_REPLY:
 			call->state = RXRPC_CALL_SERVER_AWAIT_ACK;
 			rxrpc_notify_end_tx(rx, call, notify_end_tx);
@@ -689,13 +689,13 @@ int rxrpc_do_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg, size_t len)
 		if (p.call.timeouts.normal > 0 && j == 0)
 			j = 1;
 		WRITE_ONCE(call->next_rx_timo, j);
-		/* Fall through */
+		fallthrough;
 	case 2:
 		j = msecs_to_jiffies(p.call.timeouts.idle);
 		if (p.call.timeouts.idle > 0 && j == 0)
 			j = 1;
 		WRITE_ONCE(call->next_req_timo, j);
-		/* Fall through */
+		fallthrough;
 	case 1:
 		if (p.call.timeouts.hard > 0) {
 			j = msecs_to_jiffies(p.call.timeouts.hard);
diff --git a/net/sched/sch_cake.c b/net/sched/sch_cake.c
index 561d20c9adca..042e12394b63 100644
--- a/net/sched/sch_cake.c
+++ b/net/sched/sch_cake.c
@@ -1670,7 +1670,7 @@ static u32 cake_classify(struct Qdisc *sch, struct cake_tin_data **t,
 		case TC_ACT_QUEUED:
 		case TC_ACT_TRAP:
 			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
-			/* fall through */
+			fallthrough;
 		case TC_ACT_SHOT:
 			return 0;
 		}
diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c
index 736d8ca9821b..704246bd7110 100644
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@ -887,7 +887,7 @@ static int sctp_inet6_af_supported(sa_family_t family, struct sctp_sock *sp)
 	case AF_INET:
 		if (!__ipv6_only_sock(sctp_opt2sk(sp)))
 			return 1;
-		/* fallthru */
+		fallthrough;
 	default:
 		return 0;
 	}
diff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c
index fd33281999b5..f195c2ab5201 100644
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@ -926,7 +926,7 @@ static void sctp_outq_flush_ctrl(struct sctp_flush_ctx *ctx)
 		case SCTP_CID_ABORT:
 			if (sctp_test_T_bit(chunk))
 				ctx->packet->vtag = ctx->asoc->c.my_vtag;
-			/* fallthru */
+			fallthrough;
 
 		/* The following chunks are "response" chunks, i.e.
 		 * they are generated in response to something we
@@ -941,7 +941,7 @@ static void sctp_outq_flush_ctrl(struct sctp_flush_ctx *ctx)
 		case SCTP_CID_ECN_CWR:
 		case SCTP_CID_ASCONF_ACK:
 			one_packet = 1;
-			/* Fall through */
+			fallthrough;
 
 		case SCTP_CID_SACK:
 		case SCTP_CID_HEARTBEAT:
@@ -1044,7 +1044,7 @@ static void sctp_outq_flush_data(struct sctp_flush_ctx *ctx,
 		if (!ctx->packet || !ctx->packet->has_cookie_echo)
 			return;
 
-		/* fall through */
+		fallthrough;
 	case SCTP_STATE_ESTABLISHED:
 	case SCTP_STATE_SHUTDOWN_PENDING:
 	case SCTP_STATE_SHUTDOWN_RECEIVED:
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 356a7093572d..c2296e3a50ac 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -2101,7 +2101,7 @@ static enum sctp_ierror sctp_process_unk_param(
 		break;
 	case SCTP_PARAM_ACTION_DISCARD_ERR:
 		retval =  SCTP_IERROR_ERROR;
-		/* Fall through */
+		fallthrough;
 	case SCTP_PARAM_ACTION_SKIP_ERR:
 		/* Make an ERROR chunk, preparing enough room for
 		 * returning multiple unknown parameters.
diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c
index a0591dd130f3..c122425ae89e 100644
--- a/net/sctp/sm_sideeffect.c
+++ b/net/sctp/sm_sideeffect.c
@@ -1535,7 +1535,7 @@ static int sctp_cmd_interpreter(enum sctp_event_type event_type,
 
 			if (timer_pending(timer))
 				break;
-			/* fall through */
+			fallthrough;
 
 		case SCTP_CMD_TIMER_START:
 			timer = &asoc->timers[cmd->obj.to];
diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c
index 45c81a072ab6..38368581c930 100644
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@ -4330,7 +4330,7 @@ enum sctp_disposition sctp_sf_eat_auth(struct net *net,
 			sctp_add_cmd_sf(commands, SCTP_CMD_REPLY,
 					SCTP_CHUNK(err_chunk));
 		}
-		/* Fall Through */
+		fallthrough;
 	case SCTP_IERROR_AUTH_BAD_KEYID:
 	case SCTP_IERROR_BAD_SIG:
 		return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);
diff --git a/net/smc/smc_close.c b/net/smc/smc_close.c
index a55c2672e41a..0f9ffba07d26 100644
--- a/net/smc/smc_close.c
+++ b/net/smc/smc_close.c
@@ -373,7 +373,7 @@ static void smc_close_passive_work(struct work_struct *work)
 	case SMC_PEERCLOSEWAIT1:
 		if (rxflags->peer_done_writing)
 			sk->sk_state = SMC_PEERCLOSEWAIT2;
-		/* fall through */
+		fallthrough;
 		/* to check for closing */
 	case SMC_PEERCLOSEWAIT2:
 		if (!smc_cdc_rxed_any_close(conn))
diff --git a/net/sunrpc/auth_gss/gss_krb5_wrap.c b/net/sunrpc/auth_gss/gss_krb5_wrap.c
index b912da181237..a6536819ccb3 100644
--- a/net/sunrpc/auth_gss/gss_krb5_wrap.c
+++ b/net/sunrpc/auth_gss/gss_krb5_wrap.c
@@ -137,7 +137,7 @@ gss_krb5_make_confounder(char *p, u32 conflen)
 	switch (conflen) {
 	case 16:
 		*q++ = i++;
-		/* fall through */
+		fallthrough;
 	case 8:
 		*q++ = i++;
 		break;
diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c
index 8ec08bed39cc..83d21e05c4d9 100644
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@ -1701,7 +1701,7 @@ call_reserveresult(struct rpc_task *task)
 	switch (status) {
 	case -ENOMEM:
 		rpc_delay(task, HZ >> 2);
-		/* fall through */
+		fallthrough;
 	case -EAGAIN:	/* woken up; retry */
 		task->tk_action = call_retry_reserve;
 		return;
@@ -1758,13 +1758,13 @@ call_refreshresult(struct rpc_task *task)
 		/* Use rate-limiting and a max number of retries if refresh
 		 * had status 0 but failed to update the cred.
 		 */
-		/* fall through */
+		fallthrough;
 	case -ETIMEDOUT:
 		rpc_delay(task, 3*HZ);
-		/* fall through */
+		fallthrough;
 	case -EAGAIN:
 		status = -EACCES;
-		/* fall through */
+		fallthrough;
 	case -EKEYEXPIRED:
 		if (!task->tk_cred_retry)
 			break;
@@ -2131,7 +2131,7 @@ call_connect_status(struct rpc_task *task)
 			rpc_force_rebind(clnt);
 			goto out_retry;
 		}
-		/* fall through */
+		fallthrough;
 	case -ECONNRESET:
 	case -ECONNABORTED:
 	case -ENETDOWN:
@@ -2145,7 +2145,7 @@ call_connect_status(struct rpc_task *task)
 			break;
 		/* retry with existing socket, after a delay */
 		rpc_delay(task, 3*HZ);
-		/* fall through */
+		fallthrough;
 	case -EADDRINUSE:
 	case -ENOTCONN:
 	case -EAGAIN:
@@ -2227,7 +2227,7 @@ call_transmit_status(struct rpc_task *task)
 		 */
 	case -ENOBUFS:
 		rpc_delay(task, HZ>>2);
-		/* fall through */
+		fallthrough;
 	case -EBADSLT:
 	case -EAGAIN:
 		task->tk_action = call_transmit;
@@ -2246,7 +2246,7 @@ call_transmit_status(struct rpc_task *task)
 			rpc_call_rpcerror(task, task->tk_status);
 			return;
 		}
-		/* fall through */
+		fallthrough;
 	case -ECONNRESET:
 	case -ECONNABORTED:
 	case -EADDRINUSE:
@@ -2312,7 +2312,7 @@ call_bc_transmit_status(struct rpc_task *task)
 		break;
 	case -ENOBUFS:
 		rpc_delay(task, HZ>>2);
-		/* fall through */
+		fallthrough;
 	case -EBADSLT:
 	case -EAGAIN:
 		task->tk_status = 0;
@@ -2379,7 +2379,7 @@ call_status(struct rpc_task *task)
 		 * were a timeout.
 		 */
 		rpc_delay(task, 3*HZ);
-		/* fall through */
+		fallthrough;
 	case -ETIMEDOUT:
 		break;
 	case -ECONNREFUSED:
@@ -2390,7 +2390,7 @@ call_status(struct rpc_task *task)
 		break;
 	case -EADDRINUSE:
 		rpc_delay(task, 3*HZ);
-		/* fall through */
+		fallthrough;
 	case -EPIPE:
 	case -EAGAIN:
 		break;
diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c
index fd2be1b01494..c197d463de73 100644
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -1622,7 +1622,7 @@ void xprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task)
 	case -EAGAIN:
 		xprt_add_backlog(xprt, task);
 		dprintk("RPC:       waiting for request slot\n");
-		/* fall through */
+		fallthrough;
 	default:
 		task->tk_status = -EAGAIN;
 	}
diff --git a/net/sunrpc/xprtrdma/verbs.c b/net/sunrpc/xprtrdma/verbs.c
index ca89f24a1590..ad6e2e4994ce 100644
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@ -268,7 +268,7 @@ rpcrdma_cm_event_handler(struct rdma_cm_id *id, struct rdma_cm_event *event)
 	case RDMA_CM_EVENT_DEVICE_REMOVAL:
 		pr_info("rpcrdma: removing device %s for %pISpc\n",
 			ep->re_id->device->name, sap);
-		/* fall through */
+		fallthrough;
 	case RDMA_CM_EVENT_ADDR_CHANGE:
 		ep->re_connect_status = -ENODEV;
 		goto disconnected;
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 839c49330785..3358e45b43bc 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -885,7 +885,7 @@ static int xs_local_send_request(struct rpc_rqst *req)
 	default:
 		dprintk("RPC:       sendmsg returned unrecognized error %d\n",
 			-status);
-		/* fall through */
+		fallthrough;
 	case -EPIPE:
 		xs_close(xprt);
 		status = -ENOTCONN;
@@ -1436,7 +1436,7 @@ static void xs_tcp_state_change(struct sock *sk)
 		xprt->connect_cookie++;
 		clear_bit(XPRT_CONNECTED, &xprt->state);
 		xs_run_error_worker(transport, XPRT_SOCK_WAKE_DISCONNECT);
-		/* fall through */
+		fallthrough;
 	case TCP_CLOSING:
 		/*
 		 * If the server closed down the connection, make sure that
@@ -2222,7 +2222,7 @@ static int xs_tcp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)
 	switch (ret) {
 	case 0:
 		xs_set_srcport(transport, sock);
-		/* fall through */
+		fallthrough;
 	case -EINPROGRESS:
 		/* SYN_SENT! */
 		if (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)
@@ -2275,7 +2275,7 @@ static void xs_tcp_setup_socket(struct work_struct *work)
 	default:
 		printk("%s: connect returned unhandled error %d\n",
 			__func__, status);
-		/* fall through */
+		fallthrough;
 	case -EADDRNOTAVAIL:
 		/* We're probably in TIME_WAIT. Get rid of existing socket,
 		 * and retry
* Unmerged path net/tipc/bearer.c
diff --git a/net/tipc/group.c b/net/tipc/group.c
index f53871baa42e..b1fcd2ad5ecf 100644
--- a/net/tipc/group.c
+++ b/net/tipc/group.c
@@ -542,7 +542,7 @@ void tipc_group_filter_msg(struct tipc_group *grp, struct sk_buff_head *inputq,
 				update = true;
 				deliver = false;
 			}
-			/* Fall thru */
+			fallthrough;
 		case TIPC_GRP_BCAST_MSG:
 			m->bc_rcv_nxt++;
 			ack = msg_grp_bc_ack_req(hdr);
diff --git a/net/tipc/link.c b/net/tipc/link.c
index bf599140a8ed..eb412d1e463f 100644
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@ -1239,7 +1239,7 @@ static bool tipc_data_input(struct tipc_link *l, struct sk_buff *skb,
 			skb_queue_tail(mc_inputq, skb);
 			return true;
 		}
-		/* fall through */
+		fallthrough;
 	case CONN_MANAGER:
 		skb_queue_tail(inputq, skb);
 		return true;
diff --git a/net/tipc/socket.c b/net/tipc/socket.c
index a6ea682ed228..49d72a1b6ed4 100644
--- a/net/tipc/socket.c
+++ b/net/tipc/socket.c
@@ -784,7 +784,7 @@ static __poll_t tipc_poll(struct file *file, struct socket *sock,
 	case TIPC_ESTABLISHED:
 		if (!tsk->cong_link_cnt && !tsk_conn_cong(tsk))
 			revents |= EPOLLOUT;
-		/* fall through */
+		fallthrough;
 	case TIPC_LISTEN:
 	case TIPC_CONNECTING:
 		if (!skb_queue_empty_lockless(&sk->sk_receive_queue))
@@ -2595,7 +2595,7 @@ static int tipc_connect(struct socket *sock, struct sockaddr *dest,
 		 * case is EINPROGRESS, rather than EALREADY.
 		 */
 		res = -EINPROGRESS;
-		/* fall through */
+		fallthrough;
 	case TIPC_CONNECTING:
 		if (!timeout) {
 			if (previous == TIPC_CONNECTING)
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index fc97ba9309da..9b19848ad0b3 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -812,7 +812,7 @@ static int unix_create(struct net *net, struct socket *sock, int protocol,
 		 */
 	case SOCK_RAW:
 		sock->type = SOCK_DGRAM;
-		/* fall through */
+		fallthrough;
 	case SOCK_DGRAM:
 		sock->ops = &unix_dgram_ops;
 		break;
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index edee3a645c06..6a6f2f214c10 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -959,7 +959,7 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
 		if (!ht_cap->ht_supported &&
 		    chandef->chan->band != NL80211_BAND_6GHZ)
 			return false;
-		/* fall through */
+		fallthrough;
 	case NL80211_CHAN_WIDTH_20_NOHT:
 		prohibited_flags |= IEEE80211_CHAN_NO_20MHZ;
 		width = 20;
@@ -989,7 +989,7 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
 			u32_get_bits(cap, IEEE80211_VHT_CAP_EXT_NSS_BW_MASK) > 1;
 		if (chandef->chan->band != NL80211_BAND_6GHZ && !support_80_80)
 			return false;
-		/* fall through */
+		fallthrough;
 	case NL80211_CHAN_WIDTH_80:
 		prohibited_flags |= IEEE80211_CHAN_NO_80MHZ;
 		width = 80;
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index a6c61a2e6569..db7333e20dd7 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -941,7 +941,7 @@ void cfg80211_cac_event(struct net_device *netdev,
 		       sizeof(struct cfg80211_chan_def));
 		queue_work(cfg80211_wq, &rdev->propagate_cac_done_wk);
 		cfg80211_sched_dfs_chan_update(rdev);
-		/* fall through */
+		fallthrough;
 	case NL80211_RADAR_CAC_ABORTED:
 		wdev->cac_started = false;
 		break;
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 13042c19d042..dc3507008787 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -2109,7 +2109,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 		state->split_start++;
 		if (state->split)
 			break;
-		/* fall through */
+		fallthrough;
 	case 1:
 		if (nla_put(msg, NL80211_ATTR_CIPHER_SUITES,
 			    sizeof(u32) * rdev->wiphy.n_cipher_suites,
@@ -2156,7 +2156,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 		state->split_start++;
 		if (state->split)
 			break;
-		/* fall through */
+		fallthrough;
 	case 2:
 		if (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,
 					rdev->wiphy.interface_modes))
@@ -2164,7 +2164,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 		state->split_start++;
 		if (state->split)
 			break;
-		/* fall through */
+		fallthrough;
 	case 3:
 		nl_bands = nla_nest_start_noflag(msg,
 						 NL80211_ATTR_WIPHY_BANDS);
@@ -2191,7 +2191,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 				state->chan_start++;
 				if (state->split)
 					break;
-				/* fall through */
+				fallthrough;
 			default:
 				/* add frequencies */
 				nl_freqs = nla_nest_start_noflag(msg,
@@ -2246,7 +2246,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 			state->split_start++;
 		if (state->split)
 			break;
-		/* fall through */
+		fallthrough;
 	case 4:
 		nl_cmds = nla_nest_start_noflag(msg,
 						NL80211_ATTR_SUPPORTED_COMMANDS);
@@ -2275,7 +2275,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 		state->split_start++;
 		if (state->split)
 			break;
-		/* fall through */
+		fallthrough;
 	case 5:
 		if (rdev->ops->remain_on_channel &&
 		    (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL) &&
@@ -2293,7 +2293,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 		state->split_start++;
 		if (state->split)
 			break;
-		/* fall through */
+		fallthrough;
 	case 6:
 #ifdef CONFIG_PM
 		if (nl80211_send_wowlan(msg, rdev, state->split))
@@ -2304,7 +2304,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 #else
 		state->split_start++;
 #endif
-		/* fall through */
+		fallthrough;
 	case 7:
 		if (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,
 					rdev->wiphy.software_iftypes))
@@ -2317,7 +2317,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 		state->split_start++;
 		if (state->split)
 			break;
-		/* fall through */
+		fallthrough;
 	case 8:
 		if ((rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME) &&
 		    nla_put_u32(msg, NL80211_ATTR_DEVICE_AP_SME,
@@ -5210,7 +5210,7 @@ bool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info, int attr)
 		break;
 	default:
 		WARN_ON(1);
-		/* fall through */
+		fallthrough;
 	case RATE_INFO_BW_20:
 		rate_flg = 0;
 		break;
diff --git a/net/wireless/scan.c b/net/wireless/scan.c
index d8a609f26fd4..af23a9e74382 100644
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -1920,7 +1920,7 @@ cfg80211_inform_single_bss_data(struct wiphy *wiphy,
 	switch (ftype) {
 	case CFG80211_BSS_FTYPE_BEACON:
 		ies->from_beacon = true;
-		/* fall through */
+		fallthrough;
 	case CFG80211_BSS_FTYPE_UNKNOWN:
 		rcu_assign_pointer(tmp.pub.beacon_ies, ies);
 		break;
diff --git a/net/wireless/sme.c b/net/wireless/sme.c
index 15595cf401de..372f6365f035 100644
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@ -205,7 +205,7 @@ static int cfg80211_conn_do_work(struct wireless_dev *wdev,
 		return err;
 	case CFG80211_CONN_ASSOC_FAILED_TIMEOUT:
 		*treason = NL80211_TIMEOUT_ASSOC;
-		/* fall through */
+		fallthrough;
 	case CFG80211_CONN_ASSOC_FAILED:
 		cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
 				     NULL, 0,
@@ -215,7 +215,7 @@ static int cfg80211_conn_do_work(struct wireless_dev *wdev,
 		cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
 				     NULL, 0,
 				     WLAN_REASON_DEAUTH_LEAVING, false);
-		/* fall through */
+		fallthrough;
 	case CFG80211_CONN_ABANDON:
 		/* free directly, disconnected event already sent */
 		cfg80211_sme_free(wdev);
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 7c5888a31af0..f2f9890272ba 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -200,7 +200,7 @@ static void set_mandatory_flags_band(struct ieee80211_supported_band *sband)
 				sband->bitrates[i].flags |=
 					IEEE80211_RATE_MANDATORY_G;
 				want--;
-				/* fall through */
+				fallthrough;
 			default:
 				sband->bitrates[i].flags |=
 					IEEE80211_RATE_ERP_G;
@@ -1010,7 +1010,7 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 		case NL80211_IFTYPE_STATION:
 			if (dev->ieee80211_ptr->use_4addr)
 				break;
-			/* fall through */
+			fallthrough;
 		case NL80211_IFTYPE_OCB:
 		case NL80211_IFTYPE_P2P_CLIENT:
 		case NL80211_IFTYPE_ADHOC:
diff --git a/net/wireless/wext-compat.c b/net/wireless/wext-compat.c
index aa918d7ff6bd..4d2160c989a3 100644
--- a/net/wireless/wext-compat.c
+++ b/net/wireless/wext-compat.c
@@ -1334,7 +1334,7 @@ static struct iw_statistics *cfg80211_wireless_stats(struct net_device *dev)
 			wstats.qual.qual = sig + 110;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case CFG80211_SIGNAL_TYPE_UNSPEC:
 		if (sinfo.filled & BIT_ULL(NL80211_STA_INFO_SIGNAL)) {
 			wstats.qual.updated |= IW_QUAL_LEVEL_UPDATED;
@@ -1343,7 +1343,7 @@ static struct iw_statistics *cfg80211_wireless_stats(struct net_device *dev)
 			wstats.qual.qual = sinfo.signal;
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	default:
 		wstats.qual.updated |= IW_QUAL_LEVEL_INVALID;
 		wstats.qual.updated |= IW_QUAL_QUAL_INVALID;
diff --git a/net/x25/x25_facilities.c b/net/x25/x25_facilities.c
index ad1734d36ed7..bfe6373bc9aa 100644
--- a/net/x25/x25_facilities.c
+++ b/net/x25/x25_facilities.c
@@ -103,7 +103,7 @@ int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,
 					*vc_fac_mask |= X25_MASK_REVERSE;
 					break;
 				}
-				/*fall through */
+				fallthrough;
 			case X25_FAC_THROUGHPUT:
 				facilities->throughput = p[1];
 				*vc_fac_mask |= X25_MASK_THROUGHPUT;
diff --git a/net/x25/x25_in.c b/net/x25/x25_in.c
index 3c12cae32001..a62e50c26029 100644
--- a/net/x25/x25_in.c
+++ b/net/x25/x25_in.c
@@ -345,7 +345,7 @@ static int x25_state4_machine(struct sock *sk, struct sk_buff *skb, int frametyp
 
 		case X25_RESET_REQUEST:
 			x25_write_internal(sk, X25_RESET_CONFIRMATION);
-			/* fall through */
+			fallthrough;
 		case X25_RESET_CONFIRMATION: {
 			x25_stop_timer(sk);
 			x25->condition = 0x00;
* Unmerged path net/xfrm/xfrm_policy.c
diff --git a/samples/bpf/hbm.c b/samples/bpf/hbm.c
index 7d7153777678..4b22ace52f80 100644
--- a/samples/bpf/hbm.c
+++ b/samples/bpf/hbm.c
@@ -483,7 +483,7 @@ int main(int argc, char **argv)
 					"Option -%c requires an argument.\n\n",
 					optopt);
 		case 'h':
-			// fallthrough
+			fallthrough;
 		default:
 			Usage();
 			return 0;
* Unmerged path security/apparmor/domain.c
diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 974affe50531..dd4706076728 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -294,13 +294,13 @@ void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)
 	switch (AUDIT_MODE(profile)) {
 	case AUDIT_ALL:
 		perms->audit = ALL_PERMS_MASK;
-		/* fall through */
+		fallthrough;
 	case AUDIT_NOQUIET:
 		perms->quiet = 0;
 		break;
 	case AUDIT_QUIET:
 		perms->audit = 0;
-		/* fall through */
+		fallthrough;
 	case AUDIT_QUIET_DENIED:
 		perms->quiet = ALL_PERMS_MASK;
 		break;
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index aa167d2dc1fa..ff203e2a9a65 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -225,7 +225,7 @@ static int xattr_verify(enum ima_hooks func, struct integrity_iint_cache *iint,
 	case IMA_XATTR_DIGEST_NG:
 		/* first byte contains algorithm id */
 		hash_start = 1;
-		/* fall through */
+		fallthrough;
 	case IMA_XATTR_DIGEST:
 		if (iint->flags & IMA_DIGSIG_REQUIRED) {
 			*cause = "IMA-signature-required";
@@ -398,7 +398,7 @@ int ima_appraise_measurement(enum ima_hooks func,
 		/* It's fine not to have xattrs when using a modsig. */
 		if (try_modsig)
 			break;
-		/* fall through */
+		fallthrough;
 	case INTEGRITY_NOLABEL:		/* No security.evm xattr. */
 		cause = "missing-HMAC";
 		goto out;
* Unmerged path security/integrity/ima/ima_policy.c
* Unmerged path security/integrity/ima/ima_template_lib.c
* Unmerged path security/keys/process_keys.c
* Unmerged path security/keys/request_key.c
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 59c8121e387c..6ada1ec01352 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -3623,26 +3623,20 @@ static int selinux_file_ioctl(struct file *file, unsigned int cmd,
 
 	switch (cmd) {
 	case FIONREAD:
-	/* fall through */
 	case FIBMAP:
-	/* fall through */
 	case FIGETBSZ:
-	/* fall through */
 	case FS_IOC_GETFLAGS:
-	/* fall through */
 	case FS_IOC_GETVERSION:
 		error = file_has_perm(cred, file, FILE__GETATTR);
 		break;
 
 	case FS_IOC_SETFLAGS:
-	/* fall through */
 	case FS_IOC_SETVERSION:
 		error = file_has_perm(cred, file, FILE__SETATTR);
 		break;
 
 	/* sys_ioctl() checks */
 	case FIONBIO:
-	/* fall through */
 	case FIOASYNC:
 		error = file_has_perm(cred, file, 0);
 		break;
@@ -3800,7 +3794,7 @@ static int selinux_file_fcntl(struct file *file, unsigned int cmd,
 			err = file_has_perm(cred, file, FILE__WRITE);
 			break;
 		}
-		/* fall through */
+		fallthrough;
 	case F_SETOWN:
 	case F_SETSIG:
 	case F_GETFL:
diff --git a/security/selinux/ss/mls.c b/security/selinux/ss/mls.c
index 408d306895f8..d338962fb0c4 100644
--- a/security/selinux/ss/mls.c
+++ b/security/selinux/ss/mls.c
@@ -535,7 +535,7 @@ int mls_compute_sid(struct policydb *p,
 						  scontext, tcontext);
 		}
 
-		/* Fallthrough */
+		fallthrough;
 	case AVTAB_CHANGE:
 		if ((tclass == p->process_class) || sock)
 			/* Use the process MLS attributes. */
@@ -546,8 +546,6 @@ int mls_compute_sid(struct policydb *p,
 	case AVTAB_MEMBER:
 		/* Use the process effective MLS attributes. */
 		return mls_context_cpy_low(newcontext, scontext);
-
-	/* fall through */
 	}
 	return -EINVAL;
 }
* Unmerged path security/smack/smack_lsm.c
* Unmerged path security/tomoyo/common.c
diff --git a/security/tomoyo/file.c b/security/tomoyo/file.c
index 2a374b4da8f5..f2cb5123e0b3 100644
--- a/security/tomoyo/file.c
+++ b/security/tomoyo/file.c
@@ -910,7 +910,7 @@ int tomoyo_path2_perm(const u8 operation, const struct path *path1,
 	case TOMOYO_TYPE_LINK:
 		if (!d_is_dir(path1->dentry))
 			break;
-		/* fall through */
+		fallthrough;
 	case TOMOYO_TYPE_PIVOT_ROOT:
 		tomoyo_add_slash(&buf1);
 		tomoyo_add_slash(&buf2);
diff --git a/sound/ppc/snd_ps3.c b/sound/ppc/snd_ps3.c
index d1a8557a9357..493c126e8570 100644
--- a/sound/ppc/snd_ps3.c
+++ b/sound/ppc/snd_ps3.c
@@ -227,14 +227,14 @@ static int snd_ps3_program_dma(struct snd_ps3_card_info *card,
 	switch (filltype) {
 	case SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL:
 		silent = 1;
-		/* intentionally fall thru */
+		fallthrough;
 	case SND_PS3_DMA_FILLTYPE_FIRSTFILL:
 		ch0_kick_event = PS3_AUDIO_KICK_EVENT_ALWAYS;
 		break;
 
 	case SND_PS3_DMA_FILLTYPE_SILENT_RUNNING:
 		silent = 1;
-		/* intentionally fall thru */
+		fallthrough;
 	case SND_PS3_DMA_FILLTYPE_RUNNING:
 		ch0_kick_event = PS3_AUDIO_KICK_EVENT_SERIALOUT0_EMPTY;
 		break;
diff --git a/sound/soc/atmel/mchp-i2s-mcc.c b/sound/soc/atmel/mchp-i2s-mcc.c
index 3cb63886195f..04acc18f2d72 100644
--- a/sound/soc/atmel/mchp-i2s-mcc.c
+++ b/sound/soc/atmel/mchp-i2s-mcc.c
@@ -536,7 +536,7 @@ static int mchp_i2s_mcc_hw_params(struct snd_pcm_substream *substream,
 		/* cpu is BCLK master */
 		mrb |= MCHP_I2SMCC_MRB_CLKSEL_INT;
 		set_divs = 1;
-		/* fall through */
+		fallthrough;
 	case SND_SOC_DAIFMT_CBM_CFM:
 		/* cpu is slave */
 		mra |= MCHP_I2SMCC_MRA_MODE_SLAVE;
diff --git a/sound/soc/codecs/jz4770.c b/sound/soc/codecs/jz4770.c
index c0a28f06b09a..298689a07168 100644
--- a/sound/soc/codecs/jz4770.c
+++ b/sound/soc/codecs/jz4770.c
@@ -202,7 +202,7 @@ static int jz4770_codec_set_bias_level(struct snd_soc_component *codec,
 				   REG_CR_VIC_SB_SLEEP, REG_CR_VIC_SB_SLEEP);
 		regmap_update_bits(regmap, JZ4770_CODEC_REG_CR_VIC,
 				   REG_CR_VIC_SB, REG_CR_VIC_SB);
-	/* fall-through */
+		fallthrough;
 	default:
 		break;
 	}
diff --git a/sound/soc/codecs/pcm186x.c b/sound/soc/codecs/pcm186x.c
index c5fcc632f670..a33653c615f0 100644
--- a/sound/soc/codecs/pcm186x.c
+++ b/sound/soc/codecs/pcm186x.c
@@ -401,7 +401,7 @@ static int pcm186x_set_fmt(struct snd_soc_dai *dai, unsigned int format)
 		break;
 	case SND_SOC_DAIFMT_DSP_A:
 		priv->tdm_offset += 1;
-		/* fall through */
+		fallthrough;
 		/* DSP_A uses the same basic config as DSP_B
 		 * except we need to shift the TDM output by one BCK cycle
 		 */
diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c
index d8b9c6547142..404be27c15fe 100644
--- a/sound/soc/fsl/fsl_ssi.c
+++ b/sound/soc/fsl/fsl_ssi.c
@@ -898,7 +898,7 @@ static int _fsl_ssi_set_dai_fmt(struct fsl_ssi *ssi, unsigned int fmt)
 					"missing baudclk for master mode\n");
 				return -EINVAL;
 			}
-			/* fall through */
+			fallthrough;
 		case SND_SOC_DAIFMT_CBM_CFS:
 			ssi->i2s_net |= SSI_SCR_I2S_MODE_MASTER;
 			break;
diff --git a/sound/soc/hisilicon/hi6210-i2s.c b/sound/soc/hisilicon/hi6210-i2s.c
index fd5dcd6b9f85..907f5f1f7b44 100644
--- a/sound/soc/hisilicon/hi6210-i2s.c
+++ b/sound/soc/hisilicon/hi6210-i2s.c
@@ -261,13 +261,13 @@ static int hi6210_i2s_hw_params(struct snd_pcm_substream *substream,
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_U16_LE:
 		signed_data = HII2S_I2S_CFG__S2_CODEC_DATA_FORMAT;
-		/* fall through */
+		fallthrough;
 	case SNDRV_PCM_FORMAT_S16_LE:
 		bits = HII2S_BITS_16;
 		break;
 	case SNDRV_PCM_FORMAT_U24_LE:
 		signed_data = HII2S_I2S_CFG__S2_CODEC_DATA_FORMAT;
-		/* fall through */
+		fallthrough;
 	case SNDRV_PCM_FORMAT_S24_LE:
 		bits = HII2S_BITS_24;
 		break;
diff --git a/sound/soc/intel/baytrail/sst-baytrail-pcm.c b/sound/soc/intel/baytrail/sst-baytrail-pcm.c
index 54a66cc6db89..d2cda33b65d5 100644
--- a/sound/soc/intel/baytrail/sst-baytrail-pcm.c
+++ b/sound/soc/intel/baytrail/sst-baytrail-pcm.c
@@ -181,7 +181,7 @@ static int sst_byt_pcm_trigger(struct snd_soc_component *component,
 		break;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		pdata->restore_stream = false;
-		/* fallthrough */
+		fallthrough;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		sst_byt_stream_pause(byt, pcm_data->stream);
 		break;
diff --git a/sound/soc/intel/boards/bytcht_es8316.c b/sound/soc/intel/boards/bytcht_es8316.c
index 414ae4bb5224..7ae34b49815c 100644
--- a/sound/soc/intel/boards/bytcht_es8316.c
+++ b/sound/soc/intel/boards/bytcht_es8316.c
@@ -573,7 +573,7 @@ static int snd_byt_cht_es8316_mc_probe(struct platform_device *pdev)
 			break;
 		default:
 			dev_err(dev, "get speaker GPIO failed: %d\n", ret);
-			/* fall through */
+			fallthrough;
 		case -EPROBE_DEFER:
 			return ret;
 		}
diff --git a/sound/soc/intel/boards/bytcr_rt5651.c b/sound/soc/intel/boards/bytcr_rt5651.c
index 6744e257c3dc..19911326194f 100644
--- a/sound/soc/intel/boards/bytcr_rt5651.c
+++ b/sound/soc/intel/boards/bytcr_rt5651.c
@@ -1008,7 +1008,7 @@ static int snd_byt_rt5651_mc_probe(struct platform_device *pdev)
 			default:
 				dev_err(&pdev->dev, "Failed to get ext-amp-enable GPIO: %d\n",
 					ret_val);
-				/* fall through */
+				fallthrough;
 			case -EPROBE_DEFER:
 				put_device(codec_dev);
 				return ret_val;
@@ -1027,7 +1027,7 @@ static int snd_byt_rt5651_mc_probe(struct platform_device *pdev)
 			default:
 				dev_err(&pdev->dev, "Failed to get hp-detect GPIO: %d\n",
 					ret_val);
-				/* fall through */
+				fallthrough;
 			case -EPROBE_DEFER:
 				put_device(codec_dev);
 				return ret_val;
diff --git a/sound/soc/intel/skylake/skl-pcm.c b/sound/soc/intel/skylake/skl-pcm.c
index 5dee55e9546b..bbe8d782e0af 100644
--- a/sound/soc/intel/skylake/skl-pcm.c
+++ b/sound/soc/intel/skylake/skl-pcm.c
@@ -488,7 +488,7 @@ static int skl_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
 							stream->lpib);
 			snd_hdac_ext_stream_set_lpib(stream, stream->lpib);
 		}
-		/* fall through */
+		fallthrough;
 
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
diff --git a/sound/soc/meson/axg-tdm-interface.c b/sound/soc/meson/axg-tdm-interface.c
index 36df30915378..c8664ab80d45 100644
--- a/sound/soc/meson/axg-tdm-interface.c
+++ b/sound/soc/meson/axg-tdm-interface.c
@@ -58,17 +58,17 @@ int axg_tdm_set_tdm_slots(struct snd_soc_dai *dai, u32 *tx_mask,
 	switch (slot_width) {
 	case 0:
 		slot_width = 32;
-		/* Fall-through */
+		fallthrough;
 	case 32:
 		fmt |= SNDRV_PCM_FMTBIT_S32_LE;
-		/* Fall-through */
+		fallthrough;
 	case 24:
 		fmt |= SNDRV_PCM_FMTBIT_S24_LE;
 		fmt |= SNDRV_PCM_FMTBIT_S20_LE;
-		/* Fall-through */
+		fallthrough;
 	case 16:
 		fmt |= SNDRV_PCM_FMTBIT_S16_LE;
-		/* Fall-through */
+		fallthrough;
 	case 8:
 		fmt |= SNDRV_PCM_FMTBIT_S8;
 		break;
@@ -133,7 +133,7 @@ static int axg_tdm_iface_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	case SND_SOC_DAIFMT_CBS_CFM:
 	case SND_SOC_DAIFMT_CBM_CFS:
 		dev_err(dai->dev, "only CBS_CFS and CBM_CFM are supported\n");
-		/* Fall-through */
+		fallthrough;
 	default:
 		return -EINVAL;
 	}
diff --git a/sound/soc/pxa/pxa-ssp.c b/sound/soc/pxa/pxa-ssp.c
index d1e09ade0190..c4e7307a4437 100644
--- a/sound/soc/pxa/pxa-ssp.c
+++ b/sound/soc/pxa/pxa-ssp.c
@@ -488,7 +488,7 @@ static int pxa_ssp_configure_dai_fmt(struct ssp_priv *priv)
 
 	case SND_SOC_DAIFMT_DSP_A:
 		sspsp |= SSPSP_FSRT;
-		/* fall through */
+		fallthrough;
 	case SND_SOC_DAIFMT_DSP_B:
 		sscr0 |= SSCR0_MOD | SSCR0_PSP;
 		sscr1 |= SSCR1_TRAIL | SSCR1_RWOT;
diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 1707414cfa92..5adb293d0435 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -229,13 +229,13 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 	switch (params_channels(params)) {
 	case 8:
 		val |= PDM_PATH3_EN;
-		/* fallthrough */
+		fallthrough;
 	case 6:
 		val |= PDM_PATH2_EN;
-		/* fallthrough */
+		fallthrough;
 	case 4:
 		val |= PDM_PATH1_EN;
-		/* fallthrough */
+		fallthrough;
 	case 2:
 		val |= PDM_PATH0_EN;
 		break;
diff --git a/sound/soc/samsung/i2s.c b/sound/soc/samsung/i2s.c
index 80ecb5c7fed0..df53d4ea808f 100644
--- a/sound/soc/samsung/i2s.c
+++ b/sound/soc/samsung/i2s.c
@@ -733,7 +733,7 @@ static int i2s_hw_params(struct snd_pcm_substream *substream,
 	switch (params_channels(params)) {
 	case 6:
 		val |= MOD_DC2_EN;
-		/* Fall through */
+		fallthrough;
 	case 4:
 		val |= MOD_DC1_EN;
 		break;
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b574ac6dd27a..c9a028c7d8ca 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -642,7 +642,7 @@ int snd_soc_suspend(struct device *dev)
 						"ASoC: idle_bias_off CODEC on over suspend\n");
 					break;
 				}
-				/* fall through */
+				fallthrough;
 
 			case SND_SOC_BIAS_OFF:
 				snd_soc_component_suspend(component);
diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c
index 63086fa8b861..c5ef432a023b 100644
--- a/sound/soc/soc-topology.c
+++ b/sound/soc/soc-topology.c
@@ -1069,7 +1069,7 @@ static int soc_tplg_denum_create(struct soc_tplg *tplg, unsigned int count,
 					ec->hdr.name);
 				goto err_denum;
 			}
-			/* fall through */
+			fallthrough;
 		case SND_SOC_TPLG_CTL_ENUM:
 		case SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:
 		case SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:
@@ -1457,7 +1457,7 @@ static struct snd_kcontrol_new *soc_tplg_dapm_widget_denum_create(
 					ec->hdr.name);
 				goto err_se;
 			}
-			/* fall through */
+			fallthrough;
 		case SND_SOC_TPLG_CTL_ENUM:
 		case SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:
 		case SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:
diff --git a/sound/soc/sof/intel/hda-dai.c b/sound/soc/sof/intel/hda-dai.c
index df1c6997cb4e..c6cb8c212eca 100644
--- a/sound/soc/sof/intel/hda-dai.c
+++ b/sound/soc/sof/intel/hda-dai.c
@@ -310,7 +310,7 @@ static int hda_link_pcm_trigger(struct snd_pcm_substream *substream,
 			return ret;
 		}
 
-		/* fallthrough */
+		fallthrough;
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		snd_hdac_ext_link_stream_start(link_dev);
@@ -333,7 +333,7 @@ static int hda_link_pcm_trigger(struct snd_pcm_substream *substream,
 
 		link_dev->link_prepared = 0;
 
-		/* fallthrough */
+		fallthrough;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		snd_hdac_ext_link_stream_clear(link_dev);
 		break;
diff --git a/sound/soc/sof/pcm.c b/sound/soc/sof/pcm.c
index 4c5082b7eea9..cbac6f17c52f 100644
--- a/sound/soc/sof/pcm.c
+++ b/sound/soc/sof/pcm.c
@@ -361,7 +361,7 @@ static int sof_pcm_trigger(struct snd_soc_component *component,
 			return ret;
 		}
 
-		/* fallthrough */
+		fallthrough;
 	case SNDRV_PCM_TRIGGER_START:
 		if (spcm->stream[substream->stream].suspend_ignored) {
 			/*
@@ -386,7 +386,7 @@ static int sof_pcm_trigger(struct snd_soc_component *component,
 			spcm->stream[substream->stream].suspend_ignored = true;
 			return 0;
 		}
-		/* fallthrough */
+		fallthrough;
 	case SNDRV_PCM_TRIGGER_STOP:
 		stream.hdr.cmd |= SOF_IPC_STREAM_TRIG_STOP;
 		ipc_first = true;
diff --git a/sound/soc/ti/davinci-i2s.c b/sound/soc/ti/davinci-i2s.c
index d89b5c928c4d..dd34504c09ba 100644
--- a/sound/soc/ti/davinci-i2s.c
+++ b/sound/soc/ti/davinci-i2s.c
@@ -289,7 +289,7 @@ static int davinci_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 		 * rate is lowered.
 		 */
 		inv_fs = true;
-		/* fall through */
+		fallthrough;
 	case SND_SOC_DAIFMT_DSP_A:
 		dev->mode = MOD_DSP_A;
 		break;
diff --git a/sound/soc/ti/n810.c b/sound/soc/ti/n810.c
index a1672b479cb7..f7ae76147bc6 100644
--- a/sound/soc/ti/n810.c
+++ b/sound/soc/ti/n810.c
@@ -46,7 +46,7 @@ static void n810_ext_control(struct snd_soc_dapm_context *dapm)
 	switch (n810_jack_func) {
 	case N810_JACK_HS:
 		line1l = 1;
-		/* fall through */
+		fallthrough;
 	case N810_JACK_HP:
 		hp = 1;
 		break;
diff --git a/sound/soc/ti/omap-dmic.c b/sound/soc/ti/omap-dmic.c
index 01abf1be5d78..a26588e9c3bc 100644
--- a/sound/soc/ti/omap-dmic.c
+++ b/sound/soc/ti/omap-dmic.c
@@ -203,10 +203,10 @@ static int omap_dmic_dai_hw_params(struct snd_pcm_substream *substream,
 	switch (channels) {
 	case 6:
 		dmic->ch_enabled |= OMAP_DMIC_UP3_ENABLE;
-		/* fall through */
+		fallthrough;
 	case 4:
 		dmic->ch_enabled |= OMAP_DMIC_UP2_ENABLE;
-		/* fall through */
+		fallthrough;
 	case 2:
 		dmic->ch_enabled |= OMAP_DMIC_UP1_ENABLE;
 		break;
diff --git a/sound/soc/ti/omap-mcpdm.c b/sound/soc/ti/omap-mcpdm.c
index d482b62f314a..fafb2998ad0d 100644
--- a/sound/soc/ti/omap-mcpdm.c
+++ b/sound/soc/ti/omap-mcpdm.c
@@ -309,19 +309,19 @@ static int omap_mcpdm_dai_hw_params(struct snd_pcm_substream *substream,
 			/* up to 3 channels for capture */
 			return -EINVAL;
 		link_mask |= 1 << 4;
-		/* fall through */
+		fallthrough;
 	case 4:
 		if (stream == SNDRV_PCM_STREAM_CAPTURE)
 			/* up to 3 channels for capture */
 			return -EINVAL;
 		link_mask |= 1 << 3;
-		/* fall through */
+		fallthrough;
 	case 3:
 		link_mask |= 1 << 2;
-		/* fall through */
+		fallthrough;
 	case 2:
 		link_mask |= 1 << 1;
-		/* fall through */
+		fallthrough;
 	case 1:
 		link_mask |= 1 << 0;
 		break;
diff --git a/sound/soc/ti/rx51.c b/sound/soc/ti/rx51.c
index 2a714a004163..bc7db1cba669 100644
--- a/sound/soc/ti/rx51.c
+++ b/sound/soc/ti/rx51.c
@@ -55,7 +55,7 @@ static void rx51_ext_control(struct snd_soc_dapm_context *dapm)
 		break;
 	case RX51_JACK_HS:
 		hs = 1;
-		/* fall through */
+		fallthrough;
 	case RX51_JACK_HP:
 		hp = 1;
 		break;
diff --git a/sound/soc/zte/zx-i2s.c b/sound/soc/zte/zx-i2s.c
index 568cde64ff8b..1c1a44e08a67 100644
--- a/sound/soc/zte/zx-i2s.c
+++ b/sound/soc/zte/zx-i2s.c
@@ -294,7 +294,7 @@ static int zx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			zx_i2s_rx_dma_en(zx_i2s->reg_base, true);
 		else
 			zx_i2s_tx_dma_en(zx_i2s->reg_base, true);
-	/* fall thru */
+		fallthrough;
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		if (capture)
@@ -308,7 +308,7 @@ static int zx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			zx_i2s_rx_dma_en(zx_i2s->reg_base, false);
 		else
 			zx_i2s_tx_dma_en(zx_i2s->reg_base, false);
-	/* fall thru */
+		fallthrough;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (capture)
diff --git a/sound/soc/zte/zx-spdif.c b/sound/soc/zte/zx-spdif.c
index a3a07c0730e6..b4168bd532b7 100644
--- a/sound/soc/zte/zx-spdif.c
+++ b/sound/soc/zte/zx-spdif.c
@@ -218,7 +218,7 @@ static int zx_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 		val = readl_relaxed(zx_spdif->reg_base + ZX_FIFOCTRL);
 		val |= ZX_FIFOCTRL_TX_FIFO_RST;
 		writel_relaxed(val, zx_spdif->reg_base + ZX_FIFOCTRL);
-	/* fall thru */
+		fallthrough;
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		zx_spdif_cfg_tx(zx_spdif->reg_base, true);
