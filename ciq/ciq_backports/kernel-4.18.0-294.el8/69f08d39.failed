rcu/tree: Use static initializer for krc.lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sebastian Andrzej Siewior <bigeasy@linutronix.de>
commit 69f08d3999dbef1553a3332b8055282dd3893b6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/69f08d39.failed

The per-CPU variable is initialized at runtime in
kfree_rcu_batch_init(). This function is invoked before
'rcu_scheduler_active' is set to 'RCU_SCHEDULER_RUNNING'.
After the initialisation, '->initialized' is to true.

The raw_spin_lock is only acquired if '->initialized' is
set to true. The worqueue item is only used if 'rcu_scheduler_active'
set to RCU_SCHEDULER_RUNNING which happens after initialisation.

Use a static initializer for krc.lock and remove the runtime
initialisation of the lock. Since the lock can now be always
acquired, remove the '->initialized' check.

	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
	Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
(cherry picked from commit 69f08d3999dbef1553a3332b8055282dd3893b6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 4aa7b6bbcde6,a42a4693f161..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -2702,7 -3002,8 +2702,12 @@@ struct kfree_rcu_cpu_work 
   * @lock: Synchronize access to this structure
   * @monitor_work: Promote @head to @head_free after KFREE_DRAIN_JIFFIES
   * @monitor_todo: Tracks whether a @monitor_work delayed work is pending
++<<<<<<< HEAD
 + * @initialized: The @lock and @rcu_work fields have been initialized
++=======
+  * @initialized: The @rcu_work fields have been initialized
+  * @count: Number of objects for which GP not started
++>>>>>>> 69f08d3999db (rcu/tree: Use static initializer for krc.lock)
   *
   * This is a per-CPU structure.  The reason that it is not included in
   * the rcu_data structure is to permit this code to be extracted from
@@@ -2716,13 -3019,46 +2721,48 @@@ struct kfree_rcu_cpu 
  	struct delayed_work monitor_work;
  	bool monitor_todo;
  	bool initialized;
 -	int count;
  };
  
- static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc);
+ static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {
+ 	.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),
+ };
+ 
++<<<<<<< HEAD
++=======
+ static __always_inline void
+ debug_rcu_bhead_unqueue(struct kfree_rcu_bulk_data *bhead)
+ {
+ #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD
+ 	int i;
+ 
+ 	for (i = 0; i < bhead->nr_records; i++)
+ 		debug_rcu_head_unqueue((struct rcu_head *)(bhead->records[i]));
+ #endif
+ }
+ 
+ static inline struct kfree_rcu_cpu *
+ krc_this_cpu_lock(unsigned long *flags)
+ {
+ 	struct kfree_rcu_cpu *krcp;
+ 
+ 	local_irq_save(*flags);	// For safely calling this_cpu_ptr().
+ 	krcp = this_cpu_ptr(&krc);
+ 	raw_spin_lock(&krcp->lock);
+ 
+ 	return krcp;
+ }
+ 
+ static inline void
+ krc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)
+ {
+ 	raw_spin_unlock(&krcp->lock);
+ 	local_irq_restore(flags);
+ }
  
++>>>>>>> 69f08d3999db (rcu/tree: Use static initializer for krc.lock)
  /*
   * This function is invoked in workqueue context after a grace period.
 - * It frees all the objects queued on ->bhead_free or ->head_free.
 + * It frees all the objects queued on ->head_free.
   */
  static void kfree_rcu_work(struct work_struct *work)
  {
@@@ -3773,9 -4278,11 +3813,14 @@@ static void __init kfree_rcu_batch_init
  	for_each_possible_cpu(cpu) {
  		struct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);
  
++<<<<<<< HEAD
 +		spin_lock_init(&krcp->lock);
 +		for (i = 0; i < KFREE_N_BATCHES; i++)
++=======
+ 		for (i = 0; i < KFREE_N_BATCHES; i++) {
+ 			INIT_RCU_WORK(&krcp->krw_arr[i].rcu_work, kfree_rcu_work);
++>>>>>>> 69f08d3999db (rcu/tree: Use static initializer for krc.lock)
  			krcp->krw_arr[i].krcp = krcp;
 -		}
 -
  		INIT_DELAYED_WORK(&krcp->monitor_work, kfree_rcu_monitor);
  		krcp->initialized = true;
  	}
* Unmerged path kernel/rcu/tree.c
