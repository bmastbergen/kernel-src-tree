do_move_mount(): fix an unsafe use of is_anon_ns()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 05883eee857eab4693e7d13ebab06716475c5754
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/05883eee.failed

What triggers it is a race between mount --move and umount -l
of the source; we should reject it (the source is parentless *and*
not the root of anon namespace at that), but the check for namespace
being an anon one is broken in that case - is_anon_ns() needs
ns to be non-NULL.  Better fixed here than in is_anon_ns(), since
the rest of the callers is guaranteed to get a non-NULL argument...

	Reported-by: syzbot+494c7ddf66acac0ad747@syzkaller.appspotmail.com
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 05883eee857eab4693e7d13ebab06716475c5754)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 59ab93b3ffc7,ffb13f0562b0..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -2359,37 -2579,38 +2359,50 @@@ static int do_move_mount(struct path *p
  	struct mount *old;
  	struct mountpoint *mp;
  	int err;
 -	bool attached;
 +	if (!old_name || !*old_name)
 +		return -EINVAL;
 +	err = kern_path(old_name, LOOKUP_FOLLOW, &old_path);
 +	if (err)
 +		return err;
  
 -	mp = lock_mount(new_path);
 +	mp = lock_mount(path);
 +	err = PTR_ERR(mp);
  	if (IS_ERR(mp))
 -		return PTR_ERR(mp);
 +		goto out;
  
 -	old = real_mount(old_path->mnt);
 -	p = real_mount(new_path->mnt);
 -	attached = mnt_has_parent(old);
 -	ns = old->mnt_ns;
 +	old = real_mount(old_path.mnt);
 +	p = real_mount(path->mnt);
  
  	err = -EINVAL;
++<<<<<<< HEAD
 +	if (!check_mnt(p) || !check_mnt(old))
 +		goto out1;
++=======
+ 	/* The mountpoint must be in our namespace. */
+ 	if (!check_mnt(p))
+ 		goto out;
+ 
+ 	/* The thing moved should be either ours or completely unattached. */
+ 	if (attached && !check_mnt(old))
+ 		goto out;
+ 
+ 	if (!attached && !(ns && is_anon_ns(ns)))
+ 		goto out;
++>>>>>>> 05883eee857e (do_move_mount(): fix an unsafe use of is_anon_ns())
  
  	if (old->mnt.mnt_flags & MNT_LOCKED)
 -		goto out;
 +		goto out1;
  
 -	if (old_path->dentry != old_path->mnt->mnt_root)
 -		goto out;
 +	err = -EINVAL;
 +	if (old_path.dentry != old_path.mnt->mnt_root)
 +		goto out1;
  
 -	if (d_is_dir(new_path->dentry) !=
 -	    d_is_dir(old_path->dentry))
 -		goto out;
 +	if (!mnt_has_parent(old))
 +		goto out1;
 +
 +	if (d_is_dir(path->dentry) !=
 +	      d_is_dir(old_path.dentry))
 +		goto out1;
  	/*
  	 * Don't move a mount residing in a shared parent.
  	 */
* Unmerged path fs/namespace.c
