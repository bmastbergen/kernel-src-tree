powerpc: Use a function for reading instructions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jordan Niethe <jniethe5@gmail.com>
commit f8faaffaa7d99028e457ef2d1dcb43a98f736938
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f8faaffa.failed

Prefixed instructions will mean there are instructions of different
length. As a result dereferencing a pointer to an instruction will not
necessarily give the desired result. Introduce a function for reading
instructions from memory into the instruction data type.

	Signed-off-by: Jordan Niethe <jniethe5@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
	Reviewed-by: Alistair Popple <alistair@popple.id.au>
Link: https://lore.kernel.org/r/20200506034050.24806-13-jniethe5@gmail.com
(cherry picked from commit f8faaffaa7d99028e457ef2d1dcb43a98f736938)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/inst.h
#	arch/powerpc/kernel/kprobes.c
#	arch/powerpc/kernel/mce_power.c
#	arch/powerpc/kernel/optprobes.c
#	arch/powerpc/kernel/trace/ftrace.c
#	arch/powerpc/lib/code-patching.c
#	arch/powerpc/xmon/xmon.c
diff --cc arch/powerpc/kernel/kprobes.c
index e4c5bf33970b,f64312dca84f..000000000000
--- a/arch/powerpc/kernel/kprobes.c
+++ b/arch/powerpc/kernel/kprobes.c
@@@ -118,7 -106,7 +118,11 @@@ kprobe_opcode_t *kprobe_lookup_name(con
  int arch_prepare_kprobe(struct kprobe *p)
  {
  	int ret = 0;
++<<<<<<< HEAD
 +	kprobe_opcode_t insn = *p->addr;
++=======
+ 	struct ppc_inst insn = ppc_inst_read((struct ppc_inst *)p->addr);
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  
  	if ((unsigned long)p->addr & 0x03) {
  		printk("Attempt to register kprobe at an unaligned address\n");
@@@ -229,7 -217,7 +233,11 @@@ NOKPROBE_SYMBOL(arch_prepare_kretprobe)
  static int try_to_emulate(struct kprobe *p, struct pt_regs *regs)
  {
  	int ret;
++<<<<<<< HEAD
 +	unsigned int insn = *p->ainsn.insn;
++=======
+ 	struct ppc_inst insn = ppc_inst_read((struct ppc_inst *)p->ainsn.insn);
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  
  	/* regs->nip is also adjusted if emulate_step returns 1 */
  	ret = emulate_step(regs, insn);
diff --cc arch/powerpc/kernel/mce_power.c
index 18d2eb779254,c32af49a5138..000000000000
--- a/arch/powerpc/kernel/mce_power.c
+++ b/arch/powerpc/kernel/mce_power.c
@@@ -365,7 -378,7 +365,11 @@@ static int mce_find_instr_ea_and_phys(s
  	pfn = addr_to_pfn(regs, regs->nip);
  	if (pfn != ULONG_MAX) {
  		instr_addr = (pfn << PAGE_SHIFT) + (regs->nip & ~PAGE_MASK);
++<<<<<<< HEAD
 +		instr = *(unsigned int *)(instr_addr);
++=======
+ 		instr = ppc_inst_read((struct ppc_inst *)instr_addr);
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  		if (!analyse_instr(&op, &tmp, instr)) {
  			pfn = addr_to_pfn(regs, op.ea);
  			*addr = op.ea;
diff --cc arch/powerpc/kernel/optprobes.c
index 8237884ca389,52c1ab3f85aa..000000000000
--- a/arch/powerpc/kernel/optprobes.c
+++ b/arch/powerpc/kernel/optprobes.c
@@@ -103,8 -100,9 +103,14 @@@ static unsigned long can_optimize(struc
  	 * Ensure that the instruction is not a conditional branch,
  	 * and that can be emulated.
  	 */
++<<<<<<< HEAD
 +	if (!is_conditional_branch(*p->ainsn.insn) &&
 +			analyse_instr(&op, &regs, *p->ainsn.insn) == 1) {
++=======
+ 	if (!is_conditional_branch(ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) &&
+ 	    analyse_instr(&op, &regs,
+ 			  ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) == 1) {
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  		emulate_update_regs(&regs, &op);
  		nip = regs.nip;
  	}
diff --cc arch/powerpc/kernel/trace/ftrace.c
index 4bf051d3e21e,acd5b889815f..000000000000
--- a/arch/powerpc/kernel/trace/ftrace.c
+++ b/arch/powerpc/kernel/trace/ftrace.c
@@@ -834,10 -845,10 +834,14 @@@ int ftrace_modify_call(struct dyn_ftrac
  int ftrace_update_ftrace_func(ftrace_func_t func)
  {
  	unsigned long ip = (unsigned long)(&ftrace_call);
 -	struct ppc_inst old, new;
 +	unsigned int old, new;
  	int ret;
  
++<<<<<<< HEAD
 +	old = *(unsigned int *)&ftrace_call;
++=======
+ 	old = ppc_inst_read((struct ppc_inst *)&ftrace_call);
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  	new = ftrace_call_replace(ip, (unsigned long)func, 1);
  	ret = ftrace_modify_code(ip, old, new);
  
@@@ -845,7 -856,7 +849,11 @@@
  	/* Also update the regs callback function */
  	if (!ret) {
  		ip = (unsigned long)(&ftrace_regs_call);
++<<<<<<< HEAD
 +		old = *(unsigned int *)&ftrace_regs_call;
++=======
+ 		old = ppc_inst_read((struct ppc_inst *)&ftrace_regs_call);
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  		new = ftrace_call_replace(ip, (unsigned long)func, 1);
  		ret = ftrace_modify_code(ip, old, new);
  	}
diff --cc arch/powerpc/lib/code-patching.c
index 42fdadac6587,435fc8e9f45d..000000000000
--- a/arch/powerpc/lib/code-patching.c
+++ b/arch/powerpc/lib/code-patching.c
@@@ -348,36 -346,39 +348,45 @@@ static unsigned long branch_bform_targe
  	return (unsigned long)imm;
  }
  
 -unsigned long branch_target(const struct ppc_inst *instr)
 +unsigned long branch_target(const unsigned int *instr)
  {
- 	if (instr_is_branch_iform(*instr))
+ 	if (instr_is_branch_iform(ppc_inst_read(instr)))
  		return branch_iform_target(instr);
- 	else if (instr_is_branch_bform(*instr))
+ 	else if (instr_is_branch_bform(ppc_inst_read(instr)))
  		return branch_bform_target(instr);
  
  	return 0;
  }
  
 -int instr_is_branch_to_addr(const struct ppc_inst *instr, unsigned long addr)
 +int instr_is_branch_to_addr(const unsigned int *instr, unsigned long addr)
  {
- 	if (instr_is_branch_iform(*instr) || instr_is_branch_bform(*instr))
+ 	if (instr_is_branch_iform(ppc_inst_read(instr)) ||
+ 	    instr_is_branch_bform(ppc_inst_read(instr)))
  		return branch_target(instr) == addr;
  
  	return 0;
  }
  
 -int translate_branch(struct ppc_inst *instr, const struct ppc_inst *dest,
 -		     const struct ppc_inst *src)
 +unsigned int translate_branch(const unsigned int *dest, const unsigned int *src)
  {
  	unsigned long target;
- 
  	target = branch_target(src);
  
++<<<<<<< HEAD
 +	if (instr_is_branch_iform(*src))
 +		return create_branch(dest, target, *src);
 +	else if (instr_is_branch_bform(*src))
 +		return create_cond_branch(dest, target, *src);
++=======
+ 	if (instr_is_branch_iform(ppc_inst_read(src)))
+ 		return create_branch(instr, dest, target,
+ 				     ppc_inst_val(ppc_inst_read(src)));
+ 	else if (instr_is_branch_bform(ppc_inst_read(src)))
+ 		return create_cond_branch(instr, dest, target,
+ 					  ppc_inst_val(ppc_inst_read(src)));
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  
 -	return 1;
 +	return 0;
  }
  
  #ifdef CONFIG_PPC_BOOK3E_64
@@@ -588,20 -596,22 +597,28 @@@ static void __init test_translate_branc
  	addr = (unsigned long)p;
  	patch_branch(p, addr, 0);
  	q = buf + 0x2000000;
 -	translate_branch(&instr, q, p);
 -	patch_instruction(q, instr);
 +	patch_instruction(q, translate_branch(q, p));
  	check(instr_is_branch_to_addr(p, addr));
  	check(instr_is_branch_to_addr(q, addr));
++<<<<<<< HEAD
 +	check(*q == 0x4a000000);
++=======
+ 	check(ppc_inst_equal(ppc_inst_read(q), ppc_inst(0x4a000000)));
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  
  	/* Maximum positive case, move x to x - 32 MB + 4 */
  	p = buf + 0x2000000;
  	addr = (unsigned long)p;
  	patch_branch(p, addr, 0);
  	q = buf + 4;
 -	translate_branch(&instr, q, p);
 -	patch_instruction(q, instr);
 +	patch_instruction(q, translate_branch(q, p));
  	check(instr_is_branch_to_addr(p, addr));
  	check(instr_is_branch_to_addr(q, addr));
++<<<<<<< HEAD
 +	check(*q == 0x49fffffc);
++=======
+ 	check(ppc_inst_equal(ppc_inst_read(q), ppc_inst(0x49fffffc)));
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  
  	/* Jump to x + 16 MB moved to x + 20 MB */
  	p = buf;
@@@ -636,22 -650,26 +653,30 @@@
  	/* Maximum negative case, move b . to addr + 32 KB */
  	p = buf;
  	addr = (unsigned long)p;
 -	create_cond_branch(&instr, p, addr, 0xFFFFFFFC);
 -	patch_instruction(p, instr);
 +	patch_instruction(p, create_cond_branch(p, addr, 0xFFFFFFFC));
  	q = buf + 0x8000;
 -	translate_branch(&instr, q, p);
 -	patch_instruction(q, instr);
 +	patch_instruction(q, translate_branch(q, p));
  	check(instr_is_branch_to_addr(p, addr));
  	check(instr_is_branch_to_addr(q, addr));
++<<<<<<< HEAD
 +	check(*q == 0x43ff8000);
++=======
+ 	check(ppc_inst_equal(ppc_inst_read(q), ppc_inst(0x43ff8000)));
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  
  	/* Maximum positive case, move x to x - 32 KB + 4 */
  	p = buf + 0x8000;
  	addr = (unsigned long)p;
 -	create_cond_branch(&instr, p, addr, 0xFFFFFFFC);
 -	patch_instruction(p, instr);
 +	patch_instruction(p, create_cond_branch(p, addr, 0xFFFFFFFC));
  	q = buf + 4;
 -	translate_branch(&instr, q, p);
 -	patch_instruction(q, instr);
 +	patch_instruction(q, translate_branch(q, p));
  	check(instr_is_branch_to_addr(p, addr));
  	check(instr_is_branch_to_addr(q, addr));
++<<<<<<< HEAD
 +	check(*q == 0x43ff7ffc);
++=======
+ 	check(ppc_inst_equal(ppc_inst_read(q), ppc_inst(0x43ff7ffc)));
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  
  	/* Jump to x + 12 KB moved to x + 20 KB */
  	p = buf;
diff --cc arch/powerpc/xmon/xmon.c
index 3ba3f8df7d8d,a4f8f570dbbe..000000000000
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@@ -891,9 -947,9 +891,13 @@@ static void remove_bpts(void
  		if ((bp->enabled & (BP_TRAP|BP_CIABR)) != BP_TRAP)
  			continue;
  		if (mread(bp->address, &instr, 4) == 4
 -		    && ppc_inst_equal(instr, ppc_inst(bpinstr))
 +		    && instr == bpinstr
  		    && patch_instruction(
++<<<<<<< HEAD
 +			(unsigned int *)bp->address, bp->instr[0]) != 0)
++=======
+ 			(struct ppc_inst *)bp->address, ppc_inst_read(bp->instr)) != 0)
++>>>>>>> f8faaffaa7d9 (powerpc: Use a function for reading instructions)
  			printf("Couldn't remove breakpoint at %lx\n",
  			       bp->address);
  	}
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/kernel/kprobes.c
* Unmerged path arch/powerpc/kernel/mce_power.c
* Unmerged path arch/powerpc/kernel/optprobes.c
* Unmerged path arch/powerpc/kernel/trace/ftrace.c
diff --git a/arch/powerpc/kernel/uprobes.c b/arch/powerpc/kernel/uprobes.c
index 5d105b8eeece..e2df05e625b2 100644
--- a/arch/powerpc/kernel/uprobes.c
+++ b/arch/powerpc/kernel/uprobes.c
@@ -186,7 +186,7 @@ bool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)
 	 * emulate_step() returns 1 if the insn was successfully emulated.
 	 * For all other cases, we need to single-step in hardware.
 	 */
-	ret = emulate_step(regs, auprobe->insn);
+	ret = emulate_step(regs, ppc_inst_read(&auprobe->insn));
 	if (ret > 0)
 		return true;
 
* Unmerged path arch/powerpc/lib/code-patching.c
diff --git a/arch/powerpc/lib/feature-fixups.c b/arch/powerpc/lib/feature-fixups.c
index e613b02bb2f0..48eb23299a3f 100644
--- a/arch/powerpc/lib/feature-fixups.c
+++ b/arch/powerpc/lib/feature-fixups.c
@@ -50,7 +50,7 @@ static int patch_alt_instruction(unsigned int *src, unsigned int *dest,
 {
 	unsigned int instr;
 
-	instr = *src;
+	instr = ppc_inst_read(src);
 
 	if (instr_is_relative_branch(*src)) {
 		unsigned int *target = (unsigned int *)branch_target(src);
@@ -380,7 +380,7 @@ static void do_final_fixups(void)
 	length = (__end_interrupts - _stext) / sizeof(int);
 
 	while (length--) {
-		raw_patch_instruction(dest, *src);
+		raw_patch_instruction(dest, ppc_inst_read(src));
 		src++;
 		dest++;
 	}
* Unmerged path arch/powerpc/xmon/xmon.c
