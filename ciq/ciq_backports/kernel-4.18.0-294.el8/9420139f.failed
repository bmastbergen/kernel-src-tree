dma-pool: fix coherent pool allocations for IOMMU mappings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 9420139f516d7fbc248ce17f35275cb005ed98ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9420139f.failed

When allocating coherent pool memory for an IOMMU mapping we don't care
about the DMA mask.  Move the guess for the initial GFP mask into the
dma_direct_alloc_pages and pass dma_coherent_ok as a function pointer
argument so that it doesn't get applied to the IOMMU case.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Amit Pundir <amit.pundir@linaro.org>
(cherry picked from commit 9420139f516d7fbc248ce17f35275cb005ed98ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/dma-iommu.c
#	include/linux/dma-mapping.h
#	kernel/dma/direct.c
#	kernel/dma/pool.c
diff --cc drivers/iommu/dma-iommu.c
index b4d011969bbf,5141d49a046b..000000000000
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@@ -1046,7 -1035,8 +1046,12 @@@ static void *iommu_dma_alloc(struct dev
  
  	if (IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
  	    !gfpflags_allow_blocking(gfp) && !coherent)
++<<<<<<< HEAD
 +		cpu_addr = dma_alloc_from_pool(PAGE_ALIGN(size), &page, gfp);
++=======
+ 		page = dma_alloc_from_pool(dev, PAGE_ALIGN(size), &cpu_addr,
+ 					       gfp, NULL);
++>>>>>>> 9420139f516d (dma-pool: fix coherent pool allocations for IOMMU mappings)
  	else
  		cpu_addr = iommu_dma_alloc_pages(dev, size, &page, gfp, attrs);
  	if (!cpu_addr)
diff --cc include/linux/dma-mapping.h
index 5c6819a4edf4,52635e91143b..000000000000
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@@ -525,9 -522,10 +525,16 @@@ void *dma_common_pages_remap(struct pag
  			pgprot_t prot, const void *caller);
  void dma_common_free_remap(void *cpu_addr, size_t size);
  
++<<<<<<< HEAD
 +bool dma_in_atomic_pool(void *start, size_t size);
 +void *dma_alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags);
 +bool dma_free_from_pool(void *start, size_t size);
++=======
+ struct page *dma_alloc_from_pool(struct device *dev, size_t size,
+ 		void **cpu_addr, gfp_t flags,
+ 		bool (*phys_addr_ok)(struct device *, phys_addr_t, size_t));
+ bool dma_free_from_pool(struct device *dev, void *start, size_t size);
++>>>>>>> 9420139f516d (dma-pool: fix coherent pool allocations for IOMMU mappings)
  
  int
  dma_common_get_sgtable(struct device *dev, struct sg_table *sgt, void *cpu_addr,
diff --cc kernel/dma/direct.c
index acedd0ed78fc,db6ef07aec3b..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -43,8 -43,8 +43,13 @@@ u64 dma_direct_get_required_mask(struc
  	return (1ULL << (fls64(max_dma) - 1)) * 2 - 1;
  }
  
++<<<<<<< HEAD
 +static gfp_t __dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,
 +		u64 *phys_limit)
++=======
+ static gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,
+ 				  u64 *phys_limit)
++>>>>>>> 9420139f516d (dma-pool: fix coherent pool allocations for IOMMU mappings)
  {
  	u64 dma_limit = min_not_zero(dma_mask, dev->bus_dma_limit);
  
@@@ -122,12 -156,18 +127,25 @@@ void *dma_direct_alloc_pages(struct dev
  {
  	struct page *page;
  	void *ret;
 -	int err;
  
++<<<<<<< HEAD
 +	if (IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
 +	    dma_alloc_need_uncached(dev, attrs) &&
 +	    !gfpflags_allow_blocking(gfp)) {
 +		ret = dma_alloc_from_pool(PAGE_ALIGN(size), &page, gfp);
 +		if (!ret)
++=======
+ 	size = PAGE_ALIGN(size);
+ 
+ 	if (dma_should_alloc_from_pool(dev, gfp, attrs)) {
+ 		u64 phys_mask;
+ 
+ 		gfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,
+ 				&phys_mask);
+ 		page = dma_alloc_from_pool(dev, size, &ret, gfp,
+ 				dma_coherent_ok);
+ 		if (!page)
++>>>>>>> 9420139f516d (dma-pool: fix coherent pool allocations for IOMMU mappings)
  			return NULL;
  		goto done;
  	}
* Unmerged path kernel/dma/pool.c
* Unmerged path drivers/iommu/dma-iommu.c
* Unmerged path include/linux/dma-mapping.h
* Unmerged path kernel/dma/direct.c
* Unmerged path kernel/dma/pool.c
