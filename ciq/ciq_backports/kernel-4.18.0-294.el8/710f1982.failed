KVM: arm64: Move SPSR_EL1 to the system register array

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Marc Zyngier <maz@kernel.org>
commit 710f1982187afd3f25413d92a0804ccd780634f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/710f1982.failed

SPSR_EL1 being a VNCR-capable register with ARMv8.4-NV, move it to
the sysregs array and update the accessors.

	Reviewed-by: James Morse <james.morse@arm.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
(cherry picked from commit 710f1982187afd3f25413d92a0804ccd780634f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kvm_emulate.h
#	arch/arm64/include/asm/kvm_host.h
#	arch/arm64/kvm/guest.c
#	arch/arm64/kvm/hyp/include/hyp/sysreg-sr.h
#	arch/arm64/kvm/regmap.c
diff --cc arch/arm64/include/asm/kvm_emulate.h
index f395ff663f8a,57f9042e7270..000000000000
--- a/arch/arm64/include/asm/kvm_emulate.h
+++ b/arch/arm64/include/asm/kvm_emulate.h
@@@ -208,7 -176,7 +208,11 @@@ static inline unsigned long vcpu_read_s
  	if (vcpu->arch.sysregs_loaded_on_cpu)
  		return read_sysreg_el1(SYS_SPSR);
  	else
++<<<<<<< HEAD
 +		return vcpu_gp_regs(vcpu)->spsr[KVM_SPSR_EL1];
++=======
+ 		return __vcpu_sys_reg(vcpu, SPSR_EL1);
++>>>>>>> 710f1982187a (KVM: arm64: Move SPSR_EL1 to the system register array)
  }
  
  static inline void vcpu_write_spsr(struct kvm_vcpu *vcpu, unsigned long v)
@@@ -221,7 -189,7 +225,11 @@@
  	if (vcpu->arch.sysregs_loaded_on_cpu)
  		write_sysreg_el1(v, SYS_SPSR);
  	else
++<<<<<<< HEAD
 +		vcpu_gp_regs(vcpu)->spsr[KVM_SPSR_EL1] = v;
++=======
+ 		__vcpu_sys_reg(vcpu, SPSR_EL1) = v;
++>>>>>>> 710f1982187a (KVM: arm64: Move SPSR_EL1 to the system register array)
  }
  
  /*
diff --cc arch/arm64/include/asm/kvm_host.h
index d8c4d368d7b0,91b1adb6789c..000000000000
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@@ -181,6 -185,10 +181,13 @@@ enum vcpu_sysreg 
  	APGAKEYLO_EL1,
  	APGAKEYHI_EL1,
  
++<<<<<<< HEAD
++=======
+ 	ELR_EL1,
+ 	SP_EL1,
+ 	SPSR_EL1,
+ 
++>>>>>>> 710f1982187a (KVM: arm64: Move SPSR_EL1 to the system register array)
  	/* 32bit specific registers. Keep them at the end of the range */
  	DACR32_EL2,	/* Domain Access Control Register */
  	IFSR32_EL2,	/* Instruction Fault Status Register */
@@@ -232,7 -240,15 +239,19 @@@
  #define NR_COPRO_REGS	(NR_SYS_REGS * 2)
  
  struct kvm_cpu_context {
++<<<<<<< HEAD
 +	struct kvm_regs	gp_regs;
++=======
+ 	struct user_pt_regs regs;	/* sp = sp_el0 */
+ 
+ 	u64	spsr_abt;
+ 	u64	spsr_und;
+ 	u64	spsr_irq;
+ 	u64	spsr_fiq;
+ 
+ 	struct user_fpsimd_state fp_regs;
+ 
++>>>>>>> 710f1982187a (KVM: arm64: Move SPSR_EL1 to the system register array)
  	union {
  		u64 sys_regs[NR_SYS_REGS];
  		u32 copro[NR_COPRO_REGS];
diff --cc arch/arm64/kvm/guest.c
index a0778b6214ad,dfb5218137ca..000000000000
--- a/arch/arm64/kvm/guest.c
+++ b/arch/arm64/kvm/guest.c
@@@ -117,12 -107,63 +117,67 @@@ static int validate_core_offset(const s
  	int size = core_reg_size_from_offset(vcpu, off);
  
  	if (size < 0)
 -		return NULL;
 +		return -EINVAL;
  
  	if (KVM_REG_SIZE(reg->id) != size)
 -		return NULL;
 +		return -EINVAL;
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	switch (off) {
+ 	case KVM_REG_ARM_CORE_REG(regs.regs[0]) ...
+ 	     KVM_REG_ARM_CORE_REG(regs.regs[30]):
+ 		off -= KVM_REG_ARM_CORE_REG(regs.regs[0]);
+ 		off /= 2;
+ 		return &vcpu->arch.ctxt.regs.regs[off];
+ 
+ 	case KVM_REG_ARM_CORE_REG(regs.sp):
+ 		return &vcpu->arch.ctxt.regs.sp;
+ 
+ 	case KVM_REG_ARM_CORE_REG(regs.pc):
+ 		return &vcpu->arch.ctxt.regs.pc;
+ 
+ 	case KVM_REG_ARM_CORE_REG(regs.pstate):
+ 		return &vcpu->arch.ctxt.regs.pstate;
+ 
+ 	case KVM_REG_ARM_CORE_REG(sp_el1):
+ 		return __ctxt_sys_reg(&vcpu->arch.ctxt, SP_EL1);
+ 
+ 	case KVM_REG_ARM_CORE_REG(elr_el1):
+ 		return __ctxt_sys_reg(&vcpu->arch.ctxt, ELR_EL1);
+ 
+ 	case KVM_REG_ARM_CORE_REG(spsr[KVM_SPSR_EL1]):
+ 		return __ctxt_sys_reg(&vcpu->arch.ctxt, SPSR_EL1);
+ 
+ 	case KVM_REG_ARM_CORE_REG(spsr[KVM_SPSR_ABT]):
+ 		return &vcpu->arch.ctxt.spsr_abt;
+ 
+ 	case KVM_REG_ARM_CORE_REG(spsr[KVM_SPSR_UND]):
+ 		return &vcpu->arch.ctxt.spsr_und;
+ 
+ 	case KVM_REG_ARM_CORE_REG(spsr[KVM_SPSR_IRQ]):
+ 		return &vcpu->arch.ctxt.spsr_irq;
+ 
+ 	case KVM_REG_ARM_CORE_REG(spsr[KVM_SPSR_FIQ]):
+ 		return &vcpu->arch.ctxt.spsr_fiq;
+ 
+ 	case KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]) ...
+ 	     KVM_REG_ARM_CORE_REG(fp_regs.vregs[31]):
+ 		off -= KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]);
+ 		off /= 4;
+ 		return &vcpu->arch.ctxt.fp_regs.vregs[off];
+ 
+ 	case KVM_REG_ARM_CORE_REG(fp_regs.fpsr):
+ 		return &vcpu->arch.ctxt.fp_regs.fpsr;
+ 
+ 	case KVM_REG_ARM_CORE_REG(fp_regs.fpcr):
+ 		return &vcpu->arch.ctxt.fp_regs.fpcr;
+ 
+ 	default:
+ 		return NULL;
+ 	}
++>>>>>>> 710f1982187a (KVM: arm64: Move SPSR_EL1 to the system register array)
  }
  
  static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
diff --cc arch/arm64/kvm/regmap.c
index 06fdf054b3d3,accc1d5fba61..000000000000
--- a/arch/arm64/kvm/regmap.c
+++ b/arch/arm64/kvm/regmap.c
@@@ -158,8 -147,20 +158,25 @@@ unsigned long vcpu_read_spsr32(const st
  {
  	int spsr_idx = vcpu_spsr32_mode(vcpu);
  
++<<<<<<< HEAD
 +	if (!vcpu->arch.sysregs_loaded_on_cpu)
 +		return vcpu_gp_regs(vcpu)->spsr[spsr_idx];
++=======
+ 	if (!vcpu->arch.sysregs_loaded_on_cpu) {
+ 		switch (spsr_idx) {
+ 		case KVM_SPSR_SVC:
+ 			return __vcpu_sys_reg(vcpu, SPSR_EL1);
+ 		case KVM_SPSR_ABT:
+ 			return vcpu->arch.ctxt.spsr_abt;
+ 		case KVM_SPSR_UND:
+ 			return vcpu->arch.ctxt.spsr_und;
+ 		case KVM_SPSR_IRQ:
+ 			return vcpu->arch.ctxt.spsr_irq;
+ 		case KVM_SPSR_FIQ:
+ 			return vcpu->arch.ctxt.spsr_fiq;
+ 		}
+ 	}
++>>>>>>> 710f1982187a (KVM: arm64: Move SPSR_EL1 to the system register array)
  
  	switch (spsr_idx) {
  	case KVM_SPSR_SVC:
@@@ -182,7 -183,24 +199,28 @@@ void vcpu_write_spsr32(struct kvm_vcpu 
  	int spsr_idx = vcpu_spsr32_mode(vcpu);
  
  	if (!vcpu->arch.sysregs_loaded_on_cpu) {
++<<<<<<< HEAD
 +		vcpu_gp_regs(vcpu)->spsr[spsr_idx] = v;
++=======
+ 		switch (spsr_idx) {
+ 		case KVM_SPSR_SVC:
+ 			__vcpu_sys_reg(vcpu, SPSR_EL1) = v;
+ 			break;
+ 		case KVM_SPSR_ABT:
+ 			vcpu->arch.ctxt.spsr_abt = v;
+ 			break;
+ 		case KVM_SPSR_UND:
+ 			vcpu->arch.ctxt.spsr_und = v;
+ 			break;
+ 		case KVM_SPSR_IRQ:
+ 			vcpu->arch.ctxt.spsr_irq = v;
+ 			break;
+ 		case KVM_SPSR_FIQ:
+ 			vcpu->arch.ctxt.spsr_fiq = v;
+ 			break;
+ 		}
+ 
++>>>>>>> 710f1982187a (KVM: arm64: Move SPSR_EL1 to the system register array)
  		return;
  	}
  
* Unmerged path arch/arm64/kvm/hyp/include/hyp/sysreg-sr.h
* Unmerged path arch/arm64/include/asm/kvm_emulate.h
* Unmerged path arch/arm64/include/asm/kvm_host.h
* Unmerged path arch/arm64/kvm/guest.c
* Unmerged path arch/arm64/kvm/hyp/include/hyp/sysreg-sr.h
* Unmerged path arch/arm64/kvm/regmap.c
