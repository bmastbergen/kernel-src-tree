fs: Remove unneeded IS_DAX() check in io_is_direct()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit efbe3c2493d2f7a1e1a753780fe727b34709ebd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/efbe3c24.failed

Remove the check because DAX now has it's own read/write methods and
file systems which support DAX check IS_DAX() prior to IOCB_DIRECT on
their own.  Therefore, it does not matter if the file state is DAX when
the iocb flags are created.

Also remove io_is_direct() as it is just a simple flag check.

	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit efbe3c2493d2f7a1e1a753780fe727b34709ebd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/loop.c
diff --cc drivers/block/loop.c
index 43870e997adc,14372df0f354..000000000000
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@@ -973,6 -952,132 +973,135 @@@ static void loop_update_rotational(stru
  		blk_queue_flag_clear(QUEUE_FLAG_NONROT, q);
  }
  
++<<<<<<< HEAD
++=======
+ static int loop_set_fd(struct loop_device *lo, fmode_t mode,
+ 		       struct block_device *bdev, unsigned int arg)
+ {
+ 	struct file	*file;
+ 	struct inode	*inode;
+ 	struct address_space *mapping;
+ 	struct block_device *claimed_bdev = NULL;
+ 	int		lo_flags = 0;
+ 	int		error;
+ 	loff_t		size;
+ 	bool		partscan;
+ 
+ 	/* This is safe, since we have a reference from open(). */
+ 	__module_get(THIS_MODULE);
+ 
+ 	error = -EBADF;
+ 	file = fget(arg);
+ 	if (!file)
+ 		goto out;
+ 
+ 	/*
+ 	 * If we don't hold exclusive handle for the device, upgrade to it
+ 	 * here to avoid changing device under exclusive owner.
+ 	 */
+ 	if (!(mode & FMODE_EXCL)) {
+ 		claimed_bdev = bd_start_claiming(bdev, loop_set_fd);
+ 		if (IS_ERR(claimed_bdev)) {
+ 			error = PTR_ERR(claimed_bdev);
+ 			goto out_putf;
+ 		}
+ 	}
+ 
+ 	error = mutex_lock_killable(&loop_ctl_mutex);
+ 	if (error)
+ 		goto out_bdev;
+ 
+ 	error = -EBUSY;
+ 	if (lo->lo_state != Lo_unbound)
+ 		goto out_unlock;
+ 
+ 	error = loop_validate_file(file, bdev);
+ 	if (error)
+ 		goto out_unlock;
+ 
+ 	mapping = file->f_mapping;
+ 	inode = mapping->host;
+ 
+ 	if (!(file->f_mode & FMODE_WRITE) || !(mode & FMODE_WRITE) ||
+ 	    !file->f_op->write_iter)
+ 		lo_flags |= LO_FLAGS_READ_ONLY;
+ 
+ 	error = -EFBIG;
+ 	size = get_loop_size(lo, file);
+ 	if ((loff_t)(sector_t)size != size)
+ 		goto out_unlock;
+ 	error = loop_prepare_queue(lo);
+ 	if (error)
+ 		goto out_unlock;
+ 
+ 	error = 0;
+ 
+ 	set_device_ro(bdev, (lo_flags & LO_FLAGS_READ_ONLY) != 0);
+ 
+ 	lo->use_dio = false;
+ 	lo->lo_device = bdev;
+ 	lo->lo_flags = lo_flags;
+ 	lo->lo_backing_file = file;
+ 	lo->transfer = NULL;
+ 	lo->ioctl = NULL;
+ 	lo->lo_sizelimit = 0;
+ 	lo->old_gfp_mask = mapping_gfp_mask(mapping);
+ 	mapping_set_gfp_mask(mapping, lo->old_gfp_mask & ~(__GFP_IO|__GFP_FS));
+ 
+ 	if (!(lo_flags & LO_FLAGS_READ_ONLY) && file->f_op->fsync)
+ 		blk_queue_write_cache(lo->lo_queue, true, false);
+ 
+ 	if ((lo->lo_backing_file->f_flags & O_DIRECT) && inode->i_sb->s_bdev) {
+ 		/* In case of direct I/O, match underlying block size */
+ 		unsigned short bsize = bdev_logical_block_size(
+ 			inode->i_sb->s_bdev);
+ 
+ 		blk_queue_logical_block_size(lo->lo_queue, bsize);
+ 		blk_queue_physical_block_size(lo->lo_queue, bsize);
+ 		blk_queue_io_min(lo->lo_queue, bsize);
+ 	}
+ 
+ 	loop_update_rotational(lo);
+ 	loop_update_dio(lo);
+ 	set_capacity(lo->lo_disk, size);
+ 	bd_set_size(bdev, size << 9);
+ 	loop_sysfs_init(lo);
+ 	/* let user-space know about the new size */
+ 	kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, KOBJ_CHANGE);
+ 
+ 	set_blocksize(bdev, S_ISBLK(inode->i_mode) ?
+ 		      block_size(inode->i_bdev) : PAGE_SIZE);
+ 
+ 	lo->lo_state = Lo_bound;
+ 	if (part_shift)
+ 		lo->lo_flags |= LO_FLAGS_PARTSCAN;
+ 	partscan = lo->lo_flags & LO_FLAGS_PARTSCAN;
+ 
+ 	/* Grab the block_device to prevent its destruction after we
+ 	 * put /dev/loopXX inode. Later in __loop_clr_fd() we bdput(bdev).
+ 	 */
+ 	bdgrab(bdev);
+ 	mutex_unlock(&loop_ctl_mutex);
+ 	if (partscan)
+ 		loop_reread_partitions(lo, bdev);
+ 	if (claimed_bdev)
+ 		bd_abort_claiming(bdev, claimed_bdev, loop_set_fd);
+ 	return 0;
+ 
+ out_unlock:
+ 	mutex_unlock(&loop_ctl_mutex);
+ out_bdev:
+ 	if (claimed_bdev)
+ 		bd_abort_claiming(bdev, claimed_bdev, loop_set_fd);
+ out_putf:
+ 	fput(file);
+ out:
+ 	/* This is safe: open() is still holding a reference. */
+ 	module_put(THIS_MODULE);
+ 	return error;
+ }
+ 
++>>>>>>> efbe3c2493d2 (fs: Remove unneeded IS_DAX() check in io_is_direct())
  static int
  loop_release_xfer(struct loop_device *lo)
  {
* Unmerged path drivers/block/loop.c
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5bfcacbc48a8..8eba9e43caca 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3328,11 +3328,6 @@ extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
 extern int file_update_time(struct file *file);
 
-static inline bool io_is_direct(struct file *filp)
-{
-	return (filp->f_flags & O_DIRECT) || IS_DAX(filp->f_mapping->host);
-}
-
 static inline bool vma_is_dax(const struct vm_area_struct *vma)
 {
 	return vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);
@@ -3357,7 +3352,7 @@ static inline int iocb_flags(struct file *file)
 	int res = 0;
 	if (file->f_flags & O_APPEND)
 		res |= IOCB_APPEND;
-	if (io_is_direct(file))
+	if (file->f_flags & O_DIRECT)
 		res |= IOCB_DIRECT;
 	if ((file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host))
 		res |= IOCB_DSYNC;
