mptcp: subflows garbage collection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 0e4f35d7880157ceccf0a58377d778b02762af82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0e4f35d7.failed

The msk can close MP_JOIN subflows if the initial handshake
fails. Currently such subflows are kept alive in the
conn_list until the msk itself is closed.

Beyond the wasted memory, we could end-up sending the
DATA_FIN and the DATA_FIN ack on such socket, even after a
reset.

Fixes: 43b54c6ee382 ("mptcp: Use full MPTCP-level disconnect state machine")
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0e4f35d7880157ceccf0a58377d778b02762af82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
#	net/mptcp/subflow.c
diff --cc net/mptcp/protocol.c
index fd713c3a206a,b295eb6e9580..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -1420,6 -1360,43 +1420,46 @@@ static unsigned int mptcp_sync_mss(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void pm_work(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_pm_data *pm = &msk->pm;
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 
+ 	pr_debug("msk=%p status=%x", msk, pm->status);
+ 	if (pm->status & BIT(MPTCP_PM_ADD_ADDR_RECEIVED)) {
+ 		pm->status &= ~BIT(MPTCP_PM_ADD_ADDR_RECEIVED);
+ 		mptcp_pm_nl_add_addr_received(msk);
+ 	}
+ 	if (pm->status & BIT(MPTCP_PM_ESTABLISHED)) {
+ 		pm->status &= ~BIT(MPTCP_PM_ESTABLISHED);
+ 		mptcp_pm_nl_fully_established(msk);
+ 	}
+ 	if (pm->status & BIT(MPTCP_PM_SUBFLOW_ESTABLISHED)) {
+ 		pm->status &= ~BIT(MPTCP_PM_SUBFLOW_ESTABLISHED);
+ 		mptcp_pm_nl_subflow_established(msk);
+ 	}
+ 
+ 	spin_unlock_bh(&msk->pm.lock);
+ }
+ 
+ static void __mptcp_close_subflow(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 
+ 		if (inet_sk_state_load(ssk) != TCP_CLOSE)
+ 			continue;
+ 
+ 		__mptcp_close_ssk((struct sock *)msk, ssk, subflow, 0);
+ 	}
+ }
+ 
++>>>>>>> 0e4f35d78801 (mptcp: subflows garbage collection)
  static void mptcp_worker(struct work_struct *work)
  {
  	struct mptcp_sock *msk = container_of(work, struct mptcp_sock, work);
@@@ -1437,8 -1414,14 +1477,11 @@@
  	mptcp_clean_una(sk);
  	mptcp_check_data_fin_ack(sk);
  	__mptcp_flush_join_list(msk);
+ 	if (test_and_clear_bit(MPTCP_WORK_CLOSE_SUBFLOW, &msk->flags))
+ 		__mptcp_close_subflow(msk);
+ 
  	__mptcp_move_skbs(msk);
  
 -	if (msk->pm.status)
 -		pm_work(msk);
 -
  	if (test_and_clear_bit(MPTCP_WORK_EOF, &msk->flags))
  		mptcp_check_for_eof(msk);
  
diff --cc net/mptcp/subflow.c
index dcdd522ad5a5,559f5bbd9622..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -236,6 -270,19 +236,22 @@@ static bool subflow_thmac_valid(struct 
  	return thmac == subflow->thmac;
  }
  
++<<<<<<< HEAD
++=======
+ void mptcp_subflow_reset(struct sock *ssk)
+ {
+ 	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);
+ 	struct sock *sk = subflow->conn;
+ 
+ 	tcp_set_state(ssk, TCP_CLOSE);
+ 	tcp_send_active_reset(ssk, GFP_ATOMIC);
+ 	tcp_done(ssk);
+ 	if (!test_and_set_bit(MPTCP_WORK_CLOSE_SUBFLOW, &mptcp_sk(sk)->flags) &&
+ 	    schedule_work(&mptcp_sk(sk)->work))
+ 		sock_hold(sk);
+ }
+ 
++>>>>>>> 0e4f35d78801 (mptcp: subflows garbage collection)
  static void subflow_finish_connect(struct sock *sk, const struct sk_buff *skb)
  {
  	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);
* Unmerged path net/mptcp/protocol.c
diff --git a/net/mptcp/protocol.h b/net/mptcp/protocol.h
index 35072e9204c8..17afa0e31a88 100644
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@ -90,6 +90,7 @@
 #define MPTCP_WORK_RTX		2
 #define MPTCP_WORK_EOF		3
 #define MPTCP_FALLBACK_DONE	4
+#define MPTCP_WORK_CLOSE_SUBFLOW 5
 
 struct mptcp_options_received {
 	u64	sndr_key;
* Unmerged path net/mptcp/subflow.c
