scsi: qla2xxx: Fix endianness annotations in source files

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Bart Van Assche <bvanassche@acm.org>
commit 7ffa5b939751b6638e4a99518775c8503fbb46be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7ffa5b93.failed

Fix all endianness complaints reported by sparse (C=2) without affecting
the behavior of the code on little endian CPUs.

Link: https://lore.kernel.org/r/20200518211712.11395-16-bvanassche@acm.org
	Cc: Nilesh Javali <njavali@marvell.com>
	Cc: Quinn Tran <qutran@marvell.com>
	Cc: Martin Wilck <mwilck@suse.com>
	Cc: Daniel Wagner <dwagner@suse.de>
	Cc: Roman Bolshakov <r.bolshakov@yadro.com>
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Daniel Wagner <dwagner@suse.de>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7ffa5b939751b6638e4a99518775c8503fbb46be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_sup.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 4f49726a1556,6196d874d599..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -7448,7 -7448,7 +7450,11 @@@ qla27xx_check_image_status_signature(st
  static ulong
  qla27xx_image_status_checksum(struct qla27xx_image_status *image_status)
  {
++<<<<<<< HEAD
 +	uint32_t *p = (void *)image_status;
++=======
+ 	__le32 *p = (__force __le32 *)image_status;
++>>>>>>> 7ffa5b939751 (scsi: qla2xxx: Fix endianness annotations in source files)
  	uint n = sizeof(*image_status) / sizeof(*p);
  	uint32_t sum = 0;
  
@@@ -7780,9 -7780,9 +7786,9 @@@ qla24xx_load_risc_flash(scsi_qla_host_
  		fwdt->template = NULL;
  		fwdt->length = 0;
  
 -		dcode = (uint32_t *)req->ring;
 +		dcode = (void *)req->ring;
  		qla24xx_read_flash_data(vha, dcode, faddr, 7);
- 		risc_size = be32_to_cpu(dcode[2]);
+ 		risc_size = be32_to_cpu((__force __be32)dcode[2]);
  		ql_dbg(ql_dbg_init, vha, 0x0161,
  		    "-> fwdt%u template array at %#x (%#x dwords)\n",
  		    j, faddr, risc_size);
@@@ -7972,8 -7973,8 +7979,13 @@@ qla24xx_load_risc_blob(scsi_qla_host_t 
  		return QLA_FUNCTION_FAILED;
  	}
  
++<<<<<<< HEAD
 +	fwcode = (void *)blob->fw->data;
 +	dcode = fwcode;
++=======
+ 	fwcode = (__force __be32 *)blob->fw->data;
+ 	dcode = (__force uint32_t *)fwcode;
++>>>>>>> 7ffa5b939751 (scsi: qla2xxx: Fix endianness annotations in source files)
  	if (qla24xx_risc_firmware_invalid(dcode)) {
  		ql_log(ql_log_fatal, vha, 0x0093,
  		    "Unable to verify integrity of firmware image (%zd).\n",
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index bada8ca1cc29,96d64a7034cc..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -31,6 -31,144 +31,147 @@@ const char *const port_state_str[] = 
  	"ONLINE"
  };
  
++<<<<<<< HEAD
++=======
+ static void qla24xx_purex_iocb(scsi_qla_host_t *vha, void *pkt,
+ 	void (*process_item)(struct scsi_qla_host *vha, void *pkt))
+ {
+ 	struct purex_list *list = &vha->purex_list;
+ 	struct purex_item *item;
+ 	ulong flags;
+ 
+ 	item = kzalloc(sizeof(*item), GFP_KERNEL);
+ 	if (!item) {
+ 		ql_log(ql_log_warn, vha, 0x5092,
+ 		    ">> Failed allocate purex list item.\n");
+ 		return;
+ 	}
+ 
+ 	item->vha = vha;
+ 	item->process_item = process_item;
+ 	memcpy(&item->iocb, pkt, sizeof(item->iocb));
+ 
+ 	spin_lock_irqsave(&list->lock, flags);
+ 	list_add_tail(&item->list, &list->head);
+ 	spin_unlock_irqrestore(&list->lock, flags);
+ 
+ 	set_bit(PROCESS_PUREX_IOCB, &vha->dpc_flags);
+ }
+ 
+ static void
+ qla24xx_process_abts(struct scsi_qla_host *vha, void *pkt)
+ {
+ 	struct abts_entry_24xx *abts = pkt;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct els_entry_24xx *rsp_els;
+ 	struct abts_entry_24xx *abts_rsp;
+ 	dma_addr_t dma;
+ 	uint32_t fctl;
+ 	int rval;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0286, "%s: entered.\n", __func__);
+ 
+ 	ql_log(ql_log_warn, vha, 0x0287,
+ 	    "Processing ABTS xchg=%#x oxid=%#x rxid=%#x seqid=%#x seqcnt=%#x\n",
+ 	    abts->rx_xch_addr_to_abort, abts->ox_id, abts->rx_id,
+ 	    abts->seq_id, abts->seq_cnt);
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0287,
+ 	    "-------- ABTS RCV -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0287,
+ 	    (uint8_t *)abts, sizeof(*abts));
+ 
+ 	rsp_els = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_els), &dma,
+ 	    GFP_KERNEL);
+ 	if (!rsp_els) {
+ 		ql_log(ql_log_warn, vha, 0x0287,
+ 		    "Failed allocate dma buffer ABTS/ELS RSP.\n");
+ 		return;
+ 	}
+ 
+ 	/* terminate exchange */
+ 	memset(rsp_els, 0, sizeof(*rsp_els));
+ 	rsp_els->entry_type = ELS_IOCB_TYPE;
+ 	rsp_els->entry_count = 1;
+ 	rsp_els->nport_handle = cpu_to_le16(~0);
+ 	rsp_els->rx_xchg_address = abts->rx_xch_addr_to_abort;
+ 	rsp_els->control_flags = cpu_to_le16(EPD_RX_XCHG);
+ 	ql_dbg(ql_dbg_init, vha, 0x0283,
+ 	    "Sending ELS Response to terminate exchange %#x...\n",
+ 	    abts->rx_xch_addr_to_abort);
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0283,
+ 	    "-------- ELS RSP -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0283,
+ 	    (uint8_t *)rsp_els, sizeof(*rsp_els));
+ 	rval = qla2x00_issue_iocb(vha, rsp_els, dma, 0);
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x0288,
+ 		    "%s: iocb failed to execute -> %x\n", __func__, rval);
+ 	} else if (rsp_els->comp_status) {
+ 		ql_log(ql_log_warn, vha, 0x0289,
+ 		    "%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\n",
+ 		    __func__, rsp_els->comp_status,
+ 		    rsp_els->error_subcode_1, rsp_els->error_subcode_2);
+ 	} else {
+ 		ql_dbg(ql_dbg_init, vha, 0x028a,
+ 		    "%s: abort exchange done.\n", __func__);
+ 	}
+ 
+ 	/* send ABTS response */
+ 	abts_rsp = (void *)rsp_els;
+ 	memset(abts_rsp, 0, sizeof(*abts_rsp));
+ 	abts_rsp->entry_type = ABTS_RSP_TYPE;
+ 	abts_rsp->entry_count = 1;
+ 	abts_rsp->nport_handle = abts->nport_handle;
+ 	abts_rsp->vp_idx = abts->vp_idx;
+ 	abts_rsp->sof_type = abts->sof_type & 0xf0;
+ 	abts_rsp->rx_xch_addr = abts->rx_xch_addr;
+ 	abts_rsp->d_id[0] = abts->s_id[0];
+ 	abts_rsp->d_id[1] = abts->s_id[1];
+ 	abts_rsp->d_id[2] = abts->s_id[2];
+ 	abts_rsp->r_ctl = FC_ROUTING_BLD | FC_R_CTL_BLD_BA_ACC;
+ 	abts_rsp->s_id[0] = abts->d_id[0];
+ 	abts_rsp->s_id[1] = abts->d_id[1];
+ 	abts_rsp->s_id[2] = abts->d_id[2];
+ 	abts_rsp->cs_ctl = abts->cs_ctl;
+ 	/* include flipping bit23 in fctl */
+ 	fctl = ~(abts->f_ctl[2] | 0x7F) << 16 |
+ 	    FC_F_CTL_LAST_SEQ | FC_F_CTL_END_SEQ | FC_F_CTL_SEQ_INIT;
+ 	abts_rsp->f_ctl[0] = fctl >> 0 & 0xff;
+ 	abts_rsp->f_ctl[1] = fctl >> 8 & 0xff;
+ 	abts_rsp->f_ctl[2] = fctl >> 16 & 0xff;
+ 	abts_rsp->type = FC_TYPE_BLD;
+ 	abts_rsp->rx_id = abts->rx_id;
+ 	abts_rsp->ox_id = abts->ox_id;
+ 	abts_rsp->payload.ba_acc.aborted_rx_id = abts->rx_id;
+ 	abts_rsp->payload.ba_acc.aborted_ox_id = abts->ox_id;
+ 	abts_rsp->payload.ba_acc.high_seq_cnt = cpu_to_le16(~0);
+ 	abts_rsp->rx_xch_addr_to_abort = abts->rx_xch_addr_to_abort;
+ 	ql_dbg(ql_dbg_init, vha, 0x028b,
+ 	    "Sending BA ACC response to ABTS %#x...\n",
+ 	    abts->rx_xch_addr_to_abort);
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x028b,
+ 	    "-------- ELS RSP -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x028b,
+ 	    (uint8_t *)abts_rsp, sizeof(*abts_rsp));
+ 	rval = qla2x00_issue_iocb(vha, abts_rsp, dma, 0);
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x028c,
+ 		    "%s: iocb failed to execute -> %x\n", __func__, rval);
+ 	} else if (abts_rsp->comp_status) {
+ 		ql_log(ql_log_warn, vha, 0x028d,
+ 		    "%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\n",
+ 		    __func__, abts_rsp->comp_status,
+ 		    abts_rsp->payload.error.subcode1,
+ 		    abts_rsp->payload.error.subcode2);
+ 	} else {
+ 		ql_dbg(ql_dbg_init, vha, 0x028ea,
+ 		    "%s: done.\n", __func__);
+ 	}
+ 
+ 	dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_els), rsp_els, dma);
+ }
+ 
++>>>>>>> 7ffa5b939751 (scsi: qla2xxx: Fix endianness annotations in source files)
  /**
   * qla2100_intr_handler() - Process interrupts for the ISP2100 and ISP2200.
   * @irq: interrupt number
@@@ -1700,11 -1838,10 +1840,10 @@@ qla24xx_els_ct_entry(scsi_qla_host_t *v
  				res = DID_ERROR << 16;
  			}
  		}
 -		ql_dbg(ql_dbg_user, vha, 0x503f,
 -		    "ELS IOCB Done -%s error hdl=%x comp_status=0x%x error subcode 1=0x%x error subcode 2=0x%x total_byte=0x%x\n",
 +		ql_dbg(ql_dbg_disc, vha, 0x503f,
 +		    "ELS IOCB Done -%s hdl=%x comp_status=0x%x error subcode 1=0x%x error subcode 2=0x%x total_byte=0x%x\n",
  		    type, sp->handle, comp_status, fw_status[1], fw_status[2],
- 		    le16_to_cpu(((struct els_sts_entry_24xx *)
- 			pkt)->total_byte_count));
+ 		    le32_to_cpu(ese->total_byte_count));
  		goto els_ct_done;
  	}
  
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 946fa90e85de,3b4760e80f00..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -4727,7 -4735,7 +4726,11 @@@ qla82xx_set_driver_version(scsi_qla_hos
  	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x117b,
  	    "Entered %s.\n", __func__);
  
++<<<<<<< HEAD
 +	str = (void *)version;
++=======
+ 	str = (__force __le16 *)version;
++>>>>>>> 7ffa5b939751 (scsi: qla2xxx: Fix endianness annotations in source files)
  	len = strlen(version);
  
  	mcp->mb[0] = MBC_SET_RNID_PARAMS;
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 344db146fcba,3f532a3df8e3..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -5594,6 -5744,584 +5594,587 @@@ retry_lock
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ qla25xx_rdp_rsp_reduce_size(struct scsi_qla_host *vha,
+ 	struct purex_entry_24xx *purex)
+ {
+ 	char fwstr[16];
+ 	u32 sid = purex->s_id[2] << 16 | purex->s_id[1] << 8 | purex->s_id[0];
+ 	struct port_database_24xx *pdb;
+ 
+ 	/* Domain Controller is always logged-out. */
+ 	/* if RDP request is not from Domain Controller: */
+ 	if (sid != 0xfffc01)
+ 		return false;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0181, "%s: s_id=%#x\n", __func__, sid);
+ 
+ 	pdb = kzalloc(sizeof(*pdb), GFP_KERNEL);
+ 	if (!pdb) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Failed allocate pdb\n", __func__);
+ 	} else if (qla24xx_get_port_database(vha,
+ 				le16_to_cpu(purex->nport_handle), pdb)) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Failed get pdb sid=%x\n", __func__, sid);
+ 	} else if (pdb->current_login_state != PDS_PLOGI_COMPLETE &&
+ 	    pdb->current_login_state != PDS_PRLI_COMPLETE) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Port not logged in sid=%#x\n", __func__, sid);
+ 	} else {
+ 		/* RDP request is from logged in port */
+ 		kfree(pdb);
+ 		return false;
+ 	}
+ 	kfree(pdb);
+ 
+ 	vha->hw->isp_ops->fw_version_str(vha, fwstr, sizeof(fwstr));
+ 	fwstr[strcspn(fwstr, " ")] = 0;
+ 	/* if FW version allows RDP response length upto 2048 bytes: */
+ 	if (strcmp(fwstr, "8.09.00") > 0 || strcmp(fwstr, "8.05.65") == 0)
+ 		return false;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0181, "%s: fw=%s\n", __func__, fwstr);
+ 
+ 	/* RDP response length is to be reduced to maximum 256 bytes */
+ 	return true;
+ }
+ 
+ static uint
+ qla25xx_rdp_port_speed_capability(struct qla_hw_data *ha)
+ {
+ 	if (IS_CNA_CAPABLE(ha))
+ 		return RDP_PORT_SPEED_10GB;
+ 
+ 	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
+ 		unsigned int speeds = 0;
+ 
+ 		if (ha->max_supported_speed == 2) {
+ 			if (ha->min_supported_speed <= 6)
+ 				speeds |= RDP_PORT_SPEED_64GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 2 ||
+ 		    ha->max_supported_speed == 1) {
+ 			if (ha->min_supported_speed <= 5)
+ 				speeds |= RDP_PORT_SPEED_32GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 2 ||
+ 		    ha->max_supported_speed == 1 ||
+ 		    ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 4)
+ 				speeds |= RDP_PORT_SPEED_16GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 1 ||
+ 		    ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 3)
+ 				speeds |= RDP_PORT_SPEED_8GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 2)
+ 				speeds |= RDP_PORT_SPEED_4GB;
+ 		}
+ 
+ 		return speeds;
+ 	}
+ 
+ 	if (IS_QLA2031(ha))
+ 		return RDP_PORT_SPEED_16GB|RDP_PORT_SPEED_8GB|
+ 		       RDP_PORT_SPEED_4GB;
+ 
+ 	if (IS_QLA25XX(ha))
+ 		return RDP_PORT_SPEED_8GB|RDP_PORT_SPEED_4GB|
+ 		       RDP_PORT_SPEED_2GB|RDP_PORT_SPEED_1GB;
+ 
+ 	if (IS_QLA24XX_TYPE(ha))
+ 		return RDP_PORT_SPEED_4GB|RDP_PORT_SPEED_2GB|
+ 		       RDP_PORT_SPEED_1GB;
+ 
+ 	if (IS_QLA23XX(ha))
+ 		return RDP_PORT_SPEED_2GB|RDP_PORT_SPEED_1GB;
+ 
+ 	return RDP_PORT_SPEED_1GB;
+ }
+ 
+ static uint
+ qla25xx_rdp_port_speed_currently(struct qla_hw_data *ha)
+ {
+ 	switch (ha->link_data_rate) {
+ 	case PORT_SPEED_1GB:
+ 		return RDP_PORT_SPEED_1GB;
+ 
+ 	case PORT_SPEED_2GB:
+ 		return RDP_PORT_SPEED_2GB;
+ 
+ 	case PORT_SPEED_4GB:
+ 		return RDP_PORT_SPEED_4GB;
+ 
+ 	case PORT_SPEED_8GB:
+ 		return RDP_PORT_SPEED_8GB;
+ 
+ 	case PORT_SPEED_10GB:
+ 		return RDP_PORT_SPEED_10GB;
+ 
+ 	case PORT_SPEED_16GB:
+ 		return RDP_PORT_SPEED_16GB;
+ 
+ 	case PORT_SPEED_32GB:
+ 		return RDP_PORT_SPEED_32GB;
+ 
+ 	case PORT_SPEED_64GB:
+ 		return RDP_PORT_SPEED_64GB;
+ 
+ 	default:
+ 		return RDP_PORT_SPEED_UNKNOWN;
+ 	}
+ }
+ 
+ /*
+  * Function Name: qla24xx_process_purex_iocb
+  *
+  * Description:
+  * Prepare a RDP response and send to Fabric switch
+  *
+  * PARAMETERS:
+  * vha:	SCSI qla host
+  * purex: RDP request received by HBA
+  */
+ void qla24xx_process_purex_rdp(struct scsi_qla_host *vha, void *pkt)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct purex_entry_24xx *purex = pkt;
+ 	dma_addr_t rsp_els_dma;
+ 	dma_addr_t rsp_payload_dma;
+ 	dma_addr_t stat_dma;
+ 	dma_addr_t bbc_dma;
+ 	dma_addr_t sfp_dma;
+ 	struct els_entry_24xx *rsp_els = NULL;
+ 	struct rdp_rsp_payload *rsp_payload = NULL;
+ 	struct link_statistics *stat = NULL;
+ 	struct buffer_credit_24xx *bbc = NULL;
+ 	uint8_t *sfp = NULL;
+ 	uint16_t sfp_flags = 0;
+ 	uint rsp_payload_length = sizeof(*rsp_payload);
+ 	int rval;
+ 
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0180,
+ 	    "%s: Enter\n", __func__);
+ 
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0181,
+ 	    "-------- ELS REQ -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0182,
+ 	    purex, sizeof(*purex));
+ 
+ 	if (qla25xx_rdp_rsp_reduce_size(vha, purex)) {
+ 		rsp_payload_length =
+ 		    offsetof(typeof(*rsp_payload), optical_elmt_desc);
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "Reducing RSP payload length to %u bytes...\n",
+ 		    rsp_payload_length);
+ 	}
+ 
+ 	rsp_els = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_els),
+ 	    &rsp_els_dma, GFP_KERNEL);
+ 	if (!rsp_els) {
+ 		ql_log(ql_log_warn, vha, 0x0183,
+ 		    "Failed allocate dma buffer ELS RSP.\n");
+ 		goto dealloc;
+ 	}
+ 
+ 	rsp_payload = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_payload),
+ 	    &rsp_payload_dma, GFP_KERNEL);
+ 	if (!rsp_payload) {
+ 		ql_log(ql_log_warn, vha, 0x0184,
+ 		    "Failed allocate dma buffer ELS RSP payload.\n");
+ 		goto dealloc;
+ 	}
+ 
+ 	sfp = dma_alloc_coherent(&ha->pdev->dev, SFP_RTDI_LEN,
+ 	    &sfp_dma, GFP_KERNEL);
+ 
+ 	stat = dma_alloc_coherent(&ha->pdev->dev, sizeof(*stat),
+ 	    &stat_dma, GFP_KERNEL);
+ 
+ 	bbc = dma_alloc_coherent(&ha->pdev->dev, sizeof(*bbc),
+ 	    &bbc_dma, GFP_KERNEL);
+ 
+ 	/* Prepare Response IOCB */
+ 	rsp_els->entry_type = ELS_IOCB_TYPE;
+ 	rsp_els->entry_count = 1;
+ 	rsp_els->sys_define = 0;
+ 	rsp_els->entry_status = 0;
+ 	rsp_els->handle = 0;
+ 	rsp_els->nport_handle = purex->nport_handle;
+ 	rsp_els->tx_dsd_count = cpu_to_le16(1);
+ 	rsp_els->vp_index = purex->vp_idx;
+ 	rsp_els->sof_type = EST_SOFI3;
+ 	rsp_els->rx_xchg_address = purex->rx_xchg_addr;
+ 	rsp_els->rx_dsd_count = 0;
+ 	rsp_els->opcode = purex->els_frame_payload[0];
+ 
+ 	rsp_els->d_id[0] = purex->s_id[0];
+ 	rsp_els->d_id[1] = purex->s_id[1];
+ 	rsp_els->d_id[2] = purex->s_id[2];
+ 
+ 	rsp_els->control_flags = cpu_to_le16(EPD_ELS_ACC);
+ 	rsp_els->rx_byte_count = 0;
+ 	rsp_els->tx_byte_count = cpu_to_le32(rsp_payload_length);
+ 
+ 	put_unaligned_le64(rsp_payload_dma, &rsp_els->tx_address);
+ 	rsp_els->tx_len = rsp_els->tx_byte_count;
+ 
+ 	rsp_els->rx_address = 0;
+ 	rsp_els->rx_len = 0;
+ 
+ 	/* Prepare Response Payload */
+ 	rsp_payload->hdr.cmd = cpu_to_be32(0x2 << 24); /* LS_ACC */
+ 	rsp_payload->hdr.len = cpu_to_be32(le32_to_cpu(rsp_els->tx_byte_count) -
+ 					   sizeof(rsp_payload->hdr));
+ 
+ 	/* Link service Request Info Descriptor */
+ 	rsp_payload->ls_req_info_desc.desc_tag = cpu_to_be32(0x1);
+ 	rsp_payload->ls_req_info_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc));
+ 	rsp_payload->ls_req_info_desc.req_payload_word_0 =
+ 	    cpu_to_be32p((uint32_t *)purex->els_frame_payload);
+ 
+ 	/* Link service Request Info Descriptor 2 */
+ 	rsp_payload->ls_req_info_desc2.desc_tag = cpu_to_be32(0x1);
+ 	rsp_payload->ls_req_info_desc2.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc2));
+ 	rsp_payload->ls_req_info_desc2.req_payload_word_0 =
+ 	    cpu_to_be32p((uint32_t *)purex->els_frame_payload);
+ 
+ 
+ 	rsp_payload->sfp_diag_desc.desc_tag = cpu_to_be32(0x10000);
+ 	rsp_payload->sfp_diag_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->sfp_diag_desc));
+ 
+ 	if (sfp) {
+ 		/* SFP Flags */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x7, 2, 0);
+ 		if (!rval) {
+ 			/* SFP Flags bits 3-0: Port Tx Laser Type */
+ 			if (sfp[0] & BIT_2 || sfp[1] & (BIT_6|BIT_5))
+ 				sfp_flags |= BIT_0; /* short wave */
+ 			else if (sfp[0] & BIT_1)
+ 				sfp_flags |= BIT_1; /* long wave 1310nm */
+ 			else if (sfp[1] & BIT_4)
+ 				sfp_flags |= BIT_1|BIT_0; /* long wave 1550nm */
+ 		}
+ 
+ 		/* SFP Type */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x0, 1, 0);
+ 		if (!rval) {
+ 			sfp_flags |= BIT_4; /* optical */
+ 			if (sfp[0] == 0x3)
+ 				sfp_flags |= BIT_6; /* sfp+ */
+ 		}
+ 
+ 		rsp_payload->sfp_diag_desc.sfp_flags = cpu_to_be16(sfp_flags);
+ 
+ 		/* SFP Diagnostics */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0x60, 10, 0);
+ 		if (!rval) {
+ 			__be16 *trx = (__force __be16 *)sfp; /* already be16 */
+ 			rsp_payload->sfp_diag_desc.temperature = trx[0];
+ 			rsp_payload->sfp_diag_desc.vcc = trx[1];
+ 			rsp_payload->sfp_diag_desc.tx_bias = trx[2];
+ 			rsp_payload->sfp_diag_desc.tx_power = trx[3];
+ 			rsp_payload->sfp_diag_desc.rx_power = trx[4];
+ 		}
+ 	}
+ 
+ 	/* Port Speed Descriptor */
+ 	rsp_payload->port_speed_desc.desc_tag = cpu_to_be32(0x10001);
+ 	rsp_payload->port_speed_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_speed_desc));
+ 	rsp_payload->port_speed_desc.speed_capab = cpu_to_be16(
+ 	    qla25xx_rdp_port_speed_capability(ha));
+ 	rsp_payload->port_speed_desc.operating_speed = cpu_to_be16(
+ 	    qla25xx_rdp_port_speed_currently(ha));
+ 
+ 	/* Link Error Status Descriptor */
+ 	rsp_payload->ls_err_desc.desc_tag = cpu_to_be32(0x10002);
+ 	rsp_payload->ls_err_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_err_desc));
+ 
+ 	if (stat) {
+ 		rval = qla24xx_get_isp_stats(vha, stat, stat_dma, 0);
+ 		if (!rval) {
+ 			rsp_payload->ls_err_desc.link_fail_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->link_fail_cnt));
+ 			rsp_payload->ls_err_desc.loss_sync_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->loss_sync_cnt));
+ 			rsp_payload->ls_err_desc.loss_sig_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->loss_sig_cnt));
+ 			rsp_payload->ls_err_desc.prim_seq_err_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->prim_seq_err_cnt));
+ 			rsp_payload->ls_err_desc.inval_xmit_word_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->inval_xmit_word_cnt));
+ 			rsp_payload->ls_err_desc.inval_crc_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->inval_crc_cnt));
+ 			rsp_payload->ls_err_desc.pn_port_phy_type |= BIT_6;
+ 		}
+ 	}
+ 
+ 	/* Portname Descriptor */
+ 	rsp_payload->port_name_diag_desc.desc_tag = cpu_to_be32(0x10003);
+ 	rsp_payload->port_name_diag_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_diag_desc));
+ 	memcpy(rsp_payload->port_name_diag_desc.WWNN,
+ 	    vha->node_name,
+ 	    sizeof(rsp_payload->port_name_diag_desc.WWNN));
+ 	memcpy(rsp_payload->port_name_diag_desc.WWPN,
+ 	    vha->port_name,
+ 	    sizeof(rsp_payload->port_name_diag_desc.WWPN));
+ 
+ 	/* F-Port Portname Descriptor */
+ 	rsp_payload->port_name_direct_desc.desc_tag = cpu_to_be32(0x10003);
+ 	rsp_payload->port_name_direct_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_direct_desc));
+ 	memcpy(rsp_payload->port_name_direct_desc.WWNN,
+ 	    vha->fabric_node_name,
+ 	    sizeof(rsp_payload->port_name_direct_desc.WWNN));
+ 	memcpy(rsp_payload->port_name_direct_desc.WWPN,
+ 	    vha->fabric_port_name,
+ 	    sizeof(rsp_payload->port_name_direct_desc.WWPN));
+ 
+ 	/* Bufer Credit Descriptor */
+ 	rsp_payload->buffer_credit_desc.desc_tag = cpu_to_be32(0x10006);
+ 	rsp_payload->buffer_credit_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->buffer_credit_desc));
+ 	rsp_payload->buffer_credit_desc.fcport_b2b = 0;
+ 	rsp_payload->buffer_credit_desc.attached_fcport_b2b = cpu_to_be32(0);
+ 	rsp_payload->buffer_credit_desc.fcport_rtt = cpu_to_be32(0);
+ 
+ 	if (bbc) {
+ 		memset(bbc, 0, sizeof(*bbc));
+ 		rval = qla24xx_get_buffer_credits(vha, bbc, bbc_dma);
+ 		if (!rval) {
+ 			rsp_payload->buffer_credit_desc.fcport_b2b =
+ 			    cpu_to_be32(LSW(bbc->parameter[0]));
+ 		}
+ 	}
+ 
+ 	if (rsp_payload_length < sizeof(*rsp_payload))
+ 		goto send;
+ 
+ 	/* Optical Element Descriptor, Temperature */
+ 	rsp_payload->optical_elmt_desc[0].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[0].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Voltage */
+ 	rsp_payload->optical_elmt_desc[1].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[1].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Tx Bias Current */
+ 	rsp_payload->optical_elmt_desc[2].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[2].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Tx Power */
+ 	rsp_payload->optical_elmt_desc[3].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[3].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Rx Power */
+ 	rsp_payload->optical_elmt_desc[4].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[4].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 
+ 	if (sfp) {
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0, 64, 0);
+ 		if (!rval) {
+ 			__be16 *trx = (__force __be16 *)sfp; /* already be16 */
+ 
+ 			/* Optical Element Descriptor, Temperature */
+ 			rsp_payload->optical_elmt_desc[0].high_alarm = trx[0];
+ 			rsp_payload->optical_elmt_desc[0].low_alarm = trx[1];
+ 			rsp_payload->optical_elmt_desc[0].high_warn = trx[2];
+ 			rsp_payload->optical_elmt_desc[0].low_warn = trx[3];
+ 			rsp_payload->optical_elmt_desc[0].element_flags =
+ 			    cpu_to_be32(1 << 28);
+ 
+ 			/* Optical Element Descriptor, Voltage */
+ 			rsp_payload->optical_elmt_desc[1].high_alarm = trx[4];
+ 			rsp_payload->optical_elmt_desc[1].low_alarm = trx[5];
+ 			rsp_payload->optical_elmt_desc[1].high_warn = trx[6];
+ 			rsp_payload->optical_elmt_desc[1].low_warn = trx[7];
+ 			rsp_payload->optical_elmt_desc[1].element_flags =
+ 			    cpu_to_be32(2 << 28);
+ 
+ 			/* Optical Element Descriptor, Tx Bias Current */
+ 			rsp_payload->optical_elmt_desc[2].high_alarm = trx[8];
+ 			rsp_payload->optical_elmt_desc[2].low_alarm = trx[9];
+ 			rsp_payload->optical_elmt_desc[2].high_warn = trx[10];
+ 			rsp_payload->optical_elmt_desc[2].low_warn = trx[11];
+ 			rsp_payload->optical_elmt_desc[2].element_flags =
+ 			    cpu_to_be32(3 << 28);
+ 
+ 			/* Optical Element Descriptor, Tx Power */
+ 			rsp_payload->optical_elmt_desc[3].high_alarm = trx[12];
+ 			rsp_payload->optical_elmt_desc[3].low_alarm = trx[13];
+ 			rsp_payload->optical_elmt_desc[3].high_warn = trx[14];
+ 			rsp_payload->optical_elmt_desc[3].low_warn = trx[15];
+ 			rsp_payload->optical_elmt_desc[3].element_flags =
+ 			    cpu_to_be32(4 << 28);
+ 
+ 			/* Optical Element Descriptor, Rx Power */
+ 			rsp_payload->optical_elmt_desc[4].high_alarm = trx[16];
+ 			rsp_payload->optical_elmt_desc[4].low_alarm = trx[17];
+ 			rsp_payload->optical_elmt_desc[4].high_warn = trx[18];
+ 			rsp_payload->optical_elmt_desc[4].low_warn = trx[19];
+ 			rsp_payload->optical_elmt_desc[4].element_flags =
+ 			    cpu_to_be32(5 << 28);
+ 		}
+ 
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 112, 64, 0);
+ 		if (!rval) {
+ 			/* Temperature high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[0].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 7 & 1) << 3 |
+ 				(sfp[0] >> 6 & 1) << 2 |
+ 				(sfp[4] >> 7 & 1) << 1 |
+ 				(sfp[4] >> 6 & 1) << 0);
+ 
+ 			/* Voltage high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[1].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 5 & 1) << 3 |
+ 				(sfp[0] >> 4 & 1) << 2 |
+ 				(sfp[4] >> 5 & 1) << 1 |
+ 				(sfp[4] >> 4 & 1) << 0);
+ 
+ 			/* Tx Bias Current high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[2].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 3 & 1) << 3 |
+ 				(sfp[0] >> 2 & 1) << 2 |
+ 				(sfp[4] >> 3 & 1) << 1 |
+ 				(sfp[4] >> 2 & 1) << 0);
+ 
+ 			/* Tx Power high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[3].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 1 & 1) << 3 |
+ 				(sfp[0] >> 0 & 1) << 2 |
+ 				(sfp[4] >> 1 & 1) << 1 |
+ 				(sfp[4] >> 0 & 1) << 0);
+ 
+ 			/* Rx Power high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[4].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[1] >> 7 & 1) << 3 |
+ 				(sfp[1] >> 6 & 1) << 2 |
+ 				(sfp[5] >> 7 & 1) << 1 |
+ 				(sfp[5] >> 6 & 1) << 0);
+ 		}
+ 	}
+ 
+ 	/* Optical Product Data Descriptor */
+ 	rsp_payload->optical_prod_desc.desc_tag = cpu_to_be32(0x10008);
+ 	rsp_payload->optical_prod_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->optical_prod_desc));
+ 
+ 	if (sfp) {
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 20, 64, 0);
+ 		if (!rval) {
+ 			memcpy(rsp_payload->optical_prod_desc.vendor_name,
+ 			    sfp + 0,
+ 			    sizeof(rsp_payload->optical_prod_desc.vendor_name));
+ 			memcpy(rsp_payload->optical_prod_desc.part_number,
+ 			    sfp + 20,
+ 			    sizeof(rsp_payload->optical_prod_desc.part_number));
+ 			memcpy(rsp_payload->optical_prod_desc.revision,
+ 			    sfp + 36,
+ 			    sizeof(rsp_payload->optical_prod_desc.revision));
+ 			memcpy(rsp_payload->optical_prod_desc.serial_number,
+ 			    sfp + 48,
+ 			    sizeof(rsp_payload->optical_prod_desc.serial_number));
+ 		}
+ 
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 84, 8, 0);
+ 		if (!rval) {
+ 			memcpy(rsp_payload->optical_prod_desc.date,
+ 			    sfp + 0,
+ 			    sizeof(rsp_payload->optical_prod_desc.date));
+ 		}
+ 	}
+ 
+ send:
+ 	ql_dbg(ql_dbg_init, vha, 0x0183,
+ 	    "Sending ELS Response to RDP Request...\n");
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0184,
+ 	    "-------- ELS RSP -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0185,
+ 	    rsp_els, sizeof(*rsp_els));
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0186,
+ 	    "-------- ELS RSP PAYLOAD -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0187,
+ 	    rsp_payload, rsp_payload_length);
+ 
+ 	rval = qla2x00_issue_iocb(vha, rsp_els, rsp_els_dma, 0);
+ 
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x0188,
+ 		    "%s: iocb failed to execute -> %x\n", __func__, rval);
+ 	} else if (rsp_els->comp_status) {
+ 		ql_log(ql_log_warn, vha, 0x0189,
+ 		    "%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\n",
+ 		    __func__, rsp_els->comp_status,
+ 		    rsp_els->error_subcode_1, rsp_els->error_subcode_2);
+ 	} else {
+ 		ql_dbg(ql_dbg_init, vha, 0x018a, "%s: done.\n", __func__);
+ 	}
+ 
+ dealloc:
+ 	if (bbc)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*bbc),
+ 		    bbc, bbc_dma);
+ 	if (stat)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*stat),
+ 		    stat, stat_dma);
+ 	if (sfp)
+ 		dma_free_coherent(&ha->pdev->dev, SFP_RTDI_LEN,
+ 		    sfp, sfp_dma);
+ 	if (rsp_payload)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_payload),
+ 		    rsp_payload, rsp_payload_dma);
+ 	if (rsp_els)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_els),
+ 		    rsp_els, rsp_els_dma);
+ }
+ 
+ void qla24xx_process_purex_list(struct purex_list *list)
+ {
+ 	struct list_head head = LIST_HEAD_INIT(head);
+ 	struct purex_item *item, *next;
+ 	ulong flags;
+ 
+ 	spin_lock_irqsave(&list->lock, flags);
+ 	list_splice_init(&list->head, &head);
+ 	spin_unlock_irqrestore(&list->lock, flags);
+ 
+ 	list_for_each_entry_safe(item, next, &head, list) {
+ 		list_del(&item->list);
+ 		item->process_item(item->vha, &item->iocb);
+ 		kfree(item);
+ 	}
+ }
+ 
++>>>>>>> 7ffa5b939751 (scsi: qla2xxx: Fix endianness annotations in source files)
  void
  qla83xx_idc_unlock(scsi_qla_host_t *base_vha, uint16_t requester_id)
  {
diff --cc drivers/scsi/qla2xxx/qla_sup.c
index da984d7552d5,e161c05d7d82..000000000000
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@@ -610,7 -611,7 +611,11 @@@ qla2xxx_find_flt_start(scsi_qla_host_t 
  	if (memcmp(fltl->sig, "QFLT", 4))
  		goto end;
  
++<<<<<<< HEAD
 +	wptr = (void *)req->ring;
++=======
+ 	wptr = (__force __le16 *)req->ring;
++>>>>>>> 7ffa5b939751 (scsi: qla2xxx: Fix endianness annotations in source files)
  	cnt = sizeof(*fltl) / sizeof(*wptr);
  	for (chksum = 0; cnt--; wptr++)
  		chksum += le16_to_cpu(*wptr);
@@@ -681,8 -683,8 +687,13 @@@ qla2xxx_get_flt_info(scsi_qla_host_t *v
  	    fcp_prio_cfg0[def] : fcp_prio_cfg1[def];
  
  	ha->flt_region_flt = flt_addr;
++<<<<<<< HEAD
 +	wptr = (uint16_t *)ha->flt;
 +	ha->isp_ops->read_optrom(vha, (void *)flt, flt_addr << 2,
++=======
+ 	wptr = (__force __le16 *)ha->flt;
+ 	ha->isp_ops->read_optrom(vha, flt, flt_addr << 2,
++>>>>>>> 7ffa5b939751 (scsi: qla2xxx: Fix endianness annotations in source files)
  	    (sizeof(struct qla_flt_header) + FLT_REGIONS_SIZE));
  
  	if (le16_to_cpu(*wptr) == 0xffff)
@@@ -949,7 -951,7 +960,11 @@@ qla2xxx_get_fdt_info(scsi_qla_host_t *v
  	struct qla_hw_data *ha = vha->hw;
  	struct req_que *req = ha->req_q_map[0];
  	uint16_t cnt, chksum;
++<<<<<<< HEAD
 +	uint16_t *wptr = (void *)req->ring;
++=======
+ 	__le16 *wptr = (__force __le16 *)req->ring;
++>>>>>>> 7ffa5b939751 (scsi: qla2xxx: Fix endianness annotations in source files)
  	struct qla_fdt_layout *fdt = (struct qla_fdt_layout *)req->ring;
  	uint8_t	man_id, flash_id;
  	uint16_t mid = 0, fid = 0;
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index dfd7737e5085..65f7adaa4d38 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -227,10 +227,9 @@ qla2x00_sysfs_write_nvram(struct file *filp, struct kobject *kobj,
 
 	/* Checksum NVRAM. */
 	if (IS_FWI2_CAPABLE(ha)) {
-		uint32_t *iter;
+		__le32 *iter = (__force __le32 *)buf;
 		uint32_t chksum;
 
-		iter = (uint32_t *)buf;
 		chksum = 0;
 		for (cnt = 0; cnt < ((count >> 2) - 1); cnt++, iter++)
 			chksum += le32_to_cpu(*iter);
diff --git a/drivers/scsi/qla2xxx/qla_bsg.c b/drivers/scsi/qla2xxx/qla_bsg.c
index a55ba01a0003..37636a2a1581 100644
--- a/drivers/scsi/qla2xxx/qla_bsg.c
+++ b/drivers/scsi/qla2xxx/qla_bsg.c
@@ -490,7 +490,7 @@ qla2x00_process_ct(struct bsg_job *bsg_job)
 			>> 24;
 	switch (loop_id) {
 	case 0xFC:
-		loop_id = cpu_to_le16(NPH_SNS);
+		loop_id = NPH_SNS;
 		break;
 	case 0xFA:
 		loop_id = vha->mgmt_svr_loop_id;
@@ -2042,7 +2042,7 @@ qlafx00_mgmt_cmd(struct bsg_job *bsg_job)
 
 	/* Initialize all required  fields of fcport */
 	fcport->vha = vha;
-	fcport->loop_id = piocb_rqst->dataword;
+	fcport->loop_id = le32_to_cpu(piocb_rqst->dataword);
 
 	sp->type = SRB_FXIOCB_BCMD;
 	sp->name = "bsg_fx_mgmt";
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index fbd8cb5647b6..d0ca39b92727 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -189,8 +189,8 @@ qla27xx_dump_mpi_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 }
 
 int
-qla24xx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
-    uint32_t ram_dwords, void **nxt)
+qla24xx_dump_ram(struct qla_hw_data *ha, uint32_t addr, __be32 *ram,
+		 uint32_t ram_dwords, void **nxt)
 {
 	int rval = QLA_FUNCTION_FAILED;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
@@ -254,9 +254,9 @@ qla24xx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 			return rval;
 		}
 		for (j = 0; j < dwords; j++) {
-			ram[i + j] =
-			    (IS_QLA27XX(ha) || IS_QLA28XX(ha)) ?
-			    chunk[j] : swab32(chunk[j]);
+			ram[i + j] = (__force __be32)
+				((IS_QLA27XX(ha) || IS_QLA28XX(ha)) ?
+				 chunk[j] : swab32(chunk[j]));
 		}
 	}
 
@@ -265,8 +265,8 @@ qla24xx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 }
 
 static int
-qla24xx_dump_memory(struct qla_hw_data *ha, uint32_t *code_ram,
-    uint32_t cram_size, void **nxt)
+qla24xx_dump_memory(struct qla_hw_data *ha, __be32 *code_ram,
+		    uint32_t cram_size, void **nxt)
 {
 	int rval;
 
@@ -286,11 +286,11 @@ qla24xx_dump_memory(struct qla_hw_data *ha, uint32_t *code_ram,
 	return rval;
 }
 
-static uint32_t *
+static __be32 *
 qla24xx_read_window(struct device_reg_24xx __iomem *reg, uint32_t iobase,
-    uint32_t count, uint32_t *buf)
+		    uint32_t count, __be32 *buf)
 {
-	uint32_t __iomem *dmp_reg;
+	__le32 __iomem *dmp_reg;
 
 	wrt_reg_dword(&reg->iobase_addr, iobase);
 	dmp_reg = &reg->iobase_window;
@@ -368,7 +368,7 @@ qla24xx_soft_reset(struct qla_hw_data *ha)
 }
 
 static int
-qla2xxx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint16_t *ram,
+qla2xxx_dump_ram(struct qla_hw_data *ha, uint32_t addr, __be16 *ram,
     uint32_t ram_words, void **nxt)
 {
 	int rval;
@@ -376,7 +376,7 @@ qla2xxx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint16_t *ram,
 	uint16_t mb0;
 	struct device_reg_2xxx __iomem *reg = &ha->iobase->isp;
 	dma_addr_t dump_dma = ha->gid_list_dma;
-	uint16_t *dump = (uint16_t *)ha->gid_list;
+	__le16 *dump = (__force __le16 *)ha->gid_list;
 
 	rval = QLA_SUCCESS;
 	mb0 = 0;
@@ -441,7 +441,8 @@ qla2xxx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint16_t *ram,
 		if (test_and_clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags)) {
 			rval = mb0 & MBS_MASK;
 			for (idx = 0; idx < words; idx++)
-				ram[cnt + idx] = swab16(dump[idx]);
+				ram[cnt + idx] =
+					cpu_to_be16(le16_to_cpu(dump[idx]));
 		} else {
 			rval = QLA_FUNCTION_FAILED;
 		}
@@ -453,9 +454,9 @@ qla2xxx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint16_t *ram,
 
 static inline void
 qla2xxx_read_window(struct device_reg_2xxx __iomem *reg, uint32_t count,
-    uint16_t *buf)
+		    __be16 *buf)
 {
-	uint16_t __iomem *dmp_reg = &reg->u.isp2300.fb_cmd;
+	__le16 __iomem *dmp_reg = &reg->u.isp2300.fb_cmd;
 
 	for ( ; count--; dmp_reg++)
 		*buf++ = htons(rd_reg_word(dmp_reg));
@@ -472,10 +473,10 @@ qla24xx_copy_eft(struct qla_hw_data *ha, void *ptr)
 }
 
 static inline void *
-qla25xx_copy_fce(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
+qla25xx_copy_fce(struct qla_hw_data *ha, void *ptr, __be32 **last_chain)
 {
 	uint32_t cnt;
-	uint32_t *iter_reg;
+	__be32 *iter_reg;
 	struct qla2xxx_fce_chain *fcec = ptr;
 
 	if (!ha->fce)
@@ -499,7 +500,7 @@ qla25xx_copy_fce(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
 }
 
 static inline void *
-qla25xx_copy_exlogin(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
+qla25xx_copy_exlogin(struct qla_hw_data *ha, void *ptr, __be32 **last_chain)
 {
 	struct qla2xxx_offld_chain *c = ptr;
 
@@ -517,11 +518,11 @@ qla25xx_copy_exlogin(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
 	ptr += sizeof(struct qla2xxx_offld_chain);
 	memcpy(ptr, ha->exlogin_buf, ha->exlogin_size);
 
-	return (char *)ptr + cpu_to_be32(c->size);
+	return (char *)ptr + be32_to_cpu(c->size);
 }
 
 static inline void *
-qla81xx_copy_exchoffld(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
+qla81xx_copy_exchoffld(struct qla_hw_data *ha, void *ptr, __be32 **last_chain)
 {
 	struct qla2xxx_offld_chain *c = ptr;
 
@@ -539,12 +540,12 @@ qla81xx_copy_exchoffld(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
 	ptr += sizeof(struct qla2xxx_offld_chain);
 	memcpy(ptr, ha->exchoffld_buf, ha->exchoffld_size);
 
-	return (char *)ptr + cpu_to_be32(c->size);
+	return (char *)ptr + be32_to_cpu(c->size);
 }
 
 static inline void *
 qla2xxx_copy_atioqueues(struct qla_hw_data *ha, void *ptr,
-	uint32_t **last_chain)
+			__be32 **last_chain)
 {
 	struct qla2xxx_mqueue_chain *q;
 	struct qla2xxx_mqueue_header *qh;
@@ -591,7 +592,7 @@ qla2xxx_copy_atioqueues(struct qla_hw_data *ha, void *ptr,
 }
 
 static inline void *
-qla25xx_copy_mqueues(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
+qla25xx_copy_mqueues(struct qla_hw_data *ha, void *ptr, __be32 **last_chain)
 {
 	struct qla2xxx_mqueue_chain *q;
 	struct qla2xxx_mqueue_header *qh;
@@ -662,7 +663,7 @@ qla25xx_copy_mqueues(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
 }
 
 static inline void *
-qla25xx_copy_mq(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
+qla25xx_copy_mq(struct qla_hw_data *ha, void *ptr, __be32 **last_chain)
 {
 	uint32_t cnt, que_idx;
 	uint8_t que_cnt;
@@ -736,7 +737,7 @@ qla2300_fw_dump(scsi_qla_host_t *vha)
 	uint32_t	cnt;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_2xxx __iomem *reg = &ha->iobase->isp;
-	uint16_t __iomem *dmp_reg;
+	__le16 __iomem *dmp_reg;
 	struct qla2300_fw_dump	*fw;
 	void		*nxt;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
@@ -893,7 +894,7 @@ qla2100_fw_dump(scsi_qla_host_t *vha)
 	uint16_t	mb0 = 0, mb2 = 0;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_2xxx __iomem *reg = &ha->iobase->isp;
-	uint16_t __iomem *dmp_reg;
+	__le16 __iomem *dmp_reg;
 	struct qla2100_fw_dump	*fw;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 
@@ -1074,13 +1075,13 @@ qla24xx_fw_dump(scsi_qla_host_t *vha)
 	uint32_t	cnt;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
-	uint32_t __iomem *dmp_reg;
-	uint32_t	*iter_reg;
-	uint16_t __iomem *mbx_reg;
+	__le32 __iomem *dmp_reg;
+	__be32		*iter_reg;
+	__le16 __iomem *mbx_reg;
 	struct qla24xx_fw_dump *fw;
 	void		*nxt;
 	void		*nxt_chain;
-	uint32_t	*last_chain = NULL;
+	__be32		*last_chain = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 
 	lockdep_assert_held(&ha->hardware_lock);
@@ -1320,12 +1321,12 @@ qla25xx_fw_dump(scsi_qla_host_t *vha)
 	uint32_t	cnt;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
-	uint32_t __iomem *dmp_reg;
-	uint32_t	*iter_reg;
-	uint16_t __iomem *mbx_reg;
+	__le32 __iomem *dmp_reg;
+	__be32		*iter_reg;
+	__le16 __iomem *mbx_reg;
 	struct qla25xx_fw_dump *fw;
 	void		*nxt, *nxt_chain;
-	uint32_t	*last_chain = NULL;
+	__be32		*last_chain = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 
 	lockdep_assert_held(&ha->hardware_lock);
@@ -1633,12 +1634,12 @@ qla81xx_fw_dump(scsi_qla_host_t *vha)
 	uint32_t	cnt;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
-	uint32_t __iomem *dmp_reg;
-	uint32_t	*iter_reg;
-	uint16_t __iomem *mbx_reg;
+	__le32 __iomem *dmp_reg;
+	__be32		*iter_reg;
+	__le16 __iomem *mbx_reg;
 	struct qla81xx_fw_dump *fw;
 	void		*nxt, *nxt_chain;
-	uint32_t	*last_chain = NULL;
+	__be32		*last_chain = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 
 	lockdep_assert_held(&ha->hardware_lock);
@@ -1948,12 +1949,12 @@ qla83xx_fw_dump(scsi_qla_host_t *vha)
 	uint32_t	cnt;
 	struct qla_hw_data *ha = vha->hw;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
-	uint32_t __iomem *dmp_reg;
-	uint32_t	*iter_reg;
-	uint16_t __iomem *mbx_reg;
+	__le32 __iomem *dmp_reg;
+	__be32		*iter_reg;
+	__le16 __iomem *mbx_reg;
 	struct qla83xx_fw_dump *fw;
 	void		*nxt, *nxt_chain;
-	uint32_t	*last_chain = NULL;
+	__be32		*last_chain = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 
 	lockdep_assert_held(&ha->hardware_lock);
@@ -2659,7 +2660,7 @@ ql_dump_regs(uint level, scsi_qla_host_t *vha, uint id)
 	struct device_reg_2xxx __iomem *reg = &ha->iobase->isp;
 	struct device_reg_24xx __iomem *reg24 = &ha->iobase->isp24;
 	struct device_reg_82xx __iomem *reg82 = &ha->iobase->isp82;
-	uint16_t __iomem *mbx_reg;
+	__le16 __iomem *mbx_reg;
 
 	if (!ql_mask_match(level))
 		return;
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_iocb.c b/drivers/scsi/qla2xxx/qla_iocb.c
index b0d27a9de286..0b339cfd887f 100644
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@ -661,7 +661,7 @@ qla24xx_build_scsi_type_6_iocbs(srb_t *sp, struct cmd_type_6 *cmd_pkt,
 	cur_dsd->address = 0;
 	cur_dsd->length = 0;
 	cur_dsd++;
-	cmd_pkt->control_flags |= CF_DATA_SEG_DESCR_ENABLE;
+	cmd_pkt->control_flags |= cpu_to_le16(CF_DATA_SEG_DESCR_ENABLE);
 	return 0;
 }
 
@@ -755,8 +755,8 @@ qla24xx_build_scsi_iocbs(srb_t *sp, struct cmd_type_7 *cmd_pkt,
 }
 
 struct fw_dif_context {
-	uint32_t ref_tag;
-	uint16_t app_tag;
+	__le32	ref_tag;
+	__le16	app_tag;
 	uint8_t ref_tag_mask[4];	/* Validation/Replacement Mask*/
 	uint8_t app_tag_mask[2];	/* Validation/Replacement Mask*/
 };
@@ -1389,7 +1389,7 @@ qla24xx_build_scsi_crc_2_iocbs(srb_t *sp, struct cmd_type_crc_2 *cmd_pkt,
     uint16_t tot_dsds, uint16_t tot_prot_dsds, uint16_t fw_prot_opts)
 {
 	struct dsd64		*cur_dsd;
-	uint32_t		*fcp_dl;
+	__be32			*fcp_dl;
 	scsi_qla_host_t		*vha;
 	struct scsi_cmnd	*cmd;
 	uint32_t		total_bytes = 0;
@@ -1456,7 +1456,7 @@ qla24xx_build_scsi_crc_2_iocbs(srb_t *sp, struct cmd_type_crc_2 *cmd_pkt,
 	    &crc_ctx_pkt->ref_tag, tot_prot_dsds);
 
 	put_unaligned_le64(crc_ctx_dma, &cmd_pkt->crc_context_address);
-	cmd_pkt->crc_context_len = CRC_CONTEXT_LEN_FW;
+	cmd_pkt->crc_context_len = cpu_to_le16(CRC_CONTEXT_LEN_FW);
 
 	/* Determine SCSI command length -- align to 4 byte boundary */
 	if (cmd->cmd_len > 16) {
@@ -1545,7 +1545,7 @@ qla24xx_build_scsi_crc_2_iocbs(srb_t *sp, struct cmd_type_crc_2 *cmd_pkt,
 	crc_ctx_pkt->guard_seed = cpu_to_le16(0);
 	/* Fibre channel byte count */
 	cmd_pkt->byte_count = cpu_to_le32(total_bytes);
-	fcp_dl = (uint32_t *)(crc_ctx_pkt->fcp_cmnd.cdb + 16 +
+	fcp_dl = (__be32 *)(crc_ctx_pkt->fcp_cmnd.cdb + 16 +
 	    additional_fcpcdb_len);
 	*fcp_dl = htonl(total_bytes);
 
@@ -2344,9 +2344,10 @@ qla24xx_prli_iocb(srb_t *sp, struct logio_entry_24xx *logio)
 	logio->entry_type = LOGINOUT_PORT_IOCB_TYPE;
 	logio->control_flags = cpu_to_le16(LCF_COMMAND_PRLI);
 	if (lio->u.logio.flags & SRB_LOGIN_NVME_PRLI) {
-		logio->control_flags |= LCF_NVME_PRLI;
+		logio->control_flags |= cpu_to_le16(LCF_NVME_PRLI);
 		if (sp->vha->flags.nvme_first_burst)
-			logio->io_parameter[0] = NVME_PRLI_SP_FIRST_BURST;
+			logio->io_parameter[0] =
+				cpu_to_le32(NVME_PRLI_SP_FIRST_BURST);
 	}
 
 	logio->nport_handle = cpu_to_le16(sp->fcport->loop_id);
@@ -2680,7 +2681,7 @@ qla24xx_els_logo_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
 	els_iocb->entry_status = 0;
 	els_iocb->handle = sp->handle;
 	els_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);
-	els_iocb->tx_dsd_count = 1;
+	els_iocb->tx_dsd_count = cpu_to_le16(1);
 	els_iocb->vp_index = vha->vp_idx;
 	els_iocb->sof_type = EST_SOFI3;
 	els_iocb->rx_dsd_count = 0;
@@ -2700,7 +2701,7 @@ qla24xx_els_logo_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
 			cpu_to_le32(sizeof(struct els_plogi_payload));
 		put_unaligned_le64(elsio->u.els_plogi.els_plogi_pyld_dma,
 				   &els_iocb->tx_address);
-		els_iocb->rx_dsd_count = 1;
+		els_iocb->rx_dsd_count = cpu_to_le16(1);
 		els_iocb->rx_byte_count = els_iocb->rx_len =
 			cpu_to_le32(sizeof(struct els_plogi_payload));
 		put_unaligned_le64(elsio->u.els_plogi.els_resp_pyld_dma,
@@ -2712,7 +2713,7 @@ qla24xx_els_logo_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
 		    (uint8_t *)els_iocb,
 		    sizeof(*els_iocb));
 	} else {
-		els_iocb->control_flags = 1 << 13;
+		els_iocb->control_flags = cpu_to_le16(1 << 13);
 		els_iocb->tx_byte_count =
 			cpu_to_le32(sizeof(struct els_logo_payload));
 		put_unaligned_le64(elsio->u.els_logo.els_logo_pyld_dma,
@@ -2787,7 +2788,7 @@ static void qla2x00_els_dcmd2_sp_done(srb_t *sp, int res)
 	struct qla_work_evt *e;
 	struct fc_port *conflict_fcport;
 	port_id_t cid;	/* conflict Nport id */
-	u32 *fw_status = sp->u.iocb_cmd.u.els_plogi.fw_status;
+	const __le32 *fw_status = sp->u.iocb_cmd.u.els_plogi.fw_status;
 	u16 lid;
 
 	ql_dbg(ql_dbg_disc, vha, 0x3072,
@@ -2800,7 +2801,7 @@ static void qla2x00_els_dcmd2_sp_done(srb_t *sp, int res)
 	if (sp->flags & SRB_WAKEUP_ON_COMP)
 		complete(&lio->u.els_plogi.comp);
 	else {
-		switch (fw_status[0]) {
+		switch (le32_to_cpu(fw_status[0])) {
 		case CS_DATA_UNDERRUN:
 		case CS_COMPLETE:
 			memset(&ea, 0, sizeof(ea));
@@ -2810,9 +2811,9 @@ static void qla2x00_els_dcmd2_sp_done(srb_t *sp, int res)
 			break;
 
 		case CS_IOCB_ERROR:
-			switch (fw_status[1]) {
+			switch (le32_to_cpu(fw_status[1])) {
 			case LSC_SCODE_PORTID_USED:
-				lid = fw_status[2] & 0xffff;
+				lid = le32_to_cpu(fw_status[2]) & 0xffff;
 				qlt_find_sess_invalidate_other(vha,
 				    wwn_to_u64(fcport->port_name),
 				    fcport->d_id, lid, &conflict_fcport);
@@ -2846,9 +2847,11 @@ static void qla2x00_els_dcmd2_sp_done(srb_t *sp, int res)
 				break;
 
 			case LSC_SCODE_NPORT_USED:
-				cid.b.domain = (fw_status[2] >> 16) & 0xff;
-				cid.b.area   = (fw_status[2] >>  8) & 0xff;
-				cid.b.al_pa  = fw_status[2] & 0xff;
+				cid.b.domain = (le32_to_cpu(fw_status[2]) >> 16)
+					& 0xff;
+				cid.b.area   = (le32_to_cpu(fw_status[2]) >>  8)
+					& 0xff;
+				cid.b.al_pa  = le32_to_cpu(fw_status[2]) & 0xff;
 				cid.b.rsvd_1 = 0;
 
 				ql_dbg(ql_dbg_disc, vha, 0x20ec,
@@ -3022,7 +3025,7 @@ qla24xx_els_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
         els_iocb->sys_define = 0;
         els_iocb->entry_status = 0;
         els_iocb->handle = sp->handle;
-        els_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);
+	els_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);
 	els_iocb->tx_dsd_count = cpu_to_le16(bsg_job->request_payload.sg_cnt);
 	els_iocb->vp_index = sp->vha->vp_idx;
         els_iocb->sof_type = EST_SOFI3;
@@ -3216,7 +3219,7 @@ qla82xx_start_scsi(srb_t *sp)
 	uint16_t	tot_dsds;
 	struct device_reg_82xx __iomem *reg;
 	uint32_t dbval;
-	uint32_t *fcp_dl;
+	__be32 *fcp_dl;
 	uint8_t additional_cdb_len;
 	struct ct6_dsd *ctx;
 	struct scsi_qla_host *vha = sp->vha;
@@ -3398,7 +3401,7 @@ qla82xx_start_scsi(srb_t *sp)
 
 		memcpy(ctx->fcp_cmnd->cdb, cmd->cmnd, cmd->cmd_len);
 
-		fcp_dl = (uint32_t *)(ctx->fcp_cmnd->cdb + 16 +
+		fcp_dl = (__be32 *)(ctx->fcp_cmnd->cdb + 16 +
 		    additional_cdb_len);
 		*fcp_dl = htonl((uint32_t)scsi_bufflen(cmd));
 
@@ -3536,7 +3539,7 @@ qla24xx_abort_iocb(srb_t *sp, struct abort_entry_24xx *abt_iocb)
 	memset(abt_iocb, 0, sizeof(struct abort_entry_24xx));
 	abt_iocb->entry_type = ABORT_IOCB_TYPE;
 	abt_iocb->entry_count = 1;
-	abt_iocb->handle = cpu_to_le32(make_handle(req->id, sp->handle));
+	abt_iocb->handle = make_handle(req->id, sp->handle);
 	if (sp->fcport) {
 		abt_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);
 		abt_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;
@@ -3544,10 +3547,10 @@ qla24xx_abort_iocb(srb_t *sp, struct abort_entry_24xx *abt_iocb)
 		abt_iocb->port_id[2] = sp->fcport->d_id.b.domain;
 	}
 	abt_iocb->handle_to_abort =
-	    cpu_to_le32(make_handle(aio->u.abt.req_que_no,
-				    aio->u.abt.cmd_hndl));
+		make_handle(le16_to_cpu(aio->u.abt.req_que_no),
+			    aio->u.abt.cmd_hndl);
 	abt_iocb->vp_index = vha->vp_idx;
-	abt_iocb->req_que_no = cpu_to_le16(aio->u.abt.req_que_no);
+	abt_iocb->req_que_no = aio->u.abt.req_que_no;
 	/* Send the command to the firmware */
 	wmb();
 }
@@ -3562,7 +3565,7 @@ qla2x00_mb_iocb(srb_t *sp, struct mbx_24xx_entry *mbx)
 	sz = min(ARRAY_SIZE(mbx->mb), ARRAY_SIZE(sp->u.iocb_cmd.u.mbx.out_mb));
 
 	for (i = 0; i < sz; i++)
-		mbx->mb[i] = cpu_to_le16(sp->u.iocb_cmd.u.mbx.out_mb[i]);
+		mbx->mb[i] = sp->u.iocb_cmd.u.mbx.out_mb[i];
 }
 
 static void
@@ -3586,7 +3589,7 @@ static void qla2x00_send_notify_ack_iocb(srb_t *sp,
 	nack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;
 	if (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {
 		nack->u.isp24.flags = ntfy->u.isp24.flags &
-			cpu_to_le32(NOTIFY24XX_FLAGS_PUREX_IOCB);
+			cpu_to_le16(NOTIFY24XX_FLAGS_PUREX_IOCB);
 	}
 	nack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;
 	nack->u.isp24.status = ntfy->u.isp24.status;
@@ -3613,20 +3616,20 @@ qla_nvme_ls(srb_t *sp, struct pt_ls4_request *cmd_pkt)
 	nvme = &sp->u.iocb_cmd;
 	cmd_pkt->entry_type = PT_LS4_REQUEST;
 	cmd_pkt->entry_count = 1;
-	cmd_pkt->control_flags = CF_LS4_ORIGINATOR << CF_LS4_SHIFT;
+	cmd_pkt->control_flags = cpu_to_le16(CF_LS4_ORIGINATOR << CF_LS4_SHIFT);
 
 	cmd_pkt->timeout = cpu_to_le16(nvme->u.nvme.timeout_sec);
 	cmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);
 	cmd_pkt->vp_index = sp->fcport->vha->vp_idx;
 
-	cmd_pkt->tx_dseg_count = 1;
-	cmd_pkt->tx_byte_count = nvme->u.nvme.cmd_len;
-	cmd_pkt->dsd[0].length = nvme->u.nvme.cmd_len;
+	cmd_pkt->tx_dseg_count = cpu_to_le16(1);
+	cmd_pkt->tx_byte_count = cpu_to_le32(nvme->u.nvme.cmd_len);
+	cmd_pkt->dsd[0].length = cpu_to_le32(nvme->u.nvme.cmd_len);
 	put_unaligned_le64(nvme->u.nvme.cmd_dma, &cmd_pkt->dsd[0].address);
 
-	cmd_pkt->rx_dseg_count = 1;
-	cmd_pkt->rx_byte_count = nvme->u.nvme.rsp_len;
-	cmd_pkt->dsd[1].length  = nvme->u.nvme.rsp_len;
+	cmd_pkt->rx_dseg_count = cpu_to_le16(1);
+	cmd_pkt->rx_byte_count = cpu_to_le32(nvme->u.nvme.rsp_len);
+	cmd_pkt->dsd[1].length = cpu_to_le32(nvme->u.nvme.rsp_len);
 	put_unaligned_le64(nvme->u.nvme.rsp_dma, &cmd_pkt->dsd[1].address);
 
 	return rval;
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
diff --git a/drivers/scsi/qla2xxx/qla_mr.c b/drivers/scsi/qla2xxx/qla_mr.c
index 05d3c1476667..1c22270814b3 100644
--- a/drivers/scsi/qla2xxx/qla_mr.c
+++ b/drivers/scsi/qla2xxx/qla_mr.c
@@ -3202,7 +3202,7 @@ qlafx00_tm_iocb(srb_t *sp, struct tsk_mgmt_entry_fx00 *ptm_iocb)
 	memset(&tm_iocb, 0, sizeof(struct tsk_mgmt_entry_fx00));
 	tm_iocb.entry_type = TSK_MGMT_IOCB_TYPE_FX00;
 	tm_iocb.entry_count = 1;
-	tm_iocb.handle = cpu_to_le32(make_handle(req->id, sp->handle));
+	tm_iocb.handle = make_handle(req->id, sp->handle);
 	tm_iocb.reserved_0 = 0;
 	tm_iocb.tgt_id = cpu_to_le16(sp->fcport->tgt_id);
 	tm_iocb.control_flags = cpu_to_le32(fxio->u.tmf.flags);
@@ -3228,9 +3228,8 @@ qlafx00_abort_iocb(srb_t *sp, struct abort_iocb_entry_fx00 *pabt_iocb)
 	memset(&abt_iocb, 0, sizeof(struct abort_iocb_entry_fx00));
 	abt_iocb.entry_type = ABORT_IOCB_TYPE_FX00;
 	abt_iocb.entry_count = 1;
-	abt_iocb.handle = cpu_to_le32(make_handle(req->id, sp->handle));
-	abt_iocb.abort_handle =
-	    cpu_to_le32(make_handle(req->id, fxio->u.abt.cmd_hndl));
+	abt_iocb.handle = make_handle(req->id, sp->handle);
+	abt_iocb.abort_handle = make_handle(req->id, fxio->u.abt.cmd_hndl);
 	abt_iocb.tgt_id_sts = cpu_to_le16(sp->fcport->tgt_id);
 	abt_iocb.req_que_no = cpu_to_le16(req->id);
 
@@ -3251,7 +3250,7 @@ qlafx00_fxdisc_iocb(srb_t *sp, struct fxdisc_entry_fx00 *pfxiocb)
 
 	memset(&fx_iocb, 0, sizeof(struct fxdisc_entry_fx00));
 	fx_iocb.entry_type = FX00_IOCB_TYPE;
-	fx_iocb.handle = cpu_to_le32(sp->handle);
+	fx_iocb.handle = sp->handle;
 	fx_iocb.entry_count = entry_cnt;
 
 	if (sp->type == SRB_FXIOCB_DCMD) {
diff --git a/drivers/scsi/qla2xxx/qla_nvme.c b/drivers/scsi/qla2xxx/qla_nvme.c
index b2be9c40e3cd..77d8d28fa969 100644
--- a/drivers/scsi/qla2xxx/qla_nvme.c
+++ b/drivers/scsi/qla2xxx/qla_nvme.c
@@ -138,7 +138,7 @@ static void qla_nvme_release_fcp_cmd_kref(struct kref *kref)
 	priv->sp = NULL;
 	sp->priv = NULL;
 	if (priv->comp_status == QLA_SUCCESS) {
-		fd->rcv_rsplen = nvme->u.nvme.rsp_pyld_len;
+		fd->rcv_rsplen = le16_to_cpu(nvme->u.nvme.rsp_pyld_len);
 	} else {
 		fd->rcv_rsplen = 0;
 		fd->transferred_length = 0;
@@ -426,11 +426,11 @@ static inline int qla2x00_start_nvme_mq(srb_t *sp)
 
 	/* No data transfer how do we check buffer len == 0?? */
 	if (fd->io_dir == NVMEFC_FCP_READ) {
-		cmd_pkt->control_flags = CF_READ_DATA;
+		cmd_pkt->control_flags = cpu_to_le16(CF_READ_DATA);
 		vha->qla_stats.input_bytes += fd->payload_length;
 		vha->qla_stats.input_requests++;
 	} else if (fd->io_dir == NVMEFC_FCP_WRITE) {
-		cmd_pkt->control_flags = CF_WRITE_DATA;
+		cmd_pkt->control_flags = cpu_to_le16(CF_WRITE_DATA);
 		if ((vha->flags.nvme_first_burst) &&
 		    (sp->fcport->nvme_prli_service_param &
 			NVME_PRLI_SP_FIRST_BURST)) {
@@ -438,7 +438,7 @@ static inline int qla2x00_start_nvme_mq(srb_t *sp)
 			    sp->fcport->nvme_first_burst_size) ||
 				(sp->fcport->nvme_first_burst_size == 0))
 				cmd_pkt->control_flags |=
-				    CF_NVME_FIRST_BURST_ENABLE;
+					cpu_to_le16(CF_NVME_FIRST_BURST_ENABLE);
 		}
 		vha->qla_stats.output_bytes += fd->payload_length;
 		vha->qla_stats.output_requests++;
diff --git a/drivers/scsi/qla2xxx/qla_nx.c b/drivers/scsi/qla2xxx/qla_nx.c
index 293dbde1d6e4..21f968e4a584 100644
--- a/drivers/scsi/qla2xxx/qla_nx.c
+++ b/drivers/scsi/qla2xxx/qla_nx.c
@@ -1561,14 +1561,14 @@ qla82xx_get_table_desc(const u8 *unirom, int section)
 	uint32_t i;
 	struct qla82xx_uri_table_desc *directory =
 		(struct qla82xx_uri_table_desc *)&unirom[0];
-	__le32 offset;
-	__le32 tab_type;
-	__le32 entries = cpu_to_le32(directory->num_entries);
+	uint32_t offset;
+	uint32_t tab_type;
+	uint32_t entries = le32_to_cpu(directory->num_entries);
 
 	for (i = 0; i < entries; i++) {
-		offset = cpu_to_le32(directory->findex) +
-		    (i * cpu_to_le32(directory->entry_size));
-		tab_type = cpu_to_le32(*((u32 *)&unirom[offset] + 8));
+		offset = le32_to_cpu(directory->findex) +
+		    (i * le32_to_cpu(directory->entry_size));
+		tab_type = get_unaligned_le32((u32 *)&unirom[offset] + 8);
 
 		if (tab_type == section)
 			return (struct qla82xx_uri_table_desc *)&unirom[offset];
@@ -1582,16 +1582,17 @@ qla82xx_get_data_desc(struct qla_hw_data *ha,
 	u32 section, u32 idx_offset)
 {
 	const u8 *unirom = ha->hablob->fw->data;
-	int idx = cpu_to_le32(*((int *)&unirom[ha->file_prd_off] + idx_offset));
+	int idx = get_unaligned_le32((u32 *)&unirom[ha->file_prd_off] +
+				     idx_offset);
 	struct qla82xx_uri_table_desc *tab_desc = NULL;
-	__le32 offset;
+	uint32_t offset;
 
 	tab_desc = qla82xx_get_table_desc(unirom, section);
 	if (!tab_desc)
 		return NULL;
 
-	offset = cpu_to_le32(tab_desc->findex) +
-	    (cpu_to_le32(tab_desc->entry_size) * idx);
+	offset = le32_to_cpu(tab_desc->findex) +
+	    (le32_to_cpu(tab_desc->entry_size) * idx);
 
 	return (struct qla82xx_uri_data_desc *)&unirom[offset];
 }
@@ -1606,7 +1607,7 @@ qla82xx_get_bootld_offset(struct qla_hw_data *ha)
 		uri_desc = qla82xx_get_data_desc(ha,
 		    QLA82XX_URI_DIR_SECT_BOOTLD, QLA82XX_URI_BOOTLD_IDX_OFF);
 		if (uri_desc)
-			offset = cpu_to_le32(uri_desc->findex);
+			offset = le32_to_cpu(uri_desc->findex);
 	}
 
 	return (u8 *)&ha->hablob->fw->data[offset];
@@ -1620,7 +1621,7 @@ static u32 qla82xx_get_fw_size(struct qla_hw_data *ha)
 		uri_desc =  qla82xx_get_data_desc(ha, QLA82XX_URI_DIR_SECT_FW,
 		    QLA82XX_URI_FIRMWARE_IDX_OFF);
 		if (uri_desc)
-			return cpu_to_le32(uri_desc->size);
+			return le32_to_cpu(uri_desc->size);
 	}
 
 	return get_unaligned_le32(&ha->hablob->fw->data[FW_SIZE_OFFSET]);
@@ -1636,7 +1637,7 @@ qla82xx_get_fw_offs(struct qla_hw_data *ha)
 		uri_desc = qla82xx_get_data_desc(ha, QLA82XX_URI_DIR_SECT_FW,
 			QLA82XX_URI_FIRMWARE_IDX_OFF);
 		if (uri_desc)
-			offset = cpu_to_le32(uri_desc->findex);
+			offset = le32_to_cpu(uri_desc->findex);
 	}
 
 	return (u8 *)&ha->hablob->fw->data[offset];
@@ -1847,8 +1848,8 @@ qla82xx_set_product_offset(struct qla_hw_data *ha)
 	struct qla82xx_uri_table_desc *ptab_desc = NULL;
 	const uint8_t *unirom = ha->hablob->fw->data;
 	uint32_t i;
-	__le32 entries;
-	__le32 flags, file_chiprev, offset;
+	uint32_t entries;
+	uint32_t flags, file_chiprev, offset;
 	uint8_t chiprev = ha->chip_revision;
 	/* Hardcoding mn_present flag for P3P */
 	int mn_present = 0;
@@ -1859,14 +1860,14 @@ qla82xx_set_product_offset(struct qla_hw_data *ha)
 	if (!ptab_desc)
 		return -1;
 
-	entries = cpu_to_le32(ptab_desc->num_entries);
+	entries = le32_to_cpu(ptab_desc->num_entries);
 
 	for (i = 0; i < entries; i++) {
-		offset = cpu_to_le32(ptab_desc->findex) +
-			(i * cpu_to_le32(ptab_desc->entry_size));
-		flags = cpu_to_le32(*((int *)&unirom[offset] +
+		offset = le32_to_cpu(ptab_desc->findex) +
+			(i * le32_to_cpu(ptab_desc->entry_size));
+		flags = le32_to_cpu(*((__le32 *)&unirom[offset] +
 			QLA82XX_URI_FLAGS_OFF));
-		file_chiprev = cpu_to_le32(*((int *)&unirom[offset] +
+		file_chiprev = le32_to_cpu(*((__le32 *)&unirom[offset] +
 			QLA82XX_URI_CHIP_REV_OFF));
 
 		flagbit = mn_present ? 1 : 2;
@@ -2549,8 +2550,8 @@ qla82xx_start_firmware(scsi_qla_host_t *vha)
 	return qla82xx_check_rcvpeg_state(ha);
 }
 
-static uint32_t *
-qla82xx_read_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,
+static __le32 *
+qla82xx_read_flash_data(scsi_qla_host_t *vha, __le32 *dwptr, uint32_t faddr,
 	uint32_t length)
 {
 	uint32_t i;
@@ -2675,13 +2676,13 @@ qla82xx_read_optrom_data(struct scsi_qla_host *vha, void *buf,
 	uint32_t offset, uint32_t length)
 {
 	scsi_block_requests(vha->host);
-	qla82xx_read_flash_data(vha, (uint32_t *)buf, offset, length);
+	qla82xx_read_flash_data(vha, buf, offset, length);
 	scsi_unblock_requests(vha->host);
 	return buf;
 }
 
 static int
-qla82xx_write_flash_data(struct scsi_qla_host *vha, uint32_t *dwptr,
+qla82xx_write_flash_data(struct scsi_qla_host *vha, __le32 *dwptr,
 	uint32_t faddr, uint32_t dwords)
 {
 	int ret;
@@ -2758,7 +2759,7 @@ qla82xx_write_flash_data(struct scsi_qla_host *vha, uint32_t *dwptr,
 		}
 
 		ret = qla82xx_write_flash_dword(ha, faddr,
-		    cpu_to_le32(*dwptr));
+						le32_to_cpu(*dwptr));
 		if (ret) {
 			ql_dbg(ql_dbg_p3p, vha, 0xb020,
 			    "Unable to program flash address=%x data=%x.\n",
@@ -3724,7 +3725,7 @@ qla82xx_chip_reset_cleanup(scsi_qla_host_t *vha)
 /* Minidump related functions */
 static int
 qla82xx_minidump_process_control(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	struct qla82xx_md_entry_crb *crb_entry;
@@ -3841,12 +3842,12 @@ qla82xx_minidump_process_control(scsi_qla_host_t *vha,
 
 static void
 qla82xx_minidump_process_rdocm(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t r_addr, r_stride, loop_cnt, i, r_value;
 	struct qla82xx_md_entry_rdocm *ocm_hdr;
-	uint32_t *data_ptr = *d_ptr;
+	__le32 *data_ptr = *d_ptr;
 
 	ocm_hdr = (struct qla82xx_md_entry_rdocm *)entry_hdr;
 	r_addr = ocm_hdr->read_addr;
@@ -3863,12 +3864,12 @@ qla82xx_minidump_process_rdocm(scsi_qla_host_t *vha,
 
 static void
 qla82xx_minidump_process_rdmux(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t r_addr, s_stride, s_addr, s_value, loop_cnt, i, r_value;
 	struct qla82xx_md_entry_mux *mux_hdr;
-	uint32_t *data_ptr = *d_ptr;
+	__le32 *data_ptr = *d_ptr;
 
 	mux_hdr = (struct qla82xx_md_entry_mux *)entry_hdr;
 	r_addr = mux_hdr->read_addr;
@@ -3889,12 +3890,12 @@ qla82xx_minidump_process_rdmux(scsi_qla_host_t *vha,
 
 static void
 qla82xx_minidump_process_rdcrb(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t r_addr, r_stride, loop_cnt, i, r_value;
 	struct qla82xx_md_entry_crb *crb_hdr;
-	uint32_t *data_ptr = *d_ptr;
+	__le32 *data_ptr = *d_ptr;
 
 	crb_hdr = (struct qla82xx_md_entry_crb *)entry_hdr;
 	r_addr = crb_hdr->addr;
@@ -3912,7 +3913,7 @@ qla82xx_minidump_process_rdcrb(scsi_qla_host_t *vha,
 
 static int
 qla82xx_minidump_process_l2tag(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t addr, r_addr, c_addr, t_r_addr;
@@ -3921,7 +3922,7 @@ qla82xx_minidump_process_l2tag(scsi_qla_host_t *vha,
 	uint32_t c_value_w, c_value_r;
 	struct qla82xx_md_entry_cache *cache_hdr;
 	int rval = QLA_FUNCTION_FAILED;
-	uint32_t *data_ptr = *d_ptr;
+	__le32 *data_ptr = *d_ptr;
 
 	cache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;
 	loop_count = cache_hdr->op_count;
@@ -3971,14 +3972,14 @@ qla82xx_minidump_process_l2tag(scsi_qla_host_t *vha,
 
 static void
 qla82xx_minidump_process_l1cache(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t addr, r_addr, c_addr, t_r_addr;
 	uint32_t i, k, loop_count, t_value, r_cnt, r_value;
 	uint32_t c_value_w;
 	struct qla82xx_md_entry_cache *cache_hdr;
-	uint32_t *data_ptr = *d_ptr;
+	__le32 *data_ptr = *d_ptr;
 
 	cache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;
 	loop_count = cache_hdr->op_count;
@@ -4006,14 +4007,14 @@ qla82xx_minidump_process_l1cache(scsi_qla_host_t *vha,
 
 static void
 qla82xx_minidump_process_queue(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t s_addr, r_addr;
 	uint32_t r_stride, r_value, r_cnt, qid = 0;
 	uint32_t i, k, loop_cnt;
 	struct qla82xx_md_entry_queue *q_hdr;
-	uint32_t *data_ptr = *d_ptr;
+	__le32 *data_ptr = *d_ptr;
 
 	q_hdr = (struct qla82xx_md_entry_queue *)entry_hdr;
 	s_addr = q_hdr->select_addr;
@@ -4036,13 +4037,13 @@ qla82xx_minidump_process_queue(scsi_qla_host_t *vha,
 
 static void
 qla82xx_minidump_process_rdrom(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t r_addr, r_value;
 	uint32_t i, loop_cnt;
 	struct qla82xx_md_entry_rdrom *rom_hdr;
-	uint32_t *data_ptr = *d_ptr;
+	__le32 *data_ptr = *d_ptr;
 
 	rom_hdr = (struct qla82xx_md_entry_rdrom *)entry_hdr;
 	r_addr = rom_hdr->read_addr;
@@ -4062,7 +4063,7 @@ qla82xx_minidump_process_rdrom(scsi_qla_host_t *vha,
 
 static int
 qla82xx_minidump_process_rdmem(scsi_qla_host_t *vha,
-	qla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)
+	qla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)
 {
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t r_addr, r_value, r_data;
@@ -4070,7 +4071,7 @@ qla82xx_minidump_process_rdmem(scsi_qla_host_t *vha,
 	struct qla82xx_md_entry_rdmem *m_hdr;
 	unsigned long flags;
 	int rval = QLA_FUNCTION_FAILED;
-	uint32_t *data_ptr = *d_ptr;
+	__le32 *data_ptr = *d_ptr;
 
 	m_hdr = (struct qla82xx_md_entry_rdmem *)entry_hdr;
 	r_addr = m_hdr->read_addr;
@@ -4163,12 +4164,12 @@ qla82xx_md_collect(scsi_qla_host_t *vha)
 	int no_entry_hdr = 0;
 	qla82xx_md_entry_hdr_t *entry_hdr;
 	struct qla82xx_md_template_hdr *tmplt_hdr;
-	uint32_t *data_ptr;
+	__le32 *data_ptr;
 	uint32_t total_data_size = 0, f_capture_mask, data_collected = 0;
 	int i = 0, rval = QLA_FUNCTION_FAILED;
 
 	tmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;
-	data_ptr = (uint32_t *)ha->md_dump;
+	data_ptr = ha->md_dump;
 
 	if (ha->fw_dumped) {
 		ql_log(ql_log_warn, vha, 0xb037,
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_sup.c
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 49d1dd91b744..57d726bfe193 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -389,7 +389,7 @@ static bool qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,
 		qlt_issue_marker(vha, ha_locked);
 
 		if ((entry->u.isp24.vp_index != 0xFF) &&
-		    (entry->u.isp24.nport_handle != 0xFFFF)) {
+		    (entry->u.isp24.nport_handle != cpu_to_le16(0xFFFF))) {
 			host = qlt_find_host_by_vp_idx(vha,
 			    entry->u.isp24.vp_index);
 			if (unlikely(!host)) {
@@ -1708,7 +1708,7 @@ static void qlt_send_notify_ack(struct qla_qpair *qpair,
 	nack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;
 	if (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {
 		nack->u.isp24.flags = ntfy->u.isp24.flags &
-			cpu_to_le32(NOTIFY24XX_FLAGS_PUREX_IOCB);
+			cpu_to_le16(NOTIFY24XX_FLAGS_PUREX_IOCB);
 	}
 	nack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;
 	nack->u.isp24.status = ntfy->u.isp24.status;
@@ -1736,7 +1736,8 @@ static int qlt_build_abts_resp_iocb(struct qla_tgt_mgmt_cmd *mcmd)
 	struct scsi_qla_host *vha = mcmd->vha;
 	struct qla_hw_data *ha = vha->hw;
 	struct abts_resp_to_24xx *resp;
-	uint32_t f_ctl, h;
+	__le32 f_ctl;
+	uint32_t h;
 	uint8_t *p;
 	int rc;
 	struct abts_recv_from_24xx *abts = &mcmd->orig_iocb.abts;
@@ -1793,7 +1794,7 @@ static int qlt_build_abts_resp_iocb(struct qla_tgt_mgmt_cmd *mcmd)
 		resp->fcp_hdr_le.r_ctl = R_CTL_BASIC_LINK_SERV | R_CTL_B_ACC;
 		resp->payload.ba_acct.seq_id_valid = SEQ_ID_INVALID;
 		resp->payload.ba_acct.low_seq_cnt = 0x0000;
-		resp->payload.ba_acct.high_seq_cnt = 0xFFFF;
+		resp->payload.ba_acct.high_seq_cnt = cpu_to_le16(0xFFFF);
 		resp->payload.ba_acct.ox_id = abts->fcp_hdr_le.ox_id;
 		resp->payload.ba_acct.rx_id = abts->fcp_hdr_le.rx_id;
 	} else {
@@ -1825,7 +1826,7 @@ static void qlt_24xx_send_abts_resp(struct qla_qpair *qpair,
 	struct scsi_qla_host *vha = qpair->vha;
 	struct qla_hw_data *ha = vha->hw;
 	struct abts_resp_to_24xx *resp;
-	uint32_t f_ctl;
+	__le32 f_ctl;
 	uint8_t *p;
 
 	ql_dbg(ql_dbg_tgt, vha, 0xe006,
@@ -1868,7 +1869,7 @@ static void qlt_24xx_send_abts_resp(struct qla_qpair *qpair,
 		resp->fcp_hdr_le.r_ctl = R_CTL_BASIC_LINK_SERV | R_CTL_B_ACC;
 		resp->payload.ba_acct.seq_id_valid = SEQ_ID_INVALID;
 		resp->payload.ba_acct.low_seq_cnt = 0x0000;
-		resp->payload.ba_acct.high_seq_cnt = 0xFFFF;
+		resp->payload.ba_acct.high_seq_cnt = cpu_to_le16(0xFFFF);
 		resp->payload.ba_acct.ox_id = abts->fcp_hdr_le.ox_id;
 		resp->payload.ba_acct.rx_id = abts->fcp_hdr_le.rx_id;
 	} else {
@@ -2041,7 +2042,7 @@ static void qlt_do_tmr_work(struct work_struct *work)
 
 	switch (mcmd->tmr_func) {
 	case QLA_TGT_ABTS:
-		tag = mcmd->orig_iocb.abts.exchange_addr_to_abort;
+		tag = le32_to_cpu(mcmd->orig_iocb.abts.exchange_addr_to_abort);
 		break;
 	default:
 		tag = 0;
@@ -2121,7 +2122,7 @@ static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,
 		struct qla_tgt_cmd *abort_cmd;
 
 		abort_cmd = ha->tgt.tgt_ops->find_cmd_by_tag(sess,
-		    abts->exchange_addr_to_abort);
+				le32_to_cpu(abts->exchange_addr_to_abort));
 		if (abort_cmd && abort_cmd->qpair) {
 			mcmd->qpair = abort_cmd->qpair;
 			mcmd->se_cmd.cpuid = abort_cmd->se_cmd.cpuid;
@@ -2144,7 +2145,7 @@ static void qlt_24xx_handle_abts(struct scsi_qla_host *vha,
 {
 	struct qla_hw_data *ha = vha->hw;
 	struct fc_port *sess;
-	uint32_t tag = abts->exchange_addr_to_abort;
+	uint32_t tag = le32_to_cpu(abts->exchange_addr_to_abort);
 	be_id_t s_id;
 	int rc;
 	unsigned long flags;
@@ -2234,7 +2235,7 @@ static void qlt_24xx_send_task_mgmt_ctio(struct qla_qpair *qpair,
 	ctio->entry_type = CTIO_TYPE7;
 	ctio->entry_count = 1;
 	ctio->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;
-	ctio->nport_handle = mcmd->sess->loop_id;
+	ctio->nport_handle = cpu_to_le16(mcmd->sess->loop_id);
 	ctio->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
 	ctio->vp_index = ha->vp_idx;
 	ctio->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);
@@ -2291,7 +2292,7 @@ void qlt_send_resp_ctio(struct qla_qpair *qpair, struct qla_tgt_cmd *cmd,
 	ctio->entry_type = CTIO_TYPE7;
 	ctio->entry_count = 1;
 	ctio->handle = QLA_TGT_SKIP_HANDLE;
-	ctio->nport_handle = cmd->sess->loop_id;
+	ctio->nport_handle = cpu_to_le16(cmd->sess->loop_id);
 	ctio->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
 	ctio->vp_index = vha->vp_idx;
 	ctio->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);
@@ -2851,10 +2852,14 @@ static void qlt_24xx_init_ctio_to_isp(struct ctio7_to_24xx *ctio,
 		    cpu_to_le16(SS_SENSE_LEN_VALID);
 		ctio->u.status1.sense_length =
 		    cpu_to_le16(prm->sense_buffer_len);
-		for (i = 0; i < prm->sense_buffer_len/4; i++)
-			((uint32_t *)ctio->u.status1.sense_data)[i] =
-				cpu_to_be32(((uint32_t *)prm->sense_buffer)[i]);
+		for (i = 0; i < prm->sense_buffer_len/4; i++) {
+			uint32_t v;
 
+			v = get_unaligned_be32(
+					&((uint32_t *)prm->sense_buffer)[i]);
+			put_unaligned_le32(v,
+				&((uint32_t *)ctio->u.status1.sense_data)[i]);
+		}
 		qlt_print_dif_err(prm);
 
 	} else {
@@ -3125,7 +3130,7 @@ qlt_build_ctio_crc2_pkt(struct qla_qpair *qpair, struct qla_tgt_prm *prm)
 	else if (cmd->dma_data_direction == DMA_FROM_DEVICE)
 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_OUT);
 
-	pkt->dseg_count = prm->tot_dsds;
+	pkt->dseg_count = cpu_to_le16(prm->tot_dsds);
 	/* Fibre channel byte count */
 	pkt->transfer_length = cpu_to_le32(transfer_length);
 
@@ -3147,7 +3152,7 @@ qlt_build_ctio_crc2_pkt(struct qla_qpair *qpair, struct qla_tgt_prm *prm)
 	qla_tgt_set_dif_tags(cmd, crc_ctx_pkt, &fw_prot_opts);
 
 	put_unaligned_le64(crc_ctx_dma, &pkt->crc_context_address);
-	pkt->crc_context_len = CRC_CONTEXT_LEN_FW;
+	pkt->crc_context_len = cpu_to_le16(CRC_CONTEXT_LEN_FW);
 
 	if (!bundling) {
 		cur_dsd = &crc_ctx_pkt->u.nobundling.data_dsd[0];
@@ -3584,7 +3589,7 @@ static int __qlt_send_term_imm_notif(struct scsi_qla_host *vha,
 	nack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;
 	if (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {
 		nack->u.isp24.flags = ntfy->u.isp24.flags &
-			__constant_cpu_to_le32(NOTIFY24XX_FLAGS_PUREX_IOCB);
+			cpu_to_le16(NOTIFY24XX_FLAGS_PUREX_IOCB);
 	}
 
 	/* terminate */
@@ -3658,7 +3663,7 @@ static int __qlt_send_term_exchange(struct qla_qpair *qpair,
 
 	ctio24 = (struct ctio7_to_24xx *)pkt;
 	ctio24->entry_type = CTIO_TYPE7;
-	ctio24->nport_handle = CTIO7_NHANDLE_UNRECOGNIZED;
+	ctio24->nport_handle = cpu_to_le16(CTIO7_NHANDLE_UNRECOGNIZED);
 	ctio24->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
 	ctio24->vp_index = vha->vp_idx;
 	ctio24->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);
@@ -4121,7 +4126,7 @@ static void __qlt_do_work(struct qla_tgt_cmd *cmd)
 
 	spin_lock_init(&cmd->cmd_lock);
 	cdb = &atio->u.isp24.fcp_cmnd.cdb[0];
-	cmd->se_cmd.tag = atio->u.isp24.exchange_addr;
+	cmd->se_cmd.tag = le32_to_cpu(atio->u.isp24.exchange_addr);
 
 	if (atio->u.isp24.fcp_cmnd.rddata &&
 	    atio->u.isp24.fcp_cmnd.wrdata) {
@@ -5319,7 +5324,7 @@ static int __qlt_send_busy(struct qla_qpair *qpair,
 
 	ctio24 = (struct ctio7_to_24xx *)pkt;
 	ctio24->entry_type = CTIO_TYPE7;
-	ctio24->nport_handle = sess->loop_id;
+	ctio24->nport_handle = cpu_to_le16(sess->loop_id);
 	ctio24->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
 	ctio24->vp_index = vha->vp_idx;
 	ctio24->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);
@@ -5332,13 +5337,14 @@ static int __qlt_send_busy(struct qla_qpair *qpair,
 	 * CTIO from fw w/o se_cmd doesn't provide enough info to retry it,
 	 * if the explicit conformation is used.
 	 */
-	ctio24->u.status1.ox_id = swab16(atio->u.isp24.fcp_hdr.ox_id);
+	ctio24->u.status1.ox_id =
+		cpu_to_le16(be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));
 	ctio24->u.status1.scsi_status = cpu_to_le16(status);
 
-	ctio24->u.status1.residual = get_datalen_for_atio(atio);
+	ctio24->u.status1.residual = cpu_to_le32(get_datalen_for_atio(atio));
 
 	if (ctio24->u.status1.residual != 0)
-		ctio24->u.status1.scsi_status |= SS_RESIDUAL_UNDER;
+		ctio24->u.status1.scsi_status |= cpu_to_le16(SS_RESIDUAL_UNDER);
 
 	/* Memory Barrier */
 	wmb();
@@ -5575,7 +5581,7 @@ static void qlt_24xx_atio_pkt(struct scsi_qla_host *vha,
 	switch (atio->u.raw.entry_type) {
 	case ATIO_TYPE7:
 		if (unlikely(atio->u.isp24.exchange_addr ==
-		    ATIO_EXCHANGE_ADDRESS_UNKNOWN)) {
+			     cpu_to_le32(ATIO_EXCHANGE_ADDRESS_UNKNOWN))) {
 			ql_dbg(ql_dbg_io, vha, 0x3065,
 			    "qla_target(%d): ATIO_TYPE7 "
 			    "received with UNKNOWN exchange address, "
@@ -5738,8 +5744,8 @@ static void qlt_handle_abts_completion(struct scsi_qla_host *vha,
 	    entry->compl_status);
 
 	if (le16_to_cpu(entry->compl_status) != ABTS_RESP_COMPL_SUCCESS) {
-		if ((entry->error_subcode1 == 0x1E) &&
-		    (entry->error_subcode2 == 0)) {
+		if (le32_to_cpu(entry->error_subcode1) == 0x1E &&
+		    le32_to_cpu(entry->error_subcode2) == 0) {
 			if (qlt_chk_unresolv_exchg(vha, rsp->qpair, entry)) {
 				ha->tgt.tgt_ops->free_mcmd(mcmd);
 				return;
@@ -5953,8 +5959,7 @@ void qlt_async_event(uint16_t code, struct scsi_qla_host *vha,
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf03b,
 		    "qla_target(%d): Async LOOP_UP occurred "
 		    "(m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)", vha->vp_idx,
-		    le16_to_cpu(mailbox[0]), le16_to_cpu(mailbox[1]),
-		    le16_to_cpu(mailbox[2]), le16_to_cpu(mailbox[3]));
+		    mailbox[0], mailbox[1], mailbox[2], mailbox[3]);
 		if (tgt->link_reinit_iocb_pending) {
 			qlt_send_notify_ack(ha->base_qpair,
 			    (void *)&tgt->link_reinit_iocb,
@@ -5971,18 +5976,16 @@ void qlt_async_event(uint16_t code, struct scsi_qla_host *vha,
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf03c,
 		    "qla_target(%d): Async event %#x occurred "
 		    "(m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)", vha->vp_idx, code,
-		    le16_to_cpu(mailbox[0]), le16_to_cpu(mailbox[1]),
-		    le16_to_cpu(mailbox[2]), le16_to_cpu(mailbox[3]));
+		    mailbox[0], mailbox[1], mailbox[2], mailbox[3]);
 		break;
 
 	case MBA_REJECTED_FCP_CMD:
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf017,
 		    "qla_target(%d): Async event LS_REJECT occurred (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)",
 		    vha->vp_idx,
-		    le16_to_cpu(mailbox[0]), le16_to_cpu(mailbox[1]),
-		    le16_to_cpu(mailbox[2]), le16_to_cpu(mailbox[3]));
+		    mailbox[0], mailbox[1], mailbox[2], mailbox[3]);
 
-		if (le16_to_cpu(mailbox[3]) == 1) {
+		if (mailbox[3] == 1) {
 			/* exchange starvation. */
 			vha->hw->exch_starvation++;
 			if (vha->hw->exch_starvation > 5) {
@@ -6006,10 +6009,9 @@ void qlt_async_event(uint16_t code, struct scsi_qla_host *vha,
 		    "qla_target(%d): Port update async event %#x "
 		    "occurred: updating the ports database (m[0]=%x, m[1]=%x, "
 		    "m[2]=%x, m[3]=%x)", vha->vp_idx, code,
-		    le16_to_cpu(mailbox[0]), le16_to_cpu(mailbox[1]),
-		    le16_to_cpu(mailbox[2]), le16_to_cpu(mailbox[3]));
+		    mailbox[0], mailbox[1], mailbox[2], mailbox[3]);
 
-		login_code = le16_to_cpu(mailbox[2]);
+		login_code = mailbox[2];
 		if (login_code == 0x4) {
 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf03e,
 			    "Async MB 2: Got PLOGI Complete\n");
@@ -6759,7 +6761,7 @@ qlt_init_atio_q_entries(struct scsi_qla_host *vha)
 		return;
 
 	for (cnt = 0; cnt < ha->tgt.atio_q_length; cnt++) {
-		pkt->u.raw.signature = ATIO_PROCESSED;
+		pkt->u.raw.signature = cpu_to_le32(ATIO_PROCESSED);
 		pkt++;
 	}
 
@@ -6794,7 +6796,7 @@ qlt_24xx_process_atio_queue(struct scsi_qla_host *vha, uint8_t ha_locked)
 			    "corrupted fcp frame SID[%3phN] OXID[%04x] EXCG[%x] %64phN\n",
 			    &pkt->u.isp24.fcp_hdr.s_id,
 			    be16_to_cpu(pkt->u.isp24.fcp_hdr.ox_id),
-			    le32_to_cpu(pkt->u.isp24.exchange_addr), pkt);
+			    pkt->u.isp24.exchange_addr, pkt);
 
 			adjust_corrupted_atio(pkt);
 			qlt_send_term_exchange(ha->base_qpair, NULL, pkt,
@@ -6812,7 +6814,7 @@ qlt_24xx_process_atio_queue(struct scsi_qla_host *vha, uint8_t ha_locked)
 			} else
 				ha->tgt.atio_ring_ptr++;
 
-			pkt->u.raw.signature = ATIO_PROCESSED;
+			pkt->u.raw.signature = cpu_to_le32(ATIO_PROCESSED);
 			pkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;
 		}
 		wmb();
@@ -6841,10 +6843,10 @@ qlt_24xx_config_rings(struct scsi_qla_host *vha)
 			if (IS_QLA2071(ha)) {
 				/* 4 ports Baker: Enable Interrupt Handshake */
 				icb->msix_atio = 0;
-				icb->firmware_options_2 |= BIT_26;
+				icb->firmware_options_2 |= cpu_to_le32(BIT_26);
 			} else {
 				icb->msix_atio = cpu_to_le16(msix->entry);
-				icb->firmware_options_2 &= ~BIT_26;
+				icb->firmware_options_2 &= cpu_to_le32(~BIT_26);
 			}
 			ql_dbg(ql_dbg_init, vha, 0xf072,
 			    "Registering ICB vector 0x%x for atio que.\n",
@@ -6854,7 +6856,7 @@ qlt_24xx_config_rings(struct scsi_qla_host *vha)
 		/* INTx|MSI */
 		if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
 			icb->msix_atio = 0;
-			icb->firmware_options_2 |= BIT_26;
+			icb->firmware_options_2 |= cpu_to_le32(BIT_26);
 			ql_dbg(ql_dbg_init, vha, 0xf072,
 			    "%s: Use INTx for ATIOQ.\n", __func__);
 		}
diff --git a/drivers/scsi/qla2xxx/qla_tmpl.c b/drivers/scsi/qla2xxx/qla_tmpl.c
index f05a4fa2b9d7..8dc82cfd38b2 100644
--- a/drivers/scsi/qla2xxx/qla_tmpl.c
+++ b/drivers/scsi/qla2xxx/qla_tmpl.c
@@ -919,9 +919,9 @@ static void
 qla27xx_firmware_info(struct scsi_qla_host *vha,
     struct qla27xx_fwdt_template *tmp)
 {
-	tmp->firmware_version[0] = vha->hw->fw_major_version;
-	tmp->firmware_version[1] = vha->hw->fw_minor_version;
-	tmp->firmware_version[2] = vha->hw->fw_subminor_version;
+	tmp->firmware_version[0] = cpu_to_le32(vha->hw->fw_major_version);
+	tmp->firmware_version[1] = cpu_to_le32(vha->hw->fw_minor_version);
+	tmp->firmware_version[2] = cpu_to_le32(vha->hw->fw_subminor_version);
 	tmp->firmware_version[3] = cpu_to_le32(
 		vha->hw->fw_attributes_h << 16 | vha->hw->fw_attributes);
 	tmp->firmware_version[4] = cpu_to_le32(
