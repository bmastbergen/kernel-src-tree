mm/sparse.c: do not waste pre allocated memmap space

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michal Hocko <mhocko@suse.com>
commit 09dbcf422e9b791d2d43cad8c283d9bdaef019a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/09dbcf42.failed

Vincent has noticed [1] that there is something unusual with the memmap
allocations going on on his platform

: I noticed this because on my ARM64 platform, with 1 GiB of memory the
: first [and only] section is allocated from the zeroing path while with
: 2 GiB of memory the first 1 GiB section is allocated from the
: non-zeroing path.

The underlying problem is that although sparse_buffer_init allocates
enough memory for all sections on the node sparse_buffer_alloc is not
able to consume them due to mismatch in the expected allocation
alignement.  While sparse_buffer_init preallocation uses the PAGE_SIZE
alignment the real memmap has to be aligned to section_map_size() this
results in a wasted initial chunk of the preallocated memmap and
unnecessary fallback allocation for a section.

While we are at it also change __populate_section_memmap to align to the
requested size because at least VMEMMAP has constrains to have memmap
properly aligned.

[1] http://lkml.kernel.org/r/20191030131122.8256-1-vincent.whitchurch@axis.com

[akpm@linux-foundation.org: tweak layout, per David]
Link: http://lkml.kernel.org/r/20191119092642.31799-1-mhocko@kernel.org
Fixes: 35fd1eb1e821 ("mm/sparse: abstract sparse buffer allocations")
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Reported-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
	Debugged-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
	Acked-by: David Hildenbrand <david@redhat.com>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Oscar Salvador <OSalvador@suse.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 09dbcf422e9b791d2d43cad8c283d9bdaef019a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/sparse.c
diff --cc mm/sparse.c
index 2b18ff252bdb,8526d3bf1e4e..000000000000
--- a/mm/sparse.c
+++ b/mm/sparse.c
@@@ -424,9 -458,12 +424,13 @@@ struct page __init *__populate_section_
  	if (map)
  		return map;
  
++<<<<<<< HEAD
 +	map = memblock_alloc_try_nid(size,
 +					  PAGE_SIZE, __pa(MAX_DMA_ADDRESS),
++=======
+ 	map = memblock_alloc_try_nid_raw(size, size, addr,
++>>>>>>> 09dbcf422e9b (mm/sparse.c: do not waste pre allocated memmap space)
  					  MEMBLOCK_ALLOC_ACCESSIBLE, nid);
 -	if (!map)
 -		panic("%s: Failed to allocate %lu bytes align=0x%lx nid=%d from=%pa\n",
 -		      __func__, size, PAGE_SIZE, nid, &addr);
 -
  	return map;
  }
  #endif /* !CONFIG_SPARSEMEM_VMEMMAP */
@@@ -434,13 -471,23 +438,23 @@@
  static void *sparsemap_buf __meminitdata;
  static void *sparsemap_buf_end __meminitdata;
  
 -static inline void __meminit sparse_buffer_free(unsigned long size)
 -{
 -	WARN_ON(!sparsemap_buf || size == 0);
 -	memblock_free_early(__pa(sparsemap_buf), size);
 -}
 -
  static void __init sparse_buffer_init(unsigned long size, int nid)
  {
 -	phys_addr_t addr = __pa(MAX_DMA_ADDRESS);
  	WARN_ON(sparsemap_buf);	/* forgot to call sparse_buffer_fini()? */
++<<<<<<< HEAD
 +	sparsemap_buf =
 +		memblock_alloc_try_nid_raw(size, PAGE_SIZE,
 +						__pa(MAX_DMA_ADDRESS),
 +						MEMBLOCK_ALLOC_ACCESSIBLE, nid);
++=======
+ 	/*
+ 	 * Pre-allocated buffer is mainly used by __populate_section_memmap
+ 	 * and we want it to be properly aligned to the section size - this is
+ 	 * especially the case for VMEMMAP which maps memmap to PMDs
+ 	 */
+ 	sparsemap_buf = memblock_alloc_try_nid_raw(size, section_map_size(),
+ 					addr, MEMBLOCK_ALLOC_ACCESSIBLE, nid);
++>>>>>>> 09dbcf422e9b (mm/sparse.c: do not waste pre allocated memmap space)
  	sparsemap_buf_end = sparsemap_buf + size;
  }
  
* Unmerged path mm/sparse.c
