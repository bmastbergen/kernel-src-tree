dm table: make 'struct dm_table' definition accessible to all of DM core

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mike Snitzer <snitzer@redhat.com>
commit 33bd6f0693857492ab19869d79801437ac1e42ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/33bd6f06.failed

Move 'struct dm_table' definition from dm-table.c to dm-core.h and
update DM core to access its members directly.

Helps optimize max_io_len() and other methods slightly.

	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 33bd6f0693857492ab19869d79801437ac1e42ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-table.c
#	drivers/md/dm.c
diff --cc drivers/md/dm-table.c
index e91fcab49cf0,3ad22adf322d..000000000000
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@@ -30,45 -29,6 +29,48 @@@
  #define KEYS_PER_NODE (NODE_SIZE / sizeof(sector_t))
  #define CHILDREN_PER_NODE (KEYS_PER_NODE + 1)
  
++<<<<<<< HEAD
 +struct dm_table {
 +	struct mapped_device *md;
 +	enum dm_queue_mode type;
 +
 +	/* btree table */
 +	unsigned int depth;
 +	unsigned int counts[MAX_DEPTH];	/* in nodes */
 +	sector_t *index[MAX_DEPTH];
 +
 +	unsigned int num_targets;
 +	unsigned int num_allocated;
 +	sector_t *highs;
 +	struct dm_target *targets;
 +
 +	struct target_type *immutable_target_type;
 +
 +	bool integrity_supported:1;
 +	bool singleton:1;
 +	unsigned integrity_added:1;
 +
 +	/*
 +	 * Indicates the rw permissions for the new logical
 +	 * device.  This should be a combination of FMODE_READ
 +	 * and FMODE_WRITE.
 +	 */
 +	fmode_t mode;
 +
 +	/* a list of devices used by this table */
 +	struct list_head devices;
 +
 +	/* events get handed up using this callback */
 +	void (*event_fn)(void *);
 +	void *event_context;
 +
 +	struct dm_md_mempools *mempools;
 +
 +	struct list_head target_callbacks;
 +};
 +
++=======
++>>>>>>> 33bd6f069385 (dm table: make 'struct dm_table' definition accessible to all of DM core)
  /*
   * Similar to ceiling(log_size(n))
   */
diff --cc drivers/md/dm.c
index de413f6656b0,a1adcf0ab821..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1047,8 -1042,8 +1032,13 @@@ static sector_t max_io_len(sector_t sec
  	 *   blk_max_size_offset() provides required splitting.
  	 * - blk_max_size_offset() also respects q->limits.max_sectors
  	 */
++<<<<<<< HEAD
 +	max_len = blk_max_size_offset(dm_table_get_md(ti->table)->queue,
 +				      dm_target_offset(ti, sector));
++=======
+ 	max_len = blk_max_size_offset(ti->table->md->queue,
+ 				      target_offset);
++>>>>>>> 33bd6f069385 (dm table: make 'struct dm_table' definition accessible to all of DM core)
  	if (len > max_len)
  		len = max_len;
  
diff --git a/drivers/md/dm-core.h b/drivers/md/dm-core.h
index c4ef1fceead6..d522093cb39d 100644
--- a/drivers/md/dm-core.h
+++ b/drivers/md/dm-core.h
@@ -11,6 +11,7 @@
 
 #include <linux/kthread.h>
 #include <linux/ktime.h>
+#include <linux/genhd.h>
 #include <linux/blk-mq.h>
 
 #include <trace/events/block.h>
@@ -25,9 +26,11 @@ struct dm_kobject_holder {
 };
 
 /*
- * DM core internal structure that used directly by dm.c and dm-rq.c
- * DM targets must _not_ deference a mapped_device to directly access its members!
+ * DM core internal structures used directly by dm.c, dm-rq.c and dm-table.c.
+ * DM targets must _not_ deference a mapped_device or dm_table to directly
+ * access their members!
  */
+
 struct mapped_device {
 	struct mutex suspend_lock;
 
@@ -119,6 +122,55 @@ void disable_discard(struct mapped_device *md);
 void disable_write_same(struct mapped_device *md);
 void disable_write_zeroes(struct mapped_device *md);
 
+static inline sector_t dm_get_size(struct mapped_device *md)
+{
+	return get_capacity(md->disk);
+}
+
+static inline struct dm_stats *dm_get_stats(struct mapped_device *md)
+{
+	return &md->stats;
+}
+
+#define DM_TABLE_MAX_DEPTH 16
+
+struct dm_table {
+	struct mapped_device *md;
+	enum dm_queue_mode type;
+
+	/* btree table */
+	unsigned int depth;
+	unsigned int counts[DM_TABLE_MAX_DEPTH]; /* in nodes */
+	sector_t *index[DM_TABLE_MAX_DEPTH];
+
+	unsigned int num_targets;
+	unsigned int num_allocated;
+	sector_t *highs;
+	struct dm_target *targets;
+
+	struct target_type *immutable_target_type;
+
+	bool integrity_supported:1;
+	bool singleton:1;
+	unsigned integrity_added:1;
+
+	/*
+	 * Indicates the rw permissions for the new logical
+	 * device.  This should be a combination of FMODE_READ
+	 * and FMODE_WRITE.
+	 */
+	fmode_t mode;
+
+	/* a list of devices used by this table */
+	struct list_head devices;
+
+	/* events get handed up using this callback */
+	void (*event_fn)(void *);
+	void *event_context;
+
+	struct dm_md_mempools *mempools;
+};
+
 static inline struct completion *dm_get_completion_from_kobject(struct kobject *kobj)
 {
 	return &container_of(kobj, struct dm_kobject_holder, kobj)->completion;
diff --git a/drivers/md/dm-rq.c b/drivers/md/dm-rq.c
index 20745e2e34b9..f429592e60db 100644
--- a/drivers/md/dm-rq.c
+++ b/drivers/md/dm-rq.c
@@ -175,7 +175,7 @@ static void __dm_mq_kick_requeue_list(struct request_queue *q, unsigned long mse
 
 void dm_mq_kick_requeue_list(struct mapped_device *md)
 {
-	__dm_mq_kick_requeue_list(dm_get_md_queue(md), 0);
+	__dm_mq_kick_requeue_list(md->queue, 0);
 }
 EXPORT_SYMBOL(dm_mq_kick_requeue_list);
 
* Unmerged path drivers/md/dm-table.c
* Unmerged path drivers/md/dm.c
diff --git a/drivers/md/dm.h b/drivers/md/dm.h
index 092067ac19ee..9f28ac1bf1cb 100644
--- a/drivers/md/dm.h
+++ b/drivers/md/dm.h
@@ -177,12 +177,9 @@ int dm_open_count(struct mapped_device *md);
 int dm_lock_for_deletion(struct mapped_device *md, bool mark_deferred, bool only_deferred);
 int dm_cancel_deferred_remove(struct mapped_device *md);
 int dm_request_based(struct mapped_device *md);
-sector_t dm_get_size(struct mapped_device *md);
-struct request_queue *dm_get_md_queue(struct mapped_device *md);
 int dm_get_table_device(struct mapped_device *md, dev_t dev, fmode_t mode,
 			struct dm_dev **result);
 void dm_put_table_device(struct mapped_device *md, struct dm_dev *d);
-struct dm_stats *dm_get_stats(struct mapped_device *md);
 
 int dm_kobject_uevent(struct mapped_device *md, enum kobject_action action,
 		      unsigned cookie);
