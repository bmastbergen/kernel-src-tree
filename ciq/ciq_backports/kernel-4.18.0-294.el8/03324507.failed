driver core: Allow fwnode_operations.add_links to differentiate errors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 03324507e66c7664c754b1ef92c5c3be24c78aa2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/03324507.failed

When add_links() still has suppliers that it needs to link to in the
future, this patch allows it to differentiate between suppliers that are
needed for probing vs suppliers that are needed for sync_state()
correctness.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20191028220027.251605-4-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 03324507e66c7664c754b1ef92c5c3be24c78aa2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/fwnode.h
diff --cc drivers/base/core.c
index a11a4382fe7f,e6d3e6d485da..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -1979,6 -2399,28 +1979,31 @@@ int device_add(struct device *dev
  	if (dev->fwnode && !dev->fwnode->dev)
  		dev->fwnode->dev = dev;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Check if any of the other devices (consumers) have been waiting for
+ 	 * this device (supplier) to be added so that they can create a device
+ 	 * link to it.
+ 	 *
+ 	 * This needs to happen after device_pm_add() because device_link_add()
+ 	 * requires the supplier be registered before it's called.
+ 	 *
+ 	 * But this also needs to happe before bus_probe_device() to make sure
+ 	 * waiting consumers can link to it before the driver is bound to the
+ 	 * device and the driver sync_state callback is called for this device.
+ 	 */
+ 	device_link_add_missing_supplier_links();
+ 
+ 	if (fwnode_has_op(dev->fwnode, add_links)) {
+ 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+ 		if (fw_ret == -ENODEV)
+ 			device_link_wait_for_mandatory_supplier(dev);
+ 		else if (fw_ret)
+ 			device_link_wait_for_optional_supplier(dev);
+ 	}
+ 
++>>>>>>> 03324507e66c (driver core: Allow fwnode_operations.add_links to differentiate errors)
  	bus_probe_device(dev);
  	if (parent)
  		klist_add_tail(&dev->p->knode_parent,
diff --cc include/linux/fwnode.h
index ba3d4116da4f,766ff9bb5876..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -71,6 -66,43 +71,46 @@@ struct fwnode_reference_args 
   *			       endpoint node.
   * @graph_get_port_parent: Return the parent node of a port node.
   * @graph_parse_endpoint: Parse endpoint for port and endpoint id.
++<<<<<<< HEAD
++=======
+  * @add_links:	Called after the device corresponding to the fwnode is added
+  *		using device_add(). The function is expected to create device
+  *		links to all the suppliers of the device that are available at
+  *		the time this function is called.  The function must NOT stop
+  *		at the first failed device link if other unlinked supplier
+  *		devices are present in the system.  This is necessary for the
+  *		driver/bus sync_state() callbacks to work correctly.
+  *
+  *		For example, say Device-C depends on suppliers Device-S1 and
+  *		Device-S2 and the dependency is listed in that order in the
+  *		firmware.  Say, S1 gets populated from the firmware after
+  *		late_initcall_sync().  Say S2 is populated and probed way
+  *		before that in device_initcall(). When C is populated, if this
+  *		add_links() function doesn't continue past a "failed linking to
+  *		S1" and continue linking C to S2, then S2 will get a
+  *		sync_state() callback before C is probed. This is because from
+  *		the perspective of S2, C was never a consumer when its
+  *		sync_state() evaluation is done. To avoid this, the add_links()
+  *		function has to go through all available suppliers of the
+  *		device (that corresponds to this fwnode) and link to them
+  *		before returning.
+  *
+  *		If some suppliers are not yet available (indicated by an error
+  *		return value), this function will be called again when other
+  *		devices are added to allow creating device links to any newly
+  *		available suppliers.
+  *
+  *		Return 0 if device links have been successfully created to all
+  *		the suppliers this device needs to create device links to or if
+  *		the supplier information is not known.
+  *
+  *		Return -ENODEV if and only if the suppliers needed for probing
+  *		the device are not yet available to create device links to.
+  *
+  *		Return -EAGAIN if there are suppliers that need to be linked to
+  *		that are not yet available but none of those suppliers are
+  *		necessary for probing this device.
++>>>>>>> 03324507e66c (driver core: Allow fwnode_operations.add_links to differentiate errors)
   */
  struct fwnode_operations {
  	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
* Unmerged path drivers/base/core.c
* Unmerged path include/linux/fwnode.h
