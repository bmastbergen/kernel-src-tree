xfs: refactor xfs_dabuf_map

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 45feef8f50b94d56d6a433ad5baf5cdf58e3db98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/45feef8f.failed

Merge xfs_buf_map_from_irec and xfs_da_map_covers_blocks into a single
loop in the caller.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 45feef8f50b94d56d6a433ad5baf5cdf58e3db98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_da_btree.c
diff --cc fs/xfs/libxfs/xfs_da_btree.c
index b4bb7f36af89,e078817fc26c..000000000000
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@@ -2554,51 -2479,48 +2486,77 @@@ xfs_dabuf_map
  {
  	struct xfs_mount	*mp = dp->i_mount;
  	int			nfsb = xfs_dabuf_nfsb(mp, whichfork);
- 	int			error = 0;
- 	struct xfs_bmbt_irec	irec;
- 	struct xfs_bmbt_irec	*irecs = &irec;
- 	int			nirecs;
+ 	struct xfs_bmbt_irec	irec, *irecs = &irec;
+ 	struct xfs_buf_map	*map = *mapp;
+ 	xfs_fileoff_t		off = bno;
+ 	int			error = 0, nirecs, i;
  
- 	ASSERT(map && *map);
- 	ASSERT(*nmaps == 1);
- 
- 	if (nfsb != 1)
+ 	if (nfsb > 1)
  		irecs = kmem_zalloc(sizeof(irec) * nfsb, KM_NOFS);
+ 
  	nirecs = nfsb;
- 	error = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,
- 			       &nirecs, xfs_bmapi_aflag(whichfork));
+ 	error = xfs_bmapi_read(dp, bno, nfsb, irecs, &nirecs,
+ 			xfs_bmapi_aflag(whichfork));
  	if (error)
- 		goto out;
+ 		goto out_free_irecs;
  
++<<<<<<< HEAD
 +	if (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {
 +		/* Caller ok with no mapping. */
 +		if (mappedbno == -2) {
 +			error = -1;
 +			goto out;
 +		}
 +
 +		/* Caller expected a mapping, so abort. */
 +		if (xfs_error_level >= XFS_ERRLEVEL_LOW) {
 +			int i;
 +
 +			xfs_alert(mp, "%s: bno %lld dir: inode %lld", __func__,
 +					(long long)bno, (long long)dp->i_ino);
 +			for (i = 0; i < *nmaps; i++) {
 +				xfs_alert(mp,
 +"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d",
 +					i,
 +					(long long)irecs[i].br_startoff,
 +					(long long)irecs[i].br_startblock,
 +					(long long)irecs[i].br_blockcount,
 +					irecs[i].br_state);
 +			}
 +		}
 +		XFS_ERROR_REPORT("xfs_da_do_buf(1)", XFS_ERRLEVEL_LOW, mp);
 +		error = -EFSCORRUPTED;
 +		goto out;
++=======
+ 	/*
+ 	 * Use the caller provided map for the single map case, else allocate a
+ 	 * larger one that needs to be free by the caller.
+ 	 */
+ 	if (nirecs > 1) {
+ 		map = kmem_zalloc(nirecs * sizeof(struct xfs_buf_map), KM_NOFS);
+ 		if (!map)
+ 			goto out_free_irecs;
+ 		*mapp = map;
++>>>>>>> 45feef8f50b9 (xfs: refactor xfs_dabuf_map)
  	}
- 	error = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);
- out:
+ 
+ 	for (i = 0; i < nirecs; i++) {
+ 		if (irecs[i].br_startblock == HOLESTARTBLOCK ||
+ 		    irecs[i].br_startblock == DELAYSTARTBLOCK)
+ 			goto invalid_mapping;
+ 		if (off != irecs[i].br_startoff)
+ 			goto invalid_mapping;
+ 
+ 		map[i].bm_bn = XFS_FSB_TO_DADDR(mp, irecs[i].br_startblock);
+ 		map[i].bm_len = XFS_FSB_TO_BB(mp, irecs[i].br_blockcount);
+ 		off += irecs[i].br_blockcount;
+ 	}
+ 
+ 	if (off != bno + nfsb)
+ 		goto invalid_mapping;
+ 
+ 	*nmaps = nirecs;
+ out_free_irecs:
  	if (irecs != &irec)
  		kmem_free(irecs);
  	return error;
* Unmerged path fs/xfs/libxfs/xfs_da_btree.c
