iommu/arm-smmu: Prevent forced unbinding of Arm SMMU drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Will Deacon <will@kernel.org>
commit 34debdca68efd5625a2fcea7df1a215591a01f80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/34debdca.failed

Forcefully unbinding the Arm SMMU drivers is a pretty dangerous operation,
since it will likely lead to catastrophic failure for any DMA devices
mastering through the SMMU being unbound. When the driver then attempts
to "handle" the fatal faults, it's very easy to trip over dead data
structures, leading to use-after-free.

On John's machine, he reports that the machine was "unusable" due to
loss of the storage controller following a forced unbind of the SMMUv3
driver:

  | # cd ./bus/platform/drivers/arm-smmu-v3
  | # echo arm-smmu-v3.0.auto > unbind
  | hisi_sas_v2_hw HISI0162:01: CQE_AXI_W_ERR (0x800) found!
  | platform arm-smmu-v3.0.auto: CMD_SYNC timeout at 0x00000146
  | [hwprod 0x00000146, hwcons 0x00000000]

Prevent this forced unbinding of the drivers by setting "suppress_bind_attrs"
to true.

Link: https://lore.kernel.org/lkml/06dfd385-1af0-3106-4cc5-6a5b8e864759@huawei.com
	Reported-by: John Garry <john.garry@huawei.com>
	Signed-off-by: Will Deacon <will@kernel.org>
	Tested-by: John Garry <john.garry@huawei.com> # smmu v3
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 34debdca68efd5625a2fcea7df1a215591a01f80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/arm-smmu-v3.c
#	drivers/iommu/arm-smmu.c
diff --cc drivers/iommu/arm-smmu-v3.c
index d076622e2dd4,9d4c9de6172d..000000000000
--- a/drivers/iommu/arm-smmu-v3.c
+++ b/drivers/iommu/arm-smmu-v3.c
@@@ -3699,13 -3699,17 +3699,19 @@@ static const struct of_device_id arm_sm
  
  static struct platform_driver arm_smmu_driver = {
  	.driver	= {
++<<<<<<< HEAD
 +		.name		= "arm-smmu-v3",
 +		.of_match_table	= of_match_ptr(arm_smmu_of_match),
 +		.suppress_bind_attrs = true,
++=======
+ 		.name			= "arm-smmu-v3",
+ 		.of_match_table		= of_match_ptr(arm_smmu_of_match),
+ 		.suppress_bind_attrs	= true,
++>>>>>>> 34debdca68ef (iommu/arm-smmu: Prevent forced unbinding of Arm SMMU drivers)
  	},
  	.probe	= arm_smmu_device_probe,
 -	.remove	= arm_smmu_device_remove,
  	.shutdown = arm_smmu_device_shutdown,
  };
 -module_platform_driver(arm_smmu_driver);
  
 -MODULE_DESCRIPTION("IOMMU API for ARM architected SMMUv3 implementations");
 -MODULE_AUTHOR("Will Deacon <will.deacon@arm.com>");
 -MODULE_LICENSE("GPL v2");
 +IOMMU_OF_DECLARE(arm_smmuv3, "arm,smmu-v3");
 +builtin_platform_driver(arm_smmu_driver);
diff --cc drivers/iommu/arm-smmu.c
index ab9a0239376c,5cbee88a3b83..000000000000
--- a/drivers/iommu/arm-smmu.c
+++ b/drivers/iommu/arm-smmu.c
@@@ -2479,16 -2271,14 +2479,20 @@@ static struct platform_driver arm_smmu_
  		.name			= "arm-smmu",
  		.of_match_table		= of_match_ptr(arm_smmu_of_match),
  		.pm			= &arm_smmu_pm_ops,
++<<<<<<< HEAD
 +		.suppress_bind_attrs	= true,
++=======
+ 		.suppress_bind_attrs    = true,
++>>>>>>> 34debdca68ef (iommu/arm-smmu: Prevent forced unbinding of Arm SMMU drivers)
  	},
  	.probe	= arm_smmu_device_probe,
 -	.remove	= arm_smmu_device_remove,
  	.shutdown = arm_smmu_device_shutdown,
  };
 -module_platform_driver(arm_smmu_driver);
  
 -MODULE_DESCRIPTION("IOMMU API for ARM architected SMMU implementations");
 -MODULE_AUTHOR("Will Deacon <will.deacon@arm.com>");
 -MODULE_LICENSE("GPL v2");
 +IOMMU_OF_DECLARE(arm_smmuv1, "arm,smmu-v1");
 +IOMMU_OF_DECLARE(arm_smmuv2, "arm,smmu-v2");
 +IOMMU_OF_DECLARE(arm_mmu400, "arm,mmu-400");
 +IOMMU_OF_DECLARE(arm_mmu401, "arm,mmu-401");
 +IOMMU_OF_DECLARE(arm_mmu500, "arm,mmu-500");
 +IOMMU_OF_DECLARE(cavium_smmuv2, "cavium,smmu-v2");
 +builtin_platform_driver(arm_smmu_driver);
* Unmerged path drivers/iommu/arm-smmu-v3.c
* Unmerged path drivers/iommu/arm-smmu.c
