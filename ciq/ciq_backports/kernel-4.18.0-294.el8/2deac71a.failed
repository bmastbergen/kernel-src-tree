net: atlantic: QoS implementation: min_rate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mark Starovoytov <mstarovoitov@marvell.com>
commit 2deac71ac492a6025b163701436e0aa39435a05f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2deac71a.failed

This patch adds support for mqprio min_rate limiters.

A2 HW supports Weighted Strict Priority (WSP) arbitration for Tx Descriptor
Queue scheduling among TCs, which can be used for min_rate shaping.

	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2deac71ac492a6025b163701436e0aa39435a05f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_main.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh_internal.h
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_main.c
index 25a59894105a,8a1da044e908..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_main.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_main.c
@@@ -229,6 -332,73 +229,76 @@@ static int aq_ndo_vlan_rx_kill_vid(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int aq_validate_mqprio_opt(struct aq_nic_s *self,
+ 				  struct tc_mqprio_qopt_offload *mqprio,
+ 				  const unsigned int num_tc)
+ {
+ 	const bool has_min_rate = !!(mqprio->flags & TC_MQPRIO_F_MIN_RATE);
+ 	struct aq_nic_cfg_s *aq_nic_cfg = aq_nic_get_cfg(self);
+ 	const unsigned int tcs_max = min_t(u8, aq_nic_cfg->aq_hw_caps->tcs_max,
+ 					   AQ_CFG_TCS_MAX);
+ 
+ 	if (num_tc > tcs_max) {
+ 		netdev_err(self->ndev, "Too many TCs requested\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (num_tc != 0 && !is_power_of_2(num_tc)) {
+ 		netdev_err(self->ndev, "TC count should be power of 2\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (has_min_rate && !ATL_HW_IS_CHIP_FEATURE(self->aq_hw, ANTIGUA)) {
+ 		netdev_err(self->ndev, "Min tx rate is not supported\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int aq_ndo_setup_tc(struct net_device *dev, enum tc_setup_type type,
+ 			   void *type_data)
+ {
+ 	struct tc_mqprio_qopt_offload *mqprio = type_data;
+ 	struct aq_nic_s *aq_nic = netdev_priv(dev);
+ 	bool has_min_rate;
+ 	bool has_max_rate;
+ 	int err;
+ 	int i;
+ 
+ 	if (type != TC_SETUP_QDISC_MQPRIO)
+ 		return -EOPNOTSUPP;
+ 
+ 	has_min_rate = !!(mqprio->flags & TC_MQPRIO_F_MIN_RATE);
+ 	has_max_rate = !!(mqprio->flags & TC_MQPRIO_F_MAX_RATE);
+ 
+ 	err = aq_validate_mqprio_opt(aq_nic, mqprio, mqprio->qopt.num_tc);
+ 	if (err)
+ 		return err;
+ 
+ 	for (i = 0; i < mqprio->qopt.num_tc; i++) {
+ 		if (has_max_rate) {
+ 			u64 max_rate = mqprio->max_rate[i];
+ 
+ 			do_div(max_rate, AQ_MBPS_DIVISOR);
+ 			aq_nic_setup_tc_max_rate(aq_nic, i, (u32)max_rate);
+ 		}
+ 
+ 		if (has_min_rate) {
+ 			u64 min_rate = mqprio->min_rate[i];
+ 
+ 			do_div(min_rate, AQ_MBPS_DIVISOR);
+ 			aq_nic_setup_tc_min_rate(aq_nic, i, (u32)min_rate);
+ 		}
+ 	}
+ 
+ 	return aq_nic_setup_tc_mqprio(aq_nic, mqprio->qopt.num_tc,
+ 				      mqprio->qopt.prio_tc_map);
+ }
+ 
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
  static const struct net_device_ops aq_ndev_ops = {
  	.ndo_open = aq_ndev_open,
  	.ndo_stop = aq_ndev_close,
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index ed7d344e3ed7,4435c6374f7e..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -163,6 -193,12 +163,15 @@@ static int aq_nic_update_link_status(st
  		aq_utils_obj_clear(&self->flags,
  				   AQ_NIC_LINK_DOWN);
  		netif_carrier_on(self->ndev);
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 		aq_macsec_enable(self);
+ #endif
+ 		if (self->aq_hw_ops->hw_tc_rate_limit_set)
+ 			self->aq_hw_ops->hw_tc_rate_limit_set(self->aq_hw);
+ 
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
  		netif_tx_wake_all_queues(self->ndev);
  	}
  	if (netif_carrier_ok(self->ndev) && !self->link_status.mbps) {
@@@ -1076,3 -1264,141 +1085,144 @@@ void aq_nic_shutdown(struct aq_nic_s *s
  err_exit:
  	rtnl_unlock();
  }
++<<<<<<< HEAD
++=======
+ 
+ u8 aq_nic_reserve_filter(struct aq_nic_s *self, enum aq_rx_filter_type type)
+ {
+ 	u8 location = 0xFF;
+ 	u32 fltr_cnt;
+ 	u32 n_bit;
+ 
+ 	switch (type) {
+ 	case aq_rx_filter_ethertype:
+ 		location = AQ_RX_LAST_LOC_FETHERT - AQ_RX_FIRST_LOC_FETHERT -
+ 			   self->aq_hw_rx_fltrs.fet_reserved_count;
+ 		self->aq_hw_rx_fltrs.fet_reserved_count++;
+ 		break;
+ 	case aq_rx_filter_l3l4:
+ 		fltr_cnt = AQ_RX_LAST_LOC_FL3L4 - AQ_RX_FIRST_LOC_FL3L4;
+ 		n_bit = fltr_cnt - self->aq_hw_rx_fltrs.fl3l4.reserved_count;
+ 
+ 		self->aq_hw_rx_fltrs.fl3l4.active_ipv4 |= BIT(n_bit);
+ 		self->aq_hw_rx_fltrs.fl3l4.reserved_count++;
+ 		location = n_bit;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return location;
+ }
+ 
+ void aq_nic_release_filter(struct aq_nic_s *self, enum aq_rx_filter_type type,
+ 			   u32 location)
+ {
+ 	switch (type) {
+ 	case aq_rx_filter_ethertype:
+ 		self->aq_hw_rx_fltrs.fet_reserved_count--;
+ 		break;
+ 	case aq_rx_filter_l3l4:
+ 		self->aq_hw_rx_fltrs.fl3l4.reserved_count--;
+ 		self->aq_hw_rx_fltrs.fl3l4.active_ipv4 &= ~BIT(location);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ int aq_nic_setup_tc_mqprio(struct aq_nic_s *self, u32 tcs, u8 *prio_tc_map)
+ {
+ 	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
+ 	const unsigned int prev_vecs = cfg->vecs;
+ 	bool ndev_running;
+ 	int err = 0;
+ 	int i;
+ 
+ 	/* if already the same configuration or
+ 	 * disable request (tcs is 0) and we already is disabled
+ 	 */
+ 	if (tcs == cfg->tcs || (tcs == 0 && !cfg->is_qos))
+ 		return 0;
+ 
+ 	ndev_running = netif_running(self->ndev);
+ 	if (ndev_running)
+ 		dev_close(self->ndev);
+ 
+ 	cfg->tcs = tcs;
+ 	if (cfg->tcs == 0)
+ 		cfg->tcs = 1;
+ 	if (prio_tc_map)
+ 		memcpy(cfg->prio_tc_map, prio_tc_map, sizeof(cfg->prio_tc_map));
+ 	else
+ 		for (i = 0; i < sizeof(cfg->prio_tc_map); i++)
+ 			cfg->prio_tc_map[i] = cfg->tcs * i / 8;
+ 
+ 	cfg->is_qos = (tcs != 0 ? true : false);
+ 	cfg->is_ptp = (cfg->tcs <= AQ_HW_PTP_TC);
+ 	if (!cfg->is_ptp)
+ 		netdev_warn(self->ndev, "%s\n",
+ 			    "PTP is auto disabled due to requested TC count.");
+ 
+ 	netdev_set_num_tc(self->ndev, cfg->tcs);
+ 
+ 	/* Changing the number of TCs might change the number of vectors */
+ 	aq_nic_cfg_update_num_vecs(self);
+ 	if (prev_vecs != cfg->vecs) {
+ 		err = aq_nic_realloc_vectors(self);
+ 		if (err)
+ 			goto err_exit;
+ 	}
+ 
+ 	if (ndev_running)
+ 		err = dev_open(self->ndev, NULL);
+ 
+ err_exit:
+ 	return err;
+ }
+ 
+ int aq_nic_setup_tc_max_rate(struct aq_nic_s *self, const unsigned int tc,
+ 			     const u32 max_rate)
+ {
+ 	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
+ 
+ 	if (tc >= AQ_CFG_TCS_MAX)
+ 		return -EINVAL;
+ 
+ 	if (max_rate && max_rate < 10) {
+ 		netdev_warn(self->ndev,
+ 			"Setting %s to the minimum usable value of %dMbps.\n",
+ 			"max rate", 10);
+ 		cfg->tc_max_rate[tc] = 10;
+ 	} else {
+ 		cfg->tc_max_rate[tc] = max_rate;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int aq_nic_setup_tc_min_rate(struct aq_nic_s *self, const unsigned int tc,
+ 			     const u32 min_rate)
+ {
+ 	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
+ 
+ 	if (tc >= AQ_CFG_TCS_MAX)
+ 		return -EINVAL;
+ 
+ 	if (min_rate)
+ 		set_bit(tc, &cfg->tc_min_rate_msk);
+ 	else
+ 		clear_bit(tc, &cfg->tc_min_rate_msk);
+ 
+ 	if (min_rate && min_rate < 20) {
+ 		netdev_warn(self->ndev,
+ 			"Setting %s to the minimum usable value of %dMbps.\n",
+ 			"min rate", 20);
+ 		cfg->tc_min_rate[tc] = 20;
+ 	} else {
+ 		cfg->tc_min_rate[tc] = min_rate;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.h
index f6d04351e098,2ab003065e62..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
@@@ -45,7 -59,15 +45,14 @@@ struct aq_nic_cfg_s 
  	bool is_polling;
  	bool is_rss;
  	bool is_lro;
 -	bool is_qos;
 -	bool is_ptp;
 -	enum aq_tc_mode tc_mode;
 -	u32 priv_flags;
  	u8  tcs;
++<<<<<<< HEAD
++=======
+ 	u8 prio_tc_map[8];
+ 	u32 tc_max_rate[AQ_CFG_TCS_MAX];
+ 	unsigned long tc_min_rate_msk;
+ 	u32 tc_min_rate[AQ_CFG_TCS_MAX];
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
  	struct aq_rss_parameters aq_rss;
  	u32 eee_speeds;
  };
@@@ -147,8 -191,15 +154,19 @@@ int aq_nic_set_link_ksettings(struct aq
  			      const struct ethtool_link_ksettings *cmd);
  struct aq_nic_cfg_s *aq_nic_get_cfg(struct aq_nic_s *self);
  u32 aq_nic_get_fw_version(struct aq_nic_s *self);
 -int aq_nic_set_loopback(struct aq_nic_s *self);
 +int aq_nic_change_pm_state(struct aq_nic_s *self, pm_message_t *pm_msg);
  int aq_nic_update_interrupt_moderation_settings(struct aq_nic_s *self);
  void aq_nic_shutdown(struct aq_nic_s *self);
- 
++<<<<<<< HEAD
++
++=======
+ u8 aq_nic_reserve_filter(struct aq_nic_s *self, enum aq_rx_filter_type type);
+ void aq_nic_release_filter(struct aq_nic_s *self, enum aq_rx_filter_type type,
+ 			   u32 location);
+ int aq_nic_setup_tc_mqprio(struct aq_nic_s *self, u32 tcs, u8 *prio_tc_map);
+ int aq_nic_setup_tc_max_rate(struct aq_nic_s *self, const unsigned int tc,
+ 			     const u32 max_rate);
+ int aq_nic_setup_tc_min_rate(struct aq_nic_s *self, const unsigned int tc,
+ 			     const u32 min_rate);
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
  #endif /* AQ_NIC_H */
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index b7e5ce0d7af5,320f3669305d..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -108,11 -114,34 +108,19 @@@ static int hw_atl_b0_set_fc(struct aq_h
  	return 0;
  }
  
 -static int hw_atl_b0_tc_ptp_set(struct aq_hw_s *self)
 -{
 -	/* Init TC2 for PTP_TX */
 -	hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, HW_ATL_B0_PTP_TXBUF_SIZE,
 -					       AQ_HW_PTP_TC);
 -
 -	/* Init TC2 for PTP_RX */
 -	hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, HW_ATL_B0_PTP_RXBUF_SIZE,
 -					       AQ_HW_PTP_TC);
 -	/* No flow control for PTP */
 -	hw_atl_rpb_rx_xoff_en_per_tc_set(self, 0U, AQ_HW_PTP_TC);
 -
 -	return aq_hw_err_from_flags(self);
 -}
 -
  static int hw_atl_b0_hw_qos_set(struct aq_hw_s *self)
  {
 -	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
 -	u32 tx_buff_size = HW_ATL_B0_TXBUF_MAX;
 -	u32 rx_buff_size = HW_ATL_B0_RXBUF_MAX;
 -	unsigned int prio = 0U;
  	u32 tc = 0U;
++<<<<<<< HEAD
 +	u32 buff_size = 0U;
 +	unsigned int i_priority = 0U;
++=======
+ 
+ 	if (cfg->is_ptp) {
+ 		tx_buff_size -= HW_ATL_B0_PTP_TXBUF_SIZE;
+ 		rx_buff_size -= HW_ATL_B0_PTP_RXBUF_SIZE;
+ 	}
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
  
  	/* TPS Descriptor rate init */
  	hw_atl_tps_tx_pkt_shed_desc_rate_curr_time_res_set(self, 0x0U);
@@@ -121,47 -150,39 +129,57 @@@
  	/* TPS VM init */
  	hw_atl_tps_tx_pkt_shed_desc_vm_arb_mode_set(self, 0U);
  
++<<<<<<< HEAD
 +	/* TPS TC credits init */
 +	hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);
 +	hw_atl_tps_tx_pkt_shed_data_arb_mode_set(self, 0U);
 +
 +	hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, 0xFFF, 0U);
 +	hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, 0x64, 0U);
 +	hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, 0x50, 0U);
 +	hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, 0x1E, 0U);
 +
 +	/* Tx buf size */
 +	buff_size = HW_ATL_B0_TXBUF_MAX;
 +
 +	hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, buff_size, tc);
 +	hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024 / 32U) * 66U) /
 +						   100U, tc);
 +	hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024 / 32U) * 50U) /
 +						   100U, tc);
++=======
+ 	tx_buff_size /= cfg->tcs;
+ 	rx_buff_size /= cfg->tcs;
+ 	for (tc = 0; tc < cfg->tcs; tc++) {
+ 		u32 threshold = 0U;
+ 
+ 		/* Tx buf size TC0 */
+ 		hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, tx_buff_size, tc);
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
  
 -		threshold = (tx_buff_size * (1024 / 32U) * 66U) / 100U;
 -		hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self, threshold, tc);
 -
 -		threshold = (tx_buff_size * (1024 / 32U) * 50U) / 100U;
 -		hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self, threshold, tc);
 +	/* QoS Rx buf size per TC */
 +	tc = 0;
 +	buff_size = HW_ATL_B0_RXBUF_MAX;
  
 -		/* QoS Rx buf size per TC */
 -		hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, rx_buff_size, tc);
 +	hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, buff_size, tc);
 +	hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024U / 32U) * 66U) /
 +						   100U, tc);
 +	hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024U / 32U) * 50U) /
 +						   100U, tc);
  
 -		threshold = (rx_buff_size * (1024U / 32U) * 66U) / 100U;
 -		hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self, threshold, tc);
 -
 -		threshold = (rx_buff_size * (1024U / 32U) * 50U) / 100U;
 -		hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self, threshold, tc);
 -
 -		hw_atl_b0_set_fc(self, self->aq_nic_cfg->fc.req, tc);
 -	}
 -
 -	if (cfg->is_ptp)
 -		hw_atl_b0_tc_ptp_set(self);
 +	hw_atl_b0_set_fc(self, self->aq_nic_cfg->flow_control, tc);
  
  	/* QoS 802.1p priority -> TC mapping */
 -	for (prio = 0; prio < 8; ++prio)
 -		hw_atl_rpf_rpb_user_priority_tc_map_set(self, prio,
 -							cfg->prio_tc_map[prio]);
 +	for (i_priority = 8U; i_priority--;)
 +		hw_atl_rpf_rpb_user_priority_tc_map_set(self, i_priority, 0U);
  
  	return aq_hw_err_from_flags(self);
  }
@@@ -283,6 -306,119 +301,122 @@@ static int hw_atl_b0_hw_offload_set(str
  
  		hw_atl_itr_rsc_delay_set(self, 1U);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
+ static int hw_atl_b0_hw_init_tx_tc_rate_limit(struct aq_hw_s *self)
+ {
+ 	static const u32 max_weight = BIT(HW_ATL_TPS_DATA_TCTWEIGHT_WIDTH) - 1;
+ 	/* Scale factor is based on the number of bits in fractional portion */
+ 	static const u32 scale = BIT(HW_ATL_TPS_DESC_RATE_Y_WIDTH);
+ 	static const u32 frac_msk = HW_ATL_TPS_DESC_RATE_Y_MSK >>
+ 				    HW_ATL_TPS_DESC_RATE_Y_SHIFT;
+ 	const u32 link_speed = self->aq_link_status.mbps;
+ 	struct aq_nic_cfg_s *nic_cfg = self->aq_nic_cfg;
+ 	unsigned long num_min_rated_tcs = 0;
+ 	u32 tc_weight[AQ_CFG_TCS_MAX];
+ 	u32 fixed_max_credit;
+ 	u8 min_rate_msk = 0;
+ 	u32 sum_weight = 0;
+ 	int tc;
+ 
+ 	/* By default max_credit is based upon MTU (in unit of 64b) */
+ 	fixed_max_credit = nic_cfg->aq_hw_caps->mtu / 64;
+ 
+ 	if (link_speed) {
+ 		min_rate_msk = nic_cfg->tc_min_rate_msk &
+ 			       (BIT(nic_cfg->tcs) - 1);
+ 		num_min_rated_tcs = hweight8(min_rate_msk);
+ 	}
+ 
+ 	/* First, calculate weights where min_rate is specified */
+ 	if (num_min_rated_tcs) {
+ 		for (tc = 0; tc != nic_cfg->tcs; tc++) {
+ 			if (!nic_cfg->tc_min_rate[tc]) {
+ 				tc_weight[tc] = 0;
+ 				continue;
+ 			}
+ 
+ 			tc_weight[tc] = (-1L + link_speed +
+ 					 nic_cfg->tc_min_rate[tc] *
+ 					 max_weight) /
+ 					link_speed;
+ 			tc_weight[tc] = min(tc_weight[tc], max_weight);
+ 			sum_weight += tc_weight[tc];
+ 		}
+ 	}
+ 
+ 	/* WSP, if min_rate is set for at least one TC.
+ 	 * RR otherwise.
+ 	 */
+ 	hw_atl_tps_tx_pkt_shed_data_arb_mode_set(self, min_rate_msk ? 1U : 0U);
+ 	/* Data TC Arbiter takes precedence over Descriptor TC Arbiter,
+ 	 * leave Descriptor TC Arbiter as RR.
+ 	 */
+ 	hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);
+ 
+ 	hw_atl_tps_tx_desc_rate_mode_set(self, nic_cfg->is_qos ? 1U : 0U);
+ 
+ 	for (tc = 0; tc != nic_cfg->tcs; tc++) {
+ 		const u32 en = (nic_cfg->tc_max_rate[tc] != 0) ? 1U : 0U;
+ 		const u32 desc = AQ_NIC_CFG_TCVEC2RING(nic_cfg, tc, 0);
+ 		u32 weight, max_credit;
+ 
+ 		hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, tc,
+ 							      fixed_max_credit);
+ 		hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, tc, 0x1E);
+ 
+ 		if (num_min_rated_tcs) {
+ 			weight = tc_weight[tc];
+ 
+ 			if (!weight && sum_weight < max_weight)
+ 				weight = (max_weight - sum_weight) /
+ 					 (nic_cfg->tcs - num_min_rated_tcs);
+ 			else if (!weight)
+ 				weight = 0x64;
+ 
+ 			max_credit = max(8 * weight, fixed_max_credit);
+ 		} else {
+ 			weight = 0x64;
+ 			max_credit = 0xFFF;
+ 		}
+ 
+ 		hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, tc, weight);
+ 		hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, tc,
+ 							      max_credit);
+ 
+ 		hw_atl_tps_tx_desc_rate_en_set(self, desc, en);
+ 
+ 		if (en) {
+ 			/* Nominal rate is always 10G */
+ 			const u32 rate = 10000U * scale /
+ 					 nic_cfg->tc_max_rate[tc];
+ 			const u32 rate_int = rate >>
+ 					     HW_ATL_TPS_DESC_RATE_Y_WIDTH;
+ 			const u32 rate_frac = rate & frac_msk;
+ 
+ 			hw_atl_tps_tx_desc_rate_x_set(self, desc, rate_int);
+ 			hw_atl_tps_tx_desc_rate_y_set(self, desc, rate_frac);
+ 		} else {
+ 			/* A value of 1 indicates the queue is not
+ 			 * rate controlled.
+ 			 */
+ 			hw_atl_tps_tx_desc_rate_x_set(self, desc, 1U);
+ 			hw_atl_tps_tx_desc_rate_y_set(self, desc, 0U);
+ 		}
+ 	}
+ 	for (tc = nic_cfg->tcs; tc != AQ_CFG_TCS_MAX; tc++) {
+ 		const u32 desc = AQ_NIC_CFG_TCVEC2RING(nic_cfg, tc, 0);
+ 
+ 		hw_atl_tps_tx_desc_rate_en_set(self, desc, 0U);
+ 		hw_atl_tps_tx_desc_rate_x_set(self, desc, 1U);
+ 		hw_atl_tps_tx_desc_rate_y_set(self, desc, 0U);
+ 	}
+ 
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
  	return aq_hw_err_from_flags(self);
  }
  
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
index b1c0b6850e60,b855459272ca..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
@@@ -36,4 -34,39 +36,42 @@@ extern const struct aq_hw_ops hw_atl_op
  
  #define hw_atl_ops_b1 hw_atl_ops_b0
  
++<<<<<<< HEAD
++=======
+ int hw_atl_b0_hw_rss_hash_set(struct aq_hw_s *self,
+ 			      struct aq_rss_parameters *rss_params);
+ int hw_atl_b0_hw_offload_set(struct aq_hw_s *self,
+ 			     struct aq_nic_cfg_s *aq_nic_cfg);
+ 
+ int hw_atl_b0_hw_ring_tx_start(struct aq_hw_s *self, struct aq_ring_s *ring);
+ int hw_atl_b0_hw_ring_rx_start(struct aq_hw_s *self, struct aq_ring_s *ring);
+ 
+ int hw_atl_b0_hw_ring_rx_init(struct aq_hw_s *self, struct aq_ring_s *aq_ring,
+ 			      struct aq_ring_param_s *aq_ring_param);
+ int hw_atl_b0_hw_ring_rx_fill(struct aq_hw_s *self, struct aq_ring_s *ring,
+ 			      unsigned int sw_tail_old);
+ int hw_atl_b0_hw_ring_rx_receive(struct aq_hw_s *self, struct aq_ring_s *ring);
+ 
+ int hw_atl_b0_hw_ring_tx_init(struct aq_hw_s *self, struct aq_ring_s *aq_ring,
+ 			      struct aq_ring_param_s *aq_ring_param);
+ int hw_atl_b0_hw_ring_tx_xmit(struct aq_hw_s *self, struct aq_ring_s *ring,
+ 			      unsigned int frags);
+ int hw_atl_b0_hw_ring_tx_head_update(struct aq_hw_s *self,
+ 				     struct aq_ring_s *ring);
+ 
+ int hw_atl_b0_hw_ring_tx_stop(struct aq_hw_s *self, struct aq_ring_s *ring);
+ int hw_atl_b0_hw_ring_rx_stop(struct aq_hw_s *self, struct aq_ring_s *ring);
+ 
+ int hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr);
+ 
+ int hw_atl_b0_hw_start(struct aq_hw_s *self);
+ 
+ int hw_atl_b0_hw_irq_enable(struct aq_hw_s *self, u64 mask);
+ int hw_atl_b0_hw_irq_disable(struct aq_hw_s *self, u64 mask);
+ int hw_atl_b0_hw_irq_read(struct aq_hw_s *self, u64 *mask);
+ 
+ int hw_atl_b0_hw_packet_filter_set(struct aq_hw_s *self,
+ 				   unsigned int packet_filter);
+ 
++>>>>>>> 2deac71ac492 (net: atlantic: QoS implementation: min_rate)
  #endif /* HW_ATL_B0_H */
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh_internal.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 46eaf70c5ccb..f5354b854715 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@ -232,6 +232,8 @@ struct aq_hw_ops {
 	int (*hw_rss_hash_set)(struct aq_hw_s *self,
 			       struct aq_rss_parameters *rss_params);
 
+	int (*hw_tc_rate_limit_set)(struct aq_hw_s *self);
+
 	int (*hw_get_regs)(struct aq_hw_s *self,
 			   const struct aq_hw_caps_s *aq_hw_caps,
 			   u32 *regs_buff);
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_main.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh_internal.h
