s390/qeth: remove QETH_RX_PULL_LEN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 8ca8559ff3cefd78e12b9658f21cc8bcc02407ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8ca8559f.failed

Since commit f677fcb9aeb6 ("s390/qeth: ensure linear access to packet headers"),
the CQ-specific skbs are allocated with a slightly bigger linear part
than necessary. Shrink it down to the maximum that's needed by
qeth_extract_skb().

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8ca8559ff3cefd78e12b9658f21cc8bcc02407ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index 210b547f4f17,3be3d13f8d65..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -2683,9 -2627,10 +2683,10 @@@ static int qeth_init_input_buffer(struc
  
  	if ((card->options.cq == QETH_CQ_ENABLED) && (!buf->rx_skb)) {
  		buf->rx_skb = netdev_alloc_skb(card->dev,
- 					       QETH_RX_PULL_LEN + ETH_HLEN);
+ 					       ETH_HLEN +
+ 					       sizeof(struct ipv6hdr));
  		if (!buf->rx_skb)
 -			return 1;
 +			return -ENOMEM;
  	}
  
  	pool_entry = qeth_find_free_buffer_pool_entry(card);
@@@ -5205,21 -5263,43 +5206,47 @@@ next_packet
  		     !atomic_read(&card->force_alloc_skb) &&
  		     !IS_OSN(card));
  
 -	if (use_rx_sg) {
 +	if (use_rx_sg && qethbuffer->rx_skb) {
  		/* QETH_CQ_ENABLED only: */
++<<<<<<< HEAD
 +		skb = qethbuffer->rx_skb;
 +		qethbuffer->rx_skb = NULL;
 +	} else {
 +		if (!use_rx_sg)
 +			linear_len = skb_len;
 +		skb = napi_alloc_skb(&card->napi, linear_len + headroom);
++=======
+ 		if (qethbuffer->rx_skb &&
+ 		    skb_tailroom(qethbuffer->rx_skb) >= linear_len + headroom) {
+ 			skb = qethbuffer->rx_skb;
+ 			qethbuffer->rx_skb = NULL;
+ 			goto use_skb;
+ 		}
+ 
+ 		skb = napi_get_frags(napi);
+ 		if (!skb) {
+ 			/* -ENOMEM, no point in falling back further. */
+ 			QETH_CARD_STAT_INC(card, rx_dropped_nomem);
+ 			goto walk_packet;
+ 		}
+ 
+ 		if (skb_tailroom(skb) >= linear_len + headroom) {
+ 			uses_frags = true;
+ 			goto use_skb;
+ 		}
+ 
+ 		netdev_info_once(card->dev,
+ 				 "Insufficient linear space in NAPI frags skb, need %u but have %u\n",
+ 				 linear_len + headroom, skb_tailroom(skb));
+ 		/* Shouldn't happen. Don't optimize, fall back to linear skb. */
++>>>>>>> 8ca8559ff3ce (s390/qeth: remove QETH_RX_PULL_LEN)
  	}
  
 -	linear_len = skb_len;
 -	skb = napi_alloc_skb(napi, linear_len + headroom);
 -	if (!skb) {
 +	if (!skb)
  		QETH_CARD_STAT_INC(card, rx_dropped_nomem);
 -		goto walk_packet;
 -	}
 -
 -use_skb:
 -	if (headroom)
 +	else if (headroom)
  		skb_reserve(skb, headroom);
 +
  walk_packet:
  	while (skb_len) {
  		int data_len = min(skb_len, (int)(element->length - offset));
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index 75aff3734b33..d4d09ff8578e 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -221,7 +221,6 @@ struct qeth_vnicc_info {
 
 /* large receive scatter gather copy break */
 #define QETH_RX_SG_CB (PAGE_SIZE >> 1)
-#define QETH_RX_PULL_LEN 256
 
 struct qeth_hdr_layer3 {
 	__u8  id;
* Unmerged path drivers/s390/net/qeth_core_main.c
