RDMA/mlx5: Add support in steering default miss

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Maor Gottlieb <maorg@mellanox.com>
commit 8c112a5f29a343f89072bed4b9fa176fea226798
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8c112a5f.failed

User can configure default miss rule in order to skip matching in the user
domain and forward the packet to the kernel steering domain.  When user
requests a default miss rule, we add steering rule to forward the traffic
to the next namespace.

Link: https://lore.kernel.org/r/20200504053012.270689-5-leon@kernel.org
	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Reviewed-by: Mark Zhang <markz@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 8c112a5f29a343f89072bed4b9fa176fea226798)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/flow.c
diff --cc drivers/infiniband/hw/mlx5/flow.c
index 69cb7e6e8955,3fa66474afa6..000000000000
--- a/drivers/infiniband/hw/mlx5/flow.c
+++ b/drivers/infiniband/hw/mlx5/flow.c
@@@ -67,43 -67,34 +67,71 @@@ static const struct uverbs_attr_spec ml
  	},
  };
  
++<<<<<<< HEAD
 +#define MLX5_IB_CREATE_FLOW_MAX_FLOW_ACTIONS 2
 +static int UVERBS_HANDLER(MLX5_IB_METHOD_CREATE_FLOW)(
 +	struct uverbs_attr_bundle *attrs)
++=======
+ static int get_dests(struct uverbs_attr_bundle *attrs,
+ 		     struct mlx5_ib_flow_matcher *fs_matcher, int *dest_id,
+ 		     int *dest_type, struct ib_qp **qp, bool *def_miss)
++>>>>>>> 8c112a5f29a3 (RDMA/mlx5: Add support in steering default miss)
  {
 -	bool dest_devx, dest_qp;
 +	struct mlx5_flow_context flow_context = {.flow_tag = MLX5_FS_DEFAULT_FLOW_TAG};
 +	struct mlx5_ib_flow_handler *flow_handler;
 +	struct mlx5_ib_flow_matcher *fs_matcher;
 +	struct ib_uobject **arr_flow_actions;
 +	struct ib_uflow_resources *uflow_res;
 +	struct mlx5_flow_act flow_act = {};
  	void *devx_obj;
++<<<<<<< HEAD
 +	int dest_id, dest_type;
 +	void *cmd_in;
 +	int inlen;
 +	bool dest_devx, dest_qp;
 +	struct ib_qp *qp = NULL;
 +	struct ib_uobject *uobj =
 +		uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_CREATE_FLOW_HANDLE);
 +	struct mlx5_ib_dev *dev = mlx5_udata_to_mdev(&attrs->driver_udata);
 +	int len, ret, i;
 +	u32 counter_id = 0;
 +	u32 *offset_attr;
 +	u32 offset = 0;
++=======
+ 	u32 flags;
+ 	int err;
++>>>>>>> 8c112a5f29a3 (RDMA/mlx5: Add support in steering default miss)
  
 -	dest_devx = uverbs_attr_is_valid(attrs,
 -					 MLX5_IB_ATTR_CREATE_FLOW_DEST_DEVX);
 +	if (!capable(CAP_NET_RAW))
 +		return -EPERM;
 +
 +	dest_devx =
 +		uverbs_attr_is_valid(attrs, MLX5_IB_ATTR_CREATE_FLOW_DEST_DEVX);
  	dest_qp = uverbs_attr_is_valid(attrs,
  				       MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);
  
++<<<<<<< HEAD
 +	fs_matcher = uverbs_attr_get_obj(attrs,
 +					 MLX5_IB_ATTR_CREATE_FLOW_MATCHER);
 +	if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_BYPASS &&
 +	    ((dest_devx && dest_qp) || (!dest_devx && !dest_qp)))
 +		return -EINVAL;
++=======
+ 	*def_miss = false;
+ 	err = uverbs_get_flags32(&flags, attrs,
+ 				 MLX5_IB_ATTR_CREATE_FLOW_FLAGS,
+ 				 MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS);
+ 	if (err)
+ 		return err;
+ 	*def_miss = flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS;
+ 
+ 	if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_BYPASS) {
+ 		if (dest_devx && (dest_qp || *def_miss))
+ 			return -EINVAL;
+ 		else if (dest_qp && *def_miss)
+ 			return -EINVAL;
+ 	}
++>>>>>>> 8c112a5f29a3 (RDMA/mlx5: Add support in steering default miss)
  
  	/* Allow only DEVX object as dest when inserting to FDB */
  	if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_FDB && !dest_devx)
@@@ -133,24 -124,64 +161,67 @@@
  	} else if (dest_qp) {
  		struct mlx5_ib_qp *mqp;
  
 -		*qp = uverbs_attr_get_obj(attrs,
 -					  MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);
 -		if (IS_ERR(*qp))
 -			return PTR_ERR(*qp);
 +		qp = uverbs_attr_get_obj(attrs,
 +					 MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);
 +		if (IS_ERR(qp))
 +			return PTR_ERR(qp);
  
 -		if ((*qp)->qp_type != IB_QPT_RAW_PACKET)
 +		if (qp->qp_type != IB_QPT_RAW_PACKET)
  			return -EINVAL;
  
 -		mqp = to_mqp(*qp);
 -		if (mqp->is_rss)
 -			*dest_id = mqp->rss_qp.tirn;
 +		mqp = to_mqp(qp);
 +		if (mqp->flags & MLX5_IB_QP_RSS)
 +			dest_id = mqp->rss_qp.tirn;
  		else
 -			*dest_id = mqp->raw_packet_qp.rq.tirn;
 -		*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 -	} else if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_EGRESS) {
 -		*dest_type = MLX5_FLOW_DESTINATION_TYPE_PORT;
 +			dest_id = mqp->raw_packet_qp.rq.tirn;
 +		dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 +	} else {
 +		dest_type = MLX5_FLOW_DESTINATION_TYPE_PORT;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (*dest_type == MLX5_FLOW_DESTINATION_TYPE_TIR &&
+ 	    fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_EGRESS)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ #define MLX5_IB_CREATE_FLOW_MAX_FLOW_ACTIONS 2
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_CREATE_FLOW)(
+ 	struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_flow_context flow_context = {.flow_tag =
+ 		MLX5_FS_DEFAULT_FLOW_TAG};
+ 	u32 *offset_attr, offset = 0, counter_id = 0;
+ 	int dest_id, dest_type, inlen, len, ret, i;
+ 	struct mlx5_ib_flow_handler *flow_handler;
+ 	struct mlx5_ib_flow_matcher *fs_matcher;
+ 	struct ib_uobject **arr_flow_actions;
+ 	struct ib_uflow_resources *uflow_res;
+ 	struct mlx5_flow_act flow_act = {};
+ 	struct ib_qp *qp = NULL;
+ 	void *devx_obj, *cmd_in;
+ 	struct ib_uobject *uobj;
+ 	struct mlx5_ib_dev *dev;
+ 	bool def_miss;
+ 
+ 	if (!capable(CAP_NET_RAW))
+ 		return -EPERM;
+ 
+ 	fs_matcher = uverbs_attr_get_obj(attrs,
+ 					 MLX5_IB_ATTR_CREATE_FLOW_MATCHER);
+ 	uobj =  uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_CREATE_FLOW_HANDLE);
+ 	dev = mlx5_udata_to_mdev(&attrs->driver_udata);
+ 
+ 	if (get_dests(attrs, fs_matcher, &dest_id, &dest_type, &qp, &def_miss))
+ 		return -EINVAL;
+ 
+ 	if (def_miss)
+ 		flow_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_NS;
+ 
++>>>>>>> 8c112a5f29a3 (RDMA/mlx5: Add support in steering default miss)
  	len = uverbs_attr_get_uobjs_arr(attrs,
  		MLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX, &arr_flow_actions);
  	if (len) {
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index 2acf1e381f1c..70efa80a4ba2 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -4200,18 +4200,17 @@ mlx5_ib_raw_fs_rule_add(struct mlx5_ib_dev *dev,
 
 	if (dest_type == MLX5_FLOW_DESTINATION_TYPE_TIR) {
 		dst[dst_num].type = dest_type;
-		dst[dst_num].tir_num = dest_id;
+		dst[dst_num++].tir_num = dest_id;
 		flow_act->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 	} else if (dest_type == MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE) {
 		dst[dst_num].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE_NUM;
-		dst[dst_num].ft_num = dest_id;
+		dst[dst_num++].ft_num = dest_id;
 		flow_act->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
-	} else {
-		dst[dst_num].type = MLX5_FLOW_DESTINATION_TYPE_PORT;
+	} else  if (dest_type == MLX5_FLOW_DESTINATION_TYPE_PORT) {
+		dst[dst_num++].type = MLX5_FLOW_DESTINATION_TYPE_PORT;
 		flow_act->action |= MLX5_FLOW_CONTEXT_ACTION_ALLOW;
 	}
 
-	dst_num++;
 
 	if (flow_act->action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {
 		dst[dst_num].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;
diff --git a/include/uapi/rdma/mlx5_user_ioctl_cmds.h b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
index 24f3388c3182..07cf54333193 100644
--- a/include/uapi/rdma/mlx5_user_ioctl_cmds.h
+++ b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
@@ -241,6 +241,10 @@ enum mlx5_ib_flow_type {
 	MLX5_IB_FLOW_TYPE_MC_DEFAULT,
 };
 
+enum mlx5_ib_create_flow_flags {
+	MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS = 1 << 0,
+};
+
 enum mlx5_ib_create_flow_attrs {
 	MLX5_IB_ATTR_CREATE_FLOW_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
 	MLX5_IB_ATTR_CREATE_FLOW_MATCH_VALUE,
@@ -251,6 +255,7 @@ enum mlx5_ib_create_flow_attrs {
 	MLX5_IB_ATTR_CREATE_FLOW_TAG,
 	MLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX,
 	MLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX_OFFSET,
+	MLX5_IB_ATTR_CREATE_FLOW_FLAGS,
 };
 
 enum mlx5_ib_destoy_flow_attrs {
