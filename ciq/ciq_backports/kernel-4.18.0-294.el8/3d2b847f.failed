ethtool: provide link state with LINKSTATE_GET request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michal Kubecek <mkubecek@suse.cz>
commit 3d2b847fb99cf2b28aa046e486636e555bc6ed1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3d2b847f.failed

Implement LINKSTATE_GET netlink request to get link state information.

At the moment, only link up flag as provided by ETHTOOL_GLINK ioctl command
is returned.

LINKSTATE_GET request can be used with NLM_F_DUMP (without device
identification) to request the information for all devices in current
network namespace providing the data.

	Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3d2b847fb99cf2b28aa046e486636e555bc6ed1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/ethtool-netlink.rst
#	include/uapi/linux/ethtool_netlink.h
#	net/ethtool/Makefile
#	net/ethtool/common.c
#	net/ethtool/common.h
#	net/ethtool/netlink.c
#	net/ethtool/netlink.h
diff --cc net/ethtool/Makefile
index f68387618973,9a1332fb0cc6..000000000000
--- a/net/ethtool/Makefile
+++ b/net/ethtool/Makefile
@@@ -1,3 -1,8 +1,12 @@@
  # SPDX-License-Identifier: GPL-2.0-only
  
++<<<<<<< HEAD
 +obj-y		+= ioctl.o common.o
++=======
+ obj-y				+= ioctl.o common.o
+ 
+ obj-$(CONFIG_ETHTOOL_NETLINK)	+= ethtool_nl.o
+ 
+ ethtool_nl-y	:= netlink.o bitset.o strset.o linkinfo.o linkmodes.o \
+ 		   linkstate.o
++>>>>>>> 3d2b847fb99c (ethtool: provide link state with LINKSTATE_GET request)
diff --cc net/ethtool/common.c
index 0a8728565356,e621b1694d2f..000000000000
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@@ -169,3 -169,59 +169,62 @@@ const char link_mode_names[][ETH_GSTRIN
  	__DEFINE_LINK_MODE_NAME(400000, CR8, Full),
  };
  static_assert(ARRAY_SIZE(link_mode_names) == __ETHTOOL_LINK_MODE_MASK_NBITS);
++<<<<<<< HEAD
++=======
+ 
+ /* return false if legacy contained non-0 deprecated fields
+  * maxtxpkt/maxrxpkt. rest of ksettings always updated
+  */
+ bool
+ convert_legacy_settings_to_link_ksettings(
+ 	struct ethtool_link_ksettings *link_ksettings,
+ 	const struct ethtool_cmd *legacy_settings)
+ {
+ 	bool retval = true;
+ 
+ 	memset(link_ksettings, 0, sizeof(*link_ksettings));
+ 
+ 	/* This is used to tell users that driver is still using these
+ 	 * deprecated legacy fields, and they should not use
+ 	 * %ETHTOOL_GLINKSETTINGS/%ETHTOOL_SLINKSETTINGS
+ 	 */
+ 	if (legacy_settings->maxtxpkt ||
+ 	    legacy_settings->maxrxpkt)
+ 		retval = false;
+ 
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.supported,
+ 		legacy_settings->supported);
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.advertising,
+ 		legacy_settings->advertising);
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.lp_advertising,
+ 		legacy_settings->lp_advertising);
+ 	link_ksettings->base.speed
+ 		= ethtool_cmd_speed(legacy_settings);
+ 	link_ksettings->base.duplex
+ 		= legacy_settings->duplex;
+ 	link_ksettings->base.port
+ 		= legacy_settings->port;
+ 	link_ksettings->base.phy_address
+ 		= legacy_settings->phy_address;
+ 	link_ksettings->base.autoneg
+ 		= legacy_settings->autoneg;
+ 	link_ksettings->base.mdio_support
+ 		= legacy_settings->mdio_support;
+ 	link_ksettings->base.eth_tp_mdix
+ 		= legacy_settings->eth_tp_mdix;
+ 	link_ksettings->base.eth_tp_mdix_ctrl
+ 		= legacy_settings->eth_tp_mdix_ctrl;
+ 	return retval;
+ }
+ 
+ int __ethtool_get_link(struct net_device *dev)
+ {
+ 	if (!dev->ethtool_ops->get_link)
+ 		return -EOPNOTSUPP;
+ 
+ 	return netif_running(dev) && dev->ethtool_ops->get_link(dev);
+ }
++>>>>>>> 3d2b847fb99c (ethtool: provide link state with LINKSTATE_GET request)
diff --cc net/ethtool/common.h
index bbb788908cb1,5c5f7dc90cd4..000000000000
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@@ -19,4 -20,10 +20,13 @@@ extern const cha
  phy_tunable_strings[__ETHTOOL_PHY_TUNABLE_COUNT][ETH_GSTRING_LEN];
  extern const char link_mode_names[][ETH_GSTRING_LEN];
  
++<<<<<<< HEAD
++=======
+ int __ethtool_get_link(struct net_device *dev);
+ 
+ bool convert_legacy_settings_to_link_ksettings(
+ 	struct ethtool_link_ksettings *link_ksettings,
+ 	const struct ethtool_cmd *legacy_settings);
+ 
++>>>>>>> 3d2b847fb99c (ethtool: provide link state with LINKSTATE_GET request)
  #endif /* _ETHTOOL_COMMON_H */
* Unmerged path Documentation/networking/ethtool-netlink.rst
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/netlink.c
* Unmerged path net/ethtool/netlink.h
* Unmerged path Documentation/networking/ethtool-netlink.rst
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/Makefile
* Unmerged path net/ethtool/common.c
* Unmerged path net/ethtool/common.h
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index e6221e091f3d..b0bb053473ab 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -1622,12 +1622,12 @@ static int ethtool_nway_reset(struct net_device *dev)
 static int ethtool_get_link(struct net_device *dev, char __user *useraddr)
 {
 	struct ethtool_value edata = { .cmd = ETHTOOL_GLINK };
+	int link = __ethtool_get_link(dev);
 
-	if (!dev->ethtool_ops->get_link)
-		return -EOPNOTSUPP;
-
-	edata.data = netif_running(dev) && dev->ethtool_ops->get_link(dev);
+	if (link < 0)
+		return link;
 
+	edata.data = link;
 	if (copy_to_user(useraddr, &edata, sizeof(edata)))
 		return -EFAULT;
 	return 0;
diff --git a/net/ethtool/linkstate.c b/net/ethtool/linkstate.c
new file mode 100644
index 000000000000..2740cde0a182
--- /dev/null
+++ b/net/ethtool/linkstate.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include "netlink.h"
+#include "common.h"
+
+struct linkstate_req_info {
+	struct ethnl_req_info		base;
+};
+
+struct linkstate_reply_data {
+	struct ethnl_reply_data		base;
+	int				link;
+};
+
+#define LINKSTATE_REPDATA(__reply_base) \
+	container_of(__reply_base, struct linkstate_reply_data, base)
+
+static const struct nla_policy
+linkstate_get_policy[ETHTOOL_A_LINKSTATE_MAX + 1] = {
+	[ETHTOOL_A_LINKSTATE_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_LINKSTATE_HEADER]		= { .type = NLA_NESTED },
+	[ETHTOOL_A_LINKSTATE_LINK]		= { .type = NLA_REJECT },
+};
+
+static int linkstate_prepare_data(const struct ethnl_req_info *req_base,
+				  struct ethnl_reply_data *reply_base,
+				  struct genl_info *info)
+{
+	struct linkstate_reply_data *data = LINKSTATE_REPDATA(reply_base);
+	struct net_device *dev = reply_base->dev;
+	int ret;
+
+	ret = ethnl_ops_begin(dev);
+	if (ret < 0)
+		return ret;
+	data->link = __ethtool_get_link(dev);
+	ethnl_ops_complete(dev);
+
+	return 0;
+}
+
+static int linkstate_reply_size(const struct ethnl_req_info *req_base,
+				const struct ethnl_reply_data *reply_base)
+{
+	return nla_total_size(sizeof(u8)) /* LINKSTATE_LINK */
+		+ 0;
+}
+
+static int linkstate_fill_reply(struct sk_buff *skb,
+				const struct ethnl_req_info *req_base,
+				const struct ethnl_reply_data *reply_base)
+{
+	struct linkstate_reply_data *data = LINKSTATE_REPDATA(reply_base);
+
+	if (data->link >= 0 &&
+	    nla_put_u8(skb, ETHTOOL_A_LINKSTATE_LINK, !!data->link))
+		return -EMSGSIZE;
+
+	return 0;
+}
+
+const struct ethnl_request_ops ethnl_linkstate_request_ops = {
+	.request_cmd		= ETHTOOL_MSG_LINKSTATE_GET,
+	.reply_cmd		= ETHTOOL_MSG_LINKSTATE_GET_REPLY,
+	.hdr_attr		= ETHTOOL_A_LINKSTATE_HEADER,
+	.max_attr		= ETHTOOL_A_LINKSTATE_MAX,
+	.req_info_size		= sizeof(struct linkstate_req_info),
+	.reply_data_size	= sizeof(struct linkstate_reply_data),
+	.request_policy		= linkstate_get_policy,
+
+	.prepare_data		= linkstate_prepare_data,
+	.reply_size		= linkstate_reply_size,
+	.fill_reply		= linkstate_fill_reply,
+};
* Unmerged path net/ethtool/netlink.c
* Unmerged path net/ethtool/netlink.h
