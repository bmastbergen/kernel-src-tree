x86/apic: Support 15 bits of APIC ID in MSI where available

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] apic: Support 15 bits of APIC ID in MSI where available (Vitaly Kuznetsov) [1903823]
Rebuild_FUZZ: 96.49%
commit-author David Woodhouse <dwmw@amazon.co.uk>
commit ab0f59c6f135289c7ea90b0e2471674bf289d884
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ab0f59c6.failed

Some hypervisors can allow the guest to use the Extended Destination ID
field in the MSI address to address up to 32768 CPUs.

This applies to all downstream devices which generate MSI cycles,
including HPET, I/O-APIC and PCI MSI.

HPET and PCI MSI use the same __irq_msi_compose_msg() function, while
I/O-APIC generates its own and had support for the extended bits added in
a previous commit.

	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20201024213535.443185-33-dwmw2@infradead.org

(cherry picked from commit ab0f59c6f135289c7ea90b0e2471674bf289d884)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/msi.h
#	arch/x86/kernel/apic/apic.c
diff --cc arch/x86/include/asm/msi.h
index 25ddd0916bb2,b85147d75626..000000000000
--- a/arch/x86/include/asm/msi.h
+++ b/arch/x86/include/asm/msi.h
@@@ -9,6 -9,54 +9,58 @@@ typedef struct irq_alloc_info msi_alloc
  int pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
  		    msi_alloc_info_t *arg);
  
++<<<<<<< HEAD
 +void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc);
++=======
+ /* Structs and defines for the X86 specific MSI message format */
+ 
+ typedef struct x86_msi_data {
+ 	u32	vector			:  8,
+ 		delivery_mode		:  3,
+ 		dest_mode_logical	:  1,
+ 		reserved		:  2,
+ 		active_low		:  1,
+ 		is_level		:  1;
+ 
+ 	u32	dmar_subhandle;
+ } __attribute__ ((packed)) arch_msi_msg_data_t;
+ #define arch_msi_msg_data	x86_msi_data
+ 
+ typedef struct x86_msi_addr_lo {
+ 	union {
+ 		struct {
+ 			u32	reserved_0		:  2,
+ 				dest_mode_logical	:  1,
+ 				redirect_hint		:  1,
+ 				reserved_1		:  1,
+ 				virt_destid_8_14	:  7,
+ 				destid_0_7		:  8,
+ 				base_address		: 12;
+ 		};
+ 		struct {
+ 			u32	dmar_reserved_0		:  2,
+ 				dmar_index_15		:  1,
+ 				dmar_subhandle_valid	:  1,
+ 				dmar_format		:  1,
+ 				dmar_index_0_14		: 15,
+ 				dmar_base_address	: 12;
+ 		};
+ 	};
+ } __attribute__ ((packed)) arch_msi_msg_addr_lo_t;
+ #define arch_msi_msg_addr_lo	x86_msi_addr_lo
+ 
+ #define X86_MSI_BASE_ADDRESS_LOW	(0xfee00000 >> 20)
+ 
+ typedef struct x86_msi_addr_hi {
+ 	u32	reserved		:  8,
+ 		destid_8_31		: 24;
+ } __attribute__ ((packed)) arch_msi_msg_addr_hi_t;
+ #define arch_msi_msg_addr_hi	x86_msi_addr_hi
+ 
+ #define X86_MSI_BASE_ADDRESS_HIGH	(0)
+ 
+ struct msi_msg;
+ u32 x86_msi_msg_get_destid(struct msi_msg *msg, bool extid);
++>>>>>>> ab0f59c6f135 (x86/apic: Support 15 bits of APIC ID in MSI where available)
  
  #endif /* _ASM_X86_MSI_H */
diff --cc arch/x86/kernel/apic/apic.c
index fa2b1841198c,6bd20c0de8bc..000000000000
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@@ -89,8 -91,13 +89,13 @@@ static unsigned int disabled_cpu_apici
   * This variable controls which CPUs receive external NMIs.  By default,
   * external NMIs are delivered only to the BSP.
   */
 -static int apic_extnmi __ro_after_init = APIC_EXTNMI_BSP;
 +static int apic_extnmi = APIC_EXTNMI_BSP;
  
+ /*
+  * Hypervisor supports 15 bits of APIC ID in MSI Extended Destination ID
+  */
+ static bool virt_ext_dest_id __ro_after_init;
+ 
  /*
   * Map cpu index to physical APIC ID
   */
@@@ -2419,6 -2497,46 +2436,49 @@@ int hard_smp_processor_id(void
  	return read_apic_id();
  }
  
++<<<<<<< HEAD
++=======
+ void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg,
+ 			   bool dmar)
+ {
+ 	memset(msg, 0, sizeof(*msg));
+ 
+ 	msg->arch_addr_lo.base_address = X86_MSI_BASE_ADDRESS_LOW;
+ 	msg->arch_addr_lo.dest_mode_logical = apic->dest_mode_logical;
+ 	msg->arch_addr_lo.destid_0_7 = cfg->dest_apicid & 0xFF;
+ 
+ 	msg->arch_data.delivery_mode = APIC_DELIVERY_MODE_FIXED;
+ 	msg->arch_data.vector = cfg->vector;
+ 
+ 	msg->address_hi = X86_MSI_BASE_ADDRESS_HIGH;
+ 	/*
+ 	 * Only the IOMMU itself can use the trick of putting destination
+ 	 * APIC ID into the high bits of the address. Anything else would
+ 	 * just be writing to memory if it tried that, and needs IR to
+ 	 * address APICs which can't be addressed in the normal 32-bit
+ 	 * address range at 0xFFExxxxx. That is typically just 8 bits, but
+ 	 * some hypervisors allow the extended destination ID field in bits
+ 	 * 5-11 to be used, giving support for 15 bits of APIC IDs in total.
+ 	 */
+ 	if (dmar)
+ 		msg->arch_addr_hi.destid_8_31 = cfg->dest_apicid >> 8;
+ 	else if (virt_ext_dest_id && cfg->dest_apicid < 0x8000)
+ 		msg->arch_addr_lo.virt_destid_8_14 = cfg->dest_apicid >> 8;
+ 	else
+ 		WARN_ON_ONCE(cfg->dest_apicid > 0xFF);
+ }
+ 
+ u32 x86_msi_msg_get_destid(struct msi_msg *msg, bool extid)
+ {
+ 	u32 dest = msg->arch_addr_lo.destid_0_7;
+ 
+ 	if (extid)
+ 		dest |= msg->arch_addr_hi.destid_8_31 << 8;
+ 	return dest;
+ }
+ EXPORT_SYMBOL_GPL(x86_msi_msg_get_destid);
+ 
++>>>>>>> ab0f59c6f135 (x86/apic: Support 15 bits of APIC ID in MSI where available)
  /*
   * Override the generic EOI implementation with an optimized version.
   * Only called during early boot when only one CPU is active and with
* Unmerged path arch/x86/include/asm/msi.h
diff --git a/arch/x86/include/asm/x86_init.h b/arch/x86/include/asm/x86_init.h
index 227b18b6d630..67481d1749d5 100644
--- a/arch/x86/include/asm/x86_init.h
+++ b/arch/x86/include/asm/x86_init.h
@@ -123,6 +123,7 @@ struct x86_init_pci {
  * @init_platform:		platform setup
  * @guest_late_init:		guest late init
  * @x2apic_available:		X2APIC detection
+ * @msi_ext_dest_id:		MSI supports 15-bit APIC IDs
  * @init_mem_mapping:		setup early mappings during init_mem_mapping()
  * @init_after_bootmem:		guest init after boot allocator is finished
  */
@@ -130,6 +131,7 @@ struct x86_hyper_init {
 	void (*init_platform)(void);
 	void (*guest_late_init)(void);
 	bool (*x2apic_available)(void);
+	bool (*msi_ext_dest_id)(void);
 	void (*init_mem_mapping)(void);
 	void (*init_after_bootmem)(void);
 };
* Unmerged path arch/x86/kernel/apic/apic.c
diff --git a/arch/x86/kernel/x86_init.c b/arch/x86/kernel/x86_init.c
index e88088ec779b..8b67ff7e144c 100644
--- a/arch/x86/kernel/x86_init.c
+++ b/arch/x86/kernel/x86_init.c
@@ -91,6 +91,7 @@ struct x86_init_ops x86_init __initdata = {
 		.init_platform		= x86_init_noop,
 		.guest_late_init	= x86_init_noop,
 		.x2apic_available	= bool_x86_init_noop,
+		.msi_ext_dest_id	= bool_x86_init_noop,
 		.init_mem_mapping	= x86_init_noop,
 		.init_after_bootmem	= x86_init_noop,
 	},
