xdp: Simplify xdp_return_{frame, frame_rx_napi, buff}

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Björn Töpel <bjorn.topel@intel.com>
commit 82c41671ca4f597b6ff05bd5d118161deec26e07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/82c41671.failed

The xdp_return_{frame,frame_rx_napi,buff} function are never used,
except in xdp_convert_zc_to_xdp_frame(), by the MEM_TYPE_XSK_BUFF_POOL
memory type.

To simplify and reduce code, change so that
xdp_convert_zc_to_xdp_frame() calls xsk_buff_free() directly since the
type is know, and remove MEM_TYPE_XSK_BUFF_POOL from the switch
statement in __xdp_return() function.

	Suggested-by: Maxim Mikityanskiy <maximmi@mellanox.com>
	Signed-off-by: Björn Töpel <bjorn.topel@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200520192103.355233-14-bjorn.topel@gmail.com
(cherry picked from commit 82c41671ca4f597b6ff05bd5d118161deec26e07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/xdp.c
diff --cc net/core/xdp.c
index 81089ebb85ca,90f44f382115..000000000000
--- a/net/core/xdp.c
+++ b/net/core/xdp.c
@@@ -358,10 -335,11 +358,16 @@@ EXPORT_SYMBOL_GPL(xdp_rxq_info_reg_mem_
   * scenarios (e.g. queue full), it is possible to return the xdp_frame
   * while still leveraging this protection.  The @napi_direct boolean
   * is used for those calls sites.  Thus, allowing for faster recycling
-  * of xdp_frames/pages in those cases.
+  * of xdp_frames/pages in those cases. This path is never used by the
+  * MEM_TYPE_XSK_BUFF_POOL memory type, so it's explicitly not part of
+  * the switch-statement.
   */
++<<<<<<< HEAD
 +static void __xdp_return(void *data, struct xdp_mem_info *mem, bool napi_direct,
 +			 unsigned long handle)
++=======
+ static void __xdp_return(void *data, struct xdp_mem_info *mem, bool napi_direct)
++>>>>>>> 82c41671ca4f (xdp: Simplify xdp_return_{frame, frame_rx_napi, buff})
  {
  	struct xdp_mem_allocator *xa;
  	struct page *page;
@@@ -383,36 -361,29 +389,51 @@@
  		page = virt_to_page(data); /* Assumes order0 page*/
  		put_page(page);
  		break;
++<<<<<<< HEAD
 +	case MEM_TYPE_ZERO_COPY:
 +		/* NB! Only valid from an xdp_buff! */
 +		rcu_read_lock();
 +		/* mem->id is valid, checked in xdp_rxq_info_reg_mem_model() */
 +		xa = rhashtable_lookup(mem_id_ht, &mem->id, mem_id_rht_params);
 +		xa->zc_alloc->free(xa->zc_alloc, handle);
 +		rcu_read_unlock();
++=======
++>>>>>>> 82c41671ca4f (xdp: Simplify xdp_return_{frame, frame_rx_napi, buff})
  	default:
  		/* Not possible, checked in xdp_rxq_info_reg_mem_model() */
+ 		WARN(1, "Incorrect XDP memory type (%d) usage", mem->type);
  		break;
  	}
  }
  
  void xdp_return_frame(struct xdp_frame *xdpf)
  {
++<<<<<<< HEAD
 +	__xdp_return(xdpf->data, &xdpf->mem, false, 0);
++=======
+ 	__xdp_return(xdpf->data, &xdpf->mem, false);
++>>>>>>> 82c41671ca4f (xdp: Simplify xdp_return_{frame, frame_rx_napi, buff})
  }
  EXPORT_SYMBOL_GPL(xdp_return_frame);
  
  void xdp_return_frame_rx_napi(struct xdp_frame *xdpf)
  {
++<<<<<<< HEAD
 +	__xdp_return(xdpf->data, &xdpf->mem, true, 0);
++=======
+ 	__xdp_return(xdpf->data, &xdpf->mem, true);
++>>>>>>> 82c41671ca4f (xdp: Simplify xdp_return_{frame, frame_rx_napi, buff})
  }
  EXPORT_SYMBOL_GPL(xdp_return_frame_rx_napi);
  
  void xdp_return_buff(struct xdp_buff *xdp)
  {
++<<<<<<< HEAD
 +	__xdp_return(xdp->data, &xdp->rxq->mem, true, xdp->handle);
++=======
+ 	__xdp_return(xdp->data, &xdp->rxq->mem, true);
++>>>>>>> 82c41671ca4f (xdp: Simplify xdp_return_{frame, frame_rx_napi, buff})
  }
- EXPORT_SYMBOL_GPL(xdp_return_buff);
  
  /* Only called for MEM_TYPE_PAGE_POOL see xdp.h */
  void __xdp_release_frame(void *data, struct xdp_mem_info *mem)
* Unmerged path net/core/xdp.c
