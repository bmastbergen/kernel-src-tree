KVM: VMX: Rename vmx_uret_msr's "index" to "slot"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 802145c56a0445bba39de481214302eb3d34e4fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/802145c5.failed

Rename "index" to "slot" in struct vmx_uret_msr to align with the
terminology used by common x86's kvm_user_return_msrs, and to avoid
conflating "MSR's ECX index" with "MSR's index into an array".

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200923180409.32255-16-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 802145c56a0445bba39de481214302eb3d34e4fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/vmx/vmx.h
diff --cc arch/x86/kvm/vmx/vmx.c
index 985a4bfb7517,58fb403ccd1c..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -615,8 -615,8 +615,13 @@@ static inline int __find_msr_index(stru
  {
  	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < vmx->nmsrs; ++i)
 +		if (vmx_msr_index[vmx->guest_msrs[i].index] == msr)
++=======
+ 	for (i = 0; i < vmx->nr_uret_msrs; ++i)
+ 		if (vmx_uret_msrs_list[vmx->guest_uret_msrs[i].slot] == msr)
++>>>>>>> 802145c56a04 (KVM: VMX: Rename vmx_uret_msr's "index" to "slot")
  			return i;
  	return -1;
  }
@@@ -637,9 -638,9 +642,9 @@@ static int vmx_set_guest_msr(struct vcp
  
  	u64 old_msr_data = msr->data;
  	msr->data = data;
 -	if (msr - vmx->guest_uret_msrs < vmx->nr_active_uret_msrs) {
 +	if (msr - vmx->guest_msrs < vmx->save_nmsrs) {
  		preempt_disable();
- 		ret = kvm_set_user_return_msr(msr->index, msr->data, msr->mask);
+ 		ret = kvm_set_user_return_msr(msr->slot, msr->data, msr->mask);
  		preempt_enable();
  		if (ret)
  			msr->data = old_msr_data;
@@@ -1146,12 -1140,12 +1151,21 @@@ void vmx_prepare_switch_to_guest(struc
  	 * when guest state is loaded. This happens when guest transitions
  	 * to/from long-mode by setting MSR_EFER.LMA.
  	 */
++<<<<<<< HEAD
 +	if (!vmx->guest_msrs_ready) {
 +		vmx->guest_msrs_ready = true;
 +		for (i = 0; i < vmx->save_nmsrs; ++i)
 +			kvm_set_user_return_msr(vmx->guest_msrs[i].index,
 +						vmx->guest_msrs[i].data,
 +						vmx->guest_msrs[i].mask);
++=======
+ 	if (!vmx->guest_uret_msrs_loaded) {
+ 		vmx->guest_uret_msrs_loaded = true;
+ 		for (i = 0; i < vmx->nr_active_uret_msrs; ++i)
+ 			kvm_set_user_return_msr(vmx->guest_uret_msrs[i].slot,
+ 						vmx->guest_uret_msrs[i].data,
+ 						vmx->guest_uret_msrs[i].mask);
++>>>>>>> 802145c56a04 (KVM: VMX: Rename vmx_uret_msr's "index" to "slot")
  
  	}
  
@@@ -6788,9 -6729,9 +6802,14 @@@ static int vmx_create_vcpu(struct kvm_v
  			continue;
  		if (wrmsr_safe(index, data_low, data_high) < 0)
  			continue;
 +		vmx->guest_msrs[j].index = i;
 +		vmx->guest_msrs[j].data = 0;
  
++<<<<<<< HEAD
++=======
+ 		vmx->guest_uret_msrs[j].slot = i;
+ 		vmx->guest_uret_msrs[j].data = 0;
++>>>>>>> 802145c56a04 (KVM: VMX: Rename vmx_uret_msr's "index" to "slot")
  		switch (index) {
  		case MSR_IA32_TSX_CTRL:
  			/*
diff --cc arch/x86/kvm/vmx/vmx.h
index 131d638ba270,fc63ff43929f..000000000000
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@@ -34,8 -35,8 +34,13 @@@ struct vmx_msrs 
  	struct vmx_msr_entry	val[MAX_NR_LOADSTORE_MSRS];
  };
  
++<<<<<<< HEAD
 +struct shared_msr_entry {
 +	unsigned index;
++=======
+ struct vmx_uret_msr {
+ 	unsigned int slot; /* The MSR's slot in kvm_user_return_msrs. */
++>>>>>>> 802145c56a04 (KVM: VMX: Rename vmx_uret_msr's "index" to "slot")
  	u64 data;
  	u64 mask;
  };
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
