perf/core: Replace zero-length array with flexible-array

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Gustavo A. R. Silva <gustavoars@kernel.org>
commit c50c75e9b87946499a62bffc021e95c87a1d57cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c50c75e9.failed

The current codebase makes use of the zero-length array language
extension to the C90 standard, but the preferred mechanism to declare
variable-length types such as these ones is a flexible array member[1][2],
introduced in C99:

struct foo {
        int stuff;
        struct boo array[];
};

By making use of the mechanism above, we will get a compiler warning
in case the flexible array does not occur last in the structure, which
will help us prevent some kind of undefined behavior bugs from being
inadvertently introduced[3] to the codebase from now on.

Also, notice that, dynamic memory allocations won't be affected by
this change:

"Flexible array members have incomplete type, and so the sizeof operator
may not be applied. As a quirk of the original implementation of
zero-length arrays, sizeof evaluates to zero."[1]

sizeof(flexible-array-member) triggers a warning because flexible array
members have incomplete type[1]. There are some instances of code in
which the sizeof operator is being incorrectly/erroneously applied to
zero-length arrays and the result is zero. Such instances may be hiding
some bugs. So, this work (flexible-array member conversions) will also
help to get completely rid of those sorts of issues.

This issue was found with the help of Coccinelle.

[1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
[2] https://github.com/KSPP/linux/issues/21
[3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")

	Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200511201227.GA14041@embeddedor
(cherry picked from commit c50c75e9b87946499a62bffc021e95c87a1d57cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/perf_event.h
diff --cc include/linux/perf_event.h
index 56e4dcad2112,d7b610c4eebd..000000000000
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@@ -111,8 -112,8 +111,13 @@@ struct perf_raw_record 
   */
  struct perf_branch_stack {
  	__u64				nr;
++<<<<<<< HEAD
 +	RH_KABI_BROKEN_INSERT(__u64				hw_idx)
 +	struct perf_branch_entry	entries[0];
++=======
+ 	__u64				hw_idx;
+ 	struct perf_branch_entry	entries[];
++>>>>>>> c50c75e9b879 (perf/core: Replace zero-length array with flexible-array)
  };
  
  struct task_struct;
* Unmerged path include/linux/perf_event.h
diff --git a/kernel/events/callchain.c b/kernel/events/callchain.c
index ee38c5bc1252..887ec11a523e 100644
--- a/kernel/events/callchain.c
+++ b/kernel/events/callchain.c
@@ -16,7 +16,7 @@
 
 struct callchain_cpus_entries {
 	struct rcu_head			rcu_head;
-	struct perf_callchain_entry	*cpu_entries[0];
+	struct perf_callchain_entry	*cpu_entries[];
 };
 
 int sysctl_perf_event_max_stack __read_mostly = PERF_MAX_STACK_DEPTH;
diff --git a/kernel/events/internal.h b/kernel/events/internal.h
index 747d67f130cb..fa733ed72e62 100644
--- a/kernel/events/internal.h
+++ b/kernel/events/internal.h
@@ -55,7 +55,7 @@ struct ring_buffer {
 	void				*aux_priv;
 
 	struct perf_event_mmap_page	*user_page;
-	void				*data_pages[0];
+	void				*data_pages[];
 };
 
 extern void rb_free(struct ring_buffer *rb);
