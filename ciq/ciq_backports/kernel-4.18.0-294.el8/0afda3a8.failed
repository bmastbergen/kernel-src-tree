locking/lockdep: Cure noinstr fail

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 0afda3a888dccf12557b41ef42eee942327d122b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0afda3a8.failed

When the compiler doesn't feel like inlining, it causes a noinstr
fail:

  vmlinux.o: warning: objtool: lock_is_held_type()+0xb: call to lockdep_enabled() leaves .noinstr.text section

Fixes: 4d004099a668 ("lockdep: Fix lockdep recursion")
	Reported-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20210106144017.592595176@infradead.org

(cherry picked from commit 0afda3a888dccf12557b41ef42eee942327d122b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/lockdep.c
diff --cc kernel/locking/lockdep.c
index 5607d115b751,02bc5b8f1eb2..000000000000
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@@ -74,6 -76,23 +74,26 @@@ module_param(lock_stat, int, 0644)
  #define lock_stat 0
  #endif
  
++<<<<<<< HEAD
++=======
+ DEFINE_PER_CPU(unsigned int, lockdep_recursion);
+ EXPORT_PER_CPU_SYMBOL_GPL(lockdep_recursion);
+ 
+ static __always_inline bool lockdep_enabled(void)
+ {
+ 	if (!debug_locks)
+ 		return false;
+ 
+ 	if (this_cpu_read(lockdep_recursion))
+ 		return false;
+ 
+ 	if (current->lockdep_recursion)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> 0afda3a888dc (locking/lockdep: Cure noinstr fail)
  /*
   * lockdep_lock: protects the lockdep graph, the hashes and the
   *               class/list/hash allocators.
* Unmerged path kernel/locking/lockdep.c
