powerpc/ptrace: split out SPE related functions.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [powerpc] powerpc/ptrace: split out SPE related functions (Desnes Augusto Nunes do Rosario) [1854528]
Rebuild_FUZZ: 98.95%
commit-author Christophe Leroy <christophe.leroy@c-s.fr>
commit 60ef9dbd9d2ada53f488f75ae7fef13bb4962636
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/60ef9dbd.failed

Move CONFIG_SPE functions out of ptrace.c, into
ptrace-spe.c

	Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/0f17a331760310b5562fae3791cdd3cf9c64237b.1582848567.git.christophe.leroy@c-s.fr
(cherry picked from commit 60ef9dbd9d2ada53f488f75ae7fef13bb4962636)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/ptrace-spe.c
#	arch/powerpc/kernel/ptrace.c
#	arch/powerpc/kernel/ptrace/Makefile
#	arch/powerpc/kernel/ptrace/ptrace-decl.h
diff --cc arch/powerpc/kernel/ptrace.c
index c48b84f0c17a,ca2b4d804992..000000000000
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@@ -403,365 -403,6 +403,368 @@@ static int gpr_set(struct task_struct *
  	return ret;
  }
  
++<<<<<<< HEAD:arch/powerpc/kernel/ptrace.c
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last checkpointed
 + * value of all FPR registers for the current transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + * };
 + */
 +static int fpr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +#ifdef CONFIG_VSX
 +	u64 buf[33];
 +	int i;
 +
 +	flush_fp_to_thread(target);
 +
 +	/* copy to local buffer then write that out */
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.TS_FPR(i);
 +	buf[32] = target->thread.fp_state.fpscr;
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +#else
 +	BUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=
 +		     offsetof(struct thread_fp_state, fpr[32]));
 +
 +	flush_fp_to_thread(target);
 +
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				   &target->thread.fp_state, 0, -1);
 +#endif
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last checkpointed
 + * value of all FPR registers for the current transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + * };
 + *
 + */
 +static int fpr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +#ifdef CONFIG_VSX
 +	u64 buf[33];
 +	int i;
 +
 +	flush_fp_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.TS_FPR(i);
 +	buf[32] = target->thread.fp_state.fpscr;
 +
 +	/* copy to local buffer then write that out */
 +	i = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +	if (i)
 +		return i;
 +
 +	for (i = 0; i < 32 ; i++)
 +		target->thread.TS_FPR(i) = buf[i];
 +	target->thread.fp_state.fpscr = buf[32];
 +	return 0;
 +#else
 +	BUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=
 +		     offsetof(struct thread_fp_state, fpr[32]));
 +
 +	flush_fp_to_thread(target);
 +
 +	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.fp_state, 0, -1);
 +#endif
 +}
 +
 +#ifdef CONFIG_ALTIVEC
 +/*
 + * Get/set all the altivec registers vr0..vr31, vscr, vrsave, in one go.
 + * The transfer totals 34 quadword.  Quadwords 0-31 contain the
 + * corresponding vector registers.  Quadword 32 contains the vscr as the
 + * last word (offset 12) within that quadword.  Quadword 33 contains the
 + * vrsave as the first word (offset 0) within the quadword.
 + *
 + * This definition of the VMX state is compatible with the current PPC32
 + * ptrace interface.  This allows signal handling and ptrace to use the
 + * same structures.  This also simplifies the implementation of a bi-arch
 + * (combined (32- and 64-bit) gdb.
 + */
 +
 +static int vr_active(struct task_struct *target,
 +		     const struct user_regset *regset)
 +{
 +	flush_altivec_to_thread(target);
 +	return target->thread.used_vr ? regset->n : 0;
 +}
 +
 +/*
 + * Regardless of transactions, 'vr_state' holds the current running
 + * value of all the VMX registers and 'ckvr_state' holds the last
 + * checkpointed value of all the VMX registers for the current
 + * transaction to fall back on in case it aborts.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + * };
 + */
 +static int vr_get(struct task_struct *target, const struct user_regset *regset,
 +		  unsigned int pos, unsigned int count,
 +		  void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_altivec_to_thread(target);
 +
 +	BUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=
 +		     offsetof(struct thread_vr_state, vr[32]));
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.vr_state, 0,
 +				  33 * sizeof(vector128));
 +	if (!ret) {
 +		/*
 +		 * Copy out only the low-order word of vrsave.
 +		 */
 +		int start, end;
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +
 +		vrsave.word = target->thread.vrsave;
 +
 +		start = 33 * sizeof(vector128);
 +		end = start + sizeof(vrsave);
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,
 +					  start, end);
 +	}
 +
 +	return ret;
 +}
 +
 +/*
 + * Regardless of transactions, 'vr_state' holds the current running
 + * value of all the VMX registers and 'ckvr_state' holds the last
 + * checkpointed value of all the VMX registers for the current
 + * transaction to fall back on in case it aborts.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + * };
 + */
 +static int vr_set(struct task_struct *target, const struct user_regset *regset,
 +		  unsigned int pos, unsigned int count,
 +		  const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_altivec_to_thread(target);
 +
 +	BUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=
 +		     offsetof(struct thread_vr_state, vr[32]));
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &target->thread.vr_state, 0,
 +				 33 * sizeof(vector128));
 +	if (!ret && count > 0) {
 +		/*
 +		 * We use only the first word of vrsave.
 +		 */
 +		int start, end;
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +
 +		vrsave.word = target->thread.vrsave;
 +
 +		start = 33 * sizeof(vector128);
 +		end = start + sizeof(vrsave);
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,
 +					 start, end);
 +		if (!ret)
 +			target->thread.vrsave = vrsave.word;
 +	}
 +
 +	return ret;
 +}
 +#endif /* CONFIG_ALTIVEC */
 +
 +#ifdef CONFIG_VSX
 +/*
 + * Currently to set and and get all the vsx state, you need to call
 + * the fp and VMX calls as well.  This only get/sets the lower 32
 + * 128bit VSX registers.
 + */
 +
 +static int vsr_active(struct task_struct *target,
 +		      const struct user_regset *regset)
 +{
 +	flush_vsx_to_thread(target);
 +	return target->thread.used_vsr ? regset->n : 0;
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last
 + * checkpointed value of all FPR registers for the current
 + * transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	vsx[32];
 + * };
 + */
 +static int vsr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret, i;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  buf, 0, 32 * sizeof(double));
 +
 +	return ret;
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last
 + * checkpointed value of all FPR registers for the current
 + * transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	vsx[32];
 + * };
 + */
 +static int vsr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret,i;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 buf, 0, 32 * sizeof(double));
 +	if (!ret)
 +		for (i = 0; i < 32 ; i++)
 +			target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];
 +
 +	return ret;
 +}
 +#endif /* CONFIG_VSX */
 +
 +#ifdef CONFIG_SPE
 +
 +/*
 + * For get_evrregs/set_evrregs functions 'data' has the following layout:
 + *
 + * struct {
 + *   u32 evr[32];
 + *   u64 acc;
 + *   u32 spefscr;
 + * }
 + */
 +
 +static int evr_active(struct task_struct *target,
 +		      const struct user_regset *regset)
 +{
 +	flush_spe_to_thread(target);
 +	return target->thread.used_spe ? regset->n : 0;
 +}
 +
 +static int evr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_spe_to_thread(target);
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.evr,
 +				  0, sizeof(target->thread.evr));
 +
 +	BUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=
 +		     offsetof(struct thread_struct, spefscr));
 +
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					  &target->thread.acc,
 +					  sizeof(target->thread.evr), -1);
 +
 +	return ret;
 +}
 +
 +static int evr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_spe_to_thread(target);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &target->thread.evr,
 +				 0, sizeof(target->thread.evr));
 +
 +	BUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=
 +		     offsetof(struct thread_struct, spefscr));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					 &target->thread.acc,
 +					 sizeof(target->thread.evr), -1);
 +
 +	return ret;
 +}
 +#endif /* CONFIG_SPE */
 +
++=======
++>>>>>>> 60ef9dbd9d2a (powerpc/ptrace: split out SPE related functions.):arch/powerpc/kernel/ptrace/ptrace.c
  #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
  /**
   * tm_cgpr_active - get active number of registers in CGPR
* Unmerged path arch/powerpc/kernel/ptrace-spe.c
* Unmerged path arch/powerpc/kernel/ptrace/Makefile
* Unmerged path arch/powerpc/kernel/ptrace/ptrace-decl.h
* Unmerged path arch/powerpc/kernel/ptrace-spe.c
* Unmerged path arch/powerpc/kernel/ptrace.c
* Unmerged path arch/powerpc/kernel/ptrace/Makefile
* Unmerged path arch/powerpc/kernel/ptrace/ptrace-decl.h
