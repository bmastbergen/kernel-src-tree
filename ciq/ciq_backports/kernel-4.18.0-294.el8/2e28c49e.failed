fuse: switch to use errorfc() et.al.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [fs] fuse: switch to use errorfc() et.al (Vivek Goyal) [1783467]
Rebuild_FUZZ: 98.59%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 2e28c49ea648d29c3d7b625ea6996addf28335ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2e28c49e.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 2e28c49ea648d29c3d7b625ea6996addf28335ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/inode.c
diff --cc fs/fuse/inode.c
index 10b75246113a,557611dc2d46..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -452,111 -448,104 +452,183 @@@ enum 
  	OPT_ERR
  };
  
 -static const struct fs_parameter_spec fuse_fs_parameters[] = {
 -	fsparam_string	("source",		OPT_SOURCE),
 -	fsparam_u32	("fd",			OPT_FD),
 -	fsparam_u32oct	("rootmode",		OPT_ROOTMODE),
 -	fsparam_u32	("user_id",		OPT_USER_ID),
 -	fsparam_u32	("group_id",		OPT_GROUP_ID),
 -	fsparam_flag	("default_permissions",	OPT_DEFAULT_PERMISSIONS),
 -	fsparam_flag	("allow_other",		OPT_ALLOW_OTHER),
 -	fsparam_u32	("max_read",		OPT_MAX_READ),
 -	fsparam_u32	("blksize",		OPT_BLKSIZE),
 -	fsparam_string	("subtype",		OPT_SUBTYPE),
 -	{}
 +static const match_table_t tokens = {
 +	{OPT_FD,			"fd=%u"},
 +	{OPT_ROOTMODE,			"rootmode=%o"},
 +	{OPT_USER_ID,			"user_id=%u"},
 +	{OPT_GROUP_ID,			"group_id=%u"},
 +	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
 +	{OPT_ALLOW_OTHER,		"allow_other"},
 +	{OPT_MAX_READ,			"max_read=%u"},
 +	{OPT_BLKSIZE,			"blksize=%u"},
 +	{OPT_ERR,			NULL}
  };
  
 -static int fuse_parse_param(struct fs_context *fc, struct fs_parameter *param)
 +static int fuse_match_uint(substring_t *s, unsigned int *res)
  {
++<<<<<<< HEAD
 +	int err = -ENOMEM;
 +	char *buf = match_strdup(s);
 +	if (buf) {
 +		err = kstrtouint(buf, 10, res);
 +		kfree(buf);
++=======
+ 	struct fs_parse_result result;
+ 	struct fuse_fs_context *ctx = fc->fs_private;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, fuse_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case OPT_SOURCE:
+ 		if (fc->source)
+ 			return invalfc(fc, "Multiple sources specified");
+ 		fc->source = param->string;
+ 		param->string = NULL;
+ 		break;
+ 
+ 	case OPT_SUBTYPE:
+ 		if (ctx->subtype)
+ 			return invalfc(fc, "Multiple subtypes specified");
+ 		ctx->subtype = param->string;
+ 		param->string = NULL;
+ 		return 0;
+ 
+ 	case OPT_FD:
+ 		ctx->fd = result.uint_32;
+ 		ctx->fd_present = 1;
+ 		break;
+ 
+ 	case OPT_ROOTMODE:
+ 		if (!fuse_valid_type(result.uint_32))
+ 			return invalfc(fc, "Invalid rootmode");
+ 		ctx->rootmode = result.uint_32;
+ 		ctx->rootmode_present = 1;
+ 		break;
+ 
+ 	case OPT_USER_ID:
+ 		ctx->user_id = make_kuid(fc->user_ns, result.uint_32);
+ 		if (!uid_valid(ctx->user_id))
+ 			return invalfc(fc, "Invalid user_id");
+ 		ctx->user_id_present = 1;
+ 		break;
+ 
+ 	case OPT_GROUP_ID:
+ 		ctx->group_id = make_kgid(fc->user_ns, result.uint_32);
+ 		if (!gid_valid(ctx->group_id))
+ 			return invalfc(fc, "Invalid group_id");
+ 		ctx->group_id_present = 1;
+ 		break;
+ 
+ 	case OPT_DEFAULT_PERMISSIONS:
+ 		ctx->default_permissions = 1;
+ 		break;
+ 
+ 	case OPT_ALLOW_OTHER:
+ 		ctx->allow_other = 1;
+ 		break;
+ 
+ 	case OPT_MAX_READ:
+ 		ctx->max_read = result.uint_32;
+ 		break;
+ 
+ 	case OPT_BLKSIZE:
+ 		if (!ctx->is_bdev)
+ 			return invalfc(fc, "blksize only supported for fuseblk");
+ 		ctx->blksize = result.uint_32;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
++>>>>>>> 2e28c49ea648 (fuse: switch to use errorfc() et.al.)
  	}
 -
 -	return 0;
 +	return err;
  }
  
 -static void fuse_free_fc(struct fs_context *fc)
 +static int parse_fuse_opt(char *opt, struct fuse_fs_context *d, int is_bdev,
 +			  struct user_namespace *user_ns)
  {
 -	struct fuse_fs_context *ctx = fc->fs_private;
 -
 -	if (ctx) {
 -		kfree(ctx->subtype);
 -		kfree(ctx);
 +	char *p;
 +	memset(d, 0, sizeof(struct fuse_fs_context));
 +	d->max_read = ~0;
 +	d->blksize = FUSE_DEFAULT_BLKSIZE;
 +
 +	while ((p = strsep(&opt, ",")) != NULL) {
 +		int token;
 +		int value;
 +		unsigned uv;
 +		substring_t args[MAX_OPT_ARGS];
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case OPT_FD:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->fd = value;
 +			d->fd_present = 1;
 +			break;
 +
 +		case OPT_ROOTMODE:
 +			if (match_octal(&args[0], &value))
 +				return 0;
 +			if (!fuse_valid_type(value))
 +				return 0;
 +			d->rootmode = value;
 +			d->rootmode_present = 1;
 +			break;
 +
 +		case OPT_USER_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->user_id = make_kuid(user_ns, uv);
 +			if (!uid_valid(d->user_id))
 +				return 0;
 +			d->user_id_present = 1;
 +			break;
 +
 +		case OPT_GROUP_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->group_id = make_kgid(user_ns, uv);
 +			if (!gid_valid(d->group_id))
 +				return 0;
 +			d->group_id_present = 1;
 +			break;
 +
 +		case OPT_DEFAULT_PERMISSIONS:
 +			d->default_permissions = 1;
 +			break;
 +
 +		case OPT_ALLOW_OTHER:
 +			d->allow_other = 1;
 +			break;
 +
 +		case OPT_MAX_READ:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->max_read = value;
 +			break;
 +
 +		case OPT_BLKSIZE:
 +			if (!is_bdev || match_int(&args[0], &value))
 +				return 0;
 +			d->blksize = value;
 +			break;
 +
 +		default:
 +			return 0;
 +		}
  	}
 +
 +	if (!d->fd_present || !d->rootmode_present ||
 +	    !d->user_id_present || !d->group_id_present)
 +		return 0;
 +
 +	return 1;
  }
  
  static int fuse_show_options(struct seq_file *m, struct dentry *root)
* Unmerged path fs/fuse/inode.c
