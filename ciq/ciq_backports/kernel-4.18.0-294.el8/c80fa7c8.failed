vfs: Provide sb->s_iflags settings in fs_context struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit c80fa7c8301c10ad10d997b9e86b4aeac5923b3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c80fa7c8.failed

Provide a field in the fs_context struct through which bits in the
sb->s_iflags superblock field can be set.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: linux-fsdevel@vger.kernel.org
(cherry picked from commit c80fa7c8301c10ad10d997b9e86b4aeac5923b3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/super.c
#	include/linux/fs_context.h
diff --cc fs/super.c
index 72596c26684f,f836b67abffe..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -478,6 -476,92 +478,95 @@@ void generic_shutdown_super(struct supe
  
  EXPORT_SYMBOL(generic_shutdown_super);
  
++<<<<<<< HEAD
++=======
+ bool mount_capable(struct fs_context *fc)
+ {
+ 	struct user_namespace *user_ns = fc->global ? &init_user_ns
+ 						    : fc->user_ns;
+ 
+ 	if (!(fc->fs_type->fs_flags & FS_USERNS_MOUNT))
+ 		return capable(CAP_SYS_ADMIN);
+ 	else
+ 		return ns_capable(user_ns, CAP_SYS_ADMIN);
+ }
+ 
+ /**
+  * sget_fc - Find or create a superblock
+  * @fc:	Filesystem context.
+  * @test: Comparison callback
+  * @set: Setup callback
+  *
+  * Find or create a superblock using the parameters stored in the filesystem
+  * context and the two callback functions.
+  *
+  * If an extant superblock is matched, then that will be returned with an
+  * elevated reference count that the caller must transfer or discard.
+  *
+  * If no match is made, a new superblock will be allocated and basic
+  * initialisation will be performed (s_type, s_fs_info and s_id will be set and
+  * the set() callback will be invoked), the superblock will be published and it
+  * will be returned in a partially constructed state with SB_BORN and SB_ACTIVE
+  * as yet unset.
+  */
+ struct super_block *sget_fc(struct fs_context *fc,
+ 			    int (*test)(struct super_block *, struct fs_context *),
+ 			    int (*set)(struct super_block *, struct fs_context *))
+ {
+ 	struct super_block *s = NULL;
+ 	struct super_block *old;
+ 	struct user_namespace *user_ns = fc->global ? &init_user_ns : fc->user_ns;
+ 	int err;
+ 
+ retry:
+ 	spin_lock(&sb_lock);
+ 	if (test) {
+ 		hlist_for_each_entry(old, &fc->fs_type->fs_supers, s_instances) {
+ 			if (test(old, fc))
+ 				goto share_extant_sb;
+ 		}
+ 	}
+ 	if (!s) {
+ 		spin_unlock(&sb_lock);
+ 		s = alloc_super(fc->fs_type, fc->sb_flags, user_ns);
+ 		if (!s)
+ 			return ERR_PTR(-ENOMEM);
+ 		goto retry;
+ 	}
+ 
+ 	s->s_fs_info = fc->s_fs_info;
+ 	err = set(s, fc);
+ 	if (err) {
+ 		s->s_fs_info = NULL;
+ 		spin_unlock(&sb_lock);
+ 		destroy_unused_super(s);
+ 		return ERR_PTR(err);
+ 	}
+ 	fc->s_fs_info = NULL;
+ 	s->s_type = fc->fs_type;
+ 	s->s_iflags |= fc->s_iflags;
+ 	strlcpy(s->s_id, s->s_type->name, sizeof(s->s_id));
+ 	list_add_tail(&s->s_list, &super_blocks);
+ 	hlist_add_head(&s->s_instances, &s->s_type->fs_supers);
+ 	spin_unlock(&sb_lock);
+ 	get_filesystem(s->s_type);
+ 	register_shrinker_prepared(&s->s_shrink);
+ 	return s;
+ 
+ share_extant_sb:
+ 	if (user_ns != old->s_user_ns) {
+ 		spin_unlock(&sb_lock);
+ 		destroy_unused_super(s);
+ 		return ERR_PTR(-EBUSY);
+ 	}
+ 	if (!grab_super(old))
+ 		goto retry;
+ 	destroy_unused_super(s);
+ 	return old;
+ }
+ EXPORT_SYMBOL(sget_fc);
+ 
++>>>>>>> c80fa7c8301c (vfs: Provide sb->s_iflags settings in fs_context struct)
  /**
   *	sget_userns -	find or create a superblock
   *	@type:	filesystem type superblock should belong to
* Unmerged path include/linux/fs_context.h
* Unmerged path fs/super.c
* Unmerged path include/linux/fs_context.h
