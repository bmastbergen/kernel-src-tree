mmap locking API: add mmap_read_trylock_non_owner()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michel Lespinasse <walken@google.com>
commit 0cc55a0213a02b760ade1d4755fdccfbf7d3157e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0cc55a02.failed

Add a couple APIs used by kernel/bpf/stackmap.c only:
- mmap_read_trylock_non_owner()
- mmap_read_unlock_non_owner() (may be called from a work queue).

It's still not ideal that bpf/stackmap subverts the lock ownership in this
way.  Thanks to Peter Zijlstra for suggesting this API as the least-ugly
way of addressing this in the short term.

	Signed-off-by: Michel Lespinasse <walken@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
	Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
	Reviewed-by: Davidlohr Bueso <dbueso@suse.de>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Jason Gunthorpe <jgg@ziepe.ca>
	Cc: Jerome Glisse <jglisse@redhat.com>
	Cc: John Hubbard <jhubbard@nvidia.com>
	Cc: Laurent Dufour <ldufour@linux.ibm.com>
	Cc: Liam Howlett <Liam.Howlett@oracle.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Ying Han <yinghan@google.com>
Link: http://lkml.kernel.org/r/20200520052908.204642-8-walken@google.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0cc55a0213a02b760ade1d4755fdccfbf7d3157e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/stackmap.c
diff --cc kernel/bpf/stackmap.c
index 4153fd4ee538,599488f25e40..000000000000
--- a/kernel/bpf/stackmap.c
+++ b/kernel/bpf/stackmap.c
@@@ -320,7 -316,7 +319,11 @@@ static void stack_map_get_build_id_offs
  	 * with build_id.
  	 */
  	if (!user || !current || !current->mm || irq_work_busy ||
++<<<<<<< HEAD
 +	    down_read_trylock(&current->mm->mmap_sem) == 0) {
++=======
+ 	    !mmap_read_trylock_non_owner(current->mm)) {
++>>>>>>> 0cc55a0213a0 (mmap locking API: add mmap_read_trylock_non_owner())
  		/* cannot access current->mm, fall back to ips */
  		for (i = 0; i < trace_nr; i++) {
  			id_offs[i].status = BPF_STACK_BUILD_ID_IP;
@@@ -345,16 -341,10 +348,14 @@@
  	}
  
  	if (!work) {
++<<<<<<< HEAD
 +		up_read(&current->mm->mmap_sem);
++=======
+ 		mmap_read_unlock_non_owner(current->mm);
++>>>>>>> 0cc55a0213a0 (mmap locking API: add mmap_read_trylock_non_owner())
  	} else {
- 		work->sem = &current->mm->mmap_sem;
+ 		work->mm = current->mm;
  		irq_work_queue(&work->irq_work);
- 		/*
- 		 * The irq_work will release the mmap_sem with
- 		 * up_read_non_owner(). The rwsem_release() is called
- 		 * here to release the lock from lockdep's perspective.
- 		 */
- 		rwsem_release(&current->mm->mmap_sem.dep_map, _RET_IP_);
  	}
  }
  
diff --git a/include/linux/mmap_lock.h b/include/linux/mmap_lock.h
index 97ac53b66052..424a43c06c0d 100644
--- a/include/linux/mmap_lock.h
+++ b/include/linux/mmap_lock.h
@@ -51,4 +51,18 @@ static inline void mmap_read_unlock(struct mm_struct *mm)
 	up_read(&mm->mmap_sem);
 }
 
+static inline bool mmap_read_trylock_non_owner(struct mm_struct *mm)
+{
+	if (down_read_trylock(&mm->mmap_sem)) {
+		rwsem_release(&mm->mmap_sem.dep_map, _RET_IP_);
+		return true;
+	}
+	return false;
+}
+
+static inline void mmap_read_unlock_non_owner(struct mm_struct *mm)
+{
+	up_read_non_owner(&mm->mmap_sem);
+}
+
 #endif /* _LINUX_MMAP_LOCK_H */
* Unmerged path kernel/bpf/stackmap.c
