driver core: Look for waiting consumers only for a fwnode's primary device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 5f5377eaddfc24e5d7562e588d0ff84f9264d7c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5f5377ea.failed

Commit 4dbe191c046e ("driver core: Add device links from fwnode only for
the primary device") skipped linking a fwnode's secondary device to
the suppliers listed in its fwnode.

However, a fwnode's secondary device can't be found using
get_dev_from_fwnode(). So, there's no point in trying to see if devices
waiting for suppliers might want to link to a fwnode's secondary device.

This commit removes that unnecessary step for devices that aren't a
fwnode's primary device and also moves the code to a more appropriate
part of the file.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20200515053500.215929-3-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 5f5377eaddfc24e5d7562e588d0ff84f9264d7c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
diff --cc drivers/base/core.c
index a7a93bf98225,f585d92e09d0..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -2175,8 -2522,25 +2190,28 @@@ int device_add(struct device *dev
  
  	kobject_uevent(&dev->kobj, KOBJ_ADD);
  
 -	if (dev->fwnode && !dev->fwnode->dev) {
 +	if (dev->fwnode && !dev->fwnode->dev)
  		dev->fwnode->dev = dev;
++<<<<<<< HEAD
++=======
+ 		is_fwnode_dev = true;
+ 	}
+ 
+ 	/*
+ 	 * Check if any of the other devices (consumers) have been waiting for
+ 	 * this device (supplier) to be added so that they can create a device
+ 	 * link to it.
+ 	 *
+ 	 * This needs to happen after device_pm_add() because device_link_add()
+ 	 * requires the supplier be registered before it's called.
+ 	 *
+ 	 * But this also needs to happe before bus_probe_device() to make sure
+ 	 * waiting consumers can link to it before the driver is bound to the
+ 	 * device and the driver sync_state callback is called for this device.
+ 	 */
+ 	if (is_fwnode_dev)
+ 		fw_devlink_link_device(dev);
++>>>>>>> 5f5377eaddfc (driver core: Look for waiting consumers only for a fwnode's primary device)
  
  	bus_probe_device(dev);
  	if (parent)
* Unmerged path drivers/base/core.c
