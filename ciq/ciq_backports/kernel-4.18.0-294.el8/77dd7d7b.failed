scsi: lpfc: Fix less-than-zero comparison of unsigned value

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Dick Kennedy <dick.kennedy@broadcom.com>
commit 77dd7d7b344283a3bce334d0f43fc2c0629ffe48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/77dd7d7b.failed

The expression start_idx - dbg_cnt is evaluated using unsigned int
arthithmetic (since these variables are unsigned ints) and hence can never
be less than zero, so the less than comparison is never true.  Rewrite the
expression to check for start_idx being less than dbg_cnt.

After the logic was corrected, temp_idx wasn't working correctly. So fix it
as well.

Link: https://lore.kernel.org/r/20200706204246.130416-1-jsmart2021@gmail.com
Fixes: 372c187b8a70 ("scsi: lpfc: Add an internal trace log buffer")
CC: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <jsmart2021@gmail.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Addresses-Coverity: ("Unsigned compared against 0")
(cherry picked from commit 77dd7d7b344283a3bce334d0f43fc2c0629ffe48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_init.c
diff --cc drivers/scsi/lpfc/lpfc_init.c
index 5e4be6802261,f3656bdcb582..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -13962,6 -14136,84 +13962,87 @@@ cpuhp_failure
  	return error;
  }
  
++<<<<<<< HEAD
++=======
+ void lpfc_dmp_dbg(struct lpfc_hba *phba)
+ {
+ 	unsigned int start_idx;
+ 	unsigned int dbg_cnt;
+ 	unsigned int temp_idx;
+ 	int i;
+ 	int j = 0;
+ 	unsigned long rem_nsec;
+ 
+ 	if (phba->cfg_log_verbose)
+ 		return;
+ 
+ 	if (atomic_cmpxchg(&phba->dbg_log_dmping, 0, 1) != 0)
+ 		return;
+ 
+ 	start_idx = (unsigned int)atomic_read(&phba->dbg_log_idx) % DBG_LOG_SZ;
+ 	dbg_cnt = (unsigned int)atomic_read(&phba->dbg_log_cnt);
+ 	temp_idx = start_idx;
+ 	if (dbg_cnt >= DBG_LOG_SZ) {
+ 		dbg_cnt = DBG_LOG_SZ;
+ 		temp_idx -= 1;
+ 	} else {
+ 		if ((start_idx + dbg_cnt) > (DBG_LOG_SZ - 1)) {
+ 			temp_idx = (start_idx + dbg_cnt) % DBG_LOG_SZ;
+ 		} else {
+ 			if (start_idx < dbg_cnt)
+ 				start_idx = DBG_LOG_SZ - (dbg_cnt - start_idx);
+ 			else
+ 				start_idx -= dbg_cnt;
+ 		}
+ 	}
+ 	dev_info(&phba->pcidev->dev, "start %d end %d cnt %d\n",
+ 		 start_idx, temp_idx, dbg_cnt);
+ 
+ 	for (i = 0; i < dbg_cnt; i++) {
+ 		if ((start_idx + i) < DBG_LOG_SZ)
+ 			temp_idx = (start_idx + i) % DBG_LOG_SZ;
+ 		else
+ 			temp_idx = j++;
+ 		rem_nsec = do_div(phba->dbg_log[temp_idx].t_ns, NSEC_PER_SEC);
+ 		dev_info(&phba->pcidev->dev, "%d: [%5lu.%06lu] %s",
+ 			 temp_idx,
+ 			 (unsigned long)phba->dbg_log[temp_idx].t_ns,
+ 			 rem_nsec / 1000,
+ 			 phba->dbg_log[temp_idx].log);
+ 	}
+ 	atomic_set(&phba->dbg_log_cnt, 0);
+ 	atomic_set(&phba->dbg_log_dmping, 0);
+ }
+ 
+ void lpfc_dbg_print(struct lpfc_hba *phba, const char *fmt, ...)
+ {
+ 	unsigned int idx;
+ 	va_list args;
+ 	int dbg_dmping = atomic_read(&phba->dbg_log_dmping);
+ 	struct va_format vaf;
+ 
+ 
+ 	va_start(args, fmt);
+ 	if (unlikely(dbg_dmping)) {
+ 		vaf.fmt = fmt;
+ 		vaf.va = &args;
+ 		dev_info(&phba->pcidev->dev, "%pV", &vaf);
+ 		va_end(args);
+ 		return;
+ 	}
+ 	idx = (unsigned int)atomic_fetch_add(1, &phba->dbg_log_idx) %
+ 		DBG_LOG_SZ;
+ 
+ 	atomic_inc(&phba->dbg_log_cnt);
+ 
+ 	vscnprintf(phba->dbg_log[idx].log,
+ 		   sizeof(phba->dbg_log[idx].log), fmt, args);
+ 	va_end(args);
+ 
+ 	phba->dbg_log[idx].t_ns = local_clock();
+ }
+ 
++>>>>>>> 77dd7d7b3442 (scsi: lpfc: Fix less-than-zero comparison of unsigned value)
  /**
   * lpfc_exit - lpfc module removal routine
   *
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
