kvm: x86: Set last_vmentry_cpu in vcpu_enter_guest

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jim Mattson <jmattson@google.com>
commit c967118ddb21191178c0e0080fdc41f5d85ca1d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c967118d.failed

Since this field is now in kvm_vcpu_arch, clean things up a little by
setting it in vendor-agnostic code: vcpu_enter_guest. Note that it
must be set after the call to kvm_x86_ops.run(), since it can't be
updated before pre_sev_run().

	Suggested-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Jim Mattson <jmattson@google.com>
	Reviewed-by: Oliver Upton <oupton@google.com>
	Reviewed-by: Peter Shier <pshier@google.com>
Message-Id: <20200603235623.245638-7-jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c967118ddb21191178c0e0080fdc41f5d85ca1d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/svm/svm.c
index 733f139091ec,38104f47cd25..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -3399,14 -3398,6 +3399,17 @@@ static fastpath_t svm_vcpu_run(struct k
  	 */
  	x86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);
  
++<<<<<<< HEAD
 +	/*
 +	 * Tell context tracking that this CPU is about to enter guest
 +	 * mode. This has to be after x86_spec_ctrl_set_guest() because
 +	 * that can take locks (lockdep needs RCU) and calls into world and
 +	 * some more.
 +	 */
 +	guest_enter_irqoff();
 +
++=======
++>>>>>>> c967118ddb21 (kvm: x86: Set last_vmentry_cpu in vcpu_enter_guest)
  	__svm_vcpu_run(svm->vmcb_pa, (unsigned long *)&svm->vcpu.arch.regs);
  
  #ifdef CONFIG_X86_64
diff --cc arch/x86/kvm/vmx/vmx.c
index 916d18c00f08,1de5dac952b6..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -6739,7 -6740,6 +6739,10 @@@ reenter_guest
  	if (vcpu->arch.cr2 != read_cr2())
  		write_cr2(vcpu->arch.cr2);
  
++<<<<<<< HEAD
 +	vmx->last_cpu = vcpu->cpu;
++=======
++>>>>>>> c967118ddb21 (kvm: x86: Set last_vmentry_cpu in vcpu_enter_guest)
  	vmx->fail = __vmx_vcpu_run(vmx, (unsigned long *)&vcpu->arch.regs,
  				   vmx->loaded_vmcs->launched);
  
* Unmerged path arch/x86/kvm/svm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index eb1ec384b288..c9827d2ac682 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -8531,6 +8531,7 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	if (hw_breakpoint_active())
 		hw_breakpoint_restore();
 
+	vcpu->arch.last_vmentry_cpu = vcpu->cpu;
 	vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
 
 	vcpu->mode = OUTSIDE_GUEST_MODE;
