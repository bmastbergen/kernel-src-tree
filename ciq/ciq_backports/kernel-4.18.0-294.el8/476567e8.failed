mm: remove managed_page_count_lock spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Arun KS <arunks@codeaurora.org>
commit 476567e8735a0d06225f3873a86dfa0efd95f3a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/476567e8.failed

Now that totalram_pages and managed_pages are atomic varibles, no need of
managed_page_count spinlock.  The lock had really a weak consistency
guarantee.  It hasn't been used for anything but the update but no reader
actually cares about all the values being updated to be in sync.

Link: http://lkml.kernel.org/r/1542090790-21750-5-git-send-email-arunks@codeaurora.org
	Signed-off-by: Arun KS <arunks@codeaurora.org>
	Reviewed-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: David Hildenbrand <david@redhat.com>
	Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 476567e8735a0d06225f3873a86dfa0efd95f3a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index 65ed4f0345ce,6f3d2c7af84b..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -127,10 -122,8 +127,15 @@@ nodemask_t node_states[NR_NODE_STATES] 
  };
  EXPORT_SYMBOL(node_states);
  
++<<<<<<< HEAD
 +/* Protect totalram_pages and zone->managed_pages */
 +static DEFINE_SPINLOCK(managed_page_count_lock);
 +
 +unsigned long totalram_pages __read_mostly;
++=======
+ atomic_long_t _totalram_pages __read_mostly;
+ EXPORT_SYMBOL(_totalram_pages);
++>>>>>>> 476567e8735a (mm: remove managed_page_count_lock spinlock)
  unsigned long totalreserve_pages __read_mostly;
  unsigned long totalcma_pages __read_mostly;
  
@@@ -7157,14 -7074,12 +7162,18 @@@ early_param("movablecore", cmdline_pars
  
  void adjust_managed_page_count(struct page *page, long count)
  {
++<<<<<<< HEAD
 +	spin_lock(&managed_page_count_lock);
 +	page_zone(page)->managed_pages += count;
 +	totalram_pages += count;
++=======
+ 	atomic_long_add(count, &page_zone(page)->managed_pages);
+ 	totalram_pages_add(count);
++>>>>>>> 476567e8735a (mm: remove managed_page_count_lock spinlock)
  #ifdef CONFIG_HIGHMEM
  	if (PageHighMem(page))
 -		totalhigh_pages_add(count);
 +		totalhigh_pages += count;
  #endif
- 	spin_unlock(&managed_page_count_lock);
  }
  EXPORT_SYMBOL(adjust_managed_page_count);
  
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index 9b2a1294b7c0..c4b8b1977d70 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -504,12 +504,6 @@ struct zone {
 	 * Write access to present_pages at runtime should be protected by
 	 * mem_hotplug_begin/end(). Any reader who can't tolerant drift of
 	 * present_pages should get_online_mems() to get a stable value.
-	 *
-	 * Read access to managed_pages should be safe because it's unsigned
-	 * long. Write access to zone->managed_pages and totalram_pages are
-	 * protected by managed_page_count_lock at runtime. Idealy only
-	 * adjust_managed_page_count() should be used instead of directly
-	 * touching zone->managed_pages and totalram_pages.
 	 */
 	unsigned long		managed_pages;
 	unsigned long		spanned_pages;
* Unmerged path mm/page_alloc.c
