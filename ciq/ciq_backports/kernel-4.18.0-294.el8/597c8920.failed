mm: don't wake kswapd prematurely when watermark boosting is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 597c892038e08098b17ccfe65afd9677e6979800
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/597c8920.failed

On 2-node NUMA hosts we see bursts of kswapd reclaim and subsequent
pressure spikes and stalls from cache refaults while there is plenty of
free memory in the system.

Usually, kswapd is woken up when all eligible nodes in an allocation are
full.  But the code related to watermark boosting can wake kswapd on one
full node while the other one is mostly empty.  This may be justified to
fight fragmentation, but is currently unconditionally done whether
watermark boosting is occurring or not.

In our case, many of our workloads' throughput scales with available
memory, and pure utilization is a more tangible concern than trends
around longer-term fragmentation.  As a result we generally disable
watermark boosting.

Wake kswapd only woken when watermark boosting is requested.

Link: https://lkml.kernel.org/r/20201020175833.397286-1-hannes@cmpxchg.org
Fixes: 1c30844d2dfe ("mm: reclaim small amounts of memory when an external fragmentation event occurs")
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Acked-by: Mel Gorman <mgorman@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 597c892038e08098b17ccfe65afd9677e6979800)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index 0f3a8eeb4d26,521d29718c9e..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -2324,9 -2554,8 +2326,14 @@@ static void steal_suitable_fallback(str
  	 * likelihood of future fallbacks. Wake kswapd now as the node
  	 * may be balanced overall and kswapd will not wake naturally.
  	 */
++<<<<<<< HEAD
 +	boost_watermark(zone);
 +	if (alloc_flags & ALLOC_KSWAPD)
 +		wakeup_kswapd(zone, 0, 0, zone_idx(zone));
++=======
+ 	if (boost_watermark(zone) && (alloc_flags & ALLOC_KSWAPD))
+ 		set_bit(ZONE_BOOSTED_WATERMARK, &zone->flags);
++>>>>>>> 597c892038e0 (mm: don't wake kswapd prematurely when watermark boosting is disabled)
  
  	/* We are not allowed to try stealing from the whole block */
  	if (!whole_block)
* Unmerged path mm/page_alloc.c
