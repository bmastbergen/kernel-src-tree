mm/compaction.c: remove unnecessary zone parameter in isolate_migratepages()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Pengfei Li <lpf.vector@gmail.com>
commit 32aaf0553df99cc4314f6e9f43216cd83afc6c20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/32aaf055.failed

Like commit 40cacbcb3240 ("mm, compaction: remove unnecessary zone
parameter in some instances"), remove unnecessary zone parameter.

No functional change.

Link: http://lkml.kernel.org/r/20190806151616.21107-1-lpf.vector@gmail.com
	Signed-off-by: Pengfei Li <lpf.vector@gmail.com>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Qian Cai <cai@lca.pw>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 32aaf0553df99cc4314f6e9f43216cd83afc6c20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/compaction.c
diff --cc mm/compaction.c
index 79db11f23bf2,ce08b39d85d4..000000000000
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@@ -1228,13 -1749,22 +1227,13 @@@ static isolate_migrate_t isolate_migrat
  
  	/*
  	 * Start at where we last stopped, or beginning of the zone as
 -	 * initialized by compact_zone(). The first failure will use
 -	 * the lowest PFN as the starting point for linear scanning.
 +	 * initialized by compact_zone()
  	 */
 -	low_pfn = fast_find_migrateblock(cc);
 +	low_pfn = cc->migrate_pfn;
  	block_start_pfn = pageblock_start_pfn(low_pfn);
- 	if (block_start_pfn < zone->zone_start_pfn)
- 		block_start_pfn = zone->zone_start_pfn;
+ 	if (block_start_pfn < cc->zone->zone_start_pfn)
+ 		block_start_pfn = cc->zone->zone_start_pfn;
  
 -	/*
 -	 * fast_find_migrateblock marks a pageblock skipped so to avoid
 -	 * the isolation_suitable check below, check whether the fast
 -	 * search was successful.
 -	 */
 -	fast_find_block = low_pfn != cc->migrate_pfn && !cc->fast_search_fail;
 -
  	/* Only scan within a pageblock boundary */
  	block_end_pfn = pageblock_end_pfn(low_pfn);
  
@@@ -1250,14 -1781,13 +1249,14 @@@
  		/*
  		 * This can potentially iterate a massively long zone with
  		 * many pageblocks unsuitable, so periodically check if we
 -		 * need to schedule.
 +		 * need to schedule, or even abort async compaction.
  		 */
 -		if (!(low_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages)))
 -			cond_resched();
 +		if (!(low_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))
 +						&& compact_should_abort(cc))
 +			break;
  
- 		page = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,
- 									zone);
+ 		page = pageblock_pfn_to_page(block_start_pfn,
+ 						block_end_pfn, cc->zone);
  		if (!page)
  			continue;
  
@@@ -1614,7 -2154,21 +1613,25 @@@ static enum compact_result compact_zone
  		int err;
  		unsigned long start_pfn = cc->migrate_pfn;
  
++<<<<<<< HEAD
 +		switch (isolate_migratepages(zone, cc)) {
++=======
+ 		/*
+ 		 * Avoid multiple rescans which can happen if a page cannot be
+ 		 * isolated (dirty/writeback in async mode) or if the migrated
+ 		 * pages are being allocated before the pageblock is cleared.
+ 		 * The first rescan will capture the entire pageblock for
+ 		 * migration. If it fails, it'll be marked skip and scanning
+ 		 * will proceed as normal.
+ 		 */
+ 		cc->rescan = false;
+ 		if (pageblock_start_pfn(last_migrated_pfn) ==
+ 		    pageblock_start_pfn(start_pfn)) {
+ 			cc->rescan = true;
+ 		}
+ 
+ 		switch (isolate_migratepages(cc)) {
++>>>>>>> 32aaf0553df9 (mm/compaction.c: remove unnecessary zone parameter in isolate_migratepages())
  		case ISOLATE_ABORT:
  			ret = COMPACT_CONTENDED;
  			putback_movable_pages(&cc->migratepages);
* Unmerged path mm/compaction.c
