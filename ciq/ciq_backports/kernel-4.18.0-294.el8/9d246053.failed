sched: Add a tracepoint to track rq->nr_running

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Phil Auld <pauld@redhat.com>
commit 9d246053a69196c7c27068870e9b4b66ac536f68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9d246053.failed

Add a bare tracepoint trace_sched_update_nr_running_tp which tracks
->nr_running CPU's rq. This is used to accurately trace this data and
provide a visualization of scheduler imbalances in, for example, the
form of a heat map.  The tracepoint is accessed by loading an external
kernel module. An example module (forked from Qais' module and including
the pelt related tracepoints) can be found at:

  https://github.com/auldp/tracepoints-helpers.git

A script to turn the trace-cmd report output into a heatmap plot can be
found at:

  https://github.com/jirvoz/plot-nr-running

The tracepoints are added to add_nr_running() and sub_nr_running() which
are in kernel/sched/sched.h. In order to avoid CREATE_TRACE_POINTS in
the header a wrapper call is used and the trace/events/sched.h include
is moved before sched.h in kernel/sched/core.

	Signed-off-by: Phil Auld <pauld@redhat.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200629192303.GC120228@lorien.usersys.redhat.com
(cherry picked from commit 9d246053a69196c7c27068870e9b4b66ac536f68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sched.h
#	kernel/sched/fair.c
diff --cc include/linux/sched.h
index 52eb9c8aa465,12b10ce51a08..000000000000
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@@ -1970,4 -2035,17 +1970,20 @@@ static inline void rseq_syscall(struct 
  
  #endif
  
++<<<<<<< HEAD
++=======
+ const struct sched_avg *sched_trace_cfs_rq_avg(struct cfs_rq *cfs_rq);
+ char *sched_trace_cfs_rq_path(struct cfs_rq *cfs_rq, char *str, int len);
+ int sched_trace_cfs_rq_cpu(struct cfs_rq *cfs_rq);
+ 
+ const struct sched_avg *sched_trace_rq_avg_rt(struct rq *rq);
+ const struct sched_avg *sched_trace_rq_avg_dl(struct rq *rq);
+ const struct sched_avg *sched_trace_rq_avg_irq(struct rq *rq);
+ 
+ int sched_trace_rq_cpu(struct rq *rq);
+ int sched_trace_rq_nr_running(struct rq *rq);
+ 
+ const struct cpumask *sched_trace_rd_span(struct root_domain *rd);
+ 
++>>>>>>> 9d246053a691 (sched: Add a tracepoint to track rq->nr_running)
  #endif
diff --cc kernel/sched/fair.c
index c0ffd54616a5,3213cb247aff..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -10863,3 -11214,89 +10861,92 @@@ __init void init_sched_fair_class(void
  #endif /* SMP */
  
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Helper functions to facilitate extracting info from tracepoints.
+  */
+ 
+ const struct sched_avg *sched_trace_cfs_rq_avg(struct cfs_rq *cfs_rq)
+ {
+ #ifdef CONFIG_SMP
+ 	return cfs_rq ? &cfs_rq->avg : NULL;
+ #else
+ 	return NULL;
+ #endif
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_cfs_rq_avg);
+ 
+ char *sched_trace_cfs_rq_path(struct cfs_rq *cfs_rq, char *str, int len)
+ {
+ 	if (!cfs_rq) {
+ 		if (str)
+ 			strlcpy(str, "(null)", len);
+ 		else
+ 			return NULL;
+ 	}
+ 
+ 	cfs_rq_tg_path(cfs_rq, str, len);
+ 	return str;
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_cfs_rq_path);
+ 
+ int sched_trace_cfs_rq_cpu(struct cfs_rq *cfs_rq)
+ {
+ 	return cfs_rq ? cpu_of(rq_of(cfs_rq)) : -1;
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_cfs_rq_cpu);
+ 
+ const struct sched_avg *sched_trace_rq_avg_rt(struct rq *rq)
+ {
+ #ifdef CONFIG_SMP
+ 	return rq ? &rq->avg_rt : NULL;
+ #else
+ 	return NULL;
+ #endif
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_rq_avg_rt);
+ 
+ const struct sched_avg *sched_trace_rq_avg_dl(struct rq *rq)
+ {
+ #ifdef CONFIG_SMP
+ 	return rq ? &rq->avg_dl : NULL;
+ #else
+ 	return NULL;
+ #endif
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_rq_avg_dl);
+ 
+ const struct sched_avg *sched_trace_rq_avg_irq(struct rq *rq)
+ {
+ #if defined(CONFIG_SMP) && defined(CONFIG_HAVE_SCHED_AVG_IRQ)
+ 	return rq ? &rq->avg_irq : NULL;
+ #else
+ 	return NULL;
+ #endif
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_rq_avg_irq);
+ 
+ int sched_trace_rq_cpu(struct rq *rq)
+ {
+ 	return rq ? cpu_of(rq) : -1;
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_rq_cpu);
+ 
+ const struct cpumask *sched_trace_rd_span(struct root_domain *rd)
+ {
+ #ifdef CONFIG_SMP
+ 	return rd ? rd->span : NULL;
+ #else
+ 	return NULL;
+ #endif
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_rd_span);
+ 
+ int sched_trace_rq_nr_running(struct rq *rq)
+ {
+         return rq ? rq->nr_running : -1;
+ }
+ EXPORT_SYMBOL_GPL(sched_trace_rq_nr_running);
++>>>>>>> 9d246053a691 (sched: Add a tracepoint to track rq->nr_running)
* Unmerged path include/linux/sched.h
diff --git a/include/trace/events/sched.h b/include/trace/events/sched.h
index 1078ef5d7eca..0b8851167e7f 100644
--- a/include/trace/events/sched.h
+++ b/include/trace/events/sched.h
@@ -611,6 +611,10 @@ DECLARE_TRACE(sched_util_est_se_tp,
 	TP_PROTO(struct sched_entity *se),
 	TP_ARGS(se));
 
+DECLARE_TRACE(sched_update_nr_running_tp,
+	TP_PROTO(struct rq *rq, int change),
+	TP_ARGS(rq, change));
+
 #endif /* _TRACE_SCHED_H */
 
 /* This part must be outside protection */
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 288dd69ea072..31ef777944b7 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -5,6 +5,10 @@
  *
  *  Copyright (C) 1991-2002  Linus Torvalds
  */
+#define CREATE_TRACE_POINTS
+#include <trace/events/sched.h>
+#undef CREATE_TRACE_POINTS
+
 #include "sched.h"
 
 #include <linux/nospec.h>
@@ -20,9 +24,6 @@
 
 #include "pelt.h"
 
-#define CREATE_TRACE_POINTS
-#include <trace/events/sched.h>
-
 /*
  * Export tracepoints that act as a bare tracehook (ie: have no trace event
  * associated with them) to allow external modules to probe them.
@@ -35,6 +36,7 @@ EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_se_tp);
 EXPORT_TRACEPOINT_SYMBOL_GPL(sched_overutilized_tp);
 EXPORT_TRACEPOINT_SYMBOL_GPL(sched_util_est_cfs_tp);
 EXPORT_TRACEPOINT_SYMBOL_GPL(sched_util_est_se_tp);
+EXPORT_TRACEPOINT_SYMBOL_GPL(sched_update_nr_running_tp);
 
 DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
 
@@ -7278,4 +7280,7 @@ const u32 sched_prio_to_wmult[40] = {
  /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,
 };
 
-#undef CREATE_TRACE_POINTS
+void call_trace_sched_update_nr_running(struct rq *rq, int count)
+{
+        trace_sched_update_nr_running_tp(rq, count);
+}
* Unmerged path kernel/sched/fair.c
diff --git a/kernel/sched/pelt.c b/kernel/sched/pelt.c
index bd006b79b360..85c360ae5307 100644
--- a/kernel/sched/pelt.c
+++ b/kernel/sched/pelt.c
@@ -28,8 +28,6 @@
 #include "sched.h"
 #include "pelt.h"
 
-#include <trace/events/sched.h>
-
 /*
  * Approximate:
  *   val * y^n,    where y^32 ~= 0.5 (~1 scheduling period)
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index b002c124556d..d941c71d3012 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -77,6 +77,8 @@
 #include "cpupri.h"
 #include "cpudeadline.h"
 
+#include <trace/events/sched.h>
+
 #ifdef CONFIG_SCHED_DEBUG
 # define SCHED_WARN_ON(x)	WARN_ONCE(x, #x)
 #else
@@ -98,6 +100,7 @@ extern atomic_long_t calc_load_tasks;
 extern void calc_global_load_tick(struct rq *this_rq);
 extern long calc_load_fold_active(struct rq *this_rq, long adjust);
 
+extern void call_trace_sched_update_nr_running(struct rq *rq, int count);
 /*
  * Helpers for converting nanosecond timing to jiffy resolution
  */
@@ -1898,6 +1901,9 @@ static inline void add_nr_running(struct rq *rq, unsigned count)
 	unsigned prev_nr = rq->nr_running;
 
 	rq->nr_running = prev_nr + count;
+	if (trace_sched_update_nr_running_tp_enabled()) {
+		call_trace_sched_update_nr_running(rq, count);
+	}
 
 	if (prev_nr < 2 && rq->nr_running >= 2) {
 #ifdef CONFIG_SMP
@@ -1912,6 +1918,10 @@ static inline void add_nr_running(struct rq *rq, unsigned count)
 static inline void sub_nr_running(struct rq *rq, unsigned count)
 {
 	rq->nr_running -= count;
+	if (trace_sched_update_nr_running_tp_enabled()) {
+		call_trace_sched_update_nr_running(rq, count);
+	}
+
 	/* Check if we still need preemption */
 	sched_update_tick_dependency(rq);
 }
