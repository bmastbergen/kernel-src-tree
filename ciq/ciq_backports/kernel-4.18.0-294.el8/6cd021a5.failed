udp: segment looped gso packets correctly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Willem de Bruijn <willemb@google.com>
commit 6cd021a58c18a1731f7e47f83e172c0c302d65e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6cd021a5.failed

Multicast and broadcast packets can be looped from egress to ingress
pre segmentation with dev_loopback_xmit. That function unconditionally
sets ip_summed to CHECKSUM_UNNECESSARY.

udp_rcv_segment segments gso packets in the udp rx path. Segmentation
usually executes on egress, and does not expect packets of this type.
__udp_gso_segment interprets !CHECKSUM_PARTIAL as CHECKSUM_NONE. But
the offsets are not correct for gso_make_checksum.

UDP GSO packets are of type CHECKSUM_PARTIAL, with their uh->check set
to the correct pseudo header checksum. Reset ip_summed to this type.
(CHECKSUM_PARTIAL is allowed on ingress, see comments in skbuff.h)

	Reported-by: syzbot <syzkaller@googlegroups.com>
Fixes: cf329aa42b66 ("udp: cope with UDP GRO packet misdirection")
	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6cd021a58c18a1731f7e47f83e172c0c302d65e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/udp.h
diff --cc include/net/udp.h
index dff3cf1814b5,4a180f2a13e3..000000000000
--- a/include/net/udp.h
+++ b/include/net/udp.h
@@@ -450,9 -464,36 +450,43 @@@ DECLARE_STATIC_KEY_FALSE(udpv6_encap_ne
  void udpv6_encap_enable(void);
  #endif
  
++<<<<<<< HEAD
 +#ifdef CONFIG_BPF_STREAM_PARSER
 +struct sk_psock;
 +struct proto *udp_bpf_get_proto(struct sock *sk, struct sk_psock *psock);
 +#endif /* BPF_STREAM_PARSER */
++=======
+ static inline struct sk_buff *udp_rcv_segment(struct sock *sk,
+ 					      struct sk_buff *skb, bool ipv4)
+ {
+ 	netdev_features_t features = NETIF_F_SG;
+ 	struct sk_buff *segs;
+ 
+ 	/* Avoid csum recalculation by skb_segment unless userspace explicitly
+ 	 * asks for the final checksum values
+ 	 */
+ 	if (!inet_get_convert_csum(sk))
+ 		features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+ 
+ 	if (skb->pkt_type == PACKET_LOOPBACK)
+ 		skb->ip_summed = CHECKSUM_PARTIAL;
+ 
+ 	/* the GSO CB lays after the UDP one, no need to save and restore any
+ 	 * CB fragment
+ 	 */
+ 	segs = __skb_gso_segment(skb, features, false);
+ 	if (IS_ERR_OR_NULL(segs)) {
+ 		int segs_nr = skb_shinfo(skb)->gso_segs;
+ 
+ 		atomic_add(segs_nr, &sk->sk_drops);
+ 		SNMP_ADD_STATS(__UDPX_MIB(sk, ipv4), UDP_MIB_INERRORS, segs_nr);
+ 		kfree_skb(skb);
+ 		return NULL;
+ 	}
+ 
+ 	consume_skb(skb);
+ 	return segs;
+ }
++>>>>>>> 6cd021a58c18 (udp: segment looped gso packets correctly)
  
  #endif	/* _UDP_H */
* Unmerged path include/net/udp.h
