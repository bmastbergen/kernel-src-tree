ethtool: provide message mask with DEBUG_GET request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michal Kubecek <mkubecek@suse.cz>
commit 6a94b8ccf6b77f005ab1b36a878e1d81df0c033e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6a94b8cc.failed

Implement DEBUG_GET request to get debugging settings for a device. At the
moment, only message mask corresponding to message level as reported by
ETHTOOL_GMSGLVL ioctl request is provided. (It is called message level in
ioctl interface but almost all drivers interpret it as a bit mask.)

As part of the implementation, provide symbolic names for message mask bits
as ETH_SS_MSG_CLASSES string set.

	Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6a94b8ccf6b77f005ab1b36a878e1d81df0c033e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/ethtool-netlink.rst
#	include/uapi/linux/ethtool.h
#	include/uapi/linux/ethtool_netlink.h
#	net/ethtool/Makefile
#	net/ethtool/common.c
#	net/ethtool/netlink.c
#	net/ethtool/netlink.h
#	net/ethtool/strset.c
diff --cc include/uapi/linux/ethtool.h
index 30dc4eb925a3,456fb2aa0fad..000000000000
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@@ -610,6 -607,10 +611,13 @@@ enum ethtool_stringset 
  	ETH_SS_PHY_STATS,
  	ETH_SS_PHY_TUNABLES,
  	ETH_SS_LINK_MODES,
++<<<<<<< HEAD
++=======
+ 	ETH_SS_MSG_CLASSES,
+ 
+ 	/* add new constants above here */
+ 	ETH_SS_COUNT
++>>>>>>> 6a94b8ccf6b7 (ethtool: provide message mask with DEBUG_GET request)
  };
  
  /**
diff --cc net/ethtool/Makefile
index f68387618973,c120c820a4f5..000000000000
--- a/net/ethtool/Makefile
+++ b/net/ethtool/Makefile
@@@ -1,3 -1,8 +1,12 @@@
  # SPDX-License-Identifier: GPL-2.0-only
  
++<<<<<<< HEAD
 +obj-y		+= ioctl.o common.o
++=======
+ obj-y				+= ioctl.o common.o
+ 
+ obj-$(CONFIG_ETHTOOL_NETLINK)	+= ethtool_nl.o
+ 
+ ethtool_nl-y	:= netlink.o bitset.o strset.o linkinfo.o linkmodes.o \
+ 		   linkstate.o debug.o
++>>>>>>> 6a94b8ccf6b7 (ethtool: provide message mask with DEBUG_GET request)
diff --cc net/ethtool/common.c
index 0a8728565356,aa1183a65a76..000000000000
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@@ -169,3 -170,78 +169,81 @@@ const char link_mode_names[][ETH_GSTRIN
  	__DEFINE_LINK_MODE_NAME(400000, CR8, Full),
  };
  static_assert(ARRAY_SIZE(link_mode_names) == __ETHTOOL_LINK_MODE_MASK_NBITS);
++<<<<<<< HEAD
++=======
+ 
+ const char netif_msg_class_names[][ETH_GSTRING_LEN] = {
+ 	[NETIF_MSG_DRV_BIT]		= "drv",
+ 	[NETIF_MSG_PROBE_BIT]		= "probe",
+ 	[NETIF_MSG_LINK_BIT]		= "link",
+ 	[NETIF_MSG_TIMER_BIT]		= "timer",
+ 	[NETIF_MSG_IFDOWN_BIT]		= "ifdown",
+ 	[NETIF_MSG_IFUP_BIT]		= "ifup",
+ 	[NETIF_MSG_RX_ERR_BIT]		= "rx_err",
+ 	[NETIF_MSG_TX_ERR_BIT]		= "tx_err",
+ 	[NETIF_MSG_TX_QUEUED_BIT]	= "tx_queued",
+ 	[NETIF_MSG_INTR_BIT]		= "intr",
+ 	[NETIF_MSG_TX_DONE_BIT]		= "tx_done",
+ 	[NETIF_MSG_RX_STATUS_BIT]	= "rx_status",
+ 	[NETIF_MSG_PKTDATA_BIT]		= "pktdata",
+ 	[NETIF_MSG_HW_BIT]		= "hw",
+ 	[NETIF_MSG_WOL_BIT]		= "wol",
+ };
+ static_assert(ARRAY_SIZE(netif_msg_class_names) == NETIF_MSG_CLASS_COUNT);
+ 
+ /* return false if legacy contained non-0 deprecated fields
+  * maxtxpkt/maxrxpkt. rest of ksettings always updated
+  */
+ bool
+ convert_legacy_settings_to_link_ksettings(
+ 	struct ethtool_link_ksettings *link_ksettings,
+ 	const struct ethtool_cmd *legacy_settings)
+ {
+ 	bool retval = true;
+ 
+ 	memset(link_ksettings, 0, sizeof(*link_ksettings));
+ 
+ 	/* This is used to tell users that driver is still using these
+ 	 * deprecated legacy fields, and they should not use
+ 	 * %ETHTOOL_GLINKSETTINGS/%ETHTOOL_SLINKSETTINGS
+ 	 */
+ 	if (legacy_settings->maxtxpkt ||
+ 	    legacy_settings->maxrxpkt)
+ 		retval = false;
+ 
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.supported,
+ 		legacy_settings->supported);
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.advertising,
+ 		legacy_settings->advertising);
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.lp_advertising,
+ 		legacy_settings->lp_advertising);
+ 	link_ksettings->base.speed
+ 		= ethtool_cmd_speed(legacy_settings);
+ 	link_ksettings->base.duplex
+ 		= legacy_settings->duplex;
+ 	link_ksettings->base.port
+ 		= legacy_settings->port;
+ 	link_ksettings->base.phy_address
+ 		= legacy_settings->phy_address;
+ 	link_ksettings->base.autoneg
+ 		= legacy_settings->autoneg;
+ 	link_ksettings->base.mdio_support
+ 		= legacy_settings->mdio_support;
+ 	link_ksettings->base.eth_tp_mdix
+ 		= legacy_settings->eth_tp_mdix;
+ 	link_ksettings->base.eth_tp_mdix_ctrl
+ 		= legacy_settings->eth_tp_mdix_ctrl;
+ 	return retval;
+ }
+ 
+ int __ethtool_get_link(struct net_device *dev)
+ {
+ 	if (!dev->ethtool_ops->get_link)
+ 		return -EOPNOTSUPP;
+ 
+ 	return netif_running(dev) && dev->ethtool_ops->get_link(dev);
+ }
++>>>>>>> 6a94b8ccf6b7 (ethtool: provide message mask with DEBUG_GET request)
* Unmerged path Documentation/networking/ethtool-netlink.rst
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/netlink.c
* Unmerged path net/ethtool/netlink.h
* Unmerged path net/ethtool/strset.c
* Unmerged path Documentation/networking/ethtool-netlink.rst
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 95b647bc30cf..7857b47454bd 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -4081,22 +4081,48 @@ void netif_device_attach(struct net_device *dev);
  */
 
 enum {
-	NETIF_MSG_DRV		= 0x0001,
-	NETIF_MSG_PROBE		= 0x0002,
-	NETIF_MSG_LINK		= 0x0004,
-	NETIF_MSG_TIMER		= 0x0008,
-	NETIF_MSG_IFDOWN	= 0x0010,
-	NETIF_MSG_IFUP		= 0x0020,
-	NETIF_MSG_RX_ERR	= 0x0040,
-	NETIF_MSG_TX_ERR	= 0x0080,
-	NETIF_MSG_TX_QUEUED	= 0x0100,
-	NETIF_MSG_INTR		= 0x0200,
-	NETIF_MSG_TX_DONE	= 0x0400,
-	NETIF_MSG_RX_STATUS	= 0x0800,
-	NETIF_MSG_PKTDATA	= 0x1000,
-	NETIF_MSG_HW		= 0x2000,
-	NETIF_MSG_WOL		= 0x4000,
+	NETIF_MSG_DRV_BIT,
+	NETIF_MSG_PROBE_BIT,
+	NETIF_MSG_LINK_BIT,
+	NETIF_MSG_TIMER_BIT,
+	NETIF_MSG_IFDOWN_BIT,
+	NETIF_MSG_IFUP_BIT,
+	NETIF_MSG_RX_ERR_BIT,
+	NETIF_MSG_TX_ERR_BIT,
+	NETIF_MSG_TX_QUEUED_BIT,
+	NETIF_MSG_INTR_BIT,
+	NETIF_MSG_TX_DONE_BIT,
+	NETIF_MSG_RX_STATUS_BIT,
+	NETIF_MSG_PKTDATA_BIT,
+	NETIF_MSG_HW_BIT,
+	NETIF_MSG_WOL_BIT,
+
+	/* When you add a new bit above, update netif_msg_class_names array
+	 * in net/ethtool/common.c
+	 */
+	NETIF_MSG_CLASS_COUNT,
 };
+/* Both ethtool_ops interface and internal driver implementation use u32 */
+static_assert(NETIF_MSG_CLASS_COUNT <= 32);
+
+#define __NETIF_MSG_BIT(bit)	((u32)1 << (bit))
+#define __NETIF_MSG(name)	__NETIF_MSG_BIT(NETIF_MSG_ ## name ## _BIT)
+
+#define NETIF_MSG_DRV		__NETIF_MSG(DRV)
+#define NETIF_MSG_PROBE		__NETIF_MSG(PROBE)
+#define NETIF_MSG_LINK		__NETIF_MSG(LINK)
+#define NETIF_MSG_TIMER		__NETIF_MSG(TIMER)
+#define NETIF_MSG_IFDOWN	__NETIF_MSG(IFDOWN)
+#define NETIF_MSG_IFUP		__NETIF_MSG(IFUP)
+#define NETIF_MSG_RX_ERR	__NETIF_MSG(RX_ERR)
+#define NETIF_MSG_TX_ERR	__NETIF_MSG(TX_ERR)
+#define NETIF_MSG_TX_QUEUED	__NETIF_MSG(TX_QUEUED)
+#define NETIF_MSG_INTR		__NETIF_MSG(INTR)
+#define NETIF_MSG_TX_DONE	__NETIF_MSG(TX_DONE)
+#define NETIF_MSG_RX_STATUS	__NETIF_MSG(RX_STATUS)
+#define NETIF_MSG_PKTDATA	__NETIF_MSG(PKTDATA)
+#define NETIF_MSG_HW		__NETIF_MSG(HW)
+#define NETIF_MSG_WOL		__NETIF_MSG(WOL)
 
 #define netif_msg_drv(p)	((p)->msg_enable & NETIF_MSG_DRV)
 #define netif_msg_probe(p)	((p)->msg_enable & NETIF_MSG_PROBE)
* Unmerged path include/uapi/linux/ethtool.h
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/Makefile
* Unmerged path net/ethtool/common.c
diff --git a/net/ethtool/common.h b/net/ethtool/common.h
index bbb788908cb1..7b934d5e385b 100644
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@ -18,5 +18,6 @@ tunable_strings[__ETHTOOL_TUNABLE_COUNT][ETH_GSTRING_LEN];
 extern const char
 phy_tunable_strings[__ETHTOOL_PHY_TUNABLE_COUNT][ETH_GSTRING_LEN];
 extern const char link_mode_names[][ETH_GSTRING_LEN];
+extern const char netif_msg_class_names[][ETH_GSTRING_LEN];
 
 #endif /* _ETHTOOL_COMMON_H */
diff --git a/net/ethtool/debug.c b/net/ethtool/debug.c
new file mode 100644
index 000000000000..cc121a23be5f
--- /dev/null
+++ b/net/ethtool/debug.c
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include "netlink.h"
+#include "common.h"
+#include "bitset.h"
+
+struct debug_req_info {
+	struct ethnl_req_info		base;
+};
+
+struct debug_reply_data {
+	struct ethnl_reply_data		base;
+	u32				msg_mask;
+};
+
+#define DEBUG_REPDATA(__reply_base) \
+	container_of(__reply_base, struct debug_reply_data, base)
+
+static const struct nla_policy
+debug_get_policy[ETHTOOL_A_DEBUG_MAX + 1] = {
+	[ETHTOOL_A_DEBUG_UNSPEC]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_DEBUG_HEADER]	= { .type = NLA_NESTED },
+	[ETHTOOL_A_DEBUG_MSGMASK]	= { .type = NLA_REJECT },
+};
+
+static int debug_prepare_data(const struct ethnl_req_info *req_base,
+			      struct ethnl_reply_data *reply_base,
+			      struct genl_info *info)
+{
+	struct debug_reply_data *data = DEBUG_REPDATA(reply_base);
+	struct net_device *dev = reply_base->dev;
+	int ret;
+
+	if (!dev->ethtool_ops->get_msglevel)
+		return -EOPNOTSUPP;
+
+	ret = ethnl_ops_begin(dev);
+	if (ret < 0)
+		return ret;
+	data->msg_mask = dev->ethtool_ops->get_msglevel(dev);
+	ethnl_ops_complete(dev);
+
+	return 0;
+}
+
+static int debug_reply_size(const struct ethnl_req_info *req_base,
+			    const struct ethnl_reply_data *reply_base)
+{
+	const struct debug_reply_data *data = DEBUG_REPDATA(reply_base);
+	bool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;
+
+	return ethnl_bitset32_size(&data->msg_mask, NULL, NETIF_MSG_CLASS_COUNT,
+				   netif_msg_class_names, compact);
+}
+
+static int debug_fill_reply(struct sk_buff *skb,
+			    const struct ethnl_req_info *req_base,
+			    const struct ethnl_reply_data *reply_base)
+{
+	const struct debug_reply_data *data = DEBUG_REPDATA(reply_base);
+	bool compact = req_base->flags & ETHTOOL_FLAG_COMPACT_BITSETS;
+
+	return ethnl_put_bitset32(skb, ETHTOOL_A_DEBUG_MSGMASK, &data->msg_mask,
+				  NULL, NETIF_MSG_CLASS_COUNT,
+				  netif_msg_class_names, compact);
+}
+
+const struct ethnl_request_ops ethnl_debug_request_ops = {
+	.request_cmd		= ETHTOOL_MSG_DEBUG_GET,
+	.reply_cmd		= ETHTOOL_MSG_DEBUG_GET_REPLY,
+	.hdr_attr		= ETHTOOL_A_DEBUG_HEADER,
+	.max_attr		= ETHTOOL_A_DEBUG_MAX,
+	.req_info_size		= sizeof(struct debug_req_info),
+	.reply_data_size	= sizeof(struct debug_reply_data),
+	.request_policy		= debug_get_policy,
+
+	.prepare_data		= debug_prepare_data,
+	.reply_size		= debug_reply_size,
+	.fill_reply		= debug_fill_reply,
+};
* Unmerged path net/ethtool/netlink.c
* Unmerged path net/ethtool/netlink.h
* Unmerged path net/ethtool/strset.c
