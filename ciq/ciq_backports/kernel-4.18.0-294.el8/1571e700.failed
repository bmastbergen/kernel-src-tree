net: phylink: in-band pause mode advertisement update for PCS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 1571e700fd610c39e8b50b0110b1ee9badb2fe6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1571e700.failed

Re-code the pause in-band advertisement update in light of the addition
of PCS support, so that we perform the minimum required; only the PCS
configuration function needs to be called in this case, followed by the
request to trigger a restart of negotiation if the programmed
advertisement changed.

We need to change the pcs_config() signature to pass whether resolved
pause should be passed to the MAC for setups such as mvneta and mvpp2
where doing so overrides the MAC manual flow controls.

	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1571e700fd610c39e8b50b0110b1ee9badb2fe6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phylink.c
#	include/linux/phylink.h
diff --cc drivers/net/phy/phylink.c
index a4a4987d90c1,84a426401102..000000000000
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@@ -416,26 -418,86 +416,89 @@@ static void phylink_mac_config(struct p
  		    __ETHTOOL_LINK_MODE_MASK_NBITS, state->advertising,
  		    state->pause, state->link, state->an_enabled);
  
 -	pl->mac_ops->mac_config(pl->config, pl->cur_link_an_mode, state);
 +	pl->ops->mac_config(pl->config, pl->cur_link_an_mode, state);
  }
  
 -static void phylink_mac_pcs_an_restart(struct phylink *pl)
 +static void phylink_mac_config_up(struct phylink *pl,
 +				  const struct phylink_link_state *state)
 +{
 +	if (state->link)
 +		phylink_mac_config(pl, state);
 +}
 +
 +static void phylink_mac_an_restart(struct phylink *pl)
  {
  	if (pl->link_config.an_enabled &&
 -	    phy_interface_mode_is_8023z(pl->link_config.interface) &&
 -	    phylink_autoneg_inband(pl->cur_link_an_mode)) {
 -		if (pl->pcs_ops)
 -			pl->pcs_ops->pcs_an_restart(pl->config);
 -		else
 -			pl->mac_ops->mac_an_restart(pl->config);
 -	}
 +	    phy_interface_mode_is_8023z(pl->link_config.interface))
 +		pl->ops->mac_an_restart(pl->config);
  }
  
 -static void phylink_pcs_config(struct phylink *pl, bool force_restart,
 -			       const struct phylink_link_state *state)
 +static int phylink_get_mac_state(struct phylink *pl, struct phylink_link_state *state)
  {
 -	bool restart = force_restart;
  
++<<<<<<< HEAD
++=======
+ 	if (pl->pcs_ops && pl->pcs_ops->pcs_config(pl->config,
+ 						   pl->cur_link_an_mode,
+ 						   state->interface,
+ 						   state->advertising,
+ 						   !!(pl->link_config.pause &
+ 						      MLO_PAUSE_AN)))
+ 		restart = true;
+ 
+ 	phylink_mac_config(pl, state);
+ 
+ 	if (restart)
+ 		phylink_mac_pcs_an_restart(pl);
+ }
+ 
+ /*
+  * Reconfigure for a change of inband advertisement.
+  * If we have a separate PCS, we only need to call its pcs_config() method,
+  * and then restart AN if it indicates something changed. Otherwise, we do
+  * the full MAC reconfiguration.
+  */
+ static int phylink_change_inband_advert(struct phylink *pl)
+ {
+ 	int ret;
+ 
+ 	if (test_bit(PHYLINK_DISABLE_STOPPED, &pl->phylink_disable_state))
+ 		return 0;
+ 
+ 	if (!pl->pcs_ops) {
+ 		/* Legacy method */
+ 		phylink_mac_config(pl, &pl->link_config);
+ 		phylink_mac_pcs_an_restart(pl);
+ 		return 0;
+ 	}
+ 
+ 	phylink_dbg(pl, "%s: mode=%s/%s adv=%*pb pause=%02x\n", __func__,
+ 		    phylink_an_mode_str(pl->cur_link_an_mode),
+ 		    phy_modes(pl->link_config.interface),
+ 		    __ETHTOOL_LINK_MODE_MASK_NBITS, pl->link_config.advertising,
+ 		    pl->link_config.pause);
+ 
+ 	/* Modern PCS-based method; update the advert at the PCS, and
+ 	 * restart negotiation if the pcs_config() helper indicates that
+ 	 * the programmed advertisement has changed.
+ 	 */
+ 	ret = pl->pcs_ops->pcs_config(pl->config, pl->cur_link_an_mode,
+ 				      pl->link_config.interface,
+ 				      pl->link_config.advertising,
+ 				      !!(pl->link_config.pause & MLO_PAUSE_AN));
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (ret > 0)
+ 		phylink_mac_pcs_an_restart(pl);
+ 
+ 	return 0;
+ }
+ 
+ static void phylink_mac_pcs_get_state(struct phylink *pl,
+ 				      struct phylink_link_state *state)
+ {
++>>>>>>> 1571e700fd61 (net: phylink: in-band pause mode advertisement update for PCS)
  	linkmode_copy(state->advertising, pl->link_config.advertising);
  	linkmode_zero(state->lp_advertising);
  	state->interface = pl->link_config.interface;
@@@ -1464,19 -1563,37 +1527,40 @@@ int phylink_ethtool_set_pauseparam(stru
  	linkmode_set_pause(config->advertising, pause->tx_pause,
  			   pause->rx_pause);
  
++<<<<<<< HEAD
 +	/* If we have a PHY, phylib will call our link state function if the
 +	 * mode has changed, which will trigger a resolve and update the MAC
 +	 * configuration.
++=======
+ 	manual_changed = (config->pause ^ pause_state) & MLO_PAUSE_AN ||
+ 			 (!(pause_state & MLO_PAUSE_AN) &&
+ 			   (config->pause ^ pause_state) & MLO_PAUSE_TXRX_MASK);
+ 
+ 	config->pause = pause_state;
+ 
+ 	/* Update our in-band advertisement, triggering a renegotiation if
+ 	 * the advertisement changed.
+ 	 */
+ 	if (!pl->phydev)
+ 		phylink_change_inband_advert(pl);
+ 
+ 	mutex_unlock(&pl->state_mutex);
+ 
+ 	/* If we have a PHY, a change of the pause frame advertisement will
+ 	 * cause phylib to renegotiate (if AN is enabled) which will in turn
+ 	 * call our phylink_phy_change() and trigger a resolve.  Note that
+ 	 * we can't hold our state mutex while calling phy_set_asym_pause().
++>>>>>>> 1571e700fd61 (net: phylink: in-band pause mode advertisement update for PCS)
  	 */
 -	if (pl->phydev)
 +	if (pl->phydev) {
  		phy_set_asym_pause(pl->phydev, pause->rx_pause,
  				   pause->tx_pause);
 -
 -	/* If the manual pause settings changed, make sure we trigger a
 -	 * resolve to update their state; we can not guarantee that the
 -	 * link will cycle.
 -	 */
 -	if (manual_changed) {
 -		pl->mac_link_dropped = true;
 -		phylink_run_resolve(pl);
 +	} else if (!test_bit(PHYLINK_DISABLE_STOPPED,
 +			     &pl->phylink_disable_state)) {
 +		phylink_mac_config(pl, &pl->link_config);
 +		phylink_mac_an_restart(pl);
  	}
 +	mutex_unlock(&pl->state_mutex);
  
  	return 0;
  }
diff --cc include/linux/phylink.h
index 547856db39e8,d9913d8e6b91..000000000000
--- a/include/linux/phylink.h
+++ b/include/linux/phylink.h
@@@ -240,9 -268,99 +240,105 @@@ void mac_link_down(struct phylink_confi
   * phy_init_eee() and perform appropriate MAC configuration for EEE.
   * Interface type selection must be done in mac_config().
   */
++<<<<<<< HEAD
 +void mac_link_up(struct phylink_config *config, unsigned int mode,
 +		 phy_interface_t interface,
 +		 struct phy_device *phy);
++=======
+ void mac_link_up(struct phylink_config *config, struct phy_device *phy,
+ 		 unsigned int mode, phy_interface_t interface,
+ 		 int speed, int duplex, bool tx_pause, bool rx_pause);
+ #endif
+ 
+ /**
+  * struct phylink_pcs_ops - MAC PCS operations structure.
+  * @pcs_get_state: read the current MAC PCS link state from the hardware.
+  * @pcs_config: configure the MAC PCS for the selected mode and state.
+  * @pcs_an_restart: restart 802.3z BaseX autonegotiation.
+  * @pcs_link_up: program the PCS for the resolved link configuration
+  *               (where necessary).
+  */
+ struct phylink_pcs_ops {
+ 	void (*pcs_get_state)(struct phylink_config *config,
+ 			      struct phylink_link_state *state);
+ 	int (*pcs_config)(struct phylink_config *config, unsigned int mode,
+ 			  phy_interface_t interface,
+ 			  const unsigned long *advertising,
+ 			  bool permit_pause_to_mac);
+ 	void (*pcs_an_restart)(struct phylink_config *config);
+ 	void (*pcs_link_up)(struct phylink_config *config, unsigned int mode,
+ 			    phy_interface_t interface, int speed, int duplex);
+ };
+ 
+ #if 0 /* For kernel-doc purposes only. */
+ /**
+  * pcs_get_state() - Read the current inband link state from the hardware
+  * @config: a pointer to a &struct phylink_config.
+  * @state: a pointer to a &struct phylink_link_state.
+  *
+  * Read the current inband link state from the MAC PCS, reporting the
+  * current speed in @state->speed, duplex mode in @state->duplex, pause
+  * mode in @state->pause using the %MLO_PAUSE_RX and %MLO_PAUSE_TX bits,
+  * negotiation completion state in @state->an_complete, and link up state
+  * in @state->link. If possible, @state->lp_advertising should also be
+  * populated.
+  *
+  * When present, this overrides mac_pcs_get_state() in &struct
+  * phylink_mac_ops.
+  */
+ void pcs_get_state(struct phylink_config *config,
+ 		   struct phylink_link_state *state);
+ 
+ /**
+  * pcs_config() - Configure the PCS mode and advertisement
+  * @config: a pointer to a &struct phylink_config.
+  * @mode: one of %MLO_AN_FIXED, %MLO_AN_PHY, %MLO_AN_INBAND.
+  * @interface: interface mode to be used
+  * @advertising: adertisement ethtool link mode mask
+  * @permit_pause_to_mac: permit forwarding pause resolution to MAC
+  *
+  * Configure the PCS for the operating mode, the interface mode, and set
+  * the advertisement mask. @permit_pause_to_mac indicates whether the
+  * hardware may forward the pause mode resolution to the MAC.
+  *
+  * When operating in %MLO_AN_INBAND, inband should always be enabled,
+  * otherwise inband should be disabled.
+  *
+  * For SGMII, there is no advertisement from the MAC side, the PCS should
+  * be programmed to acknowledge the inband word from the PHY.
+  *
+  * For 1000BASE-X, the advertisement should be programmed into the PCS.
+  *
+  * For most 10GBASE-R, there is no advertisement.
+  */
+ int (*pcs_config)(struct phylink_config *config, unsigned int mode,
+ 		  phy_interface_t interface, const unsigned long *advertising);
+ 
+ /**
+  * pcs_an_restart() - restart 802.3z BaseX autonegotiation
+  * @config: a pointer to a &struct phylink_config.
+  *
+  * When PCS ops are present, this overrides mac_an_restart() in &struct
+  * phylink_mac_ops.
+  */
+ void (*pcs_an_restart)(struct phylink_config *config);
+ 
+ /**
+  * pcs_link_up() - program the PCS for the resolved link configuration
+  * @config: a pointer to a &struct phylink_config.
+  * @mode: link autonegotiation mode
+  * @interface: link &typedef phy_interface_t mode
+  * @speed: link speed
+  * @duplex: link duplex
+  *
+  * This call will be made just before mac_link_up() to inform the PCS of
+  * the resolved link parameters. For example, a PCS operating in SGMII
+  * mode without in-band AN needs to be manually configured for the link
+  * and duplex setting. Otherwise, this should be a no-op.
+  */
+ void (*pcs_link_up)(struct phylink_config *config, unsigned int mode,
+ 		    phy_interface_t interface, int speed, int duplex);
++>>>>>>> 1571e700fd61 (net: phylink: in-band pause mode advertisement update for PCS)
  #endif
  
  struct phylink *phylink_create(struct phylink_config *, struct fwnode_handle *,
* Unmerged path drivers/net/phy/phylink.c
* Unmerged path include/linux/phylink.h
