s390/qeth: set TX IRQ marker on last buffer in a group

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 6ee091efa7b59829448d0f9287ea62c1f448a318
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6ee091ef.failed

When qeth_flush_buffers() gets called for a group of TX buffers
(currently up to 2 for OSA-style devices), the code iterates over each
buffer for some final processing.

During this processing, it sets the TX IRQ marker on the leading buffer
rather than the last one. This can result in delayed TX completion of
the trailing buffers. So pull the IRQ marker code out of the loop, and
apply it to the final buffer.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6ee091efa7b59829448d0f9287ea62c1f448a318)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index b22d45f3231c,164cc7f377fc..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -3572,9 -3635,13 +3572,18 @@@ static void qeth_flush_buffers(struct q
  		if (queue->bufstates)
  			queue->bufstates[bidx].user = buf;
  
++<<<<<<< HEAD
 +		if (IS_IQD(queue->card))
 +			continue;
++=======
+ 		if (IS_IQD(card)) {
+ 			skb_queue_walk(&buf->skb_list, skb)
+ 				skb_tx_timestamp(skb);
+ 		}
+ 	}
++>>>>>>> 6ee091efa7b5 (s390/qeth: set TX IRQ marker on last buffer in a group)
  
+ 	if (!IS_IQD(card)) {
  		if (!queue->do_pack) {
  			if ((atomic_read(&queue->used_buffers) >=
  				(QETH_HIGH_WATERMARK_PACK -
* Unmerged path drivers/s390/net/qeth_core_main.c
