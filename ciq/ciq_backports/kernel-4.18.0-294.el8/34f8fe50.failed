bdi: Add bdi->id

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Tejun Heo <tj@kernel.org>
commit 34f8fe501f0624de115d087680c84000b5d9abc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/34f8fe50.failed

There currently is no way to universally identify and lookup a bdi
without holding a reference and pointer to it.  This patch adds an
non-recycling bdi->id and implements bdi_get_by_id() which looks up
bdis by their ids.  This will be used by memcg foreign inode flushing.

I left bdi_list alone for simplicity and because while rb_tree does
support rcu assignment it doesn't seem to guarantee lossless walk when
walk is racing aginst tree rebalance operations.

	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 34f8fe501f0624de115d087680c84000b5d9abc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/backing-dev.c
diff --cc mm/backing-dev.c
index fcefaaa6ff5e,612aa7c5ddbd..000000000000
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@@ -1,5 -1,7 +1,6 @@@
 -// SPDX-License-Identifier: GPL-2.0-only
  
  #include <linux/wait.h>
+ #include <linux/rbtree.h>
  #include <linux/backing-dev.h>
  #include <linux/kthread.h>
  #include <linux/freezer.h>
@@@ -20,13 -21,14 +21,15 @@@ struct backing_dev_info noop_backing_de
  EXPORT_SYMBOL_GPL(noop_backing_dev_info);
  
  static struct class *bdi_class;
 +static const char *bdi_unknown_name = "(unknown)";
  
  /*
-  * bdi_lock protects updates to bdi_list. bdi_list has RCU reader side
-  * locking.
+  * bdi_lock protects bdi_tree and updates to bdi_list. bdi_list has RCU
+  * reader side locking.
   */
  DEFINE_SPINLOCK(bdi_lock);
+ static u64 bdi_id_cursor;
+ static struct rb_root bdi_tree = RB_ROOT;
  LIST_HEAD(bdi_list);
  
  /* bdi_wq serves all asynchronous writeback tasks */
@@@ -889,8 -913,7 +940,12 @@@ struct backing_dev_info *bdi_get_by_id(
  int bdi_register_va(struct backing_dev_info *bdi, const char *fmt, va_list args)
  {
  	struct device *dev;
++<<<<<<< HEAD
 +	char name[BDI_DEV_NAME_LEN];
 +	char *devname;
++=======
+ 	struct rb_node *parent, **p;
++>>>>>>> 34f8fe501f06 (bdi: Add bdi->id)
  
  	if (bdi->dev)	/* The driver needs to use separate queues per device */
  		return 0;
diff --git a/include/linux/backing-dev-defs.h b/include/linux/backing-dev-defs.h
index bc71cc0b6ded..8d043979bf65 100644
--- a/include/linux/backing-dev-defs.h
+++ b/include/linux/backing-dev-defs.h
@@ -192,6 +192,8 @@ struct bdi_writeback {
 };
 
 struct backing_dev_info {
+	u64 id;
+	struct rb_node rb_node; /* keyed by ->id */
 	struct list_head bdi_list;
 	unsigned long ra_pages;	/* max readahead in PAGE_SIZE units */
 	unsigned long io_pages;	/* max allowed IO size */
diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h
index 32003a8a39ed..c382c9b2e971 100644
--- a/include/linux/backing-dev.h
+++ b/include/linux/backing-dev.h
@@ -25,6 +25,7 @@ static inline struct backing_dev_info *bdi_get(struct backing_dev_info *bdi)
 	return bdi;
 }
 
+struct backing_dev_info *bdi_get_by_id(u64 id);
 void bdi_put(struct backing_dev_info *bdi);
 
 __printf(2, 3)
* Unmerged path mm/backing-dev.c
