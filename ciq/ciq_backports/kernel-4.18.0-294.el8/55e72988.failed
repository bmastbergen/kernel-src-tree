net: udp: fix IP header access and skb lookup on Fast/frag0 UDP GRO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] udp: fix IP header access and skb lookup on Fast/frag0 UDP GRO (Xin Long) [1879403]
Rebuild_FUZZ: 96.12%
commit-author Alexander Lobakin <alobakin@pm.me>
commit 55e729889bb07d68ab071660ce3f5e7a7872ebe8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/55e72988.failed

udp{4,6}_lib_lookup_skb() use ip{,v6}_hdr() to get IP header of the
packet. While it's probably OK for non-frag0 paths, this helpers
will also point to junk on Fast/frag0 GRO when all headers are
located in frags. As a result, sk/skb lookup may fail or give wrong
results. To support both GRO modes, skb_gro_network_header() might
be used. To not modify original functions, add private versions of
udp{4,6}_lib_lookup_skb() only to perform correct sk lookups on GRO.

Present since the introduction of "application-level" UDP GRO
in 4.7-rc1.

Misc: replace totally unneeded ternaries with plain ifs.

Fixes: a6024562ffd7 ("udp: Add GRO functions to UDP socket")
	Suggested-by: Willem de Bruijn <willemb@google.com>
	Cc: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Alexander Lobakin <alobakin@pm.me>
	Acked-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 55e729889bb07d68ab071660ce3f5e7a7872ebe8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp_offload.c
#	net/ipv6/udp_offload.c
diff --cc net/ipv4/udp_offload.c
index b081620854e2,c62805cd3131..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -413,8 -514,10 +423,13 @@@ INDIRECT_CALLABLE_SCOP
  struct sk_buff *udp4_gro_receive(struct list_head *head, struct sk_buff *skb)
  {
  	struct udphdr *uh = udp_gro_udphdr(skb);
++<<<<<<< HEAD
++=======
+ 	struct sock *sk = NULL;
+ 	struct sk_buff *pp;
++>>>>>>> 55e729889bb0 (net: udp: fix IP header access and skb lookup on Fast/frag0 UDP GRO)
  
 -	if (unlikely(!uh))
 +	if (unlikely(!uh) || !static_branch_unlikely(&udp_encap_needed_key))
  		goto flush;
  
  	/* Don't bother verifying checksum if we're going to flush anyway. */
@@@ -429,7 -532,14 +444,18 @@@
  					     inet_gro_compute_pseudo);
  skip:
  	NAPI_GRO_CB(skb)->is_ipv6 = 0;
++<<<<<<< HEAD
 +	return udp_gro_receive(head, skb, uh, udp4_lib_lookup_skb);
++=======
+ 	rcu_read_lock();
+ 
+ 	if (static_branch_unlikely(&udp_encap_needed_key))
+ 		sk = udp4_gro_lookup_skb(skb, uh->source, uh->dest);
+ 
+ 	pp = udp_gro_receive(head, skb, uh, sk);
+ 	rcu_read_unlock();
+ 	return pp;
++>>>>>>> 55e729889bb0 (net: udp: fix IP header access and skb lookup on Fast/frag0 UDP GRO)
  
  flush:
  	NAPI_GRO_CB(skb)->flush = 1;
diff --cc net/ipv6/udp_offload.c
index c25277706074,f9e888d1b9af..000000000000
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@@ -119,8 -125,10 +129,13 @@@ INDIRECT_CALLABLE_SCOP
  struct sk_buff *udp6_gro_receive(struct list_head *head, struct sk_buff *skb)
  {
  	struct udphdr *uh = udp_gro_udphdr(skb);
++<<<<<<< HEAD
++=======
+ 	struct sock *sk = NULL;
+ 	struct sk_buff *pp;
++>>>>>>> 55e729889bb0 (net: udp: fix IP header access and skb lookup on Fast/frag0 UDP GRO)
  
 -	if (unlikely(!uh))
 +	if (unlikely(!uh) || !static_branch_unlikely(&udpv6_encap_needed_key))
  		goto flush;
  
  	/* Don't bother verifying checksum if we're going to flush anyway. */
@@@ -136,7 -144,14 +151,18 @@@
  
  skip:
  	NAPI_GRO_CB(skb)->is_ipv6 = 1;
++<<<<<<< HEAD
 +	return udp_gro_receive(head, skb, uh, udp6_lib_lookup_skb);
++=======
+ 	rcu_read_lock();
+ 
+ 	if (static_branch_unlikely(&udpv6_encap_needed_key))
+ 		sk = udp6_gro_lookup_skb(skb, uh->source, uh->dest);
+ 
+ 	pp = udp_gro_receive(head, skb, uh, sk);
+ 	rcu_read_unlock();
+ 	return pp;
++>>>>>>> 55e729889bb0 (net: udp: fix IP header access and skb lookup on Fast/frag0 UDP GRO)
  
  flush:
  	NAPI_GRO_CB(skb)->flush = 1;
* Unmerged path net/ipv4/udp_offload.c
* Unmerged path net/ipv6/udp_offload.c
