compat_ioctl: simplify up block/ioctl.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Arnd Bergmann <arnd@arndb.de>
commit 9b81648cb5e3ae7296825f0c8d2f98e50631ee84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9b81648c.failed

Having separate implementations of blkdev_ioctl() often leads to these
getting out of sync, despite the comment at the top.

Since most of the ioctl commands are compatible, and we try very hard
not to add any new incompatible ones, move all the common bits into a
shared function and leave only the ones that are historically different
in separate functions for native/compat mode.

To deal with the compat_ptr() conversion, pass both the integer
argument and the pointer argument into the new blkdev_common_ioctl()
and make sure to always use the correct one of these.

blkdev_ioctl() is now only kept as a separate exported interfact
for drivers/char/raw.c, which lacks a compat_ioctl variant.
We should probably either move raw.c to staging if there are no
more users, or export blkdev_compat_ioctl() as well.

	Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
(cherry picked from commit 9b81648cb5e3ae7296825f0c8d2f98e50631ee84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/ioctl.c
diff --cc block/ioctl.c
index f8f8a81c640e,127194b9f9bd..000000000000
--- a/block/ioctl.c
+++ b/block/ioctl.c
@@@ -237,36 -270,48 +237,51 @@@ static int blk_ioctl_zeroout(struct blo
  			BLKDEV_ZERO_NOUNMAP);
  }
  
- static int put_ushort(unsigned long arg, unsigned short val)
+ static int put_ushort(unsigned short __user *argp, unsigned short val)
  {
- 	return put_user(val, (unsigned short __user *)arg);
+ 	return put_user(val, argp);
  }
  
- static int put_int(unsigned long arg, int val)
+ static int put_int(int __user *argp, int val)
  {
- 	return put_user(val, (int __user *)arg);
+ 	return put_user(val, argp);
  }
  
- static int put_uint(unsigned long arg, unsigned int val)
+ static int put_uint(unsigned int __user *argp, unsigned int val)
  {
- 	return put_user(val, (unsigned int __user *)arg);
+ 	return put_user(val, argp);
  }
  
- static int put_long(unsigned long arg, long val)
+ static int put_long(long __user *argp, long val)
  {
- 	return put_user(val, (long __user *)arg);
+ 	return put_user(val, argp);
  }
  
- static int put_ulong(unsigned long arg, unsigned long val)
+ static int put_ulong(unsigned long __user *argp, unsigned long val)
  {
- 	return put_user(val, (unsigned long __user *)arg);
+ 	return put_user(val, argp);
  }
  
- static int put_u64(unsigned long arg, u64 val)
+ static int put_u64(u64 __user *argp, u64 val)
  {
- 	return put_user(val, (u64 __user *)arg);
+ 	return put_user(val, argp);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_COMPAT
+ static int compat_put_long(compat_long_t *argp, long val)
+ {
+ 	return put_user(val, argp);
+ }
+ 
+ static int compat_put_ulong(compat_ulong_t *argp, compat_ulong_t val)
+ {
+ 	return put_user(val, argp);
+ }
+ #endif
+ 
++>>>>>>> 9b81648cb5e3 (compat_ioctl: simplify up block/ioctl.c)
  int __blkdev_driver_ioctl(struct block_device *bdev, fmode_t mode,
  			unsigned cmd, unsigned long arg)
  {
@@@ -454,6 -519,45 +469,48 @@@ static int blkdev_getgeo(struct block_d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_COMPAT
+ struct compat_hd_geometry {
+ 	unsigned char heads;
+ 	unsigned char sectors;
+ 	unsigned short cylinders;
+ 	u32 start;
+ };
+ 
+ static int compat_hdio_getgeo(struct block_device *bdev,
+ 			      struct compat_hd_geometry __user *ugeo)
+ {
+ 	struct gendisk *disk = bdev->bd_disk;
+ 	struct hd_geometry geo;
+ 	int ret;
+ 
+ 	if (!ugeo)
+ 		return -EINVAL;
+ 	if (!disk->fops->getgeo)
+ 		return -ENOTTY;
+ 
+ 	memset(&geo, 0, sizeof(geo));
+ 	/*
+ 	 * We need to set the startsect first, the driver may
+ 	 * want to override it.
+ 	 */
+ 	geo.start = get_start_sect(bdev);
+ 	ret = disk->fops->getgeo(bdev, &geo);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = copy_to_user(ugeo, &geo, 4);
+ 	ret |= put_user(geo.start, &ugeo->start);
+ 	if (ret)
+ 		ret = -EFAULT;
+ 
+ 	return ret;
+ }
+ #endif
+ 
++>>>>>>> 9b81648cb5e3 (compat_ioctl: simplify up block/ioctl.c)
  /* set the logical block size */
  static int blkdev_bszset(struct block_device *bdev, fmode_t mode,
  		int __user *argp)
@@@ -578,7 -661,132 +614,136 @@@ static int blkdev_common_ioctl(struct b
  	case IOC_PR_CLEAR:
  		return blkdev_pr_clear(bdev, argp);
  	default:
- 		return __blkdev_driver_ioctl(bdev, mode, cmd, arg);
+ 		return -ENOIOCTLCMD;
  	}
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(blkdev_ioctl);
++=======
+ 
+ /*
+  * Always keep this in sync with compat_blkdev_ioctl()
+  * to handle all incompatible commands in both functions.
+  *
+  * New commands must be compatible and go into blkdev_common_ioctl
+  */
+ int blkdev_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
+ 			unsigned long arg)
+ {
+ 	int ret;
+ 	loff_t size;
+ 	void __user *argp = (void __user *)arg;
+ 
+ 	switch (cmd) {
+ 	/* These need separate implementations for the data structure */
+ 	case HDIO_GETGEO:
+ 		return blkdev_getgeo(bdev, argp);
+ 	case BLKPG:
+ 		return blkpg_ioctl(bdev, argp);
+ 
+ 	/* Compat mode returns 32-bit data instead of 'long' */
+ 	case BLKRAGET:
+ 	case BLKFRAGET:
+ 		if (!argp)
+ 			return -EINVAL;
+ 		return put_long(argp, (bdev->bd_bdi->ra_pages*PAGE_SIZE) / 512);
+ 	case BLKGETSIZE:
+ 		size = i_size_read(bdev->bd_inode);
+ 		if ((size >> 9) > ~0UL)
+ 			return -EFBIG;
+ 		return put_ulong(argp, size >> 9);
+ 
+ 	/* The data is compatible, but the command number is different */
+ 	case BLKBSZGET: /* get block device soft block size (cf. BLKSSZGET) */
+ 		return put_int(argp, block_size(bdev));
+ 	case BLKBSZSET:
+ 		return blkdev_bszset(bdev, mode, argp);
+ 	case BLKGETSIZE64:
+ 		return put_u64(argp, i_size_read(bdev->bd_inode));
+ 
+ 	/* Incompatible alignment on i386 */
+ 	case BLKTRACESETUP:
+ 		return blk_trace_ioctl(bdev, cmd, argp);
+ 	default:
+ 		break;
+ 	}
+ 
+ 	ret = blkdev_common_ioctl(bdev, mode, cmd, arg, argp);
+ 	if (ret == -ENOIOCTLCMD)
+ 		return __blkdev_driver_ioctl(bdev, mode, cmd, arg);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(blkdev_ioctl); /* for /dev/raw */
+ 
+ #ifdef CONFIG_COMPAT
+ 
+ #define BLKBSZGET_32		_IOR(0x12, 112, int)
+ #define BLKBSZSET_32		_IOW(0x12, 113, int)
+ #define BLKGETSIZE64_32		_IOR(0x12, 114, int)
+ 
+ /* Most of the generic ioctls are handled in the normal fallback path.
+    This assumes the blkdev's low level compat_ioctl always returns
+    ENOIOCTLCMD for unknown ioctls. */
+ long compat_blkdev_ioctl(struct file *file, unsigned cmd, unsigned long arg)
+ {
+ 	int ret;
+ 	void __user *argp = compat_ptr(arg);
+ 	struct inode *inode = file->f_mapping->host;
+ 	struct block_device *bdev = inode->i_bdev;
+ 	struct gendisk *disk = bdev->bd_disk;
+ 	fmode_t mode = file->f_mode;
+ 	loff_t size;
+ 
+ 	/*
+ 	 * O_NDELAY can be altered using fcntl(.., F_SETFL, ..), so we have
+ 	 * to updated it before every ioctl.
+ 	 */
+ 	if (file->f_flags & O_NDELAY)
+ 		mode |= FMODE_NDELAY;
+ 	else
+ 		mode &= ~FMODE_NDELAY;
+ 
+ 	switch (cmd) {
+ 	/* These need separate implementations for the data structure */
+ 	case HDIO_GETGEO:
+ 		return compat_hdio_getgeo(bdev, argp);
+ 	case BLKPG:
+ 		return compat_blkpg_ioctl(bdev, argp);
+ 
+ 	/* Compat mode returns 32-bit data instead of 'long' */
+ 	case BLKRAGET:
+ 	case BLKFRAGET:
+ 		if (!argp)
+ 			return -EINVAL;
+ 		return compat_put_long(argp,
+ 			       (bdev->bd_bdi->ra_pages * PAGE_SIZE) / 512);
+ 	case BLKGETSIZE:
+ 		size = i_size_read(bdev->bd_inode);
+ 		if ((size >> 9) > ~0UL)
+ 			return -EFBIG;
+ 		return compat_put_ulong(argp, size >> 9);
+ 
+ 	/* The data is compatible, but the command number is different */
+ 	case BLKBSZGET_32: /* get the logical block size (cf. BLKSSZGET) */
+ 		return put_int(argp, bdev_logical_block_size(bdev));
+ 	case BLKBSZSET_32:
+ 		return blkdev_bszset(bdev, mode, argp);
+ 	case BLKGETSIZE64_32:
+ 		return put_u64(argp, i_size_read(bdev->bd_inode));
+ 
+ 	/* Incompatible alignment on i386 */
+ 	case BLKTRACESETUP32:
+ 		return blk_trace_ioctl(bdev, cmd, argp);
+ 	default:
+ 		break;
+ 	}
+ 
+ 	ret = blkdev_common_ioctl(bdev, mode, cmd, arg, argp);
+ 	if (ret == -ENOIOCTLCMD && disk->fops->compat_ioctl)
+ 		ret = disk->fops->compat_ioctl(bdev, mode, cmd, arg);
+ 
+ 	return ret;
+ }
+ #endif
++>>>>>>> 9b81648cb5e3 (compat_ioctl: simplify up block/ioctl.c)
* Unmerged path block/ioctl.c
