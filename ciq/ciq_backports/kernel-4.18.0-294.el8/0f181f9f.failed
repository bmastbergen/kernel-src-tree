mm/slub.c: init_on_free=1 should wipe freelist ptr for bulk allocations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Alexander Potapenko <glider@google.com>
commit 0f181f9fbea8bc7ea2f7e13ae7f8c256b39e254c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0f181f9f.failed

slab_alloc_node() already zeroed out the freelist pointer if
init_on_free was on.  Thibaut Sautereau noticed that the same needs to
be done for kmem_cache_alloc_bulk(), which performs the allocations
separately.

kmem_cache_alloc_bulk() is currently used in two places in the kernel,
so this change is unlikely to have a major performance impact.

SLAB doesn't require a similar change, as auto-initialization makes the
allocator store the freelist pointers off-slab.

Link: http://lkml.kernel.org/r/20191007091605.30530-1-glider@google.com
Fixes: 6471384af2a6 ("mm: security: introduce init_on_alloc=1 and init_on_free=1 boot options")
	Signed-off-by: Alexander Potapenko <glider@google.com>
	Reported-by: Thibaut Sautereau <thibaut@sautereau.fr>
	Reported-by: Kees Cook <keescook@chromium.org>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Laura Abbott <labbott@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0f181f9fbea8bc7ea2f7e13ae7f8c256b39e254c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index e5e6151e373d,b25c807a111f..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -2757,8 -2770,10 +2768,13 @@@ redo
  		prefetch_freepointer(s, next_object);
  		stat(s, ALLOC_FASTPATH);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	maybe_wipe_obj_freeptr(s, object);
++>>>>>>> 0f181f9fbea8 (mm/slub.c: init_on_free=1 should wipe freelist ptr for bulk allocations)
  
 -	if (unlikely(slab_want_init_on_alloc(gfpflags, s)) && object)
 +	if (unlikely(gfpflags & __GFP_ZERO) && object)
  		memset(object, 0, s->object_size);
  
  	slab_post_alloc_hook(s, gfpflags, 1, &object);
* Unmerged path mm/slub.c
