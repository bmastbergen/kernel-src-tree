iommu/vt-d: Move Kconfig and Makefile bits down into intel directory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jerry Snitselaar <jsnitsel@redhat.com>
commit ab65ba57e3acb55920999f96a6152228b52a2f49
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ab65ba57.failed

Move Intel Kconfig and Makefile bits down into intel directory
with the rest of the Intel specific files.

	Signed-off-by: Jerry Snitselaar <jsnitsel@redhat.com>
	Reviewed-by: Lu Baolu <baolu.lu@linux.intel.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Cc: Lu Baolu <baolu.lu@linux.intel.com>
Link: https://lore.kernel.org/r/20200630200636.48600-2-jsnitsel@redhat.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit ab65ba57e3acb55920999f96a6152228b52a2f49)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/Kconfig
#	drivers/iommu/Makefile
diff --cc drivers/iommu/Kconfig
index e0bc43a8d316,e9e1238aac21..000000000000
--- a/drivers/iommu/Kconfig
+++ b/drivers/iommu/Kconfig
@@@ -175,91 -172,7 +175,95 @@@ config AMD_IOMMU_DEBUGF
  	  This option is -NOT- intended for production environments, and should
  	  not generally be enabled.
  
++<<<<<<< HEAD
 +# Intel IOMMU support
 +config DMAR_TABLE
 +	bool
 +
 +config INTEL_IOMMU
 +	bool "Support for Intel IOMMU using DMA Remapping Devices"
 +	depends on PCI_MSI && ACPI && (X86 || IA64_GENERIC)
 +	select IOMMU_API
 +	select IOMMU_IOVA
 +	select NEED_DMA_MAP_STATE
 +	select DMAR_TABLE
 +	select SWIOTLB
 +	select IOASID
 +	help
 +	  DMA remapping (DMAR) devices support enables independent address
 +	  translations for Direct Memory Access (DMA) from devices.
 +	  These DMA remapping devices are reported via ACPI tables
 +	  and include PCI device scope covered by these DMA
 +	  remapping devices.
 +
 +config INTEL_IOMMU_DEBUGFS
 +	bool "Export Intel IOMMU internals in Debugfs"
 +	depends on INTEL_IOMMU && IOMMU_DEBUGFS
 +	help
 +	  !!!WARNING!!!
 +
 +	  DO NOT ENABLE THIS OPTION UNLESS YOU REALLY KNOW WHAT YOU ARE DOING!!!
 +
 +	  Expose Intel IOMMU internals in Debugfs.
 +
 +	  This option is -NOT- intended for production environments, and should
 +	  only be enabled for debugging Intel IOMMU.
 +
 +config INTEL_IOMMU_SVM
 +	bool "Support for Shared Virtual Memory with Intel IOMMU"
 +	depends on INTEL_IOMMU && X86_64
 +	select PCI_PASID
 +	select PCI_PRI
 +	select MMU_NOTIFIER
 +	select IOASID
 +	help
 +	  Shared Virtual Memory (SVM) provides a facility for devices
 +	  to access DMA resources through process address space by
 +	  means of a Process Address Space ID (PASID).
 +
 +config INTEL_IOMMU_DEFAULT_ON
 +	def_bool y
 +	prompt "Enable Intel DMA Remapping Devices by default"
 +	depends on INTEL_IOMMU
 +	help
 +	  Selecting this option will enable a DMAR device at boot time if
 +	  one is found. If this option is not selected, DMAR support can
 +	  be enabled by passing intel_iommu=on to the kernel.
 +
 +config INTEL_IOMMU_BROKEN_GFX_WA
 +	bool "Workaround broken graphics drivers (going away soon)"
 +	depends on INTEL_IOMMU && BROKEN && X86
 +	---help---
 +	  Current Graphics drivers tend to use physical address
 +	  for DMA and avoid using DMA APIs. Setting this config
 +	  option permits the IOMMU driver to set a unity map for
 +	  all the OS-visible memory. Hence the driver can continue
 +	  to use physical addresses for DMA, at least until this
 +	  option is removed in the 2.6.32 kernel.
 +
 +config INTEL_IOMMU_FLOPPY_WA
 +	def_bool y
 +	depends on INTEL_IOMMU && X86
 +	---help---
 +	  Floppy disk drivers are known to bypass DMA API calls
 +	  thereby failing to work when IOMMU is enabled. This
 +	  workaround will setup a 1:1 mapping for the first
 +	  16MiB to make floppy (an ISA device) work.
 +
 +config INTEL_IOMMU_SCALABLE_MODE_DEFAULT_ON
 +	bool "Enable Intel IOMMU scalable mode by default"
 +	depends on INTEL_IOMMU
 +	help
 +	  Selecting this option will enable by default the scalable mode if
 +	  hardware presents the capability. The scalable mode is defined in
 +	  VT-d 3.0. The scalable mode capability could be checked by reading
 +	  /sys/devices/virtual/iommu/dmar*/intel-iommu/ecap. If this option
 +	  is not selected, scalable mode support could also be enabled by
 +	  passing intel_iommu=sm_on to the kernel. If not sure, please use
 +	  the default value.
++=======
+ source "drivers/iommu/intel/Kconfig"
++>>>>>>> ab65ba57e3ac (iommu/vt-d: Move Kconfig and Makefile bits down into intel directory)
  
  config IRQ_REMAP
  	bool "Support for Interrupt Remapping"
diff --cc drivers/iommu/Makefile
index a193c2534821,71dd2f382e78..000000000000
--- a/drivers/iommu/Makefile
+++ b/drivers/iommu/Makefile
@@@ -11,18 -12,14 +12,23 @@@ obj-$(CONFIG_IOASID) += ioasid.
  obj-$(CONFIG_IOMMU_IOVA) += iova.o
  obj-$(CONFIG_OF_IOMMU)	+= of_iommu.o
  obj-$(CONFIG_MSM_IOMMU) += msm_iommu.o
 -obj-$(CONFIG_AMD_IOMMU) += amd/iommu.o amd/init.o amd/quirks.o
 -obj-$(CONFIG_AMD_IOMMU_DEBUGFS) += amd/debugfs.o
 -obj-$(CONFIG_AMD_IOMMU_V2) += amd/iommu_v2.o
 -obj-$(CONFIG_ARM_SMMU) += arm_smmu.o
 -arm_smmu-objs += arm-smmu.o arm-smmu-impl.o arm-smmu-qcom.o
 +obj-$(CONFIG_AMD_IOMMU) += amd_iommu.o amd_iommu_init.o amd_iommu_quirks.o
 +obj-$(CONFIG_AMD_IOMMU_DEBUGFS) += amd_iommu_debugfs.o
 +obj-$(CONFIG_AMD_IOMMU_V2) += amd_iommu_v2.o
 +obj-$(CONFIG_ARM_SMMU) += arm-smmu.o
  obj-$(CONFIG_ARM_SMMU_V3) += arm-smmu-v3.o
++<<<<<<< HEAD
 +obj-$(CONFIG_DMAR_TABLE) += dmar.o
 +obj-$(CONFIG_INTEL_IOMMU) += intel-iommu.o intel-pasid.o
 +obj-$(CONFIG_INTEL_IOMMU) += intel-trace.o
 +obj-$(CONFIG_INTEL_IOMMU_DEBUGFS) += intel-iommu-debugfs.o
 +obj-$(CONFIG_INTEL_IOMMU_SVM) += intel-svm.o
 +obj-$(CONFIG_IPMMU_VMSA) += ipmmu-vmsa.o
 +obj-$(CONFIG_IRQ_REMAP) += intel_irq_remapping.o irq_remapping.o
++=======
+ obj-$(CONFIG_IPMMU_VMSA) += ipmmu-vmsa.o
+ obj-$(CONFIG_IRQ_REMAP) += irq_remapping.o
++>>>>>>> ab65ba57e3ac (iommu/vt-d: Move Kconfig and Makefile bits down into intel directory)
  obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o
  obj-$(CONFIG_MTK_IOMMU_V1) += mtk_iommu_v1.o
  obj-$(CONFIG_OMAP_IOMMU) += omap-iommu.o
* Unmerged path drivers/iommu/Kconfig
* Unmerged path drivers/iommu/Makefile
diff --git a/drivers/iommu/intel/Kconfig b/drivers/iommu/intel/Kconfig
new file mode 100644
index 000000000000..877beec9d987
--- /dev/null
+++ b/drivers/iommu/intel/Kconfig
@@ -0,0 +1,86 @@
+# SPDX-License-Identifier: GPL-2.0-only
+# Intel IOMMU support
+config DMAR_TABLE
+	bool
+
+config INTEL_IOMMU
+	bool "Support for Intel IOMMU using DMA Remapping Devices"
+	depends on PCI_MSI && ACPI && (X86 || IA64)
+	select IOMMU_API
+	select IOMMU_IOVA
+	select NEED_DMA_MAP_STATE
+	select DMAR_TABLE
+	select SWIOTLB
+	select IOASID
+	help
+	  DMA remapping (DMAR) devices support enables independent address
+	  translations for Direct Memory Access (DMA) from devices.
+	  These DMA remapping devices are reported via ACPI tables
+	  and include PCI device scope covered by these DMA
+	  remapping devices.
+
+config INTEL_IOMMU_DEBUGFS
+	bool "Export Intel IOMMU internals in Debugfs"
+	depends on INTEL_IOMMU && IOMMU_DEBUGFS
+	help
+	  !!!WARNING!!!
+
+	  DO NOT ENABLE THIS OPTION UNLESS YOU REALLY KNOW WHAT YOU ARE DOING!!!
+
+	  Expose Intel IOMMU internals in Debugfs.
+
+	  This option is -NOT- intended for production environments, and should
+	  only be enabled for debugging Intel IOMMU.
+
+config INTEL_IOMMU_SVM
+	bool "Support for Shared Virtual Memory with Intel IOMMU"
+	depends on INTEL_IOMMU && X86_64
+	select PCI_PASID
+	select PCI_PRI
+	select MMU_NOTIFIER
+	select IOASID
+	help
+	  Shared Virtual Memory (SVM) provides a facility for devices
+	  to access DMA resources through process address space by
+	  means of a Process Address Space ID (PASID).
+
+config INTEL_IOMMU_DEFAULT_ON
+	def_bool y
+	prompt "Enable Intel DMA Remapping Devices by default"
+	depends on INTEL_IOMMU
+	help
+	  Selecting this option will enable a DMAR device at boot time if
+	  one is found. If this option is not selected, DMAR support can
+	  be enabled by passing intel_iommu=on to the kernel.
+
+config INTEL_IOMMU_BROKEN_GFX_WA
+	bool "Workaround broken graphics drivers (going away soon)"
+	depends on INTEL_IOMMU && BROKEN && X86
+	help
+	  Current Graphics drivers tend to use physical address
+	  for DMA and avoid using DMA APIs. Setting this config
+	  option permits the IOMMU driver to set a unity map for
+	  all the OS-visible memory. Hence the driver can continue
+	  to use physical addresses for DMA, at least until this
+	  option is removed in the 2.6.32 kernel.
+
+config INTEL_IOMMU_FLOPPY_WA
+	def_bool y
+	depends on INTEL_IOMMU && X86
+	help
+	  Floppy disk drivers are known to bypass DMA API calls
+	  thereby failing to work when IOMMU is enabled. This
+	  workaround will setup a 1:1 mapping for the first
+	  16MiB to make floppy (an ISA device) work.
+
+config INTEL_IOMMU_SCALABLE_MODE_DEFAULT_ON
+	bool "Enable Intel IOMMU scalable mode by default"
+	depends on INTEL_IOMMU
+	help
+	  Selecting this option will enable by default the scalable mode if
+	  hardware presents the capability. The scalable mode is defined in
+	  VT-d 3.0. The scalable mode capability could be checked by reading
+	  /sys/devices/virtual/iommu/dmar*/intel-iommu/ecap. If this option
+	  is not selected, scalable mode support could also be enabled by
+	  passing intel_iommu=sm_on to the kernel. If not sure, please use
+	  the default value.
diff --git a/drivers/iommu/intel/Makefile b/drivers/iommu/intel/Makefile
new file mode 100644
index 000000000000..fb8e1e8c8029
--- /dev/null
+++ b/drivers/iommu/intel/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_DMAR_TABLE) += dmar.o
+obj-$(CONFIG_INTEL_IOMMU) += iommu.o pasid.o
+obj-$(CONFIG_INTEL_IOMMU) += trace.o
+obj-$(CONFIG_INTEL_IOMMU_DEBUGFS) += debugfs.o
+obj-$(CONFIG_INTEL_IOMMU_SVM) += svm.o
+obj-$(CONFIG_IRQ_REMAP) += irq_remapping.o
