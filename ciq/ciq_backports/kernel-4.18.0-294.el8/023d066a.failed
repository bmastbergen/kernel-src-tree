vfs: Kill sget_userns()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 023d066a0d0a87696c04b0de2ceae53063d0b655
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/023d066a.failed

Kill sget_userns(), folding it into sget() as that's the only remaining
user.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: linux-fsdevel@vger.kernel.org
(cherry picked from commit 023d066a0d0a87696c04b0de2ceae53063d0b655)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/super.c
#	include/linux/fs.h
diff --cc fs/super.c
index 72596c26684f,ca2302501d32..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -478,33 -476,118 +478,43 @@@ void generic_shutdown_super(struct supe
  
  EXPORT_SYMBOL(generic_shutdown_super);
  
 -bool mount_capable(struct fs_context *fc)
 -{
 -	struct user_namespace *user_ns = fc->global ? &init_user_ns
 -						    : fc->user_ns;
 -
 -	if (!(fc->fs_type->fs_flags & FS_USERNS_MOUNT))
 -		return capable(CAP_SYS_ADMIN);
 -	else
 -		return ns_capable(user_ns, CAP_SYS_ADMIN);
 -}
 -
 -/**
 - * sget_fc - Find or create a superblock
 - * @fc:	Filesystem context.
 - * @test: Comparison callback
 - * @set: Setup callback
 - *
 - * Find or create a superblock using the parameters stored in the filesystem
 - * context and the two callback functions.
 - *
 - * If an extant superblock is matched, then that will be returned with an
 - * elevated reference count that the caller must transfer or discard.
 - *
 - * If no match is made, a new superblock will be allocated and basic
 - * initialisation will be performed (s_type, s_fs_info and s_id will be set and
 - * the set() callback will be invoked), the superblock will be published and it
 - * will be returned in a partially constructed state with SB_BORN and SB_ACTIVE
 - * as yet unset.
 - */
 -struct super_block *sget_fc(struct fs_context *fc,
 -			    int (*test)(struct super_block *, struct fs_context *),
 -			    int (*set)(struct super_block *, struct fs_context *))
 -{
 -	struct super_block *s = NULL;
 -	struct super_block *old;
 -	struct user_namespace *user_ns = fc->global ? &init_user_ns : fc->user_ns;
 -	int err;
 -
 -retry:
 -	spin_lock(&sb_lock);
 -	if (test) {
 -		hlist_for_each_entry(old, &fc->fs_type->fs_supers, s_instances) {
 -			if (test(old, fc))
 -				goto share_extant_sb;
 -		}
 -	}
 -	if (!s) {
 -		spin_unlock(&sb_lock);
 -		s = alloc_super(fc->fs_type, fc->sb_flags, user_ns);
 -		if (!s)
 -			return ERR_PTR(-ENOMEM);
 -		goto retry;
 -	}
 -
 -	s->s_fs_info = fc->s_fs_info;
 -	err = set(s, fc);
 -	if (err) {
 -		s->s_fs_info = NULL;
 -		spin_unlock(&sb_lock);
 -		destroy_unused_super(s);
 -		return ERR_PTR(err);
 -	}
 -	fc->s_fs_info = NULL;
 -	s->s_type = fc->fs_type;
 -	s->s_iflags |= fc->s_iflags;
 -	strlcpy(s->s_id, s->s_type->name, sizeof(s->s_id));
 -	list_add_tail(&s->s_list, &super_blocks);
 -	hlist_add_head(&s->s_instances, &s->s_type->fs_supers);
 -	spin_unlock(&sb_lock);
 -	get_filesystem(s->s_type);
 -	register_shrinker_prepared(&s->s_shrink);
 -	return s;
 -
 -share_extant_sb:
 -	if (user_ns != old->s_user_ns) {
 -		spin_unlock(&sb_lock);
 -		destroy_unused_super(s);
 -		return ERR_PTR(-EBUSY);
 -	}
 -	if (!grab_super(old))
 -		goto retry;
 -	destroy_unused_super(s);
 -	return old;
 -}
 -EXPORT_SYMBOL(sget_fc);
 -
  /**
-  *	sget_userns -	find or create a superblock
-  *	@type:	filesystem type superblock should belong to
-  *	@test:	comparison callback
-  *	@set:	setup callback
-  *	@flags:	mount flags
-  *	@user_ns: User namespace for the super_block
-  *	@data:	argument to each of them
+  *	sget	-	find or create a superblock
+  *	@type:	  filesystem type superblock should belong to
+  *	@test:	  comparison callback
+  *	@set:	  setup callback
+  *	@flags:	  mount flags
+  *	@data:	  argument to each of them
   */
- struct super_block *sget_userns(struct file_system_type *type,
+ struct super_block *sget(struct file_system_type *type,
  			int (*test)(struct super_block *,void *),
  			int (*set)(struct super_block *,void *),
- 			int flags, struct user_namespace *user_ns,
+ 			int flags,
  			void *data)
  {
+ 	struct user_namespace *user_ns = current_user_ns();
  	struct super_block *s = NULL;
  	struct super_block *old;
  	int err;
  
++<<<<<<< HEAD
 +	/* Ensure the requestor has permissions over the target filesystem */
 +	if (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))
 +		return ERR_PTR(-EPERM);
 +
 +	if (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&
 +	    !(type->fs_flags & FS_USERNS_MOUNT) &&
 +	    !capable(CAP_SYS_ADMIN))
 +		return ERR_PTR(-EPERM);
++=======
+ 	/* We don't yet pass the user namespace of the parent
+ 	 * mount through to here so always use &init_user_ns
+ 	 * until that changes.
+ 	 */
+ 	if (flags & SB_SUBMOUNT)
+ 		user_ns = &init_user_ns;
+ 
++>>>>>>> 023d066a0d0a (vfs: Kill sget_userns())
  retry:
  	spin_lock(&sb_lock);
  	if (test) {
diff --cc include/linux/fs.h
index feabaa0642d8,71421856ff2c..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -2268,13 -2239,12 +2268,19 @@@ void kill_litter_super(struct super_blo
  void deactivate_super(struct super_block *sb);
  void deactivate_locked_super(struct super_block *sb);
  int set_anon_super(struct super_block *s, void *data);
 -int set_anon_super_fc(struct super_block *s, struct fs_context *fc);
  int get_anon_bdev(dev_t *);
  void free_anon_bdev(dev_t);
++<<<<<<< HEAD
 +struct super_block *sget_userns(struct file_system_type *type,
 +			int (*test)(struct super_block *,void *),
 +			int (*set)(struct super_block *,void *),
 +			int flags, struct user_namespace *user_ns,
 +			void *data);
++=======
+ struct super_block *sget_fc(struct fs_context *fc,
+ 			    int (*test)(struct super_block *, struct fs_context *),
+ 			    int (*set)(struct super_block *, struct fs_context *));
++>>>>>>> 023d066a0d0a (vfs: Kill sget_userns())
  struct super_block *sget(struct file_system_type *type,
  			int (*test)(struct super_block *,void *),
  			int (*set)(struct super_block *,void *),
* Unmerged path fs/super.c
* Unmerged path include/linux/fs.h
