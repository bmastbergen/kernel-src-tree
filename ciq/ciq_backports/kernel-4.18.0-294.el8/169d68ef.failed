selinux: switch away from match_token()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 169d68efb03b728588c209c682f14328eec485c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/169d68ef.failed

It's not a good fit, unfortunately, and the next step will make it
even less so.  Open-code what we need here.

	Reviewed-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 169d68efb03b728588c209c682f14328eec485c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 42145010da10,8f2285cb9029..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -1013,125 -1006,83 +1035,201 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int selinux_add_opt(int token, const char *s, void **mnt_opts)
+ {
+ 	struct selinux_mnt_opts *opts = *mnt_opts;
+ 
+ 	if (token == Opt_labelsupport)	/* eaten and completely ignored */
+ 		return 0;
+ 
+ 	if (!opts) {
+ 		opts = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);
+ 		if (!opts)
+ 			return -ENOMEM;
+ 		*mnt_opts = opts;
+ 	}
+ 	if (!s)
+ 		return -ENOMEM;
+ 	switch (token) {
+ 	case Opt_context:
+ 		if (opts->context || opts->defcontext)
+ 			goto Einval;
+ 		opts->context = s;
+ 		break;
+ 	case Opt_fscontext:
+ 		if (opts->fscontext)
+ 			goto Einval;
+ 		opts->fscontext = s;
+ 		break;
+ 	case Opt_rootcontext:
+ 		if (opts->rootcontext)
+ 			goto Einval;
+ 		opts->rootcontext = s;
+ 		break;
+ 	case Opt_defcontext:
+ 		if (opts->context || opts->defcontext)
+ 			goto Einval;
+ 		opts->defcontext = s;
+ 		break;
+ 	}
+ 	return 0;
+ Einval:
+ 	pr_warn(SEL_MOUNT_FAIL_MSG);
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> 169d68efb03b (selinux: switch away from match_token())
  static int selinux_parse_opts_str(char *options,
 -				  void **mnt_opts)
 +				  struct security_mnt_opts *opts)
  {
++<<<<<<< HEAD
 +	char *p;
 +	char *context = NULL, *defcontext = NULL;
 +	char *fscontext = NULL, *rootcontext = NULL;
 +	int rc, num_mnt_opts = 0;
 +
 +	opts->num_mnt_opts = 0;
 +
 +	/* Standard string-based options. */
 +	while ((p = strsep(&options, "|")) != NULL) {
 +		int token;
 +		substring_t args[MAX_OPT_ARGS];
++=======
+ 	char *p = options, *next;
+ 	int rc;
+ 
+ 	/* Standard string-based options. */
+ 	for (p = options; *p; p = next) {
+ 		int token, len;
+ 		char *arg = NULL;
++>>>>>>> 169d68efb03b (selinux: switch away from match_token())
+ 
+ 		next = strchr(p, '|');
+ 		if (next) {
+ 			len = next++ - p;
+ 		} else {
+ 			len = strlen(p);
+ 			next = p + len;
+ 		}
  
- 		if (!*p)
+ 		if (!len)
  			continue;
  
++<<<<<<< HEAD
 +		token = match_token(p, tokens, args);
 +
 +		switch (token) {
 +		case Opt_context:
 +			if (context || defcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			context = match_strdup(&args[0]);
 +			if (!context) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_fscontext:
 +			if (fscontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			fscontext = match_strdup(&args[0]);
 +			if (!fscontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_rootcontext:
 +			if (rootcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			rootcontext = match_strdup(&args[0]);
 +			if (!rootcontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +
 +		case Opt_defcontext:
 +			if (context || defcontext) {
 +				rc = -EINVAL;
 +				pr_warn(SEL_MOUNT_FAIL_MSG);
 +				goto out_err;
 +			}
 +			defcontext = match_strdup(&args[0]);
 +			if (!defcontext) {
 +				rc = -ENOMEM;
 +				goto out_err;
 +			}
 +			break;
 +		case Opt_labelsupport:
 +			break;
 +		default:
 +			rc = -EINVAL;
 +			pr_warn("SELinux:  unknown mount option\n");
 +			goto out_err;
 +
++=======
+ 		token = match_opt_prefix(p, len, &arg);
+ 		if (arg)
+ 			arg = kmemdup_nul(arg, p + len - arg, GFP_KERNEL);
+ 		rc = selinux_add_opt(token, arg, mnt_opts);
+ 		if (rc) {
+ 			kfree(arg);
+ 			selinux_free_mnt_opts(*mnt_opts);
+ 			*mnt_opts = NULL;
+ 			return rc;
++>>>>>>> 169d68efb03b (selinux: switch away from match_token())
  		}
  	}
 +
 +	rc = -ENOMEM;
 +	opts->mnt_opts = kcalloc(NUM_SEL_MNT_OPTS, sizeof(char *), GFP_KERNEL);
 +	if (!opts->mnt_opts)
 +		goto out_err;
 +
 +	opts->mnt_opts_flags = kcalloc(NUM_SEL_MNT_OPTS, sizeof(int),
 +				       GFP_KERNEL);
 +	if (!opts->mnt_opts_flags)
 +		goto out_err;
 +
 +	if (fscontext) {
 +		opts->mnt_opts[num_mnt_opts] = fscontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = FSCONTEXT_MNT;
 +	}
 +	if (context) {
 +		opts->mnt_opts[num_mnt_opts] = context;
 +		opts->mnt_opts_flags[num_mnt_opts++] = CONTEXT_MNT;
 +	}
 +	if (rootcontext) {
 +		opts->mnt_opts[num_mnt_opts] = rootcontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = ROOTCONTEXT_MNT;
 +	}
 +	if (defcontext) {
 +		opts->mnt_opts[num_mnt_opts] = defcontext;
 +		opts->mnt_opts_flags[num_mnt_opts++] = DEFCONTEXT_MNT;
 +	}
 +
 +	opts->num_mnt_opts = num_mnt_opts;
  	return 0;
 +
 +out_err:
 +	security_free_mnt_opts(opts);
 +	kfree(context);
 +	kfree(defcontext);
 +	kfree(fscontext);
 +	kfree(rootcontext);
 +	return rc;
  }
  
  static int show_sid(struct seq_file *m, u32 sid)
* Unmerged path security/selinux/hooks.c
