convenience helper get_tree_nodev()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 2ac295d4f0c095310addbcb03d91d2a4c9f7d435
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2ac295d4.failed

counterpart of mount_nodev().  Switch hugetlb and pseudo to it.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 2ac295d4f0c095310addbcb03d91d2a4c9f7d435)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/libfs.c
#	include/linux/fs_context.h
diff --cc fs/libfs.c
index df5499c95c24,c9463dc6a5d4..000000000000
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@@ -241,19 -237,40 +241,23 @@@ static const struct super_operations si
  	.statfs		= simple_statfs,
  };
  
 -static int pseudo_fs_fill_super(struct super_block *s, struct fs_context *fc)
 +static int pseudo_fs_get_tree(struct fs_context *fc)
  {
++<<<<<<< HEAD
  	struct pseudo_fs_context *ctx = fc->fs_private;
 -	struct inode *root;
 +	struct dentry *root;
  
 -	s->s_maxbytes = MAX_LFS_FILESIZE;
 -	s->s_blocksize = PAGE_SIZE;
 -	s->s_blocksize_bits = PAGE_SHIFT;
 -	s->s_magic = ctx->magic;
 -	s->s_op = ctx->ops ?: &simple_super_operations;
 -	s->s_xattr = ctx->xattr;
 -	s->s_time_gran = 1;
 -	root = new_inode(s);
 -	if (!root)
 -		return -ENOMEM;
 +	root = mount_pseudo_xattr(fc->fs_type,
 +				  ctx->ops, ctx->xattr,
 +			          ctx->dops, ctx->magic);
 +	if (IS_ERR(root))
 +		return PTR_ERR(root);
  
 -	/*
 -	 * since this is the first inode, make it number 1. New inodes created
 -	 * after this must take care not to collide with it (by passing
 -	 * max_reserved of 1 to iunique).
 -	 */
 -	root->i_ino = 1;
 -	root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
 -	root->i_atime = root->i_mtime = root->i_ctime = current_time(root);
 -	s->s_root = d_make_root(root);
 -	if (!s->s_root)
 -		return -ENOMEM;
 -	s->s_d_op = ctx->dops;
 +	fc->root = root;
  	return 0;
 -}
 -
 -static int pseudo_fs_get_tree(struct fs_context *fc)
 -{
++=======
+ 	return get_tree_nodev(fc, pseudo_fs_fill_super);
++>>>>>>> 2ac295d4f0c0 (convenience helper get_tree_nodev())
  }
  
  static void pseudo_fs_free(struct fs_context *fc)
* Unmerged path include/linux/fs_context.h
diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index fa79438e4554..2ab1dbf37bac 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -1287,7 +1287,7 @@ static int hugetlbfs_get_tree(struct fs_context *fc)
 	int err = hugetlbfs_validate(fc);
 	if (err)
 		return err;
-	return vfs_get_super(fc, vfs_get_independent_super, hugetlbfs_fill_super);
+	return get_tree_nodev(fc, hugetlbfs_fill_super);
 }
 
 static void hugetlbfs_fs_context_free(struct fs_context *fc)
* Unmerged path fs/libfs.c
diff --git a/fs/super.c b/fs/super.c
index 72596c26684f..b1e7ae24b531 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -1084,6 +1084,14 @@ struct dentry *mount_ns(struct file_system_type *fs_type,
 
 EXPORT_SYMBOL(mount_ns);
 
+int get_tree_nodev(struct fs_context *fc,
+		  int (*fill_super)(struct super_block *sb,
+				    struct fs_context *fc))
+{
+	return vfs_get_super(fc, vfs_get_independent_super, fill_super);
+}
+EXPORT_SYMBOL(get_tree_nodev);
+
 #ifdef CONFIG_BLOCK
 static int set_bdev_super(struct super_block *s, void *data)
 {
* Unmerged path include/linux/fs_context.h
