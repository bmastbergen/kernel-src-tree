blk-mq: move getting driver tag and budget into one helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 7538352453189abf3a96461e187b1085b0ae0c6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/75383524.failed

Move code for getting driver tag and budget into one helper, so
blk_mq_dispatch_rq_list gets a bit simplified, and easier to read.

Meantime move updating of 'no_tag' and 'no_budget_available' into
the branch for handling partial dispatch because that is exactly
consumer of the two local variables.

Also rename the parameter of 'got_budget' as 'ask_budget'.

No functional change.

	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Tested-by: Baolin Wang <baolin.wang7@gmail.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Christoph Hellwig <hch@infradead.org>
	Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
	Cc: Sagi Grimberg <sagi@grimberg.me>
	Cc: Baolin Wang <baolin.wang7@gmail.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 7538352453189abf3a96461e187b1085b0ae0c6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 50f2205ff855,3e370f5bc40a..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1208,18 -1242,64 +1208,75 @@@ static void blk_mq_handle_dev_resource(
  	__blk_mq_requeue_request(rq);
  }
  
++<<<<<<< HEAD
++=======
+ static void blk_mq_handle_zone_resource(struct request *rq,
+ 					struct list_head *zone_list)
+ {
+ 	/*
+ 	 * If we end up here it is because we cannot dispatch a request to a
+ 	 * specific zone due to LLD level zone-write locking or other zone
+ 	 * related resource not being available. In this case, set the request
+ 	 * aside in zone_list for retrying it later.
+ 	 */
+ 	list_add(&rq->queuelist, zone_list);
+ 	__blk_mq_requeue_request(rq);
+ }
+ 
+ enum prep_dispatch {
+ 	PREP_DISPATCH_OK,
+ 	PREP_DISPATCH_NO_TAG,
+ 	PREP_DISPATCH_NO_BUDGET,
+ };
+ 
+ static enum prep_dispatch blk_mq_prep_dispatch_rq(struct request *rq,
+ 						  bool need_budget)
+ {
+ 	struct blk_mq_hw_ctx *hctx = rq->mq_hctx;
+ 
+ 	if (need_budget && !blk_mq_get_dispatch_budget(rq->q)) {
+ 		blk_mq_put_driver_tag(rq);
+ 		return PREP_DISPATCH_NO_BUDGET;
+ 	}
+ 
+ 	if (!blk_mq_get_driver_tag(rq)) {
+ 		/*
+ 		 * The initial allocation attempt failed, so we need to
+ 		 * rerun the hardware queue when a tag is freed. The
+ 		 * waitqueue takes care of that. If the queue is run
+ 		 * before we add this entry back on the dispatch list,
+ 		 * we'll re-run it below.
+ 		 */
+ 		if (!blk_mq_mark_tag_wait(hctx, rq)) {
+ 			blk_mq_put_dispatch_budget(rq->q);
+ 			return PREP_DISPATCH_NO_TAG;
+ 		}
+ 	}
+ 
+ 	return PREP_DISPATCH_OK;
+ }
+ 
++>>>>>>> 753835245318 (blk-mq: move getting driver tag and budget into one helper)
  /*
   * Returns true if we did some work AND can potentially do more.
   */
 -bool blk_mq_dispatch_rq_list(struct blk_mq_hw_ctx *hctx, struct list_head *list,
 +bool blk_mq_dispatch_rq_list(struct request_queue *q, struct list_head *list,
  			     bool got_budget)
  {
++<<<<<<< HEAD
 +	struct blk_mq_hw_ctx *hctx;
++=======
+ 	enum prep_dispatch prep;
+ 	struct request_queue *q = hctx->queue;
++>>>>>>> 753835245318 (blk-mq: move getting driver tag and budget into one helper)
  	struct request *rq, *nxt;
- 	bool no_tag = false;
  	int errors, queued;
  	blk_status_t ret = BLK_STS_OK;
++<<<<<<< HEAD
 +	bool no_budget_avail = false;
++=======
+ 	LIST_HEAD(zone_list);
++>>>>>>> 753835245318 (blk-mq: move getting driver tag and budget into one helper)
  
  	if (list_empty(list))
  		return false;
@@@ -1235,32 -1315,10 +1292,39 @@@
  
  		rq = list_first_entry(list, struct request, queuelist);
  
++<<<<<<< HEAD
 +		hctx = rq->mq_hctx;
 +		if (!got_budget && !blk_mq_get_dispatch_budget(hctx)) {
 +			blk_mq_put_driver_tag(rq);
 +			no_budget_avail = true;
 +			break;
 +		}
 +
 +		if (!blk_mq_get_driver_tag(rq)) {
 +			/*
 +			 * The initial allocation attempt failed, so we need to
 +			 * rerun the hardware queue when a tag is freed. The
 +			 * waitqueue takes care of that. If the queue is run
 +			 * before we add this entry back on the dispatch list,
 +			 * we'll re-run it below.
 +			 */
 +			if (!blk_mq_mark_tag_wait(hctx, rq)) {
 +				blk_mq_put_dispatch_budget(hctx);
 +				/*
 +				 * For non-shared tags, the RESTART check
 +				 * will suffice.
 +				 */
 +				if (hctx->flags & BLK_MQ_F_TAG_SHARED)
 +					no_tag = true;
 +				break;
 +			}
 +		}
++=======
+ 		WARN_ON_ONCE(hctx != rq->mq_hctx);
+ 		prep = blk_mq_prep_dispatch_rq(rq, !got_budget);
+ 		if (prep != PREP_DISPATCH_OK)
+ 			break;
++>>>>>>> 753835245318 (blk-mq: move getting driver tag and budget into one helper)
  
  		list_del_init(&rq->queuelist);
  
* Unmerged path block/blk-mq.c
