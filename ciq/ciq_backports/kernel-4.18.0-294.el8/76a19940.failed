dma-direct: atomic allocations must come from atomic coherent pools

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Rientjes <rientjes@google.com>
commit 76a19940bd62a81148c303f3df6d0cee9ae4b509
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/76a19940.failed

When a device requires unencrypted memory and the context does not allow
blocking, memory must be returned from the atomic coherent pools.

This avoids the remap when CONFIG_DMA_DIRECT_REMAP is not enabled and the
config only requires CONFIG_DMA_COHERENT_POOL.  This will be used for
CONFIG_AMD_MEM_ENCRYPT in a subsequent patch.

Keep all memory in these pools unencrypted.  When set_memory_decrypted()
fails, this prohibits the memory from being added.  If adding memory to
the genpool fails, and set_memory_encrypted() subsequently fails, there
is no alternative other than leaking the memory.

	Signed-off-by: David Rientjes <rientjes@google.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 76a19940bd62a81148c303f3df6d0cee9ae4b509)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
#	kernel/dma/pool.c
diff --cc kernel/dma/direct.c
index 6ff74c282557,0a4881e59aa7..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -125,10 -158,8 +158,15 @@@ void *dma_direct_alloc_pages(struct dev
  	struct page *page;
  	void *ret;
  
++<<<<<<< HEAD
 +	if (IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
 +	    dma_alloc_need_uncached(dev, attrs) &&
 +	    !gfpflags_allow_blocking(gfp)) {
 +		ret = dma_alloc_from_pool(PAGE_ALIGN(size), &page, gfp);
++=======
+ 	if (dma_should_alloc_from_pool(dev, gfp, attrs)) {
+ 		ret = dma_alloc_from_pool(dev, PAGE_ALIGN(size), &page, gfp);
++>>>>>>> 76a19940bd62 (dma-direct: atomic allocations must come from atomic coherent pools)
  		if (!ret)
  			return NULL;
  		goto done;
@@@ -209,10 -247,6 +252,13 @@@ void dma_direct_free_pages(struct devic
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
 +	    dma_free_from_pool(cpu_addr, PAGE_ALIGN(size)))
 +		return;
 +
++=======
++>>>>>>> 76a19940bd62 (dma-direct: atomic allocations must come from atomic coherent pools)
  	if (force_dma_unencrypted(dev))
  		set_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);
  
* Unmerged path kernel/dma/pool.c
* Unmerged path kernel/dma/direct.c
* Unmerged path kernel/dma/pool.c
