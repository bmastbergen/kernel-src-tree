mptcp: send out dedicated packet for ADD_ADDR using port

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit fbe0f87ac7710de31f9c37280b08e0d0d43aa6bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fbe0f87a.failed

The process is similar to that of the ADD_ADDR IPv6, this patch also sent
out a pure ack for the ADD_ADDR using port.

	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fbe0f87ac7710de31f9c37280b08e0d0d43aa6bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/options.c
#	net/mptcp/pm.c
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/options.c
index af3f2e566740,9505b11a6577..000000000000
--- a/net/mptcp/options.c
+++ b/net/mptcp/options.c
@@@ -579,14 -583,27 +579,26 @@@ static bool mptcp_established_options_a
  {
  	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);
  	struct mptcp_sock *msk = mptcp_sk(subflow->conn);
 -	bool drop_other_suboptions = false;
 -	unsigned int opt_size = *size;
  	struct mptcp_addr_info saddr;
 -	bool echo;
 -	bool port;
  	int len;
  
++<<<<<<< HEAD
++=======
+ 	if ((mptcp_pm_should_add_signal_ipv6(msk) ||
+ 	     mptcp_pm_should_add_signal_port(msk)) &&
+ 	    skb && skb_is_tcp_pure_ack(skb)) {
+ 		pr_debug("drop other suboptions");
+ 		opts->suboptions = 0;
+ 		remaining += opt_size;
+ 		drop_other_suboptions = true;
+ 	}
+ 
++>>>>>>> fbe0f87ac771 (mptcp: send out dedicated packet for ADD_ADDR using port)
  	if (!mptcp_pm_should_add_signal(msk) ||
 -	    !(mptcp_pm_add_addr_signal(msk, remaining, &saddr, &echo, &port)))
 +	    !(mptcp_pm_add_addr_signal(msk, remaining, &saddr)))
  		return false;
  
 -	len = mptcp_add_addr_len(saddr.family, echo, port);
 +	len = mptcp_add_addr_len(saddr.family);
  	if (remaining < len)
  		return false;
  
diff --cc net/mptcp/pm.c
index a78fc80f9b51,0c456747893e..000000000000
--- a/net/mptcp/pm.c
+++ b/net/mptcp/pm.c
@@@ -139,17 -153,36 +139,36 @@@ void mptcp_pm_add_addr_received(struct 
  	pr_debug("msk=%p remote_id=%d accept=%d", msk, addr->id,
  		 READ_ONCE(pm->accept_addr));
  
++<<<<<<< HEAD
 +	/* avoid acquiring the lock if there is no room for fouther addresses */
 +	if (!READ_ONCE(pm->accept_addr))
++=======
+ 	spin_lock_bh(&pm->lock);
+ 
+ 	if (!READ_ONCE(pm->accept_addr)) {
+ 		mptcp_pm_announce_addr(msk, addr, true);
+ 		mptcp_pm_add_addr_send_ack(msk);
+ 	} else if (mptcp_pm_schedule_work(msk, MPTCP_PM_ADD_ADDR_RECEIVED)) {
+ 		pm->remote = *addr;
+ 	}
+ 
+ 	spin_unlock_bh(&pm->lock);
+ }
+ 
+ void mptcp_pm_add_addr_send_ack(struct mptcp_sock *msk)
+ {
+ 	if (!mptcp_pm_should_add_signal_ipv6(msk) &&
+ 	    !mptcp_pm_should_add_signal_port(msk))
++>>>>>>> fbe0f87ac771 (mptcp: send out dedicated packet for ADD_ADDR using port)
  		return;
  
 -	mptcp_pm_schedule_work(msk, MPTCP_PM_ADD_ADDR_SEND_ACK);
 -}
 -
 -void mptcp_pm_rm_addr_received(struct mptcp_sock *msk, u8 rm_id)
 -{
 -	struct mptcp_pm_data *pm = &msk->pm;
 +	spin_lock_bh(&pm->lock);
  
 -	pr_debug("msk=%p remote_id=%d", msk, rm_id);
 +	/* be sure there is something to signal re-checking under PM lock */
 +	if (READ_ONCE(pm->accept_addr) &&
 +	    mptcp_pm_schedule_work(msk, MPTCP_PM_ADD_ADDR_RECEIVED))
 +		pm->remote = *addr;
  
 -	spin_lock_bh(&pm->lock);
 -	mptcp_pm_schedule_work(msk, MPTCP_PM_RM_ADDR_RECEIVED);
 -	pm->rm_id = rm_id;
  	spin_unlock_bh(&pm->lock);
  }
  
diff --cc net/mptcp/pm_netlink.c
index 6f3bf9fdbbbc,7a0f700e34bb..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -267,8 -396,114 +267,117 @@@ void mptcp_pm_nl_add_addr_received(stru
  	local.family = remote.family;
  
  	spin_unlock_bh(&msk->pm.lock);
 -	__mptcp_subflow_connect((struct sock *)msk, &local, &remote);
 +	__mptcp_subflow_connect((struct sock *)msk, 0, &local, &remote);
  	spin_lock_bh(&msk->pm.lock);
++<<<<<<< HEAD
++=======
+ 
+ 	mptcp_pm_announce_addr(msk, &remote, true);
+ 	mptcp_pm_nl_add_addr_send_ack(msk);
+ }
+ 
+ void mptcp_pm_nl_add_addr_send_ack(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow;
+ 
+ 	if (!mptcp_pm_should_add_signal_ipv6(msk) &&
+ 	    !mptcp_pm_should_add_signal_port(msk))
+ 		return;
+ 
+ 	__mptcp_flush_join_list(msk);
+ 	subflow = list_first_entry_or_null(&msk->conn_list, typeof(*subflow), node);
+ 	if (subflow) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		u8 add_addr;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		if (mptcp_pm_should_add_signal_ipv6(msk))
+ 			pr_debug("send ack for add_addr6");
+ 		if (mptcp_pm_should_add_signal_port(msk))
+ 			pr_debug("send ack for add_addr_port");
+ 
+ 		lock_sock(ssk);
+ 		tcp_send_ack(ssk);
+ 		release_sock(ssk);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		add_addr = READ_ONCE(msk->pm.add_addr_signal);
+ 		if (mptcp_pm_should_add_signal_ipv6(msk))
+ 			add_addr &= ~BIT(MPTCP_ADD_ADDR_IPV6);
+ 		if (mptcp_pm_should_add_signal_port(msk))
+ 			add_addr &= ~BIT(MPTCP_ADD_ADDR_PORT);
+ 		WRITE_ONCE(msk->pm.add_addr_signal, add_addr);
+ 	}
+ }
+ 
+ void mptcp_pm_nl_rm_addr_received(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("address rm_id %d", msk->pm.rm_id);
+ 
+ 	if (!msk->pm.rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 
+ 		if (msk->pm.rm_id != subflow->remote_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.add_addr_accepted--;
+ 		msk->pm.subflows--;
+ 		WRITE_ONCE(msk->pm.accept_addr, true);
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMADDR);
+ 
+ 		break;
+ 	}
+ }
+ 
+ void mptcp_pm_nl_rm_subflow_received(struct mptcp_sock *msk, u8 rm_id)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("subflow rm_id %d", rm_id);
+ 
+ 	if (!rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 
+ 		if (rm_id != subflow->local_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.local_addr_used--;
+ 		msk->pm.subflows--;
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMSUBFLOW);
+ 
+ 		break;
+ 	}
++>>>>>>> fbe0f87ac771 (mptcp: send out dedicated packet for ADD_ADDR using port)
  }
  
  static bool address_use_port(struct mptcp_pm_addr_entry *entry)
* Unmerged path net/mptcp/options.c
* Unmerged path net/mptcp/pm.c
* Unmerged path net/mptcp/pm_netlink.c
