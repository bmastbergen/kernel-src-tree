ARM/arm64: vdso: Use common vdso clock mode storage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 5e3c6a312a0946d2d83e32359612cbb925a8bed0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5e3c6a31.failed

Convert ARM/ARM64 to the generic VDSO clock mode storage. This needs to
happen in one go as they share the clocksource driver.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
Link: https://lkml.kernel.org/r/20200207124403.363235229@linutronix.de



(cherry picked from commit 5e3c6a312a0946d2d83e32359612cbb925a8bed0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/Kconfig
#	arch/arm/include/asm/vdso/gettimeofday.h
#	arch/arm/include/asm/vdso/vsyscall.h
#	arch/arm/mm/Kconfig
#	arch/arm64/Kconfig
#	arch/arm64/include/asm/vdso/gettimeofday.h
#	arch/arm64/include/asm/vdso/vsyscall.h
diff --cc arch/arm/Kconfig
index 2e4a73955452,03bbfc312fe7..000000000000
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@@ -2,15 -2,19 +2,20 @@@
  config ARM
  	bool
  	default y
++<<<<<<< HEAD
 +	select ARCH_CLOCKSOURCE_DATA
 +	select ARCH_DISCARD_MEMBLOCK if !HAVE_ARCH_PFN_VALID && !KEXEC
++=======
+ 	select ARCH_32BIT_OFF_T
+ 	select ARCH_HAS_BINFMT_FLAT
++>>>>>>> 5e3c6a312a09 (ARM/arm64: vdso: Use common vdso clock mode storage)
  	select ARCH_HAS_DEBUG_VIRTUAL if MMU
  	select ARCH_HAS_DEVMEM_IS_ALLOWED
 -	select ARCH_HAS_DMA_WRITE_COMBINE if !ARM_DMA_MEM_BUFFERABLE
  	select ARCH_HAS_ELF_RANDOMIZE
  	select ARCH_HAS_FORTIFY_SOURCE
 -	select ARCH_HAS_KEEPINITRD
  	select ARCH_HAS_KCOV
 -	select ARCH_HAS_MEMBARRIER_SYNC_CORE
  	select ARCH_HAS_PTE_SPECIAL if ARM_LPAE
  	select ARCH_HAS_PHYS_TO_DMA
 -	select ARCH_HAS_SETUP_DMA_OPS
  	select ARCH_HAS_SET_MEMORY
  	select ARCH_HAS_STRICT_KERNEL_RWX if MMU && !XIP_KERNEL
  	select ARCH_HAS_STRICT_MODULE_RWX if MMU
diff --cc arch/arm/mm/Kconfig
index 96a7b6cf459b,865e888bb84f..000000000000
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@@ -888,7 -896,11 +888,13 @@@ config VDS
  	bool "Enable VDSO for acceleration of some system calls"
  	depends on AEABI && MMU && CPU_V7
  	default y if ARM_ARCH_TIMER
 -	select HAVE_GENERIC_VDSO
  	select GENERIC_TIME_VSYSCALL
++<<<<<<< HEAD
++=======
+ 	select GENERIC_VDSO_32
+ 	select GENERIC_GETTIMEOFDAY
+ 	select GENERIC_VDSO_CLOCK_MODE
++>>>>>>> 5e3c6a312a09 (ARM/arm64: vdso: Use common vdso clock mode storage)
  	help
  	  Place in the process address space an ELF shared object
  	  providing fast implementations of gettimeofday and
diff --cc arch/arm64/Kconfig
index d3f3af6e3b68,7809d4976269..000000000000
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -5,10 -6,9 +5,9 @@@ config ARM6
  	select ACPI_GTDT if ACPI
  	select ACPI_IORT if ACPI
  	select ACPI_REDUCED_HARDWARE_ONLY if ACPI
 -	select ACPI_MCFG if (ACPI && PCI)
 +	select ACPI_MCFG if ACPI
  	select ACPI_SPCR_TABLE if ACPI
  	select ACPI_PPTT if ACPI
- 	select ARCH_CLOCKSOURCE_DATA
  	select ARCH_HAS_DEBUG_VIRTUAL
  	select ARCH_HAS_DEVMEM_IS_ALLOWED
  	select ARCH_HAS_DMA_PREP_COHERENT
@@@ -104,8 -109,11 +103,13 @@@
  	select GENERIC_STRNCPY_FROM_USER
  	select GENERIC_STRNLEN_USER
  	select GENERIC_TIME_VSYSCALL
++<<<<<<< HEAD
++=======
+ 	select GENERIC_GETTIMEOFDAY
+ 	select GENERIC_VDSO_CLOCK_MODE
++>>>>>>> 5e3c6a312a09 (ARM/arm64: vdso: Use common vdso clock mode storage)
  	select HANDLE_DOMAIN_IRQ
  	select HARDIRQS_SW_RESEND
 -	select HAVE_PCI
  	select HAVE_ACPI_APEI if (ACPI && EFI)
  	select HAVE_ALIGNED_STRUCT_PAGE if SLUB
  	select HAVE_ARCH_AUDITSYSCALL
* Unmerged path arch/arm/include/asm/vdso/gettimeofday.h
* Unmerged path arch/arm/include/asm/vdso/vsyscall.h
* Unmerged path arch/arm64/include/asm/vdso/gettimeofday.h
* Unmerged path arch/arm64/include/asm/vdso/vsyscall.h
* Unmerged path arch/arm/Kconfig
diff --git a/arch/arm/include/asm/clocksource.h b/arch/arm/include/asm/clocksource.h
index 0b350a7e26f3..73beb7f131de 100644
--- a/arch/arm/include/asm/clocksource.h
+++ b/arch/arm/include/asm/clocksource.h
@@ -1,8 +1,7 @@
 #ifndef _ASM_CLOCKSOURCE_H
 #define _ASM_CLOCKSOURCE_H
 
-struct arch_clocksource_data {
-	bool vdso_direct;	/* Usable for direct VDSO access? */
-};
+#define VDSO_ARCH_CLOCKMODES	\
+	VDSO_CLOCKMODE_ARCHTIMER
 
 #endif
* Unmerged path arch/arm/include/asm/vdso/gettimeofday.h
* Unmerged path arch/arm/include/asm/vdso/vsyscall.h
* Unmerged path arch/arm/mm/Kconfig
* Unmerged path arch/arm64/Kconfig
diff --git a/arch/arm64/include/asm/clocksource.h b/arch/arm64/include/asm/clocksource.h
index 0ece64a26c8c..eb82e9d95c5d 100644
--- a/arch/arm64/include/asm/clocksource.h
+++ b/arch/arm64/include/asm/clocksource.h
@@ -2,8 +2,7 @@
 #ifndef _ASM_CLOCKSOURCE_H
 #define _ASM_CLOCKSOURCE_H
 
-struct arch_clocksource_data {
-	bool vdso_direct;	/* Usable for direct VDSO access? */
-};
+#define VDSO_ARCH_CLOCKMODES	\
+	VDSO_CLOCKMODE_ARCHTIMER
 
 #endif
diff --git a/arch/arm64/include/asm/vdso/compat_gettimeofday.h b/arch/arm64/include/asm/vdso/compat_gettimeofday.h
index 537b1e695365..81b0c394f1d8 100644
--- a/arch/arm64/include/asm/vdso/compat_gettimeofday.h
+++ b/arch/arm64/include/asm/vdso/compat_gettimeofday.h
@@ -12,8 +12,6 @@
 
 #include <asm/vdso/compat_barrier.h>
 
-#define __VDSO_USE_SYSCALL		ULLONG_MAX
-
 #define VDSO_HAS_CLOCK_GETRES		1
 
 #define BUILD_VDSO32			1
@@ -117,11 +115,12 @@ static __always_inline u64 __arch_get_hw_counter(s32 clock_mode)
 	u64 res;
 
 	/*
-	 * clock_mode == 0 implies that vDSO are enabled otherwise
-	 * fallback on syscall.
+	 * Core checks for mode already, so this raced against a concurrent
+	 * update. Return something. Core will do another round and then
+	 * see the mode change and fallback to the syscall.
 	 */
-	if (clock_mode)
-		return __VDSO_USE_SYSCALL;
+	if (clock_mode == VDSO_CLOCKMODE_NONE)
+		return 0;
 
 	/*
 	 * This isb() is required to prevent that the counter value
* Unmerged path arch/arm64/include/asm/vdso/gettimeofday.h
* Unmerged path arch/arm64/include/asm/vdso/vsyscall.h
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index 1c1c342815ad..74aeb4317412 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -75,7 +75,7 @@ static enum arch_timer_ppi_nr arch_timer_uses_ppi = ARCH_TIMER_VIRT_PPI;
 static bool arch_timer_c3stop;
 static bool arch_timer_mem_use_virtual;
 static bool arch_counter_suspend_stop;
-static bool vdso_default = true;
+static enum vdso_clock_mode vdso_default = VDSO_CLOCKMODE_ARCHTIMER;
 
 static cpumask_t evtstrm_available = CPU_MASK_NONE;
 static bool evtstrm_enable = IS_ENABLED(CONFIG_ARM_ARCH_TIMER_EVTSTREAM);
@@ -511,8 +511,8 @@ void arch_timer_enable_workaround(const struct arch_timer_erratum_workaround *wa
 	 * change both the default value and the vdso itself.
 	 */
 	if (wa->read_cntvct_el0) {
-		clocksource_counter.archdata.vdso_direct = false;
-		vdso_default = false;
+		clocksource_counter.vdso_clock_mode = VDSO_CLOCKMODE_NONE;
+		vdso_default = VDSO_CLOCKMODE_NONE;
 	}
 }
 
@@ -933,7 +933,7 @@ static void __init arch_counter_register(unsigned type)
 		}
 
 		arch_timer_read_counter = rd;
-		clocksource_counter.archdata.vdso_direct = vdso_default;
+		clocksource_counter.vdso_clock_mode = vdso_default;
 	} else {
 		arch_timer_read_counter = arch_counter_get_cntvct_mem;
 	}
