KVM: x86: drop KVM_PV_REASON_PAGE_READY case from kvm_handle_page_fault()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 9ce372b33a2ebbd0b965148879ae169a0015d3f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9ce372b3.failed

KVM guest code in Linux enables APF only when KVM_FEATURE_ASYNC_PF_INT
is supported, this means we will never see KVM_PV_REASON_PAGE_READY
when handling page fault vmexit in KVM.

While on it, make sure we only follow genuine page fault path when
APF reason is zero. If we happen to see something else this means
that the underlying hypervisor is misbehaving. Leave WARN_ON_ONCE()
to catch that.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9ce372b33a2ebbd0b965148879ae169a0015d3f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 7c4e06bfb997,3ca70554d5f1..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -4164,28 -4165,22 +4165,43 @@@ int kvm_handle_page_fault(struct kvm_vc
  #endif
  
  	vcpu->arch.l1tf_flush_l1d = true;
++<<<<<<< HEAD
 +	switch (vcpu->arch.apf.host_apf_reason) {
 +	default:
++=======
+ 	if (!flags) {
++>>>>>>> 9ce372b33a2e (KVM: x86: drop KVM_PV_REASON_PAGE_READY case from kvm_handle_page_fault())
  		trace_kvm_page_fault(fault_address, error_code);
  
  		if (kvm_event_needs_reinjection(vcpu))
  			kvm_mmu_unprotect_page_virt(vcpu, fault_address);
  		r = kvm_mmu_page_fault(vcpu, fault_address, error_code, insn,
  				insn_len);
++<<<<<<< HEAD
 +		break;
 +	case KVM_PV_REASON_PAGE_NOT_PRESENT:
 +		vcpu->arch.apf.host_apf_reason = 0;
++=======
+ 	} else if (flags & KVM_PV_REASON_PAGE_NOT_PRESENT) {
+ 		vcpu->arch.apf.host_apf_flags = 0;
++>>>>>>> 9ce372b33a2e (KVM: x86: drop KVM_PV_REASON_PAGE_READY case from kvm_handle_page_fault())
 +		local_irq_disable();
 +		kvm_async_pf_task_wait(fault_address, 0);
 +		local_irq_enable();
++<<<<<<< HEAD
 +		break;
 +	case KVM_PV_REASON_PAGE_READY:
 +		vcpu->arch.apf.host_apf_reason = 0;
  		local_irq_disable();
 -		kvm_async_pf_task_wait_schedule(fault_address);
 +		kvm_async_pf_task_wake(fault_address);
  		local_irq_enable();
 +		break;
++=======
+ 	} else {
+ 		WARN_ONCE(1, "Unexpected host async PF flags: %x\n", flags);
++>>>>>>> 9ce372b33a2e (KVM: x86: drop KVM_PV_REASON_PAGE_READY case from kvm_handle_page_fault())
  	}
+ 
  	return r;
  }
  EXPORT_SYMBOL_GPL(kvm_handle_page_fault);
* Unmerged path arch/x86/kvm/mmu/mmu.c
