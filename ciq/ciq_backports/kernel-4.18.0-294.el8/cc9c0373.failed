RDMA/cma: Remove unneeded locking for req paths

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit cc9c037343898eb7a775e6b81d092ee21eeff218
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cc9c0373.failed

The REQ flows are concerned that once the handler is called on the new
cm_id the ULP can choose to trigger a rdma_destroy_id() concurrently at
any time.

However, this is not true, while the ULP can call rdma_destroy_id(), it
immediately blocks on the handler_mutex which prevents anything harmful
from running concurrently.

Remove the confusing extra locking and refcounts and make the
handler_mutex protecting state during destroy more clear.

Link: https://lore.kernel.org/r/20200723070707.1771101-4-leon@kernel.org
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit cc9c037343898eb7a775e6b81d092ee21eeff218)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cma.c
diff --cc drivers/infiniband/core/cma.c
index abf2fb7b598e,e07498dceb59..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -2198,11 -2201,6 +2198,14 @@@ static int cma_ib_req_handler(struct ib
  	cm_id->context = conn_id;
  	cm_id->cm_handler = cma_ib_handler;
  
++<<<<<<< HEAD
 +	/*
 +	 * Protect against the user destroying conn_id from another thread
 +	 * until we're done accessing it.
 +	 */
 +	atomic_inc(&conn_id->refcount);
++=======
++>>>>>>> cc9c03734389 (RDMA/cma: Remove unneeded locking for req paths)
  	ret = cma_cm_event_handler(conn_id, &event);
  	if (ret)
  		goto err3;
@@@ -2219,13 -2212,11 +2217,19 @@@
  	mutex_unlock(&lock);
  	mutex_unlock(&conn_id->handler_mutex);
  	mutex_unlock(&listen_id->handler_mutex);
++<<<<<<< HEAD
 +	cma_deref_id(conn_id);
++=======
++>>>>>>> cc9c03734389 (RDMA/cma: Remove unneeded locking for req paths)
  	if (net_dev)
  		dev_put(net_dev);
  	return 0;
  
  err3:
++<<<<<<< HEAD
 +	cma_deref_id(conn_id);
++=======
++>>>>>>> cc9c03734389 (RDMA/cma: Remove unneeded locking for req paths)
  	/* Destroy the CM ID by returning a non-zero value. */
  	conn_id->cm_id.ib = NULL;
  err2:
@@@ -2402,11 -2393,6 +2406,14 @@@ static int iw_conn_req_handler(struct i
  	memcpy(cma_src_addr(conn_id), laddr, rdma_addr_size(laddr));
  	memcpy(cma_dst_addr(conn_id), raddr, rdma_addr_size(raddr));
  
++<<<<<<< HEAD
 +	/*
 +	 * Protect against the user destroying conn_id from another thread
 +	 * until we're done accessing it.
 +	 */
 +	atomic_inc(&conn_id->refcount);
++=======
++>>>>>>> cc9c03734389 (RDMA/cma: Remove unneeded locking for req paths)
  	ret = cma_cm_event_handler(conn_id, &event);
  	if (ret) {
  		/* User wants to destroy the CM ID */
@@@ -2414,13 -2400,11 +2421,19 @@@
  		cma_exch(conn_id, RDMA_CM_DESTROYING);
  		mutex_unlock(&conn_id->handler_mutex);
  		mutex_unlock(&listen_id->handler_mutex);
++<<<<<<< HEAD
 +		cma_deref_id(conn_id);
++=======
++>>>>>>> cc9c03734389 (RDMA/cma: Remove unneeded locking for req paths)
  		rdma_destroy_id(&conn_id->id);
  		return ret;
  	}
  
  	mutex_unlock(&conn_id->handler_mutex);
++<<<<<<< HEAD
 +	cma_deref_id(conn_id);
++=======
++>>>>>>> cc9c03734389 (RDMA/cma: Remove unneeded locking for req paths)
  
  out:
  	mutex_unlock(&listen_id->handler_mutex);
* Unmerged path drivers/infiniband/core/cma.c
