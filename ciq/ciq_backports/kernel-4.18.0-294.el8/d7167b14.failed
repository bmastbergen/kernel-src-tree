fs_parse: fold fs_parameter_desc/fs_parameter_spec

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit d7167b149943e38ad610191ecbb0800c78bbced9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d7167b14.failed

The former contains nothing but a pointer to an array of the latter...

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit d7167b149943e38ad610191ecbb0800c78bbced9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/cell/spufs/inode.c
#	arch/s390/hypfs/inode.c
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
#	drivers/base/devtmpfs.c
#	drivers/block/rbd.c
#	drivers/usb/gadget/function/f_fs.c
#	fs/afs/super.c
#	fs/ceph/super.c
#	fs/fs_parser.c
#	fs/fuse/inode.c
#	fs/gfs2/ops_fstype.c
#	fs/hugetlbfs/inode.c
#	fs/jffs2/super.c
#	fs/nfs/fs_context.c
#	fs/proc/root.c
#	fs/ramfs/inode.c
#	fs/xfs/xfs_super.c
#	include/linux/fs.h
#	include/linux/fs_parser.h
#	include/linux/ramfs.h
#	include/linux/shmem_fs.h
#	kernel/bpf/inode.c
#	kernel/cgroup/cgroup-internal.h
#	kernel/cgroup/cgroup-v1.c
#	kernel/cgroup/cgroup.c
#	mm/shmem.c
#	net/ceph/ceph_common.c
#	security/selinux/hooks.c
#	security/smack/smack_lsm.c
diff --cc arch/powerpc/platforms/cell/spufs/inode.c
index db329d4bf1c3,25390569e24c..000000000000
--- a/arch/powerpc/platforms/cell/spufs/inode.c
+++ b/arch/powerpc/platforms/cell/spufs/inode.c
@@@ -593,16 -573,22 +593,25 @@@ long spufs_create(struct path *path, st
  }
  
  /* File system initialization */
 -struct spufs_fs_context {
 -	kuid_t	uid;
 -	kgid_t	gid;
 -	umode_t	mode;
 -};
 -
  enum {
 -	Opt_uid, Opt_gid, Opt_mode, Opt_debug,
 +	Opt_uid, Opt_gid, Opt_mode, Opt_debug, Opt_err,
  };
  
++<<<<<<< HEAD
 +static const match_table_t spufs_tokens = {
 +	{ Opt_uid,   "uid=%d" },
 +	{ Opt_gid,   "gid=%d" },
 +	{ Opt_mode,  "mode=%o" },
 +	{ Opt_debug, "debug" },
 +	{ Opt_err,    NULL  },
++=======
+ static const struct fs_parameter_spec spufs_fs_parameters[] = {
+ 	fsparam_u32	("gid",				Opt_gid),
+ 	fsparam_u32oct	("mode",			Opt_mode),
+ 	fsparam_u32	("uid",				Opt_uid),
+ 	fsparam_flag	("debug",			Opt_debug),
+ 	{}
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  };
  
  static int spufs_show_options(struct seq_file *m, struct dentry *root)
@@@ -623,47 -609,41 +632,53 @@@
  	return 0;
  }
  
 -static int spufs_parse_param(struct fs_context *fc, struct fs_parameter *param)
 +static int
 +spufs_parse_options(struct super_block *sb, char *options, struct inode *root)
  {
 -	struct spufs_fs_context *ctx = fc->fs_private;
 -	struct spufs_sb_info *sbi = fc->s_fs_info;
 -	struct fs_parse_result result;
 -	kuid_t uid;
 -	kgid_t gid;
 -	int opt;
 +	char *p;
 +	substring_t args[MAX_OPT_ARGS];
  
++<<<<<<< HEAD
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int token, option;
++=======
+ 	opt = fs_parse(fc, spufs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
 -
 -	switch (opt) {
 -	case Opt_uid:
 -		uid = make_kuid(current_user_ns(), result.uint_32);
 -		if (!uid_valid(uid))
 -			return invalf(fc, "Unknown uid");
 -		ctx->uid = uid;
 -		break;
 -	case Opt_gid:
 -		gid = make_kgid(current_user_ns(), result.uint_32);
 -		if (!gid_valid(gid))
 -			return invalf(fc, "Unknown gid");
 -		ctx->gid = gid;
 -		break;
 -	case Opt_mode:
 -		ctx->mode = result.uint_32 & S_IALLUGO;
 -		break;
 -	case Opt_debug:
 -		sbi->debug = true;
 -		break;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, spufs_tokens, args);
 +		switch (token) {
 +		case Opt_uid:
 +			if (match_int(&args[0], &option))
 +				return 0;
 +			root->i_uid = make_kuid(current_user_ns(), option);
 +			if (!uid_valid(root->i_uid))
 +				return 0;
 +			break;
 +		case Opt_gid:
 +			if (match_int(&args[0], &option))
 +				return 0;
 +			root->i_gid = make_kgid(current_user_ns(), option);
 +			if (!gid_valid(root->i_gid))
 +				return 0;
 +			break;
 +		case Opt_mode:
 +			if (match_octal(&args[0], &option))
 +				return 0;
 +			root->i_mode = option | S_IFDIR;
 +			break;
 +		case Opt_debug:
 +			spufs_get_sb_info(sb)->debug = 1;
 +			break;
 +		default:
 +			return 0;
 +		}
  	}
 -
 -	return 0;
 +	return 1;
  }
  
  static void spufs_exit_isolated_loader(void)
@@@ -769,7 -768,8 +784,12 @@@ spufs_mount(struct file_system_type *fs
  static struct file_system_type spufs_type = {
  	.owner = THIS_MODULE,
  	.name = "spufs",
++<<<<<<< HEAD
 +	.mount = spufs_mount,
++=======
+ 	.init_fs_context = spufs_init_fs_context,
+ 	.parameters	= spufs_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb = kill_litter_super,
  };
  MODULE_ALIAS_FS("spufs");
diff --cc arch/s390/hypfs/inode.c
index 06b513d192b9,5c97f48cea91..000000000000
--- a/arch/s390/hypfs/inode.c
+++ b/arch/s390/hypfs/inode.c
@@@ -207,52 -207,39 +207,68 @@@ static int hypfs_release(struct inode *
  	return 0;
  }
  
 -enum { Opt_uid, Opt_gid, };
 +enum { opt_uid, opt_gid, opt_err };
  
++<<<<<<< HEAD
 +static const match_table_t hypfs_tokens = {
 +	{opt_uid, "uid=%u"},
 +	{opt_gid, "gid=%u"},
 +	{opt_err, NULL}
 +};
 +
 +static int hypfs_parse_options(char *options, struct super_block *sb)
++=======
+ static const struct fs_parameter_spec hypfs_fs_parameters[] = {
+ 	fsparam_u32("gid", Opt_gid),
+ 	fsparam_u32("uid", Opt_uid),
+ 	{}
+ };
+ 
+ static int hypfs_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  {
 -	struct hypfs_sb_info *hypfs_info = fc->s_fs_info;
 -	struct fs_parse_result result;
 +	char *str;
 +	substring_t args[MAX_OPT_ARGS];
  	kuid_t uid;
  	kgid_t gid;
 -	int opt;
  
++<<<<<<< HEAD
 +	if (!options)
 +		return 0;
 +	while ((str = strsep(&options, ",")) != NULL) {
 +		int token, option;
 +		struct hypfs_sb_info *hypfs_info = sb->s_fs_info;
++=======
+ 	opt = fs_parse(fc, hypfs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
 -
 -	switch (opt) {
 -	case Opt_uid:
 -		uid = make_kuid(current_user_ns(), result.uint_32);
 -		if (!uid_valid(uid))
 -			return invalf(fc, "Unknown uid");
 -		hypfs_info->uid = uid;
 -		break;
 -	case Opt_gid:
 -		gid = make_kgid(current_user_ns(), result.uint_32);
 -		if (!gid_valid(gid))
 -			return invalf(fc, "Unknown gid");
 -		hypfs_info->gid = gid;
 -		break;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
 +
 +		if (!*str)
 +			continue;
 +		token = match_token(str, hypfs_tokens, args);
 +		switch (token) {
 +		case opt_uid:
 +			if (match_int(&args[0], &option))
 +				return -EINVAL;
 +			uid = make_kuid(current_user_ns(), option);
 +			if (!uid_valid(uid))
 +				return -EINVAL;
 +			hypfs_info->uid = uid;
 +			break;
 +		case opt_gid:
 +			if (match_int(&args[0], &option))
 +				return -EINVAL;
 +			gid = make_kgid(current_user_ns(), option);
 +			if (!gid_valid(gid))
 +				return -EINVAL;
 +			hypfs_info->gid = gid;
 +			break;
 +		case opt_err:
 +		default:
 +			pr_err("%s is not a valid mount option\n", str);
 +			return -EINVAL;
 +		}
  	}
  	return 0;
  }
@@@ -442,7 -449,8 +458,12 @@@ static const struct file_operations hyp
  static struct file_system_type hypfs_type = {
  	.owner		= THIS_MODULE,
  	.name		= "s390_hypfs",
++<<<<<<< HEAD
 +	.mount		= hypfs_mount,
++=======
+ 	.init_fs_context = hypfs_init_fs_context,
+ 	.parameters	= hypfs_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb	= hypfs_kill_super
  };
  
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index 08d67c922eb5,9891b4648de4..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -2232,8 -2027,80 +2232,82 @@@ out
  	rdt_last_cmd_clear();
  	mutex_unlock(&rdtgroup_mutex);
  	cpus_read_unlock();
 -	return ret;
 -}
  
++<<<<<<< HEAD
 +	return dentry;
++=======
+ enum rdt_param {
+ 	Opt_cdp,
+ 	Opt_cdpl2,
+ 	Opt_mba_mbps,
+ 	nr__rdt_params
+ };
+ 
+ static const struct fs_parameter_spec rdt_fs_parameters[] = {
+ 	fsparam_flag("cdp",		Opt_cdp),
+ 	fsparam_flag("cdpl2",		Opt_cdpl2),
+ 	fsparam_flag("mba_MBps",	Opt_mba_mbps),
+ 	{}
+ };
+ 
+ static int rdt_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct rdt_fs_context *ctx = rdt_fc2context(fc);
+ 	struct fs_parse_result result;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, rdt_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_cdp:
+ 		ctx->enable_cdpl3 = true;
+ 		return 0;
+ 	case Opt_cdpl2:
+ 		ctx->enable_cdpl2 = true;
+ 		return 0;
+ 	case Opt_mba_mbps:
+ 		if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)
+ 			return -EINVAL;
+ 		ctx->enable_mba_mbps = true;
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static void rdt_fs_context_free(struct fs_context *fc)
+ {
+ 	struct rdt_fs_context *ctx = rdt_fc2context(fc);
+ 
+ 	kernfs_free_fs_context(fc);
+ 	kfree(ctx);
+ }
+ 
+ static const struct fs_context_operations rdt_fs_context_ops = {
+ 	.free		= rdt_fs_context_free,
+ 	.parse_param	= rdt_parse_param,
+ 	.get_tree	= rdt_get_tree,
+ };
+ 
+ static int rdt_init_fs_context(struct fs_context *fc)
+ {
+ 	struct rdt_fs_context *ctx;
+ 
+ 	ctx = kzalloc(sizeof(struct rdt_fs_context), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	ctx->kfc.root = rdt_root;
+ 	ctx->kfc.magic = RDTGROUP_SUPER_MAGIC;
+ 	fc->fs_private = &ctx->kfc;
+ 	fc->ops = &rdt_fs_context_ops;
+ 	put_user_ns(fc->user_ns);
+ 	fc->user_ns = get_user_ns(&init_user_ns);
+ 	fc->global = true;
+ 	return 0;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  }
  
  static int reset_all_ctrls(struct rdt_resource *r)
@@@ -2402,9 -2273,10 +2476,16 @@@ static void rdt_kill_sb(struct super_bl
  }
  
  static struct file_system_type rdt_fs_type = {
++<<<<<<< HEAD
 +	.name    = "resctrl",
 +	.mount   = rdt_mount,
 +	.kill_sb = rdt_kill_sb,
++=======
+ 	.name			= "resctrl",
+ 	.init_fs_context	= rdt_init_fs_context,
+ 	.parameters		= rdt_fs_parameters,
+ 	.kill_sb		= rdt_kill_sb,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  };
  
  static int mon_addfile(struct kernfs_node *parent_kn, const char *name,
diff --cc drivers/base/devtmpfs.c
index b57b81af7f5b,3db9e4df1aff..000000000000
--- a/drivers/base/devtmpfs.c
+++ b/drivers/base/devtmpfs.c
@@@ -66,19 -67,15 +66,29 @@@ static struct dentry *public_dev_mount(
  	return dget(s->s_root);
  }
  
 +static struct dentry *dev_mount(struct file_system_type *fs_type, int flags,
 +		      const char *dev_name, void *data)
 +{
 +#ifdef CONFIG_TMPFS
 +	return shmem_mount(fs_type, flags, dev_name, data);
 +#else
 +	return ramfs_mount(fs_type, flags, dev_name, data);
 +#endif
 +}
 +
  static struct file_system_type internal_fs_type = {
  	.name = "devtmpfs",
++<<<<<<< HEAD
 +	.mount = dev_mount,
++=======
+ #ifdef CONFIG_TMPFS
+ 	.init_fs_context = shmem_init_fs_context,
+ 	.parameters	= shmem_fs_parameters,
+ #else
+ 	.init_fs_context = ramfs_init_fs_context,
+ 	.parameters	= ramfs_fs_parameters,
+ #endif
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb = kill_litter_super,
  };
  
diff --cc drivers/block/rbd.c
index d16fcad4775c,d0437b5fc023..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -846,25 -846,21 +846,41 @@@ enum 
  	Opt_lock_on_read,
  	Opt_exclusive,
  	Opt_notrim,
 +	Opt_err
  };
  
++<<<<<<< HEAD
 +static match_table_t rbd_opts_tokens = {
 +	{Opt_queue_depth, "queue_depth=%d"},
 +	{Opt_alloc_size, "alloc_size=%d"},
 +	{Opt_lock_timeout, "lock_timeout=%d"},
 +	/* int args above */
 +	{Opt_pool_ns, "_pool_ns=%s"},
 +	{Opt_compression_hint, "compression_hint=%s"},
 +	/* string args above */
 +	{Opt_read_only, "read_only"},
 +	{Opt_read_only, "ro"},		/* Alternate spelling */
 +	{Opt_read_write, "read_write"},
 +	{Opt_read_write, "rw"},		/* Alternate spelling */
 +	{Opt_lock_on_read, "lock_on_read"},
 +	{Opt_exclusive, "exclusive"},
 +	{Opt_notrim, "notrim"},
 +	{Opt_err, NULL}
++=======
+ static const struct fs_parameter_spec rbd_parameters[] = {
+ 	fsparam_u32	("alloc_size",			Opt_alloc_size),
+ 	fsparam_flag	("exclusive",			Opt_exclusive),
+ 	fsparam_flag	("lock_on_read",		Opt_lock_on_read),
+ 	fsparam_u32	("lock_timeout",		Opt_lock_timeout),
+ 	fsparam_flag	("notrim",			Opt_notrim),
+ 	fsparam_string	("_pool_ns",			Opt_pool_ns),
+ 	fsparam_u32	("queue_depth",			Opt_queue_depth),
+ 	fsparam_flag	("read_only",			Opt_read_only),
+ 	fsparam_flag	("read_write",			Opt_read_write),
+ 	fsparam_flag	("ro",				Opt_read_only),
+ 	fsparam_flag	("rw",				Opt_read_write),
+ 	{}
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  };
  
  struct rbd_options {
@@@ -6399,6 -6343,118 +6415,121 @@@ static inline char *dup_token(const cha
  	return dup;
  }
  
++<<<<<<< HEAD
++=======
+ static int rbd_parse_param(struct fs_parameter *param,
+ 			    struct rbd_parse_opts_ctx *pctx)
+ {
+ 	struct rbd_options *opt = pctx->opts;
+ 	struct fs_parse_result result;
+ 	struct p_log log = {.prefix = "rbd"};
+ 	int token, ret;
+ 
+ 	ret = ceph_parse_param(param, pctx->copts, NULL);
+ 	if (ret != -ENOPARAM)
+ 		return ret;
+ 
+ 	token = __fs_parse(&log, rbd_parameters, param, &result);
+ 	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
+ 	if (token < 0) {
+ 		if (token == -ENOPARAM)
+ 			return inval_plog(&log, "Unknown parameter '%s'",
+ 					  param->key);
+ 		return token;
+ 	}
+ 
+ 	switch (token) {
+ 	case Opt_queue_depth:
+ 		if (result.uint_32 < 1)
+ 			goto out_of_range;
+ 		opt->queue_depth = result.uint_32;
+ 		break;
+ 	case Opt_alloc_size:
+ 		if (result.uint_32 < SECTOR_SIZE)
+ 			goto out_of_range;
+ 		if (!is_power_of_2(result.uint_32))
+ 			return inval_plog(&log, "alloc_size must be a power of 2");
+ 		opt->alloc_size = result.uint_32;
+ 		break;
+ 	case Opt_lock_timeout:
+ 		/* 0 is "wait forever" (i.e. infinite timeout) */
+ 		if (result.uint_32 > INT_MAX / 1000)
+ 			goto out_of_range;
+ 		opt->lock_timeout = msecs_to_jiffies(result.uint_32 * 1000);
+ 		break;
+ 	case Opt_pool_ns:
+ 		kfree(pctx->spec->pool_ns);
+ 		pctx->spec->pool_ns = param->string;
+ 		param->string = NULL;
+ 		break;
+ 	case Opt_read_only:
+ 		opt->read_only = true;
+ 		break;
+ 	case Opt_read_write:
+ 		opt->read_only = false;
+ 		break;
+ 	case Opt_lock_on_read:
+ 		opt->lock_on_read = true;
+ 		break;
+ 	case Opt_exclusive:
+ 		opt->exclusive = true;
+ 		break;
+ 	case Opt_notrim:
+ 		opt->trim = false;
+ 		break;
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	return 0;
+ 
+ out_of_range:
+ 	return inval_plog(&log, "%s out of range", param->key);
+ }
+ 
+ /*
+  * This duplicates most of generic_parse_monolithic(), untying it from
+  * fs_context and skipping standard superblock and security options.
+  */
+ static int rbd_parse_options(char *options, struct rbd_parse_opts_ctx *pctx)
+ {
+ 	char *key;
+ 	int ret = 0;
+ 
+ 	dout("%s '%s'\n", __func__, options);
+ 	while ((key = strsep(&options, ",")) != NULL) {
+ 		if (*key) {
+ 			struct fs_parameter param = {
+ 				.key	= key,
+ 				.type	= fs_value_is_flag,
+ 			};
+ 			char *value = strchr(key, '=');
+ 			size_t v_len = 0;
+ 
+ 			if (value) {
+ 				if (value == key)
+ 					continue;
+ 				*value++ = 0;
+ 				v_len = strlen(value);
+ 				param.string = kmemdup_nul(value, v_len,
+ 							   GFP_KERNEL);
+ 				if (!param.string)
+ 					return -ENOMEM;
+ 				param.type = fs_value_is_string;
+ 			}
+ 			param.size = v_len;
+ 
+ 			ret = rbd_parse_param(&param, pctx);
+ 			kfree(param.string);
+ 			if (ret)
+ 				break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  /*
   * Parse the options provided for an "rbd add" (i.e., rbd image
   * mapping) request.  These arrive via a write to /sys/bus/rbd/add,
diff --cc drivers/usb/gadget/function/f_fs.c
index ea21ee799739,997e2c914901..000000000000
--- a/drivers/usb/gadget/function/f_fs.c
+++ b/drivers/usb/gadget/function/f_fs.c
@@@ -1486,90 -1477,65 +1486,119 @@@ static int ffs_sb_fill(struct super_blo
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts)
++=======
+ enum {
+ 	Opt_no_disconnect,
+ 	Opt_rmode,
+ 	Opt_fmode,
+ 	Opt_mode,
+ 	Opt_uid,
+ 	Opt_gid,
+ };
+ 
+ static const struct fs_parameter_spec ffs_fs_fs_parameters[] = {
+ 	fsparam_bool	("no_disconnect",	Opt_no_disconnect),
+ 	fsparam_u32	("rmode",		Opt_rmode),
+ 	fsparam_u32	("fmode",		Opt_fmode),
+ 	fsparam_u32	("mode",		Opt_mode),
+ 	fsparam_u32	("uid",			Opt_uid),
+ 	fsparam_u32	("gid",			Opt_gid),
+ 	{}
+ };
+ 
+ static int ffs_fs_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  {
 -	struct ffs_sb_fill_data *data = fc->fs_private;
 -	struct fs_parse_result result;
 -	int opt;
 -
  	ENTER();
  
++<<<<<<< HEAD
 +	if (!opts || !*opts)
 +		return 0;
++=======
+ 	opt = fs_parse(fc, ffs_fs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  
 -	switch (opt) {
 -	case Opt_no_disconnect:
 -		data->no_disconnect = result.boolean;
 -		break;
 -	case Opt_rmode:
 -		data->root_mode  = (result.uint_32 & 0555) | S_IFDIR;
 -		break;
 -	case Opt_fmode:
 -		data->perms.mode = (result.uint_32 & 0666) | S_IFREG;
 -		break;
 -	case Opt_mode:
 -		data->root_mode  = (result.uint_32 & 0555) | S_IFDIR;
 -		data->perms.mode = (result.uint_32 & 0666) | S_IFREG;
 -		break;
 +	for (;;) {
 +		unsigned long value;
 +		char *eq, *comma;
 +
 +		/* Option limit */
 +		comma = strchr(opts, ',');
 +		if (comma)
 +			*comma = 0;
 +
 +		/* Value limit */
 +		eq = strchr(opts, '=');
 +		if (unlikely(!eq)) {
 +			pr_err("'=' missing in %s\n", opts);
 +			return -EINVAL;
 +		}
 +		*eq = 0;
  
 -	case Opt_uid:
 -		data->perms.uid = make_kuid(current_user_ns(), result.uint_32);
 -		if (!uid_valid(data->perms.uid))
 -			goto unmapped_value;
 -		break;
 -	case Opt_gid:
 -		data->perms.gid = make_kgid(current_user_ns(), result.uint_32);
 -		if (!gid_valid(data->perms.gid))
 -			goto unmapped_value;
 -		break;
 +		/* Parse value */
 +		if (kstrtoul(eq + 1, 0, &value)) {
 +			pr_err("%s: invalid value: %s\n", opts, eq + 1);
 +			return -EINVAL;
 +		}
  
 -	default:
 -		return -ENOPARAM;
 +		/* Interpret option */
 +		switch (eq - opts) {
 +		case 13:
 +			if (!memcmp(opts, "no_disconnect", 13))
 +				data->no_disconnect = !!value;
 +			else
 +				goto invalid;
 +			break;
 +		case 5:
 +			if (!memcmp(opts, "rmode", 5))
 +				data->root_mode  = (value & 0555) | S_IFDIR;
 +			else if (!memcmp(opts, "fmode", 5))
 +				data->perms.mode = (value & 0666) | S_IFREG;
 +			else
 +				goto invalid;
 +			break;
 +
 +		case 4:
 +			if (!memcmp(opts, "mode", 4)) {
 +				data->root_mode  = (value & 0555) | S_IFDIR;
 +				data->perms.mode = (value & 0666) | S_IFREG;
 +			} else {
 +				goto invalid;
 +			}
 +			break;
 +
 +		case 3:
 +			if (!memcmp(opts, "uid", 3)) {
 +				data->perms.uid = make_kuid(current_user_ns(), value);
 +				if (!uid_valid(data->perms.uid)) {
 +					pr_err("%s: unmapped value: %lu\n", opts, value);
 +					return -EINVAL;
 +				}
 +			} else if (!memcmp(opts, "gid", 3)) {
 +				data->perms.gid = make_kgid(current_user_ns(), value);
 +				if (!gid_valid(data->perms.gid)) {
 +					pr_err("%s: unmapped value: %lu\n", opts, value);
 +					return -EINVAL;
 +				}
 +			} else {
 +				goto invalid;
 +			}
 +			break;
 +
 +		default:
 +invalid:
 +			pr_err("%s: invalid option\n", opts);
 +			return -EINVAL;
 +		}
 +
 +		/* Next iteration */
 +		if (!comma)
 +			break;
 +		opts = comma + 1;
  	}
  
  	return 0;
@@@ -1644,7 -1635,8 +1673,12 @@@ ffs_fs_kill_sb(struct super_block *sb
  static struct file_system_type ffs_fs_type = {
  	.owner		= THIS_MODULE,
  	.name		= "functionfs",
++<<<<<<< HEAD
 +	.mount		= ffs_fs_mount,
++=======
+ 	.init_fs_context = ffs_fs_init_fs_context,
+ 	.parameters	= ffs_fs_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb	= ffs_fs_kill_sb,
  };
  MODULE_ALIAS_FS("functionfs");
diff --cc fs/afs/super.c
index 44f8cce1c926,dda7a9a66848..000000000000
--- a/fs/afs/super.c
+++ b/fs/afs/super.c
@@@ -38,13 -36,17 +38,26 @@@ static void afs_destroy_inode(struct in
  static int afs_statfs(struct dentry *dentry, struct kstatfs *buf);
  static int afs_show_devname(struct seq_file *m, struct dentry *root);
  static int afs_show_options(struct seq_file *m, struct dentry *root);
++<<<<<<< HEAD
 +
 +struct file_system_type afs_fs_type = {
 +	.owner		= THIS_MODULE,
 +	.name		= "afs",
 +	.mount		= afs_mount,
 +	.kill_sb	= afs_kill_super,
 +	.fs_flags	= 0,
++=======
+ static int afs_init_fs_context(struct fs_context *fc);
+ static const struct fs_parameter_spec afs_fs_parameters[];
+ 
+ struct file_system_type afs_fs_type = {
+ 	.owner			= THIS_MODULE,
+ 	.name			= "afs",
+ 	.init_fs_context	= afs_init_fs_context,
+ 	.parameters		= afs_fs_parameters,
+ 	.kill_sb		= afs_kill_super,
+ 	.fs_flags		= FS_RENAME_DOES_D_MOVE,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  };
  MODULE_ALIAS_FS("afs");
  
@@@ -63,22 -66,27 +76,39 @@@ static const struct super_operations af
  static struct kmem_cache *afs_inode_cachep;
  static atomic_t afs_count_active_inodes;
  
 -enum afs_param {
 -	Opt_autocell,
 -	Opt_dyn,
 -	Opt_flock,
 -	Opt_source,
 +enum {
 +	afs_no_opt,
 +	afs_opt_cell,
 +	afs_opt_dyn,
 +	afs_opt_rwpath,
 +	afs_opt_vol,
 +	afs_opt_autocell,
  };
  
++<<<<<<< HEAD
 +static const match_table_t afs_options_list = {
 +	{ afs_opt_cell,		"cell=%s"	},
 +	{ afs_opt_dyn,		"dyn"		},
 +	{ afs_opt_rwpath,	"rwpath"	},
 +	{ afs_opt_vol,		"vol=%s"	},
 +	{ afs_opt_autocell,	"autocell"	},
 +	{ afs_no_opt,		NULL		},
++=======
+ static const struct constant_table afs_param_flock[] = {
+ 	{"local",	afs_flock_mode_local },
+ 	{"openafs",	afs_flock_mode_openafs },
+ 	{"strict",	afs_flock_mode_strict },
+ 	{"write",	afs_flock_mode_write },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec afs_fs_parameters[] = {
+ 	fsparam_flag  ("autocell",	Opt_autocell),
+ 	fsparam_flag  ("dyn",		Opt_dyn),
+ 	fsparam_enum  ("flock",		Opt_flock, afs_param_flock),
+ 	fsparam_string("source",	Opt_source),
+ 	{}
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  };
  
  /*
@@@ -338,9 -299,90 +368,96 @@@ static int afs_parse_device_name(struc
  	}
  
  	_debug("CELL:%s [%p] VOLUME:%*.*s SUFFIX:%s TYPE:%d%s",
++<<<<<<< HEAD
 +	       params->cell->name, params->cell,
 +	       params->volnamesz, params->volnamesz, params->volname,
 +	       suffix ?: "-", params->type, params->force ? " FORCE" : "");
++=======
+ 	       ctx->cell->name, ctx->cell,
+ 	       ctx->volnamesz, ctx->volnamesz, ctx->volname,
+ 	       suffix ?: "-", ctx->type, ctx->force ? " FORCE" : "");
+ 
+ 	fc->source = param->string;
+ 	param->string = NULL;
+ 	return 0;
+ }
+ 
+ /*
+  * Parse a single mount parameter.
+  */
+ static int afs_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	struct afs_fs_context *ctx = fc->fs_private;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, afs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_source:
+ 		return afs_parse_source(fc, param);
+ 
+ 	case Opt_autocell:
+ 		ctx->autocell = true;
+ 		break;
+ 
+ 	case Opt_dyn:
+ 		ctx->dyn_root = true;
+ 		break;
+ 
+ 	case Opt_flock:
+ 		ctx->flock_mode = result.uint_32;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	_leave(" = 0");
+ 	return 0;
+ }
+ 
+ /*
+  * Validate the options, get the cell key and look up the volume.
+  */
+ static int afs_validate_fc(struct fs_context *fc)
+ {
+ 	struct afs_fs_context *ctx = fc->fs_private;
+ 	struct afs_volume *volume;
+ 	struct key *key;
+ 
+ 	if (!ctx->dyn_root) {
+ 		if (ctx->no_cell) {
+ 			pr_warn("kAFS: Can only specify source 'none' with -o dyn\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (!ctx->cell) {
+ 			pr_warn("kAFS: No cell specified\n");
+ 			return -EDESTADDRREQ;
+ 		}
+ 
+ 		/* We try to do the mount securely. */
+ 		key = afs_request_key(ctx->cell);
+ 		if (IS_ERR(key))
+ 			return PTR_ERR(key);
+ 
+ 		ctx->key = key;
+ 
+ 		if (ctx->volume) {
+ 			afs_put_volume(ctx->cell, ctx->volume);
+ 			ctx->volume = NULL;
+ 		}
+ 
+ 		volume = afs_create_volume(ctx);
+ 		if (IS_ERR(volume))
+ 			return PTR_ERR(volume);
+ 
+ 		ctx->volume = volume;
+ 	}
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  
  	return 0;
  }
diff --cc fs/ceph/super.c
index f940cf50b7f6,d52eb3edb45d..000000000000
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@@ -140,106 -142,135 +140,212 @@@ enum 
  	/* int args above */
  	Opt_snapdirname,
  	Opt_mds_namespace,
 +	Opt_fscache_uniq,
  	Opt_recover_session,
 -	Opt_source,
 +	Opt_last_string,
  	/* string args above */
  	Opt_dirstat,
 +	Opt_nodirstat,
  	Opt_rbytes,
 +	Opt_norbytes,
  	Opt_asyncreaddir,
 +	Opt_noasyncreaddir,
  	Opt_dcache,
 +	Opt_nodcache,
  	Opt_ino32,
 +	Opt_noino32,
  	Opt_fscache,
 +	Opt_nofscache,
  	Opt_poolperm,
 +	Opt_nopoolperm,
  	Opt_require_active_mds,
 +	Opt_norequire_active_mds,
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
  	Opt_acl,
 +#endif
 +	Opt_noacl,
  	Opt_quotadf,
 +	Opt_noquotadf,
  	Opt_copyfrom,
 +	Opt_nocopyfrom,
 +	Opt_wsync,
 +	Opt_nowsync,
  };
  
 -enum ceph_recover_session_mode {
 -	ceph_recover_session_no,
 -	ceph_recover_session_clean
 +static match_table_t fsopt_tokens = {
 +	{Opt_wsize, "wsize=%d"},
 +	{Opt_rsize, "rsize=%d"},
 +	{Opt_rasize, "rasize=%d"},
 +	{Opt_caps_wanted_delay_min, "caps_wanted_delay_min=%d"},
 +	{Opt_caps_wanted_delay_max, "caps_wanted_delay_max=%d"},
 +	{Opt_caps_max, "caps_max=%d"},
 +	{Opt_readdir_max_entries, "readdir_max_entries=%d"},
 +	{Opt_readdir_max_bytes, "readdir_max_bytes=%d"},
 +	{Opt_congestion_kb, "write_congestion_kb=%d"},
 +	/* int args above */
 +	{Opt_snapdirname, "snapdirname=%s"},
 +	{Opt_mds_namespace, "mds_namespace=%s"},
 +	{Opt_recover_session, "recover_session=%s"},
 +	{Opt_fscache_uniq, "fsc=%s"},
 +	/* string args above */
 +	{Opt_dirstat, "dirstat"},
 +	{Opt_nodirstat, "nodirstat"},
 +	{Opt_rbytes, "rbytes"},
 +	{Opt_norbytes, "norbytes"},
 +	{Opt_asyncreaddir, "asyncreaddir"},
 +	{Opt_noasyncreaddir, "noasyncreaddir"},
 +	{Opt_dcache, "dcache"},
 +	{Opt_nodcache, "nodcache"},
 +	{Opt_ino32, "ino32"},
 +	{Opt_noino32, "noino32"},
 +	{Opt_fscache, "fsc"},
 +	{Opt_nofscache, "nofsc"},
 +	{Opt_poolperm, "poolperm"},
 +	{Opt_nopoolperm, "nopoolperm"},
 +	{Opt_require_active_mds, "require_active_mds"},
 +	{Opt_norequire_active_mds, "norequire_active_mds"},
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
 +	{Opt_acl, "acl"},
 +#endif
 +	{Opt_noacl, "noacl"},
 +	{Opt_quotadf, "quotadf"},
 +	{Opt_noquotadf, "noquotadf"},
 +	{Opt_copyfrom, "copyfrom"},
 +	{Opt_nocopyfrom, "nocopyfrom"},
 +	{Opt_wsync, "wsync"},
 +	{Opt_nowsync, "nowsync"},
 +	{-1, NULL}
  };
  
++<<<<<<< HEAD
 +static int parse_fsopt_token(char *c, void *private)
++=======
+ static const struct constant_table ceph_param_recover[] = {
+ 	{ "no",		ceph_recover_session_no },
+ 	{ "clean",	ceph_recover_session_clean },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec ceph_mount_parameters[] = {
+ 	fsparam_flag_no ("acl",				Opt_acl),
+ 	fsparam_flag_no ("asyncreaddir",		Opt_asyncreaddir),
+ 	fsparam_s32	("caps_max",			Opt_caps_max),
+ 	fsparam_u32	("caps_wanted_delay_max",	Opt_caps_wanted_delay_max),
+ 	fsparam_u32	("caps_wanted_delay_min",	Opt_caps_wanted_delay_min),
+ 	fsparam_u32	("write_congestion_kb",		Opt_congestion_kb),
+ 	fsparam_flag_no ("copyfrom",			Opt_copyfrom),
+ 	fsparam_flag_no ("dcache",			Opt_dcache),
+ 	fsparam_flag_no ("dirstat",			Opt_dirstat),
+ 	__fsparam	(fs_param_is_string, "fsc",	Opt_fscache,
+ 			 fs_param_neg_with_no | fs_param_v_optional, NULL),
+ 	fsparam_flag_no ("ino32",			Opt_ino32),
+ 	fsparam_string	("mds_namespace",		Opt_mds_namespace),
+ 	fsparam_flag_no ("poolperm",			Opt_poolperm),
+ 	fsparam_flag_no ("quotadf",			Opt_quotadf),
+ 	fsparam_u32	("rasize",			Opt_rasize),
+ 	fsparam_flag_no ("rbytes",			Opt_rbytes),
+ 	fsparam_u32	("readdir_max_bytes",		Opt_readdir_max_bytes),
+ 	fsparam_u32	("readdir_max_entries",		Opt_readdir_max_entries),
+ 	fsparam_enum	("recover_session",		Opt_recover_session, ceph_param_recover),
+ 	fsparam_flag_no ("require_active_mds",		Opt_require_active_mds),
+ 	fsparam_u32	("rsize",			Opt_rsize),
+ 	fsparam_string	("snapdirname",			Opt_snapdirname),
+ 	fsparam_string	("source",			Opt_source),
+ 	fsparam_u32	("wsize",			Opt_wsize),
+ 	{}
+ };
+ 
+ struct ceph_parse_opts_ctx {
+ 	struct ceph_options		*copts;
+ 	struct ceph_mount_options	*opts;
+ };
+ 
+ /*
+  * Parse the source parameter.  Distinguish the server list from the path.
+  * Internally we do not include the leading '/' in the path.
+  *
+  * The source will look like:
+  *     <server_spec>[,<server_spec>...]:[<path>]
+  * where
+  *     <server_spec> is <ip>[:<port>]
+  *     <path> is optional, but if present must begin with '/'
+  */
+ static int ceph_parse_source(struct fs_parameter *param, struct fs_context *fc)
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  {
 -	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
 -	struct ceph_mount_options *fsopt = pctx->opts;
 -	char *dev_name = param->string, *dev_name_end;
 -	int ret;
 +	struct ceph_mount_options *fsopt = private;
 +	substring_t argstr[MAX_OPT_ARGS];
 +	int token, intval, ret;
  
++<<<<<<< HEAD
 +	token = match_token((char *)c, fsopt_tokens, argstr);
++=======
+ 	dout("%s '%s'\n", __func__, dev_name);
+ 	if (!dev_name || !*dev_name)
+ 		return invalf(fc, "ceph: Empty source");
+ 
+ 	dev_name_end = strchr(dev_name, '/');
+ 	if (dev_name_end) {
+ 		if (strlen(dev_name_end) > 1) {
+ 			kfree(fsopt->server_path);
+ 			fsopt->server_path = kstrdup(dev_name_end, GFP_KERNEL);
+ 			if (!fsopt->server_path)
+ 				return -ENOMEM;
+ 		}
+ 	} else {
+ 		dev_name_end = dev_name + strlen(dev_name);
+ 	}
+ 
+ 	dev_name_end--;		/* back up to ':' separator */
+ 	if (dev_name_end < dev_name || *dev_name_end != ':')
+ 		return invalf(fc, "ceph: No path or : separator in source");
+ 
+ 	dout("device name '%.*s'\n", (int)(dev_name_end - dev_name), dev_name);
+ 	if (fsopt->server_path)
+ 		dout("server path '%s'\n", fsopt->server_path);
+ 
+ 	ret = ceph_parse_mon_ips(param->string, dev_name_end - dev_name,
+ 				 pctx->copts, fc->log.log);
+ 	if (ret)
+ 		return ret;
+ 
+ 	fc->source = param->string;
+ 	param->string = NULL;
+ 	return 0;
+ }
+ 
+ static int ceph_parse_mount_param(struct fs_context *fc,
+ 				  struct fs_parameter *param)
+ {
+ 	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
+ 	struct ceph_mount_options *fsopt = pctx->opts;
+ 	struct fs_parse_result result;
+ 	unsigned int mode;
+ 	int token, ret;
+ 
+ 	ret = ceph_parse_param(param, pctx->copts, fc->log.log);
+ 	if (ret != -ENOPARAM)
+ 		return ret;
+ 
+ 	token = fs_parse(fc, ceph_mount_parameters, param, &result);
+ 	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	if (token < 0)
 -		return token;
 +		return -EINVAL;
 +
 +	if (token < Opt_last_int) {
 +		ret = match_int(&argstr[0], &intval);
 +		if (ret < 0) {
 +			pr_err("bad option arg (not int) at '%s'\n", c);
 +			return ret;
 +		}
 +		dout("got int token %d val %d\n", token, intval);
 +	} else if (token > Opt_last_int && token < Opt_last_string) {
 +		dout("got string token %d val %s\n", token,
 +		     argstr[0].from);
 +	} else {
 +		dout("got token %d\n", token);
 +	}
  
  	switch (token) {
  	case Opt_snapdirname:
diff --cc fs/fuse/inode.c
index 10b75246113a,f22bc344d161..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -452,111 -448,104 +452,199 @@@ enum 
  	OPT_ERR
  };
  
++<<<<<<< HEAD
 +static const match_table_t tokens = {
 +	{OPT_FD,			"fd=%u"},
 +	{OPT_ROOTMODE,			"rootmode=%o"},
 +	{OPT_USER_ID,			"user_id=%u"},
 +	{OPT_GROUP_ID,			"group_id=%u"},
 +	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
 +	{OPT_ALLOW_OTHER,		"allow_other"},
 +	{OPT_MAX_READ,			"max_read=%u"},
 +	{OPT_BLKSIZE,			"blksize=%u"},
 +	{OPT_ERR,			NULL}
 +};
 +
 +static int fuse_match_uint(substring_t *s, unsigned int *res)
 +{
 +	int err = -ENOMEM;
 +	char *buf = match_strdup(s);
 +	if (buf) {
 +		err = kstrtouint(buf, 10, res);
 +		kfree(buf);
++=======
+ static const struct fs_parameter_spec fuse_fs_parameters[] = {
+ 	fsparam_string	("source",		OPT_SOURCE),
+ 	fsparam_u32	("fd",			OPT_FD),
+ 	fsparam_u32oct	("rootmode",		OPT_ROOTMODE),
+ 	fsparam_u32	("user_id",		OPT_USER_ID),
+ 	fsparam_u32	("group_id",		OPT_GROUP_ID),
+ 	fsparam_flag	("default_permissions",	OPT_DEFAULT_PERMISSIONS),
+ 	fsparam_flag	("allow_other",		OPT_ALLOW_OTHER),
+ 	fsparam_u32	("max_read",		OPT_MAX_READ),
+ 	fsparam_u32	("blksize",		OPT_BLKSIZE),
+ 	fsparam_string	("subtype",		OPT_SUBTYPE),
+ 	{}
+ };
+ 
+ static int fuse_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	struct fuse_fs_context *ctx = fc->fs_private;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, fuse_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case OPT_SOURCE:
+ 		if (fc->source)
+ 			return invalf(fc, "fuse: Multiple sources specified");
+ 		fc->source = param->string;
+ 		param->string = NULL;
+ 		break;
+ 
+ 	case OPT_SUBTYPE:
+ 		if (ctx->subtype)
+ 			return invalf(fc, "fuse: Multiple subtypes specified");
+ 		ctx->subtype = param->string;
+ 		param->string = NULL;
+ 		return 0;
+ 
+ 	case OPT_FD:
+ 		ctx->fd = result.uint_32;
+ 		ctx->fd_present = 1;
+ 		break;
+ 
+ 	case OPT_ROOTMODE:
+ 		if (!fuse_valid_type(result.uint_32))
+ 			return invalf(fc, "fuse: Invalid rootmode");
+ 		ctx->rootmode = result.uint_32;
+ 		ctx->rootmode_present = 1;
+ 		break;
+ 
+ 	case OPT_USER_ID:
+ 		ctx->user_id = make_kuid(fc->user_ns, result.uint_32);
+ 		if (!uid_valid(ctx->user_id))
+ 			return invalf(fc, "fuse: Invalid user_id");
+ 		ctx->user_id_present = 1;
+ 		break;
+ 
+ 	case OPT_GROUP_ID:
+ 		ctx->group_id = make_kgid(fc->user_ns, result.uint_32);
+ 		if (!gid_valid(ctx->group_id))
+ 			return invalf(fc, "fuse: Invalid group_id");
+ 		ctx->group_id_present = 1;
+ 		break;
+ 
+ 	case OPT_DEFAULT_PERMISSIONS:
+ 		ctx->default_permissions = 1;
+ 		break;
+ 
+ 	case OPT_ALLOW_OTHER:
+ 		ctx->allow_other = 1;
+ 		break;
+ 
+ 	case OPT_MAX_READ:
+ 		ctx->max_read = result.uint_32;
+ 		break;
+ 
+ 	case OPT_BLKSIZE:
+ 		if (!ctx->is_bdev)
+ 			return invalf(fc, "fuse: blksize only supported for fuseblk");
+ 		ctx->blksize = result.uint_32;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	}
 -
 -	return 0;
 +	return err;
  }
  
 -static void fuse_free_fc(struct fs_context *fc)
 +static int parse_fuse_opt(char *opt, struct fuse_fs_context *d, int is_bdev,
 +			  struct user_namespace *user_ns)
  {
 -	struct fuse_fs_context *ctx = fc->fs_private;
 -
 -	if (ctx) {
 -		kfree(ctx->subtype);
 -		kfree(ctx);
 +	char *p;
 +	memset(d, 0, sizeof(struct fuse_fs_context));
 +	d->max_read = ~0;
 +	d->blksize = FUSE_DEFAULT_BLKSIZE;
 +
 +	while ((p = strsep(&opt, ",")) != NULL) {
 +		int token;
 +		int value;
 +		unsigned uv;
 +		substring_t args[MAX_OPT_ARGS];
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case OPT_FD:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->fd = value;
 +			d->fd_present = 1;
 +			break;
 +
 +		case OPT_ROOTMODE:
 +			if (match_octal(&args[0], &value))
 +				return 0;
 +			if (!fuse_valid_type(value))
 +				return 0;
 +			d->rootmode = value;
 +			d->rootmode_present = 1;
 +			break;
 +
 +		case OPT_USER_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->user_id = make_kuid(user_ns, uv);
 +			if (!uid_valid(d->user_id))
 +				return 0;
 +			d->user_id_present = 1;
 +			break;
 +
 +		case OPT_GROUP_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->group_id = make_kgid(user_ns, uv);
 +			if (!gid_valid(d->group_id))
 +				return 0;
 +			d->group_id_present = 1;
 +			break;
 +
 +		case OPT_DEFAULT_PERMISSIONS:
 +			d->default_permissions = 1;
 +			break;
 +
 +		case OPT_ALLOW_OTHER:
 +			d->allow_other = 1;
 +			break;
 +
 +		case OPT_MAX_READ:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->max_read = value;
 +			break;
 +
 +		case OPT_BLKSIZE:
 +			if (!is_bdev || match_int(&args[0], &value))
 +				return 0;
 +			d->blksize = value;
 +			break;
 +
 +		default:
 +			return 0;
 +		}
  	}
 +
 +	if (!d->fd_present || !d->rootmode_present ||
 +	    !d->user_id_present || !d->group_id_present)
 +		return 0;
 +
 +	return 1;
  }
  
  static int fuse_show_options(struct seq_file *m, struct dentry *root)
@@@ -1315,7 -1341,8 +1403,12 @@@ static struct file_system_type fuse_fs_
  	.owner		= THIS_MODULE,
  	.name		= "fuse",
  	.fs_flags	= FS_HAS_SUBTYPE | FS_USERNS_MOUNT,
++<<<<<<< HEAD
 +	.mount		= fuse_mount,
++=======
+ 	.init_fs_context = fuse_init_fs_context,
+ 	.parameters	= fuse_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb	= fuse_kill_sb_anon,
  };
  MODULE_ALIAS_FS("fuse");
@@@ -1337,7 -1357,8 +1430,12 @@@ static void fuse_kill_sb_blk(struct sup
  static struct file_system_type fuseblk_fs_type = {
  	.owner		= THIS_MODULE,
  	.name		= "fuseblk",
++<<<<<<< HEAD
 +	.mount		= fuse_mount_blk,
++=======
+ 	.init_fs_context = fuse_init_fs_context,
+ 	.parameters	= fuse_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb	= fuse_kill_sb_blk,
  	.fs_flags	= FS_REQUIRES_DEV | FS_HAS_SUBTYPE,
  };
diff --cc fs/gfs2/ops_fstype.c
index ddff87690c58,32623d28612b..000000000000
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@@ -1323,7 -1300,13 +1323,17 @@@ enum opt_errors 
  	Opt_errors_panic    = GFS2_ERRORS_PANIC,
  };
  
++<<<<<<< HEAD
 +static const struct fs_parameter_spec gfs2_param_specs[] = {
++=======
+ static const struct constant_table gfs2_param_errors[] = {
+ 	{"withdraw",   Opt_errors_withdraw },
+ 	{"panic",      Opt_errors_panic },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec gfs2_fs_parameters[] = {
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	fsparam_string ("lockproto",          Opt_lockproto),
  	fsparam_string ("locktable",          Opt_locktable),
  	fsparam_string ("hostdata",           Opt_hostdata),
@@@ -1352,23 -1336,6 +1362,26 @@@
  	{}
  };
  
 +static const struct fs_parameter_enum gfs2_param_enums[] = {
 +	{ Opt_quota,    "off",        Opt_quota_off },
 +	{ Opt_quota,    "account",    Opt_quota_account },
 +	{ Opt_quota,    "on",         Opt_quota_on },
 +	{ Opt_data,     "writeback",  Opt_data_writeback },
 +	{ Opt_data,     "ordered",    Opt_data_ordered },
 +	{ Opt_errors,   "withdraw",   Opt_errors_withdraw },
 +	{ Opt_errors,   "panic",      Opt_errors_panic },
 +	{}
 +};
 +
++<<<<<<< HEAD
 +static const struct fs_parameter_description gfs2_fs_parameters = {
 +	.name = "gfs2",
 +	.specs = gfs2_param_specs,
 +	.enums = gfs2_param_enums,
 +};
 +
++=======
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  /* Parse a single mount parameter */
  static int gfs2_parse_param(struct fs_context *fc, struct fs_parameter *param)
  {
diff --cc fs/hugetlbfs/inode.c
index 7aa2a56cc419,84d445e8b5bc..000000000000
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@@ -84,11 -84,6 +84,14 @@@ static const struct fs_parameter_spec h
  	{}
  };
  
++<<<<<<< HEAD
 +static const struct fs_parameter_description hugetlb_fs_parameters = {
 +	.name		= "hugetlbfs",
 +	.specs		= hugetlb_param_specs,
 +};
 +
++=======
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  #ifdef CONFIG_NUMA
  static inline void hugetlb_set_vma_policy(struct vm_area_struct *vma,
  					struct inode *inode, pgoff_t index)
diff --cc fs/jffs2/super.c
index 87bdf0f4cba1,05d7878dfad1..000000000000
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@@ -166,73 -165,51 +166,111 @@@ static const struct export_operations j
  enum {
  	Opt_override_compr,
  	Opt_rp_size,
 +	Opt_err,
 +};
 +
 +static const match_table_t tokens = {
 +	{Opt_override_compr, "compr=%s"},
 +	{Opt_rp_size, "rp_size=%u"},
 +	{Opt_err, NULL},
  };
  
 -static const struct constant_table jffs2_param_compr[] = {
 -	{"none",	JFFS2_COMPR_MODE_NONE },
 +static int jffs2_parse_options(struct jffs2_sb_info *c, char *data)
 +{
 +	substring_t args[MAX_OPT_ARGS];
 +	char *p, *name;
 +	unsigned int opt;
 +
 +	if (!data)
 +		return 0;
 +
 +	while ((p = strsep(&data, ","))) {
 +		int token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_override_compr:
 +			name = match_strdup(&args[0]);
 +
 +			if (!name)
 +				return -ENOMEM;
 +			if (!strcmp(name, "none"))
 +				c->mount_opts.compr = JFFS2_COMPR_MODE_NONE;
  #ifdef CONFIG_JFFS2_LZO
 -	{"lzo",		JFFS2_COMPR_MODE_FORCELZO },
 +			else if (!strcmp(name, "lzo"))
 +				c->mount_opts.compr = JFFS2_COMPR_MODE_FORCELZO;
  #endif
  #ifdef CONFIG_JFFS2_ZLIB
 -	{"zlib",	JFFS2_COMPR_MODE_FORCEZLIB },
 +			else if (!strcmp(name, "zlib"))
 +				c->mount_opts.compr =
 +						JFFS2_COMPR_MODE_FORCEZLIB;
  #endif
++<<<<<<< HEAD
 +			else {
 +				pr_err("Error: unknown compressor \"%s\"\n",
 +				       name);
 +				kfree(name);
 +				return -EINVAL;
 +			}
 +			kfree(name);
 +			c->mount_opts.override_compr = true;
 +			break;
 +		case Opt_rp_size:
 +			if (match_int(&args[0], &opt))
 +				return -EINVAL;
 +			opt *= 1024;
 +			if (opt > c->mtd->size) {
 +				pr_warn("Too large reserve pool specified, max "
 +					"is %llu KB\n", c->mtd->size / 1024);
 +				return -EINVAL;
 +			}
 +			c->mount_opts.rp_size = opt;
 +			break;
 +		default:
 +			pr_err("Error: unrecognized mount option '%s' or missing value\n",
 +			       p);
 +			return -EINVAL;
 +		}
++=======
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec jffs2_fs_parameters[] = {
+ 	fsparam_enum	("compr",	Opt_override_compr, jffs2_param_compr),
+ 	fsparam_u32	("rp_size",	Opt_rp_size),
+ 	{}
+ };
+ 
+ static int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	struct jffs2_sb_info *c = fc->s_fs_info;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, jffs2_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_override_compr:
+ 		c->mount_opts.compr = result.uint_32;
+ 		c->mount_opts.override_compr = true;
+ 		break;
+ 	case Opt_rp_size:
+ 		if (result.uint_32 > UINT_MAX / 1024)
+ 			return invalf(fc, "jffs2: rp_size unrepresentable");
+ 		opt = result.uint_32 * 1024;
+ 		if (opt > c->mtd->size)
+ 			return invalf(fc, "jffs2: Too large reserve pool specified, max is %llu KB",
+ 				      c->mtd->size / 1024);
+ 		c->mount_opts.rp_size = opt;
+ 		break;
+ 	default:
+ 		return -EINVAL;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	}
  
  	return 0;
@@@ -351,7 -332,8 +389,12 @@@ static void jffs2_kill_sb(struct super_
  static struct file_system_type jffs2_fs_type = {
  	.owner =	THIS_MODULE,
  	.name =		"jffs2",
++<<<<<<< HEAD
 +	.mount =	jffs2_mount,
++=======
+ 	.init_fs_context = jffs2_init_fs_context,
+ 	.parameters =	jffs2_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb =	jffs2_kill_sb,
  };
  MODULE_ALIAS_FS("jffs2");
diff --cc fs/proc/root.c
index f4b1a9d2eca6,6a5825e12bc9..000000000000
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@@ -26,60 -27,119 +26,76 @@@
  
  #include "internal.h"
  
 -struct proc_fs_context {
 -	struct pid_namespace	*pid_ns;
 -	unsigned int		mask;
 -	int			hidepid;
 -	int			gid;
 +enum {
 +	Opt_gid, Opt_hidepid, Opt_err,
  };
  
 -enum proc_param {
 -	Opt_gid,
 -	Opt_hidepid,
 +static const match_table_t tokens = {
 +	{Opt_hidepid, "hidepid=%u"},
 +	{Opt_gid, "gid=%u"},
 +	{Opt_err, NULL},
  };
  
++<<<<<<< HEAD
 +int proc_parse_options(char *options, struct pid_namespace *pid)
++=======
+ static const struct fs_parameter_spec proc_fs_parameters[] = {
+ 	fsparam_u32("gid",	Opt_gid),
+ 	fsparam_u32("hidepid",	Opt_hidepid),
+ 	{}
+ };
+ 
+ static int proc_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  {
 -	struct proc_fs_context *ctx = fc->fs_private;
 -	struct fs_parse_result result;
 -	int opt;
 -
 +	char *p;
 +	substring_t args[MAX_OPT_ARGS];
 +	int option;
 +
++<<<<<<< HEAD
 +	if (!options)
 +		return 1;
++=======
+ 	opt = fs_parse(fc, proc_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
 -
 -	switch (opt) {
 -	case Opt_gid:
 -		ctx->gid = result.uint_32;
 -		break;
 -
 -	case Opt_hidepid:
 -		ctx->hidepid = result.uint_32;
 -		if (ctx->hidepid < HIDEPID_OFF ||
 -		    ctx->hidepid > HIDEPID_INVISIBLE)
 -			return invalf(fc, "proc: hidepid value must be between 0 and 2.\n");
 -		break;
 -
 -	default:
 -		return -EINVAL;
 -	}
 -
 -	ctx->mask |= 1 << opt;
 -	return 0;
 -}
 -
 -static void proc_apply_options(struct super_block *s,
 -			       struct fs_context *fc,
 -			       struct pid_namespace *pid_ns,
 -			       struct user_namespace *user_ns)
 -{
 -	struct proc_fs_context *ctx = fc->fs_private;
 -
 -	if (ctx->mask & (1 << Opt_gid))
 -		pid_ns->pid_gid = make_kgid(user_ns, ctx->gid);
 -	if (ctx->mask & (1 << Opt_hidepid))
 -		pid_ns->hide_pid = ctx->hidepid;
 -}
 -
 -static int proc_fill_super(struct super_block *s, struct fs_context *fc)
 -{
 -	struct pid_namespace *pid_ns = get_pid_ns(s->s_fs_info);
 -	struct inode *root_inode;
 -	int ret;
 -
 -	proc_apply_options(s, fc, pid_ns, current_user_ns());
 -
 -	/* User space would break if executables or devices appear on proc */
 -	s->s_iflags |= SB_I_USERNS_VISIBLE | SB_I_NOEXEC | SB_I_NODEV;
 -	s->s_flags |= SB_NODIRATIME | SB_NOSUID | SB_NOEXEC;
 -	s->s_blocksize = 1024;
 -	s->s_blocksize_bits = 10;
 -	s->s_magic = PROC_SUPER_MAGIC;
 -	s->s_op = &proc_sops;
 -	s->s_time_gran = 1;
 -
 -	/*
 -	 * procfs isn't actually a stacking filesystem; however, there is
 -	 * too much magic going on inside it to permit stacking things on
 -	 * top of it
 -	 */
 -	s->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;
 -	
 -	/* procfs dentries and inodes don't require IO to create */
 -	s->s_shrink.seeks = 0;
 -
 -	pde_get(&proc_root);
 -	root_inode = proc_get_inode(s, &proc_root);
 -	if (!root_inode) {
 -		pr_err("proc_fill_super: get root inode failed\n");
 -		return -ENOMEM;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int token;
 +		if (!*p)
 +			continue;
 +
 +		args[0].to = args[0].from = NULL;
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_gid:
 +			if (match_int(&args[0], &option))
 +				return 0;
 +			pid->pid_gid = make_kgid(current_user_ns(), option);
 +			break;
 +		case Opt_hidepid:
 +			if (match_int(&args[0], &option))
 +				return 0;
 +			if (option < HIDEPID_OFF ||
 +			    option > HIDEPID_INVISIBLE) {
 +				pr_err("proc: hidepid value must be between 0 and 2.\n");
 +				return 0;
 +			}
 +			pid->hide_pid = option;
 +			break;
 +		default:
 +			pr_err("proc: unrecognized mount option \"%s\" "
 +			       "or missing value\n", p);
 +			return 0;
 +		}
  	}
  
 -	s->s_root = d_make_root(root_inode);
 -	if (!s->s_root) {
 -		pr_err("proc_fill_super: allocate dentry failed\n");
 -		return -ENOMEM;
 -	}
 -
 -	ret = proc_setup_self(s);
 -	if (ret) {
 -		return ret;
 -	}
 -	return proc_setup_thread_self(s);
 +	return 1;
  }
  
 -static int proc_reconfigure(struct fs_context *fc)
 +int proc_remount(struct super_block *sb, int *flags, char *data)
  {
 -	struct super_block *sb = fc->root->d_sb;
  	struct pid_namespace *pid = sb->s_fs_info;
  
  	sync_filesystem(sb);
@@@ -115,10 -200,11 +131,18 @@@ static void proc_kill_sb(struct super_b
  }
  
  static struct file_system_type proc_fs_type = {
++<<<<<<< HEAD
 +	.name		= "proc",
 +	.mount		= proc_mount,
 +	.kill_sb	= proc_kill_sb,
 +	.fs_flags	= FS_USERNS_MOUNT,
++=======
+ 	.name			= "proc",
+ 	.init_fs_context	= proc_init_fs_context,
+ 	.parameters		= proc_fs_parameters,
+ 	.kill_sb		= proc_kill_sb,
+ 	.fs_flags		= FS_USERNS_MOUNT | FS_DISALLOW_NOTIFY_PERM,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  };
  
  void __init proc_root_init(void)
diff --cc fs/ramfs/inode.c
index b85d1e77e934,ee179a81b3da..000000000000
--- a/fs/ramfs/inode.c
+++ b/fs/ramfs/inode.c
@@@ -175,36 -177,23 +175,50 @@@ static const struct super_operations ra
  	.show_options	= ramfs_show_options,
  };
  
 -enum ramfs_param {
 +enum {
  	Opt_mode,
 +	Opt_err
  };
  
++<<<<<<< HEAD
 +static const match_table_t tokens = {
 +	{Opt_mode, "mode=%o"},
 +	{Opt_err, NULL}
 +};
 +
 +static int ramfs_parse_options(char *data, struct ramfs_mount_opts *opts)
++=======
+ const struct fs_parameter_spec ramfs_fs_parameters[] = {
+ 	fsparam_u32oct("mode",	Opt_mode),
+ 	{}
+ };
+ 
+ static int ramfs_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  {
 -	struct fs_parse_result result;
 -	struct ramfs_fs_info *fsi = fc->s_fs_info;
 -	int opt;
 -
 +	substring_t args[MAX_OPT_ARGS];
 +	int option;
 +	int token;
 +	char *p;
 +
++<<<<<<< HEAD
 +	opts->mode = RAMFS_DEFAULT_MODE;
 +
 +	while ((p = strsep(&data, ",")) != NULL) {
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_mode:
 +			if (match_octal(&args[0], &option))
 +				return -EINVAL;
 +			opts->mode = option & S_IALLUGO;
 +			break;
++=======
+ 	opt = fs_parse(fc, ramfs_fs_parameters, param, &result);
+ 	if (opt < 0) {
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  		/*
  		 * We might like to report bad mount options here;
  		 * but traditionally ramfs has ignored all mount options,
@@@ -261,7 -272,8 +275,12 @@@ static void ramfs_kill_sb(struct super_
  
  static struct file_system_type ramfs_fs_type = {
  	.name		= "ramfs",
++<<<<<<< HEAD
 +	.mount		= ramfs_mount,
++=======
+ 	.init_fs_context = ramfs_init_fs_context,
+ 	.parameters	= ramfs_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb	= ramfs_kill_sb,
  	.fs_flags	= FS_USERNS_MOUNT,
  };
diff --cc fs/xfs/xfs_super.c
index e6df26a81bbf,b03d82fcf011..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -58,343 -59,53 +58,390 @@@ enum 
  	Opt_filestreams, Opt_quota, Opt_noquota, Opt_usrquota, Opt_grpquota,
  	Opt_prjquota, Opt_uquota, Opt_gquota, Opt_pquota,
  	Opt_uqnoenforce, Opt_gqnoenforce, Opt_pqnoenforce, Opt_qnoenforce,
 -	Opt_discard, Opt_nodiscard, Opt_dax,
 +	Opt_discard, Opt_nodiscard, Opt_dax, Opt_err,
  };
  
++<<<<<<< HEAD
 +static const match_table_t tokens = {
 +	{Opt_logbufs,	"logbufs=%u"},	/* number of XFS log buffers */
 +	{Opt_logbsize,	"logbsize=%s"},	/* size of XFS log buffers */
 +	{Opt_logdev,	"logdev=%s"},	/* log device */
 +	{Opt_rtdev,	"rtdev=%s"},	/* realtime I/O device */
 +	{Opt_biosize,	"biosize=%u"},	/* log2 of preferred buffered io size */
 +	{Opt_wsync,	"wsync"},	/* safe-mode nfs compatible mount */
 +	{Opt_noalign,	"noalign"},	/* turn off stripe alignment */
 +	{Opt_swalloc,	"swalloc"},	/* turn on stripe width allocation */
 +	{Opt_sunit,	"sunit=%u"},	/* data volume stripe unit */
 +	{Opt_swidth,	"swidth=%u"},	/* data volume stripe width */
 +	{Opt_nouuid,	"nouuid"},	/* ignore filesystem UUID */
 +	{Opt_grpid,	"grpid"},	/* group-ID from parent directory */
 +	{Opt_nogrpid,	"nogrpid"},	/* group-ID from current process */
 +	{Opt_bsdgroups,	"bsdgroups"},	/* group-ID from parent directory */
 +	{Opt_sysvgroups,"sysvgroups"},	/* group-ID from current process */
 +	{Opt_allocsize,	"allocsize=%s"},/* preferred allocation size */
 +	{Opt_norecovery,"norecovery"},	/* don't run XFS recovery */
 +	{Opt_inode64,	"inode64"},	/* inodes can be allocated anywhere */
 +	{Opt_inode32,   "inode32"},	/* inode allocation limited to
 +					 * XFS_MAXINUMBER_32 */
 +	{Opt_ikeep,	"ikeep"},	/* do not free empty inode clusters */
 +	{Opt_noikeep,	"noikeep"},	/* free empty inode clusters */
 +	{Opt_largeio,	"largeio"},	/* report large I/O sizes in stat() */
 +	{Opt_nolargeio,	"nolargeio"},	/* do not report large I/O sizes
 +					 * in stat(). */
 +	{Opt_attr2,	"attr2"},	/* do use attr2 attribute format */
 +	{Opt_noattr2,	"noattr2"},	/* do not use attr2 attribute format */
 +	{Opt_filestreams,"filestreams"},/* use filestreams allocator */
 +	{Opt_quota,	"quota"},	/* disk quotas (user) */
 +	{Opt_noquota,	"noquota"},	/* no quotas */
 +	{Opt_usrquota,	"usrquota"},	/* user quota enabled */
 +	{Opt_grpquota,	"grpquota"},	/* group quota enabled */
 +	{Opt_prjquota,	"prjquota"},	/* project quota enabled */
 +	{Opt_uquota,	"uquota"},	/* user quota (IRIX variant) */
 +	{Opt_gquota,	"gquota"},	/* group quota (IRIX variant) */
 +	{Opt_pquota,	"pquota"},	/* project quota (IRIX variant) */
 +	{Opt_uqnoenforce,"uqnoenforce"},/* user quota limit enforcement */
 +	{Opt_gqnoenforce,"gqnoenforce"},/* group quota limit enforcement */
 +	{Opt_pqnoenforce,"pqnoenforce"},/* project quota limit enforcement */
 +	{Opt_qnoenforce, "qnoenforce"},	/* same as uqnoenforce */
 +	{Opt_discard,	"discard"},	/* Discard unused blocks */
 +	{Opt_nodiscard,	"nodiscard"},	/* Do not discard unused blocks */
 +	{Opt_dax,	"dax"},		/* Enable direct access to bdev pages */
 +	{Opt_err,	NULL},
 +};
 +
 +
 +STATIC int
 +suffix_kstrtoint(const substring_t *s, unsigned int base, int *res)
 +{
 +	int	last, shift_left_factor = 0, _res;
 +	char	*value;
 +	int	ret = 0;
 +
 +	value = match_strdup(s);
 +	if (!value)
 +		return -ENOMEM;
 +
 +	last = strlen(value) - 1;
 +	if (value[last] == 'K' || value[last] == 'k') {
 +		shift_left_factor = 10;
 +		value[last] = '\0';
 +	}
 +	if (value[last] == 'M' || value[last] == 'm') {
 +		shift_left_factor = 20;
 +		value[last] = '\0';
 +	}
 +	if (value[last] == 'G' || value[last] == 'g') {
 +		shift_left_factor = 30;
 +		value[last] = '\0';
 +	}
 +
 +	if (kstrtoint(value, base, &_res))
 +		ret = -EINVAL;
 +	kfree(value);
 +	*res = _res << shift_left_factor;
 +	return ret;
 +}
 +
 +/*
 + * This function fills in xfs_mount_t fields based on mount args.
 + * Note: the superblock has _not_ yet been read in.
 + *
 + * Note that this function leaks the various device name allocations on
 + * failure.  The caller takes care of them.
 + *
 + * *sb is const because this is also used to test options on the remount
 + * path, and we don't want this to have any side effects at remount time.
 + * Today this function does not change *sb, but just to future-proof...
 + */
 +STATIC int
 +xfs_parseargs(
 +	struct xfs_mount	*mp,
 +	char			*options)
 +{
 +	const struct super_block *sb = mp->m_super;
 +	char			*p;
 +	substring_t		args[MAX_OPT_ARGS];
 +	int			iosize = 0;
 +	uint8_t			iosizelog = 0;
 +
 +	/*
 +	 * Copy binary VFS mount flags we are interested in.
 +	 */
 +	if (sb_rdonly(sb))
 +		mp->m_flags |= XFS_MOUNT_RDONLY;
 +	if (sb->s_flags & SB_DIRSYNC)
 +		mp->m_flags |= XFS_MOUNT_DIRSYNC;
 +	if (sb->s_flags & SB_SYNCHRONOUS)
 +		mp->m_flags |= XFS_MOUNT_WSYNC;
 +
 +	/*
 +	 * These can be overridden by the mount option parsing.
 +	 */
 +	mp->m_logbufs = -1;
 +	mp->m_logbsize = -1;
 +
 +	if (!options)
 +		return 0;
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int		token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_logbufs:
 +			if (match_int(args, &mp->m_logbufs))
 +				return -EINVAL;
 +			break;
 +		case Opt_logbsize:
 +			if (suffix_kstrtoint(args, 10, &mp->m_logbsize))
 +				return -EINVAL;
 +			break;
 +		case Opt_logdev:
 +			kfree(mp->m_logname);
 +			mp->m_logname = match_strdup(args);
 +			if (!mp->m_logname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_rtdev:
 +			kfree(mp->m_rtname);
 +			mp->m_rtname = match_strdup(args);
 +			if (!mp->m_rtname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_allocsize:
 +		case Opt_biosize:
 +			if (suffix_kstrtoint(args, 10, &iosize))
 +				return -EINVAL;
 +			iosizelog = ffs(iosize) - 1;
 +			break;
 +		case Opt_grpid:
 +		case Opt_bsdgroups:
 +			mp->m_flags |= XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_nogrpid:
 +		case Opt_sysvgroups:
 +			mp->m_flags &= ~XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_wsync:
 +			mp->m_flags |= XFS_MOUNT_WSYNC;
 +			break;
 +		case Opt_norecovery:
 +			mp->m_flags |= XFS_MOUNT_NORECOVERY;
 +			break;
 +		case Opt_noalign:
 +			mp->m_flags |= XFS_MOUNT_NOALIGN;
 +			break;
 +		case Opt_swalloc:
 +			mp->m_flags |= XFS_MOUNT_SWALLOC;
 +			break;
 +		case Opt_sunit:
 +			if (match_int(args, &mp->m_dalign))
 +				return -EINVAL;
 +			break;
 +		case Opt_swidth:
 +			if (match_int(args, &mp->m_swidth))
 +				return -EINVAL;
 +			break;
 +		case Opt_inode32:
 +			mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_inode64:
 +			mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_nouuid:
 +			mp->m_flags |= XFS_MOUNT_NOUUID;
 +			break;
 +		case Opt_ikeep:
 +			mp->m_flags |= XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_noikeep:
 +			mp->m_flags &= ~XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_largeio:
 +			mp->m_flags |= XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_nolargeio:
 +			mp->m_flags &= ~XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_attr2:
 +			mp->m_flags |= XFS_MOUNT_ATTR2;
 +			break;
 +		case Opt_noattr2:
 +			mp->m_flags &= ~XFS_MOUNT_ATTR2;
 +			mp->m_flags |= XFS_MOUNT_NOATTR2;
 +			break;
 +		case Opt_filestreams:
 +			mp->m_flags |= XFS_MOUNT_FILESTREAMS;
 +			break;
 +		case Opt_noquota:
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
 +			break;
 +		case Opt_quota:
 +		case Opt_uquota:
 +		case Opt_usrquota:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
 +					 XFS_UQUOTA_ENFD);
 +			break;
 +		case Opt_qnoenforce:
 +		case Opt_uqnoenforce:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_UQUOTA_ENFD;
 +			break;
 +		case Opt_pquota:
 +		case Opt_prjquota:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
 +					 XFS_PQUOTA_ENFD);
 +			break;
 +		case Opt_pqnoenforce:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_PQUOTA_ENFD;
 +			break;
 +		case Opt_gquota:
 +		case Opt_grpquota:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
 +					 XFS_GQUOTA_ENFD);
 +			break;
 +		case Opt_gqnoenforce:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_GQUOTA_ENFD;
 +			break;
 +		case Opt_discard:
 +			mp->m_flags |= XFS_MOUNT_DISCARD;
 +			break;
 +		case Opt_nodiscard:
 +			mp->m_flags &= ~XFS_MOUNT_DISCARD;
 +			break;
 +#ifdef CONFIG_FS_DAX
 +		case Opt_dax:
 +			mp->m_flags |= XFS_MOUNT_DAX;
 +			break;
 +#endif
 +		default:
 +			xfs_warn(mp, "unknown mount option [%s].", p);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	/*
 +	 * no recovery flag requires a read-only mount
 +	 */
 +	if ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&
 +	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
 +		xfs_warn(mp, "no-recovery mounts must be read-only.");
 +		return -EINVAL;
 +	}
 +
 +	if ((mp->m_flags & XFS_MOUNT_NOALIGN) &&
 +	    (mp->m_dalign || mp->m_swidth)) {
 +		xfs_warn(mp,
 +	"sunit and swidth options incompatible with the noalign option");
 +		return -EINVAL;
 +	}
 +
 +	if (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {
 +		xfs_warn(mp, "quota support not available in this kernel.");
 +		return -EINVAL;
 +	}
 +
 +	if ((mp->m_dalign && !mp->m_swidth) ||
 +	    (!mp->m_dalign && mp->m_swidth)) {
 +		xfs_warn(mp, "sunit and swidth must be specified together");
 +		return -EINVAL;
 +	}
 +
 +	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
 +		xfs_warn(mp,
 +	"stripe width (%d) must be a multiple of the stripe unit (%d)",
 +			mp->m_swidth, mp->m_dalign);
 +		return -EINVAL;
 +	}
 +
 +	if (mp->m_logbufs != -1 &&
 +	    mp->m_logbufs != 0 &&
 +	    (mp->m_logbufs < XLOG_MIN_ICLOGS ||
 +	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
 +		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
 +			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
 +		return -EINVAL;
 +	}
 +	if (mp->m_logbsize != -1 &&
 +	    mp->m_logbsize !=  0 &&
 +	    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||
 +	     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||
 +	     !is_power_of_2(mp->m_logbsize))) {
 +		xfs_warn(mp,
 +			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
 +			mp->m_logbsize);
 +		return -EINVAL;
 +	}
 +
 +	if (iosizelog) {
 +		if (iosizelog > XFS_MAX_IO_LOG ||
 +		    iosizelog < XFS_MIN_IO_LOG) {
 +			xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
 +				iosizelog, XFS_MIN_IO_LOG,
 +				XFS_MAX_IO_LOG);
 +			return -EINVAL;
 +		}
 +
 +		mp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;
 +		mp->m_allocsize_log = iosizelog;
 +	}
 +
 +	return 0;
 +}
 +
++=======
+ static const struct fs_parameter_spec xfs_fs_parameters[] = {
+ 	fsparam_u32("logbufs",		Opt_logbufs),
+ 	fsparam_string("logbsize",	Opt_logbsize),
+ 	fsparam_string("logdev",	Opt_logdev),
+ 	fsparam_string("rtdev",		Opt_rtdev),
+ 	fsparam_flag("wsync",		Opt_wsync),
+ 	fsparam_flag("noalign",		Opt_noalign),
+ 	fsparam_flag("swalloc",		Opt_swalloc),
+ 	fsparam_u32("sunit",		Opt_sunit),
+ 	fsparam_u32("swidth",		Opt_swidth),
+ 	fsparam_flag("nouuid",		Opt_nouuid),
+ 	fsparam_flag("grpid",		Opt_grpid),
+ 	fsparam_flag("nogrpid",		Opt_nogrpid),
+ 	fsparam_flag("bsdgroups",	Opt_bsdgroups),
+ 	fsparam_flag("sysvgroups",	Opt_sysvgroups),
+ 	fsparam_string("allocsize",	Opt_allocsize),
+ 	fsparam_flag("norecovery",	Opt_norecovery),
+ 	fsparam_flag("inode64",		Opt_inode64),
+ 	fsparam_flag("inode32",		Opt_inode32),
+ 	fsparam_flag("ikeep",		Opt_ikeep),
+ 	fsparam_flag("noikeep",		Opt_noikeep),
+ 	fsparam_flag("largeio",		Opt_largeio),
+ 	fsparam_flag("nolargeio",	Opt_nolargeio),
+ 	fsparam_flag("attr2",		Opt_attr2),
+ 	fsparam_flag("noattr2",		Opt_noattr2),
+ 	fsparam_flag("filestreams",	Opt_filestreams),
+ 	fsparam_flag("quota",		Opt_quota),
+ 	fsparam_flag("noquota",		Opt_noquota),
+ 	fsparam_flag("usrquota",	Opt_usrquota),
+ 	fsparam_flag("grpquota",	Opt_grpquota),
+ 	fsparam_flag("prjquota",	Opt_prjquota),
+ 	fsparam_flag("uquota",		Opt_uquota),
+ 	fsparam_flag("gquota",		Opt_gquota),
+ 	fsparam_flag("pquota",		Opt_pquota),
+ 	fsparam_flag("uqnoenforce",	Opt_uqnoenforce),
+ 	fsparam_flag("gqnoenforce",	Opt_gqnoenforce),
+ 	fsparam_flag("pqnoenforce",	Opt_pqnoenforce),
+ 	fsparam_flag("qnoenforce",	Opt_qnoenforce),
+ 	fsparam_flag("discard",		Opt_discard),
+ 	fsparam_flag("nodiscard",	Opt_nodiscard),
+ 	fsparam_flag("dax",		Opt_dax),
+ 	{}
+ };
+ 
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  struct proc_xfs_info {
  	uint64_t	flag;
  	char		*str;
@@@ -1506,57 -1033,335 +1553,302 @@@ xfs_destroy_percpu_counters
  	percpu_counter_destroy(&mp->m_delalloc_blks);
  }
  
 -static void
 -xfs_fs_put_super(
 -	struct super_block	*sb)
 +static struct xfs_mount *
 +xfs_mount_alloc(void)
  {
 -	struct xfs_mount	*mp = XFS_M(sb);
 +	struct xfs_mount	*mp;
  
 -	/* if ->fill_super failed, we have no mount to tear down */
 -	if (!sb->s_fs_info)
 -		return;
 +	mp = kmem_alloc(sizeof(struct xfs_mount), KM_ZERO);
 +	if (!mp)
 +		return NULL;
  
++<<<<<<< HEAD
 +	spin_lock_init(&mp->m_sb_lock);
 +	spin_lock_init(&mp->m_agirotor_lock);
 +	INIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);
 +	spin_lock_init(&mp->m_perag_lock);
 +	mutex_init(&mp->m_growlock);
 +	atomic_set(&mp->m_active_trans, 0);
 +	INIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);
 +	INIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);
 +	INIT_DELAYED_WORK(&mp->m_cowblocks_work, xfs_cowblocks_worker);
 +	mp->m_kobj.kobject.kset = xfs_kset;
++=======
+ 	xfs_notice(mp, "Unmounting Filesystem");
+ 	xfs_filestream_unmount(mp);
+ 	xfs_unmountfs(mp);
+ 
+ 	xfs_freesb(mp);
+ 	free_percpu(mp->m_stats.xs_stats);
+ 	xfs_destroy_percpu_counters(mp);
+ 	xfs_destroy_mount_workqueues(mp);
+ 	xfs_close_devices(mp);
+ 
+ 	sb->s_fs_info = NULL;
+ 	xfs_mount_free(mp);
+ }
+ 
+ static long
+ xfs_fs_nr_cached_objects(
+ 	struct super_block	*sb,
+ 	struct shrink_control	*sc)
+ {
+ 	/* Paranoia: catch incorrect calls during mount setup or teardown */
+ 	if (WARN_ON_ONCE(!sb->s_fs_info))
+ 		return 0;
+ 	return xfs_reclaim_inodes_count(XFS_M(sb));
+ }
+ 
+ static long
+ xfs_fs_free_cached_objects(
+ 	struct super_block	*sb,
+ 	struct shrink_control	*sc)
+ {
+ 	return xfs_reclaim_inodes_nr(XFS_M(sb), sc->nr_to_scan);
+ }
+ 
+ static const struct super_operations xfs_super_operations = {
+ 	.alloc_inode		= xfs_fs_alloc_inode,
+ 	.destroy_inode		= xfs_fs_destroy_inode,
+ 	.dirty_inode		= xfs_fs_dirty_inode,
+ 	.drop_inode		= xfs_fs_drop_inode,
+ 	.put_super		= xfs_fs_put_super,
+ 	.sync_fs		= xfs_fs_sync_fs,
+ 	.freeze_fs		= xfs_fs_freeze,
+ 	.unfreeze_fs		= xfs_fs_unfreeze,
+ 	.statfs			= xfs_fs_statfs,
+ 	.show_options		= xfs_fs_show_options,
+ 	.nr_cached_objects	= xfs_fs_nr_cached_objects,
+ 	.free_cached_objects	= xfs_fs_free_cached_objects,
+ };
+ 
+ static int
+ suffix_kstrtoint(
+ 	const char	*s,
+ 	unsigned int	base,
+ 	int		*res)
+ {
+ 	int		last, shift_left_factor = 0, _res;
+ 	char		*value;
+ 	int		ret = 0;
+ 
+ 	value = kstrdup(s, GFP_KERNEL);
+ 	if (!value)
+ 		return -ENOMEM;
+ 
+ 	last = strlen(value) - 1;
+ 	if (value[last] == 'K' || value[last] == 'k') {
+ 		shift_left_factor = 10;
+ 		value[last] = '\0';
+ 	}
+ 	if (value[last] == 'M' || value[last] == 'm') {
+ 		shift_left_factor = 20;
+ 		value[last] = '\0';
+ 	}
+ 	if (value[last] == 'G' || value[last] == 'g') {
+ 		shift_left_factor = 30;
+ 		value[last] = '\0';
+ 	}
+ 
+ 	if (kstrtoint(value, base, &_res))
+ 		ret = -EINVAL;
+ 	kfree(value);
+ 	*res = _res << shift_left_factor;
+ 	return ret;
+ }
+ 
+ /*
+  * Set mount state from a mount option.
+  *
+  * NOTE: mp->m_super is NULL here!
+  */
+ static int
+ xfs_fc_parse_param(
+ 	struct fs_context	*fc,
+ 	struct fs_parameter	*param)
+ {
+ 	struct xfs_mount	*mp = fc->s_fs_info;
+ 	struct fs_parse_result	result;
+ 	int			size = 0;
+ 	int			opt;
+ 
+ 	opt = fs_parse(fc, xfs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_logbufs:
+ 		mp->m_logbufs = result.uint_32;
+ 		return 0;
+ 	case Opt_logbsize:
+ 		if (suffix_kstrtoint(param->string, 10, &mp->m_logbsize))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_logdev:
+ 		kfree(mp->m_logname);
+ 		mp->m_logname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_logname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_rtdev:
+ 		kfree(mp->m_rtname);
+ 		mp->m_rtname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_rtname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_allocsize:
+ 		if (suffix_kstrtoint(param->string, 10, &size))
+ 			return -EINVAL;
+ 		mp->m_allocsize_log = ffs(size) - 1;
+ 		mp->m_flags |= XFS_MOUNT_ALLOCSIZE;
+ 		return 0;
+ 	case Opt_grpid:
+ 	case Opt_bsdgroups:
+ 		mp->m_flags |= XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_nogrpid:
+ 	case Opt_sysvgroups:
+ 		mp->m_flags &= ~XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_wsync:
+ 		mp->m_flags |= XFS_MOUNT_WSYNC;
+ 		return 0;
+ 	case Opt_norecovery:
+ 		mp->m_flags |= XFS_MOUNT_NORECOVERY;
+ 		return 0;
+ 	case Opt_noalign:
+ 		mp->m_flags |= XFS_MOUNT_NOALIGN;
+ 		return 0;
+ 	case Opt_swalloc:
+ 		mp->m_flags |= XFS_MOUNT_SWALLOC;
+ 		return 0;
+ 	case Opt_sunit:
+ 		mp->m_dalign = result.uint_32;
+ 		return 0;
+ 	case Opt_swidth:
+ 		mp->m_swidth = result.uint_32;
+ 		return 0;
+ 	case Opt_inode32:
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_inode64:
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_nouuid:
+ 		mp->m_flags |= XFS_MOUNT_NOUUID;
+ 		return 0;
+ 	case Opt_ikeep:
+ 		mp->m_flags |= XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_noikeep:
+ 		mp->m_flags &= ~XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_largeio:
+ 		mp->m_flags |= XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_nolargeio:
+ 		mp->m_flags &= ~XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_attr2:
+ 		mp->m_flags |= XFS_MOUNT_ATTR2;
+ 		return 0;
+ 	case Opt_noattr2:
+ 		mp->m_flags &= ~XFS_MOUNT_ATTR2;
+ 		mp->m_flags |= XFS_MOUNT_NOATTR2;
+ 		return 0;
+ 	case Opt_filestreams:
+ 		mp->m_flags |= XFS_MOUNT_FILESTREAMS;
+ 		return 0;
+ 	case Opt_noquota:
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
+ 		return 0;
+ 	case Opt_quota:
+ 	case Opt_uquota:
+ 	case Opt_usrquota:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
+ 				 XFS_UQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_qnoenforce:
+ 	case Opt_uqnoenforce:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_UQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_pquota:
+ 	case Opt_prjquota:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
+ 				 XFS_PQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_pqnoenforce:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_PQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_gquota:
+ 	case Opt_grpquota:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
+ 				 XFS_GQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_gqnoenforce:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_GQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_discard:
+ 		mp->m_flags |= XFS_MOUNT_DISCARD;
+ 		return 0;
+ 	case Opt_nodiscard:
+ 		mp->m_flags &= ~XFS_MOUNT_DISCARD;
+ 		return 0;
+ #ifdef CONFIG_FS_DAX
+ 	case Opt_dax:
+ 		mp->m_flags |= XFS_MOUNT_DAX;
+ 		return 0;
+ #endif
+ 	default:
+ 		xfs_warn(mp, "unknown mount option [%s].", param->key);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_fc_validate_params(
+ 	struct xfs_mount	*mp)
+ {
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	/*
 -	 * no recovery flag requires a read-only mount
 +	 * We don't create the finobt per-ag space reservation until after log
 +	 * recovery, so we must set this to true so that an ifree transaction
 +	 * started during log recovery will not depend on space reservations
 +	 * for finobt expansion.
  	 */
 -	if ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&
 -	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
 -		xfs_warn(mp, "no-recovery mounts must be read-only.");
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_flags & XFS_MOUNT_NOALIGN) &&
 -	    (mp->m_dalign || mp->m_swidth)) {
 -		xfs_warn(mp,
 -	"sunit and swidth options incompatible with the noalign option");
 -		return -EINVAL;
 -	}
 -
 -	if (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {
 -		xfs_warn(mp, "quota support not available in this kernel.");
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_dalign && !mp->m_swidth) ||
 -	    (!mp->m_dalign && mp->m_swidth)) {
 -		xfs_warn(mp, "sunit and swidth must be specified together");
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
 -		xfs_warn(mp,
 -	"stripe width (%d) must be a multiple of the stripe unit (%d)",
 -			mp->m_swidth, mp->m_dalign);
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_logbufs != -1 &&
 -	    mp->m_logbufs != 0 &&
 -	    (mp->m_logbufs < XLOG_MIN_ICLOGS ||
 -	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
 -		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
 -			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_logbsize != -1 &&
 -	    mp->m_logbsize !=  0 &&
 -	    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||
 -	     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||
 -	     !is_power_of_2(mp->m_logbsize))) {
 -		xfs_warn(mp,
 -			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
 -			mp->m_logbsize);
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_flags & XFS_MOUNT_ALLOCSIZE) &&
 -	    (mp->m_allocsize_log > XFS_MAX_IO_LOG ||
 -	     mp->m_allocsize_log < XFS_MIN_IO_LOG)) {
 -		xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
 -			mp->m_allocsize_log, XFS_MIN_IO_LOG, XFS_MAX_IO_LOG);
 -		return -EINVAL;
 -	}
 -
 -	return 0;
 +	mp->m_finobt_nores = true;
 +	return mp;
  }
  
 -static int
 -xfs_fc_fill_super(
 +
 +STATIC int
 +xfs_fs_fill_super(
  	struct super_block	*sb,
 -	struct fs_context	*fc)
 +	void			*data,
 +	int			silent)
  {
 -	struct xfs_mount	*mp = sb->s_fs_info;
  	struct inode		*root;
 -	int			flags = 0, error;
 +	struct xfs_mount	*mp = NULL;
 +	int			flags = 0, error = -ENOMEM;
  
 +	/*
 +	 * allocate mp and do all low-level struct initializations before we
 +	 * attach it to the super
 +	 */
 +	mp = xfs_mount_alloc();
 +	if (!mp)
 +		goto out;
  	mp->m_super = sb;
 +	sb->s_fs_info = mp;
  
 -	error = xfs_fc_validate_params(mp);
 +	error = xfs_parseargs(mp, (char *)data);
  	if (error)
  		goto out_free_names;
  
@@@ -1831,7 -1732,58 +2123,12 @@@ static const struct super_operations xf
  static struct file_system_type xfs_fs_type = {
  	.owner			= THIS_MODULE,
  	.name			= "xfs",
++<<<<<<< HEAD
 +	.mount			= xfs_fs_mount,
++=======
+ 	.init_fs_context	= xfs_init_fs_context,
+ 	.parameters		= xfs_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb		= kill_block_super,
  	.fs_flags		= FS_REQUIRES_DEV,
  };
diff --cc include/linux/fs.h
index 8c7d4770a372,5ace552a2a23..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -65,6 -64,10 +65,13 @@@ struct workqueue_struct
  struct iov_iter;
  struct fscrypt_info;
  struct fscrypt_operations;
++<<<<<<< HEAD
++=======
+ struct fsverity_info;
+ struct fsverity_operations;
+ struct fs_context;
+ struct fs_parameter_spec;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  
  extern void __init inode_init(void);
  extern void __init inode_init_early(void);
@@@ -2217,7 -2221,10 +2224,12 @@@ struct file_system_type 
  #define FS_BINARY_MOUNTDATA	2
  #define FS_HAS_SUBTYPE		4
  #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 -#define FS_DISALLOW_NOTIFY_PERM	16	/* Disable fanotify permission events */
  #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
++<<<<<<< HEAD
++=======
+ 	int (*init_fs_context)(struct fs_context *);
+ 	const struct fs_parameter_spec *parameters;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	struct dentry *(*mount) (struct file_system_type *, int,
  		       const char *, void *);
  	void (*kill_sb) (struct super_block *);
diff --cc include/linux/ramfs.h
index e4d7d141545e,917528d102c4..000000000000
--- a/include/linux/ramfs.h
+++ b/include/linux/ramfs.h
@@@ -2,10 -2,11 +2,12 @@@
  #ifndef _LINUX_RAMFS_H
  #define _LINUX_RAMFS_H
  
+ #include <linux/fs_parser.h> // bleh...
+ 
  struct inode *ramfs_get_inode(struct super_block *sb, const struct inode *dir,
  	 umode_t mode, dev_t dev);
 -extern int ramfs_init_fs_context(struct fs_context *fc);
 +extern struct dentry *ramfs_mount(struct file_system_type *fs_type,
 +	 int flags, const char *dev_name, void *data);
  
  #ifdef CONFIG_MMU
  static inline int
@@@ -17,6 -18,7 +19,10 @@@ ramfs_nommu_expand_for_mapping(struct i
  extern int ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize);
  #endif
  
++<<<<<<< HEAD
++=======
+ extern const struct fs_parameter_spec ramfs_fs_parameters[];
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  extern const struct file_operations ramfs_file_operations;
  extern const struct vm_operations_struct generic_file_vm_ops;
  
diff --cc include/linux/shmem_fs.h
index c4a8a0f1d6db,d56fefef8905..000000000000
--- a/include/linux/shmem_fs.h
+++ b/include/linux/shmem_fs.h
@@@ -48,9 -50,9 +49,13 @@@ static inline struct shmem_inode_info *
  /*
   * Functions in mm/shmem.c called directly from elsewhere:
   */
++<<<<<<< HEAD
++=======
+ extern const struct fs_parameter_spec shmem_fs_parameters[];
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  extern int shmem_init(void);
 -extern int shmem_init_fs_context(struct fs_context *fc);
 +extern struct dentry *shmem_mount(struct file_system_type *fs_type,
 +	int flags, const char *dev_name, void *data);
  extern struct file *shmem_file_setup(const char *name,
  					loff_t size, unsigned long flags);
  extern struct file *shmem_kernel_file_setup(const char *name, loff_t size,
diff --cc kernel/bpf/inode.c
index 66e55d381265,f4b2ef72e265..000000000000
--- a/kernel/bpf/inode.c
+++ b/kernel/bpf/inode.c
@@@ -611,37 -585,25 +611,48 @@@ static const struct super_operations bp
  
  enum {
  	OPT_MODE,
 +	OPT_ERR,
  };
  
++<<<<<<< HEAD
 +static const match_table_t bpf_mount_tokens = {
 +	{ OPT_MODE, "mode=%o" },
 +	{ OPT_ERR, NULL },
++=======
+ static const struct fs_parameter_spec bpf_fs_parameters[] = {
+ 	fsparam_u32oct	("mode",			OPT_MODE),
+ 	{}
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  };
  
  struct bpf_mount_opts {
  	umode_t mode;
  };
  
 -static int bpf_parse_param(struct fs_context *fc, struct fs_parameter *param)
 +static int bpf_parse_options(char *data, struct bpf_mount_opts *opts)
  {
 -	struct bpf_mount_opts *opts = fc->fs_private;
 -	struct fs_parse_result result;
 -	int opt;
 +	substring_t args[MAX_OPT_ARGS];
 +	int option, token;
 +	char *ptr;
  
++<<<<<<< HEAD
 +	opts->mode = S_IRWXUGO;
 +
 +	while ((ptr = strsep(&data, ",")) != NULL) {
 +		if (!*ptr)
 +			continue;
 +
 +		token = match_token(ptr, bpf_mount_tokens, args);
 +		switch (token) {
 +		case OPT_MODE:
 +			if (match_octal(&args[0], &option))
 +				return -EINVAL;
 +			opts->mode = option & S_IALLUGO;
 +			break;
++=======
+ 	opt = fs_parse(fc, bpf_fs_parameters, param, &result);
+ 	if (opt < 0)
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  		/* We might like to report bad mount options here, but
  		 * traditionally we've ignored all mount options, so we'd
  		 * better continue to ignore non-existing options for bpf.
@@@ -686,7 -677,8 +697,12 @@@ static struct dentry *bpf_mount(struct 
  static struct file_system_type bpf_fs_type = {
  	.owner		= THIS_MODULE,
  	.name		= "bpf",
++<<<<<<< HEAD
 +	.mount		= bpf_mount,
++=======
+ 	.init_fs_context = bpf_init_fs_context,
+ 	.parameters	= bpf_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb	= kill_litter_super,
  };
  
diff --cc kernel/cgroup/cgroup-internal.h
index ce1c1553c696,bfbeabc17a9d..000000000000
--- a/kernel/cgroup/cgroup-internal.h
+++ b/kernel/cgroup/cgroup-internal.h
@@@ -7,6 -7,7 +7,10 @@@
  #include <linux/workqueue.h>
  #include <linux/list.h>
  #include <linux/refcount.h>
++<<<<<<< HEAD
++=======
+ #include <linux/fs_parser.h>
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  
  #define TRACE_CGROUP_PATH_LEN 1024
  extern spinlock_t trace_cgroup_path_lock;
@@@ -251,6 -265,7 +255,10 @@@ extern const struct proc_ns_operations 
   */
  extern struct cftype cgroup1_base_files[];
  extern struct kernfs_syscall_ops cgroup1_kf_syscall_ops;
++<<<<<<< HEAD
++=======
+ extern const struct fs_parameter_spec cgroup1_fs_parameters[];
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  
  int proc_cgroupstats_show(struct seq_file *m, void *v);
  bool cgroup1_ssid_disabled(int ssid);
diff --cc kernel/cgroup/cgroup-v1.c
index dd94e2a4c22e,408545620dad..000000000000
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@@ -873,13 -874,115 +873,122 @@@ static int cgroup1_show_options(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int parse_cgroupfs_options(char *data, struct cgroup_sb_opts *opts)
 +{
 +	char *token, *o = data;
 +	bool all_ss = false, one_ss = false;
++=======
+ enum cgroup1_param {
+ 	Opt_all,
+ 	Opt_clone_children,
+ 	Opt_cpuset_v2_mode,
+ 	Opt_name,
+ 	Opt_none,
+ 	Opt_noprefix,
+ 	Opt_release_agent,
+ 	Opt_xattr,
+ };
+ 
+ const struct fs_parameter_spec cgroup1_fs_parameters[] = {
+ 	fsparam_flag  ("all",		Opt_all),
+ 	fsparam_flag  ("clone_children", Opt_clone_children),
+ 	fsparam_flag  ("cpuset_v2_mode", Opt_cpuset_v2_mode),
+ 	fsparam_string("name",		Opt_name),
+ 	fsparam_flag  ("none",		Opt_none),
+ 	fsparam_flag  ("noprefix",	Opt_noprefix),
+ 	fsparam_string("release_agent",	Opt_release_agent),
+ 	fsparam_flag  ("xattr",		Opt_xattr),
+ 	{}
+ };
+ 
+ int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 	struct cgroup_subsys *ss;
+ 	struct fs_parse_result result;
+ 	int opt, i;
+ 
+ 	opt = fs_parse(fc, cgroup1_fs_parameters, param, &result);
+ 	if (opt == -ENOPARAM) {
+ 		if (strcmp(param->key, "source") == 0) {
+ 			fc->source = param->string;
+ 			param->string = NULL;
+ 			return 0;
+ 		}
+ 		for_each_subsys(ss, i) {
+ 			if (strcmp(param->key, ss->legacy_name))
+ 				continue;
+ 			ctx->subsys_mask |= (1 << i);
+ 			return 0;
+ 		}
+ 		return invalf(fc, "cgroup1: Unknown subsys name '%s'", param->key);
+ 	}
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_none:
+ 		/* Explicitly have no subsystems */
+ 		ctx->none = true;
+ 		break;
+ 	case Opt_all:
+ 		ctx->all_ss = true;
+ 		break;
+ 	case Opt_noprefix:
+ 		ctx->flags |= CGRP_ROOT_NOPREFIX;
+ 		break;
+ 	case Opt_clone_children:
+ 		ctx->cpuset_clone_children = true;
+ 		break;
+ 	case Opt_cpuset_v2_mode:
+ 		ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;
+ 		break;
+ 	case Opt_xattr:
+ 		ctx->flags |= CGRP_ROOT_XATTR;
+ 		break;
+ 	case Opt_release_agent:
+ 		/* Specifying two release agents is forbidden */
+ 		if (ctx->release_agent)
+ 			return invalf(fc, "cgroup1: release_agent respecified");
+ 		ctx->release_agent = param->string;
+ 		param->string = NULL;
+ 		break;
+ 	case Opt_name:
+ 		/* blocked by boot param? */
+ 		if (cgroup_no_v1_named)
+ 			return -ENOENT;
+ 		/* Can't specify an empty name */
+ 		if (!param->size)
+ 			return invalf(fc, "cgroup1: Empty name");
+ 		if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)
+ 			return invalf(fc, "cgroup1: Name too long");
+ 		/* Must match [\w.-]+ */
+ 		for (i = 0; i < param->size; i++) {
+ 			char c = param->string[i];
+ 			if (isalnum(c))
+ 				continue;
+ 			if ((c == '.') || (c == '-') || (c == '_'))
+ 				continue;
+ 			return invalf(fc, "cgroup1: Invalid name");
+ 		}
+ 		/* Specifying two names is forbidden */
+ 		if (ctx->name)
+ 			return invalf(fc, "cgroup1: name respecified");
+ 		ctx->name = param->string;
+ 		param->string = NULL;
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static int check_cgroupfs_options(struct fs_context *fc)
+ {
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	u16 mask = U16_MAX;
 -	u16 enabled = 0;
  	struct cgroup_subsys *ss;
 +	int nr_opts = 0;
  	int i;
  
  #ifdef CONFIG_CPUSETS
diff --cc kernel/cgroup/cgroup.c
index cfd0dd76492e,a70a37e85d11..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -1814,26 -1810,37 +1814,48 @@@ int cgroup_show_path(struct seq_file *s
  	return len;
  }
  
++<<<<<<< HEAD
 +static int parse_cgroup_root_flags(char *data, unsigned int *root_flags)
++=======
+ enum cgroup2_param {
+ 	Opt_nsdelegate,
+ 	Opt_memory_localevents,
+ 	nr__cgroup2_params
+ };
+ 
+ static const struct fs_parameter_spec cgroup2_fs_parameters[] = {
+ 	fsparam_flag("nsdelegate",		Opt_nsdelegate),
+ 	fsparam_flag("memory_localevents",	Opt_memory_localevents),
+ 	{}
+ };
+ 
+ static int cgroup2_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  {
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 -	struct fs_parse_result result;
 -	int opt;
 +	char *token;
  
++<<<<<<< HEAD
 +	*root_flags = 0;
++=======
+ 	opt = fs_parse(fc, cgroup2_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  
 -	switch (opt) {
 -	case Opt_nsdelegate:
 -		ctx->flags |= CGRP_ROOT_NS_DELEGATE;
 -		return 0;
 -	case Opt_memory_localevents:
 -		ctx->flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;
 +	if (!data || *data == '\0')
  		return 0;
 +
 +	while ((token = strsep(&data, ",")) != NULL) {
 +		if (!strcmp(token, "nsdelegate")) {
 +			*root_flags |= CGRP_ROOT_NS_DELEGATE;
 +			continue;
 +		}
 +
 +		pr_err("cgroup2: unknown option \"%s\"\n", token);
 +		return -EINVAL;
  	}
 -	return -EINVAL;
 +
 +	return 0;
  }
  
  static void apply_cgroup_root_flags(unsigned int root_flags)
@@@ -2111,19 -2149,65 +2133,35 @@@ static void cgroup_kill_sb(struct super
  }
  
  struct file_system_type cgroup_fs_type = {
++<<<<<<< HEAD
 +	.name = "cgroup",
 +	.mount = cgroup_mount,
 +	.kill_sb = cgroup_kill_sb,
 +	.fs_flags = FS_USERNS_MOUNT,
 +};
 +
 +static struct file_system_type cgroup2_fs_type = {
 +	.name = "cgroup2",
 +	.mount = cgroup_mount,
 +	.kill_sb = cgroup_kill_sb,
 +	.fs_flags = FS_USERNS_MOUNT,
++=======
+ 	.name			= "cgroup",
+ 	.init_fs_context	= cgroup_init_fs_context,
+ 	.parameters		= cgroup1_fs_parameters,
+ 	.kill_sb		= cgroup_kill_sb,
+ 	.fs_flags		= FS_USERNS_MOUNT,
+ };
+ 
+ static struct file_system_type cgroup2_fs_type = {
+ 	.name			= "cgroup2",
+ 	.init_fs_context	= cgroup_init_fs_context,
+ 	.parameters		= cgroup2_fs_parameters,
+ 	.kill_sb		= cgroup_kill_sb,
+ 	.fs_flags		= FS_USERNS_MOUNT,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  };
  
 -#ifdef CONFIG_CPUSETS
 -static const struct fs_context_operations cpuset_fs_context_ops = {
 -	.get_tree	= cgroup1_get_tree,
 -	.free		= cgroup_fs_context_free,
 -};
 -
 -/*
 - * This is ugly, but preserves the userspace API for existing cpuset
 - * users. If someone tries to mount the "cpuset" filesystem, we
 - * silently switch it to mount "cgroup" instead
 - */
 -static int cpuset_init_fs_context(struct fs_context *fc)
 -{
 -	char *agent = kstrdup("/sbin/cpuset_release_agent", GFP_USER);
 -	struct cgroup_fs_context *ctx;
 -	int err;
 -
 -	err = cgroup_init_fs_context(fc);
 -	if (err) {
 -		kfree(agent);
 -		return err;
 -	}
 -
 -	fc->ops = &cpuset_fs_context_ops;
 -
 -	ctx = cgroup_fc2context(fc);
 -	ctx->subsys_mask = 1 << cpuset_cgrp_id;
 -	ctx->flags |= CGRP_ROOT_NOPREFIX;
 -	ctx->release_agent = agent;
 -
 -	get_filesystem(&cgroup_fs_type);
 -	put_filesystem(fc->fs_type);
 -	fc->fs_type = &cgroup_fs_type;
 -
 -	return 0;
 -}
 -
 -static struct file_system_type cpuset_fs_type = {
 -	.name			= "cpuset",
 -	.init_fs_context	= cpuset_init_fs_context,
 -	.fs_flags		= FS_USERNS_MOUNT,
 -};
 -#endif
 -
  int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,
  			  struct cgroup_namespace *ns)
  {
diff --cc mm/shmem.c
index 1b4f8fc6c563,efbbf2bc68fb..000000000000
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@@ -3335,11 -3370,119 +3335,127 @@@ static const struct export_operations s
  	.fh_to_dentry	= shmem_fh_to_dentry,
  };
  
++<<<<<<< HEAD
 +static int shmem_parse_options(char *options, struct shmem_options *ctx)
 +{
 +	char *this_char, *value, *rest;
 +	uid_t uid;
 +	gid_t gid;
++=======
+ enum shmem_param {
+ 	Opt_gid,
+ 	Opt_huge,
+ 	Opt_mode,
+ 	Opt_mpol,
+ 	Opt_nr_blocks,
+ 	Opt_nr_inodes,
+ 	Opt_size,
+ 	Opt_uid,
+ };
+ 
+ static const struct constant_table shmem_param_enums_huge[] = {
+ 	{"never",	SHMEM_HUGE_NEVER },
+ 	{"always",	SHMEM_HUGE_ALWAYS },
+ 	{"within_size",	SHMEM_HUGE_WITHIN_SIZE },
+ 	{"advise",	SHMEM_HUGE_ADVISE },
+ 	{"deny",	SHMEM_HUGE_DENY },
+ 	{"force",	SHMEM_HUGE_FORCE },
+ 	{}
+ };
+ 
+ const struct fs_parameter_spec shmem_fs_parameters[] = {
+ 	fsparam_u32   ("gid",		Opt_gid),
+ 	fsparam_enum  ("huge",		Opt_huge,  shmem_param_enums_huge),
+ 	fsparam_u32oct("mode",		Opt_mode),
+ 	fsparam_string("mpol",		Opt_mpol),
+ 	fsparam_string("nr_blocks",	Opt_nr_blocks),
+ 	fsparam_string("nr_inodes",	Opt_nr_inodes),
+ 	fsparam_string("size",		Opt_size),
+ 	fsparam_u32   ("uid",		Opt_uid),
+ 	{}
+ };
+ 
+ static int shmem_parse_one(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct shmem_options *ctx = fc->fs_private;
+ 	struct fs_parse_result result;
+ 	unsigned long long size;
+ 	char *rest;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, shmem_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_size:
+ 		size = memparse(param->string, &rest);
+ 		if (*rest == '%') {
+ 			size <<= PAGE_SHIFT;
+ 			size *= totalram_pages();
+ 			do_div(size, 100);
+ 			rest++;
+ 		}
+ 		if (*rest)
+ 			goto bad_value;
+ 		ctx->blocks = DIV_ROUND_UP(size, PAGE_SIZE);
+ 		ctx->seen |= SHMEM_SEEN_BLOCKS;
+ 		break;
+ 	case Opt_nr_blocks:
+ 		ctx->blocks = memparse(param->string, &rest);
+ 		if (*rest)
+ 			goto bad_value;
+ 		ctx->seen |= SHMEM_SEEN_BLOCKS;
+ 		break;
+ 	case Opt_nr_inodes:
+ 		ctx->inodes = memparse(param->string, &rest);
+ 		if (*rest)
+ 			goto bad_value;
+ 		ctx->seen |= SHMEM_SEEN_INODES;
+ 		break;
+ 	case Opt_mode:
+ 		ctx->mode = result.uint_32 & 07777;
+ 		break;
+ 	case Opt_uid:
+ 		ctx->uid = make_kuid(current_user_ns(), result.uint_32);
+ 		if (!uid_valid(ctx->uid))
+ 			goto bad_value;
+ 		break;
+ 	case Opt_gid:
+ 		ctx->gid = make_kgid(current_user_ns(), result.uint_32);
+ 		if (!gid_valid(ctx->gid))
+ 			goto bad_value;
+ 		break;
+ 	case Opt_huge:
+ 		ctx->huge = result.uint_32;
+ 		if (ctx->huge != SHMEM_HUGE_NEVER &&
+ 		    !(IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&
+ 		      has_transparent_hugepage()))
+ 			goto unsupported_parameter;
+ 		ctx->seen |= SHMEM_SEEN_HUGE;
+ 		break;
+ 	case Opt_mpol:
+ 		if (IS_ENABLED(CONFIG_NUMA)) {
+ 			mpol_put(ctx->mpol);
+ 			ctx->mpol = NULL;
+ 			if (mpol_parse_str(param->string, &ctx->mpol))
+ 				goto bad_value;
+ 			break;
+ 		}
+ 		goto unsupported_parameter;
+ 	}
+ 	return 0;
+ 
+ unsupported_parameter:
+ 	return invalf(fc, "tmpfs: Unsupported parameter '%s'", param->key);
+ bad_value:
+ 	return invalf(fc, "tmpfs: Bad value for '%s'", param->key);
+ }
+ 
+ static int shmem_parse_options(struct fs_context *fc, void *data)
+ {
+ 	char *options = data;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  
  	if (options) {
  		int err = security_sb_eat_lsm_opts(options, &fc->security);
@@@ -3770,7 -3883,10 +3886,14 @@@ struct dentry *shmem_mount(struct file_
  static struct file_system_type shmem_fs_type = {
  	.owner		= THIS_MODULE,
  	.name		= "tmpfs",
++<<<<<<< HEAD
 +	.mount		= shmem_mount,
++=======
+ 	.init_fs_context = shmem_init_fs_context,
+ #ifdef CONFIG_TMPFS
+ 	.parameters	= shmem_fs_parameters,
+ #endif
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb	= kill_litter_super,
  	.fs_flags	= FS_USERNS_MOUNT,
  };
@@@ -3915,7 -4030,8 +4038,12 @@@ bool shmem_huge_enabled(struct vm_area_
  
  static struct file_system_type shmem_fs_type = {
  	.name		= "tmpfs",
++<<<<<<< HEAD
 +	.mount		= ramfs_mount,
++=======
+ 	.init_fs_context = ramfs_init_fs_context,
+ 	.parameters	= ramfs_fs_parameters,
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	.kill_sb	= kill_litter_super,
  	.fs_flags	= FS_USERNS_MOUNT,
  };
diff --cc net/ceph/ceph_common.c
index 47dc7ae211b5,a0e97f6c1072..000000000000
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@@ -281,35 -269,51 +281,83 @@@ enum 
  	Opt_abort_on_full,
  };
  
++<<<<<<< HEAD
 +static match_table_t opt_tokens = {
 +	{Opt_osdtimeout, "osdtimeout=%d"},
 +	{Opt_osdkeepalivetimeout, "osdkeepalive=%d"},
 +	{Opt_mount_timeout, "mount_timeout=%d"},
 +	{Opt_osd_idle_ttl, "osd_idle_ttl=%d"},
 +	{Opt_osd_request_timeout, "osd_request_timeout=%d"},
 +	/* int args above */
 +	{Opt_fsid, "fsid=%s"},
 +	{Opt_name, "name=%s"},
 +	{Opt_secret, "secret=%s"},
 +	{Opt_key, "key=%s"},
 +	{Opt_ip, "ip=%s"},
 +	{Opt_crush_location, "crush_location=%s"},
 +	{Opt_read_from_replica, "read_from_replica=%s"},
 +	/* string args above */
 +	{Opt_share, "share"},
 +	{Opt_noshare, "noshare"},
 +	{Opt_crc, "crc"},
 +	{Opt_nocrc, "nocrc"},
 +	{Opt_cephx_require_signatures, "cephx_require_signatures"},
 +	{Opt_nocephx_require_signatures, "nocephx_require_signatures"},
 +	{Opt_cephx_sign_messages, "cephx_sign_messages"},
 +	{Opt_nocephx_sign_messages, "nocephx_sign_messages"},
 +	{Opt_tcp_nodelay, "tcp_nodelay"},
 +	{Opt_notcp_nodelay, "notcp_nodelay"},
 +	{Opt_abort_on_full, "abort_on_full"},
 +	{-1, NULL}
 +};
 +
++=======
+ static const struct fs_parameter_spec ceph_parameters[] = {
+ 	fsparam_flag	("abort_on_full",		Opt_abort_on_full),
+ 	fsparam_flag_no ("cephx_require_signatures",	Opt_cephx_require_signatures),
+ 	fsparam_flag_no ("cephx_sign_messages",		Opt_cephx_sign_messages),
+ 	fsparam_flag_no ("crc",				Opt_crc),
+ 	fsparam_string	("fsid",			Opt_fsid),
+ 	fsparam_string	("ip",				Opt_ip),
+ 	fsparam_string	("key",				Opt_key),
+ 	fsparam_u32	("mount_timeout",		Opt_mount_timeout),
+ 	fsparam_string	("name",			Opt_name),
+ 	fsparam_u32	("osd_idle_ttl",		Opt_osd_idle_ttl),
+ 	fsparam_u32	("osd_request_timeout",		Opt_osd_request_timeout),
+ 	fsparam_u32	("osdkeepalive",		Opt_osdkeepalivetimeout),
+ 	__fsparam	(fs_param_is_s32, "osdtimeout", Opt_osdtimeout,
+ 			 fs_param_deprecated, NULL),
+ 	fsparam_string	("secret",			Opt_secret),
+ 	fsparam_flag_no ("share",			Opt_share),
+ 	fsparam_flag_no ("tcp_nodelay",			Opt_tcp_nodelay),
+ 	{}
+ };
+ 
+ struct ceph_options *ceph_alloc_options(void)
+ {
+ 	struct ceph_options *opt;
+ 
+ 	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
+ 	if (!opt)
+ 		return NULL;
+ 
+ 	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
+ 				GFP_KERNEL);
+ 	if (!opt->mon_addr) {
+ 		kfree(opt);
+ 		return NULL;
+ 	}
+ 
+ 	opt->flags = CEPH_OPT_DEFAULT;
+ 	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
+ 	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
+ 	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
+ 	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
+ 	return opt;
+ }
+ EXPORT_SYMBOL(ceph_alloc_options);
+ 
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  void ceph_destroy_options(struct ceph_options *opt)
  {
  	dout("destroy_options %p\n", opt);
@@@ -370,242 -377,159 +418,270 @@@ out
  	return err;
  }
  
 -int ceph_parse_mon_ips(const char *buf, size_t len, struct ceph_options *opt,
 -		       struct fc_log *l)
 +struct ceph_options *
 +ceph_parse_options(char *options, const char *dev_name,
 +			const char *dev_name_end,
 +			int (*parse_extra_token)(char *c, void *private),
 +			void *private)
  {
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -	int ret;
 +	struct ceph_options *opt;
 +	const char *c;
 +	int err = -ENOMEM;
 +	substring_t argstr[MAX_OPT_ARGS];
 +
 +	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
 +	if (!opt)
 +		return ERR_PTR(-ENOMEM);
 +
 +	opt->crush_locs = RB_ROOT;
 +	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
 +				GFP_KERNEL);
 +	if (!opt->mon_addr)
 +		goto out;
 +
 +	dout("parse_options %p options '%s' dev_name '%s'\n", opt, options,
 +	     dev_name);
  
 +	/* start with defaults */
 +	opt->flags = CEPH_OPT_DEFAULT;
 +	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
 +	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
 +	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
 +	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
 +	opt->read_from_replica = CEPH_READ_FROM_REPLICA_DEFAULT;
 +
 +	/* get mon ip(s) */
  	/* ip1[:port1][,ip2[:port2]...] */
 -	ret = ceph_parse_ips(buf, buf + len, opt->mon_addr, CEPH_MAX_MON,
 -			     &opt->num_mon);
 -	if (ret) {
 -		error_plog(&log, "Failed to parse monitor IPs: %d", ret);
 -		return ret;
 -	}
 +	err = ceph_parse_ips(dev_name, dev_name_end, opt->mon_addr,
 +			     CEPH_MAX_MON, &opt->num_mon);
 +	if (err < 0)
 +		goto out;
  
++<<<<<<< HEAD
 +	/* parse mount options */
 +	while ((c = strsep(&options, ",")) != NULL) {
 +		int token, intval;
 +		if (!*c)
 +			continue;
 +		err = -EINVAL;
 +		token = match_token((char *)c, opt_tokens, argstr);
 +		if (token < 0 && parse_extra_token) {
 +			/* extra? */
 +			err = parse_extra_token((char *)c, private);
 +			if (err < 0) {
 +				pr_err("bad option at '%s'\n", c);
 +				goto out;
 +			}
 +			continue;
++=======
+ 	return 0;
+ }
+ EXPORT_SYMBOL(ceph_parse_mon_ips);
+ 
+ int ceph_parse_param(struct fs_parameter *param, struct ceph_options *opt,
+ 		     struct fc_log *l)
+ {
+ 	struct fs_parse_result result;
+ 	int token, err;
+ 	struct p_log log = {.prefix = "libceph", .log = l};
+ 
+ 	token = __fs_parse(&log, ceph_parameters, param, &result);
+ 	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
+ 	if (token < 0)
+ 		return token;
+ 
+ 	switch (token) {
+ 	case Opt_ip:
+ 		err = ceph_parse_ips(param->string,
+ 				     param->string + param->size,
+ 				     &opt->my_addr,
+ 				     1, NULL);
+ 		if (err) {
+ 			error_plog(&log, "Failed to parse ip: %d", err);
+ 			return err;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  		}
 -		opt->flags |= CEPH_OPT_MYIP;
 -		break;
 -
 -	case Opt_fsid:
 -		err = parse_fsid(param->string, &opt->fsid);
 -		if (err) {
 -			error_plog(&log, "Failed to parse fsid: %d", err);
 -			return err;
 +		if (token < Opt_last_int) {
 +			err = match_int(&argstr[0], &intval);
 +			if (err < 0) {
 +				pr_err("bad option arg (not int) at '%s'\n", c);
 +				goto out;
 +			}
 +			dout("got int token %d val %d\n", token, intval);
 +		} else if (token > Opt_last_int && token < Opt_last_string) {
 +			dout("got string token %d val %s\n", token,
 +			     argstr[0].from);
 +		} else {
 +			dout("got token %d\n", token);
  		}
 -		opt->flags |= CEPH_OPT_FSID;
 -		break;
 -	case Opt_name:
 -		kfree(opt->name);
 -		opt->name = param->string;
 -		param->string = NULL;
 -		break;
 -	case Opt_secret:
 -		ceph_crypto_key_destroy(opt->key);
 -		kfree(opt->key);
 +		switch (token) {
 +		case Opt_ip:
 +			err = ceph_parse_ips(argstr[0].from,
 +					     argstr[0].to,
 +					     &opt->my_addr,
 +					     1, NULL);
 +			if (err < 0)
 +				goto out;
 +			opt->flags |= CEPH_OPT_MYIP;
 +			break;
  
 -		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 -		if (!opt->key)
 -			return -ENOMEM;
 -		err = ceph_crypto_key_unarmor(opt->key, param->string);
 -		if (err) {
 -			error_plog(&log, "Failed to parse secret: %d", err);
 -			return err;
 -		}
 -		break;
 -	case Opt_key:
 -		ceph_crypto_key_destroy(opt->key);
 -		kfree(opt->key);
 +		case Opt_fsid:
 +			err = parse_fsid(argstr[0].from, &opt->fsid);
 +			if (err == 0)
 +				opt->flags |= CEPH_OPT_FSID;
 +			break;
 +		case Opt_name:
 +			kfree(opt->name);
 +			opt->name = kstrndup(argstr[0].from,
 +					      argstr[0].to-argstr[0].from,
 +					      GFP_KERNEL);
 +			if (!opt->name) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			break;
 +		case Opt_secret:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
 +
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = ceph_crypto_key_unarmor(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
 +		case Opt_key:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
 +
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = get_secret(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
 +		case Opt_crush_location:
 +			ceph_clear_crush_locs(&opt->crush_locs);
 +			err = ceph_parse_crush_location(argstr[0].from,
 +							&opt->crush_locs);
 +			if (err) {
 +				pr_err("failed to parse CRUSH location: %d\n",
 +				       err);
 +				goto out;
 +			}
 +			break;
 +		case Opt_read_from_replica:
 +			if (!strcmp(argstr[0].from, "no")) {
 +				opt->read_from_replica = 0;
 +			} else if (!strcmp(argstr[0].from, "balance")) {
 +				opt->read_from_replica = CEPH_OSD_FLAG_BALANCE_READS;
 +			} else if (!strcmp(argstr[0].from, "localize")) {
 +				opt->read_from_replica = CEPH_OSD_FLAG_LOCALIZE_READS;
 +			} else {
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			break;
 +
 +			/* misc */
 +		case Opt_osdtimeout:
 +			pr_warn("ignoring deprecated osdtimeout option\n");
 +			break;
 +		case Opt_osdkeepalivetimeout:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osdkeepalive out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_keepalive_timeout =
 +					msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_idle_ttl:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osd_idle_ttl out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_idle_ttl = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_mount_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("mount_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->mount_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_request_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("osd_request_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_request_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
  
 -		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 -		if (!opt->key)
 -			return -ENOMEM;
 -		return get_secret(opt->key, param->string, &log);
 -
 -	case Opt_osdtimeout:
 -		warn_plog(&log, "Ignoring osdtimeout");
 -		break;
 -	case Opt_osdkeepalivetimeout:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_keepalive_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_idle_ttl:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_idle_ttl = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_mount_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->mount_timeout = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_request_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_request_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -
 -	case Opt_share:
 -		if (!result.negated)
 +		case Opt_share:
  			opt->flags &= ~CEPH_OPT_NOSHARE;
 -		else
 +			break;
 +		case Opt_noshare:
  			opt->flags |= CEPH_OPT_NOSHARE;
 -		break;
 -	case Opt_crc:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_crc:
  			opt->flags &= ~CEPH_OPT_NOCRC;
 -		else
 +			break;
 +		case Opt_nocrc:
  			opt->flags |= CEPH_OPT_NOCRC;
 -		break;
 -	case Opt_cephx_require_signatures:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_cephx_require_signatures:
  			opt->flags &= ~CEPH_OPT_NOMSGAUTH;
 -		else
 +			break;
 +		case Opt_nocephx_require_signatures:
  			opt->flags |= CEPH_OPT_NOMSGAUTH;
 -		break;
 -	case Opt_cephx_sign_messages:
 -		if (!result.negated)
 +			break;
 +		case Opt_cephx_sign_messages:
  			opt->flags &= ~CEPH_OPT_NOMSGSIGN;
 -		else
 +			break;
 +		case Opt_nocephx_sign_messages:
  			opt->flags |= CEPH_OPT_NOMSGSIGN;
 -		break;
 -	case Opt_tcp_nodelay:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_tcp_nodelay:
  			opt->flags |= CEPH_OPT_TCP_NODELAY;
 -		else
 +			break;
 +		case Opt_notcp_nodelay:
  			opt->flags &= ~CEPH_OPT_TCP_NODELAY;
 -		break;
 +			break;
  
 -	case Opt_abort_on_full:
 -		opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 -		break;
 +		case Opt_abort_on_full:
 +			opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 +			break;
  
 -	default:
 -		BUG();
 +		default:
 +			BUG_ON(token);
 +		}
  	}
  
 -	return 0;
 +	/* success */
 +	return opt;
  
 -out_of_range:
 -	return inval_plog(&log, "%s out of range", param->key);
 +out:
 +	ceph_destroy_options(opt);
 +	return ERR_PTR(err);
  }
 -EXPORT_SYMBOL(ceph_parse_param);
 +EXPORT_SYMBOL(ceph_parse_options);
  
  int ceph_print_client_options(struct seq_file *m, struct ceph_client *client,
  			      bool show_all)
diff --cc security/selinux/hooks.c
index 028981031687,d085569fd426..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -2890,6 -2770,71 +2890,74 @@@ static int selinux_umount(struct vfsmou
  				   FILESYSTEM__UNMOUNT, NULL);
  }
  
++<<<<<<< HEAD
++=======
+ static int selinux_fs_context_dup(struct fs_context *fc,
+ 				  struct fs_context *src_fc)
+ {
+ 	const struct selinux_mnt_opts *src = src_fc->security;
+ 	struct selinux_mnt_opts *opts;
+ 
+ 	if (!src)
+ 		return 0;
+ 
+ 	fc->security = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);
+ 	if (!fc->security)
+ 		return -ENOMEM;
+ 
+ 	opts = fc->security;
+ 
+ 	if (src->fscontext) {
+ 		opts->fscontext = kstrdup(src->fscontext, GFP_KERNEL);
+ 		if (!opts->fscontext)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->context) {
+ 		opts->context = kstrdup(src->context, GFP_KERNEL);
+ 		if (!opts->context)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->rootcontext) {
+ 		opts->rootcontext = kstrdup(src->rootcontext, GFP_KERNEL);
+ 		if (!opts->rootcontext)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->defcontext) {
+ 		opts->defcontext = kstrdup(src->defcontext, GFP_KERNEL);
+ 		if (!opts->defcontext)
+ 			return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct fs_parameter_spec selinux_fs_parameters[] = {
+ 	fsparam_string(CONTEXT_STR,	Opt_context),
+ 	fsparam_string(DEFCONTEXT_STR,	Opt_defcontext),
+ 	fsparam_string(FSCONTEXT_STR,	Opt_fscontext),
+ 	fsparam_string(ROOTCONTEXT_STR,	Opt_rootcontext),
+ 	fsparam_flag  (SECLABEL_STR,	Opt_seclabel),
+ 	{}
+ };
+ 
+ static int selinux_fs_context_parse_param(struct fs_context *fc,
+ 					  struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	int opt, rc;
+ 
+ 	opt = fs_parse(fc, selinux_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	rc = selinux_add_opt(opt, param->string, &fc->security);
+ 	if (!rc) {
+ 		param->string = NULL;
+ 		rc = 1;
+ 	}
+ 	return rc;
+ }
+ 
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  /* inode security operations */
  
  static int selinux_inode_alloc_security(struct inode *inode)
@@@ -7260,6 -7140,8 +7328,11 @@@ static __init int selinux_init(void
  	else
  		pr_debug("SELinux:  Starting in permissive mode\n");
  
++<<<<<<< HEAD
++=======
+ 	fs_validate_description("selinux", selinux_fs_parameters);
+ 
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	return 0;
  }
  
diff --cc security/smack/smack_lsm.c
index 77b0bfb018e5,ed17049d39d5..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -723,15 -626,89 +723,97 @@@ static int smack_parse_opts_str(char *o
  	return 0;
  
  out_opt_err:
 +	rc = -EINVAL;
  	pr_warn("Smack: duplicate mount options\n");
 -	return -EINVAL;
 -}
  
++<<<<<<< HEAD
 +out_err:
 +	kfree(fsdefault);
 +	kfree(fsfloor);
 +	kfree(fshat);
 +	kfree(fsroot);
 +	kfree(fstransmute);
++=======
+ /**
+  * smack_fs_context_dup - Duplicate the security data on fs_context duplication
+  * @fc: The new filesystem context.
+  * @src_fc: The source filesystem context being duplicated.
+  *
+  * Returns 0 on success or -ENOMEM on error.
+  */
+ static int smack_fs_context_dup(struct fs_context *fc,
+ 				struct fs_context *src_fc)
+ {
+ 	struct smack_mnt_opts *dst, *src = src_fc->security;
+ 
+ 	if (!src)
+ 		return 0;
+ 
+ 	fc->security = kzalloc(sizeof(struct smack_mnt_opts), GFP_KERNEL);
+ 	if (!fc->security)
+ 		return -ENOMEM;
+ 	dst = fc->security;
+ 
+ 	if (src->fsdefault) {
+ 		dst->fsdefault = kstrdup(src->fsdefault, GFP_KERNEL);
+ 		if (!dst->fsdefault)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fsfloor) {
+ 		dst->fsfloor = kstrdup(src->fsfloor, GFP_KERNEL);
+ 		if (!dst->fsfloor)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fshat) {
+ 		dst->fshat = kstrdup(src->fshat, GFP_KERNEL);
+ 		if (!dst->fshat)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fsroot) {
+ 		dst->fsroot = kstrdup(src->fsroot, GFP_KERNEL);
+ 		if (!dst->fsroot)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fstransmute) {
+ 		dst->fstransmute = kstrdup(src->fstransmute, GFP_KERNEL);
+ 		if (!dst->fstransmute)
+ 			return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct fs_parameter_spec smack_fs_parameters[] = {
+ 	fsparam_string("smackfsdef",		Opt_fsdefault),
+ 	fsparam_string("smackfsdefault",	Opt_fsdefault),
+ 	fsparam_string("smackfsfloor",		Opt_fsfloor),
+ 	fsparam_string("smackfshat",		Opt_fshat),
+ 	fsparam_string("smackfsroot",		Opt_fsroot),
+ 	fsparam_string("smackfstransmute",	Opt_fstransmute),
+ 	{}
+ };
+ 
+ /**
+  * smack_fs_context_parse_param - Parse a single mount parameter
+  * @fc: The new filesystem context being constructed.
+  * @param: The parameter.
+  *
+  * Returns 0 on success, -ENOPARAM to pass the parameter on or anything else on
+  * error.
+  */
+ static int smack_fs_context_parse_param(struct fs_context *fc,
+ 					struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	int opt, rc;
+ 
+ 	opt = fs_parse(fc, smack_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	rc = smack_add_opt(opt, param->string, &fc->security);
+ 	if (!rc)
+ 		param->string = NULL;
++>>>>>>> d7167b149943 (fs_parse: fold fs_parameter_desc/fs_parameter_spec)
  	return rc;
  }
  
* Unmerged path fs/fs_parser.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path include/linux/fs_parser.h
* Unmerged path arch/powerpc/platforms/cell/spufs/inode.c
* Unmerged path arch/s390/hypfs/inode.c
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
* Unmerged path drivers/base/devtmpfs.c
* Unmerged path drivers/block/rbd.c
* Unmerged path drivers/usb/gadget/function/f_fs.c
* Unmerged path fs/afs/super.c
* Unmerged path fs/ceph/super.c
* Unmerged path fs/fs_parser.c
* Unmerged path fs/fuse/inode.c
* Unmerged path fs/gfs2/ops_fstype.c
* Unmerged path fs/hugetlbfs/inode.c
* Unmerged path fs/jffs2/super.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/proc/root.c
* Unmerged path fs/ramfs/inode.c
* Unmerged path fs/xfs/xfs_super.c
* Unmerged path include/linux/fs.h
* Unmerged path include/linux/fs_parser.h
* Unmerged path include/linux/ramfs.h
* Unmerged path include/linux/shmem_fs.h
* Unmerged path kernel/bpf/inode.c
* Unmerged path kernel/cgroup/cgroup-internal.h
* Unmerged path kernel/cgroup/cgroup-v1.c
* Unmerged path kernel/cgroup/cgroup.c
* Unmerged path mm/shmem.c
* Unmerged path net/ceph/ceph_common.c
* Unmerged path security/selinux/hooks.c
* Unmerged path security/smack/smack_lsm.c
