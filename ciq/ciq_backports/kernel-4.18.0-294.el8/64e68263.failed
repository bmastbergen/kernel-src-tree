x86/boot/compressed/64: Add IDT Infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] boot/compressed/64: Add IDT Infrastructure (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 95.45%
commit-author Joerg Roedel <jroedel@suse.de>
commit 64e682638eb51070ba6044535b250aad43c5564e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/64e68263.failed

Add code needed to setup an IDT in the early pre-decompression
boot-code. The IDT is loaded first in startup_64, which is after
EfiExitBootServices() has been called, and later reloaded when the
kernel image has been relocated to the end of the decompression area.

This allows to setup different IDT handlers before and after the
relocation.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20200907131613.12703-14-joro@8bytes.org
(cherry picked from commit 64e682638eb51070ba6044535b250aad43c5564e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/head_64.S
#	arch/x86/boot/compressed/misc.h
diff --cc arch/x86/boot/compressed/head_64.S
index 8b6d90a596e6,c634ed8636da..000000000000
--- a/arch/x86/boot/compressed/head_64.S
+++ b/arch/x86/boot/compressed/head_64.S
@@@ -620,27 -700,112 +632,44 @@@ gdt
  	.quad	0x00cf92000000ffff	/* __KERNEL_DS */
  	.quad	0x0080890000000000	/* TS descriptor */
  	.quad   0x0000000000000000	/* TS continued */
 -SYM_DATA_END_LABEL(gdt, SYM_L_LOCAL, gdt_end)
 +gdt_end:
  
+ SYM_DATA_START(boot_idt_desc)
+ 	.word	boot_idt_end - boot_idt - 1
+ 	.quad	0
+ SYM_DATA_END(boot_idt_desc)
+ 	.balign 8
+ SYM_DATA_START(boot_idt)
+ 	.rept	BOOT_IDT_ENTRIES
+ 	.quad	0
+ 	.quad	0
+ 	.endr
+ SYM_DATA_END_LABEL(boot_idt, SYM_L_GLOBAL, boot_idt_end)
+ 
  #ifdef CONFIG_EFI_STUB
++<<<<<<< HEAD
 +efi_config:
 +	.quad	0
 +
++=======
+ SYM_DATA(image_offset, .long 0)
+ #endif
++>>>>>>> 64e682638eb5 (x86/boot/compressed/64: Add IDT Infrastructure)
  #ifdef CONFIG_EFI_MIXED
 -SYM_DATA_LOCAL(efi32_boot_args, .long 0, 0, 0)
 -SYM_DATA(efi_is64, .byte 1)
 -
 -#define ST32_boottime		60 // offsetof(efi_system_table_32_t, boottime)
 -#define BS32_handle_protocol	88 // offsetof(efi_boot_services_32_t, handle_protocol)
 -#define LI32_image_base		32 // offsetof(efi_loaded_image_32_t, image_base)
 -
 -	.text
 -	.code32
 -SYM_FUNC_START(efi32_pe_entry)
 -/*
 - * efi_status_t efi32_pe_entry(efi_handle_t image_handle,
 - *			       efi_system_table_32_t *sys_table)
 - */
 -
 -	pushl	%ebp
 -	movl	%esp, %ebp
 -	pushl	%eax				// dummy push to allocate loaded_image
 -
 -	pushl	%ebx				// save callee-save registers
 -	pushl	%edi
 -
 -	call	verify_cpu			// check for long mode support
 -	testl	%eax, %eax
 -	movl	$0x80000003, %eax		// EFI_UNSUPPORTED
 -	jnz	2f
 -
 -	call	1f
 -1:	pop	%ebx
 -	subl	$1b, %ebx
 -
 -	/* Get the loaded image protocol pointer from the image handle */
 -	leal	-4(%ebp), %eax
 -	pushl	%eax				// &loaded_image
 -	leal	loaded_image_proto(%ebx), %eax
 -	pushl	%eax				// pass the GUID address
 -	pushl	8(%ebp)				// pass the image handle
 -
 -	/*
 -	 * Note the alignment of the stack frame.
 -	 *   sys_table
 -	 *   handle             <-- 16-byte aligned on entry by ABI
 -	 *   return address
 -	 *   frame pointer
 -	 *   loaded_image       <-- local variable
 -	 *   saved %ebx		<-- 16-byte aligned here
 -	 *   saved %edi
 -	 *   &loaded_image
 -	 *   &loaded_image_proto
 -	 *   handle             <-- 16-byte aligned for call to handle_protocol
 -	 */
 -
 -	movl	12(%ebp), %eax			// sys_table
 -	movl	ST32_boottime(%eax), %eax	// sys_table->boottime
 -	call	*BS32_handle_protocol(%eax)	// sys_table->boottime->handle_protocol
 -	addl	$12, %esp			// restore argument space
 -	testl	%eax, %eax
 -	jnz	2f
 -
 -	movl	8(%ebp), %ecx			// image_handle
 -	movl	12(%ebp), %edx			// sys_table
 -	movl	-4(%ebp), %esi			// loaded_image
 -	movl	LI32_image_base(%esi), %esi	// loaded_image->image_base
 -	movl	%ebx, %ebp			// startup_32 for efi32_pe_stub_entry
 -	/*
 -	 * We need to set the image_offset variable here since startup_32() will
 -	 * use it before we get to the 64-bit efi_pe_entry() in C code.
 -	 */
 -	subl	%esi, %ebx
 -	movl	%ebx, image_offset(%ebp)	// save image_offset
 -	jmp	efi32_pe_stub_entry
 -
 -2:	popl	%edi				// restore callee-save registers
 -	popl	%ebx
 -	leave
 -	ret
 -SYM_FUNC_END(efi32_pe_entry)
 -
 -	.section ".rodata"
 -	/* EFI loaded image protocol GUID */
 -	.balign 4
 -SYM_DATA_START_LOCAL(loaded_image_proto)
 -	.long	0x5b1b31a1
 -	.word	0x9562, 0x11d2
 -	.byte	0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b
 -SYM_DATA_END(loaded_image_proto)
 +	.global efi32_config
 +efi32_config:
 +	.fill	5,8,0
 +	.quad	efi64_thunk
 +	.byte	0
  #endif
  
 +	.global efi64_config
 +efi64_config:
 +	.fill	5,8,0
 +	.quad	efi_call
 +	.byte	1
 +#endif /* CONFIG_EFI_STUB */
 +
  /*
   * Stack and heap for uncompression
   */
diff --cc arch/x86/boot/compressed/misc.h
index d55a1ca4f95b,8feb5f6f329e..000000000000
--- a/arch/x86/boot/compressed/misc.h
+++ b/arch/x86/boot/compressed/misc.h
@@@ -22,7 -23,7 +22,11 @@@
  #include <asm/page.h>
  #include <asm/boot.h>
  #include <asm/bootparam.h>
++<<<<<<< HEAD
 +#include <asm/bootparam_utils.h>
++=======
+ #include <asm/desc_defs.h>
++>>>>>>> 64e682638eb5 (x86/boot/compressed/64: Add IDT Infrastructure)
  
  #define BOOT_CTYPE_H
  #include <linux/acpi.h>
diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile
index 0ae4decaece3..27071c9eebda 100644
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@ -79,6 +79,7 @@ vmlinux-objs-$(CONFIG_EARLY_PRINTK) += $(obj)/early_serial_console.o
 vmlinux-objs-$(CONFIG_RANDOMIZE_BASE) += $(obj)/kaslr.o
 ifdef CONFIG_X86_64
 	vmlinux-objs-$(CONFIG_RANDOMIZE_BASE) += $(obj)/kaslr_64.o
+	vmlinux-objs-y += $(obj)/idt_64.o $(obj)/idt_handlers_64.o
 	vmlinux-objs-y += $(obj)/mem_encrypt.o
 	vmlinux-objs-y += $(obj)/pgtable_64.o
 endif
* Unmerged path arch/x86/boot/compressed/head_64.S
diff --git a/arch/x86/boot/compressed/idt_64.c b/arch/x86/boot/compressed/idt_64.c
new file mode 100644
index 000000000000..082cd6bca033
--- /dev/null
+++ b/arch/x86/boot/compressed/idt_64.c
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include <asm/trap_pf.h>
+#include <asm/segment.h>
+#include <asm/trapnr.h>
+#include "misc.h"
+
+static void set_idt_entry(int vector, void (*handler)(void))
+{
+	unsigned long address = (unsigned long)handler;
+	gate_desc entry;
+
+	memset(&entry, 0, sizeof(entry));
+
+	entry.offset_low    = (u16)(address & 0xffff);
+	entry.segment       = __KERNEL_CS;
+	entry.bits.type     = GATE_TRAP;
+	entry.bits.p        = 1;
+	entry.offset_middle = (u16)((address >> 16) & 0xffff);
+	entry.offset_high   = (u32)(address >> 32);
+
+	memcpy(&boot_idt[vector], &entry, sizeof(entry));
+}
+
+/* Have this here so we don't need to include <asm/desc.h> */
+static void load_boot_idt(const struct desc_ptr *dtr)
+{
+	asm volatile("lidt %0"::"m" (*dtr));
+}
+
+/* Setup IDT before kernel jumping to  .Lrelocated */
+void load_stage1_idt(void)
+{
+	boot_idt_desc.address = (unsigned long)boot_idt;
+
+	load_boot_idt(&boot_idt_desc);
+}
+
+/* Setup IDT after kernel jumping to  .Lrelocated */
+void load_stage2_idt(void)
+{
+	boot_idt_desc.address = (unsigned long)boot_idt;
+
+	load_boot_idt(&boot_idt_desc);
+}
diff --git a/arch/x86/boot/compressed/idt_handlers_64.S b/arch/x86/boot/compressed/idt_handlers_64.S
new file mode 100644
index 000000000000..36dee2f40a8b
--- /dev/null
+++ b/arch/x86/boot/compressed/idt_handlers_64.S
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Early IDT handler entry points
+ *
+ * Copyright (C) 2019 SUSE
+ *
+ * Author: Joerg Roedel <jroedel@suse.de>
+ */
+
+#include <asm/segment.h>
+
+/* For ORIG_RAX */
+#include "../../entry/calling.h"
+
+.macro EXCEPTION_HANDLER name function error_code=0
+SYM_FUNC_START(\name)
+
+	/* Build pt_regs */
+	.if \error_code == 0
+	pushq   $0
+	.endif
+
+	pushq   %rdi
+	pushq   %rsi
+	pushq   %rdx
+	pushq   %rcx
+	pushq   %rax
+	pushq   %r8
+	pushq   %r9
+	pushq   %r10
+	pushq   %r11
+	pushq   %rbx
+	pushq   %rbp
+	pushq   %r12
+	pushq   %r13
+	pushq   %r14
+	pushq   %r15
+
+	/* Call handler with pt_regs */
+	movq    %rsp, %rdi
+	/* Error code is second parameter */
+	movq	ORIG_RAX(%rsp), %rsi
+	call    \function
+
+	/* Restore regs */
+	popq    %r15
+	popq    %r14
+	popq    %r13
+	popq    %r12
+	popq    %rbp
+	popq    %rbx
+	popq    %r11
+	popq    %r10
+	popq    %r9
+	popq    %r8
+	popq    %rax
+	popq    %rcx
+	popq    %rdx
+	popq    %rsi
+	popq    %rdi
+
+	/* Remove error code and return */
+	addq    $8, %rsp
+
+	iretq
+SYM_FUNC_END(\name)
+	.endm
+
+	.text
+	.code64
* Unmerged path arch/x86/boot/compressed/misc.h
diff --git a/arch/x86/include/asm/desc_defs.h b/arch/x86/include/asm/desc_defs.h
index a91f3b6e4f2a..5621fb3f2d1a 100644
--- a/arch/x86/include/asm/desc_defs.h
+++ b/arch/x86/include/asm/desc_defs.h
@@ -109,6 +109,9 @@ struct desc_ptr {
 
 #endif /* !__ASSEMBLY__ */
 
+/* Boot IDT definitions */
+#define	BOOT_IDT_ENTRIES	32
+
 /* Access rights as returned by LAR */
 #define AR_TYPE_RODATA		(0 * (1 << 9))
 #define AR_TYPE_RWDATA		(1 * (1 << 9))
