dma-pool: decouple DMA_REMAP from DMA_COHERENT_POOL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Rientjes <rientjes@google.com>
commit dbed452a078d56bc7f1abecc3edd6a75e8e4484e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dbed452a.failed

DMA_REMAP is an unnecessary requirement for AMD SEV, which requires
DMA_COHERENT_POOL, so avoid selecting it when it is otherwise unnecessary.

The only other requirement for DMA coherent pools is DMA_DIRECT_REMAP, so
ensure that properly selects the config option when needed.

Fixes: 82fef0ad811f ("x86/mm: unencrypted non-blocking DMA allocations use coherent pools")
	Reported-by: Alex Xu (Hello71) <alex_y_xu@yahoo.ca>
	Signed-off-by: David Rientjes <rientjes@google.com>
	Tested-by: Alex Xu (Hello71) <alex_y_xu@yahoo.ca>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit dbed452a078d56bc7f1abecc3edd6a75e8e4484e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/Kconfig
diff --cc kernel/dma/Kconfig
index b1048cb7a930,a0ce3c1494fd..000000000000
--- a/kernel/dma/Kconfig
+++ b/kernel/dma/Kconfig
@@@ -73,8 -81,121 +77,128 @@@ config DMA_REMA
  	depends on MMU
  	select GENERIC_ALLOCATOR
  	select DMA_NONCOHERENT_MMAP
++<<<<<<< HEAD
 +	bool
++=======
++>>>>>>> dbed452a078d (dma-pool: decouple DMA_REMAP from DMA_COHERENT_POOL)
  
  config DMA_DIRECT_REMAP
  	bool
  	select DMA_REMAP
++<<<<<<< HEAD
++=======
+ 	select DMA_COHERENT_POOL
+ 
+ config DMA_CMA
+ 	bool "DMA Contiguous Memory Allocator"
+ 	depends on HAVE_DMA_CONTIGUOUS && CMA
+ 	help
+ 	  This enables the Contiguous Memory Allocator which allows drivers
+ 	  to allocate big physically-contiguous blocks of memory for use with
+ 	  hardware components that do not support I/O map nor scatter-gather.
+ 
+ 	  You can disable CMA by specifying "cma=0" on the kernel's command
+ 	  line.
+ 
+ 	  For more information see <include/linux/dma-contiguous.h>.
+ 	  If unsure, say "n".
+ 
+ if  DMA_CMA
+ comment "Default contiguous memory area size:"
+ 
+ config CMA_SIZE_MBYTES
+ 	int "Size in Mega Bytes"
+ 	depends on !CMA_SIZE_SEL_PERCENTAGE
+ 	default 0 if X86
+ 	default 16
+ 	help
+ 	  Defines the size (in MiB) of the default memory area for Contiguous
+ 	  Memory Allocator.  If the size of 0 is selected, CMA is disabled by
+ 	  default, but it can be enabled by passing cma=size[MG] to the kernel.
+ 
+ 
+ config CMA_SIZE_PERCENTAGE
+ 	int "Percentage of total memory"
+ 	depends on !CMA_SIZE_SEL_MBYTES
+ 	default 0 if X86
+ 	default 10
+ 	help
+ 	  Defines the size of the default memory area for Contiguous Memory
+ 	  Allocator as a percentage of the total memory in the system.
+ 	  If 0 percent is selected, CMA is disabled by default, but it can be
+ 	  enabled by passing cma=size[MG] to the kernel.
+ 
+ choice
+ 	prompt "Selected region size"
+ 	default CMA_SIZE_SEL_MBYTES
+ 
+ config CMA_SIZE_SEL_MBYTES
+ 	bool "Use mega bytes value only"
+ 
+ config CMA_SIZE_SEL_PERCENTAGE
+ 	bool "Use percentage value only"
+ 
+ config CMA_SIZE_SEL_MIN
+ 	bool "Use lower value (minimum)"
+ 
+ config CMA_SIZE_SEL_MAX
+ 	bool "Use higher value (maximum)"
+ 
+ endchoice
+ 
+ config CMA_ALIGNMENT
+ 	int "Maximum PAGE_SIZE order of alignment for contiguous buffers"
+ 	range 4 12
+ 	default 8
+ 	help
+ 	  DMA mapping framework by default aligns all buffers to the smallest
+ 	  PAGE_SIZE order which is greater than or equal to the requested buffer
+ 	  size. This works well for buffers up to a few hundreds kilobytes, but
+ 	  for larger buffers it just a memory waste. With this parameter you can
+ 	  specify the maximum PAGE_SIZE order for contiguous buffers. Larger
+ 	  buffers will be aligned only to this specified order. The order is
+ 	  expressed as a power of two multiplied by the PAGE_SIZE.
+ 
+ 	  For example, if your system defaults to 4KiB pages, the order value
+ 	  of 8 means that the buffers will be aligned up to 1MiB only.
+ 
+ 	  If unsure, leave the default value "8".
+ 
+ endif
+ 
+ config DMA_API_DEBUG
+ 	bool "Enable debugging of DMA-API usage"
+ 	select NEED_DMA_MAP_STATE
+ 	help
+ 	  Enable this option to debug the use of the DMA API by device drivers.
+ 	  With this option you will be able to detect common bugs in device
+ 	  drivers like double-freeing of DMA mappings or freeing mappings that
+ 	  were never allocated.
+ 
+ 	  This also attempts to catch cases where a page owned by DMA is
+ 	  accessed by the cpu in a way that could cause data corruption.  For
+ 	  example, this enables cow_user_page() to check that the source page is
+ 	  not undergoing DMA.
+ 
+ 	  This option causes a performance degradation.  Use only if you want to
+ 	  debug device drivers and dma interactions.
+ 
+ 	  If unsure, say N.
+ 
+ config DMA_API_DEBUG_SG
+ 	bool "Debug DMA scatter-gather usage"
+ 	default y
+ 	depends on DMA_API_DEBUG
+ 	help
+ 	  Perform extra checking that callers of dma_map_sg() have respected the
+ 	  appropriate segment length/boundary limits for the given device when
+ 	  preparing DMA scatterlists.
+ 
+ 	  This is particularly likely to have been overlooked in cases where the
+ 	  dma_map_sg() API is used for general bulk mapping of pages rather than
+ 	  preparing literal scatter-gather descriptors, where there is a risk of
+ 	  unexpected behaviour from DMA API implementations if the scatterlist
+ 	  is technically out-of-spec.
+ 
+ 	  If unsure, say N.
++>>>>>>> dbed452a078d (dma-pool: decouple DMA_REMAP from DMA_COHERENT_POOL)
* Unmerged path kernel/dma/Kconfig
