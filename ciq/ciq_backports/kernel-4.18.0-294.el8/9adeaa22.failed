mm, slab: move memcg_cache_params structure to mm/slab.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Waiman Long <longman@redhat.com>
commit 9adeaa226988b97bc15928e12f40a9863134467c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9adeaa22.failed

The memcg_cache_params structure is only embedded into the kmem_cache of
slab and slub allocators as defined in slab_def.h and slub_def.h and used
internally by mm code.  There is no needed to expose it in a public
header.  So move it from include/linux/slab.h to mm/slab.h.  It is just a
refactoring patch with no code change.

In fact both the slub_def.h and slab_def.h should be moved into the mm
directory as well, but that will probably cause many merge conflicts.

Link: http://lkml.kernel.org/r/20190718180827.18758-1-longman@redhat.com
	Signed-off-by: Waiman Long <longman@redhat.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9adeaa226988b97bc15928e12f40a9863134467c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/slab.h
diff --cc include/linux/slab.h
index 7964239d627e,ab2b98ad76e1..000000000000
--- a/include/linux/slab.h
+++ b/include/linux/slab.h
@@@ -599,71 -595,6 +599,74 @@@ static __always_inline void *kmalloc_no
  	return __kmalloc_node(size, flags, node);
  }
  
++<<<<<<< HEAD
 +struct memcg_cache_array {
 +	struct rcu_head rcu;
 +	struct kmem_cache *entries[0];
 +};
 +
 +/*
 + * This is the main placeholder for memcg-related information in kmem caches.
 + * Both the root cache and the child caches will have it. For the root cache,
 + * this will hold a dynamically allocated array large enough to hold
 + * information about the currently limited memcgs in the system. To allow the
 + * array to be accessed without taking any locks, on relocation we free the old
 + * version only after a grace period.
 + *
 + * Root and child caches hold different metadata.
 + *
 + * @root_cache:	Common to root and child caches.  NULL for root, pointer to
 + *		the root cache for children.
 + *
 + * The following fields are specific to root caches.
 + *
 + * @memcg_caches: kmemcg ID indexed table of child caches.  This table is
 + *		used to index child cachces during allocation and cleared
 + *		early during shutdown.
 + *
 + * @root_caches_node: List node for slab_root_caches list.
 + *
 + * @children:	List of all child caches.  While the child caches are also
 + *		reachable through @memcg_caches, a child cache remains on
 + *		this list until it is actually destroyed.
 + *
 + * The following fields are specific to child caches.
 + *
 + * @memcg:	Pointer to the memcg this cache belongs to.
 + *
 + * @children_node: List node for @root_cache->children list.
 + *
 + * @kmem_caches_node: List node for @memcg->kmem_caches list.
 + */
 +struct memcg_cache_params {
 +	struct kmem_cache *root_cache;
 +	union {
 +		struct {
 +			struct memcg_cache_array __rcu *memcg_caches;
 +			struct list_head __root_caches_node;
 +			struct list_head children;
 +			bool dying;
 +		};
 +		struct {
 +			struct mem_cgroup *memcg;
 +			struct list_head children_node;
 +			struct list_head kmem_caches_node;
 +			RH_KABI_BROKEN_INSERT(struct percpu_ref refcnt)
 +
 +			void (*RH_KABI_RENAME(deact_fn,
 +					      work_fn))(struct kmem_cache *);
 +			union {
 +				struct rcu_head RH_KABI_RENAME(deact_rcu_head,
 +							       rcu_head);
 +				struct work_struct RH_KABI_RENAME(deact_work,
 +								  work);
 +			};
 +		};
 +	};
 +};
 +
++=======
++>>>>>>> 9adeaa226988 (mm, slab: move memcg_cache_params structure to mm/slab.h)
  int memcg_update_all_caches(int num_memcgs);
  
  /**
* Unmerged path include/linux/slab.h
diff --git a/mm/slab.h b/mm/slab.h
index 84040de1e8d2..043c86348c87 100644
--- a/mm/slab.h
+++ b/mm/slab.h
@@ -30,6 +30,69 @@ struct kmem_cache {
 	struct list_head list;	/* List of all slab caches on the system */
 };
 
+#else /* !CONFIG_SLOB */
+
+struct memcg_cache_array {
+	struct rcu_head rcu;
+	struct kmem_cache *entries[0];
+};
+
+/*
+ * This is the main placeholder for memcg-related information in kmem caches.
+ * Both the root cache and the child caches will have it. For the root cache,
+ * this will hold a dynamically allocated array large enough to hold
+ * information about the currently limited memcgs in the system. To allow the
+ * array to be accessed without taking any locks, on relocation we free the old
+ * version only after a grace period.
+ *
+ * Root and child caches hold different metadata.
+ *
+ * @root_cache:	Common to root and child caches.  NULL for root, pointer to
+ *		the root cache for children.
+ *
+ * The following fields are specific to root caches.
+ *
+ * @memcg_caches: kmemcg ID indexed table of child caches.  This table is
+ *		used to index child cachces during allocation and cleared
+ *		early during shutdown.
+ *
+ * @root_caches_node: List node for slab_root_caches list.
+ *
+ * @children:	List of all child caches.  While the child caches are also
+ *		reachable through @memcg_caches, a child cache remains on
+ *		this list until it is actually destroyed.
+ *
+ * The following fields are specific to child caches.
+ *
+ * @memcg:	Pointer to the memcg this cache belongs to.
+ *
+ * @children_node: List node for @root_cache->children list.
+ *
+ * @kmem_caches_node: List node for @memcg->kmem_caches list.
+ */
+struct memcg_cache_params {
+	struct kmem_cache *root_cache;
+	union {
+		struct {
+			struct memcg_cache_array __rcu *memcg_caches;
+			struct list_head __root_caches_node;
+			struct list_head children;
+			bool dying;
+		};
+		struct {
+			struct mem_cgroup *memcg;
+			struct list_head children_node;
+			struct list_head kmem_caches_node;
+			struct percpu_ref refcnt;
+
+			void (*work_fn)(struct kmem_cache *);
+			union {
+				struct rcu_head rcu_head;
+				struct work_struct work;
+			};
+		};
+	};
+};
 #endif /* CONFIG_SLOB */
 
 #ifdef CONFIG_SLAB
