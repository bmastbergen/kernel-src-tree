xfs: move xfs_fc_get_tree() above xfs_fc_reconfigure()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ian Kent <raven@themaw.net>
commit 2f8d66b3cd796a96532d9d73957f5c1b88d48815
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2f8d66b3.failed

Grouping the options parsing and mount handling functions above the
struct fs_context_operations but below the struct super_operations
should improve (some) the grouping of the super operations while also
improving the grouping of the options parsing and mount handling code.

Now move xfs_fc_get_tree() and friends, also take the oppertunity to
change STATIC to static for the xfs_fs_put_super() function.
This is a straight code move, there aren't any functional changes.

	Signed-off-by: Ian Kent <raven@themaw.net>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 2f8d66b3cd796a96532d9d73957f5c1b88d48815)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index 9024b0a4c895,33a6eea8ae27..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1765,75 -1571,229 +1823,301 @@@ xfs_fs_fill_super
  	goto out_free_sb;
  }
  
++<<<<<<< HEAD
 +STATIC void
 +xfs_fs_put_super(
 +	struct super_block	*sb)
 +{
 +	struct xfs_mount	*mp = XFS_M(sb);
 +
 +	/* if ->fill_super failed, we have no mount to tear down */
 +	if (!sb->s_fs_info)
 +		return;
 +
 +	xfs_notice(mp, "Unmounting Filesystem");
 +	xfs_filestream_unmount(mp);
 +	xfs_unmountfs(mp);
 +
 +	xfs_freesb(mp);
 +	free_percpu(mp->m_stats.xs_stats);
 +	xfs_destroy_percpu_counters(mp);
 +	xfs_destroy_mount_workqueues(mp);
 +	xfs_close_devices(mp);
 +
 +	sb->s_fs_info = NULL;
 +	xfs_mount_free(mp);
 +}
 +
 +STATIC struct dentry *
 +xfs_fs_mount(
 +	struct file_system_type	*fs_type,
 +	int			flags,
 +	const char		*dev_name,
 +	void			*data)
 +{
 +	return mount_bdev(fs_type, flags, dev_name, data, xfs_fs_fill_super);
 +}
 +
 +static long
 +xfs_fs_nr_cached_objects(
 +	struct super_block	*sb,
 +	struct shrink_control	*sc)
 +{
 +	/* Paranoia: catch incorrect calls during mount setup or teardown */
 +	if (WARN_ON_ONCE(!sb->s_fs_info))
 +		return 0;
 +	return xfs_reclaim_inodes_count(XFS_M(sb));
 +}
 +
 +static long
 +xfs_fs_free_cached_objects(
 +	struct super_block	*sb,
 +	struct shrink_control	*sc)
 +{
 +	return xfs_reclaim_inodes_nr(XFS_M(sb), sc->nr_to_scan);
 +}
 +
 +static const struct super_operations xfs_super_operations = {
 +	.alloc_inode		= xfs_fs_alloc_inode,
 +	.destroy_inode		= xfs_fs_destroy_inode,
 +	.dirty_inode		= xfs_fs_dirty_inode,
 +	.drop_inode		= xfs_fs_drop_inode,
 +	.put_super		= xfs_fs_put_super,
 +	.sync_fs		= xfs_fs_sync_fs,
 +	.freeze_fs		= xfs_fs_freeze,
 +	.unfreeze_fs		= xfs_fs_unfreeze,
 +	.statfs			= xfs_fs_statfs,
 +	.remount_fs		= xfs_fs_remount,
 +	.show_options		= xfs_fs_show_options,
 +	.nr_cached_objects	= xfs_fs_nr_cached_objects,
 +	.free_cached_objects	= xfs_fs_free_cached_objects,
 +};
 +
++=======
+ static int
+ xfs_fc_get_tree(
+ 	struct fs_context	*fc)
+ {
+ 	return get_tree_bdev(fc, xfs_fc_fill_super);
+ }
+ 
+ static int
+ xfs_remount_rw(
+ 	struct xfs_mount	*mp)
+ {
+ 	struct xfs_sb		*sbp = &mp->m_sb;
+ 	int error;
+ 
+ 	if (mp->m_flags & XFS_MOUNT_NORECOVERY) {
+ 		xfs_warn(mp,
+ 			"ro->rw transition prohibited on norecovery mount");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&
+ 	    xfs_sb_has_ro_compat_feature(sbp, XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {
+ 		xfs_warn(mp,
+ 	"ro->rw transition prohibited on unknown (0x%x) ro-compat filesystem",
+ 			(sbp->sb_features_ro_compat &
+ 				XFS_SB_FEAT_RO_COMPAT_UNKNOWN));
+ 		return -EINVAL;
+ 	}
+ 
+ 	mp->m_flags &= ~XFS_MOUNT_RDONLY;
+ 
+ 	/*
+ 	 * If this is the first remount to writeable state we might have some
+ 	 * superblock changes to update.
+ 	 */
+ 	if (mp->m_update_sb) {
+ 		error = xfs_sync_sb(mp, false);
+ 		if (error) {
+ 			xfs_warn(mp, "failed to write sb changes");
+ 			return error;
+ 		}
+ 		mp->m_update_sb = false;
+ 	}
+ 
+ 	/*
+ 	 * Fill out the reserve pool if it is empty. Use the stashed value if
+ 	 * it is non-zero, otherwise go with the default.
+ 	 */
+ 	xfs_restore_resvblks(mp);
+ 	xfs_log_work_queue(mp);
+ 
+ 	/* Recover any CoW blocks that never got remapped. */
+ 	error = xfs_reflink_recover_cow(mp);
+ 	if (error) {
+ 		xfs_err(mp,
+ 			"Error %d recovering leftover CoW allocations.", error);
+ 			xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
+ 		return error;
+ 	}
+ 	xfs_start_block_reaping(mp);
+ 
+ 	/* Create the per-AG metadata reservation pool .*/
+ 	error = xfs_fs_reserve_ag_blocks(mp);
+ 	if (error && error != -ENOSPC)
+ 		return error;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_remount_ro(
+ 	struct xfs_mount	*mp)
+ {
+ 	int error;
+ 
+ 	/*
+ 	 * Cancel background eofb scanning so it cannot race with the final
+ 	 * log force+buftarg wait and deadlock the remount.
+ 	 */
+ 	xfs_stop_block_reaping(mp);
+ 
+ 	/* Get rid of any leftover CoW reservations... */
+ 	error = xfs_icache_free_cowblocks(mp, NULL);
+ 	if (error) {
+ 		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
+ 		return error;
+ 	}
+ 
+ 	/* Free the per-AG metadata reservation pool. */
+ 	error = xfs_fs_unreserve_ag_blocks(mp);
+ 	if (error) {
+ 		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
+ 		return error;
+ 	}
+ 
+ 	/*
+ 	 * Before we sync the metadata, we need to free up the reserve block
+ 	 * pool so that the used block count in the superblock on disk is
+ 	 * correct at the end of the remount. Stash the current* reserve pool
+ 	 * size so that if we get remounted rw, we can return it to the same
+ 	 * size.
+ 	 */
+ 	xfs_save_resvblks(mp);
+ 
+ 	xfs_quiesce_attr(mp);
+ 	mp->m_flags |= XFS_MOUNT_RDONLY;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Logically we would return an error here to prevent users from believing
+  * they might have changed mount options using remount which can't be changed.
+  *
+  * But unfortunately mount(8) adds all options from mtab and fstab to the mount
+  * arguments in some cases so we can't blindly reject options, but have to
+  * check for each specified option if it actually differs from the currently
+  * set option and only reject it if that's the case.
+  *
+  * Until that is implemented we return success for every remount request, and
+  * silently ignore all options that we can't actually change.
+  */
+ static int
+ xfs_fc_reconfigure(
+ 	struct fs_context *fc)
+ {
+ 	struct xfs_mount	*mp = XFS_M(fc->root->d_sb);
+ 	struct xfs_mount        *new_mp = fc->s_fs_info;
+ 	xfs_sb_t		*sbp = &mp->m_sb;
+ 	int			flags = fc->sb_flags;
+ 	int			error;
+ 
+ 	error = xfs_fc_validate_params(new_mp);
+ 	if (error)
+ 		return error;
+ 
+ 	sync_filesystem(mp->m_super);
+ 
+ 	/* inode32 -> inode64 */
+ 	if ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) &&
+ 	    !(new_mp->m_flags & XFS_MOUNT_SMALL_INUMS)) {
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		mp->m_maxagi = xfs_set_inode_alloc(mp, sbp->sb_agcount);
+ 	}
+ 
+ 	/* inode64 -> inode32 */
+ 	if (!(mp->m_flags & XFS_MOUNT_SMALL_INUMS) &&
+ 	    (new_mp->m_flags & XFS_MOUNT_SMALL_INUMS)) {
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		mp->m_maxagi = xfs_set_inode_alloc(mp, sbp->sb_agcount);
+ 	}
+ 
+ 	/* ro -> rw */
+ 	if ((mp->m_flags & XFS_MOUNT_RDONLY) && !(flags & SB_RDONLY)) {
+ 		error = xfs_remount_rw(mp);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/* rw -> ro */
+ 	if (!(mp->m_flags & XFS_MOUNT_RDONLY) && (flags & SB_RDONLY)) {
+ 		error = xfs_remount_ro(mp);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void xfs_fc_free(
+ 	struct fs_context	*fc)
+ {
+ 	struct xfs_mount	*mp = fc->s_fs_info;
+ 
+ 	/*
+ 	 * mp is stored in the fs_context when it is initialized.
+ 	 * mp is transferred to the superblock on a successful mount,
+ 	 * but if an error occurs before the transfer we have to free
+ 	 * it here.
+ 	 */
+ 	if (mp)
+ 		xfs_mount_free(mp);
+ }
+ 
+ static const struct fs_context_operations xfs_context_ops = {
+ 	.parse_param = xfs_fc_parse_param,
+ 	.get_tree    = xfs_fc_get_tree,
+ 	.reconfigure = xfs_fc_reconfigure,
+ 	.free        = xfs_fc_free,
+ };
+ 
+ static int xfs_init_fs_context(
+ 	struct fs_context	*fc)
+ {
+ 	struct xfs_mount	*mp;
+ 
+ 	mp = xfs_mount_alloc();
+ 	if (!mp)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * These can be overridden by the mount option parsing.
+ 	 */
+ 	mp->m_logbufs = -1;
+ 	mp->m_logbsize = -1;
+ 	mp->m_allocsize_log = 16; /* 64k */
+ 
+ 	/*
+ 	 * Copy binary VFS mount flags we are interested in.
+ 	 */
+ 	if (fc->sb_flags & SB_RDONLY)
+ 		mp->m_flags |= XFS_MOUNT_RDONLY;
+ 	if (fc->sb_flags & SB_DIRSYNC)
+ 		mp->m_flags |= XFS_MOUNT_DIRSYNC;
+ 	if (fc->sb_flags & SB_SYNCHRONOUS)
+ 		mp->m_flags |= XFS_MOUNT_WSYNC;
+ 
+ 	fc->s_fs_info = mp;
+ 	fc->ops = &xfs_context_ops;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 2f8d66b3cd79 (xfs: move xfs_fc_get_tree() above xfs_fc_reconfigure())
  static struct file_system_type xfs_fs_type = {
  	.owner			= THIS_MODULE,
  	.name			= "xfs",
* Unmerged path fs/xfs/xfs_super.c
