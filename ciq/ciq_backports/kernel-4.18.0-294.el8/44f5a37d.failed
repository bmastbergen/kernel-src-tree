scsi: qla2xxx: Fix buffer-buffer credit extraction error

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Quinn Tran <qutran@marvell.com>
commit 44f5a37d1e3e4e392412318666f8477601ae3024
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/44f5a37d.failed

Current code uses wrong mailbox option to extract bbc from firmware. This
field is nested inside of PLOGI payload.  Extract bbc from PLOGI template
payload.

Link: https://lore.kernel.org/r/20200929102152.32278-3-njavali@marvell.com
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Signed-off-by: Quinn Tran <qutran@marvell.com>
	Signed-off-by: Nilesh Javali <njavali@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 44f5a37d1e3e4e392412318666f8477601ae3024)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 6c0553957232,c1580eec6b27..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -4859,42 -4912,68 +4859,107 @@@ qla24xx_get_port_login_templ(scsi_qla_h
  	return rval;
  }
  
++<<<<<<< HEAD
 +int
 +qla24xx_get_buffer_credits(scsi_qla_host_t *vha, struct buffer_credit_24xx *bbc,
 +	dma_addr_t bbc_dma)
 +{
 +	mbx_cmd_t mc;
 +	mbx_cmd_t *mcp = &mc;
 +	int rval;
 +
 +	if (!IS_FWI2_CAPABLE(vha->hw))
 +		return QLA_FUNCTION_FAILED;
 +
 +	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118e,
 +	    "Entered %s.\n", __func__);
 +
 +	mcp->mb[0] = MBC_GET_RNID_PARAMS;
 +	mcp->mb[1] = RNID_BUFFER_CREDITS << 8;
 +	mcp->mb[2] = MSW(LSD(bbc_dma));
 +	mcp->mb[3] = LSW(LSD(bbc_dma));
 +	mcp->mb[6] = MSW(MSD(bbc_dma));
 +	mcp->mb[7] = LSW(MSD(bbc_dma));
 +	mcp->mb[8] = sizeof(*bbc) / sizeof(*bbc->parameter);
 +	mcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
 +	mcp->in_mb = MBX_1|MBX_0;
 +	mcp->buf_size = sizeof(*bbc);
 +	mcp->flags = MBX_DMA_IN;
 +	mcp->tov = MBX_TOV_SECONDS;
 +	rval = qla2x00_mailbox_command(vha, mcp);
 +
 +	if (rval != QLA_SUCCESS) {
 +		ql_dbg(ql_dbg_mbx, vha, 0x118f,
 +		    "Failed=%x mb[0]=%x,%x.\n", rval, mcp->mb[0], mcp->mb[1]);
 +	} else {
 +		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1190,
 +		    "Done %s.\n", __func__);
 +	}
 +
++=======
+ #define PUREX_CMD_COUNT	2
+ int
+ qla25xx_set_els_cmds_supported(scsi_qla_host_t *vha)
+ {
+ 	int rval;
+ 	mbx_cmd_t mc;
+ 	mbx_cmd_t *mcp = &mc;
+ 	uint8_t *els_cmd_map;
+ 	dma_addr_t els_cmd_map_dma;
+ 	uint8_t cmd_opcode[PUREX_CMD_COUNT];
+ 	uint8_t i, index, purex_bit;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!IS_QLA25XX(ha) && !IS_QLA2031(ha) &&
+ 	    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))
+ 		return QLA_SUCCESS;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1197,
+ 	    "Entered %s.\n", __func__);
+ 
+ 	els_cmd_map = dma_alloc_coherent(&ha->pdev->dev, ELS_CMD_MAP_SIZE,
+ 	    &els_cmd_map_dma, GFP_KERNEL);
+ 	if (!els_cmd_map) {
+ 		ql_log(ql_log_warn, vha, 0x7101,
+ 		    "Failed to allocate RDP els command param.\n");
+ 		return QLA_MEMORY_ALLOC_FAILED;
+ 	}
+ 
+ 	/* List of Purex ELS */
+ 	cmd_opcode[0] = ELS_FPIN;
+ 	cmd_opcode[1] = ELS_RDP;
+ 
+ 	for (i = 0; i < PUREX_CMD_COUNT; i++) {
+ 		index = cmd_opcode[i] / 8;
+ 		purex_bit = cmd_opcode[i] % 8;
+ 		els_cmd_map[index] |= 1 << purex_bit;
+ 	}
+ 
+ 	mcp->mb[0] = MBC_SET_RNID_PARAMS;
+ 	mcp->mb[1] = RNID_TYPE_ELS_CMD << 8;
+ 	mcp->mb[2] = MSW(LSD(els_cmd_map_dma));
+ 	mcp->mb[3] = LSW(LSD(els_cmd_map_dma));
+ 	mcp->mb[6] = MSW(MSD(els_cmd_map_dma));
+ 	mcp->mb[7] = LSW(MSD(els_cmd_map_dma));
+ 	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_1|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = MBX_DMA_OUT;
+ 	mcp->buf_size = ELS_CMD_MAP_SIZE;
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x118d,
+ 		    "Failed=%x (%x,%x).\n", rval, mcp->mb[0], mcp->mb[1]);
+ 	} else {
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118c,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	dma_free_coherent(&ha->pdev->dev, ELS_CMD_MAP_SIZE,
+ 	   els_cmd_map, els_cmd_map_dma);
+ 
++>>>>>>> 44f5a37d1e3e (scsi: qla2xxx: Fix buffer-buffer credit extraction error)
  	return rval;
  }
  
diff --cc drivers/scsi/qla2xxx/qla_os.c
index e7ddfc48259e,9d6292928c32..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -5595,6 -5772,492 +5595,495 @@@ retry_lock
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ qla25xx_rdp_rsp_reduce_size(struct scsi_qla_host *vha,
+ 	struct purex_entry_24xx *purex)
+ {
+ 	char fwstr[16];
+ 	u32 sid = purex->s_id[2] << 16 | purex->s_id[1] << 8 | purex->s_id[0];
+ 	struct port_database_24xx *pdb;
+ 
+ 	/* Domain Controller is always logged-out. */
+ 	/* if RDP request is not from Domain Controller: */
+ 	if (sid != 0xfffc01)
+ 		return false;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0181, "%s: s_id=%#x\n", __func__, sid);
+ 
+ 	pdb = kzalloc(sizeof(*pdb), GFP_KERNEL);
+ 	if (!pdb) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Failed allocate pdb\n", __func__);
+ 	} else if (qla24xx_get_port_database(vha,
+ 				le16_to_cpu(purex->nport_handle), pdb)) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Failed get pdb sid=%x\n", __func__, sid);
+ 	} else if (pdb->current_login_state != PDS_PLOGI_COMPLETE &&
+ 	    pdb->current_login_state != PDS_PRLI_COMPLETE) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Port not logged in sid=%#x\n", __func__, sid);
+ 	} else {
+ 		/* RDP request is from logged in port */
+ 		kfree(pdb);
+ 		return false;
+ 	}
+ 	kfree(pdb);
+ 
+ 	vha->hw->isp_ops->fw_version_str(vha, fwstr, sizeof(fwstr));
+ 	fwstr[strcspn(fwstr, " ")] = 0;
+ 	/* if FW version allows RDP response length upto 2048 bytes: */
+ 	if (strcmp(fwstr, "8.09.00") > 0 || strcmp(fwstr, "8.05.65") == 0)
+ 		return false;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0181, "%s: fw=%s\n", __func__, fwstr);
+ 
+ 	/* RDP response length is to be reduced to maximum 256 bytes */
+ 	return true;
+ }
+ 
+ /*
+  * Function Name: qla24xx_process_purex_iocb
+  *
+  * Description:
+  * Prepare a RDP response and send to Fabric switch
+  *
+  * PARAMETERS:
+  * vha:	SCSI qla host
+  * purex: RDP request received by HBA
+  */
+ void qla24xx_process_purex_rdp(struct scsi_qla_host *vha,
+ 			       struct purex_item *item)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct purex_entry_24xx *purex =
+ 	    (struct purex_entry_24xx *)&item->iocb;
+ 	dma_addr_t rsp_els_dma;
+ 	dma_addr_t rsp_payload_dma;
+ 	dma_addr_t stat_dma;
+ 	dma_addr_t sfp_dma;
+ 	struct els_entry_24xx *rsp_els = NULL;
+ 	struct rdp_rsp_payload *rsp_payload = NULL;
+ 	struct link_statistics *stat = NULL;
+ 	uint8_t *sfp = NULL;
+ 	uint16_t sfp_flags = 0;
+ 	uint rsp_payload_length = sizeof(*rsp_payload);
+ 	int rval;
+ 
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0180,
+ 	    "%s: Enter\n", __func__);
+ 
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0181,
+ 	    "-------- ELS REQ -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0182,
+ 	    purex, sizeof(*purex));
+ 
+ 	if (qla25xx_rdp_rsp_reduce_size(vha, purex)) {
+ 		rsp_payload_length =
+ 		    offsetof(typeof(*rsp_payload), optical_elmt_desc);
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "Reducing RSP payload length to %u bytes...\n",
+ 		    rsp_payload_length);
+ 	}
+ 
+ 	rsp_els = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_els),
+ 	    &rsp_els_dma, GFP_KERNEL);
+ 	if (!rsp_els) {
+ 		ql_log(ql_log_warn, vha, 0x0183,
+ 		    "Failed allocate dma buffer ELS RSP.\n");
+ 		goto dealloc;
+ 	}
+ 
+ 	rsp_payload = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_payload),
+ 	    &rsp_payload_dma, GFP_KERNEL);
+ 	if (!rsp_payload) {
+ 		ql_log(ql_log_warn, vha, 0x0184,
+ 		    "Failed allocate dma buffer ELS RSP payload.\n");
+ 		goto dealloc;
+ 	}
+ 
+ 	sfp = dma_alloc_coherent(&ha->pdev->dev, SFP_RTDI_LEN,
+ 	    &sfp_dma, GFP_KERNEL);
+ 
+ 	stat = dma_alloc_coherent(&ha->pdev->dev, sizeof(*stat),
+ 	    &stat_dma, GFP_KERNEL);
+ 
+ 	/* Prepare Response IOCB */
+ 	rsp_els->entry_type = ELS_IOCB_TYPE;
+ 	rsp_els->entry_count = 1;
+ 	rsp_els->sys_define = 0;
+ 	rsp_els->entry_status = 0;
+ 	rsp_els->handle = 0;
+ 	rsp_els->nport_handle = purex->nport_handle;
+ 	rsp_els->tx_dsd_count = cpu_to_le16(1);
+ 	rsp_els->vp_index = purex->vp_idx;
+ 	rsp_els->sof_type = EST_SOFI3;
+ 	rsp_els->rx_xchg_address = purex->rx_xchg_addr;
+ 	rsp_els->rx_dsd_count = 0;
+ 	rsp_els->opcode = purex->els_frame_payload[0];
+ 
+ 	rsp_els->d_id[0] = purex->s_id[0];
+ 	rsp_els->d_id[1] = purex->s_id[1];
+ 	rsp_els->d_id[2] = purex->s_id[2];
+ 
+ 	rsp_els->control_flags = cpu_to_le16(EPD_ELS_ACC);
+ 	rsp_els->rx_byte_count = 0;
+ 	rsp_els->tx_byte_count = cpu_to_le32(rsp_payload_length);
+ 
+ 	put_unaligned_le64(rsp_payload_dma, &rsp_els->tx_address);
+ 	rsp_els->tx_len = rsp_els->tx_byte_count;
+ 
+ 	rsp_els->rx_address = 0;
+ 	rsp_els->rx_len = 0;
+ 
+ 	/* Prepare Response Payload */
+ 	rsp_payload->hdr.cmd = cpu_to_be32(0x2 << 24); /* LS_ACC */
+ 	rsp_payload->hdr.len = cpu_to_be32(le32_to_cpu(rsp_els->tx_byte_count) -
+ 					   sizeof(rsp_payload->hdr));
+ 
+ 	/* Link service Request Info Descriptor */
+ 	rsp_payload->ls_req_info_desc.desc_tag = cpu_to_be32(0x1);
+ 	rsp_payload->ls_req_info_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc));
+ 	rsp_payload->ls_req_info_desc.req_payload_word_0 =
+ 	    cpu_to_be32p((uint32_t *)purex->els_frame_payload);
+ 
+ 	/* Link service Request Info Descriptor 2 */
+ 	rsp_payload->ls_req_info_desc2.desc_tag = cpu_to_be32(0x1);
+ 	rsp_payload->ls_req_info_desc2.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc2));
+ 	rsp_payload->ls_req_info_desc2.req_payload_word_0 =
+ 	    cpu_to_be32p((uint32_t *)purex->els_frame_payload);
+ 
+ 
+ 	rsp_payload->sfp_diag_desc.desc_tag = cpu_to_be32(0x10000);
+ 	rsp_payload->sfp_diag_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->sfp_diag_desc));
+ 
+ 	if (sfp) {
+ 		/* SFP Flags */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x7, 2, 0);
+ 		if (!rval) {
+ 			/* SFP Flags bits 3-0: Port Tx Laser Type */
+ 			if (sfp[0] & BIT_2 || sfp[1] & (BIT_6|BIT_5))
+ 				sfp_flags |= BIT_0; /* short wave */
+ 			else if (sfp[0] & BIT_1)
+ 				sfp_flags |= BIT_1; /* long wave 1310nm */
+ 			else if (sfp[1] & BIT_4)
+ 				sfp_flags |= BIT_1|BIT_0; /* long wave 1550nm */
+ 		}
+ 
+ 		/* SFP Type */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x0, 1, 0);
+ 		if (!rval) {
+ 			sfp_flags |= BIT_4; /* optical */
+ 			if (sfp[0] == 0x3)
+ 				sfp_flags |= BIT_6; /* sfp+ */
+ 		}
+ 
+ 		rsp_payload->sfp_diag_desc.sfp_flags = cpu_to_be16(sfp_flags);
+ 
+ 		/* SFP Diagnostics */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0x60, 10, 0);
+ 		if (!rval) {
+ 			__be16 *trx = (__force __be16 *)sfp; /* already be16 */
+ 			rsp_payload->sfp_diag_desc.temperature = trx[0];
+ 			rsp_payload->sfp_diag_desc.vcc = trx[1];
+ 			rsp_payload->sfp_diag_desc.tx_bias = trx[2];
+ 			rsp_payload->sfp_diag_desc.tx_power = trx[3];
+ 			rsp_payload->sfp_diag_desc.rx_power = trx[4];
+ 		}
+ 	}
+ 
+ 	/* Port Speed Descriptor */
+ 	rsp_payload->port_speed_desc.desc_tag = cpu_to_be32(0x10001);
+ 	rsp_payload->port_speed_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_speed_desc));
+ 	rsp_payload->port_speed_desc.speed_capab = cpu_to_be16(
+ 	    qla25xx_fdmi_port_speed_capability(ha));
+ 	rsp_payload->port_speed_desc.operating_speed = cpu_to_be16(
+ 	    qla25xx_fdmi_port_speed_currently(ha));
+ 
+ 	/* Link Error Status Descriptor */
+ 	rsp_payload->ls_err_desc.desc_tag = cpu_to_be32(0x10002);
+ 	rsp_payload->ls_err_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_err_desc));
+ 
+ 	if (stat) {
+ 		rval = qla24xx_get_isp_stats(vha, stat, stat_dma, 0);
+ 		if (!rval) {
+ 			rsp_payload->ls_err_desc.link_fail_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->link_fail_cnt));
+ 			rsp_payload->ls_err_desc.loss_sync_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->loss_sync_cnt));
+ 			rsp_payload->ls_err_desc.loss_sig_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->loss_sig_cnt));
+ 			rsp_payload->ls_err_desc.prim_seq_err_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->prim_seq_err_cnt));
+ 			rsp_payload->ls_err_desc.inval_xmit_word_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->inval_xmit_word_cnt));
+ 			rsp_payload->ls_err_desc.inval_crc_cnt =
+ 			    cpu_to_be32(le32_to_cpu(stat->inval_crc_cnt));
+ 			rsp_payload->ls_err_desc.pn_port_phy_type |= BIT_6;
+ 		}
+ 	}
+ 
+ 	/* Portname Descriptor */
+ 	rsp_payload->port_name_diag_desc.desc_tag = cpu_to_be32(0x10003);
+ 	rsp_payload->port_name_diag_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_diag_desc));
+ 	memcpy(rsp_payload->port_name_diag_desc.WWNN,
+ 	    vha->node_name,
+ 	    sizeof(rsp_payload->port_name_diag_desc.WWNN));
+ 	memcpy(rsp_payload->port_name_diag_desc.WWPN,
+ 	    vha->port_name,
+ 	    sizeof(rsp_payload->port_name_diag_desc.WWPN));
+ 
+ 	/* F-Port Portname Descriptor */
+ 	rsp_payload->port_name_direct_desc.desc_tag = cpu_to_be32(0x10003);
+ 	rsp_payload->port_name_direct_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_direct_desc));
+ 	memcpy(rsp_payload->port_name_direct_desc.WWNN,
+ 	    vha->fabric_node_name,
+ 	    sizeof(rsp_payload->port_name_direct_desc.WWNN));
+ 	memcpy(rsp_payload->port_name_direct_desc.WWPN,
+ 	    vha->fabric_port_name,
+ 	    sizeof(rsp_payload->port_name_direct_desc.WWPN));
+ 
+ 	/* Bufer Credit Descriptor */
+ 	rsp_payload->buffer_credit_desc.desc_tag = cpu_to_be32(0x10006);
+ 	rsp_payload->buffer_credit_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->buffer_credit_desc));
+ 	rsp_payload->buffer_credit_desc.fcport_b2b = 0;
+ 	rsp_payload->buffer_credit_desc.attached_fcport_b2b = cpu_to_be32(0);
+ 	rsp_payload->buffer_credit_desc.fcport_rtt = cpu_to_be32(0);
+ 
+ 	if (ha->flags.plogi_template_valid) {
+ 		uint32_t tmp =
+ 		be16_to_cpu(ha->plogi_els_payld.fl_csp.sp_bb_cred);
+ 		rsp_payload->buffer_credit_desc.fcport_b2b = cpu_to_be32(tmp);
+ 	}
+ 
+ 	if (rsp_payload_length < sizeof(*rsp_payload))
+ 		goto send;
+ 
+ 	/* Optical Element Descriptor, Temperature */
+ 	rsp_payload->optical_elmt_desc[0].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[0].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Voltage */
+ 	rsp_payload->optical_elmt_desc[1].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[1].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Tx Bias Current */
+ 	rsp_payload->optical_elmt_desc[2].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[2].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Tx Power */
+ 	rsp_payload->optical_elmt_desc[3].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[3].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Rx Power */
+ 	rsp_payload->optical_elmt_desc[4].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[4].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 
+ 	if (sfp) {
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0, 64, 0);
+ 		if (!rval) {
+ 			__be16 *trx = (__force __be16 *)sfp; /* already be16 */
+ 
+ 			/* Optical Element Descriptor, Temperature */
+ 			rsp_payload->optical_elmt_desc[0].high_alarm = trx[0];
+ 			rsp_payload->optical_elmt_desc[0].low_alarm = trx[1];
+ 			rsp_payload->optical_elmt_desc[0].high_warn = trx[2];
+ 			rsp_payload->optical_elmt_desc[0].low_warn = trx[3];
+ 			rsp_payload->optical_elmt_desc[0].element_flags =
+ 			    cpu_to_be32(1 << 28);
+ 
+ 			/* Optical Element Descriptor, Voltage */
+ 			rsp_payload->optical_elmt_desc[1].high_alarm = trx[4];
+ 			rsp_payload->optical_elmt_desc[1].low_alarm = trx[5];
+ 			rsp_payload->optical_elmt_desc[1].high_warn = trx[6];
+ 			rsp_payload->optical_elmt_desc[1].low_warn = trx[7];
+ 			rsp_payload->optical_elmt_desc[1].element_flags =
+ 			    cpu_to_be32(2 << 28);
+ 
+ 			/* Optical Element Descriptor, Tx Bias Current */
+ 			rsp_payload->optical_elmt_desc[2].high_alarm = trx[8];
+ 			rsp_payload->optical_elmt_desc[2].low_alarm = trx[9];
+ 			rsp_payload->optical_elmt_desc[2].high_warn = trx[10];
+ 			rsp_payload->optical_elmt_desc[2].low_warn = trx[11];
+ 			rsp_payload->optical_elmt_desc[2].element_flags =
+ 			    cpu_to_be32(3 << 28);
+ 
+ 			/* Optical Element Descriptor, Tx Power */
+ 			rsp_payload->optical_elmt_desc[3].high_alarm = trx[12];
+ 			rsp_payload->optical_elmt_desc[3].low_alarm = trx[13];
+ 			rsp_payload->optical_elmt_desc[3].high_warn = trx[14];
+ 			rsp_payload->optical_elmt_desc[3].low_warn = trx[15];
+ 			rsp_payload->optical_elmt_desc[3].element_flags =
+ 			    cpu_to_be32(4 << 28);
+ 
+ 			/* Optical Element Descriptor, Rx Power */
+ 			rsp_payload->optical_elmt_desc[4].high_alarm = trx[16];
+ 			rsp_payload->optical_elmt_desc[4].low_alarm = trx[17];
+ 			rsp_payload->optical_elmt_desc[4].high_warn = trx[18];
+ 			rsp_payload->optical_elmt_desc[4].low_warn = trx[19];
+ 			rsp_payload->optical_elmt_desc[4].element_flags =
+ 			    cpu_to_be32(5 << 28);
+ 		}
+ 
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 112, 64, 0);
+ 		if (!rval) {
+ 			/* Temperature high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[0].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 7 & 1) << 3 |
+ 				(sfp[0] >> 6 & 1) << 2 |
+ 				(sfp[4] >> 7 & 1) << 1 |
+ 				(sfp[4] >> 6 & 1) << 0);
+ 
+ 			/* Voltage high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[1].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 5 & 1) << 3 |
+ 				(sfp[0] >> 4 & 1) << 2 |
+ 				(sfp[4] >> 5 & 1) << 1 |
+ 				(sfp[4] >> 4 & 1) << 0);
+ 
+ 			/* Tx Bias Current high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[2].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 3 & 1) << 3 |
+ 				(sfp[0] >> 2 & 1) << 2 |
+ 				(sfp[4] >> 3 & 1) << 1 |
+ 				(sfp[4] >> 2 & 1) << 0);
+ 
+ 			/* Tx Power high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[3].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 1 & 1) << 3 |
+ 				(sfp[0] >> 0 & 1) << 2 |
+ 				(sfp[4] >> 1 & 1) << 1 |
+ 				(sfp[4] >> 0 & 1) << 0);
+ 
+ 			/* Rx Power high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[4].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[1] >> 7 & 1) << 3 |
+ 				(sfp[1] >> 6 & 1) << 2 |
+ 				(sfp[5] >> 7 & 1) << 1 |
+ 				(sfp[5] >> 6 & 1) << 0);
+ 		}
+ 	}
+ 
+ 	/* Optical Product Data Descriptor */
+ 	rsp_payload->optical_prod_desc.desc_tag = cpu_to_be32(0x10008);
+ 	rsp_payload->optical_prod_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->optical_prod_desc));
+ 
+ 	if (sfp) {
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 20, 64, 0);
+ 		if (!rval) {
+ 			memcpy(rsp_payload->optical_prod_desc.vendor_name,
+ 			    sfp + 0,
+ 			    sizeof(rsp_payload->optical_prod_desc.vendor_name));
+ 			memcpy(rsp_payload->optical_prod_desc.part_number,
+ 			    sfp + 20,
+ 			    sizeof(rsp_payload->optical_prod_desc.part_number));
+ 			memcpy(rsp_payload->optical_prod_desc.revision,
+ 			    sfp + 36,
+ 			    sizeof(rsp_payload->optical_prod_desc.revision));
+ 			memcpy(rsp_payload->optical_prod_desc.serial_number,
+ 			    sfp + 48,
+ 			    sizeof(rsp_payload->optical_prod_desc.serial_number));
+ 		}
+ 
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 84, 8, 0);
+ 		if (!rval) {
+ 			memcpy(rsp_payload->optical_prod_desc.date,
+ 			    sfp + 0,
+ 			    sizeof(rsp_payload->optical_prod_desc.date));
+ 		}
+ 	}
+ 
+ send:
+ 	ql_dbg(ql_dbg_init, vha, 0x0183,
+ 	    "Sending ELS Response to RDP Request...\n");
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0184,
+ 	    "-------- ELS RSP -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0185,
+ 	    rsp_els, sizeof(*rsp_els));
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0186,
+ 	    "-------- ELS RSP PAYLOAD -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0187,
+ 	    rsp_payload, rsp_payload_length);
+ 
+ 	rval = qla2x00_issue_iocb(vha, rsp_els, rsp_els_dma, 0);
+ 
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x0188,
+ 		    "%s: iocb failed to execute -> %x\n", __func__, rval);
+ 	} else if (rsp_els->comp_status) {
+ 		ql_log(ql_log_warn, vha, 0x0189,
+ 		    "%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\n",
+ 		    __func__, rsp_els->comp_status,
+ 		    rsp_els->error_subcode_1, rsp_els->error_subcode_2);
+ 	} else {
+ 		ql_dbg(ql_dbg_init, vha, 0x018a, "%s: done.\n", __func__);
+ 	}
+ 
+ dealloc:
+ 	if (stat)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*stat),
+ 		    stat, stat_dma);
+ 	if (sfp)
+ 		dma_free_coherent(&ha->pdev->dev, SFP_RTDI_LEN,
+ 		    sfp, sfp_dma);
+ 	if (rsp_payload)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_payload),
+ 		    rsp_payload, rsp_payload_dma);
+ 	if (rsp_els)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_els),
+ 		    rsp_els, rsp_els_dma);
+ }
+ 
+ void
+ qla24xx_free_purex_item(struct purex_item *item)
+ {
+ 	if (item == &item->vha->default_item)
+ 		memset(&item->vha->default_item, 0, sizeof(struct purex_item));
+ 	else
+ 		kfree(item);
+ }
+ 
+ void qla24xx_process_purex_list(struct purex_list *list)
+ {
+ 	struct list_head head = LIST_HEAD_INIT(head);
+ 	struct purex_item *item, *next;
+ 	ulong flags;
+ 
+ 	spin_lock_irqsave(&list->lock, flags);
+ 	list_splice_init(&list->head, &head);
+ 	spin_unlock_irqrestore(&list->lock, flags);
+ 
+ 	list_for_each_entry_safe(item, next, &head, list) {
+ 		list_del(&item->list);
+ 		item->process_item(item->vha, item);
+ 		qla24xx_free_purex_item(item);
+ 	}
+ }
+ 
++>>>>>>> 44f5a37d1e3e (scsi: qla2xxx: Fix buffer-buffer credit extraction error)
  void
  qla83xx_idc_unlock(scsi_qla_host_t *base_vha, uint16_t requester_id)
  {
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index ecba6f991af8..69eb62dadaec 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -3723,6 +3723,7 @@ struct qla_hw_data {
 		uint32_t	secure_adapter:1;
 		uint32_t	secure_fw:1;
 		uint32_t	max_req_queue_warned:1;
+		uint32_t	plogi_template_valid:1;
 	} flags;
 
 	uint16_t max_exchg;
@@ -4058,7 +4059,8 @@ struct qla_hw_data {
 	int 		exchoffld_count;
 
 	/* n2n */
-	struct els_plogi_payload plogi_els_payld;
+	struct fc_els_flogi plogi_els_payld;
+#define LOGIN_TEMPLATE_SIZE (sizeof(struct fc_els_flogi) - 4)
 
 	void            *swl;
 
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index 9920f8721dbd..2a4720d37137 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -4968,6 +4968,29 @@ qla2x00_free_fcport(fc_port_t *fcport)
 	kfree(fcport);
 }
 
+static void qla_get_login_template(scsi_qla_host_t *vha)
+{
+	struct qla_hw_data *ha = vha->hw;
+	int rval;
+	u32 *bp, sz;
+	__be32 *q;
+
+	memset(ha->init_cb, 0, ha->init_cb_size);
+	sz = min_t(int, sizeof(struct fc_els_flogi), ha->init_cb_size);
+	rval = qla24xx_get_port_login_templ(vha, ha->init_cb_dma,
+					    ha->init_cb, sz);
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_init, vha, 0x00d1,
+		       "PLOGI ELS param read fail.\n");
+		return;
+	}
+	q = (__be32 *)&ha->plogi_els_payld.fl_csp;
+
+	bp = (uint32_t *)ha->init_cb;
+	cpu_to_be32_array(q, bp, sz / 4);
+	ha->flags.plogi_template_valid = 1;
+}
+
 /*
  * qla2x00_configure_loop
  *      Updates Fibre Channel Device Database with what is actually on loop.
@@ -5011,6 +5034,7 @@ qla2x00_configure_loop(scsi_qla_host_t *vha)
 	clear_bit(RSCN_UPDATE, &vha->dpc_flags);
 
 	qla2x00_get_data_rate(vha);
+	qla_get_login_template(vha);
 
 	/* Determine what we need to do */
 	if ((ha->current_topology == ISP_CFG_FL ||
@@ -5095,32 +5119,11 @@ qla2x00_configure_loop(scsi_qla_host_t *vha)
 
 static int qla2x00_configure_n2n_loop(scsi_qla_host_t *vha)
 {
-	struct qla_hw_data *ha = vha->hw;
 	unsigned long flags;
 	fc_port_t *fcport;
-	int rval;
-
-	if (test_and_clear_bit(N2N_LOGIN_NEEDED, &vha->dpc_flags)) {
-		/* borrowing */
-		u32 *bp, sz;
-
-		memset(ha->init_cb, 0, ha->init_cb_size);
-		sz = min_t(int, sizeof(struct els_plogi_payload),
-			   ha->init_cb_size);
-		rval = qla24xx_get_port_login_templ(vha, ha->init_cb_dma,
-						    ha->init_cb, sz);
-		if (rval == QLA_SUCCESS) {
-			__be32 *q = &ha->plogi_els_payld.data[0];
 
-			bp = (uint32_t *)ha->init_cb;
-			cpu_to_be32_array(q, bp, sz / 4);
-			memcpy(bp, q, sizeof(ha->plogi_els_payld.data));
-		} else {
-			ql_dbg(ql_dbg_init, vha, 0x00d1,
-			       "PLOGI ELS param read fail.\n");
-			goto skip_login;
-		}
-	}
+	if (test_and_clear_bit(N2N_LOGIN_NEEDED, &vha->dpc_flags))
+		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
 
 	list_for_each_entry(fcport, &vha->vp_fcports, list) {
 		if (fcport->n2n_flag) {
@@ -5129,7 +5132,6 @@ static int qla2x00_configure_n2n_loop(scsi_qla_host_t *vha)
 		}
 	}
 
-skip_login:
 	spin_lock_irqsave(&vha->work_lock, flags);
 	vha->scan.scan_retry++;
 	spin_unlock_irqrestore(&vha->work_lock, flags);
diff --git a/drivers/scsi/qla2xxx/qla_iocb.c b/drivers/scsi/qla2xxx/qla_iocb.c
index cf655f3a6e69..dba06e9ae89d 100644
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@ -2972,8 +2972,7 @@ qla24xx_els_dcmd2_iocb(scsi_qla_host_t *vha, int els_opcode,
 	memset(ptr, 0, sizeof(struct els_plogi_payload));
 	memset(resp_ptr, 0, sizeof(struct els_plogi_payload));
 	memcpy(elsio->u.els_plogi.els_plogi_pyld->data,
-	    &ha->plogi_els_payld.data,
-	    sizeof(elsio->u.els_plogi.els_plogi_pyld->data));
+	    &ha->plogi_els_payld.fl_csp, LOGIN_TEMPLATE_SIZE);
 
 	elsio->u.els_plogi.els_cmd = els_opcode;
 	elsio->u.els_plogi.els_plogi_pyld->opcode = els_opcode;
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
