xfs: convert open coded corruption check to use XFS_IS_CORRUPT

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit a71895c5dad1ab8cf30622e208d148298ab602e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a71895c5.failed

Convert the last of the open coded corruption check and report idioms to
use the XFS_IS_CORRUPT macro.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit a71895c5dad1ab8cf30622e208d148298ab602e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc.c
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_btree.c
#	fs/xfs/libxfs/xfs_da_btree.c
#	fs/xfs/libxfs/xfs_dir2.c
#	fs/xfs/libxfs/xfs_refcount.c
#	fs/xfs/libxfs/xfs_rtbitmap.c
#	fs/xfs/xfs_attr_list.c
#	fs/xfs/xfs_iomap.c
#	fs/xfs/xfs_iops.c
#	fs/xfs/xfs_qm.c
diff --cc fs/xfs/libxfs/xfs_alloc.c
index 51a7998a4aba,c284e10af491..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -1069,7 -1071,7 +1069,11 @@@ xfs_alloc_ag_vextent_small
  		struct xfs_buf	*bp;
  
  		bp = xfs_btree_get_bufs(args->mp, args->tp, args->agno, fbno);
++<<<<<<< HEAD
 +		if (!bp) {
++=======
+ 		if (XFS_IS_CORRUPT(args->mp, !bp)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  			error = -EFSCORRUPTED;
  			goto error;
  		}
@@@ -2346,7 -2340,7 +2350,11 @@@ xfs_free_agfl_block
  		return error;
  
  	bp = xfs_btree_get_bufs(tp->t_mountp, tp, agno, agbno);
++<<<<<<< HEAD
 +	if (!bp)
++=======
+ 	if (XFS_IS_CORRUPT(tp->t_mountp, !bp))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  	xfs_trans_binval(tp, bp);
  
diff --cc fs/xfs/libxfs/xfs_bmap.c
index fe351a82a000,4acc6e37c31d..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -731,7 -731,7 +731,11 @@@ xfs_bmap_extents_to_btree
  	ip->i_d.di_nblocks++;
  	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);
  	abp = xfs_btree_get_bufl(mp, tp, args.fsbno);
++<<<<<<< HEAD
 +	if (!abp) {
++=======
+ 	if (XFS_IS_CORRUPT(mp, !abp)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		error = -EFSCORRUPTED;
  		goto out_unreserve_dquot;
  	}
@@@ -1089,7 -1089,7 +1093,11 @@@ xfs_bmap_add_attrfork
  		goto trans_cancel;
  	if (XFS_IFORK_Q(ip))
  		goto trans_cancel;
++<<<<<<< HEAD
 +	if (ip->i_d.di_anextents != 0) {
++=======
+ 	if (XFS_IS_CORRUPT(mp, ip->i_d.di_anextents != 0)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		error = -EFSCORRUPTED;
  		goto trans_cancel;
  	}
@@@ -1442,9 -1443,8 +1451,14 @@@ xfs_bmap_last_offset
  	if (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)
  		return 0;
  
++<<<<<<< HEAD
 +	if (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&
 +	    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)
 +	       return -EIO;
++=======
+ 	if (XFS_IS_CORRUPT(ip->i_mount, !xfs_ifork_has_extents(ip, whichfork)))
+ 		return -EFSCORRUPTED;
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  
  	error = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);
  	if (error || is_empty)
@@@ -3903,11 -3903,8 +3917,16 @@@ xfs_bmapi_read
  			   XFS_BMAPI_COWFORK)));
  	ASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));
  
++<<<<<<< HEAD
 +	if (unlikely(XFS_TEST_ERROR(
 +	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
 +	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
 +	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
 +		XFS_ERROR_REPORT("xfs_bmapi_read", XFS_ERRLEVEL_LOW, mp);
++=======
+ 	if (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ip, whichfork)) ||
+ 	    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  	}
  
@@@ -4415,11 -4412,8 +4434,16 @@@ xfs_bmapi_write
  	ASSERT((flags & (XFS_BMAPI_PREALLOC | XFS_BMAPI_ZERO)) !=
  			(XFS_BMAPI_PREALLOC | XFS_BMAPI_ZERO));
  
++<<<<<<< HEAD
 +	if (unlikely(XFS_TEST_ERROR(
 +	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
 +	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
 +	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
 +		XFS_ERROR_REPORT("xfs_bmapi_write", XFS_ERRLEVEL_LOW, mp);
++=======
+ 	if (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ip, whichfork)) ||
+ 	    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  	}
  
@@@ -4686,11 -4679,8 +4710,16 @@@ xfs_bmapi_remap
  	ASSERT((flags & (XFS_BMAPI_ATTRFORK | XFS_BMAPI_PREALLOC)) !=
  			(XFS_BMAPI_ATTRFORK | XFS_BMAPI_PREALLOC));
  
++<<<<<<< HEAD
 +	if (unlikely(XFS_TEST_ERROR(
 +	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
 +	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
 +	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
 +		XFS_ERROR_REPORT("xfs_bmapi_remap", XFS_ERRLEVEL_LOW, mp);
++=======
+ 	if (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ip, whichfork)) ||
+ 	    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  	}
  
@@@ -5329,14 -5319,8 +5358,16 @@@ __xfs_bunmapi
  	whichfork = xfs_bmapi_whichfork(flags);
  	ASSERT(whichfork != XFS_COW_FORK);
  	ifp = XFS_IFORK_PTR(ip, whichfork);
++<<<<<<< HEAD
 +	if (unlikely(
 +	    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
 +	    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {
 +		XFS_ERROR_REPORT("xfs_bunmapi", XFS_ERRLEVEL_LOW,
 +				 ip->i_mount);
++=======
+ 	if (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ip, whichfork)))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
- 	}
- 	mp = ip->i_mount;
  	if (XFS_FORCED_SHUTDOWN(mp))
  		return -EIO;
  
@@@ -5829,11 -5813,8 +5860,16 @@@ xfs_bmap_collapse_extents
  	int			error = 0;
  	int			logflags = 0;
  
++<<<<<<< HEAD
 +	if (unlikely(XFS_TEST_ERROR(
 +	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
 +	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
 +	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
 +		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
++=======
+ 	if (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ip, whichfork)) ||
+ 	    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  	}
  
@@@ -5949,11 -5930,8 +5985,16 @@@ xfs_bmap_insert_extents
  	int			error = 0;
  	int			logflags = 0;
  
++<<<<<<< HEAD
 +	if (unlikely(XFS_TEST_ERROR(
 +	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
 +	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
 +	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
 +		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
++=======
+ 	if (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ip, whichfork)) ||
+ 	    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  	}
  
@@@ -5991,8 -5969,9 +6032,14 @@@
  		goto del_cursor;
  	}
  
++<<<<<<< HEAD
 +	if (stop_fsb > got.br_startoff) {
 +		error = -EIO;
++=======
+ 	if (XFS_IS_CORRUPT(mp,
+ 			   stop_fsb >= got.br_startoff + got.br_blockcount)) {
+ 		error = -EFSCORRUPTED;
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		goto del_cursor;
  	}
  
@@@ -6057,12 -6036,8 +6104,17 @@@ xfs_bmap_split_extent_at
  	int				logflags = 0;
  	int				i = 0;
  
++<<<<<<< HEAD
 +	if (unlikely(XFS_TEST_ERROR(
 +	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
 +	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
 +	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
 +		XFS_ERROR_REPORT("xfs_bmap_split_extent_at",
 +				 XFS_ERRLEVEL_LOW, mp);
++=======
+ 	if (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ip, whichfork)) ||
+ 	    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  	}
  
diff --cc fs/xfs/libxfs/xfs_btree.c
index 0f6590b7113a,8f0e3a368f38..000000000000
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@@ -1848,7 -1847,7 +1846,11 @@@ xfs_btree_lookup
  	XFS_BTREE_STATS_INC(cur, lookup);
  
  	/* No such thing as a zero-level tree. */
++<<<<<<< HEAD
 +	if (cur->bc_nlevels == 0)
++=======
+ 	if (XFS_IS_CORRUPT(cur->bc_mp, cur->bc_nlevels == 0))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  
  	block = NULL;
diff --cc fs/xfs/libxfs/xfs_da_btree.c
index 09c1541dc1d4,418189498234..000000000000
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@@ -1656,11 -1663,11 +1656,19 @@@ xfs_da3_node_lookup_int
  		}
  
  		/* We can't point back to the root. */
++<<<<<<< HEAD
 +		if (blkno == args->geo->leafblk)
 +			return -EFSCORRUPTED;
 +	}
 +
 +	if (expected_level != 0)
++=======
+ 		if (XFS_IS_CORRUPT(dp->i_mount, blkno == args->geo->leafblk))
+ 			return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_IS_CORRUPT(dp->i_mount, expected_level != 0))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  
  	/*
diff --cc fs/xfs/libxfs/xfs_dir2.c
index 34566754a60f,83cc8770f0ca..000000000000
--- a/fs/xfs/libxfs/xfs_dir2.c
+++ b/fs/xfs/libxfs/xfs_dir2.c
@@@ -617,7 -617,9 +617,13 @@@ xfs_dir2_isblock
  	if ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))
  		return rval;
  	rval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;
++<<<<<<< HEAD
 +	if (rval != 0 && args->dp->i_d.di_size != args->geo->blksize)
++=======
+ 	if (XFS_IS_CORRUPT(args->dp->i_mount,
+ 			   rval != 0 &&
+ 			   args->dp->i_d.di_size != args->geo->blksize))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  	*vp = rval;
  	return 0;
diff --cc fs/xfs/libxfs/xfs_refcount.c
index 28aacb249403,d7d702ee4d1a..000000000000
--- a/fs/xfs/libxfs/xfs_refcount.c
+++ b/fs/xfs/libxfs/xfs_refcount.c
@@@ -1668,7 -1668,8 +1668,12 @@@ xfs_refcount_recover_extent
  	struct list_head		*debris = priv;
  	struct xfs_refcount_recovery	*rr;
  
++<<<<<<< HEAD
 +	if (be32_to_cpu(rec->refc.rc_refcount) != 1)
++=======
+ 	if (XFS_IS_CORRUPT(cur->bc_mp,
+ 			   be32_to_cpu(rec->refc.rc_refcount) != 1))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  
  	rr = kmem_alloc(sizeof(struct xfs_refcount_recovery), 0);
diff --cc fs/xfs/libxfs/xfs_rtbitmap.c
index 8ea1efc97b41,f42c74cb8be5..000000000000
--- a/fs/xfs/libxfs/xfs_rtbitmap.c
+++ b/fs/xfs/libxfs/xfs_rtbitmap.c
@@@ -70,7 -70,7 +70,11 @@@ xfs_rtbuf_get
  	if (error)
  		return error;
  
++<<<<<<< HEAD
 +	if (nmap == 0 || !xfs_bmap_is_real_extent(&map))
++=======
+ 	if (XFS_IS_CORRUPT(mp, nmap == 0 || !xfs_bmap_is_real_extent(&map)))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return -EFSCORRUPTED;
  
  	ASSERT(map.br_startblock != NULLFSBLOCK);
diff --cc fs/xfs/xfs_attr_list.c
index 032920952aa2,7a099df88a0c..000000000000
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@@ -269,7 -268,7 +268,11 @@@ xfs_attr_node_list_lookup
  			return 0;
  
  		/* We can't point back to the root. */
++<<<<<<< HEAD
 +		if (cursor->blkno == 0)
++=======
+ 		if (XFS_IS_CORRUPT(mp, cursor->blkno == 0))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  			return -EFSCORRUPTED;
  	}
  
diff --cc fs/xfs/xfs_iomap.c
index 2ae36199a773,28e2d1f37267..000000000000
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@@ -525,219 -502,6 +525,224 @@@ check_writeio
  	return alloc_blocks;
  }
  
 +static int
 +xfs_file_iomap_begin_delay(
 +	struct inode		*inode,
 +	loff_t			offset,
 +	loff_t			count,
 +	unsigned		flags,
 +	struct iomap		*iomap,
 +	struct iomap		*srcmap)
 +{
 +	struct xfs_inode	*ip = XFS_I(inode);
 +	struct xfs_mount	*mp = ip->i_mount;
 +	xfs_fileoff_t		offset_fsb = XFS_B_TO_FSBT(mp, offset);
 +	xfs_fileoff_t		end_fsb = xfs_iomap_end_fsb(mp, offset, count);
 +	struct xfs_bmbt_irec	imap, cmap;
 +	struct xfs_iext_cursor	icur, ccur;
 +	xfs_fsblock_t		prealloc_blocks = 0;
 +	bool			eof = false, cow_eof = false, shared = false;
 +	int			allocfork = XFS_DATA_FORK;
 +	int			error = 0;
 +
 +	ASSERT(!XFS_IS_REALTIME_INODE(ip));
 +	ASSERT(!xfs_get_extsz_hint(ip));
 +
 +	xfs_ilock(ip, XFS_ILOCK_EXCL);
 +
++<<<<<<< HEAD
 +	if (unlikely(XFS_TEST_ERROR(
 +	    (XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_EXTENTS &&
 +	     XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_BTREE),
 +	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
 +		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
++=======
++	if (XFS_IS_CORRUPT(mp, !xfs_ifork_has_extents(ip, XFS_DATA_FORK)) ||
++	    XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BMAPIFORMAT)) {
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
 +		error = -EFSCORRUPTED;
 +		goto out_unlock;
 +	}
 +
 +	XFS_STATS_INC(mp, xs_blk_mapw);
 +
 +	if (!(ip->i_df.if_flags & XFS_IFEXTENTS)) {
 +		error = xfs_iread_extents(NULL, ip, XFS_DATA_FORK);
 +		if (error)
 +			goto out_unlock;
 +	}
 +
 +	/*
 +	 * Search the data fork fork first to look up our source mapping.  We
 +	 * always need the data fork map, as we have to return it to the
 +	 * iomap code so that the higher level write code can read data in to
 +	 * perform read-modify-write cycles for unaligned writes.
 +	 */
 +	eof = !xfs_iext_lookup_extent(ip, &ip->i_df, offset_fsb, &icur, &imap);
 +	if (eof)
 +		imap.br_startoff = end_fsb; /* fake hole until the end */
 +
 +	/* We never need to allocate blocks for zeroing a hole. */
 +	if ((flags & IOMAP_ZERO) && imap.br_startoff > offset_fsb) {
 +		xfs_hole_to_iomap(ip, iomap, offset_fsb, imap.br_startoff);
 +		goto out_unlock;
 +	}
 +
 +	/*
 +	 * Search the COW fork extent list even if we did not find a data fork
 +	 * extent.  This serves two purposes: first this implements the
 +	 * speculative preallocation using cowextsize, so that we also unshare
 +	 * block adjacent to shared blocks instead of just the shared blocks
 +	 * themselves.  Second the lookup in the extent list is generally faster
 +	 * than going out to the shared extent tree.
 +	 */
 +	if (xfs_is_cow_inode(ip)) {
 +		if (!ip->i_cowfp) {
 +			ASSERT(!xfs_is_reflink_inode(ip));
 +			xfs_ifork_init_cow(ip);
 +		}
 +		cow_eof = !xfs_iext_lookup_extent(ip, ip->i_cowfp, offset_fsb,
 +				&ccur, &cmap);
 +		if (!cow_eof && cmap.br_startoff <= offset_fsb) {
 +			trace_xfs_reflink_cow_found(ip, &cmap);
 +			goto found_cow;
 +		}
 +	}
 +
 +	if (imap.br_startoff <= offset_fsb) {
 +		/*
 +		 * For reflink files we may need a delalloc reservation when
 +		 * overwriting shared extents.   This includes zeroing of
 +		 * existing extents that contain data.
 +		 */
 +		if (!xfs_is_cow_inode(ip) ||
 +		    ((flags & IOMAP_ZERO) && imap.br_state != XFS_EXT_NORM)) {
 +			trace_xfs_iomap_found(ip, offset, count, XFS_DATA_FORK,
 +					&imap);
 +			goto found_imap;
 +		}
 +
 +		xfs_trim_extent(&imap, offset_fsb, end_fsb - offset_fsb);
 +
 +		/* Trim the mapping to the nearest shared extent boundary. */
 +		error = xfs_inode_need_cow(ip, &imap, &shared);
 +		if (error)
 +			goto out_unlock;
 +
 +		/* Not shared?  Just report the (potentially capped) extent. */
 +		if (!shared) {
 +			trace_xfs_iomap_found(ip, offset, count, XFS_DATA_FORK,
 +					&imap);
 +			goto found_imap;
 +		}
 +
 +		/*
 +		 * Fork all the shared blocks from our write offset until the
 +		 * end of the extent.
 +		 */
 +		allocfork = XFS_COW_FORK;
 +		end_fsb = imap.br_startoff + imap.br_blockcount;
 +	} else {
 +		/*
 +		 * We cap the maximum length we map here to MAX_WRITEBACK_PAGES
 +		 * pages to keep the chunks of work done where somewhat
 +		 * symmetric with the work writeback does.  This is a completely
 +		 * arbitrary number pulled out of thin air.
 +		 *
 +		 * Note that the values needs to be less than 32-bits wide until
 +		 * the lower level functions are updated.
 +		 */
 +		count = min_t(loff_t, count, 1024 * PAGE_SIZE);
 +		end_fsb = xfs_iomap_end_fsb(mp, offset, count);
 +
 +		if (xfs_is_always_cow_inode(ip))
 +			allocfork = XFS_COW_FORK;
 +	}
 +
 +	error = xfs_qm_dqattach_locked(ip, false);
 +	if (error)
 +		goto out_unlock;
 +
 +	if (eof) {
 +		prealloc_blocks = xfs_iomap_prealloc_size(ip, allocfork, offset,
 +				count, &icur);
 +		if (prealloc_blocks) {
 +			xfs_extlen_t	align;
 +			xfs_off_t	end_offset;
 +			xfs_fileoff_t	p_end_fsb;
 +
 +			end_offset = XFS_ALLOC_ALIGN(mp, offset + count - 1);
 +			p_end_fsb = XFS_B_TO_FSBT(mp, end_offset) +
 +					prealloc_blocks;
 +
 +			align = xfs_eof_alignment(ip);
 +			if (align)
 +				p_end_fsb = roundup_64(p_end_fsb, align);
 +
 +			p_end_fsb = min(p_end_fsb,
 +				XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes));
 +			ASSERT(p_end_fsb > offset_fsb);
 +			prealloc_blocks = p_end_fsb - end_fsb;
 +		}
 +	}
 +
 +retry:
 +	error = xfs_bmapi_reserve_delalloc(ip, allocfork, offset_fsb,
 +			end_fsb - offset_fsb, prealloc_blocks,
 +			allocfork == XFS_DATA_FORK ? &imap : &cmap,
 +			allocfork == XFS_DATA_FORK ? &icur : &ccur,
 +			allocfork == XFS_DATA_FORK ? eof : cow_eof);
 +	switch (error) {
 +	case 0:
 +		break;
 +	case -ENOSPC:
 +	case -EDQUOT:
 +		/* retry without any preallocation */
 +		trace_xfs_delalloc_enospc(ip, offset, count);
 +		if (prealloc_blocks) {
 +			prealloc_blocks = 0;
 +			goto retry;
 +		}
 +		/*FALLTHRU*/
 +	default:
 +		goto out_unlock;
 +	}
 +
 +	if (allocfork == XFS_COW_FORK) {
 +		trace_xfs_iomap_alloc(ip, offset, count, allocfork, &cmap);
 +		goto found_cow;
 +	}
 +
 +	/*
 +	 * Flag newly allocated delalloc blocks with IOMAP_F_NEW so we punch
 +	 * them out if the write happens to fail.
 +	 */
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 +	trace_xfs_iomap_alloc(ip, offset, count, allocfork, &imap);
 +	return xfs_bmbt_to_iomap(ip, iomap, &imap, IOMAP_F_NEW);
 +
 +found_imap:
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 +	return xfs_bmbt_to_iomap(ip, iomap, &imap, 0);
 +
 +found_cow:
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 +	if (imap.br_startoff <= offset_fsb) {
 +		error = xfs_bmbt_to_iomap(ip, srcmap, &imap, 0);
 +		if (error)
 +			return error;
 +	} else {
 +		xfs_trim_extent(&cmap, offset_fsb,
 +				imap.br_startoff - offset_fsb);
 +	}
 +	return xfs_bmbt_to_iomap(ip, iomap, &cmap, IOMAP_F_SHARED);
 +
 +out_unlock:
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 +	return error;
 +
 +}
 +
  int
  xfs_iomap_write_unwritten(
  	xfs_inode_t	*ip,
diff --cc fs/xfs/xfs_iops.c
index b7094481af68,b129e077a5fa..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -478,8 -480,8 +478,13 @@@ xfs_vn_get_link_inline
  	 * The VFS crashes on a NULL pointer, so return -EFSCORRUPTED if
  	 * if_data is junk.
  	 */
++<<<<<<< HEAD
 +	link = XFS_I(inode)->i_df.if_u1.if_data;
 +	if (!link)
++=======
+ 	link = ip->i_df.if_u1.if_data;
+ 	if (XFS_IS_CORRUPT(ip->i_mount, !link))
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		return ERR_PTR(-EFSCORRUPTED);
  	return link;
  }
diff --cc fs/xfs/xfs_qm.c
index ecd8ce152ab1,7e264cbd15b9..000000000000
--- a/fs/xfs/xfs_qm.c
+++ b/fs/xfs/xfs_qm.c
@@@ -754,11 -755,15 +754,23 @@@ xfs_qm_qino_alloc
  		if ((flags & XFS_QMOPT_PQUOTA) &&
  			     (mp->m_sb.sb_gquotino != NULLFSINO)) {
  			ino = mp->m_sb.sb_gquotino;
++<<<<<<< HEAD
 +			ASSERT(mp->m_sb.sb_pquotino == NULLFSINO);
 +		} else if ((flags & XFS_QMOPT_GQUOTA) &&
 +			     (mp->m_sb.sb_pquotino != NULLFSINO)) {
 +			ino = mp->m_sb.sb_pquotino;
 +			ASSERT(mp->m_sb.sb_gquotino == NULLFSINO);
++=======
+ 			if (XFS_IS_CORRUPT(mp,
+ 					   mp->m_sb.sb_pquotino != NULLFSINO))
+ 				return -EFSCORRUPTED;
+ 		} else if ((flags & XFS_QMOPT_GQUOTA) &&
+ 			     (mp->m_sb.sb_pquotino != NULLFSINO)) {
+ 			ino = mp->m_sb.sb_pquotino;
+ 			if (XFS_IS_CORRUPT(mp,
+ 					   mp->m_sb.sb_gquotino != NULLFSINO))
+ 				return -EFSCORRUPTED;
++>>>>>>> a71895c5dad1 (xfs: convert open coded corruption check to use XFS_IS_CORRUPT)
  		}
  		if (ino != NULLFSINO) {
  			error = xfs_iget(mp, NULL, ino, 0, 0, ip);
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_btree.c
* Unmerged path fs/xfs/libxfs/xfs_da_btree.c
* Unmerged path fs/xfs/libxfs/xfs_dir2.c
diff --git a/fs/xfs/libxfs/xfs_dir2_node.c b/fs/xfs/libxfs/xfs_dir2_node.c
index 44b05eec6ee9..eff7cb8f6906 100644
--- a/fs/xfs/libxfs/xfs_dir2_node.c
+++ b/fs/xfs/libxfs/xfs_dir2_node.c
@@ -725,10 +725,9 @@ xfs_dir2_leafn_lookup_for_addname(
 			 * If it has room, return it.
 			 */
 			xfs_dir2_free_hdr_from_disk(mp, &freehdr, free);
-			if (unlikely(
-			    freehdr.bests[fi] == cpu_to_be16(NULLDATAOFF))) {
-				XFS_ERROR_REPORT("xfs_dir2_leafn_lookup_int",
-							XFS_ERRLEVEL_LOW, mp);
+			if (XFS_IS_CORRUPT(mp,
+					   freehdr.bests[fi] ==
+					   cpu_to_be16(NULLDATAOFF))) {
 				if (curfdb != newfdb)
 					xfs_trans_brelse(tp, curbp);
 				return -EFSCORRUPTED;
@@ -1717,7 +1716,9 @@ xfs_dir2_node_add_datablk(
 		if (error)
 			return error;
 
-		if (xfs_dir2_db_to_fdb(args->geo, *dbno) != fbno) {
+		if (XFS_IS_CORRUPT(mp,
+				   xfs_dir2_db_to_fdb(args->geo, *dbno) !=
+				   fbno)) {
 			xfs_alert(mp,
 "%s: dir ino %llu needed freesp block %lld for data block %lld, got %lld",
 				__func__, (unsigned long long)dp->i_ino,
@@ -1731,7 +1732,6 @@ xfs_dir2_node_add_datablk(
 			} else {
 				xfs_alert(mp, " ... fblk is NULL");
 			}
-			XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
 			return -EFSCORRUPTED;
 		}
 
* Unmerged path fs/xfs/libxfs/xfs_refcount.c
diff --git a/fs/xfs/libxfs/xfs_rmap.c b/fs/xfs/libxfs/xfs_rmap.c
index b85b98f495f9..dae1a2bf28eb 100644
--- a/fs/xfs/libxfs/xfs_rmap.c
+++ b/fs/xfs/libxfs/xfs_rmap.c
@@ -2400,7 +2400,7 @@ xfs_rmap_finish_one(
 		error = xfs_free_extent_fix_freelist(tp, agno, &agbp);
 		if (error)
 			return error;
-		if (!agbp)
+		if (XFS_IS_CORRUPT(tp->t_mountp, !agbp))
 			return -EFSCORRUPTED;
 
 		rcur = xfs_rmapbt_init_cursor(mp, tp, agbp, agno);
* Unmerged path fs/xfs/libxfs/xfs_rtbitmap.c
* Unmerged path fs/xfs/xfs_attr_list.c
diff --git a/fs/xfs/xfs_dir2_readdir.c b/fs/xfs/xfs_dir2_readdir.c
index b149cb4a4d86..95bc9ef8f5f9 100644
--- a/fs/xfs/xfs_dir2_readdir.c
+++ b/fs/xfs/xfs_dir2_readdir.c
@@ -117,11 +117,10 @@ xfs_dir2_sf_getdents(
 		ino = xfs_dir2_sf_get_ino(mp, sfp, sfep);
 		filetype = xfs_dir2_sf_get_ftype(mp, sfep);
 		ctx->pos = off & 0x7fffffff;
-		if (!xfs_dir2_namecheck(sfep->name, sfep->namelen)) {
-			XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW,
-					 dp->i_mount);
+		if (XFS_IS_CORRUPT(dp->i_mount,
+				   !xfs_dir2_namecheck(sfep->name,
+						       sfep->namelen)))
 			return -EFSCORRUPTED;
-		}
 		if (!dir_emit(ctx, (char *)sfep->name, sfep->namelen, ino,
 			    xfs_dir3_get_dtype(mp, filetype)))
 			return 0;
@@ -207,9 +206,9 @@ xfs_dir2_block_getdents(
 		/*
 		 * If it didn't fit, set the final offset to here & return.
 		 */
-		if (!xfs_dir2_namecheck(dep->name, dep->namelen)) {
-			XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW,
-					 dp->i_mount);
+		if (XFS_IS_CORRUPT(dp->i_mount,
+				   !xfs_dir2_namecheck(dep->name,
+						       dep->namelen))) {
 			error = -EFSCORRUPTED;
 			goto out_rele;
 		}
@@ -459,9 +458,9 @@ xfs_dir2_leaf_getdents(
 		filetype = xfs_dir2_data_get_ftype(mp, dep);
 
 		ctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;
-		if (!xfs_dir2_namecheck(dep->name, dep->namelen)) {
-			XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW,
-					 dp->i_mount);
+		if (XFS_IS_CORRUPT(dp->i_mount,
+				   !xfs_dir2_namecheck(dep->name,
+						       dep->namelen))) {
 			error = -EFSCORRUPTED;
 			break;
 		}
* Unmerged path fs/xfs/xfs_iomap.c
* Unmerged path fs/xfs/xfs_iops.c
diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c
index 8e9dccd6530e..a3b8f8d3ff1e 100644
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@ -103,10 +103,9 @@ xlog_alloc_buffer(
 	 * Pass log block 0 since we don't have an addr yet, buffer will be
 	 * verified on read.
 	 */
-	if (!xlog_verify_bno(log, 0, nbblks)) {
+	if (XFS_IS_CORRUPT(log->l_mp, !xlog_verify_bno(log, 0, nbblks))) {
 		xfs_warn(log->l_mp, "Invalid block length (0x%x) for buffer",
 			nbblks);
-		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);
 		return NULL;
 	}
 
@@ -152,11 +151,10 @@ xlog_do_io(
 {
 	int			error;
 
-	if (!xlog_verify_bno(log, blk_no, nbblks)) {
+	if (XFS_IS_CORRUPT(log->l_mp, !xlog_verify_bno(log, blk_no, nbblks))) {
 		xfs_warn(log->l_mp,
 			 "Invalid log block/length (0x%llx, 0x%x) for buffer",
 			 blk_no, nbblks);
-		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_HIGH, log->l_mp);
 		return -EFSCORRUPTED;
 	}
 
@@ -244,19 +242,17 @@ xlog_header_check_recover(
 	 * (XLOG_FMT_UNKNOWN). This stops us from trying to recover
 	 * a dirty log created in IRIX.
 	 */
-	if (unlikely(head->h_fmt != cpu_to_be32(XLOG_FMT))) {
+	if (XFS_IS_CORRUPT(mp, head->h_fmt != cpu_to_be32(XLOG_FMT))) {
 		xfs_warn(mp,
 	"dirty log written in incompatible format - can't recover");
 		xlog_header_check_dump(mp, head);
-		XFS_ERROR_REPORT("xlog_header_check_recover(1)",
-				 XFS_ERRLEVEL_HIGH, mp);
 		return -EFSCORRUPTED;
-	} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {
+	}
+	if (XFS_IS_CORRUPT(mp, !uuid_equal(&mp->m_sb.sb_uuid,
+					   &head->h_fs_uuid))) {
 		xfs_warn(mp,
 	"dirty log entry has mismatched uuid - can't recover");
 		xlog_header_check_dump(mp, head);
-		XFS_ERROR_REPORT("xlog_header_check_recover(2)",
-				 XFS_ERRLEVEL_HIGH, mp);
 		return -EFSCORRUPTED;
 	}
 	return 0;
@@ -279,11 +275,10 @@ xlog_header_check_mount(
 		 * by IRIX and continue.
 		 */
 		xfs_warn(mp, "null uuid in log - IRIX style log");
-	} else if (unlikely(!uuid_equal(&mp->m_sb.sb_uuid, &head->h_fs_uuid))) {
+	} else if (XFS_IS_CORRUPT(mp, !uuid_equal(&mp->m_sb.sb_uuid,
+						  &head->h_fs_uuid))) {
 		xfs_warn(mp, "log has mismatched uuid - can't recover");
 		xlog_header_check_dump(mp, head);
-		XFS_ERROR_REPORT("xlog_header_check_mount",
-				 XFS_ERRLEVEL_HIGH, mp);
 		return -EFSCORRUPTED;
 	}
 	return 0;
@@ -1700,11 +1695,10 @@ xlog_clear_stale_blocks(
 		 * the distance from the beginning of the log to the
 		 * tail.
 		 */
-		if (unlikely(head_block < tail_block || head_block >= log->l_logBBsize)) {
-			XFS_ERROR_REPORT("xlog_clear_stale_blocks(1)",
-					 XFS_ERRLEVEL_LOW, log->l_mp);
+		if (XFS_IS_CORRUPT(log->l_mp,
+				   head_block < tail_block ||
+				   head_block >= log->l_logBBsize))
 			return -EFSCORRUPTED;
-		}
 		tail_distance = tail_block + (log->l_logBBsize - head_block);
 	} else {
 		/*
@@ -1712,11 +1706,10 @@ xlog_clear_stale_blocks(
 		 * so the distance from the head to the tail is just
 		 * the tail block minus the head block.
 		 */
-		if (unlikely(head_block >= tail_block || head_cycle != (tail_cycle + 1))){
-			XFS_ERROR_REPORT("xlog_clear_stale_blocks(2)",
-					 XFS_ERRLEVEL_LOW, log->l_mp);
+		if (XFS_IS_CORRUPT(log->l_mp,
+				   head_block >= tail_block ||
+				   head_cycle != tail_cycle + 1))
 			return -EFSCORRUPTED;
-		}
 		tail_distance = tail_block - head_block;
 	}
 
@@ -2136,13 +2129,11 @@ xlog_recover_do_inode_buffer(
 		 */
 		logged_nextp = item->ri_buf[item_index].i_addr +
 				next_unlinked_offset - reg_buf_offset;
-		if (unlikely(*logged_nextp == 0)) {
+		if (XFS_IS_CORRUPT(mp, *logged_nextp == 0)) {
 			xfs_alert(mp,
 		"Bad inode buffer log record (ptr = "PTR_FMT", bp = "PTR_FMT"). "
 		"Trying to replay bad (0) inode di_next_unlinked field.",
 				item, bp);
-			XFS_ERROR_REPORT("xlog_recover_do_inode_buf",
-					 XFS_ERRLEVEL_LOW, mp);
 			return -EFSCORRUPTED;
 		}
 
@@ -2970,22 +2961,18 @@ xlog_recover_inode_pass2(
 	 * Make sure the place we're flushing out to really looks
 	 * like an inode!
 	 */
-	if (unlikely(!xfs_verify_magic16(bp, dip->di_magic))) {
+	if (XFS_IS_CORRUPT(mp, !xfs_verify_magic16(bp, dip->di_magic))) {
 		xfs_alert(mp,
 	"%s: Bad inode magic number, dip = "PTR_FMT", dino bp = "PTR_FMT", ino = %Ld",
 			__func__, dip, bp, in_f->ilf_ino);
-		XFS_ERROR_REPORT("xlog_recover_inode_pass2(1)",
-				 XFS_ERRLEVEL_LOW, mp);
 		error = -EFSCORRUPTED;
 		goto out_release;
 	}
 	ldip = item->ri_buf[1].i_addr;
-	if (unlikely(ldip->di_magic != XFS_DINODE_MAGIC)) {
+	if (XFS_IS_CORRUPT(mp, ldip->di_magic != XFS_DINODE_MAGIC)) {
 		xfs_alert(mp,
 			"%s: Bad inode log record, rec ptr "PTR_FMT", ino %Ld",
 			__func__, item, in_f->ilf_ino);
-		XFS_ERROR_REPORT("xlog_recover_inode_pass2(2)",
-				 XFS_ERRLEVEL_LOW, mp);
 		error = -EFSCORRUPTED;
 		goto out_release;
 	}
@@ -5200,14 +5187,13 @@ xlog_valid_rec_header(
 {
 	int			hlen;
 
-	if (unlikely(rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))) {
-		XFS_ERROR_REPORT("xlog_valid_rec_header(1)",
-				XFS_ERRLEVEL_LOW, log->l_mp);
+	if (XFS_IS_CORRUPT(log->l_mp,
+			   rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM)))
 		return -EFSCORRUPTED;
-	}
-	if (unlikely(
-	    (!rhead->h_version ||
-	    (be32_to_cpu(rhead->h_version) & (~XLOG_VERSION_OKBITS))))) {
+	if (XFS_IS_CORRUPT(log->l_mp,
+			   (!rhead->h_version ||
+			   (be32_to_cpu(rhead->h_version) &
+			    (~XLOG_VERSION_OKBITS))))) {
 		xfs_warn(log->l_mp, "%s: unrecognised log version (%d).",
 			__func__, be32_to_cpu(rhead->h_version));
 		return -EIO;
@@ -5215,16 +5201,11 @@ xlog_valid_rec_header(
 
 	/* LR body must have data or it wouldn't have been written */
 	hlen = be32_to_cpu(rhead->h_len);
-	if (unlikely( hlen <= 0 || hlen > INT_MAX )) {
-		XFS_ERROR_REPORT("xlog_valid_rec_header(2)",
-				XFS_ERRLEVEL_LOW, log->l_mp);
+	if (XFS_IS_CORRUPT(log->l_mp, hlen <= 0 || hlen > INT_MAX))
 		return -EFSCORRUPTED;
-	}
-	if (unlikely( blkno > log->l_logBBsize || blkno > INT_MAX )) {
-		XFS_ERROR_REPORT("xlog_valid_rec_header(3)",
-				XFS_ERRLEVEL_LOW, log->l_mp);
+	if (XFS_IS_CORRUPT(log->l_mp,
+			   blkno > log->l_logBBsize || blkno > INT_MAX))
 		return -EFSCORRUPTED;
-	}
 	return 0;
 }
 
diff --git a/fs/xfs/xfs_mount.c b/fs/xfs/xfs_mount.c
index e10f40df7ffe..29cd89033599 100644
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -846,9 +846,8 @@ xfs_mountfs(
 		goto out_free_dir;
 	}
 
-	if (!sbp->sb_logblocks) {
+	if (XFS_IS_CORRUPT(mp, !sbp->sb_logblocks)) {
 		xfs_warn(mp, "no log defined");
-		XFS_ERROR_REPORT("xfs_mountfs", XFS_ERRLEVEL_LOW, mp);
 		error = -EFSCORRUPTED;
 		goto out_free_perag;
 	}
@@ -886,12 +885,10 @@ xfs_mountfs(
 
 	ASSERT(rip != NULL);
 
-	if (unlikely(!S_ISDIR(VFS_I(rip)->i_mode))) {
+	if (XFS_IS_CORRUPT(mp, !S_ISDIR(VFS_I(rip)->i_mode))) {
 		xfs_warn(mp, "corrupted root inode %llu: not a directory",
 			(unsigned long long)rip->i_ino);
 		xfs_iunlock(rip, XFS_ILOCK_EXCL);
-		XFS_ERROR_REPORT("xfs_mountfs_int(2)", XFS_ERRLEVEL_LOW,
-				 mp);
 		error = -EFSCORRUPTED;
 		goto out_rele_rip;
 	}
* Unmerged path fs/xfs/xfs_qm.c
