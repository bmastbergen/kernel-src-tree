mm, memcg: consider subtrees in memory.events

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chris Down <chris@chrisdown.name>
commit 9852ae3fe5293264f01c49f2571ef7688f7823ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9852ae3f.failed

memory.stat and other files already consider subtrees in their output, and
we should too in order to not present an inconsistent interface.

The current situation is fairly confusing, because people interacting with
cgroups expect hierarchical behaviour in the vein of memory.stat,
cgroup.events, and other files.  For example, this causes confusion when
debugging reclaim events under low, as currently these always read "0" at
non-leaf memcg nodes, which frequently causes people to misdiagnose breach
behaviour.  The same confusion applies to other counters in this file when
debugging issues.

Aggregation is done at write time instead of at read-time since these
counters aren't hot (unlike memory.stat which is per-page, so it does it
at read time), and it makes sense to bundle this with the file
notifications.

After this patch, events are propagated up the hierarchy:

    [root@ktst ~]# cat /sys/fs/cgroup/system.slice/memory.events
    low 0
    high 0
    max 0
    oom 0
    oom_kill 0
    [root@ktst ~]# systemd-run -p MemoryMax=1 true
    Running as unit: run-r251162a189fb4562b9dabfdc9b0422f5.service
    [root@ktst ~]# cat /sys/fs/cgroup/system.slice/memory.events
    low 0
    high 0
    max 7
    oom 1
    oom_kill 1

As this is a change in behaviour, this can be reverted to the old
behaviour by mounting with the `memory_localevents' flag set.  However, we
use the new behaviour by default as there's a lack of evidence that there
are any current users of memory.events that would find this change
undesirable.

akpm: this is a behaviour change, so Cc:stable.  THis is so that
forthcoming distros which use cgroup v2 are more likely to pick up the
revised behaviour.

Link: http://lkml.kernel.org/r/20190208224419.GA24772@chrisdown.name
	Signed-off-by: Chris Down <chris@chrisdown.name>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Dennis Zhou <dennis@kernel.org>
	Cc: Suren Baghdasaryan <surenb@google.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9852ae3fe5293264f01c49f2571ef7688f7823ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cgroup/cgroup.c
diff --cc kernel/cgroup/cgroup.c
index 9e08519ae6db,426a0026225c..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -1814,26 -1808,42 +1814,53 @@@ int cgroup_show_path(struct seq_file *s
  	return len;
  }
  
++<<<<<<< HEAD
 +static int parse_cgroup_root_flags(char *data, unsigned int *root_flags)
++=======
+ enum cgroup2_param {
+ 	Opt_nsdelegate,
+ 	Opt_memory_localevents,
+ 	nr__cgroup2_params
+ };
+ 
+ static const struct fs_parameter_spec cgroup2_param_specs[] = {
+ 	fsparam_flag("nsdelegate",		Opt_nsdelegate),
+ 	fsparam_flag("memory_localevents",	Opt_memory_localevents),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description cgroup2_fs_parameters = {
+ 	.name		= "cgroup2",
+ 	.specs		= cgroup2_param_specs,
+ };
+ 
+ static int cgroup2_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 9852ae3fe529 (mm, memcg: consider subtrees in memory.events)
  {
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 -	struct fs_parse_result result;
 -	int opt;
 +	char *token;
  
 -	opt = fs_parse(fc, &cgroup2_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 +	*root_flags = 0;
  
 -	switch (opt) {
 -	case Opt_nsdelegate:
 -		ctx->flags |= CGRP_ROOT_NS_DELEGATE;
 +	if (!data || *data == '\0')
  		return 0;
++<<<<<<< HEAD
 +
 +	while ((token = strsep(&data, ",")) != NULL) {
 +		if (!strcmp(token, "nsdelegate")) {
 +			*root_flags |= CGRP_ROOT_NS_DELEGATE;
 +			continue;
 +		}
 +
 +		pr_err("cgroup2: unknown option \"%s\"\n", token);
 +		return -EINVAL;
++=======
+ 	case Opt_memory_localevents:
+ 		ctx->flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;
+ 		return 0;
++>>>>>>> 9852ae3fe529 (mm, memcg: consider subtrees in memory.events)
  	}
 -	return -EINVAL;
 +
 +	return 0;
  }
  
  static void apply_cgroup_root_flags(unsigned int root_flags)
diff --git a/Documentation/admin-guide/cgroup-v2.rst b/Documentation/admin-guide/cgroup-v2.rst
index 45de03923c4f..604f0fa99c49 100644
--- a/Documentation/admin-guide/cgroup-v2.rst
+++ b/Documentation/admin-guide/cgroup-v2.rst
@@ -179,6 +179,15 @@ cgroup v2 currently supports the following mount options.
 	ignored on non-init namespace mounts.  Please refer to the
 	Delegation section for details.
 
+  memory_localevents
+
+        Only populate memory.events with data for the current cgroup,
+        and not any subtrees. This is legacy behaviour, the default
+        behaviour without this option is to include subtree counts.
+        This option is system wide and can only be set on mount or
+        modified through remount from the init namespace. The mount
+        option is ignored on non-init namespace mounts.
+
 
 Organizing Processes and Threads
 --------------------------------
diff --git a/include/linux/cgroup-defs.h b/include/linux/cgroup-defs.h
index 0110a26434e3..972567a833ef 100644
--- a/include/linux/cgroup-defs.h
+++ b/include/linux/cgroup-defs.h
@@ -89,6 +89,11 @@ enum {
 	 * Enable cpuset controller in v1 cgroup to use v2 behavior.
 	 */
 	CGRP_ROOT_CPUSET_V2_MODE = (1 << 4),
+
+	/*
+	 * Enable legacy local memory.events.
+	 */
+	CGRP_ROOT_MEMORY_LOCAL_EVENTS = (1 << 5),
 };
 
 /* cftype->flags */
diff --git a/include/linux/memcontrol.h b/include/linux/memcontrol.h
index aaaa5a5dc184..59a9800524db 100644
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@ -786,8 +786,14 @@ static inline void count_memcg_event_mm(struct mm_struct *mm,
 static inline void memcg_memory_event(struct mem_cgroup *memcg,
 				      enum memcg_memory_event event)
 {
-	atomic_long_inc(&memcg->memory_events[event]);
-	cgroup_file_notify(&memcg->events_file);
+	do {
+		atomic_long_inc(&memcg->memory_events[event]);
+		cgroup_file_notify(&memcg->events_file);
+
+		if (cgrp_dfl_root.flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)
+			break;
+	} while ((memcg = parent_mem_cgroup(memcg)) &&
+		 !mem_cgroup_is_root(memcg));
 }
 
 static inline void memcg_memory_event_mm(struct mm_struct *mm,
* Unmerged path kernel/cgroup/cgroup.c
