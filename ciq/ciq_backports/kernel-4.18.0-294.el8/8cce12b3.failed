KVM: nSVM: set fixed bits by hand

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 8cce12b3c82717df72afb955ce74c769b0eb2b4f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8cce12b3.failed

SVM generally ignores fixed-1 bits.  Set them manually so that we
do not end up by mistake without those bits set in struct kvm_vcpu;
it is part of userspace API that KVM always returns value with the
bits set.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8cce12b3c82717df72afb955ce74c769b0eb2b4f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/nested.c
diff --cc arch/x86/kvm/svm/nested.c
index a41617fb2750,b0b667456b2e..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -356,31 -372,31 +356,56 @@@ static int nested_svm_load_cr3(struct k
  	return 0;
  }
  
 -static void nested_prepare_vmcb_save(struct vcpu_svm *svm, struct vmcb *vmcb12)
 +static void nested_prepare_vmcb_save(struct vcpu_svm *svm, struct vmcb *nested_vmcb)
  {
  	/* Load the nested guest state */
++<<<<<<< HEAD
 +	svm->vmcb->save.es = nested_vmcb->save.es;
 +	svm->vmcb->save.cs = nested_vmcb->save.cs;
 +	svm->vmcb->save.ss = nested_vmcb->save.ss;
 +	svm->vmcb->save.ds = nested_vmcb->save.ds;
 +	svm->vmcb->save.gdtr = nested_vmcb->save.gdtr;
 +	svm->vmcb->save.idtr = nested_vmcb->save.idtr;
 +	kvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);
 +	svm_set_efer(&svm->vcpu, nested_vmcb->save.efer);
 +	svm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);
 +	svm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);
 +	svm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;
 +	kvm_rax_write(&svm->vcpu, nested_vmcb->save.rax);
 +	kvm_rsp_write(&svm->vcpu, nested_vmcb->save.rsp);
 +	kvm_rip_write(&svm->vcpu, nested_vmcb->save.rip);
 +
 +	/* In case we don't even reach vcpu_run, the fields are not updated */
 +	svm->vmcb->save.rax = nested_vmcb->save.rax;
 +	svm->vmcb->save.rsp = nested_vmcb->save.rsp;
 +	svm->vmcb->save.rip = nested_vmcb->save.rip;
 +	svm->vmcb->save.dr7 = nested_vmcb->save.dr7;
 +	svm->vcpu.arch.dr6  = nested_vmcb->save.dr6;
 +	svm->vmcb->save.cpl = nested_vmcb->save.cpl;
++=======
+ 	svm->vmcb->save.es = vmcb12->save.es;
+ 	svm->vmcb->save.cs = vmcb12->save.cs;
+ 	svm->vmcb->save.ss = vmcb12->save.ss;
+ 	svm->vmcb->save.ds = vmcb12->save.ds;
+ 	svm->vmcb->save.gdtr = vmcb12->save.gdtr;
+ 	svm->vmcb->save.idtr = vmcb12->save.idtr;
+ 	kvm_set_rflags(&svm->vcpu, vmcb12->save.rflags | X86_EFLAGS_FIXED);
+ 	svm_set_efer(&svm->vcpu, vmcb12->save.efer);
+ 	svm_set_cr0(&svm->vcpu, vmcb12->save.cr0);
+ 	svm_set_cr4(&svm->vcpu, vmcb12->save.cr4);
+ 	svm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = vmcb12->save.cr2;
+ 	kvm_rax_write(&svm->vcpu, vmcb12->save.rax);
+ 	kvm_rsp_write(&svm->vcpu, vmcb12->save.rsp);
+ 	kvm_rip_write(&svm->vcpu, vmcb12->save.rip);
+ 
+ 	/* In case we don't even reach vcpu_run, the fields are not updated */
+ 	svm->vmcb->save.rax = vmcb12->save.rax;
+ 	svm->vmcb->save.rsp = vmcb12->save.rsp;
+ 	svm->vmcb->save.rip = vmcb12->save.rip;
+ 	svm->vmcb->save.dr7 = vmcb12->save.dr7 | DR7_FIXED_1;
+ 	svm->vcpu.arch.dr6  = vmcb12->save.dr6 | DR6_FIXED_1 | DR6_RTM;
+ 	svm->vmcb->save.cpl = vmcb12->save.cpl;
++>>>>>>> 8cce12b3c827 (KVM: nSVM: set fixed bits by hand)
  }
  
  static void nested_prepare_vmcb_control(struct vcpu_svm *svm)
* Unmerged path arch/x86/kvm/svm/nested.c
