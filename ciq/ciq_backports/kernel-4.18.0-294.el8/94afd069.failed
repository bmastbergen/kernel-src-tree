powerpc: Use a datatype for instructions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jordan Niethe <jniethe5@gmail.com>
commit 94afd069d937d84fb4f696eb9a78db4084e43d21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/94afd069.failed

Currently unsigned ints are used to represent instructions on powerpc.
This has worked well as instructions have always been 4 byte words.

However, ISA v3.1 introduces some changes to instructions that mean
this scheme will no longer work as well. This change is Prefixed
Instructions. A prefixed instruction is made up of a word prefix
followed by a word suffix to make an 8 byte double word instruction.
No matter the endianness of the system the prefix always comes first.
Prefixed instructions are only planned for powerpc64.

Introduce a ppc_inst type to represent both prefixed and word
instructions on powerpc64 while keeping it possible to exclusively
have word instructions on powerpc32.

	Signed-off-by: Jordan Niethe <jniethe5@gmail.com>
[mpe: Fix compile error in emulate_spe()]
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200506034050.24806-12-jniethe5@gmail.com
(cherry picked from commit 94afd069d937d84fb4f696eb9a78db4084e43d21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/code-patching.h
#	arch/powerpc/include/asm/inst.h
#	arch/powerpc/kernel/epapr_paravirt.c
#	arch/powerpc/kernel/hw_breakpoint.c
#	arch/powerpc/kernel/kprobes.c
#	arch/powerpc/kernel/optprobes.c
#	arch/powerpc/kernel/setup_32.c
#	arch/powerpc/kernel/trace/ftrace.c
#	arch/powerpc/kernel/vecemu.c
#	arch/powerpc/lib/code-patching.c
#	arch/powerpc/lib/feature-fixups.c
#	arch/powerpc/platforms/86xx/mpc86xx_smp.c
#	arch/powerpc/platforms/powermac/smp.c
#	arch/powerpc/xmon/xmon.c
diff --cc arch/powerpc/include/asm/code-patching.h
index 02e3faf76d9a,eacc9102c251..000000000000
--- a/arch/powerpc/include/asm/code-patching.h
+++ b/arch/powerpc/include/asm/code-patching.h
@@@ -25,13 -23,13 +25,23 @@@
  #define BRANCH_ABSOLUTE	0x2
  
  bool is_offset_in_branch_range(long offset);
++<<<<<<< HEAD
 +unsigned int create_branch(const unsigned int *addr,
 +			   unsigned long target, int flags);
 +unsigned int create_cond_branch(const unsigned int *addr,
 +				unsigned long target, int flags);
 +int patch_branch(unsigned int *addr, unsigned long target, int flags);
 +int patch_instruction(unsigned int *addr, unsigned int instr);
 +int raw_patch_instruction(unsigned int *addr, unsigned int instr);
++=======
+ int create_branch(struct ppc_inst *instr, const struct ppc_inst *addr,
+ 		  unsigned long target, int flags);
+ int create_cond_branch(struct ppc_inst *instr, const struct ppc_inst *addr,
+ 		       unsigned long target, int flags);
+ int patch_branch(struct ppc_inst *addr, unsigned long target, int flags);
+ int patch_instruction(struct ppc_inst *addr, struct ppc_inst instr);
+ int raw_patch_instruction(struct ppc_inst *addr, struct ppc_inst instr);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  static inline unsigned long patch_site_addr(s32 *site)
  {
@@@ -51,7 -49,7 +61,11 @@@ static inline int patch_branch_site(s3
  static inline int modify_instruction(unsigned int *addr, unsigned int clr,
  				     unsigned int set)
  {
++<<<<<<< HEAD
 +	return patch_instruction(addr, (*addr & ~clr) | set);
++=======
+ 	return patch_instruction((struct ppc_inst *)addr, ppc_inst((*addr & ~clr) | set));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  }
  
  static inline int modify_instruction_site(s32 *site, unsigned int clr, unsigned int set)
@@@ -59,13 -57,13 +73,23 @@@
  	return modify_instruction((unsigned int *)patch_site_addr(site), clr, set);
  }
  
++<<<<<<< HEAD
 +int instr_is_relative_branch(unsigned int instr);
 +int instr_is_relative_link_branch(unsigned int instr);
 +int instr_is_branch_to_addr(const unsigned int *instr, unsigned long addr);
 +unsigned long branch_target(const unsigned int *instr);
 +unsigned int translate_branch(const unsigned int *dest,
 +			      const unsigned int *src);
 +extern bool is_conditional_branch(unsigned int instr);
++=======
+ int instr_is_relative_branch(struct ppc_inst instr);
+ int instr_is_relative_link_branch(struct ppc_inst instr);
+ int instr_is_branch_to_addr(const struct ppc_inst *instr, unsigned long addr);
+ unsigned long branch_target(const struct ppc_inst *instr);
+ int translate_branch(struct ppc_inst *instr, const struct ppc_inst *dest,
+ 		     const struct ppc_inst *src);
+ extern bool is_conditional_branch(struct ppc_inst instr);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  #ifdef CONFIG_PPC_BOOK3E_64
  void __patch_exception(int exc, unsigned long addr);
  #define patch_exception(exc, name) do { \
diff --cc arch/powerpc/kernel/epapr_paravirt.c
index 59e4ba74975d,2ed14d4a47f5..000000000000
--- a/arch/powerpc/kernel/epapr_paravirt.c
+++ b/arch/powerpc/kernel/epapr_paravirt.c
@@@ -48,10 -37,10 +48,15 @@@ static int __init early_init_dt_scan_ep
  		return -1;
  
  	for (i = 0; i < (len / 4); i++) {
++<<<<<<< HEAD
 +		u32 inst = be32_to_cpu(insts[i]);
 +		patch_instruction(epapr_hypercall_start + i, inst);
++=======
+ 		struct ppc_inst inst = ppc_inst(be32_to_cpu(insts[i]));
+ 		patch_instruction((struct ppc_inst *)(epapr_hypercall_start + i), inst);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  #if !defined(CONFIG_64BIT) || defined(CONFIG_PPC_BOOK3E_64)
- 		patch_instruction(epapr_ev_idle_start + i, inst);
+ 		patch_instruction((struct ppc_inst *)(epapr_ev_idle_start + i), inst);
  #endif
  	}
  
diff --cc arch/powerpc/kernel/hw_breakpoint.c
index cb5dfa15ad41,2db9a7ac7bcb..000000000000
--- a/arch/powerpc/kernel/hw_breakpoint.c
+++ b/arch/powerpc/kernel/hw_breakpoint.c
@@@ -223,7 -244,7 +223,11 @@@ dar_range_overlaps(unsigned long dar, i
  static bool stepping_handler(struct pt_regs *regs, struct perf_event *bp,
  			     struct arch_hw_breakpoint *info)
  {
++<<<<<<< HEAD
 +	unsigned int instr = 0;
++=======
+ 	struct ppc_inst instr = ppc_inst(0);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	int ret, type, size;
  	struct instruction_op op;
  	unsigned long addr = info->address;
diff --cc arch/powerpc/kernel/kprobes.c
index e4c5bf33970b,a08ae5803622..000000000000
--- a/arch/powerpc/kernel/kprobes.c
+++ b/arch/powerpc/kernel/kprobes.c
@@@ -151,13 -139,13 +151,21 @@@ NOKPROBE_SYMBOL(arch_prepare_kprobe)
  
  void arch_arm_kprobe(struct kprobe *p)
  {
++<<<<<<< HEAD
 +	patch_instruction(p->addr, BREAKPOINT_INSTRUCTION);
++=======
+ 	patch_instruction((struct ppc_inst *)p->addr, ppc_inst(BREAKPOINT_INSTRUCTION));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  }
  NOKPROBE_SYMBOL(arch_arm_kprobe);
  
  void arch_disarm_kprobe(struct kprobe *p)
  {
++<<<<<<< HEAD
 +	patch_instruction(p->addr, p->opcode);
++=======
+ 	patch_instruction((struct ppc_inst *)p->addr, ppc_inst(p->opcode));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  }
  NOKPROBE_SYMBOL(arch_disarm_kprobe);
  
diff --cc arch/powerpc/kernel/optprobes.c
index 8237884ca389,5a71fef71c22..000000000000
--- a/arch/powerpc/kernel/optprobes.c
+++ b/arch/powerpc/kernel/optprobes.c
@@@ -151,13 -149,15 +152,25 @@@ void arch_remove_optimized_kprobe(struc
  void patch_imm32_load_insns(unsigned int val, kprobe_opcode_t *addr)
  {
  	/* addis r4,0,(insn)@h */
++<<<<<<< HEAD
 +	patch_instruction(addr, PPC_INST_ADDIS | ___PPC_RT(4) |
 +			  ((val >> 16) & 0xffff));
 +	addr++;
 +
 +	/* ori r4,r4,(insn)@l */
 +	patch_instruction(addr, PPC_INST_ORI | ___PPC_RA(4) |
 +			  ___PPC_RS(4) | (val & 0xffff));
++=======
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(4) |
+ 				   ((val >> 16) & 0xffff)));
+ 	addr++;
+ 
+ 	/* ori r4,r4,(insn)@l */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ORI | ___PPC_RA(4) |
+ 				   ___PPC_RS(4) | (val & 0xffff)));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  }
  
  /*
@@@ -167,28 -167,33 +180,58 @@@
  void patch_imm64_load_insns(unsigned long val, kprobe_opcode_t *addr)
  {
  	/* lis r3,(op)@highest */
++<<<<<<< HEAD
 +	patch_instruction(addr, PPC_INST_ADDIS | ___PPC_RT(3) |
 +			  ((val >> 48) & 0xffff));
 +	addr++;
 +
 +	/* ori r3,r3,(op)@higher */
 +	patch_instruction(addr, PPC_INST_ORI | ___PPC_RA(3) |
 +			  ___PPC_RS(3) | ((val >> 32) & 0xffff));
 +	addr++;
 +
 +	/* rldicr r3,r3,32,31 */
 +	patch_instruction(addr, PPC_INST_RLDICR | ___PPC_RA(3) |
 +			  ___PPC_RS(3) | __PPC_SH64(32) | __PPC_ME64(31));
 +	addr++;
 +
 +	/* oris r3,r3,(op)@h */
 +	patch_instruction(addr, PPC_INST_ORIS | ___PPC_RA(3) |
 +			  ___PPC_RS(3) | ((val >> 16) & 0xffff));
 +	addr++;
 +
 +	/* ori r3,r3,(op)@l */
 +	patch_instruction(addr, PPC_INST_ORI | ___PPC_RA(3) |
 +			  ___PPC_RS(3) | (val & 0xffff));
++=======
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(3) |
+ 				   ((val >> 48) & 0xffff)));
+ 	addr++;
+ 
+ 	/* ori r3,r3,(op)@higher */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ORI | ___PPC_RA(3) |
+ 				   ___PPC_RS(3) | ((val >> 32) & 0xffff)));
+ 	addr++;
+ 
+ 	/* rldicr r3,r3,32,31 */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_RLDICR | ___PPC_RA(3) |
+ 				   ___PPC_RS(3) | __PPC_SH64(32) | __PPC_ME64(31)));
+ 	addr++;
+ 
+ 	/* oris r3,r3,(op)@h */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ORIS | ___PPC_RA(3) |
+ 				   ___PPC_RS(3) | ((val >> 16) & 0xffff)));
+ 	addr++;
+ 
+ 	/* ori r3,r3,(op)@l */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ORI | ___PPC_RA(3) |
+ 				   ___PPC_RS(3) | (val & 0xffff)));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  }
  
  int arch_prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)
@@@ -234,7 -239,8 +277,12 @@@
  	size = (TMPL_END_IDX * sizeof(kprobe_opcode_t)) / sizeof(int);
  	pr_devel("Copying template to %p, size %lu\n", buff, size);
  	for (i = 0; i < size; i++) {
++<<<<<<< HEAD
 +		rc = patch_instruction(buff + i, *(optprobe_template_entry + i));
++=======
+ 		rc = patch_instruction((struct ppc_inst *)(buff + i),
+ 				       ppc_inst(*(optprobe_template_entry + i)));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  		if (rc < 0)
  			goto error;
  	}
@@@ -255,19 -261,23 +303,33 @@@
  		goto error;
  	}
  
++<<<<<<< HEAD
 +	branch_op_callback = create_branch((unsigned int *)buff + TMPL_CALL_HDLR_IDX,
 +				(unsigned long)op_callback_addr,
 +				BRANCH_SET_LINK);
 +
 +	branch_emulate_step = create_branch((unsigned int *)buff + TMPL_EMULATE_IDX,
 +				(unsigned long)emulate_step_addr,
 +				BRANCH_SET_LINK);
++=======
+ 	rc = create_branch(&branch_op_callback,
+ 			   (struct ppc_inst *)(buff + TMPL_CALL_HDLR_IDX),
+ 			   (unsigned long)op_callback_addr,
+ 			   BRANCH_SET_LINK);
+ 
+ 	rc |= create_branch(&branch_emulate_step,
+ 			    (struct ppc_inst *)(buff + TMPL_EMULATE_IDX),
+ 			    (unsigned long)emulate_step_addr,
+ 			    BRANCH_SET_LINK);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
 -	if (rc)
 +	if (!branch_op_callback || !branch_emulate_step)
  		goto error;
  
- 	patch_instruction(buff + TMPL_CALL_HDLR_IDX, branch_op_callback);
- 	patch_instruction(buff + TMPL_EMULATE_IDX, branch_emulate_step);
+ 	patch_instruction((struct ppc_inst *)(buff + TMPL_CALL_HDLR_IDX),
+ 			  branch_op_callback);
+ 	patch_instruction((struct ppc_inst *)(buff + TMPL_EMULATE_IDX),
+ 			  branch_emulate_step);
  
  	/*
  	 * 3. load instruction to be emulated into relevant register, and
@@@ -309,6 -319,7 +371,10 @@@ int arch_check_optimized_kprobe(struct 
  
  void arch_optimize_kprobes(struct list_head *oplist)
  {
++<<<<<<< HEAD
++=======
+ 	struct ppc_inst instr;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	struct optimized_kprobe *op;
  	struct optimized_kprobe *tmp;
  
@@@ -319,9 -330,10 +385,16 @@@
  		 */
  		memcpy(op->optinsn.copied_insn, op->kp.addr,
  					       RELATIVEJUMP_SIZE);
++<<<<<<< HEAD
 +		patch_instruction(op->kp.addr,
 +			create_branch((unsigned int *)op->kp.addr,
 +				      (unsigned long)op->optinsn.insn, 0));
++=======
+ 		create_branch(&instr,
+ 			      (struct ppc_inst *)op->kp.addr,
+ 			      (unsigned long)op->optinsn.insn, 0);
+ 		patch_instruction((struct ppc_inst *)op->kp.addr, instr);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  		list_del_init(&op->list);
  	}
  }
diff --cc arch/powerpc/kernel/setup_32.c
index 9036d0eeafa6,15f0a7c84944..000000000000
--- a/arch/powerpc/kernel/setup_32.c
+++ b/arch/powerpc/kernel/setup_32.c
@@@ -94,12 -72,10 +94,17 @@@ notrace unsigned long __init early_init
   * We do the initial parsing of the flat device-tree and prepares
   * for the MMU to be fully initialized.
   */
 +extern unsigned int memset_nocache_branch; /* Insn to be replaced by NOP */
 +
  notrace void __init machine_init(u64 dt_ptr)
  {
++<<<<<<< HEAD
 +	unsigned int *addr = &memset_nocache_branch;
 +	unsigned long insn;
++=======
+ 	struct ppc_inst *addr = (struct ppc_inst *)patch_site_addr(&patch__memset_nocache);
+ 	struct ppc_inst insn;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  	/* Configure static keys first, now that we're relocated. */
  	setup_feature_keys();
diff --cc arch/powerpc/kernel/trace/ftrace.c
index 4bf051d3e21e,3117ed675735..000000000000
--- a/arch/powerpc/kernel/trace/ftrace.c
+++ b/arch/powerpc/kernel/trace/ftrace.c
@@@ -48,7 -49,7 +48,11 @@@ ftrace_call_replace(unsigned long ip, u
  	addr = ppc_function_entry((void *)addr);
  
  	/* if (link) set op to 'bl' else 'b' */
++<<<<<<< HEAD
 +	op = create_branch((unsigned int *)ip, addr, link ? 1 : 0);
++=======
+ 	create_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  	return op;
  }
@@@ -89,27 -90,28 +93,35 @@@ ftrace_modify_code(unsigned long ip, st
   */
  static int test_24bit_addr(unsigned long ip, unsigned long addr)
  {
++<<<<<<< HEAD
 +	addr = ppc_function_entry((void *)addr);
 +
 +	/* use the create_branch to verify that this offset can be branched */
 +	return create_branch((unsigned int *)ip, addr, 0);
++=======
+ 	struct ppc_inst op;
+ 	addr = ppc_function_entry((void *)addr);
+ 
+ 	/* use the create_branch to verify that this offset can be branched */
+ 	return create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  }
  
- static int is_bl_op(unsigned int op)
+ static int is_bl_op(struct ppc_inst op)
  {
 -	return (ppc_inst_val(op) & 0xfc000003) == 0x48000001;
 +	return (op & 0xfc000003) == 0x48000001;
  }
  
- static int is_b_op(unsigned int op)
+ static int is_b_op(struct ppc_inst op)
  {
 -	return (ppc_inst_val(op) & 0xfc000003) == 0x48000000;
 +	return (op & 0xfc000003) == 0x48000000;
  }
  
- static unsigned long find_bl_target(unsigned long ip, unsigned int op)
+ static unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)
  {
 -	int offset;
 +	static int offset;
  
 -	offset = (ppc_inst_val(op) & 0x03fffffc);
 +	offset = (op & 0x03fffffc);
  	/* make it signed */
  	if (offset & 0x02000000)
  		offset |= 0xfe000000;
@@@ -274,9 -278,9 +286,9 @@@ __ftrace_make_nop(struct module *mod
  		return -EINVAL;
  	}
  
 -	op = ppc_inst(PPC_INST_NOP);
 +	op = PPC_INST_NOP;
  
- 	if (patch_instruction((unsigned int *)ip, op))
+ 	if (patch_instruction((struct ppc_inst *)ip, op))
  		return -EPERM;
  
  	return 0;
@@@ -287,6 -291,7 +299,10 @@@
  static unsigned long find_ftrace_tramp(unsigned long ip)
  {
  	int i;
++<<<<<<< HEAD
++=======
+ 	struct ppc_inst instr;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  	/*
  	 * We have the compiler generated long_branch tramps at the end
@@@ -322,8 -328,10 +338,13 @@@ static int add_ftrace_tramp(unsigned lo
   */
  static int setup_mcount_compiler_tramp(unsigned long tramp)
  {
- 	int i, op;
+ 	int i;
+ 	struct ppc_inst op;
  	unsigned long ptr;
++<<<<<<< HEAD
++=======
+ 	struct ppc_inst instr;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	static unsigned long ftrace_plt_tramps[NUM_FTRACE_TRAMPS];
  
  	/* Is this a known long jump tramp? */
@@@ -416,7 -424,7 +437,11 @@@ static int __ftrace_make_nop_kernel(str
  		}
  	}
  
++<<<<<<< HEAD
 +	if (patch_instruction((unsigned int *)ip, PPC_INST_NOP)) {
++=======
+ 	if (patch_instruction((struct ppc_inst *)ip, ppc_inst(PPC_INST_NOP))) {
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  		pr_err("Patching NOP failed.\n");
  		return -EPERM;
  	}
@@@ -498,10 -507,10 +523,10 @@@ expected_nop_sequence(void *ip, struct 
  }
  #else
  static int
- expected_nop_sequence(void *ip, unsigned int op0, unsigned int op1)
+ expected_nop_sequence(void *ip, struct ppc_inst op0, struct ppc_inst op1)
  {
  	/* look for patched "NOP" on ppc64 with -mprofile-kernel */
 -	if (!ppc_inst_equal(op0, ppc_inst(PPC_INST_NOP)))
 +	if (op0 != PPC_INST_NOP)
  		return 0;
  	return 1;
  }
@@@ -510,7 -519,8 +535,12 @@@
  static int
  __ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)
  {
++<<<<<<< HEAD
 +	unsigned int op[2];
++=======
+ 	struct ppc_inst op[2];
+ 	struct ppc_inst instr;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	void *ip = (void *)rec->ip;
  	unsigned long entry, ptr, tramp;
  	struct module *mod = rec->arch.mod;
@@@ -574,7 -584,8 +604,12 @@@
  static int
  __ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)
  {
++<<<<<<< HEAD
 +	unsigned int op;
++=======
+ 	int err;
+ 	struct ppc_inst op;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	unsigned long ip = rec->ip;
  
  	/* read where this goes */
@@@ -594,9 -605,9 +629,15 @@@
  	}
  
  	/* create the branch to the trampoline */
++<<<<<<< HEAD
 +	op = create_branch((unsigned int *)ip,
 +			   rec->arch.mod->arch.tramp, BRANCH_SET_LINK);
 +	if (!op) {
++=======
+ 	err = create_branch(&op, (struct ppc_inst *)ip,
+ 			    rec->arch.mod->arch.tramp, BRANCH_SET_LINK);
+ 	if (err) {
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  		pr_err("REL24 out of range!\n");
  		return -EINVAL;
  	}
@@@ -776,7 -787,7 +817,11 @@@ __ftrace_modify_call(struct dyn_ftrace 
  	}
  
  	/* Ensure branch is within 24 bits */
++<<<<<<< HEAD
 +	if (!create_branch((unsigned int *)ip, tramp, BRANCH_SET_LINK)) {
++=======
+ 	if (create_branch(&op, (struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  		pr_err("Branch out of range\n");
  		return -EINVAL;
  	}
diff --cc arch/powerpc/kernel/vecemu.c
index 4acd3fb2b38e,3dd70eeb10c5..000000000000
--- a/arch/powerpc/kernel/vecemu.c
+++ b/arch/powerpc/kernel/vecemu.c
@@@ -260,21 -261,24 +260,26 @@@ static unsigned int rfin(unsigned int x
  
  int emulate_altivec(struct pt_regs *regs)
  {
++<<<<<<< HEAD
 +	unsigned int instr, i;
++=======
+ 	struct ppc_inst instr;
+ 	unsigned int i, word;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	unsigned int va, vb, vc, vd;
  	vector128 *vrs;
  
- 	if (get_user(instr, (unsigned int __user *) regs->nip))
+ 	if (get_user(instr.val, (unsigned int __user *)regs->nip))
  		return -EFAULT;
 -
 -	word = ppc_inst_val(instr);
 -	if (ppc_inst_primary_opcode(instr) != 4)
 +	if ((instr >> 26) != 4)
  		return -EINVAL;		/* not an altivec instruction */
 -	vd = (word >> 21) & 0x1f;
 -	va = (word >> 16) & 0x1f;
 -	vb = (word >> 11) & 0x1f;
 -	vc = (word >> 6) & 0x1f;
 +	vd = (instr >> 21) & 0x1f;
 +	va = (instr >> 16) & 0x1f;
 +	vb = (instr >> 11) & 0x1f;
 +	vc = (instr >> 6) & 0x1f;
  
  	vrs = current->thread.vr_state.vr;
 -	switch (word & 0x3f) {
 +	switch (instr & 0x3f) {
  	case 10:
  		switch (vc) {
  		case 0:	/* vaddfp */
diff --cc arch/powerpc/lib/code-patching.c
index 42fdadac6587,1dff9d9d6645..000000000000
--- a/arch/powerpc/lib/code-patching.c
+++ b/arch/powerpc/lib/code-patching.c
@@@ -22,9 -17,10 +22,9 @@@
  #include <asm/page.h>
  #include <asm/code-patching.h>
  #include <asm/setup.h>
 -#include <asm/inst.h>
  
- static int __patch_instruction(unsigned int *exec_addr, unsigned int instr,
- 			       unsigned int *patch_addr)
+ static int __patch_instruction(struct ppc_inst *exec_addr, struct ppc_inst instr,
+ 			       struct ppc_inst *patch_addr)
  {
  	int err = 0;
  
@@@ -199,9 -194,12 +198,16 @@@ int patch_instruction(struct ppc_inst *
  }
  NOKPROBE_SYMBOL(patch_instruction);
  
- int patch_branch(unsigned int *addr, unsigned long target, int flags)
+ int patch_branch(struct ppc_inst *addr, unsigned long target, int flags)
  {
++<<<<<<< HEAD
 +	return patch_instruction(addr, create_branch(addr, target, flags));
++=======
+ 	struct ppc_inst instr;
+ 
+ 	create_branch(&instr, addr, target, flags);
+ 	return patch_instruction(addr, instr);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  }
  
  bool is_offset_in_branch_range(long offset)
@@@ -230,9 -228,9 +236,9 @@@
   * Helper to check if a given instruction is a conditional branch
   * Derived from the conditional checks in analyse_instr()
   */
- bool is_conditional_branch(unsigned int instr)
+ bool is_conditional_branch(struct ppc_inst instr)
  {
 -	unsigned int opcode = ppc_inst_primary_opcode(instr);
 +	unsigned int opcode = instr >> 26;
  
  	if (opcode == 16)       /* bc, bca, bcl, bcla */
  		return true;
@@@ -248,30 -246,30 +254,49 @@@
  }
  NOKPROBE_SYMBOL(is_conditional_branch);
  
++<<<<<<< HEAD
 +unsigned int create_branch(const unsigned int *addr,
 +			   unsigned long target, int flags)
++=======
+ int create_branch(struct ppc_inst *instr,
+ 		  const struct ppc_inst *addr,
+ 		  unsigned long target, int flags)
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  {
 +	unsigned int instruction;
  	long offset;
  
++<<<<<<< HEAD
++=======
+ 	*instr = ppc_inst(0);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	offset = target;
  	if (! (flags & BRANCH_ABSOLUTE))
  		offset = offset - (unsigned long)addr;
  
  	/* Check we can represent the target in the instruction format */
  	if (!is_offset_in_branch_range(offset))
 -		return 1;
 +		return 0;
  
  	/* Mask out the flags and target, so they don't step on each other. */
++<<<<<<< HEAD
 +	instruction = 0x48000000 | (flags & 0x3) | (offset & 0x03FFFFFC);
++=======
+ 	*instr = ppc_inst(0x48000000 | (flags & 0x3) | (offset & 0x03FFFFFC));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
 -	return 0;
 +	return instruction;
  }
  
++<<<<<<< HEAD
 +unsigned int create_cond_branch(const unsigned int *addr,
 +				unsigned long target, int flags)
++=======
+ int create_cond_branch(struct ppc_inst *instr, const struct ppc_inst *addr,
+ 		       unsigned long target, int flags)
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  {
 +	unsigned int instruction;
  	long offset;
  
  	offset = target;
@@@ -280,20 -278,20 +305,24 @@@
  
  	/* Check we can represent the target in the instruction format */
  	if (offset < -0x8000 || offset > 0x7FFF || offset & 0x3)
 -		return 1;
 +		return 0;
  
  	/* Mask out the flags and target, so they don't step on each other. */
++<<<<<<< HEAD
 +	instruction = 0x40000000 | (flags & 0x3FF0003) | (offset & 0xFFFC);
++=======
+ 	*instr = ppc_inst(0x40000000 | (flags & 0x3FF0003) | (offset & 0xFFFC));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
 -	return 0;
 +	return instruction;
  }
  
- static unsigned int branch_opcode(unsigned int instr)
+ static unsigned int branch_opcode(struct ppc_inst instr)
  {
 -	return ppc_inst_primary_opcode(instr) & 0x3F;
 +	return (instr >> 26) & 0x3F;
  }
  
- static int instr_is_branch_iform(unsigned int instr)
+ static int instr_is_branch_iform(struct ppc_inst instr)
  {
  	return branch_opcode(instr) == 18;
  }
@@@ -303,20 -301,20 +332,20 @@@ static int instr_is_branch_bform(struc
  	return branch_opcode(instr) == 16;
  }
  
- int instr_is_relative_branch(unsigned int instr)
+ int instr_is_relative_branch(struct ppc_inst instr)
  {
 -	if (ppc_inst_val(instr) & BRANCH_ABSOLUTE)
 +	if (instr & BRANCH_ABSOLUTE)
  		return 0;
  
  	return instr_is_branch_iform(instr) || instr_is_branch_bform(instr);
  }
  
- int instr_is_relative_link_branch(unsigned int instr)
+ int instr_is_relative_link_branch(struct ppc_inst instr)
  {
 -	return instr_is_relative_branch(instr) && (ppc_inst_val(instr) & BRANCH_SET_LINK);
 +	return instr_is_relative_branch(instr) && (instr & BRANCH_SET_LINK);
  }
  
- static unsigned long branch_iform_target(const unsigned int *instr)
+ static unsigned long branch_iform_target(const struct ppc_inst *instr)
  {
  	signed long imm;
  
@@@ -366,7 -364,8 +395,12 @@@ int instr_is_branch_to_addr(const struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +unsigned int translate_branch(const unsigned int *dest, const unsigned int *src)
++=======
+ int translate_branch(struct ppc_inst *instr, const struct ppc_inst *dest,
+ 		     const struct ppc_inst *src)
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  {
  	unsigned long target;
  
@@@ -408,7 -407,8 +442,12 @@@ static void __init test_trampoline(void
  
  static void __init test_branch_iform(void)
  {
++<<<<<<< HEAD
 +	unsigned int instr;
++=======
+ 	int err;
+ 	struct ppc_inst instr;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	unsigned long addr;
  
  	addr = (unsigned long)&instr;
@@@ -483,20 -483,24 +522,25 @@@
  
  static void __init test_create_function_call(void)
  {
- 	unsigned int *iptr;
+ 	struct ppc_inst *iptr;
  	unsigned long dest;
++<<<<<<< HEAD
++=======
+ 	struct ppc_inst instr;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  	/* Check we can create a function call */
- 	iptr = (unsigned int *)ppc_function_entry(test_trampoline);
+ 	iptr = (struct ppc_inst *)ppc_function_entry(test_trampoline);
  	dest = ppc_function_entry(test_create_function_call);
 -	create_branch(&instr, iptr, dest, BRANCH_SET_LINK);
 -	patch_instruction(iptr, instr);
 +	patch_instruction(iptr, create_branch(iptr, dest, BRANCH_SET_LINK));
  	check(instr_is_branch_to_addr(iptr, dest));
  }
  
  static void __init test_branch_bform(void)
  {
 -	int err;
  	unsigned long addr;
- 	unsigned int *iptr, instr, flags;
+ 	struct ppc_inst *iptr, instr;
+ 	unsigned int flags;
  
  	iptr = &instr;
  	addr = (unsigned long)iptr;
@@@ -566,7 -570,8 +610,12 @@@
  static void __init test_translate_branch(void)
  {
  	unsigned long addr;
++<<<<<<< HEAD
 +	unsigned int *p, *q;
++=======
+ 	struct ppc_inst *p, *q;
+ 	struct ppc_inst instr;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	void *buf;
  
  	buf = vmalloc(PAGE_ALIGN(0x2000000 + 1));
diff --cc arch/powerpc/lib/feature-fixups.c
index e613b02bb2f0,fd978b8ee6d6..000000000000
--- a/arch/powerpc/lib/feature-fixups.c
+++ b/arch/powerpc/lib/feature-fixups.c
@@@ -42,13 -39,14 +42,18 @@@ static struct ppc_inst *calc_addr(struc
  	 * the start of the alt_entry, to support the VDSO. This
  	 * routine converts that back into an actual address.
  	 */
- 	return (unsigned int *)((unsigned long)fcur + offset);
+ 	return (struct ppc_inst *)((unsigned long)fcur + offset);
  }
  
- static int patch_alt_instruction(unsigned int *src, unsigned int *dest,
- 				 unsigned int *alt_start, unsigned int *alt_end)
+ static int patch_alt_instruction(struct ppc_inst *src, struct ppc_inst *dest,
+ 				 struct ppc_inst *alt_start, struct ppc_inst *alt_end)
  {
++<<<<<<< HEAD
 +	unsigned int instr;
++=======
+ 	int err;
+ 	struct ppc_inst instr;
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  	instr = *src;
  
@@@ -149,15 -147,17 +154,27 @@@ void do_stf_entry_barrier_fixups(enum s
  
  		pr_devel("patching dest %lx\n", (unsigned long)dest);
  
++<<<<<<< HEAD
 +		patch_instruction(dest, instrs[0]);
++=======
+ 		patch_instruction((struct ppc_inst *)dest, ppc_inst(instrs[0]));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  		if (types & STF_BARRIER_FALLBACK)
- 			patch_branch(dest + 1, (unsigned long)&stf_barrier_fallback,
+ 			patch_branch((struct ppc_inst *)(dest + 1),
+ 				     (unsigned long)&stf_barrier_fallback,
  				     BRANCH_SET_LINK);
  		else
++<<<<<<< HEAD
 +			patch_instruction(dest + 1, instrs[1]);
 +
 +		patch_instruction(dest + 2, instrs[2]);
++=======
+ 			patch_instruction((struct ppc_inst *)(dest + 1),
+ 					  ppc_inst(instrs[1]));
+ 
+ 		patch_instruction((struct ppc_inst *)(dest + 2), ppc_inst(instrs[2]));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	}
  
  	printk(KERN_DEBUG "stf-barrier: patched %d entry locations (%s barrier)\n", i,
@@@ -210,12 -210,12 +227,21 @@@ void do_stf_exit_barrier_fixups(enum st
  
  		pr_devel("patching dest %lx\n", (unsigned long)dest);
  
++<<<<<<< HEAD
 +		patch_instruction(dest, instrs[0]);
 +		patch_instruction(dest + 1, instrs[1]);
 +		patch_instruction(dest + 2, instrs[2]);
 +		patch_instruction(dest + 3, instrs[3]);
 +		patch_instruction(dest + 4, instrs[4]);
 +		patch_instruction(dest + 5, instrs[5]);
++=======
+ 		patch_instruction((struct ppc_inst *)dest, ppc_inst(instrs[0]));
+ 		patch_instruction((struct ppc_inst *)(dest + 1), ppc_inst(instrs[1]));
+ 		patch_instruction((struct ppc_inst *)(dest + 2), ppc_inst(instrs[2]));
+ 		patch_instruction((struct ppc_inst *)(dest + 3), ppc_inst(instrs[3]));
+ 		patch_instruction((struct ppc_inst *)(dest + 4), ppc_inst(instrs[4]));
+ 		patch_instruction((struct ppc_inst *)(dest + 5), ppc_inst(instrs[5]));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	}
  	printk(KERN_DEBUG "stf-barrier: patched %d exit locations (%s barrier)\n", i,
  		(types == STF_BARRIER_NONE)                  ? "no" :
@@@ -263,9 -263,9 +289,15 @@@ void do_rfi_flush_fixups(enum l1d_flush
  
  		pr_devel("patching dest %lx\n", (unsigned long)dest);
  
++<<<<<<< HEAD
 +		patch_instruction(dest, instrs[0]);
 +		patch_instruction(dest + 1, instrs[1]);
 +		patch_instruction(dest + 2, instrs[2]);
++=======
+ 		patch_instruction((struct ppc_inst *)dest, ppc_inst(instrs[0]));
+ 		patch_instruction((struct ppc_inst *)(dest + 1), ppc_inst(instrs[1]));
+ 		patch_instruction((struct ppc_inst *)(dest + 2), ppc_inst(instrs[2]));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	}
  
  	printk(KERN_DEBUG "rfi-flush: patched %d locations (%s flush)\n", i,
@@@ -298,7 -298,7 +330,11 @@@ void do_barrier_nospec_fixups_range(boo
  		dest = (void *)start + *start;
  
  		pr_devel("patching dest %lx\n", (unsigned long)dest);
++<<<<<<< HEAD
 +		patch_instruction(dest, instr);
++=======
+ 		patch_instruction((struct ppc_inst *)dest, ppc_inst(instr));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	}
  
  	printk(KERN_DEBUG "barrier-nospec: patched %d locations\n", i);
@@@ -341,12 -341,35 +377,43 @@@ void do_barrier_nospec_fixups_range(boo
  		dest = (void *)start + *start;
  
  		pr_devel("patching dest %lx\n", (unsigned long)dest);
++<<<<<<< HEAD
 +		patch_instruction(dest, instr[0]);
 +		patch_instruction(dest + 1, instr[1]);
++=======
+ 		patch_instruction((struct ppc_inst *)dest, ppc_inst(instr[0]));
+ 		patch_instruction((struct ppc_inst *)(dest + 1), ppc_inst(instr[1]));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	}
  
  	printk(KERN_DEBUG "barrier-nospec: patched %d locations\n", i);
  }
++<<<<<<< HEAD
++=======
+ 
+ static void patch_btb_flush_section(long *curr)
+ {
+ 	unsigned int *start, *end;
+ 
+ 	start = (void *)curr + *curr;
+ 	end = (void *)curr + *(curr + 1);
+ 	for (; start < end; start++) {
+ 		pr_devel("patching dest %lx\n", (unsigned long)start);
+ 		patch_instruction((struct ppc_inst *)start, ppc_inst(PPC_INST_NOP));
+ 	}
+ }
+ 
+ void do_btb_flush_fixups(void)
+ {
+ 	long *start, *end;
+ 
+ 	start = PTRRELOC(&__start__btb_flush_fixup);
+ 	end = PTRRELOC(&__stop__btb_flush_fixup);
+ 
+ 	for (; start < end; start += 2)
+ 		patch_btb_flush_section(start);
+ }
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  #endif /* CONFIG_PPC_FSL_BOOK3E */
  
  void do_lwsync_fixups(unsigned long value, void *fixup_start, void *fixup_end)
diff --cc arch/powerpc/platforms/86xx/mpc86xx_smp.c
index 9f2c1ecc85c3,dba3aa73c062..000000000000
--- a/arch/powerpc/platforms/86xx/mpc86xx_smp.c
+++ b/arch/powerpc/platforms/86xx/mpc86xx_smp.c
@@@ -86,7 -83,7 +86,11 @@@ smp_86xx_kick_cpu(int nr
  		mdelay(1);
  
  	/* Restore the exception vector */
++<<<<<<< HEAD
 +	patch_instruction(vector, save_vector);
++=======
+ 	patch_instruction((struct ppc_inst *)vector, ppc_inst(save_vector));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  	local_irq_restore(flags);
  
diff --cc arch/powerpc/platforms/powermac/smp.c
index 35be6e0b886d,9969c07035b6..000000000000
--- a/arch/powerpc/platforms/powermac/smp.c
+++ b/arch/powerpc/platforms/powermac/smp.c
@@@ -832,7 -827,7 +832,11 @@@ static int smp_core99_kick_cpu(int nr
  	mdelay(1);
  
  	/* Restore our exception vector */
++<<<<<<< HEAD
 +	patch_instruction(vector, save_vector);
++=======
+ 	patch_instruction((struct ppc_inst *)vector, ppc_inst(save_vector));
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  
  	local_irq_restore(flags);
  	if (ppc_md.progress) ppc_md.progress("smp_core99_kick_cpu done", 0x347);
diff --cc arch/powerpc/xmon/xmon.c
index 3ba3f8df7d8d,2e3b15813cf1..000000000000
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@@ -891,9 -947,9 +891,9 @@@ static void remove_bpts(void
  		if ((bp->enabled & (BP_TRAP|BP_CIABR)) != BP_TRAP)
  			continue;
  		if (mread(bp->address, &instr, 4) == 4
 -		    && ppc_inst_equal(instr, ppc_inst(bpinstr))
 +		    && instr == bpinstr
  		    && patch_instruction(
- 			(unsigned int *)bp->address, bp->instr[0]) != 0)
+ 			(struct ppc_inst *)bp->address, bp->instr[0]) != 0)
  			printf("Couldn't remove breakpoint at %lx\n",
  			       bp->address);
  	}
@@@ -2739,7 -2848,7 +2739,11 @@@ generic_inst_dump(unsigned long adr, lo
  {
  	int nr, dotted;
  	unsigned long first_adr;
++<<<<<<< HEAD
 +	unsigned int inst, last_inst = 0;
++=======
+ 	struct ppc_inst inst, last_inst = ppc_inst(0);
++>>>>>>> 94afd069d937 (powerpc: Use a datatype for instructions)
  	unsigned char val[4];
  
  	dotted = 0;
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/include/asm/code-patching.h
* Unmerged path arch/powerpc/include/asm/inst.h
diff --git a/arch/powerpc/include/asm/sstep.h b/arch/powerpc/include/asm/sstep.h
index 4547891a684b..752d694953e2 100644
--- a/arch/powerpc/include/asm/sstep.h
+++ b/arch/powerpc/include/asm/sstep.h
@@ -6,6 +6,7 @@
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  */
+#include <asm/inst.h>
 
 struct pt_regs;
 
@@ -136,7 +137,7 @@ union vsx_reg {
  * otherwise.
  */
 extern int analyse_instr(struct instruction_op *op, const struct pt_regs *regs,
-			 unsigned int instr);
+			 struct ppc_inst instr);
 
 /*
  * Emulate an instruction that can be executed just by updating
@@ -153,7 +154,7 @@ void emulate_update_regs(struct pt_regs *reg, struct instruction_op *op);
  * 0 if it could not be emulated, or -1 for an instruction that
  * should not be emulated (rfid, mtmsrd clearing MSR_RI, etc.).
  */
-extern int emulate_step(struct pt_regs *regs, unsigned int instr);
+extern int emulate_step(struct pt_regs *regs, struct ppc_inst instr);
 
 /*
  * Emulate a load or store instruction by reading/writing the
diff --git a/arch/powerpc/include/asm/uprobes.h b/arch/powerpc/include/asm/uprobes.h
index 7422a999a39a..a0a8f2a922a3 100644
--- a/arch/powerpc/include/asm/uprobes.h
+++ b/arch/powerpc/include/asm/uprobes.h
@@ -24,6 +24,7 @@
 
 #include <linux/notifier.h>
 #include <asm/probes.h>
+#include <asm/inst.h>
 
 typedef ppc_opcode_t uprobe_opcode_t;
 
@@ -36,8 +37,8 @@ typedef ppc_opcode_t uprobe_opcode_t;
 
 struct arch_uprobe {
 	union {
-		u32	insn;
-		u32	ixol;
+		struct ppc_inst	insn;
+		struct ppc_inst	ixol;
 	};
 };
 
diff --git a/arch/powerpc/kernel/align.c b/arch/powerpc/kernel/align.c
index 0d1b6370bae0..493f48554ecc 100644
--- a/arch/powerpc/kernel/align.c
+++ b/arch/powerpc/kernel/align.c
@@ -108,7 +108,7 @@ static struct aligninfo spe_aligninfo[32] = {
  * so we don't need the address swizzling.
  */
 static int emulate_spe(struct pt_regs *regs, unsigned int reg,
-		       unsigned int instr)
+		       struct ppc_inst ppc_instr)
 {
 	int ret;
 	union {
@@ -119,8 +119,9 @@ static int emulate_spe(struct pt_regs *regs, unsigned int reg,
 	} data, temp;
 	unsigned char __user *p, *addr;
 	unsigned long *evr = &current->thread.evr[reg];
-	unsigned int nb, flags;
+	unsigned int nb, flags, instr;
 
+	instr = ppc_inst_val(ppc_instr);
 	instr = (instr >> 1) & 0x1f;
 
 	/* DAR has the operand effective address */
@@ -293,7 +294,7 @@ static int emulate_spe(struct pt_regs *regs, unsigned int reg,
 
 int fix_alignment(struct pt_regs *regs)
 {
-	unsigned int instr;
+	struct ppc_inst instr;
 	struct instruction_op op;
 	int r, type;
 
@@ -303,7 +304,7 @@ int fix_alignment(struct pt_regs *regs)
 	 */
 	CHECK_FULL_REGS(regs);
 
-	if (unlikely(__get_user(instr, (unsigned int __user *)regs->nip)))
+	if (unlikely(__get_user(instr.val, (unsigned int __user *)regs->nip)))
 		return -EFAULT;
 	if ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {
 		/* We don't handle PPC little-endian any more... */
diff --git a/arch/powerpc/kernel/crash_dump.c b/arch/powerpc/kernel/crash_dump.c
index bbdc4706c159..d3ee8379da58 100644
--- a/arch/powerpc/kernel/crash_dump.c
+++ b/arch/powerpc/kernel/crash_dump.c
@@ -36,7 +36,7 @@ void __init reserve_kdump_trampoline(void)
 
 static void __init create_trampoline(unsigned long addr)
 {
-	unsigned int *p = (unsigned int *)addr;
+	struct ppc_inst *p = (struct ppc_inst *)addr;
 
 	/* The maximum range of a single instruction branch, is the current
 	 * instruction's address + (32 MB - 4) bytes. For the trampoline we
* Unmerged path arch/powerpc/kernel/epapr_paravirt.c
* Unmerged path arch/powerpc/kernel/hw_breakpoint.c
diff --git a/arch/powerpc/kernel/jump_label.c b/arch/powerpc/kernel/jump_label.c
index 6472472093d0..4b3f771d50dc 100644
--- a/arch/powerpc/kernel/jump_label.c
+++ b/arch/powerpc/kernel/jump_label.c
@@ -15,7 +15,7 @@
 void arch_jump_label_transform(struct jump_entry *entry,
 			       enum jump_label_type type)
 {
-	u32 *addr = (u32 *)(unsigned long)entry->code;
+	struct ppc_inst *addr = (struct ppc_inst *)(unsigned long)entry->code;
 
 	if (type == JUMP_LABEL_JMP)
 		patch_branch(addr, entry->target, 0);
diff --git a/arch/powerpc/kernel/kgdb.c b/arch/powerpc/kernel/kgdb.c
index 59c578f865aa..5fb8687a6ac7 100644
--- a/arch/powerpc/kernel/kgdb.c
+++ b/arch/powerpc/kernel/kgdb.c
@@ -446,7 +446,7 @@ int kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)
 {
 	int err;
 	unsigned int instr;
-	unsigned int *addr = (unsigned int *)bpt->bpt_addr;
+	struct ppc_inst *addr = (struct ppc_inst *)bpt->bpt_addr;
 
 	err = probe_kernel_address(addr, instr);
 	if (err)
@@ -465,7 +465,7 @@ int kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)
 {
 	int err;
 	unsigned int instr = *(unsigned int *)bpt->saved_instr;
-	unsigned int *addr = (unsigned int *)bpt->bpt_addr;
+	struct ppc_inst *addr = (struct ppc_inst *)bpt->bpt_addr;
 
 	err = patch_instruction(addr, instr);
 	if (err)
* Unmerged path arch/powerpc/kernel/kprobes.c
diff --git a/arch/powerpc/kernel/mce_power.c b/arch/powerpc/kernel/mce_power.c
index 18d2eb779254..db351f06c0d5 100644
--- a/arch/powerpc/kernel/mce_power.c
+++ b/arch/powerpc/kernel/mce_power.c
@@ -33,6 +33,7 @@
 #include <asm/sstep.h>
 #include <asm/exception-64s.h>
 #include <asm/extable.h>
+#include <asm/inst.h>
 
 /*
  * Convert an address related to an mm to a PFN. NOTE: we are in real
@@ -357,7 +358,7 @@ static int mce_find_instr_ea_and_phys(struct pt_regs *regs, uint64_t *addr,
 	 * in real-mode is tricky and can lead to recursive
 	 * faults
 	 */
-	int instr;
+	struct ppc_inst instr;
 	unsigned long pfn, instr_addr;
 	struct instruction_op op;
 	struct pt_regs tmp = *regs;
@@ -365,7 +366,7 @@ static int mce_find_instr_ea_and_phys(struct pt_regs *regs, uint64_t *addr,
 	pfn = addr_to_pfn(regs, regs->nip);
 	if (pfn != ULONG_MAX) {
 		instr_addr = (pfn << PAGE_SHIFT) + (regs->nip & ~PAGE_MASK);
-		instr = *(unsigned int *)(instr_addr);
+		instr = *(struct ppc_inst *)(instr_addr);
 		if (!analyse_instr(&op, &tmp, instr)) {
 			pfn = addr_to_pfn(regs, op.ea);
 			*addr = op.ea;
* Unmerged path arch/powerpc/kernel/optprobes.c
* Unmerged path arch/powerpc/kernel/setup_32.c
* Unmerged path arch/powerpc/kernel/trace/ftrace.c
* Unmerged path arch/powerpc/kernel/vecemu.c
* Unmerged path arch/powerpc/lib/code-patching.c
* Unmerged path arch/powerpc/lib/feature-fixups.c
diff --git a/arch/powerpc/lib/sstep.c b/arch/powerpc/lib/sstep.c
index 65f8c55bf6ff..3c0cf6f0514d 100644
--- a/arch/powerpc/lib/sstep.c
+++ b/arch/powerpc/lib/sstep.c
@@ -1167,7 +1167,7 @@ static nokprobe_inline int trap_compare(long v1, long v2)
  * otherwise.
  */
 int analyse_instr(struct instruction_op *op, const struct pt_regs *regs,
-		  unsigned int instr)
+		  struct ppc_inst instr)
 {
 	unsigned int opcode, ra, rb, rc, rd, spr, u;
 	unsigned long int imm;
@@ -3042,7 +3042,7 @@ NOKPROBE_SYMBOL(emulate_loadstore);
  * or -1 if the instruction is one that should not be stepped,
  * such as an rfid, or a mtmsrd that would clear MSR_RI.
  */
-int emulate_step(struct pt_regs *regs, unsigned int instr)
+int emulate_step(struct pt_regs *regs, struct ppc_inst instr)
 {
 	struct instruction_op op;
 	int r, err, type;
diff --git a/arch/powerpc/lib/test_emulate_step.c b/arch/powerpc/lib/test_emulate_step.c
index 91111c36f589..31789a4dd6a6 100644
--- a/arch/powerpc/lib/test_emulate_step.c
+++ b/arch/powerpc/lib/test_emulate_step.c
@@ -465,7 +465,7 @@ struct compute_test {
 	struct {
 		char *descr;
 		unsigned long flags;
-		unsigned int instr;
+		struct ppc_inst instr;
 		struct pt_regs regs;
 	} subtests[MAX_SUBTESTS + 1];
 };
@@ -846,7 +846,7 @@ static struct compute_test compute_tests[] = {
 };
 
 static int __init emulate_compute_instr(struct pt_regs *regs,
-					unsigned int instr)
+					struct ppc_inst instr)
 {
 	struct instruction_op op;
 
@@ -864,7 +864,7 @@ static int __init emulate_compute_instr(struct pt_regs *regs,
 }
 
 static int __init execute_compute_instr(struct pt_regs *regs,
-					unsigned int instr)
+					struct ppc_inst instr)
 {
 	extern int exec_instr(struct pt_regs *regs);
 	extern s32 patch__exec_instr;
@@ -895,7 +895,8 @@ static void __init run_tests_compute(void)
 	unsigned long flags;
 	struct compute_test *test;
 	struct pt_regs *regs, exp, got;
-	unsigned int i, j, k, instr;
+	unsigned int i, j, k;
+	struct ppc_inst instr;
 	bool ignore_gpr, ignore_xer, ignore_ccr, passed;
 
 	for (i = 0; i < ARRAY_SIZE(compute_tests); i++) {
diff --git a/arch/powerpc/mm/fault.c b/arch/powerpc/mm/fault.c
index e1833a2622c5..c6b3273eeb09 100644
--- a/arch/powerpc/mm/fault.c
+++ b/arch/powerpc/mm/fault.c
@@ -70,7 +70,7 @@ static inline bool notify_page_fault(struct pt_regs *regs)
  * Check whether the instruction inst is a store using
  * an update addressing form which will update r1.
  */
-static bool store_updates_sp(unsigned int inst)
+static bool store_updates_sp(struct ppc_inst inst)
 {
 	/* check for 1 in the rA field */
 	if (((inst >> 16) & 0x1f) != 1)
@@ -303,7 +303,7 @@ static bool bad_stack_expansion(struct pt_regs *regs, unsigned long address,
 
 		if ((flags & FAULT_FLAG_WRITE) && (flags & FAULT_FLAG_USER) &&
 		    access_ok(nip, sizeof(*nip))) {
-			unsigned int inst;
+			struct ppc_inst inst;
 
 			if (!probe_user_read(&inst, nip, sizeof(inst)))
 				return !store_updates_sp(inst);
diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c
index 06537b44b85a..a53da4b20d27 100644
--- a/arch/powerpc/perf/core-book3s.c
+++ b/arch/powerpc/perf/core-book3s.c
@@ -425,14 +425,14 @@ static __u64 power_pmu_bhrb_to(u64 addr)
 		if (probe_kernel_read(&instr, (void *)addr, sizeof(instr)))
 			return 0;
 
-		return branch_target(&instr);
+		return branch_target((struct ppc_inst *)&instr);
 	}
 
 	/* Userspace: need copy instruction here then translate it */
 	if (probe_user_read(&instr, (unsigned int __user *)addr, sizeof(instr)))
 		return 0;
 
-	target = branch_target(&instr);
+	target = branch_target((struct ppc_inst *)&instr);
 	if ((!target) || (instr & BRANCH_ABSOLUTE))
 		return target;
 
* Unmerged path arch/powerpc/platforms/86xx/mpc86xx_smp.c
* Unmerged path arch/powerpc/platforms/powermac/smp.c
* Unmerged path arch/powerpc/xmon/xmon.c
diff --git a/arch/powerpc/xmon/xmon_bpts.h b/arch/powerpc/xmon/xmon_bpts.h
index b7e94375db86..57e6fb03de48 100644
--- a/arch/powerpc/xmon/xmon_bpts.h
+++ b/arch/powerpc/xmon/xmon_bpts.h
@@ -4,11 +4,11 @@
 
 #define NBPTS	256
 #ifndef __ASSEMBLY__
-#define BPT_SIZE	(sizeof(unsigned int) * 2)
-#define BPT_WORDS	(BPT_SIZE / sizeof(unsigned int))
+#include <asm/inst.h>
+#define BPT_SIZE	(sizeof(struct ppc_inst) * 2)
+#define BPT_WORDS	(BPT_SIZE / sizeof(struct ppc_inst))
 
 extern unsigned int bpt_table[NBPTS * BPT_WORDS];
-
 #endif /* __ASSEMBLY__ */
 
 #endif /* XMON_BPTS_H */
