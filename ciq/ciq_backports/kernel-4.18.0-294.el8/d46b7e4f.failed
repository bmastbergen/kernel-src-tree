net: phylink: rename mac_link_state() op to mac_pcs_get_state()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit d46b7e4fb06037a61415f5b6964fcf632ee1dc34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d46b7e4f.failed

Rename the mac_link_state() method to mac_pcs_get_state() to make it
clear that it should be returning the MACs PCS current state, which
is used for inband negotiation rather than just reading back what the
MAC has been configured for. Update the documentation to explicitly
mention that this is for inband.

We drop the return value as well; most of phylink doesn't check the
return value and it is not clear what it should do on error - instead
arrange for state->link to be false.

	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
(cherry picked from commit d46b7e4fb06037a61415f5b6964fcf632ee1dc34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/cadence/macb_main.c
#	drivers/net/ethernet/mediatek/mtk_eth_soc.c
#	drivers/net/ethernet/xilinx/xilinx_axienet_main.c
#	net/dsa/dsa_priv.h
#	net/dsa/port.c
diff --cc drivers/net/ethernet/cadence/macb_main.c
index eaaa8bf3961f,d5ae2e1e0b0e..000000000000
--- a/drivers/net/ethernet/cadence/macb_main.c
+++ b/drivers/net/ethernet/cadence/macb_main.c
@@@ -400,118 -453,178 +400,247 @@@ static void macb_set_tx_clk(struct clk 
  		netdev_err(dev, "adjusting tx_clk failed.\n");
  }
  
 -static void macb_validate(struct phylink_config *config,
 -			  unsigned long *supported,
 -			  struct phylink_link_state *state)
 +static void macb_handle_link_change(struct net_device *dev)
  {
++<<<<<<< HEAD
 +	struct macb *bp = netdev_priv(dev);
 +	struct phy_device *phydev = dev->phydev;
++=======
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 	struct macb *bp = netdev_priv(ndev);
+ 
+ 	/* We only support MII, RMII, GMII, RGMII & SGMII. */
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != PHY_INTERFACE_MODE_MII &&
+ 	    state->interface != PHY_INTERFACE_MODE_RMII &&
+ 	    state->interface != PHY_INTERFACE_MODE_GMII &&
+ 	    state->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    !phy_interface_mode_is_rgmii(state->interface)) {
+ 		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 		return;
+ 	}
+ 
+ 	if (!macb_is_gem(bp) &&
+ 	    (state->interface == PHY_INTERFACE_MODE_GMII ||
+ 	     phy_interface_mode_is_rgmii(state->interface))) {
+ 		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 		return;
+ 	}
+ 
+ 	phylink_set_port_modes(mask);
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set(mask, Asym_Pause);
+ 
+ 	phylink_set(mask, 10baseT_Half);
+ 	phylink_set(mask, 10baseT_Full);
+ 	phylink_set(mask, 100baseT_Half);
+ 	phylink_set(mask, 100baseT_Full);
+ 
+ 	if (bp->caps & MACB_CAPS_GIGABIT_MODE_AVAILABLE &&
+ 	    (state->interface == PHY_INTERFACE_MODE_NA ||
+ 	     state->interface == PHY_INTERFACE_MODE_GMII ||
+ 	     state->interface == PHY_INTERFACE_MODE_SGMII ||
+ 	     phy_interface_mode_is_rgmii(state->interface))) {
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseX_Full);
+ 
+ 		if (!(bp->caps & MACB_CAPS_NO_GIGABIT_HALF))
+ 			phylink_set(mask, 1000baseT_Half);
+ 	}
+ 
+ 	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 	bitmap_and(state->advertising, state->advertising, mask,
+ 		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+ }
+ 
+ static void macb_mac_pcs_get_state(struct phylink_config *config,
+ 				   struct phylink_link_state *state)
+ {
+ 	state->link = 0;
+ }
+ 
+ static void macb_mac_an_restart(struct phylink_config *config)
+ {
+ 	/* Not supported */
+ }
+ 
+ static void macb_mac_config(struct phylink_config *config, unsigned int mode,
+ 			    const struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct macb *bp = netdev_priv(ndev);
++>>>>>>> d46b7e4fb060 (net: phylink: rename mac_link_state() op to mac_pcs_get_state())
  	unsigned long flags;
 -	u32 old_ctrl, ctrl;
 +	int status_change = 0;
  
  	spin_lock_irqsave(&bp->lock, flags);
  
 -	old_ctrl = ctrl = macb_or_gem_readl(bp, NCFGR);
 -
 -	/* Clear all the bits we might set later */
 -	ctrl &= ~(GEM_BIT(GBE) | MACB_BIT(SPD) | MACB_BIT(FD) | MACB_BIT(PAE) |
 -		  GEM_BIT(SGMIIEN) | GEM_BIT(PCSSEL));
 +	if (phydev->link) {
 +		if ((bp->speed != phydev->speed) ||
 +		    (bp->duplex != phydev->duplex)) {
 +			u32 reg;
  
 -	if (state->speed == SPEED_1000)
 -		ctrl |= GEM_BIT(GBE);
 -	else if (state->speed == SPEED_100)
 -		ctrl |= MACB_BIT(SPD);
 +			reg = macb_readl(bp, NCFGR);
 +			reg &= ~(MACB_BIT(SPD) | MACB_BIT(FD));
 +			if (macb_is_gem(bp))
 +				reg &= ~GEM_BIT(GBE);
  
 -	if (state->duplex)
 -		ctrl |= MACB_BIT(FD);
 +			if (phydev->duplex)
 +				reg |= MACB_BIT(FD);
 +			if (phydev->speed == SPEED_100)
 +				reg |= MACB_BIT(SPD);
 +			if (phydev->speed == SPEED_1000 &&
 +			    bp->caps & MACB_CAPS_GIGABIT_MODE_AVAILABLE)
 +				reg |= GEM_BIT(GBE);
  
 -	/* We do not support MLO_PAUSE_RX yet */
 -	if (state->pause & MLO_PAUSE_TX)
 -		ctrl |= MACB_BIT(PAE);
 +			macb_or_gem_writel(bp, NCFGR, reg);
  
 -	if (state->interface == PHY_INTERFACE_MODE_SGMII)
 -		ctrl |= GEM_BIT(SGMIIEN) | GEM_BIT(PCSSEL);
 +			bp->speed = phydev->speed;
 +			bp->duplex = phydev->duplex;
 +			status_change = 1;
 +		}
 +	}
  
 -	/* Apply the new configuration, if any */
 -	if (old_ctrl ^ ctrl)
 -		macb_or_gem_writel(bp, NCFGR, ctrl);
 +	if (phydev->link != bp->link) {
 +		if (!phydev->link) {
 +			bp->speed = 0;
 +			bp->duplex = -1;
 +		}
 +		bp->link = phydev->link;
  
 -	bp->speed = state->speed;
 +		status_change = 1;
 +	}
  
  	spin_unlock_irqrestore(&bp->lock, flags);
 -}
 -
 -static void macb_mac_link_down(struct phylink_config *config, unsigned int mode,
 -			       phy_interface_t interface)
 -{
 -	struct net_device *ndev = to_net_dev(config->dev);
 -	struct macb *bp = netdev_priv(ndev);
 -	struct macb_queue *queue;
 -	unsigned int q;
 -	u32 ctrl;
  
 +	if (status_change) {
 +		if (phydev->link) {
 +			/* Update the TX clock rate if and only if the link is
 +			 * up and there has been a link change.
 +			 */
 +			macb_set_tx_clk(bp->tx_clk, phydev->speed, dev);
 +
++<<<<<<< HEAD
 +			netif_carrier_on(dev);
 +			netdev_info(dev, "link up (%d/%s)\n",
 +				    phydev->speed,
 +				    phydev->duplex == DUPLEX_FULL ?
 +				    "Full" : "Half");
 +		} else {
 +			netif_carrier_off(dev);
 +			netdev_info(dev, "link down\n");
++=======
+ 	for (q = 0, queue = bp->queues; q < bp->num_queues; ++q, ++queue)
+ 		queue_writel(queue, IDR,
+ 			     bp->rx_intr_mask | MACB_TX_INT_FLAGS | MACB_BIT(HRESP));
+ 
+ 	/* Disable Rx and Tx */
+ 	ctrl = macb_readl(bp, NCR) & ~(MACB_BIT(RE) | MACB_BIT(TE));
+ 	macb_writel(bp, NCR, ctrl);
+ 
+ 	netif_tx_stop_all_queues(ndev);
+ }
+ 
+ static void macb_mac_link_up(struct phylink_config *config, unsigned int mode,
+ 			     phy_interface_t interface, struct phy_device *phy)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct macb *bp = netdev_priv(ndev);
+ 	struct macb_queue *queue;
+ 	unsigned int q;
+ 
+ 	macb_set_tx_clk(bp->tx_clk, bp->speed, ndev);
+ 
+ 	/* Initialize rings & buffers as clearing MACB_BIT(TE) in link down
+ 	 * cleared the pipeline and control registers.
+ 	 */
+ 	bp->macbgem_ops.mog_init_rings(bp);
+ 	macb_init_buffers(bp);
+ 
+ 	for (q = 0, queue = bp->queues; q < bp->num_queues; ++q, ++queue)
+ 		queue_writel(queue, IER,
+ 			     bp->rx_intr_mask | MACB_TX_INT_FLAGS | MACB_BIT(HRESP));
+ 
+ 	/* Enable Rx and Tx */
+ 	macb_writel(bp, NCR, macb_readl(bp, NCR) | MACB_BIT(RE) | MACB_BIT(TE));
+ 
+ 	netif_tx_wake_all_queues(ndev);
+ }
+ 
+ static const struct phylink_mac_ops macb_phylink_ops = {
+ 	.validate = macb_validate,
+ 	.mac_pcs_get_state = macb_mac_pcs_get_state,
+ 	.mac_an_restart = macb_mac_an_restart,
+ 	.mac_config = macb_mac_config,
+ 	.mac_link_down = macb_mac_link_down,
+ 	.mac_link_up = macb_mac_link_up,
+ };
+ 
+ static int macb_phylink_connect(struct macb *bp)
+ {
+ 	struct net_device *dev = bp->dev;
+ 	struct phy_device *phydev;
+ 	int ret;
+ 
+ 	if (bp->pdev->dev.of_node &&
+ 	    of_parse_phandle(bp->pdev->dev.of_node, "phy-handle", 0)) {
+ 		ret = phylink_of_phy_connect(bp->phylink, bp->pdev->dev.of_node,
+ 					     0);
+ 		if (ret) {
+ 			netdev_err(dev, "Could not attach PHY (%d)\n", ret);
+ 			return ret;
++>>>>>>> d46b7e4fb060 (net: phylink: rename mac_link_state() op to mac_pcs_get_state())
 +		}
 +	}
 +}
 +
 +/* based on au1000_eth. c*/
 +static int macb_mii_probe(struct net_device *dev)
 +{
 +	struct macb *bp = netdev_priv(dev);
 +	struct macb_platform_data *pdata;
 +	struct phy_device *phydev;
 +	struct device_node *np;
 +	int phy_irq, ret, i;
 +
 +	pdata = dev_get_platdata(&bp->pdev->dev);
 +	np = bp->pdev->dev.of_node;
 +	ret = 0;
 +
 +	if (np) {
 +		if (of_phy_is_fixed_link(np)) {
 +			bp->phy_node = of_node_get(np);
 +		} else {
 +			bp->phy_node = of_parse_phandle(np, "phy-handle", 0);
 +			/* fallback to standard phy registration if no
 +			 * phy-handle was found nor any phy found during
 +			 * dt phy registration
 +			 */
 +			if (!bp->phy_node && !phy_find_first(bp->mii_bus)) {
 +				for (i = 0; i < PHY_MAX_ADDR; i++) {
 +					struct phy_device *phydev;
 +
 +					phydev = mdiobus_scan(bp->mii_bus, i);
 +					if (IS_ERR(phydev) &&
 +					    PTR_ERR(phydev) != -ENODEV) {
 +						ret = PTR_ERR(phydev);
 +						break;
 +					}
 +				}
 +
 +				if (ret)
 +					return -ENODEV;
 +			}
  		}
 +	}
 +
 +	if (bp->phy_node) {
 +		phydev = of_phy_connect(dev, bp->phy_node,
 +					&macb_handle_link_change, 0,
 +					bp->phy_interface);
 +		if (!phydev)
 +			return -ENODEV;
  	} else {
  		phydev = phy_find_first(bp->mii_bus);
  		if (!phydev) {
diff --cc drivers/net/ethernet/mediatek/mtk_eth_soc.c
index e558deb9449b,527ad2aadcca..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@@ -165,211 -187,338 +165,372 @@@ static void mtk_gmac0_rgmii_adjust(stru
  	mtk_w32(eth, val, TRGMII_TCK_CTRL);
  }
  
 -static void mtk_mac_config(struct phylink_config *config, unsigned int mode,
 -			   const struct phylink_link_state *state)
 +static void mtk_gmac_sgmii_hw_setup(struct mtk_eth *eth, int mac_id)
  {
 -	struct mtk_mac *mac = container_of(config, struct mtk_mac,
 -					   phylink_config);
 -	struct mtk_eth *eth = mac->hw;
 -	u32 mcr_cur, mcr_new, sid;
 -	int val, ge_mode, err;
 -
 -	/* MT76x8 has no hardware settings between for the MAC */
 -	if (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628) &&
 -	    mac->interface != state->interface) {
 -		/* Setup soc pin functions */
 -		switch (state->interface) {
 -		case PHY_INTERFACE_MODE_TRGMII:
 -			if (mac->id)
 -				goto err_phy;
 -			if (!MTK_HAS_CAPS(mac->hw->soc->caps,
 -					  MTK_GMAC1_TRGMII))
 -				goto err_phy;
 -			/* fall through */
 -		case PHY_INTERFACE_MODE_RGMII_TXID:
 -		case PHY_INTERFACE_MODE_RGMII_RXID:
 -		case PHY_INTERFACE_MODE_RGMII_ID:
 -		case PHY_INTERFACE_MODE_RGMII:
 -		case PHY_INTERFACE_MODE_MII:
 -		case PHY_INTERFACE_MODE_REVMII:
 -		case PHY_INTERFACE_MODE_RMII:
 -			if (MTK_HAS_CAPS(eth->soc->caps, MTK_RGMII)) {
 -				err = mtk_gmac_rgmii_path_setup(eth, mac->id);
 -				if (err)
 -					goto init_err;
 -			}
 -			break;
 -		case PHY_INTERFACE_MODE_1000BASEX:
 -		case PHY_INTERFACE_MODE_2500BASEX:
 -		case PHY_INTERFACE_MODE_SGMII:
 -			if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII)) {
 -				err = mtk_gmac_sgmii_path_setup(eth, mac->id);
 -				if (err)
 -					goto init_err;
 -			}
 -			break;
 -		case PHY_INTERFACE_MODE_GMII:
 -			if (MTK_HAS_CAPS(eth->soc->caps, MTK_GEPHY)) {
 -				err = mtk_gmac_gephy_path_setup(eth, mac->id);
 -				if (err)
 -					goto init_err;
 -			}
 -			break;
 -		default:
 -			goto err_phy;
 -		}
 +	u32 val;
  
 -		/* Setup clock for 1st gmac */
 -		if (!mac->id && state->interface != PHY_INTERFACE_MODE_SGMII &&
 -		    !phy_interface_mode_is_8023z(state->interface) &&
 -		    MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII)) {
 -			if (MTK_HAS_CAPS(mac->hw->soc->caps,
 -					 MTK_TRGMII_MT7621_CLK)) {
 -				if (mt7621_gmac0_rgmii_adjust(mac->hw,
 -							      state->interface))
 -					goto err_phy;
 -			} else {
 -				if (state->interface !=
 -				    PHY_INTERFACE_MODE_TRGMII)
 -					mtk_gmac0_rgmii_adjust(mac->hw,
 -							       state->speed);
 -			}
 -		}
 +	/* Setup the link timer and QPHY power up inside SGMIISYS */
 +	regmap_write(eth->sgmiisys, SGMSYS_PCS_LINK_TIMER,
 +		     SGMII_LINK_TIMER_DEFAULT);
  
 -		ge_mode = 0;
 -		switch (state->interface) {
 -		case PHY_INTERFACE_MODE_MII:
 -		case PHY_INTERFACE_MODE_GMII:
 -			ge_mode = 1;
 -			break;
 -		case PHY_INTERFACE_MODE_REVMII:
 -			ge_mode = 2;
 -			break;
 -		case PHY_INTERFACE_MODE_RMII:
 -			if (mac->id)
 -				goto err_phy;
 -			ge_mode = 3;
 -			break;
 -		default:
 -			break;
 -		}
 +	regmap_read(eth->sgmiisys, SGMSYS_SGMII_MODE, &val);
 +	val |= SGMII_REMOTE_FAULT_DIS;
 +	regmap_write(eth->sgmiisys, SGMSYS_SGMII_MODE, val);
  
 -		/* put the gmac into the right mode */
 +	regmap_read(eth->sgmiisys, SGMSYS_PCS_CONTROL_1, &val);
 +	val |= SGMII_AN_RESTART;
 +	regmap_write(eth->sgmiisys, SGMSYS_PCS_CONTROL_1, val);
 +
 +	regmap_read(eth->sgmiisys, SGMSYS_QPHY_PWR_STATE_CTRL, &val);
 +	val &= ~SGMII_PHYA_PWD;
 +	regmap_write(eth->sgmiisys, SGMSYS_QPHY_PWR_STATE_CTRL, val);
 +
 +	/* Determine MUX for which GMAC uses the SGMII interface */
 +	if (MTK_HAS_CAPS(eth->soc->caps, MTK_DUAL_GMAC_SHARED_SGMII)) {
  		regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 -		val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);
 -		val |= SYSCFG0_GE_MODE(ge_mode, mac->id);
 +		val &= ~SYSCFG0_SGMII_MASK;
 +		val |= !mac_id ? SYSCFG0_SGMII_GMAC1 : SYSCFG0_SGMII_GMAC2;
  		regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
  
 -		mac->interface = state->interface;
 +		dev_info(eth->dev, "setup shared sgmii for gmac=%d\n",
 +			 mac_id);
  	}
  
 -	/* SGMII */
 -	if (state->interface == PHY_INTERFACE_MODE_SGMII ||
 -	    phy_interface_mode_is_8023z(state->interface)) {
 -		/* The path GMAC to SGMII will be enabled once the SGMIISYS is
 -		 * being setup done.
 -		 */
 -		regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 +	/* Setup the GMAC1 going through SGMII path when SoC also support
 +	 * ESW on GMAC1
 +	 */
 +	if (MTK_HAS_CAPS(eth->soc->caps, MTK_GMAC1_ESW | MTK_GMAC1_SGMII) &&
 +	    !mac_id) {
 +		mtk_w32(eth, 0, MTK_MAC_MISC);
 +		dev_info(eth->dev, "setup gmac1 going through sgmii");
 +	}
 +}
 +
 +static void mtk_phy_link_adjust(struct net_device *dev)
 +{
 +	struct mtk_mac *mac = netdev_priv(dev);
 +	u16 lcl_adv = 0, rmt_adv = 0;
 +	u8 flowctrl;
 +	u32 mcr = MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG |
 +		  MAC_MCR_FORCE_MODE | MAC_MCR_TX_EN |
 +		  MAC_MCR_RX_EN | MAC_MCR_BACKOFF_EN |
 +		  MAC_MCR_BACKPR_EN;
 +
 +	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
 +		return;
 +
 +	switch (dev->phydev->speed) {
 +	case SPEED_1000:
 +		mcr |= MAC_MCR_SPEED_1000;
 +		break;
 +	case SPEED_100:
 +		mcr |= MAC_MCR_SPEED_100;
 +		break;
 +	};
  
 -		regmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,
 -				   SYSCFG0_SGMII_MASK,
 -				   ~(u32)SYSCFG0_SGMII_MASK);
 +	if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII) &&
 +	    !mac->id && !mac->trgmii)
 +		mtk_gmac0_rgmii_adjust(mac->hw, dev->phydev->speed);
  
 -		/* Decide how GMAC and SGMIISYS be mapped */
 -		sid = (MTK_HAS_CAPS(eth->soc->caps, MTK_SHARED_SGMII)) ?
 -		       0 : mac->id;
 +	if (dev->phydev->link)
 +		mcr |= MAC_MCR_FORCE_LINK;
  
 -		/* Setup SGMIISYS with the determined property */
 -		if (state->interface != PHY_INTERFACE_MODE_SGMII)
 -			err = mtk_sgmii_setup_mode_force(eth->sgmii, sid,
 -							 state);
 -		else if (phylink_autoneg_inband(mode))
 -			err = mtk_sgmii_setup_mode_an(eth->sgmii, sid);
 +	if (dev->phydev->duplex) {
 +		mcr |= MAC_MCR_FORCE_DPX;
  
 -		if (err)
 -			goto init_err;
 +		if (dev->phydev->pause)
 +			rmt_adv = LPA_PAUSE_CAP;
 +		if (dev->phydev->asym_pause)
 +			rmt_adv |= LPA_PAUSE_ASYM;
  
 -		regmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,
 -				   SYSCFG0_SGMII_MASK, val);
 -	} else if (phylink_autoneg_inband(mode)) {
 -		dev_err(eth->dev,
 -			"In-band mode not supported in non SGMII mode!\n");
 -		return;
 +		lcl_adv = linkmode_adv_to_lcl_adv_t(dev->phydev->advertising);
 +		flowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);
 +
 +		if (flowctrl & FLOW_CTRL_TX)
 +			mcr |= MAC_MCR_FORCE_TX_FC;
 +		if (flowctrl & FLOW_CTRL_RX)
 +			mcr |= MAC_MCR_FORCE_RX_FC;
 +
 +		netif_dbg(mac->hw, link, dev, "rx pause %s, tx pause %s\n",
 +			  flowctrl & FLOW_CTRL_RX ? "enabled" : "disabled",
 +			  flowctrl & FLOW_CTRL_TX ? "enabled" : "disabled");
  	}
  
 -	/* Setup gmac */
 -	mcr_cur = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
 -	mcr_new = mcr_cur;
 -	mcr_new &= ~(MAC_MCR_SPEED_100 | MAC_MCR_SPEED_1000 |
 -		     MAC_MCR_FORCE_DPX | MAC_MCR_FORCE_TX_FC |
 -		     MAC_MCR_FORCE_RX_FC);
 -	mcr_new |= MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |
 -		   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_LINK;
 +	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
 +
 +	if (dev->phydev->link)
 +		netif_carrier_on(dev);
 +	else
 +		netif_carrier_off(dev);
  
 -	switch (state->speed) {
 -	case SPEED_2500:
 -	case SPEED_1000:
 -		mcr_new |= MAC_MCR_SPEED_1000;
 +	if (!of_phy_is_fixed_link(mac->of_node))
 +		phy_print_status(dev->phydev);
 +}
 +
 +static int mtk_phy_connect_node(struct mtk_eth *eth, struct mtk_mac *mac,
 +				struct device_node *phy_node)
 +{
 +	struct phy_device *phydev;
 +	int phy_mode;
 +
 +	phy_mode = of_get_phy_mode(phy_node);
 +	if (phy_mode < 0) {
 +		dev_err(eth->dev, "incorrect phy-mode %d\n", phy_mode);
 +		return -EINVAL;
 +	}
 +
 +	phydev = of_phy_connect(eth->netdev[mac->id], phy_node,
 +				mtk_phy_link_adjust, 0, phy_mode);
 +	if (!phydev) {
 +		dev_err(eth->dev, "could not connect to PHY\n");
 +		return -ENODEV;
 +	}
 +
 +	dev_info(eth->dev,
 +		 "connected mac %d to PHY at %s [uid=%08x, driver=%s]\n",
 +		 mac->id, phydev_name(phydev), phydev->phy_id,
 +		 phydev->drv->name);
 +
 +	return 0;
 +}
 +
 +static int mtk_phy_connect(struct net_device *dev)
 +{
 +	struct mtk_mac *mac = netdev_priv(dev);
 +	struct mtk_eth *eth;
 +	struct device_node *np;
 +	u32 val;
 +
 +	eth = mac->hw;
 +	np = of_parse_phandle(mac->of_node, "phy-handle", 0);
 +	if (!np && of_phy_is_fixed_link(mac->of_node))
 +		if (!of_phy_register_fixed_link(mac->of_node))
 +			np = of_node_get(mac->of_node);
 +	if (!np)
 +		return -ENODEV;
 +
 +	mac->ge_mode = 0;
 +	switch (of_get_phy_mode(np)) {
 +	case PHY_INTERFACE_MODE_TRGMII:
 +		mac->trgmii = true;
 +	case PHY_INTERFACE_MODE_RGMII_TXID:
 +	case PHY_INTERFACE_MODE_RGMII_RXID:
 +	case PHY_INTERFACE_MODE_RGMII_ID:
 +	case PHY_INTERFACE_MODE_RGMII:
  		break;
 -	case SPEED_100:
 -		mcr_new |= MAC_MCR_SPEED_100;
 +	case PHY_INTERFACE_MODE_SGMII:
 +		if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII))
 +			mtk_gmac_sgmii_hw_setup(eth, mac->id);
  		break;
 -	}
 -	if (state->duplex == DUPLEX_FULL) {
 -		mcr_new |= MAC_MCR_FORCE_DPX;
 -		if (state->pause & MLO_PAUSE_TX)
 -			mcr_new |= MAC_MCR_FORCE_TX_FC;
 -		if (state->pause & MLO_PAUSE_RX)
 -			mcr_new |= MAC_MCR_FORCE_RX_FC;
 +	case PHY_INTERFACE_MODE_MII:
 +		mac->ge_mode = 1;
 +		break;
 +	case PHY_INTERFACE_MODE_REVMII:
 +		mac->ge_mode = 2;
 +		break;
 +	case PHY_INTERFACE_MODE_RMII:
 +		if (!mac->id)
 +			goto err_phy;
 +		mac->ge_mode = 3;
 +		break;
 +	default:
 +		goto err_phy;
  	}
  
 -	/* Only update control register when needed! */
 -	if (mcr_new != mcr_cur)
 -		mtk_w32(mac->hw, mcr_new, MTK_MAC_MCR(mac->id));
 +	/* put the gmac into the right mode */
 +	regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 +	val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);
 +	val |= SYSCFG0_GE_MODE(mac->ge_mode, mac->id);
 +	regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
  
 -	return;
 +	/* couple phydev to net_device */
 +	if (mtk_phy_connect_node(eth, mac, np))
 +		goto err_phy;
  
 -err_phy:
 -	dev_err(eth->dev, "%s: GMAC%d mode %s not supported!\n", __func__,
 -		mac->id, phy_modes(state->interface));
 -	return;
 +	dev->phydev->autoneg = AUTONEG_ENABLE;
 +	dev->phydev->speed = 0;
 +	dev->phydev->duplex = 0;
 +
 +	phy_set_max_speed(dev->phydev, SPEED_1000);
 +	phy_support_asym_pause(dev->phydev);
 +	linkmode_copy(dev->phydev->advertising, dev->phydev->supported);
 +	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
 +			 dev->phydev->advertising);
 +	phy_start_aneg(dev->phydev);
 +
 +	of_node_put(np);
 +
 +	return 0;
  
 -init_err:
 -	dev_err(eth->dev, "%s: GMAC%d mode %s err: %d!\n", __func__,
 -		mac->id, phy_modes(state->interface), err);
 +err_phy:
 +	if (of_phy_is_fixed_link(mac->of_node))
 +		of_phy_deregister_fixed_link(mac->of_node);
 +	of_node_put(np);
 +	dev_err(eth->dev, "%s: invalid phy\n", __func__);
 +	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static void mtk_mac_pcs_get_state(struct phylink_config *config,
+ 				  struct phylink_link_state *state)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 	u32 pmsr = mtk_r32(mac->hw, MTK_MAC_MSR(mac->id));
+ 
+ 	state->link = (pmsr & MAC_MSR_LINK);
+ 	state->duplex = (pmsr & MAC_MSR_DPX) >> 1;
+ 
+ 	switch (pmsr & (MAC_MSR_SPEED_1000 | MAC_MSR_SPEED_100)) {
+ 	case 0:
+ 		state->speed = SPEED_10;
+ 		break;
+ 	case MAC_MSR_SPEED_100:
+ 		state->speed = SPEED_100;
+ 		break;
+ 	case MAC_MSR_SPEED_1000:
+ 		state->speed = SPEED_1000;
+ 		break;
+ 	default:
+ 		state->speed = SPEED_UNKNOWN;
+ 		break;
+ 	}
+ 
+ 	state->pause &= (MLO_PAUSE_RX | MLO_PAUSE_TX);
+ 	if (pmsr & MAC_MSR_RX_FC)
+ 		state->pause |= MLO_PAUSE_RX;
+ 	if (pmsr & MAC_MSR_TX_FC)
+ 		state->pause |= MLO_PAUSE_TX;
+ }
+ 
+ static void mtk_mac_an_restart(struct phylink_config *config)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 
+ 	mtk_sgmii_restart_an(mac->hw, mac->id);
+ }
+ 
+ static void mtk_mac_link_down(struct phylink_config *config, unsigned int mode,
+ 			      phy_interface_t interface)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 	u32 mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
+ 
+ 	mcr &= ~(MAC_MCR_TX_EN | MAC_MCR_RX_EN);
+ 	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
+ }
+ 
+ static void mtk_mac_link_up(struct phylink_config *config, unsigned int mode,
+ 			    phy_interface_t interface,
+ 			    struct phy_device *phy)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 	u32 mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
+ 
+ 	mcr |= MAC_MCR_TX_EN | MAC_MCR_RX_EN;
+ 	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
+ }
+ 
+ static void mtk_validate(struct phylink_config *config,
+ 			 unsigned long *supported,
+ 			 struct phylink_link_state *state)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != PHY_INTERFACE_MODE_MII &&
+ 	    state->interface != PHY_INTERFACE_MODE_GMII &&
+ 	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_RGMII) &&
+ 	      phy_interface_mode_is_rgmii(state->interface)) &&
+ 	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_TRGMII) &&
+ 	      !mac->id && state->interface == PHY_INTERFACE_MODE_TRGMII) &&
+ 	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_SGMII) &&
+ 	      (state->interface == PHY_INTERFACE_MODE_SGMII ||
+ 	       phy_interface_mode_is_8023z(state->interface)))) {
+ 		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+ 	phylink_set_port_modes(mask);
+ 	phylink_set(mask, Autoneg);
+ 
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_TRGMII:
+ 		phylink_set(mask, 1000baseT_Full);
+ 		break;
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 	case PHY_INTERFACE_MODE_2500BASEX:
+ 		phylink_set(mask, 1000baseX_Full);
+ 		phylink_set(mask, 2500baseX_Full);
+ 		break;
+ 	case PHY_INTERFACE_MODE_GMII:
+ 	case PHY_INTERFACE_MODE_RGMII:
+ 	case PHY_INTERFACE_MODE_RGMII_ID:
+ 	case PHY_INTERFACE_MODE_RGMII_RXID:
+ 	case PHY_INTERFACE_MODE_RGMII_TXID:
+ 		phylink_set(mask, 1000baseT_Half);
+ 		/* fall through */
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseX_Full);
+ 		/* fall through */
+ 	case PHY_INTERFACE_MODE_MII:
+ 	case PHY_INTERFACE_MODE_RMII:
+ 	case PHY_INTERFACE_MODE_REVMII:
+ 	case PHY_INTERFACE_MODE_NA:
+ 	default:
+ 		phylink_set(mask, 10baseT_Half);
+ 		phylink_set(mask, 10baseT_Full);
+ 		phylink_set(mask, 100baseT_Half);
+ 		phylink_set(mask, 100baseT_Full);
+ 		break;
+ 	}
+ 
+ 	if (state->interface == PHY_INTERFACE_MODE_NA) {
+ 		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_SGMII)) {
+ 			phylink_set(mask, 1000baseT_Full);
+ 			phylink_set(mask, 1000baseX_Full);
+ 			phylink_set(mask, 2500baseX_Full);
+ 		}
+ 		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_RGMII)) {
+ 			phylink_set(mask, 1000baseT_Full);
+ 			phylink_set(mask, 1000baseT_Half);
+ 			phylink_set(mask, 1000baseX_Full);
+ 		}
+ 		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GEPHY)) {
+ 			phylink_set(mask, 1000baseT_Full);
+ 			phylink_set(mask, 1000baseT_Half);
+ 		}
+ 	}
+ 
+ 	phylink_set(mask, Pause);
+ 	phylink_set(mask, Asym_Pause);
+ 
+ 	linkmode_and(supported, supported, mask);
+ 	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	/* We can only operate at 2500BaseX or 1000BaseX. If requested
+ 	 * to advertise both, only report advertising at 2500BaseX.
+ 	 */
+ 	phylink_helper_basex_speed(state);
+ }
+ 
+ static const struct phylink_mac_ops mtk_phylink_ops = {
+ 	.validate = mtk_validate,
+ 	.mac_pcs_get_state = mtk_mac_pcs_get_state,
+ 	.mac_an_restart = mtk_mac_an_restart,
+ 	.mac_config = mtk_mac_config,
+ 	.mac_link_down = mtk_mac_link_down,
+ 	.mac_link_up = mtk_mac_link_up,
+ };
+ 
++>>>>>>> d46b7e4fb060 (net: phylink: rename mac_link_state() op to mac_pcs_get_state())
  static int mtk_mdio_init(struct mtk_eth *eth)
  {
  	struct device_node *mii_np;
diff --cc drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index f24f48f33802,20746b801959..000000000000
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@@ -1296,8 -1367,139 +1296,144 @@@ static const struct ethtool_ops axienet
  	.set_pauseparam = axienet_ethtools_set_pauseparam,
  	.get_coalesce   = axienet_ethtools_get_coalesce,
  	.set_coalesce   = axienet_ethtools_set_coalesce,
++<<<<<<< HEAD
 +	.get_link_ksettings = phy_ethtool_get_link_ksettings,
 +	.set_link_ksettings = phy_ethtool_set_link_ksettings,
++=======
+ 	.get_link_ksettings = axienet_ethtools_get_link_ksettings,
+ 	.set_link_ksettings = axienet_ethtools_set_link_ksettings,
+ };
+ 
+ static void axienet_validate(struct phylink_config *config,
+ 			     unsigned long *supported,
+ 			     struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	/* Only support the mode we are configured for */
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != lp->phy_mode) {
+ 		netdev_warn(ndev, "Cannot use PHY mode %s, supported: %s\n",
+ 			    phy_modes(state->interface),
+ 			    phy_modes(lp->phy_mode));
+ 		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 		return;
+ 	}
+ 
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set_port_modes(mask);
+ 
+ 	phylink_set(mask, Asym_Pause);
+ 	phylink_set(mask, Pause);
+ 	phylink_set(mask, 1000baseX_Full);
+ 	phylink_set(mask, 10baseT_Full);
+ 	phylink_set(mask, 100baseT_Full);
+ 	phylink_set(mask, 1000baseT_Full);
+ 
+ 	bitmap_and(supported, supported, mask,
+ 		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 	bitmap_and(state->advertising, state->advertising, mask,
+ 		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+ }
+ 
+ static void axienet_mac_pcs_get_state(struct phylink_config *config,
+ 				      struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	u32 emmc_reg, fcc_reg;
+ 
+ 	state->interface = lp->phy_mode;
+ 
+ 	emmc_reg = axienet_ior(lp, XAE_EMMC_OFFSET);
+ 	if (emmc_reg & XAE_EMMC_LINKSPD_1000)
+ 		state->speed = SPEED_1000;
+ 	else if (emmc_reg & XAE_EMMC_LINKSPD_100)
+ 		state->speed = SPEED_100;
+ 	else
+ 		state->speed = SPEED_10;
+ 
+ 	state->pause = 0;
+ 	fcc_reg = axienet_ior(lp, XAE_FCC_OFFSET);
+ 	if (fcc_reg & XAE_FCC_FCTX_MASK)
+ 		state->pause |= MLO_PAUSE_TX;
+ 	if (fcc_reg & XAE_FCC_FCRX_MASK)
+ 		state->pause |= MLO_PAUSE_RX;
+ 
+ 	state->an_complete = 0;
+ 	state->duplex = 1;
+ }
+ 
+ static void axienet_mac_an_restart(struct phylink_config *config)
+ {
+ 	/* Unsupported, do nothing */
+ }
+ 
+ static void axienet_mac_config(struct phylink_config *config, unsigned int mode,
+ 			       const struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	u32 emmc_reg, fcc_reg;
+ 
+ 	emmc_reg = axienet_ior(lp, XAE_EMMC_OFFSET);
+ 	emmc_reg &= ~XAE_EMMC_LINKSPEED_MASK;
+ 
+ 	switch (state->speed) {
+ 	case SPEED_1000:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_1000;
+ 		break;
+ 	case SPEED_100:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_100;
+ 		break;
+ 	case SPEED_10:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_10;
+ 		break;
+ 	default:
+ 		dev_err(&ndev->dev,
+ 			"Speed other than 10, 100 or 1Gbps is not supported\n");
+ 		break;
+ 	}
+ 
+ 	axienet_iow(lp, XAE_EMMC_OFFSET, emmc_reg);
+ 
+ 	fcc_reg = axienet_ior(lp, XAE_FCC_OFFSET);
+ 	if (state->pause & MLO_PAUSE_TX)
+ 		fcc_reg |= XAE_FCC_FCTX_MASK;
+ 	else
+ 		fcc_reg &= ~XAE_FCC_FCTX_MASK;
+ 	if (state->pause & MLO_PAUSE_RX)
+ 		fcc_reg |= XAE_FCC_FCRX_MASK;
+ 	else
+ 		fcc_reg &= ~XAE_FCC_FCRX_MASK;
+ 	axienet_iow(lp, XAE_FCC_OFFSET, fcc_reg);
+ }
+ 
+ static void axienet_mac_link_down(struct phylink_config *config,
+ 				  unsigned int mode,
+ 				  phy_interface_t interface)
+ {
+ 	/* nothing meaningful to do */
+ }
+ 
+ static void axienet_mac_link_up(struct phylink_config *config,
+ 				unsigned int mode,
+ 				phy_interface_t interface,
+ 				struct phy_device *phy)
+ {
+ 	/* nothing meaningful to do */
+ }
+ 
+ static const struct phylink_mac_ops axienet_phylink_ops = {
+ 	.validate = axienet_validate,
+ 	.mac_pcs_get_state = axienet_mac_pcs_get_state,
+ 	.mac_an_restart = axienet_mac_an_restart,
+ 	.mac_config = axienet_mac_config,
+ 	.mac_link_down = axienet_mac_link_down,
+ 	.mac_link_up = axienet_mac_link_up,
++>>>>>>> d46b7e4fb060 (net: phylink: rename mac_link_state() op to mac_pcs_get_state())
  };
  
  /**
diff --cc net/dsa/dsa_priv.h
index 4aeecfbc0008,2dd86d9bcda9..000000000000
--- a/net/dsa/dsa_priv.h
+++ b/net/dsa/dsa_priv.h
@@@ -164,8 -146,27 +164,28 @@@ int dsa_port_vlan_add(struct dsa_port *
  		      struct switchdev_trans *trans);
  int dsa_port_vlan_del(struct dsa_port *dp,
  		      const struct switchdev_obj_port_vlan *vlan);
 -int dsa_port_vid_add(struct dsa_port *dp, u16 vid, u16 flags);
 -int dsa_port_vid_del(struct dsa_port *dp, u16 vid);
  int dsa_port_link_register_of(struct dsa_port *dp);
  void dsa_port_link_unregister_of(struct dsa_port *dp);
++<<<<<<< HEAD
++=======
+ void dsa_port_phylink_validate(struct phylink_config *config,
+ 			       unsigned long *supported,
+ 			       struct phylink_link_state *state);
+ void dsa_port_phylink_mac_pcs_get_state(struct phylink_config *config,
+ 					struct phylink_link_state *state);
+ void dsa_port_phylink_mac_config(struct phylink_config *config,
+ 				 unsigned int mode,
+ 				 const struct phylink_link_state *state);
+ void dsa_port_phylink_mac_an_restart(struct phylink_config *config);
+ void dsa_port_phylink_mac_link_down(struct phylink_config *config,
+ 				    unsigned int mode,
+ 				    phy_interface_t interface);
+ void dsa_port_phylink_mac_link_up(struct phylink_config *config,
+ 				  unsigned int mode,
+ 				  phy_interface_t interface,
+ 				  struct phy_device *phydev);
+ extern const struct phylink_mac_ops dsa_port_phylink_mac_ops;
++>>>>>>> d46b7e4fb060 (net: phylink: rename mac_link_state() op to mac_pcs_get_state())
  
  /* slave.c */
  extern const struct dsa_device_ops notag_netdev_ops;
diff --cc net/dsa/port.c
index 2d7e01b23572,46ac9ba21987..000000000000
--- a/net/dsa/port.c
+++ b/net/dsa/port.c
@@@ -294,6 -414,112 +294,114 @@@ static struct phy_device *dsa_port_get_
  	return phydev;
  }
  
++<<<<<<< HEAD
++=======
+ void dsa_port_phylink_validate(struct phylink_config *config,
+ 			       unsigned long *supported,
+ 			       struct phylink_link_state *state)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->phylink_validate)
+ 		return;
+ 
+ 	ds->ops->phylink_validate(ds, dp->index, supported, state);
+ }
+ EXPORT_SYMBOL_GPL(dsa_port_phylink_validate);
+ 
+ void dsa_port_phylink_mac_pcs_get_state(struct phylink_config *config,
+ 					struct phylink_link_state *state)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	/* Only called for inband modes */
+ 	if (!ds->ops->phylink_mac_link_state) {
+ 		state->link = 0;
+ 		return;
+ 	}
+ 
+ 	if (ds->ops->phylink_mac_link_state(ds, dp->index, state) < 0)
+ 		state->link = 0;
+ }
+ EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_pcs_get_state);
+ 
+ void dsa_port_phylink_mac_config(struct phylink_config *config,
+ 				 unsigned int mode,
+ 				 const struct phylink_link_state *state)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->phylink_mac_config)
+ 		return;
+ 
+ 	ds->ops->phylink_mac_config(ds, dp->index, mode, state);
+ }
+ EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_config);
+ 
+ void dsa_port_phylink_mac_an_restart(struct phylink_config *config)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->phylink_mac_an_restart)
+ 		return;
+ 
+ 	ds->ops->phylink_mac_an_restart(ds, dp->index);
+ }
+ EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_an_restart);
+ 
+ void dsa_port_phylink_mac_link_down(struct phylink_config *config,
+ 				    unsigned int mode,
+ 				    phy_interface_t interface)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct phy_device *phydev = NULL;
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (dsa_is_user_port(ds, dp->index))
+ 		phydev = dp->slave->phydev;
+ 
+ 	if (!ds->ops->phylink_mac_link_down) {
+ 		if (ds->ops->adjust_link && phydev)
+ 			ds->ops->adjust_link(ds, dp->index, phydev);
+ 		return;
+ 	}
+ 
+ 	ds->ops->phylink_mac_link_down(ds, dp->index, mode, interface);
+ }
+ EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_link_down);
+ 
+ void dsa_port_phylink_mac_link_up(struct phylink_config *config,
+ 				  unsigned int mode,
+ 				  phy_interface_t interface,
+ 				  struct phy_device *phydev)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->phylink_mac_link_up) {
+ 		if (ds->ops->adjust_link && phydev)
+ 			ds->ops->adjust_link(ds, dp->index, phydev);
+ 		return;
+ 	}
+ 
+ 	ds->ops->phylink_mac_link_up(ds, dp->index, mode, interface, phydev);
+ }
+ EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_link_up);
+ 
+ const struct phylink_mac_ops dsa_port_phylink_mac_ops = {
+ 	.validate = dsa_port_phylink_validate,
+ 	.mac_pcs_get_state = dsa_port_phylink_mac_pcs_get_state,
+ 	.mac_config = dsa_port_phylink_mac_config,
+ 	.mac_an_restart = dsa_port_phylink_mac_an_restart,
+ 	.mac_link_down = dsa_port_phylink_mac_link_down,
+ 	.mac_link_up = dsa_port_phylink_mac_link_up,
+ };
+ 
++>>>>>>> d46b7e4fb060 (net: phylink: rename mac_link_state() op to mac_pcs_get_state())
  static int dsa_port_setup_phy_of(struct dsa_port *dp, bool enable)
  {
  	struct dsa_switch *ds = dp->ds;
* Unmerged path drivers/net/ethernet/cadence/macb_main.c
diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index f2cdc95883b4..ce7c06d6ab01 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -3293,8 +3293,8 @@ static void mvneta_validate(struct phylink_config *config,
 		   __ETHTOOL_LINK_MODE_MASK_NBITS);
 }
 
-static int mvneta_mac_link_state(struct phylink_config *config,
-				 struct phylink_link_state *state)
+static void mvneta_mac_pcs_get_state(struct phylink_config *config,
+				     struct phylink_link_state *state)
 {
 	struct net_device *ndev = to_net_dev(config->dev);
 	struct mvneta_port *pp = netdev_priv(ndev);
@@ -3318,8 +3318,6 @@ static int mvneta_mac_link_state(struct phylink_config *config,
 		state->pause |= MLO_PAUSE_RX;
 	if (gmac_stat & MVNETA_GMAC_TX_FLOW_CTRL_ENABLE)
 		state->pause |= MLO_PAUSE_TX;
-
-	return 1;
 }
 
 static void mvneta_mac_an_restart(struct phylink_config *config)
@@ -3491,7 +3489,7 @@ static void mvneta_mac_link_up(struct phylink_config *config, unsigned int mode,
 
 static const struct phylink_mac_ops mvneta_phylink_ops = {
 	.validate = mvneta_validate,
-	.mac_link_state = mvneta_mac_link_state,
+	.mac_pcs_get_state = mvneta_mac_pcs_get_state,
 	.mac_an_restart = mvneta_mac_an_restart,
 	.mac_config = mvneta_mac_config,
 	.mac_link_down = mvneta_mac_link_down,
diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index ffcc39fb56ba..712856852e34 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@ -4188,8 +4188,8 @@ static void mvpp2_phylink_validate(struct phylink_config *config,
 		   __ETHTOOL_LINK_MODE_MASK_NBITS);
 }
 
-static void mvpp22_xlg_link_state(struct mvpp2_port *port,
-				  struct phylink_link_state *state)
+static void mvpp22_xlg_pcs_get_state(struct mvpp2_port *port,
+				     struct phylink_link_state *state)
 {
 	u32 val;
 
@@ -4208,8 +4208,8 @@ static void mvpp22_xlg_link_state(struct mvpp2_port *port,
 		state->pause |= MLO_PAUSE_RX;
 }
 
-static void mvpp2_gmac_link_state(struct mvpp2_port *port,
-				  struct phylink_link_state *state)
+static void mvpp2_gmac_pcs_get_state(struct mvpp2_port *port,
+				     struct phylink_link_state *state)
 {
 	u32 val;
 
@@ -4242,8 +4242,8 @@ static void mvpp2_gmac_link_state(struct mvpp2_port *port,
 		state->pause |= MLO_PAUSE_TX;
 }
 
-static int mvpp2_phylink_mac_link_state(struct phylink_config *config,
-					struct phylink_link_state *state)
+static void mvpp2_phylink_mac_pcs_get_state(struct phylink_config *config,
+					    struct phylink_link_state *state)
 {
 	struct mvpp2_port *port = container_of(config, struct mvpp2_port,
 					       phylink_config);
@@ -4253,13 +4253,12 @@ static int mvpp2_phylink_mac_link_state(struct phylink_config *config,
 		mode &= MVPP22_XLG_CTRL3_MACMODESELECT_MASK;
 
 		if (mode == MVPP22_XLG_CTRL3_MACMODESELECT_10G) {
-			mvpp22_xlg_link_state(port, state);
-			return 1;
+			mvpp22_xlg_pcs_get_state(port, state);
+			return;
 		}
 	}
 
-	mvpp2_gmac_link_state(port, state);
-	return 1;
+	mvpp2_gmac_pcs_get_state(port, state);
 }
 
 static void mvpp2_mac_an_restart(struct phylink_config *config)
@@ -4490,7 +4489,7 @@ static void mvpp2_mac_link_down(struct phylink_config *config,
 
 static const struct phylink_mac_ops mvpp2_phylink_ops = {
 	.validate = mvpp2_phylink_validate,
-	.mac_link_state = mvpp2_phylink_mac_link_state,
+	.mac_pcs_get_state = mvpp2_phylink_mac_pcs_get_state,
 	.mac_an_restart = mvpp2_mac_an_restart,
 	.mac_config = mvpp2_mac_config,
 	.mac_link_up = mvpp2_mac_link_up,
* Unmerged path drivers/net/ethernet/mediatek/mtk_eth_soc.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 8280fa146cae..7e1ad4133b16 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -878,10 +878,10 @@ static void stmmac_validate(struct phylink_config *config,
 		      __ETHTOOL_LINK_MODE_MASK_NBITS);
 }
 
-static int stmmac_mac_link_state(struct phylink_config *config,
-				 struct phylink_link_state *state)
+static void stmmac_mac_pcs_get_state(struct phylink_config *config,
+				     struct phylink_link_state *state)
 {
-	return -EOPNOTSUPP;
+	state->link = 0;
 }
 
 static void stmmac_mac_config(struct phylink_config *config, unsigned int mode,
@@ -975,7 +975,7 @@ static void stmmac_mac_link_up(struct phylink_config *config,
 
 static const struct phylink_mac_ops stmmac_phylink_mac_ops = {
 	.validate = stmmac_validate,
-	.mac_link_state = stmmac_mac_link_state,
+	.mac_pcs_get_state = stmmac_mac_pcs_get_state,
 	.mac_config = stmmac_mac_config,
 	.mac_an_restart = stmmac_mac_an_restart,
 	.mac_link_down = stmmac_mac_link_down,
* Unmerged path drivers/net/ethernet/xilinx/xilinx_axienet_main.c
diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
index ae02f9650b4a..d927952a46c5 100644
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@ -433,9 +433,9 @@ static void phylink_mac_an_restart(struct phylink *pl)
 		pl->ops->mac_an_restart(pl->config);
 }
 
-static int phylink_get_mac_state(struct phylink *pl, struct phylink_link_state *state)
+static void phylink_mac_pcs_get_state(struct phylink *pl,
+				      struct phylink_link_state *state)
 {
-
 	linkmode_copy(state->advertising, pl->link_config.advertising);
 	linkmode_zero(state->lp_advertising);
 	state->interface = pl->link_config.interface;
@@ -446,7 +446,7 @@ static int phylink_get_mac_state(struct phylink *pl, struct phylink_link_state *
 	state->an_complete = 0;
 	state->link = 1;
 
-	return pl->ops->mac_link_state(pl->config, state);
+	pl->ops->mac_pcs_get_state(pl->config, state);
 }
 
 /* The fixed state is... fixed except for the link state,
@@ -569,7 +569,7 @@ static void phylink_resolve(struct work_struct *w)
 			break;
 
 		case MLO_AN_INBAND:
-			phylink_get_mac_state(pl, &link_state);
+			phylink_mac_pcs_get_state(pl, &link_state);
 
 			/* If we have a phy, the "up" state is the union of
 			 * both the PHY and the MAC */
@@ -1234,7 +1234,7 @@ int phylink_ethtool_ksettings_get(struct phylink *pl,
 		if (pl->phydev)
 			break;
 
-		phylink_get_mac_state(pl, &link_state);
+		phylink_mac_pcs_get_state(pl, &link_state);
 
 		/* The MAC is reporting the link results from its own PCS
 		 * layer via in-band status. Report these as the current
@@ -1685,10 +1685,7 @@ static int phylink_mii_read(struct phylink *pl, unsigned int phy_id,
 
 	case MLO_AN_INBAND:
 		if (phy_id == 0) {
-			val = phylink_get_mac_state(pl, &state);
-			if (val < 0)
-				return val;
-
+			phylink_mac_pcs_get_state(pl, &state);
 			val = phylink_mii_emul_read(reg, &state);
 		}
 		break;
diff --git a/include/linux/phylink.h b/include/linux/phylink.h
index 230e0d96c14c..c4365f9f897c 100644
--- a/include/linux/phylink.h
+++ b/include/linux/phylink.h
@@ -75,7 +75,7 @@ struct phylink_config {
 /**
  * struct phylink_mac_ops - MAC operations structure.
  * @validate: Validate and update the link configuration.
- * @mac_link_state: Read the current link state from the hardware.
+ * @mac_pcs_get_state: Read the current link state from the hardware.
  * @mac_config: configure the MAC for the selected mode and state.
  * @mac_an_restart: restart 802.3z BaseX autonegotiation.
  * @mac_link_down: take the link down.
@@ -87,8 +87,8 @@ struct phylink_mac_ops {
 	void (*validate)(struct phylink_config *config,
 			 unsigned long *supported,
 			 struct phylink_link_state *state);
-	int (*mac_link_state)(struct phylink_config *config,
-			      struct phylink_link_state *state);
+	void (*mac_pcs_get_state)(struct phylink_config *config,
+				  struct phylink_link_state *state);
 	void (*mac_config)(struct phylink_config *config, unsigned int mode,
 			   const struct phylink_link_state *state);
 	void (*mac_an_restart)(struct phylink_config *config);
@@ -130,18 +130,19 @@ void validate(struct phylink_config *config, unsigned long *supported,
 	      struct phylink_link_state *state);
 
 /**
- * mac_link_state() - Read the current link state from the hardware
+ * mac_pcs_get_state() - Read the current inband link state from the hardware
  * @config: a pointer to a &struct phylink_config.
  * @state: a pointer to a &struct phylink_link_state.
  *
- * Read the current link state from the MAC, reporting the current
- * speed in @state->speed, duplex mode in @state->duplex, pause mode
- * in @state->pause using the %MLO_PAUSE_RX and %MLO_PAUSE_TX bits,
- * negotiation completion state in @state->an_complete, and link
- * up state in @state->link.
+ * Read the current inband link state from the MAC PCS, reporting the
+ * current speed in @state->speed, duplex mode in @state->duplex, pause
+ * mode in @state->pause using the %MLO_PAUSE_RX and %MLO_PAUSE_TX bits,
+ * negotiation completion state in @state->an_complete, and link up state
+ * in @state->link. If possible, @state->lp_advertising should also be
+ * populated.
  */
-int mac_link_state(struct phylink_config *config,
-		   struct phylink_link_state *state);
+void mac_pcs_get_state(struct phylink_config *config,
+		       struct phylink_link_state *state);
 
 /**
  * mac_config() - configure the MAC for the selected mode and state
@@ -176,7 +177,7 @@ int mac_link_state(struct phylink_config *config,
  *   1000base-X or Cisco SGMII mode depending on the @state->interface
  *   mode). In both cases, link state management (whether the link
  *   is up or not) is performed by the MAC, and reported via the
- *   mac_link_state() callback. Changes in link state must be made
+ *   mac_pcs_get_state() callback. Changes in link state must be made
  *   by calling phylink_mac_change().
  *
  *   Interface mode specific details are mentioned below.
* Unmerged path net/dsa/dsa_priv.h
* Unmerged path net/dsa/port.c
