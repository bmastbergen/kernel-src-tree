x86/boot/64: Explicitly map boot_params and command line

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] boot/64: Explicitly map boot_params and command line (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 96.30%
commit-author Arvind Sankar <nivedita@alum.mit.edu>
commit b17a45b6e53f6613118b2e5cfc4a992cc50deb2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b17a45b6.failed

Commits

  ca0e22d4f011 ("x86/boot/compressed/64: Always switch to own page table")
  8570978ea030 ("x86/boot/compressed/64: Don't pre-map memory in KASLR code")

set up a new page table in the decompressor stub, but without explicit
mappings for boot_params and the kernel command line, relying on the #PF
handler instead.

This is fragile, as boot_params and the command line mappings are
required for the main kernel. If EARLY_PRINTK and RANDOMIZE_BASE are
disabled, a QEMU/OVMF boot never accesses the command line in the
decompressor stub, and so it never gets mapped. The main kernel accesses
it from the identity mapping if AMD_MEM_ENCRYPT is enabled, and will
crash.

Fix this by adding back the explicit mapping of boot_params and the
command line.

Note: the changes also removed the explicit mapping of the main kernel,
with the result that .bss and .brk may not be in the identity mapping,
but those don't get accessed by the main kernel before it switches to
its own page tables.

 [ bp: Pass boot_params with a MOV %rsp... instead of PUSH/POP. Use
   block formatting for the comment. ]

	Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Joerg Roedel <jroedel@suse.de>
Link: https://lkml.kernel.org/r/20201016200404.1615994-1-nivedita@alum.mit.edu
(cherry picked from commit b17a45b6e53f6613118b2e5cfc4a992cc50deb2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/head_64.S
#	arch/x86/boot/compressed/ident_map_64.c
diff --cc arch/x86/boot/compressed/head_64.S
index 8b6d90a596e6,017de6cc87dc..000000000000
--- a/arch/x86/boot/compressed/head_64.S
+++ b/arch/x86/boot/compressed/head_64.S
@@@ -504,6 -533,24 +504,27 @@@ ENDPROC(efi64_stub_entry
  	rep	stosq
  
  /*
++<<<<<<< HEAD
++=======
+  * If running as an SEV guest, the encryption mask is required in the
+  * page-table setup code below. When the guest also has SEV-ES enabled
+  * set_sev_encryption_mask() will cause #VC exceptions, but the stage2
+  * handler can't map its GHCB because the page-table is not set up yet.
+  * So set up the encryption mask here while still on the stage1 #VC
+  * handler. Then load stage2 IDT and switch to the kernel's own
+  * page-table.
+  */
+ 	pushq	%rsi
+ 	call	set_sev_encryption_mask
+ 	call	load_stage2_idt
+ 
+ 	/* Pass boot_params to initialize_identity_maps() */
+ 	movq	(%rsp), %rdi
+ 	call	initialize_identity_maps
+ 	popq	%rsi
+ 
+ /*
++>>>>>>> b17a45b6e53f (x86/boot/64: Explicitly map boot_params and command line)
   * Do the extraction, and jump to the new kernel..
   */
  	pushq	%rsi			/* Save the real mode argument */
* Unmerged path arch/x86/boot/compressed/ident_map_64.c
* Unmerged path arch/x86/boot/compressed/head_64.S
* Unmerged path arch/x86/boot/compressed/ident_map_64.c
