net: stmmac: Add support for CBS QDISC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jose Abreu <Jose.Abreu@synopsys.com>
commit 1f705bc61aee5fab2826bcf6de152a5d92378a85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1f705bc6.failed

This adds support for CBS reconfiguration using the TC application.

A new callback was added to TC ops struct and another one to DMA ops to
reconfigure the channel mode.

Tested in GMAC5.10.

	Signed-off-by: Jose Abreu <joabreu@synopsys.com>
	Cc: David S. Miller <davem@davemloft.net>
	Cc: Joao Pinto <jpinto@synopsys.com>
	Cc: Vitor Soares <soares@synopsys.com>
	Cc: Giuseppe Cavallaro <peppe.cavallaro@st.com>
	Cc: Alexandre Torgue <alexandre.torgue@st.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1f705bc61aee5fab2826bcf6de152a5d92378a85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
#	drivers/net/ethernet/stmicro/stmmac/hwif.h
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
diff --cc drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
index 65bc3556bd8f,6e32f8a3710b..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
@@@ -407,14 -407,17 +407,28 @@@ static void dwmac4_enable_tso(void __io
  	}
  }
  
++<<<<<<< HEAD
 +static void dwmac4_set_bfsize(void __iomem *ioaddr, int bfsize, u32 chan)
 +{
 +	u32 value = readl(ioaddr + DMA_CHAN_RX_CONTROL(chan));
 +
 +	value &= ~DMA_RBSZ_MASK;
 +	value |= (bfsize << DMA_RBSZ_SHIFT) & DMA_RBSZ_MASK;
 +
 +	writel(value, ioaddr + DMA_CHAN_RX_CONTROL(chan));
++=======
+ static void dwmac4_qmode(void __iomem *ioaddr, u32 channel, u8 qmode)
+ {
+ 	u32 mtl_tx_op = readl(ioaddr + MTL_CHAN_TX_OP_MODE(channel));
+ 
+ 	mtl_tx_op &= ~MTL_OP_MODE_TXQEN_MASK;
+ 	if (qmode != MTL_QUEUE_AVB)
+ 		mtl_tx_op |= MTL_OP_MODE_TXQEN;
+ 	else
+ 		mtl_tx_op |= MTL_OP_MODE_TXQEN_AV;
+ 
+ 	writel(mtl_tx_op, ioaddr +  MTL_CHAN_TX_OP_MODE(channel));
++>>>>>>> 1f705bc61aee (net: stmmac: Add support for CBS QDISC)
  }
  
  const struct stmmac_dma_ops dwmac4_dma_ops = {
@@@ -441,7 -444,7 +455,11 @@@
  	.set_rx_tail_ptr = dwmac4_set_rx_tail_ptr,
  	.set_tx_tail_ptr = dwmac4_set_tx_tail_ptr,
  	.enable_tso = dwmac4_enable_tso,
++<<<<<<< HEAD
 +	.set_bfsize = dwmac4_set_bfsize,
++=======
+ 	.qmode = dwmac4_qmode,
++>>>>>>> 1f705bc61aee (net: stmmac: Add support for CBS QDISC)
  };
  
  const struct stmmac_dma_ops dwmac410_dma_ops = {
@@@ -468,5 -471,5 +486,9 @@@
  	.set_rx_tail_ptr = dwmac4_set_rx_tail_ptr,
  	.set_tx_tail_ptr = dwmac4_set_tx_tail_ptr,
  	.enable_tso = dwmac4_enable_tso,
++<<<<<<< HEAD
 +	.set_bfsize = dwmac4_set_bfsize,
++=======
+ 	.qmode = dwmac4_qmode,
++>>>>>>> 1f705bc61aee (net: stmmac: Add support for CBS QDISC)
  };
diff --cc drivers/net/ethernet/stmicro/stmmac/hwif.h
index fe8b536b13f8,e2a965790648..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.h
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.h
@@@ -183,7 -183,7 +183,11 @@@ struct stmmac_dma_ops 
  	void (*set_rx_tail_ptr)(void __iomem *ioaddr, u32 tail_ptr, u32 chan);
  	void (*set_tx_tail_ptr)(void __iomem *ioaddr, u32 tail_ptr, u32 chan);
  	void (*enable_tso)(void __iomem *ioaddr, bool en, u32 chan);
++<<<<<<< HEAD
 +	void (*set_bfsize)(void __iomem *ioaddr, int bfsize, u32 chan);
++=======
+ 	void (*qmode)(void __iomem *ioaddr, u32 channel, u8 qmode);
++>>>>>>> 1f705bc61aee (net: stmmac: Add support for CBS QDISC)
  };
  
  #define stmmac_reset(__priv, __args...) \
@@@ -236,8 -236,8 +240,13 @@@
  	stmmac_do_void_callback(__priv, dma, set_tx_tail_ptr, __args)
  #define stmmac_enable_tso(__priv, __args...) \
  	stmmac_do_void_callback(__priv, dma, enable_tso, __args)
++<<<<<<< HEAD
 +#define stmmac_set_dma_bfsize(__priv, __args...) \
 +	stmmac_do_void_callback(__priv, dma, set_bfsize, __args)
++=======
+ #define stmmac_dma_qmode(__priv, __args...) \
+ 	stmmac_do_void_callback(__priv, dma, qmode, __args)
++>>>>>>> 1f705bc61aee (net: stmmac: Add support for CBS QDISC)
  
  struct mac_device_info;
  struct net_device;
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index d5fa32fe835c,93a3bea8576e..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -3781,10 -3792,9 +3781,16 @@@ static int stmmac_setup_tc(struct net_d
  
  	switch (type) {
  	case TC_SETUP_BLOCK:
++<<<<<<< HEAD
 +		return flow_block_cb_setup_simple(type_data,
 +						  &stmmac_block_cb_list,
 +						  stmmac_setup_tc_block_cb,
 +						  priv, priv, true);
++=======
+ 		return stmmac_setup_tc_block(priv, type_data);
+ 	case TC_SETUP_QDISC_CBS:
+ 		return stmmac_tc_setup_cbs(priv, priv, type_data);
++>>>>>>> 1f705bc61aee (net: stmmac: Add support for CBS QDISC)
  	default:
  		return -EOPNOTSUPP;
  	}
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/hwif.h
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
index 225c833b2291..afe1af8d9407 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
@@ -288,7 +288,69 @@ static int tc_init(struct stmmac_priv *priv)
 	return 0;
 }
 
+static int tc_setup_cbs(struct stmmac_priv *priv,
+			struct tc_cbs_qopt_offload *qopt)
+{
+	u32 tx_queues_count = priv->plat->tx_queues_to_use;
+	u32 queue = qopt->queue;
+	u32 ptr, speed_div;
+	u32 mode_to_use;
+	u64 value;
+	int ret;
+
+	/* Queue 0 is not AVB capable */
+	if (queue <= 0 || queue >= tx_queues_count)
+		return -EINVAL;
+	if (priv->speed != SPEED_100 && priv->speed != SPEED_1000)
+		return -EOPNOTSUPP;
+
+	mode_to_use = priv->plat->tx_queues_cfg[queue].mode_to_use;
+	if (mode_to_use == MTL_QUEUE_DCB && qopt->enable) {
+		ret = stmmac_dma_qmode(priv, priv->ioaddr, queue, MTL_QUEUE_AVB);
+		if (ret)
+			return ret;
+
+		priv->plat->tx_queues_cfg[queue].mode_to_use = MTL_QUEUE_AVB;
+	} else if (!qopt->enable) {
+		return stmmac_dma_qmode(priv, priv->ioaddr, queue, MTL_QUEUE_DCB);
+	}
+
+	/* Port Transmit Rate and Speed Divider */
+	ptr = (priv->speed == SPEED_100) ? 4 : 8;
+	speed_div = (priv->speed == SPEED_100) ? 100000 : 1000000;
+
+	/* Final adjustments for HW */
+	value = qopt->idleslope * 1024 * ptr;
+	do_div(value, speed_div);
+	priv->plat->tx_queues_cfg[queue].idle_slope = value & GENMASK(31, 0);
+
+	value = -qopt->sendslope * 1024UL * ptr;
+	do_div(value, speed_div);
+	priv->plat->tx_queues_cfg[queue].send_slope = value & GENMASK(31, 0);
+
+	value = qopt->hicredit * 1024 * 8;
+	priv->plat->tx_queues_cfg[queue].high_credit = value & GENMASK(31, 0);
+
+	value = qopt->locredit * 1024 * 8;
+	priv->plat->tx_queues_cfg[queue].low_credit = value & GENMASK(31, 0);
+
+	ret = stmmac_config_cbs(priv, priv->hw,
+				priv->plat->tx_queues_cfg[queue].send_slope,
+				priv->plat->tx_queues_cfg[queue].idle_slope,
+				priv->plat->tx_queues_cfg[queue].high_credit,
+				priv->plat->tx_queues_cfg[queue].low_credit,
+				queue);
+	if (ret)
+		return ret;
+
+	dev_info(priv->device, "CBS queue %d: send %d, idle %d, hi %d, lo %d\n",
+			queue, qopt->sendslope, qopt->idleslope,
+			qopt->hicredit, qopt->locredit);
+	return 0;
+}
+
 const struct stmmac_tc_ops dwmac510_tc_ops = {
 	.init = tc_init,
 	.setup_cls_u32 = tc_setup_cls_u32,
+	.setup_cbs = tc_setup_cbs,
 };
