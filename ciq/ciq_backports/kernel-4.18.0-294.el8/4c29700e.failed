mm/sparse: consistently do not zero memmap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vincent Whitchurch <vincent.whitchurch@axis.com>
commit 4c29700ed9908c15feeb84a40a415f4e921c5a66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4c29700e.failed

sparsemem without VMEMMAP has two allocation paths to allocate the
memory needed for its memmap (done in sparse_mem_map_populate()).

In one allocation path (sparse_buffer_alloc() succeeds), the memory is
not zeroed (since it was previously allocated with
memblock_alloc_try_nid_raw()).

In the other allocation path (sparse_buffer_alloc() fails and
sparse_mem_map_populate() falls back to memblock_alloc_try_nid()), the
memory is zeroed.

AFAICS this difference does not appear to be on purpose.  If the code is
supposed to work with non-initialized memory (__init_single_page() takes
care of zeroing the struct pages which are actually used), we should
consistently not zero the memory, to avoid masking bugs.

( I noticed this because on my ARM64 platform, with 1 GiB of memory the
  first [and only] section is allocated from the zeroing path while with
  2 GiB of memory the first 1 GiB section is allocated from the
  non-zeroing path. )

Michal:
 "the main user visible problem is a memory wastage. The overal amount
  of memory should be small. I wouldn't call it stable material."

Link: http://lkml.kernel.org/r/20191030131122.8256-1-vincent.whitchurch@axis.com
	Signed-off-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4c29700ed9908c15feeb84a40a415f4e921c5a66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/sparse.c
diff --cc mm/sparse.c
index 2b18ff252bdb,01e467adc219..000000000000
--- a/mm/sparse.c
+++ b/mm/sparse.c
@@@ -424,9 -458,13 +424,14 @@@ struct page __init *__populate_section_
  	if (map)
  		return map;
  
++<<<<<<< HEAD
 +	map = memblock_alloc_try_nid(size,
 +					  PAGE_SIZE, __pa(MAX_DMA_ADDRESS),
++=======
+ 	map = memblock_alloc_try_nid_raw(size,
+ 					  PAGE_SIZE, addr,
++>>>>>>> 4c29700ed990 (mm/sparse: consistently do not zero memmap)
  					  MEMBLOCK_ALLOC_ACCESSIBLE, nid);
 -	if (!map)
 -		panic("%s: Failed to allocate %lu bytes align=0x%lx nid=%d from=%pa\n",
 -		      __func__, size, PAGE_SIZE, nid, &addr);
 -
  	return map;
  }
  #endif /* !CONFIG_SPARSEMEM_VMEMMAP */
* Unmerged path mm/sparse.c
