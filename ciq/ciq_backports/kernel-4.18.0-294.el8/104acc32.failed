mm/gup: introduce pin_user_pages_fast_only()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author John Hubbard <jhubbard@nvidia.com>
commit 104acc327648b347d1716374586803e82fa1dc95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/104acc32.failed

This is the FOLL_PIN equivalent of __get_user_pages_fast(), except with a
more descriptive name, and gup_flags instead of a boolean "write" in the
argument list.

	Signed-off-by: John Hubbard <jhubbard@nvidia.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Daniel Vetter <daniel@ffwll.ch>
	Cc: David Airlie <airlied@linux.ie>
	Cc: Jani Nikula <jani.nikula@linux.intel.com>
	Cc: "Joonas Lahtinen" <joonas.lahtinen@linux.intel.com>
	Cc: Matthew Auld <matthew.auld@intel.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Cc: Souptick Joarder <jrdr.linux@gmail.com>
	Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Link: http://lkml.kernel.org/r/20200519002124.2025955-4-jhubbard@nvidia.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 104acc327648b347d1716374586803e82fa1dc95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/gup.c
diff --cc mm/gup.c
index b62e810dd644,0702c1a7e041..000000000000
--- a/mm/gup.c
+++ b/mm/gup.c
@@@ -2297,4 -2804,246 +2297,250 @@@ int get_user_pages_fast(unsigned long s
  	return ret;
  }
  
++<<<<<<< HEAD
 +#endif /* CONFIG_HAVE_GENERIC_GUP */
++=======
+ /*
+  * Like get_user_pages_fast() except it's IRQ-safe in that it won't fall back to
+  * the regular GUP.
+  * Note a difference with get_user_pages_fast: this always returns the
+  * number of pages pinned, 0 if no pages were pinned.
+  *
+  * If the architecture does not support this function, simply return with no
+  * pages pinned.
+  *
+  * Careful, careful! COW breaking can go either way, so a non-write
+  * access can get ambiguous page results. If you call this function without
+  * 'write' set, you'd better be sure that you're ok with that ambiguity.
+  */
+ int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
+ 			  struct page **pages)
+ {
+ 	int nr_pinned;
+ 	/*
+ 	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
+ 	 * because gup fast is always a "pin with a +1 page refcount" request.
+ 	 *
+ 	 * FOLL_FAST_ONLY is required in order to match the API description of
+ 	 * this routine: no fall back to regular ("slow") GUP.
+ 	 */
+ 	unsigned int gup_flags = FOLL_GET | FOLL_FAST_ONLY;
+ 
+ 	if (write)
+ 		gup_flags |= FOLL_WRITE;
+ 
+ 	nr_pinned = internal_get_user_pages_fast(start, nr_pages, gup_flags,
+ 						 pages);
+ 
+ 	/*
+ 	 * As specified in the API description above, this routine is not
+ 	 * allowed to return negative values. However, the common core
+ 	 * routine internal_get_user_pages_fast() *can* return -errno.
+ 	 * Therefore, correct for that here:
+ 	 */
+ 	if (nr_pinned < 0)
+ 		nr_pinned = 0;
+ 
+ 	return nr_pinned;
+ }
+ EXPORT_SYMBOL_GPL(__get_user_pages_fast);
+ 
+ /**
+  * get_user_pages_fast() - pin user pages in memory
+  * @start:      starting user address
+  * @nr_pages:   number of pages from start to pin
+  * @gup_flags:  flags modifying pin behaviour
+  * @pages:      array that receives pointers to the pages pinned.
+  *              Should be at least nr_pages long.
+  *
+  * Attempt to pin user pages in memory without taking mm->mmap_sem.
+  * If not successful, it will fall back to taking the lock and
+  * calling get_user_pages().
+  *
+  * Returns number of pages pinned. This may be fewer than the number requested.
+  * If nr_pages is 0 or negative, returns 0. If no pages were pinned, returns
+  * -errno.
+  */
+ int get_user_pages_fast(unsigned long start, int nr_pages,
+ 			unsigned int gup_flags, struct page **pages)
+ {
+ 	/*
+ 	 * FOLL_PIN must only be set internally by the pin_user_pages*() APIs,
+ 	 * never directly by the caller, so enforce that:
+ 	 */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_PIN))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * The caller may or may not have explicitly set FOLL_GET; either way is
+ 	 * OK. However, internally (within mm/gup.c), gup fast variants must set
+ 	 * FOLL_GET, because gup fast is always a "pin with a +1 page refcount"
+ 	 * request.
+ 	 */
+ 	gup_flags |= FOLL_GET;
+ 	return internal_get_user_pages_fast(start, nr_pages, gup_flags, pages);
+ }
+ EXPORT_SYMBOL_GPL(get_user_pages_fast);
+ 
+ /**
+  * pin_user_pages_fast() - pin user pages in memory without taking locks
+  *
+  * @start:      starting user address
+  * @nr_pages:   number of pages from start to pin
+  * @gup_flags:  flags modifying pin behaviour
+  * @pages:      array that receives pointers to the pages pinned.
+  *              Should be at least nr_pages long.
+  *
+  * Nearly the same as get_user_pages_fast(), except that FOLL_PIN is set. See
+  * get_user_pages_fast() for documentation on the function arguments, because
+  * the arguments here are identical.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for further details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ int pin_user_pages_fast(unsigned long start, int nr_pages,
+ 			unsigned int gup_flags, struct page **pages)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return internal_get_user_pages_fast(start, nr_pages, gup_flags, pages);
+ }
+ EXPORT_SYMBOL_GPL(pin_user_pages_fast);
+ 
+ /*
+  * This is the FOLL_PIN equivalent of __get_user_pages_fast(). Behavior is the
+  * same, except that this one sets FOLL_PIN instead of FOLL_GET.
+  *
+  * The API rules are the same, too: no negative values may be returned.
+  */
+ int pin_user_pages_fast_only(unsigned long start, int nr_pages,
+ 			     unsigned int gup_flags, struct page **pages)
+ {
+ 	int nr_pinned;
+ 
+ 	/*
+ 	 * FOLL_GET and FOLL_PIN are mutually exclusive. Note that the API
+ 	 * rules require returning 0, rather than -errno:
+ 	 */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return 0;
+ 	/*
+ 	 * FOLL_FAST_ONLY is required in order to match the API description of
+ 	 * this routine: no fall back to regular ("slow") GUP.
+ 	 */
+ 	gup_flags |= (FOLL_PIN | FOLL_FAST_ONLY);
+ 	nr_pinned = internal_get_user_pages_fast(start, nr_pages, gup_flags,
+ 						 pages);
+ 	/*
+ 	 * This routine is not allowed to return negative values. However,
+ 	 * internal_get_user_pages_fast() *can* return -errno. Therefore,
+ 	 * correct for that here:
+ 	 */
+ 	if (nr_pinned < 0)
+ 		nr_pinned = 0;
+ 
+ 	return nr_pinned;
+ }
+ EXPORT_SYMBOL_GPL(pin_user_pages_fast_only);
+ 
+ /**
+  * pin_user_pages_remote() - pin pages of a remote process (task != current)
+  *
+  * @tsk:	the task_struct to use for page fault accounting, or
+  *		NULL if faults are not to be recorded.
+  * @mm:		mm_struct of target mm
+  * @start:	starting user address
+  * @nr_pages:	number of pages from start to pin
+  * @gup_flags:	flags modifying lookup behaviour
+  * @pages:	array that receives pointers to the pages pinned.
+  *		Should be at least nr_pages long. Or NULL, if caller
+  *		only intends to ensure the pages are faulted in.
+  * @vmas:	array of pointers to vmas corresponding to each page.
+  *		Or NULL if the caller does not require them.
+  * @locked:	pointer to lock flag indicating whether lock is held and
+  *		subsequently whether VM_FAULT_RETRY functionality can be
+  *		utilised. Lock must initially be held.
+  *
+  * Nearly the same as get_user_pages_remote(), except that FOLL_PIN is set. See
+  * get_user_pages_remote() for documentation on the function arguments, because
+  * the arguments here are identical.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ long pin_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
+ 			   unsigned long start, unsigned long nr_pages,
+ 			   unsigned int gup_flags, struct page **pages,
+ 			   struct vm_area_struct **vmas, int *locked)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return __get_user_pages_remote(tsk, mm, start, nr_pages, gup_flags,
+ 				       pages, vmas, locked);
+ }
+ EXPORT_SYMBOL(pin_user_pages_remote);
+ 
+ /**
+  * pin_user_pages() - pin user pages in memory for use by other devices
+  *
+  * @start:	starting user address
+  * @nr_pages:	number of pages from start to pin
+  * @gup_flags:	flags modifying lookup behaviour
+  * @pages:	array that receives pointers to the pages pinned.
+  *		Should be at least nr_pages long. Or NULL, if caller
+  *		only intends to ensure the pages are faulted in.
+  * @vmas:	array of pointers to vmas corresponding to each page.
+  *		Or NULL if the caller does not require them.
+  *
+  * Nearly the same as get_user_pages(), except that FOLL_TOUCH is not set, and
+  * FOLL_PIN is set.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ long pin_user_pages(unsigned long start, unsigned long nr_pages,
+ 		    unsigned int gup_flags, struct page **pages,
+ 		    struct vm_area_struct **vmas)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return __gup_longterm_locked(current, current->mm, start, nr_pages,
+ 				     pages, vmas, gup_flags);
+ }
+ EXPORT_SYMBOL(pin_user_pages);
+ 
+ /*
+  * pin_user_pages_unlocked() is the FOLL_PIN variant of
+  * get_user_pages_unlocked(). Behavior is the same, except that this one sets
+  * FOLL_PIN and rejects FOLL_GET.
+  */
+ long pin_user_pages_unlocked(unsigned long start, unsigned long nr_pages,
+ 			     struct page **pages, unsigned int gup_flags)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return get_user_pages_unlocked(start, nr_pages, pages, gup_flags);
+ }
+ EXPORT_SYMBOL(pin_user_pages_unlocked);
++>>>>>>> 104acc327648 (mm/gup: introduce pin_user_pages_fast_only())
diff --git a/include/linux/mm.h b/include/linux/mm.h
index ef77bd76b21c..b20980213228 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1528,6 +1528,8 @@ extern int mprotect_fixup(struct vm_area_struct *vma,
  */
 int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
 			  struct page **pages);
+int pin_user_pages_fast_only(unsigned long start, int nr_pages,
+			     unsigned int gup_flags, struct page **pages);
 /*
  * per-process(per-mm_struct) statistics.
  */
* Unmerged path mm/gup.c
