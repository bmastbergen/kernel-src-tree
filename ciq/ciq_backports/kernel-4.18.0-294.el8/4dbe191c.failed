driver core: Add device links from fwnode only for the primary device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 4dbe191c046e71d6ea1ba85365ecb33961b07c4f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4dbe191c.failed

Sometimes, more than one (generally two) device can point to the same
fwnode.  However, only one device is set as the fwnode's device
(fwnode->dev) and can be looked up from the fwnode.

Typically, only one of these devices actually have a driver and actually
probe. If we create device links for all these devices, then the
suppliers' of these devices (with the same fwnode) will never get a
sync_state() call because one of their consumer devices will never probe
(because they don't have a driver).

So, create device links only for the device that is considered as the
fwnode's device.

One such example of this is the PCI bridge platform_device and the
corresponding pci_bus device. Both these devices will have the same
fwnode. It's the platform_device that is registered first and is set as
the fwnode's device. Also the platform_device is the one that actually
probes. Without this patch none of the suppliers of a PCI bridge
platform_device would get a sync_state() callback.

	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: linux-pci@vger.kernel.org
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20200321045448.15192-1-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4dbe191c046e71d6ea1ba85365ecb33961b07c4f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
diff --cc drivers/base/core.c
index 8a0d36852b14,5e3cc1651c78..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -2046,8 -2402,9 +2046,9 @@@ int device_add(struct device *dev
  	struct device *parent;
  	struct kobject *kobj;
  	struct class_interface *class_intf;
 -	int error = -EINVAL, fw_ret;
 +	int error = -EINVAL;
  	struct kobject *glue_dir = NULL;
+ 	bool is_fwnode_dev = false;
  
  	dev = get_device(dev);
  	if (!dev)
@@@ -2145,9 -2502,34 +2146,37 @@@
  
  	kobject_uevent(&dev->kobj, KOBJ_ADD);
  
- 	if (dev->fwnode && !dev->fwnode->dev)
+ 	if (dev->fwnode && !dev->fwnode->dev) {
  		dev->fwnode->dev = dev;
+ 		is_fwnode_dev = true;
+ 	}
+ 
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Check if any of the other devices (consumers) have been waiting for
+ 	 * this device (supplier) to be added so that they can create a device
+ 	 * link to it.
+ 	 *
+ 	 * This needs to happen after device_pm_add() because device_link_add()
+ 	 * requires the supplier be registered before it's called.
+ 	 *
+ 	 * But this also needs to happe before bus_probe_device() to make sure
+ 	 * waiting consumers can link to it before the driver is bound to the
+ 	 * device and the driver sync_state callback is called for this device.
+ 	 */
+ 	device_link_add_missing_supplier_links();
+ 
+ 	if (fw_devlink_flags && is_fwnode_dev &&
+ 	    fwnode_has_op(dev->fwnode, add_links)) {
+ 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+ 		if (fw_ret == -ENODEV)
+ 			device_link_wait_for_mandatory_supplier(dev);
+ 		else if (fw_ret)
+ 			device_link_wait_for_optional_supplier(dev);
+ 	}
  
++>>>>>>> 4dbe191c046e (driver core: Add device links from fwnode only for the primary device)
  	bus_probe_device(dev);
  	if (parent)
  		klist_add_tail(&dev->p->knode_parent,
* Unmerged path drivers/base/core.c
