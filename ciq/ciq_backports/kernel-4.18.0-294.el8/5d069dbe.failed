fuse: fix bad inode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 5d069dbe8aaf2a197142558b6fb2978189ba3454
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5d069dbe.failed

Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

	Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Tested-by: Jan Kara <jack@suse.cz>
	Cc: <stable@vger.kernel.org>
(cherry picked from commit 5d069dbe8aaf2a197142558b6fb2978189ba3454)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
#	fs/fuse/inode.c
#	fs/fuse/xattr.c
diff --cc fs/fuse/file.c
index e64ca703e652,8cccecb55fb8..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -218,7 -229,12 +218,10 @@@ int fuse_open_common(struct inode *inod
  	bool is_wb_truncate = (file->f_flags & O_TRUNC) &&
  			  fc->atomic_o_trunc &&
  			  fc->writeback_cache;
 -	bool dax_truncate = (file->f_flags & O_TRUNC) &&
 -			  fc->atomic_o_trunc && FUSE_IS_DAX(inode);
  
+ 	if (fuse_is_bad(inode))
+ 		return -EIO;
+ 
  	err = generic_file_open(inode, file);
  	if (err)
  		return err;
@@@ -917,90 -949,46 +920,95 @@@ static void fuse_send_readpages(struct 
  		if (!err)
  			return;
  	} else {
 -		res = fuse_simple_request(fm, &ap->args);
 +		res = fuse_simple_request(fc, &ap->args);
  		err = res < 0 ? res : 0;
  	}
 -	fuse_readpages_end(fm, &ap->args, err);
 +	fuse_readpages_end(fc, &ap->args, err);
  }
  
 -static void fuse_readahead(struct readahead_control *rac)
 +struct fuse_fill_data {
 +	struct fuse_io_args *ia;
 +	struct file *file;
 +	struct inode *inode;
 +	unsigned int nr_pages;
 +	unsigned int max_pages;
 +};
 +
 +static int fuse_readpages_fill(void *_data, struct page *page)
  {
 -	struct inode *inode = rac->mapping->host;
 +	struct fuse_fill_data *data = _data;
 +	struct fuse_io_args *ia = data->ia;
 +	struct fuse_args_pages *ap = &ia->ap;
 +	struct inode *inode = data->inode;
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	unsigned int i, max_pages, nr_pages = 0;
  
++<<<<<<< HEAD
 +	fuse_wait_on_page_writeback(inode, page->index);
++=======
+ 	if (fuse_is_bad(inode))
+ 		return;
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
 +
 +	if (ap->num_pages &&
 +	    (ap->num_pages == fc->max_pages ||
 +	     (ap->num_pages + 1) * PAGE_SIZE > fc->max_read ||
 +	     ap->pages[ap->num_pages - 1]->index + 1 != page->index)) {
 +		data->max_pages = min_t(unsigned int, data->nr_pages,
 +					fc->max_pages);
 +		fuse_send_readpages(ia, data->file);
 +		data->ia = ia = fuse_io_alloc(NULL, data->max_pages);
 +		if (!ia) {
 +			unlock_page(page);
 +			return -ENOMEM;
 +		}
 +		ap = &ia->ap;
 +	}
  
 -	max_pages = min_t(unsigned int, fc->max_pages,
 -			fc->max_read / PAGE_SIZE);
 +	if (WARN_ON(ap->num_pages >= data->max_pages)) {
 +		unlock_page(page);
 +		fuse_io_free(ia);
 +		return -EIO;
 +	}
  
 -	for (;;) {
 -		struct fuse_io_args *ia;
 -		struct fuse_args_pages *ap;
 +	get_page(page);
 +	ap->pages[ap->num_pages] = page;
 +	ap->descs[ap->num_pages].length = PAGE_SIZE;
 +	ap->num_pages++;
 +	data->nr_pages--;
 +	return 0;
 +}
  
 -		nr_pages = readahead_count(rac) - nr_pages;
 -		if (nr_pages > max_pages)
 -			nr_pages = max_pages;
 -		if (nr_pages == 0)
 -			break;
 -		ia = fuse_io_alloc(NULL, nr_pages);
 -		if (!ia)
 -			return;
 -		ap = &ia->ap;
 -		nr_pages = __readahead_batch(rac, ap->pages, nr_pages);
 -		for (i = 0; i < nr_pages; i++) {
 -			fuse_wait_on_page_writeback(inode,
 -						    readahead_index(rac) + i);
 -			ap->descs[i].length = PAGE_SIZE;
 -		}
 -		ap->num_pages = nr_pages;
 -		fuse_send_readpages(ia, rac->file);
 +static int fuse_readpages(struct file *file, struct address_space *mapping,
 +			  struct list_head *pages, unsigned nr_pages)
 +{
 +	struct inode *inode = mapping->host;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
 +	struct fuse_fill_data data;
 +	int err;
 +
 +	err = -EIO;
 +	if (is_bad_inode(inode))
 +		goto out;
 +
 +	data.file = file;
 +	data.inode = inode;
 +	data.nr_pages = nr_pages;
 +	data.max_pages = min_t(unsigned int, nr_pages, fc->max_pages);
 +;
 +	data.ia = fuse_io_alloc(NULL, data.max_pages);
 +	err = -ENOMEM;
 +	if (!data.ia)
 +		goto out;
 +
 +	err = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);
 +	if (!err) {
 +		if (data.ia->ap.num_pages)
 +			fuse_send_readpages(data.ia, file);
 +		else
 +			fuse_io_free(data.ia);
  	}
 +out:
 +	return err;
  }
  
  static ssize_t fuse_cache_read_iter(struct kiocb *iocb, struct iov_iter *to)
@@@ -1574,10 -1571,14 +1582,14 @@@ static ssize_t fuse_file_read_iter(stru
  {
  	struct file *file = iocb->ki_filp;
  	struct fuse_file *ff = file->private_data;
 -	struct inode *inode = file_inode(file);
  
++<<<<<<< HEAD
 +	if (is_bad_inode(file_inode(file)))
++=======
+ 	if (fuse_is_bad(inode))
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		return -EIO;
  
 -	if (FUSE_IS_DAX(inode))
 -		return fuse_dax_read_iter(iocb, to);
 -
  	if (!(ff->open_flags & FOPEN_DIRECT_IO))
  		return fuse_cache_read_iter(iocb, to);
  	else
@@@ -1588,10 -1589,14 +1600,14 @@@ static ssize_t fuse_file_write_iter(str
  {
  	struct file *file = iocb->ki_filp;
  	struct fuse_file *ff = file->private_data;
 -	struct inode *inode = file_inode(file);
  
++<<<<<<< HEAD
 +	if (is_bad_inode(file_inode(file)))
++=======
+ 	if (fuse_is_bad(inode))
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		return -EIO;
  
 -	if (FUSE_IS_DAX(inode))
 -		return fuse_dax_write_iter(iocb, from);
 -
  	if (!(ff->open_flags & FOPEN_DIRECT_IO))
  		return fuse_cache_write_iter(iocb, from);
  	else
diff --cc fs/fuse/inode.c
index 10b75246113a,b0e18b470e91..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -80,26 -85,54 +80,44 @@@ static struct inode *fuse_alloc_inode(s
  	fi->orig_ino = 0;
  	fi->state = 0;
  	mutex_init(&fi->mutex);
 -	init_rwsem(&fi->i_mmap_sem);
  	spin_lock_init(&fi->lock);
  	fi->forget = fuse_alloc_forget();
 -	if (!fi->forget)
 -		goto out_free;
 -
 -	if (IS_ENABLED(CONFIG_FUSE_DAX) && !fuse_dax_inode_alloc(sb, fi))
 -		goto out_free_forget;
 +	if (!fi->forget) {
 +		kmem_cache_free(fuse_inode_cachep, fi);
 +		return NULL;
 +	}
  
  	return &fi->inode;
 -
 -out_free_forget:
 -	kfree(fi->forget);
 -out_free:
 -	kmem_cache_free(fuse_inode_cachep, fi);
 -	return NULL;
  }
  
 -static void fuse_free_inode(struct inode *inode)
 +static void fuse_i_callback(struct rcu_head *head)
  {
 -	struct fuse_inode *fi = get_fuse_inode(inode);
 -
 -	mutex_destroy(&fi->mutex);
 -	kfree(fi->forget);
 -#ifdef CONFIG_FUSE_DAX
 -	kfree(fi->dax);
 -#endif
 -	kmem_cache_free(fuse_inode_cachep, fi);
 +	struct inode *inode = container_of(head, struct inode, i_rcu);
 +	kmem_cache_free(fuse_inode_cachep, inode);
  }
  
 -static void fuse_evict_inode(struct inode *inode)
 +static void fuse_destroy_inode(struct inode *inode)
  {
  	struct fuse_inode *fi = get_fuse_inode(inode);
++<<<<<<< HEAD
 +	if (S_ISREG(inode->i_mode) && !is_bad_inode(inode)) {
++=======
+ 
+ 	truncate_inode_pages_final(&inode->i_data);
+ 	clear_inode(inode);
+ 	if (inode->i_sb->s_flags & SB_ACTIVE) {
+ 		struct fuse_conn *fc = get_fuse_conn(inode);
+ 
+ 		if (FUSE_IS_DAX(inode))
+ 			fuse_dax_inode_cleanup(inode);
+ 		if (fi->nlookup) {
+ 			fuse_queue_forget(fc, fi->forget, fi->nodeid,
+ 					  fi->nlookup);
+ 			fi->forget = NULL;
+ 		}
+ 	}
+ 	if (S_ISREG(inode->i_mode) && !fuse_is_bad(inode)) {
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		WARN_ON(!list_empty(&fi->write_files));
  		WARN_ON(!list_empty(&fi->queued_writes));
  	}
diff --cc fs/fuse/xattr.c
index 20d052e08b3b,cdea18de94f7..000000000000
--- a/fs/fuse/xattr.c
+++ b/fs/fuse/xattr.c
@@@ -113,10 -113,13 +113,17 @@@ ssize_t fuse_listxattr(struct dentry *e
  	struct fuse_getxattr_out outarg;
  	ssize_t ret;
  
++<<<<<<< HEAD
 +	if (!fuse_allow_current_process(fc))
++=======
+ 	if (fuse_is_bad(inode))
+ 		return -EIO;
+ 
+ 	if (!fuse_allow_current_process(fm->fc))
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		return -EACCES;
  
 -	if (fm->fc->no_listxattr)
 +	if (fc->no_listxattr)
  		return -EOPNOTSUPP;
  
  	memset(&inarg, 0, sizeof(inarg));
diff --git a/fs/fuse/acl.c b/fs/fuse/acl.c
index 5a48cee6d7d3..f529075a2ce8 100644
--- a/fs/fuse/acl.c
+++ b/fs/fuse/acl.c
@@ -19,6 +19,9 @@ struct posix_acl *fuse_get_acl(struct inode *inode, int type)
 	void *value = NULL;
 	struct posix_acl *acl;
 
+	if (fuse_is_bad(inode))
+		return ERR_PTR(-EIO);
+
 	if (!fc->posix_acl || fc->no_getxattr)
 		return NULL;
 
@@ -53,6 +56,9 @@ int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	const char *name;
 	int ret;
 
+	if (fuse_is_bad(inode))
+		return -EIO;
+
 	if (!fc->posix_acl || fc->no_setxattr)
 		return -EOPNOTSUPP;
 
diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c
index 289872b15779..3c98f2906b41 100644
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -201,7 +201,7 @@ static int fuse_dentry_revalidate(struct dentry *entry, unsigned int flags)
 	int ret;
 
 	inode = d_inode_rcu(entry);
-	if (inode && is_bad_inode(inode))
+	if (inode && fuse_is_bad(inode))
 		goto invalid;
 	else if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||
 		 (flags & LOOKUP_REVAL)) {
@@ -386,6 +386,9 @@ static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,
 	bool outarg_valid = true;
 	bool locked;
 
+	if (fuse_is_bad(dir))
+		return ERR_PTR(-EIO);
+
 	locked = fuse_lock_inode(dir);
 	err = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,
 			       &outarg, &inode);
@@ -529,6 +532,9 @@ static int fuse_atomic_open(struct inode *dir, struct dentry *entry,
 	struct fuse_conn *fc = get_fuse_conn(dir);
 	struct dentry *res = NULL;
 
+	if (fuse_is_bad(dir))
+		return -EIO;
+
 	if (d_in_lookup(entry)) {
 		res = fuse_lookup(dir, entry, 0);
 		if (IS_ERR(res))
@@ -576,6 +582,9 @@ static int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,
 	int err;
 	struct fuse_forget_link *forget;
 
+	if (fuse_is_bad(dir))
+		return -EIO;
+
 	forget = fuse_alloc_forget();
 	if (!forget)
 		return -ENOMEM;
@@ -697,6 +706,9 @@ static int fuse_unlink(struct inode *dir, struct dentry *entry)
 	struct fuse_conn *fc = get_fuse_conn(dir);
 	FUSE_ARGS(args);
 
+	if (fuse_is_bad(dir))
+		return -EIO;
+
 	args.opcode = FUSE_UNLINK;
 	args.nodeid = get_node_id(dir);
 	args.in_numargs = 1;
@@ -733,6 +745,9 @@ static int fuse_rmdir(struct inode *dir, struct dentry *entry)
 	struct fuse_conn *fc = get_fuse_conn(dir);
 	FUSE_ARGS(args);
 
+	if (fuse_is_bad(dir))
+		return -EIO;
+
 	args.opcode = FUSE_RMDIR;
 	args.nodeid = get_node_id(dir);
 	args.in_numargs = 1;
@@ -811,6 +826,9 @@ static int fuse_rename2(struct inode *olddir, struct dentry *oldent,
 	struct fuse_conn *fc = get_fuse_conn(olddir);
 	int err;
 
+	if (fuse_is_bad(olddir))
+		return -EIO;
+
 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
 		return -EINVAL;
 
@@ -946,7 +964,7 @@ static int fuse_do_getattr(struct inode *inode, struct kstat *stat,
 	if (!err) {
 		if (fuse_invalid_attr(&outarg.attr) ||
 		    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
-			make_bad_inode(inode);
+			fuse_make_bad(inode);
 			err = -EIO;
 		} else {
 			fuse_change_attributes(inode, &outarg.attr,
@@ -1148,6 +1166,9 @@ static int fuse_permission(struct inode *inode, int mask)
 	bool refreshed = false;
 	int err = 0;
 
+	if (fuse_is_bad(inode))
+		return -EIO;
+
 	if (!fuse_allow_current_process(fc))
 		return -EACCES;
 
@@ -1243,7 +1264,7 @@ static const char *fuse_get_link(struct dentry *dentry, struct inode *inode,
 	int err;
 
 	err = -EIO;
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		goto out_err;
 
 	if (fc->cache_symlinks)
@@ -1291,7 +1312,7 @@ static int fuse_dir_fsync(struct file *file, loff_t start, loff_t end,
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	if (fc->no_fsyncdir)
@@ -1568,7 +1589,7 @@ int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,
 
 	if (fuse_invalid_attr(&outarg.attr) ||
 	    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
-		make_bad_inode(inode);
+		fuse_make_bad(inode);
 		err = -EIO;
 		goto error;
 	}
@@ -1624,6 +1645,9 @@ static int fuse_setattr(struct dentry *entry, struct iattr *attr)
 	struct file *file = (attr->ia_valid & ATTR_FILE) ? attr->ia_file : NULL;
 	int ret;
 
+	if (fuse_is_bad(inode))
+		return -EIO;
+
 	if (!fuse_allow_current_process(get_fuse_conn(inode)))
 		return -EACCES;
 
@@ -1682,6 +1706,9 @@ static int fuse_getattr(const struct path *path, struct kstat *stat,
 	struct inode *inode = d_inode(path->dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 
+	if (fuse_is_bad(inode))
+		return -EIO;
+
 	if (!fuse_allow_current_process(fc)) {
 		if (!request_mask) {
 			/*
* Unmerged path fs/fuse/file.c
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 50415774dba0..8efa693a0e0b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -158,6 +158,8 @@ enum {
 	FUSE_I_INIT_RDPLUS,
 	/** An operation changing file size is in progress  */
 	FUSE_I_SIZE_UNSTABLE,
+	/* Bad inode */
+	FUSE_I_BAD,
 };
 
 struct fuse_conn;
@@ -786,6 +788,16 @@ static inline u64 fuse_get_attr_version(struct fuse_conn *fc)
 	return atomic64_read(&fc->attr_version);
 }
 
+static inline void fuse_make_bad(struct inode *inode)
+{
+	set_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);
+}
+
+static inline bool fuse_is_bad(struct inode *inode)
+{
+	return unlikely(test_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state));
+}
+
 /** Device operations */
 extern const struct file_operations fuse_dev_operations;
 
* Unmerged path fs/fuse/inode.c
diff --git a/fs/fuse/readdir.c b/fs/fuse/readdir.c
index 6a40f75a0d25..70f685b61e3a 100644
--- a/fs/fuse/readdir.c
+++ b/fs/fuse/readdir.c
@@ -207,7 +207,7 @@ static int fuse_direntplus_link(struct file *file,
 			dput(dentry);
 			goto retry;
 		}
-		if (is_bad_inode(inode)) {
+		if (fuse_is_bad(inode)) {
 			dput(dentry);
 			return -EIO;
 		}
@@ -568,7 +568,7 @@ int fuse_readdir(struct file *file, struct dir_context *ctx)
 	struct inode *inode = file_inode(file);
 	int err;
 
-	if (is_bad_inode(inode))
+	if (fuse_is_bad(inode))
 		return -EIO;
 
 	mutex_lock(&ff->readdir.lock);
* Unmerged path fs/fuse/xattr.c
