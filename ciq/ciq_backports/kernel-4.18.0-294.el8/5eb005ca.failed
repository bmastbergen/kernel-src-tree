NFS: Rename struct nfs_parsed_mount_data to struct nfs_fs_context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 5eb005caf5383dd328199f0f2114cd7dad731d3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5eb005ca.failed

Rename struct nfs_parsed_mount_data to struct nfs_fs_context and rename
pointers to it to "ctx".  At some point this will be pointed to by an
fs_context struct's fs_private pointer.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 5eb005caf5383dd328199f0f2114cd7dad731d3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/fs_context.c
#	fs/nfs/internal.h
#	fs/nfs/super.c
diff --cc fs/nfs/internal.h
index feae10c2f600,7131fa150d1b..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -137,8 -138,7 +137,12 @@@ struct nfs_mount_request 
  
  struct nfs_mount_info {
  	unsigned int inherited_bsize;
++<<<<<<< HEAD
 +	int (*set_security)(struct super_block *, struct dentry *, struct nfs_mount_info *);
 +	struct nfs_parsed_mount_data *parsed;
++=======
+ 	struct nfs_fs_context *ctx;
++>>>>>>> 5eb005caf538 (NFS: Rename struct nfs_parsed_mount_data to struct nfs_fs_context)
  	struct nfs_clone_mount *cloned;
  	struct nfs_server *server;
  	struct nfs_fh *mntfh;
@@@ -225,6 -225,22 +229,25 @@@ extern const struct svc_version nfs4_ca
  extern const struct svc_version nfs4_callback_version4;
  
  struct nfs_pageio_descriptor;
++<<<<<<< HEAD
++=======
+ 
+ /* mount.c */
+ #define NFS_TEXT_DATA		1
+ 
+ extern struct nfs_fs_context *nfs_alloc_parsed_mount_data(void);
+ extern void nfs_free_parsed_mount_data(struct nfs_fs_context *ctx);
+ extern int nfs_parse_mount_options(char *raw, struct nfs_fs_context *ctx);
+ extern int nfs_validate_mount_data(struct file_system_type *fs_type,
+ 				   void *options,
+ 				   struct nfs_fs_context *ctx,
+ 				   struct nfs_fh *mntfh,
+ 				   const char *dev_name);
+ extern int nfs_validate_text_mount_data(void *options,
+ 					struct nfs_fs_context *ctx,
+ 					const char *dev_name);
+ 
++>>>>>>> 5eb005caf538 (NFS: Rename struct nfs_parsed_mount_data to struct nfs_fs_context)
  /* pagelist.c */
  extern int __init nfs_init_nfspagecache(void);
  extern void nfs_destroy_nfspagecache(void);
diff --cc fs/nfs/super.c
index 5a0a0d311ce8,83527515590e..000000000000
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@@ -1087,633 -726,13 +1087,639 @@@ bool nfs_auth_info_match(const struct n
  EXPORT_SYMBOL_GPL(nfs_auth_info_match);
  
  /*
++<<<<<<< HEAD
 + * Parse the value of the 'sec=' option.
 + */
 +static int nfs_parse_security_flavors(char *value,
 +				      struct nfs_parsed_mount_data *mnt)
 +{
 +	substring_t args[MAX_OPT_ARGS];
 +	rpc_authflavor_t pseudoflavor;
 +	char *p;
 +
 +	dfprintk(MOUNT, "NFS: parsing sec=%s option\n", value);
 +
 +	while ((p = strsep(&value, ":")) != NULL) {
 +		switch (match_token(p, nfs_secflavor_tokens, args)) {
 +		case Opt_sec_none:
 +			pseudoflavor = RPC_AUTH_NULL;
 +			break;
 +		case Opt_sec_sys:
 +			pseudoflavor = RPC_AUTH_UNIX;
 +			break;
 +		case Opt_sec_krb5:
 +			pseudoflavor = RPC_AUTH_GSS_KRB5;
 +			break;
 +		case Opt_sec_krb5i:
 +			pseudoflavor = RPC_AUTH_GSS_KRB5I;
 +			break;
 +		case Opt_sec_krb5p:
 +			pseudoflavor = RPC_AUTH_GSS_KRB5P;
 +			break;
 +		case Opt_sec_lkey:
 +			pseudoflavor = RPC_AUTH_GSS_LKEY;
 +			break;
 +		case Opt_sec_lkeyi:
 +			pseudoflavor = RPC_AUTH_GSS_LKEYI;
 +			break;
 +		case Opt_sec_lkeyp:
 +			pseudoflavor = RPC_AUTH_GSS_LKEYP;
 +			break;
 +		case Opt_sec_spkm:
 +			pseudoflavor = RPC_AUTH_GSS_SPKM;
 +			break;
 +		case Opt_sec_spkmi:
 +			pseudoflavor = RPC_AUTH_GSS_SPKMI;
 +			break;
 +		case Opt_sec_spkmp:
 +			pseudoflavor = RPC_AUTH_GSS_SPKMP;
 +			break;
 +		default:
 +			dfprintk(MOUNT,
 +				 "NFS: sec= option '%s' not recognized\n", p);
 +			return 0;
 +		}
 +
 +		if (!nfs_auth_info_add(&mnt->auth_info, pseudoflavor))
 +			return 0;
 +	}
 +
 +	return 1;
 +}
 +
 +static int nfs_parse_version_string(char *string,
 +		struct nfs_parsed_mount_data *mnt,
 +		substring_t *args)
 +{
 +	mnt->flags &= ~NFS_MOUNT_VER3;
 +	switch (match_token(string, nfs_vers_tokens, args)) {
 +	case Opt_vers_2:
 +		mnt->version = 2;
 +		break;
 +	case Opt_vers_3:
 +		mnt->flags |= NFS_MOUNT_VER3;
 +		mnt->version = 3;
 +		break;
 +	case Opt_vers_4:
 +		/* Backward compatibility option. In future,
 +		 * the mount program should always supply
 +		 * a NFSv4 minor version number.
 +		 */
 +		mnt->version = 4;
 +		break;
 +	case Opt_vers_4_0:
 +		mnt->version = 4;
 +		mnt->minorversion = 0;
 +		break;
 +	case Opt_vers_4_1:
 +		mnt->version = 4;
 +		mnt->minorversion = 1;
 +		break;
 +	case Opt_vers_4_2:
 +		mnt->version = 4;
 +		mnt->minorversion = 2;
 +		break;
 +	default:
 +		return 0;
 +	}
 +	return 1;
 +}
 +
 +static int nfs_get_option_str(substring_t args[], char **option)
 +{
 +	kfree(*option);
 +	*option = match_strdup(args);
 +	return !*option;
 +}
 +
 +static int nfs_get_option_ul(substring_t args[], unsigned long *option)
 +{
 +	int rc;
 +	char *string;
 +
 +	string = match_strdup(args);
 +	if (string == NULL)
 +		return -ENOMEM;
 +	rc = kstrtoul(string, 10, option);
 +	kfree(string);
 +
 +	return rc;
 +}
 +
 +static int nfs_get_option_ul_bound(substring_t args[], unsigned long *option,
 +		unsigned long l_bound, unsigned long u_bound)
 +{
 +	int ret;
 +
 +	ret = nfs_get_option_ul(args, option);
 +	if (ret != 0)
 +		return ret;
 +	if (*option < l_bound || *option > u_bound)
 +		return -ERANGE;
 +	return 0;
 +}
 +
 +/*
 + * Error-check and convert a string of mount options from user space into
 + * a data structure.  The whole mount string is processed; bad options are
 + * skipped as they are encountered.  If there were no errors, return 1;
 + * otherwise return 0 (zero).
 + */
 +static int nfs_parse_mount_options(char *raw,
 +				   struct nfs_parsed_mount_data *mnt)
 +{
 +	char *p, *string;
 +	int rc, sloppy = 0, invalid_option = 0;
 +	unsigned short protofamily = AF_UNSPEC;
 +	unsigned short mountfamily = AF_UNSPEC;
 +
 +	if (!raw) {
 +		dfprintk(MOUNT, "NFS: mount options string was NULL.\n");
 +		return 1;
 +	}
 +	dfprintk(MOUNT, "NFS: nfs mount opts='%s'\n", raw);
 +
 +	rc = security_sb_eat_lsm_opts(raw, &mnt->lsm_opts);
 +	if (rc)
 +		goto out_security_failure;
 +
 +	while ((p = strsep(&raw, ",")) != NULL) {
 +		substring_t args[MAX_OPT_ARGS];
 +		unsigned long option;
 +		int token;
 +
 +		if (!*p)
 +			continue;
 +
 +		dfprintk(MOUNT, "NFS:   parsing nfs mount option '%s'\n", p);
 +
 +		token = match_token(p, nfs_mount_option_tokens, args);
 +		switch (token) {
 +
 +		/*
 +		 * boolean options:  foo/nofoo
 +		 */
 +		case Opt_soft:
 +			mnt->flags |= NFS_MOUNT_SOFT;
 +			mnt->flags &= ~NFS_MOUNT_SOFTERR;
 +			break;
 +		case Opt_softerr:
 +			mnt->flags |= NFS_MOUNT_SOFTERR;
 +			mnt->flags &= ~NFS_MOUNT_SOFT;
 +			break;
 +		case Opt_hard:
 +			mnt->flags &= ~(NFS_MOUNT_SOFT|NFS_MOUNT_SOFTERR);
 +			break;
 +		case Opt_posix:
 +			mnt->flags |= NFS_MOUNT_POSIX;
 +			break;
 +		case Opt_noposix:
 +			mnt->flags &= ~NFS_MOUNT_POSIX;
 +			break;
 +		case Opt_cto:
 +			mnt->flags &= ~NFS_MOUNT_NOCTO;
 +			break;
 +		case Opt_nocto:
 +			mnt->flags |= NFS_MOUNT_NOCTO;
 +			break;
 +		case Opt_ac:
 +			mnt->flags &= ~NFS_MOUNT_NOAC;
 +			break;
 +		case Opt_noac:
 +			mnt->flags |= NFS_MOUNT_NOAC;
 +			break;
 +		case Opt_lock:
 +			mnt->flags &= ~NFS_MOUNT_NONLM;
 +			mnt->flags &= ~(NFS_MOUNT_LOCAL_FLOCK |
 +					NFS_MOUNT_LOCAL_FCNTL);
 +			break;
 +		case Opt_nolock:
 +			mnt->flags |= NFS_MOUNT_NONLM;
 +			mnt->flags |= (NFS_MOUNT_LOCAL_FLOCK |
 +				       NFS_MOUNT_LOCAL_FCNTL);
 +			break;
 +		case Opt_udp:
 +			mnt->flags &= ~NFS_MOUNT_TCP;
 +			mnt->nfs_server.protocol = XPRT_TRANSPORT_UDP;
 +			break;
 +		case Opt_tcp:
 +			mnt->flags |= NFS_MOUNT_TCP;
 +			mnt->nfs_server.protocol = XPRT_TRANSPORT_TCP;
 +			break;
 +		case Opt_rdma:
 +			mnt->flags |= NFS_MOUNT_TCP; /* for side protocols */
 +			mnt->nfs_server.protocol = XPRT_TRANSPORT_RDMA;
 +			xprt_load_transport(p);
 +			break;
 +		case Opt_acl:
 +			mnt->flags &= ~NFS_MOUNT_NOACL;
 +			break;
 +		case Opt_noacl:
 +			mnt->flags |= NFS_MOUNT_NOACL;
 +			break;
 +		case Opt_rdirplus:
 +			mnt->flags &= ~NFS_MOUNT_NORDIRPLUS;
 +			break;
 +		case Opt_nordirplus:
 +			mnt->flags |= NFS_MOUNT_NORDIRPLUS;
 +			break;
 +		case Opt_sharecache:
 +			mnt->flags &= ~NFS_MOUNT_UNSHARED;
 +			break;
 +		case Opt_nosharecache:
 +			mnt->flags |= NFS_MOUNT_UNSHARED;
 +			break;
 +		case Opt_resvport:
 +			mnt->flags &= ~NFS_MOUNT_NORESVPORT;
 +			break;
 +		case Opt_noresvport:
 +			mnt->flags |= NFS_MOUNT_NORESVPORT;
 +			break;
 +		case Opt_fscache:
 +			mnt->options |= NFS_OPTION_FSCACHE;
 +			kfree(mnt->fscache_uniq);
 +			mnt->fscache_uniq = NULL;
 +			break;
 +		case Opt_nofscache:
 +			mnt->options &= ~NFS_OPTION_FSCACHE;
 +			kfree(mnt->fscache_uniq);
 +			mnt->fscache_uniq = NULL;
 +			break;
 +		case Opt_migration:
 +			mnt->options |= NFS_OPTION_MIGRATION;
 +			break;
 +		case Opt_nomigration:
 +			mnt->options &= ~NFS_OPTION_MIGRATION;
 +			break;
 +
 +		/*
 +		 * options that take numeric values
 +		 */
 +		case Opt_port:
 +			if (nfs_get_option_ul(args, &option) ||
 +			    option > USHRT_MAX)
 +				goto out_invalid_value;
 +			mnt->nfs_server.port = option;
 +			break;
 +		case Opt_rsize:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->rsize = option;
 +			break;
 +		case Opt_wsize:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->wsize = option;
 +			break;
 +		case Opt_bsize:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->bsize = option;
 +			break;
 +		case Opt_timeo:
 +			if (nfs_get_option_ul_bound(args, &option, 1, INT_MAX))
 +				goto out_invalid_value;
 +			mnt->timeo = option;
 +			break;
 +		case Opt_retrans:
 +			if (nfs_get_option_ul_bound(args, &option, 0, INT_MAX))
 +				goto out_invalid_value;
 +			mnt->retrans = option;
 +			break;
 +		case Opt_acregmin:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acregmin = option;
 +			break;
 +		case Opt_acregmax:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acregmax = option;
 +			break;
 +		case Opt_acdirmin:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acdirmin = option;
 +			break;
 +		case Opt_acdirmax:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acdirmax = option;
 +			break;
 +		case Opt_actimeo:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acregmin = mnt->acregmax =
 +			mnt->acdirmin = mnt->acdirmax = option;
 +			break;
 +		case Opt_namelen:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->namlen = option;
 +			break;
 +		case Opt_mountport:
 +			if (nfs_get_option_ul(args, &option) ||
 +			    option > USHRT_MAX)
 +				goto out_invalid_value;
 +			mnt->mount_server.port = option;
 +			break;
 +		case Opt_mountvers:
 +			if (nfs_get_option_ul(args, &option) ||
 +			    option < NFS_MNT_VERSION ||
 +			    option > NFS_MNT3_VERSION)
 +				goto out_invalid_value;
 +			mnt->mount_server.version = option;
 +			break;
 +		case Opt_minorversion:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			if (option > NFS4_MAX_MINOR_VERSION)
 +				goto out_invalid_value;
 +			mnt->minorversion = option;
 +			break;
 +
 +		/*
 +		 * options that take text values
 +		 */
 +		case Opt_nfsvers:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			rc = nfs_parse_version_string(string, mnt, args);
 +			kfree(string);
 +			if (!rc)
 +				goto out_invalid_value;
 +			break;
 +		case Opt_sec:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			rc = nfs_parse_security_flavors(string, mnt);
 +			kfree(string);
 +			if (!rc) {
 +				dfprintk(MOUNT, "NFS:   unrecognized "
 +						"security flavor\n");
 +				return 0;
 +			}
 +			break;
 +		case Opt_proto:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			token = match_token(string,
 +					    nfs_xprt_protocol_tokens, args);
 +
 +			protofamily = AF_INET;
 +			switch (token) {
 +			case Opt_xprt_udp6:
 +				protofamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_udp:
 +				mnt->flags &= ~NFS_MOUNT_TCP;
 +				mnt->nfs_server.protocol = XPRT_TRANSPORT_UDP;
 +				break;
 +			case Opt_xprt_tcp6:
 +				protofamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_tcp:
 +				mnt->flags |= NFS_MOUNT_TCP;
 +				mnt->nfs_server.protocol = XPRT_TRANSPORT_TCP;
 +				break;
 +			case Opt_xprt_rdma6:
 +				protofamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_rdma:
 +				/* vector side protocols to TCP */
 +				mnt->flags |= NFS_MOUNT_TCP;
 +				mnt->nfs_server.protocol = XPRT_TRANSPORT_RDMA;
 +				xprt_load_transport(string);
 +				break;
 +			default:
 +				dfprintk(MOUNT, "NFS:   unrecognized "
 +						"transport protocol\n");
 +				kfree(string);
 +				return 0;
 +			}
 +			kfree(string);
 +			break;
 +		case Opt_mountproto:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			token = match_token(string,
 +					    nfs_xprt_protocol_tokens, args);
 +			kfree(string);
 +
 +			mountfamily = AF_INET;
 +			switch (token) {
 +			case Opt_xprt_udp6:
 +				mountfamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_udp:
 +				mnt->mount_server.protocol = XPRT_TRANSPORT_UDP;
 +				break;
 +			case Opt_xprt_tcp6:
 +				mountfamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_tcp:
 +				mnt->mount_server.protocol = XPRT_TRANSPORT_TCP;
 +				break;
 +			case Opt_xprt_rdma: /* not used for side protocols */
 +			default:
 +				dfprintk(MOUNT, "NFS:   unrecognized "
 +						"transport protocol\n");
 +				return 0;
 +			}
 +			break;
 +		case Opt_addr:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			mnt->nfs_server.addrlen =
 +				rpc_pton(mnt->net, string, strlen(string),
 +					(struct sockaddr *)
 +					&mnt->nfs_server.address,
 +					sizeof(mnt->nfs_server.address));
 +			kfree(string);
 +			if (mnt->nfs_server.addrlen == 0)
 +				goto out_invalid_address;
 +			break;
 +		case Opt_clientaddr:
 +			if (nfs_get_option_str(args, &mnt->client_address))
 +				goto out_nomem;
 +			break;
 +		case Opt_mounthost:
 +			if (nfs_get_option_str(args,
 +					       &mnt->mount_server.hostname))
 +				goto out_nomem;
 +			break;
 +		case Opt_mountaddr:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			mnt->mount_server.addrlen =
 +				rpc_pton(mnt->net, string, strlen(string),
 +					(struct sockaddr *)
 +					&mnt->mount_server.address,
 +					sizeof(mnt->mount_server.address));
 +			kfree(string);
 +			if (mnt->mount_server.addrlen == 0)
 +				goto out_invalid_address;
 +			break;
 +		case Opt_nconnect:
 +			if (nfs_get_option_ul_bound(args, &option, 1, NFS_MAX_CONNECTIONS))
 +				goto out_invalid_value;
 +			mnt->nfs_server.nconnect = option;
 +			break;
 +		case Opt_lookupcache:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			token = match_token(string,
 +					nfs_lookupcache_tokens, args);
 +			kfree(string);
 +			switch (token) {
 +				case Opt_lookupcache_all:
 +					mnt->flags &= ~(NFS_MOUNT_LOOKUP_CACHE_NONEG|NFS_MOUNT_LOOKUP_CACHE_NONE);
 +					break;
 +				case Opt_lookupcache_positive:
 +					mnt->flags &= ~NFS_MOUNT_LOOKUP_CACHE_NONE;
 +					mnt->flags |= NFS_MOUNT_LOOKUP_CACHE_NONEG;
 +					break;
 +				case Opt_lookupcache_none:
 +					mnt->flags |= NFS_MOUNT_LOOKUP_CACHE_NONEG|NFS_MOUNT_LOOKUP_CACHE_NONE;
 +					break;
 +				default:
 +					dfprintk(MOUNT, "NFS:   invalid "
 +							"lookupcache argument\n");
 +					return 0;
 +			}
 +			break;
 +		case Opt_fscache_uniq:
 +			if (nfs_get_option_str(args, &mnt->fscache_uniq))
 +				goto out_nomem;
 +			mnt->options |= NFS_OPTION_FSCACHE;
 +			break;
 +		case Opt_local_lock:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			token = match_token(string, nfs_local_lock_tokens,
 +					args);
 +			kfree(string);
 +			switch (token) {
 +			case Opt_local_lock_all:
 +				mnt->flags |= (NFS_MOUNT_LOCAL_FLOCK |
 +					       NFS_MOUNT_LOCAL_FCNTL);
 +				break;
 +			case Opt_local_lock_flock:
 +				mnt->flags |= NFS_MOUNT_LOCAL_FLOCK;
 +				break;
 +			case Opt_local_lock_posix:
 +				mnt->flags |= NFS_MOUNT_LOCAL_FCNTL;
 +				break;
 +			case Opt_local_lock_none:
 +				mnt->flags &= ~(NFS_MOUNT_LOCAL_FLOCK |
 +						NFS_MOUNT_LOCAL_FCNTL);
 +				break;
 +			default:
 +				dfprintk(MOUNT, "NFS:	invalid	"
 +						"local_lock argument\n");
 +				return 0;
 +			}
 +			break;
 +
 +		/*
 +		 * Special options
 +		 */
 +		case Opt_sloppy:
 +			sloppy = 1;
 +			dfprintk(MOUNT, "NFS:   relaxing parsing rules\n");
 +			break;
 +		case Opt_userspace:
 +		case Opt_deprecated:
 +			dfprintk(MOUNT, "NFS:   ignoring mount option "
 +					"'%s'\n", p);
 +			break;
 +
 +		default:
 +			invalid_option = 1;
 +			dfprintk(MOUNT, "NFS:   unrecognized mount option "
 +					"'%s'\n", p);
 +		}
 +	}
 +
 +	if (!sloppy && invalid_option)
 +		return 0;
 +
 +	if (mnt->minorversion && mnt->version != 4)
 +		goto out_minorversion_mismatch;
 +
 +	if (mnt->options & NFS_OPTION_MIGRATION &&
 +	    (mnt->version != 4 || mnt->minorversion != 0))
 +		goto out_migration_misuse;
 +
 +	/*
 +	 * verify that any proto=/mountproto= options match the address
 +	 * families in the addr=/mountaddr= options.
 +	 */
 +	if (protofamily != AF_UNSPEC &&
 +	    protofamily != mnt->nfs_server.address.ss_family)
 +		goto out_proto_mismatch;
 +
 +	if (mountfamily != AF_UNSPEC) {
 +		if (mnt->mount_server.addrlen) {
 +			if (mountfamily != mnt->mount_server.address.ss_family)
 +				goto out_mountproto_mismatch;
 +		} else {
 +			if (mountfamily != mnt->nfs_server.address.ss_family)
 +				goto out_mountproto_mismatch;
 +		}
 +	}
 +
 +	return 1;
 +
 +out_mountproto_mismatch:
 +	printk(KERN_INFO "NFS: mount server address does not match mountproto= "
 +			 "option\n");
 +	return 0;
 +out_proto_mismatch:
 +	printk(KERN_INFO "NFS: server address does not match proto= option\n");
 +	return 0;
 +out_invalid_address:
 +	printk(KERN_INFO "NFS: bad IP address specified: %s\n", p);
 +	return 0;
 +out_invalid_value:
 +	printk(KERN_INFO "NFS: bad mount option value specified: %s\n", p);
 +	return 0;
 +out_minorversion_mismatch:
 +	printk(KERN_INFO "NFS: mount option vers=%u does not support "
 +			 "minorversion=%u\n", mnt->version, mnt->minorversion);
 +	return 0;
 +out_migration_misuse:
 +	printk(KERN_INFO
 +		"NFS: 'migration' not supported for this NFS version\n");
 +	return 0;
 +out_nomem:
 +	printk(KERN_INFO "NFS: not enough memory to parse option\n");
 +	return 0;
 +out_security_failure:
 +	printk(KERN_INFO "NFS: security options invalid: %d\n", rc);
 +	return 0;
 +}
 +
 +/*
 + * Ensure that a specified authtype in args->auth_info is supported by
 + * the server. Returns 0 and sets args->selected_flavor if it's ok, and
++=======
+  * Ensure that a specified authtype in cfg->auth_info is supported by
+  * the server. Returns 0 and sets cfg->selected_flavor if it's ok, and
++>>>>>>> 5eb005caf538 (NFS: Rename struct nfs_parsed_mount_data to struct nfs_fs_context)
   * -EACCES if not.
   */
- static int nfs_verify_authflavors(struct nfs_parsed_mount_data *args,
- 			rpc_authflavor_t *server_authlist, unsigned int count)
+ static int nfs_verify_authflavors(struct nfs_fs_context *cfg,
+ 				  rpc_authflavor_t *server_authlist,
+ 				  unsigned int count)
  {
  	rpc_authflavor_t flavor = RPC_AUTH_MAXFLAVOR;
  	bool found_auth_null = false;
@@@ -2333,11 -1026,11 +2339,15 @@@ nfs_remount(struct super_block *sb, in
  		*flags |= SB_SYNCHRONOUS;
  
  	/* compare new mount options with old ones */
- 	error = nfs_compare_remount_data(nfss, data);
+ 	error = nfs_compare_remount_data(nfss, ctx);
  	if (!error)
++<<<<<<< HEAD
 +		error = security_sb_remount(sb, &data->lsm_opts);
++=======
+ 		error = security_sb_remount(sb, ctx->lsm_opts);
++>>>>>>> 5eb005caf538 (NFS: Rename struct nfs_parsed_mount_data to struct nfs_fs_context)
  out:
- 	nfs_free_parsed_mount_data(data);
+ 	nfs_free_parsed_mount_data(ctx);
  	return error;
  }
  EXPORT_SYMBOL_GPL(nfs_remount);
@@@ -2674,6 -1322,29 +2684,32 @@@ static struct dentry *nfs_fs_mount_comm
  	if (IS_ERR(mntroot))
  		goto error_splat_super;
  
++<<<<<<< HEAD
++=======
+ 
+ 	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL)
+ 		kflags |= SECURITY_LSM_NATIVE_LABELS;
+ 	if (mount_info->cloned) {
+ 		if (d_inode(mntroot)->i_fop != &nfs_dir_operations) {
+ 			error = -ESTALE;
+ 			goto error_splat_root;
+ 		}
+ 		/* clone any lsm security options from the parent to the new sb */
+ 		error = security_sb_clone_mnt_opts(mount_info->cloned->sb, s, kflags,
+ 				&kflags_out);
+ 	} else {
+ 		error = security_sb_set_mnt_opts(s, mount_info->ctx->lsm_opts,
+ 							kflags, &kflags_out);
+ 	}
+ 	if (error)
+ 		goto error_splat_root;
+ 	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL &&
+ 		!(kflags_out & SECURITY_LSM_NATIVE_LABELS))
+ 		NFS_SB(s)->caps &= ~NFS_CAP_SECURITY_LABEL;
+ 	if (error)
+ 		goto error_splat_root;
+ 
++>>>>>>> 5eb005caf538 (NFS: Rename struct nfs_parsed_mount_data to struct nfs_fs_context)
  	s->s_flags |= SB_ACTIVE;
  
  out:
* Unmerged path fs/nfs/fs_context.c
diff --git a/fs/nfs/client.c b/fs/nfs/client.c
index 1c6787d82fc3..f18b42c03a62 100644
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -663,28 +663,28 @@ EXPORT_SYMBOL_GPL(nfs_init_client);
  * Create a version 2 or 3 client
  */
 static int nfs_init_server(struct nfs_server *server,
-			   const struct nfs_parsed_mount_data *data,
+			   const struct nfs_fs_context *cfg,
 			   struct nfs_subversion *nfs_mod)
 {
 	struct rpc_timeout timeparms;
 	struct nfs_client_initdata cl_init = {
-		.hostname = data->nfs_server.hostname,
-		.addr = (const struct sockaddr *)&data->nfs_server.address,
-		.addrlen = data->nfs_server.addrlen,
+		.hostname = cfg->nfs_server.hostname,
+		.addr = (const struct sockaddr *)&cfg->nfs_server.address,
+		.addrlen = cfg->nfs_server.addrlen,
 		.nfs_mod = nfs_mod,
-		.proto = data->nfs_server.protocol,
-		.net = data->net,
+		.proto = cfg->nfs_server.protocol,
+		.net = cfg->net,
 		.timeparms = &timeparms,
 		.cred = server->cred,
-		.nconnect = data->nfs_server.nconnect,
+		.nconnect = cfg->nfs_server.nconnect,
 		.init_flags = (1UL << NFS_CS_REUSEPORT),
 	};
 	struct nfs_client *clp;
 	int error;
 
-	nfs_init_timeout_values(&timeparms, data->nfs_server.protocol,
-			data->timeo, data->retrans);
-	if (data->flags & NFS_MOUNT_NORESVPORT)
+	nfs_init_timeout_values(&timeparms, cfg->nfs_server.protocol,
+				cfg->timeo, cfg->retrans);
+	if (cfg->flags & NFS_MOUNT_NORESVPORT)
 		set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);
 
 	/* Allocate or find a client reference we can use */
@@ -695,46 +695,46 @@ static int nfs_init_server(struct nfs_server *server,
 	server->nfs_client = clp;
 
 	/* Initialise the client representation from the mount data */
-	server->flags = data->flags;
-	server->options = data->options;
+	server->flags = cfg->flags;
+	server->options = cfg->options;
 	server->caps |= NFS_CAP_HARDLINKS|NFS_CAP_SYMLINKS|NFS_CAP_FILEID|
 		NFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|NFS_CAP_OWNER_GROUP|
 		NFS_CAP_ATIME|NFS_CAP_CTIME|NFS_CAP_MTIME;
 
-	if (data->rsize)
-		server->rsize = nfs_block_size(data->rsize, NULL);
-	if (data->wsize)
-		server->wsize = nfs_block_size(data->wsize, NULL);
+	if (cfg->rsize)
+		server->rsize = nfs_block_size(cfg->rsize, NULL);
+	if (cfg->wsize)
+		server->wsize = nfs_block_size(cfg->wsize, NULL);
 
-	server->acregmin = data->acregmin * HZ;
-	server->acregmax = data->acregmax * HZ;
-	server->acdirmin = data->acdirmin * HZ;
-	server->acdirmax = data->acdirmax * HZ;
+	server->acregmin = cfg->acregmin * HZ;
+	server->acregmax = cfg->acregmax * HZ;
+	server->acdirmin = cfg->acdirmin * HZ;
+	server->acdirmax = cfg->acdirmax * HZ;
 
 	/* Start lockd here, before we might error out */
 	error = nfs_start_lockd(server);
 	if (error < 0)
 		goto error;
 
-	server->port = data->nfs_server.port;
-	server->auth_info = data->auth_info;
+	server->port = cfg->nfs_server.port;
+	server->auth_info = cfg->auth_info;
 
 	error = nfs_init_server_rpcclient(server, &timeparms,
-					  data->selected_flavor);
+					  cfg->selected_flavor);
 	if (error < 0)
 		goto error;
 
 	/* Preserve the values of mount_server-related mount options */
-	if (data->mount_server.addrlen) {
-		memcpy(&server->mountd_address, &data->mount_server.address,
-			data->mount_server.addrlen);
-		server->mountd_addrlen = data->mount_server.addrlen;
+	if (cfg->mount_server.addrlen) {
+		memcpy(&server->mountd_address, &cfg->mount_server.address,
+			cfg->mount_server.addrlen);
+		server->mountd_addrlen = cfg->mount_server.addrlen;
 	}
-	server->mountd_version = data->mount_server.version;
-	server->mountd_port = data->mount_server.port;
-	server->mountd_protocol = data->mount_server.protocol;
+	server->mountd_version = cfg->mount_server.version;
+	server->mountd_port = cfg->mount_server.port;
+	server->mountd_protocol = cfg->mount_server.protocol;
 
-	server->namelen  = data->namlen;
+	server->namelen  = cfg->namlen;
 	return 0;
 
 error:
@@ -975,7 +975,7 @@ struct nfs_server *nfs_create_server(struct nfs_mount_info *mount_info)
 		goto error;
 
 	/* Get a client representation */
-	error = nfs_init_server(server, mount_info->parsed, nfs_mod);
+	error = nfs_init_server(server, mount_info->ctx, nfs_mod);
 	if (error < 0)
 		goto error;
 
@@ -986,7 +986,7 @@ struct nfs_server *nfs_create_server(struct nfs_mount_info *mount_info)
 	if (server->nfs_client->rpc_ops->version == 3) {
 		if (server->namelen == 0 || server->namelen > NFS3_MAXNAMLEN)
 			server->namelen = NFS3_MAXNAMLEN;
-		if (!(mount_info->parsed->flags & NFS_MOUNT_NORDIRPLUS))
+		if (!(mount_info->ctx->flags & NFS_MOUNT_NORDIRPLUS))
 			server->caps |= NFS_CAP_READDIRPLUS;
 	} else {
 		if (server->namelen == 0 || server->namelen > NFS2_MAXNAMLEN)
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/nfs/internal.h
diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c
index 8e928f9e596a..286126a76e90 100644
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@ -1054,61 +1054,61 @@ static int nfs4_server_common_setup(struct nfs_server *server,
  * Create a version 4 volume record
  */
 static int nfs4_init_server(struct nfs_server *server,
-		struct nfs_parsed_mount_data *data)
+			    struct nfs_fs_context *ctx)
 {
 	struct rpc_timeout timeparms;
 	int error;
 
-	nfs_init_timeout_values(&timeparms, data->nfs_server.protocol,
-			data->timeo, data->retrans);
+	nfs_init_timeout_values(&timeparms, ctx->nfs_server.protocol,
+				ctx->timeo, ctx->retrans);
 
 	/* Initialise the client representation from the mount data */
-	server->flags = data->flags;
-	server->options = data->options;
-	server->auth_info = data->auth_info;
+	server->flags = ctx->flags;
+	server->options = ctx->options;
+	server->auth_info = ctx->auth_info;
 
 	/* Use the first specified auth flavor. If this flavor isn't
 	 * allowed by the server, use the SECINFO path to try the
 	 * other specified flavors */
-	if (data->auth_info.flavor_len >= 1)
-		data->selected_flavor = data->auth_info.flavors[0];
+	if (ctx->auth_info.flavor_len >= 1)
+		ctx->selected_flavor = ctx->auth_info.flavors[0];
 	else
-		data->selected_flavor = RPC_AUTH_UNIX;
+		ctx->selected_flavor = RPC_AUTH_UNIX;
 
 	/* Get a client record */
 	error = nfs4_set_client(server,
-			data->nfs_server.hostname,
-			(const struct sockaddr *)&data->nfs_server.address,
-			data->nfs_server.addrlen,
-			data->client_address,
-			data->nfs_server.protocol,
+			ctx->nfs_server.hostname,
+			(const struct sockaddr *)&ctx->nfs_server.address,
+			ctx->nfs_server.addrlen,
+			ctx->client_address,
+			ctx->nfs_server.protocol,
 			&timeparms,
-			data->minorversion,
-			data->nfs_server.nconnect,
-			data->net);
+			ctx->minorversion,
+			ctx->nfs_server.nconnect,
+			ctx->net);
 	if (error < 0)
 		return error;
 
-	if (data->rsize)
-		server->rsize = nfs_block_size(data->rsize, NULL);
-	if (data->wsize)
-		server->wsize = nfs_block_size(data->wsize, NULL);
+	if (ctx->rsize)
+		server->rsize = nfs_block_size(ctx->rsize, NULL);
+	if (ctx->wsize)
+		server->wsize = nfs_block_size(ctx->wsize, NULL);
 
-	server->acregmin = data->acregmin * HZ;
-	server->acregmax = data->acregmax * HZ;
-	server->acdirmin = data->acdirmin * HZ;
-	server->acdirmax = data->acdirmax * HZ;
-	server->port     = data->nfs_server.port;
+	server->acregmin = ctx->acregmin * HZ;
+	server->acregmax = ctx->acregmax * HZ;
+	server->acdirmin = ctx->acdirmin * HZ;
+	server->acdirmax = ctx->acdirmax * HZ;
+	server->port     = ctx->nfs_server.port;
 
 	return nfs_init_server_rpcclient(server, &timeparms,
-					 data->selected_flavor);
+					 ctx->selected_flavor);
 }
 
 /*
  * Create a version 4 volume record
  * - keyed on server and FSID
  */
-/*struct nfs_server *nfs4_create_server(const struct nfs_parsed_mount_data *data,
+/*struct nfs_server *nfs4_create_server(const struct nfs_fs_context *data,
 				      struct nfs_fh *mntfh)*/
 struct nfs_server *nfs4_create_server(struct nfs_mount_info *mount_info)
 {
@@ -1122,10 +1122,10 @@ struct nfs_server *nfs4_create_server(struct nfs_mount_info *mount_info)
 
 	server->cred = get_cred(current_cred());
 
-	auth_probe = mount_info->parsed->auth_info.flavor_len < 1;
+	auth_probe = mount_info->ctx->auth_info.flavor_len < 1;
 
 	/* set up the general RPC client */
-	error = nfs4_init_server(server, mount_info->parsed);
+	error = nfs4_init_server(server, mount_info->ctx);
 	if (error < 0)
 		goto error;
 
diff --git a/fs/nfs/nfs4super.c b/fs/nfs/nfs4super.c
index b5c4630cd799..fd2a801361b1 100644
--- a/fs/nfs/nfs4super.c
+++ b/fs/nfs/nfs4super.c
@@ -197,7 +197,7 @@ static struct dentry *do_nfs4_mount(struct nfs_server *server, int flags,
 struct dentry *nfs4_try_mount(int flags, const char *dev_name,
 			      struct nfs_mount_info *mount_info)
 {
-	struct nfs_parsed_mount_data *data = mount_info->parsed;
+	struct nfs_fs_context *ctx = mount_info->ctx;
 	struct dentry *res;
 
 	mount_info->set_security = nfs_set_sb_security;
@@ -206,8 +206,8 @@ struct dentry *nfs4_try_mount(int flags, const char *dev_name,
 
 	res = do_nfs4_mount(nfs4_create_server(mount_info),
 			    flags, mount_info,
-			    data->nfs_server.hostname,
-			    data->nfs_server.export_path);
+			    ctx->nfs_server.hostname,
+			    ctx->nfs_server.export_path);
 
 	dfprintk(MOUNT, "<-- nfs4_try_mount() = %d%s\n",
 		 PTR_ERR_OR_ZERO(res),
* Unmerged path fs/nfs/super.c
