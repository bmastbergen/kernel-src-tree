iomap: Set all uptodate bits for an Uptodate page

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Matthew Wilcox (Oracle) <willy@infradead.org>
commit 4595a298d5563cf76c1d852970f162051fd1a7a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4595a298.failed

For filesystems with block size < page size, we need to set all the
per-block uptodate bits if the page was already uptodate at the time
we create the per-block metadata.  This can happen if the page is
invalidated (eg by a write to drop_caches) but ultimately not removed
from the page cache.

This is a data corruption issue as page writeback skips blocks which
are marked !uptodate.

Fixes: 9dc55f1389f9 ("iomap: add support for sub-pagesize buffered I/O without buffer heads")
	Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
	Reported-by: Qian Cai <cai@redhat.com>
	Cc: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Gao Xiang <hsiangkao@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 4595a298d5563cf76c1d852970f162051fd1a7a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/buffered-io.c
diff --cc fs/iomap/buffered-io.c
index b83d7317385a,8180061b9e16..000000000000
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@@ -46,23 -52,17 +46,29 @@@ static struct iomap_page 
  iomap_page_create(struct inode *inode, struct page *page)
  {
  	struct iomap_page *iop = to_iomap_page(page);
 -	unsigned int nr_blocks = i_blocks_per_page(inode, page);
  
 -	if (iop || nr_blocks <= 1)
 +	if (iop || i_blocksize(inode) == PAGE_SIZE)
  		return iop;
  
 -	iop = kzalloc(struct_size(iop, uptodate, BITS_TO_LONGS(nr_blocks)),
 -			GFP_NOFS | __GFP_NOFAIL);
 +	iop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);
 +	atomic_set(&iop->read_count, 0);
 +	atomic_set(&iop->write_count, 0);
  	spin_lock_init(&iop->uptodate_lock);
++<<<<<<< HEAD
 +	bitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);
 +
 +	/*
 +	 * migrate_page_move_mapping() assumes that pages with private data have
 +	 * their count elevated by 1.
 +	 */
 +	get_page(page);
 +	set_page_private(page, (unsigned long)iop);
 +	SetPagePrivate(page);
++=======
+ 	if (PageUptodate(page))
+ 		bitmap_fill(iop->uptodate, nr_blocks);
+ 	attach_page_private(page, iop);
++>>>>>>> 4595a298d556 (iomap: Set all uptodate bits for an Uptodate page)
  	return iop;
  }
  
* Unmerged path fs/iomap/buffered-io.c
