mm/page_isolation.c: convert SKIP_HWPOISON to MEMORY_OFFLINE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Hildenbrand <david@redhat.com>
commit 756d25be457fc5497da0ceee0f3d0c9eb4d8535d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/756d25be.failed

We have two types of users of page isolation:

 1. Memory offlining:  Offline memory so it can be unplugged. Memory
                       won't be touched.

 2. Memory allocation: Allocate memory (e.g., alloc_contig_range()) to
                       become the owner of the memory and make use of
                       it.

For example, in case we want to offline memory, we can ignore (skip
over) PageHWPoison() pages, as the memory won't get used.  We can allow
to offline memory.  In contrast, we don't want to allow to allocate such
memory.

Let's generalize the approach so we can special case other types of
pages we want to skip over in case we offline memory.  While at it, also
pass the same flags to test_pages_isolated().

Link: http://lkml.kernel.org/r/20191021172353.3056-3-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Suggested-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Anshuman Khandual <anshuman.khandual@arm.com>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Pingfan Liu <kernelfans@gmail.com>
	Cc: Qian Cai <cai@lca.pw>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Cc: Alexander Duyck <alexander.h.duyck@linux.intel.com>
	Cc: Mike Rapoport <rppt@linux.ibm.com>
	Cc: Pavel Tatashin <pavel.tatashin@microsoft.com>
	Cc: Wei Yang <richard.weiyang@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 756d25be457fc5497da0ceee0f3d0c9eb4d8535d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/page-isolation.h
#	mm/memory_hotplug.c
#	mm/page_alloc.c
#	mm/page_isolation.c
diff --cc include/linux/page-isolation.h
index 6e9e72274b0d,6861df759fad..000000000000
--- a/include/linux/page-isolation.h
+++ b/include/linux/page-isolation.h
@@@ -30,8 -30,11 +30,14 @@@ static inline bool is_migrate_isolate(i
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ #define MEMORY_OFFLINE	0x1
+ #define REPORT_FAILURE	0x2
+ 
++>>>>>>> 756d25be457f (mm/page_isolation.c: convert SKIP_HWPOISON to MEMORY_OFFLINE)
  bool has_unmovable_pages(struct zone *zone, struct page *page, int count,
 -			 int migratetype, int flags);
 +			 int migratetype, bool skip_hwpoisoned_pages);
  void set_pageblock_migratetype(struct page *page, int migratetype);
  int move_freepages_block(struct zone *zone, struct page *page,
  				int migratetype, int *num_movable);
diff --cc mm/memory_hotplug.c
index 9329da49a405,84ab3298cce9..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1173,7 -1187,8 +1173,12 @@@ static bool is_pageblock_removable_nolo
  	if (!zone_spans_pfn(zone, pfn))
  		return false;
  
++<<<<<<< HEAD
 +	return !has_unmovable_pages(zone, page, 0, MIGRATE_MOVABLE, true);
++=======
+ 	return !has_unmovable_pages(zone, page, 0, MIGRATE_MOVABLE,
+ 				    MEMORY_OFFLINE);
++>>>>>>> 756d25be457f (mm/page_isolation.c: convert SKIP_HWPOISON to MEMORY_OFFLINE)
  }
  
  /* Checks if this range of memory is likely to be hot-removable. */
@@@ -1499,9 -1514,9 +1505,14 @@@ static int __ref __offline_pages(unsign
  
  	/* set above range as isolated */
  	ret = start_isolate_page_range(start_pfn, end_pfn,
++<<<<<<< HEAD
 +				       MIGRATE_MOVABLE, true);
++=======
+ 				       MIGRATE_MOVABLE,
+ 				       MEMORY_OFFLINE | REPORT_FAILURE);
++>>>>>>> 756d25be457f (mm/page_isolation.c: convert SKIP_HWPOISON to MEMORY_OFFLINE)
  	if (ret < 0) {
 +		mem_hotplug_done();
  		reason = "failure to isolate range";
  		goto failed_removal;
  	}
diff --cc mm/page_alloc.c
index 501b0fde7415,c289b02aaa3b..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -7914,7 -8261,7 +7914,11 @@@ bool has_unmovable_pages(struct zone *z
  		 * The HWPoisoned page may be not in buddy system, and
  		 * page_count() is not 0.
  		 */
++<<<<<<< HEAD
 +		if (skip_hwpoisoned_pages && PageHWPoison(page))
++=======
+ 		if ((flags & MEMORY_OFFLINE) && PageHWPoison(page))
++>>>>>>> 756d25be457f (mm/page_isolation.c: convert SKIP_HWPOISON to MEMORY_OFFLINE)
  			continue;
  
  		if (__PageMovable(page))
diff --cc mm/page_isolation.c
index 4be9ddcdf5eb,04ee1663cdbe..000000000000
--- a/mm/page_isolation.c
+++ b/mm/page_isolation.c
@@@ -167,7 -164,14 +167,18 @@@ __first_valid_page(unsigned long pfn, u
   * be MIGRATE_ISOLATE.
   * @start_pfn:		The lower PFN of the range to be isolated.
   * @end_pfn:		The upper PFN of the range to be isolated.
++<<<<<<< HEAD
 + * @migratetype:	migrate type to set in error recovery.
++=======
+  *			start_pfn/end_pfn must be aligned to pageblock_order.
+  * @migratetype:	Migrate type to set in error recovery.
+  * @flags:		The following flags are allowed (they can be combined in
+  *			a bit mask)
+  *			MEMORY_OFFLINE - isolate to offline (!allocate) memory
+  *					 e.g., skip over PageHWPoison() pages
+  *			REPORT_FAILURE - report details about the failure to
+  *			isolate the range
++>>>>>>> 756d25be457f (mm/page_isolation.c: convert SKIP_HWPOISON to MEMORY_OFFLINE)
   *
   * Making page-allocation-type to be MIGRATE_ISOLATE means free pages in
   * the range will never be allocated. Any free pages and pages freed in the
* Unmerged path include/linux/page-isolation.h
* Unmerged path mm/memory_hotplug.c
* Unmerged path mm/page_alloc.c
* Unmerged path mm/page_isolation.c
