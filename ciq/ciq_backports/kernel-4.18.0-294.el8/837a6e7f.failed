fs: add generic UNRESVSP and ZERO_RANGE ioctl handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 837a6e7f5cdb5e411c6187729e12962c2705160d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/837a6e7f.failed

These use the same scheme as the pre-existing mapping of the XFS
RESVP ioctls to ->falloc, so just extend it and remove the XFS
implementation.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
[darrick: fix compile error on s390]
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 837a6e7f5cdb5e411c6187729e12962c2705160d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/compat_ioctl.c
#	fs/xfs/xfs_ioctl.c
diff --cc fs/compat_ioctl.c
index 003bdaded58d,62e530814cef..000000000000
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@@ -567,67 -436,74 +567,84 @@@ static int mt_ioctl_trans(struct file *
  #define HCIUARTSETFLAGS		_IOW('U', 203, int)
  #define HCIUARTGETFLAGS		_IOR('U', 204, int)
  
 -#define RTC_IRQP_READ32		_IOR('p', 0x0b, compat_ulong_t)
 -#define RTC_IRQP_SET32		_IOW('p', 0x0c, compat_ulong_t)
 -#define RTC_EPOCH_READ32	_IOR('p', 0x0d, compat_ulong_t)
 -#define RTC_EPOCH_SET32		_IOW('p', 0x0e, compat_ulong_t)
 -
 -static int rtc_ioctl(struct file *file,
 -		unsigned cmd, void __user *argp)
 -{
 -	unsigned long __user *valp = compat_alloc_user_space(sizeof(*valp));
 -	int ret;
 -
 -	if (valp == NULL)
 -		return -EFAULT;
 -	switch (cmd) {
 -	case RTC_IRQP_READ32:
 -	case RTC_EPOCH_READ32:
 -		ret = do_ioctl(file, (cmd == RTC_IRQP_READ32) ?
 -					RTC_IRQP_READ : RTC_EPOCH_READ,
 -					(unsigned long)valp);
 -		if (ret)
 -			return ret;
 -		return convert_in_user(valp, (unsigned int __user *)argp);
 -	case RTC_IRQP_SET32:
 -		return do_ioctl(file, RTC_IRQP_SET, (unsigned long)argp);
 -	case RTC_EPOCH_SET32:
 -		return do_ioctl(file, RTC_EPOCH_SET, (unsigned long)argp);
 -	}
 -
 -	return -ENOIOCTLCMD;
 -}
 -
 -/* on ia32 l_start is on a 32-bit boundary */
 -#if defined(CONFIG_IA64) || defined(CONFIG_X86_64)
 -struct space_resv_32 {
 -	__s16		l_type;
 -	__s16		l_whence;
 -	__s64		l_start	__attribute__((packed));
 -			/* len == 0 means until end of file */
 -	__s64		l_len __attribute__((packed));
 -	__s32		l_sysid;
 -	__u32		l_pid;
 -	__s32		l_pad[4];	/* reserve area */
 +struct serial_struct32 {
 +        compat_int_t    type;
 +        compat_int_t    line;
 +        compat_uint_t   port;
 +        compat_int_t    irq;
 +        compat_int_t    flags;
 +        compat_int_t    xmit_fifo_size;
 +        compat_int_t    custom_divisor;
 +        compat_int_t    baud_base;
 +        unsigned short  close_delay;
 +        char    io_type;
 +        char    reserved_char[1];
 +        compat_int_t    hub6;
 +        unsigned short  closing_wait; /* time to wait before closing */
 +        unsigned short  closing_wait2; /* no longer used... */
 +        compat_uint_t   iomem_base;
 +        unsigned short  iomem_reg_shift;
 +        unsigned int    port_high;
 +     /* compat_ulong_t  iomap_base FIXME */
 +        compat_int_t    reserved[1];
  };
  
++<<<<<<< HEAD
 +static int serial_struct_ioctl(struct file *file,
 +		unsigned cmd, struct serial_struct32 __user *ss32)
++=======
+ #define FS_IOC_RESVSP_32	_IOW ('X', 40, struct space_resv_32)
+ #define FS_IOC_UNRESVSP_32	_IOW ('X', 41, struct space_resv_32)
+ #define FS_IOC_RESVSP64_32	_IOW ('X', 42, struct space_resv_32)
+ #define FS_IOC_UNRESVSP64_32	_IOW ('X', 43, struct space_resv_32)
+ #define FS_IOC_ZERO_RANGE_32	_IOW ('X', 57, struct space_resv_32)
+ 
+ /* just account for different alignment */
+ static int compat_ioctl_preallocate(struct file *file, int mode,
+ 			struct space_resv_32    __user *p32)
++>>>>>>> 837a6e7f5cdb (fs: add generic UNRESVSP and ZERO_RANGE ioctl handlers)
  {
 -	struct space_resv	__user *p = compat_alloc_user_space(sizeof(*p));
 -
 -	if (copy_in_user(&p->l_type,	&p32->l_type,	sizeof(s16)) ||
 -	    copy_in_user(&p->l_whence,	&p32->l_whence, sizeof(s16)) ||
 -	    copy_in_user(&p->l_start,	&p32->l_start,	sizeof(s64)) ||
 -	    copy_in_user(&p->l_len,	&p32->l_len,	sizeof(s64)) ||
 -	    copy_in_user(&p->l_sysid,	&p32->l_sysid,	sizeof(s32)) ||
 -	    copy_in_user(&p->l_pid,	&p32->l_pid,	sizeof(u32)) ||
 -	    copy_in_user(&p->l_pad,	&p32->l_pad,	4*sizeof(u32)))
 +        typedef struct serial_struct32 SS32;
 +        int err;
 +	struct serial_struct __user *ss = compat_alloc_user_space(sizeof(*ss));
 +        __u32 udata;
 +	unsigned int base;
 +	unsigned char *iomem_base;
 +
 +	if (ss == NULL)
  		return -EFAULT;
++<<<<<<< HEAD
 +        if (cmd == TIOCSSERIAL) {
 +		if (copy_in_user(ss, ss32, offsetof(SS32, iomem_base)) ||
 +		    get_user(udata, &ss32->iomem_base))
 +			return -EFAULT;
 +		iomem_base = compat_ptr(udata);
 +		if (put_user(iomem_base, &ss->iomem_base) ||
 +		    convert_in_user(&ss32->iomem_reg_shift,
 +		      &ss->iomem_reg_shift) ||
 +		    convert_in_user(&ss32->port_high, &ss->port_high) ||
 +		    put_user(0UL, &ss->iomap_base))
 +			return -EFAULT;
 +        }
 +	err = do_ioctl(file, cmd, (unsigned long)ss);
 +        if (cmd == TIOCGSERIAL && err >= 0) {
 +		if (copy_in_user(ss32, ss, offsetof(SS32, iomem_base)) ||
 +		    get_user(iomem_base, &ss->iomem_base))
 +			return -EFAULT;
 +		base = (unsigned long)iomem_base  >> 32 ?
 +			0xffffffff : (unsigned)(unsigned long)iomem_base;
 +		if (put_user(base, &ss32->iomem_base) ||
 +		    convert_in_user(&ss->iomem_reg_shift,
 +		      &ss32->iomem_reg_shift) ||
 +		    convert_in_user(&ss->port_high, &ss32->port_high))
 +			return -EFAULT;
 +        }
 +        return err;
++=======
+ 
+ 	return ioctl_preallocate(file, mode, p);
++>>>>>>> 837a6e7f5cdb (fs: add generic UNRESVSP and ZERO_RANGE ioctl handlers)
  }
 -#endif
  
  /*
   * simple reversible transform to make our table more evenly
@@@ -1255,38 -1020,51 +1272,61 @@@ COMPAT_SYSCALL_DEFINE3(ioctl, unsigned 
  	case FIONBIO:
  	case FIOASYNC:
  	case FIOQSIZE:
 -		break;
 -
 -#if defined(CONFIG_IA64) || defined(CONFIG_X86_64)
 +	case FS_IOC_FIEMAP:
 +	case FIGETBSZ:
 +	case FICLONERANGE:
 +	case FIDEDUPERANGE:
 +		goto found_handler;
 +	/*
 +	 * The next group is the stuff handled inside file_ioctl().
 +	 * For regular files these never reach ->ioctl(); for
 +	 * devices, sockets, etc. they do and one (FIONREAD) is
 +	 * even accepted in some cases.  In all those cases
 +	 * argument has the same type, so we can handle these
 +	 * here, shunting them towards do_vfs_ioctl().
 +	 * ->compat_ioctl() will never see any of those.
 +	 */
 +	/* pointer argument, never actually handled by ->ioctl() */
 +	case FIBMAP:
 +		goto found_handler;
 +	/* handled by some ->ioctl(); always a pointer to int */
 +	case FIONREAD:
 +		goto found_handler;
 +	/* these two get messy on amd64 due to alignment differences */
 +#if defined(CONFIG_X86_64)
  	case FS_IOC_RESVSP_32:
  	case FS_IOC_RESVSP64_32:
- 		error = compat_ioctl_preallocate(f.file, compat_ptr(arg));
+ 		error = compat_ioctl_preallocate(f.file, 0, compat_ptr(arg));
+ 		goto out_fput;
+ 	case FS_IOC_UNRESVSP_32:
+ 	case FS_IOC_UNRESVSP64_32:
+ 		error = compat_ioctl_preallocate(f.file, FALLOC_FL_PUNCH_HOLE,
+ 				compat_ptr(arg));
+ 		goto out_fput;
+ 	case FS_IOC_ZERO_RANGE_32:
+ 		error = compat_ioctl_preallocate(f.file, FALLOC_FL_ZERO_RANGE,
+ 				compat_ptr(arg));
  		goto out_fput;
  #else
  	case FS_IOC_RESVSP:
  	case FS_IOC_RESVSP64:
++<<<<<<< HEAD
 +		goto found_handler;
++=======
+ 		error = ioctl_preallocate(f.file, 0, compat_ptr(arg));
+ 		goto out_fput;
+ 	case FS_IOC_UNRESVSP:
+ 	case FS_IOC_UNRESVSP64:
+ 		error = ioctl_preallocate(f.file, FALLOC_FL_PUNCH_HOLE,
+ 				compat_ptr(arg));
+ 		goto out_fput;
+ 	case FS_IOC_ZERO_RANGE:
+ 		error = ioctl_preallocate(f.file, FALLOC_FL_ZERO_RANGE,
+ 				compat_ptr(arg));
+ 		goto out_fput;
++>>>>>>> 837a6e7f5cdb (fs: add generic UNRESVSP and ZERO_RANGE ioctl handlers)
  #endif
  
 -	case FICLONE:
 -	case FICLONERANGE:
 -	case FIDEDUPERANGE:
 -	case FS_IOC_FIEMAP:
 -		goto do_ioctl;
 -
 -	case FIBMAP:
 -	case FIGETBSZ:
 -	case FIONREAD:
 -		if (S_ISREG(file_inode(f.file)->i_mode))
 -			break;
 -		/*FALL THROUGH*/
 -
  	default:
  		if (f.file->f_op->compat_ioctl) {
  			error = f.file->f_op->compat_ioctl(f.file, cmd, arg);
diff --cc fs/xfs/xfs_ioctl.c
index f9953b9481e3,e897d5363d01..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -665,62 -639,16 +641,73 @@@ xfs_ioc_space
  		goto out_unlock;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Must wait for all AIO to complete before we continue as AIO can
 +	 * change the file size on completion without holding any locks we
 +	 * currently hold. We must do this first because AIO can update both
 +	 * the on disk and in memory inode sizes, and the operations that follow
 +	 * require the in-memory size to be fully up-to-date.
 +	 */
 +	inode_dio_wait(inode);
 +
 +	/*
 +	 * Now that AIO and DIO has drained we can flush and (if necessary)
 +	 * invalidate the cached range over the first operation we are about to
 +	 * run. We include zero range here because it starts with a hole punch
 +	 * over the target range.
 +	 */
 +	switch (cmd) {
 +	case XFS_IOC_ZERO_RANGE:
 +	case XFS_IOC_UNRESVSP:
 +	case XFS_IOC_UNRESVSP64:
 +		error = xfs_flush_unmap_range(ip, bf->l_start, bf->l_len);
 +		if (error)
 +			goto out_unlock;
 +		break;
 +	}
 +
 +	switch (cmd) {
 +	case XFS_IOC_ZERO_RANGE:
 +		flags |= XFS_PREALLOC_SET;
 +		error = xfs_zero_file_space(ip, bf->l_start, bf->l_len);
 +		break;
 +	case XFS_IOC_UNRESVSP:
 +	case XFS_IOC_UNRESVSP64:
 +		error = xfs_free_file_space(ip, bf->l_start, bf->l_len);
 +		break;
 +	case XFS_IOC_ALLOCSP:
 +	case XFS_IOC_ALLOCSP64:
 +	case XFS_IOC_FREESP:
 +	case XFS_IOC_FREESP64:
 +		flags |= XFS_PREALLOC_CLEAR;
 +		if (bf->l_start > XFS_ISIZE(ip)) {
 +			error = xfs_alloc_file_space(ip, XFS_ISIZE(ip),
 +					bf->l_start - XFS_ISIZE(ip), 0);
 +			if (error)
 +				goto out_unlock;
 +		}
 +
 +		iattr.ia_valid = ATTR_SIZE;
 +		iattr.ia_size = bf->l_start;
 +
 +		error = xfs_vn_setattr_size(file_dentry(filp), &iattr);
 +		break;
 +	default:
 +		ASSERT(0);
 +		error = -EINVAL;
++=======
+ 	if (bf->l_start > XFS_ISIZE(ip)) {
+ 		error = xfs_alloc_file_space(ip, XFS_ISIZE(ip),
+ 				bf->l_start - XFS_ISIZE(ip), 0);
+ 		if (error)
+ 			goto out_unlock;
++>>>>>>> 837a6e7f5cdb (fs: add generic UNRESVSP and ZERO_RANGE ioctl handlers)
  	}
  
+ 	iattr.ia_valid = ATTR_SIZE;
+ 	iattr.ia_size = bf->l_start;
+ 	error = xfs_vn_setattr_size(file_dentry(filp), &iattr);
  	if (error)
  		goto out_unlock;
  
* Unmerged path fs/compat_ioctl.c
diff --git a/fs/ioctl.c b/fs/ioctl.c
index df792d63bced..48858f746467 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -470,7 +470,7 @@ EXPORT_SYMBOL(generic_block_fiemap);
  * Only the l_start, l_len and l_whence fields of the 'struct space_resv'
  * are used here, rest are ignored.
  */
-int ioctl_preallocate(struct file *filp, void __user *argp)
+int ioctl_preallocate(struct file *filp, int mode, void __user *argp)
 {
 	struct inode *inode = file_inode(filp);
 	struct space_resv sr;
@@ -491,7 +491,8 @@ int ioctl_preallocate(struct file *filp, void __user *argp)
 		return -EINVAL;
 	}
 
-	return vfs_fallocate(filp, FALLOC_FL_KEEP_SIZE, sr.l_start, sr.l_len);
+	return vfs_fallocate(filp, mode | FALLOC_FL_KEEP_SIZE, sr.l_start,
+			sr.l_len);
 }
 
 /* on ia32 l_start is on a 32-bit boundary */
@@ -536,7 +537,12 @@ static int file_ioctl(struct file *filp, unsigned int cmd,
 		return put_user(i_size_read(inode) - filp->f_pos, p);
 	case FS_IOC_RESVSP:
 	case FS_IOC_RESVSP64:
-		return ioctl_preallocate(filp, p);
+		return ioctl_preallocate(filp, 0, p);
+	case FS_IOC_UNRESVSP:
+	case FS_IOC_UNRESVSP64:
+		return ioctl_preallocate(filp, FALLOC_FL_PUNCH_HOLE, p);
+	case FS_IOC_ZERO_RANGE:
+		return ioctl_preallocate(filp, FALLOC_FL_ZERO_RANGE, p);
 	}
 
 	return vfs_ioctl(filp, cmd, arg);
* Unmerged path fs/xfs/xfs_ioctl.c
diff --git a/fs/xfs/xfs_ioctl.h b/fs/xfs/xfs_ioctl.h
index 654c0bb1bcf8..25ef178cbb74 100644
--- a/fs/xfs/xfs_ioctl.h
+++ b/fs/xfs/xfs_ioctl.h
@@ -9,7 +9,6 @@
 extern int
 xfs_ioc_space(
 	struct file		*filp,
-	unsigned int		cmd,
 	xfs_flock64_t		*bf);
 
 int
diff --git a/fs/xfs/xfs_ioctl32.c b/fs/xfs/xfs_ioctl32.c
index 45228b540ea1..9bd15f963665 100644
--- a/fs/xfs/xfs_ioctl32.c
+++ b/fs/xfs/xfs_ioctl32.c
@@ -559,16 +559,13 @@ xfs_file_compat_ioctl(
 	case XFS_IOC_ALLOCSP_32:
 	case XFS_IOC_FREESP_32:
 	case XFS_IOC_ALLOCSP64_32:
-	case XFS_IOC_FREESP64_32:
-	case XFS_IOC_RESVSP64_32:
-	case XFS_IOC_UNRESVSP64_32:
-	case XFS_IOC_ZERO_RANGE_32: {
+	case XFS_IOC_FREESP64_32: {
 		struct xfs_flock64	bf;
 
 		if (xfs_compat_flock64_copyin(&bf, arg))
 			return -EFAULT;
 		cmd = _NATIVE_IOC(cmd, struct xfs_flock64);
-		return xfs_ioc_space(filp, cmd, &bf);
+		return xfs_ioc_space(filp, &bf);
 	}
 	case XFS_IOC_FSGEOMETRY_V1_32:
 		return xfs_compat_ioc_fsgeometry_v1(mp, arg);
diff --git a/include/linux/falloc.h b/include/linux/falloc.h
index fc61fdb9d1e9..63c4f0d615bc 100644
--- a/include/linux/falloc.h
+++ b/include/linux/falloc.h
@@ -20,7 +20,10 @@ struct space_resv {
 };
 
 #define FS_IOC_RESVSP		_IOW('X', 40, struct space_resv)
+#define FS_IOC_UNRESVSP		_IOW('X', 41, struct space_resv)
 #define FS_IOC_RESVSP64		_IOW('X', 42, struct space_resv)
+#define FS_IOC_UNRESVSP64	_IOW('X', 43, struct space_resv)
+#define FS_IOC_ZERO_RANGE	_IOW('X', 57, struct space_resv)
 
 #define	FALLOC_FL_SUPPORTED_MASK	(FALLOC_FL_KEEP_SIZE |		\
 					 FALLOC_FL_PUNCH_HOLE |		\
diff --git a/include/linux/fs.h b/include/linux/fs.h
index feabaa0642d8..60d807abbb92 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2563,7 +2563,7 @@ extern int finish_no_open(struct file *file, struct dentry *dentry);
 
 /* fs/ioctl.c */
 
-extern int ioctl_preallocate(struct file *filp, void __user *argp);
+extern int ioctl_preallocate(struct file *filp, int mode, void __user *argp);
 
 /* fs/dcache.c */
 extern void __init vfs_caches_init_early(void);
