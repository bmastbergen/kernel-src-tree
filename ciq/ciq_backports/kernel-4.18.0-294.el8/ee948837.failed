[fix] get rid of checking for absent device name in vfs_get_tree()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [fs] get rid of checking for absent device name in vfs_get_tree() (Scott Mayhew) [1622041]
Rebuild_FUZZ: 95.24%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit ee948837d7fa89127373c139766aacf6b02a9225
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ee948837.failed

It has no business being there, it's checked by relevant ->get_tree()
as it is *and* it returns the wrong error for no reason whatsoever.

Fixes: f3a09c92018a "introduce fs_context methods"
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit ee948837d7fa89127373c139766aacf6b02a9225)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/super.c
diff --cc fs/super.c
index 72596c26684f,2739f57515f8..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -1238,29 -1454,39 +1238,49 @@@ struct dentry *mount_single(struct file
  }
  EXPORT_SYMBOL(mount_single);
  
 -/**
 - * vfs_get_tree - Get the mountable root
 - * @fc: The superblock configuration context.
 - *
 - * The filesystem is invoked to get or create a superblock which can then later
 - * be used for mounting.  The filesystem places a pointer to the root to be
 - * used for mounting in @fc->root.
 - */
 -int vfs_get_tree(struct fs_context *fc)
 +struct dentry *
 +mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
  {
 +	struct dentry *root;
  	struct super_block *sb;
 -	int error;
 +	int error = -ENOMEM;
 +	struct security_mnt_opts opts;
  
++<<<<<<< HEAD
 +	security_init_mnt_opts(&opts);
 +
 +	if (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {
 +		error = security_sb_eat_lsm_opts(data, &opts);
 +		if (error)
 +			return ERR_PTR(error);
 +	}
 +
 +	root = type->mount(type, flags, name, data);
 +	if (IS_ERR(root)) {
 +		error = PTR_ERR(root);
 +		goto out_free_secdata;
++=======
+ 	if (fc->root)
+ 		return -EBUSY;
+ 
+ 	/* Get the mountable root in fc->root, with a ref on the root and a ref
+ 	 * on the superblock.
+ 	 */
+ 	error = fc->ops->get_tree(fc);
+ 	if (error < 0)
+ 		return error;
+ 
+ 	if (!fc->root) {
+ 		pr_err("Filesystem %s get_tree() didn't set fc->root\n",
+ 		       fc->fs_type->name);
+ 		/* We don't know what the locking state of the superblock is -
+ 		 * if there is a superblock.
+ 		 */
+ 		BUG();
++>>>>>>> ee948837d7fa ([fix] get rid of checking for absent device name in vfs_get_tree())
  	}
 -
 -	sb = fc->root->d_sb;
 +	sb = root->d_sb;
 +	BUG_ON(!sb);
  	WARN_ON(!sb->s_bdi);
  
  	if (fc->subtype && !sb->s_subtype) {
* Unmerged path fs/super.c
