iommu: Introduce cache_invalidate API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yi L Liu <yi.l.liu@intel.com>
commit 4c7c171f85b261f91270d405b7c7390aa6ddfb60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4c7c171f.failed

In any virtualization use case, when the first translation stage
is "owned" by the guest OS, the host IOMMU driver has no knowledge
of caching structure updates unless the guest invalidation activities
are trapped by the virtualizer and passed down to the host.

Since the invalidation data can be obtained from user space and will be
written into physical IOMMU, we must allow security check at various
layers. Therefore, generic invalidation data format are proposed here,
model specific IOMMU drivers need to convert them into their own format.

	Signed-off-by: Yi L Liu <yi.l.liu@intel.com>
	Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Ashok Raj <ashok.raj@intel.com>
	Signed-off-by: Eric Auger <eric.auger@redhat.com>
	Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.com>
	Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
	Reviewed-by: Eric Auger <eric.auger@redhat.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 4c7c171f85b261f91270d405b7c7390aa6ddfb60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/iommu.h
diff --cc include/linux/iommu.h
index 8f7c43366b8f,9b22055e6f85..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -263,12 -244,8 +263,16 @@@ struct iommu_iotlb_gather 
   * @sva_unbind: Unbind process address space from device
   * @sva_get_pasid: Get PASID associated to a SVA handle
   * @page_response: handle page request response
++<<<<<<< HEAD
 + * @def_domain_type: device default domain type, return value:
 + *		- IOMMU_DOMAIN_IDENTITY: must use an identity domain
 + *		- IOMMU_DOMAIN_DMA: must use a dma domain
 + *		- 0: use the default setting
++=======
+  * @cache_invalidate: invalidate translation caches
++>>>>>>> 4c7c171f85b2 (iommu: Introduce cache_invalidate API)
   * @pgsize_bitmap: bitmap of all possible supported page sizes
 + * @owner: Driver module providing these ops
   */
  struct iommu_ops {
  	bool (*capable)(enum iommu_cap);
@@@ -340,14 -306,11 +344,19 @@@
  	int (*page_response)(struct device *dev,
  			     struct iommu_fault_event *evt,
  			     struct iommu_page_response *msg);
++<<<<<<< HEAD
 +	int (*def_domain_type)(struct device *dev);
 +	struct iommu_device *(*probe_device)(struct device *dev);
 +	void (*release_device)(struct device *dev);
 +	void (*probe_finalize)(struct device *dev);
 +	) /* RH_KABI_BROKEN_INSERT_BLOCK */
++=======
+ 	int (*cache_invalidate)(struct iommu_domain *domain, struct device *dev,
+ 				struct iommu_cache_invalidate_info *inv_info);
++>>>>>>> 4c7c171f85b2 (iommu: Introduce cache_invalidate API)
  
  	unsigned long pgsize_bitmap;
 +	RH_KABI_BROKEN_INSERT(struct module *owner)
  };
  
  /**
@@@ -1091,10 -1011,14 +1103,21 @@@ static inline int iommu_sva_get_pasid(s
  	return IOMMU_PASID_INVALID;
  }
  
++<<<<<<< HEAD
 +static inline struct iommu_fwspec *dev_iommu_fwspec_get(struct device *dev)
 +{
 +	return NULL;
 +}
++=======
+ static inline int
+ iommu_cache_invalidate(struct iommu_domain *domain,
+ 		       struct device *dev,
+ 		       struct iommu_cache_invalidate_info *inv_info)
+ {
+ 	return -ENODEV;
+ }
+ 
++>>>>>>> 4c7c171f85b2 (iommu: Introduce cache_invalidate API)
  #endif /* CONFIG_IOMMU_API */
  
  #ifdef CONFIG_IOMMU_DEBUGFS
diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
index fc3ac9f31346..5b9fbe57c02d 100644
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@ -1949,6 +1949,16 @@ int iommu_attach_device(struct iommu_domain *domain, struct device *dev)
 }
 EXPORT_SYMBOL_GPL(iommu_attach_device);
 
+int iommu_cache_invalidate(struct iommu_domain *domain, struct device *dev,
+			   struct iommu_cache_invalidate_info *inv_info)
+{
+	if (unlikely(!domain->ops->cache_invalidate))
+		return -ENODEV;
+
+	return domain->ops->cache_invalidate(domain, dev, inv_info);
+}
+EXPORT_SYMBOL_GPL(iommu_cache_invalidate);
+
 static void __iommu_detach_device(struct iommu_domain *domain,
 				  struct device *dev)
 {
* Unmerged path include/linux/iommu.h
diff --git a/include/uapi/linux/iommu.h b/include/uapi/linux/iommu.h
index fc00c5d4741b..f3e96214df8e 100644
--- a/include/uapi/linux/iommu.h
+++ b/include/uapi/linux/iommu.h
@@ -152,4 +152,114 @@ struct iommu_page_response {
 	__u32	code;
 };
 
+/* defines the granularity of the invalidation */
+enum iommu_inv_granularity {
+	IOMMU_INV_GRANU_DOMAIN,	/* domain-selective invalidation */
+	IOMMU_INV_GRANU_PASID,	/* PASID-selective invalidation */
+	IOMMU_INV_GRANU_ADDR,	/* page-selective invalidation */
+	IOMMU_INV_GRANU_NR,	/* number of invalidation granularities */
+};
+
+/**
+ * struct iommu_inv_addr_info - Address Selective Invalidation Structure
+ *
+ * @flags: indicates the granularity of the address-selective invalidation
+ * - If the PASID bit is set, the @pasid field is populated and the invalidation
+ *   relates to cache entries tagged with this PASID and matching the address
+ *   range.
+ * - If ARCHID bit is set, @archid is populated and the invalidation relates
+ *   to cache entries tagged with this architecture specific ID and matching
+ *   the address range.
+ * - Both PASID and ARCHID can be set as they may tag different caches.
+ * - If neither PASID or ARCHID is set, global addr invalidation applies.
+ * - The LEAF flag indicates whether only the leaf PTE caching needs to be
+ *   invalidated and other paging structure caches can be preserved.
+ * @pasid: process address space ID
+ * @archid: architecture-specific ID
+ * @addr: first stage/level input address
+ * @granule_size: page/block size of the mapping in bytes
+ * @nb_granules: number of contiguous granules to be invalidated
+ */
+struct iommu_inv_addr_info {
+#define IOMMU_INV_ADDR_FLAGS_PASID	(1 << 0)
+#define IOMMU_INV_ADDR_FLAGS_ARCHID	(1 << 1)
+#define IOMMU_INV_ADDR_FLAGS_LEAF	(1 << 2)
+	__u32	flags;
+	__u32	archid;
+	__u64	pasid;
+	__u64	addr;
+	__u64	granule_size;
+	__u64	nb_granules;
+};
+
+/**
+ * struct iommu_inv_pasid_info - PASID Selective Invalidation Structure
+ *
+ * @flags: indicates the granularity of the PASID-selective invalidation
+ * - If the PASID bit is set, the @pasid field is populated and the invalidation
+ *   relates to cache entries tagged with this PASID and matching the address
+ *   range.
+ * - If the ARCHID bit is set, the @archid is populated and the invalidation
+ *   relates to cache entries tagged with this architecture specific ID and
+ *   matching the address range.
+ * - Both PASID and ARCHID can be set as they may tag different caches.
+ * - At least one of PASID or ARCHID must be set.
+ * @pasid: process address space ID
+ * @archid: architecture-specific ID
+ */
+struct iommu_inv_pasid_info {
+#define IOMMU_INV_PASID_FLAGS_PASID	(1 << 0)
+#define IOMMU_INV_PASID_FLAGS_ARCHID	(1 << 1)
+	__u32	flags;
+	__u32	archid;
+	__u64	pasid;
+};
+
+/**
+ * struct iommu_cache_invalidate_info - First level/stage invalidation
+ *     information
+ * @version: API version of this structure
+ * @cache: bitfield that allows to select which caches to invalidate
+ * @granularity: defines the lowest granularity used for the invalidation:
+ *     domain > PASID > addr
+ * @padding: reserved for future use (should be zero)
+ * @pasid_info: invalidation data when @granularity is %IOMMU_INV_GRANU_PASID
+ * @addr_info: invalidation data when @granularity is %IOMMU_INV_GRANU_ADDR
+ *
+ * Not all the combinations of cache/granularity are valid:
+ *
+ * +--------------+---------------+---------------+---------------+
+ * | type /       |   DEV_IOTLB   |     IOTLB     |      PASID    |
+ * | granularity  |               |               |      cache    |
+ * +==============+===============+===============+===============+
+ * | DOMAIN       |       N/A     |       Y       |       Y       |
+ * +--------------+---------------+---------------+---------------+
+ * | PASID        |       Y       |       Y       |       Y       |
+ * +--------------+---------------+---------------+---------------+
+ * | ADDR         |       Y       |       Y       |       N/A     |
+ * +--------------+---------------+---------------+---------------+
+ *
+ * Invalidations by %IOMMU_INV_GRANU_DOMAIN don't take any argument other than
+ * @version and @cache.
+ *
+ * If multiple cache types are invalidated simultaneously, they all
+ * must support the used granularity.
+ */
+struct iommu_cache_invalidate_info {
+#define IOMMU_CACHE_INVALIDATE_INFO_VERSION_1 1
+	__u32	version;
+/* IOMMU paging structure cache */
+#define IOMMU_CACHE_INV_TYPE_IOTLB	(1 << 0) /* IOMMU IOTLB */
+#define IOMMU_CACHE_INV_TYPE_DEV_IOTLB	(1 << 1) /* Device IOTLB */
+#define IOMMU_CACHE_INV_TYPE_PASID	(1 << 2) /* PASID cache */
+#define IOMMU_CACHE_INV_TYPE_NR		(3)
+	__u8	cache;
+	__u8	granularity;
+	__u8	padding[2];
+	union {
+		struct iommu_inv_pasid_info pasid_info;
+		struct iommu_inv_addr_info addr_info;
+	};
+};
+
 #endif /* _UAPI_IOMMU_H */
