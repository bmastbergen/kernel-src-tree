net: switch copy_bpf_fprog_from_user to sockptr_t

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] switch copy_bpf_fprog_from_user to sockptr_t (Jiri Benc) [1882709]
Rebuild_FUZZ: 94.62%
commit-author Christoph Hellwig <hch@lst.de>
commit b1ea9ff6aff2deae84eccaf0a07cd14912669680
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b1ea9ff6.failed

Pass a sockptr_t to prepare for set_fs-less handling of the kernel
pointer from bpf-cgroup.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b1ea9ff6aff2deae84eccaf0a07cd14912669680)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/filter.h
diff --cc include/linux/filter.h
index 519f0dbc6c88,d07a6e973a7d..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -21,6 -20,8 +21,11 @@@
  #include <linux/kallsyms.h>
  #include <linux/if_vlan.h>
  #include <linux/vmalloc.h>
++<<<<<<< HEAD
++=======
+ #include <linux/sockptr.h>
+ #include <crypto/sha.h>
++>>>>>>> b1ea9ff6aff2 (net: switch copy_bpf_fprog_from_user to sockptr_t)
  
  #include <net/sch_generic.h>
  
@@@ -1285,8 -1277,116 +1290,8 @@@ struct bpf_sockopt_kern 
  	s32		retval;
  };
  
- int copy_bpf_fprog_from_user(struct sock_fprog *dst, void __user *src, int len);
+ int copy_bpf_fprog_from_user(struct sock_fprog *dst, sockptr_t src, int len);
  
 -struct bpf_sk_lookup_kern {
 -	u16		family;
 -	u16		protocol;
 -	struct {
 -		__be32 saddr;
 -		__be32 daddr;
 -	} v4;
 -	struct {
 -		const struct in6_addr *saddr;
 -		const struct in6_addr *daddr;
 -	} v6;
 -	__be16		sport;
 -	u16		dport;
 -	struct sock	*selected_sk;
 -	bool		no_reuseport;
 -};
 -
 -extern struct static_key_false bpf_sk_lookup_enabled;
 -
 -/* Runners for BPF_SK_LOOKUP programs to invoke on socket lookup.
 - *
 - * Allowed return values for a BPF SK_LOOKUP program are SK_PASS and
 - * SK_DROP. Their meaning is as follows:
 - *
 - *  SK_PASS && ctx.selected_sk != NULL: use selected_sk as lookup result
 - *  SK_PASS && ctx.selected_sk == NULL: continue to htable-based socket lookup
 - *  SK_DROP                           : terminate lookup with -ECONNREFUSED
 - *
 - * This macro aggregates return values and selected sockets from
 - * multiple BPF programs according to following rules in order:
 - *
 - *  1. If any program returned SK_PASS and a non-NULL ctx.selected_sk,
 - *     macro result is SK_PASS and last ctx.selected_sk is used.
 - *  2. If any program returned SK_DROP return value,
 - *     macro result is SK_DROP.
 - *  3. Otherwise result is SK_PASS and ctx.selected_sk is NULL.
 - *
 - * Caller must ensure that the prog array is non-NULL, and that the
 - * array as well as the programs it contains remain valid.
 - */
 -#define BPF_PROG_SK_LOOKUP_RUN_ARRAY(array, ctx, func)			\
 -	({								\
 -		struct bpf_sk_lookup_kern *_ctx = &(ctx);		\
 -		struct bpf_prog_array_item *_item;			\
 -		struct sock *_selected_sk = NULL;			\
 -		bool _no_reuseport = false;				\
 -		struct bpf_prog *_prog;					\
 -		bool _all_pass = true;					\
 -		u32 _ret;						\
 -									\
 -		migrate_disable();					\
 -		_item = &(array)->items[0];				\
 -		while ((_prog = READ_ONCE(_item->prog))) {		\
 -			/* restore most recent selection */		\
 -			_ctx->selected_sk = _selected_sk;		\
 -			_ctx->no_reuseport = _no_reuseport;		\
 -									\
 -			_ret = func(_prog, _ctx);			\
 -			if (_ret == SK_PASS && _ctx->selected_sk) {	\
 -				/* remember last non-NULL socket */	\
 -				_selected_sk = _ctx->selected_sk;	\
 -				_no_reuseport = _ctx->no_reuseport;	\
 -			} else if (_ret == SK_DROP && _all_pass) {	\
 -				_all_pass = false;			\
 -			}						\
 -			_item++;					\
 -		}							\
 -		_ctx->selected_sk = _selected_sk;			\
 -		_ctx->no_reuseport = _no_reuseport;			\
 -		migrate_enable();					\
 -		_all_pass || _selected_sk ? SK_PASS : SK_DROP;		\
 -	 })
 -
 -static inline bool bpf_sk_lookup_run_v4(struct net *net, int protocol,
 -					const __be32 saddr, const __be16 sport,
 -					const __be32 daddr, const u16 dport,
 -					struct sock **psk)
 -{
 -	struct bpf_prog_array *run_array;
 -	struct sock *selected_sk = NULL;
 -	bool no_reuseport = false;
 -
 -	rcu_read_lock();
 -	run_array = rcu_dereference(net->bpf.run_array[NETNS_BPF_SK_LOOKUP]);
 -	if (run_array) {
 -		struct bpf_sk_lookup_kern ctx = {
 -			.family		= AF_INET,
 -			.protocol	= protocol,
 -			.v4.saddr	= saddr,
 -			.v4.daddr	= daddr,
 -			.sport		= sport,
 -			.dport		= dport,
 -		};
 -		u32 act;
 -
 -		act = BPF_PROG_SK_LOOKUP_RUN_ARRAY(run_array, ctx, BPF_PROG_RUN);
 -		if (act == SK_PASS) {
 -			selected_sk = ctx.selected_sk;
 -			no_reuseport = ctx.no_reuseport;
 -		} else {
 -			selected_sk = ERR_PTR(-ECONNREFUSED);
 -		}
 -	}
 -	rcu_read_unlock();
 -	*psk = selected_sk;
 -	return no_reuseport;
 -}
 -
  #if IS_ENABLED(CONFIG_IPV6)
  static inline bool bpf_sk_lookup_run_v6(struct net *net, int protocol,
  					const struct in6_addr *saddr,
* Unmerged path include/linux/filter.h
diff --git a/net/core/filter.c b/net/core/filter.c
index 7f019106de88..1f69085cf0fd 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -79,14 +79,14 @@
 
 #include <linux/rh_features.h>
 
-int copy_bpf_fprog_from_user(struct sock_fprog *dst, void __user *src, int len)
+int copy_bpf_fprog_from_user(struct sock_fprog *dst, sockptr_t src, int len)
 {
 	if (in_compat_syscall()) {
 		struct compat_sock_fprog f32;
 
 		if (len != sizeof(f32))
 			return -EINVAL;
-		if (copy_from_user(&f32, src, sizeof(f32)))
+		if (copy_from_sockptr(&f32, src, sizeof(f32)))
 			return -EFAULT;
 		memset(dst, 0, sizeof(*dst));
 		dst->len = f32.len;
@@ -94,7 +94,7 @@ int copy_bpf_fprog_from_user(struct sock_fprog *dst, void __user *src, int len)
 	} else {
 		if (len != sizeof(*dst))
 			return -EINVAL;
-		if (copy_from_user(dst, src, sizeof(*dst)))
+		if (copy_from_sockptr(dst, src, sizeof(*dst)))
 			return -EFAULT;
 	}
 
diff --git a/net/core/sock.c b/net/core/sock.c
index 9df323a0a5d1..ceaf803bdb1c 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -1004,7 +1004,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 	case SO_ATTACH_FILTER: {
 		struct sock_fprog fprog;
 
-		ret = copy_bpf_fprog_from_user(&fprog, optval, optlen);
+		ret = copy_bpf_fprog_from_user(&fprog, USER_SOCKPTR(optval),
+					       optlen);
 		if (!ret)
 			ret = sk_attach_filter(&fprog, sk);
 		break;
@@ -1025,7 +1026,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 	case SO_ATTACH_REUSEPORT_CBPF: {
 		struct sock_fprog fprog;
 
-		ret = copy_bpf_fprog_from_user(&fprog, optval, optlen);
+		ret = copy_bpf_fprog_from_user(&fprog, USER_SOCKPTR(optval),
+					       optlen);
 		if (!ret)
 			ret = sk_reuseport_attach_filter(&fprog, sk);
 		break;
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index cc883d1d508a..69c3916c8efc 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -1538,7 +1538,7 @@ static void __fanout_set_data_bpf(struct packet_fanout *f, struct bpf_prog *new)
 	}
 }
 
-static int fanout_set_data_cbpf(struct packet_sock *po, char __user *data,
+static int fanout_set_data_cbpf(struct packet_sock *po, sockptr_t data,
 				unsigned int len)
 {
 	struct bpf_prog *new;
@@ -1586,7 +1586,7 @@ static int fanout_set_data(struct packet_sock *po, char __user *data,
 {
 	switch (po->fanout->type) {
 	case PACKET_FANOUT_CBPF:
-		return fanout_set_data_cbpf(po, data, len);
+		return fanout_set_data_cbpf(po, USER_SOCKPTR(data), len);
 	case PACKET_FANOUT_EBPF:
 		return fanout_set_data_ebpf(po, data, len);
 	default:
