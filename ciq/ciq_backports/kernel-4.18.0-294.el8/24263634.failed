kvm: svm: Always set svm->last_cpu on VMRUN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jim Mattson <jmattson@google.com>
commit 242636343c246e338b8ea317e32dbf4ed47edc65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/24263634.failed

Previously, this field was only set when using SEV. Set it for all
vCPU configurations, so that it can be communicated to userspace for
diagnosing potential hardware errors.

	Signed-off-by: Jim Mattson <jmattson@google.com>
	Reviewed-by: Oliver Upton <oupton@google.com>
	Reviewed-by: Peter Shier <pshier@google.com>
Message-Id: <20200603235623.245638-3-jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 242636343c246e338b8ea317e32dbf4ed47edc65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/kvm/svm/svm.c
index 733f139091ec,24b7f321874f..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -3399,14 -3396,7 +3399,18 @@@ static fastpath_t svm_vcpu_run(struct k
  	 */
  	x86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);
  
++<<<<<<< HEAD
 +	/*
 +	 * Tell context tracking that this CPU is about to enter guest
 +	 * mode. This has to be after x86_spec_ctrl_set_guest() because
 +	 * that can take locks (lockdep needs RCU) and calls into world and
 +	 * some more.
 +	 */
 +	guest_enter_irqoff();
 +
++=======
+ 	svm->last_cpu = vcpu->cpu;
++>>>>>>> 242636343c24 (kvm: svm: Always set svm->last_cpu on VMRUN)
  	__svm_vcpu_run(svm->vmcb_pa, (unsigned long *)&svm->vcpu.arch.regs);
  
  #ifdef CONFIG_X86_64
diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.c
index 9693db1af57c..e7a931355214 100644
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@ -1188,7 +1188,6 @@ void pre_sev_run(struct vcpu_svm *svm, int cpu)
 	    svm->last_cpu == cpu)
 		return;
 
-	svm->last_cpu = cpu;
 	sd->sev_vmcbs[asid] = svm->vmcb;
 	svm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;
 	mark_dirty(svm->vmcb, VMCB_ASID);
* Unmerged path arch/x86/kvm/svm/svm.c
