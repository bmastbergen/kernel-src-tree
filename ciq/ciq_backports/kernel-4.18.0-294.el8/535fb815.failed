mptcp: token: move retry to caller

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Florian Westphal <fw@strlen.de>
commit 535fb8152f313dd5d30ef84ce55b01ad9cbae3cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/535fb815.failed

Once syncookie support is added, no state will be stored anymore when the
syn/ack is generated in syncookie mode.

When the ACK comes back, the generated key will be taken from the TCP ACK,
the token is re-generated and inserted into the token tree.

This means we can't retry with a new key when the token is already taken
in the syncookie case.

Therefore, move the retry logic to the caller to prepare for syncookie
support in mptcp.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 535fb8152f313dd5d30ef84ce55b01ad9cbae3cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/token.c
diff --cc net/mptcp/token.c
index 9e1312968673,f82410c54653..000000000000
--- a/net/mptcp/token.c
+++ b/net/mptcp/token.c
@@@ -64,30 -109,28 +64,49 @@@ static void mptcp_crypto_key_gen_sha(u6
  int mptcp_token_new_request(struct request_sock *req)
  {
  	struct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);
++<<<<<<< HEAD
 +	int err;
 +
 +	while (1) {
 +		u32 token;
 +
 +		mptcp_crypto_key_gen_sha(&subflow_req->local_key,
 +					 &subflow_req->token,
 +					 &subflow_req->idsn);
 +		pr_debug("req=%p local_key=%llu, token=%u, idsn=%llu\n",
 +			 req, subflow_req->local_key, subflow_req->token,
 +			 subflow_req->idsn);
 +
 +		token = subflow_req->token;
 +		spin_lock_bh(&token_tree_lock);
 +		if (!radix_tree_lookup(&token_req_tree, token) &&
 +		    !radix_tree_lookup(&token_tree, token))
 +			break;
 +		spin_unlock_bh(&token_tree_lock);
++=======
+ 	struct token_bucket *bucket;
+ 	u32 token;
+ 
+ 	mptcp_crypto_key_sha(subflow_req->local_key,
+ 			     &subflow_req->token,
+ 			     &subflow_req->idsn);
+ 	pr_debug("req=%p local_key=%llu, token=%u, idsn=%llu\n",
+ 		 req, subflow_req->local_key, subflow_req->token,
+ 		 subflow_req->idsn);
+ 
+ 	token = subflow_req->token;
+ 	bucket = token_bucket(token);
+ 	spin_lock_bh(&bucket->lock);
+ 	if (__token_bucket_busy(bucket, token)) {
+ 		spin_unlock_bh(&bucket->lock);
+ 		return -EBUSY;
++>>>>>>> 535fb8152f31 (mptcp: token: move retry to caller)
  	}
  
 -	hlist_nulls_add_head_rcu(&subflow_req->token_node, &bucket->req_chain);
 -	bucket->chain_len++;
 -	spin_unlock_bh(&bucket->lock);
 -	return 0;
 +	err = radix_tree_insert(&token_req_tree,
 +				subflow_req->token, &token_used);
 +	spin_unlock_bh(&token_tree_lock);
 +	return err;
  }
  
  /**
diff --git a/net/mptcp/subflow.c b/net/mptcp/subflow.c
index ee7b035ac01e..f4015b236c50 100644
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@ -160,11 +160,18 @@ static void subflow_init_req(struct request_sock *req,
 	}
 
 	if (mp_opt.mp_capable && listener->request_mptcp) {
-		int err;
+		int err, retries = 4;
+
+again:
+		do {
+			get_random_bytes(&subflow_req->local_key, sizeof(subflow_req->local_key));
+		} while (subflow_req->local_key == 0);
 
 		err = mptcp_token_new_request(req);
 		if (err == 0)
 			subflow_req->mp_capable = 1;
+		else if (retries-- > 0)
+			goto again;
 
 		subflow_req->ssn_offset = TCP_SKB_CB(skb)->seq;
 	} else if (mp_opt.mp_join && listener->request_mptcp) {
* Unmerged path net/mptcp/token.c
