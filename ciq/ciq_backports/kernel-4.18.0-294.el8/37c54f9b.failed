kernel: set USER_DS in kthread_use_mm

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 37c54f9bd48663f7657a9178fe08c47e4f5b537b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/37c54f9b.failed

Some architectures like arm64 and s390 require USER_DS to be set for
kernel threads to access user address space, which is the whole purpose of
kthread_use_mm, but other like x86 don't.  That has lead to a huge mess
where some callers are fixed up once they are tested on said
architectures, while others linger around and yet other like io_uring try
to do "clever" optimizations for what usually is just a trivial asignment
to a member in the thread_struct for most architectures.

Make kthread_use_mm set USER_DS, and kthread_unuse_mm restore to the
previous value instead.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Jens Axboe <axboe@kernel.dk>
	Reviewed-by: Jens Axboe <axboe@kernel.dk>
	Acked-by: Michael S. Tsirkin <mst@redhat.com>
	Cc: Alex Deucher <alexander.deucher@amd.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Felipe Balbi <balbi@kernel.org>
	Cc: Felix Kuehling <Felix.Kuehling@amd.com>
	Cc: Jason Wang <jasowang@redhat.com>
	Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
	Cc: Zhi Wang <zhi.a.wang@intel.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Link: http://lkml.kernel.org/r/20200404094101.672954-7-hch@lst.de
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 37c54f9bd48663f7657a9178fe08c47e4f5b537b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/gadget/function/f_fs.c
#	drivers/vhost/vhost.c
#	fs/io-wq.c
#	kernel/kthread.c
diff --cc drivers/usb/gadget/function/f_fs.c
index ea21ee799739,490d353d5fde..000000000000
--- a/drivers/usb/gadget/function/f_fs.c
+++ b/drivers/usb/gadget/function/f_fs.c
@@@ -823,13 -824,9 +823,19 @@@ static void ffs_user_copy_worker(struc
  	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
  
  	if (io_data->read && ret > 0) {
++<<<<<<< HEAD
 +		mm_segment_t oldfs = get_fs();
 +
 +		set_fs(USER_DS);
 +		use_mm(io_data->mm);
 +		ret = ffs_copy_to_iter(io_data->buf, ret, &io_data->data);
 +		unuse_mm(io_data->mm);
 +		set_fs(oldfs);
++=======
+ 		kthread_use_mm(io_data->mm);
+ 		ret = ffs_copy_to_iter(io_data->buf, ret, &io_data->data);
+ 		kthread_unuse_mm(io_data->mm);
++>>>>>>> 37c54f9bd486 (kernel: set USER_DS in kthread_use_mm)
  	}
  
  	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
diff --cc drivers/vhost/vhost.c
index 077eb9dd746b,421710c53f6a..000000000000
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@@ -330,10 -329,8 +330,13 @@@ static int vhost_worker(void *data
  	struct vhost_dev *dev = data;
  	struct vhost_work *work, *work_next;
  	struct llist_node *node;
- 	mm_segment_t oldfs = get_fs();
  
++<<<<<<< HEAD
 +	set_fs(USER_DS);
 +	use_mm(dev->mm);
++=======
+ 	kthread_use_mm(dev->mm);
++>>>>>>> 37c54f9bd486 (kernel: set USER_DS in kthread_use_mm)
  
  	for (;;) {
  		/* mb paired w/ kthread_stop */
@@@ -359,8 -358,7 +362,12 @@@
  				schedule();
  		}
  	}
++<<<<<<< HEAD
 +	unuse_mm(dev->mm);
 +	set_fs(oldfs);
++=======
+ 	kthread_unuse_mm(dev->mm);
++>>>>>>> 37c54f9bd486 (kernel: set USER_DS in kthread_use_mm)
  	return 0;
  }
  
diff --cc fs/io-wq.c
index d346d738a696,a5e90ac39e4d..000000000000
--- a/fs/io-wq.c
+++ b/fs/io-wq.c
@@@ -170,8 -169,7 +170,12 @@@ static bool __io_worker_unuse(struct io
  			dropped_lock = true;
  		}
  		__set_current_state(TASK_RUNNING);
++<<<<<<< HEAD
 +		set_fs(KERNEL_DS);
 +		unuse_mm(worker->mm);
++=======
+ 		kthread_unuse_mm(worker->mm);
++>>>>>>> 37c54f9bd486 (kernel: set USER_DS in kthread_use_mm)
  		mmput(worker->mm);
  		worker->mm = NULL;
  	}
@@@ -422,14 -420,11 +426,17 @@@ static void io_wq_switch_mm(struct io_w
  		mmput(worker->mm);
  		worker->mm = NULL;
  	}
- 	if (!work->mm) {
- 		set_fs(KERNEL_DS);
+ 	if (!work->mm)
  		return;
- 	}
+ 
  	if (mmget_not_zero(work->mm)) {
++<<<<<<< HEAD
 +		use_mm(work->mm);
 +		if (!worker->mm)
 +			set_fs(USER_DS);
++=======
+ 		kthread_use_mm(work->mm);
++>>>>>>> 37c54f9bd486 (kernel: set USER_DS in kthread_use_mm)
  		worker->mm = work->mm;
  		/* hang on to this mm */
  		work->mm = NULL;
diff --cc kernel/kthread.c
index c8e88a6a94fc,86357cd38eb2..000000000000
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@@ -49,8 -51,8 +49,9 @@@ struct kthread_create_inf
  struct kthread {
  	unsigned long flags;
  	unsigned int cpu;
 +	int (*threadfn)(void *);
  	void *data;
+ 	mm_segment_t oldfs;
  	struct completion parked;
  	struct completion exited;
  #ifdef CONFIG_BLK_CGROUP
@@@ -1263,21 -1236,25 +1264,32 @@@ void use_mm(struct mm_struct *mm
  
  	if (active_mm != mm)
  		mmdrop(active_mm);
+ 
+ 	to_kthread(tsk)->oldfs = get_fs();
+ 	set_fs(USER_DS);
  }
 -EXPORT_SYMBOL_GPL(kthread_use_mm);
 +EXPORT_SYMBOL_GPL(use_mm);
  
 -/**
 - * kthread_unuse_mm - reverse the effect of kthread_use_mm()
 - * @mm: address space to operate on
 +/*
 + * unuse_mm
 + *	Reverses the effect of use_mm, i.e. releases the
 + *	specified mm context which was earlier taken on
 + *	by the calling kernel thread
 + *	(Note: this routine is intended to be called only
 + *	from a kernel thread context)
   */
 -void kthread_unuse_mm(struct mm_struct *mm)
 +void unuse_mm(struct mm_struct *mm)
  {
  	struct task_struct *tsk = current;
  
++<<<<<<< HEAD
++=======
+ 	WARN_ON_ONCE(!(tsk->flags & PF_KTHREAD));
+ 	WARN_ON_ONCE(!tsk->mm);
+ 
+ 	set_fs(to_kthread(tsk)->oldfs);
+ 
++>>>>>>> 37c54f9bd486 (kernel: set USER_DS in kthread_use_mm)
  	task_lock(tsk);
  	sync_mm_rss(mm);
  	tsk->mm = NULL;
* Unmerged path drivers/usb/gadget/function/f_fs.c
* Unmerged path drivers/vhost/vhost.c
* Unmerged path fs/io-wq.c
diff --git a/fs/io_uring.c b/fs/io_uring.c
index f8c8b0e1de21..c3b5f4e10a29 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -6063,15 +6063,12 @@ static int io_sq_thread(void *data)
 {
 	struct io_ring_ctx *ctx = data;
 	const struct cred *old_cred;
-	mm_segment_t old_fs;
 	DEFINE_WAIT(wait);
 	unsigned long timeout;
 	int ret = 0;
 
 	complete(&ctx->completions[1]);
 
-	old_fs = get_fs();
-	set_fs(USER_DS);
 	old_cred = override_creds(ctx->creds);
 
 	timeout = jiffies + ctx->sq_thread_idle;
@@ -6175,7 +6172,6 @@ static int io_sq_thread(void *data)
 	if (current->task_works)
 		task_work_run();
 
-	set_fs(old_fs);
 	io_sq_thread_drop_mm(ctx);
 	revert_creds(old_cred);
 
* Unmerged path kernel/kthread.c
