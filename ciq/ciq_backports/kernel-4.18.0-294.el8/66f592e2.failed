proc: Add fs_context support to procfs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 66f592e2ece0389c018d74d1bbb2d0b9738cfe48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/66f592e2.failed

Add fs_context support to procfs.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Alexey Dobriyan <adobriyan@gmail.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 66f592e2ece0389c018d74d1bbb2d0b9738cfe48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/root.c
diff --cc fs/proc/root.c
index f4b1a9d2eca6,6927b29ece76..000000000000
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@@ -19,67 -19,132 +19,143 @@@
  #include <linux/module.h>
  #include <linux/bitops.h>
  #include <linux/user_namespace.h>
+ #include <linux/fs_context.h>
  #include <linux/mount.h>
  #include <linux/pid_namespace.h>
- #include <linux/parser.h>
+ #include <linux/fs_parser.h>
  #include <linux/cred.h>
++<<<<<<< HEAD
++=======
+ #include <linux/magic.h>
+ #include <linux/slab.h>
++>>>>>>> 66f592e2ece0 (proc: Add fs_context support to procfs)
  
  #include "internal.h"
  
- enum {
- 	Opt_gid, Opt_hidepid, Opt_err,
+ struct proc_fs_context {
+ 	struct pid_namespace	*pid_ns;
+ 	unsigned int		mask;
+ 	int			hidepid;
+ 	int			gid;
  };
  
- static const match_table_t tokens = {
- 	{Opt_hidepid, "hidepid=%u"},
- 	{Opt_gid, "gid=%u"},
- 	{Opt_err, NULL},
+ enum proc_param {
+ 	Opt_gid,
+ 	Opt_hidepid,
  };
  
++<<<<<<< HEAD
 +int proc_parse_options(char *options, struct pid_namespace *pid)
++=======
+ static const struct fs_parameter_spec proc_param_specs[] = {
+ 	fsparam_u32("gid",	Opt_gid),
+ 	fsparam_u32("hidepid",	Opt_hidepid),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description proc_fs_parameters = {
+ 	.name		= "proc",
+ 	.specs		= proc_param_specs,
+ };
+ 
+ static int proc_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 66f592e2ece0 (proc: Add fs_context support to procfs)
  {
- 	char *p;
- 	substring_t args[MAX_OPT_ARGS];
- 	int option;
- 
- 	if (!options)
- 		return 1;
- 
- 	while ((p = strsep(&options, ",")) != NULL) {
- 		int token;
- 		if (!*p)
- 			continue;
- 
- 		args[0].to = args[0].from = NULL;
- 		token = match_token(p, tokens, args);
- 		switch (token) {
- 		case Opt_gid:
- 			if (match_int(&args[0], &option))
- 				return 0;
- 			pid->pid_gid = make_kgid(current_user_ns(), option);
- 			break;
- 		case Opt_hidepid:
- 			if (match_int(&args[0], &option))
- 				return 0;
- 			if (option < HIDEPID_OFF ||
- 			    option > HIDEPID_INVISIBLE) {
- 				pr_err("proc: hidepid value must be between 0 and 2.\n");
- 				return 0;
- 			}
- 			pid->hide_pid = option;
- 			break;
- 		default:
- 			pr_err("proc: unrecognized mount option \"%s\" "
- 			       "or missing value\n", p);
- 			return 0;
- 		}
+ 	struct proc_fs_context *ctx = fc->fs_private;
+ 	struct fs_parse_result result;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, &proc_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_gid:
+ 		ctx->gid = result.uint_32;
+ 		break;
+ 
+ 	case Opt_hidepid:
+ 		ctx->hidepid = result.uint_32;
+ 		if (ctx->hidepid < HIDEPID_OFF ||
+ 		    ctx->hidepid > HIDEPID_INVISIBLE)
+ 			return invalf(fc, "proc: hidepid value must be between 0 and 2.\n");
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
  	}
  
- 	return 1;
+ 	ctx->mask |= 1 << opt;
+ 	return 0;
  }
  
++<<<<<<< HEAD
 +int proc_remount(struct super_block *sb, int *flags, char *data)
++=======
+ static void proc_apply_options(struct super_block *s,
+ 			       struct fs_context *fc,
+ 			       struct pid_namespace *pid_ns,
+ 			       struct user_namespace *user_ns)
  {
+ 	struct proc_fs_context *ctx = fc->fs_private;
+ 
+ 	if (ctx->mask & (1 << Opt_gid))
+ 		pid_ns->pid_gid = make_kgid(user_ns, ctx->gid);
+ 	if (ctx->mask & (1 << Opt_hidepid))
+ 		pid_ns->hide_pid = ctx->hidepid;
+ }
+ 
+ static int proc_fill_super(struct super_block *s, struct fs_context *fc)
+ {
+ 	struct pid_namespace *pid_ns = get_pid_ns(s->s_fs_info);
+ 	struct inode *root_inode;
+ 	int ret;
+ 
+ 	proc_apply_options(s, fc, pid_ns, current_user_ns());
+ 
+ 	/* User space would break if executables or devices appear on proc */
+ 	s->s_iflags |= SB_I_USERNS_VISIBLE | SB_I_NOEXEC | SB_I_NODEV;
+ 	s->s_flags |= SB_NODIRATIME | SB_NOSUID | SB_NOEXEC;
+ 	s->s_blocksize = 1024;
+ 	s->s_blocksize_bits = 10;
+ 	s->s_magic = PROC_SUPER_MAGIC;
+ 	s->s_op = &proc_sops;
+ 	s->s_time_gran = 1;
+ 
+ 	/*
+ 	 * procfs isn't actually a stacking filesystem; however, there is
+ 	 * too much magic going on inside it to permit stacking things on
+ 	 * top of it
+ 	 */
+ 	s->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;
+ 	
+ 	/* procfs dentries and inodes don't require IO to create */
+ 	s->s_shrink.seeks = 0;
+ 
+ 	pde_get(&proc_root);
+ 	root_inode = proc_get_inode(s, &proc_root);
+ 	if (!root_inode) {
+ 		pr_err("proc_fill_super: get root inode failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	s->s_root = d_make_root(root_inode);
+ 	if (!s->s_root) {
+ 		pr_err("proc_fill_super: allocate dentry failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	ret = proc_setup_self(s);
+ 	if (ret) {
+ 		return ret;
+ 	}
+ 	return proc_setup_thread_self(s);
+ }
+ 
+ static int proc_reconfigure(struct fs_context *fc)
++>>>>>>> 66f592e2ece0 (proc: Add fs_context support to procfs)
+ {
+ 	struct super_block *sb = fc->root->d_sb;
  	struct pid_namespace *pid = sb->s_fs_info;
  
  	sync_filesystem(sb);
diff --git a/fs/proc/inode.c b/fs/proc/inode.c
index 85ffbd27f288..a8e8a5d20050 100644
--- a/fs/proc/inode.c
+++ b/fs/proc/inode.c
@@ -128,7 +128,6 @@ static const struct super_operations proc_sops = {
 	.drop_inode	= generic_delete_inode,
 	.evict_inode	= proc_evict_inode,
 	.statfs		= simple_statfs,
-	.remount_fs	= proc_remount,
 	.show_options	= proc_show_options,
 };
 
diff --git a/fs/proc/internal.h b/fs/proc/internal.h
index 67f8409bc1c0..36e4042052bf 100644
--- a/fs/proc/internal.h
+++ b/fs/proc/internal.h
@@ -276,7 +276,6 @@ extern struct proc_dir_entry proc_root;
 extern int proc_parse_options(char *options, struct pid_namespace *pid);
 
 extern void proc_self_init(void);
-extern int proc_remount(struct super_block *, int *, char *);
 
 /*
  * task_[no]mmu.c
* Unmerged path fs/proc/root.c
