powerpc/security: Allow for processors that flush the link stack using the special bcctr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Nicholas Piggin <npiggin@gmail.com>
commit 4d24e21cc694e7253a532fe5a9bde12b284f1317
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4d24e21c.failed

If both count cache and link stack are to be flushed, and can be flushed
with the special bcctr, patch that in directly to the flush/branch nop
site.

	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200609070610.846703-7-npiggin@gmail.com
(cherry picked from commit 4d24e21cc694e7253a532fe5a9bde12b284f1317)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/security.c
diff --cc arch/powerpc/kernel/security.c
index 9203c2cff485,c9876aab3142..000000000000
--- a/arch/powerpc/kernel/security.c
+++ b/arch/powerpc/kernel/security.c
@@@ -208,18 -219,12 +208,25 @@@ ssize_t cpu_show_spectre_v2(struct devi
  		if (ccd)
  			seq_buf_printf(&s, "Indirect branch cache disabled");
  
++<<<<<<< HEAD
 +		if (link_stack_flush_enabled)
 +			seq_buf_printf(&s, ", Software link stack flush");
 +
 +	} else if (count_cache_flush_type != COUNT_CACHE_FLUSH_NONE) {
++=======
+ 	} else if (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE) {
++>>>>>>> 4d24e21cc694 (powerpc/security: Allow for processors that flush the link stack using the special bcctr)
  		seq_buf_printf(&s, "Mitigation: Software count cache flush");
  
 -		if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW)
 +		if (count_cache_flush_type == COUNT_CACHE_FLUSH_HW)
  			seq_buf_printf(&s, " (hardware accelerated)");
  
++<<<<<<< HEAD
 +		if (link_stack_flush_enabled)
 +			seq_buf_printf(&s, ", Software link stack flush");
 +
++=======
++>>>>>>> 4d24e21cc694 (powerpc/security: Allow for processors that flush the link stack using the special bcctr)
  	} else if (btb_flush_enabled) {
  		seq_buf_printf(&s, "Mitigation: Branch predictor state flush");
  	} else {
@@@ -413,58 -428,79 +427,109 @@@ static __init int stf_barrier_debugfs_i
  device_initcall(stf_barrier_debugfs_init);
  #endif /* CONFIG_DEBUG_FS */
  
 -static void update_branch_cache_flush(void)
 +static void no_count_cache_flush(void)
  {
++<<<<<<< HEAD
 +	count_cache_flush_type = COUNT_CACHE_FLUSH_NONE;
 +	pr_info("count-cache-flush: software flush disabled.\n");
++=======
+ #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
+ 	// This controls the branch from guest_exit_cont to kvm_flush_link_stack
+ 	if (link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {
+ 		patch_instruction_site(&patch__call_kvm_flush_link_stack,
+ 				       ppc_inst(PPC_INST_NOP));
+ 	} else {
+ 		// Could use HW flush, but that could also flush count cache
+ 		patch_branch_site(&patch__call_kvm_flush_link_stack,
+ 				  (u64)&kvm_flush_link_stack, BRANCH_SET_LINK);
+ 	}
+ #endif
+ 
+ 	// This controls the branch from _switch to flush_branch_caches
+ 	if (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE &&
+ 	    link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {
+ 		patch_instruction_site(&patch__call_flush_branch_caches,
+ 				       ppc_inst(PPC_INST_NOP));
+ 	} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW &&
+ 		   link_stack_flush_type == BRANCH_CACHE_FLUSH_HW) {
+ 		patch_instruction_site(&patch__call_flush_branch_caches,
+ 				       ppc_inst(PPC_INST_BCCTR_FLUSH));
+ 	} else {
+ 		patch_branch_site(&patch__call_flush_branch_caches,
+ 				  (u64)&flush_branch_caches, BRANCH_SET_LINK);
+ 
+ 		// If we just need to flush the link stack, early return
+ 		if (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE) {
+ 			patch_instruction_site(&patch__flush_link_stack_return,
+ 					       ppc_inst(PPC_INST_BLR));
+ 
+ 		// If we have flush instruction, early return
+ 		} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW) {
+ 			patch_instruction_site(&patch__flush_count_cache_return,
+ 					       ppc_inst(PPC_INST_BLR));
+ 		}
+ 	}
++>>>>>>> 4d24e21cc694 (powerpc/security: Allow for processors that flush the link stack using the special bcctr)
  }
  
 -static void toggle_branch_cache_flush(bool enable)
 +static void toggle_count_cache_flush(bool enable)
  {
 -	if (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {
 -		if (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE)
 -			count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;
 +	if (!security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE) &&
 +	    !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK))
 +		enable = false;
  
 -		pr_info("count-cache-flush: flush disabled.\n");
 -	} else {
 -		if (security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {
 -			count_cache_flush_type = BRANCH_CACHE_FLUSH_HW;
 -			pr_info("count-cache-flush: hardware flush enabled.\n");
 -		} else {
 -			count_cache_flush_type = BRANCH_CACHE_FLUSH_SW;
 -			pr_info("count-cache-flush: software flush enabled.\n");
 -		}
 +	if (!enable) {
 +		patch_instruction_site(&patch__call_flush_count_cache, PPC_INST_NOP);
 +#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
 +		patch_instruction_site(&patch__call_kvm_flush_link_stack, PPC_INST_NOP);
 +#endif
 +		pr_info("link-stack-flush: software flush disabled.\n");
 +		link_stack_flush_enabled = false;
 +		no_count_cache_flush();
 +		return;
  	}
  
 -	if (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK)) {
 -		if (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)
 -			link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;
 +	// This enables the branch from _switch to flush_count_cache
 +	patch_branch_site(&patch__call_flush_count_cache,
 +			  (u64)&flush_count_cache, BRANCH_SET_LINK);
 +
++<<<<<<< HEAD
 +#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
 +	// This enables the branch from guest_exit_cont to kvm_flush_link_stack
 +	patch_branch_site(&patch__call_kvm_flush_link_stack,
 +			  (u64)&kvm_flush_link_stack, BRANCH_SET_LINK);
 +#endif
  
 +	pr_info("link-stack-flush: software flush enabled.\n");
 +	link_stack_flush_enabled = true;
 +
 +	// If we just need to flush the link stack, patch an early return
 +	if (!security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {
 +		patch_instruction_site(&patch__flush_link_stack_return, PPC_INST_BLR);
 +		no_count_cache_flush();
 +		return;
++=======
+ 		pr_info("link-stack-flush: flush disabled.\n");
+ 	} else {
+ 		if (security_ftr_enabled(SEC_FTR_BCCTR_LINK_FLUSH_ASSIST)) {
+ 			link_stack_flush_type = BRANCH_CACHE_FLUSH_HW;
+ 			pr_info("link-stack-flush: hardware flush enabled.\n");
+ 		} else {
+ 			link_stack_flush_type = BRANCH_CACHE_FLUSH_SW;
+ 			pr_info("link-stack-flush: software flush enabled.\n");
+ 		}
++>>>>>>> 4d24e21cc694 (powerpc/security: Allow for processors that flush the link stack using the special bcctr)
 +	}
 +
 +	if (!security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {
 +		count_cache_flush_type = COUNT_CACHE_FLUSH_SW;
 +		pr_info("count-cache-flush: full software flush sequence enabled.\n");
 +		return;
  	}
  
 -	update_branch_cache_flush();
 +	patch_instruction_site(&patch__flush_count_cache_return, PPC_INST_BLR);
 +	count_cache_flush_type = COUNT_CACHE_FLUSH_HW;
 +	pr_info("count-cache-flush: hardware assisted flush sequence enabled\n");
  }
  
  void setup_count_cache_flush(void)
diff --git a/arch/powerpc/include/asm/security_features.h b/arch/powerpc/include/asm/security_features.h
index ccf44c135389..a5bcfa0831ad 100644
--- a/arch/powerpc/include/asm/security_features.h
+++ b/arch/powerpc/include/asm/security_features.h
@@ -63,6 +63,8 @@ static inline bool security_ftr_enabled(unsigned long feature)
 // bcctr 2,0,0 triggers a hardware assisted count cache flush
 #define SEC_FTR_BCCTR_FLUSH_ASSIST	0x0000000000000800ull
 
+// bcctr 2,0,0 triggers a hardware assisted link stack flush
+#define SEC_FTR_BCCTR_LINK_FLUSH_ASSIST	0x0000000000002000ull
 
 // Features indicating need for Spectre/Meltdown mitigations
 
* Unmerged path arch/powerpc/kernel/security.c
