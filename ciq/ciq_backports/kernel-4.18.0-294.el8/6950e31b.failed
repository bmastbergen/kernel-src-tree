x86/efi: Push EFI_MEMMAP check into leaf routines

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit 6950e31b35fdf4588cbbdec1813091bb02cf8871
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6950e31b.failed

In preparation for adding another EFI_MEMMAP dependent call that needs
to occur before e820__memblock_setup() fixup the existing efi calls to
check for EFI_MEMMAP internally. This ends up being cleaner than the
alternative of checking EFI_MEMMAP multiple times in setup_arch().

	Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
	Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Acked-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 6950e31b35fdf4588cbbdec1813091bb02cf8871)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/efi.h
#	arch/x86/kernel/setup.c
diff --cc arch/x86/include/asm/efi.h
index 42982a6cc6cf,45f853bce869..000000000000
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@@ -245,13 -241,26 +244,28 @@@ static inline bool efi_is_64bit(void
  		__efi_early()->runtime_services), __VA_ARGS__)
  
  extern bool efi_reboot_required(void);
 -extern bool efi_is_table_address(unsigned long phys_addr);
  
+ extern void efi_find_mirror(void);
+ extern void efi_reserve_boot_services(void);
  #else
  static inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}
  static inline bool efi_reboot_required(void)
  {
  	return false;
  }
++<<<<<<< HEAD
++=======
+ static inline  bool efi_is_table_address(unsigned long phys_addr)
+ {
+ 	return false;
+ }
+ static inline void efi_find_mirror(void)
+ {
+ }
+ static inline void efi_reserve_boot_services(void)
+ {
+ }
++>>>>>>> 6950e31b35fd (x86/efi: Push EFI_MEMMAP check into leaf routines)
  #endif /* CONFIG_EFI */
  
  #endif /* _ASM_X86_EFI_H */
diff --cc arch/x86/kernel/setup.c
index 5306303cfaa7,1c4b866bc184..000000000000
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@@ -1192,18 -1122,15 +1192,23 @@@ void __init setup_arch(char **cmdline_p
  
  	reserve_bios_regions();
  
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_MEMMAP)) {
 +		efi_fake_memmap();
 +		efi_find_mirror();
 +		efi_esrt_init();
 +		efi_mokvar_table_init();
++=======
+ 	efi_fake_memmap();
+ 	efi_find_mirror();
+ 	efi_esrt_init();
++>>>>>>> 6950e31b35fd (x86/efi: Push EFI_MEMMAP check into leaf routines)
  
- 		/*
- 		 * The EFI specification says that boot service code won't be
- 		 * called after ExitBootServices(). This is, in fact, a lie.
- 		 */
- 		efi_reserve_boot_services();
- 	}
+ 	/*
+ 	 * The EFI specification says that boot service code won't be
+ 	 * called after ExitBootServices(). This is, in fact, a lie.
+ 	 */
+ 	efi_reserve_boot_services();
  
  	/* preallocate 4k for mptable mpc */
  	e820__memblock_alloc_reserved_mpc_new();
* Unmerged path arch/x86/include/asm/efi.h
* Unmerged path arch/x86/kernel/setup.c
diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c
index 4c3f7e46cc36..f8418f9c54f0 100644
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@ -105,6 +105,9 @@ void __init efi_find_mirror(void)
 	efi_memory_desc_t *md;
 	u64 mirror_size = 0, total_size = 0;
 
+	if (!efi_enabled(EFI_MEMMAP))
+		return;
+
 	for_each_efi_memory_desc(md) {
 		unsigned long long start = md->phys_addr;
 		unsigned long long size = md->num_pages << EFI_PAGE_SHIFT;
diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index a125ad74c747..3f5f5683e18e 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -316,6 +316,9 @@ void __init efi_reserve_boot_services(void)
 {
 	efi_memory_desc_t *md;
 
+	if (!efi_enabled(EFI_MEMMAP))
+		return;
+
 	for_each_efi_memory_desc(md) {
 		u64 start = md->phys_addr;
 		u64 size = md->num_pages << EFI_PAGE_SHIFT;
diff --git a/drivers/firmware/efi/esrt.c b/drivers/firmware/efi/esrt.c
index 1ab80e06e7c5..66e6c72773af 100644
--- a/drivers/firmware/efi/esrt.c
+++ b/drivers/firmware/efi/esrt.c
@@ -245,6 +245,9 @@ void __init efi_esrt_init(void)
 	int rc;
 	phys_addr_t end;
 
+	if (!efi_enabled(EFI_MEMMAP))
+		return;
+
 	pr_debug("esrt-init: loading.\n");
 	if (!esrt_table_exists())
 		return;
diff --git a/drivers/firmware/efi/fake_mem.c b/drivers/firmware/efi/fake_mem.c
index 6c7d60c239b5..a67b97f10851 100644
--- a/drivers/firmware/efi/fake_mem.c
+++ b/drivers/firmware/efi/fake_mem.c
@@ -58,7 +58,7 @@ void __init efi_fake_memmap(void)
 	void *new_memmap;
 	int i;
 
-	if (!nr_fake_mem)
+	if (!efi_enabled(EFI_MEMMAP) || !nr_fake_mem)
 		return;
 
 	/* count up the number of EFI memory descriptor */
diff --git a/include/linux/efi.h b/include/linux/efi.h
index f214b7a114d6..a89208debea1 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1039,7 +1039,6 @@ extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if pos
 extern efi_status_t efi_query_variable_store(u32 attributes,
 					     unsigned long size,
 					     bool nonblocking);
-extern void efi_find_mirror(void);
 #else
 
 static inline efi_status_t efi_query_variable_store(u32 attributes,
