crypto: algapi - introduce the flag CRYPTO_ALG_ALLOCATES_MEMORY

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Eric Biggers <ebiggers@google.com>
commit fbb6cda44190d72aa5199d728797aabc6d2ed816
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fbb6cda4.failed

Introduce a new algorithm flag CRYPTO_ALG_ALLOCATES_MEMORY.  If this
flag is set, then the driver allocates memory in its request routine.
Such drivers are not suitable for disk encryption because GFP_ATOMIC
allocation can fail anytime (causing random I/O errors) and GFP_KERNEL
allocation can recurse into the block layer, causing a deadlock.

For now, this flag is only implemented for some algorithm types.  We
also assume some usage constraints for it to be meaningful, since there
are lots of edge cases the crypto API allows (e.g., misaligned or
fragmented scatterlists) that mean that nearly any crypto algorithm can
allocate memory in some case.  See the comment for details.

Also add this flag to CRYPTO_ALG_INHERITED_FLAGS so that when a template
is instantiated, this flag is set on the template instance if it is set
on any algorithm the instance uses.

Based on a patch by Mikulas Patocka <mpatocka@redhat.com>
(https://lore.kernel.org/r/alpine.LRH.2.02.2006301414580.30526@file01.intranet.prod.int.rdu2.redhat.com).

	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit fbb6cda44190d72aa5199d728797aabc6d2ed816)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/crypto/algapi.h
#	include/linux/crypto.h
diff --cc include/crypto/algapi.h
index 807501a4a754,143d884d65c7..000000000000
--- a/include/crypto/algapi.h
+++ b/include/crypto/algapi.h
@@@ -392,12 -241,23 +392,26 @@@ static inline int crypto_requires_off(u
  }
  
  /*
 - * When an algorithm uses another algorithm (e.g., if it's an instance of a
 - * template), these are the flags that should always be set on the "outer"
 - * algorithm if any "inner" algorithm has them set.
 + * Returns CRYPTO_ALG_ASYNC if type/mask requires the use of sync algorithms.
 + * Otherwise returns zero.
   */
++<<<<<<< HEAD
 +static inline int crypto_requires_sync(u32 type, u32 mask)
++=======
+ #define CRYPTO_ALG_INHERITED_FLAGS	\
+ 	(CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK |	\
+ 	 CRYPTO_ALG_ALLOCATES_MEMORY)
+ 
+ /*
+  * Given the type and mask that specify the flags restrictions on a template
+  * instance being created, return the mask that should be passed to
+  * crypto_grab_*() (along with type=0) to honor any request the user made to
+  * have any of the CRYPTO_ALG_INHERITED_FLAGS clear.
+  */
+ static inline u32 crypto_algt_inherited_mask(struct crypto_attr_type *algt)
++>>>>>>> fbb6cda44190 (crypto: algapi - introduce the flag CRYPTO_ALG_ALLOCATES_MEMORY)
  {
 -	return crypto_requires_off(algt, CRYPTO_ALG_INHERITED_FLAGS);
 +	return crypto_requires_off(type, mask, CRYPTO_ALG_ASYNC);
  }
  
  noinline unsigned long __crypto_memneq(const void *a, const void *b, size_t size);
diff --cc include/linux/crypto.h
index 6eb06101089f,ef90e07c9635..000000000000
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@@ -113,6 -96,43 +113,46 @@@
  #define CRYPTO_ALG_OPTIONAL_KEY		0x00004000
  
  /*
++<<<<<<< HEAD
++=======
+  * Don't trigger module loading
+  */
+ #define CRYPTO_NOLOAD			0x00008000
+ 
+ /*
+  * The algorithm may allocate memory during request processing, i.e. during
+  * encryption, decryption, or hashing.  Users can request an algorithm with this
+  * flag unset if they can't handle memory allocation failures.
+  *
+  * This flag is currently only implemented for algorithms of type "skcipher",
+  * "aead", "ahash", "shash", and "cipher".  Algorithms of other types might not
+  * have this flag set even if they allocate memory.
+  *
+  * In some edge cases, algorithms can allocate memory regardless of this flag.
+  * To avoid these cases, users must obey the following usage constraints:
+  *    skcipher:
+  *	- The IV buffer and all scatterlist elements must be aligned to the
+  *	  algorithm's alignmask.
+  *	- If the data were to be divided into chunks of size
+  *	  crypto_skcipher_walksize() (with any remainder going at the end), no
+  *	  chunk can cross a page boundary or a scatterlist element boundary.
+  *    aead:
+  *	- The IV buffer and all scatterlist elements must be aligned to the
+  *	  algorithm's alignmask.
+  *	- The first scatterlist element must contain all the associated data,
+  *	  and its pages must be !PageHighMem.
+  *	- If the plaintext/ciphertext were to be divided into chunks of size
+  *	  crypto_aead_walksize() (with the remainder going at the end), no chunk
+  *	  can cross a page boundary or a scatterlist element boundary.
+  *    ahash:
+  *	- The result buffer must be aligned to the algorithm's alignmask.
+  *	- crypto_ahash_finup() must not be used unless the algorithm implements
+  *	  ->finup() natively.
+  */
+ #define CRYPTO_ALG_ALLOCATES_MEMORY	0x00010000
+ 
+ /*
++>>>>>>> fbb6cda44190 (crypto: algapi - introduce the flag CRYPTO_ALG_ALLOCATES_MEMORY)
   * Transform masks and values (for crt_flags).
   */
  #define CRYPTO_TFM_NEED_KEY		0x00000001
* Unmerged path include/crypto/algapi.h
* Unmerged path include/linux/crypto.h
