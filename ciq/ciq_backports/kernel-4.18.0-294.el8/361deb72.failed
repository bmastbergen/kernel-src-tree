dmaengine: dmatest: wrap src & dst data into a struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Alexandru Ardelean <alexandru.ardelean@analog.com>
commit 361deb7243d275ba8ce6e27db7727fce6fd39f3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/361deb72.failed

This change wraps the data for the source & destination buffers into a
`struct dmatest_data`. The rename patterns are:
 * src_cnt -> src->cnt
 * dst_cnt -> dst->cnt
 * src_off -> src->off
 * dst_off -> dst->off
 * thread->srcs -> src->aligned
 * thread->usrcs -> src->raw
 * thread->dsts -> dst->aligned
 * thread->udsts -> dst->raw

The intent is to make a function that moves duplicate parts of the code
into common alloc & free functions, which will unclutter the
`dmatest_func()` function.

	Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 361deb7243d275ba8ce6e27db7727fce6fd39f3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/dmatest.c
diff --cc drivers/dma/dmatest.c
index 6511928b4cdf,ea1f885e70f4..000000000000
--- a/drivers/dma/dmatest.c
+++ b/drivers/dma/dmatest.c
@@@ -708,12 -715,14 +715,18 @@@ static int dmatest_func(void *data
  
  			um->addr[i] = dma_map_page(dev->dev, pg, pg_off,
  						   um->len, DMA_TO_DEVICE);
- 			srcs[i] = um->addr[i] + src_off;
+ 			srcs[i] = um->addr[i] + src->off;
  			ret = dma_mapping_error(dev->dev, um->addr[i]);
  			if (ret) {
 -				dmaengine_unmap_put(um);
  				result("src mapping error", total_tests,
++<<<<<<< HEAD
 +				       src_off, dst_off, len, ret);
 +				goto error_unmap_continue;
++=======
+ 				       src->off, dst->off, len, ret);
+ 				failed_tests++;
+ 				continue;
++>>>>>>> 361deb7243d2 (dmaengine: dmatest: wrap src & dst data into a struct)
  			}
  			um->to_cnt++;
  		}
@@@ -728,9 -737,11 +741,15 @@@
  					       DMA_BIDIRECTIONAL);
  			ret = dma_mapping_error(dev->dev, dsts[i]);
  			if (ret) {
 -				dmaengine_unmap_put(um);
  				result("dst mapping error", total_tests,
++<<<<<<< HEAD
 +				       src_off, dst_off, len, ret);
 +				goto error_unmap_continue;
++=======
+ 				       src->off, dst->off, len, ret);
+ 				failed_tests++;
+ 				continue;
++>>>>>>> 361deb7243d2 (dmaengine: dmatest: wrap src & dst data into a struct)
  			}
  			um->bidi_cnt++;
  		}
@@@ -758,10 -769,12 +777,16 @@@
  		}
  
  		if (!tx) {
++<<<<<<< HEAD
 +			result("prep error", total_tests, src_off,
 +			       dst_off, len, ret);
++=======
+ 			dmaengine_unmap_put(um);
+ 			result("prep error", total_tests, src->off,
+ 			       dst->off, len, ret);
++>>>>>>> 361deb7243d2 (dmaengine: dmatest: wrap src & dst data into a struct)
  			msleep(100);
 -			failed_tests++;
 -			continue;
 +			goto error_unmap_continue;
  		}
  
  		done->done = false;
@@@ -770,10 -783,12 +795,16 @@@
  		cookie = tx->tx_submit(tx);
  
  		if (dma_submit_error(cookie)) {
++<<<<<<< HEAD
 +			result("submit error", total_tests, src_off,
 +			       dst_off, len, ret);
++=======
+ 			dmaengine_unmap_put(um);
+ 			result("submit error", total_tests, src->off,
+ 			       dst->off, len, ret);
++>>>>>>> 361deb7243d2 (dmaengine: dmatest: wrap src & dst data into a struct)
  			msleep(100);
 -			failed_tests++;
 -			continue;
 +			goto error_unmap_continue;
  		}
  		dma_async_issue_pending(chan);
  
@@@ -782,23 -797,25 +813,30 @@@
  
  		status = dma_async_is_tx_complete(chan, cookie, NULL, NULL);
  
 -		dmaengine_unmap_put(um);
 -
  		if (!done->done) {
- 			result("test timed out", total_tests, src_off, dst_off,
+ 			result("test timed out", total_tests, src->off, dst->off,
  			       len, 0);
 -			failed_tests++;
 -			continue;
 +			goto error_unmap_continue;
  		} else if (status != DMA_COMPLETE) {
  			result(status == DMA_ERROR ?
  			       "completion error status" :
++<<<<<<< HEAD
 +			       "completion busy status", total_tests, src_off,
 +			       dst_off, len, ret);
 +			goto error_unmap_continue;
++=======
+ 			       "completion busy status", total_tests, src->off,
+ 			       dst->off, len, ret);
+ 			failed_tests++;
+ 			continue;
++>>>>>>> 361deb7243d2 (dmaengine: dmatest: wrap src & dst data into a struct)
  		}
  
 +		dmaengine_unmap_put(um);
 +
  		if (params->noverify) {
- 			verbose_result("test passed", total_tests, src_off,
- 				       dst_off, len, 0);
+ 			verbose_result("test passed", total_tests, src->off,
+ 				       dst->off, len, 0);
  			continue;
  		}
  
@@@ -833,15 -850,9 +871,15 @@@
  			       len, error_count);
  			failed_tests++;
  		} else {
- 			verbose_result("test passed", total_tests, src_off,
- 				       dst_off, len, 0);
+ 			verbose_result("test passed", total_tests, src->off,
+ 				       dst->off, len, 0);
  		}
 +
 +		continue;
 +
 +error_unmap_continue:
 +		dmaengine_unmap_put(um);
 +		failed_tests++;
  	}
  	ktime = ktime_sub(ktime_get(), ktime);
  	ktime = ktime_sub(ktime, comparetime);
* Unmerged path drivers/dma/dmatest.c
