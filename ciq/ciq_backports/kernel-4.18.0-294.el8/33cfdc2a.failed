nvme: enforce extended LBA format for fabrics metadata

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Max Gurtovoy <maxg@mellanox.com>
commit 33cfdc2aa6969829f42640f758357e4b015e9f7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/33cfdc2a.failed

An extended LBA is a larger LBA that is created when metadata associated
with the LBA is transferred contiguously with the LBA data (AKA
interleaved). The metadata may be either transferred as part of the LBA
(creating an extended LBA) or it may be transferred as a separate
contiguous buffer of data. According to the NVMeoF spec, a fabrics ctrl
supports only an Extended LBA format. Fail revalidation in case we have a
spec violation. Also add a flag that will imply on capable transports and
controllers as part of a preparation for allowing end-to-end protection
information for fabric controllers.

	Suggested-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Max Gurtovoy <maxg@mellanox.com>
	Signed-off-by: Israel Rukshin <israelr@mellanox.com>
	Reviewed-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 33cfdc2aa6969829f42640f758357e4b015e9f7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index ce3f74d6d89f,a3a4dbc59af1..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1979,6 -1944,29 +1980,32 @@@ static int __nvme_revalidate_disk(struc
  	else
  		ns->pi_type = 0;
  
++<<<<<<< HEAD
++=======
+ 	if (ns->ms) {
+ 		/*
+ 		 * For PCIe only the separate metadata pointer is supported,
+ 		 * as the block layer supplies metadata in a separate bio_vec
+ 		 * chain. For Fabrics, only metadata as part of extended data
+ 		 * LBA is supported on the wire per the Fabrics specification,
+ 		 * but the HBA/HCA will do the remapping from the separate
+ 		 * metadata buffers for us.
+ 		 */
+ 		if (id->flbas & NVME_NS_FLBAS_META_EXT) {
+ 			ns->features |= NVME_NS_EXT_LBAS;
+ 			if ((ctrl->ops->flags & NVME_F_FABRICS) &&
+ 			    (ctrl->ops->flags & NVME_F_METADATA_SUPPORTED) &&
+ 			    ctrl->max_integrity_segments)
+ 				ns->features |= NVME_NS_METADATA_SUPPORTED;
+ 		} else {
+ 			if (WARN_ON_ONCE(ctrl->ops->flags & NVME_F_FABRICS))
+ 				return -EINVAL;
+ 			if (ctrl->ops->flags & NVME_F_METADATA_SUPPORTED)
+ 				ns->features |= NVME_NS_METADATA_SUPPORTED;
+ 		}
+ 	}
+ 
++>>>>>>> 33cfdc2aa696 (nvme: enforce extended LBA format for fabrics metadata)
  	if (iob)
  		blk_queue_chunk_sectors(ns->queue, rounddown_pow_of_two(iob));
  	nvme_update_disk_info(disk, ns, id);
* Unmerged path drivers/nvme/host/core.c
