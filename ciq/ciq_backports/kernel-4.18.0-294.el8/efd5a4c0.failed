mptcp: add the address ID assignment bitmap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit efd5a4c04e1835acc64eb44818247ca88e80b294
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/efd5a4c0.failed

Currently the address ID set by the netlink PM from user-space is
overridden by the kernel. This patch added the address ID assignment
bitmap to allow user-space to set the address ID.

Use a per netns bitmask id_bitmap (256 bits) to keep track of in-use IDs.
And use next_id to keep track of the highest ID currently in use. If the
user-space provides an ID at endpoint creation time, try to use it. If
already in use, endpoint creation fails. Otherwise pick the first ID
available after the highest currently in use, with wrap-around.

	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit efd5a4c04e1835acc64eb44818247ca88e80b294)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/pm_netlink.c
index a69958fdfc35,7fe7be4eef7e..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -29,6 -28,17 +29,20 @@@ struct mptcp_pm_addr_entry 
  	struct rcu_head		rcu;
  };
  
++<<<<<<< HEAD
++=======
+ struct mptcp_pm_add_entry {
+ 	struct list_head	list;
+ 	struct mptcp_addr_info	addr;
+ 	struct timer_list	add_timer;
+ 	struct mptcp_sock	*sock;
+ 	u8			retrans_times;
+ };
+ 
+ #define MAX_ADDR_ID		255
+ #define BITMAP_SZ DIV_ROUND_UP(MAX_ADDR_ID + 1, BITS_PER_LONG)
+ 
++>>>>>>> efd5a4c04e18 (mptcp: add the address ID assignment bitmap)
  struct pm_nl_pernet {
  	/* protects pernet updates */
  	spinlock_t		lock;
@@@ -301,12 -545,30 +318,34 @@@ static int mptcp_pm_nl_append_new_local
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	if (entry->flags & MPTCP_PM_ADDR_FLAG_SIGNAL)
++=======
+ 	if (!entry->addr.id) {
+ find_next:
+ 		entry->addr.id = find_next_zero_bit(pernet->id_bitmap,
+ 						    MAX_ADDR_ID + 1,
+ 						    pernet->next_id);
+ 		if ((!entry->addr.id || entry->addr.id > MAX_ADDR_ID) &&
+ 		    pernet->next_id != 1) {
+ 			pernet->next_id = 1;
+ 			goto find_next;
+ 		}
+ 	}
+ 
+ 	if (!entry->addr.id || entry->addr.id > MAX_ADDR_ID)
+ 		goto out;
+ 
+ 	__set_bit(entry->addr.id, pernet->id_bitmap);
+ 	if (entry->addr.id > pernet->next_id)
+ 		pernet->next_id = entry->addr.id;
+ 
+ 	if (entry->addr.flags & MPTCP_PM_ADDR_FLAG_SIGNAL)
++>>>>>>> efd5a4c04e18 (mptcp: add the address ID assignment bitmap)
  		pernet->add_addr_signal_max++;
 -	if (entry->addr.flags & MPTCP_PM_ADDR_FLAG_SUBFLOW)
 +	if (entry->flags & MPTCP_PM_ADDR_FLAG_SUBFLOW)
  		pernet->local_addr_max++;
  
- 	entry->addr.id = pernet->next_id++;
  	pernet->addrs++;
  	list_add_tail_rcu(&entry->list, &pernet->local_addr_list);
  	ret = entry->addr.id;
@@@ -356,8 -618,10 +395,14 @@@ int mptcp_pm_nl_get_local_id(struct mpt
  	if (!entry)
  		return -ENOMEM;
  
 +	entry->flags = 0;
  	entry->addr = skc_local;
++<<<<<<< HEAD
++=======
+ 	entry->addr.ifindex = 0;
+ 	entry->addr.flags = 0;
+ 	entry->addr.id = 0;
++>>>>>>> efd5a4c04e18 (mptcp: add the address ID assignment bitmap)
  	ret = mptcp_pm_nl_append_new_local_addr(pernet, entry);
  	if (ret < 0)
  		kfree(entry);
@@@ -553,9 -882,12 +598,16 @@@ static int mptcp_nl_cmd_del_addr(struc
  
  	pernet->addrs--;
  	list_del_rcu(&entry->list);
++<<<<<<< HEAD
++=======
+ 	__clear_bit(entry->addr.id, pernet->id_bitmap);
+ 	spin_unlock_bh(&pernet->lock);
+ 
+ 	mptcp_nl_remove_subflow_and_signal_addr(sock_net(skb->sk), &entry->addr);
++>>>>>>> efd5a4c04e18 (mptcp: add the address ID assignment bitmap)
  	kfree_rcu(entry, rcu);
 -
 +out:
 +	spin_unlock_bh(&pernet->lock);
  	return ret;
  }
  
* Unmerged path net/mptcp/pm_netlink.c
