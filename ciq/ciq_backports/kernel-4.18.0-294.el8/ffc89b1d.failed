nvme: introduce namespace features flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Max Gurtovoy <maxg@mellanox.com>
commit ffc89b1d3ca45669e8d2226f5fd4dde756f7ad17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ffc89b1d.failed

Replace the specific ext boolean (that implies on extended LBA format)
with a feature in the new namespace features flag. This is a preparation
for adding more namespace features (such as metadata specific features).

	Signed-off-by: Max Gurtovoy <maxg@mellanox.com>
	Reviewed-by: Israel Rukshin <israelr@mellanox.com>
	Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
	Reviewed-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit ffc89b1d3ca45669e8d2226f5fd4dde756f7ad17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/lightnvm.c
diff --cc drivers/nvme/host/lightnvm.c
index 1afd444caa58,69608755d415..000000000000
--- a/drivers/nvme/host/lightnvm.c
+++ b/drivers/nvme/host/lightnvm.c
@@@ -936,6 -961,11 +936,14 @@@ int nvme_nvm_register(struct nvme_ns *n
  	geo = &dev->geo;
  	geo->csecs = 1 << ns->lba_shift;
  	geo->sos = ns->ms;
++<<<<<<< HEAD
++=======
+ 	if (ns->features & NVME_NS_EXT_LBAS)
+ 		geo->ext = true;
+ 	else
+ 		geo->ext = false;
+ 	geo->mdts = ns->ctrl->max_hw_sectors;
++>>>>>>> ffc89b1d3ca4 (nvme: introduce namespace features flag)
  
  	dev->q = q;
  	memcpy(dev->name, disk_name, DISK_NAME_LEN);
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index ce3f74d6d89f..eddd42f55f23 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -1352,7 +1352,7 @@ static int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio)
 	meta_len = (io.nblocks + 1) * ns->ms;
 	metadata = nvme_to_user_ptr(io.metadata);
 
-	if (ns->ext) {
+	if (ns->features & NVME_NS_EXT_LBAS) {
 		length += meta_len;
 		meta_len = 0;
 	} else if (meta_len) {
@@ -1932,7 +1932,7 @@ static void nvme_update_disk_info(struct gendisk *disk,
 	blk_queue_io_min(disk->queue, phys_bs);
 	blk_queue_io_opt(disk->queue, io_opt);
 
-	if (ns->ms && !ns->ext &&
+	if (ns->ms && !(ns->features & NVME_NS_EXT_LBAS) &&
 	    (ns->ctrl->ops->flags & NVME_F_METADATA_SUPPORTED))
 		nvme_init_integrity(disk, ns->ms, ns->pi_type);
 	if ((ns->ms && !nvme_ns_has_pi(ns) && !blk_get_integrity(disk)) ||
@@ -1971,8 +1971,10 @@ static void __nvme_revalidate_disk(struct gendisk *disk, struct nvme_id_ns *id)
 	else
 		iob = nvme_lba_to_sect(ns, le16_to_cpu(id->noiob));
 
+	ns->features = 0;
 	ns->ms = le16_to_cpu(id->lbaf[id->flbas & NVME_NS_FLBAS_LBA_MASK].ms);
-	ns->ext = ns->ms && (id->flbas & NVME_NS_FLBAS_META_EXT);
+	if (ns->ms && (id->flbas & NVME_NS_FLBAS_META_EXT))
+		ns->features |= NVME_NS_EXT_LBAS;
 	/* the PI implementation requires metadata equal t10 pi tuple size */
 	if (ns->ms == sizeof(struct t10_pi_tuple))
 		ns->pi_type = id->dps & NVME_NS_DPS_PI_MASK;
* Unmerged path drivers/nvme/host/lightnvm.c
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index 74fc5994de0f..e6c08668a081 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -375,6 +375,10 @@ struct nvme_ns_head {
 #endif
 };
 
+enum nvme_ns_features {
+	NVME_NS_EXT_LBAS = 1 << 0, /* support extended LBA format */
+};
+
 struct nvme_ns {
 	struct list_head list;
 
@@ -394,8 +398,8 @@ struct nvme_ns {
 	u16 ms;
 	u16 sgs;
 	u32 sws;
-	bool ext;
 	u8 pi_type;
+	unsigned long features;
 	unsigned long flags;
 #define NVME_NS_REMOVING	0
 #define NVME_NS_DEAD     	1
