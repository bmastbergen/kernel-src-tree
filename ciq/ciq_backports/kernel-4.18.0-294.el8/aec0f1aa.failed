net: atlantic: MACSec offload statistics implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Dmitry Bogdanov <dbogdanov@marvell.com>
commit aec0f1aac58e81e88efe381dc5813e2e4d2858f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/aec0f1aa.failed

This patch adds support for MACSec statistics on Atlantic network cards.

	Signed-off-by: Dmitry Bogdanov <dbogdanov@marvell.com>
	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aec0f1aac58e81e88efe381dc5813e2e4d2858f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
#	drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
#	drivers/net/ethernet/aquantia/atlantic/aq_macsec.h
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
index a64230722f5c,7241cf92b43a..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
@@@ -12,8 -9,12 +12,9 @@@
  #include "aq_ethtool.h"
  #include "aq_nic.h"
  #include "aq_vec.h"
 -#include "aq_ptp.h"
  #include "aq_filters.h"
+ #include "aq_macsec.h"
  
 -#include <linux/ptp_clock_kernel.h>
 -
  static void aq_ethtool_get_regs(struct net_device *ndev,
  				struct ethtool_regs *regs, void *p)
  {
@@@ -92,29 -97,116 +93,135 @@@ static const char aq_ethtool_queue_stat
  	"Queue[%d] InErrors",
  };
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_MACSEC)
+ static const char aq_macsec_stat_names[][ETH_GSTRING_LEN] = {
+ 	"MACSec InCtlPackets",
+ 	"MACSec InTaggedMissPackets",
+ 	"MACSec InUntaggedMissPackets",
+ 	"MACSec InNotagPackets",
+ 	"MACSec InUntaggedPackets",
+ 	"MACSec InBadTagPackets",
+ 	"MACSec InNoSciPackets",
+ 	"MACSec InUnknownSciPackets",
+ 	"MACSec InCtrlPortPassPackets",
+ 	"MACSec InUnctrlPortPassPackets",
+ 	"MACSec InCtrlPortFailPackets",
+ 	"MACSec InUnctrlPortFailPackets",
+ 	"MACSec InTooLongPackets",
+ 	"MACSec InIgpocCtlPackets",
+ 	"MACSec InEccErrorPackets",
+ 	"MACSec InUnctrlHitDropRedir",
+ 	"MACSec OutCtlPackets",
+ 	"MACSec OutUnknownSaPackets",
+ 	"MACSec OutUntaggedPackets",
+ 	"MACSec OutTooLong",
+ 	"MACSec OutEccErrorPackets",
+ 	"MACSec OutUnctrlHitDropRedir",
+ };
+ 
+ static const char *aq_macsec_txsc_stat_names[] = {
+ 	"MACSecTXSC%d ProtectedPkts",
+ 	"MACSecTXSC%d EncryptedPkts",
+ 	"MACSecTXSC%d ProtectedOctets",
+ 	"MACSecTXSC%d EncryptedOctets",
+ };
+ 
+ static const char *aq_macsec_txsa_stat_names[] = {
+ 	"MACSecTXSC%dSA%d HitDropRedirect",
+ 	"MACSecTXSC%dSA%d Protected2Pkts",
+ 	"MACSecTXSC%dSA%d ProtectedPkts",
+ 	"MACSecTXSC%dSA%d EncryptedPkts",
+ };
+ 
+ static const char *aq_macsec_rxsa_stat_names[] = {
+ 	"MACSecRXSC%dSA%d UntaggedHitPkts",
+ 	"MACSecRXSC%dSA%d CtrlHitDrpRedir",
+ 	"MACSecRXSC%dSA%d NotUsingSa",
+ 	"MACSecRXSC%dSA%d UnusedSa",
+ 	"MACSecRXSC%dSA%d NotValidPkts",
+ 	"MACSecRXSC%dSA%d InvalidPkts",
+ 	"MACSecRXSC%dSA%d OkPkts",
+ 	"MACSecRXSC%dSA%d LatePkts",
+ 	"MACSecRXSC%dSA%d DelayedPkts",
+ 	"MACSecRXSC%dSA%d UncheckedPkts",
+ 	"MACSecRXSC%dSA%d ValidatedOctets",
+ 	"MACSecRXSC%dSA%d DecryptedOctets",
+ };
+ #endif
+ 
+ static const char aq_ethtool_priv_flag_names[][ETH_GSTRING_LEN] = {
+ 	"DMASystemLoopback",
+ 	"PKTSystemLoopback",
+ 	"DMANetworkLoopback",
+ 	"PHYInternalLoopback",
+ 	"PHYExternalLoopback",
+ };
+ 
+ static u32 aq_ethtool_n_stats(struct net_device *ndev)
+ {
+ 	struct aq_nic_s *nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(nic);
+ 	u32 n_stats = ARRAY_SIZE(aq_ethtool_stat_names) +
+ 		      ARRAY_SIZE(aq_ethtool_queue_stat_names) * cfg->vecs;
+ 
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 	if (nic->macsec_cfg) {
+ 		n_stats += ARRAY_SIZE(aq_macsec_stat_names) +
+ 			   ARRAY_SIZE(aq_macsec_txsc_stat_names) *
+ 				   aq_macsec_tx_sc_cnt(nic) +
+ 			   ARRAY_SIZE(aq_macsec_txsa_stat_names) *
+ 				   aq_macsec_tx_sa_cnt(nic) +
+ 			   ARRAY_SIZE(aq_macsec_rxsa_stat_names) *
+ 				   aq_macsec_rx_sa_cnt(nic);
+ 	}
+ #endif
+ 
+ 	return n_stats;
+ }
+ 
++>>>>>>> aec0f1aac58e (net: atlantic: MACSec offload statistics implementation)
  static void aq_ethtool_stats(struct net_device *ndev,
  			     struct ethtool_stats *stats, u64 *data)
  {
  	struct aq_nic_s *aq_nic = netdev_priv(ndev);
++<<<<<<< HEAD
 +	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
 +
 +	memset(data, 0, (ARRAY_SIZE(aq_ethtool_stat_names) +
 +			 ARRAY_SIZE(aq_ethtool_queue_stat_names) *
 +			 cfg->vecs) * sizeof(u64));
 +	aq_nic_get_stats(aq_nic, data);
++=======
+ 
+ 	memset(data, 0, aq_ethtool_n_stats(ndev) * sizeof(u64));
+ 	data = aq_nic_get_stats(aq_nic, data);
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 	data = aq_macsec_get_stats(aq_nic, data);
+ #endif
++>>>>>>> aec0f1aac58e (net: atlantic: MACSec offload statistics implementation)
  }
  
  static void aq_ethtool_get_drvinfo(struct net_device *ndev,
  				   struct ethtool_drvinfo *drvinfo)
  {
 -	struct pci_dev *pdev = to_pci_dev(ndev->dev.parent);
  	struct aq_nic_s *aq_nic = netdev_priv(ndev);
++<<<<<<< HEAD
 +	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
 +	struct pci_dev *pdev = to_pci_dev(ndev->dev.parent);
 +	u32 firmware_version = aq_nic_get_fw_version(aq_nic);
 +	u32 regs_count = aq_nic_get_regs_count(aq_nic);
++=======
+ 	u32 firmware_version;
+ 	u32 regs_count;
+ 
+ 	firmware_version = aq_nic_get_fw_version(aq_nic);
+ 	regs_count = aq_nic_get_regs_count(aq_nic);
++>>>>>>> aec0f1aac58e (net: atlantic: MACSec offload statistics implementation)
  
  	strlcat(drvinfo->driver, AQ_CFG_DRV_NAME, sizeof(drvinfo->driver));
 +	strlcat(drvinfo->version, AQ_CFG_DRV_VERSION, sizeof(drvinfo->version));
  
  	snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),
  		 "%u.%u.%u", firmware_version >> 24,
@@@ -132,12 -223,18 +238,18 @@@
  static void aq_ethtool_get_strings(struct net_device *ndev,
  				   u32 stringset, u8 *data)
  {
 +	int i, si;
++<<<<<<< HEAD
  	struct aq_nic_s *aq_nic = netdev_priv(ndev);
 -	struct aq_nic_cfg_s *cfg;
 +	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
  	u8 *p = data;
 -	int i, si;
++=======
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 	int sa;
+ #endif
++>>>>>>> aec0f1aac58e (net: atlantic: MACSec offload statistics implementation)
  
 -	cfg = aq_nic_get_cfg(aq_nic);
 -
 -	switch (stringset) {
 -	case ETH_SS_STATS:
 +	if (stringset == ETH_SS_STATS) {
  		memcpy(p, aq_ethtool_stat_names,
  		       sizeof(aq_ethtool_stat_names));
  		p = p + sizeof(aq_ethtool_stat_names);
@@@ -150,20 -247,108 +262,84 @@@
  				p += ETH_GSTRING_LEN;
  			}
  		}
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 		if (!aq_nic->macsec_cfg)
+ 			break;
+ 
+ 		memcpy(p, aq_macsec_stat_names, sizeof(aq_macsec_stat_names));
+ 		p = p + sizeof(aq_macsec_stat_names);
+ 		for (i = 0; i < AQ_MACSEC_MAX_SC; i++) {
+ 			struct aq_macsec_txsc *aq_txsc;
+ 
+ 			if (!(test_bit(i, &aq_nic->macsec_cfg->txsc_idx_busy)))
+ 				continue;
+ 
+ 			for (si = 0;
+ 				si < ARRAY_SIZE(aq_macsec_txsc_stat_names);
+ 				si++) {
+ 				snprintf(p, ETH_GSTRING_LEN,
+ 					 aq_macsec_txsc_stat_names[si], i);
+ 				p += ETH_GSTRING_LEN;
+ 			}
+ 			aq_txsc = &aq_nic->macsec_cfg->aq_txsc[i];
+ 			for (sa = 0; sa < MACSEC_NUM_AN; sa++) {
+ 				if (!(test_bit(sa, &aq_txsc->tx_sa_idx_busy)))
+ 					continue;
+ 				for (si = 0;
+ 				     si < ARRAY_SIZE(aq_macsec_txsa_stat_names);
+ 				     si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 						 aq_macsec_txsa_stat_names[si],
+ 						 i, sa);
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 			}
+ 		}
+ 		for (i = 0; i < AQ_MACSEC_MAX_SC; i++) {
+ 			struct aq_macsec_rxsc *aq_rxsc;
+ 
+ 			if (!(test_bit(i, &aq_nic->macsec_cfg->rxsc_idx_busy)))
+ 				continue;
+ 
+ 			aq_rxsc = &aq_nic->macsec_cfg->aq_rxsc[i];
+ 			for (sa = 0; sa < MACSEC_NUM_AN; sa++) {
+ 				if (!(test_bit(sa, &aq_rxsc->rx_sa_idx_busy)))
+ 					continue;
+ 				for (si = 0;
+ 				     si < ARRAY_SIZE(aq_macsec_rxsa_stat_names);
+ 				     si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 						 aq_macsec_rxsa_stat_names[si],
+ 						 i, sa);
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 			}
+ 		}
+ #endif
+ 		break;
+ 	case ETH_SS_PRIV_FLAGS:
+ 		memcpy(p, aq_ethtool_priv_flag_names,
+ 		       sizeof(aq_ethtool_priv_flag_names));
+ 		break;
++>>>>>>> aec0f1aac58e (net: atlantic: MACSec offload statistics implementation)
  	}
  }
  
  static int aq_ethtool_get_sset_count(struct net_device *ndev, int stringset)
  {
  	int ret = 0;
++<<<<<<< HEAD
 +	struct aq_nic_s *aq_nic = netdev_priv(ndev);
 +	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
++=======
++>>>>>>> aec0f1aac58e (net: atlantic: MACSec offload statistics implementation)
  
  	switch (stringset) {
  	case ETH_SS_STATS:
- 		ret = ARRAY_SIZE(aq_ethtool_stat_names) +
- 			cfg->vecs * ARRAY_SIZE(aq_ethtool_queue_stat_names);
+ 		ret = aq_ethtool_n_stats(ndev);
  		break;
 -	case ETH_SS_PRIV_FLAGS:
 -		ret = ARRAY_SIZE(aq_ethtool_priv_flag_names);
 -		break;
  	default:
  		ret = -EOPNOTSUPP;
  	}
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_macsec.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_macsec.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index d52c8833a137..cca33ab2e447 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@ -697,7 +697,7 @@ int aq_nic_get_regs_count(struct aq_nic_s *self)
 	return self->aq_nic_cfg.aq_hw_caps->mac_regs_count;
 }
 
-void aq_nic_get_stats(struct aq_nic_s *self, u64 *data)
+u64 *aq_nic_get_stats(struct aq_nic_s *self, u64 *data)
 {
 	unsigned int i = 0U;
 	unsigned int count = 0U;
@@ -747,7 +747,10 @@ void aq_nic_get_stats(struct aq_nic_s *self, u64 *data)
 		aq_vec_get_sw_stats(aq_vec, data, &count);
 	}
 
+	data += count;
+
 err_exit:;
+	return data;
 }
 
 static void aq_nic_update_ndev_stats(struct aq_nic_s *self)
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
index f6d04351e098..2d0824fa7402 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
@@ -131,7 +131,7 @@ int aq_nic_start(struct aq_nic_s *self);
 int aq_nic_xmit(struct aq_nic_s *self, struct sk_buff *skb);
 int aq_nic_get_regs(struct aq_nic_s *self, struct ethtool_regs *regs, void *p);
 int aq_nic_get_regs_count(struct aq_nic_s *self);
-void aq_nic_get_stats(struct aq_nic_s *self, u64 *data);
+u64 *aq_nic_get_stats(struct aq_nic_s *self, u64 *data);
 int aq_nic_stop(struct aq_nic_s *self);
 void aq_nic_deinit(struct aq_nic_s *self);
 void aq_nic_free_hot_resources(struct aq_nic_s *self);
