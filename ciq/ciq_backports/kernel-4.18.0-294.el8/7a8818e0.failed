powerpc/optprobes: Add register argument to patch_imm64_load_insns()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jordan Niethe <jniethe5@gmail.com>
commit 7a8818e0df5c6b53c89c7c928498668a2bbb3de0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7a8818e0.failed

Currently patch_imm32_load_insns() is used to load an instruction to
r4 to be emulated by emulate_step(). For prefixed instructions we
would like to be able to load a 64bit immediate to r4. To prepare for
this make patch_imm64_load_insns() take an argument that decides which
register to load an immediate to - rather than hardcoding r3.

	Signed-off-by: Jordan Niethe <jniethe5@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200516115449.4168796-1-mpe@ellerman.id.au
(cherry picked from commit 7a8818e0df5c6b53c89c7c928498668a2bbb3de0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/optprobes.c
diff --cc arch/powerpc/kernel/optprobes.c
index 8237884ca389,8eea8dbb93fa..000000000000
--- a/arch/powerpc/kernel/optprobes.c
+++ b/arch/powerpc/kernel/optprobes.c
@@@ -162,33 -162,38 +162,64 @@@ void patch_imm32_load_insns(unsigned in
  
  /*
   * Generate instructions to load provided immediate 64-bit value
-  * to register 'r3' and patch these instructions at 'addr'.
+  * to register 'reg' and patch these instructions at 'addr'.
   */
- void patch_imm64_load_insns(unsigned long val, kprobe_opcode_t *addr)
+ void patch_imm64_load_insns(unsigned long val, int reg, kprobe_opcode_t *addr)
  {
++<<<<<<< HEAD
 +	/* lis r3,(op)@highest */
 +	patch_instruction(addr, PPC_INST_ADDIS | ___PPC_RT(3) |
 +			  ((val >> 48) & 0xffff));
 +	addr++;
 +
 +	/* ori r3,r3,(op)@higher */
 +	patch_instruction(addr, PPC_INST_ORI | ___PPC_RA(3) |
 +			  ___PPC_RS(3) | ((val >> 32) & 0xffff));
 +	addr++;
 +
 +	/* rldicr r3,r3,32,31 */
 +	patch_instruction(addr, PPC_INST_RLDICR | ___PPC_RA(3) |
 +			  ___PPC_RS(3) | __PPC_SH64(32) | __PPC_ME64(31));
 +	addr++;
 +
 +	/* oris r3,r3,(op)@h */
 +	patch_instruction(addr, PPC_INST_ORIS | ___PPC_RA(3) |
 +			  ___PPC_RS(3) | ((val >> 16) & 0xffff));
 +	addr++;
 +
 +	/* ori r3,r3,(op)@l */
 +	patch_instruction(addr, PPC_INST_ORI | ___PPC_RA(3) |
 +			  ___PPC_RS(3) | (val & 0xffff));
++=======
+ 	/* lis reg,(op)@highest */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(reg) |
+ 				   ((val >> 48) & 0xffff)));
+ 	addr++;
+ 
+ 	/* ori reg,reg,(op)@higher */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |
+ 				   ___PPC_RS(reg) | ((val >> 32) & 0xffff)));
+ 	addr++;
+ 
+ 	/* rldicr reg,reg,32,31 */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_RLDICR | ___PPC_RA(reg) |
+ 				   ___PPC_RS(reg) | __PPC_SH64(32) | __PPC_ME64(31)));
+ 	addr++;
+ 
+ 	/* oris reg,reg,(op)@h */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ORIS | ___PPC_RA(reg) |
+ 				   ___PPC_RS(reg) | ((val >> 16) & 0xffff)));
+ 	addr++;
+ 
+ 	/* ori reg,reg,(op)@l */
+ 	patch_instruction((struct ppc_inst *)addr,
+ 			  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |
+ 				   ___PPC_RS(reg) | (val & 0xffff)));
++>>>>>>> 7a8818e0df5c (powerpc/optprobes: Add register argument to patch_imm64_load_insns())
  }
  
  int arch_prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)
* Unmerged path arch/powerpc/kernel/optprobes.c
