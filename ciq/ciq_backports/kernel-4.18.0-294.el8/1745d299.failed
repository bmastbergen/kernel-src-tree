driver core: Reevaluate dev->links.need_for_probe as suppliers are added

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 1745d299af5b373abad08fa29bff0d31dc6aff21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1745d299.failed

A previous patch 03324507e66c ("driver core: Allow
fwnode_operations.add_links to differentiate errors") forgot to update
all call sites to fwnode_operations.add_links. This patch fixes that.

Legend:
-> Denotes RHS is an optional/potential supplier for LHS
=> Denotes RHS is a mandatory supplier for LHS

Example:

Device A => Device X
Device A -> Device Y

Before this patch:
1. Device A is added.
2. Device A is marked as waiting for mandatory suppliers
3. Device X is added
4. Device A is left marked as waiting for mandatory suppliers

Step 4 is wrong since all mandatory suppliers of Device A have been
added.

After this patch:
1. Device A is added.
2. Device A is marked as waiting for mandatory suppliers
3. Device X is added
4. Device A is no longer considered as waiting for mandatory suppliers

This is the correct behavior.

Fixes: 03324507e66c ("driver core: Allow fwnode_operations.add_links to differentiate errors")
	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20200222014038.180923-2-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 1745d299af5b373abad08fa29bff0d31dc6aff21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
diff --cc drivers/base/core.c
index 8a0d36852b14,79863354c801..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -448,6 -465,74 +448,77 @@@ reorder
  }
  EXPORT_SYMBOL_GPL(device_link_add);
  
++<<<<<<< HEAD
++=======
+ /**
+  * device_link_wait_for_supplier - Add device to wait_for_suppliers list
+  * @consumer: Consumer device
+  *
+  * Marks the @consumer device as waiting for suppliers to become available by
+  * adding it to the wait_for_suppliers list. The consumer device will never be
+  * probed until it's removed from the wait_for_suppliers list.
+  *
+  * The caller is responsible for adding the links to the supplier devices once
+  * they are available and removing the @consumer device from the
+  * wait_for_suppliers list once links to all the suppliers have been created.
+  *
+  * This function is NOT meant to be called from the probe function of the
+  * consumer but rather from code that creates/adds the consumer device.
+  */
+ static void device_link_wait_for_supplier(struct device *consumer,
+ 					  bool need_for_probe)
+ {
+ 	mutex_lock(&wfs_lock);
+ 	list_add_tail(&consumer->links.needs_suppliers, &wait_for_suppliers);
+ 	consumer->links.need_for_probe = need_for_probe;
+ 	mutex_unlock(&wfs_lock);
+ }
+ 
+ static void device_link_wait_for_mandatory_supplier(struct device *consumer)
+ {
+ 	device_link_wait_for_supplier(consumer, true);
+ }
+ 
+ static void device_link_wait_for_optional_supplier(struct device *consumer)
+ {
+ 	device_link_wait_for_supplier(consumer, false);
+ }
+ 
+ /**
+  * device_link_add_missing_supplier_links - Add links from consumer devices to
+  *					    supplier devices, leaving any
+  *					    consumer with inactive suppliers on
+  *					    the wait_for_suppliers list
+  *
+  * Loops through all consumers waiting on suppliers and tries to add all their
+  * supplier links. If that succeeds, the consumer device is removed from
+  * wait_for_suppliers list. Otherwise, they are left in the wait_for_suppliers
+  * list.  Devices left on the wait_for_suppliers list will not be probed.
+  *
+  * The fwnode add_links callback is expected to return 0 if it has found and
+  * added all the supplier links for the consumer device. It should return an
+  * error if it isn't able to do so.
+  *
+  * The caller of device_link_wait_for_supplier() is expected to call this once
+  * it's aware of potential suppliers becoming available.
+  */
+ static void device_link_add_missing_supplier_links(void)
+ {
+ 	struct device *dev, *tmp;
+ 
+ 	mutex_lock(&wfs_lock);
+ 	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
+ 				 links.needs_suppliers) {
+ 		int ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+ 		if (!ret)
+ 			list_del_init(&dev->links.needs_suppliers);
+ 		else if (ret != -ENODEV)
+ 			dev->links.need_for_probe = false;
+ 	}
+ 	mutex_unlock(&wfs_lock);
+ }
+ 
++>>>>>>> 1745d299af5b (driver core: Reevaluate dev->links.need_for_probe as suppliers are added)
  static void device_link_free(struct device_link *link)
  {
  	while (refcount_dec_not_one(&link->rpm_active))
* Unmerged path drivers/base/core.c
