fuse: use ->reconfigure() instead of ->remount_fs()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 0189a2d367f49729622fdafaef5da73161591859
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0189a2d3.failed

s_op->remount_fs() is only called from legacy_reconfigure(), which is not
used after being converted to the new API.

Convert to using ->reconfigure().  This restores the previous behavior of
syncing the filesystem and rejecting MS_MANDLOCK on remount.

Fixes: c30da2e981a7 ("fuse: convert to use the new mount API")
	Cc: <stable@vger.kernel.org> # v5.4
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 0189a2d367f49729622fdafaef5da73161591859)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/inode.c
diff --cc fs/fuse/inode.c
index 10b75246113a,be39dff57c28..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -118,12 -115,18 +118,14 @@@ static void fuse_evict_inode(struct ino
  		fuse_queue_forget(fc, fi->forget, fi->nodeid, fi->nlookup);
  		fi->forget = NULL;
  	}
 -	if (S_ISREG(inode->i_mode) && !is_bad_inode(inode)) {
 -		WARN_ON(!list_empty(&fi->write_files));
 -		WARN_ON(!list_empty(&fi->queued_writes));
 -	}
  }
  
- static int fuse_remount_fs(struct super_block *sb, int *flags, char *data)
+ static int fuse_reconfigure(struct fs_context *fc)
  {
+ 	struct super_block *sb = fc->root->d_sb;
+ 
  	sync_filesystem(sb);
- 	if (*flags & SB_MANDLOCK)
+ 	if (fc->sb_flags & SB_MANDLOCK)
  		return -EINVAL;
  
  	return 0;
@@@ -1280,11 -1278,53 +1281,59 @@@ static int fuse_fill_super(struct super
  	return err;
  }
  
 -static int fuse_get_tree(struct fs_context *fc)
 +static struct dentry *fuse_mount(struct file_system_type *fs_type,
 +		       int flags, const char *dev_name,
 +		       void *raw_data)
  {
++<<<<<<< HEAD
 +	return mount_nodev(fs_type, flags, raw_data, fuse_fill_super);
++=======
+ 	struct fuse_fs_context *ctx = fc->fs_private;
+ 
+ 	if (!ctx->fd_present || !ctx->rootmode_present ||
+ 	    !ctx->user_id_present || !ctx->group_id_present)
+ 		return -EINVAL;
+ 
+ #ifdef CONFIG_BLOCK
+ 	if (ctx->is_bdev)
+ 		return get_tree_bdev(fc, fuse_fill_super);
+ #endif
+ 
+ 	return get_tree_nodev(fc, fuse_fill_super);
+ }
+ 
+ static const struct fs_context_operations fuse_context_ops = {
+ 	.free		= fuse_free_fc,
+ 	.parse_param	= fuse_parse_param,
+ 	.reconfigure	= fuse_reconfigure,
+ 	.get_tree	= fuse_get_tree,
+ };
+ 
+ /*
+  * Set up the filesystem mount context.
+  */
+ static int fuse_init_fs_context(struct fs_context *fc)
+ {
+ 	struct fuse_fs_context *ctx;
+ 
+ 	ctx = kzalloc(sizeof(struct fuse_fs_context), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	ctx->max_read = ~0;
+ 	ctx->blksize = FUSE_DEFAULT_BLKSIZE;
+ 
+ #ifdef CONFIG_BLOCK
+ 	if (fc->fs_type == &fuseblk_fs_type) {
+ 		ctx->is_bdev = true;
+ 		ctx->destroy = true;
+ 	}
+ #endif
+ 
+ 	fc->fs_private = ctx;
+ 	fc->ops = &fuse_context_ops;
+ 	return 0;
++>>>>>>> 0189a2d367f4 (fuse: use ->reconfigure() instead of ->remount_fs())
  }
  
  static void fuse_sb_destroy(struct super_block *sb)
* Unmerged path fs/fuse/inode.c
