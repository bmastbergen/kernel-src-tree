RDMA/mlx5: Process create QP flags in one place

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit 2978975ce7f16131ddf70468f0b189231e33086b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2978975c.failed

create_flags is checked in too many places and scattered across all
the code, consolidate all the checks inside one function, so we will
be easily see the flow. As part of such change, delete unreachable code,
because IB/core is responsible sanitize the input.

Link: https://lore.kernel.org/r/20200427154636.381474-15-leon@kernel.org
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 2978975ce7f16131ddf70468f0b189231e33086b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 745e3ea1cb8f,02eb03484b91..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -1161,10 -1159,8 +1153,13 @@@ static int create_kernel_qp(struct mlx5
  	MLX5_SET(qpc, qpc, fre, 1);
  	MLX5_SET(qpc, qpc, rlky, 1);
  
- 	if (init_attr->create_flags & MLX5_IB_QP_CREATE_SQPN_QP1) {
+ 	if (qp->flags & MLX5_IB_QP_CREATE_SQPN_QP1)
  		MLX5_SET(qpc, qpc, deth_sqpn, 1);
++<<<<<<< HEAD
 +		qp->flags |= MLX5_IB_QP_SQPN_QP1;
 +	}
++=======
++>>>>>>> 2978975ce7f1 (RDMA/mlx5: Process create QP flags in one place)
  
  	mlx5_fill_page_frag_array(&qp->buf,
  				  (__be64 *)MLX5_ADDR_OF(create_qp_in,
@@@ -1656,10 -1647,7 +1651,14 @@@ static int create_rss_raw_qp_tir(struc
  	size_t required_cmd_sz;
  	u8 lb_flag = 0;
  
++<<<<<<< HEAD
 +	if (init_attr->qp_type != IB_QPT_RAW_PACKET)
 +		return -EOPNOTSUPP;
 +
 +	if (init_attr->create_flags || init_attr->send_cq)
++=======
+ 	if (init_attr->send_cq)
++>>>>>>> 2978975ce7f1 (RDMA/mlx5: Process create QP flags in one place)
  		return -EINVAL;
  
  	min_resp_len = offsetof(typeof(resp), bfreg_index) + sizeof(resp.bfreg_index);
@@@ -1997,77 -1986,11 +1996,83 @@@ static int create_qp_common(struct mlx5
  	if (mlx5_st < 0)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (init_attr->rwq_ind_tbl) {
 +		if (!udata)
 +			return -ENOSYS;
 +
 +		err = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);
 +		return err;
 +	}
 +
 +	if (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {
 +		if (!MLX5_CAP_GEN(mdev, block_lb_mc)) {
 +			mlx5_ib_dbg(dev, "block multicast loopback isn't supported\n");
 +			return -EINVAL;
 +		} else {
 +			qp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;
 +		}
 +	}
 +
 +	if (init_attr->create_flags &
 +			(IB_QP_CREATE_CROSS_CHANNEL |
 +			 IB_QP_CREATE_MANAGED_SEND |
 +			 IB_QP_CREATE_MANAGED_RECV)) {
 +		if (!MLX5_CAP_GEN(mdev, cd)) {
 +			mlx5_ib_dbg(dev, "cross-channel isn't supported\n");
 +			return -EINVAL;
 +		}
 +		if (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)
 +			qp->flags |= MLX5_IB_QP_CROSS_CHANNEL;
 +		if (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)
 +			qp->flags |= MLX5_IB_QP_MANAGED_SEND;
 +		if (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)
 +			qp->flags |= MLX5_IB_QP_MANAGED_RECV;
 +	}
 +
 +	if (init_attr->qp_type == IB_QPT_UD &&
 +	    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))
 +		if (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {
 +			mlx5_ib_dbg(dev, "ipoib UD lso qp isn't supported\n");
 +			return -EOPNOTSUPP;
 +		}
 +
 +	if (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {
 +		if (init_attr->qp_type != IB_QPT_RAW_PACKET) {
 +			mlx5_ib_dbg(dev, "Scatter FCS is supported only for Raw Packet QPs");
 +			return -EOPNOTSUPP;
 +		}
 +		if (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||
 +		    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {
 +			mlx5_ib_dbg(dev, "Scatter FCS isn't supported\n");
 +			return -EOPNOTSUPP;
 +		}
 +		qp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;
 +	}
 +
 +	if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)
 +		qp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;
 +
 +	if (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {
 +		if (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&
 +		      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||
 +		    (init_attr->qp_type != IB_QPT_RAW_PACKET))
 +			return -EOPNOTSUPP;
 +		qp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;
 +	}
 +
++=======
+ 	if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)
+ 		qp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;
+ 
++>>>>>>> 2978975ce7f1 (RDMA/mlx5: Process create QP flags in one place)
  	if (udata) {
 -		if (!check_flags_mask(ucmd->flags,
 +		if (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {
 +			mlx5_ib_dbg(dev, "copy failed\n");
 +			return -EFAULT;
 +		}
 +
 +		if (!check_flags_mask(ucmd.flags,
  				      MLX5_QP_FLAG_ALLOW_SCATTER_CQE |
  				      MLX5_QP_FLAG_BFREG_INDEX |
  				      MLX5_QP_FLAG_PACKET_BASED_CREDIT_MODE |
@@@ -2119,27 -2043,17 +2124,33 @@@
  				mlx5_ib_dbg(dev, "packet based credit mode isn't supported\n");
  				return -EOPNOTSUPP;
  			}
 -			qp->flags_en |= MLX5_QP_FLAG_PACKET_BASED_CREDIT_MODE;
 +			qp->flags |= MLX5_IB_QP_PACKET_BASED_CREDIT;
  		}
++<<<<<<< HEAD
 +
 +		if (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {
 +			if (init_attr->qp_type != IB_QPT_UD ||
 +			    (MLX5_CAP_GEN(dev->mdev, port_type) !=
 +			     MLX5_CAP_PORT_TYPE_IB) ||
 +			    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {
 +				mlx5_ib_dbg(dev, "Source QP option isn't supported\n");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			qp->flags |= MLX5_IB_QP_UNDERLAY;
 +			qp->underlay_qpn = init_attr->source_qpn;
 +		}
++=======
++>>>>>>> 2978975ce7f1 (RDMA/mlx5: Process create QP flags in one place)
  	} else {
  		qp->wq_sig = !!wq_signature;
  	}
  
+ 	if (qp->flags & IB_QP_CREATE_SOURCE_QPN)
+ 		qp->underlay_qpn = init_attr->source_qpn;
+ 
  	base = (init_attr->qp_type == IB_QPT_RAW_PACKET ||
 -		qp->flags & IB_QP_CREATE_SOURCE_QPN) ?
 +		qp->flags & MLX5_IB_QP_UNDERLAY) ?
  	       &qp->raw_packet_qp.rq.base :
  	       &qp->trans_qp.base;
  
@@@ -2161,16 -2075,11 +2172,11 @@@
  				mlx5_ib_dbg(dev, "invalid rq params\n");
  				return -EINVAL;
  			}
 -			if (ucmd->sq_wqe_count > max_wqes) {
 +			if (ucmd.sq_wqe_count > max_wqes) {
  				mlx5_ib_dbg(dev, "requested sq_wqe_count (%d) > max allowed (%d)\n",
 -					    ucmd->sq_wqe_count, max_wqes);
 +					    ucmd.sq_wqe_count, max_wqes);
  				return -EINVAL;
  			}
- 			if (init_attr->create_flags &
- 			    MLX5_IB_QP_CREATE_SQPN_QP1) {
- 				mlx5_ib_dbg(dev, "user-space is not allowed to create UD QPs spoofing as QP1\n");
- 				return -EINVAL;
- 			}
  			err = create_user_qp(dev, pd, qp, udata, init_attr, &in,
  					     &resp, &inlen, base);
  			if (err)
@@@ -2288,23 -2195,15 +2294,32 @@@
  		MLX5_SET(qpc, qpc, user_index, uidx);
  
  	/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */
- 	if (init_attr->qp_type == IB_QPT_UD &&
- 	    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {
+ 	if (qp->flags & IB_QP_CREATE_IPOIB_UD_LSO)
  		MLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);
++<<<<<<< HEAD
 +		qp->flags |= MLX5_IB_QP_LSO;
 +	}
 +
 +	if (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {
 +		if (!MLX5_CAP_GEN(dev->mdev, end_pad)) {
 +			mlx5_ib_dbg(dev, "scatter end padding is not supported\n");
 +			err = -EOPNOTSUPP;
 +			goto err;
 +		} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {
 +			MLX5_SET(qpc, qpc, end_padding_mode,
 +				 MLX5_WQ_END_PAD_MODE_ALIGN);
 +		} else {
 +			qp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;
 +		}
++=======
+ 
+ 	if (qp->flags & IB_QP_CREATE_PCI_WRITE_END_PADDING &&
+ 	    init_attr->qp_type != IB_QPT_RAW_PACKET) {
+ 		MLX5_SET(qpc, qpc, end_padding_mode,
+ 			 MLX5_WQ_END_PAD_MODE_ALIGN);
+ 		/* Special case to clean flag */
+ 		qp->flags &= ~IB_QP_CREATE_PCI_WRITE_END_PADDING;
++>>>>>>> 2978975ce7f1 (RDMA/mlx5: Process create QP flags in one place)
  	}
  
  	if (inlen < 0) {
@@@ -2774,16 -2500,311 +2789,317 @@@ struct ib_qp *mlx5_ib_create_qp(struct 
  	case IB_QPT_RAW_ETHERTYPE:
  	case IB_QPT_MAX:
  	default:
++<<<<<<< HEAD
 +		mlx5_ib_dbg(dev, "unsupported qp type %d\n",
++=======
+ 		goto out;
+ 	}
+ 
+ 	return 0;
+ 
+ out:
+ 	mlx5_ib_dbg(dev, "Unsupported QP type %d\n", attr->qp_type);
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static int check_valid_flow(struct mlx5_ib_dev *dev, struct ib_pd *pd,
+ 			    struct ib_qp_init_attr *attr,
+ 			    struct ib_udata *udata)
+ {
+ 	struct mlx5_ib_ucontext *ucontext = rdma_udata_to_drv_context(
+ 		udata, struct mlx5_ib_ucontext, ibucontext);
+ 
+ 	if (!udata) {
+ 		/* Kernel create_qp callers */
+ 		if (attr->rwq_ind_tbl)
+ 			return -EOPNOTSUPP;
+ 
+ 		switch (attr->qp_type) {
+ 		case IB_QPT_RAW_PACKET:
+ 		case IB_QPT_DRIVER:
+ 			return -EOPNOTSUPP;
+ 		default:
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	/* Userspace create_qp callers */
+ 	if (attr->qp_type == IB_QPT_RAW_PACKET && !ucontext->cqe_version) {
+ 		mlx5_ib_dbg(dev,
+ 			"Raw Packet QP is only supported for CQE version > 0\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (attr->qp_type != IB_QPT_RAW_PACKET && attr->rwq_ind_tbl) {
+ 		mlx5_ib_dbg(dev,
+ 			    "Wrong QP type %d for the RWQ indirect table\n",
+ 			    attr->qp_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (attr->qp_type) {
+ 	case IB_QPT_SMI:
+ 	case MLX5_IB_QPT_HW_GSI:
+ 	case MLX5_IB_QPT_REG_UMR:
+ 	case IB_QPT_GSI:
+ 		mlx5_ib_dbg(dev, "Kernel doesn't support QP type %d\n",
+ 			    attr->qp_type);
+ 		return -EINVAL;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	/*
+ 	 * We don't need to see this warning, it means that kernel code
+ 	 * missing ib_pd. Placed here to catch developer's mistakes.
+ 	 */
+ 	WARN_ONCE(!pd && attr->qp_type != IB_QPT_XRC_TGT,
+ 		  "There is a missing PD pointer assignment\n");
+ 	return 0;
+ }
+ 
+ static int process_vendor_flags(struct mlx5_ib_qp *qp,
+ 				struct ib_qp_init_attr *attr,
+ 				struct mlx5_ib_create_qp *ucmd)
+ {
+ 	switch (ucmd->flags & (MLX5_QP_FLAG_TYPE_DCT | MLX5_QP_FLAG_TYPE_DCI)) {
+ 	case MLX5_QP_FLAG_TYPE_DCI:
+ 		qp->qp_sub_type = MLX5_IB_QPT_DCI;
+ 		break;
+ 	case MLX5_QP_FLAG_TYPE_DCT:
+ 		qp->qp_sub_type = MLX5_IB_QPT_DCT;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void process_create_flag(struct mlx5_ib_dev *dev, int *flags, int flag,
+ 				bool cond, struct mlx5_ib_qp *qp)
+ {
+ 	if (!(*flags & flag))
+ 		return;
+ 
+ 	if (cond) {
+ 		qp->flags |= flag;
+ 		*flags &= ~flag;
+ 		return;
+ 	}
+ 
+ 	if (flag == MLX5_IB_QP_CREATE_WC_TEST) {
+ 		/*
+ 		 * Special case, if condition didn't meet, it won't be error,
+ 		 * just different in-kernel flow.
+ 		 */
+ 		*flags &= ~MLX5_IB_QP_CREATE_WC_TEST;
+ 		return;
+ 	}
+ 	mlx5_ib_dbg(dev, "Verbs create QP flag 0x%X is not supported\n", flag);
+ }
+ 
+ static int process_create_flags(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,
+ 				struct ib_qp_init_attr *attr)
+ {
+ 	enum ib_qp_type qp_type = attr->qp_type;
+ 	struct mlx5_core_dev *mdev = dev->mdev;
+ 	int create_flags = attr->create_flags;
+ 	bool cond;
+ 
+ 	if (qp->qp_sub_type == MLX5_IB_QPT_DCT)
+ 		return (create_flags) ? -EINVAL : 0;
+ 
+ 	if (qp_type == IB_QPT_RAW_PACKET && attr->rwq_ind_tbl)
+ 		return (create_flags) ? -EINVAL : 0;
+ 
+ 	process_create_flag(dev, &create_flags,
+ 			    IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK,
+ 			    MLX5_CAP_GEN(mdev, block_lb_mc), qp);
+ 	process_create_flag(dev, &create_flags, IB_QP_CREATE_CROSS_CHANNEL,
+ 			    MLX5_CAP_GEN(mdev, cd), qp);
+ 	process_create_flag(dev, &create_flags, IB_QP_CREATE_MANAGED_SEND,
+ 			    MLX5_CAP_GEN(mdev, cd), qp);
+ 	process_create_flag(dev, &create_flags, IB_QP_CREATE_MANAGED_RECV,
+ 			    MLX5_CAP_GEN(mdev, cd), qp);
+ 
+ 	if (qp_type == IB_QPT_UD) {
+ 		process_create_flag(dev, &create_flags,
+ 				    IB_QP_CREATE_IPOIB_UD_LSO,
+ 				    MLX5_CAP_GEN(mdev, ipoib_basic_offloads),
+ 				    qp);
+ 		cond = MLX5_CAP_GEN(mdev, port_type) == MLX5_CAP_PORT_TYPE_IB;
+ 		process_create_flag(dev, &create_flags, IB_QP_CREATE_SOURCE_QPN,
+ 				    cond, qp);
+ 	}
+ 
+ 	if (qp_type == IB_QPT_RAW_PACKET) {
+ 		cond = MLX5_CAP_GEN(mdev, eth_net_offloads) &&
+ 		       MLX5_CAP_ETH(mdev, scatter_fcs);
+ 		process_create_flag(dev, &create_flags,
+ 				    IB_QP_CREATE_SCATTER_FCS, cond, qp);
+ 
+ 		cond = MLX5_CAP_GEN(mdev, eth_net_offloads) &&
+ 		       MLX5_CAP_ETH(mdev, vlan_cap);
+ 		process_create_flag(dev, &create_flags,
+ 				    IB_QP_CREATE_CVLAN_STRIPPING, cond, qp);
+ 	}
+ 
+ 	process_create_flag(dev, &create_flags,
+ 			    IB_QP_CREATE_PCI_WRITE_END_PADDING,
+ 			    MLX5_CAP_GEN(mdev, end_pad), qp);
+ 
+ 	process_create_flag(dev, &create_flags, MLX5_IB_QP_CREATE_WC_TEST,
+ 			    qp_type != MLX5_IB_QPT_REG_UMR, qp);
+ 	process_create_flag(dev, &create_flags, MLX5_IB_QP_CREATE_SQPN_QP1,
+ 			    true, qp);
+ 
+ 	if (create_flags)
+ 		mlx5_ib_dbg(dev, "Create QP has unsupported flags 0x%X\n",
+ 			    create_flags);
+ 
+ 	return (create_flags) ? -EINVAL : 0;
+ }
+ 
+ static int create_driver_qp(struct ib_pd *pd, struct mlx5_ib_qp *qp,
+ 			    struct ib_qp_init_attr *attr,
+ 			    struct mlx5_ib_create_qp *ucmd,
+ 			    struct ib_udata *udata)
+ {
+ 	struct mlx5_ib_dev *mdev = to_mdev(pd->device);
+ 	int ret = -EINVAL;
+ 
+ 	switch (qp->qp_sub_type) {
+ 	case MLX5_IB_QPT_DCT:
+ 		if (!attr->srq || !attr->recv_cq)
+ 			goto out;
+ 
+ 		ret = create_dct(pd, qp, attr, ucmd, udata);
+ 		break;
+ 	case MLX5_IB_QPT_DCI:
+ 		if (attr->cap.max_recv_wr || attr->cap.max_recv_sge)
+ 			goto out;
+ 
+ 		ret = create_qp_common(mdev, pd, attr, ucmd, udata, qp);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ out:	return ret;
+ }
+ 
+ static size_t process_udata_size(struct ib_qp_init_attr *attr,
+ 				 struct ib_udata *udata)
+ {
+ 	size_t ucmd = sizeof(struct mlx5_ib_create_qp);
+ 
+ 	if (attr->qp_type == IB_QPT_DRIVER)
+ 		return (udata->inlen < ucmd) ? 0 : ucmd;
+ 
+ 	return ucmd;
+ }
+ 
+ static int create_raw_qp(struct ib_pd *pd, struct mlx5_ib_qp *qp,
+ 			 struct ib_qp_init_attr *attr,
+ 			 struct mlx5_ib_create_qp *ucmd, struct ib_udata *udata)
+ {
+ 	struct mlx5_ib_dev *dev = to_mdev(pd->device);
+ 
+ 	if (attr->rwq_ind_tbl)
+ 		return create_rss_raw_qp_tir(pd, qp, attr, udata);
+ 
+ 	return create_qp_common(dev, pd, attr, ucmd, udata, qp);
+ }
+ 
+ struct ib_qp *mlx5_ib_create_qp(struct ib_pd *pd,
+ 				struct ib_qp_init_attr *init_attr,
+ 				struct ib_udata *udata)
+ {
+ 	struct mlx5_ib_create_qp ucmd = {};
+ 	struct mlx5_ib_dev *dev;
+ 	struct mlx5_ib_qp *qp;
+ 	u16 xrcdn = 0;
+ 	int err;
+ 
+ 	dev = pd ? to_mdev(pd->device) :
+ 		   to_mdev(to_mxrcd(init_attr->xrcd)->ibxrcd.device);
+ 
+ 	err = check_qp_type(dev, init_attr);
+ 	if (err) {
+ 		mlx5_ib_dbg(dev, "Unsupported QP type %d\n",
++>>>>>>> 2978975ce7f1 (RDMA/mlx5: Process create QP flags in one place)
  			    init_attr->qp_type);
 -		return ERR_PTR(err);
 +		/* Don't support raw QPs */
 +		return ERR_PTR(-EINVAL);
  	}
  
++<<<<<<< HEAD
 +	if (verbs_init_attr->qp_type == IB_QPT_DRIVER)
 +		qp->qp_sub_type = init_attr->qp_type;
++=======
+ 	err = check_valid_flow(dev, pd, init_attr, udata);
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	if (init_attr->qp_type == IB_QPT_GSI)
+ 		return mlx5_ib_gsi_create_qp(pd, init_attr);
+ 
+ 	if (udata && !init_attr->rwq_ind_tbl) {
+ 		size_t inlen =
+ 			process_udata_size(init_attr, udata);
+ 
+ 		if (!inlen)
+ 			return ERR_PTR(-EINVAL);
+ 
+ 		err = ib_copy_from_udata(&ucmd, udata, inlen);
+ 		if (err)
+ 			return ERR_PTR(err);
+ 	}
+ 
+ 	qp = kzalloc(sizeof(*qp), GFP_KERNEL);
+ 	if (!qp)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (init_attr->qp_type == IB_QPT_DRIVER) {
+ 		err = process_vendor_flags(qp, init_attr, &ucmd);
+ 		if (err)
+ 			goto free_qp;
+ 	}
+ 	err = process_create_flags(dev, qp, init_attr);
+ 	if (err)
+ 		goto free_qp;
+ 
+ 	if (init_attr->qp_type == IB_QPT_XRC_TGT)
+ 		xrcdn = to_mxrcd(init_attr->xrcd)->xrcdn;
+ 
+ 	switch (init_attr->qp_type) {
+ 	case IB_QPT_DRIVER:
+ 		err = create_driver_qp(pd, qp, init_attr, &ucmd, udata);
+ 		break;
+ 	case IB_QPT_RAW_PACKET:
+ 		err = create_raw_qp(pd, qp, init_attr, &ucmd, udata);
+ 		break;
+ 	default:
+ 		err = create_qp_common(dev, pd, init_attr,
+ 				       (udata) ? &ucmd : NULL, udata, qp);
+ 	}
+ 	if (err) {
+ 		mlx5_ib_dbg(dev, "create_qp_common failed\n");
+ 		goto free_qp;
+ 	}
+ 
+ 	if (is_qp0(init_attr->qp_type))
+ 		qp->ibqp.qp_num = 0;
+ 	else if (is_qp1(init_attr->qp_type))
+ 		qp->ibqp.qp_num = 1;
+ 	else
+ 		qp->ibqp.qp_num = qp->trans_qp.base.mqp.qpn;
+ 
+ 	qp->trans_qp.xrcdn = xrcdn;
++>>>>>>> 2978975ce7f1 (RDMA/mlx5: Process create QP flags in one place)
  
  	return &qp->ibqp;
 -
 -free_qp:
 -	kfree(qp);
 -	return ERR_PTR(err);
  }
  
  static int mlx5_ib_destroy_dct(struct mlx5_ib_qp *mqp)
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
