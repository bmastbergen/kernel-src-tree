introduce cloning of fs_context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 0b52075ee62301dd150c9f2c3ddd0035ed894cde
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0b52075e.failed

new primitive: vfs_dup_fs_context().  Comes with fs_context
method (->dup()) for copying the filesystem-specific parts
of fs_context, along with LSM one (->fs_context_dup()) for
doing the same to LSM parts.

[needs better commit message, and change of Author:, anyway]

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 0b52075ee62301dd150c9f2c3ddd0035ed894cde)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs_context.c
#	include/linux/fs_context.h
#	security/selinux/hooks.c
#	security/smack/smack_lsm.c
diff --cc security/selinux/hooks.c
index 42145010da10,4ba83de5fa80..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -2874,6 -2764,76 +2874,79 @@@ static int selinux_umount(struct vfsmou
  				   FILESYSTEM__UNMOUNT, NULL);
  }
  
++<<<<<<< HEAD
++=======
+ static int selinux_fs_context_dup(struct fs_context *fc,
+ 				  struct fs_context *src_fc)
+ {
+ 	const struct selinux_mnt_opts *src = src_fc->security;
+ 	struct selinux_mnt_opts *opts;
+ 
+ 	if (!src)
+ 		return 0;
+ 
+ 	fc->security = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);
+ 	if (!fc->security)
+ 		return -ENOMEM;
+ 
+ 	opts = fc->security;
+ 
+ 	if (src->fscontext) {
+ 		opts->fscontext = kstrdup(src->fscontext, GFP_KERNEL);
+ 		if (!opts->fscontext)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->context) {
+ 		opts->context = kstrdup(src->context, GFP_KERNEL);
+ 		if (!opts->context)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->rootcontext) {
+ 		opts->rootcontext = kstrdup(src->rootcontext, GFP_KERNEL);
+ 		if (!opts->rootcontext)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->defcontext) {
+ 		opts->defcontext = kstrdup(src->defcontext, GFP_KERNEL);
+ 		if (!opts->defcontext)
+ 			return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct fs_parameter_spec selinux_param_specs[] = {
+ 	fsparam_string(CONTEXT_STR,	Opt_context),
+ 	fsparam_string(DEFCONTEXT_STR,	Opt_defcontext),
+ 	fsparam_string(FSCONTEXT_STR,	Opt_fscontext),
+ 	fsparam_string(ROOTCONTEXT_STR,	Opt_rootcontext),
+ 	fsparam_flag  (SECLABEL_STR,	Opt_seclabel),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description selinux_fs_parameters = {
+ 	.name		= "SELinux",
+ 	.specs		= selinux_param_specs,
+ };
+ 
+ static int selinux_fs_context_parse_param(struct fs_context *fc,
+ 					  struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	int opt, rc;
+ 
+ 	opt = fs_parse(fc, &selinux_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	rc = selinux_add_opt(opt, param->string, &fc->security);
+ 	if (!rc) {
+ 		param->string = NULL;
+ 		rc = 1;
+ 	}
+ 	return rc;
+ }
+ 
++>>>>>>> 0b52075ee623 (introduce cloning of fs_context)
  /* inode security operations */
  
  static int selinux_inode_alloc_security(struct inode *inode)
@@@ -6952,8 -6783,13 +7025,15 @@@ static struct security_hook_list selinu
  	LSM_HOOK_INIT(bprm_committing_creds, selinux_bprm_committing_creds),
  	LSM_HOOK_INIT(bprm_committed_creds, selinux_bprm_committed_creds),
  
++<<<<<<< HEAD
++=======
+ 	LSM_HOOK_INIT(fs_context_dup, selinux_fs_context_dup),
+ 	LSM_HOOK_INIT(fs_context_parse_param, selinux_fs_context_parse_param),
+ 
+ 	LSM_HOOK_INIT(sb_alloc_security, selinux_sb_alloc_security),
++>>>>>>> 0b52075ee623 (introduce cloning of fs_context)
  	LSM_HOOK_INIT(sb_free_security, selinux_sb_free_security),
 -	LSM_HOOK_INIT(sb_eat_lsm_opts, selinux_sb_eat_lsm_opts),
 -	LSM_HOOK_INIT(sb_free_mnt_opts, selinux_free_mnt_opts),
 +	LSM_HOOK_INIT(sb_copy_data, selinux_sb_copy_data),
  	LSM_HOOK_INIT(sb_remount, selinux_sb_remount),
  	LSM_HOOK_INIT(sb_kern_mount, selinux_sb_kern_mount),
  	LSM_HOOK_INIT(sb_show_options, selinux_sb_show_options),
diff --cc security/smack/smack_lsm.c
index 77b0bfb018e5,03176f600a87..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -723,15 -643,93 +723,101 @@@ static int smack_parse_opts_str(char *o
  	return 0;
  
  out_opt_err:
 +	rc = -EINVAL;
  	pr_warn("Smack: duplicate mount options\n");
 -	return -EINVAL;
 -}
  
++<<<<<<< HEAD
 +out_err:
 +	kfree(fsdefault);
 +	kfree(fsfloor);
 +	kfree(fshat);
 +	kfree(fsroot);
 +	kfree(fstransmute);
++=======
+ /**
+  * smack_fs_context_dup - Duplicate the security data on fs_context duplication
+  * @fc: The new filesystem context.
+  * @src_fc: The source filesystem context being duplicated.
+  *
+  * Returns 0 on success or -ENOMEM on error.
+  */
+ static int smack_fs_context_dup(struct fs_context *fc,
+ 				struct fs_context *src_fc)
+ {
+ 	struct smack_mnt_opts *dst, *src = src_fc->security;
+ 
+ 	if (!src)
+ 		return 0;
+ 
+ 	fc->security = kzalloc(sizeof(struct smack_mnt_opts), GFP_KERNEL);
+ 	if (!fc->security)
+ 		return -ENOMEM;
+ 	dst = fc->security;
+ 
+ 	if (src->fsdefault) {
+ 		dst->fsdefault = kstrdup(src->fsdefault, GFP_KERNEL);
+ 		if (!dst->fsdefault)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fsfloor) {
+ 		dst->fsfloor = kstrdup(src->fsfloor, GFP_KERNEL);
+ 		if (!dst->fsfloor)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fshat) {
+ 		dst->fshat = kstrdup(src->fshat, GFP_KERNEL);
+ 		if (!dst->fshat)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fsroot) {
+ 		dst->fsroot = kstrdup(src->fsroot, GFP_KERNEL);
+ 		if (!dst->fsroot)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fstransmute) {
+ 		dst->fstransmute = kstrdup(src->fstransmute, GFP_KERNEL);
+ 		if (!dst->fstransmute)
+ 			return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct fs_parameter_spec smack_param_specs[] = {
+ 	fsparam_string("fsdefault",	Opt_fsdefault),
+ 	fsparam_string("fsfloor",	Opt_fsfloor),
+ 	fsparam_string("fshat",		Opt_fshat),
+ 	fsparam_string("fsroot",	Opt_fsroot),
+ 	fsparam_string("fstransmute",	Opt_fstransmute),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description smack_fs_parameters = {
+ 	.name		= "smack",
+ 	.specs		= smack_param_specs,
+ };
+ 
+ /**
+  * smack_fs_context_parse_param - Parse a single mount parameter
+  * @fc: The new filesystem context being constructed.
+  * @param: The parameter.
+  *
+  * Returns 0 on success, -ENOPARAM to pass the parameter on or anything else on
+  * error.
+  */
+ static int smack_fs_context_parse_param(struct fs_context *fc,
+ 					struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	int opt, rc;
+ 
+ 	opt = fs_parse(fc, &smack_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	rc = smack_add_opt(opt, param->string, &fc->security);
+ 	if (!rc)
+ 		param->string = NULL;
++>>>>>>> 0b52075ee623 (introduce cloning of fs_context)
  	return rc;
  }
  
@@@ -4629,13 -4674,15 +4715,19 @@@ static struct security_hook_list smack_
  	LSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),
  	LSM_HOOK_INIT(syslog, smack_syslog),
  
++<<<<<<< HEAD
++=======
+ 	LSM_HOOK_INIT(fs_context_dup, smack_fs_context_dup),
+ 	LSM_HOOK_INIT(fs_context_parse_param, smack_fs_context_parse_param),
+ 
++>>>>>>> 0b52075ee623 (introduce cloning of fs_context)
  	LSM_HOOK_INIT(sb_alloc_security, smack_sb_alloc_security),
  	LSM_HOOK_INIT(sb_free_security, smack_sb_free_security),
 -	LSM_HOOK_INIT(sb_free_mnt_opts, smack_free_mnt_opts),
 -	LSM_HOOK_INIT(sb_eat_lsm_opts, smack_sb_eat_lsm_opts),
 +	LSM_HOOK_INIT(sb_copy_data, smack_sb_copy_data),
 +	LSM_HOOK_INIT(sb_kern_mount, smack_sb_kern_mount),
  	LSM_HOOK_INIT(sb_statfs, smack_sb_statfs),
  	LSM_HOOK_INIT(sb_set_mnt_opts, smack_set_mnt_opts),
 +	LSM_HOOK_INIT(sb_parse_opts_str, smack_parse_opts_str),
  
  	LSM_HOOK_INIT(bprm_set_creds, smack_bprm_set_creds),
  
* Unmerged path fs/fs_context.c
* Unmerged path include/linux/fs_context.h
* Unmerged path fs/fs_context.c
* Unmerged path include/linux/fs_context.h
diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h
index bb664d716fe6..e1bdca825556 100644
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@ -79,6 +79,11 @@
  * Security hooks for mount using fs_context.
  *	[See also Documentation/filesystems/mounting.txt]
  *
+ * @fs_context_dup:
+ *	Allocate and attach a security structure to sc->security.  This pointer
+ *	is initialised to NULL by the caller.
+ *	@fc indicates the new filesystem context.
+ *	@src_fc indicates the original filesystem context.
  * @fs_context_parse_param:
  *	Userspace provided a parameter to configure a superblock.  The LSM may
  *	reject it with an error and may use it for itself, in which case it
@@ -1480,6 +1485,7 @@ union security_list_options {
 	void (*bprm_committing_creds)(struct linux_binprm *bprm);
 	void (*bprm_committed_creds)(struct linux_binprm *bprm);
 
+	int (*fs_context_dup)(struct fs_context *fc, struct fs_context *src_sc);
 	int (*fs_context_parse_param)(struct fs_context *fc, struct fs_parameter *param);
 
 	int (*sb_alloc_security)(struct super_block *sb);
@@ -1825,6 +1831,7 @@ struct security_hook_heads {
 	struct hlist_head bprm_check_security;
 	struct hlist_head bprm_committing_creds;
 	struct hlist_head bprm_committed_creds;
+	struct hlist_head fs_context_dup;
 	struct hlist_head fs_context_parse_param;
 	struct hlist_head sb_alloc_security;
 	struct hlist_head sb_free_security;
diff --git a/include/linux/security.h b/include/linux/security.h
index ea494663ce29..6bc3a4e46627 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -247,6 +247,7 @@ int security_bprm_set_creds(struct linux_binprm *bprm);
 int security_bprm_check(struct linux_binprm *bprm);
 void security_bprm_committing_creds(struct linux_binprm *bprm);
 void security_bprm_committed_creds(struct linux_binprm *bprm);
+int security_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc);
 int security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param);
 int security_sb_alloc(struct super_block *sb);
 void security_sb_free(struct super_block *sb);
@@ -547,6 +548,11 @@ static inline void security_bprm_committed_creds(struct linux_binprm *bprm)
 {
 }
 
+static inline int security_fs_context_dup(struct fs_context *fc,
+					  struct fs_context *src_fc)
+{
+	return 0;
+}
 static inline int security_fs_context_parse_param(struct fs_context *fc,
 						  struct fs_parameter *param)
 {
diff --git a/security/security.c b/security/security.c
index def81deae1f8..7f1e911547a9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -357,6 +357,11 @@ void security_bprm_committed_creds(struct linux_binprm *bprm)
 	call_void_hook(bprm_committed_creds, bprm);
 }
 
+int security_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)
+{
+	return call_int_hook(fs_context_dup, 0, fc, src_fc);
+}
+
 int security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param)
 {
 	return call_int_hook(fs_context_parse_param, -ENOPARAM, fc, param);
* Unmerged path security/selinux/hooks.c
* Unmerged path security/smack/smack_lsm.c
