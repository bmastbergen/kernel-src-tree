x86/platform/uv: Add and decode Arch Type in UVsystab

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mike Travis <mike.travis@hpe.com>
commit 1e61f5a95f1913c015a2d6a1544c108248b3971c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1e61f5a9.failed

When the UV BIOS starts the kernel it passes the UVsystab info struct to
the kernel which contains information elements more specific than ACPI,
and generally pertinent only to the MMRs. These are read only fields
so information is passed one way only. A new field starting with UV5 is
the UV architecture type so the ACPI OEM_ID field can be used for other
purposes going forward. The UV Arch Type selects the entirety of the
MMRs available, with their addresses and fields defined in uv_mmrs.h.

	Reported-by: kernel test robot <lkp@intel.com>
	Signed-off-by: Mike Travis <mike.travis@hpe.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Dimitri Sivanich <dimitri.sivanich@hpe.com>
	Reviewed-by: Steve Wahl <steve.wahl@hpe.com>
Link: https://lkml.kernel.org/r/20201005203929.148656-7-mike.travis@hpe.com
(cherry picked from commit 1e61f5a95f1913c015a2d6a1544c108248b3971c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/uv/bios.h
#	arch/x86/platform/uv/bios_uv.c
diff --cc arch/x86/include/asm/uv/bios.h
index aa4eca8f04e7,97ac595ebc6a..000000000000
--- a/arch/x86/include/asm/uv/bios.h
+++ b/arch/x86/include/asm/uv/bios.h
@@@ -4,22 -5,8 +4,27 @@@
  /*
   * UV BIOS layer definitions.
   *
++<<<<<<< HEAD
 + *  This program is free software; you can redistribute it and/or modify
 + *  it under the terms of the GNU General Public License as published by
 + *  the Free Software Foundation; either version 2 of the License, or
 + *  (at your option) any later version.
 + *
 + *  This program is distributed in the hope that it will be useful,
 + *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 + *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 + *  GNU General Public License for more details.
 + *
 + *  You should have received a copy of the GNU General Public License
 + *  along with this program; if not, write to the Free Software
 + *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 + *
 + *  Copyright (c) 2008-2009 Silicon Graphics, Inc.  All Rights Reserved.
 + *  Copyright (c) Russ Anderson <rja@sgi.com>
++=======
+  * Copyright (C) 2007-2017 Silicon Graphics, Inc. All rights reserved.
+  * Copyright (c) Russ Anderson <rja@sgi.com>
++>>>>>>> 1e61f5a95f19 (x86/platform/uv: Add and decode Arch Type in UVsystab)
   */
  
  #include <linux/rtc.h>
@@@ -145,11 -141,8 +159,15 @@@ extern s64 uv_bios_change_memprotect(u6
  extern s64 uv_bios_reserved_page_pa(u64, u64 *, u64 *, u64 *);
  extern int uv_bios_set_legacy_vga_target(bool decode, int domain, int bus);
  
 +#ifdef CONFIG_EFI
  extern int uv_bios_init(void);
++<<<<<<< HEAD
 +#else
 +void uv_bios_init(void) { }
 +#endif
++=======
+ extern unsigned long get_uv_systab_phys(bool msg);
++>>>>>>> 1e61f5a95f19 (x86/platform/uv: Add and decode Arch Type in UVsystab)
  
  extern unsigned long sn_rtc_cycles_per_second;
  extern int uv_type;
diff --cc arch/x86/platform/uv/bios_uv.c
index 6fbaf03c6d74,b148b4c8c2ec..000000000000
--- a/arch/x86/platform/uv/bios_uv.c
+++ b/arch/x86/platform/uv/bios_uv.c
@@@ -1,22 -1,9 +1,27 @@@
  /*
   * BIOS run time interface routines.
   *
++<<<<<<< HEAD
 + *  This program is free software; you can redistribute it and/or modify
 + *  it under the terms of the GNU General Public License as published by
 + *  the Free Software Foundation; either version 2 of the License, or
 + *  (at your option) any later version.
 + *
 + *  This program is distributed in the hope that it will be useful,
 + *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 + *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 + *  GNU General Public License for more details.
 + *
 + *  You should have received a copy of the GNU General Public License
 + *  along with this program; if not, write to the Free Software
 + *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 + *
 + *  Copyright (c) 2008-2009 Silicon Graphics, Inc.  All Rights Reserved.
 + *  Copyright (c) Russ Anderson <rja@sgi.com>
++=======
+  * Copyright (C) 2007-2017 Silicon Graphics, Inc. All rights reserved.
+  * Copyright (c) Russ Anderson <rja@sgi.com>
++>>>>>>> 1e61f5a95f19 (x86/platform/uv: Add and decode Arch Type in UVsystab)
   */
  
  #include <linux/efi.h>
@@@ -190,17 -170,27 +195,42 @@@ int uv_bios_set_legacy_vga_target(bool 
  				(u64)decode, (u64)domain, (u64)bus, 0, 0);
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_EFI
 +int uv_bios_init(void)
 +{
 +	uv_systab = NULL;
 +	if ((efi.uv_systab == EFI_INVALID_TABLE_ADDR) ||
 +	    !efi.uv_systab || efi_runtime_disabled()) {
 +		pr_crit("UV: UVsystab: missing\n");
 +		return -EEXIST;
++=======
+ unsigned long get_uv_systab_phys(bool msg)
+ {
+ 	if ((uv_systab_phys == EFI_INVALID_TABLE_ADDR) ||
+ 	    !uv_systab_phys || efi_runtime_disabled()) {
+ 		if (msg)
+ 			pr_crit("UV: UVsystab: missing\n");
+ 		return 0;
++>>>>>>> 1e61f5a95f19 (x86/platform/uv: Add and decode Arch Type in UVsystab)
  	}
+ 	return uv_systab_phys;
+ }
  
++<<<<<<< HEAD
 +	uv_systab = ioremap(efi.uv_systab, sizeof(struct uv_systab));
++=======
+ int uv_bios_init(void)
+ {
+ 	unsigned long uv_systab_phys_addr;
+ 
+ 	uv_systab = NULL;
+ 	uv_systab_phys_addr = get_uv_systab_phys(1);
+ 	if (!uv_systab_phys_addr)
+ 		return -EEXIST;
+ 
+ 	uv_systab = ioremap(uv_systab_phys_addr, sizeof(struct uv_systab));
++>>>>>>> 1e61f5a95f19 (x86/platform/uv: Add and decode Arch Type in UVsystab)
  	if (!uv_systab || strncmp(uv_systab->signature, UV_SYSTAB_SIG, 4)) {
  		pr_err("UV: UVsystab: bad signature!\n");
  		iounmap(uv_systab);
@@@ -212,7 -202,7 +242,11 @@@
  		int size = uv_systab->size;
  
  		iounmap(uv_systab);
++<<<<<<< HEAD
 +		uv_systab = ioremap(efi.uv_systab, size);
++=======
+ 		uv_systab = ioremap(uv_systab_phys_addr, size);
++>>>>>>> 1e61f5a95f19 (x86/platform/uv: Add and decode Arch Type in UVsystab)
  		if (!uv_systab) {
  			pr_err("UV: UVsystab: ioremap(%d) failed!\n", size);
  			return -EFAULT;
* Unmerged path arch/x86/include/asm/uv/bios.h
diff --git a/arch/x86/kernel/apic/x2apic_uv_x.c b/arch/x86/kernel/apic/x2apic_uv_x.c
index 13dd333a697a..7dacb10a8045 100644
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@ -50,7 +50,8 @@ static u64			gru_start_paddr, gru_end_paddr;
 static union uvh_apicid		uvh_apicid;
 static int			uv_node_id;
 
-/* Unpack OEM/TABLE ID's to be NULL terminated strings */
+/* Unpack AT/OEM/TABLE ID's to be NULL terminated strings */
+static u8 uv_archtype[UV_AT_SIZE];
 static u8 oem_id[ACPI_OEM_ID_SIZE + 1];
 static u8 oem_table_id[ACPI_OEM_TABLE_ID_SIZE + 1];
 
@@ -303,18 +304,102 @@ static void __init uv_stringify(int len, char *to, char *from)
 	strncpy(to, from, len-1);
 }
 
+/* Find UV arch type entry in UVsystab */
+static unsigned long __init early_find_archtype(struct uv_systab *st)
+{
+	int i;
+
+	for (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {
+		unsigned long ptr = st->entry[i].offset;
+
+		if (!ptr)
+			continue;
+		ptr += (unsigned long)st;
+		if (st->entry[i].type == UV_SYSTAB_TYPE_ARCH_TYPE)
+			return ptr;
+	}
+	return 0;
+}
+
+/* Validate UV arch type field in UVsystab */
+static int __init decode_arch_type(unsigned long ptr)
+{
+	struct uv_arch_type_entry *uv_ate = (struct uv_arch_type_entry *)ptr;
+	int n = strlen(uv_ate->archtype);
+
+	if (n > 0 && n < sizeof(uv_ate->archtype)) {
+		pr_info("UV: UVarchtype received from BIOS\n");
+		uv_stringify(UV_AT_SIZE, uv_archtype, uv_ate->archtype);
+		return 1;
+	}
+	return 0;
+}
+
+/* Determine if UV arch type entry might exist in UVsystab */
+static int __init early_get_arch_type(void)
+{
+	unsigned long uvst_physaddr, uvst_size, ptr;
+	struct uv_systab *st;
+	u32 rev;
+	int ret;
+
+	uvst_physaddr = get_uv_systab_phys(0);
+	if (!uvst_physaddr)
+		return 0;
+
+	st = early_memremap_ro(uvst_physaddr, sizeof(struct uv_systab));
+	if (!st) {
+		pr_err("UV: Cannot access UVsystab, remap failed\n");
+		return 0;
+	}
+
+	rev = st->revision;
+	if (rev < UV_SYSTAB_VERSION_UV5) {
+		early_memunmap(st, sizeof(struct uv_systab));
+		return 0;
+	}
+
+	uvst_size = st->size;
+	early_memunmap(st, sizeof(struct uv_systab));
+	st = early_memremap_ro(uvst_physaddr, uvst_size);
+	if (!st) {
+		pr_err("UV: Cannot access UVarchtype, remap failed\n");
+		return 0;
+	}
+
+	ptr = early_find_archtype(st);
+	if (!ptr) {
+		early_memunmap(st, uvst_size);
+		return 0;
+	}
+
+	ret = decode_arch_type(ptr);
+	early_memunmap(st, uvst_size);
+	return ret;
+}
+
 static int __init uv_set_system_type(char *_oem_id)
 {
-	/* Save OEM ID */
+	/* Save OEM_ID passed from ACPI MADT */
 	uv_stringify(sizeof(oem_id), oem_id, _oem_id);
 
-	/* Set hubless type if true */
-	if (strncmp(oem_id, "SGI", 3) != 0) {
-		if (strncmp(oem_id, "NSGI", 4) != 0)
+	/* Check if BIOS sent us a UVarchtype */
+	if (!early_get_arch_type())
+
+		/* If not use OEM ID for UVarchtype */
+		uv_stringify(UV_AT_SIZE, uv_archtype, _oem_id);
+
+	/* Check if not hubbed */
+	if (strncmp(uv_archtype, "SGI", 3) != 0) {
+
+		/* (Not hubbed), check if not hubless */
+		if (strncmp(uv_archtype, "NSGI", 4) != 0)
+
+			/* (Not hubless), not a UV */
 			return 0;
 
 		/* UV4 Hubless: CH */
-		if (strncmp(oem_id, "NSGI4", 5) == 0)
+		if (strncmp(uv_archtype, "NSGI4", 5) == 0)
 			uv_hubless_system = 0x11;
 
 		/* UV3 Hubless: UV300/MC990X w/o hub */
@@ -333,10 +418,10 @@ static int __init uv_set_system_type(char *_oem_id)
 
 	/* Set hubbed type if true */
 	uv_hub_info->hub_revision =
-		!strncmp(oem_id, "SGI5", 4) ? UV5_HUB_REVISION_BASE :
-		!strncmp(oem_id, "SGI4", 4) ? UV4_HUB_REVISION_BASE :
-		!strncmp(oem_id, "SGI3", 4) ? UV3_HUB_REVISION_BASE :
-		!strcmp(oem_id, "SGI2") ? UV2_HUB_REVISION_BASE : 0;
+		!strncmp(uv_archtype, "SGI5", 4) ? UV5_HUB_REVISION_BASE :
+		!strncmp(uv_archtype, "SGI4", 4) ? UV4_HUB_REVISION_BASE :
+		!strncmp(uv_archtype, "SGI3", 4) ? UV3_HUB_REVISION_BASE :
+		!strcmp(uv_archtype, "SGI2") ? UV2_HUB_REVISION_BASE : 0;
 
 	switch (uv_hub_info->hub_revision) {
 	case UV5_HUB_REVISION_BASE:
@@ -407,8 +492,7 @@ static int __init uv_acpi_madt_oem_check(char *_oem_id, char *_oem_table_id)
 	return 0;
 
 badbios:
-	pr_err("UV: OEM_ID:%s OEM_TABLE_ID:%s\n", oem_id, oem_table_id);
-	pr_err("UV: Current UV Type or BIOS not supported\n");
+	pr_err("UV: UVarchtype:%s not supported\n", uv_archtype);
 	BUG();
 }
 
@@ -1199,6 +1283,7 @@ static void __init decode_gam_rng_tbl(unsigned long ptr)
 	pr_info("UV: GRT: %d entries, sockets(min:%x,max:%x) pnodes(min:%x,max:%x)\n", index, _min_socket, _max_socket, _min_pnode, _max_pnode);
 }
 
+/* Walk through UVsystab decoding the fields */
 static int __init decode_uv_systab(void)
 {
 	struct uv_systab *st;
@@ -1228,7 +1313,8 @@ static int __init decode_uv_systab(void)
 		if (!ptr)
 			continue;
 
-		ptr = ptr + (unsigned long)st;
+		/* point to payload */
+		ptr += (unsigned long)st;
 
 		switch (st->entry[i].type) {
 		case UV_SYSTAB_TYPE_GAM_PARAMS:
@@ -1238,6 +1324,15 @@ static int __init decode_uv_systab(void)
 		case UV_SYSTAB_TYPE_GAM_RNG_TBL:
 			decode_gam_rng_tbl(ptr);
 			break;
+
+		case UV_SYSTAB_TYPE_ARCH_TYPE:
+			/* already processed in early startup */
+			break;
+
+		default:
+			pr_err("UV:%s:Unrecognized UV_SYSTAB_TYPE:%d, skipped\n",
+				__func__, st->entry[i].type);
+			break;
 		}
 	}
 	return 0;
@@ -1278,7 +1373,7 @@ static void __init build_socket_tables(void)
 			pr_info("UV: No UVsystab socket table, ignoring\n");
 			return;
 		}
-		pr_crit("UV: Error: UVsystab address translations not available!\n");
+		pr_err("UV: Error: UVsystab address translations not available!\n");
 		BUG();
 	}
 
@@ -1404,9 +1499,9 @@ static int __maybe_unused proc_hubless_show(struct seq_file *file, void *data)
 	return 0;
 }
 
-static int __maybe_unused proc_oemid_show(struct seq_file *file, void *data)
+static int __maybe_unused proc_archtype_show(struct seq_file *file, void *data)
 {
-	seq_printf(file, "%s/%s\n", oem_id, oem_table_id);
+	seq_printf(file, "%s/%s\n", uv_archtype, oem_table_id);
 	return 0;
 }
 
@@ -1415,7 +1510,7 @@ static __init void uv_setup_proc_files(int hubless)
 	struct proc_dir_entry *pde;
 
 	pde = proc_mkdir(UV_PROC_NODE, NULL);
-	proc_create_single("oemid", 0, pde, proc_oemid_show);
+	proc_create_single("archtype", 0, pde, proc_archtype_show);
 	if (hubless)
 		proc_create_single("hubless", 0, pde, proc_hubless_show);
 	else
@@ -1467,12 +1562,14 @@ static void __init uv_system_init_hub(void)
 
 	map_low_mmrs();
 
-	/* Get uv_systab for decoding: */
+	/* Get uv_systab for decoding, setup UV BIOS calls */
 	uv_bios_init();
 
 	/* If there's an UVsystab problem then abort UV init: */
-	if (decode_uv_systab() < 0)
+	if (decode_uv_systab() < 0) {
+		pr_err("UV: Mangled UVsystab format\n");
 		return;
+	}
 
 	build_socket_tables();
 	build_uv_gr_table();
* Unmerged path arch/x86/platform/uv/bios_uv.c
