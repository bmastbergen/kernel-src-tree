net: atlantic: QoS implementation: max_rate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mark Starovoytov <mstarovoitov@marvell.com>
commit 7327699f35f8e90b32c03080b5cba4e9aa95e087
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7327699f.failed

This patch adds initial support for mqprio rate limiters (max_rate only).

Atlantic HW supports Rate-Shaping for time-sensitive traffic at per
Traffic Class (TC) granularity.
Target rate is defined by:
* nominal link rate (always 10G);
* rate factor (ratio between nominal rate and max allowed).

	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7327699f35f8e90b32c03080b5cba4e9aa95e087)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_main.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_main.c
index 25a59894105a,d8817047f4ef..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_main.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_main.c
@@@ -229,6 -332,62 +229,65 @@@ static int aq_ndo_vlan_rx_kill_vid(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int aq_validate_mqprio_opt(struct aq_nic_s *self,
+ 				  struct tc_mqprio_qopt_offload *mqprio,
+ 				  const unsigned int num_tc)
+ {
+ 	const bool has_min_rate = !!(mqprio->flags & TC_MQPRIO_F_MIN_RATE);
+ 	int i;
+ 
+ 	if (num_tc > aq_hw_num_tcs(self->aq_hw)) {
+ 		netdev_err(self->ndev, "Too many TCs requested\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (num_tc != 0 && !is_power_of_2(num_tc)) {
+ 		netdev_err(self->ndev, "TC count should be power of 2\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	for (i = 0; i < num_tc; i++) {
+ 		if (has_min_rate && mqprio->min_rate[i]) {
+ 			netdev_err(self->ndev,
+ 				   "Min tx rate is not supported\n");
+ 			return -EOPNOTSUPP;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int aq_ndo_setup_tc(struct net_device *dev, enum tc_setup_type type,
+ 			   void *type_data)
+ {
+ 	struct tc_mqprio_qopt_offload *mqprio = type_data;
+ 	struct aq_nic_s *aq_nic = netdev_priv(dev);
+ 	int err;
+ 	int i;
+ 
+ 	if (type != TC_SETUP_QDISC_MQPRIO)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = aq_validate_mqprio_opt(aq_nic, mqprio, mqprio->qopt.num_tc);
+ 	if (err)
+ 		return err;
+ 
+ 	if (mqprio->flags & TC_MQPRIO_F_MAX_RATE) {
+ 		for (i = 0; i < mqprio->qopt.num_tc; i++) {
+ 			u64 max_rate = mqprio->max_rate[i];
+ 
+ 			do_div(max_rate, AQ_MBPS_DIVISOR);
+ 			aq_nic_setup_tc_max_rate(aq_nic, i, (u32)max_rate);
+ 		}
+ 	}
+ 
+ 	return aq_nic_setup_tc_mqprio(aq_nic, mqprio->qopt.num_tc,
+ 				      mqprio->qopt.prio_tc_map);
+ }
+ 
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
  static const struct net_device_ops aq_ndev_ops = {
  	.ndo_open = aq_ndev_open,
  	.ndo_stop = aq_ndev_close,
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index ed7d344e3ed7,2e0e7d34fda0..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -1076,3 -1241,106 +1076,109 @@@ void aq_nic_shutdown(struct aq_nic_s *s
  err_exit:
  	rtnl_unlock();
  }
++<<<<<<< HEAD
++=======
+ 
+ u8 aq_nic_reserve_filter(struct aq_nic_s *self, enum aq_rx_filter_type type)
+ {
+ 	u8 location = 0xFF;
+ 	u32 fltr_cnt;
+ 	u32 n_bit;
+ 
+ 	switch (type) {
+ 	case aq_rx_filter_ethertype:
+ 		location = AQ_RX_LAST_LOC_FETHERT - AQ_RX_FIRST_LOC_FETHERT -
+ 			   self->aq_hw_rx_fltrs.fet_reserved_count;
+ 		self->aq_hw_rx_fltrs.fet_reserved_count++;
+ 		break;
+ 	case aq_rx_filter_l3l4:
+ 		fltr_cnt = AQ_RX_LAST_LOC_FL3L4 - AQ_RX_FIRST_LOC_FL3L4;
+ 		n_bit = fltr_cnt - self->aq_hw_rx_fltrs.fl3l4.reserved_count;
+ 
+ 		self->aq_hw_rx_fltrs.fl3l4.active_ipv4 |= BIT(n_bit);
+ 		self->aq_hw_rx_fltrs.fl3l4.reserved_count++;
+ 		location = n_bit;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return location;
+ }
+ 
+ void aq_nic_release_filter(struct aq_nic_s *self, enum aq_rx_filter_type type,
+ 			   u32 location)
+ {
+ 	switch (type) {
+ 	case aq_rx_filter_ethertype:
+ 		self->aq_hw_rx_fltrs.fet_reserved_count--;
+ 		break;
+ 	case aq_rx_filter_l3l4:
+ 		self->aq_hw_rx_fltrs.fl3l4.reserved_count--;
+ 		self->aq_hw_rx_fltrs.fl3l4.active_ipv4 &= ~BIT(location);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ int aq_nic_setup_tc_mqprio(struct aq_nic_s *self, u32 tcs, u8 *prio_tc_map)
+ {
+ 	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
+ 	bool ndev_running;
+ 	int err = 0;
+ 	int i;
+ 
+ 	/* if already the same configuration or
+ 	 * disable request (tcs is 0) and we already is disabled
+ 	 */
+ 	if (tcs == cfg->tcs || (tcs == 0 && !cfg->is_qos))
+ 		return 0;
+ 
+ 	ndev_running = netif_running(self->ndev);
+ 	if (ndev_running)
+ 		dev_close(self->ndev);
+ 
+ 	cfg->tcs = tcs;
+ 	if (cfg->tcs == 0)
+ 		cfg->tcs = 1;
+ 	if (prio_tc_map)
+ 		memcpy(cfg->prio_tc_map, prio_tc_map, sizeof(cfg->prio_tc_map));
+ 	else
+ 		for (i = 0; i < sizeof(cfg->prio_tc_map); i++)
+ 			cfg->prio_tc_map[i] = cfg->tcs * i / 8;
+ 
+ 	cfg->is_qos = (tcs != 0 ? true : false);
+ 	cfg->is_ptp = (cfg->tcs <= AQ_HW_PTP_TC);
+ 	if (!cfg->is_ptp)
+ 		netdev_warn(self->ndev, "%s\n",
+ 			    "PTP is auto disabled due to requested TC count.");
+ 
+ 	netdev_set_num_tc(self->ndev, cfg->tcs);
+ 
+ 	if (ndev_running)
+ 		err = dev_open(self->ndev, NULL);
+ 
+ 	return err;
+ }
+ 
+ int aq_nic_setup_tc_max_rate(struct aq_nic_s *self, const unsigned int tc,
+ 			     const u32 max_rate)
+ {
+ 	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
+ 
+ 	if (tc >= AQ_CFG_TCS_MAX)
+ 		return -EINVAL;
+ 
+ 	if (max_rate && max_rate < 10) {
+ 		netdev_warn(self->ndev,
+ 			"Setting %s to the minimum usable value of %dMbps.\n",
+ 			"max rate", 10);
+ 		cfg->tc_max_rate[tc] = 10;
+ 	} else {
+ 		cfg->tc_max_rate[tc] = max_rate;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.h
index f6d04351e098,351c4e68f40d..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
@@@ -45,7 -59,13 +45,12 @@@ struct aq_nic_cfg_s 
  	bool is_polling;
  	bool is_rss;
  	bool is_lro;
 -	bool is_qos;
 -	bool is_ptp;
 -	enum aq_tc_mode tc_mode;
 -	u32 priv_flags;
  	u8  tcs;
++<<<<<<< HEAD
++=======
+ 	u8 prio_tc_map[8];
+ 	u32 tc_max_rate[AQ_CFG_TCS_MAX];
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
  	struct aq_rss_parameters aq_rss;
  	u32 eee_speeds;
  };
@@@ -147,8 -188,13 +152,17 @@@ int aq_nic_set_link_ksettings(struct aq
  			      const struct ethtool_link_ksettings *cmd);
  struct aq_nic_cfg_s *aq_nic_get_cfg(struct aq_nic_s *self);
  u32 aq_nic_get_fw_version(struct aq_nic_s *self);
 -int aq_nic_set_loopback(struct aq_nic_s *self);
 +int aq_nic_change_pm_state(struct aq_nic_s *self, pm_message_t *pm_msg);
  int aq_nic_update_interrupt_moderation_settings(struct aq_nic_s *self);
  void aq_nic_shutdown(struct aq_nic_s *self);
- 
++<<<<<<< HEAD
++
++=======
+ u8 aq_nic_reserve_filter(struct aq_nic_s *self, enum aq_rx_filter_type type);
+ void aq_nic_release_filter(struct aq_nic_s *self, enum aq_rx_filter_type type,
+ 			   u32 location);
+ int aq_nic_setup_tc_mqprio(struct aq_nic_s *self, u32 tcs, u8 *prio_tc_map);
+ int aq_nic_setup_tc_max_rate(struct aq_nic_s *self, const unsigned int tc,
+ 			     const u32 max_rate);
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
  #endif /* AQ_NIC_H */
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index b7e5ce0d7af5,abc86eb4f525..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -108,11 -114,36 +108,21 @@@ static int hw_atl_b0_set_fc(struct aq_h
  	return 0;
  }
  
 -static int hw_atl_b0_tc_ptp_set(struct aq_hw_s *self)
 -{
 -	/* Init TC2 for PTP_TX */
 -	hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, HW_ATL_B0_PTP_TXBUF_SIZE,
 -					       AQ_HW_PTP_TC);
 -
 -	/* Init TC2 for PTP_RX */
 -	hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, HW_ATL_B0_PTP_RXBUF_SIZE,
 -					       AQ_HW_PTP_TC);
 -	/* No flow control for PTP */
 -	hw_atl_rpb_rx_xoff_en_per_tc_set(self, 0U, AQ_HW_PTP_TC);
 -
 -	return aq_hw_err_from_flags(self);
 -}
 -
  static int hw_atl_b0_hw_qos_set(struct aq_hw_s *self)
  {
 -	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
 -	u32 tx_buff_size = HW_ATL_B0_TXBUF_MAX;
 -	u32 rx_buff_size = HW_ATL_B0_RXBUF_MAX;
 -	unsigned int prio = 0U;
  	u32 tc = 0U;
++<<<<<<< HEAD
 +	u32 buff_size = 0U;
 +	unsigned int i_priority = 0U;
++=======
+ 
+ 	hw_atl_b0_hw_init_tx_tc_rate_limit(self);
+ 
+ 	if (cfg->is_ptp) {
+ 		tx_buff_size -= HW_ATL_B0_PTP_TXBUF_SIZE;
+ 		rx_buff_size -= HW_ATL_B0_PTP_RXBUF_SIZE;
+ 	}
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
  
  	/* TPS Descriptor rate init */
  	hw_atl_tps_tx_pkt_shed_desc_rate_curr_time_res_set(self, 0x0U);
@@@ -122,46 -153,45 +132,51 @@@
  	hw_atl_tps_tx_pkt_shed_desc_vm_arb_mode_set(self, 0U);
  
  	/* TPS TC credits init */
- 	hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);
  	hw_atl_tps_tx_pkt_shed_data_arb_mode_set(self, 0U);
  
 -	tx_buff_size /= cfg->tcs;
 -	rx_buff_size /= cfg->tcs;
 -	for (tc = 0; tc < cfg->tcs; tc++) {
 -		u32 threshold = 0U;
 +	hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, 0xFFF, 0U);
 +	hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, 0x64, 0U);
 +	hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, 0x50, 0U);
 +	hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, 0x1E, 0U);
  
++<<<<<<< HEAD
 +	/* Tx buf size */
 +	buff_size = HW_ATL_B0_TXBUF_MAX;
++=======
+ 		/* TX Packet Scheduler Data TC0 */
+ 		hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, 0xFFF, tc);
+ 		hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, 0x64, tc);
 -
 -		/* Tx buf size TC0 */
 -		hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, tx_buff_size, tc);
 -
 -		threshold = (tx_buff_size * (1024 / 32U) * 66U) / 100U;
 -		hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self, threshold, tc);
 -
 -		threshold = (tx_buff_size * (1024 / 32U) * 50U) / 100U;
 -		hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self, threshold, tc);
 -
 -		/* QoS Rx buf size per TC */
 -		hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, rx_buff_size, tc);
 -
 -		threshold = (rx_buff_size * (1024U / 32U) * 66U) / 100U;
 -		hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self, threshold, tc);
 -
 -		threshold = (rx_buff_size * (1024U / 32U) * 50U) / 100U;
 -		hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self, threshold, tc);
 -
 -		hw_atl_b0_set_fc(self, self->aq_nic_cfg->fc.req, tc);
 -	}
 -
 -	if (cfg->is_ptp)
 -		hw_atl_b0_tc_ptp_set(self);
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
 +
 +	hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, buff_size, tc);
 +	hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024 / 32U) * 66U) /
 +						   100U, tc);
 +	hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024 / 32U) * 50U) /
 +						   100U, tc);
 +
 +	/* QoS Rx buf size per TC */
 +	tc = 0;
 +	buff_size = HW_ATL_B0_RXBUF_MAX;
 +
 +	hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, buff_size, tc);
 +	hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024U / 32U) * 66U) /
 +						   100U, tc);
 +	hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024U / 32U) * 50U) /
 +						   100U, tc);
 +
 +	hw_atl_b0_set_fc(self, self->aq_nic_cfg->flow_control, tc);
  
  	/* QoS 802.1p priority -> TC mapping */
 -	for (prio = 0; prio < 8; ++prio)
 -		hw_atl_rpf_rpb_user_priority_tc_map_set(self, prio,
 -							cfg->prio_tc_map[prio]);
 +	for (i_priority = 8U; i_priority--;)
 +		hw_atl_rpf_rpb_user_priority_tc_map_set(self, i_priority, 0U);
  
  	return aq_hw_err_from_flags(self);
  }
@@@ -286,10 -318,62 +301,65 @@@ static int hw_atl_b0_hw_offload_set(str
  	return aq_hw_err_from_flags(self);
  }
  
+ int hw_atl_b0_hw_init_tx_tc_rate_limit(struct aq_hw_s *self)
+ {
+ 	/* Scale factor is based on the number of bits in fractional portion */
+ 	static const u32 scale = BIT(HW_ATL_TPS_DESC_RATE_Y_WIDTH);
+ 	static const u32 frac_msk = HW_ATL_TPS_DESC_RATE_Y_MSK >>
+ 				    HW_ATL_TPS_DESC_RATE_Y_SHIFT;
+ 	struct aq_nic_cfg_s *nic_cfg = self->aq_nic_cfg;
+ 	int tc;
+ 
+ 	hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);
+ 	hw_atl_tps_tx_desc_rate_mode_set(self, nic_cfg->is_qos ? 1U : 0U);
+ 	for (tc = 0; tc != nic_cfg->tcs; tc++) {
+ 		const u32 en = (nic_cfg->tc_max_rate[tc] != 0) ? 1U : 0U;
+ 		const u32 desc = AQ_NIC_CFG_TCVEC2RING(nic_cfg, tc, 0);
+ 
+ 		hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, 0x50, tc);
+ 		hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, 0x1E, tc);
+ 
+ 		hw_atl_tps_tx_desc_rate_en_set(self, desc, en);
+ 
+ 		if (en) {
+ 			/* Nominal rate is always 10G */
+ 			const u32 rate = 10000U * scale /
+ 					 nic_cfg->tc_max_rate[tc];
+ 			const u32 rate_int = rate >>
+ 					     HW_ATL_TPS_DESC_RATE_Y_WIDTH;
+ 			const u32 rate_frac = rate & frac_msk;
+ 
+ 			hw_atl_tps_tx_desc_rate_x_set(self, desc, rate_int);
+ 			hw_atl_tps_tx_desc_rate_y_set(self, desc, rate_frac);
+ 		} else {
+ 			/* A value of 1 indicates the queue is not
+ 			 * rate controlled.
+ 			 */
+ 			hw_atl_tps_tx_desc_rate_x_set(self, desc, 1U);
+ 			hw_atl_tps_tx_desc_rate_y_set(self, desc, 0U);
+ 		}
+ 	}
+ 	for (tc = nic_cfg->tcs; tc != AQ_CFG_TCS_MAX; tc++) {
+ 		const u32 desc = AQ_NIC_CFG_TCVEC2RING(nic_cfg, tc, 0);
+ 
+ 		hw_atl_tps_tx_desc_rate_en_set(self, desc, 0U);
+ 		hw_atl_tps_tx_desc_rate_x_set(self, desc, 1U);
+ 		hw_atl_tps_tx_desc_rate_y_set(self, desc, 0U);
+ 	}
+ 
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
  static int hw_atl_b0_hw_init_tx_path(struct aq_hw_s *self)
  {
+ 	struct aq_nic_cfg_s *nic_cfg = self->aq_nic_cfg;
+ 
  	/* Tx TC/Queue number config */
++<<<<<<< HEAD
 +	hw_atl_rpb_tps_tx_tc_mode_set(self, 1U);
++=======
+ 	hw_atl_tpb_tps_tx_tc_mode_set(self, nic_cfg->tc_mode);
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
  
  	hw_atl_thm_lso_tcp_flag_of_first_pkt_set(self, 0x0FF6U);
  	hw_atl_thm_lso_tcp_flag_of_middle_pkt_set(self, 0x0FF6U);
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
index b1c0b6850e60,992ee4ed37cc..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
@@@ -36,4 -34,41 +36,44 @@@ extern const struct aq_hw_ops hw_atl_op
  
  #define hw_atl_ops_b1 hw_atl_ops_b0
  
++<<<<<<< HEAD
++=======
+ int hw_atl_b0_hw_rss_hash_set(struct aq_hw_s *self,
+ 			      struct aq_rss_parameters *rss_params);
+ int hw_atl_b0_hw_offload_set(struct aq_hw_s *self,
+ 			     struct aq_nic_cfg_s *aq_nic_cfg);
+ 
+ int hw_atl_b0_hw_ring_tx_start(struct aq_hw_s *self, struct aq_ring_s *ring);
+ int hw_atl_b0_hw_ring_rx_start(struct aq_hw_s *self, struct aq_ring_s *ring);
+ 
+ int hw_atl_b0_hw_ring_rx_init(struct aq_hw_s *self, struct aq_ring_s *aq_ring,
+ 			      struct aq_ring_param_s *aq_ring_param);
+ int hw_atl_b0_hw_ring_rx_fill(struct aq_hw_s *self, struct aq_ring_s *ring,
+ 			      unsigned int sw_tail_old);
+ int hw_atl_b0_hw_ring_rx_receive(struct aq_hw_s *self, struct aq_ring_s *ring);
+ 
+ int hw_atl_b0_hw_ring_tx_init(struct aq_hw_s *self, struct aq_ring_s *aq_ring,
+ 			      struct aq_ring_param_s *aq_ring_param);
+ int hw_atl_b0_hw_ring_tx_xmit(struct aq_hw_s *self, struct aq_ring_s *ring,
+ 			      unsigned int frags);
+ int hw_atl_b0_hw_ring_tx_head_update(struct aq_hw_s *self,
+ 				     struct aq_ring_s *ring);
+ 
+ int hw_atl_b0_hw_ring_tx_stop(struct aq_hw_s *self, struct aq_ring_s *ring);
+ int hw_atl_b0_hw_ring_rx_stop(struct aq_hw_s *self, struct aq_ring_s *ring);
+ 
+ int hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr);
+ 
+ int hw_atl_b0_hw_start(struct aq_hw_s *self);
+ 
+ int hw_atl_b0_hw_init_tx_tc_rate_limit(struct aq_hw_s *self);
+ 
+ int hw_atl_b0_hw_irq_enable(struct aq_hw_s *self, u64 mask);
+ int hw_atl_b0_hw_irq_disable(struct aq_hw_s *self, u64 mask);
+ int hw_atl_b0_hw_irq_read(struct aq_hw_s *self, u64 *mask);
+ 
+ int hw_atl_b0_hw_packet_filter_set(struct aq_hw_s *self,
+ 				   unsigned int packet_filter);
+ 
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
  #endif /* HW_ATL_B0_H */
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
index 5ddaed96cf74,06220792daf1..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
@@@ -1977,6 -2038,42 +1977,45 @@@
  /* default value of bitfield lso_tcp_flag_mid[b:0] */
  #define HW_ATL_THM_LSO_TCP_FLAG_MID_DEFAULT 0x0
  
++<<<<<<< HEAD
++=======
+ /* tx tx_tc_mode bitfield definitions
+  * preprocessor definitions for the bitfield "tx_tc_mode".
+  * port="pif_tpb_tx_tc_mode_i,pif_tps_tx_tc_mode_i"
+  */
+ 
+ /* register address for bitfield tx_tc_mode */
+ #define HW_ATL_TPB_TX_TC_MODE_ADDR 0x00007900
+ /* bitmask for bitfield tx_tc_mode */
+ #define HW_ATL_TPB_TX_TC_MODE_MSK 0x00000100
+ /* inverted bitmask for bitfield tx_tc_mode */
+ #define HW_ATL_TPB_TX_TC_MODE_MSKN 0xFFFFFEFF
+ /* lower bit position of bitfield tx_tc_mode */
+ #define HW_ATL_TPB_TX_TC_MODE_SHIFT 8
+ /* width of bitfield tx_tc_mode */
+ #define HW_ATL_TPB_TX_TC_MODE_WIDTH 1
+ /* default value of bitfield tx_tc_mode */
+ #define HW_ATL_TPB_TX_TC_MODE_DEFAULT 0x0
+ 
+ /* tx tx_desc_rate_mode bitfield definitions
+  * preprocessor definitions for the bitfield "tx_desc_rate_mode".
+  * port="pif_tps_desc_rate_mode_i"
+  */
+ 
+ /* register address for bitfield tx_desc_rate_mode */
+ #define HW_ATL_TPS_TX_DESC_RATE_MODE_ADR 0x00007900
+ /* bitmask for bitfield tx_desc_rate_mode */
+ #define HW_ATL_TPS_TX_DESC_RATE_MODE_MSK 0x00000080
+ /* inverted bitmask for bitfield tx_desc_rate_mode */
+ #define HW_ATL_TPS_TX_DESC_RATE_MODE_MSKN 0xFFFFFF7F
+ /* lower bit position of bitfield tx_desc_rate_mode */
+ #define HW_ATL_TPS_TX_DESC_RATE_MODE_SHIFT 7
+ /* width of bitfield tx_desc_rate_mode */
+ #define HW_ATL_TPS_TX_DESC_RATE_MODE_WIDTH 1
+ /* default value of bitfield tx_desc_rate_mode */
+ #define HW_ATL_TPS_TX_DESC_RATE_MODE_DEFAULT 0x0
+ 
++>>>>>>> 7327699f35f8 (net: atlantic: QoS implementation: max_rate)
  /* tx tx_buf_en bitfield definitions
   * preprocessor definitions for the bitfield "tx_buf_en".
   * port="pif_tpb_tx_buf_en_i"
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 46eaf70c5ccb..1b9d7a80708c 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@ -29,6 +29,9 @@
 			(AQ_RX_LAST_LOC_FVLANID - AQ_RX_FIRST_LOC_FVLANID + 1U)
 #define AQ_RX_QUEUE_NOT_ASSIGNED   0xFFU
 
+/* Used for rate to Mbps conversion */
+#define AQ_MBPS_DIVISOR         125000 /* 1000000 / 8 */
+
 /* NIC H/W capabilities */
 struct aq_hw_caps_s {
 	u64 hw_features;
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_main.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
index 961b9b69649f..77b92b373978 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
@@ -1461,6 +1461,42 @@ void hw_atl_tps_tx_pkt_shed_tc_data_weight_set(struct aq_hw_s *aq_hw,
 			    tx_pkt_shed_tc_data_weight);
 }
 
+void hw_atl_tps_tx_desc_rate_mode_set(struct aq_hw_s *aq_hw,
+				      const u32 rate_mode)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_TX_DESC_RATE_MODE_ADR,
+			    HW_ATL_TPS_TX_DESC_RATE_MODE_MSK,
+			    HW_ATL_TPS_TX_DESC_RATE_MODE_SHIFT,
+			    rate_mode);
+}
+
+void hw_atl_tps_tx_desc_rate_en_set(struct aq_hw_s *aq_hw, const u32 desc,
+				    const u32 enable)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_RATE_EN_ADR(desc),
+			    HW_ATL_TPS_DESC_RATE_EN_MSK,
+			    HW_ATL_TPS_DESC_RATE_EN_SHIFT,
+			    enable);
+}
+
+void hw_atl_tps_tx_desc_rate_x_set(struct aq_hw_s *aq_hw, const u32 desc,
+				   const u32 rate_int)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_RATE_X_ADR(desc),
+			    HW_ATL_TPS_DESC_RATE_X_MSK,
+			    HW_ATL_TPS_DESC_RATE_X_SHIFT,
+			    rate_int);
+}
+
+void hw_atl_tps_tx_desc_rate_y_set(struct aq_hw_s *aq_hw, const u32 desc,
+				   const u32 rate_frac)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_RATE_Y_ADR(desc),
+			    HW_ATL_TPS_DESC_RATE_Y_MSK,
+			    HW_ATL_TPS_DESC_RATE_Y_SHIFT,
+			    rate_frac);
+}
+
 /* tx */
 void hw_atl_tx_tx_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 tx_reg_res_dis)
 {
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
index 1dc201492ec7..2b1f7d5ba516 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
@@ -690,6 +690,22 @@ void hw_atl_tps_tx_pkt_shed_tc_data_weight_set(struct aq_hw_s *aq_hw,
 					       u32 tx_pkt_shed_tc_data_weight,
 					u32 tc);
 
+/* set tx descriptor rate mode */
+void hw_atl_tps_tx_desc_rate_mode_set(struct aq_hw_s *aq_hw,
+				      const u32 rate_mode);
+
+/* set tx packet scheduler descriptor rate enable */
+void hw_atl_tps_tx_desc_rate_en_set(struct aq_hw_s *aq_hw, const u32 desc,
+				    const u32 enable);
+
+/* set tx packet scheduler descriptor rate integral value */
+void hw_atl_tps_tx_desc_rate_x_set(struct aq_hw_s *aq_hw, const u32 desc,
+				   const u32 rate_int);
+
+/* set tx packet scheduler descriptor rate fractional value */
+void hw_atl_tps_tx_desc_rate_y_set(struct aq_hw_s *aq_hw, const u32 desc,
+				   const u32 rate_frac);
+
 /* tx */
 
 /* set tx register reset disable */
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
