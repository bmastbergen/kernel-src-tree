s390/qeth: Remove pnso workaround

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Alexandra Winter <wintera@linux.ibm.com>
commit 0d0e2b538c13f4f698ba58485a573ce824036567
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0d0e2b53.failed

Remove workaround that supported early hardware implementations
of PNSO OC3. Rely on the 'enarf' feature bit instead.

Fixes: fa115adff2c1 ("s390/qeth: Detect PNSO OC3 capability")
	Signed-off-by: Alexandra Winter <wintera@linux.ibm.com>
	Reviewed-by: Julian Wiedmann <jwi@linux.ibm.com>
[jwi: use logical instead of bit-wise AND]
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0d0e2b538c13f4f698ba58485a573ce824036567)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index 88261c8e41f6,79939ba5d523..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -787,192 -979,62 +787,213 @@@ static void qeth_l2_setup_bridgeport_at
  	}
  }
  
++<<<<<<< HEAD
 +static int qeth_l2_set_online(struct ccwgroup_device *gdev)
 +{
 +	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
 +	struct net_device *dev = card->dev;
 +	int rc = 0;
 +	bool carrier_ok;
++=======
+ /**
+  *	qeth_l2_detect_dev2br_support() -
+  *	Detect whether this card supports 'dev to bridge fdb network address
+  *	change notification' and thus can support the learning_sync bridgeport
+  *	attribute
+  *	@card: qeth_card structure pointer
+  */
+ static void qeth_l2_detect_dev2br_support(struct qeth_card *card)
+ {
+ 	struct qeth_priv *priv = netdev_priv(card->dev);
+ 	bool dev2br_supported;
++>>>>>>> 0d0e2b538c13 (s390/qeth: Remove pnso workaround)
  
 -	QETH_CARD_TEXT(card, 2, "d2brsup");
 -	if (!IS_IQD(card))
 -		return;
 +	mutex_lock(&card->discipline_mutex);
 +	mutex_lock(&card->conf_mutex);
 +	QETH_CARD_TEXT(card, 2, "setonlin");
 +
++<<<<<<< HEAD
 +	rc = qeth_core_hardsetup_card(card, &carrier_ok);
 +	if (rc) {
 +		QETH_CARD_TEXT_(card, 2, "2err%04x", rc);
 +		rc = -ENODEV;
 +		goto out_remove;
 +	}
  
 +	mutex_lock(&card->sbp_lock);
 +	qeth_bridgeport_query_support(card);
 +	if (card->options.sbp.supported_funcs) {
 +		qeth_l2_setup_bridgeport_attrs(card);
 +		dev_info(&card->gdev->dev,
 +			 "The device represents a Bridge Capable Port\n");
 +	}
 +	mutex_unlock(&card->sbp_lock);
 +
 +	qeth_l2_register_dev_addr(card);
 +
 +	/* for the rx_bcast characteristic, init VNICC after setmac */
 +	qeth_l2_vnicc_init(card);
 +
 +	qeth_trace_features(card);
 +	qeth_l2_trace_features(card);
 +
 +	card->state = CARD_STATE_HARDSETUP;
 +	qeth_print_status_message(card);
 +
 +	/* softsetup */
 +	QETH_CARD_TEXT(card, 2, "softsetp");
 +
 +	card->state = CARD_STATE_SOFTSETUP;
 +
 +	qeth_set_allowed_threads(card, 0xffffffff, 0);
 +
 +	if (dev->reg_state != NETREG_REGISTERED) {
 +		rc = qeth_l2_setup_netdev(card);
 +		if (rc)
 +			goto out_remove;
 +
 +		if (carrier_ok)
 +			netif_carrier_on(dev);
 +	} else {
 +		rtnl_lock();
 +		if (carrier_ok)
 +			netif_carrier_on(dev);
 +		else
 +			netif_carrier_off(dev);
++=======
+ 	/* dev2br requires valid cssid,iid,chid */
+ 	dev2br_supported = card->info.ids_valid &&
+ 			   css_general_characteristics.enarf;
+ 	QETH_CARD_TEXT_(card, 2, "D2Bsup%02x", dev2br_supported);
++>>>>>>> 0d0e2b538c13 (s390/qeth: Remove pnso workaround)
  
 -	if (dev2br_supported)
 -		priv->brport_hw_features |= BR_LEARNING_SYNC;
 -	else
 -		priv->brport_hw_features &= ~BR_LEARNING_SYNC;
 +		netif_device_attach(dev);
 +		qeth_enable_hw_features(dev);
 +
 +		if (card->info.open_when_online) {
 +			card->info.open_when_online = 0;
 +			dev_open(dev, NULL);
 +		}
 +		rtnl_unlock();
 +	}
 +	/* let user_space know that device is online */
 +	kobject_uevent(&gdev->dev.kobj, KOBJ_CHANGE);
 +	mutex_unlock(&card->conf_mutex);
 +	mutex_unlock(&card->discipline_mutex);
 +	return 0;
 +
 +out_remove:
 +	qeth_l2_stop_card(card);
 +	qeth_stop_channel(&card->data);
 +	qeth_stop_channel(&card->write);
 +	qeth_stop_channel(&card->read);
 +	qdio_free(CARD_DDEV(card));
 +
 +	mutex_unlock(&card->conf_mutex);
 +	mutex_unlock(&card->discipline_mutex);
 +	return rc;
  }
  
 -static void qeth_l2_enable_brport_features(struct qeth_card *card)
 +static int __qeth_l2_set_offline(struct ccwgroup_device *cgdev,
 +					int recovery_mode)
  {
 -	struct qeth_priv *priv = netdev_priv(card->dev);
 -	int rc;
 +	struct qeth_card *card = dev_get_drvdata(&cgdev->dev);
 +	int rc = 0, rc2 = 0, rc3 = 0;
  
 -	if (priv->brport_features & BR_LEARNING_SYNC) {
 -		if (priv->brport_hw_features & BR_LEARNING_SYNC) {
 -			qeth_l2_set_pnso_mode(card, QETH_PNSO_ADDR_INFO);
 -			rc = qeth_l2_dev2br_an_set(card, true);
 -			if (rc == -EAGAIN) {
 -				/* Recoverable error, retry once */
 -				qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
 -				qeth_l2_dev2br_fdb_flush(card);
 -				qeth_l2_set_pnso_mode(card, QETH_PNSO_ADDR_INFO);
 -				rc = qeth_l2_dev2br_an_set(card, true);
 -			}
 -			if (rc) {
 -				netdev_err(card->dev,
 -					   "failed to enable bridge learning_sync: %d\n",
 -					   rc);
 -				qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
 -				qeth_l2_dev2br_fdb_flush(card);
 -				priv->brport_features ^= BR_LEARNING_SYNC;
 -			}
 -		} else {
 -			dev_warn(&card->gdev->dev,
 -				"bridge learning_sync not supported\n");
 -			priv->brport_features ^= BR_LEARNING_SYNC;
 -		}
 +	mutex_lock(&card->discipline_mutex);
 +	mutex_lock(&card->conf_mutex);
 +	QETH_CARD_TEXT(card, 3, "setoffl");
 +
 +	if ((!recovery_mode && card->info.hwtrap) || card->info.hwtrap == 2) {
 +		qeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);
 +		card->info.hwtrap = 1;
 +	}
 +
 +	rtnl_lock();
 +	card->info.open_when_online = card->dev->flags & IFF_UP;
 +	dev_close(card->dev);
 +	netif_device_detach(card->dev);
 +	netif_carrier_off(card->dev);
 +	rtnl_unlock();
 +
 +	qeth_l2_stop_card(card);
 +	rc  = qeth_stop_channel(&card->data);
 +	rc2 = qeth_stop_channel(&card->write);
 +	rc3 = qeth_stop_channel(&card->read);
 +	if (!rc)
 +		rc = (rc2) ? rc2 : rc3;
 +	if (rc)
 +		QETH_CARD_TEXT_(card, 2, "1err%d", rc);
 +	qdio_free(CARD_DDEV(card));
 +
 +	/* let user_space know that device is offline */
 +	kobject_uevent(&cgdev->dev.kobj, KOBJ_CHANGE);
 +	mutex_unlock(&card->conf_mutex);
 +	mutex_unlock(&card->discipline_mutex);
 +	return 0;
 +}
 +
 +static int qeth_l2_set_offline(struct ccwgroup_device *cgdev)
 +{
 +	return __qeth_l2_set_offline(cgdev, 0);
 +}
 +
 +static int qeth_l2_recover(void *ptr)
 +{
 +	struct qeth_card *card;
 +	int rc = 0;
 +
 +	card = (struct qeth_card *) ptr;
 +	QETH_CARD_TEXT(card, 2, "recover1");
 +	if (!qeth_do_run_thread(card, QETH_RECOVER_THREAD))
 +		return 0;
 +	QETH_CARD_TEXT(card, 2, "recover2");
 +	dev_warn(&card->gdev->dev,
 +		"A recovery process has been started for the device\n");
 +	__qeth_l2_set_offline(card->gdev, 1);
 +	rc = qeth_l2_set_online(card->gdev);
 +	if (!rc)
 +		dev_info(&card->gdev->dev,
 +			"Device successfully recovered!\n");
 +	else {
 +		ccwgroup_set_offline(card->gdev);
 +		dev_warn(&card->gdev->dev, "The qeth device driver "
 +				"failed to recover an error on the device\n");
 +	}
 +	qeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);
 +	qeth_clear_thread_running_bit(card, QETH_RECOVER_THREAD);
 +	return 0;
 +}
 +
 +static int __init qeth_l2_init(void)
 +{
 +	pr_info("register layer 2 discipline\n");
 +	return 0;
 +}
 +
 +static void __exit qeth_l2_exit(void)
 +{
 +	pr_info("unregister layer 2 discipline\n");
 +}
 +
 +/* Returns zero if the command is successfully "consumed" */
 +static int qeth_l2_control_event(struct qeth_card *card,
 +					struct qeth_ipa_cmd *cmd)
 +{
 +	switch (cmd->hdr.command) {
 +	case IPA_CMD_SETBRIDGEPORT_OSA:
 +	case IPA_CMD_SETBRIDGEPORT_IQD:
 +		if (cmd->data.sbp.hdr.command_code ==
 +				IPA_SBP_BRIDGE_PORT_STATE_CHANGE) {
 +			qeth_bridge_state_change(card, cmd);
 +			return 0;
 +		} else
 +			return 1;
 +	case IPA_CMD_ADDRESS_CHANGE_NOTIF:
 +		qeth_bridge_host_event(card, cmd);
 +		return 0;
 +	default:
 +		return 1;
  	}
  }
  
@@@ -2057,6 -2172,181 +2078,184 @@@ static void qeth_l2_vnicc_set_defaults(
  	card->options.vnicc.wanted_chars = QETH_VNICC_DEFAULT;
  }
  
++<<<<<<< HEAD
++=======
+ static const struct device_type qeth_l2_devtype = {
+ 	.name = "qeth_layer2",
+ 	.groups = qeth_l2_attr_groups,
+ };
+ 
+ static int qeth_l2_probe_device(struct ccwgroup_device *gdev)
+ {
+ 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
+ 	int rc;
+ 
+ 	if (IS_OSN(card))
+ 		dev_notice(&gdev->dev, "OSN support will be dropped in 2021\n");
+ 
+ 	qeth_l2_vnicc_set_defaults(card);
+ 	mutex_init(&card->sbp_lock);
+ 
+ 	if (gdev->dev.type == &qeth_generic_devtype) {
+ 		rc = qeth_l2_create_device_attributes(&gdev->dev);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	INIT_WORK(&card->rx_mode_work, qeth_l2_rx_mode_work);
+ 	return 0;
+ }
+ 
+ static void qeth_l2_remove_device(struct ccwgroup_device *gdev)
+ {
+ 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
+ 
+ 	if (gdev->dev.type == &qeth_generic_devtype)
+ 		qeth_l2_remove_device_attributes(&gdev->dev);
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
+ 
+ 	if (gdev->state == CCWGROUP_ONLINE)
+ 		qeth_set_offline(card, false);
+ 
+ 	cancel_work_sync(&card->close_dev_work);
+ 	if (card->dev->reg_state == NETREG_REGISTERED)
+ 		unregister_netdev(card->dev);
+ }
+ 
+ static int qeth_l2_set_online(struct qeth_card *card, bool carrier_ok)
+ {
+ 	struct net_device *dev = card->dev;
+ 	int rc = 0;
+ 
+ 	qeth_l2_detect_dev2br_support(card);
+ 
+ 	mutex_lock(&card->sbp_lock);
+ 	qeth_bridgeport_query_support(card);
+ 	if (card->options.sbp.supported_funcs) {
+ 		qeth_l2_setup_bridgeport_attrs(card);
+ 		dev_info(&card->gdev->dev,
+ 			 "The device represents a Bridge Capable Port\n");
+ 	}
+ 	mutex_unlock(&card->sbp_lock);
+ 
+ 	qeth_l2_register_dev_addr(card);
+ 
+ 	/* for the rx_bcast characteristic, init VNICC after setmac */
+ 	qeth_l2_vnicc_init(card);
+ 
+ 	qeth_l2_trace_features(card);
+ 
+ 	/* softsetup */
+ 	QETH_CARD_TEXT(card, 2, "softsetp");
+ 
+ 	card->state = CARD_STATE_SOFTSETUP;
+ 
+ 	qeth_set_allowed_threads(card, 0xffffffff, 0);
+ 
+ 	if (dev->reg_state != NETREG_REGISTERED) {
+ 		rc = qeth_l2_setup_netdev(card);
+ 		if (rc)
+ 			goto err_setup;
+ 
+ 		if (carrier_ok)
+ 			netif_carrier_on(dev);
+ 	} else {
+ 		rtnl_lock();
+ 		rc = qeth_set_real_num_tx_queues(card,
+ 						 qeth_tx_actual_queues(card));
+ 		if (rc) {
+ 			rtnl_unlock();
+ 			goto err_set_queues;
+ 		}
+ 
+ 		if (carrier_ok)
+ 			netif_carrier_on(dev);
+ 		else
+ 			netif_carrier_off(dev);
+ 
+ 		netif_device_attach(dev);
+ 		qeth_enable_hw_features(dev);
+ 		qeth_l2_enable_brport_features(card);
+ 
+ 		if (card->info.open_when_online) {
+ 			card->info.open_when_online = 0;
+ 			dev_open(dev, NULL);
+ 		}
+ 		rtnl_unlock();
+ 	}
+ 	return 0;
+ 
+ err_set_queues:
+ err_setup:
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	card->state = CARD_STATE_DOWN;
+ 	return rc;
+ }
+ 
+ static void qeth_l2_set_offline(struct qeth_card *card)
+ {
+ 	struct qeth_priv *priv = netdev_priv(card->dev);
+ 
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	qeth_l2_drain_rx_mode_cache(card);
+ 
+ 	if (card->state == CARD_STATE_SOFTSETUP)
+ 		card->state = CARD_STATE_DOWN;
+ 
+ 	qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
+ 	if (priv->brport_features & BR_LEARNING_SYNC) {
+ 		rtnl_lock();
+ 		qeth_l2_dev2br_fdb_flush(card);
+ 		rtnl_unlock();
+ 	}
+ }
+ 
+ /* Returns zero if the command is successfully "consumed" */
+ static int qeth_l2_control_event(struct qeth_card *card,
+ 				 struct qeth_ipa_cmd *cmd)
+ {
+ 	switch (cmd->hdr.command) {
+ 	case IPA_CMD_SETBRIDGEPORT_OSA:
+ 	case IPA_CMD_SETBRIDGEPORT_IQD:
+ 		if (cmd->data.sbp.hdr.command_code ==
+ 		    IPA_SBP_BRIDGE_PORT_STATE_CHANGE) {
+ 			qeth_bridge_state_change(card, cmd);
+ 			return 0;
+ 		}
+ 
+ 		return 1;
+ 	case IPA_CMD_ADDRESS_CHANGE_NOTIF:
+ 		qeth_addr_change_event(card, cmd);
+ 		return 0;
+ 	default:
+ 		return 1;
+ 	}
+ }
+ 
+ const struct qeth_discipline qeth_l2_discipline = {
+ 	.devtype = &qeth_l2_devtype,
+ 	.setup = qeth_l2_probe_device,
+ 	.remove = qeth_l2_remove_device,
+ 	.set_online = qeth_l2_set_online,
+ 	.set_offline = qeth_l2_set_offline,
+ 	.do_ioctl = NULL,
+ 	.control_event_handler = qeth_l2_control_event,
+ };
+ EXPORT_SYMBOL_GPL(qeth_l2_discipline);
+ 
+ static int __init qeth_l2_init(void)
+ {
+ 	pr_info("register layer 2 discipline\n");
+ 	return 0;
+ }
+ 
+ static void __exit qeth_l2_exit(void)
+ {
+ 	pr_info("unregister layer 2 discipline\n");
+ }
+ 
++>>>>>>> 0d0e2b538c13 (s390/qeth: Remove pnso workaround)
  module_init(qeth_l2_init);
  module_exit(qeth_l2_exit);
  MODULE_AUTHOR("Frank Blaschka <frank.blaschka@de.ibm.com>");
* Unmerged path drivers/s390/net/qeth_l2_main.c
