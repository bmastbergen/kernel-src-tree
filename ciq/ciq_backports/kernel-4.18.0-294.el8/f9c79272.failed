bpf: Refactor to provide aux info to bpf_iter_init_seq_priv_t

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yonghong Song <yhs@fb.com>
commit f9c792729581bd8b8473af163e8ab426c2c61d89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f9c79272.failed

This patch refactored target bpf_iter_init_seq_priv_t callback
function to accept additional information. This will be needed
in later patches for map element targets since a particular
map should be passed to traverse elements for that particular
map. In the future, other information may be passed to target
as well, e.g., pid, cgroup id, etc. to customize the iterator.

	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200723184110.590156-1-yhs@fb.com
(cherry picked from commit f9c792729581bd8b8473af163e8ab426c2c61d89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/proc_net.c
#	include/linux/bpf.h
#	include/linux/proc_fs.h
#	kernel/bpf/bpf_iter.c
diff --cc fs/proc/proc_net.c
index a7b12435519e,ed8a6306990c..000000000000
--- a/fs/proc/proc_net.c
+++ b/fs/proc/proc_net.c
@@@ -89,14 -90,33 +89,36 @@@ static int seq_release_net(struct inod
  	return 0;
  }
  
 -static const struct proc_ops proc_net_seq_ops = {
 -	.proc_open	= seq_open_net,
 -	.proc_read	= seq_read,
 -	.proc_write	= proc_simple_write,
 -	.proc_lseek	= seq_lseek,
 -	.proc_release	= seq_release_net,
 +static const struct file_operations proc_net_seq_fops = {
 +	.open		= seq_open_net,
 +	.read		= seq_read,
 +	.write		= proc_simple_write,
 +	.llseek		= seq_lseek,
 +	.release	= seq_release_net,
  };
  
++<<<<<<< HEAD
++=======
+ int bpf_iter_init_seq_net(void *priv_data, struct bpf_iter_aux_info *aux)
+ {
+ #ifdef CONFIG_NET_NS
+ 	struct seq_net_private *p = priv_data;
+ 
+ 	p->net = get_net(current->nsproxy->net_ns);
+ #endif
+ 	return 0;
+ }
+ 
+ void bpf_iter_fini_seq_net(void *priv_data)
+ {
+ #ifdef CONFIG_NET_NS
+ 	struct seq_net_private *p = priv_data;
+ 
+ 	put_net(p->net);
+ #endif
+ }
+ 
++>>>>>>> f9c792729581 (bpf: Refactor to provide aux info to bpf_iter_init_seq_priv_t)
  struct proc_dir_entry *proc_create_net_data(const char *name, umode_t mode,
  		struct proc_dir_entry *parent, const struct seq_operations *ops,
  		unsigned int state_size, void *data)
diff --cc include/linux/bpf.h
index 2171a69591bc,ef52717336cf..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -39,6 -38,16 +40,19 @@@ struct bpf_iter_aux_info
  extern struct idr btf_idr;
  extern spinlock_t btf_idr_lock;
  
++<<<<<<< HEAD
++=======
+ typedef int (*bpf_iter_init_seq_priv_t)(void *private_data,
+ 					struct bpf_iter_aux_info *aux);
+ typedef void (*bpf_iter_fini_seq_priv_t)(void *private_data);
+ struct bpf_iter_seq_info {
+ 	const struct seq_operations *seq_ops;
+ 	bpf_iter_init_seq_priv_t init_seq_private;
+ 	bpf_iter_fini_seq_priv_t fini_seq_private;
+ 	u32 seq_priv_size;
+ };
+ 
++>>>>>>> f9c792729581 (bpf: Refactor to provide aux info to bpf_iter_init_seq_priv_t)
  /* map is generic key/value storage optionally accesible by eBPF programs */
  struct bpf_map_ops {
  	/* funcs callable from userspace (via syscall) */
@@@ -1148,19 -1195,36 +1162,26 @@@ struct bpf_link *bpf_link_get_from_fd(u
  int bpf_obj_pin_user(u32 ufd, const char __user *pathname);
  int bpf_obj_get_user(const char __user *pathname, int flags);
  
 -#define BPF_ITER_FUNC_PREFIX "bpf_iter_"
 -#define DEFINE_BPF_ITER_FUNC(target, args...)			\
 -	extern int bpf_iter_ ## target(args);			\
 -	int __init bpf_iter_ ## target(args) { return 0; }
 +typedef int (*bpf_iter_init_seq_priv_t)(void *private_data);
 +typedef void (*bpf_iter_fini_seq_priv_t)(void *private_data);
  
++<<<<<<< HEAD
++=======
+ struct bpf_iter_aux_info {
+ };
+ 
+ #define BPF_ITER_CTX_ARG_MAX 2
++>>>>>>> f9c792729581 (bpf: Refactor to provide aux info to bpf_iter_init_seq_priv_t)
  struct bpf_iter_reg {
  	const char *target;
 -	u32 ctx_arg_info_size;
 -	struct bpf_ctx_arg_aux ctx_arg_info[BPF_ITER_CTX_ARG_MAX];
 -	const struct bpf_iter_seq_info *seq_info;
 -};
 -
 -struct bpf_iter_meta {
 -	__bpf_md_ptr(struct seq_file *, seq);
 -	u64 session_id;
 -	u64 seq_num;
 +	const struct seq_operations *seq_ops;
 +	bpf_iter_init_seq_priv_t init_seq_private;
 +	bpf_iter_fini_seq_priv_t fini_seq_private;
 +	u32 seq_priv_size;
  };
  
 -int bpf_iter_reg_target(const struct bpf_iter_reg *reg_info);
 -void bpf_iter_unreg_target(const struct bpf_iter_reg *reg_info);
 -bool bpf_iter_prog_supported(struct bpf_prog *prog);
 -int bpf_iter_link_attach(const union bpf_attr *attr, struct bpf_prog *prog);
 -int bpf_iter_new_fd(struct bpf_link *link);
 -bool bpf_link_is_iter(struct bpf_link *link);
 -struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop);
 -int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx);
 +int bpf_iter_reg_target(struct bpf_iter_reg *reg_info);
 +void bpf_iter_unreg_target(const char *target);
  
  int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value);
  int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value);
diff --cc include/linux/proc_fs.h
index 626fc65c4336,2df965cd0974..000000000000
--- a/include/linux/proc_fs.h
+++ b/include/linux/proc_fs.h
@@@ -73,6 -131,20 +73,23 @@@ struct proc_dir_entry *proc_create_net_
  						    int (*show)(struct seq_file *, void *),
  						    proc_write_t write,
  						    void *data);
++<<<<<<< HEAD
++=======
+ extern struct pid *tgid_pidfd_to_pid(const struct file *file);
+ 
+ struct bpf_iter_aux_info;
+ extern int bpf_iter_init_seq_net(void *priv_data, struct bpf_iter_aux_info *aux);
+ extern void bpf_iter_fini_seq_net(void *priv_data);
+ 
+ #ifdef CONFIG_PROC_PID_ARCH_STATUS
+ /*
+  * The architecture which selects CONFIG_PROC_PID_ARCH_STATUS must
+  * provide proc_pid_arch_status() definition.
+  */
+ int proc_pid_arch_status(struct seq_file *m, struct pid_namespace *ns,
+ 			struct pid *pid, struct task_struct *task);
+ #endif /* CONFIG_PROC_PID_ARCH_STATUS */
++>>>>>>> f9c792729581 (bpf: Refactor to provide aux info to bpf_iter_init_seq_priv_t)
  
  #else /* CONFIG_PROC_FS */
  
diff --cc kernel/bpf/bpf_iter.c
index 5a8119d17d14,8fa94cb1b5a0..000000000000
--- a/kernel/bpf/bpf_iter.c
+++ b/kernel/bpf/bpf_iter.c
@@@ -57,3 -275,265 +57,268 @@@ void bpf_iter_unreg_target(const char *
  
  	WARN_ON(found == false);
  }
++<<<<<<< HEAD
++=======
+ 
+ static void cache_btf_id(struct bpf_iter_target_info *tinfo,
+ 			 struct bpf_prog *prog)
+ {
+ 	tinfo->btf_id = prog->aux->attach_btf_id;
+ }
+ 
+ bool bpf_iter_prog_supported(struct bpf_prog *prog)
+ {
+ 	const char *attach_fname = prog->aux->attach_func_name;
+ 	u32 prog_btf_id = prog->aux->attach_btf_id;
+ 	const char *prefix = BPF_ITER_FUNC_PREFIX;
+ 	struct bpf_iter_target_info *tinfo;
+ 	int prefix_len = strlen(prefix);
+ 	bool supported = false;
+ 
+ 	if (strncmp(attach_fname, prefix, prefix_len))
+ 		return false;
+ 
+ 	mutex_lock(&targets_mutex);
+ 	list_for_each_entry(tinfo, &targets, list) {
+ 		if (tinfo->btf_id && tinfo->btf_id == prog_btf_id) {
+ 			supported = true;
+ 			break;
+ 		}
+ 		if (!strcmp(attach_fname + prefix_len, tinfo->reg_info->target)) {
+ 			cache_btf_id(tinfo, prog);
+ 			supported = true;
+ 			break;
+ 		}
+ 	}
+ 	mutex_unlock(&targets_mutex);
+ 
+ 	if (supported) {
+ 		prog->aux->ctx_arg_info_size = tinfo->reg_info->ctx_arg_info_size;
+ 		prog->aux->ctx_arg_info = tinfo->reg_info->ctx_arg_info;
+ 	}
+ 
+ 	return supported;
+ }
+ 
+ static void bpf_iter_link_release(struct bpf_link *link)
+ {
+ }
+ 
+ static void bpf_iter_link_dealloc(struct bpf_link *link)
+ {
+ 	struct bpf_iter_link *iter_link =
+ 		container_of(link, struct bpf_iter_link, link);
+ 
+ 	kfree(iter_link);
+ }
+ 
+ static int bpf_iter_link_replace(struct bpf_link *link,
+ 				 struct bpf_prog *new_prog,
+ 				 struct bpf_prog *old_prog)
+ {
+ 	int ret = 0;
+ 
+ 	mutex_lock(&link_mutex);
+ 	if (old_prog && link->prog != old_prog) {
+ 		ret = -EPERM;
+ 		goto out_unlock;
+ 	}
+ 
+ 	if (link->prog->type != new_prog->type ||
+ 	    link->prog->expected_attach_type != new_prog->expected_attach_type ||
+ 	    link->prog->aux->attach_btf_id != new_prog->aux->attach_btf_id) {
+ 		ret = -EINVAL;
+ 		goto out_unlock;
+ 	}
+ 
+ 	old_prog = xchg(&link->prog, new_prog);
+ 	bpf_prog_put(old_prog);
+ 
+ out_unlock:
+ 	mutex_unlock(&link_mutex);
+ 	return ret;
+ }
+ 
+ static const struct bpf_link_ops bpf_iter_link_lops = {
+ 	.release = bpf_iter_link_release,
+ 	.dealloc = bpf_iter_link_dealloc,
+ 	.update_prog = bpf_iter_link_replace,
+ };
+ 
+ bool bpf_link_is_iter(struct bpf_link *link)
+ {
+ 	return link->ops == &bpf_iter_link_lops;
+ }
+ 
+ int bpf_iter_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)
+ {
+ 	struct bpf_link_primer link_primer;
+ 	struct bpf_iter_target_info *tinfo;
+ 	struct bpf_iter_link *link;
+ 	bool existed = false;
+ 	u32 prog_btf_id;
+ 	int err;
+ 
+ 	if (attr->link_create.target_fd || attr->link_create.flags)
+ 		return -EINVAL;
+ 
+ 	prog_btf_id = prog->aux->attach_btf_id;
+ 	mutex_lock(&targets_mutex);
+ 	list_for_each_entry(tinfo, &targets, list) {
+ 		if (tinfo->btf_id == prog_btf_id) {
+ 			existed = true;
+ 			break;
+ 		}
+ 	}
+ 	mutex_unlock(&targets_mutex);
+ 	if (!existed)
+ 		return -ENOENT;
+ 
+ 	link = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);
+ 	if (!link)
+ 		return -ENOMEM;
+ 
+ 	bpf_link_init(&link->link, BPF_LINK_TYPE_ITER, &bpf_iter_link_lops, prog);
+ 	link->tinfo = tinfo;
+ 
+ 	err  = bpf_link_prime(&link->link, &link_primer);
+ 	if (err) {
+ 		kfree(link);
+ 		return err;
+ 	}
+ 
+ 	return bpf_link_settle(&link_primer);
+ }
+ 
+ static void init_seq_meta(struct bpf_iter_priv_data *priv_data,
+ 			  struct bpf_iter_target_info *tinfo,
+ 			  struct bpf_prog *prog)
+ {
+ 	priv_data->tinfo = tinfo;
+ 	priv_data->prog = prog;
+ 	priv_data->session_id = atomic64_inc_return(&session_id);
+ 	priv_data->seq_num = 0;
+ 	priv_data->done_stop = false;
+ }
+ 
+ static int prepare_seq_file(struct file *file, struct bpf_iter_link *link)
+ {
+ 	struct bpf_iter_priv_data *priv_data;
+ 	struct bpf_iter_target_info *tinfo;
+ 	struct bpf_prog *prog;
+ 	u32 total_priv_dsize;
+ 	struct seq_file *seq;
+ 	int err = 0;
+ 
+ 	mutex_lock(&link_mutex);
+ 	prog = link->link.prog;
+ 	bpf_prog_inc(prog);
+ 	mutex_unlock(&link_mutex);
+ 
+ 	tinfo = link->tinfo;
+ 	total_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +
+ 			   tinfo->reg_info->seq_info->seq_priv_size;
+ 	priv_data = __seq_open_private(file, tinfo->reg_info->seq_info->seq_ops,
+ 				       total_priv_dsize);
+ 	if (!priv_data) {
+ 		err = -ENOMEM;
+ 		goto release_prog;
+ 	}
+ 
+ 	if (tinfo->reg_info->seq_info->init_seq_private) {
+ 		err = tinfo->reg_info->seq_info->init_seq_private(priv_data->target_private, NULL);
+ 		if (err)
+ 			goto release_seq_file;
+ 	}
+ 
+ 	init_seq_meta(priv_data, tinfo, prog);
+ 	seq = file->private_data;
+ 	seq->private = priv_data->target_private;
+ 
+ 	return 0;
+ 
+ release_seq_file:
+ 	seq_release_private(file->f_inode, file);
+ 	file->private_data = NULL;
+ release_prog:
+ 	bpf_prog_put(prog);
+ 	return err;
+ }
+ 
+ int bpf_iter_new_fd(struct bpf_link *link)
+ {
+ 	struct file *file;
+ 	unsigned int flags;
+ 	int err, fd;
+ 
+ 	if (link->ops != &bpf_iter_link_lops)
+ 		return -EINVAL;
+ 
+ 	flags = O_RDONLY | O_CLOEXEC;
+ 	fd = get_unused_fd_flags(flags);
+ 	if (fd < 0)
+ 		return fd;
+ 
+ 	file = anon_inode_getfile("bpf_iter", &bpf_iter_fops, NULL, flags);
+ 	if (IS_ERR(file)) {
+ 		err = PTR_ERR(file);
+ 		goto free_fd;
+ 	}
+ 
+ 	err = prepare_seq_file(file,
+ 			       container_of(link, struct bpf_iter_link, link));
+ 	if (err)
+ 		goto free_file;
+ 
+ 	fd_install(fd, file);
+ 	return fd;
+ 
+ free_file:
+ 	fput(file);
+ free_fd:
+ 	put_unused_fd(fd);
+ 	return err;
+ }
+ 
+ struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)
+ {
+ 	struct bpf_iter_priv_data *iter_priv;
+ 	struct seq_file *seq;
+ 	void *seq_priv;
+ 
+ 	seq = meta->seq;
+ 	if (seq->file->f_op != &bpf_iter_fops)
+ 		return NULL;
+ 
+ 	seq_priv = seq->private;
+ 	iter_priv = container_of(seq_priv, struct bpf_iter_priv_data,
+ 				 target_private);
+ 
+ 	if (in_stop && iter_priv->done_stop)
+ 		return NULL;
+ 
+ 	meta->session_id = iter_priv->session_id;
+ 	meta->seq_num = iter_priv->seq_num;
+ 
+ 	return iter_priv->prog;
+ }
+ 
+ int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)
+ {
+ 	int ret;
+ 
+ 	rcu_read_lock();
+ 	migrate_disable();
+ 	ret = BPF_PROG_RUN(prog, ctx);
+ 	migrate_enable();
+ 	rcu_read_unlock();
+ 
+ 	/* bpf program can only return 0 or 1:
+ 	 *  0 : okay
+ 	 *  1 : retry the same object
+ 	 * The bpf_iter_run_prog() return value
+ 	 * will be seq_ops->show() return value.
+ 	 */
+ 	return ret == 0 ? 0 : -EAGAIN;
+ }
++>>>>>>> f9c792729581 (bpf: Refactor to provide aux info to bpf_iter_init_seq_priv_t)
* Unmerged path fs/proc/proc_net.c
* Unmerged path include/linux/bpf.h
* Unmerged path include/linux/proc_fs.h
* Unmerged path kernel/bpf/bpf_iter.c
diff --git a/kernel/bpf/task_iter.c b/kernel/bpf/task_iter.c
index 135ad297b957..578a1eb3f93e 100644
--- a/kernel/bpf/task_iter.c
+++ b/kernel/bpf/task_iter.c
@@ -290,7 +290,7 @@ static void task_file_seq_stop(struct seq_file *seq, void *v)
 	}
 }
 
-static int init_seq_pidns(void *priv_data)
+static int init_seq_pidns(void *priv_data, struct bpf_iter_aux_info *aux)
 {
 	struct bpf_iter_seq_task_common *common = priv_data;
 
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index c27942535c70..5218024871df 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -2836,7 +2836,7 @@ static struct pernet_operations __net_initdata tcp_sk_ops = {
 DEFINE_BPF_ITER_FUNC(tcp, struct bpf_iter_meta *meta,
 		     struct sock_common *sk_common, uid_t uid)
 
-static int bpf_iter_init_tcp(void *priv_data)
+static int bpf_iter_init_tcp(void *priv_data, struct bpf_iter_aux_info *aux)
 {
 	struct tcp_iter_state *st = priv_data;
 	struct tcp_seq_afinfo *afinfo;
@@ -2848,7 +2848,7 @@ static int bpf_iter_init_tcp(void *priv_data)
 
 	afinfo->family = AF_UNSPEC;
 	st->bpf_seq_afinfo = afinfo;
-	ret = bpf_iter_init_seq_net(priv_data);
+	ret = bpf_iter_init_seq_net(priv_data, aux);
 	if (ret)
 		kfree(afinfo);
 	return ret;
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 98e5d6011292..57e47a231842 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -3102,7 +3102,7 @@ static struct pernet_operations __net_initdata udp_sysctl_ops = {
 DEFINE_BPF_ITER_FUNC(udp, struct bpf_iter_meta *meta,
 		     struct udp_sock *udp_sk, uid_t uid, int bucket)
 
-static int bpf_iter_init_udp(void *priv_data)
+static int bpf_iter_init_udp(void *priv_data, struct bpf_iter_aux_info *aux)
 {
 	struct udp_iter_state *st = priv_data;
 	struct udp_seq_afinfo *afinfo;
@@ -3115,7 +3115,7 @@ static int bpf_iter_init_udp(void *priv_data)
 	afinfo->family = AF_UNSPEC;
 	afinfo->udp_table = &udp_table;
 	st->bpf_seq_afinfo = afinfo;
-	ret = bpf_iter_init_seq_net(priv_data);
+	ret = bpf_iter_init_seq_net(priv_data, aux);
 	if (ret)
 		kfree(afinfo);
 	return ret;
