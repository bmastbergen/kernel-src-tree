x86/sev-es: Adjust #VC IST Stack on entering NMI handler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] sev-es: Adjust #VC IST Stack on entering NMI handler (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 96.30%
commit-author Joerg Roedel <jroedel@suse.de>
commit 315562c9af3d583502b35c4b223a08d95ce69864
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/315562c9.failed

When an NMI hits in the #VC handler entry code before it has switched to
another stack, any subsequent #VC exception in the NMI code-path will
overwrite the interrupted #VC handler's stack.

Make sure this doesn't happen by explicitly adjusting the #VC IST entry
in the NMI handler for the time it can cause #VC exceptions.

 [ bp: Touchups, spelling fixes. ]

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20200907131613.12703-44-joro@8bytes.org
(cherry picked from commit 315562c9af3d583502b35c4b223a08d95ce69864)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/sev-es.h
#	arch/x86/kernel/nmi.c
#	arch/x86/kernel/sev-es.c
diff --cc arch/x86/kernel/nmi.c
index 086cf1d1d71d,4c89c4d3cb82..000000000000
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@@ -501,35 -489,27 +502,47 @@@ do_nmi(struct pt_regs *regs, long error
  	this_cpu_write(nmi_cr2, read_cr2());
  nmi_restart:
  
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_64
 +	/*
 +	 * If we interrupted a breakpoint, it is possible that
 +	 * the nmi handler will have breakpoints too. We need to
 +	 * change the IDT such that breakpoints that happen here
 +	 * continue to use the NMI stack.
 +	 */
 +	if (unlikely(is_debug_stack(regs->sp))) {
 +		debug_stack_set_zero();
 +		this_cpu_write(update_debug_stack, 1);
 +	}
 +#endif
++=======
+ 	/*
+ 	 * Needs to happen before DR7 is accessed, because the hypervisor can
+ 	 * intercept DR7 reads/writes, turning those into #VC exceptions.
+ 	 */
+ 	sev_es_ist_enter(regs);
+ 
+ 	this_cpu_write(nmi_dr7, local_db_save());
++>>>>>>> 315562c9af3d (x86/sev-es: Adjust #VC IST Stack on entering NMI handler)
  
 -	irq_state = idtentry_enter_nmi(regs);
 +	nmi_enter();
  
  	inc_irq_stat(__nmi_count);
  
  	if (!ignore_nmis)
  		default_do_nmi(regs);
  
 -	idtentry_exit_nmi(regs, irq_state);
 +	nmi_exit();
  
 -	local_db_restore(this_cpu_read(nmi_dr7));
 +#ifdef CONFIG_X86_64
 +	if (unlikely(this_cpu_read(update_debug_stack))) {
 +		debug_stack_reset();
 +		this_cpu_write(update_debug_stack, 0);
 +	}
 +#endif
  
+ 	sev_es_ist_exit();
+ 
  	if (unlikely(this_cpu_read(nmi_cr2) != read_cr2()))
  		write_cr2(this_cpu_read(nmi_cr2));
  	if (this_cpu_dec_return(nmi_state))
* Unmerged path arch/x86/include/asm/sev-es.h
* Unmerged path arch/x86/kernel/sev-es.c
* Unmerged path arch/x86/include/asm/sev-es.h
* Unmerged path arch/x86/kernel/nmi.c
* Unmerged path arch/x86/kernel/sev-es.c
