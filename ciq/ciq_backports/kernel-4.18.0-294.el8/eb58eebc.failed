net: openvswitch: set max limitation to meters

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] openvswitch: set max limitation to meters (Eelco Chaudron) [1888576]
Rebuild_FUZZ: 94.25%
commit-author Tonghao Zhang <xiangxia.m.yue@gmail.com>
commit eb58eebc7fb5e23c9cc7d557c0a9236630591526
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/eb58eebc.failed

Don't allow user to create meter unlimitedly, which may cause
to consume a large amount ofÂ kernel memory. The max number
supported is decided by physical memory and 20K meters as default.

	Cc: Pravin B Shelar <pshelar@ovn.org>
	Cc: Andy Zhou <azhou@ovn.org>
	Signed-off-by: Tonghao Zhang <xiangxia.m.yue@gmail.com>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eb58eebc7fb5e23c9cc7d557c0a9236630591526)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/meter.c
#	net/openvswitch/meter.h
diff --cc net/openvswitch/meter.c
index bb67238f0340,372f4565872d..000000000000
--- a/net/openvswitch/meter.c
+++ b/net/openvswitch/meter.c
@@@ -71,18 -66,147 +72,111 @@@ static struct dp_meter *lookup_meter(co
  	return NULL;
  }
  
 -static struct dp_meter_instance *dp_meter_instance_alloc(const u32 size)
 +static void attach_meter(struct datapath *dp, struct dp_meter *meter)
  {
 -	struct dp_meter_instance *ti;
 -
 -	ti = kvzalloc(sizeof(*ti) +
 -		      sizeof(struct dp_meter *) * size,
 -		      GFP_KERNEL);
 -	if (!ti)
 -		return NULL;
 -
 -	ti->n_meters = size;
 +	struct hlist_head *head = meter_hash_bucket(dp, meter->id);
  
 -	return ti;
 +	hlist_add_head_rcu(&meter->dp_hash_node, head);
  }
  
 -static void dp_meter_instance_free(struct dp_meter_instance *ti)
 +static void detach_meter(struct dp_meter *meter)
  {
++<<<<<<< HEAD
++=======
+ 	kvfree(ti);
+ }
+ 
+ static void dp_meter_instance_free_rcu(struct rcu_head *rcu)
+ {
+ 	struct dp_meter_instance *ti;
+ 
+ 	ti = container_of(rcu, struct dp_meter_instance, rcu);
+ 	kvfree(ti);
+ }
+ 
+ static int
+ dp_meter_instance_realloc(struct dp_meter_table *tbl, u32 size)
+ {
+ 	struct dp_meter_instance *ti = rcu_dereference_ovsl(tbl->ti);
+ 	int n_meters = min(size, ti->n_meters);
+ 	struct dp_meter_instance *new_ti;
+ 	int i;
+ 
+ 	new_ti = dp_meter_instance_alloc(size);
+ 	if (!new_ti)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < n_meters; i++)
+ 		new_ti->dp_meters[i] =
+ 			rcu_dereference_ovsl(ti->dp_meters[i]);
+ 
+ 	rcu_assign_pointer(tbl->ti, new_ti);
+ 	call_rcu(&ti->rcu, dp_meter_instance_free_rcu);
+ 
+ 	return 0;
+ }
+ 
+ static void dp_meter_instance_insert(struct dp_meter_instance *ti,
+ 				     struct dp_meter *meter)
+ {
+ 	u32 hash;
+ 
+ 	hash = meter_hash(ti, meter->id);
+ 	rcu_assign_pointer(ti->dp_meters[hash], meter);
+ }
+ 
+ static void dp_meter_instance_remove(struct dp_meter_instance *ti,
+ 				     struct dp_meter *meter)
+ {
+ 	u32 hash;
+ 
+ 	hash = meter_hash(ti, meter->id);
+ 	RCU_INIT_POINTER(ti->dp_meters[hash], NULL);
+ }
+ 
+ static int attach_meter(struct dp_meter_table *tbl, struct dp_meter *meter)
+ {
+ 	struct dp_meter_instance *ti = rcu_dereference_ovsl(tbl->ti);
+ 	u32 hash = meter_hash(ti, meter->id);
+ 	int err;
+ 
+ 	/* In generally, slots selected should be empty, because
+ 	 * OvS uses id-pool to fetch a available id.
+ 	 */
+ 	if (unlikely(rcu_dereference_ovsl(ti->dp_meters[hash])))
+ 		return -EBUSY;
+ 
+ 	dp_meter_instance_insert(ti, meter);
+ 
+ 	/* That function is thread-safe. */
+ 	tbl->count++;
+ 	if (tbl->count >= tbl->max_meters_allowed) {
+ 		err = -EFBIG;
+ 		goto attach_err;
+ 	}
+ 
+ 	if (tbl->count >= ti->n_meters &&
+ 	    dp_meter_instance_realloc(tbl, ti->n_meters * 2)) {
+ 		err = -ENOMEM;
+ 		goto attach_err;
+ 	}
+ 
+ 	return 0;
+ 
+ attach_err:
+ 	dp_meter_instance_remove(ti, meter);
+ 	tbl->count--;
+ 	return err;
+ }
+ 
+ static int detach_meter(struct dp_meter_table *tbl, struct dp_meter *meter)
+ {
+ 	struct dp_meter_instance *ti;
+ 
++>>>>>>> eb58eebc7fb5 (net: openvswitch: set max limitation to meters)
  	ASSERT_OVSL();
 -	if (!meter)
 -		return 0;
 -
 -	ti = rcu_dereference_ovsl(tbl->ti);
 -	dp_meter_instance_remove(ti, meter);
 -
 -	tbl->count--;
 -
 -	/* Shrink the meter array if necessary. */
 -	if (ti->n_meters > DP_METER_ARRAY_SIZE_MIN &&
 -	    tbl->count <= (ti->n_meters / 4)) {
 -		int half_size = ti->n_meters / 2;
 -		int i;
 -
 -		/* Avoid hash collision, don't move slots to other place.
 -		 * Make sure there are no references of meters in array
 -		 * which will be released.
 -		 */
 -		for (i = half_size; i < ti->n_meters; i++)
 -			if (rcu_dereference_ovsl(ti->dp_meters[i]))
 -				goto out;
 -
 -		if (dp_meter_instance_realloc(tbl, half_size))
 -			goto shrink_err;
 -	}
 -
 -out:
 -	return 0;
 -
 -shrink_err:
 -	dp_meter_instance_insert(ti, meter);
 -	tbl->count++;
 -	return -ENOMEM;
 +	if (meter)
 +		hlist_del_rcu(&meter->dp_hash_node);
  }
  
  static struct sk_buff *
@@@ -572,18 -722,29 +681,40 @@@ struct genl_family dp_meter_genl_famil
  
  int ovs_meters_init(struct datapath *dp)
  {
++<<<<<<< HEAD
 +	int i;
++=======
+ 	struct dp_meter_table *tbl = &dp->meter_tbl;
+ 	struct dp_meter_instance *ti;
+ 	unsigned long free_mem_bytes;
++>>>>>>> eb58eebc7fb5 (net: openvswitch: set max limitation to meters)
 +
 +	dp->meters = kmalloc_array(METER_HASH_BUCKETS,
 +				   sizeof(struct hlist_head), GFP_KERNEL);
  
 -	ti = dp_meter_instance_alloc(DP_METER_ARRAY_SIZE_MIN);
 -	if (!ti)
 +	if (!dp->meters)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	for (i = 0; i < METER_HASH_BUCKETS; i++)
 +		INIT_HLIST_HEAD(&dp->meters[i]);
++=======
+ 	/* Allow meters in a datapath to use ~3.12% of physical memory. */
+ 	free_mem_bytes = nr_free_buffer_pages() * (PAGE_SIZE >> 5);
+ 	tbl->max_meters_allowed = min(free_mem_bytes / sizeof(struct dp_meter),
+ 				      DP_METER_NUM_MAX);
+ 	if (!tbl->max_meters_allowed)
+ 		goto out_err;
+ 
+ 	rcu_assign_pointer(tbl->ti, ti);
+ 	tbl->count = 0;
++>>>>>>> eb58eebc7fb5 (net: openvswitch: set max limitation to meters)
  
  	return 0;
+ 
+ out_err:
+ 	dp_meter_instance_free(ti);
+ 	return -ENOMEM;
  }
  
  void ovs_meters_exit(struct datapath *dp)
diff --cc net/openvswitch/meter.h
index 964ace2650f8,61a3ca43cd77..000000000000
--- a/net/openvswitch/meter.h
+++ b/net/openvswitch/meter.h
@@@ -21,6 -19,8 +21,11 @@@
  struct datapath;
  
  #define DP_MAX_BANDS		1
++<<<<<<< HEAD
++=======
+ #define DP_METER_ARRAY_SIZE_MIN	BIT_ULL(10)
+ #define DP_METER_NUM_MAX	(200000UL)
++>>>>>>> eb58eebc7fb5 (net: openvswitch: set max limitation to meters)
  
  struct dp_meter_band {
  	u32 type;
@@@ -45,6 -42,18 +50,21 @@@ struct dp_meter 
  	struct dp_meter_band bands[];
  };
  
++<<<<<<< HEAD
++=======
+ struct dp_meter_instance {
+ 	struct rcu_head rcu;
+ 	u32 n_meters;
+ 	struct dp_meter __rcu *dp_meters[];
+ };
+ 
+ struct dp_meter_table {
+ 	struct dp_meter_instance __rcu *ti;
+ 	u32 count;
+ 	u32 max_meters_allowed;
+ };
+ 
++>>>>>>> eb58eebc7fb5 (net: openvswitch: set max limitation to meters)
  extern struct genl_family dp_meter_genl_family;
  int ovs_meters_init(struct datapath *dp);
  void ovs_meters_exit(struct datapath *dp);
* Unmerged path net/openvswitch/meter.c
* Unmerged path net/openvswitch/meter.h
