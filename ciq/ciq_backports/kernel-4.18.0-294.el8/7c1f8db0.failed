powerpc/ptrace: split out TRANSACTIONAL_MEM related functions.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [powerpc] powerpc/ptrace: split out TRANSACTIONAL_MEM related functions (Desnes Augusto Nunes do Rosario) [1854528]
Rebuild_FUZZ: 99.19%
commit-author Christophe Leroy <christophe.leroy@c-s.fr>
commit 7c1f8db019f82e5f81bf1a84fd8b064d5d01652a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7c1f8db0.failed

Move TRANSACTIONAL_MEM functions out of ptrace.c, into
ptrace-tm.c

	Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/2d0ef3bb2610c0344bd42252c7134f429818c000.1582848567.git.christophe.leroy@c-s.fr
(cherry picked from commit 7c1f8db019f82e5f81bf1a84fd8b064d5d01652a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/ptrace-tm.c
#	arch/powerpc/kernel/ptrace.c
#	arch/powerpc/kernel/ptrace/Makefile
#	arch/powerpc/kernel/ptrace/ptrace-decl.h
diff --cc arch/powerpc/kernel/ptrace.c
index c48b84f0c17a,2ed032f00a19..000000000000
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@@ -99,31 -96,6 +94,34 @@@ static const struct pt_regs_offset rego
  	REG_OFFSET_END,
  };
  
++<<<<<<< HEAD:arch/powerpc/kernel/ptrace.c
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +static void flush_tmregs_to_thread(struct task_struct *tsk)
 +{
 +	/*
 +	 * If task is not current, it will have been flushed already to
 +	 * it's thread_struct during __switch_to().
 +	 *
 +	 * A reclaim flushes ALL the state or if not in TM save TM SPRs
 +	 * in the appropriate thread structures from live.
 +	 */
 +
 +	if ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))
 +		return;
 +
 +	if (MSR_TM_SUSPENDED(mfmsr())) {
 +		tm_reclaim_current(TM_CAUSE_SIGNAL);
 +	} else {
 +		tm_enable();
 +		tm_save_sprs(&(tsk->thread));
 +	}
 +}
 +#else
 +static inline void flush_tmregs_to_thread(struct task_struct *tsk) { }
 +#endif
 +
++=======
++>>>>>>> 7c1f8db019f8 (powerpc/ptrace: split out TRANSACTIONAL_MEM related functions.):arch/powerpc/kernel/ptrace/ptrace.c
  /**
   * regs_query_register_offset() - query register offset from its name
   * @name:	the name of a register
@@@ -156,1301 -128,55 +154,1264 @@@ const char *regs_query_register_name(un
  	return NULL;
  }
  
 -/*
 - * does not yet catch signals sent when the child dies.
 - * in exit.c or in signal.c.
 - */
 +/*
 + * does not yet catch signals sent when the child dies.
 + * in exit.c or in signal.c.
 + */
 +
- /*
-  * Set of msr bits that gdb can change on behalf of a process.
-  */
- #ifdef CONFIG_PPC_ADV_DEBUG_REGS
- #define MSR_DEBUGCHANGE	0
- #else
- #define MSR_DEBUGCHANGE	(MSR_SE | MSR_BE)
- #endif
- 
- /*
-  * Max register writeable via put_reg
-  */
- #ifdef CONFIG_PPC32
- #define PT_MAX_PUT_REG	PT_MQ
- #else
- #define PT_MAX_PUT_REG	PT_CCR
- #endif
- 
 +static unsigned long get_user_msr(struct task_struct *task)
 +{
 +	return task->thread.regs->msr | task->thread.fpexc_mode;
 +}
 +
 +static int set_user_msr(struct task_struct *task, unsigned long msr)
 +{
 +	task->thread.regs->msr &= ~MSR_DEBUGCHANGE;
 +	task->thread.regs->msr |= msr & MSR_DEBUGCHANGE;
 +	return 0;
 +}
 +
- #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
- static unsigned long get_user_ckpt_msr(struct task_struct *task)
- {
- 	return task->thread.ckpt_regs.msr | task->thread.fpexc_mode;
- }
- 
- static int set_user_ckpt_msr(struct task_struct *task, unsigned long msr)
- {
- 	task->thread.ckpt_regs.msr &= ~MSR_DEBUGCHANGE;
- 	task->thread.ckpt_regs.msr |= msr & MSR_DEBUGCHANGE;
- 	return 0;
- }
- 
- static int set_user_ckpt_trap(struct task_struct *task, unsigned long trap)
- {
- 	task->thread.ckpt_regs.trap = trap & 0xfff0;
- 	return 0;
- }
- #endif
- 
 +#ifdef CONFIG_PPC64
 +static int get_user_dscr(struct task_struct *task, unsigned long *data)
 +{
 +	*data = task->thread.dscr;
 +	return 0;
 +}
 +
 +static int set_user_dscr(struct task_struct *task, unsigned long dscr)
 +{
 +	task->thread.dscr = dscr;
 +	task->thread.dscr_inherit = 1;
 +	return 0;
 +}
 +#else
 +static int get_user_dscr(struct task_struct *task, unsigned long *data)
 +{
 +	return -EIO;
 +}
 +
 +static int set_user_dscr(struct task_struct *task, unsigned long dscr)
 +{
 +	return -EIO;
 +}
 +#endif
 +
 +/*
 + * We prevent mucking around with the reserved area of trap
 + * which are used internally by the kernel.
 + */
 +static int set_user_trap(struct task_struct *task, unsigned long trap)
 +{
 +	task->thread.regs->trap = trap & 0xfff0;
 +	return 0;
 +}
 +
 +/*
 + * Get contents of register REGNO in task TASK.
 + */
 +int ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)
 +{
 +	unsigned int regs_max;
 +
 +	if ((task->thread.regs == NULL) || !data)
 +		return -EIO;
 +
 +	if (regno == PT_MSR) {
 +		*data = get_user_msr(task);
 +		return 0;
 +	}
 +
 +	if (regno == PT_DSCR)
 +		return get_user_dscr(task, data);
 +
 +	/*
 +	 * softe copies paca->irq_soft_mask variable state. Since irq_soft_mask is
 +	 * no more used as a flag, lets force usr to alway see the softe value as 1
 +	 * which means interrupts are not soft disabled.
 +	 */
 +	if (IS_ENABLED(CONFIG_PPC64) && regno == PT_SOFTE) {
 +		*data = 1;
 +		return  0;
 +	}
 +
 +	regs_max = sizeof(struct pt_regs) / sizeof(unsigned long);
 +	if (regno < regs_max) {
 +		regno = array_index_nospec(regno, regs_max);
 +		*data = ((unsigned long *)task->thread.regs)[regno];
 +		return 0;
 +	}
 +
 +	return -EIO;
 +}
 +
 +/*
 + * Write contents of register REGNO in task TASK.
 + */
 +int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)
 +{
 +	if (task->thread.regs == NULL)
 +		return -EIO;
 +
 +	if (regno == PT_MSR)
 +		return set_user_msr(task, data);
 +	if (regno == PT_TRAP)
 +		return set_user_trap(task, data);
 +	if (regno == PT_DSCR)
 +		return set_user_dscr(task, data);
 +
 +	if (regno <= PT_MAX_PUT_REG) {
 +		regno = array_index_nospec(regno, PT_MAX_PUT_REG + 1);
 +		((unsigned long *)task->thread.regs)[regno] = data;
 +		return 0;
 +	}
 +	return -EIO;
 +}
 +
 +static int gpr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +	int i, ret;
 +
 +	if (target->thread.regs == NULL)
 +		return -EIO;
 +
 +	if (!FULL_REGS(target->thread.regs)) {
 +		/* We have a partial register set.  Fill 14-31 with bogus values */
 +		for (i = 14; i < 32; i++)
 +			target->thread.regs->gpr[i] = NV_REG_POISON;
 +	}
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  target->thread.regs,
 +				  0, offsetof(struct pt_regs, msr));
 +	if (!ret) {
 +		unsigned long msr = get_user_msr(target);
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,
 +					  offsetof(struct pt_regs, msr),
 +					  offsetof(struct pt_regs, msr) +
 +					  sizeof(msr));
 +	}
 +
 +	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 +		     offsetof(struct pt_regs, msr) + sizeof(long));
 +
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					  &target->thread.regs->orig_gpr3,
 +					  offsetof(struct pt_regs, orig_gpr3),
 +					  sizeof(struct pt_regs));
 +	if (!ret)
 +		ret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,
 +					       sizeof(struct pt_regs), -1);
 +
 +	return ret;
 +}
 +
 +static int gpr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +	unsigned long reg;
 +	int ret;
 +
 +	if (target->thread.regs == NULL)
 +		return -EIO;
 +
 +	CHECK_FULL_REGS(target->thread.regs);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 target->thread.regs,
 +				 0, PT_MSR * sizeof(reg));
 +
 +	if (!ret && count > 0) {
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 +					 PT_MSR * sizeof(reg),
 +					 (PT_MSR + 1) * sizeof(reg));
 +		if (!ret)
 +			ret = set_user_msr(target, reg);
 +	}
 +
 +	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 +		     offsetof(struct pt_regs, msr) + sizeof(long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					 &target->thread.regs->orig_gpr3,
 +					 PT_ORIG_R3 * sizeof(reg),
 +					 (PT_MAX_PUT_REG + 1) * sizeof(reg));
 +
 +	if (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)
 +		ret = user_regset_copyin_ignore(
 +			&pos, &count, &kbuf, &ubuf,
 +			(PT_MAX_PUT_REG + 1) * sizeof(reg),
 +			PT_TRAP * sizeof(reg));
 +
 +	if (!ret && count > 0) {
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 +					 PT_TRAP * sizeof(reg),
 +					 (PT_TRAP + 1) * sizeof(reg));
 +		if (!ret)
 +			ret = set_user_trap(target, reg);
 +	}
 +
 +	if (!ret)
 +		ret = user_regset_copyin_ignore(
 +			&pos, &count, &kbuf, &ubuf,
 +			(PT_TRAP + 1) * sizeof(reg), -1);
 +
 +	return ret;
 +}
 +
++<<<<<<< HEAD:arch/powerpc/kernel/ptrace.c
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last checkpointed
 + * value of all FPR registers for the current transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + * };
 + */
 +static int fpr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +#ifdef CONFIG_VSX
 +	u64 buf[33];
 +	int i;
 +
 +	flush_fp_to_thread(target);
 +
 +	/* copy to local buffer then write that out */
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.TS_FPR(i);
 +	buf[32] = target->thread.fp_state.fpscr;
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +#else
 +	BUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=
 +		     offsetof(struct thread_fp_state, fpr[32]));
 +
 +	flush_fp_to_thread(target);
 +
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				   &target->thread.fp_state, 0, -1);
 +#endif
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last checkpointed
 + * value of all FPR registers for the current transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + * };
 + *
 + */
 +static int fpr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +#ifdef CONFIG_VSX
 +	u64 buf[33];
 +	int i;
 +
 +	flush_fp_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.TS_FPR(i);
 +	buf[32] = target->thread.fp_state.fpscr;
 +
 +	/* copy to local buffer then write that out */
 +	i = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +	if (i)
 +		return i;
 +
 +	for (i = 0; i < 32 ; i++)
 +		target->thread.TS_FPR(i) = buf[i];
 +	target->thread.fp_state.fpscr = buf[32];
 +	return 0;
 +#else
 +	BUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=
 +		     offsetof(struct thread_fp_state, fpr[32]));
 +
 +	flush_fp_to_thread(target);
 +
 +	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.fp_state, 0, -1);
 +#endif
 +}
 +
 +#ifdef CONFIG_ALTIVEC
 +/*
 + * Get/set all the altivec registers vr0..vr31, vscr, vrsave, in one go.
 + * The transfer totals 34 quadword.  Quadwords 0-31 contain the
 + * corresponding vector registers.  Quadword 32 contains the vscr as the
 + * last word (offset 12) within that quadword.  Quadword 33 contains the
 + * vrsave as the first word (offset 0) within the quadword.
 + *
 + * This definition of the VMX state is compatible with the current PPC32
 + * ptrace interface.  This allows signal handling and ptrace to use the
 + * same structures.  This also simplifies the implementation of a bi-arch
 + * (combined (32- and 64-bit) gdb.
 + */
 +
 +static int vr_active(struct task_struct *target,
 +		     const struct user_regset *regset)
 +{
 +	flush_altivec_to_thread(target);
 +	return target->thread.used_vr ? regset->n : 0;
 +}
 +
 +/*
 + * Regardless of transactions, 'vr_state' holds the current running
 + * value of all the VMX registers and 'ckvr_state' holds the last
 + * checkpointed value of all the VMX registers for the current
 + * transaction to fall back on in case it aborts.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + * };
 + */
 +static int vr_get(struct task_struct *target, const struct user_regset *regset,
 +		  unsigned int pos, unsigned int count,
 +		  void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_altivec_to_thread(target);
 +
 +	BUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=
 +		     offsetof(struct thread_vr_state, vr[32]));
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.vr_state, 0,
 +				  33 * sizeof(vector128));
 +	if (!ret) {
 +		/*
 +		 * Copy out only the low-order word of vrsave.
 +		 */
 +		int start, end;
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +
 +		vrsave.word = target->thread.vrsave;
 +
 +		start = 33 * sizeof(vector128);
 +		end = start + sizeof(vrsave);
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,
 +					  start, end);
 +	}
 +
 +	return ret;
 +}
 +
 +/*
 + * Regardless of transactions, 'vr_state' holds the current running
 + * value of all the VMX registers and 'ckvr_state' holds the last
 + * checkpointed value of all the VMX registers for the current
 + * transaction to fall back on in case it aborts.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + * };
 + */
 +static int vr_set(struct task_struct *target, const struct user_regset *regset,
 +		  unsigned int pos, unsigned int count,
 +		  const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_altivec_to_thread(target);
 +
 +	BUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=
 +		     offsetof(struct thread_vr_state, vr[32]));
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &target->thread.vr_state, 0,
 +				 33 * sizeof(vector128));
 +	if (!ret && count > 0) {
 +		/*
 +		 * We use only the first word of vrsave.
 +		 */
 +		int start, end;
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +
 +		vrsave.word = target->thread.vrsave;
 +
 +		start = 33 * sizeof(vector128);
 +		end = start + sizeof(vrsave);
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,
 +					 start, end);
 +		if (!ret)
 +			target->thread.vrsave = vrsave.word;
 +	}
 +
 +	return ret;
 +}
 +#endif /* CONFIG_ALTIVEC */
 +
 +#ifdef CONFIG_VSX
 +/*
 + * Currently to set and and get all the vsx state, you need to call
 + * the fp and VMX calls as well.  This only get/sets the lower 32
 + * 128bit VSX registers.
 + */
 +
 +static int vsr_active(struct task_struct *target,
 +		      const struct user_regset *regset)
 +{
 +	flush_vsx_to_thread(target);
 +	return target->thread.used_vsr ? regset->n : 0;
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last
 + * checkpointed value of all FPR registers for the current
 + * transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	vsx[32];
 + * };
 + */
 +static int vsr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret, i;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  buf, 0, 32 * sizeof(double));
 +
 +	return ret;
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last
 + * checkpointed value of all FPR registers for the current
 + * transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	vsx[32];
 + * };
 + */
 +static int vsr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret,i;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 buf, 0, 32 * sizeof(double));
 +	if (!ret)
 +		for (i = 0; i < 32 ; i++)
 +			target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];
 +
 +	return ret;
 +}
 +#endif /* CONFIG_VSX */
 +
 +#ifdef CONFIG_SPE
 +
 +/*
 + * For get_evrregs/set_evrregs functions 'data' has the following layout:
 + *
 + * struct {
 + *   u32 evr[32];
 + *   u64 acc;
 + *   u32 spefscr;
 + * }
 + */
 +
 +static int evr_active(struct task_struct *target,
 +		      const struct user_regset *regset)
 +{
 +	flush_spe_to_thread(target);
 +	return target->thread.used_spe ? regset->n : 0;
 +}
 +
 +static int evr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_spe_to_thread(target);
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.evr,
 +				  0, sizeof(target->thread.evr));
 +
 +	BUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=
 +		     offsetof(struct thread_struct, spefscr));
 +
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					  &target->thread.acc,
 +					  sizeof(target->thread.evr), -1);
 +
 +	return ret;
 +}
 +
 +static int evr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_spe_to_thread(target);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &target->thread.evr,
 +				 0, sizeof(target->thread.evr));
 +
 +	BUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=
 +		     offsetof(struct thread_struct, spefscr));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					 &target->thread.acc,
 +					 sizeof(target->thread.evr), -1);
 +
 +	return ret;
 +}
 +#endif /* CONFIG_SPE */
 +
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +/**
 + * tm_cgpr_active - get active number of registers in CGPR
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks for the active number of available
 + * regisers in transaction checkpointed GPR category.
 + */
 +static int tm_cgpr_active(struct task_struct *target,
 +			  const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return 0;
 +
 +	return regset->n;
 +}
 +
 +/**
 + * tm_cgpr_get - get CGPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets transaction checkpointed GPR registers.
 + *
 + * When the transaction is active, 'ckpt_regs' holds all the checkpointed
 + * GPR register values for the current transaction to fall back on if it
 + * aborts in between. This function gets those checkpointed GPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	struct pt_regs ckpt_regs;
 + * };
 + */
 +static int tm_cgpr_get(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.ckpt_regs,
 +				  0, offsetof(struct pt_regs, msr));
 +	if (!ret) {
 +		unsigned long msr = get_user_ckpt_msr(target);
 +
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,
 +					  offsetof(struct pt_regs, msr),
 +					  offsetof(struct pt_regs, msr) +
 +					  sizeof(msr));
 +	}
 +
 +	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 +		     offsetof(struct pt_regs, msr) + sizeof(long));
 +
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					  &target->thread.ckpt_regs.orig_gpr3,
 +					  offsetof(struct pt_regs, orig_gpr3),
 +					  sizeof(struct pt_regs));
 +	if (!ret)
 +		ret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,
 +					       sizeof(struct pt_regs), -1);
 +
 +	return ret;
 +}
 +
 +/*
 + * tm_cgpr_set - set the CGPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets in transaction checkpointed GPR registers.
 + *
 + * When the transaction is active, 'ckpt_regs' holds the checkpointed
 + * GPR register values for the current transaction to fall back on if it
 + * aborts in between. This function sets those checkpointed GPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	struct pt_regs ckpt_regs;
 + * };
 + */
 +static int tm_cgpr_set(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			const void *kbuf, const void __user *ubuf)
 +{
 +	unsigned long reg;
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &target->thread.ckpt_regs,
 +				 0, PT_MSR * sizeof(reg));
 +
 +	if (!ret && count > 0) {
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 +					 PT_MSR * sizeof(reg),
 +					 (PT_MSR + 1) * sizeof(reg));
 +		if (!ret)
 +			ret = set_user_ckpt_msr(target, reg);
 +	}
 +
 +	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 +		     offsetof(struct pt_regs, msr) + sizeof(long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					 &target->thread.ckpt_regs.orig_gpr3,
 +					 PT_ORIG_R3 * sizeof(reg),
 +					 (PT_MAX_PUT_REG + 1) * sizeof(reg));
 +
 +	if (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)
 +		ret = user_regset_copyin_ignore(
 +			&pos, &count, &kbuf, &ubuf,
 +			(PT_MAX_PUT_REG + 1) * sizeof(reg),
 +			PT_TRAP * sizeof(reg));
 +
 +	if (!ret && count > 0) {
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 +					 PT_TRAP * sizeof(reg),
 +					 (PT_TRAP + 1) * sizeof(reg));
 +		if (!ret)
 +			ret = set_user_ckpt_trap(target, reg);
 +	}
 +
 +	if (!ret)
 +		ret = user_regset_copyin_ignore(
 +			&pos, &count, &kbuf, &ubuf,
 +			(PT_TRAP + 1) * sizeof(reg), -1);
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_cfpr_active - get active number of registers in CFPR
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks for the active number of available
 + * regisers in transaction checkpointed FPR category.
 + */
 +static int tm_cfpr_active(struct task_struct *target,
 +				const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return 0;
 +
 +	return regset->n;
 +}
 +
 +/**
 + * tm_cfpr_get - get CFPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets in transaction checkpointed FPR registers.
 + *
 + * When the transaction is active 'ckfp_state' holds the checkpointed
 + * values for the current transaction to fall back on if it aborts
 + * in between. This function gets those checkpointed FPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + *};
 + */
 +static int tm_cfpr_get(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			void *kbuf, void __user *ubuf)
 +{
 +	u64 buf[33];
 +	int i;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	/* copy to local buffer then write that out */
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.TS_CKFPR(i);
 +	buf[32] = target->thread.ckfp_state.fpscr;
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +}
 +
 +/**
 + * tm_cfpr_set - set CFPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets in transaction checkpointed FPR registers.
 + *
 + * When the transaction is active 'ckfp_state' holds the checkpointed
 + * FPR register values for the current transaction to fall back on
 + * if it aborts in between. This function sets these checkpointed
 + * FPR registers. The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + *};
 + */
 +static int tm_cfpr_set(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			const void *kbuf, const void __user *ubuf)
 +{
 +	u64 buf[33];
 +	int i;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	for (i = 0; i < 32; i++)
 +		buf[i] = target->thread.TS_CKFPR(i);
 +	buf[32] = target->thread.ckfp_state.fpscr;
 +
 +	/* copy to local buffer then write that out */
 +	i = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +	if (i)
 +		return i;
 +	for (i = 0; i < 32 ; i++)
 +		target->thread.TS_CKFPR(i) = buf[i];
 +	target->thread.ckfp_state.fpscr = buf[32];
 +	return 0;
 +}
 +
 +/**
 + * tm_cvmx_active - get active number of registers in CVMX
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks for the active number of available
 + * regisers in checkpointed VMX category.
 + */
 +static int tm_cvmx_active(struct task_struct *target,
 +				const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return 0;
 +
 +	return regset->n;
 +}
 +
 +/**
 + * tm_cvmx_get - get CMVX registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets in transaction checkpointed VMX registers.
 + *
 + * When the transaction is active 'ckvr_state' and 'ckvrsave' hold
 + * the checkpointed values for the current transaction to fall
 + * back on if it aborts in between. The userspace interface buffer
 + * layout is as follows.
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + *};
 + */
 +static int tm_cvmx_get(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	BUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	/* Flush the state */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					&target->thread.ckvr_state, 0,
 +					33 * sizeof(vector128));
 +	if (!ret) {
 +		/*
 +		 * Copy out only the low-order word of vrsave.
 +		 */
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +		vrsave.word = target->thread.ckvrsave;
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,
 +						33 * sizeof(vector128), -1);
 +	}
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_cvmx_set - set CMVX registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets in transaction checkpointed VMX registers.
 + *
 + * When the transaction is active 'ckvr_state' and 'ckvrsave' hold
 + * the checkpointed values for the current transaction to fall
 + * back on if it aborts in between. The userspace interface buffer
 + * layout is as follows.
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + *};
 + */
 +static int tm_cvmx_set(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	BUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					&target->thread.ckvr_state, 0,
 +					33 * sizeof(vector128));
 +	if (!ret && count > 0) {
 +		/*
 +		 * We use only the low-order word of vrsave.
 +		 */
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +		vrsave.word = target->thread.ckvrsave;
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,
 +						33 * sizeof(vector128), -1);
 +		if (!ret)
 +			target->thread.ckvrsave = vrsave.word;
 +	}
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_cvsx_active - get active number of registers in CVSX
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks for the active number of available
 + * regisers in transaction checkpointed VSX category.
 + */
 +static int tm_cvsx_active(struct task_struct *target,
 +				const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return 0;
 +
 +	flush_vsx_to_thread(target);
 +	return target->thread.used_vsr ? regset->n : 0;
 +}
 +
 +/**
 + * tm_cvsx_get - get CVSX registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets in transaction checkpointed VSX registers.
 + *
 + * When the transaction is active 'ckfp_state' holds the checkpointed
 + * values for the current transaction to fall back on if it aborts
 + * in between. This function gets those checkpointed VSX registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	u64	vsx[32];
 + *};
 + */
 +static int tm_cvsx_get(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			void *kbuf, void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret, i;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	/* Flush the state */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  buf, 0, 32 * sizeof(double));
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_cvsx_set - set CFPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets in transaction checkpointed VSX registers.
 + *
 + * When the transaction is active 'ckfp_state' holds the checkpointed
 + * VSX register values for the current transaction to fall back on
 + * if it aborts in between. This function sets these checkpointed
 + * FPR registers. The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	u64	vsx[32];
 + *};
 + */
 +static int tm_cvsx_set(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			const void *kbuf, const void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret, i;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	/* Flush the state */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 buf, 0, 32 * sizeof(double));
 +	if (!ret)
 +		for (i = 0; i < 32 ; i++)
 +			target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_spr_active - get active number of registers in TM SPR
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks the active number of available
 + * regisers in the transactional memory SPR category.
 + */
 +static int tm_spr_active(struct task_struct *target,
 +			 const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	return regset->n;
 +}
 +
 +/**
 + * tm_spr_get - get the TM related SPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets transactional memory related SPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct {
 + *	u64		tm_tfhar;
 + *	u64		tm_texasr;
 + *	u64		tm_tfiar;
 + * };
 + */
 +static int tm_spr_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	/* Build tests */
 +	BUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));
 +	BUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));
 +	BUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	/* Flush the states */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	/* TFHAR register */
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tfhar, 0, sizeof(u64));
 +
 +	/* TEXASR register */
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_texasr, sizeof(u64),
 +				2 * sizeof(u64));
 +
 +	/* TFIAR register */
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tfiar,
 +				2 * sizeof(u64), 3 * sizeof(u64));
 +	return ret;
 +}
 +
 +/**
 + * tm_spr_set - set the TM related SPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets transactional memory related SPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct {
 + *	u64		tm_tfhar;
 + *	u64		tm_texasr;
 + *	u64		tm_tfiar;
 + * };
 + */
 +static int tm_spr_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	/* Build tests */
 +	BUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));
 +	BUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));
 +	BUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	/* Flush the states */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
  
 -static unsigned long get_user_msr(struct task_struct *task)
 -{
 -	return task->thread.regs->msr | task->thread.fpexc_mode;
 -}
 +	/* TFHAR register */
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tfhar, 0, sizeof(u64));
  
 -static int set_user_msr(struct task_struct *task, unsigned long msr)
 -{
 -	task->thread.regs->msr &= ~MSR_DEBUGCHANGE;
 -	task->thread.regs->msr |= msr & MSR_DEBUGCHANGE;
 -	return 0;
 -}
 +	/* TEXASR register */
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_texasr, sizeof(u64),
 +				2 * sizeof(u64));
  
 -#ifdef CONFIG_PPC64
 -static int get_user_dscr(struct task_struct *task, unsigned long *data)
 -{
 -	*data = task->thread.dscr;
 -	return 0;
 +	/* TFIAR register */
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tfiar,
 +				 2 * sizeof(u64), 3 * sizeof(u64));
 +	return ret;
  }
  
 -static int set_user_dscr(struct task_struct *task, unsigned long dscr)
 -{
 -	task->thread.dscr = dscr;
 -	task->thread.dscr_inherit = 1;
 -	return 0;
 -}
 -#else
 -static int get_user_dscr(struct task_struct *task, unsigned long *data)
 +static int tm_tar_active(struct task_struct *target,
 +			 const struct user_regset *regset)
  {
 -	return -EIO;
 -}
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
  
 -static int set_user_dscr(struct task_struct *task, unsigned long dscr)
 -{
 -	return -EIO;
 -}
 -#endif
 +	if (MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return regset->n;
  
 -/*
 - * We prevent mucking around with the reserved area of trap
 - * which are used internally by the kernel.
 - */
 -static int set_user_trap(struct task_struct *task, unsigned long trap)
 -{
 -	task->thread.regs->trap = trap & 0xfff0;
  	return 0;
  }
  
@@@ -1539,55 -282,61 +1500,57 @@@ static int tm_ppr_set(struct task_struc
  	return ret;
  }
  
 -static int gpr_set(struct task_struct *target, const struct user_regset *regset,
 -		   unsigned int pos, unsigned int count,
 -		   const void *kbuf, const void __user *ubuf)
 +static int tm_dscr_active(struct task_struct *target,
 +			 const struct user_regset *regset)
  {
 -	unsigned long reg;
 -	int ret;
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
  
 -	if (target->thread.regs == NULL)
 -		return -EIO;
 +	if (MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return regset->n;
  
 -	CHECK_FULL_REGS(target->thread.regs);
 +	return 0;
 +}
  
 -	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 -				 target->thread.regs,
 -				 0, PT_MSR * sizeof(reg));
 +static int tm_dscr_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	int ret;
  
 -	if (!ret && count > 0) {
 -		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 -					 PT_MSR * sizeof(reg),
 -					 (PT_MSR + 1) * sizeof(reg));
 -		if (!ret)
 -			ret = set_user_msr(target, reg);
 -	}
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
  
 -	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 -		     offsetof(struct pt_regs, msr) + sizeof(long));
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
  
 -	if (!ret)
 -		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 -					 &target->thread.regs->orig_gpr3,
 -					 PT_ORIG_R3 * sizeof(reg),
 -					 (PT_MAX_PUT_REG + 1) * sizeof(reg));
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_dscr, 0, sizeof(u64));
 +	return ret;
 +}
  
 -	if (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)
 -		ret = user_regset_copyin_ignore(
 -			&pos, &count, &kbuf, &ubuf,
 -			(PT_MAX_PUT_REG + 1) * sizeof(reg),
 -			PT_TRAP * sizeof(reg));
 +static int tm_dscr_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
  
 -	if (!ret && count > 0) {
 -		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 -					 PT_TRAP * sizeof(reg),
 -					 (PT_TRAP + 1) * sizeof(reg));
 -		if (!ret)
 -			ret = set_user_trap(target, reg);
 -	}
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
  
 -	if (!ret)
 -		ret = user_regset_copyin_ignore(
 -			&pos, &count, &kbuf, &ubuf,
 -			(PT_TRAP + 1) * sizeof(reg), -1);
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
  
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_dscr, 0, sizeof(u64));
  	return ret;
  }
 +#endif	/* CONFIG_PPC_TRANSACTIONAL_MEM */
  
++=======
++>>>>>>> 7c1f8db019f8 (powerpc/ptrace: split out TRANSACTIONAL_MEM related functions.):arch/powerpc/kernel/ptrace/ptrace.c
  #ifdef CONFIG_PPC64
  static int ppr_get(struct task_struct *target,
  		      const struct user_regset *regset,
* Unmerged path arch/powerpc/kernel/ptrace-tm.c
* Unmerged path arch/powerpc/kernel/ptrace/Makefile
* Unmerged path arch/powerpc/kernel/ptrace/ptrace-decl.h
* Unmerged path arch/powerpc/kernel/ptrace-tm.c
* Unmerged path arch/powerpc/kernel/ptrace.c
* Unmerged path arch/powerpc/kernel/ptrace/Makefile
* Unmerged path arch/powerpc/kernel/ptrace/ptrace-decl.h
