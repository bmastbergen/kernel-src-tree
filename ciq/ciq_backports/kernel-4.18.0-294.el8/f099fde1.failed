net/mlx5: E-switch, Support querying port function mac address

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Parav Pandit <parav@mellanox.com>
commit f099fde16db3d2594a54ba8c94ce9fa3557aa3e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f099fde1.failed

Support querying mac address of the eswitch devlink port function.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f099fde16db3d2594a54ba8c94ce9fa3557aa3e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 884ecf823ead,19cd0af7afda..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -553,6 -570,22 +558,25 @@@ static inline u16 mlx5_eswitch_index_to
  	return index;
  }
  
++<<<<<<< HEAD
++=======
+ static inline unsigned int
+ mlx5_esw_vport_to_devlink_port_index(const struct mlx5_core_dev *dev,
+ 				     u16 vport_num)
+ {
+ 	return (MLX5_CAP_GEN(dev, vhca_id) << 16) | vport_num;
+ }
+ 
+ static inline u16
+ mlx5_esw_devlink_port_index_to_vport_num(unsigned int dl_port_index)
+ {
+ 	return dl_port_index & 0xffff;
+ }
+ 
+ /* TODO: This mlx5e_tc function shouldn't be called by eswitch */
+ void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
+ 
++>>>>>>> f099fde16db3 (net/mlx5: E-switch, Support querying port function mac address)
  /* The vport getter/iterator are only valid after esw->total_vports
   * and vport->vport are initialized in mlx5_eswitch_init.
   */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index a99fe4b02b9b..3177d2458fa5 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@ -113,6 +113,7 @@ static const struct devlink_ops mlx5_devlink_ops = {
 	.eswitch_inline_mode_get = mlx5_devlink_eswitch_inline_mode_get,
 	.eswitch_encap_mode_set = mlx5_devlink_eswitch_encap_mode_set,
 	.eswitch_encap_mode_get = mlx5_devlink_eswitch_encap_mode_get,
+	.port_function_hw_addr_get = mlx5_devlink_port_function_hw_addr_get,
 #endif
 	.flash_update = mlx5_devlink_flash_update,
 	.info_get = mlx5_devlink_info_get,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 0bb72743a628..e391558390b7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -1814,6 +1814,49 @@ int mlx5_eswitch_set_vport_mac(struct mlx5_eswitch *esw,
 	return err;
 }
 
+static bool
+is_port_function_supported(const struct mlx5_eswitch *esw, u16 vport_num)
+{
+	return vport_num == MLX5_VPORT_PF ||
+	       mlx5_eswitch_is_vf_vport(esw, vport_num);
+}
+
+int mlx5_devlink_port_function_hw_addr_get(struct devlink *devlink,
+					   struct devlink_port *port,
+					   u8 *hw_addr, int *hw_addr_len,
+					   struct netlink_ext_ack *extack)
+{
+	struct mlx5_eswitch *esw;
+	struct mlx5_vport *vport;
+	int err = -EOPNOTSUPP;
+	u16 vport_num;
+
+	esw = mlx5_devlink_eswitch_get(devlink);
+	if (IS_ERR(esw))
+		return PTR_ERR(esw);
+
+	vport_num = mlx5_esw_devlink_port_index_to_vport_num(port->index);
+	if (!is_port_function_supported(esw, vport_num))
+		return -EOPNOTSUPP;
+
+	vport = mlx5_eswitch_get_vport(esw, vport_num);
+	if (IS_ERR(vport)) {
+		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
+		return PTR_ERR(vport);
+	}
+
+	mutex_lock(&esw->state_lock);
+	if (vport->enabled) {
+		ether_addr_copy(hw_addr, vport->info.mac);
+		*hw_addr_len = ETH_ALEN;
+		err = 0;
+	} else {
+		NL_SET_ERR_MSG_MOD(extack, "Eswitch vport is disabled");
+	}
+	mutex_unlock(&esw->state_lock);
+	return err;
+}
+
 int mlx5_eswitch_set_vport_state(struct mlx5_eswitch *esw,
 				 u16 vport, int link_state)
 {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
