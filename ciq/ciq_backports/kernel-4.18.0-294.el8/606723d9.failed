fs/xfs: Change XFS_MOUNT_DAX to XFS_MOUNT_DAX_ALWAYS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit 606723d982939ab138a05a8070b1ec48ed532234
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/606723d9.failed

In prep for the new tri-state mount option which then introduces
XFS_MOUNT_DAX_NEVER.

	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 606723d982939ab138a05a8070b1ec48ed532234)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index e6df26a81bbf,ce169d1c7474..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1506,57 -1024,335 +1506,302 @@@ xfs_destroy_percpu_counters
  	percpu_counter_destroy(&mp->m_delalloc_blks);
  }
  
 -static void
 -xfs_fs_put_super(
 -	struct super_block	*sb)
 +static struct xfs_mount *
 +xfs_mount_alloc(void)
  {
 -	struct xfs_mount	*mp = XFS_M(sb);
 +	struct xfs_mount	*mp;
  
 -	/* if ->fill_super failed, we have no mount to tear down */
 -	if (!sb->s_fs_info)
 -		return;
 +	mp = kmem_alloc(sizeof(struct xfs_mount), KM_ZERO);
 +	if (!mp)
 +		return NULL;
  
++<<<<<<< HEAD
 +	spin_lock_init(&mp->m_sb_lock);
 +	spin_lock_init(&mp->m_agirotor_lock);
 +	INIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);
 +	spin_lock_init(&mp->m_perag_lock);
 +	mutex_init(&mp->m_growlock);
 +	atomic_set(&mp->m_active_trans, 0);
 +	INIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);
 +	INIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);
 +	INIT_DELAYED_WORK(&mp->m_cowblocks_work, xfs_cowblocks_worker);
 +	mp->m_kobj.kobject.kset = xfs_kset;
++=======
+ 	xfs_notice(mp, "Unmounting Filesystem");
+ 	xfs_filestream_unmount(mp);
+ 	xfs_unmountfs(mp);
+ 
+ 	xfs_freesb(mp);
+ 	free_percpu(mp->m_stats.xs_stats);
+ 	xfs_destroy_percpu_counters(mp);
+ 	xfs_destroy_mount_workqueues(mp);
+ 	xfs_close_devices(mp);
+ 
+ 	sb->s_fs_info = NULL;
+ 	xfs_mount_free(mp);
+ }
+ 
+ static long
+ xfs_fs_nr_cached_objects(
+ 	struct super_block	*sb,
+ 	struct shrink_control	*sc)
+ {
+ 	/* Paranoia: catch incorrect calls during mount setup or teardown */
+ 	if (WARN_ON_ONCE(!sb->s_fs_info))
+ 		return 0;
+ 	return xfs_reclaim_inodes_count(XFS_M(sb));
+ }
+ 
+ static long
+ xfs_fs_free_cached_objects(
+ 	struct super_block	*sb,
+ 	struct shrink_control	*sc)
+ {
+ 	return xfs_reclaim_inodes_nr(XFS_M(sb), sc->nr_to_scan);
+ }
+ 
+ static const struct super_operations xfs_super_operations = {
+ 	.alloc_inode		= xfs_fs_alloc_inode,
+ 	.destroy_inode		= xfs_fs_destroy_inode,
+ 	.dirty_inode		= xfs_fs_dirty_inode,
+ 	.drop_inode		= xfs_fs_drop_inode,
+ 	.put_super		= xfs_fs_put_super,
+ 	.sync_fs		= xfs_fs_sync_fs,
+ 	.freeze_fs		= xfs_fs_freeze,
+ 	.unfreeze_fs		= xfs_fs_unfreeze,
+ 	.statfs			= xfs_fs_statfs,
+ 	.show_options		= xfs_fs_show_options,
+ 	.nr_cached_objects	= xfs_fs_nr_cached_objects,
+ 	.free_cached_objects	= xfs_fs_free_cached_objects,
+ };
+ 
+ static int
+ suffix_kstrtoint(
+ 	const char	*s,
+ 	unsigned int	base,
+ 	int		*res)
+ {
+ 	int		last, shift_left_factor = 0, _res;
+ 	char		*value;
+ 	int		ret = 0;
+ 
+ 	value = kstrdup(s, GFP_KERNEL);
+ 	if (!value)
+ 		return -ENOMEM;
+ 
+ 	last = strlen(value) - 1;
+ 	if (value[last] == 'K' || value[last] == 'k') {
+ 		shift_left_factor = 10;
+ 		value[last] = '\0';
+ 	}
+ 	if (value[last] == 'M' || value[last] == 'm') {
+ 		shift_left_factor = 20;
+ 		value[last] = '\0';
+ 	}
+ 	if (value[last] == 'G' || value[last] == 'g') {
+ 		shift_left_factor = 30;
+ 		value[last] = '\0';
+ 	}
+ 
+ 	if (kstrtoint(value, base, &_res))
+ 		ret = -EINVAL;
+ 	kfree(value);
+ 	*res = _res << shift_left_factor;
+ 	return ret;
+ }
+ 
+ /*
+  * Set mount state from a mount option.
+  *
+  * NOTE: mp->m_super is NULL here!
+  */
+ static int
+ xfs_fc_parse_param(
+ 	struct fs_context	*fc,
+ 	struct fs_parameter	*param)
+ {
+ 	struct xfs_mount	*mp = fc->s_fs_info;
+ 	struct fs_parse_result	result;
+ 	int			size = 0;
+ 	int			opt;
+ 
+ 	opt = fs_parse(fc, xfs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_logbufs:
+ 		mp->m_logbufs = result.uint_32;
+ 		return 0;
+ 	case Opt_logbsize:
+ 		if (suffix_kstrtoint(param->string, 10, &mp->m_logbsize))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_logdev:
+ 		kfree(mp->m_logname);
+ 		mp->m_logname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_logname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_rtdev:
+ 		kfree(mp->m_rtname);
+ 		mp->m_rtname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_rtname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_allocsize:
+ 		if (suffix_kstrtoint(param->string, 10, &size))
+ 			return -EINVAL;
+ 		mp->m_allocsize_log = ffs(size) - 1;
+ 		mp->m_flags |= XFS_MOUNT_ALLOCSIZE;
+ 		return 0;
+ 	case Opt_grpid:
+ 	case Opt_bsdgroups:
+ 		mp->m_flags |= XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_nogrpid:
+ 	case Opt_sysvgroups:
+ 		mp->m_flags &= ~XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_wsync:
+ 		mp->m_flags |= XFS_MOUNT_WSYNC;
+ 		return 0;
+ 	case Opt_norecovery:
+ 		mp->m_flags |= XFS_MOUNT_NORECOVERY;
+ 		return 0;
+ 	case Opt_noalign:
+ 		mp->m_flags |= XFS_MOUNT_NOALIGN;
+ 		return 0;
+ 	case Opt_swalloc:
+ 		mp->m_flags |= XFS_MOUNT_SWALLOC;
+ 		return 0;
+ 	case Opt_sunit:
+ 		mp->m_dalign = result.uint_32;
+ 		return 0;
+ 	case Opt_swidth:
+ 		mp->m_swidth = result.uint_32;
+ 		return 0;
+ 	case Opt_inode32:
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_inode64:
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_nouuid:
+ 		mp->m_flags |= XFS_MOUNT_NOUUID;
+ 		return 0;
+ 	case Opt_ikeep:
+ 		mp->m_flags |= XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_noikeep:
+ 		mp->m_flags &= ~XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_largeio:
+ 		mp->m_flags |= XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_nolargeio:
+ 		mp->m_flags &= ~XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_attr2:
+ 		mp->m_flags |= XFS_MOUNT_ATTR2;
+ 		return 0;
+ 	case Opt_noattr2:
+ 		mp->m_flags &= ~XFS_MOUNT_ATTR2;
+ 		mp->m_flags |= XFS_MOUNT_NOATTR2;
+ 		return 0;
+ 	case Opt_filestreams:
+ 		mp->m_flags |= XFS_MOUNT_FILESTREAMS;
+ 		return 0;
+ 	case Opt_noquota:
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
+ 		return 0;
+ 	case Opt_quota:
+ 	case Opt_uquota:
+ 	case Opt_usrquota:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
+ 				 XFS_UQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_qnoenforce:
+ 	case Opt_uqnoenforce:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_UQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_pquota:
+ 	case Opt_prjquota:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
+ 				 XFS_PQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_pqnoenforce:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_PQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_gquota:
+ 	case Opt_grpquota:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
+ 				 XFS_GQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_gqnoenforce:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_GQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_discard:
+ 		mp->m_flags |= XFS_MOUNT_DISCARD;
+ 		return 0;
+ 	case Opt_nodiscard:
+ 		mp->m_flags &= ~XFS_MOUNT_DISCARD;
+ 		return 0;
+ #ifdef CONFIG_FS_DAX
+ 	case Opt_dax:
+ 		mp->m_flags |= XFS_MOUNT_DAX_ALWAYS;
+ 		return 0;
+ #endif
+ 	default:
+ 		xfs_warn(mp, "unknown mount option [%s].", param->key);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_fc_validate_params(
+ 	struct xfs_mount	*mp)
+ {
++>>>>>>> 606723d98293 (fs/xfs: Change XFS_MOUNT_DAX to XFS_MOUNT_DAX_ALWAYS)
  	/*
 -	 * no recovery flag requires a read-only mount
 +	 * We don't create the finobt per-ag space reservation until after log
 +	 * recovery, so we must set this to true so that an ifree transaction
 +	 * started during log recovery will not depend on space reservations
 +	 * for finobt expansion.
  	 */
 -	if ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&
 -	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
 -		xfs_warn(mp, "no-recovery mounts must be read-only.");
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_flags & XFS_MOUNT_NOALIGN) &&
 -	    (mp->m_dalign || mp->m_swidth)) {
 -		xfs_warn(mp,
 -	"sunit and swidth options incompatible with the noalign option");
 -		return -EINVAL;
 -	}
 -
 -	if (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {
 -		xfs_warn(mp, "quota support not available in this kernel.");
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_dalign && !mp->m_swidth) ||
 -	    (!mp->m_dalign && mp->m_swidth)) {
 -		xfs_warn(mp, "sunit and swidth must be specified together");
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
 -		xfs_warn(mp,
 -	"stripe width (%d) must be a multiple of the stripe unit (%d)",
 -			mp->m_swidth, mp->m_dalign);
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_logbufs != -1 &&
 -	    mp->m_logbufs != 0 &&
 -	    (mp->m_logbufs < XLOG_MIN_ICLOGS ||
 -	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
 -		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
 -			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_logbsize != -1 &&
 -	    mp->m_logbsize !=  0 &&
 -	    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||
 -	     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||
 -	     !is_power_of_2(mp->m_logbsize))) {
 -		xfs_warn(mp,
 -			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
 -			mp->m_logbsize);
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_flags & XFS_MOUNT_ALLOCSIZE) &&
 -	    (mp->m_allocsize_log > XFS_MAX_IO_LOG ||
 -	     mp->m_allocsize_log < XFS_MIN_IO_LOG)) {
 -		xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
 -			mp->m_allocsize_log, XFS_MIN_IO_LOG, XFS_MAX_IO_LOG);
 -		return -EINVAL;
 -	}
 -
 -	return 0;
 +	mp->m_finobt_nores = true;
 +	return mp;
  }
  
 -static int
 -xfs_fc_fill_super(
 +
 +STATIC int
 +xfs_fs_fill_super(
  	struct super_block	*sb,
 -	struct fs_context	*fc)
 +	void			*data,
 +	int			silent)
  {
 -	struct xfs_mount	*mp = sb->s_fs_info;
  	struct inode		*root;
 -	int			flags = 0, error;
 +	struct xfs_mount	*mp = NULL;
 +	int			flags = 0, error = -ENOMEM;
  
 +	/*
 +	 * allocate mp and do all low-level struct initializations before we
 +	 * attach it to the super
 +	 */
 +	mp = xfs_mount_alloc();
 +	if (!mp)
 +		goto out;
  	mp->m_super = sb;
 +	sb->s_fs_info = mp;
  
 -	error = xfs_fc_validate_params(mp);
 +	error = xfs_parseargs(mp, (char *)data);
  	if (error)
  		goto out_free_names;
  
@@@ -1658,9 -1454,8 +1903,9 @@@
  	if (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)
  		sb->s_flags |= SB_I_VERSION;
  
- 	if (mp->m_flags & XFS_MOUNT_DAX) {
+ 	if (mp->m_flags & XFS_MOUNT_DAX_ALWAYS) {
  		bool rtdev_is_dax = false, datadev_is_dax;
 +		static bool printed = false;
  
  		xfs_warn(mp,
  		"DAX enabled. Warning: EXPERIMENTAL, use at your own risk");
diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c
index 841eb213b84c..07ff8fc98827 100644
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@ -1246,7 +1246,7 @@ xfs_inode_supports_dax(
 		return false;
 
 	/* DAX mount option or DAX iflag must be set. */
-	if (!(mp->m_flags & XFS_MOUNT_DAX) &&
+	if (!(mp->m_flags & XFS_MOUNT_DAX_ALWAYS) &&
 	    !(ip->i_d.di_flags2 & XFS_DIFLAG2_DAX))
 		return false;
 
diff --git a/fs/xfs/xfs_mount.h b/fs/xfs/xfs_mount.h
index 1c67cc24efa8..0903e7463edb 100644
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@ -232,8 +232,7 @@ typedef struct xfs_mount {
 #define XFS_MOUNT_FILESTREAMS	(1ULL << 24)	/* enable the filestreams
 						   allocator */
 #define XFS_MOUNT_NOATTR2	(1ULL << 25)	/* disable use of attr2 format */
-
-#define XFS_MOUNT_DAX		(1ULL << 62)	/* TEST ONLY! */
+#define XFS_MOUNT_DAX_ALWAYS	(1ULL << 26)
 
 
 /*
* Unmerged path fs/xfs/xfs_super.c
