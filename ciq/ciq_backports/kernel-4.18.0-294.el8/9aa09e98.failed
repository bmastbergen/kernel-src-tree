lpfc: nvme: Add Receive LS Request and Send LS Response support to nvme

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author James Smart <jsmart2021@gmail.com>
commit 9aa09e98b288649544c74d1a7b88223f36e4bffd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9aa09e98.failed

Now that common helpers exist, add the ability to receive NVME LS requests
to the driver. New requests will be delivered to the transport by
nvme_fc_rcv_ls_req().

In order to complete the LS, add support for Send LS Response and send
LS response completion handling to the driver.

	Signed-off-by: Paul Ely <paul.ely@broadcom.com>
	Signed-off-by: James Smart <jsmart2021@gmail.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 9aa09e98b288649544c74d1a7b88223f36e4bffd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_nvme.c
diff --cc drivers/scsi/lpfc/lpfc_nvme.c
index 4475db1997c1,21bbccf0dc31..000000000000
--- a/drivers/scsi/lpfc/lpfc_nvme.c
+++ b/drivers/scsi/lpfc/lpfc_nvme.c
@@@ -792,17 -830,113 +830,118 @@@ lpfc_nvme_ls_req(struct nvme_fc_local_p
  }
  
  /**
 - * __lpfc_nvme_ls_abort - Generic service routine to abort a prior
 - *         NVME LS request
 - * @vport: The local port that issued the LS
 - * @ndlp: The remote port the LS was sent to
 - * @pnvme_lsreq: Pointer to LS request structure from the transport
 + * lpfc_nvme_ls_abort - Issue an Link Service request
 + * @lpfc_pnvme: Pointer to the driver's nvme instance data
 + * @lpfc_nvme_lport: Pointer to the driver's local port data
 + * @lpfc_nvme_rport: Pointer to the rport getting the @lpfc_nvme_ereq
   *
 - * The driver validates the ndlp, looks for the LS, and aborts the
 - * LS if found.
 + * Driver registers this routine to handle any link service request
 + * from the nvme_fc transport to a remote nvme-aware port.
   *
++<<<<<<< HEAD
 + * Return value :
 + *   0 - Success
 + *   TODO: What are the failure codes.
++=======
+  * Returns:
+  * 0 : if LS found and aborted
+  * non-zero: various error conditions in form -Exxx
+  **/
+ int
+ __lpfc_nvme_ls_abort(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
+ 			struct nvmefc_ls_req *pnvme_lsreq)
+ {
+ 	struct lpfc_hba *phba = vport->phba;
+ 	struct lpfc_sli_ring *pring;
+ 	struct lpfc_iocbq *wqe, *next_wqe;
+ 	bool foundit = false;
+ 
+ 	if (!ndlp) {
+ 		lpfc_printf_log(phba, KERN_ERR,
+ 				LOG_NVME_DISC | LOG_NODE |
+ 					LOG_NVME_IOERR | LOG_NVME_ABTS,
+ 				"6049 NVMEx LS REQ Abort: Bad NDLP x%px DID "
+ 				"x%06x, Failing LS Req\n",
+ 				ndlp, ndlp ? ndlp->nlp_DID : 0);
+ 		return -EINVAL;
+ 	}
+ 
+ 	lpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC | LOG_NVME_ABTS,
+ 			 "6040 NVMEx LS REQ Abort: Issue LS_ABORT for lsreq "
+ 			 "x%p rqstlen:%d rsplen:%d %pad %pad\n",
+ 			 pnvme_lsreq, pnvme_lsreq->rqstlen,
+ 			 pnvme_lsreq->rsplen, &pnvme_lsreq->rqstdma,
+ 			 &pnvme_lsreq->rspdma);
+ 
+ 	/*
+ 	 * Lock the ELS ring txcmplq and look for the wqe that matches
+ 	 * this ELS. If found, issue an abort on the wqe.
+ 	 */
+ 	pring = phba->sli4_hba.nvmels_wq->pring;
+ 	spin_lock_irq(&phba->hbalock);
+ 	spin_lock(&pring->ring_lock);
+ 	list_for_each_entry_safe(wqe, next_wqe, &pring->txcmplq, list) {
+ 		if (wqe->context2 == pnvme_lsreq) {
+ 			wqe->iocb_flag |= LPFC_DRIVER_ABORTED;
+ 			foundit = true;
+ 			break;
+ 		}
+ 	}
+ 	spin_unlock(&pring->ring_lock);
+ 
+ 	if (foundit)
+ 		lpfc_sli_issue_abort_iotag(phba, pring, wqe);
+ 	spin_unlock_irq(&phba->hbalock);
+ 
+ 	if (foundit)
+ 		return 0;
+ 
+ 	lpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC | LOG_NVME_ABTS,
+ 			 "6213 NVMEx LS REQ Abort: Unable to locate req x%p\n",
+ 			 pnvme_lsreq);
+ 	return 1;
+ }
+ 
+ static int
+ lpfc_nvme_xmt_ls_rsp(struct nvme_fc_local_port *localport,
+ 		     struct nvme_fc_remote_port *remoteport,
+ 		     struct nvmefc_ls_rsp *ls_rsp)
+ {
+ 	struct lpfc_async_xchg_ctx *axchg =
+ 		container_of(ls_rsp, struct lpfc_async_xchg_ctx, ls_rsp);
+ 	struct lpfc_nvme_lport *lport;
+ 	int rc;
+ 
+ 	if (axchg->phba->pport->load_flag & FC_UNLOADING)
+ 		return -ENODEV;
+ 
+ 	lport = (struct lpfc_nvme_lport *)localport->private;
+ 
+ 	rc = __lpfc_nvme_xmt_ls_rsp(axchg, ls_rsp, __lpfc_nvme_xmt_ls_rsp_cmp);
+ 
+ 	if (rc) {
+ 		/*
+ 		 * unless the failure is due to having already sent
+ 		 * the response, an abort will be generated for the
+ 		 * exchange if the rsp can't be sent.
+ 		 */
+ 		if (rc != -EALREADY)
+ 			atomic_inc(&lport->xmt_ls_abort);
+ 		return rc;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * lpfc_nvme_ls_abort - Abort a prior NVME LS request
+  * @lpfc_nvme_lport: Transport localport that LS is to be issued from.
+  * @lpfc_nvme_rport: Transport remoteport that LS is to be sent to.
+  * @pnvme_lsreq - the transport nvme_ls_req structure for the LS
+  *
+  * Driver registers this routine to abort a NVME LS request that is
+  * in progress (from the transports perspective).
++>>>>>>> 9aa09e98b288 (lpfc: nvme: Add Receive LS Request and Send LS Response support to nvme)
   **/
  static void
  lpfc_nvme_ls_abort(struct nvme_fc_local_port *pnvme_lport,
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.c
