mm: memcg/slab: fix return of child memcg objcg for root memcg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Muchun Song <songmuchun@bytedance.com>
commit 2f7659a314736b32b66273dbf91c19874a052fde
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2f7659a3.failed

Consider the following memcg hierarchy.

                    root
                   /    \
                  A      B

If we failed to get the reference on objcg of memcg A, the
get_obj_cgroup_from_current can return the wrong objcg for the root
memcg.

Link: https://lkml.kernel.org/r/20201029164429.58703-1-songmuchun@bytedance.com
Fixes: bf4f059954dc ("mm: memcg/slab: obj_cgroup API")
	Signed-off-by: Muchun Song <songmuchun@bytedance.com>
	Acked-by: Roman Gushchin <guro@fb.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Yafang Shao <laoar.shao@gmail.com>
	Cc: Chris Down <chris@chrisdown.name>
	Cc: Christian Brauner <christian.brauner@ubuntu.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Eugene Syromiatnikov <esyr@redhat.com>
	Cc: Suren Baghdasaryan <surenb@google.com>
	Cc: Adrian Reber <areber@redhat.com>
	Cc: Marco Elver <elver@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2f7659a314736b32b66273dbf91c19874a052fde)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 4b64abb55f3f,4ac4d5edada4..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -2823,6 -2957,31 +2823,34 @@@ struct mem_cgroup *mem_cgroup_from_obj(
  	return page->mem_cgroup;
  }
  
++<<<<<<< HEAD
++=======
+ __always_inline struct obj_cgroup *get_obj_cgroup_from_current(void)
+ {
+ 	struct obj_cgroup *objcg = NULL;
+ 	struct mem_cgroup *memcg;
+ 
+ 	if (memcg_kmem_bypass())
+ 		return NULL;
+ 
+ 	rcu_read_lock();
+ 	if (unlikely(active_memcg()))
+ 		memcg = active_memcg();
+ 	else
+ 		memcg = mem_cgroup_from_task(current);
+ 
+ 	for (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg)) {
+ 		objcg = rcu_dereference(memcg->objcg);
+ 		if (objcg && obj_cgroup_tryget(objcg))
+ 			break;
+ 		objcg = NULL;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return objcg;
+ }
+ 
++>>>>>>> 2f7659a31473 (mm: memcg/slab: fix return of child memcg objcg for root memcg)
  static int memcg_alloc_cache_id(void)
  {
  	int id, size;
* Unmerged path mm/memcontrol.c
