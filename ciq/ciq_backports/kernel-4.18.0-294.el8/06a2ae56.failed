vfs: Add some logging to the core users of the fs_context log

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 06a2ae56b5b88fa57cd56e0b99bd874135efdf58
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/06a2ae56.failed

Add some logging to the core users of the fs_context log so that
information can be extracted from them as to the reason for failure.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 06a2ae56b5b88fa57cd56e0b99bd874135efdf58)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/super.c
#	kernel/cgroup/cgroup-v1.c
diff --cc fs/super.c
index 9be3be2154ec,583a0124bc39..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -1244,29 -1454,44 +1244,36 @@@ struct dentry *mount_single(struct file
  }
  EXPORT_SYMBOL(mount_single);
  
 -/**
 - * vfs_get_tree - Get the mountable root
 - * @fc: The superblock configuration context.
 - *
 - * The filesystem is invoked to get or create a superblock which can then later
 - * be used for mounting.  The filesystem places a pointer to the root to be
 - * used for mounting in @fc->root.
 - */
 -int vfs_get_tree(struct fs_context *fc)
 +struct dentry *
 +mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
  {
 +	struct dentry *root;
  	struct super_block *sb;
 -	int error;
 +	int error = -ENOMEM;
 +	struct security_mnt_opts opts;
  
++<<<<<<< HEAD
 +	security_init_mnt_opts(&opts);
++=======
+ 	if (fc->fs_type->fs_flags & FS_REQUIRES_DEV && !fc->source) {
+ 		errorf(fc, "Filesystem requires source device");
+ 		return -ENOENT;
+ 	}
++>>>>>>> 06a2ae56b5b8 (vfs: Add some logging to the core users of the fs_context log)
  
 -	if (fc->root)
 -		return -EBUSY;
 -
 -	/* Get the mountable root in fc->root, with a ref on the root and a ref
 -	 * on the superblock.
 -	 */
 -	error = fc->ops->get_tree(fc);
 -	if (error < 0)
 -		return error;
 -
 -	if (!fc->root) {
 -		pr_err("Filesystem %s get_tree() didn't set fc->root\n",
 -		       fc->fs_type->name);
 -		/* We don't know what the locking state of the superblock is -
 -		 * if there is a superblock.
 -		 */
 -		BUG();
 +	if (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {
 +		error = security_sb_eat_lsm_opts(data, &opts);
 +		if (error)
 +			return ERR_PTR(error);
  	}
  
 -	sb = fc->root->d_sb;
 +	root = type->mount(type, flags, name, data);
 +	if (IS_ERR(root)) {
 +		error = PTR_ERR(root);
 +		goto out_free_secdata;
 +	}
 +	sb = root->d_sb;
 +	BUG_ON(!sb);
  	WARN_ON(!sb->s_bdi);
  
  	if (fc->subtype && !sb->s_subtype) {
diff --cc kernel/cgroup/cgroup-v1.c
index dd94e2a4c22e,c126b34fd4ff..000000000000
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@@ -16,6 -16,9 +16,11 @@@
  
  #include <trace/events/cgroup.h>
  
++<<<<<<< HEAD
++=======
+ #define cg_invalf(fc, fmt, ...) invalf(fc, fmt, ## __VA_ARGS__)
+ 
++>>>>>>> 06a2ae56b5b8 (vfs: Add some logging to the core users of the fs_context log)
  /*
   * pidlists linger the following amount before being destroyed.  The goal
   * is avoiding frequent destruction in the middle of consecutive read calls
* Unmerged path fs/super.c
* Unmerged path kernel/cgroup/cgroup-v1.c
