net: refactor bind_bucket fastreuse into helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] refactor bind_bucket fastreuse into helper (Guillaume Nault) [1899137]
Rebuild_FUZZ: 94.38%
commit-author Tim Froidcoeur <tim.froidcoeur@tessares.net>
commit 62ffc589abb176821662efc4525ee4ac0b9c3894
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/62ffc589.failed

Refactor the fastreuse update code in inet_csk_get_port into a small
helper function that can be called from other places.

	Acked-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: Tim Froidcoeur <tim.froidcoeur@tessares.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 62ffc589abb176821662efc4525ee4ac0b9c3894)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/inet_connection_sock.h
#	net/ipv4/inet_connection_sock.c
diff --cc include/net/inet_connection_sock.h
index bcfefea637b6,aa8893c68c50..000000000000
--- a/include/net/inet_connection_sock.h
+++ b/include/net/inet_connection_sock.h
@@@ -314,10 -304,9 +314,16 @@@ void inet_csk_listen_stop(struct sock *
  
  void inet_csk_addr2sockaddr(struct sock *sk, struct sockaddr *uaddr);
  
++<<<<<<< HEAD
 +int inet_csk_compat_getsockopt(struct sock *sk, int level, int optname,
 +			       char __user *optval, int __user *optlen);
 +int inet_csk_compat_setsockopt(struct sock *sk, int level, int optname,
 +			       char __user *optval, unsigned int optlen);
++=======
+ /* update the fast reuse flag when adding a socket */
+ void inet_csk_update_fastreuse(struct inet_bind_bucket *tb,
+ 			       struct sock *sk);
++>>>>>>> 62ffc589abb1 (net: refactor bind_bucket fastreuse into helper)
  
  struct dst_entry *inet_csk_update_pmtu(struct sock *sk, u32 mtu);
  
diff --cc net/ipv4/inet_connection_sock.c
index 87a178665c2f,b457dd2d6c75..000000000000
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@@ -285,51 -296,12 +285,47 @@@ static inline int sk_reuseport_match(st
  				    ipv6_only_sock(sk), true, false);
  }
  
- /* Obtain a reference to a local port for the given sock,
-  * if snum is zero it means select any available local port.
-  * We try to allocate an odd port (and leave even ports for connect())
-  */
- int inet_csk_get_port(struct sock *sk, unsigned short snum)
+ void inet_csk_update_fastreuse(struct inet_bind_bucket *tb,
+ 			       struct sock *sk)
  {
- 	bool reuse = sk->sk_reuse && sk->sk_state != TCP_LISTEN;
- 	struct inet_hashinfo *hinfo = sk->sk_prot->h.hashinfo;
- 	int ret = 1, port = snum;
- 	struct inet_bind_hashbucket *head;
- 	struct net *net = sock_net(sk);
- 	struct inet_bind_bucket *tb = NULL;
  	kuid_t uid = sock_i_uid(sk);
++<<<<<<< HEAD
 +
 +	if (!port) {
 +		head = inet_csk_find_open_port(sk, &tb, &port);
 +		if (!head)
 +			return ret;
 +		if (!tb)
 +			goto tb_not_found;
 +		goto success;
 +	}
 +	head = &hinfo->bhash[inet_bhashfn(net, port,
 +					  hinfo->bhash_size)];
 +	spin_lock_bh(&head->lock);
 +	inet_bind_bucket_for_each(tb, &head->chain)
 +		if (net_eq(ib_net(tb), net) && tb->port == port)
 +			goto tb_found;
 +tb_not_found:
 +	tb = inet_bind_bucket_create(hinfo->bind_bucket_cachep,
 +				     net, head, port);
 +	if (!tb)
 +		goto fail_unlock;
 +tb_found:
 +	if (!hlist_empty(&tb->owners)) {
 +		if (sk->sk_reuse == SK_FORCE_REUSE)
 +			goto success;
 +
 +		if ((tb->fastreuse > 0 && reuse) ||
 +		    sk_reuseport_match(tb, sk))
 +			goto success;
 +		if (inet_csk_bind_conflict(sk, tb, true, true))
 +			goto fail_unlock;
 +	}
 +success:
++=======
+ 	bool reuse = sk->sk_reuse && sk->sk_state != TCP_LISTEN;
+ 
++>>>>>>> 62ffc589abb1 (net: refactor bind_bucket fastreuse into helper)
  	if (hlist_empty(&tb->owners)) {
  		tb->fastreuse = reuse;
  		if (sk->sk_reuseport) {
* Unmerged path include/net/inet_connection_sock.h
* Unmerged path net/ipv4/inet_connection_sock.c
