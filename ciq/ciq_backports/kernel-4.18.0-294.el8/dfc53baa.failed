x86/hyperv: Remove aliases with X64 in their name

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] hyperv: Remove aliases with X64 in their name (Vitaly Kuznetsov) [1882793]
Rebuild_FUZZ: 95.74%
commit-author Joseph Salisbury <joseph.salisbury@microsoft.com>
commit dfc53baae3c6a165a35735b789e3e083786271d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dfc53baa.failed

In the architecture independent version of hyperv-tlfs.h, commit c55a844f46f958b
removed the "X64" in the symbol names so they would make sense for both x86 and
ARM64.  That commit added aliases with the "X64" in the x86 version of hyperv-tlfs.h 
so that existing x86 code would continue to compile.

As a cleanup, update the x86 code to use the symbols without the "X64", then remove 
the aliases.  There's no functional change.

	Signed-off-by: Joseph Salisbury <joseph.salisbury@microsoft.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Acked-by: Paolo Bonzini <pbonzini@redhat.com>
Link: https://lore.kernel.org/r/1601130386-11111-1-git-send-email-jsalisbury@linux.microsoft.com

(cherry picked from commit dfc53baae3c6a165a35735b789e3e083786271d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/hyperv-tlfs.h
#	arch/x86/kernel/cpu/mshyperv.c
diff --cc arch/x86/include/asm/hyperv-tlfs.h
index 136195e87f74,0ed20e8bba9e..000000000000
--- a/arch/x86/include/asm/hyperv-tlfs.h
+++ b/arch/x86/include/asm/hyperv-tlfs.h
@@@ -39,78 -28,8 +39,83 @@@
  #define HYPERV_CPUID_MAX			0x4000ffff
  
  /*
++<<<<<<< HEAD
 + * Feature identification. EAX indicates which features are available
 + * to the partition based upon the current partition privileges.
 + * These are HYPERV_CPUID_FEATURES.EAX bits.
 + */
 +
 +/* VP Runtime (HV_X64_MSR_VP_RUNTIME) available */
 +#define HV_X64_MSR_VP_RUNTIME_AVAILABLE		BIT(0)
 +/* Partition Reference Counter (HV_X64_MSR_TIME_REF_COUNT) available*/
 +#define HV_MSR_TIME_REF_COUNT_AVAILABLE		BIT(1)
 +/*
 + * Basic SynIC MSRs (HV_X64_MSR_SCONTROL through HV_X64_MSR_EOM
 + * and HV_X64_MSR_SINT0 through HV_X64_MSR_SINT15) available
 + */
 +#define HV_X64_MSR_SYNIC_AVAILABLE		BIT(2)
 +/*
 + * Synthetic Timer MSRs (HV_X64_MSR_STIMER0_CONFIG through
 + * HV_X64_MSR_STIMER3_COUNT) available
 + */
 +#define HV_MSR_SYNTIMER_AVAILABLE		BIT(3)
 +/*
 + * APIC access MSRs (HV_X64_MSR_EOI, HV_X64_MSR_ICR and HV_X64_MSR_TPR)
 + * are available
 + */
 +#define HV_X64_MSR_APIC_ACCESS_AVAILABLE	BIT(4)
 +/* Hypercall MSRs (HV_X64_MSR_GUEST_OS_ID and HV_X64_MSR_HYPERCALL) available*/
 +#define HV_X64_MSR_HYPERCALL_AVAILABLE		BIT(5)
 +/* Access virtual processor index MSR (HV_X64_MSR_VP_INDEX) available*/
 +#define HV_X64_MSR_VP_INDEX_AVAILABLE		BIT(6)
 +/* Virtual system reset MSR (HV_X64_MSR_RESET) is available*/
 +#define HV_X64_MSR_RESET_AVAILABLE		BIT(7)
 +/*
 + * Access statistics pages MSRs (HV_X64_MSR_STATS_PARTITION_RETAIL_PAGE,
 + * HV_X64_MSR_STATS_PARTITION_INTERNAL_PAGE, HV_X64_MSR_STATS_VP_RETAIL_PAGE,
 + * HV_X64_MSR_STATS_VP_INTERNAL_PAGE) available
 + */
 +#define HV_X64_MSR_STAT_PAGES_AVAILABLE		BIT(8)
 +/* Partition reference TSC MSR is available */
 +#define HV_MSR_REFERENCE_TSC_AVAILABLE		BIT(9)
 +/* Partition Guest IDLE MSR is available */
 +#define HV_X64_MSR_GUEST_IDLE_AVAILABLE		BIT(10)
 +/*
 + * There is a single feature flag that signifies if the partition has access
 + * to MSRs with local APIC and TSC frequencies.
 + */
 +#define HV_X64_ACCESS_FREQUENCY_MSRS		BIT(11)
 +/* AccessReenlightenmentControls privilege */
 +#define HV_X64_ACCESS_REENLIGHTENMENT		BIT(13)
 +/* AccessTscInvariantControls privilege */
 +#define HV_X64_ACCESS_TSC_INVARIANT		BIT(15)
 +
 +/*
 + * Feature identification: indicates which flags were specified at partition
 + * creation. The format is the same as the partition creation flag structure
 + * defined in section Partition Creation Flags.
 + * These are HYPERV_CPUID_FEATURES.EBX bits.
 + */
 +#define HV_X64_CREATE_PARTITIONS		BIT(0)
 +#define HV_X64_ACCESS_PARTITION_ID		BIT(1)
 +#define HV_X64_ACCESS_MEMORY_POOL		BIT(2)
 +#define HV_X64_ADJUST_MESSAGE_BUFFERS		BIT(3)
 +#define HV_X64_POST_MESSAGES			BIT(4)
 +#define HV_X64_SIGNAL_EVENTS			BIT(5)
 +#define HV_X64_CREATE_PORT			BIT(6)
 +#define HV_X64_CONNECT_PORT			BIT(7)
 +#define HV_X64_ACCESS_STATS			BIT(8)
 +#define HV_X64_DEBUGGING			BIT(11)
 +#define HV_X64_CPU_POWER_MANAGEMENT		BIT(12)
 +
 +/*
 + * Feature identification. EDX indicates which miscellaneous features
 + * are available to the partition.
 + * These are HYPERV_CPUID_FEATURES.EDX bits.
++=======
+  * Group D Features.  The bit assignments are custom to each architecture.
+  * On x86/x64 these are HYPERV_CPUID_FEATURES.EDX bits.
++>>>>>>> dfc53baae3c6 (x86/hyperv: Remove aliases with X64 in their name)
   */
  /* The MWAIT instruction is available (per section MONITOR / MWAIT) */
  #define HV_X64_MWAIT_AVAILABLE				BIT(0)
diff --cc arch/x86/kernel/cpu/mshyperv.c
index 9f0ce6d7f717,9834a43cd0fa..000000000000
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@@ -335,17 -327,19 +335,21 @@@ static void __init ms_hyperv_init_platf
  	x86_platform.apic_post_init = hyperv_init;
  	hyperv_setup_mmu_ops();
  	/* Setup the IDT for hypervisor callback */
 -	alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR, asm_sysvec_hyperv_callback);
 +	alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR, hyperv_callback_vector);
  
  	/* Setup the IDT for reenlightenment notifications */
++<<<<<<< HEAD
 +	if (ms_hyperv.features & HV_X64_ACCESS_REENLIGHTENMENT)
++=======
+ 	if (ms_hyperv.features & HV_ACCESS_REENLIGHTENMENT) {
++>>>>>>> dfc53baae3c6 (x86/hyperv: Remove aliases with X64 in their name)
  		alloc_intr_gate(HYPERV_REENLIGHTENMENT_VECTOR,
 -				asm_sysvec_hyperv_reenlightenment);
 -	}
 +				hyperv_reenlightenment_vector);
  
  	/* Setup the IDT for stimer0 */
 -	if (ms_hyperv.misc_features & HV_STIMER_DIRECT_MODE_AVAILABLE) {
 +	if (ms_hyperv.misc_features & HV_STIMER_DIRECT_MODE_AVAILABLE)
  		alloc_intr_gate(HYPERV_STIMER0_VECTOR,
 -				asm_sysvec_hyperv_stimer0);
 -	}
 +				hv_stimer0_callback_vector);
  
  # ifdef CONFIG_SMP
  	smp_ops.smp_prepare_boot_cpu = hv_smp_prepare_boot_cpu;
diff --git a/arch/x86/hyperv/hv_init.c b/arch/x86/hyperv/hv_init.c
index 900e7e009fe0..43ec03694a62 100644
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@ -158,9 +158,9 @@ static inline bool hv_reenlightenment_available(void)
 	 * Check for required features and priviliges to make TSC frequency
 	 * change notifications work.
 	 */
-	return ms_hyperv.features & HV_X64_ACCESS_FREQUENCY_MSRS &&
+	return ms_hyperv.features & HV_ACCESS_FREQUENCY_MSRS &&
 		ms_hyperv.misc_features & HV_FEATURE_FREQUENCY_MSRS_AVAILABLE &&
-		ms_hyperv.features & HV_X64_ACCESS_REENLIGHTENMENT;
+		ms_hyperv.features & HV_ACCESS_REENLIGHTENMENT;
 }
 
 __visible void __irq_entry hyperv_reenlightenment_intr(struct pt_regs *regs)
@@ -344,8 +344,8 @@ void __init hyperv_init(void)
 		return;
 
 	/* Absolutely required MSRs */
-	required_msrs = HV_X64_MSR_HYPERCALL_AVAILABLE |
-		HV_X64_MSR_VP_INDEX_AVAILABLE;
+	required_msrs = HV_MSR_HYPERCALL_AVAILABLE |
+		HV_MSR_VP_INDEX_AVAILABLE;
 
 	if ((ms_hyperv.features & required_msrs) != required_msrs)
 		return;
diff --git a/arch/x86/hyperv/hv_spinlock.c b/arch/x86/hyperv/hv_spinlock.c
index b19275305de3..1c428343ae24 100644
--- a/arch/x86/hyperv/hv_spinlock.c
+++ b/arch/x86/hyperv/hv_spinlock.c
@@ -66,7 +66,7 @@ void __init hv_init_spinlocks(void)
 {
 	if (!hv_pvspin || !apic ||
 	    !(ms_hyperv.hints & HV_X64_CLUSTER_IPI_RECOMMENDED) ||
-	    !(ms_hyperv.features & HV_X64_MSR_GUEST_IDLE_AVAILABLE)) {
+	    !(ms_hyperv.features & HV_MSR_GUEST_IDLE_AVAILABLE)) {
 		pr_info("PV spinlocks disabled\n");
 		return;
 	}
* Unmerged path arch/x86/include/asm/hyperv-tlfs.h
* Unmerged path arch/x86/kernel/cpu/mshyperv.c
diff --git a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c
index 3e9d587757f7..e979e4ff0376 100644
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@ -2000,20 +2000,20 @@ int kvm_vcpu_ioctl_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid,
 			break;
 
 		case HYPERV_CPUID_FEATURES:
-			ent->eax |= HV_X64_MSR_VP_RUNTIME_AVAILABLE;
+			ent->eax |= HV_MSR_VP_RUNTIME_AVAILABLE;
 			ent->eax |= HV_MSR_TIME_REF_COUNT_AVAILABLE;
-			ent->eax |= HV_X64_MSR_SYNIC_AVAILABLE;
+			ent->eax |= HV_MSR_SYNIC_AVAILABLE;
 			ent->eax |= HV_MSR_SYNTIMER_AVAILABLE;
-			ent->eax |= HV_X64_MSR_APIC_ACCESS_AVAILABLE;
-			ent->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;
-			ent->eax |= HV_X64_MSR_VP_INDEX_AVAILABLE;
-			ent->eax |= HV_X64_MSR_RESET_AVAILABLE;
+			ent->eax |= HV_MSR_APIC_ACCESS_AVAILABLE;
+			ent->eax |= HV_MSR_HYPERCALL_AVAILABLE;
+			ent->eax |= HV_MSR_VP_INDEX_AVAILABLE;
+			ent->eax |= HV_MSR_RESET_AVAILABLE;
 			ent->eax |= HV_MSR_REFERENCE_TSC_AVAILABLE;
-			ent->eax |= HV_X64_ACCESS_FREQUENCY_MSRS;
-			ent->eax |= HV_X64_ACCESS_REENLIGHTENMENT;
+			ent->eax |= HV_ACCESS_FREQUENCY_MSRS;
+			ent->eax |= HV_ACCESS_REENLIGHTENMENT;
 
-			ent->ebx |= HV_X64_POST_MESSAGES;
-			ent->ebx |= HV_X64_SIGNAL_EVENTS;
+			ent->ebx |= HV_POST_MESSAGES;
+			ent->ebx |= HV_SIGNAL_EVENTS;
 
 			ent->edx |= HV_FEATURE_FREQUENCY_MSRS_AVAILABLE;
 			ent->edx |= HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;
