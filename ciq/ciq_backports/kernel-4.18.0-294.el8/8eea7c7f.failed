net: stmmac: xgmac: Fix missing return

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jose Abreu <Jose.Abreu@synopsys.com>
commit 8eea7c7f3f2fcc8d580df331890090a023ef3f6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8eea7c7f.failed

If FPE is supposed to be disabled we need to return after disabling it.

Fixes: f0e56c8d8f7d ("net: stmmac: xgmac3+: Add support for Frame Preemption")
	Signed-off-by: Jose Abreu <Jose.Abreu@synopsys.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8eea7c7f3f2fcc8d580df331890090a023ef3f6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
diff --cc drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
index a534a159424b,2af3ac5409b7..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
@@@ -1168,6 -1168,272 +1168,275 @@@ static void dwxgmac2_enable_vlan(struc
  	writel(value, ioaddr + XGMAC_VLAN_INCL);
  }
  
++<<<<<<< HEAD
++=======
+ static int dwxgmac2_filter_wait(struct mac_device_info *hw)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 
+ 	if (readl_poll_timeout(ioaddr + XGMAC_L3L4_ADDR_CTRL, value,
+ 			       !(value & XGMAC_XB), 100, 10000))
+ 		return -EBUSY;
+ 	return 0;
+ }
+ 
+ static int dwxgmac2_filter_read(struct mac_device_info *hw, u32 filter_no,
+ 				u8 reg, u32 *data)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	int ret;
+ 
+ 	ret = dwxgmac2_filter_wait(hw);
+ 	if (ret)
+ 		return ret;
+ 
+ 	value = ((filter_no << XGMAC_IDDR_FNUM) | reg) << XGMAC_IDDR_SHIFT;
+ 	value |= XGMAC_TT | XGMAC_XB;
+ 	writel(value, ioaddr + XGMAC_L3L4_ADDR_CTRL);
+ 
+ 	ret = dwxgmac2_filter_wait(hw);
+ 	if (ret)
+ 		return ret;
+ 
+ 	*data = readl(ioaddr + XGMAC_L3L4_DATA);
+ 	return 0;
+ }
+ 
+ static int dwxgmac2_filter_write(struct mac_device_info *hw, u32 filter_no,
+ 				 u8 reg, u32 data)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	int ret;
+ 
+ 	ret = dwxgmac2_filter_wait(hw);
+ 	if (ret)
+ 		return ret;
+ 
+ 	writel(data, ioaddr + XGMAC_L3L4_DATA);
+ 
+ 	value = ((filter_no << XGMAC_IDDR_FNUM) | reg) << XGMAC_IDDR_SHIFT;
+ 	value |= XGMAC_XB;
+ 	writel(value, ioaddr + XGMAC_L3L4_ADDR_CTRL);
+ 
+ 	return dwxgmac2_filter_wait(hw);
+ }
+ 
+ static int dwxgmac2_config_l3_filter(struct mac_device_info *hw, u32 filter_no,
+ 				     bool en, bool ipv6, bool sa, bool inv,
+ 				     u32 match)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	int ret;
+ 
+ 	value = readl(ioaddr + XGMAC_PACKET_FILTER);
+ 	value |= XGMAC_FILTER_IPFE;
+ 	writel(value, ioaddr + XGMAC_PACKET_FILTER);
+ 
+ 	ret = dwxgmac2_filter_read(hw, filter_no, XGMAC_L3L4_CTRL, &value);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* For IPv6 not both SA/DA filters can be active */
+ 	if (ipv6) {
+ 		value |= XGMAC_L3PEN0;
+ 		value &= ~(XGMAC_L3SAM0 | XGMAC_L3SAIM0);
+ 		value &= ~(XGMAC_L3DAM0 | XGMAC_L3DAIM0);
+ 		if (sa) {
+ 			value |= XGMAC_L3SAM0;
+ 			if (inv)
+ 				value |= XGMAC_L3SAIM0;
+ 		} else {
+ 			value |= XGMAC_L3DAM0;
+ 			if (inv)
+ 				value |= XGMAC_L3DAIM0;
+ 		}
+ 	} else {
+ 		value &= ~XGMAC_L3PEN0;
+ 		if (sa) {
+ 			value |= XGMAC_L3SAM0;
+ 			if (inv)
+ 				value |= XGMAC_L3SAIM0;
+ 		} else {
+ 			value |= XGMAC_L3DAM0;
+ 			if (inv)
+ 				value |= XGMAC_L3DAIM0;
+ 		}
+ 	}
+ 
+ 	ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, value);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (sa) {
+ 		ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3_ADDR0, match);
+ 		if (ret)
+ 			return ret;
+ 	} else {
+ 		ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3_ADDR1, match);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (!en)
+ 		return dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, 0);
+ 
+ 	return 0;
+ }
+ 
+ static int dwxgmac2_config_l4_filter(struct mac_device_info *hw, u32 filter_no,
+ 				     bool en, bool udp, bool sa, bool inv,
+ 				     u32 match)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	int ret;
+ 
+ 	value = readl(ioaddr + XGMAC_PACKET_FILTER);
+ 	value |= XGMAC_FILTER_IPFE;
+ 	writel(value, ioaddr + XGMAC_PACKET_FILTER);
+ 
+ 	ret = dwxgmac2_filter_read(hw, filter_no, XGMAC_L3L4_CTRL, &value);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (udp) {
+ 		value |= XGMAC_L4PEN0;
+ 	} else {
+ 		value &= ~XGMAC_L4PEN0;
+ 	}
+ 
+ 	value &= ~(XGMAC_L4SPM0 | XGMAC_L4SPIM0);
+ 	value &= ~(XGMAC_L4DPM0 | XGMAC_L4DPIM0);
+ 	if (sa) {
+ 		value |= XGMAC_L4SPM0;
+ 		if (inv)
+ 			value |= XGMAC_L4SPIM0;
+ 	} else {
+ 		value |= XGMAC_L4DPM0;
+ 		if (inv)
+ 			value |= XGMAC_L4DPIM0;
+ 	}
+ 
+ 	ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, value);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (sa) {
+ 		value = match & XGMAC_L4SP0;
+ 
+ 		ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L4_ADDR, value);
+ 		if (ret)
+ 			return ret;
+ 	} else {
+ 		value = (match << XGMAC_L4DP0_SHIFT) & XGMAC_L4DP0;
+ 
+ 		ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L4_ADDR, value);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (!en)
+ 		return dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, 0);
+ 
+ 	return 0;
+ }
+ 
+ static void dwxgmac2_set_arp_offload(struct mac_device_info *hw, bool en,
+ 				     u32 addr)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 
+ 	writel(addr, ioaddr + XGMAC_ARP_ADDR);
+ 
+ 	value = readl(ioaddr + XGMAC_RX_CONFIG);
+ 	if (en)
+ 		value |= XGMAC_CONFIG_ARPEN;
+ 	else
+ 		value &= ~XGMAC_CONFIG_ARPEN;
+ 	writel(value, ioaddr + XGMAC_RX_CONFIG);
+ }
+ 
+ static int dwxgmac3_est_write(void __iomem *ioaddr, u32 reg, u32 val, bool gcl)
+ {
+ 	u32 ctrl;
+ 
+ 	writel(val, ioaddr + XGMAC_MTL_EST_GCL_DATA);
+ 
+ 	ctrl = (reg << XGMAC_ADDR_SHIFT);
+ 	ctrl |= gcl ? 0 : XGMAC_GCRR;
+ 
+ 	writel(ctrl, ioaddr + XGMAC_MTL_EST_GCL_CONTROL);
+ 
+ 	ctrl |= XGMAC_SRWO;
+ 	writel(ctrl, ioaddr + XGMAC_MTL_EST_GCL_CONTROL);
+ 
+ 	return readl_poll_timeout_atomic(ioaddr + XGMAC_MTL_EST_GCL_CONTROL,
+ 					 ctrl, !(ctrl & XGMAC_SRWO), 100, 5000);
+ }
+ 
+ static int dwxgmac3_est_configure(void __iomem *ioaddr, struct stmmac_est *cfg,
+ 				  unsigned int ptp_rate)
+ {
+ 	int i, ret = 0x0;
+ 	u32 ctrl;
+ 
+ 	ret |= dwxgmac3_est_write(ioaddr, XGMAC_BTR_LOW, cfg->btr[0], false);
+ 	ret |= dwxgmac3_est_write(ioaddr, XGMAC_BTR_HIGH, cfg->btr[1], false);
+ 	ret |= dwxgmac3_est_write(ioaddr, XGMAC_TER, cfg->ter, false);
+ 	ret |= dwxgmac3_est_write(ioaddr, XGMAC_LLR, cfg->gcl_size, false);
+ 	ret |= dwxgmac3_est_write(ioaddr, XGMAC_CTR_LOW, cfg->ctr[0], false);
+ 	ret |= dwxgmac3_est_write(ioaddr, XGMAC_CTR_HIGH, cfg->ctr[1], false);
+ 	if (ret)
+ 		return ret;
+ 
+ 	for (i = 0; i < cfg->gcl_size; i++) {
+ 		ret = dwxgmac3_est_write(ioaddr, i, cfg->gcl[i], true);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	ctrl = readl(ioaddr + XGMAC_MTL_EST_CONTROL);
+ 	ctrl &= ~XGMAC_PTOV;
+ 	ctrl |= ((1000000000 / ptp_rate) * 9) << XGMAC_PTOV_SHIFT;
+ 	if (cfg->enable)
+ 		ctrl |= XGMAC_EEST | XGMAC_SSWL;
+ 	else
+ 		ctrl &= ~XGMAC_EEST;
+ 
+ 	writel(ctrl, ioaddr + XGMAC_MTL_EST_CONTROL);
+ 	return 0;
+ }
+ 
+ static void dwxgmac3_fpe_configure(void __iomem *ioaddr, u32 num_txq,
+ 				   u32 num_rxq, bool enable)
+ {
+ 	u32 value;
+ 
+ 	if (!enable) {
+ 		value = readl(ioaddr + XGMAC_FPE_CTRL_STS);
+ 
+ 		value &= ~XGMAC_EFPE;
+ 
+ 		writel(value, ioaddr + XGMAC_FPE_CTRL_STS);
+ 		return;
+ 	}
+ 
+ 	value = readl(ioaddr + XGMAC_RXQ_CTRL1);
+ 	value &= ~XGMAC_RQ;
+ 	value |= (num_rxq - 1) << XGMAC_RQ_SHIFT;
+ 	writel(value, ioaddr + XGMAC_RXQ_CTRL1);
+ 
+ 	value = readl(ioaddr + XGMAC_FPE_CTRL_STS);
+ 	value |= XGMAC_EFPE;
+ 	writel(value, ioaddr + XGMAC_FPE_CTRL_STS);
+ }
+ 
++>>>>>>> 8eea7c7f3f2f (net: stmmac: xgmac: Fix missing return)
  const struct stmmac_ops dwxgmac210_ops = {
  	.core_init = dwxgmac2_core_init,
  	.set_mac = dwxgmac2_set_mac,
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
