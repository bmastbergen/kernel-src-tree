s390/kernel: expand exception table logic to allow new handling options

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ilya Leoshkevich <iii@linux.ibm.com>
commit 05a68e892e89c97df6650cd8cc55058002657cbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/05a68e89.failed

This is a s390 port of commit 548acf19234d ("x86/mm: Expand the
exception table logic to allow new handling options"), which is needed
for implementing BPF_PROBE_MEM on s390.

The new handler field is made 64-bit in order to allow pointing from
dynamically allocated entries to handlers in kernel text. Unlike on x86,
NULL is used instead of ex_handler_default. This is because exception
tables are used by boot/text_dma.S, and it would be a pain to preserve
ex_handler_default.

The new infrastructure is ignored in early_pgm_check_handler, since
there is no pt_regs.

	Signed-off-by: Ilya Leoshkevich <iii@linux.ibm.com>
	Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 05a68e892e89c97df6650cd8cc55058002657cbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/traps.c
#	scripts/sortextable.c
diff --cc arch/s390/kernel/traps.c
index 82e81a9f7112,8d1e8a1a97df..000000000000
--- a/arch/s390/kernel/traps.c
+++ b/arch/s390/kernel/traps.c
@@@ -50,16 -50,8 +50,19 @@@ void do_report_trap(struct pt_regs *reg
          } else {
                  const struct exception_table_entry *fixup;
  		fixup = s390_search_extables(regs->psw.addr);
++<<<<<<< HEAD
 +                if (fixup)
 +			regs->psw.addr = extable_fixup(fixup);
 +		else {
 +			enum bug_trap_type btt;
 +
 +			btt = report_bug(regs->psw.addr, regs);
 +			if (btt == BUG_TRAP_TYPE_WARN)
 +				return;
++=======
+ 		if (!fixup || !ex_handle(fixup, regs))
++>>>>>>> 05a68e892e89 (s390/kernel: expand exception table logic to allow new handling options)
  			die(regs, str);
- 		}
          }
  }
  
@@@ -251,6 -237,27 +254,30 @@@ void space_switch_exception(struct pt_r
  	do_trap(regs, SIGILL, ILL_PRVOPC, "space switch event");
  }
  
++<<<<<<< HEAD
++=======
+ void monitor_event_exception(struct pt_regs *regs)
+ {
+ 	const struct exception_table_entry *fixup;
+ 
+ 	if (user_mode(regs))
+ 		return;
+ 
+ 	switch (report_bug(regs->psw.addr - (regs->int_code >> 16), regs)) {
+ 	case BUG_TRAP_TYPE_NONE:
+ 		fixup = s390_search_extables(regs->psw.addr);
+ 		if (fixup)
+ 			ex_handle(fixup, regs);
+ 		break;
+ 	case BUG_TRAP_TYPE_WARN:
+ 		break;
+ 	case BUG_TRAP_TYPE_BUG:
+ 		die(regs, "monitor event");
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 05a68e892e89 (s390/kernel: expand exception table logic to allow new handling options)
  void kernel_stack_overflow(struct pt_regs *regs)
  {
  	bust_spinlocks(1);
diff --cc scripts/sortextable.c
index 365a907f98b3,0ef3abfc4a51..000000000000
--- a/scripts/sortextable.c
+++ b/scripts/sortextable.c
@@@ -238,82 -255,89 +238,127 @@@ static void x86_sort_relative_table(cha
  	}
  }
  
++<<<<<<< HEAD:scripts/sortextable.c
 +static void sort_relative_table(char *extab_image, int image_size)
++=======
+ static void s390_sort_relative_table(char *extab_image, int image_size)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < image_size; i += 16) {
+ 		char *loc = extab_image + i;
+ 		uint64_t handler;
+ 
+ 		w(r((uint32_t *)loc) + i, (uint32_t *)loc);
+ 		w(r((uint32_t *)(loc + 4)) + (i + 4), (uint32_t *)(loc + 4));
+ 		/*
+ 		 * 0 is a special self-relative handler value, which means that
+ 		 * handler should be ignored. It is safe, because it means that
+ 		 * handler field points to itself, which should never happen.
+ 		 * When creating extable-relative values, keep it as 0, since
+ 		 * this should never occur either: it would mean that handler
+ 		 * field points to the first extable entry.
+ 		 */
+ 		handler = r8((uint64_t *)(loc + 8));
+ 		if (handler)
+ 			handler += i + 8;
+ 		w8(handler, (uint64_t *)(loc + 8));
+ 	}
+ 
+ 	qsort(extab_image, image_size / 16, 16, compare_relative_table);
+ 
+ 	for (i = 0; i < image_size; i += 16) {
+ 		char *loc = extab_image + i;
+ 		uint64_t handler;
+ 
+ 		w(r((uint32_t *)loc) - i, (uint32_t *)loc);
+ 		w(r((uint32_t *)(loc + 4)) - (i + 4), (uint32_t *)(loc + 4));
+ 		handler = r8((uint64_t *)(loc + 8));
+ 		if (handler)
+ 			handler -= i + 8;
+ 		w8(handler, (uint64_t *)(loc + 8));
+ 	}
+ }
+ 
+ static int do_file(char const *const fname, void *addr)
++>>>>>>> 05a68e892e89 (s390/kernel: expand exception table logic to allow new handling options):scripts/sorttable.c
  {
 -	int rc = -1;
 -	Elf32_Ehdr *ehdr = addr;
 -	table_sort_t custom_sort = NULL;
 +	int i;
 +
 +	/*
 +	 * Do the same thing the runtime sort does, first normalize to
 +	 * being relative to the start of the section.
 +	 */
 +	i = 0;
 +	while (i < image_size) {
 +		uint32_t *loc = (uint32_t *)(extab_image + i);
 +		w(r(loc) + i, loc);
 +		i += 4;
 +	}
  
 +	qsort(extab_image, image_size / 8, 8, compare_relative_table);
 +
 +	/* Now denormalize. */
 +	i = 0;
 +	while (i < image_size) {
 +		uint32_t *loc = (uint32_t *)(extab_image + i);
 +		w(r(loc) - i, loc);
 +		i += 4;
 +	}
 +}
 +
 +static void
 +do_file(char const *const fname)
 +{
 +	table_sort_t custom_sort;
 +	Elf32_Ehdr *ehdr = mmap_file(fname);
 +
 +	ehdr_curr = ehdr;
  	switch (ehdr->e_ident[EI_DATA]) {
 +	default:
 +		fprintf(stderr, "unrecognized ELF data encoding %d: %s\n",
 +			ehdr->e_ident[EI_DATA], fname);
 +		fail_file();
 +		break;
  	case ELFDATA2LSB:
 -		r	= rle;
 -		r2	= r2le;
 -		r8	= r8le;
 -		w	= wle;
 -		w2	= w2le;
 -		w8	= w8le;
 +		r = rle;
 +		r2 = r2le;
 +		r8 = r8le;
 +		w = wle;
 +		w2 = w2le;
 +		w8 = w8le;
  		break;
  	case ELFDATA2MSB:
 -		r	= rbe;
 -		r2	= r2be;
 -		r8	= r8be;
 -		w	= wbe;
 -		w2	= w2be;
 -		w8	= w8be;
 +		r = rbe;
 +		r2 = r2be;
 +		r8 = r8be;
 +		w = wbe;
 +		w2 = w2be;
 +		w8 = w8be;
  		break;
 -	default:
 -		fprintf(stderr, "unrecognized ELF data encoding %d: %s\n",
 -			ehdr->e_ident[EI_DATA], fname);
 -		return -1;
 -	}
 -
 -	if (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0 ||
 -	    (r2(&ehdr->e_type) != ET_EXEC && r2(&ehdr->e_type) != ET_DYN) ||
 -	    ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
 +	}  /* end switch */
 +	if (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0
 +	||  (r2(&ehdr->e_type) != ET_EXEC && r2(&ehdr->e_type) != ET_DYN)
 +	||  ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
  		fprintf(stderr, "unrecognized ET_EXEC/ET_DYN file %s\n", fname);
 -		return -1;
 +		fail_file();
  	}
  
 +	custom_sort = NULL;
  	switch (r2(&ehdr->e_machine)) {
 +	default:
 +		fprintf(stderr, "unrecognized e_machine %d %s\n",
 +			r2(&ehdr->e_machine), fname);
 +		fail_file();
 +		break;
  	case EM_386:
  	case EM_X86_64:
  		custom_sort = x86_sort_relative_table;
  		break;
 +
  	case EM_S390:
+ 		custom_sort = s390_sort_relative_table;
+ 		break;
  	case EM_AARCH64:
  	case EM_PARISC:
  	case EM_PPC:
diff --git a/arch/s390/include/asm/extable.h b/arch/s390/include/asm/extable.h
index ae27f756b409..3beb294fd553 100644
--- a/arch/s390/include/asm/extable.h
+++ b/arch/s390/include/asm/extable.h
@@ -1,12 +1,20 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __S390_EXTABLE_H
 #define __S390_EXTABLE_H
+
+#include <asm/ptrace.h>
+#include <linux/compiler.h>
+
 /*
- * The exception table consists of pairs of addresses: the first is the
- * address of an instruction that is allowed to fault, and the second is
- * the address at which the program should continue.  No registers are
- * modified, so it is entirely up to the continuation code to figure out
- * what to do.
+ * The exception table consists of three addresses:
+ *
+ * - Address of an instruction that is allowed to fault.
+ * - Address at which the program should continue.
+ * - Optional address of handler that takes pt_regs * argument and runs in
+ *   interrupt context.
+ *
+ * No registers are modified, so it is entirely up to the continuation code
+ * to figure out what to do.
  *
  * All the routines below use bits of fixup code that are out of line
  * with the main instruction path.  This means when everything is well,
@@ -17,6 +25,7 @@
 struct exception_table_entry
 {
 	int insn, fixup;
+	long handler;
 };
 
 extern struct exception_table_entry *__start_dma_ex_table;
@@ -29,6 +38,39 @@ static inline unsigned long extable_fixup(const struct exception_table_entry *x)
 	return (unsigned long)&x->fixup + x->fixup;
 }
 
+typedef bool (*ex_handler_t)(const struct exception_table_entry *,
+			     struct pt_regs *);
+
+static inline ex_handler_t
+ex_fixup_handler(const struct exception_table_entry *x)
+{
+	if (likely(!x->handler))
+		return NULL;
+	return (ex_handler_t)((unsigned long)&x->handler + x->handler);
+}
+
+static inline bool ex_handle(const struct exception_table_entry *x,
+			     struct pt_regs *regs)
+{
+	ex_handler_t handler = ex_fixup_handler(x);
+
+	if (unlikely(handler))
+		return handler(x, regs);
+	regs->psw.addr = extable_fixup(x);
+	return true;
+}
+
 #define ARCH_HAS_RELATIVE_EXTABLE
 
+static inline void swap_ex_entry_fixup(struct exception_table_entry *a,
+				       struct exception_table_entry *b,
+				       struct exception_table_entry tmp,
+				       int delta)
+{
+	a->fixup = b->fixup + delta;
+	b->fixup = tmp.fixup - delta;
+	a->handler = b->handler + delta;
+	b->handler = tmp.handler - delta;
+}
+
 #endif
diff --git a/arch/s390/include/asm/linkage.h b/arch/s390/include/asm/linkage.h
index 1b52c07b5642..a0a7a2c72bd4 100644
--- a/arch/s390/include/asm/linkage.h
+++ b/arch/s390/include/asm/linkage.h
@@ -14,9 +14,10 @@
 
 #define __EX_TABLE(_section, _fault, _target)				\
 	stringify_in_c(.section	_section,"a";)				\
-	stringify_in_c(.align	4;)					\
+	stringify_in_c(.align	8;)					\
 	stringify_in_c(.long	(_fault) - .;)				\
 	stringify_in_c(.long	(_target) - .;)				\
+	stringify_in_c(.quad	0;)					\
 	stringify_in_c(.previous)
 
 #define EX_TABLE(_fault, _target)					\
diff --git a/arch/s390/kernel/kprobes.c b/arch/s390/kernel/kprobes.c
index c0c88340aefe..4323acd243ca 100644
--- a/arch/s390/kernel/kprobes.c
+++ b/arch/s390/kernel/kprobes.c
@@ -543,10 +543,8 @@ static int kprobe_trap_handler(struct pt_regs *regs, int trapnr)
 		 * zero, try to fix up.
 		 */
 		entry = s390_search_extables(regs->psw.addr);
-		if (entry) {
-			regs->psw.addr = extable_fixup(entry);
+		if (entry && ex_handle(entry, regs))
 			return 1;
-		}
 
 		/*
 		 * fixup_exception() could not handle it,
* Unmerged path arch/s390/kernel/traps.c
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index f88e57399bbb..45cbd45f65e9 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -293,10 +293,8 @@ static noinline void do_no_context(struct pt_regs *regs)
 
 	/* Are we prepared to handle this kernel fault?  */
 	fixup = s390_search_extables(regs->psw.addr);
-	if (fixup) {
-		regs->psw.addr = extable_fixup(fixup);
+	if (fixup && ex_handle(fixup, regs))
 		return;
-	}
 
 	/*
 	 * Oops. The kernel tried to access some bad page. We'll have to
* Unmerged path scripts/sortextable.c
