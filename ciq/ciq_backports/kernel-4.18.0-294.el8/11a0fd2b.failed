dmaengine: Move dma_channel_rebalance() infrastructure up in code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Logan Gunthorpe <logang@deltatee.com>
commit 11a0fd2b3baa5e4a97197b9cd990b5d05e69d669
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/11a0fd2b.failed

So it can be called by a release function which is needed higher up in
the code. No functional changes intended.

	Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
Link: https://lore.kernel.org/r/20191216190120.21374-4-logang@deltatee.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 11a0fd2b3baa5e4a97197b9cd990b5d05e69d669)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/dmaengine.c
diff --cc drivers/dma/dmaengine.c
index 54a771b0bf48,1f9a6293f15a..000000000000
--- a/drivers/dma/dmaengine.c
+++ b/drivers/dma/dmaengine.c
@@@ -369,96 -463,6 +462,99 @@@ void dma_issue_pending_all(void
  }
  EXPORT_SYMBOL(dma_issue_pending_all);
  
++<<<<<<< HEAD
 +/**
 + * dma_chan_is_local - returns true if the channel is in the same numa-node as the cpu
 + */
 +static bool dma_chan_is_local(struct dma_chan *chan, int cpu)
 +{
 +	int node = dev_to_node(chan->device->dev);
 +	return node == -1 || cpumask_test_cpu(cpu, cpumask_of_node(node));
 +}
 +
 +/**
 + * min_chan - returns the channel with min count and in the same numa-node as the cpu
 + * @cap: capability to match
 + * @cpu: cpu index which the channel should be close to
 + *
 + * If some channels are close to the given cpu, the one with the lowest
 + * reference count is returned. Otherwise, cpu is ignored and only the
 + * reference count is taken into account.
 + * Must be called under dma_list_mutex.
 + */
 +static struct dma_chan *min_chan(enum dma_transaction_type cap, int cpu)
 +{
 +	struct dma_device *device;
 +	struct dma_chan *chan;
 +	struct dma_chan *min = NULL;
 +	struct dma_chan *localmin = NULL;
 +
 +	list_for_each_entry(device, &dma_device_list, global_node) {
 +		if (!dma_has_cap(cap, device->cap_mask) ||
 +		    dma_has_cap(DMA_PRIVATE, device->cap_mask))
 +			continue;
 +		list_for_each_entry(chan, &device->channels, device_node) {
 +			if (!chan->client_count)
 +				continue;
 +			if (!min || chan->table_count < min->table_count)
 +				min = chan;
 +
 +			if (dma_chan_is_local(chan, cpu))
 +				if (!localmin ||
 +				    chan->table_count < localmin->table_count)
 +					localmin = chan;
 +		}
 +	}
 +
 +	chan = localmin ? localmin : min;
 +
 +	if (chan)
 +		chan->table_count++;
 +
 +	return chan;
 +}
 +
 +/**
 + * dma_channel_rebalance - redistribute the available channels
 + *
 + * Optimize for cpu isolation (each cpu gets a dedicated channel for an
 + * operation type) in the SMP case,  and operation isolation (avoid
 + * multi-tasking channels) in the non-SMP case.  Must be called under
 + * dma_list_mutex.
 + */
 +static void dma_channel_rebalance(void)
 +{
 +	struct dma_chan *chan;
 +	struct dma_device *device;
 +	int cpu;
 +	int cap;
 +
 +	/* undo the last distribution */
 +	for_each_dma_cap_mask(cap, dma_cap_mask_all)
 +		for_each_possible_cpu(cpu)
 +			per_cpu_ptr(channel_table[cap], cpu)->chan = NULL;
 +
 +	list_for_each_entry(device, &dma_device_list, global_node) {
 +		if (dma_has_cap(DMA_PRIVATE, device->cap_mask))
 +			continue;
 +		list_for_each_entry(chan, &device->channels, device_node)
 +			chan->table_count = 0;
 +	}
 +
 +	/* don't populate the channel_table if no clients are available */
 +	if (!dmaengine_ref_count)
 +		return;
 +
 +	/* redistribute available channels */
 +	for_each_dma_cap_mask(cap, dma_cap_mask_all)
 +		for_each_online_cpu(cpu) {
 +			chan = min_chan(cap, cpu);
 +			per_cpu_ptr(channel_table[cap], cpu)->chan = chan;
 +		}
 +}
 +
++=======
++>>>>>>> 11a0fd2b3baa (dmaengine: Move dma_channel_rebalance() infrastructure up in code)
  int dma_get_slave_caps(struct dma_chan *chan, struct dma_slave_caps *caps)
  {
  	struct dma_device *device;
* Unmerged path drivers/dma/dmaengine.c
