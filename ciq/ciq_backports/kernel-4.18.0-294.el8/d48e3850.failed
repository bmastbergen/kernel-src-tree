locking/lockdep: Remove more raw_cpu_read() usage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit d48e3850030623e1c20785bceaaf78f916d0b1a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d48e3850.failed

I initially thought raw_cpu_read() was OK, since if it is !0 we have
IRQs disabled and can't get migrated, so if we get migrated both CPUs
must have 0 and it doesn't matter which 0 we read.

And while that is true; it isn't the whole store, on pretty much all
architectures (except x86) this can result in computing the address for
one CPU, getting migrated, the old CPU continuing execution with another
task (possibly setting recursion) and then the new CPU reading the value
of the old CPU, which is no longer 0.

Similer to:

  baffd723e44d ("lockdep: Revert "lockdep: Use raw_cpu_*() for per-cpu variables"")

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20201026152256.GB2651@hirez.programming.kicks-ass.net
(cherry picked from commit d48e3850030623e1c20785bceaaf78f916d0b1a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/lockdep.c
diff --cc kernel/locking/lockdep.c
index 3d05c48cad08,11028497d4df..000000000000
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@@ -74,6 -76,23 +74,26 @@@ module_param(lock_stat, int, 0644)
  #define lock_stat 0
  #endif
  
++<<<<<<< HEAD
++=======
+ DEFINE_PER_CPU(unsigned int, lockdep_recursion);
+ EXPORT_PER_CPU_SYMBOL_GPL(lockdep_recursion);
+ 
+ static inline bool lockdep_enabled(void)
+ {
+ 	if (!debug_locks)
+ 		return false;
+ 
+ 	if (this_cpu_read(lockdep_recursion))
+ 		return false;
+ 
+ 	if (current->lockdep_recursion)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> d48e38500306 (locking/lockdep: Remove more raw_cpu_read() usage)
  /*
   * lockdep_lock: protects the lockdep graph, the hashes and the
   *               class/list/hash allocators.
* Unmerged path kernel/locking/lockdep.c
