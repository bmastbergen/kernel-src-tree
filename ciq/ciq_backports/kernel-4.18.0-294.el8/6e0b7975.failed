powerpc/ptrace: move register viewing functions out of ptrace.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christophe Leroy <christophe.leroy@c-s.fr>
commit 6e0b79750ce2f3b9c9eabbb5687f343483abdc64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6e0b7975.failed

Create a dedicated ptrace-view.c file.

	Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/bfd8c3ed57c9057e4a5d3816737b5ee98c6f7e43.1582848567.git.christophe.leroy@c-s.fr
(cherry picked from commit 6e0b79750ce2f3b9c9eabbb5687f343483abdc64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/ptrace-view.c
#	arch/powerpc/kernel/ptrace.c
#	arch/powerpc/kernel/ptrace/Makefile
#	arch/powerpc/kernel/ptrace/ptrace-decl.h
diff --cc arch/powerpc/kernel/ptrace.c
index c48b84f0c17a,95e66dad32e0..000000000000
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@@ -20,2253 -20,16 +20,2254 @@@
  #include <linux/audit.h>
  #include <linux/hw_breakpoint.h>
  #include <linux/context_tracking.h>
- #include <linux/nospec.h>
  #include <linux/syscalls.h>
- #include <linux/pkeys.h>
  
  #include <asm/switch_to.h>
 +#include <asm/tm.h>
  #include <asm/asm-prototypes.h>
  #include <asm/debug.h>
  
  #define CREATE_TRACE_POINTS
  #include <trace/events/syscalls.h>
  
++<<<<<<< HEAD:arch/powerpc/kernel/ptrace.c
 +struct pt_regs_offset {
 +	const char *name;
 +	int offset;
 +};
 +
 +#define STR(s)	#s			/* convert to string */
 +#define REG_OFFSET_NAME(r) {.name = #r, .offset = offsetof(struct pt_regs, r)}
 +#define GPR_OFFSET_NAME(num)	\
 +	{.name = STR(r##num), .offset = offsetof(struct pt_regs, gpr[num])}, \
 +	{.name = STR(gpr##num), .offset = offsetof(struct pt_regs, gpr[num])}
 +#define REG_OFFSET_END {.name = NULL, .offset = 0}
 +
 +#define TVSO(f)	(offsetof(struct thread_vr_state, f))
 +#define TFSO(f)	(offsetof(struct thread_fp_state, f))
 +#define TSO(f)	(offsetof(struct thread_struct, f))
 +
 +static const struct pt_regs_offset regoffset_table[] = {
 +	GPR_OFFSET_NAME(0),
 +	GPR_OFFSET_NAME(1),
 +	GPR_OFFSET_NAME(2),
 +	GPR_OFFSET_NAME(3),
 +	GPR_OFFSET_NAME(4),
 +	GPR_OFFSET_NAME(5),
 +	GPR_OFFSET_NAME(6),
 +	GPR_OFFSET_NAME(7),
 +	GPR_OFFSET_NAME(8),
 +	GPR_OFFSET_NAME(9),
 +	GPR_OFFSET_NAME(10),
 +	GPR_OFFSET_NAME(11),
 +	GPR_OFFSET_NAME(12),
 +	GPR_OFFSET_NAME(13),
 +	GPR_OFFSET_NAME(14),
 +	GPR_OFFSET_NAME(15),
 +	GPR_OFFSET_NAME(16),
 +	GPR_OFFSET_NAME(17),
 +	GPR_OFFSET_NAME(18),
 +	GPR_OFFSET_NAME(19),
 +	GPR_OFFSET_NAME(20),
 +	GPR_OFFSET_NAME(21),
 +	GPR_OFFSET_NAME(22),
 +	GPR_OFFSET_NAME(23),
 +	GPR_OFFSET_NAME(24),
 +	GPR_OFFSET_NAME(25),
 +	GPR_OFFSET_NAME(26),
 +	GPR_OFFSET_NAME(27),
 +	GPR_OFFSET_NAME(28),
 +	GPR_OFFSET_NAME(29),
 +	GPR_OFFSET_NAME(30),
 +	GPR_OFFSET_NAME(31),
 +	REG_OFFSET_NAME(nip),
 +	REG_OFFSET_NAME(msr),
 +	REG_OFFSET_NAME(ctr),
 +	REG_OFFSET_NAME(link),
 +	REG_OFFSET_NAME(xer),
 +	REG_OFFSET_NAME(ccr),
 +#ifdef CONFIG_PPC64
 +	REG_OFFSET_NAME(softe),
 +#else
 +	REG_OFFSET_NAME(mq),
 +#endif
 +	REG_OFFSET_NAME(trap),
 +	REG_OFFSET_NAME(dar),
 +	REG_OFFSET_NAME(dsisr),
 +	REG_OFFSET_END,
 +};
 +
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +static void flush_tmregs_to_thread(struct task_struct *tsk)
 +{
 +	/*
 +	 * If task is not current, it will have been flushed already to
 +	 * it's thread_struct during __switch_to().
 +	 *
 +	 * A reclaim flushes ALL the state or if not in TM save TM SPRs
 +	 * in the appropriate thread structures from live.
 +	 */
 +
 +	if ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))
 +		return;
 +
 +	if (MSR_TM_SUSPENDED(mfmsr())) {
 +		tm_reclaim_current(TM_CAUSE_SIGNAL);
 +	} else {
 +		tm_enable();
 +		tm_save_sprs(&(tsk->thread));
 +	}
 +}
 +#else
 +static inline void flush_tmregs_to_thread(struct task_struct *tsk) { }
 +#endif
 +
 +/**
 + * regs_query_register_offset() - query register offset from its name
 + * @name:	the name of a register
 + *
 + * regs_query_register_offset() returns the offset of a register in struct
 + * pt_regs from its name. If the name is invalid, this returns -EINVAL;
 + */
 +int regs_query_register_offset(const char *name)
 +{
 +	const struct pt_regs_offset *roff;
 +	for (roff = regoffset_table; roff->name != NULL; roff++)
 +		if (!strcmp(roff->name, name))
 +			return roff->offset;
 +	return -EINVAL;
 +}
 +
 +/**
 + * regs_query_register_name() - query register name from its offset
 + * @offset:	the offset of a register in struct pt_regs.
 + *
 + * regs_query_register_name() returns the name of a register from its
 + * offset in struct pt_regs. If the @offset is invalid, this returns NULL;
 + */
 +const char *regs_query_register_name(unsigned int offset)
 +{
 +	const struct pt_regs_offset *roff;
 +	for (roff = regoffset_table; roff->name != NULL; roff++)
 +		if (roff->offset == offset)
 +			return roff->name;
 +	return NULL;
 +}
 +
 +/*
 + * does not yet catch signals sent when the child dies.
 + * in exit.c or in signal.c.
 + */
 +
 +/*
 + * Set of msr bits that gdb can change on behalf of a process.
 + */
 +#ifdef CONFIG_PPC_ADV_DEBUG_REGS
 +#define MSR_DEBUGCHANGE	0
 +#else
 +#define MSR_DEBUGCHANGE	(MSR_SE | MSR_BE)
 +#endif
 +
 +/*
 + * Max register writeable via put_reg
 + */
 +#ifdef CONFIG_PPC32
 +#define PT_MAX_PUT_REG	PT_MQ
 +#else
 +#define PT_MAX_PUT_REG	PT_CCR
 +#endif
 +
 +static unsigned long get_user_msr(struct task_struct *task)
 +{
 +	return task->thread.regs->msr | task->thread.fpexc_mode;
 +}
 +
 +static int set_user_msr(struct task_struct *task, unsigned long msr)
 +{
 +	task->thread.regs->msr &= ~MSR_DEBUGCHANGE;
 +	task->thread.regs->msr |= msr & MSR_DEBUGCHANGE;
 +	return 0;
 +}
 +
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +static unsigned long get_user_ckpt_msr(struct task_struct *task)
 +{
 +	return task->thread.ckpt_regs.msr | task->thread.fpexc_mode;
 +}
 +
 +static int set_user_ckpt_msr(struct task_struct *task, unsigned long msr)
 +{
 +	task->thread.ckpt_regs.msr &= ~MSR_DEBUGCHANGE;
 +	task->thread.ckpt_regs.msr |= msr & MSR_DEBUGCHANGE;
 +	return 0;
 +}
 +
 +static int set_user_ckpt_trap(struct task_struct *task, unsigned long trap)
 +{
 +	task->thread.ckpt_regs.trap = trap & 0xfff0;
 +	return 0;
 +}
 +#endif
 +
 +#ifdef CONFIG_PPC64
 +static int get_user_dscr(struct task_struct *task, unsigned long *data)
 +{
 +	*data = task->thread.dscr;
 +	return 0;
 +}
 +
 +static int set_user_dscr(struct task_struct *task, unsigned long dscr)
 +{
 +	task->thread.dscr = dscr;
 +	task->thread.dscr_inherit = 1;
 +	return 0;
 +}
 +#else
 +static int get_user_dscr(struct task_struct *task, unsigned long *data)
 +{
 +	return -EIO;
 +}
 +
 +static int set_user_dscr(struct task_struct *task, unsigned long dscr)
 +{
 +	return -EIO;
 +}
 +#endif
 +
 +/*
 + * We prevent mucking around with the reserved area of trap
 + * which are used internally by the kernel.
 + */
 +static int set_user_trap(struct task_struct *task, unsigned long trap)
 +{
 +	task->thread.regs->trap = trap & 0xfff0;
 +	return 0;
 +}
 +
 +/*
 + * Get contents of register REGNO in task TASK.
 + */
 +int ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)
 +{
 +	unsigned int regs_max;
 +
 +	if ((task->thread.regs == NULL) || !data)
 +		return -EIO;
 +
 +	if (regno == PT_MSR) {
 +		*data = get_user_msr(task);
 +		return 0;
 +	}
 +
 +	if (regno == PT_DSCR)
 +		return get_user_dscr(task, data);
 +
 +	/*
 +	 * softe copies paca->irq_soft_mask variable state. Since irq_soft_mask is
 +	 * no more used as a flag, lets force usr to alway see the softe value as 1
 +	 * which means interrupts are not soft disabled.
 +	 */
 +	if (IS_ENABLED(CONFIG_PPC64) && regno == PT_SOFTE) {
 +		*data = 1;
 +		return  0;
 +	}
 +
 +	regs_max = sizeof(struct pt_regs) / sizeof(unsigned long);
 +	if (regno < regs_max) {
 +		regno = array_index_nospec(regno, regs_max);
 +		*data = ((unsigned long *)task->thread.regs)[regno];
 +		return 0;
 +	}
 +
 +	return -EIO;
 +}
 +
 +/*
 + * Write contents of register REGNO in task TASK.
 + */
 +int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)
 +{
 +	if (task->thread.regs == NULL)
 +		return -EIO;
 +
 +	if (regno == PT_MSR)
 +		return set_user_msr(task, data);
 +	if (regno == PT_TRAP)
 +		return set_user_trap(task, data);
 +	if (regno == PT_DSCR)
 +		return set_user_dscr(task, data);
 +
 +	if (regno <= PT_MAX_PUT_REG) {
 +		regno = array_index_nospec(regno, PT_MAX_PUT_REG + 1);
 +		((unsigned long *)task->thread.regs)[regno] = data;
 +		return 0;
 +	}
 +	return -EIO;
 +}
 +
 +static int gpr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +	int i, ret;
 +
 +	if (target->thread.regs == NULL)
 +		return -EIO;
 +
 +	if (!FULL_REGS(target->thread.regs)) {
 +		/* We have a partial register set.  Fill 14-31 with bogus values */
 +		for (i = 14; i < 32; i++)
 +			target->thread.regs->gpr[i] = NV_REG_POISON;
 +	}
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  target->thread.regs,
 +				  0, offsetof(struct pt_regs, msr));
 +	if (!ret) {
 +		unsigned long msr = get_user_msr(target);
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,
 +					  offsetof(struct pt_regs, msr),
 +					  offsetof(struct pt_regs, msr) +
 +					  sizeof(msr));
 +	}
 +
 +	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 +		     offsetof(struct pt_regs, msr) + sizeof(long));
 +
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					  &target->thread.regs->orig_gpr3,
 +					  offsetof(struct pt_regs, orig_gpr3),
 +					  sizeof(struct pt_regs));
 +	if (!ret)
 +		ret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,
 +					       sizeof(struct pt_regs), -1);
 +
 +	return ret;
 +}
 +
 +static int gpr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +	unsigned long reg;
 +	int ret;
 +
 +	if (target->thread.regs == NULL)
 +		return -EIO;
 +
 +	CHECK_FULL_REGS(target->thread.regs);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 target->thread.regs,
 +				 0, PT_MSR * sizeof(reg));
 +
 +	if (!ret && count > 0) {
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 +					 PT_MSR * sizeof(reg),
 +					 (PT_MSR + 1) * sizeof(reg));
 +		if (!ret)
 +			ret = set_user_msr(target, reg);
 +	}
 +
 +	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 +		     offsetof(struct pt_regs, msr) + sizeof(long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					 &target->thread.regs->orig_gpr3,
 +					 PT_ORIG_R3 * sizeof(reg),
 +					 (PT_MAX_PUT_REG + 1) * sizeof(reg));
 +
 +	if (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)
 +		ret = user_regset_copyin_ignore(
 +			&pos, &count, &kbuf, &ubuf,
 +			(PT_MAX_PUT_REG + 1) * sizeof(reg),
 +			PT_TRAP * sizeof(reg));
 +
 +	if (!ret && count > 0) {
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 +					 PT_TRAP * sizeof(reg),
 +					 (PT_TRAP + 1) * sizeof(reg));
 +		if (!ret)
 +			ret = set_user_trap(target, reg);
 +	}
 +
 +	if (!ret)
 +		ret = user_regset_copyin_ignore(
 +			&pos, &count, &kbuf, &ubuf,
 +			(PT_TRAP + 1) * sizeof(reg), -1);
 +
 +	return ret;
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last checkpointed
 + * value of all FPR registers for the current transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + * };
 + */
 +static int fpr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +#ifdef CONFIG_VSX
 +	u64 buf[33];
 +	int i;
 +
 +	flush_fp_to_thread(target);
 +
 +	/* copy to local buffer then write that out */
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.TS_FPR(i);
 +	buf[32] = target->thread.fp_state.fpscr;
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +#else
 +	BUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=
 +		     offsetof(struct thread_fp_state, fpr[32]));
 +
 +	flush_fp_to_thread(target);
 +
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				   &target->thread.fp_state, 0, -1);
 +#endif
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last checkpointed
 + * value of all FPR registers for the current transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + * };
 + *
 + */
 +static int fpr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +#ifdef CONFIG_VSX
 +	u64 buf[33];
 +	int i;
 +
 +	flush_fp_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.TS_FPR(i);
 +	buf[32] = target->thread.fp_state.fpscr;
 +
 +	/* copy to local buffer then write that out */
 +	i = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +	if (i)
 +		return i;
 +
 +	for (i = 0; i < 32 ; i++)
 +		target->thread.TS_FPR(i) = buf[i];
 +	target->thread.fp_state.fpscr = buf[32];
 +	return 0;
 +#else
 +	BUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=
 +		     offsetof(struct thread_fp_state, fpr[32]));
 +
 +	flush_fp_to_thread(target);
 +
 +	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.fp_state, 0, -1);
 +#endif
 +}
 +
 +#ifdef CONFIG_ALTIVEC
 +/*
 + * Get/set all the altivec registers vr0..vr31, vscr, vrsave, in one go.
 + * The transfer totals 34 quadword.  Quadwords 0-31 contain the
 + * corresponding vector registers.  Quadword 32 contains the vscr as the
 + * last word (offset 12) within that quadword.  Quadword 33 contains the
 + * vrsave as the first word (offset 0) within the quadword.
 + *
 + * This definition of the VMX state is compatible with the current PPC32
 + * ptrace interface.  This allows signal handling and ptrace to use the
 + * same structures.  This also simplifies the implementation of a bi-arch
 + * (combined (32- and 64-bit) gdb.
 + */
 +
 +static int vr_active(struct task_struct *target,
 +		     const struct user_regset *regset)
 +{
 +	flush_altivec_to_thread(target);
 +	return target->thread.used_vr ? regset->n : 0;
 +}
 +
 +/*
 + * Regardless of transactions, 'vr_state' holds the current running
 + * value of all the VMX registers and 'ckvr_state' holds the last
 + * checkpointed value of all the VMX registers for the current
 + * transaction to fall back on in case it aborts.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + * };
 + */
 +static int vr_get(struct task_struct *target, const struct user_regset *regset,
 +		  unsigned int pos, unsigned int count,
 +		  void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_altivec_to_thread(target);
 +
 +	BUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=
 +		     offsetof(struct thread_vr_state, vr[32]));
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.vr_state, 0,
 +				  33 * sizeof(vector128));
 +	if (!ret) {
 +		/*
 +		 * Copy out only the low-order word of vrsave.
 +		 */
 +		int start, end;
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +
 +		vrsave.word = target->thread.vrsave;
 +
 +		start = 33 * sizeof(vector128);
 +		end = start + sizeof(vrsave);
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,
 +					  start, end);
 +	}
 +
 +	return ret;
 +}
 +
 +/*
 + * Regardless of transactions, 'vr_state' holds the current running
 + * value of all the VMX registers and 'ckvr_state' holds the last
 + * checkpointed value of all the VMX registers for the current
 + * transaction to fall back on in case it aborts.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + * };
 + */
 +static int vr_set(struct task_struct *target, const struct user_regset *regset,
 +		  unsigned int pos, unsigned int count,
 +		  const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_altivec_to_thread(target);
 +
 +	BUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=
 +		     offsetof(struct thread_vr_state, vr[32]));
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &target->thread.vr_state, 0,
 +				 33 * sizeof(vector128));
 +	if (!ret && count > 0) {
 +		/*
 +		 * We use only the first word of vrsave.
 +		 */
 +		int start, end;
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +
 +		vrsave.word = target->thread.vrsave;
 +
 +		start = 33 * sizeof(vector128);
 +		end = start + sizeof(vrsave);
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,
 +					 start, end);
 +		if (!ret)
 +			target->thread.vrsave = vrsave.word;
 +	}
 +
 +	return ret;
 +}
 +#endif /* CONFIG_ALTIVEC */
 +
 +#ifdef CONFIG_VSX
 +/*
 + * Currently to set and and get all the vsx state, you need to call
 + * the fp and VMX calls as well.  This only get/sets the lower 32
 + * 128bit VSX registers.
 + */
 +
 +static int vsr_active(struct task_struct *target,
 +		      const struct user_regset *regset)
 +{
 +	flush_vsx_to_thread(target);
 +	return target->thread.used_vsr ? regset->n : 0;
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last
 + * checkpointed value of all FPR registers for the current
 + * transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	vsx[32];
 + * };
 + */
 +static int vsr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret, i;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  buf, 0, 32 * sizeof(double));
 +
 +	return ret;
 +}
 +
 +/*
 + * Regardless of transactions, 'fp_state' holds the current running
 + * value of all FPR registers and 'ckfp_state' holds the last
 + * checkpointed value of all FPR registers for the current
 + * transaction.
 + *
 + * Userspace interface buffer layout:
 + *
 + * struct data {
 + *	u64	vsx[32];
 + * };
 + */
 +static int vsr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret,i;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 buf, 0, 32 * sizeof(double));
 +	if (!ret)
 +		for (i = 0; i < 32 ; i++)
 +			target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];
 +
 +	return ret;
 +}
 +#endif /* CONFIG_VSX */
 +
 +#ifdef CONFIG_SPE
 +
 +/*
 + * For get_evrregs/set_evrregs functions 'data' has the following layout:
 + *
 + * struct {
 + *   u32 evr[32];
 + *   u64 acc;
 + *   u32 spefscr;
 + * }
 + */
 +
 +static int evr_active(struct task_struct *target,
 +		      const struct user_regset *regset)
 +{
 +	flush_spe_to_thread(target);
 +	return target->thread.used_spe ? regset->n : 0;
 +}
 +
 +static int evr_get(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_spe_to_thread(target);
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.evr,
 +				  0, sizeof(target->thread.evr));
 +
 +	BUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=
 +		     offsetof(struct thread_struct, spefscr));
 +
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					  &target->thread.acc,
 +					  sizeof(target->thread.evr), -1);
 +
 +	return ret;
 +}
 +
 +static int evr_set(struct task_struct *target, const struct user_regset *regset,
 +		   unsigned int pos, unsigned int count,
 +		   const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	flush_spe_to_thread(target);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &target->thread.evr,
 +				 0, sizeof(target->thread.evr));
 +
 +	BUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=
 +		     offsetof(struct thread_struct, spefscr));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					 &target->thread.acc,
 +					 sizeof(target->thread.evr), -1);
 +
 +	return ret;
 +}
 +#endif /* CONFIG_SPE */
 +
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +/**
 + * tm_cgpr_active - get active number of registers in CGPR
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks for the active number of available
 + * regisers in transaction checkpointed GPR category.
 + */
 +static int tm_cgpr_active(struct task_struct *target,
 +			  const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return 0;
 +
 +	return regset->n;
 +}
 +
 +/**
 + * tm_cgpr_get - get CGPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets transaction checkpointed GPR registers.
 + *
 + * When the transaction is active, 'ckpt_regs' holds all the checkpointed
 + * GPR register values for the current transaction to fall back on if it
 + * aborts in between. This function gets those checkpointed GPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	struct pt_regs ckpt_regs;
 + * };
 + */
 +static int tm_cgpr_get(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.ckpt_regs,
 +				  0, offsetof(struct pt_regs, msr));
 +	if (!ret) {
 +		unsigned long msr = get_user_ckpt_msr(target);
 +
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,
 +					  offsetof(struct pt_regs, msr),
 +					  offsetof(struct pt_regs, msr) +
 +					  sizeof(msr));
 +	}
 +
 +	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 +		     offsetof(struct pt_regs, msr) + sizeof(long));
 +
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					  &target->thread.ckpt_regs.orig_gpr3,
 +					  offsetof(struct pt_regs, orig_gpr3),
 +					  sizeof(struct pt_regs));
 +	if (!ret)
 +		ret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,
 +					       sizeof(struct pt_regs), -1);
 +
 +	return ret;
 +}
 +
 +/*
 + * tm_cgpr_set - set the CGPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets in transaction checkpointed GPR registers.
 + *
 + * When the transaction is active, 'ckpt_regs' holds the checkpointed
 + * GPR register values for the current transaction to fall back on if it
 + * aborts in between. This function sets those checkpointed GPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	struct pt_regs ckpt_regs;
 + * };
 + */
 +static int tm_cgpr_set(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			const void *kbuf, const void __user *ubuf)
 +{
 +	unsigned long reg;
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &target->thread.ckpt_regs,
 +				 0, PT_MSR * sizeof(reg));
 +
 +	if (!ret && count > 0) {
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 +					 PT_MSR * sizeof(reg),
 +					 (PT_MSR + 1) * sizeof(reg));
 +		if (!ret)
 +			ret = set_user_ckpt_msr(target, reg);
 +	}
 +
 +	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
 +		     offsetof(struct pt_regs, msr) + sizeof(long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					 &target->thread.ckpt_regs.orig_gpr3,
 +					 PT_ORIG_R3 * sizeof(reg),
 +					 (PT_MAX_PUT_REG + 1) * sizeof(reg));
 +
 +	if (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)
 +		ret = user_regset_copyin_ignore(
 +			&pos, &count, &kbuf, &ubuf,
 +			(PT_MAX_PUT_REG + 1) * sizeof(reg),
 +			PT_TRAP * sizeof(reg));
 +
 +	if (!ret && count > 0) {
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
 +					 PT_TRAP * sizeof(reg),
 +					 (PT_TRAP + 1) * sizeof(reg));
 +		if (!ret)
 +			ret = set_user_ckpt_trap(target, reg);
 +	}
 +
 +	if (!ret)
 +		ret = user_regset_copyin_ignore(
 +			&pos, &count, &kbuf, &ubuf,
 +			(PT_TRAP + 1) * sizeof(reg), -1);
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_cfpr_active - get active number of registers in CFPR
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks for the active number of available
 + * regisers in transaction checkpointed FPR category.
 + */
 +static int tm_cfpr_active(struct task_struct *target,
 +				const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return 0;
 +
 +	return regset->n;
 +}
 +
 +/**
 + * tm_cfpr_get - get CFPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets in transaction checkpointed FPR registers.
 + *
 + * When the transaction is active 'ckfp_state' holds the checkpointed
 + * values for the current transaction to fall back on if it aborts
 + * in between. This function gets those checkpointed FPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + *};
 + */
 +static int tm_cfpr_get(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			void *kbuf, void __user *ubuf)
 +{
 +	u64 buf[33];
 +	int i;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	/* copy to local buffer then write that out */
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.TS_CKFPR(i);
 +	buf[32] = target->thread.ckfp_state.fpscr;
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +}
 +
 +/**
 + * tm_cfpr_set - set CFPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets in transaction checkpointed FPR registers.
 + *
 + * When the transaction is active 'ckfp_state' holds the checkpointed
 + * FPR register values for the current transaction to fall back on
 + * if it aborts in between. This function sets these checkpointed
 + * FPR registers. The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	u64	fpr[32];
 + *	u64	fpscr;
 + *};
 + */
 +static int tm_cfpr_set(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			const void *kbuf, const void __user *ubuf)
 +{
 +	u64 buf[33];
 +	int i;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	for (i = 0; i < 32; i++)
 +		buf[i] = target->thread.TS_CKFPR(i);
 +	buf[32] = target->thread.ckfp_state.fpscr;
 +
 +	/* copy to local buffer then write that out */
 +	i = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
 +	if (i)
 +		return i;
 +	for (i = 0; i < 32 ; i++)
 +		target->thread.TS_CKFPR(i) = buf[i];
 +	target->thread.ckfp_state.fpscr = buf[32];
 +	return 0;
 +}
 +
 +/**
 + * tm_cvmx_active - get active number of registers in CVMX
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks for the active number of available
 + * regisers in checkpointed VMX category.
 + */
 +static int tm_cvmx_active(struct task_struct *target,
 +				const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return 0;
 +
 +	return regset->n;
 +}
 +
 +/**
 + * tm_cvmx_get - get CMVX registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets in transaction checkpointed VMX registers.
 + *
 + * When the transaction is active 'ckvr_state' and 'ckvrsave' hold
 + * the checkpointed values for the current transaction to fall
 + * back on if it aborts in between. The userspace interface buffer
 + * layout is as follows.
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + *};
 + */
 +static int tm_cvmx_get(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	BUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	/* Flush the state */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +					&target->thread.ckvr_state, 0,
 +					33 * sizeof(vector128));
 +	if (!ret) {
 +		/*
 +		 * Copy out only the low-order word of vrsave.
 +		 */
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +		vrsave.word = target->thread.ckvrsave;
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,
 +						33 * sizeof(vector128), -1);
 +	}
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_cvmx_set - set CMVX registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets in transaction checkpointed VMX registers.
 + *
 + * When the transaction is active 'ckvr_state' and 'ckvrsave' hold
 + * the checkpointed values for the current transaction to fall
 + * back on if it aborts in between. The userspace interface buffer
 + * layout is as follows.
 + *
 + * struct data {
 + *	vector128	vr[32];
 + *	vector128	vscr;
 + *	vector128	vrsave;
 + *};
 + */
 +static int tm_cvmx_set(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	BUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +					&target->thread.ckvr_state, 0,
 +					33 * sizeof(vector128));
 +	if (!ret && count > 0) {
 +		/*
 +		 * We use only the low-order word of vrsave.
 +		 */
 +		union {
 +			elf_vrreg_t reg;
 +			u32 word;
 +		} vrsave;
 +		memset(&vrsave, 0, sizeof(vrsave));
 +		vrsave.word = target->thread.ckvrsave;
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,
 +						33 * sizeof(vector128), -1);
 +		if (!ret)
 +			target->thread.ckvrsave = vrsave.word;
 +	}
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_cvsx_active - get active number of registers in CVSX
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks for the active number of available
 + * regisers in transaction checkpointed VSX category.
 + */
 +static int tm_cvsx_active(struct task_struct *target,
 +				const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return 0;
 +
 +	flush_vsx_to_thread(target);
 +	return target->thread.used_vsr ? regset->n : 0;
 +}
 +
 +/**
 + * tm_cvsx_get - get CVSX registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets in transaction checkpointed VSX registers.
 + *
 + * When the transaction is active 'ckfp_state' holds the checkpointed
 + * values for the current transaction to fall back on if it aborts
 + * in between. This function gets those checkpointed VSX registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	u64	vsx[32];
 + *};
 + */
 +static int tm_cvsx_get(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			void *kbuf, void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret, i;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	/* Flush the state */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				  buf, 0, 32 * sizeof(double));
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_cvsx_set - set CFPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets in transaction checkpointed VSX registers.
 + *
 + * When the transaction is active 'ckfp_state' holds the checkpointed
 + * VSX register values for the current transaction to fall back on
 + * if it aborts in between. This function sets these checkpointed
 + * FPR registers. The userspace interface buffer layout is as follows.
 + *
 + * struct data {
 + *	u64	vsx[32];
 + *};
 + */
 +static int tm_cvsx_set(struct task_struct *target,
 +			const struct user_regset *regset,
 +			unsigned int pos, unsigned int count,
 +			const void *kbuf, const void __user *ubuf)
 +{
 +	u64 buf[32];
 +	int ret, i;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	/* Flush the state */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +	flush_vsx_to_thread(target);
 +
 +	for (i = 0; i < 32 ; i++)
 +		buf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 buf, 0, 32 * sizeof(double));
 +	if (!ret)
 +		for (i = 0; i < 32 ; i++)
 +			target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];
 +
 +	return ret;
 +}
 +
 +/**
 + * tm_spr_active - get active number of registers in TM SPR
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + *
 + * This function checks the active number of available
 + * regisers in the transactional memory SPR category.
 + */
 +static int tm_spr_active(struct task_struct *target,
 +			 const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	return regset->n;
 +}
 +
 +/**
 + * tm_spr_get - get the TM related SPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy from.
 + * @ubuf:	User buffer to copy into.
 + *
 + * This function gets transactional memory related SPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct {
 + *	u64		tm_tfhar;
 + *	u64		tm_texasr;
 + *	u64		tm_tfiar;
 + * };
 + */
 +static int tm_spr_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	/* Build tests */
 +	BUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));
 +	BUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));
 +	BUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	/* Flush the states */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	/* TFHAR register */
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tfhar, 0, sizeof(u64));
 +
 +	/* TEXASR register */
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_texasr, sizeof(u64),
 +				2 * sizeof(u64));
 +
 +	/* TFIAR register */
 +	if (!ret)
 +		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tfiar,
 +				2 * sizeof(u64), 3 * sizeof(u64));
 +	return ret;
 +}
 +
 +/**
 + * tm_spr_set - set the TM related SPR registers
 + * @target:	The target task.
 + * @regset:	The user regset structure.
 + * @pos:	The buffer position.
 + * @count:	Number of bytes to copy.
 + * @kbuf:	Kernel buffer to copy into.
 + * @ubuf:	User buffer to copy from.
 + *
 + * This function sets transactional memory related SPR registers.
 + * The userspace interface buffer layout is as follows.
 + *
 + * struct {
 + *	u64		tm_tfhar;
 + *	u64		tm_texasr;
 + *	u64		tm_tfiar;
 + * };
 + */
 +static int tm_spr_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	/* Build tests */
 +	BUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));
 +	BUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));
 +	BUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	/* Flush the states */
 +	flush_tmregs_to_thread(target);
 +	flush_fp_to_thread(target);
 +	flush_altivec_to_thread(target);
 +
 +	/* TFHAR register */
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tfhar, 0, sizeof(u64));
 +
 +	/* TEXASR register */
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_texasr, sizeof(u64),
 +				2 * sizeof(u64));
 +
 +	/* TFIAR register */
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tfiar,
 +				 2 * sizeof(u64), 3 * sizeof(u64));
 +	return ret;
 +}
 +
 +static int tm_tar_active(struct task_struct *target,
 +			 const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return regset->n;
 +
 +	return 0;
 +}
 +
 +static int tm_tar_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tar, 0, sizeof(u64));
 +	return ret;
 +}
 +
 +static int tm_tar_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_tar, 0, sizeof(u64));
 +	return ret;
 +}
 +
 +static int tm_ppr_active(struct task_struct *target,
 +			 const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return regset->n;
 +
 +	return 0;
 +}
 +
 +
 +static int tm_ppr_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_ppr, 0, sizeof(u64));
 +	return ret;
 +}
 +
 +static int tm_ppr_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_ppr, 0, sizeof(u64));
 +	return ret;
 +}
 +
 +static int tm_dscr_active(struct task_struct *target,
 +			 const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return regset->n;
 +
 +	return 0;
 +}
 +
 +static int tm_dscr_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_dscr, 0, sizeof(u64));
 +	return ret;
 +}
 +
 +static int tm_dscr_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	int ret;
 +
 +	if (!cpu_has_feature(CPU_FTR_TM))
 +		return -ENODEV;
 +
 +	if (!MSR_TM_ACTIVE(target->thread.regs->msr))
 +		return -ENODATA;
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				&target->thread.tm_dscr, 0, sizeof(u64));
 +	return ret;
 +}
 +#endif	/* CONFIG_PPC_TRANSACTIONAL_MEM */
 +
 +#ifdef CONFIG_PPC64
 +static int ppr_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				   &target->thread.regs->ppr, 0, sizeof(u64));
 +}
 +
 +static int ppr_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.regs->ppr, 0, sizeof(u64));
 +}
 +
 +static int dscr_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				   &target->thread.dscr, 0, sizeof(u64));
 +}
 +static int dscr_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.dscr, 0, sizeof(u64));
 +}
 +#endif
 +#ifdef CONFIG_PPC_BOOK3S_64
 +static int tar_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				   &target->thread.tar, 0, sizeof(u64));
 +}
 +static int tar_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				  &target->thread.tar, 0, sizeof(u64));
 +}
 +
 +static int ebb_active(struct task_struct *target,
 +			 const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_ARCH_207S))
 +		return -ENODEV;
 +
 +	if (target->thread.used_ebb)
 +		return regset->n;
 +
 +	return 0;
 +}
 +
 +static int ebb_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	/* Build tests */
 +	BUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));
 +	BUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));
 +
 +	if (!cpu_has_feature(CPU_FTR_ARCH_207S))
 +		return -ENODEV;
 +
 +	if (!target->thread.used_ebb)
 +		return -ENODATA;
 +
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.ebbrr, 0, 3 * sizeof(unsigned long));
 +}
 +
 +static int ebb_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	int ret = 0;
 +
 +	/* Build tests */
 +	BUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));
 +	BUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));
 +
 +	if (!cpu_has_feature(CPU_FTR_ARCH_207S))
 +		return -ENODEV;
 +
 +	if (target->thread.used_ebb)
 +		return -ENODATA;
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.ebbrr, 0, sizeof(unsigned long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.ebbhr, sizeof(unsigned long),
 +			2 * sizeof(unsigned long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.bescr,
 +			2 * sizeof(unsigned long), 3 * sizeof(unsigned long));
 +
 +	return ret;
 +}
 +static int pmu_active(struct task_struct *target,
 +			 const struct user_regset *regset)
 +{
 +	if (!cpu_has_feature(CPU_FTR_ARCH_207S))
 +		return -ENODEV;
 +
 +	return regset->n;
 +}
 +
 +static int pmu_get(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      void *kbuf, void __user *ubuf)
 +{
 +	/* Build tests */
 +	BUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));
 +	BUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));
 +	BUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));
 +	BUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));
 +
 +	if (!cpu_has_feature(CPU_FTR_ARCH_207S))
 +		return -ENODEV;
 +
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.siar, 0,
 +			5 * sizeof(unsigned long));
 +}
 +
 +static int pmu_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	int ret = 0;
 +
 +	/* Build tests */
 +	BUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));
 +	BUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));
 +	BUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));
 +	BUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));
 +
 +	if (!cpu_has_feature(CPU_FTR_ARCH_207S))
 +		return -ENODEV;
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.siar, 0,
 +			sizeof(unsigned long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.sdar, sizeof(unsigned long),
 +			2 * sizeof(unsigned long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.sier, 2 * sizeof(unsigned long),
 +			3 * sizeof(unsigned long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.mmcr2, 3 * sizeof(unsigned long),
 +			4 * sizeof(unsigned long));
 +
 +	if (!ret)
 +		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +			&target->thread.mmcr0, 4 * sizeof(unsigned long),
 +			5 * sizeof(unsigned long));
 +	return ret;
 +}
 +#endif
 +
 +#ifdef CONFIG_PPC_MEM_KEYS
 +static int pkey_active(struct task_struct *target,
 +		       const struct user_regset *regset)
 +{
 +	if (!arch_pkeys_enabled())
 +		return -ENODEV;
 +
 +	return regset->n;
 +}
 +
 +static int pkey_get(struct task_struct *target,
 +		    const struct user_regset *regset,
 +		    unsigned int pos, unsigned int count,
 +		    void *kbuf, void __user *ubuf)
 +{
 +	BUILD_BUG_ON(TSO(amr) + sizeof(unsigned long) != TSO(iamr));
 +	BUILD_BUG_ON(TSO(iamr) + sizeof(unsigned long) != TSO(uamor));
 +
 +	if (!arch_pkeys_enabled())
 +		return -ENODEV;
 +
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 +				   &target->thread.amr, 0,
 +				   ELF_NPKEY * sizeof(unsigned long));
 +}
 +
 +static int pkey_set(struct task_struct *target,
 +		      const struct user_regset *regset,
 +		      unsigned int pos, unsigned int count,
 +		      const void *kbuf, const void __user *ubuf)
 +{
 +	u64 new_amr;
 +	int ret;
 +
 +	if (!arch_pkeys_enabled())
 +		return -ENODEV;
 +
 +	/* Only the AMR can be set from userspace */
 +	if (pos != 0 || count != sizeof(new_amr))
 +		return -EINVAL;
 +
 +	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 +				 &new_amr, 0, sizeof(new_amr));
 +	if (ret)
 +		return ret;
 +
 +	/* UAMOR determines which bits of the AMR can be set from userspace. */
 +	target->thread.amr = (new_amr & target->thread.uamor) |
 +		(target->thread.amr & ~target->thread.uamor);
 +
 +	return 0;
 +}
 +#endif /* CONFIG_PPC_MEM_KEYS */
 +
 +/*
 + * These are our native regset flavors.
 + */
 +enum powerpc_regset {
 +	REGSET_GPR,
 +	REGSET_FPR,
 +#ifdef CONFIG_ALTIVEC
 +	REGSET_VMX,
 +#endif
 +#ifdef CONFIG_VSX
 +	REGSET_VSX,
 +#endif
 +#ifdef CONFIG_SPE
 +	REGSET_SPE,
 +#endif
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +	REGSET_TM_CGPR,		/* TM checkpointed GPR registers */
 +	REGSET_TM_CFPR,		/* TM checkpointed FPR registers */
 +	REGSET_TM_CVMX,		/* TM checkpointed VMX registers */
 +	REGSET_TM_CVSX,		/* TM checkpointed VSX registers */
 +	REGSET_TM_SPR,		/* TM specific SPR registers */
 +	REGSET_TM_CTAR,		/* TM checkpointed TAR register */
 +	REGSET_TM_CPPR,		/* TM checkpointed PPR register */
 +	REGSET_TM_CDSCR,	/* TM checkpointed DSCR register */
 +#endif
 +#ifdef CONFIG_PPC64
 +	REGSET_PPR,		/* PPR register */
 +	REGSET_DSCR,		/* DSCR register */
 +#endif
 +#ifdef CONFIG_PPC_BOOK3S_64
 +	REGSET_TAR,		/* TAR register */
 +	REGSET_EBB,		/* EBB registers */
 +	REGSET_PMR,		/* Performance Monitor Registers */
 +#endif
 +#ifdef CONFIG_PPC_MEM_KEYS
 +	REGSET_PKEY,		/* AMR register */
 +#endif
 +};
 +
 +static const struct user_regset native_regsets[] = {
 +	[REGSET_GPR] = {
 +		.core_note_type = NT_PRSTATUS, .n = ELF_NGREG,
 +		.size = sizeof(long), .align = sizeof(long),
 +		.get = gpr_get, .set = gpr_set
 +	},
 +	[REGSET_FPR] = {
 +		.core_note_type = NT_PRFPREG, .n = ELF_NFPREG,
 +		.size = sizeof(double), .align = sizeof(double),
 +		.get = fpr_get, .set = fpr_set
 +	},
 +#ifdef CONFIG_ALTIVEC
 +	[REGSET_VMX] = {
 +		.core_note_type = NT_PPC_VMX, .n = 34,
 +		.size = sizeof(vector128), .align = sizeof(vector128),
 +		.active = vr_active, .get = vr_get, .set = vr_set
 +	},
 +#endif
 +#ifdef CONFIG_VSX
 +	[REGSET_VSX] = {
 +		.core_note_type = NT_PPC_VSX, .n = 32,
 +		.size = sizeof(double), .align = sizeof(double),
 +		.active = vsr_active, .get = vsr_get, .set = vsr_set
 +	},
 +#endif
 +#ifdef CONFIG_SPE
 +	[REGSET_SPE] = {
 +		.core_note_type = NT_PPC_SPE, .n = 35,
 +		.size = sizeof(u32), .align = sizeof(u32),
 +		.active = evr_active, .get = evr_get, .set = evr_set
 +	},
 +#endif
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +	[REGSET_TM_CGPR] = {
 +		.core_note_type = NT_PPC_TM_CGPR, .n = ELF_NGREG,
 +		.size = sizeof(long), .align = sizeof(long),
 +		.active = tm_cgpr_active, .get = tm_cgpr_get, .set = tm_cgpr_set
 +	},
 +	[REGSET_TM_CFPR] = {
 +		.core_note_type = NT_PPC_TM_CFPR, .n = ELF_NFPREG,
 +		.size = sizeof(double), .align = sizeof(double),
 +		.active = tm_cfpr_active, .get = tm_cfpr_get, .set = tm_cfpr_set
 +	},
 +	[REGSET_TM_CVMX] = {
 +		.core_note_type = NT_PPC_TM_CVMX, .n = ELF_NVMX,
 +		.size = sizeof(vector128), .align = sizeof(vector128),
 +		.active = tm_cvmx_active, .get = tm_cvmx_get, .set = tm_cvmx_set
 +	},
 +	[REGSET_TM_CVSX] = {
 +		.core_note_type = NT_PPC_TM_CVSX, .n = ELF_NVSX,
 +		.size = sizeof(double), .align = sizeof(double),
 +		.active = tm_cvsx_active, .get = tm_cvsx_get, .set = tm_cvsx_set
 +	},
 +	[REGSET_TM_SPR] = {
 +		.core_note_type = NT_PPC_TM_SPR, .n = ELF_NTMSPRREG,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = tm_spr_active, .get = tm_spr_get, .set = tm_spr_set
 +	},
 +	[REGSET_TM_CTAR] = {
 +		.core_note_type = NT_PPC_TM_CTAR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = tm_tar_active, .get = tm_tar_get, .set = tm_tar_set
 +	},
 +	[REGSET_TM_CPPR] = {
 +		.core_note_type = NT_PPC_TM_CPPR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = tm_ppr_active, .get = tm_ppr_get, .set = tm_ppr_set
 +	},
 +	[REGSET_TM_CDSCR] = {
 +		.core_note_type = NT_PPC_TM_CDSCR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = tm_dscr_active, .get = tm_dscr_get, .set = tm_dscr_set
 +	},
 +#endif
 +#ifdef CONFIG_PPC64
 +	[REGSET_PPR] = {
 +		.core_note_type = NT_PPC_PPR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.get = ppr_get, .set = ppr_set
 +	},
 +	[REGSET_DSCR] = {
 +		.core_note_type = NT_PPC_DSCR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.get = dscr_get, .set = dscr_set
 +	},
 +#endif
 +#ifdef CONFIG_PPC_BOOK3S_64
 +	[REGSET_TAR] = {
 +		.core_note_type = NT_PPC_TAR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.get = tar_get, .set = tar_set
 +	},
 +	[REGSET_EBB] = {
 +		.core_note_type = NT_PPC_EBB, .n = ELF_NEBB,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = ebb_active, .get = ebb_get, .set = ebb_set
 +	},
 +	[REGSET_PMR] = {
 +		.core_note_type = NT_PPC_PMU, .n = ELF_NPMU,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = pmu_active, .get = pmu_get, .set = pmu_set
 +	},
 +#endif
 +#ifdef CONFIG_PPC_MEM_KEYS
 +	[REGSET_PKEY] = {
 +		.core_note_type = NT_PPC_PKEY, .n = ELF_NPKEY,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = pkey_active, .get = pkey_get, .set = pkey_set
 +	},
 +#endif
 +};
 +
 +static const struct user_regset_view user_ppc_native_view = {
 +	.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,
 +	.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)
 +};
 +
 +#include <linux/compat.h>
 +
 +static int gpr32_get_common(struct task_struct *target,
 +		     const struct user_regset *regset,
 +		     unsigned int pos, unsigned int count,
 +			    void *kbuf, void __user *ubuf,
 +			    unsigned long *regs)
 +{
 +	compat_ulong_t *k = kbuf;
 +	compat_ulong_t __user *u = ubuf;
 +	compat_ulong_t reg;
 +
 +	pos /= sizeof(reg);
 +	count /= sizeof(reg);
 +
 +	if (kbuf)
 +		for (; count > 0 && pos < PT_MSR; --count)
 +			*k++ = regs[pos++];
 +	else
 +		for (; count > 0 && pos < PT_MSR; --count)
 +			if (__put_user((compat_ulong_t) regs[pos++], u++))
 +				return -EFAULT;
 +
 +	if (count > 0 && pos == PT_MSR) {
 +		reg = get_user_msr(target);
 +		if (kbuf)
 +			*k++ = reg;
 +		else if (__put_user(reg, u++))
 +			return -EFAULT;
 +		++pos;
 +		--count;
 +	}
 +
 +	if (kbuf)
 +		for (; count > 0 && pos < PT_REGS_COUNT; --count)
 +			*k++ = regs[pos++];
 +	else
 +		for (; count > 0 && pos < PT_REGS_COUNT; --count)
 +			if (__put_user((compat_ulong_t) regs[pos++], u++))
 +				return -EFAULT;
 +
 +	kbuf = k;
 +	ubuf = u;
 +	pos *= sizeof(reg);
 +	count *= sizeof(reg);
 +	return user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,
 +					PT_REGS_COUNT * sizeof(reg), -1);
 +}
 +
 +static int gpr32_set_common(struct task_struct *target,
 +		     const struct user_regset *regset,
 +		     unsigned int pos, unsigned int count,
 +		     const void *kbuf, const void __user *ubuf,
 +		     unsigned long *regs)
 +{
 +	const compat_ulong_t *k = kbuf;
 +	const compat_ulong_t __user *u = ubuf;
 +	compat_ulong_t reg;
 +
 +	pos /= sizeof(reg);
 +	count /= sizeof(reg);
 +
 +	if (kbuf)
 +		for (; count > 0 && pos < PT_MSR; --count)
 +			regs[pos++] = *k++;
 +	else
 +		for (; count > 0 && pos < PT_MSR; --count) {
 +			if (__get_user(reg, u++))
 +				return -EFAULT;
 +			regs[pos++] = reg;
 +		}
 +
 +
 +	if (count > 0 && pos == PT_MSR) {
 +		if (kbuf)
 +			reg = *k++;
 +		else if (__get_user(reg, u++))
 +			return -EFAULT;
 +		set_user_msr(target, reg);
 +		++pos;
 +		--count;
 +	}
 +
 +	if (kbuf) {
 +		for (; count > 0 && pos <= PT_MAX_PUT_REG; --count)
 +			regs[pos++] = *k++;
 +		for (; count > 0 && pos < PT_TRAP; --count, ++pos)
 +			++k;
 +	} else {
 +		for (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {
 +			if (__get_user(reg, u++))
 +				return -EFAULT;
 +			regs[pos++] = reg;
 +		}
 +		for (; count > 0 && pos < PT_TRAP; --count, ++pos)
 +			if (__get_user(reg, u++))
 +				return -EFAULT;
 +	}
 +
 +	if (count > 0 && pos == PT_TRAP) {
 +		if (kbuf)
 +			reg = *k++;
 +		else if (__get_user(reg, u++))
 +			return -EFAULT;
 +		set_user_trap(target, reg);
 +		++pos;
 +		--count;
 +	}
 +
 +	kbuf = k;
 +	ubuf = u;
 +	pos *= sizeof(reg);
 +	count *= sizeof(reg);
 +	return user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,
 +					 (PT_TRAP + 1) * sizeof(reg), -1);
 +}
 +
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +static int tm_cgpr32_get(struct task_struct *target,
 +		     const struct user_regset *regset,
 +		     unsigned int pos, unsigned int count,
 +		     void *kbuf, void __user *ubuf)
 +{
 +	return gpr32_get_common(target, regset, pos, count, kbuf, ubuf,
 +			&target->thread.ckpt_regs.gpr[0]);
 +}
 +
 +static int tm_cgpr32_set(struct task_struct *target,
 +		     const struct user_regset *regset,
 +		     unsigned int pos, unsigned int count,
 +		     const void *kbuf, const void __user *ubuf)
 +{
 +	return gpr32_set_common(target, regset, pos, count, kbuf, ubuf,
 +			&target->thread.ckpt_regs.gpr[0]);
 +}
 +#endif /* CONFIG_PPC_TRANSACTIONAL_MEM */
 +
 +static int gpr32_get(struct task_struct *target,
 +		     const struct user_regset *regset,
 +		     unsigned int pos, unsigned int count,
 +		     void *kbuf, void __user *ubuf)
 +{
 +	int i;
 +
 +	if (target->thread.regs == NULL)
 +		return -EIO;
 +
 +	if (!FULL_REGS(target->thread.regs)) {
 +		/*
 +		 * We have a partial register set.
 +		 * Fill 14-31 with bogus values.
 +		 */
 +		for (i = 14; i < 32; i++)
 +			target->thread.regs->gpr[i] = NV_REG_POISON;
 +	}
 +	return gpr32_get_common(target, regset, pos, count, kbuf, ubuf,
 +			&target->thread.regs->gpr[0]);
 +}
 +
 +static int gpr32_set(struct task_struct *target,
 +		     const struct user_regset *regset,
 +		     unsigned int pos, unsigned int count,
 +		     const void *kbuf, const void __user *ubuf)
 +{
 +	if (target->thread.regs == NULL)
 +		return -EIO;
 +
 +	CHECK_FULL_REGS(target->thread.regs);
 +	return gpr32_set_common(target, regset, pos, count, kbuf, ubuf,
 +			&target->thread.regs->gpr[0]);
 +}
 +
 +/*
 + * These are the regset flavors matching the CONFIG_PPC32 native set.
 + */
 +static const struct user_regset compat_regsets[] = {
 +	[REGSET_GPR] = {
 +		.core_note_type = NT_PRSTATUS, .n = ELF_NGREG,
 +		.size = sizeof(compat_long_t), .align = sizeof(compat_long_t),
 +		.get = gpr32_get, .set = gpr32_set
 +	},
 +	[REGSET_FPR] = {
 +		.core_note_type = NT_PRFPREG, .n = ELF_NFPREG,
 +		.size = sizeof(double), .align = sizeof(double),
 +		.get = fpr_get, .set = fpr_set
 +	},
 +#ifdef CONFIG_ALTIVEC
 +	[REGSET_VMX] = {
 +		.core_note_type = NT_PPC_VMX, .n = 34,
 +		.size = sizeof(vector128), .align = sizeof(vector128),
 +		.active = vr_active, .get = vr_get, .set = vr_set
 +	},
 +#endif
 +#ifdef CONFIG_SPE
 +	[REGSET_SPE] = {
 +		.core_note_type = NT_PPC_SPE, .n = 35,
 +		.size = sizeof(u32), .align = sizeof(u32),
 +		.active = evr_active, .get = evr_get, .set = evr_set
 +	},
 +#endif
 +#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 +	[REGSET_TM_CGPR] = {
 +		.core_note_type = NT_PPC_TM_CGPR, .n = ELF_NGREG,
 +		.size = sizeof(long), .align = sizeof(long),
 +		.active = tm_cgpr_active,
 +		.get = tm_cgpr32_get, .set = tm_cgpr32_set
 +	},
 +	[REGSET_TM_CFPR] = {
 +		.core_note_type = NT_PPC_TM_CFPR, .n = ELF_NFPREG,
 +		.size = sizeof(double), .align = sizeof(double),
 +		.active = tm_cfpr_active, .get = tm_cfpr_get, .set = tm_cfpr_set
 +	},
 +	[REGSET_TM_CVMX] = {
 +		.core_note_type = NT_PPC_TM_CVMX, .n = ELF_NVMX,
 +		.size = sizeof(vector128), .align = sizeof(vector128),
 +		.active = tm_cvmx_active, .get = tm_cvmx_get, .set = tm_cvmx_set
 +	},
 +	[REGSET_TM_CVSX] = {
 +		.core_note_type = NT_PPC_TM_CVSX, .n = ELF_NVSX,
 +		.size = sizeof(double), .align = sizeof(double),
 +		.active = tm_cvsx_active, .get = tm_cvsx_get, .set = tm_cvsx_set
 +	},
 +	[REGSET_TM_SPR] = {
 +		.core_note_type = NT_PPC_TM_SPR, .n = ELF_NTMSPRREG,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = tm_spr_active, .get = tm_spr_get, .set = tm_spr_set
 +	},
 +	[REGSET_TM_CTAR] = {
 +		.core_note_type = NT_PPC_TM_CTAR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = tm_tar_active, .get = tm_tar_get, .set = tm_tar_set
 +	},
 +	[REGSET_TM_CPPR] = {
 +		.core_note_type = NT_PPC_TM_CPPR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = tm_ppr_active, .get = tm_ppr_get, .set = tm_ppr_set
 +	},
 +	[REGSET_TM_CDSCR] = {
 +		.core_note_type = NT_PPC_TM_CDSCR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = tm_dscr_active, .get = tm_dscr_get, .set = tm_dscr_set
 +	},
 +#endif
 +#ifdef CONFIG_PPC64
 +	[REGSET_PPR] = {
 +		.core_note_type = NT_PPC_PPR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.get = ppr_get, .set = ppr_set
 +	},
 +	[REGSET_DSCR] = {
 +		.core_note_type = NT_PPC_DSCR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.get = dscr_get, .set = dscr_set
 +	},
 +#endif
 +#ifdef CONFIG_PPC_BOOK3S_64
 +	[REGSET_TAR] = {
 +		.core_note_type = NT_PPC_TAR, .n = 1,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.get = tar_get, .set = tar_set
 +	},
 +	[REGSET_EBB] = {
 +		.core_note_type = NT_PPC_EBB, .n = ELF_NEBB,
 +		.size = sizeof(u64), .align = sizeof(u64),
 +		.active = ebb_active, .get = ebb_get, .set = ebb_set
 +	},
 +#endif
 +};
 +
 +static const struct user_regset_view user_ppc_compat_view = {
 +	.name = "ppc", .e_machine = EM_PPC, .ei_osabi = ELF_OSABI,
 +	.regsets = compat_regsets, .n = ARRAY_SIZE(compat_regsets)
 +};
 +
 +const struct user_regset_view *task_user_regset_view(struct task_struct *task)
 +{
 +	if (IS_ENABLED(CONFIG_PPC64) && test_tsk_thread_flag(task, TIF_32BIT))
 +		return &user_ppc_compat_view;
 +	return &user_ppc_native_view;
 +}
 +
++=======
+ #include "ptrace-decl.h"
++>>>>>>> 6e0b79750ce2 (powerpc/ptrace: move register viewing functions out of ptrace.c):arch/powerpc/kernel/ptrace/ptrace.c
  
  void user_enable_single_step(struct task_struct *task)
  {
* Unmerged path arch/powerpc/kernel/ptrace-view.c
* Unmerged path arch/powerpc/kernel/ptrace/Makefile
* Unmerged path arch/powerpc/kernel/ptrace/ptrace-decl.h
* Unmerged path arch/powerpc/kernel/ptrace-view.c
* Unmerged path arch/powerpc/kernel/ptrace.c
* Unmerged path arch/powerpc/kernel/ptrace/Makefile
* Unmerged path arch/powerpc/kernel/ptrace/ptrace-decl.h
