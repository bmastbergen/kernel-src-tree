mptcp: add struct mptcp_pm_add_entry

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 0abd40f823cbd3beb2889a100c2210b13a63585b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0abd40f8.failed

Add a new struct mptcp_pm_add_entry to describe add_addr's entry.

	Acked-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0abd40f823cbd3beb2889a100c2210b13a63585b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/pm_netlink.c
index 6f3bf9fdbbbc,701972b55a45..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -179,11 -183,55 +184,58 @@@ static void check_work_pending(struct m
  		WRITE_ONCE(msk->pm.work_pending, false);
  }
  
++<<<<<<< HEAD
++=======
+ static bool lookup_anno_list_by_saddr(struct mptcp_sock *msk,
+ 				      struct mptcp_addr_info *addr)
+ {
+ 	struct mptcp_pm_add_entry *entry;
+ 
+ 	list_for_each_entry(entry, &msk->pm.anno_list, list) {
+ 		if (addresses_equal(&entry->addr, addr, false))
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static bool mptcp_pm_alloc_anno_list(struct mptcp_sock *msk,
+ 				     struct mptcp_pm_addr_entry *entry)
+ {
+ 	struct mptcp_pm_add_entry *add_entry = NULL;
+ 
+ 	if (lookup_anno_list_by_saddr(msk, &entry->addr))
+ 		return false;
+ 
+ 	add_entry = kmalloc(sizeof(*add_entry), GFP_ATOMIC);
+ 	if (!add_entry)
+ 		return false;
+ 
+ 	list_add(&add_entry->list, &msk->pm.anno_list);
+ 
+ 	return true;
+ }
+ 
+ void mptcp_pm_free_anno_list(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_pm_add_entry *entry, *tmp;
+ 
+ 	pr_debug("msk=%p", msk);
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 	list_for_each_entry_safe(entry, tmp, &msk->pm.anno_list, list) {
+ 		list_del(&entry->list);
+ 		kfree(entry);
+ 	}
+ 	spin_unlock_bh(&msk->pm.lock);
+ }
+ 
++>>>>>>> 0abd40f823cb (mptcp: add struct mptcp_pm_add_entry)
  static void mptcp_pm_create_subflow_or_signal_addr(struct mptcp_sock *msk)
  {
 -	struct mptcp_addr_info remote = { 0 };
  	struct sock *sk = (struct sock *)msk;
  	struct mptcp_pm_addr_entry *local;
 +	struct mptcp_addr_info remote;
  	struct pm_nl_pernet *pernet;
  
  	pernet = net_generic(sock_net((struct sock *)msk), pm_nl_pernet_id);
@@@ -530,6 -656,68 +582,71 @@@ __lookup_addr_by_id(struct pm_nl_perne
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static bool remove_anno_list_by_saddr(struct mptcp_sock *msk,
+ 				      struct mptcp_addr_info *addr)
+ {
+ 	struct mptcp_pm_add_entry *entry, *tmp;
+ 
+ 	list_for_each_entry_safe(entry, tmp, &msk->pm.anno_list, list) {
+ 		if (addresses_equal(&entry->addr, addr, false)) {
+ 			list_del(&entry->list);
+ 			kfree(entry);
+ 			return true;
+ 		}
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static bool mptcp_pm_remove_anno_addr(struct mptcp_sock *msk,
+ 				      struct mptcp_addr_info *addr,
+ 				      bool force)
+ {
+ 	bool ret;
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 	ret = remove_anno_list_by_saddr(msk, addr);
+ 	if (ret || force)
+ 		mptcp_pm_remove_addr(msk, addr->id);
+ 	spin_unlock_bh(&msk->pm.lock);
+ 	return ret;
+ }
+ 
+ static int mptcp_nl_remove_subflow_and_signal_addr(struct net *net,
+ 						   struct mptcp_addr_info *addr)
+ {
+ 	struct mptcp_sock *msk;
+ 	long s_slot = 0, s_num = 0;
+ 
+ 	pr_debug("remove_id=%d", addr->id);
+ 
+ 	while ((msk = mptcp_token_iter_next(net, &s_slot, &s_num)) != NULL) {
+ 		struct sock *sk = (struct sock *)msk;
+ 		bool remove_subflow;
+ 
+ 		if (list_empty(&msk->conn_list)) {
+ 			mptcp_pm_remove_anno_addr(msk, addr, false);
+ 			goto next;
+ 		}
+ 
+ 		lock_sock(sk);
+ 		remove_subflow = lookup_subflow_by_saddr(&msk->conn_list, addr);
+ 		mptcp_pm_remove_anno_addr(msk, addr, remove_subflow);
+ 		if (remove_subflow)
+ 			mptcp_pm_remove_subflow(msk, addr->id);
+ 		release_sock(sk);
+ 
+ next:
+ 		sock_put(sk);
+ 		cond_resched();
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 0abd40f823cb (mptcp: add struct mptcp_pm_add_entry)
  static int mptcp_nl_cmd_del_addr(struct sk_buff *skb, struct genl_info *info)
  {
  	struct nlattr *attr = info->attrs[MPTCP_PM_ATTR_ADDR];
* Unmerged path net/mptcp/pm_netlink.c
