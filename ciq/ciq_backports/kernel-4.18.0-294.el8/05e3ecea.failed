mptcp: avoid potential infinite loop in mptcp_recvmsg()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 05e3ecea4a6305597a060da0a123c80df8827bf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/05e3ecea.failed

If a packet is ready in receive queue, and application isssues
a recvmsg()/recvfrom()/recvmmsg() request asking for zero bytes,
we hang in mptcp_recvmsg().

Fixes: ea4ca586b16f ("mptcp: refine MPTCP-level ack scheduling")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Tested-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
Link: https://lore.kernel.org/r/20201202171657.1185108-1-eric.dumazet@gmail.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 05e3ecea4a6305597a060da0a123c80df8827bf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 75ee5f9fd199,57213ff60f78..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -1246,10 -1920,9 +1246,15 @@@ static int mptcp_recvmsg(struct sock *s
  
  	len = min_t(size_t, len, INT_MAX);
  	target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
 +	__mptcp_flush_join_list(msk);
  
++<<<<<<< HEAD
 +	while (len > (size_t)copied) {
 +		int bytes_read;
++=======
+ 	while (copied < len) {
+ 		int bytes_read, old_space;
++>>>>>>> 05e3ecea4a63 (mptcp: avoid potential infinite loop in mptcp_recvmsg())
  
  		bytes_read = __mptcp_recvmsg_mskq(msk, msg, len - copied);
  		if (unlikely(bytes_read < 0)) {
* Unmerged path net/mptcp/protocol.c
