s390/tlb: Convert to generic mmu_gather

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit 9de7d833e3708213bf99d75c37483e0f773f5e16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9de7d833.failed

No change in behavior intended.

	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: aneesh.kumar@linux.vnet.ibm.com
	Cc: heiko.carstens@de.ibm.com
	Cc: linux@armlinux.org.uk
	Cc: npiggin@gmail.com
	Cc: will.deacon@arm.com
Link: http://lkml.kernel.org/r/20180918125151.31744-3-schwidefsky@de.ibm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 9de7d833e3708213bf99d75c37483e0f773f5e16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/tlb.h
diff --cc arch/s390/include/asm/tlb.h
index ac1276bb25c6,aa406c05a350..000000000000
--- a/arch/s390/include/asm/tlb.h
+++ b/arch/s390/include/asm/tlb.h
@@@ -22,76 -22,23 +22,90 @@@
   * Pages used for the page tables is a different story. FIXME: more
   */
  
- #include <linux/mm.h>
- #include <linux/pagemap.h>
- #include <linux/swap.h>
- #include <asm/processor.h>
+ void __tlb_remove_table(void *_table);
+ static inline void tlb_flush(struct mmu_gather *tlb);
+ static inline bool __tlb_remove_page_size(struct mmu_gather *tlb,
+ 					  struct page *page, int page_size);
+ 
+ #define tlb_start_vma(tlb, vma)			do { } while (0)
+ #define tlb_end_vma(tlb, vma)			do { } while (0)
+ 
+ #define tlb_flush tlb_flush
+ #define pte_free_tlb pte_free_tlb
+ #define pmd_free_tlb pmd_free_tlb
+ #define p4d_free_tlb p4d_free_tlb
+ #define pud_free_tlb pud_free_tlb
+ 
  #include <asm/pgalloc.h>
  #include <asm/tlbflush.h>
++<<<<<<< HEAD
 +
 +/* RHEL-only, missing 9de7d833e370 */
 +#ifndef nmi_uaccess_okay
 +# define nmi_uaccess_okay() true
 +#endif
 +
 +struct mmu_gather {
 +	struct mm_struct *mm;
 +	struct mmu_table_batch *batch;
 +	unsigned int fullmm;
 +	unsigned long start, end;
 +};
 +
 +struct mmu_table_batch {
 +	struct rcu_head		rcu;
 +	unsigned int		nr;
 +	void			*tables[0];
 +};
 +
 +#define MAX_TABLE_BATCH		\
 +	((PAGE_SIZE - sizeof(struct mmu_table_batch)) / sizeof(void *))
 +
 +extern void tlb_table_flush(struct mmu_gather *tlb);
 +extern void tlb_remove_table(struct mmu_gather *tlb, void *table);
 +
 +static inline void
 +arch_tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,
 +			unsigned long start, unsigned long end)
 +{
 +	tlb->mm = mm;
 +	tlb->start = start;
 +	tlb->end = end;
 +	tlb->fullmm = !(start | (end+1));
 +	tlb->batch = NULL;
 +}
 +
 +static inline void tlb_flush_mmu_tlbonly(struct mmu_gather *tlb)
 +{
 +	__tlb_flush_mm_lazy(tlb->mm);
 +}
 +
 +static inline void tlb_flush_mmu_free(struct mmu_gather *tlb)
 +{
 +	tlb_table_flush(tlb);
 +}
 +
 +
 +static inline void tlb_flush_mmu(struct mmu_gather *tlb)
 +{
 +	tlb_flush_mmu_tlbonly(tlb);
 +	tlb_flush_mmu_free(tlb);
 +}
 +
 +static inline void
 +arch_tlb_finish_mmu(struct mmu_gather *tlb,
 +		unsigned long start, unsigned long end, bool force)
 +{
 +	if (force) {
 +		tlb->start = start;
 +		tlb->end = end;
 +	}
 +
 +	tlb_flush_mmu(tlb);
 +}
++=======
+ #include <asm-generic/tlb.h>
++>>>>>>> 9de7d833e370 (s390/tlb: Convert to generic mmu_gather)
  
  /*
   * Release the page cache reference for a pte removed by
@@@ -177,18 -133,5 +200,21 @@@ static inline void pud_free_tlb(struct 
  	tlb_remove_table(tlb, pud);
  }
  
++<<<<<<< HEAD
 +#define tlb_start_vma(tlb, vma)			do { } while (0)
 +#define tlb_end_vma(tlb, vma)			do { } while (0)
 +#define tlb_remove_tlb_entry(tlb, ptep, addr)	do { } while (0)
 +#define tlb_remove_pmd_tlb_entry(tlb, pmdp, addr)	do { } while (0)
 +#define tlb_migrate_finish(mm)			do { } while (0)
 +#define tlb_remove_huge_tlb_entry(h, tlb, ptep, address)	\
 +	tlb_remove_tlb_entry(tlb, ptep, address)
 +
 +#define tlb_remove_check_page_size_change tlb_remove_check_page_size_change
 +static inline void tlb_remove_check_page_size_change(struct mmu_gather *tlb,
 +						     unsigned int page_size)
 +{
 +}
++=======
++>>>>>>> 9de7d833e370 (s390/tlb: Convert to generic mmu_gather)
  
  #endif /* _S390_TLB_H */
diff --git a/arch/s390/Kconfig b/arch/s390/Kconfig
index 247a8ecc8c7b..ad8ef0814eef 100644
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@ -159,9 +159,11 @@ config S390
 	select HAVE_PERF_USER_STACK_DUMP
 	select HAVE_MEMBLOCK_NODE_MAP
 	select HAVE_MEMBLOCK_PHYS_MAP
+	select HAVE_MMU_GATHER_NO_GATHER
 	select HAVE_MOD_ARCH_SPECIFIC
 	select HAVE_OPROFILE
 	select HAVE_PERF_EVENTS
+	select HAVE_RCU_TABLE_FREE
 	select HAVE_REGS_AND_STACK_ACCESS_API
 	select HAVE_RSEQ
 	select HAVE_SYSCALL_TRACEPOINTS
* Unmerged path arch/s390/include/asm/tlb.h
diff --git a/arch/s390/mm/pgalloc.c b/arch/s390/mm/pgalloc.c
index 20f91b069c06..63f198e788da 100644
--- a/arch/s390/mm/pgalloc.c
+++ b/arch/s390/mm/pgalloc.c
@@ -301,7 +301,7 @@ void page_table_free_rcu(struct mmu_gather *tlb, unsigned long *table,
 	tlb_remove_table(tlb, table);
 }
 
-static void __tlb_remove_table(void *_table)
+void __tlb_remove_table(void *_table)
 {
 	unsigned int mask = (unsigned long) _table & 3;
 	void *table = (void *)((unsigned long) _table ^ mask);
@@ -327,67 +327,6 @@ static void __tlb_remove_table(void *_table)
 	}
 }
 
-static void tlb_remove_table_smp_sync(void *arg)
-{
-	/* Simply deliver the interrupt */
-}
-
-static void tlb_remove_table_one(void *table)
-{
-	/*
-	 * This isn't an RCU grace period and hence the page-tables cannot be
-	 * assumed to be actually RCU-freed.
-	 *
-	 * It is however sufficient for software page-table walkers that rely
-	 * on IRQ disabling. See the comment near struct mmu_table_batch.
-	 */
-	smp_call_function(tlb_remove_table_smp_sync, NULL, 1);
-	__tlb_remove_table(table);
-}
-
-static void tlb_remove_table_rcu(struct rcu_head *head)
-{
-	struct mmu_table_batch *batch;
-	int i;
-
-	batch = container_of(head, struct mmu_table_batch, rcu);
-
-	for (i = 0; i < batch->nr; i++)
-		__tlb_remove_table(batch->tables[i]);
-
-	free_page((unsigned long)batch);
-}
-
-void tlb_table_flush(struct mmu_gather *tlb)
-{
-	struct mmu_table_batch **batch = &tlb->batch;
-
-	if (*batch) {
-		call_rcu(&(*batch)->rcu, tlb_remove_table_rcu);
-		*batch = NULL;
-	}
-}
-
-void tlb_remove_table(struct mmu_gather *tlb, void *table)
-{
-	struct mmu_table_batch **batch = &tlb->batch;
-
-	tlb->mm->context.flush_mm = 1;
-	if (*batch == NULL) {
-		*batch = (struct mmu_table_batch *)
-			__get_free_page(GFP_NOWAIT | __GFP_NOWARN);
-		if (*batch == NULL) {
-			__tlb_flush_mm_lazy(tlb->mm);
-			tlb_remove_table_one(table);
-			return;
-		}
-		(*batch)->nr = 0;
-	}
-	(*batch)->tables[(*batch)->nr++] = table;
-	if ((*batch)->nr == MAX_TABLE_BATCH)
-		tlb_flush_mmu(tlb);
-}
-
 /*
  * Base infrastructure required to generate basic asces, region, segment,
  * and page tables that do not make use of enhanced features like EDAT1.
