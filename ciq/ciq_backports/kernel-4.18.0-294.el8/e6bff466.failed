software node: replace is_array with is_inline

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit e6bff4665c595b5a4aff173848851ed49ac3bfad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e6bff466.failed

We do not need a special flag to know if we are dealing with an
array, as we can get that data from ratio between element length and
the data size, but we do need a flag to know whether or not the data
is stored directly inside property_entry.

	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
[ rjw: Subject & changelog, struct property_entry kerneldoc ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit e6bff4665c595b5a4aff173848851ed49ac3bfad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/property.h
diff --cc include/linux/property.h
index b1dbe0ba27b1,6c1ca870a9a9..000000000000
--- a/include/linux/property.h
+++ b/include/linux/property.h
@@@ -258,11 -255,13 +258,15 @@@ struct property_entry 
   * and structs.
   */
  
 -#define __PROPERTY_ENTRY_ELEMENT_SIZE(_elem_)				\
 -	sizeof(((struct property_entry *)NULL)->value._elem_)
 -
 -#define __PROPERTY_ENTRY_ARRAY_LEN(_name_, _elem_, _Type_, _val_, _len_)\
 +#define __PROPERTY_ENTRY_ARRAY_LEN(_name_, _type_, _Type_, _val_, _len_)\
  (struct property_entry) {						\
  	.name = _name_,							\
++<<<<<<< HEAD
 +	.length = (_len_) * sizeof(_type_),				\
 +	.is_array = true,						\
++=======
+ 	.length = (_len_) * __PROPERTY_ENTRY_ELEMENT_SIZE(_elem_),	\
++>>>>>>> e6bff4665c59 (software node: replace is_array with is_inline)
  	.type = DEV_PROP_##_Type_,					\
  	{ .pointer = _val_ },						\
  }
@@@ -296,30 -288,25 +300,40 @@@
  #define PROPERTY_ENTRY_STRING_ARRAY(_name_, _val_)			\
  	PROPERTY_ENTRY_STRING_ARRAY_LEN(_name_, _val_, ARRAY_SIZE(_val_))
  
++<<<<<<< HEAD
 +#define __PROPERTY_ENTRY_INTEGER(_name_, _type_, _Type_, _val_)	\
 +(struct property_entry) {					\
 +	.name = _name_,						\
 +	.length = sizeof(_type_),				\
 +	.type = DEV_PROP_##_Type_,				\
 +	{ .value = { ._type_##_data = _val_ } },		\
++=======
+ #define __PROPERTY_ENTRY_ELEMENT(_name_, _elem_, _Type_, _val_)		\
+ (struct property_entry) {						\
+ 	.name = _name_,							\
+ 	.length = __PROPERTY_ENTRY_ELEMENT_SIZE(_elem_),		\
+ 	.is_inline = true,						\
+ 	.type = DEV_PROP_##_Type_,					\
+ 	{ .value = { ._elem_ = _val_ } },				\
++>>>>>>> e6bff4665c59 (software node: replace is_array with is_inline)
  }
  
 -#define PROPERTY_ENTRY_U8(_name_, _val_)				\
 -	__PROPERTY_ENTRY_ELEMENT(_name_, u8_data, U8, _val_)
 -#define PROPERTY_ENTRY_U16(_name_, _val_)				\
 -	__PROPERTY_ENTRY_ELEMENT(_name_, u16_data, U16, _val_)
 -#define PROPERTY_ENTRY_U32(_name_, _val_)				\
 -	__PROPERTY_ENTRY_ELEMENT(_name_, u32_data, U32, _val_)
 -#define PROPERTY_ENTRY_U64(_name_, _val_)				\
 -	__PROPERTY_ENTRY_ELEMENT(_name_, u64_data, U64, _val_)
 -#define PROPERTY_ENTRY_STRING(_name_, _val_)				\
 -	__PROPERTY_ENTRY_ELEMENT(_name_, str, STRING, _val_)
 +#define PROPERTY_ENTRY_U8(_name_, _val_)		\
 +	__PROPERTY_ENTRY_INTEGER(_name_, u8, U8, _val_)
 +#define PROPERTY_ENTRY_U16(_name_, _val_)		\
 +	__PROPERTY_ENTRY_INTEGER(_name_, u16, U16, _val_)
 +#define PROPERTY_ENTRY_U32(_name_, _val_)		\
 +	__PROPERTY_ENTRY_INTEGER(_name_, u32, U32, _val_)
 +#define PROPERTY_ENTRY_U64(_name_, _val_)		\
 +	__PROPERTY_ENTRY_INTEGER(_name_, u64, U64, _val_)
 +
 +#define PROPERTY_ENTRY_STRING(_name_, _val_)		\
 +(struct property_entry) {				\
 +	.name = _name_,					\
 +	.length = sizeof(_val_),			\
 +	.type = DEV_PROP_STRING,			\
 +	{ .value = { .str = _val_ } },			\
 +}
  
  #define PROPERTY_ENTRY_BOOL(_name_)		\
  (struct property_entry) {			\
diff --git a/drivers/base/swnode.c b/drivers/base/swnode.c
index d8d0dc0ca5ac..18a30fb3cc58 100644
--- a/drivers/base/swnode.c
+++ b/drivers/base/swnode.c
@@ -108,10 +108,7 @@ static const void *property_get_pointer(const struct property_entry *prop)
 	if (!prop->length)
 		return NULL;
 
-	if (prop->is_array)
-		return prop->pointer;
-
-	return &prop->value;
+	return prop->is_inline ? &prop->value : prop->pointer;
 }
 
 static const void *property_entry_find(const struct property_entry *props,
@@ -205,7 +202,7 @@ static void property_entry_free_data(const struct property_entry *p)
 	const char * const *src_str;
 	size_t i, nval;
 
-	if (p->is_array) {
+	if (!p->is_inline) {
 		if (p->type == DEV_PROP_STRING && p->pointer) {
 			src_str = p->pointer;
 			nval = p->length / sizeof(const char *);
@@ -250,7 +247,7 @@ static int property_entry_copy_data(struct property_entry *dst,
 	const void *pointer = property_get_pointer(src);
 	const void *new;
 
-	if (src->is_array) {
+	if (!src->is_inline) {
 		if (!src->length)
 			return -ENODATA;
 
@@ -264,15 +261,16 @@ static int property_entry_copy_data(struct property_entry *dst,
 				return -ENOMEM;
 		}
 
-		dst->is_array = true;
 		dst->pointer = new;
 	} else if (src->type == DEV_PROP_STRING) {
 		new = kstrdup(src->value.str, GFP_KERNEL);
 		if (!new && src->value.str)
 			return -ENOMEM;
 
+		dst->is_inline = true;
 		dst->value.str = new;
 	} else {
+		dst->is_inline = true;
 		dst->value = src->value;
 	}
 
* Unmerged path include/linux/property.h
