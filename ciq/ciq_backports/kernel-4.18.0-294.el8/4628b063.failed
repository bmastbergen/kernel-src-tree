mm/gup: rename nr as nr_pinned in get_user_pages_fast()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Pingfan Liu <kernelfans@gmail.com>
commit 4628b063d2180c2bf142a3f6b762778c0a2d9ab0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4628b063.failed

To better reflect the held state of pages and make code self-explaining,
rename nr as nr_pinned.

	Signed-off-by: Pingfan Liu <kernelfans@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: John Hubbard <jhubbard@nvidia.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Mike Rapoport <rppt@linux.ibm.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: "Aneesh Kumar K.V" <aneesh.kumar@linux.ibm.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Shuah Khan <shuah@kernel.org>
	Cc: Jason Gunthorpe <jgg@ziepe.ca>
Link: http://lkml.kernel.org/r/1584876733-17405-2-git-send-email-kernelfans@gmail.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4628b063d2180c2bf142a3f6b762778c0a2d9ab0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/gup.c
diff --cc mm/gup.c
index 64143166cb9e,b128350772de..000000000000
--- a/mm/gup.c
+++ b/mm/gup.c
@@@ -2150,7 -2637,15 +2150,19 @@@ int __get_user_pages_fast(unsigned lon
  {
  	unsigned long len, end;
  	unsigned long flags;
++<<<<<<< HEAD
 +	int nr = 0;
++=======
+ 	int nr_pinned = 0;
+ 	/*
+ 	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
+ 	 * because gup fast is always a "pin with a +1 page refcount" request.
+ 	 */
+ 	unsigned int gup_flags = FOLL_GET;
+ 
+ 	if (write)
+ 		gup_flags |= FOLL_WRITE;
++>>>>>>> 4628b063d218 (mm/gup: rename nr as nr_pinned in get_user_pages_fast())
  
  	start = untagged_addr(start) & PAGE_MASK;
  	len = (unsigned long) nr_pages << PAGE_SHIFT;
@@@ -2173,14 -2668,16 +2185,18 @@@
  	 * block IPIs that come from THPs splitting.
  	 */
  
 -	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
 -	    gup_fast_permitted(start, end)) {
 +	if (gup_fast_permitted(start, end)) {
  		local_irq_save(flags);
++<<<<<<< HEAD
 +		gup_pgd_range(start, end, write ? FOLL_WRITE : 0, pages, &nr);
++=======
+ 		gup_pgd_range(start, end, gup_flags, pages, &nr_pinned);
++>>>>>>> 4628b063d218 (mm/gup: rename nr as nr_pinned in get_user_pages_fast())
  		local_irq_restore(flags);
  	}
  
- 	return nr;
+ 	return nr_pinned;
  }
 -EXPORT_SYMBOL_GPL(__get_user_pages_fast);
  
  static int __gup_longterm_unlocked(unsigned long start, int nr_pages,
  				   unsigned int gup_flags, struct page **pages)
@@@ -2205,30 -2702,15 +2221,30 @@@
  	return ret;
  }
  
 -static int internal_get_user_pages_fast(unsigned long start, int nr_pages,
 -					unsigned int gup_flags,
 -					struct page **pages)
 +/**
 + * get_user_pages_fast() - pin user pages in memory
 + * @start:	starting user address
 + * @nr_pages:	number of pages from start to pin
 + * @gup_flags:	flags modifying pin behaviour
 + * @pages:	array that receives pointers to the pages pinned.
 + *		Should be at least nr_pages long.
 + *
 + * Attempt to pin user pages in memory without taking mm->mmap_sem.
 + * If not successful, it will fall back to taking the lock and
 + * calling get_user_pages().
 + *
 + * Returns number of pages pinned. This may be fewer than the number
 + * requested. If nr_pages is 0 or negative, returns 0. If no pages
 + * were pinned, returns -errno.
 + */
 +int get_user_pages_fast(unsigned long start, int nr_pages,
 +			unsigned int gup_flags, struct page **pages)
  {
  	unsigned long addr, len, end;
- 	int nr = 0, ret = 0;
+ 	int nr_pinned = 0, ret = 0;
  
  	if (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |
 -				       FOLL_FORCE | FOLL_PIN | FOLL_GET)))
 +				       FOLL_FORCE)))
  		return -EINVAL;
  
  	start = untagged_addr(start) & PAGE_MASK;
@@@ -2241,19 -2723,20 +2257,19 @@@
  	if (unlikely(!access_ok((void __user *)start, len)))
  		return -EFAULT;
  
 -	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
 -	    gup_fast_permitted(start, end)) {
 +	if (gup_fast_permitted(start, end)) {
  		local_irq_disable();
- 		gup_pgd_range(addr, end, gup_flags, pages, &nr);
+ 		gup_pgd_range(addr, end, gup_flags, pages, &nr_pinned);
  		local_irq_enable();
- 		ret = nr;
+ 		ret = nr_pinned;
  	}
  
- 	if (nr < nr_pages) {
+ 	if (nr_pinned < nr_pages) {
  		/* Try to get the remaining pages with get_user_pages */
- 		start += nr << PAGE_SHIFT;
- 		pages += nr;
+ 		start += nr_pinned << PAGE_SHIFT;
+ 		pages += nr_pinned;
  
- 		ret = __gup_longterm_unlocked(start, nr_pages - nr,
+ 		ret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,
  					      gup_flags, pages);
  
  		/* Have to be a bit careful with return values */
* Unmerged path mm/gup.c
