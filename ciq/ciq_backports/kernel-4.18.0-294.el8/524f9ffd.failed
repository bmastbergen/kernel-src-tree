block: reduce part_stat_lock() scope

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 524f9ffd6a4d3622aa48ca286ff85a30ed1cdbcf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/524f9ffd.failed

We only need the stats lock (aka preempt_disable()) for updating the
states, not for looking up or dropping the hd_struct reference.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 524f9ffd6a4d3622aa48ca286ff85a30ed1cdbcf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
#	block/blk-merge.c
diff --cc block/blk-core.c
index 9aabbc020a34,a01fb2b508f0..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -1323,11 -1437,9 +1323,14 @@@ void blk_account_io_done(struct reques
  		update_io_ticks(part, jiffies, true);
  		part_stat_inc(part, ios[sgrp]);
  		part_stat_add(part, nsecs[sgrp], now - req->start_time_ns);
++<<<<<<< HEAD
 +		part_stat_add(part, time_in_queue, nsecs_to_jiffies64(now - req->start_time_ns));
 +		part_dec_in_flight(req->q, part, rq_data_dir(req));
++=======
+ 		part_stat_unlock();
++>>>>>>> 524f9ffd6a4d (block: reduce part_stat_lock() scope)
  
  		hd_struct_put(part);
- 		part_stat_unlock();
  	}
  }
  
@@@ -1339,21 -1448,46 +1342,28 @@@ void blk_account_io_start(struct reques
  	if (!blk_do_io_stat(rq))
  		return;
  
 -	rq->part = disk_map_sector_rcu(rq->rq_disk, blk_rq_pos(rq));
 -
++<<<<<<< HEAD
  	part_stat_lock();
 -	update_io_ticks(rq->part, jiffies, false);
 -	part_stat_unlock();
 -}
 -
 -unsigned long disk_start_io_acct(struct gendisk *disk, unsigned int sectors,
 -		unsigned int op)
 -{
 -	struct hd_struct *part = &disk->part0;
 -	const int sgrp = op_stat_group(op);
 -	unsigned long now = READ_ONCE(jiffies);
  
 -	part_stat_lock();
 -	update_io_ticks(part, now, false);
 -	part_stat_inc(part, ios[sgrp]);
 -	part_stat_add(part, sectors[sgrp], sectors);
 -	part_stat_local_inc(part, in_flight[op_is_write(op)]);
 -	part_stat_unlock();
 +	if (!new_io) {
 +		part = rq->part;
 +		part_stat_inc(part, merges[rw]);
 +	} else {
 +		part = disk_map_sector_rcu(rq->rq_disk, blk_rq_pos(rq));
 +		part_inc_in_flight(rq->q, part, rw);
 +		rq->part = part;
 +	}
  
 -	return now;
 -}
 -EXPORT_SYMBOL(disk_start_io_acct);
 +	update_io_ticks(part, jiffies, false);
  
 -void disk_end_io_acct(struct gendisk *disk, unsigned int op,
 -		unsigned long start_time)
 -{
 -	struct hd_struct *part = &disk->part0;
 -	const int sgrp = op_stat_group(op);
 -	unsigned long now = READ_ONCE(jiffies);
 -	unsigned long duration = now - start_time;
++=======
++	rq->part = disk_map_sector_rcu(rq->rq_disk, blk_rq_pos(rq));
+ 
+ 	part_stat_lock();
 -	update_io_ticks(part, now, true);
 -	part_stat_add(part, nsecs[sgrp], jiffies_to_nsecs(duration));
 -	part_stat_local_dec(part, in_flight[op_is_write(op)]);
++	update_io_ticks(rq->part, jiffies, false);
++>>>>>>> 524f9ffd6a4d (block: reduce part_stat_lock() scope)
  	part_stat_unlock();
  }
 -EXPORT_SYMBOL(disk_end_io_acct);
  
  /*
   * Steal bios from a request and add them to a bio list.
diff --cc block/blk-merge.c
index 96b6e62209ca,f0b0bae075a0..000000000000
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@@ -662,20 -669,17 +662,26 @@@ void blk_rq_set_mixed_merge(struct requ
  	rq->rq_flags |= RQF_MIXED_MERGE;
  }
  
 -static void blk_account_io_merge_request(struct request *req)
 +static void blk_account_io_merge(struct request *req)
  {
  	if (blk_do_io_stat(req)) {
 +		struct hd_struct *part;
 +
  		part_stat_lock();
++<<<<<<< HEAD
 +		part = req->part;
 +
 +		part_dec_in_flight(req->q, part, rq_data_dir(req));
 +
 +		hd_struct_put(part);
++=======
+ 		part_stat_inc(req->part, merges[op_stat_group(req_op(req))]);
++>>>>>>> 524f9ffd6a4d (block: reduce part_stat_lock() scope)
  		part_stat_unlock();
+ 
+ 		hd_struct_put(req->part);
  	}
  }
 -
  /*
   * Two cases of handling DISCARD merge:
   * If max_discard_segments > 1, the driver takes every bio
* Unmerged path block/blk-core.c
* Unmerged path block/blk-merge.c
