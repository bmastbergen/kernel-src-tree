iommu/arm-smmu: Add implementation infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Robin Murphy <robin.murphy@arm.com>
commit fc058d37b3450db3e146d475f85e6afd51888997
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fc058d37.failed

Add some nascent infrastructure for handling implementation-specific
details outside the flow of the architectural code. This will allow us
to keep mutually-incompatible vendor-specific hooks in their own files
where the respective interested parties can maintain them with minimal
chance of conflicts. As somewhat of a template, we'll start with a
general place to collect the relatively trivial existing quirks.

	Signed-off-by: Robin Murphy <robin.murphy@arm.com>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit fc058d37b3450db3e146d475f85e6afd51888997)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/arm-smmu.c
#	drivers/iommu/arm-smmu.h
diff --cc drivers/iommu/arm-smmu.c
index f46feb909beb,1e8153182830..000000000000
--- a/drivers/iommu/arm-smmu.c
+++ b/drivers/iommu/arm-smmu.c
@@@ -31,7 -19,7 +31,11 @@@
  
  #include <linux/acpi.h>
  #include <linux/acpi_iort.h>
++<<<<<<< HEAD
 +#include <linux/atomic.h>
++=======
+ #include <linux/bitfield.h>
++>>>>>>> fc058d37b345 (iommu/arm-smmu: Add implementation infrastructure)
  #include <linux/delay.h>
  #include <linux/dma-iommu.h>
  #include <linux/dma-mapping.h>
@@@ -52,9 -39,9 +55,8 @@@
  #include <linux/platform_device.h>
  #include <linux/pm_runtime.h>
  #include <linux/slab.h>
- #include <linux/spinlock.h>
  
  #include <linux/amba/bus.h>
 -#include <linux/fsl/mc.h>
  
  #include "arm-smmu.h"
  
@@@ -76,36 -63,6 +78,39 @@@
  #define TLB_LOOP_TIMEOUT		1000000	/* 1s! */
  #define TLB_SPIN_COUNT			10
  
++<<<<<<< HEAD
 +/* Maximum number of context banks per SMMU */
 +#define ARM_SMMU_MAX_CBS		128
 +
 +/* SMMU global address space */
 +#define ARM_SMMU_GR0(smmu)		((smmu)->base)
 +
 +/*
 + * SMMU global address space with conditional offset to access secure
 + * aliases of non-secure registers (e.g. nsCR0: 0x400, nsGFSR: 0x448,
 + * nsGFSYNR0: 0x450)
 + */
 +#define ARM_SMMU_GR0_NS(smmu)						\
 +	((smmu)->base +							\
 +		((smmu->options & ARM_SMMU_OPT_SECURE_CFG_ACCESS)	\
 +			? 0x400 : 0))
 +
 +/*
 + * Some 64-bit registers only make sense to write atomically, but in such
 + * cases all the data relevant to AArch32 formats lies within the lower word,
 + * therefore this actually makes more sense than it might first appear.
 + */
 +#ifdef CONFIG_64BIT
 +#define smmu_write_atomic_lq		writeq_relaxed
 +#else
 +#define smmu_write_atomic_lq		writel_relaxed
 +#endif
 +
 +/* Translation context bank */
 +#define ARM_SMMU_CB(smmu, n)	((smmu)->cb_base + ((n) << (smmu)->pgshift))
 +
++=======
++>>>>>>> fc058d37b345 (iommu/arm-smmu: Add implementation infrastructure)
  #define MSI_IOVA_BASE			0x8000000
  #define MSI_IOVA_LENGTH			0x100000
  
@@@ -165,70 -110,13 +157,73 @@@ struct arm_smmu_master_cfg 
  	s16				smendx[];
  };
  #define INVALID_SMENDX			-1
 -#define __fwspec_cfg(fw) ((struct arm_smmu_master_cfg *)fw->iommu_priv)
 -#define fwspec_smmu(fw)  (__fwspec_cfg(fw)->smmu)
 -#define fwspec_smendx(fw, i) \
 -	(i >= fw->num_ids ? INVALID_SMENDX : __fwspec_cfg(fw)->smendx[i])
 -#define for_each_cfg_sme(fw, i, idx) \
 -	for (i = 0; idx = fwspec_smendx(fw, i), i < fw->num_ids; ++i)
 +#define cfg_smendx(cfg, fw, i) \
 +	(i >= fw->num_ids ? INVALID_SMENDX : cfg->smendx[i])
 +#define for_each_cfg_sme(cfg, fw, i, idx) \
 +	for (i = 0; idx = cfg_smendx(cfg, fw, i), i < fw->num_ids; ++i)
 +
++<<<<<<< HEAD
 +struct arm_smmu_device {
 +	struct device			*dev;
 +
 +	void __iomem			*base;
 +	void __iomem			*cb_base;
 +	unsigned long			pgshift;
 +
 +#define ARM_SMMU_FEAT_COHERENT_WALK	(1 << 0)
 +#define ARM_SMMU_FEAT_STREAM_MATCH	(1 << 1)
 +#define ARM_SMMU_FEAT_TRANS_S1		(1 << 2)
 +#define ARM_SMMU_FEAT_TRANS_S2		(1 << 3)
 +#define ARM_SMMU_FEAT_TRANS_NESTED	(1 << 4)
 +#define ARM_SMMU_FEAT_TRANS_OPS		(1 << 5)
 +#define ARM_SMMU_FEAT_VMID16		(1 << 6)
 +#define ARM_SMMU_FEAT_FMT_AARCH64_4K	(1 << 7)
 +#define ARM_SMMU_FEAT_FMT_AARCH64_16K	(1 << 8)
 +#define ARM_SMMU_FEAT_FMT_AARCH64_64K	(1 << 9)
 +#define ARM_SMMU_FEAT_FMT_AARCH32_L	(1 << 10)
 +#define ARM_SMMU_FEAT_FMT_AARCH32_S	(1 << 11)
 +#define ARM_SMMU_FEAT_EXIDS		(1 << 12)
 +	u32				features;
 +
 +#define ARM_SMMU_OPT_SECURE_CFG_ACCESS (1 << 0)
 +	u32				options;
 +	enum arm_smmu_arch_version	version;
 +	enum arm_smmu_implementation	model;
 +
 +	u32				num_context_banks;
 +	u32				num_s2_context_banks;
 +	DECLARE_BITMAP(context_map, ARM_SMMU_MAX_CBS);
 +	struct arm_smmu_cb		*cbs;
 +	atomic_t			irptndx;
 +
 +	u32				num_mapping_groups;
 +	u16				streamid_mask;
 +	u16				smr_mask_mask;
 +	struct arm_smmu_smr		*smrs;
 +	struct arm_smmu_s2cr		*s2crs;
 +	struct mutex			stream_map_mutex;
 +
 +	unsigned long			va_size;
 +	unsigned long			ipa_size;
 +	unsigned long			pa_size;
 +	unsigned long			pgsize_bitmap;
 +
 +	u32				num_global_irqs;
 +	u32				num_context_irqs;
 +	unsigned int			*irqs;
 +	struct clk_bulk_data		*clks;
 +	int				num_clks;
 +
 +	u32				cavium_id_base; /* Specific to Cavium */
 +
 +	spinlock_t			global_sync_lock;
 +
 +	/* IOMMU core code handle */
 +	struct iommu_device		iommu;
 +};
  
++=======
++>>>>>>> fc058d37b345 (iommu/arm-smmu: Add implementation infrastructure)
  enum arm_smmu_context_fmt {
  	ARM_SMMU_CTX_FMT_NONE,
  	ARM_SMMU_CTX_FMT_AARCH64,
diff --cc drivers/iommu/arm-smmu.h
index 671b3a337fea,6fea0b0b7e51..000000000000
--- a/drivers/iommu/arm-smmu.h
+++ b/drivers/iommu/arm-smmu.h
@@@ -22,21 -10,29 +22,33 @@@
  #ifndef _ARM_SMMU_H
  #define _ARM_SMMU_H
  
++<<<<<<< HEAD
++=======
+ #include <linux/atomic.h>
+ #include <linux/bits.h>
+ #include <linux/clk.h>
+ #include <linux/device.h>
+ #include <linux/iommu.h>
+ #include <linux/mutex.h>
+ #include <linux/spinlock.h>
+ #include <linux/types.h>
+ 
++>>>>>>> fc058d37b345 (iommu/arm-smmu: Add implementation infrastructure)
  /* Configuration registers */
  #define ARM_SMMU_GR0_sCR0		0x0
 -#define sCR0_VMID16EN			BIT(31)
 -#define sCR0_BSU			GENMASK(15, 14)
 -#define sCR0_FB				BIT(13)
 -#define sCR0_PTM			BIT(12)
 -#define sCR0_VMIDPNE			BIT(11)
 -#define sCR0_USFCFG			BIT(10)
 -#define sCR0_GCFGFIE			BIT(5)
 -#define sCR0_GCFGFRE			BIT(4)
 -#define sCR0_EXIDENABLE			BIT(3)
 -#define sCR0_GFIE			BIT(2)
 -#define sCR0_GFRE			BIT(1)
 -#define sCR0_CLIENTPD			BIT(0)
 +#define sCR0_CLIENTPD			(1 << 0)
 +#define sCR0_GFRE			(1 << 1)
 +#define sCR0_GFIE			(1 << 2)
 +#define sCR0_EXIDENABLE			(1 << 3)
 +#define sCR0_GCFGFRE			(1 << 4)
 +#define sCR0_GCFGFIE			(1 << 5)
 +#define sCR0_USFCFG			(1 << 10)
 +#define sCR0_VMIDPNE			(1 << 11)
 +#define sCR0_PTM			(1 << 12)
 +#define sCR0_FB				(1 << 13)
 +#define sCR0_VMID16EN			(1 << 31)
 +#define sCR0_BSU_SHIFT			14
 +#define sCR0_BSU_MASK			0x3
  
  /* Auxiliary Configuration register */
  #define ARM_SMMU_GR0_sACR		0x10
diff --git a/MAINTAINERS b/MAINTAINERS
index 82ab4834f67b..0362c79592d6 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1145,8 +1145,7 @@ M:	Will Deacon <will.deacon@arm.com>
 R:	Robin Murphy <robin.murphy@arm.com>
 L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
 S:	Maintained
-F:	drivers/iommu/arm-smmu.c
-F:	drivers/iommu/arm-smmu-v3.c
+F:	drivers/iommu/arm-smmu*
 F:	drivers/iommu/io-pgtable-arm.c
 F:	drivers/iommu/io-pgtable-arm-v7s.c
 
diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile
index a7f2eb8d90a7..235ad6ebc325 100644
--- a/drivers/iommu/Makefile
+++ b/drivers/iommu/Makefile
@@ -13,7 +13,7 @@ obj-$(CONFIG_MSM_IOMMU) += msm_iommu.o
 obj-$(CONFIG_AMD_IOMMU) += amd_iommu.o amd_iommu_init.o amd_iommu_quirks.o
 obj-$(CONFIG_AMD_IOMMU_DEBUGFS) += amd_iommu_debugfs.o
 obj-$(CONFIG_AMD_IOMMU_V2) += amd_iommu_v2.o
-obj-$(CONFIG_ARM_SMMU) += arm-smmu.o
+obj-$(CONFIG_ARM_SMMU) += arm-smmu.o arm-smmu-impl.o
 obj-$(CONFIG_ARM_SMMU_V3) += arm-smmu-v3.o
 obj-$(CONFIG_DMAR_TABLE) += dmar.o
 obj-$(CONFIG_INTEL_IOMMU) += intel-iommu.o intel-pasid.o
diff --git a/drivers/iommu/arm-smmu-impl.c b/drivers/iommu/arm-smmu-impl.c
new file mode 100644
index 000000000000..efeb6d78da17
--- /dev/null
+++ b/drivers/iommu/arm-smmu-impl.c
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Miscellaneous Arm SMMU implementation and integration quirks
+// Copyright (C) 2019 Arm Limited
+
+#define pr_fmt(fmt) "arm-smmu: " fmt
+
+#include "arm-smmu.h"
+
+
+struct arm_smmu_device *arm_smmu_impl_init(struct arm_smmu_device *smmu)
+{
+	return smmu;
+}
* Unmerged path drivers/iommu/arm-smmu.c
* Unmerged path drivers/iommu/arm-smmu.h
