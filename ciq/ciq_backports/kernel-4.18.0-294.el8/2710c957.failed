fs_parse: get rid of ->enums

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 2710c957a8ef4fb00f21acb306e3bd6bcf80c81f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2710c957.failed

Don't do a single array; attach them to fsparam_enum() entry
instead.  And don't bother trying to embed the names into those -
it actually loses memory, with no real speedup worth mentioning.

Simplifies validation as well.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 2710c957a8ef4fb00f21acb306e3bd6bcf80c81f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/afs/super.c
#	fs/ceph/super.c
#	fs/fs_parser.c
#	fs/jffs2/super.c
#	fs/nfs/fs_context.c
#	include/linux/fs_parser.h
#	mm/shmem.c
#	net/ceph/ceph_common.c
diff --cc fs/afs/super.c
index 44f8cce1c926,42bf63b82007..000000000000
--- a/fs/afs/super.c
+++ b/fs/afs/super.c
@@@ -63,22 -66,32 +63,44 @@@ static const struct super_operations af
  static struct kmem_cache *afs_inode_cachep;
  static atomic_t afs_count_active_inodes;
  
 -enum afs_param {
 -	Opt_autocell,
 -	Opt_dyn,
 -	Opt_flock,
 -	Opt_source,
 +enum {
 +	afs_no_opt,
 +	afs_opt_cell,
 +	afs_opt_dyn,
 +	afs_opt_rwpath,
 +	afs_opt_vol,
 +	afs_opt_autocell,
  };
  
++<<<<<<< HEAD
 +static const match_table_t afs_options_list = {
 +	{ afs_opt_cell,		"cell=%s"	},
 +	{ afs_opt_dyn,		"dyn"		},
 +	{ afs_opt_rwpath,	"rwpath"	},
 +	{ afs_opt_vol,		"vol=%s"	},
 +	{ afs_opt_autocell,	"autocell"	},
 +	{ afs_no_opt,		NULL		},
++=======
+ static const struct fs_parameter_enum afs_param_flock[] = {
+ 	{"local",	afs_flock_mode_local },
+ 	{"openafs",	afs_flock_mode_openafs },
+ 	{"strict",	afs_flock_mode_strict },
+ 	{"write",	afs_flock_mode_write },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec afs_param_specs[] = {
+ 	fsparam_flag  ("autocell",	Opt_autocell),
+ 	fsparam_flag  ("dyn",		Opt_dyn),
+ 	fsparam_enum  ("flock",		Opt_flock, afs_param_flock),
+ 	fsparam_string("source",	Opt_source),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description afs_fs_parameters = {
+ 	.name		= "kAFS",
+ 	.specs		= afs_param_specs,
++>>>>>>> 2710c957a8ef (fs_parse: get rid of ->enums)
  };
  
  /*
diff --cc fs/ceph/super.c
index f940cf50b7f6,0f7c8913bb20..000000000000
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@@ -140,107 -142,141 +140,166 @@@ enum 
  	/* int args above */
  	Opt_snapdirname,
  	Opt_mds_namespace,
 +	Opt_fscache_uniq,
  	Opt_recover_session,
 -	Opt_source,
 +	Opt_last_string,
  	/* string args above */
  	Opt_dirstat,
 +	Opt_nodirstat,
  	Opt_rbytes,
 +	Opt_norbytes,
  	Opt_asyncreaddir,
 +	Opt_noasyncreaddir,
  	Opt_dcache,
 +	Opt_nodcache,
  	Opt_ino32,
 +	Opt_noino32,
  	Opt_fscache,
 +	Opt_nofscache,
  	Opt_poolperm,
 +	Opt_nopoolperm,
  	Opt_require_active_mds,
 +	Opt_norequire_active_mds,
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
  	Opt_acl,
 +#endif
 +	Opt_noacl,
  	Opt_quotadf,
 +	Opt_noquotadf,
  	Opt_copyfrom,
 +	Opt_nocopyfrom,
 +	Opt_wsync,
 +	Opt_nowsync,
  };
  
 -enum ceph_recover_session_mode {
 -	ceph_recover_session_no,
 -	ceph_recover_session_clean
 +static match_table_t fsopt_tokens = {
 +	{Opt_wsize, "wsize=%d"},
 +	{Opt_rsize, "rsize=%d"},
 +	{Opt_rasize, "rasize=%d"},
 +	{Opt_caps_wanted_delay_min, "caps_wanted_delay_min=%d"},
 +	{Opt_caps_wanted_delay_max, "caps_wanted_delay_max=%d"},
 +	{Opt_caps_max, "caps_max=%d"},
 +	{Opt_readdir_max_entries, "readdir_max_entries=%d"},
 +	{Opt_readdir_max_bytes, "readdir_max_bytes=%d"},
 +	{Opt_congestion_kb, "write_congestion_kb=%d"},
 +	/* int args above */
 +	{Opt_snapdirname, "snapdirname=%s"},
 +	{Opt_mds_namespace, "mds_namespace=%s"},
 +	{Opt_recover_session, "recover_session=%s"},
 +	{Opt_fscache_uniq, "fsc=%s"},
 +	/* string args above */
 +	{Opt_dirstat, "dirstat"},
 +	{Opt_nodirstat, "nodirstat"},
 +	{Opt_rbytes, "rbytes"},
 +	{Opt_norbytes, "norbytes"},
 +	{Opt_asyncreaddir, "asyncreaddir"},
 +	{Opt_noasyncreaddir, "noasyncreaddir"},
 +	{Opt_dcache, "dcache"},
 +	{Opt_nodcache, "nodcache"},
 +	{Opt_ino32, "ino32"},
 +	{Opt_noino32, "noino32"},
 +	{Opt_fscache, "fsc"},
 +	{Opt_nofscache, "nofsc"},
 +	{Opt_poolperm, "poolperm"},
 +	{Opt_nopoolperm, "nopoolperm"},
 +	{Opt_require_active_mds, "require_active_mds"},
 +	{Opt_norequire_active_mds, "norequire_active_mds"},
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
 +	{Opt_acl, "acl"},
 +#endif
 +	{Opt_noacl, "noacl"},
 +	{Opt_quotadf, "quotadf"},
 +	{Opt_noquotadf, "noquotadf"},
 +	{Opt_copyfrom, "copyfrom"},
 +	{Opt_nocopyfrom, "nocopyfrom"},
 +	{Opt_wsync, "wsync"},
 +	{Opt_nowsync, "nowsync"},
 +	{-1, NULL}
  };
  
++<<<<<<< HEAD
 +static int parse_fsopt_token(char *c, void *private)
++=======
+ static const struct fs_parameter_enum ceph_param_recover[] = {
+ 	{ "no",		ceph_recover_session_no },
+ 	{ "clean",	ceph_recover_session_clean },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec ceph_mount_param_specs[] = {
+ 	fsparam_flag_no ("acl",				Opt_acl),
+ 	fsparam_flag_no ("asyncreaddir",		Opt_asyncreaddir),
+ 	fsparam_s32	("caps_max",			Opt_caps_max),
+ 	fsparam_u32	("caps_wanted_delay_max",	Opt_caps_wanted_delay_max),
+ 	fsparam_u32	("caps_wanted_delay_min",	Opt_caps_wanted_delay_min),
+ 	fsparam_u32	("write_congestion_kb",		Opt_congestion_kb),
+ 	fsparam_flag_no ("copyfrom",			Opt_copyfrom),
+ 	fsparam_flag_no ("dcache",			Opt_dcache),
+ 	fsparam_flag_no ("dirstat",			Opt_dirstat),
+ 	__fsparam	(fs_param_is_string, "fsc",	Opt_fscache,
+ 			 fs_param_neg_with_no | fs_param_v_optional, NULL),
+ 	fsparam_flag_no ("ino32",			Opt_ino32),
+ 	fsparam_string	("mds_namespace",		Opt_mds_namespace),
+ 	fsparam_flag_no ("poolperm",			Opt_poolperm),
+ 	fsparam_flag_no ("quotadf",			Opt_quotadf),
+ 	fsparam_u32	("rasize",			Opt_rasize),
+ 	fsparam_flag_no ("rbytes",			Opt_rbytes),
+ 	fsparam_u32	("readdir_max_bytes",		Opt_readdir_max_bytes),
+ 	fsparam_u32	("readdir_max_entries",		Opt_readdir_max_entries),
+ 	fsparam_enum	("recover_session",		Opt_recover_session, ceph_param_recover),
+ 	fsparam_flag_no ("require_active_mds",		Opt_require_active_mds),
+ 	fsparam_u32	("rsize",			Opt_rsize),
+ 	fsparam_string	("snapdirname",			Opt_snapdirname),
+ 	fsparam_string	("source",			Opt_source),
+ 	fsparam_u32	("wsize",			Opt_wsize),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description ceph_mount_parameters = {
+ 	.name           = "ceph",
+ 	.specs          = ceph_mount_param_specs,
+ };
+ 
+ struct ceph_parse_opts_ctx {
+ 	struct ceph_options		*copts;
+ 	struct ceph_mount_options	*opts;
+ };
+ 
+ /*
+  * Parse the source parameter.  Distinguish the server list from the path.
+  * Internally we do not include the leading '/' in the path.
+  *
+  * The source will look like:
+  *     <server_spec>[,<server_spec>...]:[<path>]
+  * where
+  *     <server_spec> is <ip>[:<port>]
+  *     <path> is optional, but if present must begin with '/'
+  */
+ static int ceph_parse_source(struct fs_parameter *param, struct fs_context *fc)
++>>>>>>> 2710c957a8ef (fs_parse: get rid of ->enums)
  {
 -	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
 -	struct ceph_mount_options *fsopt = pctx->opts;
 -	char *dev_name = param->string, *dev_name_end;
 -	int ret;
 +	struct ceph_mount_options *fsopt = private;
 +	substring_t argstr[MAX_OPT_ARGS];
 +	int token, intval, ret;
  
 -	dout("%s '%s'\n", __func__, dev_name);
 -	if (!dev_name || !*dev_name)
 -		return invalf(fc, "ceph: Empty source");
 +	token = match_token((char *)c, fsopt_tokens, argstr);
 +	if (token < 0)
 +		return -EINVAL;
  
 -	dev_name_end = strchr(dev_name, '/');
 -	if (dev_name_end) {
 -		if (strlen(dev_name_end) > 1) {
 -			kfree(fsopt->server_path);
 -			fsopt->server_path = kstrdup(dev_name_end, GFP_KERNEL);
 -			if (!fsopt->server_path)
 -				return -ENOMEM;
 +	if (token < Opt_last_int) {
 +		ret = match_int(&argstr[0], &intval);
 +		if (ret < 0) {
 +			pr_err("bad option arg (not int) at '%s'\n", c);
 +			return ret;
  		}
 +		dout("got int token %d val %d\n", token, intval);
 +	} else if (token > Opt_last_int && token < Opt_last_string) {
 +		dout("got string token %d val %s\n", token,
 +		     argstr[0].from);
  	} else {
 -		dev_name_end = dev_name + strlen(dev_name);
 +		dout("got token %d\n", token);
  	}
  
 -	dev_name_end--;		/* back up to ':' separator */
 -	if (dev_name_end < dev_name || *dev_name_end != ':')
 -		return invalf(fc, "ceph: No path or : separator in source");
 -
 -	dout("device name '%.*s'\n", (int)(dev_name_end - dev_name), dev_name);
 -	if (fsopt->server_path)
 -		dout("server path '%s'\n", fsopt->server_path);
 -
 -	ret = ceph_parse_mon_ips(param->string, dev_name_end - dev_name,
 -				 pctx->copts, fc);
 -	if (ret)
 -		return ret;
 -
 -	fc->source = param->string;
 -	param->string = NULL;
 -	return 0;
 -}
 -
 -static int ceph_parse_mount_param(struct fs_context *fc,
 -				  struct fs_parameter *param)
 -{
 -	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
 -	struct ceph_mount_options *fsopt = pctx->opts;
 -	struct fs_parse_result result;
 -	unsigned int mode;
 -	int token, ret;
 -
 -	ret = ceph_parse_param(param, pctx->copts, fc);
 -	if (ret != -ENOPARAM)
 -		return ret;
 -
 -	token = fs_parse(fc, &ceph_mount_parameters, param, &result);
 -	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
 -	if (token < 0)
 -		return token;
 -
  	switch (token) {
  	case Opt_snapdirname:
  		kfree(fsopt->snapdir_name);
diff --cc fs/jffs2/super.c
index 87bdf0f4cba1,ecd1a13a35d8..000000000000
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@@ -166,73 -165,56 +166,124 @@@ static const struct export_operations j
  enum {
  	Opt_override_compr,
  	Opt_rp_size,
 +	Opt_err,
  };
  
++<<<<<<< HEAD
 +static const match_table_t tokens = {
 +	{Opt_override_compr, "compr=%s"},
 +	{Opt_rp_size, "rp_size=%u"},
 +	{Opt_err, NULL},
 +};
 +
 +static int jffs2_parse_options(struct jffs2_sb_info *c, char *data)
 +{
 +	substring_t args[MAX_OPT_ARGS];
 +	char *p, *name;
 +	unsigned int opt;
 +
 +	if (!data)
 +		return 0;
 +
 +	while ((p = strsep(&data, ","))) {
 +		int token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_override_compr:
 +			name = match_strdup(&args[0]);
 +
 +			if (!name)
 +				return -ENOMEM;
 +			if (!strcmp(name, "none"))
 +				c->mount_opts.compr = JFFS2_COMPR_MODE_NONE;
 +#ifdef CONFIG_JFFS2_LZO
 +			else if (!strcmp(name, "lzo"))
 +				c->mount_opts.compr = JFFS2_COMPR_MODE_FORCELZO;
 +#endif
 +#ifdef CONFIG_JFFS2_ZLIB
 +			else if (!strcmp(name, "zlib"))
 +				c->mount_opts.compr =
 +						JFFS2_COMPR_MODE_FORCEZLIB;
 +#endif
 +			else {
 +				pr_err("Error: unknown compressor \"%s\"\n",
 +				       name);
 +				kfree(name);
 +				return -EINVAL;
 +			}
 +			kfree(name);
 +			c->mount_opts.override_compr = true;
 +			break;
 +		case Opt_rp_size:
 +			if (match_int(&args[0], &opt))
 +				return -EINVAL;
 +			opt *= 1024;
 +			if (opt > c->mtd->size) {
 +				pr_warn("Too large reserve pool specified, max "
 +					"is %llu KB\n", c->mtd->size / 1024);
 +				return -EINVAL;
 +			}
 +			c->mount_opts.rp_size = opt;
 +			break;
 +		default:
 +			pr_err("Error: unrecognized mount option '%s' or missing value\n",
 +			       p);
 +			return -EINVAL;
 +		}
++=======
+ static const struct fs_parameter_enum jffs2_param_compr[] = {
+ 	{"none",	JFFS2_COMPR_MODE_NONE },
+ #ifdef CONFIG_JFFS2_LZO
+ 	{"lzo",		JFFS2_COMPR_MODE_FORCELZO },
+ #endif
+ #ifdef CONFIG_JFFS2_ZLIB
+ 	{"zlib",	JFFS2_COMPR_MODE_FORCEZLIB },
+ #endif
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec jffs2_param_specs[] = {
+ 	fsparam_enum	("compr",	Opt_override_compr, jffs2_param_compr),
+ 	fsparam_u32	("rp_size",	Opt_rp_size),
+ 	{}
+ };
+ 
+ const struct fs_parameter_description jffs2_fs_parameters = {
+ 	.name		= "jffs2",
+ 	.specs		= jffs2_param_specs,
+ };
+ 
+ static int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	struct jffs2_sb_info *c = fc->s_fs_info;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, &jffs2_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_override_compr:
+ 		c->mount_opts.compr = result.uint_32;
+ 		c->mount_opts.override_compr = true;
+ 		break;
+ 	case Opt_rp_size:
+ 		if (result.uint_32 > UINT_MAX / 1024)
+ 			return invalf(fc, "jffs2: rp_size unrepresentable");
+ 		opt = result.uint_32 * 1024;
+ 		if (opt > c->mtd->size)
+ 			return invalf(fc, "jffs2: Too large reserve pool specified, max is %llu KB",
+ 				      c->mtd->size / 1024);
+ 		c->mount_opts.rp_size = opt;
+ 		break;
+ 	default:
+ 		return -EINVAL;
++>>>>>>> 2710c957a8ef (fs_parse: get rid of ->enums)
  	}
  
  	return 0;
diff --cc mm/shmem.c
index 02e9c145ac0a,1c02c6c20f45..000000000000
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@@ -3330,11 -3370,124 +3330,53 @@@ static const struct export_operations s
  	.fh_to_dentry	= shmem_fh_to_dentry,
  };
  
++<<<<<<< HEAD
 +static int shmem_parse_options(char *options, struct shmem_options *ctx)
++=======
+ enum shmem_param {
+ 	Opt_gid,
+ 	Opt_huge,
+ 	Opt_mode,
+ 	Opt_mpol,
+ 	Opt_nr_blocks,
+ 	Opt_nr_inodes,
+ 	Opt_size,
+ 	Opt_uid,
+ };
+ 
+ static const struct fs_parameter_enum shmem_param_enums_huge[] = {
+ 	{"never",	SHMEM_HUGE_NEVER },
+ 	{"always",	SHMEM_HUGE_ALWAYS },
+ 	{"within_size",	SHMEM_HUGE_WITHIN_SIZE },
+ 	{"advise",	SHMEM_HUGE_ADVISE },
+ 	{"deny",	SHMEM_HUGE_DENY },
+ 	{"force",	SHMEM_HUGE_FORCE },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec shmem_param_specs[] = {
+ 	fsparam_u32   ("gid",		Opt_gid),
+ 	fsparam_enum  ("huge",		Opt_huge,  shmem_param_enums_huge),
+ 	fsparam_u32oct("mode",		Opt_mode),
+ 	fsparam_string("mpol",		Opt_mpol),
+ 	fsparam_string("nr_blocks",	Opt_nr_blocks),
+ 	fsparam_string("nr_inodes",	Opt_nr_inodes),
+ 	fsparam_string("size",		Opt_size),
+ 	fsparam_u32   ("uid",		Opt_uid),
+ 	{}
+ };
+ 
+ const struct fs_parameter_description shmem_fs_parameters = {
+ 	.name		= "tmpfs",
+ 	.specs		= shmem_param_specs,
+ };
+ 
+ static int shmem_parse_one(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 2710c957a8ef (fs_parse: get rid of ->enums)
  {
 -	struct shmem_options *ctx = fc->fs_private;
 -	struct fs_parse_result result;
 -	unsigned long long size;
 -	char *rest;
 -	int opt;
 -
 -	opt = fs_parse(fc, &shmem_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case Opt_size:
 -		size = memparse(param->string, &rest);
 -		if (*rest == '%') {
 -			size <<= PAGE_SHIFT;
 -			size *= totalram_pages();
 -			do_div(size, 100);
 -			rest++;
 -		}
 -		if (*rest)
 -			goto bad_value;
 -		ctx->blocks = DIV_ROUND_UP(size, PAGE_SIZE);
 -		ctx->seen |= SHMEM_SEEN_BLOCKS;
 -		break;
 -	case Opt_nr_blocks:
 -		ctx->blocks = memparse(param->string, &rest);
 -		if (*rest)
 -			goto bad_value;
 -		ctx->seen |= SHMEM_SEEN_BLOCKS;
 -		break;
 -	case Opt_nr_inodes:
 -		ctx->inodes = memparse(param->string, &rest);
 -		if (*rest)
 -			goto bad_value;
 -		ctx->seen |= SHMEM_SEEN_INODES;
 -		break;
 -	case Opt_mode:
 -		ctx->mode = result.uint_32 & 07777;
 -		break;
 -	case Opt_uid:
 -		ctx->uid = make_kuid(current_user_ns(), result.uint_32);
 -		if (!uid_valid(ctx->uid))
 -			goto bad_value;
 -		break;
 -	case Opt_gid:
 -		ctx->gid = make_kgid(current_user_ns(), result.uint_32);
 -		if (!gid_valid(ctx->gid))
 -			goto bad_value;
 -		break;
 -	case Opt_huge:
 -		ctx->huge = result.uint_32;
 -		if (ctx->huge != SHMEM_HUGE_NEVER &&
 -		    !(IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&
 -		      has_transparent_hugepage()))
 -			goto unsupported_parameter;
 -		ctx->seen |= SHMEM_SEEN_HUGE;
 -		break;
 -	case Opt_mpol:
 -		if (IS_ENABLED(CONFIG_NUMA)) {
 -			mpol_put(ctx->mpol);
 -			ctx->mpol = NULL;
 -			if (mpol_parse_str(param->string, &ctx->mpol))
 -				goto bad_value;
 -			break;
 -		}
 -		goto unsupported_parameter;
 -	}
 -	return 0;
 -
 -unsupported_parameter:
 -	return invalf(fc, "tmpfs: Unsupported parameter '%s'", param->key);
 -bad_value:
 -	return invalf(fc, "tmpfs: Bad value for '%s'", param->key);
 -}
 -
 -static int shmem_parse_options(struct fs_context *fc, void *data)
 -{
 -	char *options = data;
 +	char *this_char, *value, *rest;
 +	uid_t uid;
 +	gid_t gid;
  
  	if (options) {
  		int err = security_sb_eat_lsm_opts(options, &fc->security);
diff --cc net/ceph/ceph_common.c
index 47dc7ae211b5,c2d0b5c47b5f..000000000000
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@@ -281,35 -269,56 +281,57 @@@ enum 
  	Opt_abort_on_full,
  };
  
++<<<<<<< HEAD
 +static match_table_t opt_tokens = {
 +	{Opt_osdtimeout, "osdtimeout=%d"},
 +	{Opt_osdkeepalivetimeout, "osdkeepalive=%d"},
 +	{Opt_mount_timeout, "mount_timeout=%d"},
 +	{Opt_osd_idle_ttl, "osd_idle_ttl=%d"},
 +	{Opt_osd_request_timeout, "osd_request_timeout=%d"},
 +	/* int args above */
 +	{Opt_fsid, "fsid=%s"},
 +	{Opt_name, "name=%s"},
 +	{Opt_secret, "secret=%s"},
 +	{Opt_key, "key=%s"},
 +	{Opt_ip, "ip=%s"},
 +	{Opt_crush_location, "crush_location=%s"},
 +	{Opt_read_from_replica, "read_from_replica=%s"},
 +	/* string args above */
 +	{Opt_share, "share"},
 +	{Opt_noshare, "noshare"},
 +	{Opt_crc, "crc"},
 +	{Opt_nocrc, "nocrc"},
 +	{Opt_cephx_require_signatures, "cephx_require_signatures"},
 +	{Opt_nocephx_require_signatures, "nocephx_require_signatures"},
 +	{Opt_cephx_sign_messages, "cephx_sign_messages"},
 +	{Opt_nocephx_sign_messages, "nocephx_sign_messages"},
 +	{Opt_tcp_nodelay, "tcp_nodelay"},
 +	{Opt_notcp_nodelay, "notcp_nodelay"},
 +	{Opt_abort_on_full, "abort_on_full"},
 +	{-1, NULL}
++=======
+ static const struct fs_parameter_spec ceph_param_specs[] = {
+ 	fsparam_flag	("abort_on_full",		Opt_abort_on_full),
+ 	fsparam_flag_no ("cephx_require_signatures",	Opt_cephx_require_signatures),
+ 	fsparam_flag_no ("cephx_sign_messages",		Opt_cephx_sign_messages),
+ 	fsparam_flag_no ("crc",				Opt_crc),
+ 	fsparam_string	("fsid",			Opt_fsid),
+ 	fsparam_string	("ip",				Opt_ip),
+ 	fsparam_string	("key",				Opt_key),
+ 	fsparam_u32	("mount_timeout",		Opt_mount_timeout),
+ 	fsparam_string	("name",			Opt_name),
+ 	fsparam_u32	("osd_idle_ttl",		Opt_osd_idle_ttl),
+ 	fsparam_u32	("osd_request_timeout",		Opt_osd_request_timeout),
+ 	fsparam_u32	("osdkeepalive",		Opt_osdkeepalivetimeout),
+ 	__fsparam	(fs_param_is_s32, "osdtimeout", Opt_osdtimeout,
+ 			 fs_param_deprecated, NULL),
+ 	fsparam_string	("secret",			Opt_secret),
+ 	fsparam_flag_no ("share",			Opt_share),
+ 	fsparam_flag_no ("tcp_nodelay",			Opt_tcp_nodelay),
+ 	{}
++>>>>>>> 2710c957a8ef (fs_parse: get rid of ->enums)
  };
  
 -static const struct fs_parameter_description ceph_parameters = {
 -        .name           = "libceph",
 -        .specs          = ceph_param_specs,
 -};
 -
 -struct ceph_options *ceph_alloc_options(void)
 -{
 -	struct ceph_options *opt;
 -
 -	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
 -	if (!opt)
 -		return NULL;
 -
 -	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
 -				GFP_KERNEL);
 -	if (!opt->mon_addr) {
 -		kfree(opt);
 -		return NULL;
 -	}
 -
 -	opt->flags = CEPH_OPT_DEFAULT;
 -	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
 -	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
 -	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
 -	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
 -	return opt;
 -}
 -EXPORT_SYMBOL(ceph_alloc_options);
 -
  void ceph_destroy_options(struct ceph_options *opt)
  {
  	dout("destroy_options %p\n", opt);
* Unmerged path fs/fs_parser.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path include/linux/fs_parser.h
* Unmerged path fs/afs/super.c
* Unmerged path fs/ceph/super.c
* Unmerged path fs/fs_parser.c
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index f4de5fcbc3c8..aa7b0f229f8b 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -1240,6 +1240,13 @@ enum opt_quota {
 	Opt_quota_on,
 };
 
+static const struct fs_parameter_enum gfs2_param_quota[] = {
+	{"off",        Opt_quota_off },
+	{"account",    Opt_quota_account },
+	{"on",         Opt_quota_on },
+	{}
+};
+
 static const unsigned int opt_quota_values[] = {
 	[Opt_quota_off]     = GFS2_QUOTA_OFF,
 	[Opt_quota_account] = GFS2_QUOTA_ACCOUNT,
@@ -1251,11 +1258,23 @@ enum opt_data {
 	Opt_data_ordered   = GFS2_DATA_ORDERED,
 };
 
+static const struct fs_parameter_enum gfs2_param_data[] = {
+	{"writeback",  Opt_data_writeback },
+	{"ordered",    Opt_data_ordered },
+	{}
+};
+
 enum opt_errors {
 	Opt_errors_withdraw = GFS2_ERRORS_WITHDRAW,
 	Opt_errors_panic    = GFS2_ERRORS_PANIC,
 };
 
+static const struct fs_parameter_enum gfs2_param_errors[] = {
+	{"withdraw",   Opt_errors_withdraw },
+	{"panic",      Opt_errors_panic },
+	{}
+};
+
 static const struct fs_parameter_spec gfs2_param_specs[] = {
 	fsparam_string ("lockproto",          Opt_lockproto),
 	fsparam_string ("locktable",          Opt_locktable),
@@ -1269,11 +1288,11 @@ static const struct fs_parameter_spec gfs2_param_specs[] = {
 	fsparam_flag   ("upgrade",            Opt_upgrade),
 	fsparam_flag_no("acl",                Opt_acl),
 	fsparam_flag_no("suiddir",            Opt_suiddir),
-	fsparam_enum   ("data",               Opt_data),
+	fsparam_enum   ("data",               Opt_data, gfs2_param_data),
 	fsparam_flag   ("meta",               Opt_meta),
 	fsparam_flag_no("discard",            Opt_discard),
 	fsparam_s32    ("commit",             Opt_commit),
-	fsparam_enum   ("errors",             Opt_errors),
+	fsparam_enum   ("errors",             Opt_errors, gfs2_param_errors),
 	fsparam_s32    ("statfs_quantum",     Opt_statfs_quantum),
 	fsparam_s32    ("statfs_percent",     Opt_statfs_percent),
 	fsparam_s32    ("quota_quantum",      Opt_quota_quantum),
@@ -1281,25 +1300,14 @@ static const struct fs_parameter_spec gfs2_param_specs[] = {
 	fsparam_flag_no("rgrplvb",            Opt_rgrplvb),
 	fsparam_flag_no("loccookie",          Opt_loccookie),
 	/* quota can be a flag or an enum so it gets special treatment */
-	__fsparam(fs_param_is_enum, "quota", Opt_quota, fs_param_neg_with_no|fs_param_v_optional),
-	{}
-};
-
-static const struct fs_parameter_enum gfs2_param_enums[] = {
-	{ Opt_quota,    "off",        Opt_quota_off },
-	{ Opt_quota,    "account",    Opt_quota_account },
-	{ Opt_quota,    "on",         Opt_quota_on },
-	{ Opt_data,     "writeback",  Opt_data_writeback },
-	{ Opt_data,     "ordered",    Opt_data_ordered },
-	{ Opt_errors,   "withdraw",   Opt_errors_withdraw },
-	{ Opt_errors,   "panic",      Opt_errors_panic },
+	__fsparam(fs_param_is_enum, "quota", Opt_quota,
+		fs_param_neg_with_no|fs_param_v_optional, gfs2_param_quota),
 	{}
 };
 
 static const struct fs_parameter_description gfs2_fs_parameters = {
 	.name = "gfs2",
 	.specs = gfs2_param_specs,
-	.enums = gfs2_param_enums,
 };
 
 /* Parse a single mount parameter */
* Unmerged path fs/jffs2/super.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path include/linux/fs_parser.h
* Unmerged path mm/shmem.c
* Unmerged path net/ceph/ceph_common.c
