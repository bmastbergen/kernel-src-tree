iommu/arm-smmu: Allow building as a module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Will Deacon <will@kernel.org>
commit cd221bd24ff5567bbcc11ec0c303141a7c2b71bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cd221bd2.failed

By conditionally dropping support for the legacy binding and exporting
the newly introduced 'arm_smmu_impl_init()' function we can allow the
ARM SMMU driver to be built as a module.

	Signed-off-by: Will Deacon <will@kernel.org>
	Tested-by: John Garry <john.garry@huawei.com> # smmu v3
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit cd221bd24ff5567bbcc11ec0c303141a7c2b71bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/Kconfig
#	drivers/iommu/Makefile
#	drivers/iommu/arm-smmu.c
diff --cc drivers/iommu/Kconfig
index a711d380403e,d66ace717cf4..000000000000
--- a/drivers/iommu/Kconfig
+++ b/drivers/iommu/Kconfig
@@@ -362,6 -368,43 +362,46 @@@ config ARM_SMM
  	  Say Y here if your SoC includes an IOMMU device implementing
  	  the ARM SMMU architecture.
  
++<<<<<<< HEAD
++=======
+ config ARM_SMMU_LEGACY_DT_BINDINGS
+ 	bool "Support the legacy \"mmu-masters\" devicetree bindings"
+ 	depends on ARM_SMMU=y && OF
+ 	help
+ 	  Support for the badly designed and deprecated "mmu-masters"
+ 	  devicetree bindings. This allows some DMA masters to attach
+ 	  to the SMMU but does not provide any support via the DMA API.
+ 	  If you're lucky, you might be able to get VFIO up and running.
+ 
+ 	  If you say Y here then you'll make me very sad. Instead, say N
+ 	  and move your firmware to the utopian future that was 2016.
+ 
+ config ARM_SMMU_DISABLE_BYPASS_BY_DEFAULT
+ 	bool "Default to disabling bypass on ARM SMMU v1 and v2"
+ 	depends on ARM_SMMU
+ 	default y
+ 	help
+ 	  Say Y here to (by default) disable bypass streams such that
+ 	  incoming transactions from devices that are not attached to
+ 	  an iommu domain will report an abort back to the device and
+ 	  will not be allowed to pass through the SMMU.
+ 
+ 	  Any old kernels that existed before this KConfig was
+ 	  introduced would default to _allowing_ bypass (AKA the
+ 	  equivalent of NO for this config).  However the default for
+ 	  this option is YES because the old behavior is insecure.
+ 
+ 	  There are few reasons to allow unmatched stream bypass, and
+ 	  even fewer good ones.  If saying YES here breaks your board
+ 	  you should work on fixing your board.  This KConfig option
+ 	  is expected to be removed in the future and we'll simply
+ 	  hardcode the bypass disable in the code.
+ 
+ 	  NOTE: the kernel command line parameter
+ 	  'arm-smmu.disable_bypass' will continue to override this
+ 	  config.
+ 
++>>>>>>> cd221bd24ff5 (iommu/arm-smmu: Allow building as a module)
  config ARM_SMMU_V3
  	tristate "ARM Ltd. System MMU Version 3 (SMMUv3) Support"
  	depends on ARM64
diff --cc drivers/iommu/Makefile
index a7f2eb8d90a7,2104fb8afc06..000000000000
--- a/drivers/iommu/Makefile
+++ b/drivers/iommu/Makefile
@@@ -13,7 -14,8 +13,12 @@@ obj-$(CONFIG_MSM_IOMMU) += msm_iommu.
  obj-$(CONFIG_AMD_IOMMU) += amd_iommu.o amd_iommu_init.o amd_iommu_quirks.o
  obj-$(CONFIG_AMD_IOMMU_DEBUGFS) += amd_iommu_debugfs.o
  obj-$(CONFIG_AMD_IOMMU_V2) += amd_iommu_v2.o
++<<<<<<< HEAD
 +obj-$(CONFIG_ARM_SMMU) += arm-smmu.o
++=======
+ obj-$(CONFIG_ARM_SMMU) += arm-smmu-mod.o
+ arm-smmu-mod-objs += arm-smmu.o arm-smmu-impl.o arm-smmu-qcom.o
++>>>>>>> cd221bd24ff5 (iommu/arm-smmu: Allow building as a module)
  obj-$(CONFIG_ARM_SMMU_V3) += arm-smmu-v3.o
  obj-$(CONFIG_DMAR_TABLE) += dmar.o
  obj-$(CONFIG_INTEL_IOMMU) += intel-iommu.o intel-pasid.o
diff --cc drivers/iommu/arm-smmu.c
index ab9a0239376c,3cfa138fbd4f..000000000000
--- a/drivers/iommu/arm-smmu.c
+++ b/drivers/iommu/arm-smmu.c
@@@ -330,19 -126,11 +330,27 @@@ static struct arm_smmu_domain *to_smmu_
  	return container_of(dom, struct arm_smmu_domain, domain);
  }
  
++<<<<<<< HEAD
 +static void parse_driver_options(struct arm_smmu_device *smmu)
 +{
 +	int i = 0;
 +
 +	do {
 +		if (of_property_read_bool(smmu->dev->of_node,
 +						arm_smmu_options[i].prop)) {
 +			smmu->options |= arm_smmu_options[i].opt;
 +			dev_notice(smmu->dev, "option %s\n",
 +				arm_smmu_options[i].prop);
 +		}
 +	} while (arm_smmu_options[++i].opt);
 +}
++=======
+ static struct platform_driver arm_smmu_driver;
+ static struct iommu_ops arm_smmu_ops;
+ 
+ #ifdef CONFIG_ARM_SMMU_LEGACY_DT_BINDINGS
+ static int arm_smmu_bus_init(struct iommu_ops *ops);
++>>>>>>> cd221bd24ff5 (iommu/arm-smmu: Allow building as a module)
  
  static struct device_node *dev_get_dev_node(struct device *dev)
  {
@@@ -1779,8 -1621,9 +1805,9 @@@ static struct iommu_ops arm_smmu_ops = 
  	.domain_set_attr	= arm_smmu_domain_set_attr,
  	.of_xlate		= arm_smmu_of_xlate,
  	.get_resv_regions	= arm_smmu_get_resv_regions,
 -	.put_resv_regions	= arm_smmu_put_resv_regions,
 +	.put_resv_regions	= generic_iommu_put_resv_regions,
  	.pgsize_bitmap		= -1UL, /* Restricted during device attach */
+ 	.owner			= THIS_MODULE,
  };
  
  static void arm_smmu_device_reset(struct arm_smmu_device *smmu)
@@@ -2209,12 -2016,12 +2236,14 @@@ static int arm_smmu_device_dt_probe(str
  	smmu->version = data->version;
  	smmu->model = data->model;
  
 +	parse_driver_options(smmu);
 +
  	legacy_binding = of_find_property(dev->of_node, "mmu-masters", NULL);
  	if (legacy_binding && !using_generic_binding) {
- 		if (!using_legacy_binding)
- 			pr_notice("deprecated \"mmu-masters\" DT property in use; DMA API support unavailable\n");
+ 		if (!using_legacy_binding) {
+ 			pr_notice("deprecated \"mmu-masters\" DT property in use; %s support unavailable\n",
+ 				  IS_ENABLED(CONFIG_ARM_SMMU_LEGACY_DT_BINDINGS) ? "DMA API" : "SMMU");
+ 		}
  		using_legacy_binding = true;
  	} else if (!legacy_binding && !using_legacy_binding) {
  		using_generic_binding = true;
@@@ -2240,10 -2055,31 +2269,16 @@@ static void arm_smmu_bus_init(void
  #endif
  #ifdef CONFIG_PCI
  	if (!iommu_present(&pci_bus_type)) {
++<<<<<<< HEAD
 +		pci_request_acs();
 +		bus_set_iommu(&pci_bus_type, &arm_smmu_ops);
++=======
+ 		err = bus_set_iommu(&pci_bus_type, ops);
+ 		if (err)
+ 			goto err_reset_amba_ops;
++>>>>>>> cd221bd24ff5 (iommu/arm-smmu: Allow building as a module)
  	}
  #endif
 -#ifdef CONFIG_FSL_MC_BUS
 -	if (!iommu_present(&fsl_mc_bus_type)) {
 -		err = bus_set_iommu(&fsl_mc_bus_type, ops);
 -		if (err)
 -			goto err_reset_pci_ops;
 -	}
 -#endif
 -	return 0;
 -
 -err_reset_pci_ops: __maybe_unused;
 -#ifdef CONFIG_PCI
 -	bus_set_iommu(&pci_bus_type, NULL);
 -#endif
 -err_reset_amba_ops: __maybe_unused;
 -#ifdef CONFIG_ARM_AMBA
 -	bus_set_iommu(&amba_bustype, NULL);
 -#endif
 -err_reset_platform_ops: __maybe_unused;
 -	bus_set_iommu(&platform_bus_type, NULL);
 -	return err;
  }
  
  static int arm_smmu_device_probe(struct platform_device *pdev)
@@@ -2392,21 -2230,7 +2427,25 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * With the legacy DT binding in play, though, we have no guarantees about
 + * probe order, but then we're also not doing default domains, so we can
 + * delay setting bus ops until we're sure every possible SMMU is ready,
 + * and that way ensure that no add_device() calls get missed.
 + */
 +static int arm_smmu_legacy_bus_init(void)
 +{
 +	if (using_legacy_binding)
 +		arm_smmu_bus_init();
 +	return 0;
 +}
 +device_initcall_sync(arm_smmu_legacy_bus_init);
 +
 +static void arm_smmu_device_shutdown(struct platform_device *pdev)
++=======
+ static int arm_smmu_device_remove(struct platform_device *pdev)
++>>>>>>> cd221bd24ff5 (iommu/arm-smmu: Allow building as a module)
  {
  	struct arm_smmu_device *smmu = platform_get_drvdata(pdev);
  
* Unmerged path drivers/iommu/Kconfig
* Unmerged path drivers/iommu/Makefile
* Unmerged path drivers/iommu/arm-smmu.c
