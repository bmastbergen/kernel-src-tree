powerpc: Use a function for getting the instruction op code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jordan Niethe <jniethe5@gmail.com>
commit 8094892d1aff14269d3b7bfcd8b941217eecd81f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8094892d.failed

In preparation for using a data type for instructions that can not be
directly used with the '>>' operator use a function for getting the op
code of an instruction.

	Signed-off-by: Jordan Niethe <jniethe5@gmail.com>
	Reviewed-by: Alistair Popple <alistair@popple.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200506034050.24806-9-jniethe5@gmail.com
(cherry picked from commit 8094892d1aff14269d3b7bfcd8b941217eecd81f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/inst.h
#	arch/powerpc/kernel/align.c
#	arch/powerpc/kernel/vecemu.c
#	arch/powerpc/mm/fault.c
diff --cc arch/powerpc/kernel/align.c
index 0d1b6370bae0,47dbba81a227..000000000000
--- a/arch/powerpc/kernel/align.c
+++ b/arch/powerpc/kernel/align.c
@@@ -313,8 -314,8 +313,13 @@@ int fix_alignment(struct pt_regs *regs
  	}
  
  #ifdef CONFIG_SPE
++<<<<<<< HEAD
 +	if ((instr >> 26) == 0x4) {
 +		int reg = (instr >> 21) & 0x1f;
++=======
+ 	if (ppc_inst_primary_opcode(instr) == 0x4) {
+ 		int reg = (ppc_inst_val(instr) >> 21) & 0x1f;
++>>>>>>> 8094892d1aff (powerpc: Use a function for getting the instruction op code)
  		PPC_WARN_ALIGNMENT(spe, regs);
  		return emulate_spe(regs, reg, instr);
  	}
diff --cc arch/powerpc/kernel/vecemu.c
index 4acd3fb2b38e,a544590b90e5..000000000000
--- a/arch/powerpc/kernel/vecemu.c
+++ b/arch/powerpc/kernel/vecemu.c
@@@ -266,15 -267,17 +267,21 @@@ int emulate_altivec(struct pt_regs *reg
  
  	if (get_user(instr, (unsigned int __user *) regs->nip))
  		return -EFAULT;
++<<<<<<< HEAD
 +	if ((instr >> 26) != 4)
++=======
+ 
+ 	word = ppc_inst_val(instr);
+ 	if (ppc_inst_primary_opcode(instr) != 4)
++>>>>>>> 8094892d1aff (powerpc: Use a function for getting the instruction op code)
  		return -EINVAL;		/* not an altivec instruction */
 -	vd = (word >> 21) & 0x1f;
 -	va = (word >> 16) & 0x1f;
 -	vb = (word >> 11) & 0x1f;
 -	vc = (word >> 6) & 0x1f;
 +	vd = (instr >> 21) & 0x1f;
 +	va = (instr >> 16) & 0x1f;
 +	vb = (instr >> 11) & 0x1f;
 +	vc = (instr >> 6) & 0x1f;
  
  	vrs = current->thread.vr_state.vr;
 -	switch (word & 0x3f) {
 +	switch (instr & 0x3f) {
  	case 10:
  		switch (vc) {
  		case 0:	/* vaddfp */
diff --cc arch/powerpc/mm/fault.c
index 7fce65689553,2c23c3076b1e..000000000000
--- a/arch/powerpc/mm/fault.c
+++ b/arch/powerpc/mm/fault.c
@@@ -42,29 -38,10 +42,34 @@@
  #include <asm/pgtable.h>
  #include <asm/mmu.h>
  #include <asm/mmu_context.h>
 +#include <asm/tlbflush.h>
  #include <asm/siginfo.h>
  #include <asm/debug.h>
++<<<<<<< HEAD
 +
 +static inline bool notify_page_fault(struct pt_regs *regs)
 +{
 +	bool ret = false;
 +
 +#ifdef CONFIG_KPROBES
 +	/* kprobe_running() needs smp_processor_id() */
 +	if (!user_mode(regs)) {
 +		preempt_disable();
 +		if (kprobe_running() && kprobe_fault_handler(regs, 11))
 +			ret = true;
 +		preempt_enable();
 +	}
 +#endif /* CONFIG_KPROBES */
 +
 +	if (unlikely(debugger_fault_handler(regs)))
 +		ret = true;
 +
 +	return ret;
 +}
++=======
+ #include <asm/kup.h>
+ #include <asm/inst.h>
++>>>>>>> 8094892d1aff (powerpc: Use a function for getting the instruction op code)
  
  /*
   * Check whether the instruction inst is a store using
@@@ -73,10 -50,10 +78,10 @@@
  static bool store_updates_sp(unsigned int inst)
  {
  	/* check for 1 in the rA field */
 -	if (((ppc_inst_val(inst) >> 16) & 0x1f) != 1)
 +	if (((inst >> 16) & 0x1f) != 1)
  		return false;
  	/* check major opcode */
- 	switch (inst >> 26) {
+ 	switch (ppc_inst_primary_opcode(inst)) {
  	case OP_STWU:
  	case OP_STBU:
  	case OP_STHU:
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/kernel/align.c
* Unmerged path arch/powerpc/kernel/vecemu.c
diff --git a/arch/powerpc/lib/code-patching.c b/arch/powerpc/lib/code-patching.c
index d6541402be75..98f33debb3b5 100644
--- a/arch/powerpc/lib/code-patching.c
+++ b/arch/powerpc/lib/code-patching.c
@@ -228,7 +228,7 @@ bool is_offset_in_branch_range(long offset)
  */
 bool is_conditional_branch(unsigned int instr)
 {
-	unsigned int opcode = instr >> 26;
+	unsigned int opcode = ppc_inst_primary_opcode(instr);
 
 	if (opcode == 16)       /* bc, bca, bcl, bcla */
 		return true;
@@ -286,7 +286,7 @@ unsigned int create_cond_branch(const unsigned int *addr,
 
 static unsigned int branch_opcode(unsigned int instr)
 {
-	return (instr >> 26) & 0x3F;
+	return ppc_inst_primary_opcode(instr) & 0x3F;
 }
 
 static int instr_is_branch_iform(unsigned int instr)
diff --git a/arch/powerpc/lib/sstep.c b/arch/powerpc/lib/sstep.c
index 65f8c55bf6ff..7b9e0ae29b59 100644
--- a/arch/powerpc/lib/sstep.c
+++ b/arch/powerpc/lib/sstep.c
@@ -1177,7 +1177,7 @@ int analyse_instr(struct instruction_op *op, const struct pt_regs *regs,
 
 	op->type = COMPUTE;
 
-	opcode = instr >> 26;
+	opcode = ppc_inst_primary_opcode(instr);
 	switch (opcode) {
 	case 16:	/* bc */
 		op->type = BRANCH;
* Unmerged path arch/powerpc/mm/fault.c
