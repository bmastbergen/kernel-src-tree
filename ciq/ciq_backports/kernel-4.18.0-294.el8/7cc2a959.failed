mm: remove __paginginit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Pavel Tatashin <pasha.tatashin@oracle.com>
commit 7cc2a9596d77e598a476ec7819046a453378d4a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7cc2a959.failed

__paginginit is the same thing as __meminit except for platforms without
sparsemem, there it is defined as __init.

Remove __paginginit and use __meminit.  Use __ref in one single function
that merges __meminit and __init sections: setup_usemap().

Link: http://lkml.kernel.org/r/20180801122348.21588-4-osalvador@techadventures.net
	Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
	Signed-off-by: Oscar Salvador <osalvador@suse.de>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Cc: Pasha Tatashin <Pavel.Tatashin@microsoft.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7cc2a9596d77e598a476ec7819046a453378d4a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index fa941d4649d5,98fe3b68f209..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -6605,42 -6409,31 +6606,46 @@@ static u64 __init init_unavailable_rang
   * initialized by going through __init_single_page(). But, there are some
   * struct pages which are reserved in memblock allocator and their fields
   * may be accessed (for example page_to_pfn() on some configuration accesses
 - * flags). We must explicitly zero those struct pages.
 + * flags). We must explicitly initialize those struct pages.
 + *
 + * This function also addresses a similar issue where struct pages are left
 + * uninitialized because the physical address range is not covered by
 + * memblock.memory or memblock.reserved. That could happen when memblock
 + * layout is manually configured via memmap=, or when the highest physical
 + * address (max_pfn) does not end on a section boundary.
   */
++<<<<<<< HEAD
 +static void __init init_unavailable_mem(void)
++=======
+ void __meminit zero_resv_unavail(void)
++>>>>>>> 7cc2a9596d77 (mm: remove __paginginit)
  {
  	phys_addr_t start, end;
 -	unsigned long pfn;
  	u64 i, pgcnt;
 +	phys_addr_t next = 0;
  
  	/*
 -	 * Loop through ranges that are reserved, but do not have reported
 -	 * physical memory backing.
 +	 * Loop through unavailable ranges not covered by memblock.memory.
  	 */
  	pgcnt = 0;
 -	for_each_resv_unavail_range(i, &start, &end) {
 -		for (pfn = PFN_DOWN(start); pfn < PFN_UP(end); pfn++) {
 -			if (!pfn_valid(ALIGN_DOWN(pfn, pageblock_nr_pages))) {
 -				pfn = ALIGN_DOWN(pfn, pageblock_nr_pages)
 -					+ pageblock_nr_pages - 1;
 -				continue;
 -			}
 -			mm_zero_struct_page(pfn_to_page(pfn));
 -			pgcnt++;
 -		}
 +	for_each_mem_range(i, &memblock.memory, NULL,
 +			NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end, NULL) {
 +		if (next < start)
 +			pgcnt += init_unavailable_range(PFN_DOWN(next),
 +							PFN_UP(start));
 +		next = end;
  	}
  
 +	/*
 +	 * Early sections always have a fully populated memmap for the whole
 +	 * section - see pfn_valid(). If the last section has holes at the
 +	 * end and that section is marked "online", the memmap will be
 +	 * considered initialized. Make sure that memmap has a well defined
 +	 * state.
 +	 */
 +	pgcnt += init_unavailable_range(PFN_DOWN(next),
 +					round_up(max_pfn, PAGES_PER_SECTION));
 +
  	/*
  	 * Struct pages that do not have backing memory. This could be because
  	 * firmware is using some of this memory, or for some other reasons.
diff --git a/mm/internal.h b/mm/internal.h
index 9193c2ad54f9..581b7d0ae4ef 100644
--- a/mm/internal.h
+++ b/mm/internal.h
@@ -388,18 +388,6 @@ static inline struct page *mem_map_next(struct page *iter,
 	return iter + 1;
 }
 
-/*
- * FLATMEM and DISCONTIGMEM configurations use alloc_bootmem_node,
- * so all functions starting at paging_init should be marked __init
- * in those cases. SPARSEMEM, however, allows for memory hotplug,
- * and alloc_bootmem_node is not used.
- */
-#ifdef CONFIG_SPARSEMEM
-#define __paginginit __meminit
-#else
-#define __paginginit __init
-#endif
-
 /* Memory initialisation debug and verification */
 enum mminit_level {
 	MMINIT_WARNING,
* Unmerged path mm/page_alloc.c
