bpf: Sharing bpf runtime stats with BPF_ENABLE_STATS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Song Liu <songliubraving@fb.com>
commit d46edd671a147032e22cfeb271a5734703093649
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d46edd67.failed

Currently, sysctl kernel.bpf_stats_enabled controls BPF runtime stats.
Typical userspace tools use kernel.bpf_stats_enabled as follows:

  1. Enable kernel.bpf_stats_enabled;
  2. Check program run_time_ns;
  3. Sleep for the monitoring period;
  4. Check program run_time_ns again, calculate the difference;
  5. Disable kernel.bpf_stats_enabled.

The problem with this approach is that only one userspace tool can toggle
this sysctl. If multiple tools toggle the sysctl at the same time, the
measurement may be inaccurate.

To fix this problem while keep backward compatibility, introduce a new
bpf command BPF_ENABLE_STATS. On success, this command enables stats and
returns a valid fd. BPF_ENABLE_STATS takes argument "type". Currently,
only one type, BPF_STATS_RUN_TIME, is supported. We can extend the
command to support other types of stats in the future.

With BPF_ENABLE_STATS, user space tool would have the following flow:

  1. Get a fd with BPF_ENABLE_STATS, and make sure it is valid;
  2. Check program run_time_ns;
  3. Sleep for the monitoring period;
  4. Check program run_time_ns again, calculate the difference;
  5. Close the fd.

	Signed-off-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200430071506.1408910-2-songliubraving@fb.com
(cherry picked from commit d46edd671a147032e22cfeb271a5734703093649)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/sysctl.c
diff --cc include/uapi/linux/bpf.h
index 5286de38e7b3,705e4822f997..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -618,7 -608,10 +625,14 @@@ union bpf_attr 
  		__u32		old_prog_fd;
  	} link_update;
  
++<<<<<<< HEAD
 +#endif /* __GENKSYMS__ */
++=======
+ 	struct { /* struct used by BPF_ENABLE_STATS command */
+ 		__u32		type;
+ 	} enable_stats;
+ 
++>>>>>>> d46edd671a14 (bpf: Sharing bpf runtime stats with BPF_ENABLE_STATS)
  } __attribute__((aligned(8)));
  
  /* The description below is an attempt at providing documentation to eBPF
diff --cc kernel/sysctl.c
index d9e0aff1f72d,7adfe5dbce9d..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -315,6 -199,1450 +315,1453 @@@ static int min_extfrag_threshold
  static int max_extfrag_threshold = 1000;
  #endif
  
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_SYSCTL */
+ 
+ #ifdef CONFIG_BPF_SYSCALL
+ static int bpf_stats_handler(struct ctl_table *table, int write,
+ 			     void __user *buffer, size_t *lenp,
+ 			     loff_t *ppos)
+ {
+ 	struct static_key *key = (struct static_key *)table->data;
+ 	static int saved_val;
+ 	int val, ret;
+ 	struct ctl_table tmp = {
+ 		.data   = &val,
+ 		.maxlen = sizeof(val),
+ 		.mode   = table->mode,
+ 		.extra1 = SYSCTL_ZERO,
+ 		.extra2 = SYSCTL_ONE,
+ 	};
+ 
+ 	if (write && !capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	mutex_lock(&bpf_stats_enabled_mutex);
+ 	val = saved_val;
+ 	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+ 	if (write && !ret && val != saved_val) {
+ 		if (val)
+ 			static_key_slow_inc(key);
+ 		else
+ 			static_key_slow_dec(key);
+ 		saved_val = val;
+ 	}
+ 	mutex_unlock(&bpf_stats_enabled_mutex);
+ 	return ret;
+ }
+ #endif
+ 
+ /*
+  * /proc/sys support
+  */
+ 
+ #ifdef CONFIG_PROC_SYSCTL
+ 
+ static int _proc_do_string(char *data, int maxlen, int write,
+ 		char *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	size_t len;
+ 	char c, *p;
+ 
+ 	if (!data || !maxlen || !*lenp) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 
+ 	if (write) {
+ 		if (sysctl_writes_strict == SYSCTL_WRITES_STRICT) {
+ 			/* Only continue writes not past the end of buffer. */
+ 			len = strlen(data);
+ 			if (len > maxlen - 1)
+ 				len = maxlen - 1;
+ 
+ 			if (*ppos > len)
+ 				return 0;
+ 			len = *ppos;
+ 		} else {
+ 			/* Start writing from beginning of buffer. */
+ 			len = 0;
+ 		}
+ 
+ 		*ppos += *lenp;
+ 		p = buffer;
+ 		while ((p - buffer) < *lenp && len < maxlen - 1) {
+ 			c = *(p++);
+ 			if (c == 0 || c == '\n')
+ 				break;
+ 			data[len++] = c;
+ 		}
+ 		data[len] = 0;
+ 	} else {
+ 		len = strlen(data);
+ 		if (len > maxlen)
+ 			len = maxlen;
+ 
+ 		if (*ppos > len) {
+ 			*lenp = 0;
+ 			return 0;
+ 		}
+ 
+ 		data += *ppos;
+ 		len  -= *ppos;
+ 
+ 		if (len > *lenp)
+ 			len = *lenp;
+ 		if (len)
+ 			memcpy(buffer, data, len);
+ 		if (len < *lenp) {
+ 			buffer[len] = '\n';
+ 			len++;
+ 		}
+ 		*lenp = len;
+ 		*ppos += len;
+ 	}
+ 	return 0;
+ }
+ 
+ static void warn_sysctl_write(struct ctl_table *table)
+ {
+ 	pr_warn_once("%s wrote to %s when file position was not 0!\n"
+ 		"This will not be supported in the future. To silence this\n"
+ 		"warning, set kernel.sysctl_writes_strict = -1\n",
+ 		current->comm, table->procname);
+ }
+ 
+ /**
+  * proc_first_pos_non_zero_ignore - check if first position is allowed
+  * @ppos: file position
+  * @table: the sysctl table
+  *
+  * Returns true if the first position is non-zero and the sysctl_writes_strict
+  * mode indicates this is not allowed for numeric input types. String proc
+  * handlers can ignore the return value.
+  */
+ static bool proc_first_pos_non_zero_ignore(loff_t *ppos,
+ 					   struct ctl_table *table)
+ {
+ 	if (!*ppos)
+ 		return false;
+ 
+ 	switch (sysctl_writes_strict) {
+ 	case SYSCTL_WRITES_STRICT:
+ 		return true;
+ 	case SYSCTL_WRITES_WARN:
+ 		warn_sysctl_write(table);
+ 		return false;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ /**
+  * proc_dostring - read a string sysctl
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes a string from/to the user buffer. If the kernel
+  * buffer provided is not large enough to hold the string, the
+  * string is truncated. The copied string is %NULL-terminated.
+  * If the string is being read by the user process, it is copied
+  * and a newline '\n' is added. It is truncated if the buffer is
+  * not large enough.
+  *
+  * Returns 0 on success.
+  */
+ int proc_dostring(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	if (write)
+ 		proc_first_pos_non_zero_ignore(ppos, table);
+ 
+ 	return _proc_do_string(table->data, table->maxlen, write, buffer, lenp,
+ 			ppos);
+ }
+ 
+ static size_t proc_skip_spaces(char **buf)
+ {
+ 	size_t ret;
+ 	char *tmp = skip_spaces(*buf);
+ 	ret = tmp - *buf;
+ 	*buf = tmp;
+ 	return ret;
+ }
+ 
+ static void proc_skip_char(char **buf, size_t *size, const char v)
+ {
+ 	while (*size) {
+ 		if (**buf != v)
+ 			break;
+ 		(*size)--;
+ 		(*buf)++;
+ 	}
+ }
+ 
+ /**
+  * strtoul_lenient - parse an ASCII formatted integer from a buffer and only
+  *                   fail on overflow
+  *
+  * @cp: kernel buffer containing the string to parse
+  * @endp: pointer to store the trailing characters
+  * @base: the base to use
+  * @res: where the parsed integer will be stored
+  *
+  * In case of success 0 is returned and @res will contain the parsed integer,
+  * @endp will hold any trailing characters.
+  * This function will fail the parse on overflow. If there wasn't an overflow
+  * the function will defer the decision what characters count as invalid to the
+  * caller.
+  */
+ static int strtoul_lenient(const char *cp, char **endp, unsigned int base,
+ 			   unsigned long *res)
+ {
+ 	unsigned long long result;
+ 	unsigned int rv;
+ 
+ 	cp = _parse_integer_fixup_radix(cp, &base);
+ 	rv = _parse_integer(cp, base, &result);
+ 	if ((rv & KSTRTOX_OVERFLOW) || (result != (unsigned long)result))
+ 		return -ERANGE;
+ 
+ 	cp += rv;
+ 
+ 	if (endp)
+ 		*endp = (char *)cp;
+ 
+ 	*res = (unsigned long)result;
+ 	return 0;
+ }
+ 
+ #define TMPBUFLEN 22
+ /**
+  * proc_get_long - reads an ASCII formatted integer from a user buffer
+  *
+  * @buf: a kernel buffer
+  * @size: size of the kernel buffer
+  * @val: this is where the number will be stored
+  * @neg: set to %TRUE if number is negative
+  * @perm_tr: a vector which contains the allowed trailers
+  * @perm_tr_len: size of the perm_tr vector
+  * @tr: pointer to store the trailer character
+  *
+  * In case of success %0 is returned and @buf and @size are updated with
+  * the amount of bytes read. If @tr is non-NULL and a trailing
+  * character exists (size is non-zero after returning from this
+  * function), @tr is updated with the trailing character.
+  */
+ static int proc_get_long(char **buf, size_t *size,
+ 			  unsigned long *val, bool *neg,
+ 			  const char *perm_tr, unsigned perm_tr_len, char *tr)
+ {
+ 	int len;
+ 	char *p, tmp[TMPBUFLEN];
+ 
+ 	if (!*size)
+ 		return -EINVAL;
+ 
+ 	len = *size;
+ 	if (len > TMPBUFLEN - 1)
+ 		len = TMPBUFLEN - 1;
+ 
+ 	memcpy(tmp, *buf, len);
+ 
+ 	tmp[len] = 0;
+ 	p = tmp;
+ 	if (*p == '-' && *size > 1) {
+ 		*neg = true;
+ 		p++;
+ 	} else
+ 		*neg = false;
+ 	if (!isdigit(*p))
+ 		return -EINVAL;
+ 
+ 	if (strtoul_lenient(p, &p, 0, val))
+ 		return -EINVAL;
+ 
+ 	len = p - tmp;
+ 
+ 	/* We don't know if the next char is whitespace thus we may accept
+ 	 * invalid integers (e.g. 1234...a) or two integers instead of one
+ 	 * (e.g. 123...1). So lets not allow such large numbers. */
+ 	if (len == TMPBUFLEN - 1)
+ 		return -EINVAL;
+ 
+ 	if (len < *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))
+ 		return -EINVAL;
+ 
+ 	if (tr && (len < *size))
+ 		*tr = *p;
+ 
+ 	*buf += len;
+ 	*size -= len;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * proc_put_long - converts an integer to a decimal ASCII formatted string
+  *
+  * @buf: the user buffer
+  * @size: the size of the user buffer
+  * @val: the integer to be converted
+  * @neg: sign of the number, %TRUE for negative
+  *
+  * In case of success @buf and @size are updated with the amount of bytes
+  * written.
+  */
+ static void proc_put_long(void **buf, size_t *size, unsigned long val, bool neg)
+ {
+ 	int len;
+ 	char tmp[TMPBUFLEN], *p = tmp;
+ 
+ 	sprintf(p, "%s%lu", neg ? "-" : "", val);
+ 	len = strlen(tmp);
+ 	if (len > *size)
+ 		len = *size;
+ 	memcpy(*buf, tmp, len);
+ 	*size -= len;
+ 	*buf += len;
+ }
+ #undef TMPBUFLEN
+ 
+ static void proc_put_char(void **buf, size_t *size, char c)
+ {
+ 	if (*size) {
+ 		char **buffer = (char **)buf;
+ 		**buffer = c;
+ 
+ 		(*size)--;
+ 		(*buffer)++;
+ 		*buf = *buffer;
+ 	}
+ }
+ 
+ static int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,
+ 				 int *valp,
+ 				 int write, void *data)
+ {
+ 	if (write) {
+ 		if (*negp) {
+ 			if (*lvalp > (unsigned long) INT_MAX + 1)
+ 				return -EINVAL;
+ 			*valp = -*lvalp;
+ 		} else {
+ 			if (*lvalp > (unsigned long) INT_MAX)
+ 				return -EINVAL;
+ 			*valp = *lvalp;
+ 		}
+ 	} else {
+ 		int val = *valp;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			*lvalp = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			*lvalp = (unsigned long)val;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ static int do_proc_douintvec_conv(unsigned long *lvalp,
+ 				  unsigned int *valp,
+ 				  int write, void *data)
+ {
+ 	if (write) {
+ 		if (*lvalp > UINT_MAX)
+ 			return -EINVAL;
+ 		*valp = *lvalp;
+ 	} else {
+ 		unsigned int val = *valp;
+ 		*lvalp = (unsigned long)val;
+ 	}
+ 	return 0;
+ }
+ 
+ static const char proc_wspace_sep[] = { ' ', '\t', '\n' };
+ 
+ static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,
+ 		  int write, void *buffer,
+ 		  size_t *lenp, loff_t *ppos,
+ 		  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,
+ 			      int write, void *data),
+ 		  void *data)
+ {
+ 	int *i, vleft, first = 1, err = 0;
+ 	size_t left;
+ 	char *p;
+ 	
+ 	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 	
+ 	i = (int *) tbl_data;
+ 	vleft = table->maxlen / sizeof(*i);
+ 	left = *lenp;
+ 
+ 	if (!conv)
+ 		conv = do_proc_dointvec_conv;
+ 
+ 	if (write) {
+ 		if (proc_first_pos_non_zero_ignore(ppos, table))
+ 			goto out;
+ 
+ 		if (left > PAGE_SIZE - 1)
+ 			left = PAGE_SIZE - 1;
+ 		p = buffer;
+ 	}
+ 
+ 	for (; left && vleft--; i++, first=0) {
+ 		unsigned long lval;
+ 		bool neg;
+ 
+ 		if (write) {
+ 			left -= proc_skip_spaces(&p);
+ 
+ 			if (!left)
+ 				break;
+ 			err = proc_get_long(&p, &left, &lval, &neg,
+ 					     proc_wspace_sep,
+ 					     sizeof(proc_wspace_sep), NULL);
+ 			if (err)
+ 				break;
+ 			if (conv(&neg, &lval, i, 1, data)) {
+ 				err = -EINVAL;
+ 				break;
+ 			}
+ 		} else {
+ 			if (conv(&neg, &lval, i, 0, data)) {
+ 				err = -EINVAL;
+ 				break;
+ 			}
+ 			if (!first)
+ 				proc_put_char(&buffer, &left, '\t');
+ 			proc_put_long(&buffer, &left, lval, neg);
+ 		}
+ 	}
+ 
+ 	if (!write && !first && left && !err)
+ 		proc_put_char(&buffer, &left, '\n');
+ 	if (write && !err && left)
+ 		left -= proc_skip_spaces(&p);
+ 	if (write && first)
+ 		return err ? : -EINVAL;
+ 	*lenp -= left;
+ out:
+ 	*ppos += *lenp;
+ 	return err;
+ }
+ 
+ static int do_proc_dointvec(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos,
+ 		  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,
+ 			      int write, void *data),
+ 		  void *data)
+ {
+ 	return __do_proc_dointvec(table->data, table, write,
+ 			buffer, lenp, ppos, conv, data);
+ }
+ 
+ static int do_proc_douintvec_w(unsigned int *tbl_data,
+ 			       struct ctl_table *table,
+ 			       void *buffer,
+ 			       size_t *lenp, loff_t *ppos,
+ 			       int (*conv)(unsigned long *lvalp,
+ 					   unsigned int *valp,
+ 					   int write, void *data),
+ 			       void *data)
+ {
+ 	unsigned long lval;
+ 	int err = 0;
+ 	size_t left;
+ 	bool neg;
+ 	char *p = buffer;
+ 
+ 	left = *lenp;
+ 
+ 	if (proc_first_pos_non_zero_ignore(ppos, table))
+ 		goto bail_early;
+ 
+ 	if (left > PAGE_SIZE - 1)
+ 		left = PAGE_SIZE - 1;
+ 
+ 	left -= proc_skip_spaces(&p);
+ 	if (!left) {
+ 		err = -EINVAL;
+ 		goto out_free;
+ 	}
+ 
+ 	err = proc_get_long(&p, &left, &lval, &neg,
+ 			     proc_wspace_sep,
+ 			     sizeof(proc_wspace_sep), NULL);
+ 	if (err || neg) {
+ 		err = -EINVAL;
+ 		goto out_free;
+ 	}
+ 
+ 	if (conv(&lval, tbl_data, 1, data)) {
+ 		err = -EINVAL;
+ 		goto out_free;
+ 	}
+ 
+ 	if (!err && left)
+ 		left -= proc_skip_spaces(&p);
+ 
+ out_free:
+ 	if (err)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ 
+ 	/* This is in keeping with old __do_proc_dointvec() */
+ bail_early:
+ 	*ppos += *lenp;
+ 	return err;
+ }
+ 
+ static int do_proc_douintvec_r(unsigned int *tbl_data, void *buffer,
+ 			       size_t *lenp, loff_t *ppos,
+ 			       int (*conv)(unsigned long *lvalp,
+ 					   unsigned int *valp,
+ 					   int write, void *data),
+ 			       void *data)
+ {
+ 	unsigned long lval;
+ 	int err = 0;
+ 	size_t left;
+ 
+ 	left = *lenp;
+ 
+ 	if (conv(&lval, tbl_data, 0, data)) {
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	proc_put_long(&buffer, &left, lval, false);
+ 	if (!left)
+ 		goto out;
+ 
+ 	proc_put_char(&buffer, &left, '\n');
+ 
+ out:
+ 	*lenp -= left;
+ 	*ppos += *lenp;
+ 
+ 	return err;
+ }
+ 
+ static int __do_proc_douintvec(void *tbl_data, struct ctl_table *table,
+ 			       int write, void *buffer,
+ 			       size_t *lenp, loff_t *ppos,
+ 			       int (*conv)(unsigned long *lvalp,
+ 					   unsigned int *valp,
+ 					   int write, void *data),
+ 			       void *data)
+ {
+ 	unsigned int *i, vleft;
+ 
+ 	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 
+ 	i = (unsigned int *) tbl_data;
+ 	vleft = table->maxlen / sizeof(*i);
+ 
+ 	/*
+ 	 * Arrays are not supported, keep this simple. *Do not* add
+ 	 * support for them.
+ 	 */
+ 	if (vleft != 1) {
+ 		*lenp = 0;
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!conv)
+ 		conv = do_proc_douintvec_conv;
+ 
+ 	if (write)
+ 		return do_proc_douintvec_w(i, table, buffer, lenp, ppos,
+ 					   conv, data);
+ 	return do_proc_douintvec_r(i, buffer, lenp, ppos, conv, data);
+ }
+ 
+ static int do_proc_douintvec(struct ctl_table *table, int write,
+ 			     void *buffer, size_t *lenp, loff_t *ppos,
+ 			     int (*conv)(unsigned long *lvalp,
+ 					 unsigned int *valp,
+ 					 int write, void *data),
+ 			     void *data)
+ {
+ 	return __do_proc_douintvec(table->data, table, write,
+ 				   buffer, lenp, ppos, conv, data);
+ }
+ 
+ /**
+  * proc_dointvec - read a vector of integers
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string. 
+  *
+  * Returns 0 on success.
+  */
+ int proc_dointvec(struct ctl_table *table, int write, void *buffer,
+ 		  size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);
+ }
+ 
+ #ifdef CONFIG_COMPACTION
+ static int proc_dointvec_minmax_warn_RT_change(struct ctl_table *table,
+ 		int write, void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int ret, old;
+ 
+ 	if (!IS_ENABLED(CONFIG_PREEMPT_RT) || !write)
+ 		return proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 
+ 	old = *(int *)table->data;
+ 	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 	if (ret)
+ 		return ret;
+ 	if (old != *(int *)table->data)
+ 		pr_warn_once("sysctl attribute %s changed by %s[%d]\n",
+ 			     table->procname, current->comm,
+ 			     task_pid_nr(current));
+ 	return ret;
+ }
+ #endif
+ 
+ /**
+  * proc_douintvec - read a vector of unsigned integers
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer
+  * values from/to the user buffer, treated as an ASCII string.
+  *
+  * Returns 0 on success.
+  */
+ int proc_douintvec(struct ctl_table *table, int write, void *buffer,
+ 		size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_douintvec(table, write, buffer, lenp, ppos,
+ 				 do_proc_douintvec_conv, NULL);
+ }
+ 
+ /*
+  * Taint values can only be increased
+  * This means we can safely use a temporary.
+  */
+ static int proc_taint(struct ctl_table *table, int write,
+ 			       void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	struct ctl_table t;
+ 	unsigned long tmptaint = get_taint();
+ 	int err;
+ 
+ 	if (write && !capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	t = *table;
+ 	t.data = &tmptaint;
+ 	err = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (write) {
+ 		/*
+ 		 * Poor man's atomic or. Not worth adding a primitive
+ 		 * to everyone's atomic.h for this
+ 		 */
+ 		int i;
+ 		for (i = 0; i < BITS_PER_LONG && tmptaint >> i; i++) {
+ 			if ((tmptaint >> i) & 1)
+ 				add_taint(i, LOCKDEP_STILL_OK);
+ 		}
+ 	}
+ 
+ 	return err;
+ }
+ 
+ #ifdef CONFIG_PRINTK
+ static int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,
+ 				void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	if (write && !capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	return proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ }
+ #endif
+ 
+ /**
+  * struct do_proc_dointvec_minmax_conv_param - proc_dointvec_minmax() range checking structure
+  * @min: pointer to minimum allowable value
+  * @max: pointer to maximum allowable value
+  *
+  * The do_proc_dointvec_minmax_conv_param structure provides the
+  * minimum and maximum values for doing range checking for those sysctl
+  * parameters that use the proc_dointvec_minmax() handler.
+  */
+ struct do_proc_dointvec_minmax_conv_param {
+ 	int *min;
+ 	int *max;
+ };
+ 
+ static int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,
+ 					int *valp,
+ 					int write, void *data)
+ {
+ 	int tmp, ret;
+ 	struct do_proc_dointvec_minmax_conv_param *param = data;
+ 	/*
+ 	 * If writing, first do so via a temporary local int so we can
+ 	 * bounds-check it before touching *valp.
+ 	 */
+ 	int *ip = write ? &tmp : valp;
+ 
+ 	ret = do_proc_dointvec_conv(negp, lvalp, ip, write, data);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (write) {
+ 		if ((param->min && *param->min > tmp) ||
+ 		    (param->max && *param->max < tmp))
+ 			return -EINVAL;
+ 		*valp = tmp;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * proc_dointvec_minmax - read a vector of integers with min/max values
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string.
+  *
+  * This routine will ensure the values are within the range specified by
+  * table->extra1 (min) and table->extra2 (max).
+  *
+  * Returns 0 on success or -EINVAL on write when the range check fails.
+  */
+ int proc_dointvec_minmax(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	struct do_proc_dointvec_minmax_conv_param param = {
+ 		.min = (int *) table->extra1,
+ 		.max = (int *) table->extra2,
+ 	};
+ 	return do_proc_dointvec(table, write, buffer, lenp, ppos,
+ 				do_proc_dointvec_minmax_conv, &param);
+ }
+ 
+ /**
+  * struct do_proc_douintvec_minmax_conv_param - proc_douintvec_minmax() range checking structure
+  * @min: pointer to minimum allowable value
+  * @max: pointer to maximum allowable value
+  *
+  * The do_proc_douintvec_minmax_conv_param structure provides the
+  * minimum and maximum values for doing range checking for those sysctl
+  * parameters that use the proc_douintvec_minmax() handler.
+  */
+ struct do_proc_douintvec_minmax_conv_param {
+ 	unsigned int *min;
+ 	unsigned int *max;
+ };
+ 
+ static int do_proc_douintvec_minmax_conv(unsigned long *lvalp,
+ 					 unsigned int *valp,
+ 					 int write, void *data)
+ {
+ 	int ret;
+ 	unsigned int tmp;
+ 	struct do_proc_douintvec_minmax_conv_param *param = data;
+ 	/* write via temporary local uint for bounds-checking */
+ 	unsigned int *up = write ? &tmp : valp;
+ 
+ 	ret = do_proc_douintvec_conv(lvalp, up, write, data);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (write) {
+ 		if ((param->min && *param->min > tmp) ||
+ 		    (param->max && *param->max < tmp))
+ 			return -ERANGE;
+ 
+ 		*valp = tmp;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * proc_douintvec_minmax - read a vector of unsigned ints with min/max values
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer
+  * values from/to the user buffer, treated as an ASCII string. Negative
+  * strings are not allowed.
+  *
+  * This routine will ensure the values are within the range specified by
+  * table->extra1 (min) and table->extra2 (max). There is a final sanity
+  * check for UINT_MAX to avoid having to support wrap around uses from
+  * userspace.
+  *
+  * Returns 0 on success or -ERANGE on write when the range check fails.
+  */
+ int proc_douintvec_minmax(struct ctl_table *table, int write,
+ 			  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	struct do_proc_douintvec_minmax_conv_param param = {
+ 		.min = (unsigned int *) table->extra1,
+ 		.max = (unsigned int *) table->extra2,
+ 	};
+ 	return do_proc_douintvec(table, write, buffer, lenp, ppos,
+ 				 do_proc_douintvec_minmax_conv, &param);
+ }
+ 
+ static int do_proc_dopipe_max_size_conv(unsigned long *lvalp,
+ 					unsigned int *valp,
+ 					int write, void *data)
+ {
+ 	if (write) {
+ 		unsigned int val;
+ 
+ 		val = round_pipe_size(*lvalp);
+ 		if (val == 0)
+ 			return -EINVAL;
+ 
+ 		*valp = val;
+ 	} else {
+ 		unsigned int val = *valp;
+ 		*lvalp = (unsigned long) val;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int proc_dopipe_max_size(struct ctl_table *table, int write,
+ 				void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_douintvec(table, write, buffer, lenp, ppos,
+ 				 do_proc_dopipe_max_size_conv, NULL);
+ }
+ 
+ static void validate_coredump_safety(void)
+ {
+ #ifdef CONFIG_COREDUMP
+ 	if (suid_dumpable == SUID_DUMP_ROOT &&
+ 	    core_pattern[0] != '/' && core_pattern[0] != '|') {
+ 		printk(KERN_WARNING
+ "Unsafe core_pattern used with fs.suid_dumpable=2.\n"
+ "Pipe handler or fully qualified core dump path required.\n"
+ "Set kernel.core_pattern before fs.suid_dumpable.\n"
+ 		);
+ 	}
+ #endif
+ }
+ 
+ static int proc_dointvec_minmax_coredump(struct ctl_table *table, int write,
+ 		void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int error = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 	if (!error)
+ 		validate_coredump_safety();
+ 	return error;
+ }
+ 
+ #ifdef CONFIG_COREDUMP
+ static int proc_dostring_coredump(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int error = proc_dostring(table, write, buffer, lenp, ppos);
+ 	if (!error)
+ 		validate_coredump_safety();
+ 	return error;
+ }
+ #endif
+ 
+ #ifdef CONFIG_MAGIC_SYSRQ
+ static int sysrq_sysctl_handler(struct ctl_table *table, int write,
+ 				void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int tmp, ret;
+ 
+ 	tmp = sysrq_mask();
+ 
+ 	ret = __do_proc_dointvec(&tmp, table, write, buffer,
+ 			       lenp, ppos, NULL, NULL);
+ 	if (ret || !write)
+ 		return ret;
+ 
+ 	if (write)
+ 		sysrq_toggle_support(tmp);
+ 
+ 	return 0;
+ }
+ #endif
+ 
+ static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table,
+ 		int write, void *buffer, size_t *lenp, loff_t *ppos,
+ 		unsigned long convmul, unsigned long convdiv)
+ {
+ 	unsigned long *i, *min, *max;
+ 	int vleft, first = 1, err = 0;
+ 	size_t left;
+ 	char *p;
+ 
+ 	if (!data || !table->maxlen || !*lenp || (*ppos && !write)) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 
+ 	i = (unsigned long *) data;
+ 	min = (unsigned long *) table->extra1;
+ 	max = (unsigned long *) table->extra2;
+ 	vleft = table->maxlen / sizeof(unsigned long);
+ 	left = *lenp;
+ 
+ 	if (write) {
+ 		if (proc_first_pos_non_zero_ignore(ppos, table))
+ 			goto out;
+ 
+ 		if (left > PAGE_SIZE - 1)
+ 			left = PAGE_SIZE - 1;
+ 		p = buffer;
+ 	}
+ 
+ 	for (; left && vleft--; i++, first = 0) {
+ 		unsigned long val;
+ 
+ 		if (write) {
+ 			bool neg;
+ 
+ 			left -= proc_skip_spaces(&p);
+ 			if (!left)
+ 				break;
+ 
+ 			err = proc_get_long(&p, &left, &val, &neg,
+ 					     proc_wspace_sep,
+ 					     sizeof(proc_wspace_sep), NULL);
+ 			if (err)
+ 				break;
+ 			if (neg)
+ 				continue;
+ 			val = convmul * val / convdiv;
+ 			if ((min && val < *min) || (max && val > *max)) {
+ 				err = -EINVAL;
+ 				break;
+ 			}
+ 			*i = val;
+ 		} else {
+ 			val = convdiv * (*i) / convmul;
+ 			if (!first)
+ 				proc_put_char(&buffer, &left, '\t');
+ 			proc_put_long(&buffer, &left, val, false);
+ 		}
+ 	}
+ 
+ 	if (!write && !first && left && !err)
+ 		proc_put_char(&buffer, &left, '\n');
+ 	if (write && !err)
+ 		left -= proc_skip_spaces(&p);
+ 	if (write && first)
+ 		return err ? : -EINVAL;
+ 	*lenp -= left;
+ out:
+ 	*ppos += *lenp;
+ 	return err;
+ }
+ 
+ static int do_proc_doulongvec_minmax(struct ctl_table *table, int write,
+ 		void *buffer, size_t *lenp, loff_t *ppos, unsigned long convmul,
+ 		unsigned long convdiv)
+ {
+ 	return __do_proc_doulongvec_minmax(table->data, table, write,
+ 			buffer, lenp, ppos, convmul, convdiv);
+ }
+ 
+ /**
+  * proc_doulongvec_minmax - read a vector of long integers with min/max values
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long
+  * values from/to the user buffer, treated as an ASCII string.
+  *
+  * This routine will ensure the values are within the range specified by
+  * table->extra1 (min) and table->extra2 (max).
+  *
+  * Returns 0 on success.
+  */
+ int proc_doulongvec_minmax(struct ctl_table *table, int write,
+ 			   void *buffer, size_t *lenp, loff_t *ppos)
+ {
+     return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);
+ }
+ 
+ /**
+  * proc_doulongvec_ms_jiffies_minmax - read a vector of millisecond values with min/max values
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long
+  * values from/to the user buffer, treated as an ASCII string. The values
+  * are treated as milliseconds, and converted to jiffies when they are stored.
+  *
+  * This routine will ensure the values are within the range specified by
+  * table->extra1 (min) and table->extra2 (max).
+  *
+  * Returns 0 on success.
+  */
+ int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
+ 				      void *buffer, size_t *lenp, loff_t *ppos)
+ {
+     return do_proc_doulongvec_minmax(table, write, buffer,
+ 				     lenp, ppos, HZ, 1000l);
+ }
+ 
+ 
+ static int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,
+ 					 int *valp,
+ 					 int write, void *data)
+ {
+ 	if (write) {
+ 		if (*lvalp > INT_MAX / HZ)
+ 			return 1;
+ 		*valp = *negp ? -(*lvalp*HZ) : (*lvalp*HZ);
+ 	} else {
+ 		int val = *valp;
+ 		unsigned long lval;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			lval = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			lval = (unsigned long)val;
+ 		}
+ 		*lvalp = lval / HZ;
+ 	}
+ 	return 0;
+ }
+ 
+ static int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,
+ 						int *valp,
+ 						int write, void *data)
+ {
+ 	if (write) {
+ 		if (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ)
+ 			return 1;
+ 		*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp);
+ 	} else {
+ 		int val = *valp;
+ 		unsigned long lval;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			lval = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			lval = (unsigned long)val;
+ 		}
+ 		*lvalp = jiffies_to_clock_t(lval);
+ 	}
+ 	return 0;
+ }
+ 
+ static int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,
+ 					    int *valp,
+ 					    int write, void *data)
+ {
+ 	if (write) {
+ 		unsigned long jif = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);
+ 
+ 		if (jif > INT_MAX)
+ 			return 1;
+ 		*valp = (int)jif;
+ 	} else {
+ 		int val = *valp;
+ 		unsigned long lval;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			lval = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			lval = (unsigned long)val;
+ 		}
+ 		*lvalp = jiffies_to_msecs(lval);
+ 	}
+ 	return 0;
+ }
+ 
+ /**
+  * proc_dointvec_jiffies - read a vector of integers as seconds
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string. 
+  * The values read are assumed to be in seconds, and are converted into
+  * jiffies.
+  *
+  * Returns 0 on success.
+  */
+ int proc_dointvec_jiffies(struct ctl_table *table, int write,
+ 			  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+     return do_proc_dointvec(table,write,buffer,lenp,ppos,
+ 		    	    do_proc_dointvec_jiffies_conv,NULL);
+ }
+ 
+ /**
+  * proc_dointvec_userhz_jiffies - read a vector of integers as 1/USER_HZ seconds
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: pointer to the file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string. 
+  * The values read are assumed to be in 1/USER_HZ seconds, and 
+  * are converted into jiffies.
+  *
+  * Returns 0 on success.
+  */
+ int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
+ 				 void *buffer, size_t *lenp, loff_t *ppos)
+ {
+     return do_proc_dointvec(table,write,buffer,lenp,ppos,
+ 		    	    do_proc_dointvec_userhz_jiffies_conv,NULL);
+ }
+ 
+ /**
+  * proc_dointvec_ms_jiffies - read a vector of integers as 1 milliseconds
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  * @ppos: the current position in the file
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string. 
+  * The values read are assumed to be in 1/1000 seconds, and 
+  * are converted into jiffies.
+  *
+  * Returns 0 on success.
+  */
+ int proc_dointvec_ms_jiffies(struct ctl_table *table, int write, void *buffer,
+ 		size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_dointvec(table, write, buffer, lenp, ppos,
+ 				do_proc_dointvec_ms_jiffies_conv, NULL);
+ }
+ 
+ static int proc_do_cad_pid(struct ctl_table *table, int write, void *buffer,
+ 		size_t *lenp, loff_t *ppos)
+ {
+ 	struct pid *new_pid;
+ 	pid_t tmp;
+ 	int r;
+ 
+ 	tmp = pid_vnr(cad_pid);
+ 
+ 	r = __do_proc_dointvec(&tmp, table, write, buffer,
+ 			       lenp, ppos, NULL, NULL);
+ 	if (r || !write)
+ 		return r;
+ 
+ 	new_pid = find_get_pid(tmp);
+ 	if (!new_pid)
+ 		return -ESRCH;
+ 
+ 	put_pid(xchg(&cad_pid, new_pid));
+ 	return 0;
+ }
+ 
+ /**
+  * proc_do_large_bitmap - read/write from/to a large bitmap
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * The bitmap is stored at table->data and the bitmap length (in bits)
+  * in table->maxlen.
+  *
+  * We use a range comma separated format (e.g. 1,3-4,10-10) so that
+  * large bitmaps may be represented in a compact manner. Writing into
+  * the file will clear the bitmap then update it with the given input.
+  *
+  * Returns 0 on success.
+  */
+ int proc_do_large_bitmap(struct ctl_table *table, int write,
+ 			 void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int err = 0;
+ 	bool first = 1;
+ 	size_t left = *lenp;
+ 	unsigned long bitmap_len = table->maxlen;
+ 	unsigned long *bitmap = *(unsigned long **) table->data;
+ 	unsigned long *tmp_bitmap = NULL;
+ 	char tr_a[] = { '-', ',', '\n' }, tr_b[] = { ',', '\n', 0 }, c;
+ 
+ 	if (!bitmap || !bitmap_len || !left || (*ppos && !write)) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 
+ 	if (write) {
+ 		char *p = buffer;
+ 		size_t skipped = 0;
+ 
+ 		if (left > PAGE_SIZE - 1) {
+ 			left = PAGE_SIZE - 1;
+ 			/* How much of the buffer we'll skip this pass */
+ 			skipped = *lenp - left;
+ 		}
+ 
+ 		tmp_bitmap = bitmap_zalloc(bitmap_len, GFP_KERNEL);
+ 		if (!tmp_bitmap)
+ 			return -ENOMEM;
+ 		proc_skip_char(&p, &left, '\n');
+ 		while (!err && left) {
+ 			unsigned long val_a, val_b;
+ 			bool neg;
+ 			size_t saved_left;
+ 
+ 			/* In case we stop parsing mid-number, we can reset */
+ 			saved_left = left;
+ 			err = proc_get_long(&p, &left, &val_a, &neg, tr_a,
+ 					     sizeof(tr_a), &c);
+ 			/*
+ 			 * If we consumed the entirety of a truncated buffer or
+ 			 * only one char is left (may be a "-"), then stop here,
+ 			 * reset, & come back for more.
+ 			 */
+ 			if ((left <= 1) && skipped) {
+ 				left = saved_left;
+ 				break;
+ 			}
+ 
+ 			if (err)
+ 				break;
+ 			if (val_a >= bitmap_len || neg) {
+ 				err = -EINVAL;
+ 				break;
+ 			}
+ 
+ 			val_b = val_a;
+ 			if (left) {
+ 				p++;
+ 				left--;
+ 			}
+ 
+ 			if (c == '-') {
+ 				err = proc_get_long(&p, &left, &val_b,
+ 						     &neg, tr_b, sizeof(tr_b),
+ 						     &c);
+ 				/*
+ 				 * If we consumed all of a truncated buffer or
+ 				 * then stop here, reset, & come back for more.
+ 				 */
+ 				if (!left && skipped) {
+ 					left = saved_left;
+ 					break;
+ 				}
+ 
+ 				if (err)
+ 					break;
+ 				if (val_b >= bitmap_len || neg ||
+ 				    val_a > val_b) {
+ 					err = -EINVAL;
+ 					break;
+ 				}
+ 				if (left) {
+ 					p++;
+ 					left--;
+ 				}
+ 			}
+ 
+ 			bitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);
+ 			first = 0;
+ 			proc_skip_char(&p, &left, '\n');
+ 		}
+ 		left += skipped;
+ 	} else {
+ 		unsigned long bit_a, bit_b = 0;
+ 
+ 		while (left) {
+ 			bit_a = find_next_bit(bitmap, bitmap_len, bit_b);
+ 			if (bit_a >= bitmap_len)
+ 				break;
+ 			bit_b = find_next_zero_bit(bitmap, bitmap_len,
+ 						   bit_a + 1) - 1;
+ 
+ 			if (!first)
+ 				proc_put_char(&buffer, &left, ',');
+ 			proc_put_long(&buffer, &left, bit_a, false);
+ 			if (bit_a != bit_b) {
+ 				proc_put_char(&buffer, &left, '-');
+ 				proc_put_long(&buffer, &left, bit_b, false);
+ 			}
+ 
+ 			first = 0; bit_b++;
+ 		}
+ 		proc_put_char(&buffer, &left, '\n');
+ 	}
+ 
+ 	if (!err) {
+ 		if (write) {
+ 			if (*ppos)
+ 				bitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);
+ 			else
+ 				bitmap_copy(bitmap, tmp_bitmap, bitmap_len);
+ 		}
+ 		*lenp -= left;
+ 		*ppos += *lenp;
+ 	}
+ 
+ 	bitmap_free(tmp_bitmap);
+ 	return err;
+ }
+ 
+ #else /* CONFIG_PROC_SYSCTL */
+ 
+ int proc_dostring(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_douintvec(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec_minmax(struct ctl_table *table, int write,
+ 		    void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_douintvec_minmax(struct ctl_table *table, int write,
+ 			  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec_jiffies(struct ctl_table *table, int write,
+ 		    void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
+ 		    void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,
+ 			     void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_doulongvec_minmax(struct ctl_table *table, int write,
+ 		    void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
+ 				      void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_do_large_bitmap(struct ctl_table *table, int write,
+ 			 void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ #endif /* CONFIG_PROC_SYSCTL */
+ 
+ #if defined(CONFIG_SYSCTL)
+ int proc_do_static_key(struct ctl_table *table, int write,
+ 		       void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	struct static_key *key = (struct static_key *)table->data;
+ 	static DEFINE_MUTEX(static_key_mutex);
+ 	int val, ret;
+ 	struct ctl_table tmp = {
+ 		.data   = &val,
+ 		.maxlen = sizeof(val),
+ 		.mode   = table->mode,
+ 		.extra1 = SYSCTL_ZERO,
+ 		.extra2 = SYSCTL_ONE,
+ 	};
+ 
+ 	if (write && !capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	mutex_lock(&static_key_mutex);
+ 	val = static_key_enabled(key);
+ 	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+ 	if (write && !ret) {
+ 		if (val)
+ 			static_key_enable(key);
+ 		else
+ 			static_key_disable(key);
+ 	}
+ 	mutex_unlock(&static_key_mutex);
+ 	return ret;
+ }
+ 
++>>>>>>> d46edd671a14 (bpf: Sharing bpf runtime stats with BPF_ENABLE_STATS)
  static struct ctl_table kern_table[] = {
  	{
  		.procname	= "sched_child_runs_first",
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index 2c321dfdffe1..6dbd9f8bb743 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -1007,6 +1007,7 @@ _out:							\
 
 #ifdef CONFIG_BPF_SYSCALL
 DECLARE_PER_CPU(int, bpf_prog_active);
+extern struct mutex bpf_stats_enabled_mutex;
 
 /*
  * Block execution of BPF programs attached to instrumentation (perf,
* Unmerged path include/uapi/linux/bpf.h
diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c
index bc62675c1374..28c1ae3305b0 100644
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@ -3918,6 +3918,60 @@ static int bpf_link_get_fd_by_id(const union bpf_attr *attr)
 	return fd;
 }
 
+DEFINE_MUTEX(bpf_stats_enabled_mutex);
+
+static int bpf_stats_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&bpf_stats_enabled_mutex);
+	static_key_slow_dec(&bpf_stats_enabled_key.key);
+	mutex_unlock(&bpf_stats_enabled_mutex);
+	return 0;
+}
+
+static const struct file_operations bpf_stats_fops = {
+	.release = bpf_stats_release,
+};
+
+static int bpf_enable_runtime_stats(void)
+{
+	int fd;
+
+	mutex_lock(&bpf_stats_enabled_mutex);
+
+	/* Set a very high limit to avoid overflow */
+	if (static_key_count(&bpf_stats_enabled_key.key) > INT_MAX / 2) {
+		mutex_unlock(&bpf_stats_enabled_mutex);
+		return -EBUSY;
+	}
+
+	fd = anon_inode_getfd("bpf-stats", &bpf_stats_fops, NULL, O_CLOEXEC);
+	if (fd >= 0)
+		static_key_slow_inc(&bpf_stats_enabled_key.key);
+
+	mutex_unlock(&bpf_stats_enabled_mutex);
+	return fd;
+}
+
+#define BPF_ENABLE_STATS_LAST_FIELD enable_stats.type
+
+static int bpf_enable_stats(union bpf_attr *attr)
+{
+
+	if (CHECK_ATTR(BPF_ENABLE_STATS))
+		return -EINVAL;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	switch (attr->enable_stats.type) {
+	case BPF_STATS_RUN_TIME:
+		return bpf_enable_runtime_stats();
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
 SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)
 {
 	union bpf_attr attr;
@@ -4042,6 +4096,9 @@ SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, siz
 		err = bpf_obj_get_next_id(&attr, uattr,
 					  &link_idr, &link_idr_lock);
 		break;
+	case BPF_ENABLE_STATS:
+		err = bpf_enable_stats(&attr);
+		break;
 	default:
 		err = -EINVAL;
 		break;
* Unmerged path kernel/sysctl.c
diff --git a/tools/include/uapi/linux/bpf.h b/tools/include/uapi/linux/bpf.h
index 807bf415efb2..45fef500f3fc 100644
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@ -115,6 +115,7 @@ enum bpf_cmd {
 	BPF_LINK_UPDATE,
 	BPF_LINK_GET_FD_BY_ID,
 	BPF_LINK_GET_NEXT_ID,
+	BPF_ENABLE_STATS,
 };
 
 enum bpf_map_type {
@@ -390,6 +391,12 @@ enum {
  */
 #define BPF_F_QUERY_EFFECTIVE	(1U << 0)
 
+/* type for BPF_ENABLE_STATS */
+enum bpf_stats_type {
+	/* enabled run_time_ns and run_cnt */
+	BPF_STATS_RUN_TIME = 0,
+};
+
 enum bpf_stack_build_id_status {
 	/* user space need an empty entry to identify end of a trace */
 	BPF_STACK_BUILD_ID_EMPTY = 0,
@@ -601,6 +608,10 @@ union bpf_attr {
 		__u32		old_prog_fd;
 	} link_update;
 
+	struct { /* struct used by BPF_ENABLE_STATS command */
+		__u32		type;
+	} enable_stats;
+
 } __attribute__((aligned(8)));
 
 /* The description below is an attempt at providing documentation to eBPF
