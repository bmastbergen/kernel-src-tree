s390/qdio: remove internal polling in non-thinint path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit a709423f7a3a452e5fa7442425817c1bdccd7926
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a709423f.failed

For non-thinint devices in LPAR, qdio polls an idle Input Queue for a
little while to catch more work. But platform support for thinints has
been around practically _forever_ by now, so this micro-optimization is
seeing 0 actual use. Remove it to reduce the overall complexity of the
hot path.

In the meantime we also grew support for driver-level polling
(eg. NAPI in qeth), so it's quite questionable how useful this would
actually be on current kernels.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit a709423f7a3a452e5fa7442425817c1bdccd7926)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/cio/qdio.h
diff --cc drivers/s390/cio/qdio.h
index 37e66a9bcf46,cd2df4ff8e0e..000000000000
--- a/drivers/s390/cio/qdio.h
+++ b/drivers/s390/cio/qdio.h
@@@ -181,12 -180,6 +180,15 @@@ struct qdio_input_q 
  	/* Batch of SBALs that we processed while polling the queue: */
  	unsigned int batch_start;
  	unsigned int batch_count;
++<<<<<<< HEAD
 +	/* last time of noticing incoming data */
 +	u64 timestamp;
 +	/* upper-layer polling flag */
 +	unsigned long queue_irq_state;
 +	/* callback to start upper-layer polling */
 +	void (*queue_start_poll) (struct ccw_device *, int, unsigned long);
++=======
++>>>>>>> a709423f7a3a (s390/qdio: remove internal polling in non-thinint path)
  };
  
  struct qdio_output_q {
* Unmerged path drivers/s390/cio/qdio.h
diff --git a/drivers/s390/cio/qdio_main.c b/drivers/s390/cio/qdio_main.c
index 4b383467eab1..1ff9d789eafe 100644
--- a/drivers/s390/cio/qdio_main.c
+++ b/drivers/s390/cio/qdio_main.c
@@ -510,14 +510,7 @@ static int get_inbound_buffer_frontier(struct qdio_q *q, unsigned int start)
 
 static int qdio_inbound_q_moved(struct qdio_q *q, unsigned int start)
 {
-	int count;
-
-	count = get_inbound_buffer_frontier(q, start);
-
-	if (count && !is_thinint_irq(q->irq_ptr) && MACHINE_IS_LPAR)
-		q->u.in.timestamp = get_tod_clock();
-
-	return count;
+	return get_inbound_buffer_frontier(q, start);
 }
 
 static inline int qdio_inbound_q_done(struct qdio_q *q, unsigned int start)
@@ -535,22 +528,7 @@ static inline int qdio_inbound_q_done(struct qdio_q *q, unsigned int start)
 		/* more work coming */
 		return 0;
 
-	if (is_thinint_irq(q->irq_ptr))
-		return 1;
-
-	/* don't poll under z/VM */
-	if (MACHINE_IS_VM)
-		return 1;
-
-	/*
-	 * At this point we know, that inbound first_to_check
-	 * has (probably) not moved (see qdio_inbound_processing).
-	 */
-	if (get_tod_clock_fast() > q->u.in.timestamp + QDIO_INPUT_THRESHOLD) {
-		DBF_DEV_EVENT(DBF_INFO, q->irq_ptr, "in done:%02x", start);
-		return 1;
-	} else
-		return 0;
+	return 1;
 }
 
 static inline void qdio_handle_aobs(struct qdio_q *q, int start, int count)
