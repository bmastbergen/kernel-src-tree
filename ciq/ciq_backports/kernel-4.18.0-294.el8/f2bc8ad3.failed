net: ethtool: Allow PHY cable test TDR data to configured

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andrew Lunn <andrew@lunn.ch>
commit f2bc8ad31a7f814237bc6301d59296d76505a688
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f2bc8ad3.failed

Allow the user to configure where on the cable the TDR data should be
retrieved, in terms of first and last sample, and the step between
samples. Also add the ability to ask for TDR data for just one pair.

If this configuration is not provided, it defaults to 1-150m at 1m
intervals for all pairs.

	Signed-off-by: Andrew Lunn <andrew@lunn.ch>

v3:
Move the TDR configuration into a structure
Add a range check on step
Use NL_SET_ERR_MSG_ATTR() when appropriate
Move TDR configuration into a nest
Document attributes in the request

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f2bc8ad31a7f814237bc6301d59296d76505a688)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/ethtool-netlink.rst
#	drivers/net/phy/phy.c
#	include/linux/phy.h
#	include/uapi/linux/ethtool_netlink.h
#	net/ethtool/cabletest.c
diff --cc drivers/net/phy/phy.c
index bcf0682c8b7f,1de3938628f4..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -530,6 -552,70 +530,73 @@@ out
  }
  EXPORT_SYMBOL(phy_start_cable_test);
  
++<<<<<<< HEAD
++=======
+ int phy_start_cable_test_tdr(struct phy_device *phydev,
+ 			     struct netlink_ext_ack *extack,
+ 			     const struct phy_tdr_config *config)
+ {
+ 	struct net_device *dev = phydev->attached_dev;
+ 	int err = -ENOMEM;
+ 
+ 	if (!(phydev->drv &&
+ 	      phydev->drv->cable_test_tdr_start &&
+ 	      phydev->drv->cable_test_get_status)) {
+ 		NL_SET_ERR_MSG(extack,
+ 			       "PHY driver does not support cable test TDR");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	mutex_lock(&phydev->lock);
+ 	if (phydev->state == PHY_CABLETEST) {
+ 		NL_SET_ERR_MSG(extack,
+ 			       "PHY already performing a test");
+ 		err = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	if (phydev->state < PHY_UP ||
+ 	    phydev->state > PHY_CABLETEST) {
+ 		NL_SET_ERR_MSG(extack,
+ 			       "PHY not configured. Try setting interface up");
+ 		err = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	err = ethnl_cable_test_alloc(phydev, ETHTOOL_MSG_CABLE_TEST_TDR_NTF);
+ 	if (err)
+ 		goto out;
+ 
+ 	/* Mark the carrier down until the test is complete */
+ 	phy_link_down(phydev);
+ 
+ 	netif_testing_on(dev);
+ 	err = phydev->drv->cable_test_tdr_start(phydev, config);
+ 	if (err) {
+ 		netif_testing_off(dev);
+ 		phy_link_up(phydev);
+ 		goto out_free;
+ 	}
+ 
+ 	phydev->state = PHY_CABLETEST;
+ 
+ 	if (phy_polling_mode(phydev))
+ 		phy_trigger_machine(phydev);
+ 
+ 	mutex_unlock(&phydev->lock);
+ 
+ 	return 0;
+ 
+ out_free:
+ 	ethnl_cable_test_free(phydev);
+ out:
+ 	mutex_unlock(&phydev->lock);
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL(phy_start_cable_test_tdr);
+ 
++>>>>>>> f2bc8ad31a7f (net: ethtool: Allow PHY cable test TDR data to configured)
  static int phy_config_aneg(struct phy_device *phydev)
  {
  	if (phydev->drv->config_aneg)
diff --cc include/linux/phy.h
index 2350f3f655e9,8c05d0fb5c00..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -711,6 -711,11 +723,14 @@@ struct phy_driver 
  
  	/* Start a cable test */
  	int (*cable_test_start)(struct phy_device *dev);
++<<<<<<< HEAD
++=======
+ 
+ 	/* Start a raw TDR cable test */
+ 	int (*cable_test_tdr_start)(struct phy_device *dev,
+ 				    const struct phy_tdr_config *config);
+ 
++>>>>>>> f2bc8ad31a7f (net: ethtool: Allow PHY cable test TDR data to configured)
  	/* Once per second, or on interrupt, request the status of the
  	 * test.
  	 */
@@@ -1257,6 -1268,9 +1277,12 @@@ int phy_reset_after_clk_enable(struct p
  #if IS_ENABLED(CONFIG_PHYLIB)
  int phy_start_cable_test(struct phy_device *phydev,
  			 struct netlink_ext_ack *extack);
++<<<<<<< HEAD
++=======
+ int phy_start_cable_test_tdr(struct phy_device *phydev,
+ 			     struct netlink_ext_ack *extack,
+ 			     const struct phy_tdr_config *config);
++>>>>>>> f2bc8ad31a7f (net: ethtool: Allow PHY cable test TDR data to configured)
  #else
  static inline
  int phy_start_cable_test(struct phy_device *phydev,
@@@ -1265,8 -1279,20 +1291,19 @@@
  	NL_SET_ERR_MSG(extack, "Kernel not compiled with PHYLIB support");
  	return -EOPNOTSUPP;
  }
++<<<<<<< HEAD
++=======
+ static inline
+ int phy_start_cable_test_tdr(struct phy_device *phydev,
+ 			     struct netlink_ext_ack *extack,
+ 			     const struct phy_tdr_config *config)
+ {
+ 	NL_SET_ERR_MSG(extack, "Kernel not compiled with PHYLIB support");
+ 	return -EOPNOTSUPP;
+ }
++>>>>>>> f2bc8ad31a7f (net: ethtool: Allow PHY cable test TDR data to configured)
  #endif
  
 -int phy_cable_test_result(struct phy_device *phydev, u8 pair, u16 result);
 -int phy_cable_test_fault_length(struct phy_device *phydev, u8 pair,
 -				u16 cm);
 -
  static inline void phy_device_reset(struct phy_device *phydev, int value)
  {
  	mdio_device_reset(&phydev->mdio, value);
* Unmerged path Documentation/networking/ethtool-netlink.rst
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/cabletest.c
* Unmerged path Documentation/networking/ethtool-netlink.rst
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index e597bee2e966..335e51d6f138 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -198,6 +198,7 @@
 #define MII_VCT5_CTRL_PEEK_HYST_DEFAULT			3
 
 #define MII_VCT5_SAMPLE_POINT_DISTANCE		0x18
+#define MII_VCT5_SAMPLE_POINT_DISTANCE_MAX	511
 #define MII_VCT5_TX_PULSE_CTRL			0x1c
 #define MII_VCT5_TX_PULSE_CTRL_DONT_WAIT_LINK_DOWN	BIT(12)
 #define MII_VCT5_TX_PULSE_CTRL_PULSE_WIDTH_128nS	(0x0 << 10)
@@ -270,6 +271,10 @@ struct marvell_priv {
 	char *hwmon_name;
 	struct device *hwmon_dev;
 	bool cable_test_tdr;
+	u32 first;
+	u32 last;
+	u32 step;
+	s8 pair;
 };
 
 static int marvell_read_page(struct phy_device *phydev)
@@ -1787,12 +1792,18 @@ static u32 marvell_vct5_distance2cm(int distance)
 	return distance * 805 / 10;
 }
 
+static u32 marvell_vct5_cm2distance(int cm)
+{
+	return cm * 10 / 805;
+}
+
 static int marvell_vct5_amplitude_distance(struct phy_device *phydev,
-					   int distance)
+					   int distance, int pair)
 {
-	int mV_pair0, mV_pair1, mV_pair2, mV_pair3;
 	u16 reg;
 	int err;
+	int mV;
+	int i;
 
 	err = phy_write_paged(phydev, MII_MARVELL_VCT5_PAGE,
 			      MII_VCT5_SAMPLE_POINT_DISTANCE,
@@ -1814,21 +1825,20 @@ static int marvell_vct5_amplitude_distance(struct phy_device *phydev,
 	if (err)
 		return err;
 
-	mV_pair0 = marvell_vct5_amplitude(phydev, 0);
-	mV_pair1 = marvell_vct5_amplitude(phydev, 1);
-	mV_pair2 = marvell_vct5_amplitude(phydev, 2);
-	mV_pair3 = marvell_vct5_amplitude(phydev, 3);
+	for (i = 0; i < 4; i++) {
+		if (pair != PHY_PAIR_ALL && i != pair)
+			continue;
 
-	ethnl_cable_test_amplitude(phydev, ETHTOOL_A_CABLE_PAIR_A, mV_pair0);
-	ethnl_cable_test_amplitude(phydev, ETHTOOL_A_CABLE_PAIR_B, mV_pair1);
-	ethnl_cable_test_amplitude(phydev, ETHTOOL_A_CABLE_PAIR_C, mV_pair2);
-	ethnl_cable_test_amplitude(phydev, ETHTOOL_A_CABLE_PAIR_D, mV_pair3);
+		mV = marvell_vct5_amplitude(phydev, i);
+		ethnl_cable_test_amplitude(phydev, i, mV);
+	}
 
 	return 0;
 }
 
 static int marvell_vct5_amplitude_graph(struct phy_device *phydev)
 {
+	struct marvell_priv *priv = phydev->priv;
 	int distance;
 	int err;
 	u16 reg;
@@ -1843,8 +1853,11 @@ static int marvell_vct5_amplitude_graph(struct phy_device *phydev)
 	if (err)
 		return err;
 
-	for (distance = 0; distance <= 100; distance++) {
-		err = marvell_vct5_amplitude_distance(phydev, distance);
+	for (distance = priv->first;
+	     distance <= priv->last;
+	     distance += priv->step) {
+		err = marvell_vct5_amplitude_distance(phydev, distance,
+						      priv->pair);
 		if (err)
 			return err;
 	}
@@ -1918,11 +1931,24 @@ static int marvell_vct7_cable_test_start(struct phy_device *phydev)
 			       MII_VCT7_CTRL_CENTIMETERS);
 }
 
-static int marvell_vct5_cable_test_tdr_start(struct phy_device *phydev)
+static int marvell_vct5_cable_test_tdr_start(struct phy_device *phydev,
+					     const struct phy_tdr_config *cfg)
 {
 	struct marvell_priv *priv = phydev->priv;
 	int ret;
 
+	priv->cable_test_tdr = true;
+	priv->first = marvell_vct5_cm2distance(cfg->first);
+	priv->last = marvell_vct5_cm2distance(cfg->last);
+	priv->step = marvell_vct5_cm2distance(cfg->step);
+	priv->pair = cfg->pair;
+
+	if (priv->first > MII_VCT5_SAMPLE_POINT_DISTANCE_MAX)
+		return -EINVAL;
+
+	if (priv->last > MII_VCT5_SAMPLE_POINT_DISTANCE_MAX)
+		return -EINVAL;
+
 	/* Disable  VCT7 */
 	ret = phy_write_paged(phydev, MII_MARVELL_VCT7_PAGE,
 			      MII_VCT7_CTRL, 0);
@@ -1933,15 +1959,14 @@ static int marvell_vct5_cable_test_tdr_start(struct phy_device *phydev)
 	if (ret)
 		return ret;
 
-	priv->cable_test_tdr = true;
 	ret = ethnl_cable_test_pulse(phydev, 1000);
 	if (ret)
 		return ret;
 
 	return ethnl_cable_test_step(phydev,
-				     marvell_vct5_distance2cm(0),
-				     marvell_vct5_distance2cm(100),
-				     marvell_vct5_distance2cm(1));
+				     marvell_vct5_distance2cm(priv->first),
+				     marvell_vct5_distance2cm(priv->last),
+				     marvell_vct5_distance2cm(priv->step));
 }
 
 static int marvell_vct7_distance_to_length(int distance, bool meter)
* Unmerged path drivers/net/phy/phy.c
* Unmerged path include/linux/phy.h
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path net/ethtool/cabletest.c
