scsi: zfcp: fix wrong data and display format of SFP+ temperature

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Benjamin Block <bblock@linux.ibm.com>
commit a3fd4bfe85fbb67cf4ec1232d0af625ece3c508b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a3fd4bfe.failed

When implementing support for retrieval of local diagnostic data from the
FCP channel, the wrong data format was assumed for the temperature of the
local SFP+ connector. The Fibre Channel Link Services (FC-LS-3)
specification is not clear on the format of the stored integer, and only
after consulting the SNIA specification SFF-8472 did we realize it is
stored as two's complement. Thus, the used data and display format is
wrong, and highly misleading for users when the temperature should drop
below 0Â°C (however unlikely that may be).

To fix this, change the data format in `struct fsf_qtcb_bottom_port` from
unsigned to signed, and change the printf format string used to generate
`zfcp_sysfs_adapter_diag_sfp_temperature_show()` from `%hu` to `%hd`.

Link: https://lore.kernel.org/r/d6e3be5428da5c9490cfff4df7cae868bc9f1a7e.1582039501.git.bblock@linux.ibm.com
Fixes: a10a61e807b0 ("scsi: zfcp: support retrieval of SFP Data via Exchange Port Data")
Fixes: 6028f7c4cd87 ("scsi: zfcp: introduce sysfs interface for diagnostics of local SFP transceiver")
	Cc: <stable@vger.kernel.org> # 5.5+
	Reviewed-by: Jens Remus <jremus@linux.ibm.com>
	Reviewed-by: Fedor Loshakov <loshakov@linux.ibm.com>
	Reviewed-by: Steffen Maier <maier@linux.ibm.com>
	Signed-off-by: Benjamin Block <bblock@linux.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a3fd4bfe85fbb67cf4ec1232d0af625ece3c508b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/scsi/zfcp_fsf.h
#	drivers/s390/scsi/zfcp_sysfs.c
diff --cc drivers/s390/scsi/zfcp_fsf.h
index e027b2bd9a85,4bfb79f20588..000000000000
--- a/drivers/s390/scsi/zfcp_fsf.h
+++ b/drivers/s390/scsi/zfcp_fsf.h
@@@ -424,9 -410,23 +424,29 @@@ struct fsf_qtcb_bottom_port 
  	u8 cb_util;
  	u8 a_util;
  	u8 res2;
++<<<<<<< HEAD
 +	u8 res3[12];
 +	u32 fc_security_algorithms;
 +	u8 res4[236];
++=======
+ 	s16 temperature;
+ 	u16 vcc;
+ 	u16 tx_bias;
+ 	u16 tx_power;
+ 	u16 rx_power;
+ 	union {
+ 		u16 raw;
+ 		struct {
+ 			u16 fec_active		:1;
+ 			u16:7;
+ 			u16 connector_type	:2;
+ 			u16 sfp_invalid		:1;
+ 			u16 optical_port	:1;
+ 			u16 port_tx_type	:4;
+ 		};
+ 	} sfp_flags;
+ 	u8 res3[240];
++>>>>>>> a3fd4bfe85fb (scsi: zfcp: fix wrong data and display format of SFP+ temperature)
  } __attribute__ ((packed));
  
  union fsf_qtcb_bottom {
diff --cc drivers/s390/scsi/zfcp_sysfs.c
index 432e4f59b575,a711a0d15100..000000000000
--- a/drivers/s390/scsi/zfcp_sysfs.c
+++ b/drivers/s390/scsi/zfcp_sysfs.c
@@@ -744,3 -710,123 +744,126 @@@ struct device_attribute *zfcp_sysfs_sho
  	&dev_attr_queue_full,
  	NULL
  };
++<<<<<<< HEAD
++=======
+ 
+ static ssize_t zfcp_sysfs_adapter_diag_b2b_credit_show(
+ 	struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));
+ 	struct zfcp_diag_header *diag_hdr;
+ 	struct fc_els_flogi *nsp;
+ 	ssize_t rc = -ENOLINK;
+ 	unsigned long flags;
+ 	unsigned int status;
+ 
+ 	if (!adapter)
+ 		return -ENODEV;
+ 
+ 	status = atomic_read(&adapter->status);
+ 	if (0 == (status & ZFCP_STATUS_COMMON_OPEN) ||
+ 	    0 == (status & ZFCP_STATUS_COMMON_UNBLOCKED) ||
+ 	    0 != (status & ZFCP_STATUS_COMMON_ERP_FAILED))
+ 		goto out;
+ 
+ 	diag_hdr = &adapter->diagnostics->config_data.header;
+ 
+ 	rc = zfcp_diag_update_buffer_limited(
+ 		adapter, diag_hdr, zfcp_diag_update_config_data_buffer);
+ 	if (rc != 0)
+ 		goto out;
+ 
+ 	spin_lock_irqsave(&diag_hdr->access_lock, flags);
+ 	/* nport_serv_param doesn't contain the ELS_Command code */
+ 	nsp = (struct fc_els_flogi *)((unsigned long)
+ 					      adapter->diagnostics->config_data
+ 						      .data.nport_serv_param -
+ 				      sizeof(u32));
+ 
+ 	rc = scnprintf(buf, 5 + 2, "%hu\n",
+ 		       be16_to_cpu(nsp->fl_csp.sp_bb_cred));
+ 	spin_unlock_irqrestore(&diag_hdr->access_lock, flags);
+ 
+ out:
+ 	zfcp_ccw_adapter_put(adapter);
+ 	return rc;
+ }
+ static ZFCP_DEV_ATTR(adapter_diag, b2b_credit, 0400,
+ 		     zfcp_sysfs_adapter_diag_b2b_credit_show, NULL);
+ 
+ #define ZFCP_DEFINE_DIAG_SFP_ATTR(_name, _qtcb_member, _prtsize, _prtfmt)      \
+ 	static ssize_t zfcp_sysfs_adapter_diag_sfp_##_name##_show(	       \
+ 		struct device *dev, struct device_attribute *attr, char *buf)  \
+ 	{								       \
+ 		struct zfcp_adapter *const adapter =			       \
+ 			zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));	       \
+ 		struct zfcp_diag_header *diag_hdr;			       \
+ 		ssize_t rc = -ENOLINK;					       \
+ 		unsigned long flags;					       \
+ 		unsigned int status;					       \
+ 									       \
+ 		if (!adapter)						       \
+ 			return -ENODEV;					       \
+ 									       \
+ 		status = atomic_read(&adapter->status);			       \
+ 		if (0 == (status & ZFCP_STATUS_COMMON_OPEN) ||		       \
+ 		    0 == (status & ZFCP_STATUS_COMMON_UNBLOCKED) ||	       \
+ 		    0 != (status & ZFCP_STATUS_COMMON_ERP_FAILED))	       \
+ 			goto out;					       \
+ 									       \
+ 		if (!zfcp_diag_support_sfp(adapter)) {			       \
+ 			rc = -EOPNOTSUPP;				       \
+ 			goto out;					       \
+ 		}							       \
+ 									       \
+ 		diag_hdr = &adapter->diagnostics->port_data.header;	       \
+ 									       \
+ 		rc = zfcp_diag_update_buffer_limited(			       \
+ 			adapter, diag_hdr, zfcp_diag_update_port_data_buffer); \
+ 		if (rc != 0)						       \
+ 			goto out;					       \
+ 									       \
+ 		spin_lock_irqsave(&diag_hdr->access_lock, flags);	       \
+ 		rc = scnprintf(						       \
+ 			buf, (_prtsize) + 2, _prtfmt "\n",		       \
+ 			adapter->diagnostics->port_data.data._qtcb_member);    \
+ 		spin_unlock_irqrestore(&diag_hdr->access_lock, flags);	       \
+ 									       \
+ 	out:								       \
+ 		zfcp_ccw_adapter_put(adapter);				       \
+ 		return rc;						       \
+ 	}								       \
+ 	static ZFCP_DEV_ATTR(adapter_diag_sfp, _name, 0400,		       \
+ 			     zfcp_sysfs_adapter_diag_sfp_##_name##_show, NULL)
+ 
+ ZFCP_DEFINE_DIAG_SFP_ATTR(temperature, temperature, 6, "%hd");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(vcc, vcc, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(tx_bias, tx_bias, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(tx_power, tx_power, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(rx_power, rx_power, 5, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(port_tx_type, sfp_flags.port_tx_type, 2, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(optical_port, sfp_flags.optical_port, 1, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(sfp_invalid, sfp_flags.sfp_invalid, 1, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(connector_type, sfp_flags.connector_type, 1, "%hu");
+ ZFCP_DEFINE_DIAG_SFP_ATTR(fec_active, sfp_flags.fec_active, 1, "%hu");
+ 
+ static struct attribute *zfcp_sysfs_diag_attrs[] = {
+ 	&dev_attr_adapter_diag_sfp_temperature.attr,
+ 	&dev_attr_adapter_diag_sfp_vcc.attr,
+ 	&dev_attr_adapter_diag_sfp_tx_bias.attr,
+ 	&dev_attr_adapter_diag_sfp_tx_power.attr,
+ 	&dev_attr_adapter_diag_sfp_rx_power.attr,
+ 	&dev_attr_adapter_diag_sfp_port_tx_type.attr,
+ 	&dev_attr_adapter_diag_sfp_optical_port.attr,
+ 	&dev_attr_adapter_diag_sfp_sfp_invalid.attr,
+ 	&dev_attr_adapter_diag_sfp_connector_type.attr,
+ 	&dev_attr_adapter_diag_sfp_fec_active.attr,
+ 	&dev_attr_adapter_diag_b2b_credit.attr,
+ 	NULL,
+ };
+ 
+ const struct attribute_group zfcp_sysfs_diag_attr_group = {
+ 	.name = "diagnostics",
+ 	.attrs = zfcp_sysfs_diag_attrs,
+ };
++>>>>>>> a3fd4bfe85fb (scsi: zfcp: fix wrong data and display format of SFP+ temperature)
* Unmerged path drivers/s390/scsi/zfcp_fsf.h
* Unmerged path drivers/s390/scsi/zfcp_sysfs.c
