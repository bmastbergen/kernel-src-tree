scsi: core: add scsi_host_busy_iter()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Hannes Reinecke <hare@suse.de>
commit dcece99e86b1191d2789fb5b5caa4c5b7fc2bfef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dcece99e.failed

Add an iterator scsi_host_busy_iter() to traverse all busy commands.  If
locking against concurrent command completions is required, it has to be
provided by the caller.

Link: https://lore.kernel.org/r/20200228075318.91255-11-hare@suse.de
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit dcece99e86b1191d2789fb5b5caa4c5b7fc2bfef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hosts.c
diff --cc drivers/scsi/hosts.c
index bd989d33dffb,7ec91c3a66ca..000000000000
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@@ -643,3 -650,68 +643,71 @@@ void scsi_flush_work(struct Scsi_Host *
  	flush_workqueue(shost->work_q);
  }
  EXPORT_SYMBOL_GPL(scsi_flush_work);
++<<<<<<< HEAD
++=======
+ 
+ static bool complete_all_cmds_iter(struct request *rq, void *data, bool rsvd)
+ {
+ 	struct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);
+ 	int status = *(int *)data;
+ 
+ 	scsi_dma_unmap(scmd);
+ 	scmd->result = status << 16;
+ 	scmd->scsi_done(scmd);
+ 	return true;
+ }
+ 
+ /**
+  * scsi_host_complete_all_commands - Terminate all running commands
+  * @shost:	Scsi Host on which commands should be terminated
+  * @status:	Status to be set for the terminated commands
+  *
+  * There is no protection against modification of the number
+  * of outstanding commands. It is the responsibility of the
+  * caller to ensure that concurrent I/O submission and/or
+  * completion is stopped when calling this function.
+  */
+ void scsi_host_complete_all_commands(struct Scsi_Host *shost, int status)
+ {
+ 	blk_mq_tagset_busy_iter(&shost->tag_set, complete_all_cmds_iter,
+ 				&status);
+ }
+ EXPORT_SYMBOL_GPL(scsi_host_complete_all_commands);
+ 
+ struct scsi_host_busy_iter_data {
+ 	bool (*fn)(struct scsi_cmnd *, void *, bool);
+ 	void *priv;
+ };
+ 
+ static bool __scsi_host_busy_iter_fn(struct request *req, void *priv,
+ 				   bool reserved)
+ {
+ 	struct scsi_host_busy_iter_data *iter_data = priv;
+ 	struct scsi_cmnd *sc = blk_mq_rq_to_pdu(req);
+ 
+ 	return iter_data->fn(sc, iter_data->priv, reserved);
+ }
+ 
+ /**
+  * scsi_host_busy_iter - Iterate over all busy commands
+  * @shost:	Pointer to Scsi_Host.
+  * @fn:		Function to call on each busy command
+  * @priv:	Data pointer passed to @fn
+  *
+  * If locking against concurrent command completions is required
+  * ithas to be provided by the caller
+  **/
+ void scsi_host_busy_iter(struct Scsi_Host *shost,
+ 			 bool (*fn)(struct scsi_cmnd *, void *, bool),
+ 			 void *priv)
+ {
+ 	struct scsi_host_busy_iter_data iter_data = {
+ 		.fn = fn,
+ 		.priv = priv,
+ 	};
+ 
+ 	blk_mq_tagset_busy_iter(&shost->tag_set, __scsi_host_busy_iter_fn,
+ 				&iter_data);
+ }
+ EXPORT_SYMBOL_GPL(scsi_host_busy_iter);
++>>>>>>> dcece99e86b1 (scsi: core: add scsi_host_busy_iter())
* Unmerged path drivers/scsi/hosts.c
diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 8640ca5ba7bb..11abae039664 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -805,6 +805,9 @@ extern void scsi_block_requests(struct Scsi_Host *);
 extern int scsi_host_block(struct Scsi_Host *shost);
 extern int scsi_host_unblock(struct Scsi_Host *shost, int new_state);
 
+void scsi_host_busy_iter(struct Scsi_Host *,
+			 bool (*fn)(struct scsi_cmnd *, void *, bool), void *priv);
+
 struct class_container;
 
 /*
