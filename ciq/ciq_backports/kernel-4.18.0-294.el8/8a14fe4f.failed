kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jim Mattson <jmattson@google.com>
commit 8a14fe4f0c54f27c89389d13c4a1e467a88c35ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8a14fe4f.failed

Both the vcpu_vmx structure and the vcpu_svm structure have a
'last_cpu' field. Move the common field into the kvm_vcpu_arch
structure. For clarity, rename it to 'last_vmentry_cpu.'

	Suggested-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Jim Mattson <jmattson@google.com>
	Reviewed-by: Oliver Upton <oupton@google.com>
	Reviewed-by: Peter Shier <pshier@google.com>
Message-Id: <20200603235623.245638-6-jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8a14fe4f0c54f27c89389d13c4a1e467a88c35ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/svm/svm.c
index 733f139091ec,c55ebf76ec6d..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -2950,6 -2947,7 +2950,10 @@@ static int handle_exit(struct kvm_vcpu 
  		kvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;
  		kvm_run->fail_entry.hardware_entry_failure_reason
  			= svm->vmcb->control.exit_code;
++<<<<<<< HEAD
++=======
+ 		kvm_run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;
++>>>>>>> 8a14fe4f0c54 (kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu)
  		dump_vmcb(vcpu);
  		return 0;
  	}
@@@ -2973,8 -2971,9 +2977,12 @@@
  		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
  		vcpu->run->internal.suberror =
  			KVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;
 -		vcpu->run->internal.ndata = 2;
 +		vcpu->run->internal.ndata = 1;
  		vcpu->run->internal.data[0] = exit_code;
++<<<<<<< HEAD
++=======
+ 		vcpu->run->internal.data[1] = vcpu->arch.last_vmentry_cpu;
++>>>>>>> 8a14fe4f0c54 (kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu)
  		return 0;
  	}
  
@@@ -3399,14 -3398,7 +3407,18 @@@ static fastpath_t svm_vcpu_run(struct k
  	 */
  	x86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);
  
++<<<<<<< HEAD
 +	/*
 +	 * Tell context tracking that this CPU is about to enter guest
 +	 * mode. This has to be after x86_spec_ctrl_set_guest() because
 +	 * that can take locks (lockdep needs RCU) and calls into world and
 +	 * some more.
 +	 */
 +	guest_enter_irqoff();
 +
++=======
+ 	vcpu->arch.last_vmentry_cpu = vcpu->cpu;
++>>>>>>> 8a14fe4f0c54 (kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu)
  	__svm_vcpu_run(svm->vmcb_pa, (unsigned long *)&svm->vcpu.arch.regs);
  
  #ifdef CONFIG_X86_64
diff --cc arch/x86/kvm/vmx/vmx.c
index 916d18c00f08,d9ee31b0679b..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -4785,6 -4785,7 +4785,10 @@@ static int handle_exception_nmi(struct 
  		vcpu->run->internal.data[0] = vect_info;
  		vcpu->run->internal.data[1] = intr_info;
  		vcpu->run->internal.data[2] = error_code;
++<<<<<<< HEAD
++=======
+ 		vcpu->run->internal.data[3] = vcpu->arch.last_vmentry_cpu;
++>>>>>>> 8a14fe4f0c54 (kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu)
  		return 0;
  	}
  
@@@ -6006,6 -6007,7 +6010,10 @@@ static int vmx_handle_exit(struct kvm_v
  		vcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;
  		vcpu->run->fail_entry.hardware_entry_failure_reason
  			= exit_reason;
++<<<<<<< HEAD
++=======
+ 		vcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;
++>>>>>>> 8a14fe4f0c54 (kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu)
  		return 0;
  	}
  
@@@ -6014,6 -6016,7 +6022,10 @@@
  		vcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;
  		vcpu->run->fail_entry.hardware_entry_failure_reason
  			= vmcs_read32(VM_INSTRUCTION_ERROR);
++<<<<<<< HEAD
++=======
+ 		vcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;
++>>>>>>> 8a14fe4f0c54 (kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu)
  		return 0;
  	}
  
@@@ -6040,6 -6043,8 +6052,11 @@@
  			vcpu->run->internal.data[3] =
  				vmcs_read64(GUEST_PHYSICAL_ADDRESS);
  		}
++<<<<<<< HEAD
++=======
+ 		vcpu->run->internal.data[vcpu->run->internal.ndata++] =
+ 			vcpu->arch.last_vmentry_cpu;
++>>>>>>> 8a14fe4f0c54 (kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu)
  		return 0;
  	}
  
@@@ -6095,8 -6100,9 +6112,12 @@@ unexpected_vmexit
  	vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
  	vcpu->run->internal.suberror =
  			KVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;
 -	vcpu->run->internal.ndata = 2;
 +	vcpu->run->internal.ndata = 1;
  	vcpu->run->internal.data[0] = exit_reason;
++<<<<<<< HEAD
++=======
+ 	vcpu->run->internal.data[1] = vcpu->arch.last_vmentry_cpu;
++>>>>>>> 8a14fe4f0c54 (kvm: x86: Move last_cpu into kvm_vcpu_arch as last_vmentry_cpu)
  	return 0;
  }
  
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 29ebbe07ff61..6fc21a451ef4 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -826,6 +826,9 @@ struct kvm_vcpu_arch {
 	/* Flush the L1 Data cache for L1TF mitigation on VMENTER */
 	bool l1tf_flush_l1d;
 
+	/* Host CPU on which VM-entry was most recently attempted */
+	unsigned int last_vmentry_cpu;
+
 	/* AMD MSRC001_0015 Hardware Configuration */
 	u64 msr_hwcr;
 };
diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.c
index 9693db1af57c..3fa39d03335d 100644
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@ -1185,7 +1185,7 @@ void pre_sev_run(struct vcpu_svm *svm, int cpu)
 	 * 2) or this VMCB was executed on different host CPU in previous VMRUNs.
 	 */
 	if (sd->sev_vmcbs[asid] == svm->vmcb &&
-	    svm->last_cpu == cpu)
+	    svm->vcpu.arch.last_vmentry_cpu == cpu)
 		return;
 
 	svm->last_cpu = cpu;
* Unmerged path arch/x86/kvm/svm/svm.c
diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.h
index f98649af11d1..021bee6d4129 100644
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@ -158,9 +158,6 @@ struct vcpu_svm {
 	 */
 	struct list_head ir_list;
 	spinlock_t ir_list_lock;
-
-	/* which host CPU was used for running this vcpu */
-	unsigned int last_cpu;
 };
 
 struct svm_cpu_data {
* Unmerged path arch/x86/kvm/vmx/vmx.c
diff --git a/arch/x86/kvm/vmx/vmx.h b/arch/x86/kvm/vmx/vmx.h
index f8f9e214d285..639798e4a6ca 100644
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@ -300,9 +300,6 @@ struct vcpu_vmx {
 	u64 ept_pointer;
 
 	struct pt_desc pt_desc;
-
-	/* which host CPU was used for running this vcpu */
-	unsigned int last_cpu;
 };
 
 enum ept_pointers_status {
