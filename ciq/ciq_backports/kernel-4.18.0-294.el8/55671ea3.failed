cpufreq: intel_pstate: Free memory only when turning off

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 55671ea3257ac596abd817c4031a996b2867e586
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/55671ea3.failed

When intel_pstate switches the operation mode from "active" to
"passive" or the other way around, freeing its data structures
representing CPUs and allocating them again from scratch is not
necessary and wasteful.  Moreover, if these data structures are
preserved, the cached HWP Request MSR value from there may be
written to the MSR to start with to reinitialize it and help to
restore the EPP value set previously (it is set to 0xFF when CPUs
go offline to allow their SMT siblings to use the full range of
EPP values and that also happens when the driver gets unregistered).

Accordingly, modify the driver to only do a full cleanup on driver
object registration errors and when its status is changed to "off"
via sysfs and to write the cached HWP Request MSR value back to
the MSR on CPU init if the data structure representing the given
CPU is still there.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
(cherry picked from commit 55671ea3257ac596abd817c4031a996b2867e586)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 46665cfef5ca,c92c085fc495..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -2050,24 -2116,30 +2050,50 @@@ static int intel_pstate_init_cpu(unsign
  
  		all_cpu_data[cpunum] = cpu;
  
+ 		cpu->cpu = cpunum;
+ 
  		cpu->epp_default = -EINVAL;
++<<<<<<< HEAD
 +		cpu->epp_powersave = -EINVAL;
 +		cpu->epp_saved = -EINVAL;
 +	}
 +
 +	cpu = all_cpu_data[cpunum];
 +
 +	cpu->cpu = cpunum;
 +
 +	if (hwp_active) {
 +		const struct x86_cpu_id *id;
 +
 +		intel_pstate_hwp_enable(cpu);
 +
 +		id = x86_match_cpu(intel_pstate_hwp_boost_ids);
 +		if (id && intel_pstate_acpi_pm_profile_server())
 +			hwp_boost = true;
 +	}
++=======
+ 
+ 		if (hwp_active) {
+ 			const struct x86_cpu_id *id;
+ 
+ 			intel_pstate_hwp_enable(cpu);
+ 
+ 			id = x86_match_cpu(intel_pstate_hwp_boost_ids);
+ 			if (id && intel_pstate_acpi_pm_profile_server())
+ 				hwp_boost = true;
+ 		}
+ 	} else if (hwp_active) {
+ 		/*
+ 		 * Re-enable HWP in case this happens after a resume from ACPI
+ 		 * S3 if the CPU was offline during the whole system/resume
+ 		 * cycle.
+ 		 */
+ 		intel_pstate_hwp_reenable(cpu);
+ 	}
+ 
+ 	cpu->epp_powersave = -EINVAL;
+ 	cpu->epp_policy = 0;
++>>>>>>> 55671ea3257a (cpufreq: intel_pstate: Free memory only when turning off)
  
  	intel_pstate_get_cpu_pstates(cpu);
  
@@@ -2557,6 -2735,7 +2583,10 @@@ static void intel_pstate_driver_cleanup
  		}
  	}
  	put_online_cpus();
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 55671ea3257a (cpufreq: intel_pstate: Free memory only when turning off)
  	intel_pstate_driver = NULL;
  }
  
@@@ -2579,17 -2761,6 +2609,20 @@@ static int intel_pstate_register_driver
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int intel_pstate_unregister_driver(void)
 +{
 +	if (hwp_active)
 +		return -EBUSY;
 +
 +	cpufreq_unregister_driver(intel_pstate_driver);
 +	intel_pstate_driver_cleanup();
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 55671ea3257a (cpufreq: intel_pstate: Free memory only when turning off)
  static ssize_t intel_pstate_show_status(char *buf)
  {
  	if (!intel_pstate_driver)
* Unmerged path drivers/cpufreq/intel_pstate.c
