iommu/arm-smmu: Unregister IOMMU and bus ops on device removal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Will Deacon <will@kernel.org>
commit 7359572e1a5d4280ad87b969b0d30be43ef4989a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7359572e.failed

When removing the SMMU driver, we need to clear any state that we
registered during probe. This includes our bus ops, sysfs entries and
the IOMMU device registered for early firmware probing of masters.

	Signed-off-by: Will Deacon <will@kernel.org>
	Tested-by: John Garry <john.garry@huawei.com> # smmu v3
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 7359572e1a5d4280ad87b969b0d30be43ef4989a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/arm-smmu.c
diff --cc drivers/iommu/arm-smmu.c
index ab9a0239376c,1f0c09bf112a..000000000000
--- a/drivers/iommu/arm-smmu.c
+++ b/drivers/iommu/arm-smmu.c
@@@ -2241,9 -2029,31 +2249,34 @@@ static int arm_smmu_bus_init(struct iom
  #ifdef CONFIG_PCI
  	if (!iommu_present(&pci_bus_type)) {
  		pci_request_acs();
- 		bus_set_iommu(&pci_bus_type, &arm_smmu_ops);
+ 		err = bus_set_iommu(&pci_bus_type, ops);
+ 		if (err)
+ 			goto err_reset_amba_ops;
+ 	}
+ #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_FSL_MC_BUS
+ 	if (!iommu_present(&fsl_mc_bus_type)) {
+ 		err = bus_set_iommu(&fsl_mc_bus_type, ops);
+ 		if (err)
+ 			goto err_reset_pci_ops;
  	}
  #endif
+ 	return 0;
+ 
+ err_reset_pci_ops: __maybe_unused;
+ #ifdef CONFIG_PCI
+ 	bus_set_iommu(&pci_bus_type, NULL);
+ #endif
+ err_reset_amba_ops: __maybe_unused;
+ #ifdef CONFIG_ARM_AMBA
+ 	bus_set_iommu(&amba_bustype, NULL);
+ #endif
+ err_reset_platform_ops: __maybe_unused;
+ 	bus_set_iommu(&platform_bus_type, NULL);
+ 	return err;
++>>>>>>> 7359572e1a5d (iommu/arm-smmu: Unregister IOMMU and bus ops on device removal)
  }
  
  static int arm_smmu_device_probe(struct platform_device *pdev)
@@@ -2416,9 -2228,13 +2449,13 @@@ static void arm_smmu_device_shutdown(st
  	if (!bitmap_empty(smmu->context_map, ARM_SMMU_MAX_CBS))
  		dev_err(&pdev->dev, "removing device with active domains!\n");
  
+ 	arm_smmu_bus_init(NULL);
+ 	iommu_device_unregister(&smmu->iommu);
+ 	iommu_device_sysfs_remove(&smmu->iommu);
+ 
  	arm_smmu_rpm_get(smmu);
  	/* Turn the thing off */
 -	arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_sCR0, sCR0_CLIENTPD);
 +	writel(sCR0_CLIENTPD, ARM_SMMU_GR0_NS(smmu) + ARM_SMMU_GR0_sCR0);
  	arm_smmu_rpm_put(smmu);
  
  	if (pm_runtime_enabled(smmu->dev))
* Unmerged path drivers/iommu/arm-smmu.c
