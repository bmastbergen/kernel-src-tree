x86/ioapic: Handle Extended Destination ID field in RTE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] ioapic: Handle Extended Destination ID field in RTE (Vitaly Kuznetsov) [1903823]
Rebuild_FUZZ: 96.23%
commit-author David Woodhouse <dwmw@amazon.co.uk>
commit 51130d21881d435fad5fa7f25bea77aa0ffc9a4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/51130d21.failed

Bits 63-48 of the I/OAPIC Redirection Table Entry map directly to bits 19-4
of the address used in the resulting MSI cycle.

Historically, the x86 MSI format only used the top 8 of those 16 bits as
the destination APIC ID, and the "Extended Destination ID" in the lower 8
bits was unused.

With interrupt remapping, the lowest bit of the Extended Destination ID
(bit 48 of RTE, bit 4 of MSI address) is now used to indicate a remappable
format MSI.

A hypervisor can use the other 7 bits of the Extended Destination ID to
permit guests to address up to 15 bits of APIC IDs, thus allowing 32768
vCPUs before having to expose a vIOMMU and interrupt remapping to the
guest.

No behavioural change in this patch, since nothing yet permits APIC IDs
above 255 to be used with the non-IR I/OAPIC domain.

[ tglx: Converted it to the cleaned up entry/msi_msg format and added
  	commentry ]

	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20201024213535.443185-32-dwmw2@infradead.org

(cherry picked from commit 51130d21881d435fad5fa7f25bea77aa0ffc9a4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/io_apic.h
#	arch/x86/kernel/apic/io_apic.c
diff --cc arch/x86/include/asm/io_apic.h
index fd20a2334885,437aa8d00e53..000000000000
--- a/arch/x86/include/asm/io_apic.h
+++ b/arch/x86/include/asm/io_apic.h
@@@ -65,35 -56,35 +65,67 @@@ union IO_APIC_reg_03 
  };
  
  struct IO_APIC_route_entry {
++<<<<<<< HEAD
 +	__u32	vector		:  8,
 +		delivery_mode	:  3,	/* 000: FIXED
 +					 * 001: lowest prio
 +					 * 111: ExtINT
 +					 */
 +		dest_mode	:  1,	/* 0: physical, 1: logical */
 +		delivery_status	:  1,
 +		polarity	:  1,
 +		irr		:  1,
 +		trigger		:  1,	/* 0: edge, 1: level */
 +		mask		:  1,	/* 0: enabled, 1: disabled */
 +		__reserved_2	: 15;
 +
 +	__u32	__reserved_3	: 24,
 +		dest		:  8;
 +} __attribute__ ((packed));
 +
 +struct IR_IO_APIC_route_entry {
 +	__u64	vector		: 8,
 +		zero		: 3,
 +		index2		: 1,
 +		delivery_status : 1,
 +		polarity	: 1,
 +		irr		: 1,
 +		trigger		: 1,
 +		mask		: 1,
 +		reserved	: 31,
 +		format		: 1,
 +		index		: 15;
++=======
+ 	union {
+ 		struct {
+ 			u64	vector			:  8,
+ 				delivery_mode		:  3,
+ 				dest_mode_logical	:  1,
+ 				delivery_status		:  1,
+ 				active_low		:  1,
+ 				irr			:  1,
+ 				is_level		:  1,
+ 				masked			:  1,
+ 				reserved_0		: 15,
+ 				reserved_1		: 17,
+ 				virt_destid_8_14	:  7,
+ 				destid_0_7		:  8;
+ 		};
+ 		struct {
+ 			u64	ir_shared_0		:  8,
+ 				ir_zero			:  3,
+ 				ir_index_15		:  1,
+ 				ir_shared_1		:  5,
+ 				ir_reserved_0		: 31,
+ 				ir_format		:  1,
+ 				ir_index_0_14		: 15;
+ 		};
+ 		struct {
+ 			u64	w1			: 32,
+ 				w2			: 32;
+ 		};
+ 	};
++>>>>>>> 51130d21881d (x86/ioapic: Handle Extended Destination ID field in RTE)
  } __attribute__ ((packed));
  
  struct irq_alloc_info;
diff --cc arch/x86/kernel/apic/io_apic.c
index fbac72520919,1cfd65ef295b..000000000000
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@@ -1241,20 -1228,21 +1241,31 @@@ static void io_apic_print_entries(unsig
  		snprintf(buf, sizeof(buf),
  			 " pin%02x, %s, %s, %s, V(%02X), IRR(%1d), S(%1d)",
  			 i,
 -			 entry.masked ? "disabled" : "enabled ",
 -			 entry.is_level ? "level" : "edge ",
 -			 entry.active_low ? "low " : "high",
 +			 entry.mask == IOAPIC_MASKED ? "disabled" : "enabled ",
 +			 entry.trigger == IOAPIC_LEVEL ? "level" : "edge ",
 +			 entry.polarity == IOAPIC_POL_LOW ? "low " : "high",
  			 entry.vector, entry.irr, entry.delivery_status);
 -		if (entry.ir_format) {
 +		if (ir_entry->format)
  			printk(KERN_DEBUG "%s, remapped, I(%04X),  Z(%X)\n",
 +			       buf, (ir_entry->index2 << 15) | ir_entry->index,
 +			       ir_entry->zero);
 +		else
 +			printk(KERN_DEBUG "%s, %s, D(%02X), M(%1d)\n",
  			       buf,
++<<<<<<< HEAD
 +			       entry.dest_mode == IOAPIC_DEST_MODE_LOGICAL ?
 +			       "logical " : "physical",
 +			       entry.dest, entry.delivery_mode);
++=======
+ 			       (entry.ir_index_15 << 15) | entry.ir_index_0_14,
+ 				entry.ir_zero);
+ 		} else {
+ 			printk(KERN_DEBUG "%s, %s, D(%02X%02X), M(%1d)\n", buf,
+ 			       entry.dest_mode_logical ? "logical " : "physical",
+ 			       entry.virt_destid_8_14, entry.destid_0_7,
+ 			       entry.delivery_mode);
+ 		}
++>>>>>>> 51130d21881d (x86/ioapic: Handle Extended Destination ID field in RTE)
  	}
  }
  
@@@ -1422,14 -1410,16 +1433,20 @@@ void native_restore_boot_irq_mode(void
  	 */
  	if (ioapic_i8259.pin != -1) {
  		struct IO_APIC_route_entry entry;
+ 		u32 apic_id = read_apic_id();
  
  		memset(&entry, 0, sizeof(entry));
 -		entry.masked		= false;
 -		entry.is_level		= false;
 -		entry.active_low	= false;
 -		entry.dest_mode_logical	= false;
 +		entry.mask		= IOAPIC_UNMASKED;
 +		entry.trigger		= IOAPIC_EDGE;
 +		entry.polarity		= IOAPIC_POL_HIGH;
 +		entry.dest_mode		= IOAPIC_DEST_MODE_PHYSICAL;
  		entry.delivery_mode	= APIC_DELIVERY_MODE_EXTINT;
++<<<<<<< HEAD
 +		entry.dest		= read_apic_id();
++=======
+ 		entry.destid_0_7	= apic_id & 0xFF;
+ 		entry.virt_destid_8_14	= apic_id >> 8;
++>>>>>>> 51130d21881d (x86/ioapic: Handle Extended Destination ID field in RTE)
  
  		/*
  		 * Add it to the IO-APIC irq-routing table:
@@@ -1861,6 -1851,55 +1878,58 @@@ static void ioapic_ir_ack_level(struct 
  	eoi_ioapic_pin(data->entry.vector, data);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * The I/OAPIC is just a device for generating MSI messages from legacy
+  * interrupt pins. Various fields of the RTE translate into bits of the
+  * resulting MSI which had a historical meaning.
+  *
+  * With interrupt remapping, many of those bits have different meanings
+  * in the underlying MSI, but the way that the I/OAPIC transforms them
+  * from its RTE to the MSI message is the same. This function allows
+  * the parent IRQ domain to compose the MSI message, then takes the
+  * relevant bits to put them in the appropriate places in the RTE in
+  * order to generate that message when the IRQ happens.
+  *
+  * The setup here relies on a preconfigured route entry (is_level,
+  * active_low, masked) because the parent domain is merely composing the
+  * generic message routing information which is used for the MSI.
+  */
+ static void ioapic_setup_msg_from_msi(struct irq_data *irq_data,
+ 				      struct IO_APIC_route_entry *entry)
+ {
+ 	struct msi_msg msg;
+ 
+ 	/* Let the parent domain compose the MSI message */
+ 	irq_chip_compose_msi_msg(irq_data, &msg);
+ 
+ 	/*
+ 	 * - Real vector
+ 	 * - DMAR/IR: 8bit subhandle (ioapic.pin)
+ 	 * - AMD/IR:  8bit IRTE index
+ 	 */
+ 	entry->vector			= msg.arch_data.vector;
+ 	/* Delivery mode (for DMAR/IR all 0) */
+ 	entry->delivery_mode		= msg.arch_data.delivery_mode;
+ 	/* Destination mode or DMAR/IR index bit 15 */
+ 	entry->dest_mode_logical	= msg.arch_addr_lo.dest_mode_logical;
+ 	/* DMAR/IR: 1, 0 for all other modes */
+ 	entry->ir_format		= msg.arch_addr_lo.dmar_format;
+ 	/*
+ 	 * - DMAR/IR: index bit 0-14.
+ 	 *
+ 	 * - Virt: If the host supports x2apic without a virtualized IR
+ 	 *	   unit then bit 0-6 of dmar_index_0_14 are providing bit
+ 	 *	   8-14 of the destination id.
+ 	 *
+ 	 * All other modes have bit 0-6 of dmar_index_0_14 cleared and the
+ 	 * topmost 8 bits are destination id bit 0-7 (entry::destid_0_7).
+ 	 */
+ 	entry->ir_index_0_14		= msg.arch_addr_lo.dmar_index_0_14;
+ }
+ 
++>>>>>>> 51130d21881d (x86/ioapic: Handle Extended Destination ID field in RTE)
  static void ioapic_configure_entry(struct irq_data *irqd)
  {
  	struct mp_chip_data *mpd = irqd->chip_data;
@@@ -2054,14 -2086,16 +2124,25 @@@ static inline void __init unlock_ExtINT
  	entry0 = ioapic_read_entry(apic, pin);
  	clear_IO_APIC_pin(apic, pin);
  
+ 	apic_id = hard_smp_processor_id();
  	memset(&entry1, 0, sizeof(entry1));
  
++<<<<<<< HEAD
 +	entry1.dest_mode = IOAPIC_DEST_MODE_PHYSICAL;
 +	entry1.mask = IOAPIC_UNMASKED;
 +	entry1.dest = hard_smp_processor_id();
 +	entry1.delivery_mode = APIC_DELIVERY_MODE_EXTINT;
 +	entry1.polarity = entry0.polarity;
 +	entry1.trigger = IOAPIC_EDGE;
++=======
+ 	entry1.dest_mode_logical	= true;
+ 	entry1.masked			= false;
+ 	entry1.destid_0_7		= apic_id & 0xFF;
+ 	entry1.virt_destid_8_14		= apic_id >> 8;
+ 	entry1.delivery_mode		= APIC_DELIVERY_MODE_EXTINT;
+ 	entry1.active_low		= entry0.active_low;
+ 	entry1.is_level			= false;
++>>>>>>> 51130d21881d (x86/ioapic: Handle Extended Destination ID field in RTE)
  	entry1.vector = 0;
  
  	ioapic_write_entry(apic, pin, entry1);
* Unmerged path arch/x86/include/asm/io_apic.h
* Unmerged path arch/x86/kernel/apic/io_apic.c
