kasan: add memory corruption identification for software tag-based mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Walter Wu <walter-zh.wu@mediatek.com>
commit ae8f06b31a83e54777514308a63f669a1fed519e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ae8f06b3.failed

Add memory corruption identification at bug report for software tag-based
mode.  The report shows whether it is "use-after-free" or "out-of-bound"
error instead of "invalid-access" error.  This will make it easier for
programmers to see the memory corruption problem.

We extend the slab to store five old free pointer tag and free backtrace,
we can check if the tagged address is in the slab record and make a good
guess if the object is more like "use-after-free" or "out-of-bound".
therefore every slab memory corruption can be identified whether it's
"use-after-free" or "out-of-bound".

[aryabinin@virtuozzo.com: simplify & clenup code]
  Link: https://lkml.kernel.org/r/3318f9d7-a760-3cc8-b700-f06108ae745f@virtuozzo.com]
Link: http://lkml.kernel.org/r/20190821180332.11450-1-aryabinin@virtuozzo.com
	Signed-off-by: Walter Wu <walter-zh.wu@mediatek.com>
	Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Acked-by: Andrey Konovalov <andreyknvl@google.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Alexander Potapenko <glider@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ae8f06b31a83e54777514308a63f669a1fed519e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kasan/kasan.c
#	mm/kasan/kasan.h
#	mm/kasan/report.c
#	mm/kasan/tags_report.c
diff --cc mm/kasan/kasan.c
index d79269dd4b58,6b6f1198c72b..000000000000
--- a/mm/kasan/kasan.c
+++ b/mm/kasan/kasan.c
@@@ -394,8 -301,43 +394,42 @@@ size_t kasan_metadata_size(struct kmem_
  		sizeof(struct kasan_free_meta) : 0);
  }
  
++<<<<<<< HEAD:mm/kasan/kasan.c
++=======
+ struct kasan_alloc_meta *get_alloc_info(struct kmem_cache *cache,
+ 					const void *object)
+ {
+ 	return (void *)object + cache->kasan_info.alloc_meta_offset;
+ }
+ 
+ struct kasan_free_meta *get_free_info(struct kmem_cache *cache,
+ 				      const void *object)
+ {
+ 	BUILD_BUG_ON(sizeof(struct kasan_free_meta) > 32);
+ 	return (void *)object + cache->kasan_info.free_meta_offset;
+ }
+ 
+ 
+ static void kasan_set_free_info(struct kmem_cache *cache,
+ 		void *object, u8 tag)
+ {
+ 	struct kasan_alloc_meta *alloc_meta;
+ 	u8 idx = 0;
+ 
+ 	alloc_meta = get_alloc_info(cache, object);
+ 
+ #ifdef CONFIG_KASAN_SW_TAGS_IDENTIFY
+ 	idx = alloc_meta->free_track_idx;
+ 	alloc_meta->free_pointer_tag[idx] = tag;
+ 	alloc_meta->free_track_idx = (idx + 1) % KASAN_NR_FREE_STACKS;
+ #endif
+ 
+ 	set_track(&alloc_meta->free_track[idx], GFP_NOWAIT);
+ }
+ 
++>>>>>>> ae8f06b31a83 (kasan: add memory corruption identification for software tag-based mode):mm/kasan/common.c
  void kasan_poison_slab(struct page *page)
  {
 -	unsigned long i;
 -
 -	for (i = 0; i < (1 << compound_order(page)); i++)
 -		page_kasan_tag_reset(page + i);
  	kasan_poison_shadow(page_address(page),
  			PAGE_SIZE << compound_order(page),
  			KASAN_KMALLOC_REDZONE);
@@@ -516,12 -465,15 +550,13 @@@ static bool __kasan_slab_free(struct km
  	rounded_up_size = round_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE);
  	kasan_poison_shadow(object, rounded_up_size, KASAN_KMALLOC_FREE);
  
 -	if ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine) ||
 -			unlikely(!(cache->flags & SLAB_KASAN)))
 +	if (!quarantine || unlikely(!(cache->flags & SLAB_KASAN)))
  		return false;
  
- 	set_track(&get_alloc_info(cache, object)->free_track, GFP_NOWAIT);
+ 	kasan_set_free_info(cache, object, tag);
+ 
  	quarantine_put(get_free_info(cache, object), cache);
 -
 -	return IS_ENABLED(CONFIG_KASAN_GENERIC);
 +	return true;
  }
  
  bool kasan_slab_free(struct kmem_cache *cache, void *object, unsigned long ip)
diff --cc mm/kasan/kasan.h
index c12dcfde2ebd,35cff6bbb716..000000000000
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@@ -109,7 -156,10 +119,14 @@@ void kasan_report(unsigned long addr, s
  		bool is_write, unsigned long ip);
  void kasan_report_invalid_free(void *object, unsigned long ip);
  
++<<<<<<< HEAD
 +#if defined(CONFIG_SLAB) || defined(CONFIG_SLUB)
++=======
+ struct page *kasan_addr_to_page(const void *addr);
+ 
+ #if defined(CONFIG_KASAN_GENERIC) && \
+ 	(defined(CONFIG_SLAB) || defined(CONFIG_SLUB))
++>>>>>>> ae8f06b31a83 (kasan: add memory corruption identification for software tag-based mode)
  void quarantine_put(struct kasan_free_meta *info, struct kmem_cache *cache);
  void quarantine_reduce(void);
  void quarantine_remove_cache(struct kmem_cache *cache);
diff --cc mm/kasan/report.c
index 5c169aa688fd,621782100eaa..000000000000
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@@ -249,9 -189,187 +272,191 @@@ static void describe_object(struct kmem
  	describe_object_addr(cache, object, addr);
  }
  
++<<<<<<< HEAD
 +static void print_address_description(void *addr)
++=======
+ static inline bool kernel_or_module_addr(const void *addr)
+ {
+ 	if (addr >= (void *)_stext && addr < (void *)_end)
+ 		return true;
+ 	if (is_module_address((unsigned long)addr))
+ 		return true;
+ 	return false;
+ }
+ 
+ static inline bool init_task_stack_addr(const void *addr)
  {
- 	struct page *page = addr_to_page(addr);
+ 	return addr >= (void *)&init_thread_union.stack &&
+ 		(addr <= (void *)&init_thread_union.stack +
+ 			sizeof(init_thread_union.stack));
+ }
+ 
+ static bool __must_check tokenize_frame_descr(const char **frame_descr,
+ 					      char *token, size_t max_tok_len,
+ 					      unsigned long *value)
+ {
+ 	const char *sep = strchr(*frame_descr, ' ');
+ 
+ 	if (sep == NULL)
+ 		sep = *frame_descr + strlen(*frame_descr);
+ 
+ 	if (token != NULL) {
+ 		const size_t tok_len = sep - *frame_descr;
+ 
+ 		if (tok_len + 1 > max_tok_len) {
+ 			pr_err("KASAN internal error: frame description too long: %s\n",
+ 			       *frame_descr);
+ 			return false;
+ 		}
+ 
+ 		/* Copy token (+ 1 byte for '\0'). */
+ 		strlcpy(token, *frame_descr, tok_len + 1);
+ 	}
+ 
+ 	/* Advance frame_descr past separator. */
+ 	*frame_descr = sep + 1;
+ 
+ 	if (value != NULL && kstrtoul(token, 10, value)) {
+ 		pr_err("KASAN internal error: not a valid number: %s\n", token);
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static void print_decoded_frame_descr(const char *frame_descr)
+ {
+ 	/*
+ 	 * We need to parse the following string:
+ 	 *    "n alloc_1 alloc_2 ... alloc_n"
+ 	 * where alloc_i looks like
+ 	 *    "offset size len name"
+ 	 * or "offset size len name:line".
+ 	 */
+ 
+ 	char token[64];
+ 	unsigned long num_objects;
+ 
+ 	if (!tokenize_frame_descr(&frame_descr, token, sizeof(token),
+ 				  &num_objects))
+ 		return;
+ 
+ 	pr_err("\n");
+ 	pr_err("this frame has %lu %s:\n", num_objects,
+ 	       num_objects == 1 ? "object" : "objects");
+ 
+ 	while (num_objects--) {
+ 		unsigned long offset;
+ 		unsigned long size;
+ 
+ 		/* access offset */
+ 		if (!tokenize_frame_descr(&frame_descr, token, sizeof(token),
+ 					  &offset))
+ 			return;
+ 		/* access size */
+ 		if (!tokenize_frame_descr(&frame_descr, token, sizeof(token),
+ 					  &size))
+ 			return;
+ 		/* name length (unused) */
+ 		if (!tokenize_frame_descr(&frame_descr, NULL, 0, NULL))
+ 			return;
+ 		/* object name */
+ 		if (!tokenize_frame_descr(&frame_descr, token, sizeof(token),
+ 					  NULL))
+ 			return;
+ 
+ 		/* Strip line number; without filename it's not very helpful. */
+ 		strreplace(token, ':', '\0');
+ 
+ 		/* Finally, print object information. */
+ 		pr_err(" [%lu, %lu) '%s'", offset, offset + size, token);
+ 	}
+ }
+ 
+ static bool __must_check get_address_stack_frame_info(const void *addr,
+ 						      unsigned long *offset,
+ 						      const char **frame_descr,
+ 						      const void **frame_pc)
+ {
+ 	unsigned long aligned_addr;
+ 	unsigned long mem_ptr;
+ 	const u8 *shadow_bottom;
+ 	const u8 *shadow_ptr;
+ 	const unsigned long *frame;
+ 
+ 	BUILD_BUG_ON(IS_ENABLED(CONFIG_STACK_GROWSUP));
+ 
+ 	/*
+ 	 * NOTE: We currently only support printing frame information for
+ 	 * accesses to the task's own stack.
+ 	 */
+ 	if (!object_is_on_stack(addr))
+ 		return false;
+ 
+ 	aligned_addr = round_down((unsigned long)addr, sizeof(long));
+ 	mem_ptr = round_down(aligned_addr, KASAN_SHADOW_SCALE_SIZE);
+ 	shadow_ptr = kasan_mem_to_shadow((void *)aligned_addr);
+ 	shadow_bottom = kasan_mem_to_shadow(end_of_stack(current));
+ 
+ 	while (shadow_ptr >= shadow_bottom && *shadow_ptr != KASAN_STACK_LEFT) {
+ 		shadow_ptr--;
+ 		mem_ptr -= KASAN_SHADOW_SCALE_SIZE;
+ 	}
+ 
+ 	while (shadow_ptr >= shadow_bottom && *shadow_ptr == KASAN_STACK_LEFT) {
+ 		shadow_ptr--;
+ 		mem_ptr -= KASAN_SHADOW_SCALE_SIZE;
+ 	}
+ 
+ 	if (shadow_ptr < shadow_bottom)
+ 		return false;
+ 
+ 	frame = (const unsigned long *)(mem_ptr + KASAN_SHADOW_SCALE_SIZE);
+ 	if (frame[0] != KASAN_CURRENT_STACK_FRAME_MAGIC) {
+ 		pr_err("KASAN internal error: frame info validation failed; invalid marker: %lu\n",
+ 		       frame[0]);
+ 		return false;
+ 	}
+ 
+ 	*offset = (unsigned long)addr - (unsigned long)frame;
+ 	*frame_descr = (const char *)frame[1];
+ 	*frame_pc = (void *)frame[2];
+ 
+ 	return true;
+ }
+ 
+ static void print_address_stack_frame(const void *addr)
+ {
+ 	unsigned long offset;
+ 	const char *frame_descr;
+ 	const void *frame_pc;
+ 
+ 	if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
+ 		return;
+ 
+ 	if (!get_address_stack_frame_info(addr, &offset, &frame_descr,
+ 					  &frame_pc))
+ 		return;
+ 
+ 	/*
+ 	 * get_address_stack_frame_info only returns true if the given addr is
+ 	 * on the current task's stack.
+ 	 */
+ 	pr_err("\n");
+ 	pr_err("addr %px is located in stack of task %s/%d at offset %lu in frame:\n",
+ 	       addr, current->comm, task_pid_nr(current), offset);
+ 	pr_err(" %pS\n", frame_pc);
+ 
+ 	if (!frame_descr)
+ 		return;
+ 
+ 	print_decoded_frame_descr(frame_descr);
+ }
+ 
+ static void print_address_description(void *addr, u8 tag)
++>>>>>>> ae8f06b31a83 (kasan: add memory corruption identification for software tag-based mode)
+ {
+ 	struct page *page = kasan_addr_to_page(addr);
  
  	dump_stack();
  	pr_err("\n");
@@@ -393,12 -455,30 +598,32 @@@ static inline bool kasan_report_enabled
  	return !test_and_set_bit(KASAN_BIT_REPORTED, &kasan_flags);
  }
  
++<<<<<<< HEAD
 +void kasan_report(unsigned long addr, size_t size,
 +		bool is_write, unsigned long ip)
++=======
+ void kasan_report_invalid_free(void *object, unsigned long ip)
+ {
+ 	unsigned long flags;
+ 	u8 tag = get_tag(object);
+ 
+ 	object = reset_tag(object);
+ 	start_report(&flags);
+ 	pr_err("BUG: KASAN: double-free or invalid-free in %pS\n", (void *)ip);
+ 	print_tags(tag, object);
+ 	pr_err("\n");
+ 	print_address_description(object, tag);
+ 	pr_err("\n");
+ 	print_shadow_for_address(object);
+ 	end_report(&flags);
+ }
+ 
+ void __kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip)
++>>>>>>> ae8f06b31a83 (kasan: add memory corruption identification for software tag-based mode)
  {
  	struct kasan_access_info info;
 -	void *tagged_addr;
 -	void *untagged_addr;
 -	unsigned long flags;
  
 -	if (likely(!report_enabled()))
 +	if (likely(!kasan_report_enabled()))
  		return;
  
  	disable_trace_on_warning();
@@@ -409,43 -495,20 +634,62 @@@
  	info.is_write = is_write;
  	info.ip = ip;
  
++<<<<<<< HEAD
 +	kasan_report_error(&info);
++=======
+ 	start_report(&flags);
+ 
+ 	print_error_description(&info);
+ 	if (addr_has_shadow(untagged_addr))
+ 		print_tags(get_tag(tagged_addr), info.first_bad_addr);
+ 	pr_err("\n");
+ 
+ 	if (addr_has_shadow(untagged_addr)) {
+ 		print_address_description(untagged_addr, get_tag(tagged_addr));
+ 		pr_err("\n");
+ 		print_shadow_for_address(info.first_bad_addr);
+ 	} else {
+ 		dump_stack();
+ 	}
+ 
+ 	end_report(&flags);
++>>>>>>> ae8f06b31a83 (kasan: add memory corruption identification for software tag-based mode)
 +}
 +
 +
 +#define DEFINE_ASAN_REPORT_LOAD(size)                     \
 +void __asan_report_load##size##_noabort(unsigned long addr) \
 +{                                                         \
 +	kasan_report(addr, size, false, _RET_IP_);	  \
 +}                                                         \
 +EXPORT_SYMBOL(__asan_report_load##size##_noabort)
 +
 +#define DEFINE_ASAN_REPORT_STORE(size)                     \
 +void __asan_report_store##size##_noabort(unsigned long addr) \
 +{                                                          \
 +	kasan_report(addr, size, true, _RET_IP_);	   \
 +}                                                          \
 +EXPORT_SYMBOL(__asan_report_store##size##_noabort)
 +
 +DEFINE_ASAN_REPORT_LOAD(1);
 +DEFINE_ASAN_REPORT_LOAD(2);
 +DEFINE_ASAN_REPORT_LOAD(4);
 +DEFINE_ASAN_REPORT_LOAD(8);
 +DEFINE_ASAN_REPORT_LOAD(16);
 +DEFINE_ASAN_REPORT_STORE(1);
 +DEFINE_ASAN_REPORT_STORE(2);
 +DEFINE_ASAN_REPORT_STORE(4);
 +DEFINE_ASAN_REPORT_STORE(8);
 +DEFINE_ASAN_REPORT_STORE(16);
 +
 +void __asan_report_load_n_noabort(unsigned long addr, size_t size)
 +{
 +	kasan_report(addr, size, false, _RET_IP_);
 +}
 +EXPORT_SYMBOL(__asan_report_load_n_noabort);
 +
 +void __asan_report_store_n_noabort(unsigned long addr, size_t size)
 +{
 +	kasan_report(addr, size, true, _RET_IP_);
  }
 +EXPORT_SYMBOL(__asan_report_store_n_noabort);
* Unmerged path mm/kasan/tags_report.c
diff --git a/lib/Kconfig.kasan b/lib/Kconfig.kasan
index d0bad1bd9a2b..870895409c37 100644
--- a/lib/Kconfig.kasan
+++ b/lib/Kconfig.kasan
@@ -66,6 +66,14 @@ config KASAN_S390_4_LEVEL_PAGING
 	  to 3TB of RAM with KASan enabled). This options allows to force
 	  4-level paging instead.
 
+config KASAN_SW_TAGS_IDENTIFY
+	bool "Enable memory corruption identification"
+	depends on KASAN_SW_TAGS
+	help
+	  This option enables best-effort identification of bug type
+	  (use-after-free or out-of-bounds) at the cost of increased
+	  memory consumption.
+
 config TEST_KASAN
 	tristate "Module for testing kasan for bug detection"
 	depends on m && KASAN
* Unmerged path mm/kasan/kasan.c
* Unmerged path mm/kasan/kasan.h
* Unmerged path mm/kasan/report.c
* Unmerged path mm/kasan/tags_report.c
