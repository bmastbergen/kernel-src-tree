net: remove sockptr_advance

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit d3c48151512922dd35f1f393b30b9138e4441d14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d3c48151.failed

sockptr_advance never properly worked.  Replace it with _offset variants
of copy_from_sockptr and copy_to_sockptr.

Fixes: ba423fdaa589 ("net: add a new sockptr_t type")
	Reported-by: Jason A. Donenfeld <Jason@zx2c4.com>
	Reported-by: Ido Schimmel <idosch@idosch.org>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Jason A. Donenfeld <Jason@zx2c4.com>
	Tested-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d3c48151512922dd35f1f393b30b9138e4441d14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chtls/chtls_main.c
#	net/dccp/proto.c
#	net/ipv4/netfilter/arp_tables.c
#	net/ipv4/netfilter/ip_tables.c
#	net/ipv4/tcp.c
#	net/ipv6/ip6_flowlabel.c
#	net/ipv6/netfilter/ip6_tables.c
#	net/netfilter/x_tables.c
#	net/tls/tls_main.c
diff --cc drivers/crypto/chelsio/chtls/chtls_main.c
index f63294c8a97a,66d247efd561..000000000000
--- a/drivers/crypto/chelsio/chtls/chtls_main.c
+++ b/drivers/crypto/chelsio/chtls/chtls_main.c
@@@ -505,8 -525,9 +505,14 @@@ static int do_chtls_setsockopt(struct s
  		/* Obtain version and type from previous copy */
  		crypto_info[0] = tmp_crypto_info;
  		/* Now copy the following data */
++<<<<<<< HEAD
 +		rc = copy_from_user((char *)crypto_info + sizeof(*crypto_info),
 +				optval + sizeof(*crypto_info),
++=======
+ 		rc = copy_from_sockptr_offset((char *)crypto_info +
+ 				sizeof(*crypto_info),
+ 				optval, sizeof(*crypto_info),
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  				sizeof(struct tls12_crypto_info_aes_gcm_128)
  				- sizeof(*crypto_info));
  
@@@ -516,7 -537,24 +522,28 @@@
  		}
  
  		keylen = TLS_CIPHER_AES_GCM_128_KEY_SIZE;
++<<<<<<< HEAD
 +		rc = chtls_setkey(csk, keylen, optname);
++=======
+ 		cipher_type = TLS_CIPHER_AES_GCM_128;
+ 		break;
+ 	}
+ 	case TLS_CIPHER_AES_GCM_256: {
+ 		crypto_info[0] = tmp_crypto_info;
+ 		rc = copy_from_sockptr_offset((char *)crypto_info +
+ 				sizeof(*crypto_info),
+ 				optval, sizeof(*crypto_info),
+ 				sizeof(struct tls12_crypto_info_aes_gcm_256)
+ 				- sizeof(*crypto_info));
+ 
+ 		if (rc) {
+ 			rc = -EFAULT;
+ 			goto out;
+ 		}
+ 
+ 		keylen = TLS_CIPHER_AES_GCM_256_KEY_SIZE;
+ 		cipher_type = TLS_CIPHER_AES_GCM_256;
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		break;
  	}
  	default:
diff --cc net/dccp/proto.c
index 8cc6869510b7,d148ab1530e5..000000000000
--- a/net/dccp/proto.c
+++ b/net/dccp/proto.c
@@@ -421,9 -426,8 +421,14 @@@ static int dccp_setsockopt_service(stru
  			return -ENOMEM;
  
  		sl->dccpsl_nr = optlen / sizeof(u32) - 1;
++<<<<<<< HEAD
 +		if (copy_from_user(sl->dccpsl_list,
 +				   optval + sizeof(service),
 +				   optlen - sizeof(service)) ||
++=======
+ 		if (copy_from_sockptr_offset(sl->dccpsl_list, optval,
+ 				sizeof(service), optlen - sizeof(service)) ||
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		    dccp_list_has_service(sl, DCCP_SERVICE_INVALID_VALUE)) {
  			kfree(sl);
  			return -EFAULT;
diff --cc net/ipv4/netfilter/arp_tables.c
index 10d8f95eb771,d1e04d2b5170..000000000000
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@@ -972,8 -971,8 +972,13 @@@ static int do_replace(struct net *net, 
  		return -ENOMEM;
  
  	loc_cpu_entry = newinfo->entries;
++<<<<<<< HEAD
 +	if (copy_from_user(loc_cpu_entry, user + sizeof(tmp),
 +			   tmp.size) != 0) {
++=======
+ 	if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),
+ 			tmp.size) != 0) {
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		ret = -EFAULT;
  		goto free_newinfo;
  	}
@@@ -1270,7 -1267,8 +1275,12 @@@ static int compat_do_replace(struct ne
  		return -ENOMEM;
  
  	loc_cpu_entry = newinfo->entries;
++<<<<<<< HEAD
 +	if (copy_from_user(loc_cpu_entry, user + sizeof(tmp), tmp.size) != 0) {
++=======
+ 	if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),
+ 			tmp.size) != 0) {
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		ret = -EFAULT;
  		goto free_newinfo;
  	}
diff --cc net/ipv4/netfilter/ip_tables.c
index 45db860d6e83,f15bc21d7301..000000000000
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@@ -1130,8 -1126,8 +1130,13 @@@ do_replace(struct net *net, const void 
  		return -ENOMEM;
  
  	loc_cpu_entry = newinfo->entries;
++<<<<<<< HEAD
 +	if (copy_from_user(loc_cpu_entry, user + sizeof(tmp),
 +			   tmp.size) != 0) {
++=======
+ 	if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),
+ 			tmp.size) != 0) {
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		ret = -EFAULT;
  		goto free_newinfo;
  	}
@@@ -1513,8 -1508,8 +1518,13 @@@ compat_do_replace(struct net *net, voi
  		return -ENOMEM;
  
  	loc_cpu_entry = newinfo->entries;
++<<<<<<< HEAD
 +	if (copy_from_user(loc_cpu_entry, user + sizeof(tmp),
 +			   tmp.size) != 0) {
++=======
+ 	if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),
+ 			tmp.size) != 0) {
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		ret = -EFAULT;
  		goto free_newinfo;
  	}
diff --cc net/ipv4/tcp.c
index 8f4b529b1711,4afec552f211..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -2702,12 -2801,13 +2702,20 @@@ static int tcp_repair_options_est(struc
  {
  	struct tcp_sock *tp = tcp_sk(sk);
  	struct tcp_repair_opt opt;
+ 	size_t offset = 0;
  
  	while (len >= sizeof(opt)) {
++<<<<<<< HEAD
 +		if (copy_from_user(&opt, optbuf, sizeof(opt)))
 +			return -EFAULT;
 +
 +		optbuf++;
++=======
+ 		if (copy_from_sockptr_offset(&opt, optbuf, offset, sizeof(opt)))
+ 			return -EFAULT;
+ 
+ 		offset += sizeof(opt);
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		len -= sizeof(opt);
  
  		switch (opt.opt_code) {
diff --cc net/ipv6/ip6_flowlabel.c
index 22ca0befcc64,2d655260dedc..000000000000
--- a/net/ipv6/ip6_flowlabel.c
+++ b/net/ipv6/ip6_flowlabel.c
@@@ -390,7 -401,8 +390,12 @@@ fl_create(struct net *net, struct sock 
  		memset(fl->opt, 0, sizeof(*fl->opt));
  		fl->opt->tot_len = sizeof(*fl->opt) + olen;
  		err = -EFAULT;
++<<<<<<< HEAD
 +		if (copy_from_user(fl->opt+1, optval+CMSG_ALIGN(sizeof(*freq)), olen))
++=======
+ 		if (copy_from_sockptr_offset(fl->opt + 1, optval,
+ 				CMSG_ALIGN(sizeof(*freq)), olen))
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  			goto done;
  
  		msg.msg_controllen = olen;
@@@ -517,17 -534,194 +522,129 @@@ int ipv6_flowlabel_opt_get(struct sock 
  	return -ENOENT;
  }
  
 -#define socklist_dereference(__sflp) \
 -	rcu_dereference_protected(__sflp, lockdep_is_held(&ip6_sk_fl_lock))
 -
 -static int ipv6_flowlabel_put(struct sock *sk, struct in6_flowlabel_req *freq)
 -{
 -	struct ipv6_pinfo *np = inet6_sk(sk);
 -	struct ipv6_fl_socklist __rcu **sflp;
 -	struct ipv6_fl_socklist *sfl;
 -
 -	if (freq->flr_flags & IPV6_FL_F_REFLECT) {
 -		if (sk->sk_protocol != IPPROTO_TCP)
 -			return -ENOPROTOOPT;
 -		if (!np->repflow)
 -			return -ESRCH;
 -		np->flow_label = 0;
 -		np->repflow = 0;
 -		return 0;
 -	}
 -
 -	spin_lock_bh(&ip6_sk_fl_lock);
 -	for (sflp = &np->ipv6_fl_list;
 -	     (sfl = socklist_dereference(*sflp)) != NULL;
 -	     sflp = &sfl->next) {
 -		if (sfl->fl->label == freq->flr_label)
 -			goto found;
 -	}
 -	spin_unlock_bh(&ip6_sk_fl_lock);
 -	return -ESRCH;
 -found:
 -	if (freq->flr_label == (np->flow_label & IPV6_FLOWLABEL_MASK))
 -		np->flow_label &= ~IPV6_FLOWLABEL_MASK;
 -	*sflp = sfl->next;
 -	spin_unlock_bh(&ip6_sk_fl_lock);
 -	fl_release(sfl->fl);
 -	kfree_rcu(sfl, rcu);
 -	return 0;
 -}
 -
 -static int ipv6_flowlabel_renew(struct sock *sk, struct in6_flowlabel_req *freq)
 +int ipv6_flowlabel_opt(struct sock *sk, char __user *optval, int optlen)
  {
 -	struct ipv6_pinfo *np = inet6_sk(sk);
 +	int uninitialized_var(err);
++<<<<<<< HEAD
  	struct net *net = sock_net(sk);
 -	struct ipv6_fl_socklist *sfl;
 -	int err;
 -
 -	rcu_read_lock_bh();
 -	for_each_sk_fl_rcu(np, sfl) {
 -		if (sfl->fl->label == freq->flr_label) {
 -			err = fl6_renew(sfl->fl, freq->flr_linger,
 -					freq->flr_expires);
 -			rcu_read_unlock_bh();
 -			return err;
 -		}
 -	}
 -	rcu_read_unlock_bh();
 -
 -	if (freq->flr_share == IPV6_FL_S_NONE &&
 -	    ns_capable(net->user_ns, CAP_NET_ADMIN)) {
 -		struct ip6_flowlabel *fl = fl_lookup(net, freq->flr_label);
 -
 -		if (fl) {
 -			err = fl6_renew(fl, freq->flr_linger,
 -					freq->flr_expires);
 -			fl_release(fl);
 -			return err;
 -		}
 -	}
 -	return -ESRCH;
 -}
 -
 -static int ipv6_flowlabel_get(struct sock *sk, struct in6_flowlabel_req *freq,
 -		sockptr_t optval, int optlen)
 -{
 -	struct ipv6_fl_socklist *sfl, *sfl1 = NULL;
 -	struct ip6_flowlabel *fl, *fl1 = NULL;
  	struct ipv6_pinfo *np = inet6_sk(sk);
 -	struct net *net = sock_net(sk);
 -	int uninitialized_var(err);
++=======
+ 
+ 	if (freq->flr_flags & IPV6_FL_F_REFLECT) {
+ 		if (net->ipv6.sysctl.flowlabel_consistency) {
+ 			net_info_ratelimited("Can not set IPV6_FL_F_REFLECT if flowlabel_consistency sysctl is enable\n");
+ 			return -EPERM;
+ 		}
+ 
+ 		if (sk->sk_protocol != IPPROTO_TCP)
+ 			return -ENOPROTOOPT;
+ 		np->repflow = 1;
+ 		return 0;
+ 	}
+ 
+ 	if (freq->flr_label & ~IPV6_FLOWLABEL_MASK)
+ 		return -EINVAL;
+ 	if (net->ipv6.sysctl.flowlabel_state_ranges &&
+ 	    (freq->flr_label & IPV6_FLOWLABEL_STATELESS_FLAG))
+ 		return -ERANGE;
+ 
+ 	fl = fl_create(net, sk, freq, optval, optlen, &err);
+ 	if (!fl)
+ 		return err;
+ 
+ 	sfl1 = kmalloc(sizeof(*sfl1), GFP_KERNEL);
+ 
+ 	if (freq->flr_label) {
+ 		err = -EEXIST;
+ 		rcu_read_lock_bh();
+ 		for_each_sk_fl_rcu(np, sfl) {
+ 			if (sfl->fl->label == freq->flr_label) {
+ 				if (freq->flr_flags & IPV6_FL_F_EXCL) {
+ 					rcu_read_unlock_bh();
+ 					goto done;
+ 				}
+ 				fl1 = sfl->fl;
+ 				if (!atomic_inc_not_zero(&fl1->users))
+ 					fl1 = NULL;
+ 				break;
+ 			}
+ 		}
+ 		rcu_read_unlock_bh();
+ 
+ 		if (!fl1)
+ 			fl1 = fl_lookup(net, freq->flr_label);
+ 		if (fl1) {
+ recheck:
+ 			err = -EEXIST;
+ 			if (freq->flr_flags&IPV6_FL_F_EXCL)
+ 				goto release;
+ 			err = -EPERM;
+ 			if (fl1->share == IPV6_FL_S_EXCL ||
+ 			    fl1->share != fl->share ||
+ 			    ((fl1->share == IPV6_FL_S_PROCESS) &&
+ 			     (fl1->owner.pid != fl->owner.pid)) ||
+ 			    ((fl1->share == IPV6_FL_S_USER) &&
+ 			     !uid_eq(fl1->owner.uid, fl->owner.uid)))
+ 				goto release;
+ 
+ 			err = -ENOMEM;
+ 			if (!sfl1)
+ 				goto release;
+ 			if (fl->linger > fl1->linger)
+ 				fl1->linger = fl->linger;
+ 			if ((long)(fl->expires - fl1->expires) > 0)
+ 				fl1->expires = fl->expires;
+ 			fl_link(np, sfl1, fl1);
+ 			fl_free(fl);
+ 			return 0;
+ 
+ release:
+ 			fl_release(fl1);
+ 			goto done;
+ 		}
+ 	}
+ 	err = -ENOENT;
+ 	if (!(freq->flr_flags & IPV6_FL_F_CREATE))
+ 		goto done;
+ 
+ 	err = -ENOMEM;
+ 	if (!sfl1)
+ 		goto done;
+ 
+ 	err = mem_check(sk);
+ 	if (err != 0)
+ 		goto done;
+ 
+ 	fl1 = fl_intern(net, fl, freq->flr_label);
+ 	if (fl1)
+ 		goto recheck;
+ 
+ 	if (!freq->flr_label) {
+ 		size_t offset = offsetof(struct in6_flowlabel_req, flr_label);
+ 
+ 		if (copy_to_sockptr_offset(optval, offset, &fl->label,
+ 				sizeof(fl->label))) {
+ 			/* Intentionally ignore fault. */
+ 		}
+ 	}
+ 
+ 	fl_link(np, sfl1, fl);
+ 	return 0;
+ done:
+ 	fl_free(fl);
+ 	kfree(sfl1);
+ 	return err;
+ }
+ 
+ int ipv6_flowlabel_opt(struct sock *sk, sockptr_t optval, int optlen)
+ {
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  	struct in6_flowlabel_req freq;
 +	struct ipv6_fl_socklist *sfl1 = NULL;
 +	struct ipv6_fl_socklist *sfl;
 +	struct ipv6_fl_socklist __rcu **sflp;
 +	struct ip6_flowlabel *fl, *fl1 = NULL;
 +
  
  	if (optlen < sizeof(freq))
  		return -EINVAL;
diff --cc net/ipv6/netfilter/ip6_tables.c
index 04e3670c9217,2e2119bfcf13..000000000000
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@@ -1147,8 -1143,8 +1147,13 @@@ do_replace(struct net *net, const void 
  		return -ENOMEM;
  
  	loc_cpu_entry = newinfo->entries;
++<<<<<<< HEAD
 +	if (copy_from_user(loc_cpu_entry, user + sizeof(tmp),
 +			   tmp.size) != 0) {
++=======
+ 	if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),
+ 			tmp.size) != 0) {
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		ret = -EFAULT;
  		goto free_newinfo;
  	}
@@@ -1522,8 -1517,8 +1527,13 @@@ compat_do_replace(struct net *net, voi
  		return -ENOMEM;
  
  	loc_cpu_entry = newinfo->entries;
++<<<<<<< HEAD
 +	if (copy_from_user(loc_cpu_entry, user + sizeof(tmp),
 +			   tmp.size) != 0) {
++=======
+ 	if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),
+ 			tmp.size) != 0) {
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		ret = -EFAULT;
  		goto free_newinfo;
  	}
diff --cc net/netfilter/x_tables.c
index 3fe9a906120b,91bf6635ea9e..000000000000
--- a/net/netfilter/x_tables.c
+++ b/net/netfilter/x_tables.c
@@@ -1053,9 -1047,10 +1053,10 @@@ EXPORT_SYMBOL_GPL(xt_check_target)
   * Return: returns pointer that caller has to test via IS_ERR().
   * If IS_ERR is false, caller has to vfree the pointer.
   */
 -void *xt_copy_counters(sockptr_t arg, unsigned int len,
 -		       struct xt_counters_info *info)
 +void *xt_copy_counters_from_user(const void __user *user, unsigned int len,
 +				 struct xt_counters_info *info, bool compat)
  {
+ 	size_t offset;
  	void *mem;
  	u64 size;
  
@@@ -1073,7 -1068,7 +1074,11 @@@
  
  		memcpy(info->name, compat_tmp.name, sizeof(info->name) - 1);
  		info->num_counters = compat_tmp.num_counters;
++<<<<<<< HEAD
 +		user += sizeof(compat_tmp);
++=======
+ 		offset = sizeof(compat_tmp);
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  	} else
  #endif
  	{
@@@ -1081,10 -1076,10 +1086,14 @@@
  			return ERR_PTR(-EINVAL);
  
  		len -= sizeof(*info);
 -		if (copy_from_sockptr(info, arg, sizeof(*info)) != 0)
 +		if (copy_from_user(info, user, sizeof(*info)) != 0)
  			return ERR_PTR(-EFAULT);
  
++<<<<<<< HEAD
 +		user += sizeof(*info);
++=======
+ 		offset = sizeof(*info);
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  	}
  	info->name[sizeof(info->name) - 1] = '\0';
  
@@@ -1098,7 -1093,7 +1107,11 @@@
  	if (!mem)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	if (copy_from_user(mem, user, len) == 0)
++=======
+ 	if (copy_from_sockptr_offset(mem, arg, offset, len) == 0)
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  		return mem;
  
  	vfree(mem);
diff --cc net/tls/tls_main.c
index fbe79ccf0b6a,bbc52b088d29..000000000000
--- a/net/tls/tls_main.c
+++ b/net/tls/tls_main.c
@@@ -531,8 -522,9 +531,14 @@@ static int do_tls_setsockopt_conf(struc
  		goto err_crypto_info;
  	}
  
++<<<<<<< HEAD
 +	rc = copy_from_user(crypto_info + 1, optval + sizeof(*crypto_info),
 +			    optlen - sizeof(*crypto_info));
++=======
+ 	rc = copy_from_sockptr_offset(crypto_info + 1, optval,
+ 				      sizeof(*crypto_info),
+ 				      optlen - sizeof(*crypto_info));
++>>>>>>> d3c481515129 (net: remove sockptr_advance)
  	if (rc) {
  		rc = -EFAULT;
  		goto err_crypto_info;
* Unmerged path drivers/crypto/chelsio/chtls/chtls_main.c
diff --git a/include/linux/sockptr.h b/include/linux/sockptr.h
index 7a37a7425b45..ea193414298b 100644
--- a/include/linux/sockptr.h
+++ b/include/linux/sockptr.h
@@ -41,19 +41,26 @@ static inline bool sockptr_is_null(sockptr_t sockptr)
 	return !sockptr.user;
 }
 
-static inline int copy_from_sockptr(void *dst, sockptr_t src, size_t size)
+static inline int copy_from_sockptr_offset(void *dst, sockptr_t src,
+		size_t offset, size_t size)
 {
 	if (!sockptr_is_kernel(src))
-		return copy_from_user(dst, src.user, size);
-	memcpy(dst, src.kernel, size);
+		return copy_from_user(dst, src.user + offset, size);
+	memcpy(dst, src.kernel + offset, size);
 	return 0;
 }
 
-static inline int copy_to_sockptr(sockptr_t dst, const void *src, size_t size)
+static inline int copy_from_sockptr(void *dst, sockptr_t src, size_t size)
+{
+	return copy_from_sockptr_offset(dst, src, 0, size);
+}
+
+static inline int copy_to_sockptr_offset(sockptr_t dst, size_t offset,
+		const void *src, size_t size)
 {
 	if (!sockptr_is_kernel(dst))
-		return copy_to_user(dst.user, src, size);
-	memcpy(dst.kernel, src, size);
+		return copy_to_user(dst.user + offset, src, size);
+	memcpy(dst.kernel + offset, src, size);
 	return 0;
 }
 
@@ -84,14 +91,6 @@ static inline void *memdup_sockptr_nul(sockptr_t src, size_t len)
 	return p;
 }
 
-static inline void sockptr_advance(sockptr_t sockptr, size_t len)
-{
-	if (sockptr_is_kernel(sockptr))
-		sockptr.kernel += len;
-	else
-		sockptr.user += len;
-}
-
 static inline long strncpy_from_sockptr(char *dst, sockptr_t src, size_t count)
 {
 	if (sockptr_is_kernel(src)) {
* Unmerged path net/dccp/proto.c
* Unmerged path net/ipv4/netfilter/arp_tables.c
* Unmerged path net/ipv4/netfilter/ip_tables.c
* Unmerged path net/ipv4/tcp.c
* Unmerged path net/ipv6/ip6_flowlabel.c
* Unmerged path net/ipv6/netfilter/ip6_tables.c
* Unmerged path net/netfilter/x_tables.c
* Unmerged path net/tls/tls_main.c
