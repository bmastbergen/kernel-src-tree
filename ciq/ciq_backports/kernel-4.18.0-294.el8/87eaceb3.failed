mm: thp: make deferred split shrinker memcg aware

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yang Shi <yang.shi@linux.alibaba.com>
commit 87eaceb3faa59b9b4d940ec9554ce251325d83fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/87eaceb3.failed

Currently THP deferred split shrinker is not memcg aware, this may cause
premature OOM with some configuration.  For example the below test would
run into premature OOM easily:

$ cgcreate -g memory:thp
$ echo 4G > /sys/fs/cgroup/memory/thp/memory/limit_in_bytes
$ cgexec -g memory:thp transhuge-stress 4000

transhuge-stress comes from kernel selftest.

It is easy to hit OOM, but there are still a lot THP on the deferred split
queue, memcg direct reclaim can't touch them since the deferred split
shrinker is not memcg aware.

Convert deferred split shrinker memcg aware by introducing per memcg
deferred split queue.  The THP should be on either per node or per memcg
deferred split queue if it belongs to a memcg.  When the page is
immigrated to the other memcg, it will be immigrated to the target memcg's
deferred split queue too.

Reuse the second tail page's deferred_list for per memcg list since the
same THP can't be on multiple deferred split queues.

[yang.shi@linux.alibaba.com: simplify deferred split queue dereference per Kirill Tkhai]
  Link: http://lkml.kernel.org/r/1566496227-84952-5-git-send-email-yang.shi@linux.alibaba.com
Link: http://lkml.kernel.org/r/1565144277-36240-5-git-send-email-yang.shi@linux.alibaba.com
	Signed-off-by: Yang Shi <yang.shi@linux.alibaba.com>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Reviewed-by: Kirill Tkhai <ktkhai@virtuozzo.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: "Kirill A . Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Qian Cai <cai@lca.pw>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 87eaceb3faa59b9b4d940ec9554ce251325d83fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memcontrol.h
#	mm/huge_memory.c
diff --cc include/linux/memcontrol.h
index b3eb17a7bec8,9b60863429cc..000000000000
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@@ -324,18 -330,10 +324,25 @@@ struct mem_cgroup 
  	struct list_head event_list;
  	spinlock_t event_list_lock;
  
++<<<<<<< HEAD
 +	/*
 +	 * RHEL8 Warning:
 +	 * The offsets of the nodeinfo[] array entries are subject to change.
 +	 * Third-party kernel modules should NOT try to access its content.
 +	 * In addition, the following inline functions should not be used.
 +	 *  - mem_cgroup_nodeinfo()
 +	 *  - mem_cgroup_lruvec()
 +	 *  - mod_lruvec_page_state(), __mod_lruvec_page_state()
 +	 *  - inc_lruvec_page_state(), __inc_lruvec_page_state()
 +	 *  - dec_lruvec_page_state(), __dec_lruvec_page_state()
 +	 */
 +	RH_KABI_BROKEN_INSERT(MEMCG_PADDING(_pad3_))
++=======
+ #ifdef CONFIG_TRANSPARENT_HUGEPAGE
+ 	struct deferred_split deferred_split_queue;
+ #endif
+ 
++>>>>>>> 87eaceb3faa5 (mm: thp: make deferred split shrinker memcg aware)
  	struct mem_cgroup_per_node *nodeinfo[0];
  	/* WARNING: nodeinfo must be the last member here */
  };
diff --cc mm/huge_memory.c
index 60b47b7d7614,73fc517c08d2..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -2646,6 -2705,7 +2660,10 @@@ int split_huge_page_to_list(struct pag
  {
  	struct page *head = compound_head(page);
  	struct pglist_data *pgdata = NODE_DATA(page_to_nid(head));
++<<<<<<< HEAD
++=======
+ 	struct deferred_split *ds_queue = get_deferred_split_queue(page);
++>>>>>>> 87eaceb3faa5 (mm: thp: make deferred split shrinker memcg aware)
  	struct anon_vma *anon_vma = NULL;
  	struct address_space *mapping = NULL;
  	int count, mapcount, extra_pins, ret;
@@@ -2784,39 -2841,66 +2802,86 @@@ out
  
  void free_transhuge_page(struct page *page)
  {
++<<<<<<< HEAD
 +	struct pglist_data *pgdata = NODE_DATA(page_to_nid(page));
++=======
+ 	struct deferred_split *ds_queue = get_deferred_split_queue(page);
++>>>>>>> 87eaceb3faa5 (mm: thp: make deferred split shrinker memcg aware)
  	unsigned long flags;
  
 -	spin_lock_irqsave(&ds_queue->split_queue_lock, flags);
 +	spin_lock_irqsave(&pgdata->split_queue_lock, flags);
  	if (!list_empty(page_deferred_list(page))) {
 -		ds_queue->split_queue_len--;
 +		pgdata->split_queue_len--;
  		list_del(page_deferred_list(page));
  	}
 -	spin_unlock_irqrestore(&ds_queue->split_queue_lock, flags);
 +	spin_unlock_irqrestore(&pgdata->split_queue_lock, flags);
  	free_compound_page(page);
  }
  
  void deferred_split_huge_page(struct page *page)
  {
++<<<<<<< HEAD
 +	struct pglist_data *pgdata = NODE_DATA(page_to_nid(page));
++=======
+ 	struct deferred_split *ds_queue = get_deferred_split_queue(page);
+ #ifdef CONFIG_MEMCG
+ 	struct mem_cgroup *memcg = compound_head(page)->mem_cgroup;
+ #endif
++>>>>>>> 87eaceb3faa5 (mm: thp: make deferred split shrinker memcg aware)
  	unsigned long flags;
  
  	VM_BUG_ON_PAGE(!PageTransHuge(page), page);
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&pgdata->split_queue_lock, flags);
 +	if (list_empty(page_deferred_list(page))) {
 +		count_vm_event(THP_DEFERRED_SPLIT_PAGE);
 +		list_add_tail(page_deferred_list(page), &pgdata->split_queue);
 +		pgdata->split_queue_len++;
++=======
+ 	/*
+ 	 * The try_to_unmap() in page reclaim path might reach here too,
+ 	 * this may cause a race condition to corrupt deferred split queue.
+ 	 * And, if page reclaim is already handling the same page, it is
+ 	 * unnecessary to handle it again in shrinker.
+ 	 *
+ 	 * Check PageSwapCache to determine if the page is being
+ 	 * handled by page reclaim since THP swap would add the page into
+ 	 * swap cache before calling try_to_unmap().
+ 	 */
+ 	if (PageSwapCache(page))
+ 		return;
+ 
+ 	spin_lock_irqsave(&ds_queue->split_queue_lock, flags);
+ 	if (list_empty(page_deferred_list(page))) {
+ 		count_vm_event(THP_DEFERRED_SPLIT_PAGE);
+ 		list_add_tail(page_deferred_list(page), &ds_queue->split_queue);
+ 		ds_queue->split_queue_len++;
+ #ifdef CONFIG_MEMCG
+ 		if (memcg)
+ 			memcg_set_shrinker_bit(memcg, page_to_nid(page),
+ 					       deferred_split_shrinker.id);
+ #endif
++>>>>>>> 87eaceb3faa5 (mm: thp: make deferred split shrinker memcg aware)
  	}
 -	spin_unlock_irqrestore(&ds_queue->split_queue_lock, flags);
 +	spin_unlock_irqrestore(&pgdata->split_queue_lock, flags);
  }
  
  static unsigned long deferred_split_count(struct shrinker *shrink,
  		struct shrink_control *sc)
  {
  	struct pglist_data *pgdata = NODE_DATA(sc->nid);
++<<<<<<< HEAD
 +	return READ_ONCE(pgdata->split_queue_len);
++=======
+ 	struct deferred_split *ds_queue = &pgdata->deferred_split_queue;
+ 
+ #ifdef CONFIG_MEMCG
+ 	if (sc->memcg)
+ 		ds_queue = &sc->memcg->deferred_split_queue;
+ #endif
+ 	return READ_ONCE(ds_queue->split_queue_len);
++>>>>>>> 87eaceb3faa5 (mm: thp: make deferred split shrinker memcg aware)
  }
  
  static unsigned long deferred_split_scan(struct shrinker *shrink,
@@@ -2828,9 -2913,14 +2893,18 @@@
  	struct page *page;
  	int split = 0;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&pgdata->split_queue_lock, flags);
++=======
+ #ifdef CONFIG_MEMCG
+ 	if (sc->memcg)
+ 		ds_queue = &sc->memcg->deferred_split_queue;
+ #endif
+ 
+ 	spin_lock_irqsave(&ds_queue->split_queue_lock, flags);
++>>>>>>> 87eaceb3faa5 (mm: thp: make deferred split shrinker memcg aware)
  	/* Take pin on all head pages to avoid freeing them under us */
 -	list_for_each_safe(pos, next, &ds_queue->split_queue) {
 +	list_for_each_safe(pos, next, &pgdata->split_queue) {
  		page = list_entry((void *)pos, struct page, mapping);
  		page = compound_head(page);
  		if (get_page_unless_zero(page)) {
diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h
index 611b36215cc5..bd82cbf33690 100644
--- a/include/linux/huge_mm.h
+++ b/include/linux/huge_mm.h
@@ -245,6 +245,15 @@ static inline bool thp_migration_supported(void)
 	return IS_ENABLED(CONFIG_ARCH_ENABLE_THP_MIGRATION);
 }
 
+static inline struct list_head *page_deferred_list(struct page *page)
+{
+	/*
+	 * Global or memcg deferred list in the second tail pages is
+	 * occupied by compound_head.
+	 */
+	return &page[2].deferred_list;
+}
+
 #else /* CONFIG_TRANSPARENT_HUGEPAGE */
 #define HPAGE_PMD_SHIFT ({ BUILD_BUG(); 0; })
 #define HPAGE_PMD_MASK ({ BUILD_BUG(); 0; })
* Unmerged path include/linux/memcontrol.h
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index b731f80e16cd..69676a5caad5 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -141,6 +141,7 @@ struct page {
 		struct {	/* Second tail page of compound page */
 			unsigned long _compound_pad_1;	/* compound_head */
 			unsigned long _compound_pad_2;
+			/* For both global and memcg */
 			struct list_head deferred_list;
 		};
 		struct {	/* Page table pages */
* Unmerged path mm/huge_memory.c
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 48fa67e8a272..4445d5e855ff 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -4781,6 +4781,11 @@ static struct mem_cgroup *mem_cgroup_alloc(void)
 #endif
 #ifdef CONFIG_CGROUP_WRITEBACK
 	INIT_LIST_HEAD(&memcg->cgwb_list);
+#endif
+#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+	spin_lock_init(&memcg->deferred_split_queue.split_queue_lock);
+	INIT_LIST_HEAD(&memcg->deferred_split_queue.split_queue);
+	memcg->deferred_split_queue.split_queue_len = 0;
 #endif
 	idr_replace(&mem_cgroup_idr, memcg, memcg->id.id);
 	return memcg;
@@ -5161,6 +5166,14 @@ static int mem_cgroup_move_account(struct page *page,
 		__mod_lruvec_state(to_vec, NR_WRITEBACK, nr_pages);
 	}
 
+#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+	if (compound && !list_empty(page_deferred_list(page))) {
+		spin_lock(&from->deferred_split_queue.split_queue_lock);
+		list_del_init(page_deferred_list(page));
+		from->deferred_split_queue.split_queue_len--;
+		spin_unlock(&from->deferred_split_queue.split_queue_lock);
+	}
+#endif
 	/*
 	 * It is safe to change page->mem_cgroup here because the page
 	 * is referenced, charged, and isolated - we can't race with
@@ -5169,6 +5182,17 @@ static int mem_cgroup_move_account(struct page *page,
 
 	/* caller should have done css_get */
 	page->mem_cgroup = to;
+
+#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+	if (compound && list_empty(page_deferred_list(page))) {
+		spin_lock(&to->deferred_split_queue.split_queue_lock);
+		list_add_tail(page_deferred_list(page),
+			      &to->deferred_split_queue.split_queue);
+		to->deferred_split_queue.split_queue_len++;
+		spin_unlock(&to->deferred_split_queue.split_queue_lock);
+	}
+#endif
+
 	spin_unlock_irqrestore(&from->move_lock, flags);
 
 	ret = 0;
