efi/libstub: Distinguish between native/mixed not 32/64 bit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit f958efe97596837f9504fc38d75ef8e284bc0ebd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f958efe9.failed

Currently, we support mixed mode by casting all boot time firmware
calls to 64-bit explicitly on native 64-bit systems, and to 32-bit
on 32-bit systems or 64-bit systems running with 32-bit firmware.

Due to this explicit awareness of the bitness in the code, we do a
lot of casting even on generic code that is shared with other
architectures, where mixed mode does not even exist. This casting
leads to loss of coverage of type checking by the compiler, which
we should try to avoid.

So instead of distinguishing between 32-bit vs 64-bit, distinguish
between native vs mixed, and limit all the nasty casting and
pointer mangling to the code that actually deals with mixed mode.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Cc: Arvind Sankar <nivedita@alum.mit.edu>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: James Morse <james.morse@arm.com>
	Cc: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: https://lkml.kernel.org/r/20191224151025.32482-10-ardb@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit f958efe97596837f9504fc38d75ef8e284bc0ebd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/libstub/efi-stub-helper.c
#	include/linux/efi.h
diff --cc drivers/firmware/efi/libstub/efi-stub-helper.c
index 4996b58244f4,1a814dc235ba..000000000000
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@@ -421,6 -423,32 +421,35 @@@ static efi_status_t efi_file_close(voi
  	return efi_call_proto(efi_file_handle, close, handle);
  }
  
++<<<<<<< HEAD
++=======
+ static efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg,
+ 				    efi_loaded_image_t *image,
+ 				    efi_file_handle_t **__fh)
+ {
+ 	efi_file_io_interface_t *io;
+ 	efi_file_handle_t *fh;
+ 	efi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;
+ 	efi_status_t status;
+ 	void *handle = efi_table_attr(efi_loaded_image, device_handle, image);
+ 
+ 	status = efi_call_early(handle_protocol, handle,
+ 				&fs_proto, (void **)&io);
+ 	if (status != EFI_SUCCESS) {
+ 		efi_printk(sys_table_arg, "Failed to handle fs_proto\n");
+ 		return status;
+ 	}
+ 
+ 	status = efi_call_proto(efi_file_io_interface, open_volume, io, &fh);
+ 	if (status != EFI_SUCCESS)
+ 		efi_printk(sys_table_arg, "Failed to open volume\n");
+ 	else
+ 		*__fh = fh;
+ 
+ 	return status;
+ }
+ 
++>>>>>>> f958efe97596 (efi/libstub: Distinguish between native/mixed not 32/64 bit)
  /*
   * Parse the ASCII string 'cmdline' for EFI options, denoted by the efi=
   * option, e.g. efi=nochunk.
diff --cc include/linux/efi.h
index 2452f36aa11e,e9d74e9667c0..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -48,6 -48,19 +48,22 @@@ typedef u16 efi_char16_t;		/* UNICODE c
  typedef u64 efi_physical_addr_t;
  typedef void *efi_handle_t;
  
++<<<<<<< HEAD
++=======
+ #define efi_get_handle_at(array, idx)					\
+ 	(efi_is_native() ? (array)[idx] 				\
+ 		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
+ 
+ #define efi_get_handle_num(size)					\
+ 	((size) / (efi_is_native() ? sizeof(efi_handle_t) : sizeof(u32)))
+ 
+ #define for_each_efi_handle(handle, array, size, i)			\
+ 	for (i = 0;							\
+ 	     i < efi_get_handle_num(size) &&				\
+ 		((handle = efi_get_handle_at((array), i)) || true);	\
+ 	     i++)
+ 
++>>>>>>> f958efe97596 (efi/libstub: Distinguish between native/mixed not 32/64 bit)
  /*
   * The UEFI spec and EDK2 reference implementation both define EFI_GUID as
   * struct { u32 a; u16; b; u16 c; u8 d[8]; }; and so the implied alignment
@@@ -707,9 -802,12 +723,18 @@@ typedef struct 
  	u32 table;
  } efi_config_table_32_t;
  
++<<<<<<< HEAD
 +typedef struct {
 +	efi_guid_t guid;
 +	unsigned long table;
++=======
+ typedef union {
+ 	struct {
+ 		efi_guid_t guid;
+ 		void *table;
+ 	};
+ 	efi_config_table_32_t mixed_mode;
++>>>>>>> f958efe97596 (efi/libstub: Distinguish between native/mixed not 32/64 bit)
  } efi_config_table_t;
  
  typedef struct {
diff --git a/arch/arm/include/asm/efi.h b/arch/arm/include/asm/efi.h
index 17f1f1a814ff..20a78cf9b109 100644
--- a/arch/arm/include/asm/efi.h
+++ b/arch/arm/include/asm/efi.h
@@ -56,7 +56,7 @@ void efi_virtmap_unload(void);
 #define efi_call_early(f, ...)		sys_table_arg->boottime->f(__VA_ARGS__)
 #define __efi_call_early(f, ...)	f(__VA_ARGS__)
 #define efi_call_runtime(f, ...)	sys_table_arg->runtime->f(__VA_ARGS__)
-#define efi_is_64bit()			(false)
+#define efi_is_native()			(true)
 
 #define efi_call_proto(protocol, f, instance, ...)			\
 	((protocol##_t *)instance)->f(instance, ##__VA_ARGS__)
diff --git a/arch/arm64/include/asm/efi.h b/arch/arm64/include/asm/efi.h
index f818427e1750..20c3c149cfaf 100644
--- a/arch/arm64/include/asm/efi.h
+++ b/arch/arm64/include/asm/efi.h
@@ -96,7 +96,7 @@ static inline unsigned long efi_get_max_initrd_addr(unsigned long dram_base,
 #define efi_call_early(f, ...)		sys_table_arg->boottime->f(__VA_ARGS__)
 #define __efi_call_early(f, ...)	f(__VA_ARGS__)
 #define efi_call_runtime(f, ...)	sys_table_arg->runtime->f(__VA_ARGS__)
-#define efi_is_64bit()			(true)
+#define efi_is_native()			(true)
 
 #define efi_call_proto(protocol, f, instance, ...)			\
 	((protocol##_t *)instance)->f(instance, ##__VA_ARGS__)
diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c
index 10bf056d4aae..a1a507c9a0b2 100644
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@ -126,8 +126,7 @@ __setup_efi_pci(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)
 	 * large romsize. The UEFI spec limits the size of option ROMs to 16
 	 * MiB so we reject any ROMs over 16 MiB in size to catch this.
 	 */
-	romimage = (void *)(unsigned long)efi_table_attr(efi_pci_io_protocol,
-							 romimage, pci);
+	romimage = efi_table_attr(efi_pci_io_protocol, romimage, pci);
 	romsize = efi_table_attr(efi_pci_io_protocol, romsize, pci);
 	if (!romimage || !romsize || romsize > SZ_16M)
 		return EFI_INVALID_PARAMETER;
diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 7ae8753092d9..8e9ca7734154 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -226,24 +226,45 @@ static inline bool efi_is_64bit(void)
 	return __efi_early()->is64;
 }
 
-#define efi_table_attr(table, attr, instance)				\
-	(efi_is_64bit() ?						\
-		((table##_64_t *)(unsigned long)instance)->attr :	\
-		((table##_32_t *)(unsigned long)instance)->attr)
+static inline bool efi_is_native(void)
+{
+	if (!IS_ENABLED(CONFIG_X86_64))
+		return true;
+	return efi_is_64bit();
+}
+
+#define efi_mixed_mode_cast(attr)					\
+	__builtin_choose_expr(						\
+		__builtin_types_compatible_p(u32, __typeof__(attr)),	\
+			(unsigned long)(attr), (attr))
+
+#define efi_table_attr(table, attr, instance) ({			\
+	__typeof__(((table##_t *)0)->attr) __ret;			\
+	if (efi_is_native()) {						\
+		__ret = ((table##_t *)(unsigned long)instance)->attr;	\
+	} else {							\
+		__ret = (__typeof__(__ret))efi_mixed_mode_cast(		\
+		((table##_t *)(unsigned long)instance)->mixed_mode.attr);\
+	}								\
+	__ret;								\
+})
 
 #define efi_call_proto(protocol, f, instance, ...)			\
-	__efi_early()->call(efi_table_attr(protocol, f, instance),	\
+	__efi_early()->call((unsigned long)				\
+				efi_table_attr(protocol, f, instance),	\
 		instance, ##__VA_ARGS__)
 
 #define efi_call_early(f, ...)						\
-	__efi_early()->call(efi_table_attr(efi_boot_services, f,	\
+	__efi_early()->call((unsigned long)				\
+				efi_table_attr(efi_boot_services, f,	\
 		__efi_early()->boot_services), __VA_ARGS__)
 
 #define __efi_call_early(f, ...)					\
 	__efi_early()->call((unsigned long)f, __VA_ARGS__);
 
 #define efi_call_runtime(f, ...)					\
-	__efi_early()->call(efi_table_attr(efi_runtime_services, f,	\
+	__efi_early()->call((unsigned long)				\
+				efi_table_attr(efi_runtime_services, f,	\
 		__efi_early()->runtime_services), __VA_ARGS__)
 
 extern bool efi_reboot_required(void);
* Unmerged path drivers/firmware/efi/libstub/efi-stub-helper.c
* Unmerged path include/linux/efi.h
