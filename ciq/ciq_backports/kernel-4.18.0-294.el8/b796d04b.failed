tcp: factor out tcp_build_frag()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit b796d04bd014fd24e60ab4a6c604b258ac947825
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b796d04b.failed

Will be needed by the next patch, as MPTCP needs to handle
directly the error/memory-allocation-needed path.

No functional changes intended.

Additionally let MPTCP code access the tcp_remove_empty_skb()
helper.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit b796d04bd014fd24e60ab4a6c604b258ac947825)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
diff --cc net/ipv4/tcp.c
index dd99d1454bf2,a40981e347c0..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -987,60 -1061,13 +1049,36 @@@ ssize_t do_tcp_sendpages(struct sock *s
  		goto out_err;
  
  	while (size > 0) {
- 		struct sk_buff *skb = tcp_write_queue_tail(sk);
- 		int copy, i;
- 		bool can_coalesce;
- 
- 		if (!skb || (copy = size_goal - skb->len) <= 0 ||
- 		    !tcp_skb_can_collapse_to(skb)) {
- new_segment:
- 			if (!sk_stream_memory_free(sk))
- 				goto wait_for_space;
- 
- 			skb = sk_stream_alloc_skb(sk, 0, sk->sk_allocation,
- 					tcp_rtx_and_write_queues_empty(sk));
- 			if (!skb)
- 				goto wait_for_space;
+ 		struct sk_buff *skb;
+ 		size_t copy = size;
  
- #ifdef CONFIG_TLS_DEVICE
- 			skb->decrypted = !!(flags & MSG_SENDPAGE_DECRYPTED);
- #endif
- 			skb_entail(sk, skb);
- 			copy = size_goal;
- 		}
- 
- 		if (copy > size)
- 			copy = size;
- 
- 		i = skb_shinfo(skb)->nr_frags;
- 		can_coalesce = skb_can_coalesce(skb, i, page, offset);
- 		if (!can_coalesce && i >= sysctl_max_skb_frags) {
- 			tcp_mark_push(tp, skb);
- 			goto new_segment;
- 		}
- 		if (!sk_wmem_schedule(sk, copy))
+ 		skb = tcp_build_frag(sk, size_goal, flags, page, offset, &copy);
+ 		if (!skb)
  			goto wait_for_space;
  
++<<<<<<< HEAD
 +		if (can_coalesce) {
 +			skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
 +		} else {
 +			get_page(page);
 +			skb_fill_page_desc(skb, i, page, offset, copy);
 +		}
 +
 +		if (!(flags & MSG_NO_SHARED_FRAGS))
 +			skb_shinfo(skb)->tx_flags |= SKBTX_SHARED_FRAG;
 +
 +		skb->len += copy;
 +		skb->data_len += copy;
 +		skb->truesize += copy;
 +		sk_wmem_queued_add(sk, copy);
 +		sk_mem_charge(sk, copy);
 +		skb->ip_summed = CHECKSUM_PARTIAL;
 +		tp->write_seq += copy;
 +		TCP_SKB_CB(skb)->end_seq += copy;
 +		tcp_skb_pcount_set(skb, 0);
 +
++=======
++>>>>>>> b796d04bd014 (tcp: factor out tcp_build_frag())
  		if (!copied)
  			TCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_PSH;
  
diff --git a/include/net/tcp.h b/include/net/tcp.h
index eae45c2b29be..dd4ea718c207 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -324,6 +324,7 @@ void tcp_shutdown(struct sock *sk, int how);
 int tcp_v4_early_demux(struct sk_buff *skb);
 int tcp_v4_rcv(struct sk_buff *skb);
 
+void tcp_remove_empty_skb(struct sock *sk, struct sk_buff *skb);
 int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
 int tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);
 int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size);
@@ -331,6 +332,8 @@ int tcp_sendpage(struct sock *sk, struct page *page, int offset, size_t size,
 		 int flags);
 int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
 			size_t size, int flags);
+struct sk_buff *tcp_build_frag(struct sock *sk, int size_goal, int flags,
+			       struct page *page, int offset, size_t *size);
 ssize_t do_tcp_sendpages(struct sock *sk, struct page *page, int offset,
 		 size_t size, int flags);
 int tcp_send_mss(struct sock *sk, int *size_goal, int flags);
* Unmerged path net/ipv4/tcp.c
