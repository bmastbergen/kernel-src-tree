mm: Convert collapse_shmem to XArray

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit 77da9389b9d5f07d54fda092d1ab56002ec0019a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/77da9389.failed

I found another victim of the radix tree being hard to use.  Because
there was no call to radix_tree_preload(), khugepaged was allocating
radix_tree_nodes using GFP_ATOMIC.

I also converted a local_irq_save()/restore() pair to
disable()/enable().

	Signed-off-by: Matthew Wilcox <willy@infradead.org>
(cherry picked from commit 77da9389b9d5f07d54fda092d1ab56002ec0019a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/khugepaged.c
diff --cc mm/khugepaged.c
index c30f4f2474d7,9610e8cba545..000000000000
--- a/mm/khugepaged.c
+++ b/mm/khugepaged.c
@@@ -1525,16 -1494,15 +1498,25 @@@ xa_unlocked
  
  		khugepaged_pages_collapsed++;
  	} else {
++<<<<<<< HEAD
 +		/* Something went wrong: rollback changes to the radix-tree */
 +		xa_lock_irq(&mapping->i_pages);
 +		mapping->nrpages -= nr_none;
 +		shmem_uncharge(mapping->host, nr_none);
 +		radix_tree_for_each_slot(slot, &mapping->i_pages, &iter, start) {
 +			if (iter.index >= end)
 +				break;
++=======
+ 		struct page *page;
+ 		/* Something went wrong: roll back page cache changes */
+ 		shmem_uncharge(mapping->host, nr_none);
+ 		xas_lock_irq(&xas);
+ 		xas_set(&xas, start);
+ 		xas_for_each(&xas, page, end - 1) {
++>>>>>>> 77da9389b9d5 (mm: Convert collapse_shmem to XArray)
  			page = list_first_entry_or_null(&pagelist,
  					struct page, lru);
- 			if (!page || iter.index < page->index) {
+ 			if (!page || xas.xa_index < page->index) {
  				if (!nr_none)
  					break;
  				nr_none--;
* Unmerged path mm/khugepaged.c
