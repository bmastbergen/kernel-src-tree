drivers: Introduce device lookup variants by fwnode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Suzuki K Poulose <suzuki.poulose@arm.com>
commit 67843bbaf36eb087714f40e783ee78e99e9e4b86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/67843bba.failed

Add a helper to match the firmware node handle of a device and provide
wrappers for {bus/class/driver}_find_device() APIs to avoid proliferation
of duplicate custom match functions.

	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Doug Ledford <dledford@redhat.com>
	Cc: Jason Gunthorpe <jgg@ziepe.ca>
	Cc: linux-usb@vger.kernel.org
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: Ulf Hansson <ulf.hansson@linaro.org>
	Cc: Joe Perches <joe@perches.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Acked-by: Robin Murphy <robin.murphy@arm.com>
	Reviewed-by: Mathieu Poirier <mathieu.poirier@linaro.org>
	Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Link: https://lore.kernel.org/r/20190723221838.12024-4-suzuki.poulose@arm.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 67843bbaf36eb087714f40e783ee78e99e9e4b86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/devcon.c
#	drivers/hwtracing/coresight/coresight-platform.c
#	drivers/hwtracing/coresight/coresight-priv.h
#	drivers/hwtracing/coresight/coresight.c
#	include/linux/device.h
diff --cc drivers/base/devcon.c
index f7035fc12b92,1d488dc5dd0c..000000000000
--- a/drivers/base/devcon.c
+++ b/drivers/base/devcon.c
@@@ -133,11 -133,6 +133,14 @@@ static struct bus_type *generic_match_b
  	NULL,
  };
  
++<<<<<<< HEAD
 +static int device_fwnode_match(struct device *dev, void *fwnode)
 +{
 +	return dev_fwnode(dev) == fwnode;
 +}
 +
++=======
++>>>>>>> 67843bbaf36e (drivers: Introduce device lookup variants by fwnode)
  static void *device_connection_fwnode_match(struct device_connection *con)
  {
  	struct bus_type *bus;
diff --cc drivers/hwtracing/coresight/coresight-priv.h
index 0e5a74dae6a6,61d7f9ff054d..000000000000
--- a/drivers/hwtracing/coresight/coresight-priv.h
+++ b/drivers/hwtracing/coresight/coresight-priv.h
@@@ -144,4 -161,45 +144,48 @@@ static inline int etm_readl_cp14(u32 of
  static inline int etm_writel_cp14(u32 off, u32 val) { return 0; }
  #endif
  
++<<<<<<< HEAD
++=======
+ /*
+  * Macros and inline functions to handle CoreSight UCI data and driver
+  * private data in AMBA ID table entries, and extract data values.
+  */
+ 
+ /* coresight AMBA ID, no UCI, no driver data: id table entry */
+ #define CS_AMBA_ID(pid)			\
+ 	{				\
+ 		.id	= pid,		\
+ 		.mask	= 0x000fffff,	\
+ 	}
+ 
+ /* coresight AMBA ID, UCI with driver data only: id table entry. */
+ #define CS_AMBA_ID_DATA(pid, dval)				\
+ 	{							\
+ 		.id	= pid,					\
+ 		.mask	= 0x000fffff,				\
+ 		.data	=  (void *)&(struct amba_cs_uci_id)	\
+ 			{				\
+ 				.data = (void *)dval,	\
+ 			}				\
+ 	}
+ 
+ /* coresight AMBA ID, full UCI structure: id table entry. */
+ #define CS_AMBA_UCI_ID(pid, uci_ptr)	\
+ 	{				\
+ 		.id	= pid,		\
+ 		.mask	= 0x000fffff,	\
+ 		.data	= uci_ptr	\
+ 	}
+ 
+ /* extract the data value from a UCI structure given amba_id pointer. */
+ static inline void *coresight_get_uci_data(const struct amba_id *id)
+ {
+ 	if (id->data)
+ 		return ((struct amba_cs_uci_id *)(id->data))->data;
+ 	return 0;
+ }
+ 
+ void coresight_release_platform_data(struct coresight_platform_data *pdata);
+ 
++>>>>>>> 67843bbaf36e (drivers: Introduce device lookup variants by fwnode)
  #endif
diff --cc drivers/hwtracing/coresight/coresight.c
index 8d8cd6b4a220,6453c67a4d01..000000000000
--- a/drivers/hwtracing/coresight/coresight.c
+++ b/drivers/hwtracing/coresight/coresight.c
@@@ -840,13 -1042,11 +840,17 @@@ static void coresight_fixup_device_conn
  {
  	int i;
  
 -	for (i = 0; i < csdev->pdata->nr_outport; i++) {
 -		struct coresight_connection *conn = &csdev->pdata->conns[i];
 +	for (i = 0; i < csdev->nr_outport; i++) {
 +		struct coresight_connection *conn = &csdev->conns[i];
  		struct device *dev = NULL;
  
++<<<<<<< HEAD
 +		if (conn->child_name)
 +			dev = bus_find_device_by_name(&coresight_bustype, NULL,
 +						      conn->child_name);
++=======
+ 		dev = bus_find_device_by_fwnode(&coresight_bustype, conn->child_fwnode);
++>>>>>>> 67843bbaf36e (drivers: Introduce device lookup variants by fwnode)
  		if (dev) {
  			conn->child_dev = to_coresight_device(dev);
  			/* and put reference from 'bus_find_device()' */
diff --cc include/linux/device.h
index 27ff9f1dce60,7133fc1c285d..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -167,9 -164,9 +167,10 @@@ void subsys_dev_iter_init(struct subsys
  struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter);
  void subsys_dev_iter_exit(struct subsys_dev_iter *iter);
  
 +int device_match_acpi_dev(struct device *dev, const void *adev);
  int device_match_name(struct device *dev, const void *name);
  int device_match_of_node(struct device *dev, const void *np);
+ int device_match_fwnode(struct device *dev, const void *fwnode);
  
  int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data,
  		     int (*fn)(struct device *dev, void *data));
@@@ -202,27 -199,17 +203,41 @@@ bus_find_device_by_of_node(struct bus_t
  	return bus_find_device(bus, NULL, np, device_match_of_node);
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_ACPI
 +struct acpi_device;
 +
 +/**
 + * bus_find_device_by_acpi_dev : device iterator for locating a particular device
 + * matching the ACPI COMPANION device.
 + * @bus: bus type
 + * @adev: ACPI COMPANION device to match.
 + */
 +static inline struct device *
 +bus_find_device_by_acpi_dev(struct bus_type *bus, const struct acpi_device *adev)
 +{
 +	return bus_find_device(bus, NULL, adev, device_match_acpi_dev);
 +}
 +#else
 +static inline struct device *
 +bus_find_device_by_acpi_dev(struct bus_type *bus, const void *adev)
 +{
 +	return NULL;
 +}
 +#endif
++=======
+ /**
+  * bus_find_device_by_fwnode : device iterator for locating a particular device
+  * matching the fwnode.
+  * @bus: bus type
+  * @fwnode: fwnode of the device to match.
+  */
+ static inline struct device *
+ bus_find_device_by_fwnode(struct bus_type *bus, const struct fwnode_handle *fwnode)
+ {
+ 	return bus_find_device(bus, NULL, fwnode, device_match_fwnode);
+ }
++>>>>>>> 67843bbaf36e (drivers: Introduce device lookup variants by fwnode)
  
  struct device *subsys_find_device_by_id(struct bus_type *bus, unsigned int id,
  					struct device *hint);
@@@ -451,6 -404,20 +466,23 @@@ driver_find_device_by_of_node(struct de
  	return driver_find_device(drv, NULL, np, device_match_of_node);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * driver_find_device_by_fwnode- device iterator for locating a particular device
+  * by fwnode pointer.
+  * @driver: the driver we're iterating
+  * @fwnode: fwnode pointer to match.
+  */
+ static inline struct device *
+ driver_find_device_by_fwnode(struct device_driver *drv,
+ 			     const struct fwnode_handle *fwnode)
+ {
+ 	return driver_find_device(drv, NULL, fwnode, device_match_fwnode);
+ }
+ 
+ void driver_deferred_probe_add(struct device *dev);
++>>>>>>> 67843bbaf36e (drivers: Introduce device lookup variants by fwnode)
  int driver_deferred_probe_check_state(struct device *dev);
  int driver_deferred_probe_check_state_continue(struct device *dev);
  
* Unmerged path drivers/hwtracing/coresight/coresight-platform.c
diff --git a/drivers/base/core.c b/drivers/base/core.c
index d7dfbeaf0c45..23d34c8a7507 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3189,3 +3189,9 @@ int device_match_of_node(struct device *dev, const void *np)
 	return dev->of_node == np;
 }
 EXPORT_SYMBOL_GPL(device_match_of_node);
+
+int device_match_fwnode(struct device *dev, const void *fwnode)
+{
+	return dev_fwnode(dev) == fwnode;
+}
+EXPORT_SYMBOL_GPL(device_match_fwnode);
* Unmerged path drivers/base/devcon.c
* Unmerged path drivers/hwtracing/coresight/coresight-platform.c
* Unmerged path drivers/hwtracing/coresight/coresight-priv.h
* Unmerged path drivers/hwtracing/coresight/coresight.c
diff --git a/drivers/infiniband/hw/hns/hns_roce_hw_v1.c b/drivers/infiniband/hw/hns/hns_roce_hw_v1.c
index 1bddbd5ad5cb..8d4e1d9dfa0c 100644
--- a/drivers/infiniband/hw/hns/hns_roce_hw_v1.c
+++ b/drivers/infiniband/hw/hns/hns_roce_hw_v1.c
@@ -4490,19 +4490,13 @@ static const struct acpi_device_id hns_roce_acpi_match[] = {
 };
 MODULE_DEVICE_TABLE(acpi, hns_roce_acpi_match);
 
-static int hns_roce_node_match(struct device *dev, const void *fwnode)
-{
-	return dev->fwnode == fwnode;
-}
-
 static struct
 platform_device *hns_roce_find_pdev(struct fwnode_handle *fwnode)
 {
 	struct device *dev;
 
 	/* get the 'device' corresponding to the matching 'fwnode' */
-	dev = bus_find_device(&platform_bus_type, NULL,
-			      fwnode, hns_roce_node_match);
+	dev = bus_find_device_by_fwnode(&platform_bus_type, fwnode);
 	/* get the platform device */
 	return dev ? to_platform_device(dev) : NULL;
 }
diff --git a/drivers/iommu/arm-smmu-v3.c b/drivers/iommu/arm-smmu-v3.c
index d076622e2dd4..0ba26d934e8a 100644
--- a/drivers/iommu/arm-smmu-v3.c
+++ b/drivers/iommu/arm-smmu-v3.c
@@ -2510,16 +2510,11 @@ arm_smmu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova)
 
 static struct platform_driver arm_smmu_driver;
 
-static int arm_smmu_match_node(struct device *dev, const void *data)
-{
-	return dev->fwnode == data;
-}
-
 static
 struct arm_smmu_device *arm_smmu_get_by_fwnode(struct fwnode_handle *fwnode)
 {
-	struct device *dev = driver_find_device(&arm_smmu_driver.driver, NULL,
-						fwnode, arm_smmu_match_node);
+	struct device *dev = driver_find_device_by_fwnode(&arm_smmu_driver.driver,
+							  fwnode);
 	put_device(dev);
 	return dev ? dev_get_drvdata(dev) : NULL;
 }
diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c
index 9705df08ff99..d92aa4217385 100644
--- a/drivers/iommu/arm-smmu.c
+++ b/drivers/iommu/arm-smmu.c
@@ -1479,16 +1479,11 @@ static bool arm_smmu_capable(enum iommu_cap cap)
 	}
 }
 
-static int arm_smmu_match_node(struct device *dev, const void *data)
-{
-	return dev->fwnode == data;
-}
-
 static
 struct arm_smmu_device *arm_smmu_get_by_fwnode(struct fwnode_handle *fwnode)
 {
-	struct device *dev = driver_find_device(&arm_smmu_driver.driver, NULL,
-						fwnode, arm_smmu_match_node);
+	struct device *dev = driver_find_device_by_fwnode(&arm_smmu_driver.driver,
+							  fwnode);
 	put_device(dev);
 	return dev ? dev_get_drvdata(dev) : NULL;
 }
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_misc.c b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_misc.c
index 3148c6cfa801..3f6e4a051c81 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_misc.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_misc.c
@@ -758,17 +758,11 @@ struct dsaf_misc_op *hns_misc_op_get(struct dsaf_device *dsaf_dev)
 	return (void *)misc_op;
 }
 
-static int hns_dsaf_dev_match(struct device *dev, const void *fwnode)
-{
-	return dev->fwnode == fwnode;
-}
-
 struct
 platform_device *hns_dsaf_find_platform_device(struct fwnode_handle *fwnode)
 {
 	struct device *dev;
 
-	dev = bus_find_device(&platform_bus_type, NULL,
-			      fwnode, hns_dsaf_dev_match);
+	dev = bus_find_device_by_fwnode(&platform_bus_type, fwnode);
 	return dev ? to_platform_device(dev) : NULL;
 }
diff --git a/drivers/usb/roles/class.c b/drivers/usb/roles/class.c
index c8efe60e2465..0526efbc4922 100644
--- a/drivers/usb/roles/class.c
+++ b/drivers/usb/roles/class.c
@@ -85,11 +85,6 @@ enum usb_role usb_role_switch_get_role(struct usb_role_switch *sw)
 }
 EXPORT_SYMBOL_GPL(usb_role_switch_get_role);
 
-static int switch_fwnode_match(struct device *dev, const void *fwnode)
-{
-	return dev_fwnode(dev) == fwnode;
-}
-
 static void *usb_role_switch_match(struct device_connection *con, int ep,
 				   void *data)
 {
@@ -99,8 +94,7 @@ static void *usb_role_switch_match(struct device_connection *con, int ep,
 		if (con->id && !fwnode_property_present(con->fwnode, con->id))
 			return NULL;
 
-		dev = class_find_device(role_class, NULL, con->fwnode,
-					switch_fwnode_match);
+		dev = class_find_device_by_fwnode(role_class, con->fwnode);
 	} else {
 		dev = class_find_device_by_name(role_class, con->endpoint[ep]);
 	}
diff --git a/drivers/usb/typec/class.c b/drivers/usb/typec/class.c
index 18a0687a47bd..af4fb7355d3a 100644
--- a/drivers/usb/typec/class.c
+++ b/drivers/usb/typec/class.c
@@ -205,11 +205,6 @@ static void typec_altmode_put_partner(struct altmode *altmode)
 	put_device(&adev->dev);
 }
 
-static int typec_port_fwnode_match(struct device *dev, const void *fwnode)
-{
-	return dev_fwnode(dev) == fwnode;
-}
-
 static void *typec_port_match(struct device_connection *con, int ep, void *data)
 {
 	struct device *dev;
@@ -219,8 +214,7 @@ static void *typec_port_match(struct device_connection *con, int ep, void *data)
 	 * we need to return ERR_PTR(-PROBE_DEFER) when there is no device.
 	 */
 	if (con->fwnode)
-		return class_find_device(typec_class, NULL, con->fwnode,
-					 typec_port_fwnode_match);
+		return class_find_device_by_fwnode(typec_class, con->fwnode);
 
 	dev = class_find_device_by_name(typec_class, con->endpoint[ep]);
 
* Unmerged path include/linux/device.h
