KVM: VMX: Ignore userspace MSR filters for x2APIC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 9389b9d5d3566b5687829a4098e715f0016451c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9389b9d5.failed

Rework the resetting of the MSR bitmap for x2APIC MSRs to ignore userspace
filtering.  Allowing userspace to intercept reads to x2APIC MSRs when
APICV is fully enabled for the guest simply can't work; the LAPIC and thus
virtual APIC is in-kernel and cannot be directly accessed by userspace.
To keep things simple we will in fact forbid intercepting x2APIC MSRs
altogether, independent of the default_allow setting.

	Cc: Alexander Graf <graf@amazon.com>
	Cc: Aaron Lewis <aaronlewis@google.com>
	Cc: Peter Xu <peterx@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20201005195532.8674-3-sean.j.christopherson@intel.com>
[Modified to operate even if APICv is disabled, adjust documentation. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9389b9d5d3566b5687829a4098e715f0016451c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virt/kvm/api.rst
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/x86.c
diff --cc Documentation/virt/kvm/api.rst
index 235a1db41e51,bd94105f2960..000000000000
--- a/Documentation/virt/kvm/api.rst
+++ b/Documentation/virt/kvm/api.rst
@@@ -4701,6 -4707,104 +4701,107 @@@ KVM_PV_VM_VERIF
    Verify the integrity of the unpacked image. Only if this succeeds,
    KVM is allowed to start protected VCPUs.
  
++<<<<<<< HEAD
++=======
+ 4.126 KVM_X86_SET_MSR_FILTER
+ ----------------------------
+ 
+ :Capability: KVM_X86_SET_MSR_FILTER
+ :Architectures: x86
+ :Type: vm ioctl
+ :Parameters: struct kvm_msr_filter
+ :Returns: 0 on success, < 0 on error
+ 
+ ::
+ 
+   struct kvm_msr_filter_range {
+   #define KVM_MSR_FILTER_READ  (1 << 0)
+   #define KVM_MSR_FILTER_WRITE (1 << 1)
+ 	__u32 flags;
+ 	__u32 nmsrs; /* number of msrs in bitmap */
+ 	__u32 base;  /* MSR index the bitmap starts at */
+ 	__u8 *bitmap; /* a 1 bit allows the operations in flags, 0 denies */
+   };
+ 
+   #define KVM_MSR_FILTER_MAX_RANGES 16
+   struct kvm_msr_filter {
+   #define KVM_MSR_FILTER_DEFAULT_ALLOW (0 << 0)
+   #define KVM_MSR_FILTER_DEFAULT_DENY  (1 << 0)
+ 	__u32 flags;
+ 	struct kvm_msr_filter_range ranges[KVM_MSR_FILTER_MAX_RANGES];
+   };
+ 
+ flags values for ``struct kvm_msr_filter_range``:
+ 
+ ``KVM_MSR_FILTER_READ``
+ 
+   Filter read accesses to MSRs using the given bitmap. A 0 in the bitmap
+   indicates that a read should immediately fail, while a 1 indicates that
+   a read for a particular MSR should be handled regardless of the default
+   filter action.
+ 
+ ``KVM_MSR_FILTER_WRITE``
+ 
+   Filter write accesses to MSRs using the given bitmap. A 0 in the bitmap
+   indicates that a write should immediately fail, while a 1 indicates that
+   a write for a particular MSR should be handled regardless of the default
+   filter action.
+ 
+ ``KVM_MSR_FILTER_READ | KVM_MSR_FILTER_WRITE``
+ 
+   Filter both read and write accesses to MSRs using the given bitmap. A 0
+   in the bitmap indicates that both reads and writes should immediately fail,
+   while a 1 indicates that reads and writes for a particular MSR are not
+   filtered by this range.
+ 
+ flags values for ``struct kvm_msr_filter``:
+ 
+ ``KVM_MSR_FILTER_DEFAULT_ALLOW``
+ 
+   If no filter range matches an MSR index that is getting accessed, KVM will
+   fall back to allowing access to the MSR.
+ 
+ ``KVM_MSR_FILTER_DEFAULT_DENY``
+ 
+   If no filter range matches an MSR index that is getting accessed, KVM will
+   fall back to rejecting access to the MSR. In this mode, all MSRs that should
+   be processed by KVM need to explicitly be marked as allowed in the bitmaps.
+ 
+ This ioctl allows user space to define up to 16 bitmaps of MSR ranges to
+ specify whether a certain MSR access should be explicitly filtered for or not.
+ 
+ If this ioctl has never been invoked, MSR accesses are not guarded and the
+ default KVM in-kernel emulation behavior is fully preserved.
+ 
+ As soon as the filtering is in place, every MSR access is processed through
+ the filtering except for accesses to the x2APIC MSRs (from 0x800 to 0x8ff);
+ x2APIC MSRs are always allowed, independent of the ``default_allow`` setting,
+ and their behavior depends on the ``X2APIC_ENABLE`` bit of the APIC base
+ register.
+ 
+ If a bit is within one of the defined ranges, read and write
+ accesses are guarded by the bitmap's value for the MSR index. If it is not
+ defined in any range, whether MSR access is rejected is determined by the flags
+ field in the kvm_msr_filter struct: ``KVM_MSR_FILTER_DEFAULT_ALLOW`` and
+ ``KVM_MSR_FILTER_DEFAULT_DENY``.
+ 
+ Calling this ioctl with an empty set of ranges (all nmsrs == 0) disables MSR
+ filtering. In that mode, KVM_MSR_FILTER_DEFAULT_DENY no longer has any effect.
+ 
+ Each bitmap range specifies a range of MSRs to potentially allow access on.
+ The range goes from MSR index [base .. base+nmsrs]. The flags field
+ indicates whether reads, writes or both reads and writes are filtered
+ by setting a 1 bit in the bitmap for the corresponding MSR index.
+ 
+ If an MSR access is not permitted through the filtering, it generates a
+ #GP inside the guest. When combined with KVM_CAP_X86_USER_SPACE_MSR, that
+ allows user space to deflect and potentially handle various MSR accesses
+ into user space.
+ 
+ If a vCPU is in running state while this ioctl is invoked, the vCPU may
+ experience inconsistent filtering behavior on MSR accesses.
+ 
++>>>>>>> 9389b9d5d356 (KVM: VMX: Ignore userspace MSR filters for x2APIC)
  
  5. The kvm_run structure
  ========================
diff --cc arch/x86/kvm/vmx/vmx.c
index 985a4bfb7517,132a8cc9f9a4..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -3694,28 -3782,41 +3694,67 @@@ static u8 vmx_msr_bitmap_mode(struct kv
  	return mode;
  }
  
++<<<<<<< HEAD
 +static void vmx_update_msr_bitmap_x2apic(unsigned long *msr_bitmap,
 +					 u8 mode)
++=======
+ static void vmx_reset_x2apic_msrs(struct kvm_vcpu *vcpu, u8 mode)
++>>>>>>> 9389b9d5d356 (KVM: VMX: Ignore userspace MSR filters for x2APIC)
  {
+ 	unsigned long *msr_bitmap = to_vmx(vcpu)->vmcs01.msr_bitmap;
+ 	unsigned long read_intercept;
  	int msr;
  
++<<<<<<< HEAD
 +	for (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {
 +		unsigned word = msr / BITS_PER_LONG;
 +		msr_bitmap[word] = (mode & MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;
 +		msr_bitmap[word + (0x800 / sizeof(long))] = ~0;
++=======
+ 	read_intercept = (mode & MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;
+ 
+ 	for (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {
+ 		unsigned int read_idx = msr / BITS_PER_LONG;
+ 		unsigned int write_idx = read_idx + (0x800 / sizeof(long));
+ 
+ 		msr_bitmap[read_idx] = read_intercept;
+ 		msr_bitmap[write_idx] = ~0ul;
++>>>>>>> 9389b9d5d356 (KVM: VMX: Ignore userspace MSR filters for x2APIC)
  	}
+ }
  
++<<<<<<< HEAD
 +	if (mode & MSR_BITMAP_MODE_X2APIC) {
 +		/*
 +		 * TPR reads and writes can be virtualized even if virtual interrupt
 +		 * delivery is not in use.
 +		 */
 +		vmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW);
 +		if (mode & MSR_BITMAP_MODE_X2APIC_APICV) {
 +			vmx_enable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_R);
 +			vmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);
 +			vmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);
 +		}
++=======
+ static void vmx_update_msr_bitmap_x2apic(struct kvm_vcpu *vcpu, u8 mode)
+ {
+ 	if (!cpu_has_vmx_msr_bitmap())
+ 		return;
+ 
+ 	vmx_reset_x2apic_msrs(vcpu, mode);
+ 
+ 	/*
+ 	 * TPR reads and writes can be virtualized even if virtual interrupt
+ 	 * delivery is not in use.
+ 	 */
+ 	vmx_set_intercept_for_msr(vcpu, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW,
+ 				  !(mode & MSR_BITMAP_MODE_X2APIC));
+ 
+ 	if (mode & MSR_BITMAP_MODE_X2APIC_APICV) {
+ 		vmx_enable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_RW);
+ 		vmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);
+ 		vmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);
++>>>>>>> 9389b9d5d356 (KVM: VMX: Ignore userspace MSR filters for x2APIC)
  	}
  }
  
diff --cc arch/x86/kvm/x86.c
index 29982f9947ef,08cfb5e4bd07..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -1484,6 -1488,40 +1484,43 @@@ void kvm_enable_efer_bits(u64 mask
  }
  EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);
  
++<<<<<<< HEAD
++=======
+ bool kvm_msr_allowed(struct kvm_vcpu *vcpu, u32 index, u32 type)
+ {
+ 	struct kvm *kvm = vcpu->kvm;
+ 	struct msr_bitmap_range *ranges = kvm->arch.msr_filter.ranges;
+ 	u32 count = kvm->arch.msr_filter.count;
+ 	u32 i;
+ 	bool r = kvm->arch.msr_filter.default_allow;
+ 	int idx;
+ 
+ 	/* MSR filtering not set up or x2APIC enabled, allow everything */
+ 	if (!count || (index >= 0x800 && index <= 0x8ff))
+ 		return true;
+ 
+ 	/* Prevent collision with set_msr_filter */
+ 	idx = srcu_read_lock(&kvm->srcu);
+ 
+ 	for (i = 0; i < count; i++) {
+ 		u32 start = ranges[i].base;
+ 		u32 end = start + ranges[i].nmsrs;
+ 		u32 flags = ranges[i].flags;
+ 		unsigned long *bitmap = ranges[i].bitmap;
+ 
+ 		if ((index >= start) && (index < end) && (flags & type)) {
+ 			r = !!test_bit(index - start, bitmap);
+ 			break;
+ 		}
+ 	}
+ 
+ 	srcu_read_unlock(&kvm->srcu, idx);
+ 
+ 	return r;
+ }
+ EXPORT_SYMBOL_GPL(kvm_msr_allowed);
+ 
++>>>>>>> 9389b9d5d356 (KVM: VMX: Ignore userspace MSR filters for x2APIC)
  /*
   * Write @data into the MSR specified by @index.  Select MSR specific fault
   * checks are bypassed if @host_initiated is %true.
* Unmerged path Documentation/virt/kvm/api.rst
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/x86.c
