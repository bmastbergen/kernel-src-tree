driver core: Add sync_state driver/bus callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 8f8184d6bf676a8680d6f441e40317d166b46f73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8f8184d6.failed

This sync_state driver/bus callback is called once all the consumers
of a supplier have probed successfully.

This allows the supplier device's driver/bus to sync the supplier
device's state to the software state with the guarantee that all the
consumers are actively managing the resources provided by the supplier
device.

To maintain backwards compatibility and ease transition from existing
frameworks and resource cleanup schemes, late_initcall_sync is the
earliest when the sync_state callback might be called.

There is no upper bound on the time by which the sync_state callback
has to be called. This is because if a consumer device never probes,
the supplier has to maintain its resources in the state left by the
bootloader. For example, if the bootloader leaves the display
backlight at a fixed voltage and the backlight driver is never probed,
you don't want the backlight to ever be turned off after boot up.

Also, when multiple devices are added after kernel init, some
suppliers could be added before their consumer devices get added. In
these instances, the supplier devices could get their sync_state
callback called right after they probe because the consumers devices
haven't had a chance to create device links to the suppliers.

To handle this correctly, this change also provides APIs to
pause/resume sync state callbacks so that when multiple devices are
added, their sync_state callback evaluation can be postponed to happen
after all of them are added.

kbuild test robot reported missing documentation for device.state_synced
	Reported-by: kbuild test robot <lkp@intel.com>
	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20190731221721.187713-5-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 8f8184d6bf676a8680d6f441e40317d166b46f73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/device.h
diff --cc drivers/base/core.c
index 8a0d36852b14,5b1795cd116a..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -44,6 -44,10 +44,13 @@@ early_param("sysfs.deprecated", sysfs_d
  #endif
  
  /* Device links support. */
++<<<<<<< HEAD
++=======
+ static LIST_HEAD(wait_for_suppliers);
+ static DEFINE_MUTEX(wfs_lock);
+ static LIST_HEAD(deferred_sync);
+ static unsigned int supplier_sync_state_disabled;
++>>>>>>> 8f8184d6bf67 (driver core: Add sync_state driver/bus callback)
  
  #ifdef CONFIG_SRCU
  static DEFINE_MUTEX(device_links_lock);
@@@ -1714,6 -1845,8 +1783,11 @@@ void device_initialize(struct device *d
  #endif
  	INIT_LIST_HEAD(&dev->links.consumers);
  	INIT_LIST_HEAD(&dev->links.suppliers);
++<<<<<<< HEAD
++=======
+ 	INIT_LIST_HEAD(&dev->links.needs_suppliers);
+ 	INIT_LIST_HEAD(&dev->links.defer_sync);
++>>>>>>> 8f8184d6bf67 (driver core: Add sync_state driver/bus callback)
  	dev->links.status = DL_DEV_NO_DRIVER;
  }
  EXPORT_SYMBOL_GPL(device_initialize);
diff --cc include/linux/device.h
index bf5cdf5966df,63a3aafabcd6..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -81,8 -78,28 +81,31 @@@ extern void bus_remove_file(struct bus_
   *		-EPROBE_DEFER it will queue the device for deferred probing.
   * @uevent:	Called when a device is added, removed, or a few other things
   *		that generate uevents to add the environment variables.
++<<<<<<< HEAD
++=======
+  * @add_links:	Called, perhaps multiple times per device, after a device is
+  *		added to this bus.  The function is expected to create device
+  *		links to all the suppliers of the input device that are
+  *		available at the time this function is called.  As in, the
+  *		function should NOT stop at the first failed device link if
+  *		other unlinked supplier devices are present in the system.
+  *		This is necessary for the sync_state() callback to work
+  *		correctly.
+  *
+  *		Return 0 if device links have been successfully created to all
+  *		the suppliers of this device.  Return an error if some of the
+  *		suppliers are not yet available and this function needs to be
+  *		reattempted in the future.
++>>>>>>> 8f8184d6bf67 (driver core: Add sync_state driver/bus callback)
   * @probe:	Called when a new device or driver add to this bus, and callback
   *		the specific driver's probe to initial the matched device.
+  * @sync_state:	Called to sync device state to software state after all the
+  *		state tracking consumers linked to this device (present at
+  *		the time of late_initcall) have successfully bound to a
+  *		driver. If the device has no consumers, this function will
+  *		be called at late_initcall_sync level. If the device has
+  *		consumers that are never bound to a driver, this function
+  *		will never get called until they do.
   * @remove:	Called when a device removed from this bus.
   * @shutdown:	Called at shut-down time to quiesce the device.
   *
@@@ -125,7 -142,9 +148,8 @@@ struct bus_type 
  
  	int (*match)(struct device *dev, struct device_driver *drv);
  	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 -	int (*add_links)(struct device *dev);
  	int (*probe)(struct device *dev);
+ 	void (*sync_state)(struct device *dev);
  	int (*remove)(struct device *dev);
  	void (*shutdown)(struct device *dev);
  
@@@ -348,7 -419,9 +379,8 @@@ struct device_driver 
  	const struct of_device_id	*of_match_table;
  	const struct acpi_device_id	*acpi_match_table;
  
 -	int (*edit_links)(struct device *dev);
  	int (*probe) (struct device *dev);
+ 	void (*sync_state)(struct device *dev);
  	int (*remove) (struct device *dev);
  	void (*shutdown) (struct device *dev);
  	int (*suspend) (struct device *dev, pm_message_t state);
@@@ -1037,11 -1173,15 +1069,21 @@@ enum dl_dev_state 
   * struct dev_links_info - Device data related to device links.
   * @suppliers: List of links to supplier devices.
   * @consumers: List of links to consumer devices.
++<<<<<<< HEAD
++=======
+  * @needs_suppliers: Hook to global list of devices waiting for suppliers.
+  * @defer_sync: Hook to global list of devices that have deferred sync_state.
++>>>>>>> 8f8184d6bf67 (driver core: Add sync_state driver/bus callback)
   * @status: Driver status information.
   */
  struct dev_links_info {
  	struct list_head suppliers;
  	struct list_head consumers;
++<<<<<<< HEAD
++=======
+ 	struct list_head needs_suppliers;
+ 	struct list_head defer_sync;
++>>>>>>> 8f8184d6bf67 (driver core: Add sync_state driver/bus callback)
  	enum dl_dev_state status;
  };
  
@@@ -1117,6 -1255,11 +1159,14 @@@ struct device_extended_rh 
   * @offline:	Set after successful invocation of bus type's .offline().
   * @of_node_reused: Set if the device-tree node is shared with an ancestor
   *              device.
++<<<<<<< HEAD
++=======
+  * @has_edit_links: This device has a driver than is capable of
+  *		    editing the device links created by driver core.
+  * @state_synced: The hardware state of this device has been synced to match
+  *		  the software state of this device by calling the driver/bus
+  *		  sync_state() callback.
++>>>>>>> 8f8184d6bf67 (driver core: Add sync_state driver/bus callback)
   * @dma_coherent: this particular device is dma coherent, even if the
   *		architecture supports non-coherent devices.
   *
@@@ -1210,6 -1353,8 +1260,11 @@@ struct device 
  	bool			offline_disabled:1;
  	bool			offline:1;
  	bool			of_node_reused:1;
++<<<<<<< HEAD
++=======
+ 	bool			has_edit_links:1;
+ 	bool			state_synced:1;
++>>>>>>> 8f8184d6bf67 (driver core: Add sync_state driver/bus callback)
  #if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
      defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
      defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
@@@ -1569,6 -1697,13 +1624,16 @@@ struct device_link *device_link_add(str
  				    struct device *supplier, u32 flags);
  void device_link_del(struct device_link *link);
  void device_link_remove(void *consumer, struct device *supplier);
++<<<<<<< HEAD
++=======
+ void device_link_remove_from_wfs(struct device *consumer);
+ void device_links_supplier_sync_state_pause(void);
+ void device_links_supplier_sync_state_resume(void);
+ 
+ #ifndef dev_fmt
+ #define dev_fmt(fmt) fmt
+ #endif
++>>>>>>> 8f8184d6bf67 (driver core: Add sync_state driver/bus callback)
  
  #ifdef CONFIG_PRINTK
  
* Unmerged path drivers/base/core.c
* Unmerged path include/linux/device.h
