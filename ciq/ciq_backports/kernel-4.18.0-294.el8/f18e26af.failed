RDMA/mlx5: Convert modify QP to use MLX5_SET macros

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit f18e26af6aba778b888044859d9c69bb9bbc7bc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f18e26af.failed

Instead of hand crafted mlx5_qp_context and mlx5_qp_path use common
MLX5_SET() macros.

Link: https://lore.kernel.org/r/20200526115440.205922-7-leon@kernel.org
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Reviewed-by: Mark Zhang <markz@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit f18e26af6aba778b888044859d9c69bb9bbc7bc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 68ab87769d36,a24176a8ec83..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -3503,10 -3751,10 +3495,14 @@@ static int __mlx5_ib_modify_qp(struct i
  	struct mlx5_ib_qp *qp = to_mqp(ibqp);
  	struct mlx5_ib_qp_base *base = &qp->trans_qp.base;
  	struct mlx5_ib_cq *send_cq, *recv_cq;
- 	struct mlx5_qp_context *context;
  	struct mlx5_ib_pd *pd;
  	enum mlx5_qp_state mlx5_cur, mlx5_new;
++<<<<<<< HEAD
 +	enum mlx5_qp_optpar optpar;
++=======
+ 	void *qpc, *pri_path, *alt_path;
+ 	enum mlx5_qp_optpar optpar = 0;
++>>>>>>> f18e26af6aba (RDMA/mlx5: Convert modify QP to use MLX5_SET macros)
  	u32 set_id = 0;
  	int mlx5_st;
  	int err;
@@@ -3518,15 -3765,15 +3514,20 @@@
  	if (mlx5_st < 0)
  		return -EINVAL;
  
- 	context = kzalloc(sizeof(*context), GFP_KERNEL);
- 	if (!context)
+ 	qpc = kzalloc(MLX5_ST_SZ_BYTES(qpc), GFP_KERNEL);
+ 	if (!qpc)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	pd = get_pd(qp);
 +	context->flags = cpu_to_be32(mlx5_st << 16);
++=======
+ 	pd = to_mpd(qp->ibqp.pd);
+ 	MLX5_SET(qpc, qpc, st, mlx5_st);
++>>>>>>> f18e26af6aba (RDMA/mlx5: Convert modify QP to use MLX5_SET macros)
  
  	if (!(attr_mask & IB_QP_PATH_MIG_STATE)) {
- 		context->flags |= cpu_to_be32(MLX5_QP_PM_MIGRATED << 11);
+ 		MLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);
  	} else {
  		switch (attr->path_mig_state) {
  		case IB_MIG_MIGRATED:
@@@ -3541,29 -3788,23 +3542,42 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if ((cur_state == IB_QPS_RESET) && (new_state == IB_QPS_INIT)) {
 +		if ((ibqp->qp_type == IB_QPT_RC) ||
 +		    (ibqp->qp_type == IB_QPT_UD &&
 +		     !(qp->flags & MLX5_IB_QP_SQPN_QP1)) ||
 +		    (ibqp->qp_type == IB_QPT_UC) ||
 +		    (ibqp->qp_type == IB_QPT_RAW_PACKET) ||
 +		    (ibqp->qp_type == IB_QPT_XRC_INI) ||
 +		    (ibqp->qp_type == IB_QPT_XRC_TGT)) {
 +			if (dev->lag_active) {
 +				u8 p = mlx5_core_native_port_num(dev->mdev) - 1;
 +				tx_affinity = get_tx_affinity(dev, pd, base, p,
 +							      udata);
 +				context->flags |= cpu_to_be32(tx_affinity << 24);
 +			}
 +		}
 +	}
++=======
+ 	tx_affinity = get_tx_affinity(ibqp, attr, attr_mask,
+ 				      cur_state == IB_QPS_RESET &&
+ 				      new_state == IB_QPS_INIT, udata);
+ 
+ 	MLX5_SET(qpc, qpc, lag_tx_port_affinity, tx_affinity);
+ 	if (tx_affinity && new_state == IB_QPS_RTR &&
+ 	    MLX5_CAP_GEN(dev->mdev, init2_lag_tx_port_affinity))
+ 		optpar |= MLX5_QP_OPTPAR_LAG_TX_AFF;
++>>>>>>> f18e26af6aba (RDMA/mlx5: Convert modify QP to use MLX5_SET macros)
  
  	if (is_sqp(ibqp->qp_type)) {
- 		context->mtu_msgmax = (IB_MTU_256 << 5) | 8;
+ 		MLX5_SET(qpc, qpc, mtu, IB_MTU_256);
+ 		MLX5_SET(qpc, qpc, log_msg_max, 8);
  	} else if ((ibqp->qp_type == IB_QPT_UD &&
 -		    !(qp->flags & IB_QP_CREATE_SOURCE_QPN)) ||
 +		    !(qp->flags & MLX5_IB_QP_UNDERLAY)) ||
  		   ibqp->qp_type == MLX5_IB_QPT_REG_UMR) {
- 		context->mtu_msgmax = (IB_MTU_4096 << 5) | 12;
+ 		MLX5_SET(qpc, qpc, mtu, IB_MTU_4096);
+ 		MLX5_SET(qpc, qpc, log_msg_max, 12);
  	} else if (attr_mask & IB_QP_PATH_MTU) {
  		if (attr->path_mtu < IB_MTU_256 ||
  		    attr->path_mtu > IB_MTU_4096) {
@@@ -3678,10 -3917,10 +3690,15 @@@
  	}
  
  	if (!ibqp->uobject && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)
- 		context->sq_crq_size |= cpu_to_be16(1 << 4);
+ 		MLX5_SET(qpc, qpc, rlky, 1);
  
++<<<<<<< HEAD
 +	if (qp->flags & MLX5_IB_QP_SQPN_QP1)
 +		context->deth_sqpn = cpu_to_be32(1);
++=======
+ 	if (qp->flags & MLX5_IB_QP_CREATE_SQPN_QP1)
+ 		MLX5_SET(qpc, qpc, deth_sqpn, 1);
++>>>>>>> f18e26af6aba (RDMA/mlx5: Convert modify QP to use MLX5_SET macros)
  
  	mlx5_cur = to_mlx5_state(cur_state);
  	mlx5_new = to_mlx5_state(new_state);
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
diff --git a/include/linux/mlx5/qp.h b/include/linux/mlx5/qp.h
index 1af5e460b5f6..877c74780822 100644
--- a/include/linux/mlx5/qp.h
+++ b/include/linux/mlx5/qp.h
@@ -493,72 +493,6 @@ struct mlx5_core_dct {
 	struct completion	drained;
 };
 
-struct mlx5_qp_path {
-	u8			fl_free_ar;
-	u8			rsvd3;
-	__be16			pkey_index;
-	u8			rsvd0;
-	u8			grh_mlid;
-	__be16			rlid;
-	u8			ackto_lt;
-	u8			mgid_index;
-	u8			static_rate;
-	u8			hop_limit;
-	__be32			tclass_flowlabel;
-	union {
-		u8		rgid[16];
-		u8		rip[16];
-	};
-	u8			f_dscp_ecn_prio;
-	u8			ecn_dscp;
-	__be16			udp_sport;
-	u8			dci_cfi_prio_sl;
-	u8			port;
-	u8			rmac[6];
-};
-
-/* FIXME: use mlx5_ifc.h qpc */
-struct mlx5_qp_context {
-	__be32			flags;
-	__be32			flags_pd;
-	u8			mtu_msgmax;
-	u8			rq_size_stride;
-	__be16			sq_crq_size;
-	__be32			qp_counter_set_usr_page;
-	__be32			wire_qpn;
-	__be32			log_pg_sz_remote_qpn;
-	struct			mlx5_qp_path pri_path;
-	struct			mlx5_qp_path alt_path;
-	__be32			params1;
-	u8			reserved2[4];
-	__be32			next_send_psn;
-	__be32			cqn_send;
-	__be32			deth_sqpn;
-	u8			reserved3[4];
-	__be32			last_acked_psn;
-	__be32			ssn;
-	__be32			params2;
-	__be32			rnr_nextrecvpsn;
-	__be32			xrcd;
-	__be32			cqn_recv;
-	__be64			db_rec_addr;
-	__be32			qkey;
-	__be32			rq_type_srqn;
-	__be32			rmsn;
-	__be16			hw_sq_wqe_counter;
-	__be16			sw_sq_wqe_counter;
-	__be16			hw_rcyclic_byte_counter;
-	__be16			hw_rq_counter;
-	__be16			sw_rcyclic_byte_counter;
-	__be16			sw_rq_counter;
-	u8			rsvd0[5];
-	u8			cgs;
-	u8			cs_req;
-	u8			cs_res;
-	__be64			dc_access_key;
-	u8			rsvd1[24];
-};
-
 int mlx5_debug_qp_add(struct mlx5_core_dev *dev, struct mlx5_core_qp *qp);
 void mlx5_debug_qp_remove(struct mlx5_core_dev *dev, struct mlx5_core_qp *qp);
 
