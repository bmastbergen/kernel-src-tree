powerpc: Add prefixed instructions to instruction data type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jordan Niethe <jniethe5@gmail.com>
commit 650b55b707fdfa764e9f2b81314d3eb4216fb962
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/650b55b7.failed

For powerpc64, redefine the ppc_inst type so both word and prefixed
instructions can be represented. On powerpc32 the type will remain the
same. Update places which had assumed instructions to be 4 bytes long.

	Signed-off-by: Jordan Niethe <jniethe5@gmail.com>
	Reviewed-by: Alistair Popple <alistair@popple.id.au>
[mpe: Rework the get_user_inst() macros to be parameterised, and don't
      assign to the dest if an error occurred. Use CONFIG_PPC64 not
      __powerpc64__ in a few places. Address other comments from
      Christophe. Fix some sparse complaints.]
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200506034050.24806-24-jniethe5@gmail.com
(cherry picked from commit 650b55b707fdfa764e9f2b81314d3eb4216fb962)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/inst.h
#	arch/powerpc/include/asm/uaccess.h
#	arch/powerpc/kernel/crash_dump.c
#	arch/powerpc/kernel/optprobes.c
#	arch/powerpc/lib/code-patching.c
#	arch/powerpc/lib/feature-fixups.c
#	arch/powerpc/lib/inst.c
#	arch/powerpc/lib/sstep.c
diff --cc arch/powerpc/include/asm/uaccess.h
index ab580a78bb2b,c0523efa1458..000000000000
--- a/arch/powerpc/include/asm/uaccess.h
+++ b/arch/powerpc/include/asm/uaccess.h
@@@ -101,6 -105,51 +101,54 @@@ static inline int __access_ok(unsigned 
  #define __put_user_inatomic(x, ptr) \
  	__put_user_nosleep((__typeof__(*(ptr)))(x), (ptr), sizeof(*(ptr)))
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PPC64
+ 
+ #define ___get_user_instr(gu_op, dest, ptr)				\
+ ({									\
+ 	long __gui_ret = 0;						\
+ 	unsigned long __gui_ptr = (unsigned long)ptr;			\
+ 	struct ppc_inst __gui_inst;					\
+ 	unsigned int __prefix, __suffix;				\
+ 	__gui_ret = gu_op(__prefix, (unsigned int __user *)__gui_ptr);	\
+ 	if (__gui_ret == 0) {						\
+ 		if ((__prefix >> 26) == OP_PREFIX) {			\
+ 			__gui_ret = gu_op(__suffix,			\
+ 				(unsigned int __user *)__gui_ptr + 1);	\
+ 			__gui_inst = ppc_inst_prefix(__prefix,		\
+ 						     __suffix);		\
+ 		} else {						\
+ 			__gui_inst = ppc_inst(__prefix);		\
+ 		}							\
+ 		if (__gui_ret == 0)					\
+ 			(dest) = __gui_inst;				\
+ 	}								\
+ 	__gui_ret;							\
+ })
+ 
+ #define get_user_instr(x, ptr) \
+ 	___get_user_instr(get_user, x, ptr)
+ 
+ #define __get_user_instr(x, ptr) \
+ 	___get_user_instr(__get_user, x, ptr)
+ 
+ #define __get_user_instr_inatomic(x, ptr) \
+ 	___get_user_instr(__get_user_inatomic, x, ptr)
+ 
+ #else /* !CONFIG_PPC64 */
+ #define get_user_instr(x, ptr) \
+ 	get_user((x).val, (u32 __user *)(ptr))
+ 
+ #define __get_user_instr(x, ptr) \
+ 	__get_user_nocheck((x).val, (u32 __user *)(ptr), sizeof(u32), true)
+ 
+ #define __get_user_instr_inatomic(x, ptr) \
+ 	__get_user_nosleep((x).val, (u32 __user *)(ptr), sizeof(u32))
+ 
+ #endif /* CONFIG_PPC64 */
+ 
++>>>>>>> 650b55b707fd (powerpc: Add prefixed instructions to instruction data type)
  extern long __put_user_bad(void);
  
  /*
diff --cc arch/powerpc/kernel/crash_dump.c
index bbdc4706c159,735e89337398..000000000000
--- a/arch/powerpc/kernel/crash_dump.c
+++ b/arch/powerpc/kernel/crash_dump.c
@@@ -46,8 -45,8 +46,13 @@@ static void __init create_trampoline(un
  	 * branch to "addr" we jump to ("addr" + 32 MB). Although it requires
  	 * two instructions it doesn't require any registers.
  	 */
++<<<<<<< HEAD
 +	patch_instruction(p, PPC_INST_NOP);
 +	patch_branch(++p, addr + PHYSICAL_START, 0);
++=======
+ 	patch_instruction(p, ppc_inst(PPC_INST_NOP));
+ 	patch_branch((void *)p + 4, addr + PHYSICAL_START, 0);
++>>>>>>> 650b55b707fd (powerpc: Add prefixed instructions to instruction data type)
  }
  
  void __init setup_kdump_trampoline(void)
diff --cc arch/powerpc/kernel/optprobes.c
index 8237884ca389,3ac105e7faae..000000000000
--- a/arch/powerpc/kernel/optprobes.c
+++ b/arch/powerpc/kernel/optprobes.c
@@@ -193,8 -198,8 +193,13 @@@ void patch_imm64_load_insns(unsigned lo
  
  int arch_prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)
  {
++<<<<<<< HEAD
 +	kprobe_opcode_t *buff, branch_op_callback, branch_emulate_step;
 +	kprobe_opcode_t *op_callback_addr, *emulate_step_addr;
++=======
+ 	struct ppc_inst branch_op_callback, branch_emulate_step, temp;
+ 	kprobe_opcode_t *op_callback_addr, *emulate_step_addr, *buff;
++>>>>>>> 650b55b707fd (powerpc: Add prefixed instructions to instruction data type)
  	long b_offset;
  	unsigned long nip, size;
  	int rc, i;
diff --cc arch/powerpc/lib/code-patching.c
index 42fdadac6587,e9a0ea1c7ba4..000000000000
--- a/arch/powerpc/lib/code-patching.c
+++ b/arch/powerpc/lib/code-patching.c
@@@ -28,7 -24,18 +28,22 @@@ static int __patch_instruction(unsigne
  {
  	int err = 0;
  
++<<<<<<< HEAD
 +	__put_user_asm(instr, patch_addr, err, "stw");
++=======
+ 	if (!ppc_inst_prefixed(instr)) {
+ 		__put_user_asm(ppc_inst_val(instr), patch_addr, err, "stw");
+ 	} else {
+ #ifdef CONFIG_CPU_LITTLE_ENDIAN
+ 		__put_user_asm((u64)ppc_inst_suffix(instr) << 32 |
+ 			       ppc_inst_val(instr), patch_addr, err, "std");
+ #else
+ 		__put_user_asm((u64)ppc_inst_val(instr) << 32 |
+ 			       ppc_inst_suffix(instr), patch_addr, err, "std");
+ #endif
+ 	}
+ 
++>>>>>>> 650b55b707fd (powerpc: Add prefixed instructions to instruction data type)
  	if (err)
  		return err;
  
diff --cc arch/powerpc/lib/feature-fixups.c
index e613b02bb2f0,1fb845f60f43..000000000000
--- a/arch/powerpc/lib/feature-fixups.c
+++ b/arch/powerpc/lib/feature-fixups.c
@@@ -91,8 -90,8 +92,13 @@@ static int patch_feature_section(unsign
  			return 1;
  	}
  
++<<<<<<< HEAD
 +	for (; dest < end; dest++)
 +		raw_patch_instruction(dest, PPC_INST_NOP);
++=======
+ 	for (; dest < end; dest = (void *)dest + ppc_inst_len(ppc_inst(PPC_INST_NOP)))
+ 		raw_patch_instruction(dest, ppc_inst(PPC_INST_NOP));
++>>>>>>> 650b55b707fd (powerpc: Add prefixed instructions to instruction data type)
  
  	return 0;
  }
diff --cc arch/powerpc/lib/sstep.c
index 65f8c55bf6ff,ecd756c346fd..000000000000
--- a/arch/powerpc/lib/sstep.c
+++ b/arch/powerpc/lib/sstep.c
@@@ -1173,11 -1169,15 +1173,20 @@@ int analyse_instr(struct instruction_o
  	unsigned long int imm;
  	unsigned long int val, val2;
  	unsigned int mb, me, sh;
++<<<<<<< HEAD
 +	long ival;
 +
++=======
+ 	unsigned int word, suffix;
+ 	long ival;
+ 
+ 	word = ppc_inst_val(instr);
+ 	suffix = ppc_inst_suffix(instr);
+ 
++>>>>>>> 650b55b707fd (powerpc: Add prefixed instructions to instruction data type)
  	op->type = COMPUTE;
  
 -	opcode = ppc_inst_primary_opcode(instr);
 +	opcode = instr >> 26;
  	switch (opcode) {
  	case 16:	/* bc */
  		op->type = BRANCH;
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/lib/inst.c
* Unmerged path arch/powerpc/include/asm/inst.h
diff --git a/arch/powerpc/include/asm/kprobes.h b/arch/powerpc/include/asm/kprobes.h
index 9f3be5c8a4a3..936a6796ddc5 100644
--- a/arch/powerpc/include/asm/kprobes.h
+++ b/arch/powerpc/include/asm/kprobes.h
@@ -56,7 +56,7 @@ extern kprobe_opcode_t optprobe_template_ret[];
 extern kprobe_opcode_t optprobe_template_end[];
 
 /* Fixed instruction size for powerpc */
-#define MAX_INSN_SIZE		1
+#define MAX_INSN_SIZE		2
 #define MAX_OPTIMIZED_LENGTH	sizeof(kprobe_opcode_t)	/* 4 bytes */
 #define MAX_OPTINSN_SIZE	(optprobe_template_end - optprobe_template_entry)
 #define RELATIVEJUMP_SIZE	sizeof(kprobe_opcode_t)	/* 4 bytes */
diff --git a/arch/powerpc/include/asm/ppc-opcode.h b/arch/powerpc/include/asm/ppc-opcode.h
index 8fe0becd8b4e..bc3733412847 100644
--- a/arch/powerpc/include/asm/ppc-opcode.h
+++ b/arch/powerpc/include/asm/ppc-opcode.h
@@ -163,6 +163,9 @@
 /* VMX Vector Store Instructions */
 #define OP_31_XOP_STVX          231
 
+/* Prefixed Instructions */
+#define OP_PREFIX		1
+
 #define OP_31   31
 #define OP_LWZ  32
 #define OP_STFS 52
* Unmerged path arch/powerpc/include/asm/uaccess.h
diff --git a/arch/powerpc/include/asm/uprobes.h b/arch/powerpc/include/asm/uprobes.h
index 7422a999a39a..ef1967d6ca4a 100644
--- a/arch/powerpc/include/asm/uprobes.h
+++ b/arch/powerpc/include/asm/uprobes.h
@@ -27,7 +27,7 @@
 
 typedef ppc_opcode_t uprobe_opcode_t;
 
-#define MAX_UINSN_BYTES		4
+#define MAX_UINSN_BYTES		8
 #define UPROBE_XOL_SLOT_BYTES	(MAX_UINSN_BYTES)
 
 /* The following alias is needed for reference from arch-agnostic code */
* Unmerged path arch/powerpc/kernel/crash_dump.c
* Unmerged path arch/powerpc/kernel/optprobes.c
diff --git a/arch/powerpc/kernel/optprobes_head.S b/arch/powerpc/kernel/optprobes_head.S
index 98a3aeeb3c8c..5750b3dfc709 100644
--- a/arch/powerpc/kernel/optprobes_head.S
+++ b/arch/powerpc/kernel/optprobes_head.S
@@ -98,6 +98,9 @@ optprobe_template_insn:
 	/* 2, Pass instruction to be emulated in r4 */
 	nop
 	nop
+	nop
+	nop
+	nop
 
 	.global optprobe_template_call_emulate
 optprobe_template_call_emulate:
* Unmerged path arch/powerpc/lib/code-patching.c
* Unmerged path arch/powerpc/lib/feature-fixups.c
* Unmerged path arch/powerpc/lib/inst.c
* Unmerged path arch/powerpc/lib/sstep.c
diff --git a/arch/powerpc/xmon/xmon.c b/arch/powerpc/xmon/xmon.c
index 3ba3f8df7d8d..a064f22e611b 100644
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@ -701,8 +701,8 @@ static int xmon_bpt(struct pt_regs *regs)
 
 	/* Are we at the trap at bp->instr[1] for some bp? */
 	bp = in_breakpoint_table(regs->nip, &offset);
-	if (bp != NULL && offset == 4) {
-		regs->nip = bp->address + 4;
+	if (bp != NULL && (offset == 4 || offset == 8)) {
+		regs->nip = bp->address + offset;
 		atomic_dec(&bp->ref_count);
 		return 1;
 	}
diff --git a/arch/powerpc/xmon/xmon_bpts.S b/arch/powerpc/xmon/xmon_bpts.S
index f3ad0ab50854..69726814cd27 100644
--- a/arch/powerpc/xmon/xmon_bpts.S
+++ b/arch/powerpc/xmon/xmon_bpts.S
@@ -4,6 +4,8 @@
 #include <asm/asm-offsets.h>
 #include "xmon_bpts.h"
 
+/* Prefixed instructions can not cross 64 byte boundaries */
+.align 6
 .global bpt_table
 bpt_table:
 	.space NBPTS * BPT_SIZE
