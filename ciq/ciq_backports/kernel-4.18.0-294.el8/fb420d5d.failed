tcp/fq: move back to CLOCK_MONOTONIC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Eric Dumazet <edumazet@google.com>
commit fb420d5d91c1274d5966917725e71f27ed092a85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fb420d5d.failed

In the recent TCP/EDT patch series, I switched TCP and sch_fq
clocks from MONOTONIC to TAI, in order to meet the choice done
earlier for sch_etf packet scheduler.

But sure enough, this broke some setups were the TAI clock
jumps forward (by almost 50 year...), as reported
by Leonard Crestez.

If we want to converge later, we'll probably need to add
an skb field to differentiate the clock bases, or a socket option.

In the meantime, an UDP application will need to use CLOCK_MONOTONIC
base for its SCM_TXTIME timestamps if using fq packet scheduler.

Fixes: 72b0094f9182 ("tcp: switch tcp_clock_ns() to CLOCK_TAI base")
Fixes: 142537e41923 ("net_sched: sch_fq: switch to CLOCK_TAI")
Fixes: fd2bca2aa789 ("tcp: switch internal pacing timer to CLOCK_TAI")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Leonard Crestez <leonard.crestez@nxp.com>
	Tested-by: Leonard Crestez <leonard.crestez@nxp.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fb420d5d91c1274d5966917725e71f27ed092a85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_fq.c
diff --cc net/sched/sch_fq.c
index 520fc183e0d7,338222a6c664..000000000000
--- a/net/sched/sch_fq.c
+++ b/net/sched/sch_fq.c
@@@ -415,6 -412,7 +415,10 @@@ static void fq_check_throttled(struct f
  static struct sk_buff *fq_dequeue(struct Qdisc *sch)
  {
  	struct fq_sched_data *q = qdisc_priv(sch);
++<<<<<<< HEAD
++=======
+ 	u64 now = ktime_get_ns();
++>>>>>>> fb420d5d91c1 (tcp/fq: move back to CLOCK_MONOTONIC)
  	struct fq_flow_head *head;
  	struct sk_buff *skb;
  	struct fq_flow *f;
@@@ -806,13 -776,7 +810,17 @@@ static int fq_init(struct Qdisc *sch, s
  	q->fq_trees_log		= ilog2(1024);
  	q->orphan_mask		= 1024 - 1;
  	q->low_rate_threshold	= 550000 / 8;
++<<<<<<< HEAD
 +
 +	q->timer_slack = 10 * NSEC_PER_USEC; /* 10 usec of hrtimer slack */
 +
 +	/* Default ce_threshold of 4294 seconds */
 +	q->ce_threshold		= (u64)NSEC_PER_USEC * ~0U;
 +
 +	qdisc_watchdog_init(&q->watchdog, sch);
++=======
+ 	qdisc_watchdog_init_clockid(&q->watchdog, sch, CLOCK_MONOTONIC);
++>>>>>>> fb420d5d91c1 (tcp/fq: move back to CLOCK_MONOTONIC)
  
  	if (opt)
  		err = fq_change(sch, opt, extack);
@@@ -872,8 -831,7 +880,12 @@@ static int fq_dump_stats(struct Qdisc *
  	st.flows_plimit		  = q->stat_flows_plimit;
  	st.pkts_too_long	  = q->stat_pkts_too_long;
  	st.allocation_errors	  = q->stat_allocation_errors;
++<<<<<<< HEAD
 +	st.time_next_delayed_flow = q->time_next_delayed_flow + q->timer_slack -
 +				    ktime_get_ns();
++=======
+ 	st.time_next_delayed_flow = q->time_next_delayed_flow - ktime_get_ns();
++>>>>>>> fb420d5d91c1 (tcp/fq: move back to CLOCK_MONOTONIC)
  	st.flows		  = q->flows;
  	st.inactive_flows	  = q->inactive_flows;
  	st.throttled_flows	  = q->throttled_flows;
diff --git a/include/net/tcp.h b/include/net/tcp.h
index e43eeaa0964e..c64434aed420 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -763,7 +763,7 @@ void tcp_send_window_probe(struct sock *sk);
 
 static inline u64 tcp_clock_ns(void)
 {
-	return ktime_get_tai_ns();
+	return ktime_get_ns();
 }
 
 static inline u64 tcp_clock_us(void)
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
index a76cbb873152..77be1a6daf65 100644
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -764,7 +764,7 @@ void tcp_init_xmit_timers(struct sock *sk)
 {
 	inet_csk_init_xmit_timers(sk, &tcp_write_timer, &tcp_delack_timer,
 				  &tcp_keepalive_timer);
-	hrtimer_init(&tcp_sk(sk)->pacing_timer, CLOCK_TAI,
+	hrtimer_init(&tcp_sk(sk)->pacing_timer, CLOCK_MONOTONIC,
 		     HRTIMER_MODE_ABS_PINNED_SOFT);
 	tcp_sk(sk)->pacing_timer.function = tcp_pace_kick;
 
* Unmerged path net/sched/sch_fq.c
