vfs: Add a single-or-reconfig keying to vfs_get_super()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 43ce4c1feadbc84c772518a2d1974f6ba1b15089
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/43ce4c1f.failed

Add an additional keying mode to vfs_get_super() to indicate that only a
single superblock should exist in the system, and that, if it does, further
mounts should invoke reconfiguration upon it.

This allows mount_single() to be replaced.

[Fix by Eric Biggers folded in]

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 43ce4c1feadbc84c772518a2d1974f6ba1b15089)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/super.c
#	include/linux/fs_context.h
diff --cc fs/super.c
index 72596c26684f,beaf076d9733..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -1046,45 -1112,138 +1046,126 @@@ void kill_litter_super(struct super_blo
  }
  EXPORT_SYMBOL(kill_litter_super);
  
 -int set_anon_super_fc(struct super_block *sb, struct fs_context *fc)
 +static int ns_test_super(struct super_block *sb, void *data)
  {
 -	return set_anon_super(sb, NULL);
 +	return sb->s_fs_info == data;
  }
 -EXPORT_SYMBOL(set_anon_super_fc);
  
 -static int test_keyed_super(struct super_block *sb, struct fs_context *fc)
 +static int ns_set_super(struct super_block *sb, void *data)
  {
 -	return sb->s_fs_info == fc->s_fs_info;
 -}
 -
 -static int test_single_super(struct super_block *s, struct fs_context *fc)
 -{
 -	return 1;
 +	sb->s_fs_info = data;
 +	return set_anon_super(sb, NULL);
  }
  
 -/**
 - * vfs_get_super - Get a superblock with a search key set in s_fs_info.
 - * @fc: The filesystem context holding the parameters
 - * @keying: How to distinguish superblocks
 - * @fill_super: Helper to initialise a new superblock
 - *
 - * Search for a superblock and create a new one if not found.  The search
 - * criterion is controlled by @keying.  If the search fails, a new superblock
 - * is created and @fill_super() is called to initialise it.
 - *
 - * @keying can take one of a number of values:
 - *
 - * (1) vfs_get_single_super - Only one superblock of this type may exist on the
 - *     system.  This is typically used for special system filesystems.
 - *
 - * (2) vfs_get_keyed_super - Multiple superblocks may exist, but they must have
 - *     distinct keys (where the key is in s_fs_info).  Searching for the same
 - *     key again will turn up the superblock for that key.
 - *
 - * (3) vfs_get_independent_super - Multiple superblocks may exist and are
 - *     unkeyed.  Each call will get a new superblock.
 - *
 - * A permissions check is made by sget_fc() unless we're getting a superblock
 - * for a kernel-internal mount or a submount.
 - */
 -int vfs_get_super(struct fs_context *fc,
 -		  enum vfs_get_super_keying keying,
 -		  int (*fill_super)(struct super_block *sb,
 -				    struct fs_context *fc))
 +struct dentry *mount_ns(struct file_system_type *fs_type,
 +	int flags, void *data, void *ns, struct user_namespace *user_ns,
 +	int (*fill_super)(struct super_block *, void *, int))
  {
 -	int (*test)(struct super_block *, struct fs_context *);
  	struct super_block *sb;
+ 	int err;
  
++<<<<<<< HEAD
 +	sb = sget_userns(fs_type, ns_test_super, ns_set_super, flags,
 +			 user_ns, ns);
++=======
+ 	switch (keying) {
+ 	case vfs_get_single_super:
+ 	case vfs_get_single_reconf_super:
+ 		test = test_single_super;
+ 		break;
+ 	case vfs_get_keyed_super:
+ 		test = test_keyed_super;
+ 		break;
+ 	case vfs_get_independent_super:
+ 		test = NULL;
+ 		break;
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	sb = sget_fc(fc, test, set_anon_super_fc);
++>>>>>>> 43ce4c1feadb (vfs: Add a single-or-reconfig keying to vfs_get_super())
  	if (IS_ERR(sb))
 -		return PTR_ERR(sb);
 +		return ERR_CAST(sb);
  
  	if (!sb->s_root) {
++<<<<<<< HEAD
 +		int err;
 +		err = fill_super(sb, data, flags & SB_SILENT ? 1 : 0);
 +		if (err) {
 +			deactivate_locked_super(sb);
 +			return ERR_PTR(err);
 +		}
++=======
+ 		err = fill_super(sb, fc);
+ 		if (err)
+ 			goto error;
++>>>>>>> 43ce4c1feadb (vfs: Add a single-or-reconfig keying to vfs_get_super())
  
  		sb->s_flags |= SB_ACTIVE;
+ 		fc->root = dget(sb->s_root);
+ 	} else {
+ 		fc->root = dget(sb->s_root);
+ 		if (keying == vfs_get_single_reconf_super) {
+ 			err = reconfigure_super(fc);
+ 			if (err < 0) {
+ 				dput(fc->root);
+ 				fc->root = NULL;
+ 				goto error;
+ 			}
+ 		}
  	}
  
++<<<<<<< HEAD
 +	return dget(sb->s_root);
++=======
+ 	return 0;
+ 
+ error:
+ 	deactivate_locked_super(sb);
+ 	return err;
++>>>>>>> 43ce4c1feadb (vfs: Add a single-or-reconfig keying to vfs_get_super())
  }
 -EXPORT_SYMBOL(vfs_get_super);
  
++<<<<<<< HEAD
 +EXPORT_SYMBOL(mount_ns);
++=======
+ int get_tree_nodev(struct fs_context *fc,
+ 		  int (*fill_super)(struct super_block *sb,
+ 				    struct fs_context *fc))
+ {
+ 	return vfs_get_super(fc, vfs_get_independent_super, fill_super);
+ }
+ EXPORT_SYMBOL(get_tree_nodev);
+ 
+ int get_tree_single(struct fs_context *fc,
+ 		  int (*fill_super)(struct super_block *sb,
+ 				    struct fs_context *fc))
+ {
+ 	return vfs_get_super(fc, vfs_get_single_super, fill_super);
+ }
+ EXPORT_SYMBOL(get_tree_single);
+ 
+ int get_tree_single_reconf(struct fs_context *fc,
+ 		  int (*fill_super)(struct super_block *sb,
+ 				    struct fs_context *fc))
+ {
+ 	return vfs_get_super(fc, vfs_get_single_reconf_super, fill_super);
+ }
+ EXPORT_SYMBOL(get_tree_single_reconf);
+ 
+ int get_tree_keyed(struct fs_context *fc,
+ 		  int (*fill_super)(struct super_block *sb,
+ 				    struct fs_context *fc),
+ 		void *key)
+ {
+ 	fc->s_fs_info = key;
+ 	return vfs_get_super(fc, vfs_get_keyed_super, fill_super);
+ }
+ EXPORT_SYMBOL(get_tree_keyed);
++>>>>>>> 43ce4c1feadb (vfs: Add a single-or-reconfig keying to vfs_get_super())
  
  #ifdef CONFIG_BLOCK
 -
  static int set_bdev_super(struct super_block *s, void *data)
  {
  	s->s_bdev = data;
* Unmerged path include/linux/fs_context.h
* Unmerged path fs/super.c
* Unmerged path include/linux/fs_context.h
