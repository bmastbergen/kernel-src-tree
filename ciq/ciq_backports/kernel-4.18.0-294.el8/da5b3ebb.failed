tracing: irqsoff: Account for additional preempt_disable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Joel Fernandes (Google) <joel@joelfernandes.org>
commit da5b3ebb4527733299661229a8d035d64a4f0b1a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/da5b3ebb.failed

Recently we tried to make the preemptirqsoff tracer to use irqsoff
tracepoint probes. However this causes issues as reported by Masami:

[2.271078] Testing tracer preemptirqsoff: .. no entries found ..FAILED!
[2.381015] WARNING: CPU: 0 PID: 1 at /home/mhiramat/ksrc/linux/kernel/
trace/trace.c:1512 run_tracer_selftest+0xf3/0x154

This is due to the tracepoint code increasing the preempt nesting count
by calling an additional preempt_disable before calling into the
preemptoff tracer which messes up the preempt_count() check in
tracer_hardirqs_off.

To fix this, make the irqsoff tracer probes balance the additional outer
preempt_disable with a preempt_enable_notrace.

The other way to fix this is to just use SRCU for all tracepoints.
However we can't do that because we can't use NMIs from RCU context.

Link: http://lkml.kernel.org/r/20180806034049.67949-1-joel@joelfernandes.org

Fixes: c3bc8fd637a9 ("tracing: Centralize preemptirq tracepoints and unify their usage")
Fixes: e6753f23d961 ("tracepoint: Make rcuidle tracepoint callers use SRCU")
	Reported-by: Masami Hiramatsu <mhiramat@kernel.org>
	Tested-by: Masami Hiramatsu <mhiramat@kernel.org>
	Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit da5b3ebb4527733299661229a8d035d64a4f0b1a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_irqsoff.c
diff --cc kernel/trace/trace_irqsoff.c
index f8daa754cce2,ffbf1505d5bc..000000000000
--- a/kernel/trace/trace_irqsoff.c
+++ b/kernel/trace/trace_irqsoff.c
@@@ -659,6 -598,47 +659,50 @@@ static void irqsoff_tracer_stop(struct 
  }
  
  #ifdef CONFIG_IRQSOFF_TRACER
++<<<<<<< HEAD
++=======
+ /*
+  * We are only interested in hardirq on/off events:
+  */
+ static void tracer_hardirqs_on(void *none, unsigned long a0, unsigned long a1)
+ {
+ 	/*
+ 	 * Tracepoint probes are expected to be called with preempt disabled,
+ 	 * We don't care about being called with preempt disabled but we need
+ 	 * to know in the future if that changes so we can remove the next
+ 	 * preempt_enable.
+ 	 */
+ 	WARN_ON_ONCE(!preempt_count());
+ 
+ 	/* Tracepoint probes disable preemption atleast once, account for that */
+ 	preempt_enable_notrace();
+ 
+ 	if (!preempt_trace() && irq_trace())
+ 		stop_critical_timing(a0, a1);
+ 
+ 	preempt_disable_notrace();
+ }
+ 
+ static void tracer_hardirqs_off(void *none, unsigned long a0, unsigned long a1)
+ {
+ 	/*
+ 	 * Tracepoint probes are expected to be called with preempt disabled,
+ 	 * We don't care about being called with preempt disabled but we need
+ 	 * to know in the future if that changes so we can remove the next
+ 	 * preempt_enable.
+ 	 */
+ 	WARN_ON_ONCE(!preempt_count());
+ 
+ 	/* Tracepoint probes disable preemption atleast once, account for that */
+ 	preempt_enable_notrace();
+ 
+ 	if (!preempt_trace() && irq_trace())
+ 		start_critical_timing(a0, a1);
+ 
+ 	preempt_disable_notrace();
+ }
+ 
++>>>>>>> da5b3ebb4527 (tracing: irqsoff: Account for additional preempt_disable)
  static int irqsoff_tracer_init(struct trace_array *tr)
  {
  	trace_type = TRACER_IRQS_OFF;
* Unmerged path kernel/trace/trace_irqsoff.c
