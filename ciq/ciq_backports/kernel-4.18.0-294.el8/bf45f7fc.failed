procfs: switch to use of invalfc()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit bf45f7fcc4003a8347a172354e2b8b59a259822c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/bf45f7fc.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit bf45f7fcc4003a8347a172354e2b8b59a259822c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/root.c
diff --cc fs/proc/root.c
index f4b1a9d2eca6,a24976579f59..000000000000
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@@ -26,60 -27,119 +26,72 @@@
  
  #include "internal.h"
  
 -struct proc_fs_context {
 -	struct pid_namespace	*pid_ns;
 -	unsigned int		mask;
 -	int			hidepid;
 -	int			gid;
 +enum {
 +	Opt_gid, Opt_hidepid, Opt_err,
  };
  
 -enum proc_param {
 -	Opt_gid,
 -	Opt_hidepid,
 +static const match_table_t tokens = {
 +	{Opt_hidepid, "hidepid=%u"},
 +	{Opt_gid, "gid=%u"},
 +	{Opt_err, NULL},
  };
  
 -static const struct fs_parameter_spec proc_fs_parameters[] = {
 -	fsparam_u32("gid",	Opt_gid),
 -	fsparam_u32("hidepid",	Opt_hidepid),
 -	{}
 -};
 -
 -static int proc_parse_param(struct fs_context *fc, struct fs_parameter *param)
 +int proc_parse_options(char *options, struct pid_namespace *pid)
  {
 -	struct proc_fs_context *ctx = fc->fs_private;
 -	struct fs_parse_result result;
 -	int opt;
 -
 -	opt = fs_parse(fc, proc_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case Opt_gid:
 -		ctx->gid = result.uint_32;
 -		break;
 -
 +	char *p;
 +	substring_t args[MAX_OPT_ARGS];
 +	int option;
 +
 +	if (!options)
 +		return 1;
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int token;
 +		if (!*p)
 +			continue;
 +
++<<<<<<< HEAD
 +		args[0].to = args[0].from = NULL;
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_gid:
 +			if (match_int(&args[0], &option))
 +				return 0;
 +			pid->pid_gid = make_kgid(current_user_ns(), option);
 +			break;
 +		case Opt_hidepid:
 +			if (match_int(&args[0], &option))
 +				return 0;
 +			if (option < HIDEPID_OFF ||
 +			    option > HIDEPID_INVISIBLE) {
 +				pr_err("proc: hidepid value must be between 0 and 2.\n");
 +				return 0;
 +			}
 +			pid->hide_pid = option;
 +			break;
 +		default:
 +			pr_err("proc: unrecognized mount option \"%s\" "
 +			       "or missing value\n", p);
 +			return 0;
 +		}
++=======
+ 	case Opt_hidepid:
+ 		ctx->hidepid = result.uint_32;
+ 		if (ctx->hidepid < HIDEPID_OFF ||
+ 		    ctx->hidepid > HIDEPID_INVISIBLE)
+ 			return invalfc(fc, "hidepid value must be between 0 and 2.\n");
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
++>>>>>>> bf45f7fcc400 (procfs: switch to use of invalfc())
  	}
  
 -	ctx->mask |= 1 << opt;
 -	return 0;
 -}
 -
 -static void proc_apply_options(struct super_block *s,
 -			       struct fs_context *fc,
 -			       struct pid_namespace *pid_ns,
 -			       struct user_namespace *user_ns)
 -{
 -	struct proc_fs_context *ctx = fc->fs_private;
 -
 -	if (ctx->mask & (1 << Opt_gid))
 -		pid_ns->pid_gid = make_kgid(user_ns, ctx->gid);
 -	if (ctx->mask & (1 << Opt_hidepid))
 -		pid_ns->hide_pid = ctx->hidepid;
 +	return 1;
  }
  
 -static int proc_fill_super(struct super_block *s, struct fs_context *fc)
 +int proc_remount(struct super_block *sb, int *flags, char *data)
  {
 -	struct pid_namespace *pid_ns = get_pid_ns(s->s_fs_info);
 -	struct inode *root_inode;
 -	int ret;
 -
 -	proc_apply_options(s, fc, pid_ns, current_user_ns());
 -
 -	/* User space would break if executables or devices appear on proc */
 -	s->s_iflags |= SB_I_USERNS_VISIBLE | SB_I_NOEXEC | SB_I_NODEV;
 -	s->s_flags |= SB_NODIRATIME | SB_NOSUID | SB_NOEXEC;
 -	s->s_blocksize = 1024;
 -	s->s_blocksize_bits = 10;
 -	s->s_magic = PROC_SUPER_MAGIC;
 -	s->s_op = &proc_sops;
 -	s->s_time_gran = 1;
 -
 -	/*
 -	 * procfs isn't actually a stacking filesystem; however, there is
 -	 * too much magic going on inside it to permit stacking things on
 -	 * top of it
 -	 */
 -	s->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;
 -	
 -	/* procfs dentries and inodes don't require IO to create */
 -	s->s_shrink.seeks = 0;
 -
 -	pde_get(&proc_root);
 -	root_inode = proc_get_inode(s, &proc_root);
 -	if (!root_inode) {
 -		pr_err("proc_fill_super: get root inode failed\n");
 -		return -ENOMEM;
 -	}
 -
 -	s->s_root = d_make_root(root_inode);
 -	if (!s->s_root) {
 -		pr_err("proc_fill_super: allocate dentry failed\n");
 -		return -ENOMEM;
 -	}
 -
 -	ret = proc_setup_self(s);
 -	if (ret) {
 -		return ret;
 -	}
 -	return proc_setup_thread_self(s);
 -}
 -
 -static int proc_reconfigure(struct fs_context *fc)
 -{
 -	struct super_block *sb = fc->root->d_sb;
  	struct pid_namespace *pid = sb->s_fs_info;
  
  	sync_filesystem(sb);
* Unmerged path fs/proc/root.c
