fuse: reject options on reconfigure via fsconfig(2)

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit b330966f79fb4fdc49183f58db113303695a750f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b330966f.failed

Previous patch changed handling of remount/reconfigure to ignore all
options, including those that are unknown to the fuse kernel fs.  This was
done for backward compatibility, but this likely only affects the old
mount(2) API.

The new fsconfig(2) based reconfiguration could possibly be improved.  This
would make the new API less of a drop in replacement for the old, OTOH this
is a good chance to get rid of some weirdnesses in the old API.

Several other behaviors might make sense:

 1) unknown options are rejected, known options are ignored

 2) unknown options are rejected, known options are rejected if the value
 is changed, allowed otherwise

 3) all options are rejected

Prior to the backward compatibility fix to ignore all options all known
options were accepted (1), even if they change the value of a mount
parameter; fuse_reconfigure() does not look at the config values set by
fuse_parse_param().

To fix that we'd need to verify that the value provided is the same as set
in the initial configuration (2).  The major drawback is that this is much
more complex than just rejecting all attempts at changing options (3);
i.e. all options signify initial configuration values and don't make sense
on reconfigure.

This patch opts for (3) with the rationale that no mount options are
reconfigurable in fuse.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit b330966f79fb4fdc49183f58db113303695a750f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/inode.c
#	fs/namespace.c
#	include/linux/fs_context.h
diff --cc fs/fuse/inode.c
index 10b75246113a,bba747520e9b..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -452,111 -457,115 +452,194 @@@ enum 
  	OPT_ERR
  };
  
 -static const struct fs_parameter_spec fuse_fs_parameters[] = {
 -	fsparam_string	("source",		OPT_SOURCE),
 -	fsparam_u32	("fd",			OPT_FD),
 -	fsparam_u32oct	("rootmode",		OPT_ROOTMODE),
 -	fsparam_u32	("user_id",		OPT_USER_ID),
 -	fsparam_u32	("group_id",		OPT_GROUP_ID),
 -	fsparam_flag	("default_permissions",	OPT_DEFAULT_PERMISSIONS),
 -	fsparam_flag	("allow_other",		OPT_ALLOW_OTHER),
 -	fsparam_u32	("max_read",		OPT_MAX_READ),
 -	fsparam_u32	("blksize",		OPT_BLKSIZE),
 -	fsparam_string	("subtype",		OPT_SUBTYPE),
 -	{}
 +static const match_table_t tokens = {
 +	{OPT_FD,			"fd=%u"},
 +	{OPT_ROOTMODE,			"rootmode=%o"},
 +	{OPT_USER_ID,			"user_id=%u"},
 +	{OPT_GROUP_ID,			"group_id=%u"},
 +	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
 +	{OPT_ALLOW_OTHER,		"allow_other"},
 +	{OPT_MAX_READ,			"max_read=%u"},
 +	{OPT_BLKSIZE,			"blksize=%u"},
 +	{OPT_ERR,			NULL}
  };
  
 -static int fuse_parse_param(struct fs_context *fc, struct fs_parameter *param)
 +static int fuse_match_uint(substring_t *s, unsigned int *res)
  {
++<<<<<<< HEAD
 +	int err = -ENOMEM;
 +	char *buf = match_strdup(s);
 +	if (buf) {
 +		err = kstrtouint(buf, 10, res);
 +		kfree(buf);
++=======
+ 	struct fs_parse_result result;
+ 	struct fuse_fs_context *ctx = fc->fs_private;
+ 	int opt;
+ 
+ 	if (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE) {
+ 		/*
+ 		 * Ignore options coming from mount(MS_REMOUNT) for backward
+ 		 * compatibility.
+ 		 */
+ 		if (fc->oldapi)
+ 			return 0;
+ 
+ 		return invalfc(fc, "No changes allowed in reconfigure");
+ 	}
+ 
+ 	opt = fs_parse(fc, fuse_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case OPT_SOURCE:
+ 		if (fc->source)
+ 			return invalfc(fc, "Multiple sources specified");
+ 		fc->source = param->string;
+ 		param->string = NULL;
+ 		break;
+ 
+ 	case OPT_SUBTYPE:
+ 		if (ctx->subtype)
+ 			return invalfc(fc, "Multiple subtypes specified");
+ 		ctx->subtype = param->string;
+ 		param->string = NULL;
+ 		return 0;
+ 
+ 	case OPT_FD:
+ 		ctx->fd = result.uint_32;
+ 		ctx->fd_present = true;
+ 		break;
+ 
+ 	case OPT_ROOTMODE:
+ 		if (!fuse_valid_type(result.uint_32))
+ 			return invalfc(fc, "Invalid rootmode");
+ 		ctx->rootmode = result.uint_32;
+ 		ctx->rootmode_present = true;
+ 		break;
+ 
+ 	case OPT_USER_ID:
+ 		ctx->user_id = make_kuid(fc->user_ns, result.uint_32);
+ 		if (!uid_valid(ctx->user_id))
+ 			return invalfc(fc, "Invalid user_id");
+ 		ctx->user_id_present = true;
+ 		break;
+ 
+ 	case OPT_GROUP_ID:
+ 		ctx->group_id = make_kgid(fc->user_ns, result.uint_32);
+ 		if (!gid_valid(ctx->group_id))
+ 			return invalfc(fc, "Invalid group_id");
+ 		ctx->group_id_present = true;
+ 		break;
+ 
+ 	case OPT_DEFAULT_PERMISSIONS:
+ 		ctx->default_permissions = true;
+ 		break;
+ 
+ 	case OPT_ALLOW_OTHER:
+ 		ctx->allow_other = true;
+ 		break;
+ 
+ 	case OPT_MAX_READ:
+ 		ctx->max_read = result.uint_32;
+ 		break;
+ 
+ 	case OPT_BLKSIZE:
+ 		if (!ctx->is_bdev)
+ 			return invalfc(fc, "blksize only supported for fuseblk");
+ 		ctx->blksize = result.uint_32;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
++>>>>>>> b330966f79fb (fuse: reject options on reconfigure via fsconfig(2))
  	}
 -
 -	return 0;
 +	return err;
  }
  
 -static void fuse_free_fc(struct fs_context *fc)
 +static int parse_fuse_opt(char *opt, struct fuse_fs_context *d, int is_bdev,
 +			  struct user_namespace *user_ns)
  {
 -	struct fuse_fs_context *ctx = fc->fs_private;
 -
 -	if (ctx) {
 -		kfree(ctx->subtype);
 -		kfree(ctx);
 +	char *p;
 +	memset(d, 0, sizeof(struct fuse_fs_context));
 +	d->max_read = ~0;
 +	d->blksize = FUSE_DEFAULT_BLKSIZE;
 +
 +	while ((p = strsep(&opt, ",")) != NULL) {
 +		int token;
 +		int value;
 +		unsigned uv;
 +		substring_t args[MAX_OPT_ARGS];
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case OPT_FD:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->fd = value;
 +			d->fd_present = 1;
 +			break;
 +
 +		case OPT_ROOTMODE:
 +			if (match_octal(&args[0], &value))
 +				return 0;
 +			if (!fuse_valid_type(value))
 +				return 0;
 +			d->rootmode = value;
 +			d->rootmode_present = 1;
 +			break;
 +
 +		case OPT_USER_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->user_id = make_kuid(user_ns, uv);
 +			if (!uid_valid(d->user_id))
 +				return 0;
 +			d->user_id_present = 1;
 +			break;
 +
 +		case OPT_GROUP_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->group_id = make_kgid(user_ns, uv);
 +			if (!gid_valid(d->group_id))
 +				return 0;
 +			d->group_id_present = 1;
 +			break;
 +
 +		case OPT_DEFAULT_PERMISSIONS:
 +			d->default_permissions = 1;
 +			break;
 +
 +		case OPT_ALLOW_OTHER:
 +			d->allow_other = 1;
 +			break;
 +
 +		case OPT_MAX_READ:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->max_read = value;
 +			break;
 +
 +		case OPT_BLKSIZE:
 +			if (!is_bdev || match_int(&args[0], &value))
 +				return 0;
 +			d->blksize = value;
 +			break;
 +
 +		default:
 +			return 0;
 +		}
  	}
 +
 +	if (!d->fd_present || !d->rootmode_present ||
 +	    !d->user_id_present || !d->group_id_present)
 +		return 0;
 +
 +	return 1;
  }
  
  static int fuse_show_options(struct seq_file *m, struct dentry *root)
diff --cc fs/namespace.c
index 8454c0d888ea,4a0f600a3328..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -2373,25 -2599,26 +2373,43 @@@ static int do_remount(struct path *path
  	if (!can_change_locked_flags(mnt, mnt_flags))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	security_init_mnt_opts(&opts);
 +	if (data && !(sb->s_type->fs_flags & FS_BINARY_MOUNTDATA)) {
 +		err = security_sb_eat_lsm_opts(data, &opts);
 +		if (err)
 +			return err;
++=======
+ 	fc = fs_context_for_reconfigure(path->dentry, sb_flags, MS_RMT_MASK);
+ 	if (IS_ERR(fc))
+ 		return PTR_ERR(fc);
+ 
+ 	fc->oldapi = true;
+ 	err = parse_monolithic_mount_data(fc, data);
+ 	if (!err) {
+ 		down_write(&sb->s_umount);
+ 		err = -EPERM;
+ 		if (ns_capable(sb->s_user_ns, CAP_SYS_ADMIN)) {
+ 			err = reconfigure_super(fc);
+ 			if (!err)
+ 				set_mount_attributes(mnt, mnt_flags);
+ 		}
+ 		up_write(&sb->s_umount);
++>>>>>>> b330966f79fb (fuse: reject options on reconfigure via fsconfig(2))
  	}
 +	err = security_sb_remount(sb, &opts);
 +	security_free_mnt_opts(&opts);
 +	if (err)
 +		return err;
  
 -	mnt_warn_timestamp_expiry(path, &mnt->mnt);
 -
 -	put_fs_context(fc);
 +	down_write(&sb->s_umount);
 +	err = -EPERM;
 +	if (ns_capable(sb->s_user_ns, CAP_SYS_ADMIN)) {
 +		err = do_remount_sb(sb, sb_flags, data, 0);
 +		if (!err)
 +			set_mount_attributes(mnt, mnt_flags);
 +	}
 +	up_write(&sb->s_umount);
  	return err;
  }
  
* Unmerged path include/linux/fs_context.h
* Unmerged path fs/fuse/inode.c
* Unmerged path fs/namespace.c
* Unmerged path include/linux/fs_context.h
