bpf: Override the meaning of ARG_PTR_TO_MAP_VALUE for sockmap and sockhash

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Lorenz Bauer <lmb@cloudflare.com>
commit 912f442cfb1fc695510e055bdae5f4a88e4de6b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/912f442c.failed

The verifier assumes that map values are simple blobs of memory, and
therefore treats ARG_PTR_TO_MAP_VALUE, etc. as such. However, there are
map types where this isn't true. For example, sockmap and sockhash store
sockets. In general this isn't a big problem: we can just
write helpers that explicitly requests PTR_TO_SOCKET instead of
ARG_PTR_TO_MAP_VALUE.

The one exception are the standard map helpers like map_update_elem,
map_lookup_elem, etc. Here it would be nice we could overload the
function prototype for different kinds of maps. Unfortunately, this
isn't entirely straight forward:
We only know the type of the map once we have resolved meta->map_ptr
in check_func_arg. This means we can't swap out the prototype
in check_helper_call until we're half way through the function.

Instead, modify check_func_arg to treat ARG_PTR_TO_MAP_VALUE to
mean "the native type for the map" instead of "pointer to memory"
for sockmap and sockhash. This means we don't have to modify the
function prototype at all

	Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Yonghong Song <yhs@fb.com>
Link: https://lore.kernel.org/bpf/20200821102948.21918-5-lmb@cloudflare.com
(cherry picked from commit 912f442cfb1fc695510e055bdae5f4a88e4de6b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index fcf9a1bb7134,f8629bf848fe..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -3688,12 -3872,41 +3688,45 @@@ static int int_ptr_type_to_size(enum bp
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
 +static int check_func_arg(struct bpf_verifier_env *env, u32 regno,
 +			  enum bpf_arg_type arg_type,
 +			  struct bpf_call_arg_meta *meta)
++=======
+ static int resolve_map_arg_type(struct bpf_verifier_env *env,
+ 				 const struct bpf_call_arg_meta *meta,
+ 				 enum bpf_arg_type *arg_type)
+ {
+ 	if (!meta->map_ptr) {
+ 		/* kernel subsystem misconfigured verifier */
+ 		verbose(env, "invalid map_ptr to access map->type\n");
+ 		return -EACCES;
+ 	}
+ 
+ 	switch (meta->map_ptr->map_type) {
+ 	case BPF_MAP_TYPE_SOCKMAP:
+ 	case BPF_MAP_TYPE_SOCKHASH:
+ 		if (*arg_type == ARG_PTR_TO_MAP_VALUE) {
+ 			*arg_type = ARG_PTR_TO_SOCKET;
+ 		} else {
+ 			verbose(env, "invalid arg_type for sockmap/sockhash\n");
+ 			return -EINVAL;
+ 		}
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static int check_func_arg(struct bpf_verifier_env *env, u32 arg,
+ 			  struct bpf_call_arg_meta *meta,
+ 			  const struct bpf_func_proto *fn)
++>>>>>>> 912f442cfb1f (bpf: Override the meaning of ARG_PTR_TO_MAP_VALUE for sockmap and sockhash)
  {
 -	u32 regno = BPF_REG_1 + arg;
  	struct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];
  	enum bpf_reg_type expected_type, type = reg->type;
 -	enum bpf_arg_type arg_type = fn->arg_type[arg];
  	int err = 0;
  
  	if (arg_type == ARG_DONTCARE)
* Unmerged path kernel/bpf/verifier.c
