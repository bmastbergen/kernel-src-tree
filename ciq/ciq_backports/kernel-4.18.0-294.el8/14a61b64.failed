KVM: VMX: Rename "vmx_msr_index" to "vmx_uret_msrs_list"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 14a61b642de9e5612f091b3295da6d0c89449a49
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/14a61b64.failed

Rename "vmx_msr_index" to "vmx_uret_msrs_list" to associate it with the
uret MSRs array, and to avoid conflating "MSR's ECX index" with "MSR's
index into an array".  Similarly, don't use "slot" in the name as that
terminology is claimed by the common x86 "user_return_msrs" mechanism.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200923180409.32255-15-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 14a61b642de9e5612f091b3295da6d0c89449a49)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 985a4bfb7517,07781403db08..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -615,8 -615,8 +615,13 @@@ static inline int __find_msr_index(stru
  {
  	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < vmx->nmsrs; ++i)
 +		if (vmx_msr_index[vmx->guest_msrs[i].index] == msr)
++=======
+ 	for (i = 0; i < vmx->nr_uret_msrs; ++i)
+ 		if (vmx_uret_msrs_list[vmx->guest_uret_msrs[i].index] == msr)
++>>>>>>> 14a61b642de9 (KVM: VMX: Rename "vmx_msr_index" to "vmx_uret_msrs_list")
  			return i;
  	return -1;
  }
@@@ -6777,12 -6718,12 +6782,16 @@@ static int vmx_create_vcpu(struct kvm_v
  			goto free_vpid;
  	}
  
++<<<<<<< HEAD
 +	BUILD_BUG_ON(ARRAY_SIZE(vmx_msr_index) != MAX_NR_SHARED_MSRS);
++=======
+ 	BUILD_BUG_ON(ARRAY_SIZE(vmx_uret_msrs_list) != MAX_NR_USER_RETURN_MSRS);
++>>>>>>> 14a61b642de9 (KVM: VMX: Rename "vmx_msr_index" to "vmx_uret_msrs_list")
  
- 	for (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {
- 		u32 index = vmx_msr_index[i];
+ 	for (i = 0; i < ARRAY_SIZE(vmx_uret_msrs_list); ++i) {
+ 		u32 index = vmx_uret_msrs_list[i];
  		u32 data_low, data_high;
 -		int j = vmx->nr_uret_msrs;
 +		int j = vmx->nmsrs;
  
  		if (rdmsr_safe(index, &data_low, &data_high) < 0)
  			continue;
* Unmerged path arch/x86/kvm/vmx/vmx.c
