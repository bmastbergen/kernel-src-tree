lib/vdso: Move VCLOCK_TIMENS to vdso_clock_modes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 2d6b01bd88ccabba06d342ef80eaab6b39d12497
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2d6b01bd.failed

Move the time namespace indicator clock mode to the other ones for
consistency sake.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
Link: https://lkml.kernel.org/r/20200207124403.656097274@linutronix.de



(cherry picked from commit 2d6b01bd88ccabba06d342ef80eaab6b39d12497)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/clocksource.h
#	kernel/time/namespace.c
#	lib/vdso/gettimeofday.c
diff --cc include/linux/clocksource.h
index 1b7db49717c9,02e3282719bd..000000000000
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@@ -27,6 -28,17 +27,20 @@@ struct module
  #include <asm/clocksource.h>
  #endif
  
++<<<<<<< HEAD
++=======
+ enum vdso_clock_mode {
+ 	VDSO_CLOCKMODE_NONE,
+ #ifdef CONFIG_GENERIC_GETTIMEOFDAY
+ 	VDSO_ARCH_CLOCKMODES,
+ #endif
+ 	VDSO_CLOCKMODE_MAX,
+ 
+ 	/* Indicator for time namespace VDSO */
+ 	VDSO_CLOCKMODE_TIMENS = INT_MAX
+ };
+ 
++>>>>>>> 2d6b01bd88cc (lib/vdso: Move VCLOCK_TIMENS to vdso_clock_modes)
  /**
   * struct clocksource - hardware abstraction for a free running counter
   *	Provides mostly state-free accessors to the underlying hardware.
diff --cc lib/vdso/gettimeofday.c
index 632c43443888,a76ac8d17c5f..000000000000
--- a/lib/vdso/gettimeofday.c
+++ b/lib/vdso/gettimeofday.c
@@@ -33,16 -110,37 +33,42 @@@ static int do_hres(const struct vdso_da
  	u64 cycles, last, sec, ns;
  	u32 seq;
  
 -	/* Allows to compile the high resolution parts out */
 -	if (!__arch_vdso_hres_capable())
 -		return -1;
 -
  	do {
++<<<<<<< HEAD
 +		seq = vdso_read_begin(vd);
 +		cycles = __arch_get_hw_counter(vd->clock_mode) &
 +			vd->mask;
++=======
+ 		/*
+ 		 * Open coded to handle VDSO_CLOCKMODE_TIMENS. Time namespace
+ 		 * enabled tasks have a special VVAR page installed which
+ 		 * has vd->seq set to 1 and vd->clock_mode set to
+ 		 * VDSO_CLOCKMODE_TIMENS. For non time namespace affected tasks
+ 		 * this does not affect performance because if vd->seq is
+ 		 * odd, i.e. a concurrent update is in progress the extra
+ 		 * check for vd->clock_mode is just a few extra
+ 		 * instructions while spin waiting for vd->seq to become
+ 		 * even again.
+ 		 */
+ 		while (unlikely((seq = READ_ONCE(vd->seq)) & 1)) {
+ 			if (IS_ENABLED(CONFIG_TIME_NS) &&
+ 			    vd->clock_mode == VDSO_CLOCKMODE_TIMENS)
+ 				return do_hres_timens(vd, clk, ts);
+ 			cpu_relax();
+ 		}
+ 		smp_rmb();
+ 
+ 		if (unlikely(vd->clock_mode == VDSO_CLOCKMODE_NONE))
+ 			return -1;
+ 
+ 		cycles = __arch_get_hw_counter(vd->clock_mode);
++>>>>>>> 2d6b01bd88cc (lib/vdso: Move VCLOCK_TIMENS to vdso_clock_modes)
  		ns = vdso_ts->nsec;
  		last = vd->cycle_last;
 -		ns += vdso_calc_delta(cycles, last, vd->mask, vd->mult);
 +		if (unlikely((s64)cycles < 0))
 +			return clock_gettime_fallback(clk, ts);
 +		if (cycles > last)
 +			ns += (cycles - last) * vd->mult;
  		ns >>= vd->shift;
  		sec = vdso_ts->sec;
  	} while (unlikely(vdso_read_retry(vd, seq)));
@@@ -64,7 -199,18 +90,22 @@@ static void do_coarse(const struct vdso
  	u32 seq;
  
  	do {
++<<<<<<< HEAD
 +		seq = vdso_read_begin(vd);
++=======
+ 		/*
+ 		 * Open coded to handle VDSO_CLOCK_TIMENS. See comment in
+ 		 * do_hres().
+ 		 */
+ 		while ((seq = READ_ONCE(vd->seq)) & 1) {
+ 			if (IS_ENABLED(CONFIG_TIME_NS) &&
+ 			    vd->clock_mode == VDSO_CLOCKMODE_TIMENS)
+ 				return do_coarse_timens(vd, clk, ts);
+ 			cpu_relax();
+ 		}
+ 		smp_rmb();
+ 
++>>>>>>> 2d6b01bd88cc (lib/vdso: Move VCLOCK_TIMENS to vdso_clock_modes)
  		ts->tv_sec = vdso_ts->sec;
  		ts->tv_nsec = vdso_ts->nsec;
  	} while (unlikely(vdso_read_retry(vd, seq)));
@@@ -132,6 -291,10 +173,13 @@@ __cvdso_gettimeofday(struct __kernel_ol
  	}
  
  	if (unlikely(tz != NULL)) {
++<<<<<<< HEAD
++=======
+ 		if (IS_ENABLED(CONFIG_TIME_NS) &&
+ 		    vd->clock_mode == VDSO_CLOCKMODE_TIMENS)
+ 			vd = __arch_get_timens_vdso_data();
+ 
++>>>>>>> 2d6b01bd88cc (lib/vdso: Move VCLOCK_TIMENS to vdso_clock_modes)
  		tz->tz_minuteswest = vd[CS_HRES_COARSE].tz_minuteswest;
  		tz->tz_dsttime = vd[CS_HRES_COARSE].tz_dsttime;
  	}
@@@ -140,10 -303,16 +188,20 @@@
  }
  
  #ifdef VDSO_HAS_TIME
 -static __maybe_unused __kernel_old_time_t __cvdso_time(__kernel_old_time_t *time)
 +static __maybe_unused time_t __cvdso_time(time_t *time)
  {
  	const struct vdso_data *vd = __arch_get_vdso_data();
++<<<<<<< HEAD
 +	time_t t = READ_ONCE(vd[CS_HRES_COARSE].basetime[CLOCK_REALTIME].sec);
++=======
+ 	__kernel_old_time_t t;
+ 
+ 	if (IS_ENABLED(CONFIG_TIME_NS) &&
+ 	    vd->clock_mode == VDSO_CLOCKMODE_TIMENS)
+ 		vd = __arch_get_timens_vdso_data();
+ 
+ 	t = READ_ONCE(vd[CS_HRES_COARSE].basetime[CLOCK_REALTIME].sec);
++>>>>>>> 2d6b01bd88cc (lib/vdso: Move VCLOCK_TIMENS to vdso_clock_modes)
  
  	if (time)
  		*time = t;
@@@ -163,7 -331,11 +221,15 @@@ int __cvdso_clock_getres(clockid_t cloc
  
  	/* Check for negative values or invalid clocks */
  	if (unlikely((u32) clock >= MAX_CLOCKS))
++<<<<<<< HEAD
 +		goto fallback;
++=======
+ 		return -1;
+ 
+ 	if (IS_ENABLED(CONFIG_TIME_NS) &&
+ 	    vd->clock_mode == VDSO_CLOCKMODE_TIMENS)
+ 		vd = __arch_get_timens_vdso_data();
++>>>>>>> 2d6b01bd88cc (lib/vdso: Move VCLOCK_TIMENS to vdso_clock_modes)
  
  	/*
  	 * Convert the clockid to a bitmask and use it to check which
* Unmerged path kernel/time/namespace.c
* Unmerged path include/linux/clocksource.h
* Unmerged path kernel/time/namespace.c
* Unmerged path lib/vdso/gettimeofday.c
