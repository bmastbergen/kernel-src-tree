x86/apic: Always provide irq_compose_msi_msg() method for vector domain

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] apic: Always provide irq_compose_msi_msg() method for vector domain (Vitaly Kuznetsov) [1903823]
Rebuild_FUZZ: 97.10%
commit-author David Woodhouse <dwmw@amazon.co.uk>
commit f598181acfb36f67e1de138cbe80a7db497f7d8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f598181a.failed

This shouldn't be dependent on PCI_MSI. HPET and I/O-APIC can deliver
interrupts through MSI without having any PCI in the system at all.

	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20201024213535.443185-10-dwmw2@infradead.org

(cherry picked from commit f598181acfb36f67e1de138cbe80a7db497f7d8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/apic.h
#	arch/x86/kernel/apic/msi.c
diff --cc arch/x86/include/asm/apic.h
index a7a548c8f60e,34cb3c159481..000000000000
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@@ -517,42 -513,17 +517,50 @@@ extern int default_check_phys_apicid_pr
  
  #ifdef CONFIG_SMP
  bool apic_id_is_primary_thread(unsigned int id);
 -void apic_smt_update(void);
  #else
  static inline bool apic_id_is_primary_thread(unsigned int id) { return false; }
 -static inline void apic_smt_update(void) { }
  #endif
  
++<<<<<<< HEAD
 +extern void irq_enter(void);
 +extern void irq_exit(void);
 +
 +static inline void entering_irq(void)
 +{
 +	irq_enter();
 +	kvm_set_cpu_l1tf_flush_l1d();
 +}
 +
 +static inline void entering_ack_irq(void)
 +{
 +	entering_irq();
 +	ack_APIC_irq();
 +}
 +
 +static inline void ipi_entering_ack_irq(void)
 +{
 +	irq_enter();
 +	ack_APIC_irq();
 +	kvm_set_cpu_l1tf_flush_l1d();
 +}
 +
 +static inline void exiting_irq(void)
 +{
 +	irq_exit();
 +}
 +
 +static inline void exiting_ack_irq(void)
 +{
 +	ack_APIC_irq();
 +	irq_exit();
 +}
++=======
+ struct msi_msg;
+ struct irq_cfg;
+ 
+ extern void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg,
+ 				  bool dmar);
++>>>>>>> f598181acfb3 (x86/apic: Always provide irq_compose_msi_msg() method for vector domain)
  
  extern void ioapic_zap_locks(void);
  
diff --cc arch/x86/kernel/apic/msi.c
index b97f36407a88,4eda617eda1e..000000000000
--- a/arch/x86/kernel/apic/msi.c
+++ b/arch/x86/kernel/apic/msi.c
@@@ -24,35 -20,8 +23,38 @@@
  #include <asm/apic.h>
  #include <asm/irq_remapping.h>
  
 -struct irq_domain *x86_pci_msi_default_domain __ro_after_init;
 +static struct irq_domain *msi_default_domain;
 +
++<<<<<<< HEAD
 +static void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg)
 +{
 +	msg->address_hi = MSI_ADDR_BASE_HI;
 +
 +	if (x2apic_enabled())
 +		msg->address_hi |= MSI_ADDR_EXT_DEST_ID(cfg->dest_apicid);
 +
 +	msg->address_lo =
 +		MSI_ADDR_BASE_LO |
 +		((apic->irq_dest_mode == 0) ?
 +			MSI_ADDR_DEST_MODE_PHYSICAL :
 +			MSI_ADDR_DEST_MODE_LOGICAL) |
 +		MSI_ADDR_REDIRECTION_CPU |
 +		MSI_ADDR_DEST_ID(cfg->dest_apicid);
 +
 +	msg->data =
 +		MSI_DATA_TRIGGER_EDGE |
 +		MSI_DATA_LEVEL_ASSERT |
 +		MSI_DATA_DELIVERY_FIXED |
 +		MSI_DATA_VECTOR(cfg->vector);
 +}
 +
 +static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
 +{
 +	__irq_msi_compose_msg(irqd_cfg(data), msg);
 +}
  
++=======
++>>>>>>> f598181acfb3 (x86/apic: Always provide irq_compose_msi_msg() method for vector domain)
  static void irq_msi_update_msg(struct irq_data *irqd, struct irq_cfg *cfg)
  {
  	struct msi_msg msg[2] = { [1] = { }, };
* Unmerged path arch/x86/include/asm/apic.h
diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c
index fa2b1841198c..ea0378567ef8 100644
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@ -48,6 +48,7 @@
 #include <asm/io_apic.h>
 #include <asm/desc.h>
 #include <asm/hpet.h>
+#include <asm/msidef.h>
 #include <asm/mtrr.h>
 #include <asm/time.h>
 #include <asm/smp.h>
@@ -2419,6 +2420,37 @@ int hard_smp_processor_id(void)
 	return read_apic_id();
 }
 
+void __irq_msi_compose_msg(struct irq_cfg *cfg, struct msi_msg *msg,
+			   bool dmar)
+{
+	msg->address_hi = MSI_ADDR_BASE_HI;
+
+	msg->address_lo =
+		MSI_ADDR_BASE_LO |
+		(apic->dest_mode_logical ?
+			MSI_ADDR_DEST_MODE_LOGICAL :
+			MSI_ADDR_DEST_MODE_PHYSICAL) |
+		MSI_ADDR_REDIRECTION_CPU |
+		MSI_ADDR_DEST_ID(cfg->dest_apicid);
+
+	msg->data =
+		MSI_DATA_TRIGGER_EDGE |
+		MSI_DATA_LEVEL_ASSERT |
+		MSI_DATA_DELIVERY_FIXED |
+		MSI_DATA_VECTOR(cfg->vector);
+
+	/*
+	 * Only the IOMMU itself can use the trick of putting destination
+	 * APIC ID into the high bits of the address. Anything else would
+	 * just be writing to memory if it tried that, and needs IR to
+	 * address higher APIC IDs.
+	 */
+	if (dmar)
+		msg->address_hi |= MSI_ADDR_EXT_DEST_ID(cfg->dest_apicid);
+	else
+		WARN_ON_ONCE(MSI_ADDR_EXT_DEST_ID(cfg->dest_apicid));
+}
+
 /*
  * Override the generic EOI implementation with an optimized version.
  * Only called during early boot when only one CPU is active and with
* Unmerged path arch/x86/kernel/apic/msi.c
diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c
index 6867afa5d6e0..1c59afb39828 100644
--- a/arch/x86/kernel/apic/vector.c
+++ b/arch/x86/kernel/apic/vector.c
@@ -839,6 +839,12 @@ void apic_ack_edge(struct irq_data *irqd)
 	apic_ack_irq(irqd);
 }
 
+static void x86_vector_msi_compose_msg(struct irq_data *data,
+				       struct msi_msg *msg)
+{
+       __irq_msi_compose_msg(irqd_cfg(data), msg, false);
+}
+
 static struct irq_chip lapic_controller = {
 	.name			= "APIC",
 	.irq_ack		= apic_ack_edge,
