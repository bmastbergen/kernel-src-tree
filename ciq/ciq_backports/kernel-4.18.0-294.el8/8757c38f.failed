xfs: move xfs_fc_parse_param() above xfs_fc_get_tree()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ian Kent <raven@themaw.net>
commit 8757c38f2cf6e5ac474aabd7deea14729918ff7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8757c38f.failed

Grouping the options parsing and mount handling functions above the
struct fs_context_operations but below the struct super_operations
should improve (some) the grouping of the super operations while also
improving the grouping of the options parsing and mount handling code.

Lastly move xfs_fc_parse_param() and related functions down to above
xfs_fc_get_tree() and it's related functions.

But leave the options enum, struct fs_parameter_spec and the struct
fs_parameter_description declarations at the top since that's the
logical place for them.

This is a straight code move, there aren't any functional changes.

	Signed-off-by: Ian Kent <raven@themaw.net>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 8757c38f2cf6e5ac474aabd7deea14729918ff7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index 9024b0a4c895,d42c2317db66..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -58,343 -59,58 +58,346 @@@ enum 
  	Opt_filestreams, Opt_quota, Opt_noquota, Opt_usrquota, Opt_grpquota,
  	Opt_prjquota, Opt_uquota, Opt_gquota, Opt_pquota,
  	Opt_uqnoenforce, Opt_gqnoenforce, Opt_pqnoenforce, Opt_qnoenforce,
 -	Opt_discard, Opt_nodiscard, Opt_dax,
 +	Opt_discard, Opt_nodiscard, Opt_dax, Opt_err,
  };
  
 -static const struct fs_parameter_spec xfs_param_specs[] = {
 -	fsparam_u32("logbufs",		Opt_logbufs),
 -	fsparam_string("logbsize",	Opt_logbsize),
 -	fsparam_string("logdev",	Opt_logdev),
 -	fsparam_string("rtdev",		Opt_rtdev),
 -	fsparam_flag("wsync",		Opt_wsync),
 -	fsparam_flag("noalign",		Opt_noalign),
 -	fsparam_flag("swalloc",		Opt_swalloc),
 -	fsparam_u32("sunit",		Opt_sunit),
 -	fsparam_u32("swidth",		Opt_swidth),
 -	fsparam_flag("nouuid",		Opt_nouuid),
 -	fsparam_flag("grpid",		Opt_grpid),
 -	fsparam_flag("nogrpid",		Opt_nogrpid),
 -	fsparam_flag("bsdgroups",	Opt_bsdgroups),
 -	fsparam_flag("sysvgroups",	Opt_sysvgroups),
 -	fsparam_string("allocsize",	Opt_allocsize),
 -	fsparam_flag("norecovery",	Opt_norecovery),
 -	fsparam_flag("inode64",		Opt_inode64),
 -	fsparam_flag("inode32",		Opt_inode32),
 -	fsparam_flag("ikeep",		Opt_ikeep),
 -	fsparam_flag("noikeep",		Opt_noikeep),
 -	fsparam_flag("largeio",		Opt_largeio),
 -	fsparam_flag("nolargeio",	Opt_nolargeio),
 -	fsparam_flag("attr2",		Opt_attr2),
 -	fsparam_flag("noattr2",		Opt_noattr2),
 -	fsparam_flag("filestreams",	Opt_filestreams),
 -	fsparam_flag("quota",		Opt_quota),
 -	fsparam_flag("noquota",		Opt_noquota),
 -	fsparam_flag("usrquota",	Opt_usrquota),
 -	fsparam_flag("grpquota",	Opt_grpquota),
 -	fsparam_flag("prjquota",	Opt_prjquota),
 -	fsparam_flag("uquota",		Opt_uquota),
 -	fsparam_flag("gquota",		Opt_gquota),
 -	fsparam_flag("pquota",		Opt_pquota),
 -	fsparam_flag("uqnoenforce",	Opt_uqnoenforce),
 -	fsparam_flag("gqnoenforce",	Opt_gqnoenforce),
 -	fsparam_flag("pqnoenforce",	Opt_pqnoenforce),
 -	fsparam_flag("qnoenforce",	Opt_qnoenforce),
 -	fsparam_flag("discard",		Opt_discard),
 -	fsparam_flag("nodiscard",	Opt_nodiscard),
 -	fsparam_flag("dax",		Opt_dax),
 -	{}
 +static const match_table_t tokens = {
 +	{Opt_logbufs,	"logbufs=%u"},	/* number of XFS log buffers */
 +	{Opt_logbsize,	"logbsize=%s"},	/* size of XFS log buffers */
 +	{Opt_logdev,	"logdev=%s"},	/* log device */
 +	{Opt_rtdev,	"rtdev=%s"},	/* realtime I/O device */
 +	{Opt_biosize,	"biosize=%u"},	/* log2 of preferred buffered io size */
 +	{Opt_wsync,	"wsync"},	/* safe-mode nfs compatible mount */
 +	{Opt_noalign,	"noalign"},	/* turn off stripe alignment */
 +	{Opt_swalloc,	"swalloc"},	/* turn on stripe width allocation */
 +	{Opt_sunit,	"sunit=%u"},	/* data volume stripe unit */
 +	{Opt_swidth,	"swidth=%u"},	/* data volume stripe width */
 +	{Opt_nouuid,	"nouuid"},	/* ignore filesystem UUID */
 +	{Opt_grpid,	"grpid"},	/* group-ID from parent directory */
 +	{Opt_nogrpid,	"nogrpid"},	/* group-ID from current process */
 +	{Opt_bsdgroups,	"bsdgroups"},	/* group-ID from parent directory */
 +	{Opt_sysvgroups,"sysvgroups"},	/* group-ID from current process */
 +	{Opt_allocsize,	"allocsize=%s"},/* preferred allocation size */
 +	{Opt_norecovery,"norecovery"},	/* don't run XFS recovery */
 +	{Opt_inode64,	"inode64"},	/* inodes can be allocated anywhere */
 +	{Opt_inode32,   "inode32"},	/* inode allocation limited to
 +					 * XFS_MAXINUMBER_32 */
 +	{Opt_ikeep,	"ikeep"},	/* do not free empty inode clusters */
 +	{Opt_noikeep,	"noikeep"},	/* free empty inode clusters */
 +	{Opt_largeio,	"largeio"},	/* report large I/O sizes in stat() */
 +	{Opt_nolargeio,	"nolargeio"},	/* do not report large I/O sizes
 +					 * in stat(). */
 +	{Opt_attr2,	"attr2"},	/* do use attr2 attribute format */
 +	{Opt_noattr2,	"noattr2"},	/* do not use attr2 attribute format */
 +	{Opt_filestreams,"filestreams"},/* use filestreams allocator */
 +	{Opt_quota,	"quota"},	/* disk quotas (user) */
 +	{Opt_noquota,	"noquota"},	/* no quotas */
 +	{Opt_usrquota,	"usrquota"},	/* user quota enabled */
 +	{Opt_grpquota,	"grpquota"},	/* group quota enabled */
 +	{Opt_prjquota,	"prjquota"},	/* project quota enabled */
 +	{Opt_uquota,	"uquota"},	/* user quota (IRIX variant) */
 +	{Opt_gquota,	"gquota"},	/* group quota (IRIX variant) */
 +	{Opt_pquota,	"pquota"},	/* project quota (IRIX variant) */
 +	{Opt_uqnoenforce,"uqnoenforce"},/* user quota limit enforcement */
 +	{Opt_gqnoenforce,"gqnoenforce"},/* group quota limit enforcement */
 +	{Opt_pqnoenforce,"pqnoenforce"},/* project quota limit enforcement */
 +	{Opt_qnoenforce, "qnoenforce"},	/* same as uqnoenforce */
 +	{Opt_discard,	"discard"},	/* Discard unused blocks */
 +	{Opt_nodiscard,	"nodiscard"},	/* Do not discard unused blocks */
 +	{Opt_dax,	"dax"},		/* Enable direct access to bdev pages */
 +	{Opt_err,	NULL},
  };
  
 -static const struct fs_parameter_description xfs_fs_parameters = {
 -	.name		= "xfs",
 -	.specs		= xfs_param_specs,
 -};
  
++<<<<<<< HEAD
 +STATIC int
 +suffix_kstrtoint(const substring_t *s, unsigned int base, int *res)
 +{
 +	int	last, shift_left_factor = 0, _res;
 +	char	*value;
 +	int	ret = 0;
 +
 +	value = match_strdup(s);
 +	if (!value)
 +		return -ENOMEM;
 +
 +	last = strlen(value) - 1;
 +	if (value[last] == 'K' || value[last] == 'k') {
 +		shift_left_factor = 10;
 +		value[last] = '\0';
 +	}
 +	if (value[last] == 'M' || value[last] == 'm') {
 +		shift_left_factor = 20;
 +		value[last] = '\0';
 +	}
 +	if (value[last] == 'G' || value[last] == 'g') {
 +		shift_left_factor = 30;
 +		value[last] = '\0';
 +	}
 +
 +	if (kstrtoint(value, base, &_res))
 +		ret = -EINVAL;
 +	kfree(value);
 +	*res = _res << shift_left_factor;
 +	return ret;
 +}
 +
 +/*
 + * This function fills in xfs_mount_t fields based on mount args.
 + * Note: the superblock has _not_ yet been read in.
 + *
 + * Note that this function leaks the various device name allocations on
 + * failure.  The caller takes care of them.
 + *
 + * *sb is const because this is also used to test options on the remount
 + * path, and we don't want this to have any side effects at remount time.
 + * Today this function does not change *sb, but just to future-proof...
 + */
 +STATIC int
 +xfs_parseargs(
 +	struct xfs_mount	*mp,
 +	char			*options)
 +{
 +	const struct super_block *sb = mp->m_super;
 +	char			*p;
 +	substring_t		args[MAX_OPT_ARGS];
 +	int			iosize = 0;
 +	uint8_t			iosizelog = 0;
 +
 +	/*
 +	 * Copy binary VFS mount flags we are interested in.
 +	 */
 +	if (sb_rdonly(sb))
 +		mp->m_flags |= XFS_MOUNT_RDONLY;
 +	if (sb->s_flags & SB_DIRSYNC)
 +		mp->m_flags |= XFS_MOUNT_DIRSYNC;
 +	if (sb->s_flags & SB_SYNCHRONOUS)
 +		mp->m_flags |= XFS_MOUNT_WSYNC;
 +
 +	/*
 +	 * These can be overridden by the mount option parsing.
 +	 */
 +	mp->m_logbufs = -1;
 +	mp->m_logbsize = -1;
 +
 +	if (!options)
 +		return 0;
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int		token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_logbufs:
 +			if (match_int(args, &mp->m_logbufs))
 +				return -EINVAL;
 +			break;
 +		case Opt_logbsize:
 +			if (suffix_kstrtoint(args, 10, &mp->m_logbsize))
 +				return -EINVAL;
 +			break;
 +		case Opt_logdev:
 +			kfree(mp->m_logname);
 +			mp->m_logname = match_strdup(args);
 +			if (!mp->m_logname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_rtdev:
 +			kfree(mp->m_rtname);
 +			mp->m_rtname = match_strdup(args);
 +			if (!mp->m_rtname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_allocsize:
 +		case Opt_biosize:
 +			if (suffix_kstrtoint(args, 10, &iosize))
 +				return -EINVAL;
 +			iosizelog = ffs(iosize) - 1;
 +			break;
 +		case Opt_grpid:
 +		case Opt_bsdgroups:
 +			mp->m_flags |= XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_nogrpid:
 +		case Opt_sysvgroups:
 +			mp->m_flags &= ~XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_wsync:
 +			mp->m_flags |= XFS_MOUNT_WSYNC;
 +			break;
 +		case Opt_norecovery:
 +			mp->m_flags |= XFS_MOUNT_NORECOVERY;
 +			break;
 +		case Opt_noalign:
 +			mp->m_flags |= XFS_MOUNT_NOALIGN;
 +			break;
 +		case Opt_swalloc:
 +			mp->m_flags |= XFS_MOUNT_SWALLOC;
 +			break;
 +		case Opt_sunit:
 +			if (match_int(args, &mp->m_dalign))
 +				return -EINVAL;
 +			break;
 +		case Opt_swidth:
 +			if (match_int(args, &mp->m_swidth))
 +				return -EINVAL;
 +			break;
 +		case Opt_inode32:
 +			mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_inode64:
 +			mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_nouuid:
 +			mp->m_flags |= XFS_MOUNT_NOUUID;
 +			break;
 +		case Opt_ikeep:
 +			mp->m_flags |= XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_noikeep:
 +			mp->m_flags &= ~XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_largeio:
 +			mp->m_flags |= XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_nolargeio:
 +			mp->m_flags &= ~XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_attr2:
 +			mp->m_flags |= XFS_MOUNT_ATTR2;
 +			break;
 +		case Opt_noattr2:
 +			mp->m_flags &= ~XFS_MOUNT_ATTR2;
 +			mp->m_flags |= XFS_MOUNT_NOATTR2;
 +			break;
 +		case Opt_filestreams:
 +			mp->m_flags |= XFS_MOUNT_FILESTREAMS;
 +			break;
 +		case Opt_noquota:
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
 +			break;
 +		case Opt_quota:
 +		case Opt_uquota:
 +		case Opt_usrquota:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
 +					 XFS_UQUOTA_ENFD);
 +			break;
 +		case Opt_qnoenforce:
 +		case Opt_uqnoenforce:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_UQUOTA_ENFD;
 +			break;
 +		case Opt_pquota:
 +		case Opt_prjquota:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
 +					 XFS_PQUOTA_ENFD);
 +			break;
 +		case Opt_pqnoenforce:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_PQUOTA_ENFD;
 +			break;
 +		case Opt_gquota:
 +		case Opt_grpquota:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
 +					 XFS_GQUOTA_ENFD);
 +			break;
 +		case Opt_gqnoenforce:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_GQUOTA_ENFD;
 +			break;
 +		case Opt_discard:
 +			mp->m_flags |= XFS_MOUNT_DISCARD;
 +			break;
 +		case Opt_nodiscard:
 +			mp->m_flags &= ~XFS_MOUNT_DISCARD;
 +			break;
 +#ifdef CONFIG_FS_DAX
 +		case Opt_dax:
 +			mp->m_flags |= XFS_MOUNT_DAX;
 +			break;
 +#endif
 +		default:
 +			xfs_warn(mp, "unknown mount option [%s].", p);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	/*
 +	 * no recovery flag requires a read-only mount
 +	 */
 +	if ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&
 +	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
 +		xfs_warn(mp, "no-recovery mounts must be read-only.");
 +		return -EINVAL;
 +	}
 +
 +	if ((mp->m_flags & XFS_MOUNT_NOALIGN) &&
 +	    (mp->m_dalign || mp->m_swidth)) {
 +		xfs_warn(mp,
 +	"sunit and swidth options incompatible with the noalign option");
 +		return -EINVAL;
 +	}
 +
 +	if (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {
 +		xfs_warn(mp, "quota support not available in this kernel.");
 +		return -EINVAL;
 +	}
 +
 +	if ((mp->m_dalign && !mp->m_swidth) ||
 +	    (!mp->m_dalign && mp->m_swidth)) {
 +		xfs_warn(mp, "sunit and swidth must be specified together");
 +		return -EINVAL;
 +	}
 +
 +	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
 +		xfs_warn(mp,
 +	"stripe width (%d) must be a multiple of the stripe unit (%d)",
 +			mp->m_swidth, mp->m_dalign);
 +		return -EINVAL;
 +	}
 +
 +	if (mp->m_logbufs != -1 &&
 +	    mp->m_logbufs != 0 &&
 +	    (mp->m_logbufs < XLOG_MIN_ICLOGS ||
 +	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
 +		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
 +			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
 +		return -EINVAL;
 +	}
 +	if (mp->m_logbsize != -1 &&
 +	    mp->m_logbsize !=  0 &&
 +	    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||
 +	     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||
 +	     !is_power_of_2(mp->m_logbsize))) {
 +		xfs_warn(mp,
 +			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
 +			mp->m_logbsize);
 +		return -EINVAL;
 +	}
 +
 +	if (iosizelog) {
 +		if (iosizelog > XFS_MAX_IO_LOG ||
 +		    iosizelog < XFS_MIN_IO_LOG) {
 +			xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
 +				iosizelog, XFS_MIN_IO_LOG,
 +				XFS_MAX_IO_LOG);
 +			return -EINVAL;
 +		}
 +
 +		mp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;
 +		mp->m_allocsize_log = iosizelog;
 +	}
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 8757c38f2cf6 (xfs: move xfs_fc_parse_param() above xfs_fc_get_tree())
  struct proc_xfs_info {
  	uint64_t	flag;
  	char		*str;
@@@ -1561,28 -1125,277 +1564,292 @@@ xfs_mount_alloc(void
  	return mp;
  }
  
++<<<<<<< HEAD
 +
 +STATIC int
 +xfs_fs_fill_super(
++=======
+ static int
+ suffix_kstrtoint(
+ 	const char	*s,
+ 	unsigned int	base,
+ 	int		*res)
+ {
+ 	int		last, shift_left_factor = 0, _res;
+ 	char		*value;
+ 	int		ret = 0;
+ 
+ 	value = kstrdup(s, GFP_KERNEL);
+ 	if (!value)
+ 		return -ENOMEM;
+ 
+ 	last = strlen(value) - 1;
+ 	if (value[last] == 'K' || value[last] == 'k') {
+ 		shift_left_factor = 10;
+ 		value[last] = '\0';
+ 	}
+ 	if (value[last] == 'M' || value[last] == 'm') {
+ 		shift_left_factor = 20;
+ 		value[last] = '\0';
+ 	}
+ 	if (value[last] == 'G' || value[last] == 'g') {
+ 		shift_left_factor = 30;
+ 		value[last] = '\0';
+ 	}
+ 
+ 	if (kstrtoint(value, base, &_res))
+ 		ret = -EINVAL;
+ 	kfree(value);
+ 	*res = _res << shift_left_factor;
+ 	return ret;
+ }
+ 
+ /*
+  * Set mount state from a mount option.
+  *
+  * NOTE: mp->m_super is NULL here!
+  */
+ static int
+ xfs_fc_parse_param(
+ 	struct fs_context	*fc,
+ 	struct fs_parameter	*param)
+ {
+ 	struct xfs_mount	*mp = fc->s_fs_info;
+ 	struct fs_parse_result	result;
+ 	int			size = 0;
+ 	int			opt;
+ 
+ 	opt = fs_parse(fc, &xfs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_logbufs:
+ 		mp->m_logbufs = result.uint_32;
+ 		return 0;
+ 	case Opt_logbsize:
+ 		if (suffix_kstrtoint(param->string, 10, &mp->m_logbsize))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_logdev:
+ 		kfree(mp->m_logname);
+ 		mp->m_logname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_logname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_rtdev:
+ 		kfree(mp->m_rtname);
+ 		mp->m_rtname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_rtname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_allocsize:
+ 		if (suffix_kstrtoint(param->string, 10, &size))
+ 			return -EINVAL;
+ 		mp->m_allocsize_log = ffs(size) - 1;
+ 		mp->m_flags |= XFS_MOUNT_ALLOCSIZE;
+ 		return 0;
+ 	case Opt_grpid:
+ 	case Opt_bsdgroups:
+ 		mp->m_flags |= XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_nogrpid:
+ 	case Opt_sysvgroups:
+ 		mp->m_flags &= ~XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_wsync:
+ 		mp->m_flags |= XFS_MOUNT_WSYNC;
+ 		return 0;
+ 	case Opt_norecovery:
+ 		mp->m_flags |= XFS_MOUNT_NORECOVERY;
+ 		return 0;
+ 	case Opt_noalign:
+ 		mp->m_flags |= XFS_MOUNT_NOALIGN;
+ 		return 0;
+ 	case Opt_swalloc:
+ 		mp->m_flags |= XFS_MOUNT_SWALLOC;
+ 		return 0;
+ 	case Opt_sunit:
+ 		mp->m_dalign = result.uint_32;
+ 		return 0;
+ 	case Opt_swidth:
+ 		mp->m_swidth = result.uint_32;
+ 		return 0;
+ 	case Opt_inode32:
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_inode64:
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_nouuid:
+ 		mp->m_flags |= XFS_MOUNT_NOUUID;
+ 		return 0;
+ 	case Opt_ikeep:
+ 		mp->m_flags |= XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_noikeep:
+ 		mp->m_flags &= ~XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_largeio:
+ 		mp->m_flags |= XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_nolargeio:
+ 		mp->m_flags &= ~XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_attr2:
+ 		mp->m_flags |= XFS_MOUNT_ATTR2;
+ 		return 0;
+ 	case Opt_noattr2:
+ 		mp->m_flags &= ~XFS_MOUNT_ATTR2;
+ 		mp->m_flags |= XFS_MOUNT_NOATTR2;
+ 		return 0;
+ 	case Opt_filestreams:
+ 		mp->m_flags |= XFS_MOUNT_FILESTREAMS;
+ 		return 0;
+ 	case Opt_noquota:
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
+ 		return 0;
+ 	case Opt_quota:
+ 	case Opt_uquota:
+ 	case Opt_usrquota:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
+ 				 XFS_UQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_qnoenforce:
+ 	case Opt_uqnoenforce:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_UQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_pquota:
+ 	case Opt_prjquota:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
+ 				 XFS_PQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_pqnoenforce:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_PQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_gquota:
+ 	case Opt_grpquota:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
+ 				 XFS_GQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_gqnoenforce:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_GQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_discard:
+ 		mp->m_flags |= XFS_MOUNT_DISCARD;
+ 		return 0;
+ 	case Opt_nodiscard:
+ 		mp->m_flags &= ~XFS_MOUNT_DISCARD;
+ 		return 0;
+ #ifdef CONFIG_FS_DAX
+ 	case Opt_dax:
+ 		mp->m_flags |= XFS_MOUNT_DAX;
+ 		return 0;
+ #endif
+ 	default:
+ 		xfs_warn(mp, "unknown mount option [%s].", param->key);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_fc_validate_params(
+ 	struct xfs_mount	*mp)
+ {
+ 	/*
+ 	 * no recovery flag requires a read-only mount
+ 	 */
+ 	if ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&
+ 	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
+ 		xfs_warn(mp, "no-recovery mounts must be read-only.");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((mp->m_flags & XFS_MOUNT_NOALIGN) &&
+ 	    (mp->m_dalign || mp->m_swidth)) {
+ 		xfs_warn(mp,
+ 	"sunit and swidth options incompatible with the noalign option");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {
+ 		xfs_warn(mp, "quota support not available in this kernel.");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((mp->m_dalign && !mp->m_swidth) ||
+ 	    (!mp->m_dalign && mp->m_swidth)) {
+ 		xfs_warn(mp, "sunit and swidth must be specified together");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
+ 		xfs_warn(mp,
+ 	"stripe width (%d) must be a multiple of the stripe unit (%d)",
+ 			mp->m_swidth, mp->m_dalign);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mp->m_logbufs != -1 &&
+ 	    mp->m_logbufs != 0 &&
+ 	    (mp->m_logbufs < XLOG_MIN_ICLOGS ||
+ 	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
+ 		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
+ 			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (mp->m_logbsize != -1 &&
+ 	    mp->m_logbsize !=  0 &&
+ 	    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||
+ 	     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||
+ 	     !is_power_of_2(mp->m_logbsize))) {
+ 		xfs_warn(mp,
+ 			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
+ 			mp->m_logbsize);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((mp->m_flags & XFS_MOUNT_ALLOCSIZE) &&
+ 	    (mp->m_allocsize_log > XFS_MAX_IO_LOG ||
+ 	     mp->m_allocsize_log < XFS_MIN_IO_LOG)) {
+ 		xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
+ 			mp->m_allocsize_log, XFS_MIN_IO_LOG, XFS_MAX_IO_LOG);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_fc_fill_super(
++>>>>>>> 8757c38f2cf6 (xfs: move xfs_fc_parse_param() above xfs_fc_get_tree())
  	struct super_block	*sb,
 -	struct fs_context	*fc)
 +	void			*data,
 +	int			silent)
  {
 -	struct xfs_mount	*mp = sb->s_fs_info;
  	struct inode		*root;
 +	struct xfs_mount	*mp = NULL;
  	int			flags = 0, error = -ENOMEM;
  
 +	/*
 +	 * allocate mp and do all low-level struct initializations before we
 +	 * attach it to the super
 +	 */
 +	mp = xfs_mount_alloc();
 +	if (!mp)
 +		goto out;
  	mp->m_super = sb;
 +	sb->s_fs_info = mp;
  
 -	error = xfs_fc_validate_params(mp);
 +	error = xfs_parseargs(mp, (char *)data);
  	if (error)
  		goto out_free_names;
  
* Unmerged path fs/xfs/xfs_super.c
