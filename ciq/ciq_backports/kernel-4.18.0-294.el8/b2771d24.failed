mptcp: drop WORKER_RUNNING status bit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit b2771d2419fa6e978dec9ba6ccb93c5c76106374
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b2771d24.failed

Only mptcp_close() can actually cancel the workqueue,
no need to add and use this flag.

	Reviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit b2771d2419fa6e978dec9ba6ccb93c5c76106374)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
#	net/mptcp/protocol.h
diff --cc net/mptcp/protocol.c
index d41791292d73,1aaf58c59f41..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -1426,16 -1856,16 +1426,23 @@@ static void mptcp_worker(struct work_st
  {
  	struct mptcp_sock *msk = container_of(work, struct mptcp_sock, work);
  	struct sock *ssk, *sk = &msk->sk.icsk_inet.sk;
 -	struct mptcp_sendmsg_info info = {};
 +	int orig_len, orig_offset, mss_now = 0, size_goal = 0;
  	struct mptcp_data_frag *dfrag;
 +	u64 orig_write_seq;
  	size_t copied = 0;
 -	int state, ret;
 +	struct msghdr msg = {
 +		.msg_flags = MSG_DONTWAIT,
 +	};
 +	long timeo = 0;
  
  	lock_sock(sk);
++<<<<<<< HEAD
++=======
+ 	state = sk->sk_state;
+ 	if (unlikely(state == TCP_CLOSE))
+ 		goto unlock;
+ 
++>>>>>>> b2771d2419fa (mptcp: drop WORKER_RUNNING status bit)
  	mptcp_clean_una_wakeup(sk);
  	mptcp_check_data_fin_ack(sk);
  	__mptcp_flush_join_list(msk);
@@@ -1566,10 -2010,10 +1573,14 @@@ static void mptcp_cancel_work(struct so
  	struct mptcp_sock *msk = mptcp_sk(sk);
  
  	if (cancel_work_sync(&msk->work))
++<<<<<<< HEAD
 +		sock_put(sk);
++=======
+ 		__sock_put(sk);
++>>>>>>> b2771d2419fa (mptcp: drop WORKER_RUNNING status bit)
  }
  
 -void mptcp_subflow_shutdown(struct sock *sk, struct sock *ssk, int how)
 +static void mptcp_subflow_shutdown(struct sock *sk, struct sock *ssk, int how)
  {
  	lock_sock(ssk);
  
diff --cc net/mptcp/protocol.h
index a60ec79c4e54,10fffc5de9e4..000000000000
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@@ -90,6 -90,7 +90,10 @@@
  #define MPTCP_WORK_RTX		2
  #define MPTCP_WORK_EOF		3
  #define MPTCP_FALLBACK_DONE	4
++<<<<<<< HEAD
++=======
+ #define MPTCP_WORK_CLOSE_SUBFLOW 5
++>>>>>>> b2771d2419fa (mptcp: drop WORKER_RUNNING status bit)
  
  static inline bool before64(__u64 seq1, __u64 seq2)
  {
* Unmerged path net/mptcp/protocol.c
* Unmerged path net/mptcp/protocol.h
