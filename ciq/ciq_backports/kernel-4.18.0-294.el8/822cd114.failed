net: atlantic: implement UDP GSO offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Igor Russkikh <irusskikh@marvell.com>
commit 822cd114cd05a47b7c272de9b3a4da73114894ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/822cd114.failed

atlantic hardware does support UDP hardware segmentation offload.
This allows user to specify one large contiguous buffer with data
which then will be split automagically into multiple UDP packets
of specified size.

Bulk sending of large UDP streams lowers CPU usage and increases
bandwidth.

We did estimations both with udpgso_bench_tx test tool and with modified
iperf3 measurement tool (4 streams, multithread, 200b packet size)
over AQC<->AQC 10G link. Flow control is disabled to prevent RX side
impact on measurements.

No UDP GSO:
	iperf3 -c 10.0.1.2 -u -b0 -l 200 -P4 --multithread
UDP GSO:
	iperf3 -c 10.0.1.2 -u -b0 -l 12600 --udp-lso 200 -P4 --multithread

Mode          CPU   iperf speed    Line speed   Packets per second
-------------------------------------------------------------
NO UDP GSO    350%   3.07 Gbps      3.8 Gbps     1,919,419
SW UDP GSO    200%   5.55 Gbps      6.4 Gbps     3,286,144
HW UDP GSO    90%    6.80 Gbps      8.4 Gbps     4,273,117

	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 822cd114cd05a47b7c272de9b3a4da73114894ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/device_drivers/aquantia/atlantic.txt
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index a0d4f402867f,a17a4da7bc15..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -289,7 -307,9 +289,13 @@@ void aq_nic_ndev_init(struct aq_nic_s *
  	self->ndev->hw_features |= aq_hw_caps->hw_features;
  	self->ndev->features = aq_hw_caps->hw_features;
  	self->ndev->vlan_features |= NETIF_F_HW_CSUM | NETIF_F_RXCSUM |
++<<<<<<< HEAD
 +				     NETIF_F_RXHASH | NETIF_F_SG | NETIF_F_LRO;
++=======
+ 				     NETIF_F_RXHASH | NETIF_F_SG |
+ 				     NETIF_F_LRO | NETIF_F_TSO;
+ 	self->ndev->gso_partial_features = NETIF_F_GSO_UDP_L4;
++>>>>>>> 822cd114cd05 (net: atlantic: implement UDP GSO offload)
  	self->ndev->priv_flags = aq_hw_caps->hw_priv_flags;
  	self->ndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
  
@@@ -421,32 -468,62 +427,76 @@@ err_exit
  	return err;
  }
  
 -unsigned int aq_nic_map_skb(struct aq_nic_s *self, struct sk_buff *skb,
 -			    struct aq_ring_s *ring)
 +static unsigned int aq_nic_map_skb(struct aq_nic_s *self,
 +				   struct sk_buff *skb,
 +				   struct aq_ring_s *ring)
  {
++<<<<<<< HEAD
 +	unsigned int ret = 0U;
 +	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
 +	unsigned int frag_count = 0U;
 +	unsigned int dx = ring->sw_tail;
 +	struct aq_ring_buff_s *first = NULL;
 +	struct aq_ring_buff_s *dx_buff = &ring->buff_ring[dx];
 +
 +	if (unlikely(skb_is_gso(skb))) {
 +		dx_buff->flags = 0U;
 +		dx_buff->len_pkt = skb->len;
 +		dx_buff->len_l2 = ETH_HLEN;
 +		dx_buff->len_l3 = ip_hdrlen(skb);
 +		dx_buff->len_l4 = tcp_hdrlen(skb);
 +		dx_buff->mss = skb_shinfo(skb)->gso_size;
 +		dx_buff->is_txc = 1U;
 +		dx_buff->eop_index = 0xffffU;
 +
 +		dx_buff->is_ipv6 =
 +			(ip_hdr(skb)->version == 6) ? 1U : 0U;
++=======
+ 	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+ 	struct aq_ring_buff_s *first = NULL;
+ 	u8 ipver = ip_hdr(skb)->version;
+ 	struct aq_ring_buff_s *dx_buff;
+ 	bool need_context_tag = false;
+ 	unsigned int frag_count = 0U;
+ 	unsigned int ret = 0U;
+ 	unsigned int dx;
+ 	u8 l4proto = 0;
+ 
+ 	if (ipver == 4)
+ 		l4proto = ip_hdr(skb)->protocol;
+ 	else if (ipver == 6)
+ 		l4proto = ipv6_hdr(skb)->nexthdr;
+ 
+ 	dx = ring->sw_tail;
+ 	dx_buff = &ring->buff_ring[dx];
+ 	dx_buff->flags = 0U;
+ 
+ 	if (unlikely(skb_is_gso(skb))) {
+ 		dx_buff->mss = skb_shinfo(skb)->gso_size;
+ 		if (l4proto == IPPROTO_TCP) {
+ 			dx_buff->is_gso_tcp = 1U;
+ 			dx_buff->len_l4 = tcp_hdrlen(skb);
+ 		} else if (l4proto == IPPROTO_UDP) {
+ 			dx_buff->is_gso_udp = 1U;
+ 			dx_buff->len_l4 = sizeof(struct udphdr);
+ 			/* UDP GSO Hardware does not replace packet length. */
+ 			udp_hdr(skb)->len = htons(dx_buff->mss +
+ 						  dx_buff->len_l4);
+ 		} else {
+ 			WARN_ONCE(true, "Bad GSO mode");
+ 			goto exit;
+ 		}
+ 		dx_buff->len_pkt = skb->len;
+ 		dx_buff->len_l2 = ETH_HLEN;
+ 		dx_buff->len_l3 = skb_network_header_len(skb);
+ 		dx_buff->eop_index = 0xffffU;
+ 		dx_buff->is_ipv6 = (ipver == 6);
+ 		need_context_tag = true;
+ 	}
++>>>>>>> 822cd114cd05 (net: atlantic: implement UDP GSO offload)
  
 -	if (self->aq_nic_cfg.is_vlan_tx_insert && skb_vlan_tag_present(skb)) {
 -		dx_buff->vlan_tx_tag = skb_vlan_tag_get(skb);
 -		dx_buff->len_pkt = skb->len;
 -		dx_buff->is_vlan = 1U;
 -		need_context_tag = true;
 -	}
 -
 -	if (need_context_tag) {
  		dx = aq_ring_next_dx(ring, dx);
  		dx_buff = &ring->buff_ring[dx];
 -		dx_buff->flags = 0U;
  		++ret;
  	}
  
@@@ -539,7 -600,8 +574,12 @@@ mapping_error
  	     --ret, dx = aq_ring_next_dx(ring, dx)) {
  		dx_buff = &ring->buff_ring[dx];
  
++<<<<<<< HEAD
 +		if (!dx_buff->is_txc && dx_buff->pa) {
++=======
+ 		if (!(dx_buff->is_gso_tcp || dx_buff->is_gso_udp) &&
+ 		    !dx_buff->is_vlan && dx_buff->pa) {
++>>>>>>> 822cd114cd05 (net: atlantic: implement UDP GSO offload)
  			if (unlikely(dx_buff->is_sop)) {
  				dma_unmap_single(aq_nic_get_dev(self),
  						 dx_buff->pa,
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.h
index cfffc301e746,991e4d31b094..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
@@@ -73,11 -72,13 +73,21 @@@ struct __packed aq_ring_buff_s 
  			u32 is_cso_err:1;
  			u32 is_sop:1;
  			u32 is_eop:1;
++<<<<<<< HEAD
 +			u32 is_txc:1;
 +			u32 is_mapped:1;
 +			u32 is_cleaned:1;
 +			u32 is_error:1;
 +			u32 rsvd3:6;
++=======
+ 			u32 is_gso_tcp:1;
+ 			u32 is_gso_udp:1;
+ 			u32 is_mapped:1;
+ 			u32 is_cleaned:1;
+ 			u32 is_error:1;
+ 			u32 is_vlan:1;
+ 			u32 rsvd3:4;
++>>>>>>> 822cd114cd05 (net: atlantic: implement UDP GSO offload)
  			u16 eop_index;
  			u16 rsvd4;
  		};
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
index 9fe507fe2d7f,9b1062b8af64..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
@@@ -454,7 -454,7 +454,11 @@@ static int hw_atl_a0_hw_ring_tx_xmit(st
  
  		buff = &ring->buff_ring[ring->sw_tail];
  
++<<<<<<< HEAD
 +		if (buff->is_txc) {
++=======
+ 		if (buff->is_gso_tcp) {
++>>>>>>> 822cd114cd05 (net: atlantic: implement UDP GSO offload)
  			txd->ctl |= (buff->len_l3 << 31) |
  				(buff->len_l2 << 24) |
  				HW_ATL_A0_TXD_CTL_CMD_TCP |
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index 42fdeb412b12,58e891af6e09..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -43,7 -41,11 +43,15 @@@
  			NETIF_F_TSO |     \
  			NETIF_F_LRO |     \
  			NETIF_F_NTUPLE |  \
++<<<<<<< HEAD
 +			NETIF_F_HW_VLAN_CTAG_FILTER, \
++=======
+ 			NETIF_F_HW_VLAN_CTAG_FILTER | \
+ 			NETIF_F_HW_VLAN_CTAG_RX |     \
+ 			NETIF_F_HW_VLAN_CTAG_TX |     \
+ 			NETIF_F_GSO_UDP_L4      |     \
+ 			NETIF_F_GSO_PARTIAL,          \
++>>>>>>> 822cd114cd05 (net: atlantic: implement UDP GSO offload)
  	.hw_priv_flags = IFF_UNICAST_FLT, \
  	.flow_control = true,		  \
  	.mtu = HW_ATL_B0_MTU_JUMBO,	  \
@@@ -504,23 -535,29 +512,42 @@@ static int hw_atl_b0_hw_ring_tx_xmit(st
  
  		buff = &ring->buff_ring[ring->sw_tail];
  
++<<<<<<< HEAD
 +		if (buff->is_txc) {
++=======
+ 		if (buff->is_gso_tcp || buff->is_gso_udp) {
+ 			if (buff->is_gso_tcp)
+ 				txd->ctl |= HW_ATL_B0_TXD_CTL_CMD_TCP;
+ 			txd->ctl |= HW_ATL_B0_TXD_CTL_DESC_TYPE_TXC;
++>>>>>>> 822cd114cd05 (net: atlantic: implement UDP GSO offload)
  			txd->ctl |= (buff->len_l3 << 31) |
 -				    (buff->len_l2 << 24);
 -			txd->ctl2 |= (buff->mss << 16);
 -			is_gso = true;
 +				(buff->len_l2 << 24) |
 +				HW_ATL_B0_TXD_CTL_CMD_TCP |
 +				HW_ATL_B0_TXD_CTL_DESC_TYPE_TXC;
 +			txd->ctl2 |= (buff->mss << 16) |
 +				(buff->len_l4 << 8) |
 +				(buff->len_l3 >> 1);
  
  			pkt_len -= (buff->len_l4 +
  				    buff->len_l3 +
  				    buff->len_l2);
 +			is_gso = true;
 +
  			if (buff->is_ipv6)
  				txd->ctl |= HW_ATL_B0_TXD_CTL_CMD_IPV6;
++<<<<<<< HEAD
 +		} else {
++=======
+ 			txd->ctl2 |= (buff->len_l4 << 8) |
+ 				     (buff->len_l3 >> 1);
+ 		}
+ 		if (buff->is_vlan) {
+ 			txd->ctl |= HW_ATL_B0_TXD_CTL_DESC_TYPE_TXC;
+ 			txd->ctl |= buff->vlan_tx_tag << 4;
+ 			is_vlan = true;
+ 		}
+ 		if (!buff->is_gso_tcp && !buff->is_gso_udp && !buff->is_vlan) {
++>>>>>>> 822cd114cd05 (net: atlantic: implement UDP GSO offload)
  			buff_pa_len = buff->len;
  
  			txd->buf_addr = buff->pa;
* Unmerged path Documentation/networking/device_drivers/aquantia/atlantic.txt
* Unmerged path Documentation/networking/device_drivers/aquantia/atlantic.txt
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
