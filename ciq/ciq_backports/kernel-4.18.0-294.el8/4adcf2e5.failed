cpufreq: intel_pstate: Add ->offline and ->online callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 4adcf2e5829f83cbab581ba376abb7cb6404eeb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4adcf2e5.failed

Add ->offline and ->online driver callbacks to prepare for taking a
CPU offline and to restore its working configuration when it goes
back online, respectively, to avoid invoking the ->init callback on
every CPU online which is quite a bit of unnecessary overhead.

Define ->offline and ->online so that they can be used in the
passive mode as well as in the active mode and because ->offline
will do the majority of ->stop_cpu work, the passive mode does
not need that callback any more, so drop it from there.

Also modify the active mode ->suspend and ->resume callbacks to
prevent them from interfering with the new ->offline and ->online
ones in case the latter are invoked withing the system-wide suspend
and resume code flow and make the passive mode use them too.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
(cherry picked from commit 4adcf2e5829f83cbab581ba376abb7cb6404eeb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 46665cfef5ca,8181a1f1dc79..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -222,8 -219,7 +222,12 @@@ struct global_params 
   * @epp_policy:		Last saved policy used to set EPP/EPB
   * @epp_default:	Power on default HWP energy performance
   *			preference/bias
++<<<<<<< HEAD
 + * @epp_saved:		Saved EPP/EPB during system suspend or CPU offline
 + *			operation
++=======
+  * @epp_cached		Cached HWP energy-performance preference value
++>>>>>>> 4adcf2e5829f (cpufreq: intel_pstate: Add ->offline and ->online callbacks)
   * @hwp_req_cached:	Cached value of the last HWP Request MSR
   * @hwp_cap_cached:	Cached value of the last HWP Capabilities MSR
   * @last_io_update:	Last time when IO wake flag was set
@@@ -260,7 -257,7 +265,11 @@@ struct cpudata 
  	s16 epp_powersave;
  	s16 epp_policy;
  	s16 epp_default;
++<<<<<<< HEAD
 +	s16 epp_saved;
++=======
+ 	s16 epp_cached;
++>>>>>>> 4adcf2e5829f (cpufreq: intel_pstate: Add ->offline and ->online callbacks)
  	u64 hwp_req_cached;
  	u64 hwp_cap_cached;
  	u64 last_io_update;
@@@ -2249,22 -2315,56 +2267,69 @@@ static int intel_pstate_verify_policy(s
  	return 0;
  }
  
- static void intel_cpufreq_stop_cpu(struct cpufreq_policy *policy)
+ static int intel_pstate_cpu_offline(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	intel_pstate_set_min_pstate(all_cpu_data[policy->cpu]);
++=======
+ 	struct cpudata *cpu = all_cpu_data[policy->cpu];
+ 
+ 	pr_debug("CPU %d going offline\n", cpu->cpu);
+ 
+ 	if (cpu->suspended)
+ 		return 0;
+ 
+ 	/*
+ 	 * If the CPU is an SMT thread and it goes offline with the performance
+ 	 * settings different from the minimum, it will prevent its sibling
+ 	 * from getting to lower performance levels, so force the minimum
+ 	 * performance on CPU offline to prevent that from happening.
+ 	 */
+ 	if (hwp_active)
+ 		intel_pstate_hwp_offline(cpu);
+ 	else
+ 		intel_pstate_set_min_pstate(cpu);
+ 
+ 	intel_pstate_exit_perf_limits(policy);
+ 
+ 	return 0;
+ }
+ 
+ static int intel_pstate_cpu_online(struct cpufreq_policy *policy)
+ {
+ 	struct cpudata *cpu = all_cpu_data[policy->cpu];
+ 
+ 	pr_debug("CPU %d going online\n", cpu->cpu);
+ 
+ 	intel_pstate_init_acpi_perf_limits(policy);
+ 
+ 	if (hwp_active) {
+ 		/*
+ 		 * Re-enable HWP and clear the "suspended" flag to let "resume"
+ 		 * know that it need not do that.
+ 		 */
+ 		intel_pstate_hwp_reenable(cpu);
+ 		cpu->suspended = false;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 4adcf2e5829f (cpufreq: intel_pstate: Add ->offline and ->online callbacks)
  }
  
  static void intel_pstate_stop_cpu(struct cpufreq_policy *policy)
  {
- 	pr_debug("CPU %d exiting\n", policy->cpu);
+ 	pr_debug("CPU %d stopping\n", policy->cpu);
  
  	intel_pstate_clear_update_util_hook(policy->cpu);
++<<<<<<< HEAD
 +	if (hwp_active) {
 +		intel_pstate_hwp_save_state(policy);
 +		intel_pstate_hwp_force_min_perf(policy->cpu);
 +	} else {
 +		intel_cpufreq_stop_cpu(policy);
 +	}
++=======
++>>>>>>> 4adcf2e5829f (cpufreq: intel_pstate: Add ->offline and ->online callbacks)
  }
  
  static int intel_pstate_cpu_exit(struct cpufreq_policy *policy)
* Unmerged path drivers/cpufreq/intel_pstate.c
