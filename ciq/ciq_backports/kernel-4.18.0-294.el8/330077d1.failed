net/mlx5: E-switch, Supporting setting devlink port function mac address

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Parav Pandit <parav@mellanox.com>
commit 330077d14de12df5697ef192a88b11cc2166cd47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/330077d1.failed

Enable user to set mac address of the PCI PF and VF port function.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 330077d14de12df5697ef192a88b11cc2166cd47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index a99fe4b02b9b,c709e9a385f6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -113,6 -113,8 +113,11 @@@ static const struct devlink_ops mlx5_de
  	.eswitch_inline_mode_get = mlx5_devlink_eswitch_inline_mode_get,
  	.eswitch_encap_mode_set = mlx5_devlink_eswitch_encap_mode_set,
  	.eswitch_encap_mode_get = mlx5_devlink_eswitch_encap_mode_get,
++<<<<<<< HEAD
++=======
+ 	.port_function_hw_addr_get = mlx5_devlink_port_function_hw_addr_get,
+ 	.port_function_hw_addr_set = mlx5_devlink_port_function_hw_addr_set,
++>>>>>>> 330077d14de1 (net/mlx5: E-switch, Supporting setting devlink port function mac address)
  #endif
  	.flash_update = mlx5_devlink_flash_update,
  	.info_get = mlx5_devlink_info_get,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index e3ab3d0dc5c9,c656c9f081c1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1824,6 -1855,85 +1824,88 @@@ int mlx5_eswitch_set_vport_mac(struct m
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ is_port_function_supported(const struct mlx5_eswitch *esw, u16 vport_num)
+ {
+ 	return vport_num == MLX5_VPORT_PF ||
+ 	       mlx5_eswitch_is_vf_vport(esw, vport_num);
+ }
+ 
+ int mlx5_devlink_port_function_hw_addr_get(struct devlink *devlink,
+ 					   struct devlink_port *port,
+ 					   u8 *hw_addr, int *hw_addr_len,
+ 					   struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5_vport *vport;
+ 	int err = -EOPNOTSUPP;
+ 	u16 vport_num;
+ 
+ 	esw = mlx5_devlink_eswitch_get(devlink);
+ 	if (IS_ERR(esw))
+ 		return PTR_ERR(esw);
+ 
+ 	vport_num = mlx5_esw_devlink_port_index_to_vport_num(port->index);
+ 	if (!is_port_function_supported(esw, vport_num))
+ 		return -EOPNOTSUPP;
+ 
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
+ 		return PTR_ERR(vport);
+ 	}
+ 
+ 	mutex_lock(&esw->state_lock);
+ 	if (vport->enabled) {
+ 		ether_addr_copy(hw_addr, vport->info.mac);
+ 		*hw_addr_len = ETH_ALEN;
+ 		err = 0;
+ 	} else {
+ 		NL_SET_ERR_MSG_MOD(extack, "Eswitch vport is disabled");
+ 	}
+ 	mutex_unlock(&esw->state_lock);
+ 	return err;
+ }
+ 
+ int mlx5_devlink_port_function_hw_addr_set(struct devlink *devlink,
+ 					   struct devlink_port *port,
+ 					   const u8 *hw_addr, int hw_addr_len,
+ 					   struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_eswitch *esw;
+ 	struct mlx5_vport *vport;
+ 	int err = -EOPNOTSUPP;
+ 	u16 vport_num;
+ 
+ 	esw = mlx5_devlink_eswitch_get(devlink);
+ 	if (IS_ERR(esw)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Eswitch doesn't support set hw_addr");
+ 		return PTR_ERR(esw);
+ 	}
+ 
+ 	vport_num = mlx5_esw_devlink_port_index_to_vport_num(port->index);
+ 	if (!is_port_function_supported(esw, vport_num)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Port doesn't support set hw_addr");
+ 		return -EINVAL;
+ 	}
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Invalid port");
+ 		return PTR_ERR(vport);
+ 	}
+ 
+ 	mutex_lock(&esw->state_lock);
+ 	if (vport->enabled)
+ 		err = mlx5_esw_set_vport_mac_locked(esw, vport, hw_addr);
+ 	else
+ 		NL_SET_ERR_MSG_MOD(extack, "Eswitch vport is disabled");
+ 	mutex_unlock(&esw->state_lock);
+ 	return err;
+ }
+ 
++>>>>>>> 330077d14de1 (net/mlx5: E-switch, Supporting setting devlink port function mac address)
  int mlx5_eswitch_set_vport_state(struct mlx5_eswitch *esw,
  				 u16 vport, int link_state)
  {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 884ecf823ead,67e09902bd88..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -435,6 -450,15 +435,18 @@@ int mlx5_devlink_eswitch_encap_mode_set
  					struct netlink_ext_ack *extack);
  int mlx5_devlink_eswitch_encap_mode_get(struct devlink *devlink,
  					enum devlink_eswitch_encap_mode *encap);
++<<<<<<< HEAD
++=======
+ int mlx5_devlink_port_function_hw_addr_get(struct devlink *devlink,
+ 					   struct devlink_port *port,
+ 					   u8 *hw_addr, int *hw_addr_len,
+ 					   struct netlink_ext_ack *extack);
+ int mlx5_devlink_port_function_hw_addr_set(struct devlink *devlink,
+ 					   struct devlink_port *port,
+ 					   const u8 *hw_addr, int hw_addr_len,
+ 					   struct netlink_ext_ack *extack);
+ 
++>>>>>>> 330077d14de1 (net/mlx5: E-switch, Supporting setting devlink port function mac address)
  void *mlx5_eswitch_get_uplink_priv(struct mlx5_eswitch *esw, u8 rep_type);
  
  int mlx5_eswitch_add_vlan_action(struct mlx5_eswitch *esw,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
