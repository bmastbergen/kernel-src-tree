arm64: simplify detection of memory zone boundaries for UMA configs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mike Rapoport <rppt@linux.ibm.com>
commit 584cb13dca27be144a54f9e0b0d71f3db61130a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/584cb13d.failed

The free_area_init() function only requires the definition of maximal PFN
for each of the supported zone rater than calculation of actual zone sizes
and the sizes of the holes between the zones.

After removal of CONFIG_HAVE_MEMBLOCK_NODE_MAP the free_area_init() is
available to all architectures.

Using this function instead of free_area_init_node() simplifies the zone
detection.

	Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Hoan Tran <hoan@os.amperecomputing.com>	[arm64]
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Brian Cain <bcain@codeaurora.org>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Greentime Hu <green.hu@gmail.com>
	Cc: Greg Ungerer <gerg@linux-m68k.org>
	Cc: Guan Xuetao <gxt@pku.edu.cn>
	Cc: Guo Ren <guoren@kernel.org>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Helge Deller <deller@gmx.de>
	Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Ley Foon Tan <ley.foon.tan@intel.com>
	Cc: Mark Salter <msalter@redhat.com>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Nick Hu <nickhu@andestech.com>
	Cc: Paul Walmsley <paul.walmsley@sifive.com>
	Cc: Richard Weinberger <richard@nod.at>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Stafford Horne <shorne@gmail.com>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Vineet Gupta <vgupta@synopsys.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
Link: http://lkml.kernel.org/r/20200412194859.12663-9-rppt@kernel.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 584cb13dca27be144a54f9e0b0d71f3db61130a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/mm/init.c
diff --cc arch/arm64/mm/init.c
index 4311e4a65f34,e631e6425165..000000000000
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@@ -215,19 -180,18 +215,17 @@@ static void __init reserve_elfcorehdr(v
  {
  }
  #endif /* CONFIG_CRASH_DUMP */
 -
  /*
 - * Return the maximum physical address for a zone with a given address size
 - * limit. It currently assumes that for memory starting above 4G, 32-bit
 - * devices will use a DMA offset.
 + * Return the maximum physical address for ZONE_DMA32 (DMA_BIT_MASK(32)). It
 + * currently assumes that for memory starting above 4G, 32-bit devices will
 + * use a DMA offset.
   */
 -static phys_addr_t __init max_zone_phys(unsigned int zone_bits)
 +static phys_addr_t __init max_zone_dma32_phys(void)
  {
 -	phys_addr_t offset = memblock_start_of_DRAM() & GENMASK_ULL(63, zone_bits);
 -	return min(offset + (1ULL << zone_bits), memblock_end_of_DRAM());
 +	phys_addr_t offset = memblock_start_of_DRAM() & GENMASK_ULL(63, 32);
 +	return min(offset + (1ULL << 32), memblock_end_of_DRAM());
  }
  
- #ifdef CONFIG_NUMA
- 
  static void __init zone_sizes_init(unsigned long min, unsigned long max)
  {
  	unsigned long max_zone_pfns[MAX_NR_ZONES]  = {0};
@@@ -237,54 -204,9 +235,57 @@@
  #endif
  	max_zone_pfns[ZONE_NORMAL] = max;
  
 -	free_area_init(max_zone_pfns);
 +	free_area_init_nodes(max_zone_pfns);
 +}
 +
++<<<<<<< HEAD
 +#else
 +
 +static void __init zone_sizes_init(unsigned long min, unsigned long max)
 +{
 +	struct memblock_region *reg;
 +	unsigned long zone_size[MAX_NR_ZONES], zhole_size[MAX_NR_ZONES];
 +	unsigned long max_dma32 = min;
 +
 +	memset(zone_size, 0, sizeof(zone_size));
 +
 +	/* 4GB maximum for 32-bit only capable devices */
 +#ifdef CONFIG_ZONE_DMA32
 +	max_dma32 = PFN_DOWN(arm64_dma32_phys_limit);
 +	zone_size[ZONE_DMA32] = max_dma32 - min;
 +#endif
 +	zone_size[ZONE_NORMAL] = max - max_dma32;
 +
 +	memcpy(zhole_size, zone_size, sizeof(zhole_size));
 +
 +	for_each_memblock(memory, reg) {
 +		unsigned long start = memblock_region_memory_base_pfn(reg);
 +		unsigned long end = memblock_region_memory_end_pfn(reg);
 +
 +		if (start >= max)
 +			continue;
 +
 +#ifdef CONFIG_ZONE_DMA32
 +		if (start < max_dma32) {
 +			unsigned long dma_end = min(end, max_dma32);
 +			zhole_size[ZONE_DMA32] -= dma_end - start;
 +		}
 +#endif
 +		if (end > max_dma32) {
 +			unsigned long normal_end = min(end, max);
 +			unsigned long normal_start = max(start, max_dma32);
 +			zhole_size[ZONE_NORMAL] -= normal_end - normal_start;
 +		}
 +	}
 +
 +	free_area_init_node(0, zone_size, min, zhole_size);
  }
  
 +#endif /* CONFIG_NUMA */
 +
 +#ifdef CONFIG_HAVE_ARCH_PFN_VALID
++=======
++>>>>>>> 584cb13dca27 (arm64: simplify detection of memory zone boundaries for UMA configs)
  int pfn_valid(unsigned long pfn)
  {
  	phys_addr_t addr = pfn << PAGE_SHIFT;
* Unmerged path arch/arm64/mm/init.c
