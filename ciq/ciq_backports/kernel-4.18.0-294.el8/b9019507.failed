RDMA/mlx5: Refactor DV create flow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Maor Gottlieb <maorg@mellanox.com>
commit b9019507aa6e3e6a039573eb6743b38bf846771b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b9019507.failed

Move part of the code that get the destinations into function so the code
will be more readable.  In addition change the variables definition to be
in reversed christmas tree.

Link: https://lore.kernel.org/r/20200504053012.270689-4-leon@kernel.org
	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Reviewed-by: Mark Zhang <markz@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit b9019507aa6e3e6a039573eb6743b38bf846771b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/flow.c
diff --cc drivers/infiniband/hw/mlx5/flow.c
index 69cb7e6e8955,5533b5083c29..000000000000
--- a/drivers/infiniband/hw/mlx5/flow.c
+++ b/drivers/infiniband/hw/mlx5/flow.c
@@@ -133,24 -111,60 +111,66 @@@ static int get_dests(struct uverbs_attr
  	} else if (dest_qp) {
  		struct mlx5_ib_qp *mqp;
  
- 		qp = uverbs_attr_get_obj(attrs,
- 					 MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);
- 		if (IS_ERR(qp))
- 			return PTR_ERR(qp);
+ 		*qp = uverbs_attr_get_obj(attrs,
+ 					  MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);
+ 		if (IS_ERR(*qp))
+ 			return PTR_ERR(*qp);
  
- 		if (qp->qp_type != IB_QPT_RAW_PACKET)
+ 		if ((*qp)->qp_type != IB_QPT_RAW_PACKET)
  			return -EINVAL;
  
++<<<<<<< HEAD
 +		mqp = to_mqp(qp);
 +		if (mqp->flags & MLX5_IB_QP_RSS)
 +			dest_id = mqp->rss_qp.tirn;
++=======
+ 		mqp = to_mqp(*qp);
+ 		if (mqp->is_rss)
+ 			*dest_id = mqp->rss_qp.tirn;
++>>>>>>> b9019507aa6e (RDMA/mlx5: Refactor DV create flow)
  		else
- 			dest_id = mqp->raw_packet_qp.rq.tirn;
- 		dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
- 	} else {
- 		dest_type = MLX5_FLOW_DESTINATION_TYPE_PORT;
+ 			*dest_id = mqp->raw_packet_qp.rq.tirn;
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 	} else if (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_EGRESS) {
+ 		*dest_type = MLX5_FLOW_DESTINATION_TYPE_PORT;
  	}
  
+ 	if (*dest_type == MLX5_FLOW_DESTINATION_TYPE_TIR &&
+ 	    fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_EGRESS)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ #define MLX5_IB_CREATE_FLOW_MAX_FLOW_ACTIONS 2
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_CREATE_FLOW)(
+ 	struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_flow_context flow_context = {.flow_tag =
+ 		MLX5_FS_DEFAULT_FLOW_TAG};
+ 	u32 *offset_attr, offset = 0, counter_id = 0;
+ 	int dest_id, dest_type, inlen, len, ret, i;
+ 	struct mlx5_ib_flow_handler *flow_handler;
+ 	struct mlx5_ib_flow_matcher *fs_matcher;
+ 	struct ib_uobject **arr_flow_actions;
+ 	struct ib_uflow_resources *uflow_res;
+ 	struct mlx5_flow_act flow_act = {};
+ 	struct ib_qp *qp = NULL;
+ 	void *devx_obj, *cmd_in;
+ 	struct ib_uobject *uobj;
+ 	struct mlx5_ib_dev *dev;
+ 
+ 	if (!capable(CAP_NET_RAW))
+ 		return -EPERM;
+ 
+ 	fs_matcher = uverbs_attr_get_obj(attrs,
+ 					 MLX5_IB_ATTR_CREATE_FLOW_MATCHER);
+ 	uobj =  uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_CREATE_FLOW_HANDLE);
+ 	dev = mlx5_udata_to_mdev(&attrs->driver_udata);
+ 
+ 	if (get_dests(attrs, fs_matcher, &dest_id, &dest_type, &qp))
+ 		return -EINVAL;
+ 
  	len = uverbs_attr_get_uobjs_arr(attrs,
  		MLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX, &arr_flow_actions);
  	if (len) {
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
