netlink: consistently use NLA_POLICY_EXACT_LEN()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 8140860c817f3e9f78bcd1e420b9777ddcbaa629
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8140860c.failed

Change places that open-code NLA_POLICY_EXACT_LEN() to
use the macro instead, giving us flexibility in how we
handle the details of the macro.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Acked-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8140860c817f3e9f78bcd1e420b9777ddcbaa629)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireguard/netlink.c
#	net/bridge/br_netlink.c
#	net/bridge/br_vlan.c
#	net/wireless/nl80211.c
diff --cc net/bridge/br_netlink.c
index 9dc6bc61aae4,8a71c60fa357..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -1015,6 -1095,8 +1015,11 @@@ static const struct nla_policy br_polic
  	[IFLA_BR_MCAST_IGMP_VERSION] = { .type = NLA_U8 },
  	[IFLA_BR_MCAST_MLD_VERSION] = { .type = NLA_U8 },
  	[IFLA_BR_VLAN_STATS_PER_PORT] = { .type = NLA_U8 },
++<<<<<<< HEAD
++=======
+ 	[IFLA_BR_MULTI_BOOLOPT] =
+ 		NLA_POLICY_EXACT_LEN(sizeof(struct br_boolopt_multi)),
++>>>>>>> 8140860c817f (netlink: consistently use NLA_POLICY_EXACT_LEN())
  };
  
  static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
diff --cc net/bridge/br_vlan.c
index cd9b045102e3,d2b8737f9fc0..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -1271,3 -1343,716 +1271,717 @@@ int br_vlan_get_info(const struct net_d
  	return 0;
  }
  EXPORT_SYMBOL_GPL(br_vlan_get_info);
++<<<<<<< HEAD
++=======
+ 
+ static int br_vlan_is_bind_vlan_dev(const struct net_device *dev)
+ {
+ 	return is_vlan_dev(dev) &&
+ 		!!(vlan_dev_priv(dev)->flags & VLAN_FLAG_BRIDGE_BINDING);
+ }
+ 
+ static int br_vlan_is_bind_vlan_dev_fn(struct net_device *dev,
+ 				       __always_unused void *data)
+ {
+ 	return br_vlan_is_bind_vlan_dev(dev);
+ }
+ 
+ static bool br_vlan_has_upper_bind_vlan_dev(struct net_device *dev)
+ {
+ 	int found;
+ 
+ 	rcu_read_lock();
+ 	found = netdev_walk_all_upper_dev_rcu(dev, br_vlan_is_bind_vlan_dev_fn,
+ 					      NULL);
+ 	rcu_read_unlock();
+ 
+ 	return !!found;
+ }
+ 
+ struct br_vlan_bind_walk_data {
+ 	u16 vid;
+ 	struct net_device *result;
+ };
+ 
+ static int br_vlan_match_bind_vlan_dev_fn(struct net_device *dev,
+ 					  void *data_in)
+ {
+ 	struct br_vlan_bind_walk_data *data = data_in;
+ 	int found = 0;
+ 
+ 	if (br_vlan_is_bind_vlan_dev(dev) &&
+ 	    vlan_dev_priv(dev)->vlan_id == data->vid) {
+ 		data->result = dev;
+ 		found = 1;
+ 	}
+ 
+ 	return found;
+ }
+ 
+ static struct net_device *
+ br_vlan_get_upper_bind_vlan_dev(struct net_device *dev, u16 vid)
+ {
+ 	struct br_vlan_bind_walk_data data = {
+ 		.vid = vid,
+ 	};
+ 
+ 	rcu_read_lock();
+ 	netdev_walk_all_upper_dev_rcu(dev, br_vlan_match_bind_vlan_dev_fn,
+ 				      &data);
+ 	rcu_read_unlock();
+ 
+ 	return data.result;
+ }
+ 
+ static bool br_vlan_is_dev_up(const struct net_device *dev)
+ {
+ 	return  !!(dev->flags & IFF_UP) && netif_oper_up(dev);
+ }
+ 
+ static void br_vlan_set_vlan_dev_state(const struct net_bridge *br,
+ 				       struct net_device *vlan_dev)
+ {
+ 	u16 vid = vlan_dev_priv(vlan_dev)->vlan_id;
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_port *p;
+ 	bool has_carrier = false;
+ 
+ 	if (!netif_carrier_ok(br->dev)) {
+ 		netif_carrier_off(vlan_dev);
+ 		return;
+ 	}
+ 
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		vg = nbp_vlan_group(p);
+ 		if (br_vlan_find(vg, vid) && br_vlan_is_dev_up(p->dev)) {
+ 			has_carrier = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (has_carrier)
+ 		netif_carrier_on(vlan_dev);
+ 	else
+ 		netif_carrier_off(vlan_dev);
+ }
+ 
+ static void br_vlan_set_all_vlan_dev_state(struct net_bridge_port *p)
+ {
+ 	struct net_bridge_vlan_group *vg = nbp_vlan_group(p);
+ 	struct net_bridge_vlan *vlan;
+ 	struct net_device *vlan_dev;
+ 
+ 	list_for_each_entry(vlan, &vg->vlan_list, vlist) {
+ 		vlan_dev = br_vlan_get_upper_bind_vlan_dev(p->br->dev,
+ 							   vlan->vid);
+ 		if (vlan_dev) {
+ 			if (br_vlan_is_dev_up(p->dev)) {
+ 				if (netif_carrier_ok(p->br->dev))
+ 					netif_carrier_on(vlan_dev);
+ 			} else {
+ 				br_vlan_set_vlan_dev_state(p->br, vlan_dev);
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static void br_vlan_upper_change(struct net_device *dev,
+ 				 struct net_device *upper_dev,
+ 				 bool linking)
+ {
+ 	struct net_bridge *br = netdev_priv(dev);
+ 
+ 	if (!br_vlan_is_bind_vlan_dev(upper_dev))
+ 		return;
+ 
+ 	if (linking) {
+ 		br_vlan_set_vlan_dev_state(br, upper_dev);
+ 		br_opt_toggle(br, BROPT_VLAN_BRIDGE_BINDING, true);
+ 	} else {
+ 		br_opt_toggle(br, BROPT_VLAN_BRIDGE_BINDING,
+ 			      br_vlan_has_upper_bind_vlan_dev(dev));
+ 	}
+ }
+ 
+ struct br_vlan_link_state_walk_data {
+ 	struct net_bridge *br;
+ };
+ 
+ static int br_vlan_link_state_change_fn(struct net_device *vlan_dev,
+ 					void *data_in)
+ {
+ 	struct br_vlan_link_state_walk_data *data = data_in;
+ 
+ 	if (br_vlan_is_bind_vlan_dev(vlan_dev))
+ 		br_vlan_set_vlan_dev_state(data->br, vlan_dev);
+ 
+ 	return 0;
+ }
+ 
+ static void br_vlan_link_state_change(struct net_device *dev,
+ 				      struct net_bridge *br)
+ {
+ 	struct br_vlan_link_state_walk_data data = {
+ 		.br = br
+ 	};
+ 
+ 	rcu_read_lock();
+ 	netdev_walk_all_upper_dev_rcu(dev, br_vlan_link_state_change_fn,
+ 				      &data);
+ 	rcu_read_unlock();
+ }
+ 
+ /* Must be protected by RTNL. */
+ static void nbp_vlan_set_vlan_dev_state(struct net_bridge_port *p, u16 vid)
+ {
+ 	struct net_device *vlan_dev;
+ 
+ 	if (!br_opt_get(p->br, BROPT_VLAN_BRIDGE_BINDING))
+ 		return;
+ 
+ 	vlan_dev = br_vlan_get_upper_bind_vlan_dev(p->br->dev, vid);
+ 	if (vlan_dev)
+ 		br_vlan_set_vlan_dev_state(p->br, vlan_dev);
+ }
+ 
+ /* Must be protected by RTNL. */
+ int br_vlan_bridge_event(struct net_device *dev, unsigned long event, void *ptr)
+ {
+ 	struct netdev_notifier_changeupper_info *info;
+ 	struct net_bridge *br = netdev_priv(dev);
+ 	int vlcmd = 0, ret = 0;
+ 	bool changed = false;
+ 
+ 	switch (event) {
+ 	case NETDEV_REGISTER:
+ 		ret = br_vlan_add(br, br->default_pvid,
+ 				  BRIDGE_VLAN_INFO_PVID |
+ 				  BRIDGE_VLAN_INFO_UNTAGGED |
+ 				  BRIDGE_VLAN_INFO_BRENTRY, &changed, NULL);
+ 		vlcmd = RTM_NEWVLAN;
+ 		break;
+ 	case NETDEV_UNREGISTER:
+ 		changed = !br_vlan_delete(br, br->default_pvid);
+ 		vlcmd = RTM_DELVLAN;
+ 		break;
+ 	case NETDEV_CHANGEUPPER:
+ 		info = ptr;
+ 		br_vlan_upper_change(dev, info->upper_dev, info->linking);
+ 		break;
+ 
+ 	case NETDEV_CHANGE:
+ 	case NETDEV_UP:
+ 		if (!br_opt_get(br, BROPT_VLAN_BRIDGE_BINDING))
+ 			break;
+ 		br_vlan_link_state_change(dev, br);
+ 		break;
+ 	}
+ 	if (changed)
+ 		br_vlan_notify(br, NULL, br->default_pvid, 0, vlcmd);
+ 
+ 	return ret;
+ }
+ 
+ /* Must be protected by RTNL. */
+ void br_vlan_port_event(struct net_bridge_port *p, unsigned long event)
+ {
+ 	if (!br_opt_get(p->br, BROPT_VLAN_BRIDGE_BINDING))
+ 		return;
+ 
+ 	switch (event) {
+ 	case NETDEV_CHANGE:
+ 	case NETDEV_DOWN:
+ 	case NETDEV_UP:
+ 		br_vlan_set_all_vlan_dev_state(p);
+ 		break;
+ 	}
+ }
+ 
+ static bool br_vlan_stats_fill(struct sk_buff *skb,
+ 			       const struct net_bridge_vlan *v)
+ {
+ 	struct br_vlan_stats stats;
+ 	struct nlattr *nest;
+ 
+ 	nest = nla_nest_start(skb, BRIDGE_VLANDB_ENTRY_STATS);
+ 	if (!nest)
+ 		return false;
+ 
+ 	br_vlan_get_stats(v, &stats);
+ 	if (nla_put_u64_64bit(skb, BRIDGE_VLANDB_STATS_RX_BYTES, stats.rx_bytes,
+ 			      BRIDGE_VLANDB_STATS_PAD) ||
+ 	    nla_put_u64_64bit(skb, BRIDGE_VLANDB_STATS_RX_PACKETS,
+ 			      stats.rx_packets, BRIDGE_VLANDB_STATS_PAD) ||
+ 	    nla_put_u64_64bit(skb, BRIDGE_VLANDB_STATS_TX_BYTES, stats.tx_bytes,
+ 			      BRIDGE_VLANDB_STATS_PAD) ||
+ 	    nla_put_u64_64bit(skb, BRIDGE_VLANDB_STATS_TX_PACKETS,
+ 			      stats.tx_packets, BRIDGE_VLANDB_STATS_PAD))
+ 		goto out_err;
+ 
+ 	nla_nest_end(skb, nest);
+ 
+ 	return true;
+ 
+ out_err:
+ 	nla_nest_cancel(skb, nest);
+ 	return false;
+ }
+ 
+ /* v_opts is used to dump the options which must be equal in the whole range */
+ static bool br_vlan_fill_vids(struct sk_buff *skb, u16 vid, u16 vid_range,
+ 			      const struct net_bridge_vlan *v_opts,
+ 			      u16 flags,
+ 			      bool dump_stats)
+ {
+ 	struct bridge_vlan_info info;
+ 	struct nlattr *nest;
+ 
+ 	nest = nla_nest_start(skb, BRIDGE_VLANDB_ENTRY);
+ 	if (!nest)
+ 		return false;
+ 
+ 	memset(&info, 0, sizeof(info));
+ 	info.vid = vid;
+ 	if (flags & BRIDGE_VLAN_INFO_UNTAGGED)
+ 		info.flags |= BRIDGE_VLAN_INFO_UNTAGGED;
+ 	if (flags & BRIDGE_VLAN_INFO_PVID)
+ 		info.flags |= BRIDGE_VLAN_INFO_PVID;
+ 
+ 	if (nla_put(skb, BRIDGE_VLANDB_ENTRY_INFO, sizeof(info), &info))
+ 		goto out_err;
+ 
+ 	if (vid_range && vid < vid_range &&
+ 	    !(flags & BRIDGE_VLAN_INFO_PVID) &&
+ 	    nla_put_u16(skb, BRIDGE_VLANDB_ENTRY_RANGE, vid_range))
+ 		goto out_err;
+ 
+ 	if (v_opts) {
+ 		if (!br_vlan_opts_fill(skb, v_opts))
+ 			goto out_err;
+ 
+ 		if (dump_stats && !br_vlan_stats_fill(skb, v_opts))
+ 			goto out_err;
+ 	}
+ 
+ 	nla_nest_end(skb, nest);
+ 
+ 	return true;
+ 
+ out_err:
+ 	nla_nest_cancel(skb, nest);
+ 	return false;
+ }
+ 
+ static size_t rtnl_vlan_nlmsg_size(void)
+ {
+ 	return NLMSG_ALIGN(sizeof(struct br_vlan_msg))
+ 		+ nla_total_size(0) /* BRIDGE_VLANDB_ENTRY */
+ 		+ nla_total_size(sizeof(u16)) /* BRIDGE_VLANDB_ENTRY_RANGE */
+ 		+ nla_total_size(sizeof(struct bridge_vlan_info)) /* BRIDGE_VLANDB_ENTRY_INFO */
+ 		+ br_vlan_opts_nl_size(); /* bridge vlan options */
+ }
+ 
+ void br_vlan_notify(const struct net_bridge *br,
+ 		    const struct net_bridge_port *p,
+ 		    u16 vid, u16 vid_range,
+ 		    int cmd)
+ {
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_vlan *v = NULL;
+ 	struct br_vlan_msg *bvm;
+ 	struct nlmsghdr *nlh;
+ 	struct sk_buff *skb;
+ 	int err = -ENOBUFS;
+ 	struct net *net;
+ 	u16 flags = 0;
+ 	int ifindex;
+ 
+ 	/* right now notifications are done only with rtnl held */
+ 	ASSERT_RTNL();
+ 
+ 	if (p) {
+ 		ifindex = p->dev->ifindex;
+ 		vg = nbp_vlan_group(p);
+ 		net = dev_net(p->dev);
+ 	} else {
+ 		ifindex = br->dev->ifindex;
+ 		vg = br_vlan_group(br);
+ 		net = dev_net(br->dev);
+ 	}
+ 
+ 	skb = nlmsg_new(rtnl_vlan_nlmsg_size(), GFP_KERNEL);
+ 	if (!skb)
+ 		goto out_err;
+ 
+ 	err = -EMSGSIZE;
+ 	nlh = nlmsg_put(skb, 0, 0, cmd, sizeof(*bvm), 0);
+ 	if (!nlh)
+ 		goto out_err;
+ 	bvm = nlmsg_data(nlh);
+ 	memset(bvm, 0, sizeof(*bvm));
+ 	bvm->family = AF_BRIDGE;
+ 	bvm->ifindex = ifindex;
+ 
+ 	switch (cmd) {
+ 	case RTM_NEWVLAN:
+ 		/* need to find the vlan due to flags/options */
+ 		v = br_vlan_find(vg, vid);
+ 		if (!v || !br_vlan_should_use(v))
+ 			goto out_kfree;
+ 
+ 		flags = v->flags;
+ 		if (br_get_pvid(vg) == v->vid)
+ 			flags |= BRIDGE_VLAN_INFO_PVID;
+ 		break;
+ 	case RTM_DELVLAN:
+ 		break;
+ 	default:
+ 		goto out_kfree;
+ 	}
+ 
+ 	if (!br_vlan_fill_vids(skb, vid, vid_range, v, flags, false))
+ 		goto out_err;
+ 
+ 	nlmsg_end(skb, nlh);
+ 	rtnl_notify(skb, net, 0, RTNLGRP_BRVLAN, NULL, GFP_KERNEL);
+ 	return;
+ 
+ out_err:
+ 	rtnl_set_sk_err(net, RTNLGRP_BRVLAN, err);
+ out_kfree:
+ 	kfree_skb(skb);
+ }
+ 
+ /* check if v_curr can enter a range ending in range_end */
+ bool br_vlan_can_enter_range(const struct net_bridge_vlan *v_curr,
+ 			     const struct net_bridge_vlan *range_end)
+ {
+ 	return v_curr->vid - range_end->vid == 1 &&
+ 	       range_end->flags == v_curr->flags &&
+ 	       br_vlan_opts_eq_range(v_curr, range_end);
+ }
+ 
+ static int br_vlan_dump_dev(const struct net_device *dev,
+ 			    struct sk_buff *skb,
+ 			    struct netlink_callback *cb,
+ 			    u32 dump_flags)
+ {
+ 	struct net_bridge_vlan *v, *range_start = NULL, *range_end = NULL;
+ 	bool dump_stats = !!(dump_flags & BRIDGE_VLANDB_DUMPF_STATS);
+ 	struct net_bridge_vlan_group *vg;
+ 	int idx = 0, s_idx = cb->args[1];
+ 	struct nlmsghdr *nlh = NULL;
+ 	struct net_bridge_port *p;
+ 	struct br_vlan_msg *bvm;
+ 	struct net_bridge *br;
+ 	int err = 0;
+ 	u16 pvid;
+ 
+ 	if (!netif_is_bridge_master(dev) && !netif_is_bridge_port(dev))
+ 		return -EINVAL;
+ 
+ 	if (netif_is_bridge_master(dev)) {
+ 		br = netdev_priv(dev);
+ 		vg = br_vlan_group_rcu(br);
+ 		p = NULL;
+ 	} else {
+ 		p = br_port_get_rcu(dev);
+ 		if (WARN_ON(!p))
+ 			return -EINVAL;
+ 		vg = nbp_vlan_group_rcu(p);
+ 		br = p->br;
+ 	}
+ 
+ 	if (!vg)
+ 		return 0;
+ 
+ 	nlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,
+ 			RTM_NEWVLAN, sizeof(*bvm), NLM_F_MULTI);
+ 	if (!nlh)
+ 		return -EMSGSIZE;
+ 	bvm = nlmsg_data(nlh);
+ 	memset(bvm, 0, sizeof(*bvm));
+ 	bvm->family = PF_BRIDGE;
+ 	bvm->ifindex = dev->ifindex;
+ 	pvid = br_get_pvid(vg);
+ 
+ 	/* idx must stay at range's beginning until it is filled in */
+ 	list_for_each_entry_rcu(v, &vg->vlan_list, vlist) {
+ 		if (!br_vlan_should_use(v))
+ 			continue;
+ 		if (idx < s_idx) {
+ 			idx++;
+ 			continue;
+ 		}
+ 
+ 		if (!range_start) {
+ 			range_start = v;
+ 			range_end = v;
+ 			continue;
+ 		}
+ 
+ 		if (dump_stats || v->vid == pvid ||
+ 		    !br_vlan_can_enter_range(v, range_end)) {
+ 			u16 vlan_flags = br_vlan_flags(range_start, pvid);
+ 
+ 			if (!br_vlan_fill_vids(skb, range_start->vid,
+ 					       range_end->vid, range_start,
+ 					       vlan_flags, dump_stats)) {
+ 				err = -EMSGSIZE;
+ 				break;
+ 			}
+ 			/* advance number of filled vlans */
+ 			idx += range_end->vid - range_start->vid + 1;
+ 
+ 			range_start = v;
+ 		}
+ 		range_end = v;
+ 	}
+ 
+ 	/* err will be 0 and range_start will be set in 3 cases here:
+ 	 * - first vlan (range_start == range_end)
+ 	 * - last vlan (range_start == range_end, not in range)
+ 	 * - last vlan range (range_start != range_end, in range)
+ 	 */
+ 	if (!err && range_start &&
+ 	    !br_vlan_fill_vids(skb, range_start->vid, range_end->vid,
+ 			       range_start, br_vlan_flags(range_start, pvid),
+ 			       dump_stats))
+ 		err = -EMSGSIZE;
+ 
+ 	cb->args[1] = err ? idx : 0;
+ 
+ 	nlmsg_end(skb, nlh);
+ 
+ 	return err;
+ }
+ 
+ static const struct nla_policy br_vlan_db_dump_pol[BRIDGE_VLANDB_DUMP_MAX + 1] = {
+ 	[BRIDGE_VLANDB_DUMP_FLAGS] = { .type = NLA_U32 },
+ };
+ 
+ static int br_vlan_rtm_dump(struct sk_buff *skb, struct netlink_callback *cb)
+ {
+ 	struct nlattr *dtb[BRIDGE_VLANDB_DUMP_MAX + 1];
+ 	int idx = 0, err = 0, s_idx = cb->args[0];
+ 	struct net *net = sock_net(skb->sk);
+ 	struct br_vlan_msg *bvm;
+ 	struct net_device *dev;
+ 	u32 dump_flags = 0;
+ 
+ 	err = nlmsg_parse(cb->nlh, sizeof(*bvm), dtb, BRIDGE_VLANDB_DUMP_MAX,
+ 			  br_vlan_db_dump_pol, cb->extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	bvm = nlmsg_data(cb->nlh);
+ 	if (dtb[BRIDGE_VLANDB_DUMP_FLAGS])
+ 		dump_flags = nla_get_u32(dtb[BRIDGE_VLANDB_DUMP_FLAGS]);
+ 
+ 	rcu_read_lock();
+ 	if (bvm->ifindex) {
+ 		dev = dev_get_by_index_rcu(net, bvm->ifindex);
+ 		if (!dev) {
+ 			err = -ENODEV;
+ 			goto out_err;
+ 		}
+ 		err = br_vlan_dump_dev(dev, skb, cb, dump_flags);
+ 		if (err && err != -EMSGSIZE)
+ 			goto out_err;
+ 	} else {
+ 		for_each_netdev_rcu(net, dev) {
+ 			if (idx < s_idx)
+ 				goto skip;
+ 
+ 			err = br_vlan_dump_dev(dev, skb, cb, dump_flags);
+ 			if (err == -EMSGSIZE)
+ 				break;
+ skip:
+ 			idx++;
+ 		}
+ 	}
+ 	cb->args[0] = idx;
+ 	rcu_read_unlock();
+ 
+ 	return skb->len;
+ 
+ out_err:
+ 	rcu_read_unlock();
+ 
+ 	return err;
+ }
+ 
+ static const struct nla_policy br_vlan_db_policy[BRIDGE_VLANDB_ENTRY_MAX + 1] = {
+ 	[BRIDGE_VLANDB_ENTRY_INFO]	=
+ 		NLA_POLICY_EXACT_LEN(sizeof(struct bridge_vlan_info)),
+ 	[BRIDGE_VLANDB_ENTRY_RANGE]	= { .type = NLA_U16 },
+ 	[BRIDGE_VLANDB_ENTRY_STATE]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_ENTRY_TUNNEL_INFO] = { .type = NLA_NESTED },
+ };
+ 
+ static int br_vlan_rtm_process_one(struct net_device *dev,
+ 				   const struct nlattr *attr,
+ 				   int cmd, struct netlink_ext_ack *extack)
+ {
+ 	struct bridge_vlan_info *vinfo, vrange_end, *vinfo_last = NULL;
+ 	struct nlattr *tb[BRIDGE_VLANDB_ENTRY_MAX + 1];
+ 	bool changed = false, skip_processing = false;
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_port *p = NULL;
+ 	int err = 0, cmdmap = 0;
+ 	struct net_bridge *br;
+ 
+ 	if (netif_is_bridge_master(dev)) {
+ 		br = netdev_priv(dev);
+ 		vg = br_vlan_group(br);
+ 	} else {
+ 		p = br_port_get_rtnl(dev);
+ 		if (WARN_ON(!p))
+ 			return -ENODEV;
+ 		br = p->br;
+ 		vg = nbp_vlan_group(p);
+ 	}
+ 
+ 	if (WARN_ON(!vg))
+ 		return -ENODEV;
+ 
+ 	err = nla_parse_nested(tb, BRIDGE_VLANDB_ENTRY_MAX, attr,
+ 			       br_vlan_db_policy, extack);
+ 	if (err)
+ 		return err;
+ 
+ 	if (!tb[BRIDGE_VLANDB_ENTRY_INFO]) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Missing vlan entry info");
+ 		return -EINVAL;
+ 	}
+ 	memset(&vrange_end, 0, sizeof(vrange_end));
+ 
+ 	vinfo = nla_data(tb[BRIDGE_VLANDB_ENTRY_INFO]);
+ 	if (vinfo->flags & (BRIDGE_VLAN_INFO_RANGE_BEGIN |
+ 			    BRIDGE_VLAN_INFO_RANGE_END)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Old-style vlan ranges are not allowed when using RTM vlan calls");
+ 		return -EINVAL;
+ 	}
+ 	if (!br_vlan_valid_id(vinfo->vid, extack))
+ 		return -EINVAL;
+ 
+ 	if (tb[BRIDGE_VLANDB_ENTRY_RANGE]) {
+ 		vrange_end.vid = nla_get_u16(tb[BRIDGE_VLANDB_ENTRY_RANGE]);
+ 		/* validate user-provided flags without RANGE_BEGIN */
+ 		vrange_end.flags = BRIDGE_VLAN_INFO_RANGE_END | vinfo->flags;
+ 		vinfo->flags |= BRIDGE_VLAN_INFO_RANGE_BEGIN;
+ 
+ 		/* vinfo_last is the range start, vinfo the range end */
+ 		vinfo_last = vinfo;
+ 		vinfo = &vrange_end;
+ 
+ 		if (!br_vlan_valid_id(vinfo->vid, extack) ||
+ 		    !br_vlan_valid_range(vinfo, vinfo_last, extack))
+ 			return -EINVAL;
+ 	}
+ 
+ 	switch (cmd) {
+ 	case RTM_NEWVLAN:
+ 		cmdmap = RTM_SETLINK;
+ 		skip_processing = !!(vinfo->flags & BRIDGE_VLAN_INFO_ONLY_OPTS);
+ 		break;
+ 	case RTM_DELVLAN:
+ 		cmdmap = RTM_DELLINK;
+ 		break;
+ 	}
+ 
+ 	if (!skip_processing) {
+ 		struct bridge_vlan_info *tmp_last = vinfo_last;
+ 
+ 		/* br_process_vlan_info may overwrite vinfo_last */
+ 		err = br_process_vlan_info(br, p, cmdmap, vinfo, &tmp_last,
+ 					   &changed, extack);
+ 
+ 		/* notify first if anything changed */
+ 		if (changed)
+ 			br_ifinfo_notify(cmdmap, br, p);
+ 
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	/* deal with options */
+ 	if (cmd == RTM_NEWVLAN) {
+ 		struct net_bridge_vlan *range_start, *range_end;
+ 
+ 		if (vinfo_last) {
+ 			range_start = br_vlan_find(vg, vinfo_last->vid);
+ 			range_end = br_vlan_find(vg, vinfo->vid);
+ 		} else {
+ 			range_start = br_vlan_find(vg, vinfo->vid);
+ 			range_end = range_start;
+ 		}
+ 
+ 		err = br_vlan_process_options(br, p, range_start, range_end,
+ 					      tb, extack);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int br_vlan_rtm_process(struct sk_buff *skb, struct nlmsghdr *nlh,
+ 			       struct netlink_ext_ack *extack)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct br_vlan_msg *bvm;
+ 	struct net_device *dev;
+ 	struct nlattr *attr;
+ 	int err, vlans = 0;
+ 	int rem;
+ 
+ 	/* this should validate the header and check for remaining bytes */
+ 	err = nlmsg_parse(nlh, sizeof(*bvm), NULL, BRIDGE_VLANDB_MAX, NULL,
+ 			  extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	bvm = nlmsg_data(nlh);
+ 	dev = __dev_get_by_index(net, bvm->ifindex);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	if (!netif_is_bridge_master(dev) && !netif_is_bridge_port(dev)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "The device is not a valid bridge or bridge port");
+ 		return -EINVAL;
+ 	}
+ 
+ 	nlmsg_for_each_attr(attr, nlh, sizeof(*bvm), rem) {
+ 		if (nla_type(attr) != BRIDGE_VLANDB_ENTRY)
+ 			continue;
+ 
+ 		vlans++;
+ 		err = br_vlan_rtm_process_one(dev, attr, nlh->nlmsg_type,
+ 					      extack);
+ 		if (err)
+ 			break;
+ 	}
+ 	if (!vlans) {
+ 		NL_SET_ERR_MSG_MOD(extack, "No vlans found to process");
+ 		err = -EINVAL;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ void br_vlan_rtnl_init(void)
+ {
+ 	rtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_GETVLAN, NULL,
+ 			     br_vlan_rtm_dump, 0);
+ 	rtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_NEWVLAN,
+ 			     br_vlan_rtm_process, NULL, 0);
+ 	rtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_DELVLAN,
+ 			     br_vlan_rtm_process, NULL, 0);
+ }
+ 
+ void br_vlan_rtnl_uninit(void)
+ {
+ 	rtnl_unregister(PF_BRIDGE, RTM_GETVLAN);
+ 	rtnl_unregister(PF_BRIDGE, RTM_NEWVLAN);
+ 	rtnl_unregister(PF_BRIDGE, RTM_DELVLAN);
+ }
++>>>>>>> 8140860c817f (netlink: consistently use NLA_POLICY_EXACT_LEN())
diff --cc net/wireless/nl80211.c
index 5d26e9e988c8,a793b74d7ecf..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -606,6 -645,17 +606,20 @@@ const struct nla_policy nl80211_policy[
  	[NL80211_ATTR_TWT_RESPONDER] = { .type = NLA_FLAG },
  	[NL80211_ATTR_HE_OBSS_PD] = NLA_POLICY_NESTED(he_obss_pd_policy),
  	[NL80211_ATTR_VLAN_ID] = NLA_POLICY_RANGE(NLA_U16, 1, VLAN_N_VID - 2),
++<<<<<<< HEAD
++=======
+ 	[NL80211_ATTR_HE_BSS_COLOR] = NLA_POLICY_NESTED(he_bss_color_policy),
+ 	[NL80211_ATTR_TID_CONFIG] =
+ 		NLA_POLICY_NESTED_ARRAY(nl80211_tid_config_attr_policy),
+ 	[NL80211_ATTR_CONTROL_PORT_NO_PREAUTH] = { .type = NLA_FLAG },
+ 	[NL80211_ATTR_PMK_LIFETIME] = NLA_POLICY_MIN(NLA_U32, 1),
+ 	[NL80211_ATTR_PMK_REAUTH_THRESHOLD] = NLA_POLICY_RANGE(NLA_U8, 1, 100),
+ 	[NL80211_ATTR_RECEIVE_MULTICAST] = { .type = NLA_FLAG },
+ 	[NL80211_ATTR_WIPHY_FREQ_OFFSET] = NLA_POLICY_RANGE(NLA_U32, 0, 999),
+ 	[NL80211_ATTR_SCAN_FREQ_KHZ] = { .type = NLA_NESTED },
+ 	[NL80211_ATTR_HE_6GHZ_CAPABILITY] =
+ 		NLA_POLICY_EXACT_LEN(sizeof(struct ieee80211_he_6ghz_capa)),
++>>>>>>> 8140860c817f (netlink: consistently use NLA_POLICY_EXACT_LEN())
  };
  
  /* policy for the key attributes */
* Unmerged path drivers/net/wireguard/netlink.c
* Unmerged path drivers/net/wireguard/netlink.c
* Unmerged path net/bridge/br_netlink.c
* Unmerged path net/bridge/br_vlan.c
diff --git a/net/mptcp/pm_netlink.c b/net/mptcp/pm_netlink.c
index b78edf237ba0..86291c5aaae5 100644
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@ -384,8 +384,8 @@ mptcp_pm_addr_policy[MPTCP_PM_ADDR_ATTR_MAX + 1] = {
 	[MPTCP_PM_ADDR_ATTR_FAMILY]	= { .type	= NLA_U16,	},
 	[MPTCP_PM_ADDR_ATTR_ID]		= { .type	= NLA_U8,	},
 	[MPTCP_PM_ADDR_ATTR_ADDR4]	= { .type	= NLA_U32,	},
-	[MPTCP_PM_ADDR_ATTR_ADDR6]	= { .type	= NLA_EXACT_LEN,
-					    .len   = sizeof(struct in6_addr), },
+	[MPTCP_PM_ADDR_ATTR_ADDR6]	=
+		NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),
 	[MPTCP_PM_ADDR_ATTR_PORT]	= { .type	= NLA_U16	},
 	[MPTCP_PM_ADDR_ATTR_FLAGS]	= { .type	= NLA_U32	},
 	[MPTCP_PM_ADDR_ATTR_IF_IDX]     = { .type	= NLA_S32	},
diff --git a/net/sched/act_ct.c b/net/sched/act_ct.c
index 36b20aaef486..19ec1d2c0a4e 100644
--- a/net/sched/act_ct.c
+++ b/net/sched/act_ct.c
@@ -1024,7 +1024,7 @@ static int tcf_ct_act(struct sk_buff *skb, const struct tc_action *a,
 
 static const struct nla_policy ct_policy[TCA_CT_MAX + 1] = {
 	[TCA_CT_ACTION] = { .type = NLA_U16 },
-	[TCA_CT_PARMS] = { .type = NLA_EXACT_LEN, .len = sizeof(struct tc_ct) },
+	[TCA_CT_PARMS] = NLA_POLICY_EXACT_LEN(sizeof(struct tc_ct)),
 	[TCA_CT_ZONE] = { .type = NLA_U16 },
 	[TCA_CT_MARK] = { .type = NLA_U32 },
 	[TCA_CT_MARK_MASK] = { .type = NLA_U32 },
@@ -1034,10 +1034,8 @@ static const struct nla_policy ct_policy[TCA_CT_MAX + 1] = {
 				 .len = 128 / BITS_PER_BYTE },
 	[TCA_CT_NAT_IPV4_MIN] = { .type = NLA_U32 },
 	[TCA_CT_NAT_IPV4_MAX] = { .type = NLA_U32 },
-	[TCA_CT_NAT_IPV6_MIN] = { .type = NLA_EXACT_LEN,
-				  .len = sizeof(struct in6_addr) },
-	[TCA_CT_NAT_IPV6_MAX] = { .type = NLA_EXACT_LEN,
-				   .len = sizeof(struct in6_addr) },
+	[TCA_CT_NAT_IPV6_MIN] = NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),
+	[TCA_CT_NAT_IPV6_MAX] = NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),
 	[TCA_CT_NAT_PORT_MIN] = { .type = NLA_U16 },
 	[TCA_CT_NAT_PORT_MAX] = { .type = NLA_U16 },
 };
diff --git a/net/sched/act_ctinfo.c b/net/sched/act_ctinfo.c
index 6084300e51ad..b20c8ce59905 100644
--- a/net/sched/act_ctinfo.c
+++ b/net/sched/act_ctinfo.c
@@ -144,9 +144,8 @@ static int tcf_ctinfo_act(struct sk_buff *skb, const struct tc_action *a,
 }
 
 static const struct nla_policy ctinfo_policy[TCA_CTINFO_MAX + 1] = {
-	[TCA_CTINFO_ACT]		  = { .type = NLA_EXACT_LEN,
-					      .len = sizeof(struct
-							    tc_ctinfo) },
+	[TCA_CTINFO_ACT]		  =
+		NLA_POLICY_EXACT_LEN(sizeof(struct tc_ctinfo)),
 	[TCA_CTINFO_ZONE]		  = { .type = NLA_U16 },
 	[TCA_CTINFO_PARMS_DSCP_MASK]	  = { .type = NLA_U32 },
 	[TCA_CTINFO_PARMS_DSCP_STATEMASK] = { .type = NLA_U32 },
diff --git a/net/sched/act_gate.c b/net/sched/act_gate.c
index c86e7fa7b220..1fe26e2038d2 100644
--- a/net/sched/act_gate.c
+++ b/net/sched/act_gate.c
@@ -159,8 +159,8 @@ static const struct nla_policy entry_policy[TCA_GATE_ENTRY_MAX + 1] = {
 };
 
 static const struct nla_policy gate_policy[TCA_GATE_MAX + 1] = {
-	[TCA_GATE_PARMS]		= { .len = sizeof(struct tc_gate),
-					    .type = NLA_EXACT_LEN },
+	[TCA_GATE_PARMS]		=
+		NLA_POLICY_EXACT_LEN(sizeof(struct tc_gate)),
 	[TCA_GATE_PRIORITY]		= { .type = NLA_S32 },
 	[TCA_GATE_ENTRY_LIST]		= { .type = NLA_NESTED },
 	[TCA_GATE_BASE_TIME]		= { .type = NLA_U64 },
* Unmerged path net/wireless/nl80211.c
