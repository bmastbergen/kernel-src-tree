scsi: qla2xxx: SAN congestion management implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Shyam Sundar <ssundar@marvell.com>
commit 9f2475fe7406b8ef5f97099c4980021344872d9f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9f2475fe.failed

* Firmware Initialization with SCM enabled based on NVRAM setting and
  firmware support (About Firmware).

* Enable PUREX and add support for fabric performance impact
  notification (FPIN) handling.

* Allocate a default PUREX item for each vha to handle memory allocation
  failures in ISR.

Link: https://lore.kernel.org/r/20200630102229.29660-3-njavali@marvell.com
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Reviewed-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Shyam Sundar <ssundar@marvell.com>
	Signed-off-by: Arun Easi <aeasi@marvell.com>
	Signed-off-by: Nilesh Javali <njavali@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9f2475fe7406b8ef5f97099c4980021344872d9f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_isr.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index fbac8553d518,8c92af5e4390..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -3722,7 -3874,12 +3744,16 @@@ struct qla_hw_data 
  		uint32_t        n2n_bigger:1;
  		uint32_t	secure_adapter:1;
  		uint32_t	secure_fw:1;
++<<<<<<< HEAD
 +		uint32_t	max_req_queue_warned:1;
++=======
+ 				/* Supported by Adapter */
+ 		uint32_t	scm_supported_a:1;
+ 				/* Supported by Firmware */
+ 		uint32_t	scm_supported_f:1;
+ 				/* Enabled in Driver */
+ 		uint32_t	scm_enabled:1;
++>>>>>>> 9f2475fe7406 (scsi: qla2xxx: SAN congestion management implementation)
  	} flags;
  
  	uint16_t max_exchg;
@@@ -4392,6 -4564,31 +4436,34 @@@ struct active_regions 
  #define QLA_SET_DATA_RATE_NOLR	1
  #define QLA_SET_DATA_RATE_LR	2 /* Set speed and initiate LR */
  
++<<<<<<< HEAD
++=======
+ #define QLA_DEFAULT_PAYLOAD_SIZE	64
+ /*
+  * This item might be allocated with a size > sizeof(struct purex_item).
+  * The "size" variable gives the size of the payload (which
+  * is variable) starting at "iocb".
+  */
+ struct purex_item {
+ 	struct list_head list;
+ 	struct scsi_qla_host *vha;
+ 	void (*process_item)(struct scsi_qla_host *vha,
+ 			     struct purex_item *pkt);
+ 	atomic_t in_use;
+ 	uint16_t size;
+ 	struct {
+ 		uint8_t iocb[64];
+ 	} iocb;
+ };
+ 
+ #define SCM_FLAG_RDF_REJECT		0x00
+ #define SCM_FLAG_RDF_COMPLETED		0x01
+ 
+ #define QLA_CON_PRIMITIVE_RECEIVED	0x1
+ #define QLA_CONGESTION_ARB_WARNING	0x1
+ #define QLA_CONGESTION_ARB_ALARM	0X2
+ 
++>>>>>>> 9f2475fe7406 (scsi: qla2xxx: SAN congestion management implementation)
  /*
   * Qlogic scsi host structure
   */
@@@ -4589,8 -4794,10 +4661,9 @@@ typedef struct scsi_qla_host 
  	uint8_t n2n_node_name[WWN_SIZE];
  	uint8_t n2n_port_name[WWN_SIZE];
  	uint16_t	n2n_id;
 -	__le16 dport_data[4];
  	struct list_head gpnid_list;
  	struct fab_scan scan;
+ 	uint8_t	scm_fabric_connection_flags;
  
  	unsigned int irq_offset;
  } scsi_qla_host_t;
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b1a0b8670831,b4762d5e2164..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -3743,6 -3747,10 +3743,13 @@@ enable_82xx_npiv
  			    "ISP Firmware failed checksum.\n");
  			goto failed;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		/* Enable PUREX PASSTHRU */
+ 		if (ql2xrdpenable || ha->flags.scm_supported_f)
+ 			qla25xx_set_els_cmds_supported(vha);
++>>>>>>> 9f2475fe7406 (scsi: qla2xxx: SAN congestion management implementation)
  	} else
  		goto failed;
  
@@@ -3954,6 -3962,9 +3961,12 @@@ qla24xx_update_fw_options(scsi_qla_host
  			ha->fw_options[2] &= ~BIT_8;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (ql2xrdpenable || ha->flags.scm_supported_f)
+ 		ha->fw_options[1] |= ADD_FO1_ENABLE_PUREX_IOCB;
+ 
++>>>>>>> 9f2475fe7406 (scsi: qla2xxx: SAN congestion management implementation)
  	/* Enable Async 8130/8131 events -- transceiver insertion/removal */
  	if (IS_BPM_RANGE_CAPABLE(ha))
  		ha->fw_options[3] |= BIT_10;
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index bada8ca1cc29,7be32de2ae06..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -652,6 -790,179 +677,182 @@@ qla27xx_handle_8200_aen(scsi_qla_host_
  	}
  }
  
++<<<<<<< HEAD
++=======
+ struct purex_item *
+ qla24xx_alloc_purex_item(scsi_qla_host_t *vha, uint16_t size)
+ {
+ 	struct purex_item *item = NULL;
+ 	uint8_t item_hdr_size = sizeof(*item);
+ 
+ 	if (size > QLA_DEFAULT_PAYLOAD_SIZE) {
+ 		item = kzalloc(item_hdr_size +
+ 		    (size - QLA_DEFAULT_PAYLOAD_SIZE), GFP_ATOMIC);
+ 	} else {
+ 		if (atomic_inc_return(&vha->default_item.in_use) == 1) {
+ 			item = &vha->default_item;
+ 			goto initialize_purex_header;
+ 		} else {
+ 			item = kzalloc(item_hdr_size, GFP_ATOMIC);
+ 		}
+ 	}
+ 	if (!item) {
+ 		ql_log(ql_log_warn, vha, 0x5092,
+ 		       ">> Failed allocate purex list item.\n");
+ 
+ 		return NULL;
+ 	}
+ 
+ initialize_purex_header:
+ 	item->vha = vha;
+ 	item->size = size;
+ 	return item;
+ }
+ 
+ static void
+ qla24xx_queue_purex_item(scsi_qla_host_t *vha, struct purex_item *pkt,
+ 			 void (*process_item)(struct scsi_qla_host *vha,
+ 					      struct purex_item *pkt))
+ {
+ 	struct purex_list *list = &vha->purex_list;
+ 	ulong flags;
+ 
+ 	pkt->process_item = process_item;
+ 
+ 	spin_lock_irqsave(&list->lock, flags);
+ 	list_add_tail(&pkt->list, &list->head);
+ 	spin_unlock_irqrestore(&list->lock, flags);
+ 
+ 	set_bit(PROCESS_PUREX_IOCB, &vha->dpc_flags);
+ }
+ 
+ /**
+  * qla24xx_copy_std_pkt() - Copy over purex ELS which is
+  * contained in a single IOCB.
+  * purex packet.
+  * @vha: SCSI driver HA context
+  * @pkt: ELS packet
+  */
+ static struct purex_item
+ *qla24xx_copy_std_pkt(struct scsi_qla_host *vha, void *pkt)
+ {
+ 	struct purex_item *item;
+ 
+ 	item = qla24xx_alloc_purex_item(vha,
+ 					QLA_DEFAULT_PAYLOAD_SIZE);
+ 	if (!item)
+ 		return item;
+ 
+ 	memcpy(&item->iocb, pkt, sizeof(item->iocb));
+ 	return item;
+ }
+ 
++>>>>>>> 9f2475fe7406 (scsi: qla2xxx: SAN congestion management implementation)
+ /**
+  * qla27xx_copy_fpin_pkt() - Copy over fpin packets that can
+  * span over multiple IOCBs.
+  * @vha: SCSI driver HA context
+  * @pkt: ELS packet
+  * @rsp: Response queue
+  */
+ static struct purex_item *
+ qla27xx_copy_fpin_pkt(struct scsi_qla_host *vha, void **pkt,
+ 		      struct rsp_que **rsp)
+ {
+ 	struct purex_entry_24xx *purex = *pkt;
+ 	struct rsp_que *rsp_q = *rsp;
+ 	sts_cont_entry_t *new_pkt;
+ 	uint16_t no_bytes = 0, total_bytes = 0, pending_bytes = 0;
+ 	uint16_t buffer_copy_offset = 0;
+ 	uint16_t entry_count, entry_count_remaining;
+ 	struct purex_item *item;
+ 	void *fpin_pkt = NULL;
+ 
+ 	total_bytes = le16_to_cpu(purex->frame_size & 0x0FFF)
+ 	    - PURX_ELS_HEADER_SIZE;
+ 	pending_bytes = total_bytes;
+ 	entry_count = entry_count_remaining = purex->entry_count;
+ 	no_bytes = (pending_bytes > sizeof(purex->els_frame_payload))  ?
+ 		   sizeof(purex->els_frame_payload) : pending_bytes;
+ 	ql_log(ql_log_info, vha, 0x509a,
+ 	       "FPIN ELS, frame_size 0x%x, entry count %d\n",
+ 	       total_bytes, entry_count);
+ 
+ 	item = qla24xx_alloc_purex_item(vha, total_bytes);
+ 	if (!item)
+ 		return item;
+ 
+ 	fpin_pkt = &item->iocb;
+ 
+ 	memcpy(fpin_pkt, &purex->els_frame_payload[0], no_bytes);
+ 	buffer_copy_offset += no_bytes;
+ 	pending_bytes -= no_bytes;
+ 	--entry_count_remaining;
+ 
+ 	((response_t *)purex)->signature = RESPONSE_PROCESSED;
+ 	wmb();
+ 
+ 	do {
+ 		while ((total_bytes > 0) && (entry_count_remaining > 0)) {
+ 			if (rsp_q->ring_ptr->signature == RESPONSE_PROCESSED) {
+ 				ql_dbg(ql_dbg_async, vha, 0x5084,
+ 				       "Ran out of IOCBs, partial data 0x%x\n",
+ 				       buffer_copy_offset);
+ 				cpu_relax();
+ 				continue;
+ 			}
+ 
+ 			new_pkt = (sts_cont_entry_t *)rsp_q->ring_ptr;
+ 			*pkt = new_pkt;
+ 
+ 			if (new_pkt->entry_type != STATUS_CONT_TYPE) {
+ 				ql_log(ql_log_warn, vha, 0x507a,
+ 				       "Unexpected IOCB type, partial data 0x%x\n",
+ 				       buffer_copy_offset);
+ 				break;
+ 			}
+ 
+ 			rsp_q->ring_index++;
+ 			if (rsp_q->ring_index == rsp_q->length) {
+ 				rsp_q->ring_index = 0;
+ 				rsp_q->ring_ptr = rsp_q->ring;
+ 			} else {
+ 				rsp_q->ring_ptr++;
+ 			}
+ 			no_bytes = (pending_bytes > sizeof(new_pkt->data)) ?
+ 			    sizeof(new_pkt->data) : pending_bytes;
+ 			if ((buffer_copy_offset + no_bytes) <= total_bytes) {
+ 				memcpy(((uint8_t *)fpin_pkt +
+ 				    buffer_copy_offset), new_pkt->data,
+ 				    no_bytes);
+ 				buffer_copy_offset += no_bytes;
+ 				pending_bytes -= no_bytes;
+ 				--entry_count_remaining;
+ 			} else {
+ 				ql_log(ql_log_warn, vha, 0x5044,
+ 				       "Attempt to copy more that we got, optimizing..%x\n",
+ 				       buffer_copy_offset);
+ 				memcpy(((uint8_t *)fpin_pkt +
+ 				    buffer_copy_offset), new_pkt->data,
+ 				    total_bytes - buffer_copy_offset);
+ 			}
+ 
+ 			((response_t *)new_pkt)->signature = RESPONSE_PROCESSED;
+ 			wmb();
+ 		}
+ 
+ 		if (pending_bytes != 0 || entry_count_remaining != 0) {
+ 			ql_log(ql_log_fatal, vha, 0x508b,
+ 			       "Dropping partial FPIN, underrun bytes = 0x%x, entry cnts 0x%x\n",
+ 			       total_bytes, entry_count_remaining);
+ 			qla24xx_free_purex_item(item);
+ 			return NULL;
+ 		}
+ 	} while (entry_count_remaining > 0);
+ 	host_to_fcp_swap((uint8_t *)&item->iocb, total_bytes);
+ 	return item;
+ }
+ 
  /**
   * qla2x00_async_event() - Process aynchronous events.
   * @vha: SCSI driver HA context
@@@ -3094,6 -3416,8 +3308,11 @@@ void qla24xx_process_response_queue(str
  {
  	struct sts_entry_24xx *pkt;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++=======
+ 	struct purex_entry_24xx *purex_entry;
+ 	struct purex_item *pure_item;
++>>>>>>> 9f2475fe7406 (scsi: qla2xxx: SAN congestion management implementation)
  
  	if (!ha->flags.fw_started)
  		return;
@@@ -3144,6 -3468,14 +3363,17 @@@ process_err
  			qla24xx_els_ct_entry(vha, rsp->req, pkt, ELS_IOCB_TYPE);
  			break;
  		case ABTS_RECV_24XX:
++<<<<<<< HEAD
++=======
+ 			if (qla_ini_mode_enabled(vha)) {
+ 				pure_item = qla24xx_copy_std_pkt(vha, pkt);
+ 				if (!pure_item)
+ 					break;
+ 				qla24xx_queue_purex_item(vha, pure_item,
+ 							 qla24xx_process_abts);
+ 				break;
+ 			}
++>>>>>>> 9f2475fe7406 (scsi: qla2xxx: SAN congestion management implementation)
  			if (IS_QLA83XX(ha) || IS_QLA27XX(ha) ||
  			    IS_QLA28XX(ha)) {
  				/* ensure that the ATIO queue is empty */
@@@ -3188,6 -3520,36 +3418,39 @@@
  			qla_ctrlvp_completed(vha, rsp->req,
  			    (struct vp_ctrl_entry_24xx *)pkt);
  			break;
++<<<<<<< HEAD
++=======
+ 		case PUREX_IOCB_TYPE:
+ 			purex_entry = (void *)pkt;
+ 			switch (purex_entry->els_frame_payload[3]) {
+ 			case ELS_RDP:
+ 				pure_item = qla24xx_copy_std_pkt(vha, pkt);
+ 				if (!pure_item)
+ 					break;
+ 				qla24xx_queue_purex_item(vha, pure_item,
+ 						 qla24xx_process_purex_rdp);
+ 				break;
+ 			case ELS_FPIN:
+ 				if (!vha->hw->flags.scm_enabled) {
+ 					ql_log(ql_log_warn, vha, 0x5094,
+ 					       "SCM not active for this port\n");
+ 					break;
+ 				}
+ 				pure_item = qla27xx_copy_fpin_pkt(vha,
+ 							  (void **)&pkt, &rsp);
+ 				if (!pure_item)
+ 					break;
+ 				qla24xx_queue_purex_item(vha, pure_item,
+ 						 qla27xx_process_purex_fpin);
+ 				break;
+ 
+ 			default:
+ 				ql_log(ql_log_warn, vha, 0x509c,
+ 				       "Discarding ELS Request opcode 0x%x\n",
+ 				       purex_entry->els_frame_payload[3]);
+ 			}
+ 			break;
++>>>>>>> 9f2475fe7406 (scsi: qla2xxx: SAN congestion management implementation)
  		default:
  			/* Type Not Supported. */
  			ql_dbg(ql_dbg_async, vha, 0x5042,
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index fbd8cb5647b6..2ab828516bf4 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -11,10 +11,8 @@
  * ----------------------------------------------------------------------
  * |             Level            |   Last Value Used  |     Holes	|
  * ----------------------------------------------------------------------
- * | Module Init and Probe        |       0x0193       | 0x0146         |
- * |                              |                    | 0x015b-0x0160	|
- * |                              |                    | 0x016e		|
- * | Mailbox commands             |       0x1206       | 0x11a2-0x11ff	|
+ * | Module Init and Probe        |       0x0199       |                |
+ * | Mailbox commands             |       0x1206       | 0x11a5-0x11ff	|
  * | Device Discovery             |       0x2134       | 0x210e-0x2116  |
  * |				  | 		       | 0x211a         |
  * |                              |                    | 0x211c-0x2128  |
@@ -26,11 +24,7 @@
  * |                              |                    | 0x3036,0x3038  |
  * |                              |                    | 0x303a		|
  * | DPC Thread                   |       0x4023       | 0x4002,0x4013  |
- * | Async Events                 |       0x5090       | 0x502b-0x502f  |
- * |				  | 		       | 0x5047         |
- * |                              |                    | 0x5084,0x5075	|
- * |                              |                    | 0x503d,0x5044  |
- * |                              |                    | 0x505f		|
+ * | Async Events                 |       0x509c       |                |
  * | Timer Routines               |       0x6012       |                |
  * | User Space Interactions      |       0x70e3       | 0x7018,0x702e  |
  * |				  |		       | 0x7020,0x7024  |
@@ -2677,7 +2671,6 @@ ql_dump_regs(uint level, scsi_qla_host_t *vha, uint id)
 		    "mbox[%d] %#04x\n", i, rd_reg_word(mbx_reg));
 }
 
-
 void
 ql_dump_buffer(uint level, scsi_qla_host_t *vha, uint id, const void *buf,
 	       uint size)
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index 34bbd2edc2fc..7b7871382250 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -723,6 +723,8 @@ struct ct_entry_24xx {
 	struct dsd64 dsd[2];
 };
 
+#define PURX_ELS_HEADER_SIZE	0x18
+
 /*
  * ISP queue - ELS Pass-Through entry structure definition.
  */
@@ -1882,7 +1884,9 @@ struct nvram_81xx {
 	 * BIT 0    = Extended BB credits for LR
 	 * BIT 1    = Virtual Fabric Enable
 	 * BIT 2-5  = Distance Support if BIT 0 is on
-	 * BIT 6-15 = Unused
+	 * BIT 6    = Prefer FCP
+	 * BIT 7    = SCM Disabled if BIT is set (1)
+	 * BIT 8-15 = Unused
 	 */
 	uint16_t enhanced_features;
 
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index a6e3ebf4ee44..9535797efb54 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -129,6 +129,7 @@ int qla_post_iidma_work(struct scsi_qla_host *vha, fc_port_t *fcport);
 void qla_do_iidma_work(struct scsi_qla_host *vha, fc_port_t *fcport);
 int qla2x00_reserve_mgmt_server_loop_id(scsi_qla_host_t *);
 void qla_rscn_replay(fc_port_t *fcport);
+void qla24xx_free_purex_item(struct purex_item *item);
 extern bool qla24xx_risc_firmware_invalid(uint32_t *);
 
 /*
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 946fa90e85de..a2950e3a5906 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -1117,6 +1117,16 @@ qla2x00_get_fw_version(scsi_qla_host_t *vha)
 			    (ha->flags.secure_fw) ? "Supported" :
 			    "Not Supported");
 		}
+
+		if (ha->flags.scm_supported_a &&
+		    (ha->fw_attributes_ext[0] & FW_ATTR_EXT0_SCM_SUPPORTED)) {
+			ha->flags.scm_supported_f = 1;
+			memset(ha->sf_init_cb, 0, sizeof(struct init_sf_cb));
+			ha->sf_init_cb->flags |= BIT_13;
+		}
+		ql_log(ql_log_info, vha, 0x11a3, "SCM in FW: %s\n",
+		       (ha->flags.scm_supported_f) ? "Supported" :
+		       "Not Supported");
 	}
 
 failed:
@@ -1626,8 +1636,11 @@ qla2x00_get_adapter_id(scsi_qla_host_t *vha, uint16_t *id, uint8_t *al_pa,
 		mcp->in_mb |= MBX_13|MBX_12|MBX_11|MBX_10;
 	if (IS_FWI2_CAPABLE(vha->hw))
 		mcp->in_mb |= MBX_19|MBX_18|MBX_17|MBX_16;
-	if (IS_QLA27XX(vha->hw) || IS_QLA28XX(vha->hw))
+	if (IS_QLA27XX(vha->hw) || IS_QLA28XX(vha->hw)) {
 		mcp->in_mb |= MBX_15;
+		mcp->out_mb |= MBX_7|MBX_21|MBX_22|MBX_23;
+	}
+
 	mcp->tov = MBX_TOV_SECONDS;
 	mcp->flags = 0;
 	rval = qla2x00_mailbox_command(vha, mcp);
@@ -1680,8 +1693,22 @@ qla2x00_get_adapter_id(scsi_qla_host_t *vha, uint16_t *id, uint8_t *al_pa,
 			}
 		}
 
-		if (IS_QLA27XX(vha->hw) || IS_QLA28XX(vha->hw))
+		if (IS_QLA27XX(vha->hw) || IS_QLA28XX(vha->hw)) {
 			vha->bbcr = mcp->mb[15];
+			if (mcp->mb[7] & SCM_EDC_ACC_RECEIVED) {
+				ql_log(ql_log_info, vha, 0x11a4,
+				       "SCM: EDC ELS completed, flags 0x%x\n",
+				       mcp->mb[21]);
+			}
+			if (mcp->mb[7] & SCM_RDF_ACC_RECEIVED) {
+				vha->hw->flags.scm_enabled = 1;
+				vha->scm_fabric_connection_flags |=
+				    SCM_FLAG_RDF_COMPLETED;
+				ql_log(ql_log_info, vha, 0x11a5,
+				       "SCM: RDF ELS completed, flags 0x%x\n",
+				       mcp->mb[23]);
+			}
+		}
 	}
 
 	return rval;
@@ -1794,6 +1821,17 @@ qla2x00_init_firmware(scsi_qla_host_t *vha, uint16_t size)
 		mcp->mb[14] = sizeof(*ha->ex_init_cb);
 		mcp->out_mb |= MBX_14|MBX_13|MBX_12|MBX_11|MBX_10;
 	}
+
+	if (ha->flags.scm_supported_f) {
+		mcp->mb[1] |= BIT_1;
+		mcp->mb[16] = MSW(ha->sf_init_cb_dma);
+		mcp->mb[17] = LSW(ha->sf_init_cb_dma);
+		mcp->mb[18] = MSW(MSD(ha->sf_init_cb_dma));
+		mcp->mb[19] = LSW(MSD(ha->sf_init_cb_dma));
+		mcp->mb[15] = sizeof(*ha->sf_init_cb);
+		mcp->out_mb |= MBX_19|MBX_18|MBX_17|MBX_16|MBX_15;
+	}
+
 	/* 1 and 2 should normally be captured. */
 	mcp->in_mb = MBX_2|MBX_1|MBX_0;
 	if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 344db146fcba..26ba4554da48 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -4071,6 +4071,16 @@ qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,
 		    "ex_init_cb=%p.\n", ha->ex_init_cb);
 	}
 
+	/* Get consistent memory allocated for Special Features-CB. */
+	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
+		ha->sf_init_cb = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,
+						&ha->sf_init_cb_dma);
+		if (!ha->sf_init_cb)
+			goto fail_sf_init_cb;
+		ql_dbg_pci(ql_dbg_init, ha->pdev, 0x0199,
+			   "sf_init_cb=%p.\n", ha->sf_init_cb);
+	}
+
 	INIT_LIST_HEAD(&ha->gbl_dsd_list);
 
 	/* Get consistent memory allocated for Async Port-Database. */
@@ -4124,6 +4134,8 @@ qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,
 fail_loop_id_map:
 	dma_pool_free(ha->s_dma_pool, ha->async_pd, ha->async_pd_dma);
 fail_async_pd:
+	dma_pool_free(ha->s_dma_pool, ha->sf_init_cb, ha->sf_init_cb_dma);
+fail_sf_init_cb:
 	dma_pool_free(ha->s_dma_pool, ha->ex_init_cb, ha->ex_init_cb_dma);
 fail_ex_init_cb:
 	kfree(ha->npiv_info);
@@ -4546,6 +4558,10 @@ qla2x00_mem_free(struct qla_hw_data *ha)
 	ha->ms_iocb = NULL;
 	ha->ms_iocb_dma = 0;
 
+	if (ha->sf_init_cb)
+		dma_pool_free(ha->s_dma_pool,
+			      ha->sf_init_cb, ha->sf_init_cb_dma);
+
 	if (ha->ex_init_cb)
 		dma_pool_free(ha->s_dma_pool,
 			ha->ex_init_cb, ha->ex_init_cb_dma);
@@ -4633,6 +4649,8 @@ qla2x00_mem_free(struct qla_hw_data *ha)
 	kfree(ha->swl);
 	ha->swl = NULL;
 	kfree(ha->loop_id_map);
+	ha->sf_init_cb = NULL;
+	ha->sf_init_cb_dma = 0;
 	ha->loop_id_map = NULL;
 }
 
