dma-direct: check return value when encrypting or decrypting memory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Rientjes <rientjes@google.com>
commit 56fccf21d1961a06e2a0c96ce446ebf036651062
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/56fccf21.failed

__change_page_attr() can fail which will cause set_memory_encrypted() and
set_memory_decrypted() to return non-zero.

If the device requires unencrypted DMA memory and decryption fails, simply
free the memory and fail.

If attempting to re-encrypt in the failure path and that encryption fails,
there is no alternative other than to leak the memory.

Fixes: c10f07aa27da ("dma/direct: Handle force decryption for DMA coherent buffers in common code")
	Signed-off-by: David Rientjes <rientjes@google.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 56fccf21d1961a06e2a0c96ce446ebf036651062)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index 50772983c03a,2f69bfdbe315..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -124,11 -158,12 +124,12 @@@ void *dma_direct_alloc_pages(struct dev
  {
  	struct page *page;
  	void *ret;
+ 	int err;
  
 -	size = PAGE_ALIGN(size);
 -
 -	if (dma_should_alloc_from_pool(dev, gfp, attrs)) {
 -		ret = dma_alloc_from_pool(dev, size, &page, gfp);
 +	if (IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
 +	    dma_alloc_need_uncached(dev, attrs) &&
 +	    !gfpflags_allow_blocking(gfp)) {
 +		ret = dma_alloc_from_pool(PAGE_ALIGN(size), &page, gfp);
  		if (!ret)
  			return NULL;
  		goto done;
@@@ -192,6 -233,15 +197,18 @@@ done
  	else
  		*dma_handle = phys_to_dma(dev, page_to_phys(page));
  	return ret;
++<<<<<<< HEAD
++=======
+ 
+ out_encrypt_pages:
+ 	if (force_dma_unencrypted(dev)) {
+ 		err = set_memory_encrypted((unsigned long)page_address(page),
+ 					   1 << get_order(size));
+ 		/* If memory cannot be re-encrypted, it must be leaked */
+ 		if (err)
+ 			return NULL;
+ 	}
++>>>>>>> 56fccf21d196 (dma-direct: check return value when encrypting or decrypting memory)
  out_free_pages:
  	dma_free_contiguous(dev, page, size);
  	return NULL;
* Unmerged path kernel/dma/direct.c
