kasan, arm64: fix up fault handling logic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 356607f21e603523d4b0a4f918722845214fc6a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/356607f2.failed

Right now arm64 fault handling code removes pointer tags from addresses
covered by TTBR0 in faults taken from both EL0 and EL1, but doesn't do
that for pointers covered by TTBR1.

This patch adds two helper functions is_ttbr0_addr() and is_ttbr1_addr(),
where the latter one accounts for the fact that TTBR1 pointers might be
tagged when tag-based KASAN is in use, and uses these helper functions to
perform pointer checks in arch/arm64/mm/fault.c.

Link: http://lkml.kernel.org/r/3f349b0e9e48b5df3298a6b4ae0634332274494a.1544099024.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Suggested-by: Mark Rutland <mark.rutland@arm.com>
	Acked-by: Will Deacon <will.deacon@arm.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 356607f21e603523d4b0a4f918722845214fc6a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/mm/fault.c
diff --cc arch/arm64/mm/fault.c
index 8d8540c36fbc,efb7b2cbead5..000000000000
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@@ -844,12 -838,15 +857,16 @@@ asmlinkage void __exception do_debug_ex
  	if (interrupts_enabled(regs))
  		trace_hardirqs_off();
  
++<<<<<<< HEAD
 +	if (user_mode(regs) && (pc > TASK_SIZE))
++=======
+ 	if (user_mode(regs) && !is_ttbr0_addr(instruction_pointer(regs)))
++>>>>>>> 356607f21e60 (kasan, arm64: fix up fault handling logic)
  		arm64_apply_bp_hardening();
  
 -	if (!inf->fn(addr, esr, regs)) {
 -		rv = 1;
 -	} else {
 +	if (inf->fn(addr_if_watchpoint, esr, regs)) {
  		arm64_notify_die(inf->name, regs,
 -				 inf->sig, inf->code, (void __user *)addr, esr);
 -		rv = 0;
 +				 inf->sig, inf->code, (void __user *)pc, esr);
  	}
  
  	if (interrupts_enabled(regs))
* Unmerged path arch/arm64/mm/fault.c
