powerpc: Introduce functions for instruction equality

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jordan Niethe <jniethe5@gmail.com>
commit 217862d9b98bf08958d57fd7b31b9de0f1a9477d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/217862d9.failed

In preparation for an instruction data type that can not be directly
used with the '==' operator use functions for checking equality.

	Signed-off-by: Jordan Niethe <jniethe5@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
	Reviewed-by: Balamuruhan S <bala24@linux.ibm.com>
Link: https://lore.kernel.org/r/20200506034050.24806-11-jniethe5@gmail.com
(cherry picked from commit 217862d9b98bf08958d57fd7b31b9de0f1a9477d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/inst.h
#	arch/powerpc/kernel/trace/ftrace.c
#	arch/powerpc/lib/code-patching.c
#	arch/powerpc/xmon/xmon.c
diff --cc arch/powerpc/kernel/trace/ftrace.c
index 4bf051d3e21e,cbb19af4a72a..000000000000
--- a/arch/powerpc/kernel/trace/ftrace.c
+++ b/arch/powerpc/kernel/trace/ftrace.c
@@@ -71,9 -72,9 +71,9 @@@ ftrace_modify_code(unsigned long ip, un
  		return -EFAULT;
  
  	/* Make sure it is what we expect it to be */
- 	if (replaced != old) {
+ 	if (!ppc_inst_equal(replaced, old)) {
  		pr_err("%p: replaced (%#x) != old (%#x)",
 -		(void *)ip, ppc_inst_val(replaced), ppc_inst_val(old));
 +		(void *)ip, replaced, old);
  		return -EINVAL;
  	}
  
@@@ -168,8 -170,10 +168,15 @@@ __ftrace_make_nop(struct module *mod
  	}
  
  	/* We expect either a mflr r0, or a std r0, LRSAVE(r1) */
++<<<<<<< HEAD
 +	if (op != PPC_INST_MFLR && op != PPC_INST_STD_LR) {
 +		pr_err("Unexpected instruction %08x around bl _mcount\n", op);
++=======
+ 	if (!ppc_inst_equal(op, ppc_inst(PPC_INST_MFLR)) &&
+ 	    !ppc_inst_equal(op, ppc_inst(PPC_INST_STD_LR))) {
+ 		pr_err("Unexpected instruction %08x around bl _mcount\n",
+ 		       ppc_inst_val(op));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  		return -EINVAL;
  	}
  #else
@@@ -198,8 -202,8 +205,13 @@@
  		return -EFAULT;
  	}
  
++<<<<<<< HEAD
 +	if (op != PPC_INST_LD_TOC) {
 +		pr_err("Expected %08x found %08x\n", PPC_INST_LD_TOC, op);
++=======
+ 	if (!ppc_inst_equal(op,  ppc_inst(PPC_INST_LD_TOC))) {
+ 		pr_err("Expected %08x found %08x\n", PPC_INST_LD_TOC, ppc_inst_val(op));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  		return -EINVAL;
  	}
  #endif /* CONFIG_MPROFILE_KERNEL */
@@@ -492,7 -499,8 +504,12 @@@ expected_nop_sequence(void *ip, unsigne
  	 * The load offset is different depending on the ABI. For simplicity
  	 * just mask it out when doing the compare.
  	 */
++<<<<<<< HEAD
 +	if ((op0 != 0x48000008) || ((op1 & 0xffff0000) != 0xe8410000))
++=======
+ 	if (!ppc_inst_equal(op0, ppc_inst(0x48000008)) ||
+ 	    (ppc_inst_val(op1) & 0xffff0000) != 0xe8410000)
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  		return 0;
  	return 1;
  }
@@@ -501,7 -509,7 +518,11 @@@ static in
  expected_nop_sequence(void *ip, unsigned int op0, unsigned int op1)
  {
  	/* look for patched "NOP" on ppc64 with -mprofile-kernel */
++<<<<<<< HEAD
 +	if (op0 != PPC_INST_NOP)
++=======
+ 	if (!ppc_inst_equal(op0, ppc_inst(PPC_INST_NOP)))
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  		return 0;
  	return 1;
  }
@@@ -582,8 -592,8 +603,13 @@@ __ftrace_make_call(struct dyn_ftrace *r
  		return -EFAULT;
  
  	/* It should be pointing to a nop */
++<<<<<<< HEAD
 +	if (op != PPC_INST_NOP) {
 +		pr_err("Expected NOP but have %x\n", op);
++=======
+ 	if (!ppc_inst_equal(op,  ppc_inst(PPC_INST_NOP))) {
+ 		pr_err("Expected NOP but have %x\n", ppc_inst_val(op));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  		return -EINVAL;
  	}
  
@@@ -639,8 -649,8 +665,13 @@@ static int __ftrace_make_call_kernel(st
  		return -EFAULT;
  	}
  
++<<<<<<< HEAD
 +	if (op != PPC_INST_NOP) {
 +		pr_err("Unexpected call sequence at %p: %x\n", ip, op);
++=======
+ 	if (!ppc_inst_equal(op, ppc_inst(PPC_INST_NOP))) {
+ 		pr_err("Unexpected call sequence at %p: %x\n", ip, ppc_inst_val(op));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  		return -EINVAL;
  	}
  
diff --cc arch/powerpc/lib/code-patching.c
index d6541402be75,d298bb16936e..000000000000
--- a/arch/powerpc/lib/code-patching.c
+++ b/arch/powerpc/lib/code-patching.c
@@@ -460,21 -465,21 +460,25 @@@ static void __init test_branch_iform(vo
  	check(instr_is_branch_to_addr(&instr, addr - 0x2000000));
  
  	/* Out of range relative negative offset, - 32 MB + 4*/
 -	err = create_branch(&instr, &instr, addr - 0x2000004, BRANCH_SET_LINK);
 -	check(err);
 +	instr = create_branch(&instr, addr - 0x2000004, BRANCH_SET_LINK);
 +	check(instr == 0);
  
  	/* Out of range relative positive offset, + 32 MB */
 -	err = create_branch(&instr, &instr, addr + 0x2000000, BRANCH_SET_LINK);
 -	check(err);
 +	instr = create_branch(&instr, addr + 0x2000000, BRANCH_SET_LINK);
 +	check(instr == 0);
  
  	/* Unaligned target */
 -	err = create_branch(&instr, &instr, addr + 3, BRANCH_SET_LINK);
 -	check(err);
 +	instr = create_branch(&instr, addr + 3, BRANCH_SET_LINK);
 +	check(instr == 0);
  
  	/* Check flags are masked correctly */
 -	err = create_branch(&instr, &instr, addr, 0xFFFFFFFC);
 +	instr = create_branch(&instr, addr, 0xFFFFFFFC);
  	check(instr_is_branch_to_addr(&instr, addr));
++<<<<<<< HEAD
 +	check(instr == 0x48000000);
++=======
+ 	check(ppc_inst_equal(instr, ppc_inst(0x48000000)));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  }
  
  static void __init test_create_function_call(void)
@@@ -542,21 -550,21 +546,25 @@@ static void __init test_branch_bform(vo
  	check(instr_is_branch_to_addr(&instr, addr - 0x8000));
  
  	/* Out of range relative negative offset, - 32 KB + 4*/
 -	err = create_cond_branch(&instr, iptr, addr - 0x8004, flags);
 -	check(err);
 +	instr = create_cond_branch(iptr, addr - 0x8004, flags);
 +	check(instr == 0);
  
  	/* Out of range relative positive offset, + 32 KB */
 -	err = create_cond_branch(&instr, iptr, addr + 0x8000, flags);
 -	check(err);
 +	instr = create_cond_branch(iptr, addr + 0x8000, flags);
 +	check(instr == 0);
  
  	/* Unaligned target */
 -	err = create_cond_branch(&instr, iptr, addr + 3, flags);
 -	check(err);
 +	instr = create_cond_branch(iptr, addr + 3, flags);
 +	check(instr == 0);
  
  	/* Check flags are masked correctly */
 -	err = create_cond_branch(&instr, iptr, addr, 0xFFFFFFFC);
 +	instr = create_cond_branch(iptr, addr, 0xFFFFFFFC);
  	check(instr_is_branch_to_addr(&instr, addr));
++<<<<<<< HEAD
 +	check(instr == 0x43FF0000);
++=======
+ 	check(ppc_inst_equal(instr, ppc_inst(0x43FF0000)));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  }
  
  static void __init test_translate_branch(void)
@@@ -584,20 -594,22 +592,28 @@@
  	addr = (unsigned long)p;
  	patch_branch(p, addr, 0);
  	q = buf + 0x2000000;
 -	translate_branch(&instr, q, p);
 -	patch_instruction(q, instr);
 +	patch_instruction(q, translate_branch(q, p));
  	check(instr_is_branch_to_addr(p, addr));
  	check(instr_is_branch_to_addr(q, addr));
++<<<<<<< HEAD
 +	check(*q == 0x4a000000);
++=======
+ 	check(ppc_inst_equal(*q, ppc_inst(0x4a000000)));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  
  	/* Maximum positive case, move x to x - 32 MB + 4 */
  	p = buf + 0x2000000;
  	addr = (unsigned long)p;
  	patch_branch(p, addr, 0);
  	q = buf + 4;
 -	translate_branch(&instr, q, p);
 -	patch_instruction(q, instr);
 +	patch_instruction(q, translate_branch(q, p));
  	check(instr_is_branch_to_addr(p, addr));
  	check(instr_is_branch_to_addr(q, addr));
++<<<<<<< HEAD
 +	check(*q == 0x49fffffc);
++=======
+ 	check(ppc_inst_equal(*q, ppc_inst(0x49fffffc)));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  
  	/* Jump to x + 16 MB moved to x + 20 MB */
  	p = buf;
@@@ -632,22 -648,26 +648,30 @@@
  	/* Maximum negative case, move b . to addr + 32 KB */
  	p = buf;
  	addr = (unsigned long)p;
 -	create_cond_branch(&instr, p, addr, 0xFFFFFFFC);
 -	patch_instruction(p, instr);
 +	patch_instruction(p, create_cond_branch(p, addr, 0xFFFFFFFC));
  	q = buf + 0x8000;
 -	translate_branch(&instr, q, p);
 -	patch_instruction(q, instr);
 +	patch_instruction(q, translate_branch(q, p));
  	check(instr_is_branch_to_addr(p, addr));
  	check(instr_is_branch_to_addr(q, addr));
++<<<<<<< HEAD
 +	check(*q == 0x43ff8000);
++=======
+ 	check(ppc_inst_equal(*q, ppc_inst(0x43ff8000)));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  
  	/* Maximum positive case, move x to x - 32 KB + 4 */
  	p = buf + 0x8000;
  	addr = (unsigned long)p;
 -	create_cond_branch(&instr, p, addr, 0xFFFFFFFC);
 -	patch_instruction(p, instr);
 +	patch_instruction(p, create_cond_branch(p, addr, 0xFFFFFFFC));
  	q = buf + 4;
 -	translate_branch(&instr, q, p);
 -	patch_instruction(q, instr);
 +	patch_instruction(q, translate_branch(q, p));
  	check(instr_is_branch_to_addr(p, addr));
  	check(instr_is_branch_to_addr(q, addr));
++<<<<<<< HEAD
 +	check(*q == 0x43ff7ffc);
++=======
+ 	check(ppc_inst_equal(*q, ppc_inst(0x43ff7ffc)));
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  
  	/* Jump to x + 12 KB moved to x + 20 KB */
  	p = buf;
diff --cc arch/powerpc/xmon/xmon.c
index 3ba3f8df7d8d,4cf998518047..000000000000
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@@ -891,7 -947,7 +891,11 @@@ static void remove_bpts(void
  		if ((bp->enabled & (BP_TRAP|BP_CIABR)) != BP_TRAP)
  			continue;
  		if (mread(bp->address, &instr, 4) == 4
++<<<<<<< HEAD
 +		    && instr == bpinstr
++=======
+ 		    && ppc_inst_equal(instr, ppc_inst(bpinstr))
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  		    && patch_instruction(
  			(unsigned int *)bp->address, bp->instr[0]) != 0)
  			printf("Couldn't remove breakpoint at %lx\n",
@@@ -2752,8 -2861,8 +2756,13 @@@ generic_inst_dump(unsigned long adr, lo
  			}
  			break;
  		}
++<<<<<<< HEAD
 +		inst = GETWORD(val);
 +		if (adr > first_adr && inst == last_inst) {
++=======
+ 		inst = ppc_inst(GETWORD(val));
+ 		if (adr > first_adr && ppc_inst_equal(inst, last_inst)) {
++>>>>>>> 217862d9b98b (powerpc: Introduce functions for instruction equality)
  			if (!dotted) {
  				printf(" ...\n");
  				dotted = 1;
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/include/asm/inst.h
* Unmerged path arch/powerpc/kernel/trace/ftrace.c
* Unmerged path arch/powerpc/lib/code-patching.c
* Unmerged path arch/powerpc/xmon/xmon.c
