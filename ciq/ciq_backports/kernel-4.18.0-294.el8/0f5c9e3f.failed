mptcp: add port parameter for mptcp_pm_announce_addr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 0f5c9e3f079f1d0355fd8f5e5ec7e3ada095eef4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0f5c9e3f.failed

This patch added a new parameter 'port' for mptcp_pm_announce_addr. If
this parameter is true, we set the MPTCP_ADD_ADDR_PORT bit of the
add_addr_signal. That means the announced address is added with a port
number.

	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0f5c9e3f079f1d0355fd8f5e5ec7e3ada095eef4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/pm.c
#	net/mptcp/pm_netlink.c
#	net/mptcp/protocol.h
diff --cc net/mptcp/pm.c
index a78fc80f9b51,e63e14f4cf2a..000000000000
--- a/net/mptcp/pm.c
+++ b/net/mptcp/pm.c
@@@ -15,12 -13,22 +15,28 @@@ static struct workqueue_struct *pm_wq
  /* path manager command handlers */
  
  int mptcp_pm_announce_addr(struct mptcp_sock *msk,
++<<<<<<< HEAD
 +			   const struct mptcp_addr_info *addr)
++=======
+ 			   const struct mptcp_addr_info *addr,
+ 			   bool echo, bool port)
++>>>>>>> 0f5c9e3f079f (mptcp: add port parameter for mptcp_pm_announce_addr)
  {
 -	u8 add_addr = READ_ONCE(msk->pm.add_addr_signal);
 -
  	pr_debug("msk=%p, local_id=%d", msk, addr->id);
  
  	msk->pm.local = *addr;
++<<<<<<< HEAD
 +	WRITE_ONCE(msk->pm.add_addr_signal, true);
++=======
+ 	add_addr |= BIT(MPTCP_ADD_ADDR_SIGNAL);
+ 	if (echo)
+ 		add_addr |= BIT(MPTCP_ADD_ADDR_ECHO);
+ 	if (addr->family == AF_INET6)
+ 		add_addr |= BIT(MPTCP_ADD_ADDR_IPV6);
+ 	if (port)
+ 		add_addr |= BIT(MPTCP_ADD_ADDR_PORT);
+ 	WRITE_ONCE(msk->pm.add_addr_signal, add_addr);
++>>>>>>> 0f5c9e3f079f (mptcp: add port parameter for mptcp_pm_announce_addr)
  	return 0;
  }
  
@@@ -139,17 -155,36 +155,36 @@@ void mptcp_pm_add_addr_received(struct 
  	pr_debug("msk=%p remote_id=%d accept=%d", msk, addr->id,
  		 READ_ONCE(pm->accept_addr));
  
++<<<<<<< HEAD
 +	/* avoid acquiring the lock if there is no room for fouther addresses */
 +	if (!READ_ONCE(pm->accept_addr))
++=======
+ 	spin_lock_bh(&pm->lock);
+ 
+ 	if (!READ_ONCE(pm->accept_addr)) {
+ 		mptcp_pm_announce_addr(msk, addr, true, addr->port);
+ 		mptcp_pm_add_addr_send_ack(msk);
+ 	} else if (mptcp_pm_schedule_work(msk, MPTCP_PM_ADD_ADDR_RECEIVED)) {
+ 		pm->remote = *addr;
+ 	}
+ 
+ 	spin_unlock_bh(&pm->lock);
+ }
+ 
+ void mptcp_pm_add_addr_send_ack(struct mptcp_sock *msk)
+ {
+ 	if (!mptcp_pm_should_add_signal_ipv6(msk) &&
+ 	    !mptcp_pm_should_add_signal_port(msk))
++>>>>>>> 0f5c9e3f079f (mptcp: add port parameter for mptcp_pm_announce_addr)
  		return;
  
 -	mptcp_pm_schedule_work(msk, MPTCP_PM_ADD_ADDR_SEND_ACK);
 -}
 -
 -void mptcp_pm_rm_addr_received(struct mptcp_sock *msk, u8 rm_id)
 -{
 -	struct mptcp_pm_data *pm = &msk->pm;
 +	spin_lock_bh(&pm->lock);
  
 -	pr_debug("msk=%p remote_id=%d", msk, rm_id);
 +	/* be sure there is something to signal re-checking under PM lock */
 +	if (READ_ONCE(pm->accept_addr) &&
 +	    mptcp_pm_schedule_work(msk, MPTCP_PM_ADD_ADDR_RECEIVED))
 +		pm->remote = *addr;
  
 -	spin_lock_bh(&pm->lock);
 -	mptcp_pm_schedule_work(msk, MPTCP_PM_RM_ADDR_RECEIVED);
 -	pm->rm_id = rm_id;
  	spin_unlock_bh(&pm->lock);
  }
  
diff --cc net/mptcp/pm_netlink.c
index 6f3bf9fdbbbc,2560c502356b..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -179,11 -187,130 +179,133 @@@ static void check_work_pending(struct m
  		WRITE_ONCE(msk->pm.work_pending, false);
  }
  
++<<<<<<< HEAD
++=======
+ static struct mptcp_pm_add_entry *
+ lookup_anno_list_by_saddr(struct mptcp_sock *msk,
+ 			  struct mptcp_addr_info *addr)
+ {
+ 	struct mptcp_pm_add_entry *entry;
+ 
+ 	list_for_each_entry(entry, &msk->pm.anno_list, list) {
+ 		if (addresses_equal(&entry->addr, addr, false))
+ 			return entry;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void mptcp_pm_add_timer(struct timer_list *timer)
+ {
+ 	struct mptcp_pm_add_entry *entry = from_timer(entry, timer, add_timer);
+ 	struct mptcp_sock *msk = entry->sock;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("msk=%p", msk);
+ 
+ 	if (!msk)
+ 		return;
+ 
+ 	if (inet_sk_state_load(sk) == TCP_CLOSE)
+ 		return;
+ 
+ 	if (!entry->addr.id)
+ 		return;
+ 
+ 	if (mptcp_pm_should_add_signal(msk)) {
+ 		sk_reset_timer(sk, timer, jiffies + TCP_RTO_MAX / 8);
+ 		goto out;
+ 	}
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 
+ 	if (!mptcp_pm_should_add_signal(msk)) {
+ 		pr_debug("retransmit ADD_ADDR id=%d", entry->addr.id);
+ 		mptcp_pm_announce_addr(msk, &entry->addr, false, entry->addr.port);
+ 		mptcp_pm_add_addr_send_ack(msk);
+ 		entry->retrans_times++;
+ 	}
+ 
+ 	if (entry->retrans_times < ADD_ADDR_RETRANS_MAX)
+ 		sk_reset_timer(sk, timer,
+ 			       jiffies + mptcp_get_add_addr_timeout(sock_net(sk)));
+ 
+ 	spin_unlock_bh(&msk->pm.lock);
+ 
+ out:
+ 	__sock_put(sk);
+ }
+ 
+ struct mptcp_pm_add_entry *
+ mptcp_pm_del_add_timer(struct mptcp_sock *msk,
+ 		       struct mptcp_addr_info *addr)
+ {
+ 	struct mptcp_pm_add_entry *entry;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 	entry = lookup_anno_list_by_saddr(msk, addr);
+ 	if (entry)
+ 		entry->retrans_times = ADD_ADDR_RETRANS_MAX;
+ 	spin_unlock_bh(&msk->pm.lock);
+ 
+ 	if (entry)
+ 		sk_stop_timer_sync(sk, &entry->add_timer);
+ 
+ 	return entry;
+ }
+ 
+ static bool mptcp_pm_alloc_anno_list(struct mptcp_sock *msk,
+ 				     struct mptcp_pm_addr_entry *entry)
+ {
+ 	struct mptcp_pm_add_entry *add_entry = NULL;
+ 	struct sock *sk = (struct sock *)msk;
+ 	struct net *net = sock_net(sk);
+ 
+ 	if (lookup_anno_list_by_saddr(msk, &entry->addr))
+ 		return false;
+ 
+ 	add_entry = kmalloc(sizeof(*add_entry), GFP_ATOMIC);
+ 	if (!add_entry)
+ 		return false;
+ 
+ 	list_add(&add_entry->list, &msk->pm.anno_list);
+ 
+ 	add_entry->addr = entry->addr;
+ 	add_entry->sock = msk;
+ 	add_entry->retrans_times = 0;
+ 
+ 	timer_setup(&add_entry->add_timer, mptcp_pm_add_timer, 0);
+ 	sk_reset_timer(sk, &add_entry->add_timer,
+ 		       jiffies + mptcp_get_add_addr_timeout(net));
+ 
+ 	return true;
+ }
+ 
+ void mptcp_pm_free_anno_list(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_pm_add_entry *entry, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 	LIST_HEAD(free_list);
+ 
+ 	pr_debug("msk=%p", msk);
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 	list_splice_init(&msk->pm.anno_list, &free_list);
+ 	spin_unlock_bh(&msk->pm.lock);
+ 
+ 	list_for_each_entry_safe(entry, tmp, &free_list, list) {
+ 		sk_stop_timer_sync(sk, &entry->add_timer);
+ 		kfree(entry);
+ 	}
+ }
+ 
++>>>>>>> 0f5c9e3f079f (mptcp: add port parameter for mptcp_pm_announce_addr)
  static void mptcp_pm_create_subflow_or_signal_addr(struct mptcp_sock *msk)
  {
 -	struct mptcp_addr_info remote = { 0 };
  	struct sock *sk = (struct sock *)msk;
  	struct mptcp_pm_addr_entry *local;
 +	struct mptcp_addr_info remote;
  	struct pm_nl_pernet *pernet;
  
  	pernet = net_generic(sock_net((struct sock *)msk), pm_nl_pernet_id);
@@@ -199,8 -326,11 +321,16 @@@
  					      msk->pm.add_addr_signaled);
  
  		if (local) {
++<<<<<<< HEAD
 +			msk->pm.add_addr_signaled++;
 +			mptcp_pm_announce_addr(msk, &local->addr);
++=======
+ 			if (mptcp_pm_alloc_anno_list(msk, local)) {
+ 				msk->pm.add_addr_signaled++;
+ 				mptcp_pm_announce_addr(msk, &local->addr, false, local->addr.port);
+ 				mptcp_pm_nl_add_addr_send_ack(msk);
+ 			}
++>>>>>>> 0f5c9e3f079f (mptcp: add port parameter for mptcp_pm_announce_addr)
  		} else {
  			/* pick failed, avoid fourther attempts later */
  			msk->pm.local_addr_used = msk->pm.add_addr_signal_max;
@@@ -267,8 -399,114 +400,117 @@@ void mptcp_pm_nl_add_addr_received(stru
  	local.family = remote.family;
  
  	spin_unlock_bh(&msk->pm.lock);
 -	__mptcp_subflow_connect((struct sock *)msk, &local, &remote);
 +	__mptcp_subflow_connect((struct sock *)msk, 0, &local, &remote);
  	spin_lock_bh(&msk->pm.lock);
++<<<<<<< HEAD
++=======
+ 
+ 	mptcp_pm_announce_addr(msk, &remote, true, use_port);
+ 	mptcp_pm_nl_add_addr_send_ack(msk);
+ }
+ 
+ void mptcp_pm_nl_add_addr_send_ack(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow;
+ 
+ 	if (!mptcp_pm_should_add_signal_ipv6(msk) &&
+ 	    !mptcp_pm_should_add_signal_port(msk))
+ 		return;
+ 
+ 	__mptcp_flush_join_list(msk);
+ 	subflow = list_first_entry_or_null(&msk->conn_list, typeof(*subflow), node);
+ 	if (subflow) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		u8 add_addr;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		if (mptcp_pm_should_add_signal_ipv6(msk))
+ 			pr_debug("send ack for add_addr6");
+ 		if (mptcp_pm_should_add_signal_port(msk))
+ 			pr_debug("send ack for add_addr_port");
+ 
+ 		lock_sock(ssk);
+ 		tcp_send_ack(ssk);
+ 		release_sock(ssk);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		add_addr = READ_ONCE(msk->pm.add_addr_signal);
+ 		if (mptcp_pm_should_add_signal_ipv6(msk))
+ 			add_addr &= ~BIT(MPTCP_ADD_ADDR_IPV6);
+ 		if (mptcp_pm_should_add_signal_port(msk))
+ 			add_addr &= ~BIT(MPTCP_ADD_ADDR_PORT);
+ 		WRITE_ONCE(msk->pm.add_addr_signal, add_addr);
+ 	}
+ }
+ 
+ void mptcp_pm_nl_rm_addr_received(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("address rm_id %d", msk->pm.rm_id);
+ 
+ 	if (!msk->pm.rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 
+ 		if (msk->pm.rm_id != subflow->remote_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.add_addr_accepted--;
+ 		msk->pm.subflows--;
+ 		WRITE_ONCE(msk->pm.accept_addr, true);
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMADDR);
+ 
+ 		break;
+ 	}
+ }
+ 
+ void mptcp_pm_nl_rm_subflow_received(struct mptcp_sock *msk, u8 rm_id)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("subflow rm_id %d", rm_id);
+ 
+ 	if (!rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 
+ 		if (rm_id != subflow->local_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.local_addr_used--;
+ 		msk->pm.subflows--;
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMSUBFLOW);
+ 
+ 		break;
+ 	}
++>>>>>>> 0f5c9e3f079f (mptcp: add port parameter for mptcp_pm_announce_addr)
  }
  
  static bool address_use_port(struct mptcp_pm_addr_entry *entry)
diff --cc net/mptcp/protocol.h
index ec3d81e5cc62,e880fa802cdf..000000000000
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@@ -439,11 -543,18 +439,16 @@@ void mptcp_pm_subflow_established(struc
  void mptcp_pm_subflow_closed(struct mptcp_sock *msk, u8 id);
  void mptcp_pm_add_addr_received(struct mptcp_sock *msk,
  				const struct mptcp_addr_info *addr);
 -void mptcp_pm_add_addr_send_ack(struct mptcp_sock *msk);
 -void mptcp_pm_rm_addr_received(struct mptcp_sock *msk, u8 rm_id);
 -void mptcp_pm_free_anno_list(struct mptcp_sock *msk);
 -struct mptcp_pm_add_entry *
 -mptcp_pm_del_add_timer(struct mptcp_sock *msk,
 -		       struct mptcp_addr_info *addr);
  
  int mptcp_pm_announce_addr(struct mptcp_sock *msk,
++<<<<<<< HEAD
 +			   const struct mptcp_addr_info *addr);
++=======
+ 			   const struct mptcp_addr_info *addr,
+ 			   bool echo, bool port);
++>>>>>>> 0f5c9e3f079f (mptcp: add port parameter for mptcp_pm_announce_addr)
  int mptcp_pm_remove_addr(struct mptcp_sock *msk, u8 local_id);
 -int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 local_id);
 +int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 remote_id);
  
  static inline bool mptcp_pm_should_add_signal(struct mptcp_sock *msk)
  {
* Unmerged path net/mptcp/pm.c
* Unmerged path net/mptcp/pm_netlink.c
* Unmerged path net/mptcp/protocol.h
