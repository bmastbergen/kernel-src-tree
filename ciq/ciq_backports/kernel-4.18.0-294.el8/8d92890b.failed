mm/writeback: discard NR_UNSTABLE_NFS, use NR_WRITEBACK instead

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author NeilBrown <neilb@suse.de>
commit 8d92890bd6b8502d6aee4b37430ae6444ade7a8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8d92890b.failed

After an NFS page has been written it is considered "unstable" until a
COMMIT request succeeds.  If the COMMIT fails, the page will be
re-written.

These "unstable" pages are currently accounted as "reclaimable", either
in WB_RECLAIMABLE, or in NR_UNSTABLE_NFS which is included in a
'reclaimable' count.  This might have made sense when sending the COMMIT
required a separate action by the VFS/MM (e.g.  releasepage() used to
send a COMMIT).  However now that all writes generated by ->writepages()
will automatically be followed by a COMMIT (since commit 919e3bd9a875
("NFS: Ensure we commit after writeback is complete")) it makes more
sense to treat them as writeback pages.

So this patch removes NR_UNSTABLE_NFS and accounts unstable pages in
NR_WRITEBACK and WB_WRITEBACK.

A particular effect of this change is that when
wb_check_background_flush() calls wb_over_bg_threshold(), the latter
will report 'true' a lot less often as the 'unstable' pages are no
longer considered 'dirty' (as there is nothing that writeback can do
about them anyway).

Currently wb_check_background_flush() will trigger writeback to NFS even
when there are relatively few dirty pages (if there are lots of unstable
pages), this can result in small writes going to the server (10s of
Kilobytes rather than a Megabyte) which hurts throughput.  With this
patch, there are fewer writes which are each larger on average.

Where the NR_UNSTABLE_NFS count was included in statistics
virtual-files, the entry is retained, but the value is hard-coded as
zero.  static trace points and warning printks which mentioned this
counter no longer report it.

[akpm@linux-foundation.org: re-layout comment]
[akpm@linux-foundation.org: fix printk warning]
	Signed-off-by: NeilBrown <neilb@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Acked-by: Michal Hocko <mhocko@suse.com>	[mm]
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Chuck Lever <chuck.lever@oracle.com>
Link: http://lkml.kernel.org/r/87d06j7gqa.fsf@notabene.neil.brown.name
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8d92890bd6b8502d6aee4b37430ae6444ade7a8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/filesystems/proc.txt
#	mm/page-writeback.c
diff --cc Documentation/filesystems/proc.txt
index aa9a006b4bac,092b7b44d158..000000000000
--- a/Documentation/filesystems/proc.txt
+++ b/Documentation/filesystems/proc.txt
@@@ -915,33 -1003,53 +915,45 @@@ MemAvailable: An estimate of how much m
                kernel's use for its own data structures.  Among many
                other things, it is where everything from the Slab is
                allocated.  Bad things happen when you're out of lowmem.
 -SwapTotal
 -              total amount of swap space available
 -SwapFree
 -              Memory which has been evicted from RAM, and is temporarily
 +   SwapTotal: total amount of swap space available
 +    SwapFree: Memory which has been evicted from RAM, and is temporarily
                on the disk
 -Dirty
 -              Memory which is waiting to get written back to the disk
 -Writeback
 -              Memory which is actively being written back to the disk
 -AnonPages
 -              Non-file backed pages mapped into userspace page tables
 -HardwareCorrupted
 -              The amount of RAM/memory in KB, the kernel identifies as
 +       Dirty: Memory which is waiting to get written back to the disk
 +   Writeback: Memory which is actively being written back to the disk
 +   AnonPages: Non-file backed pages mapped into userspace page tables
 +HardwareCorrupted: The amount of RAM/memory in KB, the kernel identifies as
  	      corrupted.
 -AnonHugePages
 -              Non-file backed huge pages mapped into userspace page tables
 -Mapped
 -              files which have been mmaped, such as libraries
 -Shmem
 -              Total memory used by shared memory (shmem) and tmpfs
 -ShmemHugePages
 -              Memory used by shared memory (shmem) and tmpfs allocated
 +AnonHugePages: Non-file backed huge pages mapped into userspace page tables
 +      Mapped: files which have been mmaped, such as libraries
 +       Shmem: Total memory used by shared memory (shmem) and tmpfs
 +ShmemHugePages: Memory used by shared memory (shmem) and tmpfs allocated
                with huge pages
 -ShmemPmdMapped
 -              Shared memory mapped into userspace with huge pages
 -KReclaimable
 -              Kernel allocations that the kernel will attempt to reclaim
 +ShmemPmdMapped: Shared memory mapped into userspace with huge pages
 +KReclaimable: Kernel allocations that the kernel will attempt to reclaim
                under memory pressure. Includes SReclaimable (below), and other
                direct allocations with a shrinker.
 -Slab
 -              in-kernel data structures cache
 -SReclaimable
 -              Part of Slab, that might be reclaimed, such as caches
 -SUnreclaim
 -              Part of Slab, that cannot be reclaimed on memory pressure
 -PageTables
 -              amount of memory dedicated to the lowest level of page
 +        Slab: in-kernel data structures cache
 +SReclaimable: Part of Slab, that might be reclaimed, such as caches
 +  SUnreclaim: Part of Slab, that cannot be reclaimed on memory pressure
 +  PageTables: amount of memory dedicated to the lowest level of page
                tables.
++<<<<<<< HEAD:Documentation/filesystems/proc.txt
 +NFS_Unstable: NFS pages sent to the server, but not yet committed to stable
 +	      storage
 +      Bounce: Memory used for block device "bounce buffers"
 +WritebackTmp: Memory used by FUSE for temporary writeback buffers
 + CommitLimit: Based on the overcommit ratio ('vm.overcommit_ratio'),
++=======
+ NFS_Unstable
+               Always zero. Previous counted pages which had been written to
+               the server, but has not been committed to stable storage.
+ Bounce
+               Memory used for block device "bounce buffers"
+ WritebackTmp
+               Memory used by FUSE for temporary writeback buffers
+ CommitLimit
+               Based on the overcommit ratio ('vm.overcommit_ratio'),
++>>>>>>> 8d92890bd6b8 (mm/writeback: discard NR_UNSTABLE_NFS, use NR_WRITEBACK instead):Documentation/filesystems/proc.rst
                this is the total amount of  memory currently available to
                be allocated on the system. This limit is only adhered to
                if strict overcommit accounting is enabled (mode 2 in
diff --cc mm/page-writeback.c
index 77eee73a8fd5,718565266257..000000000000
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@@ -759,6 -755,9 +758,12 @@@ static void mdtc_calc_avail(struct dirt
   *
   * The wb's share of dirty limit will be adapting to its throughput and
   * bounded by the bdi->min_ratio and/or bdi->max_ratio parameters, if set.
++<<<<<<< HEAD
++=======
+  *
+  * Return: @wb's dirty limit in pages. The term "dirty" in the context of
+  * dirty balancing includes all PG_dirty and PG_writeback pages.
++>>>>>>> 8d92890bd6b8 (mm/writeback: discard NR_UNSTABLE_NFS, use NR_WRITEBACK instead)
   */
  static unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)
  {
* Unmerged path Documentation/filesystems/proc.txt
diff --git a/drivers/base/node.c b/drivers/base/node.c
index a55e191a12c4..9a36ac67fbec 100644
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@ -436,7 +436,7 @@ static ssize_t node_read_meminfo(struct device *dev,
 		       nid, K(i.sharedram),
 		       nid, sum_zone_node_page_state(nid, NR_KERNEL_STACK_KB),
 		       nid, K(sum_zone_node_page_state(nid, NR_PAGETABLE)),
-		       nid, K(node_page_state(pgdat, NR_UNSTABLE_NFS)),
+		       nid, 0UL,
 		       nid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),
 		       nid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 		       nid, K(sreclaimable +
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index f03dccf79e58..fba4fc6554cb 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -984,7 +984,6 @@ static void bdi_split_work_to_wbs(struct backing_dev_info *bdi,
 static unsigned long get_nr_dirty_pages(void)
 {
 	return global_node_page_state(NR_FILE_DIRTY) +
-		global_node_page_state(NR_UNSTABLE_NFS) +
 		get_nr_dirty_inodes();
 }
 
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8dcf11de77be..e3eae742b046 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -659,7 +659,8 @@ void nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)
 }
 
 /*
- * Record the page as unstable and mark its inode as dirty.
+ * Record the page as unstable (an extra writeback period) and mark its
+ * inode as dirty.
  */
 static inline
 void nfs_mark_page_unstable(struct page *page, struct nfs_commit_info *cinfo)
@@ -667,8 +668,11 @@ void nfs_mark_page_unstable(struct page *page, struct nfs_commit_info *cinfo)
 	if (!cinfo->dreq) {
 		struct inode *inode = page_file_mapping(page)->host;
 
-		inc_node_page_state(page, NR_UNSTABLE_NFS);
-		inc_wb_stat(&inode_to_bdi(inode)->wb, WB_RECLAIMABLE);
+		/* This page is really still in write-back - just that the
+		 * writeback is happening on the server now.
+		 */
+		inc_node_page_state(page, NR_WRITEBACK);
+		inc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);
 		__mark_inode_dirty(inode, I_DIRTY_DATASYNC);
 	}
 }
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 37d20a006b47..2158435bbe1c 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -945,9 +945,9 @@ nfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,
 static void
 nfs_clear_page_commit(struct page *page)
 {
-	dec_node_page_state(page, NR_UNSTABLE_NFS);
+	dec_node_page_state(page, NR_WRITEBACK);
 	dec_wb_stat(&inode_to_bdi(page_file_mapping(page)->host)->wb,
-		    WB_RECLAIMABLE);
+		    WB_WRITEBACK);
 }
 
 /* Called holding the request lock on @req */
diff --git a/fs/proc/meminfo.c b/fs/proc/meminfo.c
index 568d90e17c17..d298da008f6c 100644
--- a/fs/proc/meminfo.c
+++ b/fs/proc/meminfo.c
@@ -110,8 +110,7 @@ static int meminfo_proc_show(struct seq_file *m, void *v)
 	show_val_kb(m, "Quicklists:     ", quicklist_total_size());
 #endif
 
-	show_val_kb(m, "NFS_Unstable:   ",
-		    global_node_page_state(NR_UNSTABLE_NFS));
+	show_val_kb(m, "NFS_Unstable:   ", 0);
 	show_val_kb(m, "Bounce:         ",
 		    global_zone_page_state(NR_BOUNCE));
 	show_val_kb(m, "WritebackTmp:   ",
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index c21e3997e8bf..0fd3151d4aba 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -235,7 +235,6 @@ enum node_stat_item {
 	NR_SHMEM_THPS,
 	NR_SHMEM_PMDMAPPED,
 	NR_ANON_THPS,
-	NR_UNSTABLE_NFS,	/* NFS unstable pages */
 	NR_VMSCAN_WRITE,
 	NR_VMSCAN_IMMEDIATE,	/* Prioritise for reclaim when writeback ends */
 	NR_DIRTIED,		/* page dirtyings since bootup */
diff --git a/include/trace/events/writeback.h b/include/trace/events/writeback.h
index 365cbd038a51..7a1876776450 100644
--- a/include/trace/events/writeback.h
+++ b/include/trace/events/writeback.h
@@ -402,7 +402,6 @@ TRACE_EVENT(global_dirty_state,
 	TP_STRUCT__entry(
 		__field(unsigned long,	nr_dirty)
 		__field(unsigned long,	nr_writeback)
-		__field(unsigned long,	nr_unstable)
 		__field(unsigned long,	background_thresh)
 		__field(unsigned long,	dirty_thresh)
 		__field(unsigned long,	dirty_limit)
@@ -413,7 +412,6 @@ TRACE_EVENT(global_dirty_state,
 	TP_fast_assign(
 		__entry->nr_dirty	= global_node_page_state(NR_FILE_DIRTY);
 		__entry->nr_writeback	= global_node_page_state(NR_WRITEBACK);
-		__entry->nr_unstable	= global_node_page_state(NR_UNSTABLE_NFS);
 		__entry->nr_dirtied	= global_node_page_state(NR_DIRTIED);
 		__entry->nr_written	= global_node_page_state(NR_WRITTEN);
 		__entry->background_thresh = background_thresh;
@@ -421,12 +419,11 @@ TRACE_EVENT(global_dirty_state,
 		__entry->dirty_limit	= global_wb_domain.dirty_limit;
 	),
 
-	TP_printk("dirty=%lu writeback=%lu unstable=%lu "
+	TP_printk("dirty=%lu writeback=%lu "
 		  "bg_thresh=%lu thresh=%lu limit=%lu "
 		  "dirtied=%lu written=%lu",
 		  __entry->nr_dirty,
 		  __entry->nr_writeback,
-		  __entry->nr_unstable,
 		  __entry->background_thresh,
 		  __entry->dirty_thresh,
 		  __entry->dirty_limit,
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 48fa67e8a272..4c157e946547 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -4202,7 +4202,6 @@ void mem_cgroup_wb_stats(struct bdi_writeback *wb, unsigned long *pfilepages,
 
 	*pdirty = memcg_exact_page_state(memcg, NR_FILE_DIRTY);
 
-	/* this should eventually include NR_UNSTABLE_NFS */
 	*pwriteback = memcg_exact_page_state(memcg, NR_WRITEBACK);
 	*pfilepages = memcg_exact_page_state(memcg, NR_INACTIVE_FILE) +
 			memcg_exact_page_state(memcg, NR_ACTIVE_FILE);
* Unmerged path mm/page-writeback.c
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 86fc898ac882..454a0fdd364a 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -4975,7 +4975,7 @@ void show_free_areas(unsigned int filter, nodemask_t *nodemask)
 
 	printk("active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n"
 		" active_file:%lu inactive_file:%lu isolated_file:%lu\n"
-		" unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n"
+		" unevictable:%lu dirty:%lu writeback:%lu\n"
 		" slab_reclaimable:%lu slab_unreclaimable:%lu\n"
 		" mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n"
 		" free:%lu free_pcp:%lu free_cma:%lu\n",
@@ -4988,7 +4988,6 @@ void show_free_areas(unsigned int filter, nodemask_t *nodemask)
 		global_node_page_state(NR_UNEVICTABLE),
 		global_node_page_state(NR_FILE_DIRTY),
 		global_node_page_state(NR_WRITEBACK),
-		global_node_page_state(NR_UNSTABLE_NFS),
 		global_node_page_state(NR_SLAB_RECLAIMABLE),
 		global_node_page_state(NR_SLAB_UNRECLAIMABLE),
 		global_node_page_state(NR_FILE_MAPPED),
@@ -5021,7 +5020,6 @@ void show_free_areas(unsigned int filter, nodemask_t *nodemask)
 			" anon_thp: %lukB"
 #endif
 			" writeback_tmp:%lukB"
-			" unstable:%lukB"
 			" all_unreclaimable? %s"
 			"\n",
 			pgdat->node_id,
@@ -5043,7 +5041,6 @@ void show_free_areas(unsigned int filter, nodemask_t *nodemask)
 			K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),
 #endif
 			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
-			K(node_page_state(pgdat, NR_UNSTABLE_NFS)),
 			pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?
 				"yes" : "no");
 	}
diff --git a/mm/vmstat.c b/mm/vmstat.c
index 8285022e8e12..8f3830539b6d 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -1107,7 +1107,7 @@ int fragmentation_index(struct zone *zone, unsigned int order)
 					TEXT_FOR_HIGHMEM(xx) xx "_movable",
 
 const char * const vmstat_text[] = {
-	/* enum zone_stat_item countes */
+	/* enum zone_stat_item counters */
 	"nr_free_pages",
 	"nr_zone_inactive_anon",
 	"nr_zone_active_anon",
@@ -1158,7 +1158,6 @@ const char * const vmstat_text[] = {
 	"nr_shmem_hugepages",
 	"nr_shmem_pmdmapped",
 	"nr_anon_transparent_hugepages",
-	"nr_unstable",
 	"nr_vmscan_write",
 	"nr_vmscan_immediate_reclaim",
 	"nr_dirtied",
@@ -1714,6 +1713,14 @@ static int vmstat_show(struct seq_file *m, void *arg)
 	seq_puts(m, vmstat_text[off]);
 	seq_put_decimal_ull(m, " ", *l);
 	seq_putc(m, '\n');
+
+	if (off == NR_VMSTAT_ITEMS - 1) {
+		/*
+		 * We've come to the end - add any deprecated counters to avoid
+		 * breaking userspace which might depend on them being present.
+		 */
+		seq_puts(m, "nr_unstable 0\n");
+	}
 	return 0;
 }
 
