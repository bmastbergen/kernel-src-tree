KVM: SVM: Modify 64 bit intercept field to two 32 bit vectors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Babu Moger <babu.moger@amd.com>
commit c62e2e94b9d4a221f489cfeacf665c50aa9ab6cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c62e2e94.failed

Convert all the intercepts to one array of 32 bit vectors in
vmcb_control_area. This makes it easy for future intercept vector
additions. Also update trace functions.

	Signed-off-by: Babu Moger <babu.moger@amd.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
Message-Id: <159985250813.11252.5736581193881040525.stgit@bmoger-ubuntu>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c62e2e94b9d4a221f489cfeacf665c50aa9ab6cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/svm.h
#	arch/x86/kvm/svm/nested.c
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/include/asm/svm.h
index acac55d6f941,c2ae1dfb37a4..000000000000
--- a/arch/x86/include/asm/svm.h
+++ b/arch/x86/include/asm/svm.h
@@@ -3,10 -3,53 +3,58 @@@
  #define __SVM_H
  
  #include <uapi/asm/svm.h>
 -#include <uapi/asm/kvm.h>
  
++<<<<<<< HEAD
 +
 +enum {
 +	INTERCEPT_INTR,
++=======
+ /*
+  * 32-bit intercept words in the VMCB Control Area, starting
+  * at Byte offset 000h.
+  */
+ 
+ enum intercept_words {
+ 	INTERCEPT_CR = 0,
+ 	INTERCEPT_DR,
+ 	INTERCEPT_EXCEPTION,
+ 	INTERCEPT_WORD3,
+ 	INTERCEPT_WORD4,
+ 	MAX_INTERCEPT,
+ };
+ 
+ enum {
+ 	/* Byte offset 000h (word 0) */
+ 	INTERCEPT_CR0_READ = 0,
+ 	INTERCEPT_CR3_READ = 3,
+ 	INTERCEPT_CR4_READ = 4,
+ 	INTERCEPT_CR8_READ = 8,
+ 	INTERCEPT_CR0_WRITE = 16,
+ 	INTERCEPT_CR3_WRITE = 16 + 3,
+ 	INTERCEPT_CR4_WRITE = 16 + 4,
+ 	INTERCEPT_CR8_WRITE = 16 + 8,
+ 	/* Byte offset 004h (word 1) */
+ 	INTERCEPT_DR0_READ = 32,
+ 	INTERCEPT_DR1_READ,
+ 	INTERCEPT_DR2_READ,
+ 	INTERCEPT_DR3_READ,
+ 	INTERCEPT_DR4_READ,
+ 	INTERCEPT_DR5_READ,
+ 	INTERCEPT_DR6_READ,
+ 	INTERCEPT_DR7_READ,
+ 	INTERCEPT_DR0_WRITE = 48,
+ 	INTERCEPT_DR1_WRITE,
+ 	INTERCEPT_DR2_WRITE,
+ 	INTERCEPT_DR3_WRITE,
+ 	INTERCEPT_DR4_WRITE,
+ 	INTERCEPT_DR5_WRITE,
+ 	INTERCEPT_DR6_WRITE,
+ 	INTERCEPT_DR7_WRITE,
+ 	/* Byte offset 008h (word 2) */
+ 	INTERCEPT_EXCEPTION_OFFSET = 64,
+ 	/* Byte offset 00Ch (word 3) */
+ 	INTERCEPT_INTR = 96,
++>>>>>>> c62e2e94b9d4 (KVM: SVM: Modify 64 bit intercept field to two 32 bit vectors)
  	INTERCEPT_NMI,
  	INTERCEPT_SMI,
  	INTERCEPT_INIT,
@@@ -57,11 -101,8 +106,16 @@@
  
  
  struct __attribute__ ((__packed__)) vmcb_control_area {
++<<<<<<< HEAD
 +	u32 intercept_cr;
 +	u32 intercept_dr;
 +	u32 intercept_exceptions;
 +	u64 intercept;
 +	u8 reserved_1[40];
++=======
+ 	u32 intercepts[MAX_INTERCEPT];
+ 	u32 reserved_1[15 - MAX_INTERCEPT];
++>>>>>>> c62e2e94b9d4 (KVM: SVM: Modify 64 bit intercept field to two 32 bit vectors)
  	u16 pause_filter_thresh;
  	u16 pause_filter_count;
  	u64 iopm_base_pa;
diff --cc arch/x86/kvm/svm/nested.c
index 3a222ac541d6,cc0985c0e09e..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -108,17 -109,13 +108,20 @@@ void recalc_intercepts(struct vcpu_svm 
  	h = &svm->nested.hsave->control;
  	g = &svm->nested.ctl;
  
 -	for (i = 0; i < MAX_INTERCEPT; i++)
 -		c->intercepts[i] = h->intercepts[i];
 +	svm->nested.host_intercept_exceptions = h->intercept_exceptions;
  
++<<<<<<< HEAD
 +	c->intercept_cr = h->intercept_cr;
 +	c->intercept_dr = h->intercept_dr;
 +	c->intercept_exceptions = h->intercept_exceptions;
 +	c->intercept = h->intercept;
 +
++=======
++>>>>>>> c62e2e94b9d4 (KVM: SVM: Modify 64 bit intercept field to two 32 bit vectors)
  	if (g->int_ctl & V_INTR_MASKING_MASK) {
  		/* We only want the cr8 intercept bits of L1 */
 -		vmcb_clr_intercept(c, INTERCEPT_CR8_READ);
 -		vmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);
 +		c->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);
 +		c->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);
  
  		/*
  		 * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not
@@@ -129,21 -126,20 +132,34 @@@
  	}
  
  	/* We don't want to see VMMCALLs from a nested guest */
- 	c->intercept &= ~(1ULL << INTERCEPT_VMMCALL);
+ 	vmcb_clr_intercept(c, INTERCEPT_VMMCALL);
  
++<<<<<<< HEAD
 +	c->intercept_cr |= g->intercept_cr;
 +	c->intercept_dr |= g->intercept_dr;
 +	c->intercept_exceptions |= g->intercept_exceptions;
 +	c->intercept |= g->intercept;
++=======
+ 	for (i = 0; i < MAX_INTERCEPT; i++)
+ 		c->intercepts[i] |= g->intercepts[i];
++>>>>>>> c62e2e94b9d4 (KVM: SVM: Modify 64 bit intercept field to two 32 bit vectors)
  }
  
  static void copy_vmcb_control_area(struct vmcb_control_area *dst,
  				   struct vmcb_control_area *from)
  {
++<<<<<<< HEAD
 +	dst->intercept_cr         = from->intercept_cr;
 +	dst->intercept_dr         = from->intercept_dr;
 +	dst->intercept_exceptions = from->intercept_exceptions;
 +	dst->intercept            = from->intercept;
++=======
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < MAX_INTERCEPT; i++)
+ 		dst->intercepts[i] = from->intercepts[i];
+ 
++>>>>>>> c62e2e94b9d4 (KVM: SVM: Modify 64 bit intercept field to two 32 bit vectors)
  	dst->iopm_base_pa         = from->iopm_base_pa;
  	dst->msrpm_base_pa        = from->msrpm_base_pa;
  	dst->tsc_offset           = from->tsc_offset;
@@@ -459,16 -475,17 +475,24 @@@ int nested_svm_vmrun(struct vcpu_svm *s
  		goto out;
  	}
  
 -	trace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb12_gpa,
 -			       vmcb12->save.rip,
 -			       vmcb12->control.int_ctl,
 -			       vmcb12->control.event_inj,
 -			       vmcb12->control.nested_ctl);
 -
 +	trace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,
 +			       nested_vmcb->save.rip,
 +			       nested_vmcb->control.int_ctl,
 +			       nested_vmcb->control.event_inj,
 +			       nested_vmcb->control.nested_ctl);
 +
++<<<<<<< HEAD
 +	trace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,
 +				    nested_vmcb->control.intercept_cr >> 16,
 +				    nested_vmcb->control.intercept_exceptions,
 +				    nested_vmcb->control.intercept);
++=======
+ 	trace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,
+ 				    vmcb12->control.intercepts[INTERCEPT_CR] >> 16,
+ 				    vmcb12->control.intercepts[INTERCEPT_EXCEPTION],
+ 				    vmcb12->control.intercepts[INTERCEPT_WORD3],
+ 				    vmcb12->control.intercepts[INTERCEPT_WORD4]);
++>>>>>>> c62e2e94b9d4 (KVM: SVM: Modify 64 bit intercept field to two 32 bit vectors)
  
  	/* Clear internal status */
  	kvm_clear_exception_queue(&svm->vcpu);
diff --cc arch/x86/kvm/svm/svm.c
index ffcc287ce9b5,9c399b393d46..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -2806,12 -2809,14 +2803,23 @@@ static void dump_vmcb(struct kvm_vcpu *
  	}
  
  	pr_err("VMCB Control Area:\n");
++<<<<<<< HEAD
 +	pr_err("%-20s%04x\n", "cr_read:", control->intercept_cr & 0xffff);
 +	pr_err("%-20s%04x\n", "cr_write:", control->intercept_cr >> 16);
 +	pr_err("%-20s%04x\n", "dr_read:", control->intercept_dr & 0xffff);
 +	pr_err("%-20s%04x\n", "dr_write:", control->intercept_dr >> 16);
 +	pr_err("%-20s%08x\n", "exceptions:", control->intercept_exceptions);
 +	pr_err("%-20s%016llx\n", "intercepts:", control->intercept);
++=======
+ 	pr_err("%-20s%04x\n", "cr_read:", control->intercepts[INTERCEPT_CR] & 0xffff);
+ 	pr_err("%-20s%04x\n", "cr_write:", control->intercepts[INTERCEPT_CR] >> 16);
+ 	pr_err("%-20s%04x\n", "dr_read:", control->intercepts[INTERCEPT_DR] & 0xffff);
+ 	pr_err("%-20s%04x\n", "dr_write:", control->intercepts[INTERCEPT_DR] >> 16);
+ 	pr_err("%-20s%08x\n", "exceptions:", control->intercepts[INTERCEPT_EXCEPTION]);
+ 	pr_err("%-20s%08x %08x\n", "intercepts:",
+               control->intercepts[INTERCEPT_WORD3],
+ 	       control->intercepts[INTERCEPT_WORD4]);
++>>>>>>> c62e2e94b9d4 (KVM: SVM: Modify 64 bit intercept field to two 32 bit vectors)
  	pr_err("%-20s%d\n", "pause filter count:", control->pause_filter_count);
  	pr_err("%-20s%d\n", "pause filter threshold:",
  	       control->pause_filter_thresh);
* Unmerged path arch/x86/include/asm/svm.h
* Unmerged path arch/x86/kvm/svm/nested.c
* Unmerged path arch/x86/kvm/svm/svm.c
diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.h
index 7e2440454c08..e91174fd108f 100644
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@ -297,7 +297,7 @@ static inline void svm_set_intercept(struct vcpu_svm *svm, int bit)
 {
 	struct vmcb *vmcb = get_host_vmcb(svm);
 
-	vmcb->control.intercept |= (1ULL << bit);
+	vmcb_set_intercept(&vmcb->control, bit);
 
 	recalc_intercepts(svm);
 }
@@ -306,14 +306,14 @@ static inline void svm_clr_intercept(struct vcpu_svm *svm, int bit)
 {
 	struct vmcb *vmcb = get_host_vmcb(svm);
 
-	vmcb->control.intercept &= ~(1ULL << bit);
+	vmcb_clr_intercept(&vmcb->control, bit);
 
 	recalc_intercepts(svm);
 }
 
 static inline bool svm_is_intercept(struct vcpu_svm *svm, int bit)
 {
-	return (svm->vmcb->control.intercept & (1ULL << bit)) != 0;
+	return vmcb_is_intercept(&svm->vmcb->control, bit);
 }
 
 static inline bool vgif_enabled(struct vcpu_svm *svm)
@@ -374,17 +374,17 @@ static inline bool nested_svm_virtualize_tpr(struct kvm_vcpu *vcpu)
 
 static inline bool nested_exit_on_smi(struct vcpu_svm *svm)
 {
-	return (svm->nested.ctl.intercept & (1ULL << INTERCEPT_SMI));
+	return vmcb_is_intercept(&svm->nested.ctl, INTERCEPT_SMI);
 }
 
 static inline bool nested_exit_on_intr(struct vcpu_svm *svm)
 {
-	return (svm->nested.ctl.intercept & (1ULL << INTERCEPT_INTR));
+	return vmcb_is_intercept(&svm->nested.ctl, INTERCEPT_INTR);
 }
 
 static inline bool nested_exit_on_nmi(struct vcpu_svm *svm)
 {
-	return (svm->nested.ctl.intercept & (1ULL << INTERCEPT_NMI));
+	return vmcb_is_intercept(&svm->nested.ctl, INTERCEPT_NMI);
 }
 
 int enter_svm_guest_mode(struct vcpu_svm *svm, u64 vmcb_gpa,
diff --git a/arch/x86/kvm/trace.h b/arch/x86/kvm/trace.h
index dd3e08ca8345..16361811fbf9 100644
--- a/arch/x86/kvm/trace.h
+++ b/arch/x86/kvm/trace.h
@@ -544,26 +544,30 @@ TRACE_EVENT(kvm_nested_vmrun,
 );
 
 TRACE_EVENT(kvm_nested_intercepts,
-	    TP_PROTO(__u16 cr_read, __u16 cr_write, __u32 exceptions, __u64 intercept),
-	    TP_ARGS(cr_read, cr_write, exceptions, intercept),
+	    TP_PROTO(__u16 cr_read, __u16 cr_write, __u32 exceptions, __u32 intercept1,
+		     __u32 intercept2),
+	    TP_ARGS(cr_read, cr_write, exceptions, intercept1, intercept2),
 
 	TP_STRUCT__entry(
 		__field(	__u16,		cr_read		)
 		__field(	__u16,		cr_write	)
 		__field(	__u32,		exceptions	)
-		__field(	__u64,		intercept	)
+		__field(	__u32,		intercept1	)
+		__field(	__u32,		intercept2	)
 	),
 
 	TP_fast_assign(
 		__entry->cr_read	= cr_read;
 		__entry->cr_write	= cr_write;
 		__entry->exceptions	= exceptions;
-		__entry->intercept	= intercept;
+		__entry->intercept1	= intercept1;
+		__entry->intercept2	= intercept2;
 	),
 
-	TP_printk("cr_read: %04x cr_write: %04x excp: %08x intercept: %016llx",
-		__entry->cr_read, __entry->cr_write, __entry->exceptions,
-		__entry->intercept)
+	TP_printk("cr_read: %04x cr_write: %04x excp: %08x "
+		  "intercepts: %08x %08x",
+		  __entry->cr_read, __entry->cr_write, __entry->exceptions,
+		  __entry->intercept1, __entry->intercept2)
 );
 /*
  * Tracepoint for #VMEXIT while nested
