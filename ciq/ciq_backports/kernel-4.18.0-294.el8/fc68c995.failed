vxlan: Support for PMTU discovery on directly bridged links

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Stefano Brivio <sbrivio@redhat.com>
commit fc68c99577cc66e38d11b3e29304efb83fa08d53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fc68c995.failed

If the interface is a bridge or Open vSwitch port, and we can't
forward a packet because it exceeds the local PMTU estimate,
trigger an ICMP or ICMPv6 reply to the sender, using the same
interface to forward it back.

If metadata collection is enabled, reverse destination and source
addresses, so that Open vSwitch is able to match this packet against
the existing, reverse flow.

v2: Use netif_is_any_bridge_port() (David Ahern)

	Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fc68c99577cc66e38d11b3e29304efb83fa08d53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 205667d02a99,6d5816be6131..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2529,9 -2722,25 +2531,29 @@@ static void vxlan_xmit_one(struct sk_bu
  		}
  
  		ndst = &rt->dst;
++<<<<<<< HEAD
 +		skb_tunnel_check_pmtu(skb, ndst, VXLAN_HEADROOM);
++=======
+ 		err = skb_tunnel_check_pmtu(skb, ndst, VXLAN_HEADROOM,
+ 					    netif_is_any_bridge_port(dev));
+ 		if (err < 0) {
+ 			goto tx_error;
+ 		} else if (err) {
+ 			if (info) {
+ 				struct in_addr src, dst;
+ 
+ 				src = remote_ip.sin.sin_addr;
+ 				dst = local_ip.sin.sin_addr;
+ 				info->key.u.ipv4.src = src.s_addr;
+ 				info->key.u.ipv4.dst = dst.s_addr;
+ 			}
+ 			vxlan_encap_bypass(skb, vxlan, vxlan, vni, false);
+ 			dst_release(ndst);
+ 			goto out_unlock;
+ 		}
++>>>>>>> fc68c99577cc (vxlan: Support for PMTU discovery on directly bridged links)
  
 -		tos = ip_tunnel_ecn_encap(RT_TOS(tos), old_iph, skb);
 +		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
  		err = vxlan_build_skb(skb, ndst, sizeof(struct iphdr),
  				      vni, md, flags, udp_sum);
@@@ -2566,9 -2778,26 +2588,30 @@@
  				goto out_unlock;
  		}
  
++<<<<<<< HEAD
 +		skb_tunnel_check_pmtu(skb, ndst, VXLAN6_HEADROOM);
++=======
+ 		err = skb_tunnel_check_pmtu(skb, ndst, VXLAN6_HEADROOM,
+ 					    netif_is_any_bridge_port(dev));
+ 		if (err < 0) {
+ 			goto tx_error;
+ 		} else if (err) {
+ 			if (info) {
+ 				struct in6_addr src, dst;
+ 
+ 				src = remote_ip.sin6.sin6_addr;
+ 				dst = local_ip.sin6.sin6_addr;
+ 				info->key.u.ipv6.src = src;
+ 				info->key.u.ipv6.dst = dst;
+ 			}
+ 
+ 			vxlan_encap_bypass(skb, vxlan, vxlan, vni, false);
+ 			dst_release(ndst);
+ 			goto out_unlock;
+ 		}
++>>>>>>> fc68c99577cc (vxlan: Support for PMTU discovery on directly bridged links)
  
 -		tos = ip_tunnel_ecn_encap(RT_TOS(tos), old_iph, skb);
 +		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
  		skb_scrub_packet(skb, xnet);
  		err = vxlan_build_skb(skb, ndst, sizeof(struct ipv6hdr),
* Unmerged path drivers/net/vxlan.c
