RDMA/core: Update write interface to use automatic object lifetime

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit 16e51f78a9db3645d2d2dd7c0a78e7e7776b630e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/16e51f78.failed

The automatic object lifetime model allows us to change the write()
interface to have the same logic as the ioctl() path. Update the
create/alloc functions to be in the following format, so the code flow
will be the same:

 * Allocate objects
 * Initialize them
 * Call to the drivers, this is last step that is allowed to fail
 * Finalize object
 * Return response and allow to core code to handle abort/commit
   respectively.

Link: https://lore.kernel.org/r/20200719052223.75245-3-leon@kernel.org
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 16e51f78a9db3645d2d2dd7c0a78e7e7776b630e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 3af25864e2cb,479895db72e2..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -1035,26 -999,19 +989,39 @@@ static int create_cq(struct uverbs_attr
  	ret = ib_dev->ops.create_cq(cq, &attr, &attrs->driver_udata);
  	if (ret)
  		goto err_free;
+ 	rdma_restrack_uadd(&cq->res);
  
  	obj->uevent.uobject.object = cq;
++<<<<<<< HEAD
 +	memset(&resp, 0, sizeof resp);
++=======
+ 	obj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);
+ 	if (obj->uevent.event_file)
+ 		uverbs_uobject_get(&obj->uevent.event_file->uobj);
+ 	uobj_finalize_uobj_create(&obj->uevent.uobject, attrs);
+ 
++>>>>>>> 16e51f78a9db (RDMA/core: Update write interface to use automatic object lifetime)
  	resp.base.cq_handle = obj->uevent.uobject.id;
- 	resp.base.cqe       = cq->cqe;
+ 	resp.base.cqe = cq->cqe;
  	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
  
++<<<<<<< HEAD
 +	cq->res.type = RDMA_RESTRACK_CQ;
 +	rdma_restrack_uadd(&cq->res);
 +
 +	ret = uverbs_response(attrs, &resp, sizeof(resp));
 +	if (ret)
 +		goto err_cb;
 +
 +	rdma_alloc_commit_uobject(&obj->uevent.uobject, attrs);
 +	return obj;
 +
 +err_cb:
 +	ib_destroy_cq_user(cq, uverbs_get_cleared_udata(attrs));
 +	cq = NULL;
++=======
++>>>>>>> 16e51f78a9db (RDMA/core: Update write interface to use automatic object lifetime)
  err_free:
  	kfree(cq);
  err_file:
@@@ -1446,21 -1397,10 +1407,24 @@@ static int create_qp(struct uverbs_attr
  	}
  
  	obj->uevent.uobject.object = qp;
 -	obj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);
 -	if (obj->uevent.event_file)
 -		uverbs_uobject_get(&obj->uevent.event_file->uobj);
  
++<<<<<<< HEAD
 +	memset(&resp, 0, sizeof resp);
 +	resp.base.qpn             = qp->qp_num;
 +	resp.base.qp_handle       = obj->uevent.uobject.id;
 +	resp.base.max_recv_sge    = attr.cap.max_recv_sge;
 +	resp.base.max_send_sge    = attr.cap.max_send_sge;
 +	resp.base.max_recv_wr     = attr.cap.max_recv_wr;
 +	resp.base.max_send_wr     = attr.cap.max_send_wr;
 +	resp.base.max_inline_data = attr.cap.max_inline_data;
 +	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
 +
 +	ret = uverbs_response(attrs, &resp, sizeof(resp));
 +	if (ret)
 +		goto err_cb;
 +
++=======
++>>>>>>> 16e51f78a9db (RDMA/core: Update write interface to use automatic object lifetime)
  	if (xrcd) {
  		obj->uxrcd = container_of(xrcd_uobj, struct ib_uxrcd_object,
  					  uobject);
@@@ -1481,9 -1421,18 +1445,23 @@@
  					UVERBS_LOOKUP_READ);
  	if (ind_tbl)
  		uobj_put_obj_read(ind_tbl);
+ 	uobj_finalize_uobj_create(&obj->uevent.uobject, attrs);
+ 
+ 	resp.base.qpn             = qp->qp_num;
+ 	resp.base.qp_handle       = obj->uevent.uobject.id;
+ 	resp.base.max_recv_sge    = attr.cap.max_recv_sge;
+ 	resp.base.max_send_sge    = attr.cap.max_send_sge;
+ 	resp.base.max_recv_wr     = attr.cap.max_recv_wr;
+ 	resp.base.max_send_wr     = attr.cap.max_send_wr;
+ 	resp.base.max_inline_data = attr.cap.max_inline_data;
+ 	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
  
++<<<<<<< HEAD
 +	rdma_alloc_commit_uobject(&obj->uevent.uobject, attrs);
 +	return 0;
++=======
++>>>>>>> 16e51f78a9db (RDMA/core: Update write interface to use automatic object lifetime)
  err_cb:
  	ib_destroy_qp_user(qp, uverbs_get_cleared_udata(attrs));
  
@@@ -2961,25 -2892,22 +2921,30 @@@ static int ib_uverbs_ex_create_wq(struc
  	atomic_set(&wq->usecnt, 0);
  	atomic_inc(&pd->usecnt);
  	atomic_inc(&cq->usecnt);
 -	obj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);
 -	if (obj->uevent.event_file)
 -		uverbs_uobject_get(&obj->uevent.event_file->uobj);
  
- 	memset(&resp, 0, sizeof(resp));
+ 	uobj_put_obj_read(pd);
+ 	rdma_lookup_put_uobject(&cq->uobject->uevent.uobject,
+ 				UVERBS_LOOKUP_READ);
+ 	uobj_finalize_uobj_create(&obj->uevent.uobject, attrs);
+ 
  	resp.wq_handle = obj->uevent.uobject.id;
  	resp.max_sge = wq_init_attr.max_sge;
  	resp.max_wr = wq_init_attr.max_wr;
  	resp.wqn = wq->wq_num;
  	resp.response_length = uverbs_response_length(attrs, sizeof(resp));
- 	err = uverbs_response(attrs, &resp, sizeof(resp));
- 	if (err)
- 		goto err_copy;
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
  
++<<<<<<< HEAD
 +	uobj_put_obj_read(pd);
 +	rdma_lookup_put_uobject(&cq->uobject->uevent.uobject,
 +				UVERBS_LOOKUP_READ);
 +	rdma_alloc_commit_uobject(&obj->uevent.uobject, attrs);
 +	return 0;
 +
 +err_copy:
 +	ib_destroy_wq(wq, uverbs_get_cleared_udata(attrs));
++=======
++>>>>>>> 16e51f78a9db (RDMA/core: Update write interface to use automatic object lifetime)
  err_put_cq:
  	rdma_lookup_put_uobject(&cq->uobject->uevent.uobject,
  				UVERBS_LOOKUP_READ);
@@@ -3439,11 -3353,11 +3390,7 @@@ static int __uverbs_create_xsrq(struct 
  	}
  
  	obj->uevent.uobject.object = srq;
 -	obj->uevent.uobject.user_handle = cmd->user_handle;
 -	obj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);
 -	if (obj->uevent.event_file)
 -		uverbs_uobject_get(&obj->uevent.event_file->uobj);
  
- 	memset(&resp, 0, sizeof resp);
- 	resp.srq_handle = obj->uevent.uobject.id;
- 	resp.max_wr     = attr.attr.max_wr;
- 	resp.max_sge    = attr.attr.max_sge;
  	if (cmd->srq_type == IB_SRQT_XRC)
  		resp.srqn = srq->ext.xrc.srq_num;
  
@@@ -3459,11 -3369,13 +3402,18 @@@
  					UVERBS_LOOKUP_READ);
  
  	uobj_put_obj_read(pd);
- 	rdma_alloc_commit_uobject(&obj->uevent.uobject, attrs);
- 	return 0;
+ 	uobj_finalize_uobj_create(&obj->uevent.uobject, attrs);
+ 
+ 	resp.srq_handle = obj->uevent.uobject.id;
+ 	resp.max_wr = attr.attr.max_wr;
+ 	resp.max_sge = attr.attr.max_sge;
+ 	return uverbs_response(attrs, &resp, sizeof(resp));
  
++<<<<<<< HEAD
 +err_copy:
 +	ib_destroy_srq_user(srq, uverbs_get_cleared_udata(attrs));
++=======
++>>>>>>> 16e51f78a9db (RDMA/core: Update write interface to use automatic object lifetime)
  err_put_pd:
  	uobj_put_obj_read(pd);
  err_put_cq:
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
