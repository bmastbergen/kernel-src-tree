mm/gup: refactor and de-duplicate gup_fast() code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author John Hubbard <jhubbard@nvidia.com>
commit 376a34efa4eeb699d285c1a741b186d44b44c429
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/376a34ef.failed

There were two nearly identical sets of code for gup_fast() style of
walking the page tables with interrupts disabled.  This has lead to the
usual maintenance problems that arise from having duplicated code.

There is already a core internal routine in gup.c for gup_fast(), so just
enhance it very slightly: allow skipping the fall-back to "slow" (regular)
get_user_pages(), via the new FOLL_FAST_ONLY flag.  Then, just call
internal_get_user_pages_fast() from __get_user_pages_fast(), and adjust
the API to match pre-existing API behavior.

There is a change in behavior from this refactoring: the nested form of
interrupt disabling is used in all gup_fast() variants now.  That's
because there is only one place that interrupt disabling for page walking
is done, and so the safer form is required.  This should, if anything,
eliminate possible (rare) bugs, because the non-nested form of enabling
interrupts was fragile at best.

[jhubbard@nvidia.com: fixup]
  Link: http://lkml.kernel.org/r/20200521233841.1279742-1-jhubbard@nvidia.com
	Signed-off-by: John Hubbard <jhubbard@nvidia.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Daniel Vetter <daniel@ffwll.ch>
	Cc: David Airlie <airlied@linux.ie>
	Cc: Jani Nikula <jani.nikula@linux.intel.com>
	Cc: "Joonas Lahtinen" <joonas.lahtinen@linux.intel.com>
	Cc: Matthew Auld <matthew.auld@intel.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Cc: Souptick Joarder <jrdr.linux@gmail.com>
	Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Link: http://lkml.kernel.org/r/20200519002124.2025955-3-jhubbard@nvidia.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 376a34efa4eeb699d285c1a741b186d44b44c429)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm.h
#	mm/gup.c
diff --cc include/linux/mm.h
index ef77bd76b21c,e6b884715da1..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -2492,13 -2814,17 +2492,19 @@@ struct page *follow_page(struct vm_area
  #define FOLL_COW	0x4000	/* internal GUP flag */
  #define FOLL_ANON	0x8000	/* don't do file mappings */
  #define FOLL_LONGTERM	0x10000	/* mapping lifetime is indefinite: see below */
++<<<<<<< HEAD
++=======
+ #define FOLL_SPLIT_PMD	0x20000	/* split huge pmd before returning */
+ #define FOLL_PIN	0x40000	/* pages must be released via unpin_user_page */
+ #define FOLL_FAST_ONLY	0x80000	/* gup_fast: prevent fall-back to slow gup */
++>>>>>>> 376a34efa4ee (mm/gup: refactor and de-duplicate gup_fast() code)
  
  /*
 - * FOLL_PIN and FOLL_LONGTERM may be used in various combinations with each
 - * other. Here is what they mean, and how to use them:
 + * NOTE on FOLL_LONGTERM:
   *
   * FOLL_LONGTERM indicates that the page will be held for an indefinite time
 - * period _often_ under userspace control.  This is in contrast to
 - * iov_iter_get_pages(), whose usages are transient.
 + * period _often_ under userspace control.  This is contrasted with
 + * iov_iter_get_pages() where usages which are transient.
   *
   * FIXME: For pages which are part of a filesystem, mappings are subject to the
   * lifetime enforced by the filesystem and we need guarantees that longterm
diff --cc mm/gup.c
index b62e810dd644,67b5e96cd2c7..000000000000
--- a/mm/gup.c
+++ b/mm/gup.c
@@@ -2234,30 -2726,17 +2234,39 @@@ static int __gup_longterm_unlocked(unsi
  	return ret;
  }
  
 -static int internal_get_user_pages_fast(unsigned long start, int nr_pages,
 -					unsigned int gup_flags,
 -					struct page **pages)
 +/**
 + * get_user_pages_fast() - pin user pages in memory
 + * @start:	starting user address
 + * @nr_pages:	number of pages from start to pin
 + * @gup_flags:	flags modifying pin behaviour
 + * @pages:	array that receives pointers to the pages pinned.
 + *		Should be at least nr_pages long.
 + *
 + * Attempt to pin user pages in memory without taking mm->mmap_sem.
 + * If not successful, it will fall back to taking the lock and
 + * calling get_user_pages().
 + *
 + * Returns number of pages pinned. This may be fewer than the number
 + * requested. If nr_pages is 0 or negative, returns 0. If no pages
 + * were pinned, returns -errno.
 + */
 +int get_user_pages_fast(unsigned long start, int nr_pages,
 +			unsigned int gup_flags, struct page **pages)
  {
  	unsigned long addr, len, end;
++<<<<<<< HEAD
 +	int nr = 0, ret = 0;
 +
 +	if (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |
 +				       FOLL_FORCE)))
++=======
+ 	unsigned long flags;
+ 	int nr_pinned = 0, ret = 0;
+ 
+ 	if (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |
+ 				       FOLL_FORCE | FOLL_PIN | FOLL_GET |
+ 				       FOLL_FAST_ONLY)))
++>>>>>>> 376a34efa4ee (mm/gup: refactor and de-duplicate gup_fast() code)
  		return -EINVAL;
  
  	start = untagged_addr(start) & PAGE_MASK;
@@@ -2270,19 -2749,47 +2279,58 @@@
  	if (unlikely(!access_ok((void __user *)start, len)))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	if (gup_fast_permitted(start, end)) {
 +		local_irq_disable();
 +		gup_pgd_range(addr, end, gup_flags, pages, &nr);
 +		local_irq_enable();
 +		ret = nr;
 +	}
 +
 +	if (nr < nr_pages) {
++=======
+ 	/*
+ 	 * The FAST_GUP case requires FOLL_WRITE even for pure reads,
+ 	 * because get_user_pages() may need to cause an early COW in
+ 	 * order to avoid confusing the normal COW routines. So only
+ 	 * targets that are already writable are safe to do by just
+ 	 * looking at the page tables.
+ 	 *
+ 	 * NOTE! With FOLL_FAST_ONLY we allow read-only gup_fast() here,
+ 	 * because there is no slow path to fall back on. But you'd
+ 	 * better be careful about possible COW pages - you'll get _a_
+ 	 * COW page, but not necessarily the one you intended to get
+ 	 * depending on what COW event happens after this. COW may break
+ 	 * the page copy in a random direction.
+ 	 *
+ 	 * Disable interrupts. The nested form is used, in order to allow
+ 	 * full, general purpose use of this routine.
+ 	 *
+ 	 * With interrupts disabled, we block page table pages from being
+ 	 * freed from under us. See struct mmu_table_batch comments in
+ 	 * include/asm-generic/tlb.h for more details.
+ 	 *
+ 	 * We do not adopt an rcu_read_lock(.) here as we also want to
+ 	 * block IPIs that come from THPs splitting.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) && gup_fast_permitted(start, end)) {
+ 		unsigned long fast_flags = gup_flags;
+ 		if (!(gup_flags & FOLL_FAST_ONLY))
+ 			fast_flags |= FOLL_WRITE;
+ 
+ 		local_irq_save(flags);
+ 		gup_pgd_range(addr, end, fast_flags, pages, &nr_pinned);
+ 		local_irq_restore(flags);
+ 		ret = nr_pinned;
+ 	}
+ 
+ 	if (nr_pinned < nr_pages && !(gup_flags & FOLL_FAST_ONLY)) {
++>>>>>>> 376a34efa4ee (mm/gup: refactor and de-duplicate gup_fast() code)
  		/* Try to get the remaining pages with get_user_pages */
 -		start += nr_pinned << PAGE_SHIFT;
 -		pages += nr_pinned;
 +		start += nr << PAGE_SHIFT;
 +		pages += nr;
  
 -		ret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,
 +		ret = __gup_longterm_unlocked(start, nr_pages - nr,
  					      gup_flags, pages);
  
  		/* Have to be a bit careful with return values */
@@@ -2297,4 -2804,210 +2345,214 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +#endif /* CONFIG_HAVE_GENERIC_GUP */
++=======
+ /*
+  * Like get_user_pages_fast() except it's IRQ-safe in that it won't fall back to
+  * the regular GUP.
+  * Note a difference with get_user_pages_fast: this always returns the
+  * number of pages pinned, 0 if no pages were pinned.
+  *
+  * If the architecture does not support this function, simply return with no
+  * pages pinned.
+  *
+  * Careful, careful! COW breaking can go either way, so a non-write
+  * access can get ambiguous page results. If you call this function without
+  * 'write' set, you'd better be sure that you're ok with that ambiguity.
+  */
+ int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
+ 			  struct page **pages)
+ {
+ 	int nr_pinned;
+ 	/*
+ 	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
+ 	 * because gup fast is always a "pin with a +1 page refcount" request.
+ 	 *
+ 	 * FOLL_FAST_ONLY is required in order to match the API description of
+ 	 * this routine: no fall back to regular ("slow") GUP.
+ 	 */
+ 	unsigned int gup_flags = FOLL_GET | FOLL_FAST_ONLY;
+ 
+ 	if (write)
+ 		gup_flags |= FOLL_WRITE;
+ 
+ 	nr_pinned = internal_get_user_pages_fast(start, nr_pages, gup_flags,
+ 						 pages);
+ 
+ 	/*
+ 	 * As specified in the API description above, this routine is not
+ 	 * allowed to return negative values. However, the common core
+ 	 * routine internal_get_user_pages_fast() *can* return -errno.
+ 	 * Therefore, correct for that here:
+ 	 */
+ 	if (nr_pinned < 0)
+ 		nr_pinned = 0;
+ 
+ 	return nr_pinned;
+ }
+ EXPORT_SYMBOL_GPL(__get_user_pages_fast);
+ 
+ /**
+  * get_user_pages_fast() - pin user pages in memory
+  * @start:      starting user address
+  * @nr_pages:   number of pages from start to pin
+  * @gup_flags:  flags modifying pin behaviour
+  * @pages:      array that receives pointers to the pages pinned.
+  *              Should be at least nr_pages long.
+  *
+  * Attempt to pin user pages in memory without taking mm->mmap_sem.
+  * If not successful, it will fall back to taking the lock and
+  * calling get_user_pages().
+  *
+  * Returns number of pages pinned. This may be fewer than the number requested.
+  * If nr_pages is 0 or negative, returns 0. If no pages were pinned, returns
+  * -errno.
+  */
+ int get_user_pages_fast(unsigned long start, int nr_pages,
+ 			unsigned int gup_flags, struct page **pages)
+ {
+ 	/*
+ 	 * FOLL_PIN must only be set internally by the pin_user_pages*() APIs,
+ 	 * never directly by the caller, so enforce that:
+ 	 */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_PIN))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * The caller may or may not have explicitly set FOLL_GET; either way is
+ 	 * OK. However, internally (within mm/gup.c), gup fast variants must set
+ 	 * FOLL_GET, because gup fast is always a "pin with a +1 page refcount"
+ 	 * request.
+ 	 */
+ 	gup_flags |= FOLL_GET;
+ 	return internal_get_user_pages_fast(start, nr_pages, gup_flags, pages);
+ }
+ EXPORT_SYMBOL_GPL(get_user_pages_fast);
+ 
+ /**
+  * pin_user_pages_fast() - pin user pages in memory without taking locks
+  *
+  * @start:      starting user address
+  * @nr_pages:   number of pages from start to pin
+  * @gup_flags:  flags modifying pin behaviour
+  * @pages:      array that receives pointers to the pages pinned.
+  *              Should be at least nr_pages long.
+  *
+  * Nearly the same as get_user_pages_fast(), except that FOLL_PIN is set. See
+  * get_user_pages_fast() for documentation on the function arguments, because
+  * the arguments here are identical.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for further details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ int pin_user_pages_fast(unsigned long start, int nr_pages,
+ 			unsigned int gup_flags, struct page **pages)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return internal_get_user_pages_fast(start, nr_pages, gup_flags, pages);
+ }
+ EXPORT_SYMBOL_GPL(pin_user_pages_fast);
+ 
+ /**
+  * pin_user_pages_remote() - pin pages of a remote process (task != current)
+  *
+  * @tsk:	the task_struct to use for page fault accounting, or
+  *		NULL if faults are not to be recorded.
+  * @mm:		mm_struct of target mm
+  * @start:	starting user address
+  * @nr_pages:	number of pages from start to pin
+  * @gup_flags:	flags modifying lookup behaviour
+  * @pages:	array that receives pointers to the pages pinned.
+  *		Should be at least nr_pages long. Or NULL, if caller
+  *		only intends to ensure the pages are faulted in.
+  * @vmas:	array of pointers to vmas corresponding to each page.
+  *		Or NULL if the caller does not require them.
+  * @locked:	pointer to lock flag indicating whether lock is held and
+  *		subsequently whether VM_FAULT_RETRY functionality can be
+  *		utilised. Lock must initially be held.
+  *
+  * Nearly the same as get_user_pages_remote(), except that FOLL_PIN is set. See
+  * get_user_pages_remote() for documentation on the function arguments, because
+  * the arguments here are identical.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ long pin_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
+ 			   unsigned long start, unsigned long nr_pages,
+ 			   unsigned int gup_flags, struct page **pages,
+ 			   struct vm_area_struct **vmas, int *locked)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return __get_user_pages_remote(tsk, mm, start, nr_pages, gup_flags,
+ 				       pages, vmas, locked);
+ }
+ EXPORT_SYMBOL(pin_user_pages_remote);
+ 
+ /**
+  * pin_user_pages() - pin user pages in memory for use by other devices
+  *
+  * @start:	starting user address
+  * @nr_pages:	number of pages from start to pin
+  * @gup_flags:	flags modifying lookup behaviour
+  * @pages:	array that receives pointers to the pages pinned.
+  *		Should be at least nr_pages long. Or NULL, if caller
+  *		only intends to ensure the pages are faulted in.
+  * @vmas:	array of pointers to vmas corresponding to each page.
+  *		Or NULL if the caller does not require them.
+  *
+  * Nearly the same as get_user_pages(), except that FOLL_TOUCH is not set, and
+  * FOLL_PIN is set.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ long pin_user_pages(unsigned long start, unsigned long nr_pages,
+ 		    unsigned int gup_flags, struct page **pages,
+ 		    struct vm_area_struct **vmas)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return __gup_longterm_locked(current, current->mm, start, nr_pages,
+ 				     pages, vmas, gup_flags);
+ }
+ EXPORT_SYMBOL(pin_user_pages);
+ 
+ /*
+  * pin_user_pages_unlocked() is the FOLL_PIN variant of
+  * get_user_pages_unlocked(). Behavior is the same, except that this one sets
+  * FOLL_PIN and rejects FOLL_GET.
+  */
+ long pin_user_pages_unlocked(unsigned long start, unsigned long nr_pages,
+ 			     struct page **pages, unsigned int gup_flags)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return get_user_pages_unlocked(start, nr_pages, pages, gup_flags);
+ }
+ EXPORT_SYMBOL(pin_user_pages_unlocked);
++>>>>>>> 376a34efa4ee (mm/gup: refactor and de-duplicate gup_fast() code)
* Unmerged path include/linux/mm.h
* Unmerged path mm/gup.c
