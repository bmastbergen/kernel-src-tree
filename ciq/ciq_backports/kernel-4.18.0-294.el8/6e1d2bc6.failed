intel_idle: Fix intel_idle() vs tracing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 6e1d2bc675bd57640f5658a4a657ae488db4c204
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6e1d2bc6.failed

cpuidle->enter() callbacks should not call into tracing because RCU
has already been disabled. Instead of doing the broadcast thing
itself, simply advertise to the cpuidle core that those states stop
the timer.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Link: https://lkml.kernel.org/r/20201123143510.GR3021@hirez.programming.kicks-ass.net
(cherry picked from commit 6e1d2bc675bd57640f5658a4a657ae488db4c204)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/idle/intel_idle.c
diff --cc drivers/idle/intel_idle.c
index 7a873b077402,7ee7ffe22ae3..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -127,6 -103,58 +127,61 @@@ static struct cpuidle_state *cpuidle_st
  #define flg2MWAIT(flags) (((flags) >> 24) & 0xFF)
  #define MWAIT2flg(eax) ((eax & 0xFF) << 24)
  
++<<<<<<< HEAD
++=======
+ /**
+  * intel_idle - Ask the processor to enter the given idle state.
+  * @dev: cpuidle device of the target CPU.
+  * @drv: cpuidle driver (assumed to point to intel_idle_driver).
+  * @index: Target idle state index.
+  *
+  * Use the MWAIT instruction to notify the processor that the CPU represented by
+  * @dev is idle and it can try to enter the idle state corresponding to @index.
+  *
+  * If the local APIC timer is not known to be reliable in the target idle state,
+  * enable one-shot tick broadcasting for the target CPU before executing MWAIT.
+  *
+  * Optionally call leave_mm() for the target CPU upfront to avoid wakeups due to
+  * flushing user TLBs.
+  *
+  * Must be called under local_irq_disable().
+  */
+ static __cpuidle int intel_idle(struct cpuidle_device *dev,
+ 				struct cpuidle_driver *drv, int index)
+ {
+ 	struct cpuidle_state *state = &drv->states[index];
+ 	unsigned long eax = flg2MWAIT(state->flags);
+ 	unsigned long ecx = 1; /* break on interrupt flag */
+ 
+ 	mwait_idle_with_hints(eax, ecx);
+ 
+ 	return index;
+ }
+ 
+ /**
+  * intel_idle_s2idle - Ask the processor to enter the given idle state.
+  * @dev: cpuidle device of the target CPU.
+  * @drv: cpuidle driver (assumed to point to intel_idle_driver).
+  * @index: Target idle state index.
+  *
+  * Use the MWAIT instruction to notify the processor that the CPU represented by
+  * @dev is idle and it can try to enter the idle state corresponding to @index.
+  *
+  * Invoked as a suspend-to-idle callback routine with frozen user space, frozen
+  * scheduler tick and suspended scheduler clock on the target CPU.
+  */
+ static __cpuidle int intel_idle_s2idle(struct cpuidle_device *dev,
+ 				       struct cpuidle_driver *drv, int index)
+ {
+ 	unsigned long eax = flg2MWAIT(drv->states[index].flags);
+ 	unsigned long ecx = 1; /* break on interrupt flag */
+ 
+ 	mwait_idle_with_hints(eax, ecx);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 6e1d2bc675bd (intel_idle: Fix intel_idle() vs tracing)
  /*
   * States are indexed by the cstate number,
   * which is also the index into the MWAIT hint array.
@@@ -1257,7 -1210,21 +1312,25 @@@ static bool intel_idle_acpi_cst_extract
  	return false;
  }
  
++<<<<<<< HEAD
 +static void intel_idle_init_cstates_acpi(struct cpuidle_driver *drv)
++=======
+ static bool __init intel_idle_state_needs_timer_stop(struct cpuidle_state *state)
+ {
+ 	unsigned long eax = flg2MWAIT(state->flags);
+ 
+ 	if (boot_cpu_has(X86_FEATURE_ARAT))
+ 		return false;
+ 
+ 	/*
+ 	 * Switch over to one-shot tick broadcast if the target C-state
+ 	 * is deeper than C1.
+ 	 */
+ 	return !!((eax >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK);
+ }
+ 
+ static void __init intel_idle_init_cstates_acpi(struct cpuidle_driver *drv)
++>>>>>>> 6e1d2bc675bd (intel_idle: Fix intel_idle() vs tracing)
  {
  	int cstate, limit = min_t(int, CPUIDLE_STATE_MAX, acpi_state_table.count);
  
@@@ -1296,6 -1263,12 +1369,15 @@@
  		if (cx->type > ACPI_STATE_C2)
  			state->flags |= CPUIDLE_FLAG_TLB_FLUSHED;
  
++<<<<<<< HEAD
++=======
+ 		if (disabled_states_mask & BIT(cstate))
+ 			state->flags |= CPUIDLE_FLAG_OFF;
+ 
+ 		if (intel_idle_state_needs_timer_stop(state))
+ 			state->flags |= CPUIDLE_FLAG_TIMER_STOP;
+ 
++>>>>>>> 6e1d2bc675bd (intel_idle: Fix intel_idle() vs tracing)
  		state->enter = intel_idle;
  		state->enter_s2idle = intel_idle_s2idle;
  	}
@@@ -1576,11 -1501,15 +1658,14 @@@ static void intel_idle_init_cstates_icp
  		/* Structure copy. */
  		drv->states[drv->state_count] = cpuidle_state_table[cstate];
  
 -		if ((disabled_states_mask & BIT(drv->state_count)) ||
 -		    ((icpu->use_acpi || force_use_acpi) &&
 -		     intel_idle_off_by_default(mwait_hint) &&
 -		     !(cpuidle_state_table[cstate].flags & CPUIDLE_FLAG_ALWAYS_ENABLE)))
 +		if ((icpu->use_acpi && force_use_acpi) &&
 +		    intel_idle_off_by_default(mwait_hint) &&
 +		    !(cpuidle_state_table[cstate].flags & CPUIDLE_FLAG_ALWAYS_ENABLE))
  			drv->states[drv->state_count].flags |= CPUIDLE_FLAG_OFF;
  
+ 		if (intel_idle_state_needs_timer_stop(&drv->states[drv->state_count]))
+ 			drv->states[drv->state_count].flags |= CPUIDLE_FLAG_TIMER_STOP;
+ 
  		drv->state_count++;
  	}
  
* Unmerged path drivers/idle/intel_idle.c
