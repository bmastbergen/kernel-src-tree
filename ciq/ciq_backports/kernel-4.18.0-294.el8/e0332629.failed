s390/ap/zcrypt: revisit ap and zcrypt error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit e0332629e33d1926c93348d918aaaf451ef9a16b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e0332629.failed

Revisit the ap queue error handling: Based on discussions and
evaluatios with the firmware folk here is now a rework of the response
code handling for all the AP instructions. The idea is to distinguish
between failures because of some kind of invalid request where a retry
does not make any sense and a failure where another attempt to send
the very same request may succeed. The first case is handled by
returning EINVAL to the userspace application. The second case results
in retries within the zcrypt API controlled by a per message retry
counter.

Revisit the zcrpyt error handling: Similar here, based on discussions
with the firmware people here comes a rework of the handling of all
the reply codes.  Main point here is that there are only very few
cases left, where a zcrypt device queue is switched to offline. It
should never be the case that an AP reply message is 'unknown' to the
device driver as it indicates a total mismatch between device driver
and crypto card firmware. In all other cases, the code distinguishes
between failure because of invalid message (see above - EINVAL) or
failures of the infrastructure (see above - EAGAIN).

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit e0332629e33d1926c93348d918aaaf451ef9a16b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_queue.c
#	drivers/s390/crypto/zcrypt_msgtype6.c
diff --cc drivers/s390/crypto/ap_queue.c
index 7bd5294989aa,ada37f1c7ac7..000000000000
--- a/drivers/s390/crypto/ap_queue.c
+++ b/drivers/s390/crypto/ap_queue.c
@@@ -252,16 -231,19 +252,24 @@@ static enum ap_wait ap_sm_write(struct 
  		aq->requestq_count--;
  		aq->pendingq_count++;
  		if (aq->queue_count < aq->card->queue_depth) {
 -			aq->sm_state = AP_SM_STATE_WORKING;
 -			return AP_SM_WAIT_AGAIN;
 +			aq->state = AP_STATE_WORKING;
 +			return AP_WAIT_AGAIN;
  		}
 -		fallthrough;
 +		/* fall through */
  	case AP_RESPONSE_Q_FULL:
 -		aq->sm_state = AP_SM_STATE_QUEUE_FULL;
 -		return AP_SM_WAIT_INTERRUPT;
 +		aq->state = AP_STATE_QUEUE_FULL;
 +		return AP_WAIT_INTERRUPT;
  	case AP_RESPONSE_RESET_IN_PROGRESS:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_RESET_WAIT;
 +		return AP_WAIT_TIMEOUT;
++=======
+ 		aq->sm_state = AP_SM_STATE_RESET_WAIT;
+ 		return AP_SM_WAIT_TIMEOUT;
+ 	case AP_RESPONSE_INVALID_DOMAIN:
+ 		AP_DBF(DBF_WARN, "AP_RESPONSE_INVALID_DOMAIN on NQAP\n");
+ 		fallthrough;
++>>>>>>> e0332629e33d (s390/ap/zcrypt: revisit ap and zcrypt error handling)
  	case AP_RESPONSE_MESSAGE_TOO_BIG:
  	case AP_RESPONSE_REQ_FAC_NOT_INST:
  		list_del_init(&ap_msg->list);
@@@ -300,17 -286,16 +308,21 @@@ static enum ap_wait ap_sm_reset(struct 
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  	case AP_RESPONSE_RESET_IN_PROGRESS:
 -		aq->sm_state = AP_SM_STATE_RESET_WAIT;
 +		aq->state = AP_STATE_RESET_WAIT;
  		aq->interrupt = AP_INTR_DISABLED;
++<<<<<<< HEAD
 +		return AP_WAIT_TIMEOUT;
 +	case AP_RESPONSE_BUSY:
 +		return AP_WAIT_TIMEOUT;
 +	case AP_RESPONSE_Q_NOT_AVAIL:
 +	case AP_RESPONSE_DECONFIGURED:
 +	case AP_RESPONSE_CHECKSTOPPED:
++=======
+ 		return AP_SM_WAIT_TIMEOUT;
++>>>>>>> e0332629e33d (s390/ap/zcrypt: revisit ap and zcrypt error handling)
  	default:
 -		aq->dev_state = AP_DEV_STATE_ERROR;
 -		aq->last_err_rc = status.response_code;
 -		AP_DBF_WARN("%s RC 0x%02hhx on 0x%02x.%04x -> AP_DEV_STATE_ERROR\n",
 -			    __func__, status.response_code,
 -			    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));
 -		return AP_SM_WAIT_NONE;
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
  	}
  }
  
diff --cc drivers/s390/crypto/zcrypt_msgtype6.c
index 3c73516880c9,30eaa7a7aede..000000000000
--- a/drivers/s390/crypto/zcrypt_msgtype6.c
+++ b/drivers/s390/crypto/zcrypt_msgtype6.c
@@@ -799,18 -798,19 +798,24 @@@ static int convert_response_ica(struct 
  		if (msg->cprbx.cprb_ver_id == 0x02)
  			return convert_type86_ica(zq, reply,
  						  outputdata, outputdatalength);
++<<<<<<< HEAD
 +		/* fall through - wrong cprb version is an unknown response */
 +	default: /* Unknown response type, this should NEVER EVER happen */
++=======
+ 		fallthrough;	/* wrong cprb version is an unknown response */
+ 	default:
+ 		/* Unknown response type, this should NEVER EVER happen */
++>>>>>>> e0332629e33d (s390/ap/zcrypt: revisit ap and zcrypt error handling)
  		zq->online = 0;
- 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		pr_err("Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
  		       AP_QID_CARD(zq->queue->qid),
- 		       AP_QID_QUEUE(zq->queue->qid));
- 		ZCRYPT_DBF(DBF_ERR,
- 			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
- 			   AP_QID_CARD(zq->queue->qid),
- 			   AP_QID_QUEUE(zq->queue->qid),
- 			   (int) msg->hdr.type);
- 		return -EAGAIN;	/* repeat the request on a different device. */
+ 		       AP_QID_QUEUE(zq->queue->qid),
+ 		       (int) msg->hdr.type);
+ 		ZCRYPT_DBF_ERR("dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
+ 			       AP_QID_CARD(zq->queue->qid),
+ 			       AP_QID_QUEUE(zq->queue->qid),
+ 			       (int) msg->hdr.type);
+ 		return -EAGAIN;
  	}
  }
  
@@@ -861,19 -861,19 +866,19 @@@ static int convert_response_ep11_xcrb(s
  		if (msg->hdr.reply_code)
  			return convert_error(zq, reply);
  		if (msg->cprbx.cprb_ver_id == 0x04)
 -			return convert_type86_ep11_xcrb(userspace, zq, reply, xcRB);
 -		fallthrough;	/* wrong cprb version is an unknown resp */
 +			return convert_type86_ep11_xcrb(zq, reply, xcRB);
 +		/* fall through - wrong cprb version is an unknown resp */
  	default: /* Unknown response type, this should NEVER EVER happen */
  		zq->online = 0;
- 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		pr_err("Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
  		       AP_QID_CARD(zq->queue->qid),
- 		       AP_QID_QUEUE(zq->queue->qid));
- 		ZCRYPT_DBF(DBF_ERR,
- 			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
- 			   AP_QID_CARD(zq->queue->qid),
- 			   AP_QID_QUEUE(zq->queue->qid),
- 			   (int) msg->hdr.type);
- 		return -EAGAIN; /* repeat the request on a different device. */
+ 		       AP_QID_QUEUE(zq->queue->qid),
+ 		       (int) msg->hdr.type);
+ 		ZCRYPT_DBF_ERR("dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
+ 			       AP_QID_CARD(zq->queue->qid),
+ 			       AP_QID_QUEUE(zq->queue->qid),
+ 			       (int) msg->hdr.type);
+ 		return -EAGAIN;
  	}
  }
  
@@@ -892,18 -892,18 +897,18 @@@ static int convert_response_rng(struct 
  			return -EINVAL;
  		if (msg->cprbx.cprb_ver_id == 0x02)
  			return convert_type86_rng(zq, reply, data);
 -		fallthrough;	/* wrong cprb version is an unknown response */
 +		/* fall through - wrong cprb version is an unknown response */
  	default: /* Unknown response type, this should NEVER EVER happen */
  		zq->online = 0;
- 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		pr_err("Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
  		       AP_QID_CARD(zq->queue->qid),
- 		       AP_QID_QUEUE(zq->queue->qid));
- 		ZCRYPT_DBF(DBF_ERR,
- 			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
- 			   AP_QID_CARD(zq->queue->qid),
- 			   AP_QID_QUEUE(zq->queue->qid),
- 			   (int) msg->hdr.type);
- 		return -EAGAIN;	/* repeat the request on a different device. */
+ 		       AP_QID_QUEUE(zq->queue->qid),
+ 		       (int) msg->hdr.type);
+ 		ZCRYPT_DBF_ERR("dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
+ 			       AP_QID_CARD(zq->queue->qid),
+ 			       AP_QID_QUEUE(zq->queue->qid),
+ 			       (int) msg->hdr.type);
+ 		return -EAGAIN;
  	}
  }
  
diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 0a20eede0143..65bdc203daaf 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -50,6 +50,7 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_RESPONSE_NO_FIRST_PART	0x13
 #define AP_RESPONSE_MESSAGE_TOO_BIG	0x15
 #define AP_RESPONSE_REQ_FAC_NOT_INST	0x16
+#define AP_RESPONSE_INVALID_DOMAIN	0x42
 
 /*
  * Known device types
* Unmerged path drivers/s390/crypto/ap_queue.c
diff --git a/drivers/s390/crypto/zcrypt_debug.h b/drivers/s390/crypto/zcrypt_debug.h
index 241dbb5f75bf..3225489a1c41 100644
--- a/drivers/s390/crypto/zcrypt_debug.h
+++ b/drivers/s390/crypto/zcrypt_debug.h
@@ -21,6 +21,14 @@
 
 #define ZCRYPT_DBF(...)					\
 	debug_sprintf_event(zcrypt_dbf_info, ##__VA_ARGS__)
+#define ZCRYPT_DBF_ERR(...)					\
+	debug_sprintf_event(zcrypt_dbf_info, DBF_ERR, ##__VA_ARGS__)
+#define ZCRYPT_DBF_WARN(...)					\
+	debug_sprintf_event(zcrypt_dbf_info, DBF_WARN, ##__VA_ARGS__)
+#define ZCRYPT_DBF_INFO(...)					\
+	debug_sprintf_event(zcrypt_dbf_info, DBF_INFO, ##__VA_ARGS__)
+#define ZCRYPT_DBF_DBG(...)					\
+	debug_sprintf_event(zcrypt_dbf_info, DBF_DEBUG, ##__VA_ARGS__)
 
 extern debug_info_t *zcrypt_dbf_info;
 
diff --git a/drivers/s390/crypto/zcrypt_error.h b/drivers/s390/crypto/zcrypt_error.h
index 54a04f8c38ef..39e626e3a379 100644
--- a/drivers/s390/crypto/zcrypt_error.h
+++ b/drivers/s390/crypto/zcrypt_error.h
@@ -52,7 +52,6 @@ struct error_hdr {
 #define REP82_ERROR_INVALID_COMMAND	    0x30
 #define REP82_ERROR_MALFORMED_MSG	    0x40
 #define REP82_ERROR_INVALID_SPECIAL_CMD	    0x41
-#define REP82_ERROR_INVALID_DOMAIN_PRECHECK 0x42
 #define REP82_ERROR_RESERVED_FIELDO	    0x50 /* old value	*/
 #define REP82_ERROR_WORD_ALIGNMENT	    0x60
 #define REP82_ERROR_MESSAGE_LENGTH	    0x80
@@ -67,7 +66,6 @@ struct error_hdr {
 #define REP82_ERROR_ZERO_BUFFER_LEN	    0xB0
 
 #define REP88_ERROR_MODULE_FAILURE	    0x10
-
 #define REP88_ERROR_MESSAGE_TYPE	    0x20
 #define REP88_ERROR_MESSAGE_MALFORMD	    0x22
 #define REP88_ERROR_MESSAGE_LENGTH	    0x23
@@ -85,78 +83,56 @@ static inline int convert_error(struct zcrypt_queue *zq,
 	int queue = AP_QID_QUEUE(zq->queue->qid);
 
 	switch (ehdr->reply_code) {
-	case REP82_ERROR_OPERAND_INVALID:
-	case REP82_ERROR_OPERAND_SIZE:
-	case REP82_ERROR_EVEN_MOD_IN_OPND:
-	case REP88_ERROR_MESSAGE_MALFORMD:
-	case REP82_ERROR_INVALID_DOMAIN_PRECHECK:
-	case REP82_ERROR_INVALID_DOMAIN_PENDING:
-	case REP82_ERROR_INVALID_SPECIAL_CMD:
-	case REP82_ERROR_FILTERED_BY_HYPERVISOR:
-	//   REP88_ERROR_INVALID_KEY		// '82' CEX2A
-	//   REP88_ERROR_OPERAND		// '84' CEX2A
-	//   REP88_ERROR_OPERAND_EVEN_MOD	// '85' CEX2A
-		/* Invalid input data. */
+	case REP82_ERROR_INVALID_MSG_LEN:	 /* 0x23 */
+	case REP82_ERROR_RESERVD_FIELD:		 /* 0x24 */
+	case REP82_ERROR_FORMAT_FIELD:		 /* 0x29 */
+	case REP82_ERROR_MALFORMED_MSG:		 /* 0x40 */
+	case REP82_ERROR_INVALID_SPECIAL_CMD:	 /* 0x41 */
+	case REP82_ERROR_MESSAGE_LENGTH:	 /* 0x80 */
+	case REP82_ERROR_OPERAND_INVALID:	 /* 0x82 */
+	case REP82_ERROR_OPERAND_SIZE:		 /* 0x84 */
+	case REP82_ERROR_EVEN_MOD_IN_OPND:	 /* 0x85 */
+	case REP82_ERROR_INVALID_DOMAIN_PENDING: /* 0x8A */
+	case REP82_ERROR_FILTERED_BY_HYPERVISOR: /* 0x8B */
+	case REP82_ERROR_PACKET_TRUNCATED:	 /* 0xA0 */
+	case REP88_ERROR_MESSAGE_MALFORMD:	 /* 0x22 */
+	case REP88_ERROR_KEY_TYPE:		 /* 0x34 */
+		/* RY indicates malformed request */
 		ZCRYPT_DBF(DBF_WARN,
-			   "device=%02x.%04x reply=0x%02x => rc=EINVAL\n",
+			   "dev=%02x.%04x RY=0x%02x => rc=EINVAL\n",
 			   card, queue, ehdr->reply_code);
 		return -EINVAL;
-	case REP82_ERROR_MESSAGE_TYPE:
-	//   REP88_ERROR_MESSAGE_TYPE		// '20' CEX2A
+	case REP82_ERROR_MACHINE_FAILURE:	 /* 0x10 */
+	case REP82_ERROR_MESSAGE_TYPE:		 /* 0x20 */
+	case REP82_ERROR_TRANSPORT_FAIL:	 /* 0x90 */
 		/*
-		 * To sent a message of the wrong type is a bug in the
-		 * device driver. Send error msg, disable the device
-		 * and then repeat the request.
+		 * Msg to wrong type or card/infrastructure failure.
+		 * Trigger rescan of the ap bus, trigger retry request.
 		 */
 		atomic_set(&zcrypt_rescan_req, 1);
-		zq->online = 0;
-		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
-		       card, queue);
-		ZCRYPT_DBF(DBF_ERR,
-			   "device=%02x.%04x reply=0x%02x => online=0 rc=EAGAIN\n",
-			   card, queue, ehdr->reply_code);
-		return -EAGAIN;
-	case REP82_ERROR_TRANSPORT_FAIL:
-		/* Card or infrastructure failure, disable card */
-		atomic_set(&zcrypt_rescan_req, 1);
-		zq->online = 0;
-		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
-		       card, queue);
 		/* For type 86 response show the apfs value (failure reason) */
-		if (ehdr->type == TYPE86_RSP_CODE) {
+		if (ehdr->reply_code == REP82_ERROR_TRANSPORT_FAIL &&
+		    ehdr->type == TYPE86_RSP_CODE) {
 			struct {
 				struct type86_hdr hdr;
 				struct type86_fmt2_ext fmt2;
 			} __packed * head = reply->msg;
 			unsigned int apfs = *((u32 *)head->fmt2.apfs);
 
-			ZCRYPT_DBF(DBF_ERR,
-				   "device=%02x.%04x reply=0x%02x apfs=0x%x => online=0 rc=EAGAIN\n",
-				   card, queue, apfs, ehdr->reply_code);
+			ZCRYPT_DBF(DBF_WARN,
+				   "dev=%02x.%04x RY=0x%02x apfs=0x%x => bus rescan, rc=EAGAIN\n",
+				   card, queue, ehdr->reply_code, apfs);
 		} else
-			ZCRYPT_DBF(DBF_ERR,
-				   "device=%02x.%04x reply=0x%02x => online=0 rc=EAGAIN\n",
+			ZCRYPT_DBF(DBF_WARN,
+				   "dev=%02x.%04x RY=0x%02x => bus rescan, rc=EAGAIN\n",
 				   card, queue, ehdr->reply_code);
 		return -EAGAIN;
-	case REP82_ERROR_MACHINE_FAILURE:
-	//   REP88_ERROR_MODULE_FAILURE		// '10' CEX2A
-		/* If a card fails disable it and repeat the request. */
-		atomic_set(&zcrypt_rescan_req, 1);
-		zq->online = 0;
-		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
-		       card, queue);
-		ZCRYPT_DBF(DBF_ERR,
-			   "device=%02x.%04x reply=0x%02x => online=0 rc=EAGAIN\n",
-			   card, queue, ehdr->reply_code);
-		return -EAGAIN;
 	default:
-		zq->online = 0;
-		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
-		       card, queue);
-		ZCRYPT_DBF(DBF_ERR,
-			   "device=%02x.%04x reply=0x%02x => online=0 rc=EAGAIN\n",
+		/* Assume request is valid and a retry will be worth it */
+		ZCRYPT_DBF(DBF_WARN,
+			   "dev=%02x.%04x RY=0x%02x => rc=EAGAIN\n",
 			   card, queue, ehdr->reply_code);
-		return -EAGAIN;	/* repeat the request on a different device. */
+		return -EAGAIN;
 	}
 }
 
diff --git a/drivers/s390/crypto/zcrypt_msgtype50.c b/drivers/s390/crypto/zcrypt_msgtype50.c
index 7aedc338b445..88916addd513 100644
--- a/drivers/s390/crypto/zcrypt_msgtype50.c
+++ b/drivers/s390/crypto/zcrypt_msgtype50.c
@@ -356,15 +356,15 @@ static int convert_type80(struct zcrypt_queue *zq,
 	if (t80h->len < sizeof(*t80h) + outputdatalength) {
 		/* The result is too short, the CEXxA card may not do that.. */
 		zq->online = 0;
-		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+		pr_err("Crypto dev=%02x.%04x code=0x%02x => online=0 rc=EAGAIN\n",
 		       AP_QID_CARD(zq->queue->qid),
-		       AP_QID_QUEUE(zq->queue->qid));
-		ZCRYPT_DBF(DBF_ERR,
-			   "device=%02x.%04x code=0x%02x => online=0 rc=EAGAIN\n",
-			   AP_QID_CARD(zq->queue->qid),
-			   AP_QID_QUEUE(zq->queue->qid),
-			   t80h->code);
-		return -EAGAIN;	/* repeat the request on a different device. */
+		       AP_QID_QUEUE(zq->queue->qid),
+		       t80h->code);
+		ZCRYPT_DBF_ERR("dev=%02x.%04x code=0x%02x => online=0 rc=EAGAIN\n",
+			       AP_QID_CARD(zq->queue->qid),
+			       AP_QID_QUEUE(zq->queue->qid),
+			       t80h->code);
+		return -EAGAIN;
 	}
 	if (zq->zcard->user_space_type == ZCRYPT_CEX2A)
 		BUG_ON(t80h->len > CEX2A_MAX_RESPONSE_SIZE);
@@ -376,10 +376,10 @@ static int convert_type80(struct zcrypt_queue *zq,
 	return 0;
 }
 
-static int convert_response(struct zcrypt_queue *zq,
-			    struct ap_message *reply,
-			    char __user *outputdata,
-			    unsigned int outputdatalength)
+static int convert_response_cex2a(struct zcrypt_queue *zq,
+				  struct ap_message *reply,
+				  char __user *outputdata,
+				  unsigned int outputdatalength)
 {
 	/* Response type byte is the second byte in the response. */
 	unsigned char rtype = ((unsigned char *) reply->msg)[1];
@@ -393,15 +393,15 @@ static int convert_response(struct zcrypt_queue *zq,
 				      outputdata, outputdatalength);
 	default: /* Unknown response type, this should NEVER EVER happen */
 		zq->online = 0;
-		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+		pr_err("Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
 		       AP_QID_CARD(zq->queue->qid),
-		       AP_QID_QUEUE(zq->queue->qid));
-		ZCRYPT_DBF(DBF_ERR,
-			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
-			   AP_QID_CARD(zq->queue->qid),
-			   AP_QID_QUEUE(zq->queue->qid),
-			   (unsigned int) rtype);
-		return -EAGAIN;	/* repeat the request on a different device. */
+		       AP_QID_QUEUE(zq->queue->qid),
+		       (int) rtype);
+		ZCRYPT_DBF_ERR("dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\n",
+			       AP_QID_CARD(zq->queue->qid),
+			       AP_QID_QUEUE(zq->queue->qid),
+			       (int) rtype);
+		return -EAGAIN;
 	}
 }
 
@@ -476,8 +476,9 @@ static long zcrypt_cex2a_modexpo(struct zcrypt_queue *zq,
 	if (rc == 0) {
 		rc = ap_msg.rc;
 		if (rc == 0)
-			rc = convert_response(zq, &ap_msg, mex->outputdata,
-					      mex->outputdatalength);
+			rc = convert_response_cex2a(zq, &ap_msg,
+						    mex->outputdata,
+						    mex->outputdatalength);
 	} else
 		/* Signal pending. */
 		ap_cancel_message(zq->queue, &ap_msg);
@@ -520,8 +521,9 @@ static long zcrypt_cex2a_modexpo_crt(struct zcrypt_queue *zq,
 	if (rc == 0) {
 		rc = ap_msg.rc;
 		if (rc == 0)
-			rc = convert_response(zq, &ap_msg, crt->outputdata,
-					      crt->outputdatalength);
+			rc = convert_response_cex2a(zq, &ap_msg,
+						    crt->outputdata,
+						    crt->outputdatalength);
 	} else
 		/* Signal pending. */
 		ap_cancel_message(zq->queue, &ap_msg);
* Unmerged path drivers/s390/crypto/zcrypt_msgtype6.c
