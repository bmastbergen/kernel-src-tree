net: openvswitch: improve the coding style

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] openvswitch: improve the coding style (Eelco Chaudron) [1895862]
Rebuild_FUZZ: 93.67%
commit-author Tonghao Zhang <xiangxia.m.yue@gmail.com>
commit cf3266ad482d1bce2c49b6cd856a3f2d46f65023
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cf3266ad.failed

Not change the logic, just improve the coding style.

	Cc: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: Tonghao Zhang <xiangxia.m.yue@gmail.com>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cf3266ad482d1bce2c49b6cd856a3f2d46f65023)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/datapath.c
#	net/openvswitch/flow_table.c
#	net/openvswitch/vport.c
diff --cc net/openvswitch/datapath.c
index a487d643b4f4,bf701b7a394b..000000000000
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@@ -194,7 -181,8 +194,12 @@@ struct vport *ovs_lookup_vport(const st
  	struct hlist_head *head;
  
  	head = vport_hash_bucket(dp, port_no);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(vport, head, dp_hash_node) {
++=======
+ 	hlist_for_each_entry_rcu(vport, head, dp_hash_node,
+ 				 lockdep_ovsl_is_held()) {
++>>>>>>> cf3266ad482d (net: openvswitch: improve the coding style)
  		if (vport->port_no == port_no)
  			return vport;
  	}
@@@ -2086,7 -2078,8 +2095,12 @@@ static unsigned int ovs_get_max_headroo
  	int i;
  
  	for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) {
++<<<<<<< HEAD
 +		hlist_for_each_entry_rcu(vport, &dp->ports[i], dp_hash_node) {
++=======
+ 		hlist_for_each_entry_rcu(vport, &dp->ports[i], dp_hash_node,
+ 					 lockdep_ovsl_is_held()) {
++>>>>>>> cf3266ad482d (net: openvswitch: improve the coding style)
  			dev = vport->dev;
  			dev_headroom = netdev_get_fwd_headroom(dev);
  			if (dev_headroom > max_headroom)
@@@ -2104,9 -2097,11 +2118,16 @@@ static void ovs_update_headroom(struct 
  	int i;
  
  	dp->max_headroom = new_headroom;
++<<<<<<< HEAD
 +	for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++)
 +		hlist_for_each_entry_rcu(vport, &dp->ports[i], dp_hash_node)
++=======
+ 	for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) {
+ 		hlist_for_each_entry_rcu(vport, &dp->ports[i], dp_hash_node,
+ 					 lockdep_ovsl_is_held())
++>>>>>>> cf3266ad482d (net: openvswitch: improve the coding style)
  			netdev_set_rx_headroom(vport->dev, new_headroom);
+ 	}
  }
  
  static int ovs_vport_cmd_new(struct sk_buff *skb, struct genl_info *info)
@@@ -2567,7 -2556,8 +2588,12 @@@ static int __init dp_init(void
  {
  	int err;
  
++<<<<<<< HEAD
 +	BUILD_BUG_ON(sizeof(struct ovs_skb_cb) > FIELD_SIZEOF(struct sk_buff, cb));
++=======
+ 	BUILD_BUG_ON(sizeof(struct ovs_skb_cb) >
+ 		     sizeof_field(struct sk_buff, cb));
++>>>>>>> cf3266ad482d (net: openvswitch: improve the coding style)
  
  	pr_info("Open vSwitch switching datapath\n");
  
diff --cc net/openvswitch/flow_table.c
index fbf69cf1e332,441f68cf8a13..000000000000
--- a/net/openvswitch/flow_table.c
+++ b/net/openvswitch/flow_table.c
@@@ -725,7 -717,8 +730,12 @@@ static struct sw_flow *masked_flow_look
  	head = find_bucket(ti, hash);
  	(*n_mask_hit)++;
  
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(flow, head, flow_table.node[ti->node_ver]) {
++=======
+ 	hlist_for_each_entry_rcu(flow, head, flow_table.node[ti->node_ver],
+ 				 lockdep_ovsl_is_held()) {
++>>>>>>> cf3266ad482d (net: openvswitch: improve the coding style)
  		if (flow->mask == mask && flow->flow_table.hash == hash &&
  		    flow_cmp_masked_key(flow, &masked_key, &mask->range))
  			return flow;
@@@ -927,7 -921,8 +938,12 @@@ struct sw_flow *ovs_flow_tbl_lookup_ufi
  
  	hash = ufid_hash(ufid);
  	head = find_bucket(ti, hash);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(flow, head, ufid_table.node[ti->node_ver]) {
++=======
+ 	hlist_for_each_entry_rcu(flow, head, ufid_table.node[ti->node_ver],
+ 				 lockdep_ovsl_is_held()) {
++>>>>>>> cf3266ad482d (net: openvswitch: improve the coding style)
  		if (flow->ufid_table.hash == hash &&
  		    ovs_flow_cmp_ufid(flow, ufid))
  			return flow;
diff --cc net/openvswitch/vport.c
index c7964a693d24,82d801f063b7..000000000000
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@@ -110,7 -97,8 +110,12 @@@ struct vport *ovs_vport_locate(const st
  	struct hlist_head *bucket = hash_bucket(net, name);
  	struct vport *vport;
  
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(vport, bucket, hash_node)
++=======
+ 	hlist_for_each_entry_rcu(vport, bucket, hash_node,
+ 				 lockdep_ovsl_is_held())
++>>>>>>> cf3266ad482d (net: openvswitch: improve the coding style)
  		if (!strcmp(name, ovs_vport_name(vport)) &&
  		    net_eq(ovs_dp_get_net(vport->dp), net))
  			return vport;
diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c
index ad055408fed1..55a9319e6a8d 100644
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@ -755,7 +755,8 @@ static int set_sctp(struct sk_buff *skb, struct sw_flow_key *flow_key,
 	return 0;
 }
 
-static int ovs_vport_output(struct net *net, struct sock *sk, struct sk_buff *skb)
+static int ovs_vport_output(struct net *net, struct sock *sk,
+			    struct sk_buff *skb)
 {
 	struct ovs_frag_data *data = this_cpu_ptr(&ovs_frag_data_storage);
 	struct vport *vport = data->vport;
@@ -933,7 +934,7 @@ static int output_userspace(struct datapath *dp, struct sk_buff *skb,
 	upcall.mru = OVS_CB(skb)->mru;
 
 	for (a = nla_data(attr), rem = nla_len(attr); rem > 0;
-		 a = nla_next(a, &rem)) {
+	     a = nla_next(a, &rem)) {
 		switch (nla_type(a)) {
 		case OVS_USERSPACE_ATTR_USERDATA:
 			upcall.userdata = a;
* Unmerged path net/openvswitch/datapath.c
* Unmerged path net/openvswitch/flow_table.c
* Unmerged path net/openvswitch/vport.c
