net: atlantic: fix PTP on AQC10X

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Egor Pomozov <epomozov@marvell.com>
commit 901f3cc1639e5103a8997f6ab243785d292e2074
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/901f3cc1.failed

This patch fixes PTP on AQC10X.
PTP support on AQC10X requires FW involvement and FW configures the
TPS data arb mode itself.
So we must make sure driver doesn't touch TPS data arb mode on AQC10x
if PTP is enabled. Otherwise, there are no timestamps even though
packets are flowing.

Fixes: 2deac71ac492a ("net: atlantic: QoS implementation: min_rate")
	Signed-off-by: Egor Pomozov <epomozov@marvell.com>
	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 901f3cc1639e5103a8997f6ab243785d292e2074)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index b7e5ce0d7af5,2125bc20ab6a..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -283,6 -325,124 +283,127 @@@ static int hw_atl_b0_hw_offload_set(str
  
  		hw_atl_itr_rsc_delay_set(self, 1U);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
+ static int hw_atl_b0_hw_init_tx_tc_rate_limit(struct aq_hw_s *self)
+ {
+ 	static const u32 max_weight = BIT(HW_ATL_TPS_DATA_TCTWEIGHT_WIDTH) - 1;
+ 	/* Scale factor is based on the number of bits in fractional portion */
+ 	static const u32 scale = BIT(HW_ATL_TPS_DESC_RATE_Y_WIDTH);
+ 	static const u32 frac_msk = HW_ATL_TPS_DESC_RATE_Y_MSK >>
+ 				    HW_ATL_TPS_DESC_RATE_Y_SHIFT;
+ 	const u32 link_speed = self->aq_link_status.mbps;
+ 	struct aq_nic_cfg_s *nic_cfg = self->aq_nic_cfg;
+ 	unsigned long num_min_rated_tcs = 0;
+ 	u32 tc_weight[AQ_CFG_TCS_MAX];
+ 	u32 fixed_max_credit;
+ 	u8 min_rate_msk = 0;
+ 	u32 sum_weight = 0;
+ 	int tc;
+ 
+ 	/* By default max_credit is based upon MTU (in unit of 64b) */
+ 	fixed_max_credit = nic_cfg->aq_hw_caps->mtu / 64;
+ 
+ 	if (link_speed) {
+ 		min_rate_msk = nic_cfg->tc_min_rate_msk &
+ 			       (BIT(nic_cfg->tcs) - 1);
+ 		num_min_rated_tcs = hweight8(min_rate_msk);
+ 	}
+ 
+ 	/* First, calculate weights where min_rate is specified */
+ 	if (num_min_rated_tcs) {
+ 		for (tc = 0; tc != nic_cfg->tcs; tc++) {
+ 			if (!nic_cfg->tc_min_rate[tc]) {
+ 				tc_weight[tc] = 0;
+ 				continue;
+ 			}
+ 
+ 			tc_weight[tc] = (-1L + link_speed +
+ 					 nic_cfg->tc_min_rate[tc] *
+ 					 max_weight) /
+ 					link_speed;
+ 			tc_weight[tc] = min(tc_weight[tc], max_weight);
+ 			sum_weight += tc_weight[tc];
+ 		}
+ 	}
+ 
+ 	/* WSP, if min_rate is set for at least one TC.
+ 	 * RR otherwise.
+ 	 *
+ 	 * NB! MAC FW sets arb mode itself if PTP is enabled. We shouldn't
+ 	 * overwrite it here in that case.
+ 	 */
+ 	if (!nic_cfg->is_ptp)
+ 		hw_atl_tps_tx_pkt_shed_data_arb_mode_set(self, min_rate_msk ? 1U : 0U);
+ 
+ 	/* Data TC Arbiter takes precedence over Descriptor TC Arbiter,
+ 	 * leave Descriptor TC Arbiter as RR.
+ 	 */
+ 	hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);
+ 
+ 	hw_atl_tps_tx_desc_rate_mode_set(self, nic_cfg->is_qos ? 1U : 0U);
+ 
+ 	for (tc = 0; tc != nic_cfg->tcs; tc++) {
+ 		const u32 en = (nic_cfg->tc_max_rate[tc] != 0) ? 1U : 0U;
+ 		const u32 desc = AQ_NIC_CFG_TCVEC2RING(nic_cfg, tc, 0);
+ 		u32 weight, max_credit;
+ 
+ 		hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, tc,
+ 							      fixed_max_credit);
+ 		hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, tc, 0x1E);
+ 
+ 		if (num_min_rated_tcs) {
+ 			weight = tc_weight[tc];
+ 
+ 			if (!weight && sum_weight < max_weight)
+ 				weight = (max_weight - sum_weight) /
+ 					 (nic_cfg->tcs - num_min_rated_tcs);
+ 			else if (!weight)
+ 				weight = 0x64;
+ 
+ 			max_credit = max(8 * weight, fixed_max_credit);
+ 		} else {
+ 			weight = 0x64;
+ 			max_credit = 0xFFF;
+ 		}
+ 
+ 		hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, tc, weight);
+ 		hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, tc,
+ 							      max_credit);
+ 
+ 		hw_atl_tps_tx_desc_rate_en_set(self, desc, en);
+ 
+ 		if (en) {
+ 			/* Nominal rate is always 10G */
+ 			const u32 rate = 10000U * scale /
+ 					 nic_cfg->tc_max_rate[tc];
+ 			const u32 rate_int = rate >>
+ 					     HW_ATL_TPS_DESC_RATE_Y_WIDTH;
+ 			const u32 rate_frac = rate & frac_msk;
+ 
+ 			hw_atl_tps_tx_desc_rate_x_set(self, desc, rate_int);
+ 			hw_atl_tps_tx_desc_rate_y_set(self, desc, rate_frac);
+ 		} else {
+ 			/* A value of 1 indicates the queue is not
+ 			 * rate controlled.
+ 			 */
+ 			hw_atl_tps_tx_desc_rate_x_set(self, desc, 1U);
+ 			hw_atl_tps_tx_desc_rate_y_set(self, desc, 0U);
+ 		}
+ 	}
+ 	for (tc = nic_cfg->tcs; tc != AQ_CFG_TCS_MAX; tc++) {
+ 		const u32 desc = AQ_NIC_CFG_TCVEC2RING(nic_cfg, tc, 0);
+ 
+ 		hw_atl_tps_tx_desc_rate_en_set(self, desc, 0U);
+ 		hw_atl_tps_tx_desc_rate_x_set(self, desc, 1U);
+ 		hw_atl_tps_tx_desc_rate_y_set(self, desc, 0U);
+ 	}
+ 
++>>>>>>> 901f3cc1639e (net: atlantic: fix PTP on AQC10X)
  	return aq_hw_err_from_flags(self);
  }
  
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
