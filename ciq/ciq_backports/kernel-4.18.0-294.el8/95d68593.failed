sched/pelt: Sync util/runnable_sum with PELT window when propagating

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vincent Guittot <vincent.guittot@linaro.org>
commit 95d685935a2edf209fc68f52494ede4a382a6c2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/95d68593.failed

update_tg_cfs_*() propagate the impact of the attach/detach of an entity
down into the cfs_rq hierarchy and must keep the sync with the current pelt
window.

Even if we can't sync child cfs_rq and its group se, we can sync the group
se and its parent cfs_rq with current position in the PELT window. In fact,
we must keep them sync in order to stay also synced with others entities
and group entities that are already attached to the cfs_rq.

	Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200506155301.14288-1-vincent.guittot@linaro.org
(cherry picked from commit 95d685935a2edf209fc68f52494ede4a382a6c2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index 5b904a81a851,44b0c8edc260..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -3506,10 -3463,34 +3503,37 @@@ update_tg_cfs_util(struct cfs_rq *cfs_r
  static inline void
  update_tg_cfs_runnable(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)
  {
++<<<<<<< HEAD
++=======
+ 	long delta = gcfs_rq->avg.runnable_avg - se->avg.runnable_avg;
+ 	/*
+ 	 * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.
+ 	 * See ___update_load_avg() for details.
+ 	 */
+ 	u32 divider = LOAD_AVG_MAX - 1024 + cfs_rq->avg.period_contrib;
+ 
+ 	/* Nothing to update */
+ 	if (!delta)
+ 		return;
+ 
+ 	/* Set new sched_entity's runnable */
+ 	se->avg.runnable_avg = gcfs_rq->avg.runnable_avg;
+ 	se->avg.runnable_sum = se->avg.runnable_avg * divider;
+ 
+ 	/* Update parent cfs_rq runnable */
+ 	add_positive(&cfs_rq->avg.runnable_avg, delta);
+ 	cfs_rq->avg.runnable_sum = cfs_rq->avg.runnable_avg * divider;
+ }
+ 
+ static inline void
+ update_tg_cfs_load(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)
+ {
++>>>>>>> 95d685935a2e (sched/pelt: Sync util/runnable_sum with PELT window when propagating)
  	long delta_avg, running_sum, runnable_sum = gcfs_rq->prop_runnable_sum;
 -	unsigned long load_avg;
 -	u64 load_sum = 0;
 +	unsigned long runnable_load_avg, load_avg;
 +	u64 runnable_load_sum, load_sum = 0;
  	s64 delta_sum;
+ 	u32 divider;
  
  	if (!runnable_sum)
  		return;
* Unmerged path kernel/sched/fair.c
diff --git a/kernel/sched/pelt.c b/kernel/sched/pelt.c
index bd006b79b360..e170d91eddc1 100644
--- a/kernel/sched/pelt.c
+++ b/kernel/sched/pelt.c
@@ -237,6 +237,30 @@ ___update_load_sum(u64 now, struct sched_avg *sa,
 	return 1;
 }
 
+/*
+ * When syncing *_avg with *_sum, we must take into account the current
+ * position in the PELT segment otherwise the remaining part of the segment
+ * will be considered as idle time whereas it's not yet elapsed and this will
+ * generate unwanted oscillation in the range [1002..1024[.
+ *
+ * The max value of *_sum varies with the position in the time segment and is
+ * equals to :
+ *
+ *   LOAD_AVG_MAX*y + sa->period_contrib
+ *
+ * which can be simplified into:
+ *
+ *   LOAD_AVG_MAX - 1024 + sa->period_contrib
+ *
+ * because LOAD_AVG_MAX*y == LOAD_AVG_MAX-1024
+ *
+ * The same care must be taken when a sched entity is added, updated or
+ * removed from a cfs_rq and we need to update sched_avg. Scheduler entities
+ * and the cfs rq, to which they are attached, have the same position in the
+ * time segment because they use the same clock. This means that we can use
+ * the period_contrib of cfs_rq when updating the sched_avg of a sched_entity
+ * if it's more convenient.
+ */
 static __always_inline void
 ___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)
 {
