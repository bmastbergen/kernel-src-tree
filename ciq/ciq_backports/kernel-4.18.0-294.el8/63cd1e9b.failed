xfs: move xfs_fc_reconfigure() above xfs_fc_free()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ian Kent <raven@themaw.net>
commit 63cd1e9b026e760f0455d6fb959f5c963c90c10e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/63cd1e9b.failed

Grouping the options parsing and mount handling functions above the
struct fs_context_operations but below the struct super_operations
should improve (some) the grouping of the super operations while also
improving the grouping of the options parsing and mount handling code.

Start by moving xfs_fc_reconfigure() and friends.
This is a straight code move, there aren't any functional changes.

	Signed-off-by: Ian Kent <raven@themaw.net>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 63cd1e9b026e760f0455d6fb959f5c963c90c10e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index 9024b0a4c895,d93a63aa7ab1..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1170,206 -1144,6 +1170,209 @@@ xfs_quiesce_attr
  	xfs_log_quiesce(mp);
  }
  
++<<<<<<< HEAD
 +STATIC int
 +xfs_test_remount_options(
 +	struct super_block	*sb,
 +	char			*options)
 +{
 +	int			error = 0;
 +	struct xfs_mount	*tmp_mp;
 +
 +	tmp_mp = kmem_zalloc(sizeof(*tmp_mp), KM_MAYFAIL);
 +	if (!tmp_mp)
 +		return -ENOMEM;
 +
 +	tmp_mp->m_super = sb;
 +	error = xfs_parseargs(tmp_mp, options);
 +	xfs_mount_free(tmp_mp);
 +
 +	return error;
 +}
 +
 +static int
 +xfs_remount_rw(
 +	struct xfs_mount	*mp)
 +{
 +	struct xfs_sb		*sbp = &mp->m_sb;
 +	int error;
 +
 +	if (mp->m_flags & XFS_MOUNT_NORECOVERY) {
 +		xfs_warn(mp,
 +			"ro->rw transition prohibited on norecovery mount");
 +		return -EINVAL;
 +	}
 +
 +	if (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&
 +	    xfs_sb_has_ro_compat_feature(sbp, XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {
 +		xfs_warn(mp,
 +	"ro->rw transition prohibited on unknown (0x%x) ro-compat filesystem",
 +			(sbp->sb_features_ro_compat &
 +				XFS_SB_FEAT_RO_COMPAT_UNKNOWN));
 +		return -EINVAL;
 +	}
 +
 +	mp->m_flags &= ~XFS_MOUNT_RDONLY;
 +
 +	/*
 +	 * If this is the first remount to writeable state we might have some
 +	 * superblock changes to update.
 +	 */
 +	if (mp->m_update_sb) {
 +		error = xfs_sync_sb(mp, false);
 +		if (error) {
 +			xfs_warn(mp, "failed to write sb changes");
 +			return error;
 +		}
 +		mp->m_update_sb = false;
 +	}
 +
 +	/*
 +	 * Fill out the reserve pool if it is empty. Use the stashed value if
 +	 * it is non-zero, otherwise go with the default.
 +	 */
 +	xfs_restore_resvblks(mp);
 +	xfs_log_work_queue(mp);
 +
 +	/* Recover any CoW blocks that never got remapped. */
 +	error = xfs_reflink_recover_cow(mp);
 +	if (error) {
 +		xfs_err(mp,
 +			"Error %d recovering leftover CoW allocations.", error);
 +			xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 +		return error;
 +	}
 +	xfs_start_block_reaping(mp);
 +
 +	/* Create the per-AG metadata reservation pool .*/
 +	error = xfs_fs_reserve_ag_blocks(mp);
 +	if (error && error != -ENOSPC)
 +		return error;
 +
 +	return 0;
 +}
 +
 +static int
 +xfs_remount_ro(
 +	struct xfs_mount	*mp)
 +{
 +	int error;
 +
 +	/*
 +	 * Cancel background eofb scanning so it cannot race with the final
 +	 * log force+buftarg wait and deadlock the remount.
 +	 */
 +	xfs_stop_block_reaping(mp);
 +
 +	/* Get rid of any leftover CoW reservations... */
 +	error = xfs_icache_free_cowblocks(mp, NULL);
 +	if (error) {
 +		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 +		return error;
 +	}
 +
 +	/* Free the per-AG metadata reservation pool. */
 +	error = xfs_fs_unreserve_ag_blocks(mp);
 +	if (error) {
 +		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 +		return error;
 +	}
 +
 +	/*
 +	 * Before we sync the metadata, we need to free up the reserve block
 +	 * pool so that the used block count in the superblock on disk is
 +	 * correct at the end of the remount. Stash the current* reserve pool
 +	 * size so that if we get remounted rw, we can return it to the same
 +	 * size.
 +	 */
 +	xfs_save_resvblks(mp);
 +
 +	xfs_quiesce_attr(mp);
 +	mp->m_flags |= XFS_MOUNT_RDONLY;
 +
 +	return 0;
 +}
 +
 +STATIC int
 +xfs_fs_remount(
 +	struct super_block	*sb,
 +	int			*flags,
 +	char			*options)
 +{
 +	struct xfs_mount	*mp = XFS_M(sb);
 +	xfs_sb_t		*sbp = &mp->m_sb;
 +	substring_t		args[MAX_OPT_ARGS];
 +	char			*p;
 +	int			error;
 +
 +	/* First, check for complete junk; i.e. invalid options */
 +	error = xfs_test_remount_options(sb, options);
 +	if (error)
 +		return error;
 +
 +	sync_filesystem(sb);
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_inode64:
 +			mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
 +			mp->m_maxagi = xfs_set_inode_alloc(mp, sbp->sb_agcount);
 +			break;
 +		case Opt_inode32:
 +			mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
 +			mp->m_maxagi = xfs_set_inode_alloc(mp, sbp->sb_agcount);
 +			break;
 +		default:
 +			/*
 +			 * Logically we would return an error here to prevent
 +			 * users from believing they might have changed
 +			 * mount options using remount which can't be changed.
 +			 *
 +			 * But unfortunately mount(8) adds all options from
 +			 * mtab and fstab to the mount arguments in some cases
 +			 * so we can't blindly reject options, but have to
 +			 * check for each specified option if it actually
 +			 * differs from the currently set option and only
 +			 * reject it if that's the case.
 +			 *
 +			 * Until that is implemented we return success for
 +			 * every remount request, and silently ignore all
 +			 * options that we can't actually change.
 +			 */
 +#if 0
 +			xfs_info(mp,
 +		"mount option \"%s\" not supported for remount", p);
 +			return -EINVAL;
 +#else
 +			break;
 +#endif
 +		}
 +	}
 +
 +	/* ro -> rw */
 +	if ((mp->m_flags & XFS_MOUNT_RDONLY) && !(*flags & SB_RDONLY)) {
 +		error = xfs_remount_rw(mp);
 +		if (error)
 +			return error;
 +	}
 +
 +	/* rw -> ro */
 +	if (!(mp->m_flags & XFS_MOUNT_RDONLY) && (*flags & SB_RDONLY)) {
 +		error = xfs_remount_ro(mp);
 +		if (error)
 +			return error;
 +	}
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 63cd1e9b026e (xfs: move xfs_fc_reconfigure() above xfs_fc_free())
  /*
   * Second stage of a freeze. The data is already frozen so we only
   * need to take care of the metadata. Once that's done sync the superblock
@@@ -1834,6 -1578,222 +1837,225 @@@ static const struct super_operations xf
  	.free_cached_objects	= xfs_fs_free_cached_objects,
  };
  
++<<<<<<< HEAD
++=======
+ static int
+ xfs_remount_rw(
+ 	struct xfs_mount	*mp)
+ {
+ 	struct xfs_sb		*sbp = &mp->m_sb;
+ 	int error;
+ 
+ 	if (mp->m_flags & XFS_MOUNT_NORECOVERY) {
+ 		xfs_warn(mp,
+ 			"ro->rw transition prohibited on norecovery mount");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&
+ 	    xfs_sb_has_ro_compat_feature(sbp, XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {
+ 		xfs_warn(mp,
+ 	"ro->rw transition prohibited on unknown (0x%x) ro-compat filesystem",
+ 			(sbp->sb_features_ro_compat &
+ 				XFS_SB_FEAT_RO_COMPAT_UNKNOWN));
+ 		return -EINVAL;
+ 	}
+ 
+ 	mp->m_flags &= ~XFS_MOUNT_RDONLY;
+ 
+ 	/*
+ 	 * If this is the first remount to writeable state we might have some
+ 	 * superblock changes to update.
+ 	 */
+ 	if (mp->m_update_sb) {
+ 		error = xfs_sync_sb(mp, false);
+ 		if (error) {
+ 			xfs_warn(mp, "failed to write sb changes");
+ 			return error;
+ 		}
+ 		mp->m_update_sb = false;
+ 	}
+ 
+ 	/*
+ 	 * Fill out the reserve pool if it is empty. Use the stashed value if
+ 	 * it is non-zero, otherwise go with the default.
+ 	 */
+ 	xfs_restore_resvblks(mp);
+ 	xfs_log_work_queue(mp);
+ 
+ 	/* Recover any CoW blocks that never got remapped. */
+ 	error = xfs_reflink_recover_cow(mp);
+ 	if (error) {
+ 		xfs_err(mp,
+ 			"Error %d recovering leftover CoW allocations.", error);
+ 			xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
+ 		return error;
+ 	}
+ 	xfs_start_block_reaping(mp);
+ 
+ 	/* Create the per-AG metadata reservation pool .*/
+ 	error = xfs_fs_reserve_ag_blocks(mp);
+ 	if (error && error != -ENOSPC)
+ 		return error;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_remount_ro(
+ 	struct xfs_mount	*mp)
+ {
+ 	int error;
+ 
+ 	/*
+ 	 * Cancel background eofb scanning so it cannot race with the final
+ 	 * log force+buftarg wait and deadlock the remount.
+ 	 */
+ 	xfs_stop_block_reaping(mp);
+ 
+ 	/* Get rid of any leftover CoW reservations... */
+ 	error = xfs_icache_free_cowblocks(mp, NULL);
+ 	if (error) {
+ 		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
+ 		return error;
+ 	}
+ 
+ 	/* Free the per-AG metadata reservation pool. */
+ 	error = xfs_fs_unreserve_ag_blocks(mp);
+ 	if (error) {
+ 		xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
+ 		return error;
+ 	}
+ 
+ 	/*
+ 	 * Before we sync the metadata, we need to free up the reserve block
+ 	 * pool so that the used block count in the superblock on disk is
+ 	 * correct at the end of the remount. Stash the current* reserve pool
+ 	 * size so that if we get remounted rw, we can return it to the same
+ 	 * size.
+ 	 */
+ 	xfs_save_resvblks(mp);
+ 
+ 	xfs_quiesce_attr(mp);
+ 	mp->m_flags |= XFS_MOUNT_RDONLY;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Logically we would return an error here to prevent users from believing
+  * they might have changed mount options using remount which can't be changed.
+  *
+  * But unfortunately mount(8) adds all options from mtab and fstab to the mount
+  * arguments in some cases so we can't blindly reject options, but have to
+  * check for each specified option if it actually differs from the currently
+  * set option and only reject it if that's the case.
+  *
+  * Until that is implemented we return success for every remount request, and
+  * silently ignore all options that we can't actually change.
+  */
+ static int
+ xfs_fc_reconfigure(
+ 	struct fs_context *fc)
+ {
+ 	struct xfs_mount	*mp = XFS_M(fc->root->d_sb);
+ 	struct xfs_mount        *new_mp = fc->s_fs_info;
+ 	xfs_sb_t		*sbp = &mp->m_sb;
+ 	int			flags = fc->sb_flags;
+ 	int			error;
+ 
+ 	error = xfs_fc_validate_params(new_mp);
+ 	if (error)
+ 		return error;
+ 
+ 	sync_filesystem(mp->m_super);
+ 
+ 	/* inode32 -> inode64 */
+ 	if ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) &&
+ 	    !(new_mp->m_flags & XFS_MOUNT_SMALL_INUMS)) {
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		mp->m_maxagi = xfs_set_inode_alloc(mp, sbp->sb_agcount);
+ 	}
+ 
+ 	/* inode64 -> inode32 */
+ 	if (!(mp->m_flags & XFS_MOUNT_SMALL_INUMS) &&
+ 	    (new_mp->m_flags & XFS_MOUNT_SMALL_INUMS)) {
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		mp->m_maxagi = xfs_set_inode_alloc(mp, sbp->sb_agcount);
+ 	}
+ 
+ 	/* ro -> rw */
+ 	if ((mp->m_flags & XFS_MOUNT_RDONLY) && !(flags & SB_RDONLY)) {
+ 		error = xfs_remount_rw(mp);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/* rw -> ro */
+ 	if (!(mp->m_flags & XFS_MOUNT_RDONLY) && (flags & SB_RDONLY)) {
+ 		error = xfs_remount_ro(mp);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void xfs_fc_free(
+ 	struct fs_context	*fc)
+ {
+ 	struct xfs_mount	*mp = fc->s_fs_info;
+ 
+ 	/*
+ 	 * mp is stored in the fs_context when it is initialized.
+ 	 * mp is transferred to the superblock on a successful mount,
+ 	 * but if an error occurs before the transfer we have to free
+ 	 * it here.
+ 	 */
+ 	if (mp)
+ 		xfs_mount_free(mp);
+ }
+ 
+ static const struct fs_context_operations xfs_context_ops = {
+ 	.parse_param = xfs_fc_parse_param,
+ 	.get_tree    = xfs_fc_get_tree,
+ 	.reconfigure = xfs_fc_reconfigure,
+ 	.free        = xfs_fc_free,
+ };
+ 
+ static int xfs_init_fs_context(
+ 	struct fs_context	*fc)
+ {
+ 	struct xfs_mount	*mp;
+ 
+ 	mp = xfs_mount_alloc();
+ 	if (!mp)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * These can be overridden by the mount option parsing.
+ 	 */
+ 	mp->m_logbufs = -1;
+ 	mp->m_logbsize = -1;
+ 	mp->m_allocsize_log = 16; /* 64k */
+ 
+ 	/*
+ 	 * Copy binary VFS mount flags we are interested in.
+ 	 */
+ 	if (fc->sb_flags & SB_RDONLY)
+ 		mp->m_flags |= XFS_MOUNT_RDONLY;
+ 	if (fc->sb_flags & SB_DIRSYNC)
+ 		mp->m_flags |= XFS_MOUNT_DIRSYNC;
+ 	if (fc->sb_flags & SB_SYNCHRONOUS)
+ 		mp->m_flags |= XFS_MOUNT_WSYNC;
+ 
+ 	fc->s_fs_info = mp;
+ 	fc->ops = &xfs_context_ops;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 63cd1e9b026e (xfs: move xfs_fc_reconfigure() above xfs_fc_free())
  static struct file_system_type xfs_fs_type = {
  	.owner			= THIS_MODULE,
  	.name			= "xfs",
* Unmerged path fs/xfs/xfs_super.c
