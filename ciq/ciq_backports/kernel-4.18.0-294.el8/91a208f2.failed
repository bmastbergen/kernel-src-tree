net: phylink: propagate resolved link config via mac_link_up()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 91a208f2185ad4855ff03c342d0b7e4f5fc6f5df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/91a208f2.failed

Propagate the resolved link parameters via the mac_link_up() call for
MACs that do not automatically track their PCS state. We propagate the
link parameters via function arguments so that inappropriate members
of struct phylink_link_state can't be accessed, and creating a new
structure just for this adds needless complexity to the API.

	Tested-by: Andre Przywara <andre.przywara@arm.com>
	Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
	Tested-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 91a208f2185ad4855ff03c342d0b7e4f5fc6f5df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/cadence/macb_main.c
#	drivers/net/ethernet/freescale/dpaa2/dpaa2-mac.c
#	drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
#	drivers/net/ethernet/mediatek/mtk_eth_soc.c
#	drivers/net/ethernet/xilinx/xilinx_axienet_main.c
#	drivers/net/phy/phylink.c
#	net/dsa/port.c
diff --cc drivers/net/ethernet/cadence/macb_main.c
index eaaa8bf3961f,7ab0bef5e1bd..000000000000
--- a/drivers/net/ethernet/cadence/macb_main.c
+++ b/drivers/net/ethernet/cadence/macb_main.c
@@@ -409,61 -569,139 +409,138 @@@ static void macb_handle_link_change(str
  
  	spin_lock_irqsave(&bp->lock, flags);
  
 -	old_ctrl = ctrl = macb_or_gem_readl(bp, NCFGR);
 +	if (phydev->link) {
 +		if ((bp->speed != phydev->speed) ||
 +		    (bp->duplex != phydev->duplex)) {
 +			u32 reg;
  
 -	/* Clear all the bits we might set later */
 -	ctrl &= ~(MACB_BIT(SPD) | MACB_BIT(FD) | MACB_BIT(PAE));
 +			reg = macb_readl(bp, NCFGR);
 +			reg &= ~(MACB_BIT(SPD) | MACB_BIT(FD));
 +			if (macb_is_gem(bp))
 +				reg &= ~GEM_BIT(GBE);
  
 -	if (bp->caps & MACB_CAPS_MACB_IS_EMAC) {
 -		if (state->interface == PHY_INTERFACE_MODE_RMII)
 -			ctrl |= MACB_BIT(RM9200_RMII);
 -	} else {
 -		ctrl &= ~(GEM_BIT(GBE) | GEM_BIT(SGMIIEN) | GEM_BIT(PCSSEL));
 +			if (phydev->duplex)
 +				reg |= MACB_BIT(FD);
 +			if (phydev->speed == SPEED_100)
 +				reg |= MACB_BIT(SPD);
 +			if (phydev->speed == SPEED_1000 &&
 +			    bp->caps & MACB_CAPS_GIGABIT_MODE_AVAILABLE)
 +				reg |= GEM_BIT(GBE);
  
 -		/* We do not support MLO_PAUSE_RX yet */
 -		if (state->pause & MLO_PAUSE_TX)
 -			ctrl |= MACB_BIT(PAE);
 +			macb_or_gem_writel(bp, NCFGR, reg);
  
 -		if (state->interface == PHY_INTERFACE_MODE_SGMII)
 -			ctrl |= GEM_BIT(SGMIIEN) | GEM_BIT(PCSSEL);
 +			bp->speed = phydev->speed;
 +			bp->duplex = phydev->duplex;
 +			status_change = 1;
 +		}
  	}
  
 -	if (state->speed == SPEED_1000)
 -		ctrl |= GEM_BIT(GBE);
 -	else if (state->speed == SPEED_100)
 -		ctrl |= MACB_BIT(SPD);
 -
 -	if (state->duplex)
 -		ctrl |= MACB_BIT(FD);
 -
 -	/* Apply the new configuration, if any */
 -	if (old_ctrl ^ ctrl)
 -		macb_or_gem_writel(bp, NCFGR, ctrl);
 +	if (phydev->link != bp->link) {
 +		if (!phydev->link) {
 +			bp->speed = 0;
 +			bp->duplex = -1;
 +		}
 +		bp->link = phydev->link;
  
 -	bp->speed = state->speed;
 +		status_change = 1;
 +	}
  
  	spin_unlock_irqrestore(&bp->lock, flags);
 -}
 -
 -static void macb_mac_link_down(struct phylink_config *config, unsigned int mode,
 -			       phy_interface_t interface)
 -{
 -	struct net_device *ndev = to_net_dev(config->dev);
 -	struct macb *bp = netdev_priv(ndev);
 -	struct macb_queue *queue;
 -	unsigned int q;
 -	u32 ctrl;
  
 +	if (status_change) {
 +		if (phydev->link) {
 +			/* Update the TX clock rate if and only if the link is
 +			 * up and there has been a link change.
 +			 */
 +			macb_set_tx_clk(bp->tx_clk, phydev->speed, dev);
 +
++<<<<<<< HEAD
 +			netif_carrier_on(dev);
 +			netdev_info(dev, "link up (%d/%s)\n",
 +				    phydev->speed,
 +				    phydev->duplex == DUPLEX_FULL ?
 +				    "Full" : "Half");
 +		} else {
 +			netif_carrier_off(dev);
 +			netdev_info(dev, "link down\n");
++=======
+ 	if (!(bp->caps & MACB_CAPS_MACB_IS_EMAC))
+ 		for (q = 0, queue = bp->queues; q < bp->num_queues; ++q, ++queue)
+ 			queue_writel(queue, IDR,
+ 				     bp->rx_intr_mask | MACB_TX_INT_FLAGS | MACB_BIT(HRESP));
+ 
+ 	/* Disable Rx and Tx */
+ 	ctrl = macb_readl(bp, NCR) & ~(MACB_BIT(RE) | MACB_BIT(TE));
+ 	macb_writel(bp, NCR, ctrl);
+ 
+ 	netif_tx_stop_all_queues(ndev);
+ }
+ 
+ static void macb_mac_link_up(struct phylink_config *config,
+ 			     struct phy_device *phy,
+ 			     unsigned int mode, phy_interface_t interface,
+ 			     int speed, int duplex,
+ 			     bool tx_pause, bool rx_pause)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct macb *bp = netdev_priv(ndev);
+ 	struct macb_queue *queue;
+ 	unsigned int q;
+ 
+ 	if (!(bp->caps & MACB_CAPS_MACB_IS_EMAC)) {
+ 		macb_set_tx_clk(bp->tx_clk, bp->speed, ndev);
+ 
+ 		/* Initialize rings & buffers as clearing MACB_BIT(TE) in link down
+ 		 * cleared the pipeline and control registers.
+ 		 */
+ 		bp->macbgem_ops.mog_init_rings(bp);
+ 		macb_init_buffers(bp);
+ 
+ 		for (q = 0, queue = bp->queues; q < bp->num_queues; ++q, ++queue)
+ 			queue_writel(queue, IER,
+ 				     bp->rx_intr_mask | MACB_TX_INT_FLAGS | MACB_BIT(HRESP));
+ 	}
+ 
+ 	/* Enable Rx and Tx */
+ 	macb_writel(bp, NCR, macb_readl(bp, NCR) | MACB_BIT(RE) | MACB_BIT(TE));
+ 
+ 	netif_tx_wake_all_queues(ndev);
+ }
+ 
+ static const struct phylink_mac_ops macb_phylink_ops = {
+ 	.validate = macb_validate,
+ 	.mac_pcs_get_state = macb_mac_pcs_get_state,
+ 	.mac_an_restart = macb_mac_an_restart,
+ 	.mac_config = macb_mac_config,
+ 	.mac_link_down = macb_mac_link_down,
+ 	.mac_link_up = macb_mac_link_up,
+ };
+ 
+ static bool macb_phy_handle_exists(struct device_node *dn)
+ {
+ 	dn = of_parse_phandle(dn, "phy-handle", 0);
+ 	of_node_put(dn);
+ 	return dn != NULL;
+ }
+ 
+ static int macb_phylink_connect(struct macb *bp)
+ {
+ 	struct device_node *dn = bp->pdev->dev.of_node;
+ 	struct net_device *dev = bp->dev;
+ 	struct phy_device *phydev;
+ 	int ret;
+ 
+ 	if (dn)
+ 		ret = phylink_of_phy_connect(bp->phylink, dn, 0);
+ 
+ 	if (!dn || (ret && !macb_phy_handle_exists(dn))) {
+ 		phydev = phy_find_first(bp->mii_bus);
+ 		if (!phydev) {
+ 			netdev_err(dev, "no PHY found\n");
+ 			return -ENXIO;
++>>>>>>> 91a208f2185a (net: phylink: propagate resolved link config via mac_link_up())
  		}
 -
 -		/* attach the mac to the phy */
 -		ret = phylink_connect_phy(bp->phylink, phydev);
  	}
 -
 -	if (ret) {
 -		netdev_err(dev, "Could not attach PHY (%d)\n", ret);
 -		return ret;
 -	}
 -
 -	phylink_start(bp->phylink);
 -
 -	return 0;
  }
  
  /* based on au1000_eth. c*/
diff --cc drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index ffcc39fb56ba,ed8042d97e29..000000000000
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@@ -3152,9 -3474,11 +3155,15 @@@ static void mvpp2_start_dev(struct mvpp
  		 */
  		struct phylink_link_state state = {
  			.interface = port->phy_interface,
 +			.link = 1,
  		};
  		mvpp2_mac_config(&port->phylink_config, MLO_AN_INBAND, &state);
++<<<<<<< HEAD
++=======
+ 		mvpp2_mac_link_up(&port->phylink_config, NULL,
+ 				  MLO_AN_INBAND, port->phy_interface,
+ 				  SPEED_UNKNOWN, DUPLEX_UNKNOWN, false, false);
++>>>>>>> 91a208f2185a (net: phylink: propagate resolved link config via mac_link_up())
  	}
  
  	netif_tx_start_all_queues(port->dev);
@@@ -4424,20 -5139,17 +4433,23 @@@ static void mvpp2_mac_config(struct phy
  	if (port->priv->hw_version == MVPP21 && port->flags & MVPP2_F_LOOPBACK)
  		mvpp2_port_loopback_set(port, state);
  
 -	if (port->priv->hw_version == MVPP22 && change_interface)
 -		mvpp22_gop_unmask_irq(port);
 +	/* If the port already was up, make sure it's still in the same state */
 +	if (state->link || !port->has_phy) {
 +		mvpp2_port_enable(port);
  
 -	mvpp2_port_enable(port);
 +		mvpp2_egress_enable(port);
 +		mvpp2_ingress_enable(port);
 +		if (!port->has_phy)
 +			netif_carrier_on(dev);
 +		netif_tx_wake_all_queues(dev);
 +	}
  }
  
- static void mvpp2_mac_link_up(struct phylink_config *config, unsigned int mode,
- 			      phy_interface_t interface, struct phy_device *phy)
+ static void mvpp2_mac_link_up(struct phylink_config *config,
+ 			      struct phy_device *phy,
+ 			      unsigned int mode, phy_interface_t interface,
+ 			      int speed, int duplex,
+ 			      bool tx_pause, bool rx_pause)
  {
  	struct net_device *dev = to_net_dev(config->dev);
  	struct mvpp2_port *port = netdev_priv(dev);
diff --cc drivers/net/ethernet/mediatek/mtk_eth_soc.c
index e558deb9449b,8d28f90acfe7..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@@ -165,211 -187,339 +165,373 @@@ static void mtk_gmac0_rgmii_adjust(stru
  	mtk_w32(eth, val, TRGMII_TCK_CTRL);
  }
  
 -static void mtk_mac_config(struct phylink_config *config, unsigned int mode,
 -			   const struct phylink_link_state *state)
 +static void mtk_gmac_sgmii_hw_setup(struct mtk_eth *eth, int mac_id)
  {
 -	struct mtk_mac *mac = container_of(config, struct mtk_mac,
 -					   phylink_config);
 -	struct mtk_eth *eth = mac->hw;
 -	u32 mcr_cur, mcr_new, sid;
 -	int val, ge_mode, err;
 -
 -	/* MT76x8 has no hardware settings between for the MAC */
 -	if (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628) &&
 -	    mac->interface != state->interface) {
 -		/* Setup soc pin functions */
 -		switch (state->interface) {
 -		case PHY_INTERFACE_MODE_TRGMII:
 -			if (mac->id)
 -				goto err_phy;
 -			if (!MTK_HAS_CAPS(mac->hw->soc->caps,
 -					  MTK_GMAC1_TRGMII))
 -				goto err_phy;
 -			/* fall through */
 -		case PHY_INTERFACE_MODE_RGMII_TXID:
 -		case PHY_INTERFACE_MODE_RGMII_RXID:
 -		case PHY_INTERFACE_MODE_RGMII_ID:
 -		case PHY_INTERFACE_MODE_RGMII:
 -		case PHY_INTERFACE_MODE_MII:
 -		case PHY_INTERFACE_MODE_REVMII:
 -		case PHY_INTERFACE_MODE_RMII:
 -			if (MTK_HAS_CAPS(eth->soc->caps, MTK_RGMII)) {
 -				err = mtk_gmac_rgmii_path_setup(eth, mac->id);
 -				if (err)
 -					goto init_err;
 -			}
 -			break;
 -		case PHY_INTERFACE_MODE_1000BASEX:
 -		case PHY_INTERFACE_MODE_2500BASEX:
 -		case PHY_INTERFACE_MODE_SGMII:
 -			if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII)) {
 -				err = mtk_gmac_sgmii_path_setup(eth, mac->id);
 -				if (err)
 -					goto init_err;
 -			}
 -			break;
 -		case PHY_INTERFACE_MODE_GMII:
 -			if (MTK_HAS_CAPS(eth->soc->caps, MTK_GEPHY)) {
 -				err = mtk_gmac_gephy_path_setup(eth, mac->id);
 -				if (err)
 -					goto init_err;
 -			}
 -			break;
 -		default:
 -			goto err_phy;
 -		}
 +	u32 val;
  
 -		/* Setup clock for 1st gmac */
 -		if (!mac->id && state->interface != PHY_INTERFACE_MODE_SGMII &&
 -		    !phy_interface_mode_is_8023z(state->interface) &&
 -		    MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII)) {
 -			if (MTK_HAS_CAPS(mac->hw->soc->caps,
 -					 MTK_TRGMII_MT7621_CLK)) {
 -				if (mt7621_gmac0_rgmii_adjust(mac->hw,
 -							      state->interface))
 -					goto err_phy;
 -			} else {
 -				if (state->interface !=
 -				    PHY_INTERFACE_MODE_TRGMII)
 -					mtk_gmac0_rgmii_adjust(mac->hw,
 -							       state->speed);
 -			}
 -		}
 +	/* Setup the link timer and QPHY power up inside SGMIISYS */
 +	regmap_write(eth->sgmiisys, SGMSYS_PCS_LINK_TIMER,
 +		     SGMII_LINK_TIMER_DEFAULT);
  
 -		ge_mode = 0;
 -		switch (state->interface) {
 -		case PHY_INTERFACE_MODE_MII:
 -		case PHY_INTERFACE_MODE_GMII:
 -			ge_mode = 1;
 -			break;
 -		case PHY_INTERFACE_MODE_REVMII:
 -			ge_mode = 2;
 -			break;
 -		case PHY_INTERFACE_MODE_RMII:
 -			if (mac->id)
 -				goto err_phy;
 -			ge_mode = 3;
 -			break;
 -		default:
 -			break;
 -		}
 +	regmap_read(eth->sgmiisys, SGMSYS_SGMII_MODE, &val);
 +	val |= SGMII_REMOTE_FAULT_DIS;
 +	regmap_write(eth->sgmiisys, SGMSYS_SGMII_MODE, val);
  
 -		/* put the gmac into the right mode */
 +	regmap_read(eth->sgmiisys, SGMSYS_PCS_CONTROL_1, &val);
 +	val |= SGMII_AN_RESTART;
 +	regmap_write(eth->sgmiisys, SGMSYS_PCS_CONTROL_1, val);
 +
 +	regmap_read(eth->sgmiisys, SGMSYS_QPHY_PWR_STATE_CTRL, &val);
 +	val &= ~SGMII_PHYA_PWD;
 +	regmap_write(eth->sgmiisys, SGMSYS_QPHY_PWR_STATE_CTRL, val);
 +
 +	/* Determine MUX for which GMAC uses the SGMII interface */
 +	if (MTK_HAS_CAPS(eth->soc->caps, MTK_DUAL_GMAC_SHARED_SGMII)) {
  		regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 -		val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);
 -		val |= SYSCFG0_GE_MODE(ge_mode, mac->id);
 +		val &= ~SYSCFG0_SGMII_MASK;
 +		val |= !mac_id ? SYSCFG0_SGMII_GMAC1 : SYSCFG0_SGMII_GMAC2;
  		regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
  
 -		mac->interface = state->interface;
 +		dev_info(eth->dev, "setup shared sgmii for gmac=%d\n",
 +			 mac_id);
  	}
  
 -	/* SGMII */
 -	if (state->interface == PHY_INTERFACE_MODE_SGMII ||
 -	    phy_interface_mode_is_8023z(state->interface)) {
 -		/* The path GMAC to SGMII will be enabled once the SGMIISYS is
 -		 * being setup done.
 -		 */
 -		regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 +	/* Setup the GMAC1 going through SGMII path when SoC also support
 +	 * ESW on GMAC1
 +	 */
 +	if (MTK_HAS_CAPS(eth->soc->caps, MTK_GMAC1_ESW | MTK_GMAC1_SGMII) &&
 +	    !mac_id) {
 +		mtk_w32(eth, 0, MTK_MAC_MISC);
 +		dev_info(eth->dev, "setup gmac1 going through sgmii");
 +	}
 +}
 +
 +static void mtk_phy_link_adjust(struct net_device *dev)
 +{
 +	struct mtk_mac *mac = netdev_priv(dev);
 +	u16 lcl_adv = 0, rmt_adv = 0;
 +	u8 flowctrl;
 +	u32 mcr = MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG |
 +		  MAC_MCR_FORCE_MODE | MAC_MCR_TX_EN |
 +		  MAC_MCR_RX_EN | MAC_MCR_BACKOFF_EN |
 +		  MAC_MCR_BACKPR_EN;
 +
 +	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
 +		return;
 +
 +	switch (dev->phydev->speed) {
 +	case SPEED_1000:
 +		mcr |= MAC_MCR_SPEED_1000;
 +		break;
 +	case SPEED_100:
 +		mcr |= MAC_MCR_SPEED_100;
 +		break;
 +	};
  
 -		regmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,
 -				   SYSCFG0_SGMII_MASK,
 -				   ~(u32)SYSCFG0_SGMII_MASK);
 +	if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII) &&
 +	    !mac->id && !mac->trgmii)
 +		mtk_gmac0_rgmii_adjust(mac->hw, dev->phydev->speed);
  
 -		/* Decide how GMAC and SGMIISYS be mapped */
 -		sid = (MTK_HAS_CAPS(eth->soc->caps, MTK_SHARED_SGMII)) ?
 -		       0 : mac->id;
 +	if (dev->phydev->link)
 +		mcr |= MAC_MCR_FORCE_LINK;
  
 -		/* Setup SGMIISYS with the determined property */
 -		if (state->interface != PHY_INTERFACE_MODE_SGMII)
 -			err = mtk_sgmii_setup_mode_force(eth->sgmii, sid,
 -							 state);
 -		else if (phylink_autoneg_inband(mode))
 -			err = mtk_sgmii_setup_mode_an(eth->sgmii, sid);
 +	if (dev->phydev->duplex) {
 +		mcr |= MAC_MCR_FORCE_DPX;
  
 -		if (err)
 -			goto init_err;
 +		if (dev->phydev->pause)
 +			rmt_adv = LPA_PAUSE_CAP;
 +		if (dev->phydev->asym_pause)
 +			rmt_adv |= LPA_PAUSE_ASYM;
  
 -		regmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,
 -				   SYSCFG0_SGMII_MASK, val);
 -	} else if (phylink_autoneg_inband(mode)) {
 -		dev_err(eth->dev,
 -			"In-band mode not supported in non SGMII mode!\n");
 -		return;
 +		lcl_adv = linkmode_adv_to_lcl_adv_t(dev->phydev->advertising);
 +		flowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);
 +
 +		if (flowctrl & FLOW_CTRL_TX)
 +			mcr |= MAC_MCR_FORCE_TX_FC;
 +		if (flowctrl & FLOW_CTRL_RX)
 +			mcr |= MAC_MCR_FORCE_RX_FC;
 +
 +		netif_dbg(mac->hw, link, dev, "rx pause %s, tx pause %s\n",
 +			  flowctrl & FLOW_CTRL_RX ? "enabled" : "disabled",
 +			  flowctrl & FLOW_CTRL_TX ? "enabled" : "disabled");
  	}
  
 -	/* Setup gmac */
 -	mcr_cur = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
 -	mcr_new = mcr_cur;
 -	mcr_new &= ~(MAC_MCR_SPEED_100 | MAC_MCR_SPEED_1000 |
 -		     MAC_MCR_FORCE_DPX | MAC_MCR_FORCE_TX_FC |
 -		     MAC_MCR_FORCE_RX_FC);
 -	mcr_new |= MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |
 -		   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_LINK;
 +	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
 +
 +	if (dev->phydev->link)
 +		netif_carrier_on(dev);
 +	else
 +		netif_carrier_off(dev);
  
 -	switch (state->speed) {
 -	case SPEED_2500:
 -	case SPEED_1000:
 -		mcr_new |= MAC_MCR_SPEED_1000;
 +	if (!of_phy_is_fixed_link(mac->of_node))
 +		phy_print_status(dev->phydev);
 +}
 +
 +static int mtk_phy_connect_node(struct mtk_eth *eth, struct mtk_mac *mac,
 +				struct device_node *phy_node)
 +{
 +	struct phy_device *phydev;
 +	int phy_mode;
 +
 +	phy_mode = of_get_phy_mode(phy_node);
 +	if (phy_mode < 0) {
 +		dev_err(eth->dev, "incorrect phy-mode %d\n", phy_mode);
 +		return -EINVAL;
 +	}
 +
 +	phydev = of_phy_connect(eth->netdev[mac->id], phy_node,
 +				mtk_phy_link_adjust, 0, phy_mode);
 +	if (!phydev) {
 +		dev_err(eth->dev, "could not connect to PHY\n");
 +		return -ENODEV;
 +	}
 +
 +	dev_info(eth->dev,
 +		 "connected mac %d to PHY at %s [uid=%08x, driver=%s]\n",
 +		 mac->id, phydev_name(phydev), phydev->phy_id,
 +		 phydev->drv->name);
 +
 +	return 0;
 +}
 +
 +static int mtk_phy_connect(struct net_device *dev)
 +{
 +	struct mtk_mac *mac = netdev_priv(dev);
 +	struct mtk_eth *eth;
 +	struct device_node *np;
 +	u32 val;
 +
 +	eth = mac->hw;
 +	np = of_parse_phandle(mac->of_node, "phy-handle", 0);
 +	if (!np && of_phy_is_fixed_link(mac->of_node))
 +		if (!of_phy_register_fixed_link(mac->of_node))
 +			np = of_node_get(mac->of_node);
 +	if (!np)
 +		return -ENODEV;
 +
 +	mac->ge_mode = 0;
 +	switch (of_get_phy_mode(np)) {
 +	case PHY_INTERFACE_MODE_TRGMII:
 +		mac->trgmii = true;
 +	case PHY_INTERFACE_MODE_RGMII_TXID:
 +	case PHY_INTERFACE_MODE_RGMII_RXID:
 +	case PHY_INTERFACE_MODE_RGMII_ID:
 +	case PHY_INTERFACE_MODE_RGMII:
  		break;
 -	case SPEED_100:
 -		mcr_new |= MAC_MCR_SPEED_100;
 +	case PHY_INTERFACE_MODE_SGMII:
 +		if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII))
 +			mtk_gmac_sgmii_hw_setup(eth, mac->id);
  		break;
 -	}
 -	if (state->duplex == DUPLEX_FULL) {
 -		mcr_new |= MAC_MCR_FORCE_DPX;
 -		if (state->pause & MLO_PAUSE_TX)
 -			mcr_new |= MAC_MCR_FORCE_TX_FC;
 -		if (state->pause & MLO_PAUSE_RX)
 -			mcr_new |= MAC_MCR_FORCE_RX_FC;
 +	case PHY_INTERFACE_MODE_MII:
 +		mac->ge_mode = 1;
 +		break;
 +	case PHY_INTERFACE_MODE_REVMII:
 +		mac->ge_mode = 2;
 +		break;
 +	case PHY_INTERFACE_MODE_RMII:
 +		if (!mac->id)
 +			goto err_phy;
 +		mac->ge_mode = 3;
 +		break;
 +	default:
 +		goto err_phy;
  	}
  
 -	/* Only update control register when needed! */
 -	if (mcr_new != mcr_cur)
 -		mtk_w32(mac->hw, mcr_new, MTK_MAC_MCR(mac->id));
 +	/* put the gmac into the right mode */
 +	regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
 +	val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);
 +	val |= SYSCFG0_GE_MODE(mac->ge_mode, mac->id);
 +	regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
  
 -	return;
 +	/* couple phydev to net_device */
 +	if (mtk_phy_connect_node(eth, mac, np))
 +		goto err_phy;
  
 -err_phy:
 -	dev_err(eth->dev, "%s: GMAC%d mode %s not supported!\n", __func__,
 -		mac->id, phy_modes(state->interface));
 -	return;
 +	dev->phydev->autoneg = AUTONEG_ENABLE;
 +	dev->phydev->speed = 0;
 +	dev->phydev->duplex = 0;
 +
 +	phy_set_max_speed(dev->phydev, SPEED_1000);
 +	phy_support_asym_pause(dev->phydev);
 +	linkmode_copy(dev->phydev->advertising, dev->phydev->supported);
 +	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
 +			 dev->phydev->advertising);
 +	phy_start_aneg(dev->phydev);
 +
 +	of_node_put(np);
 +
 +	return 0;
  
 -init_err:
 -	dev_err(eth->dev, "%s: GMAC%d mode %s err: %d!\n", __func__,
 -		mac->id, phy_modes(state->interface), err);
 +err_phy:
 +	if (of_phy_is_fixed_link(mac->of_node))
 +		of_phy_deregister_fixed_link(mac->of_node);
 +	of_node_put(np);
 +	dev_err(eth->dev, "%s: invalid phy\n", __func__);
 +	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static void mtk_mac_pcs_get_state(struct phylink_config *config,
+ 				  struct phylink_link_state *state)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 	u32 pmsr = mtk_r32(mac->hw, MTK_MAC_MSR(mac->id));
+ 
+ 	state->link = (pmsr & MAC_MSR_LINK);
+ 	state->duplex = (pmsr & MAC_MSR_DPX) >> 1;
+ 
+ 	switch (pmsr & (MAC_MSR_SPEED_1000 | MAC_MSR_SPEED_100)) {
+ 	case 0:
+ 		state->speed = SPEED_10;
+ 		break;
+ 	case MAC_MSR_SPEED_100:
+ 		state->speed = SPEED_100;
+ 		break;
+ 	case MAC_MSR_SPEED_1000:
+ 		state->speed = SPEED_1000;
+ 		break;
+ 	default:
+ 		state->speed = SPEED_UNKNOWN;
+ 		break;
+ 	}
+ 
+ 	state->pause &= (MLO_PAUSE_RX | MLO_PAUSE_TX);
+ 	if (pmsr & MAC_MSR_RX_FC)
+ 		state->pause |= MLO_PAUSE_RX;
+ 	if (pmsr & MAC_MSR_TX_FC)
+ 		state->pause |= MLO_PAUSE_TX;
+ }
+ 
+ static void mtk_mac_an_restart(struct phylink_config *config)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 
+ 	mtk_sgmii_restart_an(mac->hw, mac->id);
+ }
+ 
+ static void mtk_mac_link_down(struct phylink_config *config, unsigned int mode,
+ 			      phy_interface_t interface)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 	u32 mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
+ 
+ 	mcr &= ~(MAC_MCR_TX_EN | MAC_MCR_RX_EN);
+ 	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
+ }
+ 
+ static void mtk_mac_link_up(struct phylink_config *config,
+ 			    struct phy_device *phy,
+ 			    unsigned int mode, phy_interface_t interface,
+ 			    int speed, int duplex, bool tx_pause, bool rx_pause)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 	u32 mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
+ 
+ 	mcr |= MAC_MCR_TX_EN | MAC_MCR_RX_EN;
+ 	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
+ }
+ 
+ static void mtk_validate(struct phylink_config *config,
+ 			 unsigned long *supported,
+ 			 struct phylink_link_state *state)
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != PHY_INTERFACE_MODE_MII &&
+ 	    state->interface != PHY_INTERFACE_MODE_GMII &&
+ 	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_RGMII) &&
+ 	      phy_interface_mode_is_rgmii(state->interface)) &&
+ 	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_TRGMII) &&
+ 	      !mac->id && state->interface == PHY_INTERFACE_MODE_TRGMII) &&
+ 	    !(MTK_HAS_CAPS(mac->hw->soc->caps, MTK_SGMII) &&
+ 	      (state->interface == PHY_INTERFACE_MODE_SGMII ||
+ 	       phy_interface_mode_is_8023z(state->interface)))) {
+ 		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+ 	phylink_set_port_modes(mask);
+ 	phylink_set(mask, Autoneg);
+ 
+ 	switch (state->interface) {
+ 	case PHY_INTERFACE_MODE_TRGMII:
+ 		phylink_set(mask, 1000baseT_Full);
+ 		break;
+ 	case PHY_INTERFACE_MODE_1000BASEX:
+ 	case PHY_INTERFACE_MODE_2500BASEX:
+ 		phylink_set(mask, 1000baseX_Full);
+ 		phylink_set(mask, 2500baseX_Full);
+ 		break;
+ 	case PHY_INTERFACE_MODE_GMII:
+ 	case PHY_INTERFACE_MODE_RGMII:
+ 	case PHY_INTERFACE_MODE_RGMII_ID:
+ 	case PHY_INTERFACE_MODE_RGMII_RXID:
+ 	case PHY_INTERFACE_MODE_RGMII_TXID:
+ 		phylink_set(mask, 1000baseT_Half);
+ 		/* fall through */
+ 	case PHY_INTERFACE_MODE_SGMII:
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseX_Full);
+ 		/* fall through */
+ 	case PHY_INTERFACE_MODE_MII:
+ 	case PHY_INTERFACE_MODE_RMII:
+ 	case PHY_INTERFACE_MODE_REVMII:
+ 	case PHY_INTERFACE_MODE_NA:
+ 	default:
+ 		phylink_set(mask, 10baseT_Half);
+ 		phylink_set(mask, 10baseT_Full);
+ 		phylink_set(mask, 100baseT_Half);
+ 		phylink_set(mask, 100baseT_Full);
+ 		break;
+ 	}
+ 
+ 	if (state->interface == PHY_INTERFACE_MODE_NA) {
+ 		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_SGMII)) {
+ 			phylink_set(mask, 1000baseT_Full);
+ 			phylink_set(mask, 1000baseX_Full);
+ 			phylink_set(mask, 2500baseX_Full);
+ 		}
+ 		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_RGMII)) {
+ 			phylink_set(mask, 1000baseT_Full);
+ 			phylink_set(mask, 1000baseT_Half);
+ 			phylink_set(mask, 1000baseX_Full);
+ 		}
+ 		if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GEPHY)) {
+ 			phylink_set(mask, 1000baseT_Full);
+ 			phylink_set(mask, 1000baseT_Half);
+ 		}
+ 	}
+ 
+ 	phylink_set(mask, Pause);
+ 	phylink_set(mask, Asym_Pause);
+ 
+ 	linkmode_and(supported, supported, mask);
+ 	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	/* We can only operate at 2500BaseX or 1000BaseX. If requested
+ 	 * to advertise both, only report advertising at 2500BaseX.
+ 	 */
+ 	phylink_helper_basex_speed(state);
+ }
+ 
+ static const struct phylink_mac_ops mtk_phylink_ops = {
+ 	.validate = mtk_validate,
+ 	.mac_pcs_get_state = mtk_mac_pcs_get_state,
+ 	.mac_an_restart = mtk_mac_an_restart,
+ 	.mac_config = mtk_mac_config,
+ 	.mac_link_down = mtk_mac_link_down,
+ 	.mac_link_up = mtk_mac_link_up,
+ };
+ 
++>>>>>>> 91a208f2185a (net: phylink: propagate resolved link config via mac_link_up())
  static int mtk_mdio_init(struct mtk_eth *eth)
  {
  	struct device_node *mii_np;
diff --cc drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index f24f48f33802,197740781157..000000000000
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@@ -1296,8 -1367,140 +1296,145 @@@ static const struct ethtool_ops axienet
  	.set_pauseparam = axienet_ethtools_set_pauseparam,
  	.get_coalesce   = axienet_ethtools_get_coalesce,
  	.set_coalesce   = axienet_ethtools_set_coalesce,
++<<<<<<< HEAD
 +	.get_link_ksettings = phy_ethtool_get_link_ksettings,
 +	.set_link_ksettings = phy_ethtool_set_link_ksettings,
++=======
+ 	.get_link_ksettings = axienet_ethtools_get_link_ksettings,
+ 	.set_link_ksettings = axienet_ethtools_set_link_ksettings,
+ };
+ 
+ static void axienet_validate(struct phylink_config *config,
+ 			     unsigned long *supported,
+ 			     struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	/* Only support the mode we are configured for */
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != lp->phy_mode) {
+ 		netdev_warn(ndev, "Cannot use PHY mode %s, supported: %s\n",
+ 			    phy_modes(state->interface),
+ 			    phy_modes(lp->phy_mode));
+ 		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 		return;
+ 	}
+ 
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set_port_modes(mask);
+ 
+ 	phylink_set(mask, Asym_Pause);
+ 	phylink_set(mask, Pause);
+ 	phylink_set(mask, 1000baseX_Full);
+ 	phylink_set(mask, 10baseT_Full);
+ 	phylink_set(mask, 100baseT_Full);
+ 	phylink_set(mask, 1000baseT_Full);
+ 
+ 	bitmap_and(supported, supported, mask,
+ 		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 	bitmap_and(state->advertising, state->advertising, mask,
+ 		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+ }
+ 
+ static void axienet_mac_pcs_get_state(struct phylink_config *config,
+ 				      struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	u32 emmc_reg, fcc_reg;
+ 
+ 	state->interface = lp->phy_mode;
+ 
+ 	emmc_reg = axienet_ior(lp, XAE_EMMC_OFFSET);
+ 	if (emmc_reg & XAE_EMMC_LINKSPD_1000)
+ 		state->speed = SPEED_1000;
+ 	else if (emmc_reg & XAE_EMMC_LINKSPD_100)
+ 		state->speed = SPEED_100;
+ 	else
+ 		state->speed = SPEED_10;
+ 
+ 	state->pause = 0;
+ 	fcc_reg = axienet_ior(lp, XAE_FCC_OFFSET);
+ 	if (fcc_reg & XAE_FCC_FCTX_MASK)
+ 		state->pause |= MLO_PAUSE_TX;
+ 	if (fcc_reg & XAE_FCC_FCRX_MASK)
+ 		state->pause |= MLO_PAUSE_RX;
+ 
+ 	state->an_complete = 0;
+ 	state->duplex = 1;
+ }
+ 
+ static void axienet_mac_an_restart(struct phylink_config *config)
+ {
+ 	/* Unsupported, do nothing */
+ }
+ 
+ static void axienet_mac_config(struct phylink_config *config, unsigned int mode,
+ 			       const struct phylink_link_state *state)
+ {
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct axienet_local *lp = netdev_priv(ndev);
+ 	u32 emmc_reg, fcc_reg;
+ 
+ 	emmc_reg = axienet_ior(lp, XAE_EMMC_OFFSET);
+ 	emmc_reg &= ~XAE_EMMC_LINKSPEED_MASK;
+ 
+ 	switch (state->speed) {
+ 	case SPEED_1000:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_1000;
+ 		break;
+ 	case SPEED_100:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_100;
+ 		break;
+ 	case SPEED_10:
+ 		emmc_reg |= XAE_EMMC_LINKSPD_10;
+ 		break;
+ 	default:
+ 		dev_err(&ndev->dev,
+ 			"Speed other than 10, 100 or 1Gbps is not supported\n");
+ 		break;
+ 	}
+ 
+ 	axienet_iow(lp, XAE_EMMC_OFFSET, emmc_reg);
+ 
+ 	fcc_reg = axienet_ior(lp, XAE_FCC_OFFSET);
+ 	if (state->pause & MLO_PAUSE_TX)
+ 		fcc_reg |= XAE_FCC_FCTX_MASK;
+ 	else
+ 		fcc_reg &= ~XAE_FCC_FCTX_MASK;
+ 	if (state->pause & MLO_PAUSE_RX)
+ 		fcc_reg |= XAE_FCC_FCRX_MASK;
+ 	else
+ 		fcc_reg &= ~XAE_FCC_FCRX_MASK;
+ 	axienet_iow(lp, XAE_FCC_OFFSET, fcc_reg);
+ }
+ 
+ static void axienet_mac_link_down(struct phylink_config *config,
+ 				  unsigned int mode,
+ 				  phy_interface_t interface)
+ {
+ 	/* nothing meaningful to do */
+ }
+ 
+ static void axienet_mac_link_up(struct phylink_config *config,
+ 				struct phy_device *phy,
+ 				unsigned int mode, phy_interface_t interface,
+ 				int speed, int duplex,
+ 				bool tx_pause, bool rx_pause)
+ {
+ 	/* nothing meaningful to do */
+ }
+ 
+ static const struct phylink_mac_ops axienet_phylink_ops = {
+ 	.validate = axienet_validate,
+ 	.mac_pcs_get_state = axienet_mac_pcs_get_state,
+ 	.mac_an_restart = axienet_mac_an_restart,
+ 	.mac_config = axienet_mac_config,
+ 	.mac_link_down = axienet_mac_link_down,
+ 	.mac_link_up = axienet_mac_link_up,
++>>>>>>> 91a208f2185a (net: phylink: propagate resolved link config via mac_link_up())
  };
  
  /**
diff --cc drivers/net/phy/phylink.c
index ae02f9650b4a,b4367fab7899..000000000000
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@@ -513,8 -480,11 +513,16 @@@ static void phylink_mac_link_up(struct 
  	struct net_device *ndev = pl->netdev;
  
  	pl->cur_interface = link_state.interface;
++<<<<<<< HEAD
 +	pl->ops->mac_link_up(pl->config, pl->link_an_mode,
 +			     pl->cur_interface, pl->phydev);
++=======
+ 	pl->ops->mac_link_up(pl->config, pl->phydev,
+ 			     pl->cur_link_an_mode, pl->cur_interface,
+ 			     link_state.speed, link_state.duplex,
+ 			     !!(link_state.pause & MLO_PAUSE_TX),
+ 			     !!(link_state.pause & MLO_PAUSE_RX));
++>>>>>>> 91a208f2185a (net: phylink: propagate resolved link config via mac_link_up())
  
  	if (ndev)
  		netif_carrier_on(ndev);
diff --cc net/dsa/port.c
index 2d7e01b23572,b2f5262b35cf..000000000000
--- a/net/dsa/port.c
+++ b/net/dsa/port.c
@@@ -294,6 -414,108 +294,110 @@@ static struct phy_device *dsa_port_get_
  	return phydev;
  }
  
++<<<<<<< HEAD
++=======
+ static void dsa_port_phylink_validate(struct phylink_config *config,
+ 				      unsigned long *supported,
+ 				      struct phylink_link_state *state)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->phylink_validate)
+ 		return;
+ 
+ 	ds->ops->phylink_validate(ds, dp->index, supported, state);
+ }
+ 
+ static void dsa_port_phylink_mac_pcs_get_state(struct phylink_config *config,
+ 					       struct phylink_link_state *state)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	/* Only called for inband modes */
+ 	if (!ds->ops->phylink_mac_link_state) {
+ 		state->link = 0;
+ 		return;
+ 	}
+ 
+ 	if (ds->ops->phylink_mac_link_state(ds, dp->index, state) < 0)
+ 		state->link = 0;
+ }
+ 
+ static void dsa_port_phylink_mac_config(struct phylink_config *config,
+ 					unsigned int mode,
+ 					const struct phylink_link_state *state)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->phylink_mac_config)
+ 		return;
+ 
+ 	ds->ops->phylink_mac_config(ds, dp->index, mode, state);
+ }
+ 
+ static void dsa_port_phylink_mac_an_restart(struct phylink_config *config)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->phylink_mac_an_restart)
+ 		return;
+ 
+ 	ds->ops->phylink_mac_an_restart(ds, dp->index);
+ }
+ 
+ static void dsa_port_phylink_mac_link_down(struct phylink_config *config,
+ 					   unsigned int mode,
+ 					   phy_interface_t interface)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct phy_device *phydev = NULL;
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (dsa_is_user_port(ds, dp->index))
+ 		phydev = dp->slave->phydev;
+ 
+ 	if (!ds->ops->phylink_mac_link_down) {
+ 		if (ds->ops->adjust_link && phydev)
+ 			ds->ops->adjust_link(ds, dp->index, phydev);
+ 		return;
+ 	}
+ 
+ 	ds->ops->phylink_mac_link_down(ds, dp->index, mode, interface);
+ }
+ 
+ static void dsa_port_phylink_mac_link_up(struct phylink_config *config,
+ 					 struct phy_device *phydev,
+ 					 unsigned int mode,
+ 					 phy_interface_t interface,
+ 					 int speed, int duplex,
+ 					 bool tx_pause, bool rx_pause)
+ {
+ 	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+ 	struct dsa_switch *ds = dp->ds;
+ 
+ 	if (!ds->ops->phylink_mac_link_up) {
+ 		if (ds->ops->adjust_link && phydev)
+ 			ds->ops->adjust_link(ds, dp->index, phydev);
+ 		return;
+ 	}
+ 
+ 	ds->ops->phylink_mac_link_up(ds, dp->index, mode, interface, phydev);
+ }
+ 
+ const struct phylink_mac_ops dsa_port_phylink_mac_ops = {
+ 	.validate = dsa_port_phylink_validate,
+ 	.mac_pcs_get_state = dsa_port_phylink_mac_pcs_get_state,
+ 	.mac_config = dsa_port_phylink_mac_config,
+ 	.mac_an_restart = dsa_port_phylink_mac_an_restart,
+ 	.mac_link_down = dsa_port_phylink_mac_link_down,
+ 	.mac_link_up = dsa_port_phylink_mac_link_up,
+ };
+ 
++>>>>>>> 91a208f2185a (net: phylink: propagate resolved link config via mac_link_up())
  static int dsa_port_setup_phy_of(struct dsa_port *dp, bool enable)
  {
  	struct dsa_switch *ds = dp->ds;
* Unmerged path drivers/net/ethernet/freescale/dpaa2/dpaa2-mac.c
diff --git a/Documentation/networking/sfp-phylink.rst b/Documentation/networking/sfp-phylink.rst
index 13c07764ff63..2f286087da0f 100644
--- a/Documentation/networking/sfp-phylink.rst
+++ b/Documentation/networking/sfp-phylink.rst
@@ -73,10 +73,13 @@ phylib to the sfp/phylink support.  Please send patches to improve
 this documentation.
 
 1. Optionally split the network driver's phylib update function into
-   three parts dealing with link-down, link-up and reconfiguring the
-   MAC settings. This can be done as a separate preparation commit.
+   two parts dealing with link-down and link-up. This can be done as
+   a separate preparation commit.
 
-   An example of this preparation can be found in git commit fc548b991fb0.
+   An older example of this preparation can be found in git commit
+   fc548b991fb0, although this was splitting into three parts; the
+   link-up part now includes configuring the MAC for the link settings.
+   Please see :c:func:`mac_link_up` for more information on this.
 
 2. Replace::
 
@@ -206,6 +209,14 @@ this documentation.
    using. This is particularly important for in-band negotiation
    methods such as 1000base-X and SGMII.
 
+   The :c:func:`mac_link_up` method is used to inform the MAC that the
+   link has come up. The call includes the negotiation mode and interface
+   for reference only. The finalised link parameters are also supplied
+   (speed, duplex and flow control/pause enablement settings) which
+   should be used to configure the MAC when the MAC and PCS are not
+   tightly integrated, or when the settings are not coming from in-band
+   negotiation.
+
    The :c:func:`mac_config` method is used to update the MAC with the
    requested state, and must avoid unnecessarily taking the link down
    when making changes to the MAC configuration.  This means the
* Unmerged path drivers/net/ethernet/cadence/macb_main.c
* Unmerged path drivers/net/ethernet/freescale/dpaa2/dpaa2-mac.c
diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index f2cdc95883b4..9ef6ee062246 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -3466,9 +3466,11 @@ static void mvneta_mac_link_down(struct phylink_config *config,
 	mvneta_set_eee(pp, false);
 }
 
-static void mvneta_mac_link_up(struct phylink_config *config, unsigned int mode,
-			       phy_interface_t interface,
-			       struct phy_device *phy)
+static void mvneta_mac_link_up(struct phylink_config *config,
+			       struct phy_device *phy,
+			       unsigned int mode, phy_interface_t interface,
+			       int speed, int duplex,
+			       bool tx_pause, bool rx_pause)
 {
 	struct net_device *ndev = to_net_dev(config->dev);
 	struct mvneta_port *pp = netdev_priv(ndev);
* Unmerged path drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
* Unmerged path drivers/net/ethernet/mediatek/mtk_eth_soc.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 43dd3a6c1732..104db3f2c629 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -960,8 +960,10 @@ static void stmmac_mac_link_down(struct phylink_config *config,
 }
 
 static void stmmac_mac_link_up(struct phylink_config *config,
+			       struct phy_device *phy,
 			       unsigned int mode, phy_interface_t interface,
-			       struct phy_device *phy)
+			       int speed, int duplex,
+			       bool tx_pause, bool rx_pause)
 {
 	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
 
* Unmerged path drivers/net/ethernet/xilinx/xilinx_axienet_main.c
* Unmerged path drivers/net/phy/phylink.c
diff --git a/include/linux/phylink.h b/include/linux/phylink.h
index 230e0d96c14c..d586982cd682 100644
--- a/include/linux/phylink.h
+++ b/include/linux/phylink.h
@@ -94,9 +94,10 @@ struct phylink_mac_ops {
 	void (*mac_an_restart)(struct phylink_config *config);
 	void (*mac_link_down)(struct phylink_config *config, unsigned int mode,
 			      phy_interface_t interface);
-	void (*mac_link_up)(struct phylink_config *config, unsigned int mode,
-			    phy_interface_t interface,
-			    struct phy_device *phy);
+	void (*mac_link_up)(struct phylink_config *config,
+			    struct phy_device *phy, unsigned int mode,
+			    phy_interface_t interface, int speed, int duplex,
+			    bool tx_pause, bool rx_pause);
 };
 
 #if 0 /* For kernel-doc purposes only. */
@@ -154,6 +155,9 @@ int mac_link_state(struct phylink_config *config,
  * guaranteed to be correct, and so any mac_config() implementation must
  * never reference these fields.
  *
+ * (this requires a rewrite - please refer to mac_link_up() for situations
+ *  where the PCS and MAC are not tightly integrated.)
+ *
  * In all negotiation modes, as defined by @mode, @state->pause indicates the
  * pause settings which should be applied as follows. If %MLO_PAUSE_AN is not
  * set, %MLO_PAUSE_TX and %MLO_PAUSE_RX indicate whether the MAC should send
@@ -164,12 +168,20 @@ int mac_link_state(struct phylink_config *config,
  * The action performed depends on the currently selected mode:
  *
  * %MLO_AN_FIXED, %MLO_AN_PHY:
- *   Configure the specified @state->speed and @state->duplex over a link
- *   specified by @state->interface. @state->advertising may be used, but
- *   is not required. Pause modes as above. Other members of @state must
- *   be ignored.
+ *   Configure for non-inband negotiation mode, where the link settings
+ *   are completely communicated via mac_link_up().  The physical link
+ *   protocol from the MAC is specified by @state->interface.
+ *
+ *   @state->advertising may be used, but is not required.
+ *
+ *   Older drivers (prior to the mac_link_up() change) may use @state->speed,
+ *   @state->duplex and @state->pause to configure the MAC, but this is
+ *   deprecated; such drivers should be converted to use mac_link_up().
  *
- *   Valid state members: interface, speed, duplex, pause, advertising.
+ *   Other members of @state must be ignored.
+ *
+ *   Valid state members: interface, advertising.
+ *   Deprecated state members: speed, duplex, pause.
  *
  * %MLO_AN_INBAND:
  *   place the link in an inband negotiation mode (such as 802.3z
@@ -230,19 +242,34 @@ void mac_link_down(struct phylink_config *config, unsigned int mode,
 /**
  * mac_link_up() - allow the link to come up
  * @config: a pointer to a &struct phylink_config.
+ * @phy: any attached phy
  * @mode: link autonegotiation mode
  * @interface: link &typedef phy_interface_t mode
- * @phy: any attached phy
+ * @speed: link speed
+ * @duplex: link duplex
+ * @tx_pause: link transmit pause enablement status
+ * @rx_pause: link receive pause enablement status
  *
- * If @mode is not an in-band negotiation mode (as defined by
- * phylink_autoneg_inband()), allow the link to come up. If @phy
- * is non-%NULL, configure Energy Efficient Ethernet by calling
+ * Configure the MAC for an established link.
+ *
+ * @speed, @duplex, @tx_pause and @rx_pause indicate the finalised link
+ * settings, and should be used to configure the MAC block appropriately
+ * where these settings are not automatically conveyed from the PCS block,
+ * or if in-band negotiation (as defined by phylink_autoneg_inband(@mode))
+ * is disabled.
+ *
+ * Note that when 802.3z in-band negotiation is in use, it is possible
+ * that the user wishes to override the pause settings, and this should
+ * be allowed when considering the implementation of this method.
+ *
+ * If in-band negotiation mode is disabled, allow the link to come up. If
+ * @phy is non-%NULL, configure Energy Efficient Ethernet by calling
  * phy_init_eee() and perform appropriate MAC configuration for EEE.
  * Interface type selection must be done in mac_config().
  */
-void mac_link_up(struct phylink_config *config, unsigned int mode,
-		 phy_interface_t interface,
-		 struct phy_device *phy);
+void mac_link_up(struct phylink_config *config, struct phy_device *phy,
+		 unsigned int mode, phy_interface_t interface,
+		 int speed, int duplex, bool tx_pause, bool rx_pause);
 #endif
 
 struct phylink *phylink_create(struct phylink_config *, struct fwnode_handle *,
* Unmerged path net/dsa/port.c
