x86/resctrl: Query LLC monitoring properties once during boot

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Reinette Chatre <reinette.chatre@intel.com>
commit 923f3a2b48bdccb6a1d1f0dd48de03de7ad936d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/923f3a2b.failed

Cache and memory bandwidth monitoring are features that are part of
x86 CPU resource control that is supported by the resctrl subsystem.
The monitoring properties are obtained via CPUID from every CPU
and only used within the resctrl subsystem where the properties are
only read from boot_cpu_data.

Obtain the monitoring properties once, placed in boot_cpu_data, via the
->c_bsp_init() helpers of the vendors that support X86_FEATURE_CQM_LLC.

	Suggested-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Reinette Chatre <reinette.chatre@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/6d74a6ac3e69f4b7a8b4115835f9455faf0f468d.1588715690.git.reinette.chatre@intel.com
(cherry picked from commit 923f3a2b48bdccb6a1d1f0dd48de03de7ad936d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/amd.c
#	arch/x86/kernel/cpu/common.c
#	arch/x86/kernel/cpu/intel.c
#	arch/x86/kernel/cpu/resctrl/core.c
diff --cc arch/x86/kernel/cpu/amd.c
index bdcf958b4de8,c36e89930965..000000000000
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@@ -16,6 -17,8 +16,11 @@@
  #include <asm/smp.h>
  #include <asm/pci-direct.h>
  #include <asm/delay.h>
++<<<<<<< HEAD
++=======
+ #include <asm/debugreg.h>
+ #include <asm/resctrl.h>
++>>>>>>> 923f3a2b48bd (x86/resctrl: Query LLC monitoring properties once during boot)
  
  #ifdef CONFIG_X86_64
  # include <asm/mmconfig.h>
diff --cc arch/x86/kernel/cpu/common.c
index d6857fdc914b,d07809286b95..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -52,11 -55,7 +52,14 @@@
  #include <asm/microcode_intel.h>
  #include <asm/intel-family.h>
  #include <asm/cpu_device_id.h>
 +#include <asm/spec_ctrl.h>
 +
 +#ifdef CONFIG_X86_LOCAL_APIC
  #include <asm/uv/uv.h>
++<<<<<<< HEAD
 +#endif
++=======
++>>>>>>> 923f3a2b48bd (x86/resctrl: Query LLC monitoring properties once during boot)
  
  #include "cpu.h"
  
@@@ -906,7 -921,6 +909,10 @@@ void get_cpu_cap(struct cpuinfo_x86 *c
  
  	init_scattered_cpuid_features(c);
  	init_speculation_control(c);
++<<<<<<< HEAD
 +	init_cqm(c);
++=======
++>>>>>>> 923f3a2b48bd (x86/resctrl: Query LLC monitoring properties once during boot)
  
  	/*
  	 * Clear/Set all flags overridden by options, after probe.
diff --cc arch/x86/kernel/cpu/intel.c
index 18eb4bce2c94,166d7c355896..000000000000
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@@ -22,7 -22,7 +22,11 @@@
  #include <asm/cpu_device_id.h>
  #include <asm/cmdline.h>
  #include <asm/traps.h>
++<<<<<<< HEAD
 +#include <asm/kdebug.h>
++=======
+ #include <asm/resctrl.h>
++>>>>>>> 923f3a2b48bd (x86/resctrl: Query LLC monitoring properties once during boot)
  
  #ifdef CONFIG_X86_64
  #include <linux/topology.h>
@@@ -1029,8 -967,8 +1038,9 @@@ static const struct cpu_dev intel_cpu_d
  #endif
  	.c_detect_tlb	= intel_detect_tlb,
  	.c_early_init   = early_init_intel,
+ 	.c_bsp_init	= bsp_init_intel,
  	.c_init		= init_intel,
 +	.c_bsp_resume	= intel_bsp_resume,
  	.c_x86_vendor	= X86_VENDOR_INTEL,
  };
  
diff --cc arch/x86/kernel/cpu/resctrl/core.c
index ff244480fe94,d5979073301e..000000000000
--- a/arch/x86/kernel/cpu/resctrl/core.c
+++ b/arch/x86/kernel/cpu/resctrl/core.c
@@@ -966,6 -958,31 +966,34 @@@ static __init void rdt_init_res_defs(vo
  
  static enum cpuhp_state rdt_online;
  
++<<<<<<< HEAD
++=======
+ /* Runs once on the BSP during boot. */
+ void resctrl_cpu_detect(struct cpuinfo_x86 *c)
+ {
+ 	if (!cpu_has(c, X86_FEATURE_CQM_LLC)) {
+ 		c->x86_cache_max_rmid  = -1;
+ 		c->x86_cache_occ_scale = -1;
+ 		return;
+ 	}
+ 
+ 	/* will be overridden if occupancy monitoring exists */
+ 	c->x86_cache_max_rmid = cpuid_ebx(0xf);
+ 
+ 	if (cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC) ||
+ 	    cpu_has(c, X86_FEATURE_CQM_MBM_TOTAL) ||
+ 	    cpu_has(c, X86_FEATURE_CQM_MBM_LOCAL)) {
+ 		u32 eax, ebx, ecx, edx;
+ 
+ 		/* QoS sub-leaf, EAX=0Fh, ECX=1 */
+ 		cpuid_count(0xf, 1, &eax, &ebx, &ecx, &edx);
+ 
+ 		c->x86_cache_max_rmid  = ecx;
+ 		c->x86_cache_occ_scale = ebx;
+ 	}
+ }
+ 
++>>>>>>> 923f3a2b48bd (x86/resctrl: Query LLC monitoring properties once during boot)
  static int __init resctrl_late_init(void)
  {
  	struct rdt_resource *r;
* Unmerged path arch/x86/kernel/cpu/amd.c
* Unmerged path arch/x86/kernel/cpu/common.c
* Unmerged path arch/x86/kernel/cpu/intel.c
* Unmerged path arch/x86/kernel/cpu/resctrl/core.c
