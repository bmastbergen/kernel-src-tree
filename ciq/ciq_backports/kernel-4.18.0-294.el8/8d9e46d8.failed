fold mount_pseudo_xattr() into pseudo_fs_get_tree()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 8d9e46d80777b484f8f0945c317ad618224d7811
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8d9e46d8.failed

... now that all other callers are gone

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 8d9e46d80777b484f8f0945c317ad618224d7811)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/libfs.c
#	include/linux/fs.h
diff --cc fs/libfs.c
index df5499c95c24,7df3c9a85f6b..000000000000
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@@ -285,59 -308,6 +312,62 @@@ struct pseudo_fs_context *init_pseudo(s
  }
  EXPORT_SYMBOL(init_pseudo);
  
++<<<<<<< HEAD
 +/*
 + * Common helper for pseudo-filesystems (sockfs, pipefs, bdev - stuff that
 + * will never be mountable)
 + */
 +struct dentry *mount_pseudo_xattr(struct file_system_type *fs_type, char *name,
 +	const struct super_operations *ops, const struct xattr_handler **xattr,
 +	const struct dentry_operations *dops, unsigned long magic)
 +{
 +	struct super_block *s;
 +	struct dentry *dentry;
 +	struct inode *root;
 +	struct qstr d_name = QSTR_INIT(name, strlen(name));
 +
 +	s = sget_userns(fs_type, NULL, set_anon_super, SB_KERNMOUNT|SB_NOUSER,
 +			&init_user_ns, NULL);
 +	if (IS_ERR(s))
 +		return ERR_CAST(s);
 +
 +	s->s_maxbytes = MAX_LFS_FILESIZE;
 +	s->s_blocksize = PAGE_SIZE;
 +	s->s_blocksize_bits = PAGE_SHIFT;
 +	s->s_magic = magic;
 +	s->s_op = ops ? ops : &simple_super_operations;
 +	s->s_xattr = xattr;
 +	s->s_time_gran = 1;
 +	root = new_inode(s);
 +	if (!root)
 +		goto Enomem;
 +	/*
 +	 * since this is the first inode, make it number 1. New inodes created
 +	 * after this must take care not to collide with it (by passing
 +	 * max_reserved of 1 to iunique).
 +	 */
 +	root->i_ino = 1;
 +	root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
 +	root->i_atime = root->i_mtime = root->i_ctime = current_time(root);
 +	dentry = __d_alloc(s, &d_name);
 +	if (!dentry) {
 +		iput(root);
 +		goto Enomem;
 +	}
 +	d_instantiate(dentry, root);
 +	s->s_root = dentry;
 +	s->s_d_op = dops;
 +	s->s_flags |= SB_ACTIVE;
 +	return dget(s->s_root);
 +
 +Enomem:
 +	deactivate_locked_super(s);
 +	return ERR_PTR(-ENOMEM);
 +}
 +EXPORT_SYMBOL(mount_pseudo_xattr);
 +
++=======
++>>>>>>> 8d9e46d80777 (fold mount_pseudo_xattr() into pseudo_fs_get_tree())
  int simple_open(struct inode *inode, struct file *file)
  {
  	if (inode->i_private)
diff --cc include/linux/fs.h
index feabaa0642d8,d625acabbfcf..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -2279,19 -2254,6 +2279,22 @@@ struct super_block *sget(struct file_sy
  			int (*test)(struct super_block *,void *),
  			int (*set)(struct super_block *,void *),
  			int flags, void *data);
++<<<<<<< HEAD
 +extern struct dentry *mount_pseudo_xattr(struct file_system_type *, char *,
 +					 const struct super_operations *ops,
 +					 const struct xattr_handler **xattr,
 +					 const struct dentry_operations *dops,
 +					 unsigned long);
 +
 +static inline struct dentry *
 +mount_pseudo(struct file_system_type *fs_type, char *name,
 +	     const struct super_operations *ops,
 +	     const struct dentry_operations *dops, unsigned long magic)
 +{
 +	return mount_pseudo_xattr(fs_type, name, ops, NULL, dops, magic);
 +}
++=======
++>>>>>>> 8d9e46d80777 (fold mount_pseudo_xattr() into pseudo_fs_get_tree())
  
  /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
  #define fops_get(fops) \
* Unmerged path fs/libfs.c
* Unmerged path include/linux/fs.h
