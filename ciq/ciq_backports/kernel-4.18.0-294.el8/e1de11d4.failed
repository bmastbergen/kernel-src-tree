x86/entry: Introduce local_db_{save,restore}()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] entry: Introduce local_db_{save, restore}() (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 94.38%
commit-author Peter Zijlstra <peterz@infradead.org>
commit e1de11d4d1a64ac1b90b9833f1a3629dae18facb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e1de11d4.failed

In order to allow other exceptions than #DB to disable breakpoints,
provide common helpers.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lkml.kernel.org/r/20200529213321.012060983@infradead.org



(cherry picked from commit e1de11d4d1a64ac1b90b9833f1a3629dae18facb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/traps.c
diff --cc arch/x86/kernel/traps.c
index bceb85be1c08,bcb9dd961c6d..000000000000
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@@ -707,6 -714,43 +707,46 @@@ static bool is_sysenter_singlestep(stru
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ static __always_inline void debug_enter(unsigned long *dr6, unsigned long *dr7)
+ {
+ 	/*
+ 	 * Disable breakpoints during exception handling; recursive exceptions
+ 	 * are exceedingly 'fun'.
+ 	 *
+ 	 * Since this function is NOKPROBE, and that also applies to
+ 	 * HW_BREAKPOINT_X, we can't hit a breakpoint before this (XXX except a
+ 	 * HW_BREAKPOINT_W on our stack)
+ 	 *
+ 	 * Entry text is excluded for HW_BP_X and cpu_entry_area, which
+ 	 * includes the entry stack is excluded for everything.
+ 	 */
+ 	*dr7 = local_db_save();
+ 
+ 	/*
+ 	 * The Intel SDM says:
+ 	 *
+ 	 *   Certain debug exceptions may clear bits 0-3. The remaining
+ 	 *   contents of the DR6 register are never cleared by the
+ 	 *   processor. To avoid confusion in identifying debug
+ 	 *   exceptions, debug handlers should clear the register before
+ 	 *   returning to the interrupted task.
+ 	 *
+ 	 * Keep it simple: clear DR6 immediately.
+ 	 */
+ 	get_debugreg(*dr6, 6);
+ 	set_debugreg(0, 6);
+ 	/* Filter out all the reserved bits which are preset to 1 */
+ 	*dr6 &= ~DR6_RESERVED;
+ }
+ 
+ static __always_inline void debug_exit(unsigned long dr7)
+ {
+ 	local_db_restore(dr7);
+ }
+ 
++>>>>>>> e1de11d4d1a6 (x86/entry: Introduce local_db_{save,restore}())
  /*
   * Our handling of the processor debug registers is non-trivial.
   * We do not clear them on entry and exit from the kernel. Therefore
diff --git a/arch/x86/include/asm/debugreg.h b/arch/x86/include/asm/debugreg.h
index 4505ac2735ad..701c58cb96a5 100644
--- a/arch/x86/include/asm/debugreg.h
+++ b/arch/x86/include/asm/debugreg.h
@@ -115,6 +115,36 @@ static inline void debug_stack_usage_inc(void) { }
 static inline void debug_stack_usage_dec(void) { }
 #endif /* X86_64 */
 
+static __always_inline unsigned long local_db_save(void)
+{
+	unsigned long dr7;
+
+	get_debugreg(dr7, 7);
+	dr7 &= ~0x400; /* architecturally set bit */
+	if (dr7)
+		set_debugreg(0, 7);
+	/*
+	 * Ensure the compiler doesn't lower the above statements into
+	 * the critical section; disabling breakpoints late would not
+	 * be good.
+	 */
+	barrier();
+
+	return dr7;
+}
+
+static __always_inline void local_db_restore(unsigned long dr7)
+{
+	/*
+	 * Ensure the compiler doesn't raise this statement into
+	 * the critical section; enabling breakpoints early would
+	 * not be good.
+	 */
+	barrier();
+	if (dr7)
+		set_debugreg(dr7, 7);
+}
+
 #ifdef CONFIG_CPU_SUP_AMD
 extern void set_dr_addr_mask(unsigned long mask, int dr);
 #else
* Unmerged path arch/x86/kernel/traps.c
