virtio: virtio_has_iommu_quirk -> virtio_has_dma_quirk

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michael S. Tsirkin <mst@redhat.com>
commit 24b6842ade6925199e182988259761504aacfbc0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/24b6842a.failed

Now that the corresponding feature bit has been renamed,
rename the quirk too - it's about special ways to
do DMA, not necessarily about the IOMMU.

	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit 24b6842ade6925199e182988259761504aacfbc0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/virtio/virtgpu_object.c
#	drivers/gpu/drm/virtio/virtgpu_vq.c
diff --cc drivers/gpu/drm/virtio/virtgpu_object.c
index 3af7ec80c7da,e8799ab0c753..000000000000
--- a/drivers/gpu/drm/virtio/virtgpu_object.c
+++ b/drivers/gpu/drm/virtio/virtgpu_object.c
@@@ -92,15 -118,69 +92,69 @@@ static const struct drm_gem_object_func
  struct drm_gem_object *virtio_gpu_create_object(struct drm_device *dev,
  						size_t size)
  {
 -	struct virtio_gpu_object_shmem *shmem;
 -	struct drm_gem_shmem_object *dshmem;
 +	struct virtio_gpu_object *bo;
  
 -	shmem = kzalloc(sizeof(*shmem), GFP_KERNEL);
 -	if (!shmem)
 +	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
 +	if (!bo)
  		return NULL;
  
++<<<<<<< HEAD
 +	bo->base.base.funcs = &virtio_gpu_gem_funcs;
 +	bo->base.map_cached = true;
 +	return &bo->base.base;
++=======
+ 	dshmem = &shmem->base.base;
+ 	dshmem->base.funcs = &virtio_gpu_shmem_funcs;
+ 	dshmem->map_cached = true;
+ 	return &dshmem->base;
+ }
+ 
+ static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev,
+ 					struct virtio_gpu_object *bo,
+ 					struct virtio_gpu_mem_entry **ents,
+ 					unsigned int *nents)
+ {
+ 	bool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev);
+ 	struct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo);
+ 	struct scatterlist *sg;
+ 	int si, ret;
+ 
+ 	ret = drm_gem_shmem_pin(&bo->base.base);
+ 	if (ret < 0)
+ 		return -EINVAL;
+ 
+ 	shmem->pages = drm_gem_shmem_get_sg_table(&bo->base.base);
+ 	if (!shmem->pages) {
+ 		drm_gem_shmem_unpin(&bo->base.base);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (use_dma_api) {
+ 		shmem->mapped = dma_map_sg(vgdev->vdev->dev.parent,
+ 					   shmem->pages->sgl,
+ 					   shmem->pages->nents,
+ 					   DMA_TO_DEVICE);
+ 		*nents = shmem->mapped;
+ 	} else {
+ 		*nents = shmem->pages->nents;
+ 	}
+ 
+ 	*ents = kmalloc_array(*nents, sizeof(struct virtio_gpu_mem_entry),
+ 			      GFP_KERNEL);
+ 	if (!(*ents)) {
+ 		DRM_ERROR("failed to allocate ent list\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for_each_sg(shmem->pages->sgl, sg, *nents, si) {
+ 		(*ents)[si].addr = cpu_to_le64(use_dma_api
+ 					       ? sg_dma_address(sg)
+ 					       : sg_phys(sg));
+ 		(*ents)[si].length = cpu_to_le32(sg->length);
+ 		(*ents)[si].padding = 0;
+ 	}
+ 	return 0;
++>>>>>>> 24b6842ade69 (virtio: virtio_has_iommu_quirk -> virtio_has_dma_quirk)
  }
  
  int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,
diff --cc drivers/gpu/drm/virtio/virtgpu_vq.c
index 5914e79d3429,53af60d484a4..000000000000
--- a/drivers/gpu/drm/virtio/virtgpu_vq.c
+++ b/drivers/gpu/drm/virtio/virtgpu_vq.c
@@@ -587,7 -599,8 +587,12 @@@ void virtio_gpu_cmd_transfer_to_host_2d
  	struct virtio_gpu_object *bo = gem_to_virtio_gpu_obj(objs->objs[0]);
  	struct virtio_gpu_transfer_to_host_2d *cmd_p;
  	struct virtio_gpu_vbuffer *vbuf;
++<<<<<<< HEAD
 +	bool use_dma_api = !virtio_has_iommu_quirk(vgdev->vdev);
++=======
+ 	bool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev);
+ 	struct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo);
++>>>>>>> 24b6842ade69 (virtio: virtio_has_iommu_quirk -> virtio_has_dma_quirk)
  
  	if (use_dma_api)
  		dma_sync_sg_for_device(vgdev->vdev->dev.parent,
@@@ -1002,7 -1015,8 +1007,12 @@@ void virtio_gpu_cmd_transfer_to_host_3d
  	struct virtio_gpu_object *bo = gem_to_virtio_gpu_obj(objs->objs[0]);
  	struct virtio_gpu_transfer_host_3d *cmd_p;
  	struct virtio_gpu_vbuffer *vbuf;
++<<<<<<< HEAD
 +	bool use_dma_api = !virtio_has_iommu_quirk(vgdev->vdev);
++=======
+ 	bool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev);
+ 	struct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo);
++>>>>>>> 24b6842ade69 (virtio: virtio_has_iommu_quirk -> virtio_has_dma_quirk)
  
  	if (use_dma_api)
  		dma_sync_sg_for_device(vgdev->vdev->dev.parent,
* Unmerged path drivers/gpu/drm/virtio/virtgpu_object.c
* Unmerged path drivers/gpu/drm/virtio/virtgpu_vq.c
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 2a27fadd57a6..f69d7b885b89 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -253,7 +253,7 @@ static inline bool virtqueue_use_indirect(struct virtqueue *_vq,
 
 static bool vring_use_dma_api(struct virtio_device *vdev)
 {
-	if (!virtio_has_iommu_quirk(vdev))
+	if (!virtio_has_dma_quirk(vdev))
 		return true;
 
 	/* Otherwise, we are left to guess. */
diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h
index d91ea998d177..30e702a38c7c 100644
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@ -157,10 +157,10 @@ static inline bool virtio_has_feature(const struct virtio_device *vdev,
 }
 
 /**
- * virtio_has_iommu_quirk - determine whether this device has the iommu quirk
+ * virtio_has_dma_quirk - determine whether this device has the DMA quirk
  * @vdev: the device
  */
-static inline bool virtio_has_iommu_quirk(const struct virtio_device *vdev)
+static inline bool virtio_has_dma_quirk(const struct virtio_device *vdev)
 {
 	/*
 	 * Note the reverse polarity of the quirk feature (compared to most
diff --git a/tools/virtio/linux/virtio_config.h b/tools/virtio/linux/virtio_config.h
index dbf14c1e2188..558aa578361e 100644
--- a/tools/virtio/linux/virtio_config.h
+++ b/tools/virtio/linux/virtio_config.h
@@ -42,10 +42,10 @@ static inline void __virtio_clear_bit(struct virtio_device *vdev,
 	(__virtio_test_bit((dev), feature))
 
 /**
- * virtio_has_iommu_quirk - determine whether this device has the iommu quirk
+ * virtio_has_dma_quirk - determine whether this device has the DMA quirk
  * @vdev: the device
  */
-static inline bool virtio_has_iommu_quirk(const struct virtio_device *vdev)
+static inline bool virtio_has_dma_quirk(const struct virtio_device *vdev)
 {
 	/*
 	 * Note the reverse polarity of the quirk feature (compared to most
