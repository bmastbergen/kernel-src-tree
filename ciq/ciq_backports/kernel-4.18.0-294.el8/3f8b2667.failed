mptcp: properly annotate nested lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 3f8b2667f257c21a992bda33bfb919ee164a429c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3f8b2667.failed

MPTCP closes the subflows while holding the msk-level lock.
While acquiring the subflow socket lock we need to use the
correct nested annotation, or we can hit a lockdep splat
at runtime.

Reported-and-tested-by: Geliang Tang <geliangtang@gmail.com>
Fixes: e16163b6e2b7 ("mptcp: refactor shutdown and close")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 3f8b2667f257c21a992bda33bfb919ee164a429c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 509aa48ee70d,64c0c54c80e8..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -1411,13 -2119,37 +1411,35 @@@ static void __mptcp_close_ssk(struct so
  
  	list_del(&subflow->node);
  
++<<<<<<< HEAD
 +	if (sock && sock != sk->sk_socket) {
 +		/* outgoing subflow */
 +		sock_release(sock);
++=======
+ 	lock_sock_nested(ssk, SINGLE_DEPTH_NESTING);
+ 
+ 	/* if we are invoked by the msk cleanup code, the subflow is
+ 	 * already orphaned
+ 	 */
+ 	sock = ssk->sk_socket;
+ 	if (sock) {
+ 		dispose_socket = sock != sk->sk_socket;
+ 		sock_orphan(ssk);
+ 	}
+ 
+ 	subflow->disposable = 1;
+ 
+ 	/* if ssk hit tcp_done(), tcp_cleanup_ulp() cleared the related ops
+ 	 * the ssk has been already destroyed, we just need to release the
+ 	 * reference owned by msk;
+ 	 */
+ 	if (!inet_csk(ssk)->icsk_ulp_ops) {
+ 		kfree_rcu(subflow, rcu);
++>>>>>>> 3f8b2667f257 (mptcp: properly annotate nested lock)
  	} else {
 -		/* otherwise tcp will dispose of the ssk and subflow ctx */
 -		__tcp_close(ssk, 0);
 -
 -		/* close acquired an extra ref */
 -		__sock_put(ssk);
 +		/* incoming subflow */
 +		tcp_close(ssk, timeout);
  	}
 -	release_sock(ssk);
 -	if (dispose_socket)
 -		iput(SOCK_INODE(sock));
 -
 -	sock_put(ssk);
  }
  
  static unsigned int mptcp_sync_mss(struct sock *sk, u32 pmtu)
* Unmerged path net/mptcp/protocol.c
