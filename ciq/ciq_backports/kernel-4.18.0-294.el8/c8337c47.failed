s390/ap: rework crypto config info and default domain code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit c8337c47deb9338417c61e7a6ba7de690eb1d300
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c8337c47.failed

Rework of the QCI crypto info and how it is used.
This is only a internal rework but does not affect the way
how the ap bus acts with ap card and queue devices and
domain handling.

Tested on z15, z14, z12 (QCI support) and z196 (no QCI support).

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit c8337c47deb9338417c61e7a6ba7de690eb1d300)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 70b945ce5806,f218a0b67ed5..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -105,16 -104,11 +104,24 @@@ static struct hrtimer ap_poll_timer
   */
  static unsigned long long poll_timeout = 250000;
  
++<<<<<<< HEAD
 +/* Suspend flag */
 +static int ap_suspend_flag;
 +/* Maximum domain id */
 +static int ap_max_domain_id;
 +/*
 + * Flag to check if domain was set through module parameter domain=. This is
 + * important when supsend and resume is done in a z/VM environment where the
 + * domain might change.
 + */
 +static int user_set_domain;
++=======
+ /* Maximum domain id, if not given via qci */
+ static int ap_max_domain_id = 15;
+ /* Maximum adapter id, if not given via qci */
+ static int ap_max_adapter_id = 63;
+ 
++>>>>>>> c8337c47deb9 (s390/ap: rework crypto config info and default domain code)
  static struct bus_type ap_bus_type;
  
  /* Adapter interrupt definitions */
@@@ -1479,16 -1376,14 +1497,18 @@@ static void _ap_scan_bus_adapter(int id
  			continue;
  		}
  		/* try to fetch infos about this queue */
- 		rc = ap_query_queue(qid, &depth, &type, &func);
+ 		broken = !ap_queue_info(qid, &type, &func, &depth);
  		if (dev) {
- 			if (rc == -ENODEV)
- 				borked = 1;
- 			else {
+ 			if (!broken) {
  				spin_lock_bh(&aq->lock);
++<<<<<<< HEAD
 +				borked = aq->state == AP_STATE_BORKED;
++=======
+ 				broken = aq->sm_state == AP_SM_STATE_BORKED;
++>>>>>>> c8337c47deb9 (s390/ap: rework crypto config info and default domain code)
  				spin_unlock_bh(&aq->lock);
  			}
- 			if (borked) {
+ 			if (broken) {
  				/* Remove broken device */
  				AP_DBF(DBF_DEBUG,
  				       "removing broken queue=%02x.%04x\n",
@@@ -1655,12 -1543,8 +1670,13 @@@ static int __init ap_module_init(void
  			ap_domain_index);
  		ap_domain_index = -1;
  	}
 +	/* In resume callback we need to know if the user had set the domain.
 +	 * If so, we can not just reset it.
 +	 */
 +	if (ap_domain_index >= 0)
 +		user_set_domain = 1;
  
+ 	/* enable interrupts if available */
  	if (ap_interrupts_available()) {
  		rc = register_adapter_interrupt(&ap_airq);
  		ap_airq_flag = (rc == 0);
@@@ -1702,12 -1586,7 +1718,11 @@@
  			goto out_work;
  	}
  
 +	rc = register_pm_notifier(&ap_power_notifier);
 +	if (rc)
 +		goto out_pm;
 +
  	queue_work(system_long_wq, &ap_scan_work);
- 	initialised = true;
  
  	return 0;
  
* Unmerged path drivers/s390/crypto/ap_bus.c
