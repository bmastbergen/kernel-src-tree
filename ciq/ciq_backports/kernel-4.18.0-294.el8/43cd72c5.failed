mac80211: factor out code to look up the average packet length duration for a rate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Felix Fietkau <nbd@nbd.name>
commit 43cd72c5892c46fe69b8a1682fb4905cf158c39c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/43cd72c5.failed

This will be used to enhance AQL estimated aggregation length

	Signed-off-by: Felix Fietkau <nbd@nbd.name>
	Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
Link: https://lore.kernel.org/r/20200821163045.62140-2-nbd@nbd.name
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 43cd72c5892c46fe69b8a1682fb4905cf158c39c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/airtime.c
diff --cc net/mac80211/airtime.c
index 9fc2968856c0,ba95f4ee1f71..000000000000
--- a/net/mac80211/airtime.c
+++ b/net/mac80211/airtime.c
@@@ -487,41 -503,100 +503,132 @@@ u32 ieee80211_calc_rx_airtime(struct ie
  }
  EXPORT_SYMBOL_GPL(ieee80211_calc_rx_airtime);
  
++<<<<<<< HEAD
++=======
+ static bool ieee80211_fill_rate_info(struct ieee80211_hw *hw,
+ 				     struct ieee80211_rx_status *stat, u8 band,
+ 				     struct rate_info *ri)
+ {
+ 	struct ieee80211_supported_band *sband = hw->wiphy->bands[band];
+ 	int i;
+ 
+ 	if (!ri || !sband)
+ 	    return false;
+ 
+ 	stat->bw = ri->bw;
+ 	stat->nss = ri->nss;
+ 	stat->rate_idx = ri->mcs;
+ 
+ 	if (ri->flags & RATE_INFO_FLAGS_HE_MCS)
+ 		stat->encoding = RX_ENC_HE;
+ 	else if (ri->flags & RATE_INFO_FLAGS_VHT_MCS)
+ 		stat->encoding = RX_ENC_VHT;
+ 	else if (ri->flags & RATE_INFO_FLAGS_MCS)
+ 		stat->encoding = RX_ENC_HT;
+ 	else
+ 		stat->encoding = RX_ENC_LEGACY;
+ 
+ 	if (ri->flags & RATE_INFO_FLAGS_SHORT_GI)
+ 		stat->enc_flags |= RX_ENC_FLAG_SHORT_GI;
+ 
+ 	stat->he_gi = ri->he_gi;
+ 
+ 	if (stat->encoding != RX_ENC_LEGACY)
+ 		return true;
+ 
+ 	stat->rate_idx = 0;
+ 	for (i = 0; i < sband->n_bitrates; i++) {
+ 		if (ri->legacy != sband->bitrates[i].bitrate)
+ 			continue;
+ 
+ 		stat->rate_idx = i;
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static int ieee80211_fill_rx_status(struct ieee80211_rx_status *stat,
+ 				    struct ieee80211_hw *hw,
+ 				    struct ieee80211_tx_rate *rate,
+ 				    struct rate_info *ri, u8 band, int len)
+ {
+ 	memset(stat, 0, sizeof(*stat));
+ 	stat->band = band;
+ 
+ 	if (ieee80211_fill_rate_info(hw, stat, band, ri))
+ 		return 0;
+ 
+ 	if (rate->idx < 0 || !rate->count)
+ 		return -1;
+ 
+ 	if (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)
+ 		stat->bw = RATE_INFO_BW_80;
+ 	else if (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+ 		stat->bw = RATE_INFO_BW_40;
+ 	else
+ 		stat->bw = RATE_INFO_BW_20;
+ 
+ 	stat->enc_flags = 0;
+ 	if (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)
+ 		stat->enc_flags |= RX_ENC_FLAG_SHORTPRE;
+ 	if (rate->flags & IEEE80211_TX_RC_SHORT_GI)
+ 		stat->enc_flags |= RX_ENC_FLAG_SHORT_GI;
+ 
+ 	stat->rate_idx = rate->idx;
+ 	if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {
+ 		stat->encoding = RX_ENC_VHT;
+ 		stat->rate_idx = ieee80211_rate_get_vht_mcs(rate);
+ 		stat->nss = ieee80211_rate_get_vht_nss(rate);
+ 	} else if (rate->flags & IEEE80211_TX_RC_MCS) {
+ 		stat->encoding = RX_ENC_HT;
+ 	} else {
+ 		stat->encoding = RX_ENC_LEGACY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 43cd72c5892c (mac80211: factor out code to look up the average packet length duration for a rate)
  static u32 ieee80211_calc_tx_airtime_rate(struct ieee80211_hw *hw,
  					  struct ieee80211_tx_rate *rate,
 -					  struct rate_info *ri,
  					  u8 band, int len)
  {
- 	struct ieee80211_rx_status stat = {
- 		.band = band,
- 	};
+ 	struct ieee80211_rx_status stat;
  
++<<<<<<< HEAD
 +	if (rate->idx < 0 || !rate->count)
 +		return 0;
 +
 +	if (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)
 +		stat.bw = RATE_INFO_BW_80;
 +	else if (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
 +		stat.bw = RATE_INFO_BW_40;
 +	else
 +		stat.bw = RATE_INFO_BW_20;
 +
 +	stat.enc_flags = 0;
 +	if (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)
 +		stat.enc_flags |= RX_ENC_FLAG_SHORTPRE;
 +	if (rate->flags & IEEE80211_TX_RC_SHORT_GI)
 +		stat.enc_flags |= RX_ENC_FLAG_SHORT_GI;
 +
 +	stat.rate_idx = rate->idx;
 +	if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {
 +		stat.encoding = RX_ENC_VHT;
 +		stat.rate_idx = ieee80211_rate_get_vht_mcs(rate);
 +		stat.nss = ieee80211_rate_get_vht_nss(rate);
 +	} else if (rate->flags & IEEE80211_TX_RC_MCS) {
 +		stat.encoding = RX_ENC_HT;
 +	} else {
 +		stat.encoding = RX_ENC_LEGACY;
 +	}
 +
++=======
+ 	if (ieee80211_fill_rx_status(&stat, hw, rate, ri, band, len))
+ 		return 0;
+ 
++>>>>>>> 43cd72c5892c (mac80211: factor out code to look up the average packet length duration for a rate)
  	return ieee80211_calc_rx_airtime(hw, &stat, len);
  }
  
* Unmerged path net/mac80211/airtime.c
