scsi: sr: get rid of sr global mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Merlijn Wajer <merlijn@archive.org>
commit 51a858817dcdbbdee22cb54b0b2b26eb145ca5b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/51a85881.failed

When replacing the Big Kernel Lock in commit 2a48fc0ab242 ("block:
autoconvert trivial BKL users to private mutex"), the lock was replaced
with a sr-wide lock.

This causes very poor performance when using multiple sr devices, as the sr
driver was not able to execute more than one command to one drive at any
given time, even when there were many CD drives available.

Replace the global mutex with per-sr-device mutex.

Someone tried this patch at the time, but it never made it upstream, due to
possible concerns with race conditions, but it's not clear the patch
actually caused those:

https://www.spinics.net/lists/linux-scsi/msg63706.html
https://www.spinics.net/lists/linux-scsi/msg63750.html

Also see

http://lists.xiph.org/pipermail/paranoia/2019-December/001647.html

Link: https://lore.kernel.org/r/20200218143918.30267-1-merlijn@archive.org
	Acked-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Merlijn Wajer <merlijn@archive.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 51a858817dcdbbdee22cb54b0b2b26eb145ca5b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/sr.c
diff --cc drivers/scsi/sr.c
index 22bd1ff79061,fe0e1c721a99..000000000000
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@@ -598,6 -598,51 +597,54 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_COMPAT
+ static int sr_block_compat_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
+ 			  unsigned long arg)
+ {
+ 	struct scsi_cd *cd = scsi_cd(bdev->bd_disk);
+ 	struct scsi_device *sdev = cd->device;
+ 	void __user *argp = compat_ptr(arg);
+ 	int ret;
+ 
+ 	mutex_lock(&cd->lock);
+ 
+ 	ret = scsi_ioctl_block_when_processing_errors(sdev, cmd,
+ 			(mode & FMODE_NDELAY) != 0);
+ 	if (ret)
+ 		goto out;
+ 
+ 	scsi_autopm_get_device(sdev);
+ 
+ 	/*
+ 	 * Send SCSI addressing ioctls directly to mid level, send other
+ 	 * ioctls to cdrom/block level.
+ 	 */
+ 	switch (cmd) {
+ 	case SCSI_IOCTL_GET_IDLUN:
+ 	case SCSI_IOCTL_GET_BUS_NUMBER:
+ 		ret = scsi_compat_ioctl(sdev, cmd, argp);
+ 		goto put;
+ 	}
+ 
+ 	ret = cdrom_ioctl(&cd->cdi, bdev, mode, cmd, (unsigned long)argp);
+ 	if (ret != -ENOSYS)
+ 		goto put;
+ 
+ 	ret = scsi_compat_ioctl(sdev, cmd, argp);
+ 
+ put:
+ 	scsi_autopm_put_device(sdev);
+ 
+ out:
+ 	mutex_unlock(&cd->lock);
+ 	return ret;
+ 
+ }
+ #endif
+ 
++>>>>>>> 51a858817dcd (scsi: sr: get rid of sr global mutex)
  static unsigned int sr_block_check_events(struct gendisk *disk,
  					  unsigned int clearing)
  {
* Unmerged path drivers/scsi/sr.c
diff --git a/drivers/scsi/sr.h b/drivers/scsi/sr.h
index a2bb7b8bace5..339c624e04d8 100644
--- a/drivers/scsi/sr.h
+++ b/drivers/scsi/sr.h
@@ -20,6 +20,7 @@
 
 #include <linux/genhd.h>
 #include <linux/kref.h>
+#include <linux/mutex.h>
 
 #define MAX_RETRIES	3
 #define SR_TIMEOUT	(30 * HZ)
@@ -51,6 +52,7 @@ typedef struct scsi_cd {
 	bool ignore_get_event:1;	/* GET_EVENT is unreliable, use TUR */
 
 	struct cdrom_device_info cdi;
+	struct mutex lock;
 	/* We hold gendisk and scsi_device references on probe and use
 	 * the refs on this kref to decide when to release them */
 	struct kref kref;
