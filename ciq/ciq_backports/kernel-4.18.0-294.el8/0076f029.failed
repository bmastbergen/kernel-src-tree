mm/memory: fix IO cost for anonymous page

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Joonsoo Kim <iamjoonsoo.kim@lge.com>
commit 0076f029cb2906d32baf3bf4401ef09663071d16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0076f029.failed

With synchronous IO swap device, swap-in is directly handled in fault
code.  Since IO cost notation isn't added there, with synchronous IO
swap device, LRU balancing could be wrongly biased.  Fix it to count it
in fault code.

Link: http://lkml.kernel.org/r/1592288204-27734-4-git-send-email-iamjoonsoo.kim@lge.com
Fixes: 314b57fb0460001 ("mm: balance LRU lists based on relative thrashing cache sizing")
	Signed-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Joonsoo Kim <js1304@gmail.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Minchan Kim <minchan.kim@gmail.com>
	Cc: Rik van Riel <riel@surriel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0076f029cb2906d32baf3bf4401ef09663071d16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory.c
diff --cc mm/memory.c
index 583eb7e0dd7f,87ec87cdc1ff..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -3045,7 -3133,28 +3045,30 @@@ vm_fault_t do_swap_page(struct vm_faul
  				__SetPageLocked(page);
  				__SetPageSwapBacked(page);
  				set_page_private(page, entry.val);
++<<<<<<< HEAD
 +				lru_cache_add_anon(page);
++=======
+ 
+ 				/* Tell memcg to use swap ownership records */
+ 				SetPageSwapCache(page);
+ 				err = mem_cgroup_charge(page, vma->vm_mm,
+ 							GFP_KERNEL);
+ 				ClearPageSwapCache(page);
+ 				if (err) {
+ 					ret = VM_FAULT_OOM;
+ 					goto out_page;
+ 				}
+ 
+ 				/*
+ 				 * XXX: Move to lru_cache_add() when it
+ 				 * supports new vs putback
+ 				 */
+ 				spin_lock_irq(&page_pgdat(page)->lru_lock);
+ 				lru_note_cost_page(page);
+ 				spin_unlock_irq(&page_pgdat(page)->lru_lock);
+ 
+ 				lru_cache_add(page);
++>>>>>>> 0076f029cb29 (mm/memory: fix IO cost for anonymous page)
  				swap_readpage(page, true);
  			}
  		} else {
* Unmerged path mm/memory.c
