mm: switch gup_hugepte to use try_get_compound_head

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 01a369160bbea43727aa2b99877f86ebddba9acc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/01a36916.failed

This applies the overflow fixes from 8fde12ca79aff ("mm: prevent
get_user_pages() from overflowing page refcount") to the powerpc hugepd
code and brings it back in sync with the other GUP cases.

Link: http://lkml.kernel.org/r/20190625143715.1689-16-hch@lst.de
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Cc: Andrey Konovalov <andreyknvl@google.com>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: David Miller <davem@davemloft.net>
	Cc: James Hogan <jhogan@kernel.org>
	Cc: Jason Gunthorpe <jgg@mellanox.com>
	Cc: Khalid Aziz <khalid.aziz@oracle.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Nicholas Piggin <npiggin@gmail.com>
	Cc: Paul Burton <paul.burton@mips.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Ralf Baechle <ralf@linux-mips.org>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 01a369160bbea43727aa2b99877f86ebddba9acc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/gup.c
diff --cc mm/gup.c
index f1c484f79152,7763abd16405..000000000000
--- a/mm/gup.c
+++ b/mm/gup.c
@@@ -1883,6 -1966,89 +1883,92 @@@ static int __gup_device_huge_pud(pud_t 
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARCH_HAS_HUGEPD
+ static unsigned long hugepte_addr_end(unsigned long addr, unsigned long end,
+ 				      unsigned long sz)
+ {
+ 	unsigned long __boundary = (addr + sz) & ~(sz-1);
+ 	return (__boundary - 1 < end - 1) ? __boundary : end;
+ }
+ 
+ static int gup_hugepte(pte_t *ptep, unsigned long sz, unsigned long addr,
+ 		       unsigned long end, int write, struct page **pages, int *nr)
+ {
+ 	unsigned long pte_end;
+ 	struct page *head, *page;
+ 	pte_t pte;
+ 	int refs;
+ 
+ 	pte_end = (addr + sz) & ~(sz-1);
+ 	if (pte_end < end)
+ 		end = pte_end;
+ 
+ 	pte = READ_ONCE(*ptep);
+ 
+ 	if (!pte_access_permitted(pte, write))
+ 		return 0;
+ 
+ 	/* hugepages are never "special" */
+ 	VM_BUG_ON(!pfn_valid(pte_pfn(pte)));
+ 
+ 	refs = 0;
+ 	head = pte_page(pte);
+ 
+ 	page = head + ((addr & (sz-1)) >> PAGE_SHIFT);
+ 	do {
+ 		VM_BUG_ON(compound_head(page) != head);
+ 		pages[*nr] = page;
+ 		(*nr)++;
+ 		page++;
+ 		refs++;
+ 	} while (addr += PAGE_SIZE, addr != end);
+ 
+ 	head = try_get_compound_head(head, refs);
+ 	if (!head) {
+ 		*nr -= refs;
+ 		return 0;
+ 	}
+ 
+ 	if (unlikely(pte_val(pte) != pte_val(*ptep))) {
+ 		/* Could be optimized better */
+ 		*nr -= refs;
+ 		while (refs--)
+ 			put_page(head);
+ 		return 0;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static int gup_huge_pd(hugepd_t hugepd, unsigned long addr,
+ 		unsigned int pdshift, unsigned long end, int write,
+ 		struct page **pages, int *nr)
+ {
+ 	pte_t *ptep;
+ 	unsigned long sz = 1UL << hugepd_shift(hugepd);
+ 	unsigned long next;
+ 
+ 	ptep = hugepte_offset(hugepd, addr, pdshift);
+ 	do {
+ 		next = hugepte_addr_end(addr, end, sz);
+ 		if (!gup_hugepte(ptep, sz, addr, end, write, pages, nr))
+ 			return 0;
+ 	} while (ptep++, addr = next, addr != end);
+ 
+ 	return 1;
+ }
+ #else
+ static inline int gup_huge_pd(hugepd_t hugepd, unsigned long addr,
+ 		unsigned pdshift, unsigned long end, int write,
+ 		struct page **pages, int *nr)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_ARCH_HAS_HUGEPD */
+ 
++>>>>>>> 01a369160bbe (mm: switch gup_hugepte to use try_get_compound_head)
  static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,
  		unsigned long end, unsigned int flags, struct page **pages, int *nr)
  {
* Unmerged path mm/gup.c
