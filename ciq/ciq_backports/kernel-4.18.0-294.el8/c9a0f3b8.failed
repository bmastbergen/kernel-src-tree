bpf: Resolve BTF IDs in vmlinux image

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit c9a0f3b85e09dd16665b639cb884490410619434
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c9a0f3b8.failed

Using BTF_ID_LIST macro to define lists for several helpers
using BTF arguments.

And running resolve_btfids on vmlinux elf object during linking,
so the .BTF_ids section gets the IDs resolved.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Tested-by: Andrii Nakryiko <andriin@fb.com>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20200711215329.41165-5-jolsa@kernel.org
(cherry picked from commit c9a0f3b85e09dd16665b639cb884490410619434)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Makefile
#	kernel/bpf/stackmap.c
#	net/core/filter.c
#	scripts/link-vmlinux.sh
diff --cc Makefile
index 5a55704af2fd,462f1a75fcb3..000000000000
--- a/Makefile
+++ b/Makefile
@@@ -369,16 -425,30 +369,17 @@@ KBUILD_HOSTLDFLAGS  := $(HOST_LFS_LDFLA
  KBUILD_HOSTLDLIBS   := $(HOST_LFS_LIBS) $(HOSTLDLIBS)
  
  # Make variables (CC, etc...)
 -CPP		= $(CC) -E
 -ifneq ($(LLVM),)
 -CC		= clang
 -LD		= ld.lld
 -AR		= llvm-ar
 -NM		= llvm-nm
 -OBJCOPY		= llvm-objcopy
 -OBJDUMP		= llvm-objdump
 -READELF		= llvm-readelf
 -OBJSIZE		= llvm-size
 -STRIP		= llvm-strip
 -else
 -CC		= $(CROSS_COMPILE)gcc
 +AS		= $(CROSS_COMPILE)as
  LD		= $(CROSS_COMPILE)ld
 +CC		= $(CROSS_COMPILE)gcc
 +CPP		= $(CC) -E
  AR		= $(CROSS_COMPILE)ar
  NM		= $(CROSS_COMPILE)nm
 +STRIP		= $(CROSS_COMPILE)strip
  OBJCOPY		= $(CROSS_COMPILE)objcopy
  OBJDUMP		= $(CROSS_COMPILE)objdump
 -READELF		= $(CROSS_COMPILE)readelf
 -OBJSIZE		= $(CROSS_COMPILE)size
 -STRIP		= $(CROSS_COMPILE)strip
 -endif
  PAHOLE		= pahole
+ RESOLVE_BTFIDS	= $(objtree)/tools/bpf/resolve_btfids/resolve_btfids
  LEX		= flex
  YACC		= bison
  AWK		= awk
@@@ -430,18 -504,21 +431,26 @@@ KBUILD_AFLAGS_KERNEL :
  KBUILD_CFLAGS_KERNEL :=
  KBUILD_AFLAGS_MODULE  := -DMODULE
  KBUILD_CFLAGS_MODULE  := -DMODULE
 -KBUILD_LDFLAGS_MODULE :=
 -export KBUILD_LDS_MODULE := $(srctree)/scripts/module-common.lds
 -KBUILD_LDFLAGS :=
 +KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
 +LDFLAGS :=
  GCC_PLUGINS_CFLAGS :=
 -CLANG_FLAGS :=
  
++<<<<<<< HEAD
 +export ARCH SRCARCH CONFIG_SHELL HOSTCC KBUILD_HOSTCFLAGS CROSS_COMPILE AS LD CC
 +export CPP AR NM STRIP OBJCOPY OBJDUMP PAHOLE KBUILD_HOSTLDFLAGS KBUILD_HOSTLDLIBS
 +export MAKE LEX YACC AWK INSTALLKERNEL PERL PYTHON PYTHON2 PYTHON3 UTS_MACHINE
 +export HOSTCXX KBUILD_HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
++=======
+ export ARCH SRCARCH CONFIG_SHELL BASH HOSTCC KBUILD_HOSTCFLAGS CROSS_COMPILE LD CC
+ export CPP AR NM STRIP OBJCOPY OBJDUMP OBJSIZE READELF PAHOLE RESOLVE_BTFIDS LEX YACC AWK INSTALLKERNEL
+ export PERL PYTHON PYTHON3 CHECK CHECKFLAGS MAKE UTS_MACHINE HOSTCXX
+ export KGZIP KBZIP2 KLZOP LZMA LZ4 XZ
+ export KBUILD_HOSTCXXFLAGS KBUILD_HOSTLDFLAGS KBUILD_HOSTLDLIBS LDFLAGS_MODULE
++>>>>>>> c9a0f3b85e09 (bpf: Resolve BTF IDs in vmlinux image)
  
 -export KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS KBUILD_LDFLAGS
 +export KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS
  export KBUILD_CFLAGS CFLAGS_KERNEL CFLAGS_MODULE
 -export CFLAGS_KASAN CFLAGS_KASAN_NOSANITIZE CFLAGS_UBSAN CFLAGS_KCSAN
 +export CFLAGS_KASAN CFLAGS_KASAN_NOSANITIZE CFLAGS_UBSAN
  export KBUILD_AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
  export KBUILD_AFLAGS_MODULE KBUILD_CFLAGS_MODULE KBUILD_LDFLAGS_MODULE
  export KBUILD_AFLAGS_KERNEL KBUILD_CFLAGS_KERNEL
diff --cc kernel/bpf/stackmap.c
index 4153fd4ee538,48d8e739975f..000000000000
--- a/kernel/bpf/stackmap.c
+++ b/kernel/bpf/stackmap.c
@@@ -525,6 -569,28 +526,31 @@@ const struct bpf_func_proto bpf_get_sta
  	.arg4_type	= ARG_ANYTHING,
  };
  
++<<<<<<< HEAD
++=======
+ BPF_CALL_4(bpf_get_task_stack, struct task_struct *, task, void *, buf,
+ 	   u32, size, u64, flags)
+ {
+ 	struct pt_regs *regs = task_pt_regs(task);
+ 
+ 	return __bpf_get_stack(regs, task, buf, size, flags);
+ }
+ 
+ BTF_ID_LIST(bpf_get_task_stack_btf_ids)
+ BTF_ID(struct, task_struct)
+ 
+ const struct bpf_func_proto bpf_get_task_stack_proto = {
+ 	.func		= bpf_get_task_stack,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_BTF_ID,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE_OR_ZERO,
+ 	.arg4_type	= ARG_ANYTHING,
+ 	.btf_id		= bpf_get_task_stack_btf_ids,
+ };
+ 
++>>>>>>> c9a0f3b85e09 (bpf: Resolve BTF IDs in vmlinux image)
  /* Called from eBPF program */
  static void *stack_map_lookup_elem(struct bpf_map *map, void *key)
  {
diff --cc net/core/filter.c
index 76aa4a2037db,4e572441e64a..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -76,8 -74,8 +76,13 @@@
  #include <net/lwtunnel.h>
  #include <net/ipv6_stubs.h>
  #include <net/bpf_sk_storage.h>
++<<<<<<< HEAD
 +
 +#include <linux/rh_features.h>
++=======
+ #include <net/transp_v6.h>
+ #include <linux/btf_ids.h>
++>>>>>>> c9a0f3b85e09 (bpf: Resolve BTF IDs in vmlinux image)
  
  /**
   *	sk_filter_trim_cap - run a packet through a socket filter
diff --cc scripts/link-vmlinux.sh
index bbfffccf5206,e26f02dbedee..000000000000
--- a/scripts/link-vmlinux.sh
+++ b/scripts/link-vmlinux.sh
@@@ -329,12 -334,20 +329,27 @@@ if [ -n "${CONFIG_KALLSYMS}" ]; the
  	fi
  fi
  
 -vmlinux_link vmlinux "${kallsymso}" ${btf_vmlinux_bin_o}
 +info LD vmlinux
 +vmlinux_link vmlinux "${kallsymso}" "${btf_vmlinux_bin_o}"
  
++<<<<<<< HEAD
 +if [ -n "${CONFIG_BUILDTIME_EXTABLE_SORT}" ]; then
 +	info SORTEX vmlinux
 +	sortextable vmlinux
++=======
+ # fill in BTF IDs
+ if [ -n "${CONFIG_DEBUG_INFO_BTF}" ]; then
+ info BTFIDS vmlinux
+ ${RESOLVE_BTFIDS} vmlinux
+ fi
+ 
+ if [ -n "${CONFIG_BUILDTIME_TABLE_SORT}" ]; then
+ 	info SORTTAB vmlinux
+ 	if ! sorttable vmlinux; then
+ 		echo >&2 Failed to sort kernel tables
+ 		exit 1
+ 	fi
++>>>>>>> c9a0f3b85e09 (bpf: Resolve BTF IDs in vmlinux image)
  fi
  
  info SYSMAP System.map
* Unmerged path Makefile
* Unmerged path kernel/bpf/stackmap.c
diff --git a/kernel/trace/bpf_trace.c b/kernel/trace/bpf_trace.c
index ba868d951c55..fba30e686989 100644
--- a/kernel/trace/bpf_trace.c
+++ b/kernel/trace/bpf_trace.c
@@ -16,6 +16,7 @@
 #include <linux/kprobes.h>
 #include <linux/syscalls.h>
 #include <linux/error-injection.h>
+#include <linux/btf_ids.h>
 
 #include <asm/tlb.h>
 
@@ -668,7 +669,9 @@ BPF_CALL_5(bpf_seq_printf, struct seq_file *, m, char *, fmt, u32, fmt_size,
 	return err;
 }
 
-static int bpf_seq_printf_btf_ids[5];
+BTF_ID_LIST(bpf_seq_printf_btf_ids)
+BTF_ID(struct, seq_file)
+
 static const struct bpf_func_proto bpf_seq_printf_proto = {
 	.func		= bpf_seq_printf,
 	.gpl_only	= true,
@@ -686,7 +689,9 @@ BPF_CALL_3(bpf_seq_write, struct seq_file *, m, const void *, data, u32, len)
 	return seq_write(m, data, len) ? -EOVERFLOW : 0;
 }
 
-static int bpf_seq_write_btf_ids[5];
+BTF_ID_LIST(bpf_seq_write_btf_ids)
+BTF_ID(struct, seq_file)
+
 static const struct bpf_func_proto bpf_seq_write_proto = {
 	.func		= bpf_seq_write,
 	.gpl_only	= true,
* Unmerged path net/core/filter.c
* Unmerged path scripts/link-vmlinux.sh
