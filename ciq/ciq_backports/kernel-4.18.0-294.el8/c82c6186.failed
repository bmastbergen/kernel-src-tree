x86/sgx: Add SGX_IOC_ENCLAVE_PROVISION

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jarkko Sakkinen <jarkko@kernel.org>
commit c82c61865024b9981f00358433bebed92ca20c00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c82c6186.failed

The whole point of SGX is to create a hardware protected place to do
“stuff”. But, before someone is willing to hand over the keys to
the castle , an enclave must often prove that it is running on an
SGX-protected processor. Provisioning enclaves play a key role in
providing proof.

There are actually three different enclaves in play in order to make this
happen:

1. The application enclave.  The familiar one we know and love that runs
   the actual code that’s doing real work.  There can be many of these on
   a single system, or even in a single application.
2. The quoting enclave  (QE).  The QE is mentioned in lots of silly
   whitepapers, but, for the purposes of kernel enabling, just pretend they
   do not exist.
3. The provisioning enclave.  There is typically only one of these
   enclaves per system.  Provisioning enclaves have access to a special
   hardware key.

   They can use this key to help to generate certificates which serve as
   proof that enclaves are running on trusted SGX hardware.  These
   certificates can be passed around without revealing the special key.

Any user who can create a provisioning enclave can access the
processor-unique Provisioning Certificate Key which has privacy and
fingerprinting implications. Even if a user is permitted to create
normal application enclaves (via /dev/sgx_enclave), they should not be
able to create provisioning enclaves. That means a separate permissions
scheme is needed to control provisioning enclave privileges.

Implement a separate device file (/dev/sgx_provision) which allows
creating provisioning enclaves. This device will typically have more
strict permissions than the plain enclave device.

The actual device “driver” is an empty stub.  Open file descriptors for
this device will represent a token which allows provisioning enclave duty.
This file descriptor can be passed around and ultimately given as an
argument to the /dev/sgx_enclave driver ioctl().

 [ bp: Touchups. ]

	Suggested-by: Andy Lutomirski <luto@kernel.org>
	Signed-off-by: Jarkko Sakkinen <jarkko@kernel.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: linux-security-module@vger.kernel.org
Link: https://lkml.kernel.org/r/20201112220135.165028-16-jarkko@kernel.org
(cherry picked from commit c82c61865024b9981f00358433bebed92ca20c00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/uapi/asm/sgx.h
#	arch/x86/kernel/cpu/sgx/driver.c
#	arch/x86/kernel/cpu/sgx/driver.h
#	arch/x86/kernel/cpu/sgx/ioctl.c
diff --cc arch/x86/kernel/cpu/sgx/driver.c
index c2810e1c7cf1,899c18499d1a..000000000000
--- a/arch/x86/kernel/cpu/sgx/driver.c
+++ b/arch/x86/kernel/cpu/sgx/driver.c
@@@ -103,10 -123,51 +107,58 @@@ static struct miscdevice sgx_dev_enclav
  	.fops = &sgx_encl_fops,
  };
  
+ static struct miscdevice sgx_dev_provision = {
+ 	.minor = MISC_DYNAMIC_MINOR,
+ 	.name = "sgx_provision",
+ 	.nodename = "sgx_provision",
+ 	.fops = &sgx_provision_fops,
+ };
+ 
  int __init sgx_drv_init(void)
  {
++<<<<<<< HEAD
 +	if (!cpu_feature_enabled(X86_FEATURE_SGX_LC))
 +		return -ENODEV;
 +
 +	return misc_register(&sgx_dev_enclave);
++=======
+ 	unsigned int eax, ebx, ecx, edx;
+ 	u64 attr_mask;
+ 	u64 xfrm_mask;
+ 	int ret;
+ 
+ 	if (!cpu_feature_enabled(X86_FEATURE_SGX_LC))
+ 		return -ENODEV;
+ 
+ 	cpuid_count(SGX_CPUID, 0, &eax, &ebx, &ecx, &edx);
+ 
+ 	if (!(eax & 1))  {
+ 		pr_err("SGX disabled: SGX1 instruction support not available.\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	sgx_misc_reserved_mask = ~ebx | SGX_MISC_RESERVED_MASK;
+ 
+ 	cpuid_count(SGX_CPUID, 1, &eax, &ebx, &ecx, &edx);
+ 
+ 	attr_mask = (((u64)ebx) << 32) + (u64)eax;
+ 	sgx_attributes_reserved_mask = ~attr_mask | SGX_ATTR_RESERVED_MASK;
+ 
+ 	if (cpu_feature_enabled(X86_FEATURE_OSXSAVE)) {
+ 		xfrm_mask = (((u64)edx) << 32) + (u64)ecx;
+ 		sgx_xfrm_reserved_mask = ~xfrm_mask;
+ 	}
+ 
+ 	ret = misc_register(&sgx_dev_enclave);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = misc_register(&sgx_dev_provision);
+ 	if (ret) {
+ 		misc_deregister(&sgx_dev_enclave);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
++>>>>>>> c82c61865024 (x86/sgx: Add SGX_IOC_ENCLAVE_PROVISION)
  }
diff --cc arch/x86/kernel/cpu/sgx/driver.h
index cda9c43b7543,4eddb4d571ef..000000000000
--- a/arch/x86/kernel/cpu/sgx/driver.h
+++ b/arch/x86/kernel/cpu/sgx/driver.h
@@@ -9,8 -9,21 +9,23 @@@
  #include <linux/rwsem.h>
  #include <linux/sched.h>
  #include <linux/workqueue.h>
 -#include <uapi/asm/sgx.h>
  #include "sgx.h"
  
++<<<<<<< HEAD
++=======
+ #define SGX_EINIT_SPIN_COUNT	20
+ #define SGX_EINIT_SLEEP_COUNT	50
+ #define SGX_EINIT_SLEEP_TIME	20
+ 
+ extern u64 sgx_attributes_reserved_mask;
+ extern u64 sgx_xfrm_reserved_mask;
+ extern u32 sgx_misc_reserved_mask;
+ 
+ extern const struct file_operations sgx_provision_fops;
+ 
+ long sgx_ioctl(struct file *filep, unsigned int cmd, unsigned long arg);
+ 
++>>>>>>> c82c61865024 (x86/sgx: Add SGX_IOC_ENCLAVE_PROVISION)
  int sgx_drv_init(void);
  
  #endif /* __ARCH_X86_SGX_DRIVER_H__ */
* Unmerged path arch/x86/include/uapi/asm/sgx.h
* Unmerged path arch/x86/kernel/cpu/sgx/ioctl.c
* Unmerged path arch/x86/include/uapi/asm/sgx.h
* Unmerged path arch/x86/kernel/cpu/sgx/driver.c
* Unmerged path arch/x86/kernel/cpu/sgx/driver.h
* Unmerged path arch/x86/kernel/cpu/sgx/ioctl.c
