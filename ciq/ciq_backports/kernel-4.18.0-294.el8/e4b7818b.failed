kasan: record and print the free track

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Walter Wu <walter-zh.wu@mediatek.com>
commit e4b7818b9aa8fa8dfd5fc7bb98f0d4c16b50fd8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e4b7818b.failed

Move free track from kasan_alloc_meta to kasan_free_meta in order to make
struct kasan_alloc_meta and kasan_free_meta size are both 16 bytes.  It is
a good size because it is the minimal redzone size and a good number of
alignment.

For free track, we make some modifications as shown below:
1) Remove the free_track from struct kasan_alloc_meta.
2) Add the free_track into struct kasan_free_meta.
3) Add a macro KASAN_KMALLOC_FREETRACK in order to check whether
   it can print free stack in KASAN report.

[1]https://bugzilla.kernel.org/show_bug.cgi?id=198437

[walter-zh.wu@mediatek.com: build fix]
  Link: http://lkml.kernel.org/r/20200710162440.23887-1-walter-zh.wu@mediatek.com

	Suggested-by: Dmitry Vyukov <dvyukov@google.com>
Co-developed-by: Dmitry Vyukov <dvyukov@google.com>
	Signed-off-by: Walter Wu <walter-zh.wu@mediatek.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Dmitry Vyukov <dvyukov@google.com>
	Reviewed-by: Dmitry Vyukov <dvyukov@google.com>
	Reviewed-by: Andrey Konovalov <andreyknvl@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Joel Fernandes <joel@joelfernandes.org>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Josh Triplett <josh@joshtriplett.org>
	Cc: Lai Jiangshan <jiangshanlai@gmail.com>
	Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: Matthias Brugger <matthias.bgg@gmail.com>
	Cc: "Paul E . McKenney" <paulmck@kernel.org>
Link: http://lkml.kernel.org/r/20200601051022.1230-1-walter-zh.wu@mediatek.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e4b7818b9aa8fa8dfd5fc7bb98f0d4c16b50fd8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kasan/common.c
#	mm/kasan/generic.c
#	mm/kasan/generic_report.c
#	mm/kasan/kasan.h
#	mm/kasan/report.c
#	mm/kasan/tags.c
diff --cc mm/kasan/kasan.h
index d4667fb5a8f3,ac499456740f..000000000000
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@@ -12,7 -17,17 +12,21 @@@
  #define KASAN_PAGE_REDZONE      0xFE  /* redzone for kmalloc_large allocations */
  #define KASAN_KMALLOC_REDZONE   0xFC  /* redzone inside slub object */
  #define KASAN_KMALLOC_FREE      0xFB  /* object was freed (kmem_cache_free/kfree) */
++<<<<<<< HEAD
 +#define KASAN_GLOBAL_REDZONE    0xFA  /* redzone for global variable */
++=======
+ #define KASAN_KMALLOC_FREETRACK 0xFA  /* object was freed and has free track set */
+ #else
+ #define KASAN_FREE_PAGE         KASAN_TAG_INVALID
+ #define KASAN_PAGE_REDZONE      KASAN_TAG_INVALID
+ #define KASAN_KMALLOC_REDZONE   KASAN_TAG_INVALID
+ #define KASAN_KMALLOC_FREE      KASAN_TAG_INVALID
+ #define KASAN_KMALLOC_FREETRACK KASAN_TAG_INVALID
+ #endif
+ 
+ #define KASAN_GLOBAL_REDZONE    0xF9  /* redzone for global variable */
+ #define KASAN_VMALLOC_INVALID   0xF8  /* unallocated space in vmapped page */
++>>>>>>> e4b7818b9aa8 (kasan: record and print the free track)
  
  /*
   * Stack redzone shadow values
@@@ -79,9 -98,27 +93,25 @@@ struct kasan_track 
  	depot_stack_handle_t stack;
  };
  
 -#ifdef CONFIG_KASAN_SW_TAGS_IDENTIFY
 -#define KASAN_NR_FREE_STACKS 5
 -#else
 -#define KASAN_NR_FREE_STACKS 1
 -#endif
 -
  struct kasan_alloc_meta {
  	struct kasan_track alloc_track;
++<<<<<<< HEAD
 +	struct kasan_track free_track;
++=======
+ #ifdef CONFIG_KASAN_GENERIC
+ 	/*
+ 	 * call_rcu() call stack is stored into struct kasan_alloc_meta.
+ 	 * The free stack is stored into struct kasan_free_meta.
+ 	 */
+ 	depot_stack_handle_t aux_stack[2];
+ #else
+ 	struct kasan_track free_track[KASAN_NR_FREE_STACKS];
+ #endif
+ #ifdef CONFIG_KASAN_SW_TAGS_IDENTIFY
+ 	u8 free_pointer_tag[KASAN_NR_FREE_STACKS];
+ 	u8 free_track_idx;
+ #endif
++>>>>>>> e4b7818b9aa8 (kasan: record and print the free track)
  };
  
  struct qlist_node {
@@@ -109,7 -170,16 +142,20 @@@ void kasan_report(unsigned long addr, s
  		bool is_write, unsigned long ip);
  void kasan_report_invalid_free(void *object, unsigned long ip);
  
++<<<<<<< HEAD
 +#if defined(CONFIG_SLAB) || defined(CONFIG_SLUB)
++=======
+ struct page *kasan_addr_to_page(const void *addr);
+ 
+ depot_stack_handle_t kasan_save_stack(gfp_t flags);
+ void kasan_set_track(struct kasan_track *track, gfp_t flags);
+ void kasan_set_free_info(struct kmem_cache *cache, void *object, u8 tag);
+ struct kasan_track *kasan_get_free_track(struct kmem_cache *cache,
+ 				void *object, u8 tag);
+ 
+ #if defined(CONFIG_KASAN_GENERIC) && \
+ 	(defined(CONFIG_SLAB) || defined(CONFIG_SLUB))
++>>>>>>> e4b7818b9aa8 (kasan: record and print the free track)
  void quarantine_put(struct kasan_free_meta *info, struct kmem_cache *cache);
  void quarantine_reduce(void);
  void quarantine_remove_cache(struct kmem_cache *cache);
diff --cc mm/kasan/report.c
index 4694bf3eb077,4f49fa6cd1aa..000000000000
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@@ -248,10 -171,28 +248,31 @@@ static void describe_object(struct kmem
  	struct kasan_alloc_meta *alloc_info = get_alloc_info(cache, object);
  
  	if (cache->flags & SLAB_KASAN) {
 -		struct kasan_track *free_track;
 -
  		print_track(&alloc_info->alloc_track, "Allocated");
  		pr_err("\n");
++<<<<<<< HEAD
 +		print_track(&alloc_info->free_track, "Freed");
 +		pr_err("\n");
++=======
+ 		free_track = kasan_get_free_track(cache, object, tag);
+ 		if (free_track) {
+ 			print_track(free_track, "Freed");
+ 			pr_err("\n");
+ 		}
+ 
+ #ifdef CONFIG_KASAN_GENERIC
+ 		if (alloc_info->aux_stack[0]) {
+ 			pr_err("Last call_rcu():\n");
+ 			print_stack(alloc_info->aux_stack[0]);
+ 			pr_err("\n");
+ 		}
+ 		if (alloc_info->aux_stack[1]) {
+ 			pr_err("Second to last call_rcu():\n");
+ 			print_stack(alloc_info->aux_stack[1]);
+ 			pr_err("\n");
+ 		}
+ #endif
++>>>>>>> e4b7818b9aa8 (kasan: record and print the free track)
  	}
  
  	describe_object_addr(cache, object, addr);
* Unmerged path mm/kasan/common.c
* Unmerged path mm/kasan/generic.c
* Unmerged path mm/kasan/generic_report.c
* Unmerged path mm/kasan/tags.c
* Unmerged path mm/kasan/common.c
* Unmerged path mm/kasan/generic.c
* Unmerged path mm/kasan/generic_report.c
* Unmerged path mm/kasan/kasan.h
diff --git a/mm/kasan/quarantine.c b/mm/kasan/quarantine.c
index b209dbaefde8..6dbcce4dea34 100644
--- a/mm/kasan/quarantine.c
+++ b/mm/kasan/quarantine.c
@@ -144,6 +144,7 @@ static void qlink_free(struct qlist_node *qlink, struct kmem_cache *cache)
 	if (IS_ENABLED(CONFIG_SLAB))
 		local_irq_save(flags);
 
+	*(u8 *)kasan_mem_to_shadow(object) = KASAN_KMALLOC_FREE;
 	___cache_free(cache, object, _THIS_IP_);
 
 	if (IS_ENABLED(CONFIG_SLAB))
* Unmerged path mm/kasan/report.c
* Unmerged path mm/kasan/tags.c
