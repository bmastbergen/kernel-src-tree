cgroup1: switch to option-by-option parsing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 8d2451f4994fa60a57617282bab91b98266a00b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8d2451f4.failed

[dhowells should be the author - it's carved out of his patch]

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 8d2451f4994fa60a57617282bab91b98266a00b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cgroup/cgroup-internal.h
#	kernel/cgroup/cgroup-v1.c
#	kernel/cgroup/cgroup.c
diff --cc kernel/cgroup/cgroup-internal.h
index ce1c1553c696,a7b5a41f170c..000000000000
--- a/kernel/cgroup/cgroup-internal.h
+++ b/kernel/cgroup/cgroup-internal.h
@@@ -257,8 -264,8 +258,14 @@@ bool cgroup1_ssid_disabled(int ssid)
  void cgroup1_pidlist_destroy_all(struct cgroup *cgrp);
  void cgroup1_release_agent(struct work_struct *work);
  void cgroup1_check_for_release(struct cgroup *cgrp);
++<<<<<<< HEAD
 +struct dentry *cgroup1_mount(struct file_system_type *fs_type, int flags,
 +			     void *data, unsigned long magic,
 +			     struct cgroup_namespace *ns);
++=======
+ int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param);
+ int cgroup1_get_tree(struct fs_context *fc);
+ int cgroup1_reconfigure(struct fs_context *ctx);
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  
  #endif /* __CGROUP_INTERNAL_H */
diff --cc kernel/cgroup/cgroup-v1.c
index dd94e2a4c22e,725e9f6fe80d..000000000000
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@@ -873,142 -909,164 +876,295 @@@ static int cgroup1_show_options(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int parse_cgroupfs_options(char *data, struct cgroup_sb_opts *opts)
 +{
 +	char *token, *o = data;
 +	bool all_ss = false, one_ss = false;
 +	u16 mask = U16_MAX;
 +	struct cgroup_subsys *ss;
 +	int nr_opts = 0;
 +	int i;
 +
 +#ifdef CONFIG_CPUSETS
 +	mask = ~((u16)1 << cpuset_cgrp_id);
 +#endif
 +
 +	memset(opts, 0, sizeof(*opts));
 +
 +	while ((token = strsep(&o, ",")) != NULL) {
 +		nr_opts++;
 +
 +		if (!*token)
 +			return -EINVAL;
 +		if (!strcmp(token, "none")) {
 +			/* Explicitly have no subsystems */
 +			opts->none = true;
 +			continue;
 +		}
 +		if (!strcmp(token, "all")) {
 +			/* Mutually exclusive option 'all' + subsystem name */
 +			if (one_ss)
 +				return -EINVAL;
 +			all_ss = true;
 +			continue;
 +		}
 +		if (!strcmp(token, "noprefix")) {
 +			opts->flags |= CGRP_ROOT_NOPREFIX;
 +			continue;
 +		}
 +		if (!strcmp(token, "clone_children")) {
 +			opts->cpuset_clone_children = true;
 +			continue;
 +		}
 +		if (!strcmp(token, "cpuset_v2_mode")) {
 +			opts->flags |= CGRP_ROOT_CPUSET_V2_MODE;
 +			continue;
 +		}
 +		if (!strcmp(token, "xattr")) {
 +			opts->flags |= CGRP_ROOT_XATTR;
 +			continue;
 +		}
 +		if (!strncmp(token, "release_agent=", 14)) {
 +			/* Specifying two release agents is forbidden */
 +			if (opts->release_agent)
 +				return -EINVAL;
 +			opts->release_agent =
 +				kstrndup(token + 14, PATH_MAX - 1, GFP_KERNEL);
 +			if (!opts->release_agent)
 +				return -ENOMEM;
 +			continue;
 +		}
 +		if (!strncmp(token, "name=", 5)) {
 +			const char *name = token + 5;
 +
 +			/* blocked by boot param? */
 +			if (cgroup_no_v1_named)
 +				return -ENOENT;
 +			/* Can't specify an empty name */
 +			if (!strlen(name))
 +				return -EINVAL;
 +			/* Must match [\w.-]+ */
 +			for (i = 0; i < strlen(name); i++) {
 +				char c = name[i];
 +				if (isalnum(c))
 +					continue;
 +				if ((c == '.') || (c == '-') || (c == '_'))
 +					continue;
 +				return -EINVAL;
 +			}
 +			/* Specifying two names is forbidden */
 +			if (opts->name)
 +				return -EINVAL;
 +			opts->name = kstrndup(name,
 +					      MAX_CGROUP_ROOT_NAMELEN - 1,
 +					      GFP_KERNEL);
 +			if (!opts->name)
 +				return -ENOMEM;
 +
 +			continue;
 +		}
 +
++=======
+ enum cgroup1_param {
+ 	Opt_all,
+ 	Opt_clone_children,
+ 	Opt_cpuset_v2_mode,
+ 	Opt_name,
+ 	Opt_none,
+ 	Opt_noprefix,
+ 	Opt_release_agent,
+ 	Opt_xattr,
+ };
+ 
+ static const struct fs_parameter_spec cgroup1_param_specs[] = {
+ 	fsparam_flag  ("all",		Opt_all),
+ 	fsparam_flag  ("clone_children", Opt_clone_children),
+ 	fsparam_flag  ("cpuset_v2_mode", Opt_cpuset_v2_mode),
+ 	fsparam_string("name",		Opt_name),
+ 	fsparam_flag  ("none",		Opt_none),
+ 	fsparam_flag  ("noprefix",	Opt_noprefix),
+ 	fsparam_string("release_agent",	Opt_release_agent),
+ 	fsparam_flag  ("xattr",		Opt_xattr),
+ 	{}
+ };
+ 
+ const struct fs_parameter_description cgroup1_fs_parameters = {
+ 	.name		= "cgroup1",
+ 	.specs		= cgroup1_param_specs,
+ };
+ 
+ int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 	struct cgroup_subsys *ss;
+ 	struct fs_parse_result result;
+ 	int opt, i;
+ 
+ 	opt = fs_parse(fc, &cgroup1_fs_parameters, param, &result);
+ 	if (opt == -ENOPARAM) {
+ 		if (strcmp(param->key, "source") == 0) {
+ 			fc->source = param->string;
+ 			param->string = NULL;
+ 			return 0;
+ 		}
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  		for_each_subsys(ss, i) {
- 			if (strcmp(token, ss->legacy_name))
+ 			if (strcmp(param->key, ss->legacy_name))
  				continue;
++<<<<<<< HEAD
 +			if (!cgroup_ssid_enabled(i))
 +				continue;
 +			if (cgroup1_ssid_disabled(i))
 +				continue;
 +
 +			/* Mutually exclusive option 'all' + subsystem name */
 +			if (all_ss)
 +				return -EINVAL;
 +			opts->subsys_mask |= (1 << i);
 +			one_ss = true;
 +
 +			break;
++=======
+ 			ctx->subsys_mask |= (1 << i);
+ 			return 0;
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  		}
- 		if (i == CGROUP_SUBSYS_COUNT)
+ 		return cg_invalf(fc, "cgroup1: Unknown subsys name '%s'", param->key);
+ 	}
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_none:
+ 		/* Explicitly have no subsystems */
+ 		ctx->none = true;
+ 		break;
+ 	case Opt_all:
+ 		ctx->all_ss = true;
+ 		break;
+ 	case Opt_noprefix:
+ 		ctx->flags |= CGRP_ROOT_NOPREFIX;
+ 		break;
+ 	case Opt_clone_children:
+ 		ctx->cpuset_clone_children = true;
+ 		break;
+ 	case Opt_cpuset_v2_mode:
+ 		ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;
+ 		break;
+ 	case Opt_xattr:
+ 		ctx->flags |= CGRP_ROOT_XATTR;
+ 		break;
+ 	case Opt_release_agent:
+ 		/* Specifying two release agents is forbidden */
+ 		if (ctx->release_agent)
+ 			return cg_invalf(fc, "cgroup1: release_agent respecified");
+ 		ctx->release_agent = param->string;
+ 		param->string = NULL;
+ 		break;
+ 	case Opt_name:
+ 		/* blocked by boot param? */
+ 		if (cgroup_no_v1_named)
  			return -ENOENT;
+ 		/* Can't specify an empty name */
+ 		if (!param->size)
+ 			return cg_invalf(fc, "cgroup1: Empty name");
+ 		if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)
+ 			return cg_invalf(fc, "cgroup1: Name too long");
+ 		/* Must match [\w.-]+ */
+ 		for (i = 0; i < param->size; i++) {
+ 			char c = param->string[i];
+ 			if (isalnum(c))
+ 				continue;
+ 			if ((c == '.') || (c == '-') || (c == '_'))
+ 				continue;
+ 			return cg_invalf(fc, "cgroup1: Invalid name");
+ 		}
+ 		/* Specifying two names is forbidden */
+ 		if (ctx->name)
+ 			return cg_invalf(fc, "cgroup1: name respecified");
+ 		ctx->name = param->string;
+ 		param->string = NULL;
+ 		break;
  	}
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ static int check_cgroupfs_options(struct fs_context *fc)
+ {
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 	u16 mask = U16_MAX;
+ 	u16 enabled = 0;
+ 	struct cgroup_subsys *ss;
+ 	int i;
+ 
+ #ifdef CONFIG_CPUSETS
+ 	mask = ~((u16)1 << cpuset_cgrp_id);
+ #endif
+ 	for_each_subsys(ss, i)
+ 		if (cgroup_ssid_enabled(i) && !cgroup1_ssid_disabled(i))
+ 			enabled |= 1 << i;
+ 
+ 	ctx->subsys_mask &= enabled;
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  
  	/*
 -	 * In absense of 'none', 'name=' or subsystem name options,
 -	 * let's default to 'all'.
 +	 * If the 'all' option was specified select all the subsystems,
 +	 * otherwise if 'none', 'name=' and a subsystem name options were
 +	 * not specified, let's default to 'all'
  	 */
++<<<<<<< HEAD
 +	if (all_ss || (!one_ss && !opts->none && !opts->name))
 +		for_each_subsys(ss, i)
 +			if (cgroup_ssid_enabled(i) && !cgroup1_ssid_disabled(i))
 +				opts->subsys_mask |= (1 << i);
++=======
+ 	if (!ctx->subsys_mask && !ctx->none && !ctx->name)
+ 		ctx->all_ss = true;
+ 
+ 	if (ctx->all_ss) {
+ 		/* Mutually exclusive option 'all' + subsystem name */
+ 		if (ctx->subsys_mask)
+ 			return cg_invalf(fc, "cgroup1: subsys name conflicts with all");
+ 		/* 'all' => select all the subsystems */
+ 		ctx->subsys_mask = enabled;
+ 	}
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  
  	/*
  	 * We either have to specify by name or by subsystems. (So all
  	 * empty hierarchies must have a name).
  	 */
++<<<<<<< HEAD
 +	if (!opts->subsys_mask && !opts->name)
 +		return -EINVAL;
++=======
+ 	if (!ctx->subsys_mask && !ctx->name)
+ 		return cg_invalf(fc, "cgroup1: Need name or subsystem set");
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  
  	/*
  	 * Option noprefix was introduced just for backward compatibility
  	 * with the old cpuset, so we allow noprefix only if mounting just
  	 * the cpuset subsystem.
  	 */
++<<<<<<< HEAD
 +	if ((opts->flags & CGRP_ROOT_NOPREFIX) && (opts->subsys_mask & mask))
 +		return -EINVAL;
 +
 +	/* Can't specify "none" and some subsystems */
 +	if (opts->subsys_mask && opts->none)
 +		return -EINVAL;
++=======
+ 	if ((ctx->flags & CGRP_ROOT_NOPREFIX) && (ctx->subsys_mask & mask))
+ 		return cg_invalf(fc, "cgroup1: noprefix used incorrectly");
+ 
+ 	/* Can't specify "none" and some subsystems */
+ 	if (ctx->subsys_mask && ctx->none)
+ 		return cg_invalf(fc, "cgroup1: none used incorrectly");
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  
  	return 0;
  }
@@@ -1023,7 -1082,7 +1179,11 @@@ static int cgroup1_remount(struct kernf
  	cgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);
  
  	/* See what subsystems are wanted */
++<<<<<<< HEAD
 +	ret = parse_cgroupfs_options(data, &opts);
++=======
+ 	ret = check_cgroupfs_options(fc);
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  	if (ret)
  		goto out_unlock;
  
@@@ -1031,14 -1090,14 +1191,21 @@@
  		pr_warn("option changes via remount are deprecated (pid=%d comm=%s)\n",
  			task_tgid_nr(current), current->comm);
  
 -	added_mask = ctx->subsys_mask & ~root->subsys_mask;
 -	removed_mask = root->subsys_mask & ~ctx->subsys_mask;
 +	added_mask = opts.subsys_mask & ~root->subsys_mask;
 +	removed_mask = root->subsys_mask & ~opts.subsys_mask;
  
  	/* Don't allow flags or name to change at remount */
++<<<<<<< HEAD
 +	if ((opts.flags ^ root->flags) ||
 +	    (opts.name && strcmp(opts.name, root->name))) {
 +		pr_err("option or name mismatch, new: 0x%x \"%s\", old: 0x%x \"%s\"\n",
 +		       opts.flags, opts.name ?: "", root->flags, root->name);
++=======
+ 	if ((ctx->flags ^ root->flags) ||
+ 	    (ctx->name && strcmp(ctx->name, root->name))) {
+ 		cg_invalf(fc, "option or name mismatch, new: 0x%x \"%s\", old: 0x%x \"%s\"",
+ 		       ctx->flags, ctx->name ?: "", root->flags, root->name);
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  		ret = -EINVAL;
  		goto out_unlock;
  	}
@@@ -1092,7 -1147,11 +1259,11 @@@ struct dentry *cgroup1_mount(struct fil
  	cgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);
  
  	/* First find the desired set of subsystems */
++<<<<<<< HEAD
 +	ret = parse_cgroupfs_options(data, &opts);
++=======
+ 	ret = check_cgroupfs_options(fc);
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  	if (ret)
  		goto out_unlock;
  
@@@ -1158,8 -1217,8 +1329,13 @@@
  	 * specification is allowed for already existing hierarchies but we
  	 * can't create new one without subsys specification.
  	 */
++<<<<<<< HEAD
 +	if (!opts.subsys_mask && !opts.none) {
 +		ret = -EINVAL;
++=======
+ 	if (!ctx->subsys_mask && !ctx->none) {
+ 		ret = cg_invalf(fc, "cgroup1: No subsys list or none specified");
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  		goto out_unlock;
  	}
  
diff --cc kernel/cgroup/cgroup.c
index 9e08519ae6db,faba00caa197..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -2050,45 -2062,88 +2050,116 @@@ struct dentry *cgroup_do_mount(struct f
  	return dentry;
  }
  
++<<<<<<< HEAD
 +static struct dentry *cgroup_mount(struct file_system_type *fs_type,
 +			 int flags, const char *unused_dev_name,
 +			 void *data)
++=======
+ /*
+  * Destroy a cgroup filesystem context.
+  */
+ static void cgroup_fs_context_free(struct fs_context *fc)
+ {
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 
+ 	kfree(ctx->name);
+ 	kfree(ctx->release_agent);
+ 	kfree(ctx);
+ }
+ 
+ static int cgroup_parse_monolithic(struct fs_context *fc, void *data)
+ {
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 
+ 	if (data)
+ 		security_sb_eat_lsm_opts(data, &fc->security);
+ 	return parse_cgroup_root_flags(data, &ctx->flags);
+ }
+ 
+ static int cgroup_get_tree(struct fs_context *fc)
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  {
  	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 -	struct dentry *root;
 +	struct dentry *dentry;
 +	int ret;
 +
 +	get_cgroup_ns(ns);
  
  	/* Check if the caller has permission to mount. */
 -	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
 -		return -EPERM;
 +	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN)) {
 +		put_cgroup_ns(ns);
 +		return ERR_PTR(-EPERM);
 +	}
 +
 +	if (fs_type == &cgroup2_fs_type) {
 +		unsigned int root_flags;
  
 -	cgrp_dfl_visible = true;
 -	cgroup_get_live(&cgrp_dfl_root.cgrp);
 +		ret = parse_cgroup_root_flags(data, &root_flags);
 +		if (ret) {
 +			put_cgroup_ns(ns);
 +			return ERR_PTR(ret);
 +		}
 +
 +		cgrp_dfl_visible = true;
 +		cgroup_get_live(&cgrp_dfl_root.cgrp);
  
 -	root = cgroup_do_mount(&cgroup2_fs_type, fc->sb_flags, &cgrp_dfl_root,
 +		dentry = cgroup_do_mount(&cgroup2_fs_type, flags, &cgrp_dfl_root,
  					 CGROUP2_SUPER_MAGIC, ns);
 -	if (IS_ERR(root))
 -		return PTR_ERR(root);
 +		if (!IS_ERR(dentry))
 +			apply_cgroup_root_flags(root_flags);
 +	} else {
 +		dentry = cgroup1_mount(&cgroup_fs_type, flags, data,
 +				       CGROUP_SUPER_MAGIC, ns);
 +	}
  
++<<<<<<< HEAD
 +	put_cgroup_ns(ns);
 +	return dentry;
++=======
+ 	apply_cgroup_root_flags(ctx->flags);
+ 	fc->root = root;
+ 	return 0;
+ }
+ 
+ static const struct fs_context_operations cgroup_fs_context_ops = {
+ 	.free		= cgroup_fs_context_free,
+ 	.parse_monolithic = cgroup_parse_monolithic,
+ 	.get_tree	= cgroup_get_tree,
+ 	.reconfigure	= cgroup_reconfigure,
+ };
+ 
+ static const struct fs_context_operations cgroup1_fs_context_ops = {
+ 	.free		= cgroup_fs_context_free,
+ 	.parse_param	= cgroup1_parse_param,
+ 	.get_tree	= cgroup1_get_tree,
+ 	.reconfigure	= cgroup1_reconfigure,
+ };
+ 
+ /*
+  * Initialise the cgroup filesystem creation/reconfiguration context.
+  */
+ static int cgroup_init_fs_context(struct fs_context *fc)
+ {
+ 	struct cgroup_fs_context *ctx;
+ 
+ 	ctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * The first time anyone tries to mount a cgroup, enable the list
+ 	 * linking each css_set to its tasks and fix up all existing tasks.
+ 	 */
+ 	if (!use_task_css_set_links)
+ 		cgroup_enable_task_cg_lists();
+ 
+ 	fc->fs_private = ctx;
+ 	if (fc->fs_type == &cgroup2_fs_type)
+ 		fc->ops = &cgroup_fs_context_ops;
+ 	else
+ 		fc->ops = &cgroup1_fs_context_ops;
+ 	return 0;
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  }
  
  static void cgroup_kill_sb(struct super_block *sb)
@@@ -2111,10 -2166,11 +2182,18 @@@
  }
  
  struct file_system_type cgroup_fs_type = {
++<<<<<<< HEAD
 +	.name = "cgroup",
 +	.mount = cgroup_mount,
 +	.kill_sb = cgroup_kill_sb,
 +	.fs_flags = FS_USERNS_MOUNT,
++=======
+ 	.name			= "cgroup",
+ 	.init_fs_context	= cgroup_init_fs_context,
+ 	.parameters		= &cgroup1_fs_parameters,
+ 	.kill_sb		= cgroup_kill_sb,
+ 	.fs_flags		= FS_USERNS_MOUNT,
++>>>>>>> 8d2451f4994f (cgroup1: switch to option-by-option parsing)
  };
  
  static struct file_system_type cgroup2_fs_type = {
* Unmerged path kernel/cgroup/cgroup-internal.h
* Unmerged path kernel/cgroup/cgroup-v1.c
* Unmerged path kernel/cgroup/cgroup.c
