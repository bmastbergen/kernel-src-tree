net: sched: Pass qdisc reference in struct flow_block_offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [net] sched: Pass qdisc reference in struct flow_block_offload (Ivan Vecera) [1874071]
Rebuild_FUZZ: 95.73%
commit-author Petr Machata <petrm@mellanox.com>
commit c40f4e50b6cfc7c66f69d12c6b3fbcd954f1ded5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c40f4e50.failed

Previously, shared blocks were only relevant for the pseudo-qdiscs ingress
and clsact. Recently, a qevent facility was introduced, which allows to
bind blocks to well-defined slots of a qdisc instance. RED in particular
got two qevents: early_drop and mark. Drivers that wish to offload these
blocks will be sent the usual notification, and need to know which qdisc it
is related to.

To that end, extend flow_block_offload with a "sch" pointer, and initialize
as appropriate. This prompts changes in the indirect block facility, which
now tracks the scheduler in addition to the netdevice. Update signatures of
several functions similarly.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c40f4e50b6cfc7c66f69d12c6b3fbcd954f1ded5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
#	drivers/net/ethernet/netronome/nfp/flower/offload.c
#	include/net/flow_offload.h
#	net/core/flow_offload.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
index 3e3a8841689d,e82e5cf64d61..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
@@@ -1911,7 -1911,7 +1911,11 @@@ static int bnxt_tc_setup_indr_block(str
  		block_cb = flow_indr_block_cb_alloc(bnxt_tc_setup_indr_block_cb,
  						    cb_priv, cb_priv,
  						    bnxt_tc_setup_indr_rel, f,
++<<<<<<< HEAD
 +						    netdev, data, cleanup);
++=======
+ 						    netdev, sch, data, bp, cleanup);
++>>>>>>> c40f4e50b6cf (net: sched: Pass qdisc reference in struct flow_block_offload)
  		if (IS_ERR(block_cb)) {
  			list_del(&cb_priv->list);
  			kfree(cb_priv);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
index 4b52bff27521,f8af109d34cc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
@@@ -442,7 -442,8 +442,12 @@@ mlx5e_rep_indr_setup_block(struct net_d
  
  		block_cb = flow_indr_block_cb_alloc(setup_cb, indr_priv, indr_priv,
  						    mlx5e_rep_indr_block_unbind,
++<<<<<<< HEAD
 +						    f, netdev, data, cleanup);
++=======
+ 						    f, netdev, sch, data, rpriv,
+ 						    cleanup);
++>>>>>>> c40f4e50b6cf (net: sched: Pass qdisc reference in struct flow_block_offload)
  		if (IS_ERR(block_cb)) {
  			list_del(&indr_priv->list);
  			kfree(indr_priv);
diff --cc drivers/net/ethernet/netronome/nfp/flower/offload.c
index 95c75250c355,4651fe417b7f..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@@ -1680,7 -1680,7 +1680,11 @@@ nfp_flower_setup_indr_tc_block(struct n
  		block_cb = flow_indr_block_cb_alloc(nfp_flower_setup_indr_block_cb,
  						    cb_priv, cb_priv,
  						    nfp_flower_setup_indr_tc_release,
++<<<<<<< HEAD
 +						    f, netdev, data, cleanup);
++=======
+ 						    f, netdev, sch, data, app, cleanup);
++>>>>>>> c40f4e50b6cf (net: sched: Pass qdisc reference in struct flow_block_offload)
  		if (IS_ERR(block_cb)) {
  			list_del(&cb_priv->list);
  			kfree(cb_priv);
diff --cc include/net/flow_offload.h
index 25f5ebd13aa2,9f88a7b730a8..000000000000
--- a/include/net/flow_offload.h
+++ b/include/net/flow_offload.h
@@@ -451,8 -456,10 +452,9 @@@ struct flow_block_cb
  struct flow_block_indr {
  	struct list_head		list;
  	struct net_device		*dev;
+ 	struct Qdisc			*sch;
  	enum flow_block_binder_type	binder_type;
  	void				*data;
 -	void				*cb_priv;
  	void				(*cleanup)(struct flow_block_cb *block_cb);
  };
  
@@@ -474,7 -481,9 +476,13 @@@ struct flow_block_cb *flow_indr_block_c
  					       void *cb_ident, void *cb_priv,
  					       void (*release)(void *cb_priv),
  					       struct flow_block_offload *bo,
++<<<<<<< HEAD
 +					       struct net_device *dev, void *data,
++=======
+ 					       struct net_device *dev,
+ 					       struct Qdisc *sch, void *data,
+ 					       void *indr_cb_priv,
++>>>>>>> c40f4e50b6cf (net: sched: Pass qdisc reference in struct flow_block_offload)
  					       void (*cleanup)(struct flow_block_cb *block_cb));
  void flow_block_cb_free(struct flow_block_cb *block_cb);
  
@@@ -559,8 -563,8 +567,13 @@@ typedef int flow_indr_block_bind_cb_t(s
  
  int flow_indr_dev_register(flow_indr_block_bind_cb_t *cb, void *cb_priv);
  void flow_indr_dev_unregister(flow_indr_block_bind_cb_t *cb, void *cb_priv,
++<<<<<<< HEAD
 +			      flow_setup_cb_t *setup_cb);
 +int flow_indr_dev_setup_offload(struct net_device *dev,
++=======
+ 			      void (*release)(void *cb_priv));
+ int flow_indr_dev_setup_offload(struct net_device *dev, struct Qdisc *sch,
++>>>>>>> c40f4e50b6cf (net: sched: Pass qdisc reference in struct flow_block_offload)
  				enum tc_setup_type type, void *data,
  				struct flow_block_offload *bo,
  				void (*cleanup)(struct flow_block_cb *block_cb));
diff --cc net/core/flow_offload.c
index 5e5f0e36f351,b8cf6ff5f961..000000000000
--- a/net/core/flow_offload.c
+++ b/net/core/flow_offload.c
@@@ -429,12 -429,15 +429,18 @@@ EXPORT_SYMBOL(flow_indr_dev_unregister)
  
  static void flow_block_indr_init(struct flow_block_cb *flow_block,
  				 struct flow_block_offload *bo,
++<<<<<<< HEAD
 +				 struct net_device *dev, void *data,
++=======
+ 				 struct net_device *dev, struct Qdisc *sch, void *data,
+ 				 void *cb_priv,
++>>>>>>> c40f4e50b6cf (net: sched: Pass qdisc reference in struct flow_block_offload)
  				 void (*cleanup)(struct flow_block_cb *block_cb))
  {
  	flow_block->indr.binder_type = bo->binder_type;
  	flow_block->indr.data = data;
 -	flow_block->indr.cb_priv = cb_priv;
  	flow_block->indr.dev = dev;
+ 	flow_block->indr.sch = sch;
  	flow_block->indr.cleanup = cleanup;
  }
  
@@@ -442,7 -445,9 +448,13 @@@ struct flow_block_cb *flow_indr_block_c
  					       void *cb_ident, void *cb_priv,
  					       void (*release)(void *cb_priv),
  					       struct flow_block_offload *bo,
++<<<<<<< HEAD
 +					       struct net_device *dev, void *data,
++=======
+ 					       struct net_device *dev,
+ 					       struct Qdisc *sch, void *data,
+ 					       void *indr_cb_priv,
++>>>>>>> c40f4e50b6cf (net: sched: Pass qdisc reference in struct flow_block_offload)
  					       void (*cleanup)(struct flow_block_cb *block_cb))
  {
  	struct flow_block_cb *block_cb;
@@@ -451,7 -456,7 +463,11 @@@
  	if (IS_ERR(block_cb))
  		goto out;
  
++<<<<<<< HEAD
 +	flow_block_indr_init(block_cb, bo, dev, data, cleanup);
++=======
+ 	flow_block_indr_init(block_cb, bo, dev, sch, data, indr_cb_priv, cleanup);
++>>>>>>> c40f4e50b6cf (net: sched: Pass qdisc reference in struct flow_block_offload)
  	list_add(&block_cb->indr.list, &flow_block_indr_list);
  
  out:
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
diff --git a/drivers/net/ethernet/netronome/nfp/flower/main.h b/drivers/net/ethernet/netronome/nfp/flower/main.h
index 14854e12e8c6..f44e41812252 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/main.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h
@@ -458,7 +458,7 @@ void nfp_flower_qos_cleanup(struct nfp_app *app);
 int nfp_flower_setup_qos_offload(struct nfp_app *app, struct net_device *netdev,
 				 struct tc_cls_matchall_offload *flow);
 void nfp_flower_stats_rlim_reply(struct nfp_app *app, struct sk_buff *skb);
-int nfp_flower_indr_setup_tc_cb(struct net_device *netdev, void *cb_priv,
+int nfp_flower_indr_setup_tc_cb(struct net_device *netdev, struct Qdisc *sch, void *cb_priv,
 				enum tc_setup_type type, void *type_data,
 				void *data,
 				void (*cleanup)(struct flow_block_cb *block_cb));
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/offload.c
* Unmerged path include/net/flow_offload.h
* Unmerged path net/core/flow_offload.c
diff --git a/net/netfilter/nf_flow_table_offload.c b/net/netfilter/nf_flow_table_offload.c
index 62651e6683f6..f62d4ffea214 100644
--- a/net/netfilter/nf_flow_table_offload.c
+++ b/net/netfilter/nf_flow_table_offload.c
@@ -963,7 +963,7 @@ static int nf_flow_table_indr_offload_cmd(struct flow_block_offload *bo,
 	nf_flow_table_block_offload_init(bo, dev_net(dev), cmd, flowtable,
 					 extack);
 
-	return flow_indr_dev_setup_offload(dev, TC_SETUP_FT, flowtable, bo,
+	return flow_indr_dev_setup_offload(dev, NULL, TC_SETUP_FT, flowtable, bo,
 					   nf_flow_table_indr_cleanup);
 }
 
diff --git a/net/netfilter/nf_tables_offload.c b/net/netfilter/nf_tables_offload.c
index 700d86107148..32076f7d32bb 100644
--- a/net/netfilter/nf_tables_offload.c
+++ b/net/netfilter/nf_tables_offload.c
@@ -311,7 +311,7 @@ static int nft_indr_block_offload_cmd(struct nft_base_chain *basechain,
 
 	nft_flow_block_offload_init(&bo, dev_net(dev), cmd, basechain, &extack);
 
-	err = flow_indr_dev_setup_offload(dev, TC_SETUP_BLOCK, basechain, &bo,
+	err = flow_indr_dev_setup_offload(dev, NULL, TC_SETUP_BLOCK, basechain, &bo,
 					  nft_indr_block_cleanup);
 	if (err < 0)
 		return err;
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index 1fbbb362271f..ef92daf6d0b5 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -626,7 +626,7 @@ static int tcf_block_setup(struct tcf_block *block,
 			   struct flow_block_offload *bo);
 
 static void tcf_block_offload_init(struct flow_block_offload *bo,
-				   struct net_device *dev,
+				   struct net_device *dev, struct Qdisc *sch,
 				   enum flow_block_command command,
 				   enum flow_block_binder_type binder_type,
 				   struct flow_block *flow_block,
@@ -638,6 +638,7 @@ static void tcf_block_offload_init(struct flow_block_offload *bo,
 	bo->block = flow_block;
 	bo->block_shared = shared;
 	bo->extack = extack;
+	bo->sch = sch;
 	INIT_LIST_HEAD(&bo->cb_list);
 }
 
@@ -648,10 +649,11 @@ static void tc_block_indr_cleanup(struct flow_block_cb *block_cb)
 {
 	struct tcf_block *block = block_cb->indr.data;
 	struct net_device *dev = block_cb->indr.dev;
+	struct Qdisc *sch = block_cb->indr.sch;
 	struct netlink_ext_ack extack = {};
 	struct flow_block_offload bo;
 
-	tcf_block_offload_init(&bo, dev, FLOW_BLOCK_UNBIND,
+	tcf_block_offload_init(&bo, dev, sch, FLOW_BLOCK_UNBIND,
 			       block_cb->indr.binder_type,
 			       &block->flow_block, tcf_block_shared(block),
 			       &extack);
@@ -669,14 +671,14 @@ static bool tcf_block_offload_in_use(struct tcf_block *block)
 }
 
 static int tcf_block_offload_cmd(struct tcf_block *block,
-				 struct net_device *dev,
+				 struct net_device *dev, struct Qdisc *sch,
 				 struct tcf_block_ext_info *ei,
 				 enum flow_block_command command,
 				 struct netlink_ext_ack *extack)
 {
 	struct flow_block_offload bo = {};
 
-	tcf_block_offload_init(&bo, dev, command, ei->binder_type,
+	tcf_block_offload_init(&bo, dev, sch, command, ei->binder_type,
 			       &block->flow_block, tcf_block_shared(block),
 			       extack);
 
@@ -693,7 +695,7 @@ static int tcf_block_offload_cmd(struct tcf_block *block,
 		return tcf_block_setup(block, &bo);
 	}
 
-	flow_indr_dev_setup_offload(dev, TC_SETUP_BLOCK, block, &bo,
+	flow_indr_dev_setup_offload(dev, sch, TC_SETUP_BLOCK, block, &bo,
 				    tc_block_indr_cleanup);
 	tcf_block_setup(block, &bo);
 
@@ -720,7 +722,7 @@ static int tcf_block_offload_bind(struct tcf_block *block, struct Qdisc *q,
 		goto err_unlock;
 	}
 
-	err = tcf_block_offload_cmd(block, dev, ei, FLOW_BLOCK_BIND, extack);
+	err = tcf_block_offload_cmd(block, dev, q, ei, FLOW_BLOCK_BIND, extack);
 	if (err == -EOPNOTSUPP)
 		goto no_offload_dev_inc;
 	if (err)
@@ -747,7 +749,7 @@ static void tcf_block_offload_unbind(struct tcf_block *block, struct Qdisc *q,
 	int err;
 
 	down_write(&block->cb_lock);
-	err = tcf_block_offload_cmd(block, dev, ei, FLOW_BLOCK_UNBIND, NULL);
+	err = tcf_block_offload_cmd(block, dev, q, ei, FLOW_BLOCK_UNBIND, NULL);
 	if (err == -EOPNOTSUPP)
 		goto no_offload_dev_dec;
 	up_write(&block->cb_lock);
