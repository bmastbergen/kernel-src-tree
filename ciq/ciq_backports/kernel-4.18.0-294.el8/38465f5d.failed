NFS: rename nfs_fs_context pointer arg in a few functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Scott Mayhew <smayhew@redhat.com>
commit 38465f5d1af932494d66b52d26bb3a02b837cdf8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/38465f5d.failed

Split out from commit "NFS: Add fs_context support."

Rename cfg to ctx in nfs_init_server(), nfs_verify_authflavors(),
and nfs_request_mount().  No functional changes.

	Signed-off-by: Scott Mayhew <smayhew@redhat.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 38465f5d1af932494d66b52d26bb3a02b837cdf8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/client.c
#	fs/nfs/super.c
diff --cc fs/nfs/client.c
index 1c6787d82fc3,69c0708b2acc..000000000000
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@@ -663,28 -658,28 +663,50 @@@ EXPORT_SYMBOL_GPL(nfs_init_client)
   * Create a version 2 or 3 client
   */
  static int nfs_init_server(struct nfs_server *server,
++<<<<<<< HEAD
 +			   const struct nfs_parsed_mount_data *data,
++=======
+ 			   const struct nfs_fs_context *ctx,
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  			   struct nfs_subversion *nfs_mod)
  {
  	struct rpc_timeout timeparms;
  	struct nfs_client_initdata cl_init = {
++<<<<<<< HEAD
 +		.hostname = data->nfs_server.hostname,
 +		.addr = (const struct sockaddr *)&data->nfs_server.address,
 +		.addrlen = data->nfs_server.addrlen,
 +		.nfs_mod = nfs_mod,
 +		.proto = data->nfs_server.protocol,
 +		.net = data->net,
 +		.timeparms = &timeparms,
 +		.cred = server->cred,
 +		.nconnect = data->nfs_server.nconnect,
++=======
+ 		.hostname = ctx->nfs_server.hostname,
+ 		.addr = (const struct sockaddr *)&ctx->nfs_server.address,
+ 		.addrlen = ctx->nfs_server.addrlen,
+ 		.nfs_mod = nfs_mod,
+ 		.proto = ctx->nfs_server.protocol,
+ 		.net = ctx->net,
+ 		.timeparms = &timeparms,
+ 		.cred = server->cred,
+ 		.nconnect = ctx->nfs_server.nconnect,
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  		.init_flags = (1UL << NFS_CS_REUSEPORT),
  	};
  	struct nfs_client *clp;
  	int error;
  
++<<<<<<< HEAD
 +	nfs_init_timeout_values(&timeparms, data->nfs_server.protocol,
 +			data->timeo, data->retrans);
 +	if (data->flags & NFS_MOUNT_NORESVPORT)
++=======
+ 	nfs_init_timeout_values(&timeparms, ctx->nfs_server.protocol,
+ 				ctx->timeo, ctx->retrans);
+ 	if (ctx->flags & NFS_MOUNT_NORESVPORT)
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  		set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);
  
  	/* Allocate or find a client reference we can use */
@@@ -695,46 -690,46 +717,84 @@@
  	server->nfs_client = clp;
  
  	/* Initialise the client representation from the mount data */
++<<<<<<< HEAD
 +	server->flags = data->flags;
 +	server->options = data->options;
++=======
+ 	server->flags = ctx->flags;
+ 	server->options = ctx->options;
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  	server->caps |= NFS_CAP_HARDLINKS|NFS_CAP_SYMLINKS|NFS_CAP_FILEID|
  		NFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|NFS_CAP_OWNER_GROUP|
  		NFS_CAP_ATIME|NFS_CAP_CTIME|NFS_CAP_MTIME;
  
++<<<<<<< HEAD
 +	if (data->rsize)
 +		server->rsize = nfs_block_size(data->rsize, NULL);
 +	if (data->wsize)
 +		server->wsize = nfs_block_size(data->wsize, NULL);
 +
 +	server->acregmin = data->acregmin * HZ;
 +	server->acregmax = data->acregmax * HZ;
 +	server->acdirmin = data->acdirmin * HZ;
 +	server->acdirmax = data->acdirmax * HZ;
++=======
+ 	if (ctx->rsize)
+ 		server->rsize = nfs_block_size(ctx->rsize, NULL);
+ 	if (ctx->wsize)
+ 		server->wsize = nfs_block_size(ctx->wsize, NULL);
+ 
+ 	server->acregmin = ctx->acregmin * HZ;
+ 	server->acregmax = ctx->acregmax * HZ;
+ 	server->acdirmin = ctx->acdirmin * HZ;
+ 	server->acdirmax = ctx->acdirmax * HZ;
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  
  	/* Start lockd here, before we might error out */
  	error = nfs_start_lockd(server);
  	if (error < 0)
  		goto error;
  
++<<<<<<< HEAD
 +	server->port = data->nfs_server.port;
 +	server->auth_info = data->auth_info;
 +
 +	error = nfs_init_server_rpcclient(server, &timeparms,
 +					  data->selected_flavor);
++=======
+ 	server->port = ctx->nfs_server.port;
+ 	server->auth_info = ctx->auth_info;
+ 
+ 	error = nfs_init_server_rpcclient(server, &timeparms,
+ 					  ctx->selected_flavor);
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  	if (error < 0)
  		goto error;
  
  	/* Preserve the values of mount_server-related mount options */
++<<<<<<< HEAD
 +	if (data->mount_server.addrlen) {
 +		memcpy(&server->mountd_address, &data->mount_server.address,
 +			data->mount_server.addrlen);
 +		server->mountd_addrlen = data->mount_server.addrlen;
 +	}
 +	server->mountd_version = data->mount_server.version;
 +	server->mountd_port = data->mount_server.port;
 +	server->mountd_protocol = data->mount_server.protocol;
 +
 +	server->namelen  = data->namlen;
++=======
+ 	if (ctx->mount_server.addrlen) {
+ 		memcpy(&server->mountd_address, &ctx->mount_server.address,
+ 			ctx->mount_server.addrlen);
+ 		server->mountd_addrlen = ctx->mount_server.addrlen;
+ 	}
+ 	server->mountd_version = ctx->mount_server.version;
+ 	server->mountd_port = ctx->mount_server.port;
+ 	server->mountd_protocol = ctx->mount_server.protocol;
+ 
+ 	server->namelen  = ctx->namlen;
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  	return 0;
  
  error:
diff --cc fs/nfs/super.c
index 5a0a0d311ce8,6c9573a32a69..000000000000
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@@ -1087,633 -726,13 +1087,643 @@@ bool nfs_auth_info_match(const struct n
  EXPORT_SYMBOL_GPL(nfs_auth_info_match);
  
  /*
++<<<<<<< HEAD
 + * Parse the value of the 'sec=' option.
 + */
 +static int nfs_parse_security_flavors(char *value,
 +				      struct nfs_parsed_mount_data *mnt)
 +{
 +	substring_t args[MAX_OPT_ARGS];
 +	rpc_authflavor_t pseudoflavor;
 +	char *p;
 +
 +	dfprintk(MOUNT, "NFS: parsing sec=%s option\n", value);
 +
 +	while ((p = strsep(&value, ":")) != NULL) {
 +		switch (match_token(p, nfs_secflavor_tokens, args)) {
 +		case Opt_sec_none:
 +			pseudoflavor = RPC_AUTH_NULL;
 +			break;
 +		case Opt_sec_sys:
 +			pseudoflavor = RPC_AUTH_UNIX;
 +			break;
 +		case Opt_sec_krb5:
 +			pseudoflavor = RPC_AUTH_GSS_KRB5;
 +			break;
 +		case Opt_sec_krb5i:
 +			pseudoflavor = RPC_AUTH_GSS_KRB5I;
 +			break;
 +		case Opt_sec_krb5p:
 +			pseudoflavor = RPC_AUTH_GSS_KRB5P;
 +			break;
 +		case Opt_sec_lkey:
 +			pseudoflavor = RPC_AUTH_GSS_LKEY;
 +			break;
 +		case Opt_sec_lkeyi:
 +			pseudoflavor = RPC_AUTH_GSS_LKEYI;
 +			break;
 +		case Opt_sec_lkeyp:
 +			pseudoflavor = RPC_AUTH_GSS_LKEYP;
 +			break;
 +		case Opt_sec_spkm:
 +			pseudoflavor = RPC_AUTH_GSS_SPKM;
 +			break;
 +		case Opt_sec_spkmi:
 +			pseudoflavor = RPC_AUTH_GSS_SPKMI;
 +			break;
 +		case Opt_sec_spkmp:
 +			pseudoflavor = RPC_AUTH_GSS_SPKMP;
 +			break;
 +		default:
 +			dfprintk(MOUNT,
 +				 "NFS: sec= option '%s' not recognized\n", p);
 +			return 0;
 +		}
 +
 +		if (!nfs_auth_info_add(&mnt->auth_info, pseudoflavor))
 +			return 0;
 +	}
 +
 +	return 1;
 +}
 +
 +static int nfs_parse_version_string(char *string,
 +		struct nfs_parsed_mount_data *mnt,
 +		substring_t *args)
 +{
 +	mnt->flags &= ~NFS_MOUNT_VER3;
 +	switch (match_token(string, nfs_vers_tokens, args)) {
 +	case Opt_vers_2:
 +		mnt->version = 2;
 +		break;
 +	case Opt_vers_3:
 +		mnt->flags |= NFS_MOUNT_VER3;
 +		mnt->version = 3;
 +		break;
 +	case Opt_vers_4:
 +		/* Backward compatibility option. In future,
 +		 * the mount program should always supply
 +		 * a NFSv4 minor version number.
 +		 */
 +		mnt->version = 4;
 +		break;
 +	case Opt_vers_4_0:
 +		mnt->version = 4;
 +		mnt->minorversion = 0;
 +		break;
 +	case Opt_vers_4_1:
 +		mnt->version = 4;
 +		mnt->minorversion = 1;
 +		break;
 +	case Opt_vers_4_2:
 +		mnt->version = 4;
 +		mnt->minorversion = 2;
 +		break;
 +	default:
 +		return 0;
 +	}
 +	return 1;
 +}
 +
 +static int nfs_get_option_str(substring_t args[], char **option)
 +{
 +	kfree(*option);
 +	*option = match_strdup(args);
 +	return !*option;
 +}
 +
 +static int nfs_get_option_ul(substring_t args[], unsigned long *option)
 +{
 +	int rc;
 +	char *string;
 +
 +	string = match_strdup(args);
 +	if (string == NULL)
 +		return -ENOMEM;
 +	rc = kstrtoul(string, 10, option);
 +	kfree(string);
 +
 +	return rc;
 +}
 +
 +static int nfs_get_option_ul_bound(substring_t args[], unsigned long *option,
 +		unsigned long l_bound, unsigned long u_bound)
 +{
 +	int ret;
 +
 +	ret = nfs_get_option_ul(args, option);
 +	if (ret != 0)
 +		return ret;
 +	if (*option < l_bound || *option > u_bound)
 +		return -ERANGE;
 +	return 0;
 +}
 +
 +/*
 + * Error-check and convert a string of mount options from user space into
 + * a data structure.  The whole mount string is processed; bad options are
 + * skipped as they are encountered.  If there were no errors, return 1;
 + * otherwise return 0 (zero).
 + */
 +static int nfs_parse_mount_options(char *raw,
 +				   struct nfs_parsed_mount_data *mnt)
 +{
 +	char *p, *string;
 +	int rc, sloppy = 0, invalid_option = 0;
 +	unsigned short protofamily = AF_UNSPEC;
 +	unsigned short mountfamily = AF_UNSPEC;
 +
 +	if (!raw) {
 +		dfprintk(MOUNT, "NFS: mount options string was NULL.\n");
 +		return 1;
 +	}
 +	dfprintk(MOUNT, "NFS: nfs mount opts='%s'\n", raw);
 +
 +	rc = security_sb_eat_lsm_opts(raw, &mnt->lsm_opts);
 +	if (rc)
 +		goto out_security_failure;
 +
 +	while ((p = strsep(&raw, ",")) != NULL) {
 +		substring_t args[MAX_OPT_ARGS];
 +		unsigned long option;
 +		int token;
 +
 +		if (!*p)
 +			continue;
 +
 +		dfprintk(MOUNT, "NFS:   parsing nfs mount option '%s'\n", p);
 +
 +		token = match_token(p, nfs_mount_option_tokens, args);
 +		switch (token) {
 +
 +		/*
 +		 * boolean options:  foo/nofoo
 +		 */
 +		case Opt_soft:
 +			mnt->flags |= NFS_MOUNT_SOFT;
 +			mnt->flags &= ~NFS_MOUNT_SOFTERR;
 +			break;
 +		case Opt_softerr:
 +			mnt->flags |= NFS_MOUNT_SOFTERR;
 +			mnt->flags &= ~NFS_MOUNT_SOFT;
 +			break;
 +		case Opt_hard:
 +			mnt->flags &= ~(NFS_MOUNT_SOFT|NFS_MOUNT_SOFTERR);
 +			break;
 +		case Opt_posix:
 +			mnt->flags |= NFS_MOUNT_POSIX;
 +			break;
 +		case Opt_noposix:
 +			mnt->flags &= ~NFS_MOUNT_POSIX;
 +			break;
 +		case Opt_cto:
 +			mnt->flags &= ~NFS_MOUNT_NOCTO;
 +			break;
 +		case Opt_nocto:
 +			mnt->flags |= NFS_MOUNT_NOCTO;
 +			break;
 +		case Opt_ac:
 +			mnt->flags &= ~NFS_MOUNT_NOAC;
 +			break;
 +		case Opt_noac:
 +			mnt->flags |= NFS_MOUNT_NOAC;
 +			break;
 +		case Opt_lock:
 +			mnt->flags &= ~NFS_MOUNT_NONLM;
 +			mnt->flags &= ~(NFS_MOUNT_LOCAL_FLOCK |
 +					NFS_MOUNT_LOCAL_FCNTL);
 +			break;
 +		case Opt_nolock:
 +			mnt->flags |= NFS_MOUNT_NONLM;
 +			mnt->flags |= (NFS_MOUNT_LOCAL_FLOCK |
 +				       NFS_MOUNT_LOCAL_FCNTL);
 +			break;
 +		case Opt_udp:
 +			mnt->flags &= ~NFS_MOUNT_TCP;
 +			mnt->nfs_server.protocol = XPRT_TRANSPORT_UDP;
 +			break;
 +		case Opt_tcp:
 +			mnt->flags |= NFS_MOUNT_TCP;
 +			mnt->nfs_server.protocol = XPRT_TRANSPORT_TCP;
 +			break;
 +		case Opt_rdma:
 +			mnt->flags |= NFS_MOUNT_TCP; /* for side protocols */
 +			mnt->nfs_server.protocol = XPRT_TRANSPORT_RDMA;
 +			xprt_load_transport(p);
 +			break;
 +		case Opt_acl:
 +			mnt->flags &= ~NFS_MOUNT_NOACL;
 +			break;
 +		case Opt_noacl:
 +			mnt->flags |= NFS_MOUNT_NOACL;
 +			break;
 +		case Opt_rdirplus:
 +			mnt->flags &= ~NFS_MOUNT_NORDIRPLUS;
 +			break;
 +		case Opt_nordirplus:
 +			mnt->flags |= NFS_MOUNT_NORDIRPLUS;
 +			break;
 +		case Opt_sharecache:
 +			mnt->flags &= ~NFS_MOUNT_UNSHARED;
 +			break;
 +		case Opt_nosharecache:
 +			mnt->flags |= NFS_MOUNT_UNSHARED;
 +			break;
 +		case Opt_resvport:
 +			mnt->flags &= ~NFS_MOUNT_NORESVPORT;
 +			break;
 +		case Opt_noresvport:
 +			mnt->flags |= NFS_MOUNT_NORESVPORT;
 +			break;
 +		case Opt_fscache:
 +			mnt->options |= NFS_OPTION_FSCACHE;
 +			kfree(mnt->fscache_uniq);
 +			mnt->fscache_uniq = NULL;
 +			break;
 +		case Opt_nofscache:
 +			mnt->options &= ~NFS_OPTION_FSCACHE;
 +			kfree(mnt->fscache_uniq);
 +			mnt->fscache_uniq = NULL;
 +			break;
 +		case Opt_migration:
 +			mnt->options |= NFS_OPTION_MIGRATION;
 +			break;
 +		case Opt_nomigration:
 +			mnt->options &= ~NFS_OPTION_MIGRATION;
 +			break;
 +
 +		/*
 +		 * options that take numeric values
 +		 */
 +		case Opt_port:
 +			if (nfs_get_option_ul(args, &option) ||
 +			    option > USHRT_MAX)
 +				goto out_invalid_value;
 +			mnt->nfs_server.port = option;
 +			break;
 +		case Opt_rsize:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->rsize = option;
 +			break;
 +		case Opt_wsize:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->wsize = option;
 +			break;
 +		case Opt_bsize:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->bsize = option;
 +			break;
 +		case Opt_timeo:
 +			if (nfs_get_option_ul_bound(args, &option, 1, INT_MAX))
 +				goto out_invalid_value;
 +			mnt->timeo = option;
 +			break;
 +		case Opt_retrans:
 +			if (nfs_get_option_ul_bound(args, &option, 0, INT_MAX))
 +				goto out_invalid_value;
 +			mnt->retrans = option;
 +			break;
 +		case Opt_acregmin:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acregmin = option;
 +			break;
 +		case Opt_acregmax:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acregmax = option;
 +			break;
 +		case Opt_acdirmin:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acdirmin = option;
 +			break;
 +		case Opt_acdirmax:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acdirmax = option;
 +			break;
 +		case Opt_actimeo:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->acregmin = mnt->acregmax =
 +			mnt->acdirmin = mnt->acdirmax = option;
 +			break;
 +		case Opt_namelen:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			mnt->namlen = option;
 +			break;
 +		case Opt_mountport:
 +			if (nfs_get_option_ul(args, &option) ||
 +			    option > USHRT_MAX)
 +				goto out_invalid_value;
 +			mnt->mount_server.port = option;
 +			break;
 +		case Opt_mountvers:
 +			if (nfs_get_option_ul(args, &option) ||
 +			    option < NFS_MNT_VERSION ||
 +			    option > NFS_MNT3_VERSION)
 +				goto out_invalid_value;
 +			mnt->mount_server.version = option;
 +			break;
 +		case Opt_minorversion:
 +			if (nfs_get_option_ul(args, &option))
 +				goto out_invalid_value;
 +			if (option > NFS4_MAX_MINOR_VERSION)
 +				goto out_invalid_value;
 +			mnt->minorversion = option;
 +			break;
 +
 +		/*
 +		 * options that take text values
 +		 */
 +		case Opt_nfsvers:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			rc = nfs_parse_version_string(string, mnt, args);
 +			kfree(string);
 +			if (!rc)
 +				goto out_invalid_value;
 +			break;
 +		case Opt_sec:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			rc = nfs_parse_security_flavors(string, mnt);
 +			kfree(string);
 +			if (!rc) {
 +				dfprintk(MOUNT, "NFS:   unrecognized "
 +						"security flavor\n");
 +				return 0;
 +			}
 +			break;
 +		case Opt_proto:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			token = match_token(string,
 +					    nfs_xprt_protocol_tokens, args);
 +
 +			protofamily = AF_INET;
 +			switch (token) {
 +			case Opt_xprt_udp6:
 +				protofamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_udp:
 +				mnt->flags &= ~NFS_MOUNT_TCP;
 +				mnt->nfs_server.protocol = XPRT_TRANSPORT_UDP;
 +				break;
 +			case Opt_xprt_tcp6:
 +				protofamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_tcp:
 +				mnt->flags |= NFS_MOUNT_TCP;
 +				mnt->nfs_server.protocol = XPRT_TRANSPORT_TCP;
 +				break;
 +			case Opt_xprt_rdma6:
 +				protofamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_rdma:
 +				/* vector side protocols to TCP */
 +				mnt->flags |= NFS_MOUNT_TCP;
 +				mnt->nfs_server.protocol = XPRT_TRANSPORT_RDMA;
 +				xprt_load_transport(string);
 +				break;
 +			default:
 +				dfprintk(MOUNT, "NFS:   unrecognized "
 +						"transport protocol\n");
 +				kfree(string);
 +				return 0;
 +			}
 +			kfree(string);
 +			break;
 +		case Opt_mountproto:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			token = match_token(string,
 +					    nfs_xprt_protocol_tokens, args);
 +			kfree(string);
 +
 +			mountfamily = AF_INET;
 +			switch (token) {
 +			case Opt_xprt_udp6:
 +				mountfamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_udp:
 +				mnt->mount_server.protocol = XPRT_TRANSPORT_UDP;
 +				break;
 +			case Opt_xprt_tcp6:
 +				mountfamily = AF_INET6;
 +				/* fall through */
 +			case Opt_xprt_tcp:
 +				mnt->mount_server.protocol = XPRT_TRANSPORT_TCP;
 +				break;
 +			case Opt_xprt_rdma: /* not used for side protocols */
 +			default:
 +				dfprintk(MOUNT, "NFS:   unrecognized "
 +						"transport protocol\n");
 +				return 0;
 +			}
 +			break;
 +		case Opt_addr:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			mnt->nfs_server.addrlen =
 +				rpc_pton(mnt->net, string, strlen(string),
 +					(struct sockaddr *)
 +					&mnt->nfs_server.address,
 +					sizeof(mnt->nfs_server.address));
 +			kfree(string);
 +			if (mnt->nfs_server.addrlen == 0)
 +				goto out_invalid_address;
 +			break;
 +		case Opt_clientaddr:
 +			if (nfs_get_option_str(args, &mnt->client_address))
 +				goto out_nomem;
 +			break;
 +		case Opt_mounthost:
 +			if (nfs_get_option_str(args,
 +					       &mnt->mount_server.hostname))
 +				goto out_nomem;
 +			break;
 +		case Opt_mountaddr:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			mnt->mount_server.addrlen =
 +				rpc_pton(mnt->net, string, strlen(string),
 +					(struct sockaddr *)
 +					&mnt->mount_server.address,
 +					sizeof(mnt->mount_server.address));
 +			kfree(string);
 +			if (mnt->mount_server.addrlen == 0)
 +				goto out_invalid_address;
 +			break;
 +		case Opt_nconnect:
 +			if (nfs_get_option_ul_bound(args, &option, 1, NFS_MAX_CONNECTIONS))
 +				goto out_invalid_value;
 +			mnt->nfs_server.nconnect = option;
 +			break;
 +		case Opt_lookupcache:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			token = match_token(string,
 +					nfs_lookupcache_tokens, args);
 +			kfree(string);
 +			switch (token) {
 +				case Opt_lookupcache_all:
 +					mnt->flags &= ~(NFS_MOUNT_LOOKUP_CACHE_NONEG|NFS_MOUNT_LOOKUP_CACHE_NONE);
 +					break;
 +				case Opt_lookupcache_positive:
 +					mnt->flags &= ~NFS_MOUNT_LOOKUP_CACHE_NONE;
 +					mnt->flags |= NFS_MOUNT_LOOKUP_CACHE_NONEG;
 +					break;
 +				case Opt_lookupcache_none:
 +					mnt->flags |= NFS_MOUNT_LOOKUP_CACHE_NONEG|NFS_MOUNT_LOOKUP_CACHE_NONE;
 +					break;
 +				default:
 +					dfprintk(MOUNT, "NFS:   invalid "
 +							"lookupcache argument\n");
 +					return 0;
 +			}
 +			break;
 +		case Opt_fscache_uniq:
 +			if (nfs_get_option_str(args, &mnt->fscache_uniq))
 +				goto out_nomem;
 +			mnt->options |= NFS_OPTION_FSCACHE;
 +			break;
 +		case Opt_local_lock:
 +			string = match_strdup(args);
 +			if (string == NULL)
 +				goto out_nomem;
 +			token = match_token(string, nfs_local_lock_tokens,
 +					args);
 +			kfree(string);
 +			switch (token) {
 +			case Opt_local_lock_all:
 +				mnt->flags |= (NFS_MOUNT_LOCAL_FLOCK |
 +					       NFS_MOUNT_LOCAL_FCNTL);
 +				break;
 +			case Opt_local_lock_flock:
 +				mnt->flags |= NFS_MOUNT_LOCAL_FLOCK;
 +				break;
 +			case Opt_local_lock_posix:
 +				mnt->flags |= NFS_MOUNT_LOCAL_FCNTL;
 +				break;
 +			case Opt_local_lock_none:
 +				mnt->flags &= ~(NFS_MOUNT_LOCAL_FLOCK |
 +						NFS_MOUNT_LOCAL_FCNTL);
 +				break;
 +			default:
 +				dfprintk(MOUNT, "NFS:	invalid	"
 +						"local_lock argument\n");
 +				return 0;
 +			}
 +			break;
 +
 +		/*
 +		 * Special options
 +		 */
 +		case Opt_sloppy:
 +			sloppy = 1;
 +			dfprintk(MOUNT, "NFS:   relaxing parsing rules\n");
 +			break;
 +		case Opt_userspace:
 +		case Opt_deprecated:
 +			dfprintk(MOUNT, "NFS:   ignoring mount option "
 +					"'%s'\n", p);
 +			break;
 +
 +		default:
 +			invalid_option = 1;
 +			dfprintk(MOUNT, "NFS:   unrecognized mount option "
 +					"'%s'\n", p);
 +		}
 +	}
 +
 +	if (!sloppy && invalid_option)
 +		return 0;
 +
 +	if (mnt->minorversion && mnt->version != 4)
 +		goto out_minorversion_mismatch;
 +
 +	if (mnt->options & NFS_OPTION_MIGRATION &&
 +	    (mnt->version != 4 || mnt->minorversion != 0))
 +		goto out_migration_misuse;
 +
 +	/*
 +	 * verify that any proto=/mountproto= options match the address
 +	 * families in the addr=/mountaddr= options.
 +	 */
 +	if (protofamily != AF_UNSPEC &&
 +	    protofamily != mnt->nfs_server.address.ss_family)
 +		goto out_proto_mismatch;
 +
 +	if (mountfamily != AF_UNSPEC) {
 +		if (mnt->mount_server.addrlen) {
 +			if (mountfamily != mnt->mount_server.address.ss_family)
 +				goto out_mountproto_mismatch;
 +		} else {
 +			if (mountfamily != mnt->nfs_server.address.ss_family)
 +				goto out_mountproto_mismatch;
 +		}
 +	}
 +
 +	return 1;
 +
 +out_mountproto_mismatch:
 +	printk(KERN_INFO "NFS: mount server address does not match mountproto= "
 +			 "option\n");
 +	return 0;
 +out_proto_mismatch:
 +	printk(KERN_INFO "NFS: server address does not match proto= option\n");
 +	return 0;
 +out_invalid_address:
 +	printk(KERN_INFO "NFS: bad IP address specified: %s\n", p);
 +	return 0;
 +out_invalid_value:
 +	printk(KERN_INFO "NFS: bad mount option value specified: %s\n", p);
 +	return 0;
 +out_minorversion_mismatch:
 +	printk(KERN_INFO "NFS: mount option vers=%u does not support "
 +			 "minorversion=%u\n", mnt->version, mnt->minorversion);
 +	return 0;
 +out_migration_misuse:
 +	printk(KERN_INFO
 +		"NFS: 'migration' not supported for this NFS version\n");
 +	return 0;
 +out_nomem:
 +	printk(KERN_INFO "NFS: not enough memory to parse option\n");
 +	return 0;
 +out_security_failure:
 +	printk(KERN_INFO "NFS: security options invalid: %d\n", rc);
 +	return 0;
 +}
 +
 +/*
 + * Ensure that a specified authtype in args->auth_info is supported by
 + * the server. Returns 0 and sets args->selected_flavor if it's ok, and
 + * -EACCES if not.
 + */
 +static int nfs_verify_authflavors(struct nfs_parsed_mount_data *args,
 +			rpc_authflavor_t *server_authlist, unsigned int count)
++=======
+  * Ensure that a specified authtype in ctx->auth_info is supported by
+  * the server. Returns 0 and sets ctx->selected_flavor if it's ok, and
+  * -EACCES if not.
+  */
+ static int nfs_verify_authflavors(struct nfs_fs_context *ctx,
+ 				  rpc_authflavor_t *server_authlist,
+ 				  unsigned int count)
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  {
  	rpc_authflavor_t flavor = RPC_AUTH_MAXFLAVOR;
  	bool found_auth_null = false;
@@@ -1734,7 -753,7 +1744,11 @@@
  	for (i = 0; i < count; i++) {
  		flavor = server_authlist[i];
  
++<<<<<<< HEAD
 +		if (nfs_auth_info_match(&args->auth_info, flavor))
++=======
+ 		if (nfs_auth_info_match(&ctx->auth_info, flavor))
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  			goto out;
  
  		if (flavor == RPC_AUTH_NULL)
@@@ -1742,7 -761,7 +1756,11 @@@
  	}
  
  	if (found_auth_null) {
++<<<<<<< HEAD
 +		flavor = args->auth_info.flavors[0];
++=======
+ 		flavor = ctx->auth_info.flavors[0];
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  		goto out;
  	}
  
@@@ -1751,8 -770,8 +1769,13 @@@
  	return -EACCES;
  
  out:
++<<<<<<< HEAD
 +	args->selected_flavor = flavor;
 +	dfprintk(MOUNT, "NFS: using auth flavor %u\n", args->selected_flavor);
++=======
+ 	ctx->selected_flavor = flavor;
+ 	dfprintk(MOUNT, "NFS: using auth flavor %u\n", ctx->selected_flavor);
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  	return 0;
  }
  
@@@ -1760,50 -779,50 +1783,93 @@@
   * Use the remote server's MOUNT service to request the NFS file handle
   * corresponding to the provided path.
   */
++<<<<<<< HEAD
 +static int nfs_request_mount(struct nfs_parsed_mount_data *args,
++=======
+ static int nfs_request_mount(struct nfs_fs_context *ctx,
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  			     struct nfs_fh *root_fh,
  			     rpc_authflavor_t *server_authlist,
  			     unsigned int *server_authlist_len)
  {
  	struct nfs_mount_request request = {
  		.sap		= (struct sockaddr *)
++<<<<<<< HEAD
 +						&args->mount_server.address,
 +		.dirpath	= args->nfs_server.export_path,
 +		.protocol	= args->mount_server.protocol,
 +		.fh		= root_fh,
 +		.noresvport	= args->flags & NFS_MOUNT_NORESVPORT,
 +		.auth_flav_len	= server_authlist_len,
 +		.auth_flavs	= server_authlist,
 +		.net		= args->net,
 +	};
 +	int status;
 +
 +	if (args->mount_server.version == 0) {
 +		switch (args->version) {
 +			default:
 +				args->mount_server.version = NFS_MNT3_VERSION;
 +				break;
 +			case 2:
 +				args->mount_server.version = NFS_MNT_VERSION;
 +		}
 +	}
 +	request.version = args->mount_server.version;
 +
 +	if (args->mount_server.hostname)
 +		request.hostname = args->mount_server.hostname;
 +	else
 +		request.hostname = args->nfs_server.hostname;
++=======
+ 						&ctx->mount_server.address,
+ 		.dirpath	= ctx->nfs_server.export_path,
+ 		.protocol	= ctx->mount_server.protocol,
+ 		.fh		= root_fh,
+ 		.noresvport	= ctx->flags & NFS_MOUNT_NORESVPORT,
+ 		.auth_flav_len	= server_authlist_len,
+ 		.auth_flavs	= server_authlist,
+ 		.net		= ctx->net,
+ 	};
+ 	int status;
+ 
+ 	if (ctx->mount_server.version == 0) {
+ 		switch (ctx->version) {
+ 			default:
+ 				ctx->mount_server.version = NFS_MNT3_VERSION;
+ 				break;
+ 			case 2:
+ 				ctx->mount_server.version = NFS_MNT_VERSION;
+ 		}
+ 	}
+ 	request.version = ctx->mount_server.version;
+ 
+ 	if (ctx->mount_server.hostname)
+ 		request.hostname = ctx->mount_server.hostname;
+ 	else
+ 		request.hostname = ctx->nfs_server.hostname;
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  
  	/*
  	 * Construct the mount server's address.
  	 */
++<<<<<<< HEAD
 +	if (args->mount_server.address.ss_family == AF_UNSPEC) {
 +		memcpy(request.sap, &args->nfs_server.address,
 +		       args->nfs_server.addrlen);
 +		args->mount_server.addrlen = args->nfs_server.addrlen;
 +	}
 +	request.salen = args->mount_server.addrlen;
 +	nfs_set_port(request.sap, &args->mount_server.port, 0);
++=======
+ 	if (ctx->mount_server.address.sa_family == AF_UNSPEC) {
+ 		memcpy(request.sap, &ctx->nfs_server.address,
+ 		       ctx->nfs_server.addrlen);
+ 		ctx->mount_server.addrlen = ctx->nfs_server.addrlen;
+ 	}
+ 	request.salen = ctx->mount_server.addrlen;
+ 	nfs_set_port(request.sap, &ctx->mount_server.port, 0);
++>>>>>>> 38465f5d1af9 (NFS: rename nfs_fs_context pointer arg in a few functions)
  
  	/*
  	 * Now ask the mount server to map our export path
* Unmerged path fs/nfs/client.c
* Unmerged path fs/nfs/super.c
