nvme-tcp: avoid race between time out and tear down

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chao Leng <lengchao@huawei.com>
commit d6f66210f4b1aa2f5944f0e34e0f8db44f499f92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d6f66210.failed

Now use teardown_lock to serialize for time out and tear down. This may
cause abnormal: first cancel all request in tear down, then time out may
complete the request again, but the request may already be freed or
restarted.

To avoid race between time out and tear down, in tear down process,
first we quiesce the queue, and then delete the timer and cancel
the time out work for the queue. At the same time we need to delete
teardown_lock.

	Signed-off-by: Chao Leng <lengchao@huawei.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit d6f66210f4b1aa2f5944f0e34e0f8db44f499f92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/tcp.c
diff --cc drivers/nvme/host/tcp.c
index bf1c3e2bb6ff,19f86ea547bb..000000000000
--- a/drivers/nvme/host/tcp.c
+++ b/drivers/nvme/host/tcp.c
@@@ -2187,6 -2162,18 +2183,21 @@@ static void nvme_tcp_submit_async_event
  	nvme_tcp_queue_request(&ctrl->async_req, true, true);
  }
  
++<<<<<<< HEAD
++=======
+ static void nvme_tcp_complete_timed_out(struct request *rq)
+ {
+ 	struct nvme_tcp_request *req = blk_mq_rq_to_pdu(rq);
+ 	struct nvme_ctrl *ctrl = &req->queue->ctrl->ctrl;
+ 
+ 	nvme_tcp_stop_queue(ctrl, nvme_tcp_queue_id(req->queue));
+ 	if (!blk_mq_request_completed(rq)) {
+ 		nvme_req(rq)->status = NVME_SC_HOST_ABORTED_CMD;
+ 		blk_mq_complete_request(rq);
+ 	}
+ }
+ 
++>>>>>>> d6f66210f4b1 (nvme-tcp: avoid race between time out and tear down)
  static enum blk_eh_timer_return
  nvme_tcp_timeout(struct request *rq, bool reserved)
  {
* Unmerged path drivers/nvme/host/tcp.c
