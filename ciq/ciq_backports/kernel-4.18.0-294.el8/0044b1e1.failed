net: atlantic: add support for FW 4.x

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Dmitry Bogdanov <dbogdanov@marvell.com>
commit 0044b1e1470aa62eeabb24983e2ff5433a68666a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0044b1e1.failed

This patch adds support for FW 4.x, which is about to get into the
production for some products.
4.x is mostly compatible with 3.x, save for soft reset, which requires
the acquisition of 2 additional semaphores.
Other differences (e.g. absence of PTP support) are handled via
capabilities.

Note: 4.x targets specific products only. 3.x is still the main firmware
branch, which should be used by most users (at least for now).

	Signed-off-by: Dmitry Bogdanov <dbogdanov@marvell.com>
	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0044b1e1470aa62eeabb24983e2ff5433a68666a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
index 961b9b69649f,9c3debae425f..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
@@@ -1,10 -1,8 +1,18 @@@
++<<<<<<< HEAD
 +/*
 + * aQuantia Corporation Network Driver
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+ // SPDX-License-Identifier: GPL-2.0-only
+ /* Atlantic Network Driver
+  *
+  * Copyright (C) 2014-2019 aQuantia Corporation
+  * Copyright (C) 2019-2020 Marvell International Ltd.
++>>>>>>> 0044b1e1470a (net: atlantic: add support for FW 4.x)
   */
  
  /* File hw_atl_llh.c: Definitions of bitfield and register access functions for
@@@ -1619,6 -1720,21 +1627,24 @@@ u32 hw_atl_sem_ram_get(struct aq_hw_s *
  	return hw_atl_reg_glb_cpu_sem_get(self, HW_ATL_FW_SM_RAM);
  }
  
++<<<<<<< HEAD
++=======
+ u32 hw_atl_sem_mdio_get(struct aq_hw_s *self)
+ {
+ 	return hw_atl_reg_glb_cpu_sem_get(self, HW_ATL_FW_SM_MDIO);
+ }
+ 
+ u32 hw_atl_sem_reset1_get(struct aq_hw_s *self)
+ {
+ 	return hw_atl_reg_glb_cpu_sem_get(self, HW_ATL_FW_SM_RESET1);
+ }
+ 
+ u32 hw_atl_sem_reset2_get(struct aq_hw_s *self)
+ {
+ 	return hw_atl_reg_glb_cpu_sem_get(self, HW_ATL_FW_SM_RESET2);
+ }
+ 
++>>>>>>> 0044b1e1470a (net: atlantic: add support for FW 4.x)
  u32 hw_atl_scrpad_get(struct aq_hw_s *aq_hw, u32 scratch_scp)
  {
  	return aq_hw_read_reg(aq_hw,
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
index 1dc201492ec7,f0954711df24..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
@@@ -1,10 -1,8 +1,18 @@@
++<<<<<<< HEAD
 +/*
 + * aQuantia Corporation Network Driver
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+ /* SPDX-License-Identifier: GPL-2.0-only */
+ /* Atlantic Network Driver
+  *
+  * Copyright (C) 2014-2019 aQuantia Corporation
+  * Copyright (C) 2019-2020 Marvell International Ltd.
++>>>>>>> 0044b1e1470a (net: atlantic: add support for FW 4.x)
   */
  
  /* File hw_atl_llh.h: Declarations of bitfield and register access functions for
@@@ -761,6 -804,44 +769,15 @@@ void hw_atl_rpfl3l4_ipv6_dest_addr_set(
  /* get global microprocessor ram semaphore */
  u32 hw_atl_sem_ram_get(struct aq_hw_s *self);
  
++<<<<<<< HEAD
++=======
+ /* get global microprocessor mdio semaphore */
+ u32 hw_atl_sem_mdio_get(struct aq_hw_s *self);
+ 
+ u32 hw_atl_sem_reset1_get(struct aq_hw_s *self);
+ u32 hw_atl_sem_reset2_get(struct aq_hw_s *self);
+ 
++>>>>>>> 0044b1e1470a (net: atlantic: add support for FW 4.x)
  /* get global microprocessor scratch pad register */
  u32 hw_atl_scrpad_get(struct aq_hw_s *aq_hw, u32 scratch_scp);
  
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
index 5ddaed96cf74,ee11cb88325e..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
@@@ -1,10 -1,8 +1,18 @@@
++<<<<<<< HEAD
 +/*
 + * aQuantia Corporation Network Driver
 + * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
 + *
 + * This program is free software; you can redistribute it and/or modify it
 + * under the terms and conditions of the GNU General Public License,
 + * version 2, as published by the Free Software Foundation.
++=======
+ /* SPDX-License-Identifier: GPL-2.0-only */
+ /* Atlantic Network Driver
+  *
+  * Copyright (C) 2014-2019 aQuantia Corporation
+  * Copyright (C) 2019-2020 Marvell International Ltd.
++>>>>>>> 0044b1e1470a (net: atlantic: add support for FW 4.x)
   */
  
  /* File hw_atl_llh_internal.h: Preprocessor definitions
@@@ -2535,50 -2724,125 +2543,130 @@@
  /* default value of bitfield uP Force Interrupt */
  #define HW_ATL_MCP_UP_FORCE_INTERRUPT_DEFAULT 0x0
  
 -/* Preprocessor definitions for Global MDIO Interfaces
 - * Address: 0x00000280 + 0x4 * Number of interface
 - */
 -#define HW_ATL_GLB_MDIO_IFACE_ADDR_BEGIN   0x00000280u
 +#define HW_ATL_RX_CTRL_ADDR_BEGIN_FL3L4   0x00005380
 +#define HW_ATL_RX_SRCA_ADDR_BEGIN_FL3L4   0x000053B0
 +#define HW_ATL_RX_DESTA_ADDR_BEGIN_FL3L4  0x000053D0
  
 -#define HW_ATL_GLB_MDIO_IFACE_N_ADR(number) \
 -	(HW_ATL_GLB_MDIO_IFACE_ADDR_BEGIN + (((number) - 1) * 0x4))
 +#define HW_ATL_RPF_L3_REG_CTRL_ADR(location) (0x00005380 + (location) * 0x4)
  
 -/* MIF MDIO Busy Bitfield Definitions
 - * Preprocessor definitions for the bitfield "MDIO Busy".
 - * PORT="mdio_pif_busy_o"
 +/* RX rpf_l3_sa{D}[1F:0] Bitfield Definitions
 + * Preprocessor definitions for the bitfield "l3_sa{D}[1F:0]".
 + * Parameter: location {D} | stride size 0x4 | range [0, 7]
 + * PORT="pif_rpf_l3_sa0_i[31:0]"
   */
  
 -/* Register address for bitfield MDIO Busy */
 -#define HW_ATL_MDIO_BUSY_ADR 0x00000284
 -/* Bitmask for bitfield MDIO Busy */
 -#define HW_ATL_MDIO_BUSY_MSK 0x80000000
 -/* Inverted bitmask for bitfield MDIO Busy */
 -#define HW_ATL_MDIO_BUSY_MSKN 0x7FFFFFFF
 -/* Lower bit position of bitfield MDIO Busy */
 -#define HW_ATL_MDIO_BUSY_SHIFT 31
 -/* Width of bitfield MDIO Busy */
 -#define HW_ATL_MDIO_BUSY_WIDTH 1
 +/* Register address for bitfield pif_rpf_l3_sa0_i[31:0] */
 +#define HW_ATL_RPF_L3_SRCA_ADR(location) (0x000053B0 + (location) * 0x4)
 +/* Bitmask for bitfield l3_sa0[1F:0] */
 +#define HW_ATL_RPF_L3_SRCA_MSK 0xFFFFFFFFu
 +/* Inverted bitmask for bitfield l3_sa0[1F:0] */
 +#define HW_ATL_RPF_L3_SRCA_MSKN 0xFFFFFFFFu
 +/* Lower bit position of bitfield l3_sa0[1F:0] */
 +#define HW_ATL_RPF_L3_SRCA_SHIFT 0
 +/* Width of bitfield l3_sa0[1F:0] */
 +#define HW_ATL_RPF_L3_SRCA_WIDTH 32
 +/* Default value of bitfield l3_sa0[1F:0] */
 +#define HW_ATL_RPF_L3_SRCA_DEFAULT 0x0
  
 -/* MIF MDIO Execute Operation Bitfield Definitions
 - * Preprocessor definitions for the bitfield "MDIO Execute Operation".
 - * PORT="pif_mdio_op_start_i"
 +/* RX rpf_l3_da{D}[1F:0] Bitfield Definitions
 + * Preprocessor definitions for the bitfield "l3_da{D}[1F:0]".
 + * Parameter: location {D} | stride size 0x4 | range [0, 7]
 + * PORT="pif_rpf_l3_da0_i[31:0]"
   */
  
 -/* Register address for bitfield MDIO Execute Operation */
 -#define HW_ATL_MDIO_EXECUTE_OPERATION_ADR 0x00000284
 -/* Bitmask for bitfield MDIO Execute Operation */
 -#define HW_ATL_MDIO_EXECUTE_OPERATION_MSK 0x00008000
 -/* Inverted bitmask for bitfield MDIO Execute Operation */
 -#define HW_ATL_MDIO_EXECUTE_OPERATION_MSKN 0xFFFF7FFF
 -/* Lower bit position of bitfield MDIO Execute Operation */
 -#define HW_ATL_MDIO_EXECUTE_OPERATION_SHIFT 15
 -/* Width of bitfield MDIO Execute Operation */
 -#define HW_ATL_MDIO_EXECUTE_OPERATION_WIDTH 1
 -/* Default value of bitfield MDIO Execute Operation */
 -#define HW_ATL_MDIO_EXECUTE_OPERATION_DEFAULT 0x0
 + /* Register address for bitfield pif_rpf_l3_da0_i[31:0] */
 +#define HW_ATL_RPF_L3_DSTA_ADR(location) (0x000053B0 + (location) * 0x4)
 +/* Bitmask for bitfield l3_da0[1F:0] */
 +#define HW_ATL_RPF_L3_DSTA_MSK 0xFFFFFFFFu
 +/* Inverted bitmask for bitfield l3_da0[1F:0] */
 +#define HW_ATL_RPF_L3_DSTA_MSKN 0xFFFFFFFFu
 +/* Lower bit position of bitfield l3_da0[1F:0] */
 +#define HW_ATL_RPF_L3_DSTA_SHIFT 0
 +/* Width of bitfield l3_da0[1F:0] */
 +#define HW_ATL_RPF_L3_DSTA_WIDTH 32
 +/* Default value of bitfield l3_da0[1F:0] */
 +#define HW_ATL_RPF_L3_DSTA_DEFAULT 0x0
  
++<<<<<<< HEAD
++=======
+ /* MIF Op Mode [1:0] Bitfield Definitions
+  * Preprocessor definitions for the bitfield "Op Mode [1:0]".
+  * PORT="pif_mdio_mode_i[1:0]"
+  */
+ 
+ /* Register address for bitfield Op Mode [1:0] */
+ #define HW_ATL_MDIO_OP_MODE_ADR 0x00000284
+ /* Bitmask for bitfield Op Mode [1:0] */
+ #define HW_ATL_MDIO_OP_MODE_MSK 0x00003000
+ /* Inverted bitmask for bitfield Op Mode [1:0] */
+ #define HW_ATL_MDIO_OP_MODE_MSKN 0xFFFFCFFF
+ /* Lower bit position of bitfield Op Mode [1:0] */
+ #define HW_ATL_MDIO_OP_MODE_SHIFT 12
+ /* Width of bitfield Op Mode [1:0] */
+ #define HW_ATL_MDIO_OP_MODE_WIDTH 2
+ /* Default value of bitfield Op Mode [1:0] */
+ #define HW_ATL_MDIO_OP_MODE_DEFAULT 0x0
+ 
+ /* MIF PHY address Bitfield Definitions
+  * Preprocessor definitions for the bitfield "PHY address".
+  * PORT="pif_mdio_phy_addr_i[9:0]"
+  */
+ 
+ /* Register address for bitfield PHY address */
+ #define HW_ATL_MDIO_PHY_ADDRESS_ADR 0x00000284
+ /* Bitmask for bitfield PHY address */
+ #define HW_ATL_MDIO_PHY_ADDRESS_MSK 0x000003FF
+ /* Inverted bitmask for bitfield PHY address */
+ #define HW_ATL_MDIO_PHY_ADDRESS_MSKN 0xFFFFFC00
+ /* Lower bit position of bitfield PHY address */
+ #define HW_ATL_MDIO_PHY_ADDRESS_SHIFT 0
+ /* Width of bitfield PHY address */
+ #define HW_ATL_MDIO_PHY_ADDRESS_WIDTH 10
+ /* Default value of bitfield PHY address */
+ #define HW_ATL_MDIO_PHY_ADDRESS_DEFAULT 0x0
+ 
+ /* MIF MDIO WriteData [F:0] Bitfield Definitions
+  * Preprocessor definitions for the bitfield "MDIO WriteData [F:0]".
+  * PORT="pif_mdio_wdata_i[15:0]"
+  */
+ 
+ /* Register address for bitfield MDIO WriteData [F:0] */
+ #define HW_ATL_MDIO_WRITE_DATA_ADR 0x00000288
+ /* Bitmask for bitfield MDIO WriteData [F:0] */
+ #define HW_ATL_MDIO_WRITE_DATA_MSK 0x0000FFFF
+ /* Inverted bitmask for bitfield MDIO WriteData [F:0] */
+ #define HW_ATL_MDIO_WRITE_DATA_MSKN 0xFFFF0000
+ /* Lower bit position of bitfield MDIO WriteData [F:0] */
+ #define HW_ATL_MDIO_WRITE_DATA_SHIFT 0
+ /* Width of bitfield MDIO WriteData [F:0] */
+ #define HW_ATL_MDIO_WRITE_DATA_WIDTH 16
+ /* Default value of bitfield MDIO WriteData [F:0] */
+ #define HW_ATL_MDIO_WRITE_DATA_DEFAULT 0x0
+ 
+ /* MIF MDIO Address [F:0] Bitfield Definitions
+  * Preprocessor definitions for the bitfield "MDIO Address [F:0]".
+  * PORT="pif_mdio_addr_i[15:0]"
+  */
+ 
+ /* Register address for bitfield MDIO Address [F:0] */
+ #define HW_ATL_MDIO_ADDRESS_ADR 0x0000028C
+ /* Bitmask for bitfield MDIO Address [F:0] */
+ #define HW_ATL_MDIO_ADDRESS_MSK 0x0000FFFF
+ /* Inverted bitmask for bitfield MDIO Address [F:0] */
+ #define HW_ATL_MDIO_ADDRESS_MSKN 0xFFFF0000
+ /* Lower bit position of bitfield MDIO Address [F:0] */
+ #define HW_ATL_MDIO_ADDRESS_SHIFT 0
+ /* Width of bitfield MDIO Address [F:0] */
+ #define HW_ATL_MDIO_ADDRESS_WIDTH 16
+ /* Default value of bitfield MDIO Address [F:0] */
+ #define HW_ATL_MDIO_ADDRESS_DEFAULT 0x0
+ 
+ #define HW_ATL_MIF_RESET_TIMEOUT_ADR 0x00000348
+ 
+ #define HW_ATL_FW_SM_MDIO       0x0U
++>>>>>>> 0044b1e1470a (net: atlantic: add support for FW 4.x)
  #define HW_ATL_FW_SM_RAM        0x2U
+ #define HW_ATL_FW_SM_RESET1     0x3U
+ #define HW_ATL_FW_SM_RESET2     0x4U
  
  #endif /* HW_ATL_LLH_INTERNAL_H */
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 38915aa0fd19,cacab3352cb8..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@@ -68,17 -71,16 +69,19 @@@ int hw_atl_utils_initfw(struct aq_hw_s 
  	hw_atl_utils_hw_chip_features_init(self,
  					   &self->chip_features);
  
 -	self->fw_ver_actual = hw_atl_utils_get_fw_version(self);
 +	hw_atl_utils_get_fw_version(self, &self->fw_ver_actual);
  
 -	if (hw_atl_utils_ver_match(HW_ATL_FW_VER_1X, self->fw_ver_actual)) {
 +	if (hw_atl_utils_ver_match(HW_ATL_FW_VER_1X,
 +				   self->fw_ver_actual) == 0) {
  		*fw_ops = &aq_fw_1x_ops;
 -	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_2X, self->fw_ver_actual)) {
 +	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_2X,
 +					  self->fw_ver_actual) == 0) {
  		*fw_ops = &aq_fw_2x_ops;
 -	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_3X, self->fw_ver_actual)) {
 +	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_3X,
 +					  self->fw_ver_actual) == 0) {
  		*fw_ops = &aq_fw_2x_ops;
+ 	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_4X, self->fw_ver_actual)) {
+ 		*fw_ops = &aq_fw_2x_ops;
  	} else {
  		aq_pr_err("Bad FW version detected: %x\n",
  			  self->fw_ver_actual);
@@@ -236,9 -239,10 +239,13 @@@ static int hw_atl_utils_soft_reset_rbl(
  
  int hw_atl_utils_soft_reset(struct aq_hw_s *self)
  {
++<<<<<<< HEAD
 +	int k;
++=======
+ 	int ver = hw_atl_utils_get_fw_version(self);
++>>>>>>> 0044b1e1470a (net: atlantic: add support for FW 4.x)
  	u32 boot_exit_code = 0;
  	u32 val;
 -	int k;
  
  	for (k = 0; k < 1000; ++k) {
  		u32 flb_status = aq_hw_read_reg(self,
@@@ -256,14 -260,12 +263,21 @@@
  
  	self->rbl_enabled = (boot_exit_code != 0);
  
++<<<<<<< HEAD
 +	/* FW 1.x may bootup in an invalid POWER state (WOL feature).
 +	 * We should work around this by forcing its state back to DEINIT
 +	 */
 +	if (!hw_atl_utils_ver_match(HW_ATL_FW_VER_1X,
 +				    aq_hw_read_reg(self,
 +						   HW_ATL_MPI_FW_VERSION))) {
++=======
+ 	if (hw_atl_utils_ver_match(HW_ATL_FW_VER_1X, ver)) {
++>>>>>>> 0044b1e1470a (net: atlantic: add support for FW 4.x)
  		int err = 0;
  
+ 		/* FW 1.x may bootup in an invalid POWER state (WOL feature).
+ 		 * We should work around this by forcing its state back to DEINIT
+ 		 */
  		hw_atl_utils_mpi_set_state(self, MPI_DEINIT);
  		err = readx_poll_timeout_atomic(hw_atl_utils_mpi_get_state,
  						self, val,
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
