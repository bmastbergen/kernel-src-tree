mm/page_isolation: fix potential warning from user

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Qian Cai <cai@lca.pw>
commit 3d680bdf60a5bade3e8cbd049927e7f8b1d3fe97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3d680bdf.failed

It makes sense to call the WARN_ON_ONCE(zone_idx(zone) == ZONE_MOVABLE)
from start_isolate_page_range(), but should avoid triggering it from
userspace, i.e, from is_mem_section_removable() because it could crash
the system by a non-root user if warn_on_panic is set.

While at it, simplify the code a bit by removing an unnecessary jump
label.

Link: http://lkml.kernel.org/r/20200120163915.1469-1-cai@lca.pw
	Signed-off-by: Qian Cai <cai@lca.pw>
	Suggested-by: Michal Hocko <mhocko@kernel.org>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3d680bdf60a5bade3e8cbd049927e7f8b1d3fe97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
#	mm/page_isolation.c
diff --cc mm/page_alloc.c
index 86fc898ac882,15e908ad933b..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -7848,26 -8205,26 +7848,31 @@@ bool has_unmovable_pages(struct zone *z
  	 * can still lead to having bootmem allocations in zone_movable.
  	 */
  
 -	if (is_migrate_cma_page(page)) {
 -		/*
 -		 * CMA allocations (alloc_contig_range) really need to mark
 -		 * isolate CMA pageblocks even when they are not movable in fact
 -		 * so consider them movable here.
 -		 */
 -		if (is_migrate_cma(migratetype))
 -			return NULL;
 +	/*
 +	 * CMA allocations (alloc_contig_range) really need to mark isolate
 +	 * CMA pageblocks even when they are not movable in fact so consider
 +	 * them movable here.
 +	 */
 +	if (is_migrate_cma(migratetype) &&
 +			is_migrate_cma(get_pageblock_migratetype(page)))
 +		return false;
  
++<<<<<<< HEAD
 +	pfn = page_to_pfn(page);
 +	for (found = 0, iter = 0; iter < pageblock_nr_pages; iter++) {
 +		unsigned long check = pfn + iter;
++=======
+ 		return page;
+ 	}
++>>>>>>> 3d680bdf60a5 (mm/page_isolation: fix potential warning from user)
  
 -	for (; iter < pageblock_nr_pages; iter++) {
 -		if (!pfn_valid_within(pfn + iter))
 +		if (!pfn_valid_within(check))
  			continue;
  
 -		page = pfn_to_page(pfn + iter);
 +		page = pfn_to_page(check);
  
  		if (PageReserved(page))
- 			goto unmovable;
+ 			return page;
  
  		/*
  		 * If the zone is movable and we have ruled out all reserved
@@@ -7887,9 -8244,9 +7892,9 @@@
  			unsigned int skip_pages;
  
  			if (!hugepage_migration_supported(page_hstate(head)))
- 				goto unmovable;
+ 				return page;
  
 -			skip_pages = compound_nr(head) - (page - head);
 +			skip_pages = (1 << compound_order(head)) - (page - head);
  			iter += skip_pages - 1;
  			continue;
  		}
@@@ -7931,14 -8286,9 +7936,20 @@@
  		 * is set to both of a memory hole page and a _used_ kernel
  		 * page at boot.
  		 */
++<<<<<<< HEAD
 +		if (found > count)
 +			goto unmovable;
 +	}
 +	return false;
 +unmovable:
 +	WARN_ON_ONCE(zone_idx(zone) == ZONE_MOVABLE);
 +	dump_page(pfn_to_page(pfn+iter), "unmovable page");
 +	return true;
++=======
+ 		return page;
+ 	}
+ 	return NULL;
++>>>>>>> 3d680bdf60a5 (mm/page_isolation: fix potential warning from user)
  }
  
  #ifdef CONFIG_CONTIG_ALLOC
diff --cc mm/page_isolation.c
index 7d60ced47f9d,a9fd7c740c23..000000000000
--- a/mm/page_isolation.c
+++ b/mm/page_isolation.c
@@@ -80,11 -49,24 +80,25 @@@ out
  									NULL);
  
  		__mod_zone_freepage_state(zone, -nr_pages, mt);
 -		ret = 0;
  	}
  
 -out:
  	spin_unlock_irqrestore(&zone->lock, flags);
- 	if (!ret)
+ 	if (!ret) {
  		drain_all_pages(zone);
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		WARN_ON_ONCE(zone_idx(zone) == ZONE_MOVABLE);
+ 
+ 		if ((isol_flags & REPORT_FAILURE) && unmovable)
+ 			/*
+ 			 * printk() with zone->lock held will likely trigger a
+ 			 * lockdep splat, so defer it here.
+ 			 */
+ 			dump_page(unmovable, "unmovable page");
+ 	}
+ 
++>>>>>>> 3d680bdf60a5 (mm/page_isolation: fix potential warning from user)
  	return ret;
  }
  
* Unmerged path mm/page_alloc.c
* Unmerged path mm/page_isolation.c
