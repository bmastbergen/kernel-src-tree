ethtool: add timestamping related string sets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michal Kubecek <mkubecek@suse.cz>
commit f76510b458a52023e96b3a700a97ffb526de17dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f76510b4.failed

Add three string sets related to timestamping information:

  ETH_SS_SOF_TIMESTAMPING: SOF_TIMESTAMPING_* flags
  ETH_SS_TS_TX_TYPES:      timestamping Tx types
  ETH_SS_TS_RX_FILTERS:    timestamping Rx filters

These will be used for TIMESTAMP_GET request.

v2: avoid compiler warning ("enumeration value not handled in switch")
    in net_hwtstamp_validate()

v3: omit dash in Tx type names ("one-step-*" -> "onestep-*"), suggested by
    Richard Cochran

	Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
	Acked-by: Richard Cochran <richardcochran@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f76510b458a52023e96b3a700a97ffb526de17dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/ethtool.h
#	include/uapi/linux/net_tstamp.h
#	net/ethtool/common.c
#	net/ethtool/common.h
#	net/ethtool/strset.c
diff --cc include/uapi/linux/ethtool.h
index 30dc4eb925a3,92f737f10117..000000000000
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@@ -598,6 -594,11 +598,14 @@@ struct ethtool_pauseparam 
   * @ETH_SS_PHY_STATS: Statistic names, for use with %ETHTOOL_GPHYSTATS
   * @ETH_SS_PHY_TUNABLES: PHY tunable names
   * @ETH_SS_LINK_MODES: link mode names
++<<<<<<< HEAD
++=======
+  * @ETH_SS_MSG_CLASSES: debug message class names
+  * @ETH_SS_WOL_MODES: wake-on-lan modes
+  * @ETH_SS_SOF_TIMESTAMPING: SOF_TIMESTAMPING_* flags
+  * @ETH_SS_TS_TX_TYPES: timestamping Tx types
+  * @ETH_SS_TS_RX_FILTERS: timestamping Rx filters
++>>>>>>> f76510b458a5 (ethtool: add timestamping related string sets)
   */
  enum ethtool_stringset {
  	ETH_SS_TEST		= 0,
@@@ -610,6 -611,14 +618,17 @@@
  	ETH_SS_PHY_STATS,
  	ETH_SS_PHY_TUNABLES,
  	ETH_SS_LINK_MODES,
++<<<<<<< HEAD
++=======
+ 	ETH_SS_MSG_CLASSES,
+ 	ETH_SS_WOL_MODES,
+ 	ETH_SS_SOF_TIMESTAMPING,
+ 	ETH_SS_TS_TX_TYPES,
+ 	ETH_SS_TS_RX_FILTERS,
+ 
+ 	/* add new constants above here */
+ 	ETH_SS_COUNT
++>>>>>>> f76510b458a5 (ethtool: add timestamping related string sets)
  };
  
  /**
diff --cc include/uapi/linux/net_tstamp.h
index e5b39721c6e4,7ed0b3d1c00a..000000000000
--- a/include/uapi/linux/net_tstamp.h
+++ b/include/uapi/linux/net_tstamp.h
@@@ -90,6 -90,17 +90,20 @@@ enum hwtstamp_tx_types 
  	 * queue.
  	 */
  	HWTSTAMP_TX_ONESTEP_SYNC,
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Same as HWTSTAMP_TX_ONESTEP_SYNC, but also enables time
+ 	 * stamp insertion directly into PDelay_Resp packets. In this
+ 	 * case, neither transmitted Sync nor PDelay_Resp packets will
+ 	 * receive a time stamp via the socket error queue.
+ 	 */
+ 	HWTSTAMP_TX_ONESTEP_P2P,
+ 
+ 	/* add new constants above here */
+ 	__HWTSTAMP_TX_CNT
++>>>>>>> f76510b458a5 (ethtool: add timestamping related string sets)
  };
  
  /* possible values for hwtstamp_config->rx_filter */
diff --cc net/ethtool/common.c
index 0a8728565356,150ff405cca4..000000000000
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@@ -167,5 -171,182 +169,184 @@@ const char link_mode_names[][ETH_GSTRIN
  	__DEFINE_LINK_MODE_NAME(400000, LR8_ER8_FR8, Full),
  	__DEFINE_LINK_MODE_NAME(400000, DR8, Full),
  	__DEFINE_LINK_MODE_NAME(400000, CR8, Full),
 -	__DEFINE_SPECIAL_MODE_NAME(FEC_LLRS, "LLRS"),
  };
  static_assert(ARRAY_SIZE(link_mode_names) == __ETHTOOL_LINK_MODE_MASK_NBITS);
++<<<<<<< HEAD
++=======
+ 
+ const char netif_msg_class_names[][ETH_GSTRING_LEN] = {
+ 	[NETIF_MSG_DRV_BIT]		= "drv",
+ 	[NETIF_MSG_PROBE_BIT]		= "probe",
+ 	[NETIF_MSG_LINK_BIT]		= "link",
+ 	[NETIF_MSG_TIMER_BIT]		= "timer",
+ 	[NETIF_MSG_IFDOWN_BIT]		= "ifdown",
+ 	[NETIF_MSG_IFUP_BIT]		= "ifup",
+ 	[NETIF_MSG_RX_ERR_BIT]		= "rx_err",
+ 	[NETIF_MSG_TX_ERR_BIT]		= "tx_err",
+ 	[NETIF_MSG_TX_QUEUED_BIT]	= "tx_queued",
+ 	[NETIF_MSG_INTR_BIT]		= "intr",
+ 	[NETIF_MSG_TX_DONE_BIT]		= "tx_done",
+ 	[NETIF_MSG_RX_STATUS_BIT]	= "rx_status",
+ 	[NETIF_MSG_PKTDATA_BIT]		= "pktdata",
+ 	[NETIF_MSG_HW_BIT]		= "hw",
+ 	[NETIF_MSG_WOL_BIT]		= "wol",
+ };
+ static_assert(ARRAY_SIZE(netif_msg_class_names) == NETIF_MSG_CLASS_COUNT);
+ 
+ const char wol_mode_names[][ETH_GSTRING_LEN] = {
+ 	[const_ilog2(WAKE_PHY)]		= "phy",
+ 	[const_ilog2(WAKE_UCAST)]	= "ucast",
+ 	[const_ilog2(WAKE_MCAST)]	= "mcast",
+ 	[const_ilog2(WAKE_BCAST)]	= "bcast",
+ 	[const_ilog2(WAKE_ARP)]		= "arp",
+ 	[const_ilog2(WAKE_MAGIC)]	= "magic",
+ 	[const_ilog2(WAKE_MAGICSECURE)]	= "magicsecure",
+ 	[const_ilog2(WAKE_FILTER)]	= "filter",
+ };
+ static_assert(ARRAY_SIZE(wol_mode_names) == WOL_MODE_COUNT);
+ 
+ const char sof_timestamping_names[][ETH_GSTRING_LEN] = {
+ 	[const_ilog2(SOF_TIMESTAMPING_TX_HARDWARE)]  = "hardware-transmit",
+ 	[const_ilog2(SOF_TIMESTAMPING_TX_SOFTWARE)]  = "software-transmit",
+ 	[const_ilog2(SOF_TIMESTAMPING_RX_HARDWARE)]  = "hardware-receive",
+ 	[const_ilog2(SOF_TIMESTAMPING_RX_SOFTWARE)]  = "software-receive",
+ 	[const_ilog2(SOF_TIMESTAMPING_SOFTWARE)]     = "software-system-clock",
+ 	[const_ilog2(SOF_TIMESTAMPING_SYS_HARDWARE)] = "hardware-legacy-clock",
+ 	[const_ilog2(SOF_TIMESTAMPING_RAW_HARDWARE)] = "hardware-raw-clock",
+ 	[const_ilog2(SOF_TIMESTAMPING_OPT_ID)]       = "option-id",
+ 	[const_ilog2(SOF_TIMESTAMPING_TX_SCHED)]     = "sched-transmit",
+ 	[const_ilog2(SOF_TIMESTAMPING_TX_ACK)]       = "ack-transmit",
+ 	[const_ilog2(SOF_TIMESTAMPING_OPT_CMSG)]     = "option-cmsg",
+ 	[const_ilog2(SOF_TIMESTAMPING_OPT_TSONLY)]   = "option-tsonly",
+ 	[const_ilog2(SOF_TIMESTAMPING_OPT_STATS)]    = "option-stats",
+ 	[const_ilog2(SOF_TIMESTAMPING_OPT_PKTINFO)]  = "option-pktinfo",
+ 	[const_ilog2(SOF_TIMESTAMPING_OPT_TX_SWHW)]  = "option-tx-swhw",
+ };
+ static_assert(ARRAY_SIZE(sof_timestamping_names) == __SOF_TIMESTAMPING_CNT);
+ 
+ const char ts_tx_type_names[][ETH_GSTRING_LEN] = {
+ 	[HWTSTAMP_TX_OFF]		= "off",
+ 	[HWTSTAMP_TX_ON]		= "on",
+ 	[HWTSTAMP_TX_ONESTEP_SYNC]	= "onestep-sync",
+ 	[HWTSTAMP_TX_ONESTEP_P2P]	= "onestep-p2p",
+ };
+ static_assert(ARRAY_SIZE(ts_tx_type_names) == __HWTSTAMP_TX_CNT);
+ 
+ const char ts_rx_filter_names[][ETH_GSTRING_LEN] = {
+ 	[HWTSTAMP_FILTER_NONE]			= "none",
+ 	[HWTSTAMP_FILTER_ALL]			= "all",
+ 	[HWTSTAMP_FILTER_SOME]			= "some",
+ 	[HWTSTAMP_FILTER_PTP_V1_L4_EVENT]	= "ptpv1-l4-event",
+ 	[HWTSTAMP_FILTER_PTP_V1_L4_SYNC]	= "ptpv1-l4-sync",
+ 	[HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ]	= "ptpv1-l4-delay-req",
+ 	[HWTSTAMP_FILTER_PTP_V2_L4_EVENT]	= "ptpv2-l4-event",
+ 	[HWTSTAMP_FILTER_PTP_V2_L4_SYNC]	= "ptpv2-l4-sync",
+ 	[HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ]	= "ptpv2-l4-delay-req",
+ 	[HWTSTAMP_FILTER_PTP_V2_L2_EVENT]	= "ptpv2-l2-event",
+ 	[HWTSTAMP_FILTER_PTP_V2_L2_SYNC]	= "ptpv2-l2-sync",
+ 	[HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ]	= "ptpv2-l2-delay-req",
+ 	[HWTSTAMP_FILTER_PTP_V2_EVENT]		= "ptpv2-event",
+ 	[HWTSTAMP_FILTER_PTP_V2_SYNC]		= "ptpv2-sync",
+ 	[HWTSTAMP_FILTER_PTP_V2_DELAY_REQ]	= "ptpv2-delay-req",
+ 	[HWTSTAMP_FILTER_NTP_ALL]		= "ntp-all",
+ };
+ static_assert(ARRAY_SIZE(ts_rx_filter_names) == __HWTSTAMP_FILTER_CNT);
+ 
+ /* return false if legacy contained non-0 deprecated fields
+  * maxtxpkt/maxrxpkt. rest of ksettings always updated
+  */
+ bool
+ convert_legacy_settings_to_link_ksettings(
+ 	struct ethtool_link_ksettings *link_ksettings,
+ 	const struct ethtool_cmd *legacy_settings)
+ {
+ 	bool retval = true;
+ 
+ 	memset(link_ksettings, 0, sizeof(*link_ksettings));
+ 
+ 	/* This is used to tell users that driver is still using these
+ 	 * deprecated legacy fields, and they should not use
+ 	 * %ETHTOOL_GLINKSETTINGS/%ETHTOOL_SLINKSETTINGS
+ 	 */
+ 	if (legacy_settings->maxtxpkt ||
+ 	    legacy_settings->maxrxpkt)
+ 		retval = false;
+ 
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.supported,
+ 		legacy_settings->supported);
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.advertising,
+ 		legacy_settings->advertising);
+ 	ethtool_convert_legacy_u32_to_link_mode(
+ 		link_ksettings->link_modes.lp_advertising,
+ 		legacy_settings->lp_advertising);
+ 	link_ksettings->base.speed
+ 		= ethtool_cmd_speed(legacy_settings);
+ 	link_ksettings->base.duplex
+ 		= legacy_settings->duplex;
+ 	link_ksettings->base.port
+ 		= legacy_settings->port;
+ 	link_ksettings->base.phy_address
+ 		= legacy_settings->phy_address;
+ 	link_ksettings->base.autoneg
+ 		= legacy_settings->autoneg;
+ 	link_ksettings->base.mdio_support
+ 		= legacy_settings->mdio_support;
+ 	link_ksettings->base.eth_tp_mdix
+ 		= legacy_settings->eth_tp_mdix;
+ 	link_ksettings->base.eth_tp_mdix_ctrl
+ 		= legacy_settings->eth_tp_mdix_ctrl;
+ 	return retval;
+ }
+ 
+ int __ethtool_get_link(struct net_device *dev)
+ {
+ 	if (!dev->ethtool_ops->get_link)
+ 		return -EOPNOTSUPP;
+ 
+ 	return netif_running(dev) && dev->ethtool_ops->get_link(dev);
+ }
+ 
+ int ethtool_get_max_rxfh_channel(struct net_device *dev, u32 *max)
+ {
+ 	u32 dev_size, current_max = 0;
+ 	u32 *indir;
+ 	int ret;
+ 
+ 	if (!dev->ethtool_ops->get_rxfh_indir_size ||
+ 	    !dev->ethtool_ops->get_rxfh)
+ 		return -EOPNOTSUPP;
+ 	dev_size = dev->ethtool_ops->get_rxfh_indir_size(dev);
+ 	if (dev_size == 0)
+ 		return -EOPNOTSUPP;
+ 
+ 	indir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);
+ 	if (!indir)
+ 		return -ENOMEM;
+ 
+ 	ret = dev->ethtool_ops->get_rxfh(dev, indir, NULL, NULL);
+ 	if (ret)
+ 		goto out;
+ 
+ 	while (dev_size--)
+ 		current_max = max(current_max, indir[dev_size]);
+ 
+ 	*max = current_max;
+ 
+ out:
+ 	kfree(indir);
+ 	return ret;
+ }
+ 
+ int ethtool_check_ops(const struct ethtool_ops *ops)
+ {
+ 	if (WARN_ON(ops->set_coalesce && !ops->supported_coalesce_params))
+ 		return -EINVAL;
+ 	/* NOTE: sufficiently insane drivers may swap ethtool_ops at runtime,
+ 	 * the fact that ops are checked at registration time does not
+ 	 * mean the ops attached to a netdev later on are sane.
+ 	 */
+ 	return 0;
+ }
++>>>>>>> f76510b458a5 (ethtool: add timestamping related string sets)
diff --cc net/ethtool/common.h
index bbb788908cb1,c54c8d57fd8f..000000000000
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@@ -18,5 -23,17 +20,20 @@@ tunable_strings[__ETHTOOL_TUNABLE_COUNT
  extern const char
  phy_tunable_strings[__ETHTOOL_PHY_TUNABLE_COUNT][ETH_GSTRING_LEN];
  extern const char link_mode_names[][ETH_GSTRING_LEN];
++<<<<<<< HEAD
++=======
+ extern const char netif_msg_class_names[][ETH_GSTRING_LEN];
+ extern const char wol_mode_names[][ETH_GSTRING_LEN];
+ extern const char sof_timestamping_names[][ETH_GSTRING_LEN];
+ extern const char ts_tx_type_names[][ETH_GSTRING_LEN];
+ extern const char ts_rx_filter_names[][ETH_GSTRING_LEN];
+ 
+ int __ethtool_get_link(struct net_device *dev);
+ 
+ bool convert_legacy_settings_to_link_ksettings(
+ 	struct ethtool_link_ksettings *link_ksettings,
+ 	const struct ethtool_cmd *legacy_settings);
+ int ethtool_get_max_rxfh_channel(struct net_device *dev, u32 *max);
++>>>>>>> f76510b458a5 (ethtool: add timestamping related string sets)
  
  #endif /* _ETHTOOL_COMMON_H */
* Unmerged path net/ethtool/strset.c
* Unmerged path include/uapi/linux/ethtool.h
* Unmerged path include/uapi/linux/net_tstamp.h
diff --git a/net/core/dev_ioctl.c b/net/core/dev_ioctl.c
index 918132a6d52a..7af0a5196909 100644
--- a/net/core/dev_ioctl.c
+++ b/net/core/dev_ioctl.c
@@ -189,6 +189,9 @@ static int net_hwtstamp_validate(struct ifreq *ifr)
 	case HWTSTAMP_TX_ONESTEP_SYNC:
 		tx_type_valid = 1;
 		break;
+	case __HWTSTAMP_TX_CNT:
+		/* not a real value */
+		break;
 	}
 
 	switch (rx_filter) {
@@ -210,6 +213,9 @@ static int net_hwtstamp_validate(struct ifreq *ifr)
 	case HWTSTAMP_FILTER_NTP_ALL:
 		rx_filter_valid = 1;
 		break;
+	case __HWTSTAMP_FILTER_CNT:
+		/* not a real value */
+		break;
 	}
 
 	if (!tx_type_valid || !rx_filter_valid)
* Unmerged path net/ethtool/common.c
* Unmerged path net/ethtool/common.h
* Unmerged path net/ethtool/strset.c
