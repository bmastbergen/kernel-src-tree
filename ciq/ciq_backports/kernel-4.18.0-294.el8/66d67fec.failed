x86/efi: Remove references to no-longer-used efi_have_uv1_memmap()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author steve.wahl@hpe.com <steve.wahl@hpe.com>
commit 66d67fecd896370d4cbbd146c9a7bf5b4c5303af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/66d67fec.failed

In removing UV1 support, efi_have_uv1_memmap is no longer used.

	Signed-off-by: Steve Wahl <steve.wahl@hpe.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Ard Biesheuvel <ardb@kernel.org>
Link: https://lkml.kernel.org/r/20200713212955.786177105@hpe.com

(cherry picked from commit 66d67fecd896370d4cbbd146c9a7bf5b4c5303af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/kexec-bzimage64.c
#	arch/x86/platform/efi/efi.c
#	arch/x86/platform/efi/efi_64.c
#	arch/x86/platform/efi/quirks.c
diff --cc arch/x86/kernel/kexec-bzimage64.c
index 192f327f3d93,57c2ecf43134..000000000000
--- a/arch/x86/kernel/kexec-bzimage64.c
+++ b/arch/x86/kernel/kexec-bzimage64.c
@@@ -173,15 -170,6 +173,18 @@@ setup_efi_state(struct boot_params *par
  	if (!current_ei->efi_memmap_size)
  		return 0;
  
++<<<<<<< HEAD
 +	/*
 +	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
 +	 * and use EFI run time services. User space will have to pass
 +	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
 +	 * without efi.
 +	 */
 +	if (efi_enabled(EFI_OLD_MEMMAP))
 +		return 0;
 +
++=======
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  	params->secure_boot = boot_params.secure_boot;
  	ei->efi_loader_signature = current_ei->efi_loader_signature;
  	ei->efi_systab = current_ei->efi_systab;
diff --cc arch/x86/platform/efi/efi.c
index 0204ffe2d898,2cc159037def..000000000000
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@@ -713,7 -648,7 +713,11 @@@ static inline void *efi_map_next_entry_
   */
  static void *efi_map_next_entry(void *entry)
  {
++<<<<<<< HEAD
 +	if (!efi_enabled(EFI_OLD_MEMMAP) && efi_enabled(EFI_64BIT)) {
++=======
+ 	if (efi_enabled(EFI_64BIT)) {
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  		/*
  		 * Starting in UEFI v2.5 the EFI_PROPERTIES_TABLE
  		 * config table feature requires us to map all entries
@@@ -841,15 -775,11 +845,21 @@@ static void __init kexec_enter_virtual_
  	efi_memory_desc_t *md;
  	unsigned int num_pages;
  
 +	efi.systab = NULL;
 +
  	/*
  	 * We don't do virtual mode, since we don't do runtime services, on
++<<<<<<< HEAD
 +	 * non-native EFI. With efi=old_map, we don't do runtime services in
 +	 * kexec kernel because in the initial boot something else might
 +	 * have been mapped at these virtual addresses.
 +	 */
 +	if (efi_is_mixed() || efi_enabled(EFI_OLD_MEMMAP)) {
++=======
+ 	 * non-native EFI.
+ 	 */
+ 	if (efi_is_mixed()) {
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  		efi_memmap_unmap();
  		clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
  		return;
@@@ -918,12 -830,6 +928,15 @@@
   * has the runtime attribute bit set in its memory descriptor into the
   * efi_pgd page table.
   *
++<<<<<<< HEAD
 + * The old method which used to update that memory descriptor with the
 + * virtual address obtained from ioremap() is still supported when the
 + * kernel is booted with efi=old_map on its command line. Same old
 + * method enabled the runtime services to be called without having to
 + * thunk back into physical mode for every invocation.
 + *
++=======
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
   * The new method does a pagetable switch in a preemption-safe manner
   * so that we're in a different address space when calling a runtime
   * function. For function arguments passing we do copy the PUDs of the
diff --cc arch/x86/platform/efi/efi_64.c
index 1616a135eea2,413583f904a6..000000000000
--- a/arch/x86/platform/efi/efi_64.c
+++ b/arch/x86/platform/efi/efi_64.c
@@@ -203,9 -74,6 +203,12 @@@ int __init efi_alloc_page_tables(void
  	pud_t *pud;
  	gfp_t gfp_mask;
  
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_OLD_MEMMAP))
 +		return 0;
 +
++=======
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  	gfp_mask = GFP_KERNEL | __GFP_ZERO;
  	efi_pgd = (pgd_t *)__get_free_pages(gfp_mask, PGD_ALLOCATION_ORDER);
  	if (!efi_pgd)
@@@ -244,9 -112,6 +247,12 @@@ void efi_sync_low_kernel_mappings(void
  	pud_t *pud_k, *pud_efi;
  	pgd_t *efi_pgd = efi_mm.pgd;
  
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_OLD_MEMMAP))
 +		return;
 +
++=======
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  	/*
  	 * We can share all PGD entries apart from the one entry that
  	 * covers the EFI runtime mapping space.
@@@ -338,9 -200,6 +344,12 @@@ int __init efi_setup_page_tables(unsign
  	unsigned npages;
  	pgd_t *pgd = efi_mm.pgd;
  
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_OLD_MEMMAP))
 +		return 0;
 +
++=======
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  	/*
  	 * It can happen that the physical address of new_memmap lands in memory
  	 * which is not mapped in the EFI page table. Therefore we need to go
@@@ -426,9 -306,6 +435,12 @@@ void __init efi_map_region(efi_memory_d
  	unsigned long size = md->num_pages << PAGE_SHIFT;
  	u64 pa = md->phys_addr;
  
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_OLD_MEMMAP))
 +		return old_map_region(md);
 +
++=======
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  	/*
  	 * Make sure the 1:1 mappings are present as a catch-all for b0rked
  	 * firmware which doesn't update all internal pointers after switching
@@@ -551,12 -408,6 +563,15 @@@ void __init efi_runtime_update_mappings
  {
  	efi_memory_desc_t *md;
  
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_OLD_MEMMAP)) {
 +		if (__supported_pte_mask & _PAGE_NX)
 +			runtime_code_page_mkexec();
 +		return;
 +	}
 +
++=======
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  	/*
  	 * Use the EFI Memory Attribute Table for mapping permissions if it
  	 * exists, since it is intended to supersede EFI_PROPERTIES_TABLE.
@@@ -605,10 -456,7 +620,14 @@@
  void __init efi_dump_pagetable(void)
  {
  #ifdef CONFIG_EFI_PGT_DUMP
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_OLD_MEMMAP))
 +		ptdump_walk_pgd_level(NULL, swapper_pg_dir);
 +	else
 +		ptdump_walk_pgd_level(NULL, efi_mm.pgd);
++=======
+ 	ptdump_walk_pgd_level(NULL, &efi_mm);
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  #endif
  }
  
@@@ -1004,24 -817,24 +1023,32 @@@ void efi_thunk_runtime_setup(void
  	efi.update_capsule = efi_thunk_update_capsule;
  	efi.query_capsule_caps = efi_thunk_query_capsule_caps;
  }
 +#endif /* CONFIG_EFI_MIXED */
  
 -efi_status_t __init __no_sanitize_address
 -efi_set_virtual_address_map(unsigned long memory_map_size,
 -			    unsigned long descriptor_size,
 -			    u32 descriptor_version,
 -			    efi_memory_desc_t *virtual_map,
 -			    unsigned long systab_phys)
 +efi_status_t __init efi_set_virtual_address_map(unsigned long memory_map_size,
 +						unsigned long descriptor_size,
 +						u32 descriptor_version,
 +						efi_memory_desc_t *virtual_map)
  {
 -	const efi_system_table_t *systab = (efi_system_table_t *)systab_phys;
  	efi_status_t status;
  	unsigned long flags;
- 	pgd_t *save_pgd = NULL;
  
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_OLD_MEMMAP)) {
 +		save_pgd = efi_old_memmap_phys_prolog();
 +		if (!save_pgd)
 +			return EFI_ABORTED;
 +	} else {
 +		efi_switch_mm(&efi_mm);
 +	}
++=======
+ 	if (efi_is_mixed())
+ 		return efi_thunk_set_virtual_address_map(memory_map_size,
+ 							 descriptor_size,
+ 							 descriptor_version,
+ 							 virtual_map);
+ 	efi_switch_mm(&efi_mm);
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  
  	kernel_fpu_begin();
  
@@@ -1034,10 -847,10 +1061,17 @@@
  
  	kernel_fpu_end();
  
++<<<<<<< HEAD
 +	if (save_pgd)
 +		efi_old_memmap_phys_epilog(save_pgd);
 +	else
 +		efi_switch_mm(efi_scratch.prev_mm);
++=======
+ 	/* grab the virtually remapped EFI runtime services table pointer */
+ 	efi.runtime = READ_ONCE(systab->runtime);
+ 
+ 	efi_switch_mm(efi_scratch.prev_mm);
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  
  	return status;
  }
diff --cc arch/x86/platform/efi/quirks.c
index 4ccb57c20f71,5a40fe411ebd..000000000000
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@@ -378,14 -381,6 +378,17 @@@ static void __init efi_unmap_pages(efi_
  	u64 va = md->virt_addr;
  
  	/*
++<<<<<<< HEAD
 +	 * To Do: Remove this check after adding functionality to unmap EFI boot
 +	 * services code/data regions from direct mapping area because
 +	 * "efi=old_map" maps EFI regions in swapper_pg_dir.
 +	 */
 +	if (efi_enabled(EFI_OLD_MEMMAP))
 +		return;
 +
 +	/*
++=======
++>>>>>>> 66d67fecd896 (x86/efi: Remove references to no-longer-used efi_have_uv1_memmap())
  	 * EFI mixed mode has all RAM mapped to access arguments while making
  	 * EFI runtime calls, hence don't unmap EFI boot services code/data
  	 * regions.
* Unmerged path arch/x86/kernel/kexec-bzimage64.c
* Unmerged path arch/x86/platform/efi/efi.c
* Unmerged path arch/x86/platform/efi/efi_64.c
* Unmerged path arch/x86/platform/efi/quirks.c
