x86/hyperv: Make hv_setup_sched_clock inline

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] hyperv: Make hv_setup_sched_clock inline (Mohammed Gamal) [1886099]
Rebuild_FUZZ: 95.24%
commit-author Michael Kelley <mikelley@microsoft.com>
commit b9d8cf2eb3ceecdee3434b87763492aee9e28845
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b9d8cf2e.failed

Make hv_setup_sched_clock inline so the reference to pv_ops works
correctly with objtool updates to detect noinstr violations.
See https://lore.kernel.org/patchwork/patch/1283635/

	Signed-off-by: Michael Kelley <mikelley@microsoft.com>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/1597022991-24088-1-git-send-email-mikelley@microsoft.com
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
(cherry picked from commit b9d8cf2eb3ceecdee3434b87763492aee9e28845)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
#	arch/x86/kernel/cpu/mshyperv.c
diff --cc arch/x86/include/asm/mshyperv.h
index d893b0b8985e,4f77b8f22e54..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -49,23 -50,24 +50,37 @@@ typedef int (*hyperv_fill_flush_list_fu
  #define hv_set_reference_tsc(val) \
  	wrmsrl(HV_X64_MSR_REFERENCE_TSC, val)
  #define hv_set_clocksource_vdso(val) \
 -	((val).vdso_clock_mode = VDSO_CLOCKMODE_HVCLOCK)
 -#define hv_enable_vdso_clocksource() \
 -	vclocks_set_used(VDSO_CLOCKMODE_HVCLOCK);
 +	((val).archdata.vclock_mode = VCLOCK_HVCLOCK)
  #define hv_get_raw_timer() rdtsc_ordered()
  
++<<<<<<< HEAD
 +void hyperv_callback_vector(void);
 +void hyperv_reenlightenment_vector(void);
 +#ifdef CONFIG_TRACING
 +#define trace_hyperv_callback_vector hyperv_callback_vector
 +#endif
++=======
+ /*
+  * Reference to pv_ops must be inline so objtool
+  * detection of noinstr violations can work correctly.
+  */
+ static __always_inline void hv_setup_sched_clock(void *sched_clock)
+ {
+ #ifdef CONFIG_PARAVIRT
+ 	pv_ops.time.sched_clock = sched_clock;
+ #endif
+ }
+ 
++>>>>>>> b9d8cf2eb3ce (x86/hyperv: Make hv_setup_sched_clock inline)
  void hyperv_vector_handler(struct pt_regs *regs);
  
 +/*
 + * Routines for stimer0 Direct Mode handling.
 + * On x86/x64, there are no percpu actions to take.
 + */
 +void hv_stimer0_vector_handler(struct pt_regs *regs);
 +void hv_stimer0_callback_vector(void);
 +
  static inline void hv_enable_stimer0_percpu_irq(int irq) {}
  static inline void hv_disable_stimer0_percpu_irq(int irq) {}
  
diff --cc arch/x86/kernel/cpu/mshyperv.c
index 9f0ce6d7f717,31125448b174..000000000000
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@@ -367,13 -361,6 +367,16 @@@ static void __init ms_hyperv_init_platf
  #endif
  }
  
++<<<<<<< HEAD
 +void hv_setup_sched_clock(void *sched_clock)
 +{
 +#ifdef CONFIG_PARAVIRT
 +	pv_time_ops.sched_clock = sched_clock;
 +#endif
 +}
 +
++=======
++>>>>>>> b9d8cf2eb3ce (x86/hyperv: Make hv_setup_sched_clock inline)
  const __initconst struct hypervisor_x86 x86_hyper_ms_hyperv = {
  	.name			= "Microsoft Hyper-V",
  	.detect			= ms_hyperv_platform,
* Unmerged path arch/x86/include/asm/mshyperv.h
* Unmerged path arch/x86/kernel/cpu/mshyperv.c
diff --git a/include/asm-generic/mshyperv.h b/include/asm-generic/mshyperv.h
index 1c4fd950f091..c5edc5e08b94 100644
--- a/include/asm-generic/mshyperv.h
+++ b/include/asm-generic/mshyperv.h
@@ -168,7 +168,6 @@ void hyperv_report_panic_msg(phys_addr_t pa, size_t size);
 bool hv_is_hyperv_initialized(void);
 bool hv_is_hibernation_supported(void);
 void hyperv_cleanup(void);
-void hv_setup_sched_clock(void *sched_clock);
 #else /* CONFIG_HYPERV */
 static inline bool hv_is_hyperv_initialized(void) { return false; }
 static inline bool hv_is_hibernation_supported(void) { return false; }
