net: stmmac: gmac5+: Add support for Frame Preemption

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jose Abreu <Jose.Abreu@synopsys.com>
commit 7c7282746883e48aff54ff6d55e6d8674a0c414a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7c728274.failed

Adds the HW specific support for Frame Preemption on GMAC5+ cores.

	Signed-off-by: Jose Abreu <Jose.Abreu@synopsys.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7c7282746883e48aff54ff6d55e6d8674a0c414a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/dwmac4.h
#	drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac5.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac5.h
diff --cc drivers/net/ethernet/stmicro/stmmac/dwmac4.h
index 20baf870a602,2e6b60a476c6..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4.h
@@@ -234,6 -239,10 +236,13 @@@ enum power_event 
  
  /* MAC HW features3 bitmap */
  #define GMAC_HW_FEAT_ASP		GENMASK(29, 28)
++<<<<<<< HEAD
++=======
+ #define GMAC_HW_FEAT_FPESEL		BIT(26)
+ #define GMAC_HW_FEAT_ESTWID		GENMASK(21, 20)
+ #define GMAC_HW_FEAT_ESTDEP		GENMASK(19, 17)
+ #define GMAC_HW_FEAT_ESTSEL		BIT(16)
++>>>>>>> 7c7282746883 (net: stmmac: gmac5+: Add support for Frame Preemption)
  #define GMAC_HW_FEAT_FRPES		GENMASK(14, 13)
  #define GMAC_HW_FEAT_FRPBS		GENMASK(12, 11)
  #define GMAC_HW_FEAT_FRPSEL		BIT(10)
diff --cc drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
index c8fe5531d429,f0c0ea616032..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
@@@ -987,6 -984,8 +987,11 @@@ const struct stmmac_ops dwmac410_ops = 
  	.set_arp_offload = dwmac4_set_arp_offload,
  	.config_l3_filter = dwmac4_config_l3_filter,
  	.config_l4_filter = dwmac4_config_l4_filter,
++<<<<<<< HEAD
++=======
+ 	.est_configure = dwmac5_est_configure,
+ 	.fpe_configure = dwmac5_fpe_configure,
++>>>>>>> 7c7282746883 (net: stmmac: gmac5+: Add support for Frame Preemption)
  };
  
  const struct stmmac_ops dwmac510_ops = {
@@@ -1030,6 -1029,8 +1035,11 @@@
  	.set_arp_offload = dwmac4_set_arp_offload,
  	.config_l3_filter = dwmac4_config_l3_filter,
  	.config_l4_filter = dwmac4_config_l4_filter,
++<<<<<<< HEAD
++=======
+ 	.est_configure = dwmac5_est_configure,
+ 	.fpe_configure = dwmac5_fpe_configure,
++>>>>>>> 7c7282746883 (net: stmmac: gmac5+: Add support for Frame Preemption)
  };
  
  int dwmac4_setup(struct stmmac_priv *priv)
diff --cc drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
index ae7c7b1a958e,213d44482ffa..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
@@@ -407,6 -404,10 +407,13 @@@ static void dwmac4_get_hw_feature(void 
  
  	/* 5.10 Features */
  	dma_cap->asp = (hw_cap & GMAC_HW_FEAT_ASP) >> 28;
++<<<<<<< HEAD
++=======
+ 	dma_cap->fpesel = (hw_cap & GMAC_HW_FEAT_FPESEL) >> 26;
+ 	dma_cap->estwid = (hw_cap & GMAC_HW_FEAT_ESTWID) >> 20;
+ 	dma_cap->estdep = (hw_cap & GMAC_HW_FEAT_ESTDEP) >> 17;
+ 	dma_cap->estsel = (hw_cap & GMAC_HW_FEAT_ESTSEL) >> 16;
++>>>>>>> 7c7282746883 (net: stmmac: gmac5+: Add support for Frame Preemption)
  	dma_cap->frpes = (hw_cap & GMAC_HW_FEAT_FRPES) >> 13;
  	dma_cap->frpbs = (hw_cap & GMAC_HW_FEAT_FRPBS) >> 11;
  	dma_cap->frpsel = (hw_cap & GMAC_HW_FEAT_FRPSEL) >> 10;
diff --cc drivers/net/ethernet/stmicro/stmmac/dwmac5.c
index e436fa160c7d,5d4a3c2458ea..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac5.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac5.c
@@@ -550,3 -550,121 +550,124 @@@ int dwmac5_flex_pps_config(void __iome
  	writel(val, ioaddr + MAC_PPS_CONTROL);
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int dwmac5_est_write(void __iomem *ioaddr, u32 reg, u32 val, bool gcl)
+ {
+ 	u32 ctrl;
+ 
+ 	writel(val, ioaddr + MTL_EST_GCL_DATA);
+ 
+ 	ctrl = (reg << ADDR_SHIFT);
+ 	ctrl |= gcl ? 0 : GCRR;
+ 
+ 	writel(ctrl, ioaddr + MTL_EST_GCL_CONTROL);
+ 
+ 	ctrl |= SRWO;
+ 	writel(ctrl, ioaddr + MTL_EST_GCL_CONTROL);
+ 
+ 	return readl_poll_timeout(ioaddr + MTL_EST_GCL_CONTROL,
+ 				  ctrl, !(ctrl & SRWO), 100, 5000);
+ }
+ 
+ int dwmac5_est_configure(void __iomem *ioaddr, struct stmmac_est *cfg,
+ 			 unsigned int ptp_rate)
+ {
+ 	u32 speed, total_offset, offset, ctrl, ctr_low;
+ 	u32 extcfg = readl(ioaddr + GMAC_EXT_CONFIG);
+ 	u32 mac_cfg = readl(ioaddr + GMAC_CONFIG);
+ 	int i, ret = 0x0;
+ 	u64 total_ctr;
+ 
+ 	if (extcfg & GMAC_CONFIG_EIPG_EN) {
+ 		offset = (extcfg & GMAC_CONFIG_EIPG) >> GMAC_CONFIG_EIPG_SHIFT;
+ 		offset = 104 + (offset * 8);
+ 	} else {
+ 		offset = (mac_cfg & GMAC_CONFIG_IPG) >> GMAC_CONFIG_IPG_SHIFT;
+ 		offset = 96 - (offset * 8);
+ 	}
+ 
+ 	speed = mac_cfg & (GMAC_CONFIG_PS | GMAC_CONFIG_FES);
+ 	speed = speed >> GMAC_CONFIG_FES_SHIFT;
+ 
+ 	switch (speed) {
+ 	case 0x0:
+ 		offset = offset * 1000; /* 1G */
+ 		break;
+ 	case 0x1:
+ 		offset = offset * 400; /* 2.5G */
+ 		break;
+ 	case 0x2:
+ 		offset = offset * 100000; /* 10M */
+ 		break;
+ 	case 0x3:
+ 		offset = offset * 10000; /* 100M */
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	offset = offset / 1000;
+ 
+ 	ret |= dwmac5_est_write(ioaddr, BTR_LOW, cfg->btr[0], false);
+ 	ret |= dwmac5_est_write(ioaddr, BTR_HIGH, cfg->btr[1], false);
+ 	ret |= dwmac5_est_write(ioaddr, TER, cfg->ter, false);
+ 	ret |= dwmac5_est_write(ioaddr, LLR, cfg->gcl_size, false);
+ 	if (ret)
+ 		return ret;
+ 
+ 	total_offset = 0;
+ 	for (i = 0; i < cfg->gcl_size; i++) {
+ 		ret = dwmac5_est_write(ioaddr, i, cfg->gcl[i] + offset, true);
+ 		if (ret)
+ 			return ret;
+ 
+ 		total_offset += offset;
+ 	}
+ 
+ 	total_ctr = cfg->ctr[0] + cfg->ctr[1] * 1000000000;
+ 	total_ctr += total_offset;
+ 
+ 	ctr_low = do_div(total_ctr, 1000000000);
+ 
+ 	ret |= dwmac5_est_write(ioaddr, CTR_LOW, ctr_low, false);
+ 	ret |= dwmac5_est_write(ioaddr, CTR_HIGH, total_ctr, false);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ctrl = readl(ioaddr + MTL_EST_CONTROL);
+ 	ctrl &= ~PTOV;
+ 	ctrl |= ((1000000000 / ptp_rate) * 6) << PTOV_SHIFT;
+ 	if (cfg->enable)
+ 		ctrl |= EEST | SSWL;
+ 	else
+ 		ctrl &= ~EEST;
+ 
+ 	writel(ctrl, ioaddr + MTL_EST_CONTROL);
+ 	return 0;
+ }
+ 
+ void dwmac5_fpe_configure(void __iomem *ioaddr, u32 num_txq, u32 num_rxq,
+ 			  bool enable)
+ {
+ 	u32 value;
+ 
+ 	if (!enable) {
+ 		value = readl(ioaddr + MAC_FPE_CTRL_STS);
+ 
+ 		value &= ~EFPE;
+ 
+ 		writel(value, ioaddr + MAC_FPE_CTRL_STS);
+ 	}
+ 
+ 	value = readl(ioaddr + GMAC_RXQ_CTRL1);
+ 	value &= ~GMAC_RXQCTRL_FPRQ;
+ 	value |= (num_rxq - 1) << GMAC_RXQCTRL_FPRQ_SHIFT;
+ 	writel(value, ioaddr + GMAC_RXQ_CTRL1);
+ 
+ 	value = readl(ioaddr + MAC_FPE_CTRL_STS);
+ 	value |= EFPE;
+ 	writel(value, ioaddr + MAC_FPE_CTRL_STS);
+ }
++>>>>>>> 7c7282746883 (net: stmmac: gmac5+: Add support for Frame Preemption)
diff --cc drivers/net/ethernet/stmicro/stmmac/dwmac5.h
index 775db776b3cc,3e8faa96b4d4..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac5.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac5.h
@@@ -83,5 -103,9 +86,12 @@@ int dwmac5_rxp_config(void __iomem *ioa
  int dwmac5_flex_pps_config(void __iomem *ioaddr, int index,
  			   struct stmmac_pps_cfg *cfg, bool enable,
  			   u32 sub_second_inc, u32 systime_flags);
++<<<<<<< HEAD
++=======
+ int dwmac5_est_configure(void __iomem *ioaddr, struct stmmac_est *cfg,
+ 			 unsigned int ptp_rate);
+ void dwmac5_fpe_configure(void __iomem *ioaddr, u32 num_txq, u32 num_rxq,
+ 			  bool enable);
++>>>>>>> 7c7282746883 (net: stmmac: gmac5+: Add support for Frame Preemption)
  
  #endif /* __DWMAC5_H__ */
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac4.h
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac5.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac5.h
