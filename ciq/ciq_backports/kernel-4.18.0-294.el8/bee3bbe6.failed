driver core: Clarify documentation for fwnode_operations.add_links()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit bee3bbe616a2c8de641a64d874f9206835bd4401
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/bee3bbe6.failed

The wording was a bit ambiguous. So update it to make it clear.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Link: https://lore.kernel.org/r/20191113023559.62295-2-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit bee3bbe616a2c8de641a64d874f9206835bd4401)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fwnode.h
diff --cc include/linux/fwnode.h
index da6c12ac38c1,23df37f85398..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -71,6 -66,44 +71,47 @@@ struct fwnode_reference_args 
   *			       endpoint node.
   * @graph_get_port_parent: Return the parent node of a port node.
   * @graph_parse_endpoint: Parse endpoint for port and endpoint id.
++<<<<<<< HEAD
++=======
+  * @add_links:	Called after the device corresponding to the fwnode is added
+  *		using device_add(). The function is expected to create device
+  *		links to all the suppliers of the device that are available at
+  *		the time this function is called.  The function must NOT stop
+  *		at the first failed device link if other unlinked supplier
+  *		devices are present in the system.  This is necessary for the
+  *		driver/bus sync_state() callbacks to work correctly.
+  *
+  *		For example, say Device-C depends on suppliers Device-S1 and
+  *		Device-S2 and the dependency is listed in that order in the
+  *		firmware.  Say, S1 gets populated from the firmware after
+  *		late_initcall_sync().  Say S2 is populated and probed way
+  *		before that in device_initcall(). When C is populated, if this
+  *		add_links() function doesn't continue past a "failed linking to
+  *		S1" and continue linking C to S2, then S2 will get a
+  *		sync_state() callback before C is probed. This is because from
+  *		the perspective of S2, C was never a consumer when its
+  *		sync_state() evaluation is done. To avoid this, the add_links()
+  *		function has to go through all available suppliers of the
+  *		device (that corresponds to this fwnode) and link to them
+  *		before returning.
+  *
+  *		If some suppliers are not yet available (indicated by an error
+  *		return value), this function will be called again when other
+  *		devices are added to allow creating device links to any newly
+  *		available suppliers.
+  *
+  *		Return 0 if device links have been successfully created to all
+  *		the known suppliers of this device or if the supplier
+  *		information is not known.
+  *
+  *		Return -ENODEV if the suppliers needed for probing this device
+  *		have not been registered yet (because device links can only be
+  *		created to devices registered with the driver core).
+  *
+  *		Return -EAGAIN if some of the suppliers of this device have not
+  *		been registered yet, but none of those suppliers are necessary
+  *		for probing the device.
++>>>>>>> bee3bbe616a2 (driver core: Clarify documentation for fwnode_operations.add_links())
   */
  struct fwnode_operations {
  	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
* Unmerged path include/linux/fwnode.h
