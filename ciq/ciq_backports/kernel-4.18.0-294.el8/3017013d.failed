nvme-rdma: avoid race between time out and tear down

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chao Leng <lengchao@huawei.com>
commit 3017013dcc82a4862bd1e140f8b762cfc594008d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3017013d.failed

Now use teardown_lock to serialize for time out and tear down. This may
cause abnormal: first cancel all request in tear down, then time out may
complete the request again, but the request may already be freed or
restarted.

To avoid race between time out and tear down, in tear down process,
first we quiesce the queue, and then delete the timer and cancel
the time out work for the queue. At the same time we need to delete
teardown_lock.

	Signed-off-by: Chao Leng <lengchao@huawei.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 3017013dcc82a4862bd1e140f8b762cfc594008d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/rdma.c
diff --cc drivers/nvme/host/rdma.c
index b3e2b13b46fe,83dbf2223125..000000000000
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@@ -1969,6 -1969,18 +1966,21 @@@ static int nvme_rdma_cm_handler(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void nvme_rdma_complete_timed_out(struct request *rq)
+ {
+ 	struct nvme_rdma_request *req = blk_mq_rq_to_pdu(rq);
+ 	struct nvme_rdma_queue *queue = req->queue;
+ 
+ 	nvme_rdma_stop_queue(queue);
+ 	if (!blk_mq_request_completed(rq)) {
+ 		nvme_req(rq)->status = NVME_SC_HOST_ABORTED_CMD;
+ 		blk_mq_complete_request(rq);
+ 	}
+ }
+ 
++>>>>>>> 3017013dcc82 (nvme-rdma: avoid race between time out and tear down)
  static enum blk_eh_timer_return
  nvme_rdma_timeout(struct request *rq, bool reserved)
  {
* Unmerged path drivers/nvme/host/rdma.c
