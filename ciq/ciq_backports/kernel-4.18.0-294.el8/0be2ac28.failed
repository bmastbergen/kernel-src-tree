mptcp: add the mibs for MP_PRIO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 0be2ac287bcc8a5b60d7c9ab11892a774052d269
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0be2ac28.failed

This patch added the mibs for MP_PRIO, MPTCP_MIB_MPPRIOTX for transmitting
of the MP_PRIO suboption, and MPTCP_MIB_MPPRIORX for receiving of it.

	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0be2ac287bcc8a5b60d7c9ab11892a774052d269)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/mib.c
#	net/mptcp/mib.h
#	net/mptcp/options.c
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/mib.c
index a1094ba97d74,8ca196489893..000000000000
--- a/net/mptcp/mib.c
+++ b/net/mptcp/mib.c
@@@ -22,6 -22,17 +22,20 @@@ static const struct snmp_mib mptcp_snmp
  	SNMP_MIB_ITEM("MPJoinAckHMacFailure", MPTCP_MIB_JOINACKMAC),
  	SNMP_MIB_ITEM("DSSNotMatching", MPTCP_MIB_DSSNOMATCH),
  	SNMP_MIB_ITEM("InfiniteMapRx", MPTCP_MIB_INFINITEMAPRX),
++<<<<<<< HEAD
++=======
+ 	SNMP_MIB_ITEM("OFOQueueTail", MPTCP_MIB_OFOQUEUETAIL),
+ 	SNMP_MIB_ITEM("OFOQueue", MPTCP_MIB_OFOQUEUE),
+ 	SNMP_MIB_ITEM("OFOMerge", MPTCP_MIB_OFOMERGE),
+ 	SNMP_MIB_ITEM("NoDSSInWindow", MPTCP_MIB_NODSSWINDOW),
+ 	SNMP_MIB_ITEM("DuplicateData", MPTCP_MIB_DUPDATA),
+ 	SNMP_MIB_ITEM("AddAddr", MPTCP_MIB_ADDADDR),
+ 	SNMP_MIB_ITEM("EchoAdd", MPTCP_MIB_ECHOADD),
+ 	SNMP_MIB_ITEM("RmAddr", MPTCP_MIB_RMADDR),
+ 	SNMP_MIB_ITEM("RmSubflow", MPTCP_MIB_RMSUBFLOW),
+ 	SNMP_MIB_ITEM("MPPrioTx", MPTCP_MIB_MPPRIOTX),
+ 	SNMP_MIB_ITEM("MPPrioRx", MPTCP_MIB_MPPRIORX),
++>>>>>>> 0be2ac287bcc (mptcp: add the mibs for MP_PRIO)
  	SNMP_MIB_SENTINEL
  };
  
diff --cc net/mptcp/mib.h
index 5579e7107989,63914a5ef6a5..000000000000
--- a/net/mptcp/mib.h
+++ b/net/mptcp/mib.h
@@@ -15,6 -15,17 +15,20 @@@ enum linux_mptcp_mib_field 
  	MPTCP_MIB_JOINACKMAC,		/* HMAC was wrong on ACK + MP_JOIN */
  	MPTCP_MIB_DSSNOMATCH,		/* Received a new mapping that did not match the previous one */
  	MPTCP_MIB_INFINITEMAPRX,	/* Received an infinite mapping */
++<<<<<<< HEAD
++=======
+ 	MPTCP_MIB_OFOQUEUETAIL,	/* Segments inserted into OoO queue tail */
+ 	MPTCP_MIB_OFOQUEUE,		/* Segments inserted into OoO queue */
+ 	MPTCP_MIB_OFOMERGE,		/* Segments merged in OoO queue */
+ 	MPTCP_MIB_NODSSWINDOW,		/* Segments not in MPTCP windows */
+ 	MPTCP_MIB_DUPDATA,		/* Segments discarded due to duplicate DSS */
+ 	MPTCP_MIB_ADDADDR,		/* Received ADD_ADDR with echo-flag=0 */
+ 	MPTCP_MIB_ECHOADD,		/* Received ADD_ADDR with echo-flag=1 */
+ 	MPTCP_MIB_RMADDR,		/* Received RM_ADDR */
+ 	MPTCP_MIB_RMSUBFLOW,		/* Remove a subflow */
+ 	MPTCP_MIB_MPPRIOTX,		/* Transmit a MP_PRIO */
+ 	MPTCP_MIB_MPPRIORX,		/* Received a MP_PRIO */
++>>>>>>> 0be2ac287bcc (mptcp: add the mibs for MP_PRIO)
  	__MPTCP_MIB_MAX
  };
  
diff --cc net/mptcp/options.c
index af3f2e566740,c9643344a8d7..000000000000
--- a/net/mptcp/options.c
+++ b/net/mptcp/options.c
@@@ -860,6 -1022,22 +860,20 @@@ void mptcp_incoming_options(struct soc
  		mp_opt.add_addr = 0;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (mp_opt.rm_addr) {
+ 		mptcp_pm_rm_addr_received(msk, mp_opt.rm_id);
+ 		mp_opt.rm_addr = 0;
+ 	}
+ 
+ 	if (mp_opt.mp_prio) {
+ 		mptcp_pm_mp_prio_received(sk, mp_opt.backup);
+ 		MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPPRIORX);
+ 		mp_opt.mp_prio = 0;
+ 	}
+ 
++>>>>>>> 0be2ac287bcc (mptcp: add the mibs for MP_PRIO)
  	if (!mp_opt.dss)
  		return;
  
diff --cc net/mptcp/pm_netlink.c
index a69958fdfc35,9b1f6298bbdb..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -265,8 -401,149 +265,152 @@@ void mptcp_pm_nl_add_addr_received(stru
  	local.family = remote.family;
  
  	spin_unlock_bh(&msk->pm.lock);
 -	__mptcp_subflow_connect(sk, &local, &remote);
 +	__mptcp_subflow_connect((struct sock *)msk, 0, &local, &remote);
  	spin_lock_bh(&msk->pm.lock);
++<<<<<<< HEAD
++=======
+ 
+ 	mptcp_pm_announce_addr(msk, &remote, true, use_port);
+ 	mptcp_pm_nl_add_addr_send_ack(msk);
+ }
+ 
+ void mptcp_pm_nl_add_addr_send_ack(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow;
+ 
+ 	if (!mptcp_pm_should_add_signal_ipv6(msk) &&
+ 	    !mptcp_pm_should_add_signal_port(msk))
+ 		return;
+ 
+ 	__mptcp_flush_join_list(msk);
+ 	subflow = list_first_entry_or_null(&msk->conn_list, typeof(*subflow), node);
+ 	if (subflow) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		u8 add_addr;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		if (mptcp_pm_should_add_signal_ipv6(msk))
+ 			pr_debug("send ack for add_addr6");
+ 		if (mptcp_pm_should_add_signal_port(msk))
+ 			pr_debug("send ack for add_addr_port");
+ 
+ 		lock_sock(ssk);
+ 		tcp_send_ack(ssk);
+ 		release_sock(ssk);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		add_addr = READ_ONCE(msk->pm.addr_signal);
+ 		if (mptcp_pm_should_add_signal_ipv6(msk))
+ 			add_addr &= ~BIT(MPTCP_ADD_ADDR_IPV6);
+ 		if (mptcp_pm_should_add_signal_port(msk))
+ 			add_addr &= ~BIT(MPTCP_ADD_ADDR_PORT);
+ 		WRITE_ONCE(msk->pm.addr_signal, add_addr);
+ 	}
+ }
+ 
+ int mptcp_pm_nl_mp_prio_send_ack(struct mptcp_sock *msk,
+ 				 struct mptcp_addr_info *addr,
+ 				 u8 bkup)
+ {
+ 	struct mptcp_subflow_context *subflow;
+ 
+ 	pr_debug("bkup=%d", bkup);
+ 
+ 	mptcp_for_each_subflow(msk, subflow) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		struct sock *sk = (struct sock *)msk;
+ 		struct mptcp_addr_info local;
+ 
+ 		local_address((struct sock_common *)ssk, &local);
+ 		if (!addresses_equal(&local, addr, addr->port))
+ 			continue;
+ 
+ 		subflow->backup = bkup;
+ 		subflow->send_mp_prio = 1;
+ 		subflow->request_bkup = bkup;
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPPRIOTX);
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		pr_debug("send ack for mp_prio");
+ 		lock_sock(ssk);
+ 		tcp_send_ack(ssk);
+ 		release_sock(ssk);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ void mptcp_pm_nl_rm_addr_received(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("address rm_id %d", msk->pm.rm_id);
+ 
+ 	if (!msk->pm.rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 
+ 		if (msk->pm.rm_id != subflow->remote_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.add_addr_accepted--;
+ 		msk->pm.subflows--;
+ 		WRITE_ONCE(msk->pm.accept_addr, true);
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMADDR);
+ 
+ 		break;
+ 	}
+ }
+ 
+ void mptcp_pm_nl_rm_subflow_received(struct mptcp_sock *msk, u8 rm_id)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("subflow rm_id %d", rm_id);
+ 
+ 	if (!rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 
+ 		if (rm_id != subflow->local_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.local_addr_used--;
+ 		msk->pm.subflows--;
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMSUBFLOW);
+ 
+ 		break;
+ 	}
++>>>>>>> 0be2ac287bcc (mptcp: add the mibs for MP_PRIO)
  }
  
  static bool address_use_port(struct mptcp_pm_addr_entry *entry)
* Unmerged path net/mptcp/mib.c
* Unmerged path net/mptcp/mib.h
* Unmerged path net/mptcp/options.c
* Unmerged path net/mptcp/pm_netlink.c
