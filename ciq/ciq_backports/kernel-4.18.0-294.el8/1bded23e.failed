KVM: arm64: Move SP_EL1 to the system register array

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Marc Zyngier <maz@kernel.org>
commit 1bded23ea71cee2053fe1dd55c5d36d35bec56aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1bded23e.failed

SP_EL1 being a VNCR-capable register with ARMv8.4-NV, move it to the
system register array and update the accessors.

	Reviewed-by: James Morse <james.morse@arm.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
(cherry picked from commit 1bded23ea71cee2053fe1dd55c5d36d35bec56aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kvm_host.h
#	arch/arm64/kvm/guest.c
#	arch/arm64/kvm/hyp/include/hyp/sysreg-sr.h
diff --cc arch/arm64/include/asm/kvm_host.h
index d8c4d368d7b0,2bd6285eaf4c..000000000000
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@@ -181,6 -185,9 +181,12 @@@ enum vcpu_sysreg 
  	APGAKEYLO_EL1,
  	APGAKEYHI_EL1,
  
++<<<<<<< HEAD
++=======
+ 	ELR_EL1,
+ 	SP_EL1,
+ 
++>>>>>>> 1bded23ea71c (KVM: arm64: Move SP_EL1 to the system register array)
  	/* 32bit specific registers. Keep them at the end of the range */
  	DACR32_EL2,	/* Domain Access Control Register */
  	IFSR32_EL2,	/* Instruction Fault Status Register */
@@@ -232,7 -239,12 +238,16 @@@
  #define NR_COPRO_REGS	(NR_SYS_REGS * 2)
  
  struct kvm_cpu_context {
++<<<<<<< HEAD
 +	struct kvm_regs	gp_regs;
++=======
+ 	struct user_pt_regs regs;	/* sp = sp_el0 */
+ 
+ 	u64	spsr[KVM_NR_SPSR];
+ 
+ 	struct user_fpsimd_state fp_regs;
+ 
++>>>>>>> 1bded23ea71c (KVM: arm64: Move SP_EL1 to the system register array)
  	union {
  		u64 sys_regs[NR_SYS_REGS];
  		u32 copro[NR_COPRO_REGS];
diff --cc arch/arm64/kvm/guest.c
index a0778b6214ad,d614716e073b..000000000000
--- a/arch/arm64/kvm/guest.c
+++ b/arch/arm64/kvm/guest.c
@@@ -117,12 -107,54 +117,58 @@@ static int validate_core_offset(const s
  	int size = core_reg_size_from_offset(vcpu, off);
  
  	if (size < 0)
 -		return NULL;
 +		return -EINVAL;
  
  	if (KVM_REG_SIZE(reg->id) != size)
 -		return NULL;
 +		return -EINVAL;
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	switch (off) {
+ 	case KVM_REG_ARM_CORE_REG(regs.regs[0]) ...
+ 	     KVM_REG_ARM_CORE_REG(regs.regs[30]):
+ 		off -= KVM_REG_ARM_CORE_REG(regs.regs[0]);
+ 		off /= 2;
+ 		return &vcpu->arch.ctxt.regs.regs[off];
+ 
+ 	case KVM_REG_ARM_CORE_REG(regs.sp):
+ 		return &vcpu->arch.ctxt.regs.sp;
+ 
+ 	case KVM_REG_ARM_CORE_REG(regs.pc):
+ 		return &vcpu->arch.ctxt.regs.pc;
+ 
+ 	case KVM_REG_ARM_CORE_REG(regs.pstate):
+ 		return &vcpu->arch.ctxt.regs.pstate;
+ 
+ 	case KVM_REG_ARM_CORE_REG(sp_el1):
+ 		return __ctxt_sys_reg(&vcpu->arch.ctxt, SP_EL1);
+ 
+ 	case KVM_REG_ARM_CORE_REG(elr_el1):
+ 		return __ctxt_sys_reg(&vcpu->arch.ctxt, ELR_EL1);
+ 
+ 	case KVM_REG_ARM_CORE_REG(spsr[0]) ...
+ 	     KVM_REG_ARM_CORE_REG(spsr[KVM_NR_SPSR - 1]):
+ 		off -= KVM_REG_ARM_CORE_REG(spsr[0]);
+ 		off /= 2;
+ 		return &vcpu->arch.ctxt.spsr[off];
+ 
+ 	case KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]) ...
+ 	     KVM_REG_ARM_CORE_REG(fp_regs.vregs[31]):
+ 		off -= KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]);
+ 		off /= 4;
+ 		return &vcpu->arch.ctxt.fp_regs.vregs[off];
+ 
+ 	case KVM_REG_ARM_CORE_REG(fp_regs.fpsr):
+ 		return &vcpu->arch.ctxt.fp_regs.fpsr;
+ 
+ 	case KVM_REG_ARM_CORE_REG(fp_regs.fpcr):
+ 		return &vcpu->arch.ctxt.fp_regs.fpcr;
+ 
+ 	default:
+ 		return NULL;
+ 	}
++>>>>>>> 1bded23ea71c (KVM: arm64: Move SP_EL1 to the system register array)
  }
  
  static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
* Unmerged path arch/arm64/kvm/hyp/include/hyp/sysreg-sr.h
* Unmerged path arch/arm64/include/asm/kvm_host.h
* Unmerged path arch/arm64/kvm/guest.c
* Unmerged path arch/arm64/kvm/hyp/include/hyp/sysreg-sr.h
