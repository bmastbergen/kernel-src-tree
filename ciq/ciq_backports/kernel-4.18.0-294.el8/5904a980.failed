net: stmmac: xgmac: Implement ARP Offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jose Abreu <Jose.Abreu@synopsys.com>
commit 5904a980f93c6bba44055dd4e7c6cb6cbb8b2a48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5904a980.failed

Implement the ARP Offload feature in XGMAC cores.

	Signed-off-by: Jose Abreu <joabreu@synopsys.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5904a980f93c6bba44055dd4e7c6cb6cbb8b2a48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/common.h
#	drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
#	drivers/net/ethernet/stmicro/stmmac/hwif.h
diff --cc drivers/net/ethernet/stmicro/stmmac/common.h
index 49bd786566fa,912bbb6515b2..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@@ -370,6 -360,8 +370,11 @@@ struct dma_features 
  	unsigned int sphen;
  	unsigned int vlins;
  	unsigned int dvlan;
++<<<<<<< HEAD
++=======
+ 	unsigned int l3l4fnum;
+ 	unsigned int arpoffsel;
++>>>>>>> 5904a980f93c (net: stmmac: xgmac: Implement ARP Offload)
  };
  
  /* GMAC TX FIFO is 8K, Rx FIFO is 16K */
diff --cc drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
index e534a3aaf4a3,36262ef8b70a..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
@@@ -1163,6 -1163,197 +1163,200 @@@ static void dwxgmac2_enable_vlan(struc
  	writel(value, ioaddr + XGMAC_VLAN_INCL);
  }
  
++<<<<<<< HEAD
++=======
+ static int dwxgmac2_filter_wait(struct mac_device_info *hw)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 
+ 	if (readl_poll_timeout(ioaddr + XGMAC_L3L4_ADDR_CTRL, value,
+ 			       !(value & XGMAC_XB), 100, 10000))
+ 		return -EBUSY;
+ 	return 0;
+ }
+ 
+ static int dwxgmac2_filter_read(struct mac_device_info *hw, u32 filter_no,
+ 				u8 reg, u32 *data)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	int ret;
+ 
+ 	ret = dwxgmac2_filter_wait(hw);
+ 	if (ret)
+ 		return ret;
+ 
+ 	value = ((filter_no << XGMAC_IDDR_FNUM) | reg) << XGMAC_IDDR_SHIFT;
+ 	value |= XGMAC_TT | XGMAC_XB;
+ 	writel(value, ioaddr + XGMAC_L3L4_ADDR_CTRL);
+ 
+ 	ret = dwxgmac2_filter_wait(hw);
+ 	if (ret)
+ 		return ret;
+ 
+ 	*data = readl(ioaddr + XGMAC_L3L4_DATA);
+ 	return 0;
+ }
+ 
+ static int dwxgmac2_filter_write(struct mac_device_info *hw, u32 filter_no,
+ 				 u8 reg, u32 data)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	int ret;
+ 
+ 	ret = dwxgmac2_filter_wait(hw);
+ 	if (ret)
+ 		return ret;
+ 
+ 	writel(data, ioaddr + XGMAC_L3L4_DATA);
+ 
+ 	value = ((filter_no << XGMAC_IDDR_FNUM) | reg) << XGMAC_IDDR_SHIFT;
+ 	value |= XGMAC_XB;
+ 	writel(value, ioaddr + XGMAC_L3L4_ADDR_CTRL);
+ 
+ 	return dwxgmac2_filter_wait(hw);
+ }
+ 
+ static int dwxgmac2_config_l3_filter(struct mac_device_info *hw, u32 filter_no,
+ 				     bool en, bool ipv6, bool sa, bool inv,
+ 				     u32 match)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	int ret;
+ 
+ 	value = readl(ioaddr + XGMAC_PACKET_FILTER);
+ 	value |= XGMAC_FILTER_IPFE;
+ 	writel(value, ioaddr + XGMAC_PACKET_FILTER);
+ 
+ 	ret = dwxgmac2_filter_read(hw, filter_no, XGMAC_L3L4_CTRL, &value);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* For IPv6 not both SA/DA filters can be active */
+ 	if (ipv6) {
+ 		value |= XGMAC_L3PEN0;
+ 		value &= ~(XGMAC_L3SAM0 | XGMAC_L3SAIM0);
+ 		value &= ~(XGMAC_L3DAM0 | XGMAC_L3DAIM0);
+ 		if (sa) {
+ 			value |= XGMAC_L3SAM0;
+ 			if (inv)
+ 				value |= XGMAC_L3SAIM0;
+ 		} else {
+ 			value |= XGMAC_L3DAM0;
+ 			if (inv)
+ 				value |= XGMAC_L3DAIM0;
+ 		}
+ 	} else {
+ 		value &= ~XGMAC_L3PEN0;
+ 		if (sa) {
+ 			value |= XGMAC_L3SAM0;
+ 			if (inv)
+ 				value |= XGMAC_L3SAIM0;
+ 		} else {
+ 			value |= XGMAC_L3DAM0;
+ 			if (inv)
+ 				value |= XGMAC_L3DAIM0;
+ 		}
+ 	}
+ 
+ 	ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, value);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (sa) {
+ 		ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3_ADDR0, match);
+ 		if (ret)
+ 			return ret;
+ 	} else {
+ 		ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3_ADDR1, match);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (!en)
+ 		return dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, 0);
+ 
+ 	return 0;
+ }
+ 
+ static int dwxgmac2_config_l4_filter(struct mac_device_info *hw, u32 filter_no,
+ 				     bool en, bool udp, bool sa, bool inv,
+ 				     u32 match)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 	int ret;
+ 
+ 	value = readl(ioaddr + XGMAC_PACKET_FILTER);
+ 	value |= XGMAC_FILTER_IPFE;
+ 	writel(value, ioaddr + XGMAC_PACKET_FILTER);
+ 
+ 	ret = dwxgmac2_filter_read(hw, filter_no, XGMAC_L3L4_CTRL, &value);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (udp) {
+ 		value |= XGMAC_L4PEN0;
+ 	} else {
+ 		value &= ~XGMAC_L4PEN0;
+ 	}
+ 
+ 	value &= ~(XGMAC_L4SPM0 | XGMAC_L4SPIM0);
+ 	value &= ~(XGMAC_L4DPM0 | XGMAC_L4DPIM0);
+ 	if (sa) {
+ 		value |= XGMAC_L4SPM0;
+ 		if (inv)
+ 			value |= XGMAC_L4SPIM0;
+ 	} else {
+ 		value |= XGMAC_L4DPM0;
+ 		if (inv)
+ 			value |= XGMAC_L4DPIM0;
+ 	}
+ 
+ 	ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, value);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (sa) {
+ 		value = match & XGMAC_L4SP0;
+ 
+ 		ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L4_ADDR, value);
+ 		if (ret)
+ 			return ret;
+ 	} else {
+ 		value = (match << XGMAC_L4DP0_SHIFT) & XGMAC_L4DP0;
+ 
+ 		ret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L4_ADDR, value);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (!en)
+ 		return dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, 0);
+ 
+ 	return 0;
+ }
+ 
+ static void dwxgmac2_set_arp_offload(struct mac_device_info *hw, bool en,
+ 				     u32 addr)
+ {
+ 	void __iomem *ioaddr = hw->pcsr;
+ 	u32 value;
+ 
+ 	writel(addr, ioaddr + XGMAC_ARP_ADDR);
+ 
+ 	value = readl(ioaddr + XGMAC_RX_CONFIG);
+ 	if (en)
+ 		value |= XGMAC_CONFIG_ARPEN;
+ 	else
+ 		value &= ~XGMAC_CONFIG_ARPEN;
+ 	writel(value, ioaddr + XGMAC_RX_CONFIG);
+ }
+ 
++>>>>>>> 5904a980f93c (net: stmmac: xgmac: Implement ARP Offload)
  const struct stmmac_ops dwxgmac210_ops = {
  	.core_init = dwxgmac2_core_init,
  	.set_mac = dwxgmac2_set_mac,
@@@ -1203,6 -1394,9 +1397,12 @@@
  	.flex_pps_config = dwxgmac2_flex_pps_config,
  	.sarc_configure = dwxgmac2_sarc_configure,
  	.enable_vlan = dwxgmac2_enable_vlan,
++<<<<<<< HEAD
++=======
+ 	.config_l3_filter = dwxgmac2_config_l3_filter,
+ 	.config_l4_filter = dwxgmac2_config_l4_filter,
+ 	.set_arp_offload = dwxgmac2_set_arp_offload,
++>>>>>>> 5904a980f93c (net: stmmac: xgmac: Implement ARP Offload)
  };
  
  int dwxgmac2_setup(struct stmmac_priv *priv)
diff --cc drivers/net/ethernet/stmicro/stmmac/hwif.h
index dda152265f96,ddb851d99618..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.h
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.h
@@@ -360,6 -363,14 +360,17 @@@ struct stmmac_ops 
  	int (*get_mac_tx_timestamp)(struct mac_device_info *hw, u64 *ts);
  	/* Source Address Insertion / Replacement */
  	void (*sarc_configure)(void __iomem *ioaddr, int val);
++<<<<<<< HEAD
++=======
+ 	/* Filtering */
+ 	int (*config_l3_filter)(struct mac_device_info *hw, u32 filter_no,
+ 				bool en, bool ipv6, bool sa, bool inv,
+ 				u32 match);
+ 	int (*config_l4_filter)(struct mac_device_info *hw, u32 filter_no,
+ 				bool en, bool udp, bool sa, bool inv,
+ 				u32 match);
+ 	void (*set_arp_offload)(struct mac_device_info *hw, bool en, u32 addr);
++>>>>>>> 5904a980f93c (net: stmmac: xgmac: Implement ARP Offload)
  };
  
  #define stmmac_core_init(__priv, __args...) \
@@@ -440,6 -451,12 +451,15 @@@
  	stmmac_do_callback(__priv, mac, get_mac_tx_timestamp, __args)
  #define stmmac_sarc_configure(__priv, __args...) \
  	stmmac_do_void_callback(__priv, mac, sarc_configure, __args)
++<<<<<<< HEAD
++=======
+ #define stmmac_config_l3_filter(__priv, __args...) \
+ 	stmmac_do_callback(__priv, mac, config_l3_filter, __args)
+ #define stmmac_config_l4_filter(__priv, __args...) \
+ 	stmmac_do_callback(__priv, mac, config_l4_filter, __args)
+ #define stmmac_set_arp_offload(__priv, __args...) \
+ 	stmmac_do_void_callback(__priv, mac, set_arp_offload, __args)
++>>>>>>> 5904a980f93c (net: stmmac: xgmac: Implement ARP Offload)
  
  /* PTP and HW Timer helpers */
  struct stmmac_hwtimestamp {
* Unmerged path drivers/net/ethernet/stmicro/stmmac/common.h
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c
index e77eb0ddf9b5..fef6661cdf85 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c
@@ -370,6 +370,7 @@ static void dwxgmac2_get_hw_feature(void __iomem *ioaddr,
 	dma_cap->atime_stamp = (hw_cap & XGMAC_HWFEAT_TSSEL) >> 12;
 	dma_cap->av = (hw_cap & XGMAC_HWFEAT_AVSEL) >> 11;
 	dma_cap->av &= (hw_cap & XGMAC_HWFEAT_RAVSEL) >> 10;
+	dma_cap->arpoffsel = (hw_cap & XGMAC_HWFEAT_ARPOFFSEL) >> 9;
 	dma_cap->rmon = (hw_cap & XGMAC_HWFEAT_MMCSEL) >> 8;
 	dma_cap->pmt_magic_frame = (hw_cap & XGMAC_HWFEAT_MGKSEL) >> 7;
 	dma_cap->pmt_remote_wake_up = (hw_cap & XGMAC_HWFEAT_RWKSEL) >> 6;
* Unmerged path drivers/net/ethernet/stmicro/stmmac/hwif.h
