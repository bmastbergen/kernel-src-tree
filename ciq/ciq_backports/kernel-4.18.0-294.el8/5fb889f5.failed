compat_ioctl: block: simplify compat_blkpg_ioctl()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Arnd Bergmann <arnd@arndb.de>
commit 5fb889f587fa2ae486e067d8a00df955ae6492b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5fb889f5.failed

There is no need to go through a compat_alloc_user_space()
copy any more, just wrap the function in a small helper that
works the same way for native and compat mode.

	Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
(cherry picked from commit 5fb889f587fa2ae486e067d8a00df955ae6492b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/ioctl.c
diff --cc block/ioctl.c
index f8f8a81c640e,d6911a1149f5..000000000000
--- a/block/ioctl.c
+++ b/block/ioctl.c
@@@ -582,3 -705,123 +613,126 @@@ int blkdev_ioctl(struct block_device *b
  	}
  }
  EXPORT_SYMBOL_GPL(blkdev_ioctl);
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_COMPAT
+ #define BLKBSZGET_32		_IOR(0x12, 112, int)
+ #define BLKBSZSET_32		_IOW(0x12, 113, int)
+ #define BLKGETSIZE64_32		_IOR(0x12, 114, int)
+ 
+ /* Most of the generic ioctls are handled in the normal fallback path.
+    This assumes the blkdev's low level compat_ioctl always returns
+    ENOIOCTLCMD for unknown ioctls. */
+ long compat_blkdev_ioctl(struct file *file, unsigned cmd, unsigned long arg)
+ {
+ 	int ret = -ENOIOCTLCMD;
+ 	struct inode *inode = file->f_mapping->host;
+ 	struct block_device *bdev = inode->i_bdev;
+ 	struct gendisk *disk = bdev->bd_disk;
+ 	fmode_t mode = file->f_mode;
+ 	loff_t size;
+ 	unsigned int max_sectors;
+ 
+ 	/*
+ 	 * O_NDELAY can be altered using fcntl(.., F_SETFL, ..), so we have
+ 	 * to updated it before every ioctl.
+ 	 */
+ 	if (file->f_flags & O_NDELAY)
+ 		mode |= FMODE_NDELAY;
+ 	else
+ 		mode &= ~FMODE_NDELAY;
+ 
+ 	switch (cmd) {
+ 	case HDIO_GETGEO:
+ 		return compat_hdio_getgeo(disk, bdev, compat_ptr(arg));
+ 	case BLKPBSZGET:
+ 		return compat_put_uint(arg, bdev_physical_block_size(bdev));
+ 	case BLKIOMIN:
+ 		return compat_put_uint(arg, bdev_io_min(bdev));
+ 	case BLKIOOPT:
+ 		return compat_put_uint(arg, bdev_io_opt(bdev));
+ 	case BLKALIGNOFF:
+ 		return compat_put_int(arg, bdev_alignment_offset(bdev));
+ 	case BLKDISCARDZEROES:
+ 		return compat_put_uint(arg, 0);
+ 	case BLKFLSBUF:
+ 	case BLKROSET:
+ 	case BLKDISCARD:
+ 	case BLKSECDISCARD:
+ 	case BLKZEROOUT:
+ 	/*
+ 	 * the ones below are implemented in blkdev_locked_ioctl,
+ 	 * but we call blkdev_ioctl, which gets the lock for us
+ 	 */
+ 	case BLKRRPART:
+ 	case BLKREPORTZONE:
+ 	case BLKRESETZONE:
+ 	case BLKOPENZONE:
+ 	case BLKCLOSEZONE:
+ 	case BLKFINISHZONE:
+ 	case BLKGETZONESZ:
+ 	case BLKGETNRZONES:
+ 		return blkdev_ioctl(bdev, mode, cmd,
+ 				(unsigned long)compat_ptr(arg));
+ 	case BLKBSZSET_32:
+ 		return blkdev_ioctl(bdev, mode, BLKBSZSET,
+ 				(unsigned long)compat_ptr(arg));
+ 	case BLKPG:
+ 		return compat_blkpg_ioctl(bdev, compat_ptr(arg));
+ 	case BLKRAGET:
+ 	case BLKFRAGET:
+ 		if (!arg)
+ 			return -EINVAL;
+ 		return compat_put_long(arg,
+ 			       (bdev->bd_bdi->ra_pages * PAGE_SIZE) / 512);
+ 	case BLKROGET: /* compatible */
+ 		return compat_put_int(arg, bdev_read_only(bdev) != 0);
+ 	case BLKBSZGET_32: /* get the logical block size (cf. BLKSSZGET) */
+ 		return compat_put_int(arg, block_size(bdev));
+ 	case BLKSSZGET: /* get block device hardware sector size */
+ 		return compat_put_int(arg, bdev_logical_block_size(bdev));
+ 	case BLKSECTGET:
+ 		max_sectors = min_t(unsigned int, USHRT_MAX,
+ 				    queue_max_sectors(bdev_get_queue(bdev)));
+ 		return compat_put_ushort(arg, max_sectors);
+ 	case BLKROTATIONAL:
+ 		return compat_put_ushort(arg,
+ 					 !blk_queue_nonrot(bdev_get_queue(bdev)));
+ 	case BLKRASET: /* compatible, but no compat_ptr (!) */
+ 	case BLKFRASET:
+ 		if (!capable(CAP_SYS_ADMIN))
+ 			return -EACCES;
+ 		bdev->bd_bdi->ra_pages = (arg * 512) / PAGE_SIZE;
+ 		return 0;
+ 	case BLKGETSIZE:
+ 		size = i_size_read(bdev->bd_inode);
+ 		if ((size >> 9) > ~0UL)
+ 			return -EFBIG;
+ 		return compat_put_ulong(arg, size >> 9);
+ 
+ 	case BLKGETSIZE64_32:
+ 		return compat_put_u64(arg, i_size_read(bdev->bd_inode));
+ 
+ 	case BLKTRACESETUP32:
+ 	case BLKTRACESTART: /* compatible */
+ 	case BLKTRACESTOP:  /* compatible */
+ 	case BLKTRACETEARDOWN: /* compatible */
+ 		ret = blk_trace_ioctl(bdev, cmd, compat_ptr(arg));
+ 		return ret;
+ 	case IOC_PR_REGISTER:
+ 	case IOC_PR_RESERVE:
+ 	case IOC_PR_RELEASE:
+ 	case IOC_PR_PREEMPT:
+ 	case IOC_PR_PREEMPT_ABORT:
+ 	case IOC_PR_CLEAR:
+ 		return blkdev_ioctl(bdev, mode, cmd,
+ 				(unsigned long)compat_ptr(arg));
+ 	default:
+ 		if (disk->fops->compat_ioctl)
+ 			ret = disk->fops->compat_ioctl(bdev, mode, cmd, arg);
+ 		return ret;
+ 	}
+ }
+ #endif
++>>>>>>> 5fb889f587fa (compat_ioctl: block: simplify compat_blkpg_ioctl())
* Unmerged path block/ioctl.c
