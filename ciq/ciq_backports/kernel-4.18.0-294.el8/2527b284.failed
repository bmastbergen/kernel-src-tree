move the capability checks from sget_userns() to legacy_get_tree()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 2527b284defaeadf74829b0b0bd3207ca7f165eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2527b284.failed

1) all call chains leading to sget_userns() pass through ->mount()
instances.
2) none of ->mount() instances is ever called directly - the only
call site is legacy_get_tree()
3) all remaining ->mount() instances end up calling sget_userns()

IOW, we might as well do the capability checks just before calling
->mount().  As for the arguments passed to mount_capable(),
in case of call chains to sget_userns() going through sget(),
we either don't call mount_capable() at all, or pass current_user_ns()
to it.  The call chains going through mount_pseudo_xattr() don't
call mount_capable() at all (SB_KERNMOUNT in flags on those).

That could've been split into smaller steps (lifting the checks
into sget(), then callers of sget(), then all the way to the
entries of every ->mount() out there, then to the sole caller),
but that would be too much churn for little benefit...

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 2527b284defaeadf74829b0b0bd3207ca7f165eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs_context.c
#	fs/internal.h
#	fs/super.c
diff --cc fs/internal.h
index 172c0652a6e5,65db901420af..000000000000
--- a/fs/internal.h
+++ b/fs/internal.h
@@@ -17,6 -17,8 +17,11 @@@ struct linux_binprm
  struct path;
  struct mount;
  struct shrink_control;
++<<<<<<< HEAD
++=======
+ struct fs_context;
+ struct user_namespace;
++>>>>>>> 2527b284defa (move the capability checks from sget_userns() to legacy_get_tree())
  
  /*
   * block_dev.c
@@@ -99,11 -111,10 +104,12 @@@ extern struct file *alloc_empty_file_no
  /*
   * super.c
   */
 -extern int reconfigure_super(struct fs_context *);
 +extern int do_remount_sb(struct super_block *, int, void *, int);
  extern bool trylock_super(struct super_block *sb);
 +extern struct dentry *mount_fs(struct file_system_type *,
 +			       int, const char *, void *);
  extern struct super_block *user_get_super(dev_t);
+ extern bool mount_capable(struct file_system_type *, struct user_namespace *);
  
  /*
   * open.c
diff --cc fs/super.c
index 72596c26684f,bdb03255c7ea..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -497,14 -583,6 +497,17 @@@ struct super_block *sget_userns(struct 
  	struct super_block *old;
  	int err;
  
++<<<<<<< HEAD
 +	/* Ensure the requestor has permissions over the target filesystem */
 +	if (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))
 +		return ERR_PTR(-EPERM);
 +
 +	if (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&
 +	    !(type->fs_flags & FS_USERNS_MOUNT) &&
 +	    !capable(CAP_SYS_ADMIN))
 +		return ERR_PTR(-EPERM);
++=======
++>>>>>>> 2527b284defa (move the capability checks from sget_userns() to legacy_get_tree())
  retry:
  	spin_lock(&sb_lock);
  	if (test) {
* Unmerged path fs/fs_context.c
* Unmerged path fs/fs_context.c
* Unmerged path fs/internal.h
* Unmerged path fs/super.c
