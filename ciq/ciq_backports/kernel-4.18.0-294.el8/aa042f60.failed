net: stmmac: Add support to Ethtool get/set ring parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Song, Yoong Siang <yoong.siang.song@intel.com>
commit aa042f60e4961d4bec57e3268624df1f3a6befa4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/aa042f60.failed

This patch add support to --show-ring & --set-ring Ethtool functions:
- Adding min, max, power of two check to new ring parameter's value.
- Bring down the network interface before changing the value of ring
  parameters.
- Bring up the network interface after changing the value of ring
  parameters.

	Signed-off-by: Song, Yoong Siang <yoong.siang.song@intel.com>
	Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
	Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aa042f60e4961d4bec57e3268624df1f3a6befa4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 0f8a7fbe4f9b,df2c74bbfcff..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -1153,13 -1213,19 +1153,20 @@@ static void stmmac_clear_tx_descriptors
  	int i;
  
  	/* Clear the TX descriptors */
++<<<<<<< HEAD
 +	for (i = 0; i < DMA_TX_SIZE; i++)
++=======
+ 	for (i = 0; i < priv->dma_tx_size; i++) {
+ 		int last = (i == (priv->dma_tx_size - 1));
+ 		struct dma_desc *p;
+ 
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  		if (priv->extend_desc)
 -			p = &tx_q->dma_etx[i].basic;
 -		else if (tx_q->tbs & STMMAC_TBS_AVAIL)
 -			p = &tx_q->dma_entx[i].basic;
 +			stmmac_init_tx_desc(priv, &tx_q->dma_etx[i].basic,
 +					priv->mode, (i == DMA_TX_SIZE - 1));
  		else
 -			p = &tx_q->dma_tx[i];
 -
 -		stmmac_init_tx_desc(priv, p, priv->mode, last);
 -	}
 +			stmmac_init_tx_desc(priv, &tx_q->dma_tx[i],
 +					priv->mode, (i == DMA_TX_SIZE - 1));
  }
  
  /**
@@@ -1372,13 -1440,15 +1381,20 @@@ static int init_dma_tx_desc_rings(struc
  		if (priv->mode == STMMAC_CHAIN_MODE) {
  			if (priv->extend_desc)
  				stmmac_mode_init(priv, tx_q->dma_etx,
++<<<<<<< HEAD
 +						tx_q->dma_tx_phy, DMA_TX_SIZE, 1);
 +			else
++=======
+ 						 tx_q->dma_tx_phy,
+ 						 priv->dma_tx_size, 1);
+ 			else if (!(tx_q->tbs & STMMAC_TBS_AVAIL))
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  				stmmac_mode_init(priv, tx_q->dma_tx,
- 						tx_q->dma_tx_phy, DMA_TX_SIZE, 0);
+ 						 tx_q->dma_tx_phy,
+ 						 priv->dma_tx_size, 0);
  		}
  
- 		for (i = 0; i < DMA_TX_SIZE; i++) {
+ 		for (i = 0; i < priv->dma_tx_size; i++) {
  			struct dma_desc *p;
  			if (priv->extend_desc)
  				p = &((tx_q->dma_etx + i)->basic);
@@@ -1507,15 -1579,20 +1523,32 @@@ static void free_dma_tx_desc_resources(
  		/* Release the DMA TX socket buffers */
  		dma_free_tx_skbufs(priv, queue);
  
++<<<<<<< HEAD
 +		/* Free DMA regions of consistent memory previously allocated */
 +		if (!priv->extend_desc)
 +			dma_free_coherent(priv->device,
 +					  DMA_TX_SIZE * sizeof(struct dma_desc),
 +					  tx_q->dma_tx, tx_q->dma_tx_phy);
 +		else
 +			dma_free_coherent(priv->device, DMA_TX_SIZE *
 +					  sizeof(struct dma_extended_desc),
 +					  tx_q->dma_etx, tx_q->dma_tx_phy);
++=======
+ 		if (priv->extend_desc) {
+ 			size = sizeof(struct dma_extended_desc);
+ 			addr = tx_q->dma_etx;
+ 		} else if (tx_q->tbs & STMMAC_TBS_AVAIL) {
+ 			size = sizeof(struct dma_edesc);
+ 			addr = tx_q->dma_entx;
+ 		} else {
+ 			size = sizeof(struct dma_desc);
+ 			addr = tx_q->dma_tx;
+ 		}
+ 
+ 		size *= priv->dma_tx_size;
+ 
+ 		dma_free_coherent(priv->device, size, addr, tx_q->dma_tx_phy);
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  
  		kfree(tx_q->tx_skbuff_dma);
  		kfree(tx_q->tx_skbuff);
@@@ -1566,22 -1644,20 +1600,38 @@@ static int alloc_dma_rx_desc_resources(
  			goto err_dma;
  
  		if (priv->extend_desc) {
++<<<<<<< HEAD
 +			rx_q->dma_erx = dma_zalloc_coherent(priv->device,
 +							    DMA_RX_SIZE *
 +							    sizeof(struct
 +							    dma_extended_desc),
 +							    &rx_q->dma_rx_phy,
 +							    GFP_KERNEL);
++=======
+ 			rx_q->dma_erx = dma_alloc_coherent(priv->device,
+ 							   priv->dma_rx_size *
+ 							   sizeof(struct dma_extended_desc),
+ 							   &rx_q->dma_rx_phy,
+ 							   GFP_KERNEL);
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  			if (!rx_q->dma_erx)
  				goto err_dma;
  
  		} else {
++<<<<<<< HEAD
 +			rx_q->dma_rx = dma_zalloc_coherent(priv->device,
 +							   DMA_RX_SIZE *
 +							   sizeof(struct
 +							   dma_desc),
 +							   &rx_q->dma_rx_phy,
 +							   GFP_KERNEL);
++=======
+ 			rx_q->dma_rx = dma_alloc_coherent(priv->device,
+ 							  priv->dma_rx_size *
+ 							  sizeof(struct dma_desc),
+ 							  &rx_q->dma_rx_phy,
+ 							  GFP_KERNEL);
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  			if (!rx_q->dma_rx)
  				goto err_dma;
  		}
@@@ -1628,25 -1706,26 +1678,48 @@@ static int alloc_dma_tx_desc_resources(
  		if (!tx_q->tx_skbuff)
  			goto err_dma;
  
++<<<<<<< HEAD
 +		if (priv->extend_desc) {
 +			tx_q->dma_etx = dma_zalloc_coherent(priv->device,
 +							    DMA_TX_SIZE *
 +							    sizeof(struct
 +							    dma_extended_desc),
 +							    &tx_q->dma_tx_phy,
 +							    GFP_KERNEL);
 +			if (!tx_q->dma_etx)
 +				goto err_dma;
 +		} else {
 +			tx_q->dma_tx = dma_zalloc_coherent(priv->device,
 +							   DMA_TX_SIZE *
 +							   sizeof(struct
 +								  dma_desc),
 +							   &tx_q->dma_tx_phy,
 +							   GFP_KERNEL);
 +			if (!tx_q->dma_tx)
 +				goto err_dma;
 +		}
++=======
+ 		if (priv->extend_desc)
+ 			size = sizeof(struct dma_extended_desc);
+ 		else if (tx_q->tbs & STMMAC_TBS_AVAIL)
+ 			size = sizeof(struct dma_edesc);
+ 		else
+ 			size = sizeof(struct dma_desc);
+ 
+ 		size *= priv->dma_tx_size;
+ 
+ 		addr = dma_alloc_coherent(priv->device, size,
+ 					  &tx_q->dma_tx_phy, GFP_KERNEL);
+ 		if (!addr)
+ 			goto err_dma;
+ 
+ 		if (priv->extend_desc)
+ 			tx_q->dma_etx = addr;
+ 		else if (tx_q->tbs & STMMAC_TBS_AVAIL)
+ 			tx_q->dma_entx = addr;
+ 		else
+ 			tx_q->dma_tx = addr;
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  	}
  
  	return 0;
@@@ -2692,6 -2775,21 +2766,24 @@@ static int stmmac_open(struct net_devic
  
  	priv->rx_copybreak = STMMAC_RX_COPYBREAK;
  
++<<<<<<< HEAD
++=======
+ 	if (!priv->dma_tx_size)
+ 		priv->dma_tx_size = DMA_DEFAULT_TX_SIZE;
+ 	if (!priv->dma_rx_size)
+ 		priv->dma_rx_size = DMA_DEFAULT_RX_SIZE;
+ 
+ 	/* Earlier check for TBS */
+ 	for (chan = 0; chan < priv->plat->tx_queues_to_use; chan++) {
+ 		struct stmmac_tx_queue *tx_q = &priv->tx_queue[chan];
+ 		int tbs_en = priv->plat->tx_queues_cfg[chan].tbs_en;
+ 
+ 		tx_q->tbs |= tbs_en ? STMMAC_TBS_AVAIL : 0;
+ 		if (stmmac_enable_tbs(priv, priv->ioaddr, tbs_en, chan))
+ 			tx_q->tbs &= ~STMMAC_TBS_AVAIL;
+ 	}
+ 
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  	ret = alloc_dma_desc_resources(priv);
  	if (ret < 0) {
  		netdev_err(priv->dev, "%s: DMA descriptors allocation failed\n",
@@@ -2875,9 -2977,14 +2967,10 @@@ static void stmmac_tso_allocator(struc
  	while (tmp_len > 0) {
  		dma_addr_t curr_addr;
  
- 		tx_q->cur_tx = STMMAC_GET_ENTRY(tx_q->cur_tx, DMA_TX_SIZE);
+ 		tx_q->cur_tx = STMMAC_GET_ENTRY(tx_q->cur_tx,
+ 						priv->dma_tx_size);
  		WARN_ON(tx_q->tx_skbuff[tx_q->cur_tx]);
 -
 -		if (tx_q->tbs & STMMAC_TBS_AVAIL)
 -			desc = &tx_q->dma_entx[tx_q->cur_tx].basic;
 -		else
 -			desc = &tx_q->dma_tx[tx_q->cur_tx];
 +		desc = tx_q->dma_tx + tx_q->cur_tx;
  
  		curr_addr = des + (total_len - tmp_len);
  		if (priv->dma_cap.addr64 <= 32)
@@@ -2971,10 -3078,15 +3064,11 @@@ static netdev_tx_t stmmac_tso_xmit(stru
  
  	/* set new MSS value if needed */
  	if (mss != tx_q->mss) {
 -		if (tx_q->tbs & STMMAC_TBS_AVAIL)
 -			mss_desc = &tx_q->dma_entx[tx_q->cur_tx].basic;
 -		else
 -			mss_desc = &tx_q->dma_tx[tx_q->cur_tx];
 -
 +		mss_desc = tx_q->dma_tx + tx_q->cur_tx;
  		stmmac_set_mss(priv, mss_desc, mss);
  		tx_q->mss = mss;
- 		tx_q->cur_tx = STMMAC_GET_ENTRY(tx_q->cur_tx, DMA_TX_SIZE);
+ 		tx_q->cur_tx = STMMAC_GET_ENTRY(tx_q->cur_tx,
+ 						priv->dma_tx_size);
  		WARN_ON(tx_q->tx_skbuff[tx_q->cur_tx]);
  	}
  
@@@ -3510,10 -3692,10 +3604,10 @@@ static int stmmac_rx(struct stmmac_pri
  		else
  			rx_head = (void *)rx_q->dma_rx;
  
- 		stmmac_display_ring(priv, rx_head, DMA_RX_SIZE, true);
+ 		stmmac_display_ring(priv, rx_head, priv->dma_rx_size, true);
  	}
  	while (count < limit) {
 -		unsigned int buf1_len = 0, buf2_len = 0;
 +		unsigned int hlen = 0, prev_len = 0;
  		enum pkt_hash_types hash_type;
  		struct stmmac_rx_buffer *buf;
  		struct dma_desc *np, *p;
@@@ -3552,9 -3734,8 +3646,14 @@@ read_again
  		if (unlikely(status & dma_own))
  			break;
  
++<<<<<<< HEAD
 +		count++;
 +
 +		rx_q->cur_rx = STMMAC_GET_ENTRY(rx_q->cur_rx, DMA_RX_SIZE);
++=======
+ 		rx_q->cur_rx = STMMAC_GET_ENTRY(rx_q->cur_rx,
+ 						priv->dma_rx_size);
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  		next_entry = rx_q->cur_rx;
  
  		if (priv->extend_desc)
@@@ -4131,11 -4319,11 +4230,16 @@@ static int stmmac_rings_status_show(str
  		if (priv->extend_desc) {
  			seq_printf(seq, "Extended descriptor ring:\n");
  			sysfs_display_ring((void *)tx_q->dma_etx,
++<<<<<<< HEAD
 +					   DMA_TX_SIZE, 1, seq);
 +		} else {
++=======
+ 					   priv->dma_tx_size, 1, seq);
+ 		} else if (!(tx_q->tbs & STMMAC_TBS_AVAIL)) {
++>>>>>>> aa042f60e496 (net: stmmac: Add support to Ethtool get/set ring parameters)
  			seq_printf(seq, "Descriptor ring:\n");
  			sysfs_display_ring((void *)tx_q->dma_tx,
- 					   DMA_TX_SIZE, 0, seq);
+ 					   priv->dma_tx_size, 0, seq);
  		}
  	}
  
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/chain_mode.c b/drivers/net/ethernet/stmicro/stmmac/chain_mode.c
index b9c9003060c5..eb653d15874b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/chain_mode.c
+++ b/drivers/net/ethernet/stmicro/stmmac/chain_mode.c
@@ -56,7 +56,7 @@ static int jumbo_frm(void *p, struct sk_buff *skb, int csum)
 
 	while (len != 0) {
 		tx_q->tx_skbuff[entry] = NULL;
-		entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
+		entry = STMMAC_GET_ENTRY(entry, priv->dma_tx_size);
 		desc = tx_q->dma_tx + entry;
 
 		if (len > bmax) {
@@ -147,7 +147,7 @@ static void refill_desc3(void *priv_ptr, struct dma_desc *p)
 		 */
 		p->des3 = cpu_to_le32((unsigned int)(rx_q->dma_rx_phy +
 				      (((rx_q->dirty_rx) + 1) %
-				       DMA_RX_SIZE) *
+				       priv->dma_rx_size) *
 				      sizeof(struct dma_desc)));
 }
 
@@ -164,7 +164,8 @@ static void clean_desc3(void *priv_ptr, struct dma_desc *p)
 		 * to keep explicit chaining in the descriptor.
 		 */
 		p->des3 = cpu_to_le32((unsigned int)((tx_q->dma_tx_phy +
-				      ((tx_q->dirty_tx + 1) % DMA_TX_SIZE))
+				      ((tx_q->dirty_tx + 1) %
+				       priv->dma_tx_size))
 				      * sizeof(struct dma_desc)));
 }
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.h
index 41eb39add60e..13db2f32ce82 100644
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -46,9 +46,16 @@
 
 #define STMMAC_CHAN0	0	/* Always supported and default for all chips */
 
-/* These need to be power of two, and >= 4 */
-#define DMA_TX_SIZE 512
-#define DMA_RX_SIZE 512
+/* TX and RX Descriptor Length, these need to be power of two.
+ * TX descriptor length less than 64 may cause transmit queue timed out error.
+ * RX descriptor length less than 64 may cause inconsistent Rx chain error.
+ */
+#define DMA_MIN_TX_SIZE		64
+#define DMA_MAX_TX_SIZE		1024
+#define DMA_DEFAULT_TX_SIZE	512
+#define DMA_MIN_RX_SIZE		64
+#define DMA_MAX_RX_SIZE		1024
+#define DMA_DEFAULT_RX_SIZE	512
 #define STMMAC_GET_ENTRY(x, size)	((x + 1) & (size - 1))
 
 #undef FRAME_FILTER_DEBUG
diff --git a/drivers/net/ethernet/stmicro/stmmac/ring_mode.c b/drivers/net/ethernet/stmicro/stmmac/ring_mode.c
index 4d9bcb4d0378..554fd33f5dbb 100644
--- a/drivers/net/ethernet/stmicro/stmmac/ring_mode.c
+++ b/drivers/net/ethernet/stmicro/stmmac/ring_mode.c
@@ -61,7 +61,7 @@ static int jumbo_frm(void *p, struct sk_buff *skb, int csum)
 		stmmac_prepare_tx_desc(priv, desc, 1, bmax, csum,
 				STMMAC_RING_MODE, 0, false, skb->len);
 		tx_q->tx_skbuff[entry] = NULL;
-		entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
+		entry = STMMAC_GET_ENTRY(entry, priv->dma_tx_size);
 
 		if (priv->extend_desc)
 			desc = (struct dma_desc *)(tx_q->dma_etx + entry);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 49e040547eb8..ae13f9ff1c37 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -166,9 +166,11 @@ struct stmmac_priv {
 
 	/* RX Queue */
 	struct stmmac_rx_queue rx_queue[MTL_MAX_RX_QUEUES];
+	unsigned int dma_rx_size;
 
 	/* TX Queue */
 	struct stmmac_tx_queue tx_queue[MTL_MAX_TX_QUEUES];
+	unsigned int dma_tx_size;
 
 	/* Generic channel for NAPI */
 	struct stmmac_channel channel[STMMAC_CH_MAX];
@@ -260,5 +262,6 @@ int stmmac_dvr_probe(struct device *device,
 void stmmac_disable_eee_mode(struct stmmac_priv *priv);
 bool stmmac_eee_init(struct stmmac_priv *priv);
 int stmmac_reinit_queues(struct net_device *dev, u32 rx_cnt, u32 tx_cnt);
+int stmmac_reinit_ringparam(struct net_device *dev, u32 rx_size, u32 tx_size);
 
 #endif /* __STMMAC_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index 1e76cf95365b..f495162fdda9 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -450,6 +450,33 @@ static int stmmac_nway_reset(struct net_device *dev)
 	return phylink_ethtool_nway_reset(priv->phylink);
 }
 
+static void stmmac_get_ringparam(struct net_device *netdev,
+				 struct ethtool_ringparam *ring)
+{
+	struct stmmac_priv *priv = netdev_priv(netdev);
+
+	ring->rx_max_pending = DMA_MAX_RX_SIZE;
+	ring->tx_max_pending = DMA_MAX_TX_SIZE;
+	ring->rx_pending = priv->dma_rx_size;
+	ring->tx_pending = priv->dma_tx_size;
+}
+
+static int stmmac_set_ringparam(struct net_device *netdev,
+				struct ethtool_ringparam *ring)
+{
+	if (ring->rx_mini_pending || ring->rx_jumbo_pending ||
+	    ring->rx_pending < DMA_MIN_RX_SIZE ||
+	    ring->rx_pending > DMA_MAX_RX_SIZE ||
+	    !is_power_of_2(ring->rx_pending) ||
+	    ring->tx_pending < DMA_MIN_TX_SIZE ||
+	    ring->tx_pending > DMA_MAX_TX_SIZE ||
+	    !is_power_of_2(ring->tx_pending))
+		return -EINVAL;
+
+	return stmmac_reinit_ringparam(netdev, ring->rx_pending,
+				       ring->tx_pending);
+}
+
 static void
 stmmac_get_pauseparam(struct net_device *netdev,
 		      struct ethtool_pauseparam *pause)
@@ -955,6 +982,8 @@ static const struct ethtool_ops stmmac_ethtool_ops = {
 	.get_regs_len = stmmac_ethtool_get_regs_len,
 	.get_link = ethtool_op_get_link,
 	.nway_reset = stmmac_nway_reset,
+	.get_ringparam = stmmac_get_ringparam,
+	.set_ringparam = stmmac_set_ringparam,
 	.get_pauseparam = stmmac_get_pauseparam,
 	.set_pauseparam = stmmac_set_pauseparam,
 	.get_ethtool_stats = stmmac_get_ethtool_stats,
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
