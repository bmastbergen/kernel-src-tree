mm, oom: remove oom_lock from oom_reaper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michal Hocko <mhocko@suse.com>
commit af5679fbc669f31f7ebd0d473bca76c24c07de30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/af5679fb.failed

oom_reaper used to rely on the oom_lock since e2fe14564d33 ("oom_reaper:
close race with exiting task").  We do not really need the lock anymore
though.  212925802454 ("mm: oom: let oom_reap_task and exit_mmap run
concurrently") has removed serialization with the exit path based on the
mm reference count and so we do not really rely on the oom_lock anymore.

Tetsuo was arguing that at least MMF_OOM_SKIP should be set under the lock
to prevent from races when the page allocator didn't manage to get the
freed (reaped) memory in __alloc_pages_may_oom but it sees the flag later
on and move on to another victim.  Although this is possible in principle
let's wait for it to actually happen in real life before we make the
locking more complex again.

Therefore remove the oom_lock for oom_reaper paths (both exit_mmap and
oom_reap_task_mm).  The reaper serializes with exit_mmap by mmap_sem +
MMF_OOM_SKIP flag.  There is no synchronization with out_of_memory path
now.

[mhocko@kernel.org: oom_reap_task_mm should return false when __oom_reap_task_mm did]
  Link: http://lkml.kernel.org/r/20180724141747.GP28386@dhcp22.suse.cz
Link: http://lkml.kernel.org/r/20180719075922.13784-1-mhocko@kernel.org
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Suggested-by: David Rientjes <rientjes@google.com>
	Acked-by: David Rientjes <rientjes@google.com>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit af5679fbc669f31f7ebd0d473bca76c24c07de30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mmap.c
#	mm/oom_kill.c
diff --cc mm/mmap.c
index fe8e11099119,5f2b2b184c60..000000000000
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@@ -3072,9 -3063,7 +3072,13 @@@ void exit_mmap(struct mm_struct *mm
  		 * which clears VM_LOCKED, otherwise the oom reaper cannot
  		 * reliably test it.
  		 */
++<<<<<<< HEAD
 +		mutex_lock(&oom_lock);
 +		__oom_reap_task_mm(mm);
 +		mutex_unlock(&oom_lock);
++=======
+ 		(void)__oom_reap_task_mm(mm);
++>>>>>>> af5679fbc669 (mm, oom: remove oom_lock from oom_reaper)
  
  		set_bit(MMF_OOM_SKIP, &mm->flags);
  		down_write(&mm->mmap_sem);
diff --cc mm/oom_kill.c
index 61089bf06f38,66a86dd049a0..000000000000
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@@ -530,42 -535,11 +530,23 @@@ void __oom_reap_task_mm(struct mm_struc
  
  static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
  {
- 	bool ret = true;
- 
- 	/*
- 	 * We have to make sure to not race with the victim exit path
- 	 * and cause premature new oom victim selection:
- 	 * oom_reap_task_mm		exit_mm
- 	 *   mmget_not_zero
- 	 *				  mmput
- 	 *				    atomic_dec_and_test
- 	 *				  exit_oom_victim
- 	 *				[...]
- 	 *				out_of_memory
- 	 *				  select_bad_process
- 	 *				    # no TIF_MEMDIE task selects new victim
- 	 *  unmap_page_range # frees some memory
- 	 */
- 	mutex_lock(&oom_lock);
- 
  	if (!down_read_trylock(&mm->mmap_sem)) {
- 		ret = false;
  		trace_skip_task_reaping(tsk->pid);
- 		goto unlock_oom;
+ 		return false;
  	}
  
 +	/*
 +	 * If the mm has invalidate_{start,end}() notifiers that could block,
 +	 * sleep to give the oom victim some more time.
 +	 * TODO: we really want to get rid of this ugly hack and make sure that
 +	 * notifiers cannot block for unbounded amount of time
 +	 */
 +	if (mm_has_blockable_invalidate_notifiers(mm)) {
 +		up_read(&mm->mmap_sem);
 +		schedule_timeout_idle(HZ);
 +		goto unlock_oom;
 +	}
 +
  	/*
  	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
  	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
@@@ -580,7 -554,11 +561,15 @@@
  
  	trace_start_task_reaping(tsk->pid);
  
++<<<<<<< HEAD
 +	__oom_reap_task_mm(mm);
++=======
+ 	/* failed to reap part of the address space. Try again later */
+ 	if (!__oom_reap_task_mm(mm)) {
+ 		up_read(&mm->mmap_sem);
+ 		return false;
+ 	}
++>>>>>>> af5679fbc669 (mm, oom: remove oom_lock from oom_reaper)
  
  	pr_info("oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n",
  			task_pid_nr(tsk), tsk->comm,
* Unmerged path mm/mmap.c
* Unmerged path mm/oom_kill.c
