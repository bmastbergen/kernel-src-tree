bpf: Remove btf_id helpers resolving

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 138b9a0511c789f2451ff1d80e7fd3f9eef3a9e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/138b9a05.failed

Now when we moved the helpers btf_id arrays into .BTF_ids section,
we can remove the code that resolve those IDs in runtime.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Tested-by: Andrii Nakryiko <andriin@fb.com>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20200711215329.41165-6-jolsa@kernel.org
(cherry picked from commit 138b9a0511c789f2451ff1d80e7fd3f9eef3a9e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/btf.c
diff --cc kernel/bpf/btf.c
index bcee2f08fd19,71140b73ae3c..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -4031,80 -4079,6 +4031,83 @@@ error
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
 +static int __btf_resolve_helper_id(struct bpf_verifier_log *log, void *fn,
 +				   int arg)
 +{
 +	char fnname[KSYM_SYMBOL_LEN + 4] = "btf_";
 +	const struct btf_param *args;
 +	const struct btf_type *t;
 +	const char *tname, *sym;
 +	u32 btf_id, i;
 +
 +	if (!btf_vmlinux) {
 +		bpf_log(log, "btf_vmlinux doesn't exist\n");
 +		return -EINVAL;
 +	}
 +
 +	if (IS_ERR(btf_vmlinux)) {
 +		bpf_log(log, "btf_vmlinux is malformed\n");
 +		return -EINVAL;
 +	}
 +
 +	sym = kallsyms_lookup((long)fn, NULL, NULL, NULL, fnname + 4);
 +	if (!sym) {
 +		bpf_log(log, "kernel doesn't have kallsyms\n");
 +		return -EFAULT;
 +	}
 +
 +	for (i = 1; i <= btf_vmlinux->nr_types; i++) {
 +		t = btf_type_by_id(btf_vmlinux, i);
 +		if (BTF_INFO_KIND(t->info) != BTF_KIND_TYPEDEF)
 +			continue;
 +		tname = __btf_name_by_offset(btf_vmlinux, t->name_off);
 +		if (!strcmp(tname, fnname))
 +			break;
 +	}
 +	if (i > btf_vmlinux->nr_types) {
 +		bpf_log(log, "helper %s type is not found\n", fnname);
 +		return -ENOENT;
 +	}
 +
 +	t = btf_type_by_id(btf_vmlinux, t->type);
 +	if (!btf_type_is_ptr(t))
 +		return -EFAULT;
 +	t = btf_type_by_id(btf_vmlinux, t->type);
 +	if (!btf_type_is_func_proto(t))
 +		return -EFAULT;
 +
 +	args = (const struct btf_param *)(t + 1);
 +	if (arg >= btf_type_vlen(t)) {
 +		bpf_log(log, "bpf helper %s doesn't have %d-th argument\n",
 +			fnname, arg);
 +		return -EINVAL;
 +	}
 +
 +	t = btf_type_by_id(btf_vmlinux, args[arg].type);
 +	if (!btf_type_is_ptr(t) || !t->type) {
 +		/* anything but the pointer to struct is a helper config bug */
 +		bpf_log(log, "ARG_PTR_TO_BTF is misconfigured\n");
 +		return -EFAULT;
 +	}
 +	btf_id = t->type;
 +	t = btf_type_by_id(btf_vmlinux, t->type);
 +	/* skip modifiers */
 +	while (btf_type_is_modifier(t)) {
 +		btf_id = t->type;
 +		t = btf_type_by_id(btf_vmlinux, t->type);
 +	}
 +	if (!btf_type_is_struct(t)) {
 +		bpf_log(log, "ARG_PTR_TO_BTF is not a struct\n");
 +		return -EFAULT;
 +	}
 +	bpf_log(log, "helper %s arg%d has btf_id %d struct %s\n", fnname + 4,
 +		arg, btf_id, __btf_name_by_offset(btf_vmlinux, t->name_off));
 +	return btf_id;
 +}
 +
++=======
++>>>>>>> 138b9a0511c7 (bpf: Remove btf_id helpers resolving)
  int btf_resolve_helper_id(struct bpf_verifier_log *log,
  			  const struct bpf_func_proto *fn, int arg)
  {
* Unmerged path kernel/bpf/btf.c
