blk-mq: streamline handling of q->mq_ops->queue_rq result

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 7bf137298cb73afdb8c5536e474f7ba71ab1c235
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7bf13729.failed

Current handling of q->mq_ops->queue_rq result is a bit ugly:

- two branches which needs to 'continue' have to check if the
dispatch local list is empty, otherwise one bad request may
be retrieved via 'rq = list_first_entry(list, struct request, queuelist);'

- the branch of 'if (unlikely(ret != BLK_STS_OK))' isn't easy
to follow, since it is actually one error branch.

Streamline this handling, so the code becomes more readable, meantime
potential kernel oops can be avoided in case that the last request in
local dispatch list is failed.

Fixes: fc17b6534eb8 ("blk-mq: switch ->queue_rq return value to blk_status_t")
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
	Cc: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 7bf137298cb73afdb8c5536e474f7ba71ab1c235)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 51b640f2232f,89c83fa97ba0..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1277,20 -1380,37 +1277,40 @@@ bool blk_mq_dispatch_rq_list(struct req
  			bd.last = !blk_mq_get_driver_tag(nxt);
  		}
  
 -		/*
 -		 * once the request is queued to lld, no need to cover the
 -		 * budget any more
 -		 */
 -		if (nr_budgets)
 -			nr_budgets--;
  		ret = q->mq_ops->queue_rq(hctx, &bd);
- 		if (ret == BLK_STS_RESOURCE || ret == BLK_STS_DEV_RESOURCE) {
- 			blk_mq_handle_dev_resource(rq, list);
+ 		switch (ret) {
+ 		case BLK_STS_OK:
+ 			queued++;
  			break;
++<<<<<<< HEAD
 +		}
 +
 +		if (unlikely(ret != BLK_STS_OK)) {
++=======
+ 		case BLK_STS_RESOURCE:
+ 		case BLK_STS_DEV_RESOURCE:
+ 			blk_mq_handle_dev_resource(rq, list);
+ 			goto out;
+ 		case BLK_STS_ZONE_RESOURCE:
+ 			/*
+ 			 * Move the request to zone_list and keep going through
+ 			 * the dispatch list to find more requests the drive can
+ 			 * accept.
+ 			 */
+ 			blk_mq_handle_zone_resource(rq, &zone_list);
+ 			break;
+ 		default:
++>>>>>>> 7bf137298cb7 (blk-mq: streamline handling of q->mq_ops->queue_rq result)
  			errors++;
  			blk_mq_end_request(rq, BLK_STS_IOERR);
- 			continue;
  		}
- 
- 		queued++;
  	} while (!list_empty(list));
++<<<<<<< HEAD
++=======
+ out:
+ 	if (!list_empty(&zone_list))
+ 		list_splice_tail_init(&zone_list, list);
++>>>>>>> 7bf137298cb7 (blk-mq: streamline handling of q->mq_ops->queue_rq result)
  
  	hctx->dispatched[queued_to_index(queued)]++;
  
* Unmerged path block/blk-mq.c
