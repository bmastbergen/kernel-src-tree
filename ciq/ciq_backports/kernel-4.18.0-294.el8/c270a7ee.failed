mm: introduce FAULT_FLAG_INTERRUPTIBLE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Peter Xu <peterx@redhat.com>
commit c270a7eedcf278304e05ebd2c96807487c97db61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c270a7ee.failed

handle_userfaultfd() is currently the only one place in the kernel page
fault procedures that can respond to non-fatal userspace signals.  It was
trying to detect such an allowance by checking against USER & KILLABLE
flags, which was "un-official".

In this patch, we introduced a new flag (FAULT_FLAG_INTERRUPTIBLE) to show
that the fault handler allows the fault procedure to respond even to
non-fatal signals.  Meanwhile, add this new flag to the default fault
flags so that all the page fault handlers can benefit from the new flag.
With that, replacing the userfault check to this one.

Since the line is getting even longer, clean up the fault flags a bit too
to ease TTY users.

Although we've got a new flag and applied it, we shouldn't have any
functional change with this patch so far.

	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Peter Xu <peterx@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Brian Geffon <bgeffon@google.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Bobby Powers <bobbypowers@gmail.com>
	Cc: Denis Plotnikov <dplotnikov@virtuozzo.com>
	Cc: "Dr . David Alan Gilbert" <dgilbert@redhat.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Jerome Glisse <jglisse@redhat.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: "Kirill A . Shutemov" <kirill@shutemov.name>
	Cc: Martin Cracauer <cracauer@cons.org>
	Cc: Marty McFadden <mcfadden8@llnl.gov>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Maya Gokhale <gokhale2@llnl.gov>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Cc: Pavel Emelyanov <xemul@openvz.org>
Link: http://lkml.kernel.org/r/20200220195348.16302-1-peterx@redhat.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c270a7eedcf278304e05ebd2c96807487c97db61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm.h
diff --cc include/linux/mm.h
index ef77bd76b21c,7eeabc37ec87..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -324,16 -381,39 +324,42 @@@ extern unsigned int kobjsize(const voi
   */
  extern pgprot_t protection_map[16];
  
- #define FAULT_FLAG_WRITE	0x01	/* Fault was a write access */
- #define FAULT_FLAG_MKWRITE	0x02	/* Fault was mkwrite of existing pte */
- #define FAULT_FLAG_ALLOW_RETRY	0x04	/* Retry fault if blocking */
- #define FAULT_FLAG_RETRY_NOWAIT	0x08	/* Don't drop mmap_sem and wait when retrying */
- #define FAULT_FLAG_KILLABLE	0x10	/* The fault task is in SIGKILL killable region */
- #define FAULT_FLAG_TRIED	0x20	/* Second try */
- #define FAULT_FLAG_USER		0x40	/* The fault originated in userspace */
- #define FAULT_FLAG_REMOTE	0x80	/* faulting for non current tsk/mm */
- #define FAULT_FLAG_INSTRUCTION  0x100	/* The fault was during an instruction fetch */
+ /**
+  * Fault flag definitions.
+  *
+  * @FAULT_FLAG_WRITE: Fault was a write fault.
+  * @FAULT_FLAG_MKWRITE: Fault was mkwrite of existing PTE.
+  * @FAULT_FLAG_ALLOW_RETRY: Allow to retry the fault if blocked.
+  * @FAULT_FLAG_RETRY_NOWAIT: Don't drop mmap_sem and wait when retrying.
+  * @FAULT_FLAG_KILLABLE: The fault task is in SIGKILL killable region.
+  * @FAULT_FLAG_TRIED: The fault has been tried once.
+  * @FAULT_FLAG_USER: The fault originated in userspace.
+  * @FAULT_FLAG_REMOTE: The fault is not for current task/mm.
+  * @FAULT_FLAG_INSTRUCTION: The fault was during an instruction fetch.
+  * @FAULT_FLAG_INTERRUPTIBLE: The fault can be interrupted by non-fatal signals.
+  */
+ #define FAULT_FLAG_WRITE			0x01
+ #define FAULT_FLAG_MKWRITE			0x02
+ #define FAULT_FLAG_ALLOW_RETRY			0x04
+ #define FAULT_FLAG_RETRY_NOWAIT			0x08
+ #define FAULT_FLAG_KILLABLE			0x10
+ #define FAULT_FLAG_TRIED			0x20
+ #define FAULT_FLAG_USER				0x40
+ #define FAULT_FLAG_REMOTE			0x80
+ #define FAULT_FLAG_INSTRUCTION  		0x100
+ #define FAULT_FLAG_INTERRUPTIBLE		0x200
+ 
++<<<<<<< HEAD
++=======
+ /*
+  * The default fault flags that should be used by most of the
+  * arch-specific page fault handlers.
+  */
+ #define FAULT_FLAG_DEFAULT  (FAULT_FLAG_ALLOW_RETRY | \
+ 			     FAULT_FLAG_KILLABLE | \
+ 			     FAULT_FLAG_INTERRUPTIBLE)
  
++>>>>>>> c270a7eedcf2 (mm: introduce FAULT_FLAG_INTERRUPTIBLE)
  #define FAULT_FLAG_TRACE \
  	{ FAULT_FLAG_WRITE,		"WRITE" }, \
  	{ FAULT_FLAG_MKWRITE,		"MKWRITE" }, \
diff --git a/fs/userfaultfd.c b/fs/userfaultfd.c
index 42e45a455bd8..63618db405da 100644
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@ -453,9 +453,7 @@ vm_fault_t handle_userfault(struct vm_fault *vmf, unsigned long reason)
 	uwq.ctx = ctx;
 	uwq.waken = false;
 
-	return_to_userland =
-		(vmf->flags & (FAULT_FLAG_USER|FAULT_FLAG_KILLABLE)) ==
-		(FAULT_FLAG_USER|FAULT_FLAG_KILLABLE);
+	return_to_userland = vmf->flags & FAULT_FLAG_INTERRUPTIBLE;
 	blocking_state = return_to_userland ? TASK_INTERRUPTIBLE :
 			 TASK_KILLABLE;
 
* Unmerged path include/linux/mm.h
