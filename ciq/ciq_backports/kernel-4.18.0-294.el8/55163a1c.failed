hwmon: (k10temp) Add support for Zen3 CPUs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Wei Huang <wei.huang2@amd.com>
commit 55163a1c00fcb526e2aa9f7f952fb38d3543da5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/55163a1c.failed

Zen3 thermal info is supported via a new PCI device ID. Also the voltage
telemetry registers and the current factors need to be defined. k10temp
driver then searches for CPU family 0x19 and configures k10temp_data
accordingly.

	Signed-off-by: Wei Huang <wei.huang2@amd.com>
Link: https://lore.kernel.org/r/20200914200715.1997757-1-wei.huang2@amd.com
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
(cherry picked from commit 55163a1c00fcb526e2aa9f7f952fb38d3543da5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hwmon/k10temp.c
diff --cc drivers/hwmon/k10temp.c
index 54315afdf91d,a250481b5a97..000000000000
--- a/drivers/hwmon/k10temp.c
+++ b/drivers/hwmon/k10temp.c
@@@ -69,9 -72,36 +69,16 @@@ static DEFINE_MUTEX(nb_smu_ind_mutex)
  #define F15H_M60H_HARDWARE_TEMP_CTRL_OFFSET	0xd8200c64
  #define F15H_M60H_REPORTED_TEMP_CTRL_OFFSET	0xd8200ca4
  
 -/* Common for Zen CPU families (Family 17h and 18h) */
 -#define ZEN_REPORTED_TEMP_CTRL_OFFSET		0x00059800
 -
 -#define ZEN_CCD_TEMP(x)				(0x00059954 + ((x) * 4))
 -#define ZEN_CCD_TEMP_VALID			BIT(11)
 -#define ZEN_CCD_TEMP_MASK			GENMASK(10, 0)
 -
 -#define ZEN_CUR_TEMP_SHIFT			21
 -#define ZEN_CUR_TEMP_RANGE_SEL_MASK		BIT(19)
 -
 -#define ZEN_SVI_BASE				0x0005A000
 -
 -/* F17h thermal registers through SMN */
 -#define F17H_M01H_SVI_TEL_PLANE0		(ZEN_SVI_BASE + 0xc)
 -#define F17H_M01H_SVI_TEL_PLANE1		(ZEN_SVI_BASE + 0x10)
 -#define F17H_M31H_SVI_TEL_PLANE0		(ZEN_SVI_BASE + 0x14)
 -#define F17H_M31H_SVI_TEL_PLANE1		(ZEN_SVI_BASE + 0x10)
 -
 -#define F17H_M01H_CFACTOR_ICORE			1000000	/* 1A / LSB	*/
 -#define F17H_M01H_CFACTOR_ISOC			250000	/* 0.25A / LSB	*/
 -#define F17H_M31H_CFACTOR_ICORE			1000000	/* 1A / LSB	*/
 -#define F17H_M31H_CFACTOR_ISOC			310000	/* 0.31A / LSB	*/
 +/* F17h M01h Access througn SMN */
 +#define F17H_M01H_REPORTED_TEMP_CTRL_OFFSET	0x00059800
  
+ /* F19h thermal registers through SMN */
+ #define F19H_M01_SVI_TEL_PLANE0			(ZEN_SVI_BASE + 0x14)
+ #define F19H_M01_SVI_TEL_PLANE1			(ZEN_SVI_BASE + 0x10)
+ 
+ #define F19H_M01H_CFACTOR_ICORE			1000000	/* 1A / LSB	*/
+ #define F19H_M01H_CFACTOR_ISOC			310000	/* 0.31A / LSB	*/
+ 
  struct k10temp_data {
  	struct pci_dev *pdev;
  	void (*read_htcreg)(struct pci_dev *pdev, u32 *regval);
@@@ -321,15 -499,57 +328,62 @@@ static int k10temp_probe(struct pci_de
  		return -ENOMEM;
  
  	data->pdev = pdev;
 -	data->show_temp |= BIT(TCTL_BIT);	/* Always show Tctl */
  
 -	if (boot_cpu_data.x86 == 0x15 &&
 -	    ((boot_cpu_data.x86_model & 0xf0) == 0x60 ||
 -	     (boot_cpu_data.x86_model & 0xf0) == 0x70)) {
 +	if (boot_cpu_data.x86 == 0x15 && (boot_cpu_data.x86_model == 0x60 ||
 +					  boot_cpu_data.x86_model == 0x70)) {
  		data->read_htcreg = read_htcreg_nb_f15;
  		data->read_tempreg = read_tempreg_nb_f15;
++<<<<<<< HEAD
 +	} else if (boot_cpu_data.x86 == 0x17) {
 +		data->temp_adjust_mask = 0x80000;
 +		data->read_tempreg = read_tempreg_nb_f17;
 +		data->show_tdie = true;
++=======
+ 	} else if (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x18) {
+ 		data->temp_adjust_mask = ZEN_CUR_TEMP_RANGE_SEL_MASK;
+ 		data->read_tempreg = read_tempreg_nb_zen;
+ 		data->show_temp |= BIT(TDIE_BIT);	/* show Tdie */
+ 		data->is_zen = true;
+ 
+ 		switch (boot_cpu_data.x86_model) {
+ 		case 0x1:	/* Zen */
+ 		case 0x8:	/* Zen+ */
+ 		case 0x11:	/* Zen APU */
+ 		case 0x18:	/* Zen+ APU */
+ 			data->show_current = !is_threadripper() && !is_epyc();
+ 			data->svi_addr[0] = F17H_M01H_SVI_TEL_PLANE0;
+ 			data->svi_addr[1] = F17H_M01H_SVI_TEL_PLANE1;
+ 			data->cfactor[0] = F17H_M01H_CFACTOR_ICORE;
+ 			data->cfactor[1] = F17H_M01H_CFACTOR_ISOC;
+ 			k10temp_get_ccd_support(pdev, data, 4);
+ 			break;
+ 		case 0x31:	/* Zen2 Threadripper */
+ 		case 0x71:	/* Zen2 */
+ 			data->show_current = !is_threadripper() && !is_epyc();
+ 			data->cfactor[0] = F17H_M31H_CFACTOR_ICORE;
+ 			data->cfactor[1] = F17H_M31H_CFACTOR_ISOC;
+ 			data->svi_addr[0] = F17H_M31H_SVI_TEL_PLANE0;
+ 			data->svi_addr[1] = F17H_M31H_SVI_TEL_PLANE1;
+ 			k10temp_get_ccd_support(pdev, data, 8);
+ 			break;
+ 		}
+ 	} else if (boot_cpu_data.x86 == 0x19) {
+ 		data->temp_adjust_mask = ZEN_CUR_TEMP_RANGE_SEL_MASK;
+ 		data->read_tempreg = read_tempreg_nb_zen;
+ 		data->show_temp |= BIT(TDIE_BIT);
+ 		data->is_zen = true;
+ 
+ 		switch (boot_cpu_data.x86_model) {
+ 		case 0x0 ... 0x1:	/* Zen3 */
+ 			data->show_current = true;
+ 			data->svi_addr[0] = F19H_M01_SVI_TEL_PLANE0;
+ 			data->svi_addr[1] = F19H_M01_SVI_TEL_PLANE1;
+ 			data->cfactor[0] = F19H_M01H_CFACTOR_ICORE;
+ 			data->cfactor[1] = F19H_M01H_CFACTOR_ISOC;
+ 			k10temp_get_ccd_support(pdev, data, 8);
+ 			break;
+ 		}
++>>>>>>> 55163a1c00fc (hwmon: (k10temp) Add support for Zen3 CPUs)
  	} else {
  		data->read_htcreg = read_htcreg_pci;
  		data->read_tempreg = read_tempreg_pci;
@@@ -364,6 -585,10 +418,13 @@@ static const struct pci_device_id k10te
  	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },
  	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F3) },
  	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F3) },
++<<<<<<< HEAD
++=======
+ 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M60H_DF_F3) },
+ 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M70H_DF_F3) },
+ 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_19H_DF_F3) },
+ 	{ PCI_VDEVICE(HYGON, PCI_DEVICE_ID_AMD_17H_DF_F3) },
++>>>>>>> 55163a1c00fc (hwmon: (k10temp) Add support for Zen3 CPUs)
  	{}
  };
  MODULE_DEVICE_TABLE(pci, k10temp_id_table);
* Unmerged path drivers/hwmon/k10temp.c
