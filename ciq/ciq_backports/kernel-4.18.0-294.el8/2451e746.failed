driver core: Avoid deferred probe due to fw_devlink_pause/resume()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 2451e746478a6a6e981cfa66b62b791ca93b90c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2451e746.failed

With the earlier patch in this series, all devices that deferred probe
due to fw_devlink_pause() will have their probes delayed till the
deferred probe thread is kicked off during late_initcall. This will also
affect all their consumers.

This delayed probing in unnecessary. So this patch just keeps track of
the devices that had their probe deferred due to fw_devlink_pause() and
attempts to probe them once during fw_devlink_resume().

Fixes: 716a7a259690 ("driver core: fw_devlink: Add support for batching fwnode parsing")
	Signed-off-by: Saravana Kannan <saravanak@google.com>
	Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
Link: https://lore.kernel.org/r/20200701194259.3337652-4-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2451e746478a6a6e981cfa66b62b791ca93b90c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/device.h
diff --cc drivers/base/core.c
index 7ffd5023ca95,05d414e9e8a4..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -44,6 -45,14 +44,17 @@@ early_param("sysfs.deprecated", sysfs_d
  #endif
  
  /* Device links support. */
++<<<<<<< HEAD
++=======
+ static LIST_HEAD(wait_for_suppliers);
+ static DEFINE_MUTEX(wfs_lock);
+ static LIST_HEAD(deferred_sync);
+ static unsigned int defer_sync_state_count = 1;
+ static unsigned int defer_fw_devlink_count;
+ static LIST_HEAD(deferred_fw_devlink);
+ static DEFINE_MUTEX(defer_fw_devlink_lock);
+ static bool fw_devlink_is_permissive(void);
++>>>>>>> 2451e746478a (driver core: Avoid deferred probe due to fw_devlink_pause/resume())
  
  #ifdef CONFIG_SRCU
  static DEFINE_MUTEX(device_links_lock);
@@@ -936,6 -1214,139 +947,142 @@@ static bool fw_devlink_is_permissive(vo
  	return fw_devlink_flags == DL_FLAG_SYNC_STATE_ONLY;
  }
  
++<<<<<<< HEAD
++=======
+ static void fw_devlink_link_device(struct device *dev)
+ {
+ 	int fw_ret;
+ 
+ 	if (!fw_devlink_flags)
+ 		return;
+ 
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	if (!defer_fw_devlink_count)
+ 		device_link_add_missing_supplier_links();
+ 
+ 	/*
+ 	 * The device's fwnode not having add_links() doesn't affect if other
+ 	 * consumers can find this device as a supplier.  So, this check is
+ 	 * intentionally placed after device_link_add_missing_supplier_links().
+ 	 */
+ 	if (!fwnode_has_op(dev->fwnode, add_links))
+ 		goto out;
+ 
+ 	/*
+ 	 * If fw_devlink is being deferred, assume all devices have mandatory
+ 	 * suppliers they need to link to later. Then, when the fw_devlink is
+ 	 * resumed, all these devices will get a chance to try and link to any
+ 	 * suppliers they have.
+ 	 */
+ 	if (!defer_fw_devlink_count) {
+ 		fw_ret = fwnode_call_int_op(dev->fwnode, add_links, dev);
+ 		if (fw_ret == -ENODEV && fw_devlink_is_permissive())
+ 			fw_ret = -EAGAIN;
+ 	} else {
+ 		fw_ret = -ENODEV;
+ 		/*
+ 		 * defer_hook is not used to add device to deferred_sync list
+ 		 * until device is bound. Since deferred fw devlink also blocks
+ 		 * probing, same list hook can be used for deferred_fw_devlink.
+ 		 */
+ 		list_add_tail(&dev->links.defer_hook, &deferred_fw_devlink);
+ 	}
+ 
+ 	if (fw_ret == -ENODEV)
+ 		device_link_wait_for_mandatory_supplier(dev);
+ 	else if (fw_ret)
+ 		device_link_wait_for_optional_supplier(dev);
+ 
+ out:
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ }
+ 
+ /**
+  * fw_devlink_pause - Pause parsing of fwnode to create device links
+  *
+  * Calling this function defers any fwnode parsing to create device links until
+  * fw_devlink_resume() is called. Both these functions are ref counted and the
+  * caller needs to match the calls.
+  *
+  * While fw_devlink is paused:
+  * - Any device that is added won't have its fwnode parsed to create device
+  *   links.
+  * - The probe of the device will also be deferred during this period.
+  * - Any devices that were already added, but waiting for suppliers won't be
+  *   able to link to newly added devices.
+  *
+  * Once fw_devlink_resume():
+  * - All the fwnodes that was not parsed will be parsed.
+  * - All the devices that were deferred probing will be reattempted if they
+  *   aren't waiting for any more suppliers.
+  *
+  * This pair of functions, is mainly meant to optimize the parsing of fwnodes
+  * when a lot of devices that need to link to each other are added in a short
+  * interval of time. For example, adding all the top level devices in a system.
+  *
+  * For example, if N devices are added and:
+  * - All the consumers are added before their suppliers
+  * - All the suppliers of the N devices are part of the N devices
+  *
+  * Then:
+  *
+  * - With the use of fw_devlink_pause() and fw_devlink_resume(), each device
+  *   will only need one parsing of its fwnode because it is guaranteed to find
+  *   all the supplier devices already registered and ready to link to. It won't
+  *   have to do another pass later to find one or more suppliers it couldn't
+  *   find in the first parse of the fwnode. So, we'll only need O(N) fwnode
+  *   parses.
+  *
+  * - Without the use of fw_devlink_pause() and fw_devlink_resume(), we would
+  *   end up doing O(N^2) parses of fwnodes because every device that's added is
+  *   guaranteed to trigger a parse of the fwnode of every device added before
+  *   it. This O(N^2) parse is made worse by the fact that when a fwnode of a
+  *   device is parsed, all it descendant devices might need to have their
+  *   fwnodes parsed too (even if the devices themselves aren't added).
+  */
+ void fw_devlink_pause(void)
+ {
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	defer_fw_devlink_count++;
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ }
+ 
+ /** fw_devlink_resume - Resume parsing of fwnode to create device links
+  *
+  * This function is used in conjunction with fw_devlink_pause() and is ref
+  * counted. See documentation for fw_devlink_pause() for more details.
+  */
+ void fw_devlink_resume(void)
+ {
+ 	struct device *dev, *tmp;
+ 	LIST_HEAD(probe_list);
+ 
+ 	mutex_lock(&defer_fw_devlink_lock);
+ 	if (!defer_fw_devlink_count) {
+ 		WARN(true, "Unmatched fw_devlink pause/resume!");
+ 		goto out;
+ 	}
+ 
+ 	defer_fw_devlink_count--;
+ 	if (defer_fw_devlink_count)
+ 		goto out;
+ 
+ 	device_link_add_missing_supplier_links();
+ 	list_splice_tail_init(&deferred_fw_devlink, &probe_list);
+ out:
+ 	mutex_unlock(&defer_fw_devlink_lock);
+ 
+ 	/*
+ 	 * bus_probe_device() can cause new devices to get added and they'll
+ 	 * try to grab defer_fw_devlink_lock. So, this needs to be done outside
+ 	 * the defer_fw_devlink_lock.
+ 	 */
+ 	list_for_each_entry_safe(dev, tmp, &probe_list, links.defer_hook) {
+ 		list_del_init(&dev->links.defer_hook);
+ 		bus_probe_device(dev);
+ 	}
+ }
++>>>>>>> 2451e746478a (driver core: Avoid deferred probe due to fw_devlink_pause/resume())
  /* Device links support end. */
  
  int (*platform_notify)(struct device *dev) = NULL;
diff --cc include/linux/device.h
index 8ea0baac3c21,5efed864b387..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -1037,6 -432,11 +1037,14 @@@ enum dl_dev_state 
   * struct dev_links_info - Device data related to device links.
   * @suppliers: List of links to supplier devices.
   * @consumers: List of links to consumer devices.
++<<<<<<< HEAD
++=======
+  * @needs_suppliers: Hook to global list of devices waiting for suppliers.
+  * @defer_hook: Hook to global list of devices that have deferred sync_state or
+  *		deferred fw_devlink.
+  * @need_for_probe: If needs_suppliers is on a list, this indicates if the
+  *		    suppliers are needed for probe or not.
++>>>>>>> 2451e746478a (driver core: Avoid deferred probe due to fw_devlink_pause/resume())
   * @status: Driver status information.
   */
  struct dev_links_info {
* Unmerged path drivers/base/core.c
* Unmerged path include/linux/device.h
