RDMA/mlx5: Set QP subtype immediately when it is known

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit 318d2b06fbaa8fbce379a4e00901251b6368b4e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/318d2b06.failed

There is no need to delay QP subtype assignment to the end of the
create_qp() function and it is better to move it to be immediately
after it is checked so we would be able to rewrite later checks
to be based on it and not on over-written struct ib_qp_init_attr.

Link: https://lore.kernel.org/r/20200427154636.381474-7-leon@kernel.org
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 318d2b06fbaa8fbce379a4e00901251b6368b4e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 9f87b08d533e,d991c33c4d9b..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -2615,19 -2575,12 +2615,18 @@@ static struct ib_qp *mlx5_ib_create_dct
  	if (err)
  		return ERR_PTR(err);
  
 -	qp->dct.in = kzalloc(MLX5_ST_SZ_BYTES(create_dct_in), GFP_KERNEL);
 -	if (!qp->dct.in)
 +	qp = kzalloc(sizeof(*qp), GFP_KERNEL);
 +	if (!qp)
  		return ERR_PTR(-ENOMEM);
  
 +	qp->dct.in = kzalloc(MLX5_ST_SZ_BYTES(create_dct_in), GFP_KERNEL);
 +	if (!qp->dct.in) {
 +		err = -ENOMEM;
 +		goto err_free;
 +	}
 +
  	MLX5_SET(create_dct_in, qp->dct.in, uid, to_mpd(pd)->uid);
  	dctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);
- 	qp->qp_sub_type = MLX5_IB_QPT_DCT;
  	MLX5_SET(dctc, dctc, pd, to_mpd(pd)->pdn);
  	MLX5_SET(dctc, dctc, srqn_xrqn, to_msrq(attr->srq)->msrq.srqn);
  	MLX5_SET(dctc, dctc, cqn, to_mcq(attr->recv_cq)->mcq.cqn);
@@@ -2732,79 -2761,40 +2731,97 @@@ struct ib_qp *mlx5_ib_create_qp(struct 
  			if (init_attr->cap.max_recv_wr ||
  			    init_attr->cap.max_recv_sge) {
  				mlx5_ib_dbg(dev, "DCI QP requires zero size receive queue\n");
 -				err = -EINVAL;
 -				goto free_qp;
 +				return ERR_PTR(-EINVAL);
  			}
+ 			qp->qp_sub_type = MLX5_IB_QPT_DCI;
  		} else {
++<<<<<<< HEAD
 +			return mlx5_ib_create_dct(pd, init_attr, &ucmd, udata);
++=======
+ 			qp->qp_sub_type = MLX5_IB_QPT_DCT;
+ 			return mlx5_ib_create_dct(pd, qp, init_attr, &ucmd,
+ 						  udata);
++>>>>>>> 318d2b06fbaa (RDMA/mlx5: Set QP subtype immediately when it is known)
  		}
  	}
  
 -	if (init_attr->qp_type == IB_QPT_XRC_TGT)
 -		xrcdn = to_mxrcd(init_attr->xrcd)->xrcdn;
 +	switch (init_attr->qp_type) {
 +	case IB_QPT_XRC_TGT:
 +	case IB_QPT_XRC_INI:
 +		if (!MLX5_CAP_GEN(dev->mdev, xrc)) {
 +			mlx5_ib_dbg(dev, "XRC not supported\n");
 +			return ERR_PTR(-ENOSYS);
 +		}
 +		init_attr->recv_cq = NULL;
 +		if (init_attr->qp_type == IB_QPT_XRC_TGT) {
 +			xrcdn = to_mxrcd(init_attr->xrcd)->xrcdn;
 +			init_attr->send_cq = NULL;
 +		}
  
 -	err = create_qp_common(dev, pd, init_attr, udata, qp);
 -	if (err) {
 -		mlx5_ib_dbg(dev, "create_qp_common failed\n");
 -		goto free_qp;
 +		/* fall through */
 +	case IB_QPT_RAW_PACKET:
 +	case IB_QPT_RC:
 +	case IB_QPT_UC:
 +	case IB_QPT_UD:
 +	case IB_QPT_SMI:
 +	case MLX5_IB_QPT_HW_GSI:
 +	case MLX5_IB_QPT_REG_UMR:
 +	case MLX5_IB_QPT_DCI:
 +		qp = kzalloc(sizeof(*qp), GFP_KERNEL);
 +		if (!qp)
 +			return ERR_PTR(-ENOMEM);
 +
 +		err = create_qp_common(dev, pd, init_attr, udata, qp);
 +		if (err) {
 +			mlx5_ib_dbg(dev, "create_qp_common failed\n");
 +			kfree(qp);
 +			return ERR_PTR(err);
 +		}
 +
 +		if (is_qp0(init_attr->qp_type))
 +			qp->ibqp.qp_num = 0;
 +		else if (is_qp1(init_attr->qp_type))
 +			qp->ibqp.qp_num = 1;
 +		else
 +			qp->ibqp.qp_num = qp->trans_qp.base.mqp.qpn;
 +
 +		mlx5_ib_dbg(dev, "ib qpnum 0x%x, mlx qpn 0x%x, rcqn 0x%x, scqn 0x%x\n",
 +			    qp->ibqp.qp_num, qp->trans_qp.base.mqp.qpn,
 +			    init_attr->recv_cq ? to_mcq(init_attr->recv_cq)->mcq.cqn : -1,
 +			    init_attr->send_cq ? to_mcq(init_attr->send_cq)->mcq.cqn : -1);
 +
 +		qp->trans_qp.xrcdn = xrcdn;
 +
 +		break;
 +
 +	case IB_QPT_GSI:
 +		return mlx5_ib_gsi_create_qp(pd, init_attr);
 +
 +	case IB_QPT_RAW_IPV6:
 +	case IB_QPT_RAW_ETHERTYPE:
 +	case IB_QPT_MAX:
 +	default:
 +		mlx5_ib_dbg(dev, "unsupported qp type %d\n",
 +			    init_attr->qp_type);
 +		/* Don't support raw QPs */
 +		return ERR_PTR(-EINVAL);
  	}
  
++<<<<<<< HEAD
 +	if (verbs_init_attr->qp_type == IB_QPT_DRIVER)
 +		qp->qp_sub_type = init_attr->qp_type;
++=======
+ 	if (is_qp0(init_attr->qp_type))
+ 		qp->ibqp.qp_num = 0;
+ 	else if (is_qp1(init_attr->qp_type))
+ 		qp->ibqp.qp_num = 1;
+ 	else
+ 		qp->ibqp.qp_num = qp->trans_qp.base.mqp.qpn;
+ 
+ 	qp->trans_qp.xrcdn = xrcdn;
++>>>>>>> 318d2b06fbaa (RDMA/mlx5: Set QP subtype immediately when it is known)
  
  	return &qp->ibqp;
 -
 -free_qp:
 -	kfree(qp);
 -	return ERR_PTR(err);
  }
  
  static int mlx5_ib_destroy_dct(struct mlx5_ib_qp *mqp)
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
