vfs: teach vfs_ioc_fssetxattr_check to check project id info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit f991492ed11055934f1b35615cb1b435325939bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f991492e.failed

Standardize the project id checks for FSSETXATTR.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
(cherry picked from commit f991492ed11055934f1b35615cb1b435325939bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/ioctl.c
#	fs/inode.c
diff --cc fs/ext4/ioctl.c
index 2a2ed4dff93b,566dfac28b3f..000000000000
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@@ -723,28 -697,15 +723,40 @@@ group_add_out
  	return err;
  }
  
++<<<<<<< HEAD
 +static int ext4_ioctl_check_project(struct inode *inode, struct fsxattr *fa)
 +{
 +	/*
 +	 * Project Quota ID state is only allowed to change from within the init
 +	 * namespace. Enforce that restriction only if we are trying to change
 +	 * the quota ID state. Everything else is allowed in user namespaces.
 +	 */
 +	if (current_user_ns() == &init_user_ns)
 +		return 0;
 +
 +	if (__kprojid_val(EXT4_I(inode)->i_projid) != fa->fsx_projid)
 +		return -EINVAL;
 +
 +	if (ext4_test_inode_flag(inode, EXT4_INODE_PROJINHERIT)) {
 +		if (!(fa->fsx_xflags & FS_XFLAG_PROJINHERIT))
 +			return -EINVAL;
 +	} else {
 +		if (fa->fsx_xflags & FS_XFLAG_PROJINHERIT)
 +			return -EINVAL;
 +	}
 +
 +	return 0;
++=======
+ static void ext4_fill_fsxattr(struct inode *inode, struct fsxattr *fa)
+ {
+ 	struct ext4_inode_info *ei = EXT4_I(inode);
+ 
+ 	simple_fill_fsxattr(fa, ext4_iflags_to_xflags(ei->i_flags &
+ 						      EXT4_FL_USER_VISIBLE));
+ 
+ 	if (ext4_has_feature_project(inode->i_sb))
+ 		fa->fsx_projid = from_kprojid(&init_user_ns, ei->i_projid);
++>>>>>>> f991492ed110 (vfs: teach vfs_ioc_fssetxattr_check to check project id info)
  }
  
  long ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
@@@ -1157,7 -1108,8 +1169,12 @@@ resizefs_out
  			return err;
  
  		inode_lock(inode);
++<<<<<<< HEAD
 +		err = ext4_ioctl_check_project(inode, &fa);
++=======
+ 		ext4_fill_fsxattr(inode, &old_fa);
+ 		err = vfs_ioc_fssetxattr_check(inode, &old_fa, &fa);
++>>>>>>> f991492ed110 (vfs: teach vfs_ioc_fssetxattr_check to check project id info)
  		if (err)
  			goto out;
  		flags = (ei->i_flags & ~EXT4_FL_XFLAG_VISIBLE) |
diff --cc fs/inode.c
index ad98bee52a46,30b720cffd9c..000000000000
--- a/fs/inode.c
+++ b/fs/inode.c
@@@ -2214,6 -2167,66 +2214,69 @@@ struct timespec64 current_time(struct i
  		return now;
  	}
  
 -	return timespec64_trunc(now, inode->i_sb->s_time_gran);
 +	return timestamp_truncate(now, inode);
  }
  EXPORT_SYMBOL(current_time);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Generic function to check FS_IOC_SETFLAGS values and reject any invalid
+  * configurations.
+  *
+  * Note: the caller should be holding i_mutex, or else be sure that they have
+  * exclusive access to the inode structure.
+  */
+ int vfs_ioc_setflags_prepare(struct inode *inode, unsigned int oldflags,
+ 			     unsigned int flags)
+ {
+ 	/*
+ 	 * The IMMUTABLE and APPEND_ONLY flags can only be changed by
+ 	 * the relevant capability.
+ 	 *
+ 	 * This test looks nicer. Thanks to Pauline Middelink
+ 	 */
+ 	if ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL) &&
+ 	    !capable(CAP_LINUX_IMMUTABLE))
+ 		return -EPERM;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(vfs_ioc_setflags_prepare);
+ 
+ /*
+  * Generic function to check FS_IOC_FSSETXATTR values and reject any invalid
+  * configurations.
+  *
+  * Note: the caller should be holding i_mutex, or else be sure that they have
+  * exclusive access to the inode structure.
+  */
+ int vfs_ioc_fssetxattr_check(struct inode *inode, const struct fsxattr *old_fa,
+ 			     struct fsxattr *fa)
+ {
+ 	/*
+ 	 * Can't modify an immutable/append-only file unless we have
+ 	 * appropriate permission.
+ 	 */
+ 	if ((old_fa->fsx_xflags ^ fa->fsx_xflags) &
+ 			(FS_XFLAG_IMMUTABLE | FS_XFLAG_APPEND) &&
+ 	    !capable(CAP_LINUX_IMMUTABLE))
+ 		return -EPERM;
+ 
+ 	/*
+ 	 * Project Quota ID state is only allowed to change from within the init
+ 	 * namespace. Enforce that restriction only if we are trying to change
+ 	 * the quota ID state. Everything else is allowed in user namespaces.
+ 	 */
+ 	if (current_user_ns() != &init_user_ns) {
+ 		if (old_fa->fsx_projid != fa->fsx_projid)
+ 			return -EINVAL;
+ 		if ((old_fa->fsx_xflags ^ fa->fsx_xflags) &
+ 				FS_XFLAG_PROJINHERIT)
+ 			return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(vfs_ioc_fssetxattr_check);
++>>>>>>> f991492ed110 (vfs: teach vfs_ioc_fssetxattr_check to check project id info)
* Unmerged path fs/ext4/ioctl.c
* Unmerged path fs/inode.c
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 44d791730753..748136f7e309 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -1485,21 +1485,6 @@ xfs_ioctl_setattr_check_projid(
 	if (fa->fsx_projid > (uint16_t)-1 &&
 	    !xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))
 		return -EINVAL;
-
-	/*
-	 * Project Quota ID state is only allowed to change from within the init
-	 * namespace. Enforce that restriction only if we are trying to change
-	 * the quota ID state. Everything else is allowed in user namespaces.
-	 */
-	if (current_user_ns() == &init_user_ns)
-		return 0;
-
-	if (xfs_get_projid(ip) != fa->fsx_projid)
-		return -EINVAL;
-	if ((fa->fsx_xflags & FS_XFLAG_PROJINHERIT) !=
-	    (ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT))
-		return -EINVAL;
-
 	return 0;
 }
 
