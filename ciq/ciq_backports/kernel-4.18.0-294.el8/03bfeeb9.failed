KVM: SVM: Change intercept_cr to generic intercepts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Babu Moger <babu.moger@amd.com>
commit 03bfeeb988a970995479eb6d108c398027ab7525
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/03bfeeb9.failed

Change intercept_cr to generic intercepts in vmcb_control_area.
Use the new vmcb_set_intercept, vmcb_clr_intercept and vmcb_is_intercept
where applicable.

	Signed-off-by: Babu Moger <babu.moger@amd.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
Message-Id: <159985248506.11252.9081085950784508671.stgit@bmoger-ubuntu>
[Change constant names. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 03bfeeb988a970995479eb6d108c398027ab7525)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/svm.h
#	arch/x86/kvm/svm/nested.c
diff --cc arch/x86/include/asm/svm.h
index acac55d6f941,20b63418ae36..000000000000
--- a/arch/x86/include/asm/svm.h
+++ b/arch/x86/include/asm/svm.h
@@@ -4,6 -4,27 +4,30 @@@
  
  #include <uapi/asm/svm.h>
  
++<<<<<<< HEAD
++=======
+ /*
+  * 32-bit intercept words in the VMCB Control Area, starting
+  * at Byte offset 000h.
+  */
+ 
+ enum intercept_words {
+ 	INTERCEPT_CR = 0,
+ 	MAX_INTERCEPT,
+ };
++>>>>>>> 03bfeeb988a9 (KVM: SVM: Change intercept_cr to generic intercepts)
+ 
+ enum {
+ 	/* Byte offset 000h (word 0) */
+ 	INTERCEPT_CR0_READ = 0,
+ 	INTERCEPT_CR3_READ = 3,
+ 	INTERCEPT_CR4_READ = 4,
+ 	INTERCEPT_CR8_READ = 8,
+ 	INTERCEPT_CR0_WRITE = 16,
+ 	INTERCEPT_CR3_WRITE = 16 + 3,
+ 	INTERCEPT_CR4_WRITE = 16 + 4,
+ 	INTERCEPT_CR8_WRITE = 16 + 8,
+ };
  
  enum {
  	INTERCEPT_INTR,
@@@ -57,7 -78,7 +81,11 @@@
  
  
  struct __attribute__ ((__packed__)) vmcb_control_area {
++<<<<<<< HEAD
 +	u32 intercept_cr;
++=======
+ 	u32 intercepts[MAX_INTERCEPT];
++>>>>>>> 03bfeeb988a9 (KVM: SVM: Change intercept_cr to generic intercepts)
  	u32 intercept_dr;
  	u32 intercept_exceptions;
  	u64 intercept;
diff --cc arch/x86/kvm/svm/nested.c
index 3a222ac541d6,4a7fcc6d312c..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -108,9 -109,9 +108,8 @@@ void recalc_intercepts(struct vcpu_svm 
  	h = &svm->nested.hsave->control;
  	g = &svm->nested.ctl;
  
 -	for (i = 0; i < MAX_INTERCEPT; i++)
 -		c->intercepts[i] = h->intercepts[i];
 +	svm->nested.host_intercept_exceptions = h->intercept_exceptions;
  
- 	c->intercept_cr = h->intercept_cr;
  	c->intercept_dr = h->intercept_dr;
  	c->intercept_exceptions = h->intercept_exceptions;
  	c->intercept = h->intercept;
@@@ -131,7 -132,9 +130,13 @@@
  	/* We don't want to see VMMCALLs from a nested guest */
  	c->intercept &= ~(1ULL << INTERCEPT_VMMCALL);
  
++<<<<<<< HEAD
 +	c->intercept_cr |= g->intercept_cr;
++=======
+ 	for (i = 0; i < MAX_INTERCEPT; i++)
+ 		c->intercepts[i] |= g->intercepts[i];
+ 
++>>>>>>> 03bfeeb988a9 (KVM: SVM: Change intercept_cr to generic intercepts)
  	c->intercept_dr |= g->intercept_dr;
  	c->intercept_exceptions |= g->intercept_exceptions;
  	c->intercept |= g->intercept;
@@@ -140,7 -143,11 +145,15 @@@
  static void copy_vmcb_control_area(struct vmcb_control_area *dst,
  				   struct vmcb_control_area *from)
  {
++<<<<<<< HEAD
 +	dst->intercept_cr         = from->intercept_cr;
++=======
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < MAX_INTERCEPT; i++)
+ 		dst->intercepts[i] = from->intercepts[i];
+ 
++>>>>>>> 03bfeeb988a9 (KVM: SVM: Change intercept_cr to generic intercepts)
  	dst->intercept_dr         = from->intercept_dr;
  	dst->intercept_exceptions = from->intercept_exceptions;
  	dst->intercept            = from->intercept;
@@@ -459,16 -486,16 +472,23 @@@ int nested_svm_vmrun(struct vcpu_svm *s
  		goto out;
  	}
  
 -	trace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb12_gpa,
 -			       vmcb12->save.rip,
 -			       vmcb12->control.int_ctl,
 -			       vmcb12->control.event_inj,
 -			       vmcb12->control.nested_ctl);
 -
 +	trace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,
 +			       nested_vmcb->save.rip,
 +			       nested_vmcb->control.int_ctl,
 +			       nested_vmcb->control.event_inj,
 +			       nested_vmcb->control.nested_ctl);
 +
++<<<<<<< HEAD
 +	trace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,
 +				    nested_vmcb->control.intercept_cr >> 16,
 +				    nested_vmcb->control.intercept_exceptions,
 +				    nested_vmcb->control.intercept);
++=======
+ 	trace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,
+ 				    vmcb12->control.intercepts[INTERCEPT_CR] >> 16,
+ 				    vmcb12->control.intercept_exceptions,
+ 				    vmcb12->control.intercept);
++>>>>>>> 03bfeeb988a9 (KVM: SVM: Change intercept_cr to generic intercepts)
  
  	/* Clear internal status */
  	kvm_clear_exception_queue(&svm->vcpu);
* Unmerged path arch/x86/include/asm/svm.h
* Unmerged path arch/x86/kvm/svm/nested.c
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index ffcc287ce9b5..8c8bd84be1ff 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -2806,8 +2806,8 @@ static void dump_vmcb(struct kvm_vcpu *vcpu)
 	}
 
 	pr_err("VMCB Control Area:\n");
-	pr_err("%-20s%04x\n", "cr_read:", control->intercept_cr & 0xffff);
-	pr_err("%-20s%04x\n", "cr_write:", control->intercept_cr >> 16);
+	pr_err("%-20s%04x\n", "cr_read:", control->intercepts[INTERCEPT_CR] & 0xffff);
+	pr_err("%-20s%04x\n", "cr_write:", control->intercepts[INTERCEPT_CR] >> 16);
 	pr_err("%-20s%04x\n", "dr_read:", control->intercept_dr & 0xffff);
 	pr_err("%-20s%04x\n", "dr_write:", control->intercept_dr >> 16);
 	pr_err("%-20s%08x\n", "exceptions:", control->intercept_exceptions);
diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.h
index 7e2440454c08..b2b55c3e00f0 100644
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@ -221,7 +221,7 @@ static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)
 {
 	struct vmcb *vmcb = get_host_vmcb(svm);
 
-	vmcb->control.intercept_cr |= (1U << bit);
+	vmcb_set_intercept(&vmcb->control, bit);
 
 	recalc_intercepts(svm);
 }
@@ -230,7 +230,7 @@ static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)
 {
 	struct vmcb *vmcb = get_host_vmcb(svm);
 
-	vmcb->control.intercept_cr &= ~(1U << bit);
+	vmcb_clr_intercept(&vmcb->control, bit);
 
 	recalc_intercepts(svm);
 }
@@ -239,7 +239,7 @@ static inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)
 {
 	struct vmcb *vmcb = get_host_vmcb(svm);
 
-	return vmcb->control.intercept_cr & (1U << bit);
+	return vmcb_is_intercept(&vmcb->control, bit);
 }
 
 static inline void set_dr_intercepts(struct vcpu_svm *svm)
