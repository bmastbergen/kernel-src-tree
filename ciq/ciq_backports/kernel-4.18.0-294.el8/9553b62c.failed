net: atlantic: Use readx_poll_timeout() for large timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sebastian Andrzej Siewior <bigeasy@linutronix.de>
commit 9553b62c1dd27df67ab2f52ec8a3bc3501887619
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9553b62c.failed

Commit
   8dcf2ad39fdb2 ("net: atlantic: add hwmon getter for MAC temperature")

implemented a read callback with an udelay(10000U). This fails to
compile on ARM because the delay is >1ms. I doubt that it is needed to
spin for 10ms even if possible on x86.

>From looking at the code, the context appears to be preemptible so using
usleep() should work and avoid busy spinning.

Use readx_poll_timeout() in the poll loop.

Fixes: 8dcf2ad39fdb2 ("net: atlantic: add hwmon getter for MAC temperature")
	Cc: Mark Starovoytov <mstarovoitov@marvell.com>
	Cc: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
	Acked-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9553b62c1dd27df67ab2f52ec8a3bc3501887619)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index b7e5ce0d7af5,8941ac4df9e3..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -1114,6 -1580,73 +1114,76 @@@ static int hw_atl_b0_hw_vlan_ctrl(struc
  	return aq_hw_err_from_flags(self);
  }
  
++<<<<<<< HEAD
++=======
+ int hw_atl_b0_set_loopback(struct aq_hw_s *self, u32 mode, bool enable)
+ {
+ 	switch (mode) {
+ 	case AQ_HW_LOOPBACK_DMA_SYS:
+ 		hw_atl_tpb_tx_dma_sys_lbk_en_set(self, enable);
+ 		hw_atl_rpb_dma_sys_lbk_set(self, enable);
+ 		break;
+ 	case AQ_HW_LOOPBACK_PKT_SYS:
+ 		hw_atl_tpo_tx_pkt_sys_lbk_en_set(self, enable);
+ 		hw_atl_rpf_tpo_to_rpf_sys_lbk_set(self, enable);
+ 		break;
+ 	case AQ_HW_LOOPBACK_DMA_NET:
+ 		hw_atl_rpf_vlan_prom_mode_en_set(self, enable);
+ 		hw_atl_rpfl2promiscuous_mode_en_set(self, enable);
+ 		hw_atl_tpb_tx_tx_clk_gate_en_set(self, !enable);
+ 		hw_atl_tpb_tx_dma_net_lbk_en_set(self, enable);
+ 		hw_atl_rpb_dma_net_lbk_set(self, enable);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 hw_atl_b0_ts_ready_and_latch_high_get(struct aq_hw_s *self)
+ {
+ 	if (hw_atl_ts_ready_get(self) && hw_atl_ts_ready_latch_high_get(self))
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ static int hw_atl_b0_get_mac_temp(struct aq_hw_s *self, u32 *temp)
+ {
+ 	bool ts_disabled;
+ 	int err;
+ 	u32 val;
+ 	u32 ts;
+ 
+ 	ts_disabled = (hw_atl_ts_power_down_get(self) == 1U);
+ 
+ 	if (ts_disabled) {
+ 		// Set AFE Temperature Sensor to on (off by default)
+ 		hw_atl_ts_power_down_set(self, 0U);
+ 
+ 		// Reset internal capacitors, biasing, and counters
+ 		hw_atl_ts_reset_set(self, 1);
+ 		hw_atl_ts_reset_set(self, 0);
+ 	}
+ 
+ 	err = readx_poll_timeout(hw_atl_b0_ts_ready_and_latch_high_get, self,
+ 				 val, val == 1, 10000U, 500000U);
+ 	if (err)
+ 		return err;
+ 
+ 	ts = hw_atl_ts_data_get(self);
+ 	*temp = ts * ts * 16 / 100000 + 60 * ts - 83410;
+ 
+ 	if (ts_disabled) {
+ 		// Set AFE Temperature Sensor back to off
+ 		hw_atl_ts_power_down_set(self, 1U);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 9553b62c1dd2 (net: atlantic: Use readx_poll_timeout() for large timeout)
  const struct aq_hw_ops hw_atl_ops_b0 = {
  	.hw_soft_reset        = hw_atl_utils_soft_reset,
  	.hw_prepare           = hw_atl_utils_initfw,
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
