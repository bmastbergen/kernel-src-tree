qed: add support for the extended speed and FEC modes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Alexander Lobakin <alobakin@marvell.com>
commit 99785a87fc7d27207c7dca0f0fe04386f1981690
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/99785a87.failed

Add all necessary code (NVM parsing, MFW and Ethtool reports etc.) to
support extended speed and FEC modes.
These new modes are supported by the new boards revisions and newer
MFW versions.

Misc: correct port type for MEDIA_KR.

	Signed-off-by: Alexander Lobakin <alobakin@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 99785a87fc7d27207c7dca0f0fe04386f1981690)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed.h
#	drivers/net/ethernet/qlogic/qed/qed_dev.c
#	drivers/net/ethernet/qlogic/qed/qed_hsi.h
#	drivers/net/ethernet/qlogic/qed/qed_main.c
#	drivers/net/ethernet/qlogic/qed/qed_mcp.c
#	drivers/net/ethernet/qlogic/qed/qed_mcp.h
diff --cc drivers/net/ethernet/qlogic/qed/qed.h
index 8a4130a026f8,b2a7b53ee760..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed.h
+++ b/drivers/net/ethernet/qlogic/qed/qed.h
@@@ -700,41 -701,42 +700,52 @@@ struct qed_dbg_feature 
  };
  
  struct qed_dev {
 -	u32				dp_module;
 -	u8				dp_level;
 -	char				name[NAME_SIZE];
 -
 +	u32	dp_module;
 +	u8	dp_level;
 +	char	name[NAME_SIZE];
 +
++<<<<<<< HEAD
 +	enum	qed_dev_type type;
 +/* Translate type/revision combo into the proper conditions */
 +#define QED_IS_BB(dev)  ((dev)->type == QED_DEV_TYPE_BB)
 +#define QED_IS_BB_B0(dev)       (QED_IS_BB(dev) && \
 +				 CHIP_REV_IS_B0(dev))
 +#define QED_IS_AH(dev)  ((dev)->type == QED_DEV_TYPE_AH)
 +#define QED_IS_K2(dev)  QED_IS_AH(dev)
++=======
+ 	enum qed_dev_type		type;
+ 	/* Translate type/revision combo into the proper conditions */
+ #define QED_IS_BB(dev)			((dev)->type == QED_DEV_TYPE_BB)
+ #define QED_IS_BB_B0(dev)		(QED_IS_BB(dev) && CHIP_REV_IS_B0(dev))
+ #define QED_IS_AH(dev)			((dev)->type == QED_DEV_TYPE_AH)
+ #define QED_IS_K2(dev)			QED_IS_AH(dev)
+ #define QED_IS_E4(dev)			(QED_IS_BB(dev) || QED_IS_AH(dev))
+ #define QED_IS_E5(dev)			((dev)->type == QED_DEV_TYPE_E5)
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  
 -	u16				vendor_id;
 -
 -	u16				device_id;
 -#define QED_DEV_ID_MASK			0xff00
 -#define QED_DEV_ID_MASK_BB		0x1600
 -#define QED_DEV_ID_MASK_AH		0x8000
 +	u16	vendor_id;
 +	u16	device_id;
 +#define QED_DEV_ID_MASK		0xff00
 +#define QED_DEV_ID_MASK_BB	0x1600
 +#define QED_DEV_ID_MASK_AH	0x8000
 +#define QED_IS_E4(dev)  (QED_IS_BB(dev) || QED_IS_AH(dev))
  
 -	u16				chip_num;
 -#define CHIP_NUM_MASK			0xffff
 -#define CHIP_NUM_SHIFT			16
 +	u16	chip_num;
 +#define CHIP_NUM_MASK                   0xffff
 +#define CHIP_NUM_SHIFT                  16
  
 -	u16				chip_rev;
 -#define CHIP_REV_MASK			0xf
 -#define CHIP_REV_SHIFT			12
 -#define CHIP_REV_IS_B0(_cdev)		((_cdev)->chip_rev == 1)
 +	u16	chip_rev;
 +#define CHIP_REV_MASK                   0xf
 +#define CHIP_REV_SHIFT                  12
 +#define CHIP_REV_IS_B0(_cdev)   ((_cdev)->chip_rev == 1)
  
  	u16				chip_metal;
 -#define CHIP_METAL_MASK			0xff
 -#define CHIP_METAL_SHIFT		4
 +#define CHIP_METAL_MASK                 0xff
 +#define CHIP_METAL_SHIFT                4
  
  	u16				chip_bond_id;
 -#define CHIP_BOND_ID_MASK		0xf
 -#define CHIP_BOND_ID_SHIFT		0
 +#define CHIP_BOND_ID_MASK               0xf
 +#define CHIP_BOND_ID_SHIFT              0
  
  	u8				num_engines;
  	u8				num_ports;
diff --cc drivers/net/ethernet/qlogic/qed/qed_dev.c
index 06a21c37219c,6516a1f921da..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@@ -3968,8 -3968,9 +3968,13 @@@ unlock_and_exit
  
  static int qed_hw_get_nvm_info(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
  {
++<<<<<<< HEAD
 +	u32 port_cfg_addr, link_temp, nvm_cfg_addr, device_capabilities;
++=======
+ 	u32 port_cfg_addr, link_temp, nvm_cfg_addr, device_capabilities, fld;
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  	u32 nvm_cfg1_offset, mf_mode, addr, generic_cont0, core_cfg;
+ 	struct qed_mcp_link_speed_params *ext_speed;
  	struct qed_mcp_link_capabilities *p_caps;
  	struct qed_mcp_link_params *link;
  
@@@ -4057,19 -4062,40 +4061,25 @@@
  		DP_NOTICE(p_hwfn, "Unknown Speed in 0x%08x\n", link_temp);
  	}
  
- 	p_hwfn->mcp_info->link_capabilities.default_speed_autoneg =
- 		link->speed.autoneg;
+ 	p_caps->default_speed_autoneg = link->speed.autoneg;
  
++<<<<<<< HEAD
 +	link_temp &= NVM_CFG1_PORT_DRV_FLOW_CONTROL_MASK;
 +	link_temp >>= NVM_CFG1_PORT_DRV_FLOW_CONTROL_OFFSET;
 +	link->pause.autoneg = !!(link_temp &
 +				 NVM_CFG1_PORT_DRV_FLOW_CONTROL_AUTONEG);
 +	link->pause.forced_rx = !!(link_temp &
 +				   NVM_CFG1_PORT_DRV_FLOW_CONTROL_RX);
 +	link->pause.forced_tx = !!(link_temp &
 +				   NVM_CFG1_PORT_DRV_FLOW_CONTROL_TX);
++=======
+ 	fld = GET_MFW_FIELD(link_temp, NVM_CFG1_PORT_DRV_FLOW_CONTROL);
+ 	link->pause.autoneg = !!(fld & NVM_CFG1_PORT_DRV_FLOW_CONTROL_AUTONEG);
+ 	link->pause.forced_rx = !!(fld & NVM_CFG1_PORT_DRV_FLOW_CONTROL_RX);
+ 	link->pause.forced_tx = !!(fld & NVM_CFG1_PORT_DRV_FLOW_CONTROL_TX);
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  	link->loopback_mode = 0;
  
 -	if (p_hwfn->mcp_info->capabilities &
 -	    FW_MB_PARAM_FEATURE_SUPPORT_FEC_CONTROL) {
 -		switch (GET_MFW_FIELD(link_temp,
 -				      NVM_CFG1_PORT_FEC_FORCE_MODE)) {
 -		case NVM_CFG1_PORT_FEC_FORCE_MODE_NONE:
 -			p_caps->fec_default |= QED_FEC_MODE_NONE;
 -			break;
 -		case NVM_CFG1_PORT_FEC_FORCE_MODE_FIRECODE:
 -			p_caps->fec_default |= QED_FEC_MODE_FIRECODE;
 -			break;
 -		case NVM_CFG1_PORT_FEC_FORCE_MODE_RS:
 -			p_caps->fec_default |= QED_FEC_MODE_RS;
 -			break;
 -		case NVM_CFG1_PORT_FEC_FORCE_MODE_AUTO:
 -			p_caps->fec_default |= QED_FEC_MODE_AUTO;
 -			break;
 -		default:
 -			DP_VERBOSE(p_hwfn, NETIF_MSG_LINK,
 -				   "unknown FEC mode in 0x%08x\n", link_temp);
 -		}
 -	} else {
 -		p_caps->fec_default = QED_FEC_MODE_UNSUPPORTED;
 -	}
 -
 -	link->fec = p_caps->fec_default;
 -
  	if (p_hwfn->mcp_info->capabilities & FW_MB_PARAM_FEATURE_SUPPORT_EEE) {
  		link_temp = qed_rd(p_hwfn, p_ptt, port_cfg_addr +
  				   offsetof(struct nvm_cfg1_port, ext_phy));
@@@ -4101,14 -4127,97 +4111,108 @@@
  		p_caps->default_eee = QED_MCP_EEE_UNSUPPORTED;
  	}
  
++<<<<<<< HEAD
 +	DP_VERBOSE(p_hwfn,
 +		   NETIF_MSG_LINK,
 +		   "Read default link: Speed 0x%08x, Adv. Speed 0x%08x, AN: 0x%02x, PAUSE AN: 0x%02x EEE: %02x [%08x usec]\n",
 +		   link->speed.forced_speed,
 +		   link->speed.advertised_speeds,
 +		   link->speed.autoneg,
 +		   link->pause.autoneg,
 +		   p_caps->default_eee, p_caps->eee_lpi_timer);
++=======
+ 	if (p_hwfn->mcp_info->capabilities &
+ 	    FW_MB_PARAM_FEATURE_SUPPORT_EXT_SPEED_FEC_CONTROL) {
+ 		ext_speed = &link->ext_speed;
+ 
+ 		link_temp = qed_rd(p_hwfn, p_ptt,
+ 				   port_cfg_addr +
+ 				   offsetof(struct nvm_cfg1_port,
+ 					    extended_speed));
+ 
+ 		fld = GET_MFW_FIELD(link_temp, NVM_CFG1_PORT_EXTENDED_SPEED);
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_AN)
+ 			ext_speed->autoneg = true;
+ 
+ 		ext_speed->forced_speed = 0;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_1G)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_1G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_10G)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_10G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_20G)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_20G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_25G)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_25G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_40G)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_40G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_50G_R)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_50G_R;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_50G_R2)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_50G_R2;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_100G_R2)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_100G_R2;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_100G_R4)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_100G_R4;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_EXTND_SPD_100G_P4)
+ 			ext_speed->forced_speed |= QED_EXT_SPEED_100G_P4;
+ 
+ 		fld = GET_MFW_FIELD(link_temp,
+ 				    NVM_CFG1_PORT_EXTENDED_SPEED_CAP);
+ 
+ 		ext_speed->advertised_speeds = 0;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_RESERVED)
+ 			ext_speed->advertised_speeds |= QED_EXT_SPEED_MASK_RES;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_1G)
+ 			ext_speed->advertised_speeds |= QED_EXT_SPEED_MASK_1G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_10G)
+ 			ext_speed->advertised_speeds |= QED_EXT_SPEED_MASK_10G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_20G)
+ 			ext_speed->advertised_speeds |= QED_EXT_SPEED_MASK_20G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_25G)
+ 			ext_speed->advertised_speeds |= QED_EXT_SPEED_MASK_25G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_40G)
+ 			ext_speed->advertised_speeds |= QED_EXT_SPEED_MASK_40G;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_50G_R)
+ 			ext_speed->advertised_speeds |=
+ 				QED_EXT_SPEED_MASK_50G_R;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_50G_R2)
+ 			ext_speed->advertised_speeds |=
+ 				QED_EXT_SPEED_MASK_50G_R2;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_100G_R2)
+ 			ext_speed->advertised_speeds |=
+ 				QED_EXT_SPEED_MASK_100G_R2;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_100G_R4)
+ 			ext_speed->advertised_speeds |=
+ 				QED_EXT_SPEED_MASK_100G_R4;
+ 		if (fld & NVM_CFG1_PORT_EXTENDED_SPEED_CAP_EXTND_SPD_100G_P4)
+ 			ext_speed->advertised_speeds |=
+ 				QED_EXT_SPEED_MASK_100G_P4;
+ 
+ 		link_temp = qed_rd(p_hwfn, p_ptt,
+ 				   port_cfg_addr +
+ 				   offsetof(struct nvm_cfg1_port,
+ 					    extended_fec_mode));
+ 		link->ext_fec_mode = link_temp;
+ 
+ 		p_caps->default_ext_speed_caps = ext_speed->advertised_speeds;
+ 		p_caps->default_ext_speed = ext_speed->forced_speed;
+ 		p_caps->default_ext_autoneg = ext_speed->autoneg;
+ 		p_caps->default_ext_fec = link->ext_fec_mode;
+ 
+ 		DP_VERBOSE(p_hwfn, NETIF_MSG_LINK,
+ 			   "Read default extended link config: Speed 0x%08x, Adv. Speed 0x%08x, AN: 0x%02x, FEC: 0x%02x\n",
+ 			   ext_speed->forced_speed,
+ 			   ext_speed->advertised_speeds, ext_speed->autoneg,
+ 			   p_caps->default_ext_fec);
+ 	}
+ 
+ 	DP_VERBOSE(p_hwfn, NETIF_MSG_LINK,
+ 		   "Read default link: Speed 0x%08x, Adv. Speed 0x%08x, AN: 0x%02x, PAUSE AN: 0x%02x, EEE: 0x%02x [0x%08x usec], FEC: 0x%02x\n",
+ 		   link->speed.forced_speed, link->speed.advertised_speeds,
+ 		   link->speed.autoneg, link->pause.autoneg,
+ 		   p_caps->default_eee, p_caps->eee_lpi_timer,
+ 		   p_caps->fec_default);
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  
  	if (IS_LEAD_HWFN(p_hwfn)) {
  		struct qed_dev *cdev = p_hwfn->cdev;
diff --cc drivers/net/ethernet/qlogic/qed/qed_hsi.h
index 7f7776d4abcd,1af3f65ab862..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_hsi.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
@@@ -11571,8 -11571,63 +11571,68 @@@ struct eth_phy_cfg 
  #define EEE_TX_TIMER_USEC_AGGRESSIVE_TIME	0x100
  #define EEE_TX_TIMER_USEC_LATENCY_TIME		0x6000
  
++<<<<<<< HEAD
 +	u32 feature_config_flags;
 +#define ETH_EEE_MODE_ADV_LPI		(1 << 0)
++=======
+ 	u32					deprecated;
+ 
+ 	u32					fec_mode;
+ #define FEC_FORCE_MODE_MASK			0x000000ff
+ #define FEC_FORCE_MODE_OFFSET			0
+ #define FEC_FORCE_MODE_NONE			0x00
+ #define FEC_FORCE_MODE_FIRECODE			0x01
+ #define FEC_FORCE_MODE_RS			0x02
+ #define FEC_FORCE_MODE_AUTO			0x07
+ #define FEC_EXTENDED_MODE_MASK			0xffffff00
+ #define FEC_EXTENDED_MODE_OFFSET		8
+ #define ETH_EXT_FEC_NONE			0x00000100
+ #define ETH_EXT_FEC_10G_NONE			0x00000200
+ #define ETH_EXT_FEC_10G_BASE_R			0x00000400
+ #define ETH_EXT_FEC_20G_NONE			0x00000800
+ #define ETH_EXT_FEC_20G_BASE_R			0x00001000
+ #define ETH_EXT_FEC_25G_NONE			0x00002000
+ #define ETH_EXT_FEC_25G_BASE_R			0x00004000
+ #define ETH_EXT_FEC_25G_RS528			0x00008000
+ #define ETH_EXT_FEC_40G_NONE			0x00010000
+ #define ETH_EXT_FEC_40G_BASE_R			0x00020000
+ #define ETH_EXT_FEC_50G_NONE			0x00040000
+ #define ETH_EXT_FEC_50G_BASE_R			0x00080000
+ #define ETH_EXT_FEC_50G_RS528			0x00100000
+ #define ETH_EXT_FEC_50G_RS544			0x00200000
+ #define ETH_EXT_FEC_100G_NONE			0x00400000
+ #define ETH_EXT_FEC_100G_BASE_R			0x00800000
+ #define ETH_EXT_FEC_100G_RS528			0x01000000
+ #define ETH_EXT_FEC_100G_RS544			0x02000000
+ 
+ 	u32					extended_speed;
+ #define ETH_EXT_SPEED_MASK			0x0000ffff
+ #define ETH_EXT_SPEED_OFFSET			0
+ #define ETH_EXT_SPEED_AN			0x00000001
+ #define ETH_EXT_SPEED_1G			0x00000002
+ #define ETH_EXT_SPEED_10G			0x00000004
+ #define ETH_EXT_SPEED_20G			0x00000008
+ #define ETH_EXT_SPEED_25G			0x00000010
+ #define ETH_EXT_SPEED_40G			0x00000020
+ #define ETH_EXT_SPEED_50G_BASE_R		0x00000040
+ #define ETH_EXT_SPEED_50G_BASE_R2		0x00000080
+ #define ETH_EXT_SPEED_100G_BASE_R2		0x00000100
+ #define ETH_EXT_SPEED_100G_BASE_R4		0x00000200
+ #define ETH_EXT_SPEED_100G_BASE_P4		0x00000400
+ #define ETH_EXT_ADV_SPEED_MASK			0xffff0000
+ #define ETH_EXT_ADV_SPEED_OFFSET		16
+ #define ETH_EXT_ADV_SPEED_RESERVED		0x00010000
+ #define ETH_EXT_ADV_SPEED_1G			0x00020000
+ #define ETH_EXT_ADV_SPEED_10G			0x00040000
+ #define ETH_EXT_ADV_SPEED_20G			0x00080000
+ #define ETH_EXT_ADV_SPEED_25G			0x00100000
+ #define ETH_EXT_ADV_SPEED_40G			0x00200000
+ #define ETH_EXT_ADV_SPEED_50G_BASE_R		0x00400000
+ #define ETH_EXT_ADV_SPEED_50G_BASE_R2		0x00800000
+ #define ETH_EXT_ADV_SPEED_100G_BASE_R2		0x01000000
+ #define ETH_EXT_ADV_SPEED_100G_BASE_R4		0x02000000
+ #define ETH_EXT_ADV_SPEED_100G_BASE_P4		0x04000000
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  };
  
  struct port_mf_cfg {
@@@ -12525,66 -12585,68 +12585,75 @@@ struct public_drv_mb 
  #define DRV_MB_PARAM_SET_LED_MODE_ON		0x1
  #define DRV_MB_PARAM_SET_LED_MODE_OFF		0x2
  
 -#define DRV_MB_PARAM_TRANSCEIVER_PORT_OFFSET			0
 -#define DRV_MB_PARAM_TRANSCEIVER_PORT_MASK			0x00000003
 -#define DRV_MB_PARAM_TRANSCEIVER_SIZE_OFFSET			2
 -#define DRV_MB_PARAM_TRANSCEIVER_SIZE_MASK			0x000000fc
 -#define DRV_MB_PARAM_TRANSCEIVER_I2C_ADDRESS_OFFSET		8
 -#define DRV_MB_PARAM_TRANSCEIVER_I2C_ADDRESS_MASK		0x0000ff00
 -#define DRV_MB_PARAM_TRANSCEIVER_OFFSET_OFFSET			16
 -#define DRV_MB_PARAM_TRANSCEIVER_OFFSET_MASK			0xffff0000
 +#define DRV_MB_PARAM_TRANSCEIVER_PORT_OFFSET		0
 +#define DRV_MB_PARAM_TRANSCEIVER_PORT_MASK		0x00000003
 +#define DRV_MB_PARAM_TRANSCEIVER_SIZE_OFFSET		2
 +#define DRV_MB_PARAM_TRANSCEIVER_SIZE_MASK		0x000000FC
 +#define DRV_MB_PARAM_TRANSCEIVER_I2C_ADDRESS_OFFSET	8
 +#define DRV_MB_PARAM_TRANSCEIVER_I2C_ADDRESS_MASK	0x0000FF00
 +#define DRV_MB_PARAM_TRANSCEIVER_OFFSET_OFFSET		16
 +#define DRV_MB_PARAM_TRANSCEIVER_OFFSET_MASK		0xFFFF0000
  
  	/* Resource Allocation params - Driver version support */
 -#define DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_MASK		0xffff0000
 -#define DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_SHIFT		16
 -#define DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_MASK		0x0000ffff
 -#define DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_SHIFT		0
 -
 -#define DRV_MB_PARAM_BIST_REGISTER_TEST				1
 -#define DRV_MB_PARAM_BIST_CLOCK_TEST				2
 -#define DRV_MB_PARAM_BIST_NVM_TEST_NUM_IMAGES			3
 -#define DRV_MB_PARAM_BIST_NVM_TEST_IMAGE_BY_INDEX		4
 -
 -#define DRV_MB_PARAM_BIST_RC_UNKNOWN				0
 -#define DRV_MB_PARAM_BIST_RC_PASSED				1
 -#define DRV_MB_PARAM_BIST_RC_FAILED				2
 -#define DRV_MB_PARAM_BIST_RC_INVALID_PARAMETER			3
 -
 -#define DRV_MB_PARAM_BIST_TEST_INDEX_SHIFT			0
 -#define DRV_MB_PARAM_BIST_TEST_INDEX_MASK			0x000000ff
 -#define DRV_MB_PARAM_BIST_TEST_IMAGE_INDEX_SHIFT		8
 -#define DRV_MB_PARAM_BIST_TEST_IMAGE_INDEX_MASK			0x0000ff00
 -
 +#define DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_MASK	0xFFFF0000
 +#define DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_SHIFT	16
 +#define DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_MASK	0x0000FFFF
 +#define DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_SHIFT	0
 +
 +#define DRV_MB_PARAM_BIST_REGISTER_TEST		1
 +#define DRV_MB_PARAM_BIST_CLOCK_TEST		2
 +#define DRV_MB_PARAM_BIST_NVM_TEST_NUM_IMAGES	3
 +#define DRV_MB_PARAM_BIST_NVM_TEST_IMAGE_BY_INDEX	4
 +
 +#define DRV_MB_PARAM_BIST_RC_UNKNOWN		0
 +#define DRV_MB_PARAM_BIST_RC_PASSED		1
 +#define DRV_MB_PARAM_BIST_RC_FAILED		2
 +#define DRV_MB_PARAM_BIST_RC_INVALID_PARAMETER	3
 +
 +#define DRV_MB_PARAM_BIST_TEST_INDEX_SHIFT	0
 +#define DRV_MB_PARAM_BIST_TEST_INDEX_MASK	0x000000FF
 +#define DRV_MB_PARAM_BIST_TEST_IMAGE_INDEX_SHIFT	8
 +#define DRV_MB_PARAM_BIST_TEST_IMAGE_INDEX_MASK		0x0000FF00
 +
++<<<<<<< HEAD
 +#define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_MASK		0x0000FFFF
 +#define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_OFFSET	0
 +#define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_EEE		0x00000002
 +#define DRV_MB_PARAM_FEATURE_SUPPORT_FUNC_VLINK		0x00010000
++=======
+ #define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_MASK			0x0000ffff
+ #define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_OFFSET		0
+ #define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_EEE			0x00000002
+ #define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_FEC_CONTROL		0x00000004
+ #define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_EXT_SPEED_FEC_CONTROL	0x00000008
+ #define DRV_MB_PARAM_FEATURE_SUPPORT_FUNC_VLINK			0x00010000
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  
  /* DRV_MSG_CODE_DEBUG_DATA_SEND parameters */
 -#define DRV_MSG_CODE_DEBUG_DATA_SEND_SIZE_OFFSET		0
 -#define DRV_MSG_CODE_DEBUG_DATA_SEND_SIZE_MASK			0xff
 +#define DRV_MSG_CODE_DEBUG_DATA_SEND_SIZE_OFFSET	0
 +#define DRV_MSG_CODE_DEBUG_DATA_SEND_SIZE_MASK		0xFF
  
  /* Driver attributes params */
 -#define DRV_MB_PARAM_ATTRIBUTE_KEY_OFFSET			0
 -#define DRV_MB_PARAM_ATTRIBUTE_KEY_MASK				0x00ffffff
 -#define DRV_MB_PARAM_ATTRIBUTE_CMD_OFFSET			24
 -#define DRV_MB_PARAM_ATTRIBUTE_CMD_MASK				0xff000000
 -
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ID_OFFSET			0
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ID_SHIFT			0
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ID_MASK			0x0000ffff
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ALL_SHIFT			16
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ALL_MASK			0x00010000
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_INIT_SHIFT			17
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_INIT_MASK			0x00020000
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_COMMIT_SHIFT		18
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_COMMIT_MASK			0x00040000
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_FREE_SHIFT			19
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_FREE_MASK			0x00080000
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ENTITY_SEL_SHIFT		20
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ENTITY_SEL_MASK		0x00100000
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ENTITY_ID_SHIFT		24
 -#define DRV_MB_PARAM_NVM_CFG_OPTION_ENTITY_ID_MASK		0x0f000000
 +#define DRV_MB_PARAM_ATTRIBUTE_KEY_OFFSET		0
 +#define DRV_MB_PARAM_ATTRIBUTE_KEY_MASK			0x00FFFFFF
 +#define DRV_MB_PARAM_ATTRIBUTE_CMD_OFFSET		24
 +#define DRV_MB_PARAM_ATTRIBUTE_CMD_MASK			0xFF000000
 +
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ID_OFFSET		0
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ID_SHIFT		0
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ID_MASK		0x0000FFFF
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ALL_SHIFT		16
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ALL_MASK		0x00010000
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_INIT_SHIFT		17
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_INIT_MASK		0x00020000
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_COMMIT_SHIFT	18
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_COMMIT_MASK		0x00040000
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_FREE_SHIFT		19
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_FREE_MASK		0x00080000
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ENTITY_SEL_SHIFT	20
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ENTITY_SEL_MASK	0x00100000
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ENTITY_ID_SHIFT	24
 +#define DRV_MB_PARAM_NVM_CFG_OPTION_ENTITY_ID_MASK	0x0f000000
  
  	u32 fw_mb_header;
  #define FW_MSG_CODE_MASK			0xffff0000
@@@ -12631,55 -12693,57 +12700,63 @@@
  
  #define FW_MSG_CODE_MDUMP_INVALID_CMD		0x00030000
  
 -	u32							fw_mb_param;
 -#define FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_MASK		0xffff0000
 -#define FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_SHIFT		16
 -#define FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_MASK		0x0000ffff
 -#define FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_SHIFT		0
 +	u32						fw_mb_param;
 +#define FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_MASK	0xffff0000
 +#define FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_SHIFT	16
 +#define FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_MASK	0x0000ffff
 +#define FW_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_SHIFT	0
  
  	/* Get PF RDMA protocol command response */
 -#define FW_MB_PARAM_GET_PF_RDMA_NONE				0x0
 -#define FW_MB_PARAM_GET_PF_RDMA_ROCE				0x1
 -#define FW_MB_PARAM_GET_PF_RDMA_IWARP				0x2
 -#define FW_MB_PARAM_GET_PF_RDMA_BOTH				0x3
 +#define FW_MB_PARAM_GET_PF_RDMA_NONE			0x0
 +#define FW_MB_PARAM_GET_PF_RDMA_ROCE			0x1
 +#define FW_MB_PARAM_GET_PF_RDMA_IWARP			0x2
 +#define FW_MB_PARAM_GET_PF_RDMA_BOTH			0x3
  
  	/* Get MFW feature support response */
++<<<<<<< HEAD
 +#define FW_MB_PARAM_FEATURE_SUPPORT_SMARTLINQ		0x00000001
 +#define FW_MB_PARAM_FEATURE_SUPPORT_EEE			0x00000002
 +#define FW_MB_PARAM_FEATURE_SUPPORT_VLINK		0x00010000
++=======
+ #define FW_MB_PARAM_FEATURE_SUPPORT_SMARTLINQ			BIT(0)
+ #define FW_MB_PARAM_FEATURE_SUPPORT_EEE				BIT(1)
+ #define FW_MB_PARAM_FEATURE_SUPPORT_FEC_CONTROL			BIT(5)
+ #define FW_MB_PARAM_FEATURE_SUPPORT_EXT_SPEED_FEC_CONTROL	BIT(6)
+ #define FW_MB_PARAM_FEATURE_SUPPORT_VLINK			BIT(16)
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  
 -#define FW_MB_PARAM_LOAD_DONE_DID_EFUSE_ERROR			BIT(0)
 +#define FW_MB_PARAM_LOAD_DONE_DID_EFUSE_ERROR		BIT(0)
  
 -#define FW_MB_PARAM_ENG_CFG_FIR_AFFIN_VALID_MASK		0x00000001
 -#define FW_MB_PARAM_ENG_CFG_FIR_AFFIN_VALID_SHIFT		0
 -#define FW_MB_PARAM_ENG_CFG_FIR_AFFIN_VALUE_MASK		0x00000002
 -#define FW_MB_PARAM_ENG_CFG_FIR_AFFIN_VALUE_SHIFT		1
 -#define FW_MB_PARAM_ENG_CFG_L2_AFFIN_VALID_MASK			0x00000004
 -#define FW_MB_PARAM_ENG_CFG_L2_AFFIN_VALID_SHIFT		2
 -#define FW_MB_PARAM_ENG_CFG_L2_AFFIN_VALUE_MASK			0x00000008
 -#define FW_MB_PARAM_ENG_CFG_L2_AFFIN_VALUE_SHIFT		3
 +#define FW_MB_PARAM_ENG_CFG_FIR_AFFIN_VALID_MASK	0x00000001
 +#define FW_MB_PARAM_ENG_CFG_FIR_AFFIN_VALID_SHIFT	0
 +#define FW_MB_PARAM_ENG_CFG_FIR_AFFIN_VALUE_MASK	0x00000002
 +#define FW_MB_PARAM_ENG_CFG_FIR_AFFIN_VALUE_SHIFT	1
 +#define FW_MB_PARAM_ENG_CFG_L2_AFFIN_VALID_MASK		0x00000004
 +#define FW_MB_PARAM_ENG_CFG_L2_AFFIN_VALID_SHIFT	2
 +#define FW_MB_PARAM_ENG_CFG_L2_AFFIN_VALUE_MASK		0x00000008
 +#define FW_MB_PARAM_ENG_CFG_L2_AFFIN_VALUE_SHIFT	3
  
 -#define FW_MB_PARAM_PPFID_BITMAP_MASK				0xff
 -#define FW_MB_PARAM_PPFID_BITMAP_SHIFT				0
 +#define FW_MB_PARAM_PPFID_BITMAP_MASK			0xff
 +#define FW_MB_PARAM_PPFID_BITMAP_SHIFT			0
  
 -	u32							drv_pulse_mb;
 -#define DRV_PULSE_SEQ_MASK					0x00007fff
 -#define DRV_PULSE_SYSTEM_TIME_MASK				0xffff0000
 -#define DRV_PULSE_ALWAYS_ALIVE					0x00008000
 +	u32						drv_pulse_mb;
 +#define DRV_PULSE_SEQ_MASK				0x00007fff
 +#define DRV_PULSE_SYSTEM_TIME_MASK			0xffff0000
 +#define DRV_PULSE_ALWAYS_ALIVE				0x00008000
  
 -	u32							mcp_pulse_mb;
 -#define MCP_PULSE_SEQ_MASK					0x00007fff
 -#define MCP_PULSE_ALWAYS_ALIVE					0x00008000
 -#define MCP_EVENT_MASK						0xffff0000
 -#define MCP_EVENT_OTHER_DRIVER_RESET_REQ			0x00010000
 +	u32						mcp_pulse_mb;
 +#define MCP_PULSE_SEQ_MASK				0x00007fff
 +#define MCP_PULSE_ALWAYS_ALIVE				0x00008000
 +#define MCP_EVENT_MASK					0xffff0000
 +#define MCP_EVENT_OTHER_DRIVER_RESET_REQ		0x00010000
  
 -	union drv_union_data					union_data;
 +	union drv_union_data				union_data;
  };
  
 -#define FW_MB_PARAM_NVM_PUT_FILE_REQ_OFFSET_MASK		0x00ffffff
 -#define FW_MB_PARAM_NVM_PUT_FILE_REQ_OFFSET_SHIFT		0
 -#define FW_MB_PARAM_NVM_PUT_FILE_REQ_SIZE_MASK			0xff000000
 -#define FW_MB_PARAM_NVM_PUT_FILE_REQ_SIZE_SHIFT			24
 +#define FW_MB_PARAM_NVM_PUT_FILE_REQ_OFFSET_MASK	0x00ffffff
 +#define FW_MB_PARAM_NVM_PUT_FILE_REQ_OFFSET_SHIFT	0
 +#define FW_MB_PARAM_NVM_PUT_FILE_REQ_SIZE_MASK		0xff000000
 +#define FW_MB_PARAM_NVM_PUT_FILE_REQ_SIZE_SHIFT		24
  
  enum MFW_DRV_MSG_TYPE {
  	MFW_DRV_MSG_LINK_CHANGE,
diff --cc drivers/net/ethernet/qlogic/qed/qed_main.c
index 28044226604f,2558cb680db3..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@@ -1997,12 -2249,8 +2246,17 @@@ static void qed_fill_link(struct qed_hw
  	    params.pause.forced_tx)
  		phylink_set(if_link->supported_caps, Pause);
  
++<<<<<<< HEAD
 +	linkmode_copy(if_link->advertised_caps, if_link->supported_caps);
 +
 +	if (params.speed.autoneg)
 +		phylink_set(if_link->advertised_caps, Autoneg);
 +	else
 +		phylink_clear(if_link->advertised_caps, Autoneg);
++=======
+ 	if_link->sup_fec = link_caps.fec_default;
+ 	if_link->active_fec = params.fec;
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  
  	/* Fill link advertised capability */
  	qed_fill_link_capability(hwfn, ptt, params.speed.advertised_speeds,
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.c
index b10a92488630,988d84564849..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@@ -1456,8 -1475,9 +1456,13 @@@ int qed_mcp_set_link(struct qed_hwfn *p
  	struct qed_mcp_link_params *params = &p_hwfn->mcp_info->link_input;
  	struct qed_mcp_mb_params mb_params;
  	struct eth_phy_cfg phy_cfg;
++<<<<<<< HEAD
++=======
+ 	u32 cmd, fec_bit = 0;
+ 	u32 val, ext_speed;
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  	int rc = 0;
 +	u32 cmd;
  
  	/* Set the shmem configuration according to params */
  	memset(&phy_cfg, 0, sizeof(phy_cfg));
@@@ -1489,19 -1509,91 +1494,103 @@@
  				   EEE_TX_TIMER_USEC_MASK;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (p_hwfn->mcp_info->capabilities &
+ 	    FW_MB_PARAM_FEATURE_SUPPORT_FEC_CONTROL) {
+ 		if (params->fec & QED_FEC_MODE_NONE)
+ 			fec_bit |= FEC_FORCE_MODE_NONE;
+ 		else if (params->fec & QED_FEC_MODE_FIRECODE)
+ 			fec_bit |= FEC_FORCE_MODE_FIRECODE;
+ 		else if (params->fec & QED_FEC_MODE_RS)
+ 			fec_bit |= FEC_FORCE_MODE_RS;
+ 		else if (params->fec & QED_FEC_MODE_AUTO)
+ 			fec_bit |= FEC_FORCE_MODE_AUTO;
+ 
+ 		SET_MFW_FIELD(phy_cfg.fec_mode, FEC_FORCE_MODE, fec_bit);
+ 	}
+ 
+ 	if (p_hwfn->mcp_info->capabilities &
+ 	    FW_MB_PARAM_FEATURE_SUPPORT_EXT_SPEED_FEC_CONTROL) {
+ 		ext_speed = 0;
+ 		if (params->ext_speed.autoneg)
+ 			ext_speed |= ETH_EXT_SPEED_AN;
+ 
+ 		val = params->ext_speed.forced_speed;
+ 		if (val & QED_EXT_SPEED_1G)
+ 			ext_speed |= ETH_EXT_SPEED_1G;
+ 		if (val & QED_EXT_SPEED_10G)
+ 			ext_speed |= ETH_EXT_SPEED_10G;
+ 		if (val & QED_EXT_SPEED_20G)
+ 			ext_speed |= ETH_EXT_SPEED_20G;
+ 		if (val & QED_EXT_SPEED_25G)
+ 			ext_speed |= ETH_EXT_SPEED_25G;
+ 		if (val & QED_EXT_SPEED_40G)
+ 			ext_speed |= ETH_EXT_SPEED_40G;
+ 		if (val & QED_EXT_SPEED_50G_R)
+ 			ext_speed |= ETH_EXT_SPEED_50G_BASE_R;
+ 		if (val & QED_EXT_SPEED_50G_R2)
+ 			ext_speed |= ETH_EXT_SPEED_50G_BASE_R2;
+ 		if (val & QED_EXT_SPEED_100G_R2)
+ 			ext_speed |= ETH_EXT_SPEED_100G_BASE_R2;
+ 		if (val & QED_EXT_SPEED_100G_R4)
+ 			ext_speed |= ETH_EXT_SPEED_100G_BASE_R4;
+ 		if (val & QED_EXT_SPEED_100G_P4)
+ 			ext_speed |= ETH_EXT_SPEED_100G_BASE_P4;
+ 
+ 		SET_MFW_FIELD(phy_cfg.extended_speed, ETH_EXT_SPEED,
+ 			      ext_speed);
+ 
+ 		ext_speed = 0;
+ 
+ 		val = params->ext_speed.advertised_speeds;
+ 		if (val & QED_EXT_SPEED_MASK_1G)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_1G;
+ 		if (val & QED_EXT_SPEED_MASK_10G)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_10G;
+ 		if (val & QED_EXT_SPEED_MASK_20G)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_20G;
+ 		if (val & QED_EXT_SPEED_MASK_25G)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_25G;
+ 		if (val & QED_EXT_SPEED_MASK_40G)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_40G;
+ 		if (val & QED_EXT_SPEED_MASK_50G_R)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_50G_BASE_R;
+ 		if (val & QED_EXT_SPEED_MASK_50G_R2)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_50G_BASE_R2;
+ 		if (val & QED_EXT_SPEED_MASK_100G_R2)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_100G_BASE_R2;
+ 		if (val & QED_EXT_SPEED_MASK_100G_R4)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_100G_BASE_R4;
+ 		if (val & QED_EXT_SPEED_MASK_100G_P4)
+ 			ext_speed |= ETH_EXT_ADV_SPEED_100G_BASE_P4;
+ 
+ 		phy_cfg.extended_speed |= ext_speed;
+ 
+ 		SET_MFW_FIELD(phy_cfg.fec_mode, FEC_EXTENDED_MODE,
+ 			      params->ext_fec_mode);
+ 	}
+ 
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  	p_hwfn->b_drv_link_init = b_up;
  
  	if (b_up) {
  		DP_VERBOSE(p_hwfn, NETIF_MSG_LINK,
++<<<<<<< HEAD
 +			   "Configuring Link: Speed 0x%08x, Pause 0x%08x, adv_speed 0x%08x, loopback 0x%08x, features 0x%08x\n",
 +			   phy_cfg.speed,
 +			   phy_cfg.pause,
 +			   phy_cfg.adv_speed,
 +			   phy_cfg.loopback_mode,
 +			   phy_cfg.feature_config_flags);
++=======
+ 			   "Configuring Link: Speed 0x%08x, Pause 0x%08x, Adv. Speed 0x%08x, Loopback 0x%08x, FEC 0x%08x, Ext. Speed 0x%08x\n",
+ 			   phy_cfg.speed, phy_cfg.pause, phy_cfg.adv_speed,
+ 			   phy_cfg.loopback_mode, phy_cfg.fec_mode,
+ 			   phy_cfg.extended_speed);
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  	} else {
- 		DP_VERBOSE(p_hwfn, NETIF_MSG_LINK,
- 			   "Resetting link\n");
+ 		DP_VERBOSE(p_hwfn, NETIF_MSG_LINK, "Resetting link\n");
  	}
  
  	memset(&mb_params, 0, sizeof(mb_params));
@@@ -3805,8 -3897,13 +3894,12 @@@ int qed_mcp_set_capabilities(struct qed
  	u32 mcp_resp, mcp_param, features;
  
  	features = DRV_MB_PARAM_FEATURE_SUPPORT_PORT_EEE |
 -		   DRV_MB_PARAM_FEATURE_SUPPORT_FUNC_VLINK |
 -		   DRV_MB_PARAM_FEATURE_SUPPORT_PORT_FEC_CONTROL;
 +		   DRV_MB_PARAM_FEATURE_SUPPORT_FUNC_VLINK;
  
+ 	if (QED_IS_E5(p_hwfn->cdev))
+ 		features |=
+ 		    DRV_MB_PARAM_FEATURE_SUPPORT_PORT_EXT_SPEED_FEC_CONTROL;
+ 
  	return qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_FEATURE_SUPPORT,
  			   features, &mcp_resp, &mcp_param);
  }
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.h
index cf678b6966f8,8edb450d0abf..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
@@@ -16,9 -16,32 +16,38 @@@
  #include "qed_dev_api.h"
  
  struct qed_mcp_link_speed_params {
++<<<<<<< HEAD
 +	bool    autoneg;
 +	u32     advertised_speeds;      /* bitmask of DRV_SPEED_CAPABILITY */
 +	u32     forced_speed;	   /* In Mb/s */
++=======
+ 	bool					autoneg;
+ 
+ 	u32					advertised_speeds;
+ #define QED_EXT_SPEED_MASK_RES			0x1
+ #define QED_EXT_SPEED_MASK_1G			0x2
+ #define QED_EXT_SPEED_MASK_10G			0x4
+ #define QED_EXT_SPEED_MASK_20G			0x8
+ #define QED_EXT_SPEED_MASK_25G			0x10
+ #define QED_EXT_SPEED_MASK_40G			0x20
+ #define QED_EXT_SPEED_MASK_50G_R		0x40
+ #define QED_EXT_SPEED_MASK_50G_R2		0x80
+ #define QED_EXT_SPEED_MASK_100G_R2		0x100
+ #define QED_EXT_SPEED_MASK_100G_R4		0x200
+ #define QED_EXT_SPEED_MASK_100G_P4		0x400
+ 
+ 	u32					forced_speed;	   /* In Mb/s */
+ #define QED_EXT_SPEED_1G			0x1
+ #define QED_EXT_SPEED_10G			0x2
+ #define QED_EXT_SPEED_20G			0x4
+ #define QED_EXT_SPEED_25G			0x8
+ #define QED_EXT_SPEED_40G			0x10
+ #define QED_EXT_SPEED_50G_R			0x20
+ #define QED_EXT_SPEED_50G_R2			0x40
+ #define QED_EXT_SPEED_100G_R2			0x80
+ #define QED_EXT_SPEED_100G_R4			0x100
+ #define QED_EXT_SPEED_100G_P4			0x200
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  };
  
  struct qed_mcp_link_pause_params {
@@@ -38,6 -61,10 +67,13 @@@ struct qed_mcp_link_params 
  	struct qed_mcp_link_pause_params	pause;
  	u32					loopback_mode;
  	struct qed_link_eee_params		eee;
++<<<<<<< HEAD
++=======
+ 	u32					fec;
+ 
+ 	struct qed_mcp_link_speed_params	ext_speed;
+ 	u32					ext_fec_mode;
++>>>>>>> 99785a87fc7d (qed: add support for the extended speed and FEC modes)
  };
  
  struct qed_mcp_link_capabilities {
* Unmerged path drivers/net/ethernet/qlogic/qed/qed.h
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_dev.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_hsi.h
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_main.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.h
diff --git a/include/linux/qed/qed_if.h b/include/linux/qed/qed_if.h
index ebe4048c382b..5ff7ce79e8e6 100644
--- a/include/linux/qed/qed_if.h
+++ b/include/linux/qed/qed_if.h
@@ -594,6 +594,7 @@ enum qed_hw_err_type {
 enum qed_dev_type {
 	QED_DEV_TYPE_BB,
 	QED_DEV_TYPE_AH,
+	QED_DEV_TYPE_E5,
 };
 
 struct qed_dev_info {
