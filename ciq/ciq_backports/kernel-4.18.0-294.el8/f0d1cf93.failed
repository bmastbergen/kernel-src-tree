scsi: scsi_debug: Add ZBC zone commands

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Douglas Gilbert <dgilbert@interlog.com>
commit f0d1cf9378bd4030725efa4c154cd39383dd0c12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f0d1cf93.failed

Add support for the 5 ZBC commands and enough functionality to emulate a
host-managed device with one conventional zone and a set of sequential
write-required zones up to the disk capacity.

Link: https://lore.kernel.org/r/20200422104221.378203-3-damien.lemoal@wdc.com
	Signed-off-by: Douglas Gilbert <dgilbert@interlog.com>
	Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f0d1cf9378bd4030725efa4c154cd39383dd0c12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_debug.c
diff --cc drivers/scsi/scsi_debug.c
index 8a8e70143123,6e999320a7f0..000000000000
--- a/drivers/scsi/scsi_debug.c
+++ b/drivers/scsi/scsi_debug.c
@@@ -247,6 -257,26 +256,29 @@@ static const char *sdebug_version_date 
  
  #define SDEBUG_MAX_CMD_LEN 32
  
++<<<<<<< HEAD
++=======
+ #define SDEB_XA_NOT_IN_USE XA_MARK_1
+ 
+ /* enumeration names taken from table 26, zbcr05 */
+ enum sdebug_z_cond {
+ 	ZBC_NOT_WRITE_POINTER	= 0x0,
+ 	ZC1_EMPTY		= 0x1,
+ 	ZC2_IMPLICIT_OPEN	= 0x2,
+ 	ZC3_EXPLICIT_OPEN	= 0x3,
+ 	ZC4_CLOSED		= 0x4,
+ 	ZC6_READ_ONLY		= 0xd,
+ 	ZC5_FULL		= 0xe,
+ 	ZC7_OFFLINE		= 0xf,
+ };
+ 
+ struct sdeb_zone_state {	/* ZBC: per zone state */
+ 	enum sdebug_z_cond z_cond;
+ 	unsigned int z_size;
+ 	sector_t z_start;
+ 	sector_t z_wp;
+ };
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  
  struct sdebug_dev_info {
  	struct list_head dev_list;
@@@ -356,7 -405,10 +398,14 @@@ enum sdeb_opcode_index 
  	SDEB_I_WRITE_SAME = 26,		/* 10, 16 */
  	SDEB_I_SYNC_CACHE = 27,		/* 10, 16 */
  	SDEB_I_COMP_WRITE = 28,
++<<<<<<< HEAD
 +	SDEB_I_LAST_ELEMENT = 29,	/* keep this last (previous + 1) */
++=======
+ 	SDEB_I_PRE_FETCH = 29,		/* 10, 16 */
+ 	SDEB_I_ZONE_OUT = 30,		/* 0x94+SA; includes no data xfer */
+ 	SDEB_I_ZONE_IN = 31,		/* 0x95+SA; all have data-in */
+ 	SDEB_I_LAST_ELEM_P1 = 32,	/* keep this last (previous + 1) */
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  };
  
  
@@@ -386,8 -438,10 +435,15 @@@ static const unsigned char opcode_ind_a
  	0, SDEB_I_VARIABLE_LEN,
  /* 0x80; 0x80->0x9f: 16 byte cdbs */
  	0, 0, 0, 0, 0, SDEB_I_ATA_PT, 0, 0,
++<<<<<<< HEAD
 +	SDEB_I_READ, SDEB_I_COMP_WRITE, SDEB_I_WRITE, 0, 0, 0, 0, 0,
 +	0, SDEB_I_SYNC_CACHE, 0, SDEB_I_WRITE_SAME, 0, 0, 0, 0,
++=======
+ 	SDEB_I_READ, SDEB_I_COMP_WRITE, SDEB_I_WRITE, 0,
+ 	0, 0, 0, SDEB_I_VERIFY,
+ 	SDEB_I_PRE_FETCH, SDEB_I_SYNC_CACHE, 0, SDEB_I_WRITE_SAME,
+ 	SDEB_I_ZONE_OUT, SDEB_I_ZONE_IN, 0, 0,
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  	0, 0, 0, 0, 0, 0, SDEB_I_SERV_ACT_IN_16, SDEB_I_SERV_ACT_OUT_16,
  /* 0xa0; 0xa0->0xbf: 12 byte cdbs */
  	SDEB_I_REPORT_LUNS, SDEB_I_ATA_PT, 0, SDEB_I_MAINT_IN,
@@@ -433,6 -488,19 +489,22 @@@ static int resp_write_same_16(struct sc
  static int resp_comp_write(struct scsi_cmnd *, struct sdebug_dev_info *);
  static int resp_write_buffer(struct scsi_cmnd *, struct sdebug_dev_info *);
  static int resp_sync_cache(struct scsi_cmnd *, struct sdebug_dev_info *);
++<<<<<<< HEAD
++=======
+ static int resp_pre_fetch(struct scsi_cmnd *, struct sdebug_dev_info *);
+ static int resp_report_zones(struct scsi_cmnd *, struct sdebug_dev_info *);
+ static int resp_open_zone(struct scsi_cmnd *, struct sdebug_dev_info *);
+ static int resp_close_zone(struct scsi_cmnd *, struct sdebug_dev_info *);
+ static int resp_finish_zone(struct scsi_cmnd *, struct sdebug_dev_info *);
+ static int resp_rwp_zone(struct scsi_cmnd *, struct sdebug_dev_info *);
+ 
+ static int sdebug_do_add_host(bool mk_new_store);
+ static int sdebug_add_host_helper(int per_host_idx);
+ static void sdebug_do_remove_host(bool the_end);
+ static int sdebug_add_store(void);
+ static void sdebug_erase_store(int idx, struct sdeb_store_info *sip);
+ static void sdebug_erase_all_stores(bool apart_from_first);
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  
  /*
   * The following are overflow arrays for cdbs that "hit" the same index in
@@@ -518,6 -592,30 +590,33 @@@ static const struct opcode_info_t sync_
  	     0xff, 0xff, 0xff, 0xff, 0x3f, 0xc7} },	/* SYNC_CACHE (16) */
  };
  
++<<<<<<< HEAD
++=======
+ static const struct opcode_info_t pre_fetch_iarr[] = {
+ 	{0, 0x90, 0, F_SYNC_DELAY | F_M_ACCESS, resp_pre_fetch, NULL,
+ 	    {16,  0x2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+ 	     0xff, 0xff, 0xff, 0xff, 0x3f, 0xc7} },	/* PRE-FETCH (16) */
+ };
+ 
+ static const struct opcode_info_t zone_out_iarr[] = {	/* ZONE OUT(16) */
+ 	{0, 0x94, 0x1, F_SA_LOW, resp_close_zone, NULL,
+ 	    {16, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+ 	     0xff, 0, 0, 0xff, 0xff, 0x1, 0xc7} },	/* CLOSE ZONE */
+ 	{0, 0x94, 0x2, F_SA_LOW, resp_finish_zone, NULL,
+ 	    {16, 0x2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+ 	     0xff, 0, 0, 0xff, 0xff, 0x1, 0xc7} },	/* FINISH ZONE */
+ 	{0, 0x94, 0x4, F_SA_LOW, resp_rwp_zone, NULL,
+ 	    {16, 0x4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+ 	     0xff, 0, 0, 0xff, 0xff, 0x1, 0xc7} },  /* RESET WRITE POINTER */
+ };
+ 
+ static const struct opcode_info_t zone_in_iarr[] = {	/* ZONE IN(16) */
+ 	{0, 0x95, 0x6, F_SA_LOW | F_D_IN, NULL, NULL,
+ 	    {16, 0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+ 	     0xff, 0xff, 0xff, 0xff, 0x3f, 0xc7} }, /* REPORT ZONES */
+ };
+ 
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  
  /* This array is accessed via SDEB_I_* values. Make sure all are mapped,
   * plus the terminating elements for logic that scans this table such as
@@@ -613,8 -712,21 +712,21 @@@ static const struct opcode_info_t opcod
  	{0, 0x89, 0, F_D_OUT | FF_MEDIA_IO, resp_comp_write, NULL,
  	    {16,  0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0,
  	     0, 0xff, 0x3f, 0xc7} },		/* COMPARE AND WRITE */
 -	{ARRAY_SIZE(pre_fetch_iarr), 0x34, 0, F_SYNC_DELAY | F_M_ACCESS,
 -	    resp_pre_fetch, pre_fetch_iarr,
 -	    {10,  0x2, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xc7, 0, 0,
 -	     0, 0, 0, 0} },			/* PRE-FETCH (10) */
  
++<<<<<<< HEAD
 +/* 29 */
++=======
+ /* 30 */
+ 	{ARRAY_SIZE(zone_out_iarr), 0x94, 0x3, F_SA_LOW,
+ 	    resp_open_zone, zone_out_iarr, /* ZONE_OUT(16), OPEN ZONE) */
+ 		{16,  0x3 /* SA */, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+ 		 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x1, 0xc7} },
+ 	{ARRAY_SIZE(zone_in_iarr), 0x95, 0x0, F_SA_LOW | F_D_IN,
+ 	    resp_report_zones, zone_in_iarr, /* ZONE_IN(16), REPORT ZONES) */
+ 		{16,  0x0 /* SA */, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+ 		 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xc7} },
+ /* sentinel */
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  	{0xff, 0, 0, 0, NULL, NULL,		/* terminating element */
  	    {0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} },
  };
@@@ -2487,14 -2624,190 +2606,190 @@@ static int resp_log_sense(struct scsi_c
  		mk_sense_invalid_fld(scp, SDEB_IN_CDB, 3, -1);
  		return check_condition_result;
  	}
 -	len = min_t(int, get_unaligned_be16(arr + 2) + 4, alloc_len);
 +	len = min(get_unaligned_be16(arr + 2) + 4, alloc_len);
  	return fill_from_dev_buffer(scp, arr,
 -		    min_t(int, len, SDEBUG_MAX_INQ_ARR_SZ));
 +		    min(len, SDEBUG_MAX_INQ_ARR_SZ));
  }
  
- static inline int check_device_access_params(struct scsi_cmnd *scp,
- 	unsigned long long lba, unsigned int num, bool write)
+ static inline bool sdebug_dev_is_zoned(struct sdebug_dev_info *devip)
  {
+ 	return devip->nr_zones != 0;
+ }
+ 
+ static struct sdeb_zone_state *zbc_zone(struct sdebug_dev_info *devip,
+ 					unsigned long long lba)
+ {
+ 	unsigned int zno;
+ 
+ 	if (devip->zsize_shift)
+ 		zno = lba >> devip->zsize_shift;
+ 	else
+ 		zno = lba / devip->zsize;
+ 	return &devip->zstate[zno];
+ }
+ 
+ static inline bool zbc_zone_is_conv(struct sdeb_zone_state *zsp)
+ {
+ 	return zsp->z_cond == ZBC_NOT_WRITE_POINTER;
+ }
+ 
+ static void zbc_close_zone(struct sdebug_dev_info *devip,
+ 			   struct sdeb_zone_state *zsp)
+ {
+ 	enum sdebug_z_cond zc;
+ 
+ 	if (zbc_zone_is_conv(zsp))
+ 		return;
+ 
+ 	zc = zsp->z_cond;
+ 	if (!(zc == ZC2_IMPLICIT_OPEN || zc == ZC3_EXPLICIT_OPEN))
+ 		return;
+ 
+ 	if (zc == ZC2_IMPLICIT_OPEN)
+ 		devip->nr_imp_open--;
+ 	else
+ 		devip->nr_exp_open--;
+ 
+ 	if (zsp->z_wp == zsp->z_start) {
+ 		zsp->z_cond = ZC1_EMPTY;
+ 	} else {
+ 		zsp->z_cond = ZC4_CLOSED;
+ 		devip->nr_closed++;
+ 	}
+ }
+ 
+ static void zbc_close_imp_open_zone(struct sdebug_dev_info *devip)
+ {
+ 	struct sdeb_zone_state *zsp = &devip->zstate[0];
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < devip->nr_zones; i++, zsp++) {
+ 		if (zsp->z_cond == ZC2_IMPLICIT_OPEN) {
+ 			zbc_close_zone(devip, zsp);
+ 			return;
+ 		}
+ 	}
+ }
+ 
+ static void zbc_open_zone(struct sdebug_dev_info *devip,
+ 			  struct sdeb_zone_state *zsp, bool explicit)
+ {
+ 	enum sdebug_z_cond zc;
+ 
+ 	if (zbc_zone_is_conv(zsp))
+ 		return;
+ 
+ 	zc = zsp->z_cond;
+ 	if ((explicit && zc == ZC3_EXPLICIT_OPEN) ||
+ 	    (!explicit && zc == ZC2_IMPLICIT_OPEN))
+ 		return;
+ 
+ 	/* Close an implicit open zone if necessary */
+ 	if (explicit && zsp->z_cond == ZC2_IMPLICIT_OPEN)
+ 		zbc_close_zone(devip, zsp);
+ 	else if (devip->max_open &&
+ 		 devip->nr_imp_open + devip->nr_exp_open >= devip->max_open)
+ 		zbc_close_imp_open_zone(devip);
+ 
+ 	if (zsp->z_cond == ZC4_CLOSED)
+ 		devip->nr_closed--;
+ 	if (explicit) {
+ 		zsp->z_cond = ZC3_EXPLICIT_OPEN;
+ 		devip->nr_exp_open++;
+ 	} else {
+ 		zsp->z_cond = ZC2_IMPLICIT_OPEN;
+ 		devip->nr_imp_open++;
+ 	}
+ }
+ 
+ static void zbc_inc_wp(struct sdebug_dev_info *devip,
+ 		       unsigned long long lba, unsigned int num)
+ {
+ 	struct sdeb_zone_state *zsp = zbc_zone(devip, lba);
+ 
+ 	if (zbc_zone_is_conv(zsp))
+ 		return;
+ 
+ 	zsp->z_wp += num;
+ 	if (zsp->z_wp >= zsp->z_start + zsp->z_size)
+ 		zsp->z_cond = ZC5_FULL;
+ }
+ 
+ static int check_zbc_access_params(struct scsi_cmnd *scp,
+ 			unsigned long long lba, unsigned int num, bool write)
+ {
+ 	struct scsi_device *sdp = scp->device;
+ 	struct sdebug_dev_info *devip = (struct sdebug_dev_info *)sdp->hostdata;
+ 	struct sdeb_zone_state *zsp = zbc_zone(devip, lba);
+ 	struct sdeb_zone_state *zsp_end = zbc_zone(devip, lba + num - 1);
+ 
+ 	if (!write) {
+ 		/* Reads cannot cross zone types boundaries */
+ 		if (zsp_end != zsp &&
+ 		    zbc_zone_is_conv(zsp) &&
+ 		    !zbc_zone_is_conv(zsp_end)) {
+ 			mk_sense_buffer(scp, ILLEGAL_REQUEST,
+ 					LBA_OUT_OF_RANGE,
+ 					READ_INVDATA_ASCQ);
+ 			return check_condition_result;
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	/* No restrictions for writes within conventional zones */
+ 	if (zbc_zone_is_conv(zsp)) {
+ 		if (!zbc_zone_is_conv(zsp_end)) {
+ 			mk_sense_buffer(scp, ILLEGAL_REQUEST,
+ 					LBA_OUT_OF_RANGE,
+ 					WRITE_BOUNDARY_ASCQ);
+ 			return check_condition_result;
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	/* Writes cannot cross sequential zone boundaries */
+ 	if (zsp_end != zsp) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST,
+ 				LBA_OUT_OF_RANGE,
+ 				WRITE_BOUNDARY_ASCQ);
+ 		return check_condition_result;
+ 	}
+ 	/* Cannot write full zones */
+ 	if (zsp->z_cond == ZC5_FULL) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST,
+ 				INVALID_FIELD_IN_CDB, 0);
+ 		return check_condition_result;
+ 	}
+ 	/* Writes must be aligned to the zone WP */
+ 	if (lba != zsp->z_wp) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST,
+ 				LBA_OUT_OF_RANGE,
+ 				UNALIGNED_WRITE_ASCQ);
+ 		return check_condition_result;
+ 	}
+ 
+ 	/* Handle implicit open of closed and empty zones */
+ 	if (zsp->z_cond == ZC1_EMPTY || zsp->z_cond == ZC4_CLOSED) {
+ 		if (devip->max_open &&
+ 		    devip->nr_exp_open >= devip->max_open) {
+ 			mk_sense_buffer(scp, DATA_PROTECT,
+ 					INSUFF_RES_ASC,
+ 					INSUFF_ZONE_ASCQ);
+ 			return check_condition_result;
+ 		}
+ 		zbc_open_zone(devip, zsp, false);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static inline int check_device_access_params
+ 			(struct scsi_cmnd *scp, unsigned long long lba,
+ 			 unsigned int num, bool write)
+ {
+ 	struct scsi_device *sdp = scp->device;
+ 	struct sdebug_dev_info *devip = (struct sdebug_dev_info *)sdp->hostdata;
+ 
  	if (lba + num > sdebug_capacity) {
  		mk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);
  		return check_condition_result;
@@@ -3061,10 -3411,13 +3359,20 @@@ static int resp_write_dt0(struct scsi_c
  			sdev_printk(KERN_ERR, scp->device, "Unprotected WR "
  				    "to DIF device\n");
  	}
++<<<<<<< HEAD
 +	ret = check_device_access_params(scp, lba, num, true);
 +	if (ret)
 +		return ret;
 +	write_lock_irqsave(&atomic_rw, iflags);
++=======
+ 
+ 	write_lock(macc_lckp);
+ 	ret = check_device_access_params(scp, lba, num, true);
+ 	if (ret) {
+ 		write_unlock(macc_lckp);
+ 		return ret;
+ 	}
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  
  	/* DIX + T10 DIF */
  	if (unlikely(sdebug_dix && scsi_prot_sg_count(scp))) {
@@@ -3077,10 -3430,13 +3385,18 @@@
  		}
  	}
  
 -	ret = do_device_access(sip, scp, 0, lba, num, true);
 +	ret = do_device_access(scp, 0, lba, num, true);
  	if (unlikely(scsi_debug_lbp()))
++<<<<<<< HEAD
 +		map_region(lba, num);
 +	write_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 		map_region(sip, lba, num);
+ 	/* If ZBC zone then bump its write pointer */
+ 	if (sdebug_dev_is_zoned(devip))
+ 		zbc_inc_wp(devip, lba, num);
+ 	write_unlock(macc_lckp);
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  	if (unlikely(-1 == ret))
  		return DID_ERROR << 16;
  	else if (unlikely(sdebug_verbose &&
@@@ -3232,9 -3589,12 +3548,16 @@@ static int resp_write_scat(struct scsi_
  			}
  		}
  
++<<<<<<< HEAD
 +		ret = do_device_access(scp, sg_off, lba, num, true);
++=======
+ 		ret = do_device_access(sip, scp, sg_off, lba, num, true);
+ 		/* If ZBC zone then bump its write pointer */
+ 		if (sdebug_dev_is_zoned(devip))
+ 			zbc_inc_wp(devip, lba, num);
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  		if (unlikely(scsi_debug_lbp()))
 -			map_region(sip, lba, num);
 +			map_region(lba, num);
  		if (unlikely(-1 == ret)) {
  			ret = DID_ERROR << 16;
  			goto err_out_unlock;
@@@ -3281,21 -3641,28 +3604,39 @@@ err_out
  static int resp_write_same(struct scsi_cmnd *scp, u64 lba, u32 num,
  			   u32 ei_lba, bool unmap, bool ndob)
  {
++<<<<<<< HEAD
++=======
+ 	struct scsi_device *sdp = scp->device;
+ 	struct sdebug_dev_info *devip = (struct sdebug_dev_info *)sdp->hostdata;
+ 	unsigned long long i;
+ 	u64 block, lbaa;
+ 	u32 lb_size = sdebug_sector_size;
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  	int ret;
 -	struct sdeb_store_info *sip = devip2sip((struct sdebug_dev_info *)
 -						scp->device->hostdata);
 -	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
 +	unsigned long iflags;
 +	unsigned long long i;
 +	u32 lb_size = sdebug_sector_size;
 +	u64 block, lbaa;
  	u8 *fs1p;
 -	u8 *fsp;
  
++<<<<<<< HEAD
 +	ret = check_device_access_params(scp, lba, num, true);
 +	if (ret)
 +		return ret;
 +
 +	write_lock_irqsave(&atomic_rw, iflags);
++=======
+ 	write_lock(macc_lckp);
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
+ 
+ 	ret = check_device_access_params(scp, lba, num, true);
+ 	if (ret) {
+ 		write_unlock(macc_lckp);
+ 		return ret;
+ 	}
  
  	if (unmap && scsi_debug_lbp()) {
 -		unmap_region(sip, lba, num);
 +		unmap_region(lba, num);
  		goto out;
  	}
  	lbaa = lba;
@@@ -3320,12 -3688,15 +3661,19 @@@
  	for (i = 1 ; i < num ; i++) {
  		lbaa = lba + i;
  		block = do_div(lbaa, sdebug_store_sectors);
 -		memmove(fsp + (block * lb_size), fs1p, lb_size);
 +		memmove(fake_storep + (block * lb_size), fs1p, lb_size);
  	}
  	if (scsi_debug_lbp())
++<<<<<<< HEAD
 +		map_region(lba, num);
++=======
+ 		map_region(sip, lba, num);
+ 	/* If ZBC zone then bump its write pointer */
+ 	if (sdebug_dev_is_zoned(devip))
+ 		zbc_inc_wp(devip, lba, num);
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  out:
 -	write_unlock(macc_lckp);
 +	write_unlock_irqrestore(&atomic_rw, iflags);
  
  	return 0;
  }
@@@ -3730,6 -4147,501 +4078,504 @@@ static int resp_report_luns(struct scsi
  	return res;
  }
  
++<<<<<<< HEAD
++=======
+ static int resp_verify(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)
+ {
+ 	bool is_bytchk3 = false;
+ 	u8 bytchk;
+ 	int ret, j;
+ 	u32 vnum, a_num, off;
+ 	const u32 lb_size = sdebug_sector_size;
+ 	u64 lba;
+ 	u8 *arr;
+ 	u8 *cmd = scp->cmnd;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
+ 
+ 	bytchk = (cmd[1] >> 1) & 0x3;
+ 	if (bytchk == 0) {
+ 		return 0;	/* always claim internal verify okay */
+ 	} else if (bytchk == 2) {
+ 		mk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 2);
+ 		return check_condition_result;
+ 	} else if (bytchk == 3) {
+ 		is_bytchk3 = true;	/* 1 block sent, compared repeatedly */
+ 	}
+ 	switch (cmd[0]) {
+ 	case VERIFY_16:
+ 		lba = get_unaligned_be64(cmd + 2);
+ 		vnum = get_unaligned_be32(cmd + 10);
+ 		break;
+ 	case VERIFY:		/* is VERIFY(10) */
+ 		lba = get_unaligned_be32(cmd + 2);
+ 		vnum = get_unaligned_be16(cmd + 7);
+ 		break;
+ 	default:
+ 		mk_sense_invalid_opcode(scp);
+ 		return check_condition_result;
+ 	}
+ 	a_num = is_bytchk3 ? 1 : vnum;
+ 	/* Treat following check like one for read (i.e. no write) access */
+ 	ret = check_device_access_params(scp, lba, a_num, false);
+ 	if (ret)
+ 		return ret;
+ 
+ 	arr = kcalloc(lb_size, vnum, GFP_ATOMIC);
+ 	if (!arr) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,
+ 				INSUFF_RES_ASCQ);
+ 		return check_condition_result;
+ 	}
+ 	/* Not changing store, so only need read access */
+ 	read_lock(macc_lckp);
+ 
+ 	ret = do_dout_fetch(scp, a_num, arr);
+ 	if (ret == -1) {
+ 		ret = DID_ERROR << 16;
+ 		goto cleanup;
+ 	} else if (sdebug_verbose && (ret < (a_num * lb_size))) {
+ 		sdev_printk(KERN_INFO, scp->device,
+ 			    "%s: %s: cdb indicated=%u, IO sent=%d bytes\n",
+ 			    my_name, __func__, a_num * lb_size, ret);
+ 	}
+ 	if (is_bytchk3) {
+ 		for (j = 1, off = lb_size; j < vnum; ++j, off += lb_size)
+ 			memcpy(arr + off, arr, lb_size);
+ 	}
+ 	ret = 0;
+ 	if (!comp_write_worker(sip, lba, vnum, arr, true)) {
+ 		mk_sense_buffer(scp, MISCOMPARE, MISCOMPARE_VERIFY_ASC, 0);
+ 		ret = check_condition_result;
+ 		goto cleanup;
+ 	}
+ cleanup:
+ 	read_unlock(macc_lckp);
+ 	kfree(arr);
+ 	return ret;
+ }
+ 
+ #define RZONES_DESC_HD 64
+ 
+ /* Report zones depending on start LBA nad reporting options */
+ static int resp_report_zones(struct scsi_cmnd *scp,
+ 			     struct sdebug_dev_info *devip)
+ {
+ 	unsigned int i, max_zones, rep_max_zones, nrz = 0;
+ 	int ret = 0;
+ 	u32 alloc_len, rep_opts, rep_len;
+ 	bool partial;
+ 	u64 lba, zs_lba;
+ 	u8 *arr = NULL, *desc;
+ 	u8 *cmd = scp->cmnd;
+ 	struct sdeb_zone_state *zsp;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
+ 
+ 	if (!sdebug_dev_is_zoned(devip)) {
+ 		mk_sense_invalid_opcode(scp);
+ 		return check_condition_result;
+ 	}
+ 	zs_lba = get_unaligned_be64(cmd + 2);
+ 	alloc_len = get_unaligned_be32(cmd + 10);
+ 	rep_opts = cmd[14] & 0x3f;
+ 	partial = cmd[14] & 0x80;
+ 
+ 	if (zs_lba >= sdebug_capacity) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);
+ 		return check_condition_result;
+ 	}
+ 
+ 	max_zones = devip->nr_zones - zs_lba / devip->zsize;
+ 	rep_max_zones = min((alloc_len - 64) >> ilog2(RZONES_DESC_HD),
+ 			    max_zones);
+ 
+ 	arr = kcalloc(RZONES_DESC_HD, alloc_len, GFP_ATOMIC);
+ 	if (!arr) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,
+ 				INSUFF_RES_ASCQ);
+ 		return check_condition_result;
+ 	}
+ 
+ 	read_lock(macc_lckp);
+ 
+ 	desc = arr + 64;
+ 	for (i = 0; i < max_zones; i++) {
+ 		lba = zs_lba + devip->zsize * i;
+ 		if (lba > sdebug_capacity)
+ 			break;
+ 		zsp = zbc_zone(devip, lba);
+ 		switch (rep_opts) {
+ 		case 0x00:
+ 			/* All zones */
+ 			break;
+ 		case 0x01:
+ 			/* Empty zones */
+ 			if (zsp->z_cond != ZC1_EMPTY)
+ 				continue;
+ 			break;
+ 		case 0x02:
+ 			/* Implicit open zones */
+ 			if (zsp->z_cond != ZC2_IMPLICIT_OPEN)
+ 				continue;
+ 			break;
+ 		case 0x03:
+ 			/* Explicit open zones */
+ 			if (zsp->z_cond != ZC3_EXPLICIT_OPEN)
+ 				continue;
+ 			break;
+ 		case 0x04:
+ 			/* Closed zones */
+ 			if (zsp->z_cond != ZC4_CLOSED)
+ 				continue;
+ 			break;
+ 		case 0x05:
+ 			/* Full zones */
+ 			if (zsp->z_cond != ZC5_FULL)
+ 				continue;
+ 			break;
+ 		case 0x06:
+ 		case 0x07:
+ 		case 0x10:
+ 		case 0x11:
+ 			/*
+ 			 * Read-only, offline, reset WP recommended and
+ 			 * non-seq-resource-used are not emulated: no zones
+ 			 * to report;
+ 			 */
+ 			continue;
+ 		case 0x3f:
+ 			/* Not write pointer (conventional) zones */
+ 			if (!zbc_zone_is_conv(zsp))
+ 				continue;
+ 			break;
+ 		default:
+ 			mk_sense_buffer(scp, ILLEGAL_REQUEST,
+ 					INVALID_FIELD_IN_CDB, 0);
+ 			ret = check_condition_result;
+ 			goto fini;
+ 		}
+ 
+ 		if (nrz < rep_max_zones) {
+ 			/* Fill zone descriptor */
+ 			if (zbc_zone_is_conv(zsp))
+ 				desc[0] = 0x1;
+ 			else
+ 				desc[0] = 0x2;
+ 			desc[1] = zsp->z_cond << 4;
+ 			put_unaligned_be64((u64)zsp->z_size, desc + 8);
+ 			put_unaligned_be64((u64)zsp->z_start, desc + 16);
+ 			put_unaligned_be64((u64)zsp->z_wp, desc + 24);
+ 			desc += 64;
+ 		}
+ 
+ 		if (partial && nrz >= rep_max_zones)
+ 			break;
+ 
+ 		nrz++;
+ 	}
+ 
+ 	/* Report header */
+ 	put_unaligned_be32(nrz * RZONES_DESC_HD, arr + 0);
+ 	put_unaligned_be64(sdebug_capacity - 1, arr + 8);
+ 
+ 	rep_len = (unsigned long)desc - (unsigned long)arr;
+ 	ret = fill_from_dev_buffer(scp, arr, min_t(int, alloc_len, rep_len));
+ 
+ fini:
+ 	read_unlock(macc_lckp);
+ 	kfree(arr);
+ 	return ret;
+ }
+ 
+ /* Logic transplanted from tcmu-runner, file_zbc.c */
+ static void zbc_open_all(struct sdebug_dev_info *devip)
+ {
+ 	struct sdeb_zone_state *zsp = &devip->zstate[0];
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < devip->nr_zones; i++, zsp++) {
+ 		if (zsp->z_cond == ZC4_CLOSED)
+ 			zbc_open_zone(devip, &devip->zstate[i], true);
+ 	}
+ }
+ 
+ static int resp_open_zone(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)
+ {
+ 	int res = 0;
+ 	u64 z_id;
+ 	enum sdebug_z_cond zc;
+ 	u8 *cmd = scp->cmnd;
+ 	struct sdeb_zone_state *zsp;
+ 	bool all = cmd[14] & 0x01;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
+ 
+ 	if (!sdebug_dev_is_zoned(devip)) {
+ 		mk_sense_invalid_opcode(scp);
+ 		return check_condition_result;
+ 	}
+ 
+ 	write_lock(macc_lckp);
+ 
+ 	if (all) {
+ 		/* Check if all closed zones can be open */
+ 		if (devip->max_open &&
+ 		    devip->nr_exp_open + devip->nr_closed > devip->max_open) {
+ 			mk_sense_buffer(scp, DATA_PROTECT, INSUFF_RES_ASC,
+ 					INSUFF_ZONE_ASCQ);
+ 			res = check_condition_result;
+ 			goto fini;
+ 		}
+ 		/* Open all closed zones */
+ 		zbc_open_all(devip);
+ 		goto fini;
+ 	}
+ 
+ 	/* Open the specified zone */
+ 	z_id = get_unaligned_be64(cmd + 2);
+ 	if (z_id >= sdebug_capacity) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	zsp = zbc_zone(devip, z_id);
+ 	if (z_id != zsp->z_start) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 	if (zbc_zone_is_conv(zsp)) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	zc = zsp->z_cond;
+ 	if (zc == ZC3_EXPLICIT_OPEN || zc == ZC5_FULL)
+ 		goto fini;
+ 
+ 	if (devip->max_open && devip->nr_exp_open >= devip->max_open) {
+ 		mk_sense_buffer(scp, DATA_PROTECT, INSUFF_RES_ASC,
+ 				INSUFF_ZONE_ASCQ);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	if (zc == ZC2_IMPLICIT_OPEN)
+ 		zbc_close_zone(devip, zsp);
+ 	zbc_open_zone(devip, zsp, true);
+ fini:
+ 	write_unlock(macc_lckp);
+ 	return res;
+ }
+ 
+ static void zbc_close_all(struct sdebug_dev_info *devip)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < devip->nr_zones; i++)
+ 		zbc_close_zone(devip, &devip->zstate[i]);
+ }
+ 
+ static int resp_close_zone(struct scsi_cmnd *scp,
+ 			   struct sdebug_dev_info *devip)
+ {
+ 	int res = 0;
+ 	u64 z_id;
+ 	u8 *cmd = scp->cmnd;
+ 	struct sdeb_zone_state *zsp;
+ 	bool all = cmd[14] & 0x01;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
+ 
+ 	if (!sdebug_dev_is_zoned(devip)) {
+ 		mk_sense_invalid_opcode(scp);
+ 		return check_condition_result;
+ 	}
+ 
+ 	write_lock(macc_lckp);
+ 
+ 	if (all) {
+ 		zbc_close_all(devip);
+ 		goto fini;
+ 	}
+ 
+ 	/* Close specified zone */
+ 	z_id = get_unaligned_be64(cmd + 2);
+ 	if (z_id >= sdebug_capacity) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	zsp = zbc_zone(devip, z_id);
+ 	if (z_id != zsp->z_start) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 	if (zbc_zone_is_conv(zsp)) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	zbc_close_zone(devip, zsp);
+ fini:
+ 	write_unlock(macc_lckp);
+ 	return res;
+ }
+ 
+ static void zbc_finish_zone(struct sdebug_dev_info *devip,
+ 			    struct sdeb_zone_state *zsp, bool empty)
+ {
+ 	enum sdebug_z_cond zc = zsp->z_cond;
+ 
+ 	if (zc == ZC4_CLOSED || zc == ZC2_IMPLICIT_OPEN ||
+ 	    zc == ZC3_EXPLICIT_OPEN || (empty && zc == ZC1_EMPTY)) {
+ 		if (zc == ZC2_IMPLICIT_OPEN || zc == ZC3_EXPLICIT_OPEN)
+ 			zbc_close_zone(devip, zsp);
+ 		if (zsp->z_cond == ZC4_CLOSED)
+ 			devip->nr_closed--;
+ 		zsp->z_wp = zsp->z_start + zsp->z_size;
+ 		zsp->z_cond = ZC5_FULL;
+ 	}
+ }
+ 
+ static void zbc_finish_all(struct sdebug_dev_info *devip)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < devip->nr_zones; i++)
+ 		zbc_finish_zone(devip, &devip->zstate[i], false);
+ }
+ 
+ static int resp_finish_zone(struct scsi_cmnd *scp,
+ 			    struct sdebug_dev_info *devip)
+ {
+ 	struct sdeb_zone_state *zsp;
+ 	int res = 0;
+ 	u64 z_id;
+ 	u8 *cmd = scp->cmnd;
+ 	bool all = cmd[14] & 0x01;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
+ 
+ 	if (!sdebug_dev_is_zoned(devip)) {
+ 		mk_sense_invalid_opcode(scp);
+ 		return check_condition_result;
+ 	}
+ 
+ 	write_lock(macc_lckp);
+ 
+ 	if (all) {
+ 		zbc_finish_all(devip);
+ 		goto fini;
+ 	}
+ 
+ 	/* Finish the specified zone */
+ 	z_id = get_unaligned_be64(cmd + 2);
+ 	if (z_id >= sdebug_capacity) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	zsp = zbc_zone(devip, z_id);
+ 	if (z_id != zsp->z_start) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 	if (zbc_zone_is_conv(zsp)) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	zbc_finish_zone(devip, zsp, true);
+ fini:
+ 	write_unlock(macc_lckp);
+ 	return res;
+ }
+ 
+ static void zbc_rwp_zone(struct sdebug_dev_info *devip,
+ 			 struct sdeb_zone_state *zsp)
+ {
+ 	enum sdebug_z_cond zc;
+ 
+ 	if (zbc_zone_is_conv(zsp))
+ 		return;
+ 
+ 	zc = zsp->z_cond;
+ 	if (zc == ZC2_IMPLICIT_OPEN || zc == ZC3_EXPLICIT_OPEN)
+ 		zbc_close_zone(devip, zsp);
+ 
+ 	if (zsp->z_cond == ZC4_CLOSED)
+ 		devip->nr_closed--;
+ 
+ 	zsp->z_wp = zsp->z_start;
+ 	zsp->z_cond = ZC1_EMPTY;
+ }
+ 
+ static void zbc_rwp_all(struct sdebug_dev_info *devip)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < devip->nr_zones; i++)
+ 		zbc_rwp_zone(devip, &devip->zstate[i]);
+ }
+ 
+ static int resp_rwp_zone(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)
+ {
+ 	struct sdeb_zone_state *zsp;
+ 	int res = 0;
+ 	u64 z_id;
+ 	u8 *cmd = scp->cmnd;
+ 	bool all = cmd[14] & 0x01;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
+ 
+ 	if (!sdebug_dev_is_zoned(devip)) {
+ 		mk_sense_invalid_opcode(scp);
+ 		return check_condition_result;
+ 	}
+ 
+ 	write_lock(macc_lckp);
+ 
+ 	if (all) {
+ 		zbc_rwp_all(devip);
+ 		goto fini;
+ 	}
+ 
+ 	z_id = get_unaligned_be64(cmd + 2);
+ 	if (z_id >= sdebug_capacity) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	zsp = zbc_zone(devip, z_id);
+ 	if (z_id != zsp->z_start) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 	if (zbc_zone_is_conv(zsp)) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		res = check_condition_result;
+ 		goto fini;
+ 	}
+ 
+ 	zbc_rwp_zone(devip, zsp);
+ fini:
+ 	write_unlock(macc_lckp);
+ 	return res;
+ }
+ 
++>>>>>>> f0d1cf9378bd (scsi: scsi_debug: Add ZBC zone commands)
  static struct sdebug_queue *get_queue(struct scsi_cmnd *cmnd)
  {
  	u32 tag = blk_mq_unique_tag(cmnd->request);
@@@ -5550,10 -6784,11 +6489,11 @@@ clean
  	list_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,
  				 dev_list) {
  		list_del(&sdbg_devinfo->dev_list);
+ 		kfree(sdbg_devinfo->zstate);
  		kfree(sdbg_devinfo);
  	}
 +
  	kfree(sdbg_host);
 -	pr_warn("%s: failed, errno=%d\n", __func__, -error);
  	return error;
  }
  
* Unmerged path drivers/scsi/scsi_debug.c
