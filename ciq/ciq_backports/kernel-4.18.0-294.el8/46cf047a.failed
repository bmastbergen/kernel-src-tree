procfs: set ->user_ns before calling ->get_tree()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 46cf047a945c7a53cb2dc9353a87a9a4e3e778cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/46cf047a.failed

here it's even simpler than in mqueue - pid_ns_prepare_proc()
does everything needed anyway.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 46cf047a945c7a53cb2dc9353a87a9a4e3e778cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/root.c
diff --cc fs/proc/root.c
index f4b1a9d2eca6,74c2c6ab10bd..000000000000
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@@ -83,22 -100,96 +83,58 @@@ int proc_remount(struct super_block *sb
  	struct pid_namespace *pid = sb->s_fs_info;
  
  	sync_filesystem(sb);
 -
 -	proc_apply_options(sb, fc, pid, current_user_ns());
 -	return 0;
 +	return !proc_parse_options(data, pid);
  }
  
 -static int proc_get_tree(struct fs_context *fc)
 +static struct dentry *proc_mount(struct file_system_type *fs_type,
 +	int flags, const char *dev_name, void *data)
  {
 -	struct proc_fs_context *ctx = fc->fs_private;
 +	struct pid_namespace *ns;
 +
++<<<<<<< HEAD
 +	if (flags & SB_KERNMOUNT) {
 +		ns = data;
 +		data = NULL;
 +	} else {
 +		ns = task_active_pid_ns(current);
 +	}
  
 +	return mount_ns(fs_type, flags, data, ns, ns->user_ns, proc_fill_super);
++=======
+ 	fc->s_fs_info = ctx->pid_ns;
+ 	return vfs_get_super(fc, vfs_get_keyed_super, proc_fill_super);
+ }
+ 
+ static void proc_fs_context_free(struct fs_context *fc)
+ {
+ 	struct proc_fs_context *ctx = fc->fs_private;
+ 
+ 	put_pid_ns(ctx->pid_ns);
+ 	kfree(ctx);
+ }
+ 
+ static const struct fs_context_operations proc_fs_context_ops = {
+ 	.free		= proc_fs_context_free,
+ 	.parse_param	= proc_parse_param,
+ 	.get_tree	= proc_get_tree,
+ 	.reconfigure	= proc_reconfigure,
+ };
+ 
+ static int proc_init_fs_context(struct fs_context *fc)
+ {
+ 	struct proc_fs_context *ctx;
+ 
+ 	ctx = kzalloc(sizeof(struct proc_fs_context), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	ctx->pid_ns = get_pid_ns(task_active_pid_ns(current));
+ 	put_user_ns(fc->user_ns);
+ 	fc->user_ns = get_user_ns(ctx->pid_ns->user_ns);
+ 	fc->fs_private = ctx;
+ 	fc->ops = &proc_fs_context_ops;
+ 	return 0;
++>>>>>>> 46cf047a945c (procfs: set ->user_ns before calling ->get_tree())
  }
  
  static void proc_kill_sb(struct super_block *sb)
* Unmerged path fs/proc/root.c
