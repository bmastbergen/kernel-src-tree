x86/db: Split out dr6/7 handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] db: Split out dr6/7 handling (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 93.33%
commit-author Peter Zijlstra <peterz@infradead.org>
commit 9f58fdde95c9509a4ded27a6d0035e79294002b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9f58fdde.failed

DR6/7 should be handled before nmi_enter() is invoked and restore after
nmi_exit() to minimize the exposure.

Split it out into helper inlines and bring it into the correct order.

	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Alexandre Chartre <alexandre.chartre@oracle.com>
	Acked-by: Andy Lutomirski <luto@kernel.org>
Link: https://lkml.kernel.org/r/20200505135314.808628211@linutronix.de




(cherry picked from commit 9f58fdde95c9509a4ded27a6d0035e79294002b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/traps.c
diff --cc arch/x86/kernel/traps.c
index bceb85be1c08,de5120e2fbe1..000000000000
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@@ -734,28 -778,13 +785,17 @@@ static __always_inline void debug_exit(
  dotraplinkage void do_debug(struct pt_regs *regs, long error_code)
  {
  	struct task_struct *tsk = current;
+ 	unsigned long dr6, dr7;
  	int user_icebp = 0;
- 	unsigned long dr6;
  	int si_code;
  
++<<<<<<< HEAD
 +	ist_enter(regs);
++=======
+ 	debug_enter(&dr6, &dr7);
  
- 	get_debugreg(dr6, 6);
- 	/*
- 	 * The Intel SDM says:
- 	 *
- 	 *   Certain debug exceptions may clear bits 0-3. The remaining
- 	 *   contents of the DR6 register are never cleared by the
- 	 *   processor. To avoid confusion in identifying debug
- 	 *   exceptions, debug handlers should clear the register before
- 	 *   returning to the interrupted task.
- 	 *
- 	 * Keep it simple: clear DR6 immediately.
- 	 */
- 	set_debugreg(0, 6);
- 
- 	/* Filter out all the reserved bits which are preset to 1 */
- 	dr6 &= ~DR6_RESERVED;
+ 	nmi_enter();
++>>>>>>> 9f58fdde95c9 (x86/db: Split out dr6/7 handling)
  
  	/*
  	 * The SDM says "The processor clears the BTF flag when it
@@@ -831,7 -860,8 +871,12 @@@
  	debug_stack_usage_dec();
  
  exit:
++<<<<<<< HEAD
 +	ist_exit(regs);
++=======
+ 	nmi_exit();
+ 	debug_exit(dr7);
++>>>>>>> 9f58fdde95c9 (x86/db: Split out dr6/7 handling)
  }
  NOKPROBE_SYMBOL(do_debug);
  
diff --git a/arch/x86/kernel/hw_breakpoint.c b/arch/x86/kernel/hw_breakpoint.c
index 34a5c1715148..94103dc59484 100644
--- a/arch/x86/kernel/hw_breakpoint.c
+++ b/arch/x86/kernel/hw_breakpoint.c
@@ -453,7 +453,7 @@ static int hw_breakpoint_handler(struct die_args *args)
 {
 	int i, cpu, rc = NOTIFY_STOP;
 	struct perf_event *bp;
-	unsigned long dr7, dr6;
+	unsigned long dr6;
 	unsigned long *dr6_p;
 
 	/* The DR6 value is pointed by args->err */
@@ -468,9 +468,6 @@ static int hw_breakpoint_handler(struct die_args *args)
 	if ((dr6 & DR_TRAP_BITS) == 0)
 		return NOTIFY_DONE;
 
-	get_debugreg(dr7, 7);
-	/* Disable breakpoints during exception handling */
-	set_debugreg(0UL, 7);
 	/*
 	 * Assert that local interrupts are disabled
 	 * Reset the DRn bits in the virtualized register value.
@@ -527,7 +524,6 @@ static int hw_breakpoint_handler(struct die_args *args)
 	    (dr6 & (~DR_TRAP_BITS)))
 		rc = NOTIFY_DONE;
 
-	set_debugreg(dr7, 7);
 	put_cpu();
 
 	return rc;
* Unmerged path arch/x86/kernel/traps.c
