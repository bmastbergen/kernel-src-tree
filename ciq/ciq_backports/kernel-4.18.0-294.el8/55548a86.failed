powerpc/mm: Limit resize_hpt_for_hotplug() call to hash guests only

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Bharata B Rao <bharata@linux.ibm.com>
commit 55548a86ebde2b3691b6a84baef1b02933408994
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/55548a86.failed

During memory hotplug and unplug, resize_hpt_for_hotplug() gets called
for both hash and radix guests but it should be called only for hash
guests. Though the call does nothing in the radix guest case, it is
cleaner to push this call into hash specific memory hotplug routines.

	Reported-by: Nathan Lynch <nathanl@linux.ibm.com>
	Signed-off-by: Bharata B Rao <bharata@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200727095704.1432916-1-bharata@linux.ibm.com
(cherry picked from commit 55548a86ebde2b3691b6a84baef1b02933408994)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/mm/book3s64/hash_utils.c
diff --cc arch/powerpc/mm/book3s64/hash_utils.c
index c7f37e28c477,30a4a91d9987..000000000000
--- a/arch/powerpc/mm/book3s64/hash_utils.c
+++ b/arch/powerpc/mm/book3s64/hash_utils.c
@@@ -804,11 -809,21 +804,26 @@@ static int resize_hpt_for_hotplug(unsig
  	return 0;
  }
  
 -int hash__create_section_mapping(unsigned long start, unsigned long end,
 -				 int nid, pgprot_t prot)
 +int hash__create_section_mapping(unsigned long start, unsigned long end, int nid)
  {
++<<<<<<< HEAD
 +	int rc = htab_bolt_mapping(start, end, __pa(start),
 +				   pgprot_val(PAGE_KERNEL), mmu_linear_psize,
 +				   mmu_kernel_ssize);
++=======
+ 	int rc;
+ 
+ 	if (end >= H_VMALLOC_START) {
+ 		pr_warn("Outside the supported range\n");
+ 		return -1;
+ 	}
+ 
+ 	resize_hpt_for_hotplug(memblock_phys_mem_size());
+ 
+ 	rc = htab_bolt_mapping(start, end, __pa(start),
+ 			       pgprot_val(prot), mmu_linear_psize,
+ 			       mmu_kernel_ssize);
++>>>>>>> 55548a86ebde (powerpc/mm: Limit resize_hpt_for_hotplug() call to hash guests only)
  
  	if (rc < 0) {
  		int rc2 = htab_remove_mapping(start, end, mmu_linear_psize,
diff --git a/arch/powerpc/include/asm/sparsemem.h b/arch/powerpc/include/asm/sparsemem.h
index b37c802d669c..8bfe9cc09dcf 100644
--- a/arch/powerpc/include/asm/sparsemem.h
+++ b/arch/powerpc/include/asm/sparsemem.h
@@ -27,12 +27,6 @@
 extern int create_section_mapping(unsigned long start, unsigned long end, int nid);
 extern int remove_section_mapping(unsigned long start, unsigned long end);
 
-#ifdef CONFIG_PPC_BOOK3S_64
-extern int resize_hpt_for_hotplug(unsigned long new_mem_size);
-#else
-static inline int resize_hpt_for_hotplug(unsigned long new_mem_size) { return 0; }
-#endif
-
 #ifdef CONFIG_NUMA
 extern int hot_add_scn_to_nid(unsigned long scn_addr);
 #else
* Unmerged path arch/powerpc/mm/book3s64/hash_utils.c
diff --git a/arch/powerpc/mm/mem.c b/arch/powerpc/mm/mem.c
index fa9ce75915ae..7f9d32a73e6f 100644
--- a/arch/powerpc/mm/mem.c
+++ b/arch/powerpc/mm/mem.c
@@ -143,8 +143,6 @@ int __ref arch_add_memory(int nid, u64 start, u64 size,
 	unsigned long nr_pages = size >> PAGE_SHIFT;
 	int rc;
 
-	resize_hpt_for_hotplug(memblock_phys_mem_size());
-
 	start = (unsigned long)__va(start);
 	rc = create_section_mapping(start, start + size, nid);
 	if (rc) {
@@ -176,9 +174,6 @@ void __ref arch_remove_memory(int nid, u64 start, u64 size,
 	 * hit that section of memory
 	 */
 	vm_unmap_aliases();
-
-	if (resize_hpt_for_hotplug(memblock_phys_mem_size()) == -ENOSPC)
-		pr_warn("Hash collision while resizing HPT\n");
 }
 #endif
 
