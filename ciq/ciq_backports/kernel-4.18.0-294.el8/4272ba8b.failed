net: atlantic: per-TC queue statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mark Starovoytov <mstarovoitov@marvell.com>
commit 4272ba8b11f88be8daca5e2477bfe110145d559c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4272ba8b.failed

This patch adds support for per-TC queue statistics.

By default (single TC), the output is the same as it used to be, e.g.:
     Queue[0] InPackets: 2
     Queue[0] OutPackets: 8
     Queue[0] Restarts: 0
     Queue[0] InJumboPackets: 0
     Queue[0] InLroPackets: 0
     Queue[0] InErrors: 0

If several TCs are enabled, then each queue statistics line is prefixed
with TC number, e.g.:
     TC0 Queue[0] InPackets: 6
     TC0 Queue[0] OutPackets: 11
Queue numbering is end-to-end, so:
     TC1 Queue[4] InPackets: 0
     TC1 Queue[4] OutPackets: 22

	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4272ba8b11f88be8daca5e2477bfe110145d559c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
index a64230722f5c,440a7d129848..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
@@@ -83,15 -88,102 +83,105 @@@ static const char aq_ethtool_stat_names
  	"InDroppedDma",
  };
  
- static const char aq_ethtool_queue_stat_names[][ETH_GSTRING_LEN] = {
- 	"Queue[%d] InPackets",
- 	"Queue[%d] OutPackets",
- 	"Queue[%d] Restarts",
- 	"Queue[%d] InJumboPackets",
- 	"Queue[%d] InLroPackets",
- 	"Queue[%d] InErrors",
+ static const char * const aq_ethtool_queue_stat_names[] = {
+ 	"%sQueue[%d] InPackets",
+ 	"%sQueue[%d] OutPackets",
+ 	"%sQueue[%d] Restarts",
+ 	"%sQueue[%d] InJumboPackets",
+ 	"%sQueue[%d] InLroPackets",
+ 	"%sQueue[%d] InErrors",
  };
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_MACSEC)
+ static const char aq_macsec_stat_names[][ETH_GSTRING_LEN] = {
+ 	"MACSec InCtlPackets",
+ 	"MACSec InTaggedMissPackets",
+ 	"MACSec InUntaggedMissPackets",
+ 	"MACSec InNotagPackets",
+ 	"MACSec InUntaggedPackets",
+ 	"MACSec InBadTagPackets",
+ 	"MACSec InNoSciPackets",
+ 	"MACSec InUnknownSciPackets",
+ 	"MACSec InCtrlPortPassPackets",
+ 	"MACSec InUnctrlPortPassPackets",
+ 	"MACSec InCtrlPortFailPackets",
+ 	"MACSec InUnctrlPortFailPackets",
+ 	"MACSec InTooLongPackets",
+ 	"MACSec InIgpocCtlPackets",
+ 	"MACSec InEccErrorPackets",
+ 	"MACSec InUnctrlHitDropRedir",
+ 	"MACSec OutCtlPackets",
+ 	"MACSec OutUnknownSaPackets",
+ 	"MACSec OutUntaggedPackets",
+ 	"MACSec OutTooLong",
+ 	"MACSec OutEccErrorPackets",
+ 	"MACSec OutUnctrlHitDropRedir",
+ };
+ 
+ static const char *aq_macsec_txsc_stat_names[] = {
+ 	"MACSecTXSC%d ProtectedPkts",
+ 	"MACSecTXSC%d EncryptedPkts",
+ 	"MACSecTXSC%d ProtectedOctets",
+ 	"MACSecTXSC%d EncryptedOctets",
+ };
+ 
+ static const char *aq_macsec_txsa_stat_names[] = {
+ 	"MACSecTXSC%dSA%d HitDropRedirect",
+ 	"MACSecTXSC%dSA%d Protected2Pkts",
+ 	"MACSecTXSC%dSA%d ProtectedPkts",
+ 	"MACSecTXSC%dSA%d EncryptedPkts",
+ };
+ 
+ static const char *aq_macsec_rxsa_stat_names[] = {
+ 	"MACSecRXSC%dSA%d UntaggedHitPkts",
+ 	"MACSecRXSC%dSA%d CtrlHitDrpRedir",
+ 	"MACSecRXSC%dSA%d NotUsingSa",
+ 	"MACSecRXSC%dSA%d UnusedSa",
+ 	"MACSecRXSC%dSA%d NotValidPkts",
+ 	"MACSecRXSC%dSA%d InvalidPkts",
+ 	"MACSecRXSC%dSA%d OkPkts",
+ 	"MACSecRXSC%dSA%d LatePkts",
+ 	"MACSecRXSC%dSA%d DelayedPkts",
+ 	"MACSecRXSC%dSA%d UncheckedPkts",
+ 	"MACSecRXSC%dSA%d ValidatedOctets",
+ 	"MACSecRXSC%dSA%d DecryptedOctets",
+ };
+ #endif
+ 
+ static const char aq_ethtool_priv_flag_names[][ETH_GSTRING_LEN] = {
+ 	"DMASystemLoopback",
+ 	"PKTSystemLoopback",
+ 	"DMANetworkLoopback",
+ 	"PHYInternalLoopback",
+ 	"PHYExternalLoopback",
+ };
+ 
+ static u32 aq_ethtool_n_stats(struct net_device *ndev)
+ {
+ 	struct aq_nic_s *nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(nic);
+ 	u32 n_stats = ARRAY_SIZE(aq_ethtool_stat_names) +
+ 		      ARRAY_SIZE(aq_ethtool_queue_stat_names) * cfg->vecs *
+ 			cfg->tcs;
+ 
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 	if (nic->macsec_cfg) {
+ 		n_stats += ARRAY_SIZE(aq_macsec_stat_names) +
+ 			   ARRAY_SIZE(aq_macsec_txsc_stat_names) *
+ 				   aq_macsec_tx_sc_cnt(nic) +
+ 			   ARRAY_SIZE(aq_macsec_txsa_stat_names) *
+ 				   aq_macsec_tx_sa_cnt(nic) +
+ 			   ARRAY_SIZE(aq_macsec_rxsa_stat_names) *
+ 				   aq_macsec_rx_sa_cnt(nic);
+ 	}
+ #endif
+ 
+ 	return n_stats;
+ }
+ 
++>>>>>>> 4272ba8b11f8 (net: atlantic: per-TC queue statistics)
  static void aq_ethtool_stats(struct net_device *ndev,
  			     struct ethtool_stats *stats, u64 *data)
  {
@@@ -132,24 -224,101 +222,111 @@@ static void aq_ethtool_get_drvinfo(stru
  static void aq_ethtool_get_strings(struct net_device *ndev,
  				   u32 stringset, u8 *data)
  {
++<<<<<<< HEAD
++=======
+ 	struct aq_nic_s *nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg;
+ 	u8 *p = data;
++>>>>>>> 4272ba8b11f8 (net: atlantic: per-TC queue statistics)
  	int i, si;
 -#if IS_ENABLED(CONFIG_MACSEC)
 -	int sa;
 -#endif
 +	struct aq_nic_s *aq_nic = netdev_priv(ndev);
 +	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
 +	u8 *p = data;
  
++<<<<<<< HEAD
 +	if (stringset == ETH_SS_STATS) {
++=======
+ 	cfg = aq_nic_get_cfg(nic);
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS: {
+ 		const int stat_cnt = ARRAY_SIZE(aq_ethtool_queue_stat_names);
+ 		char tc_string[8];
+ 		int tc;
+ 
+ 		memset(tc_string, 0, sizeof(tc_string));
++>>>>>>> 4272ba8b11f8 (net: atlantic: per-TC queue statistics)
  		memcpy(p, aq_ethtool_stat_names,
  		       sizeof(aq_ethtool_stat_names));
  		p = p + sizeof(aq_ethtool_stat_names);
- 		for (i = 0; i < cfg->vecs; i++) {
+ 
+ 		for (tc = 0; tc < cfg->tcs; tc++) {
+ 			if (cfg->is_qos)
+ 				snprintf(tc_string, 8, "TC%d ", tc);
+ 
+ 			for (i = 0; i < cfg->vecs; i++) {
+ 				for (si = 0; si < stat_cnt; si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 					     aq_ethtool_queue_stat_names[si],
+ 					     tc_string,
+ 					     AQ_NIC_TCVEC2RING(nic, tc, i));
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 			}
+ 		}
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_MACSEC)
+ 		if (!nic->macsec_cfg)
+ 			break;
+ 
+ 		memcpy(p, aq_macsec_stat_names, sizeof(aq_macsec_stat_names));
+ 		p = p + sizeof(aq_macsec_stat_names);
+ 		for (i = 0; i < AQ_MACSEC_MAX_SC; i++) {
+ 			struct aq_macsec_txsc *aq_txsc;
+ 
+ 			if (!(test_bit(i, &nic->macsec_cfg->txsc_idx_busy)))
+ 				continue;
+ 
  			for (si = 0;
- 				si < ARRAY_SIZE(aq_ethtool_queue_stat_names);
+ 				si < ARRAY_SIZE(aq_macsec_txsc_stat_names);
  				si++) {
  				snprintf(p, ETH_GSTRING_LEN,
- 					 aq_ethtool_queue_stat_names[si], i);
+ 					 aq_macsec_txsc_stat_names[si], i);
  				p += ETH_GSTRING_LEN;
  			}
+ 			aq_txsc = &nic->macsec_cfg->aq_txsc[i];
+ 			for (sa = 0; sa < MACSEC_NUM_AN; sa++) {
+ 				if (!(test_bit(sa, &aq_txsc->tx_sa_idx_busy)))
+ 					continue;
+ 				for (si = 0;
+ 				     si < ARRAY_SIZE(aq_macsec_txsa_stat_names);
+ 				     si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 						 aq_macsec_txsa_stat_names[si],
+ 						 i, sa);
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 			}
+ 		}
+ 		for (i = 0; i < AQ_MACSEC_MAX_SC; i++) {
+ 			struct aq_macsec_rxsc *aq_rxsc;
+ 
+ 			if (!(test_bit(i, &nic->macsec_cfg->rxsc_idx_busy)))
+ 				continue;
+ 
+ 			aq_rxsc = &nic->macsec_cfg->aq_rxsc[i];
+ 			for (sa = 0; sa < MACSEC_NUM_AN; sa++) {
+ 				if (!(test_bit(sa, &aq_rxsc->rx_sa_idx_busy)))
+ 					continue;
+ 				for (si = 0;
+ 				     si < ARRAY_SIZE(aq_macsec_rxsa_stat_names);
+ 				     si++) {
+ 					snprintf(p, ETH_GSTRING_LEN,
+ 						 aq_macsec_rxsa_stat_names[si],
+ 						 i, sa);
+ 					p += ETH_GSTRING_LEN;
+ 				}
+ 			}
  		}
+ #endif
+ 		break;
+ 	}
+ 	case ETH_SS_PRIV_FLAGS:
+ 		memcpy(p, aq_ethtool_priv_flag_names,
+ 		       sizeof(aq_ethtool_priv_flag_names));
+ 		break;
++>>>>>>> 4272ba8b11f8 (net: atlantic: per-TC queue statistics)
  	}
  }
  
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index ed7d344e3ed7,851f22aadea1..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -717,12 -849,13 +717,18 @@@ int aq_nic_get_regs_count(struct aq_nic
  	return self->aq_nic_cfg.aq_hw_caps->mac_regs_count;
  }
  
 -u64 *aq_nic_get_stats(struct aq_nic_s *self, u64 *data)
 +void aq_nic_get_stats(struct aq_nic_s *self, u64 *data)
  {
 +	unsigned int i = 0U;
 +	unsigned int count = 0U;
  	struct aq_vec_s *aq_vec = NULL;
  	struct aq_stats_s *stats;
++<<<<<<< HEAD
++=======
+ 	unsigned int count = 0U;
+ 	unsigned int i = 0U;
+ 	unsigned int tc;
++>>>>>>> 4272ba8b11f8 (net: atlantic: per-TC queue statistics)
  
  	if (self->aq_fw_ops->update_stats) {
  		mutex_lock(&self->fwreq_mutex);
@@@ -761,13 -894,19 +767,16 @@@
  
  	data += i;
  
- 	for (i = 0U, aq_vec = self->aq_vec[0];
- 		aq_vec && self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i]) {
- 		data += count;
- 		aq_vec_get_sw_stats(aq_vec, data, &count);
+ 	for (tc = 0U; tc < self->aq_nic_cfg.tcs; tc++) {
+ 		for (i = 0U, aq_vec = self->aq_vec[0];
+ 		     aq_vec && self->aq_vecs > i;
+ 		     ++i, aq_vec = self->aq_vec[i]) {
+ 			data += count;
+ 			aq_vec_get_sw_stats(aq_vec, tc, data, &count);
+ 		}
  	}
  
 -	data += count;
 -
  err_exit:;
 -	return data;
  }
  
  static void aq_nic_update_ndev_stats(struct aq_nic_s *self)
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_vec.c b/drivers/net/ethernet/aquantia/atlantic/aq_vec.c
index e9e3905626ba..c864d008d8f3 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_vec.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_vec.c
@@ -334,16 +334,14 @@ cpumask_t *aq_vec_get_affinity_mask(struct aq_vec_s *self)
 	return &self->aq_ring_param.affinity_mask;
 }
 
-void aq_vec_add_stats(struct aq_vec_s *self,
-		      struct aq_ring_stats_rx_s *stats_rx,
-		      struct aq_ring_stats_tx_s *stats_tx)
+static void aq_vec_add_stats(struct aq_vec_s *self,
+			     const unsigned int tc,
+			     struct aq_ring_stats_rx_s *stats_rx,
+			     struct aq_ring_stats_tx_s *stats_tx)
 {
-	struct aq_ring_s *ring = NULL;
-	unsigned int r = 0U;
+	struct aq_ring_s *ring = self->ring[tc];
 
-	for (r = 0U, ring = self->ring[0];
-		self->tx_rings > r; ++r, ring = self->ring[r]) {
-		struct aq_ring_stats_tx_s *tx = &ring[AQ_VEC_TX_ID].stats.tx;
+	if (tc < self->rx_rings) {
 		struct aq_ring_stats_rx_s *rx = &ring[AQ_VEC_RX_ID].stats.rx;
 
 		stats_rx->packets += rx->packets;
@@ -354,6 +352,10 @@ void aq_vec_add_stats(struct aq_vec_s *self,
 		stats_rx->pg_losts += rx->pg_losts;
 		stats_rx->pg_flips += rx->pg_flips;
 		stats_rx->pg_reuses += rx->pg_reuses;
+	}
+
+	if (tc < self->tx_rings) {
+		struct aq_ring_stats_tx_s *tx = &ring[AQ_VEC_TX_ID].stats.tx;
 
 		stats_tx->packets += tx->packets;
 		stats_tx->bytes += tx->bytes;
@@ -362,7 +364,8 @@ void aq_vec_add_stats(struct aq_vec_s *self,
 	}
 }
 
-int aq_vec_get_sw_stats(struct aq_vec_s *self, u64 *data, unsigned int *p_count)
+int aq_vec_get_sw_stats(struct aq_vec_s *self, const unsigned int tc, u64 *data,
+			unsigned int *p_count)
 {
 	unsigned int count = 0U;
 	struct aq_ring_stats_rx_s stats_rx;
@@ -370,7 +373,8 @@ int aq_vec_get_sw_stats(struct aq_vec_s *self, u64 *data, unsigned int *p_count)
 
 	memset(&stats_rx, 0U, sizeof(struct aq_ring_stats_rx_s));
 	memset(&stats_tx, 0U, sizeof(struct aq_ring_stats_tx_s));
-	aq_vec_add_stats(self, &stats_rx, &stats_tx);
+
+	aq_vec_add_stats(self, tc, &stats_rx, &stats_tx);
 
 	/* This data should mimic aq_ethtool_queue_stat_names structure
 	 */
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_vec.h b/drivers/net/ethernet/aquantia/atlantic/aq_vec.h
index 8bdf60bb3f63..9995ad17b3f8 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_vec.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_vec.h
@@ -35,10 +35,7 @@ void aq_vec_free(struct aq_vec_s *self);
 int aq_vec_start(struct aq_vec_s *self);
 void aq_vec_stop(struct aq_vec_s *self);
 cpumask_t *aq_vec_get_affinity_mask(struct aq_vec_s *self);
-int aq_vec_get_sw_stats(struct aq_vec_s *self, u64 *data,
+int aq_vec_get_sw_stats(struct aq_vec_s *self, const unsigned int tc, u64 *data,
 			unsigned int *p_count);
-void aq_vec_add_stats(struct aq_vec_s *self,
-		      struct aq_ring_stats_rx_s *stats_rx,
-		      struct aq_ring_stats_tx_s *stats_tx);
 
 #endif /* AQ_VEC_H */
