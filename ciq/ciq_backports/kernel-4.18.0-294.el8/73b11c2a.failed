bpf: Add support for forced LINK_DETACH command

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 73b11c2ab072d5b0599d1e12cc126f55ee306daf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/73b11c2a.failed

Add LINK_DETACH command to force-detach bpf_link without destroying it. It has
the same behavior as auto-detaching of bpf_link due to cgroup dying for
bpf_cgroup_link or net_device being destroyed for bpf_xdp_link. In such case,
bpf_link is still a valid kernel object, but is defuncts and doesn't hold BPF
program attached to corresponding BPF hook. This functionality allows users
with enough access rights to manually force-detach attached bpf_link without
killing respective owner process.

This patch implements LINK_DETACH for cgroup, xdp, and netns links, mostly
re-using existing link release handling code.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Song Liu <songliubraving@fb.com>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/20200731182830.286260-2-andriin@fb.com
(cherry picked from commit 73b11c2ab072d5b0599d1e12cc126f55ee306daf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/net_namespace.c
#	kernel/bpf/syscall.c
#	net/core/dev.c
diff --cc include/uapi/linux/bpf.h
index 55fe65639ff2,b134e679e9db..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -115,6 -115,9 +115,12 @@@ enum bpf_cmd 
  	BPF_LINK_UPDATE,
  	BPF_LINK_GET_FD_BY_ID,
  	BPF_LINK_GET_NEXT_ID,
++<<<<<<< HEAD
++=======
+ 	BPF_ENABLE_STATS,
+ 	BPF_ITER_CREATE,
+ 	BPF_LINK_DETACH,
++>>>>>>> 73b11c2ab072 (bpf: Add support for forced LINK_DETACH command)
  };
  
  enum bpf_map_type {
@@@ -618,7 -635,19 +624,23 @@@ union bpf_attr 
  		__u32		old_prog_fd;
  	} link_update;
  
++<<<<<<< HEAD
 +#endif /* __GENKSYMS__ */
++=======
+ 	struct {
+ 		__u32		link_fd;
+ 	} link_detach;
+ 
+ 	struct { /* struct used by BPF_ENABLE_STATS command */
+ 		__u32		type;
+ 	} enable_stats;
+ 
+ 	struct { /* struct used by BPF_ITER_CREATE command */
+ 		__u32		link_fd;
+ 		__u32		flags;
+ 	} iter_create;
+ 
++>>>>>>> 73b11c2ab072 (bpf: Add support for forced LINK_DETACH command)
  } __attribute__((aligned(8)));
  
  /* The description below is an attempt at providing documentation to eBPF
diff --cc kernel/bpf/syscall.c
index 124e66325086,2f343ce15747..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -4082,6 -4257,15 +4105,18 @@@ SYSCALL_DEFINE3(bpf, int, cmd, union bp
  		err = bpf_obj_get_next_id(&attr, uattr,
  					  &link_idr, &link_idr_lock);
  		break;
++<<<<<<< HEAD
++=======
+ 	case BPF_ENABLE_STATS:
+ 		err = bpf_enable_stats(&attr);
+ 		break;
+ 	case BPF_ITER_CREATE:
+ 		err = bpf_iter_create(&attr);
+ 		break;
+ 	case BPF_LINK_DETACH:
+ 		err = link_detach(&attr);
+ 		break;
++>>>>>>> 73b11c2ab072 (bpf: Add support for forced LINK_DETACH command)
  	default:
  		err = -EINVAL;
  		break;
diff --cc net/core/dev.c
index 2404a0d99788,c8b911b10187..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -8284,30 -8813,318 +8284,329 @@@ static int dev_xdp_install(struct net_d
  
  static void dev_xdp_uninstall(struct net_device *dev)
  {
 -	struct bpf_xdp_link *link;
 -	struct bpf_prog *prog;
 -	enum bpf_xdp_mode mode;
 -	bpf_op_t bpf_op;
 +	struct netdev_bpf xdp;
 +	bpf_op_t ndo_bpf;
  
 -	ASSERT_RTNL();
 +	/* Remove generic XDP */
 +	WARN_ON(dev_xdp_install(dev, generic_xdp_install, NULL, 0, NULL));
  
 -	for (mode = XDP_MODE_SKB; mode < __MAX_XDP_MODE; mode++) {
 -		prog = dev_xdp_prog(dev, mode);
 -		if (!prog)
 -			continue;
 -
 -		bpf_op = dev_xdp_bpf_op(dev, mode);
 -		if (!bpf_op)
 -			continue;
 +	/* Remove from the driver */
 +	ndo_bpf = dev->netdev_ops->ndo_bpf;
 +	if (!ndo_bpf)
 +		return;
  
 +	memset(&xdp, 0, sizeof(xdp));
 +	xdp.command = XDP_QUERY_PROG;
 +	WARN_ON(ndo_bpf(dev, &xdp));
 +	if (xdp.prog_id)
 +		WARN_ON(dev_xdp_install(dev, ndo_bpf, NULL, xdp.prog_flags,
 +					NULL));
 +
++<<<<<<< HEAD
 +	/* Remove HW offload */
 +	memset(&xdp, 0, sizeof(xdp));
 +	xdp.command = XDP_QUERY_PROG_HW;
 +	if (!ndo_bpf(dev, &xdp) && xdp.prog_id)
 +		WARN_ON(dev_xdp_install(dev, ndo_bpf, NULL, xdp.prog_flags,
 +					NULL));
++=======
+ 		WARN_ON(dev_xdp_install(dev, mode, bpf_op, NULL, 0, NULL));
+ 
+ 		/* auto-detach link from net device */
+ 		link = dev_xdp_link(dev, mode);
+ 		if (link)
+ 			link->dev = NULL;
+ 		else
+ 			bpf_prog_put(prog);
+ 
+ 		dev_xdp_set_link(dev, mode, NULL);
+ 	}
+ }
+ 
+ static int dev_xdp_attach(struct net_device *dev, struct netlink_ext_ack *extack,
+ 			  struct bpf_xdp_link *link, struct bpf_prog *new_prog,
+ 			  struct bpf_prog *old_prog, u32 flags)
+ {
+ 	struct bpf_prog *cur_prog;
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 	int err;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	/* either link or prog attachment, never both */
+ 	if (link && (new_prog || old_prog))
+ 		return -EINVAL;
+ 	/* link supports only XDP mode flags */
+ 	if (link && (flags & ~XDP_FLAGS_MODES)) {
+ 		NL_SET_ERR_MSG(extack, "Invalid XDP flags for BPF link attachment");
+ 		return -EINVAL;
+ 	}
+ 	/* just one XDP mode bit should be set, zero defaults to SKB mode */
+ 	if (hweight32(flags & XDP_FLAGS_MODES) > 1) {
+ 		NL_SET_ERR_MSG(extack, "Only one XDP mode flag can be set");
+ 		return -EINVAL;
+ 	}
+ 	/* old_prog != NULL implies XDP_FLAGS_REPLACE is set */
+ 	if (old_prog && !(flags & XDP_FLAGS_REPLACE)) {
+ 		NL_SET_ERR_MSG(extack, "XDP_FLAGS_REPLACE is not specified");
+ 		return -EINVAL;
+ 	}
+ 
+ 	mode = dev_xdp_mode(flags);
+ 	/* can't replace attached link */
+ 	if (dev_xdp_link(dev, mode)) {
+ 		NL_SET_ERR_MSG(extack, "Can't replace active BPF XDP link");
+ 		return -EBUSY;
+ 	}
+ 
+ 	cur_prog = dev_xdp_prog(dev, mode);
+ 	/* can't replace attached prog with link */
+ 	if (link && cur_prog) {
+ 		NL_SET_ERR_MSG(extack, "Can't replace active XDP program with BPF link");
+ 		return -EBUSY;
+ 	}
+ 	if ((flags & XDP_FLAGS_REPLACE) && cur_prog != old_prog) {
+ 		NL_SET_ERR_MSG(extack, "Active program does not match expected");
+ 		return -EEXIST;
+ 	}
+ 	if ((flags & XDP_FLAGS_UPDATE_IF_NOEXIST) && cur_prog) {
+ 		NL_SET_ERR_MSG(extack, "XDP program already attached");
+ 		return -EBUSY;
+ 	}
+ 
+ 	/* put effective new program into new_prog */
+ 	if (link)
+ 		new_prog = link->link.prog;
+ 
+ 	if (new_prog) {
+ 		bool offload = mode == XDP_MODE_HW;
+ 		enum bpf_xdp_mode other_mode = mode == XDP_MODE_SKB
+ 					       ? XDP_MODE_DRV : XDP_MODE_SKB;
+ 
+ 		if (!offload && dev_xdp_prog(dev, other_mode)) {
+ 			NL_SET_ERR_MSG(extack, "Native and generic XDP can't be active at the same time");
+ 			return -EEXIST;
+ 		}
+ 		if (!offload && bpf_prog_is_dev_bound(new_prog->aux)) {
+ 			NL_SET_ERR_MSG(extack, "Using device-bound program without HW_MODE flag is not supported");
+ 			return -EINVAL;
+ 		}
+ 		if (new_prog->expected_attach_type == BPF_XDP_DEVMAP) {
+ 			NL_SET_ERR_MSG(extack, "BPF_XDP_DEVMAP programs can not be attached to a device");
+ 			return -EINVAL;
+ 		}
+ 		if (new_prog->expected_attach_type == BPF_XDP_CPUMAP) {
+ 			NL_SET_ERR_MSG(extack, "BPF_XDP_CPUMAP programs can not be attached to a device");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/* don't call drivers if the effective program didn't change */
+ 	if (new_prog != cur_prog) {
+ 		bpf_op = dev_xdp_bpf_op(dev, mode);
+ 		if (!bpf_op) {
+ 			NL_SET_ERR_MSG(extack, "Underlying driver does not support XDP in native mode");
+ 			return -EOPNOTSUPP;
+ 		}
+ 
+ 		err = dev_xdp_install(dev, mode, bpf_op, extack, flags, new_prog);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (link)
+ 		dev_xdp_set_link(dev, mode, link);
+ 	else
+ 		dev_xdp_set_prog(dev, mode, new_prog);
+ 	if (cur_prog)
+ 		bpf_prog_put(cur_prog);
+ 
+ 	return 0;
+ }
+ 
+ static int dev_xdp_attach_link(struct net_device *dev,
+ 			       struct netlink_ext_ack *extack,
+ 			       struct bpf_xdp_link *link)
+ {
+ 	return dev_xdp_attach(dev, extack, link, NULL, NULL, link->flags);
+ }
+ 
+ static int dev_xdp_detach_link(struct net_device *dev,
+ 			       struct netlink_ext_ack *extack,
+ 			       struct bpf_xdp_link *link)
+ {
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	mode = dev_xdp_mode(link->flags);
+ 	if (dev_xdp_link(dev, mode) != link)
+ 		return -EINVAL;
+ 
+ 	bpf_op = dev_xdp_bpf_op(dev, mode);
+ 	WARN_ON(dev_xdp_install(dev, mode, bpf_op, NULL, 0, NULL));
+ 	dev_xdp_set_link(dev, mode, NULL);
+ 	return 0;
+ }
+ 
+ static void bpf_xdp_link_release(struct bpf_link *link)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 
+ 	rtnl_lock();
+ 
+ 	/* if racing with net_device's tear down, xdp_link->dev might be
+ 	 * already NULL, in which case link was already auto-detached
+ 	 */
+ 	if (xdp_link->dev) {
+ 		WARN_ON(dev_xdp_detach_link(xdp_link->dev, NULL, xdp_link));
+ 		xdp_link->dev = NULL;
+ 	}
+ 
+ 	rtnl_unlock();
+ }
+ 
+ static int bpf_xdp_link_detach(struct bpf_link *link)
+ {
+ 	bpf_xdp_link_release(link);
+ 	return 0;
+ }
+ 
+ static void bpf_xdp_link_dealloc(struct bpf_link *link)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 
+ 	kfree(xdp_link);
+ }
+ 
+ static void bpf_xdp_link_show_fdinfo(const struct bpf_link *link,
+ 				     struct seq_file *seq)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	u32 ifindex = 0;
+ 
+ 	rtnl_lock();
+ 	if (xdp_link->dev)
+ 		ifindex = xdp_link->dev->ifindex;
+ 	rtnl_unlock();
+ 
+ 	seq_printf(seq, "ifindex:\t%u\n", ifindex);
+ }
+ 
+ static int bpf_xdp_link_fill_link_info(const struct bpf_link *link,
+ 				       struct bpf_link_info *info)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	u32 ifindex = 0;
+ 
+ 	rtnl_lock();
+ 	if (xdp_link->dev)
+ 		ifindex = xdp_link->dev->ifindex;
+ 	rtnl_unlock();
+ 
+ 	info->xdp.ifindex = ifindex;
+ 	return 0;
+ }
+ 
+ static int bpf_xdp_link_update(struct bpf_link *link, struct bpf_prog *new_prog,
+ 			       struct bpf_prog *old_prog)
+ {
+ 	struct bpf_xdp_link *xdp_link = container_of(link, struct bpf_xdp_link, link);
+ 	enum bpf_xdp_mode mode;
+ 	bpf_op_t bpf_op;
+ 	int err = 0;
+ 
+ 	rtnl_lock();
+ 
+ 	/* link might have been auto-released already, so fail */
+ 	if (!xdp_link->dev) {
+ 		err = -ENOLINK;
+ 		goto out_unlock;
+ 	}
+ 
+ 	if (old_prog && link->prog != old_prog) {
+ 		err = -EPERM;
+ 		goto out_unlock;
+ 	}
+ 	old_prog = link->prog;
+ 	if (old_prog == new_prog) {
+ 		/* no-op, don't disturb drivers */
+ 		bpf_prog_put(new_prog);
+ 		goto out_unlock;
+ 	}
+ 
+ 	mode = dev_xdp_mode(xdp_link->flags);
+ 	bpf_op = dev_xdp_bpf_op(xdp_link->dev, mode);
+ 	err = dev_xdp_install(xdp_link->dev, mode, bpf_op, NULL,
+ 			      xdp_link->flags, new_prog);
+ 	if (err)
+ 		goto out_unlock;
+ 
+ 	old_prog = xchg(&link->prog, new_prog);
+ 	bpf_prog_put(old_prog);
+ 
+ out_unlock:
+ 	rtnl_unlock();
+ 	return err;
+ }
+ 
+ static const struct bpf_link_ops bpf_xdp_link_lops = {
+ 	.release = bpf_xdp_link_release,
+ 	.dealloc = bpf_xdp_link_dealloc,
+ 	.detach = bpf_xdp_link_detach,
+ 	.show_fdinfo = bpf_xdp_link_show_fdinfo,
+ 	.fill_link_info = bpf_xdp_link_fill_link_info,
+ 	.update_prog = bpf_xdp_link_update,
+ };
+ 
+ int bpf_xdp_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)
+ {
+ 	struct net *net = current->nsproxy->net_ns;
+ 	struct bpf_link_primer link_primer;
+ 	struct bpf_xdp_link *link;
+ 	struct net_device *dev;
+ 	int err, fd;
+ 
+ 	dev = dev_get_by_index(net, attr->link_create.target_ifindex);
+ 	if (!dev)
+ 		return -EINVAL;
+ 
+ 	link = kzalloc(sizeof(*link), GFP_USER);
+ 	if (!link) {
+ 		err = -ENOMEM;
+ 		goto out_put_dev;
+ 	}
+ 
+ 	bpf_link_init(&link->link, BPF_LINK_TYPE_XDP, &bpf_xdp_link_lops, prog);
+ 	link->dev = dev;
+ 	link->flags = attr->link_create.flags;
+ 
+ 	err = bpf_link_prime(&link->link, &link_primer);
+ 	if (err) {
+ 		kfree(link);
+ 		goto out_put_dev;
+ 	}
+ 
+ 	rtnl_lock();
+ 	err = dev_xdp_attach_link(dev, NULL, link);
+ 	rtnl_unlock();
+ 
+ 	if (err) {
+ 		bpf_link_cleanup(&link_primer);
+ 		goto out_put_dev;
+ 	}
+ 
+ 	fd = bpf_link_settle(&link_primer);
+ 	/* link itself doesn't hold dev's refcnt to not complicate shutdown */
+ 	dev_put(dev);
+ 	return fd;
+ 
+ out_put_dev:
+ 	dev_put(dev);
+ 	return err;
++>>>>>>> 73b11c2ab072 (bpf: Add support for forced LINK_DETACH command)
  }
  
  /**
* Unmerged path kernel/bpf/net_namespace.c
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index 53810b02f758..7bc82db140d9 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -761,6 +761,7 @@ struct bpf_link {
 struct bpf_link_ops {
 	void (*release)(struct bpf_link *link);
 	void (*dealloc)(struct bpf_link *link);
+	int (*detach)(struct bpf_link *link);
 	int (*update_prog)(struct bpf_link *link, struct bpf_prog *new_prog,
 			   struct bpf_prog *old_prog);
 	void (*show_fdinfo)(const struct bpf_link *link, struct seq_file *seq);
* Unmerged path include/uapi/linux/bpf.h
diff --git a/kernel/bpf/cgroup.c b/kernel/bpf/cgroup.c
index b705a035c637..60ba108bb0dd 100644
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@ -807,6 +807,7 @@ static void bpf_cgroup_link_release(struct bpf_link *link)
 {
 	struct bpf_cgroup_link *cg_link =
 		container_of(link, struct bpf_cgroup_link, link);
+	struct cgroup *cg;
 
 	/* link might have been auto-detached by dying cgroup already,
 	 * in that case our work is done here
@@ -825,8 +826,12 @@ static void bpf_cgroup_link_release(struct bpf_link *link)
 	WARN_ON(__cgroup_bpf_detach(cg_link->cgroup, NULL, cg_link,
 				    cg_link->type));
 
+	cg = cg_link->cgroup;
+	cg_link->cgroup = NULL;
+
 	mutex_unlock(&cgroup_mutex);
-	cgroup_put(cg_link->cgroup);
+
+	cgroup_put(cg);
 }
 
 static void bpf_cgroup_link_dealloc(struct bpf_link *link)
@@ -837,6 +842,13 @@ static void bpf_cgroup_link_dealloc(struct bpf_link *link)
 	kfree(cg_link);
 }
 
+static int bpf_cgroup_link_detach(struct bpf_link *link)
+{
+	bpf_cgroup_link_release(link);
+
+	return 0;
+}
+
 static void bpf_cgroup_link_show_fdinfo(const struct bpf_link *link,
 					struct seq_file *seq)
 {
@@ -876,6 +888,7 @@ static int bpf_cgroup_link_fill_link_info(const struct bpf_link *link,
 static const struct bpf_link_ops bpf_cgroup_link_lops = {
 	.release = bpf_cgroup_link_release,
 	.dealloc = bpf_cgroup_link_dealloc,
+	.detach = bpf_cgroup_link_detach,
 	.update_prog = cgroup_bpf_replace,
 	.show_fdinfo = bpf_cgroup_link_show_fdinfo,
 	.fill_link_info = bpf_cgroup_link_fill_link_info,
* Unmerged path kernel/bpf/net_namespace.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path net/core/dev.c
