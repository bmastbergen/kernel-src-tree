bpf: Support llvm-objcopy for vmlinux BTF

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Fangrui Song <maskray@google.com>
commit 90ceddcb495008ac8ba7a3dce297841efcd7d584
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/90ceddcb.failed

Simplify gen_btf logic to make it work with llvm-objcopy. The existing
'file format' and 'architecture' parsing logic is brittle and does not
work with llvm-objcopy/llvm-objdump.

'file format' output of llvm-objdump>=11 will match GNU objdump, but
'architecture' (bfdarch) may not.

.BTF in .tmp_vmlinux.btf is non-SHF_ALLOC. Add the SHF_ALLOC flag
because it is part of vmlinux image used for introspection. C code
can reference the section via linker script defined __start_BTF and
__stop_BTF. This fixes a small problem that previous .BTF had the
SHF_WRITE flag (objcopy -I binary -O elf* synthesized .data).

Additionally, `objcopy -I binary` synthesized symbols
_binary__btf_vmlinux_bin_start and _binary__btf_vmlinux_bin_stop (not
used elsewhere) are replaced with more commonplace __start_BTF and
__stop_BTF.

Add 2>/dev/null because GNU objcopy (but not llvm-objcopy) warns
"empty loadable segment detected at vaddr=0xffffffff81000000, is this intentional?"

We use a dd command to change the e_type field in the ELF header from
ET_EXEC to ET_REL so that lld will accept .btf.vmlinux.bin.o.  Accepting
ET_EXEC as an input file is an extremely rare GNU ld feature that lld
does not intend to support, because this is error-prone.

The output section description .BTF in include/asm-generic/vmlinux.lds.h
avoids potential subtle orphan section placement issues and suppresses
--orphan-handling=warn warnings.

Fixes: df786c9b9476 ("bpf: Force .BTF section start to zero when dumping from vmlinux")
Fixes: cb0cc635c7a9 ("powerpc: Include .BTF section")
	Reported-by: Nathan Chancellor <natechancellor@gmail.com>
	Signed-off-by: Fangrui Song <maskray@google.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Tested-by: Stanislav Fomichev <sdf@google.com>
	Tested-by: Andrii Nakryiko <andriin@fb.com>
	Reviewed-by: Stanislav Fomichev <sdf@google.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
	Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
Link: https://github.com/ClangBuiltLinux/linux/issues/871
Link: https://lore.kernel.org/bpf/20200318222746.173648-1-maskray@google.com
(cherry picked from commit 90ceddcb495008ac8ba7a3dce297841efcd7d584)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/asm-generic/vmlinux.lds.h
#	scripts/link-vmlinux.sh
diff --cc include/asm-generic/vmlinux.lds.h
index c1ce9140e18a,39da8d8b561d..000000000000
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@@ -466,31 -531,14 +466,41 @@@
  		__start___modver = .;					\
  		KEEP(*(__modver))					\
  		__stop___modver = .;					\
 +		. = ALIGN((align));					\
 +		__end_rodata = .;					\
  	}								\
++<<<<<<< HEAD
 +	. = ALIGN((align));
 +
 +/* RODATA & RO_DATA provided for backward compatibility.
 + * All archs are supposed to use RO_DATA() */
 +#define RODATA          RO_DATA_SECTION(4096)
 +#define RO_DATA(align)  RO_DATA_SECTION(align)
 +
 +#define SECURITY_INIT							\
 +	.security_initcall.init : AT(ADDR(.security_initcall.init) - LOAD_OFFSET) { \
 +		__security_initcall_start = .;				\
 +		KEEP(*(.security_initcall.init))			\
 +		__security_initcall_end = .;				\
 +	}
 +
 +/*
 + * Non-instrumentable text section
 + */
 +#define NOINSTR_TEXT							\
 +		ALIGN_FUNCTION();					\
 +		__noinstr_text_start = .;				\
 +		*(.noinstr.text)					\
 +		__noinstr_text_end = .;
++=======
+ 									\
+ 	RO_EXCEPTION_TABLE						\
+ 	NOTES								\
+ 	BTF								\
+ 									\
+ 	. = ALIGN((align));						\
+ 	__end_rodata = .;
++>>>>>>> 90ceddcb4950 (bpf: Support llvm-objcopy for vmlinux BTF)
  
  /*
   * .text section. Map to function alignment to avoid address changes
diff --cc scripts/link-vmlinux.sh
index bbfffccf5206,d09ab4afbda4..000000000000
--- a/scripts/link-vmlinux.sh
+++ b/scripts/link-vmlinux.sh
@@@ -126,7 -113,6 +126,10 @@@ vmlinux_link(
  gen_btf()
  {
  	local pahole_ver
++<<<<<<< HEAD
 +	local bin_arch
++=======
++>>>>>>> 90ceddcb4950 (bpf: Support llvm-objcopy for vmlinux BTF)
  
  	if ! [ -x "$(command -v ${PAHOLE})" ]; then
  		echo >&2 "BTF: ${1}: pahole (${PAHOLE}) is not available"
@@@ -139,20 -125,21 +142,33 @@@
  		return 1
  	fi
  
 -	vmlinux_link ${1}
 -
  	info "BTF" ${2}
 +	vmlinux_link ${1}
  	LLVM_OBJCOPY=${OBJCOPY} ${PAHOLE} -J ${1}
  
++<<<<<<< HEAD
 +	# dump .BTF section into raw binary file to link with final vmlinux
 +	bin_arch=$(LANG=C ${OBJDUMP} -f ${1} | grep architecture | \
 +		cut -d, -f1 | cut -d' ' -f2)
 +	bin_format=$(LANG=C ${OBJDUMP} -f ${1} | grep 'file format' | \
 +		awk '{print $4}')
 +	${OBJCOPY} --change-section-address .BTF=0 \
 +		--set-section-flags .BTF=alloc -O binary \
 +		--only-section=.BTF ${1} .btf.vmlinux.bin
 +	${OBJCOPY} -I binary -O ${bin_format} -B ${bin_arch} \
 +		--rename-section .data=.BTF .btf.vmlinux.bin ${2}
++=======
+ 	# Create ${2} which contains just .BTF section but no symbols. Add
+ 	# SHF_ALLOC because .BTF will be part of the vmlinux image. --strip-all
+ 	# deletes all symbols including __start_BTF and __stop_BTF, which will
+ 	# be redefined in the linker script. Add 2>/dev/null to suppress GNU
+ 	# objcopy warnings: "empty loadable segment detected at ..."
+ 	${OBJCOPY} --only-section=.BTF --set-section-flags .BTF=alloc,readonly \
+ 		--strip-all ${1} ${2} 2>/dev/null
+ 	# Change e_type to ET_REL so that it can be used to link final vmlinux.
+ 	# Unlike GNU ld, lld does not allow an ET_EXEC input.
+ 	printf '\1' | dd of=${2} conv=notrunc bs=1 seek=16 status=none
++>>>>>>> 90ceddcb4950 (bpf: Support llvm-objcopy for vmlinux BTF)
  }
  
  # Create ${2} .o file with all symbols from the ${1} object file
diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S
index d399757f2a7b..1eaa7ea1a824 100644
--- a/arch/powerpc/kernel/vmlinux.lds.S
+++ b/arch/powerpc/kernel/vmlinux.lds.S
@@ -325,12 +325,6 @@ SECTIONS
 		*(.branch_lt)
 	}
 
-#ifdef CONFIG_DEBUG_INFO_BTF
-	.BTF : AT(ADDR(.BTF) - LOAD_OFFSET) {
-		*(.BTF)
-	}
-#endif
-
 	.opd : AT(ADDR(.opd) - LOAD_OFFSET) {
 		__start_opd = .;
 		KEEP(*(.opd))
* Unmerged path include/asm-generic/vmlinux.lds.h
diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c
index bcee2f08fd19..37daa80d4544 100644
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@ -3477,8 +3477,8 @@ static struct btf *btf_parse(void __user *btf_data, u32 btf_data_size,
 	return ERR_PTR(err);
 }
 
-extern char __weak _binary__btf_vmlinux_bin_start[];
-extern char __weak _binary__btf_vmlinux_bin_end[];
+extern char __weak __start_BTF[];
+extern char __weak __stop_BTF[];
 extern struct btf *btf_vmlinux;
 
 #define BPF_MAP_TYPE(_id, _ops)
@@ -3607,9 +3607,8 @@ struct btf *btf_parse_vmlinux(void)
 	}
 	env->btf = btf;
 
-	btf->data = _binary__btf_vmlinux_bin_start;
-	btf->data_size = _binary__btf_vmlinux_bin_end -
-		_binary__btf_vmlinux_bin_start;
+	btf->data = __start_BTF;
+	btf->data_size = __stop_BTF - __start_BTF;
 
 	err = btf_parse_hdr(env);
 	if (err)
diff --git a/kernel/bpf/sysfs_btf.c b/kernel/bpf/sysfs_btf.c
index 7ae5dddd1fe6..3b495773de5a 100644
--- a/kernel/bpf/sysfs_btf.c
+++ b/kernel/bpf/sysfs_btf.c
@@ -9,15 +9,15 @@
 #include <linux/sysfs.h>
 
 /* See scripts/link-vmlinux.sh, gen_btf() func for details */
-extern char __weak _binary__btf_vmlinux_bin_start[];
-extern char __weak _binary__btf_vmlinux_bin_end[];
+extern char __weak __start_BTF[];
+extern char __weak __stop_BTF[];
 
 static ssize_t
 btf_vmlinux_read(struct file *file, struct kobject *kobj,
 		 struct bin_attribute *bin_attr,
 		 char *buf, loff_t off, size_t len)
 {
-	memcpy(buf, _binary__btf_vmlinux_bin_start + off, len);
+	memcpy(buf, __start_BTF + off, len);
 	return len;
 }
 
@@ -30,15 +30,14 @@ static struct kobject *btf_kobj;
 
 static int __init btf_vmlinux_init(void)
 {
-	if (!_binary__btf_vmlinux_bin_start)
+	if (!__start_BTF)
 		return 0;
 
 	btf_kobj = kobject_create_and_add("btf", kernel_kobj);
 	if (!btf_kobj)
 		return -ENOMEM;
 
-	bin_attr_btf_vmlinux.size = _binary__btf_vmlinux_bin_end -
-				    _binary__btf_vmlinux_bin_start;
+	bin_attr_btf_vmlinux.size = __stop_BTF - __start_BTF;
 
 	return sysfs_create_bin_file(btf_kobj, &bin_attr_btf_vmlinux);
 }
* Unmerged path scripts/link-vmlinux.sh
