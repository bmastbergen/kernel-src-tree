powerpc/pseries/cmm: fix managed page counts when migrating pages between zones

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Hildenbrand <david@redhat.com>
commit e352f576d345e5bf1fb62c8559851448a6c1d9cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e352f576.failed

Commit 63341ab03706 (virtio-balloon: fix managed page counts when migrating
pages between zones) fixed a long existing BUG in the virtio-balloon
driver when pages would get migrated between zones.  I did not try to
reproduce on powerpc, but looking at the code, the same should apply to
powerpc/cmm ever since it started using the balloon compaction
infrastructure (luckily just recently).

In case we have to migrate a ballon page to a newpage of another zone, the
managed page count of both zones is wrong. Paired with memory offlining
(which will adjust the managed page count), we can trigger kernel crashes
and all kinds of different symptoms.

Fix it by properly adjusting the managed page count when migrating if
the zone changed.

We'll temporarily modify the totalram page count. If this ever becomes a
problem, we can fine tune by providing helpers that don't touch
the totalram pages (e.g., adjust_zone_managed_page_count()).

Fixes: fe030c9b85e6 ("powerpc/pseries/cmm: Implement balloon compaction")
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20191216103058.4958-1-david@redhat.com
(cherry picked from commit e352f576d345e5bf1fb62c8559851448a6c1d9cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/cmm.c
diff --cc arch/powerpc/platforms/pseries/cmm.c
index 317181692fcb,9dba7e880885..000000000000
--- a/arch/powerpc/platforms/pseries/cmm.c
+++ b/arch/powerpc/platforms/pseries/cmm.c
@@@ -675,6 -502,116 +675,119 @@@ static struct notifier_block cmm_mem_n
  	.priority = CMM_MEM_HOTPLUG_PRI
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BALLOON_COMPACTION
+ static struct vfsmount *balloon_mnt;
+ 
+ static int cmm_init_fs_context(struct fs_context *fc)
+ {
+ 	return init_pseudo(fc, PPC_CMM_MAGIC) ? 0 : -ENOMEM;
+ }
+ 
+ static struct file_system_type balloon_fs = {
+ 	.name = "ppc-cmm",
+ 	.init_fs_context = cmm_init_fs_context,
+ 	.kill_sb = kill_anon_super,
+ };
+ 
+ static int cmm_migratepage(struct balloon_dev_info *b_dev_info,
+ 			   struct page *newpage, struct page *page,
+ 			   enum migrate_mode mode)
+ {
+ 	unsigned long flags;
+ 
+ 	/*
+ 	 * loan/"inflate" the newpage first.
+ 	 *
+ 	 * We might race against the cmm_thread who might discover after our
+ 	 * loan request that another page is to be unloaned. However, once
+ 	 * the cmm_thread runs again later, this error will automatically
+ 	 * be corrected.
+ 	 */
+ 	if (plpar_page_set_loaned(newpage)) {
+ 		/* Unlikely, but possible. Tell the caller not to retry now. */
+ 		pr_err_ratelimited("%s: Cannot set page to loaned.", __func__);
+ 		return -EBUSY;
+ 	}
+ 
+ 	/* balloon page list reference */
+ 	get_page(newpage);
+ 
+ 	/*
+ 	 * When we migrate a page to a different zone, we have to fixup the
+ 	 * count of both involved zones as we adjusted the managed page count
+ 	 * when inflating.
+ 	 */
+ 	if (page_zone(page) != page_zone(newpage)) {
+ 		adjust_managed_page_count(page, 1);
+ 		adjust_managed_page_count(newpage, -1);
+ 	}
+ 
+ 	spin_lock_irqsave(&b_dev_info->pages_lock, flags);
+ 	balloon_page_insert(b_dev_info, newpage);
+ 	balloon_page_delete(page);
+ 	b_dev_info->isolated_pages--;
+ 	spin_unlock_irqrestore(&b_dev_info->pages_lock, flags);
+ 
+ 	/*
+ 	 * activate/"deflate" the old page. We ignore any errors just like the
+ 	 * other callers.
+ 	 */
+ 	plpar_page_set_active(page);
+ 
+ 	/* balloon page list reference */
+ 	put_page(page);
+ 
+ 	return MIGRATEPAGE_SUCCESS;
+ }
+ 
+ static int cmm_balloon_compaction_init(void)
+ {
+ 	int rc;
+ 
+ 	balloon_devinfo_init(&b_dev_info);
+ 	b_dev_info.migratepage = cmm_migratepage;
+ 
+ 	balloon_mnt = kern_mount(&balloon_fs);
+ 	if (IS_ERR(balloon_mnt)) {
+ 		rc = PTR_ERR(balloon_mnt);
+ 		balloon_mnt = NULL;
+ 		return rc;
+ 	}
+ 
+ 	b_dev_info.inode = alloc_anon_inode(balloon_mnt->mnt_sb);
+ 	if (IS_ERR(b_dev_info.inode)) {
+ 		rc = PTR_ERR(b_dev_info.inode);
+ 		b_dev_info.inode = NULL;
+ 		kern_unmount(balloon_mnt);
+ 		balloon_mnt = NULL;
+ 		return rc;
+ 	}
+ 
+ 	b_dev_info.inode->i_mapping->a_ops = &balloon_aops;
+ 	return 0;
+ }
+ static void cmm_balloon_compaction_deinit(void)
+ {
+ 	if (b_dev_info.inode)
+ 		iput(b_dev_info.inode);
+ 	b_dev_info.inode = NULL;
+ 	kern_unmount(balloon_mnt);
+ 	balloon_mnt = NULL;
+ }
+ #else /* CONFIG_BALLOON_COMPACTION */
+ static int cmm_balloon_compaction_init(void)
+ {
+ 	return 0;
+ }
+ 
+ static void cmm_balloon_compaction_deinit(void)
+ {
+ }
+ #endif /* CONFIG_BALLOON_COMPACTION */
+ 
++>>>>>>> e352f576d345 (powerpc/pseries/cmm: fix managed page counts when migrating pages between zones)
  /**
   * cmm_init - Module initialization
   *
* Unmerged path arch/powerpc/platforms/pseries/cmm.c
