net: stmmac: tc: Add support for ETF Scheduler using TBS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jose Abreu <Jose.Abreu@synopsys.com>
commit 430b383c737ca07e83e0fe2a8d1ecdff6f4974bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/430b383c.failed

Adds the support for ETF scheduler using TBS feature which is available
in XGMAC and QoS IPs.

Changes from v2:
- Fix checkpatch issues (Jakub)
- Use the TBS bitfield

	Signed-off-by: Jose Abreu <Jose.Abreu@synopsys.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 430b383c737ca07e83e0fe2a8d1ecdff6f4974bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/common.h
#	drivers/net/ethernet/stmicro/stmmac/hwif.h
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
diff --cc drivers/net/ethernet/stmicro/stmmac/common.h
index 41eb39add60e,487099092693..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@@ -371,6 -361,14 +371,17 @@@ struct dma_features 
  	unsigned int sphen;
  	unsigned int vlins;
  	unsigned int dvlan;
++<<<<<<< HEAD
++=======
+ 	unsigned int l3l4fnum;
+ 	unsigned int arpoffsel;
+ 	/* TSN Features */
+ 	unsigned int estwid;
+ 	unsigned int estdep;
+ 	unsigned int estsel;
+ 	unsigned int fpesel;
+ 	unsigned int tbssel;
++>>>>>>> 430b383c737c (net: stmmac: tc: Add support for ETF Scheduler using TBS)
  };
  
  /* RX Buffer size must be multiple of 4/8/16 bytes */
diff --cc drivers/net/ethernet/stmicro/stmmac/hwif.h
index 59108f05df14,df63b0367aff..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.h
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.h
@@@ -497,17 -530,37 +497,46 @@@ struct stmmac_mode_ops 
  
  struct stmmac_priv;
  struct tc_cls_u32_offload;
++<<<<<<< HEAD
++=======
+ struct tc_cbs_qopt_offload;
+ struct flow_cls_offload;
+ struct tc_taprio_qopt_offload;
+ struct tc_etf_qopt_offload;
++>>>>>>> 430b383c737c (net: stmmac: tc: Add support for ETF Scheduler using TBS)
  
  struct stmmac_tc_ops {
  	int (*init)(struct stmmac_priv *priv);
  	int (*setup_cls_u32)(struct stmmac_priv *priv,
  			     struct tc_cls_u32_offload *cls);
++<<<<<<< HEAD
++=======
+ 	int (*setup_cbs)(struct stmmac_priv *priv,
+ 			 struct tc_cbs_qopt_offload *qopt);
+ 	int (*setup_cls)(struct stmmac_priv *priv,
+ 			 struct flow_cls_offload *cls);
+ 	int (*setup_taprio)(struct stmmac_priv *priv,
+ 			    struct tc_taprio_qopt_offload *qopt);
+ 	int (*setup_etf)(struct stmmac_priv *priv,
+ 			 struct tc_etf_qopt_offload *qopt);
++>>>>>>> 430b383c737c (net: stmmac: tc: Add support for ETF Scheduler using TBS)
  };
  
  #define stmmac_tc_init(__priv, __args...) \
  	stmmac_do_callback(__priv, tc, init, __args)
  #define stmmac_tc_setup_cls_u32(__priv, __args...) \
  	stmmac_do_callback(__priv, tc, setup_cls_u32, __args)
++<<<<<<< HEAD
++=======
+ #define stmmac_tc_setup_cbs(__priv, __args...) \
+ 	stmmac_do_callback(__priv, tc, setup_cbs, __args)
+ #define stmmac_tc_setup_cls(__priv, __args...) \
+ 	stmmac_do_callback(__priv, tc, setup_cls, __args)
+ #define stmmac_tc_setup_taprio(__priv, __args...) \
+ 	stmmac_do_callback(__priv, tc, setup_taprio, __args)
+ #define stmmac_tc_setup_etf(__priv, __args...) \
+ 	stmmac_do_callback(__priv, tc, setup_etf, __args)
++>>>>>>> 430b383c737c (net: stmmac: tc: Add support for ETF Scheduler using TBS)
  
  struct stmmac_counters;
  
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index fb0f537dd644,43af4fc5ab8f..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -4058,6 -4155,12 +4058,15 @@@ static int stmmac_setup_tc(struct net_d
  						  &stmmac_block_cb_list,
  						  stmmac_setup_tc_block_cb,
  						  priv, priv, true);
++<<<<<<< HEAD
++=======
+ 	case TC_SETUP_QDISC_CBS:
+ 		return stmmac_tc_setup_cbs(priv, priv, type_data);
+ 	case TC_SETUP_QDISC_TAPRIO:
+ 		return stmmac_tc_setup_taprio(priv, priv, type_data);
+ 	case TC_SETUP_QDISC_ETF:
+ 		return stmmac_tc_setup_etf(priv, priv, type_data);
++>>>>>>> 430b383c737c (net: stmmac: tc: Add support for ETF Scheduler using TBS)
  	default:
  		return -EOPNOTSUPP;
  	}
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
index 9f686caafe62,a4ce165af36b..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
@@@ -289,7 -306,452 +289,458 @@@ static int tc_init(struct stmmac_priv *
  	return 0;
  }
  
++<<<<<<< HEAD
 +const struct stmmac_tc_ops dwmac510_tc_ops = {
 +	.init = tc_init,
 +	.setup_cls_u32 = tc_setup_cls_u32,
++=======
+ static int tc_setup_cbs(struct stmmac_priv *priv,
+ 			struct tc_cbs_qopt_offload *qopt)
+ {
+ 	u32 tx_queues_count = priv->plat->tx_queues_to_use;
+ 	u32 queue = qopt->queue;
+ 	u32 ptr, speed_div;
+ 	u32 mode_to_use;
+ 	u64 value;
+ 	int ret;
+ 
+ 	/* Queue 0 is not AVB capable */
+ 	if (queue <= 0 || queue >= tx_queues_count)
+ 		return -EINVAL;
+ 	if (!priv->dma_cap.av)
+ 		return -EOPNOTSUPP;
+ 
+ 	mode_to_use = priv->plat->tx_queues_cfg[queue].mode_to_use;
+ 	if (mode_to_use == MTL_QUEUE_DCB && qopt->enable) {
+ 		ret = stmmac_dma_qmode(priv, priv->ioaddr, queue, MTL_QUEUE_AVB);
+ 		if (ret)
+ 			return ret;
+ 
+ 		priv->plat->tx_queues_cfg[queue].mode_to_use = MTL_QUEUE_AVB;
+ 	} else if (!qopt->enable) {
+ 		return stmmac_dma_qmode(priv, priv->ioaddr, queue, MTL_QUEUE_DCB);
+ 	}
+ 
+ 	/* Port Transmit Rate and Speed Divider */
+ 	ptr = (priv->speed == SPEED_100) ? 4 : 8;
+ 	speed_div = (priv->speed == SPEED_100) ? 100000 : 1000000;
+ 
+ 	/* Final adjustments for HW */
+ 	value = div_s64(qopt->idleslope * 1024ll * ptr, speed_div);
+ 	priv->plat->tx_queues_cfg[queue].idle_slope = value & GENMASK(31, 0);
+ 
+ 	value = div_s64(-qopt->sendslope * 1024ll * ptr, speed_div);
+ 	priv->plat->tx_queues_cfg[queue].send_slope = value & GENMASK(31, 0);
+ 
+ 	value = qopt->hicredit * 1024ll * 8;
+ 	priv->plat->tx_queues_cfg[queue].high_credit = value & GENMASK(31, 0);
+ 
+ 	value = qopt->locredit * 1024ll * 8;
+ 	priv->plat->tx_queues_cfg[queue].low_credit = value & GENMASK(31, 0);
+ 
+ 	ret = stmmac_config_cbs(priv, priv->hw,
+ 				priv->plat->tx_queues_cfg[queue].send_slope,
+ 				priv->plat->tx_queues_cfg[queue].idle_slope,
+ 				priv->plat->tx_queues_cfg[queue].high_credit,
+ 				priv->plat->tx_queues_cfg[queue].low_credit,
+ 				queue);
+ 	if (ret)
+ 		return ret;
+ 
+ 	dev_info(priv->device, "CBS queue %d: send %d, idle %d, hi %d, lo %d\n",
+ 			queue, qopt->sendslope, qopt->idleslope,
+ 			qopt->hicredit, qopt->locredit);
+ 	return 0;
+ }
+ 
+ static int tc_parse_flow_actions(struct stmmac_priv *priv,
+ 				 struct flow_action *action,
+ 				 struct stmmac_flow_entry *entry)
+ {
+ 	struct flow_action_entry *act;
+ 	int i;
+ 
+ 	if (!flow_action_has_entries(action))
+ 		return -EINVAL;
+ 
+ 	flow_action_for_each(i, act, action) {
+ 		switch (act->id) {
+ 		case FLOW_ACTION_DROP:
+ 			entry->action |= STMMAC_FLOW_ACTION_DROP;
+ 			return 0;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* Nothing to do, maybe inverse filter ? */
+ 	return 0;
+ }
+ 
+ static int tc_add_basic_flow(struct stmmac_priv *priv,
+ 			     struct flow_cls_offload *cls,
+ 			     struct stmmac_flow_entry *entry)
+ {
+ 	struct flow_rule *rule = flow_cls_offload_flow_rule(cls);
+ 	struct flow_dissector *dissector = rule->match.dissector;
+ 	struct flow_match_basic match;
+ 
+ 	/* Nothing to do here */
+ 	if (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_BASIC))
+ 		return -EINVAL;
+ 
+ 	flow_rule_match_basic(rule, &match);
+ 	entry->ip_proto = match.key->ip_proto;
+ 	return 0;
+ }
+ 
+ static int tc_add_ip4_flow(struct stmmac_priv *priv,
+ 			   struct flow_cls_offload *cls,
+ 			   struct stmmac_flow_entry *entry)
+ {
+ 	struct flow_rule *rule = flow_cls_offload_flow_rule(cls);
+ 	struct flow_dissector *dissector = rule->match.dissector;
+ 	bool inv = entry->action & STMMAC_FLOW_ACTION_DROP;
+ 	struct flow_match_ipv4_addrs match;
+ 	u32 hw_match;
+ 	int ret;
+ 
+ 	/* Nothing to do here */
+ 	if (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_IPV4_ADDRS))
+ 		return -EINVAL;
+ 
+ 	flow_rule_match_ipv4_addrs(rule, &match);
+ 	hw_match = ntohl(match.key->src) & ntohl(match.mask->src);
+ 	if (hw_match) {
+ 		ret = stmmac_config_l3_filter(priv, priv->hw, entry->idx, true,
+ 					      false, true, inv, hw_match);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	hw_match = ntohl(match.key->dst) & ntohl(match.mask->dst);
+ 	if (hw_match) {
+ 		ret = stmmac_config_l3_filter(priv, priv->hw, entry->idx, true,
+ 					      false, false, inv, hw_match);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int tc_add_ports_flow(struct stmmac_priv *priv,
+ 			     struct flow_cls_offload *cls,
+ 			     struct stmmac_flow_entry *entry)
+ {
+ 	struct flow_rule *rule = flow_cls_offload_flow_rule(cls);
+ 	struct flow_dissector *dissector = rule->match.dissector;
+ 	bool inv = entry->action & STMMAC_FLOW_ACTION_DROP;
+ 	struct flow_match_ports match;
+ 	u32 hw_match;
+ 	bool is_udp;
+ 	int ret;
+ 
+ 	/* Nothing to do here */
+ 	if (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_PORTS))
+ 		return -EINVAL;
+ 
+ 	switch (entry->ip_proto) {
+ 	case IPPROTO_TCP:
+ 		is_udp = false;
+ 		break;
+ 	case IPPROTO_UDP:
+ 		is_udp = true;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	flow_rule_match_ports(rule, &match);
+ 
+ 	hw_match = ntohs(match.key->src) & ntohs(match.mask->src);
+ 	if (hw_match) {
+ 		ret = stmmac_config_l4_filter(priv, priv->hw, entry->idx, true,
+ 					      is_udp, true, inv, hw_match);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	hw_match = ntohs(match.key->dst) & ntohs(match.mask->dst);
+ 	if (hw_match) {
+ 		ret = stmmac_config_l4_filter(priv, priv->hw, entry->idx, true,
+ 					      is_udp, false, inv, hw_match);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	entry->is_l4 = true;
+ 	return 0;
+ }
+ 
+ static struct stmmac_flow_entry *tc_find_flow(struct stmmac_priv *priv,
+ 					      struct flow_cls_offload *cls,
+ 					      bool get_free)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < priv->flow_entries_max; i++) {
+ 		struct stmmac_flow_entry *entry = &priv->flow_entries[i];
+ 
+ 		if (entry->cookie == cls->cookie)
+ 			return entry;
+ 		if (get_free && (entry->in_use == false))
+ 			return entry;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static struct {
+ 	int (*fn)(struct stmmac_priv *priv, struct flow_cls_offload *cls,
+ 		  struct stmmac_flow_entry *entry);
+ } tc_flow_parsers[] = {
+ 	{ .fn = tc_add_basic_flow },
+ 	{ .fn = tc_add_ip4_flow },
+ 	{ .fn = tc_add_ports_flow },
+ };
+ 
+ static int tc_add_flow(struct stmmac_priv *priv,
+ 		       struct flow_cls_offload *cls)
+ {
+ 	struct stmmac_flow_entry *entry = tc_find_flow(priv, cls, false);
+ 	struct flow_rule *rule = flow_cls_offload_flow_rule(cls);
+ 	int i, ret;
+ 
+ 	if (!entry) {
+ 		entry = tc_find_flow(priv, cls, true);
+ 		if (!entry)
+ 			return -ENOENT;
+ 	}
+ 
+ 	ret = tc_parse_flow_actions(priv, &rule->action, entry);
+ 	if (ret)
+ 		return ret;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(tc_flow_parsers); i++) {
+ 		ret = tc_flow_parsers[i].fn(priv, cls, entry);
+ 		if (!ret) {
+ 			entry->in_use = true;
+ 			continue;
+ 		}
+ 	}
+ 
+ 	if (!entry->in_use)
+ 		return -EINVAL;
+ 
+ 	entry->cookie = cls->cookie;
+ 	return 0;
+ }
+ 
+ static int tc_del_flow(struct stmmac_priv *priv,
+ 		       struct flow_cls_offload *cls)
+ {
+ 	struct stmmac_flow_entry *entry = tc_find_flow(priv, cls, false);
+ 	int ret;
+ 
+ 	if (!entry || !entry->in_use)
+ 		return -ENOENT;
+ 
+ 	if (entry->is_l4) {
+ 		ret = stmmac_config_l4_filter(priv, priv->hw, entry->idx, false,
+ 					      false, false, false, 0);
+ 	} else {
+ 		ret = stmmac_config_l3_filter(priv, priv->hw, entry->idx, false,
+ 					      false, false, false, 0);
+ 	}
+ 
+ 	entry->in_use = false;
+ 	entry->cookie = 0;
+ 	entry->is_l4 = false;
+ 	return ret;
+ }
+ 
+ static int tc_setup_cls(struct stmmac_priv *priv,
+ 			struct flow_cls_offload *cls)
+ {
+ 	int ret = 0;
+ 
+ 	switch (cls->command) {
+ 	case FLOW_CLS_REPLACE:
+ 		ret = tc_add_flow(priv, cls);
+ 		break;
+ 	case FLOW_CLS_DESTROY:
+ 		ret = tc_del_flow(priv, cls);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int tc_setup_taprio(struct stmmac_priv *priv,
+ 			   struct tc_taprio_qopt_offload *qopt)
+ {
+ 	u32 size, wid = priv->dma_cap.estwid, dep = priv->dma_cap.estdep;
+ 	struct plat_stmmacenet_data *plat = priv->plat;
+ 	struct timespec64 time;
+ 	bool fpe = false;
+ 	int i, ret = 0;
+ 	u64 ctr;
+ 
+ 	if (!priv->dma_cap.estsel)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (wid) {
+ 	case 0x1:
+ 		wid = 16;
+ 		break;
+ 	case 0x2:
+ 		wid = 20;
+ 		break;
+ 	case 0x3:
+ 		wid = 24;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	switch (dep) {
+ 	case 0x1:
+ 		dep = 64;
+ 		break;
+ 	case 0x2:
+ 		dep = 128;
+ 		break;
+ 	case 0x3:
+ 		dep = 256;
+ 		break;
+ 	case 0x4:
+ 		dep = 512;
+ 		break;
+ 	case 0x5:
+ 		dep = 1024;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (!qopt->enable)
+ 		goto disable;
+ 	if (qopt->num_entries >= dep)
+ 		return -EINVAL;
+ 	if (!qopt->base_time)
+ 		return -ERANGE;
+ 	if (!qopt->cycle_time)
+ 		return -ERANGE;
+ 
+ 	if (!plat->est) {
+ 		plat->est = devm_kzalloc(priv->device, sizeof(*plat->est),
+ 					 GFP_KERNEL);
+ 		if (!plat->est)
+ 			return -ENOMEM;
+ 	} else {
+ 		memset(plat->est, 0, sizeof(*plat->est));
+ 	}
+ 
+ 	size = qopt->num_entries;
+ 
+ 	priv->plat->est->gcl_size = size;
+ 	priv->plat->est->enable = qopt->enable;
+ 
+ 	for (i = 0; i < size; i++) {
+ 		s64 delta_ns = qopt->entries[i].interval;
+ 		u32 gates = qopt->entries[i].gate_mask;
+ 
+ 		if (delta_ns > GENMASK(wid, 0))
+ 			return -ERANGE;
+ 		if (gates > GENMASK(31 - wid, 0))
+ 			return -ERANGE;
+ 
+ 		switch (qopt->entries[i].command) {
+ 		case TC_TAPRIO_CMD_SET_GATES:
+ 			if (fpe)
+ 				return -EINVAL;
+ 			break;
+ 		case TC_TAPRIO_CMD_SET_AND_HOLD:
+ 			gates |= BIT(0);
+ 			fpe = true;
+ 			break;
+ 		case TC_TAPRIO_CMD_SET_AND_RELEASE:
+ 			gates &= ~BIT(0);
+ 			fpe = true;
+ 			break;
+ 		default:
+ 			return -EOPNOTSUPP;
+ 		}
+ 
+ 		priv->plat->est->gcl[i] = delta_ns | (gates << wid);
+ 	}
+ 
+ 	/* Adjust for real system time */
+ 	time = ktime_to_timespec64(qopt->base_time);
+ 	priv->plat->est->btr[0] = (u32)time.tv_nsec;
+ 	priv->plat->est->btr[1] = (u32)time.tv_sec;
+ 
+ 	ctr = qopt->cycle_time;
+ 	priv->plat->est->ctr[0] = do_div(ctr, NSEC_PER_SEC);
+ 	priv->plat->est->ctr[1] = (u32)ctr;
+ 
+ 	if (fpe && !priv->dma_cap.fpesel)
+ 		return -EOPNOTSUPP;
+ 
+ 	ret = stmmac_fpe_configure(priv, priv->ioaddr,
+ 				   priv->plat->tx_queues_to_use,
+ 				   priv->plat->rx_queues_to_use, fpe);
+ 	if (ret && fpe) {
+ 		netdev_err(priv->dev, "failed to enable Frame Preemption\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = stmmac_est_configure(priv, priv->ioaddr, priv->plat->est,
+ 				   priv->plat->clk_ptp_rate);
+ 	if (ret) {
+ 		netdev_err(priv->dev, "failed to configure EST\n");
+ 		goto disable;
+ 	}
+ 
+ 	netdev_info(priv->dev, "configured EST\n");
+ 	return 0;
+ 
+ disable:
+ 	priv->plat->est->enable = false;
+ 	stmmac_est_configure(priv, priv->ioaddr, priv->plat->est,
+ 			     priv->plat->clk_ptp_rate);
+ 	return ret;
+ }
+ 
+ static int tc_setup_etf(struct stmmac_priv *priv,
+ 			struct tc_etf_qopt_offload *qopt)
+ {
+ 	if (!priv->dma_cap.tbssel)
+ 		return -EOPNOTSUPP;
+ 	if (qopt->queue >= priv->plat->tx_queues_to_use)
+ 		return -EINVAL;
+ 	if (!(priv->tx_queue[qopt->queue].tbs & STMMAC_TBS_AVAIL))
+ 		return -EINVAL;
+ 
+ 	if (qopt->enable)
+ 		priv->tx_queue[qopt->queue].tbs |= STMMAC_TBS_EN;
+ 	else
+ 		priv->tx_queue[qopt->queue].tbs &= ~STMMAC_TBS_EN;
+ 
+ 	netdev_info(priv->dev, "%s ETF for Queue %d\n",
+ 		    qopt->enable ? "enabled" : "disabled", qopt->queue);
+ 	return 0;
+ }
+ 
+ const struct stmmac_tc_ops dwmac510_tc_ops = {
+ 	.init = tc_init,
+ 	.setup_cls_u32 = tc_setup_cls_u32,
+ 	.setup_cbs = tc_setup_cbs,
+ 	.setup_cls = tc_setup_cls,
+ 	.setup_taprio = tc_setup_taprio,
+ 	.setup_etf = tc_setup_etf,
++>>>>>>> 430b383c737c (net: stmmac: tc: Add support for ETF Scheduler using TBS)
  };
* Unmerged path drivers/net/ethernet/stmicro/stmmac/common.h
* Unmerged path drivers/net/ethernet/stmicro/stmmac/hwif.h
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
