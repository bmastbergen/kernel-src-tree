arm64: compat: Allow 32-bit vdso and sigpage to co-exist

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Will Deacon <will@kernel.org>
commit a39060b009ca0b5b5fe0c0dab85ed437531aab52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a39060b0.failed

In preparation for removing the signal trampoline from the compat vDSO,
allow the sigpage and the compat vDSO to co-exist.

For the moment the vDSO signal trampoline will still be used when built.
Subsequent patches will move to the sigpage consistently.

	Acked-by: Dave Martin <Dave.Martin@arm.com>
	Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Reviewed-by: Ard Biesheuvel <ardb@kernel.org>
	Reviewed-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit a39060b009ca0b5b5fe0c0dab85ed437531aab52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/Makefile
diff --cc arch/arm64/kernel/Makefile
index aa002ad6e084,a561cbb91d4d..000000000000
--- a/arch/arm64/kernel/Makefile
+++ b/arch/arm64/kernel/Makefile
@@@ -27,40 -27,44 +27,56 @@@ OBJCOPYFLAGS := --prefix-symbols=__efis
  $(obj)/%.stub.o: $(obj)/%.o FORCE
  	$(call if_changed,objcopy)
  
 -obj-$(CONFIG_COMPAT)			+= sys32.o signal32.o			\
 +arm64-obj-$(CONFIG_COMPAT)		+= sys32.o kuser32.o signal32.o 	\
  					   sys_compat.o
++<<<<<<< HEAD
 +arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
 +arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
 +arm64-obj-$(CONFIG_ARM64_MODULE_PLTS)	+= module-plts.o
 +arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
 +arm64-obj-$(CONFIG_HW_PERF_EVENTS)	+= perf_event.o
 +arm64-obj-$(CONFIG_HAVE_HW_BREAKPOINT)	+= hw_breakpoint.o
 +arm64-obj-$(CONFIG_CPU_PM)		+= sleep.o suspend.o
 +arm64-obj-$(CONFIG_CPU_IDLE)		+= cpuidle.o
 +arm64-obj-$(CONFIG_JUMP_LABEL)		+= jump_label.o
 +arm64-obj-$(CONFIG_KGDB)		+= kgdb.o
 +arm64-obj-$(CONFIG_EFI)			+= efi.o efi-entry.stub.o		\
++=======
+ obj-$(CONFIG_COMPAT)			+= sigreturn32.o
+ obj-$(CONFIG_KUSER_HELPERS)		+= kuser32.o
+ obj-$(CONFIG_FUNCTION_TRACER)		+= ftrace.o entry-ftrace.o
+ obj-$(CONFIG_MODULES)			+= module.o
+ obj-$(CONFIG_ARM64_MODULE_PLTS)		+= module-plts.o
+ obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
+ obj-$(CONFIG_HW_PERF_EVENTS)		+= perf_event.o
+ obj-$(CONFIG_HAVE_HW_BREAKPOINT)	+= hw_breakpoint.o
+ obj-$(CONFIG_CPU_PM)			+= sleep.o suspend.o
+ obj-$(CONFIG_CPU_IDLE)			+= cpuidle.o
+ obj-$(CONFIG_JUMP_LABEL)		+= jump_label.o
+ obj-$(CONFIG_KGDB)			+= kgdb.o
+ obj-$(CONFIG_EFI)			+= efi.o efi-entry.stub.o		\
++>>>>>>> a39060b009ca (arm64: compat: Allow 32-bit vdso and sigpage to co-exist)
  					   efi-rt-wrapper.o
 -obj-$(CONFIG_PCI)			+= pci.o
 -obj-$(CONFIG_ARMV8_DEPRECATED)		+= armv8_deprecated.o
 -obj-$(CONFIG_ACPI)			+= acpi.o
 -obj-$(CONFIG_ACPI_NUMA)			+= acpi_numa.o
 -obj-$(CONFIG_ARM64_ACPI_PARKING_PROTOCOL)	+= acpi_parking_protocol.o
 -obj-$(CONFIG_PARAVIRT)			+= paravirt.o
 -obj-$(CONFIG_RANDOMIZE_BASE)		+= kaslr.o
 -obj-$(CONFIG_HIBERNATION)		+= hibernate.o hibernate-asm.o
 -obj-$(CONFIG_KEXEC_CORE)		+= machine_kexec.o relocate_kernel.o	\
 +arm64-obj-$(CONFIG_PCI)			+= pci.o
 +arm64-obj-$(CONFIG_ARMV8_DEPRECATED)	+= armv8_deprecated.o
 +arm64-obj-$(CONFIG_ACPI)		+= acpi.o
 +arm64-obj-$(CONFIG_ACPI_NUMA)		+= acpi_numa.o
 +arm64-obj-$(CONFIG_ARM64_ACPI_PARKING_PROTOCOL)	+= acpi_parking_protocol.o
 +arm64-obj-$(CONFIG_PARAVIRT)		+= paravirt.o
 +arm64-obj-$(CONFIG_RANDOMIZE_BASE)	+= kaslr.o
 +arm64-obj-$(CONFIG_HIBERNATION)		+= hibernate.o hibernate-asm.o
 +arm64-obj-$(CONFIG_KEXEC_CORE)		+= machine_kexec.o relocate_kernel.o	\
  					   cpu-reset.o
 -obj-$(CONFIG_KEXEC_FILE)		+= machine_kexec_file.o kexec_image.o
 -obj-$(CONFIG_ARM64_RELOC_TEST)		+= arm64-reloc-test.o
 +arm64-obj-$(CONFIG_KEXEC_FILE)		+= machine_kexec_file.o kexec_image.o
 +arm64-obj-$(CONFIG_ARM64_RELOC_TEST)	+= arm64-reloc-test.o
  arm64-reloc-test-y := reloc_test_core.o reloc_test_syms.o
 -obj-$(CONFIG_CRASH_DUMP)		+= crash_dump.o
 -obj-$(CONFIG_CRASH_CORE)		+= crash_core.o
 -obj-$(CONFIG_ARM_SDE_INTERFACE)		+= sdei.o
 -obj-$(CONFIG_ARM64_SSBD)		+= ssbd.o
 -obj-$(CONFIG_ARM64_PTR_AUTH)		+= pointer_auth.o
 -obj-$(CONFIG_SHADOW_CALL_STACK)		+= scs.o
 +arm64-obj-$(CONFIG_CRASH_DUMP)		+= crash_dump.o
 +arm64-obj-$(CONFIG_ARM_SDE_INTERFACE)	+= sdei.o
 +arm64-obj-$(CONFIG_ARM64_SSBD)		+= ssbd.o
 +arm64-obj-$(CONFIG_ARM64_PTR_AUTH)	+= pointer_auth.o
  
 -obj-y					+= vdso/ probes/
 -obj-$(CONFIG_COMPAT_VDSO)		+= vdso32/
 +obj-y					+= $(arm64-obj-y) vdso/ probes/
 +obj-m					+= $(arm64-obj-m)
  head-y					:= head.o
  extra-y					+= $(head-y) vmlinux.lds
  
diff --git a/arch/arm64/include/asm/mmu.h b/arch/arm64/include/asm/mmu.h
index 403005102826..02370d0cebbb 100644
--- a/arch/arm64/include/asm/mmu.h
+++ b/arch/arm64/include/asm/mmu.h
@@ -29,6 +29,9 @@
 
 typedef struct {
 	atomic64_t	id;
+#ifdef CONFIG_COMPAT
+	void		*sigpage;
+#endif
 	void		*vdso;
 	unsigned long	flags;
 	atomic_t	nr_active_mm;
* Unmerged path arch/arm64/kernel/Makefile
diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c
index 1586a943cee2..4e7b207d3581 100644
--- a/arch/arm64/kernel/signal32.c
+++ b/arch/arm64/kernel/signal32.c
@@ -379,7 +379,7 @@ static void compat_setup_return(struct pt_regs *regs, struct k_sigaction *ka,
 		if (ka->sa.sa_flags & SA_SIGINFO)
 			idx += 3;
 
-		retcode = (unsigned long)current->mm->context.vdso +
+		retcode = (unsigned long)current->mm->context.sigpage +
 			  (idx << 2) + thumb;
 #endif
 	}
diff --git a/arch/arm64/kernel/vdso.c b/arch/arm64/kernel/vdso.c
index 687e2477fe34..d8fc899a2679 100644
--- a/arch/arm64/kernel/vdso.c
+++ b/arch/arm64/kernel/vdso.c
@@ -196,15 +196,12 @@ enum aarch32_map {
 #ifdef CONFIG_COMPAT_VDSO
 	AA32_MAP_VVAR,
 	AA32_MAP_VDSO,
-#else
-	AA32_MAP_SIGPAGE
 #endif
+	AA32_MAP_SIGPAGE
 };
 
 static struct page *aarch32_vectors_page __ro_after_init;
-#ifndef CONFIG_COMPAT_VDSO
 static struct page *aarch32_sig_page __ro_after_init;
-#endif
 
 static struct vm_special_mapping aarch32_vdso_maps[] = {
 	[AA32_MAP_VECTORS] = {
@@ -219,12 +216,11 @@ static struct vm_special_mapping aarch32_vdso_maps[] = {
 		.name = "[vdso]",
 		.mremap = aarch32_vdso_mremap,
 	},
-#else
+#endif /* CONFIG_COMPAT_VDSO */
 	[AA32_MAP_SIGPAGE] = {
 		.name	= "[sigpage]", /* ABI */
 		.pages	= &aarch32_sig_page,
 	},
-#endif /* CONFIG_COMPAT_VDSO */
 };
 
 static int aarch32_alloc_kuser_vdso_page(void)
@@ -244,27 +240,11 @@ static int aarch32_alloc_kuser_vdso_page(void)
 	return 0;
 }
 
-#ifdef CONFIG_COMPAT_VDSO
-static int __aarch32_alloc_vdso_pages(void)
-{
-	int ret;
-
-	vdso_info[VDSO_ABI_AA32].dm = &aarch32_vdso_maps[AA32_MAP_VVAR];
-	vdso_info[VDSO_ABI_AA32].cm = &aarch32_vdso_maps[AA32_MAP_VDSO];
-
-	ret = __vdso_init(VDSO_ABI_AA32);
-	if (ret)
-		return ret;
-
-	return aarch32_alloc_kuser_vdso_page();
-}
-#else
-static int __aarch32_alloc_vdso_pages(void)
+static int aarch32_alloc_sigpage(void)
 {
 	extern char __aarch32_sigret_code_start[], __aarch32_sigret_code_end[];
 	int sigret_sz = __aarch32_sigret_code_end - __aarch32_sigret_code_start;
 	unsigned long sigpage;
-	int ret;
 
 	sigpage = get_zeroed_page(GFP_ATOMIC);
 	if (!sigpage)
@@ -273,18 +253,34 @@ static int __aarch32_alloc_vdso_pages(void)
 	memcpy((void *)sigpage, __aarch32_sigret_code_start, sigret_sz);
 	aarch32_sig_page = virt_to_page(sigpage);
 	flush_dcache_page(aarch32_sig_page);
+	return 0;
+}
 
-	ret = aarch32_alloc_kuser_vdso_page();
-	if (ret)
-		free_page(sigpage);
+#ifdef CONFIG_COMPAT_VDSO
+static int __aarch32_alloc_vdso_pages(void)
+{
+	vdso_info[VDSO_ABI_AA32].dm = &aarch32_vdso_maps[AA32_MAP_VVAR];
+	vdso_info[VDSO_ABI_AA32].cm = &aarch32_vdso_maps[AA32_MAP_VDSO];
 
-	return ret;
+	return __vdso_init(VDSO_ABI_AA32);
 }
 #endif /* CONFIG_COMPAT_VDSO */
 
 static int __init aarch32_alloc_vdso_pages(void)
 {
-	return __aarch32_alloc_vdso_pages();
+	int ret;
+
+#ifdef CONFIG_COMPAT_VDSO
+	ret = __aarch32_alloc_vdso_pages();
+	if (ret)
+		return ret;
+#endif
+
+	ret = aarch32_alloc_sigpage();
+	if (ret)
+		return ret;
+
+	return aarch32_alloc_kuser_vdso_page();
 }
 arch_initcall(aarch32_alloc_vdso_pages);
 
@@ -304,7 +300,6 @@ static int aarch32_kuser_helpers_setup(struct mm_struct *mm)
 	return PTR_ERR_OR_ZERO(ret);
 }
 
-#ifndef CONFIG_COMPAT_VDSO
 static int aarch32_sigreturn_setup(struct mm_struct *mm)
 {
 	unsigned long addr;
@@ -327,12 +322,11 @@ static int aarch32_sigreturn_setup(struct mm_struct *mm)
 	if (IS_ERR(ret))
 		goto out;
 
-	mm->context.vdso = (void *)addr;
+	mm->context.sigpage = (void *)addr;
 
 out:
 	return PTR_ERR_OR_ZERO(ret);
 }
-#endif /* !CONFIG_COMPAT_VDSO */
 
 int aarch32_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 {
@@ -351,10 +345,11 @@ int aarch32_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 				       mm,
 				       bprm,
 				       uses_interp);
-#else
-	ret = aarch32_sigreturn_setup(mm);
+	if (ret)
+		goto out;
 #endif /* CONFIG_COMPAT_VDSO */
 
+	ret = aarch32_sigreturn_setup(mm);
 out:
 	up_write(&mm->mmap_sem);
 	return ret;
