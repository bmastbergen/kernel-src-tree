sched: Remove sched_set_*() return value

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 8b700983de82f79e05b2c1136d6513ea4c9b22c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8b700983.failed

Ingo suggested that since the new sched_set_*() functions are
implemented using the 'nocheck' variants, they really shouldn't ever
fail, so remove the return value.

	Cc: axboe@kernel.dk
	Cc: daniel.lezcano@linaro.org
	Cc: sudeep.holla@arm.com
	Cc: airlied@redhat.com
	Cc: broonie@kernel.org
	Cc: paulmck@kernel.org
	Suggested-by: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8b700983de82f79e05b2c1136d6513ea4c9b22c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/drbd/drbd_receiver.c
#	drivers/firmware/psci_checker.c
#	drivers/gpu/drm/msm/msm_drv.c
#	drivers/platform/chrome/cros_ec_spi.c
#	kernel/rcu/rcutorture.c
diff --cc drivers/block/drbd/drbd_receiver.c
index 0051af57f9ee,280615efef74..000000000000
--- a/drivers/block/drbd/drbd_receiver.c
+++ b/drivers/block/drbd/drbd_receiver.c
@@@ -5832,11 -6019,8 +5832,15 @@@ int drbd_ack_receiver(struct drbd_threa
  	unsigned int header_size = drbd_header_size(connection);
  	int expect   = header_size;
  	bool ping_timeout_active = false;
 +	struct sched_param param = { .sched_priority = 2 };
  
++<<<<<<< HEAD
 +	rv = sched_setscheduler(current, SCHED_RR, &param);
 +	if (rv < 0)
 +		drbd_err(connection, "drbd_ack_receiver: ERROR set priority, ret=%d\n", rv);
++=======
+ 	sched_set_fifo_low(current);
++>>>>>>> 8b700983de82 (sched: Remove sched_set_*() return value)
  
  	while (get_t_state(thi) == RUNNING) {
  		drbd_thread_current_set_cpu(thi);
diff --cc drivers/firmware/psci_checker.c
index 346943657962,6fff482847e7..000000000000
--- a/drivers/firmware/psci_checker.c
+++ b/drivers/firmware/psci_checker.c
@@@ -290,9 -281,7 +290,13 @@@ static int suspend_test_thread(void *ar
  	wait_for_completion(&suspend_threads_started);
  
  	/* Set maximum priority to preempt all other threads on this CPU. */
++<<<<<<< HEAD:drivers/firmware/psci_checker.c
 +	if (sched_setscheduler_nocheck(current, SCHED_FIFO, &sched_priority))
 +		pr_warn("Failed to set suspend thread scheduler on CPU %d\n",
 +			cpu);
++=======
+ 	sched_set_fifo(current);
++>>>>>>> 8b700983de82 (sched: Remove sched_set_*() return value):drivers/firmware/psci/psci_checker.c
  
  	dev = this_cpu_read(cpuidle_devices);
  	drv = cpuidle_get_cpu_driver(dev);
diff --cc drivers/gpu/drm/msm/msm_drv.c
index 021a0b6f9a59,556cca38487c..000000000000
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@@ -444,10 -494,28 +444,31 @@@ static int msm_drm_init(struct device *
  	ddev->mode_config.funcs = &mode_config_funcs;
  	ddev->mode_config.helper_private = &mode_config_helper_funcs;
  
++<<<<<<< HEAD
++=======
+ 	for (i = 0; i < priv->num_crtcs; i++) {
+ 		/* initialize event thread */
+ 		priv->event_thread[i].crtc_id = priv->crtcs[i]->base.id;
+ 		kthread_init_worker(&priv->event_thread[i].worker);
+ 		priv->event_thread[i].dev = ddev;
+ 		priv->event_thread[i].thread =
+ 			kthread_run(kthread_worker_fn,
+ 				&priv->event_thread[i].worker,
+ 				"crtc_event:%d", priv->event_thread[i].crtc_id);
+ 		if (IS_ERR(priv->event_thread[i].thread)) {
+ 			DRM_DEV_ERROR(dev, "failed to create crtc_event kthread\n");
+ 			priv->event_thread[i].thread = NULL;
+ 			goto err_msm_uninit;
+ 		}
+ 
+ 		sched_set_fifo(priv->event_thread[i].thread);
+ 	}
+ 
++>>>>>>> 8b700983de82 (sched: Remove sched_set_*() return value)
  	ret = drm_vblank_init(ddev, priv->num_crtcs);
  	if (ret < 0) {
 -		DRM_DEV_ERROR(dev, "failed to initialize vblank\n");
 -		goto err_msm_uninit;
 +		dev_err(dev, "failed to initialize vblank\n");
 +		goto fail;
  	}
  
  	if (kms) {
diff --cc drivers/platform/chrome/cros_ec_spi.c
index 2060d1483043,d09260382550..000000000000
--- a/drivers/platform/chrome/cros_ec_spi.c
+++ b/drivers/platform/chrome/cros_ec_spi.c
@@@ -636,6 -701,35 +636,38 @@@ static void cros_ec_spi_dt_probe(struc
  		ec_spi->end_of_msg_delay = val;
  }
  
++<<<<<<< HEAD
++=======
+ static void cros_ec_spi_high_pri_release(void *worker)
+ {
+ 	kthread_destroy_worker(worker);
+ }
+ 
+ static int cros_ec_spi_devm_high_pri_alloc(struct device *dev,
+ 					   struct cros_ec_spi *ec_spi)
+ {
+ 	int err;
+ 
+ 	ec_spi->high_pri_worker =
+ 		kthread_create_worker(0, "cros_ec_spi_high_pri");
+ 
+ 	if (IS_ERR(ec_spi->high_pri_worker)) {
+ 		err = PTR_ERR(ec_spi->high_pri_worker);
+ 		dev_err(dev, "Can't create cros_ec high pri worker: %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	err = devm_add_action_or_reset(dev, cros_ec_spi_high_pri_release,
+ 				       ec_spi->high_pri_worker);
+ 	if (err)
+ 		return err;
+ 
+ 	sched_set_fifo(ec_spi->high_pri_worker->task);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 8b700983de82 (sched: Remove sched_set_*() return value)
  static int cros_ec_spi_probe(struct spi_device *spi)
  {
  	struct device *dev = &spi->dev;
diff --cc kernel/rcu/rcutorture.c
index b09905127e99,b4c1146de414..000000000000
--- a/kernel/rcu/rcutorture.c
+++ b/kernel/rcu/rcutorture.c
@@@ -819,11 -893,7 +819,15 @@@ static int rcu_torture_boost(void *arg
  	VERBOSE_TOROUT_STRING("rcu_torture_boost started");
  
  	/* Set real-time priority. */
++<<<<<<< HEAD
 +	sp.sched_priority = 1;
 +	if (sched_setscheduler(current, SCHED_FIFO, &sp) < 0) {
 +		VERBOSE_TOROUT_STRING("rcu_torture_boost RT prio failed!");
 +		n_rcu_torture_boost_rterror++;
 +	}
++=======
+ 	sched_set_fifo_low(current);
++>>>>>>> 8b700983de82 (sched: Remove sched_set_*() return value)
  
  	init_rcu_head_on_stack(&rbi.rcu);
  	/* Each pass through the following loop does one boost-test cycle. */
* Unmerged path drivers/block/drbd/drbd_receiver.c
* Unmerged path drivers/firmware/psci_checker.c
* Unmerged path drivers/gpu/drm/msm/msm_drv.c
* Unmerged path drivers/platform/chrome/cros_ec_spi.c
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 5715031f6413..d9024ea767e3 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1599,9 +1599,9 @@ extern int idle_cpu(int cpu);
 extern int available_idle_cpu(int cpu);
 extern int sched_setscheduler(struct task_struct *, int, const struct sched_param *);
 extern int sched_setscheduler_nocheck(struct task_struct *, int, const struct sched_param *);
-extern int sched_set_fifo(struct task_struct *p);
-extern int sched_set_fifo_low(struct task_struct *p);
-extern int sched_set_normal(struct task_struct *p, int nice);
+extern void sched_set_fifo(struct task_struct *p);
+extern void sched_set_fifo_low(struct task_struct *p);
+extern void sched_set_normal(struct task_struct *p, int nice);
 extern int sched_setattr(struct task_struct *, const struct sched_attr *);
 extern int sched_setattr_nocheck(struct task_struct *, const struct sched_attr *);
 extern struct task_struct *idle_task(int cpu);
* Unmerged path kernel/rcu/rcutorture.c
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index fb85cef13869..8ec069e2aae1 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4771,30 +4771,30 @@ EXPORT_SYMBOL_GPL(sched_setscheduler_nocheck);
  * The administrator _MUST_ configure the system, the kernel simply doesn't
  * know enough information to make a sensible choice.
  */
-int sched_set_fifo(struct task_struct *p)
+void sched_set_fifo(struct task_struct *p)
 {
 	struct sched_param sp = { .sched_priority = MAX_RT_PRIO / 2 };
-	return sched_setscheduler_nocheck(p, SCHED_FIFO, &sp);
+	WARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);
 }
 EXPORT_SYMBOL_GPL(sched_set_fifo);
 
 /*
  * For when you don't much care about FIFO, but want to be above SCHED_NORMAL.
  */
-int sched_set_fifo_low(struct task_struct *p)
+void sched_set_fifo_low(struct task_struct *p)
 {
 	struct sched_param sp = { .sched_priority = 1 };
-	return sched_setscheduler_nocheck(p, SCHED_FIFO, &sp);
+	WARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);
 }
 EXPORT_SYMBOL_GPL(sched_set_fifo_low);
 
-int sched_set_normal(struct task_struct *p, int nice)
+void sched_set_normal(struct task_struct *p, int nice)
 {
 	struct sched_attr attr = {
 		.sched_policy = SCHED_NORMAL,
 		.sched_nice = nice,
 	};
-	return sched_setattr_nocheck(p, &attr);
+	WARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);
 }
 EXPORT_SYMBOL_GPL(sched_set_normal);
 
