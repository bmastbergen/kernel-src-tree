x86/platform/uv: Remove efi=old_map command line option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author steve.wahl@hpe.com <steve.wahl@hpe.com>
commit 3dad716240f95c3e6114965b8ea95018ef1b04c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3dad7162.failed

As a part of UV1 platform removal, delete the efi=old_map option,
which is not longer needed.

	Signed-off-by: Steve Wahl <steve.wahl@hpe.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Ard Biesheuvel <ardb@kernel.org>
Link: https://lkml.kernel.org/r/20200713212955.552098718@hpe.com

(cherry picked from commit 3dad716240f95c3e6114965b8ea95018ef1b04c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/uv/bios_uv.c
diff --cc arch/x86/platform/uv/bios_uv.c
index 6fbaf03c6d74,cd2a6e2537f6..000000000000
--- a/arch/x86/platform/uv/bios_uv.c
+++ b/arch/x86/platform/uv/bios_uv.c
@@@ -221,4 -209,150 +221,154 @@@ int uv_bios_init(void
  	pr_info("UV: UVsystab: Revision:%x\n", uv_systab->revision);
  	return 0;
  }
++<<<<<<< HEAD
 +#endif
++=======
+ 
+ static void __init early_code_mapping_set_exec(int executable)
+ {
+ 	efi_memory_desc_t *md;
+ 
+ 	if (!(__supported_pte_mask & _PAGE_NX))
+ 		return;
+ 
+ 	/* Make EFI service code area executable */
+ 	for_each_efi_memory_desc(md) {
+ 		if (md->type == EFI_RUNTIME_SERVICES_CODE ||
+ 		    md->type == EFI_BOOT_SERVICES_CODE)
+ 			efi_set_executable(md, executable);
+ 	}
+ }
+ 
+ void __init efi_uv1_memmap_phys_epilog(pgd_t *save_pgd)
+ {
+ 	/*
+ 	 * After the lock is released, the original page table is restored.
+ 	 */
+ 	int pgd_idx, i;
+ 	int nr_pgds;
+ 	pgd_t *pgd;
+ 	p4d_t *p4d;
+ 	pud_t *pud;
+ 
+ 	nr_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT) , PGDIR_SIZE);
+ 
+ 	for (pgd_idx = 0; pgd_idx < nr_pgds; pgd_idx++) {
+ 		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);
+ 		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);
+ 
+ 		if (!pgd_present(*pgd))
+ 			continue;
+ 
+ 		for (i = 0; i < PTRS_PER_P4D; i++) {
+ 			p4d = p4d_offset(pgd,
+ 					 pgd_idx * PGDIR_SIZE + i * P4D_SIZE);
+ 
+ 			if (!p4d_present(*p4d))
+ 				continue;
+ 
+ 			pud = (pud_t *)p4d_page_vaddr(*p4d);
+ 			pud_free(&init_mm, pud);
+ 		}
+ 
+ 		p4d = (p4d_t *)pgd_page_vaddr(*pgd);
+ 		p4d_free(&init_mm, p4d);
+ 	}
+ 
+ 	kfree(save_pgd);
+ 
+ 	__flush_tlb_all();
+ 	early_code_mapping_set_exec(0);
+ }
+ 
+ pgd_t * __init efi_uv1_memmap_phys_prolog(void)
+ {
+ 	unsigned long vaddr, addr_pgd, addr_p4d, addr_pud;
+ 	pgd_t *save_pgd, *pgd_k, *pgd_efi;
+ 	p4d_t *p4d, *p4d_k, *p4d_efi;
+ 	pud_t *pud;
+ 
+ 	int pgd;
+ 	int n_pgds, i, j;
+ 
+ 	early_code_mapping_set_exec(1);
+ 
+ 	n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);
+ 	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);
+ 	if (!save_pgd)
+ 		return NULL;
+ 
+ 	/*
+ 	 * Build 1:1 identity mapping for UV1 memmap usage. Note that
+ 	 * PAGE_OFFSET is PGDIR_SIZE aligned when KASLR is disabled, while
+ 	 * it is PUD_SIZE ALIGNED with KASLR enabled. So for a given physical
+ 	 * address X, the pud_index(X) != pud_index(__va(X)), we can only copy
+ 	 * PUD entry of __va(X) to fill in pud entry of X to build 1:1 mapping.
+ 	 * This means here we can only reuse the PMD tables of the direct mapping.
+ 	 */
+ 	for (pgd = 0; pgd < n_pgds; pgd++) {
+ 		addr_pgd = (unsigned long)(pgd * PGDIR_SIZE);
+ 		vaddr = (unsigned long)__va(pgd * PGDIR_SIZE);
+ 		pgd_efi = pgd_offset_k(addr_pgd);
+ 		save_pgd[pgd] = *pgd_efi;
+ 
+ 		p4d = p4d_alloc(&init_mm, pgd_efi, addr_pgd);
+ 		if (!p4d) {
+ 			pr_err("Failed to allocate p4d table!\n");
+ 			goto out;
+ 		}
+ 
+ 		for (i = 0; i < PTRS_PER_P4D; i++) {
+ 			addr_p4d = addr_pgd + i * P4D_SIZE;
+ 			p4d_efi = p4d + p4d_index(addr_p4d);
+ 
+ 			pud = pud_alloc(&init_mm, p4d_efi, addr_p4d);
+ 			if (!pud) {
+ 				pr_err("Failed to allocate pud table!\n");
+ 				goto out;
+ 			}
+ 
+ 			for (j = 0; j < PTRS_PER_PUD; j++) {
+ 				addr_pud = addr_p4d + j * PUD_SIZE;
+ 
+ 				if (addr_pud > (max_pfn << PAGE_SHIFT))
+ 					break;
+ 
+ 				vaddr = (unsigned long)__va(addr_pud);
+ 
+ 				pgd_k = pgd_offset_k(vaddr);
+ 				p4d_k = p4d_offset(pgd_k, vaddr);
+ 				pud[j] = *pud_offset(p4d_k, vaddr);
+ 			}
+ 		}
+ 		pgd_offset_k(pgd * PGDIR_SIZE)->pgd &= ~_PAGE_NX;
+ 	}
+ 
+ 	__flush_tlb_all();
+ 	return save_pgd;
+ out:
+ 	efi_uv1_memmap_phys_epilog(save_pgd);
+ 	return NULL;
+ }
+ 
+ void __iomem *__init efi_ioremap(unsigned long phys_addr, unsigned long size,
+ 				 u32 type, u64 attribute)
+ {
+ 	unsigned long last_map_pfn;
+ 
+ 	if (type == EFI_MEMORY_MAPPED_IO)
+ 		return ioremap(phys_addr, size);
+ 
+ 	last_map_pfn = init_memory_mapping(phys_addr, phys_addr + size,
+ 					   PAGE_KERNEL);
+ 	if ((last_map_pfn << PAGE_SHIFT) < phys_addr + size) {
+ 		unsigned long top = last_map_pfn << PAGE_SHIFT;
+ 		efi_ioremap(top, size - (top - phys_addr), type, attribute);
+ 	}
+ 
+ 	if (!(attribute & EFI_MEMORY_WB))
+ 		efi_memory_uc((u64)(unsigned long)__va(phys_addr), size);
+ 
+ 	return (void __iomem *)__va(phys_addr);
+ }
++>>>>>>> 3dad716240f9 (x86/platform/uv: Remove efi=old_map command line option)
* Unmerged path arch/x86/platform/uv/bios_uv.c
