iwlwifi: pcie: make iwl_pcie_txq_update_byte_cnt_tbl bus independent

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mordechay Goodstein <mordechay.goodstein@intel.com>
commit 0179bfff9780ae51d76b9e101a6d80205ce7b413
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0179bfff.failed

To avoid duplicating code we need to call iwl_pcie_txq_update_byte_cnt_tbl
function from non bus independent code so make it bus independent.

Used spatch rule

@r1@
struct iwl_trans_pcie *trans_pcie;
@@
(
-trans_pcie->scd_bc_tbls
+trans->txqs.scd_bc_tbls
|
-iwl_pcie_txq_update_byte_cnt_tbl
+iwl_txq_gen1_update_byte_cnt_tbl
|
-iwl_pcie_txq_inval_byte_cnt_tbl
+iwl_txq_gen1_inval_byte_cnt_tbl
|
-iwl_pcie_tfd_unmap
+iwl_txq_gen1_tfd_unmap
|
-iwl_pcie_tfd_tb_get_addr
+iwl_txq_gen1_tfd_tb_get_addr
|
-iwl_pcie_tfd_tb_get_len
+iwl_txq_gen1_tfd_tb_get_len
|
-iwl_pcie_tfd_get_num_tbs
+iwl_txq_gen1_tfd_get_num_tbs
)

/* clean all new unused variables */
@ depends on r1@
type T;
identifier i;
expression E;
@@
- T i = E;
 ... when != i

	Signed-off-by: Mordechay Goodstein <mordechay.goodstein@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Link: https://lore.kernel.org/r/iwlwifi.20200930191738.8d33e791ec8c.Ica35125ed640aa3aa1ecc38fb5e8f1600caa8df6@changeid
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit 0179bfff9780ae51d76b9e101a6d80205ce7b413)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/pcie/tx.c
#	drivers/net/wireless/intel/iwlwifi/queue/tx.c
#	drivers/net/wireless/intel/iwlwifi/queue/tx.h
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/tx.c
index d0058b1513b5,8c89e4a2f7f8..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
@@@ -180,99 -123,6 +177,24 @@@ void iwl_pcie_free_dma_ptr(struct iwl_t
  	memset(ptr, 0, sizeof(*ptr));
  }
  
 +static void iwl_pcie_txq_stuck_timer(struct timer_list *t)
 +{
 +	struct iwl_txq *txq = from_timer(txq, t, stuck_timer);
 +	struct iwl_trans *trans = txq->trans;
 +
 +	spin_lock(&txq->lock);
 +	/* check if triggered erroneously */
 +	if (txq->read_ptr == txq->write_ptr) {
 +		spin_unlock(&txq->lock);
 +		return;
 +	}
 +	spin_unlock(&txq->lock);
 +
 +	iwl_trans_pcie_log_scd_error(trans, txq);
 +
 +	iwl_force_nmi(trans);
 +}
 +
- /*
-  * iwl_pcie_txq_update_byte_cnt_tbl - Set up entry in Tx byte-count array
-  */
- static void iwl_pcie_txq_update_byte_cnt_tbl(struct iwl_trans *trans,
- 					     struct iwl_txq *txq, u16 byte_cnt,
- 					     int num_tbs)
- {
- 	struct iwlagn_scd_bc_tbl *scd_bc_tbl;
- 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
- 	int write_ptr = txq->write_ptr;
- 	int txq_id = txq->id;
- 	u8 sec_ctl = 0;
- 	u16 len = byte_cnt + IWL_TX_CRC_SIZE + IWL_TX_DELIMITER_SIZE;
- 	__le16 bc_ent;
- 	struct iwl_device_tx_cmd *dev_cmd = txq->entries[txq->write_ptr].cmd;
- 	struct iwl_tx_cmd *tx_cmd = (void *)dev_cmd->payload;
- 	u8 sta_id = tx_cmd->sta_id;
- 
- 	scd_bc_tbl = trans_pcie->scd_bc_tbls.addr;
- 
- 	sec_ctl = tx_cmd->sec_ctl;
- 
- 	switch (sec_ctl & TX_CMD_SEC_MSK) {
- 	case TX_CMD_SEC_CCM:
- 		len += IEEE80211_CCMP_MIC_LEN;
- 		break;
- 	case TX_CMD_SEC_TKIP:
- 		len += IEEE80211_TKIP_ICV_LEN;
- 		break;
- 	case TX_CMD_SEC_WEP:
- 		len += IEEE80211_WEP_IV_LEN + IEEE80211_WEP_ICV_LEN;
- 		break;
- 	}
- 	if (trans->txqs.bc_table_dword)
- 		len = DIV_ROUND_UP(len, 4);
- 
- 	if (WARN_ON(len > 0xFFF || write_ptr >= TFD_QUEUE_SIZE_MAX))
- 		return;
- 
- 	bc_ent = cpu_to_le16(len | (sta_id << 12));
- 
- 	scd_bc_tbl[txq_id].tfd_offset[write_ptr] = bc_ent;
- 
- 	if (write_ptr < TFD_QUEUE_SIZE_BC_DUP)
- 		scd_bc_tbl[txq_id].
- 			tfd_offset[TFD_QUEUE_SIZE_MAX + write_ptr] = bc_ent;
- }
- 
- static void iwl_pcie_txq_inval_byte_cnt_tbl(struct iwl_trans *trans,
- 					    struct iwl_txq *txq)
- {
- 	struct iwl_trans_pcie *trans_pcie =
- 		IWL_TRANS_GET_PCIE_TRANS(trans);
- 	struct iwlagn_scd_bc_tbl *scd_bc_tbl = trans_pcie->scd_bc_tbls.addr;
- 	int txq_id = txq->id;
- 	int read_ptr = txq->read_ptr;
- 	u8 sta_id = 0;
- 	__le16 bc_ent;
- 	struct iwl_device_tx_cmd *dev_cmd = txq->entries[read_ptr].cmd;
- 	struct iwl_tx_cmd *tx_cmd = (void *)dev_cmd->payload;
- 
- 	WARN_ON(read_ptr >= TFD_QUEUE_SIZE_MAX);
- 
- 	if (txq_id != trans->txqs.cmd.q_id)
- 		sta_id = tx_cmd->sta_id;
- 
- 	bc_ent = cpu_to_le16(1 | (sta_id << 12));
- 
- 	scd_bc_tbl[txq_id].tfd_offset[read_ptr] = bc_ent;
- 
- 	if (read_ptr < TFD_QUEUE_SIZE_BC_DUP)
- 		scd_bc_tbl[txq_id].
- 			tfd_offset[TFD_QUEUE_SIZE_MAX + read_ptr] = bc_ent;
- }
- 
  /*
   * iwl_pcie_txq_inc_wr_ptr - Send new write index to hardware
   */
@@@ -384,66 -205,6 +277,69 @@@ static inline void iwl_pcie_tfd_set_tb(
  	tfd_fh->num_tbs = idx + 1;
  }
  
++<<<<<<< HEAD
 +static inline u8 iwl_pcie_tfd_get_num_tbs(struct iwl_trans *trans, void *_tfd)
 +{
 +	if (trans->trans_cfg->use_tfh) {
 +		struct iwl_tfh_tfd *tfd = _tfd;
 +
 +		return le16_to_cpu(tfd->num_tbs) & 0x1f;
 +	} else {
 +		struct iwl_tfd *tfd = _tfd;
 +
 +		return tfd->num_tbs & 0x1f;
 +	}
 +}
 +
 +static void iwl_pcie_tfd_unmap(struct iwl_trans *trans,
 +			       struct iwl_cmd_meta *meta,
 +			       struct iwl_txq *txq, int index)
 +{
 +	int i, num_tbs;
 +	void *tfd = iwl_pcie_get_tfd(trans, txq, index);
 +
 +	/* Sanity check on number of chunks */
 +	num_tbs = iwl_pcie_tfd_get_num_tbs(trans, tfd);
 +
 +	if (num_tbs > trans->txqs.tfd.max_tbs) {
 +		IWL_ERR(trans, "Too many chunks: %i\n", num_tbs);
 +		/* @todo issue fatal error, it is quite serious situation */
 +		return;
 +	}
 +
 +	/* first TB is never freed - it's the bidirectional DMA data */
 +
 +	for (i = 1; i < num_tbs; i++) {
 +		if (meta->tbs & BIT(i))
 +			dma_unmap_page(trans->dev,
 +				       iwl_pcie_tfd_tb_get_addr(trans, tfd, i),
 +				       iwl_pcie_tfd_tb_get_len(trans, tfd, i),
 +				       DMA_TO_DEVICE);
 +		else
 +			dma_unmap_single(trans->dev,
 +					 iwl_pcie_tfd_tb_get_addr(trans, tfd,
 +								  i),
 +					 iwl_pcie_tfd_tb_get_len(trans, tfd,
 +								 i),
 +					 DMA_TO_DEVICE);
 +	}
 +
 +	meta->tbs = 0;
 +
 +	if (trans->trans_cfg->use_tfh) {
 +		struct iwl_tfh_tfd *tfd_fh = (void *)tfd;
 +
 +		tfd_fh->num_tbs = 0;
 +	} else {
 +		struct iwl_tfd *tfd_fh = (void *)tfd;
 +
 +		tfd_fh->num_tbs = 0;
 +	}
 +
 +}
 +
++=======
++>>>>>>> 0179bfff9780 (iwlwifi: pcie: make iwl_pcie_txq_update_byte_cnt_tbl bus independent)
  /*
   * iwl_pcie_txq_free_tfd - Free all chunks referenced by TFD [txq->q.read_ptr]
   * @trans - transport private data
@@@ -2476,10 -2072,11 +2372,11 @@@ int iwl_trans_pcie_tx(struct iwl_trans 
  	/* building the A-MSDU might have changed this data, so memcpy it now */
  	memcpy(&txq->first_tb_bufs[txq->write_ptr], dev_cmd, IWL_FIRST_TB_SIZE);
  
 -	tfd = iwl_txq_get_tfd(trans, txq, txq->write_ptr);
 +	tfd = iwl_pcie_get_tfd(trans, txq, txq->write_ptr);
  	/* Set up entry for this TFD in Tx byte-count array */
- 	iwl_pcie_txq_update_byte_cnt_tbl(trans, txq, le16_to_cpu(tx_cmd->len),
- 					 iwl_pcie_tfd_get_num_tbs(trans, tfd));
+ 	iwl_txq_gen1_update_byte_cnt_tbl(trans, txq, le16_to_cpu(tx_cmd->len),
+ 					 iwl_txq_gen1_tfd_get_num_tbs(trans,
+ 								      tfd));
  
  	wait_write_ptr = ieee80211_has_morefrags(fc);
  
* Unmerged path drivers/net/wireless/intel/iwlwifi/queue/tx.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/queue/tx.h
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.h b/drivers/net/wireless/intel/iwlwifi/iwl-trans.h
index 1257c7335dd6..00e2a1cd06d6 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.h
@@ -918,6 +918,7 @@ struct iwl_txq {
  * @dev_cmd_offs: offset from skb->cb to iwl_device_tx_cmd pointer
  * @queue_used - bit mask of used queues
  * @queue_stopped - bit mask of stopped queues
+ * @scd_bc_tbls: gen1 pointer to the byte count table of the scheduler
  */
 struct iwl_trans_txqs {
 	unsigned long queue_used[BITS_TO_LONGS(IWL_MAX_TVQM_QUEUES)];
@@ -940,6 +941,8 @@ struct iwl_trans_txqs {
 		u16 size;
 		u8 addr_size;
 	} tfd;
+
+	struct iwl_dma_ptr scd_bc_tbls;
 };
 
 /**
diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/internal.h b/drivers/net/wireless/intel/iwlwifi/pcie/internal.h
index 22b4731ef511..443f88a6a80d 100644
--- a/drivers/net/wireless/intel/iwlwifi/pcie/internal.h
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/internal.h
@@ -369,7 +369,6 @@ struct cont_rec {
  *	count for allocating and freeing the memory.
  * @trans: pointer to the generic transport area
  * @scd_base_addr: scheduler sram base address in SRAM
- * @scd_bc_tbls: pointer to the byte count table of the scheduler
  * @kw: keep warm address
  * @pci_dev: basic pci-network driver stuff
  * @hw_base: pci hardware address support
@@ -442,7 +441,6 @@ struct iwl_trans_pcie {
 	struct mutex mutex;
 	u32 inta_mask;
 	u32 scd_base_addr;
-	struct iwl_dma_ptr scd_bc_tbls;
 	struct iwl_dma_ptr kw;
 
 	struct iwl_txq *txq_memory;
@@ -604,22 +602,6 @@ void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
 void iwl_trans_pcie_set_q_ptrs(struct iwl_trans *trans, int txq_id, int ptr);
 void iwl_trans_pcie_tx_reset(struct iwl_trans *trans);
 
-static inline u16 iwl_pcie_tfd_tb_get_len(struct iwl_trans *trans, void *_tfd,
-					  u8 idx)
-{
-	if (trans->trans_cfg->use_tfh) {
-		struct iwl_tfh_tfd *tfd = _tfd;
-		struct iwl_tfh_tb *tb = &tfd->tbs[idx];
-
-		return le16_to_cpu(tb->tb_len);
-	} else {
-		struct iwl_tfd *tfd = _tfd;
-		struct iwl_tfd_tb *tb = &tfd->tbs[idx];
-
-		return le16_to_cpu(tb->hi_n_len) >> 4;
-	}
-}
-
 /*****************************************************
 * Error handling
 ******************************************************/
diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
index 575734403d8e..fb3ffdd0f59e 100644
--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@ -2993,7 +2993,7 @@ static u32 iwl_trans_pcie_get_cmdlen(struct iwl_trans *trans, void *tfd)
 	int i;
 
 	for (i = 0; i < trans->txqs.tfd.max_tbs; i++)
-		cmdlen += iwl_pcie_tfd_tb_get_len(trans, tfd, i);
+		cmdlen += iwl_txq_gen1_tfd_tb_get_len(trans, tfd, i);
 
 	return cmdlen;
 }
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/tx.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/queue/tx.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/queue/tx.h
