s390/ap: split ap queue state machine state from device state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 0b641cbd24445e56073c69dd046be488dcf1965b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0b641cbd.failed

The state machine for each ap queue covered a mixture of
device states and state machine (firmware queue state) states.

This patch splits the device states and the state machine
states into two different enums and variables. The major
state is the device state with currently these values:

  AP_DEV_STATE_UNINITIATED - fresh and virgin, not touched
  AP_DEV_STATE_OPERATING   - queue dev is working normal
  AP_DEV_STATE_SHUTDOWN	   - remove/unbind/shutdown in progress
  AP_DEV_STATE_ERROR	   - device is in error state

only when the device state is > UNINITIATED the state machine
is run. The state machine represents the states of the firmware
queue:

  AP_SM_STATE_RESET_START - starting point, reset (RAPQ) ap queue
  AP_SM_STATE_RESET_WAIT  - reset triggered, waiting to be finished
			    if irqs enabled, set up irq (AQIC)
  AP_SM_STATE_SETIRQ_WAIT - enable irq triggered, waiting to be
			    finished, then go to IDLE
  AP_SM_STATE_IDLE	  - queue is operational but empty
  AP_SM_STATE_WORKING	  - queue is operational, requests are stored
			    and replies may wait for getting fetched
  AP_SM_STATE_QUEUE_FULL  - firmware queue is full, so only replies
			    can get fetched

For debugging each ap queue shows a sysfs attribute 'states' which
displays the device and state machine state and is only available
when the kernel is build with CONFIG_ZCRYPT_DEBUG enabled.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 0b641cbd24445e56073c69dd046be488dcf1965b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
#	drivers/s390/crypto/ap_bus.h
#	drivers/s390/crypto/ap_queue.c
diff --cc drivers/s390/crypto/ap_bus.c
index 70b945ce5806,1e895fcd25cc..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -1479,16 -1376,14 +1479,20 @@@ static void _ap_scan_bus_adapter(int id
  			continue;
  		}
  		/* try to fetch infos about this queue */
 -		broken = !ap_queue_info(qid, &type, &func, &depth);
 +		rc = ap_query_queue(qid, &depth, &type, &func);
  		if (dev) {
 -			if (!broken) {
 +			if (rc == -ENODEV)
 +				borked = 1;
 +			else {
  				spin_lock_bh(&aq->lock);
++<<<<<<< HEAD
 +				borked = aq->state == AP_STATE_BORKED;
++=======
+ 				broken = aq->dev_state == AP_DEV_STATE_ERROR;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  				spin_unlock_bh(&aq->lock);
  			}
 -			if (broken) {
 +			if (borked) {
  				/* Remove broken device */
  				AP_DBF(DBF_DEBUG,
  				       "removing broken queue=%02x.%04x\n",
diff --cc drivers/s390/crypto/ap_bus.h
index 0a20eede0143,2d4558b5abaf..000000000000
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@@ -83,20 -83,16 +83,31 @@@ static inline int ap_test_bit(unsigned 
  #define AP_INTR_ENABLED		1	/* AP interrupt enabled */
  
  /*
 - * AP queue state machine states
 + * AP device states
   */
++<<<<<<< HEAD
 +enum ap_state {
 +	AP_STATE_RESET_START,
 +	AP_STATE_RESET_WAIT,
 +	AP_STATE_SETIRQ_WAIT,
 +	AP_STATE_IDLE,
 +	AP_STATE_WORKING,
 +	AP_STATE_QUEUE_FULL,
 +	AP_STATE_SUSPEND_WAIT,
 +	AP_STATE_REMOVE,	/* about to be removed from driver */
 +	AP_STATE_UNBOUND,	/* momentary not bound to a driver */
 +	AP_STATE_BORKED,	/* broken */
 +	NR_AP_STATES
++=======
+ enum ap_sm_state {
+ 	AP_SM_STATE_RESET_START = 0,
+ 	AP_SM_STATE_RESET_WAIT,
+ 	AP_SM_STATE_SETIRQ_WAIT,
+ 	AP_SM_STATE_IDLE,
+ 	AP_SM_STATE_WORKING,
+ 	AP_SM_STATE_QUEUE_FULL,
+ 	NR_AP_SM_STATES
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  };
  
  /*
@@@ -109,16 -105,27 +120,27 @@@ enum ap_event 
  };
  
  /*
 - * AP queue state wait behaviour
 + * AP wait behaviour
   */
 -enum ap_sm_wait {
 -	AP_SM_WAIT_AGAIN,	/* retry immediately */
 -	AP_SM_WAIT_TIMEOUT,	/* wait for timeout */
 -	AP_SM_WAIT_INTERRUPT,	/* wait for thin interrupt (if available) */
 -	AP_SM_WAIT_NONE,	/* no wait */
 -	NR_AP_SM_WAIT
 +enum ap_wait {
 +	AP_WAIT_AGAIN,		/* retry immediately */
 +	AP_WAIT_TIMEOUT,	/* wait for timeout */
 +	AP_WAIT_INTERRUPT,	/* wait for thin interrupt (if available) */
 +	AP_WAIT_NONE,		/* no wait */
 +	NR_AP_WAIT
  };
  
+ /*
+  * AP queue device states
+  */
+ enum ap_dev_state {
+ 	AP_DEV_STATE_UNINITIATED = 0,	/* fresh and virgin, not touched */
+ 	AP_DEV_STATE_OPERATING,		/* queue dev is working normal */
+ 	AP_DEV_STATE_SHUTDOWN,		/* remove/unbind/shutdown in progress */
+ 	AP_DEV_STATE_ERROR,		/* device is in error state */
+ 	NR_AP_DEV_STATES
+ };
+ 
  struct ap_device;
  struct ap_message;
  
@@@ -175,7 -181,6 +198,10 @@@ struct ap_queue 
  	ap_qid_t qid;			/* AP queue id. */
  	int interrupt;			/* indicate if interrupts are enabled */
  	int queue_count;		/* # messages currently on AP queue. */
++<<<<<<< HEAD
 +	enum ap_state state;		/* State of the AP device. */
++=======
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	int pendingq_count;		/* # requests on pendingq list. */
  	int requestq_count;		/* # requests on requestq list. */
  	u64 total_request_count;	/* # requests ever for this AP device.*/
@@@ -234,10 -240,10 +261,10 @@@ static inline void ap_release_message(s
  int ap_send(ap_qid_t, unsigned long long, void *, size_t);
  int ap_recv(ap_qid_t, unsigned long long *, void *, size_t);
  
 -enum ap_sm_wait ap_sm_event(struct ap_queue *aq, enum ap_sm_event event);
 -enum ap_sm_wait ap_sm_event_loop(struct ap_queue *aq, enum ap_sm_event event);
 +enum ap_wait ap_sm_event(struct ap_queue *aq, enum ap_event event);
 +enum ap_wait ap_sm_event_loop(struct ap_queue *aq, enum ap_event event);
  
- void ap_queue_message(struct ap_queue *aq, struct ap_message *ap_msg);
+ int ap_queue_message(struct ap_queue *aq, struct ap_message *ap_msg);
  void ap_cancel_message(struct ap_queue *aq, struct ap_message *ap_msg);
  void ap_flush_queue(struct ap_queue *aq);
  
diff --cc drivers/s390/crypto/ap_queue.c
index 7bd5294989aa,e7ecbcc18db3..000000000000
--- a/drivers/s390/crypto/ap_queue.c
+++ b/drivers/s390/crypto/ap_queue.c
@@@ -184,44 -184,19 +184,49 @@@ static enum ap_wait ap_sm_read(struct a
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  		if (aq->queue_count > 0) {
 -			aq->sm_state = AP_SM_STATE_WORKING;
 -			return AP_SM_WAIT_AGAIN;
 +			aq->state = AP_STATE_WORKING;
 +			return AP_WAIT_AGAIN;
  		}
 -		aq->sm_state = AP_SM_STATE_IDLE;
 -		return AP_SM_WAIT_NONE;
 +		aq->state = AP_STATE_IDLE;
 +		return AP_WAIT_NONE;
  	case AP_RESPONSE_NO_PENDING_REPLY:
  		if (aq->queue_count > 0)
 -			return AP_SM_WAIT_INTERRUPT;
 -		aq->sm_state = AP_SM_STATE_IDLE;
 -		return AP_SM_WAIT_NONE;
 +			return AP_WAIT_INTERRUPT;
 +		aq->state = AP_STATE_IDLE;
 +		return AP_WAIT_NONE;
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
 +	}
 +}
 +
 +/**
 + * ap_sm_suspend_read(): Receive pending reply messages from an AP queue
 + * without changing the device state in between. In suspend mode we don't
 + * allow sending new requests, therefore just fetch pending replies.
 + * @aq: pointer to the AP queue
 + *
 + * Returns AP_WAIT_NONE or AP_WAIT_AGAIN
 + */
 +static enum ap_wait ap_sm_suspend_read(struct ap_queue *aq)
 +{
 +	struct ap_queue_status status;
 +
 +	if (!aq->reply)
 +		return AP_WAIT_NONE;
 +	status = ap_sm_recv(aq);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		if (aq->queue_count > 0)
 +			return AP_WAIT_AGAIN;
 +		/* fall through */
 +	default:
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	}
  }
  
@@@ -268,10 -243,10 +273,15 @@@ static enum ap_wait ap_sm_write(struct 
  		aq->requestq_count--;
  		ap_msg->rc = -EINVAL;
  		ap_msg->receive(aq, ap_msg, NULL);
 -		return AP_SM_WAIT_AGAIN;
 +		return AP_WAIT_AGAIN;
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	}
  }
  
@@@ -309,8 -284,8 +319,13 @@@ static enum ap_wait ap_sm_reset(struct 
  	case AP_RESPONSE_DECONFIGURED:
  	case AP_RESPONSE_CHECKSTOPPED:
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	}
  }
  
@@@ -348,8 -323,8 +363,13 @@@ static enum ap_wait ap_sm_reset_wait(st
  	case AP_RESPONSE_DECONFIGURED:
  	case AP_RESPONSE_CHECKSTOPPED:
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	}
  }
  
@@@ -380,72 -355,59 +400,87 @@@ static enum ap_wait ap_sm_setirq_wait(s
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  		if (aq->queue_count > 0)
 -			return AP_SM_WAIT_AGAIN;
 -		fallthrough;
 +			return AP_WAIT_AGAIN;
 +		/* fallthrough */
  	case AP_RESPONSE_NO_PENDING_REPLY:
 -		return AP_SM_WAIT_TIMEOUT;
 +		return AP_WAIT_TIMEOUT;
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	}
  }
  
  /*
   * AP state machine jump table
   */
 -static ap_func_t *ap_jumptable[NR_AP_SM_STATES][NR_AP_SM_EVENTS] = {
 -	[AP_SM_STATE_RESET_START] = {
 -		[AP_SM_EVENT_POLL] = ap_sm_reset,
 -		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
 +static ap_func_t *ap_jumptable[NR_AP_STATES][NR_AP_EVENTS] = {
 +	[AP_STATE_RESET_START] = {
 +		[AP_EVENT_POLL] = ap_sm_reset,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
 +	},
 +	[AP_STATE_RESET_WAIT] = {
 +		[AP_EVENT_POLL] = ap_sm_reset_wait,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
  	},
 -	[AP_SM_STATE_RESET_WAIT] = {
 -		[AP_SM_EVENT_POLL] = ap_sm_reset_wait,
 -		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
 +	[AP_STATE_SETIRQ_WAIT] = {
 +		[AP_EVENT_POLL] = ap_sm_setirq_wait,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
  	},
 -	[AP_SM_STATE_SETIRQ_WAIT] = {
 -		[AP_SM_EVENT_POLL] = ap_sm_setirq_wait,
 -		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
 +	[AP_STATE_IDLE] = {
 +		[AP_EVENT_POLL] = ap_sm_write,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
  	},
 -	[AP_SM_STATE_IDLE] = {
 -		[AP_SM_EVENT_POLL] = ap_sm_write,
 -		[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,
 +	[AP_STATE_WORKING] = {
 +		[AP_EVENT_POLL] = ap_sm_read_write,
 +		[AP_EVENT_TIMEOUT] = ap_sm_reset,
  	},
 -	[AP_SM_STATE_WORKING] = {
 -		[AP_SM_EVENT_POLL] = ap_sm_read_write,
 -		[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,
 +	[AP_STATE_QUEUE_FULL] = {
 +		[AP_EVENT_POLL] = ap_sm_read,
 +		[AP_EVENT_TIMEOUT] = ap_sm_reset,
  	},
 -	[AP_SM_STATE_QUEUE_FULL] = {
 -		[AP_SM_EVENT_POLL] = ap_sm_read,
 -		[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,
++<<<<<<< HEAD
 +	[AP_STATE_SUSPEND_WAIT] = {
 +		[AP_EVENT_POLL] = ap_sm_suspend_read,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
  	},
 +	[AP_STATE_REMOVE] = {
 +		[AP_EVENT_POLL] = ap_sm_nop,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
 +	},
 +	[AP_STATE_UNBOUND] = {
 +		[AP_EVENT_POLL] = ap_sm_nop,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
 +	},
 +	[AP_STATE_BORKED] = {
 +		[AP_EVENT_POLL] = ap_sm_nop,
 +		[AP_EVENT_TIMEOUT] = ap_sm_nop,
 +	},
++=======
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  };
  
 -enum ap_sm_wait ap_sm_event(struct ap_queue *aq, enum ap_sm_event event)
 +enum ap_wait ap_sm_event(struct ap_queue *aq, enum ap_event event)
  {
++<<<<<<< HEAD
 +	return ap_jumptable[aq->state][event](aq);
++=======
+ 	if (aq->dev_state > AP_DEV_STATE_UNINITIATED)
+ 		return ap_jumptable[aq->sm_state][event](aq);
+ 	else
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  }
  
 -enum ap_sm_wait ap_sm_event_loop(struct ap_queue *aq, enum ap_sm_event event)
 +enum ap_wait ap_sm_event_loop(struct ap_queue *aq, enum ap_event event)
  {
 -	enum ap_sm_wait wait;
 +	enum ap_wait wait;
  
 -	while ((wait = ap_sm_event(aq, event)) == AP_SM_WAIT_AGAIN)
 +	while ((wait = ap_sm_event(aq, event)) == AP_WAIT_AGAIN)
  		;
  	return wait;
  }
@@@ -638,7 -655,6 +750,10 @@@ struct ap_queue *ap_queue_create(ap_qid
  	aq->ap_dev.device.type = &ap_queue_type;
  	aq->ap_dev.device_type = device_type;
  	aq->qid = qid;
++<<<<<<< HEAD
 +	aq->state = AP_STATE_UNBOUND;
++=======
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	aq->interrupt = AP_INTR_DISABLED;
  	spin_lock_init(&aq->lock);
  	INIT_LIST_HEAD(&aq->pendingq);
@@@ -671,14 -687,22 +786,26 @@@ int ap_queue_message(struct ap_queue *a
  	BUG_ON(!ap_msg->receive);
  
  	spin_lock_bh(&aq->lock);
- 	/* Queue the message. */
- 	list_add_tail(&ap_msg->list, &aq->requestq);
- 	aq->requestq_count++;
- 	aq->total_request_count++;
- 	atomic64_inc(&aq->card->total_request_count);
+ 
+ 	/* only allow to queue new messages if device state is ok */
+ 	if (aq->dev_state == AP_DEV_STATE_OPERATING) {
+ 		list_add_tail(&ap_msg->list, &aq->requestq);
+ 		aq->requestq_count++;
+ 		aq->total_request_count++;
+ 		atomic64_inc(&aq->card->total_request_count);
+ 	} else
+ 		rc = -ENODEV;
+ 
  	/* Send/receive as many request from the queue as possible. */
++<<<<<<< HEAD
 +	ap_wait(ap_sm_event_loop(aq, AP_EVENT_POLL));
++=======
+ 	ap_wait(ap_sm_event_loop(aq, AP_SM_EVENT_POLL));
+ 
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	spin_unlock_bh(&aq->lock);
+ 
+ 	return rc;
  }
  EXPORT_SYMBOL(ap_queue_message);
  
@@@ -749,8 -773,8 +876,13 @@@ void ap_queue_prepare_remove(struct ap_
  	spin_lock_bh(&aq->lock);
  	/* flush queue */
  	__ap_flush_queue(aq);
++<<<<<<< HEAD
 +	/* set REMOVE state to prevent new messages are queued in */
 +	aq->state = AP_STATE_REMOVE;
++=======
+ 	/* move queue device state to SHUTDOWN in progress */
+ 	aq->dev_state = AP_DEV_STATE_SHUTDOWN;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	spin_unlock_bh(&aq->lock);
  	del_timer_sync(&aq->timeout);
  }
@@@ -758,23 -782,23 +890,40 @@@
  void ap_queue_remove(struct ap_queue *aq)
  {
  	/*
++<<<<<<< HEAD
 +	 * all messages have been flushed and the state is
 +	 * AP_STATE_REMOVE. Now reset with zero which also
 +	 * clears the irq registration and move the state
 +	 * to AP_STATE_UNBOUND to signal that this queue
 +	 * is not used by any driver currently.
 +	 */
 +	spin_lock_bh(&aq->lock);
 +	ap_zapq(aq->qid);
 +	aq->state = AP_STATE_UNBOUND;
++=======
+ 	 * all messages have been flushed and the device state
+ 	 * is SHUTDOWN. Now reset with zero which also clears
+ 	 * the irq registration and move the device state
+ 	 * to the initial value AP_DEV_STATE_UNINITIATED.
+ 	 */
+ 	spin_lock_bh(&aq->lock);
+ 	ap_zapq(aq->qid);
+ 	aq->dev_state = AP_DEV_STATE_UNINITIATED;
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	spin_unlock_bh(&aq->lock);
  }
  
  void ap_queue_init_state(struct ap_queue *aq)
  {
  	spin_lock_bh(&aq->lock);
++<<<<<<< HEAD
 +	aq->state = AP_STATE_RESET_START;
 +	ap_wait(ap_sm_event(aq, AP_EVENT_POLL));
++=======
+ 	aq->dev_state = AP_DEV_STATE_OPERATING;
+ 	aq->sm_state = AP_SM_STATE_RESET_START;
+ 	ap_wait(ap_sm_event(aq, AP_SM_EVENT_POLL));
++>>>>>>> 0b641cbd2444 (s390/ap: split ap queue state machine state from device state)
  	spin_unlock_bh(&aq->lock);
  }
  EXPORT_SYMBOL(ap_queue_init_state);
* Unmerged path drivers/s390/crypto/ap_bus.c
* Unmerged path drivers/s390/crypto/ap_bus.h
* Unmerged path drivers/s390/crypto/ap_queue.c
diff --git a/drivers/s390/crypto/zcrypt_msgtype50.c b/drivers/s390/crypto/zcrypt_msgtype50.c
index 7aedc338b445..349306c2f155 100644
--- a/drivers/s390/crypto/zcrypt_msgtype50.c
+++ b/drivers/s390/crypto/zcrypt_msgtype50.c
@@ -471,7 +471,9 @@ static long zcrypt_cex2a_modexpo(struct zcrypt_queue *zq,
 	if (rc)
 		goto out_free;
 	init_completion(&work);
-	ap_queue_message(zq->queue, &ap_msg);
+	rc = ap_queue_message(zq->queue, &ap_msg);
+	if (rc)
+		goto out_free;
 	rc = wait_for_completion_interruptible(&work);
 	if (rc == 0) {
 		rc = ap_msg.rc;
@@ -515,7 +517,9 @@ static long zcrypt_cex2a_modexpo_crt(struct zcrypt_queue *zq,
 	if (rc)
 		goto out_free;
 	init_completion(&work);
-	ap_queue_message(zq->queue, &ap_msg);
+	rc = ap_queue_message(zq->queue, &ap_msg);
+	if (rc)
+		goto out_free;
 	rc = wait_for_completion_interruptible(&work);
 	if (rc == 0) {
 		rc = ap_msg.rc;
diff --git a/drivers/s390/crypto/zcrypt_msgtype6.c b/drivers/s390/crypto/zcrypt_msgtype6.c
index 3c73516880c9..61942b44546a 100644
--- a/drivers/s390/crypto/zcrypt_msgtype6.c
+++ b/drivers/s390/crypto/zcrypt_msgtype6.c
@@ -1027,7 +1027,9 @@ static long zcrypt_msgtype6_modexpo(struct zcrypt_queue *zq,
 	if (rc)
 		goto out_free;
 	init_completion(&resp_type.work);
-	ap_queue_message(zq->queue, &ap_msg);
+	rc = ap_queue_message(zq->queue, &ap_msg);
+	if (rc)
+		goto out_free;
 	rc = wait_for_completion_interruptible(&resp_type.work);
 	if (rc == 0) {
 		rc = ap_msg.rc;
@@ -1071,7 +1073,9 @@ static long zcrypt_msgtype6_modexpo_crt(struct zcrypt_queue *zq,
 	if (rc)
 		goto out_free;
 	init_completion(&resp_type.work);
-	ap_queue_message(zq->queue, &ap_msg);
+	rc = ap_queue_message(zq->queue, &ap_msg);
+	if (rc)
+		goto out_free;
 	rc = wait_for_completion_interruptible(&resp_type.work);
 	if (rc == 0) {
 		rc = ap_msg.rc;
@@ -1130,7 +1134,9 @@ static long zcrypt_msgtype6_send_cprb(struct zcrypt_queue *zq,
 	struct response_type *rtype = (struct response_type *)(ap_msg->private);
 
 	init_completion(&rtype->work);
-	ap_queue_message(zq->queue, ap_msg);
+	rc = ap_queue_message(zq->queue, ap_msg);
+	if (rc)
+		goto out;
 	rc = wait_for_completion_interruptible(&rtype->work);
 	if (rc == 0) {
 		rc = ap_msg->rc;
@@ -1139,7 +1145,7 @@ static long zcrypt_msgtype6_send_cprb(struct zcrypt_queue *zq,
 	} else
 		/* Signal pending. */
 		ap_cancel_message(zq->queue, ap_msg);
-
+out:
 	return rc;
 }
 
@@ -1232,7 +1238,9 @@ static long zcrypt_msgtype6_send_ep11_cprb(struct zcrypt_queue *zq,
 	}
 
 	init_completion(&rtype->work);
-	ap_queue_message(zq->queue, ap_msg);
+	rc = ap_queue_message(zq->queue, ap_msg);
+	if (rc)
+		goto out;
 	rc = wait_for_completion_interruptible(&rtype->work);
 	if (rc == 0) {
 		rc = ap_msg->rc;
@@ -1241,7 +1249,7 @@ static long zcrypt_msgtype6_send_ep11_cprb(struct zcrypt_queue *zq,
 	} else
 		/* Signal pending. */
 		ap_cancel_message(zq->queue, ap_msg);
-
+out:
 	return rc;
 }
 
@@ -1293,7 +1301,9 @@ static long zcrypt_msgtype6_rng(struct zcrypt_queue *zq,
 	msg->cprbx.domain = AP_QID_QUEUE(zq->queue->qid);
 
 	init_completion(&rtype->work);
-	ap_queue_message(zq->queue, ap_msg);
+	rc = ap_queue_message(zq->queue, ap_msg);
+	if (rc)
+		goto out;
 	rc = wait_for_completion_interruptible(&rtype->work);
 	if (rc == 0) {
 		rc = ap_msg->rc;
@@ -1302,7 +1312,7 @@ static long zcrypt_msgtype6_rng(struct zcrypt_queue *zq,
 	} else
 		/* Signal pending. */
 		ap_cancel_message(zq->queue, ap_msg);
-
+out:
 	return rc;
 }
 
