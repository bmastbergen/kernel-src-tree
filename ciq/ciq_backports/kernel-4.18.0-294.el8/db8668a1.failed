net: phy: marvell: Configure TDR pulse based on measurement length

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andrew Lunn <andrew@lunn.ch>
commit db8668a1951954156c039b9f8fe2881d428a522c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/db8668a1.failed

When performing a TDR measurement for a short distance, the pulse
width should be low, to help differentiate between the outgoing pulse
and any reflection. For longer distances, the pulse should be wider,
to help with attenuation.

	Signed-off-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit db8668a1951954156c039b9f8fe2881d428a522c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/marvell.c
diff --cc drivers/net/phy/marvell.c
index e597bee2e966,2c04e3b2b285..000000000000
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@@ -1829,7 -1838,10 +1834,12 @@@ static int marvell_vct5_amplitude_dista
  
  static int marvell_vct5_amplitude_graph(struct phy_device *phydev)
  {
 -	struct marvell_priv *priv = phydev->priv;
  	int distance;
++<<<<<<< HEAD
++=======
+ 	u16 width;
+ 	int page;
++>>>>>>> db8668a19519 (net: phy: marvell: Configure TDR pulse based on measurement length)
  	int err;
  	u16 reg;
  
@@@ -1843,13 -1859,38 +1857,28 @@@
  	if (err)
  		return err;
  
 -	/* Reading the TDR data is very MDIO heavy. We need to optimize
 -	 * access to keep the time to a minimum. So lock the bus once,
 -	 * and don't release it until complete. We can then avoid having
 -	 * to change the page for every access, greatly speeding things
 -	 * up.
 -	 */
 -	page = phy_select_page(phydev, MII_MARVELL_VCT5_PAGE);
 -	if (page < 0)
 -		return page;
 -
 -	for (distance = priv->first;
 -	     distance <= priv->last;
 -	     distance += priv->step) {
 -		err = marvell_vct5_amplitude_distance(phydev, distance,
 -						      priv->pair);
 +	for (distance = 0; distance <= 100; distance++) {
 +		err = marvell_vct5_amplitude_distance(phydev, distance);
  		if (err)
++<<<<<<< HEAD
 +			return err;
++=======
+ 			goto restore_page;
+ 
+ 		if (distance > TDR_SHORT_CABLE_LENGTH &&
+ 		    width == MII_VCT5_TX_PULSE_CTRL_PULSE_WIDTH_32nS) {
+ 			width = MII_VCT5_TX_PULSE_CTRL_PULSE_WIDTH_128nS;
+ 			reg = MII_VCT5_TX_PULSE_CTRL_GT_140m_46_86mV |
+ 				MII_VCT5_TX_PULSE_CTRL_DONT_WAIT_LINK_DOWN |
+ 				MII_VCT5_TX_PULSE_CTRL_MAX_AMP | width;
+ 			err = __phy_write(phydev, MII_VCT5_TX_PULSE_CTRL, reg);
+ 			if (err)
+ 				goto restore_page;
+ 		}
++>>>>>>> db8668a19519 (net: phy: marvell: Configure TDR pulse based on measurement length)
  	}
  
 -restore_page:
 -	return phy_restore_page(phydev, page, err);
 +	return 0;
  }
  
  static int marvell_cable_test_start_common(struct phy_device *phydev)
* Unmerged path drivers/net/phy/marvell.c
