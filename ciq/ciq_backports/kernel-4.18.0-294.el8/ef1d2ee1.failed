KVM: VMX: Check guest support for RDTSCP before processing MSR_TSC_AUX

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit ef1d2ee12e6cd5abbf9986f35238f2fb2cd21a6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ef1d2ee1.failed

Check for RDTSCP support prior to checking if MSR_TSC_AUX is in the uret
MSRs array so that the array lookup and manipulation are back-to-back.
This paves the way toward adding a helper to wrap the lookup and
manipulation.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200923180409.32255-10-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ef1d2ee12e6cd5abbf9986f35238f2fb2cd21a6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 985a4bfb7517,068783a13ac8..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -1644,29 -1637,31 +1644,39 @@@ static void setup_msrs(struct vcpu_vmx 
  	 * when EFER.SCE is set.
  	 */
  	if (is_long_mode(&vmx->vcpu) && (vmx->vcpu.arch.efer & EFER_SCE)) {
 -		index = __vmx_find_uret_msr(vmx, MSR_STAR);
 +		index = __find_msr_index(vmx, MSR_STAR);
  		if (index >= 0)
 -			move_msr_up(vmx, index, nr_active_uret_msrs++);
 -		index = __vmx_find_uret_msr(vmx, MSR_LSTAR);
 +			move_msr_up(vmx, index, save_nmsrs++);
 +		index = __find_msr_index(vmx, MSR_LSTAR);
  		if (index >= 0)
 -			move_msr_up(vmx, index, nr_active_uret_msrs++);
 -		index = __vmx_find_uret_msr(vmx, MSR_SYSCALL_MASK);
 +			move_msr_up(vmx, index, save_nmsrs++);
 +		index = __find_msr_index(vmx, MSR_SYSCALL_MASK);
  		if (index >= 0)
 -			move_msr_up(vmx, index, nr_active_uret_msrs++);
 +			move_msr_up(vmx, index, save_nmsrs++);
  	}
  #endif
 -	index = __vmx_find_uret_msr(vmx, MSR_EFER);
 +	index = __find_msr_index(vmx, MSR_EFER);
  	if (index >= 0 && update_transition_efer(vmx, index))
++<<<<<<< HEAD
 +		move_msr_up(vmx, index, save_nmsrs++);
 +	index = __find_msr_index(vmx, MSR_TSC_AUX);
 +	if (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))
 +		move_msr_up(vmx, index, save_nmsrs++);
 +	index = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);
++=======
+ 		move_msr_up(vmx, index, nr_active_uret_msrs++);
+ 	if (guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP)) {
+ 		index = __vmx_find_uret_msr(vmx, MSR_TSC_AUX);
+ 		if (index >= 0)
+ 			move_msr_up(vmx, index, nr_active_uret_msrs++);
+ 	}
+ 	index = __vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);
++>>>>>>> ef1d2ee12e6c (KVM: VMX: Check guest support for RDTSCP before processing MSR_TSC_AUX)
  	if (index >= 0)
 -		move_msr_up(vmx, index, nr_active_uret_msrs++);
 +		move_msr_up(vmx, index, save_nmsrs++);
  
 -	vmx->nr_active_uret_msrs = nr_active_uret_msrs;
 -	vmx->guest_uret_msrs_loaded = false;
 +	vmx->save_nmsrs = save_nmsrs;
 +	vmx->guest_msrs_ready = false;
  
  	if (cpu_has_vmx_msr_bitmap())
  		vmx_update_msr_bitmap(&vmx->vcpu);
* Unmerged path arch/x86/kvm/vmx/vmx.c
