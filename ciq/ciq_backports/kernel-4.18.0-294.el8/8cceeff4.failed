kasan: detect negative size in memory operation function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Walter Wu <walter-zh.wu@mediatek.com>
commit 8cceeff48f23eede76de995df08cf665182ec8fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8cceeff4.failed

Patch series "fix the missing underflow in memory operation function", v4.

The patchset helps to produce a KASAN report when size is negative in
memory operation functions.  It is helpful for programmer to solve an
undefined behavior issue.  Patch 1 based on Dmitry's review and
suggestion, patch 2 is a test in order to verify the patch 1.

[1]https://bugzilla.kernel.org/show_bug.cgi?id=199341
[2]https://lore.kernel.org/linux-arm-kernel/20190927034338.15813-1-walter-zh.wu@mediatek.com/

This patch (of 2):

KASAN missed detecting size is a negative number in memset(), memcpy(),
and memmove(), it will cause out-of-bounds bug.  So needs to be detected
by KASAN.

If size is a negative number, then it has a reason to be defined as
out-of-bounds bug type.  Casting negative numbers to size_t would indeed
turn up as a large size_t and its value will be larger than ULONG_MAX/2,
so that this can qualify as out-of-bounds.

KASAN report is shown below:

 BUG: KASAN: out-of-bounds in kmalloc_memmove_invalid_size+0x70/0xa0
 Read of size 18446744073709551608 at addr ffffff8069660904 by task cat/72

 CPU: 2 PID: 72 Comm: cat Not tainted 5.4.0-rc1-next-20191004ajb-00001-gdb8af2f372b2-dirty #1
 Hardware name: linux,dummy-virt (DT)
 Call trace:
  dump_backtrace+0x0/0x288
  show_stack+0x14/0x20
  dump_stack+0x10c/0x164
  print_address_description.isra.9+0x68/0x378
  __kasan_report+0x164/0x1a0
  kasan_report+0xc/0x18
  check_memory_region+0x174/0x1d0
  memmove+0x34/0x88
  kmalloc_memmove_invalid_size+0x70/0xa0

[1] https://bugzilla.kernel.org/show_bug.cgi?id=199341

[cai@lca.pw: fix -Wdeclaration-after-statement warn]
  Link: http://lkml.kernel.org/r/1583509030-27939-1-git-send-email-cai@lca.pw
[peterz@infradead.org: fix objtool warning]
  Link: http://lkml.kernel.org/r/20200305095436.GV2596@hirez.programming.kicks-ass.net
	Reported-by: kernel test robot <lkp@intel.com>
	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Suggested-by: Dmitry Vyukov <dvyukov@google.com>
	Signed-off-by: Walter Wu <walter-zh.wu@mediatek.com>
	Signed-off-by: Qian Cai <cai@lca.pw>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Dmitry Vyukov <dvyukov@google.com>
	Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Alexander Potapenko <glider@google.com>
Link: http://lkml.kernel.org/r/20191112065302.7015-1-walter-zh.wu@mediatek.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8cceeff48f23eede76de995df08cf665182ec8fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kasan.h
#	mm/kasan/common.c
#	mm/kasan/generic.c
#	mm/kasan/generic_report.c
#	mm/kasan/kasan.h
#	mm/kasan/report.c
#	mm/kasan/tags.c
#	mm/kasan/tags_report.c
diff --cc include/linux/kasan.h
index 1e5ac58e377c,31314ca7c635..000000000000
--- a/include/linux/kasan.h
+++ b/include/linux/kasan.h
@@@ -159,4 -168,70 +159,73 @@@ static inline size_t kasan_metadata_siz
  
  #endif /* CONFIG_KASAN */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KASAN_GENERIC
+ 
+ #define KASAN_SHADOW_INIT 0
+ 
+ void kasan_cache_shrink(struct kmem_cache *cache);
+ void kasan_cache_shutdown(struct kmem_cache *cache);
+ 
+ #else /* CONFIG_KASAN_GENERIC */
+ 
+ static inline void kasan_cache_shrink(struct kmem_cache *cache) {}
+ static inline void kasan_cache_shutdown(struct kmem_cache *cache) {}
+ 
+ #endif /* CONFIG_KASAN_GENERIC */
+ 
+ #ifdef CONFIG_KASAN_SW_TAGS
+ 
+ #define KASAN_SHADOW_INIT 0xFF
+ 
+ void kasan_init_tags(void);
+ 
+ void *kasan_reset_tag(const void *addr);
+ 
+ bool kasan_report(unsigned long addr, size_t size,
+ 		bool is_write, unsigned long ip);
+ 
+ #else /* CONFIG_KASAN_SW_TAGS */
+ 
+ static inline void kasan_init_tags(void) { }
+ 
+ static inline void *kasan_reset_tag(const void *addr)
+ {
+ 	return (void *)addr;
+ }
+ 
+ #endif /* CONFIG_KASAN_SW_TAGS */
+ 
+ #ifdef CONFIG_KASAN_VMALLOC
+ int kasan_populate_vmalloc(unsigned long addr, unsigned long size);
+ void kasan_poison_vmalloc(const void *start, unsigned long size);
+ void kasan_unpoison_vmalloc(const void *start, unsigned long size);
+ void kasan_release_vmalloc(unsigned long start, unsigned long end,
+ 			   unsigned long free_region_start,
+ 			   unsigned long free_region_end);
+ #else
+ static inline int kasan_populate_vmalloc(unsigned long start,
+ 					unsigned long size)
+ {
+ 	return 0;
+ }
+ 
+ static inline void kasan_poison_vmalloc(const void *start, unsigned long size)
+ { }
+ static inline void kasan_unpoison_vmalloc(const void *start, unsigned long size)
+ { }
+ static inline void kasan_release_vmalloc(unsigned long start,
+ 					 unsigned long end,
+ 					 unsigned long free_region_start,
+ 					 unsigned long free_region_end) {}
+ #endif
+ 
+ #ifdef CONFIG_KASAN_INLINE
+ void kasan_non_canonical_hook(unsigned long addr);
+ #else /* CONFIG_KASAN_INLINE */
+ static inline void kasan_non_canonical_hook(unsigned long addr) { }
+ #endif /* CONFIG_KASAN_INLINE */
+ 
++>>>>>>> 8cceeff48f23 (kasan: detect negative size in memory operation function)
  #endif /* LINUX_KASAN_H */
diff --cc mm/kasan/kasan.h
index c12dcfde2ebd,e8f37199d885..000000000000
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@@ -105,7 -132,28 +105,32 @@@ static inline const void *kasan_shadow_
  		<< KASAN_SHADOW_SCALE_SHIFT);
  }
  
++<<<<<<< HEAD
 +void kasan_report(unsigned long addr, size_t size,
++=======
+ static inline bool addr_has_shadow(const void *addr)
+ {
+ 	return (addr >= kasan_shadow_to_mem((void *)KASAN_SHADOW_START));
+ }
+ 
+ void kasan_poison_shadow(const void *address, size_t size, u8 value);
+ 
+ /**
+  * check_memory_region - Check memory region, and report if invalid access.
+  * @addr: the accessed address
+  * @size: the accessed size
+  * @write: true if access is a write access
+  * @ret_ip: return address
+  * @return: true if access was valid, false if invalid
+  */
+ bool check_memory_region(unsigned long addr, size_t size, bool write,
+ 				unsigned long ret_ip);
+ 
+ void *find_first_bad_addr(void *addr, size_t size);
+ const char *get_bug_type(struct kasan_access_info *info);
+ 
+ bool kasan_report(unsigned long addr, size_t size,
++>>>>>>> 8cceeff48f23 (kasan: detect negative size in memory operation function)
  		bool is_write, unsigned long ip);
  void kasan_report_invalid_free(void *object, unsigned long ip);
  
diff --cc mm/kasan/report.c
index 5c169aa688fd,cf5c17d5e361..000000000000
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@@ -326,126 -446,106 +326,133 @@@ static void print_shadow_for_address(co
  	}
  }
  
 -bool report_enabled(void)
 -{
 -	if (current->kasan_depth)
 -		return false;
 -	if (test_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags))
 -		return true;
 -	return !test_and_set_bit(KASAN_BIT_REPORTED, &kasan_flags);
 -}
 -
++<<<<<<< HEAD
  void kasan_report_invalid_free(void *object, unsigned long ip)
  {
  	unsigned long flags;
 -	u8 tag = get_tag(object);
  
 -	object = reset_tag(object);
 -	start_report(&flags);
 +	kasan_start_report(&flags);
  	pr_err("BUG: KASAN: double-free or invalid-free in %pS\n", (void *)ip);
 -	print_tags(tag, object);
  	pr_err("\n");
 -	print_address_description(object, tag);
 +	print_address_description(object);
  	pr_err("\n");
  	print_shadow_for_address(object);
 -	end_report(&flags);
 +	kasan_end_report(&flags);
  }
  
 -void __kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip)
 +static void kasan_report_error(struct kasan_access_info *info)
  {
 -	struct kasan_access_info info;
 -	void *tagged_addr;
 -	void *untagged_addr;
  	unsigned long flags;
  
 -	disable_trace_on_warning();
 -
 -	tagged_addr = (void *)addr;
 -	untagged_addr = reset_tag(tagged_addr);
 -
 -	info.access_addr = tagged_addr;
 -	if (addr_has_shadow(untagged_addr))
 -		info.first_bad_addr = find_first_bad_addr(tagged_addr, size);
 -	else
 -		info.first_bad_addr = untagged_addr;
 -	info.access_size = size;
 -	info.is_write = is_write;
 -	info.ip = ip;
 -
 -	start_report(&flags);
 +	kasan_start_report(&flags);
  
 -	print_error_description(&info);
 -	if (addr_has_shadow(untagged_addr))
 -		print_tags(get_tag(tagged_addr), info.first_bad_addr);
 +	print_error_description(info);
  	pr_err("\n");
  
 -	if (addr_has_shadow(untagged_addr)) {
 -		print_address_description(untagged_addr, get_tag(tagged_addr));
 -		pr_err("\n");
 -		print_shadow_for_address(info.first_bad_addr);
 -	} else {
 +	if (!addr_has_shadow(info)) {
  		dump_stack();
 +	} else {
 +		print_address_description((void *)info->access_addr);
 +		pr_err("\n");
 +		print_shadow_for_address(info->first_bad_addr);
  	}
  
 -	end_report(&flags);
 +	kasan_end_report(&flags);
  }
  
 -#ifdef CONFIG_KASAN_INLINE
 -/*
 - * With CONFIG_KASAN_INLINE, accesses to bogus pointers (outside the high
 - * canonical half of the address space) cause out-of-bounds shadow memory reads
 - * before the actual access. For addresses in the low canonical half of the
 - * address space, as well as most non-canonical addresses, that out-of-bounds
 - * shadow memory access lands in the non-canonical part of the address space.
 - * Help the user figure out what the original bogus pointer was.
 - */
 -void kasan_non_canonical_hook(unsigned long addr)
 +static unsigned long kasan_flags;
 +
 +#define KASAN_BIT_REPORTED	0
 +#define KASAN_BIT_MULTI_SHOT	1
 +
 +bool kasan_save_enable_multi_shot(void)
 +{
 +	return test_and_set_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags);
 +}
 +EXPORT_SYMBOL_GPL(kasan_save_enable_multi_shot);
 +
 +void kasan_restore_multi_shot(bool enabled)
 +{
 +	if (!enabled)
 +		clear_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags);
 +}
 +EXPORT_SYMBOL_GPL(kasan_restore_multi_shot);
 +
 +static int __init kasan_set_multi_shot(char *str)
 +{
 +	set_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags);
 +	return 1;
 +}
 +__setup("kasan_multi_shot", kasan_set_multi_shot);
 +
 +static inline bool kasan_report_enabled(void)
++=======
++bool report_enabled(void)
++>>>>>>> 8cceeff48f23 (kasan: detect negative size in memory operation function)
  {
 -	unsigned long orig_addr;
 -	const char *bug_type;
 +	if (current->kasan_depth)
 +		return false;
 +	if (test_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags))
 +		return true;
 +	return !test_and_set_bit(KASAN_BIT_REPORTED, &kasan_flags);
 +}
  
 -	if (addr < KASAN_SHADOW_OFFSET)
 +void kasan_report(unsigned long addr, size_t size,
 +		bool is_write, unsigned long ip)
 +{
 +	struct kasan_access_info info;
 +
++<<<<<<< HEAD
 +	if (likely(!kasan_report_enabled()))
  		return;
  
 -	orig_addr = (addr - KASAN_SHADOW_OFFSET) << KASAN_SHADOW_SCALE_SHIFT;
 -	/*
 -	 * For faults near the shadow address for NULL, we can be fairly certain
 -	 * that this is a KASAN shadow memory access.
 -	 * For faults that correspond to shadow for low canonical addresses, we
 -	 * can still be pretty sure - that shadow region is a fairly narrow
 -	 * chunk of the non-canonical address space.
 -	 * But faults that look like shadow for non-canonical addresses are a
 -	 * really large chunk of the address space. In that case, we still
 -	 * print the decoded address, but make it clear that this is not
 -	 * necessarily what's actually going on.
 -	 */
 -	if (orig_addr < PAGE_SIZE)
 -		bug_type = "null-ptr-deref";
 -	else if (orig_addr < TASK_SIZE)
 -		bug_type = "probably user-memory-access";
 -	else
 -		bug_type = "maybe wild-memory-access";
 -	pr_alert("KASAN: %s in range [0x%016lx-0x%016lx]\n", bug_type,
 -		 orig_addr, orig_addr + KASAN_SHADOW_MASK);
++=======
++>>>>>>> 8cceeff48f23 (kasan: detect negative size in memory operation function)
 +	disable_trace_on_warning();
 +
 +	info.access_addr = (void *)addr;
 +	info.first_bad_addr = (void *)addr;
 +	info.access_size = size;
 +	info.is_write = is_write;
 +	info.ip = ip;
 +
 +	kasan_report_error(&info);
 +}
 +
 +
 +#define DEFINE_ASAN_REPORT_LOAD(size)                     \
 +void __asan_report_load##size##_noabort(unsigned long addr) \
 +{                                                         \
 +	kasan_report(addr, size, false, _RET_IP_);	  \
 +}                                                         \
 +EXPORT_SYMBOL(__asan_report_load##size##_noabort)
 +
 +#define DEFINE_ASAN_REPORT_STORE(size)                     \
 +void __asan_report_store##size##_noabort(unsigned long addr) \
 +{                                                          \
 +	kasan_report(addr, size, true, _RET_IP_);	   \
 +}                                                          \
 +EXPORT_SYMBOL(__asan_report_store##size##_noabort)
 +
 +DEFINE_ASAN_REPORT_LOAD(1);
 +DEFINE_ASAN_REPORT_LOAD(2);
 +DEFINE_ASAN_REPORT_LOAD(4);
 +DEFINE_ASAN_REPORT_LOAD(8);
 +DEFINE_ASAN_REPORT_LOAD(16);
 +DEFINE_ASAN_REPORT_STORE(1);
 +DEFINE_ASAN_REPORT_STORE(2);
 +DEFINE_ASAN_REPORT_STORE(4);
 +DEFINE_ASAN_REPORT_STORE(8);
 +DEFINE_ASAN_REPORT_STORE(16);
 +
 +void __asan_report_load_n_noabort(unsigned long addr, size_t size)
 +{
 +	kasan_report(addr, size, false, _RET_IP_);
 +}
 +EXPORT_SYMBOL(__asan_report_load_n_noabort);
 +
 +void __asan_report_store_n_noabort(unsigned long addr, size_t size)
 +{
 +	kasan_report(addr, size, true, _RET_IP_);
  }
 -#endif
 +EXPORT_SYMBOL(__asan_report_store_n_noabort);
* Unmerged path mm/kasan/common.c
* Unmerged path mm/kasan/generic.c
* Unmerged path mm/kasan/generic_report.c
* Unmerged path mm/kasan/tags.c
* Unmerged path mm/kasan/tags_report.c
* Unmerged path include/linux/kasan.h
* Unmerged path mm/kasan/common.c
* Unmerged path mm/kasan/generic.c
* Unmerged path mm/kasan/generic_report.c
* Unmerged path mm/kasan/kasan.h
* Unmerged path mm/kasan/report.c
* Unmerged path mm/kasan/tags.c
* Unmerged path mm/kasan/tags_report.c
