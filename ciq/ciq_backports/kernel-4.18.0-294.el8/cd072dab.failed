x86/fault: Add a helper function to sanitize error code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit cd072dab453a9b4a9f7927f9eddca5a156fbd87d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cd072dab.failed

vDSO exception fixup is a replacement for signals in limited situations.
Signals and vDSO exception fixup need to provide similar information to
userspace, including the hardware error code.

That hardware error code needs to be sanitized.  For instance, if userspace
accesses a kernel address, the error code could indicate to userspace
whether the address had a Present=1 PTE.  That can leak information about
the kernel layout to userspace, which is bad.

The existing signal code does this sanitization, but fairly late in the
signal process.  The vDSO exception code runs before the sanitization
happens.

Move error code sanitization out of the signal code and into a helper.
Call the helper in the signal code.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Jarkko Sakkinen <jarkko@kernel.org>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Acked-by: Jethro Beekman <jethro@fortanix.com>
Link: https://lkml.kernel.org/r/20201112220135.165028-18-jarkko@kernel.org
(cherry picked from commit cd072dab453a9b4a9f7927f9eddca5a156fbd87d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/fault.c
diff --cc arch/x86/mm/fault.c
index e075641dae7b,0161d4acf3ad..000000000000
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@@ -662,9 -609,19 +660,15 @@@ static void sanitize_error_code(unsigne
  	 * To avoid leaking information about the kernel page
  	 * table layout, pretend that user-mode accesses to
  	 * kernel addresses are always protection faults.
 -	 *
 -	 * NB: This means that failed vsyscalls with vsyscall=none
 -	 * will have the PROT bit.  This doesn't leak any
 -	 * information and does not appear to cause any problems.
  	 */
  	if (address >= TASK_SIZE_MAX)
- 		error_code |= X86_PF_PROT;
+ 		*error_code |= X86_PF_PROT;
+ }
+ 
+ static void set_signal_archinfo(unsigned long address,
+ 				unsigned long error_code)
+ {
+ 	struct task_struct *tsk = current;
  
  	tsk->thread.trap_nr = X86_TRAP_PF;
  	tsk->thread.error_code = error_code | X86_PF_USER;
@@@ -839,25 -812,7 +845,29 @@@ __bad_area_nosemaphore(struct pt_regs *
  		if (is_errata100(regs, address))
  			return;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_64
 +		/*
 +		 * Instruction fetch faults in the vsyscall page might need
 +		 * emulation.
 +		 */
 +		if (unlikely((error_code & X86_PF_INSTR) &&
 +			     ((address & ~0xfff) == VSYSCALL_ADDR))) {
 +			if (emulate_vsyscall(regs, address))
 +				return;
 +		}
 +#endif
 +
 +		/*
 +		 * To avoid leaking information about the kernel page table
 +		 * layout, pretend that user-mode accesses to kernel addresses
 +		 * are always protection faults.
 +		 */
 +		if (address >= TASK_SIZE_MAX)
 +			error_code |= X86_PF_PROT;
++=======
+ 		sanitize_error_code(address, &error_code);
++>>>>>>> cd072dab453a (x86/fault: Add a helper function to sanitize error code)
  
  		if (likely(show_unhandled_signals))
  			show_signal_msg(regs, error_code, address, tsk);
* Unmerged path arch/x86/mm/fault.c
