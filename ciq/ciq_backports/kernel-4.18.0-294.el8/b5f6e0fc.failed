mm/kasan: change kasan_check_{read,write} to return boolean

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [mm] mm/kasan: change kasan_check_{read, write} to return boolean (Nico Pache) [1894223]
Rebuild_FUZZ: 99.16%
commit-author Marco Elver <elver@google.com>
commit b5f6e0fc7d60e0234dac82498e90dfe9027bad1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b5f6e0fc.failed

This changes {,__}kasan_check_{read,write} functions to return a boolean
denoting if the access was valid or not.

[sfr@canb.auug.org.au: include types.h for "bool"]
  Link: http://lkml.kernel.org/r/20190705184949.13cdd021@canb.auug.org.au
Link: http://lkml.kernel.org/r/20190626142014.141844-3-elver@google.com
	Signed-off-by: Marco Elver <elver@google.com>
	Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
	Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Konovalov <andreyknvl@google.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: Kees Cook <keescook@chromium.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b5f6e0fc7d60e0234dac82498e90dfe9027bad1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kasan-checks.h
#	mm/kasan/generic.c
#	mm/kasan/kasan.c
#	mm/kasan/kasan.h
#	mm/kasan/tags.c
diff --cc include/linux/kasan-checks.h
index d314150658a4,ac6aba632f2d..000000000000
--- a/include/linux/kasan-checks.h
+++ b/include/linux/kasan-checks.h
@@@ -2,14 -2,43 +2,49 @@@
  #ifndef _LINUX_KASAN_CHECKS_H
  #define _LINUX_KASAN_CHECKS_H
  
++<<<<<<< HEAD
 +#ifdef CONFIG_KASAN
 +void kasan_check_read(const volatile void *p, unsigned int size);
 +void kasan_check_write(const volatile void *p, unsigned int size);
++=======
+ #include <linux/types.h>
+ 
+ /*
+  * __kasan_check_*: Always available when KASAN is enabled. This may be used
+  * even in compilation units that selectively disable KASAN, but must use KASAN
+  * to validate access to an address.   Never use these in header files!
+  */
+ #ifdef CONFIG_KASAN
+ bool __kasan_check_read(const volatile void *p, unsigned int size);
+ bool __kasan_check_write(const volatile void *p, unsigned int size);
+ #else
+ static inline bool __kasan_check_read(const volatile void *p, unsigned int size)
+ {
+ 	return true;
+ }
+ static inline bool __kasan_check_write(const volatile void *p, unsigned int size)
+ {
+ 	return true;
+ }
+ #endif
+ 
+ /*
+  * kasan_check_*: Only available when the particular compilation unit has KASAN
+  * instrumentation enabled. May be used in header files.
+  */
+ #ifdef __SANITIZE_ADDRESS__
+ #define kasan_check_read __kasan_check_read
+ #define kasan_check_write __kasan_check_write
++>>>>>>> b5f6e0fc7d60 (mm/kasan: change kasan_check_{read,write} to return boolean)
  #else
- static inline void kasan_check_read(const volatile void *p, unsigned int size)
- { }
- static inline void kasan_check_write(const volatile void *p, unsigned int size)
- { }
+ static inline bool kasan_check_read(const volatile void *p, unsigned int size)
+ {
+ 	return true;
+ }
+ static inline bool kasan_check_write(const volatile void *p, unsigned int size)
+ {
+ 	return true;
+ }
  #endif
  
  #endif
diff --cc mm/kasan/kasan.c
index d79269dd4b58,2277b82902d8..000000000000
--- a/mm/kasan/kasan.c
+++ b/mm/kasan/kasan.c
@@@ -50,6 -87,44 +50,47 @@@ void kasan_disable_current(void
  	current->kasan_depth--;
  }
  
++<<<<<<< HEAD:mm/kasan/kasan.c
++=======
+ bool __kasan_check_read(const volatile void *p, unsigned int size)
+ {
+ 	return check_memory_region((unsigned long)p, size, false, _RET_IP_);
+ }
+ EXPORT_SYMBOL(__kasan_check_read);
+ 
+ bool __kasan_check_write(const volatile void *p, unsigned int size)
+ {
+ 	return check_memory_region((unsigned long)p, size, true, _RET_IP_);
+ }
+ EXPORT_SYMBOL(__kasan_check_write);
+ 
+ #undef memset
+ void *memset(void *addr, int c, size_t len)
+ {
+ 	check_memory_region((unsigned long)addr, len, true, _RET_IP_);
+ 
+ 	return __memset(addr, c, len);
+ }
+ 
+ #undef memmove
+ void *memmove(void *dest, const void *src, size_t len)
+ {
+ 	check_memory_region((unsigned long)src, len, false, _RET_IP_);
+ 	check_memory_region((unsigned long)dest, len, true, _RET_IP_);
+ 
+ 	return __memmove(dest, src, len);
+ }
+ 
+ #undef memcpy
+ void *memcpy(void *dest, const void *src, size_t len)
+ {
+ 	check_memory_region((unsigned long)src, len, false, _RET_IP_);
+ 	check_memory_region((unsigned long)dest, len, true, _RET_IP_);
+ 
+ 	return __memcpy(dest, src, len);
+ }
+ 
++>>>>>>> b5f6e0fc7d60 (mm/kasan: change kasan_check_{read,write} to return boolean):mm/kasan/common.c
  /*
   * Poisons the shadow memory for 'size' bytes starting from 'addr'.
   * Memory addresses should be aligned to KASAN_SHADOW_SCALE_SIZE.
diff --cc mm/kasan/kasan.h
index c12dcfde2ebd,014f19e76247..000000000000
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@@ -105,6 -121,27 +105,30 @@@ static inline const void *kasan_shadow_
  		<< KASAN_SHADOW_SCALE_SHIFT);
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool addr_has_shadow(const void *addr)
+ {
+ 	return (addr >= kasan_shadow_to_mem((void *)KASAN_SHADOW_START));
+ }
+ 
+ void kasan_poison_shadow(const void *address, size_t size, u8 value);
+ 
+ /**
+  * check_memory_region - Check memory region, and report if invalid access.
+  * @addr: the accessed address
+  * @size: the accessed size
+  * @write: true if access is a write access
+  * @ret_ip: return address
+  * @return: true if access was valid, false if invalid
+  */
+ bool check_memory_region(unsigned long addr, size_t size, bool write,
+ 				unsigned long ret_ip);
+ 
+ void *find_first_bad_addr(void *addr, size_t size);
+ const char *get_bug_type(struct kasan_access_info *info);
+ 
++>>>>>>> b5f6e0fc7d60 (mm/kasan: change kasan_check_{read,write} to return boolean)
  void kasan_report(unsigned long addr, size_t size,
  		bool is_write, unsigned long ip);
  void kasan_report_invalid_free(void *object, unsigned long ip);
* Unmerged path mm/kasan/generic.c
* Unmerged path mm/kasan/tags.c
* Unmerged path include/linux/kasan-checks.h
* Unmerged path mm/kasan/generic.c
* Unmerged path mm/kasan/kasan.c
* Unmerged path mm/kasan/kasan.h
* Unmerged path mm/kasan/tags.c
