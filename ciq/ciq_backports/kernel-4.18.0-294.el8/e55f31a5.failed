efi: x86: move efi_is_table_address() into arch/x86

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ard Biesheuvel <ard.biesheuvel@linaro.org>
commit e55f31a599478fb06a5a5d95e019e963322535cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e55f31a5.failed

The function efi_is_table_address() and the associated array of table
pointers is specific to x86. Since we will be adding some more x86
specific tables, let's move this code out of the generic code first.

	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
(cherry picked from commit e55f31a599478fb06a5a5d95e019e963322535cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi.c
#	include/linux/efi.h
diff --cc drivers/firmware/efi/efi.c
index 3c0464112093,cbdbdbc8f9eb..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -62,33 -57,6 +62,36 @@@ struct efi __read_mostly efi = 
  };
  EXPORT_SYMBOL(efi);
  
++<<<<<<< HEAD
 +static unsigned long *efi_tables[] = {
 +	&efi.mps,
 +	&efi.acpi,
 +	&efi.acpi20,
 +	&efi.smbios,
 +	&efi.smbios3,
 +	&efi.sal_systab,
 +	&efi.boot_info,
 +	&efi.hcdp,
 +	&efi.uga,
 +	&efi.uv_systab,
 +	&efi.fw_vendor,
 +	&efi.runtime,
 +	&efi.config_table,
 +	&efi.esrt,
 +	&efi.properties_table,
 +	&efi.mem_attr_table,
 +#ifdef CONFIG_EFI_RCI2_TABLE
 +	&rci2_table_phys,
 +#endif
 +	&efi.tpm_log,
 +	&efi.tpm_final_log,
 +#ifdef CONFIG_LOAD_UEFI_KEYS
 +	&efi.mokvar_table,
 +#endif
 +};
 +
++=======
++>>>>>>> e55f31a59947 (efi: x86: move efi_is_table_address() into arch/x86)
  struct mm_struct efi_mm = {
  	.mm_rb			= RB_ROOT,
  	.mm_users		= ATOMIC_INIT(2),
diff --cc include/linux/efi.h
index f214b7a114d6,60a6242765d8..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -1216,17 -1211,6 +1216,20 @@@ static inline bool efi_enabled(int feat
  	return test_bit(feature, &efi.flags) != 0;
  }
  extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
++<<<<<<< HEAD
 +
 +bool __pure __efi_soft_reserve_enabled(void);
 +
 +static inline bool __pure efi_soft_reserve_enabled(void)
 +{
 +	return IS_ENABLED(CONFIG_EFI_SOFT_RESERVE)
 +		&& __efi_soft_reserve_enabled();
 +}
 +
 +extern bool efi_is_table_address(unsigned long phys_addr);
 +extern void __init efi_set_secure_boot(enum efi_secureboot_mode mode);
++=======
++>>>>>>> e55f31a59947 (efi: x86: move efi_is_table_address() into arch/x86)
  #else
  static inline bool efi_enabled(int feature)
  {
@@@ -1240,18 -1224,6 +1243,21 @@@ efi_capsule_pending(int *reset_type
  {
  	return false;
  }
++<<<<<<< HEAD
 +
 +static inline bool efi_soft_reserve_enabled(void)
 +{
 +	return false;
 +}
 +
 +static inline bool efi_is_table_address(unsigned long phys_addr)
 +{
 +	return false;
 +}
 +
 +static inline void efi_set_secure_boot(enum efi_secureboot_mode mode) {}
++=======
++>>>>>>> e55f31a59947 (efi: x86: move efi_is_table_address() into arch/x86)
  #endif
  
  extern int efi_status_to_err(efi_status_t status);
diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 42982a6cc6cf..03decf43f2b5 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -245,6 +245,7 @@ static inline bool efi_is_64bit(void)
 		__efi_early()->runtime_services), __VA_ARGS__)
 
 extern bool efi_reboot_required(void);
+extern bool efi_is_table_address(unsigned long phys_addr);
 
 #else
 static inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}
@@ -252,6 +253,10 @@ static inline bool efi_reboot_required(void)
 {
 	return false;
 }
+static inline  bool efi_is_table_address(unsigned long phys_addr)
+{
+	return false;
+}
 #endif /* CONFIG_EFI */
 
 #endif /* _ASM_X86_EFI_H */
diff --git a/arch/x86/mm/ioremap.c b/arch/x86/mm/ioremap.c
index 5d34b85ce6b1..5e8d854066df 100644
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@ -18,6 +18,7 @@
 
 #include <asm/set_memory.h>
 #include <asm/e820/api.h>
+#include <asm/efi.h>
 #include <asm/fixmap.h>
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c
index 4c3f7e46cc36..a9e78c0d2d4c 100644
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@ -64,6 +64,25 @@ static efi_config_table_type_t arch_tables[] __initdata = {
 	{NULL_GUID, NULL, NULL},
 };
 
+static const unsigned long * const efi_tables[] = {
+	&efi.mps,
+	&efi.acpi,
+	&efi.acpi20,
+	&efi.smbios,
+	&efi.smbios3,
+	&efi.sal_systab,
+	&efi.boot_info,
+	&efi.hcdp,
+	&efi.uga,
+	&efi.uv_systab,
+	&efi.fw_vendor,
+	&efi.runtime,
+	&efi.config_table,
+	&efi.esrt,
+	&efi.properties_table,
+	&efi.mem_attr_table,
+};
+
 u64 efi_setup;		/* efi setup_data physical address */
 
 static int add_efi_memmap __initdata;
@@ -1087,3 +1106,17 @@ static int __init arch_parse_efi_cmdline(char *str)
 	return 0;
 }
 early_param("efi", arch_parse_efi_cmdline);
+
+bool efi_is_table_address(unsigned long phys_addr)
+{
+	unsigned int i;
+
+	if (phys_addr == EFI_INVALID_TABLE_ADDR)
+		return false;
+
+	for (i = 0; i < ARRAY_SIZE(efi_tables); i++)
+		if (*(efi_tables[i]) == phys_addr)
+			return true;
+
+	return false;
+}
* Unmerged path drivers/firmware/efi/efi.c
* Unmerged path include/linux/efi.h
