KVM: selftests: test KVM_GET_SUPPORTED_HV_CPUID as a system ioctl

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 8b460692fee46a47cebd66d70df88dc9aa6d6b8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8b460692.failed

KVM_GET_SUPPORTED_HV_CPUID is now supported as both vCPU and VM ioctl,
test that.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20200929150944.1235688-3-vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8b460692fee46a47cebd66d70df88dc9aa6d6b8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
diff --cc tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
index a5f091036196,88a595b7fbdd..000000000000
--- a/tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
+++ b/tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
@@@ -46,20 -46,19 +46,34 @@@ static int smt_possible(void
  }
  
  static void test_hv_cpuid(struct kvm_cpuid2 *hv_cpuid_entries,
++<<<<<<< HEAD
 +			  int evmcs_enabled)
++=======
+ 			  bool evmcs_expected)
++>>>>>>> 8b460692fee4 (KVM: selftests: test KVM_GET_SUPPORTED_HV_CPUID as a system ioctl)
  {
  	int i;
 -	int nent = 9;
 -	u32 test_val;
  
++<<<<<<< HEAD
 +	if (!evmcs_enabled)
 +		TEST_ASSERT(hv_cpuid_entries->nent == 6,
 +			    "KVM_GET_SUPPORTED_HV_CPUID should return 6 entries"
 +			    " when Enlightened VMCS is disabled (returned %d)",
 +			    hv_cpuid_entries->nent);
 +	else
 +		TEST_ASSERT(hv_cpuid_entries->nent == 7,
 +			    "KVM_GET_SUPPORTED_HV_CPUID should return 7 entries"
 +			    " when Enlightened VMCS is enabled (returned %d)",
 +			    hv_cpuid_entries->nent);
++=======
+ 	if (evmcs_expected)
+ 		nent += 1; /* 0x4000000A */
+ 
+ 	TEST_ASSERT(hv_cpuid_entries->nent == nent,
+ 		    "KVM_GET_SUPPORTED_HV_CPUID should return %d entries"
+ 		    " with evmcs=%d (returned %d)",
+ 		    nent, evmcs_expected, hv_cpuid_entries->nent);
++>>>>>>> 8b460692fee4 (KVM: selftests: test KVM_GET_SUPPORTED_HV_CPUID as a system ioctl)
  
  	for (i = 0; i < hv_cpuid_entries->nent; i++) {
  		struct kvm_cpuid_entry2 *entry = &hv_cpuid_entries->entries[i];
@@@ -69,6 -68,9 +83,12 @@@
  			    "function %x is our of supported range",
  			    entry->function);
  
++<<<<<<< HEAD
++=======
+ 		TEST_ASSERT(evmcs_expected || (entry->function != 0x4000000A),
+ 			    "0x4000000A leaf should not be reported");
+ 
++>>>>>>> 8b460692fee4 (KVM: selftests: test KVM_GET_SUPPORTED_HV_CPUID as a system ioctl)
  		TEST_ASSERT(entry->index == 0,
  			    ".index field should be zero");
  
@@@ -78,12 -80,23 +98,25 @@@
  		TEST_ASSERT(!entry->padding[0] && !entry->padding[1] &&
  			    !entry->padding[2], "padding should be zero");
  
 -		switch (entry->function) {
 -		case 0x40000000:
 -			test_val = 0x40000082;
 +		if (entry->function == 0x40000004) {
 +			int nononarchcs = !!(entry->eax & (1UL << 18));
  
++<<<<<<< HEAD
 +			TEST_ASSERT(nononarchcs == !smt_possible(),
++=======
+ 			TEST_ASSERT(entry->eax == test_val,
+ 				    "Wrong max leaf report in 0x40000000.EAX: %x"
+ 				    " (evmcs=%d)",
+ 				    entry->eax, evmcs_expected
+ 				);
+ 			break;
+ 		case 0x40000004:
+ 			test_val = entry->eax & (1UL << 18);
+ 
+ 			TEST_ASSERT(!!test_val == !smt_possible(),
++>>>>>>> 8b460692fee4 (KVM: selftests: test KVM_GET_SUPPORTED_HV_CPUID as a system ioctl)
  				    "NoNonArchitecturalCoreSharing bit"
  				    " doesn't reflect SMT setting");
 -			break;
  		}
  
  		/*
@@@ -133,7 -152,6 +172,10 @@@ struct kvm_cpuid2 *kvm_get_supported_hv
  int main(int argc, char *argv[])
  {
  	struct kvm_vm *vm;
++<<<<<<< HEAD
 +	int rv;
++=======
++>>>>>>> 8b460692fee4 (KVM: selftests: test KVM_GET_SUPPORTED_HV_CPUID as a system ioctl)
  	struct kvm_cpuid2 *hv_cpuid_entries;
  
  	/* Tell stdout not to buffer its content */
@@@ -145,37 -162,40 +186,71 @@@
  		exit(KSFT_SKIP);
  	}
  
++<<<<<<< HEAD
 +	/* Create VM */
 +	vm = vm_create_default(VCPU_ID, 0, guest_code);
 +
 +	test_hv_cpuid_e2big(vm);
 +
 +	hv_cpuid_entries = kvm_get_supported_hv_cpuid(vm);
 +	if (!hv_cpuid_entries)
 +		return 1;
 +
 +	test_hv_cpuid(hv_cpuid_entries, 0);
 +
++=======
+ 	vm = vm_create_default(VCPU_ID, 0, guest_code);
+ 
+ 	/* Test vCPU ioctl version */
+ 	test_hv_cpuid_e2big(vm, false);
+ 
+ 	hv_cpuid_entries = kvm_get_supported_hv_cpuid(vm, false);
+ 	test_hv_cpuid(hv_cpuid_entries, false);
++>>>>>>> 8b460692fee4 (KVM: selftests: test KVM_GET_SUPPORTED_HV_CPUID as a system ioctl)
  	free(hv_cpuid_entries);
  
  	if (!nested_vmx_supported() ||
  	    !kvm_check_cap(KVM_CAP_HYPERV_ENLIGHTENED_VMCS)) {
  		print_skip("Enlightened VMCS is unsupported");
++<<<<<<< HEAD
 +		goto vm_free;
++=======
+ 		goto do_sys;
++>>>>>>> 8b460692fee4 (KVM: selftests: test KVM_GET_SUPPORTED_HV_CPUID as a system ioctl)
+ 	}
+ 	vcpu_enable_evmcs(vm, VCPU_ID);
+ 	hv_cpuid_entries = kvm_get_supported_hv_cpuid(vm, false);
+ 	test_hv_cpuid(hv_cpuid_entries, true);
+ 	free(hv_cpuid_entries);
+ 
+ do_sys:
+ 	/* Test system ioctl version */
+ 	if (!kvm_check_cap(KVM_CAP_SYS_HYPERV_CPUID)) {
+ 		print_skip("KVM_CAP_SYS_HYPERV_CPUID not supported");
+ 		goto out;
  	}
  
+ 	test_hv_cpuid_e2big(vm, true);
+ 
+ 	hv_cpuid_entries = kvm_get_supported_hv_cpuid(vm, true);
+ 	test_hv_cpuid(hv_cpuid_entries, nested_vmx_supported());
+ 	free(hv_cpuid_entries);
+ 
+ out:
+ 	kvm_vm_free(vm);
+ 
 +	vcpu_enable_evmcs(vm, VCPU_ID);
 +
 +	hv_cpuid_entries = kvm_get_supported_hv_cpuid(vm);
 +	if (!hv_cpuid_entries)
 +		return 1;
 +
 +	test_hv_cpuid(hv_cpuid_entries, 1);
 +
 +	free(hv_cpuid_entries);
 +
 +vm_free:
 +	kvm_vm_free(vm);
 +
  	return 0;
  }
diff --git a/tools/testing/selftests/kvm/include/kvm_util.h b/tools/testing/selftests/kvm/include/kvm_util.h
index 919e161dd289..59482e4eb308 100644
--- a/tools/testing/selftests/kvm/include/kvm_util.h
+++ b/tools/testing/selftests/kvm/include/kvm_util.h
@@ -112,6 +112,8 @@ void vcpu_ioctl(struct kvm_vm *vm, uint32_t vcpuid, unsigned long ioctl,
 int _vcpu_ioctl(struct kvm_vm *vm, uint32_t vcpuid, unsigned long ioctl,
 		void *arg);
 void vm_ioctl(struct kvm_vm *vm, unsigned long ioctl, void *arg);
+void kvm_ioctl(struct kvm_vm *vm, unsigned long ioctl, void *arg);
+int _kvm_ioctl(struct kvm_vm *vm, unsigned long ioctl, void *arg);
 void vm_mem_region_set_flags(struct kvm_vm *vm, uint32_t slot, uint32_t flags);
 void vm_mem_region_move(struct kvm_vm *vm, uint32_t slot, uint64_t new_gpa);
 void vm_mem_region_delete(struct kvm_vm *vm, uint32_t slot);
diff --git a/tools/testing/selftests/kvm/lib/kvm_util.c b/tools/testing/selftests/kvm/lib/kvm_util.c
index 3327cebc1095..cb1c7cb90715 100644
--- a/tools/testing/selftests/kvm/lib/kvm_util.c
+++ b/tools/testing/selftests/kvm/lib/kvm_util.c
@@ -1527,6 +1527,32 @@ void vm_ioctl(struct kvm_vm *vm, unsigned long cmd, void *arg)
 		cmd, ret, errno, strerror(errno));
 }
 
+/*
+ * KVM system ioctl
+ *
+ * Input Args:
+ *   vm - Virtual Machine
+ *   cmd - Ioctl number
+ *   arg - Argument to pass to the ioctl
+ *
+ * Return: None
+ *
+ * Issues an arbitrary ioctl on a KVM fd.
+ */
+void kvm_ioctl(struct kvm_vm *vm, unsigned long cmd, void *arg)
+{
+	int ret;
+
+	ret = ioctl(vm->kvm_fd, cmd, arg);
+	TEST_ASSERT(ret == 0, "KVM ioctl %lu failed, rc: %i errno: %i (%s)",
+		cmd, ret, errno, strerror(errno));
+}
+
+int _kvm_ioctl(struct kvm_vm *vm, unsigned long cmd, void *arg)
+{
+	return ioctl(vm->kvm_fd, cmd, arg);
+}
+
 /*
  * VM Dump
  *
* Unmerged path tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
