vfs: syscall: Add move_mount(2) to move mounts around

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 2db154b3ea8e14b04fee23e3fdfd5e9d17fbc6ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2db154b3.failed

Add a move_mount() system call that will move a mount from one place to
another and, in the next commit, allow to attach an unattached mount tree.

The new system call looks like the following:

	int move_mount(int from_dfd, const char *from_path,
		       int to_dfd, const char *to_path,
		       unsigned int flags);

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: linux-api@vger.kernel.org
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 2db154b3ea8e14b04fee23e3fdfd5e9d17fbc6ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/syscalls/syscall_32.tbl
#	arch/x86/entry/syscalls/syscall_64.tbl
#	include/linux/lsm_hooks.h
#	include/linux/security.h
#	include/linux/syscalls.h
#	include/uapi/linux/mount.h
diff --cc arch/x86/entry/syscalls/syscall_32.tbl
index 2eefd2a7c1ce,0db9effb18d9..000000000000
--- a/arch/x86/entry/syscalls/syscall_32.tbl
+++ b/arch/x86/entry/syscalls/syscall_32.tbl
@@@ -396,8 -396,42 +396,45 @@@
  382	i386	pkey_free		sys_pkey_free			__ia32_sys_pkey_free
  383	i386	statx			sys_statx			__ia32_sys_statx
  384	i386	arch_prctl		sys_arch_prctl			__ia32_compat_sys_arch_prctl
 -385	i386	io_pgetevents		sys_io_pgetevents_time32	__ia32_compat_sys_io_pgetevents
 +385	i386	io_pgetevents		sys_io_pgetevents		__ia32_compat_sys_io_pgetevents
  386	i386	rseq			sys_rseq			__ia32_sys_rseq
++<<<<<<< HEAD
++=======
+ 387	i386	open_tree		sys_open_tree			__ia32_sys_open_tree
+ 388	i386	move_mount		sys_move_mount			__ia32_sys_move_mount
+ # don't use numbers 389 through 392, add new calls at the end
+ 393	i386	semget			sys_semget    			__ia32_sys_semget
+ 394	i386	semctl			sys_semctl    			__ia32_compat_sys_semctl
+ 395	i386	shmget			sys_shmget    			__ia32_sys_shmget
+ 396	i386	shmctl			sys_shmctl    			__ia32_compat_sys_shmctl
+ 397	i386	shmat			sys_shmat     			__ia32_compat_sys_shmat
+ 398	i386	shmdt			sys_shmdt     			__ia32_sys_shmdt
+ 399	i386	msgget			sys_msgget    			__ia32_sys_msgget
+ 400	i386	msgsnd			sys_msgsnd    			__ia32_compat_sys_msgsnd
+ 401	i386	msgrcv			sys_msgrcv    			__ia32_compat_sys_msgrcv
+ 402	i386	msgctl			sys_msgctl    			__ia32_compat_sys_msgctl
+ 403	i386	clock_gettime64		sys_clock_gettime		__ia32_sys_clock_gettime
+ 404	i386	clock_settime64		sys_clock_settime		__ia32_sys_clock_settime
+ 405	i386	clock_adjtime64		sys_clock_adjtime		__ia32_sys_clock_adjtime
+ 406	i386	clock_getres_time64	sys_clock_getres		__ia32_sys_clock_getres
+ 407	i386	clock_nanosleep_time64	sys_clock_nanosleep		__ia32_sys_clock_nanosleep
+ 408	i386	timer_gettime64		sys_timer_gettime		__ia32_sys_timer_gettime
+ 409	i386	timer_settime64		sys_timer_settime		__ia32_sys_timer_settime
+ 410	i386	timerfd_gettime64	sys_timerfd_gettime		__ia32_sys_timerfd_gettime
+ 411	i386	timerfd_settime64	sys_timerfd_settime		__ia32_sys_timerfd_settime
+ 412	i386	utimensat_time64	sys_utimensat			__ia32_sys_utimensat
+ 413	i386	pselect6_time64		sys_pselect6			__ia32_compat_sys_pselect6_time64
+ 414	i386	ppoll_time64		sys_ppoll			__ia32_compat_sys_ppoll_time64
+ 416	i386	io_pgetevents_time64	sys_io_pgetevents		__ia32_sys_io_pgetevents
+ 417	i386	recvmmsg_time64		sys_recvmmsg			__ia32_compat_sys_recvmmsg_time64
+ 418	i386	mq_timedsend_time64	sys_mq_timedsend		__ia32_sys_mq_timedsend
+ 419	i386	mq_timedreceive_time64	sys_mq_timedreceive		__ia32_sys_mq_timedreceive
+ 420	i386	semtimedop_time64	sys_semtimedop			__ia32_sys_semtimedop
+ 421	i386	rt_sigtimedwait_time64	sys_rt_sigtimedwait		__ia32_compat_sys_rt_sigtimedwait_time64
+ 422	i386	futex_time64		sys_futex			__ia32_sys_futex
+ 423	i386	sched_rr_get_interval_time64	sys_sched_rr_get_interval	__ia32_sys_sched_rr_get_interval
+ 424	i386	pidfd_send_signal	sys_pidfd_send_signal		__ia32_sys_pidfd_send_signal
++>>>>>>> 2db154b3ea8e (vfs: syscall: Add move_mount(2) to move mounts around)
  425	i386	io_uring_setup		sys_io_uring_setup		__ia32_sys_io_uring_setup
  426	i386	io_uring_enter		sys_io_uring_enter		__ia32_sys_io_uring_enter
  427	i386	io_uring_register	sys_io_uring_register		__ia32_sys_io_uring_register
diff --cc arch/x86/entry/syscalls/syscall_64.tbl
index 65c026185e61,0440f0eefa02..000000000000
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@@ -343,6 -343,11 +343,14 @@@
  332	common	statx			__x64_sys_statx
  333	common	io_pgetevents		__x64_sys_io_pgetevents
  334	common	rseq			__x64_sys_rseq
++<<<<<<< HEAD
++=======
+ 335	common	open_tree		__x64_sys_open_tree
+ 336	common	move_mount		__x64_sys_move_mount
+ # don't use numbers 387 through 423, add new calls after the last
+ # 'common' entry
+ 424	common	pidfd_send_signal	__x64_sys_pidfd_send_signal
++>>>>>>> 2db154b3ea8e (vfs: syscall: Add move_mount(2) to move mounts around)
  425	common	io_uring_setup		__x64_sys_io_uring_setup
  426	common	io_uring_enter		__x64_sys_io_uring_enter
  427	common	io_uring_register	__x64_sys_io_uring_register
diff --cc include/linux/lsm_hooks.h
index bb664d716fe6,cb33f81cf5a1..000000000000
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@@ -1503,7 -1503,9 +1507,13 @@@ union security_list_options 
  					struct super_block *newsb,
  					unsigned long kern_flags,
  					unsigned long *set_kern_flags);
++<<<<<<< HEAD
 +	int (*sb_parse_opts_str)(char *options, struct security_mnt_opts *opts);
++=======
+ 	int (*sb_add_mnt_opt)(const char *option, const char *val, int len,
+ 			      void **mnt_opts);
+ 	int (*move_mount)(const struct path *from_path, const struct path *to_path);
++>>>>>>> 2db154b3ea8e (vfs: syscall: Add move_mount(2) to move mounts around)
  	int (*dentry_init_security)(struct dentry *dentry, int mode,
  					const struct qstr *name, void **ctx,
  					u32 *ctxlen);
@@@ -1838,7 -1839,8 +1848,12 @@@ struct security_hook_heads 
  	struct hlist_head sb_pivotroot;
  	struct hlist_head sb_set_mnt_opts;
  	struct hlist_head sb_clone_mnt_opts;
++<<<<<<< HEAD
 +	struct hlist_head sb_parse_opts_str;
++=======
+ 	struct hlist_head sb_add_mnt_opt;
+ 	struct hlist_head move_mount;
++>>>>>>> 2db154b3ea8e (vfs: syscall: Add move_mount(2) to move mounts around)
  	struct hlist_head dentry_init_security;
  	struct hlist_head dentry_create_files_as;
  #ifdef CONFIG_SECURITY_PATH
diff --cc include/linux/security.h
index ea494663ce29,1f2e06afc28f..000000000000
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@@ -268,7 -248,9 +268,13 @@@ int security_sb_clone_mnt_opts(const st
  				struct super_block *newsb,
  				unsigned long kern_flags,
  				unsigned long *set_kern_flags);
++<<<<<<< HEAD
 +int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts);
++=======
+ int security_add_mnt_opt(const char *option, const char *val,
+ 				int len, void **mnt_opts);
+ int security_move_mount(const struct path *from_path, const struct path *to_path);
++>>>>>>> 2db154b3ea8e (vfs: syscall: Add move_mount(2) to move mounts around)
  int security_dentry_init_security(struct dentry *dentry, int mode,
  					const struct qstr *name, void **ctx,
  					u32 *ctxlen);
diff --cc include/linux/syscalls.h
index ed03cace6180,84347fc0a1a7..000000000000
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@@ -914,6 -985,13 +914,16 @@@ asmlinkage long sys_statx(int dfd, cons
  			  unsigned mask, struct statx __user *buffer);
  asmlinkage long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len,
  			 int flags, uint32_t sig);
++<<<<<<< HEAD
++=======
+ asmlinkage long sys_open_tree(int dfd, const char __user *path, unsigned flags);
+ asmlinkage long sys_move_mount(int from_dfd, const char __user *from_path,
+ 			       int to_dfd, const char __user *to_path,
+ 			       unsigned int ms_flags);
+ asmlinkage long sys_pidfd_send_signal(int pidfd, int sig,
+ 				       siginfo_t __user *info,
+ 				       unsigned int flags);
++>>>>>>> 2db154b3ea8e (vfs: syscall: Add move_mount(2) to move mounts around)
  
  /*
   * Architecture-specific system calls
* Unmerged path include/uapi/linux/mount.h
* Unmerged path arch/x86/entry/syscalls/syscall_32.tbl
* Unmerged path arch/x86/entry/syscalls/syscall_64.tbl
diff --git a/fs/namespace.c b/fs/namespace.c
index f136970f49f7..b452aa24c461 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -2351,72 +2351,81 @@ static inline int tree_contains_unbindable(struct mount *mnt)
 	return 0;
 }
 
-static int do_move_mount(struct path *path, const char *old_name)
+static int do_move_mount(struct path *old_path, struct path *new_path)
 {
-	struct path old_path, parent_path;
+	struct path parent_path = {.mnt = NULL, .dentry = NULL};
 	struct mount *p;
 	struct mount *old;
 	struct mountpoint *mp;
 	int err;
-	if (!old_name || !*old_name)
-		return -EINVAL;
-	err = kern_path(old_name, LOOKUP_FOLLOW, &old_path);
-	if (err)
-		return err;
 
-	mp = lock_mount(path);
-	err = PTR_ERR(mp);
+	mp = lock_mount(new_path);
 	if (IS_ERR(mp))
-		goto out;
+		return PTR_ERR(mp);
 
-	old = real_mount(old_path.mnt);
-	p = real_mount(path->mnt);
+	old = real_mount(old_path->mnt);
+	p = real_mount(new_path->mnt);
 
 	err = -EINVAL;
 	if (!check_mnt(p) || !check_mnt(old))
-		goto out1;
+		goto out;
 
-	if (old->mnt.mnt_flags & MNT_LOCKED)
-		goto out1;
+	if (!mnt_has_parent(old))
+		goto out;
 
-	err = -EINVAL;
-	if (old_path.dentry != old_path.mnt->mnt_root)
-		goto out1;
+	if (old->mnt.mnt_flags & MNT_LOCKED)
+		goto out;
 
-	if (!mnt_has_parent(old))
-		goto out1;
+	if (old_path->dentry != old_path->mnt->mnt_root)
+		goto out;
 
-	if (d_is_dir(path->dentry) !=
-	      d_is_dir(old_path.dentry))
-		goto out1;
+	if (d_is_dir(new_path->dentry) !=
+	    d_is_dir(old_path->dentry))
+		goto out;
 	/*
 	 * Don't move a mount residing in a shared parent.
 	 */
 	if (IS_MNT_SHARED(old->mnt_parent))
-		goto out1;
+		goto out;
 	/*
 	 * Don't move a mount tree containing unbindable mounts to a destination
 	 * mount which is shared.
 	 */
 	if (IS_MNT_SHARED(p) && tree_contains_unbindable(old))
-		goto out1;
+		goto out;
 	err = -ELOOP;
 	for (; mnt_has_parent(p); p = p->mnt_parent)
 		if (p == old)
-			goto out1;
+			goto out;
 
-	err = attach_recursive_mnt(old, real_mount(path->mnt), mp, &parent_path);
+	err = attach_recursive_mnt(old, real_mount(new_path->mnt), mp,
+				   &parent_path);
 	if (err)
-		goto out1;
+		goto out;
 
 	/* if the mount is moved, it should no longer be expire
 	 * automatically */
 	list_del_init(&old->mnt_expire);
-out1:
-	unlock_mount(mp);
 out:
+	unlock_mount(mp);
 	if (!err)
 		path_put(&parent_path);
+	return err;
+}
+
+static int do_move_mount_old(struct path *path, const char *old_name)
+{
+	struct path old_path;
+	int err;
+
+	if (!old_name || !*old_name)
+		return -EINVAL;
+
+	err = kern_path(old_name, LOOKUP_FOLLOW, &old_path);
+	if (err)
+		return err;
+
+	err = do_move_mount(&old_path, path);
 	path_put(&old_path);
 	return err;
 }
@@ -2865,7 +2874,7 @@ long do_mount(const char *dev_name, const char __user *dir_name,
 	else if (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))
 		retval = do_change_type(&path, flags);
 	else if (flags & MS_MOVE)
-		retval = do_move_mount(&path, dev_name);
+		retval = do_move_mount_old(&path, dev_name);
 	else
 		retval = do_new_mount(&path, type_page, sb_flags, mnt_flags,
 				      dev_name, data_page);
@@ -3093,6 +3102,61 @@ SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,
 	return ksys_mount(dev_name, dir_name, type, flags, data);
 }
 
+/*
+ * Move a mount from one place to another.
+ *
+ * Note the flags value is a combination of MOVE_MOUNT_* flags.
+ */
+SYSCALL_DEFINE5(move_mount,
+		int, from_dfd, const char *, from_pathname,
+		int, to_dfd, const char *, to_pathname,
+		unsigned int, flags)
+{
+	struct path from_path, to_path;
+	unsigned int lflags;
+	int ret = 0;
+
+	if (!may_mount())
+		return -EPERM;
+
+	if (flags & ~MOVE_MOUNT__MASK)
+		return -EINVAL;
+
+	/* If someone gives a pathname, they aren't permitted to move
+	 * from an fd that requires unmount as we can't get at the flag
+	 * to clear it afterwards.
+	 */
+	lflags = 0;
+	if (flags & MOVE_MOUNT_F_SYMLINKS)	lflags |= LOOKUP_FOLLOW;
+	if (flags & MOVE_MOUNT_F_AUTOMOUNTS)	lflags |= LOOKUP_AUTOMOUNT;
+	if (flags & MOVE_MOUNT_F_EMPTY_PATH)	lflags |= LOOKUP_EMPTY;
+
+	ret = user_path_at(from_dfd, from_pathname, lflags, &from_path);
+	if (ret < 0)
+		return ret;
+
+	lflags = 0;
+	if (flags & MOVE_MOUNT_T_SYMLINKS)	lflags |= LOOKUP_FOLLOW;
+	if (flags & MOVE_MOUNT_T_AUTOMOUNTS)	lflags |= LOOKUP_AUTOMOUNT;
+	if (flags & MOVE_MOUNT_T_EMPTY_PATH)	lflags |= LOOKUP_EMPTY;
+
+	ret = user_path_at(to_dfd, to_pathname, lflags, &to_path);
+	if (ret < 0)
+		goto out_from;
+
+	ret = security_move_mount(&from_path, &to_path);
+	if (ret < 0)
+		goto out_to;
+
+	ret = do_move_mount(&from_path, &to_path);
+
+out_to:
+	path_put(&to_path);
+out_from:
+	path_put(&from_path);
+	return ret;
+}
+
 /*
  * Return true if path is reachable from root
  *
* Unmerged path include/linux/lsm_hooks.h
* Unmerged path include/linux/security.h
* Unmerged path include/linux/syscalls.h
* Unmerged path include/uapi/linux/mount.h
diff --git a/security/security.c b/security/security.c
index def81deae1f8..427733559e82 100644
--- a/security/security.c
+++ b/security/security.c
@@ -452,6 +452,11 @@ int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)
 }
 EXPORT_SYMBOL(security_sb_parse_opts_str);
 
+int security_move_mount(const struct path *from_path, const struct path *to_path)
+{
+	return call_int_hook(move_mount, 0, from_path, to_path);
+}
+
 int security_inode_alloc(struct inode *inode)
 {
 	inode->i_security = NULL;
