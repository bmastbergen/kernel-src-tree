usb: typec: mux: Drop support for device name matching

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit d80bdabea98698f14f741600595b15db051c2bae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d80bdabe.failed

There are no more users for the old device connection
descriptions that used device names.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Link: https://lore.kernel.org/r/20200211112531.86510-7-heikki.krogerus@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d80bdabea98698f14f741600595b15db051c2bae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/typec/mux.c
diff --cc drivers/usb/typec/mux.c
index 405d14dbac99,b952fa2fff39..000000000000
--- a/drivers/usb/typec/mux.c
+++ b/drivers/usb/typec/mux.c
@@@ -15,35 -15,37 +15,64 @@@
  #include <linux/slab.h>
  #include <linux/usb/typec_mux.h>
  
++<<<<<<< HEAD
 +static DEFINE_MUTEX(switch_lock);
 +static DEFINE_MUTEX(mux_lock);
 +static LIST_HEAD(switch_list);
 +static LIST_HEAD(mux_list);
++=======
+ #include "bus.h"
+ 
+ static bool dev_name_ends_with(struct device *dev, const char *suffix)
+ {
+ 	const char *name = dev_name(dev);
+ 	const int name_len = strlen(name);
+ 	const int suffix_len = strlen(suffix);
+ 
+ 	if (suffix_len > name_len)
+ 		return false;
+ 
+ 	return strcmp(name + (name_len - suffix_len), suffix) == 0;
+ }
+ 
+ static int switch_fwnode_match(struct device *dev, const void *fwnode)
+ {
+ 	return dev_fwnode(dev) == fwnode && dev_name_ends_with(dev, "-switch");
+ }
++>>>>>>> d80bdabea986 (usb: typec: mux: Drop support for device name matching)
  
  static void *typec_switch_match(struct device_connection *con, int ep,
  				void *data)
  {
 -	struct device *dev;
 +	struct typec_switch *sw;
  
++<<<<<<< HEAD
 +	if (!con->fwnode) {
 +		list_for_each_entry(sw, &switch_list, entry)
 +			if (!strcmp(con->endpoint[ep], dev_name(sw->dev)))
 +				return sw;
 +		return ERR_PTR(-EPROBE_DEFER);
 +	}
++=======
+ 	if (con->id && !fwnode_property_present(con->fwnode, con->id))
+ 		return NULL;
+ 
+ 	dev = class_find_device(&typec_mux_class, NULL, con->fwnode,
+ 				switch_fwnode_match);
++>>>>>>> d80bdabea986 (usb: typec: mux: Drop support for device name matching)
 +
 +	/*
 +	 * With OF graph the mux node must have a boolean device property named
 +	 * "orientation-switch".
 +	 */
 +	if (con->id && !fwnode_property_present(con->fwnode, con->id))
 +		return NULL;
 +
 +	list_for_each_entry(sw, &switch_list, entry)
 +		if (dev_fwnode(sw->dev) == con->fwnode)
 +			return sw;
  
 -	return dev ? to_typec_switch(dev) : ERR_PTR(-EPROBE_DEFER);
 +	return con->id ? ERR_PTR(-EPROBE_DEFER) : NULL;
  }
  
  /**
@@@ -131,13 -181,6 +160,16 @@@ static void *typec_mux_match(struct dev
  	u16 *val;
  	int i;
  
++<<<<<<< HEAD
 +	if (!con->fwnode) {
 +		list_for_each_entry(mux, &mux_list, entry)
 +			if (!strcmp(con->endpoint[ep], dev_name(mux->dev)))
 +				return mux;
 +		return ERR_PTR(-EPROBE_DEFER);
 +	}
 +
++=======
++>>>>>>> d80bdabea986 (usb: typec: mux: Drop support for device name matching)
  	/*
  	 * Check has the identifier already been "consumed". If it
  	 * has, no need to do any extra connection identification.
* Unmerged path drivers/usb/typec/mux.c
