KVM: arm64: Add build rules for separate VHE/nVHE object files

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Brazdil <dbrazdil@google.com>
commit 7621712918ad4f5e6356193d9058debf657a6254
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/76217129.failed

Add new folders arch/arm64/kvm/hyp/{vhe,nvhe} and Makefiles for building code
that runs in EL2 under VHE/nVHE KVM, repsectivelly. Add an include folder for
hyp-specific header files which will include code common to VHE/nVHE.

Build nVHE code with -D__KVM_NVHE_HYPERVISOR__, VHE code with
-D__KVM_VHE_HYPERVISOR__.

Under nVHE compile each source file into a `.hyp.tmp.o` object first, then
prefix all its symbols with "__kvm_nvhe_" using `objcopy` and produce
a `.hyp.o`. Suffixes were chosen so that it would be possible for VHE and nVHE
to share some source files, but compiled with different CFLAGS.

The nVHE ELF symbol prefix is added to kallsyms.c as ignored. EL2-only symbols
will never appear in EL1 stack traces.

Due to symbol prefixing, add a section in image-vars.h for aliases of symbols
that are defined in nVHE EL2 and accessed by kernel in EL1 or vice versa.

	Signed-off-by: David Brazdil <dbrazdil@google.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20200625131420.71444-4-dbrazdil@google.com
(cherry picked from commit 7621712918ad4f5e6356193d9058debf657a6254)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/hyp/Makefile
#	scripts/kallsyms.c
diff --cc arch/arm64/kvm/hyp/Makefile
index 9e1beab1b440,9c5dfe6ff80b..000000000000
--- a/arch/arm64/kvm/hyp/Makefile
+++ b/arch/arm64/kvm/hyp/Makefile
@@@ -3,9 -3,15 +3,21 @@@
  # Makefile for Kernel-based Virtual Machine module, HYP part
  #
  
++<<<<<<< HEAD
 +ccflags-y += -fno-stack-protector -DDISABLE_BRANCH_PROFILING
 +
 +obj-$(CONFIG_KVM) += hyp.o
++=======
+ incdir := $(srctree)/$(src)/include
+ subdir-asflags-y := -I$(incdir)
+ subdir-ccflags-y := -I$(incdir)				\
+ 		    -fno-stack-protector		\
+ 		    -DDISABLE_BRANCH_PROFILING		\
+ 		    $(DISABLE_STACKLEAK_PLUGIN)
+ 
+ obj-$(CONFIG_KVM) += hyp.o nvhe/
+ obj-$(CONFIG_KVM_INDIRECT_VECTORS) += smccc_wa.o
++>>>>>>> 7621712918ad (KVM: arm64: Add build rules for separate VHE/nVHE object files)
  
  hyp-y := vgic-v3-sr.o timer-sr.o aarch32.o vgic-v2-cpuif-proxy.o sysreg-sr.o \
  	 debug-sr.o entry.o switch.o fpsimd.o tlb.o hyp-entry.o
diff --cc scripts/kallsyms.c
index a9186a98a37d,0096cd965332..000000000000
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@@ -78,18 -75,89 +78,99 @@@ static void usage(void
  	exit(1);
  }
  
 -static char *sym_name(const struct sym_entry *s)
 +/*
 + * This ignores the intensely annoying "mapping symbols" found
 + * in ARM ELF files: $a, $t and $d.
 + */
 +static inline int is_arm_mapping_symbol(const char *str)
  {
 -	return (char *)s->sym + 1;
 +	return str[0] == '$' && strchr("axtd", str[1])
 +	       && (str[2] == '\0' || str[2] == '.');
  }
  
++<<<<<<< HEAD
 +static int check_symbol_range(const char *sym, unsigned long long addr,
 +			      struct addr_range *ranges, int entries)
++=======
+ static bool is_ignored_symbol(const char *name, char type)
+ {
+ 	static const char * const ignored_symbols[] = {
+ 		/*
+ 		 * Symbols which vary between passes. Passes 1 and 2 must have
+ 		 * identical symbol lists. The kallsyms_* symbols below are
+ 		 * only added after pass 1, they would be included in pass 2
+ 		 * when --all-symbols is specified so exclude them to get a
+ 		 * stable symbol list.
+ 		 */
+ 		"kallsyms_addresses",
+ 		"kallsyms_offsets",
+ 		"kallsyms_relative_base",
+ 		"kallsyms_num_syms",
+ 		"kallsyms_names",
+ 		"kallsyms_markers",
+ 		"kallsyms_token_table",
+ 		"kallsyms_token_index",
+ 		/* Exclude linker generated symbols which vary between passes */
+ 		"_SDA_BASE_",		/* ppc */
+ 		"_SDA2_BASE_",		/* ppc */
+ 		NULL
+ 	};
+ 
+ 	static const char * const ignored_prefixes[] = {
+ 		"$",			/* local symbols for ARM, MIPS, etc. */
+ 		".LASANPC",		/* s390 kasan local symbols */
+ 		"__crc_",		/* modversions */
+ 		"__efistub_",		/* arm64 EFI stub namespace */
+ 		"__kvm_nvhe_",		/* arm64 non-VHE KVM namespace */
+ 		NULL
+ 	};
+ 
+ 	static const char * const ignored_suffixes[] = {
+ 		"_from_arm",		/* arm */
+ 		"_from_thumb",		/* arm */
+ 		"_veneer",		/* arm */
+ 		NULL
+ 	};
+ 
+ 	const char * const *p;
+ 
+ 	/* Exclude symbols which vary between passes. */
+ 	for (p = ignored_symbols; *p; p++)
+ 		if (!strcmp(name, *p))
+ 			return true;
+ 
+ 	for (p = ignored_prefixes; *p; p++)
+ 		if (!strncmp(name, *p, strlen(*p)))
+ 			return true;
+ 
+ 	for (p = ignored_suffixes; *p; p++) {
+ 		int l = strlen(name) - strlen(*p);
+ 
+ 		if (l >= 0 && !strcmp(name + l, *p))
+ 			return true;
+ 	}
+ 
+ 	if (type == 'U' || type == 'u')
+ 		return true;
+ 	/* exclude debugging symbols */
+ 	if (type == 'N' || type == 'n')
+ 		return true;
+ 
+ 	if (toupper(type) == 'A') {
+ 		/* Keep these useful absolute symbols */
+ 		if (strcmp(name, "__kernel_syscall_via_break") &&
+ 		    strcmp(name, "__kernel_syscall_via_epc") &&
+ 		    strcmp(name, "__kernel_sigtramp") &&
+ 		    strcmp(name, "__gp"))
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static void check_symbol_range(const char *sym, unsigned long long addr,
+ 			       struct addr_range *ranges, int entries)
++>>>>>>> 7621712918ad (KVM: arm64: Add build rules for separate VHE/nVHE object files)
  {
  	size_t i;
  	struct addr_range *ar;
diff --git a/arch/arm64/kernel/image-vars.h b/arch/arm64/kernel/image-vars.h
index 25a2a9b479c2..3a270656fb06 100644
--- a/arch/arm64/kernel/image-vars.h
+++ b/arch/arm64/kernel/image-vars.h
@@ -48,4 +48,18 @@ __efistub_screen_info		= screen_info;
 
 #endif
 
+#ifdef CONFIG_KVM
+
+/*
+ * KVM nVHE code has its own symbol namespace prefixed with __kvm_nvhe_, to
+ * separate it from the kernel proper. The following symbols are legally
+ * accessed by it, therefore provide aliases to make them linkable.
+ * Do not include symbols which may not be safely accessed under hypervisor
+ * memory mappings.
+ */
+
+#define KVM_NVHE_ALIAS(sym) __kvm_nvhe_##sym = sym;
+
+#endif /* CONFIG_KVM */
+
 #endif /* __ARM64_KERNEL_IMAGE_VARS_H */
* Unmerged path arch/arm64/kvm/hyp/Makefile
diff --git a/arch/arm64/kvm/hyp/nvhe/Makefile b/arch/arm64/kvm/hyp/nvhe/Makefile
new file mode 100644
index 000000000000..955f4188e00f
--- /dev/null
+++ b/arch/arm64/kvm/hyp/nvhe/Makefile
@@ -0,0 +1,34 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for Kernel-based Virtual Machine module, HYP/nVHE part
+#
+
+asflags-y := -D__KVM_NVHE_HYPERVISOR__
+ccflags-y := -D__KVM_NVHE_HYPERVISOR__
+
+obj-y :=
+
+obj-y := $(patsubst %.o,%.hyp.o,$(obj-y))
+extra-y := $(patsubst %.hyp.o,%.hyp.tmp.o,$(obj-y))
+
+$(obj)/%.hyp.tmp.o: $(src)/%.c FORCE
+	$(call if_changed_rule,cc_o_c)
+$(obj)/%.hyp.tmp.o: $(src)/%.S FORCE
+	$(call if_changed_rule,as_o_S)
+$(obj)/%.hyp.o: $(obj)/%.hyp.tmp.o FORCE
+	$(call if_changed,hypcopy)
+
+quiet_cmd_hypcopy = HYPCOPY $@
+      cmd_hypcopy = $(OBJCOPY) --prefix-symbols=__kvm_nvhe_ $< $@
+
+# KVM nVHE code is run at a different exception code with a different map, so
+# compiler instrumentation that inserts callbacks or checks into the code may
+# cause crashes. Just disable it.
+GCOV_PROFILE	:= n
+KASAN_SANITIZE	:= n
+UBSAN_SANITIZE	:= n
+KCOV_INSTRUMENT	:= n
+
+# Skip objtool checking for this directory because nVHE code is compiled with
+# non-standard build rules.
+OBJECT_FILES_NON_STANDARD := y
diff --git a/arch/arm64/kvm/hyp/vhe/Makefile b/arch/arm64/kvm/hyp/vhe/Makefile
new file mode 100644
index 000000000000..e04375546081
--- /dev/null
+++ b/arch/arm64/kvm/hyp/vhe/Makefile
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for Kernel-based Virtual Machine module, HYP/nVHE part
+#
+
+asflags-y := -D__KVM_VHE_HYPERVISOR__
+ccflags-y := -D__KVM_VHE_HYPERVISOR__
+
+obj-y :=
+
+# KVM code is run at a different exception code with a different map, so
+# compiler instrumentation that inserts callbacks or checks into the code may
+# cause crashes. Just disable it.
+GCOV_PROFILE	:= n
+KASAN_SANITIZE	:= n
+UBSAN_SANITIZE	:= n
+KCOV_INSTRUMENT	:= n
* Unmerged path scripts/kallsyms.c
