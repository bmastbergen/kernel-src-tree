mm: free_area_init: allow defining max_zone_pfn in descending order

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mike Rapoport <rppt@linux.ibm.com>
commit 51930df5801e4da60e962ea52b811634d257a148
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/51930df5.failed

Some architectures (e.g.  ARC) have the ZONE_HIGHMEM zone below the
ZONE_NORMAL.  Allowing free_area_init() parse max_zone_pfn array even it
is sorted in descending order allows using free_area_init() on such
architectures.

Add top -> down traversal of max_zone_pfn array in free_area_init() and
use the latter in ARC node/zone initialization.

[rppt@kernel.org: ARC fix]
  Link: http://lkml.kernel.org/r/20200504153901.GM14260@kernel.org
[rppt@linux.ibm.com: arc: free_area_init(): take into account PAE40 mode]
  Link: http://lkml.kernel.org/r/20200507205900.GH683243@linux.ibm.com
[akpm@linux-foundation.org: declare arch_has_descending_max_zone_pfns()]
	Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Hoan Tran <hoan@os.amperecomputing.com>	[arm64]
	Reviewed-by: Baoquan He <bhe@redhat.com>
	Cc: Brian Cain <bcain@codeaurora.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Greentime Hu <green.hu@gmail.com>
	Cc: Greg Ungerer <gerg@linux-m68k.org>
	Cc: Guan Xuetao <gxt@pku.edu.cn>
	Cc: Guo Ren <guoren@kernel.org>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Helge Deller <deller@gmx.de>
	Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Ley Foon Tan <ley.foon.tan@intel.com>
	Cc: Mark Salter <msalter@redhat.com>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Nick Hu <nickhu@andestech.com>
	Cc: Paul Walmsley <paul.walmsley@sifive.com>
	Cc: Richard Weinberger <richard@nod.at>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Stafford Horne <shorne@gmail.com>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Vineet Gupta <vgupta@synopsys.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Cc: Guenter Roeck <linux@roeck-us.net>
Link: http://lkml.kernel.org/r/20200412194859.12663-18-rppt@kernel.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 51930df5801e4da60e962ea52b811634d257a148)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arc/mm/init.c
diff --cc arch/arc/mm/init.c
index f8fe5668b30f,e7bdc2ac1c87..000000000000
--- a/arch/arc/mm/init.c
+++ b/arch/arc/mm/init.c
@@@ -78,23 -77,10 +80,30 @@@ void __init early_init_dt_add_memory_ar
  		base, TO_MB(size), !in_use ? "Not used":"");
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_BLK_DEV_INITRD
 +static int __init early_initrd(char *p)
 +{
 +	unsigned long start, size;
 +	char *endp;
 +
 +	start = memparse(p, &endp);
 +	if (*endp == ',') {
 +		size = memparse(endp + 1, NULL);
 +
 +		initrd_start = (unsigned long)__va(start);
 +		initrd_end = (unsigned long)__va(start + size);
 +	}
 +	return 0;
 +}
 +early_param("initrd", early_initrd);
 +#endif
++=======
+ bool arch_has_descending_max_zone_pfns(void)
+ {
+ 	return !IS_ENABLED(CONFIG_ARC_HAS_PAE40);
+ }
++>>>>>>> 51930df5801e (mm: free_area_init: allow defining max_zone_pfn in descending order)
  
  /*
   * First memory setup routine called from setup_arch()
@@@ -136,12 -121,15 +144,17 @@@ void __init setup_arch_memory(void
  	 * the crash
  	 */
  
++<<<<<<< HEAD
 +	memblock_add_node(low_mem_start, low_mem_sz, 0);
 +	memblock_reserve(low_mem_start, __pa(_end) - low_mem_start);
++=======
+ 	memblock_reserve(CONFIG_LINUX_LINK_BASE,
+ 			 __pa(_end) - CONFIG_LINUX_LINK_BASE);
++>>>>>>> 51930df5801e (mm: free_area_init: allow defining max_zone_pfn in descending order)
  
  #ifdef CONFIG_BLK_DEV_INITRD
 -	if (phys_initrd_size) {
 -		memblock_reserve(phys_initrd_start, phys_initrd_size);
 -		initrd_start = (unsigned long)__va(phys_initrd_start);
 -		initrd_end = initrd_start + phys_initrd_size;
 -	}
 +	if (initrd_start)
 +		memblock_reserve(__pa(initrd_start), initrd_end - initrd_start);
  #endif
  
  	early_init_fdt_reserve_self();
* Unmerged path arch/arc/mm/init.c
diff --git a/include/linux/mm.h b/include/linux/mm.h
index c2872a52dcb3..8d29dd6fd826 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2126,6 +2126,7 @@ extern void zone_pcp_reset(struct zone *zone);
 extern int min_free_kbytes;
 extern int watermark_boost_factor;
 extern int watermark_scale_factor;
+extern bool arch_has_descending_max_zone_pfns(void);
 
 /* nommu.c */
 extern atomic_long_t mmap_pages_allocated;
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index f9684b405897..8f9d1645a058 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -7168,6 +7168,15 @@ static void check_for_memory(pg_data_t *pgdat, int nid)
 	}
 }
 
+/*
+ * Some architecturs, e.g. ARC may have ZONE_HIGHMEM below ZONE_NORMAL. For
+ * such cases we allow max_zone_pfn sorted in the descending order
+ */
+bool __weak arch_has_descending_max_zone_pfns(void)
+{
+	return false;
+}
+
 /**
  * free_area_init_nodes - Initialise all pg_data_t and zone data
  * @max_zone_pfn: an array of max PFNs for each zone
@@ -7184,7 +7193,8 @@ static void check_for_memory(pg_data_t *pgdat, int nid)
 void __init free_area_init_nodes(unsigned long *max_zone_pfn)
 {
 	unsigned long start_pfn, end_pfn;
-	int i, nid;
+	int i, nid, zone;
+	bool descending;
 
 	/* Record where the zone boundaries are */
 	memset(arch_zone_lowest_possible_pfn, 0,
@@ -7193,14 +7203,20 @@ void __init free_area_init_nodes(unsigned long *max_zone_pfn)
 				sizeof(arch_zone_highest_possible_pfn));
 
 	start_pfn = find_min_pfn_with_active_regions();
+	descending = arch_has_descending_max_zone_pfns();
 
 	for (i = 0; i < MAX_NR_ZONES; i++) {
-		if (i == ZONE_MOVABLE)
+		if (descending)
+			zone = MAX_NR_ZONES - i - 1;
+		else
+			zone = i;
+
+		if (zone == ZONE_MOVABLE)
 			continue;
 
-		end_pfn = max(max_zone_pfn[i], start_pfn);
-		arch_zone_lowest_possible_pfn[i] = start_pfn;
-		arch_zone_highest_possible_pfn[i] = end_pfn;
+		end_pfn = max(max_zone_pfn[zone], start_pfn);
+		arch_zone_lowest_possible_pfn[zone] = start_pfn;
+		arch_zone_highest_possible_pfn[zone] = end_pfn;
 
 		start_pfn = end_pfn;
 	}
