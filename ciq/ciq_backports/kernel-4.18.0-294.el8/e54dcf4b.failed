net: atlantic: basic A2 init/deinit hw_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Igor Russkikh <irusskikh@marvell.com>
commit e54dcf4bba3e2c36b3eb89cd9063753c2a3ef459
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e54dcf4b.failed

This patch adds basic A2 HW initialization / deinitialization.

	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
Co-developed-by: Dmitry Bogdanov <dbogdanov@marvell.com>
	Signed-off-by: Dmitry Bogdanov <dbogdanov@marvell.com>
	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e54dcf4bba3e2c36b3eb89cd9063753c2a3ef459)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_internal.h
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index ed7d344e3ed7,f97b073efd8e..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -342,6 -378,12 +342,15 @@@ int aq_nic_init(struct aq_nic_s *self
  	if (err < 0)
  		goto err_exit;
  
++<<<<<<< HEAD
++=======
+ 	if (ATL_HW_IS_CHIP_FEATURE(self->aq_hw, ATLANTIC) &&
+ 	    self->aq_nic_cfg.aq_hw_caps->media_type == AQ_HW_MEDIA_TYPE_TP) {
+ 		self->aq_hw->phy_id = HW_ATL_PHY_ID_MAX;
+ 		err = aq_phy_init(self->aq_hw);
+ 	}
+ 
++>>>>>>> e54dcf4bba3e (net: atlantic: basic A2 init/deinit hw_ops)
  	for (i = 0U, aq_vec = self->aq_vec[0];
  		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
  		aq_vec_init(aq_vec, self->aq_hw_ops, self->aq_hw);
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index b7e5ce0d7af5,c46199f14ec4..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -166,13 -187,13 +166,13 @@@ static int hw_atl_b0_hw_qos_set(struct 
  	return aq_hw_err_from_flags(self);
  }
  
- static int hw_atl_b0_hw_rss_hash_set(struct aq_hw_s *self,
- 				     struct aq_rss_parameters *rss_params)
+ int hw_atl_b0_hw_rss_hash_set(struct aq_hw_s *self,
+ 			      struct aq_rss_parameters *rss_params)
  {
  	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
 -	unsigned int addr = 0U;
 -	unsigned int i = 0U;
  	int err = 0;
 +	unsigned int i = 0U;
 +	unsigned int addr = 0U;
  	u32 val;
  
  	for (i = 10, addr = 0U; i--; ++addr) {
@@@ -194,15 -215,15 +194,15 @@@ err_exit
  	return err;
  }
  
- static int hw_atl_b0_hw_rss_set(struct aq_hw_s *self,
- 				struct aq_rss_parameters *rss_params)
+ int hw_atl_b0_hw_rss_set(struct aq_hw_s *self,
+ 			 struct aq_rss_parameters *rss_params)
  {
 -	u32 num_rss_queues = max(1U, self->aq_nic_cfg->num_rss_queues);
  	u8 *indirection_table =	rss_params->indirection_table;
 +	u32 i = 0U;
 +	u32 num_rss_queues = max(1U, self->aq_nic_cfg->num_rss_queues);
 +	int err = 0;
  	u16 bitary[1 + (HW_ATL_B0_RSS_REDIRECTION_MAX *
  		   HW_ATL_B0_RSS_REDIRECTION_BITS / 16U)];
 -	int err = 0;
 -	u32 i = 0U;
  	u32 val;
  
  	memset(bitary, 0, sizeof(bitary));
@@@ -754,9 -854,10 +754,9 @@@ static int hw_atl_b0_hw_ring_rx_receive
  	return aq_hw_err_from_flags(self);
  }
  
- static int hw_atl_b0_hw_irq_enable(struct aq_hw_s *self, u64 mask)
+ int hw_atl_b0_hw_irq_enable(struct aq_hw_s *self, u64 mask)
  {
  	hw_atl_itr_irq_msk_setlsw_set(self, LODWORD(mask));
 -
  	return aq_hw_err_from_flags(self);
  }
  
@@@ -769,26 -870,31 +769,26 @@@ int hw_atl_b0_hw_irq_disable(struct aq_
  	return aq_hw_err_from_flags(self);
  }
  
- static int hw_atl_b0_hw_irq_read(struct aq_hw_s *self, u64 *mask)
+ int hw_atl_b0_hw_irq_read(struct aq_hw_s *self, u64 *mask)
  {
  	*mask = hw_atl_itr_irq_statuslsw_get(self);
 -
  	return aq_hw_err_from_flags(self);
  }
  
  #define IS_FILTER_ENABLED(_F_) ((packet_filter & (_F_)) ? 1U : 0U)
  
- static int hw_atl_b0_hw_packet_filter_set(struct aq_hw_s *self,
- 					  unsigned int packet_filter)
+ int hw_atl_b0_hw_packet_filter_set(struct aq_hw_s *self,
+ 				   unsigned int packet_filter)
  {
 -	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
  	unsigned int i = 0U;
 -	u32 vlan_promisc;
 -	u32 l2_promisc;
 -
 -	l2_promisc = IS_FILTER_ENABLED(IFF_PROMISC) ||
 -		     !!(cfg->priv_flags & BIT(AQ_HW_LOOPBACK_DMA_NET));
 -	vlan_promisc = l2_promisc || cfg->is_vlan_force_promisc;
 +	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
  
 -	hw_atl_rpfl2promiscuous_mode_en_set(self, l2_promisc);
 +	hw_atl_rpfl2promiscuous_mode_en_set(self,
 +					    IS_FILTER_ENABLED(IFF_PROMISC));
  
 -	hw_atl_rpf_vlan_prom_mode_en_set(self, vlan_promisc);
 +	hw_atl_rpf_vlan_prom_mode_en_set(self,
 +				     IS_FILTER_ENABLED(IFF_PROMISC) ||
 +				     cfg->is_vlan_force_promisc);
  
  	hw_atl_rpfl2multicast_flr_en_set(self,
  					 IS_FILTER_ENABLED(IFF_ALLMULTI) &&
@@@ -978,6 -1086,230 +978,232 @@@ static int hw_atl_b0_hw_ring_rx_stop(st
  	return aq_hw_err_from_flags(self);
  }
  
++<<<<<<< HEAD
++=======
+ static int hw_atl_b0_tx_tc_mode_get(struct aq_hw_s *self, u32 *tc_mode)
+ {
+ 	*tc_mode = hw_atl_tpb_tps_tx_tc_mode_get(self);
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
+ static int hw_atl_b0_rx_tc_mode_get(struct aq_hw_s *self, u32 *tc_mode)
+ {
+ 	*tc_mode = hw_atl_rpb_rpf_rx_traf_class_mode_get(self);
+ 	return aq_hw_err_from_flags(self);
+ }
+ 
+ #define get_ptp_ts_val_u64(self, indx) \
+ 	((u64)(hw_atl_pcs_ptp_clock_get(self, indx) & 0xffff))
+ 
+ static void hw_atl_b0_get_ptp_ts(struct aq_hw_s *self, u64 *stamp)
+ {
+ 	u64 ns;
+ 
+ 	hw_atl_pcs_ptp_clock_read_enable(self, 1);
+ 	hw_atl_pcs_ptp_clock_read_enable(self, 0);
+ 	ns = (get_ptp_ts_val_u64(self, 0) +
+ 	      (get_ptp_ts_val_u64(self, 1) << 16)) * NSEC_PER_SEC +
+ 	     (get_ptp_ts_val_u64(self, 3) +
+ 	      (get_ptp_ts_val_u64(self, 4) << 16));
+ 
+ 	*stamp = ns + self->ptp_clk_offset;
+ }
+ 
+ static void hw_atl_b0_adj_params_get(u64 freq, s64 adj, u32 *ns, u32 *fns)
+ {
+ 	/* For accuracy, the digit is extended */
+ 	s64 base_ns = ((adj + NSEC_PER_SEC) * NSEC_PER_SEC);
+ 	u64 nsi_frac = 0;
+ 	u64 nsi;
+ 
+ 	base_ns = div64_s64(base_ns, freq);
+ 	nsi = div64_u64(base_ns, NSEC_PER_SEC);
+ 
+ 	if (base_ns != nsi * NSEC_PER_SEC) {
+ 		s64 divisor = div64_s64((s64)NSEC_PER_SEC * NSEC_PER_SEC,
+ 					base_ns - nsi * NSEC_PER_SEC);
+ 		nsi_frac = div64_s64(FRAC_PER_NS * NSEC_PER_SEC, divisor);
+ 	}
+ 
+ 	*ns = (u32)nsi;
+ 	*fns = (u32)nsi_frac;
+ }
+ 
+ static void
+ hw_atl_b0_mac_adj_param_calc(struct hw_fw_request_ptp_adj_freq *ptp_adj_freq,
+ 			     u64 phyfreq, u64 macfreq)
+ {
+ 	s64 adj_fns_val;
+ 	s64 fns_in_sec_phy = phyfreq * (ptp_adj_freq->fns_phy +
+ 					FRAC_PER_NS * ptp_adj_freq->ns_phy);
+ 	s64 fns_in_sec_mac = macfreq * (ptp_adj_freq->fns_mac +
+ 					FRAC_PER_NS * ptp_adj_freq->ns_mac);
+ 	s64 fault_in_sec_phy = FRAC_PER_NS * NSEC_PER_SEC - fns_in_sec_phy;
+ 	s64 fault_in_sec_mac = FRAC_PER_NS * NSEC_PER_SEC - fns_in_sec_mac;
+ 	/* MAC MCP counter freq is macfreq / 4 */
+ 	s64 diff_in_mcp_overflow = (fault_in_sec_mac - fault_in_sec_phy) *
+ 				   4 * FRAC_PER_NS;
+ 
+ 	diff_in_mcp_overflow = div64_s64(diff_in_mcp_overflow,
+ 					 AQ_HW_MAC_COUNTER_HZ);
+ 	adj_fns_val = (ptp_adj_freq->fns_mac + FRAC_PER_NS *
+ 		       ptp_adj_freq->ns_mac) + diff_in_mcp_overflow;
+ 
+ 	ptp_adj_freq->mac_ns_adj = div64_s64(adj_fns_val, FRAC_PER_NS);
+ 	ptp_adj_freq->mac_fns_adj = adj_fns_val - ptp_adj_freq->mac_ns_adj *
+ 				    FRAC_PER_NS;
+ }
+ 
+ static int hw_atl_b0_adj_sys_clock(struct aq_hw_s *self, s64 delta)
+ {
+ 	self->ptp_clk_offset += delta;
+ 
+ 	self->aq_fw_ops->adjust_ptp(self, self->ptp_clk_offset);
+ 
+ 	return 0;
+ }
+ 
+ static int hw_atl_b0_set_sys_clock(struct aq_hw_s *self, u64 time, u64 ts)
+ {
+ 	s64 delta = time - (self->ptp_clk_offset + ts);
+ 
+ 	return hw_atl_b0_adj_sys_clock(self, delta);
+ }
+ 
+ static int hw_atl_b0_ts_to_sys_clock(struct aq_hw_s *self, u64 ts, u64 *time)
+ {
+ 	*time = self->ptp_clk_offset + ts;
+ 	return 0;
+ }
+ 
+ static int hw_atl_b0_adj_clock_freq(struct aq_hw_s *self, s32 ppb)
+ {
+ 	struct hw_fw_request_iface fwreq;
+ 	size_t size;
+ 
+ 	memset(&fwreq, 0, sizeof(fwreq));
+ 
+ 	fwreq.msg_id = HW_AQ_FW_REQUEST_PTP_ADJ_FREQ;
+ 	hw_atl_b0_adj_params_get(AQ_HW_MAC_COUNTER_HZ, ppb,
+ 				 &fwreq.ptp_adj_freq.ns_mac,
+ 				 &fwreq.ptp_adj_freq.fns_mac);
+ 	hw_atl_b0_adj_params_get(AQ_HW_PHY_COUNTER_HZ, ppb,
+ 				 &fwreq.ptp_adj_freq.ns_phy,
+ 				 &fwreq.ptp_adj_freq.fns_phy);
+ 	hw_atl_b0_mac_adj_param_calc(&fwreq.ptp_adj_freq,
+ 				     AQ_HW_PHY_COUNTER_HZ,
+ 				     AQ_HW_MAC_COUNTER_HZ);
+ 
+ 	size = sizeof(fwreq.msg_id) + sizeof(fwreq.ptp_adj_freq);
+ 	return self->aq_fw_ops->send_fw_request(self, &fwreq, size);
+ }
+ 
+ static int hw_atl_b0_gpio_pulse(struct aq_hw_s *self, u32 index,
+ 				u64 start, u32 period)
+ {
+ 	struct hw_fw_request_iface fwreq;
+ 	size_t size;
+ 
+ 	memset(&fwreq, 0, sizeof(fwreq));
+ 
+ 	fwreq.msg_id = HW_AQ_FW_REQUEST_PTP_GPIO_CTRL;
+ 	fwreq.ptp_gpio_ctrl.index = index;
+ 	fwreq.ptp_gpio_ctrl.period = period;
+ 	/* Apply time offset */
+ 	fwreq.ptp_gpio_ctrl.start = start;
+ 
+ 	size = sizeof(fwreq.msg_id) + sizeof(fwreq.ptp_gpio_ctrl);
+ 	return self->aq_fw_ops->send_fw_request(self, &fwreq, size);
+ }
+ 
+ static int hw_atl_b0_extts_gpio_enable(struct aq_hw_s *self, u32 index,
+ 				       u32 enable)
+ {
+ 	/* Enable/disable Sync1588 GPIO Timestamping */
+ 	aq_phy_write_reg(self, MDIO_MMD_PCS, 0xc611, enable ? 0x71 : 0);
+ 
+ 	return 0;
+ }
+ 
+ static int hw_atl_b0_get_sync_ts(struct aq_hw_s *self, u64 *ts)
+ {
+ 	u64 sec_l;
+ 	u64 sec_h;
+ 	u64 nsec_l;
+ 	u64 nsec_h;
+ 
+ 	if (!ts)
+ 		return -1;
+ 
+ 	/* PTP external GPIO clock seconds count 15:0 */
+ 	sec_l = aq_phy_read_reg(self, MDIO_MMD_PCS, 0xc914);
+ 	/* PTP external GPIO clock seconds count 31:16 */
+ 	sec_h = aq_phy_read_reg(self, MDIO_MMD_PCS, 0xc915);
+ 	/* PTP external GPIO clock nanoseconds count 15:0 */
+ 	nsec_l = aq_phy_read_reg(self, MDIO_MMD_PCS, 0xc916);
+ 	/* PTP external GPIO clock nanoseconds count 31:16 */
+ 	nsec_h = aq_phy_read_reg(self, MDIO_MMD_PCS, 0xc917);
+ 
+ 	*ts = (nsec_h << 16) + nsec_l + ((sec_h << 16) + sec_l) * NSEC_PER_SEC;
+ 
+ 	return 0;
+ }
+ 
+ static u16 hw_atl_b0_rx_extract_ts(struct aq_hw_s *self, u8 *p,
+ 				   unsigned int len, u64 *timestamp)
+ {
+ 	unsigned int offset = 14;
+ 	struct ethhdr *eth;
+ 	__be64 sec;
+ 	__be32 ns;
+ 	u8 *ptr;
+ 
+ 	if (len <= offset || !timestamp)
+ 		return 0;
+ 
+ 	/* The TIMESTAMP in the end of package has following format:
+ 	 * (big-endian)
+ 	 *   struct {
+ 	 *     uint64_t sec;
+ 	 *     uint32_t ns;
+ 	 *     uint16_t stream_id;
+ 	 *   };
+ 	 */
+ 	ptr = p + (len - offset);
+ 	memcpy(&sec, ptr, sizeof(sec));
+ 	ptr += sizeof(sec);
+ 	memcpy(&ns, ptr, sizeof(ns));
+ 
+ 	*timestamp = (be64_to_cpu(sec) & 0xffffffffffffllu) * NSEC_PER_SEC +
+ 		     be32_to_cpu(ns) + self->ptp_clk_offset;
+ 
+ 	eth = (struct ethhdr *)p;
+ 
+ 	return (eth->h_proto == htons(ETH_P_1588)) ? 12 : 14;
+ }
+ 
+ static int hw_atl_b0_extract_hwts(struct aq_hw_s *self, u8 *p, unsigned int len,
+ 				  u64 *timestamp)
+ {
+ 	struct hw_atl_rxd_hwts_wb_s *hwts_wb = (struct hw_atl_rxd_hwts_wb_s *)p;
+ 	u64 tmp, sec, ns;
+ 
+ 	sec = 0;
+ 	tmp = (hwts_wb->sec_lw0 >> 2) & 0x3ff;
+ 	sec += tmp;
+ 	tmp = (u64)((hwts_wb->sec_lw1 >> 16) & 0xffff) << 10;
+ 	sec += tmp;
+ 	tmp = (u64)(hwts_wb->sec_hw & 0xfff) << 26;
+ 	sec += tmp;
+ 	tmp = (u64)((hwts_wb->sec_hw >> 22) & 0x3ff) << 38;
+ 	sec += tmp;
+ 	ns = sec * NSEC_PER_SEC + hwts_wb->ns;
+ 	if (timestamp)
+ 		*timestamp = ns + self->ptp_clk_offset;
+ 	return 0;
+ }
+ 
++>>>>>>> e54dcf4bba3e (net: atlantic: basic A2 init/deinit hw_ops)
  static int hw_atl_b0_hw_fl3l4_clear(struct aq_hw_s *self,
  				    struct aq_rx_filter_l3l4 *data)
  {
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
index 961b9b69649f,9e2d01a6aac8..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
@@@ -1293,7 -1318,14 +1293,18 @@@ void hw_atl_tpb_tx_buff_en_set(struct a
  			    HW_ATL_TPB_TX_BUF_EN_SHIFT, tx_buff_en);
  }
  
++<<<<<<< HEAD
 +void hw_atl_rpb_tps_tx_tc_mode_set(struct aq_hw_s *aq_hw,
++=======
+ u32 hw_atl_tpb_tps_tx_tc_mode_get(struct aq_hw_s *aq_hw)
+ {
+ 	return aq_hw_read_reg_bit(aq_hw, HW_ATL_TPB_TX_TC_MODE_ADDR,
+ 			HW_ATL_TPB_TX_TC_MODE_MSK,
+ 			HW_ATL_TPB_TX_TC_MODE_SHIFT);
+ }
+ 
+ void hw_atl_tpb_tps_tx_tc_mode_set(struct aq_hw_s *aq_hw,
++>>>>>>> e54dcf4bba3e (net: atlantic: basic A2 init/deinit hw_ops)
  				   u32 tx_traf_class_mode)
  {
  	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPB_TX_TC_MODE_ADDR,
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
index 1dc201492ec7,b88cb84805d5..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
@@@ -607,9 -616,12 +607,15 @@@ void hw_atl_thm_lso_tcp_flag_of_middle_
  /* tpb */
  
  /* set TX Traffic Class Mode */
- void hw_atl_rpb_tps_tx_tc_mode_set(struct aq_hw_s *aq_hw,
+ void hw_atl_tpb_tps_tx_tc_mode_set(struct aq_hw_s *aq_hw,
  				   u32 tx_traf_class_mode);
  
++<<<<<<< HEAD
++=======
+ /* get TX Traffic Class Mode */
+ u32 hw_atl_tpb_tps_tx_tc_mode_get(struct aq_hw_s *aq_hw);
+ 
++>>>>>>> e54dcf4bba3e (net: atlantic: basic A2 init/deinit hw_ops)
  /* set tx buffer enable */
  void hw_atl_tpb_tx_buff_en_set(struct aq_hw_s *aq_hw, u32 tx_buff_en);
  
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_internal.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
index b1c0b6850e60..213c431415c6 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
@@ -36,4 +36,18 @@ extern const struct aq_hw_ops hw_atl_ops_b0;
 
 #define hw_atl_ops_b1 hw_atl_ops_b0
 
+int hw_atl_b0_hw_rss_hash_set(struct aq_hw_s *self,
+			      struct aq_rss_parameters *rss_params);
+int hw_atl_b0_hw_rss_set(struct aq_hw_s *self,
+			 struct aq_rss_parameters *rss_params);
+
+int hw_atl_b0_hw_start(struct aq_hw_s *self);
+
+int hw_atl_b0_hw_irq_enable(struct aq_hw_s *self, u64 mask);
+int hw_atl_b0_hw_irq_disable(struct aq_hw_s *self, u64 mask);
+int hw_atl_b0_hw_irq_read(struct aq_hw_s *self, u64 *mask);
+
+int hw_atl_b0_hw_packet_filter_set(struct aq_hw_s *self,
+				   unsigned int packet_filter);
+
 #endif /* HW_ATL_B0_H */
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_internal.h
