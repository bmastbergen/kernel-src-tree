s390/pci: re-introduce zpci_remove_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit 2f0230b2f2d5fd287a85583eefb5aed35b6fe510
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2f0230b2.failed

For fixing the PF to VF link removal we need to perform some action on
every removal of a zdev from the common PCI subsystem.
So in preparation re-introduce zpci_remove_device() and use that instead
of directly calling the common code functions. This  was actually still
declared from earlier code but no longer implemented.

	Reviewed-by: Pierre Morel <pmorel@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 2f0230b2f2d5fd287a85583eefb5aed35b6fe510)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci.c
#	drivers/pci/hotplug/s390_pci_hpc.c
diff --cc arch/s390/pci/pci.c
index 3ca1c80f304d,6e57ff885f8a..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -801,13 -719,37 +811,40 @@@ out
  	return rc;
  }
  
 -void zpci_release_device(struct kref *kref)
 +void zpci_remove_device(struct zpci_dev *zdev)
  {
 -	struct zpci_dev *zdev = container_of(kref, struct zpci_dev, kref);
 +	if (!zdev->bus)
 +		return;
  
++<<<<<<< HEAD
 +	pci_stop_root_bus(zdev->bus);
 +	pci_remove_root_bus(zdev->bus);
++=======
+ 	if (zdev->zbus->bus)
+ 		zpci_remove_device(zdev);
+ 
+ 	switch (zdev->state) {
+ 	case ZPCI_FN_STATE_ONLINE:
+ 	case ZPCI_FN_STATE_CONFIGURED:
+ 		zpci_disable_device(zdev);
+ 		fallthrough;
+ 	case ZPCI_FN_STATE_STANDBY:
+ 		if (zdev->has_hp_slot)
+ 			zpci_exit_slot(zdev);
+ 		zpci_cleanup_bus_resources(zdev);
+ 		zpci_bus_device_unregister(zdev);
+ 		zpci_destroy_iommu(zdev);
+ 		fallthrough;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	spin_lock(&zpci_list_lock);
+ 	list_del(&zdev->entry);
+ 	spin_unlock(&zpci_list_lock);
+ 	zpci_dbg(3, "rem fid:%x\n", zdev->fid);
+ 	kfree(zdev);
++>>>>>>> 2f0230b2f2d5 (s390/pci: re-introduce zpci_remove_device())
  }
  
  int zpci_report_error(struct pci_dev *pdev,
diff --cc drivers/pci/hotplug/s390_pci_hpc.c
index 39295d88f670,c9e790c74051..000000000000
--- a/drivers/pci/hotplug/s390_pci_hpc.c
+++ b/drivers/pci/hotplug/s390_pci_hpc.c
@@@ -87,12 -88,14 +87,20 @@@ static int disable_slot(struct hotplug_
  	if (!zpci_fn_configured(zdev->state))
  		return -EIO;
  
++<<<<<<< HEAD
 +	pdev = pci_get_slot(zdev->bus, ZPCI_DEVFN);
 +	if (pdev) {
 +		pci_stop_and_remove_bus_device_locked(pdev);
++=======
+ 	pdev = pci_get_slot(zdev->zbus->bus, zdev->devfn);
+ 	if (pdev && pci_num_vf(pdev)) {
++>>>>>>> 2f0230b2f2d5 (s390/pci: re-introduce zpci_remove_device())
  		pci_dev_put(pdev);
+ 		return -EBUSY;
  	}
  
+ 	zpci_remove_device(zdev);
+ 
  	rc = zpci_disable_device(zdev);
  	if (rc)
  		return rc;
* Unmerged path arch/s390/pci/pci.c
diff --git a/arch/s390/pci/pci_event.c b/arch/s390/pci/pci_event.c
index 8d6ee4af4230..3102dd3b9e49 100644
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@ -113,7 +113,7 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 		if (!zdev)
 			break;
 		if (pdev)
-			pci_stop_and_remove_bus_device_locked(pdev);
+			zpci_remove_device(zdev);
 
 		ret = zpci_disable_device(zdev);
 		if (ret)
@@ -132,7 +132,7 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 			/* Give the driver a hint that the function is
 			 * already unusable. */
 			pdev->error_state = pci_channel_io_perm_failure;
-			pci_stop_and_remove_bus_device_locked(pdev);
+			zpci_remove_device(zdev);
 		}
 
 		zdev->fh = ccdf->fh;
* Unmerged path drivers/pci/hotplug/s390_pci_hpc.c
