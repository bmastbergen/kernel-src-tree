mm/memory_hotplug: drop valid_start/valid_end from test_pages_in_a_zone()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Hildenbrand <david@redhat.com>
commit 92917998849eea951707c8fea2dc3007bb2ad2cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/92917998.failed

The callers are only interested in the actual zone, they don't care about
boundaries.  Return the zone instead to simplify.

Link: http://lkml.kernel.org/r/20200110183308.11849-1-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 92917998849eea951707c8fea2dc3007bb2ad2cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory_hotplug.c
diff --cc mm/memory_hotplug.c
index 722c7b5b11c6,0a54ffac8c68..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1496,9 -1476,8 +1485,14 @@@ static int __ref __offline_pages(unsign
  
  	/* This makes hotplug much easier...and readable.
  	   we assume this for now. .*/
++<<<<<<< HEAD
 +	if (!test_pages_in_a_zone(start_pfn, end_pfn, &valid_start,
 +				  &valid_end)) {
 +		mem_hotplug_done();
++=======
+ 	zone = test_pages_in_a_zone(start_pfn, end_pfn);
+ 	if (!zone) {
++>>>>>>> 92917998849e (mm/memory_hotplug: drop valid_start/valid_end from test_pages_in_a_zone())
  		ret = -EINVAL;
  		reason = "multizone range";
  		goto failed_removal;
diff --git a/drivers/base/memory.c b/drivers/base/memory.c
index d19e3924dca3..0eb90653d675 100644
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@ -406,7 +406,6 @@ static ssize_t valid_zones_show(struct device *dev,
 	struct memory_block *mem = to_memory_block(dev);
 	unsigned long start_pfn = section_nr_to_pfn(mem->start_section_nr);
 	unsigned long nr_pages = PAGES_PER_SECTION * sections_per_block;
-	unsigned long valid_start_pfn, valid_end_pfn;
 	struct zone *default_zone;
 	int nid;
 
@@ -419,11 +418,11 @@ static ssize_t valid_zones_show(struct device *dev,
 		 * The block contains more than one zone can not be offlined.
 		 * This can happen e.g. for ZONE_DMA and ZONE_DMA32
 		 */
-		if (!test_pages_in_a_zone(start_pfn, start_pfn + nr_pages,
-					  &valid_start_pfn, &valid_end_pfn))
+		default_zone = test_pages_in_a_zone(start_pfn,
+						    start_pfn + nr_pages);
+		if (!default_zone)
 			return sprintf(buf, "none\n");
-		start_pfn = valid_start_pfn;
-		strcat(buf, page_zone(pfn_to_page(start_pfn))->name);
+		strcat(buf, default_zone->name);
 		goto out;
 	}
 
diff --git a/include/linux/memory_hotplug.h b/include/linux/memory_hotplug.h
index 97ccbfde1b3b..7ad41bf6d664 100644
--- a/include/linux/memory_hotplug.h
+++ b/include/linux/memory_hotplug.h
@@ -100,8 +100,8 @@ extern int add_one_highpage(struct page *page, int pfn, int bad_ppro);
 /* VM interface that may be used by firmware interface */
 extern int online_pages(unsigned long pfn, unsigned long nr_pages,
 			int online_type, int nid);
-extern int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn,
-	unsigned long *valid_start, unsigned long *valid_end);
+extern struct zone *test_pages_in_a_zone(unsigned long start_pfn,
+					 unsigned long end_pfn);
 extern unsigned long __offline_isolated_pages(unsigned long start_pfn,
 						unsigned long end_pfn);
 
* Unmerged path mm/memory_hotplug.c
