mm: memcontrol: drop unused try/commit/cancel charge API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit f0e45fb4da29746a116e810eb91423ccfa4830fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f0e45fb4.failed

There are no more users. RIP in peace.

[arnd@arndb.de: fix an unused-function warning]
  Link: http://lkml.kernel.org/r/20200528095640.151454-1-arnd@arndb.de
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Alex Shi <alex.shi@linux.alibaba.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Balbir Singh <bsingharora@gmail.com>
Link: http://lkml.kernel.org/r/20200508183105.225460-14-hannes@cmpxchg.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f0e45fb4da29746a116e810eb91423ccfa4830fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memcontrol.h
#	mm/memcontrol.c
diff --cc include/linux/memcontrol.h
index fa05dbf9d553,46620c6343ef..000000000000
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@@ -372,16 -355,9 +372,22 @@@ static inline unsigned long mem_cgroup_
  enum mem_cgroup_protection mem_cgroup_protected(struct mem_cgroup *root,
  						struct mem_cgroup *memcg);
  
++<<<<<<< HEAD
 +int mem_cgroup_try_charge(struct page *page, struct mm_struct *mm,
 +			  gfp_t gfp_mask, struct mem_cgroup **memcgp,
 +			  bool compound);
 +int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,
 +			  gfp_t gfp_mask, struct mem_cgroup **memcgp,
 +			  bool compound);
 +void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,
 +			      bool lrucare, bool compound);
 +void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,
 +		bool compound);
++=======
+ int mem_cgroup_charge(struct page *page, struct mm_struct *mm, gfp_t gfp_mask,
+ 		      bool lrucare);
+ 
++>>>>>>> f0e45fb4da29 (mm: memcontrol: drop unused try/commit/cancel charge API)
  void mem_cgroup_uncharge(struct page *page);
  void mem_cgroup_uncharge_list(struct list_head *page_list);
  
@@@ -848,37 -838,12 +854,46 @@@ static inline enum mem_cgroup_protectio
  	return MEMCG_PROT_NONE;
  }
  
++<<<<<<< HEAD
 +static inline int mem_cgroup_try_charge(struct page *page, struct mm_struct *mm,
 +					gfp_t gfp_mask,
 +					struct mem_cgroup **memcgp,
 +					bool compound)
 +{
 +	*memcgp = NULL;
 +	return 0;
 +}
 +
 +static inline int mem_cgroup_try_charge_delay(struct page *page,
 +					      struct mm_struct *mm,
 +					      gfp_t gfp_mask,
 +					      struct mem_cgroup **memcgp,
 +					      bool compound)
 +{
 +	*memcgp = NULL;
 +	return 0;
 +}
 +
 +static inline void mem_cgroup_commit_charge(struct page *page,
 +					    struct mem_cgroup *memcg,
 +					    bool lrucare, bool compound)
 +{
 +}
 +
 +static inline void mem_cgroup_cancel_charge(struct page *page,
 +					    struct mem_cgroup *memcg,
 +					    bool compound)
 +{
 +}
 +
++=======
+ static inline int mem_cgroup_charge(struct page *page, struct mm_struct *mm,
+ 				    gfp_t gfp_mask, bool lrucare)
+ {
+ 	return 0;
+ }
+ 
++>>>>>>> f0e45fb4da29 (mm: memcontrol: drop unused try/commit/cancel charge API)
  static inline void mem_cgroup_uncharge(struct page *page)
  {
  }
diff --cc mm/memcontrol.c
index e98656a65024,1e7a10b450b2..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -6302,27 -6505,22 +6304,33 @@@ out
   * @page: page to charge
   * @mm: mm context of the victim
   * @gfp_mask: reclaim mode
++<<<<<<< HEAD
 + * @memcgp: charged memcg return
 + * @compound: charge the page as compound or small page
++=======
+  * @lrucare: page might be on the LRU already
++>>>>>>> f0e45fb4da29 (mm: memcontrol: drop unused try/commit/cancel charge API)
   *
   * Try to charge @page to the memcg that @mm belongs to, reclaiming
   * pages according to @gfp_mask if necessary.
   *
-  * Returns 0 on success, with *@memcgp pointing to the charged memcg.
-  * Otherwise, an error code is returned.
-  *
-  * After page->mapping has been set up, the caller must finalize the
-  * charge with mem_cgroup_commit_charge().  Or abort the transaction
-  * with mem_cgroup_cancel_charge() in case page instantiation fails.
+  * Returns 0 on success. Otherwise, an error code is returned.
   */
++<<<<<<< HEAD
 +int mem_cgroup_try_charge(struct page *page, struct mm_struct *mm,
 +			  gfp_t gfp_mask, struct mem_cgroup **memcgp,
 +			  bool compound)
++=======
+ int mem_cgroup_charge(struct page *page, struct mm_struct *mm, gfp_t gfp_mask,
+ 		      bool lrucare)
++>>>>>>> f0e45fb4da29 (mm: memcontrol: drop unused try/commit/cancel charge API)
  {
 -	unsigned int nr_pages = hpage_nr_pages(page);
  	struct mem_cgroup *memcg = NULL;
 +	unsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;
  	int ret = 0;
  
+ 	VM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);
+ 
  	if (mem_cgroup_disabled())
  		goto out;
  
@@@ -6354,60 -6552,8 +6362,65 @@@
  		memcg = get_mem_cgroup_from_mm(mm);
  
  	ret = try_charge(memcg, gfp_mask, nr_pages);
++<<<<<<< HEAD
 +
 +	css_put(&memcg->css);
 +out:
 +	*memcgp = memcg;
 +	return ret;
 +}
 +
 +int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,
 +			  gfp_t gfp_mask, struct mem_cgroup **memcgp,
 +			  bool compound)
 +{
 +	struct mem_cgroup *memcg;
 +	int ret;
 +
 +	ret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);
 +	memcg = *memcgp;
 +	mem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);
 +	return ret;
 +}
 +
 +/**
 + * mem_cgroup_commit_charge - commit a page charge
 + * @page: page to charge
 + * @memcg: memcg to charge the page to
 + * @lrucare: page might be on LRU already
 + * @compound: charge the page as compound or small page
 + *
 + * Finalize a charge transaction started by mem_cgroup_try_charge(),
 + * after page->mapping has been set up.  This must happen atomically
 + * as part of the page instantiation, i.e. under the page table lock
 + * for anonymous pages, under the page lock for page and swap cache.
 + *
 + * In addition, the page must not be on the LRU during the commit, to
 + * prevent racing with task migration.  If it might be, use @lrucare.
 + *
 + * Use mem_cgroup_cancel_charge() to cancel the transaction instead.
 + */
 +void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,
 +			      bool lrucare, bool compound)
 +{
 +	unsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;
 +
 +	VM_BUG_ON_PAGE(!page->mapping, page);
 +	VM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);
 +
 +	if (mem_cgroup_disabled())
 +		return;
 +	/*
 +	 * Swap faults will attempt to charge the same page multiple
 +	 * times.  But reuse_swap_page() might have removed the page
 +	 * from swapcache already, so we can't check PageSwapCache().
 +	 */
 +	if (!memcg)
 +		return;
++=======
+ 	if (ret)
+ 		goto out_put;
++>>>>>>> f0e45fb4da29 (mm: memcontrol: drop unused try/commit/cancel charge API)
  
  	commit_charge(page, memcg, lrucare);
  
@@@ -6425,32 -6571,11 +6438,38 @@@
  		 */
  		mem_cgroup_uncharge_swap(entry, nr_pages);
  	}
- }
  
++<<<<<<< HEAD
 +/**
 + * mem_cgroup_cancel_charge - cancel a page charge
 + * @page: page to charge
 + * @memcg: memcg to charge the page to
 + * @compound: charge the page as compound or small page
 + *
 + * Cancel a charge transaction started by mem_cgroup_try_charge().
 + */
 +void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,
 +		bool compound)
 +{
 +	unsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;
 +
 +	if (mem_cgroup_disabled())
 +		return;
 +	/*
 +	 * Swap faults will attempt to charge the same page multiple
 +	 * times.  But reuse_swap_page() might have removed the page
 +	 * from swapcache already, so we can't check PageSwapCache().
 +	 */
 +	if (!memcg)
 +		return;
 +
 +	cancel_charge(memcg, nr_pages);
++=======
+ out_put:
+ 	css_put(&memcg->css);
+ out:
+ 	return ret;
++>>>>>>> f0e45fb4da29 (mm: memcontrol: drop unused try/commit/cancel charge API)
  }
  
  struct uncharge_gather {
* Unmerged path include/linux/memcontrol.h
* Unmerged path mm/memcontrol.c
