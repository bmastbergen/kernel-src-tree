cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 6678889f0726910fc884c54f951d8c5646a04819
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6678889f.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 6678889f0726910fc884c54f951d8c5646a04819)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cgroup/cgroup-v1.c
diff --cc kernel/cgroup/cgroup-v1.c
index dd94e2a4c22e,0d71fc98e73d..000000000000
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@@ -1079,22 -1135,26 +1079,37 @@@ struct kernfs_syscall_ops cgroup1_kf_sy
  	.show_path		= cgroup_show_path,
  };
  
++<<<<<<< HEAD
 +struct dentry *cgroup1_mount(struct file_system_type *fs_type, int flags,
 +			     void *data, unsigned long magic,
 +			     struct cgroup_namespace *ns)
++=======
+ /*
+  * The guts of cgroup1 mount - find or create cgroup_root to use.
+  * Called with cgroup_mutex held; returns 0 on success, -E... on
+  * error and positive - in case when the candidate is busy dying.
+  * On success it stashes a reference to cgroup_root into given
+  * cgroup_fs_context; that reference is *NOT* counting towards the
+  * cgroup_root refcount.
+  */
+ static int cgroup1_root_to_use(struct fs_context *fc)
++>>>>>>> 6678889f0726 (cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper)
  {
 -	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 +	struct cgroup_sb_opts opts;
  	struct cgroup_root *root;
  	struct cgroup_subsys *ss;
 +	struct dentry *dentry;
  	int i, ret;
  
++<<<<<<< HEAD
 +	cgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);
 +
++=======
++>>>>>>> 6678889f0726 (cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper)
  	/* First find the desired set of subsystems */
 -	ret = check_cgroupfs_options(fc);
 +	ret = parse_cgroupfs_options(data, &opts);
  	if (ret)
- 		goto out_unlock;
+ 		return ret;
  
  	/*
  	 * Destruction of cgroup root is asynchronous, so subsystems may
@@@ -1138,19 -1194,18 +1149,23 @@@
  		 * If we asked for subsystems (or explicitly for no
  		 * subsystems) then they must match.
  		 */
 -		if ((ctx->subsys_mask || ctx->none) &&
 -		    (ctx->subsys_mask != root->subsys_mask)) {
 +		if ((opts.subsys_mask || opts.none) &&
 +		    (opts.subsys_mask != root->subsys_mask)) {
  			if (!name_match)
  				continue;
- 			ret = -EBUSY;
- 			goto out_unlock;
+ 			return -EBUSY;
  		}
  
 -		if (root->flags ^ ctx->flags)
 +		if (root->flags ^ opts.flags)
  			pr_warn("new mount options do not match the existing superblock, will be ignored\n");
  
++<<<<<<< HEAD
 +		ret = 0;
 +		goto out_unlock;
++=======
+ 		ctx->root = root;
+ 		return 0;
++>>>>>>> 6678889f0726 (cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper)
  	}
  
  	/*
@@@ -1158,55 -1213,59 +1173,89 @@@
  	 * specification is allowed for already existing hierarchies but we
  	 * can't create new one without subsys specification.
  	 */
++<<<<<<< HEAD
 +	if (!opts.subsys_mask && !opts.none) {
 +		ret = -EINVAL;
 +		goto out_unlock;
 +	}
++=======
+ 	if (!ctx->subsys_mask && !ctx->none)
+ 		return cg_invalf(fc, "cgroup1: No subsys list or none specified");
++>>>>>>> 6678889f0726 (cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper)
  
  	/* Hierarchies may only be created in the initial cgroup namespace. */
- 	if (ns != &init_cgroup_ns) {
- 		ret = -EPERM;
- 		goto out_unlock;
- 	}
+ 	if (ns != &init_cgroup_ns)
+ 		return -EPERM;
  
  	root = kzalloc(sizeof(*root), GFP_KERNEL);
- 	if (!root) {
- 		ret = -ENOMEM;
- 		goto out_unlock;
- 	}
+ 	if (!root)
+ 		return -ENOMEM;
  
 -	ctx->root = root;
 -	init_cgroup_root(ctx);
 +	init_cgroup_root(root, &opts);
  
 -	ret = cgroup_setup_root(root, ctx->subsys_mask);
 +	ret = cgroup_setup_root(root, opts.subsys_mask);
  	if (ret)
  		cgroup_free_root(root);
+ 	return ret;
+ }
  
+ int cgroup1_get_tree(struct fs_context *fc)
+ {
+ 	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
+ 	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
+ 	int ret;
+ 
+ 	/* Check if the caller has permission to mount. */
+ 	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	cgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);
+ 
+ 	ret = cgroup1_root_to_use(fc);
+ 	if (!ret && !percpu_ref_tryget_live(&ctx->root->cgrp.self.refcnt))
+ 		ret = 1;	/* restart */
+ 
++<<<<<<< HEAD
 +out_unlock:
 +	if (!ret && !percpu_ref_tryget_live(&root->cgrp.self.refcnt)) {
 +		mutex_unlock(&cgroup_mutex);
 +		msleep(10);
 +		ret = restart_syscall();
 +		goto out_free;
 +	}
 +	mutex_unlock(&cgroup_mutex);
 +out_free:
 +	kfree(opts.release_agent);
 +	kfree(opts.name);
 +
 +	if (ret)
 +		return ERR_PTR(ret);
 +
 +	dentry = cgroup_do_mount(&cgroup_fs_type, flags, root,
 +				 CGROUP_SUPER_MAGIC, ns);
 +
 +	if (!IS_ERR(dentry) && percpu_ref_is_dying(&root->cgrp.self.refcnt)) {
 +		struct super_block *sb = dentry->d_sb;
 +		dput(dentry);
++=======
+ 	mutex_unlock(&cgroup_mutex);
+ 
+ 	if (!ret)
+ 		ret = cgroup_do_mount(fc, CGROUP_SUPER_MAGIC, ns);
+ 
+ 	if (!ret && percpu_ref_is_dying(&ctx->root->cgrp.self.refcnt)) {
+ 		struct super_block *sb = fc->root->d_sb;
+ 		dput(fc->root);
++>>>>>>> 6678889f0726 (cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper)
  		deactivate_locked_super(sb);
+ 		ret = 1;
+ 	}
+ 
+ 	if (unlikely(ret > 0)) {
  		msleep(10);
 -		return restart_syscall();
 +		dentry = ERR_PTR(restart_syscall());
  	}
 -	return ret;
 +	return dentry;
  }
  
  static int __init cgroup1_wq_init(void)
* Unmerged path kernel/cgroup/cgroup-v1.c
