bonding: propagate transmit status

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Eric Dumazet <edumazet@google.com>
commit ae46f184bc1fb15bf2de47114c29236e61ca4bbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ae46f184.failed

Currently, bonding always returns NETDEV_TX_OK to its caller.

It is worth trying to be more accurate : TCP for instance
can have different recovery strategies if it can have more
precise status, if packet was dropped by slave qdisc.

This is especially important when host is under stress.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Jay Vosburgh <j.vosburgh@gmail.com>
	Cc: Veaceslav Falico <vfalico@gmail.com>
	Cc: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ae46f184bc1fb15bf2de47114c29236e61ca4bbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 704bda02a80a,4f9e7c421f57..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3923,15 -3923,16 +3923,19 @@@ unwind
  }
  
  /**
 - * bond_xmit_slave_id - transmit skb through slave with slave_id
 + * bond_get_slave_by_id - get xmit slave with slave_id
   * @bond: bonding device that is transmitting
 - * @skb: buffer to transmit
   * @slave_id: slave id up to slave_cnt-1 through which to transmit
   *
 - * This function tries to transmit through slave with slave_id but in case
 + * This function tries to get slave with slave_id but in case
   * it fails, it tries to find the first available slave for transmission.
 - * The skb is consumed in all cases, thus the function is void.
   */
++<<<<<<< HEAD
 +static struct slave *bond_get_slave_by_id(struct bonding *bond,
 +					  int slave_id)
++=======
+ static netdev_tx_t bond_xmit_slave_id(struct bonding *bond, struct sk_buff *skb, int slave_id)
++>>>>>>> ae46f184bc1f (bonding: propagate transmit status)
  {
  	struct list_head *iter;
  	struct slave *slave;
@@@ -3941,7 -3942,7 +3945,11 @@@
  	bond_for_each_slave_rcu(bond, slave, iter) {
  		if (--i < 0) {
  			if (bond_slave_can_tx(slave))
++<<<<<<< HEAD
 +				return slave;
++=======
+ 				return bond_dev_queue_xmit(bond, skb, slave->dev);
++>>>>>>> ae46f184bc1f (bonding: propagate transmit status)
  		}
  	}
  
@@@ -3951,10 -3952,10 +3959,17 @@@
  		if (--i < 0)
  			break;
  		if (bond_slave_can_tx(slave))
++<<<<<<< HEAD
 +			return slave;
 +	}
 +
 +	return NULL;
++=======
+ 			return bond_dev_queue_xmit(bond, skb, slave->dev);
+ 	}
+ 	/* no slave that can tx has been found */
+ 	return bond_tx_drop(bond->dev, skb);
++>>>>>>> ae46f184bc1f (bonding: propagate transmit status)
  }
  
  /**
@@@ -4014,38 -4016,18 +4029,50 @@@ static struct slave *bond_xmit_roundrob
  		if (iph->protocol == IPPROTO_IGMP) {
  			slave = rcu_dereference(bond->curr_active_slave);
  			if (slave)
++<<<<<<< HEAD
 +				return slave;
 +			return bond_get_slave_by_id(bond, 0);
++=======
+ 				return bond_dev_queue_xmit(bond, skb, slave->dev);
+ 			return bond_xmit_slave_id(bond, skb, 0);
++>>>>>>> ae46f184bc1f (bonding: propagate transmit status)
  		}
  	}
  
  non_igmp:
  	slave_cnt = READ_ONCE(bond->slave_cnt);
  	if (likely(slave_cnt)) {
++<<<<<<< HEAD
 +		slave_id = bond_rr_gen_slave_id(bond) % slave_cnt;
 +		return bond_get_slave_by_id(bond, slave_id);
 +	}
 +	return NULL;
 +}
 +
 +static netdev_tx_t bond_xmit_roundrobin(struct sk_buff *skb,
 +					struct net_device *bond_dev)
 +{
 +	struct bonding *bond = netdev_priv(bond_dev);
 +	struct slave *slave;
 +
 +	slave = bond_xmit_roundrobin_slave_get(bond, skb);
 +	if (slave)
 +		bond_dev_queue_xmit(bond, skb, slave->dev);
 +	else
 +		bond_tx_drop(bond_dev, skb);
 +	return NETDEV_TX_OK;
++=======
+ 		slave_id = bond_rr_gen_slave_id(bond);
+ 		return bond_xmit_slave_id(bond, skb, slave_id % slave_cnt);
+ 	}
+ 	return bond_tx_drop(bond_dev, skb);
++>>>>>>> ae46f184bc1f (bonding: propagate transmit status)
 +}
 +
 +static struct slave *bond_xmit_activebackup_slave_get(struct bonding *bond,
 +						      struct sk_buff *skb)
 +{
 +	return rcu_dereference(bond->curr_active_slave);
  }
  
  /* In active-backup mode, we know that bond->curr_active_slave is always valid if
@@@ -4057,13 -4039,11 +4084,11 @@@ static netdev_tx_t bond_xmit_activeback
  	struct bonding *bond = netdev_priv(bond_dev);
  	struct slave *slave;
  
 -	slave = rcu_dereference(bond->curr_active_slave);
 +	slave = bond_xmit_activebackup_slave_get(bond, skb);
  	if (slave)
- 		bond_dev_queue_xmit(bond, skb, slave->dev);
- 	else
- 		bond_tx_drop(bond_dev, skb);
+ 		return bond_dev_queue_xmit(bond, skb, slave->dev);
  
- 	return NETDEV_TX_OK;
+ 	return bond_tx_drop(bond_dev, skb);
  }
  
  /* Use this to update slave_array when (a) it's not appropriate to update
@@@ -4254,17 -4178,17 +4279,27 @@@ static netdev_tx_t bond_3ad_xor_xmit(st
  				     struct net_device *dev)
  {
  	struct bonding *bond = netdev_priv(dev);
 -	struct slave *slave;
  	struct bond_up_slave *slaves;
 -	unsigned int count;
 +	struct slave *slave;
 +
++<<<<<<< HEAD
 +	slaves = rcu_dereference(bond->usable_slaves);
 +	slave = bond_xmit_3ad_xor_slave_get(bond, skb, slaves);
 +	if (likely(slave))
 +		bond_dev_queue_xmit(bond, skb, slave->dev);
 +	else
 +		bond_tx_drop(dev, skb);
  
 +	return NETDEV_TX_OK;
++=======
+ 	slaves = rcu_dereference(bond->slave_arr);
+ 	count = slaves ? READ_ONCE(slaves->count) : 0;
+ 	if (likely(count)) {
+ 		slave = slaves->arr[bond_xmit_hash(bond, skb) % count];
+ 		return bond_dev_queue_xmit(bond, skb, slave->dev);
+ 	}
+ 	return bond_tx_drop(dev, skb);
++>>>>>>> ae46f184bc1f (bonding: propagate transmit status)
  }
  
  /* in broadcast mode, we send everything to all usable interfaces. */
diff --git a/drivers/net/bonding/bond_alb.c b/drivers/net/bonding/bond_alb.c
index e863c694c309..095ea51d1853 100644
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@ -1318,8 +1318,7 @@ static netdev_tx_t bond_do_alb_xmit(struct sk_buff *skb, struct bonding *bond,
 					tx_slave->dev->dev_addr);
 		}
 
-		bond_dev_queue_xmit(bond, skb, tx_slave->dev);
-		goto out;
+		return bond_dev_queue_xmit(bond, skb, tx_slave->dev);
 	}
 
 	if (tx_slave && bond->params.tlb_dynamic_lb) {
@@ -1329,9 +1328,7 @@ static netdev_tx_t bond_do_alb_xmit(struct sk_buff *skb, struct bonding *bond,
 	}
 
 	/* no suitable interface, frame not sent */
-	bond_tx_drop(bond->dev, skb);
-out:
-	return NETDEV_TX_OK;
+	return bond_tx_drop(bond->dev, skb);
 }
 
 struct slave *bond_xmit_tlb_slave_get(struct bonding *bond,
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/include/net/bonding.h b/include/net/bonding.h
index 1c34be3c01a1..1413a567ef7b 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -506,15 +506,17 @@ static inline unsigned long slave_last_rx(struct bonding *bond,
 }
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
-static inline void bond_netpoll_send_skb(const struct slave *slave,
+static inline netdev_tx_t bond_netpoll_send_skb(const struct slave *slave,
 					 struct sk_buff *skb)
 {
-	netpoll_send_skb(slave->np, skb);
+	return netpoll_send_skb(slave->np, skb);
 }
 #else
-static inline void bond_netpoll_send_skb(const struct slave *slave,
+static inline netdev_tx_t bond_netpoll_send_skb(const struct slave *slave,
 					 struct sk_buff *skb)
 {
+	BUG();
+	return NETDEV_TX_OK;
 }
 #endif
 
@@ -608,7 +610,7 @@ struct bond_net {
 };
 
 int bond_arp_rcv(const struct sk_buff *skb, struct bonding *bond, struct slave *slave);
-void bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
+netdev_tx_t bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
 int bond_create(struct net *net, const char *name);
 int bond_create_sysfs(struct bond_net *net);
 void bond_destroy_sysfs(struct bond_net *net);
@@ -741,10 +743,11 @@ extern struct bond_parm_tbl ad_select_tbl[];
 /* exported from bond_netlink.c */
 extern struct rtnl_link_ops bond_link_ops;
 
-static inline void bond_tx_drop(struct net_device *dev, struct sk_buff *skb)
+static inline netdev_tx_t bond_tx_drop(struct net_device *dev, struct sk_buff *skb)
 {
 	atomic_long_inc(&dev->tx_dropped);
 	dev_kfree_skb_any(skb);
+	return NET_XMIT_DROP;
 }
 
 #endif /* _NET_BONDING_H */
