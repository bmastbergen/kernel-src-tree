IB/mlx5: Fix fall-through warnings for Clang

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Gustavo A. R. Silva <gustavoars@kernel.org>
commit 808b2c925dd0308a89e717df57721a9ed015c243
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/808b2c92.failed

In preparation to enable -Wimplicit-fallthrough for Clang, fix a warning
by explicitly adding the new pseudo-keyword fallthrough; instead of
letting the code fall through to the next case.

Link: https://lore.kernel.org/r/2b0c87362bc86f6adfe56a5a6685837b71022bbf.1605896059.git.gustavoars@kernel.org
Link: https://github.com/KSPP/linux/issues/115
	Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
	Acked-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 808b2c925dd0308a89e717df57721a9ed015c243)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 8149bc8e4a26,894424909266..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -2608,60 -2411,50 +2608,84 @@@ static struct ib_qp *mlx5_ib_create_dct
  
  	qp->state = IB_QPS_RESET;
  
 -	return 0;
 +	return &qp->ibqp;
 +err_free:
 +	kfree(qp);
 +	return ERR_PTR(err);
  }
  
 -static int check_qp_type(struct mlx5_ib_dev *dev, struct ib_qp_init_attr *attr,
 -			 enum ib_qp_type *type)
 +static int set_mlx_qp_type(struct mlx5_ib_dev *dev,
 +			   struct ib_qp_init_attr *init_attr,
 +			   struct mlx5_ib_create_qp *ucmd,
 +			   struct ib_udata *udata)
  {
 -	if (attr->qp_type == IB_QPT_DRIVER && !MLX5_CAP_GEN(dev->mdev, dct))
 -		goto out;
 +	enum { MLX_QP_FLAGS = MLX5_QP_FLAG_TYPE_DCT | MLX5_QP_FLAG_TYPE_DCI };
 +	int err;
 +
++<<<<<<< HEAD
 +	if (!udata)
 +		return -EINVAL;
  
 +	if (udata->inlen < sizeof(*ucmd)) {
 +		mlx5_ib_dbg(dev, "create_qp user command is smaller than expected\n");
 +		return -EINVAL;
++=======
+ 	switch (attr->qp_type) {
+ 	case IB_QPT_XRC_TGT:
+ 	case IB_QPT_XRC_INI:
+ 		if (!MLX5_CAP_GEN(dev->mdev, xrc))
+ 			goto out;
+ 		fallthrough;
+ 	case IB_QPT_RC:
+ 	case IB_QPT_UC:
+ 	case IB_QPT_SMI:
+ 	case MLX5_IB_QPT_HW_GSI:
+ 	case IB_QPT_DRIVER:
+ 	case IB_QPT_GSI:
+ 		if (dev->profile == &raw_eth_profile)
+ 			goto out;
+ 		fallthrough;
+ 	case IB_QPT_RAW_PACKET:
+ 	case IB_QPT_UD:
+ 	case MLX5_IB_QPT_REG_UMR:
+ 		break;
+ 	default:
+ 		goto out;
++>>>>>>> 808b2c925dd0 (IB/mlx5: Fix fall-through warnings for Clang)
  	}
 +	err = ib_copy_from_udata(ucmd, udata, sizeof(*ucmd));
 +	if (err)
 +		return err;
  
 -	*type = attr->qp_type;
 -	return 0;
 +	if ((ucmd->flags & MLX_QP_FLAGS) == MLX5_QP_FLAG_TYPE_DCI) {
 +		init_attr->qp_type = MLX5_IB_QPT_DCI;
 +	} else {
 +		if ((ucmd->flags & MLX_QP_FLAGS) == MLX5_QP_FLAG_TYPE_DCT) {
 +			init_attr->qp_type = MLX5_IB_QPT_DCT;
 +		} else {
 +			mlx5_ib_dbg(dev, "Invalid QP flags\n");
 +			return -EINVAL;
 +		}
 +	}
  
 -out:
 -	mlx5_ib_dbg(dev, "Unsupported QP type %d\n", attr->qp_type);
 -	return -EOPNOTSUPP;
 +	if (!MLX5_CAP_GEN(dev->mdev, dct)) {
 +		mlx5_ib_dbg(dev, "DC transport is not supported\n");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	return 0;
  }
  
 -static int check_valid_flow(struct mlx5_ib_dev *dev, struct ib_pd *pd,
 -			    struct ib_qp_init_attr *attr,
 -			    struct ib_udata *udata)
 +struct ib_qp *mlx5_ib_create_qp(struct ib_pd *pd,
 +				struct ib_qp_init_attr *verbs_init_attr,
 +				struct ib_udata *udata)
  {
 +	struct mlx5_ib_dev *dev;
 +	struct mlx5_ib_qp *qp;
 +	u16 xrcdn = 0;
 +	int err;
 +	struct ib_qp_init_attr mlx_init_attr;
 +	struct ib_qp_init_attr *init_attr = verbs_init_attr;
  	struct mlx5_ib_ucontext *ucontext = rdma_udata_to_drv_context(
  		udata, struct mlx5_ib_ucontext, ibucontext);
  
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
