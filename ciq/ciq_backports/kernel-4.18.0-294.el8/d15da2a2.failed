nl80211: link recursive netlink nested policy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit d15da2a2e813679aeac8bff3be38d3adc849c1a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d15da2a2.failed

Now that we have limited recursive policy validation to avoid
stack overflows, change nl80211 to actually link the nested
policy (linking back to itself eventually), which allows some
code cleanups.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d15da2a2e813679aeac8bff3be38d3adc849c1a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/nl80211.c
diff --cc net/wireless/nl80211.c
index 7601bf877fe6,57c618b6cb0e..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -322,7 -322,30 +320,34 @@@ he_obss_pd_policy[NL80211_HE_OBSS_PD_AT
  		NLA_POLICY_RANGE(NLA_U8, 1, 20),
  };
  
++<<<<<<< HEAD
 +const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
++=======
+ static const struct nla_policy
+ he_bss_color_policy[NL80211_HE_BSS_COLOR_ATTR_MAX + 1] = {
+ 	[NL80211_HE_BSS_COLOR_ATTR_COLOR] = NLA_POLICY_RANGE(NLA_U8, 1, 63),
+ 	[NL80211_HE_BSS_COLOR_ATTR_DISABLED] = { .type = NLA_FLAG },
+ 	[NL80211_HE_BSS_COLOR_ATTR_PARTIAL] = { .type = NLA_FLAG },
+ };
+ 
+ static const struct nla_policy
+ nl80211_tid_config_attr_policy[NL80211_TID_CONFIG_ATTR_MAX + 1] = {
+ 	[NL80211_TID_CONFIG_ATTR_VIF_SUPP] = { .type = NLA_U64 },
+ 	[NL80211_TID_CONFIG_ATTR_PEER_SUPP] = { .type = NLA_U64 },
+ 	[NL80211_TID_CONFIG_ATTR_OVERRIDE] = { .type = NLA_FLAG },
+ 	[NL80211_TID_CONFIG_ATTR_TIDS] = NLA_POLICY_RANGE(NLA_U16, 1, 0xff),
+ 	[NL80211_TID_CONFIG_ATTR_NOACK] =
+ 			NLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),
+ 	[NL80211_TID_CONFIG_ATTR_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),
+ 	[NL80211_TID_CONFIG_ATTR_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),
+ 	[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL] =
+ 			NLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),
+ 	[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL] =
+ 			NLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),
+ };
+ 
+ static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
++>>>>>>> d15da2a2e813 (nl80211: link recursive netlink nested policy)
  	[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },
  	[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },
  	[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,
* Unmerged path net/wireless/nl80211.c
diff --git a/net/wireless/nl80211.h b/net/wireless/nl80211.h
index a41e94a49a89..d3e8e426c486 100644
--- a/net/wireless/nl80211.h
+++ b/net/wireless/nl80211.h
@@ -11,8 +11,6 @@
 int nl80211_init(void);
 void nl80211_exit(void);
 
-extern const struct nla_policy nl80211_policy[NUM_NL80211_ATTR];
-
 void *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,
 		     int flags, u8 cmd);
 bool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info,
diff --git a/net/wireless/pmsr.c b/net/wireless/pmsr.c
index c09fbf09549d..98918c68eb20 100644
--- a/net/wireless/pmsr.c
+++ b/net/wireless/pmsr.c
@@ -155,10 +155,9 @@ static int pmsr_parse_peer(struct cfg80211_registered_device *rdev,
 
 	/* reuse info->attrs */
 	memset(info->attrs, 0, sizeof(*info->attrs) * (NL80211_ATTR_MAX + 1));
-	/* need to validate here, we don't want to have validation recursion */
 	err = nla_parse_nested_deprecated(info->attrs, NL80211_ATTR_MAX,
 					  tb[NL80211_PMSR_PEER_ATTR_CHAN],
-					  nl80211_policy, info->extack);
+					  NULL, info->extack);
 	if (err)
 		return err;
 
