mptcp: create first subflow at msk creation time

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit fa68018dc45e3faee9d866d5dc484d141e8f1093
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fa68018d.failed

This cleans the code a bit and makes the behavior more consistent.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Davide Caratti <dcaratti@redhat.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fa68018dc45e3faee9d866d5dc484d141e8f1093)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 0dbee7460c72,ad619bda71cc..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -122,12 -106,9 +106,9 @@@ static int __mptcp_socket_create(struc
  	/* accept() will wait on first subflow sk_wq, and we always wakes up
  	 * via msk->sk_socket
  	 */
 -	RCU_INIT_POINTER(msk->first->sk_wq, &sk->sk_socket->wq);
 +	RCU_INIT_POINTER(msk->first->sk_wq, sk->sk_socket->wq);
  
- set_state:
- 	if (state != MPTCP_SAME_STATE)
- 		inet_sk_state_store(sk, state);
- 	return ssock;
+ 	return 0;
  }
  
  static void __mptcp_move_skb(struct mptcp_sock *msk, struct sock *ssk,
@@@ -1355,8 -1236,11 +1336,12 @@@ static int mptcp_init_sock(struct sock 
  	if (ret)
  		return ret;
  
+ 	ret = __mptcp_socket_create(mptcp_sk(sk));
+ 	if (ret)
+ 		return ret;
+ 
  	sk_sockets_allocated_inc(sk);
 +	sk->sk_rcvbuf = sock_net(sk)->ipv4.sysctl_tcp_rmem[1];
  	sk->sk_sndbuf = sock_net(sk)->ipv4.sysctl_tcp_wmem[2];
  
  	return 0;
@@@ -1895,12 -1761,15 +1880,24 @@@ static int mptcp_stream_connect(struct 
  		goto do_connect;
  	}
  
++<<<<<<< HEAD
 +	ssock = __mptcp_socket_create(msk, TCP_SYN_SENT);
 +	if (IS_ERR(ssock)) {
 +		err = PTR_ERR(ssock);
 +		goto unlock;
 +	}
 +
++=======
+ 	ssock = __mptcp_nmpc_socket(msk);
+ 	if (!ssock) {
+ 		err = -EINVAL;
+ 		goto unlock;
+ 	}
+ 
+ 	mptcp_token_destroy(msk);
+ 	inet_sk_state_store(sock->sk, TCP_SYN_SENT);
+ 	subflow = mptcp_subflow_ctx(ssock->sk);
++>>>>>>> fa68018dc45e (mptcp: create first subflow at msk creation time)
  #ifdef CONFIG_TCP_MD5SIG
  	/* no MPTCP if MD5SIG is enabled on this socket or we may run out of
  	 * TCP option space.
@@@ -1935,9 -1806,9 +1932,15 @@@ static int mptcp_listen(struct socket *
  	pr_debug("msk=%p", msk);
  
  	lock_sock(sock->sk);
++<<<<<<< HEAD
 +	ssock = __mptcp_socket_create(msk, TCP_LISTEN);
 +	if (IS_ERR(ssock)) {
 +		err = PTR_ERR(ssock);
++=======
+ 	ssock = __mptcp_nmpc_socket(msk);
+ 	if (!ssock) {
+ 		err = -EINVAL;
++>>>>>>> fa68018dc45e (mptcp: create first subflow at msk creation time)
  		goto unlock;
  	}
  
* Unmerged path net/mptcp/protocol.c
