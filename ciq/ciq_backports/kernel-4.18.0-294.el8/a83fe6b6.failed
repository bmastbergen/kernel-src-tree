net: atlantic: QoS implementation: multi-TC support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Dmitry Bezrukov <dbezrukov@marvell.com>
commit a83fe6b6ad6b10f6912025ae23bd5c2596a4e7f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a83fe6b6.failed

This patch adds multi-TC support.

PTP is automatically disabled when the user enables more than 2 TCs,
otherwise traffic on TC2 won't quite work, because it's reserved for PTP.

	Signed-off-by: Dmitry Bezrukov <dbezrukov@marvell.com>
Co-developed-by: Dmitry Bogdanov <dbogdanov@marvell.com>
	Signed-off-by: Dmitry Bogdanov <dbogdanov@marvell.com>
Co-developed-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Mark Starovoytov <mstarovoitov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a83fe6b6ad6b10f6912025ae23bd5c2596a4e7f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_hw.h
#	drivers/net/ethernet/aquantia/atlantic/aq_main.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.h
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_internal.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh_internal.h
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 46eaf70c5ccb,1dccaaee04b3..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@@ -113,10 -121,43 +113,17 @@@ struct aq_stats_s 
  #define AQ_HW_MEDIA_TYPE_TP    1U
  #define AQ_HW_MEDIA_TYPE_FIBRE 2U
  
++<<<<<<< HEAD
++=======
+ #define AQ_HW_TXD_MULTIPLE 8U
+ #define AQ_HW_RXD_MULTIPLE 8U
+ 
+ #define AQ_HW_QUEUES_MAX                32U
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  #define AQ_HW_MULTICAST_ADDRESS_MAX     32U
  
 -#define AQ_HW_PTP_TC                    2U
 -
 -#define AQ_HW_LED_BLINK    0x2U
 -#define AQ_HW_LED_DEFAULT  0x0U
 -
 -enum aq_priv_flags {
 -	AQ_HW_LOOPBACK_DMA_SYS,
 -	AQ_HW_LOOPBACK_PKT_SYS,
 -	AQ_HW_LOOPBACK_DMA_NET,
 -	AQ_HW_LOOPBACK_PHYINT_SYS,
 -	AQ_HW_LOOPBACK_PHYEXT_SYS,
 -};
 -
 -#define AQ_HW_LOOPBACK_MASK	(BIT(AQ_HW_LOOPBACK_DMA_SYS) |\
 -				 BIT(AQ_HW_LOOPBACK_PKT_SYS) |\
 -				 BIT(AQ_HW_LOOPBACK_DMA_NET) |\
 -				 BIT(AQ_HW_LOOPBACK_PHYINT_SYS) |\
 -				 BIT(AQ_HW_LOOPBACK_PHYEXT_SYS))
 -
 -#define ATL_HW_CHIP_MIPS         0x00000001U
 -#define ATL_HW_CHIP_TPO2         0x00000002U
 -#define ATL_HW_CHIP_RPF2         0x00000004U
 -#define ATL_HW_CHIP_MPI_AQ       0x00000010U
 -#define ATL_HW_CHIP_ATLANTIC     0x00800000U
 -#define ATL_HW_CHIP_REVISION_A0  0x01000000U
 -#define ATL_HW_CHIP_REVISION_B0  0x02000000U
 -#define ATL_HW_CHIP_REVISION_B1  0x04000000U
 -#define ATL_HW_CHIP_ANTIGUA      0x08000000U
 -
 -#define ATL_HW_IS_CHIP_FEATURE(_HW_, _F_) (!!(ATL_HW_CHIP_##_F_ & \
 -	(_HW_)->chip_features))
 +#define AQ_HW_TXD_MULTIPLE 8U
 +#define AQ_HW_RXD_MULTIPLE 8U
  
  struct aq_hw_s {
  	atomic_t flags;
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_main.c
index 25a59894105a,ef9e969fbf7a..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_main.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_main.c
@@@ -13,13 -10,17 +13,20 @@@
  #include "aq_nic.h"
  #include "aq_pci_func.h"
  #include "aq_ethtool.h"
 -#include "aq_ptp.h"
  #include "aq_filters.h"
+ #include "aq_hw_utils.h"
  
  #include <linux/netdevice.h>
  #include <linux/module.h>
++<<<<<<< HEAD
++=======
+ #include <linux/ip.h>
+ #include <linux/udp.h>
+ #include <net/pkt_cls.h>
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  
  MODULE_LICENSE("GPL v2");
 +MODULE_VERSION(AQ_CFG_DRV_VERSION);
  MODULE_AUTHOR(AQ_CFG_DRV_AUTHOR);
  MODULE_DESCRIPTION(AQ_CFG_DRV_DESC);
  
@@@ -237,8 -374,10 +278,9 @@@ static const struct net_device_ops aq_n
  	.ndo_change_mtu = aq_ndev_change_mtu,
  	.ndo_set_mac_address = aq_ndev_set_mac_address,
  	.ndo_set_features = aq_ndev_set_features,
 -	.ndo_do_ioctl = aq_ndev_ioctl,
  	.ndo_vlan_rx_add_vid = aq_ndo_vlan_rx_add_vid,
  	.ndo_vlan_rx_kill_vid = aq_ndo_vlan_rx_kill_vid,
+ 	.ndo_setup_tc = aq_ndo_setup_tc,
  };
  
  static int __init aq_ndev_init_module(void)
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index ed7d344e3ed7,da781082be32..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -129,7 -141,12 +131,10 @@@ void aq_nic_cfg_start(struct aq_nic_s *
  
  	cfg->link_speed_msk &= cfg->aq_hw_caps->link_speed_msk;
  	cfg->features = cfg->aq_hw_caps->hw_features;
 -	cfg->is_vlan_rx_strip = !!(cfg->features & NETIF_F_HW_VLAN_CTAG_RX);
 -	cfg->is_vlan_tx_insert = !!(cfg->features & NETIF_F_HW_VLAN_CTAG_TX);
  	cfg->is_vlan_force_promisc = true;
+ 
+ 	for (i = 0; i < sizeof(cfg->prio_tc_map); i++)
+ 		cfg->prio_tc_map[i] = cfg->tcs * i / 8;
  }
  
  static int aq_nic_update_link_status(struct aq_nic_s *self)
@@@ -576,10 -701,10 +588,17 @@@ exit
  
  int aq_nic_xmit(struct aq_nic_s *self, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct aq_ring_s *ring = NULL;
 +	unsigned int frags = 0U;
 +	unsigned int vec = skb->queue_mapping % self->aq_nic_cfg.vecs;
 +	unsigned int tc = 0U;
++=======
+ 	unsigned int vec = skb->queue_mapping % self->aq_nic_cfg.vecs;
+ 	unsigned int tc = skb->queue_mapping / self->aq_nic_cfg.vecs;
+ 	struct aq_ring_s *ring = NULL;
+ 	unsigned int frags = 0U;
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  	int err = NETDEV_TX_OK;
  
  	frags = skb_shinfo(skb)->nr_frags + 1;
@@@ -593,8 -718,14 +612,9 @@@
  
  	aq_ring_update_queue_state(ring);
  
 -	if (self->aq_nic_cfg.priv_flags & BIT(AQ_HW_LOOPBACK_DMA_NET)) {
 -		err = NETDEV_TX_BUSY;
 -		goto err_exit;
 -	}
 -
  	/* Above status update may stop the queue. Check this. */
- 	if (__netif_subqueue_stopped(self->ndev, ring->idx)) {
+ 	if (__netif_subqueue_stopped(self->ndev,
+ 				     AQ_NIC_RING2QMAP(self, ring->idx))) {
  		err = NETDEV_TX_BUSY;
  		goto err_exit;
  	}
@@@ -1076,3 -1236,86 +1096,89 @@@ void aq_nic_shutdown(struct aq_nic_s *s
  err_exit:
  	rtnl_unlock();
  }
++<<<<<<< HEAD
++=======
+ 
+ u8 aq_nic_reserve_filter(struct aq_nic_s *self, enum aq_rx_filter_type type)
+ {
+ 	u8 location = 0xFF;
+ 	u32 fltr_cnt;
+ 	u32 n_bit;
+ 
+ 	switch (type) {
+ 	case aq_rx_filter_ethertype:
+ 		location = AQ_RX_LAST_LOC_FETHERT - AQ_RX_FIRST_LOC_FETHERT -
+ 			   self->aq_hw_rx_fltrs.fet_reserved_count;
+ 		self->aq_hw_rx_fltrs.fet_reserved_count++;
+ 		break;
+ 	case aq_rx_filter_l3l4:
+ 		fltr_cnt = AQ_RX_LAST_LOC_FL3L4 - AQ_RX_FIRST_LOC_FL3L4;
+ 		n_bit = fltr_cnt - self->aq_hw_rx_fltrs.fl3l4.reserved_count;
+ 
+ 		self->aq_hw_rx_fltrs.fl3l4.active_ipv4 |= BIT(n_bit);
+ 		self->aq_hw_rx_fltrs.fl3l4.reserved_count++;
+ 		location = n_bit;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return location;
+ }
+ 
+ void aq_nic_release_filter(struct aq_nic_s *self, enum aq_rx_filter_type type,
+ 			   u32 location)
+ {
+ 	switch (type) {
+ 	case aq_rx_filter_ethertype:
+ 		self->aq_hw_rx_fltrs.fet_reserved_count--;
+ 		break;
+ 	case aq_rx_filter_l3l4:
+ 		self->aq_hw_rx_fltrs.fl3l4.reserved_count--;
+ 		self->aq_hw_rx_fltrs.fl3l4.active_ipv4 &= ~BIT(location);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ int aq_nic_setup_tc_mqprio(struct aq_nic_s *self, u32 tcs, u8 *prio_tc_map)
+ {
+ 	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
+ 	bool ndev_running;
+ 	int err = 0;
+ 	int i;
+ 
+ 	/* if already the same configuration or
+ 	 * disable request (tcs is 0) and we already is disabled
+ 	 */
+ 	if (tcs == cfg->tcs || (tcs == 0 && !cfg->is_qos))
+ 		return 0;
+ 
+ 	ndev_running = netif_running(self->ndev);
+ 	if (ndev_running)
+ 		dev_close(self->ndev);
+ 
+ 	cfg->tcs = tcs;
+ 	if (cfg->tcs == 0)
+ 		cfg->tcs = 1;
+ 	if (prio_tc_map)
+ 		memcpy(cfg->prio_tc_map, prio_tc_map, sizeof(cfg->prio_tc_map));
+ 	else
+ 		for (i = 0; i < sizeof(cfg->prio_tc_map); i++)
+ 			cfg->prio_tc_map[i] = cfg->tcs * i / 8;
+ 
+ 	cfg->is_qos = (tcs != 0 ? true : false);
+ 	cfg->is_ptp = (cfg->tcs <= AQ_HW_PTP_TC);
+ 	if (!cfg->is_ptp)
+ 		netdev_warn(self->ndev, "%s\n",
+ 			    "PTP is auto disabled due to requested TC count.");
+ 
+ 	netdev_set_num_tc(self->ndev, cfg->tcs);
+ 
+ 	if (ndev_running)
+ 		err = dev_open(self->ndev, NULL);
+ 
+ 	return err;
+ }
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.h
index f6d04351e098,29e129411945..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
@@@ -45,7 -59,12 +45,15 @@@ struct aq_nic_cfg_s 
  	bool is_polling;
  	bool is_rss;
  	bool is_lro;
++<<<<<<< HEAD
++=======
+ 	bool is_qos;
+ 	bool is_ptp;
+ 	enum aq_tc_mode tc_mode;
+ 	u32 priv_flags;
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  	u8  tcs;
+ 	u8 prio_tc_map[8];
  	struct aq_rss_parameters aq_rss;
  	u32 eee_speeds;
  };
@@@ -58,10 -78,18 +66,17 @@@
  #define AQ_NIC_FLAG_ERR_UNPLUG  0x40000000U
  #define AQ_NIC_FLAG_ERR_HW      0x80000000U
  
 -#define AQ_NIC_WOL_MODES        (WAKE_MAGIC |\
 -				 WAKE_PHY)
 +#define AQ_NIC_WOL_ENABLED	BIT(0)
  
+ #define AQ_NIC_RING_PER_TC(_NIC_) \
+ 	(((_NIC_)->aq_nic_cfg.tc_mode == AQ_TC_MODE_4TCS) ? 8 : 4)
+ 
  #define AQ_NIC_TCVEC2RING(_NIC_, _TC_, _VEC_) \
- 	((_TC_) * AQ_CFG_TCS_MAX + (_VEC_))
+ 	((_TC_) * AQ_NIC_RING_PER_TC(_NIC_) + (_VEC_))
+ 
+ #define AQ_NIC_RING2QMAP(_NIC_, _ID_) \
+ 	((_ID_) / AQ_NIC_RING_PER_TC(_NIC_) * (_NIC_)->aq_vecs + \
+ 	((_ID_) % AQ_NIC_RING_PER_TC(_NIC_)))
  
  struct aq_hw_rx_fl2 {
  	struct aq_rx_filter_vlan aq_vlans[AQ_VLAN_MAX_FILTERS];
@@@ -147,8 -186,11 +162,15 @@@ int aq_nic_set_link_ksettings(struct aq
  			      const struct ethtool_link_ksettings *cmd);
  struct aq_nic_cfg_s *aq_nic_get_cfg(struct aq_nic_s *self);
  u32 aq_nic_get_fw_version(struct aq_nic_s *self);
 -int aq_nic_set_loopback(struct aq_nic_s *self);
 +int aq_nic_change_pm_state(struct aq_nic_s *self, pm_message_t *pm_msg);
  int aq_nic_update_interrupt_moderation_settings(struct aq_nic_s *self);
  void aq_nic_shutdown(struct aq_nic_s *self);
- 
++<<<<<<< HEAD
++
++=======
+ u8 aq_nic_reserve_filter(struct aq_nic_s *self, enum aq_rx_filter_type type);
+ void aq_nic_release_filter(struct aq_nic_s *self, enum aq_rx_filter_type type,
+ 			   u32 location);
+ int aq_nic_setup_tc_mqprio(struct aq_nic_s *self, u32 tcs, u8 *prio_tc_map);
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  #endif /* AQ_NIC_H */
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.c
index 26476a262015,68fdb3994088..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
@@@ -423,8 -471,11 +429,16 @@@ int aq_ring_rx_clean(struct aq_ring_s *
  		skb_set_hash(skb, buff->rss_hash,
  			     buff->is_hash_l4 ? PKT_HASH_TYPE_L4 :
  			     PKT_HASH_TYPE_NONE);
++<<<<<<< HEAD
 +
 +		skb_record_rx_queue(skb, self->idx);
++=======
+ 		/* Send all PTP traffic to 0 queue */
+ 		skb_record_rx_queue(skb,
+ 				    is_ptp_ring ? 0
+ 						: AQ_NIC_RING2QMAP(self->aq_nic,
+ 								   self->idx));
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  
  		++self->stats.rx.packets;
  		self->stats.rx.bytes += skb->len;
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index b7e5ce0d7af5,775382440b47..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -43,7 -42,12 +43,16 @@@
  			NETIF_F_TSO |     \
  			NETIF_F_LRO |     \
  			NETIF_F_NTUPLE |  \
++<<<<<<< HEAD
 +			NETIF_F_HW_VLAN_CTAG_FILTER, \
++=======
+ 			NETIF_F_HW_VLAN_CTAG_FILTER | \
+ 			NETIF_F_HW_VLAN_CTAG_RX |     \
+ 			NETIF_F_HW_VLAN_CTAG_TX |     \
+ 			NETIF_F_GSO_UDP_L4      |     \
+ 			NETIF_F_GSO_PARTIAL |         \
+ 			NETIF_F_HW_TC,                \
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  	.hw_priv_flags = IFF_UNICAST_FLT, \
  	.flow_control = true,		  \
  	.mtu = HW_ATL_B0_MTU_JUMBO,	  \
@@@ -108,11 -114,34 +117,18 @@@ static int hw_atl_b0_set_fc(struct aq_h
  	return 0;
  }
  
 -static int hw_atl_b0_tc_ptp_set(struct aq_hw_s *self)
 -{
 -	/* Init TC2 for PTP_TX */
 -	hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, HW_ATL_B0_PTP_TXBUF_SIZE,
 -					       AQ_HW_PTP_TC);
 -
 -	/* Init TC2 for PTP_RX */
 -	hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, HW_ATL_B0_PTP_RXBUF_SIZE,
 -					       AQ_HW_PTP_TC);
 -	/* No flow control for PTP */
 -	hw_atl_rpb_rx_xoff_en_per_tc_set(self, 0U, AQ_HW_PTP_TC);
 -
 -	return aq_hw_err_from_flags(self);
 -}
 -
  static int hw_atl_b0_hw_qos_set(struct aq_hw_s *self)
  {
++<<<<<<< HEAD
++=======
+ 	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
+ 	u32 tx_buff_size = HW_ATL_B0_TXBUF_MAX;
+ 	u32 rx_buff_size = HW_ATL_B0_RXBUF_MAX;
+ 	unsigned int prio = 0U;
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  	u32 tc = 0U;
 -
 -	if (cfg->is_ptp) {
 -		tx_buff_size -= HW_ATL_B0_PTP_TXBUF_SIZE;
 -		rx_buff_size -= HW_ATL_B0_PTP_RXBUF_SIZE;
 -	}
 +	u32 buff_size = 0U;
 +	unsigned int i_priority = 0U;
  
  	/* TPS Descriptor rate init */
  	hw_atl_tps_tx_pkt_shed_desc_rate_curr_time_res_set(self, 0x0U);
@@@ -125,43 -154,45 +141,81 @@@
  	hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);
  	hw_atl_tps_tx_pkt_shed_data_arb_mode_set(self, 0U);
  
++<<<<<<< HEAD
 +	hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, 0xFFF, 0U);
 +	hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, 0x64, 0U);
 +	hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, 0x50, 0U);
 +	hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, 0x1E, 0U);
 +
 +	/* Tx buf size */
 +	buff_size = HW_ATL_B0_TXBUF_MAX;
 +
 +	hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, buff_size, tc);
 +	hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024 / 32U) * 66U) /
 +						   100U, tc);
 +	hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024 / 32U) * 50U) /
 +						   100U, tc);
 +
 +	/* QoS Rx buf size per TC */
 +	tc = 0;
 +	buff_size = HW_ATL_B0_RXBUF_MAX;
 +
 +	hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, buff_size, tc);
 +	hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024U / 32U) * 66U) /
 +						   100U, tc);
 +	hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self,
 +						   (buff_size *
 +						   (1024U / 32U) * 50U) /
 +						   100U, tc);
 +
 +	hw_atl_b0_set_fc(self, self->aq_nic_cfg->flow_control, tc);
++=======
+ 	tx_buff_size /= cfg->tcs;
+ 	rx_buff_size /= cfg->tcs;
+ 	for (tc = 0; tc < cfg->tcs; tc++) {
+ 		u32 threshold = 0U;
+ 
+ 		/* TX Packet Scheduler Data TC0 */
+ 		hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, 0xFFF, tc);
+ 		hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, 0x64, tc);
+ 		hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, 0x50, tc);
+ 		hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, 0x1E, tc);
+ 
+ 		/* Tx buf size TC0 */
+ 		hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, tx_buff_size, tc);
+ 
+ 		threshold = (tx_buff_size * (1024 / 32U) * 66U) / 100U;
+ 		hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self, threshold, tc);
+ 
+ 		threshold = (tx_buff_size * (1024 / 32U) * 50U) / 100U;
+ 		hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self, threshold, tc);
+ 
+ 		/* QoS Rx buf size per TC */
+ 		hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, rx_buff_size, tc);
+ 
+ 		threshold = (rx_buff_size * (1024U / 32U) * 66U) / 100U;
+ 		hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self, threshold, tc);
+ 
+ 		threshold = (rx_buff_size * (1024U / 32U) * 50U) / 100U;
+ 		hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self, threshold, tc);
+ 
+ 		hw_atl_b0_set_fc(self, self->aq_nic_cfg->fc.req, tc);
+ 	}
+ 
+ 	if (cfg->is_ptp)
+ 		hw_atl_b0_tc_ptp_set(self);
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  
  	/* QoS 802.1p priority -> TC mapping */
- 	for (i_priority = 8U; i_priority--;)
- 		hw_atl_rpf_rpb_user_priority_tc_map_set(self, i_priority, 0U);
+ 	for (prio = 0; prio < 8; ++prio)
+ 		hw_atl_rpf_rpb_user_priority_tc_map_set(self, prio,
+ 							cfg->prio_tc_map[prio]);
  
  	return aq_hw_err_from_flags(self);
  }
@@@ -289,7 -323,7 +343,11 @@@ static int hw_atl_b0_hw_offload_set(str
  static int hw_atl_b0_hw_init_tx_path(struct aq_hw_s *self)
  {
  	/* Tx TC/Queue number config */
++<<<<<<< HEAD
 +	hw_atl_rpb_tps_tx_tc_mode_set(self, 1U);
++=======
+ 	hw_atl_tpb_tps_tx_tc_mode_set(self, self->aq_nic_cfg->tc_mode);
++>>>>>>> a83fe6b6ad6b (net: atlantic: QoS implementation: multi-TC support)
  
  	hw_atl_thm_lso_tcp_flag_of_first_pkt_set(self, 0x0FF6U);
  	hw_atl_thm_lso_tcp_flag_of_middle_pkt_set(self, 0x0FF6U);
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_internal.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh_internal.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_filters.c b/drivers/net/ethernet/aquantia/atlantic/aq_filters.c
index 01af0f028693..7714bbe92be2 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_filters.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_filters.c
@@ -148,6 +148,8 @@ aq_check_approve_fvlan(struct aq_nic_s *aq_nic,
 		       struct aq_hw_rx_fltrs_s *rx_fltrs,
 		       struct ethtool_rx_flow_spec *fsp)
 {
+	struct aq_nic_cfg_s *cfg = &aq_nic->aq_nic_cfg;
+
 	if (fsp->location < AQ_RX_FIRST_LOC_FVLANID ||
 	    fsp->location > AQ_RX_LAST_LOC_FVLANID) {
 		netdev_err(aq_nic->ndev,
@@ -165,10 +167,10 @@ aq_check_approve_fvlan(struct aq_nic_s *aq_nic,
 		return -EINVAL;
 	}
 
-	if (fsp->ring_cookie > aq_nic->aq_nic_cfg.num_rss_queues) {
+	if (fsp->ring_cookie > cfg->num_rss_queues * cfg->tcs) {
 		netdev_err(aq_nic->ndev,
 			   "ethtool: queue number must be in range [0, %d]",
-			   aq_nic->aq_nic_cfg.num_rss_queues - 1);
+			   cfg->num_rss_queues * cfg->tcs - 1);
 		return -EINVAL;
 	}
 	return 0;
@@ -257,6 +259,7 @@ static bool __must_check
 aq_rule_is_not_correct(struct aq_nic_s *aq_nic,
 		       struct ethtool_rx_flow_spec *fsp)
 {
+	struct aq_nic_cfg_s *cfg = &aq_nic->aq_nic_cfg;
 	bool rule_is_not_correct = false;
 
 	if (!aq_nic) {
@@ -269,11 +272,11 @@ aq_rule_is_not_correct(struct aq_nic_s *aq_nic,
 	} else if (aq_check_filter(aq_nic, fsp)) {
 		rule_is_not_correct = true;
 	} else if (fsp->ring_cookie != RX_CLS_FLOW_DISC) {
-		if (fsp->ring_cookie >= aq_nic->aq_nic_cfg.num_rss_queues) {
+		if (fsp->ring_cookie >= cfg->num_rss_queues * cfg->tcs) {
 			netdev_err(aq_nic->ndev,
 				   "ethtool: The specified action is invalid.\n"
 				   "Maximum allowable value action is %u.\n",
-				   aq_nic->aq_nic_cfg.num_rss_queues - 1);
+				   cfg->num_rss_queues * cfg->tcs - 1);
 			rule_is_not_correct = true;
 		}
 	}
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_hw.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.c b/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.c
index 22a1c784dc9c..7ea24d396bb0 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.c
@@ -81,3 +81,29 @@ int aq_hw_err_from_flags(struct aq_hw_s *hw)
 err_exit:
 	return err;
 }
+
+int aq_hw_num_tcs(struct aq_hw_s *hw)
+{
+	switch (hw->aq_nic_cfg->tc_mode) {
+	case AQ_TC_MODE_8TCS:
+		return 8;
+	case AQ_TC_MODE_4TCS:
+		return 4;
+	default:
+		break;
+	}
+
+	return 1;
+}
+
+int aq_hw_q_per_tc(struct aq_hw_s *hw)
+{
+	switch (hw->aq_nic_cfg->tc_mode) {
+	case AQ_TC_MODE_8TCS:
+		return 4;
+	case AQ_TC_MODE_4TCS:
+		return 8;
+	default:
+		return 4;
+	}
+}
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.h b/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.h
index bf73428ed689..18b999cfda6d 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.h
@@ -37,5 +37,7 @@ u32 aq_hw_read_reg(struct aq_hw_s *hw, u32 reg);
 void aq_hw_write_reg(struct aq_hw_s *hw, u32 reg, u32 value);
 u64 aq_hw_read_reg64(struct aq_hw_s *hw, u32 reg);
 int aq_hw_err_from_flags(struct aq_hw_s *hw);
+int aq_hw_num_tcs(struct aq_hw_s *hw);
+int aq_hw_q_per_tc(struct aq_hw_s *hw);
 
 #endif /* AQ_HW_UTILS_H */
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_main.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
index 961b9b69649f..e65d5bae6a51 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c
@@ -736,7 +736,7 @@ void hw_atl_rpfl2_accept_all_mc_packets_set(struct aq_hw_s *aq_hw,
 }
 
 void hw_atl_rpf_rpb_user_priority_tc_map_set(struct aq_hw_s *aq_hw,
-					     u32 user_priority_tc_map, u32 tc)
+					     u32 user_priority, u32 tc)
 {
 /* register address for bitfield rx_tc_up{t}[2:0] */
 	static u32 rpf_rpb_rx_tc_upt_adr[8] = {
@@ -755,10 +755,9 @@ void hw_atl_rpf_rpb_user_priority_tc_map_set(struct aq_hw_s *aq_hw,
 			0U, 4U, 8U, 12U, 16U, 20U, 24U, 28U
 		};
 
-	aq_hw_write_reg_bit(aq_hw, rpf_rpb_rx_tc_upt_adr[tc],
-			    rpf_rpb_rx_tc_upt_msk[tc],
-			    rpf_rpb_rx_tc_upt_shft[tc],
-			    user_priority_tc_map);
+	aq_hw_write_reg_bit(aq_hw, rpf_rpb_rx_tc_upt_adr[user_priority],
+			    rpf_rpb_rx_tc_upt_msk[user_priority],
+			    rpf_rpb_rx_tc_upt_shft[user_priority], tc);
 }
 
 void hw_atl_rpf_rss_key_addr_set(struct aq_hw_s *aq_hw, u32 rss_key_addr)
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_internal.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_llh_internal.h
