x86/dumpstack: Fix misleading instruction pointer error message

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mark Mossberg <mark.mossberg@gmail.com>
commit 238c91115cd05c71447ea071624a4c9fe661f970
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/238c9111.failed

Printing "Bad RIP value" if copy_code() fails can be misleading for
userspace pointers, since copy_code() can fail if the instruction
pointer is valid but the code is paged out. This is because copy_code()
calls copy_from_user_nmi() for userspace pointers, which disables page
fault handling.

This is reproducible in OOM situations, where it's plausible that the
code may be reclaimed in the time between entry into the kernel and when
this message is printed. This leaves a misleading log in dmesg that
suggests instruction pointer corruption has occurred, which may alarm
users.

Change the message to state the error condition more precisely.

 [ bp: Massage a bit. ]

	Signed-off-by: Mark Mossberg <mark.mossberg@gmail.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20201002042915.403558-1-mark.mossberg@gmail.com
(cherry picked from commit 238c91115cd05c71447ea071624a4c9fe661f970)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/dumpstack.c
diff --cc arch/x86/kernel/dumpstack.c
index e07424e19274,ea8d51ec251b..000000000000
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@@ -97,18 -113,10 +97,24 @@@ void show_opcodes(struct pt_regs *regs
  #define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)
  	u8 opcodes[OPCODE_BUFSIZE];
  	unsigned long prologue = regs->ip - PROLOGUE_SIZE;
 +	bool bad_ip;
 +
++<<<<<<< HEAD
 +	/*
 +	 * Make sure userspace isn't trying to trick us into dumping kernel
 +	 * memory by pointing the userspace instruction pointer at it.
 +	 */
 +	bad_ip = user_mode(regs) &&
 +		__chk_range_not_ok(prologue, OPCODE_BUFSIZE, TASK_SIZE_MAX);
  
 +	if (bad_ip || probe_kernel_read(opcodes, (u8 *)prologue,
 +					OPCODE_BUFSIZE)) {
 +		printk("%sCode: Bad RIP value.\n", loglvl);
++=======
+ 	if (copy_code(regs, opcodes, prologue, sizeof(opcodes))) {
+ 		printk("%sCode: Unable to access opcode bytes at RIP 0x%lx.\n",
+ 		       loglvl, prologue);
++>>>>>>> 238c91115cd0 (x86/dumpstack: Fix misleading instruction pointer error message)
  	} else {
  		printk("%sCode: %" __stringify(PROLOGUE_SIZE) "ph <%02x> %"
  		       __stringify(EPILOGUE_SIZE) "ph\n", loglvl, opcodes,
* Unmerged path arch/x86/kernel/dumpstack.c
