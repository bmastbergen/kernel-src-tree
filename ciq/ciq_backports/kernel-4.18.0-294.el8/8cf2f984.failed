radix tree: Remove radix_tree_maybe_preload_order

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit 8cf2f98411e3a0865026a1061af637161b16d32b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8cf2f984.failed

This function was only used by the page cache which is now converted
to the XArray.

	Signed-off-by: Matthew Wilcox <willy@infradead.org>
(cherry picked from commit 8cf2f98411e3a0865026a1061af637161b16d32b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
diff --cc lib/radix-tree.c
index 310e89cc0f92,b57ddc3dbbbd..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -415,73 -412,6 +412,76 @@@ int radix_tree_maybe_preload(gfp_t gfp_
  }
  EXPORT_SYMBOL(radix_tree_maybe_preload);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_RADIX_TREE_MULTIORDER
 +/*
 + * Preload with enough objects to ensure that we can split a single entry
 + * of order @old_order into many entries of size @new_order
 + */
 +int radix_tree_split_preload(unsigned int old_order, unsigned int new_order,
 +							gfp_t gfp_mask)
 +{
 +	unsigned top = 1 << (old_order % RADIX_TREE_MAP_SHIFT);
 +	unsigned layers = (old_order / RADIX_TREE_MAP_SHIFT) -
 +				(new_order / RADIX_TREE_MAP_SHIFT);
 +	unsigned nr = 0;
 +
 +	WARN_ON_ONCE(!gfpflags_allow_blocking(gfp_mask));
 +	BUG_ON(new_order >= old_order);
 +
 +	while (layers--)
 +		nr = nr * RADIX_TREE_MAP_SIZE + 1;
 +	return __radix_tree_preload(gfp_mask, top * nr);
 +}
 +#endif
 +
 +/*
 + * The same as function above, but preload number of nodes required to insert
 + * (1 << order) continuous naturally-aligned elements.
 + */
 +int radix_tree_maybe_preload_order(gfp_t gfp_mask, int order)
 +{
 +	unsigned long nr_subtrees;
 +	int nr_nodes, subtree_height;
 +
 +	/* Preloading doesn't help anything with this gfp mask, skip it */
 +	if (!gfpflags_allow_blocking(gfp_mask)) {
 +		preempt_disable();
 +		return 0;
 +	}
 +
 +	/*
 +	 * Calculate number and height of fully populated subtrees it takes to
 +	 * store (1 << order) elements.
 +	 */
 +	nr_subtrees = 1 << order;
 +	for (subtree_height = 0; nr_subtrees > RADIX_TREE_MAP_SIZE;
 +			subtree_height++)
 +		nr_subtrees >>= RADIX_TREE_MAP_SHIFT;
 +
 +	/*
 +	 * The worst case is zero height tree with a single item at index 0 and
 +	 * then inserting items starting at ULONG_MAX - (1 << order).
 +	 *
 +	 * This requires RADIX_TREE_MAX_PATH nodes to build branch from root to
 +	 * 0-index item.
 +	 */
 +	nr_nodes = RADIX_TREE_MAX_PATH;
 +
 +	/* Plus branch to fully populated subtrees. */
 +	nr_nodes += RADIX_TREE_MAX_PATH - subtree_height;
 +
 +	/* Root node is shared. */
 +	nr_nodes--;
 +
 +	/* Plus nodes required to build subtrees. */
 +	nr_nodes += nr_subtrees * height_to_maxnodes[subtree_height];
 +
 +	return __radix_tree_preload(gfp_mask, nr_nodes);
 +}
 +
++=======
++>>>>>>> 8cf2f98411e3 (radix tree: Remove radix_tree_maybe_preload_order)
  static unsigned radix_tree_load_root(const struct radix_tree_root *root,
  		struct radix_tree_node **nodep, unsigned long *maxindex)
  {
diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h
index d9f3cf0a4c4d..91419befefc1 100644
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@ -282,7 +282,6 @@ unsigned int radix_tree_gang_lookup_slot(const struct radix_tree_root *,
 			unsigned long first_index, unsigned int max_items);
 int radix_tree_preload(gfp_t gfp_mask);
 int radix_tree_maybe_preload(gfp_t gfp_mask);
-int radix_tree_maybe_preload_order(gfp_t gfp_mask, int order);
 void radix_tree_init(void);
 void *radix_tree_tag_set(struct radix_tree_root *,
 			unsigned long index, unsigned int tag);
* Unmerged path lib/radix-tree.c
