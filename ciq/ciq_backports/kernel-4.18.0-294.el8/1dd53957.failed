virtiofs: add a mount option to enable dax

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vivek Goyal <vgoyal@redhat.com>
commit 1dd539577c42b67da796e2e758e04171bb889779
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1dd53957.failed

Add a mount option to allow using dax with virtio_fs.

	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 1dd539577c42b67da796e2e758e04171bb889779)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/fuse_i.h
#	fs/fuse/inode.c
#	fs/fuse/virtio_fs.c
diff --cc fs/fuse/fuse_i.h
index 50415774dba0,97af7952373a..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -482,10 -482,15 +482,18 @@@ struct fuse_fs_context 
  	bool destroy:1;
  	bool no_control:1;
  	bool no_force_umount:1;
++<<<<<<< HEAD
 +	bool no_mount_options:1;
++=======
+ 	bool legacy_opts_show:1;
+ 	bool dax:1;
++>>>>>>> 1dd539577c42 (virtiofs: add a mount option to enable dax)
  	unsigned int max_read;
  	unsigned int blksize;
 -	const char *subtype;
  
+ 	/* DAX device, may be NULL */
+ 	struct dax_device *dax_dev;
+ 
  	/* fuse_dev pointer to fill in, should contain NULL on entry */
  	void **fudptr;
  };
diff --cc fs/fuse/inode.c
index 10b75246113a,1780dfe063ab..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -564,19 -573,25 +564,41 @@@ static int fuse_show_options(struct seq
  	struct super_block *sb = root->d_sb;
  	struct fuse_conn *fc = get_fuse_conn_super(sb);
  
++<<<<<<< HEAD
 +	if (fc->no_mount_options)
 +		return 0;
 +
 +	seq_printf(m, ",user_id=%u", from_kuid_munged(fc->user_ns, fc->user_id));
 +	seq_printf(m, ",group_id=%u", from_kgid_munged(fc->user_ns, fc->group_id));
 +	if (fc->default_permissions)
 +		seq_puts(m, ",default_permissions");
 +	if (fc->allow_other)
 +		seq_puts(m, ",allow_other");
 +	if (fc->max_read != ~0)
 +		seq_printf(m, ",max_read=%u", fc->max_read);
 +	if (sb->s_bdev && sb->s_blocksize != FUSE_DEFAULT_BLKSIZE)
 +		seq_printf(m, ",blksize=%lu", sb->s_blocksize);
++=======
+ 	if (fc->legacy_opts_show) {
+ 		seq_printf(m, ",user_id=%u",
+ 			   from_kuid_munged(fc->user_ns, fc->user_id));
+ 		seq_printf(m, ",group_id=%u",
+ 			   from_kgid_munged(fc->user_ns, fc->group_id));
+ 		if (fc->default_permissions)
+ 			seq_puts(m, ",default_permissions");
+ 		if (fc->allow_other)
+ 			seq_puts(m, ",allow_other");
+ 		if (fc->max_read != ~0)
+ 			seq_printf(m, ",max_read=%u", fc->max_read);
+ 		if (sb->s_bdev && sb->s_blocksize != FUSE_DEFAULT_BLKSIZE)
+ 			seq_printf(m, ",blksize=%lu", sb->s_blocksize);
+ 	}
+ #ifdef CONFIG_FUSE_DAX
+ 	if (fc->dax)
+ 		seq_puts(m, ",dax");
+ #endif
+ 
++>>>>>>> 1dd539577c42 (virtiofs: add a mount option to enable dax)
  	return 0;
  }
  
@@@ -1163,9 -1182,18 +1187,24 @@@ int fuse_fill_super_common(struct super
  	if (sb->s_user_ns != &init_user_ns)
  		sb->s_xattr = fuse_no_acl_xattr_handlers;
  
++<<<<<<< HEAD
 +	fud = fuse_dev_alloc_install(fc);
 +	if (!fud)
 +		goto err;
++=======
+ 	if (IS_ENABLED(CONFIG_FUSE_DAX)) {
+ 		err = fuse_dax_conn_alloc(fc, ctx->dax_dev);
+ 		if (err)
+ 			goto err;
+ 	}
+ 
+ 	if (ctx->fudptr) {
+ 		err = -ENOMEM;
+ 		fud = fuse_dev_alloc_install(fc);
+ 		if (!fud)
+ 			goto err_free_dax;
+ 	}
++>>>>>>> 1dd539577c42 (virtiofs: add a mount option to enable dax)
  
  	fc->dev = sb->s_dev;
  	fc->sb = sb;
@@@ -1216,7 -1245,11 +1255,15 @@@
  	mutex_unlock(&fuse_mutex);
  	dput(root_dentry);
   err_dev_free:
++<<<<<<< HEAD
 +	fuse_dev_free(fud);
++=======
+ 	if (fud)
+ 		fuse_dev_free(fud);
+  err_free_dax:
+ 	if (IS_ENABLED(CONFIG_FUSE_DAX))
+ 		fuse_dax_conn_free(fc);
++>>>>>>> 1dd539577c42 (virtiofs: add a mount option to enable dax)
   err:
  	return err;
  }
diff --cc fs/fuse/virtio_fs.c
index 9e1128e7dad6,e25f62276050..000000000000
--- a/fs/fuse/virtio_fs.c
+++ b/fs/fuse/virtio_fs.c
@@@ -12,6 -12,8 +12,11 @@@
  #include <linux/virtio.h>
  #include <linux/virtio_fs.h>
  #include <linux/delay.h>
++<<<<<<< HEAD
++=======
+ #include <linux/fs_context.h>
+ #include <linux/fs_parser.h>
++>>>>>>> 1dd539577c42 (virtiofs: add a mount option to enable dax)
  #include <linux/highmem.h>
  #include <linux/uio.h>
  #include "fuse_i.h"
@@@ -1222,20 -1274,11 +1277,25 @@@ static int virtio_fs_fill_super(struct 
  {
  	struct fuse_conn *fc = get_fuse_conn_super(sb);
  	struct virtio_fs *fs = fc->iq.priv;
+ 	struct fuse_fs_context *ctx = fsc->fs_private;
  	unsigned int i;
  	int err;
++<<<<<<< HEAD
 +	struct fuse_fs_context ctx = {
 +		.rootmode = S_IFDIR,
 +		.default_permissions = 1,
 +		.allow_other = 1,
 +		.max_read = UINT_MAX,
 +		.blksize = 512,
 +		.destroy = true,
 +		.no_control = true,
 +		.no_force_umount = true,
 +		.no_mount_options = true,
 +	};
++=======
++>>>>>>> 1dd539577c42 (virtiofs: add a mount option to enable dax)
  
+ 	virtio_fs_ctx_set_defaults(ctx);
  	mutex_lock(&virtio_fs_mutex);
  
  	/* After holding mutex, make sure virtiofs device is still there.
@@@ -1258,8 -1301,11 +1318,16 @@@
  			goto err_free_fuse_devs;
  	}
  
++<<<<<<< HEAD
 +	ctx.fudptr = (void **)&fs->vqs[VQ_REQUEST].fud;
 +	err = fuse_fill_super_common(sb, &ctx);
++=======
+ 	/* virtiofs allocates and installs its own fuse devices */
+ 	ctx->fudptr = NULL;
+ 	if (ctx->dax)
+ 		ctx->dax_dev = fs->dax_dev;
+ 	err = fuse_fill_super_common(sb, ctx);
++>>>>>>> 1dd539577c42 (virtiofs: add a mount option to enable dax)
  	if (err < 0)
  		goto err_free_fuse_devs;
  
@@@ -1371,29 -1409,43 +1439,53 @@@ static struct dentry *virtio_fs_mount(s
  	fc->release = fuse_free_conn;
  	fc->delete_stale = true;
  
 -	fsc->s_fs_info = fc;
 -	sb = sget_fc(fsc, virtio_fs_test_super, virtio_fs_set_super);
 +	sb = sget(fs_type, virtio_fs_test_super, virtio_fs_set_super, flags,
 +		  fc);
  	fuse_conn_put(fc);
  	if (IS_ERR(sb))
 -		return PTR_ERR(sb);
 +		return ERR_CAST(sb);
  
  	if (!sb->s_root) {
- 		err = virtio_fs_fill_super(sb);
+ 		err = virtio_fs_fill_super(sb, fsc);
  		if (err) {
  			deactivate_locked_super(sb);
 -			return err;
 +			return ERR_PTR(err);
  		}
  
  		sb->s_flags |= SB_ACTIVE;
 +	} else {
 +		err = -EBUSY;
 +		if ((flags ^ sb->s_flags) & SB_RDONLY) {
 +			deactivate_locked_super(sb);
 +			return ERR_PTR(err);
 +		}
  	}
  
++<<<<<<< HEAD
 +	return dget(sb->s_root);
++=======
+ 	WARN_ON(fsc->root);
+ 	fsc->root = dget(sb->s_root);
+ 	return 0;
+ }
+ 
+ static const struct fs_context_operations virtio_fs_context_ops = {
+ 	.free		= virtio_fs_free_fc,
+ 	.parse_param	= virtio_fs_parse_param,
+ 	.get_tree	= virtio_fs_get_tree,
+ };
+ 
+ static int virtio_fs_init_fs_context(struct fs_context *fsc)
+ {
+ 	struct fuse_fs_context *ctx;
+ 
+ 	ctx = kzalloc(sizeof(struct fuse_fs_context), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 	fsc->fs_private = ctx;
+ 	fsc->ops = &virtio_fs_context_ops;
+ 	return 0;
++>>>>>>> 1dd539577c42 (virtiofs: add a mount option to enable dax)
  }
  
  static struct file_system_type virtio_fs_type = {
diff --git a/fs/fuse/Kconfig b/fs/fuse/Kconfig
index e70f6a548ec0..38ced9bc17a0 100644
--- a/fs/fuse/Kconfig
+++ b/fs/fuse/Kconfig
@@ -37,3 +37,16 @@ config VIRTIO_FS
 
 	  If you want to share files between guests or with the host, answer Y
 	  or M.
+
+config FUSE_DAX
+	bool "Virtio Filesystem Direct Host Memory Access support"
+	default y
+	depends on VIRTIO_FS
+	depends on FS_DAX
+	depends on DAX_DRIVER
+	help
+	  This allows bypassing guest page cache and allows mapping host page
+	  cache directly in guest address space.
+
+	  If you want to allow mounting a Virtio Filesystem with the "dax"
+	  option, answer Y.
diff --git a/fs/fuse/Makefile b/fs/fuse/Makefile
index eb33d33d4821..210f67819d1d 100644
--- a/fs/fuse/Makefile
+++ b/fs/fuse/Makefile
@@ -6,5 +6,7 @@ obj-$(CONFIG_FUSE_FS) += fuse.o
 obj-$(CONFIG_CUSE) += cuse.o
 obj-$(CONFIG_VIRTIO_FS) += virtiofs.o
 
-fuse-objs := dev.o dir.o file.o inode.o control.o xattr.o acl.o readdir.o
-virtiofs-y += virtio_fs.o
+fuse-y := dev.o dir.o file.o inode.o control.o xattr.o acl.o readdir.o
+fuse-$(CONFIG_FUSE_DAX) += dax.o
+
+virtiofs-y := virtio_fs.o
diff --git a/fs/fuse/dax.c b/fs/fuse/dax.c
new file mode 100644
index 000000000000..9660d01f49a5
--- /dev/null
+++ b/fs/fuse/dax.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dax: direct host memory access
+ * Copyright (C) 2020 Red Hat, Inc.
+ */
+
+#include "fuse_i.h"
+
+#include <linux/dax.h>
+
+struct fuse_conn_dax {
+	/* DAX device */
+	struct dax_device *dev;
+};
+
+void fuse_dax_conn_free(struct fuse_conn *fc)
+{
+	kfree(fc->dax);
+}
+
+int fuse_dax_conn_alloc(struct fuse_conn *fc, struct dax_device *dax_dev)
+{
+	struct fuse_conn_dax *fcd;
+
+	if (!dax_dev)
+		return 0;
+
+	fcd = kzalloc(sizeof(*fcd), GFP_KERNEL);
+	if (!fcd)
+		return -ENOMEM;
+
+	fcd->dev = dax_dev;
+
+	fc->dax = fcd;
+	return 0;
+}
* Unmerged path fs/fuse/fuse_i.h
* Unmerged path fs/fuse/inode.c
* Unmerged path fs/fuse/virtio_fs.c
