RDMA/mlx5: Use flags_en mechanism to mark QP created with WQE signature

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit c95e6d53970254fa04a09c0fd79ae2cfa54cd1f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c95e6d53.failed

MLX5_QP_FLAG_SIGNATURE is exposed to the users but in the kernel
the create_qp flow treated it differently from other MLX5_QP_FLAG_*s.
Fix it by ditching wq_sig boolean variable and use general flag_en
mechanism.

Link: https://lore.kernel.org/r/20200427154636.381474-16-leon@kernel.org
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit c95e6d53970254fa04a09c0fd79ae2cfa54cd1f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 745e3ea1cb8f,9d29b84242f9..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -2085,10 -2017,12 +2094,15 @@@ static int create_qp_common(struct mlx5
  		if (err)
  			return err;
  
++<<<<<<< HEAD
 +		qp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);
++=======
+ 		if (ucmd->flags & MLX5_QP_FLAG_SIGNATURE)
+ 			qp->flags_en |= MLX5_QP_FLAG_SIGNATURE;
++>>>>>>> c95e6d539702 (RDMA/mlx5: Use flags_en mechanism to mark QP created with WQE signature)
  		if (MLX5_CAP_GEN(dev->mdev, sctr_data_cqe))
 -			qp->scat_cqe =
 -				!!(ucmd->flags & MLX5_QP_FLAG_SCATTER_CQE);
 -		if (ucmd->flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {
 +			qp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);
 +		if (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {
  			if (init_attr->qp_type != IB_QPT_RAW_PACKET ||
  			    !tunnel_offload_supported(mdev)) {
  				mlx5_ib_dbg(dev, "Tunnel offload isn't supported\n");
@@@ -2119,27 -2053,15 +2133,25 @@@
  				mlx5_ib_dbg(dev, "packet based credit mode isn't supported\n");
  				return -EOPNOTSUPP;
  			}
 -			qp->flags_en |= MLX5_QP_FLAG_PACKET_BASED_CREDIT_MODE;
 +			qp->flags |= MLX5_IB_QP_PACKET_BASED_CREDIT;
  		}
 -	}
  
 -	if (qp->flags & IB_QP_CREATE_SOURCE_QPN)
 -		qp->underlay_qpn = init_attr->source_qpn;
 +		if (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {
 +			if (init_attr->qp_type != IB_QPT_UD ||
 +			    (MLX5_CAP_GEN(dev->mdev, port_type) !=
 +			     MLX5_CAP_PORT_TYPE_IB) ||
 +			    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {
 +				mlx5_ib_dbg(dev, "Source QP option isn't supported\n");
 +				return -EOPNOTSUPP;
 +			}
 +
 +			qp->flags |= MLX5_IB_QP_UNDERLAY;
 +			qp->underlay_qpn = init_attr->source_qpn;
 +		}
- 	} else {
- 		qp->wq_sig = !!wq_signature;
 +	}
  
  	base = (init_attr->qp_type == IB_QPT_RAW_PACKET ||
 -		qp->flags & IB_QP_CREATE_SOURCE_QPN) ?
 +		qp->flags & MLX5_IB_QP_UNDERLAY) ?
  	       &qp->raw_packet_qp.rq.base :
  	       &qp->trans_qp.base;
  
@@@ -2206,19 -2123,19 +2218,19 @@@
  		MLX5_SET(qpc, qpc, latency_sensitive, 1);
  
  
- 	if (qp->wq_sig)
+ 	if (qp->flags_en & MLX5_QP_FLAG_SIGNATURE)
  		MLX5_SET(qpc, qpc, wq_signature, 1);
  
 -	if (qp->flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK)
 +	if (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)
  		MLX5_SET(qpc, qpc, block_lb_mc, 1);
  
 -	if (qp->flags & IB_QP_CREATE_CROSS_CHANNEL)
 +	if (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)
  		MLX5_SET(qpc, qpc, cd_master, 1);
 -	if (qp->flags & IB_QP_CREATE_MANAGED_SEND)
 +	if (qp->flags & MLX5_IB_QP_MANAGED_SEND)
  		MLX5_SET(qpc, qpc, cd_slave_send, 1);
 -	if (qp->flags & IB_QP_CREATE_MANAGED_RECV)
 +	if (qp->flags & MLX5_IB_QP_MANAGED_RECV)
  		MLX5_SET(qpc, qpc, cd_slave_receive, 1);
 -	if (qp->flags_en & MLX5_QP_FLAG_PACKET_BASED_CREDIT_MODE)
 +	if (qp->flags & MLX5_IB_QP_PACKET_BASED_CREDIT)
  		MLX5_SET(qpc, qpc, req_e2e_credit_mode, 1);
  	if (qp->scat_cqe && (init_attr->qp_type == IB_QPT_RC ||
  			     init_attr->qp_type == IB_QPT_UC)) {
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index 23d1e95a5a49..f9bb3a405200 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -428,7 +428,6 @@ struct mlx5_ib_qp {
 	u32			flags;
 	u8			port;
 	u8			state;
-	int			wq_sig;
 	int			scat_cqe;
 	int			max_inline_data;
 	struct mlx5_bf	        bf;
diff --git a/drivers/infiniband/hw/mlx5/odp.c b/drivers/infiniband/hw/mlx5/odp.c
index 8c8d5e946948..cdfd29686123 100644
--- a/drivers/infiniband/hw/mlx5/odp.c
+++ b/drivers/infiniband/hw/mlx5/odp.c
@@ -1195,7 +1195,7 @@ static int mlx5_ib_mr_responder_pfault_handler_rq(struct mlx5_ib_dev *dev,
 	struct mlx5_ib_wq *wq = &qp->rq;
 	int wqe_size = 1 << wq->wqe_shift;
 
-	if (qp->wq_sig) {
+	if (qp->flags_en & MLX5_QP_FLAG_SIGNATURE) {
 		mlx5_ib_err(dev, "ODP fault with WQE signatures is not supported\n");
 		return -EFAULT;
 	}
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
