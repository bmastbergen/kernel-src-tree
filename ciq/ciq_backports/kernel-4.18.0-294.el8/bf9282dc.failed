cpuidle: Make CPUIDLE_FLAG_TLB_FLUSHED generic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit bf9282dc26e7fe2a0736edc568762f0f05d12416
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/bf9282dc.failed

This allows moving the leave_mm() call into generic code before
rcu_idle_enter(). Gets rid of more trace_*_rcuidle() users.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Marco Elver <elver@google.com>
Link: https://lkml.kernel.org/r/20200821085348.369441600@infradead.org
(cherry picked from commit bf9282dc26e7fe2a0736edc568762f0f05d12416)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/tlb.c
#	drivers/idle/intel_idle.c
diff --cc arch/x86/mm/tlb.c
index ed12bde105b1,0951b47e64c1..000000000000
--- a/arch/x86/mm/tlb.c
+++ b/arch/x86/mm/tlb.c
@@@ -376,38 -548,31 +376,64 @@@ void switch_mm_irqs_off(struct mm_struc
  		/* Let nmi_uaccess_okay() know that we're changing CR3. */
  		this_cpu_write(cpu_tlbstate.loaded_mm, LOADED_MM_SWITCHING);
  		barrier();
 +
 +		if (need_flush) {
 +			this_cpu_write(cpu_tlbstate.ctxs[new_asid].ctx_id, next->context.ctx_id);
 +			this_cpu_write(cpu_tlbstate.ctxs[new_asid].tlb_gen, next_tlb_gen);
 +			load_new_mm_cr3(next->pgd, new_asid, true);
 +
 +			/*
 +			 * NB: This gets called via leave_mm() in the idle path
 +			 * where RCU functions differently.  Tracing normally
 +			 * uses RCU, so we need to use the _rcuidle variant.
 +			 *
 +			 * (There is no good reason for this.  The idle code should
 +			 *  be rearranged to call this before rcu_idle_enter().)
 +			 */
 +			trace_tlb_flush_rcuidle(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 +		} else {
 +			/* The new ASID is already up to date. */
 +			load_new_mm_cr3(next->pgd, new_asid, false);
 +
 +			/* See above wrt _rcuidle. */
 +			trace_tlb_flush_rcuidle(TLB_FLUSH_ON_TASK_SWITCH, 0);
 +		}
 +
 +		/* Make sure we write CR3 before loaded_mm. */
 +		barrier();
 +
 +		this_cpu_write(cpu_tlbstate.loaded_mm, next);
 +		this_cpu_write(cpu_tlbstate.loaded_mm_asid, new_asid);
  	}
  
++<<<<<<< HEAD
 +	load_mm_cr4(next);
 +	switch_ldt(real_prev, next);
++=======
+ 	if (need_flush) {
+ 		this_cpu_write(cpu_tlbstate.ctxs[new_asid].ctx_id, next->context.ctx_id);
+ 		this_cpu_write(cpu_tlbstate.ctxs[new_asid].tlb_gen, next_tlb_gen);
+ 		load_new_mm_cr3(next->pgd, new_asid, true);
+ 
+ 		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
+ 	} else {
+ 		/* The new ASID is already up to date. */
+ 		load_new_mm_cr3(next->pgd, new_asid, false);
+ 
+ 		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, 0);
+ 	}
+ 
+ 	/* Make sure we write CR3 before loaded_mm. */
+ 	barrier();
+ 
+ 	this_cpu_write(cpu_tlbstate.loaded_mm, next);
+ 	this_cpu_write(cpu_tlbstate.loaded_mm_asid, new_asid);
+ 
+ 	if (next != real_prev) {
+ 		cr4_update_pce_mm(next);
+ 		switch_ldt(real_prev, next);
+ 	}
++>>>>>>> bf9282dc26e7 (cpuidle: Make CPUIDLE_FLAG_TLB_FLUSHED generic)
  }
  
  /*
diff --cc drivers/idle/intel_idle.c
index 0c5221d5504f,9a810e4a7946..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -123,6 -99,75 +115,78 @@@ static struct cpuidle_state *cpuidle_st
  #define flg2MWAIT(flags) (((flags) >> 24) & 0xFF)
  #define MWAIT2flg(eax) ((eax & 0xFF) << 24)
  
++<<<<<<< HEAD
++=======
+ /**
+  * intel_idle - Ask the processor to enter the given idle state.
+  * @dev: cpuidle device of the target CPU.
+  * @drv: cpuidle driver (assumed to point to intel_idle_driver).
+  * @index: Target idle state index.
+  *
+  * Use the MWAIT instruction to notify the processor that the CPU represented by
+  * @dev is idle and it can try to enter the idle state corresponding to @index.
+  *
+  * If the local APIC timer is not known to be reliable in the target idle state,
+  * enable one-shot tick broadcasting for the target CPU before executing MWAIT.
+  *
+  * Optionally call leave_mm() for the target CPU upfront to avoid wakeups due to
+  * flushing user TLBs.
+  *
+  * Must be called under local_irq_disable().
+  */
+ static __cpuidle int intel_idle(struct cpuidle_device *dev,
+ 				struct cpuidle_driver *drv, int index)
+ {
+ 	struct cpuidle_state *state = &drv->states[index];
+ 	unsigned long eax = flg2MWAIT(state->flags);
+ 	unsigned long ecx = 1; /* break on interrupt flag */
+ 	bool tick;
+ 
+ 	if (!static_cpu_has(X86_FEATURE_ARAT)) {
+ 		/*
+ 		 * Switch over to one-shot tick broadcast if the target C-state
+ 		 * is deeper than C1.
+ 		 */
+ 		if ((eax >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) {
+ 			tick = true;
+ 			tick_broadcast_enter();
+ 		} else {
+ 			tick = false;
+ 		}
+ 	}
+ 
+ 	mwait_idle_with_hints(eax, ecx);
+ 
+ 	if (!static_cpu_has(X86_FEATURE_ARAT) && tick)
+ 		tick_broadcast_exit();
+ 
+ 	return index;
+ }
+ 
+ /**
+  * intel_idle_s2idle - Ask the processor to enter the given idle state.
+  * @dev: cpuidle device of the target CPU.
+  * @drv: cpuidle driver (assumed to point to intel_idle_driver).
+  * @index: Target idle state index.
+  *
+  * Use the MWAIT instruction to notify the processor that the CPU represented by
+  * @dev is idle and it can try to enter the idle state corresponding to @index.
+  *
+  * Invoked as a suspend-to-idle callback routine with frozen user space, frozen
+  * scheduler tick and suspended scheduler clock on the target CPU.
+  */
+ static __cpuidle int intel_idle_s2idle(struct cpuidle_device *dev,
+ 				       struct cpuidle_driver *drv, int index)
+ {
+ 	unsigned long eax = flg2MWAIT(drv->states[index].flags);
+ 	unsigned long ecx = 1; /* break on interrupt flag */
+ 
+ 	mwait_idle_with_hints(eax, ecx);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> bf9282dc26e7 (cpuidle: Make CPUIDLE_FLAG_TLB_FLUSHED generic)
  /*
   * States are indexed by the cstate number,
   * which is also the index into the MWAIT hint array.
diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h
index e78c7db87801..d232de747837 100644
--- a/arch/x86/include/asm/mmu.h
+++ b/arch/x86/include/asm/mmu.h
@@ -63,5 +63,6 @@ typedef struct {
 	}
 
 void leave_mm(int cpu);
+#define leave_mm leave_mm
 
 #endif /* _ASM_X86_MMU_H */
* Unmerged path arch/x86/mm/tlb.c
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 7b9da773160e..425325c0952d 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -22,6 +22,7 @@
 #include <linux/module.h>
 #include <linux/suspend.h>
 #include <linux/tick.h>
+#include <linux/mmu_context.h>
 #include <trace/events/power.h>
 
 #include "cpuidle.h"
@@ -226,6 +227,9 @@ int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,
 		broadcast = false;
 	}
 
+	if (target_state->flags & CPUIDLE_FLAG_TLB_FLUSHED)
+		leave_mm(dev->cpu);
+
 	/* Take note of the planned idle state. */
 	sched_idle_set_state(target_state);
 
* Unmerged path drivers/idle/intel_idle.c
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
index 57c6cc62bebc..8f8a862f90be 100644
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -107,12 +107,13 @@ struct cpuidle_state {
 };
 
 /* Idle State Flags */
-#define CPUIDLE_FLAG_NONE       (0x00)
-#define CPUIDLE_FLAG_POLLING	BIT(0) /* polling state */
-#define CPUIDLE_FLAG_COUPLED	BIT(1) /* state applies to multiple cpus */
-#define CPUIDLE_FLAG_TIMER_STOP BIT(2) /* timer is stopped on this state */
-#define CPUIDLE_FLAG_UNUSABLE	BIT(3) /* avoid using this state */
-#define CPUIDLE_FLAG_OFF	BIT(4) /* disable this state by default */
+#define CPUIDLE_FLAG_NONE       	(0x00)
+#define CPUIDLE_FLAG_POLLING		BIT(0) /* polling state */
+#define CPUIDLE_FLAG_COUPLED		BIT(1) /* state applies to multiple cpus */
+#define CPUIDLE_FLAG_TIMER_STOP 	BIT(2) /* timer is stopped on this state */
+#define CPUIDLE_FLAG_UNUSABLE		BIT(3) /* avoid using this state */
+#define CPUIDLE_FLAG_OFF		BIT(4) /* disable this state by default */
+#define CPUIDLE_FLAG_TLB_FLUSHED	BIT(5) /* idle-state flushes TLBs */
 
 struct cpuidle_device_kobj;
 struct cpuidle_state_kobj;
diff --git a/include/linux/mmu_context.h b/include/linux/mmu_context.h
index d9a543a9e1cc..2494b640d5c7 100644
--- a/include/linux/mmu_context.h
+++ b/include/linux/mmu_context.h
@@ -3,6 +3,7 @@
 #define _LINUX_MMU_CONTEXT_H
 
 #include <asm/mmu_context.h>
+#include <asm/mmu.h>
 
 struct mm_struct;
 
@@ -14,4 +15,8 @@ void unuse_mm(struct mm_struct *mm);
 # define switch_mm_irqs_off switch_mm
 #endif
 
+#ifndef leave_mm
+static inline void leave_mm(int cpu) { }
+#endif
+
 #endif
