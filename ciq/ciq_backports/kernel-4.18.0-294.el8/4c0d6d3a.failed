net: phylink: add separate pcs operations structure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 4c0d6d3a7a81fcd2dcb4abf15fe2e13074cf8619
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4c0d6d3a.failed

Add a separate set of PCS operations, which MAC drivers can use to
couple phylink with their associated MAC PCS layer.  The PCS
operations include:

- pcs_get_state() - reads the link up/down, resolved speed, duplex
   and pause from the PCS.
- pcs_config() - configures the PCS for the specified mode, PHY
   interface type, and setting the advertisement.
- pcs_an_restart() - restarts 802.3 in-band negotiation with the
   link partner
- pcs_link_up() - informs the PCS that link has come up, and the
   parameters of the link. Link parameters are used to program the
   PCS for fixed speed and non-inband modes.

	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4c0d6d3a7a81fcd2dcb4abf15fe2e13074cf8619)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phylink.c
#	include/linux/phylink.h
diff --cc drivers/net/phy/phylink.c
index 203fde8d6f51,34ca12aec61b..000000000000
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@@ -40,7 -40,8 +40,12 @@@ enum 
  struct phylink {
  	/* private: */
  	struct net_device *netdev;
++<<<<<<< HEAD
 +	const struct phylink_mac_ops *ops;
++=======
+ 	const struct phylink_mac_ops *mac_ops;
+ 	const struct phylink_pcs_ops *pcs_ops;
++>>>>>>> 4c0d6d3a7a81 (net: phylink: add separate pcs operations structure)
  	struct phylink_config *config;
  	struct device *dev;
  	unsigned int old_link_state:1;
@@@ -424,16 -426,37 +429,42 @@@ static void phylink_mac_config_up(struc
  		phylink_mac_config(pl, state);
  }
  
- static void phylink_mac_an_restart(struct phylink *pl)
+ static void phylink_mac_pcs_an_restart(struct phylink *pl)
  {
  	if (pl->link_config.an_enabled &&
++<<<<<<< HEAD
 +	    phy_interface_mode_is_8023z(pl->link_config.interface))
 +		pl->ops->mac_an_restart(pl->config);
++=======
+ 	    phy_interface_mode_is_8023z(pl->link_config.interface)) {
+ 		if (pl->pcs_ops)
+ 			pl->pcs_ops->pcs_an_restart(pl->config);
+ 		else
+ 			pl->mac_ops->mac_an_restart(pl->config);
+ 	}
+ }
+ 
+ static void phylink_pcs_config(struct phylink *pl, bool force_restart,
+ 			       const struct phylink_link_state *state)
+ {
+ 	bool restart = force_restart;
+ 
+ 	if (pl->pcs_ops && pl->pcs_ops->pcs_config(pl->config,
+ 						   pl->cur_link_an_mode,
+ 						   state->interface,
+ 						   state->advertising))
+ 		restart = true;
+ 
+ 	phylink_mac_config(pl, state);
+ 
+ 	if (restart)
+ 		phylink_mac_pcs_an_restart(pl);
++>>>>>>> 4c0d6d3a7a81 (net: phylink: add separate pcs operations structure)
  }
  
 -static void phylink_mac_pcs_get_state(struct phylink *pl,
 -				      struct phylink_link_state *state)
 +static int phylink_get_mac_state(struct phylink *pl, struct phylink_link_state *state)
  {
 +
  	linkmode_copy(state->advertising, pl->link_config.advertising);
  	linkmode_zero(state->lp_advertising);
  	state->interface = pl->link_config.interface;
@@@ -444,7 -467,10 +475,14 @@@
  	state->an_complete = 0;
  	state->link = 1;
  
++<<<<<<< HEAD
 +	return pl->ops->mac_link_state(pl->config, state);
++=======
+ 	if (pl->pcs_ops)
+ 		pl->pcs_ops->pcs_get_state(pl->config, state);
+ 	else
+ 		pl->mac_ops->mac_pcs_get_state(pl->config, state);
++>>>>>>> 4c0d6d3a7a81 (net: phylink: add separate pcs operations structure)
  }
  
  /* The fixed state is... fixed except for the link state,
@@@ -511,8 -537,17 +549,22 @@@ static void phylink_link_up(struct phyl
  	struct net_device *ndev = pl->netdev;
  
  	pl->cur_interface = link_state.interface;
++<<<<<<< HEAD
 +	pl->ops->mac_link_up(pl->config, pl->link_an_mode,
 +			     pl->cur_interface, pl->phydev);
++=======
+ 
+ 	if (pl->pcs_ops && pl->pcs_ops->pcs_link_up)
+ 		pl->pcs_ops->pcs_link_up(pl->config, pl->cur_link_an_mode,
+ 					 pl->cur_interface,
+ 					 link_state.speed, link_state.duplex);
+ 
+ 	pl->mac_ops->mac_link_up(pl->config, pl->phydev,
+ 				 pl->cur_link_an_mode, pl->cur_interface,
+ 				 link_state.speed, link_state.duplex,
+ 				 !!(link_state.pause & MLO_PAUSE_TX),
+ 				 !!(link_state.pause & MLO_PAUSE_RX));
++>>>>>>> 4c0d6d3a7a81 (net: phylink: add separate pcs operations structure)
  
  	if (ndev)
  		netif_carrier_on(ndev);
diff --cc include/linux/phylink.h
index ac0a5167c2ac,3f8d37ec5503..000000000000
--- a/include/linux/phylink.h
+++ b/include/linux/phylink.h
@@@ -237,14 -265,102 +237,106 @@@ void mac_link_down(struct phylink_confi
   * phy_init_eee() and perform appropriate MAC configuration for EEE.
   * Interface type selection must be done in mac_config().
   */
 -void mac_link_up(struct phylink_config *config, struct phy_device *phy,
 -		 unsigned int mode, phy_interface_t interface,
 -		 int speed, int duplex, bool tx_pause, bool rx_pause);
 +void mac_link_up(struct phylink_config *config, unsigned int mode,
 +		 phy_interface_t interface,
 +		 struct phy_device *phy);
  #endif
  
+ /**
+  * struct phylink_pcs_ops - MAC PCS operations structure.
+  * @pcs_get_state: read the current MAC PCS link state from the hardware.
+  * @pcs_config: configure the MAC PCS for the selected mode and state.
+  * @pcs_an_restart: restart 802.3z BaseX autonegotiation.
+  * @pcs_link_up: program the PCS for the resolved link configuration
+  *               (where necessary).
+  */
+ struct phylink_pcs_ops {
+ 	void (*pcs_get_state)(struct phylink_config *config,
+ 			      struct phylink_link_state *state);
+ 	int (*pcs_config)(struct phylink_config *config, unsigned int mode,
+ 			  phy_interface_t interface,
+ 			  const unsigned long *advertising);
+ 	void (*pcs_an_restart)(struct phylink_config *config);
+ 	void (*pcs_link_up)(struct phylink_config *config, unsigned int mode,
+ 			    phy_interface_t interface, int speed, int duplex);
+ };
+ 
+ #if 0 /* For kernel-doc purposes only. */
+ /**
+  * pcs_get_state() - Read the current inband link state from the hardware
+  * @config: a pointer to a &struct phylink_config.
+  * @state: a pointer to a &struct phylink_link_state.
+  *
+  * Read the current inband link state from the MAC PCS, reporting the
+  * current speed in @state->speed, duplex mode in @state->duplex, pause
+  * mode in @state->pause using the %MLO_PAUSE_RX and %MLO_PAUSE_TX bits,
+  * negotiation completion state in @state->an_complete, and link up state
+  * in @state->link. If possible, @state->lp_advertising should also be
+  * populated.
+  *
+  * When present, this overrides mac_pcs_get_state() in &struct
+  * phylink_mac_ops.
+  */
+ void pcs_get_state(struct phylink_config *config,
+ 		   struct phylink_link_state *state);
+ 
+ /**
+  * pcs_config() - Configure the PCS mode and advertisement
+  * @config: a pointer to a &struct phylink_config.
+  * @mode: one of %MLO_AN_FIXED, %MLO_AN_PHY, %MLO_AN_INBAND.
+  * @interface: interface mode to be used
+  * @advertising: adertisement ethtool link mode mask
+  *
+  * Configure the PCS for the operating mode, the interface mode, and set
+  * the advertisement mask.
+  *
+  * When operating in %MLO_AN_INBAND, inband should always be enabled,
+  * otherwise inband should be disabled.
+  *
+  * For SGMII, there is no advertisement from the MAC side, the PCS should
+  * be programmed to acknowledge the inband word from the PHY.
+  *
+  * For 1000BASE-X, the advertisement should be programmed into the PCS.
+  *
+  * For most 10GBASE-R, there is no advertisement.
+  */
+ int (*pcs_config)(struct phylink_config *config, unsigned int mode,
+ 		  phy_interface_t interface, const unsigned long *advertising);
+ 
+ /**
+  * pcs_an_restart() - restart 802.3z BaseX autonegotiation
+  * @config: a pointer to a &struct phylink_config.
+  *
+  * When PCS ops are present, this overrides mac_an_restart() in &struct
+  * phylink_mac_ops.
+  */
+ void (*pcs_an_restart)(struct phylink_config *config);
+ 
+ /**
+  * pcs_link_up() - program the PCS for the resolved link configuration
+  * @config: a pointer to a &struct phylink_config.
+  * @mode: link autonegotiation mode
+  * @interface: link &typedef phy_interface_t mode
+  * @speed: link speed
+  * @duplex: link duplex
+  *
+  * This call will be made just before mac_link_up() to inform the PCS of
+  * the resolved link parameters. For example, a PCS operating in SGMII
+  * mode without in-band AN needs to be manually configured for the link
+  * and duplex setting. Otherwise, this should be a no-op.
+  */
+ void (*pcs_link_up)(struct phylink_config *config, unsigned int mode,
+ 		    phy_interface_t interface, int speed, int duplex);
+ #endif
+ 
  struct phylink *phylink_create(struct phylink_config *, struct fwnode_handle *,
  			       phy_interface_t iface,
++<<<<<<< HEAD
 +			       const struct phylink_mac_ops *ops);
++=======
+ 			       const struct phylink_mac_ops *mac_ops);
+ void phylink_add_pcs(struct phylink *, const struct phylink_pcs_ops *ops);
++>>>>>>> 4c0d6d3a7a81 (net: phylink: add separate pcs operations structure)
  void phylink_destroy(struct phylink *);
  
  int phylink_connect_phy(struct phylink *, struct phy_device *);
* Unmerged path drivers/net/phy/phylink.c
* Unmerged path include/linux/phylink.h
