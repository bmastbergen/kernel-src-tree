lpfc: nvmet: Add support for NVME LS request hosthandle

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author James Smart <jsmart2021@gmail.com>
commit 4c2805aab519a39e8adf281afcef40174d48fd3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/4c2805aa.failed

As the nvmet layer does not have the concept of a remoteport object, which
can be used to identify the entity on the other end of the fabric that is
to receive an LS, the hosthandle was introduced.  The driver passes the
hosthandle, a value representative of the remote port, with a ls request
receive. The LS request will create the association.  The transport will
remember the hosthandle for the association, and if there is a need to
initiate a LS request to the remote port for the association, the
hosthandle will be used. When the driver loses connectivity with the
remote port, it needs to notify the transport that the hosthandle is no
longer valid, allowing the transport to terminate associations related to
the hosthandle.

This patch adds support to the driver for the hosthandle. The driver will
use the ndlp pointer of the remote port for the hosthandle in calls to
nvmet_fc_rcv_ls_req().  The discovery engine is updated to invalidate the
hosthandle whenever connectivity with the remote port is lost.

	Signed-off-by: Paul Ely <paul.ely@broadcom.com>
	Signed-off-by: James Smart <jsmart2021@gmail.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 4c2805aab519a39e8adf281afcef40174d48fd3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_nvmet.c
diff --cc drivers/scsi/lpfc/lpfc_nvmet.c
index 0778dbb7937a,5584eaafbfb2..000000000000
--- a/drivers/scsi/lpfc/lpfc_nvmet.c
+++ b/drivers/scsi/lpfc/lpfc_nvmet.c
@@@ -1172,6 -1282,40 +1172,43 @@@ lpfc_nvmet_defer_rcv(struct nvmet_fc_ta
  	spin_unlock_irqrestore(&ctxp->ctxlock, iflag);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ lpfc_nvmet_host_release(void *hosthandle)
+ {
+ 	struct lpfc_nodelist *ndlp = hosthandle;
+ 	struct lpfc_hba *phba = NULL;
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 
+ 	phba = ndlp->phba;
+ 	if (!phba->targetport || !phba->targetport->private)
+ 		return;
+ 
+ 	lpfc_printf_log(phba, KERN_ERR, LOG_NVME,
+ 			"6202 NVMET XPT releasing hosthandle x%px\n",
+ 			hosthandle);
+ 	tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;
+ 	atomic_set(&tgtp->state, 0);
+ }
+ 
+ static void
+ lpfc_nvmet_discovery_event(struct nvmet_fc_target_port *tgtport)
+ {
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 	struct lpfc_hba *phba;
+ 	uint32_t rc;
+ 
+ 	tgtp = tgtport->private;
+ 	phba = tgtp->phba;
+ 
+ 	rc = lpfc_issue_els_rscn(phba->pport, 0);
+ 	lpfc_printf_log(phba, KERN_ERR, LOG_NVME,
+ 			"6420 NVMET subsystem change: Notification %s\n",
+ 			(rc) ? "Failed" : "Sent");
+ }
+ 
++>>>>>>> 4c2805aab519 (lpfc: nvmet: Add support for NVME LS request hosthandle)
  static struct nvmet_fc_target_template lpfc_tgttemplate = {
  	.targetport_delete = lpfc_nvmet_targetport_delete,
  	.xmt_ls_rsp     = lpfc_nvmet_xmt_ls_rsp,
@@@ -1179,6 -1323,8 +1216,11 @@@
  	.fcp_abort      = lpfc_nvmet_xmt_fcp_abort,
  	.fcp_req_release = lpfc_nvmet_xmt_fcp_release,
  	.defer_rcv	= lpfc_nvmet_defer_rcv,
++<<<<<<< HEAD
++=======
+ 	.discovery_event = lpfc_nvmet_discovery_event,
+ 	.host_release   = lpfc_nvmet_host_release,
++>>>>>>> 4c2805aab519 (lpfc: nvmet: Add support for NVME LS request hosthandle)
  
  	.max_hw_queues  = 1,
  	.max_sgl_segments = LPFC_NVMET_DEFAULT_SEGS,
diff --git a/drivers/scsi/lpfc/lpfc_crtn.h b/drivers/scsi/lpfc/lpfc_crtn.h
index 7a8c14bad841..4b98d0b97d48 100644
--- a/drivers/scsi/lpfc/lpfc_crtn.h
+++ b/drivers/scsi/lpfc/lpfc_crtn.h
@@ -574,6 +574,8 @@ void lpfc_nvmet_unsol_fcp_event(struct lpfc_hba *phba, uint32_t idx,
 				struct rqb_dmabuf *nvmebuf, uint64_t isr_ts,
 				uint8_t cqflag);
 void lpfc_nvme_mod_param_dep(struct lpfc_hba *phba);
+void lpfc_nvmet_invalidate_host(struct lpfc_hba *phba,
+			struct lpfc_nodelist *ndlp);
 void lpfc_nvme_abort_fcreq_cmpl(struct lpfc_hba *phba,
 				struct lpfc_iocbq *cmdiocb,
 				struct lpfc_wcqe_complete *abts_cmpl);
diff --git a/drivers/scsi/lpfc/lpfc_hbadisc.c b/drivers/scsi/lpfc/lpfc_hbadisc.c
index 3b0a26f60089..4084f7f2b821 100644
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -823,6 +823,12 @@ lpfc_cleanup_rpis(struct lpfc_vport *vport, int remove)
 		if ((phba->sli_rev < LPFC_SLI_REV4) &&
 		    (!remove && ndlp->nlp_type & NLP_FABRIC))
 			continue;
+
+		/* Notify transport of connectivity loss to trigger cleanup. */
+		if (phba->nvmet_support &&
+		    ndlp->nlp_state == NLP_STE_UNMAPPED_NODE)
+			lpfc_nvmet_invalidate_host(phba, ndlp);
+
 		lpfc_disc_state_machine(vport, ndlp, NULL,
 					remove
 					? NLP_EVT_DEVICE_RM
diff --git a/drivers/scsi/lpfc/lpfc_nportdisc.c b/drivers/scsi/lpfc/lpfc_nportdisc.c
index 3a712c6a8746..5ed9510dc700 100644
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c
@@ -489,6 +489,11 @@ lpfc_rcv_plogi(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
 					 (unsigned long long)
 					 wwn_to_u64(sp->portName.u.wwn));
 
+		/* Notify transport of connectivity loss to trigger cleanup. */
+		if (phba->nvmet_support &&
+		    ndlp->nlp_state == NLP_STE_UNMAPPED_NODE)
+			lpfc_nvmet_invalidate_host(phba, ndlp);
+
 		ndlp->nlp_prev_state = ndlp->nlp_state;
 		/* rport needs to be unregistered first */
 		lpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);
@@ -845,6 +850,12 @@ lpfc_rcv_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
 		lpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);
 	else
 		lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
+
+	/* Notify transport of connectivity loss to trigger cleanup. */
+	if (phba->nvmet_support &&
+	    ndlp->nlp_state == NLP_STE_UNMAPPED_NODE)
+		lpfc_nvmet_invalidate_host(phba, ndlp);
+
 	if (ndlp->nlp_DID == Fabric_DID) {
 		if (vport->port_state <= LPFC_FDISC)
 			goto out;
diff --git a/drivers/scsi/lpfc/lpfc_nvme.h b/drivers/scsi/lpfc/lpfc_nvme.h
index 10e8d868608e..0ea177d4b77e 100644
--- a/drivers/scsi/lpfc/lpfc_nvme.h
+++ b/drivers/scsi/lpfc/lpfc_nvme.h
@@ -92,9 +92,12 @@ struct lpfc_nvme_fcpreq_priv {
 #define LPFC_NVMET_WAIT_TMO		(5 * MSEC_PER_SEC)
 
 /* Used for NVME Target */
+#define LPFC_NVMET_INV_HOST_ACTIVE      1
+
 struct lpfc_nvmet_tgtport {
 	struct lpfc_hba *phba;
 	struct completion *tport_unreg_cmp;
+	atomic_t state;		/* tracks nvmet hosthandle invalidation */
 
 	/* Stats counters - lpfc_nvmet_unsol_ls_buffer */
 	atomic_t rcv_ls_req_in;
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.c
