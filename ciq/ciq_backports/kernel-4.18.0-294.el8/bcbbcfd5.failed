driver core: Allow a device to wait on optional suppliers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit bcbbcfd57247f4c2976055995e5760fb576aae1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/bcbbcfd5.failed

Before this change, if a device is waiting on suppliers, it's assumed
that all those suppliers are needed for the device to probe
successfully. This change allows marking a devices as waiting only on
optional suppliers. This allows a device to wait on suppliers (and link
to them as soon as they are available) without preventing the device
from being probed.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20191028220027.251605-3-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit bcbbcfd57247f4c2976055995e5760fb576aae1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/device.h
diff --cc drivers/base/core.c
index a11a4382fe7f,48cd43a91ce6..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -342,6 -465,70 +342,73 @@@ struct device_link *device_link_add(str
  }
  EXPORT_SYMBOL_GPL(device_link_add);
  
++<<<<<<< HEAD
++=======
+ /**
+  * device_link_wait_for_supplier - Add device to wait_for_suppliers list
+  * @consumer: Consumer device
+  *
+  * Marks the @consumer device as waiting for suppliers to become available by
+  * adding it to the wait_for_suppliers list. The consumer device will never be
+  * probed until it's removed from the wait_for_suppliers list.
+  *
+  * The caller is responsible for adding the links to the supplier devices once
+  * they are available and removing the @consumer device from the
+  * wait_for_suppliers list once links to all the suppliers have been created.
+  *
+  * This function is NOT meant to be called from the probe function of the
+  * consumer but rather from code that creates/adds the consumer device.
+  */
+ static void device_link_wait_for_supplier(struct device *consumer,
+ 					  bool need_for_probe)
+ {
+ 	mutex_lock(&wfs_lock);
+ 	list_add_tail(&consumer->links.needs_suppliers, &wait_for_suppliers);
+ 	consumer->links.need_for_probe = need_for_probe;
+ 	mutex_unlock(&wfs_lock);
+ }
+ 
+ static void device_link_wait_for_mandatory_supplier(struct device *consumer)
+ {
+ 	device_link_wait_for_supplier(consumer, true);
+ }
+ 
+ static void device_link_wait_for_optional_supplier(struct device *consumer)
+ {
+ 	device_link_wait_for_supplier(consumer, false);
+ }
+ 
+ /**
+  * device_link_add_missing_supplier_links - Add links from consumer devices to
+  *					    supplier devices, leaving any
+  *					    consumer with inactive suppliers on
+  *					    the wait_for_suppliers list
+  *
+  * Loops through all consumers waiting on suppliers and tries to add all their
+  * supplier links. If that succeeds, the consumer device is removed from
+  * wait_for_suppliers list. Otherwise, they are left in the wait_for_suppliers
+  * list.  Devices left on the wait_for_suppliers list will not be probed.
+  *
+  * The fwnode add_links callback is expected to return 0 if it has found and
+  * added all the supplier links for the consumer device. It should return an
+  * error if it isn't able to do so.
+  *
+  * The caller of device_link_wait_for_supplier() is expected to call this once
+  * it's aware of potential suppliers becoming available.
+  */
+ static void device_link_add_missing_supplier_links(void)
+ {
+ 	struct device *dev, *tmp;
+ 
+ 	mutex_lock(&wfs_lock);
+ 	list_for_each_entry_safe(dev, tmp, &wait_for_suppliers,
+ 				 links.needs_suppliers)
+ 		if (!fwnode_call_int_op(dev->fwnode, add_links, dev))
+ 			list_del_init(&dev->links.needs_suppliers);
+ 	mutex_unlock(&wfs_lock);
+ }
+ 
++>>>>>>> bcbbcfd57247 (driver core: Allow a device to wait on optional suppliers)
  static void device_link_free(struct device_link *link)
  {
  	while (refcount_dec_not_one(&link->rpm_active))
@@@ -468,6 -663,18 +535,21 @@@ int device_links_check_suppliers(struc
  	struct device_link *link;
  	int ret = 0;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Device waiting for supplier to become available is not allowed to
+ 	 * probe.
+ 	 */
+ 	mutex_lock(&wfs_lock);
+ 	if (!list_empty(&dev->links.needs_suppliers) &&
+ 	    dev->links.need_for_probe) {
+ 		mutex_unlock(&wfs_lock);
+ 		return -EPROBE_DEFER;
+ 	}
+ 	mutex_unlock(&wfs_lock);
+ 
++>>>>>>> bcbbcfd57247 (driver core: Allow a device to wait on optional suppliers)
  	device_links_write_lock();
  
  	list_for_each_entry(link, &dev->links.suppliers, c_node) {
@@@ -1979,6 -2399,24 +2070,27 @@@ int device_add(struct device *dev
  	if (dev->fwnode && !dev->fwnode->dev)
  		dev->fwnode->dev = dev;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Check if any of the other devices (consumers) have been waiting for
+ 	 * this device (supplier) to be added so that they can create a device
+ 	 * link to it.
+ 	 *
+ 	 * This needs to happen after device_pm_add() because device_link_add()
+ 	 * requires the supplier be registered before it's called.
+ 	 *
+ 	 * But this also needs to happe before bus_probe_device() to make sure
+ 	 * waiting consumers can link to it before the driver is bound to the
+ 	 * device and the driver sync_state callback is called for this device.
+ 	 */
+ 	device_link_add_missing_supplier_links();
+ 
+ 	if (fwnode_has_op(dev->fwnode, add_links)
+ 	    && fwnode_call_int_op(dev->fwnode, add_links, dev))
+ 		device_link_wait_for_mandatory_supplier(dev, true);
+ 
++>>>>>>> bcbbcfd57247 (driver core: Allow a device to wait on optional suppliers)
  	bus_probe_device(dev);
  	if (parent)
  		klist_add_tail(&dev->p->knode_parent,
diff --cc include/linux/device.h
index 7a77799bff7d,d1bcc8f122f6..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -1029,11 -1153,18 +1029,24 @@@ enum dl_dev_state 
   * struct dev_links_info - Device data related to device links.
   * @suppliers: List of links to supplier devices.
   * @consumers: List of links to consumer devices.
++<<<<<<< HEAD
++=======
+  * @needs_suppliers: Hook to global list of devices waiting for suppliers.
+  * @defer_sync: Hook to global list of devices that have deferred sync_state.
+  * @need_for_probe: If needs_suppliers is on a list, this indicates if the
+  *		    suppliers are needed for probe or not.
++>>>>>>> bcbbcfd57247 (driver core: Allow a device to wait on optional suppliers)
   * @status: Driver status information.
   */
  struct dev_links_info {
  	struct list_head suppliers;
  	struct list_head consumers;
++<<<<<<< HEAD
++=======
+ 	struct list_head needs_suppliers;
+ 	struct list_head defer_sync;
+ 	bool need_for_probe;
++>>>>>>> bcbbcfd57247 (driver core: Allow a device to wait on optional suppliers)
  	enum dl_dev_state status;
  };
  
* Unmerged path drivers/base/core.c
* Unmerged path include/linux/device.h
