intel_idle: add SnowRidge C-state table

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
commit 9cf93f056f783f986c19f40d5304d1bcffa0fc0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9cf93f05.failed

Add C-state table for the SnowRidge SoC which is found on Intel Jacobsville
platforms.

The following has been changed.

 1. C1E latency changed from 10us to 15us. It was measured using the
    open source "wult" tool (the "nic" method, 15us is the 99.99th
    percentile).

 2. C1E power break even changed from 20us to 25us, which may result
    in less C1E residency in some workloads.

 3. C6 latency changed from 50us to 130us. Measured the same way as C1E.

The C6 C-state is supported only by some SnowRidge revisions, so add a C-state
table commentary about this.

On SnowRidge, C6 support is enumerated via the usual mechanism: "mwait" leaf of
the "cpuid" instruction. The 'intel_idle' driver does check this leaf, so even
though C6 is present in the table, the driver will only use it if the CPU does
support it.

	Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 9cf93f056f783f986c19f40d5304d1bcffa0fc0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/idle/intel_idle.c
diff --cc drivers/idle/intel_idle.c
index 7a873b077402,28f93b9aa51b..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -906,115 -963,40 +906,152 @@@ static struct cpuidle_state dnv_cstates
  		.enter = NULL }
  };
  
++<<<<<<< HEAD
 +/**
 + * intel_idle - Ask the processor to enter the given idle state.
 + * @dev: cpuidle device of the target CPU.
 + * @drv: cpuidle driver (assumed to point to intel_idle_driver).
 + * @index: Target idle state index.
 + *
 + * Use the MWAIT instruction to notify the processor that the CPU represented by
 + * @dev is idle and it can try to enter the idle state corresponding to @index.
 + *
 + * If the local APIC timer is not known to be reliable in the target idle state,
 + * enable one-shot tick broadcasting for the target CPU before executing MWAIT.
 + *
 + * Optionally call leave_mm() for the target CPU upfront to avoid wakeups due to
 + * flushing user TLBs.
 + *
 + * Must be called under local_irq_disable().
 + */
 +static __cpuidle int intel_idle(struct cpuidle_device *dev,
 +				struct cpuidle_driver *drv, int index)
 +{
 +	struct cpuidle_state *state = &drv->states[index];
 +	unsigned long eax = flg2MWAIT(state->flags);
 +	unsigned long ecx = 1; /* break on interrupt flag */
 +	bool uninitialized_var(tick);
 +	int cpu = smp_processor_id();
 +
 +	/*
 +	 * leave_mm() to avoid costly and often unnecessary wakeups
 +	 * for flushing the user TLB's associated with the active mm.
 +	 */
 +	if (state->flags & CPUIDLE_FLAG_TLB_FLUSHED)
 +		leave_mm(cpu);
 +
 +	if (!static_cpu_has(X86_FEATURE_ARAT) && !lapic_timer_always_reliable) {
 +		/*
 +		 * Switch over to one-shot tick broadcast if the target C-state
 +		 * is deeper than C1.
 +		 */
 +		if ((eax >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) {
 +			tick = true;
 +			tick_broadcast_enter();
 +		} else {
 +			tick = false;
 +		}
 +	}
 +
 +	mwait_idle_with_hints(eax, ecx);
 +
 +	if (!static_cpu_has(X86_FEATURE_ARAT) && tick)
 +		tick_broadcast_exit();
 +
 +	return index;
 +}
 +
 +/**
 + * intel_idle_s2idle - Ask the processor to enter the given idle state.
 + * @dev: cpuidle device of the target CPU.
 + * @drv: cpuidle driver (assumed to point to intel_idle_driver).
 + * @index: Target idle state index.
 + *
 + * Use the MWAIT instruction to notify the processor that the CPU represented by
 + * @dev is idle and it can try to enter the idle state corresponding to @index.
 + *
 + * Invoked as a suspend-to-idle callback routine with frozen user space, frozen
 + * scheduler tick and suspended scheduler clock on the target CPU.
 + */
 +static __cpuidle void intel_idle_s2idle(struct cpuidle_device *dev,
 +					struct cpuidle_driver *drv, int index)
 +{
 +	unsigned long eax = flg2MWAIT(drv->states[index].flags);
 +	unsigned long ecx = 1; /* break on interrupt flag */
 +
 +	mwait_idle_with_hints(eax, ecx);
 +}
 +
 +static bool intel_idle_verify_cstate(unsigned int mwait_hint)
 +{
 +	unsigned int mwait_cstate = MWAIT_HINT2CSTATE(mwait_hint) + 1;
 +	unsigned int num_substates = (mwait_substates >> mwait_cstate * 4) &
 +					MWAIT_SUBSTATE_MASK;
 +
 +	/* Ignore the C-state if there are NO sub-states in CPUID for it. */
 +	if (num_substates == 0)
 +		return false;
 +
 +	if (mwait_cstate > 2 && !boot_cpu_has(X86_FEATURE_NONSTOP_TSC))
 +		mark_tsc_unstable("TSC halts in idle states deeper than C2");
 +
 +	return true;
 +}
 +
 +static void auto_demotion_disable(void)
 +{
 +	unsigned long long msr_bits;
 +
 +	rdmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);
 +	msr_bits &= ~(icpu->auto_demotion_disable_flags);
 +	wrmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);
 +}
 +static void c1e_promotion_disable(void)
 +{
 +	unsigned long long msr_bits;
 +
 +	rdmsrl(MSR_IA32_POWER_CTL, msr_bits);
 +	msr_bits &= ~0x2;
 +	wrmsrl(MSR_IA32_POWER_CTL, msr_bits);
 +}
 +
 +static const struct idle_cpu idle_cpu_nehalem = {
++=======
+ /*
+  * Note, depending on HW and FW revision, SnowRidge SoC may or may not support
+  * C6, and this is indicated in the CPUID mwait leaf.
+  */
+ static struct cpuidle_state snr_cstates[] __initdata = {
+ 	{
+ 		.name = "C1",
+ 		.desc = "MWAIT 0x00",
+ 		.flags = MWAIT2flg(0x00),
+ 		.exit_latency = 2,
+ 		.target_residency = 2,
+ 		.enter = &intel_idle,
+ 		.enter_s2idle = intel_idle_s2idle, },
+ 	{
+ 		.name = "C1E",
+ 		.desc = "MWAIT 0x01",
+ 		.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,
+ 		.exit_latency = 15,
+ 		.target_residency = 25,
+ 		.enter = &intel_idle,
+ 		.enter_s2idle = intel_idle_s2idle, },
+ 	{
+ 		.name = "C6",
+ 		.desc = "MWAIT 0x20",
+ 		.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,
+ 		.exit_latency = 130,
+ 		.target_residency = 500,
+ 		.enter = &intel_idle,
+ 		.enter_s2idle = intel_idle_s2idle, },
+ 	{
+ 		.enter = NULL }
+ };
+ 
+ static const struct idle_cpu idle_cpu_nehalem __initconst = {
++>>>>>>> 9cf93f056f78 (intel_idle: add SnowRidge C-state table)
  	.state_table = nehalem_cstates,
  	.auto_demotion_disable_flags = NHM_C1_AUTO_DEMOTE | NHM_C3_AUTO_DEMOTE,
  	.disable_promotion_to_c1e = true,
* Unmerged path drivers/idle/intel_idle.c
