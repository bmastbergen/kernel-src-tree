mm: migrate: make buffer_migrate_page_norefs() actually succeed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jan Kara <jack@suse.cz>
commit 80409c65e2c6cd1540045ee01fc55e50d95e0983
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/80409c65.failed

Currently, buffer_migrate_page_norefs() was constantly failing because
buffer_migrate_lock_buffers() grabbed reference on each buffer.  In
fact, there's no reason for buffer_migrate_lock_buffers() to grab any
buffer references as the page is locked during all our operation and
thus nobody can reclaim buffers from the page.

So remove grabbing of buffer references which also makes
buffer_migrate_page_norefs() succeed.

Link: http://lkml.kernel.org/r/20190116131217.7226-1-jack@suse.cz
Fixes: 89cb0888ca14 "mm: migrate: provide buffer_migrate_page_norefs()"
	Signed-off-by: Jan Kara <jack@suse.cz>
	Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
	Cc: Pavel Machek <pavel@ucw.cz>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Zi Yan <zi.yan@cs.rutgers.edu>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 80409c65e2c6cd1540045ee01fc55e50d95e0983)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/migrate.c
diff --cc mm/migrate.c
index 60059875287d,712b231a7376..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -775,13 -700,47 +775,57 @@@ int migrate_page(struct address_space *
  EXPORT_SYMBOL(migrate_page);
  
  #ifdef CONFIG_BLOCK
++<<<<<<< HEAD
 +/*
 + * Migration function for pages with buffers. This function can only be used
 + * if the underlying filesystem guarantees that no other references to "page"
 + * exist.
 + */
 +int buffer_migrate_page(struct address_space *mapping,
 +		struct page *newpage, struct page *page, enum migrate_mode mode)
++=======
+ /* Returns true if all buffers are successfully locked */
+ static bool buffer_migrate_lock_buffers(struct buffer_head *head,
+ 							enum migrate_mode mode)
+ {
+ 	struct buffer_head *bh = head;
+ 
+ 	/* Simple case, sync compaction */
+ 	if (mode != MIGRATE_ASYNC) {
+ 		do {
+ 			lock_buffer(bh);
+ 			bh = bh->b_this_page;
+ 
+ 		} while (bh != head);
+ 
+ 		return true;
+ 	}
+ 
+ 	/* async case, we cannot block on lock_buffer so use trylock_buffer */
+ 	do {
+ 		if (!trylock_buffer(bh)) {
+ 			/*
+ 			 * We failed to lock the buffer and cannot stall in
+ 			 * async migration. Release the taken locks
+ 			 */
+ 			struct buffer_head *failed_bh = bh;
+ 			bh = head;
+ 			while (bh != failed_bh) {
+ 				unlock_buffer(bh);
+ 				bh = bh->b_this_page;
+ 			}
+ 			return false;
+ 		}
+ 
+ 		bh = bh->b_this_page;
+ 	} while (bh != head);
+ 	return true;
+ }
+ 
+ static int __buffer_migrate_page(struct address_space *mapping,
+ 		struct page *newpage, struct page *page, enum migrate_mode mode,
+ 		bool check_refs)
++>>>>>>> 80409c65e2c6 (mm: migrate: make buffer_migrate_page_norefs() actually succeed)
  {
  	struct buffer_head *bh, *head;
  	int rc;
* Unmerged path mm/migrate.c
