scsi: scsi_debug: Weaken rwlock around ramdisk access

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Douglas Gilbert <dgilbert@interlog.com>
commit 67da413f26afc7522250bf5c9231f6711a9e7dfd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/67da413f.failed

The design of this driver is to do any ramdisk access on the same thread
that invoked the queuecommand() call. That is assumed to be user space
context. The command duration is implemented by setting the delay with a
high resolution timer. The hr timer's callback may well be in interrupt
context, but it doesn't touch the ramdisk. So try removing the
_irqsave()/_irqrestore() portion on the read-write lock that protects
ramdisk access.

Link: https://lore.kernel.org/r/20200421151424.32668-5-dgilbert@interlog.com
	Signed-off-by: Douglas Gilbert <dgilbert@interlog.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 67da413f26afc7522250bf5c9231f6711a9e7dfd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_debug.c
diff --cc drivers/scsi/scsi_debug.c
index bf9881fbdd10,ac8f31328632..000000000000
--- a/drivers/scsi/scsi_debug.c
+++ b/drivers/scsi/scsi_debug.c
@@@ -2664,14 -2736,15 +2664,24 @@@ static int prot_verify_read(struct scsi
  
  static int resp_read_dt0(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)
  {
++<<<<<<< HEAD
++=======
+ 	bool check_prot;
+ 	u32 num;
+ 	u32 ei_lba;
+ 	int ret;
+ 	u64 lba;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  	u8 *cmd = scp->cmnd;
  	struct sdebug_queued_cmd *sqcp;
 +	u64 lba;
 +	u32 num;
 +	u32 ei_lba;
 +	unsigned long iflags;
 +	int ret;
 +	bool check_prot;
  
  	switch (cmd[0]) {
  	case READ_16:
@@@ -2753,21 -2826,21 +2763,34 @@@
  		return check_condition_result;
  	}
  
++<<<<<<< HEAD
 +	read_lock_irqsave(&atomic_rw, iflags);
++=======
+ 	read_lock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  
  	/* DIX + T10 DIF */
  	if (unlikely(sdebug_dix && scsi_prot_sg_count(scp))) {
  		int prot_ret = prot_verify_read(scp, lba, num, ei_lba);
  
  		if (prot_ret) {
++<<<<<<< HEAD
 +			read_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 			read_unlock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  			mk_sense_buffer(scp, ABORTED_COMMAND, 0x10, prot_ret);
  			return illegal_condition_result;
  		}
  	}
  
++<<<<<<< HEAD
 +	ret = do_device_access(scp, 0, lba, num, false);
 +	read_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 	ret = do_device_access(sip, scp, 0, lba, num, false);
+ 	read_unlock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  	if (unlikely(ret == -1))
  		return DID_ERROR << 16;
  
@@@ -2969,13 -3045,14 +2992,21 @@@ static void unmap_region(sector_t lba, 
  
  static int resp_write_dt0(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)
  {
 -	bool check_prot;
 +	u8 *cmd = scp->cmnd;
 +	u64 lba;
  	u32 num;
  	u32 ei_lba;
++<<<<<<< HEAD
 +	unsigned long iflags;
 +	int ret;
 +	bool check_prot;
++=======
+ 	int ret;
+ 	u64 lba;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
+ 	u8 *cmd = scp->cmnd;
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  
  	switch (cmd[0]) {
  	case WRITE_16:
@@@ -3031,23 -3108,23 +3062,36 @@@
  	ret = check_device_access_params(scp, lba, num, true);
  	if (ret)
  		return ret;
++<<<<<<< HEAD
 +	write_lock_irqsave(&atomic_rw, iflags);
++=======
+ 	write_lock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  
  	/* DIX + T10 DIF */
  	if (unlikely(sdebug_dix && scsi_prot_sg_count(scp))) {
  		int prot_ret = prot_verify_write(scp, lba, num, ei_lba);
  
  		if (prot_ret) {
++<<<<<<< HEAD
 +			write_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 			write_unlock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  			mk_sense_buffer(scp, ILLEGAL_REQUEST, 0x10, prot_ret);
  			return illegal_condition_result;
  		}
  	}
  
 -	ret = do_device_access(sip, scp, 0, lba, num, true);
 +	ret = do_device_access(scp, 0, lba, num, true);
  	if (unlikely(scsi_debug_lbp()))
++<<<<<<< HEAD
 +		map_region(lba, num);
 +	write_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 		map_region(sip, lba, num);
+ 	write_unlock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  	if (unlikely(-1 == ret))
  		return DID_ERROR << 16;
  	else if (unlikely(sdebug_verbose &&
@@@ -3156,7 -3234,7 +3199,11 @@@ static int resp_write_scat(struct scsi_
  		goto err_out;
  	}
  
++<<<<<<< HEAD
 +	write_lock_irqsave(&atomic_rw, iflags);
++=======
+ 	write_lock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  	sg_off = lbdof_blen;
  	/* Spec says Buffer xfer Length field in number of LBs in dout */
  	cum_lb = 0;
@@@ -3239,7 -3317,7 +3286,11 @@@
  	}
  	ret = 0;
  err_out_unlock:
++<<<<<<< HEAD
 +	write_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 	write_unlock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  err_out:
  	kfree(lrdp);
  	return ret;
@@@ -3248,21 -3326,24 +3299,28 @@@
  static int resp_write_same(struct scsi_cmnd *scp, u64 lba, u32 num,
  			   u32 ei_lba, bool unmap, bool ndob)
  {
++<<<<<<< HEAD
 +	int ret;
 +	unsigned long iflags;
++=======
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  	unsigned long long i;
 -	u64 block, lbaa;
  	u32 lb_size = sdebug_sector_size;
 -	int ret;
 -	struct sdeb_store_info *sip = devip2sip((struct sdebug_dev_info *)
 -						scp->device->hostdata);
 -	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
 +	u64 block, lbaa;
  	u8 *fs1p;
 -	u8 *fsp;
  
  	ret = check_device_access_params(scp, lba, num, true);
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	write_lock_irqsave(&atomic_rw, iflags);
++=======
+ 	write_lock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  
  	if (unmap && scsi_debug_lbp()) {
 -		unmap_region(sip, lba, num);
 +		unmap_region(lba, num);
  		goto out;
  	}
  	lbaa = lba;
@@@ -3276,7 -3358,7 +3334,11 @@@
  		ret = fetch_to_dev_buffer(scp, fs1p, lb_size);
  
  	if (-1 == ret) {
++<<<<<<< HEAD
 +		write_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 		write_unlock(&sip->macc_lck);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  		return DID_ERROR << 16;
  	} else if (sdebug_verbose && !ndob && (ret < lb_size))
  		sdev_printk(KERN_INFO, scp->device,
@@@ -3287,12 -3369,12 +3349,16 @@@
  	for (i = 1 ; i < num ; i++) {
  		lbaa = lba + i;
  		block = do_div(lbaa, sdebug_store_sectors);
 -		memmove(fsp + (block * lb_size), fs1p, lb_size);
 +		memmove(fake_storep + (block * lb_size), fs1p, lb_size);
  	}
  	if (scsi_debug_lbp())
 -		map_region(sip, lba, num);
 +		map_region(lba, num);
  out:
++<<<<<<< HEAD
 +	write_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 	write_unlock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  
  	return 0;
  }
@@@ -3438,14 -3520,9 +3503,18 @@@ static int resp_comp_write(struct scsi_
  		return check_condition_result;
  	}
  
++<<<<<<< HEAD
 +	write_lock_irqsave(&atomic_rw, iflags);
++=======
+ 	write_lock(macc_lckp);
 -
 -	ret = do_dout_fetch(scp, dnum, arr);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
 +
 +	/* trick do_device_access() to fetch both compare and write buffers
 +	 * from data-in into arr. Safe (atomic) since write_lock held. */
 +	fake_storep_hold = fake_storep;
 +	fake_storep = arr;
 +	ret = do_device_access(scp, 0, 0, dnum, true);
 +	fake_storep = fake_storep_hold;
  	if (ret == -1) {
  		retval = DID_ERROR << 16;
  		goto cleanup;
@@@ -3459,9 -3536,9 +3528,13 @@@
  		goto cleanup;
  	}
  	if (scsi_debug_lbp())
 -		map_region(sip, lba, num);
 +		map_region(lba, num);
  cleanup:
++<<<<<<< HEAD
 +	write_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 	write_unlock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  	kfree(arr);
  	return retval;
  }
@@@ -3476,10 -3553,10 +3549,8 @@@ static int resp_unmap(struct scsi_cmnd 
  {
  	unsigned char *buf;
  	struct unmap_block_desc *desc;
 -	struct sdeb_store_info *sip = devip2sip(devip);
 -	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
  	unsigned int i, payload_len, descriptors;
  	int ret;
- 	unsigned long iflags;
- 
  
  	if (!scsi_debug_lbp())
  		return 0;	/* fib and say its done */
@@@ -3506,7 -3583,7 +3577,11 @@@
  
  	desc = (void *)&buf[8];
  
++<<<<<<< HEAD
 +	write_lock_irqsave(&atomic_rw, iflags);
++=======
+ 	write_lock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  
  	for (i = 0 ; i < descriptors ; i++) {
  		unsigned long long lba = get_unaligned_be64(&desc[i].lba);
@@@ -3522,7 -3599,7 +3597,11 @@@
  	ret = 0;
  
  out:
++<<<<<<< HEAD
 +	write_unlock_irqrestore(&atomic_rw, iflags);
++=======
+ 	write_unlock(macc_lckp);
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  	kfree(buf);
  
  	return ret;
@@@ -3697,6 -3775,81 +3776,84 @@@ static int resp_report_luns(struct scsi
  	return res;
  }
  
++<<<<<<< HEAD
++=======
+ static int resp_verify(struct scsi_cmnd *scp, struct sdebug_dev_info *devip)
+ {
+ 	bool is_bytchk3 = false;
+ 	u8 bytchk;
+ 	int ret, j;
+ 	u32 vnum, a_num, off;
+ 	const u32 lb_size = sdebug_sector_size;
+ 	u64 lba;
+ 	u8 *arr;
+ 	u8 *cmd = scp->cmnd;
+ 	struct sdeb_store_info *sip = devip2sip(devip);
+ 	rwlock_t *macc_lckp = sip ? &sip->macc_lck : &sdeb_fake_rw_lck;
+ 
+ 	bytchk = (cmd[1] >> 1) & 0x3;
+ 	if (bytchk == 0) {
+ 		return 0;	/* always claim internal verify okay */
+ 	} else if (bytchk == 2) {
+ 		mk_sense_invalid_fld(scp, SDEB_IN_CDB, 2, 2);
+ 		return check_condition_result;
+ 	} else if (bytchk == 3) {
+ 		is_bytchk3 = true;	/* 1 block sent, compared repeatedly */
+ 	}
+ 	switch (cmd[0]) {
+ 	case VERIFY_16:
+ 		lba = get_unaligned_be64(cmd + 2);
+ 		vnum = get_unaligned_be32(cmd + 10);
+ 		break;
+ 	case VERIFY:		/* is VERIFY(10) */
+ 		lba = get_unaligned_be32(cmd + 2);
+ 		vnum = get_unaligned_be16(cmd + 7);
+ 		break;
+ 	default:
+ 		mk_sense_invalid_opcode(scp);
+ 		return check_condition_result;
+ 	}
+ 	a_num = is_bytchk3 ? 1 : vnum;
+ 	/* Treat following check like one for read (i.e. no write) access */
+ 	ret = check_device_access_params(scp, lba, a_num, false);
+ 	if (ret)
+ 		return ret;
+ 
+ 	arr = kcalloc(lb_size, vnum, GFP_ATOMIC);
+ 	if (!arr) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,
+ 				INSUFF_RES_ASCQ);
+ 		return check_condition_result;
+ 	}
+ 	/* Not changing store, so only need read access */
+ 	read_lock(macc_lckp);
+ 
+ 	ret = do_dout_fetch(scp, a_num, arr);
+ 	if (ret == -1) {
+ 		ret = DID_ERROR << 16;
+ 		goto cleanup;
+ 	} else if (sdebug_verbose && (ret < (a_num * lb_size))) {
+ 		sdev_printk(KERN_INFO, scp->device,
+ 			    "%s: %s: cdb indicated=%u, IO sent=%d bytes\n",
+ 			    my_name, __func__, a_num * lb_size, ret);
+ 	}
+ 	if (is_bytchk3) {
+ 		for (j = 1, off = lb_size; j < vnum; ++j, off += lb_size)
+ 			memcpy(arr + off, arr, lb_size);
+ 	}
+ 	ret = 0;
+ 	if (!comp_write_worker(sip, lba, vnum, arr, true)) {
+ 		mk_sense_buffer(scp, MISCOMPARE, MISCOMPARE_VERIFY_ASC, 0);
+ 		ret = check_condition_result;
+ 		goto cleanup;
+ 	}
+ cleanup:
+ 	read_unlock(macc_lckp);
+ 	kfree(arr);
+ 	return ret;
+ }
+ 
++>>>>>>> 67da413f26af (scsi: scsi_debug: Weaken rwlock around ramdisk access)
  static struct sdebug_queue *get_queue(struct scsi_cmnd *cmnd)
  {
  	u32 tag = blk_mq_unique_tag(cmnd->request);
* Unmerged path drivers/scsi/scsi_debug.c
