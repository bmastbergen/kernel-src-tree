ASoC: soc-pcm: move CONFIG_DEBUG_FS functions to top side

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: soc-pcm: move CONFIG_DEBUG_FS functions to top side (Jaroslav Kysela) [1869536]
Rebuild_FUZZ: 95.00%
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit c3212829f812a4ac0c6078978c109c6f1ff882c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c3212829.failed

This is prepare for CONFIG_DEBUG_FS cleanup

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Link: https://lore.kernel.org/r/878skzjc9k.wl-kuninori.morimoto.gx@renesas.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit c3212829f812a4ac0c6078978c109c6f1ff882c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/soc-pcm.c
diff --cc sound/soc/soc-pcm.c
index f3af956b9680,fc98ab87fa45..000000000000
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@@ -2944,153 -3068,3 +3082,156 @@@ int snd_soc_dpcm_can_be_params(struct s
  	return snd_soc_dpcm_check_state(fe, be, stream, state, ARRAY_SIZE(state));
  }
  EXPORT_SYMBOL_GPL(snd_soc_dpcm_can_be_params);
++<<<<<<< HEAD
 +
 +#ifdef CONFIG_DEBUG_FS
 +static const char *dpcm_state_string(enum snd_soc_dpcm_state state)
 +{
 +	switch (state) {
 +	case SND_SOC_DPCM_STATE_NEW:
 +		return "new";
 +	case SND_SOC_DPCM_STATE_OPEN:
 +		return "open";
 +	case SND_SOC_DPCM_STATE_HW_PARAMS:
 +		return "hw_params";
 +	case SND_SOC_DPCM_STATE_PREPARE:
 +		return "prepare";
 +	case SND_SOC_DPCM_STATE_START:
 +		return "start";
 +	case SND_SOC_DPCM_STATE_STOP:
 +		return "stop";
 +	case SND_SOC_DPCM_STATE_SUSPEND:
 +		return "suspend";
 +	case SND_SOC_DPCM_STATE_PAUSED:
 +		return "paused";
 +	case SND_SOC_DPCM_STATE_HW_FREE:
 +		return "hw_free";
 +	case SND_SOC_DPCM_STATE_CLOSE:
 +		return "close";
 +	}
 +
 +	return "unknown";
 +}
 +
 +static ssize_t dpcm_show_state(struct snd_soc_pcm_runtime *fe,
 +				int stream, char *buf, size_t size)
 +{
 +	struct snd_pcm_hw_params *params = &fe->dpcm[stream].hw_params;
 +	struct snd_soc_dpcm *dpcm;
 +	ssize_t offset = 0;
 +	unsigned long flags;
 +
 +	/* FE state */
 +	offset += scnprintf(buf + offset, size - offset,
 +			"[%s - %s]\n", fe->dai_link->name,
 +			stream ? "Capture" : "Playback");
 +
 +	offset += scnprintf(buf + offset, size - offset, "State: %s\n",
 +	                dpcm_state_string(fe->dpcm[stream].state));
 +
 +	if ((fe->dpcm[stream].state >= SND_SOC_DPCM_STATE_HW_PARAMS) &&
 +	    (fe->dpcm[stream].state <= SND_SOC_DPCM_STATE_STOP))
 +		offset += scnprintf(buf + offset, size - offset,
 +				"Hardware Params: "
 +				"Format = %s, Channels = %d, Rate = %d\n",
 +				snd_pcm_format_name(params_format(params)),
 +				params_channels(params),
 +				params_rate(params));
 +
 +	/* BEs state */
 +	offset += scnprintf(buf + offset, size - offset, "Backends:\n");
 +
 +	if (list_empty(&fe->dpcm[stream].be_clients)) {
 +		offset += scnprintf(buf + offset, size - offset,
 +				" No active DSP links\n");
 +		goto out;
 +	}
 +
 +	spin_lock_irqsave(&fe->card->dpcm_lock, flags);
 +	for_each_dpcm_be(fe, stream, dpcm) {
 +		struct snd_soc_pcm_runtime *be = dpcm->be;
 +		params = &dpcm->hw_params;
 +
 +		offset += scnprintf(buf + offset, size - offset,
 +				"- %s\n", be->dai_link->name);
 +
 +		offset += scnprintf(buf + offset, size - offset,
 +				"   State: %s\n",
 +				dpcm_state_string(be->dpcm[stream].state));
 +
 +		if ((be->dpcm[stream].state >= SND_SOC_DPCM_STATE_HW_PARAMS) &&
 +		    (be->dpcm[stream].state <= SND_SOC_DPCM_STATE_STOP))
 +			offset += scnprintf(buf + offset, size - offset,
 +				"   Hardware Params: "
 +				"Format = %s, Channels = %d, Rate = %d\n",
 +				snd_pcm_format_name(params_format(params)),
 +				params_channels(params),
 +				params_rate(params));
 +	}
 +	spin_unlock_irqrestore(&fe->card->dpcm_lock, flags);
 +out:
 +	return offset;
 +}
 +
 +static ssize_t dpcm_state_read_file(struct file *file, char __user *user_buf,
 +				size_t count, loff_t *ppos)
 +{
 +	struct snd_soc_pcm_runtime *fe = file->private_data;
 +	ssize_t out_count = PAGE_SIZE, offset = 0, ret = 0;
 +	int stream;
 +	char *buf;
 +
 +	if (fe->num_cpus > 1) {
 +		dev_err(fe->dev,
 +			"%s doesn't support Multi CPU yet\n", __func__);
 +		return -EINVAL;
 +	}
 +
 +	buf = kmalloc(out_count, GFP_KERNEL);
 +	if (!buf)
 +		return -ENOMEM;
 +
 +	for_each_pcm_streams(stream)
 +		if (snd_soc_dai_stream_valid(fe->cpu_dai, stream))
 +			offset += dpcm_show_state(fe, stream,
 +						  buf + offset,
 +						  out_count - offset);
 +
 +	ret = simple_read_from_buffer(user_buf, count, ppos, buf, offset);
 +
 +	kfree(buf);
 +	return ret;
 +}
 +
 +static const struct file_operations dpcm_state_fops = {
 +	.open = simple_open,
 +	.read = dpcm_state_read_file,
 +	.llseek = default_llseek,
 +};
 +
 +void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd)
 +{
 +	if (!rtd->dai_link)
 +		return;
 +
 +	if (!rtd->dai_link->dynamic)
 +		return;
 +
 +	if (!rtd->card->debugfs_card_root)
 +		return;
 +
 +	rtd->debugfs_dpcm_root = debugfs_create_dir(rtd->dai_link->name,
 +			rtd->card->debugfs_card_root);
 +	if (!rtd->debugfs_dpcm_root) {
 +		dev_dbg(rtd->dev,
 +			 "ASoC: Failed to create dpcm debugfs directory %s\n",
 +			 rtd->dai_link->name);
 +		return;
 +	}
 +
 +	debugfs_create_file("state", 0444, rtd->debugfs_dpcm_root,
 +			    rtd, &dpcm_state_fops);
 +}
 +#endif
++=======
++>>>>>>> c3212829f812 (ASoC: soc-pcm: move CONFIG_DEBUG_FS functions to top side)
* Unmerged path sound/soc/soc-pcm.c
