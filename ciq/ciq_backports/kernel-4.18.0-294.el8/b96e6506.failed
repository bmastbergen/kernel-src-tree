KVM: x86: VMX: Make smaller physical guest address space support user-configurable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mohammed Gamal <mgamal@redhat.com>
commit b96e6506c2ea7c8e3ef0860169b6d0ba2f1aca9f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b96e6506.failed

This patch exposes allow_smaller_maxphyaddr to the user as a module parameter.
Since smaller physical address spaces are only supported on VMX, the
parameter is only exposed in the kvm_intel module.

For now disable support by default, and let the user decide if they want
to enable it.

Modifications to VMX page fault and EPT violation handling will depend
on whether that parameter is enabled.

	Signed-off-by: Mohammed Gamal <mgamal@redhat.com>
Message-Id: <20200903141122.72908-1-mgamal@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b96e6506c2ea7c8e3ef0860169b6d0ba2f1aca9f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/vmx/vmx.h
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 2bf785d60539,f0384e93548a..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -4796,9 -4801,16 +4799,22 @@@ static int handle_exception_nmi(struct 
  
  	if (is_page_fault(intr_info)) {
  		cr2 = vmx_get_exit_qual(vcpu);
++<<<<<<< HEAD
 +		/* EPT won't cause page fault directly */
 +		WARN_ON_ONCE(!vcpu->arch.apf.host_apf_reason && enable_ept);
 +		return kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0);
++=======
+ 		if (enable_ept && !vcpu->arch.apf.host_apf_flags) {
+ 			/*
+ 			 * EPT will cause page fault only if we need to
+ 			 * detect illegal GPAs.
+ 			 */
+ 			WARN_ON_ONCE(!allow_smaller_maxphyaddr);
+ 			kvm_fixup_and_inject_pf_error(vcpu, cr2, error_code);
+ 			return 1;
+ 		} else
+ 			return kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0);
++>>>>>>> b96e6506c2ea (KVM: x86: VMX: Make smaller physical guest address space support user-configurable)
  	}
  
  	ex_no = intr_info & INTR_INFO_VECTOR_MASK;
@@@ -5314,6 -5326,18 +5330,21 @@@ static int handle_ept_violation(struct 
  	       PFERR_GUEST_FINAL_MASK : PFERR_GUEST_PAGE_MASK;
  
  	vcpu->arch.exit_qualification = exit_qualification;
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Check that the GPA doesn't exceed physical memory limits, as that is
+ 	 * a guest page fault.  We have to emulate the instruction here, because
+ 	 * if the illegal address is that of a paging structure, then
+ 	 * EPT_VIOLATION_ACC_WRITE bit is set.  Alternatively, if supported we
+ 	 * would also use advanced VM-exit information for EPT violations to
+ 	 * reconstruct the page fault error code.
+ 	 */
+ 	if (unlikely(allow_smaller_maxphyaddr && kvm_mmu_is_illegal_gpa(vcpu, gpa)))
+ 		return kvm_emulate_instruction(vcpu, 0);
+ 
++>>>>>>> b96e6506c2ea (KVM: x86: VMX: Make smaller physical guest address space support user-configurable)
  	return kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);
  }
  
@@@ -8243,6 -8308,14 +8274,17 @@@ static int __init vmx_init(void
  #endif
  	vmx_check_vmcs12_offsets();
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Shadow paging doesn't have a (further) performance penalty
+ 	 * from GUEST_MAXPHYADDR < HOST_MAXPHYADDR so enable it
+ 	 * by default
+ 	 */
+ 	if (!enable_ept)
+ 		allow_smaller_maxphyaddr = true;
+ 
++>>>>>>> b96e6506c2ea (KVM: x86: VMX: Make smaller physical guest address space support user-configurable)
  	return 0;
  }
  module_init(vmx_init);
diff --cc arch/x86/kvm/vmx/vmx.h
index 6cb033e3bb90,a0e47720f60c..000000000000
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@@ -554,7 -552,10 +554,14 @@@ static inline bool vmx_has_waitpkg(stru
  
  static inline bool vmx_need_pf_intercept(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	return !enable_ept;
++=======
+ 	if (!enable_ept)
+ 		return true;
+ 
+ 	return allow_smaller_maxphyaddr && cpuid_maxphyaddr(vcpu) < boot_cpu_data.x86_phys_bits;
++>>>>>>> b96e6506c2ea (KVM: x86: VMX: Make smaller physical guest address space support user-configurable)
  }
  
  void dump_vmcs(void);
diff --cc arch/x86/kvm/x86.c
index b438f29501f9,67362607e396..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -187,6 -188,9 +187,12 @@@ static struct kvm_shared_msrs __percpu 
  u64 __read_mostly host_efer;
  EXPORT_SYMBOL_GPL(host_efer);
  
++<<<<<<< HEAD
++=======
+ bool __read_mostly allow_smaller_maxphyaddr = 0;
+ EXPORT_SYMBOL_GPL(allow_smaller_maxphyaddr);
+ 
++>>>>>>> b96e6506c2ea (KVM: x86: VMX: Make smaller physical guest address space support user-configurable)
  static u64 __read_mostly host_xss;
  u64 __read_mostly supported_xss;
  EXPORT_SYMBOL_GPL(supported_xss);
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
* Unmerged path arch/x86/kvm/x86.c
