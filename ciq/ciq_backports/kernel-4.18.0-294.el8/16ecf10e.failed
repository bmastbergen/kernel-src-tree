iommu/vt-d: Set U/S bit in first level page table by default

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 16ecf10e815d70d11d2300243f4a3b4c7c5acac7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/16ecf10e.failed

When using first-level translation for IOVA, currently the U/S bit in the
page table is cleared which implies DMA requests with user privilege are
blocked. As the result, following error messages might be observed when
passing through a device to user level:

DMAR: DRHD: handling fault status reg 3
DMAR: [DMA Read] Request device [41:00.0] PASID 1 fault addr 7ecdcd000
        [fault reason 129] SM: U/S set 0 for first-level translation
        with user privilege

This fixes it by setting U/S bit in the first level page table and makes
IOVA over first level compatible with previous second-level translation.

Fixes: b802d070a52a1 ("iommu/vt-d: Use iova over first level")
	Reported-by: Xin Zeng <xin.zeng@intel.com>
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
Link: https://lore.kernel.org/r/20200622231345.29722-3-baolu.lu@linux.intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 16ecf10e815d70d11d2300243f4a3b4c7c5acac7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
#	include/linux/intel-iommu.h
diff --cc drivers/iommu/intel-iommu.c
index 02b3f6e666d0,0fa394f7bbf9..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -948,6 -920,8 +948,11 @@@ static struct dma_pte *pfn_to_dma_pte(s
  
  			domain_flush_cache(domain, tmp_page, VTD_PAGE_SIZE);
  			pteval = ((uint64_t)virt_to_dma_pfn(tmp_page) << VTD_PAGE_SHIFT) | DMA_PTE_READ | DMA_PTE_WRITE;
++<<<<<<< HEAD:drivers/iommu/intel-iommu.c
++=======
+ 			if (domain_use_first_level(domain))
+ 				pteval |= DMA_FL_PTE_XD | DMA_FL_PTE_US;
++>>>>>>> 16ecf10e815d (iommu/vt-d: Set U/S bit in first level page table by default):drivers/iommu/intel/iommu.c
  			if (cmpxchg64(&pte->val, 0ULL, pteval))
  				/* Someone else set it while we were thinking; use theirs. */
  				free_pgtable_page(tmp_page);
@@@ -2270,7 -2240,9 +2274,13 @@@ static int __domain_mapping(struct dmar
  	if ((prot & (DMA_PTE_READ|DMA_PTE_WRITE)) == 0)
  		return -EINVAL;
  
++<<<<<<< HEAD:drivers/iommu/intel-iommu.c
 +	prot &= DMA_PTE_READ | DMA_PTE_WRITE | DMA_PTE_SNP;
++=======
+ 	attr = prot & (DMA_PTE_READ | DMA_PTE_WRITE | DMA_PTE_SNP);
+ 	if (domain_use_first_level(domain))
+ 		attr |= DMA_FL_PTE_PRESENT | DMA_FL_PTE_XD | DMA_FL_PTE_US;
++>>>>>>> 16ecf10e815d (iommu/vt-d: Set U/S bit in first level page table by default):drivers/iommu/intel/iommu.c
  
  	if (!sg) {
  		sg_res = nr_pages;
diff --cc include/linux/intel-iommu.h
index 5ad0f1f3c04d,3e8fa1c7a1e6..000000000000
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@@ -47,10 -35,17 +47,24 @@@
  #define VTD_STRIDE_SHIFT        (9)
  #define VTD_STRIDE_MASK         (((u64)-1) << VTD_STRIDE_SHIFT)
  
++<<<<<<< HEAD
 +#define DMA_PTE_READ (1)
 +#define DMA_PTE_WRITE (2)
 +#define DMA_PTE_LARGE_PAGE (1 << 7)
 +#define DMA_PTE_SNP (1 << 11)
++=======
+ #define DMA_PTE_READ		BIT_ULL(0)
+ #define DMA_PTE_WRITE		BIT_ULL(1)
+ #define DMA_PTE_LARGE_PAGE	BIT_ULL(7)
+ #define DMA_PTE_SNP		BIT_ULL(11)
+ 
+ #define DMA_FL_PTE_PRESENT	BIT_ULL(0)
+ #define DMA_FL_PTE_US		BIT_ULL(2)
+ #define DMA_FL_PTE_XD		BIT_ULL(63)
+ 
+ #define ADDR_WIDTH_5LEVEL	(57)
+ #define ADDR_WIDTH_4LEVEL	(48)
++>>>>>>> 16ecf10e815d (iommu/vt-d: Set U/S bit in first level page table by default)
  
  #define CONTEXT_TT_MULTI_LEVEL	0
  #define CONTEXT_TT_DEV_IOTLB	1
* Unmerged path drivers/iommu/intel-iommu.c
* Unmerged path include/linux/intel-iommu.h
