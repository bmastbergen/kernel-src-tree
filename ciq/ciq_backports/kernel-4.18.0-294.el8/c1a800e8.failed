geneve: Support for PMTU discovery on directly bridged links

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Stefano Brivio <sbrivio@redhat.com>
commit c1a800e88dbffca4ef48000cb3f9ad618dc7ad89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c1a800e8.failed

If the interface is a bridge or Open vSwitch port, and we can't
forward a packet because it exceeds the local PMTU estimate,
trigger an ICMP or ICMPv6 reply to the sender, using the same
interface to forward it back.

If metadata collection is enabled, set destination and source
addresses for the flow as if we were receiving the packet, so that
Open vSwitch can match the ICMP error against the existing
association.

v2: Use netif_is_any_bridge_port() (David Ahern)

	Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c1a800e88dbffca4ef48000cb3f9ad618dc7ad89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index d1f98c5cf613,c71f994fbc73..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -892,11 -893,34 +892,39 @@@ static int geneve_xmit_skb(struct sk_bu
  	if (IS_ERR(rt))
  		return PTR_ERR(rt);
  
++<<<<<<< HEAD
 +	skb_tunnel_check_pmtu(skb, &rt->dst,
 +			      GENEVE_IPV4_HLEN + info->options_len);
++=======
+ 	err = skb_tunnel_check_pmtu(skb, &rt->dst,
+ 				    GENEVE_IPV4_HLEN + info->options_len,
+ 				    netif_is_any_bridge_port(dev));
+ 	if (err < 0) {
+ 		dst_release(&rt->dst);
+ 		return err;
+ 	} else if (err) {
+ 		struct ip_tunnel_info *info;
+ 
+ 		info = skb_tunnel_info(skb);
+ 		if (info) {
+ 			info->key.u.ipv4.dst = fl4.saddr;
+ 			info->key.u.ipv4.src = fl4.daddr;
+ 		}
+ 
+ 		if (!pskb_may_pull(skb, ETH_HLEN)) {
+ 			dst_release(&rt->dst);
+ 			return -EINVAL;
+ 		}
+ 
+ 		skb->protocol = eth_type_trans(skb, geneve->dev);
+ 		netif_rx(skb);
+ 		dst_release(&rt->dst);
+ 		return -EMSGSIZE;
+ 	}
++>>>>>>> c1a800e88dbf (geneve: Support for PMTU discovery on directly bridged links)
  
  	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
 -	if (geneve->cfg.collect_md) {
 +	if (geneve->collect_md) {
  		tos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
  		ttl = key->ttl;
  
@@@ -954,10 -978,33 +982,37 @@@ static int geneve6_xmit_skb(struct sk_b
  	if (IS_ERR(dst))
  		return PTR_ERR(dst);
  
++<<<<<<< HEAD
 +	skb_tunnel_check_pmtu(skb, dst, GENEVE_IPV6_HLEN + info->options_len);
++=======
+ 	err = skb_tunnel_check_pmtu(skb, dst,
+ 				    GENEVE_IPV6_HLEN + info->options_len,
+ 				    netif_is_any_bridge_port(dev));
+ 	if (err < 0) {
+ 		dst_release(dst);
+ 		return err;
+ 	} else if (err) {
+ 		struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 
+ 		if (info) {
+ 			info->key.u.ipv6.dst = fl6.saddr;
+ 			info->key.u.ipv6.src = fl6.daddr;
+ 		}
+ 
+ 		if (!pskb_may_pull(skb, ETH_HLEN)) {
+ 			dst_release(dst);
+ 			return -EINVAL;
+ 		}
+ 
+ 		skb->protocol = eth_type_trans(skb, geneve->dev);
+ 		netif_rx(skb);
+ 		dst_release(dst);
+ 		return -EMSGSIZE;
+ 	}
++>>>>>>> c1a800e88dbf (geneve: Support for PMTU discovery on directly bridged links)
  
  	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
 -	if (geneve->cfg.collect_md) {
 +	if (geneve->collect_md) {
  		prio = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
  		ttl = key->ttl;
  	} else {
* Unmerged path drivers/net/geneve.c
