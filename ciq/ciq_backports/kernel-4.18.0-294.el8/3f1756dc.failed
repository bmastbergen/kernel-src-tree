tracing: More reverting of "tracing: Centralize preemptirq tracepoints and unify their usage"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Steven Rostedt (VMware) <rostedt@goodmis.org>
commit 3f1756dc210e5abb37121da3e7c10d65920f6ec0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3f1756dc.failed

Joel Fernandes created a nice patch that cleaned up the duplicate hooks used
by lockdep and irqsoff latency tracer. It made both use tracepoints. But the
latency tracer is triggering warnings when using tracepoints to call into
the latency tracer's routines. Mainly, they can be called from NMI context.
If that happens, then the SRCU may not work properly because on some
architectures, SRCU is not safe to be called in both NMI and non-NMI
context.

This is a partial revert of the clean up patch c3bc8fd637a9 ("tracing:
Centralize preemptirq tracepoints and unify their usage") that adds back the
direct calls into the latency tracer. It also only calls the trace events
when not in NMI.

Link: http://lkml.kernel.org/r/20180809210654.622445925@goodmis.org
	Reviewed-by: Joel Fernandes (Google) <joel@joelfernandes.org>
Fixes: c3bc8fd637a9 ("tracing: Centralize preemptirq tracepoints and unify their usage")
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 3f1756dc210e5abb37121da3e7c10d65920f6ec0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_irqsoff.c
#	kernel/trace/trace_preemptirq.c
diff --cc kernel/trace/trace_irqsoff.c
index f8daa754cce2,94c1ba139b3b..000000000000
--- a/kernel/trace/trace_irqsoff.c
+++ b/kernel/trace/trace_irqsoff.c
@@@ -659,6 -602,25 +659,28 @@@ static void irqsoff_tracer_stop(struct 
  }
  
  #ifdef CONFIG_IRQSOFF_TRACER
++<<<<<<< HEAD
++=======
+ /*
+  * We are only interested in hardirq on/off events:
+  */
+ void tracer_hardirqs_on(unsigned long a0, unsigned long a1)
+ {
+ 	unsigned int pc = preempt_count();
+ 
+ 	if (!preempt_trace(pc) && irq_trace())
+ 		stop_critical_timing(a0, a1, pc);
+ }
+ 
+ void tracer_hardirqs_off(unsigned long a0, unsigned long a1)
+ {
+ 	unsigned int pc = preempt_count();
+ 
+ 	if (!preempt_trace(pc) && irq_trace())
+ 		start_critical_timing(a0, a1, pc);
+ }
+ 
++>>>>>>> 3f1756dc210e (tracing: More reverting of "tracing: Centralize preemptirq tracepoints and unify their usage")
  static int irqsoff_tracer_init(struct trace_array *tr)
  {
  	trace_type = TRACER_IRQS_OFF;
@@@ -690,12 -652,25 +712,31 @@@ static struct tracer irqsoff_tracer __r
  	.allow_instances = true,
  	.use_max_tr	= true,
  };
 -#endif /*  CONFIG_IRQSOFF_TRACER */
 +# define register_irqsoff(trace) register_tracer(&trace)
 +#else
 +# define register_irqsoff(trace) do { } while (0)
 +#endif
  
  #ifdef CONFIG_PREEMPT_TRACER
++<<<<<<< HEAD
++=======
+ void tracer_preempt_on(unsigned long a0, unsigned long a1)
+ {
+ 	int pc = preempt_count();
+ 
+ 	if (preempt_trace(pc) && !irq_trace())
+ 		stop_critical_timing(a0, a1, pc);
+ }
+ 
+ void tracer_preempt_off(unsigned long a0, unsigned long a1)
+ {
+ 	int pc = preempt_count();
+ 
+ 	if (preempt_trace(pc) && !irq_trace())
+ 		start_critical_timing(a0, a1, pc);
+ }
+ 
++>>>>>>> 3f1756dc210e (tracing: More reverting of "tracing: Centralize preemptirq tracepoints and unify their usage")
  static int preemptoff_tracer_init(struct trace_array *tr)
  {
  	trace_type = TRACER_PREEMPT_OFF;
* Unmerged path kernel/trace/trace_preemptirq.c
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index ac5533d9bbcd..2a69cf1b7388 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -1825,6 +1825,21 @@ static inline int tracing_alloc_snapshot_instance(struct trace_array *tr)
 }
 #endif
 
+#ifdef CONFIG_PREEMPT_TRACER
+void tracer_preempt_on(unsigned long a0, unsigned long a1);
+void tracer_preempt_off(unsigned long a0, unsigned long a1);
+#else
+static inline void tracer_preempt_on(unsigned long a0, unsigned long a1) { }
+static inline void tracer_preempt_off(unsigned long a0, unsigned long a1) { }
+#endif
+#ifdef CONFIG_IRQSOFF_TRACER
+void tracer_hardirqs_on(unsigned long a0, unsigned long a1);
+void tracer_hardirqs_off(unsigned long a0, unsigned long a1);
+#else
+static inline void tracer_hardirqs_on(unsigned long a0, unsigned long a1) { }
+static inline void tracer_hardirqs_off(unsigned long a0, unsigned long a1) { }
+#endif
+
 extern struct trace_iterator *tracepoint_print_iter;
 
 #endif /* _LINUX_KERNEL_TRACE_H */
* Unmerged path kernel/trace/trace_irqsoff.c
* Unmerged path kernel/trace/trace_preemptirq.c
