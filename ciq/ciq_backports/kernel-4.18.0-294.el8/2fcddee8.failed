xfs: simplify parsing of allocsize mount option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 2fcddee8cd8fcce4cc5589a0344f40a28a6dd26f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2fcddee8.failed

Rework xfs_parseargs to fill out the default value and then parse the
option directly into the mount structure, similar to what we do for
other updates, and open code the now trivial updates based on on the
on-disk superblock directly into xfs_mountfs.

Note that this change rejects the allocsize=0 mount option that has been
documented as invalid for a long time instead of just ignoring it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 2fcddee8cd8fcce4cc5589a0344f40a28a6dd26f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index 7229faf8566c,3e5002d2a79e..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -226,10 -225,10 +226,15 @@@ xfs_parseargs
  				return -ENOMEM;
  			break;
  		case Opt_allocsize:
++<<<<<<< HEAD
 +		case Opt_biosize:
 +			if (suffix_kstrtoint(args, 10, &iosize))
++=======
+ 			if (suffix_kstrtoint(args, 10, &size))
++>>>>>>> 2fcddee8cd8f (xfs: simplify parsing of allocsize mount option)
  				return -EINVAL;
- 			iosizelog = ffs(iosize) - 1;
+ 			mp->m_allocsize_log = ffs(size) - 1;
+ 			mp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;
  			break;
  		case Opt_grpid:
  		case Opt_bsdgroups:
diff --git a/fs/xfs/xfs_mount.c b/fs/xfs/xfs_mount.c
index 5f3344242085..c9f47a0a335a 100644
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -478,30 +478,6 @@ xfs_update_alignment(
 	return 0;
 }
 
-/*
- * Set the default minimum read and write sizes unless
- * already specified in a mount option.
- * We use smaller I/O sizes when the file system
- * is being used for NFS service (wsync mount option).
- */
-STATIC void
-xfs_set_rw_sizes(xfs_mount_t *mp)
-{
-	xfs_sb_t	*sbp = &(mp->m_sb);
-	int		readio_log, writeio_log;
-
-	if (!(mp->m_flags & XFS_MOUNT_DFLT_IOSIZE))
-		writeio_log = XFS_WRITEIO_LOG_LARGE;
-	else
-		writeio_log = mp->m_allocsize_log;
-
-	if (sbp->sb_blocklog > writeio_log)
-		mp->m_allocsize_log = sbp->sb_blocklog;
-	} else
-		mp->m_allocsize_log = writeio_log;
-	mp->m_allocsize_blocks = 1 << (mp->m_allocsize_log - sbp->sb_blocklog);
-}
-
 /*
  * precalculate the low space thresholds for dynamic speculative preallocation.
  */
@@ -777,9 +753,12 @@ xfs_mountfs(
 		goto out_remove_errortag;
 
 	/*
-	 * Set the minimum read and write sizes
+	 * Update the preferred write size based on the information from the
+	 * on-disk superblock.
 	 */
-	xfs_set_rw_sizes(mp);
+	mp->m_allocsize_log =
+		max_t(uint32_t, sbp->sb_blocklog, mp->m_allocsize_log);
+	mp->m_allocsize_blocks = 1U << (mp->m_allocsize_log - sbp->sb_blocklog);
 
 	/* set the low space thresholds for dynamic preallocation */
 	xfs_set_low_space_thresholds(mp);
diff --git a/fs/xfs/xfs_mount.h b/fs/xfs/xfs_mount.h
index 109081c16a07..712dbb2039cd 100644
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@ -244,12 +244,6 @@ typedef struct xfs_mount {
 
 #define XFS_MOUNT_DAX		(1ULL << 62)	/* TEST ONLY! */
 
-
-/*
- * Default write size.
- */
-#define XFS_WRITEIO_LOG_LARGE	16
-
 /*
  * Max and min values for mount-option defined I/O
  * preallocation sizes.
* Unmerged path fs/xfs/xfs_super.c
