net: phy: bcm54140: fix less than zero comparison on an unsigned

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Colin Ian King <colin.king@canonical.com>
commit efcd549da9d7e8194b4d2d2f35eff8ce7b4da684
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/efcd549d.failed

Currently the unsigned variable tmp is being checked for an negative
error return from the call to bcm_phy_read_rdb and this can never
be true since tmp is unsigned.  Fix this by making tmp a plain int.

Addresses-Coverity: ("Unsigned compared against 0")
Fixes: 4406d36dfdf1 ("net: phy: bcm54140: add hwmon support")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Michael Walle <michael@walle.cc>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit efcd549da9d7e8194b4d2d2f35eff8ce7b4da684)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/bcm54140.c
diff --cc drivers/net/phy/bcm54140.c
index 0eeb60de67f8,7341f0126cc4..000000000000
--- a/drivers/net/phy/bcm54140.c
+++ b/drivers/net/phy/bcm54140.c
@@@ -57,8 -121,330 +57,327 @@@
  struct bcm54140_priv {
  	int port;
  	int base_addr;
 -#if IS_ENABLED(CONFIG_HWMON)
 -	bool pkg_init;
 -	/* protect the alarm bits */
 -	struct mutex alarm_lock;
 -	u16 alarm;
 -#endif
  };
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_HWMON)
+ static umode_t bcm54140_hwmon_is_visible(const void *data,
+ 					 enum hwmon_sensor_types type,
+ 					 u32 attr, int channel)
+ {
+ 	switch (type) {
+ 	case hwmon_in:
+ 		switch (attr) {
+ 		case hwmon_in_min:
+ 		case hwmon_in_max:
+ 			return 0644;
+ 		case hwmon_in_label:
+ 		case hwmon_in_input:
+ 		case hwmon_in_alarm:
+ 			return 0444;
+ 		default:
+ 			return 0;
+ 		}
+ 	case hwmon_temp:
+ 		switch (attr) {
+ 		case hwmon_temp_min:
+ 		case hwmon_temp_max:
+ 			return 0644;
+ 		case hwmon_temp_input:
+ 		case hwmon_temp_alarm:
+ 			return 0444;
+ 		default:
+ 			return 0;
+ 		}
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static int bcm54140_hwmon_read_alarm(struct device *dev, unsigned int bit,
+ 				     long *val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	struct bcm54140_priv *priv = phydev->priv;
+ 	int tmp, ret = 0;
+ 
+ 	mutex_lock(&priv->alarm_lock);
+ 
+ 	/* latch any alarm bits */
+ 	tmp = bcm_phy_read_rdb(phydev, BCM54140_RDB_MON_ISR);
+ 	if (tmp < 0) {
+ 		ret = tmp;
+ 		goto out;
+ 	}
+ 	priv->alarm |= tmp;
+ 
+ 	*val = !!(priv->alarm & bit);
+ 	priv->alarm &= ~bit;
+ 
+ out:
+ 	mutex_unlock(&priv->alarm_lock);
+ 	return ret;
+ }
+ 
+ static int bcm54140_hwmon_read_temp(struct device *dev, u32 attr, long *val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	u16 reg;
+ 	int tmp;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_input:
+ 		reg = BCM54140_RDB_MON_TEMP_VAL;
+ 		break;
+ 	case hwmon_temp_min:
+ 		reg = BCM54140_RDB_MON_TEMP_MIN;
+ 		break;
+ 	case hwmon_temp_max:
+ 		reg = BCM54140_RDB_MON_TEMP_MAX;
+ 		break;
+ 	case hwmon_temp_alarm:
+ 		return bcm54140_hwmon_read_alarm(dev,
+ 						 BCM54140_RDB_MON_ISR_TEMP,
+ 						 val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	tmp = bcm_phy_read_rdb(phydev, reg);
+ 	if (tmp < 0)
+ 		return tmp;
+ 
+ 	*val = BCM54140_HWMON_TO_TEMP(tmp & BCM54140_RDB_MON_TEMP_DATA_MASK);
+ 
+ 	return 0;
+ }
+ 
+ static int bcm54140_hwmon_read_in(struct device *dev, u32 attr,
+ 				  int channel, long *val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	u16 bit, reg;
+ 	int tmp;
+ 
+ 	switch (attr) {
+ 	case hwmon_in_input:
+ 		reg = BCM54140_HWMON_IN_VAL_REG(channel);
+ 		break;
+ 	case hwmon_in_min:
+ 		reg = BCM54140_HWMON_IN_MIN_REG(channel);
+ 		break;
+ 	case hwmon_in_max:
+ 		reg = BCM54140_HWMON_IN_MAX_REG(channel);
+ 		break;
+ 	case hwmon_in_alarm:
+ 		bit = BCM54140_HWMON_IN_ALARM_BIT(channel);
+ 		return bcm54140_hwmon_read_alarm(dev, bit, val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	tmp = bcm_phy_read_rdb(phydev, reg);
+ 	if (tmp < 0)
+ 		return tmp;
+ 
+ 	tmp &= BCM54140_HWMON_IN_MASK(channel);
+ 	*val = BCM54140_HWMON_TO_IN(channel, tmp);
+ 
+ 	return 0;
+ }
+ 
+ static int bcm54140_hwmon_read(struct device *dev,
+ 			       enum hwmon_sensor_types type, u32 attr,
+ 			       int channel, long *val)
+ {
+ 	switch (type) {
+ 	case hwmon_temp:
+ 		return bcm54140_hwmon_read_temp(dev, attr, val);
+ 	case hwmon_in:
+ 		return bcm54140_hwmon_read_in(dev, attr, channel, val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static const char *const bcm54140_hwmon_in_labels[] = {
+ 	"AVDDL",
+ 	"AVDDH",
+ };
+ 
+ static int bcm54140_hwmon_read_string(struct device *dev,
+ 				      enum hwmon_sensor_types type, u32 attr,
+ 				      int channel, const char **str)
+ {
+ 	switch (type) {
+ 	case hwmon_in:
+ 		switch (attr) {
+ 		case hwmon_in_label:
+ 			*str = bcm54140_hwmon_in_labels[channel];
+ 			return 0;
+ 		default:
+ 			return -EOPNOTSUPP;
+ 		}
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int bcm54140_hwmon_write_temp(struct device *dev, u32 attr,
+ 				     int channel, long val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	u16 mask = BCM54140_RDB_MON_TEMP_DATA_MASK;
+ 	u16 reg;
+ 
+ 	val = clamp_val(val, BCM54140_HWMON_TO_TEMP(mask),
+ 			BCM54140_HWMON_TO_TEMP(0));
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_min:
+ 		reg = BCM54140_RDB_MON_TEMP_MIN;
+ 		break;
+ 	case hwmon_temp_max:
+ 		reg = BCM54140_RDB_MON_TEMP_MAX;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return bcm_phy_modify_rdb(phydev, reg, mask,
+ 				  BCM54140_HWMON_FROM_TEMP(val));
+ }
+ 
+ static int bcm54140_hwmon_write_in(struct device *dev, u32 attr,
+ 				   int channel, long val)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	u16 mask = BCM54140_HWMON_IN_MASK(channel);
+ 	u16 reg;
+ 
+ 	val = clamp_val(val, 0, BCM54140_HWMON_TO_IN(channel, mask));
+ 
+ 	switch (attr) {
+ 	case hwmon_in_min:
+ 		reg = BCM54140_HWMON_IN_MIN_REG(channel);
+ 		break;
+ 	case hwmon_in_max:
+ 		reg = BCM54140_HWMON_IN_MAX_REG(channel);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return bcm_phy_modify_rdb(phydev, reg, mask,
+ 				  BCM54140_HWMON_FROM_IN(channel, val));
+ }
+ 
+ static int bcm54140_hwmon_write(struct device *dev,
+ 				enum hwmon_sensor_types type, u32 attr,
+ 				int channel, long val)
+ {
+ 	switch (type) {
+ 	case hwmon_temp:
+ 		return bcm54140_hwmon_write_temp(dev, attr, channel, val);
+ 	case hwmon_in:
+ 		return bcm54140_hwmon_write_in(dev, attr, channel, val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static const struct hwmon_channel_info *bcm54140_hwmon_info[] = {
+ 	HWMON_CHANNEL_INFO(temp,
+ 			   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |
+ 			   HWMON_T_ALARM),
+ 	HWMON_CHANNEL_INFO(in,
+ 			   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |
+ 			   HWMON_I_ALARM | HWMON_I_LABEL,
+ 			   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |
+ 			   HWMON_I_ALARM | HWMON_I_LABEL),
+ 	NULL
+ };
+ 
+ static const struct hwmon_ops bcm54140_hwmon_ops = {
+ 	.is_visible = bcm54140_hwmon_is_visible,
+ 	.read = bcm54140_hwmon_read,
+ 	.read_string = bcm54140_hwmon_read_string,
+ 	.write = bcm54140_hwmon_write,
+ };
+ 
+ static const struct hwmon_chip_info bcm54140_chip_info = {
+ 	.ops = &bcm54140_hwmon_ops,
+ 	.info = bcm54140_hwmon_info,
+ };
+ 
+ static int bcm54140_enable_monitoring(struct phy_device *phydev)
+ {
+ 	u16 mask, set;
+ 
+ 	/* 3.3V voltage mode */
+ 	set = BCM54140_RDB_MON_CTRL_V_MODE;
+ 
+ 	/* select round-robin */
+ 	mask = BCM54140_RDB_MON_CTRL_SEL_MASK;
+ 	set |= FIELD_PREP(BCM54140_RDB_MON_CTRL_SEL_MASK,
+ 			  BCM54140_RDB_MON_CTRL_SEL_RR);
+ 
+ 	/* remove power-down bit */
+ 	mask |= BCM54140_RDB_MON_CTRL_PWR_DOWN;
+ 
+ 	return bcm_phy_modify_rdb(phydev, BCM54140_RDB_MON_CTRL, mask, set);
+ }
+ 
+ /* Check if one PHY has already done the init of the parts common to all PHYs
+  * in the Quad PHY package.
+  */
+ static bool bcm54140_is_pkg_init(struct phy_device *phydev)
+ {
+ 	struct bcm54140_priv *priv = phydev->priv;
+ 	struct mii_bus *bus = phydev->mdio.bus;
+ 	int base_addr = priv->base_addr;
+ 	struct phy_device *phy;
+ 	int i;
+ 
+ 	/* Quad PHY */
+ 	for (i = 0; i < 4; i++) {
+ 		phy = mdiobus_get_phy(bus, base_addr + i);
+ 		if (!phy)
+ 			continue;
+ 
+ 		if ((phy->phy_id & phydev->drv->phy_id_mask) !=
+ 		    (phydev->drv->phy_id & phydev->drv->phy_id_mask))
+ 			continue;
+ 
+ 		priv = phy->priv;
+ 
+ 		if (priv && priv->pkg_init)
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static int bcm54140_probe_once(struct phy_device *phydev)
+ {
+ 	struct device *hwmon;
+ 	int ret;
+ 
+ 	/* enable hardware monitoring */
+ 	ret = bcm54140_enable_monitoring(phydev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	hwmon = devm_hwmon_device_register_with_info(&phydev->mdio.dev,
+ 						     "BCM54140", phydev,
+ 						     &bcm54140_chip_info,
+ 						     NULL);
+ 	return PTR_ERR_OR_ZERO(hwmon);
+ }
+ #endif
+ 
++>>>>>>> efcd549da9d7 (net: phy: bcm54140: fix less than zero comparison on an unsigned)
  static int bcm54140_base_read_rdb(struct phy_device *phydev, u16 rdb)
  {
  	struct bcm54140_priv *priv = phydev->priv;
* Unmerged path drivers/net/phy/bcm54140.c
