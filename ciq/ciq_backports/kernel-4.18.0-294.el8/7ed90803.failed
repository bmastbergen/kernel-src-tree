mptcp: send explicit ack on delayed ack_seq incr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 7ed90803a213736290bdcf971764ddb8ff3fa44f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7ed90803.failed

When the worker moves some bytes from the OoO queue into
the receive queue, the msk->ask_seq is updated, the MPTCP-level
ack carrying that value needs to wait the next ingress packet,
possibly slowing down or hanging the peer

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 7ed90803a213736290bdcf971764ddb8ff3fa44f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index d41791292d73,8df013daea88..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -284,9 -443,7 +298,13 @@@ static bool mptcp_check_data_fin(struc
  	 */
  
  	if (mptcp_pending_data_fin(sk, &rcv_data_fin_seq)) {
++<<<<<<< HEAD
 +		struct mptcp_subflow_context *subflow;
 +
 +		msk->ack_seq++;
++=======
+ 		WRITE_ONCE(msk->ack_seq, msk->ack_seq + 1);
++>>>>>>> 7ed90803a213 (mptcp: send explicit ack on delayed ack_seq incr)
  		WRITE_ONCE(msk->rcv_data_fin, 0);
  
  		sk->sk_shutdown |= RCV_SHUTDOWN;
@@@ -310,23 -466,12 +328,30 @@@
  			break;
  		}
  
+ 		ret = true;
  		mptcp_set_timeout(sk, NULL);
++<<<<<<< HEAD
 +		mptcp_for_each_subflow(msk, subflow) {
 +			struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
 +
 +			lock_sock(ssk);
 +			tcp_send_ack(ssk);
 +			release_sock(ssk);
 +		}
 +
 +		sk->sk_state_change(sk);
 +
 +		if (sk->sk_shutdown == SHUTDOWN_MASK ||
 +		    sk->sk_state == TCP_CLOSE)
 +			sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);
 +		else
 +			sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
++=======
+ 		mptcp_send_ack(msk);
+ 		mptcp_close_wake_up(sk);
++>>>>>>> 7ed90803a213 (mptcp: send explicit ack on delayed ack_seq incr)
  	}
+ 	return ret;
  }
  
  static bool __mptcp_move_skbs_from_subflow(struct mptcp_sock *msk,
@@@ -1227,7 -1553,12 +1252,16 @@@ static bool __mptcp_move_skbs(struct mp
  		unlock_sock_fast(ssk, slowpath);
  	} while (!done);
  
++<<<<<<< HEAD
 +	return moved > 0;
++=======
+ 	if (mptcp_ofo_queue(msk) || moved > 0) {
+ 		if (!mptcp_check_data_fin((struct sock *)msk))
+ 			mptcp_send_ack(msk);
+ 		return true;
+ 	}
+ 	return false;
++>>>>>>> 7ed90803a213 (mptcp: send explicit ack on delayed ack_seq incr)
  }
  
  static int mptcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
* Unmerged path net/mptcp/protocol.c
