net: phy: fix less than zero comparison with unsigned variable val

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Colin Ian King <colin.king@canonical.com>
commit 3a13f98b4c16fb3489bdfd7550fcaa333ee69850
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3a13f98b.failed

The unsigned variable val is being checked for an error by checking
if it is less than zero. This can never occur because val is unsigned.
Fix this by making val a plain int.

Addresses-Coverity: ("Unsigned compared against zero")
Fixes: bdbdac7649fa ("ethtool: provide UAPI for PHY master/slave configuration.")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3a13f98b4c16fb3489bdfd7550fcaa333ee69850)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy_device.c
diff --cc drivers/net/phy/phy_device.c
index edd049f1d9b6,c3a107cf578e..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -1775,6 -1913,90 +1775,93 @@@ int genphy_setup_forced(struct phy_devi
  }
  EXPORT_SYMBOL(genphy_setup_forced);
  
++<<<<<<< HEAD
++=======
+ static int genphy_setup_master_slave(struct phy_device *phydev)
+ {
+ 	u16 ctl = 0;
+ 
+ 	if (!phydev->is_gigabit_capable)
+ 		return 0;
+ 
+ 	switch (phydev->master_slave_set) {
+ 	case MASTER_SLAVE_CFG_MASTER_PREFERRED:
+ 		ctl |= CTL1000_PREFER_MASTER;
+ 		break;
+ 	case MASTER_SLAVE_CFG_SLAVE_PREFERRED:
+ 		break;
+ 	case MASTER_SLAVE_CFG_MASTER_FORCE:
+ 		ctl |= CTL1000_AS_MASTER;
+ 		/* fallthrough */
+ 	case MASTER_SLAVE_CFG_SLAVE_FORCE:
+ 		ctl |= CTL1000_ENABLE_MASTER;
+ 		break;
+ 	case MASTER_SLAVE_CFG_UNKNOWN:
+ 	case MASTER_SLAVE_CFG_UNSUPPORTED:
+ 		return 0;
+ 	default:
+ 		phydev_warn(phydev, "Unsupported Master/Slave mode\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return phy_modify_changed(phydev, MII_CTRL1000,
+ 				  (CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER |
+ 				   CTL1000_PREFER_MASTER), ctl);
+ }
+ 
+ static int genphy_read_master_slave(struct phy_device *phydev)
+ {
+ 	int cfg, state;
+ 	int val;
+ 
+ 	if (!phydev->is_gigabit_capable) {
+ 		phydev->master_slave_get = MASTER_SLAVE_CFG_UNSUPPORTED;
+ 		phydev->master_slave_state = MASTER_SLAVE_STATE_UNSUPPORTED;
+ 		return 0;
+ 	}
+ 
+ 	phydev->master_slave_get = MASTER_SLAVE_CFG_UNKNOWN;
+ 	phydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;
+ 
+ 	val = phy_read(phydev, MII_CTRL1000);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	if (val & CTL1000_ENABLE_MASTER) {
+ 		if (val & CTL1000_AS_MASTER)
+ 			cfg = MASTER_SLAVE_CFG_MASTER_FORCE;
+ 		else
+ 			cfg = MASTER_SLAVE_CFG_SLAVE_FORCE;
+ 	} else {
+ 		if (val & CTL1000_PREFER_MASTER)
+ 			cfg = MASTER_SLAVE_CFG_MASTER_PREFERRED;
+ 		else
+ 			cfg = MASTER_SLAVE_CFG_SLAVE_PREFERRED;
+ 	}
+ 
+ 	val = phy_read(phydev, MII_STAT1000);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	if (val & LPA_1000MSFAIL) {
+ 		state = MASTER_SLAVE_STATE_ERR;
+ 	} else if (phydev->link) {
+ 		/* this bits are valid only for active link */
+ 		if (val & LPA_1000MSRES)
+ 			state = MASTER_SLAVE_STATE_MASTER;
+ 		else
+ 			state = MASTER_SLAVE_STATE_SLAVE;
+ 	} else {
+ 		state = MASTER_SLAVE_STATE_UNKNOWN;
+ 	}
+ 
+ 	phydev->master_slave_get = cfg;
+ 	phydev->master_slave_state = state;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 3a13f98b4c16 (net: phy: fix less than zero comparison with unsigned variable val)
  /**
   * genphy_restart_aneg - Enable and Restart Autonegotiation
   * @phydev: target phy_device struct
* Unmerged path drivers/net/phy/phy_device.c
