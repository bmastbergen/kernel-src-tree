intel_idle: Eliminate redundant static variable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit dab20177b626198603176604c0f85ea1d67044ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dab20177.failed

The value of the lapic_timer_always_reliable static variable in
the intel_idle driver reflects the boot_cpu_has(X86_FEATURE_ARAT)
value and so it also reflects the static_cpu_has(X86_FEATURE_ARAT)
value.

Hence, the lapic_timer_always_reliable check in intel_idle() is
redundant and apart from this lapic_timer_always_reliable is only
used in two places in which boot_cpu_has(X86_FEATURE_ARAT) can be
used directly.

Eliminate the lapic_timer_always_reliable variable in accordance
with the above observations.

No intentional functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit dab20177b626198603176604c0f85ea1d67044ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/idle/intel_idle.c
diff --cc drivers/idle/intel_idle.c
index 0c5221d5504f,fa23a7ea01ac..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -75,10 -59,13 +75,13 @@@ static struct cpuidle_driver intel_idle
  };
  /* intel_idle.max_cstate=0 disables driver */
  static int max_cstate = CPUIDLE_STATE_MAX - 1;
 -static unsigned int disabled_states_mask;
 -
 -static struct cpuidle_device __percpu *intel_idle_cpuidle_devices;
  
 -static unsigned long auto_demotion_disable_flags;
 -static bool disable_promotion_to_c1e;
++<<<<<<< HEAD
 +static unsigned int mwait_substates;
 +static bool lapic_timer_always_reliable;
  
++=======
++>>>>>>> dab20177b626 (intel_idle: Eliminate redundant static variable)
  struct idle_cpu {
  	struct cpuidle_state *state_table;
  
@@@ -902,115 -961,7 +905,115 @@@ static struct cpuidle_state dnv_cstates
  		.enter = NULL }
  };
  
 -static const struct idle_cpu idle_cpu_nehalem __initconst = {
 +/**
 + * intel_idle - Ask the processor to enter the given idle state.
 + * @dev: cpuidle device of the target CPU.
 + * @drv: cpuidle driver (assumed to point to intel_idle_driver).
 + * @index: Target idle state index.
 + *
 + * Use the MWAIT instruction to notify the processor that the CPU represented by
 + * @dev is idle and it can try to enter the idle state corresponding to @index.
 + *
 + * If the local APIC timer is not known to be reliable in the target idle state,
 + * enable one-shot tick broadcasting for the target CPU before executing MWAIT.
 + *
 + * Optionally call leave_mm() for the target CPU upfront to avoid wakeups due to
 + * flushing user TLBs.
 + *
 + * Must be called under local_irq_disable().
 + */
 +static __cpuidle int intel_idle(struct cpuidle_device *dev,
 +				struct cpuidle_driver *drv, int index)
 +{
 +	struct cpuidle_state *state = &drv->states[index];
 +	unsigned long eax = flg2MWAIT(state->flags);
 +	unsigned long ecx = 1; /* break on interrupt flag */
 +	bool uninitialized_var(tick);
 +	int cpu = smp_processor_id();
 +
 +	/*
 +	 * leave_mm() to avoid costly and often unnecessary wakeups
 +	 * for flushing the user TLB's associated with the active mm.
 +	 */
 +	if (state->flags & CPUIDLE_FLAG_TLB_FLUSHED)
 +		leave_mm(cpu);
 +
- 	if (!static_cpu_has(X86_FEATURE_ARAT) && !lapic_timer_always_reliable) {
++	if (!static_cpu_has(X86_FEATURE_ARAT)) {
 +		/*
 +		 * Switch over to one-shot tick broadcast if the target C-state
 +		 * is deeper than C1.
 +		 */
 +		if ((eax >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) {
 +			tick = true;
 +			tick_broadcast_enter();
 +		} else {
 +			tick = false;
 +		}
 +	}
 +
 +	mwait_idle_with_hints(eax, ecx);
 +
 +	if (!static_cpu_has(X86_FEATURE_ARAT) && tick)
 +		tick_broadcast_exit();
 +
 +	return index;
 +}
 +
 +/**
 + * intel_idle_s2idle - Ask the processor to enter the given idle state.
 + * @dev: cpuidle device of the target CPU.
 + * @drv: cpuidle driver (assumed to point to intel_idle_driver).
 + * @index: Target idle state index.
 + *
 + * Use the MWAIT instruction to notify the processor that the CPU represented by
 + * @dev is idle and it can try to enter the idle state corresponding to @index.
 + *
 + * Invoked as a suspend-to-idle callback routine with frozen user space, frozen
 + * scheduler tick and suspended scheduler clock on the target CPU.
 + */
 +static __cpuidle void intel_idle_s2idle(struct cpuidle_device *dev,
 +					struct cpuidle_driver *drv, int index)
 +{
 +	unsigned long eax = flg2MWAIT(drv->states[index].flags);
 +	unsigned long ecx = 1; /* break on interrupt flag */
 +
 +	mwait_idle_with_hints(eax, ecx);
 +}
 +
 +static bool intel_idle_verify_cstate(unsigned int mwait_hint)
 +{
 +	unsigned int mwait_cstate = MWAIT_HINT2CSTATE(mwait_hint) + 1;
 +	unsigned int num_substates = (mwait_substates >> mwait_cstate * 4) &
 +					MWAIT_SUBSTATE_MASK;
 +
 +	/* Ignore the C-state if there are NO sub-states in CPUID for it. */
 +	if (num_substates == 0)
 +		return false;
 +
 +	if (mwait_cstate > 2 && !boot_cpu_has(X86_FEATURE_NONSTOP_TSC))
 +		mark_tsc_unstable("TSC halts in idle states deeper than C2");
 +
 +	return true;
 +}
 +
 +static void auto_demotion_disable(void)
 +{
 +	unsigned long long msr_bits;
 +
 +	rdmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);
 +	msr_bits &= ~(icpu->auto_demotion_disable_flags);
 +	wrmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);
 +}
 +static void c1e_promotion_disable(void)
 +{
 +	unsigned long long msr_bits;
 +
 +	rdmsrl(MSR_IA32_POWER_CTL, msr_bits);
 +	msr_bits &= ~0x2;
 +	wrmsrl(MSR_IA32_POWER_CTL, msr_bits);
 +}
 +
 +static const struct idle_cpu idle_cpu_nehalem = {
  	.state_table = nehalem_cstates,
  	.auto_demotion_disable_flags = NHM_C1_AUTO_DEMOTE | NHM_C3_AUTO_DEMOTE,
  	.disable_promotion_to_c1e = true,
* Unmerged path drivers/idle/intel_idle.c
