mm: do_swap_page(): fix up the error code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Michal Hocko <mhocko@suse.com>
commit 545b1b077ca6b359820436af097bc65e3f6f6cc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/545b1b07.failed

do_swap_page() returns error codes from the VM_FAULT* space.  try_charge()
might return -ENOMEM, though, and then do_swap_page() simply returns 0
which means a success.

We almost never return ENOMEM for GFP_KERNEL single page charge.  Except
for async OOM handling (oom_disabled v1).  So this needs translation to
VM_FAULT_OOM otherwise the the page fault path will not notify the
userspace and wait for an action.

Link: http://lkml.kernel.org/r/20200617090238.GL9499@dhcp22.suse.cz
Fixes: 4c6355b25e8b ("mm: memcontrol: charge swapin pages on instantiation")
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Alex Shi <alex.shi@linux.alibaba.com>
	Cc: Joonsoo Kim <js1304@gmail.com>
	Cc: Shakeel Butt <shakeelb@google.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Cc: Roman Gushchin <guro@fb.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 545b1b077ca6b359820436af097bc65e3f6f6cc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory.c
diff --cc mm/memory.c
index 583eb7e0dd7f,1c632faa2611..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -3045,7 -3132,20 +3045,22 @@@ vm_fault_t do_swap_page(struct vm_faul
  				__SetPageLocked(page);
  				__SetPageSwapBacked(page);
  				set_page_private(page, entry.val);
++<<<<<<< HEAD
 +				lru_cache_add_anon(page);
++=======
+ 
+ 				/* Tell memcg to use swap ownership records */
+ 				SetPageSwapCache(page);
+ 				err = mem_cgroup_charge(page, vma->vm_mm,
+ 							GFP_KERNEL);
+ 				ClearPageSwapCache(page);
+ 				if (err) {
+ 					ret = VM_FAULT_OOM;
+ 					goto out_page;
+ 				}
+ 
+ 				lru_cache_add(page);
++>>>>>>> 545b1b077ca6 (mm: do_swap_page(): fix up the error code)
  				swap_readpage(page, true);
  			}
  		} else {
* Unmerged path mm/memory.c
