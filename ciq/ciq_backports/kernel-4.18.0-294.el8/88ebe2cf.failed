net: stmmac: Rework stmmac_rx()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jose Abreu <Jose.Abreu@synopsys.com>
commit 88ebe2cf7f3fc9da95e0f06483fd58da3e67e675
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/88ebe2cf.failed

This looks over-engineered. Let's use some helpers to get the buffer
length and hereby simplify the stmmac_rx() function. No performance drop
was seen with the new implementation.

	Signed-off-by: Jose Abreu <Jose.Abreu@synopsys.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 88ebe2cf7f3fc9da95e0f06483fd58da3e67e675)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 3346bc57d625,a2fac7772666..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -3556,8 -3584,9 +3604,14 @@@ read_again
  		if (unlikely(error && (status & rx_not_ls)))
  			goto read_again;
  		if (unlikely(error)) {
++<<<<<<< HEAD
 +			if (skb)
 +				dev_kfree_skb(skb);
++=======
+ 			dev_kfree_skb(skb);
+ 			skb = NULL;
+ 			count++;
++>>>>>>> 88ebe2cf7f3f (net: stmmac: Rework stmmac_rx())
  			continue;
  		}
  
@@@ -3582,29 -3619,18 +3644,22 @@@
  		}
  
  		if (!skb) {
- 			int ret = stmmac_get_rx_header_len(priv, p, &hlen);
- 
- 			if (priv->sph && !ret && (hlen > 0)) {
- 				sec_len = len;
- 				if (!(status & rx_not_ls))
- 					sec_len = sec_len - hlen;
- 				len = hlen;
- 
- 				prefetch(page_address(buf->sec_page));
- 				priv->xstats.rx_split_hdr_pkt_n++;
- 			}
- 
- 			skb = napi_alloc_skb(&ch->rx_napi, len);
+ 			skb = napi_alloc_skb(&ch->rx_napi, buf1_len);
  			if (!skb) {
  				priv->dev->stats.rx_dropped++;
++<<<<<<< HEAD
 +				continue;
++=======
+ 				count++;
+ 				goto drain_data;
++>>>>>>> 88ebe2cf7f3f (net: stmmac: Rework stmmac_rx())
  			}
  
- 			dma_sync_single_for_cpu(priv->device, buf->addr, len,
- 						DMA_FROM_DEVICE);
+ 			dma_sync_single_for_cpu(priv->device, buf->addr,
+ 						buf1_len, DMA_FROM_DEVICE);
  			skb_copy_to_linear_data(skb, page_address(buf->page),
- 						len);
- 			skb_put(skb, len);
+ 						buf1_len);
+ 			skb_put(skb, buf1_len);
  
  			/* Data payload copied into SKB, page ready for recycle */
  			page_pool_recycle_direct(rx_q->page_pool, buf->page);
@@@ -3662,9 -3685,10 +3714,9 @@@ drain_data
  
  		priv->dev->stats.rx_packets++;
  		priv->dev->stats.rx_bytes += len;
 -		count++;
  	}
  
- 	if (status & rx_not_ls) {
+ 	if (status & rx_not_ls || skb) {
  		rx_q->state_saved = true;
  		rx_q->state.skb = skb;
  		rx_q->state.error = error;
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
