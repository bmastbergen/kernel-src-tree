s390/ap: add error response code field for ap queue devices

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 2ea2a6099ae3d1708f90f43c81a98cba3d4bb74c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2ea2a609.failed

On AP instruction failures the last response code is now
kept in the struct ap_queue. There is also a new sysfs
attribute showing this field (enabled only on debug kernels).

Also slight rework of the AP_DBF macros to get some more
content into one debug feature message line.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 2ea2a6099ae3d1708f90f43c81a98cba3d4bb74c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
#	drivers/s390/crypto/ap_bus.h
#	drivers/s390/crypto/ap_queue.c
diff --cc drivers/s390/crypto/ap_bus.c
index 70b945ce5806,6d61e89c5984..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -212,21 -206,40 +212,43 @@@ static inline int ap_query_configuratio
  }
  
  /**
 - * ap_init_qci_info(): Allocate and query qci config info.
 - * Does also update the static variables ap_max_domain_id
 - * and ap_max_adapter_id if this info is available.
 -
 + * ap_init_configuration(): Allocate and query configuration array.
   */
 -static void __init ap_init_qci_info(void)
 +static void ap_init_configuration(void)
  {
++<<<<<<< HEAD
 +	if (!ap_configuration_available())
++=======
+ 	if (!ap_qci_available()) {
+ 		AP_DBF_INFO("%s QCI not supported\n", __func__);
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  		return;
 -	}
  
 -	ap_qci_info = kzalloc(sizeof(*ap_qci_info), GFP_KERNEL);
 -	if (!ap_qci_info)
 +	ap_configuration = kzalloc(sizeof(*ap_configuration), GFP_KERNEL);
 +	if (!ap_configuration)
  		return;
 -	if (ap_fetch_qci_info(ap_qci_info) != 0) {
 -		kfree(ap_qci_info);
 -		ap_qci_info = NULL;
 +	if (ap_query_configuration(ap_configuration) != 0) {
 +		kfree(ap_configuration);
 +		ap_configuration = NULL;
  		return;
  	}
++<<<<<<< HEAD
++=======
+ 	AP_DBF_INFO("%s successful fetched initial qci info\n", __func__);
+ 
+ 	if (ap_qci_info->apxa) {
+ 		if (ap_qci_info->Na) {
+ 			ap_max_adapter_id = ap_qci_info->Na;
+ 			AP_DBF_INFO("%s new ap_max_adapter_id is %d\n",
+ 				    __func__, ap_max_adapter_id);
+ 		}
+ 		if (ap_qci_info->Nd) {
+ 			ap_max_domain_id = ap_qci_info->Nd;
+ 			AP_DBF_INFO("%s new ap_max_domain_id is %d\n",
+ 				    __func__, ap_max_domain_id);
+ 		}
+ 	}
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  }
  
  /*
@@@ -1048,7 -947,7 +1070,11 @@@ static ssize_t ap_domain_store(struct b
  	ap_domain_index = domain;
  	spin_unlock_bh(&ap_domain_lock);
  
++<<<<<<< HEAD
 +	AP_DBF(DBF_DEBUG, "stored new default domain=%d\n", domain);
++=======
+ 	AP_DBF_INFO("stored new default domain=%d\n", domain);
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  
  	return count;
  }
@@@ -1287,35 -1187,31 +1313,42 @@@ static void ap_select_domain(void
  	spin_lock_bh(&ap_domain_lock);
  	if (ap_domain_index >= 0) {
  		/* Domain has already been selected. */
 -		goto out;
 +		spin_unlock_bh(&ap_domain_lock);
 +		return;
  	}
 -	for (dom = 0; dom <= ap_max_domain_id; dom++) {
 -		if (!ap_test_config_usage_domain(dom) ||
 -		    !test_bit_inv(dom, ap_perms.aqm))
 +	best_domain = -1;
 +	max_count = 0;
 +	for (i = 0; i < AP_DOMAINS; i++) {
 +		if (!ap_test_config_usage_domain(i) ||
 +		    !test_bit_inv(i, ap_perms.aqm))
  			continue;
 -		for (card = 0; card <= ap_max_adapter_id; card++) {
 -			if (!ap_test_config_card_id(card) ||
 -			    !test_bit_inv(card, ap_perms.apm))
 +		count = 0;
 +		for (j = 0; j < AP_DEVICES; j++) {
 +			if (!ap_test_config_card_id(j))
  				continue;
 -			status = ap_test_queue(AP_MKQID(card, dom),
 +			status = ap_test_queue(AP_MKQID(j, i),
  					       ap_apft_available(),
  					       NULL);
 -			if (status.response_code == AP_RESPONSE_NORMAL)
 -				break;
 +			if (status.response_code != AP_RESPONSE_NORMAL)
 +				continue;
 +			count++;
 +		}
 +		if (count > max_count) {
 +			max_count = count;
 +			best_domain = i;
  		}
 -		if (card <= ap_max_adapter_id)
 -			break;
  	}
++<<<<<<< HEAD
 +	if (best_domain >= 0) {
 +		ap_domain_index = best_domain;
 +		AP_DBF(DBF_DEBUG, "new ap_domain_index=%d\n", ap_domain_index);
++=======
+ 	if (dom <= ap_max_domain_id) {
+ 		ap_domain_index = dom;
+ 		AP_DBF_INFO("%s new default domain is %d\n",
+ 			    __func__, ap_domain_index);
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  	}
 -out:
  	spin_unlock_bh(&ap_domain_lock);
  }
  
@@@ -1427,23 -1328,23 +1464,32 @@@ static void _ap_scan_bus_adapter(int id
  		/* find the first valid queue */
  		for (dom = 0; dom < AP_DOMAINS; dom++) {
  			qid = AP_MKQID(id, dom);
 -			if (ap_queue_info(qid, &type, &func, &depth))
 +			if (ap_query_queue(qid, &depth, &type, &func) == 0)
  				break;
  		}
 -		broken = false;
 +		borked = 0;
  		if (dom >= AP_DOMAINS) {
  			/* no accessible queue on this card */
 -			broken = true;
 +			borked = 1;
  		} else if (ac->raw_hwtype != type) {
  			/* card type has changed */
++<<<<<<< HEAD
 +			AP_DBF(DBF_INFO, "card=%02x type changed.\n", id);
 +			borked = 1;
 +		} else if (ac->functions != func) {
 +			/* card functions have changed */
 +			AP_DBF(DBF_INFO, "card=%02x functions changed.\n", id);
 +			borked = 1;
++=======
+ 			AP_DBF_INFO("card=%02x type changed.\n", id);
+ 			broken = true;
+ 		} else if (ac->functions != func) {
+ 			/* card functions have changed */
+ 			AP_DBF_INFO("card=%02x functions changed.\n", id);
+ 			broken = true;
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  		}
 -		if (broken) {
 +		if (borked) {
  			/* unregister card device and associated queues */
  			bus_for_each_dev(&ap_bus_type, NULL,
  					 (void *)(long) id,
@@@ -1479,20 -1380,17 +1525,19 @@@
  			continue;
  		}
  		/* try to fetch infos about this queue */
 -		broken = !ap_queue_info(qid, &type, &func, &depth);
 +		rc = ap_query_queue(qid, &depth, &type, &func);
  		if (dev) {
 -			if (!broken) {
 +			if (rc == -ENODEV)
 +				borked = 1;
 +			else {
  				spin_lock_bh(&aq->lock);
 -				broken = aq->dev_state == AP_DEV_STATE_ERROR;
 +				borked = aq->state == AP_STATE_BORKED;
  				spin_unlock_bh(&aq->lock);
  			}
 -			if (broken) {
 +			if (borked) {
  				/* Remove broken device */
- 				AP_DBF(DBF_DEBUG,
- 				       "removing broken queue=%02x.%04x\n",
- 				       id, dom);
+ 				AP_DBF_DBG("removing broken queue=%02x.%04x\n",
+ 					   id, dom);
  				device_unregister(dev);
  			}
  			put_device(dev);
@@@ -1550,10 -1448,10 +1595,17 @@@ static void ap_scan_bus(struct work_str
  {
  	int id;
  
++<<<<<<< HEAD
 +	AP_DBF(DBF_DEBUG, "%s running\n", __func__);
++=======
+ 	ap_fetch_qci_info(ap_qci_info);
+ 	ap_select_domain();
+ 
+ 	AP_DBF_DBG("%s running\n", __func__);
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
 +
 +	ap_query_configuration(ap_configuration);
 +	ap_select_domain();
  
  	/* loop over all possible adapters */
  	for (id = 0; id < AP_DEVICES; id++)
diff --cc drivers/s390/crypto/ap_bus.h
index 0a20eede0143,0b66e8866a2c..000000000000
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@@ -184,6 -189,8 +184,11 @@@ struct ap_queue 
  	struct list_head pendingq;	/* List of message sent to AP queue. */
  	struct list_head requestq;	/* List of message yet to be sent. */
  	struct ap_message *reply;	/* Per device reply message. */
++<<<<<<< HEAD
++=======
+ 	enum ap_sm_state sm_state;	/* ap queue state machine state */
+ 	int last_err_rc;		/* last error state response code */
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  };
  
  #define to_ap_queue(x) container_of((x), struct ap_queue, ap_dev.device)
diff --cc drivers/s390/crypto/ap_queue.c
index 7bd5294989aa,69ea3d2c20ae..000000000000
--- a/drivers/s390/crypto/ap_queue.c
+++ b/drivers/s390/crypto/ap_queue.c
@@@ -184,44 -184,23 +184,53 @@@ static enum ap_wait ap_sm_read(struct a
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  		if (aq->queue_count > 0) {
 -			aq->sm_state = AP_SM_STATE_WORKING;
 -			return AP_SM_WAIT_AGAIN;
 +			aq->state = AP_STATE_WORKING;
 +			return AP_WAIT_AGAIN;
  		}
 -		aq->sm_state = AP_SM_STATE_IDLE;
 -		return AP_SM_WAIT_NONE;
 +		aq->state = AP_STATE_IDLE;
 +		return AP_WAIT_NONE;
  	case AP_RESPONSE_NO_PENDING_REPLY:
  		if (aq->queue_count > 0)
 -			return AP_SM_WAIT_INTERRUPT;
 -		aq->sm_state = AP_SM_STATE_IDLE;
 -		return AP_SM_WAIT_NONE;
 +			return AP_WAIT_INTERRUPT;
 +		aq->state = AP_STATE_IDLE;
 +		return AP_WAIT_NONE;
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
 +	}
 +}
 +
 +/**
 + * ap_sm_suspend_read(): Receive pending reply messages from an AP queue
 + * without changing the device state in between. In suspend mode we don't
 + * allow sending new requests, therefore just fetch pending replies.
 + * @aq: pointer to the AP queue
 + *
 + * Returns AP_WAIT_NONE or AP_WAIT_AGAIN
 + */
 +static enum ap_wait ap_sm_suspend_read(struct ap_queue *aq)
 +{
 +	struct ap_queue_status status;
 +
 +	if (!aq->reply)
 +		return AP_WAIT_NONE;
 +	status = ap_sm_recv(aq);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		if (aq->queue_count > 0)
 +			return AP_WAIT_AGAIN;
 +		/* fall through */
 +	default:
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		aq->last_err_rc = status.response_code;
+ 		AP_DBF_WARN("%s RC 0x%02hhx on 0x%02x.%04x -> AP_DEV_STATE_ERROR\n",
+ 			    __func__, status.response_code,
+ 			    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  	}
  }
  
@@@ -268,10 -247,14 +277,19 @@@ static enum ap_wait ap_sm_write(struct 
  		aq->requestq_count--;
  		ap_msg->rc = -EINVAL;
  		ap_msg->receive(aq, ap_msg, NULL);
 -		return AP_SM_WAIT_AGAIN;
 +		return AP_WAIT_AGAIN;
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		aq->last_err_rc = status.response_code;
+ 		AP_DBF_WARN("%s RC 0x%02hhx on 0x%02x.%04x -> AP_DEV_STATE_ERROR\n",
+ 			    __func__, status.response_code,
+ 			    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  	}
  }
  
@@@ -309,8 -292,12 +327,17 @@@ static enum ap_wait ap_sm_reset(struct 
  	case AP_RESPONSE_DECONFIGURED:
  	case AP_RESPONSE_CHECKSTOPPED:
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		aq->last_err_rc = status.response_code;
+ 		AP_DBF_WARN("%s RC 0x%02hhx on 0x%02x.%04x -> AP_DEV_STATE_ERROR\n",
+ 			    __func__, status.response_code,
+ 			    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  	}
  }
  
@@@ -348,8 -335,12 +375,17 @@@ static enum ap_wait ap_sm_reset_wait(st
  	case AP_RESPONSE_DECONFIGURED:
  	case AP_RESPONSE_CHECKSTOPPED:
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		aq->last_err_rc = status.response_code;
+ 		AP_DBF_WARN("%s RC 0x%02hhx on 0x%02x.%04x -> AP_DEV_STATE_ERROR\n",
+ 			    __func__, status.response_code,
+ 			    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  	}
  }
  
@@@ -380,13 -371,17 +416,22 @@@ static enum ap_wait ap_sm_setirq_wait(s
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  		if (aq->queue_count > 0)
 -			return AP_SM_WAIT_AGAIN;
 -		fallthrough;
 +			return AP_WAIT_AGAIN;
 +		/* fallthrough */
  	case AP_RESPONSE_NO_PENDING_REPLY:
 -		return AP_SM_WAIT_TIMEOUT;
 +		return AP_WAIT_TIMEOUT;
  	default:
++<<<<<<< HEAD
 +		aq->state = AP_STATE_BORKED;
 +		return AP_WAIT_NONE;
++=======
+ 		aq->dev_state = AP_DEV_STATE_ERROR;
+ 		aq->last_err_rc = status.response_code;
+ 		AP_DBF_WARN("%s RC 0x%02hhx on 0x%02x.%04x -> AP_DEV_STATE_ERROR\n",
+ 			    __func__, status.response_code,
+ 			    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));
+ 		return AP_SM_WAIT_NONE;
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  	}
  }
  
@@@ -593,12 -563,123 +638,129 @@@ static ssize_t interrupt_show(struct de
  
  static DEVICE_ATTR_RO(interrupt);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ZCRYPT_DEBUG
+ static ssize_t states_show(struct device *dev,
+ 			   struct device_attribute *attr, char *buf)
+ {
+ 	struct ap_queue *aq = to_ap_queue(dev);
+ 	int rc = 0;
+ 
+ 	spin_lock_bh(&aq->lock);
+ 	/* queue device state */
+ 	switch (aq->dev_state) {
+ 	case AP_DEV_STATE_UNINITIATED:
+ 		rc = scnprintf(buf, PAGE_SIZE, "UNINITIATED\n");
+ 		break;
+ 	case AP_DEV_STATE_OPERATING:
+ 		rc = scnprintf(buf, PAGE_SIZE, "OPERATING");
+ 		break;
+ 	case AP_DEV_STATE_SHUTDOWN:
+ 		rc = scnprintf(buf, PAGE_SIZE, "SHUTDOWN");
+ 		break;
+ 	case AP_DEV_STATE_ERROR:
+ 		rc = scnprintf(buf, PAGE_SIZE, "ERROR");
+ 		break;
+ 	default:
+ 		rc = scnprintf(buf, PAGE_SIZE, "UNKNOWN");
+ 	}
+ 	/* state machine state */
+ 	if (aq->dev_state) {
+ 		switch (aq->sm_state) {
+ 		case AP_SM_STATE_RESET_START:
+ 			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
+ 					" [RESET_START]\n");
+ 			break;
+ 		case AP_SM_STATE_RESET_WAIT:
+ 			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
+ 					" [RESET_WAIT]\n");
+ 			break;
+ 		case AP_SM_STATE_SETIRQ_WAIT:
+ 			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
+ 					" [SETIRQ_WAIT]\n");
+ 			break;
+ 		case AP_SM_STATE_IDLE:
+ 			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
+ 					" [IDLE]\n");
+ 			break;
+ 		case AP_SM_STATE_WORKING:
+ 			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
+ 					" [WORKING]\n");
+ 			break;
+ 		case AP_SM_STATE_QUEUE_FULL:
+ 			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
+ 					" [FULL]\n");
+ 			break;
+ 		default:
+ 			rc += scnprintf(buf + rc, PAGE_SIZE - rc,
+ 					" [UNKNOWN]\n");
+ 		}
+ 	}
+ 	spin_unlock_bh(&aq->lock);
+ 
+ 	return rc;
+ }
+ static DEVICE_ATTR_RO(states);
+ 
+ static ssize_t last_err_rc_show(struct device *dev,
+ 				struct device_attribute *attr, char *buf)
+ {
+ 	struct ap_queue *aq = to_ap_queue(dev);
+ 	int rc;
+ 
+ 	spin_lock_bh(&aq->lock);
+ 	rc = aq->last_err_rc;
+ 	spin_unlock_bh(&aq->lock);
+ 
+ 	switch (rc) {
+ 	case AP_RESPONSE_NORMAL:
+ 		return scnprintf(buf, PAGE_SIZE, "NORMAL\n");
+ 	case AP_RESPONSE_Q_NOT_AVAIL:
+ 		return scnprintf(buf, PAGE_SIZE, "Q_NOT_AVAIL\n");
+ 	case AP_RESPONSE_RESET_IN_PROGRESS:
+ 		return scnprintf(buf, PAGE_SIZE, "RESET_IN_PROGRESS\n");
+ 	case AP_RESPONSE_DECONFIGURED:
+ 		return scnprintf(buf, PAGE_SIZE, "DECONFIGURED\n");
+ 	case AP_RESPONSE_CHECKSTOPPED:
+ 		return scnprintf(buf, PAGE_SIZE, "CHECKSTOPPED\n");
+ 	case AP_RESPONSE_BUSY:
+ 		return scnprintf(buf, PAGE_SIZE, "BUSY\n");
+ 	case AP_RESPONSE_INVALID_ADDRESS:
+ 		return scnprintf(buf, PAGE_SIZE, "INVALID_ADDRESS\n");
+ 	case AP_RESPONSE_OTHERWISE_CHANGED:
+ 		return scnprintf(buf, PAGE_SIZE, "OTHERWISE_CHANGED\n");
+ 	case AP_RESPONSE_Q_FULL:
+ 		return scnprintf(buf, PAGE_SIZE, "Q_FULL/NO_PENDING_REPLY\n");
+ 	case AP_RESPONSE_INDEX_TOO_BIG:
+ 		return scnprintf(buf, PAGE_SIZE, "INDEX_TOO_BIG\n");
+ 	case AP_RESPONSE_NO_FIRST_PART:
+ 		return scnprintf(buf, PAGE_SIZE, "NO_FIRST_PART\n");
+ 	case AP_RESPONSE_MESSAGE_TOO_BIG:
+ 		return scnprintf(buf, PAGE_SIZE, "MESSAGE_TOO_BIG\n");
+ 	case AP_RESPONSE_REQ_FAC_NOT_INST:
+ 		return scnprintf(buf, PAGE_SIZE, "REQ_FAC_NOT_INST\n");
+ 	default:
+ 		return scnprintf(buf, PAGE_SIZE, "response code %d\n", rc);
+ 	}
+ }
+ static DEVICE_ATTR_RO(last_err_rc);
+ #endif
+ 
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  static struct attribute *ap_queue_dev_attrs[] = {
  	&dev_attr_request_count.attr,
  	&dev_attr_requestq_count.attr,
  	&dev_attr_pendingq_count.attr,
  	&dev_attr_reset.attr,
  	&dev_attr_interrupt.attr,
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ZCRYPT_DEBUG
+ 	&dev_attr_states.attr,
+ 	&dev_attr_last_err_rc.attr,
+ #endif
++>>>>>>> 2ea2a6099ae3 (s390/ap: add error response code field for ap queue devices)
  	NULL
  };
  
* Unmerged path drivers/s390/crypto/ap_bus.c
* Unmerged path drivers/s390/crypto/ap_bus.h
diff --git a/drivers/s390/crypto/ap_debug.h b/drivers/s390/crypto/ap_debug.h
index dc675eb5aef6..34b0350d0b1a 100644
--- a/drivers/s390/crypto/ap_debug.h
+++ b/drivers/s390/crypto/ap_debug.h
@@ -20,6 +20,14 @@
 
 #define AP_DBF(...)					\
 	debug_sprintf_event(ap_dbf_info, ##__VA_ARGS__)
+#define AP_DBF_ERR(...)					\
+	debug_sprintf_event(ap_dbf_info, DBF_ERR, ##__VA_ARGS__)
+#define AP_DBF_WARN(...)					\
+	debug_sprintf_event(ap_dbf_info, DBF_WARN, ##__VA_ARGS__)
+#define AP_DBF_INFO(...)					\
+	debug_sprintf_event(ap_dbf_info, DBF_INFO, ##__VA_ARGS__)
+#define AP_DBF_DBG(...)					\
+	debug_sprintf_event(ap_dbf_info, DBF_DEBUG, ##__VA_ARGS__)
 
 extern debug_info_t *ap_dbf_info;
 
* Unmerged path drivers/s390/crypto/ap_queue.c
