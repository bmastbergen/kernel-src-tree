libbpf: Add btf__new_empty() to create an empty BTF object

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit a871b04310248024e022e104eba3ec81d144cc64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a871b043.failed

Add an ability to create an empty BTF object from scratch. This is going to be
used by pahole for BTF encoding. And also by selftest for convenient creation
of BTF objects.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/20200926011357.2366158-7-andriin@fb.com
(cherry picked from commit a871b04310248024e022e104eba3ec81d144cc64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/btf.h
#	tools/lib/bpf/libbpf.map
diff --cc tools/lib/bpf/btf.h
index d511de1e95f1,b387d0b61f1c..000000000000
--- a/tools/lib/bpf/btf.h
+++ b/tools/lib/bpf/btf.h
@@@ -26,8 -27,10 +26,15 @@@ struct bpf_object
  
  LIBBPF_API void btf__free(struct btf *btf);
  LIBBPF_API struct btf *btf__new(const void *data, __u32 size);
++<<<<<<< HEAD
 +LIBBPF_API struct btf *btf__parse_elf(const char *path,
 +				      struct btf_ext **btf_ext);
++=======
+ LIBBPF_API struct btf *btf__new_empty(void);
+ LIBBPF_API struct btf *btf__parse(const char *path, struct btf_ext **btf_ext);
+ LIBBPF_API struct btf *btf__parse_elf(const char *path, struct btf_ext **btf_ext);
+ LIBBPF_API struct btf *btf__parse_raw(const char *path);
++>>>>>>> a871b0431024 (libbpf: Add btf__new_empty() to create an empty BTF object)
  LIBBPF_API int btf__finalize_data(struct bpf_object *obj, struct btf *btf);
  LIBBPF_API int btf__load(struct btf *btf);
  LIBBPF_API __s32 btf__find_by_name(const struct btf *btf,
diff --cc tools/lib/bpf/libbpf.map
index 69599528ddbe,d02d8f51e34f..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -286,3 -254,63 +286,66 @@@ LIBBPF_0.0.8 
  		bpf_program__set_lsm;
  		bpf_set_link_xdp_fd_opts;
  } LIBBPF_0.0.7;
++<<<<<<< HEAD
++=======
+ 
+ LIBBPF_0.0.9 {
+ 	global:
+ 		bpf_enable_stats;
+ 		bpf_iter_create;
+ 		bpf_link_get_fd_by_id;
+ 		bpf_link_get_next_id;
+ 		bpf_program__attach_iter;
+ 		bpf_program__attach_netns;
+ 		perf_buffer__consume;
+ 		ring_buffer__add;
+ 		ring_buffer__consume;
+ 		ring_buffer__free;
+ 		ring_buffer__new;
+ 		ring_buffer__poll;
+ } LIBBPF_0.0.8;
+ 
+ LIBBPF_0.1.0 {
+ 	global:
+ 		bpf_link__detach;
+ 		bpf_link_detach;
+ 		bpf_map__ifindex;
+ 		bpf_map__key_size;
+ 		bpf_map__map_flags;
+ 		bpf_map__max_entries;
+ 		bpf_map__numa_node;
+ 		bpf_map__set_key_size;
+ 		bpf_map__set_map_flags;
+ 		bpf_map__set_max_entries;
+ 		bpf_map__set_numa_node;
+ 		bpf_map__set_type;
+ 		bpf_map__set_value_size;
+ 		bpf_map__type;
+ 		bpf_map__value_size;
+ 		bpf_program__attach_xdp;
+ 		bpf_program__autoload;
+ 		bpf_program__is_sk_lookup;
+ 		bpf_program__set_autoload;
+ 		bpf_program__set_sk_lookup;
+ 		btf__parse;
+ 		btf__parse_raw;
+ 		btf__pointer_size;
+ 		btf__set_fd;
+ 		btf__set_pointer_size;
+ } LIBBPF_0.0.9;
+ 
+ LIBBPF_0.2.0 {
+ 	global:
+ 		bpf_prog_bind_map;
+ 		bpf_prog_test_run_opts;
+ 		bpf_program__section_name;
+ 		btf__add_str;
+ 		btf__find_str;
+ 		btf__new_empty;
+ 		perf_buffer__buffer_cnt;
+ 		perf_buffer__buffer_fd;
+ 		perf_buffer__epoll_fd;
+ 		perf_buffer__consume_buffer;
+ 		xsk_socket__create_shared;
+ } LIBBPF_0.1.0;
++>>>>>>> a871b0431024 (libbpf: Add btf__new_empty() to create an empty BTF object)
diff --git a/tools/lib/bpf/btf.c b/tools/lib/bpf/btf.c
index 9ca048005e04..38f7b1d54b79 100644
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@ -397,6 +397,36 @@ void btf__free(struct btf *btf)
 	free(btf);
 }
 
+struct btf *btf__new_empty(void)
+{
+	struct btf *btf;
+
+	btf = calloc(1, sizeof(*btf));
+	if (!btf)
+		return ERR_PTR(-ENOMEM);
+	btf->fd = -1;
+	btf->ptr_sz = sizeof(void *);
+
+	/* +1 for empty string at offset 0 */
+	btf->raw_size = sizeof(struct btf_header) + 1;
+	btf->raw_data = calloc(1, btf->raw_size);
+	if (!btf->raw_data) {
+		free(btf);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	btf->hdr = btf->raw_data;
+	btf->hdr->hdr_len = sizeof(struct btf_header);
+	btf->hdr->magic = BTF_MAGIC;
+	btf->hdr->version = BTF_VERSION;
+
+	btf->types_data = btf->raw_data + btf->hdr->hdr_len;
+	btf->strs_data = btf->raw_data + btf->hdr->hdr_len;
+	btf->hdr->str_len = 1; /* empty string at offset 0 */
+
+	return btf;
+}
+
 struct btf *btf__new(const void *data, __u32 size)
 {
 	struct btf *btf;
* Unmerged path tools/lib/bpf/btf.h
* Unmerged path tools/lib/bpf/libbpf.map
