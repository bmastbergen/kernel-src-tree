dm table: fix DAX iterate_devices based device capability checks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jeffle Xu <jefflexu@linux.alibaba.com>
commit 5b0fab508992c2e120971da658ce80027acbc405
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5b0fab50.failed

Fix dm_table_supports_dax() and invert logic of both
iterate_devices_callout_fn so that all devices' DAX capabilities are
properly checked.

Fixes: 545ed20e6df6 ("dm: add infrastructure for DAX support")
	Cc: stable@vger.kernel.org
	Signed-off-by: Jeffle Xu <jefflexu@linux.alibaba.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 5b0fab508992c2e120971da658ce80027acbc405)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-table.c
diff --cc drivers/md/dm-table.c
index 6b62887f4f69,71f7ec508cf7..000000000000
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@@ -863,13 -820,17 +863,21 @@@ void dm_table_set_type(struct dm_table 
  EXPORT_SYMBOL_GPL(dm_table_set_type);
  
  /* validate the dax capability of the target device span */
- int device_supports_dax(struct dm_target *ti, struct dm_dev *dev,
+ int device_not_dax_capable(struct dm_target *ti, struct dm_dev *dev,
  			sector_t start, sector_t len, void *data)
  {
 -	int blocksize = *(int *) data, id;
 -	bool rc;
 +	int blocksize = *(int *) data;
  
++<<<<<<< HEAD
 +	return generic_fsdax_supported(dev->dax_dev, dev->bdev, blocksize,
 +				       start, len);
++=======
+ 	id = dax_read_lock();
+ 	rc = !dax_supported(dev->dax_dev, dev->bdev, blocksize, start, len);
+ 	dax_read_unlock(id);
+ 
+ 	return rc;
++>>>>>>> 5b0fab508992 (dm table: fix DAX iterate_devices based device capability checks)
  }
  
  /* Check devices support synchronous DAX */
@@@ -967,18 -925,9 +975,18 @@@ static int dm_table_determine_type(stru
  verify_bio_based:
  		/* We must use this table as bio-based */
  		t->type = DM_TYPE_BIO_BASED;
- 		if (dm_table_supports_dax(t, device_supports_dax, &page_size) ||
+ 		if (dm_table_supports_dax(t, device_not_dax_capable, &page_size) ||
  		    (list_empty(devices) && live_md_type == DM_TYPE_DAX_BIO_BASED)) {
  			t->type = DM_TYPE_DAX_BIO_BASED;
 +		} else {
 +			/* Check if upgrading to NVMe bio-based is valid or required */
 +			tgt = dm_table_get_immutable_target(t);
 +			if (tgt && !tgt->max_io_len && dm_table_does_not_support_partial_completion(t)) {
 +				t->type = DM_TYPE_NVME_BIO_BASED;
 +				goto verify_rq_based; /* must be stacked directly on NVMe (blk-mq) */
 +			} else if (list_empty(devices) && live_md_type == DM_TYPE_NVME_BIO_BASED) {
 +				t->type = DM_TYPE_NVME_BIO_BASED;
 +			}
  		}
  		return 0;
  	}
@@@ -1656,25 -1618,8 +1664,30 @@@ static int device_dax_write_cache_enabl
  	return false;
  }
  
++<<<<<<< HEAD
 +static int dm_table_supports_dax_write_cache(struct dm_table *t)
 +{
 +	struct dm_target *ti;
 +	unsigned i;
 +
 +	for (i = 0; i < dm_table_get_num_targets(t); i++) {
 +		ti = dm_table_get_target(t, i);
 +
 +		if (ti->type->iterate_devices &&
 +		    ti->type->iterate_devices(ti,
 +				device_dax_write_cache_enabled, NULL))
 +			return true;
 +	}
 +
 +	return false;
 +}
 +
 +static int device_is_nonrot(struct dm_target *ti, struct dm_dev *dev,
 +			    sector_t start, sector_t len, void *data)
++=======
+ static int device_is_rotational(struct dm_target *ti, struct dm_dev *dev,
+ 				sector_t start, sector_t len, void *data)
++>>>>>>> 5b0fab508992 (dm table: fix DAX iterate_devices based device capability checks)
  {
  	struct request_queue *q = bdev_get_queue(dev->bdev);
  
* Unmerged path drivers/md/dm-table.c
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index c0770218837c..45e28584c95f 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -1127,7 +1127,7 @@ static bool dm_dax_supported(struct dax_device *dax_dev, struct block_device *bd
 	if (!map)
 		goto out;
 
-	ret = dm_table_supports_dax(map, device_supports_dax, &blocksize);
+	ret = dm_table_supports_dax(map, device_not_dax_capable, &blocksize);
 
 out:
 	dm_put_live_table(md, srcu_idx);
diff --git a/drivers/md/dm.h b/drivers/md/dm.h
index d7c4f6606b5f..9fbf87e04019 100644
--- a/drivers/md/dm.h
+++ b/drivers/md/dm.h
@@ -74,7 +74,7 @@ void dm_table_free_md_mempools(struct dm_table *t);
 struct dm_md_mempools *dm_table_get_md_mempools(struct dm_table *t);
 bool dm_table_supports_dax(struct dm_table *t, iterate_devices_callout_fn fn,
 			   int *blocksize);
-int device_supports_dax(struct dm_target *ti, struct dm_dev *dev,
+int device_not_dax_capable(struct dm_target *ti, struct dm_dev *dev,
 			   sector_t start, sector_t len, void *data);
 
 void dm_lock_md_type(struct mapped_device *md);
