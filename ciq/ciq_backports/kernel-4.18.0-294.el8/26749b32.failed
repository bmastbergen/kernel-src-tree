dma-direct: mark __dma_direct_alloc_pages static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 26749b3201ab05e288fbf78fbc8585dfa2da3218
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/26749b32.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 26749b3201ab05e288fbf78fbc8585dfa2da3218)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index 50772983c03a,30c41b57acd9..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -76,7 -76,40 +76,44 @@@ static bool dma_coherent_ok(struct devi
  			min_not_zero(dev->coherent_dma_mask, dev->bus_dma_limit);
  }
  
++<<<<<<< HEAD
 +struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,
++=======
+ /*
+  * Decrypting memory is allowed to block, so if this device requires
+  * unencrypted memory it must come from atomic pools.
+  */
+ static inline bool dma_should_alloc_from_pool(struct device *dev, gfp_t gfp,
+ 					      unsigned long attrs)
+ {
+ 	if (!IS_ENABLED(CONFIG_DMA_COHERENT_POOL))
+ 		return false;
+ 	if (gfpflags_allow_blocking(gfp))
+ 		return false;
+ 	if (force_dma_unencrypted(dev))
+ 		return true;
+ 	if (!IS_ENABLED(CONFIG_DMA_DIRECT_REMAP))
+ 		return false;
+ 	if (dma_alloc_need_uncached(dev, attrs))
+ 		return true;
+ 	return false;
+ }
+ 
+ static inline bool dma_should_free_from_pool(struct device *dev,
+ 					     unsigned long attrs)
+ {
+ 	if (IS_ENABLED(CONFIG_DMA_COHERENT_POOL))
+ 		return true;
+ 	if ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&
+ 	    !force_dma_unencrypted(dev))
+ 		return false;
+ 	if (IS_ENABLED(CONFIG_DMA_DIRECT_REMAP))
+ 		return true;
+ 	return false;
+ }
+ 
+ static struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,
++>>>>>>> 26749b3201ab (dma-direct: mark __dma_direct_alloc_pages static)
  		gfp_t gfp, unsigned long attrs)
  {
  	size_t alloc_size = PAGE_ALIGN(size);
diff --git a/include/linux/dma-direct.h b/include/linux/dma-direct.h
index 1628fb6087ec..fc1c8b867efb 100644
--- a/include/linux/dma-direct.h
+++ b/include/linux/dma-direct.h
@@ -77,8 +77,6 @@ void *dma_direct_alloc_pages(struct device *dev, size_t size,
 		dma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs);
 void dma_direct_free_pages(struct device *dev, size_t size, void *cpu_addr,
 		dma_addr_t dma_addr, unsigned long attrs);
-struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,
-		gfp_t gfp, unsigned long attrs);
 int dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,
 		void *cpu_addr, dma_addr_t dma_addr, size_t size,
 		unsigned long attrs);
* Unmerged path kernel/dma/direct.c
