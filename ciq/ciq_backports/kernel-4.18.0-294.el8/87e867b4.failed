sched/pelt: Cleanup PELT divider

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vincent Guittot <vincent.guittot@linaro.org>
commit 87e867b4269f29dac8190bca13912d08163a277f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/87e867b4.failed

Factorize in a single place the calculation of the divider to be used to
to compute *_avg from *_sum value

	Suggested-by: Dietmar Eggemann <dietmar.eggemann@arm.com>
	Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200612154703.23555-1-vincent.guittot@linaro.org
(cherry picked from commit 87e867b4269f29dac8190bca13912d08163a277f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index 11771ec3ee9f,0424a0af5f87..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -3087,11 -3094,9 +3087,11 @@@ static void reweight_entity(struct cfs_
  
  #ifdef CONFIG_SMP
  	do {
- 		u32 divider = LOAD_AVG_MAX - 1024 + se->avg.period_contrib;
+ 		u32 divider = get_pelt_divider(&se->avg);
  
  		se->avg.load_avg = div_u64(se_weight(se) * se->avg.load_sum, divider);
 +		se->avg.runnable_load_avg =
 +			div_u64(se_runnable(se) * se->avg.runnable_load_sum, divider);
  	} while (0);
  #endif
  
@@@ -3481,18 -3440,17 +3481,29 @@@ static inline voi
  update_tg_cfs_util(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)
  {
  	long delta = gcfs_rq->avg.util_avg - se->avg.util_avg;
++<<<<<<< HEAD
++=======
+ 	u32 divider;
++>>>>>>> 87e867b4269f (sched/pelt: Cleanup PELT divider)
  
  	/* Nothing to update */
  	if (!delta)
  		return;
  
  	/*
++<<<<<<< HEAD
 +	 * The relation between sum and avg is:
 +	 *
 +	 *   LOAD_AVG_MAX - 1024 + sa->period_contrib
 +	 *
 +	 * however, the PELT windows are not aligned between grq and gse.
 +	 */
++=======
+ 	 * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.
+ 	 * See ___update_load_avg() for details.
+ 	 */
+ 	divider = get_pelt_divider(&cfs_rq->avg);
++>>>>>>> 87e867b4269f (sched/pelt: Cleanup PELT divider)
  
  	/* Set new sched_entity's utilization */
  	se->avg.util_avg = gcfs_rq->avg.util_avg;
@@@ -3506,16 -3464,48 +3517,53 @@@
  static inline void
  update_tg_cfs_runnable(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)
  {
++<<<<<<< HEAD
++=======
+ 	long delta = gcfs_rq->avg.runnable_avg - se->avg.runnable_avg;
+ 	u32 divider;
+ 
+ 	/* Nothing to update */
+ 	if (!delta)
+ 		return;
+ 
+ 	/*
+ 	 * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.
+ 	 * See ___update_load_avg() for details.
+ 	 */
+ 	divider = get_pelt_divider(&cfs_rq->avg);
+ 
+ 	/* Set new sched_entity's runnable */
+ 	se->avg.runnable_avg = gcfs_rq->avg.runnable_avg;
+ 	se->avg.runnable_sum = se->avg.runnable_avg * divider;
+ 
+ 	/* Update parent cfs_rq runnable */
+ 	add_positive(&cfs_rq->avg.runnable_avg, delta);
+ 	cfs_rq->avg.runnable_sum = cfs_rq->avg.runnable_avg * divider;
+ }
+ 
+ static inline void
+ update_tg_cfs_load(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)
+ {
++>>>>>>> 87e867b4269f (sched/pelt: Cleanup PELT divider)
  	long delta_avg, running_sum, runnable_sum = gcfs_rq->prop_runnable_sum;
 -	unsigned long load_avg;
 -	u64 load_sum = 0;
 +	unsigned long runnable_load_avg, load_avg;
 +	u64 runnable_load_sum, load_sum = 0;
  	s64 delta_sum;
 -	u32 divider;
  
  	if (!runnable_sum)
  		return;
  
  	gcfs_rq->prop_runnable_sum = 0;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.
+ 	 * See ___update_load_avg() for details.
+ 	 */
+ 	divider = get_pelt_divider(&cfs_rq->avg);
+ 
++>>>>>>> 87e867b4269f (sched/pelt: Cleanup PELT divider)
  	if (runnable_sum >= 0) {
  		/*
  		 * Add runnable; clip at LOAD_AVG_MAX. Reflects that until
@@@ -3715,7 -3701,11 +3763,15 @@@ update_cfs_rq_load_avg(u64 now, struct 
   */
  static void attach_entity_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se)
  {
++<<<<<<< HEAD
 +	u32 divider = LOAD_AVG_MAX - 1024 + cfs_rq->avg.period_contrib;
++=======
+ 	/*
+ 	 * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.
+ 	 * See ___update_load_avg() for details.
+ 	 */
+ 	u32 divider = get_pelt_divider(&cfs_rq->avg);
++>>>>>>> 87e867b4269f (sched/pelt: Cleanup PELT divider)
  
  	/*
  	 * When we attach the @se to the @cfs_rq, we must align the decay
* Unmerged path kernel/sched/fair.c
diff --git a/kernel/sched/pelt.c b/kernel/sched/pelt.c
index 9127d3b48596..ff935b06be4b 100644
--- a/kernel/sched/pelt.c
+++ b/kernel/sched/pelt.c
@@ -238,7 +238,7 @@ ___update_load_sum(u64 now, struct sched_avg *sa,
 static __always_inline void
 ___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)
 {
-	u32 divider = LOAD_AVG_MAX - 1024 + sa->period_contrib;
+	u32 divider = get_pelt_divider(sa);
 
 	/*
 	 * Step 2: update *_avg.
diff --git a/kernel/sched/pelt.h b/kernel/sched/pelt.h
index afff644da065..f1bb3527124d 100644
--- a/kernel/sched/pelt.h
+++ b/kernel/sched/pelt.h
@@ -17,6 +17,11 @@ update_irq_load_avg(struct rq *rq, u64 running)
 }
 #endif
 
+static inline u32 get_pelt_divider(struct sched_avg *avg)
+{
+	return LOAD_AVG_MAX - 1024 + avg->period_contrib;
+}
+
 /*
  * When a task is dequeued, its estimated utilization should not be update if
  * its util_avg has not been updated at least once.
