mm: Convert page migration to XArray

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit 89eb946a7432be639b452fac295c0c2e5186c4a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/89eb946a.failed

	Signed-off-by: Matthew Wilcox <willy@infradead.org>
(cherry picked from commit 89eb946a7432be639b452fac295c0c2e5186c4a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/migrate.c
diff --cc mm/migrate.c
index 60059875287d,b3cde3fd094a..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -324,9 -323,11 +324,17 @@@ void __migration_entry_wait(struct mm_s
  	page = migration_entry_to_page(entry);
  
  	/*
++<<<<<<< HEAD
 +	 * Once radix-tree replacement of page migration started, page_count
 +	 * is zero; but we must not call put_and_wait_on_page_locked() without
 +	 * a ref. Use get_page_unless_zero(), and just fault again if it fails.
++=======
+ 	 * Once page cache replacement of page migration started, page_count
+ 	 * *must* be zero. And, we don't want to call wait_on_page_locked()
+ 	 * against a page without get_page().
+ 	 * So, we use get_page_unless_zero(), here. Even failed, page fault
+ 	 * will occur again.
++>>>>>>> 89eb946a7432 (mm: Convert page migration to XArray)
  	 */
  	if (!get_page_unless_zero(page))
  		goto out;
@@@ -450,10 -438,17 +458,22 @@@ int migrate_page_move_mapping(struct ad
  		struct buffer_head *head, enum migrate_mode mode,
  		int extra_count)
  {
+ 	XA_STATE(xas, &mapping->i_pages, page_index(page));
  	struct zone *oldzone, *newzone;
  	int dirty;
++<<<<<<< HEAD
 +	void **pslot;
 +	int expected_count = expected_page_refs(mapping, page) + extra_count;
++=======
+ 	int expected_count = 1 + extra_count;
+ 
+ 	/*
+ 	 * Device public or private pages have an extra refcount as they are
+ 	 * ZONE_DEVICE pages.
+ 	 */
+ 	expected_count += is_device_private_page(page);
+ 	expected_count += is_device_public_page(page);
++>>>>>>> 89eb946a7432 (mm: Convert page migration to XArray)
  
  	if (!mapping) {
  		/* Anonymous page without mapping */
@@@ -472,15 -467,11 +492,18 @@@
  	oldzone = page_zone(page);
  	newzone = page_zone(newpage);
  
- 	xa_lock_irq(&mapping->i_pages);
- 
- 	pslot = radix_tree_lookup_slot(&mapping->i_pages,
-  					page_index(page));
+ 	xas_lock_irq(&xas);
  
++<<<<<<< HEAD
 +	if (page_count(page) != expected_count ||
 +		radix_tree_deref_slot_protected(pslot,
 +					&mapping->i_pages.xa_lock) != page) {
 +		xa_unlock_irq(&mapping->i_pages);
++=======
+ 	expected_count += hpage_nr_pages(page) + page_has_private(page);
+ 	if (page_count(page) != expected_count || xas_load(&xas) != page) {
+ 		xas_unlock_irq(&xas);
++>>>>>>> 89eb946a7432 (mm: Convert page migration to XArray)
  		return -EAGAIN;
  	}
  
* Unmerged path mm/migrate.c
