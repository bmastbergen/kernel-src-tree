pwm: Ensure pwm_apply_state() doesn't modify the state argument

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
commit 71523d1812aca61e32e742e87ec064e3d8c615e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/71523d18.failed

It is surprising for a PWM consumer when the variable holding the
requested state is modified by pwm_apply_state(). Consider for example a
driver doing:

        #define PERIOD 5000000
        #define DUTY_LITTLE 10
        ...
        struct pwm_state state = {
                .period = PERIOD,
                .duty_cycle = DUTY_LITTLE,
                .polarity = PWM_POLARITY_NORMAL,
                .enabled = true,
        };

        pwm_apply_state(mypwm, &state);
        ...
        state.duty_cycle = PERIOD / 2;
        pwm_apply_state(mypwm, &state);

For sure the second call to pwm_apply_state() should still have
state.period = PERIOD and not something the hardware driver chose for a
reason that doesn't necessarily apply to the second call.

So declare the state argument as a pointer to a const type and adapt all
drivers' .apply callbacks.

	Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
	Signed-off-by: Thierry Reding <thierry.reding@gmail.com>
(cherry picked from commit 71523d1812aca61e32e742e87ec064e3d8c615e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pwm/pwm-fsl-ftm.c
#	drivers/pwm/pwm-imx-tpm.c
#	drivers/pwm/pwm-imx27.c
#	drivers/pwm/pwm-jz4740.c
#	drivers/pwm/pwm-meson.c
#	drivers/pwm/pwm-rcar.c
#	drivers/pwm/pwm-sifive.c
#	drivers/pwm/pwm-sprd.c
#	include/linux/pwm.h
diff --cc drivers/pwm/pwm-fsl-ftm.c
index 557b4ea16796,59272a920479..000000000000
--- a/drivers/pwm/pwm-fsl-ftm.c
+++ b/drivers/pwm/pwm-fsl-ftm.c
@@@ -204,149 -180,175 +204,186 @@@ static unsigned long fsl_pwm_calculate_
  		m1 = FSL_PWM_CLK_FIX;
  	}
  
 -	ret = fsl_pwm_calculate_period_clk(fpc, period_ns, m0, periodcfg);
 -	if (ret)
 -		return true;
 +	cycles = fsl_pwm_calculate_period_cycles(fpc, period_ns, m0);
 +	if (cycles) {
 +		fpc->cnt_select = m0;
 +		return cycles;
 +	}
 +
 +	fpc->cnt_select = m1;
  
 -	return fsl_pwm_calculate_period_clk(fpc, period_ns, m1, periodcfg);
 +	return fsl_pwm_calculate_period_cycles(fpc, period_ns, m1);
  }
  
 -static unsigned int fsl_pwm_calculate_duty(struct fsl_pwm_chip *fpc,
 -					   unsigned int duty_ns)
 +static unsigned long fsl_pwm_calculate_duty(struct fsl_pwm_chip *fpc,
 +					    unsigned long period_ns,
 +					    unsigned long duty_ns)
  {
  	unsigned long long duty;
 +	u32 val;
  
 -	unsigned int period = fpc->period.mod_period + 1;
 -	unsigned int period_ns = fsl_pwm_ticks_to_ns(fpc, period);
 -
 -	duty = (unsigned long long)duty_ns * period;
 +	regmap_read(fpc->regmap, FTM_MOD, &val);
 +	duty = (unsigned long long)duty_ns * (val + 1);
  	do_div(duty, period_ns);
  
 -	return (unsigned int)duty;
 +	return (unsigned long)duty;
  }
  
 -static bool fsl_pwm_is_any_pwm_enabled(struct fsl_pwm_chip *fpc,
 -				       struct pwm_device *pwm)
 +static int fsl_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 +			  int duty_ns, int period_ns)
  {
 -	u32 val;
 +	struct fsl_pwm_chip *fpc = to_fsl_chip(chip);
 +	u32 period, duty;
  
 -	regmap_read(fpc->regmap, FTM_OUTMASK, &val);
 -	if (~val & 0xFF)
 -		return true;
 -	else
 -		return false;
 -}
 +	mutex_lock(&fpc->lock);
  
++<<<<<<< HEAD
++=======
+ static bool fsl_pwm_is_other_pwm_enabled(struct fsl_pwm_chip *fpc,
+ 					 struct pwm_device *pwm)
+ {
+ 	u32 val;
+ 
+ 	regmap_read(fpc->regmap, FTM_OUTMASK, &val);
+ 	if (~(val | BIT(pwm->hwpwm)) & 0xFF)
+ 		return true;
+ 	else
+ 		return false;
+ }
+ 
+ static int fsl_pwm_apply_config(struct fsl_pwm_chip *fpc,
+ 				struct pwm_device *pwm,
+ 				const struct pwm_state *newstate)
+ {
+ 	unsigned int duty;
+ 	u32 reg_polarity;
+ 
+ 	struct fsl_pwm_periodcfg periodcfg;
+ 	bool do_write_period = false;
+ 
+ 	if (!fsl_pwm_calculate_period(fpc, newstate->period, &periodcfg)) {
+ 		dev_err(fpc->chip.dev, "failed to calculate new period\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!fsl_pwm_is_any_pwm_enabled(fpc, pwm))
+ 		do_write_period = true;
++>>>>>>> 71523d1812ac (pwm: Ensure pwm_apply_state() doesn't modify the state argument)
  	/*
  	 * The Freescale FTM controller supports only a single period for
 -	 * all PWM channels, therefore verify if the newly computed period
 -	 * is different than the current period being used. In such case
 -	 * we allow to change the period only if no other pwm is running.
 +	 * all PWM channels, therefore incompatible changes need to be
 +	 * refused.
  	 */
 -	else if (!fsl_pwm_periodcfg_are_equal(&fpc->period, &periodcfg)) {
 -		if (fsl_pwm_is_other_pwm_enabled(fpc, pwm)) {
 -			dev_err(fpc->chip.dev,
 -				"Cannot change period for PWM %u, disable other PWMs first\n",
 -				pwm->hwpwm);
 -			return -EBUSY;
 -		}
 -		if (fpc->period.clk_select != periodcfg.clk_select) {
 -			int ret;
 -			enum fsl_pwm_clk oldclk = fpc->period.clk_select;
 -			enum fsl_pwm_clk newclk = periodcfg.clk_select;
 -
 -			ret = clk_prepare_enable(fpc->clk[newclk]);
 -			if (ret)
 -				return ret;
 -			clk_disable_unprepare(fpc->clk[oldclk]);
 -		}
 -		do_write_period = true;
 +	if (fpc->period_ns && fpc->period_ns != period_ns) {
 +		dev_err(fpc->chip.dev,
 +			"conflicting period requested for PWM %u\n",
 +			pwm->hwpwm);
 +		mutex_unlock(&fpc->lock);
 +		return -EBUSY;
  	}
  
 -	ftm_clear_write_protection(fpc);
 +	if (!fpc->period_ns && duty_ns) {
 +		period = fsl_pwm_calculate_period(fpc, period_ns);
 +		if (!period) {
 +			dev_err(fpc->chip.dev, "failed to calculate period\n");
 +			mutex_unlock(&fpc->lock);
 +			return -EINVAL;
 +		}
  
 -	if (do_write_period) {
 -		regmap_update_bits(fpc->regmap, FTM_SC, FTM_SC_CLK_MASK,
 -				   FTM_SC_CLK(periodcfg.clk_select));
  		regmap_update_bits(fpc->regmap, FTM_SC, FTM_SC_PS_MASK,
 -				   periodcfg.clk_ps);
 -		regmap_write(fpc->regmap, FTM_MOD, periodcfg.mod_period);
 +				   fpc->clk_ps);
 +		regmap_write(fpc->regmap, FTM_MOD, period - 1);
  
 -		fpc->period = periodcfg;
 +		fpc->period_ns = period_ns;
  	}
  
 -	duty = fsl_pwm_calculate_duty(fpc, newstate->duty_cycle);
 +	mutex_unlock(&fpc->lock);
 +
 +	duty = fsl_pwm_calculate_duty(fpc, period_ns, duty_ns);
  
  	regmap_write(fpc->regmap, FTM_CSC(pwm->hwpwm),
  		     FTM_CSC_MSB | FTM_CSC_ELSB);
  	regmap_write(fpc->regmap, FTM_CV(pwm->hwpwm), duty);
  
 -	reg_polarity = 0;
 -	if (newstate->polarity == PWM_POLARITY_INVERSED)
 -		reg_polarity = BIT(pwm->hwpwm);
 +	return 0;
 +}
  
 -	regmap_update_bits(fpc->regmap, FTM_POL, BIT(pwm->hwpwm), reg_polarity);
 +static int fsl_pwm_set_polarity(struct pwm_chip *chip,
 +				struct pwm_device *pwm,
 +				enum pwm_polarity polarity)
 +{
 +	struct fsl_pwm_chip *fpc = to_fsl_chip(chip);
 +	u32 val;
 +
 +	regmap_read(fpc->regmap, FTM_POL, &val);
 +
 +	if (polarity == PWM_POLARITY_INVERSED)
 +		val |= BIT(pwm->hwpwm);
 +	else
 +		val &= ~BIT(pwm->hwpwm);
 +
 +	regmap_write(fpc->regmap, FTM_POL, val);
 +
 +	return 0;
 +}
 +
++<<<<<<< HEAD
 +static int fsl_counter_clock_enable(struct fsl_pwm_chip *fpc)
 +{
 +	int ret;
 +
 +	/* select counter clock source */
 +	regmap_update_bits(fpc->regmap, FTM_SC, FTM_SC_CLK_MASK,
 +			   FTM_SC_CLK(fpc->cnt_select));
 +
 +	ret = clk_prepare_enable(fpc->clk[fpc->cnt_select]);
 +	if (ret)
 +		return ret;
  
 -	ftm_set_write_protection(fpc);
 +	ret = clk_prepare_enable(fpc->clk[FSL_PWM_CLK_CNTEN]);
 +	if (ret) {
 +		clk_disable_unprepare(fpc->clk[fpc->cnt_select]);
 +		return ret;
 +	}
  
  	return 0;
  }
  
 +static int fsl_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
++=======
+ static int fsl_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+ 			 const struct pwm_state *newstate)
++>>>>>>> 71523d1812ac (pwm: Ensure pwm_apply_state() doesn't modify the state argument)
  {
  	struct fsl_pwm_chip *fpc = to_fsl_chip(chip);
 -	struct pwm_state *oldstate = &pwm->state;
 -	int ret = 0;
 -
 -	/*
 -	 * oldstate to newstate : action
 -	 *
 -	 * disabled to disabled : ignore
 -	 * enabled to disabled : disable
 -	 * enabled to enabled : update settings
 -	 * disabled to enabled : update settings + enable
 -	 */
 +	int ret;
  
  	mutex_lock(&fpc->lock);
 +	regmap_update_bits(fpc->regmap, FTM_OUTMASK, BIT(pwm->hwpwm), 0);
  
 -	if (!newstate->enabled) {
 -		if (oldstate->enabled) {
 -			regmap_update_bits(fpc->regmap, FTM_OUTMASK,
 -					   BIT(pwm->hwpwm), BIT(pwm->hwpwm));
 -			clk_disable_unprepare(fpc->clk[FSL_PWM_CLK_CNTEN]);
 -			clk_disable_unprepare(fpc->clk[fpc->period.clk_select]);
 -		}
 +	ret = fsl_counter_clock_enable(fpc);
 +	mutex_unlock(&fpc->lock);
  
 -		goto end_mutex;
 -	}
 +	return ret;
 +}
  
 -	ret = fsl_pwm_apply_config(fpc, pwm, newstate);
 -	if (ret)
 -		goto end_mutex;
 -
 -	/* check if need to enable */
 -	if (!oldstate->enabled) {
 -		ret = clk_prepare_enable(fpc->clk[fpc->period.clk_select]);
 -		if (ret)
 -			goto end_mutex;
 -
 -		ret = clk_prepare_enable(fpc->clk[FSL_PWM_CLK_CNTEN]);
 -		if (ret) {
 -			clk_disable_unprepare(fpc->clk[fpc->period.clk_select]);
 -			goto end_mutex;
 -		}
 +static void fsl_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
 +{
 +	struct fsl_pwm_chip *fpc = to_fsl_chip(chip);
 +	u32 val;
  
 -		regmap_update_bits(fpc->regmap, FTM_OUTMASK, BIT(pwm->hwpwm),
 -				   0);
 -	}
 +	mutex_lock(&fpc->lock);
 +	regmap_update_bits(fpc->regmap, FTM_OUTMASK, BIT(pwm->hwpwm),
 +			   BIT(pwm->hwpwm));
 +
 +	clk_disable_unprepare(fpc->clk[FSL_PWM_CLK_CNTEN]);
 +	clk_disable_unprepare(fpc->clk[fpc->cnt_select]);
 +
 +	regmap_read(fpc->regmap, FTM_OUTMASK, &val);
 +	if ((val & 0xFF) == 0xFF)
 +		fpc->period_ns = 0;
  
 -end_mutex:
  	mutex_unlock(&fpc->lock);
 -	return ret;
  }
  
  static const struct pwm_ops fsl_pwm_ops = {
diff --cc drivers/pwm/pwm-jz4740.c
index a7b134af5e04,9d78cc21cb12..000000000000
--- a/drivers/pwm/pwm-jz4740.c
+++ b/drivers/pwm/pwm-jz4740.c
@@@ -83,8 -87,8 +83,13 @@@ static void jz4740_pwm_disable(struct p
  	jz4740_timer_disable(pwm->hwpwm);
  }
  
++<<<<<<< HEAD
 +static int jz4740_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 +			     int duty_ns, int period_ns)
++=======
+ static int jz4740_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+ 			    const struct pwm_state *state)
++>>>>>>> 71523d1812ac (pwm: Ensure pwm_apply_state() doesn't modify the state argument)
  {
  	struct jz4740_pwm_chip *jz4740 = to_jz4740(pwm->chip);
  	unsigned long long tmp;
diff --cc drivers/pwm/pwm-meson.c
index 822860b4801a,6245bbdb6e6c..000000000000
--- a/drivers/pwm/pwm-meson.c
+++ b/drivers/pwm/pwm-meson.c
@@@ -158,21 -158,19 +158,26 @@@ static void meson_pwm_free(struct pwm_c
  		clk_disable_unprepare(channel->clk);
  }
  
++<<<<<<< HEAD
 +static int meson_pwm_calc(struct meson_pwm *meson,
 +			  struct meson_pwm_channel *channel, unsigned int id,
 +			  unsigned int duty, unsigned int period)
++=======
+ static int meson_pwm_calc(struct meson_pwm *meson, struct pwm_device *pwm,
+ 			  const struct pwm_state *state)
++>>>>>>> 71523d1812ac (pwm: Ensure pwm_apply_state() doesn't modify the state argument)
  {
 -	struct meson_pwm_channel *channel = pwm_get_chip_data(pwm);
 -	unsigned int duty, period, pre_div, cnt, duty_cnt;
 +	unsigned int pre_div, cnt, duty_cnt;
  	unsigned long fin_freq = -1;
 +	u64 fin_ps;
  
 -	duty = state->duty_cycle;
 -	period = state->period;
 -
 -	if (state->polarity == PWM_POLARITY_INVERSED)
 +	if (~(meson->inverter_mask >> id) & 0x1)
  		duty = period - duty;
  
 +	if (period == channel->state.period &&
 +	    duty == channel->state.duty_cycle)
 +		return 0;
 +
  	fin_freq = clk_get_rate(channel->clk);
  	if (fin_freq == 0) {
  		dev_err(meson->chip.dev, "invalid source clock frequency\n");
diff --cc drivers/pwm/pwm-rcar.c
index 748f614d5375,852eb2347954..000000000000
--- a/drivers/pwm/pwm-rcar.c
+++ b/drivers/pwm/pwm-rcar.c
@@@ -188,11 -152,45 +188,21 @@@ static int rcar_pwm_enable(struct pwm_c
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void rcar_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
++=======
+ static void rcar_pwm_disable(struct rcar_pwm_chip *rp)
+ {
+ 	rcar_pwm_update(rp, RCAR_PWMCR_EN0, 0, RCAR_PWMCR);
+ }
+ 
+ static int rcar_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+ 			  const struct pwm_state *state)
++>>>>>>> 71523d1812ac (pwm: Ensure pwm_apply_state() doesn't modify the state argument)
  {
  	struct rcar_pwm_chip *rp = to_rcar_pwm_chip(chip);
 -	struct pwm_state cur_state;
 -	int div, ret;
 -
 -	/* This HW/driver only supports normal polarity */
 -	pwm_get_state(pwm, &cur_state);
 -	if (state->polarity != PWM_POLARITY_NORMAL)
 -		return -ENOTSUPP;
 -
 -	if (!state->enabled) {
 -		rcar_pwm_disable(rp);
 -		return 0;
 -	}
 -
 -	div = rcar_pwm_get_clock_division(rp, state->period);
 -	if (div < 0)
 -		return div;
 -
 -	rcar_pwm_update(rp, RCAR_PWMCR_SYNC, RCAR_PWMCR_SYNC, RCAR_PWMCR);
 -
 -	ret = rcar_pwm_set_counter(rp, div, state->duty_cycle, state->period);
 -	if (!ret)
 -		rcar_pwm_set_clock_control(rp, div);
 -
 -	/* The SYNC should be set to 0 even if rcar_pwm_set_counter failed */
 -	rcar_pwm_update(rp, RCAR_PWMCR_SYNC, 0, RCAR_PWMCR);
 -
 -	if (!ret)
 -		ret = rcar_pwm_enable(rp);
  
 -	return ret;
 +	rcar_pwm_update(rp, RCAR_PWMCR_EN0, 0, RCAR_PWMCR);
  }
  
  static const struct pwm_ops rcar_pwm_ops = {
diff --cc include/linux/pwm.h
index 56518adc31dd,b2c9c460947d..000000000000
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@@ -260,6 -259,15 +260,18 @@@ pwm_set_relative_duty_cycle(struct pwm_
  struct pwm_ops {
  	int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
  	void (*free)(struct pwm_chip *chip, struct pwm_device *pwm);
++<<<<<<< HEAD
++=======
+ 	int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm,
+ 		       struct pwm_capture *result, unsigned long timeout);
+ 	int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm,
+ 		     const struct pwm_state *state);
+ 	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
+ 			  struct pwm_state *state);
+ 	struct module *owner;
+ 
+ 	/* Only used by legacy drivers */
++>>>>>>> 71523d1812ac (pwm: Ensure pwm_apply_state() doesn't modify the state argument)
  	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,
  		      int duty_ns, int period_ns);
  	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
* Unmerged path drivers/pwm/pwm-imx-tpm.c
* Unmerged path drivers/pwm/pwm-imx27.c
* Unmerged path drivers/pwm/pwm-sifive.c
* Unmerged path drivers/pwm/pwm-sprd.c
diff --git a/drivers/gpio/gpio-mvebu.c b/drivers/gpio/gpio-mvebu.c
index 6c675c5accba..8c89b06f9b40 100644
--- a/drivers/gpio/gpio-mvebu.c
+++ b/drivers/gpio/gpio-mvebu.c
@@ -687,7 +687,7 @@ static void mvebu_pwm_get_state(struct pwm_chip *chip,
 }
 
 static int mvebu_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			   struct pwm_state *state)
+			   const struct pwm_state *state)
 {
 	struct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);
 	struct mvebu_gpio_chip *mvchip = mvpwm->mvchip;
diff --git a/drivers/pwm/core.c b/drivers/pwm/core.c
index 1581f6ab1b1f..41ccff3dc5f6 100644
--- a/drivers/pwm/core.c
+++ b/drivers/pwm/core.c
@@ -460,11 +460,9 @@ EXPORT_SYMBOL_GPL(pwm_free);
 /**
  * pwm_apply_state() - atomically apply a new state to a PWM device
  * @pwm: PWM device
- * @state: new state to apply. This can be adjusted by the PWM driver
- *	   if the requested config is not achievable, for example,
- *	   ->duty_cycle and ->period might be approximated.
+ * @state: new state to apply
  */
-int pwm_apply_state(struct pwm_device *pwm, struct pwm_state *state)
+int pwm_apply_state(struct pwm_device *pwm, const struct pwm_state *state)
 {
 	int err;
 
diff --git a/drivers/pwm/pwm-atmel-hlcdc.c b/drivers/pwm/pwm-atmel-hlcdc.c
index 54c6633d9b5d..20f3feb6ce4a 100644
--- a/drivers/pwm/pwm-atmel-hlcdc.c
+++ b/drivers/pwm/pwm-atmel-hlcdc.c
@@ -50,7 +50,7 @@ static inline struct atmel_hlcdc_pwm *to_atmel_hlcdc_pwm(struct pwm_chip *chip)
 }
 
 static int atmel_hlcdc_pwm_apply(struct pwm_chip *c, struct pwm_device *pwm,
-				 struct pwm_state *state)
+				 const struct pwm_state *state)
 {
 	struct atmel_hlcdc_pwm *chip = to_atmel_hlcdc_pwm(c);
 	struct atmel_hlcdc *hlcdc = chip->hlcdc;
diff --git a/drivers/pwm/pwm-atmel.c b/drivers/pwm/pwm-atmel.c
index 530d7dc5f1b5..9a6e345933b1 100644
--- a/drivers/pwm/pwm-atmel.c
+++ b/drivers/pwm/pwm-atmel.c
@@ -210,7 +210,7 @@ static void atmel_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm,
 }
 
 static int atmel_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			   struct pwm_state *state)
+			   const struct pwm_state *state)
 {
 	struct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);
 	struct pwm_state cstate;
diff --git a/drivers/pwm/pwm-bcm-iproc.c b/drivers/pwm/pwm-bcm-iproc.c
index d961a8207b1c..56c38cfae92c 100644
--- a/drivers/pwm/pwm-bcm-iproc.c
+++ b/drivers/pwm/pwm-bcm-iproc.c
@@ -115,7 +115,7 @@ static void iproc_pwmc_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
 }
 
 static int iproc_pwmc_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			    struct pwm_state *state)
+			    const struct pwm_state *state)
 {
 	unsigned long prescale = IPROC_PWM_PRESCALE_MIN;
 	struct iproc_pwmc *ip = to_iproc_pwmc(chip);
diff --git a/drivers/pwm/pwm-cros-ec.c b/drivers/pwm/pwm-cros-ec.c
index 9c13694eaa24..a208b4efdc84 100644
--- a/drivers/pwm/pwm-cros-ec.c
+++ b/drivers/pwm/pwm-cros-ec.c
@@ -96,7 +96,7 @@ static int cros_ec_pwm_get_duty(struct cros_ec_device *ec, u8 index)
 }
 
 static int cros_ec_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			     struct pwm_state *state)
+			     const struct pwm_state *state)
 {
 	struct cros_ec_pwm_device *ec_pwm = pwm_to_cros_ec_pwm(chip);
 	int duty_cycle;
* Unmerged path drivers/pwm/pwm-fsl-ftm.c
diff --git a/drivers/pwm/pwm-hibvt.c b/drivers/pwm/pwm-hibvt.c
index 27c107e78d59..57d88e8cad72 100644
--- a/drivers/pwm/pwm-hibvt.c
+++ b/drivers/pwm/pwm-hibvt.c
@@ -146,7 +146,7 @@ static void hibvt_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
 }
 
 static int hibvt_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-				struct pwm_state *state)
+			   const struct pwm_state *state)
 {
 	if (state->polarity != pwm->state.polarity)
 		hibvt_pwm_set_polarity(chip, pwm, state->polarity);
* Unmerged path drivers/pwm/pwm-imx-tpm.c
* Unmerged path drivers/pwm/pwm-imx27.c
* Unmerged path drivers/pwm/pwm-jz4740.c
diff --git a/drivers/pwm/pwm-lpss.c b/drivers/pwm/pwm-lpss.c
index 4721a264bac2..22ccc6d66c98 100644
--- a/drivers/pwm/pwm-lpss.c
+++ b/drivers/pwm/pwm-lpss.c
@@ -130,7 +130,7 @@ static inline void pwm_lpss_cond_enable(struct pwm_device *pwm, bool cond)
 }
 
 static int pwm_lpss_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			  struct pwm_state *state)
+			  const struct pwm_state *state)
 {
 	struct pwm_lpss_chip *lpwm = to_lpwm(chip);
 	int ret;
* Unmerged path drivers/pwm/pwm-meson.c
* Unmerged path drivers/pwm/pwm-rcar.c
diff --git a/drivers/pwm/pwm-rockchip.c b/drivers/pwm/pwm-rockchip.c
index 4d99d468df09..20d65e8ea236 100644
--- a/drivers/pwm/pwm-rockchip.c
+++ b/drivers/pwm/pwm-rockchip.c
@@ -102,7 +102,7 @@ static void rockchip_pwm_get_state(struct pwm_chip *chip,
 }
 
 static void rockchip_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
-			       struct pwm_state *state)
+			       const struct pwm_state *state)
 {
 	struct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);
 	unsigned long period, duty;
@@ -186,7 +186,7 @@ static int rockchip_pwm_enable(struct pwm_chip *chip,
 }
 
 static int rockchip_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			      struct pwm_state *state)
+			      const struct pwm_state *state)
 {
 	struct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);
 	struct pwm_state curstate;
* Unmerged path drivers/pwm/pwm-sifive.c
* Unmerged path drivers/pwm/pwm-sprd.c
diff --git a/drivers/pwm/pwm-stm32-lp.c b/drivers/pwm/pwm-stm32-lp.c
index 7c13e2505080..e4773f60773f 100644
--- a/drivers/pwm/pwm-stm32-lp.c
+++ b/drivers/pwm/pwm-stm32-lp.c
@@ -31,7 +31,7 @@ static inline struct stm32_pwm_lp *to_stm32_pwm_lp(struct pwm_chip *chip)
 #define STM32_LPTIM_MAX_PRESCALER	128
 
 static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			      struct pwm_state *state)
+			      const struct pwm_state *state)
 {
 	struct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);
 	unsigned long long prd, div, dty;
diff --git a/drivers/pwm/pwm-stm32.c b/drivers/pwm/pwm-stm32.c
index 4f842550fbd1..0b2dc4de7dd0 100644
--- a/drivers/pwm/pwm-stm32.c
+++ b/drivers/pwm/pwm-stm32.c
@@ -440,7 +440,7 @@ static void stm32_pwm_disable(struct stm32_pwm *priv, int ch)
 }
 
 static int stm32_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			   struct pwm_state *state)
+			   const struct pwm_state *state)
 {
 	bool enabled;
 	struct stm32_pwm *priv = to_stm32_pwm_dev(chip);
@@ -468,7 +468,7 @@ static int stm32_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 }
 
 static int stm32_pwm_apply_locked(struct pwm_chip *chip, struct pwm_device *pwm,
-				  struct pwm_state *state)
+				  const struct pwm_state *state)
 {
 	struct stm32_pwm *priv = to_stm32_pwm_dev(chip);
 	int ret;
diff --git a/drivers/pwm/pwm-sun4i.c b/drivers/pwm/pwm-sun4i.c
index 470d4f71e7eb..b17f9f9fcd5b 100644
--- a/drivers/pwm/pwm-sun4i.c
+++ b/drivers/pwm/pwm-sun4i.c
@@ -146,7 +146,7 @@ static void sun4i_pwm_get_state(struct pwm_chip *chip,
 }
 
 static int sun4i_pwm_calculate(struct sun4i_pwm_chip *sun4i_pwm,
-			       struct pwm_state *state,
+			       const struct pwm_state *state,
 			       u32 *dty, u32 *prd, unsigned int *prsclr)
 {
 	u64 clk_rate, div = 0;
@@ -203,7 +203,7 @@ static int sun4i_pwm_calculate(struct sun4i_pwm_chip *sun4i_pwm,
 }
 
 static int sun4i_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			   struct pwm_state *state)
+			   const struct pwm_state *state)
 {
 	struct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);
 	struct pwm_state cstate;
diff --git a/drivers/pwm/pwm-zx.c b/drivers/pwm/pwm-zx.c
index 5d27c16edfb1..d6da939a2e57 100644
--- a/drivers/pwm/pwm-zx.c
+++ b/drivers/pwm/pwm-zx.c
@@ -151,7 +151,7 @@ static int zx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 }
 
 static int zx_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			struct pwm_state *state)
+			const struct pwm_state *state)
 {
 	struct zx_pwm_chip *zpc = to_zx_pwm_chip(chip);
 	struct pwm_state cstate;
* Unmerged path include/linux/pwm.h
