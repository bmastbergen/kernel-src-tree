scsi: qla2xxx: Cast explicitly to uint16_t / uint32_t

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Bart Van Assche <bvanassche@acm.org>
commit ab053c09ee2066a2fe62a755f1e64dbc8eddc17c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ab053c09.failed

Casting a pointer to void * and relying on an implicit cast from void *
to uint16_t or uint32_t suppresses sparse warnings about endianness. Hence
cast explicitly to uint16_t and uint32_t. Additionally, remove superfluous
void * casts.

Link: https://lore.kernel.org/r/20200518211712.11395-13-bvanassche@acm.org
	Cc: Arun Easi <aeasi@marvell.com>
	Cc: Nilesh Javali <njavali@marvell.com>
	Cc: Daniel Wagner <dwagner@suse.de>
	Cc: Himanshu Madhani <himanshu.madhani@oracle.com>
	Cc: Martin Wilck <mwilck@suse.com>
	Cc: Roman Bolshakov <r.bolshakov@yadro.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Daniel Wagner <dwagner@suse.de>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit ab053c09ee2066a2fe62a755f1e64dbc8eddc17c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 344db146fcba,85c369fed9c5..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -5594,6 -5744,583 +5594,586 @@@ retry_lock
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ qla25xx_rdp_rsp_reduce_size(struct scsi_qla_host *vha,
+ 	struct purex_entry_24xx *purex)
+ {
+ 	char fwstr[16];
+ 	u32 sid = purex->s_id[2] << 16 | purex->s_id[1] << 8 | purex->s_id[0];
+ 	struct port_database_24xx *pdb;
+ 
+ 	/* Domain Controller is always logged-out. */
+ 	/* if RDP request is not from Domain Controller: */
+ 	if (sid != 0xfffc01)
+ 		return false;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0181, "%s: s_id=%#x\n", __func__, sid);
+ 
+ 	pdb = kzalloc(sizeof(*pdb), GFP_KERNEL);
+ 	if (!pdb) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Failed allocate pdb\n", __func__);
+ 	} else if (qla24xx_get_port_database(vha, purex->nport_handle, pdb)) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Failed get pdb sid=%x\n", __func__, sid);
+ 	} else if (pdb->current_login_state != PDS_PLOGI_COMPLETE &&
+ 	    pdb->current_login_state != PDS_PRLI_COMPLETE) {
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "%s: Port not logged in sid=%#x\n", __func__, sid);
+ 	} else {
+ 		/* RDP request is from logged in port */
+ 		kfree(pdb);
+ 		return false;
+ 	}
+ 	kfree(pdb);
+ 
+ 	vha->hw->isp_ops->fw_version_str(vha, fwstr, sizeof(fwstr));
+ 	fwstr[strcspn(fwstr, " ")] = 0;
+ 	/* if FW version allows RDP response length upto 2048 bytes: */
+ 	if (strcmp(fwstr, "8.09.00") > 0 || strcmp(fwstr, "8.05.65") == 0)
+ 		return false;
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0x0181, "%s: fw=%s\n", __func__, fwstr);
+ 
+ 	/* RDP response length is to be reduced to maximum 256 bytes */
+ 	return true;
+ }
+ 
+ static uint
+ qla25xx_rdp_port_speed_capability(struct qla_hw_data *ha)
+ {
+ 	if (IS_CNA_CAPABLE(ha))
+ 		return RDP_PORT_SPEED_10GB;
+ 
+ 	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
+ 		unsigned int speeds = 0;
+ 
+ 		if (ha->max_supported_speed == 2) {
+ 			if (ha->min_supported_speed <= 6)
+ 				speeds |= RDP_PORT_SPEED_64GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 2 ||
+ 		    ha->max_supported_speed == 1) {
+ 			if (ha->min_supported_speed <= 5)
+ 				speeds |= RDP_PORT_SPEED_32GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 2 ||
+ 		    ha->max_supported_speed == 1 ||
+ 		    ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 4)
+ 				speeds |= RDP_PORT_SPEED_16GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 1 ||
+ 		    ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 3)
+ 				speeds |= RDP_PORT_SPEED_8GB;
+ 		}
+ 
+ 		if (ha->max_supported_speed == 0) {
+ 			if (ha->min_supported_speed <= 2)
+ 				speeds |= RDP_PORT_SPEED_4GB;
+ 		}
+ 
+ 		return speeds;
+ 	}
+ 
+ 	if (IS_QLA2031(ha))
+ 		return RDP_PORT_SPEED_16GB|RDP_PORT_SPEED_8GB|
+ 		       RDP_PORT_SPEED_4GB;
+ 
+ 	if (IS_QLA25XX(ha))
+ 		return RDP_PORT_SPEED_8GB|RDP_PORT_SPEED_4GB|
+ 		       RDP_PORT_SPEED_2GB|RDP_PORT_SPEED_1GB;
+ 
+ 	if (IS_QLA24XX_TYPE(ha))
+ 		return RDP_PORT_SPEED_4GB|RDP_PORT_SPEED_2GB|
+ 		       RDP_PORT_SPEED_1GB;
+ 
+ 	if (IS_QLA23XX(ha))
+ 		return RDP_PORT_SPEED_2GB|RDP_PORT_SPEED_1GB;
+ 
+ 	return RDP_PORT_SPEED_1GB;
+ }
+ 
+ static uint
+ qla25xx_rdp_port_speed_currently(struct qla_hw_data *ha)
+ {
+ 	switch (ha->link_data_rate) {
+ 	case PORT_SPEED_1GB:
+ 		return RDP_PORT_SPEED_1GB;
+ 
+ 	case PORT_SPEED_2GB:
+ 		return RDP_PORT_SPEED_2GB;
+ 
+ 	case PORT_SPEED_4GB:
+ 		return RDP_PORT_SPEED_4GB;
+ 
+ 	case PORT_SPEED_8GB:
+ 		return RDP_PORT_SPEED_8GB;
+ 
+ 	case PORT_SPEED_10GB:
+ 		return RDP_PORT_SPEED_10GB;
+ 
+ 	case PORT_SPEED_16GB:
+ 		return RDP_PORT_SPEED_16GB;
+ 
+ 	case PORT_SPEED_32GB:
+ 		return RDP_PORT_SPEED_32GB;
+ 
+ 	case PORT_SPEED_64GB:
+ 		return RDP_PORT_SPEED_64GB;
+ 
+ 	default:
+ 		return RDP_PORT_SPEED_UNKNOWN;
+ 	}
+ }
+ 
+ /*
+  * Function Name: qla24xx_process_purex_iocb
+  *
+  * Description:
+  * Prepare a RDP response and send to Fabric switch
+  *
+  * PARAMETERS:
+  * vha:	SCSI qla host
+  * purex: RDP request received by HBA
+  */
+ void qla24xx_process_purex_rdp(struct scsi_qla_host *vha, void *pkt)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct purex_entry_24xx *purex = pkt;
+ 	dma_addr_t rsp_els_dma;
+ 	dma_addr_t rsp_payload_dma;
+ 	dma_addr_t stat_dma;
+ 	dma_addr_t bbc_dma;
+ 	dma_addr_t sfp_dma;
+ 	struct els_entry_24xx *rsp_els = NULL;
+ 	struct rdp_rsp_payload *rsp_payload = NULL;
+ 	struct link_statistics *stat = NULL;
+ 	struct buffer_credit_24xx *bbc = NULL;
+ 	uint8_t *sfp = NULL;
+ 	uint16_t sfp_flags = 0;
+ 	uint rsp_payload_length = sizeof(*rsp_payload);
+ 	int rval;
+ 
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0180,
+ 	    "%s: Enter\n", __func__);
+ 
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0181,
+ 	    "-------- ELS REQ -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0182,
+ 	    purex, sizeof(*purex));
+ 
+ 	if (qla25xx_rdp_rsp_reduce_size(vha, purex)) {
+ 		rsp_payload_length =
+ 		    offsetof(typeof(*rsp_payload), optical_elmt_desc);
+ 		ql_dbg(ql_dbg_init, vha, 0x0181,
+ 		    "Reducing RSP payload length to %u bytes...\n",
+ 		    rsp_payload_length);
+ 	}
+ 
+ 	rsp_els = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_els),
+ 	    &rsp_els_dma, GFP_KERNEL);
+ 	if (!rsp_els) {
+ 		ql_log(ql_log_warn, vha, 0x0183,
+ 		    "Failed allocate dma buffer ELS RSP.\n");
+ 		goto dealloc;
+ 	}
+ 
+ 	rsp_payload = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_payload),
+ 	    &rsp_payload_dma, GFP_KERNEL);
+ 	if (!rsp_payload) {
+ 		ql_log(ql_log_warn, vha, 0x0184,
+ 		    "Failed allocate dma buffer ELS RSP payload.\n");
+ 		goto dealloc;
+ 	}
+ 
+ 	sfp = dma_alloc_coherent(&ha->pdev->dev, SFP_RTDI_LEN,
+ 	    &sfp_dma, GFP_KERNEL);
+ 
+ 	stat = dma_alloc_coherent(&ha->pdev->dev, sizeof(*stat),
+ 	    &stat_dma, GFP_KERNEL);
+ 
+ 	bbc = dma_alloc_coherent(&ha->pdev->dev, sizeof(*bbc),
+ 	    &bbc_dma, GFP_KERNEL);
+ 
+ 	/* Prepare Response IOCB */
+ 	rsp_els->entry_type = ELS_IOCB_TYPE;
+ 	rsp_els->entry_count = 1;
+ 	rsp_els->sys_define = 0;
+ 	rsp_els->entry_status = 0;
+ 	rsp_els->handle = 0;
+ 	rsp_els->nport_handle = purex->nport_handle;
+ 	rsp_els->tx_dsd_count = 1;
+ 	rsp_els->vp_index = purex->vp_idx;
+ 	rsp_els->sof_type = EST_SOFI3;
+ 	rsp_els->rx_xchg_address = purex->rx_xchg_addr;
+ 	rsp_els->rx_dsd_count = 0;
+ 	rsp_els->opcode = purex->els_frame_payload[0];
+ 
+ 	rsp_els->d_id[0] = purex->s_id[0];
+ 	rsp_els->d_id[1] = purex->s_id[1];
+ 	rsp_els->d_id[2] = purex->s_id[2];
+ 
+ 	rsp_els->control_flags = EPD_ELS_ACC;
+ 	rsp_els->rx_byte_count = 0;
+ 	rsp_els->tx_byte_count = cpu_to_le32(rsp_payload_length);
+ 
+ 	put_unaligned_le64(rsp_payload_dma, &rsp_els->tx_address);
+ 	rsp_els->tx_len = rsp_els->tx_byte_count;
+ 
+ 	rsp_els->rx_address = 0;
+ 	rsp_els->rx_len = 0;
+ 
+ 	/* Prepare Response Payload */
+ 	rsp_payload->hdr.cmd = cpu_to_be32(0x2 << 24); /* LS_ACC */
+ 	rsp_payload->hdr.len = cpu_to_be32(
+ 	    rsp_els->tx_byte_count - sizeof(rsp_payload->hdr));
+ 
+ 	/* Link service Request Info Descriptor */
+ 	rsp_payload->ls_req_info_desc.desc_tag = cpu_to_be32(0x1);
+ 	rsp_payload->ls_req_info_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc));
+ 	rsp_payload->ls_req_info_desc.req_payload_word_0 =
+ 	    cpu_to_be32p((uint32_t *)purex->els_frame_payload);
+ 
+ 	/* Link service Request Info Descriptor 2 */
+ 	rsp_payload->ls_req_info_desc2.desc_tag = cpu_to_be32(0x1);
+ 	rsp_payload->ls_req_info_desc2.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc2));
+ 	rsp_payload->ls_req_info_desc2.req_payload_word_0 =
+ 	    cpu_to_be32p((uint32_t *)purex->els_frame_payload);
+ 
+ 
+ 	rsp_payload->sfp_diag_desc.desc_tag = cpu_to_be32(0x10000);
+ 	rsp_payload->sfp_diag_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->sfp_diag_desc));
+ 
+ 	if (sfp) {
+ 		/* SFP Flags */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x7, 2, 0);
+ 		if (!rval) {
+ 			/* SFP Flags bits 3-0: Port Tx Laser Type */
+ 			if (sfp[0] & BIT_2 || sfp[1] & (BIT_6|BIT_5))
+ 				sfp_flags |= BIT_0; /* short wave */
+ 			else if (sfp[0] & BIT_1)
+ 				sfp_flags |= BIT_1; /* long wave 1310nm */
+ 			else if (sfp[1] & BIT_4)
+ 				sfp_flags |= BIT_1|BIT_0; /* long wave 1550nm */
+ 		}
+ 
+ 		/* SFP Type */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x0, 1, 0);
+ 		if (!rval) {
+ 			sfp_flags |= BIT_4; /* optical */
+ 			if (sfp[0] == 0x3)
+ 				sfp_flags |= BIT_6; /* sfp+ */
+ 		}
+ 
+ 		rsp_payload->sfp_diag_desc.sfp_flags = cpu_to_be16(sfp_flags);
+ 
+ 		/* SFP Diagnostics */
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0x60, 10, 0);
+ 		if (!rval) {
+ 			uint16_t *trx = (uint16_t *)sfp; /* already be16 */
+ 			rsp_payload->sfp_diag_desc.temperature = trx[0];
+ 			rsp_payload->sfp_diag_desc.vcc = trx[1];
+ 			rsp_payload->sfp_diag_desc.tx_bias = trx[2];
+ 			rsp_payload->sfp_diag_desc.tx_power = trx[3];
+ 			rsp_payload->sfp_diag_desc.rx_power = trx[4];
+ 		}
+ 	}
+ 
+ 	/* Port Speed Descriptor */
+ 	rsp_payload->port_speed_desc.desc_tag = cpu_to_be32(0x10001);
+ 	rsp_payload->port_speed_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_speed_desc));
+ 	rsp_payload->port_speed_desc.speed_capab = cpu_to_be16(
+ 	    qla25xx_rdp_port_speed_capability(ha));
+ 	rsp_payload->port_speed_desc.operating_speed = cpu_to_be16(
+ 	    qla25xx_rdp_port_speed_currently(ha));
+ 
+ 	/* Link Error Status Descriptor */
+ 	rsp_payload->ls_err_desc.desc_tag = cpu_to_be32(0x10002);
+ 	rsp_payload->ls_err_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_err_desc));
+ 
+ 	if (stat) {
+ 		rval = qla24xx_get_isp_stats(vha, stat, stat_dma, 0);
+ 		if (!rval) {
+ 			rsp_payload->ls_err_desc.link_fail_cnt =
+ 			    cpu_to_be32(stat->link_fail_cnt);
+ 			rsp_payload->ls_err_desc.loss_sync_cnt =
+ 			    cpu_to_be32(stat->loss_sync_cnt);
+ 			rsp_payload->ls_err_desc.loss_sig_cnt =
+ 			    cpu_to_be32(stat->loss_sig_cnt);
+ 			rsp_payload->ls_err_desc.prim_seq_err_cnt =
+ 			    cpu_to_be32(stat->prim_seq_err_cnt);
+ 			rsp_payload->ls_err_desc.inval_xmit_word_cnt =
+ 			    cpu_to_be32(stat->inval_xmit_word_cnt);
+ 			rsp_payload->ls_err_desc.inval_crc_cnt =
+ 			    cpu_to_be32(stat->inval_crc_cnt);
+ 			rsp_payload->ls_err_desc.pn_port_phy_type |= BIT_6;
+ 		}
+ 	}
+ 
+ 	/* Portname Descriptor */
+ 	rsp_payload->port_name_diag_desc.desc_tag = cpu_to_be32(0x10003);
+ 	rsp_payload->port_name_diag_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_diag_desc));
+ 	memcpy(rsp_payload->port_name_diag_desc.WWNN,
+ 	    vha->node_name,
+ 	    sizeof(rsp_payload->port_name_diag_desc.WWNN));
+ 	memcpy(rsp_payload->port_name_diag_desc.WWPN,
+ 	    vha->port_name,
+ 	    sizeof(rsp_payload->port_name_diag_desc.WWPN));
+ 
+ 	/* F-Port Portname Descriptor */
+ 	rsp_payload->port_name_direct_desc.desc_tag = cpu_to_be32(0x10003);
+ 	rsp_payload->port_name_direct_desc.desc_len =
+ 	    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_direct_desc));
+ 	memcpy(rsp_payload->port_name_direct_desc.WWNN,
+ 	    vha->fabric_node_name,
+ 	    sizeof(rsp_payload->port_name_direct_desc.WWNN));
+ 	memcpy(rsp_payload->port_name_direct_desc.WWPN,
+ 	    vha->fabric_port_name,
+ 	    sizeof(rsp_payload->port_name_direct_desc.WWPN));
+ 
+ 	/* Bufer Credit Descriptor */
+ 	rsp_payload->buffer_credit_desc.desc_tag = cpu_to_be32(0x10006);
+ 	rsp_payload->buffer_credit_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->buffer_credit_desc));
+ 	rsp_payload->buffer_credit_desc.fcport_b2b = 0;
+ 	rsp_payload->buffer_credit_desc.attached_fcport_b2b = cpu_to_be32(0);
+ 	rsp_payload->buffer_credit_desc.fcport_rtt = cpu_to_be32(0);
+ 
+ 	if (bbc) {
+ 		memset(bbc, 0, sizeof(*bbc));
+ 		rval = qla24xx_get_buffer_credits(vha, bbc, bbc_dma);
+ 		if (!rval) {
+ 			rsp_payload->buffer_credit_desc.fcport_b2b =
+ 			    cpu_to_be32(LSW(bbc->parameter[0]));
+ 		}
+ 	}
+ 
+ 	if (rsp_payload_length < sizeof(*rsp_payload))
+ 		goto send;
+ 
+ 	/* Optical Element Descriptor, Temperature */
+ 	rsp_payload->optical_elmt_desc[0].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[0].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Voltage */
+ 	rsp_payload->optical_elmt_desc[1].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[1].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Tx Bias Current */
+ 	rsp_payload->optical_elmt_desc[2].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[2].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Tx Power */
+ 	rsp_payload->optical_elmt_desc[3].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[3].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 	/* Optical Element Descriptor, Rx Power */
+ 	rsp_payload->optical_elmt_desc[4].desc_tag = cpu_to_be32(0x10007);
+ 	rsp_payload->optical_elmt_desc[4].desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));
+ 
+ 	if (sfp) {
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0, 64, 0);
+ 		if (!rval) {
+ 			uint16_t *trx = (uint16_t *)sfp; /* already be16 */
+ 
+ 			/* Optical Element Descriptor, Temperature */
+ 			rsp_payload->optical_elmt_desc[0].high_alarm = trx[0];
+ 			rsp_payload->optical_elmt_desc[0].low_alarm = trx[1];
+ 			rsp_payload->optical_elmt_desc[0].high_warn = trx[2];
+ 			rsp_payload->optical_elmt_desc[0].low_warn = trx[3];
+ 			rsp_payload->optical_elmt_desc[0].element_flags =
+ 			    cpu_to_be32(1 << 28);
+ 
+ 			/* Optical Element Descriptor, Voltage */
+ 			rsp_payload->optical_elmt_desc[1].high_alarm = trx[4];
+ 			rsp_payload->optical_elmt_desc[1].low_alarm = trx[5];
+ 			rsp_payload->optical_elmt_desc[1].high_warn = trx[6];
+ 			rsp_payload->optical_elmt_desc[1].low_warn = trx[7];
+ 			rsp_payload->optical_elmt_desc[1].element_flags =
+ 			    cpu_to_be32(2 << 28);
+ 
+ 			/* Optical Element Descriptor, Tx Bias Current */
+ 			rsp_payload->optical_elmt_desc[2].high_alarm = trx[8];
+ 			rsp_payload->optical_elmt_desc[2].low_alarm = trx[9];
+ 			rsp_payload->optical_elmt_desc[2].high_warn = trx[10];
+ 			rsp_payload->optical_elmt_desc[2].low_warn = trx[11];
+ 			rsp_payload->optical_elmt_desc[2].element_flags =
+ 			    cpu_to_be32(3 << 28);
+ 
+ 			/* Optical Element Descriptor, Tx Power */
+ 			rsp_payload->optical_elmt_desc[3].high_alarm = trx[12];
+ 			rsp_payload->optical_elmt_desc[3].low_alarm = trx[13];
+ 			rsp_payload->optical_elmt_desc[3].high_warn = trx[14];
+ 			rsp_payload->optical_elmt_desc[3].low_warn = trx[15];
+ 			rsp_payload->optical_elmt_desc[3].element_flags =
+ 			    cpu_to_be32(4 << 28);
+ 
+ 			/* Optical Element Descriptor, Rx Power */
+ 			rsp_payload->optical_elmt_desc[4].high_alarm = trx[16];
+ 			rsp_payload->optical_elmt_desc[4].low_alarm = trx[17];
+ 			rsp_payload->optical_elmt_desc[4].high_warn = trx[18];
+ 			rsp_payload->optical_elmt_desc[4].low_warn = trx[19];
+ 			rsp_payload->optical_elmt_desc[4].element_flags =
+ 			    cpu_to_be32(5 << 28);
+ 		}
+ 
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 112, 64, 0);
+ 		if (!rval) {
+ 			/* Temperature high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[0].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 7 & 1) << 3 |
+ 				(sfp[0] >> 6 & 1) << 2 |
+ 				(sfp[4] >> 7 & 1) << 1 |
+ 				(sfp[4] >> 6 & 1) << 0);
+ 
+ 			/* Voltage high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[1].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 5 & 1) << 3 |
+ 				(sfp[0] >> 4 & 1) << 2 |
+ 				(sfp[4] >> 5 & 1) << 1 |
+ 				(sfp[4] >> 4 & 1) << 0);
+ 
+ 			/* Tx Bias Current high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[2].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 3 & 1) << 3 |
+ 				(sfp[0] >> 2 & 1) << 2 |
+ 				(sfp[4] >> 3 & 1) << 1 |
+ 				(sfp[4] >> 2 & 1) << 0);
+ 
+ 			/* Tx Power high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[3].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[0] >> 1 & 1) << 3 |
+ 				(sfp[0] >> 0 & 1) << 2 |
+ 				(sfp[4] >> 1 & 1) << 1 |
+ 				(sfp[4] >> 0 & 1) << 0);
+ 
+ 			/* Rx Power high/low alarm/warning */
+ 			rsp_payload->optical_elmt_desc[4].element_flags |=
+ 			    cpu_to_be32(
+ 				(sfp[1] >> 7 & 1) << 3 |
+ 				(sfp[1] >> 6 & 1) << 2 |
+ 				(sfp[5] >> 7 & 1) << 1 |
+ 				(sfp[5] >> 6 & 1) << 0);
+ 		}
+ 	}
+ 
+ 	/* Optical Product Data Descriptor */
+ 	rsp_payload->optical_prod_desc.desc_tag = cpu_to_be32(0x10008);
+ 	rsp_payload->optical_prod_desc.desc_len =
+ 		cpu_to_be32(RDP_DESC_LEN(rsp_payload->optical_prod_desc));
+ 
+ 	if (sfp) {
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 20, 64, 0);
+ 		if (!rval) {
+ 			memcpy(rsp_payload->optical_prod_desc.vendor_name,
+ 			    sfp + 0,
+ 			    sizeof(rsp_payload->optical_prod_desc.vendor_name));
+ 			memcpy(rsp_payload->optical_prod_desc.part_number,
+ 			    sfp + 20,
+ 			    sizeof(rsp_payload->optical_prod_desc.part_number));
+ 			memcpy(rsp_payload->optical_prod_desc.revision,
+ 			    sfp + 36,
+ 			    sizeof(rsp_payload->optical_prod_desc.revision));
+ 			memcpy(rsp_payload->optical_prod_desc.serial_number,
+ 			    sfp + 48,
+ 			    sizeof(rsp_payload->optical_prod_desc.serial_number));
+ 		}
+ 
+ 		memset(sfp, 0, SFP_RTDI_LEN);
+ 		rval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 84, 8, 0);
+ 		if (!rval) {
+ 			memcpy(rsp_payload->optical_prod_desc.date,
+ 			    sfp + 0,
+ 			    sizeof(rsp_payload->optical_prod_desc.date));
+ 		}
+ 	}
+ 
+ send:
+ 	ql_dbg(ql_dbg_init, vha, 0x0183,
+ 	    "Sending ELS Response to RDP Request...\n");
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0184,
+ 	    "-------- ELS RSP -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0185,
+ 	    rsp_els, sizeof(*rsp_els));
+ 	ql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0186,
+ 	    "-------- ELS RSP PAYLOAD -------\n");
+ 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0187,
+ 	    rsp_payload, rsp_payload_length);
+ 
+ 	rval = qla2x00_issue_iocb(vha, rsp_els, rsp_els_dma, 0);
+ 
+ 	if (rval) {
+ 		ql_log(ql_log_warn, vha, 0x0188,
+ 		    "%s: iocb failed to execute -> %x\n", __func__, rval);
+ 	} else if (rsp_els->comp_status) {
+ 		ql_log(ql_log_warn, vha, 0x0189,
+ 		    "%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\n",
+ 		    __func__, rsp_els->comp_status,
+ 		    rsp_els->error_subcode_1, rsp_els->error_subcode_2);
+ 	} else {
+ 		ql_dbg(ql_dbg_init, vha, 0x018a, "%s: done.\n", __func__);
+ 	}
+ 
+ dealloc:
+ 	if (bbc)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*bbc),
+ 		    bbc, bbc_dma);
+ 	if (stat)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*stat),
+ 		    stat, stat_dma);
+ 	if (sfp)
+ 		dma_free_coherent(&ha->pdev->dev, SFP_RTDI_LEN,
+ 		    sfp, sfp_dma);
+ 	if (rsp_payload)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_payload),
+ 		    rsp_payload, rsp_payload_dma);
+ 	if (rsp_els)
+ 		dma_free_coherent(&ha->pdev->dev, sizeof(*rsp_els),
+ 		    rsp_els, rsp_els_dma);
+ }
+ 
+ void qla24xx_process_purex_list(struct purex_list *list)
+ {
+ 	struct list_head head = LIST_HEAD_INIT(head);
+ 	struct purex_item *item, *next;
+ 	ulong flags;
+ 
+ 	spin_lock_irqsave(&list->lock, flags);
+ 	list_splice_init(&list->head, &head);
+ 	spin_unlock_irqrestore(&list->lock, flags);
+ 
+ 	list_for_each_entry_safe(item, next, &head, list) {
+ 		list_del(&item->list);
+ 		item->process_item(item->vha, &item->iocb);
+ 		kfree(item);
+ 	}
+ }
+ 
++>>>>>>> ab053c09ee20 (scsi: qla2xxx: Cast explicitly to uint16_t / uint32_t)
  void
  qla83xx_idc_unlock(scsi_qla_host_t *base_vha, uint16_t requester_id)
  {
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index fbd8cb5647b6..d020c23a5106 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -115,7 +115,7 @@ qla27xx_dump_mpi_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 {
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
 	dma_addr_t dump_dma = ha->gid_list_dma;
-	uint32_t *chunk = (void *)ha->gid_list;
+	uint32_t *chunk = (uint32_t *)ha->gid_list;
 	uint32_t dwords = qla2x00_gid_list_size(ha) / 4;
 	uint32_t stat;
 	ulong i, j, timer = 6000000;
@@ -195,7 +195,7 @@ qla24xx_dump_ram(struct qla_hw_data *ha, uint32_t addr, uint32_t *ram,
 	int rval = QLA_FUNCTION_FAILED;
 	struct device_reg_24xx __iomem *reg = &ha->iobase->isp24;
 	dma_addr_t dump_dma = ha->gid_list_dma;
-	uint32_t *chunk = (void *)ha->gid_list;
+	uint32_t *chunk = (uint32_t *)ha->gid_list;
 	uint32_t dwords = qla2x00_gid_list_size(ha) / 4;
 	uint32_t stat;
 	ulong i, j, timer = 6000000;
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index 4f49726a1556..bc264c25c172 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -992,7 +992,7 @@ static void qla24xx_async_gnl_sp_done(srb_t *sp, int res)
 
 		ql_dbg(ql_dbg_disc, vha, 0x20e8,
 		    "%s %8phC %02x:%02x:%02x CLS %x/%x lid %x \n",
-		    __func__, (void *)&wwn, e->port_id[2], e->port_id[1],
+		    __func__, &wwn, e->port_id[2], e->port_id[1],
 		    e->port_id[0], e->current_login_state, e->last_login_state,
 		    (loop_id & 0x7fff));
 	}
@@ -1343,7 +1343,7 @@ int qla24xx_async_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
 	mb[9] = vha->vp_idx;
 	mb[10] = opt;
 
-	mbx->u.mbx.in = (void *)pd;
+	mbx->u.mbx.in = pd;
 	mbx->u.mbx.in_dma = pd_dma;
 
 	sp->done = qla24xx_async_gpdb_sp_done;
@@ -4115,7 +4115,7 @@ qla2x00_init_rings(scsi_qla_host_t *vha)
 		req = ha->req_q_map[que];
 		if (!req || !test_bit(que, ha->req_qid_map))
 			continue;
-		req->out_ptr = (void *)(req->ring + req->length);
+		req->out_ptr = (uint16_t *)(req->ring + req->length);
 		*req->out_ptr = 0;
 		for (cnt = 1; cnt < req->num_outstanding_cmds; cnt++)
 			req->outstanding_cmds[cnt] = NULL;
@@ -4132,7 +4132,7 @@ qla2x00_init_rings(scsi_qla_host_t *vha)
 		rsp = ha->rsp_q_map[que];
 		if (!rsp || !test_bit(que, ha->rsp_qid_map))
 			continue;
-		rsp->in_ptr = (void *)(rsp->ring + rsp->length);
+		rsp->in_ptr = (uint16_t *)(rsp->ring + rsp->length);
 		*rsp->in_ptr = 0;
 		/* Initialize response queue entries */
 		if (IS_QLAFX00(ha))
@@ -7448,7 +7448,7 @@ qla27xx_check_image_status_signature(struct qla27xx_image_status *image_status)
 static ulong
 qla27xx_image_status_checksum(struct qla27xx_image_status *image_status)
 {
-	uint32_t *p = (void *)image_status;
+	uint32_t *p = (uint32_t *)image_status;
 	uint n = sizeof(*image_status) / sizeof(*p);
 	uint32_t sum = 0;
 
@@ -7511,7 +7511,7 @@ qla28xx_get_aux_images(
 		goto check_sec_image;
 	}
 
-	qla24xx_read_flash_data(vha, (void *)&pri_aux_image_status,
+	qla24xx_read_flash_data(vha, (uint32_t *)&pri_aux_image_status,
 	    ha->flt_region_aux_img_status_pri,
 	    sizeof(pri_aux_image_status) >> 2);
 	qla27xx_print_image(vha, "Primary aux image", &pri_aux_image_status);
@@ -7544,7 +7544,7 @@ qla28xx_get_aux_images(
 		goto check_valid_image;
 	}
 
-	qla24xx_read_flash_data(vha, (void *)&sec_aux_image_status,
+	qla24xx_read_flash_data(vha, (uint32_t *)&sec_aux_image_status,
 	    ha->flt_region_aux_img_status_sec,
 	    sizeof(sec_aux_image_status) >> 2);
 	qla27xx_print_image(vha, "Secondary aux image", &sec_aux_image_status);
@@ -7609,7 +7609,7 @@ qla27xx_get_active_image(struct scsi_qla_host *vha,
 		goto check_sec_image;
 	}
 
-	if (qla24xx_read_flash_data(vha, (void *)(&pri_image_status),
+	if (qla24xx_read_flash_data(vha, (uint32_t *)&pri_image_status,
 	    ha->flt_region_img_status_pri, sizeof(pri_image_status) >> 2) !=
 	    QLA_SUCCESS) {
 		WARN_ON_ONCE(true);
@@ -7716,7 +7716,7 @@ qla24xx_load_risc_flash(scsi_qla_host_t *vha, uint32_t *srisc_addr,
 	ql_dbg(ql_dbg_init, vha, 0x008b,
 	    "FW: Loading firmware from flash (%x).\n", faddr);
 
-	dcode = (void *)req->ring;
+	dcode = (uint32_t *)req->ring;
 	qla24xx_read_flash_data(vha, dcode, faddr, 8);
 	if (qla24xx_risc_firmware_invalid(dcode)) {
 		ql_log(ql_log_fatal, vha, 0x008c,
@@ -7729,7 +7729,7 @@ qla24xx_load_risc_flash(scsi_qla_host_t *vha, uint32_t *srisc_addr,
 		return QLA_FUNCTION_FAILED;
 	}
 
-	dcode = (void *)req->ring;
+	dcode = (uint32_t *)req->ring;
 	*srisc_addr = 0;
 	segments = FA_RISC_CODE_SEGMENTS;
 	for (j = 0; j < segments; j++) {
@@ -7780,7 +7780,7 @@ qla24xx_load_risc_flash(scsi_qla_host_t *vha, uint32_t *srisc_addr,
 		fwdt->template = NULL;
 		fwdt->length = 0;
 
-		dcode = (void *)req->ring;
+		dcode = (uint32_t *)req->ring;
 		qla24xx_read_flash_data(vha, dcode, faddr, 7);
 		risc_size = be32_to_cpu(dcode[2]);
 		ql_dbg(ql_dbg_init, vha, 0x0161,
@@ -7972,7 +7972,7 @@ qla24xx_load_risc_blob(scsi_qla_host_t *vha, uint32_t *srisc_addr)
 		return QLA_FUNCTION_FAILED;
 	}
 
-	fwcode = (void *)blob->fw->data;
+	fwcode = (uint32_t *)blob->fw->data;
 	dcode = fwcode;
 	if (qla24xx_risc_firmware_invalid(dcode)) {
 		ql_log(ql_log_fatal, vha, 0x0093,
@@ -7984,7 +7984,7 @@ qla24xx_load_risc_blob(scsi_qla_host_t *vha, uint32_t *srisc_addr)
 		return QLA_FUNCTION_FAILED;
 	}
 
-	dcode = (void *)req->ring;
+	dcode = (uint32_t *)req->ring;
 	*srisc_addr = 0;
 	segments = FA_RISC_CODE_SEGMENTS;
 	for (j = 0; j < segments; j++) {
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 946fa90e85de..942b378133ca 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -3030,7 +3030,7 @@ qla2x00_get_link_status(scsi_qla_host_t *vha, uint16_t loop_id,
 	int rval;
 	mbx_cmd_t mc;
 	mbx_cmd_t *mcp = &mc;
-	uint32_t *iter = (void *)stats;
+	uint32_t *iter = (uint32_t *)stats;
 	ushort dwords = offsetof(typeof(*stats), link_up_cnt)/sizeof(*iter);
 	struct qla_hw_data *ha = vha->hw;
 
@@ -3089,7 +3089,7 @@ qla24xx_get_isp_stats(scsi_qla_host_t *vha, struct link_statistics *stats,
 	int rval;
 	mbx_cmd_t mc;
 	mbx_cmd_t *mcp = &mc;
-	uint32_t *iter = (void *)stats;
+	uint32_t *iter = (uint32_t *)stats;
 	ushort dwords = sizeof(*stats)/sizeof(*iter);
 
 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1088,
@@ -4727,7 +4727,7 @@ qla82xx_set_driver_version(scsi_qla_host_t *vha, char *version)
 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x117b,
 	    "Entered %s.\n", __func__);
 
-	str = (void *)version;
+	str = (uint16_t *)version;
 	len = strlen(version);
 
 	mcp->mb[0] = MBC_SET_RNID_PARAMS;
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index a4a57323104f..4bba05f99059 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -763,7 +763,7 @@ qla25xx_create_req_que(struct qla_hw_data *ha, uint16_t options,
 	req->req_q_in = &reg->isp25mq.req_q_in;
 	req->req_q_out = &reg->isp25mq.req_q_out;
 	req->max_q_depth = ha->req_q_map[0]->max_q_depth;
-	req->out_ptr = (void *)(req->ring + req->length);
+	req->out_ptr = (uint16_t *)(req->ring + req->length);
 	mutex_unlock(&ha->mq_lock);
 	ql_dbg(ql_dbg_multiq, base_vha, 0xc004,
 	    "ring_ptr=%p ring_index=%d, "
@@ -877,7 +877,7 @@ qla25xx_create_rsp_que(struct qla_hw_data *ha, uint16_t options,
 	reg = ISP_QUE_REG(ha, que_id);
 	rsp->rsp_q_in = &reg->isp25mq.rsp_q_in;
 	rsp->rsp_q_out = &reg->isp25mq.rsp_q_out;
-	rsp->in_ptr = (void *)(rsp->ring + rsp->length);
+	rsp->in_ptr = (uint16_t *)(rsp->ring + rsp->length);
 	mutex_unlock(&ha->mq_lock);
 	ql_dbg(ql_dbg_multiq, base_vha, 0xc00b,
 	    "options=%x id=%d rsp_q_in=%p rsp_q_out=%p\n",
diff --git a/drivers/scsi/qla2xxx/qla_mr.c b/drivers/scsi/qla2xxx/qla_mr.c
index 05d3c1476667..7a7f1abca1e1 100644
--- a/drivers/scsi/qla2xxx/qla_mr.c
+++ b/drivers/scsi/qla2xxx/qla_mr.c
@@ -3212,7 +3212,7 @@ qlafx00_tm_iocb(srb_t *sp, struct tsk_mgmt_entry_fx00 *ptm_iocb)
 		    sizeof(struct scsi_lun));
 	}
 
-	memcpy((void *)ptm_iocb, &tm_iocb,
+	memcpy(ptm_iocb, &tm_iocb,
 	    sizeof(struct tsk_mgmt_entry_fx00));
 	wmb();
 }
@@ -3234,7 +3234,7 @@ qlafx00_abort_iocb(srb_t *sp, struct abort_iocb_entry_fx00 *pabt_iocb)
 	abt_iocb.tgt_id_sts = cpu_to_le16(sp->fcport->tgt_id);
 	abt_iocb.req_que_no = cpu_to_le16(req->id);
 
-	memcpy((void *)pabt_iocb, &abt_iocb,
+	memcpy(pabt_iocb, &abt_iocb,
 	    sizeof(struct abort_iocb_entry_fx00));
 	wmb();
 }
diff --git a/drivers/scsi/qla2xxx/qla_nvme.c b/drivers/scsi/qla2xxx/qla_nvme.c
index b2be9c40e3cd..52853fa5f9df 100644
--- a/drivers/scsi/qla2xxx/qla_nvme.c
+++ b/drivers/scsi/qla2xxx/qla_nvme.c
@@ -295,7 +295,7 @@ static int qla_nvme_ls_req(struct nvme_fc_local_port *lport,
 	sp->name = "nvme_ls";
 	sp->done = qla_nvme_sp_ls_done;
 	sp->put_fn = qla_nvme_release_ls_cmd_kref;
-	sp->priv = (void *)priv;
+	sp->priv = priv;
 	priv->sp = sp;
 	kref_init(&sp->cmd_kref);
 	spin_lock_init(&priv->cmd_lock);
@@ -565,7 +565,7 @@ static int qla_nvme_post_cmd(struct nvme_fc_local_port *lport,
 	init_waitqueue_head(&sp->nvme_ls_waitq);
 	kref_init(&sp->cmd_kref);
 	spin_lock_init(&priv->cmd_lock);
-	sp->priv = (void *)priv;
+	sp->priv = priv;
 	priv->sp = sp;
 	sp->type = SRB_NVME_CMD;
 	sp->name = "nvme_cmd";
diff --git a/drivers/scsi/qla2xxx/qla_nx2.c b/drivers/scsi/qla2xxx/qla_nx2.c
index a46830a99968..50e57603ce3d 100644
--- a/drivers/scsi/qla2xxx/qla_nx2.c
+++ b/drivers/scsi/qla2xxx/qla_nx2.c
@@ -2965,7 +2965,7 @@ qla8044_minidump_pex_dma_read(struct scsi_qla_host *vha,
 
 		/* Prepare: Write pex-dma descriptor to MS memory. */
 		rval = qla8044_ms_mem_write_128b(vha,
-		    m_hdr->desc_card_addr, (void *)&dma_desc,
+		    m_hdr->desc_card_addr, (uint32_t *)&dma_desc,
 		    (sizeof(struct qla8044_pex_dma_descriptor)/16));
 		if (rval) {
 			ql_log(ql_log_warn, vha, 0xb14a,
@@ -2987,7 +2987,7 @@ qla8044_minidump_pex_dma_read(struct scsi_qla_host *vha,
 		read_size += chunk_size;
 	}
 
-	*d_ptr = (void *)data_ptr;
+	*d_ptr = (uint32_t *)data_ptr;
 
 error_exit:
 	if (rdmem_buffer)
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
diff --git a/drivers/scsi/qla2xxx/qla_sup.c b/drivers/scsi/qla2xxx/qla_sup.c
index da984d7552d5..749b0c197d31 100644
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@ -553,7 +553,7 @@ qla2xxx_find_flt_start(scsi_qla_host_t *vha, uint32_t *start)
 	struct qla_hw_data *ha = vha->hw;
 	struct req_que *req = ha->req_q_map[0];
 	struct qla_flt_location *fltl = (void *)req->ring;
-	uint32_t *dcode = (void *)req->ring;
+	uint32_t *dcode = (uint32_t *)req->ring;
 	uint8_t *buf = (void *)req->ring, *bcode,  last_image;
 
 	/*
@@ -610,7 +610,7 @@ qla2xxx_find_flt_start(scsi_qla_host_t *vha, uint32_t *start)
 	if (memcmp(fltl->sig, "QFLT", 4))
 		goto end;
 
-	wptr = (void *)req->ring;
+	wptr = (uint16_t *)req->ring;
 	cnt = sizeof(*fltl) / sizeof(*wptr);
 	for (chksum = 0; cnt--; wptr++)
 		chksum += le16_to_cpu(*wptr);
@@ -682,7 +682,7 @@ qla2xxx_get_flt_info(scsi_qla_host_t *vha, uint32_t flt_addr)
 
 	ha->flt_region_flt = flt_addr;
 	wptr = (uint16_t *)ha->flt;
-	ha->isp_ops->read_optrom(vha, (void *)flt, flt_addr << 2,
+	ha->isp_ops->read_optrom(vha, flt, flt_addr << 2,
 	    (sizeof(struct qla_flt_header) + FLT_REGIONS_SIZE));
 
 	if (le16_to_cpu(*wptr) == 0xffff)
@@ -949,7 +949,7 @@ qla2xxx_get_fdt_info(scsi_qla_host_t *vha)
 	struct qla_hw_data *ha = vha->hw;
 	struct req_que *req = ha->req_q_map[0];
 	uint16_t cnt, chksum;
-	uint16_t *wptr = (void *)req->ring;
+	uint16_t *wptr = (uint16_t *)req->ring;
 	struct qla_fdt_layout *fdt = (struct qla_fdt_layout *)req->ring;
 	uint8_t	man_id, flash_id;
 	uint16_t mid = 0, fid = 0;
@@ -2610,7 +2610,7 @@ qla24xx_read_optrom_data(struct scsi_qla_host *vha, void *buf,
 	set_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);
 
 	/* Go with read. */
-	qla24xx_read_flash_data(vha, (void *)buf, offset >> 2, length >> 2);
+	qla24xx_read_flash_data(vha, buf, offset >> 2, length >> 2);
 
 	/* Resume HBA. */
 	clear_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);
@@ -3528,7 +3528,7 @@ qla24xx_get_flash_version(scsi_qla_host_t *vha, void *mbuf)
 
 	memset(ha->gold_fw_version, 0, sizeof(ha->gold_fw_version));
 	faddr = ha->flt_region_gold_fw;
-	qla24xx_read_flash_data(vha, (void *)dcode, ha->flt_region_gold_fw, 8);
+	qla24xx_read_flash_data(vha, dcode, ha->flt_region_gold_fw, 8);
 	if (qla24xx_risc_firmware_invalid(dcode)) {
 		ql_log(ql_log_warn, vha, 0x0056,
 		    "Unrecognized golden fw at %#x.\n", faddr);
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 49d1dd91b744..fb3a07f6c8d0 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -3896,7 +3896,7 @@ static void *qlt_ctio_to_cmd(struct scsi_qla_host *vha,
 			return NULL;
 		}
 
-		cmd = (void *) req->outstanding_cmds[h];
+		cmd = req->outstanding_cmds[h];
 		if (unlikely(cmd == NULL)) {
 			ql_dbg(ql_dbg_async, vha, 0xe053,
 			    "qla_target(%d): Suspicious: unable to find the command with handle %x req->id %d rsp->id %d\n",
@@ -5957,7 +5957,7 @@ void qlt_async_event(uint16_t code, struct scsi_qla_host *vha,
 		    le16_to_cpu(mailbox[2]), le16_to_cpu(mailbox[3]));
 		if (tgt->link_reinit_iocb_pending) {
 			qlt_send_notify_ack(ha->base_qpair,
-			    (void *)&tgt->link_reinit_iocb,
+			    &tgt->link_reinit_iocb,
 			    0, 0, 0, 0, 0, 0);
 			tgt->link_reinit_iocb_pending = 0;
 		}
