rcu/tree: docs: document bkvcache new members at struct kfree_rcu_cpu

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
commit 72a2fbda53d057081d0bca2db221995435fb0d1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/72a2fbda.failed

Changeset 53c72b590b3a ("rcu/tree: cache specified number of objects")
added new members for struct kfree_rcu_cpu, but didn't add the
corresponding at the kernel-doc markup, as repoted when doing
"make htmldocs":
	./kernel/rcu/tree.c:3113: warning: Function parameter or member 'bkvcache' not described in 'kfree_rcu_cpu'
	./kernel/rcu/tree.c:3113: warning: Function parameter or member 'nr_bkv_objs' not described in 'kfree_rcu_cpu'

So, move the description for bkvcache to kernel-doc, and add a
description for nr_bkv_objs.

Fixes: 53c72b590b3a ("rcu/tree: cache specified number of objects")
	Acked-by: Paul E. McKenney <paulmck@kernel.org>
	Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
(cherry picked from commit 72a2fbda53d057081d0bca2db221995435fb0d1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 4aa7b6bbcde6,03c54c3478b7..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -2702,7 -3020,14 +2702,18 @@@ struct kfree_rcu_cpu_work 
   * @lock: Synchronize access to this structure
   * @monitor_work: Promote @head to @head_free after KFREE_DRAIN_JIFFIES
   * @monitor_todo: Tracks whether a @monitor_work delayed work is pending
++<<<<<<< HEAD
 + * @initialized: The @lock and @rcu_work fields have been initialized
++=======
+  * @initialized: The @rcu_work fields have been initialized
+  * @count: Number of objects for which GP not started
+  * @bkvcache:
+  *	A simple cache list that contains objects for reuse purpose.
+  *	In order to save some per-cpu space the list is singular.
+  *	Even though it is lockless an access has to be protected by the
+  *	per-cpu lock.
+  * @nr_bkv_objs: number of allocated objects at @bkvcache.
++>>>>>>> 72a2fbda53d0 (rcu/tree: docs: document bkvcache new members at struct kfree_rcu_cpu)
   *
   * This is a per-CPU structure.  The reason that it is not included in
   * the rcu_data structure is to permit this code to be extracted from
@@@ -2716,9 -3042,69 +2727,15 @@@ struct kfree_rcu_cpu 
  	struct delayed_work monitor_work;
  	bool monitor_todo;
  	bool initialized;
++<<<<<<< HEAD
++=======
+ 	int count;
+ 	struct llist_head bkvcache;
+ 	int nr_bkv_objs;
++>>>>>>> 72a2fbda53d0 (rcu/tree: docs: document bkvcache new members at struct kfree_rcu_cpu)
  };
  
 -static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {
 -	.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),
 -};
 -
 -static __always_inline void
 -debug_rcu_bhead_unqueue(struct kvfree_rcu_bulk_data *bhead)
 -{
 -#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD
 -	int i;
 -
 -	for (i = 0; i < bhead->nr_records; i++)
 -		debug_rcu_head_unqueue((struct rcu_head *)(bhead->records[i]));
 -#endif
 -}
 -
 -static inline struct kfree_rcu_cpu *
 -krc_this_cpu_lock(unsigned long *flags)
 -{
 -	struct kfree_rcu_cpu *krcp;
 -
 -	local_irq_save(*flags);	// For safely calling this_cpu_ptr().
 -	krcp = this_cpu_ptr(&krc);
 -	raw_spin_lock(&krcp->lock);
 -
 -	return krcp;
 -}
 -
 -static inline void
 -krc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)
 -{
 -	raw_spin_unlock(&krcp->lock);
 -	local_irq_restore(flags);
 -}
 -
 -static inline struct kvfree_rcu_bulk_data *
 -get_cached_bnode(struct kfree_rcu_cpu *krcp)
 -{
 -	if (!krcp->nr_bkv_objs)
 -		return NULL;
 -
 -	krcp->nr_bkv_objs--;
 -	return (struct kvfree_rcu_bulk_data *)
 -		llist_del_first(&krcp->bkvcache);
 -}
 -
 -static inline bool
 -put_cached_bnode(struct kfree_rcu_cpu *krcp,
 -	struct kvfree_rcu_bulk_data *bnode)
 -{
 -	// Check the limit.
 -	if (krcp->nr_bkv_objs >= rcu_min_cached_objs)
 -		return false;
 -
 -	llist_add((struct llist_node *) bnode, &krcp->bkvcache);
 -	krcp->nr_bkv_objs++;
 -	return true;
 -
 -}
 +static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc);
  
  /*
   * This function is invoked in workqueue context after a grace period.
* Unmerged path kernel/rcu/tree.c
