arm64: Make use of ARCH_WORKAROUND_1 even when KVM is not enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [arm64] Make use of ARCH_WORKAROUND_1 even when KVM is not enabled (Auger Eric) [1882794]
Rebuild_FUZZ: 94.31%
commit-author Marc Zyngier <maz@kernel.org>
commit b11483ef5a502663732c6ca1b58d14ff9eedd6f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b11483ef.failed

We seem to be pretending that we don't have any firmware mitigation
when KVM is not compiled in, which is not quite expected.

Bring back the mitigation in this case.

Fixes: 4db61fef16a1 ("arm64: kvm: Modernize __smccc_workaround_1_smc_start annotations")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit b11483ef5a502663732c6ca1b58d14ff9eedd6f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/cpu_errata.c
diff --cc arch/arm64/kernel/cpu_errata.c
index 24102ebdf637,88966496806a..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -252,8 -236,14 +252,19 @@@ static int detect_harden_bp_fw(void
  
  	case SMCCC_CONDUIT_SMC:
  		cb = call_smc_arch_workaround_1;
++<<<<<<< HEAD
 +		smccc_start = __smccc_workaround_1_smc_start;
 +		smccc_end = __smccc_workaround_1_smc_end;
++=======
+ #if IS_ENABLED(CONFIG_KVM)
+ 		smccc_start = __smccc_workaround_1_smc;
+ 		smccc_end = __smccc_workaround_1_smc +
+ 			__SMCCC_WORKAROUND_1_SMC_SZ;
+ #else
+ 		smccc_start = NULL;
+ 		smccc_end = NULL;
+ #endif
++>>>>>>> b11483ef5a50 (arm64: Make use of ARCH_WORKAROUND_1 even when KVM is not enabled)
  		break;
  
  	default:
* Unmerged path arch/arm64/kernel/cpu_errata.c
