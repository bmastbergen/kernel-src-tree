powerpc: use the generic dma_ops_bypass mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit f1565c24b5965dfd2352f209c417ff160be04db9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f1565c24.failed

Use the DMA API bypass mechanism for direct window mappings.  This uses
common code and speed up the direct mapping case by avoiding indirect
calls just when not using dma ops at all.  It also fixes a problem where
the sync_* methods were using the bypass check for DMA allocations, but
those are part of the streaming ops.

Note that this patch loses the DMA_ATTR_WEAK_ORDERING override, which
has never been well defined, as is only used by a few drivers, which
IIRC never showed up in the typical Cell blade setups that are affected
by the ordering workaround.

Fixes: efd176a04bef ("powerpc/pseries/dma: Allow SWIOTLB")
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
(cherry picked from commit f1565c24b5965dfd2352f209c417ff160be04db9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/Kconfig
#	arch/powerpc/kernel/dma-iommu.c
diff --cc arch/powerpc/Kconfig
index 6e7bc68c7333,be868bfbe76e..000000000000
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@@ -146,12 -146,13 +146,17 @@@ config PP
  	select ARCH_USE_BUILTIN_BSWAP
  	select ARCH_USE_CMPXCHG_LOCKREF		if PPC64
  	select ARCH_WANT_IPC_PARSE_VERSION
 +	select ARCH_WANT_IRQS_OFF_ACTIVATE_MM
  	select ARCH_WEAK_RELEASE_ACQUIRE
  	select BINFMT_ELF
 -	select BUILDTIME_TABLE_SORT
 +	select BUILDTIME_EXTABLE_SORT
  	select CLONE_BACKWARDS
  	select DCACHE_WORD_ACCESS		if PPC64 && CPU_LITTLE_ENDIAN
++<<<<<<< HEAD
++=======
+ 	select DMA_OPS				if PPC64
+ 	select DMA_OPS_BYPASS			if PPC64
++>>>>>>> f1565c24b596 (powerpc: use the generic dma_ops_bypass mode)
  	select DYNAMIC_FTRACE			if FUNCTION_TRACER
  	select EDAC_ATOMIC_SCRUB
  	select EDAC_SUPPORT
diff --cc arch/powerpc/kernel/dma-iommu.c
index 809b28660b57,569fecd7b5b2..000000000000
--- a/arch/powerpc/kernel/dma-iommu.c
+++ b/arch/powerpc/kernel/dma-iommu.c
@@@ -14,23 -14,6 +14,26 @@@
   * Generic iommu implementation
   */
  
++<<<<<<< HEAD
 +/*
 + * The coherent mask may be smaller than the real mask, check if we can
 + * really use a direct window.
 + */
 +static inline bool dma_iommu_alloc_bypass(struct device *dev)
 +{
 +	return dev->iommu_bypass && !iommu_fixed_is_weak &&
 +		dma_direct_supported(dev, dev->coherent_dma_mask);
 +}
 +
 +static inline bool dma_iommu_map_bypass(struct device *dev,
 +		unsigned long attrs)
 +{
 +	return dev->iommu_bypass &&
 +		(!iommu_fixed_is_weak || (attrs & DMA_ATTR_WEAK_ORDERING));
 +}
 +
++=======
++>>>>>>> f1565c24b596 (powerpc: use the generic dma_ops_bypass mode)
  /* Allocates a contiguous real buffer and creates mappings over it.
   * Returns the virtual address of the buffer and sets dma_handle
   * to the dma address (mapping) of the first page.
@@@ -67,11 -44,8 +64,8 @@@ static dma_addr_t dma_iommu_map_page(st
  				     enum dma_data_direction direction,
  				     unsigned long attrs)
  {
- 	if (dma_iommu_map_bypass(dev, attrs))
- 		return dma_direct_map_page(dev, page, offset, size, direction,
- 				attrs);
  	return iommu_map_page(dev, get_iommu_table_base(dev), page, offset,
 -			      size, dma_get_mask(dev), direction, attrs);
 +			      size, device_to_mask(dev), direction, attrs);
  }
  
  
@@@ -91,10 -62,8 +82,8 @@@ static int dma_iommu_map_sg(struct devi
  			    int nelems, enum dma_data_direction direction,
  			    unsigned long attrs)
  {
- 	if (dma_iommu_map_bypass(dev, attrs))
- 		return dma_direct_map_sg(dev, sglist, nelems, direction, attrs);
  	return ppc_iommu_map_sg(dev, get_iommu_table_base(dev), sglist, nelems,
 -				dma_get_mask(dev), direction, attrs);
 +				device_to_mask(dev), direction, attrs);
  }
  
  static void dma_iommu_unmap_sg(struct device *dev, struct scatterlist *sglist,
@@@ -122,16 -89,15 +109,23 @@@ int dma_iommu_dma_supported(struct devi
  {
  	struct iommu_table *tbl = get_iommu_table_base(dev);
  
++<<<<<<< HEAD
 +	if (!tbl) {
 +		dev_info(dev, "Warning: IOMMU dma not supported: mask 0x%08llx"
 +			", table unavailable\n", mask);
 +		return 0;
++=======
+ 	if (dev_is_pci(dev) && dma_iommu_bypass_supported(dev, mask)) {
+ 		dev->dma_ops_bypass = true;
+ 		dev_dbg(dev, "iommu: 64-bit OK, using fixed ops\n");
+ 		return 1;
++>>>>>>> f1565c24b596 (powerpc: use the generic dma_ops_bypass mode)
  	}
  
 -	if (!tbl) {
 -		dev_err(dev, "Warning: IOMMU dma not supported: mask 0x%08llx, table unavailable\n", mask);
 -		return 0;
 +	if (dev_is_pci(dev) && dma_iommu_bypass_supported(dev, mask)) {
 +		dev->iommu_bypass = true;
 +		dev_dbg(dev, "iommu: 64-bit OK, using fixed ops\n");
 +		return 1;
  	}
  
  	if (tbl->it_offset > (mask >> tbl->it_page_shift)) {
@@@ -142,7 -108,7 +136,11 @@@
  	}
  
  	dev_dbg(dev, "iommu: not 64-bit, using default ops\n");
++<<<<<<< HEAD
 +	dev->iommu_bypass = false;
++=======
+ 	dev->dma_ops_bypass = false;
++>>>>>>> f1565c24b596 (powerpc: use the generic dma_ops_bypass mode)
  	return 1;
  }
  
* Unmerged path arch/powerpc/Kconfig
* Unmerged path arch/powerpc/kernel/dma-iommu.c
