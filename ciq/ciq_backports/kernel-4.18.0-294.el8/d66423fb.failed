bpf: Plug hole in struct bpf_sk_lookup_kern

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Lorenz Bauer <lmb@cloudflare.com>
commit d66423fbe11e141206f117b232916aa899d44959
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d66423fb.failed

As Alexei points out, struct bpf_sk_lookup_kern has two 4-byte holes.
This leads to suboptimal instructions being generated (IPv4, x86):

    1372                    struct bpf_sk_lookup_kern ctx = {
       0xffffffff81b87f30 <+624>:   xor    %eax,%eax
       0xffffffff81b87f32 <+626>:   mov    $0x6,%ecx
       0xffffffff81b87f37 <+631>:   lea    0x90(%rsp),%rdi
       0xffffffff81b87f3f <+639>:   movl   $0x110002,0x88(%rsp)
       0xffffffff81b87f4a <+650>:   rep stos %rax,%es:(%rdi)
       0xffffffff81b87f4d <+653>:   mov    0x8(%rsp),%eax
       0xffffffff81b87f51 <+657>:   mov    %r13d,0x90(%rsp)
       0xffffffff81b87f59 <+665>:   incl   %gs:0x7e4970a0(%rip)
       0xffffffff81b87f60 <+672>:   mov    %eax,0x8c(%rsp)
       0xffffffff81b87f67 <+679>:   movzwl 0x10(%rsp),%eax
       0xffffffff81b87f6c <+684>:   mov    %ax,0xa8(%rsp)
       0xffffffff81b87f74 <+692>:   movzwl 0x38(%rsp),%eax
       0xffffffff81b87f79 <+697>:   mov    %ax,0xaa(%rsp)

Fix this by moving around sport and dport. pahole confirms there
are no more holes:

    struct bpf_sk_lookup_kern {
        u16                        family;       /*     0     2 */
        u16                        protocol;     /*     2     2 */
        __be16                     sport;        /*     4     2 */
        u16                        dport;        /*     6     2 */
        struct {
                __be32             saddr;        /*     8     4 */
                __be32             daddr;        /*    12     4 */
        } v4;                                    /*     8     8 */
        struct {
                const struct in6_addr  * saddr;  /*    16     8 */
                const struct in6_addr  * daddr;  /*    24     8 */
        } v6;                                    /*    16    16 */
        struct sock *              selected_sk;  /*    32     8 */
        bool                       no_reuseport; /*    40     1 */

        /* size: 48, cachelines: 1, members: 8 */
        /* padding: 7 */
        /* last cacheline: 48 bytes */
    };

The assembly also doesn't contain the pesky rep stos anymore:

    1372                    struct bpf_sk_lookup_kern ctx = {
       0xffffffff81b87f60 <+624>:   movzwl 0x10(%rsp),%eax
       0xffffffff81b87f65 <+629>:   movq   $0x0,0xa8(%rsp)
       0xffffffff81b87f71 <+641>:   movq   $0x0,0xb0(%rsp)
       0xffffffff81b87f7d <+653>:   mov    %ax,0x9c(%rsp)
       0xffffffff81b87f85 <+661>:   movzwl 0x38(%rsp),%eax
       0xffffffff81b87f8a <+666>:   movq   $0x0,0xb8(%rsp)
       0xffffffff81b87f96 <+678>:   mov    %ax,0x9e(%rsp)
       0xffffffff81b87f9e <+686>:   mov    0x8(%rsp),%eax
       0xffffffff81b87fa2 <+690>:   movq   $0x0,0xc0(%rsp)
       0xffffffff81b87fae <+702>:   movl   $0x110002,0x98(%rsp)
       0xffffffff81b87fb9 <+713>:   mov    %eax,0xa0(%rsp)
       0xffffffff81b87fc0 <+720>:   mov    %r13d,0xa4(%rsp)

1: https://lore.kernel.org/bpf/CAADnVQKE6y9h2fwX6OS837v-Uf+aBXnT_JXiN_bbo2gitZQ3tA@mail.gmail.com/

Fixes: e9ddbb7707ff ("bpf: Introduce SK_LOOKUP program type with a dedicated attach point")
	Suggested-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
Link: https://lore.kernel.org/bpf/20200910110248.198326-1-lmb@cloudflare.com
(cherry picked from commit d66423fbe11e141206f117b232916aa899d44959)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/filter.h
diff --cc include/linux/filter.h
index dc3bd64e26c3,e962dd8117d8..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -1287,4 -1282,153 +1287,156 @@@ struct bpf_sockopt_kern 
  	s32		retval;
  };
  
++<<<<<<< HEAD
++=======
+ int copy_bpf_fprog_from_user(struct sock_fprog *dst, sockptr_t src, int len);
+ 
+ struct bpf_sk_lookup_kern {
+ 	u16		family;
+ 	u16		protocol;
+ 	__be16		sport;
+ 	u16		dport;
+ 	struct {
+ 		__be32 saddr;
+ 		__be32 daddr;
+ 	} v4;
+ 	struct {
+ 		const struct in6_addr *saddr;
+ 		const struct in6_addr *daddr;
+ 	} v6;
+ 	struct sock	*selected_sk;
+ 	bool		no_reuseport;
+ };
+ 
+ extern struct static_key_false bpf_sk_lookup_enabled;
+ 
+ /* Runners for BPF_SK_LOOKUP programs to invoke on socket lookup.
+  *
+  * Allowed return values for a BPF SK_LOOKUP program are SK_PASS and
+  * SK_DROP. Their meaning is as follows:
+  *
+  *  SK_PASS && ctx.selected_sk != NULL: use selected_sk as lookup result
+  *  SK_PASS && ctx.selected_sk == NULL: continue to htable-based socket lookup
+  *  SK_DROP                           : terminate lookup with -ECONNREFUSED
+  *
+  * This macro aggregates return values and selected sockets from
+  * multiple BPF programs according to following rules in order:
+  *
+  *  1. If any program returned SK_PASS and a non-NULL ctx.selected_sk,
+  *     macro result is SK_PASS and last ctx.selected_sk is used.
+  *  2. If any program returned SK_DROP return value,
+  *     macro result is SK_DROP.
+  *  3. Otherwise result is SK_PASS and ctx.selected_sk is NULL.
+  *
+  * Caller must ensure that the prog array is non-NULL, and that the
+  * array as well as the programs it contains remain valid.
+  */
+ #define BPF_PROG_SK_LOOKUP_RUN_ARRAY(array, ctx, func)			\
+ 	({								\
+ 		struct bpf_sk_lookup_kern *_ctx = &(ctx);		\
+ 		struct bpf_prog_array_item *_item;			\
+ 		struct sock *_selected_sk = NULL;			\
+ 		bool _no_reuseport = false;				\
+ 		struct bpf_prog *_prog;					\
+ 		bool _all_pass = true;					\
+ 		u32 _ret;						\
+ 									\
+ 		migrate_disable();					\
+ 		_item = &(array)->items[0];				\
+ 		while ((_prog = READ_ONCE(_item->prog))) {		\
+ 			/* restore most recent selection */		\
+ 			_ctx->selected_sk = _selected_sk;		\
+ 			_ctx->no_reuseport = _no_reuseport;		\
+ 									\
+ 			_ret = func(_prog, _ctx);			\
+ 			if (_ret == SK_PASS && _ctx->selected_sk) {	\
+ 				/* remember last non-NULL socket */	\
+ 				_selected_sk = _ctx->selected_sk;	\
+ 				_no_reuseport = _ctx->no_reuseport;	\
+ 			} else if (_ret == SK_DROP && _all_pass) {	\
+ 				_all_pass = false;			\
+ 			}						\
+ 			_item++;					\
+ 		}							\
+ 		_ctx->selected_sk = _selected_sk;			\
+ 		_ctx->no_reuseport = _no_reuseport;			\
+ 		migrate_enable();					\
+ 		_all_pass || _selected_sk ? SK_PASS : SK_DROP;		\
+ 	 })
+ 
+ static inline bool bpf_sk_lookup_run_v4(struct net *net, int protocol,
+ 					const __be32 saddr, const __be16 sport,
+ 					const __be32 daddr, const u16 dport,
+ 					struct sock **psk)
+ {
+ 	struct bpf_prog_array *run_array;
+ 	struct sock *selected_sk = NULL;
+ 	bool no_reuseport = false;
+ 
+ 	rcu_read_lock();
+ 	run_array = rcu_dereference(net->bpf.run_array[NETNS_BPF_SK_LOOKUP]);
+ 	if (run_array) {
+ 		struct bpf_sk_lookup_kern ctx = {
+ 			.family		= AF_INET,
+ 			.protocol	= protocol,
+ 			.v4.saddr	= saddr,
+ 			.v4.daddr	= daddr,
+ 			.sport		= sport,
+ 			.dport		= dport,
+ 		};
+ 		u32 act;
+ 
+ 		act = BPF_PROG_SK_LOOKUP_RUN_ARRAY(run_array, ctx, BPF_PROG_RUN);
+ 		if (act == SK_PASS) {
+ 			selected_sk = ctx.selected_sk;
+ 			no_reuseport = ctx.no_reuseport;
+ 		} else {
+ 			selected_sk = ERR_PTR(-ECONNREFUSED);
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 	*psk = selected_sk;
+ 	return no_reuseport;
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static inline bool bpf_sk_lookup_run_v6(struct net *net, int protocol,
+ 					const struct in6_addr *saddr,
+ 					const __be16 sport,
+ 					const struct in6_addr *daddr,
+ 					const u16 dport,
+ 					struct sock **psk)
+ {
+ 	struct bpf_prog_array *run_array;
+ 	struct sock *selected_sk = NULL;
+ 	bool no_reuseport = false;
+ 
+ 	rcu_read_lock();
+ 	run_array = rcu_dereference(net->bpf.run_array[NETNS_BPF_SK_LOOKUP]);
+ 	if (run_array) {
+ 		struct bpf_sk_lookup_kern ctx = {
+ 			.family		= AF_INET6,
+ 			.protocol	= protocol,
+ 			.v6.saddr	= saddr,
+ 			.v6.daddr	= daddr,
+ 			.sport		= sport,
+ 			.dport		= dport,
+ 		};
+ 		u32 act;
+ 
+ 		act = BPF_PROG_SK_LOOKUP_RUN_ARRAY(run_array, ctx, BPF_PROG_RUN);
+ 		if (act == SK_PASS) {
+ 			selected_sk = ctx.selected_sk;
+ 			no_reuseport = ctx.no_reuseport;
+ 		} else {
+ 			selected_sk = ERR_PTR(-ECONNREFUSED);
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 	*psk = selected_sk;
+ 	return no_reuseport;
+ }
+ #endif /* IS_ENABLED(CONFIG_IPV6) */
+ 
++>>>>>>> d66423fbe11e (bpf: Plug hole in struct bpf_sk_lookup_kern)
  #endif /* __LINUX_FILTER_H__ */
* Unmerged path include/linux/filter.h
