selftests: bpf: Pass program to bpf_prog_detach in flow_dissector

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Lorenz Bauer <lmb@cloudflare.com>
commit 1a1ad3c20a6fe0e8a4b570fbf835d7cc6e87a9d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1a1ad3c2.failed

Calling bpf_prog_detach is incorrect, since it takes target_fd as
its argument. The intention here is to pass it as attach_bpf_fd,
so use bpf_prog_detach2 and pass zero for target_fd.

Fixes: 06716e04a043 ("selftests/bpf: Extend test_flow_dissector to cover link creation")
	Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200629095630.7933-7-lmb@cloudflare.com
(cherry picked from commit 1a1ad3c20a6fe0e8a4b570fbf835d7cc6e87a9d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/prog_tests/flow_dissector.c
diff --cc tools/testing/selftests/bpf/prog_tests/flow_dissector.c
index 47548befbf41,f11f187990e9..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/flow_dissector.c
+++ b/tools/testing/selftests/bpf/prog_tests/flow_dissector.c
@@@ -474,6 -475,83 +474,86 @@@ static int init_prog_array(struct bpf_o
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void run_tests_skb_less(int tap_fd, struct bpf_map *keys)
+ {
+ 	int i, err, keys_fd;
+ 
+ 	keys_fd = bpf_map__fd(keys);
+ 	if (CHECK(keys_fd < 0, "bpf_map__fd", "err %d\n", keys_fd))
+ 		return;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(tests); i++) {
+ 		/* Keep in sync with 'flags' from eth_get_headlen. */
+ 		__u32 eth_get_headlen_flags =
+ 			BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG;
+ 		struct bpf_prog_test_run_attr tattr = {};
+ 		struct bpf_flow_keys flow_keys = {};
+ 		__u32 key = (__u32)(tests[i].keys.sport) << 16 |
+ 			    tests[i].keys.dport;
+ 
+ 		/* For skb-less case we can't pass input flags; run
+ 		 * only the tests that have a matching set of flags.
+ 		 */
+ 
+ 		if (tests[i].flags != eth_get_headlen_flags)
+ 			continue;
+ 
+ 		err = tx_tap(tap_fd, &tests[i].pkt, sizeof(tests[i].pkt));
+ 		CHECK(err < 0, "tx_tap", "err %d errno %d\n", err, errno);
+ 
+ 		err = bpf_map_lookup_elem(keys_fd, &key, &flow_keys);
+ 		CHECK_ATTR(err, tests[i].name, "bpf_map_lookup_elem %d\n", err);
+ 
+ 		CHECK_ATTR(err, tests[i].name, "skb-less err %d\n", err);
+ 		CHECK_FLOW_KEYS(tests[i].name, flow_keys, tests[i].keys);
+ 
+ 		err = bpf_map_delete_elem(keys_fd, &key);
+ 		CHECK_ATTR(err, tests[i].name, "bpf_map_delete_elem %d\n", err);
+ 	}
+ }
+ 
+ static void test_skb_less_prog_attach(struct bpf_flow *skel, int tap_fd)
+ {
+ 	int err, prog_fd;
+ 
+ 	prog_fd = bpf_program__fd(skel->progs._dissect);
+ 	if (CHECK(prog_fd < 0, "bpf_program__fd", "err %d\n", prog_fd))
+ 		return;
+ 
+ 	err = bpf_prog_attach(prog_fd, 0, BPF_FLOW_DISSECTOR, 0);
+ 	if (CHECK(err, "bpf_prog_attach", "err %d errno %d\n", err, errno))
+ 		return;
+ 
+ 	run_tests_skb_less(tap_fd, skel->maps.last_dissection);
+ 
+ 	err = bpf_prog_detach2(prog_fd, 0, BPF_FLOW_DISSECTOR);
+ 	CHECK(err, "bpf_prog_detach2", "err %d errno %d\n", err, errno);
+ }
+ 
+ static void test_skb_less_link_create(struct bpf_flow *skel, int tap_fd)
+ {
+ 	struct bpf_link *link;
+ 	int err, net_fd;
+ 
+ 	net_fd = open("/proc/self/ns/net", O_RDONLY);
+ 	if (CHECK(net_fd < 0, "open(/proc/self/ns/net)", "err %d\n", errno))
+ 		return;
+ 
+ 	link = bpf_program__attach_netns(skel->progs._dissect, net_fd);
+ 	if (CHECK(IS_ERR(link), "attach_netns", "err %ld\n", PTR_ERR(link)))
+ 		goto out_close;
+ 
+ 	run_tests_skb_less(tap_fd, skel->maps.last_dissection);
+ 
+ 	err = bpf_link__destroy(link);
+ 	CHECK(err, "bpf_link__destroy", "err %d\n", err);
+ out_close:
+ 	close(net_fd);
+ }
+ 
++>>>>>>> 1a1ad3c20a6f (selftests: bpf: Pass program to bpf_prog_detach in flow_dissector)
  void test_flow_dissector(void)
  {
  	int i, err, prog_fd, keys_fd = -1, tap_fd;
* Unmerged path tools/testing/selftests/bpf/prog_tests/flow_dissector.c
