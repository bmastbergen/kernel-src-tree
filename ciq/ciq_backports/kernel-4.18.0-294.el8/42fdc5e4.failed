blk-mq: remove the BLK_MQ_REQ_INTERNAL flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 42fdc5e49c2be97db112d410d07044e0e2c7d5bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/42fdc5e4.failed

Just check for a non-NULL elevator directly to make the code more clear.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 42fdc5e49c2be97db112d410d07044e0e2c7d5bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-tag.c
diff --cc block/blk-mq-tag.c
index 5e790d9ec58b,281367b04527..000000000000
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@@ -89,10 -90,9 +89,15 @@@ static inline bool hctx_may_queue(struc
  static int __blk_mq_get_tag(struct blk_mq_alloc_data *data,
  			    struct sbitmap_queue *bt)
  {
++<<<<<<< HEAD
 +	if (!(data->flags & BLK_MQ_REQ_INTERNAL) &&
 +	    !(data->flags & BLK_MQ_REQ_RESERVED) &&
 +	    !hctx_may_queue(data->hctx, bt))
++=======
+ 	if (!data->q->elevator && !hctx_may_queue(data->hctx, bt))
++>>>>>>> 42fdc5e49c2b (blk-mq: remove the BLK_MQ_REQ_INTERNAL flag)
  		return BLK_MQ_NO_TAG;
+ 
  	if (data->shallow_depth)
  		return __sbitmap_queue_get_shallow(bt, data->shallow_depth);
  	else
* Unmerged path block/blk-mq-tag.c
diff --git a/block/blk-mq.c b/block/blk-mq.c
index 50f2205ff855..d48ebc686310 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -277,7 +277,7 @@ static struct request *blk_mq_rq_ctx_init(struct blk_mq_alloc_data *data,
 	struct request *rq = tags->static_rqs[tag];
 	req_flags_t rq_flags = 0;
 
-	if (data->flags & BLK_MQ_REQ_INTERNAL) {
+	if (data->q->elevator) {
 		rq->tag = BLK_MQ_NO_TAG;
 		rq->internal_tag = tag;
 	} else {
@@ -362,8 +362,6 @@ static struct request *__blk_mq_alloc_request(struct blk_mq_alloc_data *data)
 		data->flags |= BLK_MQ_REQ_NOWAIT;
 
 	if (e) {
-		data->flags |= BLK_MQ_REQ_INTERNAL;
-
 		/*
 		 * Flush requests are special and go directly to the
 		 * dispatch list. Don't include reserved tags in the
@@ -378,7 +376,7 @@ static struct request *__blk_mq_alloc_request(struct blk_mq_alloc_data *data)
 retry:
 	data->ctx = blk_mq_get_ctx(q);
 	data->hctx = blk_mq_map_queue(q, data->cmd_flags, data->ctx);
-	if (!(data->flags & BLK_MQ_REQ_INTERNAL))
+	if (!e)
 		blk_mq_tag_busy(data->hctx);
 
 	/*
@@ -474,9 +472,7 @@ struct request *blk_mq_alloc_request_hctx(struct request_queue *q,
 	cpu = cpumask_first_and(data.hctx->cpumask, cpu_online_mask);
 	data.ctx = __blk_mq_get_ctx(q, cpu);
 
-	if (q->elevator)
-		data.flags |= BLK_MQ_REQ_INTERNAL;
-	else
+	if (!q->elevator)
 		blk_mq_tag_busy(data.hctx);
 
 	ret = -EWOULDBLOCK;
diff --git a/block/blk-mq.h b/block/blk-mq.h
index abd0e3d1a92b..e6c223964245 100644
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@ -164,7 +164,7 @@ struct blk_mq_alloc_data {
 
 static inline struct blk_mq_tags *blk_mq_tags_from_data(struct blk_mq_alloc_data *data)
 {
-	if (data->flags & BLK_MQ_REQ_INTERNAL)
+	if (data->q->elevator)
 		return data->hctx->sched_tags;
 
 	return data->hctx->tags;
diff --git a/include/linux/blk-mq.h b/include/linux/blk-mq.h
index 200eeffcb439..79b9f0131c90 100644
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@ -342,8 +342,6 @@ enum {
 	BLK_MQ_REQ_NOWAIT	= (__force blk_mq_req_flags_t)(1 << 0),
 	/* allocate from reserved pool */
 	BLK_MQ_REQ_RESERVED	= (__force blk_mq_req_flags_t)(1 << 1),
-	/* allocate internal/sched tag */
-	BLK_MQ_REQ_INTERNAL	= (__force blk_mq_req_flags_t)(1 << 2),
 	/* set RQF_PREEMPT */
 	BLK_MQ_REQ_PREEMPT	= (__force blk_mq_req_flags_t)(1 << 3),
 };
