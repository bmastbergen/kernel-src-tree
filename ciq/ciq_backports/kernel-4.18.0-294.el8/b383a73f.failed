fs/ext4: Introduce DAX inode flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit b383a73f2b832491a2f9e6e8ada26aad53b5763d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b383a73f.failed

Add a flag ([EXT4|FS]_DAX_FL) to preserve FS_XFLAG_DAX in the ext4
inode.

Set the flag to be user visible and changeable.  Set the flag to be
inherited.  Allow applications to change the flag at any time except if
it conflicts with the set of mutually exclusive flags (Currently VERITY,
ENCRYPT, JOURNAL_DATA).

Furthermore, restrict setting any of the exclusive flags if DAX is set.

While conceptually possible, we do not allow setting EXT4_DAX_FL while
at the same time clearing exclusion flags (or vice versa) for 2 reasons:

	1) The DAX flag does not take effect immediately which
	   introduces quite a bit of complexity
	2) There is no clear use case for being this flexible

Finally, on regular files, flag the inode to not be cached to facilitate
changing S_DAX on the next creation of the inode.

	Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Link: https://lore.kernel.org/r/20200528150003.828793-9-ira.weiny@intel.com
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit b383a73f2b832491a2f9e6e8ada26aad53b5763d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/ext4.h
#	fs/ext4/inode.c
#	fs/ext4/verity.c
diff --cc fs/ext4/ext4.h
index 3fa62516bbdb,598e00a9453f..000000000000
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@@ -402,14 -412,19 +402,26 @@@ struct flex_groups 
  #define EXT4_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
  #define EXT4_HUGE_FILE_FL               0x00040000 /* Set to each huge file */
  #define EXT4_EXTENTS_FL			0x00080000 /* Inode uses extents */
 -#define EXT4_VERITY_FL			0x00100000 /* Verity protected inode */
  #define EXT4_EA_INODE_FL	        0x00200000 /* Inode used for large EA */
++<<<<<<< HEAD
 +#define EXT4_EOFBLOCKS_FL		0x00400000 /* Blocks allocated beyond EOF */
++=======
+ /* 0x00400000 was formerly EXT4_EOFBLOCKS_FL */
+ 
+ #define EXT4_DAX_FL			0x02000000 /* Inode is DAX */
+ 
++>>>>>>> b383a73f2b83 (fs/ext4: Introduce DAX inode flag)
  #define EXT4_INLINE_DATA_FL		0x10000000 /* Inode has inline data. */
  #define EXT4_PROJINHERIT_FL		0x20000000 /* Create with parents projid */
 -#define EXT4_CASEFOLD_FL		0x40000000 /* Casefolded file */
  #define EXT4_RESERVED_FL		0x80000000 /* reserved for ext4 lib */
  
++<<<<<<< HEAD
 +#define EXT4_FL_USER_VISIBLE		0x304BDFFF /* User visible flags */
 +#define EXT4_FL_USER_MODIFIABLE		0x204BC0FF /* User modifiable flags */
++=======
+ #define EXT4_FL_USER_VISIBLE		0x725BDFFF /* User visible flags */
+ #define EXT4_FL_USER_MODIFIABLE		0x624BC0FF /* User modifiable flags */
++>>>>>>> b383a73f2b83 (fs/ext4: Introduce DAX inode flag)
  
  /* Flags we can manipulate with through EXT4_IOC_FSSETXATTR */
  #define EXT4_FL_XFLAG_VISIBLE		(EXT4_SYNC_FL | \
@@@ -424,10 -440,12 +437,15 @@@
  			   EXT4_SYNC_FL | EXT4_NODUMP_FL | EXT4_NOATIME_FL |\
  			   EXT4_NOCOMPR_FL | EXT4_JOURNAL_DATA_FL |\
  			   EXT4_NOTAIL_FL | EXT4_DIRSYNC_FL |\
++<<<<<<< HEAD
 +			   EXT4_PROJINHERIT_FL)
++=======
+ 			   EXT4_PROJINHERIT_FL | EXT4_CASEFOLD_FL |\
+ 			   EXT4_DAX_FL)
++>>>>>>> b383a73f2b83 (fs/ext4: Introduce DAX inode flag)
  
  /* Flags that are appropriate for regular files (all but dir-specific ones). */
 -#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL | EXT4_CASEFOLD_FL |\
 -			   EXT4_PROJINHERIT_FL))
 +#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL))
  
  /* Flags that are appropriate for non-directories/regular files. */
  #define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)
@@@ -472,8 -494,10 +494,13 @@@ enum 
  	EXT4_INODE_TOPDIR	= 17,	/* Top of directory hierarchies*/
  	EXT4_INODE_HUGE_FILE	= 18,	/* Set to each huge file */
  	EXT4_INODE_EXTENTS	= 19,	/* Inode uses extents */
 -	EXT4_INODE_VERITY	= 20,	/* Verity protected inode */
  	EXT4_INODE_EA_INODE	= 21,	/* Inode used for large EA */
++<<<<<<< HEAD
 +	EXT4_INODE_EOFBLOCKS	= 22,	/* Blocks allocated beyond EOF */
++=======
+ /* 22 was formerly EXT4_INODE_EOFBLOCKS */
+ 	EXT4_INODE_DAX		= 25,	/* Inode is DAX */
++>>>>>>> b383a73f2b83 (fs/ext4: Introduce DAX inode flag)
  	EXT4_INODE_INLINE_DATA	= 28,	/* Data in inode. */
  	EXT4_INODE_PROJINHERIT	= 29,	/* Create with parents projid */
  	EXT4_INODE_RESERVED	= 31,	/* reserved for ext4 lib */
diff --cc fs/ext4/inode.c
index 8e7de233296c,778b0dbe3da6..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -4736,10 -4412,17 +4736,21 @@@ static bool ext4_should_use_dax(struct 
  		return false;
  	if (ext4_test_inode_flag(inode, EXT4_INODE_ENCRYPT))
  		return false;
++<<<<<<< HEAD
 +	return true;
++=======
+ 	if (ext4_test_inode_flag(inode, EXT4_INODE_VERITY))
+ 		return false;
+ 	if (!test_bit(EXT4_FLAGS_BDEV_IS_DAX, &sbi->s_ext4_flags))
+ 		return false;
+ 	if (test_opt(inode->i_sb, DAX_ALWAYS))
+ 		return true;
+ 
+ 	return ext4_test_inode_flag(inode, EXT4_INODE_DAX);
++>>>>>>> b383a73f2b83 (fs/ext4: Introduce DAX inode flag)
  }
  
 -void ext4_set_inode_flags(struct inode *inode, bool init)
 +void ext4_set_inode_flags(struct inode *inode)
  {
  	unsigned int flags = EXT4_I(inode)->i_flags;
  	unsigned int new_fl = 0;
* Unmerged path fs/ext4/verity.c
* Unmerged path fs/ext4/ext4.h
* Unmerged path fs/ext4/inode.c
diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
index 1f47e6df3d10..3a1813449192 100644
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -292,6 +292,38 @@ static int ext4_ioctl_check_immutable(struct inode *inode, __u32 new_projid,
 	return 0;
 }
 
+static void ext4_dax_dontcache(struct inode *inode, unsigned int flags)
+{
+	struct ext4_inode_info *ei = EXT4_I(inode);
+
+	if (S_ISDIR(inode->i_mode))
+		return;
+
+	if (test_opt2(inode->i_sb, DAX_NEVER) ||
+	    test_opt(inode->i_sb, DAX_ALWAYS))
+		return;
+
+	if ((ei->i_flags ^ flags) & EXT4_DAX_FL)
+		d_mark_dontcache(inode);
+}
+
+static bool dax_compatible(struct inode *inode, unsigned int oldflags,
+			   unsigned int flags)
+{
+	if (flags & EXT4_DAX_FL) {
+		if ((oldflags & EXT4_DAX_MUT_EXCL) ||
+		     ext4_test_inode_state(inode,
+					  EXT4_STATE_VERITY_IN_PROGRESS)) {
+			return false;
+		}
+	}
+
+	if ((flags & EXT4_DAX_MUT_EXCL) && (oldflags & EXT4_DAX_FL))
+			return false;
+
+	return true;
+}
+
 static int ext4_ioctl_setflags(struct inode *inode,
 			       unsigned int flags)
 {
@@ -330,6 +362,12 @@ static int ext4_ioctl_setflags(struct inode *inode,
 		if (!capable(CAP_SYS_RESOURCE))
 			goto flags_out;
 	}
+
+	if (!dax_compatible(inode, oldflags, flags)) {
+		err = -EOPNOTSUPP;
+		goto flags_out;
+	}
+
 	if ((flags ^ oldflags) & EXT4_EXTENTS_FL)
 		migrate = 1;
 
@@ -370,6 +408,8 @@ static int ext4_ioctl_setflags(struct inode *inode,
 	if (err)
 		goto flags_err;
 
+	ext4_dax_dontcache(inode, flags);
+
 	for (i = 0, mask = 1; i < 32; i++, mask <<= 1) {
 		if (!(mask & EXT4_FL_USER_MODIFIABLE))
 			continue;
@@ -528,12 +568,15 @@ static inline __u32 ext4_iflags_to_xflags(unsigned long iflags)
 		xflags |= FS_XFLAG_NOATIME;
 	if (iflags & EXT4_PROJINHERIT_FL)
 		xflags |= FS_XFLAG_PROJINHERIT;
+	if (iflags & EXT4_DAX_FL)
+		xflags |= FS_XFLAG_DAX;
 	return xflags;
 }
 
 #define EXT4_SUPPORTED_FS_XFLAGS (FS_XFLAG_SYNC | FS_XFLAG_IMMUTABLE | \
 				  FS_XFLAG_APPEND | FS_XFLAG_NODUMP | \
-				  FS_XFLAG_NOATIME | FS_XFLAG_PROJINHERIT)
+				  FS_XFLAG_NOATIME | FS_XFLAG_PROJINHERIT | \
+				  FS_XFLAG_DAX)
 
 /* Transfer xflags flags to internal */
 static inline unsigned long ext4_xflags_to_iflags(__u32 xflags)
@@ -552,6 +595,8 @@ static inline unsigned long ext4_xflags_to_iflags(__u32 xflags)
 		iflags |= EXT4_NOATIME_FL;
 	if (xflags & FS_XFLAG_PROJINHERIT)
 		iflags |= EXT4_PROJINHERIT_FL;
+	if (xflags & FS_XFLAG_DAX)
+		iflags |= EXT4_DAX_FL;
 
 	return iflags;
 }
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 45de20b6730f..dfa98247b1de 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1332,6 +1332,9 @@ static int ext4_set_context(struct inode *inode, const void *ctx, size_t len,
 	if (WARN_ON_ONCE(IS_DAX(inode) && i_size_read(inode)))
 		return -EINVAL;
 
+	if (ext4_test_inode_flag(inode, EXT4_INODE_DAX))
+		return -EOPNOTSUPP;
+
 	res = ext4_convert_inline_data(inode);
 	if (res)
 		return res;
* Unmerged path fs/ext4/verity.c
diff --git a/include/uapi/linux/fs.h b/include/uapi/linux/fs.h
index 73e01918f996..a90169358bec 100644
--- a/include/uapi/linux/fs.h
+++ b/include/uapi/linux/fs.h
@@ -353,6 +353,7 @@ struct fscrypt_key {
 #define FS_EA_INODE_FL			0x00200000 /* Inode used for large EA */
 #define FS_EOFBLOCKS_FL			0x00400000 /* Reserved for ext4 */
 #define FS_NOCOW_FL			0x00800000 /* Do not cow file */
+#define FS_DAX_FL			0x02000000 /* Inode is DAX */
 #define FS_INLINE_DATA_FL		0x10000000 /* Reserved for ext4 */
 #define FS_PROJINHERIT_FL		0x20000000 /* Create with parents projid */
 #define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */
