mptcp: add missing memory scheduling in the rx path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 9c3f94e1681bb0ebd93390f014082042d8bc067a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9c3f94e1.failed

When moving the skbs from the subflow into the msk receive
queue, we must schedule there the required amount of memory.

Try to borrow the required memory from the subflow, if needed,
so that we leverage the existing TCP heuristic.

Fixes: 6771bfd9ee24 ("mptcp: update mptcp ack sequence from work queue")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
Link: https://lore.kernel.org/r/f6143a6193a083574f11b00dbf7b5ad151bc4ff4.1603810630.git.pabeni@redhat.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 9c3f94e1681bb0ebd93390f014082042d8bc067a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index fd713c3a206a,e7419fd15d84..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -156,15 -273,46 +156,52 @@@ static void __mptcp_move_skb(struct mpt
  
  	skb_ext_reset(skb);
  	skb_orphan(skb);
++<<<<<<< HEAD
++=======
+ 
+ 	/* try to fetch required memory from subflow */
+ 	if (!sk_rmem_schedule(sk, skb, skb->truesize)) {
+ 		if (ssk->sk_forward_alloc < skb->truesize)
+ 			goto drop;
+ 		__sk_mem_reclaim(ssk, skb->truesize);
+ 		if (!sk_rmem_schedule(sk, skb, skb->truesize))
+ 			goto drop;
+ 	}
+ 
+ 	/* the skb map_seq accounts for the skb offset:
+ 	 * mptcp_subflow_get_mapped_dsn() is based on the current tp->copied_seq
+ 	 * value
+ 	 */
+ 	MPTCP_SKB_CB(skb)->map_seq = mptcp_subflow_get_mapped_dsn(subflow);
+ 	MPTCP_SKB_CB(skb)->end_seq = MPTCP_SKB_CB(skb)->map_seq + copy_len;
++>>>>>>> 9c3f94e1681b (mptcp: add missing memory scheduling in the rx path)
  	MPTCP_SKB_CB(skb)->offset = offset;
 +	msk->ack_seq += copy_len;
  
 -	if (MPTCP_SKB_CB(skb)->map_seq == msk->ack_seq) {
 -		/* in sequence */
 -		WRITE_ONCE(msk->ack_seq, msk->ack_seq + copy_len);
 -		tail = skb_peek_tail(&sk->sk_receive_queue);
 -		if (tail && mptcp_try_coalesce(sk, tail, skb))
 -			return true;
 +	tail = skb_peek_tail(&sk->sk_receive_queue);
 +	if (tail && mptcp_try_coalesce(sk, tail, skb))
 +		return;
  
++<<<<<<< HEAD
 +	skb_set_owner_r(skb, sk);
 +	__skb_queue_tail(&sk->sk_receive_queue, skb);
++=======
+ 		skb_set_owner_r(skb, sk);
+ 		__skb_queue_tail(&sk->sk_receive_queue, skb);
+ 		return true;
+ 	} else if (after64(MPTCP_SKB_CB(skb)->map_seq, msk->ack_seq)) {
+ 		mptcp_data_queue_ofo(msk, skb);
+ 		return false;
+ 	}
+ 
+ 	/* old data, keep it simple and drop the whole pkt, sender
+ 	 * will retransmit as needed, if needed.
+ 	 */
+ 	MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_DUPDATA);
+ drop:
+ 	mptcp_drop(sk, skb);
+ 	return false;
++>>>>>>> 9c3f94e1681b (mptcp: add missing memory scheduling in the rx path)
  }
  
  static void mptcp_stop_timer(struct sock *sk)
* Unmerged path net/mptcp/protocol.c
