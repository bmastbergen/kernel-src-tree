tcp: rename request_sock cookie_ts bit to syncookie

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Florian Westphal <fw@strlen.de>
commit f8ace8d915b88bd1bbaac695de94650dbb25c7b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f8ace8d9.failed

Nowadays output function has a 'synack_type' argument that tells us when
the syn/ack is emitted via syncookies.

The request already tells us when timestamps are supported, so check
both to detect special timestamp for tcp option encoding is needed.

We could remove cookie_ts altogether, but a followup patch would
otherwise need to adjust function signatures to pass 'want_cookie' to
mptcp core.

This way, the 'existing' bit can be used.

	Suggested-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f8ace8d915b88bd1bbaac695de94650dbb25c7b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_output.c
diff --cc net/ipv4/tcp_output.c
index d91789f2fcaa,85ff417bda7f..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -3343,12 -3391,17 +3343,17 @@@ struct sk_buff *tcp_make_synack(const s
  	mss = tcp_mss_clamp(tp, dst_metric_advmss(dst));
  
  	memset(&opts, 0, sizeof(opts));
 -	now = tcp_clock_ns();
  #ifdef CONFIG_SYN_COOKIES
++<<<<<<< HEAD
 +	if (unlikely(req->cookie_ts))
 +		skb->skb_mstamp = cookie_init_timestamp(req);
++=======
+ 	if (unlikely(synack_type == TCP_SYNACK_COOKIE && ireq->tstamp_ok))
+ 		skb->skb_mstamp_ns = cookie_init_timestamp(req, now);
++>>>>>>> f8ace8d915b8 (tcp: rename request_sock cookie_ts bit to syncookie)
  	else
  #endif
 -	{
 -		skb->skb_mstamp_ns = now;
 -		if (!tcp_rsk(req)->snt_synack) /* Timestamp first SYNACK */
 -			tcp_rsk(req)->snt_synack = tcp_skb_timestamp_us(skb);
 -	}
 +		skb->skb_mstamp = tcp_clock_us();
  
  #ifdef CONFIG_TCP_MD5SIG
  	rcu_read_lock();
diff --git a/drivers/crypto/chelsio/chtls/chtls_cm.c b/drivers/crypto/chelsio/chtls/chtls_cm.c
index dc5a790d9b54..bda2626a84d9 100644
--- a/drivers/crypto/chelsio/chtls/chtls_cm.c
+++ b/drivers/crypto/chelsio/chtls/chtls_cm.c
@@ -1184,7 +1184,7 @@ static void chtls_pass_accept_request(struct sock *sk,
 
 	oreq->rsk_rcv_wnd = 0;
 	oreq->rsk_window_clamp = 0;
-	oreq->cookie_ts = 0;
+	oreq->syncookie = 0;
 	oreq->mss = 0;
 	oreq->ts_recent = 0;
 
diff --git a/include/net/request_sock.h b/include/net/request_sock.h
index 1653435f18f5..29402ec0cb0b 100644
--- a/include/net/request_sock.h
+++ b/include/net/request_sock.h
@@ -58,7 +58,7 @@ struct request_sock {
 	struct request_sock		*dl_next;
 	u16				mss;
 	u8				num_retrans; /* number of retransmits */
-	u8				cookie_ts:1; /* syncookie: encode tcpopts in timestamp */
+	u8				syncookie:1; /* syncookie: encode tcpopts in timestamp */
 	u8				num_timeout:7; /* number of timeouts */
 	u32				ts_recent;
 	struct timer_list		rsk_timer;
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 40a68f598da6..600f7ec2f763 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -6381,7 +6381,6 @@ static void tcp_openreq_init(struct request_sock *req,
 	struct inet_request_sock *ireq = inet_rsk(req);
 
 	req->rsk_rcv_wnd = 0;		/* So that tcp_send_synack() knows! */
-	req->cookie_ts = 0;
 	tcp_rsk(req)->rcv_isn = TCP_SKB_CB(skb)->seq;
 	tcp_rsk(req)->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;
 	tcp_rsk(req)->snt_synack = tcp_clock_us();
@@ -6536,6 +6535,7 @@ int tcp_conn_request(struct request_sock_ops *rsk_ops,
 	if (!req)
 		goto drop;
 
+	req->syncookie = want_cookie;
 	tcp_rsk(req)->af_specific = af_ops;
 	tcp_rsk(req)->ts_off = 0;
 #if IS_ENABLED(CONFIG_MPTCP)
@@ -6601,7 +6601,6 @@ int tcp_conn_request(struct request_sock_ops *rsk_ops,
 
 	if (want_cookie) {
 		isn = cookie_init_sequence(af_ops, sk, skb, &req->mss);
-		req->cookie_ts = tmp_opt.tstamp_ok;
 		if (!tmp_opt.tstamp_ok)
 			inet_rsk(req)->ecn_ok = 0;
 	}
* Unmerged path net/ipv4/tcp_output.c
