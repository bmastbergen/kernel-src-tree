mm, hotplug: move init_currently_empty_zone() under zone_span_lock protection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Wei Yang <richard.weiyang@gmail.com>
commit fa004ab7365ffa1e17e6b267d64798afccb94946
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fa004ab7.failed

During online_pages phase, pgdat->nr_zones will be updated in case this
zone is empty.

Currently the online_pages phase is protected by the global locks
(device_device_hotplug_lock and mem_hotplug_lock), which ensures there is
no contention during the update of nr_zones.

These global locks introduces scalability issues (especially the second
one), which slow down code relying on get_online_mems().  This is also a
preparation for not having to rely on get_online_mems() but instead some
more fine grained locks.

The patch moves init_currently_empty_zone under both zone_span_writelock
and pgdat_resize_lock because both the pgdat state is changed (nr_zones)
and the zone's start_pfn.  Also this patch changes the documentation of
node_size_lock to include the protection of nr_zones.

Link: http://lkml.kernel.org/r/20181203205016.14123-1-richard.weiyang@gmail.com
	Signed-off-by: Wei Yang <richard.weiyang@gmail.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Cc: David Hildenbrand <david@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit fa004ab7365ffa1e17e6b267d64798afccb94946)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mmzone.h
diff --cc include/linux/mmzone.h
index 31bf67ac9b4d,cc4a507d7ca4..000000000000
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@@ -715,10 -636,8 +715,15 @@@ typedef struct pglist_data 
  #endif
  #if defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)
  	/*
++<<<<<<< HEAD
 +	 * Must be held any time you expect node_start_pfn, node_present_pages
 +	 * or node_spanned_pages stay constant.
 +	 * Also synchronizes pgdat->first_deferred_pfn during deferred page
 +	 * init.
++=======
+ 	 * Must be held any time you expect node_start_pfn,
+ 	 * node_present_pages, node_spanned_pages or nr_zones to stay constant.
++>>>>>>> fa004ab7365f (mm, hotplug: move init_currently_empty_zone() under zone_span_lock protection)
  	 *
  	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to
  	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG
* Unmerged path include/linux/mmzone.h
diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c
index a089a7544722..a776a1cf4f43 100644
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@ -681,14 +681,13 @@ void __ref move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,
 	int nid = pgdat->node_id;
 	unsigned long flags;
 
-	if (zone_is_empty(zone))
-		init_currently_empty_zone(zone, start_pfn, nr_pages);
-
 	clear_zone_contiguous(zone);
 
 	/* TODO Huh pgdat is irqsave while zone is not. It used to be like that before */
 	pgdat_resize_lock(pgdat, &flags);
 	zone_span_writelock(zone);
+	if (zone_is_empty(zone))
+		init_currently_empty_zone(zone, start_pfn, nr_pages);
 	resize_zone_range(zone, start_pfn, nr_pages);
 	zone_span_writeunlock(zone);
 	resize_pgdat_range(pgdat, start_pfn, nr_pages);
