mptcp: rename add_addr_signal and mptcp_add_addr_status

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 13ad9f01a29e3f458fb3b319fb53323b2b0d1e68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/13ad9f01.failed

Since the RM_ADDR signal had been reused with add_addr_signal, it's not
suitable to call it add_addr_signal or mptcp_add_addr_status. So this
patch renamed add_addr_signal to addr_signal, and renamed
mptcp_add_addr_status to mptcp_addr_signal_status.

	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 13ad9f01a29e3f458fb3b319fb53323b2b0d1e68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/pm.c
#	net/mptcp/pm_netlink.c
#	net/mptcp/protocol.h
diff --cc net/mptcp/pm.c
index a78fc80f9b51,9256bd5d02ed..000000000000
--- a/net/mptcp/pm.c
+++ b/net/mptcp/pm.c
@@@ -15,23 -13,55 +15,55 @@@ static struct workqueue_struct *pm_wq
  /* path manager command handlers */
  
  int mptcp_pm_announce_addr(struct mptcp_sock *msk,
 -			   const struct mptcp_addr_info *addr,
 -			   bool echo, bool port)
 +			   const struct mptcp_addr_info *addr)
  {
++<<<<<<< HEAD
++=======
+ 	u8 add_addr = READ_ONCE(msk->pm.addr_signal);
+ 
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  	pr_debug("msk=%p, local_id=%d", msk, addr->id);
  
 -	if (add_addr) {
 -		pr_warn("addr_signal error, add_addr=%d", add_addr);
 -		return -EINVAL;
 -	}
 -
  	msk->pm.local = *addr;
++<<<<<<< HEAD
 +	WRITE_ONCE(msk->pm.add_addr_signal, true);
++=======
+ 	add_addr |= BIT(MPTCP_ADD_ADDR_SIGNAL);
+ 	if (echo)
+ 		add_addr |= BIT(MPTCP_ADD_ADDR_ECHO);
+ 	if (addr->family == AF_INET6)
+ 		add_addr |= BIT(MPTCP_ADD_ADDR_IPV6);
+ 	if (port)
+ 		add_addr |= BIT(MPTCP_ADD_ADDR_PORT);
+ 	WRITE_ONCE(msk->pm.addr_signal, add_addr);
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  	return 0;
  }
  
  int mptcp_pm_remove_addr(struct mptcp_sock *msk, u8 local_id)
  {
++<<<<<<< HEAD
 +	return -ENOTSUPP;
++=======
+ 	u8 rm_addr = READ_ONCE(msk->pm.addr_signal);
+ 
+ 	pr_debug("msk=%p, local_id=%d", msk, local_id);
+ 
+ 	if (rm_addr) {
+ 		pr_warn("addr_signal error, rm_addr=%d", rm_addr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	msk->pm.rm_id = local_id;
+ 	rm_addr |= BIT(MPTCP_RM_ADDR_SIGNAL);
+ 	WRITE_ONCE(msk->pm.addr_signal, rm_addr);
+ 	return 0;
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  }
  
 -int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 local_id)
 +int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 remote_id)
  {
 -	pr_debug("msk=%p, local_id=%d", msk, local_id);
 -
 -	spin_lock_bh(&msk->pm.lock);
 -	mptcp_pm_nl_rm_subflow_received(msk, local_id);
 -	spin_unlock_bh(&msk->pm.lock);
 -	return 0;
 +	return -ENOTSUPP;
  }
  
  /* path manager event handlers */
@@@ -170,7 -221,30 +202,34 @@@ bool mptcp_pm_add_addr_signal(struct mp
  		goto out_unlock;
  
  	*saddr = msk->pm.local;
++<<<<<<< HEAD
 +	WRITE_ONCE(msk->pm.add_addr_signal, false);
++=======
+ 	WRITE_ONCE(msk->pm.addr_signal, 0);
+ 	ret = true;
+ 
+ out_unlock:
+ 	spin_unlock_bh(&msk->pm.lock);
+ 	return ret;
+ }
+ 
+ bool mptcp_pm_rm_addr_signal(struct mptcp_sock *msk, unsigned int remaining,
+ 			     u8 *rm_id)
+ {
+ 	int ret = false;
+ 
+ 	spin_lock_bh(&msk->pm.lock);
+ 
+ 	/* double check after the lock is acquired */
+ 	if (!mptcp_pm_should_rm_signal(msk))
+ 		goto out_unlock;
+ 
+ 	if (remaining < TCPOLEN_MPTCP_RM_ADDR_BASE)
+ 		goto out_unlock;
+ 
+ 	*rm_id = msk->pm.rm_id;
+ 	WRITE_ONCE(msk->pm.addr_signal, 0);
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  	ret = true;
  
  out_unlock:
@@@ -218,8 -263,9 +277,12 @@@ void mptcp_pm_data_init(struct mptcp_so
  	msk->pm.add_addr_accepted = 0;
  	msk->pm.local_addr_used = 0;
  	msk->pm.subflows = 0;
 -	msk->pm.rm_id = 0;
  	WRITE_ONCE(msk->pm.work_pending, false);
++<<<<<<< HEAD
 +	WRITE_ONCE(msk->pm.add_addr_signal, false);
++=======
+ 	WRITE_ONCE(msk->pm.addr_signal, 0);
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  	WRITE_ONCE(msk->pm.accept_addr, false);
  	WRITE_ONCE(msk->pm.accept_subflow, false);
  	msk->pm.status = 0;
diff --cc net/mptcp/pm_netlink.c
index 6f3bf9fdbbbc,46da9f8c9cba..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -267,8 -399,114 +267,117 @@@ void mptcp_pm_nl_add_addr_received(stru
  	local.family = remote.family;
  
  	spin_unlock_bh(&msk->pm.lock);
 -	__mptcp_subflow_connect((struct sock *)msk, &local, &remote);
 +	__mptcp_subflow_connect((struct sock *)msk, 0, &local, &remote);
  	spin_lock_bh(&msk->pm.lock);
++<<<<<<< HEAD
++=======
+ 
+ 	mptcp_pm_announce_addr(msk, &remote, true, use_port);
+ 	mptcp_pm_nl_add_addr_send_ack(msk);
+ }
+ 
+ void mptcp_pm_nl_add_addr_send_ack(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow;
+ 
+ 	if (!mptcp_pm_should_add_signal_ipv6(msk) &&
+ 	    !mptcp_pm_should_add_signal_port(msk))
+ 		return;
+ 
+ 	__mptcp_flush_join_list(msk);
+ 	subflow = list_first_entry_or_null(&msk->conn_list, typeof(*subflow), node);
+ 	if (subflow) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		u8 add_addr;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		if (mptcp_pm_should_add_signal_ipv6(msk))
+ 			pr_debug("send ack for add_addr6");
+ 		if (mptcp_pm_should_add_signal_port(msk))
+ 			pr_debug("send ack for add_addr_port");
+ 
+ 		lock_sock(ssk);
+ 		tcp_send_ack(ssk);
+ 		release_sock(ssk);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		add_addr = READ_ONCE(msk->pm.addr_signal);
+ 		if (mptcp_pm_should_add_signal_ipv6(msk))
+ 			add_addr &= ~BIT(MPTCP_ADD_ADDR_IPV6);
+ 		if (mptcp_pm_should_add_signal_port(msk))
+ 			add_addr &= ~BIT(MPTCP_ADD_ADDR_PORT);
+ 		WRITE_ONCE(msk->pm.addr_signal, add_addr);
+ 	}
+ }
+ 
+ void mptcp_pm_nl_rm_addr_received(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("address rm_id %d", msk->pm.rm_id);
+ 
+ 	if (!msk->pm.rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 
+ 		if (msk->pm.rm_id != subflow->remote_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.add_addr_accepted--;
+ 		msk->pm.subflows--;
+ 		WRITE_ONCE(msk->pm.accept_addr, true);
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMADDR);
+ 
+ 		break;
+ 	}
+ }
+ 
+ void mptcp_pm_nl_rm_subflow_received(struct mptcp_sock *msk, u8 rm_id)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("subflow rm_id %d", rm_id);
+ 
+ 	if (!rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 
+ 		if (rm_id != subflow->local_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.local_addr_used--;
+ 		msk->pm.subflows--;
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMSUBFLOW);
+ 
+ 		break;
+ 	}
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  }
  
  static bool address_use_port(struct mptcp_pm_addr_entry *entry)
diff --cc net/mptcp/protocol.h
index ec3d81e5cc62,9ff6fd486db6..000000000000
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@@ -161,13 -168,22 +161,28 @@@ enum mptcp_pm_status 
  	MPTCP_PM_SUBFLOW_ESTABLISHED,
  };
  
++<<<<<<< HEAD
++=======
+ enum mptcp_addr_signal_status {
+ 	MPTCP_ADD_ADDR_SIGNAL,
+ 	MPTCP_ADD_ADDR_ECHO,
+ 	MPTCP_ADD_ADDR_IPV6,
+ 	MPTCP_ADD_ADDR_PORT,
+ 	MPTCP_RM_ADDR_SIGNAL,
+ };
+ 
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  struct mptcp_pm_data {
  	struct mptcp_addr_info local;
  	struct mptcp_addr_info remote;
  
  	spinlock_t	lock;		/*protects the whole PM data */
  
++<<<<<<< HEAD
 +	bool		add_addr_signal;
++=======
+ 	u8		addr_signal;
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  	bool		server_side;
  	bool		work_pending;
  	bool		accept_addr;
@@@ -447,14 -558,41 +462,51 @@@ int mptcp_pm_remove_subflow(struct mptc
  
  static inline bool mptcp_pm_should_add_signal(struct mptcp_sock *msk)
  {
++<<<<<<< HEAD
 +	return READ_ONCE(msk->pm.add_addr_signal);
++=======
+ 	return READ_ONCE(msk->pm.addr_signal) & BIT(MPTCP_ADD_ADDR_SIGNAL);
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  }
  
 -static inline bool mptcp_pm_should_add_signal_echo(struct mptcp_sock *msk)
 +static inline unsigned int mptcp_add_addr_len(int family)
  {
++<<<<<<< HEAD
 +	if (family == AF_INET)
 +		return TCPOLEN_MPTCP_ADD_ADDR;
 +	return TCPOLEN_MPTCP_ADD_ADDR6;
++=======
+ 	return READ_ONCE(msk->pm.addr_signal) & BIT(MPTCP_ADD_ADDR_ECHO);
+ }
+ 
+ static inline bool mptcp_pm_should_add_signal_ipv6(struct mptcp_sock *msk)
+ {
+ 	return READ_ONCE(msk->pm.addr_signal) & BIT(MPTCP_ADD_ADDR_IPV6);
+ }
+ 
+ static inline bool mptcp_pm_should_add_signal_port(struct mptcp_sock *msk)
+ {
+ 	return READ_ONCE(msk->pm.addr_signal) & BIT(MPTCP_ADD_ADDR_PORT);
+ }
+ 
+ static inline bool mptcp_pm_should_rm_signal(struct mptcp_sock *msk)
+ {
+ 	return READ_ONCE(msk->pm.addr_signal) & BIT(MPTCP_RM_ADDR_SIGNAL);
+ }
+ 
+ static inline unsigned int mptcp_add_addr_len(int family, bool echo, bool port)
+ {
+ 	u8 len = TCPOLEN_MPTCP_ADD_ADDR_BASE;
+ 
+ 	if (family == AF_INET6)
+ 		len = TCPOLEN_MPTCP_ADD_ADDR6_BASE;
+ 	if (!echo)
+ 		len += MPTCPOPT_THMAC_LEN;
+ 	if (port)
+ 		len += TCPOLEN_MPTCP_PORT_LEN;
+ 
+ 	return len;
++>>>>>>> 13ad9f01a29e (mptcp: rename add_addr_signal and mptcp_add_addr_status)
  }
  
  bool mptcp_pm_add_addr_signal(struct mptcp_sock *msk, unsigned int remaining,
* Unmerged path net/mptcp/pm.c
* Unmerged path net/mptcp/pm_netlink.c
* Unmerged path net/mptcp/protocol.h
