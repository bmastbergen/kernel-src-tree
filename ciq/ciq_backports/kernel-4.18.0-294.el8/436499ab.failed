powerpc/pmem: Avoid the barrier in flush routines

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
commit 436499ab868f1a9e497cfdbf641affe8a122c571
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/436499ab.failed

nvdimm expect the flush routines to just mark the cache clean. The barrier
that mark the store globally visible is done in nvdimm_flush().

	Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200701072235.223558-7-aneesh.kumar@linux.ibm.com
(cherry picked from commit 436499ab868f1a9e497cfdbf641affe8a122c571)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/lib/pmem.c
diff --cc arch/powerpc/lib/pmem.c
index 36e08bf850e0,21210fa676e5..000000000000
--- a/arch/powerpc/lib/pmem.c
+++ b/arch/powerpc/lib/pmem.c
@@@ -17,6 -9,42 +17,45 @@@
  
  #include <asm/cacheflush.h>
  
++<<<<<<< HEAD
++=======
+ static inline void __clean_pmem_range(unsigned long start, unsigned long stop)
+ {
+ 	unsigned long shift = l1_dcache_shift();
+ 	unsigned long bytes = l1_dcache_bytes();
+ 	void *addr = (void *)(start & ~(bytes - 1));
+ 	unsigned long size = stop - (unsigned long)addr + (bytes - 1);
+ 	unsigned long i;
+ 
+ 	for (i = 0; i < size >> shift; i++, addr += bytes)
+ 		asm volatile(PPC_DCBSTPS(%0, %1): :"i"(0), "r"(addr): "memory");
+ }
+ 
+ static inline void __flush_pmem_range(unsigned long start, unsigned long stop)
+ {
+ 	unsigned long shift = l1_dcache_shift();
+ 	unsigned long bytes = l1_dcache_bytes();
+ 	void *addr = (void *)(start & ~(bytes - 1));
+ 	unsigned long size = stop - (unsigned long)addr + (bytes - 1);
+ 	unsigned long i;
+ 
+ 	for (i = 0; i < size >> shift; i++, addr += bytes)
+ 		asm volatile(PPC_DCBFPS(%0, %1): :"i"(0), "r"(addr): "memory");
+ }
+ 
+ static inline void clean_pmem_range(unsigned long start, unsigned long stop)
+ {
+ 	if (cpu_has_feature(CPU_FTR_ARCH_207S))
+ 		return __clean_pmem_range(start, stop);
+ }
+ 
+ static inline void flush_pmem_range(unsigned long start, unsigned long stop)
+ {
+ 	if (cpu_has_feature(CPU_FTR_ARCH_207S))
+ 		return __flush_pmem_range(start, stop);
+ }
+ 
++>>>>>>> 436499ab868f (powerpc/pmem: Avoid the barrier in flush routines)
  /*
   * CONFIG_ARCH_HAS_PMEM_API symbols
   */
* Unmerged path arch/powerpc/lib/pmem.c
