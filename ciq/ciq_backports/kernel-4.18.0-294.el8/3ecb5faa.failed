nvmet: centralize port enable access for configfs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
commit 3ecb5faa07c7fd33a3ce1a8340841aa368df7d43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/3ecb5faa.failed

The configfs attributes which are supposed to set when port is disable
such as addr[addrfam|portid|traddr|treq|trsvcid|inline_data_size|trtype]
has repetitive check and generic error message printing.

This patch creates centralize helper to check and print an error
message that also accepts caller as a parameter. This makes error
message easy to parse for the user, removes the duplicate code and
makes it available for futures such scenarios.

	Signed-off-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 3ecb5faa07c7fd33a3ce1a8340841aa368df7d43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/configfs.c
diff --cc drivers/nvme/target/configfs.c
index 25fadb1d9ea5,20779587eefe..000000000000
--- a/drivers/nvme/target/configfs.c
+++ b/drivers/nvme/target/configfs.c
@@@ -38,6 -32,22 +38,25 @@@ static const struct nvmet_transport_nam
  	{ NVMF_TRTYPE_LOOP,	"loop" },
  };
  
++<<<<<<< HEAD
++=======
+ static const struct nvmet_type_name_map nvmet_addr_family[] = {
+ 	{ NVMF_ADDR_FAMILY_PCI,	"pcie" },
+ 	{ NVMF_ADDR_FAMILY_IP4,	"ipv4" },
+ 	{ NVMF_ADDR_FAMILY_IP6,	"ipv6" },
+ 	{ NVMF_ADDR_FAMILY_IB,	"ib" },
+ 	{ NVMF_ADDR_FAMILY_FC,	"fc" },
+ };
+ 
+ static bool nvmet_is_port_enabled(struct nvmet_port *p, const char *caller)
+ {
+ 	if (p->enabled)
+ 		pr_err("Disable port '%u' before changing attribute in %s\n",
+ 				le16_to_cpu(p->disc_addr.portid), caller);
+ 	return p->enabled;
+ }
+ 
++>>>>>>> 3ecb5faa07c7 (nvmet: centralize port enable access for configfs)
  /*
   * nvmet_port Generic ConfigFS definitions.
   * Used in any place in the ConfigFS tree that refers to an address.
@@@ -63,26 -69,21 +82,23 @@@ static ssize_t nvmet_addr_adrfam_store(
  		const char *page, size_t count)
  {
  	struct nvmet_port *port = to_nvmet_port(item);
 -	int i;
  
- 	if (port->enabled) {
- 		pr_err("Cannot modify address while enabled\n");
- 		pr_err("Disable the address before modifying\n");
+ 	if (nvmet_is_port_enabled(port, __func__))
  		return -EACCES;
- 	}
  
 -	for (i = 1; i < ARRAY_SIZE(nvmet_addr_family); i++) {
 -		if (sysfs_streq(page, nvmet_addr_family[i].name))
 -			goto found;
 +	if (sysfs_streq(page, "ipv4")) {
 +		port->disc_addr.adrfam = NVMF_ADDR_FAMILY_IP4;
 +	} else if (sysfs_streq(page, "ipv6")) {
 +		port->disc_addr.adrfam = NVMF_ADDR_FAMILY_IP6;
 +	} else if (sysfs_streq(page, "ib")) {
 +		port->disc_addr.adrfam = NVMF_ADDR_FAMILY_IB;
 +	} else if (sysfs_streq(page, "fc")) {
 +		port->disc_addr.adrfam = NVMF_ADDR_FAMILY_FC;
 +	} else {
 +		pr_err("Invalid value '%s' for adrfam\n", page);
 +		return -EINVAL;
  	}
  
 -	pr_err("Invalid value '%s' for adrfam\n", page);
 -	return -EINVAL;
 -
 -found:
 -	port->disc_addr.adrfam = i;
  	return count;
  }
  
@@@ -172,25 -172,22 +183,22 @@@ static ssize_t nvmet_addr_treq_store(st
  {
  	struct nvmet_port *port = to_nvmet_port(item);
  	u8 treq = port->disc_addr.treq & ~NVME_TREQ_SECURE_CHANNEL_MASK;
 -	int i;
  
- 	if (port->enabled) {
- 		pr_err("Cannot modify address while enabled\n");
- 		pr_err("Disable the address before modifying\n");
+ 	if (nvmet_is_port_enabled(port, __func__))
  		return -EACCES;
- 	}
  
 -	for (i = 0; i < ARRAY_SIZE(nvmet_addr_treq); i++) {
 -		if (sysfs_streq(page, nvmet_addr_treq[i].name))
 -			goto found;
 +	if (sysfs_streq(page, "not specified")) {
 +		treq |= NVMF_TREQ_NOT_SPECIFIED;
 +	} else if (sysfs_streq(page, "required")) {
 +		treq |= NVMF_TREQ_REQUIRED;
 +	} else if (sysfs_streq(page, "not required")) {
 +		treq |= NVMF_TREQ_NOT_REQUIRED;
 +	} else {
 +		pr_err("Invalid value '%s' for treq\n", page);
 +		return -EINVAL;
  	}
 -
 -	pr_err("Invalid value '%s' for treq\n", page);
 -	return -EINVAL;
 -
 -found:
 -	treq |= nvmet_addr_treq[i].type;
  	port->disc_addr.treq = treq;
 +
  	return count;
  }
  
@@@ -284,14 -274,11 +286,11 @@@ static ssize_t nvmet_addr_trtype_store(
  	struct nvmet_port *port = to_nvmet_port(item);
  	int i;
  
- 	if (port->enabled) {
- 		pr_err("Cannot modify address while enabled\n");
- 		pr_err("Disable the address before modifying\n");
+ 	if (nvmet_is_port_enabled(port, __func__))
  		return -EACCES;
- 	}
  
 -	for (i = 0; i < ARRAY_SIZE(nvmet_transport); i++) {
 -		if (sysfs_streq(page, nvmet_transport[i].name))
 +	for (i = 0; i < ARRAY_SIZE(nvmet_transport_names); i++) {
 +		if (sysfs_streq(page, nvmet_transport_names[i].name))
  			goto found;
  	}
  
* Unmerged path drivers/nvme/target/configfs.c
