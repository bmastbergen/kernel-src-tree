fs/xfs: Make DAX mount option a tri-state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit 8d6c3446ec23ecd97bc089ed224342baf9426c30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8d6c3446.failed

As agreed upon[1].  We make the dax mount option a tri-state.  '-o dax'
continues to operate the same.  We add 'always', 'never', and 'inode'
(default).

[1] https://lore.kernel.org/lkml/20200405061945.GA94792@iweiny-DESK2.sc.intel.com/

	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 8d6c3446ec23ecd97bc089ed224342baf9426c30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_mount.h
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_mount.h
index 1c67cc24efa8,37bfb50db809..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -232,14 -237,8 +232,19 @@@ typedef struct xfs_mount 
  #define XFS_MOUNT_FILESTREAMS	(1ULL << 24)	/* enable the filestreams
  						   allocator */
  #define XFS_MOUNT_NOATTR2	(1ULL << 25)	/* disable use of attr2 format */
++<<<<<<< HEAD
 +
 +#define XFS_MOUNT_DAX		(1ULL << 62)	/* TEST ONLY! */
 +
 +
 +/*
 + * Default write size.
 + */
 +#define XFS_WRITEIO_LOG_LARGE	16
++=======
+ #define XFS_MOUNT_DAX_ALWAYS	(1ULL << 26)
+ #define XFS_MOUNT_DAX_NEVER	(1ULL << 27)
++>>>>>>> 8d6c3446ec23 (fs/xfs: Make DAX mount option a tri-state)
  
  /*
   * Max and min values for mount-option defined I/O
diff --cc fs/xfs/xfs_super.c
index e6df26a81bbf,e80bd2c4c279..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -58,343 -92,54 +91,392 @@@ enum 
  	Opt_filestreams, Opt_quota, Opt_noquota, Opt_usrquota, Opt_grpquota,
  	Opt_prjquota, Opt_uquota, Opt_gquota, Opt_pquota,
  	Opt_uqnoenforce, Opt_gqnoenforce, Opt_pqnoenforce, Opt_qnoenforce,
++<<<<<<< HEAD
 +	Opt_discard, Opt_nodiscard, Opt_dax, Opt_err,
 +};
 +
 +static const match_table_t tokens = {
 +	{Opt_logbufs,	"logbufs=%u"},	/* number of XFS log buffers */
 +	{Opt_logbsize,	"logbsize=%s"},	/* size of XFS log buffers */
 +	{Opt_logdev,	"logdev=%s"},	/* log device */
 +	{Opt_rtdev,	"rtdev=%s"},	/* realtime I/O device */
 +	{Opt_biosize,	"biosize=%u"},	/* log2 of preferred buffered io size */
 +	{Opt_wsync,	"wsync"},	/* safe-mode nfs compatible mount */
 +	{Opt_noalign,	"noalign"},	/* turn off stripe alignment */
 +	{Opt_swalloc,	"swalloc"},	/* turn on stripe width allocation */
 +	{Opt_sunit,	"sunit=%u"},	/* data volume stripe unit */
 +	{Opt_swidth,	"swidth=%u"},	/* data volume stripe width */
 +	{Opt_nouuid,	"nouuid"},	/* ignore filesystem UUID */
 +	{Opt_grpid,	"grpid"},	/* group-ID from parent directory */
 +	{Opt_nogrpid,	"nogrpid"},	/* group-ID from current process */
 +	{Opt_bsdgroups,	"bsdgroups"},	/* group-ID from parent directory */
 +	{Opt_sysvgroups,"sysvgroups"},	/* group-ID from current process */
 +	{Opt_allocsize,	"allocsize=%s"},/* preferred allocation size */
 +	{Opt_norecovery,"norecovery"},	/* don't run XFS recovery */
 +	{Opt_inode64,	"inode64"},	/* inodes can be allocated anywhere */
 +	{Opt_inode32,   "inode32"},	/* inode allocation limited to
 +					 * XFS_MAXINUMBER_32 */
 +	{Opt_ikeep,	"ikeep"},	/* do not free empty inode clusters */
 +	{Opt_noikeep,	"noikeep"},	/* free empty inode clusters */
 +	{Opt_largeio,	"largeio"},	/* report large I/O sizes in stat() */
 +	{Opt_nolargeio,	"nolargeio"},	/* do not report large I/O sizes
 +					 * in stat(). */
 +	{Opt_attr2,	"attr2"},	/* do use attr2 attribute format */
 +	{Opt_noattr2,	"noattr2"},	/* do not use attr2 attribute format */
 +	{Opt_filestreams,"filestreams"},/* use filestreams allocator */
 +	{Opt_quota,	"quota"},	/* disk quotas (user) */
 +	{Opt_noquota,	"noquota"},	/* no quotas */
 +	{Opt_usrquota,	"usrquota"},	/* user quota enabled */
 +	{Opt_grpquota,	"grpquota"},	/* group quota enabled */
 +	{Opt_prjquota,	"prjquota"},	/* project quota enabled */
 +	{Opt_uquota,	"uquota"},	/* user quota (IRIX variant) */
 +	{Opt_gquota,	"gquota"},	/* group quota (IRIX variant) */
 +	{Opt_pquota,	"pquota"},	/* project quota (IRIX variant) */
 +	{Opt_uqnoenforce,"uqnoenforce"},/* user quota limit enforcement */
 +	{Opt_gqnoenforce,"gqnoenforce"},/* group quota limit enforcement */
 +	{Opt_pqnoenforce,"pqnoenforce"},/* project quota limit enforcement */
 +	{Opt_qnoenforce, "qnoenforce"},	/* same as uqnoenforce */
 +	{Opt_discard,	"discard"},	/* Discard unused blocks */
 +	{Opt_nodiscard,	"nodiscard"},	/* Do not discard unused blocks */
 +	{Opt_dax,	"dax"},		/* Enable direct access to bdev pages */
 +	{Opt_err,	NULL},
++=======
+ 	Opt_discard, Opt_nodiscard, Opt_dax, Opt_dax_enum,
+ };
+ 
+ static const struct fs_parameter_spec xfs_fs_parameters[] = {
+ 	fsparam_u32("logbufs",		Opt_logbufs),
+ 	fsparam_string("logbsize",	Opt_logbsize),
+ 	fsparam_string("logdev",	Opt_logdev),
+ 	fsparam_string("rtdev",		Opt_rtdev),
+ 	fsparam_flag("wsync",		Opt_wsync),
+ 	fsparam_flag("noalign",		Opt_noalign),
+ 	fsparam_flag("swalloc",		Opt_swalloc),
+ 	fsparam_u32("sunit",		Opt_sunit),
+ 	fsparam_u32("swidth",		Opt_swidth),
+ 	fsparam_flag("nouuid",		Opt_nouuid),
+ 	fsparam_flag("grpid",		Opt_grpid),
+ 	fsparam_flag("nogrpid",		Opt_nogrpid),
+ 	fsparam_flag("bsdgroups",	Opt_bsdgroups),
+ 	fsparam_flag("sysvgroups",	Opt_sysvgroups),
+ 	fsparam_string("allocsize",	Opt_allocsize),
+ 	fsparam_flag("norecovery",	Opt_norecovery),
+ 	fsparam_flag("inode64",		Opt_inode64),
+ 	fsparam_flag("inode32",		Opt_inode32),
+ 	fsparam_flag("ikeep",		Opt_ikeep),
+ 	fsparam_flag("noikeep",		Opt_noikeep),
+ 	fsparam_flag("largeio",		Opt_largeio),
+ 	fsparam_flag("nolargeio",	Opt_nolargeio),
+ 	fsparam_flag("attr2",		Opt_attr2),
+ 	fsparam_flag("noattr2",		Opt_noattr2),
+ 	fsparam_flag("filestreams",	Opt_filestreams),
+ 	fsparam_flag("quota",		Opt_quota),
+ 	fsparam_flag("noquota",		Opt_noquota),
+ 	fsparam_flag("usrquota",	Opt_usrquota),
+ 	fsparam_flag("grpquota",	Opt_grpquota),
+ 	fsparam_flag("prjquota",	Opt_prjquota),
+ 	fsparam_flag("uquota",		Opt_uquota),
+ 	fsparam_flag("gquota",		Opt_gquota),
+ 	fsparam_flag("pquota",		Opt_pquota),
+ 	fsparam_flag("uqnoenforce",	Opt_uqnoenforce),
+ 	fsparam_flag("gqnoenforce",	Opt_gqnoenforce),
+ 	fsparam_flag("pqnoenforce",	Opt_pqnoenforce),
+ 	fsparam_flag("qnoenforce",	Opt_qnoenforce),
+ 	fsparam_flag("discard",		Opt_discard),
+ 	fsparam_flag("nodiscard",	Opt_nodiscard),
+ 	fsparam_flag("dax",		Opt_dax),
+ 	fsparam_enum("dax",		Opt_dax_enum, dax_param_enums),
+ 	{}
++>>>>>>> 8d6c3446ec23 (fs/xfs: Make DAX mount option a tri-state)
  };
  
 +
 +STATIC int
 +suffix_kstrtoint(const substring_t *s, unsigned int base, int *res)
 +{
 +	int	last, shift_left_factor = 0, _res;
 +	char	*value;
 +	int	ret = 0;
 +
 +	value = match_strdup(s);
 +	if (!value)
 +		return -ENOMEM;
 +
 +	last = strlen(value) - 1;
 +	if (value[last] == 'K' || value[last] == 'k') {
 +		shift_left_factor = 10;
 +		value[last] = '\0';
 +	}
 +	if (value[last] == 'M' || value[last] == 'm') {
 +		shift_left_factor = 20;
 +		value[last] = '\0';
 +	}
 +	if (value[last] == 'G' || value[last] == 'g') {
 +		shift_left_factor = 30;
 +		value[last] = '\0';
 +	}
 +
 +	if (kstrtoint(value, base, &_res))
 +		ret = -EINVAL;
 +	kfree(value);
 +	*res = _res << shift_left_factor;
 +	return ret;
 +}
 +
 +/*
 + * This function fills in xfs_mount_t fields based on mount args.
 + * Note: the superblock has _not_ yet been read in.
 + *
 + * Note that this function leaks the various device name allocations on
 + * failure.  The caller takes care of them.
 + *
 + * *sb is const because this is also used to test options on the remount
 + * path, and we don't want this to have any side effects at remount time.
 + * Today this function does not change *sb, but just to future-proof...
 + */
 +STATIC int
 +xfs_parseargs(
 +	struct xfs_mount	*mp,
 +	char			*options)
 +{
 +	const struct super_block *sb = mp->m_super;
 +	char			*p;
 +	substring_t		args[MAX_OPT_ARGS];
 +	int			iosize = 0;
 +	uint8_t			iosizelog = 0;
 +
 +	/*
 +	 * Copy binary VFS mount flags we are interested in.
 +	 */
 +	if (sb_rdonly(sb))
 +		mp->m_flags |= XFS_MOUNT_RDONLY;
 +	if (sb->s_flags & SB_DIRSYNC)
 +		mp->m_flags |= XFS_MOUNT_DIRSYNC;
 +	if (sb->s_flags & SB_SYNCHRONOUS)
 +		mp->m_flags |= XFS_MOUNT_WSYNC;
 +
 +	/*
 +	 * These can be overridden by the mount option parsing.
 +	 */
 +	mp->m_logbufs = -1;
 +	mp->m_logbsize = -1;
 +
 +	if (!options)
 +		return 0;
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int		token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_logbufs:
 +			if (match_int(args, &mp->m_logbufs))
 +				return -EINVAL;
 +			break;
 +		case Opt_logbsize:
 +			if (suffix_kstrtoint(args, 10, &mp->m_logbsize))
 +				return -EINVAL;
 +			break;
 +		case Opt_logdev:
 +			kfree(mp->m_logname);
 +			mp->m_logname = match_strdup(args);
 +			if (!mp->m_logname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_rtdev:
 +			kfree(mp->m_rtname);
 +			mp->m_rtname = match_strdup(args);
 +			if (!mp->m_rtname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_allocsize:
 +		case Opt_biosize:
 +			if (suffix_kstrtoint(args, 10, &iosize))
 +				return -EINVAL;
 +			iosizelog = ffs(iosize) - 1;
 +			break;
 +		case Opt_grpid:
 +		case Opt_bsdgroups:
 +			mp->m_flags |= XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_nogrpid:
 +		case Opt_sysvgroups:
 +			mp->m_flags &= ~XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_wsync:
 +			mp->m_flags |= XFS_MOUNT_WSYNC;
 +			break;
 +		case Opt_norecovery:
 +			mp->m_flags |= XFS_MOUNT_NORECOVERY;
 +			break;
 +		case Opt_noalign:
 +			mp->m_flags |= XFS_MOUNT_NOALIGN;
 +			break;
 +		case Opt_swalloc:
 +			mp->m_flags |= XFS_MOUNT_SWALLOC;
 +			break;
 +		case Opt_sunit:
 +			if (match_int(args, &mp->m_dalign))
 +				return -EINVAL;
 +			break;
 +		case Opt_swidth:
 +			if (match_int(args, &mp->m_swidth))
 +				return -EINVAL;
 +			break;
 +		case Opt_inode32:
 +			mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_inode64:
 +			mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_nouuid:
 +			mp->m_flags |= XFS_MOUNT_NOUUID;
 +			break;
 +		case Opt_ikeep:
 +			mp->m_flags |= XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_noikeep:
 +			mp->m_flags &= ~XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_largeio:
 +			mp->m_flags |= XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_nolargeio:
 +			mp->m_flags &= ~XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_attr2:
 +			mp->m_flags |= XFS_MOUNT_ATTR2;
 +			break;
 +		case Opt_noattr2:
 +			mp->m_flags &= ~XFS_MOUNT_ATTR2;
 +			mp->m_flags |= XFS_MOUNT_NOATTR2;
 +			break;
 +		case Opt_filestreams:
 +			mp->m_flags |= XFS_MOUNT_FILESTREAMS;
 +			break;
 +		case Opt_noquota:
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
 +			break;
 +		case Opt_quota:
 +		case Opt_uquota:
 +		case Opt_usrquota:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
 +					 XFS_UQUOTA_ENFD);
 +			break;
 +		case Opt_qnoenforce:
 +		case Opt_uqnoenforce:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_UQUOTA_ENFD;
 +			break;
 +		case Opt_pquota:
 +		case Opt_prjquota:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
 +					 XFS_PQUOTA_ENFD);
 +			break;
 +		case Opt_pqnoenforce:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_PQUOTA_ENFD;
 +			break;
 +		case Opt_gquota:
 +		case Opt_grpquota:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
 +					 XFS_GQUOTA_ENFD);
 +			break;
 +		case Opt_gqnoenforce:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_GQUOTA_ENFD;
 +			break;
 +		case Opt_discard:
 +			mp->m_flags |= XFS_MOUNT_DISCARD;
 +			break;
 +		case Opt_nodiscard:
 +			mp->m_flags &= ~XFS_MOUNT_DISCARD;
 +			break;
 +#ifdef CONFIG_FS_DAX
 +		case Opt_dax:
 +			mp->m_flags |= XFS_MOUNT_DAX;
 +			break;
 +#endif
 +		default:
 +			xfs_warn(mp, "unknown mount option [%s].", p);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	/*
 +	 * no recovery flag requires a read-only mount
 +	 */
 +	if ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&
 +	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
 +		xfs_warn(mp, "no-recovery mounts must be read-only.");
 +		return -EINVAL;
 +	}
 +
 +	if ((mp->m_flags & XFS_MOUNT_NOALIGN) &&
 +	    (mp->m_dalign || mp->m_swidth)) {
 +		xfs_warn(mp,
 +	"sunit and swidth options incompatible with the noalign option");
 +		return -EINVAL;
 +	}
 +
 +	if (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {
 +		xfs_warn(mp, "quota support not available in this kernel.");
 +		return -EINVAL;
 +	}
 +
 +	if ((mp->m_dalign && !mp->m_swidth) ||
 +	    (!mp->m_dalign && mp->m_swidth)) {
 +		xfs_warn(mp, "sunit and swidth must be specified together");
 +		return -EINVAL;
 +	}
 +
 +	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
 +		xfs_warn(mp,
 +	"stripe width (%d) must be a multiple of the stripe unit (%d)",
 +			mp->m_swidth, mp->m_dalign);
 +		return -EINVAL;
 +	}
 +
 +	if (mp->m_logbufs != -1 &&
 +	    mp->m_logbufs != 0 &&
 +	    (mp->m_logbufs < XLOG_MIN_ICLOGS ||
 +	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
 +		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
 +			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
 +		return -EINVAL;
 +	}
 +	if (mp->m_logbsize != -1 &&
 +	    mp->m_logbsize !=  0 &&
 +	    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||
 +	     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||
 +	     !is_power_of_2(mp->m_logbsize))) {
 +		xfs_warn(mp,
 +			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
 +			mp->m_logbsize);
 +		return -EINVAL;
 +	}
 +
 +	if (iosizelog) {
 +		if (iosizelog > XFS_MAX_IO_LOG ||
 +		    iosizelog < XFS_MIN_IO_LOG) {
 +			xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
 +				iosizelog, XFS_MIN_IO_LOG,
 +				XFS_MAX_IO_LOG);
 +			return -EINVAL;
 +		}
 +
 +		mp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;
 +		mp->m_allocsize_log = iosizelog;
 +	}
 +
 +	return 0;
 +}
 +
  struct proc_xfs_info {
  	uint64_t	flag;
  	char		*str;
@@@ -418,7 -163,8 +500,12 @@@ xfs_fs_show_options
  		{ XFS_MOUNT_GRPID,		",grpid" },
  		{ XFS_MOUNT_DISCARD,		",discard" },
  		{ XFS_MOUNT_LARGEIO,		",largeio" },
++<<<<<<< HEAD
 +		{ XFS_MOUNT_DAX,		",dax" },
++=======
+ 		{ XFS_MOUNT_DAX_ALWAYS,		",dax=always" },
+ 		{ XFS_MOUNT_DAX_NEVER,		",dax=never" },
++>>>>>>> 8d6c3446ec23 (fs/xfs: Make DAX mount option a tri-state)
  		{ 0, NULL }
  	};
  	struct xfs_mount	*mp = XFS_M(root->d_sb);
@@@ -1506,57 -1059,338 +1593,305 @@@ xfs_destroy_percpu_counters
  	percpu_counter_destroy(&mp->m_delalloc_blks);
  }
  
 -static void
 -xfs_fs_put_super(
 -	struct super_block	*sb)
 +static struct xfs_mount *
 +xfs_mount_alloc(void)
  {
 -	struct xfs_mount	*mp = XFS_M(sb);
 +	struct xfs_mount	*mp;
  
 -	/* if ->fill_super failed, we have no mount to tear down */
 -	if (!sb->s_fs_info)
 -		return;
 +	mp = kmem_alloc(sizeof(struct xfs_mount), KM_ZERO);
 +	if (!mp)
 +		return NULL;
  
++<<<<<<< HEAD
 +	spin_lock_init(&mp->m_sb_lock);
 +	spin_lock_init(&mp->m_agirotor_lock);
 +	INIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);
 +	spin_lock_init(&mp->m_perag_lock);
 +	mutex_init(&mp->m_growlock);
 +	atomic_set(&mp->m_active_trans, 0);
 +	INIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);
 +	INIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);
 +	INIT_DELAYED_WORK(&mp->m_cowblocks_work, xfs_cowblocks_worker);
 +	mp->m_kobj.kobject.kset = xfs_kset;
++=======
+ 	xfs_notice(mp, "Unmounting Filesystem");
+ 	xfs_filestream_unmount(mp);
+ 	xfs_unmountfs(mp);
+ 
+ 	xfs_freesb(mp);
+ 	free_percpu(mp->m_stats.xs_stats);
+ 	xfs_destroy_percpu_counters(mp);
+ 	xfs_destroy_mount_workqueues(mp);
+ 	xfs_close_devices(mp);
+ 
+ 	sb->s_fs_info = NULL;
+ 	xfs_mount_free(mp);
+ }
+ 
+ static long
+ xfs_fs_nr_cached_objects(
+ 	struct super_block	*sb,
+ 	struct shrink_control	*sc)
+ {
+ 	/* Paranoia: catch incorrect calls during mount setup or teardown */
+ 	if (WARN_ON_ONCE(!sb->s_fs_info))
+ 		return 0;
+ 	return xfs_reclaim_inodes_count(XFS_M(sb));
+ }
+ 
+ static long
+ xfs_fs_free_cached_objects(
+ 	struct super_block	*sb,
+ 	struct shrink_control	*sc)
+ {
+ 	return xfs_reclaim_inodes_nr(XFS_M(sb), sc->nr_to_scan);
+ }
+ 
+ static const struct super_operations xfs_super_operations = {
+ 	.alloc_inode		= xfs_fs_alloc_inode,
+ 	.destroy_inode		= xfs_fs_destroy_inode,
+ 	.dirty_inode		= xfs_fs_dirty_inode,
+ 	.drop_inode		= xfs_fs_drop_inode,
+ 	.put_super		= xfs_fs_put_super,
+ 	.sync_fs		= xfs_fs_sync_fs,
+ 	.freeze_fs		= xfs_fs_freeze,
+ 	.unfreeze_fs		= xfs_fs_unfreeze,
+ 	.statfs			= xfs_fs_statfs,
+ 	.show_options		= xfs_fs_show_options,
+ 	.nr_cached_objects	= xfs_fs_nr_cached_objects,
+ 	.free_cached_objects	= xfs_fs_free_cached_objects,
+ };
+ 
+ static int
+ suffix_kstrtoint(
+ 	const char	*s,
+ 	unsigned int	base,
+ 	int		*res)
+ {
+ 	int		last, shift_left_factor = 0, _res;
+ 	char		*value;
+ 	int		ret = 0;
+ 
+ 	value = kstrdup(s, GFP_KERNEL);
+ 	if (!value)
+ 		return -ENOMEM;
+ 
+ 	last = strlen(value) - 1;
+ 	if (value[last] == 'K' || value[last] == 'k') {
+ 		shift_left_factor = 10;
+ 		value[last] = '\0';
+ 	}
+ 	if (value[last] == 'M' || value[last] == 'm') {
+ 		shift_left_factor = 20;
+ 		value[last] = '\0';
+ 	}
+ 	if (value[last] == 'G' || value[last] == 'g') {
+ 		shift_left_factor = 30;
+ 		value[last] = '\0';
+ 	}
+ 
+ 	if (kstrtoint(value, base, &_res))
+ 		ret = -EINVAL;
+ 	kfree(value);
+ 	*res = _res << shift_left_factor;
+ 	return ret;
+ }
+ 
+ /*
+  * Set mount state from a mount option.
+  *
+  * NOTE: mp->m_super is NULL here!
+  */
+ static int
+ xfs_fc_parse_param(
+ 	struct fs_context	*fc,
+ 	struct fs_parameter	*param)
+ {
+ 	struct xfs_mount	*mp = fc->s_fs_info;
+ 	struct fs_parse_result	result;
+ 	int			size = 0;
+ 	int			opt;
+ 
+ 	opt = fs_parse(fc, xfs_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_logbufs:
+ 		mp->m_logbufs = result.uint_32;
+ 		return 0;
+ 	case Opt_logbsize:
+ 		if (suffix_kstrtoint(param->string, 10, &mp->m_logbsize))
+ 			return -EINVAL;
+ 		return 0;
+ 	case Opt_logdev:
+ 		kfree(mp->m_logname);
+ 		mp->m_logname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_logname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_rtdev:
+ 		kfree(mp->m_rtname);
+ 		mp->m_rtname = kstrdup(param->string, GFP_KERNEL);
+ 		if (!mp->m_rtname)
+ 			return -ENOMEM;
+ 		return 0;
+ 	case Opt_allocsize:
+ 		if (suffix_kstrtoint(param->string, 10, &size))
+ 			return -EINVAL;
+ 		mp->m_allocsize_log = ffs(size) - 1;
+ 		mp->m_flags |= XFS_MOUNT_ALLOCSIZE;
+ 		return 0;
+ 	case Opt_grpid:
+ 	case Opt_bsdgroups:
+ 		mp->m_flags |= XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_nogrpid:
+ 	case Opt_sysvgroups:
+ 		mp->m_flags &= ~XFS_MOUNT_GRPID;
+ 		return 0;
+ 	case Opt_wsync:
+ 		mp->m_flags |= XFS_MOUNT_WSYNC;
+ 		return 0;
+ 	case Opt_norecovery:
+ 		mp->m_flags |= XFS_MOUNT_NORECOVERY;
+ 		return 0;
+ 	case Opt_noalign:
+ 		mp->m_flags |= XFS_MOUNT_NOALIGN;
+ 		return 0;
+ 	case Opt_swalloc:
+ 		mp->m_flags |= XFS_MOUNT_SWALLOC;
+ 		return 0;
+ 	case Opt_sunit:
+ 		mp->m_dalign = result.uint_32;
+ 		return 0;
+ 	case Opt_swidth:
+ 		mp->m_swidth = result.uint_32;
+ 		return 0;
+ 	case Opt_inode32:
+ 		mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_inode64:
+ 		mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
+ 		return 0;
+ 	case Opt_nouuid:
+ 		mp->m_flags |= XFS_MOUNT_NOUUID;
+ 		return 0;
+ 	case Opt_ikeep:
+ 		mp->m_flags |= XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_noikeep:
+ 		mp->m_flags &= ~XFS_MOUNT_IKEEP;
+ 		return 0;
+ 	case Opt_largeio:
+ 		mp->m_flags |= XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_nolargeio:
+ 		mp->m_flags &= ~XFS_MOUNT_LARGEIO;
+ 		return 0;
+ 	case Opt_attr2:
+ 		mp->m_flags |= XFS_MOUNT_ATTR2;
+ 		return 0;
+ 	case Opt_noattr2:
+ 		mp->m_flags &= ~XFS_MOUNT_ATTR2;
+ 		mp->m_flags |= XFS_MOUNT_NOATTR2;
+ 		return 0;
+ 	case Opt_filestreams:
+ 		mp->m_flags |= XFS_MOUNT_FILESTREAMS;
+ 		return 0;
+ 	case Opt_noquota:
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
+ 		mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
+ 		return 0;
+ 	case Opt_quota:
+ 	case Opt_uquota:
+ 	case Opt_usrquota:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
+ 				 XFS_UQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_qnoenforce:
+ 	case Opt_uqnoenforce:
+ 		mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_UQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_pquota:
+ 	case Opt_prjquota:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
+ 				 XFS_PQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_pqnoenforce:
+ 		mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_PQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_gquota:
+ 	case Opt_grpquota:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
+ 				 XFS_GQUOTA_ENFD);
+ 		return 0;
+ 	case Opt_gqnoenforce:
+ 		mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
+ 		mp->m_qflags &= ~XFS_GQUOTA_ENFD;
+ 		return 0;
+ 	case Opt_discard:
+ 		mp->m_flags |= XFS_MOUNT_DISCARD;
+ 		return 0;
+ 	case Opt_nodiscard:
+ 		mp->m_flags &= ~XFS_MOUNT_DISCARD;
+ 		return 0;
+ #ifdef CONFIG_FS_DAX
+ 	case Opt_dax:
+ 		xfs_mount_set_dax_mode(mp, XFS_DAX_ALWAYS);
+ 		return 0;
+ 	case Opt_dax_enum:
+ 		xfs_mount_set_dax_mode(mp, result.uint_32);
+ 		return 0;
+ #endif
+ 	default:
+ 		xfs_warn(mp, "unknown mount option [%s].", param->key);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_fc_validate_params(
+ 	struct xfs_mount	*mp)
+ {
++>>>>>>> 8d6c3446ec23 (fs/xfs: Make DAX mount option a tri-state)
  	/*
 -	 * no recovery flag requires a read-only mount
 +	 * We don't create the finobt per-ag space reservation until after log
 +	 * recovery, so we must set this to true so that an ifree transaction
 +	 * started during log recovery will not depend on space reservations
 +	 * for finobt expansion.
  	 */
 -	if ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&
 -	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
 -		xfs_warn(mp, "no-recovery mounts must be read-only.");
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_flags & XFS_MOUNT_NOALIGN) &&
 -	    (mp->m_dalign || mp->m_swidth)) {
 -		xfs_warn(mp,
 -	"sunit and swidth options incompatible with the noalign option");
 -		return -EINVAL;
 -	}
 -
 -	if (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {
 -		xfs_warn(mp, "quota support not available in this kernel.");
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_dalign && !mp->m_swidth) ||
 -	    (!mp->m_dalign && mp->m_swidth)) {
 -		xfs_warn(mp, "sunit and swidth must be specified together");
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
 -		xfs_warn(mp,
 -	"stripe width (%d) must be a multiple of the stripe unit (%d)",
 -			mp->m_swidth, mp->m_dalign);
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_logbufs != -1 &&
 -	    mp->m_logbufs != 0 &&
 -	    (mp->m_logbufs < XLOG_MIN_ICLOGS ||
 -	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
 -		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
 -			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
 -		return -EINVAL;
 -	}
 -
 -	if (mp->m_logbsize != -1 &&
 -	    mp->m_logbsize !=  0 &&
 -	    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||
 -	     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||
 -	     !is_power_of_2(mp->m_logbsize))) {
 -		xfs_warn(mp,
 -			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
 -			mp->m_logbsize);
 -		return -EINVAL;
 -	}
 -
 -	if ((mp->m_flags & XFS_MOUNT_ALLOCSIZE) &&
 -	    (mp->m_allocsize_log > XFS_MAX_IO_LOG ||
 -	     mp->m_allocsize_log < XFS_MIN_IO_LOG)) {
 -		xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
 -			mp->m_allocsize_log, XFS_MIN_IO_LOG, XFS_MAX_IO_LOG);
 -		return -EINVAL;
 -	}
 -
 -	return 0;
 +	mp->m_finobt_nores = true;
 +	return mp;
  }
  
 -static int
 -xfs_fc_fill_super(
 +
 +STATIC int
 +xfs_fs_fill_super(
  	struct super_block	*sb,
 -	struct fs_context	*fc)
 +	void			*data,
 +	int			silent)
  {
 -	struct xfs_mount	*mp = sb->s_fs_info;
  	struct inode		*root;
 -	int			flags = 0, error;
 +	struct xfs_mount	*mp = NULL;
 +	int			flags = 0, error = -ENOMEM;
  
 +	/*
 +	 * allocate mp and do all low-level struct initializations before we
 +	 * attach it to the super
 +	 */
 +	mp = xfs_mount_alloc();
 +	if (!mp)
 +		goto out;
  	mp->m_super = sb;
 +	sb->s_fs_info = mp;
  
 -	error = xfs_fc_validate_params(mp);
 +	error = xfs_parseargs(mp, (char *)data);
  	if (error)
  		goto out_free_names;
  
@@@ -1673,7 -1506,7 +2008,11 @@@
  		if (!rtdev_is_dax && !datadev_is_dax) {
  			xfs_alert(mp,
  			"DAX unsupported by block device. Turning off DAX.");
++<<<<<<< HEAD
 +			mp->m_flags &= ~XFS_MOUNT_DAX;
++=======
+ 			xfs_mount_set_dax_mode(mp, XFS_DAX_NEVER);
++>>>>>>> 8d6c3446ec23 (fs/xfs: Make DAX mount option a tri-state)
  		}
  		if (xfs_sb_version_hasreflink(&mp->m_sb)) {
  			xfs_alert(mp,
* Unmerged path fs/xfs/xfs_mount.h
* Unmerged path fs/xfs/xfs_super.c
