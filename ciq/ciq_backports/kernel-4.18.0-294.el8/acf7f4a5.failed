platform/x86: thinkpad_acpi: lap or desk mode interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mark Pearson <markpearson@lenovo.com>
commit acf7f4a59114471c3964f118564fe8e7a6f34bb8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/acf7f4a5.failed

Newer Lenovo Thinkpad platforms have support to identify whether the
system is on-lap or not using an ACPI DYTC event from the firmware.

This patch provides the ability to retrieve the current mode via sysfs
entrypoints and will be used by userspace for thermal mode and WWAN
functionality

Co-developed-by: Nitin Joshi <njoshi1@lenovo.com>
	Signed-off-by: Nitin Joshi <njoshi1@lenovo.com>
	Reviewed-by: Sugumaran <slacshiminar@lenovo.com>
	Reviewed-by: Bastien Nocera <bnocera@redhat.com>
	Signed-off-by: Mark Pearson <markpearson@lenovo.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
(cherry picked from commit acf7f4a59114471c3964f118564fe8e7a6f34bb8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/laptops/thinkpad-acpi.txt
#	drivers/platform/x86/thinkpad_acpi.c
diff --cc Documentation/laptops/thinkpad-acpi.txt
index 6cced88de6da,99066aa8d97b..000000000000
--- a/Documentation/laptops/thinkpad-acpi.txt
+++ b/Documentation/laptops/thinkpad-acpi.txt
@@@ -46,6 -49,8 +46,11 @@@ detailed description)
  	- Fan control and monitoring: fan speed, fan enable/disable
  	- WAN enable and disable
  	- UWB enable and disable
++<<<<<<< HEAD:Documentation/laptops/thinkpad-acpi.txt
++=======
+ 	- LCD Shadow (PrivacyGuard) enable and disable
+ 	- Lap mode sensor
++>>>>>>> acf7f4a59114 (platform/x86: thinkpad_acpi: lap or desk mode interface):Documentation/admin-guide/laptops/thinkpad-acpi.rst
  
  A compatibility table by model and feature is maintained on the web
  site, http://ibm-acpi.sf.net/. I appreciate any success or failure
@@@ -1338,9 -1408,45 +1343,23 @@@ Sysfs notes
  	2010.
  
  	rfkill controller switch "tpacpi_wwan_sw": refer to
 -	Documentation/driver-api/rfkill.rst for details.
 -
 -
 -LCD Shadow control
 -------------------
 -
 -procfs: /proc/acpi/ibm/lcdshadow
 -
 -Some newer T480s and T490s ThinkPads provide a feature called
 -PrivacyGuard. By turning this feature on, the usable vertical and
 -horizontal viewing angles of the LCD can be limited (as if some privacy
 -screen was applied manually in front of the display).
 -
 -procfs notes
 -^^^^^^^^^^^^
 -
 -The available commands are::
 -
 -	echo '0' >/proc/acpi/ibm/lcdshadow
 -	echo '1' >/proc/acpi/ibm/lcdshadow
 -
 -The first command ensures the best viewing angle and the latter one turns
 -on the feature, restricting the viewing angles.
 +	Documentation/rfkill.txt for details.
  
  
+ DYTC Lapmode sensor
+ ------------------
+ 
+ sysfs: dytc_lapmode
+ 
+ Newer thinkpads and mobile workstations have the ability to determine if
+ the device is in deskmode or lapmode. This feature is used by user space
+ to decide if WWAN transmission can be increased to maximum power and is
+ also useful for understanding the different thermal modes available as
+ they differ between desk and lap mode.
+ 
+ The property is read-only. If the platform doesn't have support the sysfs
+ class is not created.
+ 
  EXPERIMENTAL: UWB
  -----------------
  
diff --cc drivers/platform/x86/thinkpad_acpi.c
index c7897f7c3e01,7fee3c1c2418..000000000000
--- a/drivers/platform/x86/thinkpad_acpi.c
+++ b/drivers/platform/x86/thinkpad_acpi.c
@@@ -9658,6 -9703,205 +9658,208 @@@ static struct ibm_struct battery_driver
  	.exit = tpacpi_battery_exit,
  };
  
++<<<<<<< HEAD
++=======
+ /*************************************************************************
+  * LCD Shadow subdriver, for the Lenovo PrivacyGuard feature
+  */
+ 
+ static int lcdshadow_state;
+ 
+ static int lcdshadow_on_off(bool state)
+ {
+ 	acpi_handle set_shadow_handle;
+ 	int output;
+ 
+ 	if (ACPI_FAILURE(acpi_get_handle(hkey_handle, "SSSS", &set_shadow_handle))) {
+ 		pr_warn("Thinkpad ACPI has no %s interface.\n", "SSSS");
+ 		return -EIO;
+ 	}
+ 
+ 	if (!acpi_evalf(set_shadow_handle, &output, NULL, "dd", (int)state))
+ 		return -EIO;
+ 
+ 	lcdshadow_state = state;
+ 	return 0;
+ }
+ 
+ static int lcdshadow_set(bool on)
+ {
+ 	if (lcdshadow_state < 0)
+ 		return lcdshadow_state;
+ 	if (lcdshadow_state == on)
+ 		return 0;
+ 	return lcdshadow_on_off(on);
+ }
+ 
+ static int tpacpi_lcdshadow_init(struct ibm_init_struct *iibm)
+ {
+ 	acpi_handle get_shadow_handle;
+ 	int output;
+ 
+ 	if (ACPI_FAILURE(acpi_get_handle(hkey_handle, "GSSS", &get_shadow_handle))) {
+ 		lcdshadow_state = -ENODEV;
+ 		return 0;
+ 	}
+ 
+ 	if (!acpi_evalf(get_shadow_handle, &output, NULL, "dd", 0)) {
+ 		lcdshadow_state = -EIO;
+ 		return -EIO;
+ 	}
+ 	if (!(output & 0x10000)) {
+ 		lcdshadow_state = -ENODEV;
+ 		return 0;
+ 	}
+ 	lcdshadow_state = output & 0x1;
+ 
+ 	return 0;
+ }
+ 
+ static void lcdshadow_resume(void)
+ {
+ 	if (lcdshadow_state >= 0)
+ 		lcdshadow_on_off(lcdshadow_state);
+ }
+ 
+ static int lcdshadow_read(struct seq_file *m)
+ {
+ 	if (lcdshadow_state < 0) {
+ 		seq_puts(m, "status:\t\tnot supported\n");
+ 	} else {
+ 		seq_printf(m, "status:\t\t%d\n", lcdshadow_state);
+ 		seq_puts(m, "commands:\t0, 1\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int lcdshadow_write(char *buf)
+ {
+ 	char *cmd;
+ 	int res, state = -EINVAL;
+ 
+ 	if (lcdshadow_state < 0)
+ 		return -ENODEV;
+ 
+ 	while ((cmd = strsep(&buf, ","))) {
+ 		res = kstrtoint(cmd, 10, &state);
+ 		if (res < 0)
+ 			return res;
+ 	}
+ 
+ 	if (state >= 2 || state < 0)
+ 		return -EINVAL;
+ 
+ 	return lcdshadow_set(state);
+ }
+ 
+ static struct ibm_struct lcdshadow_driver_data = {
+ 	.name = "lcdshadow",
+ 	.resume = lcdshadow_resume,
+ 	.read = lcdshadow_read,
+ 	.write = lcdshadow_write,
+ };
+ 
+ /*************************************************************************
+  * DYTC subdriver, for the Lenovo lapmode feature
+  */
+ 
+ #define DYTC_CMD_GET          2 /* To get current IC function and mode */
+ #define DYTC_GET_LAPMODE_BIT 17 /* Set when in lapmode */
+ 
+ static bool dytc_lapmode;
+ 
+ static void dytc_lapmode_notify_change(void)
+ {
+ 	sysfs_notify(&tpacpi_pdev->dev.kobj, NULL, "dytc_lapmode");
+ }
+ 
+ static int dytc_command(int command, int *output)
+ {
+ 	acpi_handle dytc_handle;
+ 
+ 	if (ACPI_FAILURE(acpi_get_handle(hkey_handle, "DYTC", &dytc_handle))) {
+ 		/* Platform doesn't support DYTC */
+ 		return -ENODEV;
+ 	}
+ 	if (!acpi_evalf(dytc_handle, output, NULL, "dd", command))
+ 		return -EIO;
+ 	return 0;
+ }
+ 
+ static int dytc_lapmode_get(bool *state)
+ {
+ 	int output, err;
+ 
+ 	err = dytc_command(DYTC_CMD_GET, &output);
+ 	if (err)
+ 		return err;
+ 	*state = output & BIT(DYTC_GET_LAPMODE_BIT) ? true : false;
+ 	return 0;
+ }
+ 
+ static void dytc_lapmode_refresh(void)
+ {
+ 	bool new_state;
+ 	int err;
+ 
+ 	err = dytc_lapmode_get(&new_state);
+ 	if (err || (new_state == dytc_lapmode))
+ 		return;
+ 
+ 	dytc_lapmode = new_state;
+ 	dytc_lapmode_notify_change();
+ }
+ 
+ /* sysfs lapmode entry */
+ static ssize_t dytc_lapmode_show(struct device *dev,
+ 					struct device_attribute *attr,
+ 					char *buf)
+ {
+ 	return snprintf(buf, PAGE_SIZE, "%d\n", dytc_lapmode);
+ }
+ 
+ static DEVICE_ATTR_RO(dytc_lapmode);
+ 
+ static struct attribute *dytc_attributes[] = {
+ 	&dev_attr_dytc_lapmode.attr,
+ 	NULL,
+ };
+ 
+ static const struct attribute_group dytc_attr_group = {
+ 	.attrs = dytc_attributes,
+ };
+ 
+ static int tpacpi_dytc_init(struct ibm_init_struct *iibm)
+ {
+ 	int err;
+ 
+ 	err = dytc_lapmode_get(&dytc_lapmode);
+ 	/* If support isn't available (ENODEV) then don't return an error
+ 	 * but just don't create the sysfs group
+ 	 */
+ 	if (err == -ENODEV)
+ 		return 0;
+ 	/* For all other errors we can flag the failure */
+ 	if (err)
+ 		return err;
+ 
+ 	/* Platform supports this feature - create the group */
+ 	err = sysfs_create_group(&tpacpi_pdev->dev.kobj, &dytc_attr_group);
+ 	return err;
+ }
+ 
+ static void dytc_exit(void)
+ {
+ 	sysfs_remove_group(&tpacpi_pdev->dev.kobj, &dytc_attr_group);
+ }
+ 
+ static struct ibm_struct dytc_driver_data = {
+ 	.name = "dytc",
+ 	.exit = dytc_exit,
+ };
+ 
++>>>>>>> acf7f4a59114 (platform/x86: thinkpad_acpi: lap or desk mode interface)
  /****************************************************************************
   ****************************************************************************
   *
@@@ -10108,6 -10387,14 +10314,17 @@@ static struct ibm_init_struct ibms_init
  		.init = tpacpi_battery_init,
  		.data = &battery_driver_data,
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		.init = tpacpi_lcdshadow_init,
+ 		.data = &lcdshadow_driver_data,
+ 	},
+ 	{
+ 		.init = tpacpi_dytc_init,
+ 		.data = &dytc_driver_data,
+ 	},
++>>>>>>> acf7f4a59114 (platform/x86: thinkpad_acpi: lap or desk mode interface)
  };
  
  static int __init set_ibm_param(const char *val, const struct kernel_param *kp)
* Unmerged path Documentation/laptops/thinkpad-acpi.txt
* Unmerged path drivers/platform/x86/thinkpad_acpi.c
