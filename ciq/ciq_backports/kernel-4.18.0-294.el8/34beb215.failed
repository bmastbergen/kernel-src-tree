geneve: add transport ports in route lookup for geneve

jira LE-1907
cve CVE-2020-25645
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mark Gray <mark.d.gray@redhat.com>
commit 34beb21594519ce64a55a498c2fe7d567bc1ca20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/34beb215.failed

This patch adds transport ports information for route lookup so that
IPsec can select Geneve tunnel traffic to do encryption. This is
needed for OVS/OVN IPsec with encrypted Geneve tunnels.

This can be tested by configuring a host-host VPN using an IKE
daemon and specifying port numbers. For example, for an
Openswan-type configuration, the following parameters should be
configured on both hosts and IPsec set up as-per normal:

$ cat /etc/ipsec.conf

conn in
...
left=$IP1
right=$IP2
...
leftprotoport=udp/6081
rightprotoport=udp
...
conn out
...
left=$IP1
right=$IP2
...
leftprotoport=udp
rightprotoport=udp/6081
...

The tunnel can then be setup using "ip" on both hosts (but
changing the relevant IP addresses):

$ ip link add tun type geneve id 1000 remote $IP2
$ ip addr add 192.168.0.1/24 dev tun
$ ip link set tun up

This can then be tested by pinging from $IP1:

$ ping 192.168.0.2

Without this patch the traffic is unencrypted on the wire.

Fixes: 2d07dc79fe04 ("geneve: add initial netdev driver for GENEVE tunnels")
	Signed-off-by: Qiuyu Xiao <qiuyu.xiao.qyx@gmail.com>
	Signed-off-by: Mark Gray <mark.d.gray@redhat.com>
	Reviewed-by: Greg Rose <gvrose8192@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 34beb21594519ce64a55a498c2fe7d567bc1ca20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index d1f98c5cf613,974a244f45ba..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -792,9 -794,11 +793,11 @@@ static struct rtable *geneve_get_v4_rt(
  	fl4->flowi4_proto = IPPROTO_UDP;
  	fl4->daddr = info->key.u.ipv4.dst;
  	fl4->saddr = info->key.u.ipv4.src;
+ 	fl4->fl4_dport = dport;
+ 	fl4->fl4_sport = sport;
  
  	tos = info->key.tos;
 -	if ((tos == 1) && !geneve->cfg.collect_md) {
 +	if ((tos == 1) && !geneve->collect_md) {
  		tos = ip_tunnel_get_dsfield(ip_hdr(skb), skb);
  		use_cache = false;
  	}
@@@ -842,8 -847,11 +846,11 @@@ static struct dst_entry *geneve_get_v6_
  	fl6->flowi6_proto = IPPROTO_UDP;
  	fl6->daddr = info->key.u.ipv6.dst;
  	fl6->saddr = info->key.u.ipv6.src;
+ 	fl6->fl6_dport = dport;
+ 	fl6->fl6_sport = sport;
+ 
  	prio = info->key.tos;
 -	if ((prio == 1) && !geneve->cfg.collect_md) {
 +	if ((prio == 1) && !geneve->collect_md) {
  		prio = ip_tunnel_get_dsfield(ip_hdr(skb), skb);
  		use_cache = false;
  	}
@@@ -892,11 -902,33 +901,15 @@@ static int geneve_xmit_skb(struct sk_bu
  	if (IS_ERR(rt))
  		return PTR_ERR(rt);
  
 -	err = skb_tunnel_check_pmtu(skb, &rt->dst,
 -				    GENEVE_IPV4_HLEN + info->options_len,
 -				    netif_is_any_bridge_port(dev));
 -	if (err < 0) {
 -		dst_release(&rt->dst);
 -		return err;
 -	} else if (err) {
 -		struct ip_tunnel_info *info;
 -
 -		info = skb_tunnel_info(skb);
 -		if (info) {
 -			info->key.u.ipv4.dst = fl4.saddr;
 -			info->key.u.ipv4.src = fl4.daddr;
 -		}
 -
 -		if (!pskb_may_pull(skb, ETH_HLEN)) {
 -			dst_release(&rt->dst);
 -			return -EINVAL;
 -		}
 -
 -		skb->protocol = eth_type_trans(skb, geneve->dev);
 -		netif_rx(skb);
 -		dst_release(&rt->dst);
 -		return -EMSGSIZE;
 -	}
 +	skb_tunnel_check_pmtu(skb, &rt->dst,
 +			      GENEVE_IPV4_HLEN + info->options_len);
  
++<<<<<<< HEAD
 +	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
 +	if (geneve->collect_md) {
++=======
+ 	if (geneve->cfg.collect_md) {
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  		tos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
  		ttl = key->ttl;
  
@@@ -954,10 -988,32 +969,14 @@@ static int geneve6_xmit_skb(struct sk_b
  	if (IS_ERR(dst))
  		return PTR_ERR(dst);
  
 -	err = skb_tunnel_check_pmtu(skb, dst,
 -				    GENEVE_IPV6_HLEN + info->options_len,
 -				    netif_is_any_bridge_port(dev));
 -	if (err < 0) {
 -		dst_release(dst);
 -		return err;
 -	} else if (err) {
 -		struct ip_tunnel_info *info = skb_tunnel_info(skb);
 -
 -		if (info) {
 -			info->key.u.ipv6.dst = fl6.saddr;
 -			info->key.u.ipv6.src = fl6.daddr;
 -		}
 -
 -		if (!pskb_may_pull(skb, ETH_HLEN)) {
 -			dst_release(dst);
 -			return -EINVAL;
 -		}
 -
 -		skb->protocol = eth_type_trans(skb, geneve->dev);
 -		netif_rx(skb);
 -		dst_release(dst);
 -		return -EMSGSIZE;
 -	}
 +	skb_tunnel_check_pmtu(skb, dst, GENEVE_IPV6_HLEN + info->options_len);
  
++<<<<<<< HEAD
 +	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
 +	if (geneve->collect_md) {
++=======
+ 	if (geneve->cfg.collect_md) {
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  		prio = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
  		ttl = key->ttl;
  	} else {
@@@ -1066,9 -1132,8 +1094,14 @@@ static int geneve_fill_metadata_dst(str
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	info->key.tp_src = udp_flow_src_port(geneve->net, skb,
 +					     1, USHRT_MAX, true);
 +	info->key.tp_dst = geneve->info.key.tp_dst;
++=======
+ 	info->key.tp_src = sport;
+ 	info->key.tp_dst = geneve->cfg.info.key.tp_dst;
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  	return 0;
  }
  
* Unmerged path drivers/net/geneve.c
