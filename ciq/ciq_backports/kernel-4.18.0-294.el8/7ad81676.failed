x86/fpu: Reset MXCSR to default in kernel_fpu_begin()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] fpu: Reset MXCSR to default in kernel_fpu_begin() (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 96.08%
commit-author Petteri Aimonen <jpa@git.mail.kapsi.fi>
commit 7ad816762f9bf89e940e618ea40c43138b479e10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7ad81676.failed

Previously, kernel floating point code would run with the MXCSR control
register value last set by userland code by the thread that was active
on the CPU core just before kernel call. This could affect calculation
results if rounding mode was changed, or a crash if a FPU/SIMD exception
was unmasked.

Restore MXCSR to the kernel's default value.

 [ bp: Carve out from a bigger patch by Petteri, add feature check, add
   FNINIT call too (amluto). ]

	Signed-off-by: Petteri Aimonen <jpa@git.mail.kapsi.fi>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://bugzilla.kernel.org/show_bug.cgi?id=207979
Link: https://lkml.kernel.org/r/20200624114646.28953-2-bp@alien8.de
(cherry picked from commit 7ad816762f9bf89e940e618ea40c43138b479e10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/core.c
diff --cc arch/x86/kernel/fpu/core.c
index 1ca9ca3405c9,15247b96c6ea..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -124,7 -85,28 +124,32 @@@ EXPORT_SYMBOL(__kernel_fpu_end)
  void kernel_fpu_begin(void)
  {
  	preempt_disable();
++<<<<<<< HEAD
 +	__kernel_fpu_begin();
++=======
+ 
+ 	WARN_ON_FPU(!irq_fpu_usable());
+ 	WARN_ON_FPU(this_cpu_read(in_kernel_fpu));
+ 
+ 	this_cpu_write(in_kernel_fpu, true);
+ 
+ 	if (!(current->flags & PF_KTHREAD) &&
+ 	    !test_thread_flag(TIF_NEED_FPU_LOAD)) {
+ 		set_thread_flag(TIF_NEED_FPU_LOAD);
+ 		/*
+ 		 * Ignore return value -- we don't care if reg state
+ 		 * is clobbered.
+ 		 */
+ 		copy_fpregs_to_fpstate(&current->thread.fpu);
+ 	}
+ 	__cpu_invalidate_fpregs_state();
+ 
+ 	if (boot_cpu_has(X86_FEATURE_XMM))
+ 		ldmxcsr(MXCSR_DEFAULT);
+ 
+ 	if (boot_cpu_has(X86_FEATURE_FPU))
+ 		asm volatile ("fninit");
++>>>>>>> 7ad816762f9b (x86/fpu: Reset MXCSR to default in kernel_fpu_begin())
  }
  EXPORT_SYMBOL_GPL(kernel_fpu_begin);
  
diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
index 802a9497cce4..1b392a7c6a2a 100644
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@ -648,6 +648,11 @@ static inline void switch_fpu_finish(struct fpu *new_fpu)
  * MXCSR and XCR definitions:
  */
 
+static inline void ldmxcsr(u32 mxcsr)
+{
+	asm volatile("ldmxcsr %0" :: "m" (mxcsr));
+}
+
 extern unsigned int mxcsr_feature_mask;
 
 #define XCR_XFEATURE_ENABLED_MASK	0x00000000
* Unmerged path arch/x86/kernel/fpu/core.c
