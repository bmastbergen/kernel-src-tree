gfs2: further simplify gfs2_evict_inode with new func evict_should_delete

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit 53dbc27eb18999619766ff994d2b33c4655c5588
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/53dbc27e.failed

This patch further simplifies function gfs2_evict_inode() by adding a
new function evict_should_delete. The function may also lock the inode
glock.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 53dbc27eb18999619766ff994d2b33c4655c5588)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index 7ef6d48f35a7,e44030644fcd..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1306,6 -1317,112 +1312,115 @@@ static bool gfs2_upgrade_iopen_glock(st
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * evict_should_delete - determine whether the inode is eligible for deletion
+  * @inode: The inode to evict
+  *
+  * This function determines whether the evicted inode is eligible to be deleted
+  * and locks the inode glock.
+  *
+  * Returns: the fate of the dinode
+  */
+ static enum dinode_demise evict_should_delete(struct inode *inode,
+ 					      struct gfs2_holder *gh)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct super_block *sb = inode->i_sb;
+ 	struct gfs2_sbd *sdp = sb->s_fs_info;
+ 	int ret;
+ 
+ 	if (test_bit(GIF_ALLOC_FAILED, &ip->i_flags)) {
+ 		BUG_ON(!gfs2_glock_is_locked_by_me(ip->i_gl));
+ 		goto should_delete;
+ 	}
+ 
+ 	if (test_bit(GIF_DEFERRED_DELETE, &ip->i_flags))
+ 		return SHOULD_DEFER_EVICTION;
+ 
+ 	/* Deletes should never happen under memory pressure anymore.  */
+ 	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC))
+ 		return SHOULD_DEFER_EVICTION;
+ 
+ 	/* Must not read inode block until block type has been verified */
+ 	ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, gh);
+ 	if (unlikely(ret)) {
+ 		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
+ 		ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
+ 		gfs2_glock_dq_uninit(&ip->i_iopen_gh);
+ 		return SHOULD_DEFER_EVICTION;
+ 	}
+ 
+ 	if (gfs2_inode_already_deleted(ip->i_gl, ip->i_no_formal_ino))
+ 		return SHOULD_NOT_DELETE_DINODE;
+ 	ret = gfs2_check_blk_type(sdp, ip->i_no_addr, GFS2_BLKST_UNLINKED);
+ 	if (ret)
+ 		return SHOULD_NOT_DELETE_DINODE;
+ 
+ 	if (test_bit(GIF_INVALID, &ip->i_flags)) {
+ 		ret = gfs2_inode_refresh(ip);
+ 		if (ret)
+ 			return SHOULD_NOT_DELETE_DINODE;
+ 	}
+ 
+ 	/*
+ 	 * The inode may have been recreated in the meantime.
+ 	 */
+ 	if (inode->i_nlink)
+ 		return SHOULD_NOT_DELETE_DINODE;
+ 
+ should_delete:
+ 	if (gfs2_holder_initialized(&ip->i_iopen_gh) &&
+ 	    test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
+ 		if (!gfs2_upgrade_iopen_glock(inode)) {
+ 			gfs2_holder_uninit(&ip->i_iopen_gh);
+ 			return SHOULD_NOT_DELETE_DINODE;
+ 		}
+ 	}
+ 	return SHOULD_DELETE_DINODE;
+ }
+ 
+ /**
+  * evict_unlinked_inode - delete the pieces of an unlinked evicted inode
+  * @inode: The inode to evict
+  */
+ static int evict_unlinked_inode(struct inode *inode)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	int ret;
+ 
+ 	if (S_ISDIR(inode->i_mode) &&
+ 	    (ip->i_diskflags & GFS2_DIF_EXHASH)) {
+ 		ret = gfs2_dir_exhash_dealloc(ip);
+ 		if (ret)
+ 			goto out;
+ 	}
+ 
+ 	if (ip->i_eattr) {
+ 		ret = gfs2_ea_dealloc(ip);
+ 		if (ret)
+ 			goto out;
+ 	}
+ 
+ 	if (!gfs2_is_stuffed(ip)) {
+ 		ret = gfs2_file_dealloc(ip);
+ 		if (ret)
+ 			goto out;
+ 	}
+ 
+ 	/* We're about to clear the bitmap for the dinode, but as soon as we
+ 	   do, gfs2_create_inode can create another inode at the same block
+ 	   location and try to set gl_object again. We clear gl_object here so
+ 	   that subsequent inode creates don't see an old gl_object. */
+ 	glock_clear_object(ip->i_gl, ip);
+ 	ret = gfs2_dinode_dealloc(ip);
+ 	gfs2_inode_remember_delete(ip->i_gl, ip->i_no_formal_ino);
+ out:
+ 	return ret;
+ }
+ 
+ /**
++>>>>>>> 53dbc27eb189 (gfs2: further simplify gfs2_evict_inode with new func evict_should_delete)
   * gfs2_evict_inode - Remove an inode from cache
   * @inode: The inode to evict
   *
@@@ -1343,83 -1460,14 +1458,86 @@@ static void gfs2_evict_inode(struct ino
  	if (inode->i_nlink || sb_rdonly(sb))
  		goto out;
  
- 	if (test_bit(GIF_ALLOC_FAILED, &ip->i_flags)) {
- 		BUG_ON(!gfs2_glock_is_locked_by_me(ip->i_gl));
- 		gfs2_holder_mark_uninitialized(&gh);
- 		goto out_delete;
- 	}
- 
- 	if (test_bit(GIF_DEFERRED_DELETE, &ip->i_flags))
+ 	gfs2_holder_mark_uninitialized(&gh);
+ 	ret = evict_should_delete(inode, &gh);
+ 	if (ret == SHOULD_DEFER_EVICTION)
  		goto out;
++<<<<<<< HEAD
 +
 +	/* Deletes should never happen under memory pressure anymore.  */
 +	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC))
 +		goto out;
 +
 +	/* Must not read inode block until block type has been verified */
 +	error = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, &gh);
 +	if (unlikely(error)) {
 +		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
 +		ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
 +		gfs2_glock_dq_uninit(&ip->i_iopen_gh);
 +		goto out;
 +	}
 +
 +	if (gfs2_inode_already_deleted(ip->i_gl, ip->i_no_formal_ino))
 +		goto out_truncate;
 +	error = gfs2_check_blk_type(sdp, ip->i_no_addr, GFS2_BLKST_UNLINKED);
 +	if (error)
 +		goto out_truncate;
 +
 +	if (test_bit(GIF_INVALID, &ip->i_flags)) {
 +		error = gfs2_inode_refresh(ip);
 +		if (error)
 +			goto out_truncate;
 +	}
 +
 +	/*
 +	 * The inode may have been recreated in the meantime.
 +	 */
 +	if (inode->i_nlink)
 +		goto out_truncate;
 +
 +out_delete:
 +	if (gfs2_holder_initialized(&ip->i_iopen_gh) &&
 +	    test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
 +		if (!gfs2_upgrade_iopen_glock(inode)) {
 +			gfs2_holder_uninit(&ip->i_iopen_gh);
 +			goto out_truncate;
 +		}
 +	}
 +
 +	/* Case 1 starts here */
 +
 +	if (S_ISDIR(inode->i_mode) &&
 +	    (ip->i_diskflags & GFS2_DIF_EXHASH)) {
 +		error = gfs2_dir_exhash_dealloc(ip);
 +		if (error)
 +			goto out_unlock;
 +	}
 +
 +	if (ip->i_eattr) {
 +		error = gfs2_ea_dealloc(ip);
 +		if (error)
 +			goto out_unlock;
 +	}
 +
 +	if (!gfs2_is_stuffed(ip)) {
 +		error = gfs2_file_dealloc(ip);
 +		if (error)
 +			goto out_unlock;
 +	}
 +
 +	/* We're about to clear the bitmap for the dinode, but as soon as we
 +	   do, gfs2_create_inode can create another inode at the same block
 +	   location and try to set gl_object again. We clear gl_object here so
 +	   that subsequent inode creates don't see an old gl_object. */
 +	glock_clear_object(ip->i_gl, ip);
 +	error = gfs2_dinode_dealloc(ip);
 +	gfs2_inode_remember_delete(ip->i_gl, ip->i_no_formal_ino);
++=======
+ 	if (ret == SHOULD_NOT_DELETE_DINODE)
+ 		goto out_truncate;
+ 
+ 	ret = evict_unlinked_inode(inode);
++>>>>>>> 53dbc27eb189 (gfs2: further simplify gfs2_evict_inode with new func evict_should_delete)
  	goto out_unlock;
  
  out_truncate:
* Unmerged path fs/gfs2/super.c
