KVM: SVM: Modify intercept_exceptions to generic intercepts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Babu Moger <babu.moger@amd.com>
commit 9780d51dc2af1c02bed9687822ba0d6df955c302
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/9780d51d.failed

Modify intercept_exceptions to generic intercepts in vmcb_control_area. Use
the generic vmcb_set_intercept, vmcb_clr_intercept and vmcb_is_intercept to
set/clear/test the intercept_exceptions bits.

	Signed-off-by: Babu Moger <babu.moger@amd.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
Message-Id: <159985250037.11252.1361972528657052410.stgit@bmoger-ubuntu>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9780d51dc2af1c02bed9687822ba0d6df955c302)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/svm.h
#	arch/x86/kvm/svm/nested.c
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/include/asm/svm.h
index acac55d6f941,caf7a63d65aa..000000000000
--- a/arch/x86/include/asm/svm.h
+++ b/arch/x86/include/asm/svm.h
@@@ -3,7 -3,50 +3,53 @@@
  #define __SVM_H
  
  #include <uapi/asm/svm.h>
+ #include <uapi/asm/kvm.h>
  
++<<<<<<< HEAD
++=======
+ /*
+  * 32-bit intercept words in the VMCB Control Area, starting
+  * at Byte offset 000h.
+  */
+ 
+ enum intercept_words {
+ 	INTERCEPT_CR = 0,
+ 	INTERCEPT_DR,
+ 	INTERCEPT_EXCEPTION,
+ 	MAX_INTERCEPT,
+ };
+ 
+ enum {
+ 	/* Byte offset 000h (word 0) */
+ 	INTERCEPT_CR0_READ = 0,
+ 	INTERCEPT_CR3_READ = 3,
+ 	INTERCEPT_CR4_READ = 4,
+ 	INTERCEPT_CR8_READ = 8,
+ 	INTERCEPT_CR0_WRITE = 16,
+ 	INTERCEPT_CR3_WRITE = 16 + 3,
+ 	INTERCEPT_CR4_WRITE = 16 + 4,
+ 	INTERCEPT_CR8_WRITE = 16 + 8,
+ 	/* Byte offset 004h (word 1) */
+ 	INTERCEPT_DR0_READ = 32,
+ 	INTERCEPT_DR1_READ,
+ 	INTERCEPT_DR2_READ,
+ 	INTERCEPT_DR3_READ,
+ 	INTERCEPT_DR4_READ,
+ 	INTERCEPT_DR5_READ,
+ 	INTERCEPT_DR6_READ,
+ 	INTERCEPT_DR7_READ,
+ 	INTERCEPT_DR0_WRITE = 48,
+ 	INTERCEPT_DR1_WRITE,
+ 	INTERCEPT_DR2_WRITE,
+ 	INTERCEPT_DR3_WRITE,
+ 	INTERCEPT_DR4_WRITE,
+ 	INTERCEPT_DR5_WRITE,
+ 	INTERCEPT_DR6_WRITE,
+ 	INTERCEPT_DR7_WRITE,
+ 	/* Byte offset 008h (word 2) */
+ 	INTERCEPT_EXCEPTION_OFFSET = 64,
+ };
++>>>>>>> 9780d51dc2af (KVM: SVM: Modify intercept_exceptions to generic intercepts)
  
  enum {
  	INTERCEPT_INTR,
@@@ -57,9 -100,7 +103,13 @@@
  
  
  struct __attribute__ ((__packed__)) vmcb_control_area {
++<<<<<<< HEAD
 +	u32 intercept_cr;
 +	u32 intercept_dr;
 +	u32 intercept_exceptions;
++=======
+ 	u32 intercepts[MAX_INTERCEPT];
++>>>>>>> 9780d51dc2af (KVM: SVM: Modify intercept_exceptions to generic intercepts)
  	u64 intercept;
  	u8 reserved_1[40];
  	u16 pause_filter_thresh;
diff --cc arch/x86/kvm/svm/nested.c
index 3a222ac541d6,e9e6ad7fdbbe..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -108,11 -109,9 +108,14 @@@ void recalc_intercepts(struct vcpu_svm 
  	h = &svm->nested.hsave->control;
  	g = &svm->nested.ctl;
  
 -	for (i = 0; i < MAX_INTERCEPT; i++)
 -		c->intercepts[i] = h->intercepts[i];
 +	svm->nested.host_intercept_exceptions = h->intercept_exceptions;
  
++<<<<<<< HEAD
 +	c->intercept_cr = h->intercept_cr;
 +	c->intercept_dr = h->intercept_dr;
 +	c->intercept_exceptions = h->intercept_exceptions;
++=======
++>>>>>>> 9780d51dc2af (KVM: SVM: Modify intercept_exceptions to generic intercepts)
  	c->intercept = h->intercept;
  
  	if (g->int_ctl & V_INTR_MASKING_MASK) {
@@@ -131,18 -130,20 +134,32 @@@
  	/* We don't want to see VMMCALLs from a nested guest */
  	c->intercept &= ~(1ULL << INTERCEPT_VMMCALL);
  
++<<<<<<< HEAD
 +	c->intercept_cr |= g->intercept_cr;
 +	c->intercept_dr |= g->intercept_dr;
 +	c->intercept_exceptions |= g->intercept_exceptions;
++=======
+ 	for (i = 0; i < MAX_INTERCEPT; i++)
+ 		c->intercepts[i] |= g->intercepts[i];
+ 
++>>>>>>> 9780d51dc2af (KVM: SVM: Modify intercept_exceptions to generic intercepts)
  	c->intercept |= g->intercept;
  }
  
  static void copy_vmcb_control_area(struct vmcb_control_area *dst,
  				   struct vmcb_control_area *from)
  {
++<<<<<<< HEAD
 +	dst->intercept_cr         = from->intercept_cr;
 +	dst->intercept_dr         = from->intercept_dr;
 +	dst->intercept_exceptions = from->intercept_exceptions;
++=======
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < MAX_INTERCEPT; i++)
+ 		dst->intercepts[i] = from->intercepts[i];
+ 
++>>>>>>> 9780d51dc2af (KVM: SVM: Modify intercept_exceptions to generic intercepts)
  	dst->intercept            = from->intercept;
  	dst->iopm_base_pa         = from->iopm_base_pa;
  	dst->msrpm_base_pa        = from->msrpm_base_pa;
@@@ -459,16 -480,16 +476,23 @@@ int nested_svm_vmrun(struct vcpu_svm *s
  		goto out;
  	}
  
 -	trace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb12_gpa,
 -			       vmcb12->save.rip,
 -			       vmcb12->control.int_ctl,
 -			       vmcb12->control.event_inj,
 -			       vmcb12->control.nested_ctl);
 -
 +	trace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,
 +			       nested_vmcb->save.rip,
 +			       nested_vmcb->control.int_ctl,
 +			       nested_vmcb->control.event_inj,
 +			       nested_vmcb->control.nested_ctl);
 +
++<<<<<<< HEAD
 +	trace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,
 +				    nested_vmcb->control.intercept_cr >> 16,
 +				    nested_vmcb->control.intercept_exceptions,
 +				    nested_vmcb->control.intercept);
++=======
+ 	trace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,
+ 				    vmcb12->control.intercepts[INTERCEPT_CR] >> 16,
+ 				    vmcb12->control.intercepts[INTERCEPT_EXCEPTION],
+ 				    vmcb12->control.intercept);
++>>>>>>> 9780d51dc2af (KVM: SVM: Modify intercept_exceptions to generic intercepts)
  
  	/* Clear internal status */
  	kvm_clear_exception_queue(&svm->vcpu);
@@@ -960,10 -979,11 +984,11 @@@ int nested_svm_exit_special(struct vcpu
  	case SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {
  		u32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);
  
- 		if (get_host_vmcb(svm)->control.intercept_exceptions & excp_bits)
+ 		if (get_host_vmcb(svm)->control.intercepts[INTERCEPT_EXCEPTION] &
+ 				excp_bits)
  			return NESTED_EXIT_HOST;
  		else if (exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR &&
 -			 svm->vcpu.arch.apf.host_apf_flags)
 +			 svm->vcpu.arch.apf.host_apf_reason)
  			/* Trap async PF even if not shadowing */
  			return NESTED_EXIT_HOST;
  		break;
diff --cc arch/x86/kvm/svm/svm.c
index ffcc287ce9b5,c37d64fb05ff..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -2806,11 -2812,11 +2806,19 @@@ static void dump_vmcb(struct kvm_vcpu *
  	}
  
  	pr_err("VMCB Control Area:\n");
++<<<<<<< HEAD
 +	pr_err("%-20s%04x\n", "cr_read:", control->intercept_cr & 0xffff);
 +	pr_err("%-20s%04x\n", "cr_write:", control->intercept_cr >> 16);
 +	pr_err("%-20s%04x\n", "dr_read:", control->intercept_dr & 0xffff);
 +	pr_err("%-20s%04x\n", "dr_write:", control->intercept_dr >> 16);
 +	pr_err("%-20s%08x\n", "exceptions:", control->intercept_exceptions);
++=======
+ 	pr_err("%-20s%04x\n", "cr_read:", control->intercepts[INTERCEPT_CR] & 0xffff);
+ 	pr_err("%-20s%04x\n", "cr_write:", control->intercepts[INTERCEPT_CR] >> 16);
+ 	pr_err("%-20s%04x\n", "dr_read:", control->intercepts[INTERCEPT_DR] & 0xffff);
+ 	pr_err("%-20s%04x\n", "dr_write:", control->intercepts[INTERCEPT_DR] >> 16);
+ 	pr_err("%-20s%08x\n", "exceptions:", control->intercepts[INTERCEPT_EXCEPTION]);
++>>>>>>> 9780d51dc2af (KVM: SVM: Modify intercept_exceptions to generic intercepts)
  	pr_err("%-20s%016llx\n", "intercepts:", control->intercept);
  	pr_err("%-20s%d\n", "pause filter count:", control->pause_filter_count);
  	pr_err("%-20s%d\n", "pause filter threshold:",
* Unmerged path arch/x86/include/asm/svm.h
* Unmerged path arch/x86/kvm/svm/nested.c
* Unmerged path arch/x86/kvm/svm/svm.c
diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.h
index 7e2440454c08..1c791ba2424f 100644
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@ -275,20 +275,22 @@ static inline void clr_dr_intercepts(struct vcpu_svm *svm)
 	recalc_intercepts(svm);
 }
 
-static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)
+static inline void set_exception_intercept(struct vcpu_svm *svm, u32 bit)
 {
 	struct vmcb *vmcb = get_host_vmcb(svm);
 
-	vmcb->control.intercept_exceptions |= (1U << bit);
+	WARN_ON_ONCE(bit >= 32);
+	vmcb_set_intercept(&vmcb->control, INTERCEPT_EXCEPTION_OFFSET + bit);
 
 	recalc_intercepts(svm);
 }
 
-static inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)
+static inline void clr_exception_intercept(struct vcpu_svm *svm, u32 bit)
 {
 	struct vmcb *vmcb = get_host_vmcb(svm);
 
-	vmcb->control.intercept_exceptions &= ~(1U << bit);
+	WARN_ON_ONCE(bit >= 32);
+	vmcb_clr_intercept(&vmcb->control, INTERCEPT_EXCEPTION_OFFSET + bit);
 
 	recalc_intercepts(svm);
 }
