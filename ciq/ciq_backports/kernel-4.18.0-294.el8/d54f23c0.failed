RDMA/cma: Simplify DEVICE_REMOVAL for internal_id

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit d54f23c09ec62670901f1a2a4712a5218522ca2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d54f23c0.failed

cma_process_remove() triggers an unconditional rdma_destroy_id() for
internal_id's and skips the event deliver and transition through
RDMA_CM_DEVICE_REMOVAL.

This is confusing and unnecessary. internal_id always has
cma_listen_handler() as the handler, have it catch the
RDMA_CM_DEVICE_REMOVAL event and directly consume it and signal removal.

This way the FSM sequence never skips the DEVICE_REMOVAL case and the
logic in this hard to test area is simplified.

Link: https://lore.kernel.org/r/20200723070707.1771101-2-leon@kernel.org
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit d54f23c09ec62670901f1a2a4712a5218522ca2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cma.c
diff --cc drivers/infiniband/core/cma.c
index abf2fb7b598e,77743ce5216b..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -4817,11 -4812,11 +4821,16 @@@ static void cma_process_remove(struct c
  
  		list_del(&id_priv->listen_list);
  		list_del_init(&id_priv->list);
 -		cma_id_get(id_priv);
 +		atomic_inc(&id_priv->refcount);
  		mutex_unlock(&lock);
  
++<<<<<<< HEAD
 +		ret = id_priv->internal_id ? 1 : cma_remove_id_dev(id_priv);
 +		cma_deref_id(id_priv);
++=======
+ 		ret = cma_remove_id_dev(id_priv);
+ 		cma_id_put(id_priv);
++>>>>>>> d54f23c09ec6 (RDMA/cma: Simplify DEVICE_REMOVAL for internal_id)
  		if (ret)
  			rdma_destroy_id(&id_priv->id);
  
* Unmerged path drivers/infiniband/core/cma.c
