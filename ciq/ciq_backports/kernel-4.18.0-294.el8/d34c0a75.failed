mm: use unsigned types for fragmentation score

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Nitin Gupta <nigupta@nvidia.com>
commit d34c0a7599ea8c301bc471dfa1eb2bf2db6752d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/d34c0a75.failed

Proactive compaction uses per-node/zone "fragmentation score" which is
always in range [0, 100], so use unsigned type of these scores as well as
for related constants.

	Signed-off-by: Nitin Gupta <nigupta@nvidia.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Baoquan He <bhe@redhat.com>
	Cc: Luis Chamberlain <mcgrof@kernel.org>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Iurii Zaikin <yzaikin@google.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Link: http://lkml.kernel.org/r/20200618010319.13159-1-nigupta@nvidia.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d34c0a7599ea8c301bc471dfa1eb2bf2db6752d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compaction.h
#	kernel/sysctl.c
#	mm/compaction.c
#	mm/vmstat.c
diff --cc include/linux/compaction.h
index 2184076d18b0,25a521d299c1..000000000000
--- a/include/linux/compaction.h
+++ b/include/linux/compaction.h
@@@ -85,11 -85,13 +85,19 @@@ static inline unsigned long compact_gap
  
  #ifdef CONFIG_COMPACTION
  extern int sysctl_compact_memory;
++<<<<<<< HEAD
++=======
+ extern unsigned int sysctl_compaction_proactiveness;
++>>>>>>> d34c0a7599ea (mm: use unsigned types for fragmentation score)
  extern int sysctl_compaction_handler(struct ctl_table *table, int write,
 -			void *buffer, size_t *length, loff_t *ppos);
 +			void __user *buffer, size_t *length, loff_t *ppos);
  extern int sysctl_extfrag_threshold;
  extern int sysctl_compact_unevictable_allowed;
  
++<<<<<<< HEAD
++=======
+ extern unsigned int extfrag_for_order(struct zone *zone, unsigned int order);
++>>>>>>> d34c0a7599ea (mm: use unsigned types for fragmentation score)
  extern int fragmentation_index(struct zone *zone, unsigned int order);
  extern enum compact_result try_to_compact_pages(gfp_t gfp_mask,
  		unsigned int order, unsigned int alloc_flags,
diff --cc kernel/sysctl.c
index d9e0aff1f72d,287862f91717..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -1290,174 -1976,207 +1290,186 @@@ static struct ctl_table vm_table[] = 
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec,
  	},
 -#endif
 -#ifdef CONFIG_PARISC
  	{
 -		.procname	= "soft-power",
 -		.data		= &pwrsw_enabled,
 -		.maxlen		= sizeof (int),
 +		.procname	= "overcommit_ratio",
 +		.data		= &sysctl_overcommit_ratio,
 +		.maxlen		= sizeof(sysctl_overcommit_ratio),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= overcommit_ratio_handler,
  	},
 -#endif
 -#ifdef CONFIG_SYSCTL_ARCH_UNALIGN_ALLOW
  	{
 -		.procname	= "unaligned-trap",
 -		.data		= &unaligned_enabled,
 -		.maxlen		= sizeof (int),
 +		.procname	= "overcommit_kbytes",
 +		.data		= &sysctl_overcommit_kbytes,
 +		.maxlen		= sizeof(sysctl_overcommit_kbytes),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= overcommit_kbytes_handler,
  	},
 -#endif
  	{
 -		.procname	= "ctrl-alt-del",
 -		.data		= &C_A_D,
 +		.procname	= "page-cluster", 
 +		.data		= &page_cluster,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= SYSCTL_ZERO,
  	},
 -#ifdef CONFIG_FUNCTION_TRACER
  	{
 -		.procname	= "ftrace_enabled",
 -		.data		= &ftrace_enabled,
 -		.maxlen		= sizeof(int),
 +		.procname	= "dirty_background_ratio",
 +		.data		= &dirty_background_ratio,
 +		.maxlen		= sizeof(dirty_background_ratio),
  		.mode		= 0644,
 -		.proc_handler	= ftrace_enable_sysctl,
 +		.proc_handler	= dirty_background_ratio_handler,
 +		.extra1		= SYSCTL_ZERO,
 +		.extra2		= &one_hundred,
  	},
 -#endif
 -#ifdef CONFIG_STACK_TRACER
  	{
 -		.procname	= "stack_tracer_enabled",
 -		.data		= &stack_tracer_enabled,
 -		.maxlen		= sizeof(int),
 +		.procname	= "dirty_background_bytes",
 +		.data		= &dirty_background_bytes,
 +		.maxlen		= sizeof(dirty_background_bytes),
  		.mode		= 0644,
 -		.proc_handler	= stack_trace_sysctl,
 +		.proc_handler	= dirty_background_bytes_handler,
 +		.extra1		= &one_ul,
  	},
 -#endif
 -#ifdef CONFIG_TRACING
  	{
 -		.procname	= "ftrace_dump_on_oops",
 -		.data		= &ftrace_dump_on_oops,
 -		.maxlen		= sizeof(int),
 +		.procname	= "dirty_ratio",
 +		.data		= &vm_dirty_ratio,
 +		.maxlen		= sizeof(vm_dirty_ratio),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= dirty_ratio_handler,
 +		.extra1		= SYSCTL_ZERO,
 +		.extra2		= &one_hundred,
  	},
  	{
 -		.procname	= "traceoff_on_warning",
 -		.data		= &__disable_trace_on_warning,
 -		.maxlen		= sizeof(__disable_trace_on_warning),
 +		.procname	= "dirty_bytes",
 +		.data		= &vm_dirty_bytes,
 +		.maxlen		= sizeof(vm_dirty_bytes),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= dirty_bytes_handler,
 +		.extra1		= &dirty_bytes_min,
  	},
  	{
 -		.procname	= "tracepoint_printk",
 -		.data		= &tracepoint_printk,
 -		.maxlen		= sizeof(tracepoint_printk),
 +		.procname	= "dirty_writeback_centisecs",
 +		.data		= &dirty_writeback_interval,
 +		.maxlen		= sizeof(dirty_writeback_interval),
  		.mode		= 0644,
 -		.proc_handler	= tracepoint_printk_sysctl,
 +		.proc_handler	= dirty_writeback_centisecs_handler,
  	},
 -#endif
 -#ifdef CONFIG_KEXEC_CORE
  	{
 -		.procname	= "kexec_load_disabled",
 -		.data		= &kexec_load_disabled,
 -		.maxlen		= sizeof(int),
 +		.procname	= "dirty_expire_centisecs",
 +		.data		= &dirty_expire_interval,
 +		.maxlen		= sizeof(dirty_expire_interval),
  		.mode		= 0644,
 -		/* only handle a transition from default "0" to "1" */
  		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= SYSCTL_ONE,
 +		.extra1		= SYSCTL_ZERO,
  	},
 -#endif
 -#ifdef CONFIG_MODULES
  	{
 -		.procname	= "modprobe",
 -		.data		= &modprobe_path,
 -		.maxlen		= KMOD_PATH_LEN,
 +		.procname	= "dirtytime_expire_seconds",
 +		.data		= &dirtytime_expire_interval,
 +		.maxlen		= sizeof(dirtytime_expire_interval),
  		.mode		= 0644,
 -		.proc_handler	= proc_dostring,
 +		.proc_handler	= dirtytime_interval_handler,
 +		.extra1		= SYSCTL_ZERO,
  	},
  	{
 -		.procname	= "modules_disabled",
 -		.data		= &modules_disabled,
 -		.maxlen		= sizeof(int),
 +		.procname	= "swappiness",
 +		.data		= &vm_swappiness,
 +		.maxlen		= sizeof(vm_swappiness),
  		.mode		= 0644,
 -		/* only handle a transition from default "0" to "1" */
  		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= SYSCTL_ONE,
 +		.extra1		= SYSCTL_ZERO,
 +		.extra2		= &one_hundred,
  	},
 -#endif
 -#ifdef CONFIG_UEVENT_HELPER
 +#ifdef CONFIG_HUGETLB_PAGE
  	{
 -		.procname	= "hotplug",
 -		.data		= &uevent_helper,
 -		.maxlen		= UEVENT_HELPER_PATH_LEN,
 +		.procname	= "nr_hugepages",
 +		.data		= NULL,
 +		.maxlen		= sizeof(unsigned long),
  		.mode		= 0644,
 -		.proc_handler	= proc_dostring,
 +		.proc_handler	= hugetlb_sysctl_handler,
  	},
 -#endif
 -#ifdef CONFIG_CHR_DEV_SG
 +#ifdef CONFIG_NUMA
  	{
 -		.procname	= "sg-big-buff",
 -		.data		= &sg_big_buff,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 +		.procname       = "nr_hugepages_mempolicy",
 +		.data           = NULL,
 +		.maxlen         = sizeof(unsigned long),
 +		.mode           = 0644,
 +		.proc_handler   = &hugetlb_mempolicy_sysctl_handler,
  	},
 -#endif
 -#ifdef CONFIG_BSD_PROCESS_ACCT
  	{
 -		.procname	= "acct",
 -		.data		= &acct_parm,
 -		.maxlen		= 3*sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.procname		= "numa_stat",
 +		.data			= &sysctl_vm_numa_stat,
 +		.maxlen			= sizeof(int),
 +		.mode			= 0644,
 +		.proc_handler	= sysctl_vm_numa_stat_handler,
 +		.extra1			= SYSCTL_ZERO,
 +		.extra2			= SYSCTL_ONE,
  	},
  #endif
 -#ifdef CONFIG_MAGIC_SYSRQ
 +	 {
 +		.procname	= "hugetlb_shm_group",
 +		.data		= &sysctl_hugetlb_shm_group,
 +		.maxlen		= sizeof(gid_t),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec,
 +	 },
  	{
 -		.procname	= "sysrq",
 +		.procname	= "nr_overcommit_hugepages",
  		.data		= NULL,
 -		.maxlen		= sizeof (int),
 +		.maxlen		= sizeof(unsigned long),
  		.mode		= 0644,
 -		.proc_handler	= sysrq_sysctl_handler,
 +		.proc_handler	= hugetlb_overcommit_handler,
  	},
  #endif
 -#ifdef CONFIG_PROC_SYSCTL
  	{
 -		.procname	= "cad_pid",
 -		.data		= NULL,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0600,
 -		.proc_handler	= proc_do_cad_pid,
 +		.procname	= "lowmem_reserve_ratio",
 +		.data		= &sysctl_lowmem_reserve_ratio,
 +		.maxlen		= sizeof(sysctl_lowmem_reserve_ratio),
 +		.mode		= 0644,
 +		.proc_handler	= lowmem_reserve_ratio_sysctl_handler,
  	},
 -#endif
  	{
 -		.procname	= "threads-max",
 -		.data		= NULL,
 +		.procname	= "drop_caches",
 +		.data		= &sysctl_drop_caches,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= sysctl_max_threads,
 -	},
 -	{
 -		.procname	= "random",
 -		.mode		= 0555,
 -		.child		= random_table,
 -	},
 -	{
 -		.procname	= "usermodehelper",
 -		.mode		= 0555,
 -		.child		= usermodehelper_table,
 -	},
 -#ifdef CONFIG_FW_LOADER_USER_HELPER
 -	{
 -		.procname	= "firmware_config",
 -		.mode		= 0555,
 -		.child		= firmware_config_table,
 +		.proc_handler	= drop_caches_sysctl_handler,
 +		.extra1		= SYSCTL_ONE,
 +		.extra2		= &four,
  	},
 -#endif
 +#ifdef CONFIG_COMPACTION
  	{
 -		.procname	= "overflowuid",
 -		.data		= &overflowuid,
 +		.procname	= "compact_memory",
 +		.data		= &sysctl_compact_memory,
  		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &minolduid,
 -		.extra2		= &maxolduid,
 +		.mode		= 0200,
 +		.proc_handler	= sysctl_compaction_handler,
  	},
  	{
 -		.procname	= "overflowgid",
 -		.data		= &overflowgid,
 -		.maxlen		= sizeof(int),
++<<<<<<< HEAD
++=======
++		.procname	= "compaction_proactiveness",
++		.data		= &sysctl_compaction_proactiveness,
++		.maxlen		= sizeof(sysctl_compaction_proactiveness),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &minolduid,
 -		.extra2		= &maxolduid,
++		.extra1		= SYSCTL_ZERO,
++		.extra2		= &one_hundred,
+ 	},
 -#ifdef CONFIG_S390
+ 	{
 -		.procname	= "userprocess_debug",
 -		.data		= &show_unhandled_signals,
++>>>>>>> d34c0a7599ea (mm: use unsigned types for fragmentation score)
 +		.procname	= "extfrag_threshold",
 +		.data		= &sysctl_extfrag_threshold,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= &min_extfrag_threshold,
 +		.extra2		= &max_extfrag_threshold,
  	},
 -#endif
 -#ifdef CONFIG_SMP
  	{
 -		.procname	= "oops_all_cpu_backtrace",
 -		.data		= &sysctl_oops_all_cpu_backtrace,
 +		.procname	= "compact_unevictable_allowed",
 +		.data		= &sysctl_compact_unevictable_allowed,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 +		.proc_handler	= proc_dointvec_minmax_warn_RT_change,
  		.extra1		= SYSCTL_ZERO,
  		.extra2		= SYSCTL_ONE,
  	},
diff --cc mm/compaction.c
index 35fc5ff5f321,b7d433f1706a..000000000000
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@@ -50,6 -50,24 +50,27 @@@ static inline void count_compact_events
  #define pageblock_start_pfn(pfn)	block_start_pfn(pfn, pageblock_order)
  #define pageblock_end_pfn(pfn)		block_end_pfn(pfn, pageblock_order)
  
++<<<<<<< HEAD
++=======
+ /*
+  * Fragmentation score check interval for proactive compaction purposes.
+  */
+ static const unsigned int HPAGE_FRAG_CHECK_INTERVAL_MSEC = 500;
+ 
+ /*
+  * Page order with-respect-to which proactive compaction
+  * calculates external fragmentation, which is used as
+  * the "fragmentation score" of a node/zone.
+  */
+ #if defined CONFIG_TRANSPARENT_HUGEPAGE
+ #define COMPACTION_HPAGE_ORDER	HPAGE_PMD_ORDER
+ #elif defined CONFIG_HUGETLBFS
+ #define COMPACTION_HPAGE_ORDER	HUGETLB_PAGE_ORDER
+ #else
+ #define COMPACTION_HPAGE_ORDER	(PMD_SHIFT - PAGE_SHIFT)
+ #endif
+ 
++>>>>>>> d34c0a7599ea (mm: use unsigned types for fragmentation score)
  static unsigned long release_freepages(struct list_head *freelist)
  {
  	struct page *page, *next;
@@@ -1313,8 -1875,77 +1334,82 @@@ static inline bool is_via_compact_memor
  	return order == -1;
  }
  
++<<<<<<< HEAD
 +static enum compact_result __compact_finished(struct zone *zone,
 +						struct compact_control *cc)
++=======
+ static bool kswapd_is_running(pg_data_t *pgdat)
+ {
+ 	return pgdat->kswapd && (pgdat->kswapd->state == TASK_RUNNING);
+ }
+ 
+ /*
+  * A zone's fragmentation score is the external fragmentation wrt to the
+  * COMPACTION_HPAGE_ORDER scaled by the zone's size. It returns a value
+  * in the range [0, 100].
+  *
+  * The scaling factor ensures that proactive compaction focuses on larger
+  * zones like ZONE_NORMAL, rather than smaller, specialized zones like
+  * ZONE_DMA32. For smaller zones, the score value remains close to zero,
+  * and thus never exceeds the high threshold for proactive compaction.
+  */
+ static unsigned int fragmentation_score_zone(struct zone *zone)
+ {
+ 	unsigned long score;
+ 
+ 	score = zone->present_pages *
+ 			extfrag_for_order(zone, COMPACTION_HPAGE_ORDER);
+ 	return div64_ul(score, zone->zone_pgdat->node_present_pages + 1);
+ }
+ 
+ /*
+  * The per-node proactive (background) compaction process is started by its
+  * corresponding kcompactd thread when the node's fragmentation score
+  * exceeds the high threshold. The compaction process remains active till
+  * the node's score falls below the low threshold, or one of the back-off
+  * conditions is met.
+  */
+ static unsigned int fragmentation_score_node(pg_data_t *pgdat)
+ {
+ 	unsigned int score = 0;
+ 	int zoneid;
+ 
+ 	for (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {
+ 		struct zone *zone;
+ 
+ 		zone = &pgdat->node_zones[zoneid];
+ 		score += fragmentation_score_zone(zone);
+ 	}
+ 
+ 	return score;
+ }
+ 
+ static unsigned int fragmentation_score_wmark(pg_data_t *pgdat, bool low)
+ {
+ 	unsigned int wmark_low;
+ 
+ 	/*
+ 	 * Cap the low watermak to avoid excessive compaction
+ 	 * activity in case a user sets the proactivess tunable
+ 	 * close to 100 (maximum).
+ 	 */
+ 	wmark_low = max(100U - sysctl_compaction_proactiveness, 5U);
+ 	return low ? wmark_low : min(wmark_low + 10, 100U);
+ }
+ 
+ static bool should_proactive_compact_node(pg_data_t *pgdat)
+ {
+ 	int wmark_high;
+ 
+ 	if (!sysctl_compaction_proactiveness || kswapd_is_running(pgdat))
+ 		return false;
+ 
+ 	wmark_high = fragmentation_score_wmark(pgdat, false);
+ 	return fragmentation_score_node(pgdat) > wmark_high;
+ }
+ 
+ static enum compact_result __compact_finished(struct compact_control *cc)
++>>>>>>> d34c0a7599ea (mm: use unsigned types for fragmentation score)
  {
  	unsigned int order;
  	const int migratetype = cc->migratetype;
@@@ -1883,6 -2611,13 +1978,16 @@@ static void compact_nodes(void
  int sysctl_compact_memory;
  
  /*
++<<<<<<< HEAD
++=======
+  * Tunable for proactive compaction. It determines how
+  * aggressively the kernel should compact memory in the
+  * background. It takes values in the range [0, 100].
+  */
+ unsigned int __read_mostly sysctl_compaction_proactiveness = 20;
+ 
+ /*
++>>>>>>> d34c0a7599ea (mm: use unsigned types for fragmentation score)
   * This is the entry point for compacting all nodes via
   * /proc/sys/vm/compact_memory
   */
diff --cc mm/vmstat.c
index 8285022e8e12,3bb034c99887..000000000000
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@@ -1073,6 -1096,24 +1073,27 @@@ static int __fragmentation_index(unsign
  	return 1000 - div_u64( (1000+(div_u64(info->free_pages * 1000ULL, requested))), info->free_blocks_total);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Calculates external fragmentation within a zone wrt the given order.
+  * It is defined as the percentage of pages found in blocks of size
+  * less than 1 << order. It returns values in range [0, 100].
+  */
+ unsigned int extfrag_for_order(struct zone *zone, unsigned int order)
+ {
+ 	struct contig_page_info info;
+ 
+ 	fill_contig_page_info(zone, order, &info);
+ 	if (info.free_pages == 0)
+ 		return 0;
+ 
+ 	return div_u64((info.free_pages -
+ 			(info.free_blocks_suitable << order)) * 100,
+ 			info.free_pages);
+ }
+ 
++>>>>>>> d34c0a7599ea (mm: use unsigned types for fragmentation score)
  /* Same as __fragmentation index but allocs contig_page_info on stack */
  int fragmentation_index(struct zone *zone, unsigned int order)
  {
* Unmerged path include/linux/compaction.h
* Unmerged path kernel/sysctl.c
* Unmerged path mm/compaction.c
* Unmerged path mm/vmstat.c
