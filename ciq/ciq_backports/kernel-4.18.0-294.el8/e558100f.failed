NFS: Do some tidying of the parsing code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit e558100fda7e8c7888f523920214bcb35ed9382b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e558100f.failed

Do some tidying of the parsing code, including:

 (*) Returning 0/error rather than true/false.

 (*) Putting the nfs_fs_context pointer first in some arg lists.

 (*) Unwrap some lines that will now fit on one line.

 (*) Provide unioned sockaddr/sockaddr_storage fields to avoid casts.

 (*) nfs_parse_devname() can paste its return values directly into the
     nfs_fs_context struct as that's where the caller puts them.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit e558100fda7e8c7888f523920214bcb35ed9382b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/fs_context.c
#	fs/nfs/internal.h
#	fs/nfs/super.c
diff --cc fs/nfs/internal.h
index feae10c2f600,003c2b8eb1e6..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -80,12 -81,12 +80,17 @@@ struct nfs_client_initdata 
  /*
   * In-kernel mount arguments
   */
++<<<<<<< HEAD
 +struct nfs_parsed_mount_data {
 +	int			flags;
++=======
+ struct nfs_fs_context {
+ 	unsigned int		flags;		/* NFS{,4}_MOUNT_* flags */
++>>>>>>> e558100fda7e (NFS: Do some tidying of the parsing code)
  	unsigned int		rsize, wsize;
  	unsigned int		timeo, retrans;
- 	unsigned int		acregmin, acregmax,
- 				acdirmin, acdirmax;
+ 	unsigned int		acregmin, acregmax;
+ 	unsigned int		acdirmin, acdirmax;
  	unsigned int		namlen;
  	unsigned int		options;
  	unsigned int		bsize;
@@@ -95,10 -96,16 +100,13 @@@
  	unsigned int		version;
  	unsigned int		minorversion;
  	char			*fscache_uniq;
 -	unsigned short		protofamily;
 -	unsigned short		mountfamily;
  	bool			need_mount;
 -	bool			sloppy;
  
  	struct {
- 		struct sockaddr_storage	address;
+ 		union {
+ 			struct sockaddr	address;
+ 			struct sockaddr_storage	_address;
+ 		};
  		size_t			addrlen;
  		char			*hostname;
  		u32			version;
diff --cc fs/nfs/super.c
index 5a0a0d311ce8,59962bc0118f..000000000000
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@@ -1797,13 -816,13 +1797,20 @@@ static int nfs_request_mount(struct nfs
  	/*
  	 * Construct the mount server's address.
  	 */
++<<<<<<< HEAD
 +	if (args->mount_server.address.ss_family == AF_UNSPEC) {
 +		memcpy(request.sap, &args->nfs_server.address,
 +		       args->nfs_server.addrlen);
 +		args->mount_server.addrlen = args->nfs_server.addrlen;
++=======
+ 	if (cfg->mount_server.address.sa_family == AF_UNSPEC) {
+ 		memcpy(request.sap, &cfg->nfs_server.address,
+ 		       cfg->nfs_server.addrlen);
+ 		cfg->mount_server.addrlen = cfg->nfs_server.addrlen;
++>>>>>>> e558100fda7e (NFS: Do some tidying of the parsing code)
  	}
 -	request.salen = cfg->mount_server.addrlen;
 -	nfs_set_port(request.sap, &cfg->mount_server.port, 0);
 +	request.salen = args->mount_server.addrlen;
 +	nfs_set_port(request.sap, &args->mount_server.port, 0);
  
  	/*
  	 * Now ask the mount server to map our export path
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/super.c
