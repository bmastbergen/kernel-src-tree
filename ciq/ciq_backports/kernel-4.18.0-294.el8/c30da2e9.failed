fuse: convert to use the new mount API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit c30da2e981a703c6b1d49911511f7ade8dac20be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c30da2e9.failed

Convert the fuse filesystem to the new internal mount API as the old
one will be obsoleted and removed.  This allows greater flexibility in
communication of mount parameters between userspace, the VFS and the
filesystem.

See Documentation/filesystems/mount_api.txt for more information.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit c30da2e981a703c6b1d49911511f7ade8dac20be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/inode.c
diff --cc fs/fuse/inode.c
index 10b75246113a,c334f95e799a..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -59,9 -60,30 +60,33 @@@ MODULE_PARM_DESC(max_user_congthresh
  /** Congestion starts at 75% of maximum */
  #define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BLOCK
+ static struct file_system_type fuseblk_fs_type;
+ #endif
+ 
+ struct fuse_fs_context {
+ 	const char	*subtype;
+ 	bool		is_bdev;
+ 	int fd;
+ 	unsigned rootmode;
+ 	kuid_t user_id;
+ 	kgid_t group_id;
+ 	unsigned fd_present:1;
+ 	unsigned rootmode_present:1;
+ 	unsigned user_id_present:1;
+ 	unsigned group_id_present:1;
+ 	unsigned default_permissions:1;
+ 	unsigned allow_other:1;
+ 	unsigned max_read;
+ 	unsigned blksize;
+ };
+ 
++>>>>>>> c30da2e981a7 (fuse: convert to use the new mount API)
  struct fuse_forget_link *fuse_alloc_forget(void)
  {
 -	return kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);
 +	return kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL_ACCOUNT);
  }
  
  static struct inode *fuse_alloc_inode(struct super_block *sb)
@@@ -452,111 -463,110 +479,120 @@@ enum 
  	OPT_ERR
  };
  
- static const match_table_t tokens = {
- 	{OPT_FD,			"fd=%u"},
- 	{OPT_ROOTMODE,			"rootmode=%o"},
- 	{OPT_USER_ID,			"user_id=%u"},
- 	{OPT_GROUP_ID,			"group_id=%u"},
- 	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
- 	{OPT_ALLOW_OTHER,		"allow_other"},
- 	{OPT_MAX_READ,			"max_read=%u"},
- 	{OPT_BLKSIZE,			"blksize=%u"},
- 	{OPT_ERR,			NULL}
+ static const struct fs_parameter_spec fuse_param_specs[] = {
+ 	fsparam_string	("source",		OPT_SOURCE),
+ 	fsparam_u32	("fd",			OPT_FD),
+ 	fsparam_u32oct	("rootmode",		OPT_ROOTMODE),
+ 	fsparam_u32	("user_id",		OPT_USER_ID),
+ 	fsparam_u32	("group_id",		OPT_GROUP_ID),
+ 	fsparam_flag	("default_permissions",	OPT_DEFAULT_PERMISSIONS),
+ 	fsparam_flag	("allow_other",		OPT_ALLOW_OTHER),
+ 	fsparam_u32	("max_read",		OPT_MAX_READ),
+ 	fsparam_u32	("blksize",		OPT_BLKSIZE),
+ 	__fsparam(fs_param_is_string, "subtype", OPT_SUBTYPE,
+ 		  fs_param_v_optional),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description fuse_fs_parameters = {
+ 	.name		= "fuse",
+ 	.specs		= fuse_param_specs,
  };
  
- static int fuse_match_uint(substring_t *s, unsigned int *res)
+ static int fuse_parse_param(struct fs_context *fc, struct fs_parameter *param)
  {
- 	int err = -ENOMEM;
- 	char *buf = match_strdup(s);
- 	if (buf) {
- 		err = kstrtouint(buf, 10, res);
- 		kfree(buf);
- 	}
- 	return err;
- }
+ 	struct fs_parse_result result;
+ 	struct fuse_fs_context *ctx = fc->fs_private;
+ 	int opt;
  
++<<<<<<< HEAD
 +static int parse_fuse_opt(char *opt, struct fuse_fs_context *d, int is_bdev,
 +			  struct user_namespace *user_ns)
 +{
 +	char *p;
 +	memset(d, 0, sizeof(struct fuse_fs_context));
 +	d->max_read = ~0;
 +	d->blksize = FUSE_DEFAULT_BLKSIZE;
++=======
+ 	opt = fs_parse(fc, &fuse_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
++>>>>>>> c30da2e981a7 (fuse: convert to use the new mount API)
+ 
+ 	switch (opt) {
+ 	case OPT_SOURCE:
+ 		if (fc->source)
+ 			return invalf(fc, "fuse: Multiple sources specified");
+ 		fc->source = param->string;
+ 		param->string = NULL;
+ 		break;
+ 
+ 	case OPT_SUBTYPE:
+ 		if (ctx->subtype)
+ 			return invalf(fc, "fuse: Multiple subtypes specified");
+ 		ctx->subtype = param->string;
+ 		param->string = NULL;
+ 		return 0;
  
- 	while ((p = strsep(&opt, ",")) != NULL) {
- 		int token;
- 		int value;
- 		unsigned uv;
- 		substring_t args[MAX_OPT_ARGS];
- 		if (!*p)
- 			continue;
- 
- 		token = match_token(p, tokens, args);
- 		switch (token) {
- 		case OPT_FD:
- 			if (match_int(&args[0], &value))
- 				return 0;
- 			d->fd = value;
- 			d->fd_present = 1;
- 			break;
- 
- 		case OPT_ROOTMODE:
- 			if (match_octal(&args[0], &value))
- 				return 0;
- 			if (!fuse_valid_type(value))
- 				return 0;
- 			d->rootmode = value;
- 			d->rootmode_present = 1;
- 			break;
- 
- 		case OPT_USER_ID:
- 			if (fuse_match_uint(&args[0], &uv))
- 				return 0;
- 			d->user_id = make_kuid(user_ns, uv);
- 			if (!uid_valid(d->user_id))
- 				return 0;
- 			d->user_id_present = 1;
- 			break;
- 
- 		case OPT_GROUP_ID:
- 			if (fuse_match_uint(&args[0], &uv))
- 				return 0;
- 			d->group_id = make_kgid(user_ns, uv);
- 			if (!gid_valid(d->group_id))
- 				return 0;
- 			d->group_id_present = 1;
- 			break;
- 
- 		case OPT_DEFAULT_PERMISSIONS:
- 			d->default_permissions = 1;
- 			break;
- 
- 		case OPT_ALLOW_OTHER:
- 			d->allow_other = 1;
- 			break;
- 
- 		case OPT_MAX_READ:
- 			if (match_int(&args[0], &value))
- 				return 0;
- 			d->max_read = value;
- 			break;
- 
- 		case OPT_BLKSIZE:
- 			if (!is_bdev || match_int(&args[0], &value))
- 				return 0;
- 			d->blksize = value;
- 			break;
- 
- 		default:
- 			return 0;
- 		}
+ 	case OPT_FD:
+ 		ctx->fd = result.uint_32;
+ 		ctx->fd_present = 1;
+ 		break;
+ 
+ 	case OPT_ROOTMODE:
+ 		if (!fuse_valid_type(result.uint_32))
+ 			return invalf(fc, "fuse: Invalid rootmode");
+ 		ctx->rootmode = result.uint_32;
+ 		ctx->rootmode_present = 1;
+ 		break;
+ 
+ 	case OPT_USER_ID:
+ 		ctx->user_id = make_kuid(fc->user_ns, result.uint_32);
+ 		if (!uid_valid(ctx->user_id))
+ 			return invalf(fc, "fuse: Invalid user_id");
+ 		ctx->user_id_present = 1;
+ 		break;
+ 
+ 	case OPT_GROUP_ID:
+ 		ctx->group_id = make_kgid(fc->user_ns, result.uint_32);
+ 		if (!gid_valid(ctx->group_id))
+ 			return invalf(fc, "fuse: Invalid group_id");
+ 		ctx->group_id_present = 1;
+ 		break;
+ 
+ 	case OPT_DEFAULT_PERMISSIONS:
+ 		ctx->default_permissions = 1;
+ 		break;
+ 
+ 	case OPT_ALLOW_OTHER:
+ 		ctx->allow_other = 1;
+ 		break;
+ 
+ 	case OPT_MAX_READ:
+ 		ctx->max_read = result.uint_32;
+ 		break;
+ 
+ 	case OPT_BLKSIZE:
+ 		if (!ctx->is_bdev)
+ 			return invalf(fc, "fuse: blksize only supported for fuseblk");
+ 		ctx->blksize = result.uint_32;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
  	}
  
- 	if (!d->fd_present || !d->rootmode_present ||
- 	    !d->user_id_present || !d->group_id_present)
- 		return 0;
+ 	return 0;
+ }
+ 
+ static void fuse_free_fc(struct fs_context *fc)
+ {
+ 	struct fuse_fs_context *ctx = fc->fs_private;
  
- 	return 1;
+ 	if (ctx) {
+ 		kfree(ctx->subtype);
+ 		kfree(ctx);
+ 	}
  }
  
  static int fuse_show_options(struct seq_file *m, struct dentry *root)
@@@ -1122,13 -1083,17 +1158,22 @@@ void fuse_dev_free(struct fuse_dev *fud
  }
  EXPORT_SYMBOL_GPL(fuse_dev_free);
  
++<<<<<<< HEAD
 +int fuse_fill_super_common(struct super_block *sb, struct fuse_fs_context *d)
++=======
+ static int fuse_fill_super(struct super_block *sb, struct fs_context *fsc)
++>>>>>>> c30da2e981a7 (fuse: convert to use the new mount API)
  {
+ 	struct fuse_fs_context *ctx = fsc->fs_private;
  	struct fuse_dev *fud;
 -	struct fuse_conn *fc;
 +	struct fuse_conn *fc = get_fuse_conn_super(sb);
  	struct inode *root;
++<<<<<<< HEAD
++=======
+ 	struct file *file;
++>>>>>>> c30da2e981a7 (fuse: convert to use the new mount API)
  	struct dentry *root_dentry;
 -	struct fuse_req *init_req;
  	int err;
 -	int is_bdev = sb->s_bdev != NULL;
  
  	err = -EINVAL;
  	if (sb->s_flags & SB_MANDLOCK)
@@@ -1136,10 -1101,10 +1181,17 @@@
  
  	sb->s_flags &= ~(SB_NOSEC | SB_I_VERSION);
  
++<<<<<<< HEAD
 +	if (d->is_bdev) {
 +#ifdef CONFIG_BLOCK
 +		err = -EINVAL;
 +		if (!sb_set_blocksize(sb, d->blksize))
++=======
+ 	if (is_bdev) {
+ #ifdef CONFIG_BLOCK
+ 		err = -EINVAL;
+ 		if (!sb_set_blocksize(sb, ctx->blksize))
++>>>>>>> c30da2e981a7 (fuse: convert to use the new mount API)
  			goto err;
  #endif
  	} else {
@@@ -1156,6 -1124,19 +1211,22 @@@
  	if (sb->s_user_ns != &init_user_ns)
  		sb->s_iflags |= SB_I_UNTRUSTED_MOUNTER;
  
++<<<<<<< HEAD
++=======
+ 	file = fget(ctx->fd);
+ 	err = -EINVAL;
+ 	if (!file)
+ 		goto err;
+ 
+ 	/*
+ 	 * Require mount to happen from the same user namespace which
+ 	 * opened /dev/fuse to prevent potential attacks.
+ 	 */
+ 	if (file->f_op != &fuse_dev_operations ||
+ 	    file->f_cred->user_ns != sb->s_user_ns)
+ 		goto err_fput;
+ 
++>>>>>>> c30da2e981a7 (fuse: convert to use the new mount API)
  	/*
  	 * If we are not in the initial user namespace posix
  	 * acls must be translated.
@@@ -1178,18 -1167,17 +1249,32 @@@
  		fc->dont_mask = 1;
  	sb->s_flags |= SB_POSIXACL;
  
++<<<<<<< HEAD
 +	fc->default_permissions = d->default_permissions;
 +	fc->allow_other = d->allow_other;
 +	fc->user_id = d->user_id;
 +	fc->group_id = d->group_id;
 +	fc->max_read = max_t(unsigned, 4096, d->max_read);
 +	fc->destroy = d->destroy;
 +	fc->no_control = d->no_control;
 +	fc->no_force_umount = d->no_force_umount;
 +	fc->no_mount_options = d->no_mount_options;
 +
 +	err = -ENOMEM;
 +	root = fuse_get_root_inode(sb, d->rootmode);
++=======
+ 	fc->default_permissions = ctx->default_permissions;
+ 	fc->allow_other = ctx->allow_other;
+ 	fc->user_id = ctx->user_id;
+ 	fc->group_id = ctx->group_id;
+ 	fc->max_read = max_t(unsigned, 4096, ctx->max_read);
+ 
+ 	/* Used by get_root_inode() */
+ 	sb->s_fs_info = fc;
+ 
+ 	err = -ENOMEM;
+ 	root = fuse_get_root_inode(sb, ctx->rootmode);
++>>>>>>> c30da2e981a7 (fuse: convert to use the new mount API)
  	sb->s_d_op = &fuse_root_dentry_operations;
  	root_dentry = d_make_root(root);
  	if (!root_dentry)
* Unmerged path fs/fuse/inode.c
