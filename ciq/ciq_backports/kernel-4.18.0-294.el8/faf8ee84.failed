xfs: xfs_dabuf_map should return ENOMEM when map allocation fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit faf8ee8476c19b30fd16079ad616b2b0f56eaff4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/faf8ee84.failed

If the xfs_buf_map array allocation in xfs_dabuf_map fails for whatever
reason, we bail out with error code zero.  This will confuse callers, so
make sure that we return ENOMEM.  Allocation failure should never happen
with the small size of the array, but code defensively anyway.

Fixes: 45feef8f50b94d ("xfs: refactor xfs_dabuf_map")
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
(cherry picked from commit faf8ee8476c19b30fd16079ad616b2b0f56eaff4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_da_btree.c
diff --cc fs/xfs/libxfs/xfs_da_btree.c
index a977e915a859,897749c41f36..000000000000
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@@ -2573,42 -2501,68 +2573,57 @@@ xfs_dabuf_map
  {
  	struct xfs_mount	*mp = dp->i_mount;
  	int			nfsb = xfs_dabuf_nfsb(mp, whichfork);
 -	struct xfs_bmbt_irec	irec, *irecs = &irec;
 -	struct xfs_buf_map	*map = *mapp;
 -	xfs_fileoff_t		off = bno;
 -	int			error = 0, nirecs, i;
 +	int			error = 0;
 +	struct xfs_bmbt_irec	irec;
 +	struct xfs_bmbt_irec	*irecs = &irec;
 +	int			nirecs;
  
 -	if (nfsb > 1)
 -		irecs = kmem_zalloc(sizeof(irec) * nfsb, KM_NOFS);
 +	ASSERT(map && *map);
 +	ASSERT(*nmaps == 1);
  
 +	if (nfsb != 1)
 +		irecs = kmem_zalloc(sizeof(irec) * nfsb, KM_NOFS);
  	nirecs = nfsb;
 -	error = xfs_bmapi_read(dp, bno, nfsb, irecs, &nirecs,
 -			xfs_bmapi_aflag(whichfork));
 +	error = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,
 +			       &nirecs, xfs_bmapi_aflag(whichfork));
  	if (error)
 -		goto out_free_irecs;
 +		goto out;
  
++<<<<<<< HEAD
 +	if (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {
 +		/* Caller ok with no mapping. */
 +		if (mappedbno == -2) {
 +			error = -1;
 +			goto out;
 +		}
++=======
+ 	/*
+ 	 * Use the caller provided map for the single map case, else allocate a
+ 	 * larger one that needs to be free by the caller.
+ 	 */
+ 	if (nirecs > 1) {
+ 		map = kmem_zalloc(nirecs * sizeof(struct xfs_buf_map), KM_NOFS);
+ 		if (!map) {
+ 			error = -ENOMEM;
+ 			goto out_free_irecs;
+ 		}
+ 		*mapp = map;
+ 	}
++>>>>>>> faf8ee8476c1 (xfs: xfs_dabuf_map should return ENOMEM when map allocation fails)
  
 -	for (i = 0; i < nirecs; i++) {
 -		if (irecs[i].br_startblock == HOLESTARTBLOCK ||
 -		    irecs[i].br_startblock == DELAYSTARTBLOCK)
 -			goto invalid_mapping;
 -		if (off != irecs[i].br_startoff)
 -			goto invalid_mapping;
 -
 -		map[i].bm_bn = XFS_FSB_TO_DADDR(mp, irecs[i].br_startblock);
 -		map[i].bm_len = XFS_FSB_TO_BB(mp, irecs[i].br_blockcount);
 -		off += irecs[i].br_blockcount;
 -	}
 -
 -	if (off != bno + nfsb)
 -		goto invalid_mapping;
 -
 -	*nmaps = nirecs;
 -out_free_irecs:
 -	if (irecs != &irec)
 -		kmem_free(irecs);
 -	return error;
 -
 -invalid_mapping:
 -	/* Caller ok with no mapping. */
 -	if (XFS_IS_CORRUPT(mp, !(flags & XFS_DABUF_MAP_HOLE_OK))) {
 -		error = -EFSCORRUPTED;
 +		/* Caller expected a mapping, so abort. */
  		if (xfs_error_level >= XFS_ERRLEVEL_LOW) {
 -			xfs_alert(mp, "%s: bno %u inode %llu",
 -					__func__, bno, dp->i_ino);
 +			int i;
  
 -			for (i = 0; i < nirecs; i++) {
 +			xfs_alert(mp, "%s: bno %lld dir: inode %lld", __func__,
 +					(long long)bno, (long long)dp->i_ino);
 +			for (i = 0; i < *nmaps; i++) {
  				xfs_alert(mp,
  "[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d",
 -					i, irecs[i].br_startoff,
 -					irecs[i].br_startblock,
 -					irecs[i].br_blockcount,
 +					i,
 +					(long long)irecs[i].br_startoff,
 +					(long long)irecs[i].br_startblock,
 +					(long long)irecs[i].br_blockcount,
  					irecs[i].br_state);
  			}
  		}
* Unmerged path fs/xfs/libxfs/xfs_da_btree.c
