vfs: Convert nfsctl to use the new mount API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 96a374a35f822e53cad3b011dd5fbadec1b1473f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/96a374a3.failed

Convert the nfsctl filesystem to the new internal mount API as the old
one will be obsoleted and removed.  This allows greater flexibility in
communication of mount parameters between userspace, the VFS and the
filesystem.

See Documentation/filesystems/mount_api.txt for more information.

	Signed-off-by: David Howells <dhowells@redhat.com>
cc: "J. Bruce Fields" <bfields@fieldses.org>
cc: Jeff Layton <jlayton@kernel.org>
cc: linux-nfs@vger.kernel.org
(cherry picked from commit 96a374a35f822e53cad3b011dd5fbadec1b1473f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfsctl.c
diff --cc fs/nfsd/nfsctl.c
index f831a0a9bd66,0f154b0e1c8a..000000000000
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@@ -1148,201 -1147,8 +1149,205 @@@ static ssize_t write_v4_end_grace(struc
   *	populating the filesystem.
   */
  
++<<<<<<< HEAD
 +/* Basically copying rpc_get_inode. */
 +static struct inode *nfsd_get_inode(struct super_block *sb, umode_t mode)
 +{
 +	struct inode *inode = new_inode(sb);
 +	if (!inode)
 +		return NULL;
 +	/* Following advice from simple_fill_super documentation: */
 +	inode->i_ino = iunique(sb, NFSD_MaxReserved);
 +	inode->i_mode = mode;
 +	inode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);
 +	switch (mode & S_IFMT) {
 +	case S_IFDIR:
 +		inode->i_fop = &simple_dir_operations;
 +		inode->i_op = &simple_dir_inode_operations;
 +		inc_nlink(inode);
 +	default:
 +		break;
 +	}
 +	return inode;
 +}
 +
 +static int __nfsd_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode, struct nfsdfs_client *ncl)
 +{
 +	struct inode *inode;
 +
 +	inode = nfsd_get_inode(dir->i_sb, mode);
 +	if (!inode)
 +		return -ENOMEM;
 +	if (ncl) {
 +		inode->i_private = ncl;
 +		kref_get(&ncl->cl_ref);
 +	}
 +	d_add(dentry, inode);
 +	inc_nlink(dir);
 +	fsnotify_mkdir(dir, dentry);
 +	return 0;
 +}
 +
 +static struct dentry *nfsd_mkdir(struct dentry *parent, struct nfsdfs_client *ncl, char *name)
 +{
 +	struct inode *dir = parent->d_inode;
 +	struct dentry *dentry;
 +	int ret = -ENOMEM;
 +
 +	inode_lock(dir);
 +	dentry = d_alloc_name(parent, name);
 +	if (!dentry)
 +		goto out_err;
 +	ret = __nfsd_mkdir(d_inode(parent), dentry, S_IFDIR | 0600, ncl);
 +	if (ret)
 +		goto out_err;
 +out:
 +	inode_unlock(dir);
 +	return dentry;
 +out_err:
 +	dput(dentry);
 +	dentry = ERR_PTR(ret);
 +	goto out;
 +}
 +
 +static void clear_ncl(struct inode *inode)
 +{
 +	struct nfsdfs_client *ncl = inode->i_private;
 +
 +	inode->i_private = NULL;
 +	kref_put(&ncl->cl_ref, ncl->cl_release);
 +}
 +
 +static struct nfsdfs_client *__get_nfsdfs_client(struct inode *inode)
 +{
 +	struct nfsdfs_client *nc = inode->i_private;
 +
 +	if (nc)
 +		kref_get(&nc->cl_ref);
 +	return nc;
 +}
 +
 +struct nfsdfs_client *get_nfsdfs_client(struct inode *inode)
 +{
 +	struct nfsdfs_client *nc;
 +
 +	inode_lock_shared(inode);
 +	nc = __get_nfsdfs_client(inode);
 +	inode_unlock_shared(inode);
 +	return nc;
 +}
 +/* from __rpc_unlink */
 +static void nfsdfs_remove_file(struct inode *dir, struct dentry *dentry)
 +{
 +	int ret;
 +
 +	clear_ncl(d_inode(dentry));
 +	dget(dentry);
 +	ret = simple_unlink(dir, dentry);
 +	d_delete(dentry);
 +	dput(dentry);
 +	WARN_ON_ONCE(ret);
 +}
 +
 +static void nfsdfs_remove_files(struct dentry *root)
 +{
 +	struct dentry *dentry, *tmp;
 +
 +	list_for_each_entry_safe(dentry, tmp, &root->d_subdirs, d_child) {
 +		if (!simple_positive(dentry)) {
 +			WARN_ON_ONCE(1); /* I think this can't happen? */
 +			continue;
 +		}
 +		nfsdfs_remove_file(d_inode(root), dentry);
 +	}
 +}
 +
 +/* XXX: cut'n'paste from simple_fill_super; figure out if we could share
 + * code instead. */
 +static  int nfsdfs_create_files(struct dentry *root,
 +					const struct tree_descr *files)
 +{
 +	struct inode *dir = d_inode(root);
 +	struct inode *inode;
 +	struct dentry *dentry;
 +	int i;
 +
 +	inode_lock(dir);
 +	for (i = 0; files->name && files->name[0]; i++, files++) {
 +		if (!files->name)
 +			continue;
 +		dentry = d_alloc_name(root, files->name);
 +		if (!dentry)
 +			goto out;
 +		inode = nfsd_get_inode(d_inode(root)->i_sb,
 +					S_IFREG | files->mode);
 +		if (!inode) {
 +			dput(dentry);
 +			goto out;
 +		}
 +		inode->i_fop = files->ops;
 +		inode->i_private = __get_nfsdfs_client(dir);
 +		d_add(dentry, inode);
 +		fsnotify_create(dir, dentry);
 +	}
 +	inode_unlock(dir);
 +	return 0;
 +out:
 +	nfsdfs_remove_files(root);
 +	inode_unlock(dir);
 +	return -ENOMEM;
 +}
 +
 +/* on success, returns positive number unique to that client. */
 +struct dentry *nfsd_client_mkdir(struct nfsd_net *nn,
 +		struct nfsdfs_client *ncl, u32 id,
 +		const struct tree_descr *files)
 +{
 +	struct dentry *dentry;
 +	char name[11];
 +	int ret;
 +
 +	sprintf(name, "%u", id);
 +
 +	dentry = nfsd_mkdir(nn->nfsd_client_dir, ncl, name);
 +	if (IS_ERR(dentry)) /* XXX: tossing errors? */
 +		return NULL;
 +	ret = nfsdfs_create_files(dentry, files);
 +	if (ret) {
 +		nfsd_client_rmdir(dentry);
 +		return NULL;
 +	}
 +	return dentry;
 +}
 +
 +/* Taken from __rpc_rmdir: */
 +void nfsd_client_rmdir(struct dentry *dentry)
 +{
 +	struct inode *dir = d_inode(dentry->d_parent);
 +	struct inode *inode = d_inode(dentry);
 +	int ret;
 +
 +	inode_lock(dir);
 +	nfsdfs_remove_files(dentry);
 +	clear_ncl(inode);
 +	dget(dentry);
 +	ret = simple_rmdir(dir, dentry);
 +	WARN_ON_ONCE(ret);
 +	d_delete(dentry);
 +	dput(dentry);
 +	inode_unlock(dir);
 +}
 +
 +static int nfsd_fill_super(struct super_block * sb, void * data, int silent)
++=======
+ static int nfsd_fill_super(struct super_block *sb, struct fs_context *fc)
++>>>>>>> 96a374a35f82 (vfs: Convert nfsctl to use the new mount API)
  {
 +	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
 +							nfsd_net_id);
 +	struct dentry *dentry;
 +	int ret;
 +
  	static const struct tree_descr nfsd_files[] = {
  		[NFSD_List] = {"exports", &exports_nfsd_operations, S_IRUGO},
  		[NFSD_Export_features] = {"export_features",
@@@ -1371,23 -1177,33 +1376,46 @@@
  #endif
  		/* last one */ {""}
  	};
++<<<<<<< HEAD
 +	get_net(sb->s_fs_info);
 +	ret = simple_fill_super(sb, 0x6e667364, nfsd_files);
 +	if (ret)
 +		return ret;
 +	dentry = nfsd_mkdir(sb->s_root, NULL, "clients");
 +	if (IS_ERR(dentry))
 +		return PTR_ERR(dentry);
 +	nn->nfsd_client_dir = dentry;
 +	return 0;
 +
++=======
+ 
+ 	return simple_fill_super(sb, 0x6e667364, nfsd_files);
++>>>>>>> 96a374a35f82 (vfs: Convert nfsctl to use the new mount API)
+ }
+ 
+ static int nfsd_fs_get_tree(struct fs_context *fc)
+ {
+ 	fc->s_fs_info = get_net(fc->net_ns);
+ 	return vfs_get_super(fc, vfs_get_keyed_super, nfsd_fill_super);
+ }
+ 
+ static void nfsd_fs_free_fc(struct fs_context *fc)
+ {
+ 	if (fc->s_fs_info)
+ 		put_net(fc->s_fs_info);
  }
  
- static struct dentry *nfsd_mount(struct file_system_type *fs_type,
- 	int flags, const char *dev_name, void *data)
+ static const struct fs_context_operations nfsd_fs_context_ops = {
+ 	.free		= nfsd_fs_free_fc,
+ 	.get_tree	= nfsd_fs_get_tree,
+ };
+ 
+ static int nfsd_init_fs_context(struct fs_context *fc)
  {
- 	struct net *net = current->nsproxy->net_ns;
- 	return mount_ns(fs_type, flags, data, net, net->user_ns, nfsd_fill_super);
+ 	put_user_ns(fc->user_ns);
+ 	fc->user_ns = get_user_ns(fc->net_ns->user_ns);
+ 	fc->ops = &nfsd_fs_context_ops;
+ 	return 0;
  }
  
  static void nfsd_umount(struct super_block *sb)
* Unmerged path fs/nfsd/nfsctl.c
