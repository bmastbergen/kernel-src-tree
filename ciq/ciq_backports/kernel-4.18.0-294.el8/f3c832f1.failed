powerpc/watchpoint: Fix DAWR exception for CACHEOP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ravi Bangoria <ravi.bangoria@linux.ibm.com>
commit f3c832f1350bcf1e6906113ee3168066f4235dbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f3c832f1.failed

'ea' returned by analyse_instr() needs to be aligned down to cache
block size for CACHEOP instructions. analyse_instr() does not set
size for CACHEOP, thus size also needs to be calculated manually.

Fixes: 27985b2a640e ("powerpc/watchpoint: Don't ignore extraneous exceptions blindly")
Fixes: 74c6881019b7 ("powerpc/watchpoint: Prepare handler to handle more than one watchpoint")
	Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200723090813.303838-4-ravi.bangoria@linux.ibm.com
(cherry picked from commit f3c832f1350bcf1e6906113ee3168066f4235dbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/hw_breakpoint.c
diff --cc arch/powerpc/kernel/hw_breakpoint.c
index 90c5c77a5704,c55e67bab271..000000000000
--- a/arch/powerpc/kernel/hw_breakpoint.c
+++ b/arch/powerpc/kernel/hw_breakpoint.c
@@@ -444,35 -527,146 +444,145 @@@ dar_range_overlaps(unsigned long dar, i
  }
  
  /*
 - * If hw has multiple DAWR registers, we also need to check all
 - * dawrx constraint bits to confirm this is _really_ a valid event.
 - * If type is UNKNOWN, but privilege level matches, consider it as
 - * a positive match.
 + * Handle debug exception notifications.
   */
 -static bool check_dawrx_constraints(struct pt_regs *regs, int type,
 -				    struct arch_hw_breakpoint *info)
 +static bool stepping_handler(struct pt_regs *regs, struct perf_event *bp,
 +			     struct arch_hw_breakpoint *info)
  {
 -	if (OP_IS_LOAD(type) && !(info->type & HW_BRK_TYPE_READ))
 -		return false;
 +	unsigned int instr = 0;
 +	int ret, type, size;
 +	struct instruction_op op;
 +	unsigned long addr = info->address;
  
++<<<<<<< HEAD
 +	if (__get_user_inatomic(instr, (unsigned int *)regs->nip))
 +		goto fail;
++=======
+ 	/*
+ 	 * The Cache Management instructions other than dcbz never
+ 	 * cause a match. i.e. if type is CACHEOP, the instruction
+ 	 * is dcbz, and dcbz is treated as Store.
+ 	 */
+ 	if ((OP_IS_STORE(type) || type == CACHEOP) && !(info->type & HW_BRK_TYPE_WRITE))
+ 		return false;
++>>>>>>> f3c832f1350b (powerpc/watchpoint: Fix DAWR exception for CACHEOP)
  
 -	if (is_kernel_addr(regs->nip) && !(info->type & HW_BRK_TYPE_KERNEL))
 -		return false;
 -
 -	if (user_mode(regs) && !(info->type & HW_BRK_TYPE_USER))
 -		return false;
 +	ret = analyse_instr(&op, regs, instr);
 +	type = GETTYPE(op.type);
 +	size = GETSIZE(op.type);
  
 -	return true;
 -}
 -
 -/*
 - * Return true if the event is valid wrt dawr configuration,
 - * including extraneous exception. Otherwise return false.
 - */
 -static bool check_constraints(struct pt_regs *regs, struct ppc_inst instr,
 -			      unsigned long ea, int type, int size,
 -			      struct arch_hw_breakpoint *info)
 -{
 -	bool in_user_range = dar_in_user_range(regs->dar, info);
 -	bool dawrx_constraints;
 +	if (!ret && (type == LARX || type == STCX)) {
 +		printk_ratelimited("Breakpoint hit on instruction that can't be emulated."
 +				   " Breakpoint at 0x%lx will be disabled.\n", addr);
 +		goto disable;
 +	}
  
  	/*
 -	 * 8xx supports only one breakpoint and thus we can
 -	 * unconditionally return true.
 +	 * If it's extraneous event, we still need to emulate/single-
 +	 * step the instruction, but we don't generate an event.
  	 */
++<<<<<<< HEAD
 +	if (size && !dar_range_overlaps(regs->dar, size, info))
 +		info->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;
++=======
+ 	if (IS_ENABLED(CONFIG_PPC_8xx)) {
+ 		if (!in_user_range)
+ 			info->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;
+ 		return true;
+ 	}
+ 
+ 	if (unlikely(ppc_inst_equal(instr, ppc_inst(0)))) {
+ 		if (cpu_has_feature(CPU_FTR_ARCH_31) &&
+ 		    !dar_in_hw_range(regs->dar, info))
+ 			return false;
+ 
+ 		return true;
+ 	}
+ 
+ 	dawrx_constraints = check_dawrx_constraints(regs, type, info);
+ 
+ 	if (type == UNKNOWN) {
+ 		if (cpu_has_feature(CPU_FTR_ARCH_31) &&
+ 		    !dar_in_hw_range(regs->dar, info))
+ 			return false;
+ 
+ 		return dawrx_constraints;
+ 	}
+ 
+ 	if (ea_user_range_overlaps(ea, size, info))
+ 		return dawrx_constraints;
+ 
+ 	if (ea_hw_range_overlaps(ea, size, info)) {
+ 		if (dawrx_constraints) {
+ 			info->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;
+ 			return true;
+ 		}
+ 	}
+ 	return false;
+ }
+ 
+ static int cache_op_size(void)
+ {
+ #ifdef __powerpc64__
+ 	return ppc64_caches.l1d.block_size;
+ #else
+ 	return L1_CACHE_BYTES;
+ #endif
+ }
+ 
+ static void get_instr_detail(struct pt_regs *regs, struct ppc_inst *instr,
+ 			     int *type, int *size, unsigned long *ea)
+ {
+ 	struct instruction_op op;
+ 
+ 	if (__get_user_instr_inatomic(*instr, (void __user *)regs->nip))
+ 		return;
+ 
+ 	analyse_instr(&op, regs, *instr);
+ 	*type = GETTYPE(op.type);
+ 	*ea = op.ea;
+ #ifdef __powerpc64__
+ 	if (!(regs->msr & MSR_64BIT))
+ 		*ea &= 0xffffffffUL;
+ #endif
+ 
+ 	*size = GETSIZE(op.type);
+ 	if (*type == CACHEOP) {
+ 		*size = cache_op_size();
+ 		*ea &= ~(*size - 1);
+ 	}
+ }
+ 
+ static bool is_larx_stcx_instr(int type)
+ {
+ 	return type == LARX || type == STCX;
+ }
+ 
+ /*
+  * We've failed in reliably handling the hw-breakpoint. Unregister
+  * it and throw a warning message to let the user know about it.
+  */
+ static void handler_error(struct perf_event *bp, struct arch_hw_breakpoint *info)
+ {
+ 	WARN(1, "Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.",
+ 	     info->address);
+ 	perf_event_disable_inatomic(bp);
+ }
+ 
+ static void larx_stcx_err(struct perf_event *bp, struct arch_hw_breakpoint *info)
+ {
+ 	printk_ratelimited("Breakpoint hit on instruction that can't be emulated. Breakpoint at 0x%lx will be disabled.\n",
+ 			   info->address);
+ 	perf_event_disable_inatomic(bp);
+ }
+ 
+ static bool stepping_handler(struct pt_regs *regs, struct perf_event **bp,
+ 			     struct arch_hw_breakpoint **info, int *hit,
+ 			     struct ppc_inst instr)
+ {
+ 	int i;
+ 	int stepped;
++>>>>>>> f3c832f1350b (powerpc/watchpoint: Fix DAWR exception for CACHEOP)
  
  	/* Do not emulate user-space instructions, instead single-step them */
  	if (user_mode(regs)) {
* Unmerged path arch/powerpc/kernel/hw_breakpoint.c
