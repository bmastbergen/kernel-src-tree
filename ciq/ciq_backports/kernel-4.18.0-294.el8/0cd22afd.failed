mm/gup: fix a misnamed "write" argument, and a related bug

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author John Hubbard <jhubbard@nvidia.com>
commit 0cd22afdcea21fa16bb5b0d3e0508ca42072d0bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0cd22afd.failed

In several routines, the "flags" argument is incorrectly named "write".
Change it to "flags".

Also, in one place, the misnaming led to an actual bug:
"flags & FOLL_WRITE" is required, rather than just "flags".
(That problem was flagged by krobot, in v1 of this patch.)

Also, change the flags argument from int, to unsigned int.

You can see that this was a simple oversight, because the
calling code passes "flags" to the fifth argument:

gup_pgd_range():
    ...
    if (!gup_huge_pd(__hugepd(pgd_val(pgd)), addr,
		    PGDIR_SHIFT, next, flags, pages, nr))

...which, until this patch, the callees referred to as "write".

Also, change two lines to avoid checkpatch line length
complaints, and another line to fix another oversight
that checkpatch called out: missing "int" on pdshift.

Link: http://lkml.kernel.org/r/20191014184639.1512873-3-jhubbard@nvidia.com
Fixes: b798bec4741b ("mm/gup: change write parameter to flags in fast walk")
	Signed-off-by: John Hubbard <jhubbard@nvidia.com>
	Reported-by: kbuild test robot <lkp@intel.com>
	Suggested-by: Kirill A. Shutemov <kirill@shutemov.name>
	Suggested-by: Ira Weiny <ira.weiny@intel.com>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
	Cc: Keith Busch <keith.busch@intel.com>
	Cc: Shuah Khan <shuah@kernel.org>
	Cc: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0cd22afdcea21fa16bb5b0d3e0508ca42072d0bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/gup.c
diff --cc mm/gup.c
index 5fc3013a77c4,8f236a335ae9..000000000000
--- a/mm/gup.c
+++ b/mm/gup.c
@@@ -1916,8 -1964,94 +1916,97 @@@ static int __gup_device_huge_pud(pud_t 
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARCH_HAS_HUGEPD
+ static unsigned long hugepte_addr_end(unsigned long addr, unsigned long end,
+ 				      unsigned long sz)
+ {
+ 	unsigned long __boundary = (addr + sz) & ~(sz-1);
+ 	return (__boundary - 1 < end - 1) ? __boundary : end;
+ }
+ 
+ static int gup_hugepte(pte_t *ptep, unsigned long sz, unsigned long addr,
+ 		       unsigned long end, unsigned int flags,
+ 		       struct page **pages, int *nr)
+ {
+ 	unsigned long pte_end;
+ 	struct page *head, *page;
+ 	pte_t pte;
+ 	int refs;
+ 
+ 	pte_end = (addr + sz) & ~(sz-1);
+ 	if (pte_end < end)
+ 		end = pte_end;
+ 
+ 	pte = READ_ONCE(*ptep);
+ 
+ 	if (!pte_access_permitted(pte, flags & FOLL_WRITE))
+ 		return 0;
+ 
+ 	/* hugepages are never "special" */
+ 	VM_BUG_ON(!pfn_valid(pte_pfn(pte)));
+ 
+ 	refs = 0;
+ 	head = pte_page(pte);
+ 
+ 	page = head + ((addr & (sz-1)) >> PAGE_SHIFT);
+ 	do {
+ 		VM_BUG_ON(compound_head(page) != head);
+ 		pages[*nr] = page;
+ 		(*nr)++;
+ 		page++;
+ 		refs++;
+ 	} while (addr += PAGE_SIZE, addr != end);
+ 
+ 	head = try_get_compound_head(head, refs);
+ 	if (!head) {
+ 		*nr -= refs;
+ 		return 0;
+ 	}
+ 
+ 	if (unlikely(pte_val(pte) != pte_val(*ptep))) {
+ 		/* Could be optimized better */
+ 		*nr -= refs;
+ 		while (refs--)
+ 			put_page(head);
+ 		return 0;
+ 	}
+ 
+ 	SetPageReferenced(head);
+ 	return 1;
+ }
+ 
+ static int gup_huge_pd(hugepd_t hugepd, unsigned long addr,
+ 		unsigned int pdshift, unsigned long end, unsigned int flags,
+ 		struct page **pages, int *nr)
+ {
+ 	pte_t *ptep;
+ 	unsigned long sz = 1UL << hugepd_shift(hugepd);
+ 	unsigned long next;
+ 
+ 	ptep = hugepte_offset(hugepd, addr, pdshift);
+ 	do {
+ 		next = hugepte_addr_end(addr, end, sz);
+ 		if (!gup_hugepte(ptep, sz, addr, end, flags, pages, nr))
+ 			return 0;
+ 	} while (ptep++, addr = next, addr != end);
+ 
+ 	return 1;
+ }
+ #else
+ static inline int gup_huge_pd(hugepd_t hugepd, unsigned long addr,
+ 		unsigned int pdshift, unsigned long end, unsigned int flags,
+ 		struct page **pages, int *nr)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_ARCH_HAS_HUGEPD */
+ 
++>>>>>>> 0cd22afdcea2 (mm/gup: fix a misnamed "write" argument, and a related bug)
  static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,
- 		unsigned long end, unsigned int flags, struct page **pages, int *nr)
+ 			unsigned long end, unsigned int flags,
+ 			struct page **pages, int *nr)
  {
  	struct page *head, *page;
  	int refs;
* Unmerged path mm/gup.c
