procfs: Move proc_fill_super() to fs/proc/root.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 60a3c3a58e2e01e19ed2b68b415adb12118ac349
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/60a3c3a5.failed

Move proc_fill_super() to fs/proc/root.c as that's where the other
superblock stuff is.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Reviewed-by: Alexey Dobriyan <adobriyan@gmail.com>
cc: Alexey Dobriyan <adobriyan@gmail.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 60a3c3a58e2e01e19ed2b68b415adb12118ac349)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/inode.c
diff --cc fs/proc/inode.c
index 85ffbd27f288,17b5261206dd..000000000000
--- a/fs/proc/inode.c
+++ b/fs/proc/inode.c
@@@ -488,48 -487,3 +487,51 @@@ struct inode *proc_get_inode(struct sup
  	       pde_put(de);
  	return inode;
  }
++<<<<<<< HEAD
 +
 +int proc_fill_super(struct super_block *s, void *data, int silent)
 +{
 +	struct pid_namespace *ns = get_pid_ns(s->s_fs_info);
 +	struct inode *root_inode;
 +	int ret;
 +
 +	if (!proc_parse_options(data, ns))
 +		return -EINVAL;
 +
 +	/* User space would break if executables or devices appear on proc */
 +	s->s_iflags |= SB_I_USERNS_VISIBLE | SB_I_NOEXEC | SB_I_NODEV;
 +	s->s_flags |= SB_NODIRATIME | SB_NOSUID | SB_NOEXEC;
 +	s->s_blocksize = 1024;
 +	s->s_blocksize_bits = 10;
 +	s->s_magic = PROC_SUPER_MAGIC;
 +	s->s_op = &proc_sops;
 +	s->s_time_gran = 1;
 +
 +	/*
 +	 * procfs isn't actually a stacking filesystem; however, there is
 +	 * too much magic going on inside it to permit stacking things on
 +	 * top of it
 +	 */
 +	s->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;
 +	
 +	pde_get(&proc_root);
 +	root_inode = proc_get_inode(s, &proc_root);
 +	if (!root_inode) {
 +		pr_err("proc_fill_super: get root inode failed\n");
 +		return -ENOMEM;
 +	}
 +
 +	s->s_root = d_make_root(root_inode);
 +	if (!s->s_root) {
 +		pr_err("proc_fill_super: allocate dentry failed\n");
 +		return -ENOMEM;
 +	}
 +
 +	ret = proc_setup_self(s);
 +	if (ret) {
 +		return ret;
 +	}
 +	return proc_setup_thread_self(s);
 +}
++=======
++>>>>>>> 60a3c3a58e2e (procfs: Move proc_fill_super() to fs/proc/root.c)
* Unmerged path fs/proc/inode.c
diff --git a/fs/proc/internal.h b/fs/proc/internal.h
index 67f8409bc1c0..1d4e53fe1a63 100644
--- a/fs/proc/internal.h
+++ b/fs/proc/internal.h
@@ -209,13 +209,12 @@ struct pde_opener {
 	struct completion *c;
 } __randomize_layout;
 extern const struct inode_operations proc_link_inode_operations;
-
 extern const struct inode_operations proc_pid_link_inode_operations;
+extern const struct super_operations proc_sops;
 
 void proc_init_kmemcache(void);
 void set_proc_pid_nlink(void);
 extern struct inode *proc_get_inode(struct super_block *, struct proc_dir_entry *);
-extern int proc_fill_super(struct super_block *, void *data, int flags);
 extern void proc_entry_rundown(struct proc_dir_entry *);
 
 /*
@@ -273,7 +272,6 @@ static inline void proc_tty_init(void) {}
  * root.c
  */
 extern struct proc_dir_entry proc_root;
-extern int proc_parse_options(char *options, struct pid_namespace *pid);
 
 extern void proc_self_init(void);
 extern int proc_remount(struct super_block *, int *, char *);
diff --git a/fs/proc/root.c b/fs/proc/root.c
index f4b1a9d2eca6..fe4f64b3250b 100644
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@ -23,6 +23,7 @@
 #include <linux/pid_namespace.h>
 #include <linux/parser.h>
 #include <linux/cred.h>
+#include <linux/magic.h>
 
 #include "internal.h"
 
@@ -36,7 +37,7 @@ static const match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-int proc_parse_options(char *options, struct pid_namespace *pid)
+static int proc_parse_options(char *options, struct pid_namespace *pid)
 {
 	char *p;
 	substring_t args[MAX_OPT_ARGS];
@@ -78,6 +79,54 @@ int proc_parse_options(char *options, struct pid_namespace *pid)
 	return 1;
 }
 
+static int proc_fill_super(struct super_block *s, void *data, int silent)
+{
+	struct pid_namespace *ns = get_pid_ns(s->s_fs_info);
+	struct inode *root_inode;
+	int ret;
+
+	if (!proc_parse_options(data, ns))
+		return -EINVAL;
+
+	/* User space would break if executables or devices appear on proc */
+	s->s_iflags |= SB_I_USERNS_VISIBLE | SB_I_NOEXEC | SB_I_NODEV;
+	s->s_flags |= SB_NODIRATIME | SB_NOSUID | SB_NOEXEC;
+	s->s_blocksize = 1024;
+	s->s_blocksize_bits = 10;
+	s->s_magic = PROC_SUPER_MAGIC;
+	s->s_op = &proc_sops;
+	s->s_time_gran = 1;
+
+	/*
+	 * procfs isn't actually a stacking filesystem; however, there is
+	 * too much magic going on inside it to permit stacking things on
+	 * top of it
+	 */
+	s->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;
+	
+	/* procfs dentries and inodes don't require IO to create */
+	s->s_shrink.seeks = 0;
+
+	pde_get(&proc_root);
+	root_inode = proc_get_inode(s, &proc_root);
+	if (!root_inode) {
+		pr_err("proc_fill_super: get root inode failed\n");
+		return -ENOMEM;
+	}
+
+	s->s_root = d_make_root(root_inode);
+	if (!s->s_root) {
+		pr_err("proc_fill_super: allocate dentry failed\n");
+		return -ENOMEM;
+	}
+
+	ret = proc_setup_self(s);
+	if (ret) {
+		return ret;
+	}
+	return proc_setup_thread_self(s);
+}
+
 int proc_remount(struct super_block *sb, int *flags, char *data)
 {
 	struct pid_namespace *pid = sb->s_fs_info;
