net: atlantic: add fw configuration memory area

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Nikita Danilov <ndanilov@marvell.com>
commit dc12f75afcc677f225e5465b0654c54a14945168
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/dc12f75a.failed

Device FW has a separate memory area where various
config fields are stored and could be used by the
driver.

Here we modify download/upload infrastructure to
allow accessing this area.

Lateron this will be used to configure various behaviours

	Signed-off-by: Nikita Danilov <ndanilov@marvell.com>
	Signed-off-by: Igor Russkikh <irusskikh@marvell.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dc12f75afcc677f225e5465b0654c54a14945168)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 3fc41da39a0a,db8c09c5a768..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@@ -330,11 -332,75 +335,80 @@@ err_exit
  	return err;
  }
  
++<<<<<<< HEAD
 +static int hw_atl_utils_fw_upload_dwords(struct aq_hw_s *self, u32 a, u32 *p,
 +					 u32 cnt)
++=======
+ static int hw_atl_utils_write_b1_mbox(struct aq_hw_s *self, u32 addr,
+ 				      u32 *p, u32 cnt, enum mcp_area area)
++>>>>>>> dc12f75afcc6 (net: atlantic: add fw configuration memory area)
+ {
+ 	u32 data_offset = 0;
+ 	u32 offset = addr;
+ 	int err = 0;
+ 	u32 val;
+ 
+ 	switch (area) {
+ 	case MCP_AREA_CONFIG:
+ 		offset -= self->rpc_addr;
+ 		break;
+ 
+ 	case MCP_AREA_SETTINGS:
+ 		offset -= self->settings_addr;
+ 		break;
+ 	}
+ 
+ 	offset = offset / sizeof(u32);
+ 
+ 	for (; data_offset < cnt; ++data_offset, ++offset) {
+ 		aq_hw_write_reg(self, 0x328, p[data_offset]);
+ 		aq_hw_write_reg(self, 0x32C,
+ 				(area | (0xFFFF & (offset * 4))));
+ 		hw_atl_mcp_up_force_intr_set(self, 1);
+ 		/* 1000 times by 10us = 10ms */
+ 		err = readx_poll_timeout_atomic(hw_atl_scrpad12_get,
+ 						self, val,
+ 						(val & 0xF0000000) !=
+ 						area,
+ 						10U, 10000U);
+ 
+ 		if (err < 0)
+ 			break;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int hw_atl_utils_write_b0_mbox(struct aq_hw_s *self, u32 addr,
+ 				      u32 *p, u32 cnt)
  {
+ 	u32 offset = 0;
+ 	int err = 0;
  	u32 val;
+ 
+ 	aq_hw_write_reg(self, 0x208, addr);
+ 
+ 	for (; offset < cnt; ++offset) {
+ 		aq_hw_write_reg(self, 0x20C, p[offset]);
+ 		aq_hw_write_reg(self, 0x200, 0xC000);
+ 
+ 		err = readx_poll_timeout_atomic(hw_atl_utils_mif_cmd_get,
+ 						self, val,
+ 						(val & 0x100) == 0U,
+ 						10U, 10000U);
+ 
+ 		if (err < 0)
+ 			break;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int hw_atl_utils_fw_upload_dwords(struct aq_hw_s *self, u32 addr, u32 *p,
+ 					 u32 cnt, enum mcp_area area)
+ {
  	int err = 0;
+ 	u32 val;
  
  	err = readx_poll_timeout_atomic(hw_atl_sem_ram_get, self,
  					val, val == 1U,
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
index 48278e333462,68fe17ec171d..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
@@@ -240,6 -228,97 +240,100 @@@ struct __packed offload_info 
  	u8 buf[0];
  };
  
++<<<<<<< HEAD
++=======
+ struct __packed hw_atl_utils_fw_rpc {
+ 	u32 msg_id;
+ 
+ 	union {
+ 		/* fw1x structures */
+ 		struct drv_msg_wol_add msg_wol_add;
+ 		struct drv_msg_wol_remove msg_wol_remove;
+ 		struct drv_msg_enable_wakeup msg_enable_wakeup;
+ 		/* fw2x structures */
+ 		struct offload_info fw2x_offloads;
+ 	};
+ };
+ 
+ /* Mailbox FW Request interface */
+ struct __packed hw_fw_request_ptp_gpio_ctrl {
+ 	u32 index;
+ 	u32 period;
+ 	u64 start;
+ };
+ 
+ struct __packed hw_fw_request_ptp_adj_freq {
+ 	u32 ns_mac;
+ 	u32 fns_mac;
+ 	u32 ns_phy;
+ 	u32 fns_phy;
+ 	u32 mac_ns_adj;
+ 	u32 mac_fns_adj;
+ };
+ 
+ struct __packed hw_fw_request_ptp_adj_clock {
+ 	u32 ns;
+ 	u32 sec;
+ 	int sign;
+ };
+ 
+ #define HW_AQ_FW_REQUEST_PTP_GPIO_CTRL	         0x11
+ #define HW_AQ_FW_REQUEST_PTP_ADJ_FREQ	         0x12
+ #define HW_AQ_FW_REQUEST_PTP_ADJ_CLOCK	         0x13
+ 
+ struct __packed hw_fw_request_iface {
+ 	u32 msg_id;
+ 	union {
+ 		/* PTP FW Request */
+ 		struct hw_fw_request_ptp_gpio_ctrl ptp_gpio_ctrl;
+ 		struct hw_fw_request_ptp_adj_freq ptp_adj_freq;
+ 		struct hw_fw_request_ptp_adj_clock ptp_adj_clock;
+ 	};
+ };
+ 
+ struct __packed hw_atl_utils_settings {
+ 	u32 mtu;
+ 	u32 downshift_retry_count;
+ 	u32 link_pause_frame_quanta_100m;
+ 	u32 link_pause_frame_threshold_100m;
+ 	u32 link_pause_frame_quanta_1g;
+ 	u32 link_pause_frame_threshold_1g;
+ 	u32 link_pause_frame_quanta_2p5g;
+ 	u32 link_pause_frame_threshold_2p5g;
+ 	u32 link_pause_frame_quanta_5g;
+ 	u32 link_pause_frame_threshold_5g;
+ 	u32 link_pause_frame_quanta_10g;
+ 	u32 link_pause_frame_threshold_10g;
+ 	u32 pfc_quanta_class_0;
+ 	u32 pfc_threshold_class_0;
+ 	u32 pfc_quanta_class_1;
+ 	u32 pfc_threshold_class_1;
+ 	u32 pfc_quanta_class_2;
+ 	u32 pfc_threshold_class_2;
+ 	u32 pfc_quanta_class_3;
+ 	u32 pfc_threshold_class_3;
+ 	u32 pfc_quanta_class_4;
+ 	u32 pfc_threshold_class_4;
+ 	u32 pfc_quanta_class_5;
+ 	u32 pfc_threshold_class_5;
+ 	u32 pfc_quanta_class_6;
+ 	u32 pfc_threshold_class_6;
+ 	u32 pfc_quanta_class_7;
+ 	u32 pfc_threshold_class_7;
+ 	u32 eee_link_down_timeout;
+ 	u32 eee_link_up_timeout;
+ 	u32 eee_max_link_drops;
+ 	u32 eee_rates_mask;
+ 	u32 wake_timer;
+ 	u32 thermal_shutdown_off_temp;
+ 	u32 thermal_shutdown_warning_temp;
+ 	u32 thermal_shutdown_cold_temp;
+ 	u32 msm_options;
+ 	u32 dac_cable_serdes_modes;
+ 	u32 media_detect;
+ };
+ 
++>>>>>>> dc12f75afcc6 (net: atlantic: add fw configuration memory area)
  enum hw_atl_rx_action_with_traffic {
  	HW_ATL_RX_DISCARD,
  	HW_ATL_RX_HOST,
@@@ -478,6 -596,11 +572,14 @@@ struct aq_stats_s *hw_atl_utils_get_hw_
  int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,
  				  u32 *p, u32 cnt);
  
++<<<<<<< HEAD
++=======
+ int hw_atl_write_fwcfg_dwords(struct aq_hw_s *self, u32 *p, u32 cnt);
+ 
+ int hw_atl_write_fwsettings_dwords(struct aq_hw_s *self, u32 offset, u32 *p,
+ 				   u32 cnt);
+ 
++>>>>>>> dc12f75afcc6 (net: atlantic: add fw configuration memory area)
  int hw_atl_utils_fw_set_wol(struct aq_hw_s *self, bool wol_enabled, u8 *mac);
  
  int hw_atl_utils_fw_rpc_call(struct aq_hw_s *self, unsigned int rpc_size);
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
index 103608a7664f,3dbce03c5a94..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
@@@ -436,12 -402,40 +439,49 @@@ static int aq_fw2x_set_power(struct aq_
  {
  	int err = 0;
  
++<<<<<<< HEAD
 +	if (self->aq_nic_cfg->wol & AQ_NIC_WOL_ENABLED) {
 +		err = aq_fw2x_set_sleep_proxy(self, mac);
 +		if (err < 0)
 +			goto err_exit;
 +		err = aq_fw2x_set_wol_params(self, mac);
 +	}
++=======
+ 	if (self->aq_nic_cfg->wol)
+ 		err = aq_fw2x_set_wol(self, mac);
+ 
+ 	return err;
+ }
+ 
+ static int aq_fw2x_send_fw_request(struct aq_hw_s *self,
+ 				   const struct hw_fw_request_iface *fw_req,
+ 				   size_t size)
+ {
+ 	u32 ctrl2, orig_ctrl2;
+ 	u32 dword_cnt;
+ 	int err = 0;
+ 	u32 val;
+ 
+ 	/* Write data to drvIface Mailbox */
+ 	dword_cnt = size / sizeof(u32);
+ 	if (size % sizeof(u32))
+ 		dword_cnt++;
+ 	err = hw_atl_write_fwcfg_dwords(self, (void *)fw_req, dword_cnt);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	/* Toggle statistics bit for FW to update */
+ 	ctrl2 = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 	orig_ctrl2 = ctrl2 & BIT(CAPS_HI_FW_REQUEST);
+ 	ctrl2 = ctrl2 ^ BIT(CAPS_HI_FW_REQUEST);
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, ctrl2);
+ 
+ 	/* Wait FW to report back */
+ 	err = readx_poll_timeout_atomic(aq_fw2x_state2_get, self, val,
+ 					orig_ctrl2 != (val &
+ 						       BIT(CAPS_HI_FW_REQUEST)),
+ 					1U, 10000U);
++>>>>>>> dc12f75afcc6 (net: atlantic: add fw configuration memory area)
  
  err_exit:
  	return err;
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 5c8995ae94b5..35b42512c4a3 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@ -136,6 +136,7 @@ struct aq_hw_s {
 	atomic_t dpc;
 	u32 mbox_addr;
 	u32 rpc_addr;
+	u32 settings_addr;
 	u32 rpc_tid;
 	struct hw_atl_utils_fw_rpc rpc;
 };
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
