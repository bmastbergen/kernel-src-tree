x86/entry/64: Simplify idtentry a little

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 2fd37912cfb019228bf246215938e6f7619516a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/2fd37912.failed

There's a bunch of duplication in idtentry, namely the
.Lfrom_usermode_switch_stack is a paranoid=0 copy of the normal flow.

Make this explicit by creating a idtentry_part helper macro.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Acked-by: Andy Lutomirski <luto@kernel.org>
	Cc: bp@alien8.de
	Cc: torvalds@linux-foundation.org
	Cc: hpa@zytor.com
	Cc: dave.hansen@linux.intel.com
	Cc: jgross@suse.com
	Cc: zhe.he@windriver.com
	Cc: joel@joelfernandes.org
	Cc: devel@etsukata.com
Link: https://lkml.kernel.org/r/20190711114336.002429503@infradead.org

(cherry picked from commit 2fd37912cfb019228bf246215938e6f7619516a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/entry_64.S
diff --cc arch/x86/entry/entry_64.S
index 55533b42ad44,3db5fede743b..000000000000
--- a/arch/x86/entry/entry_64.S
+++ b/arch/x86/entry/entry_64.S
@@@ -868,8 -862,54 +868,54 @@@ apicinterrupt IRQ_WORK_VECTOR			irq_wor
  /*
   * Exception entry points.
   */
 -#define CPU_TSS_IST(x) PER_CPU_VAR(cpu_tss_rw) + (TSS_ist + (x) * 8)
 +#define CPU_TSS_IST(x) PER_CPU_VAR(cpu_tss_rw) + (TSS_ist + ((x) - 1) * 8)
  
+ .macro idtentry_part do_sym, has_error_code:req, paranoid:req, shift_ist=-1, ist_offset=0
+ 
+ 	.if \paranoid
+ 	call	paranoid_entry
+ 	/* returned flag: ebx=0: need swapgs on exit, ebx=1: don't need it */
+ 	.else
+ 	call	error_entry
+ 	.endif
+ 	UNWIND_HINT_REGS
+ 
+ 	.if \paranoid
+ 	.if \shift_ist != -1
+ 	TRACE_IRQS_OFF_DEBUG			/* reload IDT in case of recursion */
+ 	.else
+ 	TRACE_IRQS_OFF
+ 	.endif
+ 	.endif
+ 
+ 	movq	%rsp, %rdi			/* pt_regs pointer */
+ 
+ 	.if \has_error_code
+ 	movq	ORIG_RAX(%rsp), %rsi		/* get error code */
+ 	movq	$-1, ORIG_RAX(%rsp)		/* no syscall to restart */
+ 	.else
+ 	xorl	%esi, %esi			/* no error code */
+ 	.endif
+ 
+ 	.if \shift_ist != -1
+ 	subq	$\ist_offset, CPU_TSS_IST(\shift_ist)
+ 	.endif
+ 
+ 	call	\do_sym
+ 
+ 	.if \shift_ist != -1
+ 	addq	$\ist_offset, CPU_TSS_IST(\shift_ist)
+ 	.endif
+ 
+ 	.if \paranoid
+ 	/* this procedure expect "no swapgs" flag in ebx */
+ 	jmp	paranoid_exit
+ 	.else
+ 	jmp	error_exit
+ 	.endif
+ 
+ .endm
+ 
  /**
   * idtentry - Generate an IDT entry stub
   * @sym:		Name of the generated entry point
@@@ -945,47 -980,7 +991,51 @@@ ENTRY(\sym
  .Lfrom_usermode_no_gap_\@:
  	.endif
  
++<<<<<<< HEAD
 +	.if \paranoid
 +	call	paranoid_entry
 +	.else
 +	call	error_entry
 +	.endif
 +	UNWIND_HINT_REGS
 +	/* returned flag: ebx=0: need swapgs on exit, ebx=1: don't need it */
 +
 +	.if \paranoid
 +	.if \shift_ist != -1
 +	TRACE_IRQS_OFF_DEBUG			/* reload IDT in case of recursion */
 +	.else
 +	TRACE_IRQS_OFF
 +	.endif
 +	.endif
 +
 +	movq	%rsp, %rdi			/* pt_regs pointer */
 +
 +	.if \has_error_code
 +	movq	ORIG_RAX(%rsp), %rsi		/* get error code */
 +	movq	$-1, ORIG_RAX(%rsp)		/* no syscall to restart */
 +	.else
 +	xorl	%esi, %esi			/* no error code */
 +	.endif
 +
 +	.if \shift_ist != -1
 +	subq	$EXCEPTION_STKSZ, CPU_TSS_IST(\shift_ist)
 +	.endif
 +
 +	call	\do_sym
 +
 +	.if \shift_ist != -1
 +	addq	$EXCEPTION_STKSZ, CPU_TSS_IST(\shift_ist)
 +	.endif
 +
 +	/* these procedures expect "no swapgs" flag in ebx */
 +	.if \paranoid
 +	jmp	paranoid_exit
 +	.else
 +	jmp	error_exit
 +	.endif
++=======
+ 	idtentry_part \do_sym, \has_error_code, \paranoid, \shift_ist, \ist_offset
++>>>>>>> 2fd37912cfb0 (x86/entry/64: Simplify idtentry a little)
  
  	.if \paranoid == 1
  	/*
* Unmerged path arch/x86/entry/entry_64.S
