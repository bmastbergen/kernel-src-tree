cgroup: stash cgroup_root reference into cgroup_fs_context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit cf6299b1d00555cd10dc30d95b300d7084128a2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/cf6299b1.failed

Note that this reference is *NOT* contributing to refcount of
cgroup_root in question and is valid only until cgroup_do_mount()
returns.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit cf6299b1d00555cd10dc30d95b300d7084128a2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cgroup/cgroup-internal.h
#	kernel/cgroup/cgroup-v1.c
#	kernel/cgroup/cgroup.c
diff --cc kernel/cgroup/cgroup-internal.h
index ce1c1553c696,3c1613a7648c..000000000000
--- a/kernel/cgroup/cgroup-internal.h
+++ b/kernel/cgroup/cgroup-internal.h
@@@ -40,6 -38,27 +40,30 @@@ extern void __init enable_debug_cgroup(
  	} while (0)
  
  /*
++<<<<<<< HEAD
++=======
+  * The cgroup filesystem superblock creation/mount context.
+  */
+ struct cgroup_fs_context {
+ 	struct cgroup_root	*root;
+ 	unsigned int	flags;			/* CGRP_ROOT_* flags */
+ 
+ 	/* cgroup1 bits */
+ 	bool		cpuset_clone_children;
+ 	bool		none;			/* User explicitly requested empty subsystem */
+ 	bool		all_ss;			/* Seen 'all' option */
+ 	u16		subsys_mask;		/* Selected subsystems */
+ 	char		*name;			/* Hierarchy name */
+ 	char		*release_agent;		/* Path for release notifications */
+ };
+ 
+ static inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)
+ {
+ 	return fc->fs_private;
+ }
+ 
+ /*
++>>>>>>> cf6299b1d005 (cgroup: stash cgroup_root reference into cgroup_fs_context)
   * A cgroup can be associated with multiple css_sets as different tasks may
   * belong to different cgroups on different hierarchies.  In the other
   * direction, a css_set is naturally associated with multiple cgroups.
@@@ -200,7 -209,7 +224,11 @@@ int cgroup_path_ns_locked(struct cgrou
  			  struct cgroup_namespace *ns);
  
  void cgroup_free_root(struct cgroup_root *root);
++<<<<<<< HEAD
 +void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts);
++=======
+ void init_cgroup_root(struct cgroup_fs_context *ctx);
++>>>>>>> cf6299b1d005 (cgroup: stash cgroup_root reference into cgroup_fs_context)
  int cgroup_setup_root(struct cgroup_root *root, u16 ss_mask);
  int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask);
  struct dentry *cgroup_do_mount(struct file_system_type *fs_type, int flags,
diff --cc kernel/cgroup/cgroup-v1.c
index dd94e2a4c22e,45a198c63d6e..000000000000
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@@ -1146,9 -1205,10 +1146,10 @@@ struct dentry *cgroup1_mount(struct fil
  			goto out_unlock;
  		}
  
 -		if (root->flags ^ ctx->flags)
 +		if (root->flags ^ opts.flags)
  			pr_warn("new mount options do not match the existing superblock, will be ignored\n");
  
+ 		ctx->root = root;
  		ret = 0;
  		goto out_unlock;
  	}
@@@ -1175,9 -1235,10 +1176,14 @@@
  		goto out_unlock;
  	}
  
++<<<<<<< HEAD
 +	init_cgroup_root(root, &opts);
++=======
+ 	ctx->root = root;
+ 	init_cgroup_root(ctx);
++>>>>>>> cf6299b1d005 (cgroup: stash cgroup_root reference into cgroup_fs_context)
  
 -	ret = cgroup_setup_root(root, ctx->subsys_mask);
 +	ret = cgroup_setup_root(root, opts.subsys_mask);
  	if (ret)
  		cgroup_free_root(root);
  
diff --cc kernel/cgroup/cgroup.c
index 9e08519ae6db,57f43f63363a..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -1891,8 -1915,9 +1891,13 @@@ static void init_cgroup_housekeeping(st
  	INIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);
  }
  
++<<<<<<< HEAD
 +void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts)
++=======
+ void init_cgroup_root(struct cgroup_fs_context *ctx)
++>>>>>>> cf6299b1d005 (cgroup: stash cgroup_root reference into cgroup_fs_context)
  {
+ 	struct cgroup_root *root = ctx->root;
  	struct cgroup *cgrp = &root->cgrp;
  
  	INIT_LIST_HEAD(&root->root_list);
@@@ -2050,45 -2075,80 +2055,51 @@@ struct dentry *cgroup_do_mount(struct f
  	return dentry;
  }
  
 -/*
 - * Destroy a cgroup filesystem context.
 - */
 -static void cgroup_fs_context_free(struct fs_context *fc)
 -{
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 -
 -	kfree(ctx->name);
 -	kfree(ctx->release_agent);
 -	kfree(ctx);
 -}
 -
 -static int cgroup_get_tree(struct fs_context *fc)
 +static struct dentry *cgroup_mount(struct file_system_type *fs_type,
 +			 int flags, const char *unused_dev_name,
 +			 void *data)
  {
  	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 -	struct dentry *root;
 +	struct dentry *dentry;
 +	int ret;
 +
 +	get_cgroup_ns(ns);
  
  	/* Check if the caller has permission to mount. */
 -	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
 -		return -EPERM;
 +	if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN)) {
 +		put_cgroup_ns(ns);
 +		return ERR_PTR(-EPERM);
 +	}
  
++<<<<<<< HEAD
 +	if (fs_type == &cgroup2_fs_type) {
 +		unsigned int root_flags;
++=======
+ 	cgrp_dfl_visible = true;
+ 	cgroup_get_live(&cgrp_dfl_root.cgrp);
+ 	ctx->root = &cgrp_dfl_root;
++>>>>>>> cf6299b1d005 (cgroup: stash cgroup_root reference into cgroup_fs_context)
  
 -	root = cgroup_do_mount(&cgroup2_fs_type, fc->sb_flags, &cgrp_dfl_root,
 -					 CGROUP2_SUPER_MAGIC, ns);
 -	if (IS_ERR(root))
 -		return PTR_ERR(root);
 -
 -	apply_cgroup_root_flags(ctx->flags);
 -	fc->root = root;
 -	return 0;
 -}
 -
 -static const struct fs_context_operations cgroup_fs_context_ops = {
 -	.free		= cgroup_fs_context_free,
 -	.parse_param	= cgroup2_parse_param,
 -	.get_tree	= cgroup_get_tree,
 -	.reconfigure	= cgroup_reconfigure,
 -};
 -
 -static const struct fs_context_operations cgroup1_fs_context_ops = {
 -	.free		= cgroup_fs_context_free,
 -	.parse_param	= cgroup1_parse_param,
 -	.get_tree	= cgroup1_get_tree,
 -	.reconfigure	= cgroup1_reconfigure,
 -};
 -
 -/*
 - * Initialise the cgroup filesystem creation/reconfiguration context.
 - */
 -static int cgroup_init_fs_context(struct fs_context *fc)
 -{
 -	struct cgroup_fs_context *ctx;
 +		ret = parse_cgroup_root_flags(data, &root_flags);
 +		if (ret) {
 +			put_cgroup_ns(ns);
 +			return ERR_PTR(ret);
 +		}
  
 -	ctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);
 -	if (!ctx)
 -		return -ENOMEM;
 +		cgrp_dfl_visible = true;
 +		cgroup_get_live(&cgrp_dfl_root.cgrp);
  
 -	/*
 -	 * The first time anyone tries to mount a cgroup, enable the list
 -	 * linking each css_set to its tasks and fix up all existing tasks.
 -	 */
 -	if (!use_task_css_set_links)
 -		cgroup_enable_task_cg_lists();
 +		dentry = cgroup_do_mount(&cgroup2_fs_type, flags, &cgrp_dfl_root,
 +					 CGROUP2_SUPER_MAGIC, ns);
 +		if (!IS_ERR(dentry))
 +			apply_cgroup_root_flags(root_flags);
 +	} else {
 +		dentry = cgroup1_mount(&cgroup_fs_type, flags, data,
 +				       CGROUP_SUPER_MAGIC, ns);
 +	}
  
 -	fc->fs_private = ctx;
 -	if (fc->fs_type == &cgroup2_fs_type)
 -		fc->ops = &cgroup_fs_context_ops;
 -	else
 -		fc->ops = &cgroup1_fs_context_ops;
 -	return 0;
 +	put_cgroup_ns(ns);
 +	return dentry;
  }
  
  static void cgroup_kill_sb(struct super_block *sb)
@@@ -5541,7 -5376,8 +5552,12 @@@ int __init cgroup_init_early(void
  	struct cgroup_subsys *ss;
  	int i;
  
++<<<<<<< HEAD
 +	init_cgroup_root(&cgrp_dfl_root, &opts);
++=======
+ 	ctx.root = &cgrp_dfl_root;
+ 	init_cgroup_root(&ctx);
++>>>>>>> cf6299b1d005 (cgroup: stash cgroup_root reference into cgroup_fs_context)
  	cgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;
  
  	RCU_INIT_POINTER(init_task.cgroups, &init_css_set);
* Unmerged path kernel/cgroup/cgroup-internal.h
* Unmerged path kernel/cgroup/cgroup-v1.c
* Unmerged path kernel/cgroup/cgroup.c
