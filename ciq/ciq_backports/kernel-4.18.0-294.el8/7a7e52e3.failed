mptcp: add RM_ADDR related mibs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 7a7e52e38a40f4f6ce8f06da601556a7669cf999
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7a7e52e3.failed

This patch added two new mibs for RM_ADDR, named MPTCP_MIB_RMADDR and
MPTCP_MIB_RMSUBFLOW, when the RM_ADDR suboption is received, increase
the first mib counter, when the local subflow is removed, increase the
second mib counter.

	Suggested-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Suggested-by: Paolo Abeni <pabeni@redhat.com>
	Suggested-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Acked-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7a7e52e38a40f4f6ce8f06da601556a7669cf999)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/mib.c
#	net/mptcp/mib.h
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/mib.c
index 526ebb63e722,84d119436b22..000000000000
--- a/net/mptcp/mib.c
+++ b/net/mptcp/mib.c
@@@ -22,6 -22,15 +22,18 @@@ static const struct snmp_mib mptcp_snmp
  	SNMP_MIB_ITEM("MPJoinAckHMacFailure", MPTCP_MIB_JOINACKMAC),
  	SNMP_MIB_ITEM("DSSNotMatching", MPTCP_MIB_DSSNOMATCH),
  	SNMP_MIB_ITEM("InfiniteMapRx", MPTCP_MIB_INFINITEMAPRX),
++<<<<<<< HEAD
++=======
+ 	SNMP_MIB_ITEM("OFOQueueTail", MPTCP_MIB_OFOQUEUETAIL),
+ 	SNMP_MIB_ITEM("OFOQueue", MPTCP_MIB_OFOQUEUE),
+ 	SNMP_MIB_ITEM("OFOMerge", MPTCP_MIB_OFOMERGE),
+ 	SNMP_MIB_ITEM("NoDSSInWindow", MPTCP_MIB_NODSSWINDOW),
+ 	SNMP_MIB_ITEM("DuplicateData", MPTCP_MIB_DUPDATA),
+ 	SNMP_MIB_ITEM("AddAddr", MPTCP_MIB_ADDADDR),
+ 	SNMP_MIB_ITEM("EchoAdd", MPTCP_MIB_ECHOADD),
+ 	SNMP_MIB_ITEM("RmAddr", MPTCP_MIB_RMADDR),
+ 	SNMP_MIB_ITEM("RmSubflow", MPTCP_MIB_RMSUBFLOW),
++>>>>>>> 7a7e52e38a40 (mptcp: add RM_ADDR related mibs)
  	SNMP_MIB_SENTINEL
  };
  
diff --cc net/mptcp/mib.h
index 5579e7107989,47bcecce1106..000000000000
--- a/net/mptcp/mib.h
+++ b/net/mptcp/mib.h
@@@ -15,6 -15,15 +15,18 @@@ enum linux_mptcp_mib_field 
  	MPTCP_MIB_JOINACKMAC,		/* HMAC was wrong on ACK + MP_JOIN */
  	MPTCP_MIB_DSSNOMATCH,		/* Received a new mapping that did not match the previous one */
  	MPTCP_MIB_INFINITEMAPRX,	/* Received an infinite mapping */
++<<<<<<< HEAD
++=======
+ 	MPTCP_MIB_OFOQUEUETAIL,	/* Segments inserted into OoO queue tail */
+ 	MPTCP_MIB_OFOQUEUE,		/* Segments inserted into OoO queue */
+ 	MPTCP_MIB_OFOMERGE,		/* Segments merged in OoO queue */
+ 	MPTCP_MIB_NODSSWINDOW,		/* Segments not in MPTCP windows */
+ 	MPTCP_MIB_DUPDATA,		/* Segments discarded due to duplicate DSS */
+ 	MPTCP_MIB_ADDADDR,		/* Received ADD_ADDR with echo-flag=0 */
+ 	MPTCP_MIB_ECHOADD,		/* Received ADD_ADDR with echo-flag=1 */
+ 	MPTCP_MIB_RMADDR,		/* Received RM_ADDR */
+ 	MPTCP_MIB_RMSUBFLOW,		/* Remove a subflow */
++>>>>>>> 7a7e52e38a40 (mptcp: add RM_ADDR related mibs)
  	__MPTCP_MIB_MAX
  };
  
diff --cc net/mptcp/pm_netlink.c
index 6f3bf9fdbbbc,b33aebd85bd5..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -267,8 -311,81 +268,84 @@@ void mptcp_pm_nl_add_addr_received(stru
  	local.family = remote.family;
  
  	spin_unlock_bh(&msk->pm.lock);
 -	__mptcp_subflow_connect((struct sock *)msk, &local, &remote);
 +	__mptcp_subflow_connect((struct sock *)msk, 0, &local, &remote);
  	spin_lock_bh(&msk->pm.lock);
++<<<<<<< HEAD
++=======
+ 
+ 	mptcp_pm_announce_addr(msk, &remote, true);
+ }
+ 
+ void mptcp_pm_nl_rm_addr_received(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("address rm_id %d", msk->pm.rm_id);
+ 
+ 	if (!msk->pm.rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 		long timeout = 0;
+ 
+ 		if (msk->pm.rm_id != subflow->remote_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow, timeout);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.add_addr_accepted--;
+ 		msk->pm.subflows--;
+ 		WRITE_ONCE(msk->pm.accept_addr, true);
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMADDR);
+ 
+ 		break;
+ 	}
+ }
+ 
+ void mptcp_pm_nl_rm_subflow_received(struct mptcp_sock *msk, u8 rm_id)
+ {
+ 	struct mptcp_subflow_context *subflow, *tmp;
+ 	struct sock *sk = (struct sock *)msk;
+ 
+ 	pr_debug("subflow rm_id %d", rm_id);
+ 
+ 	if (!rm_id)
+ 		return;
+ 
+ 	if (list_empty(&msk->conn_list))
+ 		return;
+ 
+ 	list_for_each_entry_safe(subflow, tmp, &msk->conn_list, node) {
+ 		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
+ 		int how = RCV_SHUTDOWN | SEND_SHUTDOWN;
+ 		long timeout = 0;
+ 
+ 		if (rm_id != subflow->local_id)
+ 			continue;
+ 
+ 		spin_unlock_bh(&msk->pm.lock);
+ 		mptcp_subflow_shutdown(sk, ssk, how);
+ 		__mptcp_close_ssk(sk, ssk, subflow, timeout);
+ 		spin_lock_bh(&msk->pm.lock);
+ 
+ 		msk->pm.local_addr_used--;
+ 		msk->pm.subflows--;
+ 
+ 		__MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMSUBFLOW);
+ 
+ 		break;
+ 	}
++>>>>>>> 7a7e52e38a40 (mptcp: add RM_ADDR related mibs)
  }
  
  static bool address_use_port(struct mptcp_pm_addr_entry *entry)
* Unmerged path net/mptcp/mib.c
* Unmerged path net/mptcp/mib.h
* Unmerged path net/mptcp/pm_netlink.c
