seqlock: Align multi-line macros newline escapes at 72 columns

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ahmed S. Darwish <a.darwish@linutronix.de>
commit ec8702da570ebb59f38471007bf71359c51b027b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ec8702da.failed

Parent commit, "seqlock: Extend seqcount API with associated locks",
introduced a big number of multi-line macros that are newline-escaped
at 72 columns.

For overall cohesion, align the earlier-existing macros similarly.

	Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200720155530.1173732-11-a.darwish@linutronix.de
(cherry picked from commit ec8702da570ebb59f38471007bf71359c51b027b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/seqlock.h
diff --cc include/linux/seqlock.h
index 362623ec6c41,b48729988325..000000000000
--- a/include/linux/seqlock.h
+++ b/include/linux/seqlock.h
@@@ -79,13 -80,18 +79,25 @@@ static inline void __seqcount_init(seqc
  }
  
  #ifdef CONFIG_DEBUG_LOCK_ALLOC
- # define SEQCOUNT_DEP_MAP_INIT(lockname) \
- 		.dep_map = { .name = #lockname } \
  
+ # define SEQCOUNT_DEP_MAP_INIT(lockname)				\
+ 		.dep_map = { .name = #lockname }
+ 
++<<<<<<< HEAD
 +# define seqcount_init(s)				\
 +	do {						\
 +		static struct lock_class_key __key;	\
 +		__seqcount_init((s), #s, &__key);	\
++=======
+ /**
+  * seqcount_init() - runtime initializer for seqcount_t
+  * @s: Pointer to the seqcount_t instance
+  */
+ # define seqcount_init(s)						\
+ 	do {								\
+ 		static struct lock_class_key __key;			\
+ 		__seqcount_init((s), #s, &__key);			\
++>>>>>>> ec8702da570e (seqlock: Align multi-line macros newline escapes at 72 columns)
  	} while (0)
  
  static inline void seqcount_lockdep_reader_access(const seqcount_t *s)
@@@ -444,27 -843,34 +456,44 @@@ typedef struct 
  	spinlock_t lock;
  } seqlock_t;
  
++<<<<<<< HEAD
 +/*
 + * These macros triggered gcc-3.x compile-time problems.  We think these are
 + * OK now.  Be cautious.
 + */
 +#define __SEQLOCK_UNLOCKED(lockname)			\
 +	{						\
 +		.seqcount = SEQCNT_ZERO(lockname),	\
 +		.lock =	__SPIN_LOCK_UNLOCKED(lockname)	\
 +	}
 +
 +#define seqlock_init(x)					\
 +	do {						\
 +		seqcount_init(&(x)->seqcount);		\
 +		spin_lock_init(&(x)->lock);		\
++=======
+ #define __SEQLOCK_UNLOCKED(lockname)					\
+ 	{								\
+ 		.seqcount = SEQCNT_ZERO(lockname),			\
+ 		.lock =	__SPIN_LOCK_UNLOCKED(lockname)			\
+ 	}
+ 
+ /**
+  * seqlock_init() - dynamic initializer for seqlock_t
+  * @sl: Pointer to the seqlock_t instance
+  */
+ #define seqlock_init(sl)						\
+ 	do {								\
+ 		seqcount_init(&(sl)->seqcount);				\
+ 		spin_lock_init(&(sl)->lock);				\
++>>>>>>> ec8702da570e (seqlock: Align multi-line macros newline escapes at 72 columns)
  	} while (0)
  
 -/**
 - * DEFINE_SEQLOCK() - Define a statically allocated seqlock_t
 - * @sl: Name of the seqlock_t instance
 - */
 -#define DEFINE_SEQLOCK(sl) \
 -		seqlock_t sl = __SEQLOCK_UNLOCKED(sl)
 +#define DEFINE_SEQLOCK(x) \
 +		seqlock_t x = __SEQLOCK_UNLOCKED(x)
  
 -/**
 - * read_seqbegin() - start a seqlock_t read side critical section
 - * @sl: Pointer to seqlock_t
 - *
 - * Return: count, to be passed to read_seqretry()
 +/*
 + * Read side functions for starting and finalizing a read side section.
   */
  static inline unsigned read_seqbegin(const seqlock_t *sl)
  {
* Unmerged path include/linux/seqlock.h
