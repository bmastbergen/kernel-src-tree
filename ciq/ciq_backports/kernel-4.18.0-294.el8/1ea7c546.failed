RDMA/core: Annotate CMA unlock helper routine

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit 1ea7c546b8b3f27bf7da673c265b09c8f79d11bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/1ea7c546.failed

Fix the following sparse error by adding annotation to
cm_queue_work_unlock() that it releases cm_id_priv->lock lock.

 drivers/infiniband/core/cm.c:936:24: warning: context imbalance in
 'cm_queue_work_unlock' - unexpected unlock

Fixes: e83f195aa45c ("RDMA/cm: Pull duplicated code into cm_queue_work_unlock()")
Link: https://lore.kernel.org/r/20200611130045.1994026-1-leon@kernel.org
	Reported-by: kernel test robot <lkp@intel.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 1ea7c546b8b3f27bf7da673c265b09c8f79d11bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cm.c
diff --cc drivers/infiniband/core/cm.c
index 3ccb7f5631c4,0d1377232933..000000000000
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@@ -913,6 -916,36 +913,39 @@@ static void cm_free_work(struct cm_wor
  	kfree(work);
  }
  
++<<<<<<< HEAD
++=======
+ static void cm_queue_work_unlock(struct cm_id_private *cm_id_priv,
+ 				 struct cm_work *work)
+ 	__releases(&cm_id_priv->lock)
+ {
+ 	bool immediate;
+ 
+ 	/*
+ 	 * To deliver the event to the user callback we have the drop the
+ 	 * spinlock, however, we need to ensure that the user callback is single
+ 	 * threaded and receives events in the temporal order. If there are
+ 	 * already events being processed then thread new events onto a list,
+ 	 * the thread currently processing will pick them up.
+ 	 */
+ 	immediate = atomic_inc_and_test(&cm_id_priv->work_count);
+ 	if (!immediate) {
+ 		list_add_tail(&work->list, &cm_id_priv->work_list);
+ 		/*
+ 		 * This routine always consumes incoming reference. Once queued
+ 		 * to the work_list then a reference is held by the thread
+ 		 * currently running cm_process_work() and this reference is not
+ 		 * needed.
+ 		 */
+ 		cm_deref_id(cm_id_priv);
+ 	}
+ 	spin_unlock_irq(&cm_id_priv->lock);
+ 
+ 	if (immediate)
+ 		cm_process_work(cm_id_priv, work);
+ }
+ 
++>>>>>>> 1ea7c546b8b3 (RDMA/core: Annotate CMA unlock helper routine)
  static inline int cm_convert_to_ms(int iba_time)
  {
  	/* approximate conversion to ms from 4.096us x 2^iba_time */
* Unmerged path drivers/infiniband/core/cm.c
