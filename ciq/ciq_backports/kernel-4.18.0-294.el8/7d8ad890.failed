mm/kasan: introduce __kasan_check_{read,write}

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [mm] mm/kasan: introduce __kasan_check_{read, write} (Nico Pache) [1894223]
Rebuild_FUZZ: 98.92%
commit-author Marco Elver <elver@google.com>
commit 7d8ad890dad00f6cd64bfb44d9be4fceb10cf819
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/7d8ad890.failed

Patch series "mm/kasan: Add object validation in ksize()", v3.

This patch (of 5):

This introduces __kasan_check_{read,write}.  __kasan_check functions may
be used from anywhere, even compilation units that disable instrumentation
selectively.

This change eliminates the need for the __KASAN_INTERNAL definition.

[elver@google.com: v5]
  Link: http://lkml.kernel.org/r/20190708170706.174189-2-elver@google.com
Link: http://lkml.kernel.org/r/20190626142014.141844-2-elver@google.com
	Signed-off-by: Marco Elver <elver@google.com>
	Acked-by: Mark Rutland <mark.rutland@arm.com>
	Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Konovalov <andreyknvl@google.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Kees Cook <keescook@chromium.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7d8ad890dad00f6cd64bfb44d9be4fceb10cf819)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kasan-checks.h
#	mm/kasan/kasan.c
diff --cc include/linux/kasan-checks.h
index d314150658a4,221f05fbddd7..000000000000
--- a/include/linux/kasan-checks.h
+++ b/include/linux/kasan-checks.h
@@@ -2,9 -2,28 +2,34 @@@
  #ifndef _LINUX_KASAN_CHECKS_H
  #define _LINUX_KASAN_CHECKS_H
  
++<<<<<<< HEAD
 +#ifdef CONFIG_KASAN
 +void kasan_check_read(const volatile void *p, unsigned int size);
 +void kasan_check_write(const volatile void *p, unsigned int size);
++=======
+ /*
+  * __kasan_check_*: Always available when KASAN is enabled. This may be used
+  * even in compilation units that selectively disable KASAN, but must use KASAN
+  * to validate access to an address.   Never use these in header files!
+  */
+ #ifdef CONFIG_KASAN
+ void __kasan_check_read(const volatile void *p, unsigned int size);
+ void __kasan_check_write(const volatile void *p, unsigned int size);
+ #else
+ static inline void __kasan_check_read(const volatile void *p, unsigned int size)
+ { }
+ static inline void __kasan_check_write(const volatile void *p, unsigned int size)
+ { }
+ #endif
+ 
+ /*
+  * kasan_check_*: Only available when the particular compilation unit has KASAN
+  * instrumentation enabled. May be used in header files.
+  */
+ #ifdef __SANITIZE_ADDRESS__
+ #define kasan_check_read __kasan_check_read
+ #define kasan_check_write __kasan_check_write
++>>>>>>> 7d8ad890dad0 (mm/kasan: introduce __kasan_check_{read,write})
  #else
  static inline void kasan_check_read(const volatile void *p, unsigned int size)
  { }
diff --cc mm/kasan/kasan.c
index d79269dd4b58,6bada42cc152..000000000000
--- a/mm/kasan/kasan.c
+++ b/mm/kasan/kasan.c
@@@ -13,9 -14,6 +13,12 @@@
   *
   */
  
++<<<<<<< HEAD:mm/kasan/kasan.c
 +#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 +#define DISABLE_BRANCH_PROFILING
 +
++=======
++>>>>>>> 7d8ad890dad0 (mm/kasan: introduce __kasan_check_{read,write}):mm/kasan/common.c
  #include <linux/export.h>
  #include <linux/interrupt.h>
  #include <linux/init.h>
@@@ -50,6 -87,44 +53,47 @@@ void kasan_disable_current(void
  	current->kasan_depth--;
  }
  
++<<<<<<< HEAD:mm/kasan/kasan.c
++=======
+ void __kasan_check_read(const volatile void *p, unsigned int size)
+ {
+ 	check_memory_region((unsigned long)p, size, false, _RET_IP_);
+ }
+ EXPORT_SYMBOL(__kasan_check_read);
+ 
+ void __kasan_check_write(const volatile void *p, unsigned int size)
+ {
+ 	check_memory_region((unsigned long)p, size, true, _RET_IP_);
+ }
+ EXPORT_SYMBOL(__kasan_check_write);
+ 
+ #undef memset
+ void *memset(void *addr, int c, size_t len)
+ {
+ 	check_memory_region((unsigned long)addr, len, true, _RET_IP_);
+ 
+ 	return __memset(addr, c, len);
+ }
+ 
+ #undef memmove
+ void *memmove(void *dest, const void *src, size_t len)
+ {
+ 	check_memory_region((unsigned long)src, len, false, _RET_IP_);
+ 	check_memory_region((unsigned long)dest, len, true, _RET_IP_);
+ 
+ 	return __memmove(dest, src, len);
+ }
+ 
+ #undef memcpy
+ void *memcpy(void *dest, const void *src, size_t len)
+ {
+ 	check_memory_region((unsigned long)src, len, false, _RET_IP_);
+ 	check_memory_region((unsigned long)dest, len, true, _RET_IP_);
+ 
+ 	return __memcpy(dest, src, len);
+ }
+ 
++>>>>>>> 7d8ad890dad0 (mm/kasan: introduce __kasan_check_{read,write}):mm/kasan/common.c
  /*
   * Poisons the shadow memory for 'size' bytes starting from 'addr'.
   * Memory addresses should be aligned to KASAN_SHADOW_SCALE_SIZE.
* Unmerged path include/linux/kasan-checks.h
* Unmerged path mm/kasan/kasan.c
