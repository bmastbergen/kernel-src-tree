mm: ksize() should silently accept a NULL pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author William Kucharski <william.kucharski@oracle.com>
commit fa9ba3aa89f9f1c003b5f5cde893bbbc140c7223
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fa9ba3aa.failed

Other mm routines such as kfree() and kzfree() silently do the right thing
if passed a NULL pointer, so ksize() should do the same.

	Signed-off-by: William Kucharski <william.kucharski@oracle.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Matthew Wilcox (Oracle) <willy@infradead.org>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Link: http://lkml.kernel.org/r/20200616225409.4670-1-william.kucharski@oracle.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit fa9ba3aa89f9f1c003b5f5cde893bbbc140c7223)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slab_common.c
diff --cc mm/slab_common.c
index 0ab19790edb9,e493203b5002..000000000000
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@@ -1729,13 -1743,56 +1728,60 @@@ void kzfree(const void *p
  	size_t ks;
  	void *mem = (void *)p;
  
- 	if (unlikely(ZERO_OR_NULL_PTR(mem)))
- 		return;
  	ks = ksize(mem);
- 	memzero_explicit(mem, ks);
+ 	if (ks)
+ 		memzero_explicit(mem, ks);
  	kfree(mem);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(kzfree);
++=======
+ EXPORT_SYMBOL(kfree_sensitive);
+ 
+ /**
+  * ksize - get the actual amount of memory allocated for a given object
+  * @objp: Pointer to the object
+  *
+  * kmalloc may internally round up allocations and return more memory
+  * than requested. ksize() can be used to determine the actual amount of
+  * memory allocated. The caller may use this additional memory, even though
+  * a smaller amount of memory was initially specified with the kmalloc call.
+  * The caller must guarantee that objp points to a valid object previously
+  * allocated with either kmalloc() or kmem_cache_alloc(). The object
+  * must not be freed during the duration of the call.
+  *
+  * Return: size of the actual memory used by @objp in bytes
+  */
+ size_t ksize(const void *objp)
+ {
+ 	size_t size;
+ 
+ 	/*
+ 	 * We need to check that the pointed to object is valid, and only then
+ 	 * unpoison the shadow memory below. We use __kasan_check_read(), to
+ 	 * generate a more useful report at the time ksize() is called (rather
+ 	 * than later where behaviour is undefined due to potential
+ 	 * use-after-free or double-free).
+ 	 *
+ 	 * If the pointed to memory is invalid we return 0, to avoid users of
+ 	 * ksize() writing to and potentially corrupting the memory region.
+ 	 *
+ 	 * We want to perform the check before __ksize(), to avoid potentially
+ 	 * crashing in __ksize() due to accessing invalid metadata.
+ 	 */
+ 	if (unlikely(ZERO_OR_NULL_PTR(objp)) || !__kasan_check_read(objp, 1))
+ 		return 0;
+ 
+ 	size = __ksize(objp);
+ 	/*
+ 	 * We assume that ksize callers could use whole allocated area,
+ 	 * so we need to unpoison this area.
+ 	 */
+ 	kasan_unpoison_shadow(objp, size);
+ 	return size;
+ }
+ EXPORT_SYMBOL(ksize);
++>>>>>>> fa9ba3aa89f9 (mm: ksize() should silently accept a NULL pointer)
  
  /* Tracepoints definitions. */
  EXPORT_TRACEPOINT_SYMBOL(kmalloc);
* Unmerged path mm/slab_common.c
