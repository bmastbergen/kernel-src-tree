driver: core: Improve documentation for fwnode_operations.add_links()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 92df01e3601fe29eb3727a82705eafa6209053f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/92df01e3.failed

The add_links() ops shouldn't return on the first failed device link
add. It needs to continue trying to add device links to other suppliers
that are available. The documentation didn't explain WHY this behavior
is necessary. So, update the documentation with an example that explains
why this is necessary.

	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20191011191521.179614-3-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 92df01e3601fe29eb3727a82705eafa6209053f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fwnode.h
diff --cc include/linux/fwnode.h
index da6c12ac38c1,97223e2410bd..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -71,6 -66,38 +71,41 @@@ struct fwnode_reference_args 
   *			       endpoint node.
   * @graph_get_port_parent: Return the parent node of a port node.
   * @graph_parse_endpoint: Parse endpoint for port and endpoint id.
++<<<<<<< HEAD
++=======
+  * @add_links:	Called after the device corresponding to the fwnode is added
+  *		using device_add(). The function is expected to create device
+  *		links to all the suppliers of the device that are available at
+  *		the time this function is called.  The function must NOT stop
+  *		at the first failed device link if other unlinked supplier
+  *		devices are present in the system.  This is necessary for the
+  *		driver/bus sync_state() callbacks to work correctly.
+  *
+  *		For example, say Device-C depends on suppliers Device-S1 and
+  *		Device-S2 and the dependency is listed in that order in the
+  *		firmware.  Say, S1 gets populated from the firmware after
+  *		late_initcall_sync().  Say S2 is populated and probed way
+  *		before that in device_initcall(). When C is populated, if this
+  *		add_links() function doesn't continue past a "failed linking to
+  *		S1" and continue linking C to S2, then S2 will get a
+  *		sync_state() callback before C is probed. This is because from
+  *		the perspective of S2, C was never a consumer when its
+  *		sync_state() evaluation is done. To avoid this, the add_links()
+  *		function has to go through all available suppliers of the
+  *		device (that corresponds to this fwnode) and link to them
+  *		before returning.
+  *
+  *		If some suppliers are not yet available (indicated by an error
+  *		return value), this function will be called again when other
+  *		devices are added to allow creating device links to any newly
+  *		available suppliers.
+  *
+  *		Return 0 if device links have been successfully created to all
+  *		the suppliers of this device or if the supplier information is
+  *		not known. Return an error if and only if the supplier
+  *		information is known but some of the suppliers are not yet
+  *		available to create device links to.
++>>>>>>> 92df01e3601f (driver: core: Improve documentation for fwnode_operations.add_links())
   */
  struct fwnode_operations {
  	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
* Unmerged path include/linux/fwnode.h
