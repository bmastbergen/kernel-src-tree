iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Mordechay Goodstein <mordechay.goodstein@intel.com>
commit e80bfd117d89e8f9d71893edc03bc7b3c6c1eea3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e80bfd11.failed

For new APIs this avoids checking every return if it's
IWL_FW_CMD_VER_UNKNOWN (99) or it's lower than the new API value

Done with spatch:
-iwl_fw_lookup_cmd_ver(E1, E2, E3)
+iwl_fw_lookup_cmd_ver(E1, E2, E3, IWL_FW_CMD_VER_UNKNOWN)

	Signed-off-by: Mordechay Goodstein <mordechay.goodstein@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Link: https://lore.kernel.org/r/iwlwifi.20200928121852.70bec6eb8008.I6ea78553801d33f7ed10fcd2e4be4ba781fe469a@changeid
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit e80bfd117d89e8f9d71893edc03bc7b3c6c1eea3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/fw/common_rx.c
#	drivers/net/wireless/intel/iwlwifi/fw/img.h
#	drivers/net/wireless/intel/iwlwifi/fw/init.c
#	drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
#	drivers/net/wireless/intel/iwlwifi/mvm/ftm-responder.c
#	drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
#	drivers/net/wireless/intel/iwlwifi/mvm/scan.c
diff --cc drivers/net/wireless/intel/iwlwifi/fw/common_rx.c
index 6f75985eea66,c2a4e60518bc..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/fw/common_rx.c
+++ b/drivers/net/wireless/intel/iwlwifi/fw/common_rx.c
@@@ -53,36 -53,90 +53,59 @@@
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 + *
   *****************************************************************************/
 +#include "iwl-drv.h"
 +#include "runtime.h"
 +#include "fw/api/commands.h"
 +#include "fw/api/alive.h"
  
++<<<<<<< HEAD:drivers/net/wireless/intel/iwlwifi/fw/common_rx.c
 +static void iwl_fwrt_fseq_ver_mismatch(struct iwl_fw_runtime *fwrt,
 +				       struct iwl_rx_cmd_buffer *rxb)
++=======
+ #include "img.h"
+ 
+ u8 iwl_fw_lookup_cmd_ver(const struct iwl_fw *fw, u8 grp, u8 cmd, u8 def)
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver):drivers/net/wireless/intel/iwlwifi/fw/img.c
  {
 -	const struct iwl_fw_cmd_version *entry;
 -	unsigned int i;
 -
 -	if (!fw->ucode_capa.cmd_versions ||
 -	    !fw->ucode_capa.n_cmd_versions)
 -		return def;
 -
 -	entry = fw->ucode_capa.cmd_versions;
 -	for (i = 0; i < fw->ucode_capa.n_cmd_versions; i++, entry++) {
 -		if (entry->group == grp && entry->cmd == cmd) {
 -			if (entry->cmd_ver == IWL_FW_CMD_VER_UNKNOWN)
 -				return def;
 -			return entry->cmd_ver;
 -		}
 -	}
 +	struct iwl_rx_packet *pkt = rxb_addr(rxb);
 +	struct iwl_fseq_ver_mismatch_ntf *fseq = (void *)pkt->data;
  
 -	return def;
++<<<<<<< HEAD:drivers/net/wireless/intel/iwlwifi/fw/common_rx.c
 +	IWL_ERR(fwrt, "FSEQ version mismatch (aux: %d, wifi: %d)\n",
 +		__le32_to_cpu(fseq->aux_read_fseq_ver),
 +		__le32_to_cpu(fseq->wifi_fseq_ver));
  }
 -EXPORT_SYMBOL_GPL(iwl_fw_lookup_cmd_ver);
  
 -u8 iwl_fw_lookup_notif_ver(const struct iwl_fw *fw, u8 grp, u8 cmd, u8 def)
 +void iwl_fwrt_handle_notification(struct iwl_fw_runtime *fwrt,
 +				  struct iwl_rx_cmd_buffer *rxb)
  {
 -	const struct iwl_fw_cmd_version *entry;
 -	unsigned int i;
 +	struct iwl_rx_packet *pkt = rxb_addr(rxb);
 +	u32 cmd = WIDE_ID(pkt->hdr.group_id, pkt->hdr.cmd);
  
 +	switch (cmd) {
 +	case WIDE_ID(SYSTEM_GROUP, FSEQ_VER_MISMATCH_NTF):
 +		iwl_fwrt_fseq_ver_mismatch(fwrt, rxb);
 +		break;
 +	default:
 +		break;
 +	}
++=======
+ 	if (!fw->ucode_capa.cmd_versions ||
+ 	    !fw->ucode_capa.n_cmd_versions)
+ 		return def;
+ 
+ 	entry = fw->ucode_capa.cmd_versions;
+ 	for (i = 0; i < fw->ucode_capa.n_cmd_versions; i++, entry++) {
+ 		if (entry->group == grp && entry->cmd == cmd) {
 -			if (entry->notif_ver == IWL_FW_CMD_VER_UNKNOWN)
++			if (entry->cmd_ver == IWL_FW_CMD_VER_UNKNOWN)
+ 				return def;
 -			return entry->notif_ver;
++			return entry->cmd_ver;
+ 		}
+ 	}
+ 
+ 	return def;
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver):drivers/net/wireless/intel/iwlwifi/fw/img.c
  }
 -EXPORT_SYMBOL_GPL(iwl_fw_lookup_notif_ver);
 -
 -#define FW_SYSASSERT_CPU_MASK 0xf0000000
 -static const struct {
 -	const char *name;
 -	u8 num;
 -} advanced_lookup[] = {
 -	{ "NMI_INTERRUPT_WDG", 0x34 },
 -	{ "SYSASSERT", 0x35 },
 -	{ "UCODE_VERSION_MISMATCH", 0x37 },
 -	{ "BAD_COMMAND", 0x38 },
 -	{ "BAD_COMMAND", 0x39 },
 -	{ "NMI_INTERRUPT_DATA_ACTION_PT", 0x3C },
 -	{ "FATAL_ERROR", 0x3D },
 -	{ "NMI_TRM_HW_ERR", 0x46 },
 -	{ "NMI_INTERRUPT_TRM", 0x4C },
 -	{ "NMI_INTERRUPT_BREAK_POINT", 0x54 },
 -	{ "NMI_INTERRUPT_WDG_RXF_FULL", 0x5C },
 -	{ "NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL", 0x64 },
 -	{ "NMI_INTERRUPT_HOST", 0x66 },
 -	{ "NMI_INTERRUPT_LMAC_FATAL", 0x70 },
 -	{ "NMI_INTERRUPT_UMAC_FATAL", 0x71 },
 -	{ "NMI_INTERRUPT_OTHER_LMAC_FATAL", 0x73 },
 -	{ "NMI_INTERRUPT_ACTION_PT", 0x7C },
 -	{ "NMI_INTERRUPT_UNKNOWN", 0x84 },
 -	{ "NMI_INTERRUPT_INST_ACTION_PT", 0x86 },
 -	{ "ADVANCED_SYSASSERT", 0 },
 -};
 -
 -const char *iwl_fw_lookup_assert_desc(u32 num)
 -{
 -	int i;
 -
 -	for (i = 0; i < ARRAY_SIZE(advanced_lookup) - 1; i++)
 -		if (advanced_lookup[i].num == (num & ~FW_SYSASSERT_CPU_MASK))
 -			return advanced_lookup[i].name;
 -
 -	/* No entry matches 'num', so it is the last: ADVANCED_SYSASSERT */
 -	return advanced_lookup[i].name;
 -}
 -EXPORT_SYMBOL_GPL(iwl_fw_lookup_assert_desc);
 +IWL_EXPORT_SYMBOL(iwl_fwrt_handle_notification);
diff --cc drivers/net/wireless/intel/iwlwifi/fw/img.h
index 90ca5f929cf9,07d72bcf9c46..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/fw/img.h
+++ b/drivers/net/wireless/intel/iwlwifi/fw/img.h
@@@ -313,22 -312,8 +313,26 @@@ iwl_get_ucode_image(const struct iwl_f
  	return &fw->img[ucode_type];
  }
  
++<<<<<<< HEAD
 +static inline u8 iwl_mvm_lookup_cmd_ver(const struct iwl_fw *fw, u8 grp, u8 cmd)
 +{
 +	const struct iwl_fw_cmd_version *entry;
 +	unsigned int i;
 +
 +	if (!fw->ucode_capa.cmd_versions ||
 +	    !fw->ucode_capa.n_cmd_versions)
 +		return IWL_FW_CMD_VER_UNKNOWN;
 +
 +	entry = fw->ucode_capa.cmd_versions;
 +	for (i = 0; i < fw->ucode_capa.n_cmd_versions; i++, entry++) {
 +		if (entry->group == grp && entry->cmd == cmd)
 +			return entry->cmd_ver;
 +	}
 +
 +	return IWL_FW_CMD_VER_UNKNOWN;
 +}
++=======
+ u8 iwl_fw_lookup_cmd_ver(const struct iwl_fw *fw, u8 grp, u8 cmd, u8 def);
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver)
  
 -u8 iwl_fw_lookup_notif_ver(const struct iwl_fw *fw, u8 grp, u8 cmd, u8 def);
 -const char *iwl_fw_lookup_assert_desc(u32 num);
  #endif  /* __iwl_fw_img_h__ */
diff --cc drivers/net/wireless/intel/iwlwifi/fw/init.c
index ba00d162ce72,f8516c7ca767..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/fw/init.c
+++ b/drivers/net/wireless/intel/iwlwifi/fw/init.c
@@@ -95,3 -98,52 +95,55 @@@ void iwl_fw_runtime_resume(struct iwl_f
  	iwl_fw_resume_timestamp(fwrt);
  }
  IWL_EXPORT_SYMBOL(iwl_fw_runtime_resume);
++<<<<<<< HEAD
++=======
+ 
+ /* set device type and latency */
+ int iwl_set_soc_latency(struct iwl_fw_runtime *fwrt)
+ {
+ 	struct iwl_soc_configuration_cmd cmd = {};
+ 	struct iwl_host_cmd hcmd = {
+ 		.id = iwl_cmd_id(SOC_CONFIGURATION_CMD, SYSTEM_GROUP, 0),
+ 		.data[0] = &cmd,
+ 		.len[0] = sizeof(cmd),
+ 	};
+ 	int ret;
+ 
+ 	/*
+ 	 * In VER_1 of this command, the discrete value is considered
+ 	 * an integer; In VER_2, it's a bitmask.  Since we have only 2
+ 	 * values in VER_1, this is backwards-compatible with VER_2,
+ 	 * as long as we don't set any other bits.
+ 	 */
+ 	if (!fwrt->trans->trans_cfg->integrated)
+ 		cmd.flags = cpu_to_le32(SOC_CONFIG_CMD_FLAGS_DISCRETE);
+ 
+ 	BUILD_BUG_ON(IWL_CFG_TRANS_LTR_DELAY_NONE !=
+ 		     SOC_FLAGS_LTR_APPLY_DELAY_NONE);
+ 	BUILD_BUG_ON(IWL_CFG_TRANS_LTR_DELAY_200US !=
+ 		     SOC_FLAGS_LTR_APPLY_DELAY_200);
+ 	BUILD_BUG_ON(IWL_CFG_TRANS_LTR_DELAY_2500US !=
+ 		     SOC_FLAGS_LTR_APPLY_DELAY_2500);
+ 	BUILD_BUG_ON(IWL_CFG_TRANS_LTR_DELAY_1820US !=
+ 		     SOC_FLAGS_LTR_APPLY_DELAY_1820);
+ 
+ 	if (fwrt->trans->trans_cfg->ltr_delay != IWL_CFG_TRANS_LTR_DELAY_NONE &&
+ 	    !WARN_ON(!fwrt->trans->trans_cfg->integrated))
+ 		cmd.flags |= le32_encode_bits(fwrt->trans->trans_cfg->ltr_delay,
+ 					      SOC_FLAGS_LTR_APPLY_DELAY_MASK);
+ 
+ 	if (iwl_fw_lookup_cmd_ver(fwrt->fw, IWL_ALWAYS_LONG_GROUP,
+ 				  SCAN_REQ_UMAC,
+ 				  IWL_FW_CMD_VER_UNKNOWN) >= 2 &&
+ 	    fwrt->trans->trans_cfg->low_latency_xtal)
+ 		cmd.flags |= cpu_to_le32(SOC_CONFIG_CMD_FLAGS_LOW_LATENCY);
+ 
+ 	cmd.latency = cpu_to_le32(fwrt->trans->trans_cfg->xtal_latency);
+ 
+ 	ret = iwl_trans_send_cmd(fwrt->trans, &hcmd);
+ 	if (ret)
+ 		IWL_ERR(fwrt, "Failed to set soc latency: %d\n", ret);
+ 	return ret;
+ }
+ IWL_EXPORT_SYMBOL(iwl_set_soc_latency);
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver)
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
index b5a48f3daf5f,3792a5f51201..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
@@@ -576,8 -576,9 +576,14 @@@ int iwl_mvm_ftm_start(struct iwl_mvm *m
  		return -EBUSY;
  
  	if (new_api) {
++<<<<<<< HEAD
 +		u8 cmd_ver = iwl_mvm_lookup_cmd_ver(mvm->fw, LOCATION_GROUP,
 +						    TOF_RANGE_REQ_CMD);
++=======
+ 		u8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, LOCATION_GROUP,
+ 						   TOF_RANGE_REQ_CMD,
+ 						   IWL_FW_CMD_VER_UNKNOWN);
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver)
  
  		switch (cmd_ver) {
  		case 9:
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/ftm-responder.c
index 2c2ec2538d37,160f3f934ace..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/ftm-responder.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ftm-responder.c
@@@ -142,8 -142,9 +142,14 @@@ iwl_mvm_ftm_responder_cmd(struct iwl_mv
  				    IWL_TOF_RESPONDER_CMD_VALID_STA_ID),
  		.sta_id = mvmvif->bcast_sta.sta_id,
  	};
++<<<<<<< HEAD
 +	u8 cmd_ver = iwl_mvm_lookup_cmd_ver(mvm->fw, LOCATION_GROUP,
 +					    TOF_RESPONDER_CONFIG_CMD);
++=======
+ 	u8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, LOCATION_GROUP,
+ 					   TOF_RESPONDER_CONFIG_CMD,
+ 					   IWL_FW_CMD_VER_UNKNOWN);
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver)
  	int err;
  
  	lockdep_assert_held(&mvm->mutex);
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
index 0002bcdc6da2,b74978878a8d..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
@@@ -2148,8 -2149,9 +2148,14 @@@ iwl_mvm_set_chan_info_chandef(struct iw
  
  static inline int iwl_umac_scan_get_max_profiles(const struct iwl_fw *fw)
  {
++<<<<<<< HEAD
 +	u8 ver = iwl_mvm_lookup_cmd_ver(fw, IWL_ALWAYS_LONG_GROUP,
 +					SCAN_OFFLOAD_UPDATE_PROFILES_CMD);
++=======
+ 	u8 ver = iwl_fw_lookup_cmd_ver(fw, IWL_ALWAYS_LONG_GROUP,
+ 				       SCAN_OFFLOAD_UPDATE_PROFILES_CMD,
+ 				       IWL_FW_CMD_VER_UNKNOWN);
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver)
  	return (ver == IWL_FW_CMD_VER_UNKNOWN || ver < 3) ?
  		IWL_SCAN_MAX_PROFILES : IWL_SCAN_MAX_PROFILES_V2;
  }
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/scan.c
index bc48113f0568,02e3b70b36dd..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
@@@ -2228,8 -2228,9 +2228,14 @@@ static int iwl_mvm_build_scan_cmd(struc
  
  	hcmd->id = iwl_cmd_id(SCAN_REQ_UMAC, IWL_ALWAYS_LONG_GROUP, 0);
  
++<<<<<<< HEAD
 +	scan_ver = iwl_mvm_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
 +					  SCAN_REQ_UMAC);
++=======
+ 	scan_ver = iwl_fw_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
+ 					 SCAN_REQ_UMAC,
+ 					 IWL_FW_CMD_VER_UNKNOWN);
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver)
  
  	for (i = 0; i < ARRAY_SIZE(iwl_scan_umac_handlers); i++) {
  		const struct iwl_scan_umac_handler *ver_handler =
@@@ -2568,8 -2569,9 +2574,14 @@@ static int iwl_scan_req_umac_get_size(u
  int iwl_mvm_scan_size(struct iwl_mvm *mvm)
  {
  	int base_size, tail_size;
++<<<<<<< HEAD
 +	u8 scan_ver = iwl_mvm_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
 +					     SCAN_REQ_UMAC);
++=======
+ 	u8 scan_ver = iwl_fw_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
+ 					    SCAN_REQ_UMAC,
+ 					    IWL_FW_CMD_VER_UNKNOWN);
++>>>>>>> e80bfd117d89 (iwlwifi: fw: add default value for iwl_fw_lookup_cmd_ver)
  
  	base_size = iwl_scan_req_umac_get_size(scan_ver);
  	if (base_size)
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/common_rx.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/img.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/init.c
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/d3.c b/drivers/net/wireless/intel/iwlwifi/mvm/d3.c
index 3a1e5ac46ea0..b152f5a6ba0f 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/d3.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/d3.c
@@ -781,7 +781,8 @@ static int iwl_mvm_wowlan_config_key_params(struct iwl_mvm *mvm,
 
 	if (key_data.use_rsc_tsc) {
 		int ver = iwl_fw_lookup_cmd_ver(mvm->fw, LONG_GROUP,
-						WOWLAN_TSC_RSC_PARAM);
+						WOWLAN_TSC_RSC_PARAM,
+						IWL_FW_CMD_VER_UNKNOWN);
 		int size;
 
 		if (ver == 4) {
@@ -810,7 +811,8 @@ static int iwl_mvm_wowlan_config_key_params(struct iwl_mvm *mvm,
 	    !fw_has_api(&mvm->fw->ucode_capa,
 			IWL_UCODE_TLV_API_TKIP_MIC_KEYS)) {
 		int ver = iwl_fw_lookup_cmd_ver(mvm->fw, LONG_GROUP,
-						WOWLAN_TKIP_PARAM);
+						WOWLAN_TKIP_PARAM,
+						IWL_FW_CMD_VER_UNKNOWN);
 		int size;
 
 		if (ver == 2) {
@@ -836,8 +838,10 @@ static int iwl_mvm_wowlan_config_key_params(struct iwl_mvm *mvm,
 
 	/* configure rekey data only if offloaded rekey is supported (d3) */
 	if (mvmvif->rekey_data.valid) {
-		cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
-						WOWLAN_KEK_KCK_MATERIAL);
+		cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,
+						IWL_ALWAYS_LONG_GROUP,
+						WOWLAN_KEK_KCK_MATERIAL,
+						IWL_FW_CMD_VER_UNKNOWN);
 		if (WARN_ON(cmd_ver != 2 && cmd_ver != 3 &&
 			    cmd_ver != IWL_FW_CMD_VER_UNKNOWN))
 			return -EINVAL;
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/ftm-responder.c
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/fw.c b/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
index 407c968afe89..7b84837c4bb6 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
@@ -604,7 +604,8 @@ static int iwl_send_phy_cfg_cmd(struct iwl_mvm *mvm)
 		mvm->fw->default_calib[ucode_type].flow_trigger;
 
 	cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
-					PHY_CONFIGURATION_CMD);
+					PHY_CONFIGURATION_CMD,
+					IWL_FW_CMD_VER_UNKNOWN);
 	if (cmd_ver == 3) {
 		iwl_mvm_phy_filter_init(mvm, &phy_filters);
 		memcpy(&phy_cfg_cmd.phy_specific_cfg, &phy_filters,
@@ -762,7 +763,8 @@ int iwl_mvm_sar_select_profile(struct iwl_mvm *mvm, int prof_a, int prof_b)
 	u16 len = 0;
 	u32 n_subbands;
 	u8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, LONG_GROUP,
-					   REDUCE_TX_POWER_CMD);
+					   REDUCE_TX_POWER_CMD,
+					   IWL_FW_CMD_VER_UNKNOWN);
 
 	if (cmd_ver == 6) {
 		len = sizeof(cmd.v6);
@@ -805,8 +807,9 @@ int iwl_mvm_get_sar_geo_profile(struct iwl_mvm *mvm)
 	u16 len;
 	int ret;
 	struct iwl_host_cmd cmd;
-	u8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,
-					   PHY_OPS_GROUP, GEO_TX_POWER_LIMIT);
+	u8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, PHY_OPS_GROUP,
+					   GEO_TX_POWER_LIMIT,
+					   IWL_FW_CMD_VER_UNKNOWN);
 
 	/* the ops field is at the same spot for all versions, so set in v1 */
 	geo_tx_cmd.v1.ops =
@@ -851,8 +854,9 @@ static int iwl_mvm_sar_geo_init(struct iwl_mvm *mvm)
 	union iwl_geo_tx_power_profiles_cmd cmd;
 	u16 len;
 	int ret;
-	u8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,
-					   PHY_OPS_GROUP, GEO_TX_POWER_LIMIT);
+	u8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, PHY_OPS_GROUP,
+					   GEO_TX_POWER_LIMIT,
+					   IWL_FW_CMD_VER_UNKNOWN);
 
 	/* the table is also at the same position both in v1 and v2 */
 	ret = iwl_sar_geo_init(&mvm->fwrt, &cmd.v1.table[0][0],
@@ -993,7 +997,8 @@ int iwl_mvm_ppag_send_cmd(struct iwl_mvm *mvm)
 	}
 
 	cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, PHY_OPS_GROUP,
-					PER_PLATFORM_ANT_GAIN_CMD);
+					PER_PLATFORM_ANT_GAIN_CMD,
+					IWL_FW_CMD_VER_UNKNOWN);
 	if (cmd_ver == 1) {
 		num_sub_bands = IWL_NUM_SUB_BANDS;
 		gain = mvm->fwrt.ppag_table.v1.gain[0];
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
index 0657b68e63fb..dee94faf5e79 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
@@ -1316,7 +1316,8 @@ static int iwl_mvm_set_tx_power(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 		.common.pwr_restriction = cpu_to_le16(8 * tx_power),
 	};
 	u8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, LONG_GROUP,
-					   REDUCE_TX_POWER_CMD);
+					   REDUCE_TX_POWER_CMD,
+					   IWL_FW_CMD_VER_UNKNOWN);
 
 	if (tx_power == IWL_DEFAULT_MAX_TX_POWER)
 		cmd.common.pwr_restriction = cpu_to_le16(IWL_DEV_MAX_TX_POWER);
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/scan.c
