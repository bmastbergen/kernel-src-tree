bonding: allow xfrm offload setup post-module-load

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jarod Wilson <jarod@redhat.com>
commit a3b658cfb66497525278cbf852913a04dbaae992
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a3b658cf.failed

At the moment, bonding xfrm crypto offload can only be set up if the bonding
module is loaded with active-backup mode already set. We need to be able to
make this work with bonds set to AB after the bonding driver has already
been loaded.

So what's done here is:

1) move #define BOND_XFRM_FEATURES to net/bonding.h so it can be used
by both bond_main.c and bond_options.c
2) set BOND_XFRM_FEATURES in bond_dev->hw_features universally, rather than
only when loading in AB mode
3) wire up xfrmdev_ops universally too
4) disable BOND_XFRM_FEATURES in bond_dev->features if not AB
5) exit early (non-AB case) from bond_ipsec_offload_ok, to prevent a
performance hit from traversing into the underlying drivers
5) toggle BOND_XFRM_FEATURES in bond_dev->wanted_features and call
netdev_change_features() from bond_option_mode_set()

In my local testing, I can change bonding modes back and forth on the fly,
have hardware offload work when I'm in AB, and see no performance penalty
to non-AB software encryption, despite having xfrm bits all wired up for
all modes now.

Fixes: 18cb261afd7b ("bonding: support hardware encryption offload to slaves")
	Reported-by: Huy Nguyen <huyn@mellanox.com>
CC: Saeed Mahameed <saeedm@mellanox.com>
CC: Jay Vosburgh <j.vosburgh@gmail.com>
CC: Veaceslav Falico <vfalico@gmail.com>
CC: Andy Gospodarek <andy@greyhouse.net>
CC: "David S. Miller" <davem@davemloft.net>
CC: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
CC: Jakub Kicinski <kuba@kernel.org>
CC: Steffen Klassert <steffen.klassert@secunet.com>
CC: Herbert Xu <herbert@gondor.apana.org.au>
CC: netdev@vger.kernel.org
CC: intel-wired-lan@lists.osuosl.org
	Signed-off-by: Jarod Wilson <jarod@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a3b658cfb66497525278cbf852913a04dbaae992)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 704bda02a80a,2adf6ce20a38..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -372,6 -373,87 +372,90 @@@ static int bond_vlan_rx_kill_vid(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*---------------------------------- XFRM -----------------------------------*/
+ 
+ #ifdef CONFIG_XFRM_OFFLOAD
+ /**
+  * bond_ipsec_add_sa - program device with a security association
+  * @xs: pointer to transformer state struct
+  **/
+ static int bond_ipsec_add_sa(struct xfrm_state *xs)
+ {
+ 	struct net_device *bond_dev = xs->xso.dev;
+ 	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct slave *slave = rtnl_dereference(bond->curr_active_slave);
+ 
+ 	xs->xso.real_dev = slave->dev;
+ 	bond->xs = xs;
+ 
+ 	if (!(slave->dev->xfrmdev_ops
+ 	      && slave->dev->xfrmdev_ops->xdo_dev_state_add)) {
+ 		slave_warn(bond_dev, slave->dev, "Slave does not support ipsec offload\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return slave->dev->xfrmdev_ops->xdo_dev_state_add(xs);
+ }
+ 
+ /**
+  * bond_ipsec_del_sa - clear out this specific SA
+  * @xs: pointer to transformer state struct
+  **/
+ static void bond_ipsec_del_sa(struct xfrm_state *xs)
+ {
+ 	struct net_device *bond_dev = xs->xso.dev;
+ 	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct slave *slave = rtnl_dereference(bond->curr_active_slave);
+ 
+ 	if (!slave)
+ 		return;
+ 
+ 	xs->xso.real_dev = slave->dev;
+ 
+ 	if (!(slave->dev->xfrmdev_ops
+ 	      && slave->dev->xfrmdev_ops->xdo_dev_state_delete)) {
+ 		slave_warn(bond_dev, slave->dev, "%s: no slave xdo_dev_state_delete\n", __func__);
+ 		return;
+ 	}
+ 
+ 	slave->dev->xfrmdev_ops->xdo_dev_state_delete(xs);
+ }
+ 
+ /**
+  * bond_ipsec_offload_ok - can this packet use the xfrm hw offload
+  * @skb: current data packet
+  * @xs: pointer to transformer state struct
+  **/
+ static bool bond_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *xs)
+ {
+ 	struct net_device *bond_dev = xs->xso.dev;
+ 	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct slave *curr_active = rtnl_dereference(bond->curr_active_slave);
+ 	struct net_device *slave_dev = curr_active->dev;
+ 
+ 	if (BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP)
+ 		return true;
+ 
+ 	if (!(slave_dev->xfrmdev_ops
+ 	      && slave_dev->xfrmdev_ops->xdo_dev_offload_ok)) {
+ 		slave_warn(bond_dev, slave_dev, "%s: no slave xdo_dev_offload_ok\n", __func__);
+ 		return false;
+ 	}
+ 
+ 	xs->xso.real_dev = slave_dev;
+ 	return slave_dev->xfrmdev_ops->xdo_dev_offload_ok(skb, xs);
+ }
+ 
+ static const struct xfrmdev_ops bond_xfrmdev_ops = {
+ 	.xdo_dev_state_add = bond_ipsec_add_sa,
+ 	.xdo_dev_state_delete = bond_ipsec_del_sa,
+ 	.xdo_dev_offload_ok = bond_ipsec_offload_ok,
+ };
+ #endif /* CONFIG_XFRM_OFFLOAD */
+ 
++>>>>>>> a3b658cfb664 (bonding: allow xfrm offload setup post-module-load)
  /*------------------------------- Link status -------------------------------*/
  
  /* Set the carrier state for the master according to the state of its
@@@ -4551,6 -4650,12 +4635,15 @@@ void bond_setup(struct net_device *bond
  	bond_dev->priv_flags |= IFF_BONDING | IFF_UNICAST_FLT | IFF_NO_QUEUE;
  	bond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_XFRM_OFFLOAD
+ 	/* set up xfrm device ops (only supported in active-backup right now) */
+ 	bond_dev->xfrmdev_ops = &bond_xfrmdev_ops;
+ 	bond->xs = NULL;
+ #endif /* CONFIG_XFRM_OFFLOAD */
+ 
++>>>>>>> a3b658cfb664 (bonding: allow xfrm offload setup post-module-load)
  	/* don't acquire bond device's netif_tx_lock when transmitting */
  	bond_dev->features |= NETIF_F_LLTX;
  
@@@ -4569,8 -4674,16 +4662,19 @@@
  				NETIF_F_HW_VLAN_CTAG_FILTER;
  
  	bond_dev->hw_features |= NETIF_F_GSO_ENCAP_ALL | NETIF_F_GSO_UDP_L4;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_XFRM_OFFLOAD
+ 	bond_dev->hw_features |= BOND_XFRM_FEATURES;
+ #endif /* CONFIG_XFRM_OFFLOAD */
++>>>>>>> a3b658cfb664 (bonding: allow xfrm offload setup post-module-load)
  	bond_dev->features |= bond_dev->hw_features;
  	bond_dev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX;
+ #ifdef CONFIG_XFRM_OFFLOAD
+ 	/* Disable XFRM features if this isn't an active-backup config */
+ 	if (BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP)
+ 		bond_dev->features &= ~BOND_XFRM_FEATURES;
+ #endif /* CONFIG_XFRM_OFFLOAD */
  }
  
  /* Destroy a bonding device.
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 215c10923289..1b65d144ae44 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -767,6 +767,14 @@ static int bond_option_mode_set(struct bonding *bond,
 	if (newval->value == BOND_MODE_ALB)
 		bond->params.tlb_dynamic_lb = 1;
 
+#ifdef CONFIG_XFRM_OFFLOAD
+	if (newval->value == BOND_MODE_ACTIVEBACKUP)
+		bond->dev->wanted_features |= BOND_XFRM_FEATURES;
+	else
+		bond->dev->wanted_features &= ~BOND_XFRM_FEATURES;
+	netdev_change_features(bond->dev);
+#endif /* CONFIG_XFRM_OFFLOAD */
+
 	/* don't cache arp_validate between modes */
 	bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
 	bond->params.mode = newval->value;
diff --git a/include/net/bonding.h b/include/net/bonding.h
index 1c34be3c01a1..917e06636040 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -86,6 +86,11 @@
 #define bond_for_each_slave_rcu(bond, pos, iter) \
 	netdev_for_each_lower_private_rcu((bond)->dev, pos, iter)
 
+#ifdef CONFIG_XFRM_OFFLOAD
+#define BOND_XFRM_FEATURES (NETIF_F_HW_ESP | NETIF_F_HW_ESP_TX_CSUM | \
+			    NETIF_F_GSO_ESP)
+#endif /* CONFIG_XFRM_OFFLOAD */
+
 #ifdef CONFIG_NET_POLL_CONTROLLER
 extern atomic_t netpoll_block_tx;
 
