fold struct fs_parameter_enum into struct constant_table

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 5eede625297f4d21dc12ea7a7418fd21672f131d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/5eede625.failed

no real difference now

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 5eede625297f4d21dc12ea7a7418fd21672f131d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/afs/super.c
#	fs/ceph/super.c
#	fs/fs_parser.c
#	fs/gfs2/ops_fstype.c
#	fs/jffs2/super.c
#	fs/nfs/fs_context.c
#	include/linux/fs_parser.h
#	mm/shmem.c
diff --cc fs/afs/super.c
index 44f8cce1c926,8d71d10761b7..000000000000
--- a/fs/afs/super.c
+++ b/fs/afs/super.c
@@@ -63,22 -66,32 +63,44 @@@ static const struct super_operations af
  static struct kmem_cache *afs_inode_cachep;
  static atomic_t afs_count_active_inodes;
  
 -enum afs_param {
 -	Opt_autocell,
 -	Opt_dyn,
 -	Opt_flock,
 -	Opt_source,
 +enum {
 +	afs_no_opt,
 +	afs_opt_cell,
 +	afs_opt_dyn,
 +	afs_opt_rwpath,
 +	afs_opt_vol,
 +	afs_opt_autocell,
  };
  
++<<<<<<< HEAD
 +static const match_table_t afs_options_list = {
 +	{ afs_opt_cell,		"cell=%s"	},
 +	{ afs_opt_dyn,		"dyn"		},
 +	{ afs_opt_rwpath,	"rwpath"	},
 +	{ afs_opt_vol,		"vol=%s"	},
 +	{ afs_opt_autocell,	"autocell"	},
 +	{ afs_no_opt,		NULL		},
++=======
+ static const struct constant_table afs_param_flock[] = {
+ 	{"local",	afs_flock_mode_local },
+ 	{"openafs",	afs_flock_mode_openafs },
+ 	{"strict",	afs_flock_mode_strict },
+ 	{"write",	afs_flock_mode_write },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec afs_param_specs[] = {
+ 	fsparam_flag  ("autocell",	Opt_autocell),
+ 	fsparam_flag  ("dyn",		Opt_dyn),
+ 	fsparam_enum  ("flock",		Opt_flock, afs_param_flock),
+ 	fsparam_string("source",	Opt_source),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description afs_fs_parameters = {
+ 	.name		= "kAFS",
+ 	.specs		= afs_param_specs,
++>>>>>>> 5eede625297f (fold struct fs_parameter_enum into struct constant_table)
  };
  
  /*
diff --cc fs/ceph/super.c
index f940cf50b7f6,2bad9bc1fd70..000000000000
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@@ -140,107 -142,141 +140,166 @@@ enum 
  	/* int args above */
  	Opt_snapdirname,
  	Opt_mds_namespace,
 +	Opt_fscache_uniq,
  	Opt_recover_session,
 -	Opt_source,
 +	Opt_last_string,
  	/* string args above */
  	Opt_dirstat,
 +	Opt_nodirstat,
  	Opt_rbytes,
 +	Opt_norbytes,
  	Opt_asyncreaddir,
 +	Opt_noasyncreaddir,
  	Opt_dcache,
 +	Opt_nodcache,
  	Opt_ino32,
 +	Opt_noino32,
  	Opt_fscache,
 +	Opt_nofscache,
  	Opt_poolperm,
 +	Opt_nopoolperm,
  	Opt_require_active_mds,
 +	Opt_norequire_active_mds,
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
  	Opt_acl,
 +#endif
 +	Opt_noacl,
  	Opt_quotadf,
 +	Opt_noquotadf,
  	Opt_copyfrom,
 +	Opt_nocopyfrom,
 +	Opt_wsync,
 +	Opt_nowsync,
  };
  
 -enum ceph_recover_session_mode {
 -	ceph_recover_session_no,
 -	ceph_recover_session_clean
 +static match_table_t fsopt_tokens = {
 +	{Opt_wsize, "wsize=%d"},
 +	{Opt_rsize, "rsize=%d"},
 +	{Opt_rasize, "rasize=%d"},
 +	{Opt_caps_wanted_delay_min, "caps_wanted_delay_min=%d"},
 +	{Opt_caps_wanted_delay_max, "caps_wanted_delay_max=%d"},
 +	{Opt_caps_max, "caps_max=%d"},
 +	{Opt_readdir_max_entries, "readdir_max_entries=%d"},
 +	{Opt_readdir_max_bytes, "readdir_max_bytes=%d"},
 +	{Opt_congestion_kb, "write_congestion_kb=%d"},
 +	/* int args above */
 +	{Opt_snapdirname, "snapdirname=%s"},
 +	{Opt_mds_namespace, "mds_namespace=%s"},
 +	{Opt_recover_session, "recover_session=%s"},
 +	{Opt_fscache_uniq, "fsc=%s"},
 +	/* string args above */
 +	{Opt_dirstat, "dirstat"},
 +	{Opt_nodirstat, "nodirstat"},
 +	{Opt_rbytes, "rbytes"},
 +	{Opt_norbytes, "norbytes"},
 +	{Opt_asyncreaddir, "asyncreaddir"},
 +	{Opt_noasyncreaddir, "noasyncreaddir"},
 +	{Opt_dcache, "dcache"},
 +	{Opt_nodcache, "nodcache"},
 +	{Opt_ino32, "ino32"},
 +	{Opt_noino32, "noino32"},
 +	{Opt_fscache, "fsc"},
 +	{Opt_nofscache, "nofsc"},
 +	{Opt_poolperm, "poolperm"},
 +	{Opt_nopoolperm, "nopoolperm"},
 +	{Opt_require_active_mds, "require_active_mds"},
 +	{Opt_norequire_active_mds, "norequire_active_mds"},
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
 +	{Opt_acl, "acl"},
 +#endif
 +	{Opt_noacl, "noacl"},
 +	{Opt_quotadf, "quotadf"},
 +	{Opt_noquotadf, "noquotadf"},
 +	{Opt_copyfrom, "copyfrom"},
 +	{Opt_nocopyfrom, "nocopyfrom"},
 +	{Opt_wsync, "wsync"},
 +	{Opt_nowsync, "nowsync"},
 +	{-1, NULL}
  };
  
++<<<<<<< HEAD
 +static int parse_fsopt_token(char *c, void *private)
++=======
+ static const struct constant_table ceph_param_recover[] = {
+ 	{ "no",		ceph_recover_session_no },
+ 	{ "clean",	ceph_recover_session_clean },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec ceph_mount_param_specs[] = {
+ 	fsparam_flag_no ("acl",				Opt_acl),
+ 	fsparam_flag_no ("asyncreaddir",		Opt_asyncreaddir),
+ 	fsparam_s32	("caps_max",			Opt_caps_max),
+ 	fsparam_u32	("caps_wanted_delay_max",	Opt_caps_wanted_delay_max),
+ 	fsparam_u32	("caps_wanted_delay_min",	Opt_caps_wanted_delay_min),
+ 	fsparam_u32	("write_congestion_kb",		Opt_congestion_kb),
+ 	fsparam_flag_no ("copyfrom",			Opt_copyfrom),
+ 	fsparam_flag_no ("dcache",			Opt_dcache),
+ 	fsparam_flag_no ("dirstat",			Opt_dirstat),
+ 	__fsparam	(fs_param_is_string, "fsc",	Opt_fscache,
+ 			 fs_param_neg_with_no | fs_param_v_optional, NULL),
+ 	fsparam_flag_no ("ino32",			Opt_ino32),
+ 	fsparam_string	("mds_namespace",		Opt_mds_namespace),
+ 	fsparam_flag_no ("poolperm",			Opt_poolperm),
+ 	fsparam_flag_no ("quotadf",			Opt_quotadf),
+ 	fsparam_u32	("rasize",			Opt_rasize),
+ 	fsparam_flag_no ("rbytes",			Opt_rbytes),
+ 	fsparam_u32	("readdir_max_bytes",		Opt_readdir_max_bytes),
+ 	fsparam_u32	("readdir_max_entries",		Opt_readdir_max_entries),
+ 	fsparam_enum	("recover_session",		Opt_recover_session, ceph_param_recover),
+ 	fsparam_flag_no ("require_active_mds",		Opt_require_active_mds),
+ 	fsparam_u32	("rsize",			Opt_rsize),
+ 	fsparam_string	("snapdirname",			Opt_snapdirname),
+ 	fsparam_string	("source",			Opt_source),
+ 	fsparam_u32	("wsize",			Opt_wsize),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description ceph_mount_parameters = {
+ 	.name           = "ceph",
+ 	.specs          = ceph_mount_param_specs,
+ };
+ 
+ struct ceph_parse_opts_ctx {
+ 	struct ceph_options		*copts;
+ 	struct ceph_mount_options	*opts;
+ };
+ 
+ /*
+  * Parse the source parameter.  Distinguish the server list from the path.
+  * Internally we do not include the leading '/' in the path.
+  *
+  * The source will look like:
+  *     <server_spec>[,<server_spec>...]:[<path>]
+  * where
+  *     <server_spec> is <ip>[:<port>]
+  *     <path> is optional, but if present must begin with '/'
+  */
+ static int ceph_parse_source(struct fs_parameter *param, struct fs_context *fc)
++>>>>>>> 5eede625297f (fold struct fs_parameter_enum into struct constant_table)
  {
 -	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
 -	struct ceph_mount_options *fsopt = pctx->opts;
 -	char *dev_name = param->string, *dev_name_end;
 -	int ret;
 +	struct ceph_mount_options *fsopt = private;
 +	substring_t argstr[MAX_OPT_ARGS];
 +	int token, intval, ret;
  
 -	dout("%s '%s'\n", __func__, dev_name);
 -	if (!dev_name || !*dev_name)
 -		return invalf(fc, "ceph: Empty source");
 +	token = match_token((char *)c, fsopt_tokens, argstr);
 +	if (token < 0)
 +		return -EINVAL;
  
 -	dev_name_end = strchr(dev_name, '/');
 -	if (dev_name_end) {
 -		if (strlen(dev_name_end) > 1) {
 -			kfree(fsopt->server_path);
 -			fsopt->server_path = kstrdup(dev_name_end, GFP_KERNEL);
 -			if (!fsopt->server_path)
 -				return -ENOMEM;
 +	if (token < Opt_last_int) {
 +		ret = match_int(&argstr[0], &intval);
 +		if (ret < 0) {
 +			pr_err("bad option arg (not int) at '%s'\n", c);
 +			return ret;
  		}
 +		dout("got int token %d val %d\n", token, intval);
 +	} else if (token > Opt_last_int && token < Opt_last_string) {
 +		dout("got string token %d val %s\n", token,
 +		     argstr[0].from);
  	} else {
 -		dev_name_end = dev_name + strlen(dev_name);
 +		dout("got token %d\n", token);
  	}
  
 -	dev_name_end--;		/* back up to ':' separator */
 -	if (dev_name_end < dev_name || *dev_name_end != ':')
 -		return invalf(fc, "ceph: No path or : separator in source");
 -
 -	dout("device name '%.*s'\n", (int)(dev_name_end - dev_name), dev_name);
 -	if (fsopt->server_path)
 -		dout("server path '%s'\n", fsopt->server_path);
 -
 -	ret = ceph_parse_mon_ips(param->string, dev_name_end - dev_name,
 -				 pctx->copts, fc);
 -	if (ret)
 -		return ret;
 -
 -	fc->source = param->string;
 -	param->string = NULL;
 -	return 0;
 -}
 -
 -static int ceph_parse_mount_param(struct fs_context *fc,
 -				  struct fs_parameter *param)
 -{
 -	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
 -	struct ceph_mount_options *fsopt = pctx->opts;
 -	struct fs_parse_result result;
 -	unsigned int mode;
 -	int token, ret;
 -
 -	ret = ceph_parse_param(param, pctx->copts, fc);
 -	if (ret != -ENOPARAM)
 -		return ret;
 -
 -	token = fs_parse(fc, &ceph_mount_parameters, param, &result);
 -	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
 -	if (token < 0)
 -		return token;
 -
  	switch (token) {
  	case Opt_snapdirname:
  		kfree(fsopt->snapdir_name);
diff --cc fs/gfs2/ops_fstype.c
index f4de5fcbc3c8,16230e496fdb..000000000000
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@@ -1240,6 -1271,13 +1240,16 @@@ enum opt_quota 
  	Opt_quota_on,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct constant_table gfs2_param_quota[] = {
+ 	{"off",        Opt_quota_off },
+ 	{"account",    Opt_quota_account },
+ 	{"on",         Opt_quota_on },
+ 	{}
+ };
+ 
++>>>>>>> 5eede625297f (fold struct fs_parameter_enum into struct constant_table)
  static const unsigned int opt_quota_values[] = {
  	[Opt_quota_off]     = GFS2_QUOTA_OFF,
  	[Opt_quota_account] = GFS2_QUOTA_ACCOUNT,
@@@ -1251,11 -1289,23 +1261,29 @@@ enum opt_data 
  	Opt_data_ordered   = GFS2_DATA_ORDERED,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct constant_table gfs2_param_data[] = {
+ 	{"writeback",  Opt_data_writeback },
+ 	{"ordered",    Opt_data_ordered },
+ 	{}
+ };
+ 
++>>>>>>> 5eede625297f (fold struct fs_parameter_enum into struct constant_table)
  enum opt_errors {
  	Opt_errors_withdraw = GFS2_ERRORS_WITHDRAW,
  	Opt_errors_panic    = GFS2_ERRORS_PANIC,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct constant_table gfs2_param_errors[] = {
+ 	{"withdraw",   Opt_errors_withdraw },
+ 	{"panic",      Opt_errors_panic },
+ 	{}
+ };
+ 
++>>>>>>> 5eede625297f (fold struct fs_parameter_enum into struct constant_table)
  static const struct fs_parameter_spec gfs2_param_specs[] = {
  	fsparam_string ("lockproto",          Opt_lockproto),
  	fsparam_string ("locktable",          Opt_locktable),
diff --cc fs/jffs2/super.c
index 87bdf0f4cba1,1e54f736865d..000000000000
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@@ -166,73 -165,56 +166,78 @@@ static const struct export_operations j
  enum {
  	Opt_override_compr,
  	Opt_rp_size,
 +	Opt_err,
  };
  
++<<<<<<< HEAD
 +static const match_table_t tokens = {
 +	{Opt_override_compr, "compr=%s"},
 +	{Opt_rp_size, "rp_size=%u"},
 +	{Opt_err, NULL},
 +};
 +
 +static int jffs2_parse_options(struct jffs2_sb_info *c, char *data)
 +{
 +	substring_t args[MAX_OPT_ARGS];
 +	char *p, *name;
 +	unsigned int opt;
 +
 +	if (!data)
 +		return 0;
 +
 +	while ((p = strsep(&data, ","))) {
 +		int token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_override_compr:
 +			name = match_strdup(&args[0]);
 +
 +			if (!name)
 +				return -ENOMEM;
 +			if (!strcmp(name, "none"))
 +				c->mount_opts.compr = JFFS2_COMPR_MODE_NONE;
++=======
+ static const struct constant_table jffs2_param_compr[] = {
+ 	{"none",	JFFS2_COMPR_MODE_NONE },
++>>>>>>> 5eede625297f (fold struct fs_parameter_enum into struct constant_table)
  #ifdef CONFIG_JFFS2_LZO
 -	{"lzo",		JFFS2_COMPR_MODE_FORCELZO },
 +			else if (!strcmp(name, "lzo"))
 +				c->mount_opts.compr = JFFS2_COMPR_MODE_FORCELZO;
  #endif
  #ifdef CONFIG_JFFS2_ZLIB
 -	{"zlib",	JFFS2_COMPR_MODE_FORCEZLIB },
 +			else if (!strcmp(name, "zlib"))
 +				c->mount_opts.compr =
 +						JFFS2_COMPR_MODE_FORCEZLIB;
  #endif
 -	{}
 -};
 -
 -static const struct fs_parameter_spec jffs2_param_specs[] = {
 -	fsparam_enum	("compr",	Opt_override_compr, jffs2_param_compr),
 -	fsparam_u32	("rp_size",	Opt_rp_size),
 -	{}
 -};
 -
 -const struct fs_parameter_description jffs2_fs_parameters = {
 -	.name		= "jffs2",
 -	.specs		= jffs2_param_specs,
 -};
 -
 -static int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)
 -{
 -	struct fs_parse_result result;
 -	struct jffs2_sb_info *c = fc->s_fs_info;
 -	int opt;
 -
 -	opt = fs_parse(fc, &jffs2_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case Opt_override_compr:
 -		c->mount_opts.compr = result.uint_32;
 -		c->mount_opts.override_compr = true;
 -		break;
 -	case Opt_rp_size:
 -		if (result.uint_32 > UINT_MAX / 1024)
 -			return invalf(fc, "jffs2: rp_size unrepresentable");
 -		opt = result.uint_32 * 1024;
 -		if (opt > c->mtd->size)
 -			return invalf(fc, "jffs2: Too large reserve pool specified, max is %llu KB",
 -				      c->mtd->size / 1024);
 -		c->mount_opts.rp_size = opt;
 -		break;
 -	default:
 -		return -EINVAL;
 +			else {
 +				pr_err("Error: unknown compressor \"%s\"\n",
 +				       name);
 +				kfree(name);
 +				return -EINVAL;
 +			}
 +			kfree(name);
 +			c->mount_opts.override_compr = true;
 +			break;
 +		case Opt_rp_size:
 +			if (match_int(&args[0], &opt))
 +				return -EINVAL;
 +			opt *= 1024;
 +			if (opt > c->mtd->size) {
 +				pr_warn("Too large reserve pool specified, max "
 +					"is %llu KB\n", c->mtd->size / 1024);
 +				return -EINVAL;
 +			}
 +			c->mount_opts.rp_size = opt;
 +			break;
 +		default:
 +			pr_err("Error: unrecognized mount option '%s' or missing value\n",
 +			       p);
 +			return -EINVAL;
 +		}
  	}
  
  	return 0;
diff --cc mm/shmem.c
index 02e9c145ac0a,90c7737bcce2..000000000000
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@@ -3330,11 -3370,124 +3330,53 @@@ static const struct export_operations s
  	.fh_to_dentry	= shmem_fh_to_dentry,
  };
  
++<<<<<<< HEAD
 +static int shmem_parse_options(char *options, struct shmem_options *ctx)
++=======
+ enum shmem_param {
+ 	Opt_gid,
+ 	Opt_huge,
+ 	Opt_mode,
+ 	Opt_mpol,
+ 	Opt_nr_blocks,
+ 	Opt_nr_inodes,
+ 	Opt_size,
+ 	Opt_uid,
+ };
+ 
+ static const struct constant_table shmem_param_enums_huge[] = {
+ 	{"never",	SHMEM_HUGE_NEVER },
+ 	{"always",	SHMEM_HUGE_ALWAYS },
+ 	{"within_size",	SHMEM_HUGE_WITHIN_SIZE },
+ 	{"advise",	SHMEM_HUGE_ADVISE },
+ 	{"deny",	SHMEM_HUGE_DENY },
+ 	{"force",	SHMEM_HUGE_FORCE },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec shmem_param_specs[] = {
+ 	fsparam_u32   ("gid",		Opt_gid),
+ 	fsparam_enum  ("huge",		Opt_huge,  shmem_param_enums_huge),
+ 	fsparam_u32oct("mode",		Opt_mode),
+ 	fsparam_string("mpol",		Opt_mpol),
+ 	fsparam_string("nr_blocks",	Opt_nr_blocks),
+ 	fsparam_string("nr_inodes",	Opt_nr_inodes),
+ 	fsparam_string("size",		Opt_size),
+ 	fsparam_u32   ("uid",		Opt_uid),
+ 	{}
+ };
+ 
+ const struct fs_parameter_description shmem_fs_parameters = {
+ 	.name		= "tmpfs",
+ 	.specs		= shmem_param_specs,
+ };
+ 
+ static int shmem_parse_one(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 5eede625297f (fold struct fs_parameter_enum into struct constant_table)
  {
 -	struct shmem_options *ctx = fc->fs_private;
 -	struct fs_parse_result result;
 -	unsigned long long size;
 -	char *rest;
 -	int opt;
 -
 -	opt = fs_parse(fc, &shmem_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case Opt_size:
 -		size = memparse(param->string, &rest);
 -		if (*rest == '%') {
 -			size <<= PAGE_SHIFT;
 -			size *= totalram_pages();
 -			do_div(size, 100);
 -			rest++;
 -		}
 -		if (*rest)
 -			goto bad_value;
 -		ctx->blocks = DIV_ROUND_UP(size, PAGE_SIZE);
 -		ctx->seen |= SHMEM_SEEN_BLOCKS;
 -		break;
 -	case Opt_nr_blocks:
 -		ctx->blocks = memparse(param->string, &rest);
 -		if (*rest)
 -			goto bad_value;
 -		ctx->seen |= SHMEM_SEEN_BLOCKS;
 -		break;
 -	case Opt_nr_inodes:
 -		ctx->inodes = memparse(param->string, &rest);
 -		if (*rest)
 -			goto bad_value;
 -		ctx->seen |= SHMEM_SEEN_INODES;
 -		break;
 -	case Opt_mode:
 -		ctx->mode = result.uint_32 & 07777;
 -		break;
 -	case Opt_uid:
 -		ctx->uid = make_kuid(current_user_ns(), result.uint_32);
 -		if (!uid_valid(ctx->uid))
 -			goto bad_value;
 -		break;
 -	case Opt_gid:
 -		ctx->gid = make_kgid(current_user_ns(), result.uint_32);
 -		if (!gid_valid(ctx->gid))
 -			goto bad_value;
 -		break;
 -	case Opt_huge:
 -		ctx->huge = result.uint_32;
 -		if (ctx->huge != SHMEM_HUGE_NEVER &&
 -		    !(IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&
 -		      has_transparent_hugepage()))
 -			goto unsupported_parameter;
 -		ctx->seen |= SHMEM_SEEN_HUGE;
 -		break;
 -	case Opt_mpol:
 -		if (IS_ENABLED(CONFIG_NUMA)) {
 -			mpol_put(ctx->mpol);
 -			ctx->mpol = NULL;
 -			if (mpol_parse_str(param->string, &ctx->mpol))
 -				goto bad_value;
 -			break;
 -		}
 -		goto unsupported_parameter;
 -	}
 -	return 0;
 -
 -unsupported_parameter:
 -	return invalf(fc, "tmpfs: Unsupported parameter '%s'", param->key);
 -bad_value:
 -	return invalf(fc, "tmpfs: Bad value for '%s'", param->key);
 -}
 -
 -static int shmem_parse_options(struct fs_context *fc, void *data)
 -{
 -	char *options = data;
 +	char *this_char, *value, *rest;
 +	uid_t uid;
 +	gid_t gid;
  
  	if (options) {
  		int err = security_sb_eat_lsm_opts(options, &fc->security);
* Unmerged path fs/fs_parser.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path include/linux/fs_parser.h
* Unmerged path fs/afs/super.c
* Unmerged path fs/ceph/super.c
* Unmerged path fs/fs_parser.c
* Unmerged path fs/gfs2/ops_fstype.c
* Unmerged path fs/jffs2/super.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path include/linux/fs_parser.h
* Unmerged path mm/shmem.c
