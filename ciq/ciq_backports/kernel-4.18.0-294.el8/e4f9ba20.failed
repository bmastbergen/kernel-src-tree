fs/xfs: Update xfs_ioctl_setattr_dax_invalidate()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit e4f9ba20d3b8c2b86ec71f326882e1a3c4e47953
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/e4f9ba20.failed

Because of the separation of FS_XFLAG_DAX from S_DAX and the delayed
setting of S_DAX, data invalidation no longer needs to happen when
FS_XFLAG_DAX is changed.

Change xfs_ioctl_setattr_dax_invalidate() to be
xfs_ioctl_dax_check_set_cache() and alter the code to reflect the new
functionality.

Furthermore, we no longer need the locking so we remove the join_flags
logic.

	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit e4f9ba20d3b8c2b86ec71f326882e1a3c4e47953)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/xfs_ioctl.c
index 44d791730753,ff474f2c9acf..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1245,65 -1245,26 +1245,54 @@@ xfs_ioctl_setattr_xflags
  	return 0;
  }
  
- /*
-  * If we are changing DAX flags, we have to ensure the file is clean and any
-  * cached objects in the address space are invalidated and removed. This
-  * requires us to lock out other IO and page faults similar to a truncate
-  * operation. The locks need to be held until the transaction has been committed
-  * so that the cache invalidation is atomic with respect to the DAX flag
-  * manipulation.
-  */
- static int
- xfs_ioctl_setattr_dax_invalidate(
+ static void
+ xfs_ioctl_setattr_prepare_dax(
  	struct xfs_inode	*ip,
- 	struct fsxattr		*fa,
- 	int			*join_flags)
+ 	struct fsxattr		*fa)
  {
++<<<<<<< HEAD
 +	struct inode		*inode = VFS_I(ip);
 +	struct super_block	*sb = inode->i_sb;
 +	int			error;
 +
 +	*join_flags = 0;
 +
 +	/*
 +	 * It is only valid to set the DAX flag on regular files and
 +	 * directories on filesystems where the block size is equal to the page
 +	 * size. On directories it serves as an inherited hint so we don't
 +	 * have to check the device for dax support or flush pagecache.
 +	 */
 +	if (fa->fsx_xflags & FS_XFLAG_DAX) {
 +		if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
 +			return -EINVAL;
 +		if (!bdev_dax_supported(xfs_find_bdev_for_inode(VFS_I(ip)),
 +				sb->s_blocksize))
 +			return -EINVAL;
 +	}
 +
 +	/* If the DAX state is not changing, we have nothing to do here. */
 +	if ((fa->fsx_xflags & FS_XFLAG_DAX) && IS_DAX(inode))
 +		return 0;
 +	if (!(fa->fsx_xflags & FS_XFLAG_DAX) && !IS_DAX(inode))
 +		return 0;
++=======
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct inode            *inode = VFS_I(ip);
++>>>>>>> e4f9ba20d3b8 (fs/xfs: Update xfs_ioctl_setattr_dax_invalidate())
  
  	if (S_ISDIR(inode->i_mode))
- 		return 0;
+ 		return;
  
- 	/* lock, flush and invalidate mapping in preparation for flag change */
- 	xfs_ilock(ip, XFS_MMAPLOCK_EXCL | XFS_IOLOCK_EXCL);
- 	error = filemap_write_and_wait(inode->i_mapping);
- 	if (error)
- 		goto out_unlock;
- 	error = invalidate_inode_pages2(inode->i_mapping);
- 	if (error)
- 		goto out_unlock;
- 
- 	*join_flags = XFS_MMAPLOCK_EXCL | XFS_IOLOCK_EXCL;
- 	return 0;
- 
- out_unlock:
- 	xfs_iunlock(ip, XFS_MMAPLOCK_EXCL | XFS_IOLOCK_EXCL);
- 	return error;
+ 	if ((mp->m_flags & XFS_MOUNT_DAX_ALWAYS) ||
+ 	    (mp->m_flags & XFS_MOUNT_DAX_NEVER))
+ 		return;
  
+ 	if (((fa->fsx_xflags & FS_XFLAG_DAX) &&
+ 	    !(ip->i_d.di_flags2 & XFS_DIFLAG2_DAX)) ||
+ 	    (!(fa->fsx_xflags & FS_XFLAG_DAX) &&
+ 	     (ip->i_d.di_flags2 & XFS_DIFLAG2_DAX)))
+ 		d_mark_dontcache(inode);
  }
  
  /*
@@@ -1674,8 -1591,8 +1643,7 @@@ xfs_ioc_setxflags
  {
  	struct xfs_trans	*tp;
  	struct fsxattr		fa;
 -	struct fsxattr		old_fa;
  	unsigned int		flags;
- 	int			join_flags = 0;
  	int			error;
  
  	if (copy_from_user(&flags, arg, sizeof(flags)))
* Unmerged path fs/xfs/xfs_ioctl.c
