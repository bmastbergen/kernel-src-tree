teach move_mount(2) to work with OPEN_TREE_CLONE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 44dfd84a6d54a675e35ab618d9fab47b36cb78cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/44dfd84a.failed

Allow a detached tree created by open_tree(..., OPEN_TREE_CLONE) to be
attached by move_mount(2).

If by the time of final fput() of OPEN_TREE_CLONE-opened file its tree is
not detached anymore, it won't be dissolved.  move_mount(2) is adjusted
to handle detached source.

That gives us equivalents of mount --bind and mount --rbind.

Thanks also to Alan Jenkins <alan.christopher.jenkins@gmail.com> for
providing a whole bunch of ways to break things using this interface.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 44dfd84a6d54a675e35ab618d9fab47b36cb78cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index f136970f49f7,1e72d19fa4f8..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1754,6 -1833,27 +1754,30 @@@ struct vfsmount *collect_mounts(const s
  	return &tree->mnt;
  }
  
++<<<<<<< HEAD
++=======
+ static void free_mnt_ns(struct mnt_namespace *);
+ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *, bool);
+ 
+ void dissolve_on_fput(struct vfsmount *mnt)
+ {
+ 	struct mnt_namespace *ns;
+ 	namespace_lock();
+ 	lock_mount_hash();
+ 	ns = real_mount(mnt)->mnt_ns;
+ 	if (ns) {
+ 		if (is_anon_ns(ns))
+ 			umount_tree(real_mount(mnt), UMOUNT_CONNECTED);
+ 		else
+ 			ns = NULL;
+ 	}
+ 	unlock_mount_hash();
+ 	namespace_unlock();
+ 	if (ns)
+ 		free_mnt_ns(ns);
+ }
+ 
++>>>>>>> 44dfd84a6d54 (teach move_mount(2) to work with OPEN_TREE_CLONE)
  void drop_collected_mounts(struct vfsmount *mnt)
  {
  	namespace_lock();
@@@ -2351,72 -2549,117 +2379,160 @@@ static inline int tree_contains_unbinda
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int do_move_mount(struct path *path, const char *old_name)
 +{
 +	struct path old_path, parent_path;
++=======
+ /*
+  * Check that there aren't references to earlier/same mount namespaces in the
+  * specified subtree.  Such references can act as pins for mount namespaces
+  * that aren't checked by the mount-cycle checking code, thereby allowing
+  * cycles to be made.
+  */
+ static bool check_for_nsfs_mounts(struct mount *subtree)
+ {
+ 	struct mount *p;
+ 	bool ret = false;
+ 
+ 	lock_mount_hash();
+ 	for (p = subtree; p; p = next_mnt(p, subtree))
+ 		if (mnt_ns_loop(p->mnt.mnt_root))
+ 			goto out;
+ 
+ 	ret = true;
+ out:
+ 	unlock_mount_hash();
+ 	return ret;
+ }
+ 
+ static int do_move_mount(struct path *old_path, struct path *new_path)
+ {
+ 	struct path parent_path = {.mnt = NULL, .dentry = NULL};
+ 	struct mnt_namespace *ns;
++>>>>>>> 44dfd84a6d54 (teach move_mount(2) to work with OPEN_TREE_CLONE)
  	struct mount *p;
  	struct mount *old;
  	struct mountpoint *mp;
  	int err;
++<<<<<<< HEAD
 +	if (!old_name || !*old_name)
 +		return -EINVAL;
 +	err = kern_path(old_name, LOOKUP_FOLLOW, &old_path);
 +	if (err)
 +		return err;
++=======
+ 	bool attached;
++>>>>>>> 44dfd84a6d54 (teach move_mount(2) to work with OPEN_TREE_CLONE)
  
 -	mp = lock_mount(new_path);
 +	mp = lock_mount(path);
 +	err = PTR_ERR(mp);
  	if (IS_ERR(mp))
 -		return PTR_ERR(mp);
 +		goto out;
  
++<<<<<<< HEAD
 +	old = real_mount(old_path.mnt);
 +	p = real_mount(path->mnt);
 +
 +	err = -EINVAL;
 +	if (!check_mnt(p) || !check_mnt(old))
 +		goto out1;
++=======
+ 	old = real_mount(old_path->mnt);
+ 	p = real_mount(new_path->mnt);
+ 	attached = mnt_has_parent(old);
+ 	ns = old->mnt_ns;
+ 
+ 	err = -EINVAL;
+ 	/* The mountpoint must be in our namespace. */
+ 	if (!check_mnt(p))
+ 		goto out;
+ 
+ 	/* The thing moved should be either ours or completely unattached. */
+ 	if (attached && !check_mnt(old))
+ 		goto out;
+ 
+ 	if (!attached && !is_anon_ns(ns))
+ 		goto out;
++>>>>>>> 44dfd84a6d54 (teach move_mount(2) to work with OPEN_TREE_CLONE)
  
  	if (old->mnt.mnt_flags & MNT_LOCKED)
 -		goto out;
 +		goto out1;
  
 -	if (old_path->dentry != old_path->mnt->mnt_root)
 -		goto out;
 +	err = -EINVAL;
 +	if (old_path.dentry != old_path.mnt->mnt_root)
 +		goto out1;
  
 -	if (d_is_dir(new_path->dentry) !=
 -	    d_is_dir(old_path->dentry))
 -		goto out;
 +	if (!mnt_has_parent(old))
 +		goto out1;
 +
 +	if (d_is_dir(path->dentry) !=
 +	      d_is_dir(old_path.dentry))
 +		goto out1;
  	/*
  	 * Don't move a mount residing in a shared parent.
  	 */
++<<<<<<< HEAD
 +	if (IS_MNT_SHARED(old->mnt_parent))
 +		goto out1;
++=======
+ 	if (attached && IS_MNT_SHARED(old->mnt_parent))
+ 		goto out;
++>>>>>>> 44dfd84a6d54 (teach move_mount(2) to work with OPEN_TREE_CLONE)
  	/*
  	 * Don't move a mount tree containing unbindable mounts to a destination
  	 * mount which is shared.
  	 */
  	if (IS_MNT_SHARED(p) && tree_contains_unbindable(old))
 -		goto out;
 +		goto out1;
  	err = -ELOOP;
+ 	if (!check_for_nsfs_mounts(old))
+ 		goto out;
  	for (; mnt_has_parent(p); p = p->mnt_parent)
  		if (p == old)
 -			goto out;
 +			goto out1;
  
++<<<<<<< HEAD
 +	err = attach_recursive_mnt(old, real_mount(path->mnt), mp, &parent_path);
++=======
+ 	err = attach_recursive_mnt(old, real_mount(new_path->mnt), mp,
+ 				   attached ? &parent_path : NULL);
++>>>>>>> 44dfd84a6d54 (teach move_mount(2) to work with OPEN_TREE_CLONE)
  	if (err)
 -		goto out;
 +		goto out1;
  
  	/* if the mount is moved, it should no longer be expire
  	 * automatically */
  	list_del_init(&old->mnt_expire);
 -out:
 +out1:
  	unlock_mount(mp);
++<<<<<<< HEAD
 +out:
 +	if (!err)
 +		path_put(&parent_path);
++=======
+ 	if (!err) {
+ 		path_put(&parent_path);
+ 		if (!attached)
+ 			free_mnt_ns(ns);
+ 	}
+ 	return err;
+ }
+ 
+ static int do_move_mount_old(struct path *path, const char *old_name)
+ {
+ 	struct path old_path;
+ 	int err;
+ 
+ 	if (!old_name || !*old_name)
+ 		return -EINVAL;
+ 
+ 	err = kern_path(old_name, LOOKUP_FOLLOW, &old_path);
+ 	if (err)
+ 		return err;
+ 
+ 	err = do_move_mount(&old_path, path);
++>>>>>>> 44dfd84a6d54 (teach move_mount(2) to work with OPEN_TREE_CLONE)
  	path_put(&old_path);
  	return err;
  }
@@@ -3094,6 -3334,63 +3210,66 @@@ SYSCALL_DEFINE5(mount, char __user *, d
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Move a mount from one place to another.
+  * In combination with open_tree(OPEN_TREE_CLONE [| AT_RECURSIVE]) it can be
+  * used to copy a mount subtree.
+  *
+  * Note the flags value is a combination of MOVE_MOUNT_* flags.
+  */
+ SYSCALL_DEFINE5(move_mount,
+ 		int, from_dfd, const char *, from_pathname,
+ 		int, to_dfd, const char *, to_pathname,
+ 		unsigned int, flags)
+ {
+ 	struct path from_path, to_path;
+ 	unsigned int lflags;
+ 	int ret = 0;
+ 
+ 	if (!may_mount())
+ 		return -EPERM;
+ 
+ 	if (flags & ~MOVE_MOUNT__MASK)
+ 		return -EINVAL;
+ 
+ 	/* If someone gives a pathname, they aren't permitted to move
+ 	 * from an fd that requires unmount as we can't get at the flag
+ 	 * to clear it afterwards.
+ 	 */
+ 	lflags = 0;
+ 	if (flags & MOVE_MOUNT_F_SYMLINKS)	lflags |= LOOKUP_FOLLOW;
+ 	if (flags & MOVE_MOUNT_F_AUTOMOUNTS)	lflags |= LOOKUP_AUTOMOUNT;
+ 	if (flags & MOVE_MOUNT_F_EMPTY_PATH)	lflags |= LOOKUP_EMPTY;
+ 
+ 	ret = user_path_at(from_dfd, from_pathname, lflags, &from_path);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	lflags = 0;
+ 	if (flags & MOVE_MOUNT_T_SYMLINKS)	lflags |= LOOKUP_FOLLOW;
+ 	if (flags & MOVE_MOUNT_T_AUTOMOUNTS)	lflags |= LOOKUP_AUTOMOUNT;
+ 	if (flags & MOVE_MOUNT_T_EMPTY_PATH)	lflags |= LOOKUP_EMPTY;
+ 
+ 	ret = user_path_at(to_dfd, to_pathname, lflags, &to_path);
+ 	if (ret < 0)
+ 		goto out_from;
+ 
+ 	ret = security_move_mount(&from_path, &to_path);
+ 	if (ret < 0)
+ 		goto out_to;
+ 
+ 	ret = do_move_mount(&from_path, &to_path);
+ 
+ out_to:
+ 	path_put(&to_path);
+ out_from:
+ 	path_put(&from_path);
+ 	return ret;
+ }
+ 
+ /*
++>>>>>>> 44dfd84a6d54 (teach move_mount(2) to work with OPEN_TREE_CLONE)
   * Return true if path is reachable from root
   *
   * namespace_sem or mount_lock is held
* Unmerged path fs/namespace.c
