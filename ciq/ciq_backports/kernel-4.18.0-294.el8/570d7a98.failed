vfs: move_mount: reject moving kernel internal mounts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Eric Biggers <ebiggers@google.com>
commit 570d7a98e7d6d5d8706d94ffd2d40adeaa318332
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/570d7a98.failed

sys_move_mount() crashes by dereferencing the pointer MNT_NS_INTERNAL,
a.k.a. ERR_PTR(-EINVAL), if the old mount is specified by fd for a
kernel object with an internal mount, such as a pipe or memfd.

Fix it by checking for this case and returning -EINVAL.

[AV: what we want is is_mounted(); use that instead of making the
condition even more convoluted]

Reproducer:

    #include <unistd.h>

    #define __NR_move_mount         429
    #define MOVE_MOUNT_F_EMPTY_PATH 0x00000004

    int main()
    {
    	int fds[2];

    	pipe(fds);
        syscall(__NR_move_mount, fds[0], "", -1, "/", MOVE_MOUNT_F_EMPTY_PATH);
    }

	Reported-by: syzbot+6004acbaa1893ad013f0@syzkaller.appspotmail.com
Fixes: 2db154b3ea8e ("vfs: syscall: Add move_mount(2) to move mounts around")
	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 570d7a98e7d6d5d8706d94ffd2d40adeaa318332)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 59ab93b3ffc7,6fbc9126367a..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -2359,37 -2580,39 +2359,51 @@@ static int do_move_mount(struct path *p
  	struct mount *old;
  	struct mountpoint *mp;
  	int err;
 -	bool attached;
 +	if (!old_name || !*old_name)
 +		return -EINVAL;
 +	err = kern_path(old_name, LOOKUP_FOLLOW, &old_path);
 +	if (err)
 +		return err;
  
 -	mp = lock_mount(new_path);
 +	mp = lock_mount(path);
 +	err = PTR_ERR(mp);
  	if (IS_ERR(mp))
 -		return PTR_ERR(mp);
 +		goto out;
  
 -	old = real_mount(old_path->mnt);
 -	p = real_mount(new_path->mnt);
 -	attached = mnt_has_parent(old);
 -	ns = old->mnt_ns;
 +	old = real_mount(old_path.mnt);
 +	p = real_mount(path->mnt);
  
  	err = -EINVAL;
++<<<<<<< HEAD
 +	if (!check_mnt(p) || !check_mnt(old))
 +		goto out1;
++=======
+ 	/* The mountpoint must be in our namespace. */
+ 	if (!check_mnt(p))
+ 		goto out;
+ 
+ 	/* The thing moved must be mounted... */
+ 	if (!is_mounted(&old->mnt))
+ 		goto out;
+ 
+ 	/* ... and either ours or the root of anon namespace */
+ 	if (!(attached ? check_mnt(old) : is_anon_ns(ns)))
+ 		goto out;
++>>>>>>> 570d7a98e7d6 (vfs: move_mount: reject moving kernel internal mounts)
  
  	if (old->mnt.mnt_flags & MNT_LOCKED)
 -		goto out;
 +		goto out1;
  
 -	if (old_path->dentry != old_path->mnt->mnt_root)
 -		goto out;
 +	err = -EINVAL;
 +	if (old_path.dentry != old_path.mnt->mnt_root)
 +		goto out1;
  
 -	if (d_is_dir(new_path->dentry) !=
 -	    d_is_dir(old_path->dentry))
 -		goto out;
 +	if (!mnt_has_parent(old))
 +		goto out1;
 +
 +	if (d_is_dir(path->dentry) !=
 +	      d_is_dir(old_path.dentry))
 +		goto out1;
  	/*
  	 * Don't move a mount residing in a shared parent.
  	 */
* Unmerged path fs/namespace.c
