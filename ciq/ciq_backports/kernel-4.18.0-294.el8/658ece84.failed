KVM: VMX: Rename vcpu_vmx's "guest_msrs_ready" to "guest_uret_msrs_loaded"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 658ece84f5da1cd8e36f0d13449aa95c61667b4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/658ece84.failed

Add "uret" to "guest_msrs_ready" to explicitly associate it with the
"guest_uret_msrs" array, and replace "ready" with "loaded" to more
precisely reflect what it tracks, e.g. "ready" could be interpreted as
meaning ready for processing (setup_msrs() has run), which is wrong.
"loaded" also aligns with the similar "guest_state_loaded" field.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200923180409.32255-8-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 658ece84f5da1cd8e36f0d13449aa95c61667b4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/vmx/vmx.h
diff --cc arch/x86/kvm/vmx/vmx.c
index 985a4bfb7517,252cce60af70..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -1146,12 -1134,12 +1146,21 @@@ void vmx_prepare_switch_to_guest(struc
  	 * when guest state is loaded. This happens when guest transitions
  	 * to/from long-mode by setting MSR_EFER.LMA.
  	 */
++<<<<<<< HEAD
 +	if (!vmx->guest_msrs_ready) {
 +		vmx->guest_msrs_ready = true;
 +		for (i = 0; i < vmx->save_nmsrs; ++i)
 +			kvm_set_user_return_msr(vmx->guest_msrs[i].index,
 +						vmx->guest_msrs[i].data,
 +						vmx->guest_msrs[i].mask);
++=======
+ 	if (!vmx->guest_uret_msrs_loaded) {
+ 		vmx->guest_uret_msrs_loaded = true;
+ 		for (i = 0; i < vmx->nr_active_uret_msrs; ++i)
+ 			kvm_set_user_return_msr(vmx->guest_uret_msrs[i].index,
+ 						vmx->guest_uret_msrs[i].data,
+ 						vmx->guest_uret_msrs[i].mask);
++>>>>>>> 658ece84f5da (KVM: VMX: Rename vcpu_vmx's "guest_msrs_ready" to "guest_uret_msrs_loaded")
  
  	}
  
@@@ -1657,16 -1650,16 +1666,21 @@@ static void setup_msrs(struct vcpu_vmx 
  #endif
  	index = __find_msr_index(vmx, MSR_EFER);
  	if (index >= 0 && update_transition_efer(vmx, index))
 -		move_msr_up(vmx, index, nr_active_uret_msrs++);
 +		move_msr_up(vmx, index, save_nmsrs++);
  	index = __find_msr_index(vmx, MSR_TSC_AUX);
  	if (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))
 -		move_msr_up(vmx, index, nr_active_uret_msrs++);
 +		move_msr_up(vmx, index, save_nmsrs++);
  	index = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);
  	if (index >= 0)
 -		move_msr_up(vmx, index, nr_active_uret_msrs++);
 +		move_msr_up(vmx, index, save_nmsrs++);
  
++<<<<<<< HEAD
 +	vmx->save_nmsrs = save_nmsrs;
 +	vmx->guest_msrs_ready = false;
++=======
+ 	vmx->nr_active_uret_msrs = nr_active_uret_msrs;
+ 	vmx->guest_uret_msrs_loaded = false;
++>>>>>>> 658ece84f5da (KVM: VMX: Rename vcpu_vmx's "guest_msrs_ready" to "guest_uret_msrs_loaded")
  
  	if (cpu_has_vmx_msr_bitmap())
  		vmx_update_msr_bitmap(&vmx->vcpu);
diff --cc arch/x86/kvm/vmx/vmx.h
index 131d638ba270,8cb04e75defc..000000000000
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@@ -195,10 -196,10 +195,17 @@@ struct vcpu_vmx 
  	u32                   idt_vectoring_info;
  	ulong                 rflags;
  
++<<<<<<< HEAD
 +	struct shared_msr_entry guest_msrs[MAX_NR_SHARED_MSRS];
 +	int                   nmsrs;
 +	int                   save_nmsrs;
 +	bool                  guest_msrs_ready;
++=======
+ 	struct vmx_uret_msr   guest_uret_msrs[MAX_NR_USER_RETURN_MSRS];
+ 	int                   nr_uret_msrs;
+ 	int                   nr_active_uret_msrs;
+ 	bool                  guest_uret_msrs_loaded;
++>>>>>>> 658ece84f5da (KVM: VMX: Rename vcpu_vmx's "guest_msrs_ready" to "guest_uret_msrs_loaded")
  #ifdef CONFIG_X86_64
  	u64		      msr_host_kernel_gs_base;
  	u64		      msr_guest_kernel_gs_base;
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
