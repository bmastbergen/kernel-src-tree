lib/vdso: Avoid highres update if clocksource is not VDSO capable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit c7a18100bdffdff440c7291db6e80863fab0461e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c7a18100.failed

If the current clocksource is not VDSO capable there is no point in
updating the high resolution parts of the VDSO data.

Replace the architecture specific check with a check for a VDSO capable
clocksource and skip the update if there is none.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
Link: https://lkml.kernel.org/r/20200207124403.563379423@linutronix.de


(cherry picked from commit c7a18100bdffdff440c7291db6e80863fab0461e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/include/asm/vdso/vsyscall.h
#	include/asm-generic/vdso/vsyscall.h
#	kernel/time/vsyscall.c
diff --cc include/asm-generic/vdso/vsyscall.h
index e94b19782c92,c835607f78ae..000000000000
--- a/include/asm-generic/vdso/vsyscall.h
+++ b/include/asm-generic/vdso/vsyscall.h
@@@ -11,27 -11,6 +11,30 @@@ static __always_inline struct vdso_dat
  }
  #endif /* __arch_get_k_vdso_data */
  
++<<<<<<< HEAD
 +#ifndef __arch_update_vdso_data
 +static __always_inline int __arch_update_vdso_data(void)
 +{
 +	return 0;
 +}
 +#endif /* __arch_update_vdso_data */
 +
 +#ifndef __arch_get_clock_mode
 +static __always_inline int __arch_get_clock_mode(struct timekeeper *tk)
 +{
 +	return 0;
 +}
 +#endif /* __arch_get_clock_mode */
 +
 +#ifndef __arch_use_vsyscall
 +static __always_inline int __arch_use_vsyscall(struct vdso_data *vdata)
 +{
 +	return 1;
 +}
 +#endif /* __arch_use_vsyscall */
 +
++=======
++>>>>>>> c7a18100bdff (lib/vdso: Avoid highres update if clocksource is not VDSO capable)
  #ifndef __arch_update_vsyscall
  static __always_inline void __arch_update_vsyscall(struct vdso_data *vdata,
  						   struct timekeeper *tk)
diff --cc kernel/time/vsyscall.c
index 4bc37ac3bb05,54ce6eb2ca36..000000000000
--- a/kernel/time/vsyscall.c
+++ b/kernel/time/vsyscall.c
@@@ -110,7 -98,17 +110,21 @@@ void update_vsyscall(struct timekeeper 
  	nsec		= nsec + tk->wall_to_monotonic.tv_nsec;
  	vdso_ts->sec	+= __iter_div_u64_rem(nsec, NSEC_PER_SEC, &vdso_ts->nsec);
  
++<<<<<<< HEAD
 +	if (__arch_use_vsyscall(vdata))
++=======
+ 	/*
+ 	 * Read without the seqlock held by clock_getres().
+ 	 * Note: No need to have a second copy.
+ 	 */
+ 	WRITE_ONCE(vdata[CS_HRES_COARSE].hrtimer_res, hrtimer_resolution);
+ 
+ 	/*
+ 	 * If the current clocksource is not VDSO capable, then spare the
+ 	 * update of the high reolution parts.
+ 	 */
+ 	if (clock_mode != VDSO_CLOCKMODE_NONE)
++>>>>>>> c7a18100bdff (lib/vdso: Avoid highres update if clocksource is not VDSO capable)
  		update_vdso_data(vdata, tk);
  
  	__arch_update_vsyscall(vdata, tk);
* Unmerged path arch/arm/include/asm/vdso/vsyscall.h
* Unmerged path arch/arm/include/asm/vdso/vsyscall.h
* Unmerged path include/asm-generic/vdso/vsyscall.h
* Unmerged path kernel/time/vsyscall.c
