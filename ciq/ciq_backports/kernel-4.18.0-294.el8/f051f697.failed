x86/nmi: Protect NMI entry against instrumentation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [x86] nmi: Protect NMI entry against instrumentation (Vitaly Kuznetsov) [1868080]
Rebuild_FUZZ: 95.83%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit f051f697955049c7cf10a635ab8149aa619243b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/f051f697.failed

Mark all functions in the fragile code parts noinstr or force inlining so
they can't be instrumented.

Also make the hardware latency tracer invocation explicit outside of
non-instrumentable section.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Alexandre Chartre <alexandre.chartre@oracle.com>
	Acked-by: Peter Zijlstra <peterz@infradead.org>
	Acked-by: Andy Lutomirski <luto@kernel.org>
Link: https://lkml.kernel.org/r/20200505135314.716186134@linutronix.de




(cherry picked from commit f051f697955049c7cf10a635ab8149aa619243b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/nmi.c
diff --cc arch/x86/kernel/nmi.c
index 086cf1d1d71d,3052c78f03aa..000000000000
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@@ -488,11 -488,29 +492,30 @@@ static DEFINE_PER_CPU(unsigned long, nm
   * switch back to the original IDT.
   */
  static DEFINE_PER_CPU(int, update_debug_stack);
++<<<<<<< HEAD
++=======
+ 
+ static noinstr bool is_debug_stack(unsigned long addr)
+ {
+ 	struct cea_exception_stacks *cs = __this_cpu_read(cea_exception_stacks);
+ 	unsigned long top = CEA_ESTACK_TOP(cs, DB);
+ 	unsigned long bot = CEA_ESTACK_BOT(cs, DB1);
+ 
+ 	if (__this_cpu_read(debug_stack_usage))
+ 		return true;
+ 	/*
+ 	 * Note, this covers the guard page between DB and DB1 as well to
+ 	 * avoid two checks. But by all means @addr can never point into
+ 	 * the guard page.
+ 	 */
+ 	return addr >= bot && addr < top;
+ }
++>>>>>>> f051f6979550 (x86/nmi: Protect NMI entry against instrumentation)
  #endif
  
 -DEFINE_IDTENTRY_NMI(exc_nmi)
 +dotraplinkage notrace void
 +do_nmi(struct pt_regs *regs, long error_code)
  {
 -	if (IS_ENABLED(CONFIG_SMP) && cpu_is_offline(smp_processor_id()))
 -		return;
 -
  	if (this_cpu_read(nmi_state) != NMI_NOT_RUNNING) {
  		this_cpu_write(nmi_state, NMI_LATCHED);
  		return;
diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h
index 13c5ee878a47..26e51a7dad60 100644
--- a/arch/x86/include/asm/desc.h
+++ b/arch/x86/include/asm/desc.h
@@ -214,7 +214,7 @@ static inline void native_load_gdt(const struct desc_ptr *dtr)
 	asm volatile("lgdt %0"::"m" (*dtr));
 }
 
-static inline void native_load_idt(const struct desc_ptr *dtr)
+static __always_inline void native_load_idt(const struct desc_ptr *dtr)
 {
 	asm volatile("lidt %0"::"m" (*dtr));
 }
@@ -393,7 +393,7 @@ extern unsigned long system_vectors[];
 
 #ifdef CONFIG_X86_64
 DECLARE_PER_CPU(u32, debug_idt_ctr);
-static inline bool is_debug_idt_enabled(void)
+static __always_inline bool is_debug_idt_enabled(void)
 {
 	if (this_cpu_read(debug_idt_ctr))
 		return true;
@@ -401,7 +401,7 @@ static inline bool is_debug_idt_enabled(void)
 	return false;
 }
 
-static inline void load_debug_idt(void)
+static __always_inline void load_debug_idt(void)
 {
 	load_idt((const struct desc_ptr *)&debug_idt_descr);
 }
@@ -423,7 +423,7 @@ static inline void load_debug_idt(void)
  * that doesn't need to disable interrupts, as nothing should be
  * bothering the CPU then.
  */
-static inline void load_current_idt(void)
+static __always_inline void load_current_idt(void)
 {
 	if (is_debug_idt_enabled())
 		load_debug_idt();
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index d6857fdc914b..3289c6ce6480 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -1671,21 +1671,19 @@ NOKPROBE_SYMBOL(is_debug_stack);
 
 DEFINE_PER_CPU(u32, debug_idt_ctr);
 
-void debug_stack_set_zero(void)
+noinstr void debug_stack_set_zero(void)
 {
 	this_cpu_inc(debug_idt_ctr);
 	load_current_idt();
 }
-NOKPROBE_SYMBOL(debug_stack_set_zero);
 
-void debug_stack_reset(void)
+noinstr void debug_stack_reset(void)
 {
 	if (WARN_ON(!this_cpu_read(debug_idt_ctr)))
 		return;
 	if (this_cpu_dec_return(debug_idt_ctr) == 0)
 		load_current_idt();
 }
-NOKPROBE_SYMBOL(debug_stack_reset);
 
 #else	/* CONFIG_X86_64 */
 
* Unmerged path arch/x86/kernel/nmi.c
