efi/x86: Merge the setup_efi_pci32() and setup_efi_pci64() routines

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ard Biesheuvel <ard.biesheuvel@linaro.org>
commit 75c5a713ab4b774c7d990ec748dddba714034436
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/75c5a713.failed

After merging the 32-bit and 64-bit versions of the code that invokes
the PCI I/O protocol methods to preserve PCI ROM images in commit:

  2c3625cb9fa2 ("efi/x86: Fold __setup_efi_pci32() and __setup_efi_pci64() ...")

there are still separate code paths for 32-bit and 64-bit, where the only
difference is the size of a EFI_HANDLE. So let's parameterize a single
implementation for that difference only, and get rid of the two copies of
the code.

While at it, rename __setup_efi_pci() to preserve_pci_rom_image() to
better reflect its purpose.

	Tested-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Lukas Wunner <lukas@wunner.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/20180720014726.24031-3-ard.biesheuvel@linaro.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 75c5a713ab4b774c7d990ec748dddba714034436)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
diff --cc arch/x86/boot/compressed/eboot.c
index 589c8337729e,c72550783c16..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -181,96 -181,6 +181,99 @@@ free_struct
  	return status;
  }
  
++<<<<<<< HEAD
 +static void
 +setup_efi_pci32(struct boot_params *params, void **pci_handle,
 +		unsigned long size)
 +{
 +	efi_pci_io_protocol_t *pci = NULL;
 +	efi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;
 +	u32 *handles = (u32 *)(unsigned long)pci_handle;
 +	efi_status_t status;
 +	unsigned long nr_pci;
 +	struct setup_data *data;
 +	int i;
 +
 +	data = (struct setup_data *)(unsigned long)params->hdr.setup_data;
 +
 +	while (data && data->next)
 +		data = (struct setup_data *)(unsigned long)data->next;
 +
 +	nr_pci = size / sizeof(u32);
 +	for (i = 0; i < nr_pci; i++) {
 +		struct pci_setup_rom *rom = NULL;
 +		u32 h = handles[i];
 +
 +		status = efi_call_early(handle_protocol, h,
 +					&pci_proto, (void **)&pci);
 +
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		if (!pci)
 +			continue;
 +
 +		status = __setup_efi_pci(pci, &rom);
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		if (data)
 +			data->next = (unsigned long)rom;
 +		else
 +			params->hdr.setup_data = (unsigned long)rom;
 +
 +		data = (struct setup_data *)rom;
 +
 +	}
 +}
 +
 +static void
 +setup_efi_pci64(struct boot_params *params, void **pci_handle,
 +		unsigned long size)
 +{
 +	efi_pci_io_protocol_t *pci = NULL;
 +	efi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;
 +	u64 *handles = (u64 *)(unsigned long)pci_handle;
 +	efi_status_t status;
 +	unsigned long nr_pci;
 +	struct setup_data *data;
 +	int i;
 +
 +	data = (struct setup_data *)(unsigned long)params->hdr.setup_data;
 +
 +	while (data && data->next)
 +		data = (struct setup_data *)(unsigned long)data->next;
 +
 +	nr_pci = size / sizeof(u64);
 +	for (i = 0; i < nr_pci; i++) {
 +		struct pci_setup_rom *rom = NULL;
 +		u64 h = handles[i];
 +
 +		status = efi_call_early(handle_protocol, h,
 +					&pci_proto, (void **)&pci);
 +
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		if (!pci)
 +			continue;
 +
 +		status = __setup_efi_pci(pci, &rom);
 +		if (status != EFI_SUCCESS)
 +			continue;
 +
 +		if (data)
 +			data->next = (unsigned long)rom;
 +		else
 +			params->hdr.setup_data = (unsigned long)rom;
 +
 +		data = (struct setup_data *)rom;
 +
 +	}
 +}
 +
++=======
++>>>>>>> 75c5a713ab4b (efi/x86: Merge the setup_efi_pci32() and setup_efi_pci64() routines)
  /*
   * There's no way to return an informative status from this function,
   * because any analysis (and printing of error messages) needs to be
* Unmerged path arch/x86/boot/compressed/eboot.c
