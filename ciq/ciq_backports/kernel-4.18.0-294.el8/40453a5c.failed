mptcp: add the incoming MP_PRIO support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Geliang Tang <geliangtang@gmail.com>
commit 40453a5c61f4dc43bbbdbf7cefed4eb1bc8d69b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/40453a5c.failed

This patch added the incoming MP_PRIO logic:

Added a flag named mp_prio in struct mptcp_options_received, to mark the
MP_PRIO is received, and save the priority value to struct
mptcp_options_received's backup member. Then invoke
mptcp_pm_mp_prio_received with the receiving subsocket and the backup
value.

In mptcp_pm_mp_prio_received, get the subflow context according the input
subsocket, and change the subflow's backup as the incoming priority value.

	Signed-off-by: Geliang Tang <geliangtang@gmail.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 40453a5c61f4dc43bbbdbf7cefed4eb1bc8d69b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/options.c
#	net/mptcp/protocol.h
diff --cc net/mptcp/options.c
index af3f2e566740,adfa96dd991c..000000000000
--- a/net/mptcp/options.c
+++ b/net/mptcp/options.c
@@@ -279,6 -282,25 +279,28 @@@ static void mptcp_parse_option(const st
  		pr_debug("RM_ADDR: id=%d", mp_opt->rm_id);
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case MPTCPOPT_MP_PRIO:
+ 		if (opsize != TCPOLEN_MPTCP_PRIO)
+ 			break;
+ 
+ 		mp_opt->mp_prio = 1;
+ 		mp_opt->backup = *ptr++ & MPTCP_PRIO_BKUP;
+ 		pr_debug("MP_PRIO: prio=%d", mp_opt->backup);
+ 		break;
+ 
+ 	case MPTCPOPT_MP_FASTCLOSE:
+ 		if (opsize != TCPOLEN_MPTCP_FASTCLOSE)
+ 			break;
+ 
+ 		ptr += 2;
+ 		mp_opt->rcvr_key = get_unaligned_be64(ptr);
+ 		ptr += 8;
+ 		mp_opt->fastclose = 1;
+ 		break;
+ 
++>>>>>>> 40453a5c61f4 (mptcp: add the incoming MP_PRIO support)
  	default:
  		break;
  	}
@@@ -860,6 -1022,21 +883,19 @@@ void mptcp_incoming_options(struct soc
  		mp_opt.add_addr = 0;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (mp_opt.rm_addr) {
+ 		mptcp_pm_rm_addr_received(msk, mp_opt.rm_id);
+ 		mp_opt.rm_addr = 0;
+ 	}
+ 
+ 	if (mp_opt.mp_prio) {
+ 		mptcp_pm_mp_prio_received(sk, mp_opt.backup);
+ 		mp_opt.mp_prio = 0;
+ 	}
+ 
++>>>>>>> 40453a5c61f4 (mptcp: add the incoming MP_PRIO support)
  	if (!mp_opt.dss)
  		return;
  
diff --cc net/mptcp/protocol.h
index 46bdc749922f,d6400ad2d615..000000000000
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@@ -84,9 -88,12 +84,12 @@@
  #define MPTCP_ADDR_IPVERSION_4	4
  #define MPTCP_ADDR_IPVERSION_6	6
  
+ /* MPTCP MP_PRIO flags */
+ #define MPTCP_PRIO_BKUP		BIT(0)
+ 
  /* MPTCP socket flags */
  #define MPTCP_DATA_READY	0
 -#define MPTCP_NOSPACE		1
 +#define MPTCP_SEND_SPACE	1
  #define MPTCP_WORK_RTX		2
  #define MPTCP_WORK_EOF		3
  #define MPTCP_FALLBACK_DONE	4
@@@ -439,11 -555,22 +443,24 @@@ void mptcp_pm_subflow_established(struc
  void mptcp_pm_subflow_closed(struct mptcp_sock *msk, u8 id);
  void mptcp_pm_add_addr_received(struct mptcp_sock *msk,
  				const struct mptcp_addr_info *addr);
++<<<<<<< HEAD
++=======
+ void mptcp_pm_add_addr_send_ack(struct mptcp_sock *msk);
+ void mptcp_pm_rm_addr_received(struct mptcp_sock *msk, u8 rm_id);
+ void mptcp_pm_mp_prio_received(struct sock *sk, u8 bkup);
+ int mptcp_pm_nl_mp_prio_send_ack(struct mptcp_sock *msk,
+ 				 struct mptcp_addr_info *addr,
+ 				 u8 bkup);
+ void mptcp_pm_free_anno_list(struct mptcp_sock *msk);
+ struct mptcp_pm_add_entry *
+ mptcp_pm_del_add_timer(struct mptcp_sock *msk,
+ 		       struct mptcp_addr_info *addr);
++>>>>>>> 40453a5c61f4 (mptcp: add the incoming MP_PRIO support)
  
  int mptcp_pm_announce_addr(struct mptcp_sock *msk,
 -			   const struct mptcp_addr_info *addr,
 -			   bool echo, bool port);
 +			   const struct mptcp_addr_info *addr);
  int mptcp_pm_remove_addr(struct mptcp_sock *msk, u8 local_id);
 -int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 local_id);
 +int mptcp_pm_remove_subflow(struct mptcp_sock *msk, u8 remote_id);
  
  static inline bool mptcp_pm_should_add_signal(struct mptcp_sock *msk)
  {
* Unmerged path net/mptcp/options.c
diff --git a/net/mptcp/pm.c b/net/mptcp/pm.c
index a78fc80f9b51..71b95be85395 100644
--- a/net/mptcp/pm.c
+++ b/net/mptcp/pm.c
@@ -153,6 +153,14 @@ void mptcp_pm_add_addr_received(struct mptcp_sock *msk,
 	spin_unlock_bh(&pm->lock);
 }
 
+void mptcp_pm_mp_prio_received(struct sock *sk, u8 bkup)
+{
+	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);
+
+	pr_debug("subflow->backup=%d, bkup=%d\n", subflow->backup, bkup);
+	subflow->backup = bkup;
+}
+
 /* path manager helpers */
 
 bool mptcp_pm_add_addr_signal(struct mptcp_sock *msk, unsigned int remaining,
* Unmerged path net/mptcp/protocol.h
