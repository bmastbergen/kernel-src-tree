dma-mapping: remove dma_mark_declared_memory_occupied

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 91a6fda95cb67c94b887355690d1923a7eb6f630
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/91a6fda9.failed

This API is not used anywhere, so remove it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 91a6fda95cb67c94b887355690d1923a7eb6f630)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/DMA-API.txt
#	include/linux/dma-mapping.h
#	kernel/dma/coherent.c
diff --cc Documentation/DMA-API.txt
index ac8c6327ce70,b9d0cba83877..000000000000
--- a/Documentation/DMA-API.txt
+++ b/Documentation/DMA-API.txt
@@@ -613,20 -596,14 +613,31 @@@ you should use the dma_pool() API
  
  ::
  
++<<<<<<< HEAD
 +	void *
 +	dma_mark_declared_memory_occupied(struct device *dev,
 +					  dma_addr_t device_addr, size_t size)
 +
 +This is used to occupy specific regions of the declared space
 +(dma_alloc_coherent() will hand out the first free region it finds).
 +
 +device_addr is the *device* address of the region requested.
 +
 +size is the size (and should be a page-sized multiple).
 +
 +The return value will be either a pointer to the processor virtual
 +address of the memory, or an error (via PTR_ERR()) if any part of the
 +region is occupied.
++=======
+ 	void
+ 	dma_release_declared_memory(struct device *dev)
+ 
+ Remove the memory region previously declared from the system.  This
+ API performs *no* in-use checking for this region and will return
+ unconditionally having removed all the required structures.  It is the
+ driver's job to ensure that no parts of this memory region are
+ currently in use.
++>>>>>>> 91a6fda95cb6 (dma-mapping: remove dma_mark_declared_memory_occupied)
  
  Part III - Debug drivers use of the DMA-API
  -------------------------------------------
diff --cc include/linux/dma-mapping.h
index 06cb794fc6c7,d29faadf6ef2..000000000000
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@@ -858,11 -736,13 +858,16 @@@ static inline int dma_get_cache_alignme
  	return 1;
  }
  
 -/* flags for the coherent memory api */
 -#define DMA_MEMORY_EXCLUSIVE		0x01
 -
 -#ifdef CONFIG_DMA_DECLARE_COHERENT
 +#ifdef CONFIG_HAVE_GENERIC_DMA_COHERENT
  int dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,
++<<<<<<< HEAD
 +				dma_addr_t device_addr, size_t size);
 +void *dma_mark_declared_memory_occupied(struct device *dev,
 +					dma_addr_t device_addr, size_t size);
++=======
+ 				dma_addr_t device_addr, size_t size, int flags);
+ void dma_release_declared_memory(struct device *dev);
++>>>>>>> 91a6fda95cb6 (dma-mapping: remove dma_mark_declared_memory_occupied)
  #else
  static inline int
  dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,
@@@ -871,13 -751,11 +876,21 @@@
  	return -ENOSYS;
  }
  
++<<<<<<< HEAD
 +static inline void *
 +dma_mark_declared_memory_occupied(struct device *dev,
 +				  dma_addr_t device_addr, size_t size)
 +{
 +	return ERR_PTR(-EBUSY);
 +}
 +#endif /* CONFIG_HAVE_GENERIC_DMA_COHERENT */
++=======
+ static inline void
+ dma_release_declared_memory(struct device *dev)
+ {
+ }
+ #endif /* CONFIG_DMA_DECLARE_COHERENT */
++>>>>>>> 91a6fda95cb6 (dma-mapping: remove dma_mark_declared_memory_occupied)
  
  static inline void *dmam_alloc_coherent(struct device *dev, size_t size,
  		dma_addr_t *dma_handle, gfp_t gfp)
diff --cc kernel/dma/coherent.c
index 58d6bb278726,1d12a31af6d7..000000000000
--- a/kernel/dma/coherent.c
+++ b/kernel/dma/coherent.c
@@@ -122,33 -124,21 +122,38 @@@ int dma_declare_coherent_memory(struct 
  		dma_release_coherent_memory(mem);
  	return ret;
  }
 -EXPORT_SYMBOL(dma_declare_coherent_memory);
  
 -void dma_release_declared_memory(struct device *dev)
++<<<<<<< HEAD
 +void *dma_mark_declared_memory_occupied(struct device *dev,
 +					dma_addr_t device_addr, size_t size)
  {
  	struct dma_coherent_mem *mem = dev->dma_mem;
 +	unsigned long flags;
 +	int pos, err;
 +
 +	size += device_addr & ~PAGE_MASK;
  
  	if (!mem)
 -		return;
 -	dma_release_coherent_memory(mem);
 -	dev->dma_mem = NULL;
 +		return ERR_PTR(-EINVAL);
 +
 +	spin_lock_irqsave(&mem->spinlock, flags);
 +	pos = PFN_DOWN(device_addr - dma_get_device_base(dev, mem));
 +	err = bitmap_allocate_region(mem->bitmap, pos, get_order(size));
 +	spin_unlock_irqrestore(&mem->spinlock, flags);
 +
 +	if (err != 0)
 +		return ERR_PTR(err);
 +	return mem->virt_base + (pos << PAGE_SHIFT);
  }
 -EXPORT_SYMBOL(dma_release_declared_memory);
 +EXPORT_SYMBOL(dma_mark_declared_memory_occupied);
  
 +static void *__dma_alloc_from_coherent(struct device *dev,
 +				       struct dma_coherent_mem *mem,
 +				       ssize_t size, dma_addr_t *dma_handle)
++=======
+ static void *__dma_alloc_from_coherent(struct dma_coherent_mem *mem,
+ 		ssize_t size, dma_addr_t *dma_handle)
++>>>>>>> 91a6fda95cb6 (dma-mapping: remove dma_mark_declared_memory_occupied)
  {
  	int order = get_order(size);
  	unsigned long flags;
* Unmerged path Documentation/DMA-API.txt
* Unmerged path include/linux/dma-mapping.h
* Unmerged path kernel/dma/coherent.c
