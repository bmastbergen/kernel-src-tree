xfs: remove the xfs_btree_get_buf[ls] functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
Rebuild_CHGLOG: - [fs] xfs: remove the xfs_btree_get_buffunctions (Carlos Maiolino) [1859160]
Rebuild_FUZZ: 94.38%
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit ee647f85cb81b09bbfa2886954828ed03fa3ec38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ee647f85.failed

Remove the xfs_btree_get_bufs and xfs_btree_get_bufl functions, since
they're pretty trivial oneliners.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit ee647f85cb81b09bbfa2886954828ed03fa3ec38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc.c
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_btree.c
diff --cc fs/xfs/libxfs/xfs_alloc.c
index b572287a5c89,34b65635ee34..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -1068,11 -1070,11 +1068,17 @@@ xfs_alloc_ag_vextent_small
  	if (args->datatype & XFS_ALLOC_USERDATA) {
  		struct xfs_buf	*bp;
  
++<<<<<<< HEAD
 +		bp = xfs_btree_get_bufs(args->mp, args->tp, args->agno, fbno);
 +		if (!bp) {
 +			error = -EFSCORRUPTED;
++=======
+ 		error = xfs_trans_get_buf(args->tp, args->mp->m_ddev_targp,
+ 				XFS_AGB_TO_DADDR(args->mp, args->agno, fbno),
+ 				args->mp->m_bsize, 0, &bp);
+ 		if (error)
++>>>>>>> ee647f85cb81 (xfs: remove the xfs_btree_get_buf[ls] functions)
  			goto error;
- 		}
  		xfs_trans_binval(args->tp, bp);
  	}
  	*fbnop = args->agbno = fbno;
@@@ -2345,9 -2347,11 +2351,17 @@@ xfs_free_agfl_block
  	if (error)
  		return error;
  
++<<<<<<< HEAD
 +	bp = xfs_btree_get_bufs(tp->t_mountp, tp, agno, agbno);
 +	if (!bp)
 +		return -EFSCORRUPTED;
++=======
+ 	error = xfs_trans_get_buf(tp, tp->t_mountp->m_ddev_targp,
+ 			XFS_AGB_TO_DADDR(tp->t_mountp, agno, agbno),
+ 			tp->t_mountp->m_bsize, 0, &bp);
+ 	if (error)
+ 		return error;
++>>>>>>> ee647f85cb81 (xfs: remove the xfs_btree_get_buf[ls] functions)
  	xfs_trans_binval(tp, bp);
  
  	return 0;
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 587bd1aa6a1c,cfcef076c72f..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -730,11 -730,11 +730,17 @@@ xfs_bmap_extents_to_btree
  	cur->bc_private.b.allocated++;
  	ip->i_d.di_nblocks++;
  	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);
++<<<<<<< HEAD
 +	abp = xfs_btree_get_bufl(mp, tp, args.fsbno);
 +	if (!abp) {
 +		error = -EFSCORRUPTED;
++=======
+ 	error = xfs_trans_get_buf(tp, mp->m_ddev_targp,
+ 			XFS_FSB_TO_DADDR(mp, args.fsbno),
+ 			mp->m_bsize, 0, &abp);
+ 	if (error)
++>>>>>>> ee647f85cb81 (xfs: remove the xfs_btree_get_buf[ls] functions)
  		goto out_unreserve_dquot;
- 	}
  
  	/*
  	 * Fill in the child block.
diff --cc fs/xfs/libxfs/xfs_btree.c
index 9fce860fd162,fd300dc93ca4..000000000000
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@@ -681,42 -679,6 +681,45 @@@ xfs_btree_get_block
  }
  
  /*
++<<<<<<< HEAD
 + * Get a buffer for the block, return it with no data read.
 + * Long-form addressing.
 + */
 +xfs_buf_t *				/* buffer for fsbno */
 +xfs_btree_get_bufl(
 +	xfs_mount_t	*mp,		/* file system mount point */
 +	xfs_trans_t	*tp,		/* transaction pointer */
 +	xfs_fsblock_t	fsbno)		/* file system block number */
 +{
 +	xfs_daddr_t		d;		/* real disk block address */
 +
 +	ASSERT(fsbno != NULLFSBLOCK);
 +	d = XFS_FSB_TO_DADDR(mp, fsbno);
 +	return xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, 0);
 +}
 +
 +/*
 + * Get a buffer for the block, return it with no data read.
 + * Short-form addressing.
 + */
 +xfs_buf_t *				/* buffer for agno/agbno */
 +xfs_btree_get_bufs(
 +	xfs_mount_t	*mp,		/* file system mount point */
 +	xfs_trans_t	*tp,		/* transaction pointer */
 +	xfs_agnumber_t	agno,		/* allocation group number */
 +	xfs_agblock_t	agbno)		/* allocation group block number */
 +{
 +	xfs_daddr_t		d;		/* real disk block address */
 +
 +	ASSERT(agno != NULLAGNUMBER);
 +	ASSERT(agbno != NULLAGBLOCK);
 +	d = XFS_AGB_TO_DADDR(mp, agno, agbno);
 +	return xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, 0);
 +}
 +
 +/*
++=======
++>>>>>>> ee647f85cb81 (xfs: remove the xfs_btree_get_buf[ls] functions)
   * Change the cursor to point to the first record at the given level.
   * Other levels are unaffected.
   */
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_btree.c
diff --git a/fs/xfs/libxfs/xfs_btree.h b/fs/xfs/libxfs/xfs_btree.h
index fb9b2121c628..3eff7c321d43 100644
--- a/fs/xfs/libxfs/xfs_btree.h
+++ b/fs/xfs/libxfs/xfs_btree.h
@@ -296,27 +296,6 @@ xfs_btree_dup_cursor(
 	xfs_btree_cur_t		*cur,	/* input cursor */
 	xfs_btree_cur_t		**ncur);/* output cursor */
 
-/*
- * Get a buffer for the block, return it with no data read.
- * Long-form addressing.
- */
-struct xfs_buf *				/* buffer for fsbno */
-xfs_btree_get_bufl(
-	struct xfs_mount	*mp,	/* file system mount point */
-	struct xfs_trans	*tp,	/* transaction pointer */
-	xfs_fsblock_t		fsbno);	/* file system block number */
-
-/*
- * Get a buffer for the block, return it with no data read.
- * Short-form addressing.
- */
-struct xfs_buf *				/* buffer for agno/agbno */
-xfs_btree_get_bufs(
-	struct xfs_mount	*mp,	/* file system mount point */
-	struct xfs_trans	*tp,	/* transaction pointer */
-	xfs_agnumber_t		agno,	/* allocation group number */
-	xfs_agblock_t		agbno);	/* allocation group block number */
-
 /*
  * Compute first and last byte offsets for the fields given.
  * Interprets the offsets table, which contains struct field offsets.
