convert do_remount_sb() to fs_context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author David Howells <dhowells@redhat.com>
commit 8d0347f6c3a9d4953ddd636a31c6584da082e084
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/8d0347f6.failed

Replace do_remount_sb() with a function, reconfigure_super(), that's
fs_context aware.  The fs_context is expected to be parameterised already
and have ->root pointing to the superblock to be reconfigured.

A legacy wrapper is provided that is intended to be called from the
fs_context ops when those appear, but for now is called directly from
reconfigure_super().  This wrapper invokes the ->remount_fs() superblock op
for the moment.  It is intended that the remount_fs() op will be phased
out.

The fs_context->purpose is set to FS_CONTEXT_FOR_RECONFIGURE to indicate
that the context is being used for reconfiguration.

do_umount_root() is provided to consolidate remount-to-R/O for umount and
emergency remount by creating a context and invoking reconfiguration.

do_remount(), do_umount() and do_emergency_remount_callback() are switched
to use the new process.

[AV -- fold UMOUNT and EMERGENCY_REMOUNT in; fixes the
umount / bug, gets rid of pointless complexity]
[AV -- set ->net_ns in all cases; nfs remount will need that]
[AV -- shift security_sb_remount() call into reconfigure_super(); the callers
that didn't do security_sb_remount() have NULL fc->security anyway, so it's
a no-op for them]

	Signed-off-by: David Howells <dhowells@redhat.com>
Co-developed-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 8d0347f6c3a9d4953ddd636a31c6584da082e084)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs_context.c
#	fs/internal.h
#	fs/namespace.c
#	include/linux/fs_context.h
diff --cc fs/internal.h
index 172c0652a6e5,016a5b8dd305..000000000000
--- a/fs/internal.h
+++ b/fs/internal.h
@@@ -50,10 -53,16 +50,21 @@@ extern int __block_write_begin_int(stru
  extern void __init chrdev_init(void);
  
  /*
++<<<<<<< HEAD
++=======
+  * fs_context.c
+  */
+ extern int legacy_get_tree(struct fs_context *fc);
+ extern int legacy_reconfigure(struct fs_context *fc);
+ extern int parse_monolithic_mount_data(struct fs_context *, void *);
+ extern void fc_drop_locked(struct fs_context *);
+ 
+ /*
++>>>>>>> 8d0347f6c3a9 (convert do_remount_sb() to fs_context)
   * namei.c
   */
 +extern int filename_lookup(int dfd, struct filename *name, unsigned flags,
 +			   struct path *path, struct path *root);
  extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
  extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
  			   const char *, unsigned int, struct path *);
@@@ -99,10 -108,8 +110,10 @@@ extern struct file *alloc_empty_file_no
  /*
   * super.c
   */
- extern int do_remount_sb(struct super_block *, int, void *, int);
+ extern int reconfigure_super(struct fs_context *);
  extern bool trylock_super(struct super_block *sb);
 +extern struct dentry *mount_fs(struct file_system_type *,
 +			       int, const char *, void *);
  extern struct super_block *user_get_super(dev_t);
  
  /*
diff --cc fs/namespace.c
index d4be8b82f7bd,931228d8518a..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -2308,7 -2386,7 +2327,11 @@@ static int do_remount(struct path *path
  	int err;
  	struct super_block *sb = path->mnt->mnt_sb;
  	struct mount *mnt = real_mount(path->mnt);
++<<<<<<< HEAD
 +	struct security_mnt_opts opts;
++=======
+ 	struct fs_context *fc;
++>>>>>>> 8d0347f6c3a9 (convert do_remount_sb() to fs_context)
  
  	if (!check_mnt(mnt))
  		return -EINVAL;
@@@ -2319,25 -2397,22 +2342,35 @@@
  	if (!can_change_locked_flags(mnt, mnt_flags))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	security_init_mnt_opts(&opts);
 +	if (data && !(sb->s_type->fs_flags & FS_BINARY_MOUNTDATA)) {
 +		err = security_sb_eat_lsm_opts(data, &opts);
 +		if (err)
 +			return err;
 +	}
 +	err = security_sb_remount(sb, &opts);
 +	security_free_mnt_opts(&opts);
 +	if (err)
 +		return err;
++=======
+ 	fc = fs_context_for_reconfigure(path->dentry, sb_flags, MS_RMT_MASK);
+ 	if (IS_ERR(fc))
+ 		return PTR_ERR(fc);
++>>>>>>> 8d0347f6c3a9 (convert do_remount_sb() to fs_context)
  
- 	down_write(&sb->s_umount);
- 	err = -EPERM;
- 	if (ns_capable(sb->s_user_ns, CAP_SYS_ADMIN)) {
- 		err = do_remount_sb(sb, sb_flags, data, 0);
- 		if (!err)
- 			set_mount_attributes(mnt, mnt_flags);
+ 	err = parse_monolithic_mount_data(fc, data);
+ 	if (!err) {
+ 		down_write(&sb->s_umount);
+ 		err = -EPERM;
+ 		if (ns_capable(sb->s_user_ns, CAP_SYS_ADMIN)) {
+ 			err = reconfigure_super(fc);
+ 			if (!err)
+ 				set_mount_attributes(mnt, mnt_flags);
+ 		}
+ 		up_write(&sb->s_umount);
  	}
- 	up_write(&sb->s_umount);
+ 	put_fs_context(fc);
  	return err;
  }
  
* Unmerged path fs/fs_context.c
* Unmerged path include/linux/fs_context.h
* Unmerged path fs/fs_context.c
* Unmerged path fs/internal.h
* Unmerged path fs/namespace.c
diff --git a/fs/super.c b/fs/super.c
index 9be3be2154ec..423a7ff7381c 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -838,28 +838,35 @@ struct super_block *user_get_super(dev_t dev)
 }
 
 /**
- *	do_remount_sb - asks filesystem to change mount options.
- *	@sb:	superblock in question
- *	@sb_flags: revised superblock flags
- *	@data:	the rest of options
- *      @force: whether or not to force the change
+ * reconfigure_super - asks filesystem to change superblock parameters
+ * @fc: The superblock and configuration
  *
- *	Alters the mount options of a mounted file system.
+ * Alters the configuration parameters of a live superblock.
  */
-int do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)
+int reconfigure_super(struct fs_context *fc)
 {
+	struct super_block *sb = fc->root->d_sb;
 	int retval;
-	int remount_ro;
+	bool remount_ro = false;
+	bool force = fc->sb_flags & SB_FORCE;
 
+	if (fc->sb_flags_mask & ~MS_RMT_MASK)
+		return -EINVAL;
 	if (sb->s_writers.frozen != SB_UNFROZEN)
 		return -EBUSY;
 
+	retval = security_sb_remount(sb, fc->security);
+	if (retval)
+		return retval;
+
+	if (fc->sb_flags_mask & SB_RDONLY) {
 #ifdef CONFIG_BLOCK
-	if (!(sb_flags & SB_RDONLY) && bdev_read_only(sb->s_bdev))
-		return -EACCES;
+		if (!(fc->sb_flags & SB_RDONLY) && bdev_read_only(sb->s_bdev))
+			return -EACCES;
 #endif
 
-	remount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);
+		remount_ro = (fc->sb_flags & SB_RDONLY) && !sb_rdonly(sb);
+	}
 
 	if (remount_ro) {
 		if (!hlist_empty(&sb->s_pins)) {
@@ -870,13 +877,14 @@ int do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)
 				return 0;
 			if (sb->s_writers.frozen != SB_UNFROZEN)
 				return -EBUSY;
-			remount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);
+			remount_ro = !sb_rdonly(sb);
 		}
 	}
 	shrink_dcache_sb(sb);
 
-	/* If we are remounting RDONLY and current sb is read/write,
-	   make sure there are no rw files opened */
+	/* If we are reconfiguring to RDONLY and current sb is read/write,
+	 * make sure there are no files open for writing.
+	 */
 	if (remount_ro) {
 		if (force) {
 			sb->s_readonly_remount = 1;
@@ -888,17 +896,17 @@ int do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)
 		}
 	}
 
-	if (sb->s_op->remount_fs) {
-		retval = sb->s_op->remount_fs(sb, &sb_flags, data);
-		if (retval) {
-			if (!force)
-				goto cancel_readonly;
-			/* If forced remount, go ahead despite any errors */
-			WARN(1, "forced remount of a %s fs returned %i\n",
-			     sb->s_type->name, retval);
-		}
+	retval = legacy_reconfigure(fc);
+	if (retval) {
+		if (!force)
+			goto cancel_readonly;
+		/* If forced remount, go ahead despite any errors */
+		WARN(1, "forced remount of a %s fs returned %i\n",
+		     sb->s_type->name, retval);
 	}
-	sb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (sb_flags & MS_RMT_MASK);
+
+	WRITE_ONCE(sb->s_flags, ((sb->s_flags & ~fc->sb_flags_mask) |
+				 (fc->sb_flags & fc->sb_flags_mask)));
 	/* Needs to be ordered wrt mnt_is_readonly() */
 	smp_wmb();
 	sb->s_readonly_remount = 0;
@@ -925,10 +933,15 @@ static void do_emergency_remount_callback(struct super_block *sb)
 	down_write(&sb->s_umount);
 	if (sb->s_root && sb->s_bdev && (sb->s_flags & SB_BORN) &&
 	    !sb_rdonly(sb)) {
-		/*
-		 * What lock protects sb->s_flags??
-		 */
-		do_remount_sb(sb, SB_RDONLY, NULL, 1);
+		struct fs_context *fc;
+
+		fc = fs_context_for_reconfigure(sb->s_root,
+					SB_RDONLY | SB_FORCE, SB_RDONLY);
+		if (!IS_ERR(fc)) {
+			if (parse_monolithic_mount_data(fc, NULL) == 0)
+				(void)reconfigure_super(fc);
+			put_fs_context(fc);
+		}
 	}
 	up_write(&sb->s_umount);
 }
@@ -1215,6 +1228,31 @@ struct dentry *mount_nodev(struct file_system_type *fs_type,
 }
 EXPORT_SYMBOL(mount_nodev);
 
+static int reconfigure_single(struct super_block *s,
+			      int flags, void *data)
+{
+	struct fs_context *fc;
+	int ret;
+
+	/* The caller really need to be passing fc down into mount_single(),
+	 * then a chunk of this can be removed.  [Bollocks -- AV]
+	 * Better yet, reconfiguration shouldn't happen, but rather the second
+	 * mount should be rejected if the parameters are not compatible.
+	 */
+	fc = fs_context_for_reconfigure(s->s_root, flags, MS_RMT_MASK);
+	if (IS_ERR(fc))
+		return PTR_ERR(fc);
+
+	ret = parse_monolithic_mount_data(fc, data);
+	if (ret < 0)
+		goto out;
+
+	ret = reconfigure_super(fc);
+out:
+	put_fs_context(fc);
+	return ret;
+}
+
 static int compare_single(struct super_block *s, void *p)
 {
 	return 1;
@@ -1232,13 +1270,14 @@ struct dentry *mount_single(struct file_system_type *fs_type,
 		return ERR_CAST(s);
 	if (!s->s_root) {
 		error = fill_super(s, data, flags & SB_SILENT ? 1 : 0);
-		if (error) {
-			deactivate_locked_super(s);
-			return ERR_PTR(error);
-		}
-		s->s_flags |= SB_ACTIVE;
+		if (!error)
+			s->s_flags |= SB_ACTIVE;
 	} else {
-		do_remount_sb(s, flags, data, 0);
+		error = reconfigure_single(s, flags, data);
+	}
+	if (unlikely(error)) {
+		deactivate_locked_super(s);
+		return ERR_PTR(error);
 	}
 	return dget(s->s_root);
 }
diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc0bba4da9f8..496fa58a4d2b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1327,6 +1327,7 @@ extern int send_sigurg(struct fown_struct *fown);
 
 /* These sb flags are internal to the kernel */
 #define SB_SUBMOUNT     (1<<26)
+#define SB_FORCE    	(1<<27)
 #define SB_NOSEC	(1<<28)
 #define SB_BORN		(1<<29)
 #define SB_ACTIVE	(1<<30)
* Unmerged path include/linux/fs_context.h
