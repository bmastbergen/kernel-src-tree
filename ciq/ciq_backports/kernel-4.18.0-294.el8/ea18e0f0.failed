block/diskstats: accumulate all per-cpu counters in one pass

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
commit ea18e0f0a63af9064db3d4065d90fa743ae0991b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ea18e0f0.failed

Reading /proc/diskstats iterates over all cpus for summing each field.
It's faster to sum all fields in one pass.

Hammering /proc/diskstats with fio shows 2x performance improvement:

fio --name=test --numjobs=$JOBS --filename=/proc/diskstats \
    --size=1k --bs=1k --fallocate=none --create_on_open=1 \
    --time_based=1 --runtime=10 --invalidate=0 --group_report

	  JOBS=1	JOBS=10
Before:	  7k iops	64k iops
After:	 18k iops      120k iops

Also this way code is more compact:

add/remove: 1/0 grow/shrink: 0/2 up/down: 194/-1540 (-1346)
Function                                     old     new   delta
part_stat_read_all                             -     194    +194
diskstats_show                              1344     631    -713
part_stat_show                              1219     392    -827
Total: Before=14966947, After=14965601, chg -0.01%

	Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit ea18e0f0a63af9064db3d4065d90fa743ae0991b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/genhd.c
diff --cc block/genhd.c
index b777d4d99066,9eb981f7e5a4..000000000000
--- a/block/genhd.c
+++ b/block/genhd.c
@@@ -68,7 -70,56 +68,35 @@@ void set_capacity_revalidate_and_notify
  
  EXPORT_SYMBOL_GPL(set_capacity_revalidate_and_notify);
  
 -/*
 - * Format the device name of the indicated disk into the supplied buffer and
 - * return a pointer to that same buffer for convenience.
 - */
 -char *disk_name(struct gendisk *hd, int partno, char *buf)
 -{
 -	if (!partno)
 -		snprintf(buf, BDEVNAME_SIZE, "%s", hd->disk_name);
 -	else if (isdigit(hd->disk_name[strlen(hd->disk_name)-1]))
 -		snprintf(buf, BDEVNAME_SIZE, "%sp%d", hd->disk_name, partno);
 -	else
 -		snprintf(buf, BDEVNAME_SIZE, "%s%d", hd->disk_name, partno);
 -
 -	return buf;
 -}
 -
 -const char *bdevname(struct block_device *bdev, char *buf)
 -{
 -	return disk_name(bdev->bd_disk, bdev->bd_part->partno, buf);
 -}
 -EXPORT_SYMBOL(bdevname);
  
+ #ifdef CONFIG_SMP
+ static void part_stat_read_all(struct hd_struct *part, struct disk_stats *stat)
+ {
+ 	int cpu;
+ 
+ 	memset(stat, 0, sizeof(struct disk_stats));
+ 	for_each_possible_cpu(cpu) {
+ 		struct disk_stats *ptr = per_cpu_ptr(part->dkstats, cpu);
+ 		int group;
+ 
+ 		for (group = 0; group < NR_STAT_GROUPS; group++) {
+ 			stat->nsecs[group] += ptr->nsecs[group];
+ 			stat->sectors[group] += ptr->sectors[group];
+ 			stat->ios[group] += ptr->ios[group];
+ 			stat->merges[group] += ptr->merges[group];
+ 		}
+ 
+ 		stat->io_ticks += ptr->io_ticks;
+ 		stat->time_in_queue += ptr->time_in_queue;
+ 	}
+ }
+ #else /* CONFIG_SMP */
+ static void part_stat_read_all(struct hd_struct *part, struct disk_stats *stat)
+ {
+ 	memcpy(stat, &part->dkstats, sizeof(struct disk_stats));
+ }
+ #endif /* CONFIG_SMP */
+ 
  void part_inc_in_flight(struct request_queue *q, struct hd_struct *part, int rw)
  {
  	if (queue_is_mq(q))
@@@ -1247,6 -1228,63 +1275,66 @@@ static ssize_t disk_ro_show(struct devi
  	return sprintf(buf, "%d\n", get_disk_ro(disk) ? 1 : 0);
  }
  
++<<<<<<< HEAD
++=======
+ ssize_t part_size_show(struct device *dev,
+ 		       struct device_attribute *attr, char *buf)
+ {
+ 	struct hd_struct *p = dev_to_part(dev);
+ 
+ 	return sprintf(buf, "%llu\n",
+ 		(unsigned long long)part_nr_sects_read(p));
+ }
+ 
+ ssize_t part_stat_show(struct device *dev,
+ 		       struct device_attribute *attr, char *buf)
+ {
+ 	struct hd_struct *p = dev_to_part(dev);
+ 	struct request_queue *q = part_to_disk(p)->queue;
+ 	struct disk_stats stat;
+ 	unsigned int inflight;
+ 
+ 	part_stat_read_all(p, &stat);
+ 	inflight = part_in_flight(q, p);
+ 
+ 	return sprintf(buf,
+ 		"%8lu %8lu %8llu %8u "
+ 		"%8lu %8lu %8llu %8u "
+ 		"%8u %8u %8u "
+ 		"%8lu %8lu %8llu %8u "
+ 		"%8lu %8u"
+ 		"\n",
+ 		stat.ios[STAT_READ],
+ 		stat.merges[STAT_READ],
+ 		(unsigned long long)stat.sectors[STAT_READ],
+ 		(unsigned int)div_u64(stat.nsecs[STAT_READ], NSEC_PER_MSEC),
+ 		stat.ios[STAT_WRITE],
+ 		stat.merges[STAT_WRITE],
+ 		(unsigned long long)stat.sectors[STAT_WRITE],
+ 		(unsigned int)div_u64(stat.nsecs[STAT_WRITE], NSEC_PER_MSEC),
+ 		inflight,
+ 		jiffies_to_msecs(stat.io_ticks),
+ 		jiffies_to_msecs(stat.time_in_queue),
+ 		stat.ios[STAT_DISCARD],
+ 		stat.merges[STAT_DISCARD],
+ 		(unsigned long long)stat.sectors[STAT_DISCARD],
+ 		(unsigned int)div_u64(stat.nsecs[STAT_DISCARD], NSEC_PER_MSEC),
+ 		stat.ios[STAT_FLUSH],
+ 		(unsigned int)div_u64(stat.nsecs[STAT_FLUSH], NSEC_PER_MSEC));
+ }
+ 
+ ssize_t part_inflight_show(struct device *dev, struct device_attribute *attr,
+ 			   char *buf)
+ {
+ 	struct hd_struct *p = dev_to_part(dev);
+ 	struct request_queue *q = part_to_disk(p)->queue;
+ 	unsigned int inflight[2];
+ 
+ 	part_in_flight_rw(q, p, inflight);
+ 	return sprintf(buf, "%8u %8u\n", inflight[0], inflight[1]);
+ }
+ 
++>>>>>>> ea18e0f0a63a (block/diskstats: accumulate all per-cpu counters in one pass)
  static ssize_t disk_capability_show(struct device *dev,
  				    struct device_attribute *attr, char *buf)
  {
@@@ -1499,24 -1542,32 +1590,39 @@@ static int diskstats_show(struct seq_fi
  			   "%lu %lu %lu %u "
  			   "%lu %lu %lu %u "
  			   "%u %u %u "
 -			   "%lu %lu %lu %u "
 -			   "%lu %u"
 -			   "\n",
 +			   "%lu %lu %lu %u\n",
  			   MAJOR(part_devt(hd)), MINOR(part_devt(hd)),
  			   disk_name(gp, hd->partno, buf),
- 			   part_stat_read(hd, ios[STAT_READ]),
- 			   part_stat_read(hd, merges[STAT_READ]),
- 			   part_stat_read(hd, sectors[STAT_READ]),
- 			   (unsigned int)part_stat_read_msecs(hd, STAT_READ),
- 			   part_stat_read(hd, ios[STAT_WRITE]),
- 			   part_stat_read(hd, merges[STAT_WRITE]),
- 			   part_stat_read(hd, sectors[STAT_WRITE]),
- 			   (unsigned int)part_stat_read_msecs(hd, STAT_WRITE),
+ 			   stat.ios[STAT_READ],
+ 			   stat.merges[STAT_READ],
+ 			   stat.sectors[STAT_READ],
+ 			   (unsigned int)div_u64(stat.nsecs[STAT_READ],
+ 							NSEC_PER_MSEC),
+ 			   stat.ios[STAT_WRITE],
+ 			   stat.merges[STAT_WRITE],
+ 			   stat.sectors[STAT_WRITE],
+ 			   (unsigned int)div_u64(stat.nsecs[STAT_WRITE],
+ 							NSEC_PER_MSEC),
  			   inflight,
++<<<<<<< HEAD
 +			   jiffies_to_msecs(part_stat_read(hd, io_ticks)),
 +			   jiffies_to_msecs(part_stat_read(hd, time_in_queue)),
 +			   part_stat_read(hd, ios[STAT_DISCARD]),
 +			   part_stat_read(hd, merges[STAT_DISCARD]),
 +			   part_stat_read(hd, sectors[STAT_DISCARD]),
 +			   (unsigned int)part_stat_read_msecs(hd, STAT_DISCARD)
++=======
+ 			   jiffies_to_msecs(stat.io_ticks),
+ 			   jiffies_to_msecs(stat.time_in_queue),
+ 			   stat.ios[STAT_DISCARD],
+ 			   stat.merges[STAT_DISCARD],
+ 			   stat.sectors[STAT_DISCARD],
+ 			   (unsigned int)div_u64(stat.nsecs[STAT_DISCARD],
+ 						 NSEC_PER_MSEC),
+ 			   stat.ios[STAT_FLUSH],
+ 			   (unsigned int)div_u64(stat.nsecs[STAT_FLUSH],
+ 						 NSEC_PER_MSEC)
++>>>>>>> ea18e0f0a63a (block/diskstats: accumulate all per-cpu counters in one pass)
  			);
  	}
  	disk_part_iter_exit(&piter);
* Unmerged path block/genhd.c
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index cc06a16154eb..0c1158208085 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -371,9 +371,6 @@ static inline void free_part_stats(struct hd_struct *part)
 
 #endif /* CONFIG_SMP */
 
-#define part_stat_read_msecs(part, which)				\
-	div_u64(part_stat_read(part, nsecs[which]), NSEC_PER_MSEC)
-
 #define part_stat_read_accum(part, field)				\
 	(part_stat_read(part, field[STAT_READ]) +			\
 	 part_stat_read(part, field[STAT_WRITE]) +			\
