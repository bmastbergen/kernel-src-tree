nfs: get rid of ->set_security()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit adf2314fe667565258f304a04990d334defabeaf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/adf2314f.failed

it's always either nfs_set_sb_security() or nfs_clone_sb_security(),
the choice being controlled by mount_info->cloned != NULL.  No need
to add methods, especially when both instances live right next to
the caller and are never accessed anywhere else.

	Reviewed-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit adf2314fe667565258f304a04990d334defabeaf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/super.c
diff --cc fs/nfs/super.c
index 5a0a0d311ce8,de00f89dbe6e..000000000000
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@@ -2554,52 -2550,6 +2554,55 @@@ static void nfs_get_cache_cookie(struc
  }
  #endif
  
++<<<<<<< HEAD
 +int nfs_set_sb_security(struct super_block *s, struct dentry *mntroot,
 +			struct nfs_mount_info *mount_info)
 +{
 +	int error;
 +	unsigned long kflags = 0, kflags_out = 0;
 +	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL)
 +		kflags |= SECURITY_LSM_NATIVE_LABELS;
 +
 +	error = security_sb_set_mnt_opts(s, &mount_info->parsed->lsm_opts,
 +						kflags, &kflags_out);
 +	if (error)
 +		goto err;
 +
 +	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL &&
 +		!(kflags_out & SECURITY_LSM_NATIVE_LABELS))
 +		NFS_SB(s)->caps &= ~NFS_CAP_SECURITY_LABEL;
 +err:
 +	return error;
 +}
 +EXPORT_SYMBOL_GPL(nfs_set_sb_security);
 +
 +int nfs_clone_sb_security(struct super_block *s, struct dentry *mntroot,
 +			  struct nfs_mount_info *mount_info)
 +{
 +	int error;
 +	unsigned long kflags = 0, kflags_out = 0;
 +
 +	/* clone any lsm security options from the parent to the new sb */
 +	if (d_inode(mntroot)->i_fop != &nfs_dir_operations)
 +		return -ESTALE;
 +
 +	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL)
 +		kflags |= SECURITY_LSM_NATIVE_LABELS;
 +
 +	error = security_sb_clone_mnt_opts(mount_info->cloned->sb, s, kflags,
 +			&kflags_out);
 +	if (error)
 +		return error;
 +
 +	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL &&
 +		!(kflags_out & SECURITY_LSM_NATIVE_LABELS))
 +		NFS_SB(s)->caps &= ~NFS_CAP_SECURITY_LABEL;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(nfs_clone_sb_security);
 +
++=======
++>>>>>>> adf2314fe667 (nfs: get rid of ->set_security())
  static void nfs_set_readahead(struct backing_dev_info *bdi,
  			      unsigned long iomax_pages)
  {
@@@ -2674,6 -2625,29 +2678,32 @@@ static struct dentry *nfs_fs_mount_comm
  	if (IS_ERR(mntroot))
  		goto error_splat_super;
  
++<<<<<<< HEAD
++=======
+ 
+ 	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL)
+ 		kflags |= SECURITY_LSM_NATIVE_LABELS;
+ 	if (mount_info->cloned) {
+ 		if (d_inode(mntroot)->i_fop != &nfs_dir_operations) {
+ 			error = -ESTALE;
+ 			goto error_splat_root;
+ 		}
+ 		/* clone any lsm security options from the parent to the new sb */
+ 		error = security_sb_clone_mnt_opts(mount_info->cloned->sb, s, kflags,
+ 				&kflags_out);
+ 	} else {
+ 		error = security_sb_set_mnt_opts(s, mount_info->parsed->lsm_opts,
+ 							kflags, &kflags_out);
+ 	}
+ 	if (error)
+ 		goto error_splat_root;
+ 	if (NFS_SB(s)->caps & NFS_CAP_SECURITY_LABEL &&
+ 		!(kflags_out & SECURITY_LSM_NATIVE_LABELS))
+ 		NFS_SB(s)->caps &= ~NFS_CAP_SECURITY_LABEL;
+ 	if (error)
+ 		goto error_splat_root;
+ 
++>>>>>>> adf2314fe667 (nfs: get rid of ->set_security())
  	s->s_flags |= SB_ACTIVE;
  
  out:
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index feae10c2f600..a59ef0c9b22b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -137,7 +137,6 @@ struct nfs_mount_request {
 
 struct nfs_mount_info {
 	unsigned int inherited_bsize;
-	int (*set_security)(struct super_block *, struct dentry *, struct nfs_mount_info *);
 	struct nfs_parsed_mount_data *parsed;
 	struct nfs_clone_mount *cloned;
 	struct nfs_server *server;
@@ -391,8 +390,6 @@ extern struct file_system_type nfs4_referral_fs_type;
 #endif
 bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);
 struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *);
-int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
-int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
 void nfs_kill_super(struct super_block *);
 
diff --git a/fs/nfs/namespace.c b/fs/nfs/namespace.c
index 0dbf0e798502..9b57bc24f471 100644
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@ -234,7 +234,6 @@ struct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,
 	};
 	struct nfs_mount_info mount_info = {
 		.inherited_bsize = sb->s_blocksize_bits,
-		.set_security = nfs_clone_sb_security,
 		.cloned = &mountdata,
 		.mntfh = fh,
 		.nfs_mod = NFS_SB(sb)->nfs_client->cl_nfs_mod,
diff --git a/fs/nfs/nfs4super.c b/fs/nfs/nfs4super.c
index b5c4630cd799..a5019fa21e13 100644
--- a/fs/nfs/nfs4super.c
+++ b/fs/nfs/nfs4super.c
@@ -200,8 +200,6 @@ struct dentry *nfs4_try_mount(int flags, const char *dev_name,
 	struct nfs_parsed_mount_data *data = mount_info->parsed;
 	struct dentry *res;
 
-	mount_info->set_security = nfs_set_sb_security;
-
 	dfprintk(MOUNT, "--> nfs4_try_mount()\n");
 
 	res = do_nfs4_mount(nfs4_create_server(mount_info),
@@ -223,7 +221,6 @@ static struct dentry *nfs4_referral_mount(struct file_system_type *fs_type,
 {
 	struct nfs_clone_mount *data = raw_data;
 	struct nfs_mount_info mount_info = {
-		.set_security = nfs_clone_sb_security,
 		.cloned = data,
 		.nfs_mod = &nfs_v4,
 	};
* Unmerged path fs/nfs/super.c
