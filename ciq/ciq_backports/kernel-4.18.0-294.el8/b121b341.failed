bpf: Add PTR_TO_BTF_ID_OR_NULL support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yonghong Song <yhs@fb.com>
commit b121b341e5983bdccf7a5d6cf9236a45c965a31f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/b121b341.failed

Add bpf_reg_type PTR_TO_BTF_ID_OR_NULL support.
For tracing/iter program, the bpf program context
definition, e.g., for previous bpf_map target, looks like
  struct bpf_iter__bpf_map {
    struct bpf_iter_meta *meta;
    struct bpf_map *map;
  };

The kernel guarantees that meta is not NULL, but
map pointer maybe NULL. The NULL map indicates that all
objects have been traversed, so bpf program can take
proper action, e.g., do final aggregation and/or send
final report to user space.

Add btf_id_or_null_non0_off to prog->aux structure, to
indicate that if the context access offset is not 0,
set to PTR_TO_BTF_ID_OR_NULL instead of PTR_TO_BTF_ID.
This bit is set for tracing/iter program.

	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20200509175912.2476576-1-yhs@fb.com
(cherry picked from commit b121b341e5983bdccf7a5d6cf9236a45c965a31f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/verifier.c
diff --cc include/linux/bpf.h
index 52b8376d90fb,cf4b6e44f2bc..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -666,27 -652,26 +667,36 @@@ struct bpf_prog_aux 
  	u32 stack_depth;
  	u32 id;
  	u32 func_cnt; /* used by non-func prog as the number of func progs */
 -	u32 func_idx; /* 0 for non-func prog, the index in func array for func prog */
 -	u32 attach_btf_id; /* in-kernel BTF type id to attach to */
 -	struct bpf_prog *linked_prog;
 -	bool verifier_zext; /* Zero extensions has been inserted by verifier. */
 +	RH_KABI_BROKEN_INSERT(u32 func_idx) /* 0 for non-func prog, the index in func array for func prog */
 +	RH_KABI_BROKEN_INSERT(u32 attach_btf_id) /* in-kernel BTF type id to attach to */
 +	RH_KABI_BROKEN_INSERT(struct bpf_prog *linked_prog)
 +	RH_KABI_BROKEN_INSERT(bool verifier_zext) /* Zero extensions has been inserted by verifier. */
  	bool offload_requested;
++<<<<<<< HEAD
 +	RH_KABI_BROKEN_INSERT(bool attach_btf_trace) /* true if attaching to BTF-enabled raw tp */
 +	RH_KABI_BROKEN_INSERT(bool func_proto_unreliable)
 +	RH_KABI_BROKEN_INSERT(enum bpf_tramp_prog_type trampoline_prog_type)
 +	RH_KABI_BROKEN_INSERT(struct bpf_trampoline *trampoline)
 +	RH_KABI_BROKEN_INSERT(struct hlist_node tramp_hlist)
++=======
+ 	bool attach_btf_trace; /* true if attaching to BTF-enabled raw tp */
+ 	bool func_proto_unreliable;
+ 	bool btf_id_or_null_non0_off;
+ 	enum bpf_tramp_prog_type trampoline_prog_type;
+ 	struct bpf_trampoline *trampoline;
+ 	struct hlist_node tramp_hlist;
++>>>>>>> b121b341e598 (bpf: Add PTR_TO_BTF_ID_OR_NULL support)
  	/* BTF_KIND_FUNC_PROTO for valid attach_btf_id */
 -	const struct btf_type *attach_func_proto;
 +	RH_KABI_BROKEN_INSERT(const struct btf_type *attach_func_proto)
  	/* function name for valid attach_btf_id */
 -	const char *attach_func_name;
 +	RH_KABI_BROKEN_INSERT(const char *attach_func_name)
  	struct bpf_prog **func;
  	void *jit_data; /* JIT specific data. arch dependent */
 -	struct bpf_jit_poke_descriptor *poke_tab;
 -	u32 size_poke_tab;
 -	struct bpf_ksym ksym;
 +	RH_KABI_BROKEN_INSERT(struct bpf_jit_poke_descriptor *poke_tab)
 +	RH_KABI_BROKEN_INSERT(u32 size_poke_tab)
 +	RH_KABI_BROKEN_REMOVE(struct latch_tree_node ksym_tnode)
 +	RH_KABI_BROKEN_REMOVE(struct list_head ksym_lnode)
 +	RH_KABI_BROKEN_INSERT(struct bpf_ksym ksym)
  	const struct bpf_prog_ops *ops;
  	struct bpf_map **used_maps;
  	struct bpf_prog *prog;
diff --cc kernel/bpf/verifier.c
index 94c907288a2e,36b2a38a06fe..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -10650,6 -10634,23 +10657,26 @@@ static int check_attach_btf_id(struct b
  		prog->aux->attach_func_proto = t;
  		prog->aux->attach_btf_trace = true;
  		return 0;
++<<<<<<< HEAD
++=======
+ 	case BPF_TRACE_ITER:
+ 		if (!btf_type_is_func(t)) {
+ 			verbose(env, "attach_btf_id %u is not a function\n",
+ 				btf_id);
+ 			return -EINVAL;
+ 		}
+ 		t = btf_type_by_id(btf, t->type);
+ 		if (!btf_type_is_func_proto(t))
+ 			return -EINVAL;
+ 		prog->aux->attach_func_name = tname;
+ 		prog->aux->attach_func_proto = t;
+ 		if (!bpf_iter_prog_supported(prog))
+ 			return -EINVAL;
+ 		prog->aux->btf_id_or_null_non0_off = true;
+ 		ret = btf_distill_func_proto(&env->log, btf, t,
+ 					     tname, &fmodel);
+ 		return ret;
++>>>>>>> b121b341e598 (bpf: Add PTR_TO_BTF_ID_OR_NULL support)
  	default:
  		if (!prog_extension)
  			return -EINVAL;
* Unmerged path include/linux/bpf.h
diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c
index 4e561d0a8a51..14009c425dd8 100644
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@ -3791,7 +3791,10 @@ bool btf_ctx_access(int off, int size, enum bpf_access_type type,
 		return true;
 
 	/* this is a pointer to another type */
-	info->reg_type = PTR_TO_BTF_ID;
+	if (off != 0 && prog->aux->btf_id_or_null_non0_off)
+		info->reg_type = PTR_TO_BTF_ID_OR_NULL;
+	else
+		info->reg_type = PTR_TO_BTF_ID;
 
 	if (tgt_prog) {
 		ret = btf_translate_to_vmlinux(log, btf, t, tgt_prog->type, arg);
* Unmerged path kernel/bpf/verifier.c
