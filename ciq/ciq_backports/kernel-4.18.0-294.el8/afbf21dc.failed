bpf: Support readonly/readwrite buffers in verifier

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yonghong Song <yhs@fb.com>
commit afbf21dce668ef59482037596eaffbe5041e094c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/afbf21dc.failed

Readonly and readwrite buffer register states
are introduced. Totally four states,
PTR_TO_RDONLY_BUF[_OR_NULL] and PTR_TO_RDWR_BUF[_OR_NULL]
are supported. As suggested by their respective
names, PTR_TO_RDONLY_BUF[_OR_NULL] are for
readonly buffers and PTR_TO_RDWR_BUF[_OR_NULL]
for read/write buffers.

These new register states will be used
by later bpf map element iterator.

New register states share some similarity to
PTR_TO_TP_BUFFER as it will calculate accessed buffer
size during verification time. The accessed buffer
size will be later compared to other metrics during
later attach/link_create time.

Similar to reg_state PTR_TO_BTF_ID_OR_NULL in bpf
iterator programs, PTR_TO_RDONLY_BUF_OR_NULL or
PTR_TO_RDWR_BUF_OR_NULL reg_types can be set at
prog->aux->bpf_ctx_arg_aux, and bpf verifier will
retrieve the values during btf_ctx_access().
Later bpf map element iterator implementation
will show how such information will be assigned
during target registeration time.

The verifier is also enhanced such that PTR_TO_RDONLY_BUF
can be passed to ARG_PTR_TO_MEM[_OR_NULL] helper argument, and
PTR_TO_RDWR_BUF can be passed to ARG_PTR_TO_MEM[_OR_NULL] or
ARG_PTR_TO_UNINIT_MEM.

	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200723184111.590274-1-yhs@fb.com
(cherry picked from commit afbf21dce668ef59482037596eaffbe5041e094c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/verifier.c
diff --cc include/linux/bpf.h
index 2171a69591bc,f9c4bb08f616..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -331,6 -350,13 +331,16 @@@ enum bpf_reg_type 
  	PTR_TO_TP_BUFFER,	 /* reg points to a writable raw tp's buffer */
  	PTR_TO_XDP_SOCK,	 /* reg points to struct xdp_sock */
  	PTR_TO_BTF_ID,		 /* reg points to kernel struct */
++<<<<<<< HEAD
++=======
+ 	PTR_TO_BTF_ID_OR_NULL,	 /* reg points to kernel struct or NULL */
+ 	PTR_TO_MEM,		 /* reg points to valid memory region */
+ 	PTR_TO_MEM_OR_NULL,	 /* reg points to valid memory region or NULL */
+ 	PTR_TO_RDONLY_BUF,	 /* reg points to a readonly buffer */
+ 	PTR_TO_RDONLY_BUF_OR_NULL, /* reg points to a readonly buffer or NULL */
+ 	PTR_TO_RDWR_BUF,	 /* reg points to a read/write buffer */
+ 	PTR_TO_RDWR_BUF_OR_NULL, /* reg points to a read/write buffer or NULL */
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  };
  
  /* The information passed from prog-specific *_is_valid_access
@@@ -666,27 -695,29 +676,38 @@@ struct bpf_prog_aux 
  	u32 stack_depth;
  	u32 id;
  	u32 func_cnt; /* used by non-func prog as the number of func progs */
++<<<<<<< HEAD
 +	RH_KABI_BROKEN_INSERT(u32 func_idx) /* 0 for non-func prog, the index in func array for func prog */
 +	RH_KABI_BROKEN_INSERT(u32 attach_btf_id) /* in-kernel BTF type id to attach to */
 +	RH_KABI_BROKEN_INSERT(struct bpf_prog *linked_prog)
 +	RH_KABI_BROKEN_INSERT(bool verifier_zext) /* Zero extensions has been inserted by verifier. */
++=======
+ 	u32 func_idx; /* 0 for non-func prog, the index in func array for func prog */
+ 	u32 attach_btf_id; /* in-kernel BTF type id to attach to */
+ 	u32 ctx_arg_info_size;
+ 	u32 max_rdonly_access;
+ 	u32 max_rdwr_access;
+ 	const struct bpf_ctx_arg_aux *ctx_arg_info;
+ 	struct bpf_prog *linked_prog;
+ 	bool verifier_zext; /* Zero extensions has been inserted by verifier. */
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  	bool offload_requested;
 -	bool attach_btf_trace; /* true if attaching to BTF-enabled raw tp */
 -	bool func_proto_unreliable;
 -	enum bpf_tramp_prog_type trampoline_prog_type;
 -	struct bpf_trampoline *trampoline;
 -	struct hlist_node tramp_hlist;
 +	RH_KABI_BROKEN_INSERT(bool attach_btf_trace) /* true if attaching to BTF-enabled raw tp */
 +	RH_KABI_BROKEN_INSERT(bool func_proto_unreliable)
 +	RH_KABI_BROKEN_INSERT(enum bpf_tramp_prog_type trampoline_prog_type)
 +	RH_KABI_BROKEN_INSERT(struct bpf_trampoline *trampoline)
 +	RH_KABI_BROKEN_INSERT(struct hlist_node tramp_hlist)
  	/* BTF_KIND_FUNC_PROTO for valid attach_btf_id */
 -	const struct btf_type *attach_func_proto;
 +	RH_KABI_BROKEN_INSERT(const struct btf_type *attach_func_proto)
  	/* function name for valid attach_btf_id */
 -	const char *attach_func_name;
 +	RH_KABI_BROKEN_INSERT(const char *attach_func_name)
  	struct bpf_prog **func;
  	void *jit_data; /* JIT specific data. arch dependent */
 -	struct bpf_jit_poke_descriptor *poke_tab;
 -	u32 size_poke_tab;
 -	struct bpf_ksym ksym;
 +	RH_KABI_BROKEN_INSERT(struct bpf_jit_poke_descriptor *poke_tab)
 +	RH_KABI_BROKEN_INSERT(u32 size_poke_tab)
 +	RH_KABI_BROKEN_REMOVE(struct latch_tree_node ksym_tnode)
 +	RH_KABI_BROKEN_REMOVE(struct list_head ksym_lnode)
 +	RH_KABI_BROKEN_INSERT(struct bpf_ksym ksym)
  	const struct bpf_prog_ops *ops;
  	struct bpf_map **used_maps;
  	struct bpf_prog *prog;
diff --cc kernel/bpf/verifier.c
index b8aec186e303,8d6979db48d8..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -414,7 -407,11 +414,15 @@@ static bool reg_type_may_be_null(enum b
  	return type == PTR_TO_MAP_VALUE_OR_NULL ||
  	       type == PTR_TO_SOCKET_OR_NULL ||
  	       type == PTR_TO_SOCK_COMMON_OR_NULL ||
++<<<<<<< HEAD
 +	       type == PTR_TO_TCP_SOCK_OR_NULL;
++=======
+ 	       type == PTR_TO_TCP_SOCK_OR_NULL ||
+ 	       type == PTR_TO_BTF_ID_OR_NULL ||
+ 	       type == PTR_TO_MEM_OR_NULL ||
+ 	       type == PTR_TO_RDONLY_BUF_OR_NULL ||
+ 	       type == PTR_TO_RDWR_BUF_OR_NULL;
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  }
  
  static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)
@@@ -499,6 -502,13 +507,16 @@@ static const char * const reg_type_str[
  	[PTR_TO_TP_BUFFER]	= "tp_buffer",
  	[PTR_TO_XDP_SOCK]	= "xdp_sock",
  	[PTR_TO_BTF_ID]		= "ptr_",
++<<<<<<< HEAD
++=======
+ 	[PTR_TO_BTF_ID_OR_NULL]	= "ptr_or_null_",
+ 	[PTR_TO_MEM]		= "mem",
+ 	[PTR_TO_MEM_OR_NULL]	= "mem_or_null",
+ 	[PTR_TO_RDONLY_BUF]	= "rdonly_buf",
+ 	[PTR_TO_RDONLY_BUF_OR_NULL] = "rdonly_buf_or_null",
+ 	[PTR_TO_RDWR_BUF]	= "rdwr_buf",
+ 	[PTR_TO_RDWR_BUF_OR_NULL] = "rdwr_buf_or_null",
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  };
  
  static char slot_type_char[] = {
@@@ -2155,6 -2178,11 +2173,14 @@@ static bool is_spillable_regtype(enum b
  	case PTR_TO_TCP_SOCK_OR_NULL:
  	case PTR_TO_XDP_SOCK:
  	case PTR_TO_BTF_ID:
++<<<<<<< HEAD
++=======
+ 	case PTR_TO_BTF_ID_OR_NULL:
+ 	case PTR_TO_RDONLY_BUF:
+ 	case PTR_TO_RDONLY_BUF_OR_NULL:
+ 	case PTR_TO_RDWR_BUF:
+ 	case PTR_TO_RDWR_BUF_OR_NULL:
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  		return true;
  	default:
  		return false;
@@@ -3331,6 -3468,26 +3391,29 @@@ static int check_mem_access(struct bpf_
  	} else if (reg->type == PTR_TO_BTF_ID) {
  		err = check_ptr_to_btf_access(env, regs, regno, off, size, t,
  					      value_regno);
++<<<<<<< HEAD
++=======
+ 	} else if (reg->type == CONST_PTR_TO_MAP) {
+ 		err = check_ptr_to_map_access(env, regs, regno, off, size, t,
+ 					      value_regno);
+ 	} else if (reg->type == PTR_TO_RDONLY_BUF) {
+ 		if (t == BPF_WRITE) {
+ 			verbose(env, "R%d cannot write into %s\n",
+ 				regno, reg_type_str[reg->type]);
+ 			return -EACCES;
+ 		}
+ 		err = check_buffer_access(env, reg, regno, off, size, "rdonly",
+ 					  false,
+ 					  &env->prog->aux->max_rdonly_access);
+ 		if (!err && value_regno >= 0)
+ 			mark_reg_unknown(env, regs, value_regno);
+ 	} else if (reg->type == PTR_TO_RDWR_BUF) {
+ 		err = check_buffer_access(env, reg, regno, off, size, "rdwr",
+ 					  false,
+ 					  &env->prog->aux->max_rdwr_access);
+ 		if (!err && t == BPF_READ && value_regno >= 0)
+ 			mark_reg_unknown(env, regs, value_regno);
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  	} else {
  		verbose(env, "R%d invalid mem access '%s'\n", regno,
  			reg_type_str[reg->type]);
@@@ -3568,6 -3725,22 +3651,25 @@@ static int check_helper_mem_access(stru
  			return -EACCES;
  		return check_map_access(env, regno, reg->off, access_size,
  					zero_size_allowed);
++<<<<<<< HEAD
++=======
+ 	case PTR_TO_MEM:
+ 		return check_mem_region_access(env, regno, reg->off,
+ 					       access_size, reg->mem_size,
+ 					       zero_size_allowed);
+ 	case PTR_TO_RDONLY_BUF:
+ 		if (meta && meta->raw_mode)
+ 			return -EACCES;
+ 		return check_buffer_access(env, reg, regno, reg->off,
+ 					   access_size, zero_size_allowed,
+ 					   "rdonly",
+ 					   &env->prog->aux->max_rdonly_access);
+ 	case PTR_TO_RDWR_BUF:
+ 		return check_buffer_access(env, reg, regno, reg->off,
+ 					   access_size, zero_size_allowed,
+ 					   "rdwr",
+ 					   &env->prog->aux->max_rdwr_access);
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  	default: /* scalar_value|ptr_to_stack or invalid ptr */
  		return check_stack_boundary(env, regno, access_size,
  					    zero_size_allowed, meta);
@@@ -3806,6 -4005,9 +3908,12 @@@ static int check_func_arg(struct bpf_ve
  			/* final test in check_stack_boundary() */;
  		else if (!type_is_pkt_pointer(type) &&
  			 type != PTR_TO_MAP_VALUE &&
++<<<<<<< HEAD
++=======
+ 			 type != PTR_TO_MEM &&
+ 			 type != PTR_TO_RDONLY_BUF &&
+ 			 type != PTR_TO_RDWR_BUF &&
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  			 type != expected_type)
  			goto err_type;
  		meta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;
@@@ -6625,6 -6877,14 +6733,17 @@@ static void mark_ptr_or_null_reg(struc
  			reg->type = PTR_TO_SOCK_COMMON;
  		} else if (reg->type == PTR_TO_TCP_SOCK_OR_NULL) {
  			reg->type = PTR_TO_TCP_SOCK;
++<<<<<<< HEAD
++=======
+ 		} else if (reg->type == PTR_TO_BTF_ID_OR_NULL) {
+ 			reg->type = PTR_TO_BTF_ID;
+ 		} else if (reg->type == PTR_TO_MEM_OR_NULL) {
+ 			reg->type = PTR_TO_MEM;
+ 		} else if (reg->type == PTR_TO_RDONLY_BUF_OR_NULL) {
+ 			reg->type = PTR_TO_RDONLY_BUF;
+ 		} else if (reg->type == PTR_TO_RDWR_BUF_OR_NULL) {
+ 			reg->type = PTR_TO_RDWR_BUF;
++>>>>>>> afbf21dce668 (bpf: Support readonly/readwrite buffers in verifier)
  		}
  		if (is_null) {
  			/* We don't need id and ref_obj_id from this point
* Unmerged path include/linux/bpf.h
diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c
index 52afb4b50a36..84341f0b4000 100644
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@ -3767,6 +3767,19 @@ bool btf_ctx_access(int off, int size, enum bpf_access_type type,
 			btf_kind_str[BTF_INFO_KIND(t->info)]);
 		return false;
 	}
+
+	/* check for PTR_TO_RDONLY_BUF_OR_NULL or PTR_TO_RDWR_BUF_OR_NULL */
+	for (i = 0; i < prog->aux->ctx_arg_info_size; i++) {
+		const struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];
+
+		if (ctx_arg_info->offset == off &&
+		    (ctx_arg_info->reg_type == PTR_TO_RDONLY_BUF_OR_NULL ||
+		     ctx_arg_info->reg_type == PTR_TO_RDWR_BUF_OR_NULL)) {
+			info->reg_type = ctx_arg_info->reg_type;
+			return true;
+		}
+	}
+
 	if (t->type == 0)
 		/* This is a pointer to void.
 		 * It is the same as scalar from the verifier safety pov.
* Unmerged path kernel/bpf/verifier.c
