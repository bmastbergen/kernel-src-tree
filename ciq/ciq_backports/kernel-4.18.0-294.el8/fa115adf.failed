s390/qeth: Detect PNSO OC3 capability

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Alexandra Winter <wintera@linux.ibm.com>
commit fa115adff2c16b02b2baaf9ed1869c0115cd3ca4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/fa115adf.failed

This patch detects whether device-to-bridge-notification, provided
by the Perform Network Subchannel Operation (PNSO) operation code
ADDR_INFO (OC3), is supported by this card. A following patch will
map this to the learning_sync bridgeport flag, so we store it in
priv->brport_hw_features in bridgeport flag format.

Only IQD cards provide PNSO.
There is a feature bit to indicate whether the machine provides OC3,
unfortunately it is not set on old machines.
So PNSO is called to find out. As this will disable notification
and is exclusive with bridgeport_notification, this must be done
during card initialisation before previous settings are restored.

PNSO functionality requires some configuration values that are added to
the qeth_card.info structure. Some helper functions are defined to fill
them out when the card is brought online and some other places are
adapted, that can also benefit from these fields.

	Signed-off-by: Alexandra Winter <wintera@linux.ibm.com>
	Reviewed-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fa115adff2c16b02b2baaf9ed1869c0115cd3ca4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_core_main.c
#	drivers/s390/net/qeth_l2_main.c
diff --cc drivers/s390/net/qeth_core.h
index 7c464101b646,14c583b5ea11..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -775,6 -785,11 +782,14 @@@ struct qeth_switch_info 
  	__u32 settings;
  };
  
++<<<<<<< HEAD
++=======
+ struct qeth_priv {
+ 	unsigned int rx_copybreak;
+ 	u32 brport_hw_features;
+ };
+ 
++>>>>>>> fa115adff2c1 (s390/qeth: Detect PNSO OC3 capability)
  #define QETH_NAPI_WEIGHT NAPI_POLL_WEIGHT
  
  struct qeth_card {
diff --cc drivers/s390/net/qeth_core_main.c
index 543f78a58fff,7cd0cbf8a4f0..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -4962,24 -5011,31 +4956,52 @@@ out
  	return;
  }
  
++<<<<<<< HEAD
 +static void qeth_qdio_establish_cq(struct qeth_card *card,
 +				   struct qdio_buffer **in_sbal_ptrs,
 +				   void (**queue_start_poll)
 +					(struct ccw_device *, int,
 +					 unsigned long))
 +{
 +	int i;
 +
 +	if (card->options.cq == QETH_CQ_ENABLED) {
 +		int offset = QDIO_MAX_BUFFERS_PER_Q *
 +			     (card->qdio.no_in_queues - 1);
 +
 +		for (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; i++)
 +			in_sbal_ptrs[offset + i] =
 +				card->qdio.c_q->bufs[i].buffer;
 +
 +		queue_start_poll[card->qdio.no_in_queues - 1] = NULL;
 +	}
++=======
+ static void qeth_read_ccw_conf_data(struct qeth_card *card)
+ {
+ 	struct qeth_card_info *info = &card->info;
+ 	struct ccw_device *cdev = CARD_DDEV(card);
+ 	struct ccw_dev_id dev_id;
+ 
+ 	QETH_CARD_TEXT(card, 2, "ccwconfd");
+ 	ccw_device_get_id(cdev, &dev_id);
+ 
+ 	info->ddev_devno = dev_id.devno;
+ 	info->ids_valid = !ccw_device_get_cssid(cdev, &info->cssid) &&
+ 			  !ccw_device_get_iid(cdev, &info->iid) &&
+ 			  !ccw_device_get_chid(cdev, 0, &info->chid);
+ 	info->ssid = dev_id.ssid;
+ 
+ 	dev_info(&card->gdev->dev, "CHID: %x CHPID: %x\n",
+ 		 info->chid, info->chpid);
+ 
+ 	QETH_CARD_TEXT_(card, 3, "devn%x", info->ddev_devno);
+ 	QETH_CARD_TEXT_(card, 3, "cssid:%x", info->cssid);
+ 	QETH_CARD_TEXT_(card, 3, "iid:%x", info->iid);
+ 	QETH_CARD_TEXT_(card, 3, "ssid:%x", info->ssid);
+ 	QETH_CARD_TEXT_(card, 3, "chpid:%x", info->chpid);
+ 	QETH_CARD_TEXT_(card, 3, "chid:%x", info->chid);
+ 	QETH_CARD_TEXT_(card, 3, "idval%x", info->ids_valid);
++>>>>>>> fa115adff2c1 (s390/qeth: Detect PNSO OC3 capability)
  }
  
  static int qeth_qdio_establish(struct qeth_card *card)
diff --cc drivers/s390/net/qeth_l2_main.c
index 88261c8e41f6,7cba3d0035bf..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -20,6 -21,8 +21,11 @@@
  #include <linux/list.h>
  #include <linux/hash.h>
  #include <linux/hashtable.h>
++<<<<<<< HEAD
++=======
+ #include <asm/chsc.h>
+ #include <asm/css_chars.h>
++>>>>>>> fa115adff2c1 (s390/qeth: Detect PNSO OC3 capability)
  #include <asm/setup.h>
  #include "qeth_core.h"
  #include "qeth_l2.h"
@@@ -787,9 -828,49 +793,53 @@@ static void qeth_l2_setup_bridgeport_at
  	}
  }
  
++<<<<<<< HEAD
 +static int qeth_l2_set_online(struct ccwgroup_device *gdev)
++=======
+ /**
+  *	qeth_l2_detect_dev2br_support() -
+  *	Detect whether this card supports 'dev to bridge fdb network address
+  *	change notification' and thus can support the learning_sync bridgeport
+  *	attribute
+  *	@card: qeth_card structure pointer
+  *
+  *	This is a destructive test and must be called before dev2br or
+  *	bridgeport address notification is enabled!
+  */
+ static void qeth_l2_detect_dev2br_support(struct qeth_card *card)
+ {
+ 	struct qeth_priv *priv = netdev_priv(card->dev);
+ 	bool dev2br_supported;
+ 	int rc;
+ 
+ 	QETH_CARD_TEXT(card, 2, "d2brsup");
+ 	if (!IS_IQD(card))
+ 		return;
+ 
+ 	/* dev2br requires valid cssid,iid,chid */
+ 	if (!card->info.ids_valid) {
+ 		dev2br_supported = false;
+ 	} else if (css_general_characteristics.enarf) {
+ 		dev2br_supported = true;
+ 	} else {
+ 		/* Old machines don't have the feature bit:
+ 		 * Probe by testing whether a disable succeeds
+ 		 */
+ 		rc = qeth_l2_pnso(card, PNSO_OC_NET_ADDR_INFO, 0, NULL, NULL);
+ 		dev2br_supported = !rc;
+ 	}
+ 	QETH_CARD_TEXT_(card, 2, "D2Bsup%02x", dev2br_supported);
+ 
+ 	if (dev2br_supported)
+ 		priv->brport_hw_features |= BR_LEARNING_SYNC;
+ 	else
+ 		priv->brport_hw_features &= ~BR_LEARNING_SYNC;
+ }
+ 
+ static int qeth_l2_set_online(struct qeth_card *card)
++>>>>>>> fa115adff2c1 (s390/qeth: Detect PNSO OC3 capability)
  {
 -	struct ccwgroup_device *gdev = card->gdev;
 +	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
  	struct net_device *dev = card->dev;
  	int rc = 0;
  	bool carrier_ok;
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_core_main.c
* Unmerged path drivers/s390/net/qeth_l2_main.c
