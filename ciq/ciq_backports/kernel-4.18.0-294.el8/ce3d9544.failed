net: add sock_set_keepalive

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Christoph Hellwig <hch@lst.de>
commit ce3d9544cecacd40389c399d2b7ca31acc533b70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/ce3d9544.failed

Add a helper to directly set the SO_KEEPALIVE sockopt from kernel space
without going through a fake uaccess.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ce3d9544cecacd40389c399d2b7ca31acc533b70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
#	net/core/sock.c
diff --cc include/net/sock.h
index 4a0ac3143804,dc08c176238f..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -2615,7 -2688,12 +2615,12 @@@ static inline bool sk_dev_equal_l3scope
  
  void sock_def_readable(struct sock *sk);
  
 -int sock_bindtoindex(struct sock *sk, int ifindex);
 -void sock_enable_timestamps(struct sock *sk);
  void sock_no_linger(struct sock *sk);
++<<<<<<< HEAD
++=======
+ void sock_set_keepalive(struct sock *sk);
+ void sock_set_priority(struct sock *sk, u32 priority);
++>>>>>>> ce3d9544ceca (net: add sock_set_keepalive)
  void sock_set_reuseaddr(struct sock *sk);
 -void sock_set_sndtimeo(struct sock *sk, s64 secs);
  
  #endif	/* _SOCK_H */
diff --cc net/core/sock.c
index 18458e268ca8,728f5fb156a0..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -708,6 -738,57 +708,60 @@@ void sock_no_linger(struct sock *sk
  }
  EXPORT_SYMBOL(sock_no_linger);
  
++<<<<<<< HEAD
++=======
+ void sock_set_priority(struct sock *sk, u32 priority)
+ {
+ 	lock_sock(sk);
+ 	sk->sk_priority = priority;
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_priority);
+ 
+ void sock_set_sndtimeo(struct sock *sk, s64 secs)
+ {
+ 	lock_sock(sk);
+ 	if (secs && secs < MAX_SCHEDULE_TIMEOUT / HZ - 1)
+ 		sk->sk_sndtimeo = secs * HZ;
+ 	else
+ 		sk->sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_sndtimeo);
+ 
+ static void __sock_set_timestamps(struct sock *sk, bool val, bool new, bool ns)
+ {
+ 	if (val)  {
+ 		sock_valbool_flag(sk, SOCK_TSTAMP_NEW, new);
+ 		sock_valbool_flag(sk, SOCK_RCVTSTAMPNS, ns);
+ 		sock_set_flag(sk, SOCK_RCVTSTAMP);
+ 		sock_enable_timestamp(sk, SOCK_TIMESTAMP);
+ 	} else {
+ 		sock_reset_flag(sk, SOCK_RCVTSTAMP);
+ 		sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
+ 		sock_reset_flag(sk, SOCK_TSTAMP_NEW);
+ 	}
+ }
+ 
+ void sock_enable_timestamps(struct sock *sk)
+ {
+ 	lock_sock(sk);
+ 	__sock_set_timestamps(sk, true, false, true);
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_enable_timestamps);
+ 
+ void sock_set_keepalive(struct sock *sk)
+ {
+ 	lock_sock(sk);
+ 	if (sk->sk_prot->keepalive)
+ 		sk->sk_prot->keepalive(sk, true);
+ 	sock_valbool_flag(sk, SOCK_KEEPOPEN, true);
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_keepalive);
+ 
++>>>>>>> ce3d9544ceca (net: add sock_set_keepalive)
  /*
   *	This is meant for all protocols to use and covers goings on
   *	at the socket level. Everything here is generic.
diff --git a/fs/dlm/lowcomms.c b/fs/dlm/lowcomms.c
index 61aee4538464..0650ac3e509f 100644
--- a/fs/dlm/lowcomms.c
+++ b/fs/dlm/lowcomms.c
@@ -1265,11 +1265,7 @@ static struct socket *tcp_create_listen_sock(struct connection *con,
 		con->sock = NULL;
 		goto create_out;
 	}
-	result = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,
-				 (char *)&one, sizeof(one));
-	if (result < 0) {
-		log_print("Set keepalive failed: %d", result);
-	}
+	sock_set_keepalive(sock->sk);
 
 	result = sock->ops->listen(sock, 5);
 	if (result < 0) {
* Unmerged path include/net/sock.h
* Unmerged path net/core/sock.c
diff --git a/net/rds/tcp_listen.c b/net/rds/tcp_listen.c
index 27d79afe25f7..a6ba95ba8e2f 100644
--- a/net/rds/tcp_listen.c
+++ b/net/rds/tcp_listen.c
@@ -43,13 +43,9 @@ int rds_tcp_keepalive(struct socket *sock)
 	/* values below based on xs_udp_default_timeout */
 	int keepidle = 5; /* send a probe 'keepidle' secs after last data */
 	int keepcnt = 5; /* number of unack'ed probes before declaring dead */
-	int keepalive = 1;
 	int ret = 0;
 
-	ret = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,
-				(char *)&keepalive, sizeof(keepalive));
-	if (ret < 0)
-		goto bail;
+	sock_set_keepalive(sock->sk);
 
 	ret = kernel_setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT,
 				(char *)&keepcnt, sizeof(keepcnt));
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 845d0be805ec..30082cd03996 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -2110,7 +2110,6 @@ static void xs_tcp_set_socket_timeouts(struct rpc_xprt *xprt,
 	struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
 	unsigned int keepidle;
 	unsigned int keepcnt;
-	unsigned int opt_on = 1;
 	unsigned int timeo;
 
 	spin_lock(&xprt->transport_lock);
@@ -2122,8 +2121,7 @@ static void xs_tcp_set_socket_timeouts(struct rpc_xprt *xprt,
 	spin_unlock(&xprt->transport_lock);
 
 	/* TCP Keepalive options */
-	kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,
-			(char *)&opt_on, sizeof(opt_on));
+	sock_set_keepalive(sock->sk);
 	kernel_setsockopt(sock, SOL_TCP, TCP_KEEPIDLE,
 			(char *)&keepidle, sizeof(keepidle));
 	kernel_setsockopt(sock, SOL_TCP, TCP_KEEPINTVL,
