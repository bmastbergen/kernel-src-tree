net: remove newlines in NL_SET_ERR_MSG_MOD

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit c75a33c84b83ffbb8b8b58a6bf4dea69dba21326
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c75a33c8.failed

The NL_SET_ERR_MSG_MOD macro is used to report a string describing an
error message to userspace via the netlink extended ACK structure. It
should not have a trailing newline.

Add a cocci script which catches cases where the newline marker is
present. Using this script, fix the handful of cases which accidentally
included a trailing new line.

I couldn't figure out a way to get a patch mode working, so this script
only implements context, report, and org.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Cc: Jakub Kicinski <kuba@kernel.org>
	Cc: Andy Whitcroft <apw@canonical.com>
	Cc: Joe Perches <joe@perches.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c75a33c84b83ffbb8b8b58a6bf4dea69dba21326)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mscc/ocelot_tc.c
#	net/bridge/br_mrp_netlink.c
#	net/bridge/br_stp_if.c
#	net/dsa/slave.c
diff --cc net/bridge/br_stp_if.c
index 808e2b914015,ba55851fe132..000000000000
--- a/net/bridge/br_stp_if.c
+++ b/net/bridge/br_stp_if.c
@@@ -203,6 -201,12 +203,15 @@@ void br_stp_set_enabled(struct net_brid
  {
  	ASSERT_RTNL();
  
++<<<<<<< HEAD
++=======
+ 	if (br_mrp_enabled(br)) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "STP can't be enabled if MRP is already enabled");
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> c75a33c84b83 (net: remove newlines in NL_SET_ERR_MSG_MOD)
  	if (val) {
  		if (br->stp_enabled == BR_NO_STP)
  			br_stp_start(br);
diff --cc net/dsa/slave.c
index fcacebafc502,dfb4282fc339..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -758,6 -842,120 +758,123 @@@ dsa_slave_mall_tc_entry_find(struct net
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ dsa_slave_add_cls_matchall_mirred(struct net_device *dev,
+ 				  struct tc_cls_matchall_offload *cls,
+ 				  bool ingress)
+ {
+ 	struct dsa_port *dp = dsa_slave_to_port(dev);
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_mall_mirror_tc_entry *mirror;
+ 	struct dsa_mall_tc_entry *mall_tc_entry;
+ 	struct dsa_switch *ds = dp->ds;
+ 	struct flow_action_entry *act;
+ 	struct dsa_port *to_dp;
+ 	int err;
+ 
+ 	if (!ds->ops->port_mirror_add)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!flow_action_basic_hw_stats_check(&cls->rule->action,
+ 					      cls->common.extack))
+ 		return -EOPNOTSUPP;
+ 
+ 	act = &cls->rule->action.entries[0];
+ 
+ 	if (!act->dev)
+ 		return -EINVAL;
+ 
+ 	if (!dsa_slave_dev_check(act->dev))
+ 		return -EOPNOTSUPP;
+ 
+ 	mall_tc_entry = kzalloc(sizeof(*mall_tc_entry), GFP_KERNEL);
+ 	if (!mall_tc_entry)
+ 		return -ENOMEM;
+ 
+ 	mall_tc_entry->cookie = cls->cookie;
+ 	mall_tc_entry->type = DSA_PORT_MALL_MIRROR;
+ 	mirror = &mall_tc_entry->mirror;
+ 
+ 	to_dp = dsa_slave_to_port(act->dev);
+ 
+ 	mirror->to_local_port = to_dp->index;
+ 	mirror->ingress = ingress;
+ 
+ 	err = ds->ops->port_mirror_add(ds, dp->index, mirror, ingress);
+ 	if (err) {
+ 		kfree(mall_tc_entry);
+ 		return err;
+ 	}
+ 
+ 	list_add_tail(&mall_tc_entry->list, &p->mall_tc_list);
+ 
+ 	return err;
+ }
+ 
+ static int
+ dsa_slave_add_cls_matchall_police(struct net_device *dev,
+ 				  struct tc_cls_matchall_offload *cls,
+ 				  bool ingress)
+ {
+ 	struct netlink_ext_ack *extack = cls->common.extack;
+ 	struct dsa_port *dp = dsa_slave_to_port(dev);
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_mall_policer_tc_entry *policer;
+ 	struct dsa_mall_tc_entry *mall_tc_entry;
+ 	struct dsa_switch *ds = dp->ds;
+ 	struct flow_action_entry *act;
+ 	int err;
+ 
+ 	if (!ds->ops->port_policer_add) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "Policing offload not implemented");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (!ingress) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "Only supported on ingress qdisc");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (!flow_action_basic_hw_stats_check(&cls->rule->action,
+ 					      cls->common.extack))
+ 		return -EOPNOTSUPP;
+ 
+ 	list_for_each_entry(mall_tc_entry, &p->mall_tc_list, list) {
+ 		if (mall_tc_entry->type == DSA_PORT_MALL_POLICER) {
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "Only one port policer allowed");
+ 			return -EEXIST;
+ 		}
+ 	}
+ 
+ 	act = &cls->rule->action.entries[0];
+ 
+ 	mall_tc_entry = kzalloc(sizeof(*mall_tc_entry), GFP_KERNEL);
+ 	if (!mall_tc_entry)
+ 		return -ENOMEM;
+ 
+ 	mall_tc_entry->cookie = cls->cookie;
+ 	mall_tc_entry->type = DSA_PORT_MALL_POLICER;
+ 	policer = &mall_tc_entry->policer;
+ 	policer->rate_bytes_per_sec = act->police.rate_bytes_ps;
+ 	policer->burst = act->police.burst;
+ 
+ 	err = ds->ops->port_policer_add(ds, dp->index, policer);
+ 	if (err) {
+ 		kfree(mall_tc_entry);
+ 		return err;
+ 	}
+ 
+ 	list_add_tail(&mall_tc_entry->list, &p->mall_tc_list);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> c75a33c84b83 (net: remove newlines in NL_SET_ERR_MSG_MOD)
  static int dsa_slave_add_cls_matchall(struct net_device *dev,
  				      struct tc_cls_matchall_offload *cls,
  				      bool ingress)
* Unmerged path drivers/net/ethernet/mscc/ocelot_tc.c
* Unmerged path net/bridge/br_mrp_netlink.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index b470c261572d..20cea7e6cb01 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -962,7 +962,7 @@ mlx5e_tc_add_nic_flow(struct mlx5e_priv *priv,
 		if (IS_ERR(priv->fs.tc.t)) {
 			mutex_unlock(&priv->fs.tc.t_lock);
 			NL_SET_ERR_MSG_MOD(extack,
-					   "Failed to create tc offload table\n");
+					   "Failed to create tc offload table");
 			netdev_err(priv->netdev,
 				   "Failed to create tc offload table\n");
 			return PTR_ERR(priv->fs.tc.t);
* Unmerged path drivers/net/ethernet/mscc/ocelot_tc.c
* Unmerged path net/bridge/br_mrp_netlink.c
* Unmerged path net/bridge/br_stp_if.c
* Unmerged path net/dsa/slave.c
diff --git a/scripts/coccinelle/misc/newline_in_nl_msg.cocci b/scripts/coccinelle/misc/newline_in_nl_msg.cocci
new file mode 100644
index 000000000000..c175886e4015
--- /dev/null
+++ b/scripts/coccinelle/misc/newline_in_nl_msg.cocci
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier: GPL-2.0-only
+///
+/// Catch strings ending in newline with GENL_SET_ERR_MSG, NL_SET_ERR_MSG,
+/// NL_SET_ERR_MSG_MOD.
+///
+// Confidence: Very High
+// Copyright: (C) 2020 Intel Corporation
+// URL: http://coccinelle.lip6.fr/
+// Options: --no-includes --include-headers
+
+virtual context
+virtual org
+virtual report
+
+@r depends on context || org || report@
+expression e;
+constant m;
+position p;
+@@
+  \(GENL_SET_ERR_MSG\|NL_SET_ERR_MSG\|NL_SET_ERR_MSG_MOD\)(e,m@p)
+
+@script:python@
+m << r.m;
+@@
+
+if not m.endswith("\\n\""):
+	cocci.include_match(False)
+
+@r1 depends on r@
+identifier fname;
+expression r.e;
+constant r.m;
+position r.p;
+@@
+  fname(e,m@p)
+
+//----------------------------------------------------------
+//  For context mode
+//----------------------------------------------------------
+
+@depends on context && r@
+identifier r1.fname;
+expression r.e;
+constant r.m;
+@@
+* fname(e,m)
+
+//----------------------------------------------------------
+//  For org mode
+//----------------------------------------------------------
+
+@script:python depends on org@
+fname << r1.fname;
+m << r.m;
+p << r.p;
+@@
+
+if m.endswith("\\n\""):
+	msg="WARNING avoid newline at end of message in %s" % (fname)
+	msg_safe=msg.replace("[","@(").replace("]",")")
+	coccilib.org.print_todo(p[0], msg_safe)
+
+//----------------------------------------------------------
+//  For report mode
+//----------------------------------------------------------
+
+@script:python depends on report@
+fname << r1.fname;
+m << r.m;
+p << r.p;
+@@
+
+if m.endswith("\\n\""):
+	msg="WARNING avoid newline at end of message in %s" % (fname)
+	coccilib.report.print_report(p[0], msg)
