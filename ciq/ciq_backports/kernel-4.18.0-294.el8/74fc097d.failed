tools/bpf: Support new uapi for map element bpf iterator

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yonghong Song <yhs@fb.com>
commit 74fc097de327b37e8fe3ff580ce7ffaa7c1740dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/74fc097d.failed

Previous commit adjusted kernel uapi for map
element bpf iterator. This patch adjusted libbpf API
due to uapi change. bpftool and bpf_iter selftests
are also changed accordingly.

	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/20200805055058.1457623-1-yhs@fb.com
(cherry picked from commit 74fc097de327b37e8fe3ff580ce7ffaa7c1740dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/bpf.c
#	tools/lib/bpf/bpf.h
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.h
diff --cc tools/lib/bpf/bpf.c
index da45889fc732,0750681057c2..000000000000
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@@ -598,6 -598,10 +598,13 @@@ int bpf_link_create(int prog_fd, int ta
  	attr.link_create.prog_fd = prog_fd;
  	attr.link_create.target_fd = target_fd;
  	attr.link_create.attach_type = attach_type;
++<<<<<<< HEAD
++=======
+ 	attr.link_create.flags = OPTS_GET(opts, flags, 0);
+ 	attr.link_create.iter_info =
+ 		ptr_to_u64(OPTS_GET(opts, iter_info, (void *)0));
+ 	attr.link_create.iter_info_len = OPTS_GET(opts, iter_info_len, 0);
++>>>>>>> 74fc097de327 (tools/bpf: Support new uapi for map element bpf iterator)
  
  	return sys_bpf(BPF_LINK_CREATE, &attr, sizeof(attr));
  }
diff --cc tools/lib/bpf/bpf.h
index f8c9bd418cb7,015d13f25fcc..000000000000
--- a/tools/lib/bpf/bpf.h
+++ b/tools/lib/bpf/bpf.h
@@@ -168,10 -168,14 +168,19 @@@ LIBBPF_API int bpf_prog_detach(int atta
  LIBBPF_API int bpf_prog_detach2(int prog_fd, int attachable_fd,
  				enum bpf_attach_type type);
  
+ union bpf_iter_link_info; /* defined in up-to-date linux/bpf.h */
  struct bpf_link_create_opts {
  	size_t sz; /* size of this struct for forward/backward compatibility */
++<<<<<<< HEAD
 +};
 +#define bpf_link_create_opts__last_field sz
++=======
+ 	__u32 flags;
+ 	union bpf_iter_link_info *iter_info;
+ 	__u32 iter_info_len;
+ };
+ #define bpf_link_create_opts__last_field iter_info_len
++>>>>>>> 74fc097de327 (tools/bpf: Support new uapi for map element bpf iterator)
  
  LIBBPF_API int bpf_link_create(int prog_fd, int target_fd,
  			       enum bpf_attach_type attach_type,
diff --cc tools/lib/bpf/libbpf.c
index 8a925e090a9b,0a06124f7999..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -8112,7 -8266,67 +8112,71 @@@ bpf_program__attach_cgroup(struct bpf_p
  	if (link_fd < 0) {
  		link_fd = -errno;
  		free(link);
++<<<<<<< HEAD
 +		pr_warn("program '%s': failed to attach to cgroup: %s\n",
++=======
+ 		pr_warn("program '%s': failed to attach to %s: %s\n",
+ 			bpf_program__title(prog, false), target_name,
+ 			libbpf_strerror_r(link_fd, errmsg, sizeof(errmsg)));
+ 		return ERR_PTR(link_fd);
+ 	}
+ 	link->fd = link_fd;
+ 	return link;
+ }
+ 
+ struct bpf_link *
+ bpf_program__attach_cgroup(struct bpf_program *prog, int cgroup_fd)
+ {
+ 	return bpf_program__attach_fd(prog, cgroup_fd, "cgroup");
+ }
+ 
+ struct bpf_link *
+ bpf_program__attach_netns(struct bpf_program *prog, int netns_fd)
+ {
+ 	return bpf_program__attach_fd(prog, netns_fd, "netns");
+ }
+ 
+ struct bpf_link *bpf_program__attach_xdp(struct bpf_program *prog, int ifindex)
+ {
+ 	/* target_fd/target_ifindex use the same field in LINK_CREATE */
+ 	return bpf_program__attach_fd(prog, ifindex, "xdp");
+ }
+ 
+ struct bpf_link *
+ bpf_program__attach_iter(struct bpf_program *prog,
+ 			 const struct bpf_iter_attach_opts *opts)
+ {
+ 	DECLARE_LIBBPF_OPTS(bpf_link_create_opts, link_create_opts);
+ 	char errmsg[STRERR_BUFSIZE];
+ 	struct bpf_link *link;
+ 	int prog_fd, link_fd;
+ 	__u32 target_fd = 0;
+ 
+ 	if (!OPTS_VALID(opts, bpf_iter_attach_opts))
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	link_create_opts.iter_info = OPTS_GET(opts, link_info, (void *)0);
+ 	link_create_opts.iter_info_len = OPTS_GET(opts, link_info_len, 0);
+ 
+ 	prog_fd = bpf_program__fd(prog);
+ 	if (prog_fd < 0) {
+ 		pr_warn("program '%s': can't attach before loaded\n",
+ 			bpf_program__title(prog, false));
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	link = calloc(1, sizeof(*link));
+ 	if (!link)
+ 		return ERR_PTR(-ENOMEM);
+ 	link->detach = &bpf_link__detach_fd;
+ 
+ 	link_fd = bpf_link_create(prog_fd, target_fd, BPF_TRACE_ITER,
+ 				  &link_create_opts);
+ 	if (link_fd < 0) {
+ 		link_fd = -errno;
+ 		free(link);
+ 		pr_warn("program '%s': failed to attach to iterator: %s\n",
++>>>>>>> 74fc097de327 (tools/bpf: Support new uapi for map element bpf iterator)
  			bpf_program__title(prog, false),
  			libbpf_strerror_r(link_fd, errmsg, sizeof(errmsg)));
  		return ERR_PTR(link_fd);
diff --cc tools/lib/bpf/libbpf.h
index 02e427ddd9d9,5ecb4069a9f0..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -272,6 -265,17 +272,20 @@@ struct bpf_map
  
  LIBBPF_API struct bpf_link *bpf_map__attach_struct_ops(struct bpf_map *map);
  
++<<<<<<< HEAD
++=======
+ struct bpf_iter_attach_opts {
+ 	size_t sz; /* size of this struct for forward/backward compatibility */
+ 	union bpf_iter_link_info *link_info;
+ 	__u32 link_info_len;
+ };
+ #define bpf_iter_attach_opts__last_field link_info_len
+ 
+ LIBBPF_API struct bpf_link *
+ bpf_program__attach_iter(struct bpf_program *prog,
+ 			 const struct bpf_iter_attach_opts *opts);
+ 
++>>>>>>> 74fc097de327 (tools/bpf: Support new uapi for map element bpf iterator)
  struct bpf_insn;
  
  /*
diff --git a/tools/bpf/bpftool/iter.c b/tools/bpf/bpftool/iter.c
index c9dba7543dba..3b1aad7535dd 100644
--- a/tools/bpf/bpftool/iter.c
+++ b/tools/bpf/bpftool/iter.c
@@ -11,6 +11,7 @@
 static int do_pin(int argc, char **argv)
 {
 	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, iter_opts);
+	union bpf_iter_link_info linfo;
 	const char *objfile, *path;
 	struct bpf_program *prog;
 	struct bpf_object *obj;
@@ -36,6 +37,11 @@ static int do_pin(int argc, char **argv)
 			map_fd = map_parse_fd(&argc, &argv);
 			if (map_fd < 0)
 				return -1;
+
+			memset(&linfo, 0, sizeof(linfo));
+			linfo.map.map_fd = map_fd;
+			iter_opts.link_info = &linfo;
+			iter_opts.link_info_len = sizeof(linfo);
 		}
 	}
 
@@ -57,9 +63,6 @@ static int do_pin(int argc, char **argv)
 		goto close_obj;
 	}
 
-	if (map_fd >= 0)
-		iter_opts.map_fd = map_fd;
-
 	link = bpf_program__attach_iter(prog, &iter_opts);
 	if (IS_ERR(link)) {
 		err = PTR_ERR(link);
diff --git a/tools/include/uapi/linux/bpf.h b/tools/include/uapi/linux/bpf.h
index 9f6d3977ecf3..92015f2b517c 100644
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@ -81,6 +81,12 @@ struct bpf_cgroup_storage_key {
 	__u32	attach_type;		/* program attach type */
 };
 
+union bpf_iter_link_info {
+	struct {
+		__u32	map_fd;
+	} map;
+};
+
 /* BPF syscall commands, see bpf(2) man-page for details. */
 enum bpf_cmd {
 	BPF_MAP_CREATE,
@@ -589,6 +595,8 @@ union bpf_attr {
 		__u32		target_fd;	/* object to attach to */
 		__u32		attach_type;	/* attach type */
 		__u32		flags;		/* extra flags */
+		__aligned_u64	iter_info;	/* extra bpf_iter_link_info */
+		__u32		iter_info_len;	/* iter_info length */
 	} link_create;
 
 	struct { /* struct used by BPF_LINK_UPDATE command */
* Unmerged path tools/lib/bpf/bpf.c
* Unmerged path tools/lib/bpf/bpf.h
* Unmerged path tools/lib/bpf/libbpf.c
* Unmerged path tools/lib/bpf/libbpf.h
diff --git a/tools/testing/selftests/bpf/prog_tests/bpf_iter.c b/tools/testing/selftests/bpf/prog_tests/bpf_iter.c
index 4ffefdc1130f..7375d9a6d242 100644
--- a/tools/testing/selftests/bpf/prog_tests/bpf_iter.c
+++ b/tools/testing/selftests/bpf/prog_tests/bpf_iter.c
@@ -468,6 +468,7 @@ static void test_bpf_hash_map(void)
 	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);
 	struct bpf_iter_bpf_hash_map *skel;
 	int err, i, len, map_fd, iter_fd;
+	union bpf_iter_link_info linfo;
 	__u64 val, expected_val = 0;
 	struct bpf_link *link;
 	struct key_t {
@@ -490,13 +491,16 @@ static void test_bpf_hash_map(void)
 		goto out;
 
 	/* iterator with hashmap2 and hashmap3 should fail */
-	opts.map_fd = bpf_map__fd(skel->maps.hashmap2);
+	memset(&linfo, 0, sizeof(linfo));
+	linfo.map.map_fd = bpf_map__fd(skel->maps.hashmap2);
+	opts.link_info = &linfo;
+	opts.link_info_len = sizeof(linfo);
 	link = bpf_program__attach_iter(skel->progs.dump_bpf_hash_map, &opts);
 	if (CHECK(!IS_ERR(link), "attach_iter",
 		  "attach_iter for hashmap2 unexpected succeeded\n"))
 		goto out;
 
-	opts.map_fd = bpf_map__fd(skel->maps.hashmap3);
+	linfo.map.map_fd = bpf_map__fd(skel->maps.hashmap3);
 	link = bpf_program__attach_iter(skel->progs.dump_bpf_hash_map, &opts);
 	if (CHECK(!IS_ERR(link), "attach_iter",
 		  "attach_iter for hashmap3 unexpected succeeded\n"))
@@ -519,7 +523,7 @@ static void test_bpf_hash_map(void)
 			goto out;
 	}
 
-	opts.map_fd = map_fd;
+	linfo.map.map_fd = map_fd;
 	link = bpf_program__attach_iter(skel->progs.dump_bpf_hash_map, &opts);
 	if (CHECK(IS_ERR(link), "attach_iter", "attach_iter failed\n"))
 		goto out;
@@ -562,6 +566,7 @@ static void test_bpf_percpu_hash_map(void)
 	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);
 	struct bpf_iter_bpf_percpu_hash_map *skel;
 	int err, i, j, len, map_fd, iter_fd;
+	union bpf_iter_link_info linfo;
 	__u32 expected_val = 0;
 	struct bpf_link *link;
 	struct key_t {
@@ -606,7 +611,10 @@ static void test_bpf_percpu_hash_map(void)
 			goto out;
 	}
 
-	opts.map_fd = map_fd;
+	memset(&linfo, 0, sizeof(linfo));
+	linfo.map.map_fd = map_fd;
+	opts.link_info = &linfo;
+	opts.link_info_len = sizeof(linfo);
 	link = bpf_program__attach_iter(skel->progs.dump_bpf_percpu_hash_map, &opts);
 	if (CHECK(IS_ERR(link), "attach_iter", "attach_iter failed\n"))
 		goto out;
@@ -649,6 +657,7 @@ static void test_bpf_array_map(void)
 	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);
 	__u32 expected_key = 0, res_first_key;
 	struct bpf_iter_bpf_array_map *skel;
+	union bpf_iter_link_info linfo;
 	int err, i, map_fd, iter_fd;
 	struct bpf_link *link;
 	char buf[64] = {};
@@ -673,7 +682,10 @@ static void test_bpf_array_map(void)
 			goto out;
 	}
 
-	opts.map_fd = map_fd;
+	memset(&linfo, 0, sizeof(linfo));
+	linfo.map.map_fd = map_fd;
+	opts.link_info = &linfo;
+	opts.link_info_len = sizeof(linfo);
 	link = bpf_program__attach_iter(skel->progs.dump_bpf_array_map, &opts);
 	if (CHECK(IS_ERR(link), "attach_iter", "attach_iter failed\n"))
 		goto out;
@@ -730,6 +742,7 @@ static void test_bpf_percpu_array_map(void)
 	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);
 	struct bpf_iter_bpf_percpu_array_map *skel;
 	__u32 expected_key = 0, expected_val = 0;
+	union bpf_iter_link_info linfo;
 	int err, i, j, map_fd, iter_fd;
 	struct bpf_link *link;
 	char buf[64];
@@ -765,7 +778,10 @@ static void test_bpf_percpu_array_map(void)
 			goto out;
 	}
 
-	opts.map_fd = map_fd;
+	memset(&linfo, 0, sizeof(linfo));
+	linfo.map.map_fd = map_fd;
+	opts.link_info = &linfo;
+	opts.link_info_len = sizeof(linfo);
 	link = bpf_program__attach_iter(skel->progs.dump_bpf_percpu_array_map, &opts);
 	if (CHECK(IS_ERR(link), "attach_iter", "attach_iter failed\n"))
 		goto out;
@@ -803,6 +819,7 @@ static void test_bpf_sk_storage_map(void)
 	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);
 	int err, i, len, map_fd, iter_fd, num_sockets;
 	struct bpf_iter_bpf_sk_storage_map *skel;
+	union bpf_iter_link_info linfo;
 	int sock_fd[3] = {-1, -1, -1};
 	__u32 val, expected_val = 0;
 	struct bpf_link *link;
@@ -829,7 +846,10 @@ static void test_bpf_sk_storage_map(void)
 			goto out;
 	}
 
-	opts.map_fd = map_fd;
+	memset(&linfo, 0, sizeof(linfo));
+	linfo.map.map_fd = map_fd;
+	opts.link_info = &linfo;
+	opts.link_info_len = sizeof(linfo);
 	link = bpf_program__attach_iter(skel->progs.dump_bpf_sk_storage_map, &opts);
 	if (CHECK(IS_ERR(link), "attach_iter", "attach_iter failed\n"))
 		goto out;
@@ -871,6 +891,7 @@ static void test_rdonly_buf_out_of_bound(void)
 {
 	DECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);
 	struct bpf_iter_test_kern5 *skel;
+	union bpf_iter_link_info linfo;
 	struct bpf_link *link;
 
 	skel = bpf_iter_test_kern5__open_and_load();
@@ -878,7 +899,10 @@ static void test_rdonly_buf_out_of_bound(void)
 		  "skeleton open_and_load failed\n"))
 		return;
 
-	opts.map_fd = bpf_map__fd(skel->maps.hashmap1);
+	memset(&linfo, 0, sizeof(linfo));
+	linfo.map.map_fd = bpf_map__fd(skel->maps.hashmap1);
+	opts.link_info = &linfo;
+	opts.link_info_len = sizeof(linfo);
 	link = bpf_program__attach_iter(skel->progs.dump_bpf_hash_map, &opts);
 	if (CHECK(!IS_ERR(link), "attach_iter", "unexpected success\n"))
 		bpf_link__destroy(link);
