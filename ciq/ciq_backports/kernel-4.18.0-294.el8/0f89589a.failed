Pass consistent param->type to fs_parse()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 0f89589a8c6f1033cb847a606517998efb0da8ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/0f89589a.failed

As it is, vfs_parse_fs_string() makes "foo" and "foo=" indistinguishable;
both get fs_value_is_string for ->type and NULL for ->string.  To make
it even more unpleasant, that combination is impossible to produce with
fsconfig().

Much saner rules would be
        "foo"           => fs_value_is_flag, NULL
	"foo="          => fs_value_is_string, ""
	"foo=bar"       => fs_value_is_string, "bar"
All cases are distinguishable, all results are expressable by fsconfig(),
->has_value checks are much simpler that way (to the point of the field
being useless) and quite a few regressions go away (gfs2 has no business
accepting -o nodebug=, for example).

Partially based upon patches from Miklos.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 0f89589a8c6f1033cb847a606517998efb0da8ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
#	fs/fs_context.c
#	fs/fs_parser.c
#	include/linux/fs_parser.h
diff --cc drivers/block/rbd.c
index ea25974ec267,9fc686be81ca..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -6393,6 -6348,119 +6393,122 @@@ static inline char *dup_token(const cha
  	return dup;
  }
  
++<<<<<<< HEAD
++=======
+ static int rbd_parse_param(struct fs_parameter *param,
+ 			    struct rbd_parse_opts_ctx *pctx)
+ {
+ 	struct rbd_options *opt = pctx->opts;
+ 	struct fs_parse_result result;
+ 	int token, ret;
+ 
+ 	ret = ceph_parse_param(param, pctx->copts, NULL);
+ 	if (ret != -ENOPARAM)
+ 		return ret;
+ 
+ 	token = fs_parse(NULL, &rbd_parameters, param, &result);
+ 	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
+ 	if (token < 0) {
+ 		if (token == -ENOPARAM) {
+ 			return invalf(NULL, "rbd: Unknown parameter '%s'",
+ 				      param->key);
+ 		}
+ 		return token;
+ 	}
+ 
+ 	switch (token) {
+ 	case Opt_queue_depth:
+ 		if (result.uint_32 < 1)
+ 			goto out_of_range;
+ 		opt->queue_depth = result.uint_32;
+ 		break;
+ 	case Opt_alloc_size:
+ 		if (result.uint_32 < SECTOR_SIZE)
+ 			goto out_of_range;
+ 		if (!is_power_of_2(result.uint_32)) {
+ 			return invalf(NULL, "rbd: alloc_size must be a power of 2");
+ 		}
+ 		opt->alloc_size = result.uint_32;
+ 		break;
+ 	case Opt_lock_timeout:
+ 		/* 0 is "wait forever" (i.e. infinite timeout) */
+ 		if (result.uint_32 > INT_MAX / 1000)
+ 			goto out_of_range;
+ 		opt->lock_timeout = msecs_to_jiffies(result.uint_32 * 1000);
+ 		break;
+ 	case Opt_pool_ns:
+ 		kfree(pctx->spec->pool_ns);
+ 		pctx->spec->pool_ns = param->string;
+ 		param->string = NULL;
+ 		break;
+ 	case Opt_read_only:
+ 		opt->read_only = true;
+ 		break;
+ 	case Opt_read_write:
+ 		opt->read_only = false;
+ 		break;
+ 	case Opt_lock_on_read:
+ 		opt->lock_on_read = true;
+ 		break;
+ 	case Opt_exclusive:
+ 		opt->exclusive = true;
+ 		break;
+ 	case Opt_notrim:
+ 		opt->trim = false;
+ 		break;
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	return 0;
+ 
+ out_of_range:
+ 	return invalf(NULL, "rbd: %s out of range", param->key);
+ }
+ 
+ /*
+  * This duplicates most of generic_parse_monolithic(), untying it from
+  * fs_context and skipping standard superblock and security options.
+  */
+ static int rbd_parse_options(char *options, struct rbd_parse_opts_ctx *pctx)
+ {
+ 	char *key;
+ 	int ret = 0;
+ 
+ 	dout("%s '%s'\n", __func__, options);
+ 	while ((key = strsep(&options, ",")) != NULL) {
+ 		if (*key) {
+ 			struct fs_parameter param = {
+ 				.key	= key,
+ 				.type	= fs_value_is_flag,
+ 			};
+ 			char *value = strchr(key, '=');
+ 			size_t v_len = 0;
+ 
+ 			if (value) {
+ 				if (value == key)
+ 					continue;
+ 				*value++ = 0;
+ 				v_len = strlen(value);
+ 				param.string = kmemdup_nul(value, v_len,
+ 							   GFP_KERNEL);
+ 				if (!param.string)
+ 					return -ENOMEM;
+ 				param.type = fs_value_is_string;
+ 			}
+ 			param.size = v_len;
+ 
+ 			ret = rbd_parse_param(&param, pctx);
+ 			kfree(param.string);
+ 			if (ret)
+ 				break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 0f89589a8c6f (Pass consistent param->type to fs_parse())
  /*
   * Parse the options provided for an "rbd add" (i.e., rbd image
   * mapping) request.  These arrive via a write to /sys/bus/rbd/add,
* Unmerged path fs/fs_context.c
* Unmerged path fs/fs_parser.c
* Unmerged path include/linux/fs_parser.h
* Unmerged path drivers/block/rbd.c
* Unmerged path fs/fs_context.c
* Unmerged path fs/fs_parser.c
* Unmerged path include/linux/fs_parser.h
