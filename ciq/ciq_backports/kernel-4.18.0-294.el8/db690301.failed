iommu/io-pgtable-arm: Prepare for TTBR1 usage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Robin Murphy <robin.murphy@arm.com>
commit db6903010aa5b7691d8234a179f4cf71a119445a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/db690301.failed

Now that we can correctly extract top-level indices without relying on
the remaining upper bits being zero, the only remaining impediments to
using a given table for TTBR1 are the address validation on map/unmap
and the awkward TCR translation granule format. Add a quirk so that we
can do the right thing at those points.

	Tested-by: Jordan Crouse <jcrouse@codeaurora.org>
	Signed-off-by: Robin Murphy <robin.murphy@arm.com>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit db6903010aa5b7691d8234a179f4cf71a119445a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/io-pgtable-arm.c
diff --cc drivers/iommu/io-pgtable-arm.c
index c5503d730284,983b08477e64..000000000000
--- a/drivers/iommu/io-pgtable-arm.c
+++ b/drivers/iommu/io-pgtable-arm.c
@@@ -111,17 -100,14 +111,24 @@@
  #define ARM_LPAE_PTE_MEMATTR_DEV	(((arm_lpae_iopte)0x1) << 2)
  
  /* Register bits */
 -#define ARM_LPAE_TCR_TG0_4K		0
 -#define ARM_LPAE_TCR_TG0_64K		1
 -#define ARM_LPAE_TCR_TG0_16K		2
 +#define ARM_32_LPAE_TCR_EAE		(1 << 31)
 +#define ARM_64_LPAE_S2_TCR_RES1		(1U << 31)
 +
++<<<<<<< HEAD
 +#define ARM_LPAE_TCR_EPD1		(1 << 23)
  
 +#define ARM_LPAE_TCR_TG0_4K		(0 << 14)
 +#define ARM_LPAE_TCR_TG0_64K		(1 << 14)
 +#define ARM_LPAE_TCR_TG0_16K		(2 << 14)
 +
 +#define ARM_LPAE_TCR_SH0_SHIFT		12
 +#define ARM_LPAE_TCR_SH0_MASK		0x3
++=======
+ #define ARM_LPAE_TCR_TG1_16K		1
+ #define ARM_LPAE_TCR_TG1_4K		2
+ #define ARM_LPAE_TCR_TG1_64K		3
+ 
++>>>>>>> db6903010aa5 (iommu/io-pgtable-arm: Prepare for TTBR1 usage)
  #define ARM_LPAE_TCR_SH_NS		0
  #define ARM_LPAE_TCR_SH_OS		2
  #define ARM_LPAE_TCR_SH_IS		3
@@@ -798,9 -787,12 +811,15 @@@ arm_64_lpae_alloc_pgtable_s1(struct io_
  {
  	u64 reg;
  	struct arm_lpae_io_pgtable *data;
++<<<<<<< HEAD
++=======
+ 	typeof(&cfg->arm_lpae_s1_cfg.tcr) tcr = &cfg->arm_lpae_s1_cfg.tcr;
+ 	bool tg1;
++>>>>>>> db6903010aa5 (iommu/io-pgtable-arm: Prepare for TTBR1 usage)
  
  	if (cfg->quirks & ~(IO_PGTABLE_QUIRK_ARM_NS |
- 			    IO_PGTABLE_QUIRK_NON_STRICT))
+ 			    IO_PGTABLE_QUIRK_NON_STRICT |
+ 			    IO_PGTABLE_QUIRK_ARM_TTBR1))
  		return NULL;
  
  	data = arm_lpae_alloc_pgtable(cfg);
@@@ -809,24 -801,25 +828,35 @@@
  
  	/* TCR */
  	if (cfg->coherent_walk) {
 -		tcr->sh = ARM_LPAE_TCR_SH_IS;
 -		tcr->irgn = ARM_LPAE_TCR_RGN_WBWA;
 -		tcr->orgn = ARM_LPAE_TCR_RGN_WBWA;
 +		reg = (ARM_LPAE_TCR_SH_IS << ARM_LPAE_TCR_SH0_SHIFT) |
 +		      (ARM_LPAE_TCR_RGN_WBWA << ARM_LPAE_TCR_IRGN0_SHIFT) |
 +		      (ARM_LPAE_TCR_RGN_WBWA << ARM_LPAE_TCR_ORGN0_SHIFT);
  	} else {
 -		tcr->sh = ARM_LPAE_TCR_SH_OS;
 -		tcr->irgn = ARM_LPAE_TCR_RGN_NC;
 -		tcr->orgn = ARM_LPAE_TCR_RGN_NC;
 +		reg = (ARM_LPAE_TCR_SH_OS << ARM_LPAE_TCR_SH0_SHIFT) |
 +		      (ARM_LPAE_TCR_RGN_NC << ARM_LPAE_TCR_IRGN0_SHIFT) |
 +		      (ARM_LPAE_TCR_RGN_NC << ARM_LPAE_TCR_ORGN0_SHIFT);
  	}
  
+ 	tg1 = cfg->quirks & IO_PGTABLE_QUIRK_ARM_TTBR1;
  	switch (ARM_LPAE_GRANULE(data)) {
  	case SZ_4K:
++<<<<<<< HEAD
 +		reg |= ARM_LPAE_TCR_TG0_4K;
 +		break;
 +	case SZ_16K:
 +		reg |= ARM_LPAE_TCR_TG0_16K;
 +		break;
 +	case SZ_64K:
 +		reg |= ARM_LPAE_TCR_TG0_64K;
++=======
+ 		tcr->tg = tg1 ? ARM_LPAE_TCR_TG1_4K : ARM_LPAE_TCR_TG0_4K;
+ 		break;
+ 	case SZ_16K:
+ 		tcr->tg = tg1 ? ARM_LPAE_TCR_TG1_16K : ARM_LPAE_TCR_TG0_16K;
+ 		break;
+ 	case SZ_64K:
+ 		tcr->tg = tg1 ? ARM_LPAE_TCR_TG1_64K : ARM_LPAE_TCR_TG0_64K;
++>>>>>>> db6903010aa5 (iommu/io-pgtable-arm: Prepare for TTBR1 usage)
  		break;
  	}
  
* Unmerged path drivers/iommu/io-pgtable-arm.c
diff --git a/include/linux/io-pgtable.h b/include/linux/io-pgtable.h
index 6b1b8be3ebec..f939f58ec468 100644
--- a/include/linux/io-pgtable.h
+++ b/include/linux/io-pgtable.h
@@ -84,12 +84,16 @@ struct io_pgtable_cfg {
 	 * IO_PGTABLE_QUIRK_NON_STRICT: Skip issuing synchronous leaf TLBIs
 	 *	on unmap, for DMA domains using the flush queue mechanism for
 	 *	delayed invalidation.
+	 *
+	 * IO_PGTABLE_QUIRK_ARM_TTBR1: (ARM LPAE format) Configure the table
+	 *	for use in the upper half of a split address space.
 	 */
 	#define IO_PGTABLE_QUIRK_ARM_NS		BIT(0)
 	#define IO_PGTABLE_QUIRK_NO_PERMS	BIT(1)
 	#define IO_PGTABLE_QUIRK_TLBI_ON_MAP	BIT(2)
 	#define IO_PGTABLE_QUIRK_ARM_MTK_4GB	BIT(3)
 	#define IO_PGTABLE_QUIRK_NON_STRICT	BIT(4)
+	#define IO_PGTABLE_QUIRK_ARM_TTBR1	BIT(5)
 	unsigned long			quirks;
 	unsigned long			pgsize_bitmap;
 	unsigned int			ias;
