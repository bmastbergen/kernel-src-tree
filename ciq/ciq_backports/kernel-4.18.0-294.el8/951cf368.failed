bpf: net: Use precomputed btf_id for bpf iterators

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yonghong Song <yhs@fb.com>
commit 951cf368bcb11d6f817709660cf5cd914072c36f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/951cf368.failed

One additional field btf_id is added to struct
bpf_ctx_arg_aux to store the precomputed btf_ids.
The btf_id is computed at build time with
BTF_ID_LIST or BTF_ID_LIST_GLOBAL macro definitions.
All existing bpf iterators are changed to used
pre-compute btf_ids.

	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200720163403.1393551-1-yhs@fb.com
(cherry picked from commit 951cf368bcb11d6f817709660cf5cd914072c36f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/btf.c
#	kernel/bpf/map_iter.c
#	kernel/bpf/task_iter.c
#	net/ipv6/route.c
#	net/netlink/af_netlink.c
diff --cc include/linux/bpf.h
index 531af1e44e56,bae557ff2da8..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -656,13 -664,19 +656,23 @@@ struct bpf_jit_poke_descriptor 
  	u16 reason;
  };
  
++<<<<<<< HEAD
++=======
+ /* reg_type info for ctx arguments */
+ struct bpf_ctx_arg_aux {
+ 	u32 offset;
+ 	enum bpf_reg_type reg_type;
+ 	u32 btf_id;
+ };
+ 
++>>>>>>> 951cf368bcb1 (bpf: net: Use precomputed btf_id for bpf iterators)
  struct bpf_prog_aux {
 -	atomic64_t refcnt;
 +	RH_KABI_BROKEN_REPLACE(atomic_t refcnt, atomic64_t refcnt)
  	u32 used_map_cnt;
  	u32 max_ctx_offset;
 -	u32 max_pkt_offset;
 -	u32 max_tp_access;
 +	/* not protected by KABI, safe to extend in the middle */
 +	RH_KABI_BROKEN_INSERT(u32 max_pkt_offset)
 +	RH_KABI_BROKEN_INSERT(u32 max_tp_access)
  	u32 stack_depth;
  	u32 id;
  	u32 func_cnt; /* used by non-func prog as the number of func progs */
diff --cc kernel/bpf/btf.c
index 52afb4b50a36,ee36b7f60936..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -3778,8 -3817,17 +3778,21 @@@ bool btf_ctx_access(int off, int size, 
  		return true;
  
  	/* this is a pointer to another type */
++<<<<<<< HEAD
 +	info->reg_type = PTR_TO_BTF_ID;
++=======
+ 	for (i = 0; i < prog->aux->ctx_arg_info_size; i++) {
+ 		const struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];
  
+ 		if (ctx_arg_info->offset == off) {
+ 			info->reg_type = ctx_arg_info->reg_type;
+ 			info->btf_id = ctx_arg_info->btf_id;
+ 			return true;
+ 		}
+ 	}
++>>>>>>> 951cf368bcb1 (bpf: net: Use precomputed btf_id for bpf iterators)
+ 
+ 	info->reg_type = PTR_TO_BTF_ID;
  	if (tgt_prog) {
  		ret = btf_translate_to_vmlinux(log, btf, t, tgt_prog->type, arg);
  		if (ret > 0) {
diff --cc kernel/bpf/map_iter.c
index 8162e0c00b9f,8a7af11b411f..000000000000
--- a/kernel/bpf/map_iter.c
+++ b/kernel/bpf/map_iter.c
@@@ -81,17 -82,26 +82,40 @@@ static const struct seq_operations bpf_
  	.show	= bpf_map_seq_show,
  };
  
++<<<<<<< HEAD
 +static int __init bpf_map_iter_init(void)
 +{
 +	struct bpf_iter_reg reg_info = {
 +		.target			= "bpf_map",
 +		.seq_ops		= &bpf_map_seq_ops,
 +		.init_seq_private	= NULL,
 +		.fini_seq_private	= NULL,
 +		.seq_priv_size		= sizeof(struct bpf_iter_seq_map_info),
 +	};
 +
 +	return bpf_iter_reg_target(&reg_info);
++=======
+ BTF_ID_LIST(btf_bpf_map_id)
+ BTF_ID(struct, bpf_map)
+ 
+ static struct bpf_iter_reg bpf_map_reg_info = {
+ 	.target			= "bpf_map",
+ 	.seq_ops		= &bpf_map_seq_ops,
+ 	.init_seq_private	= NULL,
+ 	.fini_seq_private	= NULL,
+ 	.seq_priv_size		= sizeof(struct bpf_iter_seq_map_info),
+ 	.ctx_arg_info_size	= 1,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__bpf_map, map),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ };
+ 
+ static int __init bpf_map_iter_init(void)
+ {
+ 	bpf_map_reg_info.ctx_arg_info[0].btf_id = *btf_bpf_map_id;
+ 	return bpf_iter_reg_target(&bpf_map_reg_info);
++>>>>>>> 951cf368bcb1 (bpf: net: Use precomputed btf_id for bpf iterators)
  }
  
  late_initcall(bpf_map_iter_init);
diff --cc kernel/bpf/task_iter.c
index 135ad297b957,2feecf095609..000000000000
--- a/kernel/bpf/task_iter.c
+++ b/kernel/bpf/task_iter.c
@@@ -312,24 -313,43 +313,60 @@@ static const struct seq_operations task
  	.show	= task_file_seq_show,
  };
  
++<<<<<<< HEAD
++=======
+ BTF_ID_LIST(btf_task_file_ids)
+ BTF_ID(struct, task_struct)
+ BTF_ID(struct, file)
+ 
+ static struct bpf_iter_reg task_reg_info = {
+ 	.target			= "task",
+ 	.seq_ops		= &task_seq_ops,
+ 	.init_seq_private	= init_seq_pidns,
+ 	.fini_seq_private	= fini_seq_pidns,
+ 	.seq_priv_size		= sizeof(struct bpf_iter_seq_task_info),
+ 	.ctx_arg_info_size	= 1,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__task, task),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ };
+ 
+ static struct bpf_iter_reg task_file_reg_info = {
+ 	.target			= "task_file",
+ 	.seq_ops		= &task_file_seq_ops,
+ 	.init_seq_private	= init_seq_pidns,
+ 	.fini_seq_private	= fini_seq_pidns,
+ 	.seq_priv_size		= sizeof(struct bpf_iter_seq_task_file_info),
+ 	.ctx_arg_info_size	= 2,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__task_file, task),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 		{ offsetof(struct bpf_iter__task_file, file),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ };
+ 
++>>>>>>> 951cf368bcb1 (bpf: net: Use precomputed btf_id for bpf iterators)
  static int __init task_iter_init(void)
  {
 +	struct bpf_iter_reg task_file_reg_info = {
 +		.target			= "task_file",
 +		.seq_ops		= &task_file_seq_ops,
 +		.init_seq_private	= init_seq_pidns,
 +		.fini_seq_private	= fini_seq_pidns,
 +		.seq_priv_size		= sizeof(struct bpf_iter_seq_task_file_info),
 +	};
 +	struct bpf_iter_reg task_reg_info = {
 +		.target			= "task",
 +		.seq_ops		= &task_seq_ops,
 +		.init_seq_private	= init_seq_pidns,
 +		.fini_seq_private	= fini_seq_pidns,
 +		.seq_priv_size		= sizeof(struct bpf_iter_seq_task_info),
 +	};
  	int ret;
  
+ 	task_reg_info.ctx_arg_info[0].btf_id = btf_task_file_ids[0];
  	ret = bpf_iter_reg_target(&task_reg_info);
  	if (ret)
  		return ret;
diff --cc net/ipv6/route.c
index 8d3f84864403,33f5efbad0a9..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -5669,6 -6420,39 +5670,42 @@@ void __init ip6_route_init_special_entr
    #endif
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_BUILTIN(CONFIG_IPV6)
+ #if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)
+ DEFINE_BPF_ITER_FUNC(ipv6_route, struct bpf_iter_meta *meta, struct fib6_info *rt)
+ 
+ BTF_ID_LIST(btf_fib6_info_id)
+ BTF_ID(struct, fib6_info)
+ 
+ static struct bpf_iter_reg ipv6_route_reg_info = {
+ 	.target			= "ipv6_route",
+ 	.seq_ops		= &ipv6_route_seq_ops,
+ 	.init_seq_private	= bpf_iter_init_seq_net,
+ 	.fini_seq_private	= bpf_iter_fini_seq_net,
+ 	.seq_priv_size		= sizeof(struct ipv6_route_iter),
+ 	.ctx_arg_info_size	= 1,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__ipv6_route, rt),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ };
+ 
+ static int __init bpf_iter_register(void)
+ {
+ 	ipv6_route_reg_info.ctx_arg_info[0].btf_id = *btf_fib6_info_id;
+ 	return bpf_iter_reg_target(&ipv6_route_reg_info);
+ }
+ 
+ static void bpf_iter_unregister(void)
+ {
+ 	bpf_iter_unreg_target(&ipv6_route_reg_info);
+ }
+ #endif
+ #endif
+ 
++>>>>>>> 951cf368bcb1 (bpf: net: Use precomputed btf_id for bpf iterators)
  int __init ip6_route_init(void)
  {
  	int ret;
diff --cc net/netlink/af_netlink.c
index 9b0e55efc3d6,3cd58f0c2de4..000000000000
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@@ -2745,6 -2803,30 +2746,33 @@@ static const struct rhashtable_params n
  	.automatic_shrinking = true,
  };
  
++<<<<<<< HEAD
++=======
+ #if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)
+ BTF_ID_LIST(btf_netlink_sock_id)
+ BTF_ID(struct, netlink_sock)
+ 
+ static struct bpf_iter_reg netlink_reg_info = {
+ 	.target			= "netlink",
+ 	.seq_ops		= &netlink_seq_ops,
+ 	.init_seq_private	= bpf_iter_init_seq_net,
+ 	.fini_seq_private	= bpf_iter_fini_seq_net,
+ 	.seq_priv_size		= sizeof(struct nl_seq_iter),
+ 	.ctx_arg_info_size	= 1,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__netlink, sk),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ };
+ 
+ static int __init bpf_iter_register(void)
+ {
+ 	netlink_reg_info.ctx_arg_info[0].btf_id = *btf_netlink_sock_id;
+ 	return bpf_iter_reg_target(&netlink_reg_info);
+ }
+ #endif
+ 
++>>>>>>> 951cf368bcb1 (bpf: net: Use precomputed btf_id for bpf iterators)
  static int __init netlink_proto_init(void)
  {
  	int i;
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/btf.c
* Unmerged path kernel/bpf/map_iter.c
* Unmerged path kernel/bpf/task_iter.c
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index c27942535c70..8488352dd1d1 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -81,6 +81,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/inetdevice.h>
+#include <linux/btf_ids.h>
 
 #include <crypto/hash.h>
 #include <linux/scatterlist.h>
@@ -2862,7 +2863,7 @@ static void bpf_iter_fini_tcp(void *priv_data)
 	bpf_iter_fini_seq_net(priv_data);
 }
 
-static const struct bpf_iter_reg tcp_reg_info = {
+static struct bpf_iter_reg tcp_reg_info = {
 	.target			= "tcp",
 	.seq_ops		= &bpf_iter_tcp_seq_ops,
 	.init_seq_private	= bpf_iter_init_tcp,
@@ -2877,6 +2878,7 @@ static const struct bpf_iter_reg tcp_reg_info = {
 
 static void __init bpf_iter_register(void)
 {
+	tcp_reg_info.ctx_arg_info[0].btf_id = btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON];
 	if (bpf_iter_reg_target(&tcp_reg_info))
 		pr_warn("Warning: could not register bpf iterator tcp\n");
 }
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 98e5d6011292..0657b67ef427 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -110,6 +110,7 @@
 #include <net/xfrm.h>
 #include <trace/events/udp.h>
 #include <linux/static_key.h>
+#include <linux/btf_ids.h>
 #include <trace/events/skb.h>
 #include <net/busy_poll.h>
 #include "udp_impl.h"
@@ -3129,7 +3130,7 @@ static void bpf_iter_fini_udp(void *priv_data)
 	bpf_iter_fini_seq_net(priv_data);
 }
 
-static const struct bpf_iter_reg udp_reg_info = {
+static struct bpf_iter_reg udp_reg_info = {
 	.target			= "udp",
 	.seq_ops		= &bpf_iter_udp_seq_ops,
 	.init_seq_private	= bpf_iter_init_udp,
@@ -3144,6 +3145,7 @@ static const struct bpf_iter_reg udp_reg_info = {
 
 static void __init bpf_iter_register(void)
 {
+	udp_reg_info.ctx_arg_info[0].btf_id = btf_sock_ids[BTF_SOCK_TYPE_UDP];
 	if (bpf_iter_reg_target(&udp_reg_info))
 		pr_warn("Warning: could not register bpf iterator udp\n");
 }
* Unmerged path net/ipv6/route.c
* Unmerged path net/netlink/af_netlink.c
