KVM: SVM: Remove set_cr_intercept, clr_cr_intercept and is_cr_intercept

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Babu Moger <babu.moger@amd.com>
commit 830bd71f2c0684b530970d0aea792a12c0cbcdd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/830bd71f.failed

Remove set_cr_intercept, clr_cr_intercept and is_cr_intercept. Instead
call generic svm_set_intercept, svm_clr_intercept an dsvm_is_intercep
tfor all cr intercepts.

	Signed-off-by: Babu Moger <babu.moger@amd.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
Message-Id: <159985253016.11252.16945893859439811480.stgit@bmoger-ubuntu>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 830bd71f2c0684b530970d0aea792a12c0cbcdd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.h
diff --cc arch/x86/kvm/svm/svm.h
index 7e2440454c08,4cd360e8a77a..000000000000
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@@ -217,29 -213,22 +217,48 @@@ static inline struct vmcb *get_host_vmc
  		return svm->vmcb;
  }
  
++<<<<<<< HEAD
 +static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)
 +{
 +	struct vmcb *vmcb = get_host_vmcb(svm);
 +
 +	vmcb->control.intercept_cr |= (1U << bit);
 +
 +	recalc_intercepts(svm);
 +}
 +
 +static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)
 +{
 +	struct vmcb *vmcb = get_host_vmcb(svm);
 +
 +	vmcb->control.intercept_cr &= ~(1U << bit);
 +
 +	recalc_intercepts(svm);
 +}
 +
 +static inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)
 +{
 +	struct vmcb *vmcb = get_host_vmcb(svm);
 +
 +	return vmcb->control.intercept_cr & (1U << bit);
++=======
+ static inline void vmcb_set_intercept(struct vmcb_control_area *control, u32 bit)
+ {
+ 	WARN_ON_ONCE(bit >= 32 * MAX_INTERCEPT);
+ 	__set_bit(bit, (unsigned long *)&control->intercepts);
+ }
+ 
+ static inline void vmcb_clr_intercept(struct vmcb_control_area *control, u32 bit)
+ {
+ 	WARN_ON_ONCE(bit >= 32 * MAX_INTERCEPT);
+ 	__clear_bit(bit, (unsigned long *)&control->intercepts);
+ }
+ 
+ static inline bool vmcb_is_intercept(struct vmcb_control_area *control, u32 bit)
+ {
+ 	WARN_ON_ONCE(bit >= 32 * MAX_INTERCEPT);
+ 	return test_bit(bit, (unsigned long *)&control->intercepts);
++>>>>>>> 830bd71f2c06 (KVM: SVM: Remove set_cr_intercept, clr_cr_intercept and is_cr_intercept)
  }
  
  static inline void set_dr_intercepts(struct vcpu_svm *svm)
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index ffcc287ce9b5..111dcb4884a4 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -991,14 +991,14 @@ static void init_vmcb(struct vcpu_svm *svm)
 
 	svm->vcpu.arch.hflags = 0;
 
-	set_cr_intercept(svm, INTERCEPT_CR0_READ);
-	set_cr_intercept(svm, INTERCEPT_CR3_READ);
-	set_cr_intercept(svm, INTERCEPT_CR4_READ);
-	set_cr_intercept(svm, INTERCEPT_CR0_WRITE);
-	set_cr_intercept(svm, INTERCEPT_CR3_WRITE);
-	set_cr_intercept(svm, INTERCEPT_CR4_WRITE);
+	svm_set_intercept(svm, INTERCEPT_CR0_READ);
+	svm_set_intercept(svm, INTERCEPT_CR3_READ);
+	svm_set_intercept(svm, INTERCEPT_CR4_READ);
+	svm_set_intercept(svm, INTERCEPT_CR0_WRITE);
+	svm_set_intercept(svm, INTERCEPT_CR3_WRITE);
+	svm_set_intercept(svm, INTERCEPT_CR4_WRITE);
 	if (!kvm_vcpu_apicv_active(&svm->vcpu))
-		set_cr_intercept(svm, INTERCEPT_CR8_WRITE);
+		svm_set_intercept(svm, INTERCEPT_CR8_WRITE);
 
 	set_dr_intercepts(svm);
 
@@ -1093,8 +1093,8 @@ static void init_vmcb(struct vcpu_svm *svm)
 		control->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;
 		svm_clr_intercept(svm, INTERCEPT_INVLPG);
 		clr_exception_intercept(svm, PF_VECTOR);
-		clr_cr_intercept(svm, INTERCEPT_CR3_READ);
-		clr_cr_intercept(svm, INTERCEPT_CR3_WRITE);
+		svm_clr_intercept(svm, INTERCEPT_CR3_READ);
+		svm_clr_intercept(svm, INTERCEPT_CR3_WRITE);
 		save->g_pat = svm->vcpu.arch.pat;
 		save->cr3 = 0;
 		save->cr4 = 0;
@@ -1536,11 +1536,11 @@ static void update_cr0_intercept(struct vcpu_svm *svm)
 	vmcb_mark_dirty(svm->vmcb, VMCB_CR);
 
 	if (gcr0 == *hcr0) {
-		clr_cr_intercept(svm, INTERCEPT_CR0_READ);
-		clr_cr_intercept(svm, INTERCEPT_CR0_WRITE);
+		svm_clr_intercept(svm, INTERCEPT_CR0_READ);
+		svm_clr_intercept(svm, INTERCEPT_CR0_WRITE);
 	} else {
-		set_cr_intercept(svm, INTERCEPT_CR0_READ);
-		set_cr_intercept(svm, INTERCEPT_CR0_WRITE);
+		svm_set_intercept(svm, INTERCEPT_CR0_READ);
+		svm_set_intercept(svm, INTERCEPT_CR0_WRITE);
 	}
 }
 
@@ -2926,7 +2926,7 @@ static int handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
 
 	trace_kvm_exit(exit_code, vcpu, KVM_ISA_SVM);
 
-	if (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))
+	if (!svm_is_intercept(svm, INTERCEPT_CR0_WRITE))
 		vcpu->arch.cr0 = svm->vmcb->save.cr0;
 	if (npt_enabled)
 		vcpu->arch.cr3 = svm->vmcb->save.cr3;
@@ -3047,13 +3047,13 @@ static void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)
 	if (nested_svm_virtualize_tpr(vcpu))
 		return;
 
-	clr_cr_intercept(svm, INTERCEPT_CR8_WRITE);
+	svm_clr_intercept(svm, INTERCEPT_CR8_WRITE);
 
 	if (irr == -1)
 		return;
 
 	if (tpr >= irr)
-		set_cr_intercept(svm, INTERCEPT_CR8_WRITE);
+		svm_set_intercept(svm, INTERCEPT_CR8_WRITE);
 }
 
 bool svm_nmi_blocked(struct kvm_vcpu *vcpu)
@@ -3241,7 +3241,7 @@ static inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)
 	if (nested_svm_virtualize_tpr(vcpu))
 		return;
 
-	if (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {
+	if (!svm_is_intercept(svm, INTERCEPT_CR8_WRITE)) {
 		int cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;
 		kvm_set_cr8(vcpu, cr8);
 	}
* Unmerged path arch/x86/kvm/svm/svm.h
