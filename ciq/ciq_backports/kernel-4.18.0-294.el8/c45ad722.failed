KVM: SVM: Introduce vmcb_(set_intercept/clr_intercept/_is_intercept)

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Babu Moger <babu.moger@amd.com>
commit c45ad7229d139ad48e894a271f8df6975e53d12e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/c45ad722.failed

This is in preparation for the future intercept vector additions.

Add new functions vmcb_set_intercept, vmcb_clr_intercept and vmcb_is_intercept
using kernel APIs __set_bit, __clear_bit and test_bit espectively.

	Signed-off-by: Babu Moger <babu.moger@amd.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
Message-Id: <159985247876.11252.16039238014239824460.stgit@bmoger-ubuntu>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c45ad7229d139ad48e894a271f8df6975e53d12e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/nested.c
diff --cc arch/x86/kvm/svm/nested.c
index 3a222ac541d6,69dfd7c1a5b7..000000000000
--- a/arch/x86/kvm/svm/nested.c
+++ b/arch/x86/kvm/svm/nested.c
@@@ -108,7 -109,8 +109,12 @@@ void recalc_intercepts(struct vcpu_svm 
  	h = &svm->nested.hsave->control;
  	g = &svm->nested.ctl;
  
++<<<<<<< HEAD
 +	svm->nested.host_intercept_exceptions = h->intercept_exceptions;
++=======
+ 	for (i = 0; i < MAX_INTERCEPT; i++)
+ 		c->intercepts[i] = h->intercepts[i];
++>>>>>>> c45ad7229d13 (KVM: SVM: Introduce vmcb_(set_intercept/clr_intercept/_is_intercept))
  
  	c->intercept_cr = h->intercept_cr;
  	c->intercept_dr = h->intercept_dr;
diff --git a/arch/x86/include/asm/svm.h b/arch/x86/include/asm/svm.h
index acac55d6f941..6e11237a0a71 100644
--- a/arch/x86/include/asm/svm.h
+++ b/arch/x86/include/asm/svm.h
@@ -4,6 +4,14 @@
 
 #include <uapi/asm/svm.h>
 
+/*
+ * 32-bit intercept words in the VMCB Control Area, starting
+ * at Byte offset 000h.
+ */
+
+enum intercept_words {
+	MAX_INTERCEPT,
+};
 
 enum {
 	INTERCEPT_INTR,
@@ -57,6 +65,7 @@ enum {
 
 
 struct __attribute__ ((__packed__)) vmcb_control_area {
+	u32 intercepts[MAX_INTERCEPT];
 	u32 intercept_cr;
 	u32 intercept_dr;
 	u32 intercept_exceptions;
* Unmerged path arch/x86/kvm/svm/nested.c
diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.h
index 7e2440454c08..bf9346d7783a 100644
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@ -217,6 +217,24 @@ static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)
 		return svm->vmcb;
 }
 
+static inline void vmcb_set_intercept(struct vmcb_control_area *control, u32 bit)
+{
+	WARN_ON_ONCE(bit >= 32 * MAX_INTERCEPT);
+	__set_bit(bit, (unsigned long *)&control->intercepts);
+}
+
+static inline void vmcb_clr_intercept(struct vmcb_control_area *control, u32 bit)
+{
+	WARN_ON_ONCE(bit >= 32 * MAX_INTERCEPT);
+	__clear_bit(bit, (unsigned long *)&control->intercepts);
+}
+
+static inline bool vmcb_is_intercept(struct vmcb_control_area *control, u32 bit)
+{
+	WARN_ON_ONCE(bit >= 32 * MAX_INTERCEPT);
+	return test_bit(bit, (unsigned long *)&control->intercepts);
+}
+
 static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)
 {
 	struct vmcb *vmcb = get_host_vmcb(svm);
