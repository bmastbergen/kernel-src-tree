bpf: Sync linux/bpf.h to tools/

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Jakub Sitnicki <jakub@cloudflare.com>
commit a352b32ae969788b706f666f764702cd0ab4a40a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/a352b32a.failed

Newly added program, context type and helper is used by tests in a
subsequent patch. Synchronize the header file.

	Signed-off-by: Jakub Sitnicki <jakub@cloudflare.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20200717103536.397595-12-jakub@cloudflare.com
(cherry picked from commit a352b32ae969788b706f666f764702cd0ab4a40a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/include/uapi/linux/bpf.h
diff --cc tools/include/uapi/linux/bpf.h
index 9f6d3977ecf3,54d0c886e3ba..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -217,6 -221,15 +218,18 @@@ enum bpf_attach_type 
  	BPF_TRACE_FEXIT,
  	BPF_MODIFY_RETURN,
  	BPF_LSM_MAC,
++<<<<<<< HEAD
++=======
+ 	BPF_TRACE_ITER,
+ 	BPF_CGROUP_INET4_GETPEERNAME,
+ 	BPF_CGROUP_INET6_GETPEERNAME,
+ 	BPF_CGROUP_INET4_GETSOCKNAME,
+ 	BPF_CGROUP_INET6_GETSOCKNAME,
+ 	BPF_XDP_DEVMAP,
+ 	BPF_CGROUP_INET_SOCK_RELEASE,
+ 	BPF_XDP_CPUMAP,
+ 	BPF_SK_LOOKUP,
++>>>>>>> a352b32ae969 (bpf: Sync linux/bpf.h to tools/)
  	__MAX_BPF_ATTACH_TYPE
  };
  
@@@ -3036,8 -3069,12 +3049,12 @@@ union bpf_attr 
   * 	Return
   * 		The id is returned or 0 in case the id could not be retrieved.
   *
 - * long bpf_sk_assign(struct sk_buff *skb, struct bpf_sock *sk, u64 flags)
 + * int bpf_sk_assign(struct sk_buff *skb, struct bpf_sock *sk, u64 flags)
   *	Description
+  *		Helper is overloaded depending on BPF program type. This
+  *		description applies to **BPF_PROG_TYPE_SCHED_CLS** and
+  *		**BPF_PROG_TYPE_SCHED_ACT** programs.
+  *
   *		Assign the *sk* to the *skb*. When combined with appropriate
   *		routing configuration to receive the packet towards the socket,
   *		will cause *skb* to be delivered to the specified socket.
@@@ -3049,15 -3086,70 +3066,65 @@@
   *
   *		The *flags* argument must be zero.
   *	Return
 - *		0 on success, or a negative error in case of failure:
 - *
 - *		**-EINVAL** if specified *flags* are not supported.
 - *
 - *		**-ENOENT** if the socket is unavailable for assignment.
 - *
 - *		**-ENETUNREACH** if the socket is unreachable (wrong netns).
 - *
 - *		**-EOPNOTSUPP** if the operation is not supported, for example
 - *		a call from outside of TC ingress.
 + *		0 on success, or a negative errno in case of failure.
   *
 - *		**-ESOCKTNOSUPPORT** if the socket type is not supported
 - *		(reuseport).
 + *		* **-EINVAL**		Unsupported flags specified.
 + *		* **-ENOENT**		Socket is unavailable for assignment.
 + *		* **-ENETUNREACH**	Socket is unreachable (wrong netns).
 + *		* **-EOPNOTSUPP**	Unsupported operation, for example a
 + *					call from outside of TC ingress.
 + *		* **-ESOCKTNOSUPPORT**	Socket type not supported (reuseport).
   *
+  * long bpf_sk_assign(struct bpf_sk_lookup *ctx, struct bpf_sock *sk, u64 flags)
+  *	Description
+  *		Helper is overloaded depending on BPF program type. This
+  *		description applies to **BPF_PROG_TYPE_SK_LOOKUP** programs.
+  *
+  *		Select the *sk* as a result of a socket lookup.
+  *
+  *		For the operation to succeed passed socket must be compatible
+  *		with the packet description provided by the *ctx* object.
+  *
+  *		L4 protocol (**IPPROTO_TCP** or **IPPROTO_UDP**) must
+  *		be an exact match. While IP family (**AF_INET** or
+  *		**AF_INET6**) must be compatible, that is IPv6 sockets
+  *		that are not v6-only can be selected for IPv4 packets.
+  *
+  *		Only TCP listeners and UDP unconnected sockets can be
+  *		selected. *sk* can also be NULL to reset any previous
+  *		selection.
+  *
+  *		*flags* argument can combination of following values:
+  *
+  *		* **BPF_SK_LOOKUP_F_REPLACE** to override the previous
+  *		  socket selection, potentially done by a BPF program
+  *		  that ran before us.
+  *
+  *		* **BPF_SK_LOOKUP_F_NO_REUSEPORT** to skip
+  *		  load-balancing within reuseport group for the socket
+  *		  being selected.
+  *
+  *		On success *ctx->sk* will point to the selected socket.
+  *
+  *	Return
+  *		0 on success, or a negative errno in case of failure.
+  *
+  *		* **-EAFNOSUPPORT** if socket family (*sk->family*) is
+  *		  not compatible with packet family (*ctx->family*).
+  *
+  *		* **-EEXIST** if socket has been already selected,
+  *		  potentially by another program, and
+  *		  **BPF_SK_LOOKUP_F_REPLACE** flag was not specified.
+  *
+  *		* **-EINVAL** if unsupported flags were specified.
+  *
+  *		* **-EPROTOTYPE** if socket L4 protocol
+  *		  (*sk->protocol*) doesn't match packet protocol
+  *		  (*ctx->protocol*).
+  *
+  *		* **-ESOCKTNOSUPPORT** if socket is not in allowed
+  *		  state (TCP listening or UDP unconnected).
+  *
   * u64 bpf_ktime_get_boot_ns(void)
   * 	Description
   * 		Return the time elapsed since system boot, in nanoseconds.
@@@ -3340,6 -3640,35 +3407,38 @@@ enum 
  	BPF_F_GET_BRANCH_RECORDS_SIZE	= (1ULL << 0),
  };
  
++<<<<<<< HEAD
++=======
+ /* BPF_FUNC_bpf_ringbuf_commit, BPF_FUNC_bpf_ringbuf_discard, and
+  * BPF_FUNC_bpf_ringbuf_output flags.
+  */
+ enum {
+ 	BPF_RB_NO_WAKEUP		= (1ULL << 0),
+ 	BPF_RB_FORCE_WAKEUP		= (1ULL << 1),
+ };
+ 
+ /* BPF_FUNC_bpf_ringbuf_query flags */
+ enum {
+ 	BPF_RB_AVAIL_DATA = 0,
+ 	BPF_RB_RING_SIZE = 1,
+ 	BPF_RB_CONS_POS = 2,
+ 	BPF_RB_PROD_POS = 3,
+ };
+ 
+ /* BPF ring buffer constants */
+ enum {
+ 	BPF_RINGBUF_BUSY_BIT		= (1U << 31),
+ 	BPF_RINGBUF_DISCARD_BIT		= (1U << 30),
+ 	BPF_RINGBUF_HDR_SZ		= 8,
+ };
+ 
+ /* BPF_FUNC_sk_assign flags in bpf_sk_lookup context. */
+ enum {
+ 	BPF_SK_LOOKUP_F_REPLACE		= (1ULL << 0),
+ 	BPF_SK_LOOKUP_F_NO_REUSEPORT	= (1ULL << 1),
+ };
+ 
++>>>>>>> a352b32ae969 (bpf: Sync linux/bpf.h to tools/)
  /* Mode for BPF_FUNC_skb_adjust_room helper. */
  enum bpf_adj_room_mode {
  	BPF_ADJ_ROOM_NET,
* Unmerged path tools/include/uapi/linux/bpf.h
