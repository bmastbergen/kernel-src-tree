intel_idle: Clean up kerneldoc comments for multiple functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 6eacb15fef4ef90b8c6467bd80b8be2de1fe1b3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/6eacb15f.failed

Turn the description comments of some functions in the intel_idle
driver into proper kerneldoc ones and clean them up.

No functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 6eacb15fef4ef90b8c6467bd80b8be2de1fe1b3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/idle/intel_idle.c
diff --cc drivers/idle/intel_idle.c
index adafee3bbdac,9575615c8f4a..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -1328,80 -1288,13 +1328,85 @@@ static inline void intel_idle_init_csta
  static inline bool intel_idle_off_by_default(u32 mwait_hint) { return false; }
  #endif /* !CONFIG_ACPI_PROCESSOR_CSTATE */
  
++<<<<<<< HEAD
 +/*
 + * intel_idle_probe()
 + */
 +static int __init intel_idle_probe(void)
 +{
 +	unsigned int eax, ebx, ecx;
 +	const struct x86_cpu_id *id;
 +
 +	if (max_cstate == 0) {
 +		pr_debug("disabled\n");
 +		return -EPERM;
 +	}
 +
 +	id = x86_match_cpu(intel_idle_ids);
 +	if (id) {
 +		if (!boot_cpu_has(X86_FEATURE_MWAIT)) {
 +			pr_debug("Please enable MWAIT in BIOS SETUP\n");
 +			return -ENODEV;
 +		}
 +	} else {
 +		id = x86_match_cpu(intel_mwait_ids);
 +		if (!id)
 +			return -ENODEV;
 +	}
 +
 +	if (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)
 +		return -ENODEV;
 +
 +	cpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &mwait_substates);
 +
 +	if (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||
 +	    !(ecx & CPUID5_ECX_INTERRUPT_BREAK) ||
 +	    !mwait_substates)
 +			return -ENODEV;
 +
 +	pr_debug("MWAIT substates: 0x%x\n", mwait_substates);
 +
 +	icpu = (const struct idle_cpu *)id->driver_data;
 +	if (icpu) {
 +		cpuidle_state_table = icpu->state_table;
 +		if (icpu->use_acpi && force_use_acpi)
 +			intel_idle_acpi_cst_extract();
 +	} else if (!intel_idle_acpi_cst_extract()) {
 +		return -ENODEV;
 +	}
 +
 +	pr_debug("v" INTEL_IDLE_VERSION " model 0x%X\n",
 +		 boot_cpu_data.x86_model);
 +
 +	return 0;
 +}
 +
 +/*
 + * intel_idle_cpuidle_devices_uninit()
 + * Unregisters the cpuidle devices.
 + */
 +static void intel_idle_cpuidle_devices_uninit(void)
 +{
 +	int i;
 +	struct cpuidle_device *dev;
 +
 +	for_each_online_cpu(i) {
 +		dev = per_cpu_ptr(intel_idle_cpuidle_devices, i);
 +		cpuidle_unregister_device(dev);
 +	}
 +}
 +
 +/*
 + * ivt_idle_state_table_update(void)
++=======
+ /**
+  * ivt_idle_state_table_update - Tune the idle states table for Ivy Town.
++>>>>>>> 6eacb15fef4e (intel_idle: Clean up kerneldoc comments for multiple functions)
   *
-  * Tune IVT multi-socket targets
-  * Assumption: num_sockets == (max_package_num + 1)
+  * Tune IVT multi-socket targets.
+  * Assumption: num_sockets == (max_package_num + 1).
   */
 -static void __init ivt_idle_state_table_update(void)
 +static void ivt_idle_state_table_update(void)
  {
  	/* IVT uses a different table for 1-2, 3-4, and > 4 sockets */
  	int cpu, package_num, num_sockets = 1;
@@@ -1440,15 -1335,16 +1445,21 @@@ static unsigned long long irtl_2_usec(u
  
  	ns = irtl_ns_units[(irtl >> 10) & 0x7];
  
 -	return div_u64((irtl & 0x3FF) * ns, NSEC_PER_USEC);
 +	return div64_u64((irtl & 0x3FF) * ns, 1000);
  }
++<<<<<<< HEAD
 +/*
 + * bxt_idle_state_table_update(void)
++=======
+ 
+ /**
+  * bxt_idle_state_table_update - Fix up the Broxton idle states table.
++>>>>>>> 6eacb15fef4e (intel_idle: Clean up kerneldoc comments for multiple functions)
   *
-  * On BXT, we trust the IRTL to show the definitive maximum latency
-  * We use the same value for target_residency.
+  * On BXT, trust the IRTL (Interrupt Response Time Limit) MSR to show the
+  * definitive maximum latency and use the same value for target_residency.
   */
 -static void __init bxt_idle_state_table_update(void)
 +static void bxt_idle_state_table_update(void)
  {
  	unsigned long long msr;
  	unsigned int usec;
@@@ -1489,13 -1385,13 +1500,13 @@@
  	}
  
  }
- /*
-  * sklh_idle_state_table_update(void)
+ 
+ /**
+  * sklh_idle_state_table_update - Fix up the Sky Lake idle states table.
   *
-  * On SKL-H (model 0x5e) disable C8 and C9 if:
-  * C10 is enabled and SGX disabled
+  * On SKL-H (model 0x5e) skip C8 and C9 if C10 is enabled and SGX disabled.
   */
 -static void __init sklh_idle_state_table_update(void)
 +static void sklh_idle_state_table_update(void)
  {
  	unsigned long long msr;
  	unsigned int eax, ebx, ecx, edx;
@@@ -1602,10 -1519,30 +1613,37 @@@ static void __init intel_idle_cpuidle_d
  		intel_idle_init_cstates_acpi(drv);
  }
  
++<<<<<<< HEAD
 +/*
 + * intel_idle_cpu_init()
 + * allocate, initialize, register cpuidle_devices
 + * @cpu: cpu/core to initialize
++=======
+ static void auto_demotion_disable(void)
+ {
+ 	unsigned long long msr_bits;
+ 
+ 	rdmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);
+ 	msr_bits &= ~auto_demotion_disable_flags;
+ 	wrmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);
+ }
+ 
+ static void c1e_promotion_disable(void)
+ {
+ 	unsigned long long msr_bits;
+ 
+ 	rdmsrl(MSR_IA32_POWER_CTL, msr_bits);
+ 	msr_bits &= ~0x2;
+ 	wrmsrl(MSR_IA32_POWER_CTL, msr_bits);
+ }
+ 
+ /**
+  * intel_idle_cpu_init - Register the target CPU with the cpuidle core.
+  * @cpu: CPU to initialize.
+  *
+  * Register a cpuidle device object for @cpu and update its MSRs in accordance
+  * with the processor model flags.
++>>>>>>> 6eacb15fef4e (intel_idle: Clean up kerneldoc comments for multiple functions)
   */
  static int intel_idle_cpu_init(unsigned int cpu)
  {
* Unmerged path drivers/idle/intel_idle.c
