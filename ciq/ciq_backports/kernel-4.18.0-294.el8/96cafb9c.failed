fs_parser: remove fs_parameter_description name field

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Eric Sandeen <sandeen@sandeen.net>
commit 96cafb9ccb153f6a82ff2c9bde68916d9d65501e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/96cafb9c.failed

Unused now.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Acked-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 96cafb9ccb153f6a82ff2c9bde68916d9d65501e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/cell/spufs/inode.c
#	arch/s390/hypfs/inode.c
#	arch/x86/kernel/cpu/resctrl/rdtgroup.c
#	drivers/block/rbd.c
#	drivers/usb/gadget/function/f_fs.c
#	fs/afs/super.c
#	fs/ceph/super.c
#	fs/filesystems.c
#	fs/fs_parser.c
#	fs/fuse/inode.c
#	fs/jffs2/super.c
#	fs/nfs/fs_context.c
#	fs/proc/root.c
#	fs/ramfs/inode.c
#	fs/xfs/xfs_super.c
#	include/linux/fs_parser.h
#	kernel/bpf/inode.c
#	kernel/cgroup/cgroup-v1.c
#	kernel/cgroup/cgroup.c
#	mm/shmem.c
#	net/ceph/ceph_common.c
#	security/selinux/hooks.c
#	security/smack/smack_lsm.c
diff --cc arch/powerpc/platforms/cell/spufs/inode.c
index db329d4bf1c3,36ce5d0ac675..000000000000
--- a/arch/powerpc/platforms/cell/spufs/inode.c
+++ b/arch/powerpc/platforms/cell/spufs/inode.c
@@@ -593,16 -573,26 +593,29 @@@ long spufs_create(struct path *path, st
  }
  
  /* File system initialization */
 -struct spufs_fs_context {
 -	kuid_t	uid;
 -	kgid_t	gid;
 -	umode_t	mode;
 -};
 -
  enum {
 -	Opt_uid, Opt_gid, Opt_mode, Opt_debug,
 +	Opt_uid, Opt_gid, Opt_mode, Opt_debug, Opt_err,
  };
  
++<<<<<<< HEAD
 +static const match_table_t spufs_tokens = {
 +	{ Opt_uid,   "uid=%d" },
 +	{ Opt_gid,   "gid=%d" },
 +	{ Opt_mode,  "mode=%o" },
 +	{ Opt_debug, "debug" },
 +	{ Opt_err,    NULL  },
++=======
+ static const struct fs_parameter_spec spufs_param_specs[] = {
+ 	fsparam_u32	("gid",				Opt_gid),
+ 	fsparam_u32oct	("mode",			Opt_mode),
+ 	fsparam_u32	("uid",				Opt_uid),
+ 	fsparam_flag	("debug",			Opt_debug),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description spufs_fs_parameters = {
+ 	.specs		= spufs_param_specs,
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  };
  
  static int spufs_show_options(struct seq_file *m, struct dentry *root)
diff --cc arch/s390/hypfs/inode.c
index 06b513d192b9,b3a6d13a63bf..000000000000
--- a/arch/s390/hypfs/inode.c
+++ b/arch/s390/hypfs/inode.c
@@@ -207,52 -207,43 +207,60 @@@ static int hypfs_release(struct inode *
  	return 0;
  }
  
 -enum { Opt_uid, Opt_gid, };
 +enum { opt_uid, opt_gid, opt_err };
  
 -static const struct fs_parameter_spec hypfs_param_specs[] = {
 -	fsparam_u32("gid", Opt_gid),
 -	fsparam_u32("uid", Opt_uid),
 -	{}
 +static const match_table_t hypfs_tokens = {
 +	{opt_uid, "uid=%u"},
 +	{opt_gid, "gid=%u"},
 +	{opt_err, NULL}
  };
  
++<<<<<<< HEAD
 +static int hypfs_parse_options(char *options, struct super_block *sb)
++=======
+ static const struct fs_parameter_description hypfs_fs_parameters = {
+ 	.specs		= hypfs_param_specs,
+ };
+ 
+ static int hypfs_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct hypfs_sb_info *hypfs_info = fc->s_fs_info;
 -	struct fs_parse_result result;
 +	char *str;
 +	substring_t args[MAX_OPT_ARGS];
  	kuid_t uid;
  	kgid_t gid;
 -	int opt;
 -
 -	opt = fs_parse(fc, &hypfs_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case Opt_uid:
 -		uid = make_kuid(current_user_ns(), result.uint_32);
 -		if (!uid_valid(uid))
 -			return invalf(fc, "Unknown uid");
 -		hypfs_info->uid = uid;
 -		break;
 -	case Opt_gid:
 -		gid = make_kgid(current_user_ns(), result.uint_32);
 -		if (!gid_valid(gid))
 -			return invalf(fc, "Unknown gid");
 -		hypfs_info->gid = gid;
 -		break;
 +
 +	if (!options)
 +		return 0;
 +	while ((str = strsep(&options, ",")) != NULL) {
 +		int token, option;
 +		struct hypfs_sb_info *hypfs_info = sb->s_fs_info;
 +
 +		if (!*str)
 +			continue;
 +		token = match_token(str, hypfs_tokens, args);
 +		switch (token) {
 +		case opt_uid:
 +			if (match_int(&args[0], &option))
 +				return -EINVAL;
 +			uid = make_kuid(current_user_ns(), option);
 +			if (!uid_valid(uid))
 +				return -EINVAL;
 +			hypfs_info->uid = uid;
 +			break;
 +		case opt_gid:
 +			if (match_int(&args[0], &option))
 +				return -EINVAL;
 +			gid = make_kgid(current_user_ns(), option);
 +			if (!gid_valid(gid))
 +				return -EINVAL;
 +			hypfs_info->gid = gid;
 +			break;
 +		case opt_err:
 +		default:
 +			pr_err("%s is not a valid mount option\n", str);
 +			return -EINVAL;
 +		}
  	}
  	return 0;
  }
diff --cc arch/x86/kernel/cpu/resctrl/rdtgroup.c
index 08d67c922eb5,f145594e4d6a..000000000000
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@@ -2232,8 -2027,84 +2232,86 @@@ out
  	rdt_last_cmd_clear();
  	mutex_unlock(&rdtgroup_mutex);
  	cpus_read_unlock();
 -	return ret;
 -}
  
++<<<<<<< HEAD
 +	return dentry;
++=======
+ enum rdt_param {
+ 	Opt_cdp,
+ 	Opt_cdpl2,
+ 	Opt_mba_mbps,
+ 	nr__rdt_params
+ };
+ 
+ static const struct fs_parameter_spec rdt_param_specs[] = {
+ 	fsparam_flag("cdp",		Opt_cdp),
+ 	fsparam_flag("cdpl2",		Opt_cdpl2),
+ 	fsparam_flag("mba_MBps",	Opt_mba_mbps),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description rdt_fs_parameters = {
+ 	.specs		= rdt_param_specs,
+ };
+ 
+ static int rdt_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct rdt_fs_context *ctx = rdt_fc2context(fc);
+ 	struct fs_parse_result result;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, &rdt_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_cdp:
+ 		ctx->enable_cdpl3 = true;
+ 		return 0;
+ 	case Opt_cdpl2:
+ 		ctx->enable_cdpl2 = true;
+ 		return 0;
+ 	case Opt_mba_mbps:
+ 		if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)
+ 			return -EINVAL;
+ 		ctx->enable_mba_mbps = true;
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static void rdt_fs_context_free(struct fs_context *fc)
+ {
+ 	struct rdt_fs_context *ctx = rdt_fc2context(fc);
+ 
+ 	kernfs_free_fs_context(fc);
+ 	kfree(ctx);
+ }
+ 
+ static const struct fs_context_operations rdt_fs_context_ops = {
+ 	.free		= rdt_fs_context_free,
+ 	.parse_param	= rdt_parse_param,
+ 	.get_tree	= rdt_get_tree,
+ };
+ 
+ static int rdt_init_fs_context(struct fs_context *fc)
+ {
+ 	struct rdt_fs_context *ctx;
+ 
+ 	ctx = kzalloc(sizeof(struct rdt_fs_context), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	ctx->kfc.root = rdt_root;
+ 	ctx->kfc.magic = RDTGROUP_SUPER_MAGIC;
+ 	fc->fs_private = &ctx->kfc;
+ 	fc->ops = &rdt_fs_context_ops;
+ 	put_user_ns(fc->user_ns);
+ 	fc->user_ns = get_user_ns(&init_user_ns);
+ 	fc->global = true;
+ 	return 0;
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  }
  
  static int reset_all_ctrls(struct rdt_resource *r)
diff --cc drivers/block/rbd.c
index d16fcad4775c,e87486920382..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -846,25 -846,25 +846,45 @@@ enum 
  	Opt_lock_on_read,
  	Opt_exclusive,
  	Opt_notrim,
 +	Opt_err
  };
  
++<<<<<<< HEAD
 +static match_table_t rbd_opts_tokens = {
 +	{Opt_queue_depth, "queue_depth=%d"},
 +	{Opt_alloc_size, "alloc_size=%d"},
 +	{Opt_lock_timeout, "lock_timeout=%d"},
 +	/* int args above */
 +	{Opt_pool_ns, "_pool_ns=%s"},
 +	{Opt_compression_hint, "compression_hint=%s"},
 +	/* string args above */
 +	{Opt_read_only, "read_only"},
 +	{Opt_read_only, "ro"},		/* Alternate spelling */
 +	{Opt_read_write, "read_write"},
 +	{Opt_read_write, "rw"},		/* Alternate spelling */
 +	{Opt_lock_on_read, "lock_on_read"},
 +	{Opt_exclusive, "exclusive"},
 +	{Opt_notrim, "notrim"},
 +	{Opt_err, NULL}
++=======
+ static const struct fs_parameter_spec rbd_param_specs[] = {
+ 	fsparam_u32	("alloc_size",			Opt_alloc_size),
+ 	fsparam_flag	("exclusive",			Opt_exclusive),
+ 	fsparam_flag	("lock_on_read",		Opt_lock_on_read),
+ 	fsparam_u32	("lock_timeout",		Opt_lock_timeout),
+ 	fsparam_flag	("notrim",			Opt_notrim),
+ 	fsparam_string	("_pool_ns",			Opt_pool_ns),
+ 	fsparam_u32	("queue_depth",			Opt_queue_depth),
+ 	fsparam_flag	("read_only",			Opt_read_only),
+ 	fsparam_flag	("read_write",			Opt_read_write),
+ 	fsparam_flag	("ro",				Opt_read_only),
+ 	fsparam_flag	("rw",				Opt_read_write),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description rbd_parameters = {
+ 	.specs		= rbd_param_specs,
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  };
  
  struct rbd_options {
diff --cc drivers/usb/gadget/function/f_fs.c
index ea21ee799739,eda1972b70eb..000000000000
--- a/drivers/usb/gadget/function/f_fs.c
+++ b/drivers/usb/gadget/function/f_fs.c
@@@ -1486,90 -1477,69 +1486,117 @@@ static int ffs_sb_fill(struct super_blo
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts)
++=======
+ enum {
+ 	Opt_no_disconnect,
+ 	Opt_rmode,
+ 	Opt_fmode,
+ 	Opt_mode,
+ 	Opt_uid,
+ 	Opt_gid,
+ };
+ 
+ static const struct fs_parameter_spec ffs_fs_param_specs[] = {
+ 	fsparam_bool	("no_disconnect",	Opt_no_disconnect),
+ 	fsparam_u32	("rmode",		Opt_rmode),
+ 	fsparam_u32	("fmode",		Opt_fmode),
+ 	fsparam_u32	("mode",		Opt_mode),
+ 	fsparam_u32	("uid",			Opt_uid),
+ 	fsparam_u32	("gid",			Opt_gid),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description ffs_fs_fs_parameters = {
+ 	.specs		= ffs_fs_param_specs,
+ };
+ 
+ static int ffs_fs_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct ffs_sb_fill_data *data = fc->fs_private;
 -	struct fs_parse_result result;
 -	int opt;
 -
  	ENTER();
  
 -	opt = fs_parse(fc, &ffs_fs_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 +	if (!opts || !*opts)
 +		return 0;
  
 -	switch (opt) {
 -	case Opt_no_disconnect:
 -		data->no_disconnect = result.boolean;
 -		break;
 -	case Opt_rmode:
 -		data->root_mode  = (result.uint_32 & 0555) | S_IFDIR;
 -		break;
 -	case Opt_fmode:
 -		data->perms.mode = (result.uint_32 & 0666) | S_IFREG;
 -		break;
 -	case Opt_mode:
 -		data->root_mode  = (result.uint_32 & 0555) | S_IFDIR;
 -		data->perms.mode = (result.uint_32 & 0666) | S_IFREG;
 -		break;
 +	for (;;) {
 +		unsigned long value;
 +		char *eq, *comma;
 +
 +		/* Option limit */
 +		comma = strchr(opts, ',');
 +		if (comma)
 +			*comma = 0;
 +
 +		/* Value limit */
 +		eq = strchr(opts, '=');
 +		if (unlikely(!eq)) {
 +			pr_err("'=' missing in %s\n", opts);
 +			return -EINVAL;
 +		}
 +		*eq = 0;
  
 -	case Opt_uid:
 -		data->perms.uid = make_kuid(current_user_ns(), result.uint_32);
 -		if (!uid_valid(data->perms.uid))
 -			goto unmapped_value;
 -		break;
 -	case Opt_gid:
 -		data->perms.gid = make_kgid(current_user_ns(), result.uint_32);
 -		if (!gid_valid(data->perms.gid))
 -			goto unmapped_value;
 -		break;
 +		/* Parse value */
 +		if (kstrtoul(eq + 1, 0, &value)) {
 +			pr_err("%s: invalid value: %s\n", opts, eq + 1);
 +			return -EINVAL;
 +		}
  
 -	default:
 -		return -ENOPARAM;
 +		/* Interpret option */
 +		switch (eq - opts) {
 +		case 13:
 +			if (!memcmp(opts, "no_disconnect", 13))
 +				data->no_disconnect = !!value;
 +			else
 +				goto invalid;
 +			break;
 +		case 5:
 +			if (!memcmp(opts, "rmode", 5))
 +				data->root_mode  = (value & 0555) | S_IFDIR;
 +			else if (!memcmp(opts, "fmode", 5))
 +				data->perms.mode = (value & 0666) | S_IFREG;
 +			else
 +				goto invalid;
 +			break;
 +
 +		case 4:
 +			if (!memcmp(opts, "mode", 4)) {
 +				data->root_mode  = (value & 0555) | S_IFDIR;
 +				data->perms.mode = (value & 0666) | S_IFREG;
 +			} else {
 +				goto invalid;
 +			}
 +			break;
 +
 +		case 3:
 +			if (!memcmp(opts, "uid", 3)) {
 +				data->perms.uid = make_kuid(current_user_ns(), value);
 +				if (!uid_valid(data->perms.uid)) {
 +					pr_err("%s: unmapped value: %lu\n", opts, value);
 +					return -EINVAL;
 +				}
 +			} else if (!memcmp(opts, "gid", 3)) {
 +				data->perms.gid = make_kgid(current_user_ns(), value);
 +				if (!gid_valid(data->perms.gid)) {
 +					pr_err("%s: unmapped value: %lu\n", opts, value);
 +					return -EINVAL;
 +				}
 +			} else {
 +				goto invalid;
 +			}
 +			break;
 +
 +		default:
 +invalid:
 +			pr_err("%s: invalid option\n", opts);
 +			return -EINVAL;
 +		}
 +
 +		/* Next iteration */
 +		if (!comma)
 +			break;
 +		opts = comma + 1;
  	}
  
  	return 0;
diff --cc fs/afs/super.c
index 44f8cce1c926,862c806bc22f..000000000000
--- a/fs/afs/super.c
+++ b/fs/afs/super.c
@@@ -63,22 -66,31 +63,43 @@@ static const struct super_operations af
  static struct kmem_cache *afs_inode_cachep;
  static atomic_t afs_count_active_inodes;
  
 -enum afs_param {
 -	Opt_autocell,
 -	Opt_dyn,
 -	Opt_flock,
 -	Opt_source,
 +enum {
 +	afs_no_opt,
 +	afs_opt_cell,
 +	afs_opt_dyn,
 +	afs_opt_rwpath,
 +	afs_opt_vol,
 +	afs_opt_autocell,
  };
  
++<<<<<<< HEAD
 +static const match_table_t afs_options_list = {
 +	{ afs_opt_cell,		"cell=%s"	},
 +	{ afs_opt_dyn,		"dyn"		},
 +	{ afs_opt_rwpath,	"rwpath"	},
 +	{ afs_opt_vol,		"vol=%s"	},
 +	{ afs_opt_autocell,	"autocell"	},
 +	{ afs_no_opt,		NULL		},
++=======
+ static const struct constant_table afs_param_flock[] = {
+ 	{"local",	afs_flock_mode_local },
+ 	{"openafs",	afs_flock_mode_openafs },
+ 	{"strict",	afs_flock_mode_strict },
+ 	{"write",	afs_flock_mode_write },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec afs_param_specs[] = {
+ 	fsparam_flag  ("autocell",	Opt_autocell),
+ 	fsparam_flag  ("dyn",		Opt_dyn),
+ 	fsparam_enum  ("flock",		Opt_flock, afs_param_flock),
+ 	fsparam_string("source",	Opt_source),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description afs_fs_parameters = {
+ 	.specs		= afs_param_specs,
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  };
  
  /*
diff --cc fs/ceph/super.c
index f940cf50b7f6,497469149e4b..000000000000
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@@ -140,107 -142,140 +140,165 @@@ enum 
  	/* int args above */
  	Opt_snapdirname,
  	Opt_mds_namespace,
 +	Opt_fscache_uniq,
  	Opt_recover_session,
 -	Opt_source,
 +	Opt_last_string,
  	/* string args above */
  	Opt_dirstat,
 +	Opt_nodirstat,
  	Opt_rbytes,
 +	Opt_norbytes,
  	Opt_asyncreaddir,
 +	Opt_noasyncreaddir,
  	Opt_dcache,
 +	Opt_nodcache,
  	Opt_ino32,
 +	Opt_noino32,
  	Opt_fscache,
 +	Opt_nofscache,
  	Opt_poolperm,
 +	Opt_nopoolperm,
  	Opt_require_active_mds,
 +	Opt_norequire_active_mds,
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
  	Opt_acl,
 +#endif
 +	Opt_noacl,
  	Opt_quotadf,
 +	Opt_noquotadf,
  	Opt_copyfrom,
 +	Opt_nocopyfrom,
 +	Opt_wsync,
 +	Opt_nowsync,
  };
  
 -enum ceph_recover_session_mode {
 -	ceph_recover_session_no,
 -	ceph_recover_session_clean
 +static match_table_t fsopt_tokens = {
 +	{Opt_wsize, "wsize=%d"},
 +	{Opt_rsize, "rsize=%d"},
 +	{Opt_rasize, "rasize=%d"},
 +	{Opt_caps_wanted_delay_min, "caps_wanted_delay_min=%d"},
 +	{Opt_caps_wanted_delay_max, "caps_wanted_delay_max=%d"},
 +	{Opt_caps_max, "caps_max=%d"},
 +	{Opt_readdir_max_entries, "readdir_max_entries=%d"},
 +	{Opt_readdir_max_bytes, "readdir_max_bytes=%d"},
 +	{Opt_congestion_kb, "write_congestion_kb=%d"},
 +	/* int args above */
 +	{Opt_snapdirname, "snapdirname=%s"},
 +	{Opt_mds_namespace, "mds_namespace=%s"},
 +	{Opt_recover_session, "recover_session=%s"},
 +	{Opt_fscache_uniq, "fsc=%s"},
 +	/* string args above */
 +	{Opt_dirstat, "dirstat"},
 +	{Opt_nodirstat, "nodirstat"},
 +	{Opt_rbytes, "rbytes"},
 +	{Opt_norbytes, "norbytes"},
 +	{Opt_asyncreaddir, "asyncreaddir"},
 +	{Opt_noasyncreaddir, "noasyncreaddir"},
 +	{Opt_dcache, "dcache"},
 +	{Opt_nodcache, "nodcache"},
 +	{Opt_ino32, "ino32"},
 +	{Opt_noino32, "noino32"},
 +	{Opt_fscache, "fsc"},
 +	{Opt_nofscache, "nofsc"},
 +	{Opt_poolperm, "poolperm"},
 +	{Opt_nopoolperm, "nopoolperm"},
 +	{Opt_require_active_mds, "require_active_mds"},
 +	{Opt_norequire_active_mds, "norequire_active_mds"},
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
 +	{Opt_acl, "acl"},
 +#endif
 +	{Opt_noacl, "noacl"},
 +	{Opt_quotadf, "quotadf"},
 +	{Opt_noquotadf, "noquotadf"},
 +	{Opt_copyfrom, "copyfrom"},
 +	{Opt_nocopyfrom, "nocopyfrom"},
 +	{Opt_wsync, "wsync"},
 +	{Opt_nowsync, "nowsync"},
 +	{-1, NULL}
  };
  
++<<<<<<< HEAD
 +static int parse_fsopt_token(char *c, void *private)
++=======
+ static const struct constant_table ceph_param_recover[] = {
+ 	{ "no",		ceph_recover_session_no },
+ 	{ "clean",	ceph_recover_session_clean },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec ceph_mount_param_specs[] = {
+ 	fsparam_flag_no ("acl",				Opt_acl),
+ 	fsparam_flag_no ("asyncreaddir",		Opt_asyncreaddir),
+ 	fsparam_s32	("caps_max",			Opt_caps_max),
+ 	fsparam_u32	("caps_wanted_delay_max",	Opt_caps_wanted_delay_max),
+ 	fsparam_u32	("caps_wanted_delay_min",	Opt_caps_wanted_delay_min),
+ 	fsparam_u32	("write_congestion_kb",		Opt_congestion_kb),
+ 	fsparam_flag_no ("copyfrom",			Opt_copyfrom),
+ 	fsparam_flag_no ("dcache",			Opt_dcache),
+ 	fsparam_flag_no ("dirstat",			Opt_dirstat),
+ 	__fsparam	(fs_param_is_string, "fsc",	Opt_fscache,
+ 			 fs_param_neg_with_no | fs_param_v_optional, NULL),
+ 	fsparam_flag_no ("ino32",			Opt_ino32),
+ 	fsparam_string	("mds_namespace",		Opt_mds_namespace),
+ 	fsparam_flag_no ("poolperm",			Opt_poolperm),
+ 	fsparam_flag_no ("quotadf",			Opt_quotadf),
+ 	fsparam_u32	("rasize",			Opt_rasize),
+ 	fsparam_flag_no ("rbytes",			Opt_rbytes),
+ 	fsparam_u32	("readdir_max_bytes",		Opt_readdir_max_bytes),
+ 	fsparam_u32	("readdir_max_entries",		Opt_readdir_max_entries),
+ 	fsparam_enum	("recover_session",		Opt_recover_session, ceph_param_recover),
+ 	fsparam_flag_no ("require_active_mds",		Opt_require_active_mds),
+ 	fsparam_u32	("rsize",			Opt_rsize),
+ 	fsparam_string	("snapdirname",			Opt_snapdirname),
+ 	fsparam_string	("source",			Opt_source),
+ 	fsparam_u32	("wsize",			Opt_wsize),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description ceph_mount_parameters = {
+ 	.specs          = ceph_mount_param_specs,
+ };
+ 
+ struct ceph_parse_opts_ctx {
+ 	struct ceph_options		*copts;
+ 	struct ceph_mount_options	*opts;
+ };
+ 
+ /*
+  * Parse the source parameter.  Distinguish the server list from the path.
+  * Internally we do not include the leading '/' in the path.
+  *
+  * The source will look like:
+  *     <server_spec>[,<server_spec>...]:[<path>]
+  * where
+  *     <server_spec> is <ip>[:<port>]
+  *     <path> is optional, but if present must begin with '/'
+  */
+ static int ceph_parse_source(struct fs_parameter *param, struct fs_context *fc)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
 -	struct ceph_mount_options *fsopt = pctx->opts;
 -	char *dev_name = param->string, *dev_name_end;
 -	int ret;
 +	struct ceph_mount_options *fsopt = private;
 +	substring_t argstr[MAX_OPT_ARGS];
 +	int token, intval, ret;
  
 -	dout("%s '%s'\n", __func__, dev_name);
 -	if (!dev_name || !*dev_name)
 -		return invalf(fc, "ceph: Empty source");
 +	token = match_token((char *)c, fsopt_tokens, argstr);
 +	if (token < 0)
 +		return -EINVAL;
  
 -	dev_name_end = strchr(dev_name, '/');
 -	if (dev_name_end) {
 -		if (strlen(dev_name_end) > 1) {
 -			kfree(fsopt->server_path);
 -			fsopt->server_path = kstrdup(dev_name_end, GFP_KERNEL);
 -			if (!fsopt->server_path)
 -				return -ENOMEM;
 +	if (token < Opt_last_int) {
 +		ret = match_int(&argstr[0], &intval);
 +		if (ret < 0) {
 +			pr_err("bad option arg (not int) at '%s'\n", c);
 +			return ret;
  		}
 +		dout("got int token %d val %d\n", token, intval);
 +	} else if (token > Opt_last_int && token < Opt_last_string) {
 +		dout("got string token %d val %s\n", token,
 +		     argstr[0].from);
  	} else {
 -		dev_name_end = dev_name + strlen(dev_name);
 +		dout("got token %d\n", token);
  	}
  
 -	dev_name_end--;		/* back up to ':' separator */
 -	if (dev_name_end < dev_name || *dev_name_end != ':')
 -		return invalf(fc, "ceph: No path or : separator in source");
 -
 -	dout("device name '%.*s'\n", (int)(dev_name_end - dev_name), dev_name);
 -	if (fsopt->server_path)
 -		dout("server path '%s'\n", fsopt->server_path);
 -
 -	ret = ceph_parse_mon_ips(param->string, dev_name_end - dev_name,
 -				 pctx->copts, fc->log.log);
 -	if (ret)
 -		return ret;
 -
 -	fc->source = param->string;
 -	param->string = NULL;
 -	return 0;
 -}
 -
 -static int ceph_parse_mount_param(struct fs_context *fc,
 -				  struct fs_parameter *param)
 -{
 -	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
 -	struct ceph_mount_options *fsopt = pctx->opts;
 -	struct fs_parse_result result;
 -	unsigned int mode;
 -	int token, ret;
 -
 -	ret = ceph_parse_param(param, pctx->copts, fc->log.log);
 -	if (ret != -ENOPARAM)
 -		return ret;
 -
 -	token = fs_parse(fc, &ceph_mount_parameters, param, &result);
 -	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
 -	if (token < 0)
 -		return token;
 -
  	switch (token) {
  	case Opt_snapdirname:
  		kfree(fsopt->snapdir_name);
diff --cc fs/filesystems.c
index b03f57b1105b,77bf5f95362d..000000000000
--- a/fs/filesystems.c
+++ b/fs/filesystems.c
@@@ -73,6 -74,10 +73,13 @@@ int register_filesystem(struct file_sys
  	int res = 0;
  	struct file_system_type ** p;
  
++<<<<<<< HEAD
++=======
+ 	if (fs->parameters &&
+ 	    !fs_validate_description(fs->name, fs->parameters))
+ 		return -EINVAL;
+ 
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  	BUG_ON(strchr(fs->name, '.'));
  	if (fs->next)
  		return -EBUSY;
diff --cc fs/fuse/inode.c
index 10b75246113a,5a01daadee7e..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -452,111 -448,108 +452,119 @@@ enum 
  	OPT_ERR
  };
  
 -static const struct fs_parameter_spec fuse_param_specs[] = {
 -	fsparam_string	("source",		OPT_SOURCE),
 -	fsparam_u32	("fd",			OPT_FD),
 -	fsparam_u32oct	("rootmode",		OPT_ROOTMODE),
 -	fsparam_u32	("user_id",		OPT_USER_ID),
 -	fsparam_u32	("group_id",		OPT_GROUP_ID),
 -	fsparam_flag	("default_permissions",	OPT_DEFAULT_PERMISSIONS),
 -	fsparam_flag	("allow_other",		OPT_ALLOW_OTHER),
 -	fsparam_u32	("max_read",		OPT_MAX_READ),
 -	fsparam_u32	("blksize",		OPT_BLKSIZE),
 -	fsparam_string	("subtype",		OPT_SUBTYPE),
 -	{}
 +static const match_table_t tokens = {
 +	{OPT_FD,			"fd=%u"},
 +	{OPT_ROOTMODE,			"rootmode=%o"},
 +	{OPT_USER_ID,			"user_id=%u"},
 +	{OPT_GROUP_ID,			"group_id=%u"},
 +	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
 +	{OPT_ALLOW_OTHER,		"allow_other"},
 +	{OPT_MAX_READ,			"max_read=%u"},
 +	{OPT_BLKSIZE,			"blksize=%u"},
 +	{OPT_ERR,			NULL}
  };
  
++<<<<<<< HEAD
 +static int fuse_match_uint(substring_t *s, unsigned int *res)
++=======
+ static const struct fs_parameter_description fuse_fs_parameters = {
+ 	.specs		= fuse_param_specs,
+ };
+ 
+ static int fuse_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct fs_parse_result result;
 -	struct fuse_fs_context *ctx = fc->fs_private;
 -	int opt;
 -
 -	opt = fs_parse(fc, &fuse_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case OPT_SOURCE:
 -		if (fc->source)
 -			return invalf(fc, "fuse: Multiple sources specified");
 -		fc->source = param->string;
 -		param->string = NULL;
 -		break;
 -
 -	case OPT_SUBTYPE:
 -		if (ctx->subtype)
 -			return invalf(fc, "fuse: Multiple subtypes specified");
 -		ctx->subtype = param->string;
 -		param->string = NULL;
 -		return 0;
 -
 -	case OPT_FD:
 -		ctx->fd = result.uint_32;
 -		ctx->fd_present = 1;
 -		break;
 -
 -	case OPT_ROOTMODE:
 -		if (!fuse_valid_type(result.uint_32))
 -			return invalf(fc, "fuse: Invalid rootmode");
 -		ctx->rootmode = result.uint_32;
 -		ctx->rootmode_present = 1;
 -		break;
 -
 -	case OPT_USER_ID:
 -		ctx->user_id = make_kuid(fc->user_ns, result.uint_32);
 -		if (!uid_valid(ctx->user_id))
 -			return invalf(fc, "fuse: Invalid user_id");
 -		ctx->user_id_present = 1;
 -		break;
 -
 -	case OPT_GROUP_ID:
 -		ctx->group_id = make_kgid(fc->user_ns, result.uint_32);
 -		if (!gid_valid(ctx->group_id))
 -			return invalf(fc, "fuse: Invalid group_id");
 -		ctx->group_id_present = 1;
 -		break;
 -
 -	case OPT_DEFAULT_PERMISSIONS:
 -		ctx->default_permissions = 1;
 -		break;
 -
 -	case OPT_ALLOW_OTHER:
 -		ctx->allow_other = 1;
 -		break;
 -
 -	case OPT_MAX_READ:
 -		ctx->max_read = result.uint_32;
 -		break;
 -
 -	case OPT_BLKSIZE:
 -		if (!ctx->is_bdev)
 -			return invalf(fc, "fuse: blksize only supported for fuseblk");
 -		ctx->blksize = result.uint_32;
 -		break;
 -
 -	default:
 -		return -EINVAL;
 +	int err = -ENOMEM;
 +	char *buf = match_strdup(s);
 +	if (buf) {
 +		err = kstrtouint(buf, 10, res);
 +		kfree(buf);
  	}
 -
 -	return 0;
 +	return err;
  }
  
 -static void fuse_free_fc(struct fs_context *fc)
 +static int parse_fuse_opt(char *opt, struct fuse_fs_context *d, int is_bdev,
 +			  struct user_namespace *user_ns)
  {
 -	struct fuse_fs_context *ctx = fc->fs_private;
 -
 -	if (ctx) {
 -		kfree(ctx->subtype);
 -		kfree(ctx);
 +	char *p;
 +	memset(d, 0, sizeof(struct fuse_fs_context));
 +	d->max_read = ~0;
 +	d->blksize = FUSE_DEFAULT_BLKSIZE;
 +
 +	while ((p = strsep(&opt, ",")) != NULL) {
 +		int token;
 +		int value;
 +		unsigned uv;
 +		substring_t args[MAX_OPT_ARGS];
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case OPT_FD:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->fd = value;
 +			d->fd_present = 1;
 +			break;
 +
 +		case OPT_ROOTMODE:
 +			if (match_octal(&args[0], &value))
 +				return 0;
 +			if (!fuse_valid_type(value))
 +				return 0;
 +			d->rootmode = value;
 +			d->rootmode_present = 1;
 +			break;
 +
 +		case OPT_USER_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->user_id = make_kuid(user_ns, uv);
 +			if (!uid_valid(d->user_id))
 +				return 0;
 +			d->user_id_present = 1;
 +			break;
 +
 +		case OPT_GROUP_ID:
 +			if (fuse_match_uint(&args[0], &uv))
 +				return 0;
 +			d->group_id = make_kgid(user_ns, uv);
 +			if (!gid_valid(d->group_id))
 +				return 0;
 +			d->group_id_present = 1;
 +			break;
 +
 +		case OPT_DEFAULT_PERMISSIONS:
 +			d->default_permissions = 1;
 +			break;
 +
 +		case OPT_ALLOW_OTHER:
 +			d->allow_other = 1;
 +			break;
 +
 +		case OPT_MAX_READ:
 +			if (match_int(&args[0], &value))
 +				return 0;
 +			d->max_read = value;
 +			break;
 +
 +		case OPT_BLKSIZE:
 +			if (!is_bdev || match_int(&args[0], &value))
 +				return 0;
 +			d->blksize = value;
 +			break;
 +
 +		default:
 +			return 0;
 +		}
  	}
 +
 +	if (!d->fd_present || !d->rootmode_present ||
 +	    !d->user_id_present || !d->group_id_present)
 +		return 0;
 +
 +	return 1;
  }
  
  static int fuse_show_options(struct seq_file *m, struct dentry *root)
diff --cc fs/jffs2/super.c
index 87bdf0f4cba1,f6fda79e98cf..000000000000
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@@ -166,73 -165,55 +166,115 @@@ static const struct export_operations j
  enum {
  	Opt_override_compr,
  	Opt_rp_size,
 +	Opt_err,
 +};
 +
 +static const match_table_t tokens = {
 +	{Opt_override_compr, "compr=%s"},
 +	{Opt_rp_size, "rp_size=%u"},
 +	{Opt_err, NULL},
  };
  
 -static const struct constant_table jffs2_param_compr[] = {
 -	{"none",	JFFS2_COMPR_MODE_NONE },
 +static int jffs2_parse_options(struct jffs2_sb_info *c, char *data)
 +{
 +	substring_t args[MAX_OPT_ARGS];
 +	char *p, *name;
 +	unsigned int opt;
 +
 +	if (!data)
 +		return 0;
 +
 +	while ((p = strsep(&data, ","))) {
 +		int token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_override_compr:
 +			name = match_strdup(&args[0]);
 +
 +			if (!name)
 +				return -ENOMEM;
 +			if (!strcmp(name, "none"))
 +				c->mount_opts.compr = JFFS2_COMPR_MODE_NONE;
  #ifdef CONFIG_JFFS2_LZO
 -	{"lzo",		JFFS2_COMPR_MODE_FORCELZO },
 +			else if (!strcmp(name, "lzo"))
 +				c->mount_opts.compr = JFFS2_COMPR_MODE_FORCELZO;
  #endif
  #ifdef CONFIG_JFFS2_ZLIB
 -	{"zlib",	JFFS2_COMPR_MODE_FORCEZLIB },
 +			else if (!strcmp(name, "zlib"))
 +				c->mount_opts.compr =
 +						JFFS2_COMPR_MODE_FORCEZLIB;
  #endif
++<<<<<<< HEAD
 +			else {
 +				pr_err("Error: unknown compressor \"%s\"\n",
 +				       name);
 +				kfree(name);
 +				return -EINVAL;
 +			}
 +			kfree(name);
 +			c->mount_opts.override_compr = true;
 +			break;
 +		case Opt_rp_size:
 +			if (match_int(&args[0], &opt))
 +				return -EINVAL;
 +			opt *= 1024;
 +			if (opt > c->mtd->size) {
 +				pr_warn("Too large reserve pool specified, max "
 +					"is %llu KB\n", c->mtd->size / 1024);
 +				return -EINVAL;
 +			}
 +			c->mount_opts.rp_size = opt;
 +			break;
 +		default:
 +			pr_err("Error: unrecognized mount option '%s' or missing value\n",
 +			       p);
 +			return -EINVAL;
 +		}
++=======
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec jffs2_param_specs[] = {
+ 	fsparam_enum	("compr",	Opt_override_compr, jffs2_param_compr),
+ 	fsparam_u32	("rp_size",	Opt_rp_size),
+ 	{}
+ };
+ 
+ const struct fs_parameter_description jffs2_fs_parameters = {
+ 	.specs		= jffs2_param_specs,
+ };
+ 
+ static int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	struct jffs2_sb_info *c = fc->s_fs_info;
+ 	int opt;
+ 
+ 	opt = fs_parse(fc, &jffs2_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	switch (opt) {
+ 	case Opt_override_compr:
+ 		c->mount_opts.compr = result.uint_32;
+ 		c->mount_opts.override_compr = true;
+ 		break;
+ 	case Opt_rp_size:
+ 		if (result.uint_32 > UINT_MAX / 1024)
+ 			return invalf(fc, "jffs2: rp_size unrepresentable");
+ 		opt = result.uint_32 * 1024;
+ 		if (opt > c->mtd->size)
+ 			return invalf(fc, "jffs2: Too large reserve pool specified, max is %llu KB",
+ 				      c->mtd->size / 1024);
+ 		c->mount_opts.rp_size = opt;
+ 		break;
+ 	default:
+ 		return -EINVAL;
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  	}
  
  	return 0;
diff --cc fs/proc/root.c
index f4b1a9d2eca6,c44765447d05..000000000000
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@@ -26,60 -27,123 +26,74 @@@
  
  #include "internal.h"
  
 -struct proc_fs_context {
 -	struct pid_namespace	*pid_ns;
 -	unsigned int		mask;
 -	int			hidepid;
 -	int			gid;
 +enum {
 +	Opt_gid, Opt_hidepid, Opt_err,
  };
  
 -enum proc_param {
 -	Opt_gid,
 -	Opt_hidepid,
 +static const match_table_t tokens = {
 +	{Opt_hidepid, "hidepid=%u"},
 +	{Opt_gid, "gid=%u"},
 +	{Opt_err, NULL},
  };
  
++<<<<<<< HEAD
 +int proc_parse_options(char *options, struct pid_namespace *pid)
++=======
+ static const struct fs_parameter_spec proc_param_specs[] = {
+ 	fsparam_u32("gid",	Opt_gid),
+ 	fsparam_u32("hidepid",	Opt_hidepid),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description proc_fs_parameters = {
+ 	.specs		= proc_param_specs,
+ };
+ 
+ static int proc_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct proc_fs_context *ctx = fc->fs_private;
 -	struct fs_parse_result result;
 -	int opt;
 -
 -	opt = fs_parse(fc, &proc_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case Opt_gid:
 -		ctx->gid = result.uint_32;
 -		break;
 -
 -	case Opt_hidepid:
 -		ctx->hidepid = result.uint_32;
 -		if (ctx->hidepid < HIDEPID_OFF ||
 -		    ctx->hidepid > HIDEPID_INVISIBLE)
 -			return invalf(fc, "proc: hidepid value must be between 0 and 2.\n");
 -		break;
 -
 -	default:
 -		return -EINVAL;
 +	char *p;
 +	substring_t args[MAX_OPT_ARGS];
 +	int option;
 +
 +	if (!options)
 +		return 1;
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int token;
 +		if (!*p)
 +			continue;
 +
 +		args[0].to = args[0].from = NULL;
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_gid:
 +			if (match_int(&args[0], &option))
 +				return 0;
 +			pid->pid_gid = make_kgid(current_user_ns(), option);
 +			break;
 +		case Opt_hidepid:
 +			if (match_int(&args[0], &option))
 +				return 0;
 +			if (option < HIDEPID_OFF ||
 +			    option > HIDEPID_INVISIBLE) {
 +				pr_err("proc: hidepid value must be between 0 and 2.\n");
 +				return 0;
 +			}
 +			pid->hide_pid = option;
 +			break;
 +		default:
 +			pr_err("proc: unrecognized mount option \"%s\" "
 +			       "or missing value\n", p);
 +			return 0;
 +		}
  	}
  
 -	ctx->mask |= 1 << opt;
 -	return 0;
 -}
 -
 -static void proc_apply_options(struct super_block *s,
 -			       struct fs_context *fc,
 -			       struct pid_namespace *pid_ns,
 -			       struct user_namespace *user_ns)
 -{
 -	struct proc_fs_context *ctx = fc->fs_private;
 -
 -	if (ctx->mask & (1 << Opt_gid))
 -		pid_ns->pid_gid = make_kgid(user_ns, ctx->gid);
 -	if (ctx->mask & (1 << Opt_hidepid))
 -		pid_ns->hide_pid = ctx->hidepid;
 -}
 -
 -static int proc_fill_super(struct super_block *s, struct fs_context *fc)
 -{
 -	struct pid_namespace *pid_ns = get_pid_ns(s->s_fs_info);
 -	struct inode *root_inode;
 -	int ret;
 -
 -	proc_apply_options(s, fc, pid_ns, current_user_ns());
 -
 -	/* User space would break if executables or devices appear on proc */
 -	s->s_iflags |= SB_I_USERNS_VISIBLE | SB_I_NOEXEC | SB_I_NODEV;
 -	s->s_flags |= SB_NODIRATIME | SB_NOSUID | SB_NOEXEC;
 -	s->s_blocksize = 1024;
 -	s->s_blocksize_bits = 10;
 -	s->s_magic = PROC_SUPER_MAGIC;
 -	s->s_op = &proc_sops;
 -	s->s_time_gran = 1;
 -
 -	/*
 -	 * procfs isn't actually a stacking filesystem; however, there is
 -	 * too much magic going on inside it to permit stacking things on
 -	 * top of it
 -	 */
 -	s->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;
 -	
 -	/* procfs dentries and inodes don't require IO to create */
 -	s->s_shrink.seeks = 0;
 -
 -	pde_get(&proc_root);
 -	root_inode = proc_get_inode(s, &proc_root);
 -	if (!root_inode) {
 -		pr_err("proc_fill_super: get root inode failed\n");
 -		return -ENOMEM;
 -	}
 -
 -	s->s_root = d_make_root(root_inode);
 -	if (!s->s_root) {
 -		pr_err("proc_fill_super: allocate dentry failed\n");
 -		return -ENOMEM;
 -	}
 -
 -	ret = proc_setup_self(s);
 -	if (ret) {
 -		return ret;
 -	}
 -	return proc_setup_thread_self(s);
 +	return 1;
  }
  
 -static int proc_reconfigure(struct fs_context *fc)
 +int proc_remount(struct super_block *sb, int *flags, char *data)
  {
 -	struct super_block *sb = fc->root->d_sb;
  	struct pid_namespace *pid = sb->s_fs_info;
  
  	sync_filesystem(sb);
diff --cc fs/ramfs/inode.c
index b85d1e77e934,bb7ab562ff4d..000000000000
--- a/fs/ramfs/inode.c
+++ b/fs/ramfs/inode.c
@@@ -175,36 -177,27 +175,44 @@@ static const struct super_operations ra
  	.show_options	= ramfs_show_options,
  };
  
 -enum ramfs_param {
 +enum {
  	Opt_mode,
 +	Opt_err
  };
  
 -static const struct fs_parameter_spec ramfs_param_specs[] = {
 -	fsparam_u32oct("mode",	Opt_mode),
 -	{}
 +static const match_table_t tokens = {
 +	{Opt_mode, "mode=%o"},
 +	{Opt_err, NULL}
  };
  
++<<<<<<< HEAD
 +static int ramfs_parse_options(char *data, struct ramfs_mount_opts *opts)
++=======
+ const struct fs_parameter_description ramfs_fs_parameters = {
+ 	.specs		= ramfs_param_specs,
+ };
+ 
+ static int ramfs_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct fs_parse_result result;
 -	struct ramfs_fs_info *fsi = fc->s_fs_info;
 -	int opt;
 -
 -	opt = fs_parse(fc, &ramfs_fs_parameters, param, &result);
 -	if (opt < 0) {
 +	substring_t args[MAX_OPT_ARGS];
 +	int option;
 +	int token;
 +	char *p;
 +
 +	opts->mode = RAMFS_DEFAULT_MODE;
 +
 +	while ((p = strsep(&data, ",")) != NULL) {
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_mode:
 +			if (match_octal(&args[0], &option))
 +				return -EINVAL;
 +			opts->mode = option & S_IALLUGO;
 +			break;
  		/*
  		 * We might like to report bad mount options here;
  		 * but traditionally ramfs has ignored all mount options,
diff --cc fs/xfs/xfs_super.c
index e6df26a81bbf,ee23a2bf1a81..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -58,342 -59,56 +58,348 @@@ enum 
  	Opt_filestreams, Opt_quota, Opt_noquota, Opt_usrquota, Opt_grpquota,
  	Opt_prjquota, Opt_uquota, Opt_gquota, Opt_pquota,
  	Opt_uqnoenforce, Opt_gqnoenforce, Opt_pqnoenforce, Opt_qnoenforce,
 -	Opt_discard, Opt_nodiscard, Opt_dax,
 +	Opt_discard, Opt_nodiscard, Opt_dax, Opt_err,
  };
  
 -static const struct fs_parameter_spec xfs_param_specs[] = {
 -	fsparam_u32("logbufs",		Opt_logbufs),
 -	fsparam_string("logbsize",	Opt_logbsize),
 -	fsparam_string("logdev",	Opt_logdev),
 -	fsparam_string("rtdev",		Opt_rtdev),
 -	fsparam_flag("wsync",		Opt_wsync),
 -	fsparam_flag("noalign",		Opt_noalign),
 -	fsparam_flag("swalloc",		Opt_swalloc),
 -	fsparam_u32("sunit",		Opt_sunit),
 -	fsparam_u32("swidth",		Opt_swidth),
 -	fsparam_flag("nouuid",		Opt_nouuid),
 -	fsparam_flag("grpid",		Opt_grpid),
 -	fsparam_flag("nogrpid",		Opt_nogrpid),
 -	fsparam_flag("bsdgroups",	Opt_bsdgroups),
 -	fsparam_flag("sysvgroups",	Opt_sysvgroups),
 -	fsparam_string("allocsize",	Opt_allocsize),
 -	fsparam_flag("norecovery",	Opt_norecovery),
 -	fsparam_flag("inode64",		Opt_inode64),
 -	fsparam_flag("inode32",		Opt_inode32),
 -	fsparam_flag("ikeep",		Opt_ikeep),
 -	fsparam_flag("noikeep",		Opt_noikeep),
 -	fsparam_flag("largeio",		Opt_largeio),
 -	fsparam_flag("nolargeio",	Opt_nolargeio),
 -	fsparam_flag("attr2",		Opt_attr2),
 -	fsparam_flag("noattr2",		Opt_noattr2),
 -	fsparam_flag("filestreams",	Opt_filestreams),
 -	fsparam_flag("quota",		Opt_quota),
 -	fsparam_flag("noquota",		Opt_noquota),
 -	fsparam_flag("usrquota",	Opt_usrquota),
 -	fsparam_flag("grpquota",	Opt_grpquota),
 -	fsparam_flag("prjquota",	Opt_prjquota),
 -	fsparam_flag("uquota",		Opt_uquota),
 -	fsparam_flag("gquota",		Opt_gquota),
 -	fsparam_flag("pquota",		Opt_pquota),
 -	fsparam_flag("uqnoenforce",	Opt_uqnoenforce),
 -	fsparam_flag("gqnoenforce",	Opt_gqnoenforce),
 -	fsparam_flag("pqnoenforce",	Opt_pqnoenforce),
 -	fsparam_flag("qnoenforce",	Opt_qnoenforce),
 -	fsparam_flag("discard",		Opt_discard),
 -	fsparam_flag("nodiscard",	Opt_nodiscard),
 -	fsparam_flag("dax",		Opt_dax),
 -	{}
 +static const match_table_t tokens = {
 +	{Opt_logbufs,	"logbufs=%u"},	/* number of XFS log buffers */
 +	{Opt_logbsize,	"logbsize=%s"},	/* size of XFS log buffers */
 +	{Opt_logdev,	"logdev=%s"},	/* log device */
 +	{Opt_rtdev,	"rtdev=%s"},	/* realtime I/O device */
 +	{Opt_biosize,	"biosize=%u"},	/* log2 of preferred buffered io size */
 +	{Opt_wsync,	"wsync"},	/* safe-mode nfs compatible mount */
 +	{Opt_noalign,	"noalign"},	/* turn off stripe alignment */
 +	{Opt_swalloc,	"swalloc"},	/* turn on stripe width allocation */
 +	{Opt_sunit,	"sunit=%u"},	/* data volume stripe unit */
 +	{Opt_swidth,	"swidth=%u"},	/* data volume stripe width */
 +	{Opt_nouuid,	"nouuid"},	/* ignore filesystem UUID */
 +	{Opt_grpid,	"grpid"},	/* group-ID from parent directory */
 +	{Opt_nogrpid,	"nogrpid"},	/* group-ID from current process */
 +	{Opt_bsdgroups,	"bsdgroups"},	/* group-ID from parent directory */
 +	{Opt_sysvgroups,"sysvgroups"},	/* group-ID from current process */
 +	{Opt_allocsize,	"allocsize=%s"},/* preferred allocation size */
 +	{Opt_norecovery,"norecovery"},	/* don't run XFS recovery */
 +	{Opt_inode64,	"inode64"},	/* inodes can be allocated anywhere */
 +	{Opt_inode32,   "inode32"},	/* inode allocation limited to
 +					 * XFS_MAXINUMBER_32 */
 +	{Opt_ikeep,	"ikeep"},	/* do not free empty inode clusters */
 +	{Opt_noikeep,	"noikeep"},	/* free empty inode clusters */
 +	{Opt_largeio,	"largeio"},	/* report large I/O sizes in stat() */
 +	{Opt_nolargeio,	"nolargeio"},	/* do not report large I/O sizes
 +					 * in stat(). */
 +	{Opt_attr2,	"attr2"},	/* do use attr2 attribute format */
 +	{Opt_noattr2,	"noattr2"},	/* do not use attr2 attribute format */
 +	{Opt_filestreams,"filestreams"},/* use filestreams allocator */
 +	{Opt_quota,	"quota"},	/* disk quotas (user) */
 +	{Opt_noquota,	"noquota"},	/* no quotas */
 +	{Opt_usrquota,	"usrquota"},	/* user quota enabled */
 +	{Opt_grpquota,	"grpquota"},	/* group quota enabled */
 +	{Opt_prjquota,	"prjquota"},	/* project quota enabled */
 +	{Opt_uquota,	"uquota"},	/* user quota (IRIX variant) */
 +	{Opt_gquota,	"gquota"},	/* group quota (IRIX variant) */
 +	{Opt_pquota,	"pquota"},	/* project quota (IRIX variant) */
 +	{Opt_uqnoenforce,"uqnoenforce"},/* user quota limit enforcement */
 +	{Opt_gqnoenforce,"gqnoenforce"},/* group quota limit enforcement */
 +	{Opt_pqnoenforce,"pqnoenforce"},/* project quota limit enforcement */
 +	{Opt_qnoenforce, "qnoenforce"},	/* same as uqnoenforce */
 +	{Opt_discard,	"discard"},	/* Discard unused blocks */
 +	{Opt_nodiscard,	"nodiscard"},	/* Do not discard unused blocks */
 +	{Opt_dax,	"dax"},		/* Enable direct access to bdev pages */
 +	{Opt_err,	NULL},
  };
  
++<<<<<<< HEAD
 +
 +STATIC int
 +suffix_kstrtoint(const substring_t *s, unsigned int base, int *res)
 +{
 +	int	last, shift_left_factor = 0, _res;
 +	char	*value;
 +	int	ret = 0;
 +
 +	value = match_strdup(s);
 +	if (!value)
 +		return -ENOMEM;
 +
 +	last = strlen(value) - 1;
 +	if (value[last] == 'K' || value[last] == 'k') {
 +		shift_left_factor = 10;
 +		value[last] = '\0';
 +	}
 +	if (value[last] == 'M' || value[last] == 'm') {
 +		shift_left_factor = 20;
 +		value[last] = '\0';
 +	}
 +	if (value[last] == 'G' || value[last] == 'g') {
 +		shift_left_factor = 30;
 +		value[last] = '\0';
 +	}
 +
 +	if (kstrtoint(value, base, &_res))
 +		ret = -EINVAL;
 +	kfree(value);
 +	*res = _res << shift_left_factor;
 +	return ret;
 +}
 +
 +/*
 + * This function fills in xfs_mount_t fields based on mount args.
 + * Note: the superblock has _not_ yet been read in.
 + *
 + * Note that this function leaks the various device name allocations on
 + * failure.  The caller takes care of them.
 + *
 + * *sb is const because this is also used to test options on the remount
 + * path, and we don't want this to have any side effects at remount time.
 + * Today this function does not change *sb, but just to future-proof...
 + */
 +STATIC int
 +xfs_parseargs(
 +	struct xfs_mount	*mp,
 +	char			*options)
 +{
 +	const struct super_block *sb = mp->m_super;
 +	char			*p;
 +	substring_t		args[MAX_OPT_ARGS];
 +	int			iosize = 0;
 +	uint8_t			iosizelog = 0;
 +
 +	/*
 +	 * Copy binary VFS mount flags we are interested in.
 +	 */
 +	if (sb_rdonly(sb))
 +		mp->m_flags |= XFS_MOUNT_RDONLY;
 +	if (sb->s_flags & SB_DIRSYNC)
 +		mp->m_flags |= XFS_MOUNT_DIRSYNC;
 +	if (sb->s_flags & SB_SYNCHRONOUS)
 +		mp->m_flags |= XFS_MOUNT_WSYNC;
 +
 +	/*
 +	 * These can be overridden by the mount option parsing.
 +	 */
 +	mp->m_logbufs = -1;
 +	mp->m_logbsize = -1;
 +
 +	if (!options)
 +		return 0;
 +
 +	while ((p = strsep(&options, ",")) != NULL) {
 +		int		token;
 +
 +		if (!*p)
 +			continue;
 +
 +		token = match_token(p, tokens, args);
 +		switch (token) {
 +		case Opt_logbufs:
 +			if (match_int(args, &mp->m_logbufs))
 +				return -EINVAL;
 +			break;
 +		case Opt_logbsize:
 +			if (suffix_kstrtoint(args, 10, &mp->m_logbsize))
 +				return -EINVAL;
 +			break;
 +		case Opt_logdev:
 +			kfree(mp->m_logname);
 +			mp->m_logname = match_strdup(args);
 +			if (!mp->m_logname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_rtdev:
 +			kfree(mp->m_rtname);
 +			mp->m_rtname = match_strdup(args);
 +			if (!mp->m_rtname)
 +				return -ENOMEM;
 +			break;
 +		case Opt_allocsize:
 +		case Opt_biosize:
 +			if (suffix_kstrtoint(args, 10, &iosize))
 +				return -EINVAL;
 +			iosizelog = ffs(iosize) - 1;
 +			break;
 +		case Opt_grpid:
 +		case Opt_bsdgroups:
 +			mp->m_flags |= XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_nogrpid:
 +		case Opt_sysvgroups:
 +			mp->m_flags &= ~XFS_MOUNT_GRPID;
 +			break;
 +		case Opt_wsync:
 +			mp->m_flags |= XFS_MOUNT_WSYNC;
 +			break;
 +		case Opt_norecovery:
 +			mp->m_flags |= XFS_MOUNT_NORECOVERY;
 +			break;
 +		case Opt_noalign:
 +			mp->m_flags |= XFS_MOUNT_NOALIGN;
 +			break;
 +		case Opt_swalloc:
 +			mp->m_flags |= XFS_MOUNT_SWALLOC;
 +			break;
 +		case Opt_sunit:
 +			if (match_int(args, &mp->m_dalign))
 +				return -EINVAL;
 +			break;
 +		case Opt_swidth:
 +			if (match_int(args, &mp->m_swidth))
 +				return -EINVAL;
 +			break;
 +		case Opt_inode32:
 +			mp->m_flags |= XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_inode64:
 +			mp->m_flags &= ~XFS_MOUNT_SMALL_INUMS;
 +			break;
 +		case Opt_nouuid:
 +			mp->m_flags |= XFS_MOUNT_NOUUID;
 +			break;
 +		case Opt_ikeep:
 +			mp->m_flags |= XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_noikeep:
 +			mp->m_flags &= ~XFS_MOUNT_IKEEP;
 +			break;
 +		case Opt_largeio:
 +			mp->m_flags |= XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_nolargeio:
 +			mp->m_flags &= ~XFS_MOUNT_LARGEIO;
 +			break;
 +		case Opt_attr2:
 +			mp->m_flags |= XFS_MOUNT_ATTR2;
 +			break;
 +		case Opt_noattr2:
 +			mp->m_flags &= ~XFS_MOUNT_ATTR2;
 +			mp->m_flags |= XFS_MOUNT_NOATTR2;
 +			break;
 +		case Opt_filestreams:
 +			mp->m_flags |= XFS_MOUNT_FILESTREAMS;
 +			break;
 +		case Opt_noquota:
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
 +			mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
 +			break;
 +		case Opt_quota:
 +		case Opt_uquota:
 +		case Opt_usrquota:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
 +					 XFS_UQUOTA_ENFD);
 +			break;
 +		case Opt_qnoenforce:
 +		case Opt_uqnoenforce:
 +			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_UQUOTA_ENFD;
 +			break;
 +		case Opt_pquota:
 +		case Opt_prjquota:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
 +					 XFS_PQUOTA_ENFD);
 +			break;
 +		case Opt_pqnoenforce:
 +			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_PQUOTA_ENFD;
 +			break;
 +		case Opt_gquota:
 +		case Opt_grpquota:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
 +					 XFS_GQUOTA_ENFD);
 +			break;
 +		case Opt_gqnoenforce:
 +			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
 +			mp->m_qflags &= ~XFS_GQUOTA_ENFD;
 +			break;
 +		case Opt_discard:
 +			mp->m_flags |= XFS_MOUNT_DISCARD;
 +			break;
 +		case Opt_nodiscard:
 +			mp->m_flags &= ~XFS_MOUNT_DISCARD;
 +			break;
 +#ifdef CONFIG_FS_DAX
 +		case Opt_dax:
 +			mp->m_flags |= XFS_MOUNT_DAX;
 +			break;
 +#endif
 +		default:
 +			xfs_warn(mp, "unknown mount option [%s].", p);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	/*
 +	 * no recovery flag requires a read-only mount
 +	 */
 +	if ((mp->m_flags & XFS_MOUNT_NORECOVERY) &&
 +	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
 +		xfs_warn(mp, "no-recovery mounts must be read-only.");
 +		return -EINVAL;
 +	}
 +
 +	if ((mp->m_flags & XFS_MOUNT_NOALIGN) &&
 +	    (mp->m_dalign || mp->m_swidth)) {
 +		xfs_warn(mp,
 +	"sunit and swidth options incompatible with the noalign option");
 +		return -EINVAL;
 +	}
 +
 +	if (!IS_ENABLED(CONFIG_XFS_QUOTA) && mp->m_qflags != 0) {
 +		xfs_warn(mp, "quota support not available in this kernel.");
 +		return -EINVAL;
 +	}
 +
 +	if ((mp->m_dalign && !mp->m_swidth) ||
 +	    (!mp->m_dalign && mp->m_swidth)) {
 +		xfs_warn(mp, "sunit and swidth must be specified together");
 +		return -EINVAL;
 +	}
 +
 +	if (mp->m_dalign && (mp->m_swidth % mp->m_dalign != 0)) {
 +		xfs_warn(mp,
 +	"stripe width (%d) must be a multiple of the stripe unit (%d)",
 +			mp->m_swidth, mp->m_dalign);
 +		return -EINVAL;
 +	}
 +
 +	if (mp->m_logbufs != -1 &&
 +	    mp->m_logbufs != 0 &&
 +	    (mp->m_logbufs < XLOG_MIN_ICLOGS ||
 +	     mp->m_logbufs > XLOG_MAX_ICLOGS)) {
 +		xfs_warn(mp, "invalid logbufs value: %d [not %d-%d]",
 +			mp->m_logbufs, XLOG_MIN_ICLOGS, XLOG_MAX_ICLOGS);
 +		return -EINVAL;
 +	}
 +	if (mp->m_logbsize != -1 &&
 +	    mp->m_logbsize !=  0 &&
 +	    (mp->m_logbsize < XLOG_MIN_RECORD_BSIZE ||
 +	     mp->m_logbsize > XLOG_MAX_RECORD_BSIZE ||
 +	     !is_power_of_2(mp->m_logbsize))) {
 +		xfs_warn(mp,
 +			"invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]",
 +			mp->m_logbsize);
 +		return -EINVAL;
 +	}
 +
 +	if (iosizelog) {
 +		if (iosizelog > XFS_MAX_IO_LOG ||
 +		    iosizelog < XFS_MIN_IO_LOG) {
 +			xfs_warn(mp, "invalid log iosize: %d [not %d-%d]",
 +				iosizelog, XFS_MIN_IO_LOG,
 +				XFS_MAX_IO_LOG);
 +			return -EINVAL;
 +		}
 +
 +		mp->m_flags |= XFS_MOUNT_DFLT_IOSIZE;
 +		mp->m_allocsize_log = iosizelog;
 +	}
 +
 +	return 0;
 +}
++=======
+ static const struct fs_parameter_description xfs_fs_parameters = {
+ 	.specs		= xfs_param_specs,
+ };
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  
  struct proc_xfs_info {
  	uint64_t	flag;
diff --cc kernel/bpf/inode.c
index 66e55d381265,9608aa48128d..000000000000
--- a/kernel/bpf/inode.c
+++ b/kernel/bpf/inode.c
@@@ -611,12 -585,15 +611,22 @@@ static const struct super_operations bp
  
  enum {
  	OPT_MODE,
 +	OPT_ERR,
  };
  
++<<<<<<< HEAD
 +static const match_table_t bpf_mount_tokens = {
 +	{ OPT_MODE, "mode=%o" },
 +	{ OPT_ERR, NULL },
++=======
+ static const struct fs_parameter_spec bpf_param_specs[] = {
+ 	fsparam_u32oct	("mode",			OPT_MODE),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description bpf_fs_parameters = {
+ 	.specs		= bpf_param_specs,
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  };
  
  struct bpf_mount_opts {
diff --cc kernel/cgroup/cgroup-v1.c
index dd94e2a4c22e,c7b526f33621..000000000000
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@@ -873,13 -874,119 +873,44 @@@ static int cgroup1_show_options(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int parse_cgroupfs_options(char *data, struct cgroup_sb_opts *opts)
++=======
+ enum cgroup1_param {
+ 	Opt_all,
+ 	Opt_clone_children,
+ 	Opt_cpuset_v2_mode,
+ 	Opt_name,
+ 	Opt_none,
+ 	Opt_noprefix,
+ 	Opt_release_agent,
+ 	Opt_xattr,
+ };
+ 
+ static const struct fs_parameter_spec cgroup1_param_specs[] = {
+ 	fsparam_flag  ("all",		Opt_all),
+ 	fsparam_flag  ("clone_children", Opt_clone_children),
+ 	fsparam_flag  ("cpuset_v2_mode", Opt_cpuset_v2_mode),
+ 	fsparam_string("name",		Opt_name),
+ 	fsparam_flag  ("none",		Opt_none),
+ 	fsparam_flag  ("noprefix",	Opt_noprefix),
+ 	fsparam_string("release_agent",	Opt_release_agent),
+ 	fsparam_flag  ("xattr",		Opt_xattr),
+ 	{}
+ };
+ 
+ const struct fs_parameter_description cgroup1_fs_parameters = {
+ 	.specs		= cgroup1_param_specs,
+ };
+ 
+ int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 -	struct cgroup_subsys *ss;
 -	struct fs_parse_result result;
 -	int opt, i;
 -
 -	opt = fs_parse(fc, &cgroup1_fs_parameters, param, &result);
 -	if (opt == -ENOPARAM) {
 -		if (strcmp(param->key, "source") == 0) {
 -			fc->source = param->string;
 -			param->string = NULL;
 -			return 0;
 -		}
 -		for_each_subsys(ss, i) {
 -			if (strcmp(param->key, ss->legacy_name))
 -				continue;
 -			ctx->subsys_mask |= (1 << i);
 -			return 0;
 -		}
 -		return invalf(fc, "cgroup1: Unknown subsys name '%s'", param->key);
 -	}
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case Opt_none:
 -		/* Explicitly have no subsystems */
 -		ctx->none = true;
 -		break;
 -	case Opt_all:
 -		ctx->all_ss = true;
 -		break;
 -	case Opt_noprefix:
 -		ctx->flags |= CGRP_ROOT_NOPREFIX;
 -		break;
 -	case Opt_clone_children:
 -		ctx->cpuset_clone_children = true;
 -		break;
 -	case Opt_cpuset_v2_mode:
 -		ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;
 -		break;
 -	case Opt_xattr:
 -		ctx->flags |= CGRP_ROOT_XATTR;
 -		break;
 -	case Opt_release_agent:
 -		/* Specifying two release agents is forbidden */
 -		if (ctx->release_agent)
 -			return invalf(fc, "cgroup1: release_agent respecified");
 -		ctx->release_agent = param->string;
 -		param->string = NULL;
 -		break;
 -	case Opt_name:
 -		/* blocked by boot param? */
 -		if (cgroup_no_v1_named)
 -			return -ENOENT;
 -		/* Can't specify an empty name */
 -		if (!param->size)
 -			return invalf(fc, "cgroup1: Empty name");
 -		if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)
 -			return invalf(fc, "cgroup1: Name too long");
 -		/* Must match [\w.-]+ */
 -		for (i = 0; i < param->size; i++) {
 -			char c = param->string[i];
 -			if (isalnum(c))
 -				continue;
 -			if ((c == '.') || (c == '-') || (c == '_'))
 -				continue;
 -			return invalf(fc, "cgroup1: Invalid name");
 -		}
 -		/* Specifying two names is forbidden */
 -		if (ctx->name)
 -			return invalf(fc, "cgroup1: name respecified");
 -		ctx->name = param->string;
 -		param->string = NULL;
 -		break;
 -	}
 -	return 0;
 -}
 -
 -static int check_cgroupfs_options(struct fs_context *fc)
 -{
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 +	char *token, *o = data;
 +	bool all_ss = false, one_ss = false;
  	u16 mask = U16_MAX;
 -	u16 enabled = 0;
  	struct cgroup_subsys *ss;
 +	int nr_opts = 0;
  	int i;
  
  #ifdef CONFIG_CPUSETS
diff --cc kernel/cgroup/cgroup.c
index cfd0dd76492e,d86d441d93ca..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -1814,26 -1810,41 +1814,46 @@@ int cgroup_show_path(struct seq_file *s
  	return len;
  }
  
++<<<<<<< HEAD
 +static int parse_cgroup_root_flags(char *data, unsigned int *root_flags)
++=======
+ enum cgroup2_param {
+ 	Opt_nsdelegate,
+ 	Opt_memory_localevents,
+ 	nr__cgroup2_params
+ };
+ 
+ static const struct fs_parameter_spec cgroup2_param_specs[] = {
+ 	fsparam_flag("nsdelegate",		Opt_nsdelegate),
+ 	fsparam_flag("memory_localevents",	Opt_memory_localevents),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description cgroup2_fs_parameters = {
+ 	.specs		= cgroup2_param_specs,
+ };
+ 
+ static int cgroup2_parse_param(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
 -	struct fs_parse_result result;
 -	int opt;
 +	char *token;
  
 -	opt = fs_parse(fc, &cgroup2_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 +	*root_flags = 0;
  
 -	switch (opt) {
 -	case Opt_nsdelegate:
 -		ctx->flags |= CGRP_ROOT_NS_DELEGATE;
 -		return 0;
 -	case Opt_memory_localevents:
 -		ctx->flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;
 +	if (!data || *data == '\0')
  		return 0;
 +
 +	while ((token = strsep(&data, ",")) != NULL) {
 +		if (!strcmp(token, "nsdelegate")) {
 +			*root_flags |= CGRP_ROOT_NS_DELEGATE;
 +			continue;
 +		}
 +
 +		pr_err("cgroup2: unknown option \"%s\"\n", token);
 +		return -EINVAL;
  	}
 -	return -EINVAL;
 +
 +	return 0;
  }
  
  static void apply_cgroup_root_flags(unsigned int root_flags)
diff --cc mm/shmem.c
index 1b4f8fc6c563,445d038a54b9..000000000000
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@@ -3335,11 -3370,123 +3335,52 @@@ static const struct export_operations s
  	.fh_to_dentry	= shmem_fh_to_dentry,
  };
  
++<<<<<<< HEAD
 +static int shmem_parse_options(char *options, struct shmem_options *ctx)
++=======
+ enum shmem_param {
+ 	Opt_gid,
+ 	Opt_huge,
+ 	Opt_mode,
+ 	Opt_mpol,
+ 	Opt_nr_blocks,
+ 	Opt_nr_inodes,
+ 	Opt_size,
+ 	Opt_uid,
+ };
+ 
+ static const struct constant_table shmem_param_enums_huge[] = {
+ 	{"never",	SHMEM_HUGE_NEVER },
+ 	{"always",	SHMEM_HUGE_ALWAYS },
+ 	{"within_size",	SHMEM_HUGE_WITHIN_SIZE },
+ 	{"advise",	SHMEM_HUGE_ADVISE },
+ 	{"deny",	SHMEM_HUGE_DENY },
+ 	{"force",	SHMEM_HUGE_FORCE },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec shmem_param_specs[] = {
+ 	fsparam_u32   ("gid",		Opt_gid),
+ 	fsparam_enum  ("huge",		Opt_huge,  shmem_param_enums_huge),
+ 	fsparam_u32oct("mode",		Opt_mode),
+ 	fsparam_string("mpol",		Opt_mpol),
+ 	fsparam_string("nr_blocks",	Opt_nr_blocks),
+ 	fsparam_string("nr_inodes",	Opt_nr_inodes),
+ 	fsparam_string("size",		Opt_size),
+ 	fsparam_u32   ("uid",		Opt_uid),
+ 	{}
+ };
+ 
+ const struct fs_parameter_description shmem_fs_parameters = {
+ 	.specs		= shmem_param_specs,
+ };
+ 
+ static int shmem_parse_one(struct fs_context *fc, struct fs_parameter *param)
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  {
 -	struct shmem_options *ctx = fc->fs_private;
 -	struct fs_parse_result result;
 -	unsigned long long size;
 -	char *rest;
 -	int opt;
 -
 -	opt = fs_parse(fc, &shmem_fs_parameters, param, &result);
 -	if (opt < 0)
 -		return opt;
 -
 -	switch (opt) {
 -	case Opt_size:
 -		size = memparse(param->string, &rest);
 -		if (*rest == '%') {
 -			size <<= PAGE_SHIFT;
 -			size *= totalram_pages();
 -			do_div(size, 100);
 -			rest++;
 -		}
 -		if (*rest)
 -			goto bad_value;
 -		ctx->blocks = DIV_ROUND_UP(size, PAGE_SIZE);
 -		ctx->seen |= SHMEM_SEEN_BLOCKS;
 -		break;
 -	case Opt_nr_blocks:
 -		ctx->blocks = memparse(param->string, &rest);
 -		if (*rest)
 -			goto bad_value;
 -		ctx->seen |= SHMEM_SEEN_BLOCKS;
 -		break;
 -	case Opt_nr_inodes:
 -		ctx->inodes = memparse(param->string, &rest);
 -		if (*rest)
 -			goto bad_value;
 -		ctx->seen |= SHMEM_SEEN_INODES;
 -		break;
 -	case Opt_mode:
 -		ctx->mode = result.uint_32 & 07777;
 -		break;
 -	case Opt_uid:
 -		ctx->uid = make_kuid(current_user_ns(), result.uint_32);
 -		if (!uid_valid(ctx->uid))
 -			goto bad_value;
 -		break;
 -	case Opt_gid:
 -		ctx->gid = make_kgid(current_user_ns(), result.uint_32);
 -		if (!gid_valid(ctx->gid))
 -			goto bad_value;
 -		break;
 -	case Opt_huge:
 -		ctx->huge = result.uint_32;
 -		if (ctx->huge != SHMEM_HUGE_NEVER &&
 -		    !(IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&
 -		      has_transparent_hugepage()))
 -			goto unsupported_parameter;
 -		ctx->seen |= SHMEM_SEEN_HUGE;
 -		break;
 -	case Opt_mpol:
 -		if (IS_ENABLED(CONFIG_NUMA)) {
 -			mpol_put(ctx->mpol);
 -			ctx->mpol = NULL;
 -			if (mpol_parse_str(param->string, &ctx->mpol))
 -				goto bad_value;
 -			break;
 -		}
 -		goto unsupported_parameter;
 -	}
 -	return 0;
 -
 -unsupported_parameter:
 -	return invalf(fc, "tmpfs: Unsupported parameter '%s'", param->key);
 -bad_value:
 -	return invalf(fc, "tmpfs: Bad value for '%s'", param->key);
 -}
 -
 -static int shmem_parse_options(struct fs_context *fc, void *data)
 -{
 -	char *options = data;
 +	char *this_char, *value, *rest;
 +	uid_t uid;
 +	gid_t gid;
  
  	if (options) {
  		int err = security_sb_eat_lsm_opts(options, &fc->security);
diff --cc net/ceph/ceph_common.c
index 47dc7ae211b5,f639e04d9c63..000000000000
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@@ -281,35 -269,55 +281,66 @@@ enum 
  	Opt_abort_on_full,
  };
  
 -static const struct fs_parameter_spec ceph_param_specs[] = {
 -	fsparam_flag	("abort_on_full",		Opt_abort_on_full),
 -	fsparam_flag_no ("cephx_require_signatures",	Opt_cephx_require_signatures),
 -	fsparam_flag_no ("cephx_sign_messages",		Opt_cephx_sign_messages),
 -	fsparam_flag_no ("crc",				Opt_crc),
 -	fsparam_string	("fsid",			Opt_fsid),
 -	fsparam_string	("ip",				Opt_ip),
 -	fsparam_string	("key",				Opt_key),
 -	fsparam_u32	("mount_timeout",		Opt_mount_timeout),
 -	fsparam_string	("name",			Opt_name),
 -	fsparam_u32	("osd_idle_ttl",		Opt_osd_idle_ttl),
 -	fsparam_u32	("osd_request_timeout",		Opt_osd_request_timeout),
 -	fsparam_u32	("osdkeepalive",		Opt_osdkeepalivetimeout),
 -	__fsparam	(fs_param_is_s32, "osdtimeout", Opt_osdtimeout,
 -			 fs_param_deprecated, NULL),
 -	fsparam_string	("secret",			Opt_secret),
 -	fsparam_flag_no ("share",			Opt_share),
 -	fsparam_flag_no ("tcp_nodelay",			Opt_tcp_nodelay),
 -	{}
 +static match_table_t opt_tokens = {
 +	{Opt_osdtimeout, "osdtimeout=%d"},
 +	{Opt_osdkeepalivetimeout, "osdkeepalive=%d"},
 +	{Opt_mount_timeout, "mount_timeout=%d"},
 +	{Opt_osd_idle_ttl, "osd_idle_ttl=%d"},
 +	{Opt_osd_request_timeout, "osd_request_timeout=%d"},
 +	/* int args above */
 +	{Opt_fsid, "fsid=%s"},
 +	{Opt_name, "name=%s"},
 +	{Opt_secret, "secret=%s"},
 +	{Opt_key, "key=%s"},
 +	{Opt_ip, "ip=%s"},
 +	{Opt_crush_location, "crush_location=%s"},
 +	{Opt_read_from_replica, "read_from_replica=%s"},
 +	/* string args above */
 +	{Opt_share, "share"},
 +	{Opt_noshare, "noshare"},
 +	{Opt_crc, "crc"},
 +	{Opt_nocrc, "nocrc"},
 +	{Opt_cephx_require_signatures, "cephx_require_signatures"},
 +	{Opt_nocephx_require_signatures, "nocephx_require_signatures"},
 +	{Opt_cephx_sign_messages, "cephx_sign_messages"},
 +	{Opt_nocephx_sign_messages, "nocephx_sign_messages"},
 +	{Opt_tcp_nodelay, "tcp_nodelay"},
 +	{Opt_notcp_nodelay, "notcp_nodelay"},
 +	{Opt_abort_on_full, "abort_on_full"},
 +	{-1, NULL}
  };
  
++<<<<<<< HEAD
++=======
+ static const struct fs_parameter_description ceph_parameters = {
+         .specs          = ceph_param_specs,
+ };
+ 
+ struct ceph_options *ceph_alloc_options(void)
+ {
+ 	struct ceph_options *opt;
+ 
+ 	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
+ 	if (!opt)
+ 		return NULL;
+ 
+ 	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
+ 				GFP_KERNEL);
+ 	if (!opt->mon_addr) {
+ 		kfree(opt);
+ 		return NULL;
+ 	}
+ 
+ 	opt->flags = CEPH_OPT_DEFAULT;
+ 	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
+ 	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
+ 	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
+ 	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
+ 	return opt;
+ }
+ EXPORT_SYMBOL(ceph_alloc_options);
+ 
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  void ceph_destroy_options(struct ceph_options *opt)
  {
  	dout("destroy_options %p\n", opt);
diff --cc security/selinux/hooks.c
index 028981031687,54f34631bc16..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -2890,6 -2770,75 +2890,78 @@@ static int selinux_umount(struct vfsmou
  				   FILESYSTEM__UNMOUNT, NULL);
  }
  
++<<<<<<< HEAD
++=======
+ static int selinux_fs_context_dup(struct fs_context *fc,
+ 				  struct fs_context *src_fc)
+ {
+ 	const struct selinux_mnt_opts *src = src_fc->security;
+ 	struct selinux_mnt_opts *opts;
+ 
+ 	if (!src)
+ 		return 0;
+ 
+ 	fc->security = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);
+ 	if (!fc->security)
+ 		return -ENOMEM;
+ 
+ 	opts = fc->security;
+ 
+ 	if (src->fscontext) {
+ 		opts->fscontext = kstrdup(src->fscontext, GFP_KERNEL);
+ 		if (!opts->fscontext)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->context) {
+ 		opts->context = kstrdup(src->context, GFP_KERNEL);
+ 		if (!opts->context)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->rootcontext) {
+ 		opts->rootcontext = kstrdup(src->rootcontext, GFP_KERNEL);
+ 		if (!opts->rootcontext)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->defcontext) {
+ 		opts->defcontext = kstrdup(src->defcontext, GFP_KERNEL);
+ 		if (!opts->defcontext)
+ 			return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct fs_parameter_spec selinux_param_specs[] = {
+ 	fsparam_string(CONTEXT_STR,	Opt_context),
+ 	fsparam_string(DEFCONTEXT_STR,	Opt_defcontext),
+ 	fsparam_string(FSCONTEXT_STR,	Opt_fscontext),
+ 	fsparam_string(ROOTCONTEXT_STR,	Opt_rootcontext),
+ 	fsparam_flag  (SECLABEL_STR,	Opt_seclabel),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description selinux_fs_parameters = {
+ 	.specs		= selinux_param_specs,
+ };
+ 
+ static int selinux_fs_context_parse_param(struct fs_context *fc,
+ 					  struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	int opt, rc;
+ 
+ 	opt = fs_parse(fc, &selinux_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	rc = selinux_add_opt(opt, param->string, &fc->security);
+ 	if (!rc) {
+ 		param->string = NULL;
+ 		rc = 1;
+ 	}
+ 	return rc;
+ }
+ 
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  /* inode security operations */
  
  static int selinux_inode_alloc_security(struct inode *inode)
@@@ -7260,6 -7144,8 +7332,11 @@@ static __init int selinux_init(void
  	else
  		pr_debug("SELinux:  Starting in permissive mode\n");
  
++<<<<<<< HEAD
++=======
+ 	fs_validate_description("selinux", &selinux_fs_parameters);
+ 
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  	return 0;
  }
  
diff --cc security/smack/smack_lsm.c
index 77b0bfb018e5,646c0b4aa8c4..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -723,15 -626,93 +723,101 @@@ static int smack_parse_opts_str(char *o
  	return 0;
  
  out_opt_err:
 +	rc = -EINVAL;
  	pr_warn("Smack: duplicate mount options\n");
 -	return -EINVAL;
 -}
  
++<<<<<<< HEAD
 +out_err:
 +	kfree(fsdefault);
 +	kfree(fsfloor);
 +	kfree(fshat);
 +	kfree(fsroot);
 +	kfree(fstransmute);
++=======
+ /**
+  * smack_fs_context_dup - Duplicate the security data on fs_context duplication
+  * @fc: The new filesystem context.
+  * @src_fc: The source filesystem context being duplicated.
+  *
+  * Returns 0 on success or -ENOMEM on error.
+  */
+ static int smack_fs_context_dup(struct fs_context *fc,
+ 				struct fs_context *src_fc)
+ {
+ 	struct smack_mnt_opts *dst, *src = src_fc->security;
+ 
+ 	if (!src)
+ 		return 0;
+ 
+ 	fc->security = kzalloc(sizeof(struct smack_mnt_opts), GFP_KERNEL);
+ 	if (!fc->security)
+ 		return -ENOMEM;
+ 	dst = fc->security;
+ 
+ 	if (src->fsdefault) {
+ 		dst->fsdefault = kstrdup(src->fsdefault, GFP_KERNEL);
+ 		if (!dst->fsdefault)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fsfloor) {
+ 		dst->fsfloor = kstrdup(src->fsfloor, GFP_KERNEL);
+ 		if (!dst->fsfloor)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fshat) {
+ 		dst->fshat = kstrdup(src->fshat, GFP_KERNEL);
+ 		if (!dst->fshat)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fsroot) {
+ 		dst->fsroot = kstrdup(src->fsroot, GFP_KERNEL);
+ 		if (!dst->fsroot)
+ 			return -ENOMEM;
+ 	}
+ 	if (src->fstransmute) {
+ 		dst->fstransmute = kstrdup(src->fstransmute, GFP_KERNEL);
+ 		if (!dst->fstransmute)
+ 			return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct fs_parameter_spec smack_param_specs[] = {
+ 	fsparam_string("smackfsdef",		Opt_fsdefault),
+ 	fsparam_string("smackfsdefault",	Opt_fsdefault),
+ 	fsparam_string("smackfsfloor",		Opt_fsfloor),
+ 	fsparam_string("smackfshat",		Opt_fshat),
+ 	fsparam_string("smackfsroot",		Opt_fsroot),
+ 	fsparam_string("smackfstransmute",	Opt_fstransmute),
+ 	{}
+ };
+ 
+ static const struct fs_parameter_description smack_fs_parameters = {
+ 	.specs		= smack_param_specs,
+ };
+ 
+ /**
+  * smack_fs_context_parse_param - Parse a single mount parameter
+  * @fc: The new filesystem context being constructed.
+  * @param: The parameter.
+  *
+  * Returns 0 on success, -ENOPARAM to pass the parameter on or anything else on
+  * error.
+  */
+ static int smack_fs_context_parse_param(struct fs_context *fc,
+ 					struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	int opt, rc;
+ 
+ 	opt = fs_parse(fc, &smack_fs_parameters, param, &result);
+ 	if (opt < 0)
+ 		return opt;
+ 
+ 	rc = smack_add_opt(opt, param->string, &fc->security);
+ 	if (!rc)
+ 		param->string = NULL;
++>>>>>>> 96cafb9ccb15 (fs_parser: remove fs_parameter_description name field)
  	return rc;
  }
  
* Unmerged path fs/fs_parser.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path include/linux/fs_parser.h
diff --git a/Documentation/filesystems/mount_api.txt b/Documentation/filesystems/mount_api.txt
index 00ff0cfccfa7..7e09dc3418b3 100644
--- a/Documentation/filesystems/mount_api.txt
+++ b/Documentation/filesystems/mount_api.txt
@@ -519,7 +519,6 @@ Parameters are described using structures defined in linux/fs_parser.h.
 There's a core description struct that links everything together:
 
 	struct fs_parameter_description {
-		const char	name[16];
 		const struct fs_parameter_spec *specs;
 		const struct fs_parameter_enum *enums;
 	};
@@ -535,19 +534,13 @@ For example:
 	};
 
 	static const struct fs_parameter_description afs_fs_parameters = {
-		.name		= "kAFS",
 		.specs		= afs_param_specs,
 		.enums		= afs_param_enums,
 	};
 
 The members are as follows:
 
- (1) const char name[16];
-
-     The name to be used in error messages generated by the parse helper
-     functions.
-
- (2) const struct fs_parameter_specification *specs;
+ (1) const struct fs_parameter_specification *specs;
 
      Table of parameter specifications, terminated with a null entry, where the
      entries are of type:
@@ -626,7 +619,7 @@ The members are as follows:
      of arguments to specify the type and the flags for anything that doesn't
      match one of the above macros.
 
- (6) const struct fs_parameter_enum *enums;
+ (2) const struct fs_parameter_enum *enums;
 
      Table of enum value names to integer mappings, terminated with a null
      entry.  This is of type:
* Unmerged path arch/powerpc/platforms/cell/spufs/inode.c
* Unmerged path arch/s390/hypfs/inode.c
* Unmerged path arch/x86/kernel/cpu/resctrl/rdtgroup.c
* Unmerged path drivers/block/rbd.c
* Unmerged path drivers/usb/gadget/function/f_fs.c
* Unmerged path fs/afs/super.c
* Unmerged path fs/ceph/super.c
* Unmerged path fs/filesystems.c
* Unmerged path fs/fs_parser.c
* Unmerged path fs/fuse/inode.c
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index ddff87690c58..8f3a55df667d 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -1364,7 +1364,6 @@ static const struct fs_parameter_enum gfs2_param_enums[] = {
 };
 
 static const struct fs_parameter_description gfs2_fs_parameters = {
-	.name = "gfs2",
 	.specs = gfs2_param_specs,
 	.enums = gfs2_param_enums,
 };
diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index 7aa2a56cc419..eb5b88b57c7d 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -85,7 +85,6 @@ static const struct fs_parameter_spec hugetlb_param_specs[] = {
 };
 
 static const struct fs_parameter_description hugetlb_fs_parameters = {
-	.name		= "hugetlbfs",
 	.specs		= hugetlb_param_specs,
 };
 
* Unmerged path fs/jffs2/super.c
* Unmerged path fs/nfs/fs_context.c
* Unmerged path fs/proc/root.c
* Unmerged path fs/ramfs/inode.c
* Unmerged path fs/xfs/xfs_super.c
* Unmerged path include/linux/fs_parser.h
* Unmerged path kernel/bpf/inode.c
* Unmerged path kernel/cgroup/cgroup-v1.c
* Unmerged path kernel/cgroup/cgroup.c
* Unmerged path mm/shmem.c
* Unmerged path net/ceph/ceph_common.c
* Unmerged path security/selinux/hooks.c
* Unmerged path security/smack/smack_lsm.c
