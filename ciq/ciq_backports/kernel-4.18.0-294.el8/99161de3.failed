powerpc/64s/radix: tidy up TLB flushing code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Nicholas Piggin <npiggin@gmail.com>
commit 99161de3a283af59f2813da6cbdccc1d2784c7de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/99161de3.failed

There should be no functional changes.

- Use calls to existing radix_tlb.c functions in flush_partition.

- Rename radix__flush_tlb_lpid to radix__flush_all_lpid and similar,
  because they flush everything, matching flush_all_mm rather than
  flush_tlb_mm for the lpid.

- Remove some unused radix_tlb.c flush primitives.

Signed-off: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20190902152931.17840-3-npiggin@gmail.com
(cherry picked from commit 99161de3a283af59f2813da6cbdccc1d2784c7de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/book3s/64/tlbflush-radix.h
#	arch/powerpc/mm/book3s64/radix_tlb.c
diff --cc arch/powerpc/include/asm/book3s/64/tlbflush-radix.h
index 671316f9e95d,4ce795d30377..000000000000
--- a/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h
+++ b/arch/powerpc/include/asm/book3s/64/tlbflush-radix.h
@@@ -13,8 -13,28 +13,33 @@@ static inline int mmu_get_ap(int psize
  
  #ifdef CONFIG_PPC_RADIX_MMU
  extern void radix__tlbiel_all(unsigned int action);
++<<<<<<< HEAD
 +#else
 +static inline void radix__tlbiel_all(unsigned int action) { WARN_ON(1); };
++=======
+ extern void radix__flush_tlb_lpid_page(unsigned int lpid,
+ 					unsigned long addr,
+ 					unsigned long page_size);
+ extern void radix__flush_pwc_lpid(unsigned int lpid);
+ extern void radix__flush_all_lpid(unsigned int lpid);
+ extern void radix__flush_all_lpid_guest(unsigned int lpid);
+ #else
+ static inline void radix__tlbiel_all(unsigned int action) { WARN_ON(1); };
+ static inline void radix__flush_tlb_lpid_page(unsigned int lpid,
+ 					unsigned long addr,
+ 					unsigned long page_size)
+ {
+ 	WARN_ON(1);
+ }
+ static inline void radix__flush_pwc_lpid(unsigned int lpid)
+ {
+ 	WARN_ON(1);
+ }
+ static inline void radix__flush_all_lpid(unsigned int lpid)
+ {
+ 	WARN_ON(1);
+ }
++>>>>>>> 99161de3a283 (powerpc/64s/radix: tidy up TLB flushing code)
  #endif
  
  extern void radix__flush_hugetlb_tlb_range(struct vm_area_struct *vma,
@@@ -49,12 -69,4 +74,15 @@@ extern void radix__flush_tlb_pwc(struc
  extern void radix__flush_tlb_collapsed_pmd(struct mm_struct *mm, unsigned long addr);
  extern void radix__flush_tlb_all(void);
  
++<<<<<<< HEAD
 +extern void radix__flush_tlb_lpid_page(unsigned int lpid,
 +					unsigned long addr,
 +					unsigned long page_size);
 +extern void radix__flush_pwc_lpid(unsigned int lpid);
 +extern void radix__flush_tlb_lpid(unsigned int lpid);
 +extern void radix__local_flush_tlb_lpid(unsigned int lpid);
 +extern void radix__local_flush_tlb_lpid_guest(unsigned int lpid);
 +
++=======
++>>>>>>> 99161de3a283 (powerpc/64s/radix: tidy up TLB flushing code)
  #endif
diff --cc arch/powerpc/mm/book3s64/radix_tlb.c
index f43e7b4e131f,082f90d068ee..000000000000
--- a/arch/powerpc/mm/book3s64/radix_tlb.c
+++ b/arch/powerpc/mm/book3s64/radix_tlb.c
@@@ -120,23 -116,7 +120,27 @@@ static inline void __tlbie_pid(unsigne
  	trace_tlbie(0, 0, rb, rs, ric, prs, r);
  }
  
++<<<<<<< HEAD
 +static inline void __tlbiel_lpid(unsigned long lpid, int set,
 +				unsigned long ric)
 +{
 +	unsigned long rb,rs,prs,r;
 +
 +	rb = PPC_BIT(52); /* IS = 2 */
 +	rb |= set << PPC_BITLSHIFT(51);
 +	rs = 0;  /* LPID comes from LPIDR */
 +	prs = 0; /* partition scoped */
 +	r = 1;   /* radix format */
 +
 +	asm volatile(PPC_TLBIEL(%0, %4, %3, %2, %1)
 +		     : : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(rs) : "memory");
 +	trace_tlbie(lpid, 1, rb, rs, ric, prs, r);
 +}
 +
 +static inline void __tlbie_lpid(unsigned long lpid, unsigned long ric)
++=======
+ static __always_inline void __tlbie_lpid(unsigned long lpid, unsigned long ric)
++>>>>>>> 99161de3a283 (powerpc/64s/radix: tidy up TLB flushing code)
  {
  	unsigned long rb,rs,prs,r;
  
@@@ -150,8 -130,7 +154,12 @@@
  	trace_tlbie(lpid, 0, rb, rs, ric, prs, r);
  }
  
++<<<<<<< HEAD
 +static inline void __tlbiel_lpid_guest(unsigned long lpid, int set,
 +				unsigned long ric)
++=======
+ static __always_inline void __tlbie_lpid_guest(unsigned long lpid, unsigned long ric)
++>>>>>>> 99161de3a283 (powerpc/64s/radix: tidy up TLB flushing code)
  {
  	unsigned long rb,rs,prs,r;
  
@@@ -161,14 -139,13 +168,19 @@@
  	prs = 1; /* process scoped */
  	r = 1;   /* radix format */
  
- 	asm volatile(PPC_TLBIEL(%0, %4, %3, %2, %1)
+ 	asm volatile(PPC_TLBIE_5(%0, %4, %3, %2, %1)
  		     : : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(rs) : "memory");
- 	trace_tlbie(lpid, 1, rb, rs, ric, prs, r);
+ 	trace_tlbie(lpid, 0, rb, rs, ric, prs, r);
  }
  
++<<<<<<< HEAD
 +
 +static inline void __tlbiel_va(unsigned long va, unsigned long pid,
 +			       unsigned long ap, unsigned long ric)
++=======
+ static __always_inline void __tlbiel_va(unsigned long va, unsigned long pid,
+ 					unsigned long ap, unsigned long ric)
++>>>>>>> 99161de3a283 (powerpc/64s/radix: tidy up TLB flushing code)
  {
  	unsigned long rb,rs,prs,r;
  
@@@ -351,34 -265,7 +363,37 @@@ static inline void _tlbie_pid(unsigned 
  	asm volatile("eieio; tlbsync; ptesync": : :"memory");
  }
  
++<<<<<<< HEAD
 +static inline void _tlbiel_lpid(unsigned long lpid, unsigned long ric)
 +{
 +	int set;
 +
 +	VM_BUG_ON(mfspr(SPRN_LPID) != lpid);
 +
 +	asm volatile("ptesync": : :"memory");
 +
 +	/*
 +	 * Flush the first set of the TLB, and if we're doing a RIC_FLUSH_ALL,
 +	 * also flush the entire Page Walk Cache.
 +	 */
 +	__tlbiel_lpid(lpid, 0, ric);
 +
 +	/* For PWC, only one flush is needed */
 +	if (ric == RIC_FLUSH_PWC) {
 +		asm volatile("ptesync": : :"memory");
 +		return;
 +	}
 +
 +	/* For the remaining sets, just flush the TLB */
 +	for (set = 1; set < POWER9_TLB_SETS_RADIX ; set++)
 +		__tlbiel_lpid(lpid, set, RIC_FLUSH_TLB);
 +
 +	asm volatile("ptesync": : :"memory");
 +	asm volatile(PPC_INVALIDATE_ERAT "; isync" : : :"memory");
 +}
 +
++=======
++>>>>>>> 99161de3a283 (powerpc/64s/radix: tidy up TLB flushing code)
  static inline void _tlbie_lpid(unsigned long lpid, unsigned long ric)
  {
  	asm volatile("ptesync": : :"memory");
@@@ -404,34 -289,29 +419,41 @@@
  	asm volatile("eieio; tlbsync; ptesync": : :"memory");
  }
  
++<<<<<<< HEAD
 +static inline void _tlbiel_lpid_guest(unsigned long lpid, unsigned long ric)
++=======
+ static __always_inline void _tlbie_lpid_guest(unsigned long lpid, unsigned long ric)
++>>>>>>> 99161de3a283 (powerpc/64s/radix: tidy up TLB flushing code)
  {
- 	int set;
- 
- 	VM_BUG_ON(mfspr(SPRN_LPID) != lpid);
- 
- 	asm volatile("ptesync": : :"memory");
- 
  	/*
- 	 * Flush the first set of the TLB, and if we're doing a RIC_FLUSH_ALL,
- 	 * also flush the entire Page Walk Cache.
+ 	 * Workaround the fact that the "ric" argument to __tlbie_pid
+ 	 * must be a compile-time contraint to match the "i" constraint
+ 	 * in the asm statement.
  	 */
- 	__tlbiel_lpid_guest(lpid, 0, ric);
- 
- 	/* For PWC, only one flush is needed */
- 	if (ric == RIC_FLUSH_PWC) {
- 		asm volatile("ptesync": : :"memory");
- 		return;
+ 	switch (ric) {
+ 	case RIC_FLUSH_TLB:
+ 		__tlbie_lpid_guest(lpid, RIC_FLUSH_TLB);
+ 		break;
+ 	case RIC_FLUSH_PWC:
+ 		__tlbie_lpid_guest(lpid, RIC_FLUSH_PWC);
+ 		break;
+ 	case RIC_FLUSH_ALL:
+ 	default:
+ 		__tlbie_lpid_guest(lpid, RIC_FLUSH_ALL);
  	}
++<<<<<<< HEAD
 +
 +	/* For the remaining sets, just flush the TLB */
 +	for (set = 1; set < POWER9_TLB_SETS_RADIX ; set++)
 +		__tlbiel_lpid_guest(lpid, set, RIC_FLUSH_TLB);
 +
 +	asm volatile("ptesync": : :"memory");
++=======
+ 	fixup_tlbie_lpid(lpid);
+ 	asm volatile("eieio; tlbsync; ptesync": : :"memory");
++>>>>>>> 99161de3a283 (powerpc/64s/radix: tidy up TLB flushing code)
  }
  
- 
  static inline void __tlbiel_va_range(unsigned long start, unsigned long end,
  				    unsigned long pid, unsigned long page_size,
  				    unsigned long psize)
* Unmerged path arch/powerpc/include/asm/book3s/64/tlbflush-radix.h
diff --git a/arch/powerpc/kvm/book3s_hv_nested.c b/arch/powerpc/kvm/book3s_hv_nested.c
index e182e7fc15af..ee8984a217c9 100644
--- a/arch/powerpc/kvm/book3s_hv_nested.c
+++ b/arch/powerpc/kvm/book3s_hv_nested.c
@@ -398,7 +398,7 @@ static void kvmhv_flush_lpid(unsigned int lpid)
 	long rc;
 
 	if (!kvmhv_on_pseries()) {
-		radix__flush_tlb_lpid(lpid);
+		radix__flush_all_lpid(lpid);
 		return;
 	}
 
diff --git a/arch/powerpc/mm/book3s64/pgtable.c b/arch/powerpc/mm/book3s64/pgtable.c
index e3da07e289f2..38d14827f3e1 100644
--- a/arch/powerpc/mm/book3s64/pgtable.c
+++ b/arch/powerpc/mm/book3s64/pgtable.c
@@ -222,20 +222,17 @@ void __init mmu_partition_table_init(void)
 
 static void flush_partition(unsigned int lpid, bool radix)
 {
-	asm volatile("ptesync" : : : "memory");
 	if (radix) {
-		asm volatile(PPC_TLBIE_5(%0,%1,2,0,1) : :
-			     "r" (TLBIEL_INVAL_SET_LPID), "r" (lpid));
-		asm volatile(PPC_TLBIE_5(%0,%1,2,1,1) : :
-			     "r" (TLBIEL_INVAL_SET_LPID), "r" (lpid));
-		trace_tlbie(lpid, 0, TLBIEL_INVAL_SET_LPID, lpid, 2, 0, 1);
+		radix__flush_all_lpid(lpid);
+		radix__flush_all_lpid_guest(lpid);
 	} else {
+		asm volatile("ptesync" : : : "memory");
 		asm volatile(PPC_TLBIE_5(%0,%1,2,0,0) : :
 			     "r" (TLBIEL_INVAL_SET_LPID), "r" (lpid));
+		/* do we need fixup here ?*/
+		asm volatile("eieio; tlbsync; ptesync" : : : "memory");
 		trace_tlbie(lpid, 0, TLBIEL_INVAL_SET_LPID, lpid, 2, 0, 0);
 	}
-	/* do we need fixup here ?*/
-	asm volatile("eieio; tlbsync; ptesync" : : : "memory");
 }
 
 void mmu_partition_table_set_entry(unsigned int lpid, unsigned long dw0,
* Unmerged path arch/powerpc/mm/book3s64/radix_tlb.c
