vfio, mm: pin_user_pages (FOLL_PIN) and put_user_page() conversion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author John Hubbard <jhubbard@nvidia.com>
commit 19fed0dae94dbe66235c116a0e058712d8bc291c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/19fed0da.failed

1. Change vfio from get_user_pages_remote(), to
   pin_user_pages_remote().

2. Because all FOLL_PIN-acquired pages must be released via
   put_user_page(), also convert the put_page() call over to
   put_user_pages_dirty_lock().

Note that this effectively changes the code's behavior in
vfio_iommu_type1.c: put_pfn(): it now ultimately calls
set_page_dirty_lock(), instead of set_page_dirty().  This is probably
more accurate.

As Christoph Hellwig put it, "set_page_dirty() is only safe if we are
dealing with a file backed page where we have reference on the inode it
hangs off." [1]

[1] https://lore.kernel.org/r/20190723153640.GB720@lst.de

Link: http://lkml.kernel.org/r/20200107224558.2362728-20-jhubbard@nvidia.com
	Signed-off-by: John Hubbard <jhubbard@nvidia.com>
	Tested-by: Alex Williamson <alex.williamson@redhat.com>
	Acked-by: Alex Williamson <alex.williamson@redhat.com>
	Cc: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
	Cc: Björn Töpel <bjorn.topel@intel.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Jason Gunthorpe <jgg@mellanox.com>
	Cc: Jason Gunthorpe <jgg@ziepe.ca>
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Jerome Glisse <jglisse@redhat.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Kirill A. Shutemov <kirill@shutemov.name>
	Cc: Leon Romanovsky <leonro@mellanox.com>
	Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
	Cc: Mike Rapoport <rppt@linux.ibm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 19fed0dae94dbe66235c116a0e058712d8bc291c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/vfio_iommu_type1.c
diff --cc drivers/vfio/vfio_iommu_type1.c
index f1a7cfd55b17,18bfc2fc8e6d..000000000000
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@@ -359,34 -328,16 +358,39 @@@ static int vaddr_get_pfn(struct mm_stru
  		flags |= FOLL_WRITE;
  
  	down_read(&mm->mmap_sem);
++<<<<<<< HEAD
 +	if (mm == current->mm) {
 +		ret = get_user_pages(vaddr, 1, flags | FOLL_LONGTERM, page,
 +				     vmas);
 +	} else {
 +		ret = get_user_pages_remote(NULL, mm, vaddr, 1, flags, page,
 +					    vmas, NULL);
 +		/*
 +		 * The lifetime of a vaddr_get_pfn() page pin is
 +		 * userspace-controlled. In the fs-dax case this could
 +		 * lead to indefinite stalls in filesystem operations.
 +		 * Disallow attempts to pin fs-dax pages via this
 +		 * interface.
 +		 */
 +		if (ret > 0 && vma_is_fsdax(vmas[0])) {
 +			ret = -EOPNOTSUPP;
 +			put_page(page[0]);
 +		}
 +	}
 +	up_read(&mm->mmap_sem);
 +
++=======
+ 	ret = pin_user_pages_remote(NULL, mm, vaddr, 1, flags | FOLL_LONGTERM,
+ 				    page, NULL, NULL);
++>>>>>>> 19fed0dae94d (vfio, mm: pin_user_pages (FOLL_PIN) and put_user_page() conversion)
  	if (ret == 1) {
  		*pfn = page_to_pfn(page[0]);
 -		ret = 0;
 -		goto done;
 +		return 0;
  	}
  
 -	vaddr = untagged_addr(vaddr);
 +	down_read(&mm->mmap_sem);
  
 +retry:
  	vma = find_vma_intersection(mm, vaddr, vaddr + 1);
  
  	if (vma && vma->vm_flags & VM_PFNMAP) {
* Unmerged path drivers/vfio/vfio_iommu_type1.c
