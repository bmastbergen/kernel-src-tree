powerpc/pseries: Handle UE event for memcpy_mcsafe

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Ganesh Goudar <ganeshgr@linux.ibm.com>
commit efbc4303b255bb80ab1283794b36dd5fe1fb0ec3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/efbc4303.failed

memcpy_mcsafe has been implemented for power machines which is used
by pmem infrastructure, so that an UE encountered during memcpy from
pmem devices would not result in panic instead a right error code
is returned. The implementation expects machine check handler to ignore
the event and set nip to continue the execution from fixup code.

Appropriate changes are already made to powernv machine check handler,
make similar changes to pseries machine check handler to ignore the
the event and set nip to continue execution at the fixup entry if we
hit UE at an instruction with a fixup entry.

while we are at it, have a common function which searches the exception
table entry and updates nip with fixup address, and any future common
changes can be made in this function that are valid for both architectures.

powernv changes are made by
commit 895e3dceeb97 ("powerpc/mce: Handle UE event for memcpy_mcsafe")

	Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
	Reviewed-by: Santosh S <santosh@fossix.org>
	Signed-off-by: Ganesh Goudar <ganeshgr@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200326184916.31172-1-ganeshgr@linux.ibm.com
(cherry picked from commit efbc4303b255bb80ab1283794b36dd5fe1fb0ec3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/ras.c
diff --cc arch/powerpc/platforms/pseries/ras.c
index fa1449d4c5f5,aa6208c8d4f0..000000000000
--- a/arch/powerpc/platforms/pseries/ras.c
+++ b/arch/powerpc/platforms/pseries/ras.c
@@@ -676,6 -553,108 +676,111 @@@ static int mce_handle_error(struct rtas
  
  	mce_log = (struct pseries_mc_errorlog *)pseries_log->data;
  	error_type = mce_log->error_type;
++<<<<<<< HEAD
++=======
+ 	err_sub_type = rtas_mc_error_sub_type(mce_log);
+ 
+ 	switch (mce_log->error_type) {
+ 	case MC_ERROR_TYPE_UE:
+ 		mce_err.error_type = MCE_ERROR_TYPE_UE;
+ 		mce_common_process_ue(regs, &mce_err);
+ 		if (mce_err.ignore_event)
+ 			disposition = RTAS_DISP_FULLY_RECOVERED;
+ 		switch (err_sub_type) {
+ 		case MC_ERROR_UE_IFETCH:
+ 			mce_err.u.ue_error_type = MCE_UE_ERROR_IFETCH;
+ 			break;
+ 		case MC_ERROR_UE_PAGE_TABLE_WALK_IFETCH:
+ 			mce_err.u.ue_error_type = MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH;
+ 			break;
+ 		case MC_ERROR_UE_LOAD_STORE:
+ 			mce_err.u.ue_error_type = MCE_UE_ERROR_LOAD_STORE;
+ 			break;
+ 		case MC_ERROR_UE_PAGE_TABLE_WALK_LOAD_STORE:
+ 			mce_err.u.ue_error_type = MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE;
+ 			break;
+ 		case MC_ERROR_UE_INDETERMINATE:
+ 		default:
+ 			mce_err.u.ue_error_type = MCE_UE_ERROR_INDETERMINATE;
+ 			break;
+ 		}
+ 		if (mce_log->sub_err_type & UE_EFFECTIVE_ADDR_PROVIDED)
+ 			eaddr = be64_to_cpu(mce_log->effective_address);
+ 
+ 		if (mce_log->sub_err_type & UE_LOGICAL_ADDR_PROVIDED) {
+ 			paddr = be64_to_cpu(mce_log->logical_address);
+ 		} else if (mce_log->sub_err_type & UE_EFFECTIVE_ADDR_PROVIDED) {
+ 			unsigned long pfn;
+ 
+ 			pfn = addr_to_pfn(regs, eaddr);
+ 			if (pfn != ULONG_MAX)
+ 				paddr = pfn << PAGE_SHIFT;
+ 		}
+ 
+ 		break;
+ 	case MC_ERROR_TYPE_SLB:
+ 		mce_err.error_type = MCE_ERROR_TYPE_SLB;
+ 		switch (err_sub_type) {
+ 		case MC_ERROR_SLB_PARITY:
+ 			mce_err.u.slb_error_type = MCE_SLB_ERROR_PARITY;
+ 			break;
+ 		case MC_ERROR_SLB_MULTIHIT:
+ 			mce_err.u.slb_error_type = MCE_SLB_ERROR_MULTIHIT;
+ 			break;
+ 		case MC_ERROR_SLB_INDETERMINATE:
+ 		default:
+ 			mce_err.u.slb_error_type = MCE_SLB_ERROR_INDETERMINATE;
+ 			break;
+ 		}
+ 		if (mce_log->sub_err_type & 0x80)
+ 			eaddr = be64_to_cpu(mce_log->effective_address);
+ 		break;
+ 	case MC_ERROR_TYPE_ERAT:
+ 		mce_err.error_type = MCE_ERROR_TYPE_ERAT;
+ 		switch (err_sub_type) {
+ 		case MC_ERROR_ERAT_PARITY:
+ 			mce_err.u.erat_error_type = MCE_ERAT_ERROR_PARITY;
+ 			break;
+ 		case MC_ERROR_ERAT_MULTIHIT:
+ 			mce_err.u.erat_error_type = MCE_ERAT_ERROR_MULTIHIT;
+ 			break;
+ 		case MC_ERROR_ERAT_INDETERMINATE:
+ 		default:
+ 			mce_err.u.erat_error_type = MCE_ERAT_ERROR_INDETERMINATE;
+ 			break;
+ 		}
+ 		if (mce_log->sub_err_type & 0x80)
+ 			eaddr = be64_to_cpu(mce_log->effective_address);
+ 		break;
+ 	case MC_ERROR_TYPE_TLB:
+ 		mce_err.error_type = MCE_ERROR_TYPE_TLB;
+ 		switch (err_sub_type) {
+ 		case MC_ERROR_TLB_PARITY:
+ 			mce_err.u.tlb_error_type = MCE_TLB_ERROR_PARITY;
+ 			break;
+ 		case MC_ERROR_TLB_MULTIHIT:
+ 			mce_err.u.tlb_error_type = MCE_TLB_ERROR_MULTIHIT;
+ 			break;
+ 		case MC_ERROR_TLB_INDETERMINATE:
+ 		default:
+ 			mce_err.u.tlb_error_type = MCE_TLB_ERROR_INDETERMINATE;
+ 			break;
+ 		}
+ 		if (mce_log->sub_err_type & 0x80)
+ 			eaddr = be64_to_cpu(mce_log->effective_address);
+ 		break;
+ 	case MC_ERROR_TYPE_D_CACHE:
+ 		mce_err.error_type = MCE_ERROR_TYPE_DCACHE;
+ 		break;
+ 	case MC_ERROR_TYPE_I_CACHE:
+ 		mce_err.error_type = MCE_ERROR_TYPE_DCACHE;
+ 		break;
+ 	case MC_ERROR_TYPE_UNKNOWN:
+ 	default:
+ 		mce_err.error_type = MCE_ERROR_TYPE_UNKNOWN;
+ 		break;
+ 	}
++>>>>>>> efbc4303b255 (powerpc/pseries: Handle UE event for memcpy_mcsafe)
  
  #ifdef CONFIG_PPC_BOOK3S_64
  	if (disposition == RTAS_DISP_NOT_RECOVERED) {
diff --git a/arch/powerpc/include/asm/mce.h b/arch/powerpc/include/asm/mce.h
index 95ec50eadb94..6c4e1cf455f1 100644
--- a/arch/powerpc/include/asm/mce.h
+++ b/arch/powerpc/include/asm/mce.h
@@ -213,6 +213,8 @@ extern void machine_check_queue_event(void);
 extern void machine_check_print_event_info(struct machine_check_event *evt,
 					   bool user_mode, bool in_guest);
 unsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr);
+extern void mce_common_process_ue(struct pt_regs *regs,
+				  struct mce_error_info *mce_err);
 #ifdef CONFIG_PPC_BOOK3S_64
 void flush_and_reload_slb(void);
 #endif /* CONFIG_PPC_BOOK3S_64 */
diff --git a/arch/powerpc/kernel/mce.c b/arch/powerpc/kernel/mce.c
index b4119ae43b3c..95af895c8a15 100644
--- a/arch/powerpc/kernel/mce.c
+++ b/arch/powerpc/kernel/mce.c
@@ -28,6 +28,7 @@
 #include <linux/percpu.h>
 #include <linux/export.h>
 #include <linux/irq_work.h>
+#include <linux/extable.h>
 
 #include <asm/machdep.h>
 #include <asm/mce.h>
@@ -261,6 +262,19 @@ void machine_check_queue_event(void)
 	/* Queue irq work to process this event later. */
 	irq_work_queue(&mce_event_process_work);
 }
+
+void mce_common_process_ue(struct pt_regs *regs,
+			   struct mce_error_info *mce_err)
+{
+	const struct exception_table_entry *entry;
+
+	entry = search_kernel_exception_table(regs->nip);
+	if (entry) {
+		mce_err->ignore_event = true;
+		regs->nip = extable_fixup(entry);
+	}
+}
+
 /*
  * process pending MCE event from the mce event queue. This function will be
  * called during syscall exit.
diff --git a/arch/powerpc/kernel/mce_power.c b/arch/powerpc/kernel/mce_power.c
index e15100ace981..506a959d2616 100644
--- a/arch/powerpc/kernel/mce_power.c
+++ b/arch/powerpc/kernel/mce_power.c
@@ -559,14 +559,10 @@ static long mce_handle_ue_error(struct pt_regs *regs,
 				struct mce_error_info *mce_err)
 {
 	long handled = 0;
-	const struct exception_table_entry *entry;
 
-	entry = search_kernel_exception_table(regs->nip);
-	if (entry) {
-		mce_err->ignore_event = true;
-		regs->nip = extable_fixup(entry);
+	mce_common_process_ue(regs, mce_err);
+	if (mce_err->ignore_event)
 		return 1;
-	}
 
 	/*
 	 * On specific SCOM read via MMIO we may get a machine check
* Unmerged path arch/powerpc/platforms/pseries/ras.c
