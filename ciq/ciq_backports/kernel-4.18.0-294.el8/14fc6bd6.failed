bpf: Refactor bpf_iter_reg to have separate seq_info member

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Yonghong Song <yhs@fb.com>
commit 14fc6bd6b79c430f615500d0fe6cea4722110db8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/14fc6bd6.failed

There is no functionality change for this patch.
Struct bpf_iter_reg is used to register a bpf_iter target,
which includes information for both prog_load, link_create
and seq_file creation.

This patch puts fields related seq_file creation into
a different structure. This will be useful for map
elements iterator where one iterator covers different
map types and different map types may have different
seq_ops, init/fini private_data function and
private_data size.

	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200723184109.590030-1-yhs@fb.com
(cherry picked from commit 14fc6bd6b79c430f615500d0fe6cea4722110db8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/bpf_iter.c
#	kernel/bpf/map_iter.c
#	kernel/bpf/task_iter.c
#	net/ipv4/tcp_ipv4.c
#	net/ipv4/udp.c
#	net/ipv6/route.c
#	net/netlink/af_netlink.c
diff --cc include/linux/bpf.h
index 2171a69591bc,127067f71fd4..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -1148,19 -1193,33 +1157,33 @@@ struct bpf_link *bpf_link_get_from_fd(u
  int bpf_obj_pin_user(u32 ufd, const char __user *pathname);
  int bpf_obj_get_user(const char __user *pathname, int flags);
  
++<<<<<<< HEAD
 +typedef int (*bpf_iter_init_seq_priv_t)(void *private_data);
 +typedef void (*bpf_iter_fini_seq_priv_t)(void *private_data);
 +
 +struct bpf_iter_reg {
 +	const char *target;
 +	const struct seq_operations *seq_ops;
 +	bpf_iter_init_seq_priv_t init_seq_private;
 +	bpf_iter_fini_seq_priv_t fini_seq_private;
 +	u32 seq_priv_size;
++=======
+ #define BPF_ITER_FUNC_PREFIX "bpf_iter_"
+ #define DEFINE_BPF_ITER_FUNC(target, args...)			\
+ 	extern int bpf_iter_ ## target(args);			\
+ 	int __init bpf_iter_ ## target(args) { return 0; }
+ 
+ #define BPF_ITER_CTX_ARG_MAX 2
+ struct bpf_iter_reg {
+ 	const char *target;
+ 	u32 ctx_arg_info_size;
+ 	struct bpf_ctx_arg_aux ctx_arg_info[BPF_ITER_CTX_ARG_MAX];
+ 	const struct bpf_iter_seq_info *seq_info;
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
  };
  
 -struct bpf_iter_meta {
 -	__bpf_md_ptr(struct seq_file *, seq);
 -	u64 session_id;
 -	u64 seq_num;
 -};
 -
 -int bpf_iter_reg_target(const struct bpf_iter_reg *reg_info);
 -void bpf_iter_unreg_target(const struct bpf_iter_reg *reg_info);
 -bool bpf_iter_prog_supported(struct bpf_prog *prog);
 -int bpf_iter_link_attach(const union bpf_attr *attr, struct bpf_prog *prog);
 -int bpf_iter_new_fd(struct bpf_link *link);
 -bool bpf_link_is_iter(struct bpf_link *link);
 -struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop);
 -int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx);
 +int bpf_iter_reg_target(struct bpf_iter_reg *reg_info);
 +void bpf_iter_unreg_target(const char *target);
  
  int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value);
  int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value);
diff --cc kernel/bpf/bpf_iter.c
index 5a8119d17d14,5b2387d6aa1f..000000000000
--- a/kernel/bpf/bpf_iter.c
+++ b/kernel/bpf/bpf_iter.c
@@@ -17,7 -29,217 +17,221 @@@ struct bpf_iter_target_info 
  static struct list_head targets = LIST_HEAD_INIT(targets);
  static DEFINE_MUTEX(targets_mutex);
  
++<<<<<<< HEAD
 +int bpf_iter_reg_target(struct bpf_iter_reg *reg_info)
++=======
+ /* protect bpf_iter_link changes */
+ static DEFINE_MUTEX(link_mutex);
+ 
+ /* incremented on every opened seq_file */
+ static atomic64_t session_id;
+ 
+ static int prepare_seq_file(struct file *file, struct bpf_iter_link *link);
+ 
+ static void bpf_iter_inc_seq_num(struct seq_file *seq)
+ {
+ 	struct bpf_iter_priv_data *iter_priv;
+ 
+ 	iter_priv = container_of(seq->private, struct bpf_iter_priv_data,
+ 				 target_private);
+ 	iter_priv->seq_num++;
+ }
+ 
+ static void bpf_iter_dec_seq_num(struct seq_file *seq)
+ {
+ 	struct bpf_iter_priv_data *iter_priv;
+ 
+ 	iter_priv = container_of(seq->private, struct bpf_iter_priv_data,
+ 				 target_private);
+ 	iter_priv->seq_num--;
+ }
+ 
+ static void bpf_iter_done_stop(struct seq_file *seq)
+ {
+ 	struct bpf_iter_priv_data *iter_priv;
+ 
+ 	iter_priv = container_of(seq->private, struct bpf_iter_priv_data,
+ 				 target_private);
+ 	iter_priv->done_stop = true;
+ }
+ 
+ /* bpf_seq_read, a customized and simpler version for bpf iterator.
+  * no_llseek is assumed for this file.
+  * The following are differences from seq_read():
+  *  . fixed buffer size (PAGE_SIZE)
+  *  . assuming no_llseek
+  *  . stop() may call bpf program, handling potential overflow there
+  */
+ static ssize_t bpf_seq_read(struct file *file, char __user *buf, size_t size,
+ 			    loff_t *ppos)
+ {
+ 	struct seq_file *seq = file->private_data;
+ 	size_t n, offs, copied = 0;
+ 	int err = 0;
+ 	void *p;
+ 
+ 	mutex_lock(&seq->lock);
+ 
+ 	if (!seq->buf) {
+ 		seq->size = PAGE_SIZE;
+ 		seq->buf = kmalloc(seq->size, GFP_KERNEL);
+ 		if (!seq->buf) {
+ 			err = -ENOMEM;
+ 			goto done;
+ 		}
+ 	}
+ 
+ 	if (seq->count) {
+ 		n = min(seq->count, size);
+ 		err = copy_to_user(buf, seq->buf + seq->from, n);
+ 		if (err) {
+ 			err = -EFAULT;
+ 			goto done;
+ 		}
+ 		seq->count -= n;
+ 		seq->from += n;
+ 		copied = n;
+ 		goto done;
+ 	}
+ 
+ 	seq->from = 0;
+ 	p = seq->op->start(seq, &seq->index);
+ 	if (!p)
+ 		goto stop;
+ 	if (IS_ERR(p)) {
+ 		err = PTR_ERR(p);
+ 		seq->op->stop(seq, p);
+ 		seq->count = 0;
+ 		goto done;
+ 	}
+ 
+ 	err = seq->op->show(seq, p);
+ 	if (err > 0) {
+ 		/* object is skipped, decrease seq_num, so next
+ 		 * valid object can reuse the same seq_num.
+ 		 */
+ 		bpf_iter_dec_seq_num(seq);
+ 		seq->count = 0;
+ 	} else if (err < 0 || seq_has_overflowed(seq)) {
+ 		if (!err)
+ 			err = -E2BIG;
+ 		seq->op->stop(seq, p);
+ 		seq->count = 0;
+ 		goto done;
+ 	}
+ 
+ 	while (1) {
+ 		loff_t pos = seq->index;
+ 
+ 		offs = seq->count;
+ 		p = seq->op->next(seq, p, &seq->index);
+ 		if (pos == seq->index) {
+ 			pr_info_ratelimited("buggy seq_file .next function %ps "
+ 				"did not updated position index\n",
+ 				seq->op->next);
+ 			seq->index++;
+ 		}
+ 
+ 		if (IS_ERR_OR_NULL(p))
+ 			break;
+ 
+ 		/* got a valid next object, increase seq_num */
+ 		bpf_iter_inc_seq_num(seq);
+ 
+ 		if (seq->count >= size)
+ 			break;
+ 
+ 		err = seq->op->show(seq, p);
+ 		if (err > 0) {
+ 			bpf_iter_dec_seq_num(seq);
+ 			seq->count = offs;
+ 		} else if (err < 0 || seq_has_overflowed(seq)) {
+ 			seq->count = offs;
+ 			if (offs == 0) {
+ 				if (!err)
+ 					err = -E2BIG;
+ 				seq->op->stop(seq, p);
+ 				goto done;
+ 			}
+ 			break;
+ 		}
+ 	}
+ stop:
+ 	offs = seq->count;
+ 	/* bpf program called if !p */
+ 	seq->op->stop(seq, p);
+ 	if (!p) {
+ 		if (!seq_has_overflowed(seq)) {
+ 			bpf_iter_done_stop(seq);
+ 		} else {
+ 			seq->count = offs;
+ 			if (offs == 0) {
+ 				err = -E2BIG;
+ 				goto done;
+ 			}
+ 		}
+ 	}
+ 
+ 	n = min(seq->count, size);
+ 	err = copy_to_user(buf, seq->buf, n);
+ 	if (err) {
+ 		err = -EFAULT;
+ 		goto done;
+ 	}
+ 	copied = n;
+ 	seq->count -= n;
+ 	seq->from = n;
+ done:
+ 	if (!copied)
+ 		copied = err;
+ 	else
+ 		*ppos += copied;
+ 	mutex_unlock(&seq->lock);
+ 	return copied;
+ }
+ 
+ static int iter_open(struct inode *inode, struct file *file)
+ {
+ 	struct bpf_iter_link *link = inode->i_private;
+ 
+ 	return prepare_seq_file(file, link);
+ }
+ 
+ static int iter_release(struct inode *inode, struct file *file)
+ {
+ 	struct bpf_iter_priv_data *iter_priv;
+ 	struct seq_file *seq;
+ 
+ 	seq = file->private_data;
+ 	if (!seq)
+ 		return 0;
+ 
+ 	iter_priv = container_of(seq->private, struct bpf_iter_priv_data,
+ 				 target_private);
+ 
+ 	if (iter_priv->tinfo->reg_info->seq_info->fini_seq_private)
+ 		iter_priv->tinfo->reg_info->seq_info->fini_seq_private(seq->private);
+ 
+ 	bpf_prog_put(iter_priv->prog);
+ 	seq->private = iter_priv;
+ 
+ 	return seq_release_private(inode, file);
+ }
+ 
+ const struct file_operations bpf_iter_fops = {
+ 	.open		= iter_open,
+ 	.llseek		= no_llseek,
+ 	.read		= bpf_seq_read,
+ 	.release	= iter_release,
+ };
+ 
+ /* The argument reg_info will be cached in bpf_iter_target_info.
+  * The common practice is to declare target reg_info as
+  * a const static variable and passed as an argument to
+  * bpf_iter_reg_target().
+  */
+ int bpf_iter_reg_target(const struct bpf_iter_reg *reg_info)
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
  {
  	struct bpf_iter_target_info *tinfo;
  
@@@ -57,3 -275,265 +271,268 @@@ void bpf_iter_unreg_target(const char *
  
  	WARN_ON(found == false);
  }
++<<<<<<< HEAD
++=======
+ 
+ static void cache_btf_id(struct bpf_iter_target_info *tinfo,
+ 			 struct bpf_prog *prog)
+ {
+ 	tinfo->btf_id = prog->aux->attach_btf_id;
+ }
+ 
+ bool bpf_iter_prog_supported(struct bpf_prog *prog)
+ {
+ 	const char *attach_fname = prog->aux->attach_func_name;
+ 	u32 prog_btf_id = prog->aux->attach_btf_id;
+ 	const char *prefix = BPF_ITER_FUNC_PREFIX;
+ 	struct bpf_iter_target_info *tinfo;
+ 	int prefix_len = strlen(prefix);
+ 	bool supported = false;
+ 
+ 	if (strncmp(attach_fname, prefix, prefix_len))
+ 		return false;
+ 
+ 	mutex_lock(&targets_mutex);
+ 	list_for_each_entry(tinfo, &targets, list) {
+ 		if (tinfo->btf_id && tinfo->btf_id == prog_btf_id) {
+ 			supported = true;
+ 			break;
+ 		}
+ 		if (!strcmp(attach_fname + prefix_len, tinfo->reg_info->target)) {
+ 			cache_btf_id(tinfo, prog);
+ 			supported = true;
+ 			break;
+ 		}
+ 	}
+ 	mutex_unlock(&targets_mutex);
+ 
+ 	if (supported) {
+ 		prog->aux->ctx_arg_info_size = tinfo->reg_info->ctx_arg_info_size;
+ 		prog->aux->ctx_arg_info = tinfo->reg_info->ctx_arg_info;
+ 	}
+ 
+ 	return supported;
+ }
+ 
+ static void bpf_iter_link_release(struct bpf_link *link)
+ {
+ }
+ 
+ static void bpf_iter_link_dealloc(struct bpf_link *link)
+ {
+ 	struct bpf_iter_link *iter_link =
+ 		container_of(link, struct bpf_iter_link, link);
+ 
+ 	kfree(iter_link);
+ }
+ 
+ static int bpf_iter_link_replace(struct bpf_link *link,
+ 				 struct bpf_prog *new_prog,
+ 				 struct bpf_prog *old_prog)
+ {
+ 	int ret = 0;
+ 
+ 	mutex_lock(&link_mutex);
+ 	if (old_prog && link->prog != old_prog) {
+ 		ret = -EPERM;
+ 		goto out_unlock;
+ 	}
+ 
+ 	if (link->prog->type != new_prog->type ||
+ 	    link->prog->expected_attach_type != new_prog->expected_attach_type ||
+ 	    link->prog->aux->attach_btf_id != new_prog->aux->attach_btf_id) {
+ 		ret = -EINVAL;
+ 		goto out_unlock;
+ 	}
+ 
+ 	old_prog = xchg(&link->prog, new_prog);
+ 	bpf_prog_put(old_prog);
+ 
+ out_unlock:
+ 	mutex_unlock(&link_mutex);
+ 	return ret;
+ }
+ 
+ static const struct bpf_link_ops bpf_iter_link_lops = {
+ 	.release = bpf_iter_link_release,
+ 	.dealloc = bpf_iter_link_dealloc,
+ 	.update_prog = bpf_iter_link_replace,
+ };
+ 
+ bool bpf_link_is_iter(struct bpf_link *link)
+ {
+ 	return link->ops == &bpf_iter_link_lops;
+ }
+ 
+ int bpf_iter_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)
+ {
+ 	struct bpf_link_primer link_primer;
+ 	struct bpf_iter_target_info *tinfo;
+ 	struct bpf_iter_link *link;
+ 	bool existed = false;
+ 	u32 prog_btf_id;
+ 	int err;
+ 
+ 	if (attr->link_create.target_fd || attr->link_create.flags)
+ 		return -EINVAL;
+ 
+ 	prog_btf_id = prog->aux->attach_btf_id;
+ 	mutex_lock(&targets_mutex);
+ 	list_for_each_entry(tinfo, &targets, list) {
+ 		if (tinfo->btf_id == prog_btf_id) {
+ 			existed = true;
+ 			break;
+ 		}
+ 	}
+ 	mutex_unlock(&targets_mutex);
+ 	if (!existed)
+ 		return -ENOENT;
+ 
+ 	link = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);
+ 	if (!link)
+ 		return -ENOMEM;
+ 
+ 	bpf_link_init(&link->link, BPF_LINK_TYPE_ITER, &bpf_iter_link_lops, prog);
+ 	link->tinfo = tinfo;
+ 
+ 	err  = bpf_link_prime(&link->link, &link_primer);
+ 	if (err) {
+ 		kfree(link);
+ 		return err;
+ 	}
+ 
+ 	return bpf_link_settle(&link_primer);
+ }
+ 
+ static void init_seq_meta(struct bpf_iter_priv_data *priv_data,
+ 			  struct bpf_iter_target_info *tinfo,
+ 			  struct bpf_prog *prog)
+ {
+ 	priv_data->tinfo = tinfo;
+ 	priv_data->prog = prog;
+ 	priv_data->session_id = atomic64_inc_return(&session_id);
+ 	priv_data->seq_num = 0;
+ 	priv_data->done_stop = false;
+ }
+ 
+ static int prepare_seq_file(struct file *file, struct bpf_iter_link *link)
+ {
+ 	struct bpf_iter_priv_data *priv_data;
+ 	struct bpf_iter_target_info *tinfo;
+ 	struct bpf_prog *prog;
+ 	u32 total_priv_dsize;
+ 	struct seq_file *seq;
+ 	int err = 0;
+ 
+ 	mutex_lock(&link_mutex);
+ 	prog = link->link.prog;
+ 	bpf_prog_inc(prog);
+ 	mutex_unlock(&link_mutex);
+ 
+ 	tinfo = link->tinfo;
+ 	total_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +
+ 			   tinfo->reg_info->seq_info->seq_priv_size;
+ 	priv_data = __seq_open_private(file, tinfo->reg_info->seq_info->seq_ops,
+ 				       total_priv_dsize);
+ 	if (!priv_data) {
+ 		err = -ENOMEM;
+ 		goto release_prog;
+ 	}
+ 
+ 	if (tinfo->reg_info->seq_info->init_seq_private) {
+ 		err = tinfo->reg_info->seq_info->init_seq_private(priv_data->target_private);
+ 		if (err)
+ 			goto release_seq_file;
+ 	}
+ 
+ 	init_seq_meta(priv_data, tinfo, prog);
+ 	seq = file->private_data;
+ 	seq->private = priv_data->target_private;
+ 
+ 	return 0;
+ 
+ release_seq_file:
+ 	seq_release_private(file->f_inode, file);
+ 	file->private_data = NULL;
+ release_prog:
+ 	bpf_prog_put(prog);
+ 	return err;
+ }
+ 
+ int bpf_iter_new_fd(struct bpf_link *link)
+ {
+ 	struct file *file;
+ 	unsigned int flags;
+ 	int err, fd;
+ 
+ 	if (link->ops != &bpf_iter_link_lops)
+ 		return -EINVAL;
+ 
+ 	flags = O_RDONLY | O_CLOEXEC;
+ 	fd = get_unused_fd_flags(flags);
+ 	if (fd < 0)
+ 		return fd;
+ 
+ 	file = anon_inode_getfile("bpf_iter", &bpf_iter_fops, NULL, flags);
+ 	if (IS_ERR(file)) {
+ 		err = PTR_ERR(file);
+ 		goto free_fd;
+ 	}
+ 
+ 	err = prepare_seq_file(file,
+ 			       container_of(link, struct bpf_iter_link, link));
+ 	if (err)
+ 		goto free_file;
+ 
+ 	fd_install(fd, file);
+ 	return fd;
+ 
+ free_file:
+ 	fput(file);
+ free_fd:
+ 	put_unused_fd(fd);
+ 	return err;
+ }
+ 
+ struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)
+ {
+ 	struct bpf_iter_priv_data *iter_priv;
+ 	struct seq_file *seq;
+ 	void *seq_priv;
+ 
+ 	seq = meta->seq;
+ 	if (seq->file->f_op != &bpf_iter_fops)
+ 		return NULL;
+ 
+ 	seq_priv = seq->private;
+ 	iter_priv = container_of(seq_priv, struct bpf_iter_priv_data,
+ 				 target_private);
+ 
+ 	if (in_stop && iter_priv->done_stop)
+ 		return NULL;
+ 
+ 	meta->session_id = iter_priv->session_id;
+ 	meta->seq_num = iter_priv->seq_num;
+ 
+ 	return iter_priv->prog;
+ }
+ 
+ int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)
+ {
+ 	int ret;
+ 
+ 	rcu_read_lock();
+ 	migrate_disable();
+ 	ret = BPF_PROG_RUN(prog, ctx);
+ 	migrate_enable();
+ 	rcu_read_unlock();
+ 
+ 	/* bpf program can only return 0 or 1:
+ 	 *  0 : okay
+ 	 *  1 : retry the same object
+ 	 * The bpf_iter_run_prog() return value
+ 	 * will be seq_ops->show() return value.
+ 	 */
+ 	return ret == 0 ? 0 : -EAGAIN;
+ }
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
diff --cc kernel/bpf/map_iter.c
index 8162e0c00b9f,1a69241fb1e2..000000000000
--- a/kernel/bpf/map_iter.c
+++ b/kernel/bpf/map_iter.c
@@@ -81,17 -78,30 +81,40 @@@ static const struct seq_operations bpf_
  	.show	= bpf_map_seq_show,
  };
  
++<<<<<<< HEAD
++=======
+ BTF_ID_LIST(btf_bpf_map_id)
+ BTF_ID(struct, bpf_map)
+ 
+ static const struct bpf_iter_seq_info bpf_map_seq_info = {
+ 	.seq_ops		= &bpf_map_seq_ops,
+ 	.init_seq_private	= NULL,
+ 	.fini_seq_private	= NULL,
+ 	.seq_priv_size		= sizeof(struct bpf_iter_seq_map_info),
+ };
+ 
+ static struct bpf_iter_reg bpf_map_reg_info = {
+ 	.target			= "bpf_map",
+ 	.ctx_arg_info_size	= 1,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__bpf_map, map),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ 	.seq_info		= &bpf_map_seq_info,
+ };
+ 
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
  static int __init bpf_map_iter_init(void)
  {
 -	bpf_map_reg_info.ctx_arg_info[0].btf_id = *btf_bpf_map_id;
 -	return bpf_iter_reg_target(&bpf_map_reg_info);
 +	struct bpf_iter_reg reg_info = {
 +		.target			= "bpf_map",
 +		.seq_ops		= &bpf_map_seq_ops,
 +		.init_seq_private	= NULL,
 +		.fini_seq_private	= NULL,
 +		.seq_priv_size		= sizeof(struct bpf_iter_seq_map_info),
 +	};
 +
 +	return bpf_iter_reg_target(&reg_info);
  }
  
  late_initcall(bpf_map_iter_init);
diff --cc kernel/bpf/task_iter.c
index 135ad297b957,6d9cd23869bf..000000000000
--- a/kernel/bpf/task_iter.c
+++ b/kernel/bpf/task_iter.c
@@@ -312,24 -315,51 +312,67 @@@ static const struct seq_operations task
  	.show	= task_file_seq_show,
  };
  
++<<<<<<< HEAD
++=======
+ BTF_ID_LIST(btf_task_file_ids)
+ BTF_ID(struct, task_struct)
+ BTF_ID(struct, file)
+ 
+ static const struct bpf_iter_seq_info task_seq_info = {
+ 	.seq_ops		= &task_seq_ops,
+ 	.init_seq_private	= init_seq_pidns,
+ 	.fini_seq_private	= fini_seq_pidns,
+ 	.seq_priv_size		= sizeof(struct bpf_iter_seq_task_info),
+ };
+ 
+ static struct bpf_iter_reg task_reg_info = {
+ 	.target			= "task",
+ 	.ctx_arg_info_size	= 1,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__task, task),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ 	.seq_info		= &task_seq_info,
+ };
+ 
+ static const struct bpf_iter_seq_info task_file_seq_info = {
+ 	.seq_ops		= &task_file_seq_ops,
+ 	.init_seq_private	= init_seq_pidns,
+ 	.fini_seq_private	= fini_seq_pidns,
+ 	.seq_priv_size		= sizeof(struct bpf_iter_seq_task_file_info),
+ };
+ 
+ static struct bpf_iter_reg task_file_reg_info = {
+ 	.target			= "task_file",
+ 	.ctx_arg_info_size	= 2,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__task_file, task),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 		{ offsetof(struct bpf_iter__task_file, file),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ 	.seq_info		= &task_file_seq_info,
+ };
+ 
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
  static int __init task_iter_init(void)
  {
 +	struct bpf_iter_reg task_file_reg_info = {
 +		.target			= "task_file",
 +		.seq_ops		= &task_file_seq_ops,
 +		.init_seq_private	= init_seq_pidns,
 +		.fini_seq_private	= fini_seq_pidns,
 +		.seq_priv_size		= sizeof(struct bpf_iter_seq_task_file_info),
 +	};
 +	struct bpf_iter_reg task_reg_info = {
 +		.target			= "task",
 +		.seq_ops		= &task_seq_ops,
 +		.init_seq_private	= init_seq_pidns,
 +		.fini_seq_private	= fini_seq_pidns,
 +		.seq_priv_size		= sizeof(struct bpf_iter_seq_task_info),
 +	};
  	int ret;
  
 -	task_reg_info.ctx_arg_info[0].btf_id = btf_task_file_ids[0];
  	ret = bpf_iter_reg_target(&task_reg_info);
  	if (ret)
  		return ret;
diff --cc net/ipv4/tcp_ipv4.c
index c27942535c70,cb288fdcf2ca..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -2862,8 -2947,7 +2862,12 @@@ static void bpf_iter_fini_tcp(void *pri
  	bpf_iter_fini_seq_net(priv_data);
  }
  
++<<<<<<< HEAD
 +static const struct bpf_iter_reg tcp_reg_info = {
 +	.target			= "tcp",
++=======
+ static const struct bpf_iter_seq_info tcp_seq_info = {
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
  	.seq_ops		= &bpf_iter_tcp_seq_ops,
  	.init_seq_private	= bpf_iter_init_tcp,
  	.fini_seq_private	= bpf_iter_fini_tcp,
diff --cc net/ipv4/udp.c
index 98e5d6011292,1bc50ec2caef..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -3129,8 -3208,7 +3129,12 @@@ static void bpf_iter_fini_udp(void *pri
  	bpf_iter_fini_seq_net(priv_data);
  }
  
++<<<<<<< HEAD
 +static const struct bpf_iter_reg udp_reg_info = {
 +	.target			= "udp",
++=======
+ static const struct bpf_iter_seq_info udp_seq_info = {
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
  	.seq_ops		= &bpf_iter_udp_seq_ops,
  	.init_seq_private	= bpf_iter_init_udp,
  	.fini_seq_private	= bpf_iter_fini_udp,
diff --cc net/ipv6/route.c
index 8d3f84864403,8bfc57b0802a..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -5669,6 -6420,43 +5669,46 @@@ void __init ip6_route_init_special_entr
    #endif
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_BUILTIN(CONFIG_IPV6)
+ #if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)
+ DEFINE_BPF_ITER_FUNC(ipv6_route, struct bpf_iter_meta *meta, struct fib6_info *rt)
+ 
+ BTF_ID_LIST(btf_fib6_info_id)
+ BTF_ID(struct, fib6_info)
+ 
+ static const struct bpf_iter_seq_info ipv6_route_seq_info = {
+ 	.seq_ops		= &ipv6_route_seq_ops,
+ 	.init_seq_private	= bpf_iter_init_seq_net,
+ 	.fini_seq_private	= bpf_iter_fini_seq_net,
+ 	.seq_priv_size		= sizeof(struct ipv6_route_iter),
+ };
+ 
+ static struct bpf_iter_reg ipv6_route_reg_info = {
+ 	.target			= "ipv6_route",
+ 	.ctx_arg_info_size	= 1,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__ipv6_route, rt),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ 	.seq_info		= &ipv6_route_seq_info,
+ };
+ 
+ static int __init bpf_iter_register(void)
+ {
+ 	ipv6_route_reg_info.ctx_arg_info[0].btf_id = *btf_fib6_info_id;
+ 	return bpf_iter_reg_target(&ipv6_route_reg_info);
+ }
+ 
+ static void bpf_iter_unregister(void)
+ {
+ 	bpf_iter_unreg_target(&ipv6_route_reg_info);
+ }
+ #endif
+ #endif
+ 
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
  int __init ip6_route_init(void)
  {
  	int ret;
diff --cc net/netlink/af_netlink.c
index 9b0e55efc3d6,b5f30d7d30d0..000000000000
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@@ -2745,6 -2803,34 +2745,37 @@@ static const struct rhashtable_params n
  	.automatic_shrinking = true,
  };
  
++<<<<<<< HEAD
++=======
+ #if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)
+ BTF_ID_LIST(btf_netlink_sock_id)
+ BTF_ID(struct, netlink_sock)
+ 
+ static const struct bpf_iter_seq_info netlink_seq_info = {
+ 	.seq_ops		= &netlink_seq_ops,
+ 	.init_seq_private	= bpf_iter_init_seq_net,
+ 	.fini_seq_private	= bpf_iter_fini_seq_net,
+ 	.seq_priv_size		= sizeof(struct nl_seq_iter),
+ };
+ 
+ static struct bpf_iter_reg netlink_reg_info = {
+ 	.target			= "netlink",
+ 	.ctx_arg_info_size	= 1,
+ 	.ctx_arg_info		= {
+ 		{ offsetof(struct bpf_iter__netlink, sk),
+ 		  PTR_TO_BTF_ID_OR_NULL },
+ 	},
+ 	.seq_info		= &netlink_seq_info,
+ };
+ 
+ static int __init bpf_iter_register(void)
+ {
+ 	netlink_reg_info.ctx_arg_info[0].btf_id = *btf_netlink_sock_id;
+ 	return bpf_iter_reg_target(&netlink_reg_info);
+ }
+ #endif
+ 
++>>>>>>> 14fc6bd6b79c (bpf: Refactor bpf_iter_reg to have separate seq_info member)
  static int __init netlink_proto_init(void)
  {
  	int i;
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/bpf_iter.c
* Unmerged path kernel/bpf/map_iter.c
diff --git a/kernel/bpf/prog_iter.c b/kernel/bpf/prog_iter.c
index 6541b577d69f..53a73c841c13 100644
--- a/kernel/bpf/prog_iter.c
+++ b/kernel/bpf/prog_iter.c
@@ -81,17 +81,21 @@ static const struct seq_operations bpf_prog_seq_ops = {
 BTF_ID_LIST(btf_bpf_prog_id)
 BTF_ID(struct, bpf_prog)
 
-static struct bpf_iter_reg bpf_prog_reg_info = {
-	.target			= "bpf_prog",
+static const struct bpf_iter_seq_info bpf_prog_seq_info = {
 	.seq_ops		= &bpf_prog_seq_ops,
 	.init_seq_private	= NULL,
 	.fini_seq_private	= NULL,
 	.seq_priv_size		= sizeof(struct bpf_iter_seq_prog_info),
+};
+
+static struct bpf_iter_reg bpf_prog_reg_info = {
+	.target			= "bpf_prog",
 	.ctx_arg_info_size	= 1,
 	.ctx_arg_info		= {
 		{ offsetof(struct bpf_iter__bpf_prog, prog),
 		  PTR_TO_BTF_ID_OR_NULL },
 	},
+	.seq_info		= &bpf_prog_seq_info,
 };
 
 static int __init bpf_prog_iter_init(void)
* Unmerged path kernel/bpf/task_iter.c
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv4/udp.c
* Unmerged path net/ipv6/route.c
* Unmerged path net/netlink/af_netlink.c
