KVM: x86: announce KVM_FEATURE_ASYNC_PF_INT

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-294.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 72de5fa4c16195827252b961ba44028a39dfeaff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-294.el8/72de5fa4.failed

Introduce new capability to indicate that KVM supports interrupt based
delivery of 'page ready' APF events. This includes support for both
MSR_KVM_ASYNC_PF_INT and MSR_KVM_ASYNC_PF_ACK.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20200525144125.143875-8-vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 72de5fa4c16195827252b961ba44028a39dfeaff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virt/kvm/msr.rst
diff --cc Documentation/virt/kvm/msr.rst
index 33892036672d,e37a14c323d2..000000000000
--- a/Documentation/virt/kvm/msr.rst
+++ b/Documentation/virt/kvm/msr.rst
@@@ -190,35 -190,65 +190,91 @@@ MSR_KVM_ASYNC_PF_EN
  	0x4b564d02
  
  data:
 -	Asynchronous page fault (APF) control MSR.
 -
 -	Bits 63-6 hold 64-byte aligned physical address of a 64 byte memory area
 -	which must be in guest RAM and must be zeroed. This memory is expected
 -	to hold a copy of the following structure::
 -
 +	Bits 63-6 hold 64-byte aligned physical address of a
 +	64 byte memory area which must be in guest RAM and must be
 +	zeroed. Bits 5-3 are reserved and should be zero. Bit 0 is 1
 +	when asynchronous page faults are enabled on the vcpu 0 when
 +	disabled. Bit 1 is 1 if asynchronous page faults can be injected
 +	when vcpu is in cpl == 0. Bit 2 is 1 if asynchronous page faults
 +	are delivered to L1 as #PF vmexits.  Bit 2 can be set only if
 +	KVM_FEATURE_ASYNC_PF_VMEXIT is present in CPUID.
 +
 +	First 4 byte of 64 byte memory location will be written to by
 +	the hypervisor at the time of asynchronous page fault (APF)
 +	injection to indicate type of asynchronous page fault. Value
 +	of 1 means that the page referred to by the page fault is not
 +	present. Value 2 means that the page is now available. Disabling
 +	interrupt inhibits APFs. Guest must not enable interrupt
 +	before the reason is read, or it may be overwritten by another
 +	APF. Since APF uses the same exception vector as regular page
 +	fault guest must reset the reason to 0 before it does
 +	something that can generate normal page fault.  If during page
 +	fault APF reason is 0 it means that this is regular page
 +	fault.
 +
++<<<<<<< HEAD
 +	During delivery of type 1 APF cr2 contains a token that will
 +	be used to notify a guest when missing page becomes
 +	available. When page becomes available type 2 APF is sent with
 +	cr2 set to the token associated with the page. There is special
 +	kind of token 0xffffffff which tells vcpu that it should wake
 +	up all processes waiting for APFs and no individual type 2 APFs
 +	will be sent.
++=======
+ 	  struct kvm_vcpu_pv_apf_data {
+ 		/* Used for 'page not present' events delivered via #PF */
+ 		__u32 flags;
+ 
+ 		/* Used for 'page ready' events delivered via interrupt notification */
+ 		__u32 token;
+ 
+ 		__u8 pad[56];
+ 		__u32 enabled;
+ 	  };
+ 
+ 	Bits 5-4 of the MSR are reserved and should be zero. Bit 0 is set to 1
+ 	when asynchronous page faults are enabled on the vcpu, 0 when disabled.
+ 	Bit 1 is 1 if asynchronous page faults can be injected when vcpu is in
+ 	cpl == 0. Bit 2 is 1 if asynchronous page faults are delivered to L1 as
+ 	#PF vmexits.  Bit 2 can be set only if KVM_FEATURE_ASYNC_PF_VMEXIT is
+ 	present in CPUID. Bit 3 enables interrupt based delivery of 'page ready'
+ 	events. Bit 3 can only be set if KVM_FEATURE_ASYNC_PF_INT is present in
+ 	CPUID.
+ 
+ 	'Page not present' events are currently always delivered as synthetic
+ 	#PF exception. During delivery of these events APF CR2 register contains
+ 	a token that will be used to notify the guest when missing page becomes
+ 	available. Also, to make it possible to distinguish between real #PF and
+ 	APF, first 4 bytes of 64 byte memory location ('flags') will be written
+ 	to by the hypervisor at the time of injection. Only first bit of 'flags'
+ 	is currently supported, when set, it indicates that the guest is dealing
+ 	with asynchronous 'page not present' event. If during a page fault APF
+ 	'flags' is '0' it means that this is regular page fault. Guest is
+ 	supposed to clear 'flags' when it is done handling #PF exception so the
+ 	next event can be delivered.
+ 
+ 	Note, since APF 'page not present' events use the same exception vector
+ 	as regular page fault, guest must reset 'flags' to '0' before it does
+ 	something that can generate normal page fault.
+ 
+ 	Bytes 5-7 of 64 byte memory location ('token') will be written to by the
+ 	hypervisor at the time of APF 'page ready' event injection. The content
+ 	of these bytes is a token which was previously delivered as 'page not
+ 	present' event. The event indicates the page in now available. Guest is
+ 	supposed to write '0' to 'token' when it is done handling 'page ready'
+ 	event and to write 1' to MSR_KVM_ASYNC_PF_ACK after clearing the location;
+ 	writing to the MSR forces KVM to re-scan its queue and deliver the next
+ 	pending notification.
+ 
+ 	Note, MSR_KVM_ASYNC_PF_INT MSR specifying the interrupt vector for 'page
+ 	ready' APF delivery needs to be written to before enabling APF mechanism
+ 	in MSR_KVM_ASYNC_PF_EN or interrupt #0 can get injected. The MSR is
+ 	available if KVM_FEATURE_ASYNC_PF_INT is present in CPUID.
+ 
+ 	Note, previously, 'page ready' events were delivered via the same #PF
+ 	exception as 'page not present' events but this is now deprecated. If
+ 	bit 3 (interrupt based delivery) is not set APF events are not delivered.
++>>>>>>> 72de5fa4c161 (KVM: x86: announce KVM_FEATURE_ASYNC_PF_INT)
  
  	If APF is disabled while there are outstanding APFs, they will
  	not be delivered.
@@@ -319,3 -350,29 +375,32 @@@ data
  
  	KVM guests can request the host not to poll on HLT, for example if
  	they are performing polling themselves.
++<<<<<<< HEAD
++=======
+ 
+ MSR_KVM_ASYNC_PF_INT:
+ 	0x4b564d06
+ 
+ data:
+ 	Second asynchronous page fault (APF) control MSR.
+ 
+ 	Bits 0-7: APIC vector for delivery of 'page ready' APF events.
+ 	Bits 8-63: Reserved
+ 
+ 	Interrupt vector for asynchnonous 'page ready' notifications delivery.
+ 	The vector has to be set up before asynchronous page fault mechanism
+ 	is enabled in MSR_KVM_ASYNC_PF_EN.  The MSR is only available if
+ 	KVM_FEATURE_ASYNC_PF_INT is present in CPUID.
+ 
+ MSR_KVM_ASYNC_PF_ACK:
+ 	0x4b564d07
+ 
+ data:
+ 	Asynchronous page fault (APF) acknowledgment.
+ 
+ 	When the guest is done processing 'page ready' APF event and 'token'
+ 	field in 'struct kvm_vcpu_pv_apf_data' is cleared it is supposed to
+ 	write '1' to bit 0 of the MSR, this causes the host to re-scan its queue
+ 	and check if there are more notifications pending. The MSR is available
+ 	if KVM_FEATURE_ASYNC_PF_INT is present in CPUID.
++>>>>>>> 72de5fa4c161 (KVM: x86: announce KVM_FEATURE_ASYNC_PF_INT)
diff --git a/Documentation/virt/kvm/cpuid.rst b/Documentation/virt/kvm/cpuid.rst
index f721c89327ec..a7dff9186bed 100644
--- a/Documentation/virt/kvm/cpuid.rst
+++ b/Documentation/virt/kvm/cpuid.rst
@@ -86,6 +86,12 @@ KVM_FEATURE_PV_SCHED_YIELD        13          guest checks this feature bit
                                               before using paravirtualized
                                               sched yield.
 
+KVM_FEATURE_ASYNC_PF_INT          14          guest checks this feature bit
+                                              before using the second async
+                                              pf control msr 0x4b564d06 and
+                                              async pf acknowledgment msr
+                                              0x4b564d07.
+
 KVM_FEATURE_CLOCSOURCE_STABLE_BIT 24          host will warn if no guest-side
                                               per-cpu warps are expeced in
                                               kvmclock
* Unmerged path Documentation/virt/kvm/msr.rst
diff --git a/arch/x86/include/uapi/asm/kvm_para.h b/arch/x86/include/uapi/asm/kvm_para.h
index 2a8e0b6b9805..78a83a2ce178 100644
--- a/arch/x86/include/uapi/asm/kvm_para.h
+++ b/arch/x86/include/uapi/asm/kvm_para.h
@@ -31,6 +31,7 @@
 #define KVM_FEATURE_PV_SEND_IPI	11
 #define KVM_FEATURE_POLL_CONTROL	12
 #define KVM_FEATURE_PV_SCHED_YIELD	13
+#define KVM_FEATURE_ASYNC_PF_INT	14
 
 #define KVM_HINTS_REALTIME      0
 
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index d2ce3812633b..6afbbe96dfa0 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -715,7 +715,8 @@ static inline int __do_cpuid_func(struct kvm_cpuid_array *array, u32 function)
 			     (1 << KVM_FEATURE_ASYNC_PF_VMEXIT) |
 			     (1 << KVM_FEATURE_PV_SEND_IPI) |
 			     (1 << KVM_FEATURE_POLL_CONTROL) |
-			     (1 << KVM_FEATURE_PV_SCHED_YIELD);
+			     (1 << KVM_FEATURE_PV_SCHED_YIELD) |
+			     (1 << KVM_FEATURE_ASYNC_PF_INT);
 
 		if (sched_info_on())
 			entry->eax |= (1 << KVM_FEATURE_STEAL_TIME);
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index acc910a907d8..35df805d637e 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -3401,6 +3401,7 @@ int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
 	case KVM_CAP_X86_ROBUST_SINGLESTEP:
 	case KVM_CAP_XSAVE:
 	case KVM_CAP_ASYNC_PF:
+	case KVM_CAP_ASYNC_PF_INT:
 	case KVM_CAP_GET_TSC_KHZ:
 	case KVM_CAP_KVMCLOCK_CTRL:
 	case KVM_CAP_READONLY_MEM:
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index a18f96c6ee48..b8157fdae345 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -1020,6 +1020,7 @@ struct kvm_ppc_resize_hpt {
 #define KVM_CAP_S390_PROTECTED 180
 #define KVM_CAP_PPC_SECURE_GUEST 181
 #define KVM_CAP_HALT_POLL 182
+#define KVM_CAP_ASYNC_PF_INT 183
 
 #ifdef KVM_CAP_IRQ_ROUTING
 
