overflow: add DEFINE_FLEX() for on-stack allocs

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.37.1.el9_4
commit-author Przemek Kitszel <przemyslaw.kitszel@intel.com>
commit 26dd68d293fd1c5ac966fb5dd5f6d89de322a541
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.37.1.el9_4/26dd68d2.failed

Add DEFINE_FLEX() macro for on-stack allocations of structs with
flexible array member.

Expose __struct_size() macro outside of fortify-string.h, as it could be
used to read size of structs allocated by DEFINE_FLEX().
Move __member_size() alongside it.
-Kees

Using underlying array for on-stack storage lets us to declare
known-at-compile-time structures without kzalloc().

Actual usage for ice driver is in following patches of the series.

Missing __has_builtin() workaround is moved up to serve also assembly
compilation with m68k-linux-gcc, see [1].
Error was (note the .S file extension):
In file included from ../include/linux/linkage.h:5,
                 from ../arch/m68k/fpsp040/skeleton.S:40:
../include/linux/compiler_types.h:331:5: warning: "__has_builtin" is not defined, evaluates to 0 [-Wundef]
  331 | #if __has_builtin(__builtin_dynamic_object_size)
      |     ^~~~~~~~~~~~~
../include/linux/compiler_types.h:331:18: error: missing binary operator before token "("
  331 | #if __has_builtin(__builtin_dynamic_object_size)
      |                  ^

[1] https://lore.kernel.org/netdev/202308112122.OuF0YZqL-lkp@intel.com/
Co-developed-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
Link: https://lore.kernel.org/r/20230912115937.1645707-2-przemyslaw.kitszel@intel.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 26dd68d293fd1c5ac966fb5dd5f6d89de322a541)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compiler_types.h
#	include/linux/fortify-string.h
#	include/linux/overflow.h
diff --cc include/linux/compiler_types.h
index 017132b312dc,6f1ca49306d2..000000000000
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@@ -2,10 -2,23 +2,19 @@@
  #ifndef __LINUX_COMPILER_TYPES_H
  #define __LINUX_COMPILER_TYPES_H
  
+ /*
+  * __has_builtin is supported on gcc >= 10, clang >= 3 and icc >= 21.
+  * In the meantime, to support gcc < 10, we implement __has_builtin
+  * by hand.
+  */
+ #ifndef __has_builtin
+ #define __has_builtin(x) (0)
+ #endif
+ 
  #ifndef __ASSEMBLY__
  
 -/*
 - * Skipped when running bindgen due to a libclang issue;
 - * see https://github.com/rust-lang/rust-bindgen/issues/2244.
 - */
  #if defined(CONFIG_DEBUG_INFO_BTF) && defined(CONFIG_PAHOLE_HAS_BTF_TAG) && \
 -	__has_attribute(btf_type_tag) && !defined(__BINDGEN__)
 +	__has_attribute(btf_type_tag)
  # define BTF_TYPE_TAG(value) __attribute__((btf_type_tag(#value)))
  #else
  # define BTF_TYPE_TAG(value) /* nothing */
@@@ -72,15 -88,59 +81,71 @@@ static inline void __chk_io_ptr(const v
  /* Attributes */
  #include <linux/compiler_attributes.h>
  
++<<<<<<< HEAD
 +/* Builtins */
 +
 +/*
 + * __has_builtin is supported on gcc >= 10, clang >= 3 and icc >= 21.
 + * In the meantime, to support gcc < 10, we implement __has_builtin
 + * by hand.
 + */
 +#ifndef __has_builtin
 +#define __has_builtin(x) (0)
++=======
+ #if CONFIG_FUNCTION_ALIGNMENT > 0
+ #define __function_aligned		__aligned(CONFIG_FUNCTION_ALIGNMENT)
+ #else
+ #define __function_aligned
+ #endif
+ 
+ /*
+  *   gcc: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-cold-function-attribute
+  *   gcc: https://gcc.gnu.org/onlinedocs/gcc/Label-Attributes.html#index-cold-label-attribute
+  *
+  * When -falign-functions=N is in use, we must avoid the cold attribute as
+  * contemporary versions of GCC drop the alignment for cold functions. Worse,
+  * GCC can implicitly mark callees of cold functions as cold themselves, so
+  * it's not sufficient to add __function_aligned here as that will not ensure
+  * that callees are correctly aligned.
+  *
+  * See:
+  *
+  *   https://lore.kernel.org/lkml/Y77%2FqVgvaJidFpYt@FVFF77S0Q05N
+  *   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88345#c9
+  */
+ #if !defined(CONFIG_CC_IS_GCC) || (CONFIG_FUNCTION_ALIGNMENT == 0)
+ #define __cold				__attribute__((__cold__))
+ #else
+ #define __cold
+ #endif
+ 
+ /*
+  * On x86-64 and arm64 targets, __preserve_most changes the calling convention
+  * of a function to make the code in the caller as unintrusive as possible. This
+  * convention behaves identically to the C calling convention on how arguments
+  * and return values are passed, but uses a different set of caller- and callee-
+  * saved registers.
+  *
+  * The purpose is to alleviates the burden of saving and recovering a large
+  * register set before and after the call in the caller.  This is beneficial for
+  * rarely taken slow paths, such as error-reporting functions that may be called
+  * from hot paths.
+  *
+  * Note: This may conflict with instrumentation inserted on function entry which
+  * does not use __preserve_most or equivalent convention (if in assembly). Since
+  * function tracing assumes the normal C calling convention, where the attribute
+  * is supported, __preserve_most implies notrace.  It is recommended to restrict
+  * use of the attribute to functions that should or already disable tracing.
+  *
+  * Optional: not supported by gcc.
+  *
+  * clang: https://clang.llvm.org/docs/AttributeReference.html#preserve-most
+  */
+ #if __has_attribute(__preserve_most__) && (defined(CONFIG_X86_64) || defined(CONFIG_ARM64))
+ # define __preserve_most notrace __attribute__((__preserve_most__))
+ #else
+ # define __preserve_most
++>>>>>>> 26dd68d293fd (overflow: add DEFINE_FLEX() for on-stack allocs)
  #endif
  
  /* Compiler specific macros. */
diff --cc include/linux/fortify-string.h
index 6b49ed68f741,1e7711185ec6..000000000000
--- a/include/linux/fortify-string.h
+++ b/include/linux/fortify-string.h
@@@ -88,8 -90,18 +88,23 @@@ extern char *__underlying_strncpy(char 
   * size, rather than struct size), but there remain some stragglers using
   * type 0 that will be converted in the future.
   */
++<<<<<<< HEAD
 +#define POS	__pass_object_size(1)
 +#define POS0	__pass_object_size(0)
++=======
+ #if __has_builtin(__builtin_dynamic_object_size)
+ #define POS			__pass_dynamic_object_size(1)
+ #define POS0			__pass_dynamic_object_size(0)
+ #else
+ #define POS			__pass_object_size(1)
+ #define POS0			__pass_object_size(0)
+ #endif
+ 
+ #define __compiletime_lessthan(bounds, length)	(	\
+ 	__builtin_constant_p((bounds) < (length)) &&	\
+ 	(bounds) < (length)				\
+ )
++>>>>>>> 26dd68d293fd (overflow: add DEFINE_FLEX() for on-stack allocs)
  
  /**
   * strncpy - Copy a string to memory with non-guaranteed NUL padding
diff --cc include/linux/overflow.h
index 2d6a8cf92c6a,7b5cf4a5cd19..000000000000
--- a/include/linux/overflow.h
+++ b/include/linux/overflow.h
@@@ -404,4 -293,55 +404,58 @@@ static inline size_t __must_check size_
  		sizeof(*(p)) + flex_array_size(p, member, count),	\
  		size_add(sizeof(*(p)), flex_array_size(p, member, count)))
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct_size_t() - Calculate size of structure with trailing flexible array
+  * @type: structure type name.
+  * @member: Name of the array member.
+  * @count: Number of elements in the array.
+  *
+  * Calculates size of memory needed for structure @type followed by an
+  * array of @count number of @member elements. Prefer using struct_size()
+  * when possible instead, to keep calculations associated with a specific
+  * instance variable of type @type.
+  *
+  * Return: number of bytes needed or SIZE_MAX on overflow.
+  */
+ #define struct_size_t(type, member, count)					\
+ 	struct_size((type *)NULL, member, count)
+ 
+ /**
+  * _DEFINE_FLEX() - helper macro for DEFINE_FLEX() family.
+  * Enables caller macro to pass (different) initializer.
+  *
+  * @type: structure type name, including "struct" keyword.
+  * @name: Name for a variable to define.
+  * @member: Name of the array member.
+  * @count: Number of elements in the array; must be compile-time const.
+  * @initializer: initializer expression (could be empty for no init).
+  */
+ #define _DEFINE_FLEX(type, name, member, count, initializer)			\
+ 	_Static_assert(__builtin_constant_p(count),				\
+ 		       "onstack flex array members require compile-time const count"); \
+ 	union {									\
+ 		u8 bytes[struct_size_t(type, member, count)];			\
+ 		type obj;							\
+ 	} name##_u initializer;							\
+ 	type *name = (type *)&name##_u
+ 
+ /**
+  * DEFINE_FLEX() - Define an on-stack instance of structure with a trailing
+  * flexible array member.
+  *
+  * @type: structure type name, including "struct" keyword.
+  * @name: Name for a variable to define.
+  * @member: Name of the array member.
+  * @count: Number of elements in the array; must be compile-time const.
+  *
+  * Define a zeroed, on-stack, instance of @type structure with a trailing
+  * flexible array member.
+  * Use __struct_size(@name) to get compile-time size of it afterwards.
+  */
+ #define DEFINE_FLEX(type, name, member, count)			\
+ 	_DEFINE_FLEX(type, name, member, count, = {})
+ 
++>>>>>>> 26dd68d293fd (overflow: add DEFINE_FLEX() for on-stack allocs)
  #endif /* __LINUX_OVERFLOW_H */
* Unmerged path include/linux/compiler_types.h
* Unmerged path include/linux/fortify-string.h
* Unmerged path include/linux/overflow.h
