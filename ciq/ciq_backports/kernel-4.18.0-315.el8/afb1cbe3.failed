LSM: Infrastructure management of the inode security

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Casey Schaufler <casey@schaufler-ca.com>
commit afb1cbe37440c7f38b9cf46fc331cc9dfd5cce21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/afb1cbe3.failed

Move management of the inode->i_security blob out
of the individual security modules and into the security
infrastructure. Instead of allocating the blobs from within
the modules the modules tell the infrastructure how much
space is required, and the space is allocated there.

	Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
[kees: adjusted for ordered init series]
	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit afb1cbe37440c7f38b9cf46fc331cc9dfd5cce21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/lsm_hooks.h
#	security/security.c
#	security/selinux/hooks.c
#	security/smack/smack.h
#	security/smack/smack_lsm.c
diff --cc include/linux/lsm_hooks.h
index 84380f3a8dab,1c798e842de2..000000000000
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@@ -1479,10 -2028,13 +1479,18 @@@ struct security_hook_list 
  } __randomize_layout;
  
  /*
 - * Security blob size or offset data.
 + * LSM_RET_VOID is used as the default value in LSM_HOOK definitions for void
 + * LSM hooks (in include/linux/lsm_hook_defs.h).
   */
++<<<<<<< HEAD
 +#define LSM_RET_VOID ((void) 0)
++=======
+ struct lsm_blob_sizes {
+ 	int	lbs_cred;
+ 	int	lbs_file;
+ 	int	lbs_inode;
+ };
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  
  /*
   * Initializing a security_hook_list structure takes
@@@ -1552,4 -2105,10 +1560,13 @@@ static inline void security_delete_hook
  #define __lsm_ro_after_init	__ro_after_init
  #endif /* CONFIG_SECURITY_WRITABLE_HOOKS */
  
++<<<<<<< HEAD
++=======
+ extern int lsm_inode_alloc(struct inode *inode);
+ 
+ #ifdef CONFIG_SECURITY
+ void __init lsm_early_cred(struct cred *cred);
+ #endif
+ 
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  #endif /* ! __LINUX_LSM_HOOKS_H */
diff --cc security/security.c
index 8555aece1bce,4989fb65e662..000000000000
--- a/security/security.c
+++ b/security/security.c
@@@ -41,9 -38,14 +41,16 @@@
  #define LSM_COUNT (__end_lsm_info - __start_lsm_info)
  
  struct security_hook_heads security_hook_heads __lsm_ro_after_init;
++<<<<<<< HEAD
 +static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);
++=======
+ static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
+ 
+ static struct kmem_cache *lsm_file_cache;
+ static struct kmem_cache *lsm_inode_cache;
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  
  char *lsm_names;
 -static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;
 -
  /* Boot-time LSM user choice */
  static __initdata const char *chosen_lsm_order;
  static __initdata const char *chosen_major_lsm;
@@@ -142,6 -144,33 +149,36 @@@ static bool __init lsm_allowed(struct l
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static void __init lsm_set_blob_size(int *need, int *lbs)
+ {
+ 	int offset;
+ 
+ 	if (*need > 0) {
+ 		offset = *lbs;
+ 		*lbs += *need;
+ 		*need = offset;
+ 	}
+ }
+ 
+ static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
+ {
+ 	if (!needed)
+ 		return;
+ 
+ 	lsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);
+ 	lsm_set_blob_size(&needed->lbs_file, &blob_sizes.lbs_file);
+ 	/*
+ 	 * The inode blob gets an rcu_head in addition to
+ 	 * what the modules might need.
+ 	 */
+ 	if (needed->lbs_inode && blob_sizes.lbs_inode == 0)
+ 		blob_sizes.lbs_inode = sizeof(struct rcu_head);
+ 	lsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);
+ }
+ 
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  /* Prepare LSM for initialization. */
  static void __init prepare_lsm(struct lsm_info *lsm)
  {
@@@ -262,6 -289,22 +299,25 @@@ static void __init ordered_lsm_init(voi
  	for (lsm = ordered_lsms; *lsm; lsm++)
  		prepare_lsm(*lsm);
  
++<<<<<<< HEAD
++=======
+ 	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
+ 	init_debug("file blob size     = %d\n", blob_sizes.lbs_file);
+ 	init_debug("inode blob size    = %d\n", blob_sizes.lbs_inode);
+ 
+ 	/*
+ 	 * Create any kmem_caches needed for blobs
+ 	 */
+ 	if (blob_sizes.lbs_file)
+ 		lsm_file_cache = kmem_cache_create("lsm_file_cache",
+ 						   blob_sizes.lbs_file, 0,
+ 						   SLAB_PANIC, NULL);
+ 	if (blob_sizes.lbs_inode)
+ 		lsm_inode_cache = kmem_cache_create("lsm_inode_cache",
+ 						    blob_sizes.lbs_inode, 0,
+ 						    SLAB_PANIC, NULL);
+ 
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  	for (lsm = ordered_lsms; *lsm; lsm++)
  		initialize_lsm(*lsm);
  
@@@ -371,46 -414,107 +427,67 @@@ void __init security_add_hooks(struct s
  		panic("%s - Cannot get early memory.\n", __func__);
  }
  
 -int call_lsm_notifier(enum lsm_event event, void *data)
 -{
 -	return atomic_notifier_call_chain(&lsm_notifier_chain, event, data);
 -}
 -EXPORT_SYMBOL(call_lsm_notifier);
 -
 -int register_lsm_notifier(struct notifier_block *nb)
 -{
 -	return atomic_notifier_chain_register(&lsm_notifier_chain, nb);
 -}
 -EXPORT_SYMBOL(register_lsm_notifier);
 -
 -int unregister_lsm_notifier(struct notifier_block *nb)
 +int call_blocking_lsm_notifier(enum lsm_event event, void *data)
  {
 -	return atomic_notifier_chain_unregister(&lsm_notifier_chain, nb);
 +	return blocking_notifier_call_chain(&blocking_lsm_notifier_chain,
 +					    event, data);
  }
 -EXPORT_SYMBOL(unregister_lsm_notifier);
 +EXPORT_SYMBOL(call_blocking_lsm_notifier);
  
 -/**
 - * lsm_cred_alloc - allocate a composite cred blob
 - * @cred: the cred that needs a blob
 - * @gfp: allocation type
 - *
 - * Allocate the cred blob for all the modules
 - *
 - * Returns 0, or -ENOMEM if memory can't be allocated.
 - */
 -static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)
 +int register_blocking_lsm_notifier(struct notifier_block *nb)
  {
 -	if (blob_sizes.lbs_cred == 0) {
 -		cred->security = NULL;
 -		return 0;
 -	}
 -
 -	cred->security = kzalloc(blob_sizes.lbs_cred, gfp);
 -	if (cred->security == NULL)
 -		return -ENOMEM;
 -	return 0;
 +	return blocking_notifier_chain_register(&blocking_lsm_notifier_chain,
 +						nb);
  }
 +EXPORT_SYMBOL(register_blocking_lsm_notifier);
  
 -/**
 - * lsm_early_cred - during initialization allocate a composite cred blob
 - * @cred: the cred that needs a blob
 - *
 - * Allocate the cred blob for all the modules if it's not already there
 - */
 -void __init lsm_early_cred(struct cred *cred)
 +int unregister_blocking_lsm_notifier(struct notifier_block *nb)
  {
 -	int rc;
 -
 -	if (cred == NULL)
 -		panic("%s: NULL cred.\n", __func__);
 -	if (cred->security != NULL)
 -		return;
 -	rc = lsm_cred_alloc(cred, GFP_KERNEL);
 -	if (rc)
 -		panic("%s: Early cred alloc failed.\n", __func__);
 +	return blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,
 +						  nb);
  }
 +EXPORT_SYMBOL(unregister_blocking_lsm_notifier);
  
 -/**
 - * lsm_file_alloc - allocate a composite file blob
 - * @file: the file that needs a blob
 +/*
 + * The default value of the LSM hook is defined in linux/lsm_hook_defs.h and
 + * can be accessed with:
   *
 - * Allocate the file blob for all the modules
 + *	LSM_RET_DEFAULT(<hook_name>)
   *
 - * Returns 0, or -ENOMEM if memory can't be allocated.
 + * The macros below define static constants for the default value of each
 + * LSM hook.
   */
 -static int lsm_file_alloc(struct file *file)
 -{
 -	if (!lsm_file_cache) {
 -		file->f_security = NULL;
 -		return 0;
 -	}
 +#define LSM_RET_DEFAULT(NAME) (NAME##_default)
 +#define DECLARE_LSM_RET_DEFAULT_void(DEFAULT, NAME)
 +#define DECLARE_LSM_RET_DEFAULT_int(DEFAULT, NAME) \
 +	static const int LSM_RET_DEFAULT(NAME) = (DEFAULT);
 +#define LSM_HOOK(RET, DEFAULT, NAME, ...) \
 +	DECLARE_LSM_RET_DEFAULT_##RET(DEFAULT, NAME)
  
 -	file->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);
 -	if (file->f_security == NULL)
 -		return -ENOMEM;
 -	return 0;
 -}
 +#include <linux/lsm_hook_defs.h>
 +#undef LSM_HOOK
  
+ /**
+  * lsm_inode_alloc - allocate a composite inode blob
+  * @inode: the inode that needs a blob
+  *
+  * Allocate the inode blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_inode_alloc(struct inode *inode)
+ {
+ 	if (!lsm_inode_cache) {
+ 		inode->i_security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	inode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);
+ 	if (inode->i_security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
  /*
   * Hook list operation macros.
   *
@@@ -674,15 -772,24 +751,29 @@@ int security_add_mnt_opt(const char *op
  }
  EXPORT_SYMBOL(security_add_mnt_opt);
  
 +int security_move_mount(const struct path *from_path, const struct path *to_path)
 +{
 +	return call_int_hook(move_mount, 0, from_path, to_path);
 +}
 +
  int security_inode_alloc(struct inode *inode)
  {
- 	inode->i_security = NULL;
- 	return call_int_hook(inode_alloc_security, 0, inode);
+ 	int rc = lsm_inode_alloc(inode);
+ 
+ 	if (unlikely(rc))
+ 		return rc;
+ 	rc = call_int_hook(inode_alloc_security, 0, inode);
+ 	if (unlikely(rc))
+ 		security_inode_free(inode);
+ 	return rc;
+ }
+ 
+ static void inode_free_by_rcu(struct rcu_head *head)
+ {
+ 	/*
+ 	 * The rcu head is at the start of the inode blob
+ 	 */
+ 	kmem_cache_free(lsm_inode_cache, head);
  }
  
  void security_inode_free(struct inode *inode)
diff --cc security/selinux/hooks.c
index 02238a76d816,23da46cd6e37..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -149,9 -145,6 +149,12 @@@ static int __init checkreqprot_setup(ch
  }
  __setup("checkreqprot=", checkreqprot_setup);
  
++<<<<<<< HEAD
 +static struct kmem_cache *sel_inode_cache;
 +static struct kmem_cache *file_security_cache;
 +
++=======
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  /**
   * selinux_secmark_enabled - Check to see if SECMARK is currently enabled
   *
@@@ -7000,82 -6603,11 +6982,90 @@@ static void selinux_bpf_prog_free(struc
  }
  #endif
  
++<<<<<<< HEAD
 +/*
 + * IMPORTANT NOTE: When adding new hooks, please be careful to keep this order:
 + * 1. any hooks that don't belong to (2.) or (3.) below,
 + * 2. hooks that both access structures allocated by other hooks, and allocate
 + *    structures that can be later accessed by other hooks (mostly "cloning"
 + *    hooks),
 + * 3. hooks that only allocate structures that can be later accessed by other
 + *    hooks ("allocating" hooks).
 + *
 + * Please follow block comment delimiters in the list to keep this order.
 + *
 + * This ordering is needed for SELinux runtime disable to work at least somewhat
 + * safely. Breaking the ordering rules above might lead to NULL pointer derefs
 + * when disabling SELinux at runtime.
 + */
 +
 +#ifdef CONFIG_PERF_EVENTS
 +static int selinux_perf_event_open(struct perf_event_attr *attr, int type)
 +{
 +	u32 requested, sid = current_sid();
 +
 +	if (type == PERF_SECURITY_OPEN)
 +		requested = PERF_EVENT__OPEN;
 +	else if (type == PERF_SECURITY_CPU)
 +		requested = PERF_EVENT__CPU;
 +	else if (type == PERF_SECURITY_KERNEL)
 +		requested = PERF_EVENT__KERNEL;
 +	else if (type == PERF_SECURITY_TRACEPOINT)
 +		requested = PERF_EVENT__TRACEPOINT;
 +	else
 +		return -EINVAL;
 +
 +	return avc_has_perm(&selinux_state, sid, sid, SECCLASS_PERF_EVENT,
 +			    requested, NULL);
 +}
 +
 +static int selinux_perf_event_alloc(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec;
 +
 +	perfsec = kzalloc(sizeof(*perfsec), GFP_KERNEL);
 +	if (!perfsec)
 +		return -ENOMEM;
 +
 +	perfsec->sid = current_sid();
 +	event->security = perfsec;
 +
 +	return 0;
 +}
 +
 +static void selinux_perf_event_free(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +
 +	event->security = NULL;
 +	kfree(perfsec);
 +}
 +
 +static int selinux_perf_event_read(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +	u32 sid = current_sid();
 +
 +	return avc_has_perm(&selinux_state, sid, perfsec->sid,
 +			    SECCLASS_PERF_EVENT, PERF_EVENT__READ, NULL);
 +}
 +
 +static int selinux_perf_event_write(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +	u32 sid = current_sid();
 +
 +	return avc_has_perm(&selinux_state, sid, perfsec->sid,
 +			    SECCLASS_PERF_EVENT, PERF_EVENT__WRITE, NULL);
 +}
 +#endif
++=======
+ struct lsm_blob_sizes selinux_blob_sizes __lsm_ro_after_init = {
+ 	.lbs_cred = sizeof(struct task_security_struct),
+ 	.lbs_file = sizeof(struct file_security_struct),
+ 	.lbs_inode = sizeof(struct inode_security_struct),
+ };
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  
  static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {
  	LSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),
@@@ -7364,12 -6859,6 +7354,15 @@@ static __init int selinux_init(void
  
  	default_noexec = !(VM_DATA_DEFAULT_FLAGS & VM_EXEC);
  
++<<<<<<< HEAD
 +	sel_inode_cache = kmem_cache_create("selinux_inode_security",
 +					    sizeof(struct inode_security_struct),
 +					    0, SLAB_PANIC, NULL);
 +	file_security_cache = kmem_cache_create("selinux_file_security",
 +					    sizeof(struct file_security_struct),
 +					    0, SLAB_PANIC, NULL);
++=======
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  	avc_init();
  
  	avtab_cache_init();
diff --cc security/smack/smack.h
index f7db791fb566,bf0abc35ca1c..000000000000
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@@ -356,6 -357,22 +356,25 @@@ extern struct list_head smack_onlycap_l
  #define SMACK_HASH_SLOTS 16
  extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
  
++<<<<<<< HEAD
++=======
+ static inline struct task_smack *smack_cred(const struct cred *cred)
+ {
+ 	return cred->security + smack_blob_sizes.lbs_cred;
+ }
+ 
+ static inline struct smack_known **smack_file(const struct file *file)
+ {
+ 	return (struct smack_known **)(file->f_security +
+ 				       smack_blob_sizes.lbs_file);
+ }
+ 
+ static inline struct inode_smack *smack_inode(const struct inode *inode)
+ {
+ 	return inode->i_security + smack_blob_sizes.lbs_inode;
+ }
+ 
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  /*
   * Is the directory transmuting?
   */
diff --cc security/smack/smack_lsm.c
index 922e3ab09003,804897c82810..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -832,17 -774,12 +833,23 @@@ static int smack_set_mnt_opts(struct su
  	/*
  	 * Initialize the root inode.
  	 */
++<<<<<<< HEAD
 +	isp = inode->i_security;
 +	if (isp == NULL) {
 +		isp = new_inode_smack(sp->smk_root);
 +		if (isp == NULL)
 +			return -ENOMEM;
 +		inode->i_security = isp;
 +	} else
 +		isp->smk_inode = sp->smk_root;
++=======
+ 	init_inode_smack(inode, sp->smk_root);
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  
- 	if (transmute)
+ 	if (transmute) {
+ 		isp = smack_inode(inode);
  		isp->smk_flags |= SMK_INODE_TRANSMUTE;
+ 	}
  
  	return 0;
  }
@@@ -978,42 -882,6 +983,45 @@@ static int smack_inode_alloc_security(s
  }
  
  /**
++<<<<<<< HEAD
 + * smack_inode_free_rcu - Free inode_smack blob from cache
 + * @head: the rcu_head for getting inode_smack pointer
 + *
 + *  Call back function called from call_rcu() to free
 + *  the i_security blob pointer in inode
 + */
 +static void smack_inode_free_rcu(struct rcu_head *head)
 +{
 +	struct inode_smack *issp;
 +
 +	issp = container_of(head, struct inode_smack, smk_rcu);
 +	kmem_cache_free(smack_inode_cache, issp);
 +}
 +
 +/**
 + * smack_inode_free_security - free an inode blob using call_rcu()
 + * @inode: the inode with a blob
 + *
 + * Clears the blob pointer in inode using RCU
 + */
 +static void smack_inode_free_security(struct inode *inode)
 +{
 +	struct inode_smack *issp = inode->i_security;
 +
 +	/*
 +	 * The inode may still be referenced in a path walk and
 +	 * a call to smack_inode_permission() can be made
 +	 * after smack_inode_free_security() is called.
 +	 * To avoid race condition free the i_security via RCU
 +	 * and leave the current inode->i_security pointer intact.
 +	 * The inode will be freed after the RCU grace period too.
 +	 */
 +	call_rcu(&issp->smk_rcu, smack_inode_free_rcu);
 +}
 +
 +/**
++=======
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
   * smack_inode_init_security - copy out the smack from an inode
   * @inode: the newly created inode
   * @dir: containing directory object
@@@ -4641,6 -4503,12 +4649,15 @@@ static int smack_dentry_create_files_as
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct lsm_blob_sizes smack_blob_sizes __lsm_ro_after_init = {
+ 	.lbs_cred = sizeof(struct task_smack),
+ 	.lbs_file = sizeof(struct smack_known *),
+ 	.lbs_inode = sizeof(struct inode_smack),
+ };
+ 
++>>>>>>> afb1cbe37440 (LSM: Infrastructure management of the inode security)
  static struct security_hook_list smack_hooks[] __lsm_ro_after_init = {
  	LSM_HOOK_INIT(ptrace_access_check, smack_ptrace_access_check),
  	LSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),
* Unmerged path include/linux/lsm_hooks.h
* Unmerged path security/security.c
* Unmerged path security/selinux/hooks.c
diff --git a/security/selinux/include/objsec.h b/security/selinux/include/objsec.h
index e4f7d53cbff2..8f470888bd5b 100644
--- a/security/selinux/include/objsec.h
+++ b/security/selinux/include/objsec.h
@@ -47,10 +47,7 @@ enum label_initialized {
 
 struct inode_security_struct {
 	struct inode *inode;	/* back pointer to inode object */
-	union {
-		struct list_head list;	/* list of inode_security_struct */
-		struct rcu_head rcu;	/* for freeing the inode_security_struct */
-	};
+	struct list_head list;	/* list of inode_security_struct */
 	u32 task_sid;		/* SID of creating task */
 	u32 sid;		/* SID of this object */
 	u16 sclass;		/* security class of this object */
@@ -166,7 +163,9 @@ static inline struct file_security_struct *selinux_file(const struct file *file)
 static inline struct inode_security_struct *selinux_inode(
 						const struct inode *inode)
 {
-	return inode->i_security;
+	if (unlikely(!inode->i_security))
+		return NULL;
+	return inode->i_security + selinux_blob_sizes.lbs_inode;
 }
 
 static inline struct msg_security_struct *selinux_msg_msg(
* Unmerged path security/smack/smack.h
* Unmerged path security/smack/smack_lsm.c
