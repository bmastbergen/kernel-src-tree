mt76: always use WTBL_MAX_SIZE for tlv allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Ryder Lee <ryder.lee@mediatek.com>
commit be2a2872d0b1db26222cfcd829f2d9e08f4c84c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/be2a2872.failed

Simplify WTBL defines.

	Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit be2a2872d0b1db26222cfcd829f2d9e08f4c84c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
index 6ef5670211d1,411ebb56baef..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
@@@ -767,302 -362,6 +767,305 @@@ enum 
  	BSS_INFO_MAX_NUM
  };
  
++<<<<<<< HEAD
 +enum {
 +	WTBL_RESET_AND_SET = 1,
 +	WTBL_SET,
 +	WTBL_QUERY,
 +	WTBL_RESET_ALL
 +};
 +
 +struct wtbl_req_hdr {
 +	u8 wlan_idx;
 +	u8 operation;
 +	__le16 tlv_num;
 +	u8 rsv[4];
 +} __packed;
 +
 +struct wtbl_generic {
 +	__le16 tag;
 +	__le16 len;
 +	u8 peer_addr[ETH_ALEN];
 +	u8 muar_idx;
 +	u8 skip_tx;
 +	u8 cf_ack;
 +	u8 qos;
 +	u8 mesh;
 +	u8 adm;
 +	__le16 partial_aid;
 +	u8 baf_en;
 +	u8 aad_om;
 +} __packed;
 +
 +struct wtbl_rx {
 +	__le16 tag;
 +	__le16 len;
 +	u8 rcid;
 +	u8 rca1;
 +	u8 rca2;
 +	u8 rv;
 +	u8 rsv[4];
 +} __packed;
 +
 +struct wtbl_ht {
 +	__le16 tag;
 +	__le16 len;
 +	u8 ht;
 +	u8 ldpc;
 +	u8 af;
 +	u8 mm;
 +	u8 rsv[4];
 +} __packed;
 +
 +struct wtbl_vht {
 +	__le16 tag;
 +	__le16 len;
 +	u8 ldpc;
 +	u8 dyn_bw;
 +	u8 vht;
 +	u8 txop_ps;
 +	u8 rsv[4];
 +} __packed;
 +
 +struct wtbl_tx_ps {
 +	__le16 tag;
 +	__le16 len;
 +	u8 txps;
 +	u8 rsv[3];
 +} __packed;
 +
 +struct wtbl_hdr_trans {
 +	__le16 tag;
 +	__le16 len;
 +	u8 to_ds;
 +	u8 from_ds;
 +	u8 disable_rx_trans;
 +	u8 rsv;
 +} __packed;
 +
 +enum {
 +	MT_BA_TYPE_INVALID,
 +	MT_BA_TYPE_ORIGINATOR,
 +	MT_BA_TYPE_RECIPIENT
 +};
 +
 +enum {
 +	RST_BA_MAC_TID_MATCH,
 +	RST_BA_MAC_MATCH,
 +	RST_BA_NO_MATCH
 +};
 +
 +struct wtbl_ba {
 +	__le16 tag;
 +	__le16 len;
 +	/* common */
 +	u8 tid;
 +	u8 ba_type;
 +	u8 rsv0[2];
 +	/* originator only */
 +	__le16 sn;
 +	u8 ba_en;
 +	u8 ba_winsize_idx;
 +	__le16 ba_winsize;
 +	/* recipient only */
 +	u8 peer_addr[ETH_ALEN];
 +	u8 rst_ba_tid;
 +	u8 rst_ba_sel;
 +	u8 rst_ba_sb;
 +	u8 band_idx;
 +	u8 rsv1[4];
 +} __packed;
 +
 +struct wtbl_bf {
 +	__le16 tag;
 +	__le16 len;
 +	u8 ibf;
 +	u8 ebf;
 +	u8 ibf_vht;
 +	u8 ebf_vht;
 +	u8 gid;
 +	u8 pfmu_idx;
 +	u8 rsv[2];
 +} __packed;
 +
 +struct wtbl_smps {
 +	__le16 tag;
 +	__le16 len;
 +	u8 smps;
 +	u8 rsv[3];
 +} __packed;
 +
 +struct wtbl_pn {
 +	__le16 tag;
 +	__le16 len;
 +	u8 pn[6];
 +	u8 rsv[2];
 +} __packed;
 +
 +struct wtbl_spe {
 +	__le16 tag;
 +	__le16 len;
 +	u8 spe_idx;
 +	u8 rsv[3];
 +} __packed;
 +
 +struct wtbl_raw {
 +	__le16 tag;
 +	__le16 len;
 +	u8 wtbl_idx;
 +	u8 dw;
 +	u8 rsv[2];
 +	__le32 msk;
 +	__le32 val;
 +} __packed;
 +
 +#define MT7615_WTBL_UPDATE_MAX_SIZE	(sizeof(struct wtbl_req_hdr) +	\
 +					 sizeof(struct wtbl_generic) +	\
 +					 sizeof(struct wtbl_rx) +	\
 +					 sizeof(struct wtbl_ht) +	\
 +					 sizeof(struct wtbl_vht) +	\
 +					 sizeof(struct wtbl_tx_ps) +	\
 +					 sizeof(struct wtbl_hdr_trans) +\
 +					 sizeof(struct wtbl_ba) +	\
 +					 sizeof(struct wtbl_bf) +	\
 +					 sizeof(struct wtbl_smps) +	\
 +					 sizeof(struct wtbl_pn) +	\
 +					 sizeof(struct wtbl_spe))
 +
 +#define MT7615_STA_UPDATE_MAX_SIZE	(sizeof(struct sta_req_hdr) +	\
 +					 sizeof(struct sta_rec_basic) +	\
 +					 sizeof(struct sta_rec_ht) +	\
 +					 sizeof(struct sta_rec_vht) +	\
 +					 sizeof(struct sta_rec_uapsd) + \
 +					 sizeof(struct tlv) +	\
 +					 MT7615_WTBL_UPDATE_MAX_SIZE)
 +
 +#define MT7615_WTBL_UPDATE_BA_SIZE	(sizeof(struct wtbl_req_hdr) +	\
 +					 sizeof(struct wtbl_ba))
 +
++=======
++>>>>>>> be2a2872d0b1 (mt76: always use WTBL_MAX_SIZE for tlv allocation)
 +enum {
 +	WTBL_GENERIC,
 +	WTBL_RX,
 +	WTBL_HT,
 +	WTBL_VHT,
 +	WTBL_PEER_PS, /* not used */
 +	WTBL_TX_PS,
 +	WTBL_HDR_TRANS,
 +	WTBL_SEC_KEY,
 +	WTBL_BA,
 +	WTBL_RDG, /* obsoleted */
 +	WTBL_PROTECT, /* not used */
 +	WTBL_CLEAR, /* not used */
 +	WTBL_BF,
 +	WTBL_SMPS,
 +	WTBL_RAW_DATA, /* debug only */
 +	WTBL_PN,
 +	WTBL_SPE,
 +	WTBL_MAX_NUM
 +};
 +
 +struct sta_ntlv_hdr {
 +	u8 rsv[2];
 +	__le16 tlv_num;
 +} __packed;
 +
 +struct sta_req_hdr {
 +	u8 bss_idx;
 +	u8 wlan_idx;
 +	__le16 tlv_num;
 +	u8 is_tlv_append;
 +	u8 muar_idx;
 +	u8 rsv[2];
 +} __packed;
 +
 +struct sta_rec_state {
 +	__le16 tag;
 +	__le16 len;
 +	u8 state;
 +	__le32 flags;
 +	u8 vhtop;
 +	u8 pad[2];
 +} __packed;
 +
 +struct sta_rec_basic {
 +	__le16 tag;
 +	__le16 len;
 +	__le32 conn_type;
 +	u8 conn_state;
 +	u8 qos;
 +	__le16 aid;
 +	u8 peer_addr[ETH_ALEN];
 +#define EXTRA_INFO_VER	BIT(0)
 +#define EXTRA_INFO_NEW	BIT(1)
 +	__le16 extra_info;
 +} __packed;
 +
 +struct sta_rec_ht {
 +	__le16 tag;
 +	__le16 len;
 +	__le16 ht_cap;
 +	u16 rsv;
 +} __packed;
 +
 +struct sta_rec_vht {
 +	__le16 tag;
 +	__le16 len;
 +	__le32 vht_cap;
 +	__le16 vht_rx_mcs_map;
 +	__le16 vht_tx_mcs_map;
 +} __packed;
 +
 +struct sta_rec_ba {
 +	__le16 tag;
 +	__le16 len;
 +	u8 tid;
 +	u8 ba_type;
 +	u8 amsdu;
 +	u8 ba_en;
 +	__le16 ssn;
 +	__le16 winsize;
 +} __packed;
 +
 +struct sta_rec_uapsd {
 +	__le16 tag;
 +	__le16 len;
 +	u8 dac_map;
 +	u8 tac_map;
 +	u8 max_sp;
 +	u8 rsv0;
 +	__le16 listen_interval;
 +	u8 rsv1[2];
 +} __packed;
 +
 +enum {
 +	STA_REC_BASIC,
 +	STA_REC_RA,
 +	STA_REC_RA_CMM_INFO,
 +	STA_REC_RA_UPDATE,
 +	STA_REC_BF,
 +	STA_REC_AMSDU, /* for CR4 */
 +	STA_REC_BA,
 +	STA_REC_STATE,
 +	STA_REC_TX_PROC, /* for hdr trans and CSO in CR4 */
 +	STA_REC_HT,
 +	STA_REC_VHT,
 +	STA_REC_APPS,
 +	STA_REC_WTBL = 13,
 +	STA_REC_MAX_NUM
 +};
 +
 +enum {
 +	CMD_CBW_20MHZ,
 +	CMD_CBW_40MHZ,
 +	CMD_CBW_80MHZ,
 +	CMD_CBW_160MHZ,
 +	CMD_CBW_10MHZ,
 +	CMD_CBW_5MHZ,
 +	CMD_CBW_8080MHZ
 +};
 +
  enum {
  	CH_SWITCH_NORMAL = 0,
  	CH_SWITCH_SCAN = 3,
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
index 22c9252267db..bd37104955a3 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
@@ -589,7 +589,7 @@ mt7915_mcu_alloc_wtbl_req(struct mt7915_dev *dev, struct mt7915_sta *msta,
 
 	if (!nskb) {
 		nskb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
-					  MT7915_WTBL_UPDATE_BA_SIZE);
+					  MT7915_WTBL_UPDATE_MAX_SIZE);
 		if (!nskb)
 			return ERR_PTR(-ENOMEM);
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
index 983973e5182c..bd2128436382 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
@@ -1041,9 +1041,6 @@ enum {
 					 sizeof(struct tlv) +		\
 					 MT7915_WTBL_UPDATE_MAX_SIZE)
 
-#define MT7915_WTBL_UPDATE_BA_SIZE	(sizeof(struct wtbl_req_hdr) +	\
-					 sizeof(struct wtbl_ba))
-
 #define MT7915_BSS_UPDATE_MAX_SIZE	(sizeof(struct sta_req_hdr) +	\
 					 sizeof(struct bss_info_omac) +	\
 					 sizeof(struct bss_info_basic) +\
