cfg80211: add support to configure HE MCS for beacon rate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Rajkumar Manoharan <rmanohar@codeaurora.org>
commit c4a30446a92a222d2f368254dcc4ab2fda0ba924
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/c4a30446.failed

This allows an option to configure a single HE MCS beacon tx rate.

	Signed-off-by: Rajkumar Manoharan <rmanohar@codeaurora.org>
Link: https://lore.kernel.org/r/1602879327-29488-2-git-send-email-rmanohar@codeaurora.org
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit c4a30446a92a222d2f368254dcc4ab2fda0ba924)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/nl80211.h
diff --cc include/uapi/linux/nl80211.h
index dc94d21b6a61,e1e5b3d4dd81..000000000000
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@@ -5859,6 -5898,15 +5860,18 @@@ enum nl80211_feature_flags 
   * @NL80211_EXT_FEATURE_SAE_OFFLOAD_AP: Device wants to do SAE authentication
   *	in AP mode (SAE password is passed as part of the start AP command).
   *
++<<<<<<< HEAD
++=======
+  * @NL80211_EXT_FEATURE_FILS_DISCOVERY: Driver/device supports FILS discovery
+  *	frames transmission
+  *
+  * @NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP: Driver/device supports
+  *	unsolicited broadcast probe response transmission
+  *
+  * @NL80211_EXT_FEATURE_BEACON_RATE_HE: Driver supports beacon rate
+  *	configuration (AP/mesh) with HE rates.
+  *
++>>>>>>> c4a30446a92a (cfg80211: add support to configure HE MCS for beacon rate)
   * @NUM_NL80211_EXT_FEATURES: number of extended features.
   * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
   */
@@@ -5917,6 -5965,9 +5930,12 @@@ enum nl80211_ext_feature_index 
  	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION,
  	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK,
  	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP,
++<<<<<<< HEAD
++=======
+ 	NL80211_EXT_FEATURE_FILS_DISCOVERY,
+ 	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP,
+ 	NL80211_EXT_FEATURE_BEACON_RATE_HE,
++>>>>>>> c4a30446a92a (cfg80211: add support to configure HE MCS for beacon rate)
  
  	/* add new features before the definition below */
  	NUM_NL80211_EXT_FEATURES,
* Unmerged path include/uapi/linux/nl80211.h
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 6a4a9764a69b..388ae5d284dc 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -4659,6 +4659,7 @@ static int nl80211_parse_tx_bitrate_mask(struct genl_info *info,
 					mask->control[band].ht_mcs))
 				return -EINVAL;
 		}
+
 		if (tb[NL80211_TXRATE_VHT]) {
 			if (!vht_set_mcs_mask(
 					sband,
@@ -4666,6 +4667,7 @@ static int nl80211_parse_tx_bitrate_mask(struct genl_info *info,
 					mask->control[band].vht_mcs))
 				return -EINVAL;
 		}
+
 		if (tb[NL80211_TXRATE_GI]) {
 			mask->control[band].gi =
 				nla_get_u8(tb[NL80211_TXRATE_GI]);
@@ -4677,6 +4679,7 @@ static int nl80211_parse_tx_bitrate_mask(struct genl_info *info,
 				     nla_data(tb[NL80211_TXRATE_HE]),
 				     mask->control[band].he_mcs))
 			return -EINVAL;
+
 		if (tb[NL80211_TXRATE_HE_GI])
 			mask->control[band].he_gi =
 				nla_get_u8(tb[NL80211_TXRATE_HE_GI]);
@@ -4718,7 +4721,7 @@ static int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,
 				   enum nl80211_band band,
 				   struct cfg80211_bitrate_mask *beacon_rate)
 {
-	u32 count_ht, count_vht, i;
+	u32 count_ht, count_vht, count_he, i;
 	u32 rate = beacon_rate->control[band].legacy;
 
 	/* Allow only one rate */
@@ -4751,7 +4754,21 @@ static int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,
 			return -EINVAL;
 	}
 
-	if ((count_ht && count_vht) || (!rate && !count_ht && !count_vht))
+	count_he = 0;
+	for (i = 0; i < NL80211_HE_NSS_MAX; i++) {
+		if (hweight16(beacon_rate->control[band].he_mcs[i]) > 1) {
+			return -EINVAL;
+		} else if (beacon_rate->control[band].he_mcs[i]) {
+			count_he++;
+			if (count_he > 1)
+				return -EINVAL;
+		}
+		if (count_he && rate)
+			return -EINVAL;
+	}
+
+	if ((count_ht && count_vht && count_he) ||
+	    (!rate && !count_ht && !count_vht && !count_he))
 		return -EINVAL;
 
 	if (rate &&
@@ -4766,6 +4783,10 @@ static int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,
 	    !wiphy_ext_feature_isset(&rdev->wiphy,
 				     NL80211_EXT_FEATURE_BEACON_RATE_VHT))
 		return -EINVAL;
+	if (count_he &&
+	    !wiphy_ext_feature_isset(&rdev->wiphy,
+				     NL80211_EXT_FEATURE_BEACON_RATE_HE))
+		return -EINVAL;
 
 	return 0;
 }
