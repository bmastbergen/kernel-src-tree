KVM: arm64: Fix CPU interface MMIO compatibility detection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Marc Zyngier <maz@kernel.org>
commit af22df997d71c32304d6835a8b690281063b8010
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/af22df99.failed

In order to detect whether a GICv3 CPU interface is MMIO capable,
we switch ICC_SRE_EL1.SRE to 0 and check whether it sticks.

However, this is only possible if *ALL* of the HCR_EL2 interrupt
overrides are set, and the CPU is perfectly allowed to ignore
the write to ICC_SRE_EL1 otherwise. This leads KVM to pretend
that a whole bunch of ARMv8.0 CPUs aren't MMIO-capable, and
breaks VMs that should work correctly otherwise.

Fix this by setting IMO/FMO/IMO before touching ICC_SRE_EL1,
and clear them afterwards. This allows us to reliably detect
the CPU interface capabilities.

	Tested-by: Shameerali Kolothum Thodi <shameerali.kolothum.thodi@huawei.com>
Fixes: 9739f6ef053f ("KVM: arm64: Workaround firmware wrongly advertising GICv2-on-v3 compatibility")
	Signed-off-by: Marc Zyngier <maz@kernel.org>
(cherry picked from commit af22df997d71c32304d6835a8b690281063b8010)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/hyp/vgic-v3-sr.c
diff --cc arch/arm64/kvm/hyp/vgic-v3-sr.c
index 48c15d8ffd04,39f8f7f9227c..000000000000
--- a/arch/arm64/kvm/hyp/vgic-v3-sr.c
+++ b/arch/arm64/kvm/hyp/vgic-v3-sr.c
@@@ -414,9 -405,54 +414,52 @@@ void __vgic_v3_init_lrs(void
  		__gic_v3_set_lr(0, i);
  }
  
 -/*
 - * Return the GIC CPU configuration:
 - * - [31:0]  ICH_VTR_EL2
 - * - [62:32] RES0
 - * - [63]    MMIO (GICv2) capable
 - */
 -u64 __vgic_v3_get_gic_config(void)
 +u64 __vgic_v3_get_ich_vtr_el2(void)
  {
++<<<<<<< HEAD
 +	return read_gicreg(ICH_VTR_EL2);
++=======
+ 	u64 val, sre = read_gicreg(ICC_SRE_EL1);
+ 	unsigned long flags = 0;
+ 
+ 	/*
+ 	 * To check whether we have a MMIO-based (GICv2 compatible)
+ 	 * CPU interface, we need to disable the system register
+ 	 * view. To do that safely, we have to prevent any interrupt
+ 	 * from firing (which would be deadly).
+ 	 *
+ 	 * Note that this only makes sense on VHE, as interrupts are
+ 	 * already masked for nVHE as part of the exception entry to
+ 	 * EL2.
+ 	 */
+ 	if (has_vhe())
+ 		flags = local_daif_save();
+ 
+ 	/*
+ 	 * Table 11-2 "Permitted ICC_SRE_ELx.SRE settings" indicates
+ 	 * that to be able to set ICC_SRE_EL1.SRE to 0, all the
+ 	 * interrupt overrides must be set. You've got to love this.
+ 	 */
+ 	sysreg_clear_set(hcr_el2, 0, HCR_AMO | HCR_FMO | HCR_IMO);
+ 	isb();
+ 	write_gicreg(0, ICC_SRE_EL1);
+ 	isb();
+ 
+ 	val = read_gicreg(ICC_SRE_EL1);
+ 
+ 	write_gicreg(sre, ICC_SRE_EL1);
+ 	isb();
+ 	sysreg_clear_set(hcr_el2, HCR_AMO | HCR_FMO | HCR_IMO, 0);
+ 	isb();
+ 
+ 	if (has_vhe())
+ 		local_daif_restore(flags);
+ 
+ 	val  = (val & ICC_SRE_EL1_SRE) ? 0 : (1ULL << 63);
+ 	val |= read_gicreg(ICH_VTR_EL2);
+ 
+ 	return val;
++>>>>>>> af22df997d71 (KVM: arm64: Fix CPU interface MMIO compatibility detection)
  }
  
  u64 __vgic_v3_read_vmcr(void)
* Unmerged path arch/arm64/kvm/hyp/vgic-v3-sr.c
