devlink: Support get and set state of port function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Parav Pandit <parav@nvidia.com>
commit a556dded9c23c51c82654f1ebe389cbc0bc22057
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/a556dded.failed

devlink port function can be in active or inactive state.
Allow users to get and set port function's state.

When the port function it activated, its operational state may change
after a while when the device is created and driver binds to it.
Similarly on deactivation flow.

To clearly describe the state of the port function and its device's
operational state in the host system, define state and opstate
attributes.

Example of a PCI SF port which supports a port function:

$ devlink dev eswitch set pci/0000:06:00.0 mode switchdev

$ devlink port show
pci/0000:06:00.0/65535: type eth netdev ens2f0np0 flavour physical port 0 splittable false

$ devlink port add pci/0000:06:00.0 flavour pcisf pfnum 0 sfnum 88
pci/0000:08:00.0/32768: type eth netdev eth6 flavour pcisf controller 0 pfnum 0 sfnum 88 external false splittable false
  function:
    hw_addr 00:00:00:00:00:00 state inactive opstate detached

$ devlink port show pci/0000:06:00.0/32768
pci/0000:06:00.0/32768: type eth netdev ens2f0npf0sf88 flavour pcisf controller 0 pfnum 0 sfnum 88 external false splittable false
  function:
    hw_addr 00:00:00:00:88:88 state inactive opstate detached

$ devlink port function set pci/0000:06:00.0/32768 hw_addr 00:00:00:00:88:88 state active

$ devlink port show pci/0000:06:00.0/32768 -jp
{
    "port": {
        "pci/0000:06:00.0/32768": {
            "type": "eth",
            "netdev": "ens2f0npf0sf88",
            "flavour": "pcisf",
            "controller": 0,
            "pfnum": 0,
            "sfnum": 88,
            "external": false,
            "splittable": false,
            "function": {
                "hw_addr": "00:00:00:00:88:88",
                "state": "active",
                "opstate": "attached"
            }
        }
    }
}

	Signed-off-by: Parav Pandit <parav@nvidia.com>
	Reviewed-by: Jiri Pirko <jiri@nvidia.com>
	Reviewed-by: Vu Pham <vuhuong@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit a556dded9c23c51c82654f1ebe389cbc0bc22057)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/devlink.h
diff --cc include/net/devlink.h
index 8196d015ec57,691ee76ca548..000000000000
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@@ -1343,6 -1373,79 +1343,82 @@@ struct devlink_ops 
  	int (*port_function_hw_addr_set)(struct devlink *devlink, struct devlink_port *port,
  					 const u8 *hw_addr, int hw_addr_len,
  					 struct netlink_ext_ack *extack);
++<<<<<<< HEAD
++=======
+ 	/**
+ 	 * port_new() - Add a new port function of a specified flavor
+ 	 * @devlink: Devlink instance
+ 	 * @attrs: attributes of the new port
+ 	 * @extack: extack for reporting error messages
+ 	 * @new_port_index: index of the new port
+ 	 *
+ 	 * Devlink core will call this device driver function upon user request
+ 	 * to create a new port function of a specified flavor and optional
+ 	 * attributes
+ 	 *
+ 	 * Notes:
+ 	 *	- Called without devlink instance lock being held. Drivers must
+ 	 *	  implement own means of synchronization
+ 	 *	- On success, drivers must register a port with devlink core
+ 	 *
+ 	 * Return: 0 on success, negative value otherwise.
+ 	 */
+ 	int (*port_new)(struct devlink *devlink,
+ 			const struct devlink_port_new_attrs *attrs,
+ 			struct netlink_ext_ack *extack,
+ 			unsigned int *new_port_index);
+ 	/**
+ 	 * port_del() - Delete a port function
+ 	 * @devlink: Devlink instance
+ 	 * @port_index: port function index to delete
+ 	 * @extack: extack for reporting error messages
+ 	 *
+ 	 * Devlink core will call this device driver function upon user request
+ 	 * to delete a previously created port function
+ 	 *
+ 	 * Notes:
+ 	 *	- Called without devlink instance lock being held. Drivers must
+ 	 *	  implement own means of synchronization
+ 	 *	- On success, drivers must unregister the corresponding devlink
+ 	 *	  port
+ 	 *
+ 	 * Return: 0 on success, negative value otherwise.
+ 	 */
+ 	int (*port_del)(struct devlink *devlink, unsigned int port_index,
+ 			struct netlink_ext_ack *extack);
+ 	/**
+ 	 * port_fn_state_get() - Get the state of a port function
+ 	 * @devlink: Devlink instance
+ 	 * @port: The devlink port
+ 	 * @state: Admin configured state
+ 	 * @opstate: Current operational state
+ 	 * @extack: extack for reporting error messages
+ 	 *
+ 	 * Reports the admin and operational state of a devlink port function
+ 	 *
+ 	 * Return: 0 on success, negative value otherwise.
+ 	 */
+ 	int (*port_fn_state_get)(struct devlink *devlink,
+ 				 struct devlink_port *port,
+ 				 enum devlink_port_fn_state *state,
+ 				 enum devlink_port_fn_opstate *opstate,
+ 				 struct netlink_ext_ack *extack);
+ 	/**
+ 	 * port_fn_state_set() - Set the admin state of a port function
+ 	 * @devlink: Devlink instance
+ 	 * @port: The devlink port
+ 	 * @state: Admin state
+ 	 * @extack: extack for reporting error messages
+ 	 *
+ 	 * Set the admin state of a devlink port function
+ 	 *
+ 	 * Return: 0 on success, negative value otherwise.
+ 	 */
+ 	int (*port_fn_state_set)(struct devlink *devlink,
+ 				 struct devlink_port *port,
+ 				 enum devlink_port_fn_state state,
+ 				 struct netlink_ext_ack *extack);
++>>>>>>> a556dded9c23 (devlink: Support get and set state of port function)
  };
  
  static inline void *devlink_priv(struct devlink *devlink)
* Unmerged path include/net/devlink.h
diff --git a/include/uapi/linux/devlink.h b/include/uapi/linux/devlink.h
index 1a241b09a7f8..f6008b2fa60f 100644
--- a/include/uapi/linux/devlink.h
+++ b/include/uapi/linux/devlink.h
@@ -583,9 +583,29 @@ enum devlink_resource_unit {
 enum devlink_port_function_attr {
 	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC,
 	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR,	/* binary */
+	DEVLINK_PORT_FN_ATTR_STATE,	/* u8 */
+	DEVLINK_PORT_FN_ATTR_OPSTATE,	/* u8 */
 
 	__DEVLINK_PORT_FUNCTION_ATTR_MAX,
 	DEVLINK_PORT_FUNCTION_ATTR_MAX = __DEVLINK_PORT_FUNCTION_ATTR_MAX - 1
 };
 
+enum devlink_port_fn_state {
+	DEVLINK_PORT_FN_STATE_INACTIVE,
+	DEVLINK_PORT_FN_STATE_ACTIVE,
+};
+
+/**
+ * enum devlink_port_fn_opstate - indicates operational state of the function
+ * @DEVLINK_PORT_FN_OPSTATE_ATTACHED: Driver is attached to the function.
+ * For graceful tear down of the function, after inactivation of the
+ * function, user should wait for operational state to turn DETACHED.
+ * @DEVLINK_PORT_FN_OPSTATE_DETACHED: Driver is detached from the function.
+ * It is safe to delete the port.
+ */
+enum devlink_port_fn_opstate {
+	DEVLINK_PORT_FN_OPSTATE_DETACHED,
+	DEVLINK_PORT_FN_OPSTATE_ATTACHED,
+};
+
 #endif /* _UAPI_LINUX_DEVLINK_H_ */
diff --git a/net/core/devlink.c b/net/core/devlink.c
index c9ff69b87ef6..c27efde92a11 100644
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@ -91,6 +91,9 @@ EXPORT_TRACEPOINT_SYMBOL_GPL(devlink_trap_report);
 
 static const struct nla_policy devlink_function_nl_policy[DEVLINK_PORT_FUNCTION_ATTR_MAX + 1] = {
 	[DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR] = { .type = NLA_BINARY },
+	[DEVLINK_PORT_FN_ATTR_STATE] =
+		NLA_POLICY_RANGE(NLA_U8, DEVLINK_PORT_FN_STATE_INACTIVE,
+				 DEVLINK_PORT_FN_STATE_ACTIVE),
 };
 
 static LIST_HEAD(devlink_list);
@@ -733,6 +736,58 @@ devlink_port_fn_hw_addr_fill(struct devlink *devlink, const struct devlink_ops *
 	return 0;
 }
 
+static bool
+devlink_port_fn_state_valid(enum devlink_port_fn_state state)
+{
+	return state == DEVLINK_PORT_FN_STATE_INACTIVE ||
+	       state == DEVLINK_PORT_FN_STATE_ACTIVE;
+}
+
+static bool
+devlink_port_fn_opstate_valid(enum devlink_port_fn_opstate opstate)
+{
+	return opstate == DEVLINK_PORT_FN_OPSTATE_DETACHED ||
+	       opstate == DEVLINK_PORT_FN_OPSTATE_ATTACHED;
+}
+
+static int
+devlink_port_fn_state_fill(struct devlink *devlink,
+			   const struct devlink_ops *ops,
+			   struct devlink_port *port, struct sk_buff *msg,
+			   struct netlink_ext_ack *extack,
+			   bool *msg_updated)
+{
+	enum devlink_port_fn_opstate opstate;
+	enum devlink_port_fn_state state;
+	int err;
+
+	if (!ops->port_fn_state_get)
+		return 0;
+
+	err = ops->port_fn_state_get(devlink, port, &state, &opstate, extack);
+	if (err) {
+		if (err == -EOPNOTSUPP)
+			return 0;
+		return err;
+	}
+	if (!devlink_port_fn_state_valid(state)) {
+		WARN_ON_ONCE(1);
+		NL_SET_ERR_MSG_MOD(extack, "Invalid state read from driver");
+		return -EINVAL;
+	}
+	if (!devlink_port_fn_opstate_valid(opstate)) {
+		WARN_ON_ONCE(1);
+		NL_SET_ERR_MSG_MOD(extack,
+				   "Invalid operational state read from driver");
+		return -EINVAL;
+	}
+	if (nla_put_u8(msg, DEVLINK_PORT_FN_ATTR_STATE, state) ||
+	    nla_put_u8(msg, DEVLINK_PORT_FN_ATTR_OPSTATE, opstate))
+		return -EMSGSIZE;
+	*msg_updated = true;
+	return 0;
+}
+
 static int
 devlink_nl_port_function_attrs_put(struct sk_buff *msg, struct devlink_port *port,
 				   struct netlink_ext_ack *extack)
@@ -750,6 +805,11 @@ devlink_nl_port_function_attrs_put(struct sk_buff *msg, struct devlink_port *por
 	ops = devlink->ops;
 	err = devlink_port_fn_hw_addr_fill(devlink, ops, port, msg,
 					   extack, &msg_updated);
+	if (err)
+		goto out;
+	err = devlink_port_fn_state_fill(devlink, ops, port, msg, extack,
+					 &msg_updated);
+out:
 	if (err || !msg_updated)
 		nla_nest_cancel(msg, function_attr);
 	else
@@ -1015,6 +1075,24 @@ devlink_port_function_hw_addr_set(struct devlink *devlink, struct devlink_port *
 	return ops->port_function_hw_addr_set(devlink, port, hw_addr, hw_addr_len, extack);
 }
 
+static int devlink_port_fn_state_set(struct devlink *devlink,
+				     struct devlink_port *port,
+				     const struct nlattr *attr,
+				     struct netlink_ext_ack *extack)
+{
+	enum devlink_port_fn_state state;
+	const struct devlink_ops *ops;
+
+	state = nla_get_u8(attr);
+	ops = devlink->ops;
+	if (!ops->port_fn_state_set) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "Function does not support state setting");
+		return -EOPNOTSUPP;
+	}
+	return ops->port_fn_state_set(devlink, port, state, extack);
+}
+
 static int
 devlink_port_function_set(struct devlink *devlink, struct devlink_port *port,
 			  const struct nlattr *attr, struct netlink_ext_ack *extack)
@@ -1030,8 +1108,18 @@ devlink_port_function_set(struct devlink *devlink, struct devlink_port *port,
 	}
 
 	attr = tb[DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR];
-	if (attr)
+	if (attr) {
 		err = devlink_port_function_hw_addr_set(devlink, port, attr, extack);
+		if (err)
+			return err;
+	}
+	/* Keep this as the last function attribute set, so that when
+	 * multiple port function attributes are set along with state,
+	 * Those can be applied first before activating the state.
+	 */
+	attr = tb[DEVLINK_PORT_FN_ATTR_STATE];
+	if (attr)
+		err = devlink_port_fn_state_set(devlink, port, attr, extack);
 
 	if (!err)
 		devlink_port_notify(port, DEVLINK_CMD_PORT_NEW);
