netfilter: nft_compat: make sure xtables destructors have run

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Florian Westphal <fw@strlen.de>
commit ffe8923f109b7ea92c0842c89e61300eefa11c94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/ffe8923f.failed

Pablo Neira found that after recent update of xt_IDLETIMER the
iptables-nft tests sometimes show an error.

He tracked this down to the delayed cleanup used by nf_tables core:
del rule (transaction A)
add rule (transaction B)

Its possible that by time transaction B (both in same netns) runs,
the xt target destructor has not been invoked yet.

For native nft expressions this is no problem because all expressions
that have such side effects make sure these are handled from the commit
phase, rather than async cleanup.

For nft_compat however this isn't true.

Instead of forcing synchronous behaviour for nft_compat, keep track
of the number of outstanding destructor calls.

When we attempt to create a new expression, flush the cleanup worker
to make sure destructors have completed.

With lots of help from Pablo Neira.

	Reported-by: Pablo Neira Ayso <pablo@netfilter.org>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit ffe8923f109b7ea92c0842c89e61300eefa11c94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 94134a2f2b50,79e4db3cadec..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -7191,46 -7478,11 +7197,51 @@@ static void nf_tables_commit_release(st
  	spin_unlock(&nf_tables_destroy_list_lock);
  
  	nf_tables_module_autoload_cleanup(net);
++<<<<<<< HEAD
 +	mutex_unlock(&net->nft_commit_mutex);
 +
++=======
++>>>>>>> ffe8923f109b (netfilter: nft_compat: make sure xtables destructors have run)
  	schedule_work(&trans_destroy_work);
+ 
+ 	mutex_unlock(&net->nft.commit_mutex);
  }
  
 +static void nft_commit_notify(struct net *net, u32 portid)
 +{
 +	struct sk_buff *batch_skb = NULL, *nskb, *skb;
 +	unsigned char *data;
 +	int len;
 +
 +	list_for_each_entry_safe(skb, nskb, &net->nft_notify_list, list) {
 +		if (!batch_skb) {
 +new_batch:
 +			batch_skb = skb;
 +			len = NLMSG_GOODSIZE - skb->len;
 +			list_del(&skb->list);
 +			continue;
 +		}
 +		len -= skb->len;
 +		if (len > 0 && NFT_CB(skb).report == NFT_CB(batch_skb).report) {
 +			data = skb_put(batch_skb, skb->len);
 +			memcpy(data, skb->data, skb->len);
 +			list_del(&skb->list);
 +			kfree_skb(skb);
 +			continue;
 +		}
 +		nfnetlink_send(batch_skb, net, portid, NFNLGRP_NFTABLES,
 +			       NFT_CB(batch_skb).report, GFP_KERNEL);
 +		goto new_batch;
 +	}
 +
 +	if (batch_skb) {
 +		nfnetlink_send(batch_skb, net, portid, NFNLGRP_NFTABLES,
 +			       NFT_CB(batch_skb).report, GFP_KERNEL);
 +	}
 +
 +	WARN_ON_ONCE(!list_empty(&net->nft_notify_list));
 +}
 +
  static int nf_tables_commit(struct net *net, struct sk_buff *skb)
  {
  	struct nft_trans *trans, *next;
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index f2e03a3cc4be..af72e22dd124 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -1467,4 +1467,6 @@ void nft_chain_filter_fini(void);
 
 void __init nft_chain_route_init(void);
 void nft_chain_route_fini(void);
+
+void nf_tables_trans_destroy_flush_work(void);
 #endif /* _NET_NF_TABLES_H */
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_compat.c b/net/netfilter/nft_compat.c
index 276f1f2d6de1..b6702e9a223c 100644
--- a/net/netfilter/nft_compat.c
+++ b/net/netfilter/nft_compat.c
@@ -30,6 +30,8 @@ struct nft_xt_match_priv {
 	void *info;
 };
 
+static refcount_t nft_compat_pending_destroy = REFCOUNT_INIT(1);
+
 static int nft_compat_chain_validate_dependency(const struct nft_ctx *ctx,
 						const char *tablename)
 {
@@ -239,6 +241,15 @@ nft_target_init(const struct nft_ctx *ctx, const struct nft_expr *expr,
 
 	nft_target_set_tgchk_param(&par, ctx, target, info, &e, proto, inv);
 
+	/* xtables matches or targets can have side effects, e.g.
+	 * creation/destruction of /proc files.
+	 * The xt ->destroy functions are run asynchronously from
+	 * work queue.  If we have pending invocations we thus
+	 * need to wait for those to finish.
+	 */
+	if (refcount_read(&nft_compat_pending_destroy) > 1)
+		nf_tables_trans_destroy_flush_work();
+
 	ret = xt_check_target(&par, size, proto, inv);
 	if (ret < 0)
 		return ret;
@@ -250,6 +261,13 @@ nft_target_init(const struct nft_ctx *ctx, const struct nft_expr *expr,
 	return 0;
 }
 
+static void __nft_mt_tg_destroy(struct module *me, const struct nft_expr *expr)
+{
+	refcount_dec(&nft_compat_pending_destroy);
+	module_put(me);
+	kfree(expr->ops);
+}
+
 static void
 nft_target_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)
 {
@@ -265,8 +283,7 @@ nft_target_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)
 	if (par.target->destroy != NULL)
 		par.target->destroy(&par);
 
-	module_put(me);
-	kfree(expr->ops);
+	__nft_mt_tg_destroy(me, expr);
 }
 
 static int nft_extension_dump_info(struct sk_buff *skb, int attr,
@@ -497,8 +514,7 @@ __nft_match_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr,
 	if (par.match->destroy != NULL)
 		par.match->destroy(&par);
 
-	module_put(me);
-	kfree(expr->ops);
+	__nft_mt_tg_destroy(me, expr);
 }
 
 static void
@@ -703,6 +719,14 @@ static const struct nfnetlink_subsystem nfnl_compat_subsys = {
 
 static struct nft_expr_type nft_match_type;
 
+static void nft_mt_tg_deactivate(const struct nft_ctx *ctx,
+				 const struct nft_expr *expr,
+				 enum nft_trans_phase phase)
+{
+	if (phase == NFT_TRANS_COMMIT)
+		refcount_inc(&nft_compat_pending_destroy);
+}
+
 static const struct nft_expr_ops *
 nft_match_select_ops(const struct nft_ctx *ctx,
 		     const struct nlattr * const tb[])
@@ -741,6 +765,7 @@ nft_match_select_ops(const struct nft_ctx *ctx,
 	ops->type = &nft_match_type;
 	ops->eval = nft_match_eval;
 	ops->init = nft_match_init;
+	ops->deactivate = nft_mt_tg_deactivate,
 	ops->destroy = nft_match_destroy;
 	ops->dump = nft_match_dump;
 	ops->validate = nft_match_validate;
@@ -831,6 +856,7 @@ nft_target_select_ops(const struct nft_ctx *ctx,
 	ops->size = NFT_EXPR_SIZE(XT_ALIGN(target->targetsize));
 	ops->init = nft_target_init;
 	ops->destroy = nft_target_destroy;
+	ops->deactivate = nft_mt_tg_deactivate,
 	ops->dump = nft_target_dump;
 	ops->validate = nft_target_validate;
 	ops->data = target;
@@ -894,6 +920,8 @@ static void __exit nft_compat_module_exit(void)
 	nfnetlink_subsys_unregister(&nfnl_compat_subsys);
 	nft_unregister_expr(&nft_target_type);
 	nft_unregister_expr(&nft_match_type);
+
+	WARN_ON_ONCE(refcount_read(&nft_compat_pending_destroy) != 1);
 }
 
 MODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_NFT_COMPAT);
