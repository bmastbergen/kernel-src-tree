locking/rtmutex: Remove empty and unused debug stubs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 8188d74e68174b11ff7c4a635ffc8fd31eacc6b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/8188d74e.failed

No users or useless and therefore just ballast.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lore.kernel.org/r/20210326153943.549192485@linutronix.de
(cherry picked from commit 8188d74e68174b11ff7c4a635ffc8fd31eacc6b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rtmutex.h
#	kernel/locking/rtmutex-debug.c
diff --cc include/linux/rtmutex.h
index 48b334b9eb87,d1672de9ca89..000000000000
--- a/include/linux/rtmutex.h
+++ b/include/linux/rtmutex.h
@@@ -43,23 -40,12 +43,29 @@@ struct rt_mutex_waiter
  struct hrtimer_sleeper;
  
  #ifdef CONFIG_DEBUG_RT_MUTEXES
++<<<<<<< HEAD
 + extern int rt_mutex_debug_check_no_locks_freed(const void *from,
 +						unsigned long len);
 + extern void rt_mutex_debug_check_no_locks_held(struct task_struct *task);
 +#else
 + static inline int rt_mutex_debug_check_no_locks_freed(const void *from,
 +						       unsigned long len)
 + {
 +	return 0;
 + }
 +# define rt_mutex_debug_check_no_locks_held(task)	do { } while (0)
++=======
+ extern void rt_mutex_debug_task_free(struct task_struct *tsk);
+ #else
+ static inline void rt_mutex_debug_task_free(struct task_struct *tsk) { }
++>>>>>>> 8188d74e6817 (locking/rtmutex: Remove empty and unused debug stubs)
  #endif
  
 -#define rt_mutex_init(mutex) \
 +#ifdef CONFIG_DEBUG_RT_MUTEXES
 +# define __DEBUG_RT_MUTEX_INITIALIZER(mutexname) \
 +	, .name = #mutexname
 +
 +# define rt_mutex_init(mutex) \
  do { \
  	static struct lock_class_key __key; \
  	__rt_mutex_init(mutex, __func__, &__key); \
diff --cc kernel/locking/rtmutex-debug.c
index 36222f3f2c33,df584c91710b..000000000000
--- a/kernel/locking/rtmutex-debug.c
+++ b/kernel/locking/rtmutex-debug.c
@@@ -58,83 -38,6 +58,86 @@@ void rt_mutex_debug_task_free(struct ta
  	DEBUG_LOCKS_WARN_ON(task->pi_blocked_on);
  }
  
++<<<<<<< HEAD
 +/*
 + * We fill out the fields in the waiter to store the information about
 + * the deadlock. We print when we return. act_waiter can be NULL in
 + * case of a remove waiter operation.
 + */
 +void debug_rt_mutex_deadlock(enum rtmutex_chainwalk chwalk,
 +			     struct rt_mutex_waiter *act_waiter,
 +			     struct rt_mutex *lock)
 +{
 +	struct task_struct *task;
 +
 +	if (!debug_locks || chwalk == RT_MUTEX_FULL_CHAINWALK || !act_waiter)
 +		return;
 +
 +	task = rt_mutex_owner(act_waiter->lock);
 +	if (task && task != current) {
 +		act_waiter->deadlock_task_pid = get_pid(task_pid(task));
 +		act_waiter->deadlock_lock = lock;
 +	}
 +}
 +
 +void debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter)
 +{
 +	struct task_struct *task;
 +
 +	if (!waiter->deadlock_lock || !debug_locks)
 +		return;
 +
 +	rcu_read_lock();
 +	task = pid_task(waiter->deadlock_task_pid, PIDTYPE_PID);
 +	if (!task) {
 +		rcu_read_unlock();
 +		return;
 +	}
 +
 +	if (!debug_locks_off()) {
 +		rcu_read_unlock();
 +		return;
 +	}
 +
 +	pr_warn("\n");
 +	pr_warn("============================================\n");
 +	pr_warn("WARNING: circular locking deadlock detected!\n");
 +	pr_warn("%s\n", print_tainted());
 +	pr_warn("--------------------------------------------\n");
 +	printk("%s/%d is deadlocking current task %s/%d\n\n",
 +	       task->comm, task_pid_nr(task),
 +	       current->comm, task_pid_nr(current));
 +
 +	printk("\n1) %s/%d is trying to acquire this lock:\n",
 +	       current->comm, task_pid_nr(current));
 +	printk_lock(waiter->lock, 1);
 +
 +	printk("\n2) %s/%d is blocked on this lock:\n",
 +		task->comm, task_pid_nr(task));
 +	printk_lock(waiter->deadlock_lock, 1);
 +
 +	debug_show_held_locks(current);
 +	debug_show_held_locks(task);
 +
 +	printk("\n%s/%d's [blocked] stackdump:\n\n",
 +		task->comm, task_pid_nr(task));
 +	show_stack(task, NULL);
 +	printk("\n%s/%d's [current] stackdump:\n\n",
 +		current->comm, task_pid_nr(current));
 +	dump_stack();
 +	debug_show_all_locks();
 +	rcu_read_unlock();
 +
 +	printk("[ turning off deadlock detection."
 +	       "Please report this trace. ]\n\n");
 +}
 +
 +void debug_rt_mutex_lock(struct rt_mutex *lock)
 +{
 +}
 +
++=======
++>>>>>>> 8188d74e6817 (locking/rtmutex: Remove empty and unused debug stubs)
  void debug_rt_mutex_unlock(struct rt_mutex *lock)
  {
  	DEBUG_LOCKS_WARN_ON(rt_mutex_owner(lock) != current);
* Unmerged path include/linux/rtmutex.h
* Unmerged path kernel/locking/rtmutex-debug.c
diff --git a/kernel/locking/rtmutex-debug.h b/kernel/locking/rtmutex-debug.h
index 772c9b012b62..3c76dce3aed6 100644
--- a/kernel/locking/rtmutex-debug.h
+++ b/kernel/locking/rtmutex-debug.h
@@ -13,10 +13,7 @@
 extern void debug_rt_mutex_init_waiter(struct rt_mutex_waiter *waiter);
 extern void debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter);
 extern void debug_rt_mutex_init(struct rt_mutex *lock, const char *name, struct lock_class_key *key);
-extern void debug_rt_mutex_lock(struct rt_mutex *lock);
 extern void debug_rt_mutex_unlock(struct rt_mutex *lock);
-extern void debug_rt_mutex_proxy_lock(struct rt_mutex *lock,
-				      struct task_struct *powner);
 extern void debug_rt_mutex_proxy_unlock(struct rt_mutex *lock);
 extern void debug_rt_mutex_deadlock(enum rtmutex_chainwalk chwalk,
 				    struct rt_mutex_waiter *waiter,
diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c
index 0d1634491095..fcda89fadc41 100644
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@ -885,9 +885,6 @@ static int try_to_take_rt_mutex(struct rt_mutex *lock, struct task_struct *task,
 	raw_spin_unlock(&task->pi_lock);
 
 takeit:
-	/* We got the lock. */
-	debug_rt_mutex_lock(lock);
-
 	/*
 	 * This either preserves the RT_MUTEX_HAS_WAITERS bit if there
 	 * are still waiters or clears it.
@@ -1582,20 +1579,6 @@ void __sched rt_mutex_futex_unlock(struct rt_mutex *lock)
 		rt_mutex_postunlock(&wake_q);
 }
 
-/**
- * rt_mutex_destroy - mark a mutex unusable
- * @lock: the mutex to be destroyed
- *
- * This function marks the mutex uninitialized, and any subsequent
- * use of the mutex is forbidden. The mutex must not be locked when
- * this function is called.
- */
-void rt_mutex_destroy(struct rt_mutex *lock)
-{
-	WARN_ON(rt_mutex_is_locked(lock));
-}
-EXPORT_SYMBOL_GPL(rt_mutex_destroy);
-
 /**
  * __rt_mutex_init - initialize the rt_mutex
  *
@@ -1637,7 +1620,6 @@ void rt_mutex_init_proxy_locked(struct rt_mutex *lock,
 				struct task_struct *proxy_owner)
 {
 	__rt_mutex_init(lock, NULL, NULL);
-	debug_rt_mutex_proxy_lock(lock, proxy_owner);
 	rt_mutex_set_owner(lock, proxy_owner);
 }
 
diff --git a/kernel/locking/rtmutex.h b/kernel/locking/rtmutex.h
index 4dbdec15f1a0..e0b23148d42a 100644
--- a/kernel/locking/rtmutex.h
+++ b/kernel/locking/rtmutex.h
@@ -13,8 +13,6 @@
 
 #define debug_rt_mutex_init_waiter(w)			do { } while (0)
 #define debug_rt_mutex_free_waiter(w)			do { } while (0)
-#define debug_rt_mutex_lock(l)				do { } while (0)
-#define debug_rt_mutex_proxy_lock(l,p)			do { } while (0)
 #define debug_rt_mutex_proxy_unlock(l)			do { } while (0)
 #define debug_rt_mutex_unlock(l)			do { } while (0)
 #define debug_rt_mutex_init(m, n, k)			do { } while (0)
