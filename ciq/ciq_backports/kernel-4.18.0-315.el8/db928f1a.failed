mt76: mt7663: rely on mt76_connac_pm_ref/mt76_connac_pm_unref in tx/rx napi

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit db928f1ab9789f99a0e57b35f3c8d652ad5350f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/db928f1a.failed

Introduce mt7615_poll_rx rx napi callback for mt7663.
Do not access device registers in tx/rx napi if the device is not awake.

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit db928f1ab9789f99a0e57b35f3c8d652ad5350f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7615/dma.c
#	drivers/net/wireless/mediatek/mt76/mt7615/mac.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/dma.c
index 847ccaa0296f,8004ae5c16a9..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/dma.c
@@@ -241,7 -285,7 +265,11 @@@ int mt7615_dma_init(struct mt7615_dev *
  
  	mt76_wr(dev, MT_DELAY_INT_CFG, 0);
  
++<<<<<<< HEAD
 +	ret = mt76_init_queues(dev);
++=======
+ 	ret = mt76_init_queues(dev, mt7615_poll_rx);
++>>>>>>> db928f1ab978 (mt76: mt7663: rely on mt76_connac_pm_ref/mt76_connac_pm_unref in tx/rx napi)
  	if (ret < 0)
  		return ret;
  
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mac.c
index 1b8b80e3739d,e81c7d322811..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
@@@ -1888,33 -1913,15 +1888,43 @@@ void mt7615_pm_wake_work(struct work_st
  						pm.wake_work);
  	mphy = dev->phy.mt76;
  
++<<<<<<< HEAD
 +	if (mt7615_mcu_set_drv_ctrl(dev)) {
 +		dev_err(mphy->dev->dev, "failed to wake device\n");
 +		goto out;
++=======
+ 	if (!mt7615_mcu_set_drv_ctrl(dev)) {
+ 		int i;
+ 
+ 		mt76_for_each_q_rx(&dev->mt76, i)
+ 			napi_schedule(&dev->mt76.napi[i]);
+ 		mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
+ 		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], false);
++>>>>>>> db928f1ab978 (mt76: mt7663: rely on mt76_connac_pm_ref/mt76_connac_pm_unref in tx/rx napi)
  	}
  
 +	spin_lock_bh(&dev->pm.txq_lock);
 +	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 +		struct mt7615_sta *msta = dev->pm.tx_q[i].msta;
 +		struct ieee80211_sta *sta = NULL;
 +		struct mt76_wcid *wcid;
 +
 +		if (!dev->pm.tx_q[i].skb)
 +			continue;
 +
 +		wcid = msta ? &msta->wcid : &dev->mt76.global_wcid;
 +		if (msta && wcid->sta)
 +			sta = container_of((void *)msta, struct ieee80211_sta,
 +					   drv_priv);
 +
 +		mt76_tx(mphy, sta, wcid, dev->pm.tx_q[i].skb);
 +		dev->pm.tx_q[i].skb = NULL;
 +	}
 +	spin_unlock_bh(&dev->pm.txq_lock);
 +
 +	mt76_worker_schedule(&dev->mt76.tx_worker);
 +
 +out:
  	ieee80211_wake_queues(mphy->hw);
  	complete_all(&dev->pm.wake_cmpl);
  }
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/dma.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mac.c
