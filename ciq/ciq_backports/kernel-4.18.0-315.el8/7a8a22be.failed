PCI/AER: Clear AER status from Root Port when resetting Downstream Port

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Keith Busch <kbusch@kernel.org>
commit 7a8a22be35a5058366429e311017e05206c43137
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/7a8a22be.failed

The pci_dev parameter given to aer_root_reset() may be a Downstream Port
rather than the Root Port. Get the Root Port from the provided device in
order to clear the root's AER status.

Link: https://lore.kernel.org/r/20210104230300.1277180-3-kbusch@kernel.org
	Tested-by: Hedi Berriche <hedi.berriche@hpe.com>
	Signed-off-by: Keith Busch <kbusch@kernel.org>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Sean V Kelley <sean.v.kelley@intel.com>
	Acked-by: Hedi Berriche <hedi.berriche@hpe.com>
(cherry picked from commit 7a8a22be35a5058366429e311017e05206c43137)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pcie/aer.c
diff --cc drivers/pci/pcie/aer.c
index 60c49c452658,3fd4aaaa627e..000000000000
--- a/drivers/pci/pcie/aer.c
+++ b/drivers/pci/pcie/aer.c
@@@ -1369,25 -1380,52 +1369,46 @@@ static pci_ers_result_t aer_root_reset(
  	u32 reg32;
  	int rc;
  
++<<<<<<< HEAD
 +	if (pcie_aer_is_native(dev)) {
++=======
+ 	/*
+ 	 * Only Root Ports and RCECs have AER Root Command and Root Status
+ 	 * registers.  If "dev" is an RCiEP, the relevant registers are in
+ 	 * the RCEC.
+ 	 */
+ 	if (type == PCI_EXP_TYPE_RC_END)
+ 		root = dev->rcec;
+ 	else
+ 		root = pcie_find_root_port(dev);
+ 
+ 	/*
+ 	 * If the platform retained control of AER, an RCiEP may not have
+ 	 * an RCEC visible to us, so dev->rcec ("root") may be NULL.  In
+ 	 * that case, firmware is responsible for these registers.
+ 	 */
+ 	aer = root ? root->aer_cap : 0;
+ 
+ 	if ((host->native_aer || pcie_ports_native) && aer) {
++>>>>>>> 7a8a22be35a5 (PCI/AER: Clear AER status from Root Port when resetting Downstream Port)
  		/* Disable Root's interrupt in response to error messages */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, &reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, &reg32);
  		reg32 &= ~ROOT_PORT_INTR_ON_MESG_MASK;
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, reg32);
  	}
  
 -	if (type == PCI_EXP_TYPE_RC_EC || type == PCI_EXP_TYPE_RC_END) {
 -		if (pcie_has_flr(dev)) {
 -			rc = pcie_flr(dev);
 -			pci_info(dev, "has been reset (%d)\n", rc);
 -		} else {
 -			pci_info(dev, "not reset (no FLR support)\n");
 -			rc = -ENOTTY;
 -		}
 -	} else {
 -		rc = pci_bus_error_reset(dev);
 -		pci_info(dev, "Root Port link has been reset (%d)\n", rc);
 -	}
 +	rc = pci_bus_error_reset(dev);
 +	pci_info(dev, "Root Port link has been reset (%d)\n", rc);
  
 -	if ((host->native_aer || pcie_ports_native) && aer) {
 +	if (pcie_aer_is_native(dev)) {
  		/* Clear Root Error Status */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_STATUS, &reg32);
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_STATUS, reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_STATUS, &reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_STATUS, reg32);
  
  		/* Enable Root Port's interrupt in response to error messages */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, &reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, &reg32);
  		reg32 |= ROOT_PORT_INTR_ON_MESG_MASK;
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, reg32);
  	}
  
  	return rc ? PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_RECOVERED;
* Unmerged path drivers/pci/pcie/aer.c
