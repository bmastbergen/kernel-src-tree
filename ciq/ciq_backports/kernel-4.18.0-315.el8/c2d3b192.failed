mt76: mt7915: add support for ipg in testmode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Shayne Chen <shayne.chen@mediatek.com>
commit c2d3b1926f30c5bfc634a500a6a3825716cb0b59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/c2d3b192.failed

Add support to calculate and apply ipg parameters in testmode
for MT7915 NIC.

	Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit c2d3b1926f30c5bfc634a500a6a3825716cb0b59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
index fe56ab18e974,21a052cef234..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
@@@ -130,15 -132,121 +130,120 @@@ mt7915_tm_set_trx(struct mt7915_dev *de
  				 sizeof(req), false);
  }
  
+ static int
+ mt7915_tm_set_slot_time(struct mt7915_phy *phy, u8 slot_time, u8 sifs)
+ {
+ 	struct mt7915_dev *dev = phy->dev;
+ 	struct mt7915_tm_cmd req = {
+ 		.testmode_en = !(phy->mt76->test.state == MT76_TM_STATE_OFF),
+ 		.param_idx = MCU_ATE_SET_SLOT_TIME,
+ 		.param.slot.slot_time = slot_time,
+ 		.param.slot.sifs = sifs,
+ 		.param.slot.rifs = 2,
+ 		.param.slot.eifs = cpu_to_le16(60),
+ 		.param.slot.band = phy != &dev->phy,
+ 	};
+ 
+ 	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_ATE_CTRL, &req,
+ 				 sizeof(req), false);
+ }
+ 
+ static int
+ mt7915_tm_set_wmm_qid(struct mt7915_dev *dev, u8 qid, u8 aifs, u8 cw_min,
+ 		      u16 cw_max, u16 txop)
+ {
+ 	struct mt7915_mcu_tx req = { .total = 1 };
+ 	struct edca *e = &req.edca[0];
+ 
+ 	e->queue = qid;
+ 	e->set = WMM_PARAM_SET;
+ 
+ 	e->aifs = aifs;
+ 	e->cw_min = cw_min;
+ 	e->cw_max = cpu_to_le16(cw_max);
+ 	e->txop = cpu_to_le16(txop);
+ 
+ 	return mt7915_mcu_update_edca(dev, &req);
+ }
+ 
+ static int
+ mt7915_tm_set_ipg_params(struct mt7915_phy *phy, u32 ipg, u8 mode)
+ {
+ #define TM_DEFAULT_SIFS	10
+ #define TM_MAX_SIFS	127
+ #define TM_MAX_AIFSN	0xf
+ #define TM_MIN_AIFSN	0x1
+ #define BBP_PROC_TIME	1500
+ 	struct mt7915_dev *dev = phy->dev;
+ 	u8 sig_ext = (mode == MT76_TM_TX_MODE_CCK) ? 0 : 6;
+ 	u8 slot_time = 9, sifs = TM_DEFAULT_SIFS;
+ 	u8 aifsn = TM_MIN_AIFSN;
+ 	u32 i2t_time, tr2t_time, txv_time;
+ 	bool ext_phy = phy != &dev->phy;
+ 	u16 cw = 0;
+ 
+ 	if (ipg < sig_ext + slot_time + sifs)
+ 		ipg = 0;
+ 
+ 	if (!ipg)
+ 		goto done;
+ 
+ 	ipg -= sig_ext;
+ 
+ 	if (ipg <= (TM_MAX_SIFS + slot_time)) {
+ 		sifs = ipg - slot_time;
+ 	} else {
+ 		u32 val = (ipg + slot_time) / slot_time;
+ 
+ 		while (val >>= 1)
+ 			cw++;
+ 
+ 		if (cw > 16)
+ 			cw = 16;
+ 
+ 		ipg -= ((1 << cw) - 1) * slot_time;
+ 
+ 		aifsn = ipg / slot_time;
+ 		if (aifsn > TM_MAX_AIFSN)
+ 			aifsn = TM_MAX_AIFSN;
+ 
+ 		ipg -= aifsn * slot_time;
+ 
+ 		if (ipg > TM_DEFAULT_SIFS) {
+ 			if (ipg < TM_MAX_SIFS)
+ 				sifs = ipg;
+ 			else
+ 				sifs = TM_MAX_SIFS;
+ 		}
+ 	}
+ done:
+ 	txv_time = mt76_get_field(dev, MT_TMAC_ATCR(ext_phy),
+ 				  MT_TMAC_ATCR_TXV_TOUT);
+ 	txv_time *= 50;	/* normal clock time */
+ 
+ 	i2t_time = (slot_time * 1000 - txv_time - BBP_PROC_TIME) / 50;
+ 	tr2t_time = (sifs * 1000 - txv_time - BBP_PROC_TIME) / 50;
+ 
+ 	mt76_set(dev, MT_TMAC_TRCR0(ext_phy),
+ 		 FIELD_PREP(MT_TMAC_TRCR0_TR2T_CHK, tr2t_time) |
+ 		 FIELD_PREP(MT_TMAC_TRCR0_I2T_CHK, i2t_time));
+ 
+ 	mt7915_tm_set_slot_time(phy, slot_time, sifs);
+ 
+ 	return mt7915_tm_set_wmm_qid(dev,
+ 				     mt7915_lmac_mapping(dev, IEEE80211_AC_BE),
+ 				     aifsn, cw, cw, 0);
+ }
+ 
  static void
 -mt7915_tm_reg_backup_restore(struct mt7915_phy *phy)
 +mt7915_tm_reg_backup_restore(struct mt7915_dev *dev, struct mt7915_phy *phy)
  {
  	int n_regs = ARRAY_SIZE(reg_backup_list);
 -	struct mt7915_dev *dev = phy->dev;
  	bool ext_phy = phy != &dev->phy;
 -	u32 *b = phy->test.reg_backup;
 +	u32 *b = dev->test.reg_backup;
  	int i;
  
 -	if (phy->mt76->test.state == MT76_TM_STATE_OFF) {
 +	if (dev->mt76.test.state == MT76_TM_STATE_OFF) {
  		for (i = 0; i < n_regs; i++)
  			mt76_wr(dev, reg_backup_list[i].band[ext_phy], b[i]);
  		return;
@@@ -201,29 -310,54 +306,59 @@@ mt7915_tm_set_tx_frames(struct mt7915_d
  {
  	static const u8 spe_idx_map[] = {0, 0, 1, 0, 3, 2, 4, 0,
  					 9, 8, 6, 10, 16, 12, 18, 0};
++<<<<<<< HEAD
 +	struct sk_buff *skb = dev->mt76.test.tx_skb;
++=======
+ 	struct mt76_testmode_data *td = &phy->mt76->test;
+ 	struct mt7915_dev *dev = phy->dev;
+ 	struct sk_buff *skb = td->tx_skb;
++>>>>>>> c2d3b1926f30 (mt76: mt7915: add support for ipg in testmode)
  	struct ieee80211_tx_info *info;
+ 	u8 duty_cycle = td->tx_duty_cycle;
+ 	u32 tx_time = td->tx_time;
+ 	u32 ipg = td->tx_ipg;
  
 -	mt7915_tm_set_trx(phy, TM_MAC_RX_RXV, false);
 +	mt7915_tm_set_trx(dev, &dev->phy, TM_MAC_RX_RXV, false);
  
  	if (en) {
 +		u8 tx_ant = dev->mt76.test.tx_antenna_mask;
 +
  		mutex_unlock(&dev->mt76.mutex);
 -		mt7915_set_channel(phy);
 +		mt7915_set_channel(&dev->phy);
  		mutex_lock(&dev->mt76.mutex);
  
 -		mt7915_mcu_set_chan_info(phy, MCU_EXT_CMD_SET_RX_PATH);
 -
 -		if (td->tx_spe_idx) {
 -			phy->test.spe_idx = td->tx_spe_idx;
 -		} else {
 -			u8 tx_ant = td->tx_antenna_mask;
 -
 -			if (phy != &dev->phy)
 -				tx_ant >>= 2;
 -			phy->test.spe_idx = spe_idx_map[tx_ant];
 -		}
 +		mt7915_mcu_set_chan_info(&dev->phy, MCU_EXT_CMD_SET_RX_PATH);
 +		dev->test.spe_idx = spe_idx_map[tx_ant];
  	}
  
++<<<<<<< HEAD
 +	mt7915_tm_set_trx(dev, &dev->phy, TM_MAC_TX, en);
++=======
+ 	/* if all three params are set, duty_cycle will be ignored */
+ 	if (duty_cycle && tx_time && !ipg) {
+ 		ipg = tx_time * 100 / duty_cycle - tx_time;
+ 	} else if (duty_cycle && !tx_time && ipg) {
+ 		if (duty_cycle < 100)
+ 			tx_time = duty_cycle * ipg / (100 - duty_cycle);
+ 	}
+ 
+ 	mt7915_tm_set_ipg_params(phy, ipg, td->tx_rate_mode);
+ 
+ 	if (ipg)
+ 		td->tx_queued_limit = MT76_TM_TIMEOUT * 1000000 / ipg / 2;
++>>>>>>> c2d3b1926f30 (mt76: mt7915: add support for ipg in testmode)
  
  	if (!en || !skb)
  		return;
  
  	info = IEEE80211_SKB_CB(skb);
++<<<<<<< HEAD
 +	info->control.vif = dev->phy.monitor_vif;
++=======
+ 	info->control.vif = phy->monitor_vif;
+ 
+ 	mt7915_tm_set_trx(phy, TM_MAC_TX, en);
++>>>>>>> c2d3b1926f30 (mt76: mt7915: add support for ipg in testmode)
  }
  
  static void
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
index 983973e5182c..4f3663f9ba16 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
@@ -49,6 +49,7 @@ enum {
 enum {
 	MCU_ATE_SET_TRX = 0x1,
 	MCU_ATE_SET_FREQ_OFFSET = 0xa,
+	MCU_ATE_SET_SLOT_TIME = 0x13,
 };
 
 struct mt7915_mcu_rxd {
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/regs.h b/drivers/net/wireless/mediatek/mt76/mt7915/regs.h
index fded019fc897..ba4754cf6182 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/regs.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/regs.h
@@ -59,6 +59,13 @@
 #define MT_TIMEOUT_VAL_PLCP		GENMASK(15, 0)
 #define MT_TIMEOUT_VAL_CCA		GENMASK(31, 16)
 
+#define MT_TMAC_ATCR(_band)		MT_WF_TMAC(_band, 0x098)
+#define MT_TMAC_ATCR_TXV_TOUT		GENMASK(7, 0)
+
+#define MT_TMAC_TRCR0(_band)		MT_WF_TMAC(_band, 0x09c)
+#define MT_TMAC_TRCR0_TR2T_CHK		GENMASK(8, 0)
+#define MT_TMAC_TRCR0_I2T_CHK		GENMASK(24, 16)
+
 #define MT_TMAC_ICR0(_band)		MT_WF_TMAC(_band, 0x0a4)
 #define MT_IFS_EIFS			GENMASK(8, 0)
 #define MT_IFS_RIFS			GENMASK(14, 10)
@@ -70,7 +77,6 @@
 #define MT_TMAC_CTCR0_INS_DDLMT_EN		BIT(17)
 #define MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN	BIT(18)
 
-#define MT_TMAC_TRCR0(_band)		MT_WF_TMAC(_band, 0x09c)
 #define MT_TMAC_TFCR0(_band)		MT_WF_TMAC(_band, 0x1e0)
 
 /* DMA Band 0 */
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/testmode.h b/drivers/net/wireless/mediatek/mt76/mt7915/testmode.h
index 964f2d7fde3a..784d4c948886 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/testmode.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/testmode.h
@@ -16,6 +16,16 @@ struct mt7915_tm_freq_offset {
 	__le32 freq_offset;
 };
 
+struct mt7915_tm_slot_time {
+	u8 slot_time;
+	u8 sifs;
+	u8 rifs;
+	u8 _rsv;
+	__le16 eifs;
+	u8 band;
+	u8 _rsv1[5];
+};
+
 struct mt7915_tm_cmd {
 	u8 testmode_en;
 	u8 param_idx;
@@ -24,6 +34,7 @@ struct mt7915_tm_cmd {
 		__le32 data;
 		struct mt7915_tm_trx trx;
 		struct mt7915_tm_freq_offset freq;
+		struct mt7915_tm_slot_time slot;
 		u8 test[72];
 	} param;
 } __packed;
