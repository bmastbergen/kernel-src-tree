PCI/ERR: Add pci_walk_bridge() to pcie_do_recovery()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Sean V Kelley <sean.v.kelley@intel.com>
commit 05e9ae19ab83881a0f33025bd1288e41e552a34b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/05e9ae19.failed

Consolidate subordinate bus checks with pci_walk_bus() into
pci_walk_bridge() for walking below potentially AER affected bridges.

Link: https://lore.kernel.org/r/20201121001036.8560-10-sean.v.kelley@intel.com
	Tested-by: Jonathan Cameron <Jonathan.Cameron@huawei.com> # non-native/no RCEC
	Signed-off-by: Sean V Kelley <sean.v.kelley@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 05e9ae19ab83881a0f33025bd1288e41e552a34b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pcie/err.c
diff --cc drivers/pci/pcie/err.c
index c74d622dbbc4,8b53aecdb43d..000000000000
--- a/drivers/pci/pcie/err.c
+++ b/drivers/pci/pcie/err.c
@@@ -146,29 -146,48 +146,58 @@@ out
  	return 0;
  }
  
+ /**
+  * pci_walk_bridge - walk bridges potentially AER affected
+  * @bridge:	bridge which may be a Port
+  * @cb:		callback to be called for each device found
+  * @userdata:	arbitrary pointer to be passed to callback
+  *
+  * If the device provided is a bridge, walk the subordinate bus, including
+  * any bridged devices on buses under this bus.  Call the provided callback
+  * on each device found.
+  */
+ static void pci_walk_bridge(struct pci_dev *bridge,
+ 			    int (*cb)(struct pci_dev *, void *),
+ 			    void *userdata)
+ {
+ 	if (bridge->subordinate)
+ 		pci_walk_bus(bridge->subordinate, cb, userdata);
+ }
+ 
  pci_ers_result_t pcie_do_recovery(struct pci_dev *dev,
 -		pci_channel_state_t state,
 -		pci_ers_result_t (*reset_subordinates)(struct pci_dev *pdev))
 +			enum pci_channel_state state,
 +			pci_ers_result_t (*reset_link)(struct pci_dev *pdev))
  {
  	int type = pci_pcie_type(dev);
++<<<<<<< HEAD
++=======
+ 	struct pci_dev *bridge;
++>>>>>>> 05e9ae19ab83 (PCI/ERR: Add pci_walk_bridge() to pcie_do_recovery())
  	pci_ers_result_t status = PCI_ERS_RESULT_CAN_RECOVER;
 +	struct pci_bus *bus;
  
  	/*
 -	 * Error recovery runs on all subordinates of the bridge.  If the
 -	 * bridge detected the error, it is cleared at the end.
 +	 * Error recovery runs on all subordinates of the first downstream port.
 +	 * If the downstream port detected the error, it is cleared at the end.
  	 */
 -	if (type == PCI_EXP_TYPE_ROOT_PORT ||
 -	    type == PCI_EXP_TYPE_DOWNSTREAM)
 -		bridge = dev;
 -	else
 -		bridge = pci_upstream_bridge(dev);
 +	if (!(type == PCI_EXP_TYPE_ROOT_PORT ||
 +	      type == PCI_EXP_TYPE_DOWNSTREAM))
 +		dev = pci_upstream_bridge(dev);
 +	bus = dev->subordinate;
  
++<<<<<<< HEAD
 +	pci_dbg(dev, "broadcast error_detected message\n");
 +	if (state == pci_channel_io_frozen) {
 +		pci_walk_bus(bus, report_frozen_detected, &status);
 +		status = reset_link(dev);
++=======
+ 	pci_dbg(bridge, "broadcast error_detected message\n");
+ 	if (state == pci_channel_io_frozen) {
+ 		pci_walk_bridge(bridge, report_frozen_detected, &status);
+ 		status = reset_subordinates(bridge);
++>>>>>>> 05e9ae19ab83 (PCI/ERR: Add pci_walk_bridge() to pcie_do_recovery())
  		if (status != PCI_ERS_RESULT_RECOVERED) {
 -			pci_warn(bridge, "subordinate device reset failed\n");
 +			pci_warn(dev, "link reset failed\n");
  			goto failed;
  		}
  	} else {
@@@ -177,8 -196,8 +206,13 @@@
  
  	if (status == PCI_ERS_RESULT_CAN_RECOVER) {
  		status = PCI_ERS_RESULT_RECOVERED;
++<<<<<<< HEAD
 +		pci_dbg(dev, "broadcast mmio_enabled message\n");
 +		pci_walk_bus(bus, report_mmio_enabled, &status);
++=======
+ 		pci_dbg(bridge, "broadcast mmio_enabled message\n");
+ 		pci_walk_bridge(bridge, report_mmio_enabled, &status);
++>>>>>>> 05e9ae19ab83 (PCI/ERR: Add pci_walk_bridge() to pcie_do_recovery())
  	}
  
  	if (status == PCI_ERS_RESULT_NEED_RESET) {
@@@ -188,20 -207,20 +222,30 @@@
  		 * drivers' slot_reset callbacks?
  		 */
  		status = PCI_ERS_RESULT_RECOVERED;
++<<<<<<< HEAD
 +		pci_dbg(dev, "broadcast slot_reset message\n");
 +		pci_walk_bus(bus, report_slot_reset, &status);
++=======
+ 		pci_dbg(bridge, "broadcast slot_reset message\n");
+ 		pci_walk_bridge(bridge, report_slot_reset, &status);
++>>>>>>> 05e9ae19ab83 (PCI/ERR: Add pci_walk_bridge() to pcie_do_recovery())
  	}
  
  	if (status != PCI_ERS_RESULT_RECOVERED)
  		goto failed;
  
++<<<<<<< HEAD
 +	pci_dbg(dev, "broadcast resume message\n");
 +	pci_walk_bus(bus, report_resume, &status);
++=======
+ 	pci_dbg(bridge, "broadcast resume message\n");
+ 	pci_walk_bridge(bridge, report_resume, &status);
++>>>>>>> 05e9ae19ab83 (PCI/ERR: Add pci_walk_bridge() to pcie_do_recovery())
  
 -	if (pcie_aer_is_native(bridge))
 -		pcie_clear_device_status(bridge);
 -	pci_aer_clear_nonfatal_status(bridge);
 -	pci_info(bridge, "device recovery successful\n");
 +	if (pcie_aer_is_native(dev))
 +		pcie_clear_device_status(dev);
 +	pci_aer_clear_nonfatal_status(dev);
 +	pci_info(dev, "device recovery successful\n");
  	return status;
  
  failed:
* Unmerged path drivers/pci/pcie/err.c
