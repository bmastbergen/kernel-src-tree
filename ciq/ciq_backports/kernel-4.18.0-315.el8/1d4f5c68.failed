mt76: mt7921: get rid of useless MT76_STATE_PM in mt7921_mac_work

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 1d4f5c68a0ed1838383013b3aca69a124b2dc9ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/1d4f5c68.failed

Remove useless MT76_STATE_PM check in mt7921_mac_work since
mt7921_mutex_acquire will wake up the device if necessary

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 1d4f5c68a0ed1838383013b3aca69a124b2dc9ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7921/mac.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index bcbd59a23f9b,5dcb574a2768..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@@ -1355,7 -1493,7 +1355,11 @@@ void mt7921_mac_work(struct work_struc
  					       mac_work.work);
  	phy = mphy->priv;
  
++<<<<<<< HEAD
 +	mutex_lock(&mphy->dev->mutex);
++=======
+ 	mt7921_mutex_acquire(phy->dev);
++>>>>>>> 1d4f5c68a0ed (mt76: mt7921: get rid of useless MT76_STATE_PM in mt7921_mac_work)
  
  	mt76_update_survey(mphy->dev);
  	if (++mphy->mac_work_count == 5) {
@@@ -1368,8 -1506,121 +1372,13 @@@
  		mt7921_mac_sta_stats_work(phy);
  	}
  
++<<<<<<< HEAD
 +	mutex_unlock(&mphy->dev->mutex);
 +
 +	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
++=======
+ 	mt7921_mutex_release(phy->dev);
+ 	ieee80211_queue_delayed_work(phy->mt76->hw, &mphy->mac_work,
++>>>>>>> 1d4f5c68a0ed (mt76: mt7921: get rid of useless MT76_STATE_PM in mt7921_mac_work)
  				     MT7921_WATCHDOG_TIME);
  }
 -
 -void mt7921_pm_wake_work(struct work_struct *work)
 -{
 -	struct mt7921_dev *dev;
 -	struct mt76_phy *mphy;
 -
 -	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
 -						pm.wake_work);
 -	mphy = dev->phy.mt76;
 -
 -	if (!mt7921_mcu_drv_pmctrl(dev)) {
 -		int i;
 -
 -		mt76_for_each_q_rx(&dev->mt76, i)
 -			napi_schedule(&dev->mt76.napi[i]);
 -		mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
 -		mt7921_tx_cleanup(dev);
 -	}
 -
 -	ieee80211_wake_queues(mphy->hw);
 -	complete_all(&dev->pm.wake_cmpl);
 -}
 -
 -void mt7921_pm_power_save_work(struct work_struct *work)
 -{
 -	struct mt7921_dev *dev;
 -	unsigned long delta;
 -
 -	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
 -						pm.ps_work.work);
 -
 -	delta = dev->pm.idle_timeout;
 -	if (time_is_after_jiffies(dev->pm.last_activity + delta)) {
 -		delta = dev->pm.last_activity + delta - jiffies;
 -		goto out;
 -	}
 -
 -	if (!mt7921_mcu_fw_pmctrl(dev))
 -		return;
 -out:
 -	queue_delayed_work(dev->mt76.wq, &dev->pm.ps_work, delta);
 -}
 -
 -int mt7921_mac_set_beacon_filter(struct mt7921_phy *phy,
 -				 struct ieee80211_vif *vif,
 -				 bool enable)
 -{
 -	struct mt7921_dev *dev = phy->dev;
 -	bool ext_phy = phy != &dev->phy;
 -	int err;
 -
 -	if (!dev->pm.enable)
 -		return -EOPNOTSUPP;
 -
 -	err = mt7921_mcu_set_bss_pm(dev, vif, enable);
 -	if (err)
 -		return err;
 -
 -	if (enable) {
 -		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
 -		mt76_set(dev, MT_WF_RFCR(ext_phy),
 -			 MT_WF_RFCR_DROP_OTHER_BEACON);
 -	} else {
 -		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
 -		mt76_clear(dev, MT_WF_RFCR(ext_phy),
 -			   MT_WF_RFCR_DROP_OTHER_BEACON);
 -	}
 -
 -	return 0;
 -}
 -
 -void mt7921_coredump_work(struct work_struct *work)
 -{
 -	struct mt7921_dev *dev;
 -	char *dump, *data;
 -
 -	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
 -						coredump.work.work);
 -
 -	if (time_is_after_jiffies(dev->coredump.last_activity +
 -				  4 * MT76_CONNAC_COREDUMP_TIMEOUT)) {
 -		queue_delayed_work(dev->mt76.wq, &dev->coredump.work,
 -				   MT76_CONNAC_COREDUMP_TIMEOUT);
 -		return;
 -	}
 -
 -	dump = vzalloc(MT76_CONNAC_COREDUMP_SZ);
 -	data = dump;
 -
 -	while (true) {
 -		struct sk_buff *skb;
 -
 -		spin_lock_bh(&dev->mt76.lock);
 -		skb = __skb_dequeue(&dev->coredump.msg_list);
 -		spin_unlock_bh(&dev->mt76.lock);
 -
 -		if (!skb)
 -			break;
 -
 -		skb_pull(skb, sizeof(struct mt7921_mcu_rxd));
 -		if (data + skb->len - dump > MT76_CONNAC_COREDUMP_SZ) {
 -			dev_kfree_skb(skb);
 -			continue;
 -		}
 -
 -		memcpy(data, skb->data, skb->len);
 -		data += skb->len;
 -
 -		dev_kfree_skb(skb);
 -	}
 -	dev_coredumpv(dev->mt76.dev, dump, MT76_CONNAC_COREDUMP_SZ,
 -		      GFP_KERNEL);
 -	mt7921_reset(&dev->mt76);
 -}
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mac.c
