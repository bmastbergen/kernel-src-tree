net: ena: add device distinct log prefix to files

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Shay Agroskin <shayagr@amazon.com>
commit da580ca8de2c74c242b5e4eaa7e8ccc67322598a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/da580ca8.failed

ENA logs are adjusted to display the full ENA representation to
distinct each ENA device in case of multiple interfaces.
Using netdev_err/warn and dev_info functions for logging provides
uniform printing with clear distinction of the device and interface.

This patch changes all printing in ena_com files to use netev_* logging
functions except for messages of info level. Log functions of that level
would be printed with dev_info because of the early stage they are
called in when net_device struct isn't yet registered.

To allow using netdev_* functions in all ena_com functions, a pointer to
the net_device was added to ena_com_dev struct.

The patch also adds some log messages to make driver debugging easier.

	Signed-off-by: Amit Bernstein <amitbern@amazon.com>
	Signed-off-by: Shay Agroskin <shayagr@amazon.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit da580ca8de2c74c242b5e4eaa7e8ccc67322598a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amazon/ena/ena_com.c
#	drivers/net/ethernet/amazon/ena/ena_eth_com.c
#	drivers/net/ethernet/amazon/ena/ena_eth_com.h
#	drivers/net/ethernet/amazon/ena/ena_netdev.c
diff --cc drivers/net/ethernet/amazon/ena/ena_com.c
index d02aeb5b8e86,e168edf3c930..000000000000
--- a/drivers/net/ethernet/amazon/ena/ena_com.c
+++ b/drivers/net/ethernet/amazon/ena/ena_com.c
@@@ -71,7 -71,8 +71,12 @@@ static int ena_com_mem_addr_set(struct 
  				       dma_addr_t addr)
  {
  	if ((addr & GENMASK_ULL(ena_dev->dma_addr_bits - 1, 0)) != addr) {
++<<<<<<< HEAD
 +		pr_err("dma address has more bits that the device supports\n");
++=======
+ 		netdev_err(ena_dev->net_device,
+ 			   "DMA address has more bits that the device supports\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -EINVAL;
  	}
  
@@@ -81,16 -82,17 +86,26 @@@
  	return 0;
  }
  
 -static int ena_com_admin_init_sq(struct ena_com_admin_queue *admin_queue)
 +static int ena_com_admin_init_sq(struct ena_com_admin_queue *queue)
  {
++<<<<<<< HEAD
 +	struct ena_com_admin_sq *sq = &queue->sq;
 +	u16 size = ADMIN_SQ_SIZE(queue->q_depth);
++=======
+ 	struct ena_com_dev *ena_dev = admin_queue->ena_dev;
+ 	struct ena_com_admin_sq *sq = &admin_queue->sq;
+ 	u16 size = ADMIN_SQ_SIZE(admin_queue->q_depth);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
 -	sq->entries = dma_alloc_coherent(admin_queue->q_dmadev, size,
 -					 &sq->dma_addr, GFP_KERNEL);
 +	sq->entries = dma_zalloc_coherent(queue->q_dmadev, size, &sq->dma_addr,
 +					  GFP_KERNEL);
  
  	if (!sq->entries) {
++<<<<<<< HEAD
 +		pr_err("memory allocation failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory allocation failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -ENOMEM;
  	}
  
@@@ -103,16 -105,17 +118,26 @@@
  	return 0;
  }
  
 -static int ena_com_admin_init_cq(struct ena_com_admin_queue *admin_queue)
 +static int ena_com_admin_init_cq(struct ena_com_admin_queue *queue)
  {
++<<<<<<< HEAD
 +	struct ena_com_admin_cq *cq = &queue->cq;
 +	u16 size = ADMIN_CQ_SIZE(queue->q_depth);
++=======
+ 	struct ena_com_dev *ena_dev = admin_queue->ena_dev;
+ 	struct ena_com_admin_cq *cq = &admin_queue->cq;
+ 	u16 size = ADMIN_CQ_SIZE(admin_queue->q_depth);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
 -	cq->entries = dma_alloc_coherent(admin_queue->q_dmadev, size,
 -					 &cq->dma_addr, GFP_KERNEL);
 +	cq->entries = dma_zalloc_coherent(queue->q_dmadev, size, &cq->dma_addr,
 +					  GFP_KERNEL);
  
  	if (!cq->entries) {
++<<<<<<< HEAD
 +		pr_err("memory allocation failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory allocation failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -ENOMEM;
  	}
  
@@@ -129,13 -132,13 +154,17 @@@ static int ena_com_admin_init_aenq(stru
  	u32 addr_low, addr_high, aenq_caps;
  	u16 size;
  
 -	ena_dev->aenq.q_depth = ENA_ASYNC_QUEUE_DEPTH;
 +	dev->aenq.q_depth = ENA_ASYNC_QUEUE_DEPTH;
  	size = ADMIN_AENQ_SIZE(ENA_ASYNC_QUEUE_DEPTH);
 -	aenq->entries = dma_alloc_coherent(ena_dev->dmadev, size,
 -					   &aenq->dma_addr, GFP_KERNEL);
 +	aenq->entries = dma_zalloc_coherent(dev->dmadev, size, &aenq->dma_addr,
 +					    GFP_KERNEL);
  
  	if (!aenq->entries) {
++<<<<<<< HEAD
 +		pr_err("memory allocation failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory allocation failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -ENOMEM;
  	}
  
@@@ -153,10 -156,11 +182,15 @@@
  	aenq_caps |= (sizeof(struct ena_admin_aenq_entry)
  		      << ENA_REGS_AENQ_CAPS_AENQ_ENTRY_SIZE_SHIFT) &
  		     ENA_REGS_AENQ_CAPS_AENQ_ENTRY_SIZE_MASK;
 -	writel(aenq_caps, ena_dev->reg_bar + ENA_REGS_AENQ_CAPS_OFF);
 +	writel(aenq_caps, dev->reg_bar + ENA_REGS_AENQ_CAPS_OFF);
  
  	if (unlikely(!aenq_handlers)) {
++<<<<<<< HEAD
 +		pr_err("aenq handlers pointer is NULL\n");
++=======
+ 		netdev_err(ena_dev->net_device,
+ 			   "AENQ handlers pointer is NULL\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -EINVAL;
  	}
  
@@@ -172,22 -176,25 +206,41 @@@ static void comp_ctxt_release(struct en
  	atomic_dec(&queue->outstanding_cmds);
  }
  
 -static struct ena_comp_ctx *get_comp_ctxt(struct ena_com_admin_queue *admin_queue,
 +static struct ena_comp_ctx *get_comp_ctxt(struct ena_com_admin_queue *queue,
  					  u16 command_id, bool capture)
  {
++<<<<<<< HEAD
 +	if (unlikely(command_id >= queue->q_depth)) {
 +		pr_err("command id is larger than the queue size. cmd_id: %u queue size %d\n",
 +		       command_id, queue->q_depth);
 +		return NULL;
 +	}
 +
 +	if (unlikely(!queue->comp_ctx)) {
 +		pr_err("Completion context is NULL\n");
 +		return NULL;
 +	}
 +
 +	if (unlikely(queue->comp_ctx[command_id].occupied && capture)) {
 +		pr_err("Completion context is occupied\n");
++=======
+ 	if (unlikely(command_id >= admin_queue->q_depth)) {
+ 		netdev_err(admin_queue->ena_dev->net_device,
+ 			   "Command id is larger than the queue size. cmd_id: %u queue size %d\n",
+ 			   command_id, admin_queue->q_depth);
+ 		return NULL;
+ 	}
+ 
+ 	if (unlikely(!admin_queue->comp_ctx)) {
+ 		netdev_err(admin_queue->ena_dev->net_device,
+ 			   "Completion context is NULL\n");
+ 		return NULL;
+ 	}
+ 
+ 	if (unlikely(admin_queue->comp_ctx[command_id].occupied && capture)) {
+ 		netdev_err(admin_queue->ena_dev->net_device,
+ 			   "Completion context is occupied\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return NULL;
  	}
  
@@@ -217,7 -224,8 +270,12 @@@ static struct ena_comp_ctx *__ena_com_s
  	/* In case of queue FULL */
  	cnt = (u16)atomic_read(&admin_queue->outstanding_cmds);
  	if (cnt >= admin_queue->q_depth) {
++<<<<<<< HEAD
 +		pr_debug("admin queue is full.\n");
++=======
+ 		netdev_dbg(admin_queue->ena_dev->net_device,
+ 			   "Admin queue is full.\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		admin_queue->stats.out_of_space++;
  		return ERR_PTR(-ENOSPC);
  	}
@@@ -257,15 -265,17 +315,27 @@@
  	return comp_ctx;
  }
  
 -static int ena_com_init_comp_ctxt(struct ena_com_admin_queue *admin_queue)
 +static int ena_com_init_comp_ctxt(struct ena_com_admin_queue *queue)
  {
++<<<<<<< HEAD
 +	size_t size = queue->q_depth * sizeof(struct ena_comp_ctx);
 +	struct ena_comp_ctx *comp_ctx;
 +	u16 i;
 +
 +	queue->comp_ctx = devm_kzalloc(queue->q_dmadev, size, GFP_KERNEL);
 +	if (unlikely(!queue->comp_ctx)) {
 +		pr_err("memory allocation failed\n");
++=======
+ 	struct ena_com_dev *ena_dev = admin_queue->ena_dev;
+ 	size_t size = admin_queue->q_depth * sizeof(struct ena_comp_ctx);
+ 	struct ena_comp_ctx *comp_ctx;
+ 	u16 i;
+ 
+ 	admin_queue->comp_ctx =
+ 		devm_kzalloc(admin_queue->q_dmadev, size, GFP_KERNEL);
+ 	if (unlikely(!admin_queue->comp_ctx)) {
+ 		netdev_err(ena_dev->net_device, "Memory allocation failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -ENOMEM;
  	}
  
@@@ -336,7 -346,8 +406,12 @@@ static int ena_com_init_io_sq(struct en
  		}
  
  		if (!io_sq->desc_addr.virt_addr) {
++<<<<<<< HEAD
 +			pr_err("memory allocation failed\n");
++=======
+ 			netdev_err(ena_dev->net_device,
+ 				   "Memory allocation failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  			return -ENOMEM;
  		}
  	}
@@@ -362,7 -373,8 +437,12 @@@
  				devm_kzalloc(ena_dev->dmadev, size, GFP_KERNEL);
  
  		if (!io_sq->bounce_buf_ctrl.base_buffer) {
++<<<<<<< HEAD
 +			pr_err("bounce buffer memory allocation failed\n");
++=======
+ 			netdev_err(ena_dev->net_device,
+ 				   "Bounce buffer memory allocation failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  			return -ENOMEM;
  		}
  
@@@ -422,7 -434,7 +502,11 @@@ static int ena_com_init_io_cq(struct en
  	}
  
  	if (!io_cq->cdesc_addr.virt_addr) {
++<<<<<<< HEAD
 +		pr_err("memory allocation failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory allocation failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -ENOMEM;
  	}
  
@@@ -495,10 -508,12 +580,16 @@@ static void ena_com_handle_admin_comple
  	admin_queue->stats.completed_cmd += comp_num;
  }
  
- static int ena_com_comp_status_to_errno(u8 comp_status)
+ static int ena_com_comp_status_to_errno(struct ena_com_admin_queue *admin_queue,
+ 					u8 comp_status)
  {
  	if (unlikely(comp_status != 0))
++<<<<<<< HEAD
 +		pr_err("admin command failed[%u]\n", comp_status);
++=======
+ 		netdev_err(admin_queue->ena_dev->net_device,
+ 			   "Admin command failed[%u]\n", comp_status);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  	switch (comp_status) {
  	case ENA_ADMIN_SUCCESS:
@@@ -692,7 -715,8 +791,12 @@@ static int ena_com_config_llq_info(stru
  		/* The desc list entry size should be whole multiply of 8
  		 * This requirement comes from __iowrite64_copy()
  		 */
++<<<<<<< HEAD
 +		pr_err("illegal entry size %d\n", llq_info->desc_list_entry_size);
++=======
+ 		netdev_err(ena_dev->net_device, "Illegal entry size %d\n",
+ 			   llq_info->desc_list_entry_size);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -EINVAL;
  	}
  
@@@ -833,9 -862,10 +942,16 @@@ static u32 ena_com_reg_bar_read32(struc
  	}
  
  	if (unlikely(i == timeout)) {
++<<<<<<< HEAD
 +		pr_err("reading reg failed for timeout. expected: req id[%hu] offset[%hu] actual: req id[%hu] offset[%hu]\n",
 +		       mmio_read->seq_num, offset, read_resp->req_id,
 +		       read_resp->reg_off);
++=======
+ 		netdev_err(ena_dev->net_device,
+ 			   "Reading reg failed for timeout. expected: req id[%hu] offset[%hu] actual: req id[%hu] offset[%hu]\n",
+ 			   mmio_read->seq_num, offset, read_resp->req_id,
+ 			   read_resp->reg_off);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		ret = ENA_MMIO_READ_TIMEOUT;
  		goto err;
  	}
@@@ -900,7 -931,8 +1017,12 @@@ static int ena_com_destroy_io_sq(struc
  					    sizeof(destroy_resp));
  
  	if (unlikely(ret && (ret != -ENODEV)))
++<<<<<<< HEAD
 +		pr_err("failed to destroy io sq error: %d\n", ret);
++=======
+ 		netdev_err(ena_dev->net_device,
+ 			   "Failed to destroy io sq error: %d\n", ret);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  	return ret;
  }
@@@ -1009,7 -1043,7 +1133,11 @@@ static int ena_com_get_feature_ex(struc
  				   &get_cmd.control_buffer.address,
  				   control_buf_dma_addr);
  	if (unlikely(ret)) {
++<<<<<<< HEAD
 +		pr_err("memory address set failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory address set failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return ret;
  	}
  
@@@ -1129,9 -1164,10 +1258,16 @@@ static int ena_com_indirect_table_alloc
  
  	if ((get_resp.u.ind_table.min_size > log_size) ||
  	    (get_resp.u.ind_table.max_size < log_size)) {
++<<<<<<< HEAD
 +		pr_err("indirect table size doesn't fit. requested size: %d while min is:%d and max %d\n",
 +		       1 << log_size, 1 << get_resp.u.ind_table.min_size,
 +		       1 << get_resp.u.ind_table.max_size);
++=======
+ 		netdev_err(ena_dev->net_device,
+ 			   "Indirect table size doesn't fit. requested size: %d while min is:%d and max %d\n",
+ 			   1 << log_size, 1 << get_resp.u.ind_table.min_size,
+ 			   1 << get_resp.u.ind_table.max_size);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -EINVAL;
  	}
  
@@@ -1222,7 -1258,8 +1358,12 @@@ static int ena_com_create_io_sq(struct 
  					   &create_cmd.sq_ba,
  					   io_sq->desc_addr.phys_addr);
  		if (unlikely(ret)) {
++<<<<<<< HEAD
 +			pr_err("memory address set failed\n");
++=======
+ 			netdev_err(ena_dev->net_device,
+ 				   "Memory address set failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  			return ret;
  		}
  	}
@@@ -1251,7 -1289,8 +1393,12 @@@
  			cmd_completion.llq_descriptors_offset);
  	}
  
++<<<<<<< HEAD
 +	pr_debug("created sq[%u], depth[%u]\n", io_sq->idx, io_sq->q_depth);
++=======
+ 	netdev_dbg(ena_dev->net_device, "Created sq[%u], depth[%u]\n",
+ 		   io_sq->idx, io_sq->q_depth);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  	return ret;
  }
@@@ -1364,7 -1408,7 +1516,11 @@@ int ena_com_create_io_cq(struct ena_com
  				   &create_cmd.cq_ba,
  				   io_cq->cdesc_addr.phys_addr);
  	if (unlikely(ret)) {
++<<<<<<< HEAD
 +		pr_err("memory address set failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory address set failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return ret;
  	}
  
@@@ -1393,7 -1438,8 +1550,12 @@@
  			(u32 __iomem *)((uintptr_t)ena_dev->reg_bar +
  			cmd_completion.numa_node_register_offset);
  
++<<<<<<< HEAD
 +	pr_debug("created cq[%u], depth[%u]\n", io_cq->idx, io_cq->q_depth);
++=======
+ 	netdev_dbg(ena_dev->net_device, "Created cq[%u], depth[%u]\n",
+ 		   io_cq->idx, io_cq->q_depth);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  	return ret;
  }
@@@ -1586,19 -1637,20 +1753,36 @@@ int ena_com_validate_version(struct ena
  		return -ETIME;
  	}
  
++<<<<<<< HEAD
 +	pr_info("ena device version: %d.%d\n",
 +		(ver & ENA_REGS_VERSION_MAJOR_VERSION_MASK) >>
 +			ENA_REGS_VERSION_MAJOR_VERSION_SHIFT,
 +		ver & ENA_REGS_VERSION_MINOR_VERSION_MASK);
 +
 +	pr_info("ena controller version: %d.%d.%d implementation version %d\n",
 +		(ctrl_ver & ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_MASK) >>
 +			ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_SHIFT,
 +		(ctrl_ver & ENA_REGS_CONTROLLER_VERSION_MINOR_VERSION_MASK) >>
 +			ENA_REGS_CONTROLLER_VERSION_MINOR_VERSION_SHIFT,
 +		(ctrl_ver & ENA_REGS_CONTROLLER_VERSION_SUBMINOR_VERSION_MASK),
 +		(ctrl_ver & ENA_REGS_CONTROLLER_VERSION_IMPL_ID_MASK) >>
 +			ENA_REGS_CONTROLLER_VERSION_IMPL_ID_SHIFT);
++=======
+ 	dev_info(ena_dev->dmadev, "ENA device version: %d.%d\n",
+ 		 (ver & ENA_REGS_VERSION_MAJOR_VERSION_MASK) >>
+ 			 ENA_REGS_VERSION_MAJOR_VERSION_SHIFT,
+ 		 ver & ENA_REGS_VERSION_MINOR_VERSION_MASK);
+ 
+ 	dev_info(ena_dev->dmadev,
+ 		 "ENA controller version: %d.%d.%d implementation version %d\n",
+ 		 (ctrl_ver & ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_MASK) >>
+ 			 ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_SHIFT,
+ 		 (ctrl_ver & ENA_REGS_CONTROLLER_VERSION_MINOR_VERSION_MASK) >>
+ 			 ENA_REGS_CONTROLLER_VERSION_MINOR_VERSION_SHIFT,
+ 		 (ctrl_ver & ENA_REGS_CONTROLLER_VERSION_SUBMINOR_VERSION_MASK),
+ 		 (ctrl_ver & ENA_REGS_CONTROLLER_VERSION_IMPL_ID_MASK) >>
+ 			 ENA_REGS_CONTROLLER_VERSION_IMPL_ID_SHIFT);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  	ctrl_ver_masked =
  		(ctrl_ver & ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_MASK) |
@@@ -2019,12 -2088,14 +2207,20 @@@ void ena_com_aenq_intr_handler(struct e
  		dma_rmb();
  
  		timestamp = (u64)aenq_common->timestamp_low |
++<<<<<<< HEAD
 +			    ((u64)aenq_common->timestamp_high << 32);
 +		pr_debug("AENQ! Group[%x] Syndrom[%x] timestamp: [%llus]\n",
 +			 aenq_common->group, aenq_common->syndrom, timestamp);
++=======
+ 			((u64)aenq_common->timestamp_high << 32);
+ 
+ 		netdev_dbg(ena_dev->net_device,
+ 			   "AENQ! Group[%x] Syndrome[%x] timestamp: [%llus]\n",
+ 			   aenq_common->group, aenq_common->syndrome, timestamp);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  		/* Handle specific event*/
 -		handler_cb = ena_com_get_specific_aenq_cb(ena_dev,
 +		handler_cb = ena_com_get_specific_aenq_cb(dev,
  							  aenq_common->group);
  		handler_cb(data, aenq_e); /* call the actual event handler*/
  
@@@ -2262,7 -2342,7 +2466,11 @@@ int ena_com_set_hash_function(struct en
  				   &cmd.control_buffer.address,
  				   rss->hash_key_dma_addr);
  	if (unlikely(ret)) {
++<<<<<<< HEAD
 +		pr_err("memory address set failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory address set failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return ret;
  	}
  
@@@ -2432,7 -2516,7 +2644,11 @@@ int ena_com_set_hash_ctrl(struct ena_co
  				   &cmd.control_buffer.address,
  				   rss->hash_ctrl_dma_addr);
  	if (unlikely(ret)) {
++<<<<<<< HEAD
 +		pr_err("memory address set failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory address set failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return ret;
  	}
  	cmd.control_buffer.length = sizeof(*hash_ctrl);
@@@ -2493,9 -2578,10 +2710,16 @@@ int ena_com_set_default_hash_ctrl(struc
  		available_fields = hash_ctrl->selected_fields[i].fields &
  				hash_ctrl->supported_fields[i].fields;
  		if (available_fields != hash_ctrl->selected_fields[i].fields) {
++<<<<<<< HEAD
 +			pr_err("hash control doesn't support all the desire configuration. proto %x supported %x selected %x\n",
 +			       i, hash_ctrl->supported_fields[i].fields,
 +			       hash_ctrl->selected_fields[i].fields);
++=======
+ 			netdev_err(ena_dev->net_device,
+ 				   "Hash control doesn't support all the desire configuration. proto %x supported %x selected %x\n",
+ 				   i, hash_ctrl->supported_fields[i].fields,
+ 				   hash_ctrl->selected_fields[i].fields);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  			return -EOPNOTSUPP;
  		}
  	}
@@@ -2531,8 -2618,9 +2756,14 @@@ int ena_com_fill_hash_ctrl(struct ena_c
  	/* Make sure all the fields are supported */
  	supported_fields = hash_ctrl->supported_fields[proto].fields;
  	if ((hash_fields & supported_fields) != hash_fields) {
++<<<<<<< HEAD
 +		pr_err("proto %d doesn't support the required fields %x. supports only: %x\n",
 +		       proto, hash_fields, supported_fields);
++=======
+ 		netdev_err(ena_dev->net_device,
+ 			   "Proto %d doesn't support the required fields %x. supports only: %x\n",
+ 			   proto, hash_fields, supported_fields);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  	}
  
  	hash_ctrl->selected_fields[proto].fields = hash_fields;
@@@ -2596,7 -2685,7 +2828,11 @@@ int ena_com_indirect_table_set(struct e
  				   &cmd.control_buffer.address,
  				   rss->rss_ind_tbl_dma_addr);
  	if (unlikely(ret)) {
++<<<<<<< HEAD
 +		pr_err("memory address set failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory address set failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return ret;
  	}
  
@@@ -2766,7 -2856,7 +3003,11 @@@ int ena_com_set_host_attributes(struct 
  				   &cmd.u.host_attr.debug_ba,
  				   host_attr->debug_area_dma_addr);
  	if (unlikely(ret)) {
++<<<<<<< HEAD
 +		pr_err("memory address set failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory address set failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return ret;
  	}
  
@@@ -2774,7 -2864,7 +3015,11 @@@
  				   &cmd.u.host_attr.os_info_ba,
  				   host_attr->host_info_dma_addr);
  	if (unlikely(ret)) {
++<<<<<<< HEAD
 +		pr_err("memory address set failed\n");
++=======
+ 		netdev_err(ena_dev->net_device, "Memory address set failed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return ret;
  	}
  
@@@ -2893,7 -2990,8 +3145,12 @@@ int ena_com_config_dev_mode(struct ena_
  		(llq_info->descs_num_before_header * sizeof(struct ena_eth_io_tx_desc));
  
  	if (unlikely(ena_dev->tx_max_header_size == 0)) {
++<<<<<<< HEAD
 +		pr_err("the size of the LLQ entry is smaller than needed\n");
++=======
+ 		netdev_err(ena_dev->net_device,
+ 			   "The size of the LLQ entry is smaller than needed\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -EINVAL;
  	}
  
diff --cc drivers/net/ethernet/amazon/ena/ena_eth_com.c
index 48576a99e52b,85daeac219ec..000000000000
--- a/drivers/net/ethernet/amazon/ena/ena_eth_com.c
+++ b/drivers/net/ethernet/amazon/ena/ena_eth_com.c
@@@ -62,8 -64,9 +63,14 @@@ static int ena_com_write_bounce_buffer_
  		}
  
  		io_sq->entries_in_tx_burst_left--;
++<<<<<<< HEAD
 +		pr_debug("decreasing entries_in_tx_burst_left of queue %d to %d\n",
 +			 io_sq->qid, io_sq->entries_in_tx_burst_left);
++=======
+ 		netdev_dbg(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 			   "Decreasing entries_in_tx_burst_left of queue %d to %d\n",
+ 			   io_sq->qid, io_sq->entries_in_tx_burst_left);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  	}
  
  	/* Make sure everything was written into the bounce buffer before
@@@ -101,12 -104,14 +108,22 @@@ static int ena_com_write_header_to_boun
  
  	if (unlikely((header_offset + header_len) >
  		     llq_info->desc_list_entry_size)) {
++<<<<<<< HEAD
 +		pr_err("trying to write header larger than llq entry can accommodate\n");
++=======
+ 		netdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 			   "Trying to write header larger than llq entry can accommodate\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -EFAULT;
  	}
  
  	if (unlikely(!bounce_buffer)) {
++<<<<<<< HEAD
 +		pr_err("bounce buffer is NULL\n");
++=======
+ 		netdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 			   "Bounce buffer is NULL\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -EFAULT;
  	}
  
@@@ -124,7 -129,8 +141,12 @@@ static void *get_sq_desc_llq(struct ena
  	bounce_buffer = pkt_ctrl->curr_bounce_buf;
  
  	if (unlikely(!bounce_buffer)) {
++<<<<<<< HEAD
 +		pr_err("bounce buffer is NULL\n");
++=======
+ 		netdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 			   "Bounce buffer is NULL\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return NULL;
  	}
  
@@@ -248,8 -255,9 +270,14 @@@ static u16 ena_com_cdesc_rx_pkt_get(str
  		io_cq->cur_rx_pkt_cdesc_count = 0;
  		io_cq->cur_rx_pkt_cdesc_start_idx = head_masked;
  
++<<<<<<< HEAD
 +		pr_debug("ena q_id: %d packets were completed. first desc idx %u descs# %d\n",
 +			 io_cq->qid, *first_cdesc_idx, count);
++=======
+ 		netdev_dbg(ena_com_io_cq_to_ena_dev(io_cq)->net_device,
+ 			   "ENA q_id: %d packets were completed. first desc idx %u descs# %d\n",
+ 			   io_cq->qid, *first_cdesc_idx, count);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  	} else {
  		io_cq->cur_rx_pkt_cdesc_count += count;
  		count = 0;
@@@ -333,8 -341,9 +361,14 @@@ static int ena_com_create_and_store_tx_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void ena_com_rx_set_flags(struct ena_com_rx_ctx *ena_rx_ctx,
 +					struct ena_eth_io_rx_cdesc_base *cdesc)
++=======
+ static void ena_com_rx_set_flags(struct ena_com_io_cq *io_cq,
+ 				 struct ena_com_rx_ctx *ena_rx_ctx,
+ 				 struct ena_eth_io_rx_cdesc_base *cdesc)
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  {
  	ena_rx_ctx->l3_proto = cdesc->status &
  		ENA_ETH_IO_RX_CDESC_BASE_L3_PROTO_IDX_MASK;
@@@ -355,10 -364,11 +389,18 @@@
  		(cdesc->status & ENA_ETH_IO_RX_CDESC_BASE_IPV4_FRAG_MASK) >>
  		ENA_ETH_IO_RX_CDESC_BASE_IPV4_FRAG_SHIFT;
  
++<<<<<<< HEAD
 +	pr_debug("ena_rx_ctx->l3_proto %d ena_rx_ctx->l4_proto %d\nena_rx_ctx->l3_csum_err %d ena_rx_ctx->l4_csum_err %d\nhash frag %d frag: %d cdesc_status: %x\n",
 +		 ena_rx_ctx->l3_proto, ena_rx_ctx->l4_proto,
 +		 ena_rx_ctx->l3_csum_err, ena_rx_ctx->l4_csum_err,
 +		 ena_rx_ctx->hash, ena_rx_ctx->frag, cdesc->status);
++=======
+ 	netdev_dbg(ena_com_io_cq_to_ena_dev(io_cq)->net_device,
+ 		   "l3_proto %d l4_proto %d l3_csum_err %d l4_csum_err %d hash %d frag %d cdesc_status %x\n",
+ 		   ena_rx_ctx->l3_proto, ena_rx_ctx->l4_proto,
+ 		   ena_rx_ctx->l3_csum_err, ena_rx_ctx->l4_csum_err,
+ 		   ena_rx_ctx->hash, ena_rx_ctx->frag, cdesc->status);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  }
  
  /*****************************************************************************/
@@@ -388,8 -399,9 +431,14 @@@ int ena_com_prepare_tx(struct ena_com_i
  	}
  
  	if (unlikely(header_len > io_sq->tx_max_header_size)) {
++<<<<<<< HEAD
 +		pr_err("header size is too large %d max header: %d\n",
 +		       header_len, io_sq->tx_max_header_size);
++=======
+ 		netdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 			   "Header size is too large %d max header: %d\n",
+ 			   header_len, io_sq->tx_max_header_size);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return -EINVAL;
  	}
  
@@@ -403,7 -415,8 +452,12 @@@
  
  	rc = ena_com_create_and_store_tx_meta_desc(io_sq, ena_tx_ctx, &have_meta);
  	if (unlikely(rc)) {
++<<<<<<< HEAD
 +		pr_err("failed to create and store tx meta desc\n");
++=======
+ 		netdev_err(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 			   "Failed to create and store tx meta desc\n");
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		return rc;
  	}
  
@@@ -527,12 -540,14 +581,19 @@@ int ena_com_rx_pkt(struct ena_com_io_c
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	pr_debug("fetch rx packet: queue %d completed desc: %d\n", io_cq->qid,
 +		 nb_hw_desc);
++=======
+ 	netdev_dbg(ena_com_io_cq_to_ena_dev(io_cq)->net_device,
+ 		   "Fetch rx packet: queue %d completed desc: %d\n", io_cq->qid,
+ 		   nb_hw_desc);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  	if (unlikely(nb_hw_desc > ena_rx_ctx->max_bufs)) {
- 		pr_err("Too many RX cdescs (%d) > MAX(%d)\n", nb_hw_desc,
- 		       ena_rx_ctx->max_bufs);
+ 		netdev_err(ena_com_io_cq_to_ena_dev(io_cq)->net_device,
+ 			   "Too many RX cdescs (%d) > MAX(%d)\n", nb_hw_desc,
+ 			   ena_rx_ctx->max_bufs);
  		return -ENOSPC;
  	}
  
diff --cc drivers/net/ethernet/amazon/ena/ena_eth_com.h
index 74c9a72ec3ef,689313ee25a8..000000000000
--- a/drivers/net/ethernet/amazon/ena/ena_eth_com.h
+++ b/drivers/net/ethernet/amazon/ena/ena_eth_com.h
@@@ -140,8 -140,9 +140,14 @@@ static inline bool ena_com_is_doorbell_
  						   llq_info->descs_per_entry);
  	}
  
++<<<<<<< HEAD
 +	pr_debug("queue: %d num_descs: %d num_entries_needed: %d\n", io_sq->qid,
 +		 num_descs, num_entries_needed);
++=======
+ 	netdev_dbg(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 		   "Queue: %d num_descs: %d num_entries_needed: %d\n",
+ 		   io_sq->qid, num_descs, num_entries_needed);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  	return num_entries_needed > io_sq->entries_in_tx_burst_left;
  }
@@@ -151,14 -152,16 +157,26 @@@ static inline int ena_com_write_sq_door
  	u16 max_entries_in_tx_burst = io_sq->llq_info.max_entries_in_tx_burst;
  	u16 tail = io_sq->tail;
  
++<<<<<<< HEAD
 +	pr_debug("write submission queue doorbell for queue: %d tail: %d\n",
 +		 io_sq->qid, tail);
++=======
+ 	netdev_dbg(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 		   "Write submission queue doorbell for queue: %d tail: %d\n",
+ 		   io_sq->qid, tail);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  
  	writel(tail, io_sq->db_addr);
  
  	if (is_llq_max_tx_burst_exists(io_sq)) {
++<<<<<<< HEAD
 +		pr_debug("reset available entries in tx burst for queue %d to %d\n",
 +			 io_sq->qid, max_entries_in_tx_burst);
++=======
+ 		netdev_dbg(ena_com_io_sq_to_ena_dev(io_sq)->net_device,
+ 			   "Reset available entries in tx burst for queue %d to %d\n",
+ 			   io_sq->qid, max_entries_in_tx_burst);
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  		io_sq->entries_in_tx_burst_left = max_entries_in_tx_burst;
  	}
  
diff --cc drivers/net/ethernet/amazon/ena/ena_netdev.c
index a34982bbddb7,b3eef9bd4716..000000000000
--- a/drivers/net/ethernet/amazon/ena/ena_netdev.c
+++ b/drivers/net/ethernet/amazon/ena/ena_netdev.c
@@@ -4173,12 -4178,30 +4173,33 @@@ static int ena_probe(struct pci_dev *pd
  
  	ena_dev->dmadev = &pdev->dev;
  
++<<<<<<< HEAD
++=======
+ 	netdev = alloc_etherdev_mq(sizeof(struct ena_adapter), ENA_MAX_RINGS);
+ 	if (!netdev) {
+ 		dev_err(&pdev->dev, "alloc_etherdev_mq failed\n");
+ 		rc = -ENOMEM;
+ 		goto err_free_region;
+ 	}
+ 
+ 	SET_NETDEV_DEV(netdev, &pdev->dev);
+ 	adapter = netdev_priv(netdev);
+ 	adapter->ena_dev = ena_dev;
+ 	adapter->netdev = netdev;
+ 	adapter->pdev = pdev;
+ 	adapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);
+ 
+ 	ena_dev->net_device = netdev;
+ 
+ 	pci_set_drvdata(pdev, adapter);
+ 
++>>>>>>> da580ca8de2c (net: ena: add device distinct log prefix to files)
  	rc = ena_device_init(ena_dev, pdev, &get_feat_ctx, &wd_state);
  	if (rc) {
 -		dev_err(&pdev->dev, "ENA device init failed\n");
 +		dev_err(&pdev->dev, "ena device init failed\n");
  		if (rc == -ETIME)
  			rc = -EPROBE_DEFER;
 -		goto err_netdev_destroy;
 +		goto err_free_region;
  	}
  
  	rc = ena_map_llq_mem_bar(pdev, ena_dev, bars);
* Unmerged path drivers/net/ethernet/amazon/ena/ena_com.c
diff --git a/drivers/net/ethernet/amazon/ena/ena_com.h b/drivers/net/ethernet/amazon/ena/ena_com.h
index fe60a5696d9e..443fc58ad369 100644
--- a/drivers/net/ethernet/amazon/ena/ena_com.h
+++ b/drivers/net/ethernet/amazon/ena/ena_com.h
@@ -303,6 +303,7 @@ struct ena_com_dev {
 	u8 __iomem *reg_bar;
 	void __iomem *mem_bar;
 	void *dmadev;
+	struct net_device *net_device;
 
 	enum ena_admin_placement_policy_type tx_mem_queue_type;
 	u32 tx_max_header_size;
@@ -931,6 +932,26 @@ int ena_com_config_dev_mode(struct ena_com_dev *ena_dev,
 			    struct ena_admin_feature_llq_desc *llq_features,
 			    struct ena_llq_configurations *llq_default_config);
 
+/* ena_com_io_sq_to_ena_dev - Extract ena_com_dev using contained field io_sq.
+ * @io_sq: IO submit queue struct
+ *
+ * @return - ena_com_dev struct extracted from io_sq
+ */
+static inline struct ena_com_dev *ena_com_io_sq_to_ena_dev(struct ena_com_io_sq *io_sq)
+{
+	return container_of(io_sq, struct ena_com_dev, io_sq_queues[io_sq->qid]);
+}
+
+/* ena_com_io_cq_to_ena_dev - Extract ena_com_dev using contained field io_cq.
+ * @io_sq: IO submit queue struct
+ *
+ * @return - ena_com_dev struct extracted from io_sq
+ */
+static inline struct ena_com_dev *ena_com_io_cq_to_ena_dev(struct ena_com_io_cq *io_cq)
+{
+	return container_of(io_cq, struct ena_com_dev, io_cq_queues[io_cq->qid]);
+}
+
 static inline bool ena_com_get_adaptive_moderation_enabled(struct ena_com_dev *ena_dev)
 {
 	return ena_dev->adaptive_coalescing;
* Unmerged path drivers/net/ethernet/amazon/ena/ena_eth_com.c
* Unmerged path drivers/net/ethernet/amazon/ena/ena_eth_com.h
* Unmerged path drivers/net/ethernet/amazon/ena/ena_netdev.c
