platform/x86: Intel PMT class driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Alexander Duyck <alexander.h.duyck@linux.intel.com>
commit e2729113ce66d8d21f729b41bc3ed3feaf1acf69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/e2729113.failed

Intel Platform Monitoring Technology is meant to provide a common way to
access telemetry and system metrics.

Register mappings are not provided by the driver. Instead, a GUID is read
from a header for each endpoint. The GUID identifies the device and is to
be used with an XML, provided by the vendor, to discover the available set
of metrics and their register mapping.  This allows firmware updates to
modify the register space without needing to update the driver every time
with new mappings. Firmware writes a new GUID in this case to specify the
new mapping.  Software tools with access to the associated XML file can
then interpret the changes.

The module manages access to all Intel PMT endpoints on a system,
independent of the device exporting them. It creates an intel_pmt class
to manage the devices. For each telemetry endpoint, sysfs files provide
GUID and size information as well as a pointer to the parent device the
telemetry came from. Software may discover the association between
endpoints and devices by iterating through the list in sysfs, or by looking
for the existence of the class folder under the device of interest.  A
binary sysfs attribute of the same name allows software to then read or map
the telemetry space for direct access.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
	Signed-off-by: David E. Box <david.e.box@linux.intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Lee Jones <lee.jones@linaro.org>
(cherry picked from commit e2729113ce66d8d21f729b41bc3ed3feaf1acf69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
#	drivers/platform/x86/Kconfig
#	drivers/platform/x86/Makefile
diff --cc MAINTAINERS
index d6a72e992d56,3d15a7b855cf..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -7456,27 -8991,41 +7456,47 @@@ F:	include/linux/scif.
  F:	include/uapi/linux/mic_common.h
  F:	include/uapi/linux/mic_ioctl.h
  F:	include/uapi/linux/scif_ioctl.h
 -
 -INTEL P-Unit IPC DRIVER
 -M:	Zha Qipeng <qipeng.zha@intel.com>
 -L:	platform-driver-x86@vger.kernel.org
 -S:	Maintained
 -F:	arch/x86/include/asm/intel_punit_ipc.h
 -F:	drivers/platform/x86/intel_punit_ipc.c
 +F:	drivers/misc/mic/
 +F:	drivers/dma/mic_x100_dma.c
 +F:	drivers/dma/mic_x100_dma.h
 +F:	Documentation/mic/
  
  INTEL PMC CORE DRIVER
 -M:	Rajneesh Bhardwaj <irenic.rajneesh@gmail.com>
 -M:	David E Box <david.e.box@intel.com>
 +M:	Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
 +M:	Vishwanath Somayaji <vishwanath.somayaji@intel.com>
  L:	platform-driver-x86@vger.kernel.org
  S:	Maintained
 +F:	arch/x86/include/asm/pmc_core.h
  F:	drivers/platform/x86/intel_pmc_core*
  
 -INTEL PMIC GPIO DRIVERS
 -M:	Andy Shevchenko <andy@kernel.org>
 +INTEL PMC/P-Unit IPC DRIVER
 +M:	Zha Qipeng<qipeng.zha@intel.com>
 +L:	platform-driver-x86@vger.kernel.org
  S:	Maintained
++<<<<<<< HEAD
 +F:	drivers/platform/x86/intel_pmc_ipc.c
 +F:	drivers/platform/x86/intel_punit_ipc.c
 +F:	arch/x86/include/asm/intel_pmc_ipc.h
 +F:	arch/x86/include/asm/intel_punit_ipc.h
++=======
+ T:	git git://git.kernel.org/pub/scm/linux/kernel/git/andy/linux-gpio-intel.git
+ F:	drivers/gpio/gpio-*cove.c
+ F:	drivers/gpio/gpio-msic.c
+ 
+ INTEL PMIC MULTIFUNCTION DEVICE DRIVERS
+ M:	Andy Shevchenko <andy@kernel.org>
+ S:	Maintained
+ F:	drivers/mfd/intel_msic.c
+ F:	drivers/mfd/intel_soc_pmic*
+ F:	include/linux/mfd/intel_msic.h
+ F:	include/linux/mfd/intel_soc_pmic*
+ 
+ INTEL PMT DRIVER
+ M:	"David E. Box" <david.e.box@linux.intel.com>
+ S:	Maintained
+ F:	drivers/mfd/intel_pmt.c
+ F:	drivers/platform/x86/intel_pmt_*
++>>>>>>> e2729113ce66 (platform/x86: Intel PMT class driver)
  
  INTEL PRO/WIRELESS 2100, 2200BG, 2915ABG NETWORK CONNECTION SUPPORT
  M:	Stanislav Yakovlev <stas.yakovlev@gmail.com>
diff --cc drivers/platform/x86/Kconfig
index 2a795afbb303,7d168a434d05..000000000000
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@@ -1033,110 -1241,15 +1033,111 @@@ config INTEL_IM
  
  	  If you are running on a Galileo/Quark say Y here.
  
 -config INTEL_IPS
 -	tristate "Intel Intelligent Power Sharing"
 +config INTEL_PMC_CORE
 +	tristate "Intel PMC Core driver"
 +	depends on PCI
 +	---help---
 +	  The Intel Platform Controller Hub for Intel Core SoCs provides access
 +	  to Power Management Controller registers via a PCI interface. This
 +	  driver can utilize debugging capabilities and supported features as
 +	  exposed by the Power Management Controller.
 +
 +	  Supported features:
 +		- SLP_S0_RESIDENCY counter
 +		- PCH IP Power Gating status
 +		- LTR Ignore
 +		- MPHY/PLL gating status (Sunrisepoint PCH only)
 +
++<<<<<<< HEAD
 +config IBM_RTL
 +	tristate "Device driver to enable PRTL support"
 +	depends on PCI
 +	---help---
 +	 Enable support for IBM Premium Real Time Mode (PRTM).
 +	 This module will allow you the enter and exit PRTM in the BIOS via
 +	 sysfs on platforms that support this feature.  System in PRTM will
 +	 not receive CPU-generated SMIs for recoverable errors.  Use of this
 +	 feature without proper support may void your hardware warranty.
 +
 +	 If the proper BIOS support is found the driver will load and create
 +	 /sys/devices/system/ibm_rtl/.  The "state" variable will indicate
 +	 whether or not the BIOS is in PRTM.
 +	 state = 0 (BIOS SMIs on)
 +	 state = 1 (BIOS SMIs off)
 +
 +config XO1_RFKILL
 +	tristate "OLPC XO-1 software RF kill switch"
 +	depends on OLPC || COMPILE_TEST
 +	depends on RFKILL
 +	---help---
 +	  Support for enabling/disabling the WLAN interface on the OLPC XO-1
 +	  laptop.
 +
 +config XO15_EBOOK
 +	tristate "OLPC XO-1.5 ebook switch"
 +	depends on OLPC || COMPILE_TEST
 +	depends on ACPI && INPUT
 +	---help---
 +	  Support for the ebook switch on the OLPC XO-1.5 laptop.
 +
 +	  This switch is triggered as the screen is rotated and folded down to
 +	  convert the device into ebook form.
 +
 +config SAMSUNG_LAPTOP
 +	tristate "Samsung Laptop driver"
 +	depends on RFKILL || RFKILL = n
 +	depends on ACPI_VIDEO || ACPI_VIDEO = n
 +	depends on BACKLIGHT_CLASS_DEVICE
 +	select LEDS_CLASS
 +	select NEW_LEDS
 +	---help---
 +	  This module implements a driver for a wide range of different
 +	  Samsung laptops.  It offers control over the different
 +	  function keys, wireless LED, LCD backlight level.
 +
 +	  It may also provide some sysfs files described in
 +	  <file:Documentation/ABI/testing/sysfs-driver-samsung-laptop>
 +
 +	  To compile this driver as a module, choose M here: the module
 +	  will be called samsung-laptop.
 +
 +config MXM_WMI
 +       tristate "WMI support for MXM Laptop Graphics"
 +       depends on ACPI_WMI
 +       ---help---
 +          MXM is a standard for laptop graphics cards, the WMI interface
 +	  is required for switchable nvidia graphics machines
 +
 +config INTEL_OAKTRAIL
 +	tristate "Intel Oaktrail Platform Extras"
 +	depends on ACPI
 +	depends on ACPI_VIDEO || ACPI_VIDEO = n
 +	depends on RFKILL && BACKLIGHT_CLASS_DEVICE && ACPI
 +	---help---
 +	  Intel Oaktrail platform need this driver to provide interfaces to
 +	  enable/disable the Camera, WiFi, BT etc. devices. If in doubt, say Y
 +	  here; it will only load on supported platforms.
 +
 +config SAMSUNG_Q10
 +	tristate "Samsung Q10 Extras"
 +	depends on ACPI
 +	select BACKLIGHT_CLASS_DEVICE
 +	---help---
 +	  This driver provides support for backlight control on Samsung Q10
 +	  and related laptops, including Dell Latitude X200.
 +
 +config APPLE_GMUX
 +	tristate "Apple Gmux Driver"
  	depends on ACPI && PCI
 -	help
 -	  Intel Calpella platforms support dynamic power sharing between the
 -	  CPU and GPU, maximizing performance in a given TDP.  This driver,
 -	  along with the CPU frequency and i915 drivers, provides that
 -	  functionality.  If in doubt, say Y here; it will only load on
 -	  supported platforms.
 +	depends on PNP
 +	depends on BACKLIGHT_CLASS_DEVICE
 +	depends on BACKLIGHT_APPLE=n || BACKLIGHT_APPLE
 +	depends on ACPI_VIDEO=n || ACPI_VIDEO
 +	---help---
 +	  This driver provides support for the gmux device found on many
 +	  Apple laptops, which controls the display mux for the hybrid
 +	  graphics as well as the backlight. Currently only backlight
 +	  control is supported by the driver.
  
  config INTEL_RST
          tristate "Intel Rapid Start Technology Driver"
@@@ -1189,17 -1310,69 +1190,30 @@@ config INTEL_BXTWC_PMIC_TM
  	  This driver enables the alarm wakeup functionality in the TMU unit
  	  of Whiskey Cove PMIC.
  
 -config INTEL_CHTDC_TI_PWRBTN
 -	tristate "Intel Cherry Trail Dollar Cove TI power button driver"
 -	depends on INTEL_SOC_PMIC_CHTDC_TI
 -	depends on INPUT
 -	help
 -	  This option adds a power button driver driver for Dollar Cove TI
 -	  PMIC on Intel Cherry Trail devices.
 -
 -	  To compile this driver as a module, choose M here: the module
 -	  will be called intel_chtdc_ti_pwrbtn.
 -
 -config INTEL_MFLD_THERMAL
 -       tristate "Thermal driver for Intel Medfield platform"
 -       depends on MFD_INTEL_MSIC && THERMAL
 -       help
 -         Say Y here to enable thermal driver support for the  Intel Medfield
 -         platform.
 -
 -config INTEL_MID_POWER_BUTTON
 -	tristate "power button driver for Intel MID platforms"
 -	depends on INTEL_SCU && INPUT
 -	help
 -	  This driver handles the power button on the Intel MID platforms.
 -
 -	  If unsure, say N.
 -
 -config INTEL_MRFLD_PWRBTN
 -	tristate "Intel Merrifield Basin Cove power button driver"
 -	depends on INTEL_SOC_PMIC_MRFLD
 -	depends on INPUT
 -	help
 -	  This option adds a power button driver for Basin Cove PMIC
 -	  on Intel Merrifield devices.
 -
 -	  To compile this driver as a module, choose M here: the module
 -	  will be called intel_mrfld_pwrbtn.
 -
 -config INTEL_PMC_CORE
 -	tristate "Intel PMC Core driver"
 -	depends on PCI
 -	help
 -	  The Intel Platform Controller Hub for Intel Core SoCs provides access
 -	  to Power Management Controller registers via a PCI interface. This
 -	  driver can utilize debugging capabilities and supported features as
 -	  exposed by the Power Management Controller.
 -
 -	  Supported features:
 -		- SLP_S0_RESIDENCY counter
 -		- PCH IP Power Gating status
 -		- LTR Ignore
 -		- MPHY/PLL gating status (Sunrisepoint PCH only)
 +config SURFACE_PRO3_BUTTON
 +	tristate "Power/home/volume buttons driver for Microsoft Surface Pro 3/4 tablet"
 +	depends on ACPI && INPUT
 +	---help---
 +	  This driver handles the power/home/volume buttons on the Microsoft Surface Pro 3/4 tablet.
  
 +config SURFACE_3_BUTTON
 +	tristate "Power/home/volume buttons driver for Microsoft Surface 3 tablet"
 +	depends on ACPI && KEYBOARD_GPIO && I2C
 +	---help---
 +	  This driver handles the power/home/volume buttons on the Microsoft Surface 3 tablet.
++=======
+ config INTEL_PMT_CLASS
+ 	tristate "Intel Platform Monitoring Technology (PMT) Class driver"
+ 	help
+ 	  The Intel Platform Monitoring Technology (PMT) class driver provides
+ 	  the basic sysfs interface and file hierarchy uses by PMT devices.
+ 
+ 	  For more information, see:
+ 	  <file:Documentation/ABI/testing/sysfs-class-intel_pmt>
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called intel_pmt_class.
++>>>>>>> e2729113ce66 (platform/x86: Intel PMT class driver)
  
  config INTEL_PUNIT_IPC
  	tristate "Intel P-Unit IPC Driver"
diff --cc drivers/platform/x86/Makefile
index bc8f22d7c92e,f4b1f87f2401..000000000000
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@@ -55,44 -111,42 +55,59 @@@ obj-$(CONFIG_INTEL_WMI_THUNDERBOLT)	+= 
  # before toshiba_acpi initializes
  obj-$(CONFIG_ACPI_TOSHIBA)	+= toshiba_acpi.o
  
 -# Laptop drivers
 -obj-$(CONFIG_ACPI_CMPC)		+= classmate-laptop.o
 -obj-$(CONFIG_COMPAL_LAPTOP)	+= compal-laptop.o
 -obj-$(CONFIG_LG_LAPTOP)		+= lg-laptop.o
 -obj-$(CONFIG_PANASONIC_LAPTOP)	+= panasonic-laptop.o
 -obj-$(CONFIG_SONY_LAPTOP)	+= sony-laptop.o
 -obj-$(CONFIG_SYSTEM76_ACPI)	+= system76_acpi.o
 -obj-$(CONFIG_TOPSTAR_LAPTOP)	+= topstar-laptop.o
 -
 -# Platform drivers
 -obj-$(CONFIG_I2C_MULTI_INSTANTIATE)	+= i2c-multi-instantiate.o
 -obj-$(CONFIG_MLX_PLATFORM)		+= mlx-platform.o
 -obj-$(CONFIG_TOUCHSCREEN_DMI)		+= touchscreen_dmi.o
 -
 -# Intel uncore drivers
 -obj-$(CONFIG_INTEL_IPS)				+= intel_ips.o
 -obj-$(CONFIG_INTEL_RST)				+= intel-rst.o
 -obj-$(CONFIG_INTEL_SMARTCONNECT)		+= intel-smartconnect.o
 -obj-$(CONFIG_INTEL_SPEED_SELECT_INTERFACE)	+= intel_speed_select_if/
 -obj-$(CONFIG_INTEL_TURBO_MAX_3)			+= intel_turbo_max_3.o
 -obj-$(CONFIG_INTEL_UNCORE_FREQ_CONTROL)		+= intel-uncore-frequency.o
 +obj-$(CONFIG_TOSHIBA_BT_RFKILL)	+= toshiba_bluetooth.o
 +obj-$(CONFIG_TOSHIBA_HAPS)	+= toshiba_haps.o
 +obj-$(CONFIG_TOSHIBA_WMI)	+= toshiba-wmi.o
 +obj-$(CONFIG_INTEL_CHT_INT33FE)	+= intel_cht_int33fe.o
 +obj-$(CONFIG_INTEL_INT0002_VGPIO) += intel_int0002_vgpio.o
 +obj-$(CONFIG_INTEL_HID_EVENT)	+= intel-hid.o
 +obj-$(CONFIG_INTEL_VBTN)	+= intel-vbtn.o
 +obj-$(CONFIG_INTEL_SCU_IPC)	+= intel_scu_ipc.o
 +obj-$(CONFIG_INTEL_SCU_IPC_UTIL) += intel_scu_ipcutil.o
 +obj-$(CONFIG_INTEL_MFLD_THERMAL) += intel_mid_thermal.o
 +obj-$(CONFIG_INTEL_IPS)		+= intel_ips.o
 +obj-$(CONFIG_XO1_RFKILL)	+= xo1-rfkill.o
 +obj-$(CONFIG_XO15_EBOOK)	+= xo15-ebook.o
 +obj-$(CONFIG_IBM_RTL)		+= ibm_rtl.o
 +obj-$(CONFIG_SAMSUNG_LAPTOP)	+= samsung-laptop.o
 +obj-$(CONFIG_MXM_WMI)		+= mxm-wmi.o
 +obj-$(CONFIG_INTEL_MID_POWER_BUTTON)	+= intel_mid_powerbtn.o
++<<<<<<< HEAD
 +obj-$(CONFIG_INTEL_OAKTRAIL)	+= intel_oaktrail.o
 +obj-$(CONFIG_SAMSUNG_Q10)	+= samsung-q10.o
 +obj-$(CONFIG_APPLE_GMUX)	+= apple-gmux.o
 +obj-$(CONFIG_INTEL_RST)		+= intel-rst.o
 +obj-$(CONFIG_INTEL_SMARTCONNECT)	+= intel-smartconnect.o
  
 -# Intel PMIC / PMC / P-Unit devices
 +obj-$(CONFIG_PVPANIC)           += pvpanic.o
 +obj-$(CONFIG_ALIENWARE_WMI)	+= alienware-wmi.o
 +obj-$(CONFIG_INTEL_PMC_IPC)	+= intel_pmc_ipc.o
 +obj-$(CONFIG_SILEAD_DMI)	+= silead_dmi.o
 +obj-$(CONFIG_SURFACE_PRO3_BUTTON)	+= surfacepro3_button.o
 +obj-$(CONFIG_SURFACE_3_BUTTON)	+= surface3_button.o
 +obj-$(CONFIG_INTEL_PUNIT_IPC)  += intel_punit_ipc.o
  obj-$(CONFIG_INTEL_BXTWC_PMIC_TMU)	+= intel_bxtwc_tmu.o
 +obj-$(CONFIG_INTEL_TELEMETRY)	+= intel_telemetry_core.o \
 +				   intel_telemetry_pltdrv.o \
 +				   intel_telemetry_debugfs.o
 +obj-$(CONFIG_INTEL_PMC_CORE)    += intel_pmc_core.o intel_pmc_core_pltdrv.o
 +obj-$(CONFIG_PMC_ATOM)		+= pmc_atom.o
 +obj-$(CONFIG_MLX_PLATFORM)	+= mlx-platform.o
 +obj-$(CONFIG_INTEL_TURBO_MAX_3) += intel_turbo_max_3.o
  obj-$(CONFIG_INTEL_CHTDC_TI_PWRBTN)	+= intel_chtdc_ti_pwrbtn.o
 -obj-$(CONFIG_INTEL_MFLD_THERMAL)	+= intel_mid_thermal.o
 -obj-$(CONFIG_INTEL_MID_POWER_BUTTON)	+= intel_mid_powerbtn.o
 +obj-$(CONFIG_I2C_MULTI_INSTANTIATE)	+= i2c-multi-instantiate.o
 +obj-$(CONFIG_INTEL_SPEED_SELECT_INTERFACE) += intel_speed_select_if/
++=======
+ obj-$(CONFIG_INTEL_MRFLD_PWRBTN)	+= intel_mrfld_pwrbtn.o
+ obj-$(CONFIG_INTEL_PMC_CORE)		+= intel_pmc_core.o intel_pmc_core_pltdrv.o
+ obj-$(CONFIG_INTEL_PMT_CLASS)		+= intel_pmt_class.o
+ obj-$(CONFIG_INTEL_PUNIT_IPC)		+= intel_punit_ipc.o
+ obj-$(CONFIG_INTEL_SCU_IPC)		+= intel_scu_ipc.o
+ obj-$(CONFIG_INTEL_SCU_PCI)		+= intel_scu_pcidrv.o
+ obj-$(CONFIG_INTEL_SCU_PLATFORM)	+= intel_scu_pltdrv.o
+ obj-$(CONFIG_INTEL_SCU_IPC_UTIL)	+= intel_scu_ipcutil.o
+ obj-$(CONFIG_INTEL_TELEMETRY)		+= intel_telemetry_core.o \
+ 					   intel_telemetry_pltdrv.o \
+ 					   intel_telemetry_debugfs.o
+ obj-$(CONFIG_PMC_ATOM)			+= pmc_atom.o
++>>>>>>> e2729113ce66 (platform/x86: Intel PMT class driver)
diff --git a/Documentation/ABI/testing/sysfs-class-intel_pmt b/Documentation/ABI/testing/sysfs-class-intel_pmt
new file mode 100644
index 000000000000..926b5cf95fd1
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-class-intel_pmt
@@ -0,0 +1,54 @@
+What:		/sys/class/intel_pmt/
+Date:		October 2020
+KernelVersion:	5.10
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		The intel_pmt/ class directory contains information for
+		devices that expose hardware telemetry using Intel Platform
+		Monitoring Technology (PMT)
+
+What:		/sys/class/intel_pmt/telem<x>
+Date:		October 2020
+KernelVersion:	5.10
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		The telem<x> directory contains files describing an instance of
+		a PMT telemetry device that exposes hardware telemetry. Each
+		telem<x> directory has an associated telem file. This file
+		may be opened and mapped or read to access the telemetry space
+		of the device. The register layout of the telemetry space is
+		determined from an XML file that matches the PCI device id and
+		GUID for the device.
+
+What:		/sys/class/intel_pmt/telem<x>/telem
+Date:		October 2020
+KernelVersion:	5.10
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RO) The telemetry data for this telemetry device. This file
+		may be mapped or read to obtain the data.
+
+What:		/sys/class/intel_pmt/telem<x>/guid
+Date:		October 2020
+KernelVersion:	5.10
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RO) The GUID for this telemetry device. The GUID identifies
+		the version of the XML file for the parent device that is to
+		be used to get the register layout.
+
+What:		/sys/class/intel_pmt/telem<x>/size
+Date:		October 2020
+KernelVersion:	5.10
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RO) The size of telemetry region in bytes that corresponds to
+		the mapping size for the telem file.
+
+What:		/sys/class/intel_pmt/telem<x>/offset
+Date:		October 2020
+KernelVersion:	5.10
+Contact:	David Box <david.e.box@linux.intel.com>
+Description:
+		(RO) The offset of telemetry region in bytes that corresponds to
+		the mapping for the telem file.
* Unmerged path MAINTAINERS
* Unmerged path drivers/platform/x86/Kconfig
* Unmerged path drivers/platform/x86/Makefile
diff --git a/drivers/platform/x86/intel_pmt_class.c b/drivers/platform/x86/intel_pmt_class.c
new file mode 100644
index 000000000000..aa88dc23bbde
--- /dev/null
+++ b/drivers/platform/x86/intel_pmt_class.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Platform Monitory Technology Telemetry driver
+ *
+ * Copyright (c) 2020, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * Author: "Alexander Duyck" <alexander.h.duyck@linux.intel.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+
+#include "intel_pmt_class.h"
+
+#define PMT_XA_START		0
+#define PMT_XA_MAX		INT_MAX
+#define PMT_XA_LIMIT		XA_LIMIT(PMT_XA_START, PMT_XA_MAX)
+
+/*
+ * sysfs
+ */
+static ssize_t
+intel_pmt_read(struct file *filp, struct kobject *kobj,
+	       struct bin_attribute *attr, char *buf, loff_t off,
+	       size_t count)
+{
+	struct intel_pmt_entry *entry = container_of(attr,
+						     struct intel_pmt_entry,
+						     pmt_bin_attr);
+
+	if (off < 0)
+		return -EINVAL;
+
+	if (off >= entry->size)
+		return 0;
+
+	if (count > entry->size - off)
+		count = entry->size - off;
+
+	memcpy_fromio(buf, entry->base + off, count);
+
+	return count;
+}
+
+static int
+intel_pmt_mmap(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr, struct vm_area_struct *vma)
+{
+	struct intel_pmt_entry *entry = container_of(attr,
+						     struct intel_pmt_entry,
+						     pmt_bin_attr);
+	unsigned long vsize = vma->vm_end - vma->vm_start;
+	struct device *dev = kobj_to_dev(kobj);
+	unsigned long phys = entry->base_addr;
+	unsigned long pfn = PFN_DOWN(phys);
+	unsigned long psize;
+
+	if (vma->vm_flags & (VM_WRITE | VM_MAYWRITE))
+		return -EROFS;
+
+	psize = (PFN_UP(entry->base_addr + entry->size) - pfn) * PAGE_SIZE;
+	if (vsize > psize) {
+		dev_err(dev, "Requested mmap size is too large\n");
+		return -EINVAL;
+	}
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (io_remap_pfn_range(vma, vma->vm_start, pfn,
+		vsize, vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static ssize_t
+guid_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct intel_pmt_entry *entry = dev_get_drvdata(dev);
+
+	return sprintf(buf, "0x%x\n", entry->guid);
+}
+static DEVICE_ATTR_RO(guid);
+
+static ssize_t size_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct intel_pmt_entry *entry = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%zu\n", entry->size);
+}
+static DEVICE_ATTR_RO(size);
+
+static ssize_t
+offset_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct intel_pmt_entry *entry = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%lu\n", offset_in_page(entry->base_addr));
+}
+static DEVICE_ATTR_RO(offset);
+
+static struct attribute *intel_pmt_attrs[] = {
+	&dev_attr_guid.attr,
+	&dev_attr_size.attr,
+	&dev_attr_offset.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(intel_pmt);
+
+static struct class intel_pmt_class = {
+	.name = "intel_pmt",
+	.owner = THIS_MODULE,
+	.dev_groups = intel_pmt_groups,
+};
+
+static int intel_pmt_populate_entry(struct intel_pmt_entry *entry,
+				    struct intel_pmt_header *header,
+				    struct device *dev,
+				    struct resource *disc_res)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev->parent);
+	u8 bir;
+
+	/*
+	 * The base offset should always be 8 byte aligned.
+	 *
+	 * For non-local access types the lower 3 bits of base offset
+	 * contains the index of the base address register where the
+	 * telemetry can be found.
+	 */
+	bir = GET_BIR(header->base_offset);
+
+	/* Local access and BARID only for now */
+	switch (header->access_type) {
+	case ACCESS_LOCAL:
+		if (bir) {
+			dev_err(dev,
+				"Unsupported BAR index %d for access type %d\n",
+				bir, header->access_type);
+			return -EINVAL;
+		}
+		/*
+		 * For access_type LOCAL, the base address is as follows:
+		 * base address = end of discovery region + base offset
+		 */
+		entry->base_addr = disc_res->end + 1 + header->base_offset;
+		break;
+	case ACCESS_BARID:
+		/*
+		 * If another BAR was specified then the base offset
+		 * represents the offset within that BAR. SO retrieve the
+		 * address from the parent PCI device and add offset.
+		 */
+		entry->base_addr = pci_resource_start(pci_dev, bir) +
+				   GET_ADDRESS(header->base_offset);
+		break;
+	default:
+		dev_err(dev, "Unsupported access type %d\n",
+			header->access_type);
+		return -EINVAL;
+	}
+
+	entry->guid = header->guid;
+	entry->size = header->size;
+
+	return 0;
+}
+
+static int intel_pmt_dev_register(struct intel_pmt_entry *entry,
+				  struct intel_pmt_namespace *ns,
+				  struct device *parent)
+{
+	struct resource res;
+	struct device *dev;
+	int ret;
+
+	ret = xa_alloc(ns->xa, &entry->devid, entry, PMT_XA_LIMIT, GFP_KERNEL);
+	if (ret)
+		return ret;
+
+	dev = device_create(&intel_pmt_class, parent, MKDEV(0, 0), entry,
+			    "%s%d", ns->name, entry->devid);
+
+	if (IS_ERR(dev)) {
+		dev_err(parent, "Could not create %s%d device node\n",
+			ns->name, entry->devid);
+		ret = PTR_ERR(dev);
+		goto fail_dev_create;
+	}
+
+	entry->kobj = &dev->kobj;
+
+	if (ns->attr_grp) {
+		ret = sysfs_create_group(entry->kobj, ns->attr_grp);
+		if (ret)
+			goto fail_sysfs;
+	}
+
+	/* if size is 0 assume no data buffer, so no file needed */
+	if (!entry->size)
+		return 0;
+
+	res.start = entry->base_addr;
+	res.end = res.start + entry->size - 1;
+	res.flags = IORESOURCE_MEM;
+
+	entry->base = devm_ioremap_resource(dev, &res);
+	if (IS_ERR(entry->base)) {
+		ret = PTR_ERR(entry->base);
+		goto fail_ioremap;
+	}
+
+	sysfs_bin_attr_init(&entry->pmt_bin_attr);
+	entry->pmt_bin_attr.attr.name = ns->name;
+	entry->pmt_bin_attr.attr.mode = 0440;
+	entry->pmt_bin_attr.mmap = intel_pmt_mmap;
+	entry->pmt_bin_attr.read = intel_pmt_read;
+	entry->pmt_bin_attr.size = entry->size;
+
+	ret = sysfs_create_bin_file(&dev->kobj, &entry->pmt_bin_attr);
+	if (!ret)
+		return 0;
+
+fail_ioremap:
+	sysfs_remove_group(entry->kobj, ns->attr_grp);
+fail_sysfs:
+	device_unregister(dev);
+fail_dev_create:
+	xa_erase(ns->xa, entry->devid);
+
+	return ret;
+}
+
+int intel_pmt_dev_create(struct intel_pmt_entry *entry,
+			 struct intel_pmt_namespace *ns,
+			 struct platform_device *pdev, int idx)
+{
+	struct intel_pmt_header header;
+	struct resource	*disc_res;
+	int ret = -ENODEV;
+
+	disc_res = platform_get_resource(pdev, IORESOURCE_MEM, idx);
+	if (!disc_res)
+		return ret;
+
+	entry->disc_table = devm_platform_ioremap_resource(pdev, idx);
+	if (IS_ERR(entry->disc_table))
+		return PTR_ERR(entry->disc_table);
+
+	ret = ns->pmt_header_decode(entry, &header, &pdev->dev);
+	if (ret)
+		return ret;
+
+	ret = intel_pmt_populate_entry(entry, &header, &pdev->dev, disc_res);
+	if (ret)
+		return ret;
+
+	return intel_pmt_dev_register(entry, ns, &pdev->dev);
+
+}
+EXPORT_SYMBOL_GPL(intel_pmt_dev_create);
+
+void intel_pmt_dev_destroy(struct intel_pmt_entry *entry,
+			   struct intel_pmt_namespace *ns)
+{
+	struct device *dev = kobj_to_dev(entry->kobj);
+
+	if (entry->size)
+		sysfs_remove_bin_file(entry->kobj, &entry->pmt_bin_attr);
+
+	if (ns->attr_grp)
+		sysfs_remove_group(entry->kobj, ns->attr_grp);
+
+	device_unregister(dev);
+	xa_erase(ns->xa, entry->devid);
+}
+EXPORT_SYMBOL_GPL(intel_pmt_dev_destroy);
+
+static int __init pmt_class_init(void)
+{
+	return class_register(&intel_pmt_class);
+}
+
+static void __exit pmt_class_exit(void)
+{
+	class_unregister(&intel_pmt_class);
+}
+
+module_init(pmt_class_init);
+module_exit(pmt_class_exit);
+
+MODULE_AUTHOR("Alexander Duyck <alexander.h.duyck@linux.intel.com>");
+MODULE_DESCRIPTION("Intel PMT Class driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/platform/x86/intel_pmt_class.h b/drivers/platform/x86/intel_pmt_class.h
new file mode 100644
index 000000000000..de8f8139ba31
--- /dev/null
+++ b/drivers/platform/x86/intel_pmt_class.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _INTEL_PMT_CLASS_H
+#define _INTEL_PMT_CLASS_H
+
+#include <linux/platform_device.h>
+#include <linux/xarray.h>
+#include <linux/types.h>
+#include <linux/bits.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+/* PMT access types */
+#define ACCESS_BARID		2
+#define ACCESS_LOCAL		3
+
+/* PMT discovery base address/offset register layout */
+#define GET_BIR(v)		((v) & GENMASK(2, 0))
+#define GET_ADDRESS(v)		((v) & GENMASK(31, 3))
+
+struct intel_pmt_entry {
+	struct bin_attribute	pmt_bin_attr;
+	struct kobject		*kobj;
+	void __iomem		*disc_table;
+	void __iomem		*base;
+	unsigned long		base_addr;
+	size_t			size;
+	u32			guid;
+	int			devid;
+};
+
+struct intel_pmt_header {
+	u32	base_offset;
+	u32	size;
+	u32	guid;
+	u8	access_type;
+};
+
+struct intel_pmt_namespace {
+	const char *name;
+	struct xarray *xa;
+	const struct attribute_group *attr_grp;
+	int (*pmt_header_decode)(struct intel_pmt_entry *entry,
+				 struct intel_pmt_header *header,
+				 struct device *dev);
+};
+
+int intel_pmt_dev_create(struct intel_pmt_entry *entry,
+			 struct intel_pmt_namespace *ns,
+			 struct platform_device *pdev, int idx);
+void intel_pmt_dev_destroy(struct intel_pmt_entry *entry,
+			   struct intel_pmt_namespace *ns);
+#endif
