PCI/ERR: Use "bridge" for clarity in pcie_do_recovery()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Sean V Kelley <sean.v.kelley@intel.com>
commit 0791721d800790e6e533bd8467df67f0dc4f2fec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/0791721d.failed

pcie_do_recovery() may be called with "dev" being either a bridge (Root
Port or Switch Downstream Port) or an Endpoint.  The bulk of the function
deals with the bridge, so if we start with an Endpoint, we reset "dev" to
be the bridge leading to it.

For clarity, replace "dev" in the body of the function with "bridge".  No
functional change intended.

Link: https://lore.kernel.org/r/20201121001036.8560-8-sean.v.kelley@intel.com
	Tested-by: Jonathan Cameron <Jonathan.Cameron@huawei.com> # non-native/no RCEC
	Signed-off-by: Sean V Kelley <sean.v.kelley@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
	Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
(cherry picked from commit 0791721d800790e6e533bd8467df67f0dc4f2fec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pcie/err.c
diff --cc drivers/pci/pcie/err.c
index c74d622dbbc4,46a5b84f8842..000000000000
--- a/drivers/pci/pcie/err.c
+++ b/drivers/pci/pcie/err.c
@@@ -147,28 -147,31 +147,37 @@@ out
  }
  
  pci_ers_result_t pcie_do_recovery(struct pci_dev *dev,
 -		pci_channel_state_t state,
 -		pci_ers_result_t (*reset_subordinates)(struct pci_dev *pdev))
 +			enum pci_channel_state state,
 +			pci_ers_result_t (*reset_link)(struct pci_dev *pdev))
  {
  	int type = pci_pcie_type(dev);
- 	pci_ers_result_t status = PCI_ERS_RESULT_CAN_RECOVER;
+ 	struct pci_dev *bridge;
  	struct pci_bus *bus;
+ 	pci_ers_result_t status = PCI_ERS_RESULT_CAN_RECOVER;
  
  	/*
- 	 * Error recovery runs on all subordinates of the first downstream port.
- 	 * If the downstream port detected the error, it is cleared at the end.
+ 	 * Error recovery runs on all subordinates of the bridge.  If the
+ 	 * bridge detected the error, it is cleared at the end.
  	 */
  	if (!(type == PCI_EXP_TYPE_ROOT_PORT ||
  	      type == PCI_EXP_TYPE_DOWNSTREAM))
- 		dev = pci_upstream_bridge(dev);
- 	bus = dev->subordinate;
+ 		bridge = pci_upstream_bridge(dev);
+ 	else
+ 		bridge = dev;
  
- 	pci_dbg(dev, "broadcast error_detected message\n");
+ 	bus = bridge->subordinate;
+ 	pci_dbg(bridge, "broadcast error_detected message\n");
  	if (state == pci_channel_io_frozen) {
  		pci_walk_bus(bus, report_frozen_detected, &status);
++<<<<<<< HEAD
 +		status = reset_link(dev);
 +		if (status != PCI_ERS_RESULT_RECOVERED) {
 +			pci_warn(dev, "link reset failed\n");
++=======
+ 		status = reset_subordinates(bridge);
+ 		if (status != PCI_ERS_RESULT_RECOVERED) {
+ 			pci_warn(bridge, "subordinate device reset failed\n");
++>>>>>>> 0791721d8007 (PCI/ERR: Use "bridge" for clarity in pcie_do_recovery())
  			goto failed;
  		}
  	} else {
* Unmerged path drivers/pci/pcie/err.c
