mt76: move token utilities in mt76 common module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit d089692bc7938a1030db98d493497cda9afe4b43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/d089692b.failed

Move token management in mt76 common module since it is shared between
mt7615, mt7915 and mt7921 drivers

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit d089692bc7938a1030db98d493497cda9afe4b43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7615/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
#	drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
#	drivers/net/wireless/mediatek/mt76/mt7915/init.c
#	drivers/net/wireless/mediatek/mt76/mt7915/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7921/init.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mac.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mac.c
index 1b8b80e3739d,d11375661875..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
@@@ -1439,11 -1465,7 +1439,15 @@@ mt7615_mac_tx_free_token(struct mt7615_
  	u8 wcid;
  
  	trace_mac_tx_free(dev, token);
++<<<<<<< HEAD
 +
 +	spin_lock_bh(&dev->token_lock);
 +	txwi = idr_remove(&dev->token, token);
 +	spin_unlock_bh(&dev->token_lock);
 +
++=======
+ 	txwi = mt76_token_put(mdev, token);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  	if (!txwi)
  		return;
  
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
index 08d3dd375ce7,5d174aa7f88d..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
@@@ -40,8 -40,7 +40,12 @@@ static int mt7615_init_hardware(struct 
  	mt76_wr(dev, MT_INT_SOURCE_CSR, ~0);
  
  	INIT_WORK(&dev->mcu_work, mt7615_pci_init_work);
++<<<<<<< HEAD
 +	spin_lock_init(&dev->token_lock);
 +	idr_init(&dev->token);
++=======
+ 	mt76_token_init(&dev->mt76);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  
  	ret = mt7615_eeprom_init(dev, addr);
  	if (ret < 0)
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
index 4cf7c5d34325,d7cbef752f9f..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
@@@ -37,9 -37,7 +37,13 @@@ void mt7615_tx_complete_skb(struct mt76
  			token = le16_to_cpu(txp->hw.msdu_id[0]) &
  				~MT_MSDU_ID_VALID;
  
++<<<<<<< HEAD
 +		spin_lock_bh(&dev->token_lock);
 +		t = idr_remove(&dev->token, token);
 +		spin_unlock_bh(&dev->token_lock);
++=======
+ 		t = mt76_token_put(mdev, token);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  		e->skb = t ? t->skb : NULL;
  	}
  
@@@ -161,9 -159,7 +165,13 @@@ int mt7615_tx_prepare_skb(struct mt76_d
  	t = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);
  	t->skb = tx_info->skb;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&dev->token_lock);
 +	id = idr_alloc(&dev->token, t, 0, MT7615_TOKEN_SIZE, GFP_ATOMIC);
 +	spin_unlock_bh(&dev->token_lock);
++=======
+ 	id = mt76_token_get(mdev, &t);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  	if (id < 0)
  		return id;
  
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/init.c
index 49c09d0d8906,c7e9808f228f..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
@@@ -267,6 -153,257 +267,259 @@@ mt7915_init_wiphy(struct ieee80211_hw *
  	ieee80211_hw_set(hw, WANT_MONITOR_VIF);
  
  	hw->max_tx_fragments = 4;
++<<<<<<< HEAD
++=======
+ 
+ 	if (phy->mt76->cap.has_2ghz)
+ 		phy->mt76->sband_2g.sband.ht_cap.cap |=
+ 			IEEE80211_HT_CAP_LDPC_CODING |
+ 			IEEE80211_HT_CAP_MAX_AMSDU;
+ 
+ 	if (phy->mt76->cap.has_5ghz) {
+ 		phy->mt76->sband_5g.sband.ht_cap.cap |=
+ 			IEEE80211_HT_CAP_LDPC_CODING |
+ 			IEEE80211_HT_CAP_MAX_AMSDU;
+ 		phy->mt76->sband_5g.sband.vht_cap.cap |=
+ 			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 |
+ 			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;
+ 	}
+ 
+ 	mt76_set_stream_caps(phy->mt76, true);
+ 	mt7915_set_stream_vht_txbf_caps(phy);
+ 	mt7915_set_stream_he_caps(phy);
+ }
+ 
+ static void
+ mt7915_mac_init_band(struct mt7915_dev *dev, u8 band)
+ {
+ 	u32 mask, set;
+ 
+ 	mt76_rmw_field(dev, MT_TMAC_CTCR0(band),
+ 		       MT_TMAC_CTCR0_INS_DDLMT_REFTIME, 0x3f);
+ 	mt76_set(dev, MT_TMAC_CTCR0(band),
+ 		 MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN |
+ 		 MT_TMAC_CTCR0_INS_DDLMT_EN);
+ 
+ 	mask = MT_MDP_RCFR0_MCU_RX_MGMT |
+ 	       MT_MDP_RCFR0_MCU_RX_CTL_NON_BAR |
+ 	       MT_MDP_RCFR0_MCU_RX_CTL_BAR;
+ 	set = FIELD_PREP(MT_MDP_RCFR0_MCU_RX_MGMT, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR0_MCU_RX_CTL_NON_BAR, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR0_MCU_RX_CTL_BAR, MT_MDP_TO_HIF);
+ 	mt76_rmw(dev, MT_MDP_BNRCFR0(band), mask, set);
+ 
+ 	mask = MT_MDP_RCFR1_MCU_RX_BYPASS |
+ 	       MT_MDP_RCFR1_RX_DROPPED_UCAST |
+ 	       MT_MDP_RCFR1_RX_DROPPED_MCAST;
+ 	set = FIELD_PREP(MT_MDP_RCFR1_MCU_RX_BYPASS, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR1_RX_DROPPED_UCAST, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR1_RX_DROPPED_MCAST, MT_MDP_TO_HIF);
+ 	mt76_rmw(dev, MT_MDP_BNRCFR1(band), mask, set);
+ 
+ 	mt76_set(dev, MT_WF_RMAC_MIB_TIME0(band), MT_WF_RMAC_MIB_RXTIME_EN);
+ 	mt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0(band), MT_WF_RMAC_MIB_RXTIME_EN);
+ 
+ 	mt76_rmw_field(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_MAX_RX_LEN, 1536);
+ 	/* disable rx rate report by default due to hw issues */
+ 	mt76_clear(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_RXD_G5_EN);
+ }
+ 
+ static void mt7915_mac_init(struct mt7915_dev *dev)
+ {
+ 	int i;
+ 
+ 	mt76_rmw_field(dev, MT_MDP_DCR1, MT_MDP_DCR1_MAX_RX_LEN, 1536);
+ 	/* enable hardware de-agg */
+ 	mt76_set(dev, MT_MDP_DCR0, MT_MDP_DCR0_DAMSDU_EN);
+ 
+ 	for (i = 0; i < MT7915_WTBL_SIZE; i++)
+ 		mt7915_mac_wtbl_update(dev, i,
+ 				       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
+ 	for (i = 0; i < 2; i++)
+ 		mt7915_mac_init_band(dev, i);
+ }
+ 
+ static int mt7915_txbf_init(struct mt7915_dev *dev)
+ {
+ 	int ret;
+ 
+ 
+ 	if (dev->dbdc_support) {
+ 		ret = mt7915_mcu_set_txbf_module(dev);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	/* trigger sounding packets */
+ 	ret = mt7915_mcu_set_txbf_sounding(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* enable eBF */
+ 	return mt7915_mcu_set_txbf_type(dev);
+ }
+ 
+ static int mt7915_register_ext_phy(struct mt7915_dev *dev)
+ {
+ 	struct mt7915_phy *phy = mt7915_ext_phy(dev);
+ 	struct mt76_phy *mphy;
+ 	int ret;
+ 
+ 	if (!dev->dbdc_support)
+ 		return 0;
+ 
+ 	if (phy)
+ 		return 0;
+ 
+ 	mphy = mt76_alloc_phy(&dev->mt76, sizeof(*phy), &mt7915_ops);
+ 	if (!mphy)
+ 		return -ENOMEM;
+ 
+ 	phy = mphy->priv;
+ 	phy->dev = dev;
+ 	phy->mt76 = mphy;
+ 	mphy->chainmask = dev->chainmask & ~dev->mphy.chainmask;
+ 	mphy->antenna_mask = BIT(hweight8(mphy->chainmask)) - 1;
+ 
+ 	INIT_LIST_HEAD(&phy->stats_list);
+ 	INIT_DELAYED_WORK(&mphy->mac_work, mt7915_mac_work);
+ 
+ 	mt7915_eeprom_parse_band_config(phy);
+ 	mt7915_init_wiphy(mphy->hw);
+ 
+ 	memcpy(mphy->macaddr, dev->mt76.eeprom.data + MT_EE_MAC_ADDR2,
+ 	       ETH_ALEN);
+ 	mt76_eeprom_override(mphy);
+ 
+ 	ret = mt7915_init_tx_queues(phy, MT7915_TXQ_BAND1,
+ 				    MT7915_TX_RING_SIZE);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = mt76_register_phy(mphy, true, mt7915_rates,
+ 				ARRAY_SIZE(mt7915_rates));
+ 	if (ret)
+ 		goto error;
+ 
+ 	return 0;
+ 
+ error:
+ 	ieee80211_free_hw(mphy->hw);
+ 	return ret;
+ }
+ 
+ static void mt7915_init_work(struct work_struct *work)
+ {
+ 	struct mt7915_dev *dev = container_of(work, struct mt7915_dev,
+ 				 init_work);
+ 
+ 	mt7915_mcu_set_eeprom(dev);
+ 	mt7915_mac_init(dev);
+ 	mt7915_init_txpower(dev, &dev->mphy.sband_2g.sband);
+ 	mt7915_init_txpower(dev, &dev->mphy.sband_5g.sband);
+ 	mt7915_txbf_init(dev);
+ }
+ 
+ static void mt7915_wfsys_reset(struct mt7915_dev *dev)
+ {
+ 	u32 val = MT_TOP_PWR_KEY | MT_TOP_PWR_SW_PWR_ON | MT_TOP_PWR_PWR_ON;
+ 
+ #define MT_MCU_DUMMY_RANDOM	GENMASK(15, 0)
+ #define MT_MCU_DUMMY_DEFAULT	GENMASK(31, 16)
+ 
+ 	mt76_wr(dev, MT_MCU_WFDMA0_DUMMY_CR, MT_MCU_DUMMY_RANDOM);
+ 
+ 	/* change to software control */
+ 	val |= MT_TOP_PWR_SW_RST;
+ 	mt76_wr(dev, MT_TOP_PWR_CTRL, val);
+ 
+ 	/* reset wfsys */
+ 	val &= ~MT_TOP_PWR_SW_RST;
+ 	mt76_wr(dev, MT_TOP_PWR_CTRL, val);
+ 
+ 	/* release wfsys then mcu re-excutes romcode */
+ 	val |= MT_TOP_PWR_SW_RST;
+ 	mt76_wr(dev, MT_TOP_PWR_CTRL, val);
+ 
+ 	/* switch to hw control */
+ 	val &= ~MT_TOP_PWR_SW_RST;
+ 	val |= MT_TOP_PWR_HW_CTRL;
+ 	mt76_wr(dev, MT_TOP_PWR_CTRL, val);
+ 
+ 	/* check whether mcu resets to default */
+ 	if (!mt76_poll_msec(dev, MT_MCU_WFDMA0_DUMMY_CR, MT_MCU_DUMMY_DEFAULT,
+ 			    MT_MCU_DUMMY_DEFAULT, 1000)) {
+ 		dev_err(dev->mt76.dev, "wifi subsystem reset failure\n");
+ 		return;
+ 	}
+ 
+ 	/* wfsys reset won't clear host registers */
+ 	mt76_clear(dev, MT_TOP_MISC, MT_TOP_MISC_FW_STATE);
+ 
+ 	msleep(100);
+ }
+ 
+ static int mt7915_init_hardware(struct mt7915_dev *dev)
+ {
+ 	int ret, idx;
+ 
+ 	mt76_wr(dev, MT_INT_SOURCE_CSR, ~0);
+ 
+ 	INIT_WORK(&dev->init_work, mt7915_init_work);
+ 	mt76_token_init(&dev->mt76);
+ 
+ 	dev->dbdc_support = !!(mt76_rr(dev, MT_HW_BOUND) & BIT(5));
+ 
+ 	/* If MCU was already running, it is likely in a bad state */
+ 	if (mt76_get_field(dev, MT_TOP_MISC, MT_TOP_MISC_FW_STATE) >
+ 	    FW_STATE_FW_DOWNLOAD)
+ 		mt7915_wfsys_reset(dev);
+ 
+ 	ret = mt7915_dma_init(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	set_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);
+ 
+ 	/*
+ 	 * force firmware operation mode into normal state,
+ 	 * which should be set before firmware download stage.
+ 	 */
+ 	mt76_wr(dev, MT_SWDEF_MODE, MT_SWDEF_NORMAL_MODE);
+ 
+ 	ret = mt7915_mcu_init(dev);
+ 	if (ret) {
+ 		/* Reset and try again */
+ 		mt7915_wfsys_reset(dev);
+ 
+ 		ret = mt7915_mcu_init(dev);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	ret = mt7915_eeprom_init(dev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 
+ 	if (dev->flash_mode) {
+ 		ret = mt7915_mcu_apply_group_cal(dev);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	/* Beacon and mgmt frames should occupy wcid 0 */
+ 	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7915_WTBL_STA - 1);
+ 	if (idx)
+ 		return -ENOSPC;
+ 
+ 	dev->mt76.global_wcid.idx = idx;
+ 	dev->mt76.global_wcid.hw_key_idx = -1;
+ 	dev->mt76.global_wcid.tx_info |= MT_WCID_TX_INFO_SET;
+ 	rcu_assign_pointer(dev->mt76.wcid[idx], &dev->mt76.global_wcid);
+ 
+ 	return 0;
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  }
  
  void mt7915_set_stream_vht_txbf_caps(struct mt7915_phy *phy)
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/mac.c
index 44bdff82d4d2,7a9759fb79d8..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
@@@ -902,30 -970,10 +902,10 @@@ void mt7915_mac_write_txwi(struct mt791
  		txwi[3] |= cpu_to_le32(MT_TXD3_BA_DISABLE);
  	}
  
 -	if (mt76_testmode_enabled(mphy))
 -		mt7915_mac_write_txwi_tm(mphy->priv, txwi, skb);
 +	if (mt76_testmode_enabled(&dev->mt76))
 +		mt7915_mac_write_txwi_tm(dev, mphy, txwi, skb);
  }
  
- static void
- mt7915_set_tx_blocked(struct mt7915_dev *dev, bool blocked)
- {
- 	struct mt76_phy *mphy = &dev->mphy, *mphy2 = dev->mt76.phy2;
- 	struct mt76_queue *q, *q2 = NULL;
- 
- 	q = mphy->q_tx[0];
- 	if (blocked == q->blocked)
- 		return;
- 
- 	q->blocked = blocked;
- 	if (mphy2) {
- 		q2 = mphy2->q_tx[0];
- 		q2->blocked = blocked;
- 	}
- 
- 	if (!blocked)
- 		mt76_worker_schedule(&dev->mt76.tx_worker);
- }
- 
  int mt7915_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
  			  enum mt76_txq_id qid, struct mt76_wcid *wcid,
  			  struct ieee80211_sta *sta,
@@@ -978,15 -1026,7 +958,19 @@@
  	t = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);
  	t->skb = tx_info->skb;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&dev->token_lock);
 +	id = idr_alloc(&dev->token, t, 0, MT7915_TOKEN_SIZE, GFP_ATOMIC);
 +	if (id >= 0)
 +		dev->token_count++;
 +
 +	if (dev->token_count >= MT7915_TOKEN_SIZE - MT7915_TOKEN_FREE_THR)
 +		mt7915_set_tx_blocked(dev, true);
 +	spin_unlock_bh(&dev->token_lock);
 +
++=======
+ 	id = mt76_token_consume(mdev, &t);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  	if (id < 0)
  		return id;
  
@@@ -1146,15 -1190,7 +1130,19 @@@ void mt7915_mac_tx_free(struct mt7915_d
  		msdu = FIELD_GET(MT_TX_FREE_MSDU_ID, info);
  		stat = FIELD_GET(MT_TX_FREE_STATUS, info);
  
++<<<<<<< HEAD
 +		spin_lock_bh(&dev->token_lock);
 +		txwi = idr_remove(&dev->token, msdu);
 +		if (txwi)
 +			dev->token_count--;
 +		if (dev->token_count < MT7915_TOKEN_SIZE - MT7915_TOKEN_FREE_THR &&
 +		    dev->mphy.q_tx[0]->blocked)
 +			wake = true;
 +		spin_unlock_bh(&dev->token_lock);
 +
++=======
+ 		txwi = mt76_token_release(mdev, msdu, &wake);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  		if (!txwi)
  			continue;
  
@@@ -1184,11 -1220,8 +1172,16 @@@
  
  	mt7915_mac_sta_poll(dev);
  
++<<<<<<< HEAD
 +	if (wake) {
 +		spin_lock_bh(&dev->token_lock);
 +		mt7915_set_tx_blocked(dev, false);
 +		spin_unlock_bh(&dev->token_lock);
 +	}
++=======
+ 	if (wake)
+ 		mt76_set_tx_blocked(&dev->mt76, false);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  
  	mt76_worker_schedule(&dev->mt76.tx_worker);
  
@@@ -1217,10 -1250,7 +1210,14 @@@ void mt7915_tx_complete_skb(struct mt76
  		struct mt7915_txp *txp;
  
  		txp = mt7915_txwi_to_txp(mdev, e->txwi);
++<<<<<<< HEAD
 +
 +		spin_lock_bh(&dev->token_lock);
 +		t = idr_remove(&dev->token, le16_to_cpu(txp->token));
 +		spin_unlock_bh(&dev->token_lock);
++=======
+ 		t = mt76_token_put(mdev, le16_to_cpu(txp->token));
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  		e->skb = t ? t->skb : NULL;
  	}
  
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/init.c
index a1cf9d52fcea,c32fea6378af..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
@@@ -163,9 -170,7 +163,13 @@@ static int mt7921_init_hardware(struct 
  {
  	int ret, idx;
  
++<<<<<<< HEAD
 +	spin_lock_init(&dev->token_lock);
 +	idr_init(&dev->token);
 +
++=======
+ 	mt76_token_init(&dev->mt76);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  	ret = mt7921_dma_init(dev);
  	if (ret)
  		return ret;
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index bcbd59a23f9b,256151bf6bf8..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@@ -788,15 -810,7 +774,19 @@@ int mt7921_tx_prepare_skb(struct mt76_d
  	t = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);
  	t->skb = tx_info->skb;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&dev->token_lock);
 +	id = idr_alloc(&dev->token, t, 0, MT7921_TOKEN_SIZE, GFP_ATOMIC);
 +	if (id >= 0)
 +		dev->token_count++;
 +
 +	if (dev->token_count >= MT7921_TOKEN_SIZE - MT7921_TOKEN_FREE_THR)
 +		mt7921_set_tx_blocked(dev, true);
 +	spin_unlock_bh(&dev->token_lock);
 +
++=======
+ 	id = mt76_token_consume(mdev, &t);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  	if (id < 0)
  		return id;
  
@@@ -958,15 -972,7 +948,19 @@@ void mt7921_mac_tx_free(struct mt7921_d
  		msdu = FIELD_GET(MT_TX_FREE_MSDU_ID, info);
  		stat = FIELD_GET(MT_TX_FREE_STATUS, info);
  
++<<<<<<< HEAD
 +		spin_lock_bh(&dev->token_lock);
 +		txwi = idr_remove(&dev->token, msdu);
 +		if (txwi)
 +			dev->token_count--;
 +		if (dev->token_count < MT7921_TOKEN_SIZE - MT7921_TOKEN_FREE_THR &&
 +		    dev->mphy.q_tx[0]->blocked)
 +			wake = true;
 +		spin_unlock_bh(&dev->token_lock);
 +
++=======
+ 		txwi = mt76_token_release(mdev, msdu, &wake);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  		if (!txwi)
  			continue;
  
@@@ -994,15 -1000,8 +988,20 @@@
  		mt76_put_txwi(mdev, txwi);
  	}
  
++<<<<<<< HEAD
 +	mt7921_mac_sta_poll(dev);
 +
 +	if (wake) {
 +		spin_lock_bh(&dev->token_lock);
 +		mt7921_set_tx_blocked(dev, false);
 +		spin_unlock_bh(&dev->token_lock);
 +	}
++=======
+ 	if (wake)
+ 		mt76_set_tx_blocked(&dev->mt76, false);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
 +
 +	mt76_worker_schedule(&dev->mt76.tx_worker);
  
  	napi_consume_skb(skb, 1);
  
@@@ -1030,11 -1032,8 +1029,14 @@@ void mt7921_tx_complete_skb(struct mt76
  		u16 token;
  
  		txp = mt7921_txwi_to_txp(mdev, e->txwi);
- 
  		token = le16_to_cpu(txp->hw.msdu_id[0]) & ~MT_MSDU_ID_VALID;
++<<<<<<< HEAD
 +		spin_lock_bh(&dev->token_lock);
 +		t = idr_remove(&dev->token, token);
 +		spin_unlock_bh(&dev->token_lock);
++=======
+ 		t = mt76_token_put(mdev, token);
++>>>>>>> d089692bc793 (mt76: move token utilities in mt76 common module)
  		e->skb = t ? t->skb : NULL;
  	}
  
diff --git a/drivers/net/wireless/mediatek/mt76/mt76.h b/drivers/net/wireless/mediatek/mt76/mt76.h
index 1f34f62819ee..be467428ba56 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@ -17,12 +17,14 @@
 #include "util.h"
 #include "testmode.h"
 
-#define MT_MCU_RING_SIZE    32
-#define MT_RX_BUF_SIZE      2048
-#define MT_SKB_HEAD_LEN     128
+#define MT_MCU_RING_SIZE	32
+#define MT_RX_BUF_SIZE		2048
+#define MT_SKB_HEAD_LEN		128
 
-#define MT_MAX_NON_AQL_PKT  16
-#define MT_TXQ_FREE_THR     32
+#define MT_MAX_NON_AQL_PKT	16
+#define MT_TXQ_FREE_THR		32
+
+#define MT76_TOKEN_FREE_THR	64
 
 struct mt76_dev;
 struct mt76_phy;
@@ -327,6 +329,7 @@ struct mt76_driver_ops {
 	u32 drv_flags;
 	u32 survey_flags;
 	u16 txwi_size;
+	u16 token_size;
 	u8 mcs_rates;
 
 	void (*update_survey)(struct mt76_dev *dev);
@@ -1154,4 +1157,41 @@ s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 			      struct mt76_power_limits *dest,
 			      s8 target_power);
 
+struct mt76_txwi_cache *
+mt76_token_release(struct mt76_dev *dev, int token, bool *wake);
+int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi);
+void mt76_token_init(struct mt76_dev *dev);
+void __mt76_set_tx_blocked(struct mt76_dev *dev, bool blocked);
+
+static inline void mt76_set_tx_blocked(struct mt76_dev *dev, bool blocked)
+{
+	spin_lock_bh(&dev->token_lock);
+	__mt76_set_tx_blocked(dev, blocked);
+	spin_unlock_bh(&dev->token_lock);
+}
+
+static inline int
+mt76_token_get(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi)
+{
+	int token;
+
+	spin_lock_bh(&dev->token_lock);
+	token = idr_alloc(&dev->token, *ptxwi, 0, dev->drv->token_size,
+			  GFP_ATOMIC);
+	spin_unlock_bh(&dev->token_lock);
+
+	return token;
+}
+
+static inline struct mt76_txwi_cache *
+mt76_token_put(struct mt76_dev *dev, int token)
+{
+	struct mt76_txwi_cache *txwi;
+
+	spin_lock_bh(&dev->token_lock);
+	txwi = idr_remove(&dev->token, token);
+	spin_unlock_bh(&dev->token_lock);
+
+	return txwi;
+}
 #endif
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c b/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c
index d3267dcbc8f2..3dca2f9b4d91 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c
@@ -181,6 +181,7 @@ int mt7615_mmio_probe(struct device *pdev, void __iomem *mem_base,
 		.survey_flags = SURVEY_INFO_TIME_TX |
 				SURVEY_INFO_TIME_RX |
 				SURVEY_INFO_TIME_BSS_RX,
+		.token_size = MT7615_TOKEN_SIZE,
 		.tx_prepare_skb = mt7615_tx_prepare_skb,
 		.tx_complete_skb = mt7615_tx_complete_skb,
 		.rx_skb = mt7615_queue_rx_skb,
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/init.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h b/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
index 2ffe7fd42d87..4f53e08dcf39 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
@@ -32,7 +32,6 @@
 
 #define MT7915_EEPROM_SIZE		3584
 #define MT7915_TOKEN_SIZE		8192
-#define MT7915_TOKEN_FREE_THR		64
 
 #define MT7915_CFEND_RATE_DEFAULT	0x49	/* OFDM 24M */
 #define MT7915_CFEND_RATE_11B		0x03	/* 11B LP, 11M */
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/pci.c b/drivers/net/wireless/mediatek/mt76/mt7915/pci.c
index 3ac5bbb94d29..269ea8b630b3 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/pci.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/pci.c
@@ -105,6 +105,7 @@ static int mt7915_pci_probe(struct pci_dev *pdev,
 		.survey_flags = SURVEY_INFO_TIME_TX |
 				SURVEY_INFO_TIME_RX |
 				SURVEY_INFO_TIME_BSS_RX,
+		.token_size = MT7915_TOKEN_SIZE,
 		.tx_prepare_skb = mt7915_tx_prepare_skb,
 		.tx_complete_skb = mt7915_tx_complete_skb,
 		.rx_skb = mt7915_queue_rx_skb,
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/init.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index 6e3579d48c30..142bd6e0507a 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@ -32,7 +32,6 @@
 
 #define MT7921_EEPROM_SIZE		3584
 #define MT7921_TOKEN_SIZE		8192
-#define MT7921_TOKEN_FREE_THR		64
 
 #define MT7921_CFEND_RATE_DEFAULT	0x49	/* OFDM 24M */
 #define MT7921_CFEND_RATE_11B		0x03	/* 11B LP, 11M */
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/pci.c b/drivers/net/wireless/mediatek/mt76/mt7921/pci.c
index 395aac82f6c2..8029de4473c5 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/pci.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/pci.c
@@ -86,6 +86,7 @@ static int mt7921_pci_probe(struct pci_dev *pdev,
 		.survey_flags = SURVEY_INFO_TIME_TX |
 				SURVEY_INFO_TIME_RX |
 				SURVEY_INFO_TIME_BSS_RX,
+		.token_size = MT7921_TOKEN_SIZE,
 		.tx_prepare_skb = mt7921_tx_prepare_skb,
 		.tx_complete_skb = mt7921_tx_complete_skb,
 		.rx_skb = mt7921_queue_rx_skb,
diff --git a/drivers/net/wireless/mediatek/mt76/tx.c b/drivers/net/wireless/mediatek/mt76/tx.c
index a3689d8e2307..0060002af763 100644
--- a/drivers/net/wireless/mediatek/mt76/tx.c
+++ b/drivers/net/wireless/mediatek/mt76/tx.c
@@ -631,3 +631,71 @@ void mt76_queue_tx_complete(struct mt76_dev *dev, struct mt76_queue *q,
 	spin_unlock_bh(&q->lock);
 }
 EXPORT_SYMBOL_GPL(mt76_queue_tx_complete);
+
+void mt76_token_init(struct mt76_dev *dev)
+{
+	spin_lock_init(&dev->token_lock);
+	idr_init(&dev->token);
+}
+EXPORT_SYMBOL_GPL(mt76_token_init);
+
+void __mt76_set_tx_blocked(struct mt76_dev *dev, bool blocked)
+{
+	struct mt76_phy *phy = &dev->phy, *phy2 = dev->phy2;
+	struct mt76_queue *q, *q2 = NULL;
+
+	q = phy->q_tx[0];
+	if (blocked == q->blocked)
+		return;
+
+	q->blocked = blocked;
+	if (phy2) {
+		q2 = phy2->q_tx[0];
+		q2->blocked = blocked;
+	}
+
+	if (!blocked)
+		mt76_worker_schedule(&dev->tx_worker);
+}
+EXPORT_SYMBOL_GPL(__mt76_set_tx_blocked);
+
+int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi)
+{
+	int token;
+
+	spin_lock_bh(&dev->token_lock);
+
+	token = idr_alloc(&dev->token, *ptxwi, 0, dev->drv->token_size,
+			  GFP_ATOMIC);
+	if (token >= 0)
+		dev->token_count++;
+
+	if (dev->token_count >= dev->drv->token_size - MT76_TOKEN_FREE_THR)
+		__mt76_set_tx_blocked(dev, true);
+
+	spin_unlock_bh(&dev->token_lock);
+
+	return token;
+}
+EXPORT_SYMBOL_GPL(mt76_token_consume);
+
+struct mt76_txwi_cache *
+mt76_token_release(struct mt76_dev *dev, int token, bool *wake)
+{
+	struct mt76_txwi_cache *txwi;
+
+	spin_lock_bh(&dev->token_lock);
+
+	txwi = idr_remove(&dev->token, token);
+	if (txwi)
+		dev->token_count--;
+
+	if (dev->token_count < dev->drv->token_size - MT76_TOKEN_FREE_THR &&
+	    dev->phy.q_tx[0]->blocked)
+		*wake = true;
+
+	spin_unlock_bh(&dev->token_lock);
+
+	return txwi;
+}
+EXPORT_SYMBOL_GPL(mt76_token_release);
