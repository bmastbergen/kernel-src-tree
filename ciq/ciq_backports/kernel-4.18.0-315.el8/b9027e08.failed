mt76: move chainmask in mt76_phy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit b9027e0816ebbced1248924beffc28f0146c0e72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/b9027e08.failed

Move chainmask from driver phy to mt76_phy since it is used by all
drivers. This is a preliminary patch to create a common mcu library used
by mt7615 and mt7921 drivers

Co-developed-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit b9027e0816ebbced1248924beffc28f0146c0e72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt76.h
#	drivers/net/wireless/mediatek/mt76/mt7615/testmode.c
#	drivers/net/wireless/mediatek/mt76/mt7915/eeprom.c
#	drivers/net/wireless/mediatek/mt76/mt7915/init.c
#	drivers/net/wireless/mediatek/mt76/mt7915/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
diff --cc drivers/net/wireless/mediatek/mt76/mt76.h
index b1381101ffac,1925e7fbc1b1..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@@ -574,6 -579,14 +574,17 @@@ struct mt76_phy 
  
  	int txpower_cur;
  	u8 antenna_mask;
++<<<<<<< HEAD
++=======
+ 	u16 chainmask;
+ 
+ #ifdef CONFIG_NL80211_TESTMODE
+ 	struct mt76_testmode_data test;
+ #endif
+ 
+ 	struct delayed_work mac_work;
+ 	u8 mac_work_count;
++>>>>>>> b9027e0816eb (mt76: move chainmask in mt76_phy)
  };
  
  struct mt76_dev {
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/testmode.c
index 8fc97a52411a,a0542a309e27..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/testmode.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/testmode.c
@@@ -185,7 -178,7 +185,11 @@@ mt7615_tm_set_tx_antenna(struct mt7615_
  		return;
  
  	if (!en)
++<<<<<<< HEAD
 +		mask = dev->phy.chainmask;
++=======
+ 		mask = phy->mt76->chainmask;
++>>>>>>> b9027e0816eb (mt76: move chainmask in mt76_phy)
  
  	for (i = 0; i < 4; i++) {
  		mt76_rmw_field(dev, MT_WF_PHY_RFINTF3_0(i),
@@@ -311,7 -306,7 +315,11 @@@ mt7615_tm_set_params(struct mt76_dev *m
  	    td->state == MT76_TM_STATE_OFF)
  		return 0;
  
++<<<<<<< HEAD
 +	if (td->tx_antenna_mask & ~dev->phy.chainmask)
++=======
+ 	if (td->tx_antenna_mask & ~mphy->chainmask)
++>>>>>>> b9027e0816eb (mt76: move chainmask in mt76_phy)
  		return -EINVAL;
  
  	for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/eeprom.c
index d65910cc0709,7807b9165e01..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/eeprom.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/eeprom.c
@@@ -52,26 -55,41 +52,38 @@@ static void mt7915_eeprom_parse_hw_cap(
  	val = FIELD_GET(MT_EE_WIFI_CONF_BAND_SEL, val);
  	switch (val) {
  	case MT_EE_5GHZ:
 -		phy->mt76->cap.has_5ghz = true;
 +		dev->mphy.cap.has_5ghz = true;
  		break;
  	case MT_EE_2GHZ:
 -		phy->mt76->cap.has_2ghz = true;
 +		dev->mphy.cap.has_2ghz = true;
  		break;
  	default:
 -		phy->mt76->cap.has_2ghz = true;
 -		phy->mt76->cap.has_5ghz = true;
 +		dev->mphy.cap.has_2ghz = true;
 +		dev->mphy.cap.has_5ghz = true;
  		break;
  	}
 -}
 -
 -static void mt7915_eeprom_parse_hw_cap(struct mt7915_dev *dev)
 -{
 -	u8 nss, tx_mask[2] = {}, *eeprom = dev->mt76.eeprom.data;
 -
 -	mt7915_eeprom_parse_band_config(&dev->phy);
  
  	/* read tx mask from eeprom */
 -	tx_mask[0] = FIELD_GET(MT_EE_WIFI_CONF_TX_MASK,
 -			       eeprom[MT_EE_WIFI_CONF]);
 -	if (dev->dbdc_support)
 -		tx_mask[1] = FIELD_GET(MT_EE_WIFI_CONF_TX_MASK,
 -				       eeprom[MT_EE_WIFI_CONF + 1]);
 -
 +	tx_mask =  FIELD_GET(MT_EE_WIFI_CONF_TX_MASK,
 +			     eeprom[MT_EE_WIFI_CONF]);
 +	if (!tx_mask || tx_mask > max_nss)
 +		tx_mask = max_nss;
 +
++<<<<<<< HEAD
 +	dev->chainmask = BIT(tx_mask) - 1;
 +	dev->mphy.antenna_mask = dev->chainmask;
 +	dev->phy.chainmask = dev->chainmask;
++=======
+ 	nss = tx_mask[0] + tx_mask[1];
+ 	if (!nss || nss > 4) {
+ 		tx_mask[0] = 4;
+ 		nss = 4;
+ 	}
+ 
+ 	dev->chainmask = BIT(nss) - 1;
+ 	dev->mphy.antenna_mask = BIT(tx_mask[0]) - 1;
+ 	dev->mphy.chainmask = dev->mphy.antenna_mask;
++>>>>>>> b9027e0816eb (mt76: move chainmask in mt76_phy)
  }
  
  int mt7915_eeprom_init(struct mt7915_dev *dev)
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/init.c
index 49c09d0d8906,eed35443e69c..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
@@@ -269,9 -113,223 +269,226 @@@ mt7915_init_wiphy(struct ieee80211_hw *
  	hw->max_tx_fragments = 4;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mt7915_mac_init_band(struct mt7915_dev *dev, u8 band)
+ {
+ 	u32 mask, set;
+ 
+ 	mt76_rmw_field(dev, MT_TMAC_CTCR0(band),
+ 		       MT_TMAC_CTCR0_INS_DDLMT_REFTIME, 0x3f);
+ 	mt76_set(dev, MT_TMAC_CTCR0(band),
+ 		 MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN |
+ 		 MT_TMAC_CTCR0_INS_DDLMT_EN);
+ 
+ 	mask = MT_MDP_RCFR0_MCU_RX_MGMT |
+ 	       MT_MDP_RCFR0_MCU_RX_CTL_NON_BAR |
+ 	       MT_MDP_RCFR0_MCU_RX_CTL_BAR;
+ 	set = FIELD_PREP(MT_MDP_RCFR0_MCU_RX_MGMT, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR0_MCU_RX_CTL_NON_BAR, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR0_MCU_RX_CTL_BAR, MT_MDP_TO_HIF);
+ 	mt76_rmw(dev, MT_MDP_BNRCFR0(band), mask, set);
+ 
+ 	mask = MT_MDP_RCFR1_MCU_RX_BYPASS |
+ 	       MT_MDP_RCFR1_RX_DROPPED_UCAST |
+ 	       MT_MDP_RCFR1_RX_DROPPED_MCAST;
+ 	set = FIELD_PREP(MT_MDP_RCFR1_MCU_RX_BYPASS, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR1_RX_DROPPED_UCAST, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR1_RX_DROPPED_MCAST, MT_MDP_TO_HIF);
+ 	mt76_rmw(dev, MT_MDP_BNRCFR1(band), mask, set);
+ 
+ 	mt76_set(dev, MT_WF_RMAC_MIB_TIME0(band), MT_WF_RMAC_MIB_RXTIME_EN);
+ 	mt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0(band), MT_WF_RMAC_MIB_RXTIME_EN);
+ 
+ 	mt76_rmw_field(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_MAX_RX_LEN, 1536);
+ 	/* disable rx rate report by default due to hw issues */
+ 	mt76_clear(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_RXD_G5_EN);
+ }
+ 
+ static void mt7915_mac_init(struct mt7915_dev *dev)
+ {
+ 	int i;
+ 
+ 	mt76_rmw_field(dev, MT_MDP_DCR1, MT_MDP_DCR1_MAX_RX_LEN, 1536);
+ 	/* disable hardware de-agg */
+ 	mt76_clear(dev, MT_MDP_DCR0, MT_MDP_DCR0_DAMSDU_EN);
+ 
+ 	for (i = 0; i < MT7915_WTBL_SIZE; i++)
+ 		mt7915_mac_wtbl_update(dev, i,
+ 				       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
+ 	for (i = 0; i < 2; i++)
+ 		mt7915_mac_init_band(dev, i);
+ 
+ 	mt7915_mcu_set_rts_thresh(&dev->phy, 0x92b);
+ }
+ 
+ static int mt7915_txbf_init(struct mt7915_dev *dev)
+ {
+ 	int ret;
+ 
+ 	/*
+ 	 * TODO: DBDC & check whether iBF phase calibration data has
+ 	 * been stored in eeprom offset 0x651~0x7b8, then write down
+ 	 * 0x1111 into 0x651 and 0x651 to trigger iBF.
+ 	 */
+ 
+ 	/* trigger sounding packets */
+ 	ret = mt7915_mcu_set_txbf_sounding(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* enable iBF & eBF */
+ 	return mt7915_mcu_set_txbf_type(dev);
+ }
+ 
+ static void
+ mt7915_init_txpower_band(struct mt7915_dev *dev,
+ 			 struct ieee80211_supported_band *sband)
+ {
+ 	int i, n_chains = hweight8(dev->mphy.antenna_mask);
+ 
+ 	for (i = 0; i < sband->n_channels; i++) {
+ 		struct ieee80211_channel *chan = &sband->channels[i];
+ 		u32 target_power = 0;
+ 		int j;
+ 
+ 		for (j = 0; j < n_chains; j++) {
+ 			u32 val;
+ 
+ 			val = mt7915_eeprom_get_target_power(dev, chan, j);
+ 			target_power = max(target_power, val);
+ 		}
+ 
+ 		chan->max_power = min_t(int, chan->max_reg_power,
+ 					target_power / 2);
+ 		chan->orig_mpwr = target_power / 2;
+ 	}
+ }
+ 
+ static void mt7915_init_txpower(struct mt7915_dev *dev)
+ {
+ 	mt7915_init_txpower_band(dev, &dev->mphy.sband_2g.sband);
+ 	mt7915_init_txpower_band(dev, &dev->mphy.sband_5g.sband);
+ 
+ 	mt7915_eeprom_init_sku(dev);
+ }
+ 
+ static int mt7915_register_ext_phy(struct mt7915_dev *dev)
+ {
+ 	struct mt7915_phy *phy = mt7915_ext_phy(dev);
+ 	struct mt76_phy *mphy;
+ 	int ret;
+ 
+ 	if (!dev->dbdc_support)
+ 		return 0;
+ 
+ 	if (phy)
+ 		return 0;
+ 
+ 	mphy = mt76_alloc_phy(&dev->mt76, sizeof(*phy), &mt7915_ops);
+ 	if (!mphy)
+ 		return -ENOMEM;
+ 
+ 	phy = mphy->priv;
+ 	phy->dev = dev;
+ 	phy->mt76 = mphy;
+ 	mphy->chainmask = dev->chainmask & ~dev->mphy.chainmask;
+ 	mphy->antenna_mask = BIT(hweight8(mphy->chainmask)) - 1;
+ 	mt7915_init_wiphy(mphy->hw);
+ 
+ 	INIT_LIST_HEAD(&phy->stats_list);
+ 	INIT_DELAYED_WORK(&mphy->mac_work, mt7915_mac_work);
+ 
+ 	mt7915_eeprom_parse_band_config(phy);
+ 	mt7915_set_stream_vht_txbf_caps(phy);
+ 	mt7915_set_stream_he_caps(phy);
+ 
+ 	memcpy(mphy->macaddr, dev->mt76.eeprom.data + MT_EE_MAC_ADDR2,
+ 	       ETH_ALEN);
+ 	mt76_eeprom_override(mphy);
+ 
+ 	/* The second interface does not get any packets unless it has a vif */
+ 	ieee80211_hw_set(mphy->hw, WANT_MONITOR_VIF);
+ 
+ 	ret = mt7915_init_tx_queues(phy, MT7915_TXQ_BAND1,
+ 				    MT7915_TX_RING_SIZE);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = mt76_register_phy(mphy, true, mt7915_rates,
+ 				ARRAY_SIZE(mt7915_rates));
+ 	if (ret)
+ 		goto error;
+ 
+ 	return 0;
+ 
+ error:
+ 	ieee80211_free_hw(mphy->hw);
+ 	return ret;
+ }
+ 
+ static void mt7915_init_work(struct work_struct *work)
+ {
+ 	struct mt7915_dev *dev = container_of(work, struct mt7915_dev,
+ 				 init_work);
+ 
+ 	mt7915_mcu_set_eeprom(dev);
+ 	mt7915_mac_init(dev);
+ 	mt7915_init_txpower(dev);
+ 	mt7915_txbf_init(dev);
+ 	mt7915_register_ext_phy(dev);
+ }
+ 
+ static int mt7915_init_hardware(struct mt7915_dev *dev)
+ {
+ 	int ret, idx;
+ 
+ 	mt76_wr(dev, MT_INT_SOURCE_CSR, ~0);
+ 
+ 	INIT_WORK(&dev->init_work, mt7915_init_work);
+ 	spin_lock_init(&dev->token_lock);
+ 	idr_init(&dev->token);
+ 
+ 	dev->dbdc_support = !!(mt7915_l1_rr(dev, MT_HW_BOUND) & BIT(5));
+ 
+ 	ret = mt7915_dma_init(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	set_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);
+ 
+ 	/*
+ 	 * force firmware operation mode into normal state,
+ 	 * which should be set before firmware download stage.
+ 	 */
+ 	mt76_wr(dev, MT_SWDEF_MODE, MT_SWDEF_NORMAL_MODE);
+ 
+ 	ret = mt7915_mcu_init(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = mt7915_eeprom_init(dev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	/* Beacon and mgmt frames should occupy wcid 0 */
+ 	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7915_WTBL_STA - 1);
+ 	if (idx)
+ 		return -ENOSPC;
+ 
+ 	dev->mt76.global_wcid.idx = idx;
+ 	dev->mt76.global_wcid.hw_key_idx = -1;
+ 	dev->mt76.global_wcid.tx_info |= MT_WCID_TX_INFO_SET;
+ 	rcu_assign_pointer(dev->mt76.wcid[idx], &dev->mt76.global_wcid);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> b9027e0816eb (mt76: move chainmask in mt76_phy)
  void mt7915_set_stream_vht_txbf_caps(struct mt7915_phy *phy)
  {
- 	int nss = hweight8(phy->chainmask);
+ 	int nss = hweight8(phy->mt76->chainmask);
  	u32 *cap = &phy->mt76->sband_5g.sband.vht_cap.cap;
  
  	*cap |= IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |
@@@ -672,7 -643,16 +888,20 @@@ int mt7915_register_device(struct mt791
  	dev->mphy.sband_5g.sband.vht_cap.cap |=
  			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 |
  			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;
++<<<<<<< HEAD
 +	mt7915_cap_dbdc_disable(dev);
++=======
+ 	if (!dev->dbdc_support)
+ 		dev->mphy.sband_5g.sband.vht_cap.cap |=
+ 			IEEE80211_VHT_CAP_SHORT_GI_160 |
+ 			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;
+ 	dev->mphy.hw->wiphy->available_antennas_rx = dev->mphy.chainmask;
+ 	dev->mphy.hw->wiphy->available_antennas_tx = dev->mphy.chainmask;
+ 
+ 	mt76_set_stream_caps(&dev->mphy, true);
+ 	mt7915_set_stream_vht_txbf_caps(&dev->phy);
+ 	mt7915_set_stream_he_caps(&dev->phy);
++>>>>>>> b9027e0816eb (mt76: move chainmask in mt76_phy)
  	dev->phy.dfs_state = -1;
  
  #ifdef CONFIG_NL80211_TESTMODE
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/mac.c
index 2621e27aedf5,261bb1890a4c..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
@@@ -1351,9 -1362,8 +1351,14 @@@ mt7915_phy_get_nf(struct mt7915_phy *ph
  	u32 val, sum = 0, n = 0;
  	int nss, i;
  
++<<<<<<< HEAD
 +	/* TODO: DBDC: 0,1 for 2.4G, 2,3 for 5G */
 +	for (nss = 0; nss < hweight8(phy->chainmask); nss++) {
 +		u32 reg = MT_WF_IRPI(nss);
++=======
+ 	for (nss = 0; nss < hweight8(phy->mt76->chainmask); nss++) {
+ 		u32 reg = MT_WF_IRPI(nss + (idx << dev->dbdc_support));
++>>>>>>> b9027e0816eb (mt76: move chainmask in mt76_phy)
  
  		for (i = 0; i < ARRAY_SIZE(nf_power); i++, reg += 4) {
  			val = mt7915_l2_rr(dev, reg);
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
index fe56ab18e974,06353de2e762..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
@@@ -307,7 -316,7 +307,11 @@@ mt7915_tm_set_params(struct mt76_dev *m
  	    td->state == MT76_TM_STATE_OFF)
  		return 0;
  
++<<<<<<< HEAD
 +	if (td->tx_antenna_mask & ~dev->phy.chainmask)
++=======
+ 	if (td->tx_antenna_mask & ~mphy->chainmask)
++>>>>>>> b9027e0816eb (mt76: move chainmask in mt76_phy)
  		return -EINVAL;
  
  	for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/eeprom.c b/drivers/net/wireless/mediatek/mt76/mt7615/eeprom.c
index ea69aadfd531..cece5598d304 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/eeprom.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/eeprom.c
@@ -161,7 +161,7 @@ static void mt7615_eeprom_parse_hw_cap(struct mt7615_dev *dev)
 
 	dev->chainmask = BIT(tx_mask) - 1;
 	dev->mphy.antenna_mask = dev->chainmask;
-	dev->phy.chainmask = dev->chainmask;
+	dev->mphy.chainmask = dev->chainmask;
 }
 
 static int mt7663_eeprom_get_target_power_index(struct mt7615_dev *dev,
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/init.c b/drivers/net/wireless/mediatek/mt76/mt7615/init.c
index e470a75365f8..29abca7529f9 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/init.c
@@ -362,9 +362,9 @@ mt7615_cap_dbdc_enable(struct mt7615_dev *dev)
 		dev->mphy.antenna_mask = dev->chainmask >> 2;
 	else
 		dev->mphy.antenna_mask = dev->chainmask >> 1;
-	dev->phy.chainmask = dev->mphy.antenna_mask;
-	dev->mphy.hw->wiphy->available_antennas_rx = dev->phy.chainmask;
-	dev->mphy.hw->wiphy->available_antennas_tx = dev->phy.chainmask;
+	dev->mphy.chainmask = dev->mphy.antenna_mask;
+	dev->mphy.hw->wiphy->available_antennas_rx = dev->mphy.chainmask;
+	dev->mphy.hw->wiphy->available_antennas_tx = dev->mphy.chainmask;
 	mt76_set_stream_caps(&dev->mphy, true);
 }
 
@@ -375,7 +375,7 @@ mt7615_cap_dbdc_disable(struct mt7615_dev *dev)
 			IEEE80211_VHT_CAP_SHORT_GI_160 |
 			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;
 	dev->mphy.antenna_mask = dev->chainmask;
-	dev->phy.chainmask = dev->chainmask;
+	dev->mphy.chainmask = dev->chainmask;
 	dev->mphy.hw->wiphy->available_antennas_rx = dev->chainmask;
 	dev->mphy.hw->wiphy->available_antennas_tx = dev->chainmask;
 	mt76_set_stream_caps(&dev->mphy, true);
@@ -404,8 +404,8 @@ int mt7615_register_ext_phy(struct mt7615_dev *dev)
 	phy = mphy->priv;
 	phy->dev = dev;
 	phy->mt76 = mphy;
-	phy->chainmask = dev->chainmask & ~dev->phy.chainmask;
-	mphy->antenna_mask = BIT(hweight8(phy->chainmask)) - 1;
+	mphy->chainmask = dev->chainmask & ~dev->mphy.chainmask;
+	mphy->antenna_mask = BIT(hweight8(mphy->chainmask)) - 1;
 	mt7615_init_wiphy(mphy->hw);
 
 	INIT_DELAYED_WORK(&phy->mac_work, mt7615_mac_work);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
index 433d4c941a48..aee6af059a22 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
@@ -326,7 +326,7 @@ static int mt7615_mac_fill_rx(struct mt7615_dev *dev, struct sk_buff *skb)
 		 * that PHY.
 		 */
 		if (phy_idx < 0) {
-			int first_chain = ffs(phy2->chainmask) - 1;
+			int first_chain = ffs(phy2->mt76->chainmask) - 1;
 
 			phy_idx = ((rxdg5 >> (first_chain * 8)) & 0xff) == 0;
 		}
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/main.c b/drivers/net/wireless/mediatek/mt76/mt7615/main.c
index 56dd0b4e4460..b502b7568465 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/main.c
@@ -910,7 +910,7 @@ mt7615_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
 		else
 			tx_ant <<= 1;
 	}
-	phy->chainmask = tx_ant;
+	phy->mt76->chainmask = tx_ant;
 
 	mt76_set_stream_caps(phy->mt76, true);
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
index 39f4f540cb69..7fdbcd0115b7 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
@@ -1662,7 +1662,7 @@ mt7615_mcu_uni_add_bss(struct mt7615_phy *phy, struct ieee80211_vif *vif,
 			.center_chan = ieee80211_frequency_to_channel(freq1),
 			.center_chan2 = ieee80211_frequency_to_channel(freq2),
 			.tx_streams = hweight8(phy->mt76->antenna_mask),
-			.rx_streams = phy->chainmask,
+			.rx_streams = phy->mt76->chainmask,
 			.short_st = true,
 		},
 	};
@@ -2880,7 +2880,7 @@ int mt7615_mcu_set_chan_info(struct mt7615_phy *phy, int cmd)
 		.control_chan = chandef->chan->hw_value,
 		.center_chan = ieee80211_frequency_to_channel(freq1),
 		.tx_streams = hweight8(phy->mt76->antenna_mask),
-		.rx_streams_mask = phy->chainmask,
+		.rx_streams_mask = phy->mt76->chainmask,
 		.center_chan2 = ieee80211_frequency_to_channel(freq2),
 	};
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h b/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
index d697ff2ea56e..7df9752d4e57 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
@@ -171,8 +171,6 @@ struct mt7615_phy {
 	s8 ofdm_sensitivity;
 	s8 cck_sensitivity;
 
-	u16 chainmask;
-
 	s16 coverage_class;
 	u8 slottime;
 
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/testmode.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x02.h b/drivers/net/wireless/mediatek/mt76/mt76x02.h
index d626817a2103..4d58c2c1c0ac 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x02.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02.h
@@ -82,8 +82,6 @@ struct mt76x02_dev {
 
 	struct mutex phy_mutex;
 
-	u16 chainmask;
-
 	u8 txdone_seq;
 	DECLARE_KFIFO_PTR(txstatus_fifo, struct mt76x02_tx_status);
 	spinlock_t txstatus_fifo_lock;
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c b/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c
index da6d3f51f6d4..b33e9a9ed17b 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c
@@ -345,7 +345,7 @@ void mt76x02_mac_write_txwi(struct mt76x02_dev *dev, struct mt76x02_txwi *txwi,
 	u16 txwi_flags = 0;
 	u8 nss;
 	s8 txpwr_adj, max_txpwr_adj;
-	u8 ccmp_pn[8], nstreams = dev->chainmask & 0xf;
+	u8 ccmp_pn[8], nstreams = dev->mphy.chainmask & 0xf;
 
 	memset(txwi, 0, sizeof(*txwi));
 
@@ -685,7 +685,7 @@ mt76x02_mac_process_rate(struct mt76x02_dev *dev,
 		status->rate_idx = idx;
 		break;
 	case MT_PHY_TYPE_VHT: {
-		u8 n_rxstream = dev->chainmask & 0xf;
+		u8 n_rxstream = dev->mphy.chainmask & 0xf;
 
 		status->encoding = RX_ENC_VHT;
 		status->rate_idx = FIELD_GET(MT_RATE_INDEX_VHT_IDX, idx);
@@ -777,7 +777,7 @@ int mt76x02_mac_process_rx(struct mt76x02_dev *dev, struct sk_buff *skb,
 	u16 rate = le16_to_cpu(rxwi->rate);
 	u16 tid_sn = le16_to_cpu(rxwi->tid_sn);
 	bool unicast = rxwi->rxinfo & cpu_to_le32(MT_RXINFO_UNICAST);
-	int pad_len = 0, nstreams = dev->chainmask & 0xf;
+	int pad_len = 0, nstreams = dev->mphy.chainmask & 0xf;
 	s8 signal;
 	u8 pn_len;
 	u8 wcid;
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x02_phy.c b/drivers/net/wireless/mediatek/mt76/mt76x02_phy.c
index aaadc15ea83c..2e53b0c1afdd 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_phy.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_phy.c
@@ -16,7 +16,7 @@ void mt76x02_phy_set_rxpath(struct mt76x02_dev *dev)
 	val = mt76_rr(dev, MT_BBP(AGC, 0));
 	val &= ~BIT(4);
 
-	switch (dev->chainmask & 0xf) {
+	switch (dev->mphy.chainmask & 0xf) {
 	case 2:
 		val |= BIT(3);
 		break;
@@ -35,7 +35,7 @@ void mt76x02_phy_set_txdac(struct mt76x02_dev *dev)
 {
 	int txpath;
 
-	txpath = (dev->chainmask >> 8) & 0xf;
+	txpath = (dev->mphy.chainmask >> 8) & 0xf;
 	switch (txpath) {
 	case 2:
 		mt76_set(dev, MT_BBP(TXBE, 5), 0x3);
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x02_util.c b/drivers/net/wireless/mediatek/mt76/mt76x02_util.c
index ea31650a01b8..460f3775d5df 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_util.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_util.c
@@ -197,10 +197,10 @@ void mt76x02_init_device(struct mt76x02_dev *dev)
 				IEEE80211_HT_CAP_LDPC_CODING;
 		dev->mphy.sband_5g.sband.ht_cap.cap |=
 				IEEE80211_HT_CAP_LDPC_CODING;
-		dev->chainmask = 0x202;
+		dev->mphy.chainmask = 0x202;
 		dev->mphy.antenna_mask = 3;
 	} else {
-		dev->chainmask = 0x101;
+		dev->mphy.chainmask = 0x101;
 		dev->mphy.antenna_mask = 1;
 	}
 }
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x2/mcu.c b/drivers/net/wireless/mediatek/mt76/mt76x2/mcu.c
index 3c2738903d7d..ac83ce5f3e8b 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x2/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x2/mcu.c
@@ -29,7 +29,7 @@ int mt76x2_mcu_set_channel(struct mt76x02_dev *dev, u8 channel, u8 bw,
 		.idx = channel,
 		.scan = scan,
 		.bw = bw,
-		.chainmask = cpu_to_le16(dev->chainmask),
+		.chainmask = cpu_to_le16(dev->mphy.chainmask),
 	};
 
 	/* first set the channel without the extension channel info */
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x2/pci_main.c b/drivers/net/wireless/mediatek/mt76/mt76x2/pci_main.c
index 98f4cf398320..cf19abcff9b6 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x2/pci_main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x2/pci_main.c
@@ -116,7 +116,7 @@ static int mt76x2_set_antenna(struct ieee80211_hw *hw, u32 tx_ant,
 
 	mutex_lock(&dev->mt76.mutex);
 
-	dev->chainmask = (tx_ant == 3) ? 0x202 : 0x101;
+	dev->mphy.chainmask = (tx_ant == 3) ? 0x202 : 0x101;
 	dev->mphy.antenna_mask = tx_ant;
 
 	mt76_set_stream_caps(&dev->mphy, true);
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/eeprom.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/init.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/main.c b/drivers/net/wireless/mediatek/mt76/mt7915/main.c
index e5708026df54..62a609eefc99 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/main.c
@@ -810,7 +810,7 @@ mt7915_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
 		else
 			tx_ant <<= 1;
 	}
-	phy->chainmask = tx_ant;
+	phy->mt76->chainmask = tx_ant;
 
 	mt76_set_stream_caps(phy->mt76, true);
 	mt7915_set_stream_vht_txbf_caps(phy);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
index a43f6e293aa8..5f3319920b18 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
@@ -839,9 +839,9 @@ static void
 mt7915_mcu_bss_ra_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 		      struct mt7915_phy *phy)
 {
+	int max_nss = hweight8(phy->mt76->chainmask);
 	struct bss_info_ra *ra;
 	struct tlv *tlv;
-	int max_nss = hweight8(phy->chainmask);
 
 	tlv = mt7915_mcu_add_tlv(skb, BSS_INFO_RA, sizeof(*ra));
 
@@ -1776,7 +1776,7 @@ mt7915_mcu_sta_bfer_vht(struct ieee80211_sta *sta, struct mt7915_phy *phy,
 {
 	struct ieee80211_sta_vht_cap *pc = &sta->vht_cap;
 	struct ieee80211_sta_vht_cap *vc = &phy->mt76->sband_5g.sband.vht_cap;
-	u8 bfee_nr, bfer_nr, n, tx_ant = hweight8(phy->chainmask) - 1;
+	u8 bfee_nr, bfer_nr, n, tx_ant = hweight8(phy->mt76->chainmask) - 1;
 	u16 mcs_map;
 
 	bf->tx_mode = MT_PHY_TYPE_VHT;
@@ -1873,9 +1873,9 @@ mt7915_mcu_sta_bfer_tlv(struct sk_buff *skb, struct ieee80211_sta *sta,
 			struct ieee80211_vif *vif, struct mt7915_phy *phy,
 			bool enable)
 {
+	int tx_ant = hweight8(phy->mt76->chainmask) - 1;
 	struct sta_rec_bf *bf;
 	struct tlv *tlv;
-	int tx_ant = hweight8(phy->chainmask) - 1;
 	const u8 matrix[4][4] = {
 		{0, 0, 0, 0},
 		{1, 1, 0, 0},	/* 2x1, 2x2, 2x3, 2x4 */
@@ -1928,9 +1928,9 @@ static void
 mt7915_mcu_sta_bfee_tlv(struct sk_buff *skb, struct ieee80211_sta *sta,
 			struct mt7915_phy *phy)
 {
+	int tx_ant = hweight8(phy->mt76->chainmask) - 1;
 	struct sta_rec_bfee *bfee;
 	struct tlv *tlv;
-	int tx_ant = hweight8(phy->chainmask) - 1;
 	u8 nr = 0;
 
 	tlv = mt7915_mcu_add_tlv(skb, STA_REC_BFEE, sizeof(*bfee));
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h b/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
index 86b2a8866e72..7419eb7092f4 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
@@ -126,7 +126,6 @@ struct mt7915_phy {
 	u64 omac_mask;
 
 	u16 noise;
-	u16 chainmask;
 
 	s16 coverage_class;
 	u8 slottime;
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
