wireless: align to draft 11ax D3.0

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Shaul Triebitz <shaul.triebitz@intel.com>
commit add7453ad62f05c8f1a48675bb4dfed52e6ac878
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/add7453a.failed

Align to new 11ax draft D3.0.  Change/add new MAC and PHY capabilities
and update drivers' 11ax capabilities and mac80211's debugfs
accordingly.

	Signed-off-by: Shaul Triebitz <shaul.triebitz@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit add7453ad62f05c8f1a48675bb4dfed52e6ac878)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
#	drivers/net/wireless/mac80211_hwsim.c
#	include/linux/ieee80211.h
#	net/mac80211/debugfs_sta.c
diff --cc drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
index 720193d16539,27db4a3ba1f8..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
@@@ -531,171 -468,103 +531,250 @@@ static void iwl_init_vht_hw_capab(struc
  	}
  
  	vht_cap->vht_mcs.tx_mcs_map = vht_cap->vht_mcs.rx_mcs_map;
 +
 +	vht_cap->vht_mcs.tx_highest |=
 +		cpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE);
  }
  
++<<<<<<< HEAD
 +static const struct ieee80211_sband_iftype_data iwl_he_capa[] = {
 +	{
 +		.types_mask = BIT(NL80211_IFTYPE_STATION),
 +		.he_cap = {
 +			.has_he = true,
 +			.he_cap_elem = {
 +				.mac_cap_info[0] =
 +					IEEE80211_HE_MAC_CAP0_HTC_HE |
 +					IEEE80211_HE_MAC_CAP0_TWT_REQ,
 +				.mac_cap_info[1] =
 +					IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
 +					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
 +				.mac_cap_info[2] =
 +					IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP,
 +				.mac_cap_info[3] =
 +					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
 +					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
 +				.mac_cap_info[4] =
 +					IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU |
 +					IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
 +				.mac_cap_info[5] =
 +					IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B40 |
 +					IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B41 |
 +					IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU |
 +					IEEE80211_HE_MAC_CAP5_HE_DYNAMIC_SM_PS |
 +					IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX,
 +				.phy_cap_info[0] =
 +					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G |
 +					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
 +					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G,
 +				.phy_cap_info[1] =
 +					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
 +					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
 +					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD,
 +				.phy_cap_info[2] =
 +					IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US,
 +				.phy_cap_info[3] =
 +					IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_NO_DCM |
 +					IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |
 +					IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_NO_DCM |
 +					IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,
 +				.phy_cap_info[4] =
 +					IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |
 +					IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_8 |
 +					IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_8,
 +				.phy_cap_info[5] =
 +					IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_2 |
 +					IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_2,
 +				.phy_cap_info[6] =
 +					IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT,
 +				.phy_cap_info[7] =
 +					IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_AR |
 +					IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI |
 +					IEEE80211_HE_PHY_CAP7_MAX_NC_1,
 +				.phy_cap_info[8] =
 +					IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |
 +					IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |
 +					IEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU |
 +					IEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU |
 +					IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_2x996,
 +				.phy_cap_info[9] =
 +					IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |
 +					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
 +					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB |
 +					IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_RESERVED,
 +			},
 +			/*
 +			 * Set default Tx/Rx HE MCS NSS Support field.
 +			 * Indicate support for up to 2 spatial streams and all
 +			 * MCS, without any special cases
 +			 */
 +			.he_mcs_nss_supp = {
 +				.rx_mcs_80 = cpu_to_le16(0xfffa),
 +				.tx_mcs_80 = cpu_to_le16(0xfffa),
 +				.rx_mcs_160 = cpu_to_le16(0xfffa),
 +				.tx_mcs_160 = cpu_to_le16(0xfffa),
 +				.rx_mcs_80p80 = cpu_to_le16(0xffff),
 +				.tx_mcs_80p80 = cpu_to_le16(0xffff),
 +			},
 +			/*
 +			 * Set default PPE thresholds, with PPET16 set to 0,
 +			 * PPET8 set to 7
 +			 */
 +			.ppe_thres = {0x61, 0x1c, 0xc7, 0x71},
++=======
+ static struct ieee80211_sband_iftype_data iwl_he_capa = {
+ 	.types_mask = BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP),
+ 	.he_cap = {
+ 		.has_he = true,
+ 		.he_cap_elem = {
+ 			.mac_cap_info[0] =
+ 				IEEE80211_HE_MAC_CAP0_HTC_HE |
+ 				IEEE80211_HE_MAC_CAP0_TWT_REQ,
+ 			.mac_cap_info[1] =
+ 				IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 				IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 			.mac_cap_info[2] =
+ 				IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP |
+ 				IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 				IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 			.mac_cap_info[3] =
+ 				IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 				IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 			.mac_cap_info[4] =
+ 				IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU |
+ 				IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
+ 			.mac_cap_info[5] =
+ 				IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B40 |
+ 				IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B41 |
+ 				IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU,
+ 			.phy_cap_info[0] =
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G |
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G,
+ 			.phy_cap_info[1] =
+ 				IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 				IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 				IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 				IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 			.phy_cap_info[2] =
+ 				IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 				IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 			.phy_cap_info[3] =
+ 				IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_BPSK |
+ 				IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |
+ 				IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_BPSK |
+ 				IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,
+ 			.phy_cap_info[4] =
+ 				IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |
+ 				IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_8 |
+ 				IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_8,
+ 			.phy_cap_info[5] =
+ 				IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_2 |
+ 				IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_2 |
+ 				IEEE80211_HE_PHY_CAP5_NG16_SU_FEEDBACK |
+ 				IEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK,
+ 			.phy_cap_info[6] =
+ 				IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU |
+ 				IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU |
+ 				IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMER_FB |
+ 				IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMER_FB |
+ 				IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |
+ 				IEEE80211_HE_PHY_CAP6_PARTIAL_BANDWIDTH_DL_MUMIMO |
+ 				IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT,
+ 			.phy_cap_info[7] =
+ 				IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_AR |
+ 				IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI |
+ 				IEEE80211_HE_PHY_CAP7_MAX_NC_1,
+ 			.phy_cap_info[8] =
+ 				IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |
+ 				IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |
+ 				IEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU |
+ 				IEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU |
+ 				IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_160_OR_80P80_MHZ,
+ 			.phy_cap_info[9] =
+ 				IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |
+ 				IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
+ 				IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB,
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  		},
 -		/*
 -		 * Set default Tx/Rx HE MCS NSS Support field. Indicate support
 -		 * for up to 2 spatial streams and all MCS, without any special
 -		 * cases
 -		 */
 -		.he_mcs_nss_supp = {
 -			.rx_mcs_80 = cpu_to_le16(0xfffa),
 -			.tx_mcs_80 = cpu_to_le16(0xfffa),
 -			.rx_mcs_160 = cpu_to_le16(0xfffa),
 -			.tx_mcs_160 = cpu_to_le16(0xfffa),
 -			.rx_mcs_80p80 = cpu_to_le16(0xffff),
 -			.tx_mcs_80p80 = cpu_to_le16(0xffff),
 +	},
 +	{
 +		.types_mask = BIT(NL80211_IFTYPE_AP),
 +		.he_cap = {
 +			.has_he = true,
 +			.he_cap_elem = {
 +				.mac_cap_info[0] =
 +					IEEE80211_HE_MAC_CAP0_HTC_HE,
 +				.mac_cap_info[1] =
 +					IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
 +					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
 +				.mac_cap_info[2] =
 +					IEEE80211_HE_MAC_CAP2_BSR,
 +				.mac_cap_info[3] =
 +					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
 +					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
 +				.mac_cap_info[4] =
 +					IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
 +				.mac_cap_info[5] =
 +					IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU,
 +				.phy_cap_info[0] =
 +					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G |
 +					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
 +					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G,
 +				.phy_cap_info[1] =
 +					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD,
 +				.phy_cap_info[2] =
 +					IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US,
 +				.phy_cap_info[3] =
 +					IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_NO_DCM |
 +					IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |
 +					IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_NO_DCM |
 +					IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,
 +				.phy_cap_info[4] =
 +					IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |
 +					IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_8 |
 +					IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_8,
 +				.phy_cap_info[5] =
 +					IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_2 |
 +					IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_2,
 +				.phy_cap_info[6] =
 +					IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT,
 +				.phy_cap_info[7] =
 +					IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI |
 +					IEEE80211_HE_PHY_CAP7_MAX_NC_1,
 +				.phy_cap_info[8] =
 +					IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |
 +					IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |
 +					IEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU |
 +					IEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU |
 +					IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_2x996,
 +				.phy_cap_info[9] =
 +					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
 +					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB |
 +					IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_RESERVED,
 +			},
 +			/*
 +			 * Set default Tx/Rx HE MCS NSS Support field.
 +			 * Indicate support for up to 2 spatial streams and all
 +			 * MCS, without any special cases
 +			 */
 +			.he_mcs_nss_supp = {
 +				.rx_mcs_80 = cpu_to_le16(0xfffa),
 +				.tx_mcs_80 = cpu_to_le16(0xfffa),
 +				.rx_mcs_160 = cpu_to_le16(0xfffa),
 +				.tx_mcs_160 = cpu_to_le16(0xfffa),
 +				.rx_mcs_80p80 = cpu_to_le16(0xffff),
 +				.tx_mcs_80p80 = cpu_to_le16(0xffff),
 +			},
 +			/*
 +			 * Set default PPE thresholds, with PPET16 set to 0,
 +			 * PPET8 set to 7
 +			 */
 +			.ppe_thres = {0x61, 0x1c, 0xc7, 0x71},
  		},
 -		/*
 -		 * Set default PPE thresholds, with PPET16 set to 0, PPET8 set
 -		 * to 7
 -		 */
 -		.ppe_thres = {0x61, 0x1c, 0xc7, 0x71},
  	},
  };
  
@@@ -779,27 -581,20 +858,36 @@@ static void iwl_init_he_hw_capab(struc
  
  	/* If not 2x2, we need to indicate 1x1 in the Midamble RX Max NSTS */
  	if ((tx_chains & rx_chains) != ANT_AB) {
++<<<<<<< HEAD
 +		int i;
 +
 +		for (i = 0; i < sband->n_iftype_data; i++) {
 +			iftype_data[i].he_cap.he_cap_elem.phy_cap_info[1] &=
 +				~IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS;
 +			iftype_data[i].he_cap.he_cap_elem.phy_cap_info[2] &=
 +				~IEEE80211_HE_PHY_CAP2_MIDAMBLE_RX_TX_MAX_NSTS;
 +			iftype_data[i].he_cap.he_cap_elem.phy_cap_info[7] &=
 +				~IEEE80211_HE_PHY_CAP7_MAX_NC_MASK;
 +		}
++=======
+ 		iwl_he_capa.he_cap.he_cap_elem.phy_cap_info[1] &=
+ 			~IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS;
+ 		iwl_he_capa.he_cap.he_cap_elem.phy_cap_info[2] &=
+ 			~IEEE80211_HE_PHY_CAP2_MIDAMBLE_RX_TX_MAX_NSTS;
+ 		iwl_he_capa.he_cap.he_cap_elem.phy_cap_info[7] &=
+ 			~IEEE80211_HE_PHY_CAP7_MAX_NC_MASK;
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  	}
 +	iwl_init_he_6ghz_capa(trans, data, sband, tx_chains, rx_chains);
  }
  
 -static void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,
 +static void iwl_init_sbands(struct iwl_trans *trans,
  			    struct iwl_nvm_data *data,
 -			    const __le16 *nvm_ch_flags, u8 tx_chains,
 -			    u8 rx_chains, u32 sbands_flags)
 +			    const void *nvm_ch_flags, u8 tx_chains,
 +			    u8 rx_chains, u32 sbands_flags, bool v4)
  {
 +	struct device *dev = trans->dev;
 +	const struct iwl_cfg *cfg = trans->cfg;
  	int n_channels;
  	int n_used = 0;
  	struct ieee80211_supported_band *sband;
diff --cc drivers/net/wireless/mac80211_hwsim.c
index 56f509eae73a,f3863101af78..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -3,6 -2,12 +3,15 @@@
   * mac80211_hwsim - software simulator of 802.11 radio(s) for mac80211
   * Copyright (c) 2008, Jouni Malinen <j@w1.fi>
   * Copyright (c) 2011, Javier Lopez <jlopex@gmail.com>
++<<<<<<< HEAD
++=======
+  * Copyright (c) 2016 - 2017 Intel Deutschland GmbH
+  * Copyright (C) 2018 Intel Corporation
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
   */
  
  /*
@@@ -2513,6 -2520,118 +2522,121 @@@ out_err
  	nlmsg_free(mcast_skb);
  }
  
++<<<<<<< HEAD
++=======
+ static const struct ieee80211_sband_iftype_data he_capa_2ghz = {
+ 	/* TODO: should we support other types, e.g., P2P?*/
+ 	.types_mask = BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP),
+ 	.he_cap = {
+ 		.has_he = true,
+ 		.he_cap_elem = {
+ 			.mac_cap_info[0] =
+ 				IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 			.mac_cap_info[1] =
+ 				IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 				IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 			.mac_cap_info[2] =
+ 				IEEE80211_HE_MAC_CAP2_BSR |
+ 				IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 				IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 			.mac_cap_info[3] =
+ 				IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 				IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 			.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 			.phy_cap_info[1] =
+ 				IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 				IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 				IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 				IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 			.phy_cap_info[2] =
+ 				IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 				IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 			/* Leave all the other PHY capability bytes unset, as
+ 			 * DCM, beam forming, RU and PPE threshold information
+ 			 * are not supported
+ 			 */
+ 		},
+ 		.he_mcs_nss_supp = {
+ 			.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_160 = cpu_to_le16(0xffff),
+ 			.tx_mcs_160 = cpu_to_le16(0xffff),
+ 			.rx_mcs_80p80 = cpu_to_le16(0xffff),
+ 			.tx_mcs_80p80 = cpu_to_le16(0xffff),
+ 		},
+ 	},
+ };
+ 
+ static const struct ieee80211_sband_iftype_data he_capa_5ghz = {
+ 	/* TODO: should we support other types, e.g., P2P?*/
+ 	.types_mask = BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP),
+ 	.he_cap = {
+ 		.has_he = true,
+ 		.he_cap_elem = {
+ 			.mac_cap_info[0] =
+ 				IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 			.mac_cap_info[1] =
+ 				IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 				IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 			.mac_cap_info[2] =
+ 				IEEE80211_HE_MAC_CAP2_BSR |
+ 				IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 				IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 			.mac_cap_info[3] =
+ 				IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 				IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 			.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 			.phy_cap_info[0] =
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,
+ 			.phy_cap_info[1] =
+ 				IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 				IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 				IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 				IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 			.phy_cap_info[2] =
+ 				IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 				IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 			/* Leave all the other PHY capability bytes unset, as
+ 			 * DCM, beam forming, RU and PPE threshold information
+ 			 * are not supported
+ 			 */
+ 		},
+ 		.he_mcs_nss_supp = {
+ 			.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_160 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_160 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 		},
+ 	},
+ };
+ 
+ static void mac80211_hswim_he_capab(struct ieee80211_supported_band *sband)
+ {
+ 	if (sband->band == NL80211_BAND_2GHZ)
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)&he_capa_2ghz;
+ 	else if (sband->band == NL80211_BAND_5GHZ)
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)&he_capa_5ghz;
+ 	else
+ 		return;
+ 
+ 	sband->n_iftype_data = 1;
+ }
+ 
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  static int mac80211_hwsim_new_radio(struct genl_info *info,
  				    struct hwsim_new_radio_params *param)
  {
diff --cc include/linux/ieee80211.h
index 38a2eebb798e,c4809ad8ab46..000000000000
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@@ -1716,7 -1555,7 +1716,11 @@@ struct ieee80211_vht_operation 
   * struct ieee80211_he_cap_elem - HE capabilities element
   *
   * This structure is the "HE capabilities element" fixed fields as
++<<<<<<< HEAD
 + * described in P802.11ax_D4.0 section 9.4.2.242.2 and 9.4.2.242.3
++=======
+  * described in P802.11ax_D3.0 section 9.4.2.237.2 and 9.4.2.237.3
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
   */
  struct ieee80211_he_cap_elem {
  	u8 mac_cap_info[6];
@@@ -1980,12 -1800,6 +1984,15 @@@ int ieee80211_get_vht_max_nss(struct ie
  #define IEEE80211_HE_MAC_CAP5_SUBCHAN_SELECVITE_TRANSMISSION	0x04
  #define IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU			0x08
  #define IEEE80211_HE_MAC_CAP5_OM_CTRL_UL_MU_DATA_DIS_RX		0x10
++<<<<<<< HEAD
 +#define IEEE80211_HE_MAC_CAP5_HE_DYNAMIC_SM_PS			0x20
 +#define IEEE80211_HE_MAC_CAP5_PUNCTURED_SOUNDING		0x40
 +#define IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX		0x80
 +
 +#define IEEE80211_HE_VHT_MAX_AMPDU_FACTOR	20
 +#define IEEE80211_HE_HT_MAX_AMPDU_FACTOR	16
++=======
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  
  /* 802.11ax HE PHY capabilities */
  #define IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G		0x02
@@@ -2109,11 -1923,11 +2116,19 @@@
  #define IEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU			0x08
  #define IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI		0x10
  #define IEEE80211_HE_PHY_CAP8_MIDAMBLE_RX_TX_2X_AND_1XLTF		0x20
++<<<<<<< HEAD
 +#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_242				0x00
 +#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_484				0x40
 +#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_996				0x80
 +#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_2x996				0xc0
 +#define IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_MASK				0xc0
++=======
+ #define IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_20MHZ				0x00
+ #define IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_40MHZ				0x40
+ #define IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_80MHZ				0x80
+ #define IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_160_OR_80P80_MHZ		0xc0
+ #define IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_MASK				0xc0
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  
  #define IEEE80211_HE_PHY_CAP9_LONGER_THAN_16_SIGB_OFDM_SYM		0x01
  #define IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK		0x02
@@@ -2121,11 -1935,6 +2136,14 @@@
  #define IEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU		0x08
  #define IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB	0x10
  #define IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB	0x20
++<<<<<<< HEAD
 +#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_0US			0x00
 +#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_8US			0x40
 +#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_16US			0x80
 +#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_RESERVED		0xc0
 +#define IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_MASK			0xc0
++=======
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  
  /* 802.11ax HE TX/RX MCS NSS Support  */
  #define IEEE80211_TX_RX_MCS_NSS_SUPP_HIGHEST_MCS_POS			(3)
diff --cc net/mac80211/debugfs_sta.c
index 829dcad69c2c,af5185a836e5..000000000000
--- a/net/mac80211/debugfs_sta.c
+++ b/net/mac80211/debugfs_sta.c
@@@ -742,9 -627,6 +742,12 @@@ static ssize_t sta_he_capa_read(struct 
  	      "SUBCHAN-SELECVITE-TRANSMISSION");
  	PFLAG(MAC, 5, UL_2x996_TONE_RU, "UL-2x996-TONE-RU");
  	PFLAG(MAC, 5, OM_CTRL_UL_MU_DATA_DIS_RX, "OM-CTRL-UL-MU-DATA-DIS-RX");
++<<<<<<< HEAD
 +	PFLAG(MAC, 5, HE_DYNAMIC_SM_PS, "HE-DYNAMIC-SM-PS");
 +	PFLAG(MAC, 5, PUNCTURED_SOUNDING, "PUNCTURED-SOUNDING");
 +	PFLAG(MAC, 5, HT_VHT_TRIG_FRAME_RX, "HT-VHT-TRIG-FRAME-RX");
++=======
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  
  	cap = hec->he_cap_elem.phy_cap_info;
  	p += scnprintf(p, buf_sz + buf - p,
@@@ -879,18 -761,18 +882,33 @@@
  	PFLAG(PHY, 8, MIDAMBLE_RX_TX_2X_AND_1XLTF,
  	      "MIDAMBLE-RX-TX-2X-AND-1XLTF");
  
++<<<<<<< HEAD
 +	switch (cap[8] & IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_MASK) {
 +	case IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_242:
 +		PRINT("DCM-MAX-RU-242");
 +		break;
 +	case IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_484:
 +		PRINT("DCM-MAX-RU-484");
 +		break;
 +	case IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_996:
 +		PRINT("DCM-MAX-RU-996");
 +		break;
 +	case IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_2x996:
 +		PRINT("DCM-MAX-RU-2x996");
++=======
+ 	switch (cap[8] & IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_MASK) {
+ 	case IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_20MHZ:
+ 		PRINT("DDCM-MAX-BW-20MHZ");
+ 		break;
+ 	case IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_40MHZ:
+ 		PRINT("DCM-MAX-BW-40MHZ");
+ 		break;
+ 	case IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_80MHZ:
+ 		PRINT("DCM-MAX-BW-80MHZ");
+ 		break;
+ 	case IEEE80211_HE_PHY_CAP8_DCM_MAX_BW_160_OR_80P80_MHZ:
+ 		PRINT("DCM-MAX-BW-160-OR-80P80-MHZ");
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  		break;
  	}
  
@@@ -906,18 -788,6 +924,21 @@@
  	      "RX-FULL-BW-SU-USING-MU-WITH-COMP-SIGB");
  	PFLAG(PHY, 9, RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB,
  	      "RX-FULL-BW-SU-USING-MU-WITH-NON-COMP-SIGB");
++<<<<<<< HEAD
 +
 +	switch (cap[9] & IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_MASK) {
 +	case IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_0US:
 +		PRINT("NOMINAL-PACKET-PADDING-0US");
 +		break;
 +	case IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_8US:
 +		PRINT("NOMINAL-PACKET-PADDING-8US");
 +		break;
 +	case IEEE80211_HE_PHY_CAP9_NOMIMAL_PKT_PADDING_16US:
 +		PRINT("NOMINAL-PACKET-PADDING-16US");
 +		break;
 +	}
++=======
++>>>>>>> add7453ad62f (wireless: align to draft 11ax D3.0)
  
  #undef PFLAG_RANGE_DEFAULT
  #undef PFLAG_RANGE
* Unmerged path drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
* Unmerged path include/linux/ieee80211.h
* Unmerged path net/mac80211/debugfs_sta.c
