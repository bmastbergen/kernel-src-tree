mt76: move token_lock, token and token_count in mt76_dev

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit b17aff3368916136ba2a87669bb3c319e5c6d0b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/b17aff33.failed

Move token_lock, token and token_count data structures in mt76_dev.
This is a preliminary patch to move token management in mt76 common
module since it is shared by mt7615, mt7915 and mt7921 drivers.

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit b17aff3368916136ba2a87669bb3c319e5c6d0b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
#	drivers/net/wireless/mediatek/mt76/mt7915/init.c
#	drivers/net/wireless/mediatek/mt76/mt7915/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
index 4cf7c5d34325,d5aff409132d..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
@@@ -181,3 -181,178 +181,181 @@@ int mt7615_tx_prepare_skb(struct mt76_d
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ void mt7615_dma_reset(struct mt7615_dev *dev)
+ {
+ 	int i;
+ 
+ 	mt76_clear(dev, MT_WPDMA_GLO_CFG,
+ 		   MT_WPDMA_GLO_CFG_RX_DMA_EN | MT_WPDMA_GLO_CFG_TX_DMA_EN |
+ 		   MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);
+ 
+ 	usleep_range(1000, 2000);
+ 
+ 	for (i = 0; i < __MT_TXQ_MAX; i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);
+ 
+ 	for (i = 0; i < __MT_MCUQ_MAX; i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i)
+ 		mt76_queue_rx_reset(dev, i);
+ 
+ 	mt76_tx_status_check(&dev->mt76, NULL, true);
+ 
+ 	mt7615_dma_start(dev);
+ }
+ EXPORT_SYMBOL_GPL(mt7615_dma_reset);
+ 
+ static void
+ mt7615_hif_int_event_trigger(struct mt7615_dev *dev, u8 event)
+ {
+ 	u32 reg = MT_MCU_INT_EVENT;
+ 
+ 	if (is_mt7663(&dev->mt76))
+ 		reg = MT7663_MCU_INT_EVENT;
+ 
+ 	mt76_wr(dev, reg, event);
+ 
+ 	mt7622_trigger_hif_int(dev, true);
+ 	mt7622_trigger_hif_int(dev, false);
+ }
+ 
+ static bool
+ mt7615_wait_reset_state(struct mt7615_dev *dev, u32 state)
+ {
+ 	bool ret;
+ 
+ 	ret = wait_event_timeout(dev->reset_wait,
+ 				 (READ_ONCE(dev->reset_state) & state),
+ 				 MT7615_RESET_TIMEOUT);
+ 	WARN(!ret, "Timeout waiting for MCU reset state %x\n", state);
+ 	return ret;
+ }
+ 
+ static void
+ mt7615_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)
+ {
+ 	struct ieee80211_hw *hw = priv;
+ 	struct mt7615_dev *dev = mt7615_hw_dev(hw);
+ 
+ 	switch (vif->type) {
+ 	case NL80211_IFTYPE_MESH_POINT:
+ 	case NL80211_IFTYPE_ADHOC:
+ 	case NL80211_IFTYPE_AP:
+ 		mt7615_mcu_add_beacon(dev, hw, vif,
+ 				      vif->bss_conf.enable_beacon);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void
+ mt7615_update_beacons(struct mt7615_dev *dev)
+ {
+ 	ieee80211_iterate_active_interfaces(dev->mt76.hw,
+ 		IEEE80211_IFACE_ITER_RESUME_ALL,
+ 		mt7615_update_vif_beacon, dev->mt76.hw);
+ 
+ 	if (!dev->mt76.phy2)
+ 		return;
+ 
+ 	ieee80211_iterate_active_interfaces(dev->mt76.phy2->hw,
+ 		IEEE80211_IFACE_ITER_RESUME_ALL,
+ 		mt7615_update_vif_beacon, dev->mt76.phy2->hw);
+ }
+ 
+ void mt7615_mac_reset_work(struct work_struct *work)
+ {
+ 	struct mt7615_phy *phy2;
+ 	struct mt76_phy *ext_phy;
+ 	struct mt7615_dev *dev;
+ 
+ 	dev = container_of(work, struct mt7615_dev, reset_work);
+ 	ext_phy = dev->mt76.phy2;
+ 	phy2 = ext_phy ? ext_phy->priv : NULL;
+ 
+ 	if (!(READ_ONCE(dev->reset_state) & MT_MCU_CMD_STOP_PDMA))
+ 		return;
+ 
+ 	ieee80211_stop_queues(mt76_hw(dev));
+ 	if (ext_phy)
+ 		ieee80211_stop_queues(ext_phy->hw);
+ 
+ 	set_bit(MT76_RESET, &dev->mphy.state);
+ 	set_bit(MT76_MCU_RESET, &dev->mphy.state);
+ 	wake_up(&dev->mt76.mcu.wait);
+ 	cancel_delayed_work_sync(&dev->mphy.mac_work);
+ 	del_timer_sync(&dev->phy.roc_timer);
+ 	cancel_work_sync(&dev->phy.roc_work);
+ 	if (phy2) {
+ 		set_bit(MT76_RESET, &phy2->mt76->state);
+ 		cancel_delayed_work_sync(&phy2->mt76->mac_work);
+ 		del_timer_sync(&phy2->roc_timer);
+ 		cancel_work_sync(&phy2->roc_work);
+ 	}
+ 
+ 	/* lock/unlock all queues to ensure that no tx is pending */
+ 	mt76_txq_schedule_all(&dev->mphy);
+ 	if (ext_phy)
+ 		mt76_txq_schedule_all(ext_phy);
+ 
+ 	mt76_worker_disable(&dev->mt76.tx_worker);
+ 	napi_disable(&dev->mt76.napi[0]);
+ 	napi_disable(&dev->mt76.napi[1]);
+ 	napi_disable(&dev->mt76.tx_napi);
+ 
+ 	mt7615_mutex_acquire(dev);
+ 
+ 	mt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_PDMA_STOPPED);
+ 
+ 	if (mt7615_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
+ 		mt7615_dma_reset(dev);
+ 
+ 		mt7615_tx_token_put(dev);
+ 		idr_init(&dev->mt76.token);
+ 
+ 		mt76_wr(dev, MT_WPDMA_MEM_RNG_ERR, 0);
+ 
+ 		mt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_PDMA_INIT);
+ 		mt7615_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
+ 	}
+ 
+ 	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
+ 	clear_bit(MT76_RESET, &dev->mphy.state);
+ 	if (phy2)
+ 		clear_bit(MT76_RESET, &phy2->mt76->state);
+ 
+ 	mt76_worker_enable(&dev->mt76.tx_worker);
+ 	napi_enable(&dev->mt76.tx_napi);
+ 	napi_schedule(&dev->mt76.tx_napi);
+ 
+ 	napi_enable(&dev->mt76.napi[0]);
+ 	napi_schedule(&dev->mt76.napi[0]);
+ 
+ 	napi_enable(&dev->mt76.napi[1]);
+ 	napi_schedule(&dev->mt76.napi[1]);
+ 
+ 	ieee80211_wake_queues(mt76_hw(dev));
+ 	if (ext_phy)
+ 		ieee80211_wake_queues(ext_phy->hw);
+ 
+ 	mt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_RESET_DONE);
+ 	mt7615_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);
+ 
+ 	mt7615_update_beacons(dev);
+ 
+ 	mt7615_mutex_release(dev);
+ 
+ 	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
+ 				     MT7615_WATCHDOG_TIME);
+ 	if (phy2)
+ 		ieee80211_queue_delayed_work(ext_phy->hw,
+ 					     &phy2->mt76->mac_work,
+ 					     MT7615_WATCHDOG_TIME);
+ 
+ }
++>>>>>>> b17aff336891 (mt76: move token_lock, token and token_count in mt76_dev)
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/init.c
index 49c09d0d8906,b97834fae0ba..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
@@@ -267,6 -153,258 +267,260 @@@ mt7915_init_wiphy(struct ieee80211_hw *
  	ieee80211_hw_set(hw, WANT_MONITOR_VIF);
  
  	hw->max_tx_fragments = 4;
++<<<<<<< HEAD
++=======
+ 
+ 	if (phy->mt76->cap.has_2ghz)
+ 		phy->mt76->sband_2g.sband.ht_cap.cap |=
+ 			IEEE80211_HT_CAP_LDPC_CODING |
+ 			IEEE80211_HT_CAP_MAX_AMSDU;
+ 
+ 	if (phy->mt76->cap.has_5ghz) {
+ 		phy->mt76->sband_5g.sband.ht_cap.cap |=
+ 			IEEE80211_HT_CAP_LDPC_CODING |
+ 			IEEE80211_HT_CAP_MAX_AMSDU;
+ 		phy->mt76->sband_5g.sband.vht_cap.cap |=
+ 			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 |
+ 			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;
+ 	}
+ 
+ 	mt76_set_stream_caps(phy->mt76, true);
+ 	mt7915_set_stream_vht_txbf_caps(phy);
+ 	mt7915_set_stream_he_caps(phy);
+ }
+ 
+ static void
+ mt7915_mac_init_band(struct mt7915_dev *dev, u8 band)
+ {
+ 	u32 mask, set;
+ 
+ 	mt76_rmw_field(dev, MT_TMAC_CTCR0(band),
+ 		       MT_TMAC_CTCR0_INS_DDLMT_REFTIME, 0x3f);
+ 	mt76_set(dev, MT_TMAC_CTCR0(band),
+ 		 MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN |
+ 		 MT_TMAC_CTCR0_INS_DDLMT_EN);
+ 
+ 	mask = MT_MDP_RCFR0_MCU_RX_MGMT |
+ 	       MT_MDP_RCFR0_MCU_RX_CTL_NON_BAR |
+ 	       MT_MDP_RCFR0_MCU_RX_CTL_BAR;
+ 	set = FIELD_PREP(MT_MDP_RCFR0_MCU_RX_MGMT, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR0_MCU_RX_CTL_NON_BAR, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR0_MCU_RX_CTL_BAR, MT_MDP_TO_HIF);
+ 	mt76_rmw(dev, MT_MDP_BNRCFR0(band), mask, set);
+ 
+ 	mask = MT_MDP_RCFR1_MCU_RX_BYPASS |
+ 	       MT_MDP_RCFR1_RX_DROPPED_UCAST |
+ 	       MT_MDP_RCFR1_RX_DROPPED_MCAST;
+ 	set = FIELD_PREP(MT_MDP_RCFR1_MCU_RX_BYPASS, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR1_RX_DROPPED_UCAST, MT_MDP_TO_HIF) |
+ 	      FIELD_PREP(MT_MDP_RCFR1_RX_DROPPED_MCAST, MT_MDP_TO_HIF);
+ 	mt76_rmw(dev, MT_MDP_BNRCFR1(band), mask, set);
+ 
+ 	mt76_set(dev, MT_WF_RMAC_MIB_TIME0(band), MT_WF_RMAC_MIB_RXTIME_EN);
+ 	mt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0(band), MT_WF_RMAC_MIB_RXTIME_EN);
+ 
+ 	mt76_rmw_field(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_MAX_RX_LEN, 1536);
+ 	/* disable rx rate report by default due to hw issues */
+ 	mt76_clear(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_RXD_G5_EN);
+ }
+ 
+ static void mt7915_mac_init(struct mt7915_dev *dev)
+ {
+ 	int i;
+ 
+ 	mt76_rmw_field(dev, MT_MDP_DCR1, MT_MDP_DCR1_MAX_RX_LEN, 1536);
+ 	/* enable hardware de-agg */
+ 	mt76_set(dev, MT_MDP_DCR0, MT_MDP_DCR0_DAMSDU_EN);
+ 
+ 	for (i = 0; i < MT7915_WTBL_SIZE; i++)
+ 		mt7915_mac_wtbl_update(dev, i,
+ 				       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
+ 	for (i = 0; i < 2; i++)
+ 		mt7915_mac_init_band(dev, i);
+ }
+ 
+ static int mt7915_txbf_init(struct mt7915_dev *dev)
+ {
+ 	int ret;
+ 
+ 
+ 	if (dev->dbdc_support) {
+ 		ret = mt7915_mcu_set_txbf_module(dev);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	/* trigger sounding packets */
+ 	ret = mt7915_mcu_set_txbf_sounding(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* enable eBF */
+ 	return mt7915_mcu_set_txbf_type(dev);
+ }
+ 
+ static int mt7915_register_ext_phy(struct mt7915_dev *dev)
+ {
+ 	struct mt7915_phy *phy = mt7915_ext_phy(dev);
+ 	struct mt76_phy *mphy;
+ 	int ret;
+ 
+ 	if (!dev->dbdc_support)
+ 		return 0;
+ 
+ 	if (phy)
+ 		return 0;
+ 
+ 	mphy = mt76_alloc_phy(&dev->mt76, sizeof(*phy), &mt7915_ops);
+ 	if (!mphy)
+ 		return -ENOMEM;
+ 
+ 	phy = mphy->priv;
+ 	phy->dev = dev;
+ 	phy->mt76 = mphy;
+ 	mphy->chainmask = dev->chainmask & ~dev->mphy.chainmask;
+ 	mphy->antenna_mask = BIT(hweight8(mphy->chainmask)) - 1;
+ 
+ 	INIT_LIST_HEAD(&phy->stats_list);
+ 	INIT_DELAYED_WORK(&mphy->mac_work, mt7915_mac_work);
+ 
+ 	mt7915_eeprom_parse_band_config(phy);
+ 	mt7915_init_wiphy(mphy->hw);
+ 
+ 	memcpy(mphy->macaddr, dev->mt76.eeprom.data + MT_EE_MAC_ADDR2,
+ 	       ETH_ALEN);
+ 	mt76_eeprom_override(mphy);
+ 
+ 	ret = mt7915_init_tx_queues(phy, MT7915_TXQ_BAND1,
+ 				    MT7915_TX_RING_SIZE);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = mt76_register_phy(mphy, true, mt7915_rates,
+ 				ARRAY_SIZE(mt7915_rates));
+ 	if (ret)
+ 		goto error;
+ 
+ 	return 0;
+ 
+ error:
+ 	ieee80211_free_hw(mphy->hw);
+ 	return ret;
+ }
+ 
+ static void mt7915_init_work(struct work_struct *work)
+ {
+ 	struct mt7915_dev *dev = container_of(work, struct mt7915_dev,
+ 				 init_work);
+ 
+ 	mt7915_mcu_set_eeprom(dev);
+ 	mt7915_mac_init(dev);
+ 	mt7915_init_txpower(dev, &dev->mphy.sband_2g.sband);
+ 	mt7915_init_txpower(dev, &dev->mphy.sband_5g.sband);
+ 	mt7915_txbf_init(dev);
+ }
+ 
+ static void mt7915_wfsys_reset(struct mt7915_dev *dev)
+ {
+ 	u32 val = MT_TOP_PWR_KEY | MT_TOP_PWR_SW_PWR_ON | MT_TOP_PWR_PWR_ON;
+ 
+ #define MT_MCU_DUMMY_RANDOM	GENMASK(15, 0)
+ #define MT_MCU_DUMMY_DEFAULT	GENMASK(31, 16)
+ 
+ 	mt76_wr(dev, MT_MCU_WFDMA0_DUMMY_CR, MT_MCU_DUMMY_RANDOM);
+ 
+ 	/* change to software control */
+ 	val |= MT_TOP_PWR_SW_RST;
+ 	mt76_wr(dev, MT_TOP_PWR_CTRL, val);
+ 
+ 	/* reset wfsys */
+ 	val &= ~MT_TOP_PWR_SW_RST;
+ 	mt76_wr(dev, MT_TOP_PWR_CTRL, val);
+ 
+ 	/* release wfsys then mcu re-excutes romcode */
+ 	val |= MT_TOP_PWR_SW_RST;
+ 	mt76_wr(dev, MT_TOP_PWR_CTRL, val);
+ 
+ 	/* switch to hw control */
+ 	val &= ~MT_TOP_PWR_SW_RST;
+ 	val |= MT_TOP_PWR_HW_CTRL;
+ 	mt76_wr(dev, MT_TOP_PWR_CTRL, val);
+ 
+ 	/* check whether mcu resets to default */
+ 	if (!mt76_poll_msec(dev, MT_MCU_WFDMA0_DUMMY_CR, MT_MCU_DUMMY_DEFAULT,
+ 			    MT_MCU_DUMMY_DEFAULT, 1000)) {
+ 		dev_err(dev->mt76.dev, "wifi subsystem reset failure\n");
+ 		return;
+ 	}
+ 
+ 	/* wfsys reset won't clear host registers */
+ 	mt76_clear(dev, MT_TOP_MISC, MT_TOP_MISC_FW_STATE);
+ 
+ 	msleep(100);
+ }
+ 
+ static int mt7915_init_hardware(struct mt7915_dev *dev)
+ {
+ 	int ret, idx;
+ 
+ 	mt76_wr(dev, MT_INT_SOURCE_CSR, ~0);
+ 
+ 	INIT_WORK(&dev->init_work, mt7915_init_work);
+ 	spin_lock_init(&dev->mt76.token_lock);
+ 	idr_init(&dev->mt76.token);
+ 
+ 	dev->dbdc_support = !!(mt76_rr(dev, MT_HW_BOUND) & BIT(5));
+ 
+ 	/* If MCU was already running, it is likely in a bad state */
+ 	if (mt76_get_field(dev, MT_TOP_MISC, MT_TOP_MISC_FW_STATE) >
+ 	    FW_STATE_FW_DOWNLOAD)
+ 		mt7915_wfsys_reset(dev);
+ 
+ 	ret = mt7915_dma_init(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	set_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);
+ 
+ 	/*
+ 	 * force firmware operation mode into normal state,
+ 	 * which should be set before firmware download stage.
+ 	 */
+ 	mt76_wr(dev, MT_SWDEF_MODE, MT_SWDEF_NORMAL_MODE);
+ 
+ 	ret = mt7915_mcu_init(dev);
+ 	if (ret) {
+ 		/* Reset and try again */
+ 		mt7915_wfsys_reset(dev);
+ 
+ 		ret = mt7915_mcu_init(dev);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	ret = mt7915_eeprom_init(dev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 
+ 	if (dev->flash_mode) {
+ 		ret = mt7915_mcu_apply_group_cal(dev);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	/* Beacon and mgmt frames should occupy wcid 0 */
+ 	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7915_WTBL_STA - 1);
+ 	if (idx)
+ 		return -ENOSPC;
+ 
+ 	dev->mt76.global_wcid.idx = idx;
+ 	dev->mt76.global_wcid.hw_key_idx = -1;
+ 	dev->mt76.global_wcid.tx_info |= MT_WCID_TX_INFO_SET;
+ 	rcu_assign_pointer(dev->mt76.wcid[idx], &dev->mt76.global_wcid);
+ 
+ 	return 0;
++>>>>>>> b17aff336891 (mt76: move token_lock, token and token_count in mt76_dev)
  }
  
  void mt7915_set_stream_vht_txbf_caps(struct mt7915_phy *phy)
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/mac.c
index 44bdff82d4d2,a2d60be00f9f..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
@@@ -1485,6 -1573,35 +1485,38 @@@ mt7915_dma_reset(struct mt7915_dev *dev
  		 MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN);
  	mt76_set(dev, MT_WFDMA1_GLO_CFG,
  		 MT_WFDMA1_GLO_CFG_TX_DMA_EN | MT_WFDMA1_GLO_CFG_RX_DMA_EN);
++<<<<<<< HEAD
++=======
+ 	if (dev->hif2) {
+ 		mt76_set(dev, MT_WFDMA0_GLO_CFG + hif1_ofs,
+ 			(MT_WFDMA0_GLO_CFG_TX_DMA_EN |
+ 			 MT_WFDMA0_GLO_CFG_RX_DMA_EN));
+ 		mt76_set(dev, MT_WFDMA1_GLO_CFG + hif1_ofs,
+ 			(MT_WFDMA1_GLO_CFG_TX_DMA_EN |
+ 			 MT_WFDMA1_GLO_CFG_RX_DMA_EN));
+ 	}
+ }
+ 
+ void mt7915_tx_token_put(struct mt7915_dev *dev)
+ {
+ 	struct mt76_txwi_cache *txwi;
+ 	int id;
+ 
+ 	spin_lock_bh(&dev->mt76.token_lock);
+ 	idr_for_each_entry(&dev->mt76.token, txwi, id) {
+ 		mt7915_txp_skb_unmap(&dev->mt76, txwi);
+ 		if (txwi->skb) {
+ 			struct ieee80211_hw *hw;
+ 
+ 			hw = mt76_tx_status_get_hw(&dev->mt76, txwi->skb);
+ 			ieee80211_free_txskb(hw, txwi->skb);
+ 		}
+ 		mt76_put_txwi(&dev->mt76, txwi);
+ 		dev->mt76.token_count--;
+ 	}
+ 	spin_unlock_bh(&dev->mt76.token_lock);
+ 	idr_destroy(&dev->mt76.token);
++>>>>>>> b17aff336891 (mt76: move token_lock, token and token_count in mt76_dev)
  }
  
  /* system error recovery */
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
index 2ffe7fd42d87,582c2bfdf070..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
@@@ -168,27 -187,12 +168,34 @@@ struct mt7915_dev 
  
  	u32 hw_pattern;
  
++<<<<<<< HEAD
 +	spinlock_t token_lock;
 +	int token_count;
 +	struct idr token;
 +
 +	s8 **rate_power; /* TODO: use mt76_rate_power */
++=======
+ 	bool dbdc_support;
+ 	bool flash_mode;
+ 	bool fw_debug;
+ 	bool ibf;
++>>>>>>> b17aff336891 (mt76: move token_lock, token and token_count in mt76_dev)
 +
 +	bool fw_debug;
 +
 +#ifdef CONFIG_NL80211_TESTMODE
 +	struct {
 +		u32 *reg_backup;
  
 -	void *cal;
 +		s32 last_freq_offset;
 +		u8 last_rcpi[4];
 +		s8 last_ib_rssi[4];
 +		s8 last_wb_rssi[4];
 +		u8 last_snr;
 +
 +		u8 spe_idx;
 +	} test;
 +#endif
  };
  
  enum {
diff --git a/drivers/net/wireless/mediatek/mt76/mt76.h b/drivers/net/wireless/mediatek/mt76/mt76.h
index 1f34f62819ee..50b0c828315f 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@ -625,6 +625,10 @@ struct mt76_dev {
 	struct napi_struct tx_napi;
 	struct delayed_work mac_work;
 
+	spinlock_t token_lock;
+	struct idr token;
+	int token_count;
+
 	wait_queue_head_t tx_wait;
 	struct sk_buff_head status_list;
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
index 1b8b80e3739d..005e30c29a2b 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
@@ -1440,9 +1440,9 @@ mt7615_mac_tx_free_token(struct mt7615_dev *dev, u16 token)
 
 	trace_mac_tx_free(dev, token);
 
-	spin_lock_bh(&dev->token_lock);
-	txwi = idr_remove(&dev->token, token);
-	spin_unlock_bh(&dev->token_lock);
+	spin_lock_bh(&mdev->token_lock);
+	txwi = idr_remove(&mdev->token, token);
+	spin_unlock_bh(&mdev->token_lock);
 
 	if (!txwi)
 		return;
@@ -2094,8 +2094,8 @@ void mt7615_tx_token_put(struct mt7615_dev *dev)
 	struct mt76_txwi_cache *txwi;
 	int id;
 
-	spin_lock_bh(&dev->token_lock);
-	idr_for_each_entry(&dev->token, txwi, id) {
+	spin_lock_bh(&dev->mt76.token_lock);
+	idr_for_each_entry(&dev->mt76.token, txwi, id) {
 		mt7615_txp_skb_unmap(&dev->mt76, txwi);
 		if (txwi->skb) {
 			struct ieee80211_hw *hw;
@@ -2105,8 +2105,8 @@ void mt7615_tx_token_put(struct mt7615_dev *dev)
 		}
 		mt76_put_txwi(&dev->mt76, txwi);
 	}
-	spin_unlock_bh(&dev->token_lock);
-	idr_destroy(&dev->token);
+	spin_unlock_bh(&dev->mt76.token_lock);
+	idr_destroy(&dev->mt76.token);
 }
 EXPORT_SYMBOL_GPL(mt7615_tx_token_put);
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h b/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
index c44247f210c3..796199287866 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
@@ -268,9 +268,6 @@ struct mt7615_dev {
 	bool flash_eeprom;
 	bool dbdc_support;
 
-	spinlock_t token_lock;
-	struct idr token;
-
 	u8 fw_ver;
 
 	struct work_struct rate_work;
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c b/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
index 08d3dd375ce7..4459385100e6 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
@@ -40,8 +40,8 @@ static int mt7615_init_hardware(struct mt7615_dev *dev)
 	mt76_wr(dev, MT_INT_SOURCE_CSR, ~0);
 
 	INIT_WORK(&dev->mcu_work, mt7615_pci_init_work);
-	spin_lock_init(&dev->token_lock);
-	idr_init(&dev->token);
+	spin_lock_init(&dev->mt76.token_lock);
+	idr_init(&dev->mt76.token);
 
 	ret = mt7615_eeprom_init(dev, addr);
 	if (ret < 0)
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/init.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/mac.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/mt7915.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/init.c b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
index a1cf9d52fcea..55e33748746b 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
@@ -163,8 +163,8 @@ static int mt7921_init_hardware(struct mt7921_dev *dev)
 {
 	int ret, idx;
 
-	spin_lock_init(&dev->token_lock);
-	idr_init(&dev->token);
+	spin_lock_init(&dev->mt76.token_lock);
+	idr_init(&dev->mt76.token);
 
 	ret = mt7921_dma_init(dev);
 	if (ret)
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index bcbd59a23f9b..40bf1c1f6192 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@ -788,14 +788,14 @@ int mt7921_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	t = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);
 	t->skb = tx_info->skb;
 
-	spin_lock_bh(&dev->token_lock);
-	id = idr_alloc(&dev->token, t, 0, MT7921_TOKEN_SIZE, GFP_ATOMIC);
+	spin_lock_bh(&mdev->token_lock);
+	id = idr_alloc(&mdev->token, t, 0, MT7921_TOKEN_SIZE, GFP_ATOMIC);
 	if (id >= 0)
-		dev->token_count++;
+		mdev->token_count++;
 
-	if (dev->token_count >= MT7921_TOKEN_SIZE - MT7921_TOKEN_FREE_THR)
+	if (mdev->token_count >= MT7921_TOKEN_SIZE - MT7921_TOKEN_FREE_THR)
 		mt7921_set_tx_blocked(dev, true);
-	spin_unlock_bh(&dev->token_lock);
+	spin_unlock_bh(&mdev->token_lock);
 
 	if (id < 0)
 		return id;
@@ -958,14 +958,14 @@ void mt7921_mac_tx_free(struct mt7921_dev *dev, struct sk_buff *skb)
 		msdu = FIELD_GET(MT_TX_FREE_MSDU_ID, info);
 		stat = FIELD_GET(MT_TX_FREE_STATUS, info);
 
-		spin_lock_bh(&dev->token_lock);
-		txwi = idr_remove(&dev->token, msdu);
+		spin_lock_bh(&mdev->token_lock);
+		txwi = idr_remove(&mdev->token, msdu);
 		if (txwi)
-			dev->token_count--;
-		if (dev->token_count < MT7921_TOKEN_SIZE - MT7921_TOKEN_FREE_THR &&
+			mdev->token_count--;
+		if (mdev->token_count < MT7921_TOKEN_SIZE - MT7921_TOKEN_FREE_THR &&
 		    dev->mphy.q_tx[0]->blocked)
 			wake = true;
-		spin_unlock_bh(&dev->token_lock);
+		spin_unlock_bh(&mdev->token_lock);
 
 		if (!txwi)
 			continue;
@@ -997,9 +997,9 @@ void mt7921_mac_tx_free(struct mt7921_dev *dev, struct sk_buff *skb)
 	mt7921_mac_sta_poll(dev);
 
 	if (wake) {
-		spin_lock_bh(&dev->token_lock);
+		spin_lock_bh(&mdev->token_lock);
 		mt7921_set_tx_blocked(dev, false);
-		spin_unlock_bh(&dev->token_lock);
+		spin_unlock_bh(&mdev->token_lock);
 	}
 
 	mt76_worker_schedule(&dev->mt76.tx_worker);
@@ -1032,9 +1032,9 @@ void mt7921_tx_complete_skb(struct mt76_dev *mdev, struct mt76_queue_entry *e)
 		txp = mt7921_txwi_to_txp(mdev, e->txwi);
 
 		token = le16_to_cpu(txp->hw.msdu_id[0]) & ~MT_MSDU_ID_VALID;
-		spin_lock_bh(&dev->token_lock);
-		t = idr_remove(&dev->token, token);
-		spin_unlock_bh(&dev->token_lock);
+		spin_lock_bh(&mdev->token_lock);
+		t = idr_remove(&mdev->token, token);
+		spin_unlock_bh(&mdev->token_lock);
 		e->skb = t ? t->skb : NULL;
 	}
 
@@ -1208,8 +1208,8 @@ void mt7921_tx_token_put(struct mt7921_dev *dev)
 	struct mt76_txwi_cache *txwi;
 	int id;
 
-	spin_lock_bh(&dev->token_lock);
-	idr_for_each_entry(&dev->token, txwi, id) {
+	spin_lock_bh(&dev->mt76.token_lock);
+	idr_for_each_entry(&dev->mt76.token, txwi, id) {
 		mt7921_txp_skb_unmap(&dev->mt76, txwi);
 		if (txwi->skb) {
 			struct ieee80211_hw *hw;
@@ -1218,10 +1218,10 @@ void mt7921_tx_token_put(struct mt7921_dev *dev)
 			ieee80211_free_txskb(hw, txwi->skb);
 		}
 		mt76_put_txwi(&dev->mt76, txwi);
-		dev->token_count--;
+		dev->mt76.token_count--;
 	}
-	spin_unlock_bh(&dev->token_lock);
-	idr_destroy(&dev->token);
+	spin_unlock_bh(&dev->mt76.token_lock);
+	idr_destroy(&dev->mt76.token);
 }
 
 /* system error recovery */
@@ -1255,7 +1255,7 @@ void mt7921_mac_reset_work(struct work_struct *work)
 	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);
 
 	mt7921_tx_token_put(dev);
-	idr_init(&dev->token);
+	idr_init(&dev->mt76.token);
 
 	if (mt7921_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
 		mt7921_dma_reset(&dev->phy);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index 6e3579d48c30..7a62e93061ae 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@ -158,10 +158,6 @@ struct mt7921_dev {
 	struct list_head sta_poll_list;
 	spinlock_t sta_poll_lock;
 
-	spinlock_t token_lock;
-	int token_count;
-	struct idr token;
-
 	u8 fw_debug;
 };
 
