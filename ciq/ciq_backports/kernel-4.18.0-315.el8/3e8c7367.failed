LSM: Make some functions static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Wei Yongjun <weiyongjun1@huawei.com>
commit 3e8c73671244af16f1a6042f1c10d13b75cd1156
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/3e8c7367.failed

Fixes the following sparse warnings:

security/security.c:533:5: warning:
 symbol 'lsm_task_alloc' was not declared. Should it be static?
security/security.c:554:5: warning:
 symbol 'lsm_ipc_alloc' was not declared. Should it be static?
security/security.c:575:5: warning:
 symbol 'lsm_msg_msg_alloc' was not declared. Should it be static?

Fixes: f4ad8f2c4076 ("LSM: Infrastructure management of the task security")
	Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
	Acked-by: Casey Schaufler <casey@schaufler-ca.com>
	Signed-off-by: James Morris <james.morris@microsoft.com>
(cherry picked from commit 3e8c73671244af16f1a6042f1c10d13b75cd1156)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/security.c
diff --cc security/security.c
index 8555aece1bce,3664fb9d5cf7..000000000000
--- a/security/security.c
+++ b/security/security.c
@@@ -371,45 -426,178 +371,186 @@@ void __init security_add_hooks(struct s
  		panic("%s - Cannot get early memory.\n", __func__);
  }
  
 -int call_lsm_notifier(enum lsm_event event, void *data)
 +int call_blocking_lsm_notifier(enum lsm_event event, void *data)
  {
 -	return atomic_notifier_call_chain(&lsm_notifier_chain, event, data);
 +	return blocking_notifier_call_chain(&blocking_lsm_notifier_chain,
 +					    event, data);
  }
 -EXPORT_SYMBOL(call_lsm_notifier);
 +EXPORT_SYMBOL(call_blocking_lsm_notifier);
  
 -int register_lsm_notifier(struct notifier_block *nb)
 +int register_blocking_lsm_notifier(struct notifier_block *nb)
  {
 -	return atomic_notifier_chain_register(&lsm_notifier_chain, nb);
 +	return blocking_notifier_chain_register(&blocking_lsm_notifier_chain,
 +						nb);
  }
 -EXPORT_SYMBOL(register_lsm_notifier);
 +EXPORT_SYMBOL(register_blocking_lsm_notifier);
  
 -int unregister_lsm_notifier(struct notifier_block *nb)
 +int unregister_blocking_lsm_notifier(struct notifier_block *nb)
  {
 -	return atomic_notifier_chain_unregister(&lsm_notifier_chain, nb);
 +	return blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,
 +						  nb);
  }
 -EXPORT_SYMBOL(unregister_lsm_notifier);
 +EXPORT_SYMBOL(unregister_blocking_lsm_notifier);
  
 -/**
 - * lsm_cred_alloc - allocate a composite cred blob
 - * @cred: the cred that needs a blob
 - * @gfp: allocation type
 +/*
 + * The default value of the LSM hook is defined in linux/lsm_hook_defs.h and
 + * can be accessed with:
   *
 - * Allocate the cred blob for all the modules
 + *	LSM_RET_DEFAULT(<hook_name>)
   *
 - * Returns 0, or -ENOMEM if memory can't be allocated.
 + * The macros below define static constants for the default value of each
 + * LSM hook.
   */
 -static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)
 -{
 -	if (blob_sizes.lbs_cred == 0) {
 -		cred->security = NULL;
 -		return 0;
 -	}
 -
 +#define LSM_RET_DEFAULT(NAME) (NAME##_default)
 +#define DECLARE_LSM_RET_DEFAULT_void(DEFAULT, NAME)
 +#define DECLARE_LSM_RET_DEFAULT_int(DEFAULT, NAME) \
 +	static const int LSM_RET_DEFAULT(NAME) = (DEFAULT);
 +#define LSM_HOOK(RET, DEFAULT, NAME, ...) \
 +	DECLARE_LSM_RET_DEFAULT_##RET(DEFAULT, NAME)
 +
++<<<<<<< HEAD
 +#include <linux/lsm_hook_defs.h>
 +#undef LSM_HOOK
++=======
+ 	cred->security = kzalloc(blob_sizes.lbs_cred, gfp);
+ 	if (cred->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_early_cred - during initialization allocate a composite cred blob
+  * @cred: the cred that needs a blob
+  *
+  * Allocate the cred blob for all the modules
+  */
+ static void __init lsm_early_cred(struct cred *cred)
+ {
+ 	int rc = lsm_cred_alloc(cred, GFP_KERNEL);
+ 
+ 	if (rc)
+ 		panic("%s: Early cred alloc failed.\n", __func__);
+ }
+ 
+ /**
+  * lsm_file_alloc - allocate a composite file blob
+  * @file: the file that needs a blob
+  *
+  * Allocate the file blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ static int lsm_file_alloc(struct file *file)
+ {
+ 	if (!lsm_file_cache) {
+ 		file->f_security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	file->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);
+ 	if (file->f_security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_inode_alloc - allocate a composite inode blob
+  * @inode: the inode that needs a blob
+  *
+  * Allocate the inode blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_inode_alloc(struct inode *inode)
+ {
+ 	if (!lsm_inode_cache) {
+ 		inode->i_security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	inode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);
+ 	if (inode->i_security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_task_alloc - allocate a composite task blob
+  * @task: the task that needs a blob
+  *
+  * Allocate the task blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ static int lsm_task_alloc(struct task_struct *task)
+ {
+ 	if (blob_sizes.lbs_task == 0) {
+ 		task->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	task->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);
+ 	if (task->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_ipc_alloc - allocate a composite ipc blob
+  * @kip: the ipc that needs a blob
+  *
+  * Allocate the ipc blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ static int lsm_ipc_alloc(struct kern_ipc_perm *kip)
+ {
+ 	if (blob_sizes.lbs_ipc == 0) {
+ 		kip->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	kip->security = kzalloc(blob_sizes.lbs_ipc, GFP_KERNEL);
+ 	if (kip->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_msg_msg_alloc - allocate a composite msg_msg blob
+  * @mp: the msg_msg that needs a blob
+  *
+  * Allocate the ipc blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ static int lsm_msg_msg_alloc(struct msg_msg *mp)
+ {
+ 	if (blob_sizes.lbs_msg_msg == 0) {
+ 		mp->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	mp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);
+ 	if (mp->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_early_task - during initialization allocate a composite task blob
+  * @task: the task that needs a blob
+  *
+  * Allocate the task blob for all the modules
+  */
+ static void __init lsm_early_task(struct task_struct *task)
+ {
+ 	int rc = lsm_task_alloc(task);
+ 
+ 	if (rc)
+ 		panic("%s: Early task alloc failed.\n", __func__);
+ }
++>>>>>>> 3e8c73671244 (LSM: Make some functions static)
  
  /*
   * Hook list operation macros.
* Unmerged path security/security.c
