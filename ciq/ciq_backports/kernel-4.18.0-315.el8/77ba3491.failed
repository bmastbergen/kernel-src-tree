mt76: mt7921: introduce mt7921_wpdma_reinit_cond utility routine

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 77ba349101ac22bae2d4e635245b60173d49de2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/77ba3491.failed

Add mt7921_wpdma_reinit_cond to check dummy reg if driver needs to
reinitialized WPDMA after driver_own operation

Co-developed-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
Co-developed-by: Leon Yen <leon.yen@mediatek.com>
	Signed-off-by: Leon Yen <leon.yen@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 77ba349101ac22bae2d4e635245b60173d49de2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt76_connac.h
#	drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
index 1557547efa2f,6ee423dd4027..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
@@@ -161,6 -149,190 +161,193 @@@ mt7921_queues_read(struct seq_file *s, 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mt7921_seq_puts_array(struct seq_file *file, const char *str,
+ 		      s8 *val, int len)
+ {
+ 	int i;
+ 
+ 	seq_printf(file, "%-16s:", str);
+ 	for (i = 0; i < len; i++)
+ 		if (val[i] == 127)
+ 			seq_printf(file, " %6s", "N.A");
+ 		else
+ 			seq_printf(file, " %6d", val[i]);
+ 	seq_puts(file, "\n");
+ }
+ 
+ #define mt7921_print_txpwr_entry(prefix, rate)				\
+ ({									\
+ 	mt7921_seq_puts_array(s, #prefix " (user)",			\
+ 			      txpwr.data[TXPWR_USER].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_USER].rate)); \
+ 	mt7921_seq_puts_array(s, #prefix " (eeprom)",			\
+ 			      txpwr.data[TXPWR_EEPROM].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_EEPROM].rate)); \
+ 	mt7921_seq_puts_array(s, #prefix " (tmac)",			\
+ 			      txpwr.data[TXPWR_MAC].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_MAC].rate));	\
+ })
+ 
+ static int
+ mt7921_txpwr(struct seq_file *s, void *data)
+ {
+ 	struct mt7921_dev *dev = dev_get_drvdata(s->private);
+ 	struct mt7921_txpwr txpwr;
+ 	int ret;
+ 
+ 	ret = mt7921_get_txpwr_info(dev, &txpwr);
+ 	if (ret)
+ 		return ret;
+ 
+ 	seq_printf(s, "Tx power table (channel %d)\n", txpwr.ch);
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s\n",
+ 		   " ", "1m", "2m", "5m", "11m");
+ 	mt7921_print_txpwr_entry(CCK, cck);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "6m", "9m", "12m", "18m", "24m", "36m",
+ 		   "48m", "54m");
+ 	mt7921_print_txpwr_entry(OFDM, ofdm);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7");
+ 	mt7921_print_txpwr_entry(HT20, ht20);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7", "mcs32");
+ 	mt7921_print_txpwr_entry(HT40, ht40);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7", "mcs8", "mcs9", "mcs10", "mcs11");
+ 	mt7921_print_txpwr_entry(VHT20, vht20);
+ 	mt7921_print_txpwr_entry(VHT40, vht40);
+ 	mt7921_print_txpwr_entry(VHT80, vht80);
+ 	mt7921_print_txpwr_entry(VHT160, vht160);
+ 	mt7921_print_txpwr_entry(HE26, he26);
+ 	mt7921_print_txpwr_entry(HE52, he52);
+ 	mt7921_print_txpwr_entry(HE106, he106);
+ 	mt7921_print_txpwr_entry(HE242, he242);
+ 	mt7921_print_txpwr_entry(HE484, he484);
+ 	mt7921_print_txpwr_entry(HE996, he996);
+ 	mt7921_print_txpwr_entry(HE996x2, he996x2);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_set(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 	struct mt76_connac_pm *pm = &dev->pm;
+ 	struct mt76_phy *mphy = dev->phy.mt76;
+ 
+ 	if (val == pm->enable)
+ 		return 0;
+ 
+ 	mt7921_mutex_acquire(dev);
+ 
+ 	if (!pm->enable) {
+ 		pm->stats.last_wake_event = jiffies;
+ 		pm->stats.last_doze_event = jiffies;
+ 	}
+ 	pm->enable = val;
+ 
+ 	ieee80211_iterate_active_interfaces(mphy->hw,
+ 					    IEEE80211_IFACE_ITER_RESUME_ALL,
+ 					    mt7921_pm_interface_iter, mphy->priv);
+ 	mt7921_mutex_release(dev);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_get(void *data, u64 *val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	*val = dev->pm.enable;
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_pm, mt7921_pm_get, mt7921_pm_set, "%lld\n");
+ 
+ static int
+ mt7921_pm_stats(struct seq_file *s, void *data)
+ {
+ 	struct mt7921_dev *dev = dev_get_drvdata(s->private);
+ 	struct mt76_connac_pm *pm = &dev->pm;
+ 
+ 	unsigned long awake_time = pm->stats.awake_time;
+ 	unsigned long doze_time = pm->stats.doze_time;
+ 
+ 	if (!test_bit(MT76_STATE_PM, &dev->mphy.state))
+ 		awake_time += jiffies - pm->stats.last_wake_event;
+ 	else
+ 		doze_time += jiffies - pm->stats.last_doze_event;
+ 
+ 	seq_printf(s, "awake time: %14u\ndoze time: %15u\n",
+ 		   jiffies_to_msecs(awake_time),
+ 		   jiffies_to_msecs(doze_time));
+ 
+ 	seq_printf(s, "low power wakes: %9d\n", pm->stats.lp_wake);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_idle_timeout_set(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	dev->pm.idle_timeout = msecs_to_jiffies(val);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_idle_timeout_get(void *data, u64 *val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	*val = jiffies_to_msecs(dev->pm.idle_timeout);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_pm_idle_timeout, mt7921_pm_idle_timeout_get,
+ 			 mt7921_pm_idle_timeout_set, "%lld\n");
+ 
+ static int mt7921_chip_reset(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 	int ret = 0;
+ 
+ 	switch (val) {
+ 	case 1:
+ 		/* Reset wifisys directly. */
+ 		mt7921_reset(&dev->mt76);
+ 		break;
+ 	default:
+ 		/* Collect the core dump before reset wifisys. */
+ 		mt7921_mutex_acquire(dev);
+ 		ret = mt76_connac_mcu_chip_config(&dev->mt76);
+ 		mt7921_mutex_release(dev);
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_reset, NULL, mt7921_chip_reset, "%lld\n");
+ 
++>>>>>>> 77ba349101ac (mt76: mt7921: introduce mt7921_wpdma_reinit_cond utility routine)
  int mt7921_init_debugfs(struct mt7921_dev *dev)
  {
  	struct dentry *dir;
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index 6e3579d48c30,5bcbf1bc0746..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@@ -225,7 -253,8 +225,12 @@@ int mt7921_eeprom_get_target_power(stru
  				   u8 chain_idx);
  void mt7921_eeprom_init_sku(struct mt7921_dev *dev);
  int mt7921_dma_init(struct mt7921_dev *dev);
++<<<<<<< HEAD
 +void mt7921_dma_prefetch(struct mt7921_dev *dev);
++=======
+ int mt7921_wpdma_reset(struct mt7921_dev *dev, bool force);
+ int mt7921_wpdma_reinit_cond(struct mt7921_dev *dev);
++>>>>>>> 77ba349101ac (mt76: mt7921: introduce mt7921_wpdma_reinit_cond utility routine)
  void mt7921_dma_cleanup(struct mt7921_dev *dev);
  int mt7921_run_firmware(struct mt7921_dev *dev);
  int mt7921_mcu_init(struct mt7921_dev *dev);
@@@ -293,6 -316,12 +298,15 @@@ mt7921_l1_rmw(struct mt7921_dev *dev, u
  #define mt7921_l1_set(dev, addr, val)	mt7921_l1_rmw(dev, addr, 0, val)
  #define mt7921_l1_clear(dev, addr, val)	mt7921_l1_rmw(dev, addr, val, 0)
  
++<<<<<<< HEAD
++=======
+ static inline bool mt7921_dma_need_reinit(struct mt7921_dev *dev)
+ {
+ 	return !mt76_get_field(dev, MT_WFDMA_DUMMY_CR, MT_WFDMA_NEED_REINIT);
+ }
+ 
+ void mt7921_mac_init(struct mt7921_dev *dev);
++>>>>>>> 77ba349101ac (mt76: mt7921: introduce mt7921_wpdma_reinit_cond utility routine)
  bool mt7921_mac_wtbl_update(struct mt7921_dev *dev, int idx, u32 mask);
  void mt7921_mac_reset_counters(struct mt7921_phy *phy);
  void mt7921_mac_write_txwi(struct mt7921_dev *dev, __le32 *txwi,
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/dma.c b/drivers/net/wireless/mediatek/mt76/mt7921/dma.c
index cd9665610284..b933f4588369 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/dma.c
@@ -206,6 +206,31 @@ static int mt7921_dmashdl_disabled(struct mt7921_dev *dev)
 	return 0;
 }
 
+int mt7921_wpdma_reinit_cond(struct mt7921_dev *dev)
+{
+	struct mt76_connac_pm *pm = &dev->pm;
+	int err;
+
+	/* check if the wpdma must be reinitialized */
+	if (mt7921_dma_need_reinit(dev)) {
+		/* disable interrutpts */
+		mt76_wr(dev, MT_WFDMA0_HOST_INT_ENA, 0);
+		mt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0x0);
+
+		err = mt7921_wpdma_reset(dev, false);
+		if (err) {
+			dev_err(dev->mt76.dev, "wpdma reset failed\n");
+			return err;
+		}
+
+		/* enable interrutpts */
+		mt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);
+		pm->stats.lp_wake++;
+	}
+
+	return 0;
+}
+
 int mt7921_dma_init(struct mt7921_dev *dev)
 {
 	/* Increase buffer size to receive large VHT/HE MPDUs */
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
