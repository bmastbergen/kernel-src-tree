mac80211_hwsim: use DEFINE_SPINLOCK() for spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Guobin Huang <huangguobin4@huawei.com>
commit 30a70d18e862d505a34f2b21ccb83f5d4792e2d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/30a70d18.failed

spinlock can be initialized automatically with DEFINE_SPINLOCK()
rather than explicitly calling spin_lock_init().

	Reported-by: Hulk Robot <hulkci@huawei.com>
	Signed-off-by: Guobin Huang <huangguobin4@huawei.com>
Link: https://lore.kernel.org/r/1616839160-6654-1-git-send-email-huangguobin4@huawei.com
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 30a70d18e862d505a34f2b21ccb83f5d4792e2d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
diff --cc drivers/net/wireless/mac80211_hwsim.c
index 44349b59bf72,d56d2095a0d4..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -557,49 -596,7 +557,53 @@@ static const struct nl80211_vendor_cmd_
  	{ .vendor_id = OUI_QCA, .subcmd = 1 },
  };
  
++<<<<<<< HEAD
 +static const struct ieee80211_iface_limit hwsim_if_limits[] = {
 +	{ .max = 1, .types = BIT(NL80211_IFTYPE_ADHOC) },
 +	{ .max = 2048,  .types = BIT(NL80211_IFTYPE_STATION) |
 +				 BIT(NL80211_IFTYPE_P2P_CLIENT) |
 +#ifdef CONFIG_MAC80211_MESH
 +				 BIT(NL80211_IFTYPE_MESH_POINT) |
 +#endif
 +				 BIT(NL80211_IFTYPE_AP) |
 +				 BIT(NL80211_IFTYPE_P2P_GO) },
 +	/* must be last, see hwsim_if_comb */
 +	{ .max = 1, .types = BIT(NL80211_IFTYPE_P2P_DEVICE) }
 +};
 +
 +static const struct ieee80211_iface_combination hwsim_if_comb[] = {
 +	{
 +		.limits = hwsim_if_limits,
 +		/* remove the last entry which is P2P_DEVICE */
 +		.n_limits = ARRAY_SIZE(hwsim_if_limits) - 1,
 +		.max_interfaces = 2048,
 +		.num_different_channels = 1,
 +		.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
 +				       BIT(NL80211_CHAN_WIDTH_20) |
 +				       BIT(NL80211_CHAN_WIDTH_40) |
 +				       BIT(NL80211_CHAN_WIDTH_80) |
 +				       BIT(NL80211_CHAN_WIDTH_160),
 +	},
 +};
 +
 +static const struct ieee80211_iface_combination hwsim_if_comb_p2p_dev[] = {
 +	{
 +		.limits = hwsim_if_limits,
 +		.n_limits = ARRAY_SIZE(hwsim_if_limits),
 +		.max_interfaces = 2048,
 +		.num_different_channels = 1,
 +		.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
 +				       BIT(NL80211_CHAN_WIDTH_20) |
 +				       BIT(NL80211_CHAN_WIDTH_40) |
 +				       BIT(NL80211_CHAN_WIDTH_80) |
 +				       BIT(NL80211_CHAN_WIDTH_160),
 +	},
 +};
 +
 +static spinlock_t hwsim_radio_lock;
++=======
+ static DEFINE_SPINLOCK(hwsim_radio_lock);
++>>>>>>> 30a70d18e862 (mac80211_hwsim: use DEFINE_SPINLOCK() for spinlock)
  static LIST_HEAD(hwsim_radios);
  static struct rhashtable hwsim_radios_rht;
  static int hwsim_radio_idx;
@@@ -750,9 -752,56 +754,56 @@@ static const struct nla_policy hwsim_ge
  	[HWSIM_ATTR_RADIO_NAME] = { .type = NLA_STRING },
  	[HWSIM_ATTR_NO_VIF] = { .type = NLA_FLAG },
  	[HWSIM_ATTR_FREQ] = { .type = NLA_U32 },
 -	[HWSIM_ATTR_TX_INFO_FLAGS] = { .type = NLA_BINARY },
 -	[HWSIM_ATTR_PERM_ADDR] = NLA_POLICY_ETH_ADDR_COMPAT,
 -	[HWSIM_ATTR_IFTYPE_SUPPORT] = { .type = NLA_U32 },
 -	[HWSIM_ATTR_CIPHER_SUPPORT] = { .type = NLA_BINARY },
 +	[HWSIM_ATTR_PERM_ADDR] = { .type = NLA_UNSPEC, .len = ETH_ALEN },
  };
  
++<<<<<<< HEAD
++=======
+ #if IS_REACHABLE(CONFIG_VIRTIO)
+ 
+ /* MAC80211_HWSIM virtio queues */
+ static struct virtqueue *hwsim_vqs[HWSIM_NUM_VQS];
+ static bool hwsim_virtio_enabled;
+ static DEFINE_SPINLOCK(hwsim_virtio_lock);
+ 
+ static void hwsim_virtio_rx_work(struct work_struct *work);
+ static DECLARE_WORK(hwsim_virtio_rx, hwsim_virtio_rx_work);
+ 
+ static int hwsim_tx_virtio(struct mac80211_hwsim_data *data,
+ 			   struct sk_buff *skb)
+ {
+ 	struct scatterlist sg[1];
+ 	unsigned long flags;
+ 	int err;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	if (!hwsim_virtio_enabled) {
+ 		err = -ENODEV;
+ 		goto out_free;
+ 	}
+ 
+ 	sg_init_one(sg, skb->head, skb_end_offset(skb));
+ 	err = virtqueue_add_outbuf(hwsim_vqs[HWSIM_VQ_TX], sg, 1, skb,
+ 				   GFP_ATOMIC);
+ 	if (err)
+ 		goto out_free;
+ 	virtqueue_kick(hwsim_vqs[HWSIM_VQ_TX]);
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 	return 0;
+ 
+ out_free:
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 	nlmsg_free(skb);
+ 	return err;
+ }
+ #else
+ /* cause a linker error if this ends up being needed */
+ extern int hwsim_tx_virtio(struct mac80211_hwsim_data *data,
+ 			   struct sk_buff *skb);
+ #define hwsim_virtio_enabled false
+ #endif
+ 
++>>>>>>> 30a70d18e862 (mac80211_hwsim: use DEFINE_SPINLOCK() for spinlock)
  static void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,
  				    struct sk_buff *skb,
  				    struct ieee80211_channel *chan);
@@@ -3787,6 -4207,227 +3838,230 @@@ static void hwsim_exit_netlink(void
  	genl_unregister_family(&hwsim_genl_family);
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_REACHABLE(CONFIG_VIRTIO)
+ static void hwsim_virtio_tx_done(struct virtqueue *vq)
+ {
+ 	unsigned int len;
+ 	struct sk_buff *skb;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	while ((skb = virtqueue_get_buf(vq, &len)))
+ 		nlmsg_free(skb);
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ }
+ 
+ static int hwsim_virtio_handle_cmd(struct sk_buff *skb)
+ {
+ 	struct nlmsghdr *nlh;
+ 	struct genlmsghdr *gnlh;
+ 	struct nlattr *tb[HWSIM_ATTR_MAX + 1];
+ 	struct genl_info info = {};
+ 	int err;
+ 
+ 	nlh = nlmsg_hdr(skb);
+ 	gnlh = nlmsg_data(nlh);
+ 	err = genlmsg_parse(nlh, &hwsim_genl_family, tb, HWSIM_ATTR_MAX,
+ 			    hwsim_genl_policy, NULL);
+ 	if (err) {
+ 		pr_err_ratelimited("hwsim: genlmsg_parse returned %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	info.attrs = tb;
+ 
+ 	switch (gnlh->cmd) {
+ 	case HWSIM_CMD_FRAME:
+ 		hwsim_cloned_frame_received_nl(skb, &info);
+ 		break;
+ 	case HWSIM_CMD_TX_INFO_FRAME:
+ 		hwsim_tx_info_frame_received_nl(skb, &info);
+ 		break;
+ 	default:
+ 		pr_err_ratelimited("hwsim: invalid cmd: %d\n", gnlh->cmd);
+ 		return -EPROTO;
+ 	}
+ 	return 0;
+ }
+ 
+ static void hwsim_virtio_rx_work(struct work_struct *work)
+ {
+ 	struct virtqueue *vq;
+ 	unsigned int len;
+ 	struct sk_buff *skb;
+ 	struct scatterlist sg[1];
+ 	int err;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	if (!hwsim_virtio_enabled)
+ 		goto out_unlock;
+ 
+ 	skb = virtqueue_get_buf(hwsim_vqs[HWSIM_VQ_RX], &len);
+ 	if (!skb)
+ 		goto out_unlock;
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 
+ 	skb->data = skb->head;
+ 	skb_set_tail_pointer(skb, len);
+ 	hwsim_virtio_handle_cmd(skb);
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	if (!hwsim_virtio_enabled) {
+ 		nlmsg_free(skb);
+ 		goto out_unlock;
+ 	}
+ 	vq = hwsim_vqs[HWSIM_VQ_RX];
+ 	sg_init_one(sg, skb->head, skb_end_offset(skb));
+ 	err = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_ATOMIC);
+ 	if (WARN(err, "virtqueue_add_inbuf returned %d\n", err))
+ 		nlmsg_free(skb);
+ 	else
+ 		virtqueue_kick(vq);
+ 	schedule_work(&hwsim_virtio_rx);
+ 
+ out_unlock:
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ }
+ 
+ static void hwsim_virtio_rx_done(struct virtqueue *vq)
+ {
+ 	schedule_work(&hwsim_virtio_rx);
+ }
+ 
+ static int init_vqs(struct virtio_device *vdev)
+ {
+ 	vq_callback_t *callbacks[HWSIM_NUM_VQS] = {
+ 		[HWSIM_VQ_TX] = hwsim_virtio_tx_done,
+ 		[HWSIM_VQ_RX] = hwsim_virtio_rx_done,
+ 	};
+ 	const char *names[HWSIM_NUM_VQS] = {
+ 		[HWSIM_VQ_TX] = "tx",
+ 		[HWSIM_VQ_RX] = "rx",
+ 	};
+ 
+ 	return virtio_find_vqs(vdev, HWSIM_NUM_VQS,
+ 			       hwsim_vqs, callbacks, names, NULL);
+ }
+ 
+ static int fill_vq(struct virtqueue *vq)
+ {
+ 	int i, err;
+ 	struct sk_buff *skb;
+ 	struct scatterlist sg[1];
+ 
+ 	for (i = 0; i < virtqueue_get_vring_size(vq); i++) {
+ 		skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 		if (!skb)
+ 			return -ENOMEM;
+ 
+ 		sg_init_one(sg, skb->head, skb_end_offset(skb));
+ 		err = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_KERNEL);
+ 		if (err) {
+ 			nlmsg_free(skb);
+ 			return err;
+ 		}
+ 	}
+ 	virtqueue_kick(vq);
+ 	return 0;
+ }
+ 
+ static void remove_vqs(struct virtio_device *vdev)
+ {
+ 	int i;
+ 
+ 	vdev->config->reset(vdev);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(hwsim_vqs); i++) {
+ 		struct virtqueue *vq = hwsim_vqs[i];
+ 		struct sk_buff *skb;
+ 
+ 		while ((skb = virtqueue_detach_unused_buf(vq)))
+ 			nlmsg_free(skb);
+ 	}
+ 
+ 	vdev->config->del_vqs(vdev);
+ }
+ 
+ static int hwsim_virtio_probe(struct virtio_device *vdev)
+ {
+ 	int err;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	if (hwsim_virtio_enabled) {
+ 		spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 		return -EEXIST;
+ 	}
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 
+ 	err = init_vqs(vdev);
+ 	if (err)
+ 		return err;
+ 
+ 	err = fill_vq(hwsim_vqs[HWSIM_VQ_RX]);
+ 	if (err)
+ 		goto out_remove;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	hwsim_virtio_enabled = true;
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 
+ 	schedule_work(&hwsim_virtio_rx);
+ 	return 0;
+ 
+ out_remove:
+ 	remove_vqs(vdev);
+ 	return err;
+ }
+ 
+ static void hwsim_virtio_remove(struct virtio_device *vdev)
+ {
+ 	hwsim_virtio_enabled = false;
+ 
+ 	cancel_work_sync(&hwsim_virtio_rx);
+ 
+ 	remove_vqs(vdev);
+ }
+ 
+ /* MAC80211_HWSIM virtio device id table */
+ static const struct virtio_device_id id_table[] = {
+ 	{ VIRTIO_ID_MAC80211_HWSIM, VIRTIO_DEV_ANY_ID },
+ 	{ 0 }
+ };
+ MODULE_DEVICE_TABLE(virtio, id_table);
+ 
+ static struct virtio_driver virtio_hwsim = {
+ 	.driver.name = KBUILD_MODNAME,
+ 	.driver.owner = THIS_MODULE,
+ 	.id_table = id_table,
+ 	.probe = hwsim_virtio_probe,
+ 	.remove = hwsim_virtio_remove,
+ };
+ 
+ static int hwsim_register_virtio_driver(void)
+ {
+ 	return register_virtio_driver(&virtio_hwsim);
+ }
+ 
+ static void hwsim_unregister_virtio_driver(void)
+ {
+ 	unregister_virtio_driver(&virtio_hwsim);
+ }
+ #else
+ static inline int hwsim_register_virtio_driver(void)
+ {
+ 	return 0;
+ }
+ 
+ static inline void hwsim_unregister_virtio_driver(void)
+ {
+ }
+ #endif
+ 
++>>>>>>> 30a70d18e862 (mac80211_hwsim: use DEFINE_SPINLOCK() for spinlock)
  static int __init init_mac80211_hwsim(void)
  {
  	int i, err;
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
