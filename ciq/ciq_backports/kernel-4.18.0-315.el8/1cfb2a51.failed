LSM: Make lsm_early_cred() and lsm_early_task() local functions.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
commit 1cfb2a512e74e577bb0ed7c8d76df90a41a83f6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/1cfb2a51.failed

Since current->cred == current->real_cred when ordered_lsm_init()
is called, and lsm_early_cred()/lsm_early_task() need to be called
between the amount of required bytes is determined and module specific
initialization function is called, we can move these calls from
individual modules to ordered_lsm_init().

	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Acked-by: Casey Schaufler <casey@schaufler-ca.com>
	Signed-off-by: James Morris <james.morris@microsoft.com>
(cherry picked from commit 1cfb2a512e74e577bb0ed7c8d76df90a41a83f6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/lsm_hooks.h
#	security/apparmor/lsm.c
#	security/security.c
#	security/selinux/hooks.c
#	security/smack/smack_lsm.c
#	security/tomoyo/tomoyo.c
diff --cc include/linux/lsm_hooks.h
index 84380f3a8dab,22fc786d723a..000000000000
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@@ -1552,4 -2110,6 +1552,9 @@@ static inline void security_delete_hook
  #define __lsm_ro_after_init	__ro_after_init
  #endif /* CONFIG_SECURITY_WRITABLE_HOOKS */
  
++<<<<<<< HEAD
++=======
+ extern int lsm_inode_alloc(struct inode *inode);
+ 
++>>>>>>> 1cfb2a512e74 (LSM: Make lsm_early_cred() and lsm_early_task() local functions.)
  #endif /* ! __LINUX_LSM_HOOKS_H */
diff --cc security/apparmor/lsm.c
index 85c05989635b,bb5a02d2439f..000000000000
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@@ -1449,14 -1483,8 +1449,18 @@@ static int param_set_mode(const char *v
  static int __init set_init_ctx(void)
  {
  	struct cred *cred = (struct cred *)current->real_cred;
 +	struct aa_task_ctx *ctx;
 +
++<<<<<<< HEAD
 +	ctx = aa_alloc_task_ctx(GFP_KERNEL);
 +	if (!ctx)
 +		return -ENOMEM;
  
 +	cred_label(cred) = aa_get_label(ns_unconfined(root_ns));
 +	task_ctx(current) = ctx;
++=======
+ 	set_cred_label(cred, aa_get_label(ns_unconfined(root_ns)));
++>>>>>>> 1cfb2a512e74 (LSM: Make lsm_early_cred() and lsm_early_task() local functions.)
  
  	return 0;
  }
diff --cc security/security.c
index 8555aece1bce,992b612c819a..000000000000
--- a/security/security.c
+++ b/security/security.c
@@@ -262,6 -296,27 +265,30 @@@ static void __init ordered_lsm_init(voi
  	for (lsm = ordered_lsms; *lsm; lsm++)
  		prepare_lsm(*lsm);
  
++<<<<<<< HEAD
++=======
+ 	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
+ 	init_debug("file blob size     = %d\n", blob_sizes.lbs_file);
+ 	init_debug("inode blob size    = %d\n", blob_sizes.lbs_inode);
+ 	init_debug("ipc blob size      = %d\n", blob_sizes.lbs_ipc);
+ 	init_debug("msg_msg blob size  = %d\n", blob_sizes.lbs_msg_msg);
+ 	init_debug("task blob size     = %d\n", blob_sizes.lbs_task);
+ 
+ 	/*
+ 	 * Create any kmem_caches needed for blobs
+ 	 */
+ 	if (blob_sizes.lbs_file)
+ 		lsm_file_cache = kmem_cache_create("lsm_file_cache",
+ 						   blob_sizes.lbs_file, 0,
+ 						   SLAB_PANIC, NULL);
+ 	if (blob_sizes.lbs_inode)
+ 		lsm_inode_cache = kmem_cache_create("lsm_inode_cache",
+ 						    blob_sizes.lbs_inode, 0,
+ 						    SLAB_PANIC, NULL);
+ 
+ 	lsm_early_cred((struct cred *) current->cred);
+ 	lsm_early_task(current);
++>>>>>>> 1cfb2a512e74 (LSM: Make lsm_early_cred() and lsm_early_task() local functions.)
  	for (lsm = ordered_lsms; *lsm; lsm++)
  		initialize_lsm(*lsm);
  
@@@ -371,45 -426,178 +398,186 @@@ void __init security_add_hooks(struct s
  		panic("%s - Cannot get early memory.\n", __func__);
  }
  
 -int call_lsm_notifier(enum lsm_event event, void *data)
 +int call_blocking_lsm_notifier(enum lsm_event event, void *data)
  {
 -	return atomic_notifier_call_chain(&lsm_notifier_chain, event, data);
 +	return blocking_notifier_call_chain(&blocking_lsm_notifier_chain,
 +					    event, data);
  }
 -EXPORT_SYMBOL(call_lsm_notifier);
 +EXPORT_SYMBOL(call_blocking_lsm_notifier);
  
 -int register_lsm_notifier(struct notifier_block *nb)
 +int register_blocking_lsm_notifier(struct notifier_block *nb)
  {
 -	return atomic_notifier_chain_register(&lsm_notifier_chain, nb);
 +	return blocking_notifier_chain_register(&blocking_lsm_notifier_chain,
 +						nb);
  }
 -EXPORT_SYMBOL(register_lsm_notifier);
 +EXPORT_SYMBOL(register_blocking_lsm_notifier);
  
 -int unregister_lsm_notifier(struct notifier_block *nb)
 +int unregister_blocking_lsm_notifier(struct notifier_block *nb)
  {
 -	return atomic_notifier_chain_unregister(&lsm_notifier_chain, nb);
 +	return blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,
 +						  nb);
  }
 -EXPORT_SYMBOL(unregister_lsm_notifier);
 +EXPORT_SYMBOL(unregister_blocking_lsm_notifier);
  
 -/**
 - * lsm_cred_alloc - allocate a composite cred blob
 - * @cred: the cred that needs a blob
 - * @gfp: allocation type
 +/*
 + * The default value of the LSM hook is defined in linux/lsm_hook_defs.h and
 + * can be accessed with:
   *
 - * Allocate the cred blob for all the modules
 + *	LSM_RET_DEFAULT(<hook_name>)
   *
 - * Returns 0, or -ENOMEM if memory can't be allocated.
 + * The macros below define static constants for the default value of each
 + * LSM hook.
   */
 -static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)
 -{
 -	if (blob_sizes.lbs_cred == 0) {
 -		cred->security = NULL;
 -		return 0;
 -	}
 -
 +#define LSM_RET_DEFAULT(NAME) (NAME##_default)
 +#define DECLARE_LSM_RET_DEFAULT_void(DEFAULT, NAME)
 +#define DECLARE_LSM_RET_DEFAULT_int(DEFAULT, NAME) \
 +	static const int LSM_RET_DEFAULT(NAME) = (DEFAULT);
 +#define LSM_HOOK(RET, DEFAULT, NAME, ...) \
 +	DECLARE_LSM_RET_DEFAULT_##RET(DEFAULT, NAME)
 +
++<<<<<<< HEAD
 +#include <linux/lsm_hook_defs.h>
 +#undef LSM_HOOK
++=======
+ 	cred->security = kzalloc(blob_sizes.lbs_cred, gfp);
+ 	if (cred->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_early_cred - during initialization allocate a composite cred blob
+  * @cred: the cred that needs a blob
+  *
+  * Allocate the cred blob for all the modules
+  */
+ static void __init lsm_early_cred(struct cred *cred)
+ {
+ 	int rc = lsm_cred_alloc(cred, GFP_KERNEL);
+ 
+ 	if (rc)
+ 		panic("%s: Early cred alloc failed.\n", __func__);
+ }
+ 
+ /**
+  * lsm_file_alloc - allocate a composite file blob
+  * @file: the file that needs a blob
+  *
+  * Allocate the file blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ static int lsm_file_alloc(struct file *file)
+ {
+ 	if (!lsm_file_cache) {
+ 		file->f_security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	file->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);
+ 	if (file->f_security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_inode_alloc - allocate a composite inode blob
+  * @inode: the inode that needs a blob
+  *
+  * Allocate the inode blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_inode_alloc(struct inode *inode)
+ {
+ 	if (!lsm_inode_cache) {
+ 		inode->i_security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	inode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);
+ 	if (inode->i_security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_task_alloc - allocate a composite task blob
+  * @task: the task that needs a blob
+  *
+  * Allocate the task blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_task_alloc(struct task_struct *task)
+ {
+ 	if (blob_sizes.lbs_task == 0) {
+ 		task->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	task->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);
+ 	if (task->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_ipc_alloc - allocate a composite ipc blob
+  * @kip: the ipc that needs a blob
+  *
+  * Allocate the ipc blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_ipc_alloc(struct kern_ipc_perm *kip)
+ {
+ 	if (blob_sizes.lbs_ipc == 0) {
+ 		kip->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	kip->security = kzalloc(blob_sizes.lbs_ipc, GFP_KERNEL);
+ 	if (kip->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_msg_msg_alloc - allocate a composite msg_msg blob
+  * @mp: the msg_msg that needs a blob
+  *
+  * Allocate the ipc blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_msg_msg_alloc(struct msg_msg *mp)
+ {
+ 	if (blob_sizes.lbs_msg_msg == 0) {
+ 		mp->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	mp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);
+ 	if (mp->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_early_task - during initialization allocate a composite task blob
+  * @task: the task that needs a blob
+  *
+  * Allocate the task blob for all the modules
+  */
+ static void __init lsm_early_task(struct task_struct *task)
+ {
+ 	int rc = lsm_task_alloc(task);
+ 
+ 	if (rc)
+ 		panic("%s: Early task alloc failed.\n", __func__);
+ }
++>>>>>>> 1cfb2a512e74 (LSM: Make lsm_early_cred() and lsm_early_task() local functions.)
  
  /*
   * Hook list operation macros.
diff --cc security/selinux/hooks.c
index 02238a76d816,5d92167dbe05..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -214,12 -207,8 +214,16 @@@ static void cred_init_security(void
  	struct cred *cred = (struct cred *) current->real_cred;
  	struct task_security_struct *tsec;
  
++<<<<<<< HEAD
 +	tsec = kzalloc(sizeof(struct task_security_struct), GFP_KERNEL);
 +	if (!tsec)
 +		panic("SELinux:  Failed to initialize initial task.\n");
 +
++=======
+ 	tsec = selinux_cred(cred);
++>>>>>>> 1cfb2a512e74 (LSM: Make lsm_early_cred() and lsm_early_task() local functions.)
  	tsec->osid = tsec->sid = SECINITSID_KERNEL;
 +	cred->security = tsec;
  }
  
  /*
diff --cc security/smack/smack_lsm.c
index 922e3ab09003,79d6d2a6a0bc..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -4826,13 -4671,16 +4826,26 @@@ static __init int smack_init(void
  	if (!smack_inode_cache)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	tsp = new_task_smack(&smack_known_floor, &smack_known_floor,
 +				GFP_KERNEL);
 +	if (tsp == NULL) {
 +		kmem_cache_destroy(smack_inode_cache);
 +		return -ENOMEM;
 +	}
 +
++=======
+ 	/*
+ 	 * Set the security state for the initial task.
+ 	 */
+ 	tsp = smack_cred(cred);
+ 	init_task_smack(tsp, &smack_known_floor, &smack_known_floor);
+ 
+ 	/*
+ 	 * Register with LSM
+ 	 */
+ 	security_add_hooks(smack_hooks, ARRAY_SIZE(smack_hooks), "smack");
++>>>>>>> 1cfb2a512e74 (LSM: Make lsm_early_cred() and lsm_early_task() local functions.)
  	smack_enabled = 1;
  
  	pr_info("Smack:  Initializing.\n");
diff --cc security/tomoyo/tomoyo.c
index daff7d7897ad,2b3eee06004b..000000000000
--- a/security/tomoyo/tomoyo.c
+++ b/security/tomoyo/tomoyo.c
@@@ -543,8 -566,10 +543,13 @@@ static int __init tomoyo_init(void
  	/* register ourselves with the security framework */
  	security_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks), "tomoyo");
  	printk(KERN_INFO "TOMOYO Linux initialized\n");
++<<<<<<< HEAD
 +	cred->security = &tomoyo_kernel_domain;
++=======
+ 	blob = tomoyo_cred(cred);
+ 	*blob = &tomoyo_kernel_domain;
++>>>>>>> 1cfb2a512e74 (LSM: Make lsm_early_cred() and lsm_early_task() local functions.)
  	tomoyo_mm_init();
 -
  	return 0;
  }
  
* Unmerged path include/linux/lsm_hooks.h
* Unmerged path security/apparmor/lsm.c
* Unmerged path security/security.c
* Unmerged path security/selinux/hooks.c
* Unmerged path security/smack/smack_lsm.c
* Unmerged path security/tomoyo/tomoyo.c
