libbpf: Parse multi-function sections into multiple BPF programs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit c112239272c6bacf7fcd0a0dc71999ad8eb1c55c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/c1122392.failed

Teach libbpf how to parse code sections into potentially multiple bpf_program
instances, based on ELF FUNC symbols. Each BPF program will keep track of its
position within containing ELF section for translating section instruction
offsets into program instruction offsets: regardless of BPF program's location
in ELF section, it's first instruction is always at local instruction offset
0, so when libbpf is working with relocations (which use section-based
instruction offsets) this is critical to make proper translations.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/20200903203542.15944-3-andriin@fb.com
(cherry picked from commit c112239272c6bacf7fcd0a0dc71999ad8eb1c55c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index 133c0050e689,57f87eee5be5..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -436,6 -467,16 +464,19 @@@ struct bpf_object 
  };
  #define obj_elf_valid(o)	((o)->efile.elf)
  
++<<<<<<< HEAD
++=======
+ static const char *elf_sym_str(const struct bpf_object *obj, size_t off);
+ static const char *elf_sec_str(const struct bpf_object *obj, size_t off);
+ static Elf_Scn *elf_sec_by_idx(const struct bpf_object *obj, size_t idx);
+ static Elf_Scn *elf_sec_by_name(const struct bpf_object *obj, const char *name);
+ static int elf_sec_hdr(const struct bpf_object *obj, Elf_Scn *scn, GElf_Shdr *hdr);
+ static const char *elf_sec_name(const struct bpf_object *obj, Elf_Scn *scn);
+ static Elf_Data *elf_sec_data(const struct bpf_object *obj, Elf_Scn *scn);
+ static int elf_sym_by_sec_off(const struct bpf_object *obj, size_t sec_idx,
+ 			      size_t off, __u32 sym_type, GElf_Sym *sym);
+ 
++>>>>>>> c112239272c6 (libbpf: Parse multi-function sections into multiple BPF programs)
  void bpf_program__unload(struct bpf_program *prog)
  {
  	int i;
@@@ -497,14 -538,13 +538,18 @@@ static char *__bpf_program__pin_name(st
  }
  
  static int
++<<<<<<< HEAD
 +bpf_program__init(void *data, size_t size, char *section_name, int idx,
 +		  struct bpf_program *prog)
- {
- 	const size_t bpf_insn_sz = sizeof(struct bpf_insn);
- 
- 	if (size == 0 || size % bpf_insn_sz) {
- 		pr_warn("corrupted section '%s', size: %zu\n",
- 			section_name, size);
++=======
+ bpf_program__init(struct bpf_program *prog, const char *name,
+ 		  size_t sec_idx, const char *sec_name, size_t sec_off,
+ 		  void *insn_data, size_t insn_data_sz)
++>>>>>>> c112239272c6 (libbpf: Parse multi-function sections into multiple BPF programs)
+ {
+ 	if (insn_data_sz == 0 || insn_data_sz % BPF_INSN_SZ || sec_off % BPF_INSN_SZ) {
+ 		pr_warn("sec '%s': corrupted program '%s', offset %zu, size %zu\n",
+ 			sec_name, name, sec_off, insn_data_sz);
  		return -EINVAL;
  	}
  
@@@ -545,88 -585,71 +590,145 @@@ errout
  }
  
  static int
++<<<<<<< HEAD
 +bpf_object__add_program(struct bpf_object *obj, void *data, size_t size,
 +			char *section_name, int idx)
- {
- 	struct bpf_program prog, *progs;
++=======
+ bpf_object__add_programs(struct bpf_object *obj, Elf_Data *sec_data,
+ 			 const char *sec_name, int sec_idx)
++>>>>>>> c112239272c6 (libbpf: Parse multi-function sections into multiple BPF programs)
+ {
+ 	struct bpf_program *prog, *progs;
+ 	void *data = sec_data->d_buf;
+ 	size_t sec_sz = sec_data->d_size, sec_off, prog_sz;
  	int nr_progs, err;
- 
- 	err = bpf_program__init(data, size, section_name, idx, &prog);
- 	if (err)
- 		return err;
+ 	const char *name;
+ 	GElf_Sym sym;
  
  	progs = obj->programs;
  	nr_progs = obj->nr_programs;
+ 	sec_off = 0;
  
++<<<<<<< HEAD
 +	progs = libbpf_reallocarray(progs, nr_progs + 1, sizeof(progs[0]));
 +	if (!progs) {
 +		/*
 +		 * In this case the original obj->programs
 +		 * is still valid, so don't need special treat for
 +		 * bpf_close_object().
 +		 */
 +		pr_warn("failed to alloc a new program under section '%s'\n",
 +			section_name);
 +		bpf_program__exit(&prog);
 +		return -ENOMEM;
 +	}
 +
 +	pr_debug("found program %s\n", prog.section_name);
 +	obj->programs = progs;
 +	obj->nr_programs = nr_progs + 1;
 +	prog.obj = obj;
 +	progs[nr_progs] = prog;
 +	return 0;
 +}
 +
 +static int
 +bpf_object__init_prog_names(struct bpf_object *obj)
 +{
 +	Elf_Data *symbols = obj->efile.symbols;
 +	struct bpf_program *prog;
 +	size_t pi, si;
 +
 +	for (pi = 0; pi < obj->nr_programs; pi++) {
 +		const char *name = NULL;
 +
 +		prog = &obj->programs[pi];
 +
 +		for (si = 0; si < symbols->d_size / sizeof(GElf_Sym) && !name;
 +		     si++) {
 +			GElf_Sym sym;
 +
 +			if (!gelf_getsym(symbols, si, &sym))
 +				continue;
 +			if (sym.st_shndx != prog->idx)
 +				continue;
 +			if (GELF_ST_BIND(sym.st_info) != STB_GLOBAL)
 +				continue;
 +
 +			name = elf_strptr(obj->efile.elf,
 +					  obj->efile.strtabidx,
 +					  sym.st_name);
 +			if (!name) {
 +				pr_warn("failed to get sym name string for prog %s\n",
 +					prog->section_name);
 +				return -LIBBPF_ERRNO__LIBELF;
 +			}
++=======
+ 	while (sec_off < sec_sz) {
+ 		if (elf_sym_by_sec_off(obj, sec_idx, sec_off, STT_FUNC, &sym)) {
+ 			pr_warn("sec '%s': failed to find program symbol at offset %zu\n",
+ 				sec_name, sec_off);
+ 			return -LIBBPF_ERRNO__FORMAT;
++>>>>>>> c112239272c6 (libbpf: Parse multi-function sections into multiple BPF programs)
  		}
  
- 		if (!name && prog->idx == obj->efile.text_shndx)
- 			name = ".text";
+ 		prog_sz = sym.st_size;
  
+ 		name = elf_sym_str(obj, sym.st_name);
  		if (!name) {
++<<<<<<< HEAD
 +			pr_warn("failed to find sym for prog %s\n",
 +				prog->section_name);
 +			return -EINVAL;
 +		}
 +
 +		prog->name = strdup(name);
 +		if (!prog->name) {
 +			pr_warn("failed to allocate memory for prog sym %s\n",
 +				name);
 +			return -ENOMEM;
 +		}
++=======
+ 			pr_warn("sec '%s': failed to get symbol name for offset %zu\n",
+ 				sec_name, sec_off);
+ 			return -LIBBPF_ERRNO__FORMAT;
+ 		}
+ 
+ 		if (sec_off + prog_sz > sec_sz) {
+ 			pr_warn("sec '%s': program at offset %zu crosses section boundary\n",
+ 				sec_name, sec_off);
+ 			return -LIBBPF_ERRNO__FORMAT;
+ 		}
+ 
+ 		pr_debug("sec '%s': found program '%s' at offset %zu, code size %zu bytes\n",
+ 			 sec_name, name, sec_off, prog_sz);
+ 
+ 		progs = reallocarray(progs, nr_progs + 1, sizeof(*progs));
+ 		if (!progs) {
+ 			/*
+ 			 * In this case the original obj->programs
+ 			 * is still valid, so don't need special treat for
+ 			 * bpf_close_object().
+ 			 */
+ 			pr_warn("sec '%s': failed to alloc memory for new program '%s'\n",
+ 				sec_name, name);
+ 			return -ENOMEM;
+ 		}
+ 		obj->programs = progs;
+ 
+ 		prog = &progs[nr_progs];
+ 		memset(prog, 0, sizeof(*prog));
+ 		prog->obj = obj;
+ 
+ 		err = bpf_program__init(prog, name, sec_idx, sec_name, sec_off,
+ 					data + sec_off, prog_sz);
+ 		if (err)
+ 			return err;
+ 
+ 		nr_progs++;
+ 		obj->nr_programs = nr_progs;
+ 
+ 		sec_off += prog_sz;
++>>>>>>> c112239272c6 (libbpf: Parse multi-function sections into multiple BPF programs)
  	}
  
  	return 0;
@@@ -2595,6 -2580,179 +2697,182 @@@ report
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static const char *elf_sym_str(const struct bpf_object *obj, size_t off)
+ {
+ 	const char *name;
+ 
+ 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
+ 	if (!name) {
+ 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
+ 			off, obj->path, elf_errmsg(-1));
+ 		return NULL;
+ 	}
+ 
+ 	return name;
+ }
+ 
+ static const char *elf_sec_str(const struct bpf_object *obj, size_t off)
+ {
+ 	const char *name;
+ 
+ 	name = elf_strptr(obj->efile.elf, obj->efile.shstrndx, off);
+ 	if (!name) {
+ 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
+ 			off, obj->path, elf_errmsg(-1));
+ 		return NULL;
+ 	}
+ 
+ 	return name;
+ }
+ 
+ static Elf_Scn *elf_sec_by_idx(const struct bpf_object *obj, size_t idx)
+ {
+ 	Elf_Scn *scn;
+ 
+ 	scn = elf_getscn(obj->efile.elf, idx);
+ 	if (!scn) {
+ 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
+ 			idx, obj->path, elf_errmsg(-1));
+ 		return NULL;
+ 	}
+ 	return scn;
+ }
+ 
+ static Elf_Scn *elf_sec_by_name(const struct bpf_object *obj, const char *name)
+ {
+ 	Elf_Scn *scn = NULL;
+ 	Elf *elf = obj->efile.elf;
+ 	const char *sec_name;
+ 
+ 	while ((scn = elf_nextscn(elf, scn)) != NULL) {
+ 		sec_name = elf_sec_name(obj, scn);
+ 		if (!sec_name)
+ 			return NULL;
+ 
+ 		if (strcmp(sec_name, name) != 0)
+ 			continue;
+ 
+ 		return scn;
+ 	}
+ 	return NULL;
+ }
+ 
+ static int elf_sec_hdr(const struct bpf_object *obj, Elf_Scn *scn, GElf_Shdr *hdr)
+ {
+ 	if (!scn)
+ 		return -EINVAL;
+ 
+ 	if (gelf_getshdr(scn, hdr) != hdr) {
+ 		pr_warn("elf: failed to get section(%zu) header from %s: %s\n",
+ 			elf_ndxscn(scn), obj->path, elf_errmsg(-1));
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const char *elf_sec_name(const struct bpf_object *obj, Elf_Scn *scn)
+ {
+ 	const char *name;
+ 	GElf_Shdr sh;
+ 
+ 	if (!scn)
+ 		return NULL;
+ 
+ 	if (elf_sec_hdr(obj, scn, &sh))
+ 		return NULL;
+ 
+ 	name = elf_sec_str(obj, sh.sh_name);
+ 	if (!name) {
+ 		pr_warn("elf: failed to get section(%zu) name from %s: %s\n",
+ 			elf_ndxscn(scn), obj->path, elf_errmsg(-1));
+ 		return NULL;
+ 	}
+ 
+ 	return name;
+ }
+ 
+ static Elf_Data *elf_sec_data(const struct bpf_object *obj, Elf_Scn *scn)
+ {
+ 	Elf_Data *data;
+ 
+ 	if (!scn)
+ 		return NULL;
+ 
+ 	data = elf_getdata(scn, 0);
+ 	if (!data) {
+ 		pr_warn("elf: failed to get section(%zu) %s data from %s: %s\n",
+ 			elf_ndxscn(scn), elf_sec_name(obj, scn) ?: "<?>",
+ 			obj->path, elf_errmsg(-1));
+ 		return NULL;
+ 	}
+ 
+ 	return data;
+ }
+ 
+ static int elf_sym_by_sec_off(const struct bpf_object *obj, size_t sec_idx,
+ 			      size_t off, __u32 sym_type, GElf_Sym *sym)
+ {
+ 	Elf_Data *symbols = obj->efile.symbols;
+ 	size_t n = symbols->d_size / sizeof(GElf_Sym);
+ 	int i;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		if (!gelf_getsym(symbols, i, sym))
+ 			continue;
+ 		if (sym->st_shndx != sec_idx || sym->st_value != off)
+ 			continue;
+ 		if (GELF_ST_TYPE(sym->st_info) != sym_type)
+ 			continue;
+ 		return 0;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static bool is_sec_name_dwarf(const char *name)
+ {
+ 	/* approximation, but the actual list is too long */
+ 	return strncmp(name, ".debug_", sizeof(".debug_") - 1) == 0;
+ }
+ 
+ static bool ignore_elf_section(GElf_Shdr *hdr, const char *name)
+ {
+ 	/* no special handling of .strtab */
+ 	if (hdr->sh_type == SHT_STRTAB)
+ 		return true;
+ 
+ 	/* ignore .llvm_addrsig section as well */
+ 	if (hdr->sh_type == 0x6FFF4C03 /* SHT_LLVM_ADDRSIG */)
+ 		return true;
+ 
+ 	/* no subprograms will lead to an empty .text section, ignore it */
+ 	if (hdr->sh_type == SHT_PROGBITS && hdr->sh_size == 0 &&
+ 	    strcmp(name, ".text") == 0)
+ 		return true;
+ 
+ 	/* DWARF sections */
+ 	if (is_sec_name_dwarf(name))
+ 		return true;
+ 
+ 	if (strncmp(name, ".rel", sizeof(".rel") - 1) == 0) {
+ 		name += sizeof(".rel") - 1;
+ 		/* DWARF section relocations */
+ 		if (is_sec_name_dwarf(name))
+ 			return true;
+ 
+ 		/* .BTF and .BTF.ext don't need relocations */
+ 		if (strcmp(name, BTF_ELF_SEC) == 0 ||
+ 		    strcmp(name, BTF_EXT_ELF_SEC) == 0)
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
++>>>>>>> c112239272c6 (libbpf: Parse multi-function sections into multiple BPF programs)
  static int bpf_object__elf_collect(struct bpf_object *obj)
  {
  	Elf *elf = obj->efile.elf;
@@@ -2673,19 -2833,9 +2951,24 @@@
  			if (sh.sh_flags & SHF_EXECINSTR) {
  				if (strcmp(name, ".text") == 0)
  					obj->efile.text_shndx = idx;
++<<<<<<< HEAD
 +				err = bpf_object__add_program(obj, data->d_buf,
 +							      data->d_size,
 +							      name, idx);
 +				if (err) {
 +					char errmsg[STRERR_BUFSIZE];
 +					char *cp;
 +
 +					cp = libbpf_strerror_r(-err, errmsg,
 +							       sizeof(errmsg));
 +					pr_warn("failed to alloc program %s (%s): %s",
 +						name, obj->path, cp);
++=======
+ 				err = bpf_object__add_programs(obj, data, name, idx);
+ 				if (err)
++>>>>>>> c112239272c6 (libbpf: Parse multi-function sections into multiple BPF programs)
  					return err;
 +				}
  			} else if (strcmp(name, DATA_SEC) == 0) {
  				obj->efile.data = data;
  				obj->efile.data_shndx = idx;
* Unmerged path tools/lib/bpf/libbpf.c
