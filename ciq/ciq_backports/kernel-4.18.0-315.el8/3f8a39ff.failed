mac80211: support driver-based disconnect with reconnect hint

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 3f8a39ff28078e4b56d94e8676f49d9975f82e51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/3f8a39ff.failed

Support the driver indicating that a disconnection needs
to be performed, and pass through the reconnect hint in
this case.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Link: https://lore.kernel.org/r/iwlwifi.20201206145305.5c8dab7a22a0.I58459fdf6968b16c90cab9c574f0f04ca22b0c79@changeid
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 3f8a39ff28078e4b56d94e8676f49d9975f82e51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/mlme.c
diff --cc net/mac80211/mlme.c
index d4da9822a111,3e124eee91d4..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -2741,7 -2741,7 +2741,11 @@@ static void ieee80211_report_disconnect
  	};
  
  	if (tx)
++<<<<<<< HEAD
 +		cfg80211_tx_mlme_mgmt(sdata->dev, buf, len);
++=======
+ 		cfg80211_tx_mlme_mgmt(sdata->dev, buf, len, reconnect);
++>>>>>>> 3f8a39ff2807 (mac80211: support driver-based disconnect with reconnect hint)
  	else
  		cfg80211_rx_mlme_mgmt(sdata->dev, buf, len);
  
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 1c0d3847f9fc..1e49070e7015 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -5899,6 +5899,17 @@ void ieee80211_beacon_loss(struct ieee80211_vif *vif);
  */
 void ieee80211_connection_loss(struct ieee80211_vif *vif);
 
+/**
+ * ieee80211_disconnect - request disconnection
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @reconnect: immediate reconnect is desired
+ *
+ * Request disconnection from the current network and, if enabled, send a
+ * hint to the higher layers that immediate reconnect is desired.
+ */
+void ieee80211_disconnect(struct ieee80211_vif *vif, bool reconnect);
+
 /**
  * ieee80211_resume_disconnect - disconnect from AP after resume
  *
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 2a21226fb518..aee42fb7c3e5 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -457,7 +457,9 @@ struct ieee80211_if_managed {
 	unsigned long probe_timeout;
 	int probe_send_count;
 	bool nullfunc_failed;
-	bool connection_loss;
+	u8 connection_loss:1,
+	   driver_disconnect:1,
+	   reconnect:1;
 
 	struct cfg80211_bss *associated;
 	struct ieee80211_mgd_auth_data *auth_data;
* Unmerged path net/mac80211/mlme.c
diff --git a/net/mac80211/trace.h b/net/mac80211/trace.h
index 7d3304ee7b74..bb2ff1df9451 100644
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -2,7 +2,7 @@
 /*
 * Portions of this file
 * Copyright(c) 2016-2017 Intel Deutschland GmbH
-* Copyright (C) 2018 - 2019 Intel Corporation
+* Copyright (C) 2018 - 2020 Intel Corporation
 */
 
 #if !defined(__MAC80211_DRIVER_TRACE) || defined(TRACE_HEADER_MULTI_READ)
@@ -2086,6 +2086,27 @@ TRACE_EVENT(api_connection_loss,
 	)
 );
 
+TRACE_EVENT(api_disconnect,
+	TP_PROTO(struct ieee80211_sub_if_data *sdata, bool reconnect),
+
+	TP_ARGS(sdata, reconnect),
+
+	TP_STRUCT__entry(
+		VIF_ENTRY
+		__field(int, reconnect)
+	),
+
+	TP_fast_assign(
+		VIF_ASSIGN;
+		__entry->reconnect = reconnect;
+	),
+
+	TP_printk(
+		VIF_PR_FMT " reconnect:%d",
+		VIF_PR_ARG, __entry->reconnect
+	)
+);
+
 TRACE_EVENT(api_cqm_rssi_notify,
 	TP_PROTO(struct ieee80211_sub_if_data *sdata,
 		 enum nl80211_cqm_rssi_threshold_event rssi_event,
