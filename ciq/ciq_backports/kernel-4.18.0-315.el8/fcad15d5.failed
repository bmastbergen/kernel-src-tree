mt76: mt7921: introduce mt7921_wpdma_reset utility routine

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit fcad15d52ef52002e069ed9a091a0c0a54691c27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/fcad15d5.failed

Introduce mt7921_wpdma_reset routine to reset wpdma during chip reset
or driver_own request.

	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit fcad15d52ef52002e069ed9a091a0c0a54691c27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7921/dma.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/dma.c
index cd9665610284,af4b6cf38929..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/dma.c
@@@ -206,6 -229,119 +206,122 @@@ static int mt7921_dmashdl_disabled(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int mt7921_dma_reset(struct mt7921_dev *dev, bool force)
+ {
+ 	int i;
+ 
+ 	if (force) {
+ 		/* reset */
+ 		mt76_clear(dev, MT_WFDMA0_RST,
+ 			   MT_WFDMA0_RST_DMASHDL_ALL_RST |
+ 			   MT_WFDMA0_RST_LOGIC_RST);
+ 
+ 		mt76_set(dev, MT_WFDMA0_RST,
+ 			 MT_WFDMA0_RST_DMASHDL_ALL_RST |
+ 			 MT_WFDMA0_RST_LOGIC_RST);
+ 	}
+ 
+ 	/* disable WFDMA0 */
+ 	mt76_clear(dev, MT_WFDMA0_GLO_CFG,
+ 		   MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN |
+ 		   MT_WFDMA0_GLO_CFG_CSR_DISP_BASE_PTR_CHAIN_EN |
+ 		   MT_WFDMA0_GLO_CFG_OMIT_TX_INFO |
+ 		   MT_WFDMA0_GLO_CFG_OMIT_RX_INFO |
+ 		   MT_WFDMA0_GLO_CFG_OMIT_RX_INFO_PFET2);
+ 
+ 	if (!mt76_poll(dev, MT_WFDMA0_GLO_CFG,
+ 		       MT_WFDMA0_GLO_CFG_TX_DMA_BUSY |
+ 		       MT_WFDMA0_GLO_CFG_RX_DMA_BUSY, 0, 1000))
+ 		return -ETIMEDOUT;
+ 
+ 	/* reset hw queues */
+ 	for (i = 0; i < __MT_TXQ_MAX; i++)
+ 		mt76_queue_reset(dev, dev->mphy.q_tx[i]);
+ 
+ 	for (i = 0; i < __MT_MCUQ_MAX; i++)
+ 		mt76_queue_reset(dev, dev->mt76.q_mcu[i]);
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i)
+ 		mt76_queue_reset(dev, &dev->mt76.q_rx[i]);
+ 
+ 	mt76_tx_status_check(&dev->mt76, NULL, true);
+ 
+ 	/* configure perfetch settings */
+ 	mt7921_dma_prefetch(dev);
+ 
+ 	/* reset dma idx */
+ 	mt76_wr(dev, MT_WFDMA0_RST_DTX_PTR, ~0);
+ 
+ 	/* configure delay interrupt */
+ 	mt76_wr(dev, MT_WFDMA0_PRI_DLY_INT_CFG0, 0);
+ 
+ 	mt76_set(dev, MT_WFDMA0_GLO_CFG,
+ 		 MT_WFDMA0_GLO_CFG_TX_WB_DDONE |
+ 		 MT_WFDMA0_GLO_CFG_FIFO_LITTLE_ENDIAN |
+ 		 MT_WFDMA0_GLO_CFG_CLK_GAT_DIS |
+ 		 MT_WFDMA0_GLO_CFG_OMIT_TX_INFO |
+ 		 MT_WFDMA0_GLO_CFG_CSR_DISP_BASE_PTR_CHAIN_EN |
+ 		 MT_WFDMA0_GLO_CFG_OMIT_RX_INFO_PFET2);
+ 
+ 	mt76_set(dev, MT_WFDMA0_GLO_CFG,
+ 		 MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN);
+ 
+ 	mt76_set(dev, MT_WFDMA_DUMMY_CR, MT_WFDMA_NEED_REINIT);
+ 
+ 	/* enable interrupts for TX/RX rings */
+ 	mt7921_irq_enable(dev,
+ 			  MT_INT_RX_DONE_ALL | MT_INT_TX_DONE_ALL |
+ 			  MT_INT_MCU_CMD);
+ 	mt76_set(dev, MT_MCU2HOST_SW_INT_ENA, MT_MCU_CMD_WAKE_RX_PCIE);
+ 
+ 	return 0;
+ }
+ 
+ int mt7921_wfsys_reset(struct mt7921_dev *dev)
+ {
+ 	mt76_set(dev, 0x70002600, BIT(0));
+ 	msleep(200);
+ 	mt76_clear(dev, 0x70002600, BIT(0));
+ 
+ 	if (!__mt76_poll_msec(&dev->mt76, MT_WFSYS_SW_RST_B,
+ 			      WFSYS_SW_INIT_DONE, WFSYS_SW_INIT_DONE, 500))
+ 		return -ETIMEDOUT;
+ 
+ 	return 0;
+ }
+ 
+ int mt7921_wpdma_reset(struct mt7921_dev *dev, bool force)
+ {
+ 	int i, err;
+ 
+ 	/* clean up hw queues */
+ 	for (i = 0; i < ARRAY_SIZE(dev->mt76.phy.q_tx); i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dev->mt76.q_mcu); i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i)
+ 		mt76_queue_rx_cleanup(dev, &dev->mt76.q_rx[i]);
+ 
+ 	if (force) {
+ 		err = mt7921_wfsys_reset(dev);
+ 		if (err)
+ 			return err;
+ 	}
+ 	err = mt7921_dma_reset(dev, force);
+ 	if (err)
+ 		return err;
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i)
+ 		mt76_queue_rx_reset(dev, i);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> fcad15d52ef5 (mt76: mt7921: introduce mt7921_wpdma_reset utility routine)
  int mt7921_dma_init(struct mt7921_dev *dev)
  {
  	/* Increase buffer size to receive large VHT/HE MPDUs */
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index bcbd59a23f9b,f1efe9eaf791..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@@ -1162,47 -1197,13 +1162,50 @@@ void mt7921_update_channel(struct mt76_
  	mt7921_phy_update_channel(&mdev->phy, 0);
  	/* reset obss airtime */
  	mt76_set(dev, MT_WF_RMAC_MIB_TIME0(0), MT_WF_RMAC_MIB_RXTIME_CLR);
 +}
  
 -	mt76_connac_power_save_sched(&dev->mphy, &dev->pm);
++<<<<<<< HEAD
 +static bool
 +mt7921_wait_reset_state(struct mt7921_dev *dev, u32 state)
 +{
 +	bool ret;
 +
 +	ret = wait_event_timeout(dev->reset_wait,
 +				 (READ_ONCE(dev->reset_state) & state),
 +				 MT7921_RESET_TIMEOUT);
 +
 +	WARN(!ret, "Timeout waiting for MCU reset state %x\n", state);
 +	return ret;
 +}
 +
 +static void
 +mt7921_dma_reset(struct mt7921_phy *phy)
 +{
 +	struct mt7921_dev *dev = phy->dev;
 +	int i;
 +
 +	mt76_clear(dev, MT_WFDMA0_GLO_CFG,
 +		   MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN);
 +
 +	usleep_range(1000, 2000);
 +
 +	mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WA], true);
 +	for (i = 0; i < __MT_TXQ_MAX; i++)
 +		mt76_queue_tx_cleanup(dev, phy->mt76->q_tx[i], true);
 +
 +	mt76_for_each_q_rx(&dev->mt76, i) {
 +		mt76_queue_rx_reset(dev, i);
 +	}
 +
 +	/* re-init prefetch settings after reset */
 +	mt7921_dma_prefetch(dev);
 +
 +	mt76_set(dev, MT_WFDMA0_GLO_CFG,
 +		 MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN);
  }
  
++=======
++>>>>>>> fcad15d52ef5 (mt76: mt7921: introduce mt7921_wpdma_reset utility routine)
  void mt7921_tx_token_put(struct mt7921_dev *dev)
  {
  	struct mt76_txwi_cache *txwi;
@@@ -1257,38 -1263,83 +1260,53 @@@ void mt7921_mac_reset_work(struct work_
  	mt7921_tx_token_put(dev);
  	idr_init(&dev->token);
  
++<<<<<<< HEAD
 +	if (mt7921_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
 +		mt7921_dma_reset(&dev->phy);
 +
 +		mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);
 +		mt7921_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
++=======
+ 	err = mt7921_wpdma_reset(dev, true);
+ 	if (err)
+ 		return err;
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i) {
+ 		napi_enable(&dev->mt76.napi[i]);
+ 		napi_schedule(&dev->mt76.napi[i]);
++>>>>>>> fcad15d52ef5 (mt76: mt7921: introduce mt7921_wpdma_reset utility routine)
  	}
  
 -	napi_enable(&dev->mt76.tx_napi);
 -	napi_schedule(&dev->mt76.tx_napi);
 -	mt76_worker_enable(&dev->mt76.tx_worker);
 -
  	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
 -	clear_bit(MT76_STATE_PM, &dev->mphy.state);
 +	clear_bit(MT76_RESET, &dev->mphy.state);
  
++<<<<<<< HEAD
 +	mt76_worker_enable(&dev->mt76.tx_worker);
 +	napi_enable(&dev->mt76.tx_napi);
 +	napi_schedule(&dev->mt76.tx_napi);
++=======
+ 	mt76_wr(dev, MT_WFDMA0_HOST_INT_ENA, 0);
+ 	mt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);
++>>>>>>> fcad15d52ef5 (mt76: mt7921: introduce mt7921_wpdma_reset utility routine)
  
 -	err = mt7921_run_firmware(dev);
 -	if (err)
 -		return err;
 -
 -	err = mt7921_mcu_set_eeprom(dev);
 -	if (err)
 -		return err;
 +	napi_enable(&dev->mt76.napi[0]);
 +	napi_schedule(&dev->mt76.napi[0]);
  
 -	mt7921_mac_init(dev);
 -	return __mt7921_start(&dev->phy);
 -}
 +	napi_enable(&dev->mt76.napi[1]);
 +	napi_schedule(&dev->mt76.napi[1]);
  
 -/* system error recovery */
 -void mt7921_mac_reset_work(struct work_struct *work)
 -{
 -	struct ieee80211_hw *hw;
 -	struct mt7921_dev *dev;
 -	int i;
 +	napi_enable(&dev->mt76.napi[2]);
 +	napi_schedule(&dev->mt76.napi[2]);
  
 -	dev = container_of(work, struct mt7921_dev, reset_work);
 -	hw = mt76_hw(dev);
 -
 -	dev_err(dev->mt76.dev, "chip reset\n");
 -	ieee80211_stop_queues(hw);
 +	ieee80211_wake_queues(mt76_hw(dev));
  
 -	cancel_delayed_work_sync(&dev->mphy.mac_work);
 -	cancel_delayed_work_sync(&dev->pm.ps_work);
 -	cancel_work_sync(&dev->pm.wake_work);
 +	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_RESET_DONE);
 +	mt7921_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);
  
 -	mutex_lock(&dev->mt76.mutex);
 -	for (i = 0; i < 10; i++) {
 -		if (!mt7921_mac_reset(dev))
 -			break;
 -	}
  	mutex_unlock(&dev->mt76.mutex);
  
 -	if (i == 10)
 -		dev_err(dev->mt76.dev, "chip reset failed\n");
 -
 -	if (test_and_clear_bit(MT76_HW_SCANNING, &dev->mphy.state)) {
 -		struct cfg80211_scan_info info = {
 -			.aborted = true,
 -		};
 -
 -		ieee80211_scan_completed(dev->mphy.hw, &info);
 -	}
 -
 -	ieee80211_wake_queues(hw);
 -	ieee80211_iterate_active_interfaces(hw,
 -					    IEEE80211_IFACE_ITER_RESUME_ALL,
 -					    mt7921_vif_connect_iter, NULL);
 -}
 -
 -void mt7921_reset(struct mt76_dev *mdev)
 -{
 -	struct mt7921_dev *dev = container_of(mdev, struct mt7921_dev, mt76);
 -
 -	queue_work(dev->mt76.wq, &dev->reset_work);
 +	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
 +				     MT7921_WATCHDOG_TIME);
  }
  
  static void
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index 6e3579d48c30,67a2571aa470..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@@ -225,7 -253,7 +225,11 @@@ int mt7921_eeprom_get_target_power(stru
  				   u8 chain_idx);
  void mt7921_eeprom_init_sku(struct mt7921_dev *dev);
  int mt7921_dma_init(struct mt7921_dev *dev);
++<<<<<<< HEAD
 +void mt7921_dma_prefetch(struct mt7921_dev *dev);
++=======
+ int mt7921_wpdma_reset(struct mt7921_dev *dev, bool force);
++>>>>>>> fcad15d52ef5 (mt76: mt7921: introduce mt7921_wpdma_reset utility routine)
  void mt7921_dma_cleanup(struct mt7921_dev *dev);
  int mt7921_run_firmware(struct mt7921_dev *dev);
  int mt7921_mcu_init(struct mt7921_dev *dev);
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/dma.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mac.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
