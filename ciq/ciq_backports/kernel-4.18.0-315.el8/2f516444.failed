wireless: fix spelling of A-MSDU in HE capabilities

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 2f5164447cdab6419edddde3a214f93a53aa4e60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/2f516444.failed

In the HE capabilities, spell A-MSDU correctly, not "A-MDSU".

	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Link: https://lore.kernel.org/r/iwlwifi.20210409123755.9e6ff1af1181.If6868bc6902ccd9a95c74c78f716c4b41473ef14@changeid
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 2f5164447cdab6419edddde3a214f93a53aa4e60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
diff --cc drivers/net/wireless/mac80211_hwsim.c
index 44349b59bf72,51ce767eaf88..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -2715,6 -2776,235 +2715,238 @@@ out_err
  	nlmsg_free(mcast_skb);
  }
  
++<<<<<<< HEAD
++=======
+ static const struct ieee80211_sband_iftype_data he_capa_2ghz[] = {
+ 	{
+ 		/* TODO: should we support other types, e.g., P2P?*/
+ 		.types_mask = BIT(NL80211_IFTYPE_STATION) |
+ 			      BIT(NL80211_IFTYPE_AP),
+ 		.he_cap = {
+ 			.has_he = true,
+ 			.he_cap_elem = {
+ 				.mac_cap_info[0] =
+ 					IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 				.mac_cap_info[1] =
+ 					IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 				.mac_cap_info[2] =
+ 					IEEE80211_HE_MAC_CAP2_BSR |
+ 					IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 					IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 				.mac_cap_info[3] =
+ 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,
+ 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
+ 				.phy_cap_info[1] =
+ 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 					IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 				.phy_cap_info[2] =
+ 					IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 					IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 					IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 					IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 					IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 				/* Leave all the other PHY capability bytes
+ 				 * unset, as DCM, beam forming, RU and PPE
+ 				 * threshold information are not supported
+ 				 */
+ 			},
+ 			.he_mcs_nss_supp = {
+ 				.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_160 = cpu_to_le16(0xffff),
+ 				.tx_mcs_160 = cpu_to_le16(0xffff),
+ 				.rx_mcs_80p80 = cpu_to_le16(0xffff),
+ 				.tx_mcs_80p80 = cpu_to_le16(0xffff),
+ 			},
+ 		},
+ 	},
+ #ifdef CONFIG_MAC80211_MESH
+ 	{
+ 		/* TODO: should we support other types, e.g., IBSS?*/
+ 		.types_mask = BIT(NL80211_IFTYPE_MESH_POINT),
+ 		.he_cap = {
+ 			.has_he = true,
+ 			.he_cap_elem = {
+ 				.mac_cap_info[0] =
+ 					IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 				.mac_cap_info[1] =
+ 					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 				.mac_cap_info[2] =
+ 					IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 				.mac_cap_info[3] =
+ 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,
+ 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
+ 				.phy_cap_info[1] =
+ 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 					IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 				.phy_cap_info[2] = 0,
+ 
+ 				/* Leave all the other PHY capability bytes
+ 				 * unset, as DCM, beam forming, RU and PPE
+ 				 * threshold information are not supported
+ 				 */
+ 			},
+ 			.he_mcs_nss_supp = {
+ 				.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_160 = cpu_to_le16(0xffff),
+ 				.tx_mcs_160 = cpu_to_le16(0xffff),
+ 				.rx_mcs_80p80 = cpu_to_le16(0xffff),
+ 				.tx_mcs_80p80 = cpu_to_le16(0xffff),
+ 			},
+ 		},
+ 	},
+ #endif
+ };
+ 
+ static const struct ieee80211_sband_iftype_data he_capa_5ghz[] = {
+ 	{
+ 		/* TODO: should we support other types, e.g., P2P?*/
+ 		.types_mask = BIT(NL80211_IFTYPE_STATION) |
+ 			      BIT(NL80211_IFTYPE_AP),
+ 		.he_cap = {
+ 			.has_he = true,
+ 			.he_cap_elem = {
+ 				.mac_cap_info[0] =
+ 					IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 				.mac_cap_info[1] =
+ 					IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 				.mac_cap_info[2] =
+ 					IEEE80211_HE_MAC_CAP2_BSR |
+ 					IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 					IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 				.mac_cap_info[3] =
+ 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,
+ 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
+ 				.phy_cap_info[0] =
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,
+ 				.phy_cap_info[1] =
+ 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 					IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 				.phy_cap_info[2] =
+ 					IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 					IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 					IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 					IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 					IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 				/* Leave all the other PHY capability bytes
+ 				 * unset, as DCM, beam forming, RU and PPE
+ 				 * threshold information are not supported
+ 				 */
+ 			},
+ 			.he_mcs_nss_supp = {
+ 				.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_160 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_160 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 			},
+ 		},
+ 	},
+ #ifdef CONFIG_MAC80211_MESH
+ 	{
+ 		/* TODO: should we support other types, e.g., IBSS?*/
+ 		.types_mask = BIT(NL80211_IFTYPE_MESH_POINT),
+ 		.he_cap = {
+ 			.has_he = true,
+ 			.he_cap_elem = {
+ 				.mac_cap_info[0] =
+ 					IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 				.mac_cap_info[1] =
+ 					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 				.mac_cap_info[2] =
+ 					IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 				.mac_cap_info[3] =
+ 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,
+ 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
+ 				.phy_cap_info[0] =
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,
+ 				.phy_cap_info[1] =
+ 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 					IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 				.phy_cap_info[2] = 0,
+ 
+ 				/* Leave all the other PHY capability bytes
+ 				 * unset, as DCM, beam forming, RU and PPE
+ 				 * threshold information are not supported
+ 				 */
+ 			},
+ 			.he_mcs_nss_supp = {
+ 				.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_160 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_160 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 			},
+ 		},
+ 	},
+ #endif
+ };
+ 
+ static void mac80211_hwsim_he_capab(struct ieee80211_supported_band *sband)
+ {
+ 	u16 n_iftype_data;
+ 
+ 	if (sband->band == NL80211_BAND_2GHZ) {
+ 		n_iftype_data = ARRAY_SIZE(he_capa_2ghz);
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)he_capa_2ghz;
+ 	} else if (sband->band == NL80211_BAND_5GHZ) {
+ 		n_iftype_data = ARRAY_SIZE(he_capa_5ghz);
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)he_capa_5ghz;
+ 	} else {
+ 		return;
+ 	}
+ 
+ 	sband->n_iftype_data = n_iftype_data;
+ }
+ 
+ #ifdef CONFIG_MAC80211_MESH
+ #define HWSIM_MESH_BIT BIT(NL80211_IFTYPE_MESH_POINT)
+ #else
+ #define HWSIM_MESH_BIT 0
+ #endif
+ 
+ #define HWSIM_DEFAULT_IF_LIMIT \
+ 	(BIT(NL80211_IFTYPE_STATION) | \
+ 	 BIT(NL80211_IFTYPE_P2P_CLIENT) | \
+ 	 BIT(NL80211_IFTYPE_AP) | \
+ 	 BIT(NL80211_IFTYPE_P2P_GO) | \
+ 	 HWSIM_MESH_BIT)
+ 
+ #define HWSIM_IFTYPE_SUPPORT_MASK \
+ 	(BIT(NL80211_IFTYPE_STATION) | \
+ 	 BIT(NL80211_IFTYPE_AP) | \
+ 	 BIT(NL80211_IFTYPE_P2P_CLIENT) | \
+ 	 BIT(NL80211_IFTYPE_P2P_GO) | \
+ 	 BIT(NL80211_IFTYPE_ADHOC) | \
+ 	 BIT(NL80211_IFTYPE_MESH_POINT) | \
+ 	 BIT(NL80211_IFTYPE_OCB))
+ 
++>>>>>>> 2f5164447cda (wireless: fix spelling of A-MSDU in HE capabilities)
  static int mac80211_hwsim_new_radio(struct genl_info *info,
  				    struct hwsim_new_radio_params *param)
  {
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
index c5a1e84dc1ab..b514875565ca 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
@@ -552,7 +552,7 @@ static const struct ieee80211_sband_iftype_data iwl_he_capa[] = {
 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
 				.mac_cap_info[4] =
-					IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU |
+					IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU |
 					IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
 				.mac_cap_info[5] =
 					IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B40 |
@@ -638,7 +638,7 @@ static const struct ieee80211_sband_iftype_data iwl_he_capa[] = {
 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
 				.mac_cap_info[4] =
-					IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+					IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
 				.mac_cap_info[5] =
 					IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU,
 				.phy_cap_info[0] =
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/init.c b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
index 49c09d0d8906..75d004964d91 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
@@ -420,7 +420,7 @@ mt7915_init_he_caps(struct mt7915_phy *phy, enum nl80211_band band,
 			IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
 			IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_RESERVED;
 		he_cap_elem->mac_cap_info[4] =
-			IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU;
+			IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU;
 
 		if (band == NL80211_BAND_2GHZ)
 			he_cap_elem->phy_cap_info[0] =
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
index ba80c55cb820..eb2f27be55b1 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
@@ -1352,7 +1352,7 @@ mt7915_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
 	if (elem->mac_cap_info[3] & IEEE80211_HE_MAC_CAP3_OMI_CONTROL)
 		cap |= STA_REC_HE_CAP_OM;
 
-	if (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU)
+	if (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU)
 		cap |= STA_REC_HE_CAP_AMSDU_IN_AMPDU;
 
 	if (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_BQR)
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/main.c b/drivers/net/wireless/mediatek/mt76/mt7921/main.c
index c3e38909c927..37abc5ec514c 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/main.c
@@ -67,7 +67,7 @@ mt7921_init_he_caps(struct mt7921_phy *phy, enum nl80211_band band,
 			IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
 			IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_RESERVED;
 		he_cap_elem->mac_cap_info[4] =
-			IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU;
+			IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU;
 
 		if (band == NL80211_BAND_2GHZ)
 			he_cap_elem->phy_cap_info[0] =
diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h
index 2b9103994857..a37e891c3389 100644
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -2026,7 +2026,7 @@ int ieee80211_get_vht_max_nss(struct ieee80211_vht_cap *cap,
 #define IEEE80211_HE_MAC_CAP4_SRP_RESP				0x08
 #define IEEE80211_HE_MAC_CAP4_NDP_FB_REP			0x10
 #define IEEE80211_HE_MAC_CAP4_OPS				0x20
-#define IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU			0x40
+#define IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU			0x40
 /* Multi TID agg TX is split between byte #4 and #5
  * The value is a combination of B39,B40,B41
  */
diff --git a/net/mac80211/debugfs_sta.c b/net/mac80211/debugfs_sta.c
index eb4bb79d936a..8ea6fb90f140 100644
--- a/net/mac80211/debugfs_sta.c
+++ b/net/mac80211/debugfs_sta.c
@@ -734,7 +734,7 @@ static ssize_t sta_he_capa_read(struct file *file, char __user *userbuf,
 	PFLAG(MAC, 4, SRP_RESP, "SRP-RESP");
 	PFLAG(MAC, 4, NDP_FB_REP, "NDP-FB-REP");
 	PFLAG(MAC, 4, OPS, "OPS");
-	PFLAG(MAC, 4, AMDSU_IN_AMPDU, "AMSDU-IN-AMPDU");
+	PFLAG(MAC, 4, AMSDU_IN_AMPDU, "AMSDU-IN-AMPDU");
 
 	PRINT("MULTI-TID-AGG-TX-QOS-%d", ((cap[5] << 1) | (cap[4] >> 7)) & 0x7);
 
