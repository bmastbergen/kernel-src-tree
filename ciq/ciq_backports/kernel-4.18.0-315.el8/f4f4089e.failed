mt76: connac: move mcu_update_arp_filter in mt76_connac module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit f4f4089eb145d18af93977aebdcb899d8eaa890a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/f4f4089e.failed

Move mt76_connac_mcu_update_arp_filter in mt76_connac module since the
code is shared between mt7615 and mt7921

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit f4f4089eb145d18af93977aebdcb899d8eaa890a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
#	drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
#	drivers/net/wireless/mediatek/mt76/mt7921/main.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
index c82b7f8b9319,364daef4b0be..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
@@@ -3981,53 -2704,6 +3981,56 @@@ int mt7615_mcu_set_roc(struct mt7615_ph
  				 sizeof(req), false);
  }
  
++<<<<<<< HEAD
 +int mt7615_mcu_update_arp_filter(struct ieee80211_hw *hw,
 +				 struct ieee80211_vif *vif,
 +				 struct ieee80211_bss_conf *info)
 +{
 +	struct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;
 +	struct mt7615_dev *dev = mt7615_hw_dev(hw);
 +	struct sk_buff *skb;
 +	int i, len = min_t(int, info->arp_addr_cnt,
 +			   IEEE80211_BSS_ARP_ADDR_LIST_LEN);
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7615_arpns_tlv arp;
 +	} req_hdr = {
 +		.hdr = {
 +			.bss_idx = mvif->idx,
 +		},
 +		.arp = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ARP),
 +			.len = cpu_to_le16(sizeof(struct mt7615_arpns_tlv)),
 +			.ips_num = len,
 +			.mode = 2,  /* update */
 +			.option = 1,
 +		},
 +	};
 +
 +	if (!mt7615_firmware_offload(dev))
 +		return 0;
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(req_hdr) + len * sizeof(__be32));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &req_hdr, sizeof(req_hdr));
 +	for (i = 0; i < len; i++) {
 +		u8 *addr = (u8 *)skb_put(skb, sizeof(__be32));
 +
 +		memcpy(addr, &info->arp_addr_list[i], sizeof(__be32));
 +	}
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_UNI_CMD_OFFLOAD,
 +				     true);
 +}
 +
++=======
++>>>>>>> f4f4089eb145 (mt76: connac: move mcu_update_arp_filter in mt76_connac module)
  int mt7615_mcu_set_p2p_oppps(struct ieee80211_hw *hw,
  			     struct ieee80211_vif *vif)
  {
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
index b95a8ec185be,5262b84a28c7..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
@@@ -618,15 -549,6 +618,18 @@@ int mt7615_mac_set_beacon_filter(struc
  				 bool enable);
  int mt7615_mcu_set_bss_pm(struct mt7615_dev *dev, struct ieee80211_vif *vif,
  			  bool enable);
++<<<<<<< HEAD
 +int mt7615_mcu_set_hif_suspend(struct mt7615_dev *dev, bool suspend);
 +void mt7615_mcu_set_suspend_iter(void *priv, u8 *mac,
 +				 struct ieee80211_vif *vif);
 +int mt7615_mcu_update_gtk_rekey(struct ieee80211_hw *hw,
 +				struct ieee80211_vif *vif,
 +				struct cfg80211_gtk_rekey_data *key);
 +int mt7615_mcu_update_arp_filter(struct ieee80211_hw *hw,
 +				 struct ieee80211_vif *vif,
 +				 struct ieee80211_bss_conf *info);
++=======
++>>>>>>> f4f4089eb145 (mt76: connac: move mcu_update_arp_filter in mt76_connac module)
  int __mt7663_load_firmware(struct mt7615_dev *dev);
  u32 mt7615_mcu_reg_rr(struct mt76_dev *dev, u32 offset);
  void mt7615_mcu_reg_wr(struct mt76_dev *dev, u32 offset, u32 val);
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/main.c
index c3e38909c927,0ded32732004..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/main.c
@@@ -564,7 -623,17 +564,21 @@@ static void mt7921_bss_info_changed(str
  	if (changed & BSS_CHANGED_PS)
  		mt7921_mcu_uni_bss_ps(dev, vif);
  
++<<<<<<< HEAD
 +	mutex_unlock(&dev->mt76.mutex);
++=======
+ 	if (changed & BSS_CHANGED_ASSOC)
+ 		mt7921_bss_bcnft_apply(dev, vif, info->assoc);
+ 
+ 	if (changed & BSS_CHANGED_ARP_FILTER) {
+ 		struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
+ 
+ 		mt76_connac_mcu_update_arp_filter(&dev->mt76, &mvif->mt76,
+ 						  info);
+ 	}
+ 
+ 	mt7921_mutex_release(dev);
++>>>>>>> f4f4089eb145 (mt76: connac: move mcu_update_arp_filter in mt76_connac module)
  }
  
  int mt7921_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
index 031cb2bd8cce,14ba856de0b6..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
@@@ -2639,296 -1264,100 +2639,369 @@@ int mt7921_mcu_set_bss_pm(struct mt7921
  				 sizeof(req), false);
  }
  
 -int mt7921_mcu_drv_pmctrl(struct mt7921_dev *dev)
 +#ifdef CONFIG_PM
 +int mt7921_mcu_set_hif_suspend(struct mt7921_dev *dev, bool suspend)
  {
 -	struct mt76_phy *mphy = &dev->mt76.phy;
 +	struct {
 +		struct {
 +			u8 hif_type; /* 0x0: HIF_SDIO
 +				      * 0x1: HIF_USB
 +				      * 0x2: HIF_PCIE
 +				      */
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct hif_suspend_tlv {
 +			__le16 tag;
 +			__le16 len;
 +			u8 suspend;
 +		} __packed hif_suspend;
 +	} req = {
 +		.hif_suspend = {
 +			.tag = cpu_to_le16(0), /* 0: UNI_HIF_CTRL_BASIC */
 +			.len = cpu_to_le16(sizeof(struct hif_suspend_tlv)),
 +			.suspend = suspend,
 +		},
 +	};
 +
 +	if (mt76_is_mmio(&dev->mt76))
 +		req.hdr.hif_type = 2;
 +	else if (mt76_is_usb(&dev->mt76))
 +		req.hdr.hif_type = 1;
 +	else if (mt76_is_sdio(&dev->mt76))
 +		req.hdr.hif_type = 0;
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_HIF_CTRL, &req,
 +				 sizeof(req), true);
 +}
 +EXPORT_SYMBOL_GPL(mt7921_mcu_set_hif_suspend);
 +
++<<<<<<< HEAD
 +static int
 +mt7921_mcu_set_wow_ctrl(struct mt7921_phy *phy, struct ieee80211_vif *vif,
 +			bool suspend, struct cfg80211_wowlan *wowlan)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_dev *dev = phy->dev;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_wow_ctrl_tlv wow_ctrl_tlv;
 +		struct mt7921_wow_gpio_param_tlv gpio_tlv;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.wow_ctrl_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_WOW_CTRL),
 +			.len = cpu_to_le16(sizeof(struct mt7921_wow_ctrl_tlv)),
 +			.cmd = suspend ? 1 : 2,
 +		},
 +		.gpio_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_WOW_GPIO_PARAM),
 +			.len = cpu_to_le16(sizeof(struct mt7921_wow_gpio_param_tlv)),
 +			.gpio_pin = 0xff, /* follow fw about GPIO pin */
 +		},
 +	};
 +
 +	if (wowlan->magic_pkt)
 +		req.wow_ctrl_tlv.trigger |= BIT(0);
 +	if (wowlan->disconnect)
 +		req.wow_ctrl_tlv.trigger |= BIT(2);
 +	if (wowlan->nd_config) {
 +		mt7921_mcu_sched_scan_req(phy, vif, wowlan->nd_config);
 +		req.wow_ctrl_tlv.trigger |= BIT(5);
 +		mt7921_mcu_sched_scan_enable(phy, vif, suspend);
 +	}
 +
 +	if (mt76_is_mmio(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_PCIE;
 +	else if (mt76_is_usb(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_USB;
 +	else if (mt76_is_sdio(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_GPIO;
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_SUSPEND, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_wow_pattern(struct mt7921_dev *dev,
 +			   struct ieee80211_vif *vif,
 +			   u8 index, bool enable,
 +			   struct cfg80211_pkt_pattern *pattern)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_wow_pattern_tlv *ptlv;
 +	struct sk_buff *skb;
 +	struct req_hdr {
 +		u8 bss_idx;
 +		u8 pad[3];
 +	} __packed hdr = {
 +		.bss_idx = mvif->mt76.idx,
 +	};
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(hdr) + sizeof(*ptlv));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &hdr, sizeof(hdr));
 +	ptlv = (struct mt7921_wow_pattern_tlv *)skb_put(skb, sizeof(*ptlv));
 +	ptlv->tag = cpu_to_le16(UNI_SUSPEND_WOW_PATTERN);
 +	ptlv->len = cpu_to_le16(sizeof(*ptlv));
 +	ptlv->data_len = pattern->pattern_len;
 +	ptlv->enable = enable;
 +	ptlv->index = index;
 +
 +	memcpy(ptlv->pattern, pattern->pattern, pattern->pattern_len);
 +	memcpy(ptlv->mask, pattern->mask, pattern->pattern_len / 8);
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_UNI_CMD_SUSPEND,
 +				     true);
 +}
 +
 +static int
 +mt7921_mcu_set_suspend_mode(struct mt7921_dev *dev,
 +			    struct ieee80211_vif *vif,
 +			    bool enable, u8 mdtim, bool wow_suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_suspend_tlv suspend_tlv;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.suspend_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_MODE_SETTING),
 +			.len = cpu_to_le16(sizeof(struct mt7921_suspend_tlv)),
 +			.enable = enable,
 +			.mdtim = mdtim,
 +			.wow_suspend = wow_suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_SUSPEND, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_gtk_rekey(struct mt7921_dev *dev,
 +			 struct ieee80211_vif *vif,
 +			 bool suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_gtk_rekey_tlv gtk_tlv;
 +	} __packed req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.gtk_tlv = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY),
 +			.len = cpu_to_le16(sizeof(struct mt7921_gtk_rekey_tlv)),
 +			.rekey_mode = !suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_OFFLOAD, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_arp_filter(struct mt7921_dev *dev, struct ieee80211_vif *vif,
 +			  bool suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_arpns_tlv arpns;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.arpns = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ARP),
 +			.len = cpu_to_le16(sizeof(struct mt7921_arpns_tlv)),
 +			.mode = suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_OFFLOAD, &req,
 +				 sizeof(req), true);
 +}
 +
 +void mt7921_mcu_set_suspend_iter(void *priv, u8 *mac,
 +				 struct ieee80211_vif *vif)
 +{
 +	struct mt7921_phy *phy = priv;
 +	bool suspend = test_bit(MT76_STATE_SUSPEND, &phy->mt76->state);
 +	struct ieee80211_hw *hw = phy->mt76->hw;
 +	struct cfg80211_wowlan *wowlan = hw->wiphy->wowlan_config;
  	int i;
  
 -	if (!test_and_clear_bit(MT76_STATE_PM, &mphy->state))
 -		goto out;
 +	mt7921_mcu_set_gtk_rekey(phy->dev, vif, suspend);
 +	mt7921_mcu_set_arp_filter(phy->dev, vif, suspend);
  
 -	for (i = 0; i < MT7921_DRV_OWN_RETRY_COUNT; i++) {
 -		mt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_CLR_OWN);
 -		if (mt76_poll_msec(dev, MT_CONN_ON_LPCTL,
 -				   PCIE_LPCR_HOST_OWN_SYNC, 0, 50))
 -			break;
 +	mt7921_mcu_set_suspend_mode(phy->dev, vif, suspend, 1, true);
 +
 +	for (i = 0; i < wowlan->n_patterns; i++)
 +		mt7921_mcu_set_wow_pattern(phy->dev, vif, i, suspend,
 +					   &wowlan->patterns[i]);
 +	mt7921_mcu_set_wow_ctrl(phy, vif, suspend, wowlan);
 +}
 +
 +static void
 +mt7921_mcu_key_iter(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 +		    struct ieee80211_sta *sta, struct ieee80211_key_conf *key,
 +		    void *data)
 +{
 +	struct mt7921_gtk_rekey_tlv *gtk_tlv = data;
 +	u32 cipher;
 +
 +	if (key->cipher != WLAN_CIPHER_SUITE_AES_CMAC &&
 +	    key->cipher != WLAN_CIPHER_SUITE_CCMP &&
 +	    key->cipher != WLAN_CIPHER_SUITE_TKIP)
 +		return;
 +
 +	if (key->cipher == WLAN_CIPHER_SUITE_TKIP) {
 +		gtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_1);
 +		cipher = BIT(3);
 +	} else {
 +		gtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_2);
 +		cipher = BIT(4);
  	}
  
 -	if (i == MT7921_DRV_OWN_RETRY_COUNT) {
 -		dev_err(dev->mt76.dev, "driver own failed\n");
 -		mt7921_reset(&dev->mt76);
 -		return -EIO;
 +	/* we are assuming here to have a single pairwise key */
 +	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {
 +		gtk_tlv->pairwise_cipher = cpu_to_le32(cipher);
 +		gtk_tlv->group_cipher = cpu_to_le32(cipher);
 +		gtk_tlv->keyid = key->keyidx;
  	}
 +}
  
 -out:
 -	dev->pm.last_activity = jiffies;
 +int mt7921_mcu_update_gtk_rekey(struct ieee80211_hw *hw,
 +				struct ieee80211_vif *vif,
 +				struct cfg80211_gtk_rekey_data *key)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_dev *dev = mt7921_hw_dev(hw);
 +	struct mt7921_gtk_rekey_tlv *gtk_tlv;
 +	struct sk_buff *skb;
 +	struct {
 +		u8 bss_idx;
 +		u8 pad[3];
 +	} __packed hdr = {
 +		.bss_idx = mvif->mt76.idx,
 +	};
  
 -	return 0;
 -}
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(hdr) + sizeof(*gtk_tlv));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &hdr, sizeof(hdr));
 +	gtk_tlv = (struct mt7921_gtk_rekey_tlv *)skb_put(skb,
 +							 sizeof(*gtk_tlv));
 +	gtk_tlv->tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY);
 +	gtk_tlv->len = cpu_to_le16(sizeof(*gtk_tlv));
 +	gtk_tlv->rekey_mode = 2;
 +	gtk_tlv->option = 1;
 +
 +	rcu_read_lock();
 +	ieee80211_iter_keys_rcu(hw, vif, mt7921_mcu_key_iter, gtk_tlv);
 +	rcu_read_unlock();
 +
 +	memcpy(gtk_tlv->kek, key->kek, NL80211_KEK_LEN);
 +	memcpy(gtk_tlv->kck, key->kck, NL80211_KCK_LEN);
 +	memcpy(gtk_tlv->replay_ctr, key->replay_ctr, NL80211_REPLAY_CTR_LEN);
  
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_UNI_CMD_OFFLOAD,
 +				     true);
 +}
 +#endif /* CONFIG_PM */
++=======
+ int mt7921_mcu_fw_pmctrl(struct mt7921_dev *dev)
+ {
+ 	struct mt76_phy *mphy = &dev->mt76.phy;
+ 	int i;
+ 
+ 	if (test_and_set_bit(MT76_STATE_PM, &mphy->state))
+ 		return 0;
+ 
+ 	for (i = 0; i < MT7921_DRV_OWN_RETRY_COUNT; i++) {
+ 		mt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_SET_OWN);
+ 		if (mt76_poll_msec(dev, MT_CONN_ON_LPCTL,
+ 				   PCIE_LPCR_HOST_OWN_SYNC, 4, 50))
+ 			break;
+ 	}
+ 
+ 	if (i == MT7921_DRV_OWN_RETRY_COUNT) {
+ 		dev_err(dev->mt76.dev, "firmware own failed\n");
+ 		mt7921_reset(&dev->mt76);
+ 		return -EIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void
+ mt7921_pm_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)
+ {
+ 	struct mt7921_phy *phy = priv;
+ 	struct mt7921_dev *dev = phy->dev;
+ 	int ret;
+ 
+ 	if (dev->pm.enable)
+ 		ret = mt7921_mcu_uni_bss_bcnft(dev, vif, true);
+ 	else
+ 		ret = mt7921_mcu_set_bss_pm(dev, vif, false);
+ 
+ 	if (ret)
+ 		return;
+ 
+ 	if (dev->pm.enable) {
+ 		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_set(dev, MT_WF_RFCR(0), MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	} else {
+ 		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_clear(dev, MT_WF_RFCR(0), MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	}
+ }
+ 
+ int mt7921_get_txpwr_info(struct mt7921_dev *dev, struct mt7921_txpwr *txpwr)
+ {
+ 	struct mt7921_txpwr_event *event;
+ 	struct mt7921_txpwr_req req = {
+ 		.dbdc_idx = 0,
+ 	};
+ 	struct sk_buff *skb;
+ 	int ret;
+ 
+ 	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_CMD_GET_TXPWR,
+ 					&req, sizeof(req), true, &skb);
+ 	if (ret)
+ 		return ret;
+ 
+ 	event = (struct mt7921_txpwr_event *)skb->data;
+ 	WARN_ON(skb->len != le16_to_cpu(event->len));
+ 	memcpy(txpwr, &event->txpwr, sizeof(event->txpwr));
+ 
+ 	dev_kfree_skb(skb);
+ 
+ 	return 0;
+ }
++>>>>>>> f4f4089eb145 (mt76: connac: move mcu_update_arp_filter in mt76_connac module)
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index e784231c65df,3982e074ff50..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@@ -360,13 -364,16 +360,28 @@@ int mt7921_mcu_uni_bss_bcnft(struct mt7
  			     bool enable);
  int mt7921_mcu_set_bss_pm(struct mt7921_dev *dev, struct ieee80211_vif *vif,
  			  bool enable);
++<<<<<<< HEAD
 +int mt7921_mcu_set_hif_suspend(struct mt7921_dev *dev, bool suspend);
 +void mt7921_mcu_set_suspend_iter(void *priv, u8 *mac,
 +				 struct ieee80211_vif *vif);
 +int mt7921_mcu_update_gtk_rekey(struct ieee80211_hw *hw,
 +				struct ieee80211_vif *vif,
 +				struct cfg80211_gtk_rekey_data *key);
 +int mt7921_mcu_update_arp_filter(struct ieee80211_hw *hw,
 +				 struct ieee80211_vif *vif,
 +				 struct ieee80211_bss_conf *info);
++=======
+ int mt7921_mcu_drv_pmctrl(struct mt7921_dev *dev);
+ int mt7921_mcu_fw_pmctrl(struct mt7921_dev *dev);
+ void mt7921_pm_wake_work(struct work_struct *work);
+ void mt7921_pm_power_save_work(struct work_struct *work);
+ bool mt7921_wait_for_mcu_init(struct mt7921_dev *dev);
+ int mt7921_mac_set_beacon_filter(struct mt7921_phy *phy,
+ 				 struct ieee80211_vif *vif,
+ 				 bool enable);
+ void mt7921_pm_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif);
+ void mt7921_coredump_work(struct work_struct *work);
+ int mt7921_wfsys_reset(struct mt7921_dev *dev);
+ int mt7921_get_txpwr_info(struct mt7921_dev *dev, struct mt7921_txpwr *txpwr);
++>>>>>>> f4f4089eb145 (mt76: connac: move mcu_update_arp_filter in mt76_connac module)
  #endif
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/main.c b/drivers/net/wireless/mediatek/mt76/mt7615/main.c
index f8409002c8b6..6254309ff619 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/main.c
@@ -558,8 +558,13 @@ static void mt7615_bss_info_changed(struct ieee80211_hw *hw,
 	if (changed & BSS_CHANGED_PS)
 		mt7615_mcu_set_vif_ps(dev, vif);
 
-	if (changed & BSS_CHANGED_ARP_FILTER)
-		mt7615_mcu_update_arp_filter(hw, vif, info);
+	if ((changed & BSS_CHANGED_ARP_FILTER) &&
+	    mt7615_firmware_offload(dev)) {
+		struct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;
+
+		mt76_connac_mcu_update_arp_filter(&dev->mt76, &mvif->mt76,
+						  info);
+	}
 
 	mt7615_mutex_release(dev);
 }
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/main.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
