net: ena: Update XDP verdict upon failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Shay Agroskin <shayagr@amazon.com>
commit 225353c070fda18a23785e34e1eec2be508a3a3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/225353c0.failed

The verdict returned from ena_xdp_execute() is used to determine the
fate of the RX buffer's page. In case of XDP Redirect/TX error the
verdict should be set to XDP_ABORTED, otherwise the page won't be freed.

Fixes: a318c70ad152 ("net: ena: introduce XDP redirect implementation")
	Signed-off-by: Shay Agroskin <shayagr@amazon.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 225353c070fda18a23785e34e1eec2be508a3a3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amazon/ena/ena_netdev.c
diff --cc drivers/net/ethernet/amazon/ena/ena_netdev.c
index a34982bbddb7,a0596c073ddd..000000000000
--- a/drivers/net/ethernet/amazon/ena/ena_netdev.c
+++ b/drivers/net/ethernet/amazon/ena/ena_netdev.c
@@@ -350,21 -398,48 +350,47 @@@ static int ena_xdp_execute(struct ena_r
  
  	verdict = bpf_prog_run_xdp(xdp_prog, xdp);
  
++<<<<<<< HEAD
 +	if (verdict == XDP_TX) {
 +		ena_xdp_xmit_buff(rx_ring->netdev,
 +				  xdp,
 +				  rx_ring->qid + rx_ring->adapter->num_io_queues,
 +				  rx_info);
++=======
+ 	switch (verdict) {
+ 	case XDP_TX:
+ 		xdpf = xdp_convert_buff_to_frame(xdp);
+ 		if (unlikely(!xdpf)) {
+ 			trace_xdp_exception(rx_ring->netdev, xdp_prog, verdict);
+ 			xdp_stat = &rx_ring->rx_stats.xdp_aborted;
+ 			verdict = XDP_ABORTED;
+ 			break;
+ 		}
++>>>>>>> 225353c070fd (net: ena: Update XDP verdict upon failure)
  
 -		/* Find xmit queue */
 -		qid = rx_ring->qid + rx_ring->adapter->num_io_queues;
 -		xdp_ring = &rx_ring->adapter->tx_ring[qid];
 -
 -		/* The XDP queues are shared between XDP_TX and XDP_REDIRECT */
 -		spin_lock(&xdp_ring->xdp_tx_lock);
 -
 -		ena_xdp_xmit_frame(xdp_ring, rx_ring->netdev, xdpf, XDP_XMIT_FLUSH);
 -
 -		spin_unlock(&xdp_ring->xdp_tx_lock);
  		xdp_stat = &rx_ring->rx_stats.xdp_tx;
++<<<<<<< HEAD
 +	} else if (unlikely(verdict == XDP_ABORTED)) {
++=======
+ 		break;
+ 	case XDP_REDIRECT:
+ 		if (likely(!xdp_do_redirect(rx_ring->netdev, xdp, xdp_prog))) {
+ 			xdp_stat = &rx_ring->rx_stats.xdp_redirect;
+ 			break;
+ 		}
+ 		trace_xdp_exception(rx_ring->netdev, xdp_prog, verdict);
+ 		xdp_stat = &rx_ring->rx_stats.xdp_aborted;
+ 		verdict = XDP_ABORTED;
+ 		break;
+ 	case XDP_ABORTED:
++>>>>>>> 225353c070fd (net: ena: Update XDP verdict upon failure)
  		trace_xdp_exception(rx_ring->netdev, xdp_prog, verdict);
  		xdp_stat = &rx_ring->rx_stats.xdp_aborted;
 -		break;
 -	case XDP_DROP:
 +	} else if (unlikely(verdict == XDP_DROP)) {
  		xdp_stat = &rx_ring->rx_stats.xdp_drop;
 -		break;
 -	case XDP_PASS:
 +	} else if (unlikely(verdict == XDP_PASS)) {
  		xdp_stat = &rx_ring->rx_stats.xdp_pass;
 -		break;
 -	default:
 +	} else {
  		bpf_warn_invalid_xdp_action(verdict);
  		xdp_stat = &rx_ring->rx_stats.xdp_invalid;
  	}
* Unmerged path drivers/net/ethernet/amazon/ena/ena_netdev.c
