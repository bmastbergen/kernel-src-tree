mt76: connac: alaways wake the device before scanning

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit a61826203ba8806b4cdffd36bafdce3e9ad35c24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/a6182620.failed

move scanning check from mt76_connac_power_save_sched routine
to mt7921_pm_power_save_work/mt7615_pm_power_save_work ones

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit a61826203ba8806b4cdffd36bafdce3e9ad35c24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mac.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index bcbd59a23f9b,90ede75cfba8..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@@ -1368,8 -1506,125 +1368,129 @@@ void mt7921_mac_work(struct work_struc
  		mt7921_mac_sta_stats_work(phy);
  	}
  
 -	mt7921_mutex_release(phy->dev);
 -	ieee80211_queue_delayed_work(phy->mt76->hw, &mphy->mac_work,
 +	mutex_unlock(&mphy->dev->mutex);
 +
 +	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
  				     MT7921_WATCHDOG_TIME);
  }
++<<<<<<< HEAD
++=======
+ 
+ void mt7921_pm_wake_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	struct mt76_phy *mphy;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						pm.wake_work);
+ 	mphy = dev->phy.mt76;
+ 
+ 	if (!mt7921_mcu_drv_pmctrl(dev)) {
+ 		int i;
+ 
+ 		mt76_for_each_q_rx(&dev->mt76, i)
+ 			napi_schedule(&dev->mt76.napi[i]);
+ 		mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
+ 		mt7921_tx_cleanup(dev);
+ 	}
+ 
+ 	ieee80211_wake_queues(mphy->hw);
+ 	complete_all(&dev->pm.wake_cmpl);
+ }
+ 
+ void mt7921_pm_power_save_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	unsigned long delta;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						pm.ps_work.work);
+ 
+ 	delta = dev->pm.idle_timeout;
+ 	if (test_bit(MT76_HW_SCANNING, &dev->mphy.state) ||
+ 	    test_bit(MT76_HW_SCHED_SCANNING, &dev->mphy.state))
+ 		goto out;
+ 
+ 	if (time_is_after_jiffies(dev->pm.last_activity + delta)) {
+ 		delta = dev->pm.last_activity + delta - jiffies;
+ 		goto out;
+ 	}
+ 
+ 	if (!mt7921_mcu_fw_pmctrl(dev))
+ 		return;
+ out:
+ 	queue_delayed_work(dev->mt76.wq, &dev->pm.ps_work, delta);
+ }
+ 
+ int mt7921_mac_set_beacon_filter(struct mt7921_phy *phy,
+ 				 struct ieee80211_vif *vif,
+ 				 bool enable)
+ {
+ 	struct mt7921_dev *dev = phy->dev;
+ 	bool ext_phy = phy != &dev->phy;
+ 	int err;
+ 
+ 	if (!dev->pm.enable)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = mt7921_mcu_set_bss_pm(dev, vif, enable);
+ 	if (err)
+ 		return err;
+ 
+ 	if (enable) {
+ 		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_set(dev, MT_WF_RFCR(ext_phy),
+ 			 MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	} else {
+ 		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_clear(dev, MT_WF_RFCR(ext_phy),
+ 			   MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void mt7921_coredump_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	char *dump, *data;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						coredump.work.work);
+ 
+ 	if (time_is_after_jiffies(dev->coredump.last_activity +
+ 				  4 * MT76_CONNAC_COREDUMP_TIMEOUT)) {
+ 		queue_delayed_work(dev->mt76.wq, &dev->coredump.work,
+ 				   MT76_CONNAC_COREDUMP_TIMEOUT);
+ 		return;
+ 	}
+ 
+ 	dump = vzalloc(MT76_CONNAC_COREDUMP_SZ);
+ 	data = dump;
+ 
+ 	while (true) {
+ 		struct sk_buff *skb;
+ 
+ 		spin_lock_bh(&dev->mt76.lock);
+ 		skb = __skb_dequeue(&dev->coredump.msg_list);
+ 		spin_unlock_bh(&dev->mt76.lock);
+ 
+ 		if (!skb)
+ 			break;
+ 
+ 		skb_pull(skb, sizeof(struct mt7921_mcu_rxd));
+ 		if (data + skb->len - dump > MT76_CONNAC_COREDUMP_SZ) {
+ 			dev_kfree_skb(skb);
+ 			continue;
+ 		}
+ 
+ 		memcpy(data, skb->data, skb->len);
+ 		data += skb->len;
+ 
+ 		dev_kfree_skb(skb);
+ 	}
+ 	dev_coredumpv(dev->mt76.dev, dump, MT76_CONNAC_COREDUMP_SZ,
+ 		      GFP_KERNEL);
+ 	mt7921_reset(&dev->mt76);
+ }
++>>>>>>> a61826203ba8 (mt76: connac: alaways wake the device before scanning)
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
index 1b8b80e3739d..bb36b88c9bb7 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
@@ -1982,6 +1982,10 @@ void mt7615_pm_power_save_work(struct work_struct *work)
 						pm.ps_work.work);
 
 	delta = dev->pm.idle_timeout;
+	if (test_bit(MT76_HW_SCANNING, &dev->mphy.state) ||
+	    test_bit(MT76_HW_SCHED_SCANNING, &dev->mphy.state))
+		goto out;
+
 	if (time_is_after_jiffies(dev->pm.last_activity + delta)) {
 		delta = dev->pm.last_activity + delta - jiffies;
 		goto out;
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mac.c
