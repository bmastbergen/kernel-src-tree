mt76: move tx hw data queues in mt76_phy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 91990519298e231bf102f7242d5f483bef5e514a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/91990519.failed

Move hw data queues in mt76_phy from mt76_dev since mt7915 supports per
phy hw queues in dbdc mode

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 91990519298e231bf102f7242d5f483bef5e514a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7603/beacon.c
#	drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
#	drivers/net/wireless/mediatek/mt76/tx.c
#	drivers/net/wireless/mediatek/mt76/usb.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7603/beacon.c
index ea68087bd8e5,5d4522f440b7..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7603/beacon.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/beacon.c
@@@ -23,13 -24,14 +23,22 @@@ mt7603_update_beacon_iter(void *priv, u
  	if (!skb)
  		return;
  
++<<<<<<< HEAD
 +	mt76_tx_queue_skb(dev, MT_TXQ_BEACON, skb, &mvif->sta.wcid, NULL);
++=======
+ 	mt76_tx_queue_skb(dev, dev->mphy.q_tx[MT_TXQ_BEACON], skb,
+ 			  &mvif->sta.wcid, NULL);
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  
  	spin_lock_bh(&dev->ps_lock);
  	mt76_wr(dev, MT_DMA_FQCR0, MT_DMA_FQCR0_BUSY |
  		FIELD_PREP(MT_DMA_FQCR0_TARGET_WCID, mvif->sta.wcid.idx) |
  		FIELD_PREP(MT_DMA_FQCR0_TARGET_QID,
++<<<<<<< HEAD
 +			   dev->mt76.q_tx[MT_TXQ_CAB]->hw_idx) |
++=======
+ 			   dev->mphy.q_tx[MT_TXQ_CAB]->hw_idx) |
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  		FIELD_PREP(MT_DMA_FQCR0_DEST_PORT_ID, 3) |
  		FIELD_PREP(MT_DMA_FQCR0_DEST_QUEUE_ID, 8));
  
@@@ -78,7 -81,7 +87,11 @@@ void mt7603_pre_tbtt_tasklet(unsigned l
  	data.dev = dev;
  	__skb_queue_head_init(&data.q);
  
++<<<<<<< HEAD
 +	q = dev->mt76.q_tx[MT_TXQ_BEACON];
++=======
+ 	q = dev->mphy.q_tx[MT_TXQ_BEACON];
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  	spin_lock_bh(&q->lock);
  	ieee80211_iterate_active_interfaces_atomic(mt76_hw(dev),
  		IEEE80211_IFACE_ITER_RESUME_ALL,
@@@ -89,13 -92,13 +102,21 @@@
  	/* Flush all previous CAB queue packets */
  	mt76_wr(dev, MT_WF_ARB_CAB_FLUSH, GENMASK(30, 16) | BIT(0));
  
++<<<<<<< HEAD
 +	mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[MT_TXQ_CAB], false);
++=======
+ 	mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_CAB], false);
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  
 -	mt76_csa_check(mdev);
 -	if (mdev->csa_complete)
 +	mt76_csa_check(&dev->mt76);
 +	if (dev->mt76.csa_complete)
  		goto out;
  
++<<<<<<< HEAD
 +	q = dev->mt76.q_tx[MT_TXQ_CAB];
++=======
+ 	q = dev->mphy.q_tx[MT_TXQ_CAB];
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  	do {
  		nframes = skb_queue_len(&data.q);
  		ieee80211_iterate_active_interfaces_atomic(mt76_hw(dev),
@@@ -120,7 -123,7 +141,11 @@@
  		struct ieee80211_vif *vif = info->control.vif;
  		struct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;
  
++<<<<<<< HEAD
 +		mt76_tx_queue_skb(dev, MT_TXQ_CAB, skb, &mvif->sta.wcid, NULL);
++=======
+ 		mt76_tx_queue_skb(dev, q, skb, &mvif->sta.wcid, NULL);
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  	}
  	mt76_queue_kick(dev, q);
  	spin_unlock_bh(&q->lock);
@@@ -135,9 -138,8 +160,14 @@@
  		 ((1 << (MT7603_MAX_INTERFACES - 1)) - 1)));
  
  out:
++<<<<<<< HEAD
 +	mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[MT_TXQ_BEACON], false);
 +	if (dev->mt76.q_tx[MT_TXQ_BEACON]->queued >
 +	    hweight8(dev->mt76.beacon_mask))
++=======
+ 	mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_BEACON], false);
+ 	if (dev->mphy.q_tx[MT_TXQ_BEACON]->queued > hweight8(mdev->beacon_mask))
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  		dev->beacon_check++;
  }
  
diff --cc drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
index 1caa9f703491,e7e87311d355..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
@@@ -11,10 -11,11 +11,16 @@@
  #include "mt76x02_mcu.h"
  #include "trace.h"
  
 -static void mt76x02_pre_tbtt_tasklet(struct tasklet_struct *t)
 +static void mt76x02_pre_tbtt_tasklet(unsigned long arg)
  {
++<<<<<<< HEAD
 +	struct mt76x02_dev *dev = (struct mt76x02_dev *)arg;
 +	struct mt76_queue *q = dev->mt76.q_tx[MT_TXQ_PSD];
++=======
+ 	struct mt76x02_dev *dev = from_tasklet(dev, t, mt76.pre_tbtt_tasklet);
+ 	struct mt76_dev *mdev = &dev->mt76;
+ 	struct mt76_queue *q = dev->mphy.q_tx[MT_TXQ_PSD];
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  	struct beacon_bc_data data = {};
  	struct sk_buff *skb;
  	int i;
@@@ -58,8 -59,7 +64,12 @@@
  		struct ieee80211_vif *vif = info->control.vif;
  		struct mt76x02_vif *mvif = (struct mt76x02_vif *)vif->drv_priv;
  
++<<<<<<< HEAD
 +		mt76_tx_queue_skb(dev, MT_TXQ_PSD, skb, &mvif->group_wcid,
 +				  NULL);
++=======
+ 		mt76_tx_queue_skb(dev, q, skb, &mvif->group_wcid, NULL);
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  	}
  	spin_unlock_bh(&q->lock);
  }
diff --cc drivers/net/wireless/mediatek/mt76/tx.c
index 73624700fe44,65360067b8fa..000000000000
--- a/drivers/net/wireless/mediatek/mt76/tx.c
+++ b/drivers/net/wireless/mediatek/mt76/tx.c
@@@ -230,7 -230,8 +230,12 @@@ __mt76_tx_queue_skb(struct mt76_dev *de
  		    bool *stop)
  {
  	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
++<<<<<<< HEAD
 +	struct mt76_queue *q;
++=======
+ 	struct mt76_queue *q = phy->q_tx[qid];
+ 	struct mt76_dev *dev = phy->dev;
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  	bool non_aql;
  	int pending;
  	int idx;
@@@ -286,10 -286,10 +291,10 @@@ mt76_tx(struct mt76_phy *phy, struct ie
  	if (ext_phy)
  		info->hw_queue |= MT_TX_HW_QUEUE_EXT_PHY;
  
- 	q = dev->q_tx[qid];
+ 	q = phy->q_tx[qid];
  
  	spin_lock_bh(&q->lock);
 -	__mt76_tx_queue_skb(phy, qid, skb, wcid, sta, NULL);
 +	__mt76_tx_queue_skb(dev, qid, skb, wcid, sta, NULL);
  	dev->queue_ops->kick(dev, q);
  
  	if (q->queued > q->ndesc - 8 && !q->stopped) {
diff --cc drivers/net/wireless/mediatek/mt76/usb.c
index f1ae9ff835b2,81393788f98e..000000000000
--- a/drivers/net/wireless/mediatek/mt76/usb.c
+++ b/drivers/net/wireless/mediatek/mt76/usb.c
@@@ -980,7 -993,9 +980,13 @@@ static int mt76u_alloc_tx(struct mt76_d
  
  		spin_lock_init(&q->lock);
  		q->hw_idx = mt76u_ac_to_hwq(dev, i);
++<<<<<<< HEAD
 +		dev->q_tx[i] = q;
++=======
+ 		q->qid = i;
+ 
+ 		dev->phy.q_tx[i] = q;
++>>>>>>> 91990519298e (mt76: move tx hw data queues in mt76_phy)
  
  		q->entry = devm_kcalloc(dev->dev,
  					MT_NUM_TX_ENTRIES, sizeof(*q->entry),
diff --git a/drivers/net/wireless/mediatek/mt76/debugfs.c b/drivers/net/wireless/mediatek/mt76/debugfs.c
index 52f583cb1418..d4a6b8108971 100644
--- a/drivers/net/wireless/mediatek/mt76/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/debugfs.c
@@ -30,8 +30,8 @@ int mt76_queues_read(struct seq_file *s, void *data)
 	struct mt76_dev *dev = dev_get_drvdata(s->private);
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(dev->q_tx); i++) {
-		struct mt76_queue *q = dev->q_tx[i];
+	for (i = 0; i < ARRAY_SIZE(dev->phy.q_tx); i++) {
+		struct mt76_queue *q = dev->phy.q_tx[i];
 
 		if (!q)
 			continue;
diff --git a/drivers/net/wireless/mediatek/mt76/dma.c b/drivers/net/wireless/mediatek/mt76/dma.c
index 07208b8b851d..d74a06b5a163 100644
--- a/drivers/net/wireless/mediatek/mt76/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/dma.c
@@ -662,8 +662,11 @@ void mt76_dma_cleanup(struct mt76_dev *dev)
 	mt76_worker_disable(&dev->tx_worker);
 	netif_napi_del(&dev->tx_napi);
 
-	for (i = 0; i < ARRAY_SIZE(dev->q_tx); i++)
-		mt76_dma_tx_cleanup(dev, dev->q_tx[i], true);
+	for (i = 0; i < ARRAY_SIZE(dev->phy.q_tx); i++) {
+		mt76_dma_tx_cleanup(dev, dev->phy.q_tx[i], true);
+		if (dev->phy2)
+			mt76_dma_tx_cleanup(dev, dev->phy2->q_tx[i], true);
+	}
 
 	for (i = 0; i < ARRAY_SIZE(dev->q_mcu); i++)
 		mt76_dma_tx_cleanup(dev, dev->q_mcu[i], true);
diff --git a/drivers/net/wireless/mediatek/mt76/mac80211.c b/drivers/net/wireless/mediatek/mt76/mac80211.c
index 6dcd902efb3d..0fc090283f80 100644
--- a/drivers/net/wireless/mediatek/mt76/mac80211.c
+++ b/drivers/net/wireless/mediatek/mt76/mac80211.c
@@ -539,14 +539,11 @@ EXPORT_SYMBOL_GPL(mt76_rx);
 
 bool mt76_has_tx_pending(struct mt76_phy *phy)
 {
-	struct mt76_dev *dev = phy->dev;
 	struct mt76_queue *q;
-	int i, offset;
-
-	offset = __MT_TXQ_MAX * (phy != &dev->phy);
+	int i;
 
 	for (i = 0; i < __MT_TXQ_MAX; i++) {
-		q = dev->q_tx[offset + i];
+		q = phy->q_tx[i];
 		if (q && q->queued)
 			return true;
 	}
diff --git a/drivers/net/wireless/mediatek/mt76/mt76.h b/drivers/net/wireless/mediatek/mt76/mt76.h
index 0f2dddcab301..dba91fed32f0 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@ -559,6 +559,8 @@ struct mt76_phy {
 
 	unsigned long state;
 
+	struct mt76_queue *q_tx[__MT_TXQ_MAX];
+
 	struct cfg80211_chan_def chandef;
 	struct ieee80211_channel *main_chan;
 
@@ -605,7 +607,6 @@ struct mt76_dev {
 	struct sk_buff_head rx_skb[__MT_RXQ_MAX];
 
 	struct list_head txwi_cache;
-	struct mt76_queue *q_tx[2 * __MT_TXQ_MAX];
 	struct mt76_queue *q_mcu[__MT_MCUQ_MAX];
 	struct mt76_queue q_rx[__MT_RXQ_MAX];
 	const struct mt76_queue_ops *queue_ops;
@@ -795,7 +796,7 @@ static inline int mt76_init_tx_queue(struct mt76_phy *phy, int qid, int idx,
 		return PTR_ERR(q);
 
 	q->qid = qid;
-	phy->dev->q_tx[qid] = q;
+	phy->q_tx[qid] = q;
 
 	return 0;
 }
@@ -936,7 +937,7 @@ void mt76_rx(struct mt76_dev *dev, enum mt76_rxq_id q, struct sk_buff *skb);
 void mt76_tx(struct mt76_phy *dev, struct ieee80211_sta *sta,
 	     struct mt76_wcid *wcid, struct sk_buff *skb);
 void mt76_wake_tx_queue(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
-void mt76_stop_tx_queues(struct mt76_dev *dev, struct ieee80211_sta *sta,
+void mt76_stop_tx_queues(struct mt76_phy *phy, struct ieee80211_sta *sta,
 			 bool send_bar);
 void mt76_tx_check_agg_ssn(struct ieee80211_sta *sta, struct sk_buff *skb);
 void mt76_txq_schedule(struct mt76_phy *phy, enum mt76_txq_id qid);
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7603/beacon.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/dma.c b/drivers/net/wireless/mediatek/mt76/mt7603/dma.c
index 3f479d9d63aa..0086f18cb79a 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/dma.c
@@ -133,14 +133,14 @@ static int mt7603_poll_tx(struct napi_struct *napi, int budget)
 
 	mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], false);
 	for (i = MT_TXQ_PSD; i >= 0; i--)
-		mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[i], false);
+		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], false);
 
 	if (napi_complete_done(napi, 0))
 		mt7603_irq_enable(dev, MT_INT_TX_DONE_ALL);
 
 	mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], false);
 	for (i = MT_TXQ_PSD; i >= 0; i--)
-		mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[i], false);
+		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], false);
 
 	mt7603_mac_sta_poll(dev);
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
index 5288301e7614..55095e66f2ef 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
@@ -445,7 +445,7 @@ void mt7603_mac_sta_poll(struct mt7603_dev *dev)
 
 		sta = container_of((void *)msta, struct ieee80211_sta, drv_priv);
 		for (i = 0; i < 4; i++) {
-			struct mt76_queue *q = dev->mt76.q_tx[i];
+			struct mt76_queue *q = dev->mphy.q_tx[i];
 			u8 qidx = q->hw_idx;
 			u8 tid = ac_to_tid[i];
 			u32 txtime = airtime[qidx];
@@ -896,7 +896,7 @@ mt7603_mac_write_txwi(struct mt7603_dev *dev, __le32 *txwi,
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;
 	struct ieee80211_vif *vif = info->control.vif;
-	struct mt76_queue *q = dev->mt76.q_tx[qid];
+	struct mt76_queue *q = dev->mphy.q_tx[qid];
 	struct mt7603_vif *mvif;
 	int wlan_idx;
 	int hdr_len = ieee80211_get_hdrlen_from_skb(skb);
@@ -1436,7 +1436,7 @@ static void mt7603_mac_watchdog_reset(struct mt7603_dev *dev)
 
 	mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], true);
 	for (i = 0; i < __MT_TXQ_MAX; i++)
-		mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[i], true);
+		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);
 
 	mt76_for_each_q_rx(&dev->mt76, i) {
 		mt76_queue_rx_reset(dev, i);
@@ -1515,7 +1515,7 @@ static bool mt7603_tx_hang(struct mt7603_dev *dev)
 	int i;
 
 	for (i = 0; i < 4; i++) {
-		q = dev->mt76.q_tx[i];
+		q = dev->mphy.q_tx[i];
 
 		if (!q->queued)
 			continue;
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/main.c b/drivers/net/wireless/mediatek/mt76/mt7603/main.c
index 64b259123001..6d47b57cbc39 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/main.c
@@ -383,7 +383,7 @@ mt7603_ps_tx_list(struct mt7603_dev *dev, struct sk_buff_head *list)
 	while ((skb = __skb_dequeue(list)) != NULL) {
 		int qid = skb_get_queue_mapping(skb);
 
-		mt76_tx_queue_skb_raw(dev, dev->mt76.q_tx[qid], skb, 0);
+		mt76_tx_queue_skb_raw(dev, dev->mphy.q_tx[qid], skb, 0);
 	}
 }
 
@@ -394,7 +394,7 @@ mt7603_sta_ps(struct mt76_dev *mdev, struct ieee80211_sta *sta, bool ps)
 	struct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;
 	struct sk_buff_head list;
 
-	mt76_stop_tx_queues(&dev->mt76, sta, true);
+	mt76_stop_tx_queues(&dev->mphy, sta, true);
 	mt7603_wtbl_set_ps(dev, msta, ps);
 	if (ps)
 		return;
@@ -514,7 +514,7 @@ mt7603_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u16 queue,
 	u16 cw_max = (1 << 10) - 1;
 	u32 val;
 
-	queue = dev->mt76.q_tx[queue]->hw_idx;
+	queue = dev->mphy.q_tx[queue]->hw_idx;
 
 	if (params->cw_min)
 		cw_min = params->cw_min;
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/debugfs.c b/drivers/net/wireless/mediatek/mt76/mt7615/debugfs.c
index c5090cf0e472..f84f5814bc71 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/debugfs.c
@@ -187,7 +187,7 @@ mt7615_reset_test_set(void *data, u64 val)
 	skb_put(skb, 1);
 
 	mt7615_mutex_acquire(dev);
-	mt76_tx_queue_skb_raw(dev, dev->mt76.q_tx[0], skb, 0);
+	mt76_tx_queue_skb_raw(dev, dev->mphy.q_tx[0], skb, 0);
 	mt7615_mutex_release(dev);
 
 	return 0;
@@ -347,7 +347,7 @@ mt7615_queues_read(struct seq_file *s, void *data)
 		struct mt76_queue *q;
 		char *queue;
 	} queue_map[] = {
-		{ dev->mt76.q_tx[MT_TXQ_BE], "PDMA0" },
+		{ dev->mphy.q_tx[MT_TXQ_BE], "PDMA0" },
 		{ dev->mt76.q_mcu[MT_MCUQ_WM], "MCUQ" },
 		{ dev->mt76.q_mcu[MT_MCUQ_FWDL], "MCUFWQ" },
 	};
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/dma.c b/drivers/net/wireless/mediatek/mt76/mt7615/dma.c
index 39b5af7b94ab..d3033ebaade6 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/dma.c
@@ -60,7 +60,7 @@ mt7615_init_tx_queues(struct mt7615_dev *dev)
 		return ret;
 
 	for (i = 1; i <= MT_TXQ_PSD ; i++)
-		dev->mt76.q_tx[i] = dev->mt76.q_tx[0];
+		dev->mphy.q_tx[i] = dev->mphy.q_tx[0];
 
 	return mt76_init_mcu_queue(&dev->mt76, MT_MCUQ_WM, MT7615_TXQ_MCU,
 				   MT7615_TX_MCU_RING_SIZE, MT_TX_RING_BASE);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/init.c b/drivers/net/wireless/mediatek/mt76/mt7615/init.c
index e470a75365f8..4ba52848cc61 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/init.c
@@ -385,7 +385,7 @@ int mt7615_register_ext_phy(struct mt7615_dev *dev)
 {
 	struct mt7615_phy *phy = mt7615_ext_phy(dev);
 	struct mt76_phy *mphy;
-	int ret;
+	int i, ret;
 
 	if (!is_mt7615(&dev->mt76))
 		return -EOPNOTSUPP;
@@ -429,6 +429,10 @@ int mt7615_register_ext_phy(struct mt7615_dev *dev)
 	mphy->sband_2g.sband.n_channels = 0;
 	mphy->hw->wiphy->bands[NL80211_BAND_2GHZ] = NULL;
 
+	/* mt7615 second phy shares the same hw queues with the primary one */
+	for (i = 0; i <= MT_TXQ_PSD ; i++)
+		mphy->q_tx[i] = dev->mphy.q_tx[i];
+
 	ret = mt76_register_phy(mphy);
 	if (ret)
 		ieee80211_free_hw(mphy->hw);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
index bf25ed6714a2..0f360be0b885 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
@@ -1435,12 +1435,12 @@ static void mt7615_mac_tx_free(struct mt7615_dev *dev, struct sk_buff *skb)
 	struct mt7615_tx_free *free = (struct mt7615_tx_free *)skb->data;
 	u8 i, count;
 
-	mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[MT_TXQ_PSD], false);
+	mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_PSD], false);
 	if (is_mt7615(&dev->mt76)) {
-		mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[MT_TXQ_BE], false);
+		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_BE], false);
 	} else {
 		for (i = 0; i < IEEE80211_NUM_ACS; i++)
-			mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[i], false);
+			mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], false);
 	}
 
 	count = FIELD_GET(MT_TX_FREE_MSDU_ID_CNT, le16_to_cpu(free->ctrl));
@@ -2046,7 +2046,7 @@ void mt7615_dma_reset(struct mt7615_dev *dev)
 
 	mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], true);
 	for (i = 0; i < __MT_TXQ_MAX; i++)
-		mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[i], true);
+		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);
 
 	mt76_for_each_q_rx(&dev->mt76, i) {
 		mt76_queue_rx_reset(dev, i);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/sdio_txrx.c b/drivers/net/wireless/mediatek/mt76/mt7615/sdio_txrx.c
index 9cd33dd8b20c..13d77f8fca86 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/sdio_txrx.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/sdio_txrx.c
@@ -287,7 +287,7 @@ void mt7663s_txrx_worker(struct mt76_worker *w)
 
 		/* tx */
 		for (i = 0; i <= MT_TXQ_PSD; i++) {
-			ret = mt7663s_tx_run_queue(dev, dev->q_tx[i]);
+			ret = mt7663s_tx_run_queue(dev, dev->phy.q_tx[i]);
 			if (ret > 0)
 				nframes += ret;
 		}
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c b/drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c
index 2c2f56112b57..efd70ddc2fd1 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c
@@ -67,7 +67,7 @@ int mt76x02u_tx_prepare_skb(struct mt76_dev *mdev, void *data,
 			    struct mt76_tx_info *tx_info)
 {
 	struct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);
-	int pid, len = tx_info->skb->len, ep = q2ep(mdev->q_tx[qid]->hw_idx);
+	int pid, len = tx_info->skb->len, ep = q2ep(dev->mphy.q_tx[qid]->hw_idx);
 	struct mt76x02_txwi *txwi;
 	bool ampdu = IEEE80211_SKB_CB(tx_info->skb)->flags & IEEE80211_TX_CTL_AMPDU;
 	enum mt76_qsel qsel;
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x02_util.c b/drivers/net/wireless/mediatek/mt76/mt76x02_util.c
index ea31650a01b8..86c1b545f363 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_util.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_util.c
@@ -488,7 +488,7 @@ int mt76x02_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	u8 cw_min = 5, cw_max = 10, qid;
 	u32 val;
 
-	qid = dev->mt76.q_tx[queue]->hw_idx;
+	qid = dev->mphy.q_tx[queue]->hw_idx;
 
 	if (params->cw_min)
 		cw_min = fls(params->cw_min);
@@ -622,7 +622,7 @@ void mt76x02_sta_ps(struct mt76_dev *mdev, struct ieee80211_sta *sta,
 	struct mt76x02_sta *msta = (struct mt76x02_sta *)sta->drv_priv;
 	int idx = msta->wcid.idx;
 
-	mt76_stop_tx_queues(&dev->mt76, sta, true);
+	mt76_stop_tx_queues(&dev->mphy, sta, true);
 	if (mt76_is_mmio(mdev))
 		mt76x02_mac_wcid_set_drop(dev, idx, ps);
 }
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c b/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
index ac2c5997b22f..551246ac931f 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
@@ -284,7 +284,7 @@ mt7915_queues_read(struct seq_file *s, void *data)
 		struct mt76_queue *q;
 		char *queue;
 	} queue_map[] = {
-		{ dev->mt76.q_tx[MT_TXQ_BE], "WFDMA0" },
+		{ dev->mphy.q_tx[MT_TXQ_BE], "WFDMA0" },
 		{ dev->mt76.q_mcu[MT_MCUQ_WM], "MCUWM" },
 		{ dev->mt76.q_mcu[MT_MCUQ_WA], "MCUWA" },
 		{ dev->mt76.q_mcu[MT_MCUQ_FWDL], "MCUFWQ" },
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/dma.c b/drivers/net/wireless/mediatek/mt76/mt7915/dma.c
index 4f7c5fd83efb..3f1e45ee5755 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/dma.c
@@ -6,16 +6,16 @@
 #include "mac.h"
 
 static int
-mt7915_init_tx_queues(struct mt7915_dev *dev, int idx, int n_desc)
+mt7915_init_tx_queues(struct mt7915_phy *phy, int idx, int n_desc)
 {
 	int i, err;
 
-	err = mt76_init_tx_queue(&dev->mphy, 0, idx, n_desc, MT_TX_RING_BASE);
+	err = mt76_init_tx_queue(phy->mt76, 0, idx, n_desc, MT_TX_RING_BASE);
 	if (err < 0)
 		return err;
 
 	for (i = 0; i <= MT_TXQ_PSD; i++)
-		dev->mt76.q_tx[i] = dev->mt76.q_tx[0];
+		phy->mt76->q_tx[i] = phy->mt76->q_tx[0];
 
 	return 0;
 }
@@ -237,7 +237,7 @@ int mt7915_dma_init(struct mt7915_dev *dev)
 	mt76_wr(dev, MT_WFDMA1_PRI_DLY_INT_CFG0, 0);
 
 	/* init tx queue */
-	ret = mt7915_init_tx_queues(dev, MT7915_TXQ_BAND0,
+	ret = mt7915_init_tx_queues(&dev->phy, MT7915_TXQ_BAND0,
 				    MT7915_TX_RING_SIZE);
 	if (ret)
 		return ret;
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
index abca896f151d..3aedc079d7b6 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
@@ -1072,8 +1072,8 @@ void mt7915_mac_tx_free(struct mt7915_dev *dev, struct sk_buff *skb)
 	u8 i, count;
 
 	/* clean DMA queues and unmap buffers first */
-	mt76_queue_tx_cleanup(dev, mdev->q_tx[MT_TXQ_PSD], false);
-	mt76_queue_tx_cleanup(dev, mdev->q_tx[MT_TXQ_BE], false);
+	mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_PSD], false);
+	mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_BE], false);
 
 	/*
 	 * TODO: MT_TX_FREE_LATENCY is msdu time from the TXD is queued into PLE,
@@ -1410,8 +1410,9 @@ mt7915_update_beacons(struct mt7915_dev *dev)
 }
 
 static void
-mt7915_dma_reset(struct mt7915_dev *dev)
+mt7915_dma_reset(struct mt7915_phy *phy)
 {
+	struct mt7915_dev *dev = phy->dev;
 	int i;
 
 	mt76_clear(dev, MT_WFDMA0_GLO_CFG,
@@ -1422,7 +1423,7 @@ mt7915_dma_reset(struct mt7915_dev *dev)
 
 	mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WA], true);
 	for (i = 0; i < __MT_TXQ_MAX; i++)
-		mt76_queue_tx_cleanup(dev, dev->mt76.q_tx[i], true);
+		mt76_queue_tx_cleanup(dev, phy->mt76->q_tx[i], true);
 
 	mt76_for_each_q_rx(&dev->mt76, i) {
 		mt76_queue_rx_reset(dev, i);
@@ -1478,7 +1479,7 @@ void mt7915_mac_reset_work(struct work_struct *work)
 	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);
 
 	if (mt7915_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
-		mt7915_dma_reset(dev);
+		mt7915_dma_reset(&dev->phy);
 
 		mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);
 		mt7915_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
diff --git a/drivers/net/wireless/mediatek/mt76/sdio.c b/drivers/net/wireless/mediatek/mt76/sdio.c
index 86f6fda51c99..5d099172ff81 100644
--- a/drivers/net/wireless/mediatek/mt76/sdio.c
+++ b/drivers/net/wireless/mediatek/mt76/sdio.c
@@ -67,7 +67,7 @@ static int mt76s_alloc_tx(struct mt76_dev *dev)
 			return PTR_ERR(q);
 
 		q->qid = i;
-		dev->q_tx[i] = q;
+		dev->phy.q_tx[i] = q;
 	}
 
 	q = mt76s_alloc_tx_queue(dev);
@@ -206,7 +206,8 @@ static void mt76s_status_worker(struct mt76_worker *w)
 		nframes = mt76s_process_tx_queue(dev, dev->q_mcu[MT_MCUQ_WM]);
 
 		for (i = 0; i <= MT_TXQ_PSD; i++)
-			nframes += mt76s_process_tx_queue(dev, dev->q_tx[i]);
+			nframes += mt76s_process_tx_queue(dev,
+							  dev->phy.q_tx[i]);
 
 		if (dev->drv->tx_status_data &&
 		    !test_and_set_bit(MT76_READING_STATS, &dev->phy.state))
diff --git a/drivers/net/wireless/mediatek/mt76/testmode.c b/drivers/net/wireless/mediatek/mt76/testmode.c
index d1b171697e28..57c4a92a3015 100644
--- a/drivers/net/wireless/mediatek/mt76/testmode.c
+++ b/drivers/net/wireless/mediatek/mt76/testmode.c
@@ -23,6 +23,7 @@ void mt76_testmode_tx_pending(struct mt76_dev *dev)
 {
 	struct mt76_testmode_data *td = &dev->test;
 	struct mt76_wcid *wcid = &dev->global_wcid;
+	struct mt76_phy *phy = &dev->phy;
 	struct sk_buff *skb = td->tx_skb;
 	struct mt76_queue *q;
 	int qid;
@@ -31,7 +32,7 @@ void mt76_testmode_tx_pending(struct mt76_dev *dev)
 		return;
 
 	qid = skb_get_queue_mapping(skb);
-	q = dev->q_tx[qid];
+	q = phy->q_tx[qid];
 
 	spin_lock_bh(&q->lock);
 
* Unmerged path drivers/net/wireless/mediatek/mt76/tx.c
* Unmerged path drivers/net/wireless/mediatek/mt76/usb.c
