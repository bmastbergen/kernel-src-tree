bpf: Fix passing zero to PTR_ERR() in bpf_btf_printf_prepare

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Wang Qing <wangqing@vivo.com>
commit abbaa433de07076fb8ef524b77ce55d94bad5fc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/abbaa433.failed

There is a bug when passing zero to PTR_ERR() and return.
Fix the smatch error.

Fixes: c4d0bfb45068 ("bpf: Add bpf_snprintf_btf helper")
	Signed-off-by: Wang Qing <wangqing@vivo.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Yonghong Song <yhs@fb.com>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/1604735144-686-1-git-send-email-wangqing@vivo.com
(cherry picked from commit abbaa433de07076fb8ef524b77ce55d94bad5fc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/bpf_trace.c
diff --cc kernel/trace/bpf_trace.c
index fa9081cef38b,5113fd423cdf..000000000000
--- a/kernel/trace/bpf_trace.c
+++ b/kernel/trace/bpf_trace.c
@@@ -1086,6 -1127,118 +1086,121 @@@ static const struct bpf_func_proto bpf_
  	.arg1_type	= ARG_ANYTHING,
  };
  
++<<<<<<< HEAD
++=======
+ BPF_CALL_3(bpf_d_path, struct path *, path, char *, buf, u32, sz)
+ {
+ 	long len;
+ 	char *p;
+ 
+ 	if (!sz)
+ 		return 0;
+ 
+ 	p = d_path(path, buf, sz);
+ 	if (IS_ERR(p)) {
+ 		len = PTR_ERR(p);
+ 	} else {
+ 		len = buf + sz - p;
+ 		memmove(buf, p, len);
+ 	}
+ 
+ 	return len;
+ }
+ 
+ BTF_SET_START(btf_allowlist_d_path)
+ #ifdef CONFIG_SECURITY
+ BTF_ID(func, security_file_permission)
+ BTF_ID(func, security_inode_getattr)
+ BTF_ID(func, security_file_open)
+ #endif
+ #ifdef CONFIG_SECURITY_PATH
+ BTF_ID(func, security_path_truncate)
+ #endif
+ BTF_ID(func, vfs_truncate)
+ BTF_ID(func, vfs_fallocate)
+ BTF_ID(func, dentry_open)
+ BTF_ID(func, vfs_getattr)
+ BTF_ID(func, filp_close)
+ BTF_SET_END(btf_allowlist_d_path)
+ 
+ static bool bpf_d_path_allowed(const struct bpf_prog *prog)
+ {
+ 	return btf_id_set_contains(&btf_allowlist_d_path, prog->aux->attach_btf_id);
+ }
+ 
+ BTF_ID_LIST_SINGLE(bpf_d_path_btf_ids, struct, path)
+ 
+ static const struct bpf_func_proto bpf_d_path_proto = {
+ 	.func		= bpf_d_path,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_BTF_ID,
+ 	.arg1_btf_id	= &bpf_d_path_btf_ids[0],
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE_OR_ZERO,
+ 	.allowed	= bpf_d_path_allowed,
+ };
+ 
+ #define BTF_F_ALL	(BTF_F_COMPACT  | BTF_F_NONAME | \
+ 			 BTF_F_PTR_RAW | BTF_F_ZERO)
+ 
+ static int bpf_btf_printf_prepare(struct btf_ptr *ptr, u32 btf_ptr_size,
+ 				  u64 flags, const struct btf **btf,
+ 				  s32 *btf_id)
+ {
+ 	const struct btf_type *t;
+ 
+ 	if (unlikely(flags & ~(BTF_F_ALL)))
+ 		return -EINVAL;
+ 
+ 	if (btf_ptr_size != sizeof(struct btf_ptr))
+ 		return -EINVAL;
+ 
+ 	*btf = bpf_get_btf_vmlinux();
+ 
+ 	if (IS_ERR_OR_NULL(*btf))
+ 		return IS_ERR(*btf) ? PTR_ERR(*btf) : -EINVAL;
+ 
+ 	if (ptr->type_id > 0)
+ 		*btf_id = ptr->type_id;
+ 	else
+ 		return -EINVAL;
+ 
+ 	if (*btf_id > 0)
+ 		t = btf_type_by_id(*btf, *btf_id);
+ 	if (*btf_id <= 0 || !t)
+ 		return -ENOENT;
+ 
+ 	return 0;
+ }
+ 
+ BPF_CALL_5(bpf_snprintf_btf, char *, str, u32, str_size, struct btf_ptr *, ptr,
+ 	   u32, btf_ptr_size, u64, flags)
+ {
+ 	const struct btf *btf;
+ 	s32 btf_id;
+ 	int ret;
+ 
+ 	ret = bpf_btf_printf_prepare(ptr, btf_ptr_size, flags, &btf, &btf_id);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return btf_type_snprintf_show(btf, btf_id, ptr->ptr, str, str_size,
+ 				      flags);
+ }
+ 
+ const struct bpf_func_proto bpf_snprintf_btf_proto = {
+ 	.func		= bpf_snprintf_btf,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_MEM,
+ 	.arg2_type	= ARG_CONST_SIZE,
+ 	.arg3_type	= ARG_PTR_TO_MEM,
+ 	.arg4_type	= ARG_CONST_SIZE,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
++>>>>>>> abbaa433de07 (bpf: Fix passing zero to PTR_ERR() in bpf_btf_printf_prepare)
  const struct bpf_func_proto *
  bpf_tracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
  {
* Unmerged path kernel/trace/bpf_trace.c
