libbpf: Fix potential multiplication overflow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 8eb629585d2231e90112148009e2a11b0979ca38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/8eb62958.failed

Detected by LGTM static analyze in Github repo, fix potential multiplication
overflow before result is casted to size_t.

Fixes: 8505e8709b5e ("libbpf: Implement generalized .BTF.ext func/line info adjustment")
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20200904041611.1695163-2-andriin@fb.com
(cherry picked from commit 8eb629585d2231e90112148009e2a11b0979ca38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index 133c0050e689,550950eb1860..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -5620,20 -5748,390 +5620,273 @@@ bpf_program__relocate(struct bpf_progra
  				insn[0].imm = (__u32)ext->ksym.addr;
  				insn[1].imm = ext->ksym.addr >> 32;
  			}
 -			relo->processed = true;
  			break;
  		case RELO_CALL:
++<<<<<<< HEAD
 +			err = bpf_program__reloc_text(prog, obj, relo);
++=======
+ 			/* will be handled as a follow up pass */
+ 			break;
+ 		default:
+ 			pr_warn("prog '%s': relo #%d: bad relo type %d\n",
+ 				prog->name, i, relo->type);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int adjust_prog_btf_ext_info(const struct bpf_object *obj,
+ 				    const struct bpf_program *prog,
+ 				    const struct btf_ext_info *ext_info,
+ 				    void **prog_info, __u32 *prog_rec_cnt,
+ 				    __u32 *prog_rec_sz)
+ {
+ 	void *copy_start = NULL, *copy_end = NULL;
+ 	void *rec, *rec_end, *new_prog_info;
+ 	const struct btf_ext_info_sec *sec;
+ 	size_t old_sz, new_sz;
+ 	const char *sec_name;
+ 	int i, off_adj;
+ 
+ 	for_each_btf_ext_sec(ext_info, sec) {
+ 		sec_name = btf__name_by_offset(obj->btf, sec->sec_name_off);
+ 		if (!sec_name)
+ 			return -EINVAL;
+ 		if (strcmp(sec_name, prog->sec_name) != 0)
+ 			continue;
+ 
+ 		for_each_btf_ext_rec(ext_info, sec, i, rec) {
+ 			__u32 insn_off = *(__u32 *)rec / BPF_INSN_SZ;
+ 
+ 			if (insn_off < prog->sec_insn_off)
+ 				continue;
+ 			if (insn_off >= prog->sec_insn_off + prog->sec_insn_cnt)
+ 				break;
+ 
+ 			if (!copy_start)
+ 				copy_start = rec;
+ 			copy_end = rec + ext_info->rec_size;
+ 		}
+ 
+ 		if (!copy_start)
+ 			return -ENOENT;
+ 
+ 		/* append func/line info of a given (sub-)program to the main
+ 		 * program func/line info
+ 		 */
+ 		old_sz = (size_t)(*prog_rec_cnt) * ext_info->rec_size;
+ 		new_sz = old_sz + (copy_end - copy_start);
+ 		new_prog_info = realloc(*prog_info, new_sz);
+ 		if (!new_prog_info)
+ 			return -ENOMEM;
+ 		*prog_info = new_prog_info;
+ 		*prog_rec_cnt = new_sz / ext_info->rec_size;
+ 		memcpy(new_prog_info + old_sz, copy_start, copy_end - copy_start);
+ 
+ 		/* Kernel instruction offsets are in units of 8-byte
+ 		 * instructions, while .BTF.ext instruction offsets generated
+ 		 * by Clang are in units of bytes. So convert Clang offsets
+ 		 * into kernel offsets and adjust offset according to program
+ 		 * relocated position.
+ 		 */
+ 		off_adj = prog->sub_insn_off - prog->sec_insn_off;
+ 		rec = new_prog_info + old_sz;
+ 		rec_end = new_prog_info + new_sz;
+ 		for (; rec < rec_end; rec += ext_info->rec_size) {
+ 			__u32 *insn_off = rec;
+ 
+ 			*insn_off = *insn_off / BPF_INSN_SZ + off_adj;
+ 		}
+ 		*prog_rec_sz = ext_info->rec_size;
+ 		return 0;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static int
+ reloc_prog_func_and_line_info(const struct bpf_object *obj,
+ 			      struct bpf_program *main_prog,
+ 			      const struct bpf_program *prog)
+ {
+ 	int err;
+ 
+ 	/* no .BTF.ext relocation if .BTF.ext is missing or kernel doesn't
+ 	 * supprot func/line info
+ 	 */
+ 	if (!obj->btf_ext || !kernel_supports(FEAT_BTF_FUNC))
+ 		return 0;
+ 
+ 	/* only attempt func info relocation if main program's func_info
+ 	 * relocation was successful
+ 	 */
+ 	if (main_prog != prog && !main_prog->func_info)
+ 		goto line_info;
+ 
+ 	err = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->func_info,
+ 				       &main_prog->func_info,
+ 				       &main_prog->func_info_cnt,
+ 				       &main_prog->func_info_rec_size);
+ 	if (err) {
+ 		if (err != -ENOENT) {
+ 			pr_warn("prog '%s': error relocating .BTF.ext function info: %d\n",
+ 				prog->name, err);
+ 			return err;
+ 		}
+ 		if (main_prog->func_info) {
+ 			/*
+ 			 * Some info has already been found but has problem
+ 			 * in the last btf_ext reloc. Must have to error out.
+ 			 */
+ 			pr_warn("prog '%s': missing .BTF.ext function info.\n", prog->name);
+ 			return err;
+ 		}
+ 		/* Have problem loading the very first info. Ignore the rest. */
+ 		pr_warn("prog '%s': missing .BTF.ext function info for the main program, skipping all of .BTF.ext func info.\n",
+ 			prog->name);
+ 	}
+ 
+ line_info:
+ 	/* don't relocate line info if main program's relocation failed */
+ 	if (main_prog != prog && !main_prog->line_info)
+ 		return 0;
+ 
+ 	err = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->line_info,
+ 				       &main_prog->line_info,
+ 				       &main_prog->line_info_cnt,
+ 				       &main_prog->line_info_rec_size);
+ 	if (err) {
+ 		if (err != -ENOENT) {
+ 			pr_warn("prog '%s': error relocating .BTF.ext line info: %d\n",
+ 				prog->name, err);
+ 			return err;
+ 		}
+ 		if (main_prog->line_info) {
+ 			/*
+ 			 * Some info has already been found but has problem
+ 			 * in the last btf_ext reloc. Must have to error out.
+ 			 */
+ 			pr_warn("prog '%s': missing .BTF.ext line info.\n", prog->name);
+ 			return err;
+ 		}
+ 		/* Have problem loading the very first info. Ignore the rest. */
+ 		pr_warn("prog '%s': missing .BTF.ext line info for the main program, skipping all of .BTF.ext line info.\n",
+ 			prog->name);
+ 	}
+ 	return 0;
+ }
+ 
+ static int cmp_relo_by_insn_idx(const void *key, const void *elem)
+ {
+ 	size_t insn_idx = *(const size_t *)key;
+ 	const struct reloc_desc *relo = elem;
+ 
+ 	if (insn_idx == relo->insn_idx)
+ 		return 0;
+ 	return insn_idx < relo->insn_idx ? -1 : 1;
+ }
+ 
+ static struct reloc_desc *find_prog_insn_relo(const struct bpf_program *prog, size_t insn_idx)
+ {
+ 	return bsearch(&insn_idx, prog->reloc_desc, prog->nr_reloc,
+ 		       sizeof(*prog->reloc_desc), cmp_relo_by_insn_idx);
+ }
+ 
+ static int
+ bpf_object__reloc_code(struct bpf_object *obj, struct bpf_program *main_prog,
+ 		       struct bpf_program *prog)
+ {
+ 	size_t sub_insn_idx, insn_idx, new_cnt;
+ 	struct bpf_program *subprog;
+ 	struct bpf_insn *insns, *insn;
+ 	struct reloc_desc *relo;
+ 	int err;
+ 
+ 	err = reloc_prog_func_and_line_info(obj, main_prog, prog);
+ 	if (err)
+ 		return err;
+ 
+ 	for (insn_idx = 0; insn_idx < prog->sec_insn_cnt; insn_idx++) {
+ 		insn = &main_prog->insns[prog->sub_insn_off + insn_idx];
+ 		if (!insn_is_subprog_call(insn))
+ 			continue;
+ 
+ 		relo = find_prog_insn_relo(prog, insn_idx);
+ 		if (relo && relo->type != RELO_CALL) {
+ 			pr_warn("prog '%s': unexpected relo for insn #%zu, type %d\n",
+ 				prog->name, insn_idx, relo->type);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 		if (relo) {
+ 			/* sub-program instruction index is a combination of
+ 			 * an offset of a symbol pointed to by relocation and
+ 			 * call instruction's imm field; for global functions,
+ 			 * call always has imm = -1, but for static functions
+ 			 * relocation is against STT_SECTION and insn->imm
+ 			 * points to a start of a static function
+ 			 */
+ 			sub_insn_idx = relo->sym_off / BPF_INSN_SZ + insn->imm + 1;
+ 		} else {
+ 			/* if subprogram call is to a static function within
+ 			 * the same ELF section, there won't be any relocation
+ 			 * emitted, but it also means there is no additional
+ 			 * offset necessary, insns->imm is relative to
+ 			 * instruction's original position within the section
+ 			 */
+ 			sub_insn_idx = prog->sec_insn_off + insn_idx + insn->imm + 1;
+ 		}
+ 
+ 		/* we enforce that sub-programs should be in .text section */
+ 		subprog = find_prog_by_sec_insn(obj, obj->efile.text_shndx, sub_insn_idx);
+ 		if (!subprog) {
+ 			pr_warn("prog '%s': no .text section found yet sub-program call exists\n",
+ 				prog->name);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 
+ 		/* if it's the first call instruction calling into this
+ 		 * subprogram (meaning this subprog hasn't been processed
+ 		 * yet) within the context of current main program:
+ 		 *   - append it at the end of main program's instructions blog;
+ 		 *   - process is recursively, while current program is put on hold;
+ 		 *   - if that subprogram calls some other not yet processes
+ 		 *   subprogram, same thing will happen recursively until
+ 		 *   there are no more unprocesses subprograms left to append
+ 		 *   and relocate.
+ 		 */
+ 		if (subprog->sub_insn_off == 0) {
+ 			subprog->sub_insn_off = main_prog->insns_cnt;
+ 
+ 			new_cnt = main_prog->insns_cnt + subprog->insns_cnt;
+ 			insns = libbpf_reallocarray(main_prog->insns, new_cnt, sizeof(*insns));
+ 			if (!insns) {
+ 				pr_warn("prog '%s': failed to realloc prog code\n", main_prog->name);
+ 				return -ENOMEM;
+ 			}
+ 			main_prog->insns = insns;
+ 			main_prog->insns_cnt = new_cnt;
+ 
+ 			memcpy(main_prog->insns + subprog->sub_insn_off, subprog->insns,
+ 			       subprog->insns_cnt * sizeof(*insns));
+ 
+ 			pr_debug("prog '%s': added %zu insns from sub-prog '%s'\n",
+ 				 main_prog->name, subprog->insns_cnt, subprog->name);
+ 
+ 			err = bpf_object__reloc_code(obj, main_prog, subprog);
++>>>>>>> 8eb629585d22 (libbpf: Fix potential multiplication overflow)
  			if (err)
  				return err;
 +			break;
 +		default:
 +			pr_warn("relo #%d: bad relo type %d\n", i, relo->type);
 +			return -EINVAL;
  		}
 -
 -		/* main_prog->insns memory could have been re-allocated, so
 -		 * calculate pointer again
 -		 */
 -		insn = &main_prog->insns[prog->sub_insn_off + insn_idx];
 -		/* calculate correct instruction position within current main
 -		 * prog; each main prog can have a different set of
 -		 * subprograms appended (potentially in different order as
 -		 * well), so position of any subprog can be different for
 -		 * different main programs */
 -		insn->imm = subprog->sub_insn_off - (prog->sub_insn_off + insn_idx) - 1;
 -
 -		if (relo)
 -			relo->processed = true;
 -
 -		pr_debug("prog '%s': insn #%zu relocated, imm %d points to subprog '%s' (now at %zu offset)\n",
 -			 prog->name, insn_idx, insn->imm, subprog->name, subprog->sub_insn_off);
 -	}
 -
 -	return 0;
 -}
 -
 -/*
 - * Relocate sub-program calls.
 - *
 - * Algorithm operates as follows. Each entry-point BPF program (referred to as
 - * main prog) is processed separately. For each subprog (non-entry functions,
 - * that can be called from either entry progs or other subprogs) gets their
 - * sub_insn_off reset to zero. This serves as indicator that this subprogram
 - * hasn't been yet appended and relocated within current main prog. Once its
 - * relocated, sub_insn_off will point at the position within current main prog
 - * where given subprog was appended. This will further be used to relocate all
 - * the call instructions jumping into this subprog.
 - *
 - * We start with main program and process all call instructions. If the call
 - * is into a subprog that hasn't been processed (i.e., subprog->sub_insn_off
 - * is zero), subprog instructions are appended at the end of main program's
 - * instruction array. Then main program is "put on hold" while we recursively
 - * process newly appended subprogram. If that subprogram calls into another
 - * subprogram that hasn't been appended, new subprogram is appended again to
 - * the *main* prog's instructions (subprog's instructions are always left
 - * untouched, as they need to be in unmodified state for subsequent main progs
 - * and subprog instructions are always sent only as part of a main prog) and
 - * the process continues recursively. Once all the subprogs called from a main
 - * prog or any of its subprogs are appended (and relocated), all their
 - * positions within finalized instructions array are known, so it's easy to
 - * rewrite call instructions with correct relative offsets, corresponding to
 - * desired target subprog.
 - *
 - * Its important to realize that some subprogs might not be called from some
 - * main prog and any of its called/used subprogs. Those will keep their
 - * subprog->sub_insn_off as zero at all times and won't be appended to current
 - * main prog and won't be relocated within the context of current main prog.
 - * They might still be used from other main progs later.
 - *
 - * Visually this process can be shown as below. Suppose we have two main
 - * programs mainA and mainB and BPF object contains three subprogs: subA,
 - * subB, and subC. mainA calls only subA, mainB calls only subC, but subA and
 - * subC both call subB:
 - *
 - *        +--------+ +-------+
 - *        |        v v       |
 - *     +--+---+ +--+-+-+ +---+--+
 - *     | subA | | subB | | subC |
 - *     +--+---+ +------+ +---+--+
 - *        ^                  ^
 - *        |                  |
 - *    +---+-------+   +------+----+
 - *    |   mainA   |   |   mainB   |
 - *    +-----------+   +-----------+
 - *
 - * We'll start relocating mainA, will find subA, append it and start
 - * processing sub A recursively:
 - *
 - *    +-----------+------+
 - *    |   mainA   | subA |
 - *    +-----------+------+
 - *
 - * At this point we notice that subB is used from subA, so we append it and
 - * relocate (there are no further subcalls from subB):
 - *
 - *    +-----------+------+------+
 - *    |   mainA   | subA | subB |
 - *    +-----------+------+------+
 - *
 - * At this point, we relocate subA calls, then go one level up and finish with
 - * relocatin mainA calls. mainA is done.
 - *
 - * For mainB process is similar but results in different order. We start with
 - * mainB and skip subA and subB, as mainB never calls them (at least
 - * directly), but we see subC is needed, so we append and start processing it:
 - *
 - *    +-----------+------+
 - *    |   mainB   | subC |
 - *    +-----------+------+
 - * Now we see subC needs subB, so we go back to it, append and relocate it:
 - *
 - *    +-----------+------+------+
 - *    |   mainB   | subC | subB |
 - *    +-----------+------+------+
 - *
 - * At this point we unwind recursion, relocate calls in subC, then in mainB.
 - */
 -static int
 -bpf_object__relocate_calls(struct bpf_object *obj, struct bpf_program *prog)
 -{
 -	struct bpf_program *subprog;
 -	int i, j, err;
 -
 -	/* mark all subprogs as not relocated (yet) within the context of
 -	 * current main program
 -	 */
 -	for (i = 0; i < obj->nr_programs; i++) {
 -		subprog = &obj->programs[i];
 -		if (!prog_is_subprog(obj, subprog))
 -			continue;
 -
 -		subprog->sub_insn_off = 0;
 -		for (j = 0; j < subprog->nr_reloc; j++)
 -			if (subprog->reloc_desc[j].type == RELO_CALL)
 -				subprog->reloc_desc[j].processed = false;
  	}
  
 -	err = bpf_object__reloc_code(obj, prog, prog);
 -	if (err)
 -		return err;
 -
 -
 +	zfree(&prog->reloc_desc);
 +	prog->nr_reloc = 0;
  	return 0;
  }
  
* Unmerged path tools/lib/bpf/libbpf.c
