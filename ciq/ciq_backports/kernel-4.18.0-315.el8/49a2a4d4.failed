kernel/bpf/verifier: Fix build when NET is not enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Randy Dunlap <rdunlap@infradead.org>
commit 49a2a4d4163f95e36e2bec50e06813b73401bc76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/49a2a4d4.failed

Fix build errors in kernel/bpf/verifier.c when CONFIG_NET is
not enabled.

../kernel/bpf/verifier.c:3995:13: error: ‘btf_sock_ids’ undeclared here (not in a function); did you mean ‘bpf_sock_ops’?
  .btf_id = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],

../kernel/bpf/verifier.c:3995:26: error: ‘BTF_SOCK_TYPE_SOCK_COMMON’ undeclared here (not in a function); did you mean ‘PTR_TO_SOCK_COMMON’?
  .btf_id = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],

Fixes: 1df8f55a37bd ("bpf: Enable bpf_skc_to_* sock casting helper to networking prog type")
	Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Yonghong Song <yhs@fb.com>
Link: https://lore.kernel.org/bpf/20201007021613.13646-1-rdunlap@infradead.org
(cherry picked from commit 49a2a4d4163f95e36e2bec50e06813b73401bc76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index 9cd242ebc598,62b804651a48..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -3937,6 -3961,159 +3937,162 @@@ static int resolve_map_arg_type(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct bpf_reg_types {
+ 	const enum bpf_reg_type types[10];
+ 	u32 *btf_id;
+ };
+ 
+ static const struct bpf_reg_types map_key_value_types = {
+ 	.types = {
+ 		PTR_TO_STACK,
+ 		PTR_TO_PACKET,
+ 		PTR_TO_PACKET_META,
+ 		PTR_TO_MAP_VALUE,
+ 	},
+ };
+ 
+ static const struct bpf_reg_types sock_types = {
+ 	.types = {
+ 		PTR_TO_SOCK_COMMON,
+ 		PTR_TO_SOCKET,
+ 		PTR_TO_TCP_SOCK,
+ 		PTR_TO_XDP_SOCK,
+ 	},
+ };
+ 
+ #ifdef CONFIG_NET
+ static const struct bpf_reg_types btf_id_sock_common_types = {
+ 	.types = {
+ 		PTR_TO_SOCK_COMMON,
+ 		PTR_TO_SOCKET,
+ 		PTR_TO_TCP_SOCK,
+ 		PTR_TO_XDP_SOCK,
+ 		PTR_TO_BTF_ID,
+ 	},
+ 	.btf_id = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],
+ };
+ #endif
+ 
+ static const struct bpf_reg_types mem_types = {
+ 	.types = {
+ 		PTR_TO_STACK,
+ 		PTR_TO_PACKET,
+ 		PTR_TO_PACKET_META,
+ 		PTR_TO_MAP_VALUE,
+ 		PTR_TO_MEM,
+ 		PTR_TO_RDONLY_BUF,
+ 		PTR_TO_RDWR_BUF,
+ 	},
+ };
+ 
+ static const struct bpf_reg_types int_ptr_types = {
+ 	.types = {
+ 		PTR_TO_STACK,
+ 		PTR_TO_PACKET,
+ 		PTR_TO_PACKET_META,
+ 		PTR_TO_MAP_VALUE,
+ 	},
+ };
+ 
+ static const struct bpf_reg_types fullsock_types = { .types = { PTR_TO_SOCKET } };
+ static const struct bpf_reg_types scalar_types = { .types = { SCALAR_VALUE } };
+ static const struct bpf_reg_types context_types = { .types = { PTR_TO_CTX } };
+ static const struct bpf_reg_types alloc_mem_types = { .types = { PTR_TO_MEM } };
+ static const struct bpf_reg_types const_map_ptr_types = { .types = { CONST_PTR_TO_MAP } };
+ static const struct bpf_reg_types btf_ptr_types = { .types = { PTR_TO_BTF_ID } };
+ static const struct bpf_reg_types spin_lock_types = { .types = { PTR_TO_MAP_VALUE } };
+ static const struct bpf_reg_types percpu_btf_ptr_types = { .types = { PTR_TO_PERCPU_BTF_ID } };
+ 
+ static const struct bpf_reg_types *compatible_reg_types[__BPF_ARG_TYPE_MAX] = {
+ 	[ARG_PTR_TO_MAP_KEY]		= &map_key_value_types,
+ 	[ARG_PTR_TO_MAP_VALUE]		= &map_key_value_types,
+ 	[ARG_PTR_TO_UNINIT_MAP_VALUE]	= &map_key_value_types,
+ 	[ARG_PTR_TO_MAP_VALUE_OR_NULL]	= &map_key_value_types,
+ 	[ARG_CONST_SIZE]		= &scalar_types,
+ 	[ARG_CONST_SIZE_OR_ZERO]	= &scalar_types,
+ 	[ARG_CONST_ALLOC_SIZE_OR_ZERO]	= &scalar_types,
+ 	[ARG_CONST_MAP_PTR]		= &const_map_ptr_types,
+ 	[ARG_PTR_TO_CTX]		= &context_types,
+ 	[ARG_PTR_TO_CTX_OR_NULL]	= &context_types,
+ 	[ARG_PTR_TO_SOCK_COMMON]	= &sock_types,
+ #ifdef CONFIG_NET
+ 	[ARG_PTR_TO_BTF_ID_SOCK_COMMON]	= &btf_id_sock_common_types,
+ #endif
+ 	[ARG_PTR_TO_SOCKET]		= &fullsock_types,
+ 	[ARG_PTR_TO_SOCKET_OR_NULL]	= &fullsock_types,
+ 	[ARG_PTR_TO_BTF_ID]		= &btf_ptr_types,
+ 	[ARG_PTR_TO_SPIN_LOCK]		= &spin_lock_types,
+ 	[ARG_PTR_TO_MEM]		= &mem_types,
+ 	[ARG_PTR_TO_MEM_OR_NULL]	= &mem_types,
+ 	[ARG_PTR_TO_UNINIT_MEM]		= &mem_types,
+ 	[ARG_PTR_TO_ALLOC_MEM]		= &alloc_mem_types,
+ 	[ARG_PTR_TO_ALLOC_MEM_OR_NULL]	= &alloc_mem_types,
+ 	[ARG_PTR_TO_INT]		= &int_ptr_types,
+ 	[ARG_PTR_TO_LONG]		= &int_ptr_types,
+ 	[ARG_PTR_TO_PERCPU_BTF_ID]	= &percpu_btf_ptr_types,
+ };
+ 
+ static int check_reg_type(struct bpf_verifier_env *env, u32 regno,
+ 			  enum bpf_arg_type arg_type,
+ 			  const u32 *arg_btf_id)
+ {
+ 	struct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];
+ 	enum bpf_reg_type expected, type = reg->type;
+ 	const struct bpf_reg_types *compatible;
+ 	int i, j;
+ 
+ 	compatible = compatible_reg_types[arg_type];
+ 	if (!compatible) {
+ 		verbose(env, "verifier internal error: unsupported arg type %d\n", arg_type);
+ 		return -EFAULT;
+ 	}
+ 
+ 	for (i = 0; i < ARRAY_SIZE(compatible->types); i++) {
+ 		expected = compatible->types[i];
+ 		if (expected == NOT_INIT)
+ 			break;
+ 
+ 		if (type == expected)
+ 			goto found;
+ 	}
+ 
+ 	verbose(env, "R%d type=%s expected=", regno, reg_type_str[type]);
+ 	for (j = 0; j + 1 < i; j++)
+ 		verbose(env, "%s, ", reg_type_str[compatible->types[j]]);
+ 	verbose(env, "%s\n", reg_type_str[compatible->types[j]]);
+ 	return -EACCES;
+ 
+ found:
+ 	if (type == PTR_TO_BTF_ID) {
+ 		if (!arg_btf_id) {
+ 			if (!compatible->btf_id) {
+ 				verbose(env, "verifier internal error: missing arg compatible BTF ID\n");
+ 				return -EFAULT;
+ 			}
+ 			arg_btf_id = compatible->btf_id;
+ 		}
+ 
+ 		if (!btf_struct_ids_match(&env->log, reg->off, reg->btf_id,
+ 					  *arg_btf_id)) {
+ 			verbose(env, "R%d is of type %s but %s is expected\n",
+ 				regno, kernel_type_name(reg->btf_id),
+ 				kernel_type_name(*arg_btf_id));
+ 			return -EACCES;
+ 		}
+ 
+ 		if (!tnum_is_const(reg->var_off) || reg->var_off.value) {
+ 			verbose(env, "R%d is a pointer to in-kernel struct with non-zero offset\n",
+ 				regno);
+ 			return -EACCES;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 49a2a4d4163f (kernel/bpf/verifier: Fix build when NET is not enabled)
  static int check_func_arg(struct bpf_verifier_env *env, u32 arg,
  			  struct bpf_call_arg_meta *meta,
  			  const struct bpf_func_proto *fn)
* Unmerged path kernel/bpf/verifier.c
