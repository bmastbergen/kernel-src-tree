bpf: Deref map in BPF_PROG_BIND_MAP when it's already used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit 1028ae4069991e26d1522e957939fb61d2da1d12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/1028ae40.failed

We are missing a deref for the case when we are doing BPF_PROG_BIND_MAP
on a map that's being already held by the program.
There is 'if (ret) bpf_map_put(map)' below which doesn't trigger
because we don't consider this an error.
Let's add missing bpf_map_put() for this specific condition.

Fixes: ef15314aa5de ("bpf: Add BPF_PROG_BIND_MAP syscall")
	Reported-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20201003002544.3601440-1-sdf@google.com
(cherry picked from commit 1028ae4069991e26d1522e957939fb61d2da1d12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/syscall.c
diff --cc kernel/bpf/syscall.c
index 70e6c7e995cb,1110ecd7d1f3..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -4311,6 -4293,68 +4311,71 @@@ static int bpf_iter_create(union bpf_at
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ #define BPF_PROG_BIND_MAP_LAST_FIELD prog_bind_map.flags
+ 
+ static int bpf_prog_bind_map(union bpf_attr *attr)
+ {
+ 	struct bpf_prog *prog;
+ 	struct bpf_map *map;
+ 	struct bpf_map **used_maps_old, **used_maps_new;
+ 	int i, ret = 0;
+ 
+ 	if (CHECK_ATTR(BPF_PROG_BIND_MAP))
+ 		return -EINVAL;
+ 
+ 	if (attr->prog_bind_map.flags)
+ 		return -EINVAL;
+ 
+ 	prog = bpf_prog_get(attr->prog_bind_map.prog_fd);
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	map = bpf_map_get(attr->prog_bind_map.map_fd);
+ 	if (IS_ERR(map)) {
+ 		ret = PTR_ERR(map);
+ 		goto out_prog_put;
+ 	}
+ 
+ 	mutex_lock(&prog->aux->used_maps_mutex);
+ 
+ 	used_maps_old = prog->aux->used_maps;
+ 
+ 	for (i = 0; i < prog->aux->used_map_cnt; i++)
+ 		if (used_maps_old[i] == map) {
+ 			bpf_map_put(map);
+ 			goto out_unlock;
+ 		}
+ 
+ 	used_maps_new = kmalloc_array(prog->aux->used_map_cnt + 1,
+ 				      sizeof(used_maps_new[0]),
+ 				      GFP_KERNEL);
+ 	if (!used_maps_new) {
+ 		ret = -ENOMEM;
+ 		goto out_unlock;
+ 	}
+ 
+ 	memcpy(used_maps_new, used_maps_old,
+ 	       sizeof(used_maps_old[0]) * prog->aux->used_map_cnt);
+ 	used_maps_new[prog->aux->used_map_cnt] = map;
+ 
+ 	prog->aux->used_map_cnt++;
+ 	prog->aux->used_maps = used_maps_new;
+ 
+ 	kfree(used_maps_old);
+ 
+ out_unlock:
+ 	mutex_unlock(&prog->aux->used_maps_mutex);
+ 
+ 	if (ret)
+ 		bpf_map_put(map);
+ out_prog_put:
+ 	bpf_prog_put(prog);
+ 	return ret;
+ }
+ 
++>>>>>>> 1028ae406999 (bpf: Deref map in BPF_PROG_BIND_MAP when it's already used)
  SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)
  {
  	union bpf_attr attr;
* Unmerged path kernel/bpf/syscall.c
