xsk: Fix possible crash in socket_release when out-of-memory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit 1fd17c8cd0aa636afcf441ee23023b5a7cba4efa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/1fd17c8c.failed

Fix possible crash in socket_release when an out-of-memory error has
occurred in the bind call. If a socket using the XDP_SHARED_UMEM flag
encountered an error in xp_create_and_assign_umem, the bind code
jumped to the exit routine but erroneously forgot to set the err value
before jumping. This meant that the exit routine thought the setup
went well and set the state of the socket to XSK_BOUND. The xsk socket
release code will then, at application exit, think that this is a
properly setup socket, when it is not, leading to a crash when all
fields in the socket have in fact not been initialized properly. Fix
this by setting the err variable in xsk_bind so that the socket is not
set to XSK_BOUND which leads to the clean-up in xsk_release not being
triggered.

Fixes: 1c1efc2af158 ("xsk: Create and free buffer pool independently from umem")
	Reported-by: syzbot+ddc7b4944bc61da19b81@syzkaller.appspotmail.com
	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/1601112373-10595-1-git-send-email-magnus.karlsson@gmail.com
(cherry picked from commit 1fd17c8cd0aa636afcf441ee23023b5a7cba4efa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xdp/xsk.c
diff --cc net/xdp/xsk.c
index 10c97cce9e3d,ba4dfb17c666..000000000000
--- a/net/xdp/xsk.c
+++ b/net/xdp/xsk.c
@@@ -665,10 -695,38 +665,45 @@@ static int xsk_bind(struct socket *sock
  			sockfd_put(sock);
  			goto out_unlock;
  		}
++<<<<<<< HEAD
 +		if (umem_xs->dev != dev || umem_xs->queue_id != qid) {
 +			err = -EINVAL;
 +			sockfd_put(sock);
 +			goto out_unlock;
++=======
+ 
+ 		if (umem_xs->queue_id != qid || umem_xs->dev != dev) {
+ 			/* Share the umem with another socket on another qid
+ 			 * and/or device.
+ 			 */
+ 			xs->pool = xp_create_and_assign_umem(xs,
+ 							     umem_xs->umem);
+ 			if (!xs->pool) {
+ 				err = -ENOMEM;
+ 				sockfd_put(sock);
+ 				goto out_unlock;
+ 			}
+ 
+ 			err = xp_assign_dev_shared(xs->pool, umem_xs->umem,
+ 						   dev, qid);
+ 			if (err) {
+ 				xp_destroy(xs->pool);
+ 				xs->pool = NULL;
+ 				sockfd_put(sock);
+ 				goto out_unlock;
+ 			}
+ 		} else {
+ 			/* Share the buffer pool with the other socket. */
+ 			if (xs->fq_tmp || xs->cq_tmp) {
+ 				/* Do not allow setting your own fq or cq. */
+ 				err = -EINVAL;
+ 				sockfd_put(sock);
+ 				goto out_unlock;
+ 			}
+ 
+ 			xp_get_pool(umem_xs->pool);
+ 			xs->pool = umem_xs->pool;
++>>>>>>> 1fd17c8cd0aa (xsk: Fix possible crash in socket_release when out-of-memory)
  		}
  
  		xdp_get_umem(umem_xs->umem);
* Unmerged path net/xdp/xsk.c
