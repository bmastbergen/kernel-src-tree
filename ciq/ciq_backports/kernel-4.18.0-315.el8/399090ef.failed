mt76: mt76_connac: move hw_scan and sched_scan routine in mt76_connac_mcu module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 399090ef96059da9cc6459e2d68347a27254bbf5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/399090ef.failed

Move hw_scan/sched_scan in mt76_connac_mcu module in order to be reused in
mt7615 and mt7921 drivers

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 399090ef96059da9cc6459e2d68347a27254bbf5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
#	drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
#	drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
index bb481662d3c5,8efe64962f10..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
@@@ -2954,314 -2231,6 +2954,317 @@@ int mt7615_mcu_set_sku_en(struct mt7615
  				 sizeof(req), true);
  }
  
++<<<<<<< HEAD
 +int mt7615_mcu_set_vif_ps(struct mt7615_dev *dev, struct ieee80211_vif *vif)
 +{
 +	struct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;
 +	struct {
 +		u8 bss_idx;
 +		u8 ps_state; /* 0: device awake
 +			      * 1: static power save
 +			      * 2: dynamic power saving
 +			      */
 +	} req = {
 +		.bss_idx = mvif->idx,
 +		.ps_state = vif->bss_conf.ps ? 2 : 0,
 +	};
 +
 +	if (vif->type != NL80211_IFTYPE_STATION)
 +		return -ENOTSUPP;
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_CMD_SET_PS_PROFILE, &req,
 +				 sizeof(req), false);
 +}
 +
 +int mt7615_mcu_set_channel_domain(struct mt7615_phy *phy)
 +{
 +	struct mt76_phy *mphy = phy->mt76;
 +	struct mt7615_dev *dev = phy->dev;
 +	struct mt7615_mcu_channel_domain {
 +		u8 alpha2[4]; /* regulatory_request.alpha2 */
 +		u8 bw_2g; /* BW_20_40M		0
 +			   * BW_20M		1
 +			   * BW_20_40_80M	2
 +			   * BW_20_40_80_160M	3
 +			   * BW_20_40_80_8080M	4
 +			   */
 +		u8 bw_5g;
 +		__le16 pad;
 +		u8 n_2ch;
 +		u8 n_5ch;
 +		__le16 pad2;
 +	} __packed hdr = {
 +		.bw_2g = 0,
 +		.bw_5g = 3,
 +	};
 +	struct mt7615_mcu_chan {
 +		__le16 hw_value;
 +		__le16 pad;
 +		__le32 flags;
 +	} __packed channel;
 +	int len, i, n_max_channels, n_2ch = 0, n_5ch = 0;
 +	struct ieee80211_channel *chan;
 +	struct sk_buff *skb;
 +
 +	if (!mt7615_firmware_offload(dev))
 +		return 0;
 +
 +	n_max_channels = mphy->sband_2g.sband.n_channels +
 +			 mphy->sband_5g.sband.n_channels;
 +	len = sizeof(hdr) + n_max_channels * sizeof(channel);
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_reserve(skb, sizeof(hdr));
 +
 +	for (i = 0; i < mphy->sband_2g.sband.n_channels; i++) {
 +		chan = &mphy->sband_2g.sband.channels[i];
 +		if (chan->flags & IEEE80211_CHAN_DISABLED)
 +			continue;
 +
 +		channel.hw_value = cpu_to_le16(chan->hw_value);
 +		channel.flags = cpu_to_le32(chan->flags);
 +		channel.pad = 0;
 +
 +		skb_put_data(skb, &channel, sizeof(channel));
 +		n_2ch++;
 +	}
 +	for (i = 0; i < mphy->sband_5g.sband.n_channels; i++) {
 +		chan = &mphy->sband_5g.sband.channels[i];
 +		if (chan->flags & IEEE80211_CHAN_DISABLED)
 +			continue;
 +
 +		channel.hw_value = cpu_to_le16(chan->hw_value);
 +		channel.flags = cpu_to_le32(chan->flags);
 +		channel.pad = 0;
 +
 +		skb_put_data(skb, &channel, sizeof(channel));
 +		n_5ch++;
 +	}
 +
 +	BUILD_BUG_ON(sizeof(dev->mt76.alpha2) > sizeof(hdr.alpha2));
 +	memcpy(hdr.alpha2, dev->mt76.alpha2, sizeof(dev->mt76.alpha2));
 +	hdr.n_2ch = n_2ch;
 +	hdr.n_5ch = n_5ch;
 +
 +	memcpy(__skb_push(skb, sizeof(hdr)), &hdr, sizeof(hdr));
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_CMD_SET_CHAN_DOMAIN,
 +				     false);
 +}
 +
 +#define MT7615_SCAN_CHANNEL_TIME	60
 +int mt7615_mcu_hw_scan(struct mt7615_phy *phy, struct ieee80211_vif *vif,
 +		       struct ieee80211_scan_request *scan_req)
 +{
 +	struct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;
 +	struct cfg80211_scan_request *sreq = &scan_req->req;
 +	int n_ssids = 0, err, i, duration = MT7615_SCAN_CHANNEL_TIME;
 +	int ext_channels_num = max_t(int, sreq->n_channels - 32, 0);
 +	struct ieee80211_channel **scan_list = sreq->channels;
 +	struct mt7615_dev *dev = phy->dev;
 +	bool ext_phy = phy != &dev->phy;
 +	struct mt7615_mcu_scan_channel *chan;
 +	struct mt7615_hw_scan_req *req;
 +	struct sk_buff *skb;
 +
 +	/* fall-back to sw-scan */
 +	if (!mt7615_firmware_offload(dev))
 +		return 1;
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(*req));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	set_bit(MT76_HW_SCANNING, &phy->mt76->state);
 +	mvif->scan_seq_num = (mvif->scan_seq_num + 1) & 0x7f;
 +
 +	req = (struct mt7615_hw_scan_req *)skb_put(skb, sizeof(*req));
 +
 +	req->seq_num = mvif->scan_seq_num | ext_phy << 7;
 +	req->bss_idx = mvif->idx;
 +	req->scan_type = sreq->n_ssids ? 1 : 0;
 +	req->probe_req_num = sreq->n_ssids ? 2 : 0;
 +	req->version = 1;
 +
 +	for (i = 0; i < sreq->n_ssids; i++) {
 +		if (!sreq->ssids[i].ssid_len)
 +			continue;
 +
 +		req->ssids[i].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);
 +		memcpy(req->ssids[i].ssid, sreq->ssids[i].ssid,
 +		       sreq->ssids[i].ssid_len);
 +		n_ssids++;
 +	}
 +	req->ssid_type = n_ssids ? BIT(2) : BIT(0);
 +	req->ssid_type_ext = n_ssids ? BIT(0) : 0;
 +	req->ssids_num = n_ssids;
 +
 +	/* increase channel time for passive scan */
 +	if (!sreq->n_ssids)
 +		duration *= 2;
 +	req->timeout_value = cpu_to_le16(sreq->n_channels * duration);
 +	req->channel_min_dwell_time = cpu_to_le16(duration);
 +	req->channel_dwell_time = cpu_to_le16(duration);
 +
 +	req->channels_num = min_t(u8, sreq->n_channels, 32);
 +	req->ext_channels_num = min_t(u8, ext_channels_num, 32);
 +	for (i = 0; i < req->channels_num + req->ext_channels_num; i++) {
 +		if (i >= 32)
 +			chan = &req->ext_channels[i - 32];
 +		else
 +			chan = &req->channels[i];
 +
 +		chan->band = scan_list[i]->band == NL80211_BAND_2GHZ ? 1 : 2;
 +		chan->channel_num = scan_list[i]->hw_value;
 +	}
 +	req->channel_type = sreq->n_channels ? 4 : 0;
 +
 +	if (sreq->ie_len > 0) {
 +		memcpy(req->ies, sreq->ie, sreq->ie_len);
 +		req->ies_len = cpu_to_le16(sreq->ie_len);
 +	}
 +
 +	memcpy(req->bssid, sreq->bssid, ETH_ALEN);
 +	if (sreq->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {
 +		get_random_mask_addr(req->random_mac, sreq->mac_addr,
 +				     sreq->mac_addr_mask);
 +		req->scan_func = 1;
 +	}
 +
 +	err = mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_CMD_START_HW_SCAN,
 +				    false);
 +	if (err < 0)
 +		clear_bit(MT76_HW_SCANNING, &phy->mt76->state);
 +
 +	return err;
 +}
 +
 +int mt7615_mcu_cancel_hw_scan(struct mt7615_phy *phy,
 +			      struct ieee80211_vif *vif)
 +{
 +	struct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;
 +	struct mt7615_dev *dev = phy->dev;
 +	struct {
 +		u8 seq_num;
 +		u8 is_ext_channel;
 +		u8 rsv[2];
 +	} __packed req = {
 +		.seq_num = mvif->scan_seq_num,
 +	};
 +
 +	if (test_and_clear_bit(MT76_HW_SCANNING, &phy->mt76->state)) {
 +		struct cfg80211_scan_info info = {
 +			.aborted = true,
 +		};
 +
 +		ieee80211_scan_completed(phy->mt76->hw, &info);
 +	}
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_CMD_CANCEL_HW_SCAN, &req,
 +				 sizeof(req), false);
 +}
 +
 +int mt7615_mcu_sched_scan_req(struct mt7615_phy *phy,
 +			      struct ieee80211_vif *vif,
 +			      struct cfg80211_sched_scan_request *sreq)
 +{
 +	struct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;
 +	struct ieee80211_channel **scan_list = sreq->channels;
 +	struct mt7615_dev *dev = phy->dev;
 +	bool ext_phy = phy != &dev->phy;
 +	struct mt7615_mcu_scan_channel *chan;
 +	struct mt7615_sched_scan_req *req;
 +	struct cfg80211_match_set *match;
 +	struct cfg80211_ssid *ssid;
 +	struct sk_buff *skb;
 +	int i;
 +
 +	if (!mt7615_firmware_offload(dev))
 +		return -ENOTSUPP;
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(*req) + sreq->ie_len);
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	mvif->scan_seq_num = (mvif->scan_seq_num + 1) & 0x7f;
 +
 +	req = (struct mt7615_sched_scan_req *)skb_put(skb, sizeof(*req));
 +	req->version = 1;
 +	req->seq_num = mvif->scan_seq_num | ext_phy << 7;
 +
 +	if (sreq->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {
 +		get_random_mask_addr(req->random_mac, sreq->mac_addr,
 +				     sreq->mac_addr_mask);
 +		req->scan_func = 1;
 +	}
 +
 +	req->ssids_num = sreq->n_ssids;
 +	for (i = 0; i < req->ssids_num; i++) {
 +		ssid = &sreq->ssids[i];
 +		memcpy(req->ssids[i].ssid, ssid->ssid, ssid->ssid_len);
 +		req->ssids[i].ssid_len = cpu_to_le32(ssid->ssid_len);
 +	}
 +
 +	req->match_num = sreq->n_match_sets;
 +	for (i = 0; i < req->match_num; i++) {
 +		match = &sreq->match_sets[i];
 +		memcpy(req->match[i].ssid, match->ssid.ssid,
 +		       match->ssid.ssid_len);
 +		req->match[i].rssi_th = cpu_to_le32(match->rssi_thold);
 +		req->match[i].ssid_len = match->ssid.ssid_len;
 +	}
 +
 +	req->channel_type = sreq->n_channels ? 4 : 0;
 +	req->channels_num = min_t(u8, sreq->n_channels, 64);
 +	for (i = 0; i < req->channels_num; i++) {
 +		chan = &req->channels[i];
 +		chan->band = scan_list[i]->band == NL80211_BAND_2GHZ ? 1 : 2;
 +		chan->channel_num = scan_list[i]->hw_value;
 +	}
 +
 +	req->intervals_num = sreq->n_scan_plans;
 +	for (i = 0; i < req->intervals_num; i++)
 +		req->intervals[i] = cpu_to_le16(sreq->scan_plans[i].interval);
 +
 +	if (sreq->ie_len > 0) {
 +		req->ie_len = cpu_to_le16(sreq->ie_len);
 +		memcpy(skb_put(skb, sreq->ie_len), sreq->ie, sreq->ie_len);
 +	}
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_CMD_SCHED_SCAN_REQ,
 +				     false);
 +}
 +
 +int mt7615_mcu_sched_scan_enable(struct mt7615_phy *phy,
 +				 struct ieee80211_vif *vif,
 +				 bool enable)
 +{
 +	struct mt7615_dev *dev = phy->dev;
 +	struct {
 +		u8 active; /* 0: enabled 1: disabled */
 +		u8 rsv[3];
 +	} __packed req = {
 +		.active = !enable,
 +	};
 +
 +	if (!mt7615_firmware_offload(dev))
 +		return -ENOTSUPP;
 +
 +	if (enable)
 +		set_bit(MT76_HW_SCHED_SCANNING, &phy->mt76->state);
 +	else
 +		clear_bit(MT76_HW_SCHED_SCANNING, &phy->mt76->state);
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_CMD_SCHED_SCAN_ENABLE, &req,
 +				 sizeof(req), false);
 +}
 +
++=======
++>>>>>>> 399090ef9605 (mt76: mt76_connac: move hw_scan and sched_scan routine in mt76_connac_mcu module)
  static int mt7615_find_freq_idx(const u16 *freqs, int n_freqs, u16 cur)
  {
  	int i;
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
index 6ef5670211d1,69f94b766938..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
@@@ -305,134 -249,6 +305,137 @@@ struct mt7615_mcu_uni_event 
  	__le32 status; /* 0: success, others: fail */
  } __packed;
  
++<<<<<<< HEAD
 +struct mt7615_beacon_loss_event {
 +	u8 bss_idx;
 +	u8 reason;
 +	u8 pad[2];
 +} __packed;
 +
 +struct mt7615_mcu_scan_ssid {
 +	__le32 ssid_len;
 +	u8 ssid[IEEE80211_MAX_SSID_LEN];
 +} __packed;
 +
 +struct mt7615_mcu_scan_channel {
 +	u8 band; /* 1: 2.4GHz
 +		  * 2: 5.0GHz
 +		  * Others: Reserved
 +		  */
 +	u8 channel_num;
 +} __packed;
 +
 +struct mt7615_mcu_scan_match {
 +	__le32 rssi_th;
 +	u8 ssid[IEEE80211_MAX_SSID_LEN];
 +	u8 ssid_len;
 +	u8 rsv[3];
 +} __packed;
 +
 +struct mt7615_hw_scan_req {
 +	u8 seq_num;
 +	u8 bss_idx;
 +	u8 scan_type; /* 0: PASSIVE SCAN
 +		       * 1: ACTIVE SCAN
 +		       */
 +	u8 ssid_type; /* BIT(0) wildcard SSID
 +		       * BIT(1) P2P wildcard SSID
 +		       * BIT(2) specified SSID + wildcard SSID
 +		       * BIT(2) + ssid_type_ext BIT(0) specified SSID only
 +		       */
 +	u8 ssids_num;
 +	u8 probe_req_num; /* Number of probe request for each SSID */
 +	u8 scan_func; /* BIT(0) Enable random MAC scan
 +		       * BIT(1) Disable DBDC scan type 1~3.
 +		       * BIT(2) Use DBDC scan type 3 (dedicated one RF to scan).
 +		       */
 +	u8 version; /* 0: Not support fields after ies.
 +		     * 1: Support fields after ies.
 +		     */
 +	struct mt7615_mcu_scan_ssid ssids[4];
 +	__le16 probe_delay_time;
 +	__le16 channel_dwell_time; /* channel Dwell interval */
 +	__le16 timeout_value;
 +	u8 channel_type; /* 0: Full channels
 +			  * 1: Only 2.4GHz channels
 +			  * 2: Only 5GHz channels
 +			  * 3: P2P social channel only (channel #1, #6 and #11)
 +			  * 4: Specified channels
 +			  * Others: Reserved
 +			  */
 +	u8 channels_num; /* valid when channel_type is 4 */
 +	/* valid when channels_num is set */
 +	struct mt7615_mcu_scan_channel channels[32];
 +	__le16 ies_len;
 +	u8 ies[MT7615_SCAN_IE_LEN];
 +	/* following fields are valid if version > 0 */
 +	u8 ext_channels_num;
 +	u8 ext_ssids_num;
 +	__le16 channel_min_dwell_time;
 +	struct mt7615_mcu_scan_channel ext_channels[32];
 +	struct mt7615_mcu_scan_ssid ext_ssids[6];
 +	u8 bssid[ETH_ALEN];
 +	u8 random_mac[ETH_ALEN]; /* valid when BIT(1) in scan_func is set. */
 +	u8 pad[63];
 +	u8 ssid_type_ext;
 +} __packed;
 +
 +#define SCAN_DONE_EVENT_MAX_CHANNEL_NUM	64
 +struct mt7615_hw_scan_done {
 +	u8 seq_num;
 +	u8 sparse_channel_num;
 +	struct mt7615_mcu_scan_channel sparse_channel;
 +	u8 complete_channel_num;
 +	u8 current_state;
 +	u8 version;
 +	u8 pad;
 +	__le32 beacon_scan_num;
 +	u8 pno_enabled;
 +	u8 pad2[3];
 +	u8 sparse_channel_valid_num;
 +	u8 pad3[3];
 +	u8 channel_num[SCAN_DONE_EVENT_MAX_CHANNEL_NUM];
 +	/* idle format for channel_idle_time
 +	 * 0: first bytes: idle time(ms) 2nd byte: dwell time(ms)
 +	 * 1: first bytes: idle time(8ms) 2nd byte: dwell time(8ms)
 +	 * 2: dwell time (16us)
 +	 */
 +	__le16 channel_idle_time[SCAN_DONE_EVENT_MAX_CHANNEL_NUM];
 +	/* beacon and probe response count */
 +	u8 beacon_probe_num[SCAN_DONE_EVENT_MAX_CHANNEL_NUM];
 +	u8 mdrdy_count[SCAN_DONE_EVENT_MAX_CHANNEL_NUM];
 +	__le32 beacon_2g_num;
 +	__le32 beacon_5g_num;
 +} __packed;
 +
 +struct mt7615_sched_scan_req {
 +	u8 version;
 +	u8 seq_num;
 +	u8 stop_on_match;
 +	u8 ssids_num;
 +	u8 match_num;
 +	u8 pad;
 +	__le16 ie_len;
 +	struct mt7615_mcu_scan_ssid ssids[MT7615_MAX_SCHED_SCAN_SSID];
 +	struct mt7615_mcu_scan_match match[MT7615_MAX_SCAN_MATCH];
 +	u8 channel_type;
 +	u8 channels_num;
 +	u8 intervals_num;
 +	u8 scan_func; /* BIT(0) eable random mac address */
 +	struct mt7615_mcu_scan_channel channels[64];
 +	__le16 intervals[MT7615_MAX_SCHED_SCAN_INTERVAL];
 +	u8 random_mac[ETH_ALEN]; /* valid when BIT(0) in scan_func is set */
 +	u8 pad2[58];
 +} __packed;
 +
 +struct nt7615_sched_scan_done {
 +	u8 seq_num;
 +	u8 status; /* 0: ssid found */
 +	__le16 pad;
 +} __packed;
 +
++=======
++>>>>>>> 399090ef9605 (mt76: mt76_connac: move hw_scan and sched_scan routine in mt76_connac_mcu module)
  struct mt7615_mcu_reg_event {
  	__le32 reg;
  	__le32 val;
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
index 8e80331c345e,0173db8fd0f7..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
@@@ -563,17 -531,6 +558,20 @@@ int mt7615_mcu_set_tx_power(struct mt76
  void mt7615_mcu_exit(struct mt7615_dev *dev);
  void mt7615_mcu_fill_msg(struct mt7615_dev *dev, struct sk_buff *skb,
  			 int cmd, int *wait_seq);
++<<<<<<< HEAD
 +int mt7615_mcu_set_channel_domain(struct mt7615_phy *phy);
 +int mt7615_mcu_hw_scan(struct mt7615_phy *phy, struct ieee80211_vif *vif,
 +		       struct ieee80211_scan_request *scan_req);
 +int mt7615_mcu_cancel_hw_scan(struct mt7615_phy *phy,
 +			      struct ieee80211_vif *vif);
 +int mt7615_mcu_sched_scan_req(struct mt7615_phy *phy,
 +			      struct ieee80211_vif *vif,
 +			      struct cfg80211_sched_scan_request *sreq);
 +int mt7615_mcu_sched_scan_enable(struct mt7615_phy *phy,
 +				 struct ieee80211_vif *vif,
 +				 bool enable);
++=======
++>>>>>>> 399090ef9605 (mt76: mt76_connac: move hw_scan and sched_scan routine in mt76_connac_mcu module)
  
  int mt7615_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
  			  enum mt76_txq_id qid, struct mt76_wcid *wcid,
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/init.c b/drivers/net/wireless/mediatek/mt76/mt7615/init.c
index 14ddfc27f0d6..8a0c48dd0b1a 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/init.c
@@ -343,11 +343,12 @@ mt7615_init_wiphy(struct ieee80211_hw *hw)
 	}
 	wiphy->reg_notifier = mt7615_regd_notifier;
 
-	wiphy->max_sched_scan_plan_interval = MT7615_MAX_SCHED_SCAN_INTERVAL;
+	wiphy->max_sched_scan_plan_interval =
+		MT76_CONNAC_MAX_SCHED_SCAN_INTERVAL;
 	wiphy->max_sched_scan_ie_len = IEEE80211_MAX_DATA_LEN;
-	wiphy->max_scan_ie_len = MT7615_SCAN_IE_LEN;
-	wiphy->max_sched_scan_ssids = MT7615_MAX_SCHED_SCAN_SSID;
-	wiphy->max_match_sets = MT7615_MAX_SCAN_MATCH;
+	wiphy->max_scan_ie_len = MT76_CONNAC_SCAN_IE_LEN;
+	wiphy->max_sched_scan_ssids = MT76_CONNAC_MAX_SCHED_SCAN_SSID;
+	wiphy->max_match_sets = MT76_CONNAC_MAX_SCAN_MATCH;
 	wiphy->max_sched_scan_reqs = 1;
 	wiphy->max_scan_ssids = 4;
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/main.c b/drivers/net/wireless/mediatek/mt76/mt7615/main.c
index 56dd0b4e4460..ec27e9ca8bb1 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/main.c
@@ -993,8 +993,12 @@ mt7615_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct mt76_phy *mphy = hw->priv;
 	int err;
 
+	/* fall-back to sw-scan */
+	if (!mt7615_firmware_offload(dev))
+		return 1;
+
 	mt7615_mutex_acquire(dev);
-	err = mt7615_mcu_hw_scan(mphy->priv, vif, req);
+	err = mt76_connac_mcu_hw_scan(mphy, vif, req);
 	mt7615_mutex_release(dev);
 
 	return err;
@@ -1007,7 +1011,7 @@ mt7615_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	struct mt76_phy *mphy = hw->priv;
 
 	mt7615_mutex_acquire(dev);
-	mt7615_mcu_cancel_hw_scan(mphy->priv, vif);
+	mt76_connac_mcu_cancel_hw_scan(mphy, vif);
 	mt7615_mutex_release(dev);
 }
 
@@ -1020,13 +1024,16 @@ mt7615_start_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct mt76_phy *mphy = hw->priv;
 	int err;
 
+	if (!mt7615_firmware_offload(dev))
+		return -EOPNOTSUPP;
+
 	mt7615_mutex_acquire(dev);
 
-	err = mt7615_mcu_sched_scan_req(mphy->priv, vif, req);
+	err = mt76_connac_mcu_sched_scan_req(mphy, vif, req);
 	if (err < 0)
 		goto out;
 
-	err = mt7615_mcu_sched_scan_enable(mphy->priv, vif, true);
+	err = mt76_connac_mcu_sched_scan_enable(mphy, vif, true);
 out:
 	mt7615_mutex_release(dev);
 
@@ -1040,8 +1047,11 @@ mt7615_stop_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	struct mt76_phy *mphy = hw->priv;
 	int err;
 
+	if (!mt7615_firmware_offload(dev))
+		return -EOPNOTSUPP;
+
 	mt7615_mutex_acquire(dev);
-	err = mt7615_mcu_sched_scan_enable(mphy->priv, vif, false);
+	err = mt76_connac_mcu_sched_scan_enable(mphy, vif, false);
 	mt7615_mutex_release(dev);
 
 	return err;
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mcu.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
