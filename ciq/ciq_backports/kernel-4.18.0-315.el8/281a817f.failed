scsi: smartpqi: Refactor aio submission code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Don Brace <don.brace@microchip.com>
commit 281a817f232e2f580665e8a45fce1a43899d3007
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/281a817f.failed

Refactor aio submission code:

    1. Break up function pqi_raid_bypass_submit_scsi_cmd()
       into smaller functions.

    2. Add common block (rmd - raid_map_data) to carry around into newly
       added functions.

    3. Prepare for new AIO functionality.

No functional changes.

Link: https://lore.kernel.org/r/161549371553.25025.8840958689316611074.stgit@brunhilda
	Reviewed-by: Scott Benesh <scott.benesh@microchip.com>
	Reviewed-by: Mike McGowen <mike.mcgowen@microchip.com>
	Reviewed-by: Scott Teel <scott.teel@microchip.com>
	Reviewed-by: Kevin Barnett <kevin.barnett@microchip.com>
	Reviewed-by: Martin Wilck <mwilck@suse.com>
	Signed-off-by: Don Brace <don.brace@microchip.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 281a817f232e2f580665e8a45fce1a43899d3007)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/smartpqi/smartpqi_init.c
diff --cc drivers/scsi/smartpqi/smartpqi_init.c
index 57bb771cf3b7,c895d32952c1..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@@ -2277,78 -2273,35 +2304,55 @@@ static int pqi_get_aio_lba_and_block_co
  	/* Check for valid opcode, get LBA and block count. */
  	switch (scmd->cmnd[0]) {
  	case WRITE_6:
++<<<<<<< HEAD
 +		is_write = true;
 +		/* fall through */
++=======
+ 		rmd->is_write = true;
+ 		fallthrough;
++>>>>>>> 281a817f232e (scsi: smartpqi: Refactor aio submission code)
  	case READ_6:
- 		first_block = (u64)(((scmd->cmnd[1] & 0x1f) << 16) |
+ 		rmd->first_block = (u64)(((scmd->cmnd[1] & 0x1f) << 16) |
  			(scmd->cmnd[2] << 8) | scmd->cmnd[3]);
- 		block_cnt = (u32)scmd->cmnd[4];
- 		if (block_cnt == 0)
- 			block_cnt = 256;
+ 		rmd->block_cnt = (u32)scmd->cmnd[4];
+ 		if (rmd->block_cnt == 0)
+ 			rmd->block_cnt = 256;
  		break;
  	case WRITE_10:
++<<<<<<< HEAD
 +		is_write = true;
 +		/* fall through */
++=======
+ 		rmd->is_write = true;
+ 		fallthrough;
++>>>>>>> 281a817f232e (scsi: smartpqi: Refactor aio submission code)
  	case READ_10:
- 		first_block = (u64)get_unaligned_be32(&scmd->cmnd[2]);
- 		block_cnt = (u32)get_unaligned_be16(&scmd->cmnd[7]);
+ 		rmd->first_block = (u64)get_unaligned_be32(&scmd->cmnd[2]);
+ 		rmd->block_cnt = (u32)get_unaligned_be16(&scmd->cmnd[7]);
  		break;
  	case WRITE_12:
++<<<<<<< HEAD
 +		is_write = true;
 +		/* fall through */
++=======
+ 		rmd->is_write = true;
+ 		fallthrough;
++>>>>>>> 281a817f232e (scsi: smartpqi: Refactor aio submission code)
  	case READ_12:
- 		first_block = (u64)get_unaligned_be32(&scmd->cmnd[2]);
- 		block_cnt = get_unaligned_be32(&scmd->cmnd[6]);
+ 		rmd->first_block = (u64)get_unaligned_be32(&scmd->cmnd[2]);
+ 		rmd->block_cnt = get_unaligned_be32(&scmd->cmnd[6]);
  		break;
  	case WRITE_16:
++<<<<<<< HEAD
 +		is_write = true;
 +		/* fall through */
++=======
+ 		rmd->is_write = true;
+ 		fallthrough;
++>>>>>>> 281a817f232e (scsi: smartpqi: Refactor aio submission code)
  	case READ_16:
- 		first_block = get_unaligned_be64(&scmd->cmnd[2]);
- 		block_cnt = get_unaligned_be32(&scmd->cmnd[10]);
+ 		rmd->first_block = get_unaligned_be64(&scmd->cmnd[2]);
+ 		rmd->block_cnt = get_unaligned_be32(&scmd->cmnd[10]);
  		break;
  	default:
  		/* Process via normal I/O path. */
diff --git a/drivers/scsi/smartpqi/smartpqi.h b/drivers/scsi/smartpqi/smartpqi.h
index 7d3f956e949f..01e18da139e3 100644
--- a/drivers/scsi/smartpqi/smartpqi.h
+++ b/drivers/scsi/smartpqi/smartpqi.h
@@ -908,6 +908,58 @@ struct raid_map {
 
 #pragma pack()
 
+struct pqi_scsi_dev_raid_map_data {
+	bool	is_write;
+	u8	raid_level;
+	u32	map_index;
+	u64	first_block;
+	u64	last_block;
+	u32	data_length;
+	u32	block_cnt;
+	u32	blocks_per_row;
+	u64	first_row;
+	u64	last_row;
+	u32	first_row_offset;
+	u32	last_row_offset;
+	u32	first_column;
+	u32	last_column;
+	u64	r5or6_first_row;
+	u64	r5or6_last_row;
+	u32	r5or6_first_row_offset;
+	u32	r5or6_last_row_offset;
+	u32	r5or6_first_column;
+	u32	r5or6_last_column;
+	u16	data_disks_per_row;
+	u32	total_disks_per_row;
+	u16	layout_map_count;
+	u32	stripesize;
+	u16	strip_size;
+	u32	first_group;
+	u32	last_group;
+	u32	current_group;
+	u32	map_row;
+	u32	aio_handle;
+	u64	disk_block;
+	u32	disk_block_cnt;
+	u8	cdb[16];
+	u8	cdb_length;
+	int	offload_to_mirror;
+
+	/* RAID1 specific */
+#define NUM_RAID1_MAP_ENTRIES	3
+	u32	num_it_nexus_entries;
+	u32	it_nexus[NUM_RAID1_MAP_ENTRIES];
+
+	/* RAID5 RAID6 specific */
+	u32	p_parity_it_nexus;	/* aio_handle */
+	u32	q_parity_it_nexus;	/* aio_handle */
+	u8	xor_mult;
+	u64	row;
+	u64	stripe_lba;
+	u32	p_index;
+	u32	q_index;
+};
+
 #define RAID_CTLR_LUNID		"\0\0\0\0\0\0\0\0"
 
 struct pqi_scsi_dev {
* Unmerged path drivers/scsi/smartpqi/smartpqi_init.c
