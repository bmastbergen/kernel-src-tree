iwlwifi: pcie: merge napi_poll_msix functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Mordechay Goodstein <mordechay.goodstein@intel.com>
commit 2b6166664d2b5553953a8a5dee0843f3b1ca18e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/2b616666.failed

The only difference between iwl_pcie_napi_poll_msix_shared() and
iwl_pcie_napi_poll_msix() is when we have a shared queue and nothing
in the rx queue.  This case doesn't affect CPU performance, so we can
merge the two functions.

	Signed-off-by: Mordechay Goodstein <mordechay.goodstein@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Link: https://lore.kernel.org/r/iwlwifi.20210411124417.9d1b61ef53a5.I60b33d5379cf7c12f1de30fc3fd4cefc38220141@changeid
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit 2b6166664d2b5553953a8a5dee0843f3b1ca18e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/pcie/rx.c
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/rx.c
index 42322424f0ef,e4607f943ac3..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/rx.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/rx.c
@@@ -1009,10 -1009,62 +1009,65 @@@ void iwl_pcie_rx_init_rxb_lists(struct 
  	rxq->used_count = 0;
  }
  
 -static int iwl_pcie_rx_handle(struct iwl_trans *trans, int queue, int budget);
 -
 -static int iwl_pcie_napi_poll(struct napi_struct *napi, int budget)
 +int iwl_pcie_dummy_napi_poll(struct napi_struct *napi, int budget)
  {
++<<<<<<< HEAD
 +	WARN_ON(1);
 +	return 0;
++=======
+ 	struct iwl_rxq *rxq = container_of(napi, struct iwl_rxq, napi);
+ 	struct iwl_trans_pcie *trans_pcie;
+ 	struct iwl_trans *trans;
+ 	int ret;
+ 
+ 	trans_pcie = container_of(napi->dev, struct iwl_trans_pcie, napi_dev);
+ 	trans = trans_pcie->trans;
+ 
+ 	ret = iwl_pcie_rx_handle(trans, rxq->id, budget);
+ 
+ 	if (ret < budget) {
+ 		spin_lock(&trans_pcie->irq_lock);
+ 		if (test_bit(STATUS_INT_ENABLED, &trans->status))
+ 			_iwl_enable_interrupts(trans);
+ 		spin_unlock(&trans_pcie->irq_lock);
+ 
+ 		napi_complete_done(&rxq->napi, ret);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int iwl_pcie_napi_poll_msix(struct napi_struct *napi, int budget)
+ {
+ 	struct iwl_rxq *rxq = container_of(napi, struct iwl_rxq, napi);
+ 	struct iwl_trans_pcie *trans_pcie;
+ 	struct iwl_trans *trans;
+ 	int ret;
+ 
+ 	trans_pcie = container_of(napi->dev, struct iwl_trans_pcie, napi_dev);
+ 	trans = trans_pcie->trans;
+ 
+ 	ret = iwl_pcie_rx_handle(trans, rxq->id, budget);
+ 	IWL_DEBUG_ISR(trans, "[%d] handled %d, budget %d\n", rxq->id, ret,
+ 		      budget);
+ 
+ 	if (ret < budget) {
+ 		int irq_line = rxq->id;
+ 
+ 		/* FIRST_RSS is shared with line 0 */
+ 		if (trans_pcie->shared_vec_mask & IWL_SHARED_IRQ_FIRST_RSS &&
+ 		    rxq->id == 1)
+ 			irq_line = 0;
+ 
+ 		spin_lock(&trans_pcie->irq_lock);
+ 		iwl_pcie_clear_irq(trans, irq_line);
+ 		spin_unlock(&trans_pcie->irq_lock);
+ 
+ 		napi_complete_done(&rxq->napi, ret);
+ 	}
+ 
+ 	return ret;
++>>>>>>> 2b6166664d2b (iwlwifi: pcie: merge napi_poll_msix functions)
  }
  
  static int _iwl_pcie_rx_init(struct iwl_trans *trans)
@@@ -1063,11 -1115,19 +1118,22 @@@
  
  		iwl_pcie_rx_init_rxb_lists(rxq);
  
++<<<<<<< HEAD
 +		if (!rxq->napi.poll)
++=======
+ 		spin_unlock_bh(&rxq->lock);
+ 
+ 		if (!rxq->napi.poll) {
+ 			int (*poll)(struct napi_struct *, int) = iwl_pcie_napi_poll;
+ 
+ 			if (trans_pcie->msix_enabled)
+ 				poll = iwl_pcie_napi_poll_msix;
+ 
++>>>>>>> 2b6166664d2b (iwlwifi: pcie: merge napi_poll_msix functions)
  			netif_napi_add(&trans_pcie->napi_dev, &rxq->napi,
 -				       poll, NAPI_POLL_WEIGHT);
 -			napi_enable(&rxq->napi);
 -		}
 +				       iwl_pcie_dummy_napi_poll, 64);
  
 +		spin_unlock_bh(&rxq->lock);
  	}
  
  	/* move the pool to the default queue and allocator ownerships */
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/rx.c
