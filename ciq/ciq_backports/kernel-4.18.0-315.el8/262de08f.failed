intel: clean up mismatched header comments

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 262de08f64e34bf1731e0e6296a9fc1e493e8b54
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/262de08f.failed

A bunch of header comments were showing warnings when compiling
with W=1. Fix them all at once. This changes only comments.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 262de08f64e34bf1731e0e6296a9fc1e493e8b54)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_dcb.c
#	drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_dcb.c
index 9de503c5f99b,673f341f4c0c..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_dcb.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_dcb.c
@@@ -933,6 -933,953 +933,956 @@@ i40e_status i40e_init_dcb(struct i40e_h
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_get_fw_lldp_status
+  * @hw: pointer to the hw struct
+  * @lldp_status: pointer to the status enum
+  *
+  * Get status of FW Link Layer Discovery Protocol (LLDP) Agent.
+  * Status of agent is reported via @lldp_status parameter.
+  **/
+ enum i40e_status_code
+ i40e_get_fw_lldp_status(struct i40e_hw *hw,
+ 			enum i40e_get_fw_lldp_status_resp *lldp_status)
+ {
+ 	struct i40e_virt_mem mem;
+ 	i40e_status ret;
+ 	u8 *lldpmib;
+ 
+ 	if (!lldp_status)
+ 		return I40E_ERR_PARAM;
+ 
+ 	/* Allocate buffer for the LLDPDU */
+ 	ret = i40e_allocate_virt_mem(hw, &mem, I40E_LLDPDU_SIZE);
+ 	if (ret)
+ 		return ret;
+ 
+ 	lldpmib = (u8 *)mem.va;
+ 	ret = i40e_aq_get_lldp_mib(hw, 0, 0, (void *)lldpmib,
+ 				   I40E_LLDPDU_SIZE, NULL, NULL, NULL);
+ 
+ 	if (!ret) {
+ 		*lldp_status = I40E_GET_FW_LLDP_STATUS_ENABLED;
+ 	} else if (hw->aq.asq_last_status == I40E_AQ_RC_ENOENT) {
+ 		/* MIB is not available yet but the agent is running */
+ 		*lldp_status = I40E_GET_FW_LLDP_STATUS_ENABLED;
+ 		ret = 0;
+ 	} else if (hw->aq.asq_last_status == I40E_AQ_RC_EPERM) {
+ 		*lldp_status = I40E_GET_FW_LLDP_STATUS_DISABLED;
+ 		ret = 0;
+ 	}
+ 
+ 	i40e_free_virt_mem(hw, &mem);
+ 	return ret;
+ }
+ 
+ /**
+  * i40e_add_ieee_ets_tlv - Prepare ETS TLV in IEEE format
+  * @tlv: Fill the ETS config data in IEEE format
+  * @dcbcfg: Local store which holds the DCB Config
+  *
+  * Prepare IEEE 802.1Qaz ETS CFG TLV
+  **/
+ static void i40e_add_ieee_ets_tlv(struct i40e_lldp_org_tlv *tlv,
+ 				  struct i40e_dcbx_config *dcbcfg)
+ {
+ 	u8 priority0, priority1, maxtcwilling = 0;
+ 	struct i40e_dcb_ets_config *etscfg;
+ 	u16 offset = 0, typelength, i;
+ 	u8 *buf = tlv->tlvinfo;
+ 	u32 ouisubtype;
+ 
+ 	typelength = (u16)((I40E_TLV_TYPE_ORG << I40E_LLDP_TLV_TYPE_SHIFT) |
+ 			I40E_IEEE_ETS_TLV_LENGTH);
+ 	tlv->typelength = htons(typelength);
+ 
+ 	ouisubtype = (u32)((I40E_IEEE_8021QAZ_OUI << I40E_LLDP_TLV_OUI_SHIFT) |
+ 			I40E_IEEE_SUBTYPE_ETS_CFG);
+ 	tlv->ouisubtype = htonl(ouisubtype);
+ 
+ 	/* First Octet post subtype
+ 	 * --------------------------
+ 	 * |will-|CBS  | Re-  | Max |
+ 	 * |ing  |     |served| TCs |
+ 	 * --------------------------
+ 	 * |1bit | 1bit|3 bits|3bits|
+ 	 */
+ 	etscfg = &dcbcfg->etscfg;
+ 	if (etscfg->willing)
+ 		maxtcwilling = BIT(I40E_IEEE_ETS_WILLING_SHIFT);
+ 	maxtcwilling |= etscfg->maxtcs & I40E_IEEE_ETS_MAXTC_MASK;
+ 	buf[offset] = maxtcwilling;
+ 
+ 	/* Move offset to Priority Assignment Table */
+ 	offset++;
+ 
+ 	/* Priority Assignment Table (4 octets)
+ 	 * Octets:|    1    |    2    |    3    |    4    |
+ 	 *        -----------------------------------------
+ 	 *        |pri0|pri1|pri2|pri3|pri4|pri5|pri6|pri7|
+ 	 *        -----------------------------------------
+ 	 *   Bits:|7  4|3  0|7  4|3  0|7  4|3  0|7  4|3  0|
+ 	 *        -----------------------------------------
+ 	 */
+ 	for (i = 0; i < 4; i++) {
+ 		priority0 = etscfg->prioritytable[i * 2] & 0xF;
+ 		priority1 = etscfg->prioritytable[i * 2 + 1] & 0xF;
+ 		buf[offset] = (priority0 << I40E_IEEE_ETS_PRIO_1_SHIFT) |
+ 				priority1;
+ 		offset++;
+ 	}
+ 
+ 	/* TC Bandwidth Table (8 octets)
+ 	 * Octets:| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
+ 	 *        ---------------------------------
+ 	 *        |tc0|tc1|tc2|tc3|tc4|tc5|tc6|tc7|
+ 	 *        ---------------------------------
+ 	 */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		buf[offset++] = etscfg->tcbwtable[i];
+ 
+ 	/* TSA Assignment Table (8 octets)
+ 	 * Octets:| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
+ 	 *        ---------------------------------
+ 	 *        |tc0|tc1|tc2|tc3|tc4|tc5|tc6|tc7|
+ 	 *        ---------------------------------
+ 	 */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		buf[offset++] = etscfg->tsatable[i];
+ }
+ 
+ /**
+  * i40e_add_ieee_etsrec_tlv - Prepare ETS Recommended TLV in IEEE format
+  * @tlv: Fill ETS Recommended TLV in IEEE format
+  * @dcbcfg: Local store which holds the DCB Config
+  *
+  * Prepare IEEE 802.1Qaz ETS REC TLV
+  **/
+ static void i40e_add_ieee_etsrec_tlv(struct i40e_lldp_org_tlv *tlv,
+ 				     struct i40e_dcbx_config *dcbcfg)
+ {
+ 	struct i40e_dcb_ets_config *etsrec;
+ 	u16 offset = 0, typelength, i;
+ 	u8 priority0, priority1;
+ 	u8 *buf = tlv->tlvinfo;
+ 	u32 ouisubtype;
+ 
+ 	typelength = (u16)((I40E_TLV_TYPE_ORG << I40E_LLDP_TLV_TYPE_SHIFT) |
+ 			I40E_IEEE_ETS_TLV_LENGTH);
+ 	tlv->typelength = htons(typelength);
+ 
+ 	ouisubtype = (u32)((I40E_IEEE_8021QAZ_OUI << I40E_LLDP_TLV_OUI_SHIFT) |
+ 			I40E_IEEE_SUBTYPE_ETS_REC);
+ 	tlv->ouisubtype = htonl(ouisubtype);
+ 
+ 	etsrec = &dcbcfg->etsrec;
+ 	/* First Octet is reserved */
+ 	/* Move offset to Priority Assignment Table */
+ 	offset++;
+ 
+ 	/* Priority Assignment Table (4 octets)
+ 	 * Octets:|    1    |    2    |    3    |    4    |
+ 	 *        -----------------------------------------
+ 	 *        |pri0|pri1|pri2|pri3|pri4|pri5|pri6|pri7|
+ 	 *        -----------------------------------------
+ 	 *   Bits:|7  4|3  0|7  4|3  0|7  4|3  0|7  4|3  0|
+ 	 *        -----------------------------------------
+ 	 */
+ 	for (i = 0; i < 4; i++) {
+ 		priority0 = etsrec->prioritytable[i * 2] & 0xF;
+ 		priority1 = etsrec->prioritytable[i * 2 + 1] & 0xF;
+ 		buf[offset] = (priority0 << I40E_IEEE_ETS_PRIO_1_SHIFT) |
+ 				priority1;
+ 		offset++;
+ 	}
+ 
+ 	/* TC Bandwidth Table (8 octets)
+ 	 * Octets:| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
+ 	 *        ---------------------------------
+ 	 *        |tc0|tc1|tc2|tc3|tc4|tc5|tc6|tc7|
+ 	 *        ---------------------------------
+ 	 */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		buf[offset++] = etsrec->tcbwtable[i];
+ 
+ 	/* TSA Assignment Table (8 octets)
+ 	 * Octets:| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
+ 	 *        ---------------------------------
+ 	 *        |tc0|tc1|tc2|tc3|tc4|tc5|tc6|tc7|
+ 	 *        ---------------------------------
+ 	 */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		buf[offset++] = etsrec->tsatable[i];
+ }
+ 
+ /**
+  * i40e_add_ieee_pfc_tlv - Prepare PFC TLV in IEEE format
+  * @tlv: Fill PFC TLV in IEEE format
+  * @dcbcfg: Local store to get PFC CFG data
+  *
+  * Prepare IEEE 802.1Qaz PFC CFG TLV
+  **/
+ static void i40e_add_ieee_pfc_tlv(struct i40e_lldp_org_tlv *tlv,
+ 				  struct i40e_dcbx_config *dcbcfg)
+ {
+ 	u8 *buf = tlv->tlvinfo;
+ 	u32 ouisubtype;
+ 	u16 typelength;
+ 
+ 	typelength = (u16)((I40E_TLV_TYPE_ORG << I40E_LLDP_TLV_TYPE_SHIFT) |
+ 			I40E_IEEE_PFC_TLV_LENGTH);
+ 	tlv->typelength = htons(typelength);
+ 
+ 	ouisubtype = (u32)((I40E_IEEE_8021QAZ_OUI << I40E_LLDP_TLV_OUI_SHIFT) |
+ 			I40E_IEEE_SUBTYPE_PFC_CFG);
+ 	tlv->ouisubtype = htonl(ouisubtype);
+ 
+ 	/* ----------------------------------------
+ 	 * |will-|MBC  | Re-  | PFC |  PFC Enable  |
+ 	 * |ing  |     |served| cap |              |
+ 	 * -----------------------------------------
+ 	 * |1bit | 1bit|2 bits|4bits| 1 octet      |
+ 	 */
+ 	if (dcbcfg->pfc.willing)
+ 		buf[0] = BIT(I40E_IEEE_PFC_WILLING_SHIFT);
+ 
+ 	if (dcbcfg->pfc.mbc)
+ 		buf[0] |= BIT(I40E_IEEE_PFC_MBC_SHIFT);
+ 
+ 	buf[0] |= dcbcfg->pfc.pfccap & 0xF;
+ 	buf[1] = dcbcfg->pfc.pfcenable;
+ }
+ 
+ /**
+  * i40e_add_ieee_app_pri_tlv -  Prepare APP TLV in IEEE format
+  * @tlv: Fill APP TLV in IEEE format
+  * @dcbcfg: Local store to get APP CFG data
+  *
+  * Prepare IEEE 802.1Qaz APP CFG TLV
+  **/
+ static void i40e_add_ieee_app_pri_tlv(struct i40e_lldp_org_tlv *tlv,
+ 				      struct i40e_dcbx_config *dcbcfg)
+ {
+ 	u16 typelength, length, offset = 0;
+ 	u8 priority, selector, i = 0;
+ 	u8 *buf = tlv->tlvinfo;
+ 	u32 ouisubtype;
+ 
+ 	/* No APP TLVs then just return */
+ 	if (dcbcfg->numapps == 0)
+ 		return;
+ 	ouisubtype = (u32)((I40E_IEEE_8021QAZ_OUI << I40E_LLDP_TLV_OUI_SHIFT) |
+ 			I40E_IEEE_SUBTYPE_APP_PRI);
+ 	tlv->ouisubtype = htonl(ouisubtype);
+ 
+ 	/* Move offset to App Priority Table */
+ 	offset++;
+ 	/* Application Priority Table (3 octets)
+ 	 * Octets:|         1          |    2    |    3    |
+ 	 *        -----------------------------------------
+ 	 *        |Priority|Rsrvd| Sel |    Protocol ID    |
+ 	 *        -----------------------------------------
+ 	 *   Bits:|23    21|20 19|18 16|15                0|
+ 	 *        -----------------------------------------
+ 	 */
+ 	while (i < dcbcfg->numapps) {
+ 		priority = dcbcfg->app[i].priority & 0x7;
+ 		selector = dcbcfg->app[i].selector & 0x7;
+ 		buf[offset] = (priority << I40E_IEEE_APP_PRIO_SHIFT) | selector;
+ 		buf[offset + 1] = (dcbcfg->app[i].protocolid >> 0x8) & 0xFF;
+ 		buf[offset + 2] =  dcbcfg->app[i].protocolid & 0xFF;
+ 		/* Move to next app */
+ 		offset += 3;
+ 		i++;
+ 		if (i >= I40E_DCBX_MAX_APPS)
+ 			break;
+ 	}
+ 	/* length includes size of ouisubtype + 1 reserved + 3*numapps */
+ 	length = sizeof(tlv->ouisubtype) + 1 + (i * 3);
+ 	typelength = (u16)((I40E_TLV_TYPE_ORG << I40E_LLDP_TLV_TYPE_SHIFT) |
+ 		(length & 0x1FF));
+ 	tlv->typelength = htons(typelength);
+ }
+ 
+ /**
+  * i40e_add_dcb_tlv - Add all IEEE TLVs
+  * @tlv: pointer to org tlv
+  * @dcbcfg: pointer to modified dcbx config structure *
+  * @tlvid: tlv id to be added
+  * add tlv information
+  **/
+ static void i40e_add_dcb_tlv(struct i40e_lldp_org_tlv *tlv,
+ 			     struct i40e_dcbx_config *dcbcfg,
+ 			     u16 tlvid)
+ {
+ 	switch (tlvid) {
+ 	case I40E_IEEE_TLV_ID_ETS_CFG:
+ 		i40e_add_ieee_ets_tlv(tlv, dcbcfg);
+ 		break;
+ 	case I40E_IEEE_TLV_ID_ETS_REC:
+ 		i40e_add_ieee_etsrec_tlv(tlv, dcbcfg);
+ 		break;
+ 	case I40E_IEEE_TLV_ID_PFC_CFG:
+ 		i40e_add_ieee_pfc_tlv(tlv, dcbcfg);
+ 		break;
+ 	case I40E_IEEE_TLV_ID_APP_PRI:
+ 		i40e_add_ieee_app_pri_tlv(tlv, dcbcfg);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ /**
+  * i40e_set_dcb_config - Set the local LLDP MIB to FW
+  * @hw: pointer to the hw struct
+  *
+  * Set DCB configuration to the Firmware
+  **/
+ i40e_status i40e_set_dcb_config(struct i40e_hw *hw)
+ {
+ 	struct i40e_dcbx_config *dcbcfg;
+ 	struct i40e_virt_mem mem;
+ 	u8 mib_type, *lldpmib;
+ 	i40e_status ret;
+ 	u16 miblen;
+ 
+ 	/* update the hw local config */
+ 	dcbcfg = &hw->local_dcbx_config;
+ 	/* Allocate the LLDPDU */
+ 	ret = i40e_allocate_virt_mem(hw, &mem, I40E_LLDPDU_SIZE);
+ 	if (ret)
+ 		return ret;
+ 
+ 	mib_type = SET_LOCAL_MIB_AC_TYPE_LOCAL_MIB;
+ 	if (dcbcfg->app_mode == I40E_DCBX_APPS_NON_WILLING) {
+ 		mib_type |= SET_LOCAL_MIB_AC_TYPE_NON_WILLING_APPS <<
+ 			    SET_LOCAL_MIB_AC_TYPE_NON_WILLING_APPS_SHIFT;
+ 	}
+ 	lldpmib = (u8 *)mem.va;
+ 	i40e_dcb_config_to_lldp(lldpmib, &miblen, dcbcfg);
+ 	ret = i40e_aq_set_lldp_mib(hw, mib_type, (void *)lldpmib, miblen, NULL);
+ 
+ 	i40e_free_virt_mem(hw, &mem);
+ 	return ret;
+ }
+ 
+ /**
+  * i40e_dcb_config_to_lldp - Convert Dcbconfig to MIB format
+  * @lldpmib: pointer to mib to be output
+  * @miblen: pointer to u16 for length of lldpmib
+  * @dcbcfg: store for LLDPDU data
+  *
+  * send DCB configuration to FW
+  **/
+ i40e_status i40e_dcb_config_to_lldp(u8 *lldpmib, u16 *miblen,
+ 				    struct i40e_dcbx_config *dcbcfg)
+ {
+ 	u16 length, offset = 0, tlvid, typelength;
+ 	struct i40e_lldp_org_tlv *tlv;
+ 
+ 	tlv = (struct i40e_lldp_org_tlv *)lldpmib;
+ 	tlvid = I40E_TLV_ID_START;
+ 	do {
+ 		i40e_add_dcb_tlv(tlv, dcbcfg, tlvid++);
+ 		typelength = ntohs(tlv->typelength);
+ 		length = (u16)((typelength & I40E_LLDP_TLV_LEN_MASK) >>
+ 				I40E_LLDP_TLV_LEN_SHIFT);
+ 		if (length)
+ 			offset += length + I40E_IEEE_TLV_HEADER_LENGTH;
+ 		/* END TLV or beyond LLDPDU size */
+ 		if (tlvid >= I40E_TLV_ID_END_OF_LLDPPDU ||
+ 		    offset >= I40E_LLDPDU_SIZE)
+ 			break;
+ 		/* Move to next TLV */
+ 		if (length)
+ 			tlv = (struct i40e_lldp_org_tlv *)((char *)tlv +
+ 			      sizeof(tlv->typelength) + length);
+ 	} while (tlvid < I40E_TLV_ID_END_OF_LLDPPDU);
+ 	*miblen = offset;
+ 	return I40E_SUCCESS;
+ }
+ 
+ /**
+  * i40e_dcb_hw_rx_fifo_config
+  * @hw: pointer to the hw struct
+  * @ets_mode: Strict Priority or Round Robin mode
+  * @non_ets_mode: Strict Priority or Round Robin
+  * @max_exponent: Exponent to calculate max refill credits
+  * @lltc_map: Low latency TC bitmap
+  *
+  * Configure HW Rx FIFO as part of DCB configuration.
+  **/
+ void i40e_dcb_hw_rx_fifo_config(struct i40e_hw *hw,
+ 				enum i40e_dcb_arbiter_mode ets_mode,
+ 				enum i40e_dcb_arbiter_mode non_ets_mode,
+ 				u32 max_exponent,
+ 				u8 lltc_map)
+ {
+ 	u32 reg = rd32(hw, I40E_PRTDCB_RETSC);
+ 
+ 	reg &= ~I40E_PRTDCB_RETSC_ETS_MODE_MASK;
+ 	reg |= ((u32)ets_mode << I40E_PRTDCB_RETSC_ETS_MODE_SHIFT) &
+ 		I40E_PRTDCB_RETSC_ETS_MODE_MASK;
+ 
+ 	reg &= ~I40E_PRTDCB_RETSC_NON_ETS_MODE_MASK;
+ 	reg |= ((u32)non_ets_mode << I40E_PRTDCB_RETSC_NON_ETS_MODE_SHIFT) &
+ 		I40E_PRTDCB_RETSC_NON_ETS_MODE_MASK;
+ 
+ 	reg &= ~I40E_PRTDCB_RETSC_ETS_MAX_EXP_MASK;
+ 	reg |= (max_exponent << I40E_PRTDCB_RETSC_ETS_MAX_EXP_SHIFT) &
+ 		I40E_PRTDCB_RETSC_ETS_MAX_EXP_MASK;
+ 
+ 	reg &= ~I40E_PRTDCB_RETSC_LLTC_MASK;
+ 	reg |= (lltc_map << I40E_PRTDCB_RETSC_LLTC_SHIFT) &
+ 		I40E_PRTDCB_RETSC_LLTC_MASK;
+ 	wr32(hw, I40E_PRTDCB_RETSC, reg);
+ }
+ 
+ /**
+  * i40e_dcb_hw_rx_cmd_monitor_config
+  * @hw: pointer to the hw struct
+  * @num_tc: Total number of traffic class
+  * @num_ports: Total number of ports on device
+  *
+  * Configure HW Rx command monitor as part of DCB configuration.
+  **/
+ void i40e_dcb_hw_rx_cmd_monitor_config(struct i40e_hw *hw,
+ 				       u8 num_tc, u8 num_ports)
+ {
+ 	u32 threshold;
+ 	u32 fifo_size;
+ 	u32 reg;
+ 
+ 	/* Set the threshold and fifo_size based on number of ports */
+ 	switch (num_ports) {
+ 	case 1:
+ 		threshold = I40E_DCB_1_PORT_THRESHOLD;
+ 		fifo_size = I40E_DCB_1_PORT_FIFO_SIZE;
+ 		break;
+ 	case 2:
+ 		if (num_tc > 4) {
+ 			threshold = I40E_DCB_2_PORT_THRESHOLD_HIGH_NUM_TC;
+ 			fifo_size = I40E_DCB_2_PORT_FIFO_SIZE_HIGH_NUM_TC;
+ 		} else {
+ 			threshold = I40E_DCB_2_PORT_THRESHOLD_LOW_NUM_TC;
+ 			fifo_size = I40E_DCB_2_PORT_FIFO_SIZE_LOW_NUM_TC;
+ 		}
+ 		break;
+ 	case 4:
+ 		if (num_tc > 4) {
+ 			threshold = I40E_DCB_4_PORT_THRESHOLD_HIGH_NUM_TC;
+ 			fifo_size = I40E_DCB_4_PORT_FIFO_SIZE_HIGH_NUM_TC;
+ 		} else {
+ 			threshold = I40E_DCB_4_PORT_THRESHOLD_LOW_NUM_TC;
+ 			fifo_size = I40E_DCB_4_PORT_FIFO_SIZE_LOW_NUM_TC;
+ 		}
+ 		break;
+ 	default:
+ 		i40e_debug(hw, I40E_DEBUG_DCB, "Invalid num_ports %u.\n",
+ 			   (u32)num_ports);
+ 		return;
+ 	}
+ 
+ 	/* The hardware manual describes setting up of I40E_PRT_SWR_PM_THR
+ 	 * based on the number of ports and traffic classes for a given port as
+ 	 * part of DCB configuration.
+ 	 */
+ 	reg = rd32(hw, I40E_PRT_SWR_PM_THR);
+ 	reg &= ~I40E_PRT_SWR_PM_THR_THRESHOLD_MASK;
+ 	reg |= (threshold << I40E_PRT_SWR_PM_THR_THRESHOLD_SHIFT) &
+ 		I40E_PRT_SWR_PM_THR_THRESHOLD_MASK;
+ 	wr32(hw, I40E_PRT_SWR_PM_THR, reg);
+ 
+ 	reg = rd32(hw, I40E_PRTDCB_RPPMC);
+ 	reg &= ~I40E_PRTDCB_RPPMC_RX_FIFO_SIZE_MASK;
+ 	reg |= (fifo_size << I40E_PRTDCB_RPPMC_RX_FIFO_SIZE_SHIFT) &
+ 		I40E_PRTDCB_RPPMC_RX_FIFO_SIZE_MASK;
+ 	wr32(hw, I40E_PRTDCB_RPPMC, reg);
+ }
+ 
+ /**
+  * i40e_dcb_hw_pfc_config
+  * @hw: pointer to the hw struct
+  * @pfc_en: Bitmap of PFC enabled priorities
+  * @prio_tc: priority to tc assignment indexed by priority
+  *
+  * Configure HW Priority Flow Controller as part of DCB configuration.
+  **/
+ void i40e_dcb_hw_pfc_config(struct i40e_hw *hw,
+ 			    u8 pfc_en, u8 *prio_tc)
+ {
+ 	u16 refresh_time = (u16)I40E_DEFAULT_PAUSE_TIME / 2;
+ 	u32 link_speed = hw->phy.link_info.link_speed;
+ 	u8 first_pfc_prio = 0;
+ 	u8 num_pfc_tc = 0;
+ 	u8 tc2pfc = 0;
+ 	u32 reg;
+ 	u8 i;
+ 
+ 	/* Get Number of PFC TCs and TC2PFC map */
+ 	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
+ 		if (pfc_en & BIT(i)) {
+ 			if (!first_pfc_prio)
+ 				first_pfc_prio = i;
+ 			/* Set bit for the PFC TC */
+ 			tc2pfc |= BIT(prio_tc[i]);
+ 			num_pfc_tc++;
+ 		}
+ 	}
+ 
+ 	switch (link_speed) {
+ 	case I40E_LINK_SPEED_10GB:
+ 		reg = rd32(hw, I40E_PRTDCB_MFLCN);
+ 		reg |= BIT(I40E_PRTDCB_MFLCN_DPF_SHIFT) &
+ 			I40E_PRTDCB_MFLCN_DPF_MASK;
+ 		reg &= ~I40E_PRTDCB_MFLCN_RFCE_MASK;
+ 		reg &= ~I40E_PRTDCB_MFLCN_RPFCE_MASK;
+ 		if (pfc_en) {
+ 			reg |= BIT(I40E_PRTDCB_MFLCN_RPFCM_SHIFT) &
+ 				I40E_PRTDCB_MFLCN_RPFCM_MASK;
+ 			reg |= ((u32)pfc_en << I40E_PRTDCB_MFLCN_RPFCE_SHIFT) &
+ 				I40E_PRTDCB_MFLCN_RPFCE_MASK;
+ 		}
+ 		wr32(hw, I40E_PRTDCB_MFLCN, reg);
+ 
+ 		reg = rd32(hw, I40E_PRTDCB_FCCFG);
+ 		reg &= ~I40E_PRTDCB_FCCFG_TFCE_MASK;
+ 		if (pfc_en)
+ 			reg |= (I40E_DCB_PFC_ENABLED <<
+ 				I40E_PRTDCB_FCCFG_TFCE_SHIFT) &
+ 				I40E_PRTDCB_FCCFG_TFCE_MASK;
+ 		wr32(hw, I40E_PRTDCB_FCCFG, reg);
+ 
+ 		/* FCTTV and FCRTV to be set by default */
+ 		break;
+ 	case I40E_LINK_SPEED_40GB:
+ 		reg = rd32(hw, I40E_PRTMAC_HSEC_CTL_RX_ENABLE_GPP);
+ 		reg &= ~I40E_PRTMAC_HSEC_CTL_RX_ENABLE_GPP_MASK;
+ 		wr32(hw, I40E_PRTMAC_HSEC_CTL_RX_ENABLE_GPP, reg);
+ 
+ 		reg = rd32(hw, I40E_PRTMAC_HSEC_CTL_RX_ENABLE_PPP);
+ 		reg &= ~I40E_PRTMAC_HSEC_CTL_RX_ENABLE_GPP_MASK;
+ 		reg |= BIT(I40E_PRTMAC_HSEC_CTL_RX_ENABLE_PPP_SHIFT) &
+ 			I40E_PRTMAC_HSEC_CTL_RX_ENABLE_PPP_MASK;
+ 		wr32(hw, I40E_PRTMAC_HSEC_CTL_RX_ENABLE_PPP, reg);
+ 
+ 		reg = rd32(hw, I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE);
+ 		reg &= ~I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE_MASK;
+ 		reg |= ((u32)pfc_en <<
+ 			   I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE_SHIFT) &
+ 			I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE_MASK;
+ 		wr32(hw, I40E_PRTMAC_HSEC_CTL_RX_PAUSE_ENABLE, reg);
+ 
+ 		reg = rd32(hw, I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE);
+ 		reg &= ~I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE_MASK;
+ 		reg |= ((u32)pfc_en <<
+ 			   I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE_SHIFT) &
+ 			I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE_MASK;
+ 		wr32(hw, I40E_PRTMAC_HSEC_CTL_TX_PAUSE_ENABLE, reg);
+ 
+ 		for (i = 0; i < I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER_MAX_INDEX; i++) {
+ 			reg = rd32(hw, I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER(i));
+ 			reg &= ~I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER_MASK;
+ 			if (pfc_en) {
+ 				reg |= ((u32)refresh_time <<
+ 					I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER_SHIFT) &
+ 					I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER_MASK;
+ 			}
+ 			wr32(hw, I40E_PRTMAC_HSEC_CTL_TX_PAUSE_REFRESH_TIMER(i), reg);
+ 		}
+ 		/* PRTMAC_HSEC_CTL_TX_PAUSE_QUANTA default value is 0xFFFF
+ 		 * for all user priorities
+ 		 */
+ 		break;
+ 	}
+ 
+ 	reg = rd32(hw, I40E_PRTDCB_TC2PFC);
+ 	reg &= ~I40E_PRTDCB_TC2PFC_TC2PFC_MASK;
+ 	reg |= ((u32)tc2pfc << I40E_PRTDCB_TC2PFC_TC2PFC_SHIFT) &
+ 		I40E_PRTDCB_TC2PFC_TC2PFC_MASK;
+ 	wr32(hw, I40E_PRTDCB_TC2PFC, reg);
+ 
+ 	reg = rd32(hw, I40E_PRTDCB_RUP);
+ 	reg &= ~I40E_PRTDCB_RUP_NOVLANUP_MASK;
+ 	reg |= ((u32)first_pfc_prio << I40E_PRTDCB_RUP_NOVLANUP_SHIFT) &
+ 		 I40E_PRTDCB_RUP_NOVLANUP_MASK;
+ 	wr32(hw, I40E_PRTDCB_RUP, reg);
+ 
+ 	reg = rd32(hw, I40E_PRTDCB_TDPMC);
+ 	reg &= ~I40E_PRTDCB_TDPMC_TCPM_MODE_MASK;
+ 	if (num_pfc_tc > I40E_DCB_PFC_FORCED_NUM_TC) {
+ 		reg |= BIT(I40E_PRTDCB_TDPMC_TCPM_MODE_SHIFT) &
+ 			I40E_PRTDCB_TDPMC_TCPM_MODE_MASK;
+ 	}
+ 	wr32(hw, I40E_PRTDCB_TDPMC, reg);
+ 
+ 	reg = rd32(hw, I40E_PRTDCB_TCPMC);
+ 	reg &= ~I40E_PRTDCB_TCPMC_TCPM_MODE_MASK;
+ 	if (num_pfc_tc > I40E_DCB_PFC_FORCED_NUM_TC) {
+ 		reg |= BIT(I40E_PRTDCB_TCPMC_TCPM_MODE_SHIFT) &
+ 			I40E_PRTDCB_TCPMC_TCPM_MODE_MASK;
+ 	}
+ 	wr32(hw, I40E_PRTDCB_TCPMC, reg);
+ }
+ 
+ /**
+  * i40e_dcb_hw_set_num_tc
+  * @hw: pointer to the hw struct
+  * @num_tc: number of traffic classes
+  *
+  * Configure number of traffic classes in HW
+  **/
+ void i40e_dcb_hw_set_num_tc(struct i40e_hw *hw, u8 num_tc)
+ {
+ 	u32 reg = rd32(hw, I40E_PRTDCB_GENC);
+ 
+ 	reg &= ~I40E_PRTDCB_GENC_NUMTC_MASK;
+ 	reg |= ((u32)num_tc << I40E_PRTDCB_GENC_NUMTC_SHIFT) &
+ 		I40E_PRTDCB_GENC_NUMTC_MASK;
+ 	wr32(hw, I40E_PRTDCB_GENC, reg);
+ }
+ 
+ /**
+  * i40e_dcb_hw_get_num_tc
+  * @hw: pointer to the hw struct
+  *
+  * Returns number of traffic classes configured in HW
+  **/
+ u8 i40e_dcb_hw_get_num_tc(struct i40e_hw *hw)
+ {
+ 	u32 reg = rd32(hw, I40E_PRTDCB_GENC);
+ 
+ 	return (u8)((reg & I40E_PRTDCB_GENC_NUMTC_MASK) >>
+ 		I40E_PRTDCB_GENC_NUMTC_SHIFT);
+ }
+ 
+ /**
+  * i40e_dcb_hw_rx_ets_bw_config
+  * @hw: pointer to the hw struct
+  * @bw_share: Bandwidth share indexed per traffic class
+  * @mode: Strict Priority or Round Robin mode between UP sharing same
+  * traffic class
+  * @prio_type: TC is ETS enabled or strict priority
+  *
+  * Configure HW Rx ETS bandwidth as part of DCB configuration.
+  **/
+ void i40e_dcb_hw_rx_ets_bw_config(struct i40e_hw *hw, u8 *bw_share,
+ 				  u8 *mode, u8 *prio_type)
+ {
+ 	u32 reg;
+ 	u8 i;
+ 
+ 	for (i = 0; i <= I40E_PRTDCB_RETSTCC_MAX_INDEX; i++) {
+ 		reg = rd32(hw, I40E_PRTDCB_RETSTCC(i));
+ 		reg &= ~(I40E_PRTDCB_RETSTCC_BWSHARE_MASK     |
+ 			 I40E_PRTDCB_RETSTCC_UPINTC_MODE_MASK |
+ 			 I40E_PRTDCB_RETSTCC_ETSTC_SHIFT);
+ 		reg |= ((u32)bw_share[i] << I40E_PRTDCB_RETSTCC_BWSHARE_SHIFT) &
+ 			 I40E_PRTDCB_RETSTCC_BWSHARE_MASK;
+ 		reg |= ((u32)mode[i] << I40E_PRTDCB_RETSTCC_UPINTC_MODE_SHIFT) &
+ 			 I40E_PRTDCB_RETSTCC_UPINTC_MODE_MASK;
+ 		reg |= ((u32)prio_type[i] << I40E_PRTDCB_RETSTCC_ETSTC_SHIFT) &
+ 			 I40E_PRTDCB_RETSTCC_ETSTC_MASK;
+ 		wr32(hw, I40E_PRTDCB_RETSTCC(i), reg);
+ 	}
+ }
+ 
+ /**
+  * i40e_dcb_hw_rx_up2tc_config
+  * @hw: pointer to the hw struct
+  * @prio_tc: priority to tc assignment indexed by priority
+  *
+  * Configure HW Rx UP2TC map as part of DCB configuration.
+  **/
+ void i40e_dcb_hw_rx_up2tc_config(struct i40e_hw *hw, u8 *prio_tc)
+ {
+ 	u32 reg = rd32(hw, I40E_PRTDCB_RUP2TC);
+ #define I40E_UP2TC_REG(val, i) \
+ 		(((val) << I40E_PRTDCB_RUP2TC_UP##i##TC_SHIFT) & \
+ 		  I40E_PRTDCB_RUP2TC_UP##i##TC_MASK)
+ 
+ 	reg |= I40E_UP2TC_REG(prio_tc[0], 0);
+ 	reg |= I40E_UP2TC_REG(prio_tc[1], 1);
+ 	reg |= I40E_UP2TC_REG(prio_tc[2], 2);
+ 	reg |= I40E_UP2TC_REG(prio_tc[3], 3);
+ 	reg |= I40E_UP2TC_REG(prio_tc[4], 4);
+ 	reg |= I40E_UP2TC_REG(prio_tc[5], 5);
+ 	reg |= I40E_UP2TC_REG(prio_tc[6], 6);
+ 	reg |= I40E_UP2TC_REG(prio_tc[7], 7);
+ 
+ 	wr32(hw, I40E_PRTDCB_RUP2TC, reg);
+ }
+ 
+ /**
+  * i40e_dcb_hw_calculate_pool_sizes - configure dcb pool sizes
+  * @hw: pointer to the hw struct
+  * @num_ports: Number of available ports on the device
+  * @eee_enabled: EEE enabled for the given port
+  * @pfc_en: Bit map of PFC enabled traffic classes
+  * @mfs_tc: Array of max frame size for each traffic class
+  * @pb_cfg: pointer to packet buffer configuration
+  *
+  * Calculate the shared and dedicated per TC pool sizes,
+  * watermarks and threshold values.
+  **/
+ void i40e_dcb_hw_calculate_pool_sizes(struct i40e_hw *hw,
+ 				      u8 num_ports, bool eee_enabled,
+ 				      u8 pfc_en, u32 *mfs_tc,
+ 				      struct i40e_rx_pb_config *pb_cfg)
+ {
+ 	u32 pool_size[I40E_MAX_TRAFFIC_CLASS];
+ 	u32 high_wm[I40E_MAX_TRAFFIC_CLASS];
+ 	u32 low_wm[I40E_MAX_TRAFFIC_CLASS];
+ 	u32 total_pool_size = 0;
+ 	int shared_pool_size; /* Need signed variable */
+ 	u32 port_pb_size;
+ 	u32 mfs_max = 0;
+ 	u32 pcirtt;
+ 	u8 i;
+ 
+ 	/* Get the MFS(max) for the port */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		if (mfs_tc[i] > mfs_max)
+ 			mfs_max = mfs_tc[i];
+ 	}
+ 
+ 	pcirtt = I40E_BT2B(I40E_PCIRTT_LINK_SPEED_10G);
+ 
+ 	/* Calculate effective Rx PB size per port */
+ 	port_pb_size = I40E_DEVICE_RPB_SIZE / num_ports;
+ 	if (eee_enabled)
+ 		port_pb_size -= I40E_BT2B(I40E_EEE_TX_LPI_EXIT_TIME);
+ 	port_pb_size -= mfs_max;
+ 
+ 	/* Step 1 Calculating tc pool/shared pool sizes and watermarks */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		if (pfc_en & BIT(i)) {
+ 			low_wm[i] = (I40E_DCB_WATERMARK_START_FACTOR *
+ 				     mfs_tc[i]) + pcirtt;
+ 			high_wm[i] = low_wm[i];
+ 			high_wm[i] += ((mfs_max > I40E_MAX_FRAME_SIZE)
+ 					? mfs_max : I40E_MAX_FRAME_SIZE);
+ 			pool_size[i] = high_wm[i];
+ 			pool_size[i] += I40E_BT2B(I40E_STD_DV_TC(mfs_max,
+ 								mfs_tc[i]));
+ 		} else {
+ 			low_wm[i] = 0;
+ 			pool_size[i] = (I40E_DCB_WATERMARK_START_FACTOR *
+ 					mfs_tc[i]) + pcirtt;
+ 			high_wm[i] = pool_size[i];
+ 		}
+ 		total_pool_size += pool_size[i];
+ 	}
+ 
+ 	shared_pool_size = port_pb_size - total_pool_size;
+ 	if (shared_pool_size > 0) {
+ 		pb_cfg->shared_pool_size = shared_pool_size;
+ 		pb_cfg->shared_pool_high_wm = shared_pool_size;
+ 		pb_cfg->shared_pool_low_wm = 0;
+ 		for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 			pb_cfg->shared_pool_low_thresh[i] = 0;
+ 			pb_cfg->shared_pool_high_thresh[i] = shared_pool_size;
+ 			pb_cfg->tc_pool_size[i] = pool_size[i];
+ 			pb_cfg->tc_pool_high_wm[i] = high_wm[i];
+ 			pb_cfg->tc_pool_low_wm[i] = low_wm[i];
+ 		}
+ 
+ 	} else {
+ 		i40e_debug(hw, I40E_DEBUG_DCB,
+ 			   "The shared pool size for the port is negative %d.\n",
+ 			   shared_pool_size);
+ 	}
+ }
+ 
+ /**
+  * i40e_dcb_hw_rx_pb_config
+  * @hw: pointer to the hw struct
+  * @old_pb_cfg: Existing Rx Packet buffer configuration
+  * @new_pb_cfg: New Rx Packet buffer configuration
+  *
+  * Program the Rx Packet Buffer registers.
+  **/
+ void i40e_dcb_hw_rx_pb_config(struct i40e_hw *hw,
+ 			      struct i40e_rx_pb_config *old_pb_cfg,
+ 			      struct i40e_rx_pb_config *new_pb_cfg)
+ {
+ 	u32 old_val;
+ 	u32 new_val;
+ 	u32 reg;
+ 	u8 i;
+ 
+ 	/* The Rx Packet buffer register programming needs to be done in a
+ 	 * certain order and the following code is based on that
+ 	 * requirement.
+ 	 */
+ 
+ 	/* Program the shared pool low water mark per port if decreasing */
+ 	old_val = old_pb_cfg->shared_pool_low_wm;
+ 	new_val = new_pb_cfg->shared_pool_low_wm;
+ 	if (new_val < old_val) {
+ 		reg = rd32(hw, I40E_PRTRPB_SLW);
+ 		reg &= ~I40E_PRTRPB_SLW_SLW_MASK;
+ 		reg |= (new_val << I40E_PRTRPB_SLW_SLW_SHIFT) &
+ 			I40E_PRTRPB_SLW_SLW_MASK;
+ 		wr32(hw, I40E_PRTRPB_SLW, reg);
+ 	}
+ 
+ 	/* Program the shared pool low threshold and tc pool
+ 	 * low water mark per TC that are decreasing.
+ 	 */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		old_val = old_pb_cfg->shared_pool_low_thresh[i];
+ 		new_val = new_pb_cfg->shared_pool_low_thresh[i];
+ 		if (new_val < old_val) {
+ 			reg = rd32(hw, I40E_PRTRPB_SLT(i));
+ 			reg &= ~I40E_PRTRPB_SLT_SLT_TCN_MASK;
+ 			reg |= (new_val << I40E_PRTRPB_SLT_SLT_TCN_SHIFT) &
+ 				I40E_PRTRPB_SLT_SLT_TCN_MASK;
+ 			wr32(hw, I40E_PRTRPB_SLT(i), reg);
+ 		}
+ 
+ 		old_val = old_pb_cfg->tc_pool_low_wm[i];
+ 		new_val = new_pb_cfg->tc_pool_low_wm[i];
+ 		if (new_val < old_val) {
+ 			reg = rd32(hw, I40E_PRTRPB_DLW(i));
+ 			reg &= ~I40E_PRTRPB_DLW_DLW_TCN_MASK;
+ 			reg |= (new_val << I40E_PRTRPB_DLW_DLW_TCN_SHIFT) &
+ 				I40E_PRTRPB_DLW_DLW_TCN_MASK;
+ 			wr32(hw, I40E_PRTRPB_DLW(i), reg);
+ 		}
+ 	}
+ 
+ 	/* Program the shared pool high water mark per port if decreasing */
+ 	old_val = old_pb_cfg->shared_pool_high_wm;
+ 	new_val = new_pb_cfg->shared_pool_high_wm;
+ 	if (new_val < old_val) {
+ 		reg = rd32(hw, I40E_PRTRPB_SHW);
+ 		reg &= ~I40E_PRTRPB_SHW_SHW_MASK;
+ 		reg |= (new_val << I40E_PRTRPB_SHW_SHW_SHIFT) &
+ 			I40E_PRTRPB_SHW_SHW_MASK;
+ 		wr32(hw, I40E_PRTRPB_SHW, reg);
+ 	}
+ 
+ 	/* Program the shared pool high threshold and tc pool
+ 	 * high water mark per TC that are decreasing.
+ 	 */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		old_val = old_pb_cfg->shared_pool_high_thresh[i];
+ 		new_val = new_pb_cfg->shared_pool_high_thresh[i];
+ 		if (new_val < old_val) {
+ 			reg = rd32(hw, I40E_PRTRPB_SHT(i));
+ 			reg &= ~I40E_PRTRPB_SHT_SHT_TCN_MASK;
+ 			reg |= (new_val << I40E_PRTRPB_SHT_SHT_TCN_SHIFT) &
+ 				I40E_PRTRPB_SHT_SHT_TCN_MASK;
+ 			wr32(hw, I40E_PRTRPB_SHT(i), reg);
+ 		}
+ 
+ 		old_val = old_pb_cfg->tc_pool_high_wm[i];
+ 		new_val = new_pb_cfg->tc_pool_high_wm[i];
+ 		if (new_val < old_val) {
+ 			reg = rd32(hw, I40E_PRTRPB_DHW(i));
+ 			reg &= ~I40E_PRTRPB_DHW_DHW_TCN_MASK;
+ 			reg |= (new_val << I40E_PRTRPB_DHW_DHW_TCN_SHIFT) &
+ 				I40E_PRTRPB_DHW_DHW_TCN_MASK;
+ 			wr32(hw, I40E_PRTRPB_DHW(i), reg);
+ 		}
+ 	}
+ 
+ 	/* Write Dedicated Pool Sizes per TC */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		new_val = new_pb_cfg->tc_pool_size[i];
+ 		reg = rd32(hw, I40E_PRTRPB_DPS(i));
+ 		reg &= ~I40E_PRTRPB_DPS_DPS_TCN_MASK;
+ 		reg |= (new_val << I40E_PRTRPB_DPS_DPS_TCN_SHIFT) &
+ 			I40E_PRTRPB_DPS_DPS_TCN_MASK;
+ 		wr32(hw, I40E_PRTRPB_DPS(i), reg);
+ 	}
+ 
+ 	/* Write Shared Pool Size per port */
+ 	new_val = new_pb_cfg->shared_pool_size;
+ 	reg = rd32(hw, I40E_PRTRPB_SPS);
+ 	reg &= ~I40E_PRTRPB_SPS_SPS_MASK;
+ 	reg |= (new_val << I40E_PRTRPB_SPS_SPS_SHIFT) &
+ 		I40E_PRTRPB_SPS_SPS_MASK;
+ 	wr32(hw, I40E_PRTRPB_SPS, reg);
+ 
+ 	/* Program the shared pool low water mark per port if increasing */
+ 	old_val = old_pb_cfg->shared_pool_low_wm;
+ 	new_val = new_pb_cfg->shared_pool_low_wm;
+ 	if (new_val > old_val) {
+ 		reg = rd32(hw, I40E_PRTRPB_SLW);
+ 		reg &= ~I40E_PRTRPB_SLW_SLW_MASK;
+ 		reg |= (new_val << I40E_PRTRPB_SLW_SLW_SHIFT) &
+ 			I40E_PRTRPB_SLW_SLW_MASK;
+ 		wr32(hw, I40E_PRTRPB_SLW, reg);
+ 	}
+ 
+ 	/* Program the shared pool low threshold and tc pool
+ 	 * low water mark per TC that are increasing.
+ 	 */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		old_val = old_pb_cfg->shared_pool_low_thresh[i];
+ 		new_val = new_pb_cfg->shared_pool_low_thresh[i];
+ 		if (new_val > old_val) {
+ 			reg = rd32(hw, I40E_PRTRPB_SLT(i));
+ 			reg &= ~I40E_PRTRPB_SLT_SLT_TCN_MASK;
+ 			reg |= (new_val << I40E_PRTRPB_SLT_SLT_TCN_SHIFT) &
+ 				I40E_PRTRPB_SLT_SLT_TCN_MASK;
+ 			wr32(hw, I40E_PRTRPB_SLT(i), reg);
+ 		}
+ 
+ 		old_val = old_pb_cfg->tc_pool_low_wm[i];
+ 		new_val = new_pb_cfg->tc_pool_low_wm[i];
+ 		if (new_val > old_val) {
+ 			reg = rd32(hw, I40E_PRTRPB_DLW(i));
+ 			reg &= ~I40E_PRTRPB_DLW_DLW_TCN_MASK;
+ 			reg |= (new_val << I40E_PRTRPB_DLW_DLW_TCN_SHIFT) &
+ 				I40E_PRTRPB_DLW_DLW_TCN_MASK;
+ 			wr32(hw, I40E_PRTRPB_DLW(i), reg);
+ 		}
+ 	}
+ 
+ 	/* Program the shared pool high water mark per port if increasing */
+ 	old_val = old_pb_cfg->shared_pool_high_wm;
+ 	new_val = new_pb_cfg->shared_pool_high_wm;
+ 	if (new_val > old_val) {
+ 		reg = rd32(hw, I40E_PRTRPB_SHW);
+ 		reg &= ~I40E_PRTRPB_SHW_SHW_MASK;
+ 		reg |= (new_val << I40E_PRTRPB_SHW_SHW_SHIFT) &
+ 			I40E_PRTRPB_SHW_SHW_MASK;
+ 		wr32(hw, I40E_PRTRPB_SHW, reg);
+ 	}
+ 
+ 	/* Program the shared pool high threshold and tc pool
+ 	 * high water mark per TC that are increasing.
+ 	 */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		old_val = old_pb_cfg->shared_pool_high_thresh[i];
+ 		new_val = new_pb_cfg->shared_pool_high_thresh[i];
+ 		if (new_val > old_val) {
+ 			reg = rd32(hw, I40E_PRTRPB_SHT(i));
+ 			reg &= ~I40E_PRTRPB_SHT_SHT_TCN_MASK;
+ 			reg |= (new_val << I40E_PRTRPB_SHT_SHT_TCN_SHIFT) &
+ 				I40E_PRTRPB_SHT_SHT_TCN_MASK;
+ 			wr32(hw, I40E_PRTRPB_SHT(i), reg);
+ 		}
+ 
+ 		old_val = old_pb_cfg->tc_pool_high_wm[i];
+ 		new_val = new_pb_cfg->tc_pool_high_wm[i];
+ 		if (new_val > old_val) {
+ 			reg = rd32(hw, I40E_PRTRPB_DHW(i));
+ 			reg &= ~I40E_PRTRPB_DHW_DHW_TCN_MASK;
+ 			reg |= (new_val << I40E_PRTRPB_DHW_DHW_TCN_SHIFT) &
+ 				I40E_PRTRPB_DHW_DHW_TCN_MASK;
+ 			wr32(hw, I40E_PRTRPB_DHW(i), reg);
+ 		}
+ 	}
+ }
+ 
+ /**
++>>>>>>> 262de08f64e3 (intel: clean up mismatched header comments)
   * _i40e_read_lldp_cfg - generic read of LLDP Configuration data from NVM
   * @hw: pointer to the HW structure
   * @lldp_cfg: pointer to hold lldp configuration variables
diff --cc drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c
index 9deae9a35423,e32c61909b31..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c
@@@ -94,6 -97,713 +94,716 @@@ static int i40e_dcbnl_ieee_getpfc(struc
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_dcbnl_ieee_setets - set IEEE ETS configuration
+  * @netdev: the corresponding netdev
+  * @ets: structure to hold the ETS information
+  *
+  * Set IEEE ETS configuration
+  **/
+ static int i40e_dcbnl_ieee_setets(struct net_device *netdev,
+ 				  struct ieee_ets *ets)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 	struct i40e_dcbx_config *old_cfg;
+ 	int i, ret;
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return -EINVAL;
+ 
+ 	old_cfg = &pf->hw.local_dcbx_config;
+ 	/* Copy current config into temp */
+ 	pf->tmp_cfg = *old_cfg;
+ 
+ 	/* Update the ETS configuration for temp */
+ 	pf->tmp_cfg.etscfg.willing = ets->willing;
+ 	pf->tmp_cfg.etscfg.maxtcs = I40E_MAX_TRAFFIC_CLASS;
+ 	pf->tmp_cfg.etscfg.cbs = ets->cbs;
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		pf->tmp_cfg.etscfg.tcbwtable[i] = ets->tc_tx_bw[i];
+ 		pf->tmp_cfg.etscfg.tsatable[i] = ets->tc_tsa[i];
+ 		pf->tmp_cfg.etscfg.prioritytable[i] = ets->prio_tc[i];
+ 		pf->tmp_cfg.etsrec.tcbwtable[i] = ets->tc_reco_bw[i];
+ 		pf->tmp_cfg.etsrec.tsatable[i] = ets->tc_reco_tsa[i];
+ 		pf->tmp_cfg.etsrec.prioritytable[i] = ets->reco_prio_tc[i];
+ 	}
+ 
+ 	/* Commit changes to HW */
+ 	ret = i40e_hw_dcb_config(pf, &pf->tmp_cfg);
+ 	if (ret) {
+ 		dev_info(&pf->pdev->dev,
+ 			 "Failed setting DCB ETS configuration err %s aq_err %s\n",
+ 			 i40e_stat_str(&pf->hw, ret),
+ 			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * i40e_dcbnl_ieee_setpfc - set local IEEE PFC configuration
+  * @netdev: the corresponding netdev
+  * @pfc: structure to hold the PFC information
+  *
+  * Sets local IEEE PFC configuration
+  **/
+ static int i40e_dcbnl_ieee_setpfc(struct net_device *netdev,
+ 				  struct ieee_pfc *pfc)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 	struct i40e_dcbx_config *old_cfg;
+ 	int ret;
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return -EINVAL;
+ 
+ 	old_cfg = &pf->hw.local_dcbx_config;
+ 	/* Copy current config into temp */
+ 	pf->tmp_cfg = *old_cfg;
+ 	if (pfc->pfc_cap)
+ 		pf->tmp_cfg.pfc.pfccap = pfc->pfc_cap;
+ 	else
+ 		pf->tmp_cfg.pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;
+ 	pf->tmp_cfg.pfc.pfcenable = pfc->pfc_en;
+ 
+ 	ret = i40e_hw_dcb_config(pf, &pf->tmp_cfg);
+ 	if (ret) {
+ 		dev_info(&pf->pdev->dev,
+ 			 "Failed setting DCB PFC configuration err %s aq_err %s\n",
+ 			 i40e_stat_str(&pf->hw, ret),
+ 			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * i40e_dcbnl_ieee_setapp - set local IEEE App configuration
+  * @netdev: the corresponding netdev
+  * @app: structure to hold the Application information
+  *
+  * Sets local IEEE App configuration
+  **/
+ static int i40e_dcbnl_ieee_setapp(struct net_device *netdev,
+ 				  struct dcb_app *app)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 	struct i40e_dcb_app_priority_table new_app;
+ 	struct i40e_dcbx_config *old_cfg;
+ 	int ret;
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return -EINVAL;
+ 
+ 	old_cfg = &pf->hw.local_dcbx_config;
+ 	if (old_cfg->numapps == I40E_DCBX_MAX_APPS)
+ 		return -EINVAL;
+ 
+ 	ret = dcb_ieee_setapp(netdev, app);
+ 	if (ret)
+ 		return ret;
+ 
+ 	new_app.selector = app->selector;
+ 	new_app.protocolid = app->protocol;
+ 	new_app.priority = app->priority;
+ 	/* Already internally available */
+ 	if (i40e_dcbnl_find_app(old_cfg, &new_app))
+ 		return 0;
+ 
+ 	/* Copy current config into temp */
+ 	pf->tmp_cfg = *old_cfg;
+ 	/* Add the app */
+ 	pf->tmp_cfg.app[pf->tmp_cfg.numapps++] = new_app;
+ 
+ 	ret = i40e_hw_dcb_config(pf, &pf->tmp_cfg);
+ 	if (ret) {
+ 		dev_info(&pf->pdev->dev,
+ 			 "Failed setting DCB configuration err %s aq_err %s\n",
+ 			 i40e_stat_str(&pf->hw, ret),
+ 			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * i40e_dcbnl_ieee_delapp - delete local IEEE App configuration
+  * @netdev: the corresponding netdev
+  * @app: structure to hold the Application information
+  *
+  * Deletes local IEEE App configuration other than the first application
+  * required by firmware
+  **/
+ static int i40e_dcbnl_ieee_delapp(struct net_device *netdev,
+ 				  struct dcb_app *app)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 	struct i40e_dcbx_config *old_cfg;
+ 	int i, j, ret;
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return -EINVAL;
+ 
+ 	ret = dcb_ieee_delapp(netdev, app);
+ 	if (ret)
+ 		return ret;
+ 
+ 	old_cfg = &pf->hw.local_dcbx_config;
+ 	/* Need one app for FW so keep it */
+ 	if (old_cfg->numapps == 1)
+ 		return 0;
+ 
+ 	/* Copy current config into temp */
+ 	pf->tmp_cfg = *old_cfg;
+ 
+ 	/* Find and reset the app */
+ 	for (i = 1; i < pf->tmp_cfg.numapps; i++) {
+ 		if (app->selector == pf->tmp_cfg.app[i].selector &&
+ 		    app->protocol == pf->tmp_cfg.app[i].protocolid &&
+ 		    app->priority == pf->tmp_cfg.app[i].priority) {
+ 			/* Reset the app data */
+ 			pf->tmp_cfg.app[i].selector = 0;
+ 			pf->tmp_cfg.app[i].protocolid = 0;
+ 			pf->tmp_cfg.app[i].priority = 0;
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* If the specific DCB app not found */
+ 	if (i == pf->tmp_cfg.numapps)
+ 		return -EINVAL;
+ 
+ 	pf->tmp_cfg.numapps--;
+ 	/* Overwrite the tmp_cfg app */
+ 	for (j = i; j < pf->tmp_cfg.numapps; j++)
+ 		pf->tmp_cfg.app[j] = old_cfg->app[j + 1];
+ 
+ 	ret = i40e_hw_dcb_config(pf, &pf->tmp_cfg);
+ 	if (ret) {
+ 		dev_info(&pf->pdev->dev,
+ 			 "Failed setting DCB configuration err %s aq_err %s\n",
+ 			 i40e_stat_str(&pf->hw, ret),
+ 			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * i40e_dcbnl_getstate - Get DCB enabled state
+  * @netdev: the corresponding netdev
+  *
+  * Get the current DCB enabled state
+  **/
+ static u8 i40e_dcbnl_getstate(struct net_device *netdev)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	dev_dbg(&pf->pdev->dev, "DCB state=%d\n",
+ 		!!(pf->flags & I40E_FLAG_DCB_ENABLED));
+ 	return !!(pf->flags & I40E_FLAG_DCB_ENABLED);
+ }
+ 
+ /**
+  * i40e_dcbnl_setstate - Set DCB state
+  * @netdev: the corresponding netdev
+  * @state: enable or disable
+  *
+  * Set the DCB state
+  **/
+ static u8 i40e_dcbnl_setstate(struct net_device *netdev, u8 state)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 	int ret = I40E_DCBNL_STATUS_SUCCESS;
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return ret;
+ 
+ 	dev_dbg(&pf->pdev->dev, "new state=%d current state=%d\n",
+ 		state, (pf->flags & I40E_FLAG_DCB_ENABLED) ? 1 : 0);
+ 	/* Nothing to do */
+ 	if (!state == !(pf->flags & I40E_FLAG_DCB_ENABLED))
+ 		return ret;
+ 
+ 	if (i40e_is_sw_dcb(pf)) {
+ 		if (state) {
+ 			pf->flags |= I40E_FLAG_DCB_ENABLED;
+ 			memcpy(&pf->hw.desired_dcbx_config,
+ 			       &pf->hw.local_dcbx_config,
+ 			       sizeof(struct i40e_dcbx_config));
+ 		} else {
+ 			pf->flags &= ~I40E_FLAG_DCB_ENABLED;
+ 		}
+ 	} else {
+ 		/* Cannot directly manipulate FW LLDP Agent */
+ 		ret = I40E_DCBNL_STATUS_ERROR;
+ 	}
+ 	return ret;
+ }
+ 
+ /**
+  * i40e_dcbnl_set_pg_tc_cfg_tx - Set CEE PG Tx config
+  * @netdev: the corresponding netdev
+  * @tc: the corresponding traffic class
+  * @prio_type: the traffic priority type
+  * @bwg_id: the BW group id the traffic class belongs to
+  * @bw_pct: the BW percentage for the corresponding BWG
+  * @up_map: prio mapped to corresponding tc
+  *
+  * Set Tx PG settings for CEE mode
+  **/
+ static void i40e_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev, int tc,
+ 					u8 prio_type, u8 bwg_id, u8 bw_pct,
+ 					u8 up_map)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 	int i;
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return;
+ 
+ 	/* LLTC not supported yet */
+ 	if (tc >= I40E_MAX_TRAFFIC_CLASS)
+ 		return;
+ 
+ 	/* prio_type, bwg_id and bw_pct per UP are not supported */
+ 
+ 	/* Use only up_map to map tc */
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		if (up_map & BIT(i))
+ 			pf->tmp_cfg.etscfg.prioritytable[i] = tc;
+ 	}
+ 	pf->tmp_cfg.etscfg.tsatable[tc] = I40E_IEEE_TSA_ETS;
+ 	dev_dbg(&pf->pdev->dev,
+ 		"Set PG config tc=%d bwg_id=%d prio_type=%d bw_pct=%d up_map=%d\n",
+ 		tc, bwg_id, prio_type, bw_pct, up_map);
+ }
+ 
+ /**
+  * i40e_dcbnl_set_pg_bwg_cfg_tx - Set CEE PG Tx BW config
+  * @netdev: the corresponding netdev
+  * @pgid: the corresponding traffic class
+  * @bw_pct: the BW percentage for the specified traffic class
+  *
+  * Set Tx BW settings for CEE mode
+  **/
+ static void i40e_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev, int pgid,
+ 					 u8 bw_pct)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return;
+ 
+ 	/* LLTC not supported yet */
+ 	if (pgid >= I40E_MAX_TRAFFIC_CLASS)
+ 		return;
+ 
+ 	pf->tmp_cfg.etscfg.tcbwtable[pgid] = bw_pct;
+ 	dev_dbg(&pf->pdev->dev, "Set PG BW config tc=%d bw_pct=%d\n",
+ 		pgid, bw_pct);
+ }
+ 
+ /**
+  * i40e_dcbnl_set_pg_tc_cfg_rx - Set CEE PG Rx config
+  * @netdev: the corresponding netdev
+  * @prio: the corresponding traffic class
+  * @prio_type: the traffic priority type
+  * @pgid: the BW group id the traffic class belongs to
+  * @bw_pct: the BW percentage for the corresponding BWG
+  * @up_map: prio mapped to corresponding tc
+  *
+  * Set Rx BW settings for CEE mode. The hardware does not support this
+  * so we won't allow setting of this parameter.
+  **/
+ static void i40e_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev,
+ 					int __always_unused prio,
+ 					u8 __always_unused prio_type,
+ 					u8 __always_unused pgid,
+ 					u8 __always_unused bw_pct,
+ 					u8 __always_unused up_map)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	dev_dbg(&pf->pdev->dev, "Rx TC PG Config Not Supported.\n");
+ }
+ 
+ /**
+  * i40e_dcbnl_set_pg_bwg_cfg_rx - Set CEE PG Rx config
+  * @netdev: the corresponding netdev
+  * @pgid: the corresponding traffic class
+  * @bw_pct: the BW percentage for the specified traffic class
+  *
+  * Set Rx BW settings for CEE mode. The hardware does not support this
+  * so we won't allow setting of this parameter.
+  **/
+ static void i40e_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev, int pgid,
+ 					 u8 bw_pct)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	dev_dbg(&pf->pdev->dev, "Rx BWG PG Config Not Supported.\n");
+ }
+ 
+ /**
+  * i40e_dcbnl_get_pg_tc_cfg_tx - Get CEE PG Tx config
+  * @netdev: the corresponding netdev
+  * @prio: the corresponding user priority
+  * @prio_type: traffic priority type
+  * @pgid: the BW group ID the traffic class belongs to
+  * @bw_pct: BW percentage for the corresponding BWG
+  * @up_map: prio mapped to corresponding TC
+  *
+  * Get Tx PG settings for CEE mode
+  **/
+ static void i40e_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev, int prio,
+ 					u8 __always_unused *prio_type,
+ 					u8 *pgid,
+ 					u8 __always_unused *bw_pct,
+ 					u8 __always_unused *up_map)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return;
+ 
+ 	if (prio >= I40E_MAX_USER_PRIORITY)
+ 		return;
+ 
+ 	*pgid = pf->hw.local_dcbx_config.etscfg.prioritytable[prio];
+ 	dev_dbg(&pf->pdev->dev, "Get PG config prio=%d tc=%d\n",
+ 		prio, *pgid);
+ }
+ 
+ /**
+  * i40e_dcbnl_get_pg_bwg_cfg_tx - Get CEE PG BW config
+  * @netdev: the corresponding netdev
+  * @pgid: the corresponding traffic class
+  * @bw_pct: the BW percentage for the corresponding TC
+  *
+  * Get Tx BW settings for given TC in CEE mode
+  **/
+ static void i40e_dcbnl_get_pg_bwg_cfg_tx(struct net_device *netdev, int pgid,
+ 					 u8 *bw_pct)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return;
+ 
+ 	if (pgid >= I40E_MAX_TRAFFIC_CLASS)
+ 		return;
+ 
+ 	*bw_pct = pf->hw.local_dcbx_config.etscfg.tcbwtable[pgid];
+ 	dev_dbg(&pf->pdev->dev, "Get PG BW config tc=%d bw_pct=%d\n",
+ 		pgid, *bw_pct);
+ }
+ 
+ /**
+  * i40e_dcbnl_get_pg_tc_cfg_rx - Get CEE PG Rx config
+  * @netdev: the corresponding netdev
+  * @prio: the corresponding user priority
+  * @prio_type: the traffic priority type
+  * @pgid: the PG ID
+  * @bw_pct: the BW percentage for the corresponding BWG
+  * @up_map: prio mapped to corresponding TC
+  *
+  * Get Rx PG settings for CEE mode. The UP2TC map is applied in same
+  * manner for Tx and Rx (symmetrical) so return the TC information for
+  * given priority accordingly.
+  **/
+ static void i40e_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev, int prio,
+ 					u8 *prio_type, u8 *pgid, u8 *bw_pct,
+ 					u8 *up_map)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return;
+ 
+ 	if (prio >= I40E_MAX_USER_PRIORITY)
+ 		return;
+ 
+ 	*pgid = pf->hw.local_dcbx_config.etscfg.prioritytable[prio];
+ }
+ 
+ /**
+  * i40e_dcbnl_get_pg_bwg_cfg_rx - Get CEE PG BW Rx config
+  * @netdev: the corresponding netdev
+  * @pgid: the corresponding traffic class
+  * @bw_pct: the BW percentage for the corresponding TC
+  *
+  * Get Rx BW settings for given TC in CEE mode
+  * The adapter doesn't support Rx ETS and runs in strict priority
+  * mode in Rx path and hence just return 0.
+  **/
+ static void i40e_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev, int pgid,
+ 					 u8 *bw_pct)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return;
+ 	*bw_pct = 0;
+ }
+ 
+ /**
+  * i40e_dcbnl_set_pfc_cfg - Set CEE PFC configuration
+  * @netdev: the corresponding netdev
+  * @prio: the corresponding user priority
+  * @setting: the PFC setting for given priority
+  *
+  * Set the PFC enabled/disabled setting for given user priority
+  **/
+ static void i40e_dcbnl_set_pfc_cfg(struct net_device *netdev, int prio,
+ 				   u8 setting)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return;
+ 
+ 	if (prio >= I40E_MAX_USER_PRIORITY)
+ 		return;
+ 
+ 	pf->tmp_cfg.pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;
+ 	if (setting)
+ 		pf->tmp_cfg.pfc.pfcenable |= BIT(prio);
+ 	else
+ 		pf->tmp_cfg.pfc.pfcenable &= ~BIT(prio);
+ 	dev_dbg(&pf->pdev->dev,
+ 		"Set PFC Config up=%d setting=%d pfcenable=0x%x\n",
+ 		prio, setting, pf->tmp_cfg.pfc.pfcenable);
+ }
+ 
+ /**
+  * i40e_dcbnl_get_pfc_cfg - Get CEE PFC configuration
+  * @netdev: the corresponding netdev
+  * @prio: the corresponding user priority
+  * @setting: the PFC setting for given priority
+  *
+  * Get the PFC enabled/disabled setting for given user priority
+  **/
+ static void i40e_dcbnl_get_pfc_cfg(struct net_device *netdev, int prio,
+ 				   u8 *setting)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return;
+ 
+ 	if (prio >= I40E_MAX_USER_PRIORITY)
+ 		return;
+ 
+ 	*setting = (pf->hw.local_dcbx_config.pfc.pfcenable >> prio) & 0x1;
+ 	dev_dbg(&pf->pdev->dev,
+ 		"Get PFC Config up=%d setting=%d pfcenable=0x%x\n",
+ 		prio, *setting, pf->hw.local_dcbx_config.pfc.pfcenable);
+ }
+ 
+ /**
+  * i40e_dcbnl_cee_set_all - Commit CEE DCB settings to hardware
+  * @netdev: the corresponding netdev
+  *
+  * Commit the current DCB configuration to hardware
+  **/
+ static u8 i40e_dcbnl_cee_set_all(struct net_device *netdev)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 	int err;
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return I40E_DCBNL_STATUS_ERROR;
+ 
+ 	dev_dbg(&pf->pdev->dev, "Commit DCB Configuration to the hardware\n");
+ 	err = i40e_hw_dcb_config(pf, &pf->tmp_cfg);
+ 
+ 	return err ? I40E_DCBNL_STATUS_ERROR : I40E_DCBNL_STATUS_SUCCESS;
+ }
+ 
+ /**
+  * i40e_dcbnl_get_cap - Get DCBX capabilities of adapter
+  * @netdev: the corresponding netdev
+  * @capid: the capability type
+  * @cap: the capability value
+  *
+  * Return the capability value for a given capability type
+  **/
+ static u8 i40e_dcbnl_get_cap(struct net_device *netdev, int capid, u8 *cap)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->flags & I40E_FLAG_DCB_CAPABLE))
+ 		return I40E_DCBNL_STATUS_ERROR;
+ 
+ 	switch (capid) {
+ 	case DCB_CAP_ATTR_PG:
+ 	case DCB_CAP_ATTR_PFC:
+ 		*cap = true;
+ 		break;
+ 	case DCB_CAP_ATTR_PG_TCS:
+ 	case DCB_CAP_ATTR_PFC_TCS:
+ 		*cap = 0x80;
+ 		break;
+ 	case DCB_CAP_ATTR_DCBX:
+ 		*cap = pf->dcbx_cap;
+ 		break;
+ 	case DCB_CAP_ATTR_UP2TC:
+ 	case DCB_CAP_ATTR_GSP:
+ 	case DCB_CAP_ATTR_BCN:
+ 	default:
+ 		*cap = false;
+ 		break;
+ 	}
+ 
+ 	dev_dbg(&pf->pdev->dev, "Get Capability cap=%d capval=0x%x\n",
+ 		capid, *cap);
+ 	return I40E_DCBNL_STATUS_SUCCESS;
+ }
+ 
+ /**
+  * i40e_dcbnl_getnumtcs - Get max number of traffic classes supported
+  * @netdev: the corresponding netdev
+  * @tcid: the TC id
+  * @num: total number of TCs supported by the device
+  *
+  * Return the total number of TCs supported by the adapter
+  **/
+ static int i40e_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	if (!(pf->flags & I40E_FLAG_DCB_CAPABLE))
+ 		return -EINVAL;
+ 
+ 	*num = I40E_MAX_TRAFFIC_CLASS;
+ 	return 0;
+ }
+ 
+ /**
+  * i40e_dcbnl_setnumtcs - Set CEE number of traffic classes
+  * @netdev: the corresponding netdev
+  * @tcid: the TC id
+  * @num: total number of TCs
+  *
+  * Set the total number of TCs (Unsupported)
+  **/
+ static int i40e_dcbnl_setnumtcs(struct net_device *netdev, int tcid, u8 num)
+ {
+ 	return -EINVAL;
+ }
+ 
+ /**
+  * i40e_dcbnl_getpfcstate - Get CEE PFC mode
+  * @netdev: the corresponding netdev
+  *
+  * Get the current PFC enabled state
+  **/
+ static u8 i40e_dcbnl_getpfcstate(struct net_device *netdev)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	/* Return enabled if any PFC enabled UP */
+ 	if (pf->hw.local_dcbx_config.pfc.pfcenable)
+ 		return 1;
+ 	else
+ 		return 0;
+ }
+ 
+ /**
+  * i40e_dcbnl_setpfcstate - Set CEE PFC mode
+  * @netdev: the corresponding netdev
+  * @state: required state
+  *
+  * The PFC state to be set; this is enabled/disabled based on the PFC
+  * priority settings and not via this call for i40e driver
+  **/
+ static void i40e_dcbnl_setpfcstate(struct net_device *netdev, u8 state)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	dev_dbg(&pf->pdev->dev, "PFC State is modified via PFC config.\n");
+ }
+ 
+ /**
+  * i40e_dcbnl_getapp - Get CEE APP
+  * @netdev: the corresponding netdev
+  * @idtype: the App selector
+  * @id: the App ethtype or port number
+  *
+  * Return the CEE mode app for the given idtype and id
+  **/
+ static int i40e_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 	struct dcb_app app = {
+ 				.selector = idtype,
+ 				.protocol = id,
+ 			     };
+ 
+ 	if (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_CEE) ||
+ 	    (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED))
+ 		return -EINVAL;
+ 
+ 	return dcb_getapp(netdev, &app);
+ }
+ 
+ /**
+  * i40e_dcbnl_setdcbx - set required DCBx capability
+  * @netdev: the corresponding netdev
+  * @mode: new DCB mode managed or CEE+IEEE
+  *
+  * Set DCBx capability features
+  **/
+ static u8 i40e_dcbnl_setdcbx(struct net_device *netdev, u8 mode)
+ {
+ 	struct i40e_pf *pf = i40e_netdev_to_pf(netdev);
+ 
+ 	/* Do not allow to set mode if managed by Firmware */
+ 	if (pf->dcbx_cap & DCB_CAP_DCBX_LLD_MANAGED)
+ 		return I40E_DCBNL_STATUS_ERROR;
+ 
+ 	/* No support for LLD_MANAGED modes or CEE+IEEE */
+ 	if ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||
+ 	    ((mode & DCB_CAP_DCBX_VER_IEEE) && (mode & DCB_CAP_DCBX_VER_CEE)) ||
+ 	    !(mode & DCB_CAP_DCBX_HOST))
+ 		return I40E_DCBNL_STATUS_ERROR;
+ 
+ 	/* Already set to the given mode no change */
+ 	if (mode == pf->dcbx_cap)
+ 		return I40E_DCBNL_STATUS_SUCCESS;
+ 
+ 	pf->dcbx_cap = mode;
+ 	if (mode & DCB_CAP_DCBX_VER_CEE)
+ 		pf->hw.local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_CEE;
+ 	else
+ 		pf->hw.local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_IEEE;
+ 
+ 	dev_dbg(&pf->pdev->dev, "mode=%d\n", mode);
+ 	return I40E_DCBNL_STATUS_SUCCESS;
+ }
+ 
+ /**
++>>>>>>> 262de08f64e3 (intel: clean up mismatched header comments)
   * i40e_dcbnl_getdcbx - retrieve current DCBx capability
   * @dev: the corresponding netdev
   *
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c b/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c
index c45315472245..86397c564dfc 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c
@@ -105,7 +105,7 @@ static int fm10k_dcbnl_ieee_setpfc(struct net_device *dev, struct ieee_pfc *pfc)
 }
 
 /**
- * fm10k_dcbnl_ieee_getdcbx - get the DCBX configuration for the device
+ * fm10k_dcbnl_getdcbx - get the DCBX configuration for the device
  * @dev: netdev interface for the device
  *
  * Returns that we support only IEEE DCB for this interface
@@ -116,7 +116,7 @@ static u8 fm10k_dcbnl_getdcbx(struct net_device __always_unused *dev)
 }
 
 /**
- * fm10k_dcbnl_ieee_setdcbx - get the DCBX configuration for the device
+ * fm10k_dcbnl_setdcbx - get the DCBX configuration for the device
  * @dev: netdev interface for the device
  * @mode: new mode for this device
  *
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c b/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c
index 1d27b2fb23af..5c77054d67c6 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c
@@ -185,7 +185,7 @@ void fm10k_dbg_q_vector_init(struct fm10k_q_vector *q_vector)
 }
 
 /**
- * fm10k_dbg_free_q_vector_dir - setup debugfs for the q_vectors
+ * fm10k_dbg_q_vector_exit - setup debugfs for the q_vectors
  * @q_vector: q_vector to allocate directories for
  **/
 void fm10k_dbg_q_vector_exit(struct fm10k_q_vector *q_vector)
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_main.c b/drivers/net/ethernet/intel/fm10k/fm10k_main.c
index 247f44f4cb30..3362f26d7f99 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_main.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_main.c
@@ -1774,7 +1774,7 @@ static void fm10k_free_q_vectors(struct fm10k_intfc *interface)
 }
 
 /**
- * f10k_reset_msix_capability - reset MSI-X capability
+ * fm10k_reset_msix_capability - reset MSI-X capability
  * @interface: board private structure to initialize
  *
  * Reset the MSI-X capability back to its starting state
@@ -1787,7 +1787,7 @@ static void fm10k_reset_msix_capability(struct fm10k_intfc *interface)
 }
 
 /**
- * f10k_init_msix_capability - configure MSI-X capability
+ * fm10k_init_msix_capability - configure MSI-X capability
  * @interface: board private structure to initialize
  *
  * Attempt to configure the interrupts using the best available
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c b/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c
index 8e2e92bf3cd4..a2642b9b3602 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c
@@ -692,7 +692,7 @@ static bool fm10k_mbx_tx_complete(struct fm10k_mbx_info *mbx)
 }
 
 /**
- *  fm10k_mbx_deqeueue_rx - Dequeues the message from the head in the Rx FIFO
+ *  fm10k_mbx_dequeue_rx - Dequeues the message from the head in the Rx FIFO
  *  @hw: pointer to hardware structure
  *  @mbx: pointer to mailbox
  *
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_pf.c b/drivers/net/ethernet/intel/fm10k/fm10k_pf.c
index c0780c3624c8..af1b0cde3670 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_pf.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_pf.c
@@ -1417,7 +1417,7 @@ s32 fm10k_iov_msg_lport_state_pf(struct fm10k_hw *hw, u32 **results,
 }
 
 /**
- *  fm10k_update_stats_hw_pf - Updates hardware related statistics of PF
+ *  fm10k_update_hw_stats_pf - Updates hardware related statistics of PF
  *  @hw: pointer to hardware structure
  *  @stats: pointer to the stats structure to update
  *
diff --git a/drivers/net/ethernet/intel/i40e/i40e_common.c b/drivers/net/ethernet/intel/i40e/i40e_common.c
index adc9e4fa4789..acb492834eee 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c
@@ -2332,7 +2332,7 @@ i40e_status i40e_aq_set_vsi_vlan_promisc(struct i40e_hw *hw,
 }
 
 /**
- * i40e_get_vsi_params - get VSI configuration info
+ * i40e_aq_get_vsi_params - get VSI configuration info
  * @hw: pointer to the hw struct
  * @vsi_ctx: pointer to a vsi context struct
  * @cmd_details: pointer to command details structure or NULL
@@ -2586,7 +2586,7 @@ i40e_status i40e_get_link_status(struct i40e_hw *hw, bool *link_up)
 }
 
 /**
- * i40e_updatelink_status - update status of the HW network link
+ * i40e_update_link_info - update status of the HW network link
  * @hw: pointer to the hw struct
  **/
 noinline_for_stack i40e_status i40e_update_link_info(struct i40e_hw *hw)
@@ -4996,7 +4996,7 @@ u8 i40e_get_phy_address(struct i40e_hw *hw, u8 dev_num)
 }
 
 /**
- * i40e_blink_phy_led
+ * i40e_blink_phy_link_led
  * @hw: pointer to the HW structure
  * @time: time how long led will blinks in secs
  * @interval: gap between LED on and off in msecs
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_dcb.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ddp.c b/drivers/net/ethernet/intel/i40e/i40e_ddp.c
index 5e08f100c413..e1069ae658ad 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ddp.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ddp.c
@@ -77,7 +77,7 @@ static bool i40e_ddp_profiles_overlap(struct i40e_profile_info *new,
 }
 
 /**
- * i40e_ddp_does_profiles_ - checks if DDP overlaps with existing one.
+ * i40e_ddp_does_profile_overlap - checks if DDP overlaps with existing one.
  * @hw: HW data structure
  * @pinfo: DDP profile information structure
  *
diff --git a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
index d7c13ca9be7d..e8230da29f05 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
@@ -651,7 +651,7 @@ static void i40e_dbg_dump_vsi_no_seid(struct i40e_pf *pf)
 }
 
 /**
- * i40e_dbg_dump_stats - handles dump stats write into command datum
+ * i40e_dbg_dump_eth_stats - handles dump stats write into command datum
  * @pf: the i40e_pf created in command write
  * @estats: the eth stats structure to be dumped
  **/
@@ -1638,7 +1638,7 @@ static const struct file_operations i40e_dbg_command_fops = {
 static char i40e_dbg_netdev_ops_buf[256] = "";
 
 /**
- * i40e_dbg_netdev_ops - read for netdev_ops datum
+ * i40e_dbg_netdev_ops_read - read for netdev_ops datum
  * @filp: the opened file
  * @buffer: where to write the data for the user to read
  * @count: the size of the user's buffer
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 402f4fc20bc1..184ecfc3600b 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -212,7 +212,7 @@ static void __i40e_add_stat_strings(u8 **p, const struct i40e_stats stats[],
 }
 
 /**
- * 40e_add_stat_strings - copy stat strings into ethtool buffer
+ * i40e_add_stat_strings - copy stat strings into ethtool buffer
  * @p: ethtool supplied buffer
  * @stats: stat definitions array
  *
diff --git a/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c b/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c
index a3da422ab05b..d6e92ecddfbd 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c
@@ -511,7 +511,7 @@ i40e_status i40e_configure_lan_hmc(struct i40e_hw *hw,
 }
 
 /**
- * i40e_delete_hmc_object - remove hmc objects
+ * i40e_delete_lan_hmc_object - remove hmc objects
  * @hw: pointer to the HW structure
  * @info: pointer to i40e_hmc_delete_obj_info struct
  *
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 8048edf980ca..1d6fec528be0 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -2025,7 +2025,7 @@ static void i40e_undo_add_filter_entries(struct i40e_vsi *vsi,
 }
 
 /**
- * i40e_next_entry - Get the next non-broadcast filter from a list
+ * i40e_next_filter - Get the next non-broadcast filter from a list
  * @next: pointer to filter in list
  *
  * Returns the next non-broadcast filter in the list. Required so that we
@@ -5177,7 +5177,7 @@ static u8 i40e_pf_get_num_tc(struct i40e_pf *pf)
 }
 
 /**
- * i40e_pf_get_pf_tc_map - Get bitmap for enabled traffic classes
+ * i40e_pf_get_tc_map - Get bitmap for enabled traffic classes
  * @pf: PF being queried
  *
  * Return a bitmap for enabled traffic classes for this PF.
@@ -9013,7 +9013,7 @@ static void i40e_fdir_flush_and_replay(struct i40e_pf *pf)
 }
 
 /**
- * i40e_get_current_atr_count - Get the count of total FD ATR filters programmed
+ * i40e_get_current_atr_cnt - Get the count of total FD ATR filters programmed
  * @pf: board private structure
  **/
 u32 i40e_get_current_atr_cnt(struct i40e_pf *pf)
diff --git a/drivers/net/ethernet/intel/i40e/i40e_nvm.c b/drivers/net/ethernet/intel/i40e/i40e_nvm.c
index 7164f4ad8120..fe6dca846028 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_nvm.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_nvm.c
@@ -4,7 +4,7 @@
 #include "i40e_prototype.h"
 
 /**
- * i40e_init_nvm_ops - Initialize NVM function pointers
+ * i40e_init_nvm - Initialize NVM function pointers
  * @hw: pointer to the HW structure
  *
  * Setup the function pointers and the NVM info structure. Should be called
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ptp.c b/drivers/net/ethernet/intel/i40e/i40e_ptp.c
index 7a879614ca55..f1f6fc3744e9 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ptp.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ptp.c
@@ -216,7 +216,7 @@ static int i40e_ptp_feature_enable(struct ptp_clock_info *ptp,
 }
 
 /**
- * i40e_ptp_update_latch_events - Read I40E_PRTTSYN_STAT_1 and latch events
+ * i40e_ptp_get_rx_events - Read I40E_PRTTSYN_STAT_1 and latch events
  * @pf: the PF data structure
  *
  * This function reads I40E_PRTTSYN_STAT_1 and updates the corresponding timers
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
index f4f60087c77c..3865ef49c09b 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@ -3208,7 +3208,7 @@ static int i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
 }
 
 /**
- * i40e_create_tx_ctx Build the Tx context descriptor
+ * i40e_create_tx_ctx - Build the Tx context descriptor
  * @tx_ring:  ring to create the descriptor on
  * @cd_type_cmd_tso_mss: Quad Word 1
  * @cd_tunneling: Quad Word 0 - bits 0-31
diff --git a/drivers/net/ethernet/intel/i40e/i40e_xsk.c b/drivers/net/ethernet/intel/i40e/i40e_xsk.c
index fdb4bf6e6a23..20a89a0fd965 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_xsk.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_xsk.c
@@ -565,7 +565,7 @@ void i40e_xsk_clean_rx_ring(struct i40e_ring *rx_ring)
 }
 
 /**
- * i40e_xsk_clean_xdp_ring - Clean the XDP Tx ring on shutdown
+ * i40e_xsk_clean_tx_ring - Clean the XDP Tx ring on shutdown
  * @tx_ring: XDP Tx ring
  **/
 void i40e_xsk_clean_tx_ring(struct i40e_ring *tx_ring)
diff --git a/drivers/net/ethernet/intel/iavf/iavf_main.c b/drivers/net/ethernet/intel/iavf/iavf_main.c
index 524f17550f40..da92c61d6a81 100644
--- a/drivers/net/ethernet/intel/iavf/iavf_main.c
+++ b/drivers/net/ethernet/intel/iavf/iavf_main.c
@@ -2530,7 +2530,7 @@ static int iavf_validate_tx_bandwidth(struct iavf_adapter *adapter,
 }
 
 /**
- * iavf_validate_channel_config - validate queue mapping info
+ * iavf_validate_ch_config - validate queue mapping info
  * @adapter: board private structure
  * @mqprio_qopt: queue parameters
  *
diff --git a/drivers/net/ethernet/intel/iavf/iavf_txrx.c b/drivers/net/ethernet/intel/iavf/iavf_txrx.c
index ffaf2742a2e0..d6cba53a3a21 100644
--- a/drivers/net/ethernet/intel/iavf/iavf_txrx.c
+++ b/drivers/net/ethernet/intel/iavf/iavf_txrx.c
@@ -2098,7 +2098,7 @@ static int iavf_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags,
 }
 
 /**
- * iavf_create_tx_ctx Build the Tx context descriptor
+ * iavf_create_tx_ctx - Build the Tx context descriptor
  * @tx_ring:  ring to create the descriptor on
  * @cd_type_cmd_tso_mss: Quad Word 1
  * @cd_tunneling: Quad Word 0 - bits 0-31
diff --git a/drivers/net/ethernet/intel/iavf/iavf_virtchnl.c b/drivers/net/ethernet/intel/iavf/iavf_virtchnl.c
index 647e7fde11b4..b5317d1e5541 100644
--- a/drivers/net/ethernet/intel/iavf/iavf_virtchnl.c
+++ b/drivers/net/ethernet/intel/iavf/iavf_virtchnl.c
@@ -1005,7 +1005,7 @@ iavf_set_adapter_link_speed_from_vpe(struct iavf_adapter *adapter,
 }
 
 /**
- * iavf_enable_channel
+ * iavf_enable_channels
  * @adapter: adapter structure
  *
  * Request that the PF enable channels as specified by
@@ -1046,7 +1046,7 @@ void iavf_enable_channels(struct iavf_adapter *adapter)
 }
 
 /**
- * iavf_disable_channel
+ * iavf_disable_channels
  * @adapter: adapter structure
  *
  * Request that the PF disable channels that are configured
diff --git a/drivers/net/ethernet/intel/igb/e1000_mbx.c b/drivers/net/ethernet/intel/igb/e1000_mbx.c
index 33cceb77e960..29383112bc19 100644
--- a/drivers/net/ethernet/intel/igb/e1000_mbx.c
+++ b/drivers/net/ethernet/intel/igb/e1000_mbx.c
@@ -441,7 +441,7 @@ static s32 igb_read_mbx_pf(struct e1000_hw *hw, u32 *msg, u16 size,
 }
 
 /**
- *  e1000_init_mbx_params_pf - set initial values for pf mailbox
+ *  igb_init_mbx_params_pf - set initial values for pf mailbox
  *  @hw: pointer to the HW structure
  *
  *  Initializes the hw->mbx struct to correct values for pf mailbox
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index 293c055f2810..ce9bb75dce66 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -2039,7 +2039,7 @@ static void igb_power_down_link(struct igb_adapter *adapter)
 }
 
 /**
- * Detect and switch function for Media Auto Sense
+ * igb_check_swap_media -  Detect and switch function for Media Auto Sense
  * @adapter: address of the board private structure
  **/
 static void igb_check_swap_media(struct igb_adapter *adapter)
@@ -4022,7 +4022,7 @@ static int igb_sw_init(struct igb_adapter *adapter)
 }
 
 /**
- *  igb_open - Called when a network interface is made active
+ *  __igb_open - Called when a network interface is made active
  *  @netdev: network interface device structure
  *  @resuming: indicates whether we are in a resume call
  *
@@ -4140,7 +4140,7 @@ int igb_open(struct net_device *netdev)
 }
 
 /**
- *  igb_close - Disables a network interface
+ *  __igb_close - Disables a network interface
  *  @netdev: network interface device structure
  *  @suspending: indicates we are in a suspend call
  *
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
index 8d3798a32f0e..f9a31f1ac7bc 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
@@ -1351,7 +1351,7 @@ static u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
 }
 
 /**
- *  ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter
+ *  ixgbe_fdir_add_signature_filter_82599 - Adds a signature hash filter
  *  @hw: pointer to hardware structure
  *  @input: unique input dword
  *  @common: compressed common input dword
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
index 62ddb452f862..9521d335ea07 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
@@ -2707,7 +2707,7 @@ s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_enable_rx_buff - Enables the receive data path
+ *  ixgbe_enable_rx_buff_generic - Enables the receive data path
  *  @hw: pointer to hardware structure
  *
  *  Enables the receive data path
@@ -3029,14 +3029,14 @@ s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
 }
 
 /**
+ *  ixgbe_set_vmdq_san_mac_generic - Associate VMDq pool index with a rx address
+ *  @hw: pointer to hardware struct
+ *  @vmdq: VMDq pool index
+ *
  *  This function should only be involved in the IOV mode.
  *  In IOV mode, Default pool is next pool after the number of
  *  VFs advertized and not 0.
  *  MPSAR table needs to be updated for SAN_MAC RAR [hw->mac.san_mac_rar_index]
- *
- *  ixgbe_set_vmdq_san_mac - Associate default VMDq pool index with a rx address
- *  @hw: pointer to hardware struct
- *  @vmdq: VMDq pool index
  **/
 s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq)
 {
@@ -3896,7 +3896,7 @@ static s32 ixgbe_get_ets_data(struct ixgbe_hw *hw, u16 *ets_cfg,
 }
 
 /**
- *  ixgbe_get_thermal_sensor_data - Gathers thermal sensor data
+ *  ixgbe_get_thermal_sensor_data_generic - Gathers thermal sensor data
  *  @hw: pointer to hardware structure
  *
  *  Returns the thermal sensor data structure
@@ -4054,8 +4054,7 @@ void ixgbe_get_orom_version(struct ixgbe_hw *hw,
 }
 
 /**
- *  ixgbe_get_oem_prod_version Etrack ID from EEPROM
- *
+ *  ixgbe_get_oem_prod_version - Etrack ID from EEPROM
  *  @hw: pointer to hardware structure
  *  @nvm_ver: pointer to output structure
  *
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index ee7da5cadab7..d3a553171244 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -226,7 +226,7 @@ static s32 ixgbe_get_parent_bus_info(struct ixgbe_adapter *adapter)
 }
 
 /**
- * ixgbe_check_from_parent - Determine whether PCIe info should come from parent
+ * ixgbe_pcie_from_parent - Determine whether PCIe info should come from parent
  * @hw: hw specific details
  *
  * This function is used by probe to determine whether a device's PCI-Express
@@ -6149,7 +6149,7 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
 }
 
 /**
- * ixgbe_eee_capable - helper function to determine EEE support on X550
+ * ixgbe_set_eee_capable - helper function to determine EEE support on X550
  * @adapter: board private structure
  */
 static void ixgbe_set_eee_capable(struct ixgbe_adapter *adapter)
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
index f77fa3e4fdd1..070fc3f0ebec 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
@@ -461,12 +461,13 @@ s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_read_phy_mdi - Reads a value from a specified PHY register without
- *  the SWFW lock
+ *  ixgbe_read_phy_reg_mdi - read PHY register
  *  @hw: pointer to hardware structure
  *  @reg_addr: 32 bit address of PHY register to read
  *  @device_type: 5 bit device type
  *  @phy_data: Pointer to read data from PHY register
+ *
+ *  Reads a value from a specified PHY register without the SWFW lock
  **/
 s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
 		       u16 *phy_data)
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
index de563cfd294d..c6d20060c5d1 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
@@ -702,7 +702,7 @@ static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)
 }
 
 /**
- * ixgbe_release_nvm_semaphore - Release hardware semaphore
+ * ixgbe_release_swfw_sync_semaphore - Release hardware semaphore
  * @hw: pointer to hardware structure
  *
  * This function clears hardware semaphore bits.
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
index 5e339afa682a..9724ffb16518 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
@@ -1248,7 +1248,7 @@ static s32 ixgbe_get_bus_info_X550em(struct ixgbe_hw *hw)
 }
 
 /**
- * ixgbe_fw_recovery_mode - Check FW NVM recovery mode
+ * ixgbe_fw_recovery_mode_X550 - Check FW NVM recovery mode
  * @hw: pointer t hardware structure
  *
  * Returns true if in FW NVM recovery mode.
diff --git a/drivers/net/ethernet/intel/ixgbevf/vf.c b/drivers/net/ethernet/intel/ixgbevf/vf.c
index bfe6dfcec4ab..5fc347abab3c 100644
--- a/drivers/net/ethernet/intel/ixgbevf/vf.c
+++ b/drivers/net/ethernet/intel/ixgbevf/vf.c
@@ -121,9 +121,11 @@ static s32 ixgbevf_reset_hw_vf(struct ixgbe_hw *hw)
 }
 
 /**
+ * ixgbevf_hv_reset_hw_vf - reset via Hyper-V
+ * @hw: pointer to private hardware struct
+ *
  * Hyper-V variant; the VF/PF communication is through the PCI
  * config space.
- * @hw: pointer to private hardware struct
  */
 static s32 ixgbevf_hv_reset_hw_vf(struct ixgbe_hw *hw)
 {
@@ -513,9 +515,11 @@ static s32 ixgbevf_update_mc_addr_list_vf(struct ixgbe_hw *hw,
 }
 
 /**
- * Hyper-V variant - just a stub.
+ * ixgbevf_hv_update_mc_addr_list_vf - stub
  * @hw: unused
  * @netdev: unused
+ *
+ * Hyper-V variant - just a stub.
  */
 static s32 ixgbevf_hv_update_mc_addr_list_vf(struct ixgbe_hw *hw,
 					     struct net_device *netdev)
@@ -564,9 +568,11 @@ static s32 ixgbevf_update_xcast_mode(struct ixgbe_hw *hw, int xcast_mode)
 }
 
 /**
- * Hyper-V variant - just a stub.
+ * ixgbevf_hv_update_xcast_mode - stub
  * @hw: unused
  * @xcast_mode: unused
+ *
+ * Hyper-V variant - just a stub.
  */
 static s32 ixgbevf_hv_update_xcast_mode(struct ixgbe_hw *hw, int xcast_mode)
 {
@@ -608,7 +614,7 @@ static s32 ixgbevf_set_vfta_vf(struct ixgbe_hw *hw, u32 vlan, u32 vind,
 }
 
 /**
- * Hyper-V variant - just a stub.
+ * ixgbevf_hv_set_vfta_vf - * Hyper-V variant - just a stub.
  * @hw: unused
  * @vlan: unused
  * @vind: unused
@@ -726,11 +732,13 @@ static s32 ixgbevf_check_mac_link_vf(struct ixgbe_hw *hw,
 }
 
 /**
- * Hyper-V variant; there is no mailbox communication.
+ * ixgbevf_hv_check_mac_link_vf - check link
  * @hw: pointer to private hardware struct
  * @speed: pointer to link speed
  * @link_up: true is link is up, false otherwise
  * @autoneg_wait_to_complete: unused
+ *
+ * Hyper-V variant; there is no mailbox communication.
  */
 static s32 ixgbevf_hv_check_mac_link_vf(struct ixgbe_hw *hw,
 					ixgbe_link_speed *speed,
