PCI/ERR: Clear AER status only when we control AER

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Sean V Kelley <sean.v.kelley@intel.com>
commit aa344bc8b727b47b4350b59d8166216a3f351e55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/aa344bc8.failed

In some cases a bridge may not exist as the hardware controlling may be
handled only by firmware and so is not visible to the OS. This scenario is
also possible in future use cases involving non-native use of RCECs by
firmware. In this scenario, we expect the platform to retain control of the
bridge and to clear error status itself.

Clear error status only when the OS has native control of AER.

	Signed-off-by: Sean V Kelley <sean.v.kelley@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit aa344bc8b727b47b4350b59d8166216a3f351e55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pcie/err.c
diff --cc drivers/pci/pcie/err.c
index c74d622dbbc4,45a0ce95632a..000000000000
--- a/drivers/pci/pcie/err.c
+++ b/drivers/pci/pcie/err.c
@@@ -146,29 -146,49 +146,33 @@@ out
  	return 0;
  }
  
 -/**
 - * pci_walk_bridge - walk bridges potentially AER affected
 - * @bridge:	bridge which may be a Port
 - * @cb:		callback to be called for each device found
 - * @userdata:	arbitrary pointer to be passed to callback
 - *
 - * If the device provided is a bridge, walk the subordinate bus, including
 - * any bridged devices on buses under this bus.  Call the provided callback
 - * on each device found.
 - */
 -static void pci_walk_bridge(struct pci_dev *bridge,
 -			    int (*cb)(struct pci_dev *, void *),
 -			    void *userdata)
 -{
 -	if (bridge->subordinate)
 -		pci_walk_bus(bridge->subordinate, cb, userdata);
 -}
 -
  pci_ers_result_t pcie_do_recovery(struct pci_dev *dev,
 -		pci_channel_state_t state,
 -		pci_ers_result_t (*reset_subordinates)(struct pci_dev *pdev))
 +			enum pci_channel_state state,
 +			pci_ers_result_t (*reset_link)(struct pci_dev *pdev))
  {
  	int type = pci_pcie_type(dev);
 -	struct pci_dev *bridge;
  	pci_ers_result_t status = PCI_ERS_RESULT_CAN_RECOVER;
++<<<<<<< HEAD
 +	struct pci_bus *bus;
++=======
+ 	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
++>>>>>>> aa344bc8b727 (PCI/ERR: Clear AER status only when we control AER)
  
  	/*
 -	 * Error recovery runs on all subordinates of the bridge.  If the
 -	 * bridge detected the error, it is cleared at the end.
 +	 * Error recovery runs on all subordinates of the first downstream port.
 +	 * If the downstream port detected the error, it is cleared at the end.
  	 */
 -	if (type == PCI_EXP_TYPE_ROOT_PORT ||
 -	    type == PCI_EXP_TYPE_DOWNSTREAM)
 -		bridge = dev;
 -	else
 -		bridge = pci_upstream_bridge(dev);
 +	if (!(type == PCI_EXP_TYPE_ROOT_PORT ||
 +	      type == PCI_EXP_TYPE_DOWNSTREAM))
 +		dev = pci_upstream_bridge(dev);
 +	bus = dev->subordinate;
  
 -	pci_dbg(bridge, "broadcast error_detected message\n");
 +	pci_dbg(dev, "broadcast error_detected message\n");
  	if (state == pci_channel_io_frozen) {
 -		pci_walk_bridge(bridge, report_frozen_detected, &status);
 -		status = reset_subordinates(bridge);
 +		pci_walk_bus(bus, report_frozen_detected, &status);
 +		status = reset_link(dev);
  		if (status != PCI_ERS_RESULT_RECOVERED) {
 -			pci_warn(bridge, "subordinate device reset failed\n");
 +			pci_warn(dev, "link reset failed\n");
  			goto failed;
  		}
  	} else {
@@@ -195,13 -215,21 +199,28 @@@
  	if (status != PCI_ERS_RESULT_RECOVERED)
  		goto failed;
  
 -	pci_dbg(bridge, "broadcast resume message\n");
 -	pci_walk_bridge(bridge, report_resume, &status);
 +	pci_dbg(dev, "broadcast resume message\n");
 +	pci_walk_bus(bus, report_resume, &status);
  
++<<<<<<< HEAD
 +	if (pcie_aer_is_native(dev))
 +		pcie_clear_device_status(dev);
 +	pci_aer_clear_nonfatal_status(dev);
 +	pci_info(dev, "device recovery successful\n");
++=======
+ 	/*
+ 	 * If we have native control of AER, clear error status in the Root
+ 	 * Port or Downstream Port that signaled the error.  If the
+ 	 * platform retained control of AER, it is responsible for clearing
+ 	 * this status.  In that case, the signaling device may not even be
+ 	 * visible to the OS.
+ 	 */
+ 	if (host->native_aer || pcie_ports_native) {
+ 		pcie_clear_device_status(bridge);
+ 		pci_aer_clear_nonfatal_status(bridge);
+ 	}
+ 	pci_info(bridge, "device recovery successful\n");
++>>>>>>> aa344bc8b727 (PCI/ERR: Clear AER status only when we control AER)
  	return status;
  
  failed:
* Unmerged path drivers/pci/pcie/err.c
