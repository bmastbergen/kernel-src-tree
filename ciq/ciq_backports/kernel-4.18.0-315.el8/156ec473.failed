platform/x86: amd-pmc: Add AMD platform support for S2Idle

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
commit 156ec4731cb22b06c08e27debc1ef9f16f4bbb5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/156ec473.failed

AMD Power Management Controller driver a.k.a. amd-pmc driver is the
controller which is meant for the final S2Idle transaction that goes to
the PMFW running on the AMD SMU (System Management Unit) responsible for
tuning of the VDD.

Once all the monitored list or the idle constraints are met, this driver
would go and set the OS_HINT (meaning all the devices have reached to
their lowest state possible) via the SMU mailboxes.

This driver would also provide some debug capabilities via debugfs.

	Signed-off-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
Link: https://lore.kernel.org/r/20201105140531.2955555-1-Shyam-sundar.S-k@amd.com
	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit 156ec4731cb22b06c08e27debc1ef9f16f4bbb5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
#	drivers/platform/x86/Kconfig
#	drivers/platform/x86/Makefile
diff --cc MAINTAINERS
index d6a72e992d56,0e54a5841b98..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -787,10 -912,36 +787,39 @@@ F:	drivers/gpu/drm/amd/amdgpu/amdgpu_am
  F:	drivers/gpu/drm/amd/amdkfd/
  F:	drivers/gpu/drm/amd/include/cik_structs.h
  F:	drivers/gpu/drm/amd/include/kgd_kfd_interface.h
 -F:	drivers/gpu/drm/amd/include/v9_structs.h
  F:	drivers/gpu/drm/amd/include/vi_structs.h
 +F:	drivers/gpu/drm/amd/include/v9_structs.h
  F:	include/uapi/linux/kfd_ioctl.h
  
++<<<<<<< HEAD
++=======
+ AMD SPI DRIVER
+ M:	Sanjay R Mehta <sanju.mehta@amd.com>
+ S:	Maintained
+ F:	drivers/spi/spi-amd.c
+ 
+ AMD MP2 I2C DRIVER
+ M:	Elie Morisse <syniurge@gmail.com>
+ M:	Nehal Shah <nehal-bakulchandra.shah@amd.com>
+ M:	Shyam Sundar S K <shyam-sundar.s-k@amd.com>
+ L:	linux-i2c@vger.kernel.org
+ S:	Maintained
+ F:	drivers/i2c/busses/i2c-amd-mp2*
+ 
+ AMD PMC DRIVER
+ M:	Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	drivers/platform/x86/amd-pmc.*
+ 
+ AMD POWERPLAY
+ M:	Evan Quan <evan.quan@amd.com>
+ L:	amd-gfx@lists.freedesktop.org
+ S:	Supported
+ T:	git git://people.freedesktop.org/~agd5f/linux
+ F:	drivers/gpu/drm/amd/powerplay/
+ 
++>>>>>>> 156ec4731cb2 (platform/x86: amd-pmc: Add AMD platform support for S2Idle)
  AMD SEATTLE DEVICE TREE SUPPORT
  M:	Brijesh Singh <brijeshkumar.singh@amd.com>
  M:	Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
diff --cc drivers/platform/x86/Kconfig
index 2a795afbb303,a8ea8ab093b9..000000000000
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@@ -15,40 -16,113 +15,41 @@@ menuconfig X86_PLATFORM_DEVICE
  
  if X86_PLATFORM_DEVICES
  
 -config ACPI_WMI
 -	tristate "WMI"
 -	depends on ACPI
 -	help
 -	  This driver adds support for the ACPI-WMI (Windows Management
 -	  Instrumentation) mapper device (PNP0C14) found on some systems.
 -
 -	  ACPI-WMI is a proprietary extension to ACPI to expose parts of the
 -	  ACPI firmware to userspace - this is done through various vendor
 -	  defined methods and data blocks in a PNP0C14 device, which are then
 -	  made available for userspace to call.
 -
 -	  The implementation of this in Linux currently only exposes this to
 -	  other kernel space drivers.
 -
 -	  This driver is a required dependency to build the firmware specific
 -	  drivers needed on many machines, including Acer and HP laptops.
 -
 -	  It is safe to enable this driver even if your DSDT doesn't define
 -	  any ACPI-WMI devices.
 -
 -config WMI_BMOF
 -	tristate "WMI embedded Binary MOF driver"
 -	depends on ACPI_WMI
 -	default ACPI_WMI
 -	help
 -	  Say Y here if you want to be able to read a firmware-embedded
 -	  WMI Binary MOF data. Using this requires userspace tools and may be
 -	  rather tedious.
 -
 -	  To compile this driver as a module, choose M here: the module will
 -	  be called wmi-bmof.
 -
 -config ALIENWARE_WMI
 -	tristate "Alienware Special feature control"
 +config ACER_WMI
 +	tristate "Acer WMI Laptop Extras"
  	depends on ACPI
 -	depends on LEDS_CLASS
 -	depends on NEW_LEDS
 -	depends on ACPI_WMI
 -	help
 -	 This is a driver for controlling Alienware BIOS driven
 -	 features.  It exposes an interface for controlling the AlienFX
 -	 zones on Alienware machines that don't contain a dedicated AlienFX
 -	 USB MCU such as the X51 and X51-R2.
 -
 -config HUAWEI_WMI
 -	tristate "Huawei WMI laptop extras driver"
 -	depends on ACPI_BATTERY
 -	depends on ACPI_WMI
 -	depends on INPUT
 -	select INPUT_SPARSEKMAP
  	select LEDS_CLASS
 -	select LEDS_TRIGGERS
 -	select LEDS_TRIGGER_AUDIO
  	select NEW_LEDS
 -	help
 -	  This driver provides support for Huawei WMI hotkeys, battery charge
 -	  control, fn-lock, mic-mute LED, and other extra features.
 -
 -	  To compile this driver as a module, choose M here: the module
 -	  will be called huawei-wmi.
 -
 -config INTEL_WMI_SBL_FW_UPDATE
 -	tristate "Intel WMI Slim Bootloader firmware update signaling driver"
 -	depends on ACPI_WMI
 -	help
 -	  Say Y here if you want to be able to use the WMI interface to signal
 -	  Slim Bootloader to trigger update on next reboot.
 -
 -	  To compile this driver as a module, choose M here: the module will
 -	  be called intel-wmi-sbl-fw-update.
 -
 -config INTEL_WMI_THUNDERBOLT
 -	tristate "Intel WMI thunderbolt force power driver"
 +	depends on BACKLIGHT_CLASS_DEVICE
 +	depends on SERIO_I8042
 +	depends on INPUT
 +	depends on RFKILL || RFKILL = n
  	depends on ACPI_WMI
 -	help
 -	  Say Y here if you want to be able to use the WMI interface on select
 -	  systems to force the power control of Intel Thunderbolt controllers.
 -	  This is useful for updating the firmware when devices are not plugged
 -	  into the controller.
 -
 -	  To compile this driver as a module, choose M here: the module will
 -	  be called intel-wmi-thunderbolt.
 +	select INPUT_SPARSEKMAP
 +	# Acer WMI depends on ACPI_VIDEO when ACPI is enabled
 +        select ACPI_VIDEO if ACPI
 +	---help---
 +	  This is a driver for newer Acer (and Wistron) laptops. It adds
 +	  wireless radio and bluetooth control, and on some laptops,
 +	  exposes the mail LED and LCD backlight.
  
 -config MXM_WMI
 -       tristate "WMI support for MXM Laptop Graphics"
 -       depends on ACPI_WMI
 -	help
 -          MXM is a standard for laptop graphics cards, the WMI interface
 -	  is required for switchable nvidia graphics machines
 +	  If you have an ACPI-WMI compatible Acer/ Wistron laptop, say Y or M
 +	  here.
  
 -config PEAQ_WMI
 -	tristate "PEAQ 2-in-1 WMI hotkey driver"
 -	depends on ACPI_WMI
 -	depends on INPUT
 -	help
 -	 Say Y here if you want to support WMI-based hotkeys on PEAQ 2-in-1s.
++<<<<<<< HEAD
 +config ACER_WIRELESS
 +        tristate "Acer Wireless Radio Control Driver"
 +        depends on ACPI
 +        depends on INPUT
 +        ---help---
 +          The Acer Wireless Radio Control handles the airplane mode hotkey
 +          present on new Acer laptops.
  
 -config XIAOMI_WMI
 -	tristate "Xiaomi WMI key driver"
 -	depends on ACPI_WMI
 -	depends on INPUT
 -	help
 -	  Say Y here if you want to support WMI-based keys on Xiaomi notebooks.
 +          Say Y or M here if you have an Acer notebook with an airplane mode
 +          hotkey.
  
 -	  To compile this driver as a module, choose M here: the module will
 -	  be called xiaomi-wmi.
 +          If you choose to compile this driver as a module the module will be
 +          called acer-wireless.
  
  config ACERHDF
  	tristate "Acer Aspire One temperature and fan driver"
@@@ -68,17 -145,67 +69,45 @@@
  	  If you have an Acer Aspire One netbook, say Y or M
  	  here.
  
 -config ACER_WIRELESS
 -        tristate "Acer Wireless Radio Control Driver"
 -        depends on ACPI
 -        depends on INPUT
 -	help
 -          The Acer Wireless Radio Control handles the airplane mode hotkey
 -          present on new Acer laptops.
 -
 -          Say Y or M here if you have an Acer notebook with an airplane mode
 -          hotkey.
 -
 -          If you choose to compile this driver as a module the module will be
 -          called acer-wireless.
 -
 -config ACER_WMI
 -	tristate "Acer WMI Laptop Extras"
 +config ALIENWARE_WMI
 +	tristate "Alienware Special feature control"
  	depends on ACPI
 -	select LEDS_CLASS
 -	select NEW_LEDS
 -	depends on BACKLIGHT_CLASS_DEVICE
 -	depends on SERIO_I8042
 -	depends on INPUT
 -	depends on RFKILL || RFKILL = n
 +	depends on LEDS_CLASS
 +	depends on NEW_LEDS
  	depends on ACPI_WMI
 -	select INPUT_SPARSEKMAP
 -	# Acer WMI depends on ACPI_VIDEO when ACPI is enabled
 -        select ACPI_VIDEO if ACPI
 -	help
 -	  This is a driver for newer Acer (and Wistron) laptops. It adds
 -	  wireless radio and bluetooth control, and on some laptops,
 -	  exposes the mail LED and LCD backlight.
 -
 -	  If you have an ACPI-WMI compatible Acer/ Wistron laptop, say Y or M
 -	  here.
 -
 +	---help---
 +	 This is a driver for controlling Alienware BIOS driven
 +	 features.  It exposes an interface for controlling the AlienFX
 +	 zones on Alienware machines that don't contain a dedicated AlienFX
 +	 USB MCU such as the X51 and X51-R2.
++=======
+ config AMD_PMC
+ 	tristate "AMD SoC PMC driver"
+ 	depends on ACPI && PCI
+ 	help
+ 	  The driver provides support for AMD Power Management Controller
+ 	  primarily responsible for S2Idle transactions that are driven from
+ 	  a platform firmware running on SMU. This driver also provides a debug
+ 	  mechanism to investigate the S2Idle transactions and failures.
+ 
+ 	  Say Y or M here if you have a notebook powered by AMD RYZEN CPU/APU.
+ 
+ 	  If you choose to compile this driver as a module the module will be
+ 	  called amd-pmc.
+ 
+ config APPLE_GMUX
+ 	tristate "Apple Gmux Driver"
+ 	depends on ACPI && PCI
+ 	depends on PNP
+ 	depends on BACKLIGHT_CLASS_DEVICE
+ 	depends on BACKLIGHT_APPLE=n || BACKLIGHT_APPLE
+ 	depends on ACPI_VIDEO=n || ACPI_VIDEO
+ 	help
+ 	  This driver provides support for the gmux device found on many
+ 	  Apple laptops, which controls the display mux for the hybrid
+ 	  graphics as well as the backlight. Currently only backlight
+ 	  control is supported by the driver.
++>>>>>>> 156ec4731cb2 (platform/x86: amd-pmc: Add AMD platform support for S2Idle)
  
  config ASUS_LAPTOP
  	tristate "Asus Laptop Extras"
diff --cc drivers/platform/x86/Makefile
index bc8f22d7c92e,8a47c7627c0a..000000000000
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@@ -3,31 -3,64 +3,60 @@@
  # Makefile for linux/drivers/platform/x86
  # x86 Platform-Specific Drivers
  #
++<<<<<<< HEAD
++=======
+ 
+ # Windows Management Interface
+ obj-$(CONFIG_ACPI_WMI)		+= wmi.o
+ obj-$(CONFIG_WMI_BMOF)		+= wmi-bmof.o
+ 
+ # WMI drivers
+ obj-$(CONFIG_ALIENWARE_WMI)		+= alienware-wmi.o
+ obj-$(CONFIG_HUAWEI_WMI)		+= huawei-wmi.o
+ obj-$(CONFIG_INTEL_WMI_SBL_FW_UPDATE)	+= intel-wmi-sbl-fw-update.o
+ obj-$(CONFIG_INTEL_WMI_THUNDERBOLT)	+= intel-wmi-thunderbolt.o
+ obj-$(CONFIG_MXM_WMI)			+= mxm-wmi.o
+ obj-$(CONFIG_PEAQ_WMI)			+= peaq-wmi.o
+ obj-$(CONFIG_XIAOMI_WMI)		+= xiaomi-wmi.o
+ 
+ # Acer
+ obj-$(CONFIG_ACERHDF)		+= acerhdf.o
+ obj-$(CONFIG_ACER_WIRELESS)	+= acer-wireless.o
+ obj-$(CONFIG_ACER_WMI)		+= acer-wmi.o
+ 
+ # AMD
+ obj-$(CONFIG_AMD_PMC)		+= amd-pmc.o
+ 
+ # Apple
+ obj-$(CONFIG_APPLE_GMUX)	+= apple-gmux.o
+ 
+ # ASUS
++>>>>>>> 156ec4731cb2 (platform/x86: amd-pmc: Add AMD platform support for S2Idle)
  obj-$(CONFIG_ASUS_LAPTOP)	+= asus-laptop.o
 -obj-$(CONFIG_ASUS_WIRELESS)	+= asus-wireless.o
  obj-$(CONFIG_ASUS_WMI)		+= asus-wmi.o
  obj-$(CONFIG_ASUS_NB_WMI)	+= asus-nb-wmi.o
 +obj-$(CONFIG_ASUS_WIRELESS)	+= asus-wireless.o
  obj-$(CONFIG_EEEPC_LAPTOP)	+= eeepc-laptop.o
  obj-$(CONFIG_EEEPC_WMI)		+= eeepc-wmi.o
 -
 -# Dell
 -obj-$(CONFIG_DCDBAS)			+= dcdbas.o
 -obj-$(CONFIG_DELL_SMBIOS)		+= dell-smbios.o
 -dell-smbios-objs			:= dell-smbios-base.o
 +obj-$(CONFIG_MSI_LAPTOP)	+= msi-laptop.o
 +obj-$(CONFIG_ACPI_CMPC)		+= classmate-laptop.o
 +obj-$(CONFIG_COMPAL_LAPTOP)	+= compal-laptop.o
 +obj-$(CONFIG_DCDBAS)		+= dcdbas.o
 +obj-$(CONFIG_DELL_SMBIOS)	+= dell-smbios.o
 +dell-smbios-objs		:= dell-smbios-base.o
  dell-smbios-$(CONFIG_DELL_SMBIOS_WMI)	+= dell-smbios-wmi.o
  dell-smbios-$(CONFIG_DELL_SMBIOS_SMM)	+= dell-smbios-smm.o
 -obj-$(CONFIG_DELL_LAPTOP)		+= dell-laptop.o
 -obj-$(CONFIG_DELL_RBTN)			+= dell-rbtn.o
 -obj-$(CONFIG_DELL_RBU)			+= dell_rbu.o
 -obj-$(CONFIG_DELL_SMO8800)		+= dell-smo8800.o
 -obj-$(CONFIG_DELL_WMI)			+= dell-wmi.o
 +obj-$(CONFIG_DELL_LAPTOP)	+= dell-laptop.o
 +obj-$(CONFIG_DELL_WMI)		+= dell-wmi.o
  obj-$(CONFIG_DELL_WMI_DESCRIPTOR)	+= dell-wmi-descriptor.o
 -obj-$(CONFIG_DELL_WMI_AIO)		+= dell-wmi-aio.o
 -obj-$(CONFIG_DELL_WMI_LED)		+= dell-wmi-led.o
 +obj-$(CONFIG_DELL_WMI_AIO)	+= dell-wmi-aio.o
 +obj-$(CONFIG_DELL_WMI_LED)	+= dell-wmi-led.o
  obj-$(CONFIG_DELL_WMI_SYSMAN)		+= dell-wmi-sysman/
 -
 -# Fujitsu
 -obj-$(CONFIG_AMILO_RFKILL)	+= amilo-rfkill.o
 -obj-$(CONFIG_FUJITSU_LAPTOP)	+= fujitsu-laptop.o
 -obj-$(CONFIG_FUJITSU_TABLET)	+= fujitsu-tablet.o
 -
 -# GPD
 -obj-$(CONFIG_GPD_POCKET_FAN)	+= gpd-pocket-fan.o
 -
 -# Hewlett Packard
 +obj-$(CONFIG_DELL_SMO8800)	+= dell-smo8800.o
 +obj-$(CONFIG_DELL_RBTN)		+= dell-rbtn.o
 +obj-$(CONFIG_ACER_WMI)		+= acer-wmi.o
 +obj-$(CONFIG_ACER_WIRELESS)	+= acer-wireless.o
 +obj-$(CONFIG_ACERHDF)		+= acerhdf.o
  obj-$(CONFIG_HP_ACCEL)		+= hp_accel.o
  obj-$(CONFIG_HP_WIRELESS)	+= hp-wireless.o
  obj-$(CONFIG_HP_WMI)		+= hp-wmi.o
* Unmerged path MAINTAINERS
* Unmerged path drivers/platform/x86/Kconfig
* Unmerged path drivers/platform/x86/Makefile
diff --git a/drivers/platform/x86/amd-pmc.c b/drivers/platform/x86/amd-pmc.c
new file mode 100644
index 000000000000..0102bf1c7916
--- /dev/null
+++ b/drivers/platform/x86/amd-pmc.c
@@ -0,0 +1,286 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * AMD SoC Power Management Controller Driver
+ *
+ * Copyright (c) 2020, Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Author: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/acpi.h>
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/suspend.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+
+/* SMU communication registers */
+#define AMD_PMC_REGISTER_MESSAGE	0x538
+#define AMD_PMC_REGISTER_RESPONSE	0x980
+#define AMD_PMC_REGISTER_ARGUMENT	0x9BC
+
+/* Base address of SMU for mapping physical address to virtual address */
+#define AMD_PMC_SMU_INDEX_ADDRESS	0xB8
+#define AMD_PMC_SMU_INDEX_DATA		0xBC
+#define AMD_PMC_MAPPING_SIZE		0x01000
+#define AMD_PMC_BASE_ADDR_OFFSET	0x10000
+#define AMD_PMC_BASE_ADDR_LO		0x13B102E8
+#define AMD_PMC_BASE_ADDR_HI		0x13B102EC
+#define AMD_PMC_BASE_ADDR_LO_MASK	GENMASK(15, 0)
+#define AMD_PMC_BASE_ADDR_HI_MASK	GENMASK(31, 20)
+
+/* SMU Response Codes */
+#define AMD_PMC_RESULT_OK                    0x01
+#define AMD_PMC_RESULT_CMD_REJECT_BUSY       0xFC
+#define AMD_PMC_RESULT_CMD_REJECT_PREREQ     0xFD
+#define AMD_PMC_RESULT_CMD_UNKNOWN           0xFE
+#define AMD_PMC_RESULT_FAILED                0xFF
+
+/* List of supported CPU ids */
+#define AMD_CPU_ID_RV			0x15D0
+#define AMD_CPU_ID_RN			0x1630
+#define AMD_CPU_ID_PCO			AMD_CPU_ID_RV
+#define AMD_CPU_ID_CZN			AMD_CPU_ID_RN
+
+#define AMD_SMU_FW_VERSION		0x0
+#define PMC_MSG_DELAY_MIN_US		100
+#define RESPONSE_REGISTER_LOOP_MAX	200
+
+enum amd_pmc_def {
+	MSG_TEST = 0x01,
+	MSG_OS_HINT_PCO,
+	MSG_OS_HINT_RN,
+};
+
+struct amd_pmc_dev {
+	void __iomem *regbase;
+	void __iomem *smu_base;
+	u32 base_addr;
+	u32 cpu_id;
+	struct device *dev;
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+	struct dentry *dbgfs_dir;
+#endif /* CONFIG_DEBUG_FS */
+};
+
+static struct amd_pmc_dev pmc;
+
+static inline u32 amd_pmc_reg_read(struct amd_pmc_dev *dev, int reg_offset)
+{
+	return ioread32(dev->regbase + reg_offset);
+}
+
+static inline void amd_pmc_reg_write(struct amd_pmc_dev *dev, int reg_offset, u32 val)
+{
+	iowrite32(val, dev->regbase + reg_offset);
+}
+
+#if CONFIG_DEBUG_FS
+static int smu_fw_info_show(struct seq_file *s, void *unused)
+{
+	struct amd_pmc_dev *dev = s->private;
+	u32 value;
+
+	value = ioread32(dev->smu_base + AMD_SMU_FW_VERSION);
+	seq_printf(s, "SMU FW Info: %x\n", value);
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(smu_fw_info);
+
+static void amd_pmc_dbgfs_unregister(struct amd_pmc_dev *dev)
+{
+	debugfs_remove_recursive(dev->dbgfs_dir);
+}
+
+static void amd_pmc_dbgfs_register(struct amd_pmc_dev *dev)
+{
+	dev->dbgfs_dir = debugfs_create_dir("amd_pmc", NULL);
+	debugfs_create_file("smu_fw_info", 0644, dev->dbgfs_dir, dev,
+			    &smu_fw_info_fops);
+}
+#else
+static inline void amd_pmc_dbgfs_register(struct amd_pmc_dev *dev)
+{
+}
+
+static inline void amd_pmc_dbgfs_unregister(struct amd_pmc_dev *dev)
+{
+}
+#endif /* CONFIG_DEBUG_FS */
+
+static void amd_pmc_dump_registers(struct amd_pmc_dev *dev)
+{
+	u32 value;
+
+	value = amd_pmc_reg_read(dev, AMD_PMC_REGISTER_RESPONSE);
+	dev_dbg(dev->dev, "AMD_PMC_REGISTER_RESPONSE:%x\n", value);
+
+	value = amd_pmc_reg_read(dev, AMD_PMC_REGISTER_ARGUMENT);
+	dev_dbg(dev->dev, "AMD_PMC_REGISTER_ARGUMENT:%x\n", value);
+
+	value = amd_pmc_reg_read(dev, AMD_PMC_REGISTER_MESSAGE);
+	dev_dbg(dev->dev, "AMD_PMC_REGISTER_MESSAGE:%x\n", value);
+}
+
+static int amd_pmc_send_cmd(struct amd_pmc_dev *dev, bool set)
+{
+	int rc;
+	u8 msg;
+	u32 val;
+
+	/* Wait until we get a valid response */
+	rc = readx_poll_timeout(ioread32, dev->regbase + AMD_PMC_REGISTER_RESPONSE,
+				val, val > 0, PMC_MSG_DELAY_MIN_US,
+				PMC_MSG_DELAY_MIN_US * RESPONSE_REGISTER_LOOP_MAX);
+	if (rc) {
+		dev_err(dev->dev, "failed to talk to SMU\n");
+		return rc;
+	}
+
+	/* Write zero to response register */
+	amd_pmc_reg_write(dev, AMD_PMC_REGISTER_RESPONSE, 0);
+
+	/* Write argument into response register */
+	amd_pmc_reg_write(dev, AMD_PMC_REGISTER_ARGUMENT, set);
+
+	/* Write message ID to message ID register */
+	msg = (dev->cpu_id == AMD_CPU_ID_RN) ? MSG_OS_HINT_RN : MSG_OS_HINT_PCO;
+	amd_pmc_reg_write(dev, AMD_PMC_REGISTER_MESSAGE, msg);
+	return 0;
+}
+
+static int __maybe_unused amd_pmc_suspend(struct device *dev)
+{
+	struct amd_pmc_dev *pdev = dev_get_drvdata(dev);
+	int rc;
+
+	rc = amd_pmc_send_cmd(pdev, 1);
+	if (rc)
+		dev_err(pdev->dev, "suspend failed\n");
+
+	amd_pmc_dump_registers(pdev);
+	return 0;
+}
+
+static int __maybe_unused amd_pmc_resume(struct device *dev)
+{
+	struct amd_pmc_dev *pdev = dev_get_drvdata(dev);
+	int rc;
+
+	rc = amd_pmc_send_cmd(pdev, 0);
+	if (rc)
+		dev_err(pdev->dev, "resume failed\n");
+
+	amd_pmc_dump_registers(pdev);
+	return 0;
+}
+
+static const struct dev_pm_ops amd_pmc_pm_ops = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(amd_pmc_suspend, amd_pmc_resume)
+};
+
+static const struct pci_device_id pmc_pci_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_CZN) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_RN) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_PCO) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_RV) },
+	{ }
+};
+
+static int amd_pmc_probe(struct platform_device *pdev)
+{
+	struct amd_pmc_dev *dev = &pmc;
+	struct pci_dev *rdev;
+	u32 base_addr_lo;
+	u32 base_addr_hi;
+	u64 base_addr;
+	int err;
+	u32 val;
+
+	dev->dev = &pdev->dev;
+
+	rdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));
+	if (!rdev || !pci_match_id(pmc_pci_ids, rdev))
+		return -ENODEV;
+
+	dev->cpu_id = rdev->device;
+	err = pci_write_config_dword(rdev, AMD_PMC_SMU_INDEX_ADDRESS, AMD_PMC_BASE_ADDR_LO);
+	if (err) {
+		dev_err(dev->dev, "error writing to 0x%x\n", AMD_PMC_SMU_INDEX_ADDRESS);
+		return pcibios_err_to_errno(err);
+	}
+
+	err = pci_read_config_dword(rdev, AMD_PMC_SMU_INDEX_DATA, &val);
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	base_addr_lo = val & AMD_PMC_BASE_ADDR_HI_MASK;
+
+	err = pci_write_config_dword(rdev, AMD_PMC_SMU_INDEX_ADDRESS, AMD_PMC_BASE_ADDR_HI);
+	if (err) {
+		dev_err(dev->dev, "error writing to 0x%x\n", AMD_PMC_SMU_INDEX_ADDRESS);
+		return pcibios_err_to_errno(err);
+	}
+
+	err = pci_read_config_dword(rdev, AMD_PMC_SMU_INDEX_DATA, &val);
+	if (err)
+		return pcibios_err_to_errno(err);
+
+	base_addr_hi = val & AMD_PMC_BASE_ADDR_LO_MASK;
+	pci_dev_put(rdev);
+	base_addr = ((u64)base_addr_hi << 32 | base_addr_lo);
+
+	dev->smu_base = devm_ioremap(dev->dev, base_addr, AMD_PMC_MAPPING_SIZE);
+	if (!dev->smu_base)
+		return -ENOMEM;
+
+	dev->regbase = devm_ioremap(dev->dev, base_addr + AMD_PMC_BASE_ADDR_OFFSET,
+				    AMD_PMC_MAPPING_SIZE);
+	if (!dev->regbase)
+		return -ENOMEM;
+
+	amd_pmc_dump_registers(dev);
+
+	platform_set_drvdata(pdev, dev);
+	amd_pmc_dbgfs_register(dev);
+	return 0;
+}
+
+static int amd_pmc_remove(struct platform_device *pdev)
+{
+	struct amd_pmc_dev *dev = platform_get_drvdata(pdev);
+
+	amd_pmc_dbgfs_unregister(dev);
+	return 0;
+}
+
+static const struct acpi_device_id amd_pmc_acpi_ids[] = {
+	{"AMDI0005", 0},
+	{"AMD0004", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, amd_pmc_acpi_ids);
+
+static struct platform_driver amd_pmc_driver = {
+	.driver = {
+		.name = "amd_pmc",
+		.acpi_match_table = amd_pmc_acpi_ids,
+		.pm = &amd_pmc_pm_ops,
+	},
+	.probe = amd_pmc_probe,
+	.remove = amd_pmc_remove,
+};
+module_platform_driver(amd_pmc_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("AMD PMC Driver");
