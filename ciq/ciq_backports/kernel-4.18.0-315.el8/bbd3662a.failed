Infrastructure management of the cred security blob

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Casey Schaufler <casey@schaufler-ca.com>
commit bbd3662a834813730912a58efb44dd6df6d952e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/bbd3662a.failed

Move management of the cred security blob out of the
security modules and into the security infrastructre.
Instead of allocating and freeing space the security
modules tell the infrastructure how much space they
require.

	Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
[kees: adjusted for ordered init series]
	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit bbd3662a834813730912a58efb44dd6df6d952e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/lsm_hooks.h
#	security/apparmor/include/cred.h
#	security/apparmor/lsm.c
#	security/selinux/hooks.c
#	security/selinux/include/objsec.h
#	security/smack/smack.h
#	security/smack/smack_lsm.c
#	security/tomoyo/common.h
#	security/tomoyo/tomoyo.c
diff --cc include/linux/lsm_hooks.h
index 84380f3a8dab,dd33666567bc..000000000000
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@@ -1479,10 -2028,11 +1479,18 @@@ struct security_hook_list 
  } __randomize_layout;
  
  /*
++<<<<<<< HEAD
 + * LSM_RET_VOID is used as the default value in LSM_HOOK definitions for void
 + * LSM hooks (in include/linux/lsm_hook_defs.h).
 + */
 +#define LSM_RET_VOID ((void) 0)
++=======
+  * Security blob size or offset data.
+  */
+ struct lsm_blob_sizes {
+ 	int	lbs_cred;
+ };
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  
  /*
   * Initializing a security_hook_list structure takes
diff --cc security/apparmor/include/cred.h
index e287b7d0d4be,b9504a05fddc..000000000000
--- a/security/apparmor/include/cred.h
+++ b/security/apparmor/include/cred.h
@@@ -23,8 -23,22 +23,27 @@@
  #include "policy_ns.h"
  #include "task.h"
  
++<<<<<<< HEAD
 +#define cred_label(X) ((X)->security)
 +
++=======
+ static inline struct aa_label *cred_label(const struct cred *cred)
+ {
+ 	struct aa_label **blob = cred->security + apparmor_blob_sizes.lbs_cred;
+ 
+ 	AA_BUG(!blob);
+ 	return *blob;
+ }
+ 
+ static inline void set_cred_label(const struct cred *cred,
+ 				  struct aa_label *label)
+ {
+ 	struct aa_label **blob = cred->security + apparmor_blob_sizes.lbs_cred;
+ 
+ 	AA_BUG(!blob);
+ 	*blob = label;
+ }
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  
  /**
   * aa_cred_raw_label - obtain cred's label
diff --cc security/apparmor/lsm.c
index 85c05989635b,d5e4a384f205..000000000000
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@@ -1126,6 -1137,27 +1126,30 @@@ static void apparmor_sock_graft(struct 
  		ctx->label = aa_get_current_label();
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NETWORK_SECMARK
+ static int apparmor_inet_conn_request(struct sock *sk, struct sk_buff *skb,
+ 				      struct request_sock *req)
+ {
+ 	struct aa_sk_ctx *ctx = SK_CTX(sk);
+ 
+ 	if (!skb->secmark)
+ 		return 0;
+ 
+ 	return apparmor_secmark_check(ctx->label, OP_CONNECT, AA_MAY_CONNECT,
+ 				      skb->secmark, sk);
+ }
+ #endif
+ 
+ /*
+  * The cred blob is a pointer to, not an instance of, an aa_task_ctx.
+  */
+ struct lsm_blob_sizes apparmor_blob_sizes __lsm_ro_after_init = {
+ 	.lbs_cred = sizeof(struct aa_task_ctx *),
+ };
+ 
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  static struct security_hook_list apparmor_hooks[] __lsm_ro_after_init = {
  	LSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),
  	LSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),
@@@ -1455,7 -1492,8 +1479,12 @@@ static int __init set_init_ctx(void
  	if (!ctx)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	cred_label(cred) = aa_get_label(ns_unconfined(root_ns));
++=======
+ 	lsm_early_cred(cred);
+ 	set_cred_label(cred, aa_get_label(ns_unconfined(root_ns)));
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  	task_ctx(current) = ctx;
  
  	return 0;
diff --cc security/selinux/hooks.c
index 02238a76d816,239b13b442e7..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -7000,82 -6644,9 +6966,88 @@@ static void selinux_bpf_prog_free(struc
  }
  #endif
  
++<<<<<<< HEAD
 +/*
 + * IMPORTANT NOTE: When adding new hooks, please be careful to keep this order:
 + * 1. any hooks that don't belong to (2.) or (3.) below,
 + * 2. hooks that both access structures allocated by other hooks, and allocate
 + *    structures that can be later accessed by other hooks (mostly "cloning"
 + *    hooks),
 + * 3. hooks that only allocate structures that can be later accessed by other
 + *    hooks ("allocating" hooks).
 + *
 + * Please follow block comment delimiters in the list to keep this order.
 + *
 + * This ordering is needed for SELinux runtime disable to work at least somewhat
 + * safely. Breaking the ordering rules above might lead to NULL pointer derefs
 + * when disabling SELinux at runtime.
 + */
 +
 +#ifdef CONFIG_PERF_EVENTS
 +static int selinux_perf_event_open(struct perf_event_attr *attr, int type)
 +{
 +	u32 requested, sid = current_sid();
 +
 +	if (type == PERF_SECURITY_OPEN)
 +		requested = PERF_EVENT__OPEN;
 +	else if (type == PERF_SECURITY_CPU)
 +		requested = PERF_EVENT__CPU;
 +	else if (type == PERF_SECURITY_KERNEL)
 +		requested = PERF_EVENT__KERNEL;
 +	else if (type == PERF_SECURITY_TRACEPOINT)
 +		requested = PERF_EVENT__TRACEPOINT;
 +	else
 +		return -EINVAL;
 +
 +	return avc_has_perm(&selinux_state, sid, sid, SECCLASS_PERF_EVENT,
 +			    requested, NULL);
 +}
 +
 +static int selinux_perf_event_alloc(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec;
 +
 +	perfsec = kzalloc(sizeof(*perfsec), GFP_KERNEL);
 +	if (!perfsec)
 +		return -ENOMEM;
 +
 +	perfsec->sid = current_sid();
 +	event->security = perfsec;
 +
 +	return 0;
 +}
 +
 +static void selinux_perf_event_free(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +
 +	event->security = NULL;
 +	kfree(perfsec);
 +}
 +
 +static int selinux_perf_event_read(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +	u32 sid = current_sid();
 +
 +	return avc_has_perm(&selinux_state, sid, perfsec->sid,
 +			    SECCLASS_PERF_EVENT, PERF_EVENT__READ, NULL);
 +}
 +
 +static int selinux_perf_event_write(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +	u32 sid = current_sid();
 +
 +	return avc_has_perm(&selinux_state, sid, perfsec->sid,
 +			    SECCLASS_PERF_EVENT, PERF_EVENT__WRITE, NULL);
 +}
 +#endif
++=======
+ struct lsm_blob_sizes selinux_blob_sizes __lsm_ro_after_init = {
+ 	.lbs_cred = sizeof(struct task_security_struct),
+ };
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  
  static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {
  	LSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),
@@@ -7415,7 -6948,8 +7385,12 @@@ void selinux_complete_init(void
  DEFINE_LSM(selinux) = {
  	.name = "selinux",
  	.flags = LSM_FLAG_LEGACY_MAJOR | LSM_FLAG_EXCLUSIVE,
++<<<<<<< HEAD
 +	.enabled = &selinux_enabled_boot,
++=======
+ 	.enabled = &selinux_enabled,
+ 	.blobs = &selinux_blob_sizes,
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  	.init = selinux_init,
  };
  
diff --cc security/selinux/include/objsec.h
index e4f7d53cbff2,c2974b031d05..000000000000
--- a/security/selinux/include/objsec.h
+++ b/security/selinux/include/objsec.h
@@@ -25,7 -25,7 +25,11 @@@
  #include <linux/binfmts.h>
  #include <linux/in.h>
  #include <linux/spinlock.h>
++<<<<<<< HEAD
 +#include <linux/msg.h>
++=======
+ #include <linux/lsm_hooks.h>
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  #include <net/net_namespace.h>
  #include "flask.h"
  #include "avc.h"
@@@ -146,49 -156,13 +150,50 @@@ struct pkey_security_struct 
  };
  
  struct bpf_security_struct {
 -	u32 sid;  /*SID of bpf obj creater*/
 +	u32 sid;  /* SID of bpf obj creator */
 +};
 +
 +struct perf_event_security_struct {
 +	u32 sid;  /* SID of perf_event obj creator */
  };
  
+ extern struct lsm_blob_sizes selinux_blob_sizes;
  static inline struct task_security_struct *selinux_cred(const struct cred *cred)
  {
- 	return cred->security;
+ 	return cred->security + selinux_blob_sizes.lbs_cred;
  }
  
 +static inline struct file_security_struct *selinux_file(const struct file *file)
 +{
 +	return file->f_security;
 +}
 +
 +static inline struct inode_security_struct *selinux_inode(
 +						const struct inode *inode)
 +{
 +	return inode->i_security;
 +}
 +
 +static inline struct msg_security_struct *selinux_msg_msg(
 +						const struct msg_msg *msg_msg)
 +{
 +	return msg_msg->security;
 +}
 +
 +static inline struct ipc_security_struct *selinux_ipc(
 +						const struct kern_ipc_perm *ipc)
 +{
 +	return ipc->security;
 +}
 +
 +/*
 + * get the subjective security ID of the current task
 + */
 +static inline u32 current_sid(void)
 +{
 +	const struct task_security_struct *tsec = selinux_cred(current_cred());
 +
 +	return tsec->sid;
 +}
 +
  #endif /* _SELINUX_OBJSEC_H_ */
diff --cc security/smack/smack.h
index f7db791fb566,b27eb252e953..000000000000
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@@ -356,6 -357,11 +357,14 @@@ extern struct list_head smack_onlycap_l
  #define SMACK_HASH_SLOTS 16
  extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
  
++<<<<<<< HEAD
++=======
+ static inline struct task_smack *smack_cred(const struct cred *cred)
+ {
+ 	return cred->security + smack_blob_sizes.lbs_cred;
+ }
+ 
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  /*
   * Is the directory transmuting?
   */
diff --cc security/smack/smack_lsm.c
index 922e3ab09003,bad27a8e1631..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -2006,15 -1909,11 +1985,16 @@@ static void smack_cred_free(struct cre
  static int smack_cred_prepare(struct cred *new, const struct cred *old,
  			      gfp_t gfp)
  {
++<<<<<<< HEAD
 +	struct task_smack *old_tsp = old->security;
 +	struct task_smack *new_tsp;
++=======
+ 	struct task_smack *old_tsp = smack_cred(old);
+ 	struct task_smack *new_tsp = smack_cred(new);
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  	int rc;
  
- 	new_tsp = new_task_smack(old_tsp->smk_task, old_tsp->smk_task, gfp);
- 	if (new_tsp == NULL)
- 		return -ENOMEM;
- 
- 	new->security = new_tsp;
+ 	init_task_smack(new_tsp, old_tsp->smk_task, old_tsp->smk_task);
  
  	rc = smk_copy_rules(&new_tsp->smk_rules, &old_tsp->smk_rules, gfp);
  	if (rc != 0)
diff --cc security/tomoyo/common.h
index 539bcdd30bb8,4fc17294a12d..000000000000
--- a/security/tomoyo/common.h
+++ b/security/tomoyo/common.h
@@@ -1197,6 -1200,17 +1198,20 @@@ static inline void tomoyo_put_group(str
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * tomoyo_cred - Get a pointer to the tomoyo cred security blob
+  * @cred - the relevant cred
+  *
+  * Returns pointer to the tomoyo cred blob.
+  */
+ static inline struct tomoyo_domain_info **tomoyo_cred(const struct cred *cred)
+ {
+ 	return cred->security + tomoyo_blob_sizes.lbs_cred;
+ }
+ 
+ /**
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
   * tomoyo_domain - Get "struct tomoyo_domain_info" for current thread.
   *
   * Returns pointer to "struct tomoyo_domain_info" for current thread.
diff --cc security/tomoyo/tomoyo.c
index daff7d7897ad,9094cf41a247..000000000000
--- a/security/tomoyo/tomoyo.c
+++ b/security/tomoyo/tomoyo.c
@@@ -543,13 -566,18 +547,20 @@@ static int __init tomoyo_init(void
  	/* register ourselves with the security framework */
  	security_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks), "tomoyo");
  	printk(KERN_INFO "TOMOYO Linux initialized\n");
++<<<<<<< HEAD
 +	cred->security = &tomoyo_kernel_domain;
++=======
+ 	lsm_early_cred(cred);
+ 	blob = tomoyo_cred(cred);
+ 	*blob = &tomoyo_kernel_domain;
++>>>>>>> bbd3662a8348 (Infrastructure management of the cred security blob)
  	tomoyo_mm_init();
 -
  	return 0;
  }
  
  DEFINE_LSM(tomoyo) = {
  	.name = "tomoyo",
 -	.enabled = &tomoyo_enabled,
  	.flags = LSM_FLAG_LEGACY_MAJOR | LSM_FLAG_EXCLUSIVE,
+ 	.blobs = &tomoyo_blob_sizes,
  	.init = tomoyo_init,
  };
* Unmerged path include/linux/lsm_hooks.h
* Unmerged path security/apparmor/include/cred.h
diff --git a/security/apparmor/include/lib.h b/security/apparmor/include/lib.h
index 6505e1ad9e23..bbe9b384d71d 100644
--- a/security/apparmor/include/lib.h
+++ b/security/apparmor/include/lib.h
@@ -16,6 +16,7 @@
 
 #include <linux/slab.h>
 #include <linux/fs.h>
+#include <linux/lsm_hooks.h>
 
 #include "match.h"
 
@@ -55,6 +56,9 @@ const char *aa_splitn_fqname(const char *fqname, size_t n, const char **ns_name,
 			     size_t *ns_len);
 void aa_info_message(const char *str);
 
+/* Security blob offsets */
+extern struct lsm_blob_sizes apparmor_blob_sizes;
+
 /**
  * aa_strneq - compare null terminated @str to a non null terminated substring
  * @str: a null terminated string
* Unmerged path security/apparmor/lsm.c
diff --git a/security/security.c b/security/security.c
index 8555aece1bce..daa3a588613e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -44,6 +44,8 @@ struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);
 
 char *lsm_names;
+static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;
+
 /* Boot-time LSM user choice */
 static __initdata const char *chosen_lsm_order;
 static __initdata const char *chosen_major_lsm;
@@ -142,6 +144,25 @@ static bool __init lsm_allowed(struct lsm_info *lsm)
 	return true;
 }
 
+static void __init lsm_set_blob_size(int *need, int *lbs)
+{
+	int offset;
+
+	if (*need > 0) {
+		offset = *lbs;
+		*lbs += *need;
+		*need = offset;
+	}
+}
+
+static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
+{
+	if (!needed)
+		return;
+
+	lsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);
+}
+
 /* Prepare LSM for initialization. */
 static void __init prepare_lsm(struct lsm_info *lsm)
 {
@@ -156,6 +177,8 @@ static void __init prepare_lsm(struct lsm_info *lsm)
 			exclusive = lsm;
 			init_debug("exclusive chosen: %s\n", lsm->name);
 		}
+
+		lsm_set_blob_sizes(lsm->blobs);
 	}
 }
 
@@ -262,6 +285,8 @@ static void __init ordered_lsm_init(void)
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		prepare_lsm(*lsm);
 
+	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
+
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		initialize_lsm(*lsm);
 
@@ -411,6 +436,47 @@ EXPORT_SYMBOL(unregister_blocking_lsm_notifier);
 #include <linux/lsm_hook_defs.h>
 #undef LSM_HOOK
 
+/**
+ * lsm_cred_alloc - allocate a composite cred blob
+ * @cred: the cred that needs a blob
+ * @gfp: allocation type
+ *
+ * Allocate the cred blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)
+{
+	if (blob_sizes.lbs_cred == 0) {
+		cred->security = NULL;
+		return 0;
+	}
+
+	cred->security = kzalloc(blob_sizes.lbs_cred, gfp);
+	if (cred->security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+/**
+ * lsm_early_cred - during initialization allocate a composite cred blob
+ * @cred: the cred that needs a blob
+ *
+ * Allocate the cred blob for all the modules if it's not already there
+ */
+void __init lsm_early_cred(struct cred *cred)
+{
+	int rc;
+
+	if (cred == NULL)
+		panic("%s: NULL cred.\n", __func__);
+	if (cred->security != NULL)
+		return;
+	rc = lsm_cred_alloc(cred, GFP_KERNEL);
+	if (rc)
+		panic("%s: Early cred alloc failed.\n", __func__);
+}
+
 /*
  * Hook list operation macros.
  *
@@ -1257,7 +1323,15 @@ void security_task_free(struct task_struct *task)
 
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
-	return call_int_hook(cred_alloc_blank, 0, cred, gfp);
+	int rc = lsm_cred_alloc(cred, gfp);
+
+	if (rc)
+		return rc;
+
+	rc = call_int_hook(cred_alloc_blank, 0, cred, gfp);
+	if (rc)
+		security_cred_free(cred);
+	return rc;
 }
 
 void security_cred_free(struct cred *cred)
@@ -1270,11 +1344,22 @@ void security_cred_free(struct cred *cred)
 		return;
 
 	call_void_hook(cred_free, cred);
+
+	kfree(cred->security);
+	cred->security = NULL;
 }
 
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
 {
-	return call_int_hook(cred_prepare, 0, new, old, gfp);
+	int rc = lsm_cred_alloc(new, gfp);
+
+	if (rc)
+		return rc;
+
+	rc = call_int_hook(cred_prepare, 0, new, old, gfp);
+	if (rc)
+		security_cred_free(new);
+	return rc;
 }
 
 void security_transfer_creds(struct cred *new, const struct cred *old)
* Unmerged path security/selinux/hooks.c
* Unmerged path security/selinux/include/objsec.h
* Unmerged path security/smack/smack.h
* Unmerged path security/smack/smack_lsm.c
* Unmerged path security/tomoyo/common.h
* Unmerged path security/tomoyo/tomoyo.c
