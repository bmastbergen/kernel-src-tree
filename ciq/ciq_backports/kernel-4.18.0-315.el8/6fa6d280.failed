lib/strncpy_from_user.c: Mask out bytes after NUL terminator.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Daniel Xu <dxu@dxuuu.xyz>
commit 6fa6d28051e9fcaa1570e69648ea13a353a5d218
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/6fa6d280.failed

do_strncpy_from_user() may copy some extra bytes after the NUL
terminator into the destination buffer. This usually does not matter for
normal string operations. However, when BPF programs key BPF maps with
strings, this matters a lot.

A BPF program may read strings from user memory by calling the
bpf_probe_read_user_str() helper which eventually calls
do_strncpy_from_user(). The program can then key a map with the
destination buffer. BPF map keys are fixed-width and string-agnostic,
meaning that map keys are treated as a set of bytes.

The issue is when do_strncpy_from_user() overcopies bytes after the NUL
terminator, it can result in seemingly identical strings occupying
multiple slots in a BPF map. This behavior is subtle and totally
unexpected by the user.

This commit masks out the bytes following the NUL while preserving
long-sized stride in the fast path.

Fixes: 6ae08ae3dea2 ("bpf: Add probe_read_{user, kernel} and probe_read_{user, kernel}_str helpers")
	Signed-off-by: Daniel Xu <dxu@dxuuu.xyz>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/21efc982b3e9f2f7b0379eed642294caaa0c27a7.1605642949.git.dxu@dxuuu.xyz
(cherry picked from commit 6fa6d28051e9fcaa1570e69648ea13a353a5d218)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/bpf_trace.c
diff --cc kernel/trace/bpf_trace.c
index fa9081cef38b,048c655315f1..000000000000
--- a/kernel/trace/bpf_trace.c
+++ b/kernel/trace/bpf_trace.c
@@@ -176,10 -181,19 +176,24 @@@ bpf_probe_read_user_str_common(void *ds
  {
  	int ret;
  
++<<<<<<< HEAD
 +	ret = strncpy_from_unsafe_user(dst, unsafe_ptr, size);
++=======
+ 	/*
+ 	 * NB: We rely on strncpy_from_user() not copying junk past the NUL
+ 	 * terminator into `dst`.
+ 	 *
+ 	 * strncpy_from_user() does long-sized strides in the fast path. If the
+ 	 * strncpy does not mask out the bytes after the NUL in `unsafe_ptr`,
+ 	 * then there could be junk after the NUL in `dst`. If user takes `dst`
+ 	 * and keys a hash map with it, then semantically identical strings can
+ 	 * occupy multiple entries in the map.
+ 	 */
+ 	ret = strncpy_from_user_nofault(dst, unsafe_ptr, size);
++>>>>>>> 6fa6d28051e9 (lib/strncpy_from_user.c: Mask out bytes after NUL terminator.)
  	if (unlikely(ret < 0))
  		memset(dst, 0, size);
 +
  	return ret;
  }
  
* Unmerged path kernel/trace/bpf_trace.c
diff --git a/lib/strncpy_from_user.c b/lib/strncpy_from_user.c
index af3ba828de94..6f0478c26372 100644
--- a/lib/strncpy_from_user.c
+++ b/lib/strncpy_from_user.c
@@ -32,17 +32,32 @@ static inline long do_strncpy_from_user(char *dst, const char __user *src, long
 		goto byte_at_a_time;
 
 	while (max >= sizeof(unsigned long)) {
-		unsigned long c, data;
+		unsigned long c, data, mask;
 
 		/* Fall back to byte-at-a-time if we get a page fault */
 		unsafe_get_user(c, (unsigned long __user *)(src+res), byte_at_a_time);
 
-		*(unsigned long *)(dst+res) = c;
+		/*
+		 * Note that we mask out the bytes following the NUL. This is
+		 * important to do because string oblivious code may read past
+		 * the NUL. For those routines, we don't want to give them
+		 * potentially random bytes after the NUL in `src`.
+		 *
+		 * One example of such code is BPF map keys. BPF treats map keys
+		 * as an opaque set of bytes. Without the post-NUL mask, any BPF
+		 * maps keyed by strings returned from strncpy_from_user() may
+		 * have multiple entries for semantically identical strings.
+		 */
 		if (has_zero(c, &data, &constants)) {
 			data = prep_zero_mask(c, data, &constants);
 			data = create_zero_mask(data);
+			mask = zero_bytemask(data);
+			*(unsigned long *)(dst+res) = c & mask;
 			return res + find_zero(data);
 		}
+
+		*(unsigned long *)(dst+res) = c;
+
 		res += sizeof(unsigned long);
 		max -= sizeof(unsigned long);
 	}
