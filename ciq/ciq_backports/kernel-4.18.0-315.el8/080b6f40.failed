bpf: Don't rely on GCC __attribute__((optimize)) to disable GCSE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 080b6f40763565f65ebb9540219c71ce885cf568
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/080b6f40.failed

Commit 3193c0836 ("bpf: Disable GCC -fgcse optimization for
___bpf_prog_run()") introduced a __no_fgcse macro that expands to a
function scope __attribute__((optimize("-fno-gcse"))), to disable a
GCC specific optimization that was causing trouble on x86 builds, and
was not expected to have any positive effect in the first place.

However, as the GCC manual documents, __attribute__((optimize))
is not for production use, and results in all other optimization
options to be forgotten for the function in question. This can
cause all kinds of trouble, but in one particular reported case,
it causes -fno-asynchronous-unwind-tables to be disregarded,
resulting in .eh_frame info to be emitted for the function.

This reverts commit 3193c0836, and instead, it disables the -fgcse
optimization for the entire source file, but only when building for
X86 using GCC with CONFIG_BPF_JIT_ALWAYS_ON disabled. Note that the
original commit states that CONFIG_RETPOLINE=n triggers the issue,
whereas CONFIG_RETPOLINE=y performs better without the optimization,
so it is kept disabled in both cases.

Fixes: 3193c0836f20 ("bpf: Disable GCC -fgcse optimization for ___bpf_prog_run()")
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
	Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
Link: https://lore.kernel.org/lkml/CAMuHMdUg0WJHEcq6to0-eODpXPOywLot6UD2=GFHpzoj_hCoBQ@mail.gmail.com/
Link: https://lore.kernel.org/bpf/20201028171506.15682-2-ardb@kernel.org
(cherry picked from commit 080b6f40763565f65ebb9540219c71ce885cf568)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compiler-gcc.h
#	include/linux/compiler_types.h
diff --cc include/linux/compiler-gcc.h
index 7c46bb151ee3,5deb37024574..000000000000
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@@ -391,21 -175,3 +391,24 @@@
  #else
  #define __diag_GCC_8(s)
  #endif
++<<<<<<< HEAD
 +
 +#define __no_fgcse __attribute__((optimize("-fno-gcse")))
 +
 +/*
 + * Add the pseudo keyword 'fallthrough' so case statement blocks
 + * must end with any of these keywords:
 + *   break;
 + *   fallthrough;
 + *   goto <label>;
 + *   return [expression];
 + *
 + *  gcc: https://gcc.gnu.org/onlinedocs/gcc/Statement-Attributes.html#Statement-Attributes
 + */
 +#if __has_attribute(__fallthrough__)
 +# define fallthrough			__attribute__((__fallthrough__))
 +#else
 +# define fallthrough			do {} while (0)  /* fallthrough */
 +#endif
++=======
++>>>>>>> 080b6f407635 (bpf: Don't rely on GCC __attribute__((optimize)) to disable GCSE)
diff --cc include/linux/compiler_types.h
index 94ff52aee1d6,ac3fa37a84f9..000000000000
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@@ -239,50 -237,88 +239,53 @@@ struct ftrace_likely_data 
  # define __noscs
  #endif
  
 -#ifndef asm_volatile_goto
 -#define asm_volatile_goto(x...) asm goto(x)
 +/*
 + * Tell gcc if a function is cold. The compiler will assume any path
 + * directly leading to the call is unlikely.
 + */
 +
 +#ifndef __cold
 +#define __cold
  #endif
  
 -#ifdef CONFIG_CC_HAS_ASM_INLINE
 -#define asm_inline asm __inline
 -#else
 -#define asm_inline asm
 +/* Simple shorthand for a section definition */
 +#ifndef __section
 +# define __section(S) __attribute__ ((__section__(#S)))
  #endif
  
 -/* Are two types/vars the same type (ignoring qualifiers)? */
 -#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
++<<<<<<< HEAD
 +#ifndef __visible
 +#define __visible
 +#endif
 +
 +#ifndef __nostackprotector
 +# define __nostackprotector
 +#endif
  
  /*
 - * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving
 - *			       non-scalar types unchanged.
 - */
 -/*
 - * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'
 - * is not type-compatible with 'signed char', and we define a separate case.
 + * Assume alignment of return value.
   */
 -#define __scalar_type_to_expr_cases(type)				\
 -		unsigned type:	(unsigned type)0,			\
 -		signed type:	(signed type)0
 -
 -#define __unqual_scalar_typeof(x) typeof(				\
 -		_Generic((x),						\
 -			 char:	(char)0,				\
 -			 __scalar_type_to_expr_cases(char),		\
 -			 __scalar_type_to_expr_cases(short),		\
 -			 __scalar_type_to_expr_cases(int),		\
 -			 __scalar_type_to_expr_cases(long),		\
 -			 __scalar_type_to_expr_cases(long long),	\
 -			 default: (x)))
 +#ifndef __assume_aligned
 +#define __assume_aligned(a, ...)
 +#endif
  
 -/* Is this type a native word size -- useful for atomic operations */
 -#define __native_word(t) \
 -	(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \
 -	 sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))
  
 -/* Compile time object size, -1 for unknown */
 -#ifndef __compiletime_object_size
 -# define __compiletime_object_size(obj) -1
 -#endif
 -#ifndef __compiletime_warning
 -# define __compiletime_warning(message)
 -#endif
 -#ifndef __compiletime_error
 -# define __compiletime_error(message)
 +#ifndef __no_fgcse
 +# define __no_fgcse
  #endif
  
 -#ifdef __OPTIMIZE__
 -# define __compiletime_assert(condition, msg, prefix, suffix)		\
 -	do {								\
 -		extern void prefix ## suffix(void) __compiletime_error(msg); \
 -		if (!(condition))					\
 -			prefix ## suffix();				\
 -	} while (0)
 -#else
 -# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)
++=======
++>>>>>>> 080b6f407635 (bpf: Don't rely on GCC __attribute__((optimize)) to disable GCSE)
 +/* Are two types/vars the same type (ignoring qualifiers)? */
 +#ifndef __same_type
 +# define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
  #endif
  
 -#define _compiletime_assert(condition, msg, prefix, suffix) \
 -	__compiletime_assert(condition, msg, prefix, suffix)
 -
 -/**
 - * compiletime_assert - break build and emit msg if condition is false
 - * @condition: a compile-time constant condition to check
 - * @msg:       a message to emit if condition is false
 - *
 - * In tradition of POSIX assert, this macro will break the build if the
 - * supplied condition is *false*, emitting the supplied error message if the
 - * compiler has support to do so.
 - */
 -#define compiletime_assert(condition, msg) \
 -	_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)
 -
 -#define compiletime_assert_atomic_type(t)				\
 -	compiletime_assert(__native_word(t),				\
 -		"Need native word sized stores/loads for atomicity.")
 +/* Is this type a native word size -- useful for atomic operations */
 +#ifndef __native_word
 +# define __native_word(t) (sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))
 +#endif
  
 -/* Helpers for emitting diagnostics in pragmas. */
  #ifndef __diag
  #define __diag(string)
  #endif
* Unmerged path include/linux/compiler-gcc.h
* Unmerged path include/linux/compiler_types.h
diff --git a/kernel/bpf/Makefile b/kernel/bpf/Makefile
index e6eb9c0402da..0cc0de72163d 100644
--- a/kernel/bpf/Makefile
+++ b/kernel/bpf/Makefile
@@ -1,6 +1,10 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-y := core.o
-CFLAGS_core.o += $(call cc-disable-warning, override-init)
+ifneq ($(CONFIG_BPF_JIT_ALWAYS_ON),y)
+# ___bpf_prog_run() needs GCSE disabled on x86; see 3193c0836f203 for details
+cflags-nogcse-$(CONFIG_X86)$(CONFIG_CC_IS_GCC) := -fno-gcse
+endif
+CFLAGS_core.o += $(call cc-disable-warning, override-init) $(cflags-nogcse-yy)
 
 obj-$(CONFIG_BPF_SYSCALL) += syscall.o verifier.o inode.o helpers.o tnum.o bpf_iter.o map_iter.o task_iter.o prog_iter.o
 obj-$(CONFIG_BPF_SYSCALL) += hashtab.o arraymap.o percpu_freelist.o bpf_lru_list.o lpm_trie.o map_in_map.o
diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c
index 02ebe648dabe..012041c61c9c 100644
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -1372,7 +1372,7 @@ u64 __weak bpf_probe_read_kernel(void *dst, u32 size, const void *unsafe_ptr)
  *
  * Decode and execute eBPF instructions.
  */
-static u64 __no_fgcse ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn, u64 *stack)
+static u64 ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn, u64 *stack)
 {
 #define BPF_INSN_2_LBL(x, y)    [BPF_##x | BPF_##y] = &&x##_##y
 #define BPF_INSN_3_LBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = &&x##_##y##_##z
