mt76: mt7915: calculate new packet length when tx_time is set in testmode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Shayne Chen <shayne.chen@mediatek.com>
commit c46df37f72ea0fddd51e5da2576a1f8ee37df776
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/c46df37f.failed

If tx_time is set, calculate a new packet length based on tx time and
tx rate.

	Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit c46df37f72ea0fddd51e5da2576a1f8ee37df776)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
index fe56ab18e974,89e550fb599e..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
@@@ -130,15 -132,211 +130,213 @@@ mt7915_tm_set_trx(struct mt7915_dev *de
  				 sizeof(req), false);
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mt7915_tm_set_slot_time(struct mt7915_phy *phy, u8 slot_time, u8 sifs)
+ {
+ 	struct mt7915_dev *dev = phy->dev;
+ 	struct mt7915_tm_cmd req = {
+ 		.testmode_en = !(phy->mt76->test.state == MT76_TM_STATE_OFF),
+ 		.param_idx = MCU_ATE_SET_SLOT_TIME,
+ 		.param.slot.slot_time = slot_time,
+ 		.param.slot.sifs = sifs,
+ 		.param.slot.rifs = 2,
+ 		.param.slot.eifs = cpu_to_le16(60),
+ 		.param.slot.band = phy != &dev->phy,
+ 	};
+ 
+ 	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_ATE_CTRL, &req,
+ 				 sizeof(req), false);
+ }
+ 
+ static int
+ mt7915_tm_set_wmm_qid(struct mt7915_dev *dev, u8 qid, u8 aifs, u8 cw_min,
+ 		      u16 cw_max, u16 txop)
+ {
+ 	struct mt7915_mcu_tx req = { .total = 1 };
+ 	struct edca *e = &req.edca[0];
+ 
+ 	e->queue = qid;
+ 	e->set = WMM_PARAM_SET;
+ 
+ 	e->aifs = aifs;
+ 	e->cw_min = cw_min;
+ 	e->cw_max = cpu_to_le16(cw_max);
+ 	e->txop = cpu_to_le16(txop);
+ 
+ 	return mt7915_mcu_update_edca(dev, &req);
+ }
+ 
+ static int
+ mt7915_tm_set_ipg_params(struct mt7915_phy *phy, u32 ipg, u8 mode)
+ {
+ #define TM_DEFAULT_SIFS	10
+ #define TM_MAX_SIFS	127
+ #define TM_MAX_AIFSN	0xf
+ #define TM_MIN_AIFSN	0x1
+ #define BBP_PROC_TIME	1500
+ 	struct mt7915_dev *dev = phy->dev;
+ 	u8 sig_ext = (mode == MT76_TM_TX_MODE_CCK) ? 0 : 6;
+ 	u8 slot_time = 9, sifs = TM_DEFAULT_SIFS;
+ 	u8 aifsn = TM_MIN_AIFSN;
+ 	u32 i2t_time, tr2t_time, txv_time;
+ 	bool ext_phy = phy != &dev->phy;
+ 	u16 cw = 0;
+ 
+ 	if (ipg < sig_ext + slot_time + sifs)
+ 		ipg = 0;
+ 
+ 	if (!ipg)
+ 		goto done;
+ 
+ 	ipg -= sig_ext;
+ 
+ 	if (ipg <= (TM_MAX_SIFS + slot_time)) {
+ 		sifs = ipg - slot_time;
+ 	} else {
+ 		u32 val = (ipg + slot_time) / slot_time;
+ 
+ 		while (val >>= 1)
+ 			cw++;
+ 
+ 		if (cw > 16)
+ 			cw = 16;
+ 
+ 		ipg -= ((1 << cw) - 1) * slot_time;
+ 
+ 		aifsn = ipg / slot_time;
+ 		if (aifsn > TM_MAX_AIFSN)
+ 			aifsn = TM_MAX_AIFSN;
+ 
+ 		ipg -= aifsn * slot_time;
+ 
+ 		if (ipg > TM_DEFAULT_SIFS) {
+ 			if (ipg < TM_MAX_SIFS)
+ 				sifs = ipg;
+ 			else
+ 				sifs = TM_MAX_SIFS;
+ 		}
+ 	}
+ done:
+ 	txv_time = mt76_get_field(dev, MT_TMAC_ATCR(ext_phy),
+ 				  MT_TMAC_ATCR_TXV_TOUT);
+ 	txv_time *= 50;	/* normal clock time */
+ 
+ 	i2t_time = (slot_time * 1000 - txv_time - BBP_PROC_TIME) / 50;
+ 	tr2t_time = (sifs * 1000 - txv_time - BBP_PROC_TIME) / 50;
+ 
+ 	mt76_set(dev, MT_TMAC_TRCR0(ext_phy),
+ 		 FIELD_PREP(MT_TMAC_TRCR0_TR2T_CHK, tr2t_time) |
+ 		 FIELD_PREP(MT_TMAC_TRCR0_I2T_CHK, i2t_time));
+ 
+ 	mt7915_tm_set_slot_time(phy, slot_time, sifs);
+ 
+ 	return mt7915_tm_set_wmm_qid(dev,
+ 				     mt7915_lmac_mapping(dev, IEEE80211_AC_BE),
+ 				     aifsn, cw, cw, 0);
+ }
+ 
+ static int
+ mt7915_tm_set_tx_len(struct mt7915_phy *phy, u32 tx_time)
+ {
+ 	struct mt76_phy *mphy = phy->mt76;
+ 	struct mt76_testmode_data *td = &mphy->test;
+ 	struct sk_buff *old = td->tx_skb, *new;
+ 	struct ieee80211_supported_band *sband;
+ 	struct rate_info rate = {};
+ 	u16 flags = 0, tx_len;
+ 	u32 bitrate;
+ 
+ 	if (!tx_time || !old)
+ 		return 0;
+ 
+ 	rate.mcs = td->tx_rate_idx;
+ 	rate.nss = td->tx_rate_nss;
+ 
+ 	switch (td->tx_rate_mode) {
+ 	case MT76_TM_TX_MODE_CCK:
+ 	case MT76_TM_TX_MODE_OFDM:
+ 		if (mphy->chandef.chan->band == NL80211_BAND_5GHZ)
+ 			sband = &mphy->sband_5g.sband;
+ 		else
+ 			sband = &mphy->sband_2g.sband;
+ 
+ 		rate.legacy = sband->bitrates[rate.mcs].bitrate;
+ 		break;
+ 	case MT76_TM_TX_MODE_HT:
+ 		rate.mcs += rate.nss * 8;
+ 		flags |= RATE_INFO_FLAGS_MCS;
+ 
+ 		if (td->tx_rate_sgi)
+ 			flags |= RATE_INFO_FLAGS_SHORT_GI;
+ 		break;
+ 	case MT76_TM_TX_MODE_VHT:
+ 		flags |= RATE_INFO_FLAGS_VHT_MCS;
+ 
+ 		if (td->tx_rate_sgi)
+ 			flags |= RATE_INFO_FLAGS_SHORT_GI;
+ 		break;
+ 	case MT76_TM_TX_MODE_HE_SU:
+ 	case MT76_TM_TX_MODE_HE_EXT_SU:
+ 	case MT76_TM_TX_MODE_HE_TB:
+ 	case MT76_TM_TX_MODE_HE_MU:
+ 		rate.he_gi = td->tx_rate_sgi;
+ 		flags |= RATE_INFO_FLAGS_HE_MCS;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 	rate.flags = flags;
+ 
+ 	switch (mphy->chandef.width) {
+ 	case NL80211_CHAN_WIDTH_160:
+ 	case NL80211_CHAN_WIDTH_80P80:
+ 		rate.bw = RATE_INFO_BW_160;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_80:
+ 		rate.bw = RATE_INFO_BW_80;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_40:
+ 		rate.bw = RATE_INFO_BW_40;
+ 		break;
+ 	default:
+ 		rate.bw = RATE_INFO_BW_20;
+ 		break;
+ 	}
+ 
+ 	bitrate = cfg80211_calculate_bitrate(&rate);
+ 	tx_len = bitrate * tx_time / 10 / 8;
+ 
+ 	if (tx_len < sizeof(struct ieee80211_hdr))
+ 		tx_len = sizeof(struct ieee80211_hdr);
+ 	else if (tx_len > IEEE80211_MAX_FRAME_LEN)
+ 		tx_len = IEEE80211_MAX_FRAME_LEN;
+ 
+ 	new = alloc_skb(tx_len, GFP_KERNEL);
+ 	if (!new)
+ 		return -ENOMEM;
+ 
+ 	skb_copy_header(new, old);
+ 	__skb_put_zero(new, tx_len);
+ 	memcpy(new->data, old->data, sizeof(struct ieee80211_hdr));
+ 
+ 	dev_kfree_skb(old);
+ 	td->tx_skb = new;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c46df37f72ea (mt76: mt7915: calculate new packet length when tx_time is set in testmode)
  static void
 -mt7915_tm_reg_backup_restore(struct mt7915_phy *phy)
 +mt7915_tm_reg_backup_restore(struct mt7915_dev *dev, struct mt7915_phy *phy)
  {
  	int n_regs = ARRAY_SIZE(reg_backup_list);
 -	struct mt7915_dev *dev = phy->dev;
  	bool ext_phy = phy != &dev->phy;
 -	u32 *b = phy->test.reg_backup;
 +	u32 *b = dev->test.reg_backup;
  	int i;
  
 -	if (phy->mt76->test.state == MT76_TM_STATE_OFF) {
 +	if (dev->mt76.test.state == MT76_TM_STATE_OFF) {
  		for (i = 0; i < n_regs; i++)
  			mt76_wr(dev, reg_backup_list[i].band[ext_phy], b[i]);
  		return;
@@@ -201,29 -400,54 +399,57 @@@ mt7915_tm_set_tx_frames(struct mt7915_d
  {
  	static const u8 spe_idx_map[] = {0, 0, 1, 0, 3, 2, 4, 0,
  					 9, 8, 6, 10, 16, 12, 18, 0};
++<<<<<<< HEAD
 +	struct sk_buff *skb = dev->mt76.test.tx_skb;
++=======
+ 	struct mt76_testmode_data *td = &phy->mt76->test;
+ 	struct mt7915_dev *dev = phy->dev;
++>>>>>>> c46df37f72ea (mt76: mt7915: calculate new packet length when tx_time is set in testmode)
  	struct ieee80211_tx_info *info;
 -	u8 duty_cycle = td->tx_duty_cycle;
 -	u32 tx_time = td->tx_time;
 -	u32 ipg = td->tx_ipg;
  
 -	mt7915_tm_set_trx(phy, TM_MAC_RX_RXV, false);
 +	mt7915_tm_set_trx(dev, &dev->phy, TM_MAC_RX_RXV, false);
  
  	if (en) {
 +		u8 tx_ant = dev->mt76.test.tx_antenna_mask;
 +
  		mutex_unlock(&dev->mt76.mutex);
 -		mt7915_set_channel(phy);
 +		mt7915_set_channel(&dev->phy);
  		mutex_lock(&dev->mt76.mutex);
  
 -		mt7915_mcu_set_chan_info(phy, MCU_EXT_CMD_SET_RX_PATH);
 -
 -		if (td->tx_spe_idx) {
 -			phy->test.spe_idx = td->tx_spe_idx;
 -		} else {
 -			u8 tx_ant = td->tx_antenna_mask;
 -
 -			if (phy != &dev->phy)
 -				tx_ant >>= 2;
 -			phy->test.spe_idx = spe_idx_map[tx_ant];
 -		}
 +		mt7915_mcu_set_chan_info(&dev->phy, MCU_EXT_CMD_SET_RX_PATH);
 +		dev->test.spe_idx = spe_idx_map[tx_ant];
  	}
  
++<<<<<<< HEAD
 +	mt7915_tm_set_trx(dev, &dev->phy, TM_MAC_TX, en);
++=======
+ 	/* if all three params are set, duty_cycle will be ignored */
+ 	if (duty_cycle && tx_time && !ipg) {
+ 		ipg = tx_time * 100 / duty_cycle - tx_time;
+ 	} else if (duty_cycle && !tx_time && ipg) {
+ 		if (duty_cycle < 100)
+ 			tx_time = duty_cycle * ipg / (100 - duty_cycle);
+ 	}
  
- 	if (!en || !skb)
+ 	mt7915_tm_set_ipg_params(phy, ipg, td->tx_rate_mode);
+ 	mt7915_tm_set_tx_len(phy, tx_time);
+ 
+ 	if (ipg)
+ 		td->tx_queued_limit = MT76_TM_TIMEOUT * 1000000 / ipg / 2;
++>>>>>>> c46df37f72ea (mt76: mt7915: calculate new packet length when tx_time is set in testmode)
+ 
+ 	if (!en || !td->tx_skb)
  		return;
  
++<<<<<<< HEAD
 +	info = IEEE80211_SKB_CB(skb);
 +	info->control.vif = dev->phy.monitor_vif;
++=======
+ 	info = IEEE80211_SKB_CB(td->tx_skb);
+ 	info->control.vif = phy->monitor_vif;
+ 
+ 	mt7915_tm_set_trx(phy, TM_MAC_TX, en);
++>>>>>>> c46df37f72ea (mt76: mt7915: calculate new packet length when tx_time is set in testmode)
  }
  
  static void
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
