mac80211_hwsim: allow setting iftype support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author James Prestwood <james.prestwood@linux.intel.com>
commit 99e3a44bac37ff033af711ec2ee8e48b6fabcad3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/99e3a44b.failed

The mac80211_hwsim driver hard codes its supported interface types. For
testing purposes it would be valuable to allow changing these supported
types in order to simulate actual drivers than support a limited set of
iftypes. A new attribute was added to allow this:

- HWSIM_ATTR_IFTYPE_SUPPORT
	A u32 bit field of supported NL80211_IFTYPE_* bits

This will only enable/disable iftypes that mac80211_hwsim already
supports.

In order to accomplish this, the ieee80211_iface_limit structure needed
to be built dynamically to only include limit rules for iftypes that
the user requested to enable.

	Signed-off-by: James Prestwood <james.prestwood@linux.intel.com>
[fix some indentation, add netlink error string]
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 99e3a44bac37ff033af711ec2ee8e48b6fabcad3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
diff --cc drivers/net/wireless/mac80211_hwsim.c
index fd008245b808,2fbea02e289a..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -2511,6 -2480,139 +2473,142 @@@ out_err
  	nlmsg_free(mcast_skb);
  }
  
++<<<<<<< HEAD
++=======
+ static const struct ieee80211_sband_iftype_data he_capa_2ghz = {
+ 	/* TODO: should we support other types, e.g., P2P?*/
+ 	.types_mask = BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP),
+ 	.he_cap = {
+ 		.has_he = true,
+ 		.he_cap_elem = {
+ 			.mac_cap_info[0] =
+ 				IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 			.mac_cap_info[1] =
+ 				IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 				IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 			.mac_cap_info[2] =
+ 				IEEE80211_HE_MAC_CAP2_BSR |
+ 				IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 				IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 			.mac_cap_info[3] =
+ 				IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 				IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 			.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 			.phy_cap_info[1] =
+ 				IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 				IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 				IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 				IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 			.phy_cap_info[2] =
+ 				IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 				IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 			/* Leave all the other PHY capability bytes unset, as
+ 			 * DCM, beam forming, RU and PPE threshold information
+ 			 * are not supported
+ 			 */
+ 		},
+ 		.he_mcs_nss_supp = {
+ 			.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_160 = cpu_to_le16(0xffff),
+ 			.tx_mcs_160 = cpu_to_le16(0xffff),
+ 			.rx_mcs_80p80 = cpu_to_le16(0xffff),
+ 			.tx_mcs_80p80 = cpu_to_le16(0xffff),
+ 		},
+ 	},
+ };
+ 
+ static const struct ieee80211_sband_iftype_data he_capa_5ghz = {
+ 	/* TODO: should we support other types, e.g., P2P?*/
+ 	.types_mask = BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP),
+ 	.he_cap = {
+ 		.has_he = true,
+ 		.he_cap_elem = {
+ 			.mac_cap_info[0] =
+ 				IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 			.mac_cap_info[1] =
+ 				IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 				IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 			.mac_cap_info[2] =
+ 				IEEE80211_HE_MAC_CAP2_BSR |
+ 				IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 				IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 			.mac_cap_info[3] =
+ 				IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 				IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 			.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 			.phy_cap_info[0] =
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,
+ 			.phy_cap_info[1] =
+ 				IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 				IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 				IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 				IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 			.phy_cap_info[2] =
+ 				IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 				IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 			/* Leave all the other PHY capability bytes unset, as
+ 			 * DCM, beam forming, RU and PPE threshold information
+ 			 * are not supported
+ 			 */
+ 		},
+ 		.he_mcs_nss_supp = {
+ 			.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_160 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_160 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 		},
+ 	},
+ };
+ 
+ static void mac80211_hswim_he_capab(struct ieee80211_supported_band *sband)
+ {
+ 	if (sband->band == NL80211_BAND_2GHZ)
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)&he_capa_2ghz;
+ 	else if (sband->band == NL80211_BAND_5GHZ)
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)&he_capa_5ghz;
+ 	else
+ 		return;
+ 
+ 	sband->n_iftype_data = 1;
+ }
+ 
+ #ifdef CONFIG_MAC80211_MESH
+ #define HWSIM_MESH_BIT BIT(NL80211_IFTYPE_MESH_POINT)
+ #else
+ #define HWSIM_MESH_BIT 0
+ #endif
+ 
+ #define HWSIM_DEFAULT_IF_LIMIT \
+ 	(BIT(NL80211_IFTYPE_STATION) | \
+ 	 BIT(NL80211_IFTYPE_P2P_CLIENT) | \
+ 	 BIT(NL80211_IFTYPE_AP) | \
+ 	 BIT(NL80211_IFTYPE_P2P_GO) | \
+ 	 HWSIM_MESH_BIT)
+ 
+ #define HWSIM_IFTYPE_SUPPORT_MASK \
+ 	(BIT(NL80211_IFTYPE_STATION) | \
+ 	 BIT(NL80211_IFTYPE_AP) | \
+ 	 BIT(NL80211_IFTYPE_P2P_CLIENT) | \
+ 	 BIT(NL80211_IFTYPE_P2P_GO) | \
+ 	 BIT(NL80211_IFTYPE_ADHOC) | \
+ 	 BIT(NL80211_IFTYPE_MESH_POINT))
+ 
++>>>>>>> 99e3a44bac37 (mac80211_hwsim: allow setting iftype support)
  static int mac80211_hwsim_new_radio(struct genl_info *info,
  				    struct hwsim_new_radio_params *param)
  {
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
diff --git a/drivers/net/wireless/mac80211_hwsim.h b/drivers/net/wireless/mac80211_hwsim.h
index 3dc22059f6ef..5a669e9c4a6f 100644
--- a/drivers/net/wireless/mac80211_hwsim.h
+++ b/drivers/net/wireless/mac80211_hwsim.h
@@ -129,6 +129,7 @@ enum {
  * @HWSIM_ATTR_TX_INFO_FLAGS: additional flags for corresponding
  *	rates of %HWSIM_ATTR_TX_INFO
  * @HWSIM_ATTR_PERM_ADDR: permanent mac address of new radio
+ * @HWSIM_ATTR_IFTYPE_SUPPORT: u32 attribute of supported interface types bits
  * @__HWSIM_ATTR_MAX: enum limit
  */
 
@@ -157,6 +158,7 @@ enum {
 	HWSIM_ATTR_PAD,
 	HWSIM_ATTR_TX_INFO_FLAGS,
 	HWSIM_ATTR_PERM_ADDR,
+	HWSIM_ATTR_IFTYPE_SUPPORT,
 	__HWSIM_ATTR_MAX,
 };
 #define HWSIM_ATTR_MAX (__HWSIM_ATTR_MAX - 1)
