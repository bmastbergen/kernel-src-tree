tcp: refactor setting the initial congestion window

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Yuchung Cheng <ycheng@google.com>
commit 98fa6271cfcb1de873b3fe0caf48d9daa1bcc0ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/98fa6271.failed

Relocate the congestion window initialization from tcp_init_metrics()
to tcp_init_transfer() to improve code readability.

	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: Soheil Hassas Yeganeh <soheil@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 98fa6271cfcb1de873b3fe0caf48d9daa1bcc0ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_metrics.c
diff --cc net/ipv4/tcp_metrics.c
index bcfd8b8bedf9,c4848e7a0aad..000000000000
--- a/net/ipv4/tcp_metrics.c
+++ b/net/ipv4/tcp_metrics.c
@@@ -512,16 -512,6 +512,19 @@@ reset
  
  		inet_csk(sk)->icsk_rto = TCP_TIMEOUT_FALLBACK;
  	}
++<<<<<<< HEAD
 +	/* Cut cwnd down to 1 per RFC5681 if SYN or SYN-ACK has been
 +	 * retransmitted. In light of RFC6298 more aggressive 1sec
 +	 * initRTO, we only reset cwnd when more than 1 SYN/SYN-ACK
 +	 * retransmission has occurred.
 +	 */
 +	if (tp->total_retrans > 1)
 +		tp->snd_cwnd = 1;
 +	else
 +		tp->snd_cwnd = tcp_init_cwnd(tp, dst);
 +	tp->snd_cwnd_stamp = tcp_jiffies32;
++=======
++>>>>>>> 98fa6271cfcb (tcp: refactor setting the initial congestion window)
  }
  
  bool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst)
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 98852debb36e..03a7dd6e0f82 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -460,18 +460,6 @@ void tcp_init_sock(struct sock *sk)
 }
 EXPORT_SYMBOL(tcp_init_sock);
 
-void tcp_init_transfer(struct sock *sk, int bpf_op)
-{
-	struct inet_connection_sock *icsk = inet_csk(sk);
-
-	tcp_mtup_init(sk);
-	icsk->icsk_af_ops->rebuild_header(sk);
-	tcp_init_metrics(sk);
-	tcp_call_bpf(sk, bpf_op, 0, NULL);
-	tcp_init_congestion_control(sk);
-	tcp_init_buffer_space(sk);
-}
-
 static void tcp_tx_timestamp(struct sock *sk, u16 tsflags)
 {
 	struct sk_buff *skb = tcp_write_queue_tail(sk);
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 7ad9d21661f3..d5f69483bb05 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -5741,6 +5741,32 @@ void tcp_rcv_established(struct sock *sk, struct sk_buff *skb)
 }
 EXPORT_SYMBOL(tcp_rcv_established);
 
+void tcp_init_transfer(struct sock *sk, int bpf_op)
+{
+	struct inet_connection_sock *icsk = inet_csk(sk);
+	struct tcp_sock *tp = tcp_sk(sk);
+
+	tcp_mtup_init(sk);
+	icsk->icsk_af_ops->rebuild_header(sk);
+	tcp_init_metrics(sk);
+
+	/* Initialize the congestion window to start the transfer.
+	 * Cut cwnd down to 1 per RFC5681 if SYN or SYN-ACK has been
+	 * retransmitted. In light of RFC6298 more aggressive 1sec
+	 * initRTO, we only reset cwnd when more than 1 SYN/SYN-ACK
+	 * retransmission has occurred.
+	 */
+	if (tp->total_retrans > 1 && tp->undo_marker)
+		tp->snd_cwnd = 1;
+	else
+		tp->snd_cwnd = tcp_init_cwnd(tp, __sk_dst_get(sk));
+	tp->snd_cwnd_stamp = tcp_jiffies32;
+
+	tcp_call_bpf(sk, bpf_op, 0, NULL);
+	tcp_init_congestion_control(sk);
+	tcp_init_buffer_space(sk);
+}
+
 void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
* Unmerged path net/ipv4/tcp_metrics.c
