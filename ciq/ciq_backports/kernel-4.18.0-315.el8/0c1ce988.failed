mt76: mt7921: add wifi reset support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 0c1ce988460765ece1ba8eacd00533eefb6e666a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/0c1ce988.failed

Introduce wifi chip reset support for mt7921 device to recover mcu
hangs.

Co-developed-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 0c1ce988460765ece1ba8eacd00533eefb6e666a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7921/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
#	drivers/net/wireless/mediatek/mt76/mt7921/regs.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index 52c5eacf1b8a,05971ea9f8fa..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@@ -1170,19 -1177,22 +1170,17 @@@ void mt7921_update_channel(struct mt76_
  	mt7921_phy_update_channel(&mdev->phy, 0);
  	/* reset obss airtime */
  	mt76_set(dev, MT_WF_RMAC_MIB_TIME0(0), MT_WF_RMAC_MIB_RXTIME_CLR);
 -
 -	mt76_connac_power_save_sched(&dev->mphy, &dev->pm);
  }
  
- static bool
- mt7921_wait_reset_state(struct mt7921_dev *dev, u32 state)
+ static int
+ mt7921_wfsys_reset(struct mt7921_dev *dev)
  {
- 	bool ret;
+ 	mt76_set(dev, 0x70002600, BIT(0));
+ 	msleep(200);
+ 	mt76_clear(dev, 0x70002600, BIT(0));
  
- 	ret = wait_event_timeout(dev->reset_wait,
- 				 (READ_ONCE(dev->reset_state) & state),
- 				 MT7921_RESET_TIMEOUT);
- 
- 	WARN(!ret, "Timeout waiting for MCU reset state %x\n", state);
- 	return ret;
+ 	return __mt76_poll_msec(&dev->mt76, MT_WFSYS_SW_RST_B,
+ 				WFSYS_SW_INIT_DONE, WFSYS_SW_INIT_DONE, 500);
  }
  
  static void
@@@ -1252,51 -1308,95 +1296,106 @@@ mt7921_mac_reset(struct mt7921_dev *dev
  	mt76_txq_schedule_all(&dev->mphy);
  
  	mt76_worker_disable(&dev->mt76.tx_worker);
- 	napi_disable(&dev->mt76.napi[0]);
- 	napi_disable(&dev->mt76.napi[1]);
- 	napi_disable(&dev->mt76.napi[2]);
+ 	napi_disable(&dev->mt76.napi[MT_RXQ_MAIN]);
+ 	napi_disable(&dev->mt76.napi[MT_RXQ_MCU]);
+ 	napi_disable(&dev->mt76.napi[MT_RXQ_MCU_WA]);
  	napi_disable(&dev->mt76.tx_napi);
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->mt76.mutex);
 +
 +	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);
 +
++=======
++>>>>>>> 0c1ce9884607 (mt76: mt7921: add wifi reset support)
  	mt7921_tx_token_put(dev);
  	idr_init(&dev->token);
  
- 	if (mt7921_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
- 		mt7921_dma_reset(&dev->phy);
+ 	/* clean up hw queues */
+ 	for (i = 0; i < ARRAY_SIZE(dev->mt76.phy.q_tx); i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);
  
- 		mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);
- 		mt7921_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
- 	}
+ 	for (i = 0; i < ARRAY_SIZE(dev->mt76.q_mcu); i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);
  
- 	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
- 	clear_bit(MT76_RESET, &dev->mphy.state);
+ 	mt76_for_each_q_rx(&dev->mt76, i)
+ 		mt76_queue_rx_cleanup(dev, &dev->mt76.q_rx[i]);
+ 
+ 	mt7921_wfsys_reset(dev);
+ 	mt7921_dma_reset(dev);
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i) {
+ 		mt76_queue_rx_reset(dev, i);
+ 		napi_enable(&dev->mt76.napi[i]);
+ 		napi_schedule(&dev->mt76.napi[i]);
+ 	}
  
- 	mt76_worker_enable(&dev->mt76.tx_worker);
  	napi_enable(&dev->mt76.tx_napi);
  	napi_schedule(&dev->mt76.tx_napi);
+ 	mt76_worker_enable(&dev->mt76.tx_worker);
  
- 	napi_enable(&dev->mt76.napi[0]);
- 	napi_schedule(&dev->mt76.napi[0]);
+ 	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
  
- 	napi_enable(&dev->mt76.napi[1]);
- 	napi_schedule(&dev->mt76.napi[1]);
+ 	mt76_wr(dev, MT_WFDMA0_HOST_INT_ENA, 0);
+ 	mt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);
+ 	mt7921_irq_enable(dev,
+ 			  MT_INT_RX_DONE_ALL | MT_INT_TX_DONE_ALL |
+ 			  MT_INT_MCU_CMD);
  
- 	napi_enable(&dev->mt76.napi[2]);
- 	napi_schedule(&dev->mt76.napi[2]);
+ 	err = mt7921_run_firmware(dev);
+ 	if (err)
+ 		return err;
  
- 	ieee80211_wake_queues(mt76_hw(dev));
+ 	err = mt7921_mcu_set_eeprom(dev);
+ 	if (err)
+ 		return err;
  
- 	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_RESET_DONE);
- 	mt7921_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);
+ 	mt7921_mac_init(dev);
+ 	return __mt7921_start(&dev->phy);
+ }
  
++<<<<<<< HEAD
 +	mutex_unlock(&dev->mt76.mutex);
++=======
+ /* system error recovery */
+ void mt7921_mac_reset_work(struct work_struct *work)
+ {
+ 	struct ieee80211_hw *hw;
+ 	struct mt7921_dev *dev;
+ 	int i;
++>>>>>>> 0c1ce9884607 (mt76: mt7921: add wifi reset support)
  
- 	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
- 				     MT7921_WATCHDOG_TIME);
+ 	dev = container_of(work, struct mt7921_dev, reset_work);
+ 	hw = mt76_hw(dev);
+ 
+ 	dev_err(dev->mt76.dev, "chip reset\n");
+ 	ieee80211_stop_queues(hw);
+ 
+ 	cancel_delayed_work_sync(&dev->mphy.mac_work);
+ 	cancel_delayed_work_sync(&dev->pm.ps_work);
+ 	cancel_work_sync(&dev->pm.wake_work);
+ 
+ 	mutex_lock(&dev->mt76.mutex);
+ 	for (i = 0; i < 10; i++) {
+ 		if (!mt7921_mac_reset(dev))
+ 			break;
+ 	}
+ 	mutex_unlock(&dev->mt76.mutex);
+ 
+ 	if (i == 10)
+ 		dev_err(dev->mt76.dev, "chip reset failed\n");
+ 
+ 	ieee80211_wake_queues(hw);
+ 	ieee80211_iterate_active_interfaces(hw,
+ 					    IEEE80211_IFACE_ITER_RESUME_ALL,
+ 					    mt7921_vif_connect_iter, 0);
+ }
+ 
+ void mt7921_reset(struct mt76_dev *mdev)
+ {
+ 	struct mt7921_dev *dev = container_of(mdev, struct mt7921_dev, mt76);
+ 
+ 	queue_work(dev->mt76.wq, &dev->reset_work);
  }
  
  static void
@@@ -1376,8 -1479,119 +1475,121 @@@ void mt7921_mac_work(struct work_struc
  		mt7921_mac_sta_stats_work(phy);
  	}
  
 -	mt7921_mutex_release(phy->dev);
 +	mutex_unlock(&mphy->dev->mutex);
  
 -out:
 -	ieee80211_queue_delayed_work(phy->mt76->hw, &mphy->mac_work,
 +	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
  				     MT7921_WATCHDOG_TIME);
  }
++<<<<<<< HEAD
++=======
+ 
+ void mt7921_pm_wake_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	struct mt76_phy *mphy;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						pm.wake_work);
+ 	mphy = dev->phy.mt76;
+ 
+ 	if (!mt7921_mcu_drv_pmctrl(dev))
+ 		mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
+ 	else
+ 		dev_err(mphy->dev->dev, "failed to wake device\n");
+ 
+ 	ieee80211_wake_queues(mphy->hw);
+ 	complete_all(&dev->pm.wake_cmpl);
+ }
+ 
+ void mt7921_pm_power_save_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	unsigned long delta;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						pm.ps_work.work);
+ 
+ 	delta = dev->pm.idle_timeout;
+ 	if (time_is_after_jiffies(dev->pm.last_activity + delta)) {
+ 		delta = dev->pm.last_activity + delta - jiffies;
+ 		goto out;
+ 	}
+ 
+ 	if (!mt7921_mcu_fw_pmctrl(dev))
+ 		return;
+ out:
+ 	queue_delayed_work(dev->mt76.wq, &dev->pm.ps_work, delta);
+ }
+ 
+ int mt7921_mac_set_beacon_filter(struct mt7921_phy *phy,
+ 				 struct ieee80211_vif *vif,
+ 				 bool enable)
+ {
+ 	struct mt7921_dev *dev = phy->dev;
+ 	bool ext_phy = phy != &dev->phy;
+ 	int err;
+ 
+ 	if (!dev->pm.enable)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = mt7921_mcu_set_bss_pm(dev, vif, enable);
+ 	if (err)
+ 		return err;
+ 
+ 	if (enable) {
+ 		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_set(dev, MT_WF_RFCR(ext_phy),
+ 			 MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	} else {
+ 		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_clear(dev, MT_WF_RFCR(ext_phy),
+ 			   MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void mt7921_coredump_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	char *dump, *data;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						coredump.work.work);
+ 
+ 	if (time_is_after_jiffies(dev->coredump.last_activity +
+ 				  4 * MT76_CONNAC_COREDUMP_TIMEOUT)) {
+ 		queue_delayed_work(dev->mt76.wq, &dev->coredump.work,
+ 				   MT76_CONNAC_COREDUMP_TIMEOUT);
+ 		return;
+ 	}
+ 
+ 	dump = vzalloc(MT76_CONNAC_COREDUMP_SZ);
+ 	data = dump;
+ 
+ 	while (true) {
+ 		struct sk_buff *skb;
+ 
+ 		spin_lock_bh(&dev->mt76.lock);
+ 		skb = __skb_dequeue(&dev->coredump.msg_list);
+ 		spin_unlock_bh(&dev->mt76.lock);
+ 
+ 		if (!skb)
+ 			break;
+ 
+ 		skb_pull(skb, sizeof(struct mt7921_mcu_rxd));
+ 		if (data + skb->len - dump > MT76_CONNAC_COREDUMP_SZ) {
+ 			dev_kfree_skb(skb);
+ 			continue;
+ 		}
+ 
+ 		memcpy(data, skb->data, skb->len);
+ 		data += skb->len;
+ 
+ 		dev_kfree_skb(skb);
+ 	}
+ 	dev_coredumpv(dev->mt76.dev, dump, MT76_CONNAC_COREDUMP_SZ,
+ 		      GFP_KERNEL);
+ 	mt7921_reset(&dev->mt76);
+ }
++>>>>>>> 0c1ce9884607 (mt76: mt7921: add wifi reset support)
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
index aac903fec380,98b48b26a6fe..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
@@@ -2636,296 -1253,77 +2637,312 @@@ int mt7921_mcu_set_bss_pm(struct mt7921
  				 sizeof(req), false);
  }
  
 -int mt7921_mcu_drv_pmctrl(struct mt7921_dev *dev)
 +#ifdef CONFIG_PM
 +int mt7921_mcu_set_hif_suspend(struct mt7921_dev *dev, bool suspend)
  {
 -	struct mt76_phy *mphy = &dev->mt76.phy;
 -	int i;
 +	struct {
 +		struct {
 +			u8 hif_type; /* 0x0: HIF_SDIO
 +				      * 0x1: HIF_USB
 +				      * 0x2: HIF_PCIE
 +				      */
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct hif_suspend_tlv {
 +			__le16 tag;
 +			__le16 len;
 +			u8 suspend;
 +		} __packed hif_suspend;
 +	} req = {
 +		.hif_suspend = {
 +			.tag = cpu_to_le16(0), /* 0: UNI_HIF_CTRL_BASIC */
 +			.len = cpu_to_le16(sizeof(struct hif_suspend_tlv)),
 +			.suspend = suspend,
 +		},
 +	};
  
 -	if (!test_and_clear_bit(MT76_STATE_PM, &mphy->state))
 -		goto out;
 +	if (mt76_is_mmio(&dev->mt76))
 +		req.hdr.hif_type = 2;
 +	else if (mt76_is_usb(&dev->mt76))
 +		req.hdr.hif_type = 1;
 +	else if (mt76_is_sdio(&dev->mt76))
 +		req.hdr.hif_type = 0;
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_HIF_CTRL, &req,
 +				 sizeof(req), true);
 +}
 +EXPORT_SYMBOL_GPL(mt7921_mcu_set_hif_suspend);
 +
 +static int
 +mt7921_mcu_set_wow_ctrl(struct mt7921_phy *phy, struct ieee80211_vif *vif,
 +			bool suspend, struct cfg80211_wowlan *wowlan)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_dev *dev = phy->dev;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_wow_ctrl_tlv wow_ctrl_tlv;
 +		struct mt7921_wow_gpio_param_tlv gpio_tlv;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.wow_ctrl_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_WOW_CTRL),
 +			.len = cpu_to_le16(sizeof(struct mt7921_wow_ctrl_tlv)),
 +			.cmd = suspend ? 1 : 2,
 +		},
 +		.gpio_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_WOW_GPIO_PARAM),
 +			.len = cpu_to_le16(sizeof(struct mt7921_wow_gpio_param_tlv)),
 +			.gpio_pin = 0xff, /* follow fw about GPIO pin */
 +		},
 +	};
  
 -	for (i = 0; i < MT7921_DRV_OWN_RETRY_COUNT; i++) {
 -		mt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_CLR_OWN);
 -		if (mt76_poll_msec(dev, MT_CONN_ON_LPCTL,
 -				   PCIE_LPCR_HOST_OWN_SYNC, 0, 50))
 -			break;
 +	if (wowlan->magic_pkt)
 +		req.wow_ctrl_tlv.trigger |= BIT(0);
 +	if (wowlan->disconnect)
 +		req.wow_ctrl_tlv.trigger |= BIT(2);
 +	if (wowlan->nd_config) {
 +		mt7921_mcu_sched_scan_req(phy, vif, wowlan->nd_config);
 +		req.wow_ctrl_tlv.trigger |= BIT(5);
 +		mt7921_mcu_sched_scan_enable(phy, vif, suspend);
  	}
  
++<<<<<<< HEAD
 +	if (mt76_is_mmio(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_PCIE;
 +	else if (mt76_is_usb(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_USB;
 +	else if (mt76_is_sdio(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_GPIO;
++=======
+ 	if (i == MT7921_DRV_OWN_RETRY_COUNT) {
+ 		dev_err(dev->mt76.dev, "driver own failed\n");
+ 		mt7921_reset(&dev->mt76);
+ 		return -EIO;
+ 	}
++>>>>>>> 0c1ce9884607 (mt76: mt7921: add wifi reset support)
  
 -out:
 -	dev->pm.last_activity = jiffies;
 -
 -	return 0;
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_SUSPEND, &req,
 +				 sizeof(req), true);
  }
  
 -int mt7921_mcu_fw_pmctrl(struct mt7921_dev *dev)
 +static int
 +mt7921_mcu_set_wow_pattern(struct mt7921_dev *dev,
 +			   struct ieee80211_vif *vif,
 +			   u8 index, bool enable,
 +			   struct cfg80211_pkt_pattern *pattern)
  {
 -	struct mt76_phy *mphy = &dev->mt76.phy;
 -	int i;
 -
 -	if (test_and_set_bit(MT76_STATE_PM, &mphy->state))
 -		return 0;
 -
 -	for (i = 0; i < MT7921_DRV_OWN_RETRY_COUNT; i++) {
 -		mt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_SET_OWN);
 -		if (mt76_poll_msec(dev, MT_CONN_ON_LPCTL,
 -				   PCIE_LPCR_HOST_OWN_SYNC, 4, 50))
 -			break;
 -	}
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_wow_pattern_tlv *ptlv;
 +	struct sk_buff *skb;
 +	struct req_hdr {
 +		u8 bss_idx;
 +		u8 pad[3];
 +	} __packed hdr = {
 +		.bss_idx = mvif->mt76.idx,
 +	};
  
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(hdr) + sizeof(*ptlv));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &hdr, sizeof(hdr));
 +	ptlv = (struct mt7921_wow_pattern_tlv *)skb_put(skb, sizeof(*ptlv));
 +	ptlv->tag = cpu_to_le16(UNI_SUSPEND_WOW_PATTERN);
 +	ptlv->len = cpu_to_le16(sizeof(*ptlv));
 +	ptlv->data_len = pattern->pattern_len;
 +	ptlv->enable = enable;
 +	ptlv->index = index;
 +
++<<<<<<< HEAD
 +	memcpy(ptlv->pattern, pattern->pattern, pattern->pattern_len);
 +	memcpy(ptlv->mask, pattern->mask, pattern->pattern_len / 8);
++=======
+ 	if (i == MT7921_DRV_OWN_RETRY_COUNT) {
+ 		dev_err(dev->mt76.dev, "firmware own failed\n");
+ 		mt7921_reset(&dev->mt76);
+ 		return -EIO;
+ 	}
++>>>>>>> 0c1ce9884607 (mt76: mt7921: add wifi reset support)
  
 -	return 0;
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_UNI_CMD_SUSPEND,
 +				     true);
  }
  
 -void
 -mt7921_pm_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)
 +static int
 +mt7921_mcu_set_suspend_mode(struct mt7921_dev *dev,
 +			    struct ieee80211_vif *vif,
 +			    bool enable, u8 mdtim, bool wow_suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_suspend_tlv suspend_tlv;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.suspend_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_MODE_SETTING),
 +			.len = cpu_to_le16(sizeof(struct mt7921_suspend_tlv)),
 +			.enable = enable,
 +			.mdtim = mdtim,
 +			.wow_suspend = wow_suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_SUSPEND, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_gtk_rekey(struct mt7921_dev *dev,
 +			 struct ieee80211_vif *vif,
 +			 bool suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_gtk_rekey_tlv gtk_tlv;
 +	} __packed req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.gtk_tlv = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY),
 +			.len = cpu_to_le16(sizeof(struct mt7921_gtk_rekey_tlv)),
 +			.rekey_mode = !suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_OFFLOAD, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_arp_filter(struct mt7921_dev *dev, struct ieee80211_vif *vif,
 +			  bool suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_arpns_tlv arpns;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.arpns = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ARP),
 +			.len = cpu_to_le16(sizeof(struct mt7921_arpns_tlv)),
 +			.mode = suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_OFFLOAD, &req,
 +				 sizeof(req), true);
 +}
 +
 +void mt7921_mcu_set_suspend_iter(void *priv, u8 *mac,
 +				 struct ieee80211_vif *vif)
  {
  	struct mt7921_phy *phy = priv;
 -	struct mt7921_dev *dev = phy->dev;
 -	int ret;
 +	bool suspend = test_bit(MT76_STATE_SUSPEND, &phy->mt76->state);
 +	struct ieee80211_hw *hw = phy->mt76->hw;
 +	struct cfg80211_wowlan *wowlan = hw->wiphy->wowlan_config;
 +	int i;
  
 -	if (dev->pm.enable)
 -		ret = mt7921_mcu_uni_bss_bcnft(dev, vif, true);
 -	else
 -		ret = mt7921_mcu_set_bss_pm(dev, vif, false);
 +	mt7921_mcu_set_gtk_rekey(phy->dev, vif, suspend);
 +	mt7921_mcu_set_arp_filter(phy->dev, vif, suspend);
  
 -	if (ret)
 +	mt7921_mcu_set_suspend_mode(phy->dev, vif, suspend, 1, true);
 +
 +	for (i = 0; i < wowlan->n_patterns; i++)
 +		mt7921_mcu_set_wow_pattern(phy->dev, vif, i, suspend,
 +					   &wowlan->patterns[i]);
 +	mt7921_mcu_set_wow_ctrl(phy, vif, suspend, wowlan);
 +}
 +
 +static void
 +mt7921_mcu_key_iter(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 +		    struct ieee80211_sta *sta, struct ieee80211_key_conf *key,
 +		    void *data)
 +{
 +	struct mt7921_gtk_rekey_tlv *gtk_tlv = data;
 +	u32 cipher;
 +
 +	if (key->cipher != WLAN_CIPHER_SUITE_AES_CMAC &&
 +	    key->cipher != WLAN_CIPHER_SUITE_CCMP &&
 +	    key->cipher != WLAN_CIPHER_SUITE_TKIP)
  		return;
  
 -	if (dev->pm.enable) {
 -		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
 -		mt76_set(dev, MT_WF_RFCR(0), MT_WF_RFCR_DROP_OTHER_BEACON);
 +	if (key->cipher == WLAN_CIPHER_SUITE_TKIP) {
 +		gtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_1);
 +		cipher = BIT(3);
  	} else {
 -		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
 -		mt76_clear(dev, MT_WF_RFCR(0), MT_WF_RFCR_DROP_OTHER_BEACON);
 +		gtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_2);
 +		cipher = BIT(4);
  	}
 +
 +	/* we are assuming here to have a single pairwise key */
 +	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {
 +		gtk_tlv->pairwise_cipher = cpu_to_le32(cipher);
 +		gtk_tlv->group_cipher = cpu_to_le32(cipher);
 +		gtk_tlv->keyid = key->keyidx;
 +	}
 +}
 +
 +int mt7921_mcu_update_gtk_rekey(struct ieee80211_hw *hw,
 +				struct ieee80211_vif *vif,
 +				struct cfg80211_gtk_rekey_data *key)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_dev *dev = mt7921_hw_dev(hw);
 +	struct mt7921_gtk_rekey_tlv *gtk_tlv;
 +	struct sk_buff *skb;
 +	struct {
 +		u8 bss_idx;
 +		u8 pad[3];
 +	} __packed hdr = {
 +		.bss_idx = mvif->mt76.idx,
 +	};
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(hdr) + sizeof(*gtk_tlv));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &hdr, sizeof(hdr));
 +	gtk_tlv = (struct mt7921_gtk_rekey_tlv *)skb_put(skb,
 +							 sizeof(*gtk_tlv));
 +	gtk_tlv->tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY);
 +	gtk_tlv->len = cpu_to_le16(sizeof(*gtk_tlv));
 +	gtk_tlv->rekey_mode = 2;
 +	gtk_tlv->option = 1;
 +
 +	rcu_read_lock();
 +	ieee80211_iter_keys_rcu(hw, vif, mt7921_mcu_key_iter, gtk_tlv);
 +	rcu_read_unlock();
 +
 +	memcpy(gtk_tlv->kek, key->kek, NL80211_KEK_LEN);
 +	memcpy(gtk_tlv->kck, key->kck, NL80211_KCK_LEN);
 +	memcpy(gtk_tlv->replay_ctr, key->replay_ctr, NL80211_REPLAY_CTR_LEN);
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_UNI_CMD_OFFLOAD,
 +				     true);
  }
 +#endif /* CONFIG_PM */
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/regs.h
index 28451c7d9573,035fa472fa7d..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/regs.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/regs.h
@@@ -413,6 -413,15 +413,18 @@@
  
  #define MT_DMASHDL_SCHED_SET(_n)	MT_DMA_SHDL(0x070 + ((_n) << 2))
  
++<<<<<<< HEAD
++=======
+ #define MT_CONN_ON_LPCTL		0x7c060010
+ #define PCIE_LPCR_HOST_OWN_SYNC		BIT(2)
+ #define PCIE_LPCR_HOST_CLR_OWN		BIT(1)
+ #define PCIE_LPCR_HOST_SET_OWN		BIT(0)
+ 
+ #define MT_WFSYS_SW_RST_B		0x18000140
+ #define WFSYS_SW_RST_B			BIT(0)
+ #define WFSYS_SW_INIT_DONE		BIT(4)
+ 
++>>>>>>> 0c1ce9884607 (mt76: mt7921: add wifi reset support)
  #define MT_CONN_ON_MISC			0x7c0600f0
  #define MT_TOP_MISC2_FW_N9_RDY		GENMASK(1, 0)
  
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/init.c b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
index 1af7367c40d5..00d88699fa8c 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
@@ -141,7 +141,7 @@ mt7921_mac_init_band(struct mt7921_dev *dev, u8 band)
 	mt76_clear(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_RXD_G5_EN);
 }
 
-static void mt7921_mac_init(struct mt7921_dev *dev)
+void mt7921_mac_init(struct mt7921_dev *dev)
 {
 	int i;
 
@@ -223,7 +223,6 @@ int mt7921_register_device(struct mt7921_dev *dev)
 	INIT_LIST_HEAD(&dev->sta_poll_list);
 	spin_lock_init(&dev->sta_poll_lock);
 
-	init_waitqueue_head(&dev->reset_wait);
 	INIT_WORK(&dev->reset_work, mt7921_mac_reset_work);
 
 	ret = mt7921_init_hardware(dev);
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mac.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index 2a7af97420c3..3c1196c4dd4d 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@ -153,8 +153,6 @@ struct mt7921_dev {
 
 	struct work_struct init_work;
 	struct work_struct reset_work;
-	wait_queue_head_t reset_wait;
-	u32 reset_state;
 
 	struct list_head sta_poll_list;
 	spinlock_t sta_poll_lock;
@@ -296,6 +294,7 @@ mt7921_l1_rmw(struct mt7921_dev *dev, u32 addr, u32 mask, u32 val)
 #define mt7921_l1_set(dev, addr, val)	mt7921_l1_rmw(dev, addr, 0, val)
 #define mt7921_l1_clear(dev, addr, val)	mt7921_l1_rmw(dev, addr, val, 0)
 
+void mt7921_mac_init(struct mt7921_dev *dev);
 bool mt7921_mac_wtbl_update(struct mt7921_dev *dev, int idx, u32 mask);
 void mt7921_mac_reset_counters(struct mt7921_phy *phy);
 void mt7921_mac_write_txwi(struct mt7921_dev *dev, __le32 *txwi,
@@ -311,6 +310,7 @@ void mt7921_mac_sta_remove(struct mt76_dev *mdev, struct ieee80211_vif *vif,
 			   struct ieee80211_sta *sta);
 void mt7921_mac_work(struct work_struct *work);
 void mt7921_mac_reset_work(struct work_struct *work);
+void mt7921_reset(struct mt76_dev *mdev);
 int mt7921_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 			  enum mt76_txq_id qid, struct mt76_wcid *wcid,
 			  struct ieee80211_sta *sta,
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/regs.h
