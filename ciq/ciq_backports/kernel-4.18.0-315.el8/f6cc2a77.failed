scsi: smartpqi: Add support for BMIC sense feature cmd and feature bits

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Kevin Barnett <kevin.barnett@microchip.com>
commit f6cc2a774aa7f5469f381b52804bb244d4f8f4d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/f6cc2a77.failed

Determine support for supported features from BMIC sense feature command
instead of config table. Enable features such as: RAID 1/5/6 write
support, SATA wwid, and encryption.

Link: https://lore.kernel.org/r/161549373914.25025.7999816178098103135.stgit@brunhilda
	Reviewed-by: Scott Teel <scott.teel@microchip.com>
	Reviewed-by: Mike McGowen <mike.mcgowen@microchip.com>
	Reviewed-by: Scott Benesh <scott.benesh@microchip.com>
	Signed-off-by: Kevin Barnett <kevin.barnett@microchip.com>
	Signed-off-by: Don Brace <don.brace@microchip.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f6cc2a774aa7f5469f381b52804bb244d4f8f4d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/smartpqi/smartpqi.h
#	drivers/scsi/smartpqi/smartpqi_init.c
diff --cc drivers/scsi/smartpqi/smartpqi.h
index 7d3f956e949f,35e892579773..000000000000
--- a/drivers/scsi/smartpqi/smartpqi.h
+++ b/drivers/scsi/smartpqi/smartpqi.h
@@@ -312,6 -313,71 +312,74 @@@ struct pqi_aio_path_request 
  		sg_descriptors[PQI_MAX_EMBEDDED_SG_DESCRIPTORS];
  };
  
++<<<<<<< HEAD
++=======
+ #define PQI_RAID1_NVME_XFER_LIMIT	(32 * 1024)	/* 32 KiB */
+ struct pqi_aio_r1_path_request {
+ 	struct pqi_iu_header header;
+ 	__le16	request_id;
+ 	__le16	volume_id;	/* ID of the RAID volume */
+ 	__le32	it_nexus_1;	/* IT nexus of the 1st drive in the RAID volume */
+ 	__le32	it_nexus_2;	/* IT nexus of the 2nd drive in the RAID volume */
+ 	__le32	it_nexus_3;	/* IT nexus of the 3rd drive in the RAID volume */
+ 	__le32	data_length;	/* total bytes to read/write */
+ 	u8	data_direction : 2;
+ 	u8	partial : 1;
+ 	u8	memory_type : 1;
+ 	u8	fence : 1;
+ 	u8	encryption_enable : 1;
+ 	u8	reserved : 2;
+ 	u8	task_attribute : 3;
+ 	u8	command_priority : 4;
+ 	u8	reserved2 : 1;
+ 	__le16	data_encryption_key_index;
+ 	u8	cdb[16];
+ 	__le16	error_index;
+ 	u8	num_sg_descriptors;
+ 	u8	cdb_length;
+ 	u8	num_drives;	/* number of drives in the RAID volume (2 or 3) */
+ 	u8	reserved3[3];
+ 	__le32	encrypt_tweak_lower;
+ 	__le32	encrypt_tweak_upper;
+ 	struct pqi_sg_descriptor sg_descriptors[PQI_MAX_EMBEDDED_SG_DESCRIPTORS];
+ };
+ 
+ #define PQI_DEFAULT_MAX_WRITE_RAID_5_6			(8 * 1024U)
+ #define PQI_DEFAULT_MAX_TRANSFER_ENCRYPTED_SAS_SATA	(~0U)
+ #define PQI_DEFAULT_MAX_TRANSFER_ENCRYPTED_NVME		(32 * 1024U)
+ 
+ struct pqi_aio_r56_path_request {
+ 	struct pqi_iu_header header;
+ 	__le16	request_id;
+ 	__le16	volume_id;		/* ID of the RAID volume */
+ 	__le32	data_it_nexus;		/* IT nexus for the data drive */
+ 	__le32	p_parity_it_nexus;	/* IT nexus for the P parity drive */
+ 	__le32	q_parity_it_nexus;	/* IT nexus for the Q parity drive */
+ 	__le32	data_length;		/* total bytes to read/write */
+ 	u8	data_direction : 2;
+ 	u8	partial : 1;
+ 	u8	mem_type : 1;		/* 0 = PCIe, 1 = DDR */
+ 	u8	fence : 1;
+ 	u8	encryption_enable : 1;
+ 	u8	reserved : 2;
+ 	u8	task_attribute : 3;
+ 	u8	command_priority : 4;
+ 	u8	reserved1 : 1;
+ 	__le16	data_encryption_key_index;
+ 	u8	cdb[16];
+ 	__le16	error_index;
+ 	u8	num_sg_descriptors;
+ 	u8	cdb_length;
+ 	u8	xor_multiplier;
+ 	u8	reserved2[3];
+ 	__le32	encrypt_tweak_lower;
+ 	__le32	encrypt_tweak_upper;
+ 	__le64	row;			/* row = logical LBA/blocks per row */
+ 	u8	reserved3[8];
+ 	struct pqi_sg_descriptor sg_descriptors[PQI_MAX_EMBEDDED_R56_SG_DESCRIPTORS];
+ };
+ 
++>>>>>>> f6cc2a774aa7 (scsi: smartpqi: Add support for BMIC sense feature cmd and feature bits)
  struct pqi_io_response {
  	struct pqi_iu_header header;
  	__le16	request_id;
@@@ -952,9 -1086,9 +1035,10 @@@ struct pqi_scsi_dev 
  	u16	phys_connector[8];
  	bool	raid_bypass_configured;	/* RAID bypass configured */
  	bool	raid_bypass_enabled;	/* RAID bypass enabled */
 -	u32	next_bypass_group;
 +	int	offload_to_mirror;	/* Send next RAID bypass request */
 +					/* to mirror drive. */
  	struct raid_map *raid_map;	/* RAID bypass map */
+ 	u32	max_transfer_encrypted;
  
  	struct pqi_sas_port *sas_port;
  	struct scsi_device *sdev;
@@@ -1158,6 -1293,17 +1242,20 @@@ struct pqi_ctrl_info 
  	u8		soft_reset_handshake_supported : 1;
  	u8		raid_iu_timeout_supported: 1;
  	u8		tmf_iu_timeout_supported: 1;
++<<<<<<< HEAD
++=======
+ 	u8		enable_r1_writes : 1;
+ 	u8		enable_r5_writes : 1;
+ 	u8		enable_r6_writes : 1;
+ 	u8		lv_drive_type_mix_valid : 1;
+ 
+ 	u8		ciss_report_log_flags;
+ 	u32		max_transfer_encrypted_sas_sata;
+ 	u32		max_transfer_encrypted_nvme;
+ 	u32		max_write_raid_5_6;
+ 	u32		max_write_raid_1_10_2drive;
+ 	u32		max_write_raid_1_10_3drive;
++>>>>>>> f6cc2a774aa7 (scsi: smartpqi: Add support for BMIC sense feature cmd and feature bits)
  
  	struct list_head scsi_device_list;
  	spinlock_t	scsi_device_list_lock;
diff --cc drivers/scsi/smartpqi/smartpqi_init.c
index 15d4619f5e0b,82f75a6be71c..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@@ -2268,55 -2386,47 +2409,94 @@@ static inline void pqi_set_encryption_i
   * Attempt to perform RAID bypass mapping for a logical volume I/O.
   */
  
++<<<<<<< HEAD
++=======
+ static bool pqi_aio_raid_level_supported(struct pqi_ctrl_info *ctrl_info,
+ 	struct pqi_scsi_dev_raid_map_data *rmd)
+ {
+ 	bool is_supported = true;
+ 
+ 	switch (rmd->raid_level) {
+ 	case SA_RAID_0:
+ 		break;
+ 	case SA_RAID_1:
+ 		if (rmd->is_write && (!ctrl_info->enable_r1_writes ||
+ 			rmd->data_length > ctrl_info->max_write_raid_1_10_2drive))
+ 			is_supported = false;
+ 		break;
+ 	case SA_RAID_TRIPLE:
+ 		if (rmd->is_write && (!ctrl_info->enable_r1_writes ||
+ 			rmd->data_length > ctrl_info->max_write_raid_1_10_3drive))
+ 			is_supported = false;
+ 		break;
+ 	case SA_RAID_5:
+ 		if (rmd->is_write && (!ctrl_info->enable_r5_writes ||
+ 			rmd->data_length > ctrl_info->max_write_raid_5_6))
+ 			is_supported = false;
+ 		break;
+ 	case SA_RAID_6:
+ 		if (rmd->is_write && (!ctrl_info->enable_r6_writes ||
+ 			rmd->data_length > ctrl_info->max_write_raid_5_6))
+ 			is_supported = false;
+ 		break;
+ 	default:
+ 		is_supported = false;
+ 		break;
+ 	}
+ 
+ 	return is_supported;
+ }
+ 
++>>>>>>> f6cc2a774aa7 (scsi: smartpqi: Add support for BMIC sense feature cmd and feature bits)
  #define PQI_RAID_BYPASS_INELIGIBLE	1
  
 -static int pqi_get_aio_lba_and_block_count(struct scsi_cmnd *scmd,
 -			struct pqi_scsi_dev_raid_map_data *rmd)
 +static int pqi_raid_bypass_submit_scsi_cmd(struct pqi_ctrl_info *ctrl_info,
 +	struct pqi_scsi_dev *device, struct scsi_cmnd *scmd,
 +	struct pqi_queue_group *queue_group)
  {
 +	struct raid_map *raid_map;
 +	bool is_write = false;
 +	u32 map_index;
 +	u64 first_block;
 +	u64 last_block;
 +	u32 block_cnt;
 +	u32 blocks_per_row;
 +	u64 first_row;
 +	u64 last_row;
 +	u32 first_row_offset;
 +	u32 last_row_offset;
 +	u32 first_column;
 +	u32 last_column;
 +	u64 r0_first_row;
 +	u64 r0_last_row;
 +	u32 r5or6_blocks_per_row;
 +	u64 r5or6_first_row;
 +	u64 r5or6_last_row;
 +	u32 r5or6_first_row_offset;
 +	u32 r5or6_last_row_offset;
 +	u32 r5or6_first_column;
 +	u32 r5or6_last_column;
 +	u16 data_disks_per_row;
 +	u32 total_disks_per_row;
 +	u16 layout_map_count;
 +	u32 stripesize;
 +	u16 strip_size;
 +	u32 first_group;
 +	u32 last_group;
 +	u32 current_group;
 +	u32 map_row;
 +	u32 aio_handle;
 +	u64 disk_block;
 +	u32 disk_block_cnt;
 +	u8 cdb[16];
 +	u8 cdb_length;
 +	int offload_to_mirror;
 +	struct pqi_encryption_info *encryption_info_ptr;
 +	struct pqi_encryption_info encryption_info;
 +#if BITS_PER_LONG == 32
 +	u64 tmpdiv;
 +#endif
 +
  	/* Check for valid opcode, get LBA and block count. */
  	switch (scmd->cmnd[0]) {
  	case WRITE_6:
@@@ -2557,43 -2763,42 +2737,64 @@@
  
  	/* Handle differing logical/physical block sizes. */
  	if (raid_map->phys_blk_shift) {
 -		rmd.disk_block <<= raid_map->phys_blk_shift;
 -		rmd.disk_block_cnt <<= raid_map->phys_blk_shift;
 +		disk_block <<= raid_map->phys_blk_shift;
 +		disk_block_cnt <<= raid_map->phys_blk_shift;
  	}
  
 -	if (unlikely(rmd.disk_block_cnt > 0xffff))
 +	if (unlikely(disk_block_cnt > 0xffff))
  		return PQI_RAID_BYPASS_INELIGIBLE;
  
 -	pqi_set_aio_cdb(&rmd);
 +	/* Build the new CDB for the physical disk I/O. */
 +	if (disk_block > 0xffffffff) {
 +		cdb[0] = is_write ? WRITE_16 : READ_16;
 +		cdb[1] = 0;
 +		put_unaligned_be64(disk_block, &cdb[2]);
 +		put_unaligned_be32(disk_block_cnt, &cdb[10]);
 +		cdb[14] = 0;
 +		cdb[15] = 0;
 +		cdb_length = 16;
 +	} else {
 +		cdb[0] = is_write ? WRITE_10 : READ_10;
 +		cdb[1] = 0;
 +		put_unaligned_be32((u32)disk_block, &cdb[2]);
 +		cdb[6] = 0;
 +		put_unaligned_be16((u16)disk_block_cnt, &cdb[7]);
 +		cdb[9] = 0;
 +		cdb_length = 10;
 +	}
  
  	if (get_unaligned_le16(&raid_map->flags) &
- 		RAID_MAP_ENCRYPTION_ENABLED) {
+ 			RAID_MAP_ENCRYPTION_ENABLED) {
+ 		if (rmd.data_length > device->max_transfer_encrypted)
+ 			return PQI_RAID_BYPASS_INELIGIBLE;
  		pqi_set_encryption_info(&encryption_info, raid_map,
 -			rmd.first_block);
 +			first_block);
  		encryption_info_ptr = &encryption_info;
  	} else {
  		encryption_info_ptr = NULL;
  	}
  
++<<<<<<< HEAD
 +	return pqi_aio_submit_io(ctrl_info, scmd, aio_handle,
 +		cdb, cdb_length, queue_group, encryption_info_ptr, true);
++=======
+ 	if (rmd.is_write) {
+ 		switch (device->raid_level) {
+ 		case SA_RAID_1:
+ 		case SA_RAID_TRIPLE:
+ 			return pqi_aio_submit_r1_write_io(ctrl_info, scmd, queue_group,
+ 				encryption_info_ptr, device, &rmd);
+ 		case SA_RAID_5:
+ 		case SA_RAID_6:
+ 			return pqi_aio_submit_r56_write_io(ctrl_info, scmd, queue_group,
+ 					encryption_info_ptr, device, &rmd);
+ 		}
+ 	}
+ 
+ 	return pqi_aio_submit_io(ctrl_info, scmd, rmd.aio_handle,
+ 		rmd.cdb, rmd.cdb_length, queue_group,
+ 		encryption_info_ptr, true);
++>>>>>>> f6cc2a774aa7 (scsi: smartpqi: Add support for BMIC sense feature cmd and feature bits)
  }
  
  #define PQI_STATUS_IDLE		0x0
* Unmerged path drivers/scsi/smartpqi/smartpqi.h
* Unmerged path drivers/scsi/smartpqi/smartpqi_init.c
