mt76: mt7615: fix hardware error recovery for mt7663

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Felix Fietkau <nbd@nbd.name>
commit 453873637b85b413456fb6257df336940b1d598a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/45387363.failed

MT7663 uses different bits for communicating reset commands/status between MCU
and host. Also add an extra initial reset command.

	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 453873637b85b413456fb6257df336940b1d598a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7615/dma.c
#	drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/dma.c
index 847ccaa0296f,642b4eab0d8b..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/dma.c
@@@ -176,6 -176,25 +176,28 @@@ static void mt7663_dma_sched_init(struc
  	mt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_SCHED_SET1), 0xedcba987);
  }
  
++<<<<<<< HEAD
++=======
+ void mt7615_dma_start(struct mt7615_dev *dev)
+ {
+ 	/* start dma engine */
+ 	mt76_set(dev, MT_WPDMA_GLO_CFG,
+ 		 MT_WPDMA_GLO_CFG_TX_DMA_EN |
+ 		 MT_WPDMA_GLO_CFG_RX_DMA_EN |
+ 		 MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);
+ 
+ 	if (is_mt7622(&dev->mt76))
+ 		mt7622_dma_sched_init(dev);
+ 
+ 	if (is_mt7663(&dev->mt76)) {
+ 		mt7663_dma_sched_init(dev);
+ 
+ 		mt76_wr(dev, MT_MCU2HOST_INT_ENABLE, MT7663_MCU_CMD_ERROR_MASK);
+ 	}
+ 
+ }
+ 
++>>>>>>> 453873637b85 (mt76: mt7615: fix hardware error recovery for mt7663)
  int mt7615_dma_init(struct mt7615_dev *dev)
  {
  	int rx_ring_size = MT7615_RX_RING_SIZE;
@@@ -253,20 -273,17 +276,26 @@@
  		  MT_WPDMA_GLO_CFG_TX_DMA_BUSY |
  		  MT_WPDMA_GLO_CFG_RX_DMA_BUSY, 0, 1000);
  
 +	/* start dma engine */
 +	mt76_set(dev, MT_WPDMA_GLO_CFG,
 +		 MT_WPDMA_GLO_CFG_TX_DMA_EN |
 +		 MT_WPDMA_GLO_CFG_RX_DMA_EN);
 +
  	/* enable interrupts for TX/RX rings */
- 	mt7615_irq_enable(dev, MT_INT_RX_DONE_ALL | mt7615_tx_mcu_int_mask(dev) |
- 			       MT_INT_MCU_CMD);
+ 
+ 	mask = MT_INT_RX_DONE_ALL | mt7615_tx_mcu_int_mask(dev);
+ 	if (is_mt7663(&dev->mt76))
+ 	    mask |= MT7663_INT_MCU_CMD;
+ 	else
+ 	    mask |= MT_INT_MCU_CMD;
+ 
+ 	mt7615_irq_enable(dev, mask);
  
 -	mt7615_dma_start(dev);
 +	if (is_mt7622(&dev->mt76))
 +		mt7622_dma_sched_init(dev);
 +
 +	if (is_mt7663(&dev->mt76))
 +		mt7663_dma_sched_init(dev);
  
  	return 0;
  }
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
index 4cf7c5d34325,d20962cdecc8..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
@@@ -181,3 -181,178 +181,181 @@@ int mt7615_tx_prepare_skb(struct mt76_d
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ void mt7615_dma_reset(struct mt7615_dev *dev)
+ {
+ 	int i;
+ 
+ 	mt76_clear(dev, MT_WPDMA_GLO_CFG,
+ 		   MT_WPDMA_GLO_CFG_RX_DMA_EN | MT_WPDMA_GLO_CFG_TX_DMA_EN |
+ 		   MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);
+ 
+ 	usleep_range(1000, 2000);
+ 
+ 	for (i = 0; i < __MT_TXQ_MAX; i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);
+ 
+ 	for (i = 0; i < __MT_MCUQ_MAX; i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i)
+ 		mt76_queue_rx_reset(dev, i);
+ 
+ 	mt76_tx_status_check(&dev->mt76, NULL, true);
+ 
+ 	mt7615_dma_start(dev);
+ }
+ EXPORT_SYMBOL_GPL(mt7615_dma_reset);
+ 
+ static void
+ mt7615_hif_int_event_trigger(struct mt7615_dev *dev, u8 event)
+ {
+ 	u32 reg = MT_MCU_INT_EVENT;
+ 
+ 	if (is_mt7663(&dev->mt76))
+ 		reg = MT7663_MCU_INT_EVENT;
+ 
+ 	mt76_wr(dev, reg, event);
+ 
+ 	mt7622_trigger_hif_int(dev, true);
+ 	mt7622_trigger_hif_int(dev, false);
+ }
+ 
+ static bool
+ mt7615_wait_reset_state(struct mt7615_dev *dev, u32 state)
+ {
+ 	bool ret;
+ 
+ 	ret = wait_event_timeout(dev->reset_wait,
+ 				 (READ_ONCE(dev->reset_state) & state),
+ 				 MT7615_RESET_TIMEOUT);
+ 	WARN(!ret, "Timeout waiting for MCU reset state %x\n", state);
+ 	return ret;
+ }
+ 
+ static void
+ mt7615_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)
+ {
+ 	struct ieee80211_hw *hw = priv;
+ 	struct mt7615_dev *dev = mt7615_hw_dev(hw);
+ 
+ 	switch (vif->type) {
+ 	case NL80211_IFTYPE_MESH_POINT:
+ 	case NL80211_IFTYPE_ADHOC:
+ 	case NL80211_IFTYPE_AP:
+ 		mt7615_mcu_add_beacon(dev, hw, vif,
+ 				      vif->bss_conf.enable_beacon);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void
+ mt7615_update_beacons(struct mt7615_dev *dev)
+ {
+ 	ieee80211_iterate_active_interfaces(dev->mt76.hw,
+ 		IEEE80211_IFACE_ITER_RESUME_ALL,
+ 		mt7615_update_vif_beacon, dev->mt76.hw);
+ 
+ 	if (!dev->mt76.phy2)
+ 		return;
+ 
+ 	ieee80211_iterate_active_interfaces(dev->mt76.phy2->hw,
+ 		IEEE80211_IFACE_ITER_RESUME_ALL,
+ 		mt7615_update_vif_beacon, dev->mt76.phy2->hw);
+ }
+ 
+ void mt7615_mac_reset_work(struct work_struct *work)
+ {
+ 	struct mt7615_phy *phy2;
+ 	struct mt76_phy *ext_phy;
+ 	struct mt7615_dev *dev;
+ 
+ 	dev = container_of(work, struct mt7615_dev, reset_work);
+ 	ext_phy = dev->mt76.phy2;
+ 	phy2 = ext_phy ? ext_phy->priv : NULL;
+ 
+ 	if (!(READ_ONCE(dev->reset_state) & MT_MCU_CMD_STOP_PDMA))
+ 		return;
+ 
+ 	ieee80211_stop_queues(mt76_hw(dev));
+ 	if (ext_phy)
+ 		ieee80211_stop_queues(ext_phy->hw);
+ 
+ 	set_bit(MT76_RESET, &dev->mphy.state);
+ 	set_bit(MT76_MCU_RESET, &dev->mphy.state);
+ 	wake_up(&dev->mt76.mcu.wait);
+ 	cancel_delayed_work_sync(&dev->mphy.mac_work);
+ 	del_timer_sync(&dev->phy.roc_timer);
+ 	cancel_work_sync(&dev->phy.roc_work);
+ 	if (phy2) {
+ 		set_bit(MT76_RESET, &phy2->mt76->state);
+ 		cancel_delayed_work_sync(&phy2->mt76->mac_work);
+ 		del_timer_sync(&phy2->roc_timer);
+ 		cancel_work_sync(&phy2->roc_work);
+ 	}
+ 
+ 	/* lock/unlock all queues to ensure that no tx is pending */
+ 	mt76_txq_schedule_all(&dev->mphy);
+ 	if (ext_phy)
+ 		mt76_txq_schedule_all(ext_phy);
+ 
+ 	mt76_worker_disable(&dev->mt76.tx_worker);
+ 	napi_disable(&dev->mt76.napi[0]);
+ 	napi_disable(&dev->mt76.napi[1]);
+ 	napi_disable(&dev->mt76.tx_napi);
+ 
+ 	mt7615_mutex_acquire(dev);
+ 
+ 	mt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_PDMA_STOPPED);
+ 
+ 	if (mt7615_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
+ 		mt7615_dma_reset(dev);
+ 
+ 		mt7615_tx_token_put(dev);
+ 		idr_init(&dev->token);
+ 
+ 		mt76_wr(dev, MT_WPDMA_MEM_RNG_ERR, 0);
+ 
+ 		mt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_PDMA_INIT);
+ 		mt7615_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
+ 	}
+ 
+ 	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
+ 	clear_bit(MT76_RESET, &dev->mphy.state);
+ 	if (phy2)
+ 		clear_bit(MT76_RESET, &phy2->mt76->state);
+ 
+ 	mt76_worker_enable(&dev->mt76.tx_worker);
+ 	napi_enable(&dev->mt76.tx_napi);
+ 	napi_schedule(&dev->mt76.tx_napi);
+ 
+ 	napi_enable(&dev->mt76.napi[0]);
+ 	napi_schedule(&dev->mt76.napi[0]);
+ 
+ 	napi_enable(&dev->mt76.napi[1]);
+ 	napi_schedule(&dev->mt76.napi[1]);
+ 
+ 	ieee80211_wake_queues(mt76_hw(dev));
+ 	if (ext_phy)
+ 		ieee80211_wake_queues(ext_phy->hw);
+ 
+ 	mt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_RESET_DONE);
+ 	mt7615_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);
+ 
+ 	mt7615_update_beacons(dev);
+ 
+ 	mt7615_mutex_release(dev);
+ 
+ 	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
+ 				     MT7615_WATCHDOG_TIME);
+ 	if (phy2)
+ 		ieee80211_queue_delayed_work(ext_phy->hw,
+ 					     &phy2->mt76->mac_work,
+ 					     MT7615_WATCHDOG_TIME);
+ 
+ }
++>>>>>>> 453873637b85 (mt76: mt7615: fix hardware error recovery for mt7663)
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/dma.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c b/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c
index d3267dcbc8f2..845a160ae3b7 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c
@@ -105,6 +105,7 @@ static void mt7615_irq_tasklet(unsigned long data)
 {
 	struct mt7615_dev *dev = (struct mt7615_dev *)data;
 	u32 intr, mask = 0, tx_mcu_mask = mt7615_tx_mcu_int_mask(dev);
+	u32 mcu_int;
 
 	mt76_wr(dev, MT_INT_MASK_CSR, 0);
 
@@ -128,15 +129,23 @@ static void mt7615_irq_tasklet(unsigned long data)
 	if (intr & MT_INT_RX_DONE(1))
 		napi_schedule(&dev->mt76.napi[1]);
 
-	if (intr & MT_INT_MCU_CMD) {
-		u32 val = mt76_rr(dev, MT_MCU_CMD);
+	if (!(intr & (MT_INT_MCU_CMD | MT7663_INT_MCU_CMD)))
+		return;
 
-		if (val & MT_MCU_CMD_ERROR_MASK) {
-			dev->reset_state = val;
-			ieee80211_queue_work(mt76_hw(dev), &dev->reset_work);
-			wake_up(&dev->reset_wait);
-		}
+	if (is_mt7663(&dev->mt76)) {
+		mcu_int = mt76_rr(dev, MT_MCU2HOST_INT_STATUS);
+		mcu_int &= MT7663_MCU_CMD_ERROR_MASK;
+	} else {
+		mcu_int = mt76_rr(dev, MT_MCU_CMD);
+		mcu_int &= MT_MCU_CMD_ERROR_MASK;
 	}
+
+	if (!mcu_int)
+		return;
+
+	dev->reset_state = mcu_int;
+	ieee80211_queue_work(mt76_hw(dev), &dev->reset_work);
+	wake_up(&dev->reset_wait);
 }
 
 static u32 __mt7615_reg_addr(struct mt7615_dev *dev, u32 addr)
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c b/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
index 15b417d6d889..371abc54a58b 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/pci_init.c
@@ -47,6 +47,12 @@ static int mt7615_init_hardware(struct mt7615_dev *dev)
 	if (ret < 0)
 		return ret;
 
+	if (is_mt7663(&dev->mt76)) {
+		/* Reset RGU */
+		mt76_clear(dev, MT_MCU_CIRQ_IRQ_SEL(4), BIT(1));
+		mt76_set(dev, MT_MCU_CIRQ_IRQ_SEL(4), BIT(1));
+	}
+
 	ret = mt7615_dma_init(dev);
 	if (ret)
 		return ret;
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/regs.h b/drivers/net/wireless/mediatek/mt76/mt7615/regs.h
index 3f6a5d5101ca..247870249cb1 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/regs.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/regs.h
@@ -61,6 +61,11 @@ enum mt7615_reg_base {
 #define MT_MCU_PCIE_REMAP_2_BASE	GENMASK(31, 19)
 #define MT_PCIE_REMAP_BASE_2		((dev)->reg_map[MT_PCIE_REMAP_BASE2])
 
+#define MT_MCU_CIRQ_BASE		0xc0000
+#define MT_MCU_CIRQ(ofs)		(MT_MCU_CIRQ_BASE + (ofs))
+
+#define MT_MCU_CIRQ_IRQ_SEL(n)		MT_MCU_CIRQ((n) << 2)
+
 #define MT_HIF(ofs)			((dev)->reg_map[MT_HIF_BASE] + (ofs))
 #define MT_HIF_RST			MT_HIF(0x100)
 #define MT_HIF_LOGIC_RST_N		BIT(4)
@@ -88,6 +93,10 @@ enum mt7615_reg_base {
 #define MT_CFG_LPCR_HOST_FW_OWN		BIT(0)
 #define MT_CFG_LPCR_HOST_DRV_OWN	BIT(1)
 
+#define MT_MCU2HOST_INT_STATUS		MT_HIF(0x1f0)
+#define MT_MCU2HOST_INT_ENABLE		MT_HIF(0x1f4)
+
+#define MT7663_MCU_INT_EVENT		MT_HIF(0x108)
 #define MT_MCU_INT_EVENT		MT_HIF(0x1f8)
 #define MT_MCU_INT_EVENT_PDMA_STOPPED	BIT(0)
 #define MT_MCU_INT_EVENT_PDMA_INIT	BIT(1)
@@ -102,6 +111,7 @@ enum mt7615_reg_base {
 #define MT_INT_RX_DONE_ALL		GENMASK(1, 0)
 #define MT_INT_TX_DONE_ALL		GENMASK(19, 4)
 #define MT_INT_TX_DONE(_n)		BIT((_n) + 4)
+#define MT7663_INT_MCU_CMD		BIT(29)
 #define MT_INT_MCU_CMD			BIT(30)
 
 #define MT_WPDMA_GLO_CFG		MT_HIF(0x208)
@@ -138,6 +148,7 @@ enum mt7615_reg_base {
 #define MT_MCU_CMD_PDMA_ERROR		BIT(27)
 #define MT_MCU_CMD_PCIE_ERROR		BIT(28)
 #define MT_MCU_CMD_ERROR_MASK		(GENMASK(5, 1) | GENMASK(28, 24))
+#define MT7663_MCU_CMD_ERROR_MASK	GENMASK(5, 2)
 
 #define MT_TX_RING_BASE			MT_HIF(0x300)
 #define MT_RX_RING_BASE			MT_HIF(0x400)
