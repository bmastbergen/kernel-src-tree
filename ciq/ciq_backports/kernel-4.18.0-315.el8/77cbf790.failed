nl80211: fix locking for wireless device netns change

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 77cbf790e5b482256662e14c8b6ef4fecb07d06d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/77cbf790.failed

We have all the network interfaces marked as netns-local
since the only reasonable thing to do right now is to set
a whole device, including all netdevs, into a different
network namespace. For this reason, we also have our own
way of changing the network namespace.

Unfortunately, the RTNL locking changes broke this, and
it now results in many RTNL assertions. The trivial fix
for those (just hold RTNL for the changes) however leads
to deadlocks in the cfg80211 netdev notifier.

Since we only need the wiphy, and that's still protected
by the RTNL, add a new NL80211_FLAG_NO_WIPHY_MTX flag to
the nl80211 ops and use it to _not_ take the wiphy mutex
but only the RTNL. This way, the notifier does all the
work necessary during unregistration/registration of the
netdevs from the old and in the new namespace.

	Reported-by: Sid Hayn <sidhayn@gmail.com>
Fixes: a05829a7222e ("cfg80211: avoid holding the RTNL when calling the driver")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
Link: https://lore.kernel.org/r/20210310215839.eadf7c43781b.I5fc6cf6676f800ab8008e03bbea9c3349b02d804@changeid
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 77cbf790e5b482256662e14c8b6ef4fecb07d06d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/nl80211.c
diff --cc net/wireless/nl80211.c
index 6ff26d687322,ae6097fff133..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -14493,6 -14841,14 +14494,17 @@@ static int nl80211_pre_doit(const struc
  		info->user_ptr[0] = rdev;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (rdev && !(ops->internal_flags & NL80211_FLAG_NO_WIPHY_MTX)) {
+ 		wiphy_lock(&rdev->wiphy);
+ 		/* we keep the mutex locked until post_doit */
+ 		__release(&rdev->wiphy.mtx);
+ 	}
+ 	if (!(ops->internal_flags & NL80211_FLAG_NEED_RTNL))
+ 		rtnl_unlock();
+ 
++>>>>>>> 77cbf790e5b4 (nl80211: fix locking for wireless device netns change)
  	return 0;
  }
  
@@@ -14510,6 -14866,15 +14522,18 @@@ static void nl80211_post_doit(const str
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (info->user_ptr[0] &&
+ 	    !(ops->internal_flags & NL80211_FLAG_NO_WIPHY_MTX)) {
+ 		struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 
+ 		/* we kept the mutex locked since pre_doit */
+ 		__acquire(&rdev->wiphy.mtx);
+ 		wiphy_unlock(&rdev->wiphy);
+ 	}
+ 
++>>>>>>> 77cbf790e5b4 (nl80211: fix locking for wireless device netns change)
  	if (ops->internal_flags & NL80211_FLAG_NEED_RTNL)
  		rtnl_unlock();
  
@@@ -14894,7 -15332,8 +14918,12 @@@ static const struct genl_small_ops nl80
  		.doit = nl80211_wiphy_netns,
  		.flags = GENL_UNS_ADMIN_PERM,
  		.internal_flags = NL80211_FLAG_NEED_WIPHY |
++<<<<<<< HEAD
 +				  NL80211_FLAG_NEED_RTNL,
++=======
+ 				  NL80211_FLAG_NEED_RTNL |
+ 				  NL80211_FLAG_NO_WIPHY_MTX,
++>>>>>>> 77cbf790e5b4 (nl80211: fix locking for wireless device netns change)
  	},
  	{
  		.cmd = NL80211_CMD_GET_SURVEY,
* Unmerged path net/wireless/nl80211.c
