mt76: mt7915: fix memleak when mt7915_unregister_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Ryder Lee <ryder.lee@mediatek.com>
commit e9d32af478cfc3744a45245c0b126738af4b3ac4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/e9d32af4.failed

mt7915_tx_token_put() should get call before mt76_free_pending_txwi().

Fixes: f285dfb98562 ("mt76: mt7915: reset token when mac_reset happens")
	Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit e9d32af478cfc3744a45245c0b126738af4b3ac4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7915/init.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/init.c
index 49c09d0d8906,d242e186424d..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
@@@ -697,22 -740,8 +697,27 @@@ void mt7915_unregister_device(struct mt
  	mt7915_unregister_ext_phy(dev);
  	mt76_unregister_device(&dev->mt76);
  	mt7915_mcu_exit(dev);
++<<<<<<< HEAD
 +	mt7915_dma_cleanup(dev);
 +
 +	spin_lock_bh(&dev->token_lock);
 +	idr_for_each_entry(&dev->token, txwi, id) {
 +		mt7915_txp_skb_unmap(&dev->mt76, txwi);
 +		if (txwi->skb) {
 +			struct ieee80211_hw *hw;
 +
 +			hw = mt76_tx_status_get_hw(&dev->mt76, txwi->skb);
 +			ieee80211_free_txskb(hw, txwi->skb);
 +		}
 +		mt76_put_txwi(&dev->mt76, txwi);
 +		dev->token_count--;
 +	}
 +	spin_unlock_bh(&dev->token_lock);
 +	idr_destroy(&dev->token);
++=======
+ 	mt7915_tx_token_put(dev);
+ 	mt7915_dma_cleanup(dev);
++>>>>>>> e9d32af478cf (mt76: mt7915: fix memleak when mt7915_unregister_device())
  
  	mt76_free_device(&dev->mt76);
  }
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/init.c
