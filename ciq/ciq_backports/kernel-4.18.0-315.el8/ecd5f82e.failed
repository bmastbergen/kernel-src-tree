LSM: Infrastructure management of the ipc security blob

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Casey Schaufler <casey@schaufler-ca.com>
commit ecd5f82e05ddd9b06c258167ec7467ac79741d77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/ecd5f82e.failed

Move management of the kern_ipc_perm->security and
msg_msg->security blobs out of the individual security
modules and into the security infrastructure. Instead
of allocating the blobs from within the modules the modules
tell the infrastructure how much space is required, and
the space is allocated there.

	Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
[kees: adjusted for ordered init series]
	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit ecd5f82e05ddd9b06c258167ec7467ac79741d77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/lsm_hooks.h
#	security/security.c
#	security/selinux/hooks.c
#	security/smack/smack.h
#	security/smack/smack_lsm.c
diff --cc include/linux/lsm_hooks.h
index 84380f3a8dab,40511a8a5ae6..000000000000
--- a/include/linux/lsm_hooks.h
+++ b/include/linux/lsm_hooks.h
@@@ -1479,10 -2028,16 +1479,21 @@@ struct security_hook_list 
  } __randomize_layout;
  
  /*
 - * Security blob size or offset data.
 + * LSM_RET_VOID is used as the default value in LSM_HOOK definitions for void
 + * LSM hooks (in include/linux/lsm_hook_defs.h).
   */
++<<<<<<< HEAD
 +#define LSM_RET_VOID ((void) 0)
++=======
+ struct lsm_blob_sizes {
+ 	int	lbs_cred;
+ 	int	lbs_file;
+ 	int	lbs_inode;
+ 	int	lbs_ipc;
+ 	int	lbs_msg_msg;
+ 	int	lbs_task;
+ };
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  
  /*
   * Initializing a security_hook_list structure takes
diff --cc security/security.c
index 8555aece1bce,953fc3ea18a9..000000000000
--- a/security/security.c
+++ b/security/security.c
@@@ -30,11 -30,9 +30,12 @@@
  #include <linux/personality.h>
  #include <linux/backing-dev.h>
  #include <linux/string.h>
+ #include <linux/msg.h>
  #include <net/flow.h>
  
 +/* RHEL8-only: work around a KABI false positive */
 +#include RH_KABI_FAKE_INCLUDE(<trace/events/initcall.h>)
 +
  #define MAX_LSM_EVM_XATTR	2
  
  /* How many LSMs were built into the kernel? */
@@@ -142,6 -145,36 +143,39 @@@ static bool __init lsm_allowed(struct l
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static void __init lsm_set_blob_size(int *need, int *lbs)
+ {
+ 	int offset;
+ 
+ 	if (*need > 0) {
+ 		offset = *lbs;
+ 		*lbs += *need;
+ 		*need = offset;
+ 	}
+ }
+ 
+ static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
+ {
+ 	if (!needed)
+ 		return;
+ 
+ 	lsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);
+ 	lsm_set_blob_size(&needed->lbs_file, &blob_sizes.lbs_file);
+ 	/*
+ 	 * The inode blob gets an rcu_head in addition to
+ 	 * what the modules might need.
+ 	 */
+ 	if (needed->lbs_inode && blob_sizes.lbs_inode == 0)
+ 		blob_sizes.lbs_inode = sizeof(struct rcu_head);
+ 	lsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);
+ 	lsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);
+ 	lsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);
+ 	lsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);
+ }
+ 
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  /* Prepare LSM for initialization. */
  static void __init prepare_lsm(struct lsm_info *lsm)
  {
@@@ -262,6 -293,25 +296,28 @@@ static void __init ordered_lsm_init(voi
  	for (lsm = ordered_lsms; *lsm; lsm++)
  		prepare_lsm(*lsm);
  
++<<<<<<< HEAD
++=======
+ 	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
+ 	init_debug("file blob size     = %d\n", blob_sizes.lbs_file);
+ 	init_debug("inode blob size    = %d\n", blob_sizes.lbs_inode);
+ 	init_debug("ipc blob size      = %d\n", blob_sizes.lbs_ipc);
+ 	init_debug("msg_msg blob size  = %d\n", blob_sizes.lbs_msg_msg);
+ 	init_debug("task blob size     = %d\n", blob_sizes.lbs_task);
+ 
+ 	/*
+ 	 * Create any kmem_caches needed for blobs
+ 	 */
+ 	if (blob_sizes.lbs_file)
+ 		lsm_file_cache = kmem_cache_create("lsm_file_cache",
+ 						   blob_sizes.lbs_file, 0,
+ 						   SLAB_PANIC, NULL);
+ 	if (blob_sizes.lbs_inode)
+ 		lsm_inode_cache = kmem_cache_create("lsm_inode_cache",
+ 						    blob_sizes.lbs_inode, 0,
+ 						    SLAB_PANIC, NULL);
+ 
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  	for (lsm = ordered_lsms; *lsm; lsm++)
  		initialize_lsm(*lsm);
  
@@@ -371,45 -421,188 +427,196 @@@ void __init security_add_hooks(struct s
  		panic("%s - Cannot get early memory.\n", __func__);
  }
  
 -int call_lsm_notifier(enum lsm_event event, void *data)
 +int call_blocking_lsm_notifier(enum lsm_event event, void *data)
  {
 -	return atomic_notifier_call_chain(&lsm_notifier_chain, event, data);
 +	return blocking_notifier_call_chain(&blocking_lsm_notifier_chain,
 +					    event, data);
  }
 -EXPORT_SYMBOL(call_lsm_notifier);
 +EXPORT_SYMBOL(call_blocking_lsm_notifier);
  
 -int register_lsm_notifier(struct notifier_block *nb)
 +int register_blocking_lsm_notifier(struct notifier_block *nb)
  {
 -	return atomic_notifier_chain_register(&lsm_notifier_chain, nb);
 +	return blocking_notifier_chain_register(&blocking_lsm_notifier_chain,
 +						nb);
  }
 -EXPORT_SYMBOL(register_lsm_notifier);
 +EXPORT_SYMBOL(register_blocking_lsm_notifier);
  
 -int unregister_lsm_notifier(struct notifier_block *nb)
 +int unregister_blocking_lsm_notifier(struct notifier_block *nb)
  {
 -	return atomic_notifier_chain_unregister(&lsm_notifier_chain, nb);
 +	return blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,
 +						  nb);
  }
 -EXPORT_SYMBOL(unregister_lsm_notifier);
 +EXPORT_SYMBOL(unregister_blocking_lsm_notifier);
  
 -/**
 - * lsm_cred_alloc - allocate a composite cred blob
 - * @cred: the cred that needs a blob
 - * @gfp: allocation type
 +/*
 + * The default value of the LSM hook is defined in linux/lsm_hook_defs.h and
 + * can be accessed with:
   *
 - * Allocate the cred blob for all the modules
 + *	LSM_RET_DEFAULT(<hook_name>)
   *
 - * Returns 0, or -ENOMEM if memory can't be allocated.
 + * The macros below define static constants for the default value of each
 + * LSM hook.
   */
 -static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)
 -{
 -	if (blob_sizes.lbs_cred == 0) {
 -		cred->security = NULL;
 -		return 0;
 -	}
 -
 +#define LSM_RET_DEFAULT(NAME) (NAME##_default)
 +#define DECLARE_LSM_RET_DEFAULT_void(DEFAULT, NAME)
 +#define DECLARE_LSM_RET_DEFAULT_int(DEFAULT, NAME) \
 +	static const int LSM_RET_DEFAULT(NAME) = (DEFAULT);
 +#define LSM_HOOK(RET, DEFAULT, NAME, ...) \
 +	DECLARE_LSM_RET_DEFAULT_##RET(DEFAULT, NAME)
 +
++<<<<<<< HEAD
 +#include <linux/lsm_hook_defs.h>
 +#undef LSM_HOOK
++=======
+ 	cred->security = kzalloc(blob_sizes.lbs_cred, gfp);
+ 	if (cred->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_early_cred - during initialization allocate a composite cred blob
+  * @cred: the cred that needs a blob
+  *
+  * Allocate the cred blob for all the modules if it's not already there
+  */
+ void __init lsm_early_cred(struct cred *cred)
+ {
+ 	int rc;
+ 
+ 	if (cred == NULL)
+ 		panic("%s: NULL cred.\n", __func__);
+ 	if (cred->security != NULL)
+ 		return;
+ 	rc = lsm_cred_alloc(cred, GFP_KERNEL);
+ 	if (rc)
+ 		panic("%s: Early cred alloc failed.\n", __func__);
+ }
+ 
+ /**
+  * lsm_file_alloc - allocate a composite file blob
+  * @file: the file that needs a blob
+  *
+  * Allocate the file blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ static int lsm_file_alloc(struct file *file)
+ {
+ 	if (!lsm_file_cache) {
+ 		file->f_security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	file->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);
+ 	if (file->f_security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_inode_alloc - allocate a composite inode blob
+  * @inode: the inode that needs a blob
+  *
+  * Allocate the inode blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_inode_alloc(struct inode *inode)
+ {
+ 	if (!lsm_inode_cache) {
+ 		inode->i_security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	inode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);
+ 	if (inode->i_security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_task_alloc - allocate a composite task blob
+  * @task: the task that needs a blob
+  *
+  * Allocate the task blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_task_alloc(struct task_struct *task)
+ {
+ 	if (blob_sizes.lbs_task == 0) {
+ 		task->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	task->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);
+ 	if (task->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_ipc_alloc - allocate a composite ipc blob
+  * @kip: the ipc that needs a blob
+  *
+  * Allocate the ipc blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_ipc_alloc(struct kern_ipc_perm *kip)
+ {
+ 	if (blob_sizes.lbs_ipc == 0) {
+ 		kip->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	kip->security = kzalloc(blob_sizes.lbs_ipc, GFP_KERNEL);
+ 	if (kip->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_msg_msg_alloc - allocate a composite msg_msg blob
+  * @mp: the msg_msg that needs a blob
+  *
+  * Allocate the ipc blob for all the modules
+  *
+  * Returns 0, or -ENOMEM if memory can't be allocated.
+  */
+ int lsm_msg_msg_alloc(struct msg_msg *mp)
+ {
+ 	if (blob_sizes.lbs_msg_msg == 0) {
+ 		mp->security = NULL;
+ 		return 0;
+ 	}
+ 
+ 	mp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);
+ 	if (mp->security == NULL)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ /**
+  * lsm_early_task - during initialization allocate a composite task blob
+  * @task: the task that needs a blob
+  *
+  * Allocate the task blob for all the modules if it's not already there
+  */
+ void __init lsm_early_task(struct task_struct *task)
+ {
+ 	int rc;
+ 
+ 	if (task == NULL)
+ 		panic("%s: task cred.\n", __func__);
+ 	if (task->security != NULL)
+ 		return;
+ 	rc = lsm_task_alloc(task);
+ 	if (rc)
+ 		panic("%s: Early task alloc failed.\n", __func__);
+ }
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  
  /*
   * Hook list operation macros.
diff --cc security/selinux/hooks.c
index 02238a76d816,d98e1d8d18f6..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -5963,83 -5623,13 +5963,66 @@@ static unsigned int selinux_ipv6_postro
  
  static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)
  {
 -	return selinux_nlmsg_perm(sk, skb);
 +	int rc = 0;
 +	unsigned int msg_len;
 +	unsigned int data_len = skb->len;
 +	unsigned char *data = skb->data;
 +	struct nlmsghdr *nlh;
 +	struct sk_security_struct *sksec = sk->sk_security;
 +	u16 sclass = sksec->sclass;
 +	u32 perm;
 +
 +	while (data_len >= nlmsg_total_size(0)) {
 +		nlh = (struct nlmsghdr *)data;
 +
 +		/* NOTE: the nlmsg_len field isn't reliably set by some netlink
 +		 *       users which means we can't reject skb's with bogus
 +		 *       length fields; our solution is to follow what
 +		 *       netlink_rcv_skb() does and simply skip processing at
 +		 *       messages with length fields that are clearly junk
 +		 */
 +		if (nlh->nlmsg_len < NLMSG_HDRLEN || nlh->nlmsg_len > data_len)
 +			return 0;
 +
 +		rc = selinux_nlmsg_lookup(sclass, nlh->nlmsg_type, &perm);
 +		if (rc == 0) {
 +			rc = sock_has_perm(sk, perm);
 +			if (rc)
 +				return rc;
 +		} else if (rc == -EINVAL) {
 +			/* -EINVAL is a missing msg/perm mapping */
 +			pr_warn_ratelimited("SELinux: unrecognized netlink"
 +				" message: protocol=%hu nlmsg_type=%hu sclass=%s"
 +				" pid=%d comm=%s\n",
 +				sk->sk_protocol, nlh->nlmsg_type,
 +				secclass_map[sclass - 1].name,
 +				task_pid_nr(current), current->comm);
 +			if (enforcing_enabled(&selinux_state) &&
 +			    !security_get_allow_unknown(&selinux_state))
 +				return rc;
 +			rc = 0;
 +		} else if (rc == -ENOENT) {
 +			/* -ENOENT is a missing socket/class mapping, ignore */
 +			rc = 0;
 +		} else {
 +			return rc;
 +		}
 +
 +		/* move to the next message after applying netlink padding */
 +		msg_len = NLMSG_ALIGN(nlh->nlmsg_len);
 +		if (msg_len >= data_len)
 +			return 0;
 +		data_len -= msg_len;
 +		data += msg_len;
 +	}
 +
 +	return rc;
  }
  
- static int ipc_alloc_security(struct kern_ipc_perm *perm,
- 			      u16 sclass)
+ static void ipc_init_security(struct ipc_security_struct *isec, u16 sclass)
  {
- 	struct ipc_security_struct *isec;
- 
- 	isec = kzalloc(sizeof(struct ipc_security_struct), GFP_KERNEL);
- 	if (!isec)
- 		return -ENOMEM;
- 
  	isec->sclass = sclass;
  	isec->sid = current_sid();
- 	perm->security = isec;
- 
- 	return 0;
- }
- 
- static void ipc_free_security(struct kern_ipc_perm *perm)
- {
- 	struct ipc_security_struct *isec = perm->security;
- 	perm->security = NULL;
- 	kfree(isec);
  }
  
  static int msg_msg_alloc_security(struct msg_msg *msg)
@@@ -7000,82 -6533,13 +6930,92 @@@ static void selinux_bpf_prog_free(struc
  }
  #endif
  
++<<<<<<< HEAD
 +/*
 + * IMPORTANT NOTE: When adding new hooks, please be careful to keep this order:
 + * 1. any hooks that don't belong to (2.) or (3.) below,
 + * 2. hooks that both access structures allocated by other hooks, and allocate
 + *    structures that can be later accessed by other hooks (mostly "cloning"
 + *    hooks),
 + * 3. hooks that only allocate structures that can be later accessed by other
 + *    hooks ("allocating" hooks).
 + *
 + * Please follow block comment delimiters in the list to keep this order.
 + *
 + * This ordering is needed for SELinux runtime disable to work at least somewhat
 + * safely. Breaking the ordering rules above might lead to NULL pointer derefs
 + * when disabling SELinux at runtime.
 + */
 +
 +#ifdef CONFIG_PERF_EVENTS
 +static int selinux_perf_event_open(struct perf_event_attr *attr, int type)
 +{
 +	u32 requested, sid = current_sid();
 +
 +	if (type == PERF_SECURITY_OPEN)
 +		requested = PERF_EVENT__OPEN;
 +	else if (type == PERF_SECURITY_CPU)
 +		requested = PERF_EVENT__CPU;
 +	else if (type == PERF_SECURITY_KERNEL)
 +		requested = PERF_EVENT__KERNEL;
 +	else if (type == PERF_SECURITY_TRACEPOINT)
 +		requested = PERF_EVENT__TRACEPOINT;
 +	else
 +		return -EINVAL;
 +
 +	return avc_has_perm(&selinux_state, sid, sid, SECCLASS_PERF_EVENT,
 +			    requested, NULL);
 +}
 +
 +static int selinux_perf_event_alloc(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec;
 +
 +	perfsec = kzalloc(sizeof(*perfsec), GFP_KERNEL);
 +	if (!perfsec)
 +		return -ENOMEM;
 +
 +	perfsec->sid = current_sid();
 +	event->security = perfsec;
 +
 +	return 0;
 +}
 +
 +static void selinux_perf_event_free(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +
 +	event->security = NULL;
 +	kfree(perfsec);
 +}
 +
 +static int selinux_perf_event_read(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +	u32 sid = current_sid();
 +
 +	return avc_has_perm(&selinux_state, sid, perfsec->sid,
 +			    SECCLASS_PERF_EVENT, PERF_EVENT__READ, NULL);
 +}
 +
 +static int selinux_perf_event_write(struct perf_event *event)
 +{
 +	struct perf_event_security_struct *perfsec = event->security;
 +	u32 sid = current_sid();
 +
 +	return avc_has_perm(&selinux_state, sid, perfsec->sid,
 +			    SECCLASS_PERF_EVENT, PERF_EVENT__WRITE, NULL);
 +}
 +#endif
++=======
+ struct lsm_blob_sizes selinux_blob_sizes __lsm_ro_after_init = {
+ 	.lbs_cred = sizeof(struct task_security_struct),
+ 	.lbs_file = sizeof(struct file_security_struct),
+ 	.lbs_inode = sizeof(struct inode_security_struct),
+ 	.lbs_ipc = sizeof(struct ipc_security_struct),
+ 	.lbs_msg_msg = sizeof(struct msg_security_struct),
+ };
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  
  static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {
  	LSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),
@@@ -7188,20 -6649,21 +7128,35 @@@
  	LSM_HOOK_INIT(ipc_permission, selinux_ipc_permission),
  	LSM_HOOK_INIT(ipc_getsecid, selinux_ipc_getsecid),
  
++<<<<<<< HEAD
 +	LSM_HOOK_INIT(msg_msg_free_security, selinux_msg_msg_free_security),
 +
 +	LSM_HOOK_INIT(msg_queue_free_security, selinux_msg_queue_free_security),
++=======
+ 	LSM_HOOK_INIT(msg_msg_alloc_security, selinux_msg_msg_alloc_security),
+ 
+ 	LSM_HOOK_INIT(msg_queue_alloc_security,
+ 			selinux_msg_queue_alloc_security),
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  	LSM_HOOK_INIT(msg_queue_associate, selinux_msg_queue_associate),
  	LSM_HOOK_INIT(msg_queue_msgctl, selinux_msg_queue_msgctl),
  	LSM_HOOK_INIT(msg_queue_msgsnd, selinux_msg_queue_msgsnd),
  	LSM_HOOK_INIT(msg_queue_msgrcv, selinux_msg_queue_msgrcv),
  
++<<<<<<< HEAD
 +	LSM_HOOK_INIT(shm_free_security, selinux_shm_free_security),
++=======
+ 	LSM_HOOK_INIT(shm_alloc_security, selinux_shm_alloc_security),
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  	LSM_HOOK_INIT(shm_associate, selinux_shm_associate),
  	LSM_HOOK_INIT(shm_shmctl, selinux_shm_shmctl),
  	LSM_HOOK_INIT(shm_shmat, selinux_shm_shmat),
  
++<<<<<<< HEAD
 +	LSM_HOOK_INIT(sem_free_security, selinux_sem_free_security),
++=======
+ 	LSM_HOOK_INIT(sem_alloc_security, selinux_sem_alloc_security),
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  	LSM_HOOK_INIT(sem_associate, selinux_sem_associate),
  	LSM_HOOK_INIT(sem_semctl, selinux_sem_semctl),
  	LSM_HOOK_INIT(sem_semop, selinux_sem_semop),
diff --cc security/smack/smack.h
index f7db791fb566,9c7c95a5c497..000000000000
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@@ -356,6 -358,32 +356,35 @@@ extern struct list_head smack_onlycap_l
  #define SMACK_HASH_SLOTS 16
  extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
  
++<<<<<<< HEAD
++=======
+ static inline struct task_smack *smack_cred(const struct cred *cred)
+ {
+ 	return cred->security + smack_blob_sizes.lbs_cred;
+ }
+ 
+ static inline struct smack_known **smack_file(const struct file *file)
+ {
+ 	return (struct smack_known **)(file->f_security +
+ 				       smack_blob_sizes.lbs_file);
+ }
+ 
+ static inline struct inode_smack *smack_inode(const struct inode *inode)
+ {
+ 	return inode->i_security + smack_blob_sizes.lbs_inode;
+ }
+ 
+ static inline struct smack_known **smack_msg_msg(const struct msg_msg *msg)
+ {
+ 	return msg->security + smack_blob_sizes.lbs_msg_msg;
+ }
+ 
+ static inline struct smack_known **smack_ipc(const struct kern_ipc_perm *ipc)
+ {
+ 	return ipc->security + smack_blob_sizes.lbs_ipc;
+ }
+ 
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  /*
   * Is the directory transmuting?
   */
diff --cc security/smack/smack_lsm.c
index 922e3ab09003,0b848b1f6366..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -4641,6 -4485,14 +4619,17 @@@ static int smack_dentry_create_files_as
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct lsm_blob_sizes smack_blob_sizes __lsm_ro_after_init = {
+ 	.lbs_cred = sizeof(struct task_smack),
+ 	.lbs_file = sizeof(struct smack_known *),
+ 	.lbs_inode = sizeof(struct inode_smack),
+ 	.lbs_ipc = sizeof(struct smack_known *),
+ 	.lbs_msg_msg = sizeof(struct smack_known *),
+ };
+ 
++>>>>>>> ecd5f82e05dd (LSM: Infrastructure management of the ipc security blob)
  static struct security_hook_list smack_hooks[] __lsm_ro_after_init = {
  	LSM_HOOK_INIT(ptrace_access_check, smack_ptrace_access_check),
  	LSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),
* Unmerged path include/linux/lsm_hooks.h
* Unmerged path security/security.c
* Unmerged path security/selinux/hooks.c
diff --git a/security/selinux/include/objsec.h b/security/selinux/include/objsec.h
index e4f7d53cbff2..6c7edde71310 100644
--- a/security/selinux/include/objsec.h
+++ b/security/selinux/include/objsec.h
@@ -172,13 +172,13 @@ static inline struct inode_security_struct *selinux_inode(
 static inline struct msg_security_struct *selinux_msg_msg(
 						const struct msg_msg *msg_msg)
 {
-	return msg_msg->security;
+	return msg_msg->security + selinux_blob_sizes.lbs_msg_msg;
 }
 
 static inline struct ipc_security_struct *selinux_ipc(
 						const struct kern_ipc_perm *ipc)
 {
-	return ipc->security;
+	return ipc->security + selinux_blob_sizes.lbs_ipc;
 }
 
 /*
* Unmerged path security/smack/smack.h
* Unmerged path security/smack/smack_lsm.c
