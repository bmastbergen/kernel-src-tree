libbpf: Deprecate notion of BPF program "title" in favor of "section name"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 52109584202783e90a83c95103307a9a03ba7d9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/52109584.failed

BPF program title is ambigious and misleading term. It is ELF section name, so
let's just call it that and deprecate bpf_program__title() API in favor of
bpf_program__section_name().

Additionally, using bpf_object__find_program_by_title() is now inherently
dangerous and ambiguous, as multiple BPF program can have the same section
name. So deprecate this API as well and recommend to switch to non-ambiguous
bpf_object__find_program_by_name().

Internally, clean up usage and mis-usage of BPF program section name for
denoting BPF program name. Shorten the field name to prog->sec_name to be
consistent with all other prog->sec_* variables.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200903203542.15944-11-andriin@fb.com
(cherry picked from commit 52109584202783e90a83c95103307a9a03ba7d9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.map
diff --cc tools/lib/bpf/libbpf.c
index 133c0050e689,47b43c13eee5..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -215,13 -216,30 +215,40 @@@ struct bpf_sec_def 
   * linux/filter.h.
   */
  struct bpf_program {
++<<<<<<< HEAD
 +	/* Index in elf obj file, for relocation use. */
 +	int idx;
 +	char *name;
 +	int prog_ifindex;
 +	char *section_name;
 +	const struct bpf_sec_def *sec_def;
 +	/* section_name with / replaced by _; makes recursive pinning
++=======
+ 	const struct bpf_sec_def *sec_def;
+ 	char *sec_name;
+ 	size_t sec_idx;
+ 	/* this program's instruction offset (in number of instructions)
+ 	 * within its containing ELF section
+ 	 */
+ 	size_t sec_insn_off;
+ 	/* number of original instructions in ELF section belonging to this
+ 	 * program, not taking into account subprogram instructions possible
+ 	 * appended later during relocation
+ 	 */
+ 	size_t sec_insn_cnt;
+ 	/* Offset (in number of instructions) of the start of instruction
+ 	 * belonging to this BPF program  within its containing main BPF
+ 	 * program. For the entry-point (main) BPF program, this is always
+ 	 * zero. For a sub-program, this gets reset before each of main BPF
+ 	 * programs are processed and relocated and is used to determined
+ 	 * whether sub-program was already appended to the main program, and
+ 	 * if yes, at which instruction offset.
+ 	 */
+ 	size_t sub_insn_off;
+ 
+ 	char *name;
+ 	/* sec_name with / replaced by _; makes recursive pinning
++>>>>>>> 521095842027 (libbpf: Deprecate notion of BPF program "title" in favor of "section name")
  	 * in bpf_object__pin_programs easier
  	 */
  	char *pin_name;
@@@ -538,8 -571,36 +565,38 @@@ bpf_program__init(void *data, size_t si
  	prog->type = BPF_PROG_TYPE_UNSPEC;
  	prog->load = true;
  
++<<<<<<< HEAD
++=======
+ 	prog->instances.fds = NULL;
+ 	prog->instances.nr = -1;
+ 
+ 	prog->sec_name = strdup(sec_name);
+ 	if (!prog->sec_name)
+ 		goto errout;
+ 
+ 	prog->name = strdup(name);
+ 	if (!prog->name)
+ 		goto errout;
+ 
+ 	prog->pin_name = __bpf_program__pin_name(prog);
+ 	if (!prog->pin_name)
+ 		goto errout;
+ 
+ 	prog->insns = malloc(insn_data_sz);
+ 	if (!prog->insns)
+ 		goto errout;
+ 	memcpy(prog->insns, insn_data, insn_data_sz);
+ 
+ 	for (i = 0; i < prog->insns_cnt; i++) {
+ 		if (insn_is_subprog_call(&prog->insns[i])) {
+ 			obj->has_subcalls = true;
+ 			break;
+ 		}
+ 	}
+ 
++>>>>>>> 521095842027 (libbpf: Deprecate notion of BPF program "title" in favor of "section name")
  	return 0;
  errout:
 -	pr_warn("sec '%s': failed to allocate memory for prog '%s'\n", sec_name, name);
  	bpf_program__exit(prog);
  	return -ENOMEM;
  }
@@@ -5139,16 -5312,17 +5191,27 @@@ static int bpf_core_patch_insn(struct b
  		imm = insn[0].imm + ((__u64)insn[1].imm << 32);
  		if (res->validate && imm != orig_val) {
  			pr_warn("prog '%s': relo #%d: unexpected insn #%d (LDIMM64) value: got %llu, exp %u -> %u\n",
++<<<<<<< HEAD
 +				bpf_program__title(prog, false), relo_idx,
 +				insn_idx, imm, orig_val, new_val);
++=======
+ 				prog->name, relo_idx,
+ 				insn_idx, (unsigned long long)imm,
+ 				orig_val, new_val);
++>>>>>>> 521095842027 (libbpf: Deprecate notion of BPF program "title" in favor of "section name")
  			return -EINVAL;
  		}
  
  		insn[0].imm = new_val;
  		insn[1].imm = 0; /* currently only 32-bit values are supported */
  		pr_debug("prog '%s': relo #%d: patched insn #%d (LDIMM64) imm64 %llu -> %u\n",
++<<<<<<< HEAD
 +			 bpf_program__title(prog, false), relo_idx, insn_idx,
 +			 imm, new_val);
++=======
+ 			 prog->name, relo_idx, insn_idx,
+ 			 (unsigned long long)imm, new_val);
++>>>>>>> 521095842027 (libbpf: Deprecate notion of BPF program "title" in favor of "section name")
  		break;
  	}
  	default:
@@@ -5485,21 -5657,25 +5546,26 @@@ bpf_object__relocate_core(struct bpf_ob
  			err = -EINVAL;
  			goto out;
  		}
 -		/* bpf_object's ELF is gone by now so it's not easy to find
 -		 * section index by section name, but we can find *any*
 -		 * bpf_program within desired section name and use it's
 -		 * prog->sec_idx to do a proper search by section index and
 -		 * instruction offset
 -		 */
  		prog = NULL;
  		for (i = 0; i < obj->nr_programs; i++) {
++<<<<<<< HEAD
 +			if (!strcmp(obj->programs[i].section_name, sec_name)) {
 +				prog = &obj->programs[i];
++=======
+ 			prog = &obj->programs[i];
+ 			if (strcmp(prog->sec_name, sec_name) == 0)
++>>>>>>> 521095842027 (libbpf: Deprecate notion of BPF program "title" in favor of "section name")
  				break;
 +			}
  		}
  		if (!prog) {
 -			pr_warn("sec '%s': failed to find a BPF program\n", sec_name);
 -			return -ENOENT;
 +			pr_warn("failed to find program '%s' for CO-RE offset relocation\n",
 +				sec_name);
 +			err = -EINVAL;
 +			goto out;
  		}
 -		sec_idx = prog->sec_idx;
  
 -		pr_debug("sec '%s': found %d CO-RE relocations\n",
 +		pr_debug("prog '%s': performing %d CO-RE offset relocs\n",
  			 sec_name, sec->num_info);
  
  		for_each_btf_ext_rec(seg, sec, i, rec) {
@@@ -5620,20 -5748,390 +5686,273 @@@ bpf_program__relocate(struct bpf_progra
  				insn[0].imm = (__u32)ext->ksym.addr;
  				insn[1].imm = ext->ksym.addr >> 32;
  			}
 -			relo->processed = true;
  			break;
  		case RELO_CALL:
++<<<<<<< HEAD
 +			err = bpf_program__reloc_text(prog, obj, relo);
++=======
+ 			/* will be handled as a follow up pass */
+ 			break;
+ 		default:
+ 			pr_warn("prog '%s': relo #%d: bad relo type %d\n",
+ 				prog->name, i, relo->type);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int adjust_prog_btf_ext_info(const struct bpf_object *obj,
+ 				    const struct bpf_program *prog,
+ 				    const struct btf_ext_info *ext_info,
+ 				    void **prog_info, __u32 *prog_rec_cnt,
+ 				    __u32 *prog_rec_sz)
+ {
+ 	void *copy_start = NULL, *copy_end = NULL;
+ 	void *rec, *rec_end, *new_prog_info;
+ 	const struct btf_ext_info_sec *sec;
+ 	size_t old_sz, new_sz;
+ 	const char *sec_name;
+ 	int i, off_adj;
+ 
+ 	for_each_btf_ext_sec(ext_info, sec) {
+ 		sec_name = btf__name_by_offset(obj->btf, sec->sec_name_off);
+ 		if (!sec_name)
+ 			return -EINVAL;
+ 		if (strcmp(sec_name, prog->sec_name) != 0)
+ 			continue;
+ 
+ 		for_each_btf_ext_rec(ext_info, sec, i, rec) {
+ 			__u32 insn_off = *(__u32 *)rec / BPF_INSN_SZ;
+ 
+ 			if (insn_off < prog->sec_insn_off)
+ 				continue;
+ 			if (insn_off >= prog->sec_insn_off + prog->sec_insn_cnt)
+ 				break;
+ 
+ 			if (!copy_start)
+ 				copy_start = rec;
+ 			copy_end = rec + ext_info->rec_size;
+ 		}
+ 
+ 		if (!copy_start)
+ 			return -ENOENT;
+ 
+ 		/* append func/line info of a given (sub-)program to the main
+ 		 * program func/line info
+ 		 */
+ 		old_sz = (*prog_rec_cnt) * ext_info->rec_size;
+ 		new_sz = old_sz + (copy_end - copy_start);
+ 		new_prog_info = realloc(*prog_info, new_sz);
+ 		if (!new_prog_info)
+ 			return -ENOMEM;
+ 		*prog_info = new_prog_info;
+ 		*prog_rec_cnt = new_sz / ext_info->rec_size;
+ 		memcpy(new_prog_info + old_sz, copy_start, copy_end - copy_start);
+ 
+ 		/* Kernel instruction offsets are in units of 8-byte
+ 		 * instructions, while .BTF.ext instruction offsets generated
+ 		 * by Clang are in units of bytes. So convert Clang offsets
+ 		 * into kernel offsets and adjust offset according to program
+ 		 * relocated position.
+ 		 */
+ 		off_adj = prog->sub_insn_off - prog->sec_insn_off;
+ 		rec = new_prog_info + old_sz;
+ 		rec_end = new_prog_info + new_sz;
+ 		for (; rec < rec_end; rec += ext_info->rec_size) {
+ 			__u32 *insn_off = rec;
+ 
+ 			*insn_off = *insn_off / BPF_INSN_SZ + off_adj;
+ 		}
+ 		*prog_rec_sz = ext_info->rec_size;
+ 		return 0;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static int
+ reloc_prog_func_and_line_info(const struct bpf_object *obj,
+ 			      struct bpf_program *main_prog,
+ 			      const struct bpf_program *prog)
+ {
+ 	int err;
+ 
+ 	/* no .BTF.ext relocation if .BTF.ext is missing or kernel doesn't
+ 	 * supprot func/line info
+ 	 */
+ 	if (!obj->btf_ext || !kernel_supports(FEAT_BTF_FUNC))
+ 		return 0;
+ 
+ 	/* only attempt func info relocation if main program's func_info
+ 	 * relocation was successful
+ 	 */
+ 	if (main_prog != prog && !main_prog->func_info)
+ 		goto line_info;
+ 
+ 	err = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->func_info,
+ 				       &main_prog->func_info,
+ 				       &main_prog->func_info_cnt,
+ 				       &main_prog->func_info_rec_size);
+ 	if (err) {
+ 		if (err != -ENOENT) {
+ 			pr_warn("prog '%s': error relocating .BTF.ext function info: %d\n",
+ 				prog->name, err);
+ 			return err;
+ 		}
+ 		if (main_prog->func_info) {
+ 			/*
+ 			 * Some info has already been found but has problem
+ 			 * in the last btf_ext reloc. Must have to error out.
+ 			 */
+ 			pr_warn("prog '%s': missing .BTF.ext function info.\n", prog->name);
+ 			return err;
+ 		}
+ 		/* Have problem loading the very first info. Ignore the rest. */
+ 		pr_warn("prog '%s': missing .BTF.ext function info for the main program, skipping all of .BTF.ext func info.\n",
+ 			prog->name);
+ 	}
+ 
+ line_info:
+ 	/* don't relocate line info if main program's relocation failed */
+ 	if (main_prog != prog && !main_prog->line_info)
+ 		return 0;
+ 
+ 	err = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->line_info,
+ 				       &main_prog->line_info,
+ 				       &main_prog->line_info_cnt,
+ 				       &main_prog->line_info_rec_size);
+ 	if (err) {
+ 		if (err != -ENOENT) {
+ 			pr_warn("prog '%s': error relocating .BTF.ext line info: %d\n",
+ 				prog->name, err);
+ 			return err;
+ 		}
+ 		if (main_prog->line_info) {
+ 			/*
+ 			 * Some info has already been found but has problem
+ 			 * in the last btf_ext reloc. Must have to error out.
+ 			 */
+ 			pr_warn("prog '%s': missing .BTF.ext line info.\n", prog->name);
+ 			return err;
+ 		}
+ 		/* Have problem loading the very first info. Ignore the rest. */
+ 		pr_warn("prog '%s': missing .BTF.ext line info for the main program, skipping all of .BTF.ext line info.\n",
+ 			prog->name);
+ 	}
+ 	return 0;
+ }
+ 
+ static int cmp_relo_by_insn_idx(const void *key, const void *elem)
+ {
+ 	size_t insn_idx = *(const size_t *)key;
+ 	const struct reloc_desc *relo = elem;
+ 
+ 	if (insn_idx == relo->insn_idx)
+ 		return 0;
+ 	return insn_idx < relo->insn_idx ? -1 : 1;
+ }
+ 
+ static struct reloc_desc *find_prog_insn_relo(const struct bpf_program *prog, size_t insn_idx)
+ {
+ 	return bsearch(&insn_idx, prog->reloc_desc, prog->nr_reloc,
+ 		       sizeof(*prog->reloc_desc), cmp_relo_by_insn_idx);
+ }
+ 
+ static int
+ bpf_object__reloc_code(struct bpf_object *obj, struct bpf_program *main_prog,
+ 		       struct bpf_program *prog)
+ {
+ 	size_t sub_insn_idx, insn_idx, new_cnt;
+ 	struct bpf_program *subprog;
+ 	struct bpf_insn *insns, *insn;
+ 	struct reloc_desc *relo;
+ 	int err;
+ 
+ 	err = reloc_prog_func_and_line_info(obj, main_prog, prog);
+ 	if (err)
+ 		return err;
+ 
+ 	for (insn_idx = 0; insn_idx < prog->sec_insn_cnt; insn_idx++) {
+ 		insn = &main_prog->insns[prog->sub_insn_off + insn_idx];
+ 		if (!insn_is_subprog_call(insn))
+ 			continue;
+ 
+ 		relo = find_prog_insn_relo(prog, insn_idx);
+ 		if (relo && relo->type != RELO_CALL) {
+ 			pr_warn("prog '%s': unexpected relo for insn #%zu, type %d\n",
+ 				prog->name, insn_idx, relo->type);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 		if (relo) {
+ 			/* sub-program instruction index is a combination of
+ 			 * an offset of a symbol pointed to by relocation and
+ 			 * call instruction's imm field; for global functions,
+ 			 * call always has imm = -1, but for static functions
+ 			 * relocation is against STT_SECTION and insn->imm
+ 			 * points to a start of a static function
+ 			 */
+ 			sub_insn_idx = relo->sym_off / BPF_INSN_SZ + insn->imm + 1;
+ 		} else {
+ 			/* if subprogram call is to a static function within
+ 			 * the same ELF section, there won't be any relocation
+ 			 * emitted, but it also means there is no additional
+ 			 * offset necessary, insns->imm is relative to
+ 			 * instruction's original position within the section
+ 			 */
+ 			sub_insn_idx = prog->sec_insn_off + insn_idx + insn->imm + 1;
+ 		}
+ 
+ 		/* we enforce that sub-programs should be in .text section */
+ 		subprog = find_prog_by_sec_insn(obj, obj->efile.text_shndx, sub_insn_idx);
+ 		if (!subprog) {
+ 			pr_warn("prog '%s': no .text section found yet sub-program call exists\n",
+ 				prog->name);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 
+ 		/* if it's the first call instruction calling into this
+ 		 * subprogram (meaning this subprog hasn't been processed
+ 		 * yet) within the context of current main program:
+ 		 *   - append it at the end of main program's instructions blog;
+ 		 *   - process is recursively, while current program is put on hold;
+ 		 *   - if that subprogram calls some other not yet processes
+ 		 *   subprogram, same thing will happen recursively until
+ 		 *   there are no more unprocesses subprograms left to append
+ 		 *   and relocate.
+ 		 */
+ 		if (subprog->sub_insn_off == 0) {
+ 			subprog->sub_insn_off = main_prog->insns_cnt;
+ 
+ 			new_cnt = main_prog->insns_cnt + subprog->insns_cnt;
+ 			insns = libbpf_reallocarray(main_prog->insns, new_cnt, sizeof(*insns));
+ 			if (!insns) {
+ 				pr_warn("prog '%s': failed to realloc prog code\n", main_prog->name);
+ 				return -ENOMEM;
+ 			}
+ 			main_prog->insns = insns;
+ 			main_prog->insns_cnt = new_cnt;
+ 
+ 			memcpy(main_prog->insns + subprog->sub_insn_off, subprog->insns,
+ 			       subprog->insns_cnt * sizeof(*insns));
+ 
+ 			pr_debug("prog '%s': added %zu insns from sub-prog '%s'\n",
+ 				 main_prog->name, subprog->insns_cnt, subprog->name);
+ 
+ 			err = bpf_object__reloc_code(obj, main_prog, subprog);
++>>>>>>> 521095842027 (libbpf: Deprecate notion of BPF program "title" in favor of "section name")
  			if (err)
  				return err;
 +			break;
 +		default:
 +			pr_warn("relo #%d: bad relo type %d\n", i, relo->type);
 +			return -EINVAL;
  		}
 -
 -		/* main_prog->insns memory could have been re-allocated, so
 -		 * calculate pointer again
 -		 */
 -		insn = &main_prog->insns[prog->sub_insn_off + insn_idx];
 -		/* calculate correct instruction position within current main
 -		 * prog; each main prog can have a different set of
 -		 * subprograms appended (potentially in different order as
 -		 * well), so position of any subprog can be different for
 -		 * different main programs */
 -		insn->imm = subprog->sub_insn_off - (prog->sub_insn_off + insn_idx) - 1;
 -
 -		if (relo)
 -			relo->processed = true;
 -
 -		pr_debug("prog '%s': insn #%zu relocated, imm %d points to subprog '%s' (now at %zu offset)\n",
 -			 prog->name, insn_idx, insn->imm, subprog->name, subprog->sub_insn_off);
 -	}
 -
 -	return 0;
 -}
 -
 -/*
 - * Relocate sub-program calls.
 - *
 - * Algorithm operates as follows. Each entry-point BPF program (referred to as
 - * main prog) is processed separately. For each subprog (non-entry functions,
 - * that can be called from either entry progs or other subprogs) gets their
 - * sub_insn_off reset to zero. This serves as indicator that this subprogram
 - * hasn't been yet appended and relocated within current main prog. Once its
 - * relocated, sub_insn_off will point at the position within current main prog
 - * where given subprog was appended. This will further be used to relocate all
 - * the call instructions jumping into this subprog.
 - *
 - * We start with main program and process all call instructions. If the call
 - * is into a subprog that hasn't been processed (i.e., subprog->sub_insn_off
 - * is zero), subprog instructions are appended at the end of main program's
 - * instruction array. Then main program is "put on hold" while we recursively
 - * process newly appended subprogram. If that subprogram calls into another
 - * subprogram that hasn't been appended, new subprogram is appended again to
 - * the *main* prog's instructions (subprog's instructions are always left
 - * untouched, as they need to be in unmodified state for subsequent main progs
 - * and subprog instructions are always sent only as part of a main prog) and
 - * the process continues recursively. Once all the subprogs called from a main
 - * prog or any of its subprogs are appended (and relocated), all their
 - * positions within finalized instructions array are known, so it's easy to
 - * rewrite call instructions with correct relative offsets, corresponding to
 - * desired target subprog.
 - *
 - * Its important to realize that some subprogs might not be called from some
 - * main prog and any of its called/used subprogs. Those will keep their
 - * subprog->sub_insn_off as zero at all times and won't be appended to current
 - * main prog and won't be relocated within the context of current main prog.
 - * They might still be used from other main progs later.
 - *
 - * Visually this process can be shown as below. Suppose we have two main
 - * programs mainA and mainB and BPF object contains three subprogs: subA,
 - * subB, and subC. mainA calls only subA, mainB calls only subC, but subA and
 - * subC both call subB:
 - *
 - *        +--------+ +-------+
 - *        |        v v       |
 - *     +--+---+ +--+-+-+ +---+--+
 - *     | subA | | subB | | subC |
 - *     +--+---+ +------+ +---+--+
 - *        ^                  ^
 - *        |                  |
 - *    +---+-------+   +------+----+
 - *    |   mainA   |   |   mainB   |
 - *    +-----------+   +-----------+
 - *
 - * We'll start relocating mainA, will find subA, append it and start
 - * processing sub A recursively:
 - *
 - *    +-----------+------+
 - *    |   mainA   | subA |
 - *    +-----------+------+
 - *
 - * At this point we notice that subB is used from subA, so we append it and
 - * relocate (there are no further subcalls from subB):
 - *
 - *    +-----------+------+------+
 - *    |   mainA   | subA | subB |
 - *    +-----------+------+------+
 - *
 - * At this point, we relocate subA calls, then go one level up and finish with
 - * relocatin mainA calls. mainA is done.
 - *
 - * For mainB process is similar but results in different order. We start with
 - * mainB and skip subA and subB, as mainB never calls them (at least
 - * directly), but we see subC is needed, so we append and start processing it:
 - *
 - *    +-----------+------+
 - *    |   mainB   | subC |
 - *    +-----------+------+
 - * Now we see subC needs subB, so we go back to it, append and relocate it:
 - *
 - *    +-----------+------+------+
 - *    |   mainB   | subC | subB |
 - *    +-----------+------+------+
 - *
 - * At this point we unwind recursion, relocate calls in subC, then in mainB.
 - */
 -static int
 -bpf_object__relocate_calls(struct bpf_object *obj, struct bpf_program *prog)
 -{
 -	struct bpf_program *subprog;
 -	int i, j, err;
 -
 -	/* mark all subprogs as not relocated (yet) within the context of
 -	 * current main program
 -	 */
 -	for (i = 0; i < obj->nr_programs; i++) {
 -		subprog = &obj->programs[i];
 -		if (!prog_is_subprog(obj, subprog))
 -			continue;
 -
 -		subprog->sub_insn_off = 0;
 -		for (j = 0; j < subprog->nr_reloc; j++)
 -			if (subprog->reloc_desc[j].type == RELO_CALL)
 -				subprog->reloc_desc[j].processed = false;
  	}
  
 -	err = bpf_object__reloc_code(obj, prog, prog);
 -	if (err)
 -		return err;
 -
 -
 +	zfree(&prog->reloc_desc);
 +	prog->nr_reloc = 0;
  	return 0;
  }
  
diff --cc tools/lib/bpf/libbpf.map
index 0db77fbd2de9,92ceb48a5ca2..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -334,30 -302,10 +334,39 @@@ LIBBPF_0.1.0 
  
  LIBBPF_0.2.0 {
  	global:
++<<<<<<< HEAD
 +		bpf_program__attach_freplace;
 +		btf__add_array;
 +		btf__add_const;
 +		btf__add_enum;
 +		btf__add_enum_value;
 +		btf__add_datasec;
 +		btf__add_datasec_var_info;
 +		btf__add_field;
 +		btf__add_func;
 +		btf__add_func_param;
 +		btf__add_func_proto;
 +		btf__add_fwd;
 +		btf__add_int;
 +		btf__add_ptr;
 +		btf__add_restrict;
 +		btf__add_str;
 +		btf__add_struct;
 +		btf__add_typedef;
 +		btf__add_union;
 +		btf__add_var;
 +		btf__add_volatile;
 +		btf__endianness;
 +		btf__find_str;
 +		btf__new_empty;
 +		btf__set_endianness;
 +		btf__str_by_offset;
++=======
+ 		bpf_program__section_name;
+ 		perf_buffer__buffer_cnt;
+ 		perf_buffer__buffer_fd;
+ 		perf_buffer__epoll_fd;
+ 		perf_buffer__consume_buffer;
+ 		xsk_socket__create_shared;
++>>>>>>> 521095842027 (libbpf: Deprecate notion of BPF program "title" in favor of "section name")
  } LIBBPF_0.1.0;
* Unmerged path tools/lib/bpf/libbpf.c
diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index 3bed37161627..66432484ad74 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -210,8 +210,9 @@ LIBBPF_API void bpf_program__set_ifindex(struct bpf_program *prog,
 					 __u32 ifindex);
 
 LIBBPF_API const char *bpf_program__name(const struct bpf_program *prog);
-LIBBPF_API const char *bpf_program__title(const struct bpf_program *prog,
-					  bool needs_copy);
+LIBBPF_API const char *bpf_program__section_name(const struct bpf_program *prog);
+LIBBPF_API LIBBPF_DEPRECATED("BPF program title is confusing term; please use bpf_program__section_name() instead")
+const char *bpf_program__title(const struct bpf_program *prog, bool needs_copy);
 LIBBPF_API bool bpf_program__autoload(const struct bpf_program *prog);
 LIBBPF_API int bpf_program__set_autoload(struct bpf_program *prog, bool autoload);
 
* Unmerged path tools/lib/bpf/libbpf.map
