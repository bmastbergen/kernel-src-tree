mt76: mt7921: rely on mt76_connac_mcu module for sched_scan and hw_scan

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 80fc1e37c0eb0115c980a5bbc011724fa41bfdb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/80fc1e37.failed

Rely on mt76_connac_mcu module for sched_scan and hw_scan and remove
duplicated code

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 80fc1e37c0eb0115c980a5bbc011724fa41bfdb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mcu.h
#	drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
index 77055ff812eb,e36cae5711aa..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
@@@ -1938,561 -1110,7 +1938,565 @@@ int mt7921_mcu_get_eeprom(struct mt7921
  	return 0;
  }
  
++<<<<<<< HEAD
 +int
 +mt7921_mcu_uni_add_dev(struct mt7921_dev *dev,
 +		       struct ieee80211_vif *vif, bool enable)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	u8 omac_idx = mvif->mt76.omac_idx;
 +	struct {
 +		struct {
 +			u8 omac_idx;
 +			u8 band_idx;
 +			__le16 pad;
 +		} __packed hdr;
 +		struct req_tlv {
 +			__le16 tag;
 +			__le16 len;
 +			u8 active;
 +			u8 pad;
 +			u8 omac_addr[ETH_ALEN];
 +		} __packed tlv;
 +	} dev_req = {
 +		.hdr = {
 +			.omac_idx = omac_idx,
 +			.band_idx = mvif->mt76.band_idx,
 +		},
 +		.tlv = {
 +			.tag = cpu_to_le16(DEV_INFO_ACTIVE),
 +			.len = cpu_to_le16(sizeof(struct req_tlv)),
 +			.active = enable,
 +		},
 +	};
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_bss_basic_tlv basic;
 +	} basic_req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.basic = {
 +			.tag = cpu_to_le16(UNI_BSS_INFO_BASIC),
 +			.len = cpu_to_le16(sizeof(struct mt7921_bss_basic_tlv)),
 +			.omac_idx = omac_idx,
 +			.band_idx = mvif->mt76.band_idx,
 +			.wmm_idx = mvif->mt76.wmm_idx,
 +			.active = enable,
 +			.bmc_tx_wlan_idx = cpu_to_le16(mvif->sta.wcid.idx),
 +			.sta_idx = cpu_to_le16(mvif->sta.wcid.idx),
 +			.conn_state = 1,
 +		},
 +	};
 +	int err, idx, cmd, len;
 +	void *data;
 +
 +	switch (vif->type) {
 +	case NL80211_IFTYPE_MESH_POINT:
 +	case NL80211_IFTYPE_AP:
 +		basic_req.basic.conn_type = cpu_to_le32(CONNECTION_INFRA_AP);
 +		break;
 +	case NL80211_IFTYPE_STATION:
 +		basic_req.basic.conn_type = cpu_to_le32(CONNECTION_INFRA_STA);
 +		break;
 +	case NL80211_IFTYPE_ADHOC:
 +		basic_req.basic.conn_type = cpu_to_le32(CONNECTION_IBSS_ADHOC);
 +		break;
 +	default:
 +		WARN_ON(1);
 +		break;
 +	}
 +
 +	idx = omac_idx > EXT_BSSID_START ? HW_BSSID_0 : omac_idx;
 +	basic_req.basic.hw_bss_idx = idx;
 +
 +	memcpy(dev_req.tlv.omac_addr, vif->addr, ETH_ALEN);
 +
 +	cmd = enable ? MCU_UNI_CMD_DEV_INFO_UPDATE : MCU_UNI_CMD_BSS_INFO_UPDATE;
 +	data = enable ? (void *)&dev_req : (void *)&basic_req;
 +	len = enable ? sizeof(dev_req) : sizeof(basic_req);
 +
 +	err = mt76_mcu_send_msg(&dev->mt76, cmd, data, len, true);
 +	if (err < 0)
 +		return err;
 +
 +	cmd = enable ? MCU_UNI_CMD_BSS_INFO_UPDATE : MCU_UNI_CMD_DEV_INFO_UPDATE;
 +	data = enable ? (void *)&basic_req : (void *)&dev_req;
 +	len = enable ? sizeof(basic_req) : sizeof(dev_req);
 +
 +	return mt76_mcu_send_msg(&dev->mt76, cmd, data, len, true);
 +}
 +
 +int
 +mt7921_mcu_uni_add_bss(struct mt7921_phy *phy, struct ieee80211_vif *vif,
 +		       bool enable)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
 +	int freq1 = chandef->center_freq1, freq2 = chandef->center_freq2;
 +	struct mt7921_dev *dev = phy->dev;
 +	enum nl80211_band band = chandef->chan->band;
 +	u8 omac_idx = mvif->mt76.omac_idx;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_bss_basic_tlv basic;
 +		struct mt7921_bss_qos_tlv qos;
 +	} basic_req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.basic = {
 +			.tag = cpu_to_le16(UNI_BSS_INFO_BASIC),
 +			.len = cpu_to_le16(sizeof(struct mt7921_bss_basic_tlv)),
 +			.bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int),
 +			.dtim_period = vif->bss_conf.dtim_period,
 +			.omac_idx = omac_idx,
 +			.band_idx = mvif->mt76.band_idx,
 +			.wmm_idx = mvif->mt76.wmm_idx,
 +			.active = true, /* keep bss deactivated */
 +			.phymode = mt7921_get_phy_mode(phy->dev, vif, band, NULL),
 +		},
 +		.qos = {
 +			.tag = cpu_to_le16(UNI_BSS_INFO_QBSS),
 +			.len = cpu_to_le16(sizeof(struct mt7921_bss_qos_tlv)),
 +			.qos = vif->bss_conf.qos,
 +		},
 +	};
 +
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct bss_info_uni_he he;
 +	} he_req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.he = {
 +			.tag = cpu_to_le16(UNI_BSS_INFO_HE_BASIC),
 +			.len = cpu_to_le16(sizeof(struct bss_info_uni_he)),
 +		},
 +	};
 +
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct rlm_tlv {
 +			__le16 tag;
 +			__le16 len;
 +			u8 control_channel;
 +			u8 center_chan;
 +			u8 center_chan2;
 +			u8 bw;
 +			u8 tx_streams;
 +			u8 rx_streams;
 +			u8 short_st;
 +			u8 ht_op_info;
 +			u8 sco;
 +			u8 pad[3];
 +		} __packed rlm;
 +	} __packed rlm_req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.rlm = {
 +			.tag = cpu_to_le16(UNI_BSS_INFO_RLM),
 +			.len = cpu_to_le16(sizeof(struct rlm_tlv)),
 +			.control_channel = chandef->chan->hw_value,
 +			.center_chan = ieee80211_frequency_to_channel(freq1),
 +			.center_chan2 = ieee80211_frequency_to_channel(freq2),
 +			.tx_streams = hweight8(phy->mt76->antenna_mask),
 +			.rx_streams = phy->mt76->chainmask,
 +			.short_st = true,
 +		},
 +	};
 +	int err, conn_type;
 +	u8 idx;
 +
 +	idx = omac_idx > EXT_BSSID_START ? HW_BSSID_0 : omac_idx;
 +	basic_req.basic.hw_bss_idx = idx;
 +
 +	switch (vif->type) {
 +	case NL80211_IFTYPE_MESH_POINT:
 +	case NL80211_IFTYPE_AP:
 +		if (vif->p2p)
 +			conn_type = CONNECTION_P2P_GO;
 +		else
 +			conn_type = CONNECTION_INFRA_AP;
 +		basic_req.basic.conn_type = cpu_to_le32(conn_type);
 +		break;
 +	case NL80211_IFTYPE_STATION:
 +		if (vif->p2p)
 +			conn_type = CONNECTION_P2P_GC;
 +		else
 +			conn_type = CONNECTION_INFRA_STA;
 +		basic_req.basic.conn_type = cpu_to_le32(conn_type);
 +		break;
 +	case NL80211_IFTYPE_ADHOC:
 +		basic_req.basic.conn_type = cpu_to_le32(CONNECTION_IBSS_ADHOC);
 +		break;
 +	default:
 +		WARN_ON(1);
 +		break;
 +	}
 +
 +	memcpy(basic_req.basic.bssid, vif->bss_conf.bssid, ETH_ALEN);
 +	basic_req.basic.bmc_tx_wlan_idx = cpu_to_le16(mvif->sta.wcid.idx);
 +	basic_req.basic.sta_idx = cpu_to_le16(mvif->sta.wcid.idx);
 +	basic_req.basic.conn_state = !enable;
 +
 +	err = mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_BSS_INFO_UPDATE,
 +				&basic_req, sizeof(basic_req), true);
 +	if (err < 0)
 +		return err;
 +
 +	if (vif->bss_conf.he_support) {
 +		mt7921_mcu_uni_bss_he_tlv((struct tlv *)&he_req.he, vif, phy);
 +
 +		err = mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_BSS_INFO_UPDATE,
 +					&he_req, sizeof(he_req), true);
 +		if (err < 0)
 +			return err;
 +	}
 +
 +	switch (chandef->width) {
 +	case NL80211_CHAN_WIDTH_40:
 +		rlm_req.rlm.bw = CMD_CBW_40MHZ;
 +		break;
 +	case NL80211_CHAN_WIDTH_80:
 +		rlm_req.rlm.bw = CMD_CBW_80MHZ;
 +		break;
 +	case NL80211_CHAN_WIDTH_80P80:
 +		rlm_req.rlm.bw = CMD_CBW_8080MHZ;
 +		break;
 +	case NL80211_CHAN_WIDTH_160:
 +		rlm_req.rlm.bw = CMD_CBW_160MHZ;
 +		break;
 +	case NL80211_CHAN_WIDTH_5:
 +		rlm_req.rlm.bw = CMD_CBW_5MHZ;
 +		break;
 +	case NL80211_CHAN_WIDTH_10:
 +		rlm_req.rlm.bw = CMD_CBW_10MHZ;
 +		break;
 +	case NL80211_CHAN_WIDTH_20_NOHT:
 +	case NL80211_CHAN_WIDTH_20:
 +	default:
 +		rlm_req.rlm.bw = CMD_CBW_20MHZ;
 +		break;
 +	}
 +
 +	if (rlm_req.rlm.control_channel < rlm_req.rlm.center_chan)
 +		rlm_req.rlm.sco = 1; /* SCA */
 +	else if (rlm_req.rlm.control_channel > rlm_req.rlm.center_chan)
 +		rlm_req.rlm.sco = 3; /* SCB */
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_BSS_INFO_UPDATE,
 +				 &rlm_req, sizeof(rlm_req), true);
 +}
 +
 +static int
 +mt7921_mcu_add_sta_cmd(struct mt7921_dev *dev, struct ieee80211_vif *vif,
 +		       struct ieee80211_sta *sta, bool enable, int cmd)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct wtbl_req_hdr *wtbl_hdr;
 +	struct mt7921_sta *msta;
 +	struct tlv *sta_wtbl;
 +	struct sk_buff *skb;
 +
 +	msta = sta ? (struct mt7921_sta *)sta->drv_priv : &mvif->sta;
 +
 +	skb = mt7921_mcu_alloc_sta_req(dev, mvif, msta,
 +				       MT7921_STA_UPDATE_MAX_SIZE);
 +	if (IS_ERR(skb))
 +		return PTR_ERR(skb);
 +
 +	mt7921_mcu_sta_basic_tlv(skb, vif, sta, enable);
 +	if (enable && sta)
 +		mt7921_mcu_sta_tlv(dev, skb, sta, vif);
 +
 +	sta_wtbl = mt7921_mcu_add_tlv(skb, STA_REC_WTBL, sizeof(struct tlv));
 +
 +	wtbl_hdr = mt7921_mcu_alloc_wtbl_req(dev, msta, WTBL_RESET_AND_SET,
 +					     sta_wtbl, &skb);
 +	if (enable) {
 +		mt7921_mcu_wtbl_generic_tlv(skb, vif, sta, sta_wtbl, wtbl_hdr);
 +		if (sta)
 +			mt7921_mcu_wtbl_ht_tlv(skb, sta, sta_wtbl, wtbl_hdr);
 +	}
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, cmd, true);
 +}
 +
 +int
 +mt7921_mcu_uni_add_sta(struct mt7921_dev *dev, struct ieee80211_vif *vif,
 +		       struct ieee80211_sta *sta, bool enable)
 +{
 +	return mt7921_mcu_add_sta_cmd(dev, vif, sta, enable,
 +				      MCU_UNI_CMD_STA_REC_UPDATE);
 +}
 +
 +int mt7921_mcu_set_channel_domain(struct mt7921_phy *phy)
 +{
 +	struct mt76_phy *mphy = phy->mt76;
 +	struct mt7921_dev *dev = phy->dev;
 +	struct mt7921_mcu_channel_domain {
 +		__le32 country_code; /* regulatory_request.alpha2 */
 +		u8 bw_2g; /* BW_20_40M		0
 +			   * BW_20M		1
 +			   * BW_20_40_80M	2
 +			   * BW_20_40_80_160M	3
 +			   * BW_20_40_80_8080M	4
 +			   */
 +		u8 bw_5g;
 +		__le16 pad;
 +		u8 n_2ch;
 +		u8 n_5ch;
 +		__le16 pad2;
 +	} __packed hdr = {
 +		.bw_2g = 0,
 +		.bw_5g = 3,
 +		.n_2ch = mphy->sband_2g.sband.n_channels,
 +		.n_5ch = mphy->sband_5g.sband.n_channels,
 +	};
 +	struct mt7921_mcu_chan {
 +		__le16 hw_value;
 +		__le16 pad;
 +		__le32 flags;
 +	} __packed;
 +	int i, n_channels = hdr.n_2ch + hdr.n_5ch;
 +	int len = sizeof(hdr) + n_channels * sizeof(struct mt7921_mcu_chan);
 +	struct sk_buff *skb;
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &hdr, sizeof(hdr));
 +
 +	for (i = 0; i < n_channels; i++) {
 +		struct ieee80211_channel *chan;
 +		struct mt7921_mcu_chan channel;
 +
 +		if (i < hdr.n_2ch)
 +			chan = &mphy->sband_2g.sband.channels[i];
 +		else
 +			chan = &mphy->sband_5g.sband.channels[i - hdr.n_2ch];
 +
 +		channel.hw_value = cpu_to_le16(chan->hw_value);
 +		channel.flags = cpu_to_le32(chan->flags);
 +		channel.pad = 0;
 +
 +		skb_put_data(skb, &channel, sizeof(channel));
 +	}
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_CMD_SET_CHAN_DOMAIN,
 +				     false);
 +}
 +
 +#define MT7921_SCAN_CHANNEL_TIME	60
 +int mt7921_mcu_hw_scan(struct mt7921_phy *phy, struct ieee80211_vif *vif,
 +		       struct ieee80211_scan_request *scan_req)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct cfg80211_scan_request *sreq = &scan_req->req;
 +	int n_ssids = 0, err, i, duration = MT7921_SCAN_CHANNEL_TIME;
 +	int ext_channels_num = max_t(int, sreq->n_channels - 32, 0);
 +	struct ieee80211_channel **scan_list = sreq->channels;
 +	struct mt7921_dev *dev = phy->dev;
 +	struct mt7921_mcu_scan_channel *chan;
 +	struct mt7921_hw_scan_req *req;
 +	struct sk_buff *skb;
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(*req));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	set_bit(MT76_HW_SCANNING, &phy->mt76->state);
 +	mvif->mt76.scan_seq_num = (mvif->mt76.scan_seq_num + 1) & 0x7f;
 +
 +	req = (struct mt7921_hw_scan_req *)skb_put(skb, sizeof(*req));
 +
 +	req->seq_num = mvif->mt76.scan_seq_num;
 +	req->bss_idx = mvif->mt76.idx;
 +	req->scan_type = sreq->n_ssids ? 1 : 0;
 +	req->probe_req_num = sreq->n_ssids ? 2 : 0;
 +	req->version = 1;
 +
 +	for (i = 0; i < sreq->n_ssids; i++) {
 +		if (!sreq->ssids[i].ssid_len)
 +			continue;
 +
 +		req->ssids[i].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);
 +		memcpy(req->ssids[i].ssid, sreq->ssids[i].ssid,
 +		       sreq->ssids[i].ssid_len);
 +		n_ssids++;
 +	}
 +	req->ssid_type = n_ssids ? BIT(2) : BIT(0);
 +	req->ssid_type_ext = n_ssids ? BIT(0) : 0;
 +	req->ssids_num = n_ssids;
 +
 +	/* increase channel time for passive scan */
 +	if (!sreq->n_ssids)
 +		duration *= 2;
 +	req->timeout_value = cpu_to_le16(sreq->n_channels * duration);
 +	req->channel_min_dwell_time = cpu_to_le16(duration);
 +	req->channel_dwell_time = cpu_to_le16(duration);
 +
 +	req->channels_num = min_t(u8, sreq->n_channels, 32);
 +	req->ext_channels_num = min_t(u8, ext_channels_num, 32);
 +	for (i = 0; i < req->channels_num + req->ext_channels_num; i++) {
 +		if (i >= 32)
 +			chan = &req->ext_channels[i - 32];
 +		else
 +			chan = &req->channels[i];
 +
 +		chan->band = scan_list[i]->band == NL80211_BAND_2GHZ ? 1 : 2;
 +		chan->channel_num = scan_list[i]->hw_value;
 +	}
 +	req->channel_type = sreq->n_channels ? 4 : 0;
 +
 +	if (sreq->ie_len > 0) {
 +		memcpy(req->ies, sreq->ie, sreq->ie_len);
 +		req->ies_len = cpu_to_le16(sreq->ie_len);
 +	}
 +
 +	memcpy(req->bssid, sreq->bssid, ETH_ALEN);
 +	if (sreq->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {
 +		get_random_mask_addr(req->random_mac, sreq->mac_addr,
 +				     sreq->mac_addr_mask);
 +		req->scan_func = 1;
 +	}
 +
 +	err = mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_CMD_START_HW_SCAN,
 +				    false);
 +	if (err < 0)
 +		clear_bit(MT76_HW_SCANNING, &phy->mt76->state);
 +
 +	return err;
 +}
 +
 +int mt7921_mcu_cancel_hw_scan(struct mt7921_phy *phy,
 +			      struct ieee80211_vif *vif)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_dev *dev = phy->dev;
 +	struct {
 +		u8 seq_num;
 +		u8 is_ext_channel;
 +		u8 rsv[2];
 +	} __packed req = {
 +		.seq_num = mvif->mt76.scan_seq_num,
 +	};
 +
 +	if (test_and_clear_bit(MT76_HW_SCANNING, &phy->mt76->state)) {
 +		struct cfg80211_scan_info info = {
 +			.aborted = true,
 +		};
 +
 +		ieee80211_scan_completed(phy->mt76->hw, &info);
 +	}
 +
 +	return mt76_mcu_send_msg(&dev->mt76,  MCU_CMD_CANCEL_HW_SCAN, &req,
 +				 sizeof(req), false);
 +}
 +
 +int mt7921_mcu_sched_scan_req(struct mt7921_phy *phy,
 +			      struct ieee80211_vif *vif,
 +			      struct cfg80211_sched_scan_request *sreq)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct ieee80211_channel **scan_list = sreq->channels;
 +	struct mt7921_dev *dev = phy->dev;
 +	struct mt7921_mcu_scan_channel *chan;
 +	struct mt7921_sched_scan_req *req;
 +	struct cfg80211_match_set *match;
 +	struct cfg80211_ssid *ssid;
 +	struct sk_buff *skb;
 +	int i;
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(*req) + sreq->ie_len);
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	mvif->mt76.scan_seq_num = (mvif->mt76.scan_seq_num + 1) & 0x7f;
 +
 +	req = (struct mt7921_sched_scan_req *)skb_put(skb, sizeof(*req));
 +	req->version = 1;
 +	req->seq_num = mvif->mt76.scan_seq_num;
 +
 +	req->ssids_num = sreq->n_ssids;
 +	for (i = 0; i < req->ssids_num; i++) {
 +		ssid = &sreq->ssids[i];
 +		memcpy(req->ssids[i].ssid, ssid->ssid, ssid->ssid_len);
 +		req->ssids[i].ssid_len = cpu_to_le32(ssid->ssid_len);
 +	}
 +
 +	req->match_num = sreq->n_match_sets;
 +	for (i = 0; i < req->match_num; i++) {
 +		match = &sreq->match_sets[i];
 +		memcpy(req->match[i].ssid, match->ssid.ssid,
 +		       match->ssid.ssid_len);
 +		req->match[i].rssi_th = cpu_to_le32(match->rssi_thold);
 +		req->match[i].ssid_len = match->ssid.ssid_len;
 +	}
 +
 +	req->channel_type = sreq->n_channels ? 4 : 0;
 +	req->channels_num = min_t(u8, sreq->n_channels, 64);
 +	for (i = 0; i < req->channels_num; i++) {
 +		chan = &req->channels[i];
 +		chan->band = scan_list[i]->band == NL80211_BAND_2GHZ ? 1 : 2;
 +		chan->channel_num = scan_list[i]->hw_value;
 +	}
 +
 +	req->intervals_num = sreq->n_scan_plans;
 +	for (i = 0; i < req->intervals_num; i++)
 +		req->intervals[i] = cpu_to_le16(sreq->scan_plans[i].interval);
 +
 +	if (sreq->ie_len > 0) {
 +		req->ie_len = cpu_to_le16(sreq->ie_len);
 +		memcpy(skb_put(skb, sreq->ie_len), sreq->ie, sreq->ie_len);
 +	}
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_CMD_SCHED_SCAN_REQ,
 +				     false);
 +}
 +
 +int mt7921_mcu_sched_scan_enable(struct mt7921_phy *phy,
 +				 struct ieee80211_vif *vif,
 +				 bool enable)
 +{
 +	struct mt7921_dev *dev = phy->dev;
 +	struct {
 +		u8 active; /* 0: enabled 1: disabled */
 +		u8 rsv[3];
 +	} __packed req = {
 +		.active = !enable,
 +	};
 +
 +	if (enable)
 +		set_bit(MT76_HW_SCHED_SCANNING, &phy->mt76->state);
 +	else
 +		clear_bit(MT76_HW_SCHED_SCANNING, &phy->mt76->state);
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_CMD_SCHED_SCAN_ENABLE, &req,
 +				 sizeof(req), false);
 +}
 +
 +u32 mt7921_get_wtbl_info(struct mt7921_dev *dev, u16 wlan_idx)
++=======
+ u32 mt7921_get_wtbl_info(struct mt7921_dev *dev, u32 wlan_idx)
++>>>>>>> 80fc1e37c0eb (mt76: mt7921: rely on mt76_connac_mcu module for sched_scan and hw_scan)
  {
  	struct mt7921_mcu_wlan_info wtbl_info = {
  		.wlan_idx = cpu_to_le32(wlan_idx),
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mcu.h
index 6b3877959bd3,4682cc7c583b..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.h
@@@ -850,192 -386,6 +850,195 @@@ struct mt7921_mcu_reg_event 
  	__le32 val;
  } __packed;
  
++<<<<<<< HEAD
 +struct mt7921_bss_basic_tlv {
 +	__le16 tag;
 +	__le16 len;
 +	u8 active;
 +	u8 omac_idx;
 +	u8 hw_bss_idx;
 +	u8 band_idx;
 +	__le32 conn_type;
 +	u8 conn_state;
 +	u8 wmm_idx;
 +	u8 bssid[ETH_ALEN];
 +	__le16 bmc_tx_wlan_idx;
 +	__le16 bcn_interval;
 +	u8 dtim_period;
 +	u8 phymode; /* bit(0): A
 +		     * bit(1): B
 +		     * bit(2): G
 +		     * bit(3): GN
 +		     * bit(4): AN
 +		     * bit(5): AC
 +		     */
 +	__le16 sta_idx;
 +	u8 nonht_basic_phy;
 +	u8 pad[3];
 +} __packed;
 +
 +struct mt7921_bss_qos_tlv {
 +	__le16 tag;
 +	__le16 len;
 +	u8 qos;
 +	u8 pad[3];
 +} __packed;
 +
 +struct mt7921_beacon_loss_event {
 +	u8 bss_idx;
 +	u8 reason;
 +	u8 pad[2];
 +} __packed;
 +
 +struct mt7921_mcu_scan_ssid {
 +	__le32 ssid_len;
 +	u8 ssid[IEEE80211_MAX_SSID_LEN];
 +} __packed;
 +
 +struct mt7921_mcu_scan_channel {
 +	u8 band; /* 1: 2.4GHz
 +		  * 2: 5.0GHz
 +		  * Others: Reserved
 +		  */
 +	u8 channel_num;
 +} __packed;
 +
 +struct mt7921_mcu_scan_match {
 +	__le32 rssi_th;
 +	u8 ssid[IEEE80211_MAX_SSID_LEN];
 +	u8 ssid_len;
 +	u8 rsv[3];
 +} __packed;
 +
 +struct mt7921_hw_scan_req {
 +	u8 seq_num;
 +	u8 bss_idx;
 +	u8 scan_type; /* 0: PASSIVE SCAN
 +		       * 1: ACTIVE SCAN
 +		       */
 +	u8 ssid_type; /* BIT(0) wildcard SSID
 +		       * BIT(1) P2P wildcard SSID
 +		       * BIT(2) specified SSID + wildcard SSID
 +		       * BIT(2) + ssid_type_ext BIT(0) specified SSID only
 +		       */
 +	u8 ssids_num;
 +	u8 probe_req_num; /* Number of probe request for each SSID */
 +	u8 scan_func; /* BIT(0) Enable random MAC scan
 +		       * BIT(1) Disable DBDC scan type 1~3.
 +		       * BIT(2) Use DBDC scan type 3 (dedicated one RF to scan).
 +		       */
 +	u8 version; /* 0: Not support fields after ies.
 +		     * 1: Support fields after ies.
 +		     */
 +	struct mt7921_mcu_scan_ssid ssids[4];
 +	__le16 probe_delay_time;
 +	__le16 channel_dwell_time; /* channel Dwell interval */
 +	__le16 timeout_value;
 +	u8 channel_type; /* 0: Full channels
 +			  * 1: Only 2.4GHz channels
 +			  * 2: Only 5GHz channels
 +			  * 3: P2P social channel only (channel #1, #6 and #11)
 +			  * 4: Specified channels
 +			  * Others: Reserved
 +			  */
 +	u8 channels_num; /* valid when channel_type is 4 */
 +	/* valid when channels_num is set */
 +	struct mt7921_mcu_scan_channel channels[32];
 +	__le16 ies_len;
 +	u8 ies[MT7921_SCAN_IE_LEN];
 +	/* following fields are valid if version > 0 */
 +	u8 ext_channels_num;
 +	u8 ext_ssids_num;
 +	__le16 channel_min_dwell_time;
 +	struct mt7921_mcu_scan_channel ext_channels[32];
 +	struct mt7921_mcu_scan_ssid ext_ssids[6];
 +	u8 bssid[ETH_ALEN];
 +	u8 random_mac[ETH_ALEN]; /* valid when BIT(1) in scan_func is set. */
 +	u8 pad[63];
 +	u8 ssid_type_ext;
 +} __packed;
 +
 +#define SCAN_DONE_EVENT_MAX_CHANNEL_NUM	64
 +struct mt7921_hw_scan_done {
 +	u8 seq_num;
 +	u8 sparse_channel_num;
 +	struct mt7921_mcu_scan_channel sparse_channel;
 +	u8 complete_channel_num;
 +	u8 current_state;
 +	u8 version;
 +	u8 pad;
 +	__le32 beacon_scan_num;
 +	u8 pno_enabled;
 +	u8 pad2[3];
 +	u8 sparse_channel_valid_num;
 +	u8 pad3[3];
 +	u8 channel_num[SCAN_DONE_EVENT_MAX_CHANNEL_NUM];
 +	/* idle format for channel_idle_time
 +	 * 0: first bytes: idle time(ms) 2nd byte: dwell time(ms)
 +	 * 1: first bytes: idle time(8ms) 2nd byte: dwell time(8ms)
 +	 * 2: dwell time (16us)
 +	 */
 +	__le16 channel_idle_time[SCAN_DONE_EVENT_MAX_CHANNEL_NUM];
 +	/* beacon and probe response count */
 +	u8 beacon_probe_num[SCAN_DONE_EVENT_MAX_CHANNEL_NUM];
 +	u8 mdrdy_count[SCAN_DONE_EVENT_MAX_CHANNEL_NUM];
 +	__le32 beacon_2g_num;
 +	__le32 beacon_5g_num;
 +} __packed;
 +
 +struct mt7921_sched_scan_req {
 +	u8 version;
 +	u8 seq_num;
 +	u8 stop_on_match;
 +	u8 ssids_num;
 +	u8 match_num;
 +	u8 pad;
 +	__le16 ie_len;
 +	struct mt7921_mcu_scan_ssid ssids[MT7921_MAX_SCHED_SCAN_SSID];
 +	struct mt7921_mcu_scan_match match[MT7921_MAX_SCAN_MATCH];
 +	u8 channel_type;
 +	u8 channels_num;
 +	u8 intervals_num;
 +	u8 scan_func;
 +	struct mt7921_mcu_scan_channel channels[64];
 +	__le16 intervals[MT7921_MAX_SCHED_SCAN_INTERVAL];
 +	u8 bss_idx;
 +	u8 pad2[64];
 +} __packed;
 +
 +struct mt7921_mcu_bss_event {
 +	u8 bss_idx;
 +	u8 is_absent;
 +	u8 free_quota;
 +	u8 pad;
 +} __packed;
 +
 +enum {
 +	PHY_TYPE_HR_DSSS_INDEX = 0,
 +	PHY_TYPE_ERP_INDEX,
 +	PHY_TYPE_ERP_P2P_INDEX,
 +	PHY_TYPE_OFDM_INDEX,
 +	PHY_TYPE_HT_INDEX,
 +	PHY_TYPE_VHT_INDEX,
 +	PHY_TYPE_HE_INDEX,
 +	PHY_TYPE_INDEX_NUM
 +};
 +
 +#define PHY_TYPE_BIT_HR_DSSS    BIT(PHY_TYPE_HR_DSSS_INDEX)
 +#define PHY_TYPE_BIT_ERP        BIT(PHY_TYPE_ERP_INDEX)
 +#define PHY_TYPE_BIT_OFDM       BIT(PHY_TYPE_OFDM_INDEX)
 +#define PHY_TYPE_BIT_HT         BIT(PHY_TYPE_HT_INDEX)
 +#define PHY_TYPE_BIT_VHT        BIT(PHY_TYPE_VHT_INDEX)
 +#define PHY_TYPE_BIT_HE         BIT(PHY_TYPE_HE_INDEX)
 +
 +#define MT_WTBL_RATE_TX_MODE	GENMASK(9, 6)
 +#define MT_WTBL_RATE_MCS	GENMASK(5, 0)
 +#define MT_WTBL_RATE_NSS	GENMASK(12, 10)
 +#define MT_WTBL_RATE_HE_GI	GENMASK(7, 4)
 +#define MT_WTBL_RATE_GI		GENMASK(3, 0)
 +
++=======
++>>>>>>> 80fc1e37c0eb (mt76: mt7921: rely on mt76_connac_mcu module for sched_scan and hw_scan)
  struct mt7921_mcu_tx_config {
  	u8 peer_addr[ETH_ALEN];
  	u8 sw;
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index a6d5a000d9cc,6085531cfd06..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@@ -343,18 -309,7 +338,22 @@@ int mt7921_mcu_uni_rx_ba(struct mt7921_
  			 struct ieee80211_ampdu_params *params,
  			 bool enable);
  void mt7921_scan_work(struct work_struct *work);
++<<<<<<< HEAD
 +int mt7921_mcu_set_channel_domain(struct mt7921_phy *phy);
 +int mt7921_mcu_hw_scan(struct mt7921_phy *phy, struct ieee80211_vif *vif,
 +		       struct ieee80211_scan_request *scan_req);
 +int mt7921_mcu_sched_scan_req(struct mt7921_phy *phy,
 +			      struct ieee80211_vif *vif,
 +			      struct cfg80211_sched_scan_request *sreq);
 +int mt7921_mcu_sched_scan_enable(struct mt7921_phy *phy,
 +				 struct ieee80211_vif *vif,
 +				 bool enable);
 +int mt7921_mcu_cancel_hw_scan(struct mt7921_phy *phy,
 +			      struct ieee80211_vif *vif);
 +u32 mt7921_get_wtbl_info(struct mt7921_dev *dev, u16 wlan_idx);
++=======
+ u32 mt7921_get_wtbl_info(struct mt7921_dev *dev, u32 wlan_idx);
++>>>>>>> 80fc1e37c0eb (mt76: mt7921: rely on mt76_connac_mcu module for sched_scan and hw_scan)
  int mt7921_mcu_uni_bss_ps(struct mt7921_dev *dev, struct ieee80211_vif *vif);
  int mt7921_mcu_uni_bss_bcnft(struct mt7921_dev *dev, struct ieee80211_vif *vif,
  			     bool enable);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/init.c b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
index ca293fbc682e..1db291fb3479 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
@@ -68,12 +68,13 @@ mt7921_init_wiphy(struct ieee80211_hw *hw)
 
 	wiphy->iface_combinations = if_comb;
 	wiphy->n_iface_combinations = ARRAY_SIZE(if_comb);
-	wiphy->max_scan_ie_len = MT7921_SCAN_IE_LEN;
+	wiphy->max_scan_ie_len = MT76_CONNAC_SCAN_IE_LEN;
 	wiphy->max_scan_ssids = 4;
-	wiphy->max_sched_scan_plan_interval = MT7921_MAX_SCHED_SCAN_INTERVAL;
+	wiphy->max_sched_scan_plan_interval =
+		MT76_CONNAC_MAX_SCHED_SCAN_INTERVAL;
 	wiphy->max_sched_scan_ie_len = IEEE80211_MAX_DATA_LEN;
-	wiphy->max_sched_scan_ssids = MT7921_MAX_SCHED_SCAN_SSID;
-	wiphy->max_match_sets = MT7921_MAX_SCAN_MATCH;
+	wiphy->max_sched_scan_ssids = MT76_CONNAC_MAX_SCHED_SCAN_SSID;
+	wiphy->max_match_sets = MT76_CONNAC_MAX_SCAN_MATCH;
 	wiphy->max_sched_scan_reqs = 1;
 	wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/main.c b/drivers/net/wireless/mediatek/mt76/mt7921/main.c
index 2d505d0549d7..1b4d12a5c038 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/main.c
@@ -854,7 +854,7 @@ mt7921_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	int err;
 
 	mutex_lock(&dev->mt76.mutex);
-	err = mt7921_mcu_hw_scan(mphy->priv, vif, req);
+	err = mt76_connac_mcu_hw_scan(mphy, vif, req);
 	mutex_unlock(&dev->mt76.mutex);
 
 	return err;
@@ -867,7 +867,7 @@ mt7921_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	struct mt76_phy *mphy = hw->priv;
 
 	mutex_lock(&dev->mt76.mutex);
-	mt7921_mcu_cancel_hw_scan(mphy->priv, vif);
+	mt76_connac_mcu_cancel_hw_scan(mphy, vif);
 	mutex_unlock(&dev->mt76.mutex);
 }
 
@@ -882,11 +882,11 @@ mt7921_start_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mutex_lock(&dev->mt76.mutex);
 
-	err = mt7921_mcu_sched_scan_req(mphy->priv, vif, req);
+	err = mt76_connac_mcu_sched_scan_req(mphy, vif, req);
 	if (err < 0)
 		goto out;
 
-	err = mt7921_mcu_sched_scan_enable(mphy->priv, vif, true);
+	err = mt76_connac_mcu_sched_scan_enable(mphy, vif, true);
 out:
 	mutex_unlock(&dev->mt76.mutex);
 
@@ -901,7 +901,7 @@ mt7921_stop_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	int err;
 
 	mutex_lock(&dev->mt76.mutex);
-	err = mt7921_mcu_sched_scan_enable(mphy->priv, vif, false);
+	err = mt76_connac_mcu_sched_scan_enable(mphy, vif, false);
 	mutex_unlock(&dev->mt76.mutex);
 
 	return err;
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mcu.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
