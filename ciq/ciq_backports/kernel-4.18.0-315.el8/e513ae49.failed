mt76: mt7921: abort uncompleted scan by wifi reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Sean Wang <sean.wang@mediatek.com>
commit e513ae49088bbb0d00299a9f996f88f08cca7dc6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/e513ae49.failed

Scan abort should be required for the uncompleted hardware scan
interrupted by wifi reset. Otherwise, it is possible that the scan
request after wifi reset gets error code -EBUSY from mac80211 and
then blocks the reconnectting to the access point.

Fixes: 0c1ce9884607 ("mt76: mt7921: add wifi reset support")
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit e513ae49088bbb0d00299a9f996f88f08cca7dc6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7921/mac.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index bcbd59a23f9b,3145880df6e7..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@@ -1245,50 -1335,103 +1245,75 @@@ void mt7921_mac_reset_work(struct work_
  	mt76_txq_schedule_all(&dev->mphy);
  
  	mt76_worker_disable(&dev->mt76.tx_worker);
 -	napi_disable(&dev->mt76.napi[MT_RXQ_MAIN]);
 -	napi_disable(&dev->mt76.napi[MT_RXQ_MCU]);
 -	napi_disable(&dev->mt76.napi[MT_RXQ_MCU_WA]);
 +	napi_disable(&dev->mt76.napi[0]);
 +	napi_disable(&dev->mt76.napi[1]);
 +	napi_disable(&dev->mt76.napi[2]);
  	napi_disable(&dev->mt76.tx_napi);
  
 -	mt7921_tx_token_put(dev);
 -	idr_init(&dev->token);
 -
 -	/* clean up hw queues */
 -	for (i = 0; i < ARRAY_SIZE(dev->mt76.phy.q_tx); i++)
 -		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);
 +	mutex_lock(&dev->mt76.mutex);
  
 -	for (i = 0; i < ARRAY_SIZE(dev->mt76.q_mcu); i++)
 -		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);
 +	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);
  
 -	mt76_for_each_q_rx(&dev->mt76, i)
 -		mt76_queue_rx_cleanup(dev, &dev->mt76.q_rx[i]);
 +	mt7921_tx_token_put(dev);
 +	idr_init(&dev->token);
  
 -	mt7921_wfsys_reset(dev);
 -	mt7921_dma_reset(dev);
 +	if (mt7921_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
 +		mt7921_dma_reset(&dev->phy);
  
 -	mt76_for_each_q_rx(&dev->mt76, i) {
 -		mt76_queue_rx_reset(dev, i);
 -		napi_enable(&dev->mt76.napi[i]);
 -		napi_schedule(&dev->mt76.napi[i]);
 +		mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);
 +		mt7921_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
  	}
  
 -	napi_enable(&dev->mt76.tx_napi);
 -	napi_schedule(&dev->mt76.tx_napi);
 -	mt76_worker_enable(&dev->mt76.tx_worker);
 -
  	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
 +	clear_bit(MT76_RESET, &dev->mphy.state);
  
 -	mt76_wr(dev, MT_WFDMA0_HOST_INT_ENA, 0);
 -	mt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);
 -	mt7921_irq_enable(dev,
 -			  MT_INT_RX_DONE_ALL | MT_INT_TX_DONE_ALL |
 -			  MT_INT_MCU_CMD);
 -
 -	err = mt7921_run_firmware(dev);
 -	if (err)
 -		return err;
 -
 -	err = mt7921_mcu_set_eeprom(dev);
 -	if (err)
 -		return err;
 +	mt76_worker_enable(&dev->mt76.tx_worker);
 +	napi_enable(&dev->mt76.tx_napi);
 +	napi_schedule(&dev->mt76.tx_napi);
  
 -	mt7921_mac_init(dev);
 -	return __mt7921_start(&dev->phy);
 -}
 +	napi_enable(&dev->mt76.napi[0]);
 +	napi_schedule(&dev->mt76.napi[0]);
  
 -/* system error recovery */
 -void mt7921_mac_reset_work(struct work_struct *work)
 -{
 -	struct ieee80211_hw *hw;
 -	struct mt7921_dev *dev;
 -	int i;
 +	napi_enable(&dev->mt76.napi[1]);
 +	napi_schedule(&dev->mt76.napi[1]);
  
 -	dev = container_of(work, struct mt7921_dev, reset_work);
 -	hw = mt76_hw(dev);
 +	napi_enable(&dev->mt76.napi[2]);
 +	napi_schedule(&dev->mt76.napi[2]);
  
 -	dev_err(dev->mt76.dev, "chip reset\n");
 -	ieee80211_stop_queues(hw);
 +	ieee80211_wake_queues(mt76_hw(dev));
  
 -	cancel_delayed_work_sync(&dev->mphy.mac_work);
 -	cancel_delayed_work_sync(&dev->pm.ps_work);
 -	cancel_work_sync(&dev->pm.wake_work);
 +	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_RESET_DONE);
 +	mt7921_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);
  
 -	mutex_lock(&dev->mt76.mutex);
 -	for (i = 0; i < 10; i++) {
 -		if (!mt7921_mac_reset(dev))
 -			break;
 -	}
  	mutex_unlock(&dev->mt76.mutex);
  
++<<<<<<< HEAD
 +	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
 +				     MT7921_WATCHDOG_TIME);
++=======
+ 	if (i == 10)
+ 		dev_err(dev->mt76.dev, "chip reset failed\n");
+ 
+ 	if (test_and_clear_bit(MT76_HW_SCANNING, &dev->mphy.state)) {
+ 		struct cfg80211_scan_info info = {
+ 			.aborted = true,
+ 		};
+ 
+ 		ieee80211_scan_completed(dev->mphy.hw, &info);
+ 	}
+ 
+ 	ieee80211_wake_queues(hw);
+ 	ieee80211_iterate_active_interfaces(hw,
+ 					    IEEE80211_IFACE_ITER_RESUME_ALL,
+ 					    mt7921_vif_connect_iter, 0);
+ }
+ 
+ void mt7921_reset(struct mt76_dev *mdev)
+ {
+ 	struct mt7921_dev *dev = container_of(mdev, struct mt7921_dev, mt76);
+ 
+ 	queue_work(dev->mt76.wq, &dev->reset_work);
++>>>>>>> e513ae49088b (mt76: mt7921: abort uncompleted scan by wifi reset)
  }
  
  static void
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mac.c
