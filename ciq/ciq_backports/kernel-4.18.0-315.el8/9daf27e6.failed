mt76: mt76u: use dedicated thread for status work

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 9daf27e62852d68c6ffc2c21090238ea51bb0a7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/9daf27e6.failed

Split tx and status path in mt76-usb module relying on mt76 workers APIs

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 9daf27e62852d68c6ffc2c21090238ea51bb0a7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt76.h
#	drivers/net/wireless/mediatek/mt76/usb.c
diff --cc drivers/net/wireless/mediatek/mt76/mt76.h
index 49d61ce83183,970c5f81d016..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@@ -430,7 -430,9 +430,13 @@@ struct mt76_usb 
  	u8 *data;
  	u16 data_len;
  
++<<<<<<< HEAD
 +	struct tasklet_struct rx_tasklet;
++=======
+ 	struct mt76_worker status_worker;
+ 	struct mt76_worker rx_worker;
+ 
++>>>>>>> 9daf27e62852 (mt76: mt76u: use dedicated thread for status work)
  	struct work_struct stat_work;
  
  	u8 out_ep[__MT_EP_OUT_MAX];
diff --cc drivers/net/wireless/mediatek/mt76/usb.c
index f1ae9ff835b2,7396bdae6db0..000000000000
--- a/drivers/net/wireless/mediatek/mt76/usb.c
+++ b/drivers/net/wireless/mediatek/mt76/usb.c
@@@ -1020,6 -1038,9 +1023,12 @@@ void mt76u_stop_tx(struct mt76_dev *dev
  {
  	int ret;
  
++<<<<<<< HEAD
++=======
+ 	mt76_worker_disable(&dev->tx_worker);
+ 	mt76_worker_disable(&dev->usb.status_worker);
+ 
++>>>>>>> 9daf27e62852 (mt76: mt76u: use dedicated thread for status work)
  	ret = wait_event_timeout(dev->tx_wait, !mt76_has_tx_pending(&dev->phy),
  				 HZ / 5);
  	if (!ret) {
@@@ -1061,6 -1077,9 +1070,12 @@@
  	cancel_work_sync(&dev->usb.stat_work);
  	clear_bit(MT76_READING_STATS, &dev->phy.state);
  
++<<<<<<< HEAD
++=======
+ 	mt76_worker_enable(&dev->tx_worker);
+ 	mt76_worker_enable(&dev->usb.status_worker);
+ 
++>>>>>>> 9daf27e62852 (mt76: mt76u: use dedicated thread for status work)
  	mt76_tx_status_check(dev, NULL, true);
  }
  EXPORT_SYMBOL_GPL(mt76u_stop_tx);
@@@ -1110,8 -1129,6 +1125,11 @@@ int mt76u_init(struct mt76_dev *dev
  	mt76u_ops.rmw = ext ? mt76u_rmw_ext : mt76u_rmw;
  	mt76u_ops.write_copy = ext ? mt76u_copy_ext : mt76u_copy;
  
++<<<<<<< HEAD
 +	dev->tx_worker.fn = mt76u_tx_worker;
 +	tasklet_init(&usb->rx_tasklet, mt76u_rx_tasklet, (unsigned long)dev);
++=======
++>>>>>>> 9daf27e62852 (mt76: mt76u: use dedicated thread for status work)
  	INIT_WORK(&usb->stat_work, mt76u_tx_status_data);
  
  	usb->data_len = usb_maxpacket(udev, usb_sndctrlpipe(udev, 0), 1);
@@@ -1132,14 -1149,22 +1150,31 @@@
  
  	err = mt76u_set_endpoints(intf, usb);
  	if (err < 0)
++<<<<<<< HEAD
 +		goto error;
++=======
+ 		return err;
+ 
+ 	err = mt76_worker_setup(dev->hw, &usb->rx_worker, mt76u_rx_worker,
+ 				"usb-rx");
+ 	if (err)
+ 		return err;
+ 
+ 	err = mt76_worker_setup(dev->hw, &usb->status_worker,
+ 				mt76u_status_worker, "usb-status");
+ 	if (err)
+ 		return err;
+ 
+ 	sched_set_fifo_low(usb->rx_worker.task);
+ 	sched_set_fifo_low(usb->status_worker.task);
++>>>>>>> 9daf27e62852 (mt76: mt76u: use dedicated thread for status work)
  
  	return 0;
 +
 +error:
 +	destroy_workqueue(dev->wq);
 +
 +	return err;
  }
  EXPORT_SYMBOL_GPL(mt76u_init);
  
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76.h
* Unmerged path drivers/net/wireless/mediatek/mt76/usb.c
