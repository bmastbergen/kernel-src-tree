mt76: mt7921: introduce Runtime PM support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Sean Wang <sean.wang@mediatek.com>
commit 1d8efc741df80be940e1584b5ac613dc03d58bd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/1d8efc74.failed

Introduce runtime PM to mt7921 driver

Co-developed-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 1d8efc741df80be940e1584b5ac613dc03d58bd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7921/main.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/main.c
index 2d505d0549d7,729f6c42cdde..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/main.c
@@@ -174,10 -174,11 +174,10 @@@ static int mt7921_start(struct ieee8021
  	struct mt7921_dev *dev = mt7921_hw_dev(hw);
  	struct mt7921_phy *phy = mt7921_hw_phy(hw);
  
- 	mutex_lock(&dev->mt76.mutex);
+ 	mt7921_mutex_acquire(dev);
  
 -	mt76_connac_mcu_set_mac_enable(&dev->mt76, 0, true, false);
 -	mt76_connac_mcu_set_channel_domain(phy->mt76);
 -
 +	mt7921_mcu_set_mac(dev, 0, true, false);
 +	mt7921_mcu_set_channel_domain(phy);
  	mt7921_mcu_set_chan_info(phy, MCU_EXT_CMD_SET_RX_PATH);
  	mt7921_mac_reset_counters(phy);
  	set_bit(MT76_STATE_RUNNING, &phy->mt76->state);
@@@ -197,10 -198,14 +197,19 @@@ static void mt7921_stop(struct ieee8021
  
  	cancel_delayed_work_sync(&phy->mt76->mac_work);
  
- 	mutex_lock(&dev->mt76.mutex);
+ 	cancel_delayed_work_sync(&dev->pm.ps_work);
+ 	cancel_work_sync(&dev->pm.wake_work);
+ 	mt76_connac_free_pending_tx_skbs(&dev->pm, NULL);
+ 
+ 	mt7921_mutex_acquire(dev);
  	clear_bit(MT76_STATE_RUNNING, &phy->mt76->state);
++<<<<<<< HEAD
 +	mt7921_mcu_set_mac(dev, 0, false, false);
 +	mutex_unlock(&dev->mt76.mutex);
++=======
+ 	mt76_connac_mcu_set_mac_enable(&dev->mt76, 0, false, false);
+ 	mt7921_mutex_release(dev);
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
  }
  
  static inline int get_free_idx(u32 mask, u8 start, u8 end)
@@@ -333,7 -348,15 +351,19 @@@ static void mt7921_remove_interface(str
  	if (vif == phy->monitor_vif)
  		phy->monitor_vif = NULL;
  
++<<<<<<< HEAD
 +	mt7921_mcu_uni_add_dev(dev, vif, false);
++=======
+ 	mt76_connac_free_pending_tx_skbs(&dev->pm, &msta->wcid);
+ 
+ 	if (dev->pm.enable) {
+ 		mt7921_mcu_set_bss_pm(dev, vif, false);
+ 		mt76_clear(dev, MT_WF_RFCR(0),
+ 			   MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	}
+ 
+ 	mt76_connac_mcu_uni_add_dev(&dev->mphy, vif, &mvif->sta.wcid, false);
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
  
  	rcu_assign_pointer(dev->mt76.wcid[idx], NULL);
  
@@@ -588,8 -611,14 +618,12 @@@ int mt7921_mac_sta_add(struct mt76_dev 
  	msta->wcid.tx_info |= MT_WCID_TX_INFO_SET;
  	msta->stats.jiffies = jiffies;
  
+ 	ret = mt76_connac_pm_wake(&dev->mphy, &dev->pm);
+ 	if (ret)
+ 		return ret;
+ 
  	if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)
 -		mt76_connac_mcu_uni_add_bss(&dev->mphy, vif, &mvif->sta.wcid,
 -					    true);
 -
 +		mt7921_mcu_uni_add_bss(&dev->phy, vif, true);
  	mt7921_mac_wtbl_update(dev, idx,
  			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
  
@@@ -606,11 -638,21 +642,20 @@@ void mt7921_mac_sta_remove(struct mt76_
  	struct mt7921_dev *dev = container_of(mdev, struct mt7921_dev, mt76);
  	struct mt7921_sta *msta = (struct mt7921_sta *)sta->drv_priv;
  
++<<<<<<< HEAD
 +	mt7921_mcu_uni_add_sta(dev, vif, sta, false);
++=======
+ 	mt76_connac_free_pending_tx_skbs(&dev->pm, &msta->wcid);
+ 	mt76_connac_pm_wake(&dev->mphy, &dev->pm);
+ 
+ 	mt76_connac_mcu_add_sta_cmd(&dev->mphy, vif, sta, &msta->wcid, false,
+ 				    MCU_UNI_CMD_STA_REC_UPDATE);
+ 
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
  	mt7921_mac_wtbl_update(dev, msta->wcid.idx,
  			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
 -
 -	if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {
 -		struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 -
 -		mt76_connac_mcu_uni_add_bss(&dev->mphy, vif, &mvif->sta.wcid,
 -					    false);
 -	}
 +	if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)
 +		mt7921_mcu_uni_add_bss(&dev->phy, vif, false);
  
  	spin_lock_bh(&dev->sta_poll_lock);
  	if (!list_empty(&msta->poll_list))
@@@ -650,11 -726,10 +729,17 @@@ static void mt7921_tx(struct ieee80211_
  static int mt7921_set_rts_threshold(struct ieee80211_hw *hw, u32 val)
  {
  	struct mt7921_dev *dev = mt7921_hw_dev(hw);
 +	struct mt7921_phy *phy = mt7921_hw_phy(hw);
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->mt76.mutex);
 +	mt7921_mcu_set_rts_thresh(phy, val);
 +	mutex_unlock(&dev->mt76.mutex);
++=======
+ 	mt7921_mutex_acquire(dev);
+ 	mt76_connac_mcu_set_rts_thresh(&dev->mt76, val, 0);
+ 	mt7921_mutex_release(dev);
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
  
  	return 0;
  }
@@@ -853,9 -928,9 +938,15 @@@ mt7921_hw_scan(struct ieee80211_hw *hw
  	struct mt76_phy *mphy = hw->priv;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->mt76.mutex);
 +	err = mt7921_mcu_hw_scan(mphy->priv, vif, req);
 +	mutex_unlock(&dev->mt76.mutex);
++=======
+ 	mt7921_mutex_acquire(dev);
+ 	err = mt76_connac_mcu_hw_scan(mphy, vif, req);
+ 	mt7921_mutex_release(dev);
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
  
  	return err;
  }
@@@ -866,9 -941,9 +957,15 @@@ mt7921_cancel_hw_scan(struct ieee80211_
  	struct mt7921_dev *dev = mt7921_hw_dev(hw);
  	struct mt76_phy *mphy = hw->priv;
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->mt76.mutex);
 +	mt7921_mcu_cancel_hw_scan(mphy->priv, vif);
 +	mutex_unlock(&dev->mt76.mutex);
++=======
+ 	mt7921_mutex_acquire(dev);
+ 	mt76_connac_mcu_cancel_hw_scan(mphy, vif);
+ 	mt7921_mutex_release(dev);
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
  }
  
  static int
@@@ -880,15 -955,15 +977,15 @@@ mt7921_start_sched_scan(struct ieee8021
  	struct mt76_phy *mphy = hw->priv;
  	int err;
  
- 	mutex_lock(&dev->mt76.mutex);
+ 	mt7921_mutex_acquire(dev);
  
 -	err = mt76_connac_mcu_sched_scan_req(mphy, vif, req);
 +	err = mt7921_mcu_sched_scan_req(mphy->priv, vif, req);
  	if (err < 0)
  		goto out;
  
 -	err = mt76_connac_mcu_sched_scan_enable(mphy, vif, true);
 +	err = mt7921_mcu_sched_scan_enable(mphy->priv, vif, true);
  out:
- 	mutex_unlock(&dev->mt76.mutex);
+ 	mt7921_mutex_release(dev);
  
  	return err;
  }
@@@ -900,9 -975,9 +997,15 @@@ mt7921_stop_sched_scan(struct ieee80211
  	struct mt76_phy *mphy = hw->priv;
  	int err;
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->mt76.mutex);
 +	err = mt7921_mcu_sched_scan_enable(mphy->priv, vif, false);
 +	mutex_unlock(&dev->mt76.mutex);
++=======
+ 	mt7921_mutex_acquire(dev);
+ 	err = mt76_connac_mcu_sched_scan_enable(mphy, vif, false);
+ 	mt7921_mutex_release(dev);
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
  
  	return err;
  }
@@@ -984,11 -1062,12 +1090,11 @@@ static int mt7921_suspend(struct ieee80
  	set_bit(MT76_STATE_SUSPEND, &phy->mt76->state);
  	ieee80211_iterate_active_interfaces(hw,
  					    IEEE80211_IFACE_ITER_RESUME_ALL,
 -					    mt76_connac_mcu_set_suspend_iter,
 -					    &dev->mphy);
 +					    mt7921_mcu_set_suspend_iter, phy);
  
 -	err = mt76_connac_mcu_set_hif_suspend(&dev->mt76, true);
 +	err = mt7921_mcu_set_hif_suspend(dev, true);
  
- 	mutex_unlock(&dev->mt76.mutex);
+ 	mt7921_mutex_release(dev);
  
  	return err;
  }
@@@ -999,9 -1078,9 +1105,9 @@@ static int mt7921_resume(struct ieee802
  	struct mt7921_phy *phy = mt7921_hw_phy(hw);
  	int err;
  
- 	mutex_lock(&dev->mt76.mutex);
+ 	mt7921_mutex_acquire(dev);
  
 -	err = mt76_connac_mcu_set_hif_suspend(&dev->mt76, false);
 +	err = mt7921_mcu_set_hif_suspend(dev, false);
  	if (err < 0)
  		goto out;
  
@@@ -1033,9 -1114,9 +1140,15 @@@ static void mt7921_set_rekey_data(struc
  {
  	struct mt7921_dev *dev = mt7921_hw_dev(hw);
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->mt76.mutex);
 +	mt7921_mcu_update_gtk_rekey(hw, vif, data);
 +	mutex_unlock(&dev->mt76.mutex);
++=======
+ 	mt7921_mutex_acquire(dev);
+ 	mt76_connac_mcu_update_gtk_rekey(hw, vif, data);
+ 	mt7921_mutex_release(dev);
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
  }
  #endif /* CONFIG_PM */
  
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
index 77055ff812eb,6ad313fd398e..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
@@@ -1694,9 -893,11 +1694,11 @@@ static int mt7921_load_firmware(struct 
  	mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_FWDL], false);
  
  #ifdef CONFIG_PM
 -	dev->mt76.hw->wiphy->wowlan = &mt76_connac_wowlan_support;
 +	dev->mt76.hw->wiphy->wowlan = &mt7921_wowlan_support;
  #endif /* CONFIG_PM */
  
+ 	clear_bit(MT76_STATE_PM, &dev->mphy.state);
+ 
  	dev_err(dev->mt76.dev, "Firmware init done\n");
  
  	return 0;
@@@ -2624,296 -1235,69 +2626,365 @@@ int mt7921_mcu_set_bss_pm(struct mt7921
  				 sizeof(req), false);
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PM
 +int mt7921_mcu_set_hif_suspend(struct mt7921_dev *dev, bool suspend)
 +{
 +	struct {
 +		struct {
 +			u8 hif_type; /* 0x0: HIF_SDIO
 +				      * 0x1: HIF_USB
 +				      * 0x2: HIF_PCIE
 +				      */
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct hif_suspend_tlv {
 +			__le16 tag;
 +			__le16 len;
 +			u8 suspend;
 +		} __packed hif_suspend;
 +	} req = {
 +		.hif_suspend = {
 +			.tag = cpu_to_le16(0), /* 0: UNI_HIF_CTRL_BASIC */
 +			.len = cpu_to_le16(sizeof(struct hif_suspend_tlv)),
 +			.suspend = suspend,
 +		},
 +	};
 +
 +	if (mt76_is_mmio(&dev->mt76))
 +		req.hdr.hif_type = 2;
 +	else if (mt76_is_usb(&dev->mt76))
 +		req.hdr.hif_type = 1;
 +	else if (mt76_is_sdio(&dev->mt76))
 +		req.hdr.hif_type = 0;
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_HIF_CTRL, &req,
 +				 sizeof(req), true);
 +}
 +EXPORT_SYMBOL_GPL(mt7921_mcu_set_hif_suspend);
 +
 +static int
 +mt7921_mcu_set_wow_ctrl(struct mt7921_phy *phy, struct ieee80211_vif *vif,
 +			bool suspend, struct cfg80211_wowlan *wowlan)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_dev *dev = phy->dev;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_wow_ctrl_tlv wow_ctrl_tlv;
 +		struct mt7921_wow_gpio_param_tlv gpio_tlv;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.wow_ctrl_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_WOW_CTRL),
 +			.len = cpu_to_le16(sizeof(struct mt7921_wow_ctrl_tlv)),
 +			.cmd = suspend ? 1 : 2,
 +		},
 +		.gpio_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_WOW_GPIO_PARAM),
 +			.len = cpu_to_le16(sizeof(struct mt7921_wow_gpio_param_tlv)),
 +			.gpio_pin = 0xff, /* follow fw about GPIO pin */
 +		},
 +	};
 +
 +	if (wowlan->magic_pkt)
 +		req.wow_ctrl_tlv.trigger |= BIT(0);
 +	if (wowlan->disconnect)
 +		req.wow_ctrl_tlv.trigger |= BIT(2);
 +	if (wowlan->nd_config) {
 +		mt7921_mcu_sched_scan_req(phy, vif, wowlan->nd_config);
 +		req.wow_ctrl_tlv.trigger |= BIT(5);
 +		mt7921_mcu_sched_scan_enable(phy, vif, suspend);
 +	}
 +
 +	if (mt76_is_mmio(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_PCIE;
 +	else if (mt76_is_usb(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_USB;
 +	else if (mt76_is_sdio(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_GPIO;
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_SUSPEND, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_wow_pattern(struct mt7921_dev *dev,
 +			   struct ieee80211_vif *vif,
 +			   u8 index, bool enable,
 +			   struct cfg80211_pkt_pattern *pattern)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_wow_pattern_tlv *ptlv;
 +	struct sk_buff *skb;
 +	struct req_hdr {
 +		u8 bss_idx;
 +		u8 pad[3];
 +	} __packed hdr = {
 +		.bss_idx = mvif->mt76.idx,
 +	};
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(hdr) + sizeof(*ptlv));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &hdr, sizeof(hdr));
 +	ptlv = (struct mt7921_wow_pattern_tlv *)skb_put(skb, sizeof(*ptlv));
 +	ptlv->tag = cpu_to_le16(UNI_SUSPEND_WOW_PATTERN);
 +	ptlv->len = cpu_to_le16(sizeof(*ptlv));
 +	ptlv->data_len = pattern->pattern_len;
 +	ptlv->enable = enable;
 +	ptlv->index = index;
 +
 +	memcpy(ptlv->pattern, pattern->pattern, pattern->pattern_len);
 +	memcpy(ptlv->mask, pattern->mask, pattern->pattern_len / 8);
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_UNI_CMD_SUSPEND,
 +				     true);
 +}
 +
 +static int
 +mt7921_mcu_set_suspend_mode(struct mt7921_dev *dev,
 +			    struct ieee80211_vif *vif,
 +			    bool enable, u8 mdtim, bool wow_suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_suspend_tlv suspend_tlv;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.suspend_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_MODE_SETTING),
 +			.len = cpu_to_le16(sizeof(struct mt7921_suspend_tlv)),
 +			.enable = enable,
 +			.mdtim = mdtim,
 +			.wow_suspend = wow_suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_SUSPEND, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_gtk_rekey(struct mt7921_dev *dev,
 +			 struct ieee80211_vif *vif,
 +			 bool suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_gtk_rekey_tlv gtk_tlv;
 +	} __packed req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.gtk_tlv = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY),
 +			.len = cpu_to_le16(sizeof(struct mt7921_gtk_rekey_tlv)),
 +			.rekey_mode = !suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_OFFLOAD, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_arp_filter(struct mt7921_dev *dev, struct ieee80211_vif *vif,
 +			  bool suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_arpns_tlv arpns;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.arpns = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ARP),
 +			.len = cpu_to_le16(sizeof(struct mt7921_arpns_tlv)),
 +			.mode = suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_OFFLOAD, &req,
 +				 sizeof(req), true);
 +}
 +
 +void mt7921_mcu_set_suspend_iter(void *priv, u8 *mac,
 +				 struct ieee80211_vif *vif)
 +{
 +	struct mt7921_phy *phy = priv;
 +	bool suspend = test_bit(MT76_STATE_SUSPEND, &phy->mt76->state);
 +	struct ieee80211_hw *hw = phy->mt76->hw;
 +	struct cfg80211_wowlan *wowlan = hw->wiphy->wowlan_config;
 +	int i;
 +
 +	mt7921_mcu_set_gtk_rekey(phy->dev, vif, suspend);
 +	mt7921_mcu_set_arp_filter(phy->dev, vif, suspend);
 +
 +	mt7921_mcu_set_suspend_mode(phy->dev, vif, suspend, 1, true);
 +
 +	for (i = 0; i < wowlan->n_patterns; i++)
 +		mt7921_mcu_set_wow_pattern(phy->dev, vif, i, suspend,
 +					   &wowlan->patterns[i]);
 +	mt7921_mcu_set_wow_ctrl(phy, vif, suspend, wowlan);
 +}
 +
 +static void
 +mt7921_mcu_key_iter(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 +		    struct ieee80211_sta *sta, struct ieee80211_key_conf *key,
 +		    void *data)
 +{
 +	struct mt7921_gtk_rekey_tlv *gtk_tlv = data;
 +	u32 cipher;
 +
 +	if (key->cipher != WLAN_CIPHER_SUITE_AES_CMAC &&
 +	    key->cipher != WLAN_CIPHER_SUITE_CCMP &&
 +	    key->cipher != WLAN_CIPHER_SUITE_TKIP)
 +		return;
 +
 +	if (key->cipher == WLAN_CIPHER_SUITE_TKIP) {
 +		gtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_1);
 +		cipher = BIT(3);
 +	} else {
 +		gtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_2);
 +		cipher = BIT(4);
 +	}
 +
 +	/* we are assuming here to have a single pairwise key */
 +	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {
 +		gtk_tlv->pairwise_cipher = cpu_to_le32(cipher);
 +		gtk_tlv->group_cipher = cpu_to_le32(cipher);
 +		gtk_tlv->keyid = key->keyidx;
 +	}
 +}
 +
 +int mt7921_mcu_update_gtk_rekey(struct ieee80211_hw *hw,
 +				struct ieee80211_vif *vif,
 +				struct cfg80211_gtk_rekey_data *key)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_dev *dev = mt7921_hw_dev(hw);
 +	struct mt7921_gtk_rekey_tlv *gtk_tlv;
 +	struct sk_buff *skb;
 +	struct {
 +		u8 bss_idx;
 +		u8 pad[3];
 +	} __packed hdr = {
 +		.bss_idx = mvif->mt76.idx,
 +	};
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(hdr) + sizeof(*gtk_tlv));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &hdr, sizeof(hdr));
 +	gtk_tlv = (struct mt7921_gtk_rekey_tlv *)skb_put(skb,
 +							 sizeof(*gtk_tlv));
 +	gtk_tlv->tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY);
 +	gtk_tlv->len = cpu_to_le16(sizeof(*gtk_tlv));
 +	gtk_tlv->rekey_mode = 2;
 +	gtk_tlv->option = 1;
 +
 +	rcu_read_lock();
 +	ieee80211_iter_keys_rcu(hw, vif, mt7921_mcu_key_iter, gtk_tlv);
 +	rcu_read_unlock();
 +
 +	memcpy(gtk_tlv->kek, key->kek, NL80211_KEK_LEN);
 +	memcpy(gtk_tlv->kck, key->kck, NL80211_KCK_LEN);
 +	memcpy(gtk_tlv->replay_ctr, key->replay_ctr, NL80211_REPLAY_CTR_LEN);
 +
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_UNI_CMD_OFFLOAD,
 +				     true);
 +}
 +#endif /* CONFIG_PM */
++=======
+ int mt7921_mcu_drv_pmctrl(struct mt7921_dev *dev)
+ {
+ 	struct mt76_phy *mphy = &dev->mt76.phy;
+ 	int i;
+ 
+ 	if (!test_and_clear_bit(MT76_STATE_PM, &mphy->state))
+ 		goto out;
+ 
+ 	for (i = 0; i < MT7921_DRV_OWN_RETRY_COUNT; i++) {
+ 		mt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_CLR_OWN);
+ 		if (mt76_poll_msec(dev, MT_CONN_ON_LPCTL,
+ 				   PCIE_LPCR_HOST_OWN_SYNC, 0, 50))
+ 			break;
+ 	}
+ 
+ 	if (i == MT7921_DRV_OWN_RETRY_COUNT) {
+ 		dev_err(dev->mt76.dev, "driver own failed\n");
+ 		return -EIO;
+ 	}
+ 
+ out:
+ 	dev->pm.last_activity = jiffies;
+ 
+ 	return 0;
+ }
+ 
+ int mt7921_mcu_fw_pmctrl(struct mt7921_dev *dev)
+ {
+ 	struct mt76_phy *mphy = &dev->mt76.phy;
+ 	int i;
+ 
+ 	if (test_and_set_bit(MT76_STATE_PM, &mphy->state))
+ 		return 0;
+ 
+ 	for (i = 0; i < MT7921_DRV_OWN_RETRY_COUNT; i++) {
+ 		mt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_SET_OWN);
+ 		if (mt76_poll_msec(dev, MT_CONN_ON_LPCTL,
+ 				   PCIE_LPCR_HOST_OWN_SYNC, 4, 50))
+ 			break;
+ 	}
+ 
+ 	if (i == MT7921_DRV_OWN_RETRY_COUNT) {
+ 		dev_err(dev->mt76.dev, "firmware own failed\n");
+ 		return -EIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void
+ mt7921_pm_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)
+ {
+ 	struct mt7921_phy *phy = priv;
+ 	struct mt7921_dev *dev = phy->dev;
+ 
+ 	if (mt7921_mcu_set_bss_pm(dev, vif, dev->pm.enable))
+ 		return;
+ 
+ 	if (dev->pm.enable) {
+ 		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_set(dev, MT_WF_RFCR(0), MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	} else {
+ 		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_clear(dev, MT_WF_RFCR(0), MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	}
+ }
++>>>>>>> 1d8efc741df8 (mt76: mt7921: introduce Runtime PM support)
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c b/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
index 9cdeb14cc933..390e0e49724d 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
@@ -159,6 +159,60 @@ mt7921_queues_read(struct seq_file *s, void *data)
 	return 0;
 }
 
+static int
+mt7921_pm_set(void *data, u64 val)
+{
+	struct mt7921_dev *dev = data;
+	struct mt76_phy *mphy = dev->phy.mt76;
+	int ret = 0;
+
+	mt7921_mutex_acquire(dev);
+
+	dev->pm.enable = val;
+
+	ieee80211_iterate_active_interfaces(mphy->hw,
+					    IEEE80211_IFACE_ITER_RESUME_ALL,
+					    mt7921_pm_interface_iter, mphy->priv);
+	mt7921_mutex_release(dev);
+
+	return ret;
+}
+
+static int
+mt7921_pm_get(void *data, u64 *val)
+{
+	struct mt7921_dev *dev = data;
+
+	*val = dev->pm.enable;
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_pm, mt7921_pm_get, mt7921_pm_set, "%lld\n");
+
+static int
+mt7921_pm_idle_timeout_set(void *data, u64 val)
+{
+	struct mt7921_dev *dev = data;
+
+	dev->pm.idle_timeout = msecs_to_jiffies(val);
+
+	return 0;
+}
+
+static int
+mt7921_pm_idle_timeout_get(void *data, u64 *val)
+{
+	struct mt7921_dev *dev = data;
+
+	*val = jiffies_to_msecs(dev->pm.idle_timeout);
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_pm_idle_timeout, mt7921_pm_idle_timeout_get,
+			 mt7921_pm_idle_timeout_set, "%lld\n");
+
 int mt7921_init_debugfs(struct mt7921_dev *dev)
 {
 	struct dentry *dir;
@@ -173,6 +227,9 @@ int mt7921_init_debugfs(struct mt7921_dev *dev)
 				    mt7921_queues_acq);
 	debugfs_create_file("tx_stats", 0400, dir, dev, &fops_tx_stats);
 	debugfs_create_file("fw_debug", 0600, dir, dev, &fops_fw_debug);
+	debugfs_create_file("runtime-pm", 0600, dir, dev, &fops_pm);
+	debugfs_create_file("idle-timeout", 0600, dir, dev,
+			    &fops_pm_idle_timeout);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/init.c b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
index ca293fbc682e..3f58ee48614c 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
@@ -199,6 +199,12 @@ int mt7921_register_device(struct mt7921_dev *dev)
 	dev->phy.dev = dev;
 	dev->phy.mt76 = &dev->mt76.phy;
 	dev->mt76.phy.priv = &dev->phy;
+
+	INIT_DELAYED_WORK(&dev->pm.ps_work, mt7921_pm_power_save_work);
+	INIT_WORK(&dev->pm.wake_work, mt7921_pm_wake_work);
+	init_completion(&dev->pm.wake_cmpl);
+	spin_lock_init(&dev->pm.txq_lock);
+	set_bit(MT76_STATE_PM, &dev->mphy.state);
 	INIT_LIST_HEAD(&dev->phy.stats_list);
 	INIT_DELAYED_WORK(&dev->mphy.mac_work, mt7921_mac_work);
 	INIT_DELAYED_WORK(&dev->phy.scan_work, mt7921_scan_work);
@@ -214,6 +220,7 @@ int mt7921_register_device(struct mt7921_dev *dev)
 		return ret;
 
 	mt7921_init_wiphy(hw);
+	dev->pm.idle_timeout = MT7921_PM_TIMEOUT;
 	dev->mphy.sband_2g.sband.ht_cap.cap |=
 			IEEE80211_HT_CAP_LDPC_CODING |
 			IEEE80211_HT_CAP_MAX_AMSDU;
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index 968894cfc98b..006cf7fe1bff 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@ -1001,22 +1001,27 @@ void mt7921_mac_tx_free(struct mt7921_dev *dev, struct sk_buff *skb)
 		mt76_put_txwi(mdev, txwi);
 	}
 
-	mt7921_mac_sta_poll(dev);
-
 	if (wake) {
 		spin_lock_bh(&dev->token_lock);
 		mt7921_set_tx_blocked(dev, false);
 		spin_unlock_bh(&dev->token_lock);
 	}
 
-	mt76_worker_schedule(&dev->mt76.tx_worker);
-
 	napi_consume_skb(skb, 1);
 
 	list_for_each_entry_safe(skb, tmp, &free_list, list) {
 		skb_list_del_init(skb);
 		napi_consume_skb(skb, 1);
 	}
+
+	if (test_bit(MT76_STATE_PM, &dev->phy.mt76->state))
+		return;
+
+	mt7921_mac_sta_poll(dev);
+
+	mt76_connac_power_save_sched(&dev->mphy, &dev->pm);
+
+	mt76_worker_schedule(&dev->mt76.tx_worker);
 }
 
 void mt7921_tx_complete_skb(struct mt76_dev *mdev, struct mt76_queue_entry *e)
@@ -1166,9 +1171,14 @@ void mt7921_update_channel(struct mt76_dev *mdev)
 {
 	struct mt7921_dev *dev = container_of(mdev, struct mt7921_dev, mt76);
 
+	if (mt76_connac_pm_wake(&dev->mphy, &dev->pm))
+		return;
+
 	mt7921_phy_update_channel(&mdev->phy, 0);
 	/* reset obss airtime */
 	mt76_set(dev, MT_WF_RMAC_MIB_TIME0(0), MT_WF_RMAC_MIB_RXTIME_CLR);
+
+	mt76_connac_power_save_sched(&dev->mphy, &dev->pm);
 }
 
 static bool
@@ -1257,7 +1267,7 @@ void mt7921_mac_reset_work(struct work_struct *work)
 	napi_disable(&dev->mt76.napi[2]);
 	napi_disable(&dev->mt76.tx_napi);
 
-	mutex_lock(&dev->mt76.mutex);
+	mt7921_mutex_acquire(dev);
 
 	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);
 
@@ -1292,7 +1302,7 @@ void mt7921_mac_reset_work(struct work_struct *work)
 	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_RESET_DONE);
 	mt7921_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);
 
-	mutex_unlock(&dev->mt76.mutex);
+	mt7921_mutex_release(dev);
 
 	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
 				     MT7921_WATCHDOG_TIME);
@@ -1373,7 +1383,10 @@ void mt7921_mac_work(struct work_struct *work)
 					       mac_work.work);
 	phy = mphy->priv;
 
-	mutex_lock(&mphy->dev->mutex);
+	if (test_bit(MT76_STATE_PM, &mphy->state))
+		goto out;
+
+	mt7921_mutex_acquire(phy->dev);
 
 	mt76_update_survey(mphy->dev);
 	if (++mphy->mac_work_count == 5) {
@@ -1386,8 +1399,75 @@ void mt7921_mac_work(struct work_struct *work)
 		mt7921_mac_sta_stats_work(phy);
 	};
 
-	mutex_unlock(&mphy->dev->mutex);
+	mt7921_mutex_release(phy->dev);
 
-	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
+out:
+	ieee80211_queue_delayed_work(phy->mt76->hw, &mphy->mac_work,
 				     MT7921_WATCHDOG_TIME);
 }
+
+void mt7921_pm_wake_work(struct work_struct *work)
+{
+	struct mt7921_dev *dev;
+	struct mt76_phy *mphy;
+
+	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+						pm.wake_work);
+	mphy = dev->phy.mt76;
+
+	if (!mt7921_mcu_drv_pmctrl(dev))
+		mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
+	else
+		dev_err(mphy->dev->dev, "failed to wake device\n");
+
+	ieee80211_wake_queues(mphy->hw);
+	complete_all(&dev->pm.wake_cmpl);
+}
+
+void mt7921_pm_power_save_work(struct work_struct *work)
+{
+	struct mt7921_dev *dev;
+	unsigned long delta;
+
+	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+						pm.ps_work.work);
+
+	delta = dev->pm.idle_timeout;
+	if (time_is_after_jiffies(dev->pm.last_activity + delta)) {
+		delta = dev->pm.last_activity + delta - jiffies;
+		goto out;
+	}
+
+	if (!mt7921_mcu_fw_pmctrl(dev))
+		return;
+out:
+	queue_delayed_work(dev->mt76.wq, &dev->pm.ps_work, delta);
+}
+
+int mt7921_mac_set_beacon_filter(struct mt7921_phy *phy,
+				 struct ieee80211_vif *vif,
+				 bool enable)
+{
+	struct mt7921_dev *dev = phy->dev;
+	bool ext_phy = phy != &dev->phy;
+	int err;
+
+	if (!dev->pm.enable)
+		return -EOPNOTSUPP;
+
+	err = mt7921_mcu_set_bss_pm(dev, vif, enable);
+	if (err)
+		return err;
+
+	if (enable) {
+		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
+		mt76_set(dev, MT_WF_RFCR(ext_phy),
+			 MT_WF_RFCR_DROP_OTHER_BEACON);
+	} else {
+		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
+		mt76_clear(dev, MT_WF_RFCR(ext_phy),
+			   MT_WF_RFCR_DROP_OTHER_BEACON);
+	}
+
+	return 0;
+}
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/main.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index a6d5a000d9cc..528eefccafa8 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@ -6,7 +6,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/ktime.h>
-#include "../mt76.h"
+#include "../mt76_connac.h"
 #include "regs.h"
 
 #define MT7921_MAX_INTERFACES		4
@@ -16,6 +16,7 @@
 #define MT7921_WTBL_STA			(MT7921_WTBL_RESERVED - \
 					 MT7921_MAX_INTERFACES)
 
+#define MT7921_PM_TIMEOUT		(HZ / 12)
 #define MT7921_HW_SCAN_TIMEOUT		(HZ / 10)
 #define MT7921_WATCHDOG_TIME		(HZ / 10)
 #define MT7921_RESET_TIMEOUT		(30 * HZ)
@@ -27,6 +28,8 @@
 #define MT7921_RX_RING_SIZE		1536
 #define MT7921_RX_MCU_RING_SIZE		512
 
+#define MT7921_DRV_OWN_RETRY_COUNT	10
+
 #define MT7921_FIRMWARE_WM		"mediatek/WIFI_RAM_CODE_MT7961_1.bin"
 #define MT7921_ROM_PATCH		"mediatek/WIFI_MT7961_patch_mcu_1_2_hdr.bin"
 
@@ -164,6 +167,8 @@ struct mt7921_dev {
 	struct idr token;
 
 	u8 fw_debug;
+
+	struct mt76_connac_pm pm;
 };
 
 enum {
@@ -206,6 +211,11 @@ mt7921_hw_dev(struct ieee80211_hw *hw)
 	return container_of(phy->dev, struct mt7921_dev, mt76);
 }
 
+#define mt7921_mutex_acquire(dev)	\
+	mt76_connac_mutex_acquire(&(dev)->mt76, &(dev)->pm)
+#define mt7921_mutex_release(dev)	\
+	mt76_connac_mutex_release(&(dev)->mt76, &(dev)->pm)
+
 static inline u8 mt7921_lmac_mapping(struct mt7921_dev *dev, u8 ac)
 {
 	/* LMAC uses the reverse order of mac80211 AC indexes */
@@ -369,4 +379,13 @@ int mt7921_mcu_update_gtk_rekey(struct ieee80211_hw *hw,
 int mt7921_mcu_update_arp_filter(struct ieee80211_hw *hw,
 				 struct ieee80211_vif *vif,
 				 struct ieee80211_bss_conf *info);
+int mt7921_mcu_drv_pmctrl(struct mt7921_dev *dev);
+int mt7921_mcu_fw_pmctrl(struct mt7921_dev *dev);
+void mt7921_pm_wake_work(struct work_struct *work);
+void mt7921_pm_power_save_work(struct work_struct *work);
+bool mt7921_wait_for_mcu_init(struct mt7921_dev *dev);
+int mt7921_mac_set_beacon_filter(struct mt7921_phy *phy,
+				 struct ieee80211_vif *vif,
+				 bool enable);
+void mt7921_pm_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif);
 #endif
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/pci.c b/drivers/net/wireless/mediatek/mt76/mt7921/pci.c
index 202cde1b6289..e125fbf6c187 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/pci.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/pci.c
@@ -175,6 +175,10 @@ static int mt7921_pci_suspend(struct pci_dev *pdev, pm_message_t state)
 	bool hif_suspend;
 	int i, err;
 
+	err = mt76_connac_pm_wake(&dev->mphy, &dev->pm);
+	if (err < 0)
+		return err;
+
 	hif_suspend = !test_bit(MT76_STATE_SUSPEND, &dev->mphy.state);
 	if (hif_suspend) {
 		err = mt7921_mcu_set_hif_suspend(dev, true);
@@ -209,6 +213,10 @@ static int mt7921_pci_suspend(struct pci_dev *pdev, pm_message_t state)
 	if (err)
 		goto restore;
 
+	err = mt7921_mcu_drv_pmctrl(dev);
+	if (err)
+		goto restore;
+
 	return 0;
 
 restore:
@@ -228,6 +236,10 @@ static int mt7921_pci_resume(struct pci_dev *pdev)
 	struct mt7921_dev *dev = container_of(mdev, struct mt7921_dev, mt76);
 	int i, err;
 
+	err = mt7921_mcu_fw_pmctrl(dev);
+	if (err < 0)
+		return err;
+
 	err = pci_set_power_state(pdev, PCI_D0);
 	if (err)
 		return err;
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/regs.h b/drivers/net/wireless/mediatek/mt76/mt7921/regs.h
index 2071eeec04d7..18980bb32dee 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/regs.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/regs.h
@@ -408,6 +408,11 @@
 
 #define MT_DMASHDL_SCHED_SET(_n)	MT_DMA_SHDL(0x070 + ((_n) << 2))
 
+#define MT_CONN_ON_LPCTL		0x7c060010
+#define PCIE_LPCR_HOST_OWN_SYNC		BIT(2)
+#define PCIE_LPCR_HOST_CLR_OWN		BIT(1)
+#define PCIE_LPCR_HOST_SET_OWN		BIT(0)
+
 #define MT_CONN_ON_MISC			0x7c0600f0
 #define MT_TOP_MISC2_FW_N9_RDY		GENMASK(1, 0)
 
