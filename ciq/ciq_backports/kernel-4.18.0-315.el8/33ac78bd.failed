PCI/AER: Specify the type of Port that was reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Keith Busch <kbusch@kernel.org>
commit 33ac78bd3b509d36e7f109a447e28af42e637cb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/33ac78bd.failed

The AER driver may be called upon to reset either a Downstream or a Root
Port. Check which type it is to properly identify it when logging that
the reset occurred.

Link: https://lore.kernel.org/r/20210104230300.1277180-5-kbusch@kernel.org
	Tested-by: Hedi Berriche <hedi.berriche@hpe.com>
	Signed-off-by: Keith Busch <kbusch@kernel.org>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Hedi Berriche <hedi.berriche@hpe.com>
(cherry picked from commit 33ac78bd3b509d36e7f109a447e28af42e637cb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pcie/aer.c
diff --cc drivers/pci/pcie/aer.c
index 60c49c452658,ba22388342d1..000000000000
--- a/drivers/pci/pcie/aer.c
+++ b/drivers/pci/pcie/aer.c
@@@ -1369,25 -1380,53 +1369,41 @@@ static pci_ers_result_t aer_root_reset(
  	u32 reg32;
  	int rc;
  
 -	/*
 -	 * Only Root Ports and RCECs have AER Root Command and Root Status
 -	 * registers.  If "dev" is an RCiEP, the relevant registers are in
 -	 * the RCEC.
 -	 */
 -	if (type == PCI_EXP_TYPE_RC_END)
 -		root = dev->rcec;
 -	else
 -		root = pcie_find_root_port(dev);
 -
 -	/*
 -	 * If the platform retained control of AER, an RCiEP may not have
 -	 * an RCEC visible to us, so dev->rcec ("root") may be NULL.  In
 -	 * that case, firmware is responsible for these registers.
 -	 */
 -	aer = root ? root->aer_cap : 0;
 -
 -	if ((host->native_aer || pcie_ports_native) && aer) {
 +	if (pcie_aer_is_native(dev)) {
  		/* Disable Root's interrupt in response to error messages */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, &reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, &reg32);
  		reg32 &= ~ROOT_PORT_INTR_ON_MESG_MASK;
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, reg32);
  	}
  
++<<<<<<< HEAD
 +	rc = pci_bus_error_reset(dev);
 +	pci_info(dev, "Root Port link has been reset (%d)\n", rc);
++=======
+ 	if (type == PCI_EXP_TYPE_RC_EC || type == PCI_EXP_TYPE_RC_END) {
+ 		if (pcie_has_flr(dev)) {
+ 			rc = pcie_flr(dev);
+ 			pci_info(dev, "has been reset (%d)\n", rc);
+ 		} else {
+ 			pci_info(dev, "not reset (no FLR support)\n");
+ 			rc = -ENOTTY;
+ 		}
+ 	} else {
+ 		rc = pci_bus_error_reset(dev);
+ 		pci_info(dev, "%s Port link has been reset (%d)\n",
+ 			pci_is_root_bus(dev->bus) ? "Root" : "Downstream", rc);
+ 	}
++>>>>>>> 33ac78bd3b50 (PCI/AER: Specify the type of Port that was reset)
  
 -	if ((host->native_aer || pcie_ports_native) && aer) {
 +	if (pcie_aer_is_native(dev)) {
  		/* Clear Root Error Status */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_STATUS, &reg32);
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_STATUS, reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_STATUS, &reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_STATUS, reg32);
  
  		/* Enable Root Port's interrupt in response to error messages */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, &reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, &reg32);
  		reg32 |= ROOT_PORT_INTR_ON_MESG_MASK;
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, reg32);
  	}
  
  	return rc ? PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_RECOVERED;
* Unmerged path drivers/pci/pcie/aer.c
