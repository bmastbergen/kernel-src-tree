PCI/ERR: Retain status from error notification

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Keith Busch <kbusch@kernel.org>
commit 387c72cdd7fb6bef650fb078d0f6ae9682abf631
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/387c72cd.failed

Overwriting the frozen detected status with the result of the link reset
loses the NEED_RESET result that drivers are depending on for error
handling to report the .slot_reset() callback. Retain this status so
that subsequent error handling has the correct flow.

Link: https://lore.kernel.org/r/20210104230300.1277180-4-kbusch@kernel.org
	Reported-by: Hinko Kocevar <hinko.kocevar@ess.eu>
	Tested-by: Hedi Berriche <hedi.berriche@hpe.com>
	Signed-off-by: Keith Busch <kbusch@kernel.org>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Sean V Kelley <sean.v.kelley@intel.com>
	Acked-by: Hedi Berriche <hedi.berriche@hpe.com>
(cherry picked from commit 387c72cdd7fb6bef650fb078d0f6ae9682abf631)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pcie/err.c
diff --cc drivers/pci/pcie/err.c
index c74d622dbbc4,b576aa890c76..000000000000
--- a/drivers/pci/pcie/err.c
+++ b/drivers/pci/pcie/err.c
@@@ -146,29 -146,60 +146,35 @@@ out
  	return 0;
  }
  
 -/**
 - * pci_walk_bridge - walk bridges potentially AER affected
 - * @bridge:	bridge which may be a Port, an RCEC, or an RCiEP
 - * @cb:		callback to be called for each device found
 - * @userdata:	arbitrary pointer to be passed to callback
 - *
 - * If the device provided is a bridge, walk the subordinate bus, including
 - * any bridged devices on buses under this bus.  Call the provided callback
 - * on each device found.
 - *
 - * If the device provided has no subordinate bus, e.g., an RCEC or RCiEP,
 - * call the callback on the device itself.
 - */
 -static void pci_walk_bridge(struct pci_dev *bridge,
 -			    int (*cb)(struct pci_dev *, void *),
 -			    void *userdata)
 -{
 -	if (bridge->subordinate)
 -		pci_walk_bus(bridge->subordinate, cb, userdata);
 -	else
 -		cb(bridge, userdata);
 -}
 -
  pci_ers_result_t pcie_do_recovery(struct pci_dev *dev,
 -		pci_channel_state_t state,
 -		pci_ers_result_t (*reset_subordinates)(struct pci_dev *pdev))
 +			enum pci_channel_state state,
 +			pci_ers_result_t (*reset_link)(struct pci_dev *pdev))
  {
  	int type = pci_pcie_type(dev);
 -	struct pci_dev *bridge;
  	pci_ers_result_t status = PCI_ERS_RESULT_CAN_RECOVER;
 -	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
 +	struct pci_bus *bus;
  
  	/*
 -	 * If the error was detected by a Root Port, Downstream Port, RCEC,
 -	 * or RCiEP, recovery runs on the device itself.  For Ports, that
 -	 * also includes any subordinate devices.
 -	 *
 -	 * If it was detected by another device (Endpoint, etc), recovery
 -	 * runs on the device and anything else under the same Port, i.e.,
 -	 * everything under "bridge".
 +	 * Error recovery runs on all subordinates of the first downstream port.
 +	 * If the downstream port detected the error, it is cleared at the end.
  	 */
 -	if (type == PCI_EXP_TYPE_ROOT_PORT ||
 -	    type == PCI_EXP_TYPE_DOWNSTREAM ||
 -	    type == PCI_EXP_TYPE_RC_EC ||
 -	    type == PCI_EXP_TYPE_RC_END)
 -		bridge = dev;
 -	else
 -		bridge = pci_upstream_bridge(dev);
 -
 -	pci_dbg(bridge, "broadcast error_detected message\n");
 +	if (!(type == PCI_EXP_TYPE_ROOT_PORT ||
 +	      type == PCI_EXP_TYPE_DOWNSTREAM))
 +		dev = pci_upstream_bridge(dev);
 +	bus = dev->subordinate;
 +
 +	pci_dbg(dev, "broadcast error_detected message\n");
  	if (state == pci_channel_io_frozen) {
++<<<<<<< HEAD
 +		pci_walk_bus(bus, report_frozen_detected, &status);
 +		status = reset_link(dev);
 +		if (status != PCI_ERS_RESULT_RECOVERED) {
 +			pci_warn(dev, "link reset failed\n");
++=======
+ 		pci_walk_bridge(bridge, report_frozen_detected, &status);
+ 		if (reset_subordinates(bridge) != PCI_ERS_RESULT_RECOVERED) {
+ 			pci_warn(bridge, "subordinate device reset failed\n");
++>>>>>>> 387c72cdd7fb (PCI/ERR: Retain status from error notification)
  			goto failed;
  		}
  	} else {
* Unmerged path drivers/pci/pcie/err.c
