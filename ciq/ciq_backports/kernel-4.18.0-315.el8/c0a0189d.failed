mac80211_hwsim: allow configurable cipher types

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author James Prestwood <james.prestwood@linux.intel.com>
commit c0a0189d827de189b15d07d0d9776b3965d59d8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/c0a0189d.failed

The mac80211_hwsim driver does not specify supported cipher types, which
in turn enables all ciphers to be supported in software. (see
net/mac80211/main.c:ieee80211_init_cipher_suites). Allowing ciphers
to be configurable is valuable for simulating older drivers that may
not support all ciphers.

This patch adds a new attribute:

 - HWSIM_ATTR_CIPHER_SUPPORT
	A u32 array/list of supported cipher types

This only allows enabling/disabling cipher types listed in the (new)
"hwsim_ciphers" array in mac80211_hwsim.c. Any unknown cipher type
will result in -EINVAL.

	Signed-off-by: James Prestwood <james.prestwood@linux.intel.com>
[fix some indentation, change to hwsim_known_ciphers(),
 add error messages, validate length better]
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit c0a0189d827de189b15d07d0d9776b3965d59d8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
#	drivers/net/wireless/mac80211_hwsim.h
diff --cc drivers/net/wireless/mac80211_hwsim.c
index fd008245b808,4033a800b209..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -512,7 -487,11 +526,9 @@@ struct mac80211_hwsim_data 
  	struct ieee80211_channel channels_5ghz[ARRAY_SIZE(hwsim_channels_5ghz)];
  	struct ieee80211_rate rates[ARRAY_SIZE(hwsim_rates)];
  	struct ieee80211_iface_combination if_combination;
 -	struct ieee80211_iface_limit if_limits[3];
 -	int n_if_limits;
  
+ 	u32 ciphers[ARRAY_SIZE(hwsim_ciphers)];
+ 
  	struct mac_address addresses[2];
  	int channels, idx;
  	bool use_chanctx;
@@@ -639,6 -618,8 +655,11 @@@ static const struct nla_policy hwsim_ge
  	[HWSIM_ATTR_NO_VIF] = { .type = NLA_FLAG },
  	[HWSIM_ATTR_FREQ] = { .type = NLA_U32 },
  	[HWSIM_ATTR_PERM_ADDR] = { .type = NLA_UNSPEC, .len = ETH_ALEN },
++<<<<<<< HEAD
++=======
+ 	[HWSIM_ATTR_IFTYPE_SUPPORT] = { .type = NLA_U32 },
+ 	[HWSIM_ATTR_CIPHER_SUPPORT] = { .type = NLA_BINARY },
++>>>>>>> c0a0189d827d (mac80211_hwsim: allow configurable cipher types)
  };
  
  static void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,
@@@ -2407,6 -2392,9 +2428,12 @@@ struct hwsim_new_radio_params 
  	const char *hwname;
  	bool no_vif;
  	const u8 *perm_addr;
++<<<<<<< HEAD
++=======
+ 	u32 iftypes;
+ 	u32 *ciphers;
+ 	u8 n_ciphers;
++>>>>>>> c0a0189d827d (mac80211_hwsim: allow configurable cipher types)
  };
  
  static void hwsim_mcast_config_msg(struct sk_buff *mcast_skb,
@@@ -2601,24 -2749,31 +2628,48 @@@ static int mac80211_hwsim_new_radio(str
  		hw->wiphy->max_scan_ssids = 255;
  		hw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
  		hw->wiphy->max_remain_on_channel_duration = 1000;
 +		hw->wiphy->iface_combinations = &data->if_combination;
 +		if (param->p2p_device)
 +			data->if_combination = hwsim_if_comb_p2p_dev[0];
 +		else
 +			data->if_combination = hwsim_if_comb[0];
 +		hw->wiphy->n_iface_combinations = 1;
 +		/* For channels > 1 DFS is not allowed */
  		data->if_combination.radar_detect_widths = 0;
  		data->if_combination.num_different_channels = data->channels;
 +	} else if (param->p2p_device) {
 +		hw->wiphy->iface_combinations = hwsim_if_comb_p2p_dev;
 +		hw->wiphy->n_iface_combinations =
 +			ARRAY_SIZE(hwsim_if_comb_p2p_dev);
 +	} else {
 +		hw->wiphy->iface_combinations = hwsim_if_comb;
 +		hw->wiphy->n_iface_combinations = ARRAY_SIZE(hwsim_if_comb);
  	}
  
++<<<<<<< HEAD
++=======
+ 	data->if_combination.n_limits = n_limits;
+ 	data->if_combination.max_interfaces = 2048;
+ 	data->if_combination.num_different_channels = 1;
+ 	data->if_combination.radar_detect_widths =
+ 					BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+ 					BIT(NL80211_CHAN_WIDTH_20) |
+ 					BIT(NL80211_CHAN_WIDTH_40) |
+ 					BIT(NL80211_CHAN_WIDTH_80) |
+ 					BIT(NL80211_CHAN_WIDTH_160);
+ 	data->if_combination.limits = data->if_limits;
+ 
+ 	hw->wiphy->iface_combinations = &data->if_combination;
+ 	hw->wiphy->n_iface_combinations = 1;
+ 
+ 	if (param->ciphers) {
+ 		memcpy(data->ciphers, param->ciphers,
+ 		       param->n_ciphers * sizeof(u32));
+ 		hw->wiphy->cipher_suites = data->ciphers;
+ 		hw->wiphy->n_cipher_suites = param->n_ciphers;
+ 	}
+ 
++>>>>>>> c0a0189d827d (mac80211_hwsim: allow configurable cipher types)
  	INIT_DELAYED_WORK(&data->roc_start, hw_roc_start);
  	INIT_DELAYED_WORK(&data->roc_done, hw_roc_done);
  	INIT_DELAYED_WORK(&data->hw_scan, hw_scan_work);
@@@ -3230,6 -3405,57 +3304,60 @@@ static int hwsim_new_radio_nl(struct sk
  		param.perm_addr = nla_data(info->attrs[HWSIM_ATTR_PERM_ADDR]);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT]) {
+ 		param.iftypes =
+ 			nla_get_u32(info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT]);
+ 
+ 		if (param.iftypes & ~HWSIM_IFTYPE_SUPPORT_MASK) {
+ 			NL_SET_ERR_MSG_ATTR(info->extack,
+ 					    info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT],
+ 					    "cannot support more iftypes than kernel");
+ 			return -EINVAL;
+ 		}
+ 	} else {
+ 		param.iftypes = HWSIM_IFTYPE_SUPPORT_MASK;
+ 	}
+ 
+ 	/* ensure both flag and iftype support is honored */
+ 	if (param.p2p_device ||
+ 	    param.iftypes & BIT(NL80211_IFTYPE_P2P_DEVICE)) {
+ 		param.iftypes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
+ 		param.p2p_device = true;
+ 	}
+ 
+ 	if (info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]) {
+ 		u32 len = nla_len(info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]);
+ 
+ 		param.ciphers =
+ 			nla_data(info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]);
+ 
+ 		if (len % sizeof(u32)) {
+ 			NL_SET_ERR_MSG_ATTR(info->extack,
+ 					    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],
+ 					    "bad cipher list length");
+ 			return -EINVAL;
+ 		}
+ 
+ 		param.n_ciphers = len / sizeof(u32);
+ 
+ 		if (param.n_ciphers > ARRAY_SIZE(hwsim_ciphers)) {
+ 			NL_SET_ERR_MSG_ATTR(info->extack,
+ 					    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],
+ 					    "too many ciphers specified");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (!hwsim_known_ciphers(param.ciphers, param.n_ciphers)) {
+ 			NL_SET_ERR_MSG_ATTR(info->extack,
+ 					    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],
+ 					    "unsupported ciphers specified");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
++>>>>>>> c0a0189d827d (mac80211_hwsim: allow configurable cipher types)
  	if (info->attrs[HWSIM_ATTR_RADIO_NAME]) {
  		hwname = kasprintf(GFP_KERNEL, "%.*s",
  				   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),
diff --cc drivers/net/wireless/mac80211_hwsim.h
index 3dc22059f6ef,a1ef8457fad4..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.h
+++ b/drivers/net/wireless/mac80211_hwsim.h
@@@ -129,6 -132,8 +129,11 @@@ enum 
   * @HWSIM_ATTR_TX_INFO_FLAGS: additional flags for corresponding
   *	rates of %HWSIM_ATTR_TX_INFO
   * @HWSIM_ATTR_PERM_ADDR: permanent mac address of new radio
++<<<<<<< HEAD
++=======
+  * @HWSIM_ATTR_IFTYPE_SUPPORT: u32 attribute of supported interface types bits
+  * @HWSIM_ATTR_CIPHER_SUPPORT: u32 array of supported cipher types
++>>>>>>> c0a0189d827d (mac80211_hwsim: allow configurable cipher types)
   * @__HWSIM_ATTR_MAX: enum limit
   */
  
@@@ -157,6 -162,8 +162,11 @@@ enum 
  	HWSIM_ATTR_PAD,
  	HWSIM_ATTR_TX_INFO_FLAGS,
  	HWSIM_ATTR_PERM_ADDR,
++<<<<<<< HEAD
++=======
+ 	HWSIM_ATTR_IFTYPE_SUPPORT,
+ 	HWSIM_ATTR_CIPHER_SUPPORT,
++>>>>>>> c0a0189d827d (mac80211_hwsim: allow configurable cipher types)
  	__HWSIM_ATTR_MAX,
  };
  #define HWSIM_ATTR_MAX (__HWSIM_ATTR_MAX - 1)
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
* Unmerged path drivers/net/wireless/mac80211_hwsim.h
