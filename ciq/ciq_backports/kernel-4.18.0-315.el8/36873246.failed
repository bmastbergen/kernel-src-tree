mt76: mt7921: add awake and doze time accounting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 36873246f78a2d82eb8c43f74af52f199757dcff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/36873246.failed

Introduce awake and doze time accounting for runtime pm.

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 36873246f78a2d82eb8c43f74af52f199757dcff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt76_connac.h
#	drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
index 1557547efa2f,f3982578cc56..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
@@@ -161,6 -149,187 +161,190 @@@ mt7921_queues_read(struct seq_file *s, 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mt7921_seq_puts_array(struct seq_file *file, const char *str,
+ 		      s8 *val, int len)
+ {
+ 	int i;
+ 
+ 	seq_printf(file, "%-16s:", str);
+ 	for (i = 0; i < len; i++)
+ 		if (val[i] == 127)
+ 			seq_printf(file, " %6s", "N.A");
+ 		else
+ 			seq_printf(file, " %6d", val[i]);
+ 	seq_puts(file, "\n");
+ }
+ 
+ #define mt7921_print_txpwr_entry(prefix, rate)				\
+ ({									\
+ 	mt7921_seq_puts_array(s, #prefix " (user)",			\
+ 			      txpwr.data[TXPWR_USER].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_USER].rate)); \
+ 	mt7921_seq_puts_array(s, #prefix " (eeprom)",			\
+ 			      txpwr.data[TXPWR_EEPROM].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_EEPROM].rate)); \
+ 	mt7921_seq_puts_array(s, #prefix " (tmac)",			\
+ 			      txpwr.data[TXPWR_MAC].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_MAC].rate));	\
+ })
+ 
+ static int
+ mt7921_txpwr(struct seq_file *s, void *data)
+ {
+ 	struct mt7921_dev *dev = dev_get_drvdata(s->private);
+ 	struct mt7921_txpwr txpwr;
+ 	int ret;
+ 
+ 	ret = mt7921_get_txpwr_info(dev, &txpwr);
+ 	if (ret)
+ 		return ret;
+ 
+ 	seq_printf(s, "Tx power table (channel %d)\n", txpwr.ch);
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s\n",
+ 		   " ", "1m", "2m", "5m", "11m");
+ 	mt7921_print_txpwr_entry(CCK, cck);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "6m", "9m", "12m", "18m", "24m", "36m",
+ 		   "48m", "54m");
+ 	mt7921_print_txpwr_entry(OFDM, ofdm);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7");
+ 	mt7921_print_txpwr_entry(HT20, ht20);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7", "mcs32");
+ 	mt7921_print_txpwr_entry(HT40, ht40);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7", "mcs8", "mcs9", "mcs10", "mcs11");
+ 	mt7921_print_txpwr_entry(VHT20, vht20);
+ 	mt7921_print_txpwr_entry(VHT40, vht40);
+ 	mt7921_print_txpwr_entry(VHT80, vht80);
+ 	mt7921_print_txpwr_entry(VHT160, vht160);
+ 	mt7921_print_txpwr_entry(HE26, he26);
+ 	mt7921_print_txpwr_entry(HE52, he52);
+ 	mt7921_print_txpwr_entry(HE106, he106);
+ 	mt7921_print_txpwr_entry(HE242, he242);
+ 	mt7921_print_txpwr_entry(HE484, he484);
+ 	mt7921_print_txpwr_entry(HE996, he996);
+ 	mt7921_print_txpwr_entry(HE996x2, he996x2);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_set(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 	struct mt76_connac_pm *pm = &dev->pm;
+ 	struct mt76_phy *mphy = dev->phy.mt76;
+ 
+ 	if (val == pm->enable)
+ 		return 0;
+ 
+ 	mt7921_mutex_acquire(dev);
+ 
+ 	if (!pm->enable) {
+ 		pm->stats.last_wake_event = jiffies;
+ 		pm->stats.last_doze_event = jiffies;
+ 	}
+ 	pm->enable = val;
+ 
+ 	ieee80211_iterate_active_interfaces(mphy->hw,
+ 					    IEEE80211_IFACE_ITER_RESUME_ALL,
+ 					    mt7921_pm_interface_iter, mphy->priv);
+ 	mt7921_mutex_release(dev);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_get(void *data, u64 *val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	*val = dev->pm.enable;
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_pm, mt7921_pm_get, mt7921_pm_set, "%lld\n");
+ 
+ static int
+ mt7921_pm_stats(struct seq_file *s, void *data)
+ {
+ 	struct mt7921_dev *dev = dev_get_drvdata(s->private);
+ 	struct mt76_connac_pm *pm = &dev->pm;
+ 	unsigned long awake_time = pm->stats.awake_time;
+ 	unsigned long doze_time = pm->stats.doze_time;
+ 
+ 	if (!test_bit(MT76_STATE_PM, &dev->mphy.state))
+ 		awake_time += jiffies - pm->stats.last_wake_event;
+ 	else
+ 		doze_time += jiffies - pm->stats.last_doze_event;
+ 
+ 	seq_printf(s, "awake time: %14u\ndoze time: %15u\n",
+ 		   jiffies_to_msecs(awake_time),
+ 		   jiffies_to_msecs(doze_time));
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_idle_timeout_set(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	dev->pm.idle_timeout = msecs_to_jiffies(val);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_idle_timeout_get(void *data, u64 *val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	*val = jiffies_to_msecs(dev->pm.idle_timeout);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_pm_idle_timeout, mt7921_pm_idle_timeout_get,
+ 			 mt7921_pm_idle_timeout_set, "%lld\n");
+ 
+ static int mt7921_chip_reset(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 	int ret = 0;
+ 
+ 	switch (val) {
+ 	case 1:
+ 		/* Reset wifisys directly. */
+ 		mt7921_reset(&dev->mt76);
+ 		break;
+ 	default:
+ 		/* Collect the core dump before reset wifisys. */
+ 		mt7921_mutex_acquire(dev);
+ 		ret = mt76_connac_mcu_chip_config(&dev->mt76);
+ 		mt7921_mutex_release(dev);
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_reset, NULL, mt7921_chip_reset, "%lld\n");
+ 
++>>>>>>> 36873246f78a (mt76: mt7921: add awake and doze time accounting)
  int mt7921_init_debugfs(struct mt7921_dev *dev)
  {
  	struct dentry *dir;
@@@ -173,8 -342,16 +357,17 @@@
  				    mt7921_queues_read);
  	debugfs_create_devm_seqfile(dev->mt76.dev, "acq", dir,
  				    mt7921_queues_acq);
 -	debugfs_create_devm_seqfile(dev->mt76.dev, "txpower_sku", dir,
 -				    mt7921_txpwr);
 -	debugfs_create_file("tx_stats", 0400, dir, dev, &mt7921_tx_stats_fops);
 +	debugfs_create_file("tx_stats", 0400, dir, dev, &fops_tx_stats);
  	debugfs_create_file("fw_debug", 0600, dir, dev, &fops_fw_debug);
++<<<<<<< HEAD
++=======
+ 	debugfs_create_file("runtime-pm", 0600, dir, dev, &fops_pm);
+ 	debugfs_create_file("idle-timeout", 0600, dir, dev,
+ 			    &fops_pm_idle_timeout);
+ 	debugfs_create_file("chip_reset", 0600, dir, dev, &fops_reset);
+ 	debugfs_create_devm_seqfile(dev->mt76.dev, "runtime_pm_stats", dir,
+ 				    mt7921_pm_stats);
++>>>>>>> 36873246f78a (mt76: mt7921: add awake and doze time accounting)
  
  	return 0;
  }
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
index 031cb2bd8cce,c00295b63ba8..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
@@@ -2639,256 -1264,100 +2639,307 @@@ int mt7921_mcu_set_bss_pm(struct mt7921
  				 sizeof(req), false);
  }
  
 -int mt7921_mcu_drv_pmctrl(struct mt7921_dev *dev)
 +#ifdef CONFIG_PM
 +int mt7921_mcu_set_hif_suspend(struct mt7921_dev *dev, bool suspend)
  {
++<<<<<<< HEAD
 +	struct {
 +		struct {
 +			u8 hif_type; /* 0x0: HIF_SDIO
 +				      * 0x1: HIF_USB
 +				      * 0x2: HIF_PCIE
 +				      */
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct hif_suspend_tlv {
 +			__le16 tag;
 +			__le16 len;
 +			u8 suspend;
 +		} __packed hif_suspend;
 +	} req = {
 +		.hif_suspend = {
 +			.tag = cpu_to_le16(0), /* 0: UNI_HIF_CTRL_BASIC */
 +			.len = cpu_to_le16(sizeof(struct hif_suspend_tlv)),
 +			.suspend = suspend,
 +		},
 +	};
 +
 +	if (mt76_is_mmio(&dev->mt76))
 +		req.hdr.hif_type = 2;
 +	else if (mt76_is_usb(&dev->mt76))
 +		req.hdr.hif_type = 1;
 +	else if (mt76_is_sdio(&dev->mt76))
 +		req.hdr.hif_type = 0;
++=======
+ 	struct mt76_phy *mphy = &dev->mt76.phy;
+ 	struct mt76_connac_pm *pm = &dev->pm;
+ 	int i, err = 0;
+ 
+ 	mutex_lock(&pm->mutex);
++>>>>>>> 36873246f78a (mt76: mt7921: add awake and doze time accounting)
  
 -	if (!test_bit(MT76_STATE_PM, &mphy->state))
 -		goto out;
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_HIF_CTRL, &req,
 +				 sizeof(req), true);
 +}
 +EXPORT_SYMBOL_GPL(mt7921_mcu_set_hif_suspend);
  
 -	for (i = 0; i < MT7921_DRV_OWN_RETRY_COUNT; i++) {
 -		mt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_CLR_OWN);
 -		if (mt76_poll_msec(dev, MT_CONN_ON_LPCTL,
 -				   PCIE_LPCR_HOST_OWN_SYNC, 0, 50))
 -			break;
 -	}
 +static int
 +mt7921_mcu_set_wow_ctrl(struct mt7921_phy *phy, struct ieee80211_vif *vif,
 +			bool suspend, struct cfg80211_wowlan *wowlan)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_dev *dev = phy->dev;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_wow_ctrl_tlv wow_ctrl_tlv;
 +		struct mt7921_wow_gpio_param_tlv gpio_tlv;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.wow_ctrl_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_WOW_CTRL),
 +			.len = cpu_to_le16(sizeof(struct mt7921_wow_ctrl_tlv)),
 +			.cmd = suspend ? 1 : 2,
 +		},
 +		.gpio_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_WOW_GPIO_PARAM),
 +			.len = cpu_to_le16(sizeof(struct mt7921_wow_gpio_param_tlv)),
 +			.gpio_pin = 0xff, /* follow fw about GPIO pin */
 +		},
 +	};
  
 -	if (i == MT7921_DRV_OWN_RETRY_COUNT) {
 -		dev_err(dev->mt76.dev, "driver own failed\n");
 -		err = -EIO;
 -		goto out;
 +	if (wowlan->magic_pkt)
 +		req.wow_ctrl_tlv.trigger |= BIT(0);
 +	if (wowlan->disconnect)
 +		req.wow_ctrl_tlv.trigger |= BIT(2);
 +	if (wowlan->nd_config) {
 +		mt7921_mcu_sched_scan_req(phy, vif, wowlan->nd_config);
 +		req.wow_ctrl_tlv.trigger |= BIT(5);
 +		mt7921_mcu_sched_scan_enable(phy, vif, suspend);
  	}
 -	clear_bit(MT76_STATE_PM, &mphy->state);
  
 +	if (mt76_is_mmio(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_PCIE;
 +	else if (mt76_is_usb(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_USB;
 +	else if (mt76_is_sdio(&dev->mt76))
 +		req.wow_ctrl_tlv.wakeup_hif = WOW_GPIO;
 +
++<<<<<<< HEAD
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_SUSPEND, &req,
 +				 sizeof(req), true);
++=======
+ 	pm->stats.last_wake_event = jiffies;
+ 	pm->stats.doze_time += pm->stats.last_wake_event -
+ 			       pm->stats.last_doze_event;
+ out:
+ 	mutex_unlock(&pm->mutex);
+ 
+ 	if (err)
+ 		mt7921_reset(&dev->mt76);
+ 
+ 	return err;
++>>>>>>> 36873246f78a (mt76: mt7921: add awake and doze time accounting)
  }
  
 -int mt7921_mcu_fw_pmctrl(struct mt7921_dev *dev)
 +static int
 +mt7921_mcu_set_wow_pattern(struct mt7921_dev *dev,
 +			   struct ieee80211_vif *vif,
 +			   u8 index, bool enable,
 +			   struct cfg80211_pkt_pattern *pattern)
  {
++<<<<<<< HEAD
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct mt7921_wow_pattern_tlv *ptlv;
 +	struct sk_buff *skb;
 +	struct req_hdr {
 +		u8 bss_idx;
 +		u8 pad[3];
 +	} __packed hdr = {
 +		.bss_idx = mvif->mt76.idx,
 +	};
 +
 +	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 +				 sizeof(hdr) + sizeof(*ptlv));
 +	if (!skb)
 +		return -ENOMEM;
 +
 +	skb_put_data(skb, &hdr, sizeof(hdr));
 +	ptlv = (struct mt7921_wow_pattern_tlv *)skb_put(skb, sizeof(*ptlv));
 +	ptlv->tag = cpu_to_le16(UNI_SUSPEND_WOW_PATTERN);
 +	ptlv->len = cpu_to_le16(sizeof(*ptlv));
 +	ptlv->data_len = pattern->pattern_len;
 +	ptlv->enable = enable;
 +	ptlv->index = index;
++=======
+ 	struct mt76_phy *mphy = &dev->mt76.phy;
+ 	struct mt76_connac_pm *pm = &dev->pm;
+ 	int i, err = 0;
+ 
+ 	mutex_lock(&pm->mutex);
+ 
+ 	if (mt76_connac_skip_fw_pmctrl(mphy, pm))
+ 		goto out;
++>>>>>>> 36873246f78a (mt76: mt7921: add awake and doze time accounting)
  
 -	for (i = 0; i < MT7921_DRV_OWN_RETRY_COUNT; i++) {
 -		mt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_SET_OWN);
 -		if (mt76_poll_msec(dev, MT_CONN_ON_LPCTL,
 -				   PCIE_LPCR_HOST_OWN_SYNC, 4, 50))
 -			break;
 -	}
 +	memcpy(ptlv->pattern, pattern->pattern, pattern->pattern_len);
 +	memcpy(ptlv->mask, pattern->mask, pattern->pattern_len / 8);
  
++<<<<<<< HEAD
 +	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_UNI_CMD_SUSPEND,
 +				     true);
++=======
+ 	if (i == MT7921_DRV_OWN_RETRY_COUNT) {
+ 		dev_err(dev->mt76.dev, "firmware own failed\n");
+ 		clear_bit(MT76_STATE_PM, &mphy->state);
+ 		err = -EIO;
+ 	}
+ 
+ 	pm->stats.last_doze_event = jiffies;
+ 	pm->stats.awake_time += pm->stats.last_doze_event -
+ 				pm->stats.last_wake_event;
+ out:
+ 	mutex_unlock(&pm->mutex);
+ 
+ 	if (err)
+ 		mt7921_reset(&dev->mt76);
+ 
+ 	return err;
++>>>>>>> 36873246f78a (mt76: mt7921: add awake and doze time accounting)
 +}
 +
 +static int
 +mt7921_mcu_set_suspend_mode(struct mt7921_dev *dev,
 +			    struct ieee80211_vif *vif,
 +			    bool enable, u8 mdtim, bool wow_suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_suspend_tlv suspend_tlv;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.suspend_tlv = {
 +			.tag = cpu_to_le16(UNI_SUSPEND_MODE_SETTING),
 +			.len = cpu_to_le16(sizeof(struct mt7921_suspend_tlv)),
 +			.enable = enable,
 +			.mdtim = mdtim,
 +			.wow_suspend = wow_suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_SUSPEND, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_gtk_rekey(struct mt7921_dev *dev,
 +			 struct ieee80211_vif *vif,
 +			 bool suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_gtk_rekey_tlv gtk_tlv;
 +	} __packed req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.gtk_tlv = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY),
 +			.len = cpu_to_le16(sizeof(struct mt7921_gtk_rekey_tlv)),
 +			.rekey_mode = !suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_OFFLOAD, &req,
 +				 sizeof(req), true);
 +}
 +
 +static int
 +mt7921_mcu_set_arp_filter(struct mt7921_dev *dev, struct ieee80211_vif *vif,
 +			  bool suspend)
 +{
 +	struct mt7921_vif *mvif = (struct mt7921_vif *)vif->drv_priv;
 +	struct {
 +		struct {
 +			u8 bss_idx;
 +			u8 pad[3];
 +		} __packed hdr;
 +		struct mt7921_arpns_tlv arpns;
 +	} req = {
 +		.hdr = {
 +			.bss_idx = mvif->mt76.idx,
 +		},
 +		.arpns = {
 +			.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ARP),
 +			.len = cpu_to_le16(sizeof(struct mt7921_arpns_tlv)),
 +			.mode = suspend,
 +		},
 +	};
 +
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD_OFFLOAD, &req,
 +				 sizeof(req), true);
  }
  
 -void
 -mt7921_pm_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)
 +void mt7921_mcu_set_suspend_iter(void *priv, u8 *mac,
 +				 struct ieee80211_vif *vif)
  {
  	struct mt7921_phy *phy = priv;
 -	struct mt7921_dev *dev = phy->dev;
 -	int ret;
 +	bool suspend = test_bit(MT76_STATE_SUSPEND, &phy->mt76->state);
 +	struct ieee80211_hw *hw = phy->mt76->hw;
 +	struct cfg80211_wowlan *wowlan = hw->wiphy->wowlan_config;
 +	int i;
  
 -	if (dev->pm.enable)
 -		ret = mt7921_mcu_uni_bss_bcnft(dev, vif, true);
 -	else
 -		ret = mt7921_mcu_set_bss_pm(dev, vif, false);
 +	mt7921_mcu_set_gtk_rekey(phy->dev, vif, suspend);
 +	mt7921_mcu_set_arp_filter(phy->dev, vif, suspend);
  
 -	if (ret)
 +	mt7921_mcu_set_suspend_mode(phy->dev, vif, suspend, 1, true);
 +
 +	for (i = 0; i < wowlan->n_patterns; i++)
 +		mt7921_mcu_set_wow_pattern(phy->dev, vif, i, suspend,
 +					   &wowlan->patterns[i]);
 +	mt7921_mcu_set_wow_ctrl(phy, vif, suspend, wowlan);
 +}
 +
 +static void
 +mt7921_mcu_key_iter(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 +		    struct ieee80211_sta *sta, struct ieee80211_key_conf *key,
 +		    void *data)
 +{
 +	struct mt7921_gtk_rekey_tlv *gtk_tlv = data;
 +	u32 cipher;
 +
 +	if (key->cipher != WLAN_CIPHER_SUITE_AES_CMAC &&
 +	    key->cipher != WLAN_CIPHER_SUITE_CCMP &&
 +	    key->cipher != WLAN_CIPHER_SUITE_TKIP)
  		return;
  
 -	if (dev->pm.enable) {
 -		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
 -		mt76_set(dev, MT_WF_RFCR(0), MT_WF_RFCR_DROP_OTHER_BEACON);
 +	if (key->cipher == WLAN_CIPHER_SUITE_TKIP) {
 +		gtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_1);
 +		cipher = BIT(3);
  	} else {
 -		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
 -		mt76_clear(dev, MT_WF_RFCR(0), MT_WF_RFCR_DROP_OTHER_BEACON);
 +		gtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_2);
 +		cipher = BIT(4);
 +	}
 +
 +	/* we are assuming here to have a single pairwise key */
 +	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {
 +		gtk_tlv->pairwise_cipher = cpu_to_le32(cipher);
 +		gtk_tlv->group_cipher = cpu_to_le32(cipher);
 +		gtk_tlv->keyid = key->keyidx;
  	}
  }
  
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/init.c b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
index a1cf9d52fcea..52ee2f273cf8 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
@@ -222,6 +222,10 @@ int mt7921_register_device(struct mt7921_dev *dev)
 	init_waitqueue_head(&dev->reset_wait);
 	INIT_WORK(&dev->reset_work, mt7921_mac_reset_work);
 
+	dev->pm.idle_timeout = MT7921_PM_TIMEOUT;
+	dev->pm.stats.last_wake_event = jiffies;
+	dev->pm.stats.last_doze_event = jiffies;
+
 	ret = mt7921_init_hardware(dev);
 	if (ret)
 		return ret;
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
