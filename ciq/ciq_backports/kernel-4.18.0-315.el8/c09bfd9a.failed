selftests: tc: Add generic mpls matching support for tc-flower

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Guillaume Nault <gnault@redhat.com>
commit c09bfd9a5df933f614af909d33ada673485b46ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/c09bfd9a.failed

Add tests in tc_flower.sh for generic matching on MPLS Label Stack
Entries. The label, tc, bos and ttl fields are tested for the first
and second labels. For each field, the minimal and maximal values are
tested (the former at depth 1 and the later at depth 2).
There are also tests for matching the presence of a label stack entry
at a given depth.

In order to reduce the amount of code, all "lse" subcommands are tested
in match_mpls_lse_test(). Action "continue" is used, so that test
packets are evaluated by all filters. Then, we can verify if each
filter matched the expected number of packets.

Some versions of tc-flower produced invalid json output when dumping
MPLS filters with depth > 1. Skip the test if tc isn't recent enough.

	Signed-off-by: Guillaume Nault <gnault@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c09bfd9a5df933f614af909d33ada673485b46ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/net/forwarding/lib.sh
#	tools/testing/selftests/net/forwarding/tc_flower.sh
diff --cc tools/testing/selftests/net/forwarding/lib.sh
index 977fc2b326a2,be71012b8fc5..000000000000
--- a/tools/testing/selftests/net/forwarding/lib.sh
+++ b/tools/testing/selftests/net/forwarding/lib.sh
@@@ -42,6 -42,47 +42,50 @@@ check_tc_version(
  	fi
  }
  
++<<<<<<< HEAD
++=======
+ # Old versions of tc don't understand "mpls_uc"
+ check_tc_mpls_support()
+ {
+ 	local dev=$1; shift
+ 
+ 	tc filter add dev $dev ingress protocol mpls_uc pref 1 handle 1 \
+ 		matchall action pipe &> /dev/null
+ 	if [[ $? -ne 0 ]]; then
+ 		echo "SKIP: iproute2 too old; tc is missing MPLS support"
+ 		return 1
+ 	fi
+ 	tc filter del dev $dev ingress protocol mpls_uc pref 1 handle 1 \
+ 		matchall
+ }
+ 
+ # Old versions of tc produce invalid json output for mpls lse statistics
+ check_tc_mpls_lse_stats()
+ {
+ 	local dev=$1; shift
+ 	local ret;
+ 
+ 	tc filter add dev $dev ingress protocol mpls_uc pref 1 handle 1 \
+ 		flower mpls lse depth 2                                 \
+ 		action continue &> /dev/null
+ 
+ 	if [[ $? -ne 0 ]]; then
+ 		echo "SKIP: iproute2 too old; tc-flower is missing extended MPLS support"
+ 		return 1
+ 	fi
+ 
+ 	tc -j filter show dev $dev ingress protocol mpls_uc | jq . &> /dev/null
+ 	ret=$?
+ 	tc filter del dev $dev ingress protocol mpls_uc pref 1 handle 1 \
+ 		flower
+ 
+ 	if [[ $ret -ne 0 ]]; then
+ 		echo "SKIP: iproute2 too old; tc-flower produces invalid json output for extended MPLS filters"
+ 		return 1
+ 	fi
+ }
+ 
++>>>>>>> c09bfd9a5df9 (selftests: tc: Add generic mpls matching support for tc-flower)
  check_tc_shblock_support()
  {
  	tc filter help 2>&1 | grep block &> /dev/null
diff --cc tools/testing/selftests/net/forwarding/tc_flower.sh
index b11d8e6b5bc1,a554838666c4..000000000000
--- a/tools/testing/selftests/net/forwarding/tc_flower.sh
+++ b/tools/testing/selftests/net/forwarding/tc_flower.sh
@@@ -3,7 -3,9 +3,13 @@@
  
  ALL_TESTS="match_dst_mac_test match_src_mac_test match_dst_ip_test \
  	match_src_ip_test match_ip_flags_test match_pcp_test match_vlan_test \
++<<<<<<< HEAD
 +	match_ip_tos_test match_indev_test match_ip_ttl_test"
++=======
+ 	match_ip_tos_test match_indev_test match_mpls_label_test \
+ 	match_mpls_tc_test match_mpls_bos_test match_mpls_ttl_test \
+ 	match_mpls_lse_test"
++>>>>>>> c09bfd9a5df9 (selftests: tc: Add generic mpls matching support for tc-flower)
  NUM_NETIFS=2
  source tc_common.sh
  source lib.sh
@@@ -370,6 -336,309 +376,312 @@@ match_indev_test(
  	log_test "indev match ($tcflags)"
  }
  
++<<<<<<< HEAD
++=======
+ # Unfortunately, mausezahn can't build MPLS headers when used in L2
+ # mode, so we have this function to build Label Stack Entries.
+ mpls_lse()
+ {
+ 	local label=$1
+ 	local tc=$2
+ 	local bos=$3
+ 	local ttl=$4
+ 
+ 	printf "%02x %02x %02x %02x"                        \
+ 		$((label >> 12))                            \
+ 		$((label >> 4 & 0xff))                      \
+ 		$((((label & 0xf) << 4) + (tc << 1) + bos)) \
+ 		$ttl
+ }
+ 
+ match_mpls_label_test()
+ {
+ 	local ethtype="88 47"; readonly ethtype
+ 	local pkt
+ 
+ 	RET=0
+ 
+ 	check_tc_mpls_support $h2 || return 0
+ 
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 1 handle 101 \
+ 		flower $tcflags mpls_label 0 action drop
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 2 handle 102 \
+ 		flower $tcflags mpls_label 1048575 action drop
+ 
+ 	pkt="$ethtype $(mpls_lse 1048575 0 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 1
+ 	check_fail $? "Matched on a wrong filter (1048575)"
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 1
+ 	check_err $? "Did not match on correct filter (1048575)"
+ 
+ 	pkt="$ethtype $(mpls_lse 0 0 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 2
+ 	check_fail $? "Matched on a wrong filter (0)"
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 1
+ 	check_err $? "Did not match on correct filter (0)"
+ 
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 2 handle 102 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 1 handle 101 flower
+ 
+ 	log_test "mpls_label match ($tcflags)"
+ }
+ 
+ match_mpls_tc_test()
+ {
+ 	local ethtype="88 47"; readonly ethtype
+ 	local pkt
+ 
+ 	RET=0
+ 
+ 	check_tc_mpls_support $h2 || return 0
+ 
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 1 handle 101 \
+ 		flower $tcflags mpls_tc 0 action drop
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 2 handle 102 \
+ 		flower $tcflags mpls_tc 7 action drop
+ 
+ 	pkt="$ethtype $(mpls_lse 0 7 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 1
+ 	check_fail $? "Matched on a wrong filter (7)"
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 1
+ 	check_err $? "Did not match on correct filter (7)"
+ 
+ 	pkt="$ethtype $(mpls_lse 0 0 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 2
+ 	check_fail $? "Matched on a wrong filter (0)"
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 1
+ 	check_err $? "Did not match on correct filter (0)"
+ 
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 2 handle 102 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 1 handle 101 flower
+ 
+ 	log_test "mpls_tc match ($tcflags)"
+ }
+ 
+ match_mpls_bos_test()
+ {
+ 	local ethtype="88 47"; readonly ethtype
+ 	local pkt
+ 
+ 	RET=0
+ 
+ 	check_tc_mpls_support $h2 || return 0
+ 
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 1 handle 101 \
+ 		flower $tcflags mpls_bos 0 action drop
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 2 handle 102 \
+ 		flower $tcflags mpls_bos 1 action drop
+ 
+ 	pkt="$ethtype $(mpls_lse 0 0 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 1
+ 	check_fail $? "Matched on a wrong filter (1)"
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 1
+ 	check_err $? "Did not match on correct filter (1)"
+ 
+ 	# Need to add a second label to properly mark the Bottom of Stack
+ 	pkt="$ethtype $(mpls_lse 0 0 0 255) $(mpls_lse 0 0 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 2
+ 	check_fail $? "Matched on a wrong filter (0)"
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 1
+ 	check_err $? "Did not match on correct filter (0)"
+ 
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 2 handle 102 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 1 handle 101 flower
+ 
+ 	log_test "mpls_bos match ($tcflags)"
+ }
+ 
+ match_mpls_ttl_test()
+ {
+ 	local ethtype="88 47"; readonly ethtype
+ 	local pkt
+ 
+ 	RET=0
+ 
+ 	check_tc_mpls_support $h2 || return 0
+ 
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 1 handle 101 \
+ 		flower $tcflags mpls_ttl 0 action drop
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 2 handle 102 \
+ 		flower $tcflags mpls_ttl 255 action drop
+ 
+ 	pkt="$ethtype $(mpls_lse 0 0 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 1
+ 	check_fail $? "Matched on a wrong filter (255)"
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 1
+ 	check_err $? "Did not match on correct filter (255)"
+ 
+ 	pkt="$ethtype $(mpls_lse 0 0 1 0)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 2
+ 	check_fail $? "Matched on a wrong filter (0)"
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 1
+ 	check_err $? "Did not match on correct filter (0)"
+ 
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 2 handle 102 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 1 handle 101 flower
+ 
+ 	log_test "mpls_ttl match ($tcflags)"
+ }
+ 
+ match_mpls_lse_test()
+ {
+ 	local ethtype="88 47"; readonly ethtype
+ 	local pkt
+ 
+ 	RET=0
+ 
+ 	check_tc_mpls_lse_stats $h2 || return 0
+ 
+ 	# Match on first LSE (minimal values for each field)
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 1 handle 101 \
+ 		flower $tcflags mpls lse depth 1 label 0 action continue
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 2 handle 102 \
+ 		flower $tcflags mpls lse depth 1 tc 0 action continue
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 3 handle 103 \
+ 		flower $tcflags mpls lse depth 1 bos 0 action continue
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 4 handle 104 \
+ 		flower $tcflags mpls lse depth 1 ttl 0 action continue
+ 
+ 	# Match on second LSE (maximal values for each field)
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 5 handle 105 \
+ 		flower $tcflags mpls lse depth 2 label 1048575 action continue
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 6 handle 106 \
+ 		flower $tcflags mpls lse depth 2 tc 7 action continue
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 7 handle 107 \
+ 		flower $tcflags mpls lse depth 2 bos 1 action continue
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 8 handle 108 \
+ 		flower $tcflags mpls lse depth 2 ttl 255 action continue
+ 
+ 	# Match on LSE depth
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 9 handle 109 \
+ 		flower $tcflags mpls lse depth 1 action continue
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 10 handle 110 \
+ 		flower $tcflags mpls lse depth 2 action continue
+ 	tc filter add dev $h2 ingress protocol mpls_uc pref 11 handle 111 \
+ 		flower $tcflags mpls lse depth 3 action continue
+ 
+ 	# Base packet, matched by all filters (except for stack depth 3)
+ 	pkt="$ethtype $(mpls_lse 0 0 0 0) $(mpls_lse 1048575 7 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Make a variant of the above packet, with a non-matching value
+ 	# for each LSE field
+ 
+ 	# Wrong label at depth 1
+ 	pkt="$ethtype $(mpls_lse 1 0 0 0) $(mpls_lse 1048575 7 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Wrong TC at depth 1
+ 	pkt="$ethtype $(mpls_lse 0 1 0 0) $(mpls_lse 1048575 7 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Wrong BOS at depth 1 (not adding a second LSE here since BOS is set
+ 	# in the first label, so anything that'd follow wouldn't be considered)
+ 	pkt="$ethtype $(mpls_lse 0 0 1 0)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Wrong TTL at depth 1
+ 	pkt="$ethtype $(mpls_lse 0 0 0 1) $(mpls_lse 1048575 7 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Wrong label at depth 2
+ 	pkt="$ethtype $(mpls_lse 0 0 0 0) $(mpls_lse 1048574 7 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Wrong TC at depth 2
+ 	pkt="$ethtype $(mpls_lse 0 0 0 0) $(mpls_lse 1048575 6 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Wrong BOS at depth 2 (adding a third LSE here since BOS isn't set in
+ 	# the second label)
+ 	pkt="$ethtype $(mpls_lse 0 0 0 0) $(mpls_lse 1048575 7 0 255)"
+ 	pkt="$pkt $(mpls_lse 0 0 1 255)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Wrong TTL at depth 2
+ 	pkt="$ethtype $(mpls_lse 0 0 0 0) $(mpls_lse 1048575 7 1 254)"
+ 	$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac "$pkt" -q
+ 
+ 	# Filters working at depth 1 should match all packets but one
+ 
+ 	tc_check_packets "dev $h2 ingress" 101 8
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc_check_packets "dev $h2 ingress" 102 8
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc_check_packets "dev $h2 ingress" 103 8
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc_check_packets "dev $h2 ingress" 104 8
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	# Filters working at depth 2 should match all packets but two (because
+ 	# of the test packet where the label stack depth is just one)
+ 
+ 	tc_check_packets "dev $h2 ingress" 105 7
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc_check_packets "dev $h2 ingress" 106 7
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc_check_packets "dev $h2 ingress" 107 7
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc_check_packets "dev $h2 ingress" 108 7
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	# Finally, verify the filters that only match on LSE depth
+ 
+ 	tc_check_packets "dev $h2 ingress" 109 9
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc_check_packets "dev $h2 ingress" 110 8
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc_check_packets "dev $h2 ingress" 111 1
+ 	check_err $? "Did not match on correct filter"
+ 
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 11 handle 111 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 10 handle 110 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 9 handle 109 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 8 handle 108 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 7 handle 107 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 6 handle 106 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 5 handle 105 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 4 handle 104 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 3 handle 103 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 2 handle 102 flower
+ 	tc filter del dev $h2 ingress protocol mpls_uc pref 1 handle 101 flower
+ 
+ 	log_test "mpls lse match ($tcflags)"
+ }
+ 
++>>>>>>> c09bfd9a5df9 (selftests: tc: Add generic mpls matching support for tc-flower)
  setup_prepare()
  {
  	h1=${NETIFS[p1]}
* Unmerged path tools/testing/selftests/net/forwarding/lib.sh
* Unmerged path tools/testing/selftests/net/forwarding/tc_flower.sh
