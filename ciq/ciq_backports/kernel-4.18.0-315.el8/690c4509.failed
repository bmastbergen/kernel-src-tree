mac80211_hwsim: Fix a typo in the name of function 'mac80211_hswim_he_capab()'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Christophe JAILLET <christophe.jaillet@wanadoo.fr>
commit 690c4509e980e7c9652945f5ae47e90f00f25ffc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/690c4509.failed

This function name should be 'mac80211_hwsim_he_capab()' (s wand w
switched) to be consistent with the rest of the file.
Fix and use it.

	Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Link: https://lore.kernel.org/r/20190725191328.18010-1-christophe.jaillet@wanadoo.fr
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 690c4509e980e7c9652945f5ae47e90f00f25ffc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
diff --cc drivers/net/wireless/mac80211_hwsim.c
index c8bb99e8be57,c4611eb4eb86..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -2513,6 -2496,139 +2513,142 @@@ out_err
  	nlmsg_free(mcast_skb);
  }
  
++<<<<<<< HEAD
++=======
+ static const struct ieee80211_sband_iftype_data he_capa_2ghz = {
+ 	/* TODO: should we support other types, e.g., P2P?*/
+ 	.types_mask = BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP),
+ 	.he_cap = {
+ 		.has_he = true,
+ 		.he_cap_elem = {
+ 			.mac_cap_info[0] =
+ 				IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 			.mac_cap_info[1] =
+ 				IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 				IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 			.mac_cap_info[2] =
+ 				IEEE80211_HE_MAC_CAP2_BSR |
+ 				IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 				IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 			.mac_cap_info[3] =
+ 				IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 				IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 			.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 			.phy_cap_info[1] =
+ 				IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 				IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 				IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 				IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 			.phy_cap_info[2] =
+ 				IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 				IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 			/* Leave all the other PHY capability bytes unset, as
+ 			 * DCM, beam forming, RU and PPE threshold information
+ 			 * are not supported
+ 			 */
+ 		},
+ 		.he_mcs_nss_supp = {
+ 			.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_160 = cpu_to_le16(0xffff),
+ 			.tx_mcs_160 = cpu_to_le16(0xffff),
+ 			.rx_mcs_80p80 = cpu_to_le16(0xffff),
+ 			.tx_mcs_80p80 = cpu_to_le16(0xffff),
+ 		},
+ 	},
+ };
+ 
+ static const struct ieee80211_sband_iftype_data he_capa_5ghz = {
+ 	/* TODO: should we support other types, e.g., P2P?*/
+ 	.types_mask = BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP),
+ 	.he_cap = {
+ 		.has_he = true,
+ 		.he_cap_elem = {
+ 			.mac_cap_info[0] =
+ 				IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 			.mac_cap_info[1] =
+ 				IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 				IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 			.mac_cap_info[2] =
+ 				IEEE80211_HE_MAC_CAP2_BSR |
+ 				IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 				IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 			.mac_cap_info[3] =
+ 				IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 				IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 			.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 			.phy_cap_info[0] =
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
+ 				IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,
+ 			.phy_cap_info[1] =
+ 				IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 				IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 				IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 				IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 			.phy_cap_info[2] =
+ 				IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 				IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 				IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 			/* Leave all the other PHY capability bytes unset, as
+ 			 * DCM, beam forming, RU and PPE threshold information
+ 			 * are not supported
+ 			 */
+ 		},
+ 		.he_mcs_nss_supp = {
+ 			.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_160 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_160 = cpu_to_le16(0xfffa),
+ 			.rx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 			.tx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 		},
+ 	},
+ };
+ 
+ static void mac80211_hwsim_he_capab(struct ieee80211_supported_band *sband)
+ {
+ 	if (sband->band == NL80211_BAND_2GHZ)
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)&he_capa_2ghz;
+ 	else if (sband->band == NL80211_BAND_5GHZ)
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)&he_capa_5ghz;
+ 	else
+ 		return;
+ 
+ 	sband->n_iftype_data = 1;
+ }
+ 
+ #ifdef CONFIG_MAC80211_MESH
+ #define HWSIM_MESH_BIT BIT(NL80211_IFTYPE_MESH_POINT)
+ #else
+ #define HWSIM_MESH_BIT 0
+ #endif
+ 
+ #define HWSIM_DEFAULT_IF_LIMIT \
+ 	(BIT(NL80211_IFTYPE_STATION) | \
+ 	 BIT(NL80211_IFTYPE_P2P_CLIENT) | \
+ 	 BIT(NL80211_IFTYPE_AP) | \
+ 	 BIT(NL80211_IFTYPE_P2P_GO) | \
+ 	 HWSIM_MESH_BIT)
+ 
+ #define HWSIM_IFTYPE_SUPPORT_MASK \
+ 	(BIT(NL80211_IFTYPE_STATION) | \
+ 	 BIT(NL80211_IFTYPE_AP) | \
+ 	 BIT(NL80211_IFTYPE_P2P_CLIENT) | \
+ 	 BIT(NL80211_IFTYPE_P2P_GO) | \
+ 	 BIT(NL80211_IFTYPE_ADHOC) | \
+ 	 BIT(NL80211_IFTYPE_MESH_POINT))
+ 
++>>>>>>> 690c4509e980 (mac80211_hwsim: Fix a typo in the name of function 'mac80211_hswim_he_capab()')
  static int mac80211_hwsim_new_radio(struct genl_info *info,
  				    struct hwsim_new_radio_params *param)
  {
@@@ -2734,6 -2897,8 +2870,11 @@@
  		sband->ht_cap.mcs.rx_mask[1] = 0xff;
  		sband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
  
++<<<<<<< HEAD
++=======
+ 		mac80211_hwsim_he_capab(sband);
+ 
++>>>>>>> 690c4509e980 (mac80211_hwsim: Fix a typo in the name of function 'mac80211_hswim_he_capab()')
  		hw->wiphy->bands[band] = sband;
  	}
  
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
