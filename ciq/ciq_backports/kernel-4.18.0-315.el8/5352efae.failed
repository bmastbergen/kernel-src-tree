mt76: mt7915: directly read per-rate tx power from registers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Shayne Chen <shayne.chen@mediatek.com>
commit 5352efaed0812dc23308498a2e700630f603579f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/5352efae.failed

Since driver no longer handler per-rate tx power setting, we need to
read the power values directly from registers.

	Tested-by: Evelyn Tsai <evelyn.tsai@mediatek.com>
	Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
	Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 5352efaed0812dc23308498a2e700630f603579f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
#	drivers/net/wireless/mediatek/mt76/mt7915/regs.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
index c960dfd21024,6a8ddeeecbe9..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
@@@ -304,8 -299,7 +304,12 @@@ mt7915_queues_read(struct seq_file *s, 
  }
  
  static void
++<<<<<<< HEAD
 +mt7915_puts_rate_txpower(struct seq_file *s, s8 *delta,
 +			 s8 txpower_cur, int band)
++=======
+ mt7915_puts_rate_txpower(struct seq_file *s, struct mt7915_phy *phy)
++>>>>>>> 5352efaed081 (mt76: mt7915: directly read per-rate tx power from registers)
  {
  	static const char * const sku_group_name[] = {
  		"CCK", "OFDM", "HT20", "HT40",
@@@ -313,24 -307,54 +317,75 @@@
  		"RU26", "RU52", "RU106", "RU242/SU20",
  		"RU484/SU40", "RU996/SU80", "RU2x996/SU160"
  	};
++<<<<<<< HEAD
 +	s8 txpower[MT7915_SKU_RATE_NUM];
 +	int i, idx = 0;
 +
 +	for (i = 0; i < MT7915_SKU_RATE_NUM; i++)
 +		txpower[i] = DIV_ROUND_UP(txpower_cur + delta[i], 2);
 +
 +	for (i = 0; i < MAX_SKU_RATE_GROUP_NUM; i++) {
 +		const struct sku_group *sku = &mt7915_sku_groups[i];
 +		u32 offset = sku->offset[band];
 +
 +		if (!offset) {
 +			idx += sku->len;
 +			continue;
 +		}
 +
 +		mt76_seq_puts_array(s, sku_group_name[i],
 +				    txpower + idx, sku->len);
 +		idx += sku->len;
++=======
+ 	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+ 	bool ext_phy = phy != &dev->phy;
+ 	u32 reg_base;
+ 	int i, idx = 0;
+ 
+ 	if (!phy)
+ 		return;
+ 
+ 	reg_base = MT_TMAC_FP0R0(ext_phy);
+ 	seq_printf(s, "\nBand %d\n", ext_phy);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(mt7915_sku_group_len); i++) {
+ 		u8 cnt, mcs_num = mt7915_sku_group_len[i];
+ 		s8 txpower[12];
+ 		int j;
+ 
+ 		if (i == SKU_HT_BW20 || i == SKU_HT_BW40) {
+ 			mcs_num = 8;
+ 		} else if (i >= SKU_VHT_BW20 && i <= SKU_VHT_BW160) {
+ 			mcs_num = 10;
+ 		} else if (i == SKU_HE_RU26) {
+ 			reg_base = MT_TMAC_FP0R18(ext_phy);
+ 			idx = 0;
+ 		}
+ 
+ 		for (j = 0, cnt = 0; j < DIV_ROUND_UP(mcs_num, 4); j++) {
+ 			u32 val;
+ 
+ 			if (i == SKU_VHT_BW160 && idx == 60) {
+ 				reg_base = MT_TMAC_FP0R15(ext_phy);
+ 				idx = 0;
+ 			}
+ 
+ 			val = mt76_rr(dev, reg_base + (idx / 4) * 4);
+ 
+ 			if (idx && idx % 4)
+ 				val >>= (idx % 4) * 8;
+ 
+ 			while (val > 0 && cnt < mcs_num) {
+ 				s8 pwr = FIELD_GET(MT_TMAC_FP_MASK, val);
+ 
+ 				txpower[cnt++] = pwr;
+ 				val >>= 8;
+ 				idx++;
+ 			}
+ 		}
+ 
+ 		mt76_seq_puts_array(s, sku_group_name[i], txpower, mcs_num);
++>>>>>>> 5352efaed081 (mt76: mt7915: directly read per-rate tx power from registers)
  	}
  }
  
@@@ -338,24 -362,9 +393,30 @@@ static in
  mt7915_read_rate_txpower(struct seq_file *s, void *data)
  {
  	struct mt7915_dev *dev = dev_get_drvdata(s->private);
++<<<<<<< HEAD
 +	struct mt76_phy *mphy = &dev->mphy;
 +	enum nl80211_band band = mphy->chandef.chan->band;
 +	s8 *delta = dev->rate_power[band];
 +	s8 txpower_base = mphy->txpower_cur - delta[MT7915_SKU_MAX_DELTA_IDX];
 +
 +	seq_puts(s, "Band 0:\n");
 +	mt7915_puts_rate_txpower(s, delta, txpower_base, band);
 +
 +	if (dev->mt76.phy2) {
 +		mphy = dev->mt76.phy2;
 +		band = mphy->chandef.chan->band;
 +		delta = dev->rate_power[band];
 +		txpower_base = mphy->txpower_cur -
 +			       delta[MT7915_SKU_MAX_DELTA_IDX];
 +
 +		seq_puts(s, "Band 1:\n");
 +		mt7915_puts_rate_txpower(s, delta, txpower_base, band);
 +	}
++=======
+ 
+ 	mt7915_puts_rate_txpower(s, &dev->phy);
+ 	mt7915_puts_rate_txpower(s, mt7915_ext_phy(dev));
++>>>>>>> 5352efaed081 (mt76: mt7915: directly read per-rate tx power from registers)
  
  	return 0;
  }
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/regs.h
index fded019fc897,efe0f2904c66..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/regs.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/regs.h
@@@ -70,14 -82,17 +70,22 @@@
  #define MT_TMAC_CTCR0_INS_DDLMT_EN		BIT(17)
  #define MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN	BIT(18)
  
++<<<<<<< HEAD
 +#define MT_TMAC_TRCR0(_band)		MT_WF_TMAC(_band, 0x09c)
++=======
+ #define MT_TMAC_FP0R0(_band)		MT_WF_TMAC(_band, 0x020)
+ #define MT_TMAC_FP0R15(_band)		MT_WF_TMAC(_band, 0x080)
+ #define MT_TMAC_FP0R18(_band)		MT_WF_TMAC(_band, 0x270)
+ #define MT_TMAC_FP_MASK			GENMASK(7, 0)
+ 
++>>>>>>> 5352efaed081 (mt76: mt7915: directly read per-rate tx power from registers)
  #define MT_TMAC_TFCR0(_band)		MT_WF_TMAC(_band, 0x1e0)
  
 -#define MT_WF_DMA_BASE(_band)		((_band) ? 0xa1e00 : 0x21e00)
 -#define MT_WF_DMA(_band, ofs)		(MT_WF_DMA_BASE(_band) + (ofs))
 +/* DMA Band 0 */
 +#define MT_WF_DMA_BASE			0x21e00
 +#define MT_WF_DMA(ofs)			(MT_WF_DMA_BASE + (ofs))
  
 -#define MT_DMA_DCR0(_band)		MT_WF_DMA(_band, 0x000)
 +#define MT_DMA_DCR0			MT_WF_DMA(0x000)
  #define MT_DMA_DCR0_MAX_RX_LEN		GENMASK(15, 3)
  #define MT_DMA_DCR0_RXD_G5_EN		BIT(23)
  
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/regs.h
