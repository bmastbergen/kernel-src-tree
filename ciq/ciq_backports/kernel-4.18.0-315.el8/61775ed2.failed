lockdep: Make __bfs(.match) return bool

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Boqun Feng <boqun.feng@gmail.com>
commit 61775ed243433ff0556c4f76905929fe01e92922
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/61775ed2.failed

The "match" parameter of __bfs() is used for checking whether we hit a
match in the search, therefore it should return a boolean value rather
than an integer for better readability.

This patch then changes the return type of the function parameter and the
match functions to bool.

	Suggested-by: Peter Zijlstra <peterz@infradead.org>
	Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200807074238.1632519-9-boqun.feng@gmail.com
(cherry picked from commit 61775ed243433ff0556c4f76905929fe01e92922)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/lockdep.c
diff --cc kernel/locking/lockdep.c
index 3abcaf4f62ca,78cd74d77be9..000000000000
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@@ -1548,14 -1551,78 +1548,86 @@@ static inline u8 calc_depb(struct held_
  }
  
  /*
 - * Initialize a lock_list entry @lock belonging to @class as the root for a BFS
 - * search.
 + * Forward- or backward-dependency search, used for both circular dependency
 + * checking and hardirq-unsafe/softirq-unsafe checking.
   */
++<<<<<<< HEAD
 +static int __bfs(struct lock_list *source_entry,
 +		 void *data,
 +		 int (*match)(struct lock_list *entry, void *data),
 +		 struct lock_list **target_entry,
 +		 int offset)
++=======
+ static inline void __bfs_init_root(struct lock_list *lock,
+ 				   struct lock_class *class)
+ {
+ 	lock->class = class;
+ 	lock->parent = NULL;
+ 	lock->only_xr = 0;
+ }
+ 
+ /*
+  * Initialize a lock_list entry @lock based on a lock acquisition @hlock as the
+  * root for a BFS search.
+  *
+  * ->only_xr of the initial lock node is set to @hlock->read == 2, to make sure
+  * that <prev> -> @hlock and @hlock -> <whatever __bfs() found> is not -(*R)->
+  * and -(S*)->.
+  */
+ static inline void bfs_init_root(struct lock_list *lock,
+ 				 struct held_lock *hlock)
+ {
+ 	__bfs_init_root(lock, hlock_class(hlock));
+ 	lock->only_xr = (hlock->read == 2);
+ }
+ 
+ /*
+  * Similar to bfs_init_root() but initialize the root for backwards BFS.
+  *
+  * ->only_xr of the initial lock node is set to @hlock->read != 0, to make sure
+  * that <next> -> @hlock and @hlock -> <whatever backwards BFS found> is not
+  * -(*S)-> and -(R*)-> (reverse order of -(*R)-> and -(S*)->).
+  */
+ static inline void bfs_init_rootb(struct lock_list *lock,
+ 				  struct held_lock *hlock)
+ {
+ 	__bfs_init_root(lock, hlock_class(hlock));
+ 	lock->only_xr = (hlock->read != 0);
+ }
+ 
+ /*
+  * Breadth-First Search to find a strong path in the dependency graph.
+  *
+  * @source_entry: the source of the path we are searching for.
+  * @data: data used for the second parameter of @match function
+  * @match: match function for the search
+  * @target_entry: pointer to the target of a matched path
+  * @offset: the offset to struct lock_class to determine whether it is
+  *          locks_after or locks_before
+  *
+  * We may have multiple edges (considering different kinds of dependencies,
+  * e.g. ER and SN) between two nodes in the dependency graph. But
+  * only the strong dependency path in the graph is relevant to deadlocks. A
+  * strong dependency path is a dependency path that doesn't have two adjacent
+  * dependencies as -(*R)-> -(S*)->, please see:
+  *
+  *         Documentation/locking/lockdep-design.rst
+  *
+  * for more explanation of the definition of strong dependency paths
+  *
+  * In __bfs(), we only traverse in the strong dependency path:
+  *
+  *     In lock_list::only_xr, we record whether the previous dependency only
+  *     has -(*R)-> in the search, and if it does (prev only has -(*R)->), we
+  *     filter out any -(S*)-> in the current dependency and after that, the
+  *     ->only_xr is set according to whether we only have -(*R)-> left.
+  */
+ static enum bfs_result __bfs(struct lock_list *source_entry,
+ 			     void *data,
+ 			     bool (*match)(struct lock_list *entry, void *data),
+ 			     struct lock_list **target_entry,
+ 			     int offset)
++>>>>>>> 61775ed24343 (lockdep: Make __bfs(.match) return bool)
  {
  	struct lock_list *entry;
  	struct lock_list *lock;
@@@ -1611,20 -1708,22 +1683,36 @@@ exit
  	return ret;
  }
  
++<<<<<<< HEAD
 +static inline int __bfs_forwards(struct lock_list *src_entry,
 +			void *data,
 +			int (*match)(struct lock_list *entry, void *data),
 +			struct lock_list **target_entry)
++=======
+ static inline enum bfs_result
+ __bfs_forwards(struct lock_list *src_entry,
+ 	       void *data,
+ 	       bool (*match)(struct lock_list *entry, void *data),
+ 	       struct lock_list **target_entry)
++>>>>>>> 61775ed24343 (lockdep: Make __bfs(.match) return bool)
  {
  	return __bfs(src_entry, data, match, target_entry,
  		     offsetof(struct lock_class, locks_after));
  
  }
  
++<<<<<<< HEAD
 +static inline int __bfs_backwards(struct lock_list *src_entry,
 +			void *data,
 +			int (*match)(struct lock_list *entry, void *data),
 +			struct lock_list **target_entry)
++=======
+ static inline enum bfs_result
+ __bfs_backwards(struct lock_list *src_entry,
+ 		void *data,
+ 		bool (*match)(struct lock_list *entry, void *data),
+ 		struct lock_list **target_entry)
++>>>>>>> 61775ed24343 (lockdep: Make __bfs(.match) return bool)
  {
  	return __bfs(src_entry, data, match, target_entry,
  		     offsetof(struct lock_class, locks_before));
* Unmerged path kernel/locking/lockdep.c
