mt76: mt7915: add support for continuous tx in testmode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Shayne Chen <shayne.chen@mediatek.com>
commit 3f0caa3cbf941cb962212770326649c21a527028
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/3f0caa3c.failed

Implement continuous tx state for MT7915 NIC testmode.

	Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 3f0caa3cbf941cb962212770326649c21a527028)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
#	drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
index d7deeb0df765,f26bad0c4bae..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
@@@ -3210,11 -3206,17 +3210,25 @@@ int mt7915_mcu_set_chan_info(struct mt7
  	};
  
  #ifdef CONFIG_NL80211_TESTMODE
++<<<<<<< HEAD
 +	if (dev->mt76.test.tx_antenna_mask &&
 +	    (dev->mt76.test.state == MT76_TM_STATE_TX_FRAMES ||
 +	     dev->mt76.test.state == MT76_TM_STATE_RX_FRAMES)) {
 +		req.tx_streams_num = fls(dev->mt76.test.tx_antenna_mask);
 +		req.rx_streams = dev->mt76.test.tx_antenna_mask;
++=======
+ 	if (phy->mt76->test.tx_antenna_mask &&
+ 	    (phy->mt76->test.state == MT76_TM_STATE_TX_FRAMES ||
+ 	     phy->mt76->test.state == MT76_TM_STATE_RX_FRAMES ||
+ 	     phy->mt76->test.state == MT76_TM_STATE_TX_CONT)) {
+ 		req.tx_streams_num = fls(phy->mt76->test.tx_antenna_mask);
+ 		req.rx_streams = phy->mt76->test.tx_antenna_mask;
+ 
+ 		if (ext_phy) {
+ 			req.tx_streams_num = 2;
+ 			req.rx_streams >>= 2;
+ 		}
++>>>>>>> 3f0caa3cbf94 (mt76: mt7915: add support for continuous tx in testmode)
  	}
  #endif
  
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
index fe56ab18e974,1762d94253e3..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
@@@ -197,80 -410,243 +197,262 @@@ mt7915_tm_init(struct mt7915_dev *dev
  }
  
  static void
++<<<<<<< HEAD
 +mt7915_tm_set_tx_frames(struct mt7915_dev *dev, bool en)
++=======
+ mt7915_tm_update_channel(struct mt7915_phy *phy)
+ {
+ 	mutex_unlock(&phy->dev->mt76.mutex);
+ 	mt7915_set_channel(phy);
+ 	mutex_lock(&phy->dev->mt76.mutex);
+ 
+ 	mt7915_mcu_set_chan_info(phy, MCU_EXT_CMD_SET_RX_PATH);
+ }
+ 
+ static void
+ mt7915_tm_set_tx_frames(struct mt7915_phy *phy, bool en)
++>>>>>>> 3f0caa3cbf94 (mt76: mt7915: add support for continuous tx in testmode)
  {
  	static const u8 spe_idx_map[] = {0, 0, 1, 0, 3, 2, 4, 0,
  					 9, 8, 6, 10, 16, 12, 18, 0};
 -	struct mt76_testmode_data *td = &phy->mt76->test;
 -	struct mt7915_dev *dev = phy->dev;
 +	struct sk_buff *skb = dev->mt76.test.tx_skb;
  	struct ieee80211_tx_info *info;
 -	u8 duty_cycle = td->tx_duty_cycle;
 -	u32 tx_time = td->tx_time;
 -	u32 ipg = td->tx_ipg;
  
 -	mt7915_tm_set_trx(phy, TM_MAC_RX_RXV, false);
 -	mt7915_tm_clean_hwq(phy, dev->mt76.global_wcid.idx);
 +	mt7915_tm_set_trx(dev, &dev->phy, TM_MAC_RX_RXV, false);
  
  	if (en) {
++<<<<<<< HEAD
 +		u8 tx_ant = dev->mt76.test.tx_antenna_mask;
 +
 +		mutex_unlock(&dev->mt76.mutex);
 +		mt7915_set_channel(&dev->phy);
 +		mutex_lock(&dev->mt76.mutex);
 +
 +		mt7915_mcu_set_chan_info(&dev->phy, MCU_EXT_CMD_SET_RX_PATH);
 +		dev->test.spe_idx = spe_idx_map[tx_ant];
++=======
+ 		mt7915_tm_update_channel(phy);
+ 
+ 		if (td->tx_spe_idx) {
+ 			phy->test.spe_idx = td->tx_spe_idx;
+ 		} else {
+ 			u8 tx_ant = td->tx_antenna_mask;
+ 
+ 			if (phy != &dev->phy)
+ 				tx_ant >>= 2;
+ 			phy->test.spe_idx = spe_idx_map[tx_ant];
+ 		}
++>>>>>>> 3f0caa3cbf94 (mt76: mt7915: add support for continuous tx in testmode)
  	}
  
 -	/* if all three params are set, duty_cycle will be ignored */
 -	if (duty_cycle && tx_time && !ipg) {
 -		ipg = tx_time * 100 / duty_cycle - tx_time;
 -	} else if (duty_cycle && !tx_time && ipg) {
 -		if (duty_cycle < 100)
 -			tx_time = duty_cycle * ipg / (100 - duty_cycle);
 -	}
 -
 -	mt7915_tm_set_ipg_params(phy, ipg, td->tx_rate_mode);
 -	mt7915_tm_set_tx_len(phy, tx_time);
 +	mt7915_tm_set_trx(dev, &dev->phy, TM_MAC_TX, en);
  
 -	if (ipg)
 -		td->tx_queued_limit = MT76_TM_TIMEOUT * 1000000 / ipg / 2;
 -
 -	if (!en || !td->tx_skb)
 +	if (!en || !skb)
  		return;
  
 -	info = IEEE80211_SKB_CB(td->tx_skb);
 -	info->control.vif = phy->monitor_vif;
 -
 -	mt7915_tm_set_trx(phy, TM_MAC_TX, en);
 +	info = IEEE80211_SKB_CB(skb);
 +	info->control.vif = dev->phy.monitor_vif;
  }
  
  static void
 -mt7915_tm_set_rx_frames(struct mt7915_phy *phy, bool en)
 +mt7915_tm_set_rx_frames(struct mt7915_dev *dev, bool en)
  {
++<<<<<<< HEAD
 +	if (en) {
 +		mutex_unlock(&dev->mt76.mutex);
 +		mt7915_set_channel(&dev->phy);
 +		mutex_lock(&dev->mt76.mutex);
 +
 +		mt7915_mcu_set_chan_info(&dev->phy, MCU_EXT_CMD_SET_RX_PATH);
 +	}
++=======
+ 	if (en)
+ 		mt7915_tm_update_channel(phy);
++>>>>>>> 3f0caa3cbf94 (mt76: mt7915: add support for continuous tx in testmode)
  
 -	mt7915_tm_set_trx(phy, TM_MAC_RX_RXV, en);
 +	mt7915_tm_set_trx(dev, &dev->phy, TM_MAC_RX_RXV, en);
  }
  
+ static int
+ mt7915_tm_rf_switch_mode(struct mt7915_dev *dev, u32 oper)
+ {
+ 	struct mt7915_tm_rf_test req = {
+ 		.op.op_mode = cpu_to_le32(oper),
+ 	};
+ 
+ 	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_RF_TEST, &req,
+ 				 sizeof(req), true);
+ }
+ 
+ static int
+ mt7915_tm_set_tx_cont(struct mt7915_phy *phy, bool en)
+ {
+ #define TX_CONT_START	0x05
+ #define TX_CONT_STOP	0x06
+ 	struct mt7915_dev *dev = phy->dev;
+ 	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+ 	int freq1 = ieee80211_frequency_to_channel(chandef->center_freq1);
+ 	struct mt76_testmode_data *td = &phy->mt76->test;
+ 	u32 func_idx = en ? TX_CONT_START : TX_CONT_STOP;
+ 	u8 rate_idx = td->tx_rate_idx, mode;
+ 	u16 rateval;
+ 	struct mt7915_tm_rf_test req = {
+ 		.action = 1,
+ 		.icap_len = 120,
+ 		.op.rf.func_idx = cpu_to_le32(func_idx),
+ 	};
+ 	struct tm_tx_cont *tx_cont = &req.op.rf.param.tx_cont;
+ 
+ 	tx_cont->control_ch = chandef->chan->hw_value;
+ 	tx_cont->center_ch = freq1;
+ 	tx_cont->tx_ant = td->tx_antenna_mask;
+ 	tx_cont->band = phy != &dev->phy;
+ 
+ 	switch (chandef->width) {
+ 	case NL80211_CHAN_WIDTH_40:
+ 		tx_cont->bw = CMD_CBW_40MHZ;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_80:
+ 		tx_cont->bw = CMD_CBW_80MHZ;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_80P80:
+ 		tx_cont->bw = CMD_CBW_8080MHZ;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_160:
+ 		tx_cont->bw = CMD_CBW_160MHZ;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_5:
+ 		tx_cont->bw = CMD_CBW_5MHZ;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_10:
+ 		tx_cont->bw = CMD_CBW_10MHZ;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_20:
+ 		tx_cont->bw = CMD_CBW_20MHZ;
+ 		break;
+ 	case NL80211_CHAN_WIDTH_20_NOHT:
+ 		tx_cont->bw = CMD_CBW_20MHZ;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	if (!en) {
+ 		req.op.rf.param.func_data = cpu_to_le32(phy != &dev->phy);
+ 		goto out;
+ 	}
+ 
+ 	if (td->tx_rate_mode <= MT76_TM_TX_MODE_OFDM) {
+ 		struct ieee80211_supported_band *sband;
+ 		u8 idx = rate_idx;
+ 
+ 		if (chandef->chan->band == NL80211_BAND_5GHZ)
+ 			sband = &phy->mt76->sband_5g.sband;
+ 		else
+ 			sband = &phy->mt76->sband_2g.sband;
+ 
+ 		if (td->tx_rate_mode == MT76_TM_TX_MODE_OFDM)
+ 			idx += 4;
+ 		rate_idx = sband->bitrates[idx].hw_value & 0xff;
+ 	}
+ 
+ 	switch (td->tx_rate_mode) {
+ 	case MT76_TM_TX_MODE_CCK:
+ 		mode = MT_PHY_TYPE_CCK;
+ 		break;
+ 	case MT76_TM_TX_MODE_OFDM:
+ 		mode = MT_PHY_TYPE_OFDM;
+ 		break;
+ 	case MT76_TM_TX_MODE_HT:
+ 		mode = MT_PHY_TYPE_HT;
+ 		break;
+ 	case MT76_TM_TX_MODE_VHT:
+ 		mode = MT_PHY_TYPE_VHT;
+ 		break;
+ 	case MT76_TM_TX_MODE_HE_SU:
+ 		mode = MT_PHY_TYPE_HE_SU;
+ 		break;
+ 	case MT76_TM_TX_MODE_HE_EXT_SU:
+ 		mode = MT_PHY_TYPE_HE_EXT_SU;
+ 		break;
+ 	case MT76_TM_TX_MODE_HE_TB:
+ 		mode = MT_PHY_TYPE_HE_TB;
+ 		break;
+ 	case MT76_TM_TX_MODE_HE_MU:
+ 		mode = MT_PHY_TYPE_HE_MU;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	rateval =  mode << 6 | rate_idx;
+ 	tx_cont->rateval = cpu_to_le16(rateval);
+ 
+ out:
+ 	if (!en) {
+ 		int ret;
+ 
+ 		ret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_RF_TEST, &req,
+ 					sizeof(req), true);
+ 		if (ret)
+ 			return ret;
+ 
+ 		return mt7915_tm_rf_switch_mode(dev, RF_OPER_NORMAL);
+ 	}
+ 
+ 	mt7915_tm_rf_switch_mode(dev, RF_OPER_RF_TEST);
+ 	mt7915_tm_update_channel(phy);
+ 
+ 	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_RF_TEST, &req,
+ 				 sizeof(req), true);
+ }
+ 
  static void
 -mt7915_tm_update_params(struct mt7915_phy *phy, u32 changed)
 +mt7915_tm_update_params(struct mt7915_dev *dev, u32 changed)
  {
 -	struct mt76_testmode_data *td = &phy->mt76->test;
 -	bool en = phy->mt76->test.state != MT76_TM_STATE_OFF;
 +	struct mt76_testmode_data *td = &dev->mt76.test;
 +	bool en = dev->mt76.test.state != MT76_TM_STATE_OFF;
  
  	if (changed & BIT(TM_CHANGED_FREQ_OFFSET))
 -		mt7915_tm_set_freq_offset(phy, en, en ? td->freq_offset : 0);
 +		mt7915_tm_set_freq_offset(dev, en, en ? td->freq_offset : 0);
  	if (changed & BIT(TM_CHANGED_TXPOWER))
 -		mt7915_tm_set_tx_power(phy);
 +		mt7915_tm_set_tx_power(&dev->phy);
  }
  
  static int
 -mt7915_tm_set_state(struct mt76_phy *mphy, enum mt76_testmode_state state)
 +mt7915_tm_set_state(struct mt76_dev *mdev, enum mt76_testmode_state state)
  {
 -	struct mt76_testmode_data *td = &mphy->test;
 -	struct mt7915_phy *phy = mphy->priv;
 +	struct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);
 +	struct mt76_testmode_data *td = &mdev->test;
  	enum mt76_testmode_state prev_state = td->state;
  
 -	mphy->test.state = state;
 -
 +	mdev->test.state = state;
 +
++<<<<<<< HEAD
 +	if (prev_state == MT76_TM_STATE_TX_FRAMES)
 +		mt7915_tm_set_tx_frames(dev, false);
 +	else if (state == MT76_TM_STATE_TX_FRAMES)
 +		mt7915_tm_set_tx_frames(dev, true);
 +	else if (prev_state == MT76_TM_STATE_RX_FRAMES)
 +		mt7915_tm_set_rx_frames(dev, false);
 +	else if (state == MT76_TM_STATE_RX_FRAMES)
 +		mt7915_tm_set_rx_frames(dev, true);
 +	else if (prev_state == MT76_TM_STATE_OFF || state == MT76_TM_STATE_OFF)
 +		mt7915_tm_init(dev);
++=======
+ 	if (prev_state == MT76_TM_STATE_TX_FRAMES ||
+ 	    state == MT76_TM_STATE_TX_FRAMES)
+ 		mt7915_tm_set_tx_frames(phy, state == MT76_TM_STATE_TX_FRAMES);
+ 	else if (prev_state == MT76_TM_STATE_RX_FRAMES ||
+ 		 state == MT76_TM_STATE_RX_FRAMES)
+ 		mt7915_tm_set_rx_frames(phy, state == MT76_TM_STATE_RX_FRAMES);
+ 	else if (prev_state == MT76_TM_STATE_TX_CONT ||
+ 		 state == MT76_TM_STATE_TX_CONT)
+ 		mt7915_tm_set_tx_cont(phy, state == MT76_TM_STATE_TX_CONT);
+ 	else if (prev_state == MT76_TM_STATE_OFF ||
+ 		 state == MT76_TM_STATE_OFF)
+ 		mt7915_tm_init(phy, !(state == MT76_TM_STATE_OFF));
++>>>>>>> 3f0caa3cbf94 (mt76: mt7915: add support for continuous tx in testmode)
  
  	if ((state == MT76_TM_STATE_IDLE &&
  	     prev_state == MT76_TM_STATE_OFF) ||
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
index 983973e5182c..b85302964d0d 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.h
@@ -232,6 +232,7 @@ enum {
 
 enum {
 	MCU_EXT_CMD_EFUSE_ACCESS = 0x01,
+	MCU_EXT_CMD_RF_TEST = 0x04,
 	MCU_EXT_CMD_PM_STATE_CTRL = 0x07,
 	MCU_EXT_CMD_CHANNEL_SWITCH = 0x08,
 	MCU_EXT_CMD_FW_LOG_2_HOST = 0x13,
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/testmode.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/testmode.h b/drivers/net/wireless/mediatek/mt76/mt7915/testmode.h
index 964f2d7fde3a..4df1b80fd56d 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/testmode.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/testmode.h
@@ -37,4 +37,44 @@ enum {
 	TM_MAC_RX_RXV,
 };
 
+struct tm_tx_cont {
+	u8 control_ch;
+	u8 center_ch;
+	u8 bw;
+	u8 tx_ant;
+	__le16 rateval;
+	u8 band;
+	u8 txfd_mode;
+};
+
+struct mt7915_tm_rf_test {
+	u8 action;
+	u8 icap_len;
+	u8 _rsv[2];
+	union {
+		__le32 op_mode;
+		__le32 freq;
+
+		struct {
+			__le32 func_idx;
+			union {
+				__le32 func_data;
+				__le32 cal_dump;
+
+				struct tm_tx_cont tx_cont;
+
+				u8 _pad[80];
+			} param;
+		} rf;
+	} op;
+} __packed;
+
+enum {
+	RF_OPER_NORMAL,
+	RF_OPER_RF_TEST,
+	RF_OPER_ICAP,
+	RF_OPER_ICAP_OVERLAP,
+	RF_OPER_WIFI_SPECTRUM,
+};
+
 #endif
