mac80211_hwsim: Register support for HE meshpoint

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Sven Eckelmann <seckelmann@datto.com>
commit b697746c62df8cfbaa04b94ae75de7098a08beb7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/b697746c.failed

Some features of 802.11ax without central organizing (AP) STA can also be
used in mesh mode. hwsim can be used to assist initial development of these
features without having access to HW.

	Signed-off-by: Sven Eckelmann <seckelmann@datto.com>
Link: https://lore.kernel.org/r/20190813063657.7544-1-sven@narfation.org
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit b697746c62df8cfbaa04b94ae75de7098a08beb7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
diff --cc drivers/net/wireless/mac80211_hwsim.c
index 5befc078752b,635956024e88..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -2513,6 -2497,234 +2513,237 @@@ out_err
  	nlmsg_free(mcast_skb);
  }
  
++<<<<<<< HEAD
++=======
+ static const struct ieee80211_sband_iftype_data he_capa_2ghz[] = {
+ 	{
+ 		/* TODO: should we support other types, e.g., P2P?*/
+ 		.types_mask = BIT(NL80211_IFTYPE_STATION) |
+ 			      BIT(NL80211_IFTYPE_AP),
+ 		.he_cap = {
+ 			.has_he = true,
+ 			.he_cap_elem = {
+ 				.mac_cap_info[0] =
+ 					IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 				.mac_cap_info[1] =
+ 					IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 				.mac_cap_info[2] =
+ 					IEEE80211_HE_MAC_CAP2_BSR |
+ 					IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 					IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 				.mac_cap_info[3] =
+ 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 				.phy_cap_info[1] =
+ 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 					IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 				.phy_cap_info[2] =
+ 					IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 					IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 					IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 					IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 					IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 				/* Leave all the other PHY capability bytes
+ 				 * unset, as DCM, beam forming, RU and PPE
+ 				 * threshold information are not supported
+ 				 */
+ 			},
+ 			.he_mcs_nss_supp = {
+ 				.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_160 = cpu_to_le16(0xffff),
+ 				.tx_mcs_160 = cpu_to_le16(0xffff),
+ 				.rx_mcs_80p80 = cpu_to_le16(0xffff),
+ 				.tx_mcs_80p80 = cpu_to_le16(0xffff),
+ 			},
+ 		},
+ 	},
+ #ifdef CONFIG_MAC80211_MESH
+ 	{
+ 		/* TODO: should we support other types, e.g., IBSS?*/
+ 		.types_mask = BIT(NL80211_IFTYPE_MESH_POINT),
+ 		.he_cap = {
+ 			.has_he = true,
+ 			.he_cap_elem = {
+ 				.mac_cap_info[0] =
+ 					IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 				.mac_cap_info[1] =
+ 					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 				.mac_cap_info[2] =
+ 					IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 				.mac_cap_info[3] =
+ 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 				.phy_cap_info[1] =
+ 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 					IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 				.phy_cap_info[2] = 0,
+ 
+ 				/* Leave all the other PHY capability bytes
+ 				 * unset, as DCM, beam forming, RU and PPE
+ 				 * threshold information are not supported
+ 				 */
+ 			},
+ 			.he_mcs_nss_supp = {
+ 				.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_160 = cpu_to_le16(0xffff),
+ 				.tx_mcs_160 = cpu_to_le16(0xffff),
+ 				.rx_mcs_80p80 = cpu_to_le16(0xffff),
+ 				.tx_mcs_80p80 = cpu_to_le16(0xffff),
+ 			},
+ 		},
+ 	},
+ #endif
+ };
+ 
+ static const struct ieee80211_sband_iftype_data he_capa_5ghz[] = {
+ 	{
+ 		/* TODO: should we support other types, e.g., P2P?*/
+ 		.types_mask = BIT(NL80211_IFTYPE_STATION) |
+ 			      BIT(NL80211_IFTYPE_AP),
+ 		.he_cap = {
+ 			.has_he = true,
+ 			.he_cap_elem = {
+ 				.mac_cap_info[0] =
+ 					IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 				.mac_cap_info[1] =
+ 					IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+ 					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 				.mac_cap_info[2] =
+ 					IEEE80211_HE_MAC_CAP2_BSR |
+ 					IEEE80211_HE_MAC_CAP2_MU_CASCADING |
+ 					IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 				.mac_cap_info[3] =
+ 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 				.phy_cap_info[0] =
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,
+ 				.phy_cap_info[1] =
+ 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 					IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 				.phy_cap_info[2] =
+ 					IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |
+ 					IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |
+ 					IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |
+ 					IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |
+ 					IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,
+ 
+ 				/* Leave all the other PHY capability bytes
+ 				 * unset, as DCM, beam forming, RU and PPE
+ 				 * threshold information are not supported
+ 				 */
+ 			},
+ 			.he_mcs_nss_supp = {
+ 				.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_160 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_160 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 			},
+ 		},
+ 	},
+ #ifdef CONFIG_MAC80211_MESH
+ 	{
+ 		/* TODO: should we support other types, e.g., IBSS?*/
+ 		.types_mask = BIT(NL80211_IFTYPE_MESH_POINT),
+ 		.he_cap = {
+ 			.has_he = true,
+ 			.he_cap_elem = {
+ 				.mac_cap_info[0] =
+ 					IEEE80211_HE_MAC_CAP0_HTC_HE,
+ 				.mac_cap_info[1] =
+ 					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+ 				.mac_cap_info[2] =
+ 					IEEE80211_HE_MAC_CAP2_ACK_EN,
+ 				.mac_cap_info[3] =
+ 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+ 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
+ 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
+ 				.phy_cap_info[0] =
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
+ 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,
+ 				.phy_cap_info[1] =
+ 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
+ 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+ 					IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |
+ 					IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,
+ 				.phy_cap_info[2] = 0,
+ 
+ 				/* Leave all the other PHY capability bytes
+ 				 * unset, as DCM, beam forming, RU and PPE
+ 				 * threshold information are not supported
+ 				 */
+ 			},
+ 			.he_mcs_nss_supp = {
+ 				.rx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_160 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_160 = cpu_to_le16(0xfffa),
+ 				.rx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 				.tx_mcs_80p80 = cpu_to_le16(0xfffa),
+ 			},
+ 		},
+ 	},
+ #endif
+ };
+ 
+ static void mac80211_hwsim_he_capab(struct ieee80211_supported_band *sband)
+ {
+ 	u16 n_iftype_data;
+ 
+ 	if (sband->band == NL80211_BAND_2GHZ) {
+ 		n_iftype_data = ARRAY_SIZE(he_capa_2ghz);
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)he_capa_2ghz;
+ 	} else if (sband->band == NL80211_BAND_5GHZ) {
+ 		n_iftype_data = ARRAY_SIZE(he_capa_5ghz);
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)he_capa_5ghz;
+ 	} else {
+ 		return;
+ 	}
+ 
+ 	sband->n_iftype_data = n_iftype_data;
+ }
+ 
+ #ifdef CONFIG_MAC80211_MESH
+ #define HWSIM_MESH_BIT BIT(NL80211_IFTYPE_MESH_POINT)
+ #else
+ #define HWSIM_MESH_BIT 0
+ #endif
+ 
+ #define HWSIM_DEFAULT_IF_LIMIT \
+ 	(BIT(NL80211_IFTYPE_STATION) | \
+ 	 BIT(NL80211_IFTYPE_P2P_CLIENT) | \
+ 	 BIT(NL80211_IFTYPE_AP) | \
+ 	 BIT(NL80211_IFTYPE_P2P_GO) | \
+ 	 HWSIM_MESH_BIT)
+ 
+ #define HWSIM_IFTYPE_SUPPORT_MASK \
+ 	(BIT(NL80211_IFTYPE_STATION) | \
+ 	 BIT(NL80211_IFTYPE_AP) | \
+ 	 BIT(NL80211_IFTYPE_P2P_CLIENT) | \
+ 	 BIT(NL80211_IFTYPE_P2P_GO) | \
+ 	 BIT(NL80211_IFTYPE_ADHOC) | \
+ 	 BIT(NL80211_IFTYPE_MESH_POINT))
+ 
++>>>>>>> b697746c62df (mac80211_hwsim: Register support for HE meshpoint)
  static int mac80211_hwsim_new_radio(struct genl_info *info,
  				    struct hwsim_new_radio_params *param)
  {
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
