arm64: kernel: disable CNP on Carmel

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Rich Wiley <rwiley@nvidia.com>
commit 20109a859a9b514eb10c22b8a14b5704ffe93897
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/20109a85.failed

On NVIDIA Carmel cores, CNP behaves differently than it does on standard
ARM cores. On Carmel, if two cores have CNP enabled and share an L2 TLB
entry created by core0 for a specific ASID, a non-shareable TLBI from
core1 may still see the shared entry. On standard ARM cores, that TLBI
will invalidate the shared entry as well.

This causes issues with patchsets that attempt to do local TLBIs based
on cpumasks instead of broadcast TLBIs. Avoid these issues by disabling
CNP support for NVIDIA Carmel cores.

	Signed-off-by: Rich Wiley <rwiley@nvidia.com>
Link: https://lore.kernel.org/r/20210324002809.30271-1-rwiley@nvidia.com
[will: Fix pre-existing whitespace issue]
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit 20109a859a9b514eb10c22b8a14b5704ffe93897)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/arm64/silicon-errata.rst
#	arch/arm64/Kconfig
#	arch/arm64/include/asm/cpucaps.h
#	arch/arm64/kernel/cpu_errata.c
diff --cc arch/arm64/Kconfig
index 2d198fa762a0,e4e1b6550115..000000000000
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -746,22 -810,22 +746,37 @@@ config QCOM_FALKOR_ERRATUM_E104
  
  	  If unsure, say Y.
  
++<<<<<<< HEAD
 +config FUJITSU_ERRATUM_010001
 +	bool "Fujitsu-A64FX erratum E#010001: Undefined fault may occur wrongly"
++=======
+ config NVIDIA_CARMEL_CNP_ERRATUM
+ 	bool "NVIDIA Carmel CNP: CNP on Carmel semantically different than ARM cores"
+ 	default y
+ 	help
+ 	  If CNP is enabled on Carmel cores, non-sharable TLBIs on a core will not
+ 	  invalidate shared TLB entries installed by a different core, as it would
+ 	  on standard ARM cores.
+ 
+ 	  If unsure, say Y.
+ 
+ config SOCIONEXT_SYNQUACER_PREITS
+ 	bool "Socionext Synquacer: Workaround for GICv3 pre-ITS"
++>>>>>>> 20109a859a9b (arm64: kernel: disable CNP on Carmel)
  	default y
  	help
 -	  Socionext Synquacer SoCs implement a separate h/w block to generate
 -	  MSI doorbell writes with non-zero values for the device ID.
 +	  This option adds a workaround for Fujitsu-A64FX erratum E#010001.
 +	  On some variants of the Fujitsu-A64FX cores ver(1.0, 1.1), memory
 +	  accesses may cause undefined fault (Data abort, DFSC=0b111111).
 +	  This fault occurs under a specific hardware condition when a
 +	  load/store instruction performs an address translation using:
 +	  case-1  TTBR0_EL1 with TCR_EL1.NFD0 == 1.
 +	  case-2  TTBR0_EL2 with TCR_EL2.NFD0 == 1.
 +	  case-3  TTBR1_EL1 with TCR_EL1.NFD1 == 1.
 +	  case-4  TTBR1_EL2 with TCR_EL2.NFD1 == 1.
 +
 +	  The workaround is to ensure these bits are clear in TCR_ELx.
 +	  The workaround only affects the Fujitsu-A64FX.
  
  	  If unsure, say Y.
  
diff --cc arch/arm64/include/asm/cpucaps.h
index 43df5254d135,c40f2490cd7b..000000000000
--- a/arch/arm64/include/asm/cpucaps.h
+++ b/arch/arm64/include/asm/cpucaps.h
@@@ -61,12 -48,26 +61,36 @@@
  #define ARM64_HAS_GENERIC_AUTH_ARCH		40
  #define ARM64_HAS_GENERIC_AUTH_IMP_DEF		41
  #define ARM64_HAS_IRQ_PRIO_MASKING		42
++<<<<<<< HEAD
 +#define ARM64_WORKAROUND_CAVIUM_TX2_219_TVM	43
 +#define ARM64_WORKAROUND_CAVIUM_TX2_219_PRFM	44
 +#define ARM64_WORKAROUND_1463225		45
 +#define ARM64_WORKAROUND_1542419		46
 +#define ARM64_HAS_32BIT_EL1			47
 +
 +#define ARM64_NCAPS				48
++=======
+ #define ARM64_HAS_DCPODP			43
+ #define ARM64_WORKAROUND_1463225		44
+ #define ARM64_WORKAROUND_CAVIUM_TX2_219_TVM	45
+ #define ARM64_WORKAROUND_CAVIUM_TX2_219_PRFM	46
+ #define ARM64_WORKAROUND_1542419		47
+ #define ARM64_HAS_E0PD				48
+ #define ARM64_HAS_RNG				49
+ #define ARM64_HAS_AMU_EXTN			50
+ #define ARM64_HAS_ADDRESS_AUTH			51
+ #define ARM64_HAS_GENERIC_AUTH			52
+ #define ARM64_HAS_32BIT_EL1			53
+ #define ARM64_BTI				54
+ #define ARM64_HAS_ARMv8_4_TTL			55
+ #define ARM64_HAS_TLB_RANGE			56
+ #define ARM64_MTE				57
+ #define ARM64_WORKAROUND_1508412		58
+ #define ARM64_HAS_LDAPR				59
+ #define ARM64_KVM_PROTECTED_MODE		60
+ #define ARM64_WORKAROUND_NVIDIA_CARMEL_CNP	61
+ 
+ #define ARM64_NCAPS				62
++>>>>>>> 20109a859a9b (arm64: kernel: disable CNP on Carmel)
  
  #endif /* __ASM_CPUCAPS_H */
diff --cc arch/arm64/kernel/cpu_errata.c
index ca6bb07dd84a,e2c20c036442..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -913,6 -516,24 +913,27 @@@ const struct arm64_cpu_capabilities arm
  		.cpu_enable = cpu_enable_trap_ctr_access,
  	},
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_ERRATUM_1508412
+ 	{
+ 		/* we depend on the firmware portion for correctness */
+ 		.desc = "ARM erratum 1508412 (kernel portion)",
+ 		.capability = ARM64_WORKAROUND_1508412,
+ 		ERRATA_MIDR_RANGE(MIDR_CORTEX_A77,
+ 				  0, 0,
+ 				  1, 0),
+ 	},
+ #endif
+ #ifdef CONFIG_NVIDIA_CARMEL_CNP_ERRATUM
+ 	{
+ 		/* NVIDIA Carmel */
+ 		.desc = "NVIDIA Carmel CNP erratum",
+ 		.capability = ARM64_WORKAROUND_NVIDIA_CARMEL_CNP,
+ 		ERRATA_MIDR_ALL_VERSIONS(MIDR_NVIDIA_CARMEL),
+ 	},
+ #endif
++>>>>>>> 20109a859a9b (arm64: kernel: disable CNP on Carmel)
  	{
  	}
  };
* Unmerged path Documentation/arm64/silicon-errata.rst
* Unmerged path Documentation/arm64/silicon-errata.rst
* Unmerged path arch/arm64/Kconfig
* Unmerged path arch/arm64/include/asm/cpucaps.h
* Unmerged path arch/arm64/kernel/cpu_errata.c
diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c
index 6aa72fdaeb2c..06d42cf73c72 100644
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@ -983,7 +983,10 @@ has_useable_cnp(const struct arm64_cpu_capabilities *entry, int scope)
 	 * may share TLB entries with a CPU stuck in the crashed
 	 * kernel.
 	 */
-	 if (is_kdump_kernel())
+	if (is_kdump_kernel())
+		return false;
+
+	if (cpus_have_const_cap(ARM64_WORKAROUND_NVIDIA_CARMEL_CNP))
 		return false;
 
 	return has_cpuid_feature(entry, scope);
