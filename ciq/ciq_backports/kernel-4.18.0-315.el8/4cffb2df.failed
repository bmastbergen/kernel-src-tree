KVM: selftests: vgic_init kvm selftests fixup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Eric Auger <eric.auger@redhat.com>
commit 4cffb2df4260ed38c7ae4105f6913ad2d71a16ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/4cffb2df.failed

Bring some improvements/rationalization over the first version
of the vgic_init selftests:

- ucall_init is moved in run_cpu()
- vcpu_args_set is not called as not needed
- whenever a helper is supposed to succeed, call the non "_" version
- helpers do not return -errno, instead errno is checked by the caller
- vm_gic struct is used whenever possible, as well as vm_gic_destroy
- _kvm_create_device takes an addition fd parameter

	Signed-off-by: Eric Auger <eric.auger@redhat.com>
	Suggested-by: Andrew Jones <drjones@redhat.com>
	Reviewed-by: Andrew Jones <drjones@redhat.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20210407135937.533141-1-eric.auger@redhat.com
(cherry picked from commit 4cffb2df4260ed38c7ae4105f6913ad2d71a16ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/aarch64/vgic_init.c
#	tools/testing/selftests/kvm/include/kvm_util.h
#	tools/testing/selftests/kvm/lib/kvm_util.c
diff --cc tools/testing/selftests/kvm/include/kvm_util.h
index 0e6cc25642a6,bea4644d645d..000000000000
--- a/tools/testing/selftests/kvm/include/kvm_util.h
+++ b/tools/testing/selftests/kvm/include/kvm_util.h
@@@ -223,6 -223,15 +223,18 @@@ int vcpu_nested_state_set(struct kvm_v
  #endif
  void *vcpu_map_dirty_ring(struct kvm_vm *vm, uint32_t vcpuid);
  
++<<<<<<< HEAD
++=======
+ int _kvm_device_check_attr(int dev_fd, uint32_t group, uint64_t attr);
+ int kvm_device_check_attr(int dev_fd, uint32_t group, uint64_t attr);
+ int _kvm_create_device(struct kvm_vm *vm, uint64_t type, bool test, int *fd);
+ int kvm_create_device(struct kvm_vm *vm, uint64_t type, bool test);
+ int _kvm_device_access(int dev_fd, uint32_t group, uint64_t attr,
+ 		       void *val, bool write);
+ int kvm_device_access(int dev_fd, uint32_t group, uint64_t attr,
+ 		      void *val, bool write);
+ 
++>>>>>>> 4cffb2df4260 (KVM: selftests: vgic_init kvm selftests fixup)
  const char *exit_reason_str(unsigned int exit_reason);
  
  void virt_pgd_alloc(struct kvm_vm *vm, uint32_t pgd_memslot);
diff --cc tools/testing/selftests/kvm/lib/kvm_util.c
index 35247dba362e,5067d041fb00..000000000000
--- a/tools/testing/selftests/kvm/lib/kvm_util.c
+++ b/tools/testing/selftests/kvm/lib/kvm_util.c
@@@ -1731,6 -1729,81 +1731,84 @@@ int _kvm_ioctl(struct kvm_vm *vm, unsig
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Device Ioctl
+  */
+ 
+ int _kvm_device_check_attr(int dev_fd, uint32_t group, uint64_t attr)
+ {
+ 	struct kvm_device_attr attribute = {
+ 		.group = group,
+ 		.attr = attr,
+ 		.flags = 0,
+ 	};
+ 
+ 	return ioctl(dev_fd, KVM_HAS_DEVICE_ATTR, &attribute);
+ }
+ 
+ int kvm_device_check_attr(int dev_fd, uint32_t group, uint64_t attr)
+ {
+ 	int ret = _kvm_device_check_attr(dev_fd, group, attr);
+ 
+ 	TEST_ASSERT(ret >= 0, "KVM_HAS_DEVICE_ATTR failed, rc: %i errno: %i", ret, errno);
+ 	return ret;
+ }
+ 
+ int _kvm_create_device(struct kvm_vm *vm, uint64_t type, bool test, int *fd)
+ {
+ 	struct kvm_create_device create_dev;
+ 	int ret;
+ 
+ 	create_dev.type = type;
+ 	create_dev.fd = -1;
+ 	create_dev.flags = test ? KVM_CREATE_DEVICE_TEST : 0;
+ 	ret = ioctl(vm_get_fd(vm), KVM_CREATE_DEVICE, &create_dev);
+ 	*fd = create_dev.fd;
+ 	return ret;
+ }
+ 
+ int kvm_create_device(struct kvm_vm *vm, uint64_t type, bool test)
+ {
+ 	int fd, ret;
+ 
+ 	ret = _kvm_create_device(vm, type, test, &fd);
+ 
+ 	if (!test) {
+ 		TEST_ASSERT(ret >= 0,
+ 			    "KVM_CREATE_DEVICE IOCTL failed, rc: %i errno: %i", ret, errno);
+ 		return fd;
+ 	}
+ 	return ret;
+ }
+ 
+ int _kvm_device_access(int dev_fd, uint32_t group, uint64_t attr,
+ 		      void *val, bool write)
+ {
+ 	struct kvm_device_attr kvmattr = {
+ 		.group = group,
+ 		.attr = attr,
+ 		.flags = 0,
+ 		.addr = (uintptr_t)val,
+ 	};
+ 	int ret;
+ 
+ 	ret = ioctl(dev_fd, write ? KVM_SET_DEVICE_ATTR : KVM_GET_DEVICE_ATTR,
+ 		    &kvmattr);
+ 	return ret;
+ }
+ 
+ int kvm_device_access(int dev_fd, uint32_t group, uint64_t attr,
+ 		      void *val, bool write)
+ {
+ 	int ret = _kvm_device_access(dev_fd, group, attr, val, write);
+ 
+ 	TEST_ASSERT(ret >= 0, "KVM_SET|GET_DEVICE_ATTR IOCTL failed, rc: %i errno: %i", ret, errno);
+ 	return ret;
+ }
+ 
+ /*
++>>>>>>> 4cffb2df4260 (KVM: selftests: vgic_init kvm selftests fixup)
   * VM Dump
   *
   * Input Args:
* Unmerged path tools/testing/selftests/kvm/aarch64/vgic_init.c
* Unmerged path tools/testing/selftests/kvm/aarch64/vgic_init.c
* Unmerged path tools/testing/selftests/kvm/include/kvm_util.h
* Unmerged path tools/testing/selftests/kvm/lib/kvm_util.c
