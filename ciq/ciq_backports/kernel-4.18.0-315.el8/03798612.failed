mac80211_hwsim: use GFP_ATOMIC under spin lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Wei Yongjun <weiyongjun1@huawei.com>
commit 0379861217dc2dd46e3bc517010060065b0dd6fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/03798612.failed

A spin lock is taken here so we should use GFP_ATOMIC.

Fixes: 5d44fe7c9808 ("mac80211_hwsim: add frame transmission support over virtio")
	Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
Link: https://lore.kernel.org/r/20200422020154.112088-1-weiyongjun1@huawei.com
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 0379861217dc2dd46e3bc517010060065b0dd6fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
diff --cc drivers/net/wireless/mac80211_hwsim.c
index 2b831c30cdc8,0528d4cb4d37..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -3573,6 -3993,229 +3573,232 @@@ static void hwsim_exit_netlink(void
  	genl_unregister_family(&hwsim_genl_family);
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_REACHABLE(CONFIG_VIRTIO)
+ static void hwsim_virtio_tx_done(struct virtqueue *vq)
+ {
+ 	unsigned int len;
+ 	struct sk_buff *skb;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	while ((skb = virtqueue_get_buf(vq, &len)))
+ 		nlmsg_free(skb);
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ }
+ 
+ static int hwsim_virtio_handle_cmd(struct sk_buff *skb)
+ {
+ 	struct nlmsghdr *nlh;
+ 	struct genlmsghdr *gnlh;
+ 	struct nlattr *tb[HWSIM_ATTR_MAX + 1];
+ 	struct genl_info info = {};
+ 	int err;
+ 
+ 	nlh = nlmsg_hdr(skb);
+ 	gnlh = nlmsg_data(nlh);
+ 	err = genlmsg_parse(nlh, &hwsim_genl_family, tb, HWSIM_ATTR_MAX,
+ 			    hwsim_genl_policy, NULL);
+ 	if (err) {
+ 		pr_err_ratelimited("hwsim: genlmsg_parse returned %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	info.attrs = tb;
+ 
+ 	switch (gnlh->cmd) {
+ 	case HWSIM_CMD_FRAME:
+ 		hwsim_cloned_frame_received_nl(skb, &info);
+ 		break;
+ 	case HWSIM_CMD_TX_INFO_FRAME:
+ 		hwsim_tx_info_frame_received_nl(skb, &info);
+ 		break;
+ 	default:
+ 		pr_err_ratelimited("hwsim: invalid cmd: %d\n", gnlh->cmd);
+ 		return -EPROTO;
+ 	}
+ 	return 0;
+ }
+ 
+ static void hwsim_virtio_rx_work(struct work_struct *work)
+ {
+ 	struct virtqueue *vq;
+ 	unsigned int len;
+ 	struct sk_buff *skb;
+ 	struct scatterlist sg[1];
+ 	int err;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	if (!hwsim_virtio_enabled)
+ 		goto out_unlock;
+ 
+ 	skb = virtqueue_get_buf(hwsim_vqs[HWSIM_VQ_RX], &len);
+ 	if (!skb)
+ 		goto out_unlock;
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 
+ 	skb->data = skb->head;
+ 	skb_set_tail_pointer(skb, len);
+ 	hwsim_virtio_handle_cmd(skb);
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	if (!hwsim_virtio_enabled) {
+ 		nlmsg_free(skb);
+ 		goto out_unlock;
+ 	}
+ 	vq = hwsim_vqs[HWSIM_VQ_RX];
+ 	sg_init_one(sg, skb->head, skb_end_offset(skb));
+ 	err = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_ATOMIC);
+ 	if (WARN(err, "virtqueue_add_inbuf returned %d\n", err))
+ 		nlmsg_free(skb);
+ 	else
+ 		virtqueue_kick(vq);
+ 	schedule_work(&hwsim_virtio_rx);
+ 
+ out_unlock:
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ }
+ 
+ static void hwsim_virtio_rx_done(struct virtqueue *vq)
+ {
+ 	schedule_work(&hwsim_virtio_rx);
+ }
+ 
+ static int init_vqs(struct virtio_device *vdev)
+ {
+ 	vq_callback_t *callbacks[HWSIM_NUM_VQS] = {
+ 		[HWSIM_VQ_TX] = hwsim_virtio_tx_done,
+ 		[HWSIM_VQ_RX] = hwsim_virtio_rx_done,
+ 	};
+ 	const char *names[HWSIM_NUM_VQS] = {
+ 		[HWSIM_VQ_TX] = "tx",
+ 		[HWSIM_VQ_RX] = "rx",
+ 	};
+ 
+ 	return virtio_find_vqs(vdev, HWSIM_NUM_VQS,
+ 			       hwsim_vqs, callbacks, names, NULL);
+ }
+ 
+ static int fill_vq(struct virtqueue *vq)
+ {
+ 	int i, err;
+ 	struct sk_buff *skb;
+ 	struct scatterlist sg[1];
+ 
+ 	for (i = 0; i < virtqueue_get_vring_size(vq); i++) {
+ 		skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 		if (!skb)
+ 			return -ENOMEM;
+ 
+ 		sg_init_one(sg, skb->head, skb_end_offset(skb));
+ 		err = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_KERNEL);
+ 		if (err) {
+ 			nlmsg_free(skb);
+ 			return err;
+ 		}
+ 	}
+ 	virtqueue_kick(vq);
+ 	return 0;
+ }
+ 
+ static void remove_vqs(struct virtio_device *vdev)
+ {
+ 	int i;
+ 
+ 	vdev->config->reset(vdev);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(hwsim_vqs); i++) {
+ 		struct virtqueue *vq = hwsim_vqs[i];
+ 		struct sk_buff *skb;
+ 
+ 		while ((skb = virtqueue_detach_unused_buf(vq)))
+ 			nlmsg_free(skb);
+ 	}
+ 
+ 	vdev->config->del_vqs(vdev);
+ }
+ 
+ static int hwsim_virtio_probe(struct virtio_device *vdev)
+ {
+ 	int err;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	if (hwsim_virtio_enabled) {
+ 		spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 		return -EEXIST;
+ 	}
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 
+ 	err = init_vqs(vdev);
+ 	if (err)
+ 		return err;
+ 
+ 	err = fill_vq(hwsim_vqs[HWSIM_VQ_RX]);
+ 	if (err)
+ 		goto out_remove;
+ 
+ 	spin_lock_irqsave(&hwsim_virtio_lock, flags);
+ 	hwsim_virtio_enabled = true;
+ 	spin_unlock_irqrestore(&hwsim_virtio_lock, flags);
+ 
+ 	schedule_work(&hwsim_virtio_rx);
+ 	return 0;
+ 
+ out_remove:
+ 	remove_vqs(vdev);
+ 	return err;
+ }
+ 
+ static void hwsim_virtio_remove(struct virtio_device *vdev)
+ {
+ 	hwsim_virtio_enabled = false;
+ 
+ 	cancel_work_sync(&hwsim_virtio_rx);
+ 
+ 	remove_vqs(vdev);
+ }
+ 
+ /* MAC80211_HWSIM virtio device id table */
+ static const struct virtio_device_id id_table[] = {
+ 	{ VIRTIO_ID_MAC80211_HWSIM, VIRTIO_DEV_ANY_ID },
+ 	{ 0 }
+ };
+ MODULE_DEVICE_TABLE(virtio, id_table);
+ 
+ static struct virtio_driver virtio_hwsim = {
+ 	.driver.name = KBUILD_MODNAME,
+ 	.driver.owner = THIS_MODULE,
+ 	.id_table = id_table,
+ 	.probe = hwsim_virtio_probe,
+ 	.remove = hwsim_virtio_remove,
+ };
+ 
+ static int hwsim_register_virtio_driver(void)
+ {
+ 	spin_lock_init(&hwsim_virtio_lock);
+ 
+ 	return register_virtio_driver(&virtio_hwsim);
+ }
+ 
+ static void hwsim_unregister_virtio_driver(void)
+ {
+ 	unregister_virtio_driver(&virtio_hwsim);
+ }
+ #else
+ static inline int hwsim_register_virtio_driver(void)
+ {
+ 	return 0;
+ }
+ 
+ static inline void hwsim_unregister_virtio_driver(void)
+ {
+ }
+ #endif
+ 
++>>>>>>> 0379861217dc (mac80211_hwsim: use GFP_ATOMIC under spin lock)
  static int __init init_mac80211_hwsim(void)
  {
  	int i, err;
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
