PCI/ERR: Recover from RCiEP AER errors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Qiuxu Zhuo <qiuxu.zhuo@intel.com>
commit 5790862255028c831761e13014ee87a06df828f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/57908622.failed

Add support for handling AER errors detected by Root Complex Integrated
Endpoints (RCiEPs).  These errors are signaled to software natively via a
Root Complex Event Collector (RCEC) or non-natively via ACPI APEI if the
platform retains control of AER or uses a non-standard RCEC-like device.

When recovering from RCiEP errors, the Root Error Command and Status
registers are in the AER Capability of an associated RCEC (if any), not in
a Root Port.  In the non-native case, the platform is responsible for those
registers and we can't touch them.

[bhelgaas: commit log, etc]
Co-developed-by: Sean V Kelley <sean.v.kelley@intel.com>
Link: https://lore.kernel.org/r/20201121001036.8560-13-sean.v.kelley@intel.com
	Signed-off-by: Sean V Kelley <sean.v.kelley@intel.com>
	Signed-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 5790862255028c831761e13014ee87a06df828f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pcie/aer.c
#	drivers/pci/pcie/err.c
diff --cc drivers/pci/pcie/aer.c
index b4939eeb60df,e682df536be5..000000000000
--- a/drivers/pci/pcie/aer.c
+++ b/drivers/pci/pcie/aer.c
@@@ -1351,10 -1359,10 +1351,15 @@@ static int aer_probe(struct pcie_devic
  }
  
  /**
++<<<<<<< HEAD
 + * aer_root_reset - reset link on Root Port
 + * @dev: pointer to Root Port's pci_dev data structure
++=======
+  * aer_root_reset - reset Root Port hierarchy, RCEC, or RCiEP
+  * @dev: pointer to Root Port, RCEC, or RCiEP
++>>>>>>> 579086225502 (PCI/ERR: Recover from RCiEP AER errors)
   *
 - * Invoked by Port Bus driver when performing reset.
 + * Invoked by Port Bus driver when performing link reset at Root Port.
   */
  static pci_ers_result_t aer_root_reset(struct pci_dev *dev)
  {
@@@ -1362,25 -1373,52 +1367,61 @@@
  	u32 reg32;
  	int rc;
  
++<<<<<<< HEAD
 +	if (pcie_aer_is_native(dev)) {
++=======
+ 	/*
+ 	 * Only Root Ports and RCECs have AER Root Command and Root Status
+ 	 * registers.  If "dev" is an RCiEP, the relevant registers are in
+ 	 * the RCEC.
+ 	 */
+ 	if (type == PCI_EXP_TYPE_RC_END)
+ 		root = dev->rcec;
+ 	else
+ 		root = dev;
+ 
+ 	/*
+ 	 * If the platform retained control of AER, an RCiEP may not have
+ 	 * an RCEC visible to us, so dev->rcec ("root") may be NULL.  In
+ 	 * that case, firmware is responsible for these registers.
+ 	 */
+ 	aer = root ? root->aer_cap : 0;
+ 
+ 	if ((host->native_aer || pcie_ports_native) && aer) {
++>>>>>>> 579086225502 (PCI/ERR: Recover from RCiEP AER errors)
  		/* Disable Root's interrupt in response to error messages */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, &reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, &reg32);
  		reg32 &= ~ROOT_PORT_INTR_ON_MESG_MASK;
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, reg32);
  	}
  
++<<<<<<< HEAD
 +	rc = pci_bus_error_reset(dev);
 +	pci_info(dev, "Root Port link has been reset (%d)\n", rc);
++=======
+ 	if (type == PCI_EXP_TYPE_RC_EC || type == PCI_EXP_TYPE_RC_END) {
+ 		if (pcie_has_flr(dev)) {
+ 			rc = pcie_flr(dev);
+ 			pci_info(dev, "has been reset (%d)\n", rc);
+ 		} else {
+ 			pci_info(dev, "not reset (no FLR support)\n");
+ 			rc = -ENOTTY;
+ 		}
+ 	} else {
+ 		rc = pci_bus_error_reset(dev);
+ 		pci_info(dev, "Root Port link has been reset (%d)\n", rc);
+ 	}
++>>>>>>> 579086225502 (PCI/ERR: Recover from RCiEP AER errors)
  
 -	if ((host->native_aer || pcie_ports_native) && aer) {
 +	if (pcie_aer_is_native(dev)) {
  		/* Clear Root Error Status */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_STATUS, &reg32);
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_STATUS, reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_STATUS, &reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_STATUS, reg32);
  
  		/* Enable Root Port's interrupt in response to error messages */
 -		pci_read_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, &reg32);
 +		pci_read_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, &reg32);
  		reg32 |= ROOT_PORT_INTR_ON_MESG_MASK;
 -		pci_write_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, reg32);
 +		pci_write_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, reg32);
  	}
  
  	return rc ? PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_RECOVERED;
diff --cc drivers/pci/pcie/err.c
index c74d622dbbc4,510f31f0ef6d..000000000000
--- a/drivers/pci/pcie/err.c
+++ b/drivers/pci/pcie/err.c
@@@ -146,29 -146,61 +146,73 @@@ out
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * pci_walk_bridge - walk bridges potentially AER affected
+  * @bridge:	bridge which may be a Port, an RCEC, or an RCiEP
+  * @cb:		callback to be called for each device found
+  * @userdata:	arbitrary pointer to be passed to callback
+  *
+  * If the device provided is a bridge, walk the subordinate bus, including
+  * any bridged devices on buses under this bus.  Call the provided callback
+  * on each device found.
+  *
+  * If the device provided has no subordinate bus, e.g., an RCEC or RCiEP,
+  * call the callback on the device itself.
+  */
+ static void pci_walk_bridge(struct pci_dev *bridge,
+ 			    int (*cb)(struct pci_dev *, void *),
+ 			    void *userdata)
+ {
+ 	if (bridge->subordinate)
+ 		pci_walk_bus(bridge->subordinate, cb, userdata);
+ 	else
+ 		cb(bridge, userdata);
+ }
+ 
++>>>>>>> 579086225502 (PCI/ERR: Recover from RCiEP AER errors)
  pci_ers_result_t pcie_do_recovery(struct pci_dev *dev,
 -		pci_channel_state_t state,
 -		pci_ers_result_t (*reset_subordinates)(struct pci_dev *pdev))
 +			enum pci_channel_state state,
 +			pci_ers_result_t (*reset_link)(struct pci_dev *pdev))
  {
  	int type = pci_pcie_type(dev);
 -	struct pci_dev *bridge;
  	pci_ers_result_t status = PCI_ERS_RESULT_CAN_RECOVER;
 -	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
 +	struct pci_bus *bus;
  
  	/*
++<<<<<<< HEAD
 +	 * Error recovery runs on all subordinates of the first downstream port.
 +	 * If the downstream port detected the error, it is cleared at the end.
 +	 */
 +	if (!(type == PCI_EXP_TYPE_ROOT_PORT ||
 +	      type == PCI_EXP_TYPE_DOWNSTREAM))
 +		dev = pci_upstream_bridge(dev);
 +	bus = dev->subordinate;
++=======
+ 	 * If the error was detected by a Root Port, Downstream Port, RCEC,
+ 	 * or RCiEP, recovery runs on the device itself.  For Ports, that
+ 	 * also includes any subordinate devices.
+ 	 *
+ 	 * If it was detected by another device (Endpoint, etc), recovery
+ 	 * runs on the device and anything else under the same Port, i.e.,
+ 	 * everything under "bridge".
+ 	 */
+ 	if (type == PCI_EXP_TYPE_ROOT_PORT ||
+ 	    type == PCI_EXP_TYPE_DOWNSTREAM ||
+ 	    type == PCI_EXP_TYPE_RC_EC ||
+ 	    type == PCI_EXP_TYPE_RC_END)
+ 		bridge = dev;
+ 	else
+ 		bridge = pci_upstream_bridge(dev);
++>>>>>>> 579086225502 (PCI/ERR: Recover from RCiEP AER errors)
  
 -	pci_dbg(bridge, "broadcast error_detected message\n");
 +	pci_dbg(dev, "broadcast error_detected message\n");
  	if (state == pci_channel_io_frozen) {
 -		pci_walk_bridge(bridge, report_frozen_detected, &status);
 -		status = reset_subordinates(bridge);
 +		pci_walk_bus(bus, report_frozen_detected, &status);
 +		status = reset_link(dev);
  		if (status != PCI_ERS_RESULT_RECOVERED) {
 -			pci_warn(bridge, "subordinate device reset failed\n");
 +			pci_warn(dev, "link reset failed\n");
  			goto failed;
  		}
  	} else {
* Unmerged path drivers/pci/pcie/aer.c
* Unmerged path drivers/pci/pcie/err.c
