bpf: Always return target ifindex in bpf_fib_lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Toke Høiland-Jørgensen <toke@redhat.com>
commit d1c362e1dd68a421cf9033404cf141a4ab734a5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/d1c362e1.failed

The bpf_fib_lookup() helper performs a neighbour lookup for the destination
IP and returns BPF_FIB_LKUP_NO_NEIGH if this fails, with the expectation
that the BPF program will pass the packet up the stack in this case.
However, with the addition of bpf_redirect_neigh() that can be used instead
to perform the neighbour lookup, at the cost of a bit of duplicated work.

For that we still need the target ifindex, and since bpf_fib_lookup()
already has that at the time it performs the neighbour lookup, there is
really no reason why it can't just return it in any case. So let's just
always return the ifindex if the FIB lookup itself succeeds.

	Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Cc: David Ahern <dsahern@gmail.com>
Link: https://lore.kernel.org/bpf/20201009184234.134214-1-toke@redhat.com
(cherry picked from commit d1c362e1dd68a421cf9033404cf141a4ab734a5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/filter.c
diff --cc net/core/filter.c
index a22f97d754fb,96ec4cbbf4e0..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -4941,17 -5321,16 +4940,18 @@@ static int bpf_ipv4_fib_lookup(struct n
  			return BPF_FIB_LKUP_RET_FRAG_NEEDED;
  	}
  
 -	nhc = res.nhc;
 +	nh = &res.fi->fib_nh[res.nh_sel];
  
  	/* do not handle lwt encaps right now */
 -	if (nhc->nhc_lwtstate)
 +	if (nh->nh_lwtstate)
  		return BPF_FIB_LKUP_RET_UNSUPP_LWT;
  
 -	dev = nhc->nhc_dev;
 +	dev = nh->nh_dev;
 +	if (nh->nh_gw)
 +		params->ipv4_dst = nh->nh_gw;
  
  	params->rt_metric = res.fi->fib_priority;
+ 	params->ifindex = dev->ifindex;
  
  	/* xdp and cls_bpf programs are run in RCU-bh so
  	 * rcu_read_lock_bh is not needed here
@@@ -5058,14 -5448,15 +5058,20 @@@ static int bpf_ipv6_fib_lookup(struct n
  			return BPF_FIB_LKUP_RET_FRAG_NEEDED;
  	}
  
 -	if (res.nh->fib_nh_lws)
 +	if (f6i->fib6_nh.nh_lwtstate)
  		return BPF_FIB_LKUP_RET_UNSUPP_LWT;
  
 -	if (res.nh->fib_nh_gw_family)
 -		*dst = res.nh->fib_nh_gw6;
 +	if (f6i->fib6_flags & RTF_GATEWAY)
 +		*dst = f6i->fib6_nh.nh_gw;
  
++<<<<<<< HEAD
 +	dev = f6i->fib6_nh.nh_dev;
 +	params->rt_metric = f6i->fib6_metric;
++=======
+ 	dev = res.nh->fib_nh_dev;
+ 	params->rt_metric = res.f6i->fib6_metric;
+ 	params->ifindex = dev->ifindex;
++>>>>>>> d1c362e1dd68 (bpf: Always return target ifindex in bpf_fib_lookup)
  
  	/* xdp and cls_bpf programs are run in RCU-bh so rcu_read_lock_bh is
  	 * not needed here.
* Unmerged path net/core/filter.c
