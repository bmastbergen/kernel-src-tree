mt76: mt7921: add coredump support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Sean Wang <sean.wang@mediatek.com>
commit 0da3c795d07bf005d4b0be8d6cdc4714aa51a988
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/0da3c795.failed

Introduce coredump support to mt7921 driver.

The coredump would be produced when MCU met the fatal error or driver
sent out the specific cmd to force trigger it.

Co-developed-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 0da3c795d07bf005d4b0be8d6cdc4714aa51a988)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt76_connac.h
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
#	drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
#	drivers/net/wireless/mediatek/mt76/mt7921/Kconfig
#	drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/Kconfig
index 24932d2e8dee,001f2b9cec26..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/Kconfig
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/Kconfig
@@@ -1,7 -1,8 +1,12 @@@
  # SPDX-License-Identifier: ISC
  config MT7921E
  	tristate "MediaTek MT7921E (PCIe) support"
++<<<<<<< HEAD
 +	select MT76_CORE
++=======
+ 	select MT76_CONNAC_LIB
+ 	select WANT_DEV_COREDUMP
++>>>>>>> 0da3c795d07b (mt76: mt7921: add coredump support)
  	depends on MAC80211
  	depends on PCI
  	help
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
index 9cdeb14cc933,0dc8e25e18e4..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
@@@ -159,6 -159,74 +159,77 @@@ mt7921_queues_read(struct seq_file *s, 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mt7921_pm_set(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 	struct mt76_phy *mphy = dev->phy.mt76;
+ 	int ret = 0;
+ 
+ 	mt7921_mutex_acquire(dev);
+ 
+ 	dev->pm.enable = val;
+ 
+ 	ieee80211_iterate_active_interfaces(mphy->hw,
+ 					    IEEE80211_IFACE_ITER_RESUME_ALL,
+ 					    mt7921_pm_interface_iter, mphy->priv);
+ 	mt7921_mutex_release(dev);
+ 
+ 	return ret;
+ }
+ 
+ static int
+ mt7921_pm_get(void *data, u64 *val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	*val = dev->pm.enable;
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_pm, mt7921_pm_get, mt7921_pm_set, "%lld\n");
+ 
+ static int
+ mt7921_pm_idle_timeout_set(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	dev->pm.idle_timeout = msecs_to_jiffies(val);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_idle_timeout_get(void *data, u64 *val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	*val = jiffies_to_msecs(dev->pm.idle_timeout);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_pm_idle_timeout, mt7921_pm_idle_timeout_get,
+ 			 mt7921_pm_idle_timeout_set, "%lld\n");
+ 
+ static int mt7921_config(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 	int ret;
+ 
+ 	mt7921_mutex_acquire(dev);
+ 	ret = mt76_connac_mcu_chip_config(&dev->mt76);
+ 	mt7921_mutex_release(dev);
+ 
+ 	return ret;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_config, NULL, mt7921_config, "%lld\n");
+ 
++>>>>>>> 0da3c795d07b (mt76: mt7921: add coredump support)
  int mt7921_init_debugfs(struct mt7921_dev *dev)
  {
  	struct dentry *dir;
@@@ -173,6 -241,10 +244,13 @@@
  				    mt7921_queues_acq);
  	debugfs_create_file("tx_stats", 0400, dir, dev, &fops_tx_stats);
  	debugfs_create_file("fw_debug", 0600, dir, dev, &fops_fw_debug);
++<<<<<<< HEAD
++=======
+ 	debugfs_create_file("runtime-pm", 0600, dir, dev, &fops_pm);
+ 	debugfs_create_file("idle-timeout", 0600, dir, dev,
+ 			    &fops_pm_idle_timeout);
+ 	debugfs_create_file("chip_config", 0600, dir, dev, &fops_config);
++>>>>>>> 0da3c795d07b (mt76: mt7921: add coredump support)
  
  	return 0;
  }
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index 968894cfc98b,3f9097481a5e..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@@ -1386,8 -1401,116 +1388,118 @@@ void mt7921_mac_work(struct work_struc
  		mt7921_mac_sta_stats_work(phy);
  	};
  
 -	mt7921_mutex_release(phy->dev);
 +	mutex_unlock(&mphy->dev->mutex);
  
 -out:
 -	ieee80211_queue_delayed_work(phy->mt76->hw, &mphy->mac_work,
 +	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
  				     MT7921_WATCHDOG_TIME);
  }
++<<<<<<< HEAD
++=======
+ 
+ void mt7921_pm_wake_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	struct mt76_phy *mphy;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						pm.wake_work);
+ 	mphy = dev->phy.mt76;
+ 
+ 	if (!mt7921_mcu_drv_pmctrl(dev))
+ 		mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
+ 	else
+ 		dev_err(mphy->dev->dev, "failed to wake device\n");
+ 
+ 	ieee80211_wake_queues(mphy->hw);
+ 	complete_all(&dev->pm.wake_cmpl);
+ }
+ 
+ void mt7921_pm_power_save_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	unsigned long delta;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						pm.ps_work.work);
+ 
+ 	delta = dev->pm.idle_timeout;
+ 	if (time_is_after_jiffies(dev->pm.last_activity + delta)) {
+ 		delta = dev->pm.last_activity + delta - jiffies;
+ 		goto out;
+ 	}
+ 
+ 	if (!mt7921_mcu_fw_pmctrl(dev))
+ 		return;
+ out:
+ 	queue_delayed_work(dev->mt76.wq, &dev->pm.ps_work, delta);
+ }
+ 
+ int mt7921_mac_set_beacon_filter(struct mt7921_phy *phy,
+ 				 struct ieee80211_vif *vif,
+ 				 bool enable)
+ {
+ 	struct mt7921_dev *dev = phy->dev;
+ 	bool ext_phy = phy != &dev->phy;
+ 	int err;
+ 
+ 	if (!dev->pm.enable)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = mt7921_mcu_set_bss_pm(dev, vif, enable);
+ 	if (err)
+ 		return err;
+ 
+ 	if (enable) {
+ 		vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_set(dev, MT_WF_RFCR(ext_phy),
+ 			 MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	} else {
+ 		vif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;
+ 		mt76_clear(dev, MT_WF_RFCR(ext_phy),
+ 			   MT_WF_RFCR_DROP_OTHER_BEACON);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void mt7921_coredump_work(struct work_struct *work)
+ {
+ 	struct mt7921_dev *dev;
+ 	char *dump, *data;
+ 
+ 	dev = (struct mt7921_dev *)container_of(work, struct mt7921_dev,
+ 						coredump.work.work);
+ 
+ 	if (time_is_after_jiffies(dev->coredump.last_activity +
+ 				  4 * MT76_CONNAC_COREDUMP_TIMEOUT)) {
+ 		queue_delayed_work(dev->mt76.wq, &dev->coredump.work,
+ 				   MT76_CONNAC_COREDUMP_TIMEOUT);
+ 		return;
+ 	}
+ 
+ 	dump = vzalloc(MT76_CONNAC_COREDUMP_SZ);
+ 	data = dump;
+ 
+ 	while (true) {
+ 		struct sk_buff *skb;
+ 
+ 		spin_lock_bh(&dev->mt76.lock);
+ 		skb = __skb_dequeue(&dev->coredump.msg_list);
+ 		spin_unlock_bh(&dev->mt76.lock);
+ 
+ 		if (!skb)
+ 			break;
+ 
+ 		skb_pull(skb, sizeof(struct mt7921_mcu_rxd));
+ 		if (data + skb->len - dump > MT76_CONNAC_COREDUMP_SZ)
+ 			break;
+ 
+ 		memcpy(data, skb->data, skb->len);
+ 		data += skb->len;
+ 
+ 		dev_kfree_skb(skb);
+ 	}
+ 	dev_coredumpv(dev->mt76.dev, dump, MT76_CONNAC_COREDUMP_SZ,
+ 		      GFP_KERNEL);
+ }
++>>>>>>> 0da3c795d07b (mt76: mt7921: add coredump support)
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index a6d5a000d9cc,46e6aeec35ae..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@@ -6,7 -6,7 +6,11 @@@
  
  #include <linux/interrupt.h>
  #include <linux/ktime.h>
++<<<<<<< HEAD
 +#include "../mt76.h"
++=======
+ #include "../mt76_connac_mcu.h"
++>>>>>>> 0da3c795d07b (mt76: mt7921: add coredump support)
  #include "regs.h"
  
  #define MT7921_MAX_INTERFACES		4
@@@ -164,20 -162,9 +168,25 @@@ struct mt7921_dev 
  	struct idr token;
  
  	u8 fw_debug;
 +};
  
++<<<<<<< HEAD
 +enum {
 +	HW_BSSID_0 = 0x0,
 +	HW_BSSID_1,
 +	HW_BSSID_2,
 +	HW_BSSID_3,
 +	HW_BSSID_MAX = HW_BSSID_3,
 +	EXT_BSSID_START = 0x10,
 +	EXT_BSSID_1,
 +	EXT_BSSID_15 = 0x1f,
 +	EXT_BSSID_MAX = EXT_BSSID_15,
 +	REPEATER_BSSID_START = 0x20,
 +	REPEATER_BSSID_MAX = 0x3f,
++=======
+ 	struct mt76_connac_pm pm;
+ 	struct mt76_connac_coredump coredump;
++>>>>>>> 0da3c795d07b (mt76: mt7921: add coredump support)
  };
  
  enum {
@@@ -369,4 -329,14 +378,17 @@@ int mt7921_mcu_update_gtk_rekey(struct 
  int mt7921_mcu_update_arp_filter(struct ieee80211_hw *hw,
  				 struct ieee80211_vif *vif,
  				 struct ieee80211_bss_conf *info);
++<<<<<<< HEAD
++=======
+ int mt7921_mcu_drv_pmctrl(struct mt7921_dev *dev);
+ int mt7921_mcu_fw_pmctrl(struct mt7921_dev *dev);
+ void mt7921_pm_wake_work(struct work_struct *work);
+ void mt7921_pm_power_save_work(struct work_struct *work);
+ bool mt7921_wait_for_mcu_init(struct mt7921_dev *dev);
+ int mt7921_mac_set_beacon_filter(struct mt7921_phy *phy,
+ 				 struct ieee80211_vif *vif,
+ 				 bool enable);
+ void mt7921_pm_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif);
+ void mt7921_coredump_work(struct work_struct *work);
++>>>>>>> 0da3c795d07b (mt76: mt7921: add coredump support)
  #endif
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/Kconfig
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/init.c b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
index de8b54e6c039..ea166a5008e9 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/init.c
@@ -218,7 +218,9 @@ int mt7921_register_device(struct mt7921_dev *dev)
 	INIT_LIST_HEAD(&dev->phy.stats_list);
 	INIT_DELAYED_WORK(&dev->mphy.mac_work, mt7921_mac_work);
 	INIT_DELAYED_WORK(&dev->phy.scan_work, mt7921_scan_work);
+	INIT_DELAYED_WORK(&dev->coredump.work, mt7921_coredump_work);
 	skb_queue_head_init(&dev->phy.scan_event_list);
+	skb_queue_head_init(&dev->coredump.msg_list);
 	INIT_LIST_HEAD(&dev->sta_poll_list);
 	spin_lock_init(&dev->sta_poll_lock);
 
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
index 77055ff812eb..3a5a0ec654d4 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
@@ -639,6 +639,10 @@ mt7921_mcu_rx_unsolicited_event(struct mt7921_dev *dev, struct sk_buff *skb)
 	case MCU_EVENT_DBG_MSG:
 		mt7921_mcu_debug_msg_event(dev, skb);
 		break;
+	case MCU_EVENT_COREDUMP:
+		mt76_connac_mcu_coredump_event(&dev->mt76, skb,
+					       &dev->coredump);
+		return;
 	default:
 		break;
 	}
@@ -660,6 +664,7 @@ void mt7921_mcu_rx_event(struct mt7921_dev *dev, struct sk_buff *skb)
 	    rxd->eid == MCU_EVENT_BSS_ABSENCE ||
 	    rxd->eid == MCU_EVENT_SCAN_DONE ||
 	    rxd->eid == MCU_EVENT_DBG_MSG ||
+	    rxd->eid == MCU_EVENT_COREDUMP ||
 	    !rxd->seq)
 		mt7921_mcu_rx_unsolicited_event(dev, skb);
 	else
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.h b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.h
index 6b3877959bd3..3b91529d3bb4 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.h
@@ -83,6 +83,7 @@ enum {
 	MCU_EVENT_CH_PRIVILEGE = 0x18,
 	MCU_EVENT_SCHED_SCAN_DONE = 0x23,
 	MCU_EVENT_DBG_MSG = 0x27,
+	MCU_EVENT_COREDUMP = 0xf0,
 };
 
 /* ext event table */
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
