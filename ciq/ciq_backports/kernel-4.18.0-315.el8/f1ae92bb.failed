mt76: mt7921: add wifisys reset support in debugfs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Sean Wang <sean.wang@mediatek.com>
commit f1ae92bbc43b68521bc0e866327dc896f10c11ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/f1ae92bb.failed

Introduce chip_reset knob in mt7921 debugfs to export a way to users
able to trigger wifi reset, and group the similar operations
previously defined in chip_config in the same knob.

	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit f1ae92bbc43b68521bc0e866327dc896f10c11ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
index 1557547efa2f,5a54cd8d2ce4..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
@@@ -161,6 -149,159 +161,162 @@@ mt7921_queues_read(struct seq_file *s, 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mt7921_seq_puts_array(struct seq_file *file, const char *str,
+ 		      s8 *val, int len)
+ {
+ 	int i;
+ 
+ 	seq_printf(file, "%-16s:", str);
+ 	for (i = 0; i < len; i++)
+ 		if (val[i] == 127)
+ 			seq_printf(file, " %6s", "N.A");
+ 		else
+ 			seq_printf(file, " %6d", val[i]);
+ 	seq_puts(file, "\n");
+ }
+ 
+ #define mt7921_print_txpwr_entry(prefix, rate)				\
+ ({									\
+ 	mt7921_seq_puts_array(s, #prefix " (user)",			\
+ 			      txpwr.data[TXPWR_USER].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_USER].rate)); \
+ 	mt7921_seq_puts_array(s, #prefix " (eeprom)",			\
+ 			      txpwr.data[TXPWR_EEPROM].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_EEPROM].rate)); \
+ 	mt7921_seq_puts_array(s, #prefix " (tmac)",			\
+ 			      txpwr.data[TXPWR_MAC].rate,		\
+ 			      ARRAY_SIZE(txpwr.data[TXPWR_MAC].rate));	\
+ })
+ 
+ static int
+ mt7921_txpwr(struct seq_file *s, void *data)
+ {
+ 	struct mt7921_dev *dev = dev_get_drvdata(s->private);
+ 	struct mt7921_txpwr txpwr;
+ 	int ret;
+ 
+ 	ret = mt7921_get_txpwr_info(dev, &txpwr);
+ 	if (ret)
+ 		return ret;
+ 
+ 	seq_printf(s, "Tx power table (channel %d)\n", txpwr.ch);
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s\n",
+ 		   " ", "1m", "2m", "5m", "11m");
+ 	mt7921_print_txpwr_entry(CCK, cck);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "6m", "9m", "12m", "18m", "24m", "36m",
+ 		   "48m", "54m");
+ 	mt7921_print_txpwr_entry(OFDM, ofdm);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7");
+ 	mt7921_print_txpwr_entry(HT20, ht20);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7", "mcs32");
+ 	mt7921_print_txpwr_entry(HT40, ht40);
+ 
+ 	seq_printf(s, "%-16s  %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+ 		   " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+ 		   "mcs6", "mcs7", "mcs8", "mcs9", "mcs10", "mcs11");
+ 	mt7921_print_txpwr_entry(VHT20, vht20);
+ 	mt7921_print_txpwr_entry(VHT40, vht40);
+ 	mt7921_print_txpwr_entry(VHT80, vht80);
+ 	mt7921_print_txpwr_entry(VHT160, vht160);
+ 	mt7921_print_txpwr_entry(HE26, he26);
+ 	mt7921_print_txpwr_entry(HE52, he52);
+ 	mt7921_print_txpwr_entry(HE106, he106);
+ 	mt7921_print_txpwr_entry(HE242, he242);
+ 	mt7921_print_txpwr_entry(HE484, he484);
+ 	mt7921_print_txpwr_entry(HE996, he996);
+ 	mt7921_print_txpwr_entry(HE996x2, he996x2);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_set(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 	struct mt76_phy *mphy = dev->phy.mt76;
+ 
+ 	mt7921_mutex_acquire(dev);
+ 
+ 	dev->pm.enable = val;
+ 
+ 	ieee80211_iterate_active_interfaces(mphy->hw,
+ 					    IEEE80211_IFACE_ITER_RESUME_ALL,
+ 					    mt7921_pm_interface_iter, mphy->priv);
+ 	mt7921_mutex_release(dev);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_get(void *data, u64 *val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	*val = dev->pm.enable;
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_pm, mt7921_pm_get, mt7921_pm_set, "%lld\n");
+ 
+ static int
+ mt7921_pm_idle_timeout_set(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	dev->pm.idle_timeout = msecs_to_jiffies(val);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mt7921_pm_idle_timeout_get(void *data, u64 *val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 
+ 	*val = jiffies_to_msecs(dev->pm.idle_timeout);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_pm_idle_timeout, mt7921_pm_idle_timeout_get,
+ 			 mt7921_pm_idle_timeout_set, "%lld\n");
+ 
+ static int mt7921_chip_reset(void *data, u64 val)
+ {
+ 	struct mt7921_dev *dev = data;
+ 	int ret = 0;
+ 
+ 	switch (val) {
+ 	case 1:
+ 		/* Reset wifisys directly. */
+ 		mt7921_reset(&dev->mt76);
+ 		break;
+ 	default:
+ 		/* Collect the core dump before reset wifisys. */
+ 		mt7921_mutex_acquire(dev);
+ 		ret = mt76_connac_mcu_chip_config(&dev->mt76);
+ 		mt7921_mutex_release(dev);
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ DEFINE_DEBUGFS_ATTRIBUTE(fops_reset, NULL, mt7921_chip_reset, "%lld\n");
+ 
++>>>>>>> f1ae92bbc43b (mt76: mt7921: add wifisys reset support in debugfs)
  int mt7921_init_debugfs(struct mt7921_dev *dev)
  {
  	struct dentry *dir;
@@@ -173,8 -314,14 +329,15 @@@
  				    mt7921_queues_read);
  	debugfs_create_devm_seqfile(dev->mt76.dev, "acq", dir,
  				    mt7921_queues_acq);
 -	debugfs_create_devm_seqfile(dev->mt76.dev, "txpower_sku", dir,
 -				    mt7921_txpwr);
 -	debugfs_create_file("tx_stats", 0400, dir, dev, &mt7921_tx_stats_fops);
 +	debugfs_create_file("tx_stats", 0400, dir, dev, &fops_tx_stats);
  	debugfs_create_file("fw_debug", 0600, dir, dev, &fops_fw_debug);
++<<<<<<< HEAD
++=======
+ 	debugfs_create_file("runtime-pm", 0600, dir, dev, &fops_pm);
+ 	debugfs_create_file("idle-timeout", 0600, dir, dev,
+ 			    &fops_pm_idle_timeout);
+ 	debugfs_create_file("chip_reset", 0600, dir, dev, &fops_reset);
++>>>>>>> f1ae92bbc43b (mt76: mt7921: add wifisys reset support in debugfs)
  
  	return 0;
  }
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/debugfs.c
