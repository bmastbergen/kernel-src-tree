tcp: move rx_opt & syn_data_acked init to tcp_disconnect()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 6bcdc40dddfe79408e809ec1e2c13f08c863c0b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/6bcdc40d.failed

If we make sure all listeners have these fields cleared, then a clone
will also inherit zero values.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6bcdc40dddfe79408e809ec1e2c13f08c863c0b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
#	net/ipv4/tcp_minisocks.c
diff --cc net/ipv4/tcp.c
index 09484262d3e9,541bdb9f81d7..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -2663,6 -2609,19 +2663,22 @@@ int tcp_disconnect(struct sock *sk, in
  	tp->sacked_out = 0;
  	tp->tlp_high_seq = 0;
  	tp->last_oow_ack_time = 0;
++<<<<<<< HEAD
++=======
+ 	/* There's a bubble in the pipe until at least the first ACK. */
+ 	tp->app_limited = ~0U;
+ 	tp->rack.mstamp = 0;
+ 	tp->rack.advanced = 0;
+ 	tp->rack.reo_wnd_steps = 1;
+ 	tp->rack.last_delivered = 0;
+ 	tp->rack.reo_wnd_persist = 0;
+ 	tp->rack.dsack_seen = 0;
+ 	tp->syn_data_acked = 0;
+ 	tp->rx_opt.saw_tstamp = 0;
+ 	tp->rx_opt.dsack = 0;
+ 	tp->rx_opt.num_sacks = 0;
+ 
++>>>>>>> 6bcdc40dddfe (tcp: move rx_opt & syn_data_acked init to tcp_disconnect())
  
  	/* Clean up fastopen related fields */
  	tcp_free_fastopen_req(tp);
diff --cc net/ipv4/tcp_minisocks.c
index 079dc195a8be,182595e2d40f..000000000000
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@@ -487,25 -486,9 +487,20 @@@ struct sock *tcp_create_openreq_child(c
  	newsk->sk_txhash = treq->txhash;
  	newtp->total_retrans = req->num_retrans;
  
 +	/* So many TCP implementations out there (incorrectly) count the
 +	 * initial SYN frame in their delayed-ACK and congestion control
 +	 * algorithms that we must have the following bandaid to talk
 +	 * efficiently to them.  -DaveM
 +	 */
 +	newtp->snd_cwnd = TCP_INIT_CWND;
 +	newtp->snd_cwnd_cnt = 0;
 +
 +	/* There's a bubble in the pipe until at least the first ACK. */
 +	newtp->app_limited = ~0U;
 +
  	tcp_init_xmit_timers(newsk);
 -	newtp->write_seq = newtp->pushed_seq = treq->snt_isn + 1;
 +	WRITE_ONCE(newtp->write_seq, newtp->pushed_seq = treq->snt_isn + 1);
  
- 	newtp->rx_opt.saw_tstamp = 0;
- 
- 	newtp->rx_opt.dsack = 0;
- 	newtp->rx_opt.num_sacks = 0;
- 
  	if (sock_flag(newsk, SOCK_KEEPOPEN))
  		inet_csk_reset_keepalive_timer(newsk,
  					       keepalive_time_when(newtp));
@@@ -545,16 -528,7 +540,20 @@@
  	newtp->rx_opt.mss_clamp = req->mss;
  	tcp_ecn_openreq_child(newtp, req);
  	newtp->fastopen_req = NULL;
++<<<<<<< HEAD
 +	RCU_INIT_POINTER(newtp->fastopen_rsk, NULL);
 +	newtp->syn_data_acked = 0;
 +	newtp->rack.mstamp = 0;
 +	newtp->rack.advanced = 0;
 +	newtp->rack.reo_wnd_steps = 1;
 +	newtp->rack.last_delivered = 0;
 +	newtp->rack.reo_wnd_persist = 0;
 +	newtp->rack.dsack_seen = 0;
 +
 +	tcp_bpf_clone(sk, newsk);
++=======
+ 	newtp->fastopen_rsk = NULL;
++>>>>>>> 6bcdc40dddfe (tcp: move rx_opt & syn_data_acked init to tcp_disconnect())
  
  	__TCP_INC_STATS(sock_net(sk), TCP_MIB_PASSIVEOPENS);
  
* Unmerged path net/ipv4/tcp.c
* Unmerged path net/ipv4/tcp_minisocks.c
