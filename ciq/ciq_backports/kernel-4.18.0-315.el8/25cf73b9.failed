libbpf: Fix possible use after free in xsk_socket__delete

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit 25cf73b9ff88fd4608699a0313f820758b4c252d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/25cf73b9.failed

Fix a possible use after free in xsk_socket__delete that will happen
if xsk_put_ctx() frees the ctx. To fix, save the umem reference taken
from the context and just use that instead.

Fixes: 2f6324a3937f ("libbpf: Support shared umems between queues and devices")
	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Andrii Nakryiko <andrii@kernel.org>
Link: https://lore.kernel.org/bpf/1604396490-12129-3-git-send-email-magnus.karlsson@gmail.com
(cherry picked from commit 25cf73b9ff88fd4608699a0313f820758b4c252d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/xsk.c
diff --cc tools/lib/bpf/xsk.c
index a9b02103767b,9bc537d0b92d..000000000000
--- a/tools/lib/bpf/xsk.c
+++ b/tools/lib/bpf/xsk.c
@@@ -776,14 -892,18 +776,25 @@@ void xsk_socket__delete(struct xsk_sock
  {
  	size_t desc_sz = sizeof(struct xdp_desc);
  	struct xdp_mmap_offsets off;
++<<<<<<< HEAD
++=======
+ 	struct xsk_umem *umem;
+ 	struct xsk_ctx *ctx;
++>>>>>>> 25cf73b9ff88 (libbpf: Fix possible use after free in xsk_socket__delete)
  	int err;
  
  	if (!xsk)
  		return;
  
++<<<<<<< HEAD
 +	if (xsk->prog_fd != -1) {
++=======
+ 	ctx = xsk->ctx;
+ 	umem = ctx->umem;
+ 	if (ctx->prog_fd != -1) {
++>>>>>>> 25cf73b9ff88 (libbpf: Fix possible use after free in xsk_socket__delete)
  		xsk_delete_bpf_maps(xsk);
 -		close(ctx->prog_fd);
 +		close(xsk->prog_fd);
  	}
  
  	err = xsk_get_mmap_offsets(xsk->fd, &off);
@@@ -796,14 -916,15 +807,24 @@@
  			munmap(xsk->tx->ring - off.tx.desc,
  			       off.tx.desc + xsk->config.tx_size * desc_sz);
  		}
 +
  	}
  
++<<<<<<< HEAD
 +	xsk->umem->refcount--;
 +	/* Do not close an fd that also has an associated umem connected
 +	 * to it.
 +	 */
 +	if (xsk->fd != xsk->umem->fd)
++=======
+ 	xsk_put_ctx(ctx);
+ 
+ 	umem->refcount--;
+ 	/* Do not close an fd that also has an associated umem connected
+ 	 * to it.
+ 	 */
+ 	if (xsk->fd != umem->fd)
++>>>>>>> 25cf73b9ff88 (libbpf: Fix possible use after free in xsk_socket__delete)
  		close(xsk->fd);
  	free(xsk);
  }
* Unmerged path tools/lib/bpf/xsk.c
