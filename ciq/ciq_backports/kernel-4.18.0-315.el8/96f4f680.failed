KVM: arm64: Don't advertise FEAT_SPE to guests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Alexandru Elisei <alexandru.elisei@arm.com>
commit 96f4f6809beec1bb2338e1aeac408e6a733f8135
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/96f4f680.failed

Even though KVM sets up MDCR_EL2 to trap accesses to the SPE buffer and
sampling control registers and to inject an undefined exception, the
presence of FEAT_SPE is still advertised in the ID_AA64DFR0_EL1 register,
if the hardware supports it. Getting an undefined exception when accessing
a register usually happens for a hardware feature which is not implemented,
and indeed this is how PMU emulation is handled when the virtual machine
has been created without the KVM_ARM_VCPU_PMU_V3 feature. Let's be
consistent and never advertise FEAT_SPE, because KVM doesn't have support
for emulating it yet.

	Signed-off-by: Alexandru Elisei <alexandru.elisei@arm.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20210409152154.198566-3-alexandru.elisei@arm.com
(cherry picked from commit 96f4f6809beec1bb2338e1aeac408e6a733f8135)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/sys_regs.c
diff --cc arch/arm64/kvm/sys_regs.c
index 4a40d4e1e697,61ee9bfb8826..000000000000
--- a/arch/arm64/kvm/sys_regs.c
+++ b/arch/arm64/kvm/sys_regs.c
@@@ -1112,34 -1032,46 +1112,44 @@@ static bool access_arch_timer(struct kv
  static u64 read_id_reg(const struct kvm_vcpu *vcpu,
  		struct sys_reg_desc const *r, bool raz)
  {
 -	u32 id = reg_to_encoding(r);
 +	u32 id = sys_reg((u32)r->Op0, (u32)r->Op1,
 +			 (u32)r->CRn, (u32)r->CRm, (u32)r->Op2);
  	u64 val = raz ? 0 : read_sanitised_ftr_reg(id);
  
 -	switch (id) {
 -	case SYS_ID_AA64PFR0_EL1:
 +	if (id == SYS_ID_AA64PFR0_EL1) {
  		if (!vcpu_has_sve(vcpu))
 -			val &= ~FEATURE(ID_AA64PFR0_SVE);
 -		val &= ~FEATURE(ID_AA64PFR0_AMU);
 -		val &= ~FEATURE(ID_AA64PFR0_CSV2);
 -		val |= FIELD_PREP(FEATURE(ID_AA64PFR0_CSV2), (u64)vcpu->kvm->arch.pfr0_csv2);
 -		val &= ~FEATURE(ID_AA64PFR0_CSV3);
 -		val |= FIELD_PREP(FEATURE(ID_AA64PFR0_CSV3), (u64)vcpu->kvm->arch.pfr0_csv3);
 -		break;
 -	case SYS_ID_AA64PFR1_EL1:
 -		val &= ~FEATURE(ID_AA64PFR1_MTE);
 -		break;
 -	case SYS_ID_AA64ISAR1_EL1:
 -		if (!vcpu_has_ptrauth(vcpu))
 -			val &= ~(FEATURE(ID_AA64ISAR1_APA) |
 -				 FEATURE(ID_AA64ISAR1_API) |
 -				 FEATURE(ID_AA64ISAR1_GPA) |
 -				 FEATURE(ID_AA64ISAR1_GPI));
 -		break;
 -	case SYS_ID_AA64DFR0_EL1:
 -		/* Limit debug to ARMv8.0 */
 -		val &= ~FEATURE(ID_AA64DFR0_DEBUGVER);
 -		val |= FIELD_PREP(FEATURE(ID_AA64DFR0_DEBUGVER), 6);
 -		/* Limit guests to PMUv3 for ARMv8.4 */
 +			val &= ~(0xfUL << ID_AA64PFR0_SVE_SHIFT);
 +		val &= ~(0xfUL << ID_AA64PFR0_AMU_SHIFT);
 +	} else if (id == SYS_ID_AA64ISAR1_EL1 && !vcpu_has_ptrauth(vcpu)) {
 +		val &= ~((0xfUL << ID_AA64ISAR1_APA_SHIFT) |
 +			 (0xfUL << ID_AA64ISAR1_API_SHIFT) |
 +			 (0xfUL << ID_AA64ISAR1_GPA_SHIFT) |
 +			 (0xfUL << ID_AA64ISAR1_GPI_SHIFT));
 +	} else if (id == SYS_ID_AA64DFR0_EL1) {
 +		u64 cap = 0;
 +
 +		/* Limit guests to PMUv3 for ARMv8.1 */
 +		if (kvm_vcpu_has_pmu(vcpu))
 +			cap = ID_AA64DFR0_PMUVER_8_1;
 +
  		val = cpuid_feature_cap_perfmon_field(val,
++<<<<<<< HEAD
 +						ID_AA64DFR0_PMUVER_SHIFT,
 +						cap);
 +	} else if (id == SYS_ID_DFR0_EL1) {
 +		/* Limit guests to PMUv3 for ARMv8.1 */
++=======
+ 						      ID_AA64DFR0_PMUVER_SHIFT,
+ 						      kvm_vcpu_has_pmu(vcpu) ? ID_AA64DFR0_PMUVER_8_4 : 0);
+ 		/* Hide SPE from guests */
+ 		val &= ~FEATURE(ID_AA64DFR0_PMSVER);
+ 		break;
+ 	case SYS_ID_DFR0_EL1:
+ 		/* Limit guests to PMUv3 for ARMv8.4 */
++>>>>>>> 96f4f6809bee (KVM: arm64: Don't advertise FEAT_SPE to guests)
  		val = cpuid_feature_cap_perfmon_field(val,
  						      ID_DFR0_PERFMON_SHIFT,
 -						      kvm_vcpu_has_pmu(vcpu) ? ID_DFR0_PERFMON_8_4 : 0);
 -		break;
 +						      kvm_vcpu_has_pmu(vcpu) ? ID_DFR0_PERFMON_8_1 : 0);
  	}
  
  	return val;
* Unmerged path arch/arm64/kvm/sys_regs.c
