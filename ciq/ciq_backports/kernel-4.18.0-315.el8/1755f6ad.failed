mt76: mt76_connac: move pm utility routines in mt76_connac_lib module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 1755f6ad0fe0f04a958039b05f8fb38c5217f01b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/1755f6ad.failed

Move power_save common code shared between mt7663 and mt7921 in
mt76_connac module

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 1755f6ad0fe0f04a958039b05f8fb38c5217f01b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/Makefile
#	drivers/net/wireless/mediatek/mt76/mt7615/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7615/main.c
#	drivers/net/wireless/mediatek/mt76/mt76_connac.h
diff --cc drivers/net/wireless/mediatek/mt76/Makefile
index e53584db0756,eac419c64788..000000000000
--- a/drivers/net/wireless/mediatek/mt76/Makefile
+++ b/drivers/net/wireless/mediatek/mt76/Makefile
@@@ -26,6 -27,8 +26,11 @@@ mt76x02-lib-y := mt76x02_util.o mt76x02
  
  mt76x02-usb-y := mt76x02_usb_mcu.o mt76x02_usb_core.o
  
++<<<<<<< HEAD
++=======
+ mt76-connac-lib-y := mt76_connac_mcu.o mt76_connac_mac.o
+ 
++>>>>>>> 1755f6ad0fe0 (mt76: mt76_connac: move pm utility routines in mt76_connac_lib module)
  obj-$(CONFIG_MT76x0_COMMON) += mt76x0/
  obj-$(CONFIG_MT76x2_COMMON) += mt76x2/
  obj-$(CONFIG_MT7603E) += mt7603/
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mac.c
index 433d4c941a48,6a3e1a609852..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
@@@ -1868,33 -1867,11 +1867,36 @@@ void mt7615_pm_wake_work(struct work_st
  						pm.wake_work);
  	mphy = dev->phy.mt76;
  
- 	if (mt7615_mcu_set_drv_ctrl(dev)) {
+ 	if (!mt7615_mcu_set_drv_ctrl(dev))
+ 		mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
+ 	else
  		dev_err(mphy->dev->dev, "failed to wake device\n");
- 		goto out;
- 	}
  
++<<<<<<< HEAD
 +	spin_lock_bh(&dev->pm.txq_lock);
 +	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 +		struct mt7615_sta *msta = dev->pm.tx_q[i].msta;
 +		struct ieee80211_sta *sta = NULL;
 +		struct mt76_wcid *wcid;
 +
 +		if (!dev->pm.tx_q[i].skb)
 +			continue;
 +
 +		wcid = msta ? &msta->wcid : &dev->mt76.global_wcid;
 +		if (msta && wcid->sta)
 +			sta = container_of((void *)msta, struct ieee80211_sta,
 +					   drv_priv);
 +
 +		mt76_tx(mphy, sta, wcid, dev->pm.tx_q[i].skb);
 +		dev->pm.tx_q[i].skb = NULL;
 +	}
 +	spin_unlock_bh(&dev->pm.txq_lock);
 +
 +	mt76_worker_schedule(&dev->mt76.tx_worker);
 +
 +out:
++=======
++>>>>>>> 1755f6ad0fe0 (mt76: mt76_connac: move pm utility routines in mt76_connac_lib module)
  	ieee80211_wake_queues(mphy->hw);
  	complete_all(&dev->pm.wake_cmpl);
  }
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/main.c
index 56dd0b4e4460,25faf486d279..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/main.c
@@@ -24,22 -24,6 +24,25 @@@ static bool mt7615_dev_running(struct m
  	return phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state);
  }
  
++<<<<<<< HEAD
 +static void mt7615_free_pending_tx_skbs(struct mt7615_dev *dev,
 +					struct mt7615_sta *msta)
 +{
 +	int i;
 +
 +	spin_lock_bh(&dev->pm.txq_lock);
 +	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 +		if (msta && dev->pm.tx_q[i].msta != msta)
 +			continue;
 +
 +		dev_kfree_skb(dev->pm.tx_q[i].skb);
 +		dev->pm.tx_q[i].skb = NULL;
 +	}
 +	spin_unlock_bh(&dev->pm.txq_lock);
 +}
 +
++=======
++>>>>>>> 1755f6ad0fe0 (mt76: mt76_connac: move pm utility routines in mt76_connac_lib module)
  static int mt7615_start(struct ieee80211_hw *hw)
  {
  	struct mt7615_dev *dev = mt7615_hw_dev(hw);
@@@ -256,10 -242,10 +259,10 @@@ static void mt7615_remove_interface(str
  	if (vif == phy->monitor_vif)
  	    phy->monitor_vif = NULL;
  
- 	mt7615_free_pending_tx_skbs(dev, msta);
+ 	mt76_connac_free_pending_tx_skbs(&dev->pm, &msta->wcid);
  
  	mt7615_mac_set_beacon_filter(phy, vif, false);
 -	mt7615_mcu_add_dev_info(phy, vif, false);
 +	mt7615_mcu_add_dev_info(dev, vif, false);
  
  	rcu_assign_pointer(dev->mt76.wcid[idx], NULL);
  
@@@ -588,23 -576,20 +592,27 @@@ int mt7615_mac_sta_add(struct mt76_dev 
  	msta->vif = mvif;
  	msta->wcid.sta = 1;
  	msta->wcid.idx = idx;
 -	msta->wcid.ext_phy = mvif->mt76.band_idx;
 +	msta->wcid.ext_phy = mvif->band_idx;
  
- 	err = mt7615_pm_wake(dev);
+ 	phy = mvif->mt76.band_idx ? mt7615_ext_phy(dev) : &dev->phy;
+ 	err = mt76_connac_pm_wake(phy->mt76, &dev->pm);
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {
 +		struct mt7615_phy *phy;
 +
 +		phy = mvif->band_idx ? mt7615_ext_phy(dev) : &dev->phy;
++=======
+ 	if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)
++>>>>>>> 1755f6ad0fe0 (mt76: mt76_connac: move pm utility routines in mt76_connac_lib module)
  		mt7615_mcu_add_bss_info(phy, vif, sta, true);
- 	}
  	mt7615_mac_wtbl_update(dev, idx,
  			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
 -	mt7615_mcu_sta_add(&dev->phy, vif, sta, true);
 +	mt7615_mcu_sta_add(dev, vif, sta, true);
  
- 	mt7615_pm_power_save_sched(dev);
+ 	mt76_connac_power_save_sched(phy->mt76, &dev->pm);
  
  	return 0;
  }
@@@ -615,20 -600,19 +623,27 @@@ void mt7615_mac_sta_remove(struct mt76_
  {
  	struct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);
  	struct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;
+ 	struct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;
+ 	struct mt7615_phy *phy;
+ 
+ 	mt76_connac_free_pending_tx_skbs(&dev->pm, &msta->wcid);
  
- 	mt7615_free_pending_tx_skbs(dev, msta);
- 	mt7615_pm_wake(dev);
+ 	phy = mvif->mt76.band_idx ? mt7615_ext_phy(dev) : &dev->phy;
+ 	mt76_connac_pm_wake(phy->mt76, &dev->pm);
  
 -	mt7615_mcu_sta_add(&dev->phy, vif, sta, false);
 +	mt7615_mcu_sta_add(dev, vif, sta, false);
  	mt7615_mac_wtbl_update(dev, msta->wcid.idx,
  			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
++<<<<<<< HEAD
 +	if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {
 +		struct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;
 +		struct mt7615_phy *phy;
 +
 +		phy = mvif->band_idx ? mt7615_ext_phy(dev) : &dev->phy;
++=======
+ 	if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)
++>>>>>>> 1755f6ad0fe0 (mt76: mt76_connac: move pm utility routines in mt76_connac_lib module)
  		mt7615_mcu_add_bss_info(phy, vif, sta, false);
- 	}
  
  	spin_lock_bh(&dev->sta_poll_lock);
  	if (!list_empty(&msta->poll_list))
@@@ -720,16 -704,7 +735,20 @@@ static void mt7615_tx(struct ieee80211_
  		skb_set_queue_mapping(skb, qid);
  	}
  
++<<<<<<< HEAD
 +	spin_lock_bh(&dev->pm.txq_lock);
 +	if (!dev->pm.tx_q[qid].skb) {
 +		ieee80211_stop_queues(hw);
 +		dev->pm.tx_q[qid].msta = msta;
 +		dev->pm.tx_q[qid].skb = skb;
 +		queue_work(dev->mt76.wq, &dev->pm.wake_work);
 +	} else {
 +		dev_kfree_skb(skb);
 +	}
 +	spin_unlock_bh(&dev->pm.txq_lock);
++=======
+ 	mt76_connac_pm_queue_skb(hw, &dev->pm, wcid, skb);
++>>>>>>> 1755f6ad0fe0 (mt76: mt76_connac: move pm utility routines in mt76_connac_lib module)
  }
  
  static int mt7615_set_rts_threshold(struct ieee80211_hw *hw, u32 val)
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac.h
* Unmerged path drivers/net/wireless/mediatek/mt76/Makefile
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mac.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/main.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h b/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
index 8e80331c345e..4477edade34f 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mt7615.h
@@ -427,8 +427,6 @@ void mt7615_mac_set_rates(struct mt7615_phy *phy, struct mt7615_sta *sta,
 			  struct ieee80211_tx_rate *probe_rate,
 			  struct ieee80211_tx_rate *rates);
 void mt7615_pm_wake_work(struct work_struct *work);
-int mt7615_pm_wake(struct mt7615_dev *dev);
-void mt7615_pm_power_save_sched(struct mt7615_dev *dev);
 void mt7615_pm_power_save_work(struct work_struct *work);
 int mt7615_mcu_del_wtbl_all(struct mt7615_dev *dev);
 int mt7615_mcu_set_chan_info(struct mt7615_phy *phy, int cmd);
@@ -484,19 +482,10 @@ static inline u16 mt7615_wtbl_size(struct mt7615_dev *dev)
 		return MT7615_WTBL_SIZE;
 }
 
-static inline void mt7615_mutex_acquire(struct mt7615_dev *dev)
-	 __acquires(&dev->mt76.mutex)
-{
-	mutex_lock(&dev->mt76.mutex);
-	mt7615_pm_wake(dev);
-}
-
-static inline void mt7615_mutex_release(struct mt7615_dev *dev)
-	__releases(&dev->mt76.mutex)
-{
-	mt7615_pm_power_save_sched(dev);
-	mutex_unlock(&dev->mt76.mutex);
-}
+#define mt7615_mutex_acquire(dev)	\
+	mt76_connac_mutex_acquire(&(dev)->mt76, &(dev)->pm)
+#define mt7615_mutex_release(dev)	\
+	mt76_connac_mutex_release(&(dev)->mt76, &(dev)->pm)
 
 static inline u8 mt7615_lmac_mapping(struct mt7615_dev *dev, u8 ac)
 {
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/pci.c b/drivers/net/wireless/mediatek/mt76/mt7615/pci.c
index dbd29d897b29..29d887492b8d 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/pci.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/pci.c
@@ -75,7 +75,7 @@ static int mt7615_pci_suspend(struct pci_dev *pdev, pm_message_t state)
 	bool hif_suspend;
 	int i, err;
 
-	err = mt7615_pm_wake(dev);
+	err = mt76_connac_pm_wake(&dev->mphy, &dev->pm);
 	if (err < 0)
 		return err;
 
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76_connac.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c b/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c
new file mode 100644
index 000000000000..c5f5037f5757
--- /dev/null
+++ b/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c
@@ -0,0 +1,119 @@
+// SPDX-License-Identifier: ISC
+/* Copyright (C) 2020 MediaTek Inc. */
+
+#include "mt76_connac.h"
+
+int mt76_connac_pm_wake(struct mt76_phy *phy, struct mt76_connac_pm *pm)
+{
+	struct mt76_dev *dev = phy->dev;
+
+	if (!pm->enable)
+		return 0;
+
+	if (!mt76_is_mmio(dev))
+		return 0;
+
+	if (!test_bit(MT76_STATE_PM, &phy->state))
+		return 0;
+
+	if (test_bit(MT76_HW_SCANNING, &phy->state) ||
+	    test_bit(MT76_HW_SCHED_SCANNING, &phy->state))
+		return 0;
+
+	if (queue_work(dev->wq, &pm->wake_work))
+		reinit_completion(&pm->wake_cmpl);
+
+	if (!wait_for_completion_timeout(&pm->wake_cmpl, 3 * HZ)) {
+		ieee80211_wake_queues(phy->hw);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mt76_connac_pm_wake);
+
+void mt76_connac_power_save_sched(struct mt76_phy *phy,
+				  struct mt76_connac_pm *pm)
+{
+	struct mt76_dev *dev = phy->dev;
+
+	if (!mt76_is_mmio(dev))
+		return;
+
+	if (!pm->enable || !test_bit(MT76_STATE_RUNNING, &phy->state))
+		return;
+
+	pm->last_activity = jiffies;
+
+	if (test_bit(MT76_HW_SCANNING, &phy->state) ||
+	    test_bit(MT76_HW_SCHED_SCANNING, &phy->state))
+		return;
+
+	if (!test_bit(MT76_STATE_PM, &phy->state))
+		queue_delayed_work(dev->wq, &pm->ps_work, pm->idle_timeout);
+}
+EXPORT_SYMBOL_GPL(mt76_connac_power_save_sched);
+
+void mt76_connac_free_pending_tx_skbs(struct mt76_connac_pm *pm,
+				      struct mt76_wcid *wcid)
+{
+	int i;
+
+	spin_lock_bh(&pm->txq_lock);
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		if (wcid && pm->tx_q[i].wcid != wcid)
+			continue;
+
+		dev_kfree_skb(pm->tx_q[i].skb);
+		pm->tx_q[i].skb = NULL;
+	}
+	spin_unlock_bh(&pm->txq_lock);
+}
+EXPORT_SYMBOL_GPL(mt76_connac_free_pending_tx_skbs);
+
+void mt76_connac_pm_queue_skb(struct ieee80211_hw *hw,
+			      struct mt76_connac_pm *pm,
+			      struct mt76_wcid *wcid,
+			      struct sk_buff *skb)
+{
+	int qid = skb_get_queue_mapping(skb);
+	struct mt76_phy *phy = hw->priv;
+
+	spin_lock_bh(&pm->txq_lock);
+	if (!pm->tx_q[qid].skb) {
+		ieee80211_stop_queues(hw);
+		pm->tx_q[qid].wcid = wcid;
+		pm->tx_q[qid].skb = skb;
+		queue_work(phy->dev->wq, &pm->wake_work);
+	} else {
+		dev_kfree_skb(skb);
+	}
+	spin_unlock_bh(&pm->txq_lock);
+}
+EXPORT_SYMBOL_GPL(mt76_connac_pm_queue_skb);
+
+void mt76_connac_pm_dequeue_skbs(struct mt76_phy *phy,
+				 struct mt76_connac_pm *pm)
+{
+	int i;
+
+	spin_lock_bh(&pm->txq_lock);
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		struct mt76_wcid *wcid = pm->tx_q[i].wcid;
+		struct ieee80211_sta *sta = NULL;
+
+		if (!pm->tx_q[i].skb)
+			continue;
+
+		if (wcid && wcid->sta)
+			sta = container_of((void *)wcid, struct ieee80211_sta,
+					   drv_priv);
+
+		mt76_tx(phy, sta, wcid, pm->tx_q[i].skb);
+		pm->tx_q[i].skb = NULL;
+	}
+	spin_unlock_bh(&pm->txq_lock);
+
+	mt76_worker_schedule(&phy->dev->tx_worker);
+}
+EXPORT_SYMBOL_GPL(mt76_connac_pm_dequeue_skbs);
