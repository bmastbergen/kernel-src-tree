mt76: mt7915: add support for rx decapsulation offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Felix Fietkau <nbd@nbd.name>
commit 90e3abf07c80a70f31227eea861f306312d5dbea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/90e3abf0.failed

For AP and Client mode, the hardware can pass received packets as 802.3 frames
that can be passed to the network stack as-is.

	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 90e3abf07c80a70f31227eea861f306312d5dbea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7915/mac.c
#	drivers/net/wireless/mediatek/mt76/mt7915/mac.h
#	drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/mac.c
index 75cc60fe135a,1a7291caf099..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c
@@@ -320,8 -320,15 +320,16 @@@ int mt7915_mac_fill_rx(struct mt7915_de
  	u32 rxd1 = le32_to_cpu(rxd[1]);
  	u32 rxd2 = le32_to_cpu(rxd[2]);
  	u32 rxd3 = le32_to_cpu(rxd[3]);
 -	u32 rxd4 = le32_to_cpu(rxd[4]);
 -	u32 csum_mask = MT_RXD0_NORMAL_IP_SUM | MT_RXD0_NORMAL_UDP_TCP_SUM;
  	bool unicast, insert_ccmp_hdr = false;
++<<<<<<< HEAD
 +	u8 remove_pad;
++=======
+ 	u8 remove_pad, amsdu_info;
+ 	bool hdr_trans;
+ 	u16 seq_ctrl = 0;
+ 	u8 qos_ctl = 0;
+ 	__le16 fc = 0;
++>>>>>>> 90e3abf07c80 (mt76: mt7915: add support for rx decapsulation offload)
  	int i, idx;
  
  	memset(status, 0, sizeof(*status));
@@@ -338,8 -345,12 +346,9 @@@
  	if (!test_bit(MT76_STATE_RUNNING, &mphy->state))
  		return -EINVAL;
  
 -	if (rxd2 & MT_RXD2_NORMAL_AMSDU_ERR)
 -		return -EINVAL;
 -
  	unicast = FIELD_GET(MT_RXD3_NORMAL_ADDR_TYPE, rxd3) == MT_RXD3_NORMAL_U2M;
  	idx = FIELD_GET(MT_RXD1_NORMAL_WLAN_IDX, rxd1);
+ 	hdr_trans = rxd2 & MT_RXD2_NORMAL_HDR_TRANS;
  	status->wcid = mt7915_rx_get_wcid(dev, idx, unicast);
  
  	if (status->wcid) {
@@@ -541,7 -562,19 +557,23 @@@
  
  	skb_pull(skb, (u8 *)rxd - skb->data + 2 * remove_pad);
  
++<<<<<<< HEAD
 +	if (insert_ccmp_hdr) {
++=======
+ 	amsdu_info = FIELD_GET(MT_RXD4_NORMAL_PAYLOAD_FORMAT, rxd4);
+ 	status->amsdu = !!amsdu_info;
+ 	if (status->amsdu) {
+ 		status->first_amsdu = amsdu_info == MT_RXD4_FIRST_AMSDU_FRAME;
+ 		status->last_amsdu = amsdu_info == MT_RXD4_LAST_AMSDU_FRAME;
+ 		if (!hdr_trans) {
+ 			memmove(skb->data + 2, skb->data,
+ 				ieee80211_get_hdrlen_from_skb(skb));
+ 			skb_pull(skb, 2);
+ 		}
+ 	}
+ 
+ 	if (insert_ccmp_hdr && !hdr_trans) {
++>>>>>>> 90e3abf07c80 (mt76: mt7915: add support for rx decapsulation offload)
  		u8 key_id = FIELD_GET(MT_RXD1_NORMAL_KEY_ID, rxd1);
  
  		mt76_insert_ccmp_hdr(skb, key_id);
@@@ -555,9 -600,9 +599,15 @@@
  		return 0;
  
  	status->aggr = unicast &&
++<<<<<<< HEAD
 +		       !ieee80211_is_qos_nullfunc(hdr->frame_control);
 +	status->tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;
 +	status->seqno = IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl));
++=======
+ 		       !ieee80211_is_qos_nullfunc(fc);
+ 	status->qos_ctl = qos_ctl;
+ 	status->seqno = IEEE80211_SEQ_TO_SN(seq_ctrl);
++>>>>>>> 90e3abf07c80 (mt76: mt7915: add support for rx decapsulation offload)
  
  	return 0;
  }
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/mac.h
index d420392b952d,0f929fb53027..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mac.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mac.h
@@@ -95,6 -99,19 +95,22 @@@ enum rx_pkt_type 
  #define MT_RXD3_NORMAL_PF_MODE		BIT(29)
  #define MT_RXD3_NORMAL_PF_STS		GENMASK(31, 30)
  
++<<<<<<< HEAD
++=======
+ #define MT_RXV_HDR_BAND_IDX		BIT(24)
+ 
+ /* RXD GROUP4 */
+ #define MT_RXD6_FRAME_CONTROL		GENMASK(15, 0)
+ #define MT_RXD6_TA_LO			GENMASK(31, 16)
+ 
+ #define MT_RXD7_TA_HI			GENMASK(31, 0)
+ 
+ #define MT_RXD8_SEQ_CTRL		GENMASK(15, 0)
+ #define MT_RXD8_QOS_CTL			GENMASK(31, 16)
+ 
+ #define MT_RXD9_HT_CONTROL		GENMASK(31, 0)
+ 
++>>>>>>> 90e3abf07c80 (mt76: mt7915: add support for rx decapsulation offload)
  /* P-RXV */
  #define MT_PRXV_TX_RATE			GENMASK(6, 0)
  #define MT_PRXV_TX_DCM			BIT(4)
diff --cc drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
index 22c9252267db,6a8a1aa50756..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
@@@ -2889,7 -2921,10 +2911,14 @@@ int mt7915_mcu_set_mac(struct mt7915_de
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_MAC_INIT_CTRL,
++=======
+ 	if (hdr_trans)
+ 		mt7915_mcu_set_rx_hdr_trans_blacklist(dev, band);
+ 
+ 	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(MAC_INIT_CTRL),
++>>>>>>> 90e3abf07c80 (mt76: mt7915: add support for rx decapsulation offload)
  				 &req_mac, sizeof(req_mac), true);
  }
  
diff --git a/drivers/net/wireless/mediatek/mt76/mt76.h b/drivers/net/wireless/mediatek/mt76/mt76.h
index e5947573fe0b..5a9a0866bd40 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@ -194,6 +194,7 @@ enum mt76_wcid_flags {
 	MT_WCID_FLAG_CHECK_PS,
 	MT_WCID_FLAG_PS,
 	MT_WCID_FLAG_4ADDR,
+	MT_WCID_FLAG_HDR_TRANS,
 };
 
 #define MT76_N_WCIDS 288
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/init.c b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
index 49c09d0d8906..5d501ae995ec 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
@@ -264,6 +264,7 @@ mt7915_init_wiphy(struct ieee80211_hw *hw)
 
 	ieee80211_hw_set(hw, HAS_RATE_CONTROL);
 	ieee80211_hw_set(hw, SUPPORTS_TX_ENCAP_OFFLOAD);
+	ieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);
 	ieee80211_hw_set(hw, WANT_MONITOR_VIF);
 
 	hw->max_tx_fragments = 4;
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/mac.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/mac.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/main.c b/drivers/net/wireless/mediatek/mt76/mt7915/main.c
index 46ffb2fe82db..2dd937b7cda2 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/main.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/main.c
@@ -34,14 +34,14 @@ static int mt7915_start(struct ieee80211_hw *hw)
 
 	if (!running) {
 		mt7915_mcu_set_pm(dev, 0, 0);
-		mt7915_mcu_set_mac(dev, 0, true, false);
+		mt7915_mcu_set_mac(dev, 0, true, true);
 		mt7915_mcu_set_scs(dev, 0, true);
 		mt7915_mac_enable_nf(dev, 0);
 	}
 
 	if (phy != &dev->phy) {
 		mt7915_mcu_set_pm(dev, 1, 0);
-		mt7915_mcu_set_mac(dev, 1, true, false);
+		mt7915_mcu_set_mac(dev, 1, true, true);
 		mt7915_mcu_set_scs(dev, 1, true);
 		mt7915_mac_enable_nf(dev, 1);
 	}
@@ -886,6 +886,22 @@ static void mt7915_sta_set_4addr(struct ieee80211_hw *hw,
 	mt7915_mcu_sta_update_hdr_trans(dev, vif, sta);
 }
 
+static void mt7915_sta_set_decap_offload(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif,
+				 struct ieee80211_sta *sta,
+				 bool enabled)
+{
+	struct mt7915_dev *dev = mt7915_hw_dev(hw);
+	struct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;
+
+	if (enabled)
+		set_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);
+	else
+		clear_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);
+
+	mt7915_mcu_sta_update_hdr_trans(dev, vif, sta);
+}
+
 const struct ieee80211_ops mt7915_ops = {
 	.tx = mt7915_tx,
 	.start = mt7915_start,
@@ -918,6 +934,7 @@ const struct ieee80211_ops mt7915_ops = {
 	.set_coverage_class = mt7915_set_coverage_class,
 	.sta_statistics = mt7915_sta_statistics,
 	.sta_set_4addr = mt7915_sta_set_4addr,
+	.sta_set_decap_offload = mt7915_sta_set_decap_offload,
 	CFG80211_TESTMODE_CMD(mt76_testmode_cmd)
 	CFG80211_TESTMODE_DUMP(mt76_testmode_dump)
 #ifdef CONFIG_MAC80211_DEBUGFS
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
