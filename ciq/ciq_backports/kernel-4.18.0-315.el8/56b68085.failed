blk-mq: Some tag allocation code refactoring

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author John Garry <john.garry@huawei.com>
commit 56b68085e536eff2676108f2f8356889a7dbbf55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/56b68085.failed

The tag allocation code to alloc the sbitmap pairs is common for regular
bitmaps tags and shared sbitmap, so refactor into a common function.

Also remove superfluous "flags" argument from blk_mq_init_shared_sbitmap().

	Signed-off-by: John Garry <john.garry@huawei.com>
	Reviewed-by: Ming Lei <ming.lei@redhat.com>
Link: https://lore.kernel.org/r/1620907258-30910-2-git-send-email-john.garry@huawei.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 56b68085e536eff2676108f2f8356889a7dbbf55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-tag.c
diff --cc block/blk-mq-tag.c
index 8f98deb219f8,f597d40de10b..000000000000
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@@ -486,23 -507,18 +506,26 @@@ static int blk_mq_init_bitmap_tags(stru
  	tags->breserved_tags = &tags->__breserved_tags;
  
  	return 0;
- free_bitmap_tags:
- 	sbitmap_queue_free(&tags->__bitmap_tags);
- 	return -ENOMEM;
  }
  
- int blk_mq_init_shared_sbitmap(struct blk_mq_tag_set *set, unsigned int flags)
+ int blk_mq_init_shared_sbitmap(struct blk_mq_tag_set *set)
  {
- 	unsigned int depth = set->queue_depth - set->reserved_tags;
  	int alloc_policy = BLK_MQ_FLAG_TO_ALLOC_POLICY(set->flags);
- 	bool round_robin = alloc_policy == BLK_TAG_ALLOC_RR;
- 	int i, node = set->numa_node;
+ 	int i, ret;
  
++<<<<<<< HEAD
 +	if (bt_alloc(&set->aux->__bitmap_tags, depth, round_robin, node))
 +		return -ENOMEM;
 +	if (bt_alloc(&set->aux->__breserved_tags, set->reserved_tags,
 +		     round_robin, node))
 +		goto free_bitmap_tags;
++=======
+ 	ret = blk_mq_init_bitmaps(&set->__bitmap_tags, &set->__breserved_tags,
+ 				  set->queue_depth, set->reserved_tags,
+ 				  set->numa_node, alloc_policy);
+ 	if (ret)
+ 		return ret;
++>>>>>>> 56b68085e536 (blk-mq: Some tag allocation code refactoring)
  
  	for (i = 0; i < set->nr_hw_queues; i++) {
  		struct blk_mq_tags *tags = set->tags[i];
@@@ -512,9 -528,6 +535,12 @@@
  	}
  
  	return 0;
++<<<<<<< HEAD
 +free_bitmap_tags:
 +	sbitmap_queue_free(&set->aux->__bitmap_tags);
 +	return -ENOMEM;
++=======
++>>>>>>> 56b68085e536 (blk-mq: Some tag allocation code refactoring)
  }
  
  void blk_mq_exit_shared_sbitmap(struct blk_mq_tag_set *set)
* Unmerged path block/blk-mq-tag.c
diff --git a/block/blk-mq-tag.h b/block/blk-mq-tag.h
index 85ce321c37b9..6fe1bbc0762a 100644
--- a/block/blk-mq-tag.h
+++ b/block/blk-mq-tag.h
@@ -32,11 +32,14 @@ extern struct blk_mq_tags *blk_mq_init_tags(unsigned int nr_tags,
 					unsigned int reserved_tags,
 					int node, unsigned int flags);
 extern void blk_mq_free_tags(struct blk_mq_tags *tags, unsigned int flags);
+extern int blk_mq_init_bitmaps(struct sbitmap_queue *bitmap_tags,
+			       struct sbitmap_queue *breserved_tags,
+			       unsigned int queue_depth,
+			       unsigned int reserved,
+			       int node, int alloc_policy);
 
-extern int blk_mq_init_shared_sbitmap(struct blk_mq_tag_set *set,
-				      unsigned int flags);
+extern int blk_mq_init_shared_sbitmap(struct blk_mq_tag_set *set);
 extern void blk_mq_exit_shared_sbitmap(struct blk_mq_tag_set *set);
-
 extern unsigned int blk_mq_get_tag(struct blk_mq_alloc_data *data);
 extern void blk_mq_put_tag(struct blk_mq_tags *tags, struct blk_mq_ctx *ctx,
 			   unsigned int tag);
diff --git a/block/blk-mq.c b/block/blk-mq.c
index f74460f8b4bc..1e7df4f80cf7 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -3567,7 +3567,7 @@ int blk_mq_alloc_tag_set(struct blk_mq_tag_set *set)
 	if (blk_mq_is_sbitmap_shared(set->flags)) {
 		atomic_set(&set->active_queues_shared_sbitmap, 0);
 
-		if (blk_mq_init_shared_sbitmap(set, set->flags)) {
+		if (blk_mq_init_shared_sbitmap(set)) {
 			ret = -ENOMEM;
 			goto out_free_mq_rq_maps;
 		}
