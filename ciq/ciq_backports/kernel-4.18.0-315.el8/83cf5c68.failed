xsk: Fix use-after-free in failed shared_umem bind

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit 83cf5c68d663fc78ce529c41bf24f9f6be88bef4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/83cf5c68.failed

Fix use-after-free when a shared umem bind fails. The code incorrectly
tried to free the allocated buffer pool both in the bind code and then
later also when the socket was released. Fix this by setting the
buffer pool pointer to NULL after the bind code has freed the pool, so
that the socket release code will not try to free the pool. This is
the same solution as the regular, non-shared umem code path has. This
was missing from the shared umem path.

Fixes: b5aea28dca13 ("xsk: Add shared umem support between queue ids")
	Reported-by: syzbot+5334f62e4d22804e646a@syzkaller.appspotmail.com
	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/1599032164-25684-1-git-send-email-magnus.karlsson@intel.com
(cherry picked from commit 83cf5c68d663fc78ce529c41bf24f9f6be88bef4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xdp/xsk.c
diff --cc net/xdp/xsk.c
index 10c97cce9e3d,3895697f8540..000000000000
--- a/net/xdp/xsk.c
+++ b/net/xdp/xsk.c
@@@ -665,10 -695,37 +665,44 @@@ static int xsk_bind(struct socket *sock
  			sockfd_put(sock);
  			goto out_unlock;
  		}
++<<<<<<< HEAD
 +		if (umem_xs->dev != dev || umem_xs->queue_id != qid) {
 +			err = -EINVAL;
 +			sockfd_put(sock);
 +			goto out_unlock;
++=======
+ 
+ 		if (umem_xs->queue_id != qid || umem_xs->dev != dev) {
+ 			/* Share the umem with another socket on another qid
+ 			 * and/or device.
+ 			 */
+ 			xs->pool = xp_create_and_assign_umem(xs,
+ 							     umem_xs->umem);
+ 			if (!xs->pool) {
+ 				sockfd_put(sock);
+ 				goto out_unlock;
+ 			}
+ 
+ 			err = xp_assign_dev_shared(xs->pool, umem_xs->umem,
+ 						   dev, qid);
+ 			if (err) {
+ 				xp_destroy(xs->pool);
+ 				xs->pool = NULL;
+ 				sockfd_put(sock);
+ 				goto out_unlock;
+ 			}
+ 		} else {
+ 			/* Share the buffer pool with the other socket. */
+ 			if (xs->fq_tmp || xs->cq_tmp) {
+ 				/* Do not allow setting your own fq or cq. */
+ 				err = -EINVAL;
+ 				sockfd_put(sock);
+ 				goto out_unlock;
+ 			}
+ 
+ 			xp_get_pool(umem_xs->pool);
+ 			xs->pool = umem_xs->pool;
++>>>>>>> 83cf5c68d663 (xsk: Fix use-after-free in failed shared_umem bind)
  		}
  
  		xdp_get_umem(umem_xs->umem);
* Unmerged path net/xdp/xsk.c
