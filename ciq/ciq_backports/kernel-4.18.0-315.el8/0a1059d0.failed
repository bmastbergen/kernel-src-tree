mt76: mt7921: move mt7921_dma_reset in dma.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 0a1059d0f06023a7d045d05055c9d2ebad3b9c9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/0a1059d0.failed

Move mt7921_dma_reset routine in dma.c and make mt7921_dma_prefetch
static. Moreover add force parameter to mt7921_dma_reset signature.
This is a preliminary patch to reset dma mt7921_mcu_drv_pmctrl.

	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 0a1059d0f06023a7d045d05055c9d2ebad3b9c9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7921/dma.c
#	drivers/net/wireless/mediatek/mt76/mt7921/mac.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/dma.c
index cd9665610284,0c577a5bac13..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/dma.c
@@@ -74,7 -79,25 +74,29 @@@ static int mt7921_poll_tx(struct napi_s
  	return 0;
  }
  
++<<<<<<< HEAD
 +void mt7921_dma_prefetch(struct mt7921_dev *dev)
++=======
+ static int mt7921_poll_rx(struct napi_struct *napi, int budget)
+ {
+ 	struct mt7921_dev *dev;
+ 	int done;
+ 
+ 	dev = container_of(napi->dev, struct mt7921_dev, mt76.napi_dev);
+ 
+ 	if (!mt76_connac_pm_ref(&dev->mphy, &dev->pm)) {
+ 		napi_complete(napi);
+ 		queue_work(dev->mt76.wq, &dev->pm.wake_work);
+ 		return 0;
+ 	}
+ 	done = mt76_dma_rx_poll(napi, budget);
+ 	mt76_connac_pm_unref(&dev->pm);
+ 
+ 	return done;
+ }
+ 
+ static void mt7921_dma_prefetch(struct mt7921_dev *dev)
++>>>>>>> 0a1059d0f060 (mt76: mt7921: move mt7921_dma_reset in dma.c)
  {
  #define PREFETCH(base, depth)	((base) << 16 | (depth))
  
diff --cc drivers/net/wireless/mediatek/mt76/mt7921/mac.c
index bcbd59a23f9b,8b4fbb7f304c..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c
@@@ -1162,47 -1197,23 +1162,50 @@@ void mt7921_update_channel(struct mt76_
  	mt7921_phy_update_channel(&mdev->phy, 0);
  	/* reset obss airtime */
  	mt76_set(dev, MT_WF_RMAC_MIB_TIME0(0), MT_WF_RMAC_MIB_RXTIME_CLR);
 +}
 +
 +static bool
 +mt7921_wait_reset_state(struct mt7921_dev *dev, u32 state)
 +{
 +	bool ret;
 +
 +	ret = wait_event_timeout(dev->reset_wait,
 +				 (READ_ONCE(dev->reset_state) & state),
 +				 MT7921_RESET_TIMEOUT);
  
 -	mt76_connac_power_save_sched(&dev->mphy, &dev->pm);
 +	WARN(!ret, "Timeout waiting for MCU reset state %x\n", state);
 +	return ret;
  }
  
 -int mt7921_wfsys_reset(struct mt7921_dev *dev)
++<<<<<<< HEAD
 +static void
 +mt7921_dma_reset(struct mt7921_phy *phy)
  {
 -	mt76_set(dev, 0x70002600, BIT(0));
 -	msleep(200);
 -	mt76_clear(dev, 0x70002600, BIT(0));
 +	struct mt7921_dev *dev = phy->dev;
 +	int i;
 +
 +	mt76_clear(dev, MT_WFDMA0_GLO_CFG,
 +		   MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN);
 +
 +	usleep_range(1000, 2000);
  
 -	return __mt76_poll_msec(&dev->mt76, MT_WFSYS_SW_RST_B,
 -				WFSYS_SW_INIT_DONE, WFSYS_SW_INIT_DONE, 500);
 +	mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WA], true);
 +	for (i = 0; i < __MT_TXQ_MAX; i++)
 +		mt76_queue_tx_cleanup(dev, phy->mt76->q_tx[i], true);
 +
 +	mt76_for_each_q_rx(&dev->mt76, i) {
 +		mt76_queue_rx_reset(dev, i);
 +	}
 +
 +	/* re-init prefetch settings after reset */
 +	mt7921_dma_prefetch(dev);
 +
 +	mt76_set(dev, MT_WFDMA0_GLO_CFG,
 +		 MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN);
  }
  
++=======
++>>>>>>> 0a1059d0f060 (mt76: mt7921: move mt7921_dma_reset in dma.c)
  void mt7921_tx_token_put(struct mt7921_dev *dev)
  {
  	struct mt76_txwi_cache *txwi;
@@@ -1257,38 -1273,96 +1260,54 @@@ void mt7921_mac_reset_work(struct work_
  	mt7921_tx_token_put(dev);
  	idr_init(&dev->token);
  
 -	/* clean up hw queues */
 -	for (i = 0; i < ARRAY_SIZE(dev->mt76.phy.q_tx); i++)
 -		mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);
 +	if (mt7921_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
 +		mt7921_dma_reset(&dev->phy);
  
++<<<<<<< HEAD
 +		mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);
 +		mt7921_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
++=======
+ 	for (i = 0; i < ARRAY_SIZE(dev->mt76.q_mcu); i++)
+ 		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i)
+ 		mt76_queue_rx_cleanup(dev, &dev->mt76.q_rx[i]);
+ 
+ 	mt7921_wfsys_reset(dev);
+ 	mt7921_dma_reset(dev, true);
+ 
+ 	mt76_for_each_q_rx(&dev->mt76, i) {
+ 		mt76_queue_rx_reset(dev, i);
+ 		napi_enable(&dev->mt76.napi[i]);
+ 		napi_schedule(&dev->mt76.napi[i]);
++>>>>>>> 0a1059d0f060 (mt76: mt7921: move mt7921_dma_reset in dma.c)
  	}
  
 -	napi_enable(&dev->mt76.tx_napi);
 -	napi_schedule(&dev->mt76.tx_napi);
 -	mt76_worker_enable(&dev->mt76.tx_worker);
 -
  	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
 -	clear_bit(MT76_STATE_PM, &dev->mphy.state);
 +	clear_bit(MT76_RESET, &dev->mphy.state);
  
 -	mt76_wr(dev, MT_WFDMA0_HOST_INT_ENA, 0);
 -	mt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);
 -	mt7921_irq_enable(dev,
 -			  MT_INT_RX_DONE_ALL | MT_INT_TX_DONE_ALL |
 -			  MT_INT_MCU_CMD);
 -
 -	err = mt7921_run_firmware(dev);
 -	if (err)
 -		return err;
 -
 -	err = mt7921_mcu_set_eeprom(dev);
 -	if (err)
 -		return err;
 +	mt76_worker_enable(&dev->mt76.tx_worker);
 +	napi_enable(&dev->mt76.tx_napi);
 +	napi_schedule(&dev->mt76.tx_napi);
  
 -	mt7921_mac_init(dev);
 -	return __mt7921_start(&dev->phy);
 -}
 +	napi_enable(&dev->mt76.napi[0]);
 +	napi_schedule(&dev->mt76.napi[0]);
  
 -/* system error recovery */
 -void mt7921_mac_reset_work(struct work_struct *work)
 -{
 -	struct ieee80211_hw *hw;
 -	struct mt7921_dev *dev;
 -	int i;
 +	napi_enable(&dev->mt76.napi[1]);
 +	napi_schedule(&dev->mt76.napi[1]);
  
 -	dev = container_of(work, struct mt7921_dev, reset_work);
 -	hw = mt76_hw(dev);
 +	napi_enable(&dev->mt76.napi[2]);
 +	napi_schedule(&dev->mt76.napi[2]);
  
 -	dev_err(dev->mt76.dev, "chip reset\n");
 -	ieee80211_stop_queues(hw);
 +	ieee80211_wake_queues(mt76_hw(dev));
  
 -	cancel_delayed_work_sync(&dev->mphy.mac_work);
 -	cancel_delayed_work_sync(&dev->pm.ps_work);
 -	cancel_work_sync(&dev->pm.wake_work);
 +	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_RESET_DONE);
 +	mt7921_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);
  
 -	mutex_lock(&dev->mt76.mutex);
 -	for (i = 0; i < 10; i++) {
 -		if (!mt7921_mac_reset(dev))
 -			break;
 -	}
  	mutex_unlock(&dev->mt76.mutex);
  
 -	if (i == 10)
 -		dev_err(dev->mt76.dev, "chip reset failed\n");
 -
 -	if (test_and_clear_bit(MT76_HW_SCANNING, &dev->mphy.state)) {
 -		struct cfg80211_scan_info info = {
 -			.aborted = true,
 -		};
 -
 -		ieee80211_scan_completed(dev->mphy.hw, &info);
 -	}
 -
 -	ieee80211_wake_queues(hw);
 -	ieee80211_iterate_active_interfaces(hw,
 -					    IEEE80211_IFACE_ITER_RESUME_ALL,
 -					    mt7921_vif_connect_iter, NULL);
 -}
 -
 -void mt7921_reset(struct mt76_dev *mdev)
 -{
 -	struct mt7921_dev *dev = container_of(mdev, struct mt7921_dev, mt76);
 -
 -	queue_work(dev->mt76.wq, &dev->reset_work);
 +	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
 +				     MT7921_WATCHDOG_TIME);
  }
  
  static void
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/dma.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7921/mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
index 6e3579d48c30..898bfd59cace 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mt7921.h
@@ -225,7 +225,7 @@ int mt7921_eeprom_get_target_power(struct mt7921_dev *dev,
 				   u8 chain_idx);
 void mt7921_eeprom_init_sku(struct mt7921_dev *dev);
 int mt7921_dma_init(struct mt7921_dev *dev);
-void mt7921_dma_prefetch(struct mt7921_dev *dev);
+int mt7921_dma_reset(struct mt7921_dev *dev, bool force);
 void mt7921_dma_cleanup(struct mt7921_dev *dev);
 int mt7921_run_firmware(struct mt7921_dev *dev);
 int mt7921_mcu_init(struct mt7921_dev *dev);
