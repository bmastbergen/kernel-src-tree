tcp: move snd_cwnd & snd_cwnd_cnt init to tcp_disconnect()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 3a9a57f637943404920a8945323dc733845e697c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/3a9a57f6.failed

Passive connections can inherit proper value by cloning,
if we make sure all listeners have the proper values there.

tcp_disconnect() was setting snd_cwnd to 2, which seems
quite obsolete since IW10 adoption.

Also remove an obsolete comment.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3a9a57f637943404920a8945323dc733845e697c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
diff --cc net/ipv4/tcp.c
index b97a32f41877,3f99ad92eaed..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -2617,23 -2572,19 +2617,33 @@@ int tcp_disconnect(struct sock *sk, in
  	sk->sk_shutdown = 0;
  	sock_reset_flag(sk, SOCK_DONE);
  	tp->srtt_us = 0;
++<<<<<<< HEAD
 +
 +	seq = tp->write_seq + tp->max_window + 2;
 +	if (!seq)
 +		seq = 1;
 +	WRITE_ONCE(tp->write_seq, seq);
 +	tp->snd_cwnd = 2;
 +
++=======
+ 	tp->mdev_us = jiffies_to_usecs(TCP_TIMEOUT_INIT);
+ 	tp->rcv_rtt_last_tsecr = 0;
+ 	tp->write_seq += tp->max_window + 2;
+ 	if (tp->write_seq == 0)
+ 		tp->write_seq = 1;
+ 	icsk->icsk_backoff = 0;
++>>>>>>> 3a9a57f63794 (tcp: move snd_cwnd & snd_cwnd_cnt init to tcp_disconnect())
  	icsk->icsk_probes_out = 0;
  	icsk->icsk_rto = TCP_TIMEOUT_INIT;
  	tp->snd_ssthresh = TCP_INFINITE_SSTHRESH;
+ 	tp->snd_cwnd = TCP_INIT_CWND;
  	tp->snd_cwnd_cnt = 0;
  	tp->window_clamp = 0;
 +	tp->delivered = 0;
  	tp->delivered_ce = 0;
 +	if (icsk->icsk_ca_ops->release)
 +		icsk->icsk_ca_ops->release(sk);
 +	memset(icsk->icsk_ca_priv, 0, sizeof(icsk->icsk_ca_priv));
  	tcp_set_ca_state(sk, TCP_CA_Open);
  	tp->is_sack_reneg = 0;
  	tcp_clear_retrans(tp);
* Unmerged path net/ipv4/tcp.c
diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
index 4612d8b4d262..04fd0e6e895a 100644
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@ -491,14 +491,6 @@ struct sock *tcp_create_openreq_child(const struct sock *sk,
 	newtp->last_oow_ack_time = 0;
 	newtp->total_retrans = req->num_retrans;
 
-	/* So many TCP implementations out there (incorrectly) count the
-	 * initial SYN frame in their delayed-ACK and congestion control
-	 * algorithms that we must have the following bandaid to talk
-	 * efficiently to them.  -DaveM
-	 */
-	newtp->snd_cwnd = TCP_INIT_CWND;
-	newtp->snd_cwnd_cnt = 0;
-
 	/* There's a bubble in the pipe until at least the first ACK. */
 	newtp->app_limited = ~0U;
 
