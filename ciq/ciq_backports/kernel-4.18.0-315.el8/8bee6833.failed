xsk: Fix memory leak for failed bind

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit 8bee683384087a6275c9183a483435225f7bb209
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/8bee6833.failed

Fix a possible memory leak when a bind of an AF_XDP socket fails. When
the fill and completion rings are created, they are tied to the
socket. But when the buffer pool is later created at bind time, the
ownership of these two rings are transferred to the buffer pool as
they might be shared between sockets (and the buffer pool cannot be
created until we know what we are binding to). So, before the buffer
pool is created, these two rings are cleaned up with the socket, and
after they have been transferred they are cleaned up together with
the buffer pool.

The problem is that ownership was transferred before it was absolutely
certain that the buffer pool could be created and initialized
correctly and when one of these errors occurred, the fill and
completion rings did neither belong to the socket nor the pool and
where therefore leaked. Solve this by moving the ownership transfer
to the point where the buffer pool has been completely set up and
there is no way it can fail.

Fixes: 7361f9c3d719 ("xsk: Move fill and completion rings to buffer pool")
	Reported-by: syzbot+cfa88ddd0655afa88763@syzkaller.appspotmail.com
	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Björn Töpel <bjorn.topel@intel.com>
Link: https://lore.kernel.org/bpf/20201214085127.3960-1-magnus.karlsson@gmail.com
(cherry picked from commit 8bee683384087a6275c9183a483435225f7bb209)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xdp/xsk_buff_pool.c
diff --cc net/xdp/xsk_buff_pool.c
index a2044c245215,818b75060922..000000000000
--- a/net/xdp/xsk_buff_pool.c
+++ b/net/xdp/xsk_buff_pool.c
@@@ -46,15 -57,24 +46,24 @@@ struct xsk_buff_pool *xp_create(struct 
  	if (!pool->heads)
  		goto out;
  
 -	pool->chunk_mask = ~((u64)umem->chunk_size - 1);
 -	pool->addrs_cnt = umem->size;
 -	pool->heads_cnt = umem->chunks;
 -	pool->free_heads_cnt = umem->chunks;
 -	pool->headroom = umem->headroom;
 -	pool->chunk_size = umem->chunk_size;
 -	pool->unaligned = umem->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;
 -	pool->frame_len = umem->chunk_size - umem->headroom -
 -		XDP_PACKET_HEADROOM;
 -	pool->umem = umem;
 -	pool->addrs = umem->addrs;
 +	pool->chunk_mask = ~((u64)chunk_size - 1);
 +	pool->addrs_cnt = size;
 +	pool->heads_cnt = chunks;
 +	pool->free_heads_cnt = chunks;
 +	pool->headroom = headroom;
 +	pool->chunk_size = chunk_size;
 +	pool->unaligned = unaligned;
 +	pool->frame_len = chunk_size - headroom - XDP_PACKET_HEADROOM;
  	INIT_LIST_HEAD(&pool->free_list);
++<<<<<<< HEAD
++=======
+ 	INIT_LIST_HEAD(&pool->xsk_tx_list);
+ 	spin_lock_init(&pool->xsk_tx_list_lock);
+ 	refcount_set(&pool->users, 1);
+ 
+ 	pool->fq = xs->fq_tmp;
+ 	pool->cq = xs->cq_tmp;
++>>>>>>> 8bee68338408 (xsk: Fix memory leak for failed bind)
  
  	for (i = 0; i < pool->free_heads_cnt; i++) {
  		xskb = &pool->heads[i];
diff --git a/net/xdp/xsk.c b/net/xdp/xsk.c
index 57e57607ff9e..a6edd441e716 100644
--- a/net/xdp/xsk.c
+++ b/net/xdp/xsk.c
@@ -696,6 +696,10 @@ static int xsk_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 			goto out_unlock;
 	}
 
+	/* FQ and CQ are now owned by the buffer pool and cleaned up with it. */
+	xs->fq_tmp = NULL;
+	xs->cq_tmp = NULL;
+
 	xs->dev = dev;
 	xs->zc = xs->umem->zc;
 	xs->queue_id = qid;
* Unmerged path net/xdp/xsk_buff_pool.c
