xsk: Fix possible segfault in xsk umem diagnostics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-315.el8
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit 53ea2076d851ee37e4f3954c5ae569439b138248
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-315.el8/53ea2076.failed

Fix possible segfault in the xsk diagnostics code when dumping
information about the umem. This can happen when a umem has been
created, but the socket has not been bound yet. In this case, the xsk
buffer pool does not exist yet and we cannot dump the information
that was moved from the umem to the buffer pool. Fix this by testing
for the existence of the buffer pool and if not there, do not dump any
of that information.

Fixes: c2d3d6a47462 ("xsk: Move queue_id, dev and need_wakeup to buffer pool")
Fixes: 7361f9c3d719 ("xsk: Move fill and completion rings to buffer pool")
	Reported-by: syzbot+3f04d36b7336f7868066@syzkaller.appspotmail.com
	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/1599036743-26454-1-git-send-email-magnus.karlsson@intel.com
(cherry picked from commit 53ea2076d851ee37e4f3954c5ae569439b138248)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xdp/xsk_diag.c
diff --cc net/xdp/xsk_diag.c
index 21e9c2d123ee,c014217f5fa7..000000000000
--- a/net/xdp/xsk_diag.c
+++ b/net/xdp/xsk_diag.c
@@@ -58,21 -59,20 +58,35 @@@ static int xsk_diag_put_umem(const stru
  	du.num_pages = umem->npgs;
  	du.chunk_size = umem->chunk_size;
  	du.headroom = umem->headroom;
++<<<<<<< HEAD
 +	du.ifindex = umem->dev ? umem->dev->ifindex : 0;
 +	du.queue_id = umem->queue_id;
++=======
+ 	du.ifindex = (pool && pool->netdev) ? pool->netdev->ifindex : 0;
+ 	du.queue_id = pool ? pool->queue_id : 0;
++>>>>>>> 53ea2076d851 (xsk: Fix possible segfault in xsk umem diagnostics)
  	du.flags = 0;
  	if (umem->zc)
  		du.flags |= XDP_DU_F_ZEROCOPY;
  	du.refs = refcount_read(&umem->users);
  
  	err = nla_put(nlskb, XDP_DIAG_UMEM, sizeof(du), &du);
++<<<<<<< HEAD
 +
 +	if (!err && umem->fq)
 +		err = xsk_diag_put_ring(umem->fq, XDP_DIAG_UMEM_FILL_RING, nlskb);
 +	if (!err && umem->cq) {
 +		err = xsk_diag_put_ring(umem->cq, XDP_DIAG_UMEM_COMPLETION_RING,
 +					nlskb);
 +	}
++=======
+ 	if (!err && pool && pool->fq)
+ 		err = xsk_diag_put_ring(pool->fq,
+ 					XDP_DIAG_UMEM_FILL_RING, nlskb);
+ 	if (!err && pool && pool->cq)
+ 		err = xsk_diag_put_ring(pool->cq,
+ 					XDP_DIAG_UMEM_COMPLETION_RING, nlskb);
++>>>>>>> 53ea2076d851 (xsk: Fix possible segfault in xsk umem diagnostics)
  	return err;
  }
  
* Unmerged path net/xdp/xsk_diag.c
