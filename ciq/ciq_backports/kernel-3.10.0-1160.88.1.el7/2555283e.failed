mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse

jira LE-1907
cve CVE-2022-42703
Rebuild_History Non-Buildable kernel-3.10.0-1160.88.1.el7
commit-author Jann Horn <jannh@google.com>
commit 2555283eb40df89945557273121e9393ef9b542b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.88.1.el7/2555283e.failed

anon_vma->degree tracks the combined number of child anon_vmas and VMAs
that use the anon_vma as their ->anon_vma.

anon_vma_clone() then assumes that for any anon_vma attached to
src->anon_vma_chain other than src->anon_vma, it is impossible for it to
be a leaf node of the VMA tree, meaning that for such VMAs ->degree is
elevated by 1 because of a child anon_vma, meaning that if ->degree
equals 1 there are no VMAs that use the anon_vma as their ->anon_vma.

This assumption is wrong because the ->degree optimization leads to leaf
nodes being abandoned on anon_vma_clone() - an existing anon_vma is
reused and no new parent-child relationship is created.  So it is
possible to reuse an anon_vma for one VMA while it is still tied to
another VMA.

This is an issue because is_mergeable_anon_vma() and its callers assume
that if two VMAs have the same ->anon_vma, the list of anon_vmas
attached to the VMAs is guaranteed to be the same.  When this assumption
is violated, vma_merge() can merge pages into a VMA that is not attached
to the corresponding anon_vma, leading to dangling page->mapping
pointers that will be dereferenced during rmap walks.

Fix it by separately tracking the number of child anon_vmas and the
number of VMAs using the anon_vma as their ->anon_vma.

Fixes: 7a3ef208e662 ("mm: prevent endless growth of anon_vma hierarchy")
	Cc: stable@kernel.org
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Jann Horn <jannh@google.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2555283eb40df89945557273121e9393ef9b542b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rmap.h
#	mm/rmap.c
diff --cc include/linux/rmap.h
index 4aaf3978fbde,b89b4b86951f..000000000000
--- a/include/linux/rmap.h
+++ b/include/linux/rmap.h
@@@ -37,6 -41,19 +37,22 @@@ struct anon_vma 
  	atomic_t refcount;
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * Count of child anon_vmas. Equals to the count of all anon_vmas that
+ 	 * have ->parent pointing to this one, including itself.
+ 	 *
+ 	 * This counter is used for making decision about reusing anon_vma
+ 	 * instead of forking new one. See comments in function anon_vma_clone.
+ 	 */
+ 	unsigned long num_children;
+ 	/* Count of VMAs whose ->anon_vma pointer points to this object. */
+ 	unsigned long num_active_vmas;
+ 
+ 	struct anon_vma *parent;	/* Parent of this anon_vma */
+ 
+ 	/*
++>>>>>>> 2555283eb40d (mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse)
  	 * NOTE: the LSB of the rb_root.rb_node is set by
  	 * mm_take_all_locks() _after_ taking the above lock. So the
  	 * rb_root must only be read/written after taking the above lock
diff --cc mm/rmap.c
index cddadae178d8,93d5a6f793d2..000000000000
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@@ -284,11 -297,10 +285,15 @@@ int anon_vma_clone(struct vm_area_struc
  		anon_vma_chain_link(dst, avc, anon_vma);
  
  		/*
- 		 * Reuse existing anon_vma if its degree lower than two,
- 		 * that means it has no vma and only one anon_vma child.
+ 		 * Reuse existing anon_vma if it has no vma and only one
+ 		 * anon_vma child.
  		 *
++<<<<<<< HEAD
 +		 * Do not chose parent anon_vma, otherwise first child
 +		 * will always reuse it. Root anon_vma is never reused:
++=======
+ 		 * Root anon_vma is never reused:
++>>>>>>> 2555283eb40d (mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse)
  		 * it has self-parent reference and at least one child.
  		 */
  		if (!dst->anon_vma && src->anon_vma &&
@@@ -397,8 -411,8 +404,13 @@@ void unlink_anon_vmas(struct vm_area_st
  		 * Leave empty anon_vmas on the list - we'll need
  		 * to free them outside the lock.
  		 */
++<<<<<<< HEAD
 +		if (RB_EMPTY_ROOT(&anon_vma->rb_root)) {
 +			anon_vma->parent->degree--;
++=======
+ 		if (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {
+ 			anon_vma->parent->num_children--;
++>>>>>>> 2555283eb40d (mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse)
  			continue;
  		}
  
@@@ -424,7 -438,8 +436,12 @@@
  	list_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {
  		struct anon_vma *anon_vma = avc->anon_vma;
  
++<<<<<<< HEAD
 +		BUG_ON(anon_vma->degree);
++=======
+ 		VM_WARN_ON(anon_vma->num_children);
+ 		VM_WARN_ON(anon_vma->num_active_vmas);
++>>>>>>> 2555283eb40d (mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse)
  		put_anon_vma(anon_vma);
  
  		list_del(&avc->same_vma);
* Unmerged path include/linux/rmap.h
* Unmerged path mm/rmap.c
