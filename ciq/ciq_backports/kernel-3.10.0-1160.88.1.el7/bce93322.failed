proc: proc_skip_spaces() shouldn't think it is working on C strings

jira LE-1907
cve CVE-2022-4378
Rebuild_History Non-Buildable kernel-3.10.0-1160.88.1.el7
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit bce9332220bd677d83b19d21502776ad555a0e73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.88.1.el7/bce93322.failed

proc_skip_spaces() seems to think it is working on C strings, and ends
up being just a wrapper around skip_spaces() with a really odd calling
convention.

Instead of basing it on skip_spaces(), it should have looked more like
proc_skip_char(), which really is the exact same function (except it
skips a particular character, rather than whitespace).  So use that as
inspiration, odd coding and all.

Now the calling convention actually makes sense and works for the
intended purpose.

Reported-and-tested-by: Kyle Zeng <zengyhkyle@gmail.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bce9332220bd677d83b19d21502776ad555a0e73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sysctl.c
diff --cc kernel/sysctl.c
index 7ee875300e85,c6d9dec11b74..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -1885,1398 -1399,1105 +1885,1425 @@@ static int _proc_do_string(char *data, 
  	}
  
  	if (write) {
 -		char *p = buffer;
 -		size_t skipped = 0;
 +		if (sysctl_writes_strict == SYSCTL_WRITES_STRICT) {
 +			/* Only continue writes not past the end of buffer. */
 +			len = strlen(data);
 +			if (len > maxlen - 1)
 +				len = maxlen - 1;
  
 -		if (left > PAGE_SIZE - 1) {
 -			left = PAGE_SIZE - 1;
 -			/* How much of the buffer we'll skip this pass */
 -			skipped = *lenp - left;
 +			if (*ppos > len)
 +				return 0;
 +			len = *ppos;
 +		} else {
 +			/* Start writing from beginning of buffer. */
 +			len = 0;
  		}
  
 -		tmp_bitmap = bitmap_zalloc(bitmap_len, GFP_KERNEL);
 -		if (!tmp_bitmap)
 -			return -ENOMEM;
 -		proc_skip_char(&p, &left, '\n');
 -		while (!err && left) {
 -			unsigned long val_a, val_b;
 -			bool neg;
 -			size_t saved_left;
 -
 -			/* In case we stop parsing mid-number, we can reset */
 -			saved_left = left;
 -			err = proc_get_long(&p, &left, &val_a, &neg, tr_a,
 -					     sizeof(tr_a), &c);
 -			/*
 -			 * If we consumed the entirety of a truncated buffer or
 -			 * only one char is left (may be a "-"), then stop here,
 -			 * reset, & come back for more.
 -			 */
 -			if ((left <= 1) && skipped) {
 -				left = saved_left;
 -				break;
 -			}
 -
 -			if (err)
 -				break;
 -			if (val_a >= bitmap_len || neg) {
 -				err = -EINVAL;
 +		*ppos += *lenp;
 +		p = buffer;
 +		while ((p - buffer) < *lenp && len < maxlen - 1) {
 +			if (get_user(c, p++))
 +				return -EFAULT;
 +			if (c == 0 || c == '\n')
  				break;
 -			}
 -
 -			val_b = val_a;
 -			if (left) {
 -				p++;
 -				left--;
 -			}
 -
 -			if (c == '-') {
 -				err = proc_get_long(&p, &left, &val_b,
 -						     &neg, tr_b, sizeof(tr_b),
 -						     &c);
 -				/*
 -				 * If we consumed all of a truncated buffer or
 -				 * then stop here, reset, & come back for more.
 -				 */
 -				if (!left && skipped) {
 -					left = saved_left;
 -					break;
 -				}
 -
 -				if (err)
 -					break;
 -				if (val_b >= bitmap_len || neg ||
 -				    val_a > val_b) {
 -					err = -EINVAL;
 -					break;
 -				}
 -				if (left) {
 -					p++;
 -					left--;
 -				}
 -			}
 -
 -			bitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);
 -			proc_skip_char(&p, &left, '\n');
 +			data[len++] = c;
  		}
 -		left += skipped;
 +		data[len] = 0;
  	} else {
 -		unsigned long bit_a, bit_b = 0;
 -		bool first = 1;
 -
 -		while (left) {
 -			bit_a = find_next_bit(bitmap, bitmap_len, bit_b);
 -			if (bit_a >= bitmap_len)
 -				break;
 -			bit_b = find_next_zero_bit(bitmap, bitmap_len,
 -						   bit_a + 1) - 1;
 -
 -			if (!first)
 -				proc_put_char(&buffer, &left, ',');
 -			proc_put_long(&buffer, &left, bit_a, false);
 -			if (bit_a != bit_b) {
 -				proc_put_char(&buffer, &left, '-');
 -				proc_put_long(&buffer, &left, bit_b, false);
 -			}
 +		len = strlen(data);
 +		if (len > maxlen)
 +			len = maxlen;
  
 -			first = 0; bit_b++;
 +		if (*ppos > len) {
 +			*lenp = 0;
 +			return 0;
  		}
 -		proc_put_char(&buffer, &left, '\n');
 -	}
  
 -	if (!err) {
 -		if (write) {
 -			if (*ppos)
 -				bitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);
 -			else
 -				bitmap_copy(bitmap, tmp_bitmap, bitmap_len);
 +		data += *ppos;
 +		len  -= *ppos;
 +
 +		if (len > *lenp)
 +			len = *lenp;
 +		if (len)
 +			if (copy_to_user(buffer, data, len))
 +				return -EFAULT;
 +		if (len < *lenp) {
 +			if (put_user('\n', buffer + len))
 +				return -EFAULT;
 +			len++;
  		}
 -		*lenp -= left;
 -		*ppos += *lenp;
 +		*lenp = len;
 +		*ppos += len;
  	}
 +	return 0;
 +}
  
 -	bitmap_free(tmp_bitmap);
 -	return err;
 +static void warn_sysctl_write(struct ctl_table *table)
 +{
 +	pr_warn_once("%s wrote to %s when file position was not 0!\n"
 +		"This will not be supported in the future. To silence this\n"
 +		"warning, set kernel.sysctl_writes_strict = -1\n",
 +		current->comm, table->procname);
  }
  
 -#else /* CONFIG_PROC_SYSCTL */
 +/**
 + * proc_first_pos_non_zero_ignore - check if firs position is allowed
 + * @ppos: file position
 + * @table: the sysctl table
 + *
 + * Returns true if the first position is non-zero and the sysctl_writes_strict
 + * mode indicates this is not allowed for numeric input types. String proc
 + * hadlers can ignore the return value.
 + */
 +static bool proc_first_pos_non_zero_ignore(loff_t *ppos,
 +					   struct ctl_table *table)
 +{
 +	if (!*ppos)
 +		return false;
 +
 +	switch (sysctl_writes_strict) {
 +	case SYSCTL_WRITES_STRICT:
 +		return true;
 +	case SYSCTL_WRITES_WARN:
 +		warn_sysctl_write(table);
 +		return false;
 +	default:
 +		return false;
 +	}
 +}
  
 +/**
 + * proc_dostring - read a string sysctl
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes a string from/to the user buffer. If the kernel
 + * buffer provided is not large enough to hold the string, the
 + * string is truncated. The copied string is %NULL-terminated.
 + * If the string is being read by the user process, it is copied
 + * and a newline '\n' is added. It is truncated if the buffer is
 + * not large enough.
 + *
 + * Returns 0 on success.
 + */
  int proc_dostring(struct ctl_table *table, int write,
 -		  void *buffer, size_t *lenp, loff_t *ppos)
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
  {
 -	return -ENOSYS;
 -}
 +	if (write)
 +		proc_first_pos_non_zero_ignore(ppos, table);
  
 -int proc_dobool(struct ctl_table *table, int write,
 -		void *buffer, size_t *lenp, loff_t *ppos)
 -{
 -	return -ENOSYS;
 +	return _proc_do_string((char *)(table->data), table->maxlen, write,
 +			       (char __user *)buffer, lenp, ppos);
  }
  
- static size_t proc_skip_spaces(char **buf)
 -int proc_dointvec(struct ctl_table *table, int write,
 -		  void *buffer, size_t *lenp, loff_t *ppos)
++static void proc_skip_spaces(char **buf, size_t *size)
  {
- 	size_t ret;
- 	char *tmp = skip_spaces(*buf);
- 	ret = tmp - *buf;
- 	*buf = tmp;
- 	return ret;
 -	return -ENOSYS;
++	while (*size) {
++		if (!isspace(**buf))
++			break;
++		(*size)--;
++		(*buf)++;
++	}
  }
  
 -int proc_douintvec(struct ctl_table *table, int write,
 -		  void *buffer, size_t *lenp, loff_t *ppos)
 +static void proc_skip_char(char **buf, size_t *size, const char v)
  {
 -	return -ENOSYS;
 +	while (*size) {
 +		if (**buf != v)
 +			break;
 +		(*size)--;
 +		(*buf)++;
 +	}
  }
  
 -int proc_dointvec_minmax(struct ctl_table *table, int write,
 -		    void *buffer, size_t *lenp, loff_t *ppos)
 +/**
 + * strtoul_lenient - parse an ASCII formatted integer from a buffer and only
 + *                   fail on overflow
 + *
 + * @cp: kernel buffer containing the string to parse
 + * @endp: pointer to store the trailing characters
 + * @base: the base to use
 + * @res: where the parsed integer will be stored
 + *
 + * In case of success 0 is returned and @res will contain the parsed integer,
 + * @endp will hold any trailing characters.
 + * This function will fail the parse on overflow. If there wasn't an overflow
 + * the function will defer the decision what characters count as invalid to the
 + * caller.
 + */
 +static int strtoul_lenient(const char *cp, char **endp, unsigned int base,
 +			   unsigned long *res)
  {
 -	return -ENOSYS;
 -}
 +	unsigned long long result;
 +	unsigned int rv;
  
 -int proc_douintvec_minmax(struct ctl_table *table, int write,
 -			  void *buffer, size_t *lenp, loff_t *ppos)
 -{
 -	return -ENOSYS;
 -}
 +	cp = _parse_integer_fixup_radix(cp, &base);
 +	rv = _parse_integer(cp, base, &result);
 +	if ((rv & KSTRTOX_OVERFLOW) || (result != (unsigned long)result))
 +		return -ERANGE;
  
 -int proc_dou8vec_minmax(struct ctl_table *table, int write,
 -			void *buffer, size_t *lenp, loff_t *ppos)
 -{
 -	return -ENOSYS;
 -}
 +	cp += rv;
  
 -int proc_dointvec_jiffies(struct ctl_table *table, int write,
 -		    void *buffer, size_t *lenp, loff_t *ppos)
 -{
 -	return -ENOSYS;
 -}
 +	if (endp)
 +		*endp = (char *)cp;
  
 -int proc_dointvec_ms_jiffies_minmax(struct ctl_table *table, int write,
 -				    void *buffer, size_t *lenp, loff_t *ppos)
 -{
 -	return -ENOSYS;
 +	*res = (unsigned long)result;
 +	return 0;
  }
  
 -int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
 -		    void *buffer, size_t *lenp, loff_t *ppos)
 +#define TMPBUFLEN 22
 +/**
 + * proc_get_long - reads an ASCII formatted integer from a user buffer
 + *
 + * @buf: a kernel buffer
 + * @size: size of the kernel buffer
 + * @val: this is where the number will be stored
 + * @neg: set to %TRUE if number is negative
 + * @perm_tr: a vector which contains the allowed trailers
 + * @perm_tr_len: size of the perm_tr vector
 + * @tr: pointer to store the trailer character
 + *
 + * In case of success %0 is returned and @buf and @size are updated with
 + * the amount of bytes read. If @tr is non-NULL and a trailing
 + * character exists (size is non-zero after returning from this
 + * function), @tr is updated with the trailing character.
 + */
 +static int proc_get_long(char **buf, size_t *size,
 +			  unsigned long *val, bool *neg,
 +			  const char *perm_tr, unsigned perm_tr_len, char *tr)
  {
 -	return -ENOSYS;
 +	char *p, tmp[TMPBUFLEN];
 +	ssize_t len = *size;
 +
 +	if (len <= 0)
 +		return -EINVAL;
 +
 +	if (len > TMPBUFLEN - 1)
 +		len = TMPBUFLEN - 1;
 +
 +	memcpy(tmp, *buf, len);
 +
 +	tmp[len] = 0;
 +	p = tmp;
 +	if (*p == '-' && *size > 1) {
 +		*neg = true;
 +		p++;
 +	} else
 +		*neg = false;
 +	if (!isdigit(*p))
 +		return -EINVAL;
 +
 +	if (strtoul_lenient(p, &p, 0, val))
 +		return -EINVAL;
 +
 +	len = p - tmp;
 +
 +	/* We don't know if the next char is whitespace thus we may accept
 +	 * invalid integers (e.g. 1234...a) or two integers instead of one
 +	 * (e.g. 123...1). So lets not allow such large numbers. */
 +	if (len == TMPBUFLEN - 1)
 +		return -EINVAL;
 +
 +	if (len < *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))
 +		return -EINVAL;
 +
 +	if (tr && (len < *size))
 +		*tr = *p;
 +
 +	*buf += len;
 +	*size -= len;
 +
 +	return 0;
  }
  
 -int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,
 -			     void *buffer, size_t *lenp, loff_t *ppos)
 +/**
 + * proc_put_long - converts an integer to a decimal ASCII formatted string
 + *
 + * @buf: the user buffer
 + * @size: the size of the user buffer
 + * @val: the integer to be converted
 + * @neg: sign of the number, %TRUE for negative
 + *
 + * In case of success %0 is returned and @buf and @size are updated with
 + * the amount of bytes written.
 + */
 +static int proc_put_long(void __user **buf, size_t *size, unsigned long val,
 +			  bool neg)
  {
 -	return -ENOSYS;
 +	int len;
 +	char tmp[TMPBUFLEN], *p = tmp;
 +
 +	sprintf(p, "%s%lu", neg ? "-" : "", val);
 +	len = strlen(tmp);
 +	if (len > *size)
 +		len = *size;
 +	if (copy_to_user(*buf, tmp, len))
 +		return -EFAULT;
 +	*size -= len;
 +	*buf += len;
 +	return 0;
  }
 +#undef TMPBUFLEN
  
 -int proc_doulongvec_minmax(struct ctl_table *table, int write,
 -		    void *buffer, size_t *lenp, loff_t *ppos)
 +static int proc_put_char(void __user **buf, size_t *size, char c)
  {
 -	return -ENOSYS;
 +	if (*size) {
 +		char __user **buffer = (char __user **)buf;
 +		if (put_user(c, *buffer))
 +			return -EFAULT;
 +		(*size)--, (*buffer)++;
 +		*buf = *buffer;
 +	}
 +	return 0;
  }
  
 -int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
 -				      void *buffer, size_t *lenp, loff_t *ppos)
 +static int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,
 +				 int *valp,
 +				 int write, void *data)
  {
 -	return -ENOSYS;
 +	if (write) {
 +		if (*negp) {
 +			if (*lvalp > (unsigned long) INT_MAX + 1)
 +				return -EINVAL;
 +			*valp = -*lvalp;
 +		} else {
 +			if (*lvalp > (unsigned long) INT_MAX)
 +				return -EINVAL;
 +			*valp = *lvalp;
 +		}
 +	} else {
 +		int val = *valp;
 +		if (val < 0) {
 +			*negp = true;
 +			*lvalp = (unsigned long)-val;
 +		} else {
 +			*negp = false;
 +			*lvalp = (unsigned long)val;
 +		}
 +	}
 +	return 0;
  }
  
 -int proc_do_large_bitmap(struct ctl_table *table, int write,
 -			 void *buffer, size_t *lenp, loff_t *ppos)
 +static int do_proc_douintvec_conv(unsigned long *lvalp,
 +				  unsigned int *valp,
 +				  int write, void *data)
  {
 -	return -ENOSYS;
 +	if (write) {
 +		if (*lvalp > UINT_MAX)
 +			return -EINVAL;
 +		*valp = *lvalp;
 +	} else {
 +		unsigned int val = *valp;
 +		*lvalp = (unsigned long)val;
 +	}
 +	return 0;
  }
  
 -#endif /* CONFIG_PROC_SYSCTL */
 +static const char proc_wspace_sep[] = { ' ', '\t', '\n' };
  
 -#if defined(CONFIG_SYSCTL)
 -int proc_do_static_key(struct ctl_table *table, int write,
 -		       void *buffer, size_t *lenp, loff_t *ppos)
 +static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,
 +		  int write, void __user *buffer,
 +		  size_t *lenp, loff_t *ppos,
 +		  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,
 +			      int write, void *data),
 +		  void *data)
  {
 -	struct static_key *key = (struct static_key *)table->data;
 -	static DEFINE_MUTEX(static_key_mutex);
 -	int val, ret;
 -	struct ctl_table tmp = {
 -		.data   = &val,
 -		.maxlen = sizeof(val),
 -		.mode   = table->mode,
 -		.extra1 = SYSCTL_ZERO,
 -		.extra2 = SYSCTL_ONE,
 -	};
 +	int *i, vleft, first = 1, err = 0;
 +	unsigned long page = 0;
 +	size_t left;
 +	char *kbuf;
 +	
 +	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
 +		*lenp = 0;
 +		return 0;
 +	}
 +	
 +	i = (int *) tbl_data;
 +	vleft = table->maxlen / sizeof(*i);
 +	left = *lenp;
  
 -	if (write && !capable(CAP_SYS_ADMIN))
 -		return -EPERM;
 +	if (!conv)
 +		conv = do_proc_dointvec_conv;
 +
 +	if (write) {
 +		if (proc_first_pos_non_zero_ignore(ppos, table))
 +			goto out;
 +
 +		if (left > PAGE_SIZE - 1)
 +			left = PAGE_SIZE - 1;
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			err = -EFAULT;
 +			goto free;
 +		}
 +		kbuf[left] = 0;
 +	}
 +
 +	for (; left && vleft--; i++, first=0) {
 +		unsigned long lval;
 +		bool neg;
 +
 +		if (write) {
++<<<<<<< HEAD
 +			left -= proc_skip_spaces(&kbuf);
++=======
++			proc_skip_spaces(&p, &left);
++>>>>>>> bce9332220bd (proc: proc_skip_spaces() shouldn't think it is working on C strings)
  
 -	mutex_lock(&static_key_mutex);
 -	val = static_key_enabled(key);
 -	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
 -	if (write && !ret) {
 -		if (val)
 -			static_key_enable(key);
 -		else
 -			static_key_disable(key);
 +			if (!left)
 +				break;
 +			err = proc_get_long(&kbuf, &left, &lval, &neg,
 +					     proc_wspace_sep,
 +					     sizeof(proc_wspace_sep), NULL);
 +			if (err)
 +				break;
 +			if (conv(&neg, &lval, i, 1, data)) {
 +				err = -EINVAL;
 +				break;
 +			}
 +		} else {
 +			if (conv(&neg, &lval, i, 0, data)) {
 +				err = -EINVAL;
 +				break;
 +			}
 +			if (!first)
 +				err = proc_put_char(&buffer, &left, '\t');
 +			if (err)
 +				break;
 +			err = proc_put_long(&buffer, &left, lval, neg);
 +			if (err)
 +				break;
 +		}
  	}
 -	mutex_unlock(&static_key_mutex);
 -	return ret;
 -}
  
 -static struct ctl_table kern_table[] = {
 -#ifdef CONFIG_NUMA_BALANCING
 -	{
 -		.procname	= "numa_balancing",
 -		.data		= NULL, /* filled in by handler */
 -		.maxlen		= sizeof(unsigned int),
 -		.mode		= 0644,
 -		.proc_handler	= sysctl_numa_balancing,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_FOUR,
 -	},
 -	{
 -		.procname	= "numa_balancing_promote_rate_limit_MBps",
 -		.data		= &sysctl_numa_balancing_promote_rate_limit,
 -		.maxlen		= sizeof(unsigned int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#endif /* CONFIG_NUMA_BALANCING */
 -	{
 -		.procname	= "panic",
 -		.data		= &panic_timeout,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#ifdef CONFIG_PROC_SYSCTL
 -	{
 -		.procname	= "tainted",
 -		.maxlen 	= sizeof(long),
 -		.mode		= 0644,
 -		.proc_handler	= proc_taint,
 -	},
 -	{
 -		.procname	= "sysctl_writes_strict",
 -		.data		= &sysctl_writes_strict,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_NEG_ONE,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -	{
 -		.procname	= "print-fatal-signals",
 -		.data		= &print_fatal_signals,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#ifdef CONFIG_SPARC
 -	{
 -		.procname	= "reboot-cmd",
 -		.data		= reboot_command,
 -		.maxlen		= 256,
 -		.mode		= 0644,
 -		.proc_handler	= proc_dostring,
 -	},
 -	{
 -		.procname	= "stop-a",
 -		.data		= &stop_a_enabled,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "scons-poweroff",
 -		.data		= &scons_pwroff,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_SPARC64
 -	{
 -		.procname	= "tsb-ratio",
 -		.data		= &sysctl_tsb_ratio,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_PARISC
 -	{
 -		.procname	= "soft-power",
 -		.data		= &pwrsw_enabled,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_SYSCTL_ARCH_UNALIGN_ALLOW
 -	{
 -		.procname	= "unaligned-trap",
 -		.data		= &unaligned_enabled,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_STACK_TRACER
 -	{
 -		.procname	= "stack_tracer_enabled",
 -		.data		= &stack_tracer_enabled,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= stack_trace_sysctl,
 -	},
 -#endif
 -#ifdef CONFIG_TRACING
 -	{
 -		.procname	= "ftrace_dump_on_oops",
 -		.data		= &ftrace_dump_on_oops,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "traceoff_on_warning",
 -		.data		= &__disable_trace_on_warning,
 -		.maxlen		= sizeof(__disable_trace_on_warning),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "tracepoint_printk",
 -		.data		= &tracepoint_printk,
 -		.maxlen		= sizeof(tracepoint_printk),
 -		.mode		= 0644,
 -		.proc_handler	= tracepoint_printk_sysctl,
 -	},
 -#endif
 -#ifdef CONFIG_MODULES
 -	{
 -		.procname	= "modprobe",
 -		.data		= &modprobe_path,
 -		.maxlen		= KMOD_PATH_LEN,
 -		.mode		= 0644,
 -		.proc_handler	= proc_dostring,
 -	},
 -	{
 -		.procname	= "modules_disabled",
 -		.data		= &modules_disabled,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		/* only handle a transition from default "0" to "1" */
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -#ifdef CONFIG_UEVENT_HELPER
 -	{
 -		.procname	= "hotplug",
 -		.data		= &uevent_helper,
 -		.maxlen		= UEVENT_HELPER_PATH_LEN,
 -		.mode		= 0644,
 -		.proc_handler	= proc_dostring,
 -	},
 -#endif
 -#ifdef CONFIG_MAGIC_SYSRQ
 -	{
 -		.procname	= "sysrq",
 -		.data		= NULL,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= sysrq_sysctl_handler,
 -	},
 -#endif
 -#ifdef CONFIG_PROC_SYSCTL
 -	{
 -		.procname	= "cad_pid",
 -		.data		= NULL,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0600,
 -		.proc_handler	= proc_do_cad_pid,
 -	},
 -#endif
 -	{
 -		.procname	= "threads-max",
 -		.data		= NULL,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= sysctl_max_threads,
 -	},
 -	{
 -		.procname	= "usermodehelper",
 -		.mode		= 0555,
 -		.child		= usermodehelper_table,
 -	},
 -	{
 -		.procname	= "overflowuid",
 -		.data		= &overflowuid,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_MAXOLDUID,
 -	},
 -	{
 -		.procname	= "overflowgid",
 -		.data		= &overflowgid,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_MAXOLDUID,
 -	},
 -#ifdef CONFIG_S390
 -	{
 -		.procname	= "userprocess_debug",
 -		.data		= &show_unhandled_signals,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -	{
 -		.procname	= "pid_max",
 -		.data		= &pid_max,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &pid_max_min,
 -		.extra2		= &pid_max_max,
 -	},
 -	{
 -		.procname	= "panic_on_oops",
 -		.data		= &panic_on_oops,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "panic_print",
 -		.data		= &panic_print,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -	{
 -		.procname	= "ngroups_max",
 -		.data		= (void *)&ngroups_max,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "cap_last_cap",
 -		.data		= (void *)&cap_last_cap,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86)
 -	{
 -		.procname       = "unknown_nmi_panic",
 -		.data           = &unknown_nmi_panic,
 -		.maxlen         = sizeof (int),
 -		.mode           = 0644,
 -		.proc_handler   = proc_dointvec,
 -	},
 -#endif
 +	if (!write && !first && left && !err)
 +		err = proc_put_char(&buffer, &left, '\n');
 +	if (write && !err && left)
++<<<<<<< HEAD
 +		left -= proc_skip_spaces(&kbuf);
 +free:
 +	if (write) {
 +		free_page(page);
 +		if (first)
 +			return err ? : -EINVAL;
 +	}
++=======
++		proc_skip_spaces(&p, &left);
++	if (write && first)
++		return err ? : -EINVAL;
++>>>>>>> bce9332220bd (proc: proc_skip_spaces() shouldn't think it is working on C strings)
 +	*lenp -= left;
 +out:
 +	*ppos += *lenp;
 +	return err;
 +}
  
 -#if (defined(CONFIG_X86_32) || defined(CONFIG_PARISC)) && \
 -	defined(CONFIG_DEBUG_STACKOVERFLOW)
 -	{
 -		.procname	= "panic_on_stackoverflow",
 -		.data		= &sysctl_panic_on_stackoverflow,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#if defined(CONFIG_X86)
 -	{
 -		.procname	= "panic_on_unrecovered_nmi",
 -		.data		= &panic_on_unrecovered_nmi,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "panic_on_io_nmi",
 -		.data		= &panic_on_io_nmi,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "bootloader_type",
 -		.data		= &bootloader_type,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "bootloader_version",
 -		.data		= &bootloader_version,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "io_delay_type",
 -		.data		= &io_delay_type,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#if defined(CONFIG_MMU)
 -	{
 -		.procname	= "randomize_va_space",
 -		.data		= &randomize_va_space,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#if defined(CONFIG_S390) && defined(CONFIG_SMP)
 -	{
 -		.procname	= "spin_retry",
 -		.data		= &spin_retry,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#if	defined(CONFIG_ACPI_SLEEP) && defined(CONFIG_X86)
 -	{
 -		.procname	= "acpi_video_flags",
 -		.data		= &acpi_realmode_flags,
 -		.maxlen		= sizeof (unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -#endif
 -#ifdef CONFIG_SYSCTL_ARCH_UNALIGN_NO_WARN
 -	{
 -		.procname	= "ignore-unaligned-usertrap",
 -		.data		= &no_unaligned_warning,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_IA64
 -	{
 -		.procname	= "unaligned-dump-stack",
 -		.data		= &unaligned_dump_stack,
 -		.maxlen		= sizeof (int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_RT_MUTEXES
 -	{
 -		.procname	= "max_lock_depth",
 -		.data		= &max_lock_depth,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -#endif
 -#ifdef CONFIG_KEYS
 -	{
 -		.procname	= "keys",
 -		.mode		= 0555,
 -		.child		= key_sysctls,
 -	},
 +static int do_proc_dointvec(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos,
 +		  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,
 +			      int write, void *data),
 +		  void *data)
 +{
 +	return __do_proc_dointvec(table->data, table, write,
 +			buffer, lenp, ppos, conv, data);
 +}
 +
 +static int do_proc_douintvec_w(unsigned int *tbl_data,
 +			       struct ctl_table *table,
 +			       void __user *buffer,
 +			       size_t *lenp, loff_t *ppos,
 +			       int (*conv)(unsigned long *lvalp,
 +					   unsigned int *valp,
 +					   int write, void *data),
 +			       void *data)
 +{
 +	unsigned long lval;
 +	int err = 0;
 +	size_t left;
 +	bool neg;
 +	char *kbuf = NULL, *p;
 +
 +	left = *lenp;
 +
 +	if (proc_first_pos_non_zero_ignore(ppos, table))
 +		goto bail_early;
 +
 +	if (left > PAGE_SIZE - 1)
 +		left = PAGE_SIZE - 1;
 +
++<<<<<<< HEAD
 +	p = kbuf = memdup_user_nul(buffer, left);
 +	if (IS_ERR(kbuf))
 +		return -EINVAL;
 +
 +	left -= proc_skip_spaces(&p);
++=======
++	proc_skip_spaces(&p, &left);
++>>>>>>> bce9332220bd (proc: proc_skip_spaces() shouldn't think it is working on C strings)
 +	if (!left) {
 +		err = -EINVAL;
 +		goto out_free;
 +	}
 +
 +	err = proc_get_long(&p, &left, &lval, &neg,
 +			     proc_wspace_sep,
 +			     sizeof(proc_wspace_sep), NULL);
 +	if (err || neg) {
 +		err = -EINVAL;
 +		goto out_free;
 +	}
 +
 +	if (conv(&lval, tbl_data, 1, data)) {
 +		err = -EINVAL;
 +		goto out_free;
 +	}
 +
 +	if (!err && left)
- 		left -= proc_skip_spaces(&p);
++		proc_skip_spaces(&p, &left);
 +
 +out_free:
 +	kfree(kbuf);
 +	if (err)
 +		return -EINVAL;
 +
 +	return 0;
 +
 +	/* This is in keeping with old __do_proc_dointvec() */
 +bail_early:
 +	*ppos += *lenp;
 +	return err;
 +}
 +
 +static int do_proc_douintvec_r(unsigned int *tbl_data, void __user *buffer,
 +			       size_t *lenp, loff_t *ppos,
 +			       int (*conv)(unsigned long *lvalp,
 +					   unsigned int *valp,
 +					   int write, void *data),
 +			       void *data)
 +{
 +	unsigned long lval;
 +	int err = 0;
 +	size_t left;
 +
 +	left = *lenp;
 +
 +	if (conv(&lval, tbl_data, 0, data)) {
 +		err = -EINVAL;
 +		goto out;
 +	}
 +
 +	err = proc_put_long(&buffer, &left, lval, false);
 +	if (err || !left)
 +		goto out;
 +
 +	err = proc_put_char(&buffer, &left, '\n');
 +
 +out:
 +	*lenp -= left;
 +	*ppos += *lenp;
 +
 +	return err;
 +}
 +
 +static int __do_proc_douintvec(void *tbl_data, struct ctl_table *table,
 +			       int write, void __user *buffer,
 +			       size_t *lenp, loff_t *ppos,
 +			       int (*conv)(unsigned long *lvalp,
 +					   unsigned int *valp,
 +					   int write, void *data),
 +			       void *data)
 +{
 +	unsigned int *i, vleft;
 +
 +	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
 +		*lenp = 0;
 +		return 0;
 +	}
 +
 +	i = (unsigned int *) tbl_data;
 +	vleft = table->maxlen / sizeof(*i);
 +
 +	/*
 +	 * Arrays are not supported, keep this simple. *Do not* add
 +	 * support for them.
 +	 */
 +	if (vleft != 1) {
 +		*lenp = 0;
 +		return -EINVAL;
 +	}
 +
 +	if (!conv)
 +		conv = do_proc_douintvec_conv;
 +
 +	if (write)
 +		return do_proc_douintvec_w(i, table, buffer, lenp, ppos,
 +					   conv, data);
 +	return do_proc_douintvec_r(i, buffer, lenp, ppos, conv, data);
 +}
 +
 +static int do_proc_douintvec(struct ctl_table *table, int write,
 +			     void __user *buffer, size_t *lenp, loff_t *ppos,
 +			     int (*conv)(unsigned long *lvalp,
 +					 unsigned int *valp,
 +					 int write, void *data),
 +			     void *data)
 +{
 +	return __do_proc_douintvec(table->data, table, write,
 +				   buffer, lenp, ppos, conv, data);
 +}
 +
 +/**
 + * proc_dointvec - read a vector of integers
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string. 
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec(struct ctl_table *table, int write,
 +		     void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);
 +}
 +
 +/**
 + * proc_douintvec - read a vector of unsigned integers
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer
 + * values from/to the user buffer, treated as an ASCII string.
 + *
 + * Returns 0 on success.
 + */
 +int proc_douintvec(struct ctl_table *table, int write,
 +		     void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return do_proc_douintvec(table, write, buffer, lenp, ppos,
 +				 do_proc_douintvec_conv, NULL);
 +}
 +
 +/*
 + * Taint values can only be increased
 + * This means we can safely use a temporary.
 + */
 +static int proc_taint(struct ctl_table *table, int write,
 +			       void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct ctl_table t;
 +	unsigned long tmptaint = get_taint();
 +	int err;
 +
 +	if (write && !capable(CAP_SYS_ADMIN))
 +		return -EPERM;
 +
 +	t = *table;
 +	t.data = &tmptaint;
 +	err = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);
 +	if (err < 0)
 +		return err;
 +
 +	if (write) {
 +		int i;
 +
 +		/*
 +		 * If we are relying on panic_on_taint not producing
 +		 * false positives due to userspace input, bail out
 +		 * before setting the requested taint flags.
 +		 */
 +		if (panic_on_taint_nousertaint && (tmptaint & panic_on_taint))
 +			return -EINVAL;
 +
 +		/*
 +		 * Poor man's atomic or. Not worth adding a primitive
 +		 * to everyone's atomic.h for this
 +		 */
 +		for (i = 0; i < TAINT_FLAGS_COUNT; i++)
 +			if ((1UL << i) & tmptaint)
 +				add_taint(i, LOCKDEP_STILL_OK);
 +	}
 +
 +	return err;
 +}
 +
 +#ifdef CONFIG_PRINTK
 +static int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,
 +				void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	if (write && !capable(CAP_SYS_ADMIN))
 +		return -EPERM;
 +
 +	return proc_dointvec_minmax(table, write, buffer, lenp, ppos);
 +}
  #endif
 -#ifdef CONFIG_PERF_EVENTS
 +
 +struct do_proc_dointvec_minmax_conv_param {
 +	int *min;
 +	int *max;
 +};
 +
 +static int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,
 +					int *valp,
 +					int write, void *data)
 +{
 +	int tmp, ret;
 +	struct do_proc_dointvec_minmax_conv_param *param = data;
  	/*
 -	 * User-space scripts rely on the existence of this file
 -	 * as a feature check for perf_events being enabled.
 -	 *
 -	 * So it's an ABI, do not remove!
 +	 * If writing, first do so via a temporary local int so we can
 +	 * bounds-check it before touching *valp.
  	 */
 -	{
 -		.procname	= "perf_event_paranoid",
 -		.data		= &sysctl_perf_event_paranoid,
 -		.maxlen		= sizeof(sysctl_perf_event_paranoid),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "perf_event_mlock_kb",
 -		.data		= &sysctl_perf_event_mlock,
 -		.maxlen		= sizeof(sysctl_perf_event_mlock),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "perf_event_max_sample_rate",
 -		.data		= &sysctl_perf_event_sample_rate,
 -		.maxlen		= sizeof(sysctl_perf_event_sample_rate),
 -		.mode		= 0644,
 -		.proc_handler	= perf_proc_update_handler,
 -		.extra1		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "perf_cpu_time_max_percent",
 -		.data		= &sysctl_perf_cpu_time_max_percent,
 -		.maxlen		= sizeof(sysctl_perf_cpu_time_max_percent),
 -		.mode		= 0644,
 -		.proc_handler	= perf_cpu_time_max_percent_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE_HUNDRED,
 -	},
 -	{
 -		.procname	= "perf_event_max_stack",
 -		.data		= &sysctl_perf_event_max_stack,
 -		.maxlen		= sizeof(sysctl_perf_event_max_stack),
 -		.mode		= 0644,
 -		.proc_handler	= perf_event_max_stack_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= (void *)&six_hundred_forty_kb,
 -	},
 -	{
 -		.procname	= "perf_event_max_contexts_per_stack",
 -		.data		= &sysctl_perf_event_max_contexts_per_stack,
 -		.maxlen		= sizeof(sysctl_perf_event_max_contexts_per_stack),
 -		.mode		= 0644,
 -		.proc_handler	= perf_event_max_stack_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE_THOUSAND,
 -	},
 -#endif
 -	{
 -		.procname	= "panic_on_warn",
 -		.data		= &panic_on_warn,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#ifdef CONFIG_TREE_RCU
 -	{
 -		.procname	= "panic_on_rcu_stall",
 -		.data		= &sysctl_panic_on_rcu_stall,
 -		.maxlen		= sizeof(sysctl_panic_on_rcu_stall),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "max_rcu_stall_to_panic",
 -		.data		= &sysctl_max_rcu_stall_to_panic,
 -		.maxlen		= sizeof(sysctl_max_rcu_stall_to_panic),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= SYSCTL_INT_MAX,
 -	},
 +	int *ip = write ? &tmp : valp;
 +
 +	ret = do_proc_dointvec_conv(negp, lvalp, ip, write, data);
 +	if (ret)
 +		return ret;
 +
 +	if (write) {
 +		if ((param->min && *param->min > tmp) ||
 +		    (param->max && *param->max < tmp))
 +			return -EINVAL;
 +		*valp = tmp;
 +	}
 +
 +	return 0;
 +}
 +
 +/**
 + * proc_dointvec_minmax - read a vector of integers with min/max values
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string.
 + *
 + * This routine will ensure the values are within the range specified by
 + * table->extra1 (min) and table->extra2 (max).
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec_minmax(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct do_proc_dointvec_minmax_conv_param param = {
 +		.min = (int *) table->extra1,
 +		.max = (int *) table->extra2,
 +	};
 +	return do_proc_dointvec(table, write, buffer, lenp, ppos,
 +				do_proc_dointvec_minmax_conv, &param);
 +}
 +
 +struct do_proc_douintvec_minmax_conv_param {
 +	unsigned int *min;
 +	unsigned int *max;
 +};
 +
 +static int do_proc_douintvec_minmax_conv(unsigned long *lvalp,
 +					 unsigned int *valp,
 +					 int write, void *data)
 +{
 +	int ret;
 +	unsigned int tmp;
 +	struct do_proc_douintvec_minmax_conv_param *param = data;
 +	/* write via temporary local uint for bounds-checking */
 +	unsigned int *up = write ? &tmp : valp;
 +
 +	ret = do_proc_douintvec_conv(lvalp, up, write, data);
 +	if (ret)
 +		return ret;
 +
 +	if (write) {
 +		if ((param->min && *param->min > tmp) ||
 +		    (param->max && *param->max < tmp))
 +			return -ERANGE;
 +
 +		*valp = tmp;
 +	}
 +
 +	return 0;
 +}
 +
 +/**
 + * proc_douintvec_minmax - read a vector of unsigned ints with min/max values
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer
 + * values from/to the user buffer, treated as an ASCII string. Negative
 + * strings are not allowed.
 + *
 + * This routine will ensure the values are within the range specified by
 + * table->extra1 (min) and table->extra2 (max). There is a final sanity
 + * check for UINT_MAX to avoid having to support wrap around uses from
 + * userspace.
 + *
 + * Returns 0 on success.
 + */
 +int proc_douintvec_minmax(struct ctl_table *table, int write,
 +			  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct do_proc_douintvec_minmax_conv_param param = {
 +		.min = (unsigned int *) table->extra1,
 +		.max = (unsigned int *) table->extra2,
 +	};
 +	return do_proc_douintvec(table, write, buffer, lenp, ppos,
 +				 do_proc_douintvec_minmax_conv, &param);
 +}
 +
 +struct do_proc_dopipe_max_size_conv_param {
 +	unsigned int *min;
 +};
 +
 +static int do_proc_dopipe_max_size_conv(unsigned long *lvalp,
 +					unsigned int *valp,
 +					int write, void *data)
 +{
 +	struct do_proc_dopipe_max_size_conv_param *param = data;
 +
 +	if (write) {
 +		unsigned int val;
 +
 +		if (*lvalp > UINT_MAX)
 +			return -EINVAL;
 +
 +		val = round_pipe_size(*lvalp);
 +		if (val == 0)
 +			return -EINVAL;
 +
 +		if (param->min && *param->min > val)
 +			return -ERANGE;
 +
 +		*valp = val;
 +	} else {
 +		unsigned int val = *valp;
 +		*lvalp = (unsigned long) val;
 +	}
 +
 +	return 0;
 +}
 +
 +int proc_dopipe_max_size(struct ctl_table *table, int write,
 +			 void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct do_proc_dopipe_max_size_conv_param param = {
 +		.min = (unsigned int *) table->extra1,
 +	};
 +	return do_proc_douintvec(table, write, buffer, lenp, ppos,
 +				 do_proc_dopipe_max_size_conv, &param);
 +}
 +
 +static void validate_coredump_safety(void)
 +{
 +#ifdef CONFIG_COREDUMP
 +	if (suid_dumpable == SUID_DUMP_ROOT &&
 +	    core_pattern[0] != '/' && core_pattern[0] != '|') {
 +		printk(KERN_WARNING "Unsafe core_pattern used with "\
 +			"suid_dumpable=2. Pipe handler or fully qualified "\
 +			"core dump path required.\n");
 +	}
  #endif
 -	{ }
 -};
 +}
 +
 +static int proc_dointvec_minmax_coredump(struct ctl_table *table, int write,
 +		void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	int error = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
 +	if (!error)
 +		validate_coredump_safety();
 +	return error;
 +}
 +
 +#ifdef CONFIG_COREDUMP
 +static int proc_dostring_coredump(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	int error = proc_dostring(table, write, buffer, lenp, ppos);
 +	if (!error)
 +		validate_coredump_safety();
 +	return error;
 +}
 +#endif
 +
 +static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table, int write,
 +				     void __user *buffer,
 +				     size_t *lenp, loff_t *ppos,
 +				     unsigned long convmul,
 +				     unsigned long convdiv)
 +{
 +	unsigned long *i, *min, *max;
 +	int vleft, first = 1, err = 0;
 +	unsigned long page = 0;
 +	size_t left;
 +	char *kbuf;
 +
 +	if (!data || !table->maxlen || !*lenp || (*ppos && !write)) {
 +		*lenp = 0;
 +		return 0;
 +	}
 +
 +	i = (unsigned long *) data;
 +	min = (unsigned long *) table->extra1;
 +	max = (unsigned long *) table->extra2;
 +	vleft = table->maxlen / sizeof(unsigned long);
 +	left = *lenp;
 +
 +	if (write) {
 +		if (proc_first_pos_non_zero_ignore(ppos, table))
 +			goto out;
 +
 +		if (left > PAGE_SIZE - 1)
 +			left = PAGE_SIZE - 1;
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			err = -EFAULT;
 +			goto free;
 +		}
 +		kbuf[left] = 0;
 +	}
 +
 +	for (; left && vleft--; i++, first = 0) {
 +		unsigned long val;
 +
 +		if (write) {
 +			bool neg;
 +
++<<<<<<< HEAD
 +			left -= proc_skip_spaces(&kbuf);
++=======
++			proc_skip_spaces(&p, &left);
++			if (!left)
++				break;
++>>>>>>> bce9332220bd (proc: proc_skip_spaces() shouldn't think it is working on C strings)
 +
 +			err = proc_get_long(&kbuf, &left, &val, &neg,
 +					     proc_wspace_sep,
 +					     sizeof(proc_wspace_sep), NULL);
 +			if (err)
 +				break;
 +			if (neg)
 +				continue;
 +			if ((min && val < *min) || (max && val > *max))
 +				continue;
 +			*i = val;
 +		} else {
 +			val = convdiv * (*i) / convmul;
 +			if (!first)
 +				err = proc_put_char(&buffer, &left, '\t');
 +			err = proc_put_long(&buffer, &left, val, false);
 +			if (err)
 +				break;
 +		}
 +	}
 +
 +	if (!write && !first && left && !err)
 +		err = proc_put_char(&buffer, &left, '\n');
 +	if (write && !err)
++<<<<<<< HEAD
 +		left -= proc_skip_spaces(&kbuf);
 +free:
 +	if (write) {
 +		free_page(page);
 +		if (first)
 +			return err ? : -EINVAL;
 +	}
++=======
++		proc_skip_spaces(&p, &left);
++	if (write && first)
++		return err ? : -EINVAL;
++>>>>>>> bce9332220bd (proc: proc_skip_spaces() shouldn't think it is working on C strings)
 +	*lenp -= left;
 +out:
 +	*ppos += *lenp;
 +	return err;
 +}
 +
 +static int do_proc_doulongvec_minmax(struct ctl_table *table, int write,
 +				     void __user *buffer,
 +				     size_t *lenp, loff_t *ppos,
 +				     unsigned long convmul,
 +				     unsigned long convdiv)
 +{
 +	return __do_proc_doulongvec_minmax(table->data, table, write,
 +			buffer, lenp, ppos, convmul, convdiv);
 +}
 +
 +/**
 + * proc_doulongvec_minmax - read a vector of long integers with min/max values
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long
 + * values from/to the user buffer, treated as an ASCII string.
 + *
 + * This routine will ensure the values are within the range specified by
 + * table->extra1 (min) and table->extra2 (max).
 + *
 + * Returns 0 on success.
 + */
 +int proc_doulongvec_minmax(struct ctl_table *table, int write,
 +			   void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +    return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);
 +}
 +
 +/**
 + * proc_doulongvec_ms_jiffies_minmax - read a vector of millisecond values with min/max values
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long
 + * values from/to the user buffer, treated as an ASCII string. The values
 + * are treated as milliseconds, and converted to jiffies when they are stored.
 + *
 + * This routine will ensure the values are within the range specified by
 + * table->extra1 (min) and table->extra2 (max).
 + *
 + * Returns 0 on success.
 + */
 +int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
 +				      void __user *buffer,
 +				      size_t *lenp, loff_t *ppos)
 +{
 +    return do_proc_doulongvec_minmax(table, write, buffer,
 +				     lenp, ppos, HZ, 1000l);
 +}
 +
 +
 +static int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,
 +					 int *valp,
 +					 int write, void *data)
 +{
 +	if (write) {
 +		if (*lvalp > LONG_MAX / HZ)
 +			return 1;
 +		*valp = *negp ? -(*lvalp*HZ) : (*lvalp*HZ);
 +	} else {
 +		int val = *valp;
 +		unsigned long lval;
 +		if (val < 0) {
 +			*negp = true;
 +			lval = (unsigned long)-val;
 +		} else {
 +			*negp = false;
 +			lval = (unsigned long)val;
 +		}
 +		*lvalp = lval / HZ;
 +	}
 +	return 0;
 +}
 +
 +static int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,
 +						int *valp,
 +						int write, void *data)
 +{
 +	if (write) {
 +		if (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ)
 +			return 1;
 +		*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp);
 +	} else {
 +		int val = *valp;
 +		unsigned long lval;
 +		if (val < 0) {
 +			*negp = true;
 +			lval = (unsigned long)-val;
 +		} else {
 +			*negp = false;
 +			lval = (unsigned long)val;
 +		}
 +		*lvalp = jiffies_to_clock_t(lval);
 +	}
 +	return 0;
 +}
 +
 +static int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,
 +					    int *valp,
 +					    int write, void *data)
 +{
 +	if (write) {
 +		unsigned long jif = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);
 +
 +		if (jif > INT_MAX)
 +			return 1;
 +		*valp = (int)jif;
 +	} else {
 +		int val = *valp;
 +		unsigned long lval;
 +		if (val < 0) {
 +			*negp = true;
 +			lval = (unsigned long)-val;
 +		} else {
 +			*negp = false;
 +			lval = (unsigned long)val;
 +		}
 +		*lvalp = jiffies_to_msecs(lval);
 +	}
 +	return 0;
 +}
 +
 +/**
 + * proc_dointvec_jiffies - read a vector of integers as seconds
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string. 
 + * The values read are assumed to be in seconds, and are converted into
 + * jiffies.
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec_jiffies(struct ctl_table *table, int write,
 +			  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +    return do_proc_dointvec(table,write,buffer,lenp,ppos,
 +		    	    do_proc_dointvec_jiffies_conv,NULL);
 +}
 +
 +/**
 + * proc_dointvec_userhz_jiffies - read a vector of integers as 1/USER_HZ seconds
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: pointer to the file position
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string. 
 + * The values read are assumed to be in 1/USER_HZ seconds, and 
 + * are converted into jiffies.
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
 +				 void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +    return do_proc_dointvec(table,write,buffer,lenp,ppos,
 +		    	    do_proc_dointvec_userhz_jiffies_conv,NULL);
 +}
 +
 +/**
 + * proc_dointvec_ms_jiffies - read a vector of integers as 1 milliseconds
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + * @ppos: the current position in the file
 + *
 + * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
 + * values from/to the user buffer, treated as an ASCII string. 
 + * The values read are assumed to be in 1/1000 seconds, and 
 + * are converted into jiffies.
 + *
 + * Returns 0 on success.
 + */
 +int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,
 +			     void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return do_proc_dointvec(table, write, buffer, lenp, ppos,
 +				do_proc_dointvec_ms_jiffies_conv, NULL);
 +}
 +
 +static int proc_do_cad_pid(struct ctl_table *table, int write,
 +			   void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	struct pid *new_pid;
 +	pid_t tmp;
 +	int r;
  
 -static struct ctl_table vm_table[] = {
 -	{
 -		.procname	= "overcommit_memory",
 -		.data		= &sysctl_overcommit_memory,
 -		.maxlen		= sizeof(sysctl_overcommit_memory),
 -		.mode		= 0644,
 -		.proc_handler	= overcommit_policy_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_TWO,
 -	},
 -	{
 -		.procname	= "overcommit_ratio",
 -		.data		= &sysctl_overcommit_ratio,
 -		.maxlen		= sizeof(sysctl_overcommit_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= overcommit_ratio_handler,
 -	},
 -	{
 -		.procname	= "overcommit_kbytes",
 -		.data		= &sysctl_overcommit_kbytes,
 -		.maxlen		= sizeof(sysctl_overcommit_kbytes),
 -		.mode		= 0644,
 -		.proc_handler	= overcommit_kbytes_handler,
 -	},
 -	{
 -		.procname	= "page-cluster",
 -		.data		= &page_cluster,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "dirtytime_expire_seconds",
 -		.data		= &dirtytime_expire_interval,
 -		.maxlen		= sizeof(dirtytime_expire_interval),
 -		.mode		= 0644,
 -		.proc_handler	= dirtytime_interval_handler,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "swappiness",
 -		.data		= &vm_swappiness,
 -		.maxlen		= sizeof(vm_swappiness),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_TWO_HUNDRED,
 -	},
 -#ifdef CONFIG_NUMA
 -	{
 -		.procname	= "numa_stat",
 -		.data		= &sysctl_vm_numa_stat,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= sysctl_vm_numa_stat_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -#ifdef CONFIG_HUGETLB_PAGE
 -	{
 -		.procname	= "nr_hugepages",
 -		.data		= NULL,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= hugetlb_sysctl_handler,
 -	},
 -#ifdef CONFIG_NUMA
 -	{
 -		.procname       = "nr_hugepages_mempolicy",
 -		.data           = NULL,
 -		.maxlen         = sizeof(unsigned long),
 -		.mode           = 0644,
 -		.proc_handler   = &hugetlb_mempolicy_sysctl_handler,
 -	},
 -#endif
 -	 {
 -		.procname	= "hugetlb_shm_group",
 -		.data		= &sysctl_hugetlb_shm_group,
 -		.maxlen		= sizeof(gid_t),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	 },
 -	{
 -		.procname	= "nr_overcommit_hugepages",
 -		.data		= NULL,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= hugetlb_overcommit_handler,
 -	},
 -#endif
 -	{
 -		.procname	= "lowmem_reserve_ratio",
 -		.data		= &sysctl_lowmem_reserve_ratio,
 -		.maxlen		= sizeof(sysctl_lowmem_reserve_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= lowmem_reserve_ratio_sysctl_handler,
 -	},
 -	{
 -		.procname	= "drop_caches",
 -		.data		= &sysctl_drop_caches,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0200,
 -		.proc_handler	= drop_caches_sysctl_handler,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= SYSCTL_FOUR,
 -	},
 -#ifdef CONFIG_COMPACTION
 -	{
 -		.procname	= "compact_memory",
 -		.data		= NULL,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0200,
 -		.proc_handler	= sysctl_compaction_handler,
 -	},
 -	{
 -		.procname	= "compaction_proactiveness",
 -		.data		= &sysctl_compaction_proactiveness,
 -		.maxlen		= sizeof(sysctl_compaction_proactiveness),
 -		.mode		= 0644,
 -		.proc_handler	= compaction_proactiveness_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE_HUNDRED,
 -	},
 -	{
 -		.procname	= "extfrag_threshold",
 -		.data		= &sysctl_extfrag_threshold,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE_THOUSAND,
 -	},
 -	{
 -		.procname	= "compact_unevictable_allowed",
 -		.data		= &sysctl_compact_unevictable_allowed,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax_warn_RT_change,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 +	tmp = pid_vnr(cad_pid);
 +
 +	r = __do_proc_dointvec(&tmp, table, write, buffer,
 +			       lenp, ppos, NULL, NULL);
 +	if (r || !write)
 +		return r;
 +
 +	new_pid = find_get_pid(tmp);
 +	if (!new_pid)
 +		return -ESRCH;
 +
 +	put_pid(xchg(&cad_pid, new_pid));
 +	return 0;
 +}
 +
 +/**
 + * proc_do_large_bitmap - read/write from/to a large bitmap
 + * @table: the sysctl table
 + * @write: %TRUE if this is a write to the sysctl file
 + * @buffer: the user buffer
 + * @lenp: the size of the user buffer
 + * @ppos: file position
 + *
 + * The bitmap is stored at table->data and the bitmap length (in bits)
 + * in table->maxlen.
 + *
 + * We use a range comma separated format (e.g. 1,3-4,10-10) so that
 + * large bitmaps may be represented in a compact manner. Writing into
 + * the file will clear the bitmap then update it with the given input.
 + *
 + * Returns 0 on success.
 + */
 +int proc_do_large_bitmap(struct ctl_table *table, int write,
 +			 void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	int err = 0;
 +	bool first = 1;
 +	size_t left = *lenp;
 +	unsigned long bitmap_len = table->maxlen;
 +	unsigned long *bitmap = (unsigned long *) table->data;
 +	unsigned long *tmp_bitmap = NULL;
 +	char tr_a[] = { '-', ',', '\n' }, tr_b[] = { ',', '\n', 0 }, c;
 +
 +	if (!bitmap_len || !left || (*ppos && !write)) {
 +		*lenp = 0;
 +		return 0;
 +	}
 +
 +	if (write) {
 +		unsigned long page = 0;
 +		char *kbuf;
 +		size_t skipped = 0;
 +
 +		if (left > PAGE_SIZE - 1) {
 +			left = PAGE_SIZE - 1;
 +			/* How much of the buffer we'll skip this pass */
 +			skipped = *lenp - left;
 +		}
 +
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			free_page(page);
 +			return -EFAULT;
 +                }
 +		kbuf[left] = 0;
 +
 +		tmp_bitmap = kzalloc(BITS_TO_LONGS(bitmap_len) * sizeof(unsigned long),
 +				     GFP_KERNEL);
 +		if (!tmp_bitmap) {
 +			free_page(page);
 +			return -ENOMEM;
 +		}
 +		proc_skip_char(&kbuf, &left, '\n');
 +		while (!err && left) {
 +			unsigned long val_a, val_b;
 +			bool neg;
 +			size_t saved_left;
 +
 +			/* In case we stop parsing mid-number, we can reset */
 +			saved_left = left;
 +			err = proc_get_long(&kbuf, &left, &val_a, &neg, tr_a,
 +					     sizeof(tr_a), &c);
 +			/*
 +			 * If we consumed the entirety of a truncated buffer or
 +			 * only one char is left (may be a "-"), then stop here,
 +			 * reset, & come back for more.
 +			 */
 +			if ((left <= 1) && skipped) {
 +				left = saved_left;
 +				break;
 +			}
 +
 +			if (err)
 +				break;
 +			if (val_a >= bitmap_len || neg) {
 +				err = -EINVAL;
 +				break;
 +			}
 +
 +			val_b = val_a;
 +			if (left) {
 +				kbuf++;
 +				left--;
 +			}
 +
 +			if (c == '-') {
 +				err = proc_get_long(&kbuf, &left, &val_b,
 +						     &neg, tr_b, sizeof(tr_b),
 +						     &c);
 +				/*
 +				 * If we consumed all of a truncated buffer or
 +				 * then stop here, reset, & come back for more.
 +				 */
 +				if (!left && skipped) {
 +					left = saved_left;
 +					break;
 +				}
 +
 +				if (err)
 +					break;
 +				if (val_b >= bitmap_len || neg ||
 +				    val_a > val_b) {
 +					err = -EINVAL;
 +					break;
 +				}
 +				if (left) {
 +					kbuf++;
 +					left--;
 +				}
 +			}
 +
 +			bitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);
 +			first = 0;
 +			proc_skip_char(&kbuf, &left, '\n');
 +		}
 +		free_page(page);
 +		left += skipped;
 +	} else {
 +		unsigned long bit_a, bit_b = 0;
 +
 +		while (left) {
 +			bit_a = find_next_bit(bitmap, bitmap_len, bit_b);
 +			if (bit_a >= bitmap_len)
 +				break;
 +			bit_b = find_next_zero_bit(bitmap, bitmap_len,
 +						   bit_a + 1) - 1;
 +
 +			if (!first) {
 +				err = proc_put_char(&buffer, &left, ',');
 +				if (err)
 +					break;
 +			}
 +			err = proc_put_long(&buffer, &left, bit_a, false);
 +			if (err)
 +				break;
 +			if (bit_a != bit_b) {
 +				err = proc_put_char(&buffer, &left, '-');
 +				if (err)
 +					break;
 +				err = proc_put_long(&buffer, &left, bit_b, false);
 +				if (err)
 +					break;
 +			}
 +
 +			first = 0; bit_b++;
 +		}
 +		if (!err)
 +			err = proc_put_char(&buffer, &left, '\n');
 +	}
 +
 +	if (!err) {
 +		if (write) {
 +			if (*ppos)
 +				bitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);
 +			else
 +				bitmap_copy(bitmap, tmp_bitmap, bitmap_len);
 +		}
 +		kfree(tmp_bitmap);
 +		*lenp -= left;
 +		*ppos += *lenp;
 +		return 0;
 +	} else {
 +		kfree(tmp_bitmap);
 +		return err;
 +	}
 +}
  
 -#endif /* CONFIG_COMPACTION */
 -	{
 -		.procname	= "min_free_kbytes",
 -		.data		= &min_free_kbytes,
 -		.maxlen		= sizeof(min_free_kbytes),
 -		.mode		= 0644,
 -		.proc_handler	= min_free_kbytes_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "watermark_boost_factor",
 -		.data		= &watermark_boost_factor,
 -		.maxlen		= sizeof(watermark_boost_factor),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "watermark_scale_factor",
 -		.data		= &watermark_scale_factor,
 -		.maxlen		= sizeof(watermark_scale_factor),
 -		.mode		= 0644,
 -		.proc_handler	= watermark_scale_factor_sysctl_handler,
 -		.extra1		= SYSCTL_ONE,
 -		.extra2		= SYSCTL_THREE_THOUSAND,
 -	},
 -	{
 -		.procname	= "percpu_pagelist_high_fraction",
 -		.data		= &percpu_pagelist_high_fraction,
 -		.maxlen		= sizeof(percpu_pagelist_high_fraction),
 -		.mode		= 0644,
 -		.proc_handler	= percpu_pagelist_high_fraction_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "page_lock_unfairness",
 -		.data		= &sysctl_page_lock_unfairness,
 -		.maxlen		= sizeof(sysctl_page_lock_unfairness),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#ifdef CONFIG_MMU
 -	{
 -		.procname	= "max_map_count",
 -		.data		= &sysctl_max_map_count,
 -		.maxlen		= sizeof(sysctl_max_map_count),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#else
 -	{
 -		.procname	= "nr_trim_pages",
 -		.data		= &sysctl_nr_trim_pages,
 -		.maxlen		= sizeof(sysctl_nr_trim_pages),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#endif
 -	{
 -		.procname	= "vfs_cache_pressure",
 -		.data		= &sysctl_vfs_cache_pressure,
 -		.maxlen		= sizeof(sysctl_vfs_cache_pressure),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#if defined(HAVE_ARCH_PICK_MMAP_LAYOUT) || \
 -    defined(CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT)
 -	{
 -		.procname	= "legacy_va_layout",
 -		.data		= &sysctl_legacy_va_layout,
 -		.maxlen		= sizeof(sysctl_legacy_va_layout),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#endif
 -#ifdef CONFIG_NUMA
 -	{
 -		.procname	= "zone_reclaim_mode",
 -		.data		= &node_reclaim_mode,
 -		.maxlen		= sizeof(node_reclaim_mode),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -	{
 -		.procname	= "min_unmapped_ratio",
 -		.data		= &sysctl_min_unmapped_ratio,
 -		.maxlen		= sizeof(sysctl_min_unmapped_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= sysctl_min_unmapped_ratio_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE_HUNDRED,
 -	},
 -	{
 -		.procname	= "min_slab_ratio",
 -		.data		= &sysctl_min_slab_ratio,
 -		.maxlen		= sizeof(sysctl_min_slab_ratio),
 -		.mode		= 0644,
 -		.proc_handler	= sysctl_min_slab_ratio_sysctl_handler,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE_HUNDRED,
 -	},
 -#endif
 -#ifdef CONFIG_SMP
 -	{
 -		.procname	= "stat_interval",
 -		.data		= &sysctl_stat_interval,
 -		.maxlen		= sizeof(sysctl_stat_interval),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_jiffies,
 -	},
 -	{
 -		.procname	= "stat_refresh",
 -		.data		= NULL,
 -		.maxlen		= 0,
 -		.mode		= 0600,
 -		.proc_handler	= vmstat_refresh,
 -	},
 -#endif
 -#ifdef CONFIG_MMU
 -	{
 -		.procname	= "mmap_min_addr",
 -		.data		= &dac_mmap_min_addr,
 -		.maxlen		= sizeof(unsigned long),
 -		.mode		= 0644,
 -		.proc_handler	= mmap_min_addr_handler,
 -	},
 -#endif
 -#ifdef CONFIG_NUMA
 -	{
 -		.procname	= "numa_zonelist_order",
 -		.data		= &numa_zonelist_order,
 -		.maxlen		= NUMA_ZONELIST_ORDER_LEN,
 -		.mode		= 0644,
 -		.proc_handler	= numa_zonelist_order_handler,
 -	},
 -#endif
 -#if (defined(CONFIG_X86_32) && !defined(CONFIG_UML))|| \
 -   (defined(CONFIG_SUPERH) && defined(CONFIG_VSYSCALL))
 -	{
 -		.procname	= "vdso_enabled",
 -#ifdef CONFIG_X86_32
 -		.data		= &vdso32_enabled,
 -		.maxlen		= sizeof(vdso32_enabled),
 -#else
 -		.data		= &vdso_enabled,
 -		.maxlen		= sizeof(vdso_enabled),
 -#endif
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -		.extra1		= SYSCTL_ZERO,
 -	},
 -#endif
 -#ifdef CONFIG_MEMORY_FAILURE
 -	{
 -		.procname	= "memory_failure_early_kill",
 -		.data		= &sysctl_memory_failure_early_kill,
 -		.maxlen		= sizeof(sysctl_memory_failure_early_kill),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -	{
 -		.procname	= "memory_failure_recovery",
 -		.data		= &sysctl_memory_failure_recovery,
 -		.maxlen		= sizeof(sysctl_memory_failure_recovery),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -	{
 -		.procname	= "user_reserve_kbytes",
 -		.data		= &sysctl_user_reserve_kbytes,
 -		.maxlen		= sizeof(sysctl_user_reserve_kbytes),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -	{
 -		.procname	= "admin_reserve_kbytes",
 -		.data		= &sysctl_admin_reserve_kbytes,
 -		.maxlen		= sizeof(sysctl_admin_reserve_kbytes),
 -		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
 -	},
 -#ifdef CONFIG_HAVE_ARCH_MMAP_RND_BITS
 -	{
 -		.procname	= "mmap_rnd_bits",
 -		.data		= &mmap_rnd_bits,
 -		.maxlen		= sizeof(mmap_rnd_bits),
 -		.mode		= 0600,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= (void *)&mmap_rnd_bits_min,
 -		.extra2		= (void *)&mmap_rnd_bits_max,
 -	},
 -#endif
 -#ifdef CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS
 -	{
 -		.procname	= "mmap_rnd_compat_bits",
 -		.data		= &mmap_rnd_compat_bits,
 -		.maxlen		= sizeof(mmap_rnd_compat_bits),
 -		.mode		= 0600,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= (void *)&mmap_rnd_compat_bits_min,
 -		.extra2		= (void *)&mmap_rnd_compat_bits_max,
 -	},
 -#endif
 -#ifdef CONFIG_USERFAULTFD
 -	{
 -		.procname	= "unprivileged_userfaultfd",
 -		.data		= &sysctl_unprivileged_userfaultfd,
 -		.maxlen		= sizeof(sysctl_unprivileged_userfaultfd),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= SYSCTL_ZERO,
 -		.extra2		= SYSCTL_ONE,
 -	},
 -#endif
 -	{ }
 -};
 +#else /* CONFIG_PROC_SYSCTL */
  
 -static struct ctl_table debug_table[] = {
 -#ifdef CONFIG_SYSCTL_EXCEPTION_TRACE
 -	{
 -		.procname	= "exception-trace",
 -		.data		= &show_unhandled_signals,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec
 -	},
 -#endif
 -	{ }
 -};
 +int proc_dostring(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
  
 -static struct ctl_table dev_table[] = {
 -	{ }
 -};
 +int proc_dointvec(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
  
 -DECLARE_SYSCTL_BASE(kernel, kern_table);
 -DECLARE_SYSCTL_BASE(vm, vm_table);
 -DECLARE_SYSCTL_BASE(debug, debug_table);
 -DECLARE_SYSCTL_BASE(dev, dev_table);
 +int proc_douintvec(struct ctl_table *table, int write,
 +		  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
  
 -int __init sysctl_init_bases(void)
 +int proc_dointvec_minmax(struct ctl_table *table, int write,
 +		    void __user *buffer, size_t *lenp, loff_t *ppos)
  {
 -	register_sysctl_base(kernel);
 -	register_sysctl_base(vm);
 -	register_sysctl_base(debug);
 -	register_sysctl_base(dev);
 +	return -ENOSYS;
 +}
  
 -	return 0;
 +int proc_douintvec_minmax(struct ctl_table *table, int write,
 +			  void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
  }
 -#endif /* CONFIG_SYSCTL */
 +
 +int proc_dopipe_max_size(struct ctl_table *table, int write,
 +			 void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_dointvec_jiffies(struct ctl_table *table, int write,
 +		    void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
 +		    void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,
 +			     void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_doulongvec_minmax(struct ctl_table *table, int write,
 +		    void __user *buffer, size_t *lenp, loff_t *ppos)
 +{
 +	return -ENOSYS;
 +}
 +
 +int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
 +				      void __user *buffer,
 +				      size_t *lenp, loff_t *ppos)
 +{
 +    return -ENOSYS;
 +}
 +
 +
 +#endif /* CONFIG_PROC_SYSCTL */
 +
  /*
   * No sense putting this after each symbol definition, twice,
   * exception granted :-)
* Unmerged path kernel/sysctl.c
