SUNRPC: Remove redundant check for the reply length in call_decode()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 5e3863fd597eba8c6679de805681631b1aad9bdb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5e3863fd.failed

Now that we're using the xdr_stream functions to decode the header,
the test for the minimum reply length is redundant.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 5e3863fd597eba8c6679de805681631b1aad9bdb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 4c9385209a04,228970e6e52b..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -2292,39 -2392,28 +2292,61 @@@ call_decode(struct rpc_task *task
  	WARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,
  				sizeof(req->rq_rcv_buf)) != 0);
  
++<<<<<<< HEAD
 +	if (req->rq_rcv_buf.len < 12) {
 +		if (!RPC_IS_SOFT(task)) {
 +			task->tk_action = call_bind;
 +			goto out_retry;
++=======
+ 	xdr_init_decode(&xdr, &req->rq_rcv_buf,
+ 			req->rq_rcv_buf.head[0].iov_base, req);
+ 	switch (rpc_decode_header(task, &xdr)) {
+ 	case 0:
+ 		task->tk_action = rpc_exit_task;
+ 		task->tk_status = rpcauth_unwrap_resp(task, &xdr);
+ 		dprintk("RPC: %5u %s result %d\n",
+ 			task->tk_pid, __func__, task->tk_status);
+ 		return;
+ 	case -EAGAIN:
+ 		task->tk_status = 0;
+ 		/* Note: rpc_decode_header() may have freed the RPC slot */
+ 		if (task->tk_rqstp == req) {
+ 			xdr_free_bvec(&req->rq_rcv_buf);
+ 			req->rq_reply_bytes_recvd = 0;
+ 			req->rq_rcv_buf.len = 0;
+ 			if (task->tk_client->cl_discrtry)
+ 				xprt_conditional_disconnect(req->rq_xprt,
+ 							    req->rq_connect_cookie);
++>>>>>>> 5e3863fd597e (SUNRPC: Remove redundant check for the reply length in call_decode())
  		}
 -		task->tk_action = call_encode;
 -		rpc_check_timeout(task);
 +		dprintk("RPC:       %s: too small RPC reply size (%d bytes)\n",
 +				clnt->cl_program->name, task->tk_status);
 +		task->tk_action = call_timeout;
 +		goto out_retry;
 +	}
 +
 +	p = rpc_verify_header(task);
 +	if (IS_ERR(p)) {
 +		if (p == ERR_PTR(-EAGAIN))
 +			goto out_retry;
 +		return;
 +	}
 +	task->tk_action = rpc_exit_task;
 +
 +	task->tk_status = rpcauth_unwrap_resp(task, decode, req, p,
 +					      task->tk_msg.rpc_resp);
 +
 +	dprintk("RPC: %5u call_decode result %d\n", task->tk_pid,
 +			task->tk_status);
 +	return;
 +out_retry:
 +	task->tk_status = 0;
 +	/* Note: rpc_verify_header() may have freed the RPC slot */
 +	if (task->tk_rqstp == req) {
 +		req->rq_reply_bytes_recvd = req->rq_rcv_buf.len = 0;
 +		if (task->tk_client->cl_discrtry)
 +			xprt_conditional_disconnect(req->rq_xprt,
 +					req->rq_connect_cookie);
  	}
  }
  
* Unmerged path net/sunrpc/clnt.c
