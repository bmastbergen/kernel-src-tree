libbpf: Fix realloc usage in bpf_core_find_cands

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 35b9211c0a2427e8f39e534f442f43804fc8d5ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/35b9211c.failed

Fix bug requesting invalid size of reallocated array when constructing CO-RE
relocation candidate list. This can cause problems if there are many potential
candidates and a very fine-grained memory allocator bucket sizes are used.

Fixes: ddc7c3042614 ("libbpf: implement BPF CO-RE offset relocation algorithm")
	Reported-by: William Smith <williampsmith@fb.com>
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Yonghong Song <yhs@fb.com>
Link: https://lore.kernel.org/bpf/20200124201847.212528-1-andriin@fb.com
(cherry picked from commit 35b9211c0a2427e8f39e534f442f43804fc8d5ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index f4c01aa6f359,514b1a524abb..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -2304,6 -3612,1031 +2304,1034 @@@ bpf_program_reloc_btf_ext(struct bpf_pr
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #define BPF_CORE_SPEC_MAX_LEN 64
+ 
+ /* represents BPF CO-RE field or array element accessor */
+ struct bpf_core_accessor {
+ 	__u32 type_id;		/* struct/union type or array element type */
+ 	__u32 idx;		/* field index or array index */
+ 	const char *name;	/* field name or NULL for array accessor */
+ };
+ 
+ struct bpf_core_spec {
+ 	const struct btf *btf;
+ 	/* high-level spec: named fields and array indices only */
+ 	struct bpf_core_accessor spec[BPF_CORE_SPEC_MAX_LEN];
+ 	/* high-level spec length */
+ 	int len;
+ 	/* raw, low-level spec: 1-to-1 with accessor spec string */
+ 	int raw_spec[BPF_CORE_SPEC_MAX_LEN];
+ 	/* raw spec length */
+ 	int raw_len;
+ 	/* field bit offset represented by spec */
+ 	__u32 bit_offset;
+ };
+ 
+ static bool str_is_empty(const char *s)
+ {
+ 	return !s || !s[0];
+ }
+ 
+ static bool is_flex_arr(const struct btf *btf,
+ 			const struct bpf_core_accessor *acc,
+ 			const struct btf_array *arr)
+ {
+ 	const struct btf_type *t;
+ 
+ 	/* not a flexible array, if not inside a struct or has non-zero size */
+ 	if (!acc->name || arr->nelems > 0)
+ 		return false;
+ 
+ 	/* has to be the last member of enclosing struct */
+ 	t = btf__type_by_id(btf, acc->type_id);
+ 	return acc->idx == btf_vlen(t) - 1;
+ }
+ 
+ /*
+  * Turn bpf_field_reloc into a low- and high-level spec representation,
+  * validating correctness along the way, as well as calculating resulting
+  * field bit offset, specified by accessor string. Low-level spec captures
+  * every single level of nestedness, including traversing anonymous
+  * struct/union members. High-level one only captures semantically meaningful
+  * "turning points": named fields and array indicies.
+  * E.g., for this case:
+  *
+  *   struct sample {
+  *       int __unimportant;
+  *       struct {
+  *           int __1;
+  *           int __2;
+  *           int a[7];
+  *       };
+  *   };
+  *
+  *   struct sample *s = ...;
+  *
+  *   int x = &s->a[3]; // access string = '0:1:2:3'
+  *
+  * Low-level spec has 1:1 mapping with each element of access string (it's
+  * just a parsed access string representation): [0, 1, 2, 3].
+  *
+  * High-level spec will capture only 3 points:
+  *   - intial zero-index access by pointer (&s->... is the same as &s[0]...);
+  *   - field 'a' access (corresponds to '2' in low-level spec);
+  *   - array element #3 access (corresponds to '3' in low-level spec).
+  *
+  */
+ static int bpf_core_spec_parse(const struct btf *btf,
+ 			       __u32 type_id,
+ 			       const char *spec_str,
+ 			       struct bpf_core_spec *spec)
+ {
+ 	int access_idx, parsed_len, i;
+ 	struct bpf_core_accessor *acc;
+ 	const struct btf_type *t;
+ 	const char *name;
+ 	__u32 id;
+ 	__s64 sz;
+ 
+ 	if (str_is_empty(spec_str) || *spec_str == ':')
+ 		return -EINVAL;
+ 
+ 	memset(spec, 0, sizeof(*spec));
+ 	spec->btf = btf;
+ 
+ 	/* parse spec_str="0:1:2:3:4" into array raw_spec=[0, 1, 2, 3, 4] */
+ 	while (*spec_str) {
+ 		if (*spec_str == ':')
+ 			++spec_str;
+ 		if (sscanf(spec_str, "%d%n", &access_idx, &parsed_len) != 1)
+ 			return -EINVAL;
+ 		if (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)
+ 			return -E2BIG;
+ 		spec_str += parsed_len;
+ 		spec->raw_spec[spec->raw_len++] = access_idx;
+ 	}
+ 
+ 	if (spec->raw_len == 0)
+ 		return -EINVAL;
+ 
+ 	/* first spec value is always reloc type array index */
+ 	t = skip_mods_and_typedefs(btf, type_id, &id);
+ 	if (!t)
+ 		return -EINVAL;
+ 
+ 	access_idx = spec->raw_spec[0];
+ 	spec->spec[0].type_id = id;
+ 	spec->spec[0].idx = access_idx;
+ 	spec->len++;
+ 
+ 	sz = btf__resolve_size(btf, id);
+ 	if (sz < 0)
+ 		return sz;
+ 	spec->bit_offset = access_idx * sz * 8;
+ 
+ 	for (i = 1; i < spec->raw_len; i++) {
+ 		t = skip_mods_and_typedefs(btf, id, &id);
+ 		if (!t)
+ 			return -EINVAL;
+ 
+ 		access_idx = spec->raw_spec[i];
+ 		acc = &spec->spec[spec->len];
+ 
+ 		if (btf_is_composite(t)) {
+ 			const struct btf_member *m;
+ 			__u32 bit_offset;
+ 
+ 			if (access_idx >= btf_vlen(t))
+ 				return -EINVAL;
+ 
+ 			bit_offset = btf_member_bit_offset(t, access_idx);
+ 			spec->bit_offset += bit_offset;
+ 
+ 			m = btf_members(t) + access_idx;
+ 			if (m->name_off) {
+ 				name = btf__name_by_offset(btf, m->name_off);
+ 				if (str_is_empty(name))
+ 					return -EINVAL;
+ 
+ 				acc->type_id = id;
+ 				acc->idx = access_idx;
+ 				acc->name = name;
+ 				spec->len++;
+ 			}
+ 
+ 			id = m->type;
+ 		} else if (btf_is_array(t)) {
+ 			const struct btf_array *a = btf_array(t);
+ 			bool flex;
+ 
+ 			t = skip_mods_and_typedefs(btf, a->type, &id);
+ 			if (!t)
+ 				return -EINVAL;
+ 
+ 			flex = is_flex_arr(btf, acc - 1, a);
+ 			if (!flex && access_idx >= a->nelems)
+ 				return -EINVAL;
+ 
+ 			spec->spec[spec->len].type_id = id;
+ 			spec->spec[spec->len].idx = access_idx;
+ 			spec->len++;
+ 
+ 			sz = btf__resolve_size(btf, id);
+ 			if (sz < 0)
+ 				return sz;
+ 			spec->bit_offset += access_idx * sz * 8;
+ 		} else {
+ 			pr_warn("relo for [%u] %s (at idx %d) captures type [%d] of unexpected kind %d\n",
+ 				type_id, spec_str, i, id, btf_kind(t));
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static bool bpf_core_is_flavor_sep(const char *s)
+ {
+ 	/* check X___Y name pattern, where X and Y are not underscores */
+ 	return s[0] != '_' &&				      /* X */
+ 	       s[1] == '_' && s[2] == '_' && s[3] == '_' &&   /* ___ */
+ 	       s[4] != '_';				      /* Y */
+ }
+ 
+ /* Given 'some_struct_name___with_flavor' return the length of a name prefix
+  * before last triple underscore. Struct name part after last triple
+  * underscore is ignored by BPF CO-RE relocation during relocation matching.
+  */
+ static size_t bpf_core_essential_name_len(const char *name)
+ {
+ 	size_t n = strlen(name);
+ 	int i;
+ 
+ 	for (i = n - 5; i >= 0; i--) {
+ 		if (bpf_core_is_flavor_sep(name + i))
+ 			return i + 1;
+ 	}
+ 	return n;
+ }
+ 
+ /* dynamically sized list of type IDs */
+ struct ids_vec {
+ 	__u32 *data;
+ 	int len;
+ };
+ 
+ static void bpf_core_free_cands(struct ids_vec *cand_ids)
+ {
+ 	free(cand_ids->data);
+ 	free(cand_ids);
+ }
+ 
+ static struct ids_vec *bpf_core_find_cands(const struct btf *local_btf,
+ 					   __u32 local_type_id,
+ 					   const struct btf *targ_btf)
+ {
+ 	size_t local_essent_len, targ_essent_len;
+ 	const char *local_name, *targ_name;
+ 	const struct btf_type *t;
+ 	struct ids_vec *cand_ids;
+ 	__u32 *new_ids;
+ 	int i, err, n;
+ 
+ 	t = btf__type_by_id(local_btf, local_type_id);
+ 	if (!t)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	local_name = btf__name_by_offset(local_btf, t->name_off);
+ 	if (str_is_empty(local_name))
+ 		return ERR_PTR(-EINVAL);
+ 	local_essent_len = bpf_core_essential_name_len(local_name);
+ 
+ 	cand_ids = calloc(1, sizeof(*cand_ids));
+ 	if (!cand_ids)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	n = btf__get_nr_types(targ_btf);
+ 	for (i = 1; i <= n; i++) {
+ 		t = btf__type_by_id(targ_btf, i);
+ 		targ_name = btf__name_by_offset(targ_btf, t->name_off);
+ 		if (str_is_empty(targ_name))
+ 			continue;
+ 
+ 		targ_essent_len = bpf_core_essential_name_len(targ_name);
+ 		if (targ_essent_len != local_essent_len)
+ 			continue;
+ 
+ 		if (strncmp(local_name, targ_name, local_essent_len) == 0) {
+ 			pr_debug("[%d] %s: found candidate [%d] %s\n",
+ 				 local_type_id, local_name, i, targ_name);
+ 			new_ids = reallocarray(cand_ids->data,
+ 					       cand_ids->len + 1,
+ 					       sizeof(*cand_ids->data));
+ 			if (!new_ids) {
+ 				err = -ENOMEM;
+ 				goto err_out;
+ 			}
+ 			cand_ids->data = new_ids;
+ 			cand_ids->data[cand_ids->len++] = i;
+ 		}
+ 	}
+ 	return cand_ids;
+ err_out:
+ 	bpf_core_free_cands(cand_ids);
+ 	return ERR_PTR(err);
+ }
+ 
+ /* Check two types for compatibility, skipping const/volatile/restrict and
+  * typedefs, to ensure we are relocating compatible entities:
+  *   - any two STRUCTs/UNIONs are compatible and can be mixed;
+  *   - any two FWDs are compatible, if their names match (modulo flavor suffix);
+  *   - any two PTRs are always compatible;
+  *   - for ENUMs, names should be the same (ignoring flavor suffix) or at
+  *     least one of enums should be anonymous;
+  *   - for ENUMs, check sizes, names are ignored;
+  *   - for INT, size and signedness are ignored;
+  *   - for ARRAY, dimensionality is ignored, element types are checked for
+  *     compatibility recursively;
+  *   - everything else shouldn't be ever a target of relocation.
+  * These rules are not set in stone and probably will be adjusted as we get
+  * more experience with using BPF CO-RE relocations.
+  */
+ static int bpf_core_fields_are_compat(const struct btf *local_btf,
+ 				      __u32 local_id,
+ 				      const struct btf *targ_btf,
+ 				      __u32 targ_id)
+ {
+ 	const struct btf_type *local_type, *targ_type;
+ 
+ recur:
+ 	local_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);
+ 	targ_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
+ 	if (!local_type || !targ_type)
+ 		return -EINVAL;
+ 
+ 	if (btf_is_composite(local_type) && btf_is_composite(targ_type))
+ 		return 1;
+ 	if (btf_kind(local_type) != btf_kind(targ_type))
+ 		return 0;
+ 
+ 	switch (btf_kind(local_type)) {
+ 	case BTF_KIND_PTR:
+ 		return 1;
+ 	case BTF_KIND_FWD:
+ 	case BTF_KIND_ENUM: {
+ 		const char *local_name, *targ_name;
+ 		size_t local_len, targ_len;
+ 
+ 		local_name = btf__name_by_offset(local_btf,
+ 						 local_type->name_off);
+ 		targ_name = btf__name_by_offset(targ_btf, targ_type->name_off);
+ 		local_len = bpf_core_essential_name_len(local_name);
+ 		targ_len = bpf_core_essential_name_len(targ_name);
+ 		/* one of them is anonymous or both w/ same flavor-less names */
+ 		return local_len == 0 || targ_len == 0 ||
+ 		       (local_len == targ_len &&
+ 			strncmp(local_name, targ_name, local_len) == 0);
+ 	}
+ 	case BTF_KIND_INT:
+ 		/* just reject deprecated bitfield-like integers; all other
+ 		 * integers are by default compatible between each other
+ 		 */
+ 		return btf_int_offset(local_type) == 0 &&
+ 		       btf_int_offset(targ_type) == 0;
+ 	case BTF_KIND_ARRAY:
+ 		local_id = btf_array(local_type)->type;
+ 		targ_id = btf_array(targ_type)->type;
+ 		goto recur;
+ 	default:
+ 		pr_warn("unexpected kind %d relocated, local [%d], target [%d]\n",
+ 			btf_kind(local_type), local_id, targ_id);
+ 		return 0;
+ 	}
+ }
+ 
+ /*
+  * Given single high-level named field accessor in local type, find
+  * corresponding high-level accessor for a target type. Along the way,
+  * maintain low-level spec for target as well. Also keep updating target
+  * bit offset.
+  *
+  * Searching is performed through recursive exhaustive enumeration of all
+  * fields of a struct/union. If there are any anonymous (embedded)
+  * structs/unions, they are recursively searched as well. If field with
+  * desired name is found, check compatibility between local and target types,
+  * before returning result.
+  *
+  * 1 is returned, if field is found.
+  * 0 is returned if no compatible field is found.
+  * <0 is returned on error.
+  */
+ static int bpf_core_match_member(const struct btf *local_btf,
+ 				 const struct bpf_core_accessor *local_acc,
+ 				 const struct btf *targ_btf,
+ 				 __u32 targ_id,
+ 				 struct bpf_core_spec *spec,
+ 				 __u32 *next_targ_id)
+ {
+ 	const struct btf_type *local_type, *targ_type;
+ 	const struct btf_member *local_member, *m;
+ 	const char *local_name, *targ_name;
+ 	__u32 local_id;
+ 	int i, n, found;
+ 
+ 	targ_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
+ 	if (!targ_type)
+ 		return -EINVAL;
+ 	if (!btf_is_composite(targ_type))
+ 		return 0;
+ 
+ 	local_id = local_acc->type_id;
+ 	local_type = btf__type_by_id(local_btf, local_id);
+ 	local_member = btf_members(local_type) + local_acc->idx;
+ 	local_name = btf__name_by_offset(local_btf, local_member->name_off);
+ 
+ 	n = btf_vlen(targ_type);
+ 	m = btf_members(targ_type);
+ 	for (i = 0; i < n; i++, m++) {
+ 		__u32 bit_offset;
+ 
+ 		bit_offset = btf_member_bit_offset(targ_type, i);
+ 
+ 		/* too deep struct/union/array nesting */
+ 		if (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)
+ 			return -E2BIG;
+ 
+ 		/* speculate this member will be the good one */
+ 		spec->bit_offset += bit_offset;
+ 		spec->raw_spec[spec->raw_len++] = i;
+ 
+ 		targ_name = btf__name_by_offset(targ_btf, m->name_off);
+ 		if (str_is_empty(targ_name)) {
+ 			/* embedded struct/union, we need to go deeper */
+ 			found = bpf_core_match_member(local_btf, local_acc,
+ 						      targ_btf, m->type,
+ 						      spec, next_targ_id);
+ 			if (found) /* either found or error */
+ 				return found;
+ 		} else if (strcmp(local_name, targ_name) == 0) {
+ 			/* matching named field */
+ 			struct bpf_core_accessor *targ_acc;
+ 
+ 			targ_acc = &spec->spec[spec->len++];
+ 			targ_acc->type_id = targ_id;
+ 			targ_acc->idx = i;
+ 			targ_acc->name = targ_name;
+ 
+ 			*next_targ_id = m->type;
+ 			found = bpf_core_fields_are_compat(local_btf,
+ 							   local_member->type,
+ 							   targ_btf, m->type);
+ 			if (!found)
+ 				spec->len--; /* pop accessor */
+ 			return found;
+ 		}
+ 		/* member turned out not to be what we looked for */
+ 		spec->bit_offset -= bit_offset;
+ 		spec->raw_len--;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Try to match local spec to a target type and, if successful, produce full
+  * target spec (high-level, low-level + bit offset).
+  */
+ static int bpf_core_spec_match(struct bpf_core_spec *local_spec,
+ 			       const struct btf *targ_btf, __u32 targ_id,
+ 			       struct bpf_core_spec *targ_spec)
+ {
+ 	const struct btf_type *targ_type;
+ 	const struct bpf_core_accessor *local_acc;
+ 	struct bpf_core_accessor *targ_acc;
+ 	int i, sz, matched;
+ 
+ 	memset(targ_spec, 0, sizeof(*targ_spec));
+ 	targ_spec->btf = targ_btf;
+ 
+ 	local_acc = &local_spec->spec[0];
+ 	targ_acc = &targ_spec->spec[0];
+ 
+ 	for (i = 0; i < local_spec->len; i++, local_acc++, targ_acc++) {
+ 		targ_type = skip_mods_and_typedefs(targ_spec->btf, targ_id,
+ 						   &targ_id);
+ 		if (!targ_type)
+ 			return -EINVAL;
+ 
+ 		if (local_acc->name) {
+ 			matched = bpf_core_match_member(local_spec->btf,
+ 							local_acc,
+ 							targ_btf, targ_id,
+ 							targ_spec, &targ_id);
+ 			if (matched <= 0)
+ 				return matched;
+ 		} else {
+ 			/* for i=0, targ_id is already treated as array element
+ 			 * type (because it's the original struct), for others
+ 			 * we should find array element type first
+ 			 */
+ 			if (i > 0) {
+ 				const struct btf_array *a;
+ 				bool flex;
+ 
+ 				if (!btf_is_array(targ_type))
+ 					return 0;
+ 
+ 				a = btf_array(targ_type);
+ 				flex = is_flex_arr(targ_btf, targ_acc - 1, a);
+ 				if (!flex && local_acc->idx >= a->nelems)
+ 					return 0;
+ 				if (!skip_mods_and_typedefs(targ_btf, a->type,
+ 							    &targ_id))
+ 					return -EINVAL;
+ 			}
+ 
+ 			/* too deep struct/union/array nesting */
+ 			if (targ_spec->raw_len == BPF_CORE_SPEC_MAX_LEN)
+ 				return -E2BIG;
+ 
+ 			targ_acc->type_id = targ_id;
+ 			targ_acc->idx = local_acc->idx;
+ 			targ_acc->name = NULL;
+ 			targ_spec->len++;
+ 			targ_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;
+ 			targ_spec->raw_len++;
+ 
+ 			sz = btf__resolve_size(targ_btf, targ_id);
+ 			if (sz < 0)
+ 				return sz;
+ 			targ_spec->bit_offset += local_acc->idx * sz * 8;
+ 		}
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static int bpf_core_calc_field_relo(const struct bpf_program *prog,
+ 				    const struct bpf_field_reloc *relo,
+ 				    const struct bpf_core_spec *spec,
+ 				    __u32 *val, bool *validate)
+ {
+ 	const struct bpf_core_accessor *acc = &spec->spec[spec->len - 1];
+ 	const struct btf_type *t = btf__type_by_id(spec->btf, acc->type_id);
+ 	__u32 byte_off, byte_sz, bit_off, bit_sz;
+ 	const struct btf_member *m;
+ 	const struct btf_type *mt;
+ 	bool bitfield;
+ 	__s64 sz;
+ 
+ 	/* a[n] accessor needs special handling */
+ 	if (!acc->name) {
+ 		if (relo->kind == BPF_FIELD_BYTE_OFFSET) {
+ 			*val = spec->bit_offset / 8;
+ 		} else if (relo->kind == BPF_FIELD_BYTE_SIZE) {
+ 			sz = btf__resolve_size(spec->btf, acc->type_id);
+ 			if (sz < 0)
+ 				return -EINVAL;
+ 			*val = sz;
+ 		} else {
+ 			pr_warn("prog '%s': relo %d at insn #%d can't be applied to array access\n",
+ 				bpf_program__title(prog, false),
+ 				relo->kind, relo->insn_off / 8);
+ 			return -EINVAL;
+ 		}
+ 		if (validate)
+ 			*validate = true;
+ 		return 0;
+ 	}
+ 
+ 	m = btf_members(t) + acc->idx;
+ 	mt = skip_mods_and_typedefs(spec->btf, m->type, NULL);
+ 	bit_off = spec->bit_offset;
+ 	bit_sz = btf_member_bitfield_size(t, acc->idx);
+ 
+ 	bitfield = bit_sz > 0;
+ 	if (bitfield) {
+ 		byte_sz = mt->size;
+ 		byte_off = bit_off / 8 / byte_sz * byte_sz;
+ 		/* figure out smallest int size necessary for bitfield load */
+ 		while (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {
+ 			if (byte_sz >= 8) {
+ 				/* bitfield can't be read with 64-bit read */
+ 				pr_warn("prog '%s': relo %d at insn #%d can't be satisfied for bitfield\n",
+ 					bpf_program__title(prog, false),
+ 					relo->kind, relo->insn_off / 8);
+ 				return -E2BIG;
+ 			}
+ 			byte_sz *= 2;
+ 			byte_off = bit_off / 8 / byte_sz * byte_sz;
+ 		}
+ 	} else {
+ 		sz = btf__resolve_size(spec->btf, m->type);
+ 		if (sz < 0)
+ 			return -EINVAL;
+ 		byte_sz = sz;
+ 		byte_off = spec->bit_offset / 8;
+ 		bit_sz = byte_sz * 8;
+ 	}
+ 
+ 	/* for bitfields, all the relocatable aspects are ambiguous and we
+ 	 * might disagree with compiler, so turn off validation of expected
+ 	 * value, except for signedness
+ 	 */
+ 	if (validate)
+ 		*validate = !bitfield;
+ 
+ 	switch (relo->kind) {
+ 	case BPF_FIELD_BYTE_OFFSET:
+ 		*val = byte_off;
+ 		break;
+ 	case BPF_FIELD_BYTE_SIZE:
+ 		*val = byte_sz;
+ 		break;
+ 	case BPF_FIELD_SIGNED:
+ 		/* enums will be assumed unsigned */
+ 		*val = btf_is_enum(mt) ||
+ 		       (btf_int_encoding(mt) & BTF_INT_SIGNED);
+ 		if (validate)
+ 			*validate = true; /* signedness is never ambiguous */
+ 		break;
+ 	case BPF_FIELD_LSHIFT_U64:
+ #if __BYTE_ORDER == __LITTLE_ENDIAN
+ 		*val = 64 - (bit_off + bit_sz - byte_off  * 8);
+ #else
+ 		*val = (8 - byte_sz) * 8 + (bit_off - byte_off * 8);
+ #endif
+ 		break;
+ 	case BPF_FIELD_RSHIFT_U64:
+ 		*val = 64 - bit_sz;
+ 		if (validate)
+ 			*validate = true; /* right shift is never ambiguous */
+ 		break;
+ 	case BPF_FIELD_EXISTS:
+ 	default:
+ 		pr_warn("prog '%s': unknown relo %d at insn #%d\n",
+ 			bpf_program__title(prog, false),
+ 			relo->kind, relo->insn_off / 8);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Patch relocatable BPF instruction.
+  *
+  * Patched value is determined by relocation kind and target specification.
+  * For field existence relocation target spec will be NULL if field is not
+  * found.
+  * Expected insn->imm value is determined using relocation kind and local
+  * spec, and is checked before patching instruction. If actual insn->imm value
+  * is wrong, bail out with error.
+  *
+  * Currently three kinds of BPF instructions are supported:
+  * 1. rX = <imm> (assignment with immediate operand);
+  * 2. rX += <imm> (arithmetic operations with immediate operand);
+  */
+ static int bpf_core_reloc_insn(struct bpf_program *prog,
+ 			       const struct bpf_field_reloc *relo,
+ 			       int relo_idx,
+ 			       const struct bpf_core_spec *local_spec,
+ 			       const struct bpf_core_spec *targ_spec)
+ {
+ 	__u32 orig_val, new_val;
+ 	struct bpf_insn *insn;
+ 	bool validate = true;
+ 	int insn_idx, err;
+ 	__u8 class;
+ 
+ 	if (relo->insn_off % sizeof(struct bpf_insn))
+ 		return -EINVAL;
+ 	insn_idx = relo->insn_off / sizeof(struct bpf_insn);
+ 	insn = &prog->insns[insn_idx];
+ 	class = BPF_CLASS(insn->code);
+ 
+ 	if (relo->kind == BPF_FIELD_EXISTS) {
+ 		orig_val = 1; /* can't generate EXISTS relo w/o local field */
+ 		new_val = targ_spec ? 1 : 0;
+ 	} else if (!targ_spec) {
+ 		pr_debug("prog '%s': relo #%d: substituting insn #%d w/ invalid insn\n",
+ 			 bpf_program__title(prog, false), relo_idx, insn_idx);
+ 		insn->code = BPF_JMP | BPF_CALL;
+ 		insn->dst_reg = 0;
+ 		insn->src_reg = 0;
+ 		insn->off = 0;
+ 		/* if this instruction is reachable (not a dead code),
+ 		 * verifier will complain with the following message:
+ 		 * invalid func unknown#195896080
+ 		 */
+ 		insn->imm = 195896080; /* => 0xbad2310 => "bad relo" */
+ 		return 0;
+ 	} else {
+ 		err = bpf_core_calc_field_relo(prog, relo, local_spec,
+ 					       &orig_val, &validate);
+ 		if (err)
+ 			return err;
+ 		err = bpf_core_calc_field_relo(prog, relo, targ_spec,
+ 					       &new_val, NULL);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	switch (class) {
+ 	case BPF_ALU:
+ 	case BPF_ALU64:
+ 		if (BPF_SRC(insn->code) != BPF_K)
+ 			return -EINVAL;
+ 		if (validate && insn->imm != orig_val) {
+ 			pr_warn("prog '%s': relo #%d: unexpected insn #%d (ALU/ALU64) value: got %u, exp %u -> %u\n",
+ 				bpf_program__title(prog, false), relo_idx,
+ 				insn_idx, insn->imm, orig_val, new_val);
+ 			return -EINVAL;
+ 		}
+ 		orig_val = insn->imm;
+ 		insn->imm = new_val;
+ 		pr_debug("prog '%s': relo #%d: patched insn #%d (ALU/ALU64) imm %u -> %u\n",
+ 			 bpf_program__title(prog, false), relo_idx, insn_idx,
+ 			 orig_val, new_val);
+ 		break;
+ 	case BPF_LDX:
+ 	case BPF_ST:
+ 	case BPF_STX:
+ 		if (validate && insn->off != orig_val) {
+ 			pr_warn("prog '%s': relo #%d: unexpected insn #%d (LD/LDX/ST/STX) value: got %u, exp %u -> %u\n",
+ 				bpf_program__title(prog, false), relo_idx,
+ 				insn_idx, insn->off, orig_val, new_val);
+ 			return -EINVAL;
+ 		}
+ 		if (new_val > SHRT_MAX) {
+ 			pr_warn("prog '%s': relo #%d: insn #%d (LDX/ST/STX) value too big: %u\n",
+ 				bpf_program__title(prog, false), relo_idx,
+ 				insn_idx, new_val);
+ 			return -ERANGE;
+ 		}
+ 		orig_val = insn->off;
+ 		insn->off = new_val;
+ 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) off %u -> %u\n",
+ 			 bpf_program__title(prog, false), relo_idx, insn_idx,
+ 			 orig_val, new_val);
+ 		break;
+ 	default:
+ 		pr_warn("prog '%s': relo #%d: trying to relocate unrecognized insn #%d, code:%x, src:%x, dst:%x, off:%x, imm:%x\n",
+ 			bpf_program__title(prog, false), relo_idx,
+ 			insn_idx, insn->code, insn->src_reg, insn->dst_reg,
+ 			insn->off, insn->imm);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* Output spec definition in the format:
+  * [<type-id>] (<type-name>) + <raw-spec> => <offset>@<spec>,
+  * where <spec> is a C-syntax view of recorded field access, e.g.: x.a[3].b
+  */
+ static void bpf_core_dump_spec(int level, const struct bpf_core_spec *spec)
+ {
+ 	const struct btf_type *t;
+ 	const char *s;
+ 	__u32 type_id;
+ 	int i;
+ 
+ 	type_id = spec->spec[0].type_id;
+ 	t = btf__type_by_id(spec->btf, type_id);
+ 	s = btf__name_by_offset(spec->btf, t->name_off);
+ 	libbpf_print(level, "[%u] %s + ", type_id, s);
+ 
+ 	for (i = 0; i < spec->raw_len; i++)
+ 		libbpf_print(level, "%d%s", spec->raw_spec[i],
+ 			     i == spec->raw_len - 1 ? " => " : ":");
+ 
+ 	libbpf_print(level, "%u.%u @ &x",
+ 		     spec->bit_offset / 8, spec->bit_offset % 8);
+ 
+ 	for (i = 0; i < spec->len; i++) {
+ 		if (spec->spec[i].name)
+ 			libbpf_print(level, ".%s", spec->spec[i].name);
+ 		else
+ 			libbpf_print(level, "[%u]", spec->spec[i].idx);
+ 	}
+ 
+ }
+ 
+ static size_t bpf_core_hash_fn(const void *key, void *ctx)
+ {
+ 	return (size_t)key;
+ }
+ 
+ static bool bpf_core_equal_fn(const void *k1, const void *k2, void *ctx)
+ {
+ 	return k1 == k2;
+ }
+ 
+ static void *u32_as_hash_key(__u32 x)
+ {
+ 	return (void *)(uintptr_t)x;
+ }
+ 
+ /*
+  * CO-RE relocate single instruction.
+  *
+  * The outline and important points of the algorithm:
+  * 1. For given local type, find corresponding candidate target types.
+  *    Candidate type is a type with the same "essential" name, ignoring
+  *    everything after last triple underscore (___). E.g., `sample`,
+  *    `sample___flavor_one`, `sample___flavor_another_one`, are all candidates
+  *    for each other. Names with triple underscore are referred to as
+  *    "flavors" and are useful, among other things, to allow to
+  *    specify/support incompatible variations of the same kernel struct, which
+  *    might differ between different kernel versions and/or build
+  *    configurations.
+  *
+  *    N.B. Struct "flavors" could be generated by bpftool's BTF-to-C
+  *    converter, when deduplicated BTF of a kernel still contains more than
+  *    one different types with the same name. In that case, ___2, ___3, etc
+  *    are appended starting from second name conflict. But start flavors are
+  *    also useful to be defined "locally", in BPF program, to extract same
+  *    data from incompatible changes between different kernel
+  *    versions/configurations. For instance, to handle field renames between
+  *    kernel versions, one can use two flavors of the struct name with the
+  *    same common name and use conditional relocations to extract that field,
+  *    depending on target kernel version.
+  * 2. For each candidate type, try to match local specification to this
+  *    candidate target type. Matching involves finding corresponding
+  *    high-level spec accessors, meaning that all named fields should match,
+  *    as well as all array accesses should be within the actual bounds. Also,
+  *    types should be compatible (see bpf_core_fields_are_compat for details).
+  * 3. It is supported and expected that there might be multiple flavors
+  *    matching the spec. As long as all the specs resolve to the same set of
+  *    offsets across all candidates, there is no error. If there is any
+  *    ambiguity, CO-RE relocation will fail. This is necessary to accomodate
+  *    imprefection of BTF deduplication, which can cause slight duplication of
+  *    the same BTF type, if some directly or indirectly referenced (by
+  *    pointer) type gets resolved to different actual types in different
+  *    object files. If such situation occurs, deduplicated BTF will end up
+  *    with two (or more) structurally identical types, which differ only in
+  *    types they refer to through pointer. This should be OK in most cases and
+  *    is not an error.
+  * 4. Candidate types search is performed by linearly scanning through all
+  *    types in target BTF. It is anticipated that this is overall more
+  *    efficient memory-wise and not significantly worse (if not better)
+  *    CPU-wise compared to prebuilding a map from all local type names to
+  *    a list of candidate type names. It's also sped up by caching resolved
+  *    list of matching candidates per each local "root" type ID, that has at
+  *    least one bpf_field_reloc associated with it. This list is shared
+  *    between multiple relocations for the same type ID and is updated as some
+  *    of the candidates are pruned due to structural incompatibility.
+  */
+ static int bpf_core_reloc_field(struct bpf_program *prog,
+ 				 const struct bpf_field_reloc *relo,
+ 				 int relo_idx,
+ 				 const struct btf *local_btf,
+ 				 const struct btf *targ_btf,
+ 				 struct hashmap *cand_cache)
+ {
+ 	const char *prog_name = bpf_program__title(prog, false);
+ 	struct bpf_core_spec local_spec, cand_spec, targ_spec;
+ 	const void *type_key = u32_as_hash_key(relo->type_id);
+ 	const struct btf_type *local_type, *cand_type;
+ 	const char *local_name, *cand_name;
+ 	struct ids_vec *cand_ids;
+ 	__u32 local_id, cand_id;
+ 	const char *spec_str;
+ 	int i, j, err;
+ 
+ 	local_id = relo->type_id;
+ 	local_type = btf__type_by_id(local_btf, local_id);
+ 	if (!local_type)
+ 		return -EINVAL;
+ 
+ 	local_name = btf__name_by_offset(local_btf, local_type->name_off);
+ 	if (str_is_empty(local_name))
+ 		return -EINVAL;
+ 
+ 	spec_str = btf__name_by_offset(local_btf, relo->access_str_off);
+ 	if (str_is_empty(spec_str))
+ 		return -EINVAL;
+ 
+ 	err = bpf_core_spec_parse(local_btf, local_id, spec_str, &local_spec);
+ 	if (err) {
+ 		pr_warn("prog '%s': relo #%d: parsing [%d] %s + %s failed: %d\n",
+ 			prog_name, relo_idx, local_id, local_name, spec_str,
+ 			err);
+ 		return -EINVAL;
+ 	}
+ 
+ 	pr_debug("prog '%s': relo #%d: kind %d, spec is ", prog_name, relo_idx,
+ 		 relo->kind);
+ 	bpf_core_dump_spec(LIBBPF_DEBUG, &local_spec);
+ 	libbpf_print(LIBBPF_DEBUG, "\n");
+ 
+ 	if (!hashmap__find(cand_cache, type_key, (void **)&cand_ids)) {
+ 		cand_ids = bpf_core_find_cands(local_btf, local_id, targ_btf);
+ 		if (IS_ERR(cand_ids)) {
+ 			pr_warn("prog '%s': relo #%d: target candidate search failed for [%d] %s: %ld",
+ 				prog_name, relo_idx, local_id, local_name,
+ 				PTR_ERR(cand_ids));
+ 			return PTR_ERR(cand_ids);
+ 		}
+ 		err = hashmap__set(cand_cache, type_key, cand_ids, NULL, NULL);
+ 		if (err) {
+ 			bpf_core_free_cands(cand_ids);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	for (i = 0, j = 0; i < cand_ids->len; i++) {
+ 		cand_id = cand_ids->data[i];
+ 		cand_type = btf__type_by_id(targ_btf, cand_id);
+ 		cand_name = btf__name_by_offset(targ_btf, cand_type->name_off);
+ 
+ 		err = bpf_core_spec_match(&local_spec, targ_btf,
+ 					  cand_id, &cand_spec);
+ 		pr_debug("prog '%s': relo #%d: matching candidate #%d %s against spec ",
+ 			 prog_name, relo_idx, i, cand_name);
+ 		bpf_core_dump_spec(LIBBPF_DEBUG, &cand_spec);
+ 		libbpf_print(LIBBPF_DEBUG, ": %d\n", err);
+ 		if (err < 0) {
+ 			pr_warn("prog '%s': relo #%d: matching error: %d\n",
+ 				prog_name, relo_idx, err);
+ 			return err;
+ 		}
+ 		if (err == 0)
+ 			continue;
+ 
+ 		if (j == 0) {
+ 			targ_spec = cand_spec;
+ 		} else if (cand_spec.bit_offset != targ_spec.bit_offset) {
+ 			/* if there are many candidates, they should all
+ 			 * resolve to the same bit offset
+ 			 */
+ 			pr_warn("prog '%s': relo #%d: offset ambiguity: %u != %u\n",
+ 				prog_name, relo_idx, cand_spec.bit_offset,
+ 				targ_spec.bit_offset);
+ 			return -EINVAL;
+ 		}
+ 
+ 		cand_ids->data[j++] = cand_spec.spec[0].type_id;
+ 	}
+ 
+ 	/*
+ 	 * For BPF_FIELD_EXISTS relo or when used BPF program has field
+ 	 * existence checks or kernel version/config checks, it's expected
+ 	 * that we might not find any candidates. In this case, if field
+ 	 * wasn't found in any candidate, the list of candidates shouldn't
+ 	 * change at all, we'll just handle relocating appropriately,
+ 	 * depending on relo's kind.
+ 	 */
+ 	if (j > 0)
+ 		cand_ids->len = j;
+ 
+ 	/*
+ 	 * If no candidates were found, it might be both a programmer error,
+ 	 * as well as expected case, depending whether instruction w/
+ 	 * relocation is guarded in some way that makes it unreachable (dead
+ 	 * code) if relocation can't be resolved. This is handled in
+ 	 * bpf_core_reloc_insn() uniformly by replacing that instruction with
+ 	 * BPF helper call insn (using invalid helper ID). If that instruction
+ 	 * is indeed unreachable, then it will be ignored and eliminated by
+ 	 * verifier. If it was an error, then verifier will complain and point
+ 	 * to a specific instruction number in its log.
+ 	 */
+ 	if (j == 0)
+ 		pr_debug("prog '%s': relo #%d: no matching targets found for [%d] %s + %s\n",
+ 			 prog_name, relo_idx, local_id, local_name, spec_str);
+ 
+ 	/* bpf_core_reloc_insn should know how to handle missing targ_spec */
+ 	err = bpf_core_reloc_insn(prog, relo, relo_idx, &local_spec,
+ 				  j ? &targ_spec : NULL);
+ 	if (err) {
+ 		pr_warn("prog '%s': relo #%d: failed to patch insn at offset %d: %d\n",
+ 			prog_name, relo_idx, relo->insn_off, err);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ bpf_core_reloc_fields(struct bpf_object *obj, const char *targ_btf_path)
+ {
+ 	const struct btf_ext_info_sec *sec;
+ 	const struct bpf_field_reloc *rec;
+ 	const struct btf_ext_info *seg;
+ 	struct hashmap_entry *entry;
+ 	struct hashmap *cand_cache = NULL;
+ 	struct bpf_program *prog;
+ 	struct btf *targ_btf;
+ 	const char *sec_name;
+ 	int i, err = 0;
+ 
+ 	if (targ_btf_path)
+ 		targ_btf = btf__parse_elf(targ_btf_path, NULL);
+ 	else
+ 		targ_btf = libbpf_find_kernel_btf();
+ 	if (IS_ERR(targ_btf)) {
+ 		pr_warn("failed to get target BTF: %ld\n", PTR_ERR(targ_btf));
+ 		return PTR_ERR(targ_btf);
+ 	}
+ 
+ 	cand_cache = hashmap__new(bpf_core_hash_fn, bpf_core_equal_fn, NULL);
+ 	if (IS_ERR(cand_cache)) {
+ 		err = PTR_ERR(cand_cache);
+ 		goto out;
+ 	}
+ 
+ 	seg = &obj->btf_ext->field_reloc_info;
+ 	for_each_btf_ext_sec(seg, sec) {
+ 		sec_name = btf__name_by_offset(obj->btf, sec->sec_name_off);
+ 		if (str_is_empty(sec_name)) {
+ 			err = -EINVAL;
+ 			goto out;
+ 		}
+ 		prog = bpf_object__find_program_by_title(obj, sec_name);
+ 		if (!prog) {
+ 			pr_warn("failed to find program '%s' for CO-RE offset relocation\n",
+ 				sec_name);
+ 			err = -EINVAL;
+ 			goto out;
+ 		}
+ 
+ 		pr_debug("prog '%s': performing %d CO-RE offset relocs\n",
+ 			 sec_name, sec->num_info);
+ 
+ 		for_each_btf_ext_rec(seg, sec, i, rec) {
+ 			err = bpf_core_reloc_field(prog, rec, i, obj->btf,
+ 						   targ_btf, cand_cache);
+ 			if (err) {
+ 				pr_warn("prog '%s': relo #%d: failed to relocate: %d\n",
+ 					sec_name, i, err);
+ 				goto out;
+ 			}
+ 		}
+ 	}
+ 
+ out:
+ 	btf__free(targ_btf);
+ 	if (!IS_ERR_OR_NULL(cand_cache)) {
+ 		hashmap__for_each_entry(cand_cache, entry, i) {
+ 			bpf_core_free_cands(entry->value);
+ 		}
+ 		hashmap__free(cand_cache);
+ 	}
+ 	return err;
+ }
+ 
+ static int
+ bpf_object__relocate_core(struct bpf_object *obj, const char *targ_btf_path)
+ {
+ 	int err = 0;
+ 
+ 	if (obj->btf_ext->field_reloc_info.len)
+ 		err = bpf_core_reloc_fields(obj, targ_btf_path);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 35b9211c0a24 (libbpf: Fix realloc usage in bpf_core_find_cands)
  static int
  bpf_program__reloc_text(struct bpf_program *prog, struct bpf_object *obj,
  			struct reloc_desc *relo)
* Unmerged path tools/lib/bpf/libbpf.c
