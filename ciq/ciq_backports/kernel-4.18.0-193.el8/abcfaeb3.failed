intel_rapl: Fix module autoloading issue

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Zhang Rui <rui.zhang@intel.com>
commit abcfaeb3f5dc8bded4ba446eb2fb017a7a41d9bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/abcfaeb3.failed

intel_rapl driver used to have a list of cpuids, which is used to
1. check if the processor support RAPL MSRs
2. do some cpu model specific setting
3. module autoloading

Now, the cpu model specific setting are moved to intel_rapl_common.c as
part of the common code, because the setup is also needed by RAPL MMIO
interface on those platforms.
But removing the cpuid list from intel_rapl MSR interface driver results
in that the driver can not be loaded automatically.

Maintaining another copy of the cpuid list in intel_rapl_msr.c does not make
sense because it increases the complexity when enabling RAPL support on a
new cpu model.

Fix the problem by creating an "intel_rapl_msr" platform device in the
common code, and make RAPL MSR interface driver (intel_rapl_msr.c) probe the
platform device directly.

	Reviewed-by: Pandruvada, Srinivas <srinivas.pandruvada@intel.com>
	Tested-by: Pandruvada, Srinivas <srinivas.pandruvada@intel.com>
	Signed-off-by: Zhang Rui <rui.zhang@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit abcfaeb3f5dc8bded4ba446eb2fb017a7a41d9bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/powercap/intel_rapl.c
#	drivers/powercap/intel_rapl_msr.c
diff --cc drivers/powercap/intel_rapl.c
index cb3f68ebdb60,f1b7bcc32891..000000000000
--- a/drivers/powercap/intel_rapl.c
+++ b/drivers/powercap/intel_rapl.c
@@@ -31,9 -19,10 +31,16 @@@
  #include <linux/powercap.h>
  #include <linux/suspend.h>
  #include <linux/intel_rapl.h>
++<<<<<<< HEAD:drivers/powercap/intel_rapl.c
 +
 +#include <asm/iosf_mbi.h>
 +#include <asm/processor.h>
++=======
+ #include <linux/processor.h>
+ #include <linux/platform_device.h>
+ 
+ #include <asm/iosf_mbi.h>
++>>>>>>> abcfaeb3f5dc (intel_rapl: Fix module autoloading issue):drivers/powercap/intel_rapl_common.c
  #include <asm/cpu_device_id.h>
  #include <asm/intel-family.h>
  
@@@ -1486,42 -1406,7 +1493,46 @@@ static struct notifier_block rapl_pm_no
  	.notifier_call = rapl_pm_callback,
  };
  
++<<<<<<< HEAD:drivers/powercap/intel_rapl.c
 +static int rapl_msr_read_raw(int cpu, struct reg_action *ra)
 +{
 +	if (rdmsrl_safe_on_cpu(cpu, ra->reg, &ra->value)) {
 +		pr_debug("failed to read msr 0x%x on cpu %d\n", ra->reg, cpu);
 +		return -EIO;
 +	}
 +	ra->value &= ra->mask;
 +	return 0;
 +}
 +
 +static void rapl_msr_update_func(void *info)
 +{
 +	struct reg_action *ra = info;
 +	u64 val;
 +
 +	ra->err = rdmsrl_safe(ra->reg, &val);
 +	if (ra->err)
 +		return;
 +
 +	val &= ~ra->mask;
 +	val |= ra->value;
 +
 +	ra->err = wrmsrl_safe(ra->reg, val);
 +}
 +
 +
 +static int rapl_msr_write_raw(int cpu, struct reg_action *ra)
 +{
 +	int ret;
 +
 +	ret = smp_call_function_single(cpu, rapl_msr_update_func, ra, 1);
 +	if (WARN_ON_ONCE(ret))
 +		return ret;
 +
 +	return ra->err;
 +}
++=======
+ static struct platform_device *rapl_msr_platdev;
++>>>>>>> abcfaeb3f5dc (intel_rapl: Fix module autoloading issue):drivers/powercap/intel_rapl_common.c
  
  static int __init rapl_init(void)
  {
@@@ -1538,49 -1423,36 +1549,76 @@@
  
  	rapl_defaults = (struct rapl_defaults *)id->driver_data;
  
 +	rapl_msr_priv.read_raw = rapl_msr_read_raw;
 +	rapl_msr_priv.write_raw = rapl_msr_write_raw;
 +
 +	rapl_msr_priv.control_type = powercap_register_control_type(NULL, "intel-rapl", NULL);
 +	if (IS_ERR(rapl_msr_priv.control_type)) {
 +		pr_debug("failed to register powercap control_type.\n");
 +		return PTR_ERR(rapl_msr_priv.control_type);
 +	}
 +
 +	ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "powercap/rapl:online",
 +				rapl_cpu_online, rapl_cpu_down_prep);
 +	if (ret < 0)
 +		goto err_unreg;
 +	rapl_msr_priv.pcap_rapl_online = ret;
 +
 +	/* Don't bail out if PSys is not supported */
 +	rapl_add_platform_domain(&rapl_msr_priv);
 +
  	ret = register_pm_notifier(&rapl_pm_notifier);
  	if (ret)
++<<<<<<< HEAD:drivers/powercap/intel_rapl.c
 +		goto err_unreg_all;
 +
 +	return 0;
 +
 +err_unreg_all:
 +	cpuhp_remove_state(rapl_msr_priv.pcap_rapl_online);
 +
 +err_unreg:
 +	powercap_unregister_control_type(rapl_msr_priv.control_type);
++=======
+ 		return ret;
+ 
+ 	rapl_msr_platdev = platform_device_alloc("intel_rapl_msr", 0);
+ 	if (!rapl_msr_platdev) {
+ 		ret = -ENOMEM;
+ 		goto end;
+ 	}
+ 
+ 	ret = platform_device_add(rapl_msr_platdev);
+ 	if (ret)
+ 		platform_device_put(rapl_msr_platdev);
+ 
+ end:
+ 	if (ret)
+ 		unregister_pm_notifier(&rapl_pm_notifier);
+ 
++>>>>>>> abcfaeb3f5dc (intel_rapl: Fix module autoloading issue):drivers/powercap/intel_rapl_common.c
  	return ret;
  }
  
  static void __exit rapl_exit(void)
  {
+ 	platform_device_unregister(rapl_msr_platdev);
  	unregister_pm_notifier(&rapl_pm_notifier);
++<<<<<<< HEAD:drivers/powercap/intel_rapl.c
 +	cpuhp_remove_state(rapl_msr_priv.pcap_rapl_online);
 +	rapl_remove_platform_domain(&rapl_msr_priv);
 +	powercap_unregister_control_type(rapl_msr_priv.control_type);
++=======
++>>>>>>> abcfaeb3f5dc (intel_rapl: Fix module autoloading issue):drivers/powercap/intel_rapl_common.c
  }
  
  module_init(rapl_init);
  module_exit(rapl_exit);
  
++<<<<<<< HEAD:drivers/powercap/intel_rapl.c
 +MODULE_DESCRIPTION("Driver for Intel RAPL (Running Average Power Limit)");
++=======
+ MODULE_DESCRIPTION("Intel Runtime Average Power Limit (RAPL) common code");
++>>>>>>> abcfaeb3f5dc (intel_rapl: Fix module autoloading issue):drivers/powercap/intel_rapl_common.c
  MODULE_AUTHOR("Jacob Pan <jacob.jun.pan@intel.com>");
  MODULE_LICENSE("GPL v2");
* Unmerged path drivers/powercap/intel_rapl_msr.c
* Unmerged path drivers/powercap/intel_rapl.c
* Unmerged path drivers/powercap/intel_rapl_msr.c
