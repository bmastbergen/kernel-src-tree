iommu/vt-d: Delegate the identity domain to upper layer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [iommu] vt-d: Delegate the identity domain to upper layer (Jerry Snitselaar) [1742234]
Rebuild_FUZZ: 94.23%
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 4de354ec2f0c0529980ea4aa9fc4f35b296d3de8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4de354ec.failed

This allows the iommu generic layer to allocate an identity domain
and attach it to a device. Hence, the identity domain is delegated
to upper layer. As a side effect, iommu_identity_mapping can't be
used to check the existence of identity domains any more.

	Signed-off-by: James Sewart <jamessewart@arista.com>
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 4de354ec2f0c0529980ea4aa9fc4f35b296d3de8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 844e71353b6d,dc7d376a03aa..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -3583,11 -3647,8 +3604,14 @@@ static int iommu_no_mapping(struct devi
  	int found;
  
  	if (iommu_dummy(dev))
 -		return false;
 +		return 1;
 +
++<<<<<<< HEAD
 +	if (!iommu_identity_mapping)
 +		return 0;
  
++=======
++>>>>>>> 4de354ec2f0c (iommu/vt-d: Delegate the identity domain to upper layer)
  	found = identity_mapping(dev);
  	if (found) {
  		if (iommu_should_identity_map(dev, 0))
@@@ -5040,37 -5101,142 +5071,38 @@@ static struct iommu_domain *intel_iommu
  
  static void intel_iommu_domain_free(struct iommu_domain *domain)
  {
- 	domain_exit(to_dmar_domain(domain));
+ 	if (domain != &si_domain->domain)
+ 		domain_exit(to_dmar_domain(domain));
  }
  
 -/*
 - * Check whether a @domain could be attached to the @dev through the
 - * aux-domain attach/detach APIs.
 - */
 -static inline bool
 -is_aux_domain(struct device *dev, struct iommu_domain *domain)
 -{
 -	struct device_domain_info *info = dev->archdata.iommu;
 -
 -	return info && info->auxd_enabled &&
 -			domain->type == IOMMU_DOMAIN_UNMANAGED;
 -}
 -
 -static void auxiliary_link_device(struct dmar_domain *domain,
 -				  struct device *dev)
 -{
 -	struct device_domain_info *info = dev->archdata.iommu;
 -
 -	assert_spin_locked(&device_domain_lock);
 -	if (WARN_ON(!info))
 -		return;
 -
 -	domain->auxd_refcnt++;
 -	list_add(&domain->auxd, &info->auxiliary_domains);
 -}
 -
 -static void auxiliary_unlink_device(struct dmar_domain *domain,
 -				    struct device *dev)
 -{
 -	struct device_domain_info *info = dev->archdata.iommu;
 -
 -	assert_spin_locked(&device_domain_lock);
 -	if (WARN_ON(!info))
 -		return;
 -
 -	list_del(&domain->auxd);
 -	domain->auxd_refcnt--;
 -
 -	if (!domain->auxd_refcnt && domain->default_pasid > 0)
 -		intel_pasid_free_id(domain->default_pasid);
 -}
 -
 -static int aux_domain_add_dev(struct dmar_domain *domain,
 -			      struct device *dev)
 +static int intel_iommu_attach_device(struct iommu_domain *domain,
 +				     struct device *dev)
  {
 -	int ret;
 -	u8 bus, devfn;
 -	unsigned long flags;
 +	struct dmar_domain *dmar_domain = to_dmar_domain(domain);
  	struct intel_iommu *iommu;
 +	int addr_width;
 +	u8 bus, devfn;
  
 -	iommu = device_to_iommu(dev, &bus, &devfn);
 -	if (!iommu)
 -		return -ENODEV;
 -
 -	if (domain->default_pasid <= 0) {
 -		int pasid;
 -
 -		pasid = intel_pasid_alloc_id(domain, PASID_MIN,
 -					     pci_max_pasids(to_pci_dev(dev)),
 -					     GFP_KERNEL);
 -		if (pasid <= 0) {
 -			pr_err("Can't allocate default pasid\n");
 -			return -ENODEV;
 -		}
 -		domain->default_pasid = pasid;
 +	if (device_is_rmrr_locked(dev)) {
 +		dev_warn(dev, "Device is ineligible for IOMMU domain attach due to platform RMRR requirement.  Contact your platform vendor.\n");
 +		return -EPERM;
  	}
  
 -	spin_lock_irqsave(&device_domain_lock, flags);
 -	/*
 -	 * iommu->lock must be held to attach domain to iommu and setup the
 -	 * pasid entry for second level translation.
 -	 */
 -	spin_lock(&iommu->lock);
 -	ret = domain_attach_iommu(domain, iommu);
 -	if (ret)
 -		goto attach_failed;
 -
 -	/* Setup the PASID entry for mediated devices: */
 -	ret = intel_pasid_setup_second_level(iommu, domain, dev,
 -					     domain->default_pasid);
 -	if (ret)
 -		goto table_failed;
 -	spin_unlock(&iommu->lock);
 -
 -	auxiliary_link_device(domain, dev);
 -
 -	spin_unlock_irqrestore(&device_domain_lock, flags);
 -
 -	return 0;
 -
 -table_failed:
 -	domain_detach_iommu(domain, iommu);
 -attach_failed:
 -	spin_unlock(&iommu->lock);
 -	spin_unlock_irqrestore(&device_domain_lock, flags);
 -	if (!domain->auxd_refcnt && domain->default_pasid > 0)
 -		intel_pasid_free_id(domain->default_pasid);
 -
 -	return ret;
 -}
 -
 -static void aux_domain_remove_dev(struct dmar_domain *domain,
 -				  struct device *dev)
 -{
 -	struct device_domain_info *info;
 -	struct intel_iommu *iommu;
 -	unsigned long flags;
 -
 -	if (!is_aux_domain(dev, &domain->domain))
 -		return;
 -
 -	spin_lock_irqsave(&device_domain_lock, flags);
 -	info = dev->archdata.iommu;
 -	iommu = info->iommu;
 -
 -	auxiliary_unlink_device(domain, dev);
 -
 -	spin_lock(&iommu->lock);
 -	intel_pasid_tear_down_entry(iommu, dev, domain->default_pasid);
 -	domain_detach_iommu(domain, iommu);
 -	spin_unlock(&iommu->lock);
 +	/* normally dev is not mapped */
 +	if (unlikely(domain_context_mapped(dev))) {
 +		struct dmar_domain *old_domain;
  
 -	spin_unlock_irqrestore(&device_domain_lock, flags);
 -}
 +		old_domain = find_domain(dev);
 +		if (old_domain) {
 +			rcu_read_lock();
 +			dmar_remove_one_dev_info(old_domain, dev);
 +			rcu_read_unlock();
  
 -static int prepare_domain_attach_device(struct iommu_domain *domain,
 -					struct device *dev)
 -{
 -	struct dmar_domain *dmar_domain = to_dmar_domain(domain);
 -	struct intel_iommu *iommu;
 -	int addr_width;
 -	u8 bus, devfn;
 +			if (!domain_type_is_vm_or_si(old_domain) &&
 +			     list_empty(&old_domain->devices))
 +				domain_exit(old_domain);
 +		}
 +	}
  
  	iommu = device_to_iommu(dev, &bus, &devfn);
  	if (!iommu)
* Unmerged path drivers/iommu/intel-iommu.c
