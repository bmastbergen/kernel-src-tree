net/mlx5: E-Switch, Handle representors creation in handler context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Handle representors creation in handler context (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 96.92%
commit-author Vu Pham <vuhuong@mellanox.com>
commit ac35dcd6e4bdfadc90d6566ccf9fdc3b8f5e1b23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ac35dcd6.failed

Unified representors creation in esw_functions_changed context
handler. Emulate the esw_function_changed event for FW/HW that
does not support this event.

	Signed-off-by: Vu Pham <vuhuong@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Bodong Wang <bodong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit ac35dcd6e4bdfadc90d6566ccf9fdc3b8f5e1b23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 881a0621eae0,504c0440b0b0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1666,6 -1718,8 +1666,11 @@@ static int eswitch_vport_event(struct n
  
  int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_vport *vport;
+ 	int total_nvports = 0;
++>>>>>>> ac35dcd6e4bd (net/mlx5: E-Switch, Handle representors creation in handler context)
  	int err;
  	int i, enabled_events;
  
@@@ -1683,6 -1737,13 +1688,16 @@@
  
  	esw_info(esw->dev, "E-Switch enable SRIOV: nvfs(%d) mode (%d)\n", nvfs, mode);
  
++<<<<<<< HEAD
++=======
+ 	if (mode == SRIOV_OFFLOADS) {
+ 		if (mlx5_core_is_ecpf_esw_manager(esw->dev))
+ 			total_nvports = esw->total_vports;
+ 		else
+ 			total_nvports = nvfs + MLX5_SPECIAL_VPORTS(esw->dev);
+ 	}
+ 
++>>>>>>> ac35dcd6e4bd (net/mlx5: E-Switch, Handle representors creation in handler context)
  	esw->mode = mode;
  
  	mlx5_lag_update(esw->dev);
@@@ -1694,7 -1755,7 +1709,11 @@@
  	} else {
  		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_ETH);
  		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_IB);
++<<<<<<< HEAD
 +		err = esw_offloads_init(esw, nvfs + MLX5_SPECIAL_VPORTS);
++=======
+ 		err = esw_offloads_init(esw, nvfs, total_nvports);
++>>>>>>> ac35dcd6e4bd (net/mlx5: E-Switch, Handle representors creation in handler context)
  	}
  
  	if (err)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 087fd65120c5,f843d8a35a2c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1296,7 -1432,26 +1296,30 @@@ static int esw_offloads_load_reps(struc
  
  err_reps:
  	while (rep_type-- > 0)
++<<<<<<< HEAD
 +		esw_offloads_unload_reps_type(esw, nvports, rep_type);
++=======
+ 		__unload_reps_vf_vport(esw, nvports, rep_type);
+ 	return err;
+ }
+ 
+ static int esw_offloads_load_special_vport(struct mlx5_eswitch *esw)
+ {
+ 	u8 rep_type = 0;
+ 	int err;
+ 
+ 	for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++) {
+ 		err = __load_reps_special_vport(esw, rep_type);
+ 		if (err)
+ 			goto err_reps;
+ 	}
+ 
+ 	return err;
+ 
+ err_reps:
+ 	while (rep_type-- > 0)
+ 		__unload_reps_special_vport(esw, rep_type);
++>>>>>>> ac35dcd6e4bd (net/mlx5: E-Switch, Handle representors creation in handler context)
  	return err;
  }
  
@@@ -1603,7 -1760,101 +1626,105 @@@ static void esw_offloads_steering_clean
  		esw_prio_tag_acls_cleanup(esw);
  }
  
++<<<<<<< HEAD
 +int esw_offloads_init(struct mlx5_eswitch *esw, int nvports)
++=======
+ static void esw_functions_changed_event_handler(struct work_struct *work)
+ {
+ 	struct mlx5_host_work *host_work;
+ 	struct mlx5_eswitch *esw;
+ 	u16 num_vfs = 0;
+ 	int err;
+ 
+ 	host_work = container_of(work, struct mlx5_host_work, work);
+ 	esw = host_work->esw;
+ 
+ 	err = mlx5_esw_query_functions(esw->dev, &num_vfs);
+ 	if (err || num_vfs == esw->esw_funcs.num_vfs)
+ 		goto out;
+ 
+ 	/* Number of VFs can only change from "0 to x" or "x to 0". */
+ 	if (esw->esw_funcs.num_vfs > 0) {
+ 		esw_offloads_unload_vf_reps(esw, esw->esw_funcs.num_vfs);
+ 	} else {
+ 		err = esw_offloads_load_vf_reps(esw, num_vfs);
+ 
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	esw->esw_funcs.num_vfs = num_vfs;
+ 
+ out:
+ 	kfree(host_work);
+ }
+ 
+ static void esw_emulate_event_handler(struct work_struct *work)
+ {
+ 	struct mlx5_host_work *host_work =
+ 		container_of(work, struct mlx5_host_work, work);
+ 	struct mlx5_eswitch *esw = host_work->esw;
+ 	int err;
+ 
+ 	if (esw->esw_funcs.num_vfs) {
+ 		err = esw_offloads_load_vf_reps(esw, esw->esw_funcs.num_vfs);
+ 		if (err)
+ 			esw_warn(esw->dev, "Load vf reps err=%d\n", err);
+ 	}
+ 	kfree(host_work);
+ }
+ 
+ static int esw_functions_changed_event(struct notifier_block *nb,
+ 				       unsigned long type, void *data)
+ {
+ 	struct mlx5_esw_functions *esw_funcs;
+ 	struct mlx5_host_work *host_work;
+ 	struct mlx5_eswitch *esw;
+ 
+ 	host_work = kzalloc(sizeof(*host_work), GFP_ATOMIC);
+ 	if (!host_work)
+ 		return NOTIFY_DONE;
+ 
+ 	esw_funcs = mlx5_nb_cof(nb, struct mlx5_esw_functions, nb);
+ 	esw = container_of(esw_funcs, struct mlx5_eswitch, esw_funcs);
+ 
+ 	host_work->esw = esw;
+ 
+ 	if (mlx5_eswitch_is_funcs_handler(esw->dev))
+ 		INIT_WORK(&host_work->work,
+ 			  esw_functions_changed_event_handler);
+ 	else
+ 		INIT_WORK(&host_work->work, esw_emulate_event_handler);
+ 	queue_work(esw->work_queue, &host_work->work);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static void esw_functions_changed_event_init(struct mlx5_eswitch *esw,
+ 					     u16 vf_nvports)
+ {
+ 	if (mlx5_eswitch_is_funcs_handler(esw->dev)) {
+ 		esw->esw_funcs.num_vfs = 0;
+ 		MLX5_NB_INIT(&esw->esw_funcs.nb, esw_functions_changed_event,
+ 			     ESW_FUNCTIONS_CHANGED);
+ 		mlx5_eq_notifier_register(esw->dev, &esw->esw_funcs.nb);
+ 	} else {
+ 		esw->esw_funcs.num_vfs = vf_nvports;
+ 	}
+ }
+ 
+ static void esw_functions_changed_event_cleanup(struct mlx5_eswitch *esw)
+ {
+ 	if (!mlx5_eswitch_is_funcs_handler(esw->dev))
+ 		return;
+ 
+ 	mlx5_eq_notifier_unregister(esw->dev, &esw->esw_funcs.nb);
+ 	flush_workqueue(esw->work_queue);
+ }
+ 
+ int esw_offloads_init(struct mlx5_eswitch *esw, int vf_nvports,
+ 		      int total_nvports)
++>>>>>>> ac35dcd6e4bd (net/mlx5: E-Switch, Handle representors creation in handler context)
  {
  	int err;
  
@@@ -1613,11 -1862,30 +1734,37 @@@
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = esw_offloads_load_reps(esw, nvports);
++=======
+ 	/* Only load special vports reps. VF reps will be loaded in
+ 	 * context of functions_changed event handler through real
+ 	 * or emulated event.
+ 	 */
+ 	err = esw_offloads_load_special_vport(esw);
++>>>>>>> ac35dcd6e4bd (net/mlx5: E-Switch, Handle representors creation in handler context)
  	if (err)
  		goto err_reps;
  
  	esw_offloads_devcom_init(esw);
++<<<<<<< HEAD
++=======
+ 
+ 	esw_functions_changed_event_init(esw, vf_nvports);
+ 
+ 	mlx5_rdma_enable_roce(esw->dev);
+ 
+ 	/* Call esw_functions_changed event to load VF reps:
+ 	 * 1. HW does not support the event then emulate it
+ 	 * Or
+ 	 * 2. The event was already notified when num_vfs changed
+ 	 * and eswitch was in legacy mode
+ 	 */
+ 	esw_functions_changed_event(&esw->esw_funcs.nb.nb,
+ 				    MLX5_EVENT_TYPE_ESW_FUNCTIONS_CHANGED,
+ 				    NULL);
+ 
++>>>>>>> ac35dcd6e4bd (net/mlx5: E-Switch, Handle representors creation in handler context)
  	return 0;
  
  err_reps:
@@@ -1644,10 -1912,12 +1791,17 @@@ static int esw_offloads_stop(struct mlx
  	return err;
  }
  
 -void esw_offloads_cleanup(struct mlx5_eswitch *esw)
 +void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports)
  {
++<<<<<<< HEAD
 +	esw_offloads_devcom_cleanup(esw);
 +	esw_offloads_unload_reps(esw, nvports);
++=======
+ 	esw_functions_changed_event_cleanup(esw);
+ 	mlx5_rdma_disable_roce(esw->dev);
+ 	esw_offloads_devcom_cleanup(esw);
+ 	esw_offloads_unload_all_reps(esw, esw->esw_funcs.num_vfs);
++>>>>>>> ac35dcd6e4bd (net/mlx5: E-Switch, Handle representors creation in handler context)
  	esw_offloads_steering_cleanup(esw);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
