bpf: fix minor issues in documentation for BPF helpers.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [uapi] bpf: fix minor issues in documentation for BPF helpers (Yauheni Kaliuta) [1747615]
Rebuild_FUZZ: 99.08%
commit-author Quentin Monnet <quentin.monnet@netronome.com>
commit 80867c5e3c0275c7208816faac768a44fa3747be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/80867c5e.failed

This commit brings many minor fixes to the documentation for BPF helper
functions. Mostly, this is limited to formatting fixes and improvements.
In particular, fix broken formatting for bpf_skb_adjust_room().

Besides formatting, replace the mention of "bpf_fullsock()" (that is not
associated with any function or type exposed to the user) in the
description of bpf_sk_storage_get() by "full socket".

	Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 80867c5e3c0275c7208816faac768a44fa3747be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
diff --cc include/uapi/linux/bpf.h
index d5a77164c7e4,63e0cf66f01a..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2470,11 -2480,198 +2472,201 @@@ union bpf_attr 
   *
   * struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *sk)
   *	Description
 - *		Return a **struct bpf_sock** pointer in **TCP_LISTEN** state.
 - *		**bpf_sk_release**\ () is unnecessary and not allowed.
 + *		Return a **struct bpf_sock** pointer in TCP_LISTEN state.
 + *		bpf_sk_release() is unnecessary and not allowed.
   *	Return
 - *		A **struct bpf_sock** pointer on success, or **NULL** in
 + *		A **struct bpf_sock** pointer on success, or NULL in
   *		case of failure.
++<<<<<<< HEAD
++=======
+  *
+  * struct bpf_sock *bpf_skc_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		This function is identical to **bpf_sk_lookup_tcp**\ (), except
+  *		that it also returns timewait or request sockets. Use
+  *		**bpf_sk_fullsock**\ () or **bpf_tcp_sock**\ () to access the
+  *		full structure.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from *reuse*\ **->socks**\ [] using the hash of the
+  *		tuple.
+  *
+  * int bpf_tcp_check_syncookie(struct bpf_sock *sk, void *iph, u32 iph_len, struct tcphdr *th, u32 th_len)
+  * 	Description
+  * 		Check whether *iph* and *th* contain a valid SYN cookie ACK for
+  * 		the listening socket in *sk*.
+  *
+  * 		*iph* points to the start of the IPv4 or IPv6 header, while
+  * 		*iph_len* contains **sizeof**\ (**struct iphdr**) or
+  * 		**sizeof**\ (**struct ip6hdr**).
+  *
+  * 		*th* points to the start of the TCP header, while *th_len*
+  * 		contains **sizeof**\ (**struct tcphdr**).
+  *
+  * 	Return
+  * 		0 if *iph* and *th* are a valid SYN cookie ACK, or a negative
+  * 		error otherwise.
+  *
+  * int bpf_sysctl_get_name(struct bpf_sysctl *ctx, char *buf, size_t buf_len, u64 flags)
+  *	Description
+  *		Get name of sysctl in /proc/sys/ and copy it into provided by
+  *		program buffer *buf* of size *buf_len*.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *
+  *		If *flags* is zero, full name (e.g. "net/ipv4/tcp_mem") is
+  *		copied. Use **BPF_F_SYSCTL_BASE_NAME** flag to copy base name
+  *		only (e.g. "tcp_mem").
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  * int bpf_sysctl_get_current_value(struct bpf_sysctl *ctx, char *buf, size_t buf_len)
+  *	Description
+  *		Get current value of sysctl as it is presented in /proc/sys
+  *		(incl. newline, etc), and copy it as a string into provided
+  *		by program buffer *buf* of size *buf_len*.
+  *
+  *		The whole value is copied, no matter what file position user
+  *		space issued e.g. sys_read at.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  *		**-EINVAL** if current value was unavailable, e.g. because
+  *		sysctl is uninitialized and read returns -EIO for it.
+  *
+  * int bpf_sysctl_get_new_value(struct bpf_sysctl *ctx, char *buf, size_t buf_len)
+  *	Description
+  *		Get new value being written by user space to sysctl (before
+  *		the actual write happens) and copy it as a string into
+  *		provided by program buffer *buf* of size *buf_len*.
+  *
+  *		User space may write new value at file position > 0.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  *		**-EINVAL** if sysctl is being read.
+  *
+  * int bpf_sysctl_set_new_value(struct bpf_sysctl *ctx, const char *buf, size_t buf_len)
+  *	Description
+  *		Override new value being written by user space to sysctl with
+  *		value provided by program in buffer *buf* of size *buf_len*.
+  *
+  *		*buf* should contain a string in same form as provided by user
+  *		space on sysctl write.
+  *
+  *		User space may write new value at file position > 0. To override
+  *		the whole sysctl value file position should be set to zero.
+  *	Return
+  *		0 on success.
+  *
+  *		**-E2BIG** if the *buf_len* is too big.
+  *
+  *		**-EINVAL** if sysctl is being read.
+  *
+  * int bpf_strtol(const char *buf, size_t buf_len, u64 flags, long *res)
+  *	Description
+  *		Convert the initial part of the string from buffer *buf* of
+  *		size *buf_len* to a long integer according to the given base
+  *		and save the result in *res*.
+  *
+  *		The string may begin with an arbitrary amount of white space
+  *		(as determined by **isspace**\ (3)) followed by a single
+  *		optional '**-**' sign.
+  *
+  *		Five least significant bits of *flags* encode base, other bits
+  *		are currently unused.
+  *
+  *		Base must be either 8, 10, 16 or 0 to detect it automatically
+  *		similar to user space **strtol**\ (3).
+  *	Return
+  *		Number of characters consumed on success. Must be positive but
+  *		no more than *buf_len*.
+  *
+  *		**-EINVAL** if no valid digits were found or unsupported base
+  *		was provided.
+  *
+  *		**-ERANGE** if resulting value was out of range.
+  *
+  * int bpf_strtoul(const char *buf, size_t buf_len, u64 flags, unsigned long *res)
+  *	Description
+  *		Convert the initial part of the string from buffer *buf* of
+  *		size *buf_len* to an unsigned long integer according to the
+  *		given base and save the result in *res*.
+  *
+  *		The string may begin with an arbitrary amount of white space
+  *		(as determined by **isspace**\ (3)).
+  *
+  *		Five least significant bits of *flags* encode base, other bits
+  *		are currently unused.
+  *
+  *		Base must be either 8, 10, 16 or 0 to detect it automatically
+  *		similar to user space **strtoul**\ (3).
+  *	Return
+  *		Number of characters consumed on success. Must be positive but
+  *		no more than *buf_len*.
+  *
+  *		**-EINVAL** if no valid digits were found or unsupported base
+  *		was provided.
+  *
+  *		**-ERANGE** if resulting value was out of range.
+  *
+  * void *bpf_sk_storage_get(struct bpf_map *map, struct bpf_sock *sk, void *value, u64 flags)
+  *	Description
+  *		Get a bpf-local-storage from a *sk*.
+  *
+  *		Logically, it could be thought of getting the value from
+  *		a *map* with *sk* as the **key**.  From this
+  *		perspective,  the usage is not much different from
+  *		**bpf_map_lookup_elem**\ (*map*, **&**\ *sk*) except this
+  *		helper enforces the key must be a full socket and the map must
+  *		be a **BPF_MAP_TYPE_SK_STORAGE** also.
+  *
+  *		Underneath, the value is stored locally at *sk* instead of
+  *		the *map*.  The *map* is used as the bpf-local-storage
+  *		"type". The bpf-local-storage "type" (i.e. the *map*) is
+  *		searched against all bpf-local-storages residing at *sk*.
+  *
+  *		An optional *flags* (**BPF_SK_STORAGE_GET_F_CREATE**) can be
+  *		used such that a new bpf-local-storage will be
+  *		created if one does not exist.  *value* can be used
+  *		together with **BPF_SK_STORAGE_GET_F_CREATE** to specify
+  *		the initial value of a bpf-local-storage.  If *value* is
+  *		**NULL**, the new bpf-local-storage will be zero initialized.
+  *	Return
+  *		A bpf-local-storage pointer is returned on success.
+  *
+  *		**NULL** if not found or there was an error in adding
+  *		a new bpf-local-storage.
+  *
+  * int bpf_sk_storage_delete(struct bpf_map *map, struct bpf_sock *sk)
+  *	Description
+  *		Delete a bpf-local-storage from a *sk*.
+  *	Return
+  *		0 on success.
+  *
+  *		**-ENOENT** if the bpf-local-storage cannot be found.
++>>>>>>> 80867c5e3c02 (bpf: fix minor issues in documentation for BPF helpers.)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
* Unmerged path include/uapi/linux/bpf.h
