net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Consider host PF for inline mode and vlan pop (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 96.83%
commit-author Bodong Wang <bodong@mellanox.com>
commit 411ec9e0b45792e2ac7c55f94a635d5ce894910b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/411ec9e0.failed

When ECPF is the eswitch manager, host PF is treated like other VFs.
Driver should do the same for inline mode and vlan pop.

Add new iterators to include host PF if ECPF is the eswitch manager.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 411ec9e0b45792e2ac7c55f94a635d5ce894910b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	include/linux/mlx5/vport.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index f4a0b22e3987,935b9429bb2a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1820,6 -1890,8 +1820,11 @@@ int mlx5_eswitch_init(struct mlx5_core_
  		return -ENOMEM;
  
  	esw->dev = dev;
++<<<<<<< HEAD
++=======
+ 	esw->manager_vport = mlx5_eswitch_manager_vport(dev);
+ 	esw->first_host_vport = mlx5_eswitch_first_host_vport_num(dev);
++>>>>>>> 411ec9e0b457 (net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop)
  
  	esw->work_queue = create_singlethread_workqueue("mlx5_esw_wq");
  	if (!esw->work_queue) {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index af9a875f1cf1,f59183440d7f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -209,10 -226,13 +209,16 @@@ struct mlx5_eswitch 
  	struct mlx5_esw_offload offloads;
  	int                     mode;
  	int                     nvports;
++<<<<<<< HEAD
++=======
+ 	u16                     manager_vport;
+ 	u16                     first_host_vport;
+ 	struct mlx5_esw_functions esw_funcs;
++>>>>>>> 411ec9e0b457 (net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop)
  };
  
 -void esw_offloads_cleanup(struct mlx5_eswitch *esw);
 -int esw_offloads_init(struct mlx5_eswitch *esw);
 +void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports);
 +int esw_offloads_init(struct mlx5_eswitch *esw, int nvports);
  void esw_offloads_cleanup_reps(struct mlx5_eswitch *esw);
  int esw_offloads_init_reps(struct mlx5_eswitch *esw);
  void esw_vport_cleanup_ingress_rules(struct mlx5_eswitch *esw,
@@@ -392,9 -416,142 +398,148 @@@ bool mlx5_esw_multipath_prereq(struct m
  #define esw_debug(dev, format, ...)				\
  	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
  
++<<<<<<< HEAD
 +/* TODO: This mlx5e_tc function shouldn't be called by eswitch */
 +void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
 +
++=======
+ /* The returned number is valid only when the dev is eswitch manager. */
+ static inline u16 mlx5_eswitch_manager_vport(struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_core_is_ecpf_esw_manager(dev) ?
+ 		MLX5_VPORT_ECPF : MLX5_VPORT_PF;
+ }
+ 
+ static inline u16 mlx5_eswitch_first_host_vport_num(struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_core_is_ecpf_esw_manager(dev) ?
+ 		MLX5_VPORT_PF : MLX5_VPORT_FIRST_VF;
+ }
+ 
+ static inline bool mlx5_eswitch_is_funcs_handler(struct mlx5_core_dev *dev)
+ {
+ 	/* Ideally device should have the functions changed supported
+ 	 * capability regardless of it being ECPF or PF wherever such
+ 	 * event should be processed such as on eswitch manager device.
+ 	 * However, some ECPF based device might not have this capability
+ 	 * set. Hence OR for ECPF check to cover such device.
+ 	 */
+ 	return MLX5_CAP_ESW(dev, esw_functions_changed) ||
+ 	       mlx5_core_is_ecpf_esw_manager(dev);
+ }
+ 
+ static inline int mlx5_eswitch_uplink_idx(struct mlx5_eswitch *esw)
+ {
+ 	/* Uplink always locate at the last element of the array.*/
+ 	return esw->total_vports - 1;
+ }
+ 
+ static inline int mlx5_eswitch_ecpf_idx(struct mlx5_eswitch *esw)
+ {
+ 	return esw->total_vports - 2;
+ }
+ 
+ static inline int mlx5_eswitch_vport_num_to_index(struct mlx5_eswitch *esw,
+ 						  u16 vport_num)
+ {
+ 	if (vport_num == MLX5_VPORT_ECPF) {
+ 		if (!mlx5_ecpf_vport_exists(esw->dev))
+ 			esw_warn(esw->dev, "ECPF vport doesn't exist!\n");
+ 		return mlx5_eswitch_ecpf_idx(esw);
+ 	}
+ 
+ 	if (vport_num == MLX5_VPORT_UPLINK)
+ 		return mlx5_eswitch_uplink_idx(esw);
+ 
+ 	return vport_num;
+ }
+ 
+ static inline int mlx5_eswitch_index_to_vport_num(struct mlx5_eswitch *esw,
+ 						  int index)
+ {
+ 	if (index == mlx5_eswitch_ecpf_idx(esw) &&
+ 	    mlx5_ecpf_vport_exists(esw->dev))
+ 		return MLX5_VPORT_ECPF;
+ 
+ 	if (index == mlx5_eswitch_uplink_idx(esw))
+ 		return MLX5_VPORT_UPLINK;
+ 
+ 	return index;
+ }
+ 
+ /* TODO: This mlx5e_tc function shouldn't be called by eswitch */
+ void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
+ 
+ /* The vport getter/iterator are only valid after esw->total_vports
+  * and vport->vport are initialized in mlx5_eswitch_init.
+  */
+ #define mlx5_esw_for_all_vports(esw, i, vport)		\
+ 	for ((i) = MLX5_VPORT_PF;			\
+ 	     (vport) = &(esw)->vports[i],		\
+ 	     (i) < (esw)->total_vports; (i)++)
+ 
+ #define mlx5_esw_for_each_vf_vport(esw, i, vport, nvfs)	\
+ 	for ((i) = MLX5_VPORT_FIRST_VF;			\
+ 	     (vport) = &(esw)->vports[(i)],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_vf_vport_reverse(esw, i, vport, nvfs)	\
+ 	for ((i) = (nvfs);					\
+ 	     (vport) = &(esw)->vports[(i)],			\
+ 	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+ 
+ /* The rep getter/iterator are only valid after esw->total_vports
+  * and vport->vport are initialized in mlx5_eswitch_init.
+  */
+ #define mlx5_esw_for_all_reps(esw, i, rep)			\
+ 	for ((i) = MLX5_VPORT_PF;				\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) < (esw)->total_vports; (i)++)
+ 
+ #define mlx5_esw_for_each_vf_rep(esw, i, rep, nvfs)		\
+ 	for ((i) = MLX5_VPORT_FIRST_VF;				\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvfs)	\
+ 	for ((i) = (nvfs);					\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+ 
+ #define mlx5_esw_for_each_vf_vport_num(esw, vport, nvfs)	\
+ 	for ((vport) = MLX5_VPORT_FIRST_VF; (vport) <= (nvfs); (vport)++)
+ 
+ #define mlx5_esw_for_each_vf_vport_num_reverse(esw, vport, nvfs)	\
+ 	for ((vport) = (nvfs); (vport) >= MLX5_VPORT_FIRST_VF; (vport)--)
+ 
+ /* Includes host PF (vport 0) if it's not esw manager. */
+ #define mlx5_esw_for_each_host_func_rep(esw, i, rep, nvfs)	\
+ 	for ((i) = (esw)->first_host_vport;			\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_host_func_rep_reverse(esw, i, rep, nvfs)	\
+ 	for ((i) = (nvfs);						\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],			\
+ 	     (i) >= (esw)->first_host_vport; (i)--)
+ 
+ #define mlx5_esw_for_each_host_func_vport(esw, vport, nvfs)	\
+ 	for ((vport) = (esw)->first_host_vport;			\
+ 	     (vport) <= (nvfs); (vport)++)
+ 
+ #define mlx5_esw_for_each_host_func_vport_reverse(esw, vport, nvfs)	\
+ 	for ((vport) = (nvfs);						\
+ 	     (vport) >= (esw)->first_host_vport; (vport)--)
+ 
+ struct mlx5_vport *__must_check
+ mlx5_eswitch_get_vport(struct mlx5_eswitch *esw, u16 vport_num);
+ 
+ bool mlx5_eswitch_is_vf_vport(const struct mlx5_eswitch *esw, u16 vport_num);
+ 
+ void mlx5_eswitch_update_num_of_vfs(struct mlx5_eswitch *esw, const int num_vfs);
+ int mlx5_esw_funcs_changed_handler(struct notifier_block *nb, unsigned long type, void *data);
+ 
++>>>>>>> 411ec9e0b457 (net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop)
  #else  /* CONFIG_MLX5_ESWITCH */
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,50e5841c1698..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -314,12 -344,11 +314,17 @@@ mlx5_eswitch_del_fwd_rule(struct mlx5_e
  static int esw_set_global_vlan_pop(struct mlx5_eswitch *esw, u8 val)
  {
  	struct mlx5_eswitch_rep *rep;
- 	int vf_vport, err = 0;
+ 	int i, err = 0;
  
  	esw_debug(esw->dev, "%s applying global %s policy\n", __func__, val ? "pop" : "none");
++<<<<<<< HEAD
 +	for (vf_vport = 1; vf_vport < esw->enabled_vports; vf_vport++) {
 +		rep = &esw->offloads.vport_reps[vf_vport];
 +		if (!rep->rep_if[REP_ETH].valid)
++=======
+ 	mlx5_esw_for_each_host_func_rep(esw, i, rep, esw->esw_funcs.num_vfs) {
+ 		if (atomic_read(&rep->rep_data[REP_ETH].state) != REP_LOADED)
++>>>>>>> 411ec9e0b457 (net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop)
  			continue;
  
  		err = __mlx5_eswitch_set_vport_vlan(esw, rep->vport, 0, 0, val);
@@@ -1817,7 -2330,7 +1822,11 @@@ int mlx5_devlink_eswitch_inline_mode_se
  	if (err)
  		goto out;
  
++<<<<<<< HEAD
 +	for (vport = 1; vport < esw->enabled_vports; vport++) {
++=======
+ 	mlx5_esw_for_each_host_func_vport(esw, vport, esw->esw_funcs.num_vfs) {
++>>>>>>> 411ec9e0b457 (net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop)
  		err = mlx5_modify_nic_vport_min_inline(dev, vport, mlx5_mode);
  		if (err) {
  			NL_SET_ERR_MSG_MOD(extack,
@@@ -1830,7 -2343,8 +1839,12 @@@
  	return 0;
  
  revert_inline_mode:
++<<<<<<< HEAD
 +	while (--vport > 0)
++=======
+ 	num_vport = --vport;
+ 	mlx5_esw_for_each_host_func_vport_reverse(esw, vport, num_vport)
++>>>>>>> 411ec9e0b457 (net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop)
  		mlx5_modify_nic_vport_min_inline(dev,
  						 vport,
  						 esw->offloads.inline_mode);
@@@ -1875,9 -2389,10 +1889,14 @@@ int mlx5_eswitch_inline_mode_get(struc
  	}
  
  query_vports:
++<<<<<<< HEAD
 +	for (vport = 1; vport <= nvfs; vport++) {
++=======
+ 	mlx5_query_nic_vport_min_inline(dev, esw->first_host_vport, &prev_mlx5_mode);
+ 	mlx5_esw_for_each_host_func_vport(esw, vport, esw->esw_funcs.num_vfs) {
++>>>>>>> 411ec9e0b457 (net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop)
  		mlx5_query_nic_vport_min_inline(dev, vport, &mlx5_mode);
- 		if (vport > 1 && prev_mlx5_mode != mlx5_mode)
+ 		if (prev_mlx5_mode != mlx5_mode)
  			return -EINVAL;
  		prev_mlx5_mode = mlx5_mode;
  	}
diff --cc include/linux/mlx5/vport.h
index bf6a92201084,6cbf29229749..000000000000
--- a/include/linux/mlx5/vport.h
+++ b/include/linux/mlx5/vport.h
@@@ -51,6 -58,14 +51,17 @@@ enum 
  	MLX5_CAP_INLINE_MODE_NOT_REQUIRED,
  };
  
++<<<<<<< HEAD
++=======
+ /* Vport number for each function must keep unchanged */
+ enum {
+ 	MLX5_VPORT_PF			= 0x0,
+ 	MLX5_VPORT_FIRST_VF		= 0x1,
+ 	MLX5_VPORT_ECPF			= 0xfffe,
+ 	MLX5_VPORT_UPLINK		= 0xffff
+ };
+ 
++>>>>>>> 411ec9e0b457 (net/mlx5: E-Switch, Consider host PF for inline mode and vlan pop)
  u8 mlx5_query_vport_state(struct mlx5_core_dev *mdev, u8 opmod, u16 vport);
  int mlx5_modify_vport_admin_state(struct mlx5_core_dev *mdev, u8 opmod,
  				  u16 vport, u8 other_vport, u8 state);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path include/linux/mlx5/vport.h
