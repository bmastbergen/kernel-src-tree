net/mlx5: E-switch, Removed unused hwid

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-switch, Removed unused hwid (Alaa Hleihel) [1663231 1724327 1724336]
Rebuild_FUZZ: 94.59%
commit-author Parav Pandit <parav@mellanox.com>
commit ef2e4094e076858343ea1202046443f642a245cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ef2e4094.failed

Currently mlx5_eswitch_rep stores same hw ID for all representors.
However it is never used from this structure.
It is always used from mlx5_vport.

Hence, remove unused field.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Vu Pham <vuhuong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit ef2e4094e076858343ea1202046443f642a245cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,42cc5001255b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1206,12 -1392,10 +1206,19 @@@ void esw_offloads_cleanup_reps(struct m
  
  int esw_offloads_init_reps(struct mlx5_eswitch *esw)
  {
++<<<<<<< HEAD
 +	int total_vports = MLX5_TOTAL_VPORTS(esw->dev);
 +	struct mlx5_core_dev *dev = esw->dev;
 +	struct mlx5_esw_offload *offloads;
 +	struct mlx5_eswitch_rep *rep;
 +	u8 hw_id[ETH_ALEN];
 +	int vport;
++=======
+ 	int total_vports = esw->total_vports;
+ 	struct mlx5_eswitch_rep *rep;
+ 	int vport_index;
+ 	u8 rep_type;
++>>>>>>> ef2e4094e076 (net/mlx5: E-switch, Removed unused hwid)
  
  	esw->offloads.vport_reps = kcalloc(total_vports,
  					   sizeof(struct mlx5_eswitch_rep),
@@@ -1219,37 -1403,71 +1226,47 @@@
  	if (!esw->offloads.vport_reps)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	offloads = &esw->offloads;
 +	mlx5_query_nic_vport_mac_address(dev, 0, hw_id);
 +
 +	for (vport = 0; vport < total_vfs; vport++) {
 +		rep = &offloads->vport_reps[vport];
 +
 +		rep->vport = vport;
 +		ether_addr_copy(rep->hw_id, hw_id);
++=======
+ 	mlx5_esw_for_all_reps(esw, vport_index, rep) {
+ 		rep->vport = mlx5_eswitch_index_to_vport_num(esw, vport_index);
+ 		rep->vport_index = vport_index;
+ 
+ 		for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++)
+ 			atomic_set(&rep->rep_data[rep_type].state,
+ 				   REP_UNREGISTERED);
++>>>>>>> ef2e4094e076 (net/mlx5: E-switch, Removed unused hwid)
  	}
  
 -	return 0;
 -}
 +	offloads->vport_reps[0].vport = FDB_UPLINK_VPORT;
  
 -static void __esw_offloads_unload_rep(struct mlx5_eswitch *esw,
 -				      struct mlx5_eswitch_rep *rep, u8 rep_type)
 -{
 -	if (atomic_cmpxchg(&rep->rep_data[rep_type].state,
 -			   REP_LOADED, REP_REGISTERED) == REP_LOADED)
 -		esw->offloads.rep_ops[rep_type]->unload(rep);
 +	return 0;
  }
  
 -static void __unload_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
 +static void esw_offloads_unload_reps_type(struct mlx5_eswitch *esw, int nvports,
 +					  u8 rep_type)
  {
  	struct mlx5_eswitch_rep *rep;
 +	int vport;
  
 -	if (mlx5_ecpf_vport_exists(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_ECPF);
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 -	}
 +	for (vport = nvports - 1; vport >= 0; vport--) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
  
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 +		rep->rep_if[rep_type].unload(rep);
  	}
 -
 -	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 -	__esw_offloads_unload_rep(esw, rep, rep_type);
 -}
 -
 -static void __unload_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
 -				   u8 rep_type)
 -{
 -	struct mlx5_eswitch_rep *rep;
 -	int i;
 -
 -	mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvports)
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 -}
 -
 -static void esw_offloads_unload_vf_reps(struct mlx5_eswitch *esw, int nvports)
 -{
 -	u8 rep_type = NUM_REP_TYPES;
 -
 -	while (rep_type-- > 0)
 -		__unload_reps_vf_vport(esw, nvports, rep_type);
 -}
 -
 -static void __unload_reps_all_vport(struct mlx5_eswitch *esw, u8 rep_type)
 -{
 -	__unload_reps_vf_vport(esw, esw->esw_funcs.num_vfs, rep_type);
 -
 -	/* Special vports must be the last to unload. */
 -	__unload_reps_special_vport(esw, rep_type);
  }
  
 -static void esw_offloads_unload_all_reps(struct mlx5_eswitch *esw)
 +static void esw_offloads_unload_reps(struct mlx5_eswitch *esw, int nvports)
  {
  	u8 rep_type = NUM_REP_TYPES;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/include/linux/mlx5/eswitch.h b/include/linux/mlx5/eswitch.h
index 5c8be6f99f8d..c4ebb196f908 100644
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@ -36,7 +36,6 @@ struct mlx5_eswitch_rep_if {
 struct mlx5_eswitch_rep {
 	struct mlx5_eswitch_rep_if rep_if[NUM_REP_TYPES];
 	u16		       vport;
-	u8		       hw_id[ETH_ALEN];
 	u16		       vlan;
 	u32		       vlan_refcount;
 };
