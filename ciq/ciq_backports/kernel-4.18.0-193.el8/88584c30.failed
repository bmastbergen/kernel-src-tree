xfrm: policy: fix policy hash rebuild

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Florian Westphal <fw@strlen.de>
commit 88584c30e31967db2ad03c7015a9aea3460deb2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/88584c30.failed

Dan Carpenter reports following static checker warning:
 net/xfrm/xfrm_policy.c:1316 xfrm_hash_rebuild()
 warn: 'dir' is out of bounds '3' vs '2'

 |  1280          /* reset the bydst and inexact table in all directions */
 |  1281          xfrm_hash_reset_inexact_table(net);
 |  1282
 |  1283          for (dir = 0; dir < XFRM_POLICY_MAX; dir++) {
 |                              ^^^^^^^^^^^^^^^^^^^^^
 |dir == XFRM_POLICY_MAX at the end of this loop.
 |  1304          /* re-insert all policies by order of creation */
 |  1305          list_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) {
 [..]
 |  1314                                            xfrm_policy_id2dir(policy->index));
 |  1315                  if (!chain) {
 |  1316                          void *p = xfrm_policy_inexact_insert(policy, dir, 0);

Fix this by updating 'dir' based on current policy.  Otherwise, the
inexact policies won't be found anymore during lookup, as they get
hashed to a bogus bin.

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
Fixes: cc1bb845adc9 ("xfrm: policy: return NULL when inexact search needed")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 88584c30e31967db2ad03c7015a9aea3460deb2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 6b43f9247a17,be04091eb7db..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -621,10 -1312,14 +623,21 @@@ static void xfrm_hash_rebuild(struct wo
  		}
  		newpos = NULL;
  		chain = policy_hash_bysel(net, &policy->selector,
++<<<<<<< HEAD
 +					  policy->family,
 +					  xfrm_policy_id2dir(policy->index));
 +		if (!chain)
 +			chain = &net->xfrm.policy_inexact[dir];
++=======
+ 					  policy->family, dir);
+ 		if (!chain) {
+ 			void *p = xfrm_policy_inexact_insert(policy, dir, 0);
+ 
+ 			WARN_ONCE(IS_ERR(p), "reinsert: %ld\n", PTR_ERR(p));
+ 			continue;
+ 		}
+ 
++>>>>>>> 88584c30e319 (xfrm: policy: fix policy hash rebuild)
  		hlist_for_each_entry(pol, chain, bydst) {
  			if (policy->priority >= pol->priority)
  				newpos = &pol->bydst;
* Unmerged path net/xfrm/xfrm_policy.c
