SUNRPC: Fix disconnection races

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 0445f92c5d537c173a54446b80d2052145de5148
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/0445f92c.failed

When the socket is closed, we need to call xprt_disconnect_done() in order
to clean up the XPRT_WRITE_SPACE flag, and wake up the sleeping tasks.

However, we also want to ensure that we don't wake them up before the socket
is closed, since that would cause thundering herd issues with everyone
piling up to retransmit before the TCP shutdown dance has completed.
Only the task that holds XPRT_LOCKED needs to wake up early in order to
allow the close to complete.

	Reported-by: Dave Wysochanski <dwysocha@redhat.com>
	Reported-by: Scott Mayhew <smayhew@redhat.com>
	Cc: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Tested-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 0445f92c5d537c173a54446b80d2052145de5148)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index 135e7c1d525c,4c471b4235ba..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -1648,9 -1488,9 +1648,15 @@@ static void xs_tcp_state_change(struct 
  		if (test_and_clear_bit(XPRT_SOCK_CONNECTING,
  					&transport->sock_state))
  			xprt_clear_connecting(xprt);
++<<<<<<< HEAD
 +		if (sk->sk_err)
 +			xprt_wake_pending_tasks(xprt, -sk->sk_err);
 +		xs_sock_mark_closed(xprt);
++=======
+ 		clear_bit(XPRT_CLOSING, &xprt->state);
+ 		/* Trigger the socket release */
+ 		xs_tcp_force_close(xprt);
++>>>>>>> 0445f92c5d53 (SUNRPC: Fix disconnection races)
  	}
   out:
  	read_unlock_bh(&sk->sk_callback_lock);
diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c
index 672043b072dd..9eca1d382736 100644
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@ -1930,6 +1930,7 @@ call_connect_status(struct rpc_task *task)
 		/* retry with existing socket, after a delay */
 		rpc_delay(task, 3*HZ);
 		/* fall through */
+	case -ENOTCONN:
 	case -EAGAIN:
 		/* Check for timeouts before looping back to call_bind */
 	case -ETIMEDOUT:
diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c
index c4d4cd12e49e..38dfc0e5fcd8 100644
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -639,7 +639,9 @@ void xprt_force_disconnect(struct rpc_xprt *xprt)
 	/* Try to schedule an autoclose RPC call */
 	if (test_and_set_bit(XPRT_LOCKED, &xprt->state) == 0)
 		queue_work(xprtiod_workqueue, &xprt->task_cleanup);
-	xprt_wake_pending_tasks(xprt, -EAGAIN);
+	else if (xprt->snd_task)
+		rpc_wake_up_queued_task_set_status(&xprt->pending,
+				xprt->snd_task, -ENOTCONN);
 	spin_unlock_bh(&xprt->transport_lock);
 }
 EXPORT_SYMBOL_GPL(xprt_force_disconnect);
@@ -797,6 +799,7 @@ static void xprt_connect_status(struct rpc_task *task)
 	case -ENETUNREACH:
 	case -EHOSTUNREACH:
 	case -EPIPE:
+	case -ENOTCONN:
 	case -EAGAIN:
 		dprintk("RPC: %5u xprt_connect_status: retrying\n", task->tk_pid);
 		break;
* Unmerged path net/sunrpc/xprtsock.c
