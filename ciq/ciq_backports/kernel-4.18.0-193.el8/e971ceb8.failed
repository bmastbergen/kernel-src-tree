netfilter: synproxy: fix rst sequence number mismatch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Fernando Fernandez Mancera <ffmancera@riseup.net>
commit e971ceb803e147e47c15cbb7c5b84327c6453786
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e971ceb8.failed

14:51:00.024418 IP 192.168.122.1.41462 > netfilter.90: Flags [S], seq
4023580551,
14:51:00.024454 IP netfilter.90 > 192.168.122.1.41462: Flags [S.], seq
727560212, ack 4023580552,
14:51:00.024524 IP 192.168.122.1.41462 > netfilter.90: Flags [.], ack 1,

Note: here, synproxy will send a SYN to the real server, as the 3whs was
completed sucessfully. Instead of a syn/ack that we can intercept, we instead
received a reset packet from the real backend, that we forward to the original
client. However, we don't use the correct sequence number, so the reset is not
effective in closing the connection coming from the client.

14:51:00.024550 IP netfilter.90 > 192.168.122.1.41462: Flags [R.], seq
3567407084,
14:51:00.231196 IP 192.168.122.1.41462 > netfilter.90: Flags [.], ack 1,
14:51:00.647911 IP 192.168.122.1.41462 > netfilter.90: Flags [.], ack 1,
14:51:01.474395 IP 192.168.122.1.41462 > netfilter.90: Flags [.], ack 1,

Fixes: 48b1de4c110a ("netfilter: add SYNPROXY core/target")
	Signed-off-by: Fernando Fernandez Mancera <ffmancera@riseup.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit e971ceb803e147e47c15cbb7c5b84327c6453786)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_synproxy_core.c
diff --cc net/netfilter/nf_synproxy_core.c
index 8ff4d22f10b2,c769462a839e..000000000000
--- a/net/netfilter/nf_synproxy_core.c
+++ b/net/netfilter/nf_synproxy_core.c
@@@ -416,5 -410,830 +416,833 @@@ static void __exit synproxy_core_exit(v
  module_init(synproxy_core_init);
  module_exit(synproxy_core_exit);
  
++<<<<<<< HEAD
++=======
+ static struct iphdr *
+ synproxy_build_ip(struct net *net, struct sk_buff *skb, __be32 saddr,
+ 		  __be32 daddr)
+ {
+ 	struct iphdr *iph;
+ 
+ 	skb_reset_network_header(skb);
+ 	iph = skb_put(skb, sizeof(*iph));
+ 	iph->version	= 4;
+ 	iph->ihl	= sizeof(*iph) / 4;
+ 	iph->tos	= 0;
+ 	iph->id		= 0;
+ 	iph->frag_off	= htons(IP_DF);
+ 	iph->ttl	= net->ipv4.sysctl_ip_default_ttl;
+ 	iph->protocol	= IPPROTO_TCP;
+ 	iph->check	= 0;
+ 	iph->saddr	= saddr;
+ 	iph->daddr	= daddr;
+ 
+ 	return iph;
+ }
+ 
+ static void
+ synproxy_send_tcp(struct net *net,
+ 		  const struct sk_buff *skb, struct sk_buff *nskb,
+ 		  struct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,
+ 		  struct iphdr *niph, struct tcphdr *nth,
+ 		  unsigned int tcp_hdr_size)
+ {
+ 	nth->check = ~tcp_v4_check(tcp_hdr_size, niph->saddr, niph->daddr, 0);
+ 	nskb->ip_summed   = CHECKSUM_PARTIAL;
+ 	nskb->csum_start  = (unsigned char *)nth - nskb->head;
+ 	nskb->csum_offset = offsetof(struct tcphdr, check);
+ 
+ 	skb_dst_set_noref(nskb, skb_dst(skb));
+ 	nskb->protocol = htons(ETH_P_IP);
+ 	if (ip_route_me_harder(net, nskb, RTN_UNSPEC))
+ 		goto free_nskb;
+ 
+ 	if (nfct) {
+ 		nf_ct_set(nskb, (struct nf_conn *)nfct, ctinfo);
+ 		nf_conntrack_get(nfct);
+ 	}
+ 
+ 	ip_local_out(net, nskb->sk, nskb);
+ 	return;
+ 
+ free_nskb:
+ 	kfree_skb(nskb);
+ }
+ 
+ void
+ synproxy_send_client_synack(struct net *net,
+ 			    const struct sk_buff *skb, const struct tcphdr *th,
+ 			    const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct iphdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 	u16 mss = opts->mss_encode;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip(net, nskb, iph->daddr, iph->saddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->dest;
+ 	nth->dest	= th->source;
+ 	nth->seq	= htonl(__cookie_v4_init_sequence(iph, th, &mss));
+ 	nth->ack_seq	= htonl(ntohl(th->seq) + 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_SYN | TCP_FLAG_ACK;
+ 	if (opts->options & NF_SYNPROXY_OPT_ECN)
+ 		tcp_flag_word(nth) |= TCP_FLAG_ECE;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= 0;
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp(net, skb, nskb, skb_nfct(skb),
+ 			  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);
+ }
+ EXPORT_SYMBOL_GPL(synproxy_send_client_synack);
+ 
+ static void
+ synproxy_send_server_syn(struct net *net,
+ 			 const struct sk_buff *skb, const struct tcphdr *th,
+ 			 const struct synproxy_options *opts, u32 recv_seq)
+ {
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	struct sk_buff *nskb;
+ 	struct iphdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip(net, nskb, iph->saddr, iph->daddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->source;
+ 	nth->dest	= th->dest;
+ 	nth->seq	= htonl(recv_seq - 1);
+ 	/* ack_seq is used to relay our ISN to the synproxy hook to initialize
+ 	 * sequence number translation once a connection tracking entry exists.
+ 	 */
+ 	nth->ack_seq	= htonl(ntohl(th->ack_seq) - 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_SYN;
+ 	if (opts->options & NF_SYNPROXY_OPT_ECN)
+ 		tcp_flag_word(nth) |= TCP_FLAG_ECE | TCP_FLAG_CWR;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= th->window;
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp(net, skb, nskb, &snet->tmpl->ct_general, IP_CT_NEW,
+ 			  niph, nth, tcp_hdr_size);
+ }
+ 
+ static void
+ synproxy_send_server_ack(struct net *net,
+ 			 const struct ip_ct_tcp *state,
+ 			 const struct sk_buff *skb, const struct tcphdr *th,
+ 			 const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct iphdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip(net, nskb, iph->daddr, iph->saddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->dest;
+ 	nth->dest	= th->source;
+ 	nth->seq	= htonl(ntohl(th->ack_seq));
+ 	nth->ack_seq	= htonl(ntohl(th->seq) + 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_ACK;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= htons(state->seen[IP_CT_DIR_ORIGINAL].td_maxwin);
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp(net, skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);
+ }
+ 
+ static void
+ synproxy_send_client_ack(struct net *net,
+ 			 const struct sk_buff *skb, const struct tcphdr *th,
+ 			 const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct iphdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip(net, nskb, iph->saddr, iph->daddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->source;
+ 	nth->dest	= th->dest;
+ 	nth->seq	= htonl(ntohl(th->seq) + 1);
+ 	nth->ack_seq	= th->ack_seq;
+ 	tcp_flag_word(nth) = TCP_FLAG_ACK;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= htons(ntohs(th->window) >> opts->wscale);
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp(net, skb, nskb, skb_nfct(skb),
+ 			  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);
+ }
+ 
+ bool
+ synproxy_recv_client_ack(struct net *net,
+ 			 const struct sk_buff *skb, const struct tcphdr *th,
+ 			 struct synproxy_options *opts, u32 recv_seq)
+ {
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	int mss;
+ 
+ 	mss = __cookie_v4_check(ip_hdr(skb), th, ntohl(th->ack_seq) - 1);
+ 	if (mss == 0) {
+ 		this_cpu_inc(snet->stats->cookie_invalid);
+ 		return false;
+ 	}
+ 
+ 	this_cpu_inc(snet->stats->cookie_valid);
+ 	opts->mss = mss;
+ 	opts->options |= NF_SYNPROXY_OPT_MSS;
+ 
+ 	if (opts->options & NF_SYNPROXY_OPT_TIMESTAMP)
+ 		synproxy_check_timestamp_cookie(opts);
+ 
+ 	synproxy_send_server_syn(net, skb, th, opts, recv_seq);
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(synproxy_recv_client_ack);
+ 
+ unsigned int
+ ipv4_synproxy_hook(void *priv, struct sk_buff *skb,
+ 		   const struct nf_hook_state *nhs)
+ {
+ 	struct net *net = nhs->net;
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	enum ip_conntrack_info ctinfo;
+ 	struct nf_conn *ct;
+ 	struct nf_conn_synproxy *synproxy;
+ 	struct synproxy_options opts = {};
+ 	const struct ip_ct_tcp *state;
+ 	struct tcphdr *th, _th;
+ 	unsigned int thoff;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct)
+ 		return NF_ACCEPT;
+ 
+ 	synproxy = nfct_synproxy(ct);
+ 	if (!synproxy)
+ 		return NF_ACCEPT;
+ 
+ 	if (nf_is_loopback_packet(skb) ||
+ 	    ip_hdr(skb)->protocol != IPPROTO_TCP)
+ 		return NF_ACCEPT;
+ 
+ 	thoff = ip_hdrlen(skb);
+ 	th = skb_header_pointer(skb, thoff, sizeof(_th), &_th);
+ 	if (!th)
+ 		return NF_DROP;
+ 
+ 	state = &ct->proto.tcp;
+ 	switch (state->state) {
+ 	case TCP_CONNTRACK_CLOSE:
+ 		if (th->rst && CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL) {
+ 			nf_ct_seqadj_init(ct, ctinfo, synproxy->isn -
+ 						      ntohl(th->seq) + 1);
+ 			break;
+ 		}
+ 
+ 		if (!th->syn || th->ack ||
+ 		    CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)
+ 			break;
+ 
+ 		/* Reopened connection - reset the sequence number and timestamp
+ 		 * adjustments, they will get initialized once the connection is
+ 		 * reestablished.
+ 		 */
+ 		nf_ct_seqadj_init(ct, ctinfo, 0);
+ 		synproxy->tsoff = 0;
+ 		this_cpu_inc(snet->stats->conn_reopened);
+ 
+ 		/* fall through */
+ 	case TCP_CONNTRACK_SYN_SENT:
+ 		if (!synproxy_parse_options(skb, thoff, th, &opts))
+ 			return NF_DROP;
+ 
+ 		if (!th->syn && th->ack &&
+ 		    CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {
+ 			/* Keep-Alives are sent with SEG.SEQ = SND.NXT-1,
+ 			 * therefore we need to add 1 to make the SYN sequence
+ 			 * number match the one of first SYN.
+ 			 */
+ 			if (synproxy_recv_client_ack(net, skb, th, &opts,
+ 						     ntohl(th->seq) + 1)) {
+ 				this_cpu_inc(snet->stats->cookie_retrans);
+ 				consume_skb(skb);
+ 				return NF_STOLEN;
+ 			} else {
+ 				return NF_DROP;
+ 			}
+ 		}
+ 
+ 		synproxy->isn = ntohl(th->ack_seq);
+ 		if (opts.options & NF_SYNPROXY_OPT_TIMESTAMP)
+ 			synproxy->its = opts.tsecr;
+ 
+ 		nf_conntrack_event_cache(IPCT_SYNPROXY, ct);
+ 		break;
+ 	case TCP_CONNTRACK_SYN_RECV:
+ 		if (!th->syn || !th->ack)
+ 			break;
+ 
+ 		if (!synproxy_parse_options(skb, thoff, th, &opts))
+ 			return NF_DROP;
+ 
+ 		if (opts.options & NF_SYNPROXY_OPT_TIMESTAMP) {
+ 			synproxy->tsoff = opts.tsval - synproxy->its;
+ 			nf_conntrack_event_cache(IPCT_SYNPROXY, ct);
+ 		}
+ 
+ 		opts.options &= ~(NF_SYNPROXY_OPT_MSS |
+ 				  NF_SYNPROXY_OPT_WSCALE |
+ 				  NF_SYNPROXY_OPT_SACK_PERM);
+ 
+ 		swap(opts.tsval, opts.tsecr);
+ 		synproxy_send_server_ack(net, state, skb, th, &opts);
+ 
+ 		nf_ct_seqadj_init(ct, ctinfo, synproxy->isn - ntohl(th->seq));
+ 		nf_conntrack_event_cache(IPCT_SEQADJ, ct);
+ 
+ 		swap(opts.tsval, opts.tsecr);
+ 		synproxy_send_client_ack(net, skb, th, &opts);
+ 
+ 		consume_skb(skb);
+ 		return NF_STOLEN;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	synproxy_tstamp_adjust(skb, thoff, th, ct, ctinfo, synproxy);
+ 	return NF_ACCEPT;
+ }
+ EXPORT_SYMBOL_GPL(ipv4_synproxy_hook);
+ 
+ static const struct nf_hook_ops ipv4_synproxy_ops[] = {
+ 	{
+ 		.hook		= ipv4_synproxy_hook,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM - 1,
+ 	},
+ 	{
+ 		.hook		= ipv4_synproxy_hook,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM - 1,
+ 	},
+ };
+ 
+ int nf_synproxy_ipv4_init(struct synproxy_net *snet, struct net *net)
+ {
+ 	int err;
+ 
+ 	if (snet->hook_ref4 == 0) {
+ 		err = nf_register_net_hooks(net, ipv4_synproxy_ops,
+ 					    ARRAY_SIZE(ipv4_synproxy_ops));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	snet->hook_ref4++;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nf_synproxy_ipv4_init);
+ 
+ void nf_synproxy_ipv4_fini(struct synproxy_net *snet, struct net *net)
+ {
+ 	snet->hook_ref4--;
+ 	if (snet->hook_ref4 == 0)
+ 		nf_unregister_net_hooks(net, ipv4_synproxy_ops,
+ 					ARRAY_SIZE(ipv4_synproxy_ops));
+ }
+ EXPORT_SYMBOL_GPL(nf_synproxy_ipv4_fini);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static struct ipv6hdr *
+ synproxy_build_ip_ipv6(struct net *net, struct sk_buff *skb,
+ 		       const struct in6_addr *saddr,
+ 		       const struct in6_addr *daddr)
+ {
+ 	struct ipv6hdr *iph;
+ 
+ 	skb_reset_network_header(skb);
+ 	iph = skb_put(skb, sizeof(*iph));
+ 	ip6_flow_hdr(iph, 0, 0);
+ 	iph->hop_limit	= net->ipv6.devconf_all->hop_limit;
+ 	iph->nexthdr	= IPPROTO_TCP;
+ 	iph->saddr	= *saddr;
+ 	iph->daddr	= *daddr;
+ 
+ 	return iph;
+ }
+ 
+ static void
+ synproxy_send_tcp_ipv6(struct net *net,
+ 		       const struct sk_buff *skb, struct sk_buff *nskb,
+ 		       struct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,
+ 		       struct ipv6hdr *niph, struct tcphdr *nth,
+ 		       unsigned int tcp_hdr_size)
+ {
+ 	struct dst_entry *dst;
+ 	struct flowi6 fl6;
+ 	int err;
+ 
+ 	nth->check = ~tcp_v6_check(tcp_hdr_size, &niph->saddr, &niph->daddr, 0);
+ 	nskb->ip_summed   = CHECKSUM_PARTIAL;
+ 	nskb->csum_start  = (unsigned char *)nth - nskb->head;
+ 	nskb->csum_offset = offsetof(struct tcphdr, check);
+ 
+ 	memset(&fl6, 0, sizeof(fl6));
+ 	fl6.flowi6_proto = IPPROTO_TCP;
+ 	fl6.saddr = niph->saddr;
+ 	fl6.daddr = niph->daddr;
+ 	fl6.fl6_sport = nth->source;
+ 	fl6.fl6_dport = nth->dest;
+ 	security_skb_classify_flow((struct sk_buff *)skb,
+ 				   flowi6_to_flowi(&fl6));
+ 	err = nf_ip6_route(net, &dst, flowi6_to_flowi(&fl6), false);
+ 	if (err) {
+ 		goto free_nskb;
+ 	}
+ 
+ 	dst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);
+ 	if (IS_ERR(dst))
+ 		goto free_nskb;
+ 
+ 	skb_dst_set(nskb, dst);
+ 
+ 	if (nfct) {
+ 		nf_ct_set(nskb, (struct nf_conn *)nfct, ctinfo);
+ 		nf_conntrack_get(nfct);
+ 	}
+ 
+ 	ip6_local_out(net, nskb->sk, nskb);
+ 	return;
+ 
+ free_nskb:
+ 	kfree_skb(nskb);
+ }
+ 
+ void
+ synproxy_send_client_synack_ipv6(struct net *net,
+ 				 const struct sk_buff *skb,
+ 				 const struct tcphdr *th,
+ 				 const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct ipv6hdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 	u16 mss = opts->mss_encode;
+ 
+ 	iph = ipv6_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip_ipv6(net, nskb, &iph->daddr, &iph->saddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->dest;
+ 	nth->dest	= th->source;
+ 	nth->seq	= htonl(nf_ipv6_cookie_init_sequence(iph, th, &mss));
+ 	nth->ack_seq	= htonl(ntohl(th->seq) + 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_SYN | TCP_FLAG_ACK;
+ 	if (opts->options & NF_SYNPROXY_OPT_ECN)
+ 		tcp_flag_word(nth) |= TCP_FLAG_ECE;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= 0;
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp_ipv6(net, skb, nskb, skb_nfct(skb),
+ 			       IP_CT_ESTABLISHED_REPLY, niph, nth,
+ 			       tcp_hdr_size);
+ }
+ EXPORT_SYMBOL_GPL(synproxy_send_client_synack_ipv6);
+ 
+ static void
+ synproxy_send_server_syn_ipv6(struct net *net, const struct sk_buff *skb,
+ 			      const struct tcphdr *th,
+ 			      const struct synproxy_options *opts, u32 recv_seq)
+ {
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	struct sk_buff *nskb;
+ 	struct ipv6hdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ipv6_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip_ipv6(net, nskb, &iph->saddr, &iph->daddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->source;
+ 	nth->dest	= th->dest;
+ 	nth->seq	= htonl(recv_seq - 1);
+ 	/* ack_seq is used to relay our ISN to the synproxy hook to initialize
+ 	 * sequence number translation once a connection tracking entry exists.
+ 	 */
+ 	nth->ack_seq	= htonl(ntohl(th->ack_seq) - 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_SYN;
+ 	if (opts->options & NF_SYNPROXY_OPT_ECN)
+ 		tcp_flag_word(nth) |= TCP_FLAG_ECE | TCP_FLAG_CWR;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= th->window;
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp_ipv6(net, skb, nskb, &snet->tmpl->ct_general,
+ 			       IP_CT_NEW, niph, nth, tcp_hdr_size);
+ }
+ 
+ static void
+ synproxy_send_server_ack_ipv6(struct net *net, const struct ip_ct_tcp *state,
+ 			      const struct sk_buff *skb,
+ 			      const struct tcphdr *th,
+ 			      const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct ipv6hdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ipv6_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip_ipv6(net, nskb, &iph->daddr, &iph->saddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->dest;
+ 	nth->dest	= th->source;
+ 	nth->seq	= htonl(ntohl(th->ack_seq));
+ 	nth->ack_seq	= htonl(ntohl(th->seq) + 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_ACK;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= htons(state->seen[IP_CT_DIR_ORIGINAL].td_maxwin);
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp_ipv6(net, skb, nskb, NULL, 0, niph, nth,
+ 			       tcp_hdr_size);
+ }
+ 
+ static void
+ synproxy_send_client_ack_ipv6(struct net *net, const struct sk_buff *skb,
+ 			      const struct tcphdr *th,
+ 			      const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct ipv6hdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ipv6_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip_ipv6(net, nskb, &iph->saddr, &iph->daddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->source;
+ 	nth->dest	= th->dest;
+ 	nth->seq	= htonl(ntohl(th->seq) + 1);
+ 	nth->ack_seq	= th->ack_seq;
+ 	tcp_flag_word(nth) = TCP_FLAG_ACK;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= htons(ntohs(th->window) >> opts->wscale);
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp_ipv6(net, skb, nskb, skb_nfct(skb),
+ 			       IP_CT_ESTABLISHED_REPLY, niph, nth,
+ 			       tcp_hdr_size);
+ }
+ 
+ bool
+ synproxy_recv_client_ack_ipv6(struct net *net,
+ 			      const struct sk_buff *skb,
+ 			      const struct tcphdr *th,
+ 			      struct synproxy_options *opts, u32 recv_seq)
+ {
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	int mss;
+ 
+ 	mss = nf_cookie_v6_check(ipv6_hdr(skb), th, ntohl(th->ack_seq) - 1);
+ 	if (mss == 0) {
+ 		this_cpu_inc(snet->stats->cookie_invalid);
+ 		return false;
+ 	}
+ 
+ 	this_cpu_inc(snet->stats->cookie_valid);
+ 	opts->mss = mss;
+ 	opts->options |= NF_SYNPROXY_OPT_MSS;
+ 
+ 	if (opts->options & NF_SYNPROXY_OPT_TIMESTAMP)
+ 		synproxy_check_timestamp_cookie(opts);
+ 
+ 	synproxy_send_server_syn_ipv6(net, skb, th, opts, recv_seq);
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(synproxy_recv_client_ack_ipv6);
+ 
+ unsigned int
+ ipv6_synproxy_hook(void *priv, struct sk_buff *skb,
+ 		   const struct nf_hook_state *nhs)
+ {
+ 	struct net *net = nhs->net;
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	enum ip_conntrack_info ctinfo;
+ 	struct nf_conn *ct;
+ 	struct nf_conn_synproxy *synproxy;
+ 	struct synproxy_options opts = {};
+ 	const struct ip_ct_tcp *state;
+ 	struct tcphdr *th, _th;
+ 	__be16 frag_off;
+ 	u8 nexthdr;
+ 	int thoff;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct)
+ 		return NF_ACCEPT;
+ 
+ 	synproxy = nfct_synproxy(ct);
+ 	if (!synproxy)
+ 		return NF_ACCEPT;
+ 
+ 	if (nf_is_loopback_packet(skb))
+ 		return NF_ACCEPT;
+ 
+ 	nexthdr = ipv6_hdr(skb)->nexthdr;
+ 	thoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr,
+ 				 &frag_off);
+ 	if (thoff < 0 || nexthdr != IPPROTO_TCP)
+ 		return NF_ACCEPT;
+ 
+ 	th = skb_header_pointer(skb, thoff, sizeof(_th), &_th);
+ 	if (!th)
+ 		return NF_DROP;
+ 
+ 	state = &ct->proto.tcp;
+ 	switch (state->state) {
+ 	case TCP_CONNTRACK_CLOSE:
+ 		if (th->rst && CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL) {
+ 			nf_ct_seqadj_init(ct, ctinfo, synproxy->isn -
+ 						      ntohl(th->seq) + 1);
+ 			break;
+ 		}
+ 
+ 		if (!th->syn || th->ack ||
+ 		    CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)
+ 			break;
+ 
+ 		/* Reopened connection - reset the sequence number and timestamp
+ 		 * adjustments, they will get initialized once the connection is
+ 		 * reestablished.
+ 		 */
+ 		nf_ct_seqadj_init(ct, ctinfo, 0);
+ 		synproxy->tsoff = 0;
+ 		this_cpu_inc(snet->stats->conn_reopened);
+ 
+ 		/* fall through */
+ 	case TCP_CONNTRACK_SYN_SENT:
+ 		if (!synproxy_parse_options(skb, thoff, th, &opts))
+ 			return NF_DROP;
+ 
+ 		if (!th->syn && th->ack &&
+ 		    CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {
+ 			/* Keep-Alives are sent with SEG.SEQ = SND.NXT-1,
+ 			 * therefore we need to add 1 to make the SYN sequence
+ 			 * number match the one of first SYN.
+ 			 */
+ 			if (synproxy_recv_client_ack_ipv6(net, skb, th, &opts,
+ 							  ntohl(th->seq) + 1)) {
+ 				this_cpu_inc(snet->stats->cookie_retrans);
+ 				consume_skb(skb);
+ 				return NF_STOLEN;
+ 			} else {
+ 				return NF_DROP;
+ 			}
+ 		}
+ 
+ 		synproxy->isn = ntohl(th->ack_seq);
+ 		if (opts.options & NF_SYNPROXY_OPT_TIMESTAMP)
+ 			synproxy->its = opts.tsecr;
+ 
+ 		nf_conntrack_event_cache(IPCT_SYNPROXY, ct);
+ 		break;
+ 	case TCP_CONNTRACK_SYN_RECV:
+ 		if (!th->syn || !th->ack)
+ 			break;
+ 
+ 		if (!synproxy_parse_options(skb, thoff, th, &opts))
+ 			return NF_DROP;
+ 
+ 		if (opts.options & NF_SYNPROXY_OPT_TIMESTAMP) {
+ 			synproxy->tsoff = opts.tsval - synproxy->its;
+ 			nf_conntrack_event_cache(IPCT_SYNPROXY, ct);
+ 		}
+ 
+ 		opts.options &= ~(NF_SYNPROXY_OPT_MSS |
+ 				  NF_SYNPROXY_OPT_WSCALE |
+ 				  NF_SYNPROXY_OPT_SACK_PERM);
+ 
+ 		swap(opts.tsval, opts.tsecr);
+ 		synproxy_send_server_ack_ipv6(net, state, skb, th, &opts);
+ 
+ 		nf_ct_seqadj_init(ct, ctinfo, synproxy->isn - ntohl(th->seq));
+ 		nf_conntrack_event_cache(IPCT_SEQADJ, ct);
+ 
+ 		swap(opts.tsval, opts.tsecr);
+ 		synproxy_send_client_ack_ipv6(net, skb, th, &opts);
+ 
+ 		consume_skb(skb);
+ 		return NF_STOLEN;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	synproxy_tstamp_adjust(skb, thoff, th, ct, ctinfo, synproxy);
+ 	return NF_ACCEPT;
+ }
+ EXPORT_SYMBOL_GPL(ipv6_synproxy_hook);
+ 
+ static const struct nf_hook_ops ipv6_synproxy_ops[] = {
+ 	{
+ 		.hook		= ipv6_synproxy_hook,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM - 1,
+ 	},
+ 	{
+ 		.hook		= ipv6_synproxy_hook,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM - 1,
+ 	},
+ };
+ 
+ int
+ nf_synproxy_ipv6_init(struct synproxy_net *snet, struct net *net)
+ {
+ 	int err;
+ 
+ 	if (snet->hook_ref6 == 0) {
+ 		err = nf_register_net_hooks(net, ipv6_synproxy_ops,
+ 					    ARRAY_SIZE(ipv6_synproxy_ops));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	snet->hook_ref6++;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nf_synproxy_ipv6_init);
+ 
+ void
+ nf_synproxy_ipv6_fini(struct synproxy_net *snet, struct net *net)
+ {
+ 	snet->hook_ref6--;
+ 	if (snet->hook_ref6 == 0)
+ 		nf_unregister_net_hooks(net, ipv6_synproxy_ops,
+ 					ARRAY_SIZE(ipv6_synproxy_ops));
+ }
+ EXPORT_SYMBOL_GPL(nf_synproxy_ipv6_fini);
+ #endif /* CONFIG_IPV6 */
+ 
++>>>>>>> e971ceb803e1 (netfilter: synproxy: fix rst sequence number mismatch)
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
* Unmerged path net/netfilter/nf_synproxy_core.c
