xfs: refactor inode unlinked pointer update functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit f2fc16a3d7c12224d4c19055fef40ca6379b2045
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f2fc16a3.failed

Hoist the functions that update an inode's unlinked pointer updates into
a helper.  No functional changes.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit f2fc16a3d7c12224d4c19055fef40ca6379b2045)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_trace.h
diff --cc fs/xfs/xfs_inode.c
index e66f940da2c6,eb51fa33f91a..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -1907,8 -1907,127 +1907,132 @@@ xfs_inactive
  }
  
  /*
++<<<<<<< HEAD
 + * This is called when the inode's link count has gone to 0 or we are creating
 + * a tmpfile via O_TMPFILE.  The inode @ip must have nlink == 0.
++=======
+  * Point the AGI unlinked bucket at an inode and log the results.  The caller
+  * is responsible for validating the old value.
+  */
+ STATIC int
+ xfs_iunlink_update_bucket(
+ 	struct xfs_trans	*tp,
+ 	xfs_agnumber_t		agno,
+ 	struct xfs_buf		*agibp,
+ 	unsigned int		bucket_index,
+ 	xfs_agino_t		new_agino)
+ {
+ 	struct xfs_agi		*agi = XFS_BUF_TO_AGI(agibp);
+ 	xfs_agino_t		old_value;
+ 	int			offset;
+ 
+ 	ASSERT(xfs_verify_agino_or_null(tp->t_mountp, agno, new_agino));
+ 
+ 	old_value = be32_to_cpu(agi->agi_unlinked[bucket_index]);
+ 	trace_xfs_iunlink_update_bucket(tp->t_mountp, agno, bucket_index,
+ 			old_value, new_agino);
+ 
+ 	/*
+ 	 * We should never find the head of the list already set to the value
+ 	 * passed in because either we're adding or removing ourselves from the
+ 	 * head of the list.
+ 	 */
+ 	if (old_value == new_agino)
+ 		return -EFSCORRUPTED;
+ 
+ 	agi->agi_unlinked[bucket_index] = cpu_to_be32(new_agino);
+ 	offset = offsetof(struct xfs_agi, agi_unlinked) +
+ 			(sizeof(xfs_agino_t) * bucket_index);
+ 	xfs_trans_log_buf(tp, agibp, offset, offset + sizeof(xfs_agino_t) - 1);
+ 	return 0;
+ }
+ 
+ /* Set an on-disk inode's next_unlinked pointer. */
+ STATIC void
+ xfs_iunlink_update_dinode(
+ 	struct xfs_trans	*tp,
+ 	xfs_agnumber_t		agno,
+ 	xfs_agino_t		agino,
+ 	struct xfs_buf		*ibp,
+ 	struct xfs_dinode	*dip,
+ 	struct xfs_imap		*imap,
+ 	xfs_agino_t		next_agino)
+ {
+ 	struct xfs_mount	*mp = tp->t_mountp;
+ 	int			offset;
+ 
+ 	ASSERT(xfs_verify_agino_or_null(mp, agno, next_agino));
+ 
+ 	trace_xfs_iunlink_update_dinode(mp, agno, agino,
+ 			be32_to_cpu(dip->di_next_unlinked), next_agino);
+ 
+ 	dip->di_next_unlinked = cpu_to_be32(next_agino);
+ 	offset = imap->im_boffset +
+ 			offsetof(struct xfs_dinode, di_next_unlinked);
+ 
+ 	/* need to recalc the inode CRC if appropriate */
+ 	xfs_dinode_calc_crc(mp, dip);
+ 	xfs_trans_inode_buf(tp, ibp);
+ 	xfs_trans_log_buf(tp, ibp, offset, offset + sizeof(xfs_agino_t) - 1);
+ 	xfs_inobp_check(mp, ibp);
+ }
+ 
+ /* Set an in-core inode's unlinked pointer and return the old value. */
+ STATIC int
+ xfs_iunlink_update_inode(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_agnumber_t		agno,
+ 	xfs_agino_t		next_agino,
+ 	xfs_agino_t		*old_next_agino)
+ {
+ 	struct xfs_mount	*mp = tp->t_mountp;
+ 	struct xfs_dinode	*dip;
+ 	struct xfs_buf		*ibp;
+ 	xfs_agino_t		old_value;
+ 	int			error;
+ 
+ 	ASSERT(xfs_verify_agino_or_null(mp, agno, next_agino));
+ 
+ 	error = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp, 0, 0);
+ 	if (error)
+ 		return error;
+ 
+ 	/* Make sure the old pointer isn't garbage. */
+ 	old_value = be32_to_cpu(dip->di_next_unlinked);
+ 	if (!xfs_verify_agino_or_null(mp, agno, old_value)) {
+ 		error = -EFSCORRUPTED;
+ 		goto out;
+ 	}
+ 
+ 	/*
+ 	 * Since we're updating a linked list, we should never find that the
+ 	 * current pointer is the same as the new value, unless we're
+ 	 * terminating the list.
+ 	 */
+ 	*old_next_agino = old_value;
+ 	if (old_value == next_agino) {
+ 		if (next_agino != NULLAGINO)
+ 			error = -EFSCORRUPTED;
+ 		goto out;
+ 	}
+ 
+ 	/* Ok, update the new pointer. */
+ 	xfs_iunlink_update_dinode(tp, agno, XFS_INO_TO_AGINO(mp, ip->i_ino),
+ 			ibp, dip, &ip->i_imap, next_agino);
+ 	return 0;
+ out:
+ 	xfs_trans_brelse(tp, ibp);
+ 	return error;
+ }
+ 
+ /*
+  * This is called when the inode's link count goes to 0 or we are creating a
+  * tmpfile via O_TMPFILE. In the case of a tmpfile, @ignore_linkcount will be
+  * set to true as the link count is dropped to zero by the VFS after we've
+  * created the file successfully, so we have to add it to the unlinked list
+  * while the link count is non-zero.
++>>>>>>> f2fc16a3d7c1 (xfs: refactor inode unlinked pointer update functions)
   *
   * We place the on-disk inode on a list in the AGI.  It will be pulled from this
   * list when the inode is freed.
@@@ -1927,10 -2044,8 +2049,9 @@@ xfs_iunlink
  	xfs_agnumber_t		agno = XFS_INO_TO_AGNO(mp, ip->i_ino);
  	xfs_agino_t		agino = XFS_INO_TO_AGINO(mp, ip->i_ino);
  	short			bucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;
- 	int			offset;
  	int			error;
  
 +	ASSERT(VFS_I(ip)->i_nlink == 0);
  	ASSERT(VFS_I(ip)->i_mode != 0);
  
  	/* Get the agi buffer first.  It ensures lock ordering on the list. */
@@@ -1950,41 -2065,21 +2071,29 @@@
  		return -EFSCORRUPTED;
  
  	if (next_agino != NULLAGINO) {
+ 		xfs_agino_t	old_agino;
+ 
  		/*
- 		 * There is already another inode in the bucket we need
- 		 * to add ourselves to.  Add us at the front of the list.
- 		 * Here we put the head pointer into our next pointer,
- 		 * and then we fall through to point the head at us.
+ 		 * There is already another inode in the bucket, so point this
+ 		 * inode to the current head of the list.
  		 */
- 		error = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,
- 				       0, 0);
+ 		error = xfs_iunlink_update_inode(tp, ip, agno, next_agino,
+ 				&old_agino);
  		if (error)
  			return error;
- 
- 		ASSERT(dip->di_next_unlinked == cpu_to_be32(NULLAGINO));
- 		dip->di_next_unlinked = agi->agi_unlinked[bucket_index];
- 		offset = ip->i_imap.im_boffset +
- 			offsetof(xfs_dinode_t, di_next_unlinked);
- 
- 		/* need to recalc the inode CRC if appropriate */
- 		xfs_dinode_calc_crc(mp, dip);
- 
- 		xfs_trans_inode_buf(tp, ibp);
- 		xfs_trans_log_buf(tp, ibp, offset,
- 				  (offset + sizeof(xfs_agino_t) - 1));
- 		xfs_inobp_check(mp, ibp);
+ 		ASSERT(old_agino == NULLAGINO);
  	}
  
 -	/* Point the head of the list to point to this inode. */
 -	return xfs_iunlink_update_bucket(tp, agno, agibp, bucket_index, agino);
 +	/*
 +	 * Point the bucket head pointer at the inode being inserted.
 +	 */
 +	ASSERT(agino != 0);
 +	agi->agi_unlinked[bucket_index] = cpu_to_be32(agino);
 +	offset = offsetof(xfs_agi_t, agi_unlinked) +
 +		(sizeof(xfs_agino_t) * bucket_index);
 +	xfs_trans_log_buf(tp, agibp, offset,
 +			  (offset + sizeof(xfs_agino_t) - 1));
 +	return 0;
  }
  
  /*
@@@ -2032,45 -2123,21 +2137,52 @@@ xfs_iunlink_remove
  		/*
  		 * We're at the head of the list.  Get the inode's on-disk
  		 * buffer to see if there is anyone after us on the list.
- 		 * Only modify our next pointer if it is not already NULLAGINO.
- 		 * This saves us the overhead of dealing with the buffer when
- 		 * there is no need to change it.
  		 */
- 		error = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,
- 				       0, 0);
- 		if (error) {
- 			xfs_warn(mp, "%s: xfs_imap_to_bp returned error %d.",
- 				__func__, error);
+ 		error = xfs_iunlink_update_inode(tp, ip, agno, NULLAGINO,
+ 				&next_agino);
+ 		if (error)
  			return error;
++<<<<<<< HEAD
 +		}
 +		next_agino = be32_to_cpu(dip->di_next_unlinked);
 +		ASSERT(next_agino != 0);
 +		if (next_agino != NULLAGINO) {
 +			dip->di_next_unlinked = cpu_to_be32(NULLAGINO);
 +			offset = ip->i_imap.im_boffset +
 +				offsetof(xfs_dinode_t, di_next_unlinked);
 +
 +			/* need to recalc the inode CRC if appropriate */
 +			xfs_dinode_calc_crc(mp, dip);
 +
 +			xfs_trans_inode_buf(tp, ibp);
 +			xfs_trans_log_buf(tp, ibp, offset,
 +					  (offset + sizeof(xfs_agino_t) - 1));
 +			xfs_inobp_check(mp, ibp);
 +		} else {
 +			xfs_trans_brelse(tp, ibp);
 +		}
 +		/*
 +		 * Point the bucket head pointer at the next inode.
 +		 */
 +		ASSERT(next_agino != 0);
 +		ASSERT(next_agino != agino);
 +		agi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);
 +		offset = offsetof(xfs_agi_t, agi_unlinked) +
 +			(sizeof(xfs_agino_t) * bucket_index);
 +		xfs_trans_log_buf(tp, agibp, offset,
 +				  (offset + sizeof(xfs_agino_t) - 1));
++=======
+ 
+ 		/* Point the head of the list to the next unlinked inode. */
+ 		error = xfs_iunlink_update_bucket(tp, agno, agibp, bucket_index,
+ 				next_agino);
+ 		if (error)
+ 			return error;
++>>>>>>> f2fc16a3d7c1 (xfs: refactor inode unlinked pointer update functions)
  	} else {
+ 		struct xfs_imap	imap;
+ 		xfs_agino_t	prev_agino;
+ 
  		/*
  		 * We need to search the list for the inode being freed.
  		 */
diff --cc fs/xfs/xfs_trace.h
index 6fcc893dfc91,fbec8f0e1a9a..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -3371,6 -3371,58 +3371,61 @@@ DEFINE_TRANS_EVENT(xfs_trans_roll)
  DEFINE_TRANS_EVENT(xfs_trans_add_item);
  DEFINE_TRANS_EVENT(xfs_trans_free_items);
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(xfs_iunlink_update_bucket,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, unsigned int bucket,
+ 		 xfs_agino_t old_ptr, xfs_agino_t new_ptr),
+ 	TP_ARGS(mp, agno, bucket, old_ptr, new_ptr),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(unsigned int, bucket)
+ 		__field(xfs_agino_t, old_ptr)
+ 		__field(xfs_agino_t, new_ptr)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->bucket = bucket;
+ 		__entry->old_ptr = old_ptr;
+ 		__entry->new_ptr = new_ptr;
+ 	),
+ 	TP_printk("dev %d:%d agno %u bucket %u old 0x%x new 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->bucket,
+ 		  __entry->old_ptr,
+ 		  __entry->new_ptr)
+ );
+ 
+ TRACE_EVENT(xfs_iunlink_update_dinode,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, xfs_agino_t agino,
+ 		 xfs_agino_t old_ptr, xfs_agino_t new_ptr),
+ 	TP_ARGS(mp, agno, agino, old_ptr, new_ptr),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agino_t, agino)
+ 		__field(xfs_agino_t, old_ptr)
+ 		__field(xfs_agino_t, new_ptr)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->agino = agino;
+ 		__entry->old_ptr = old_ptr;
+ 		__entry->new_ptr = new_ptr;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agino 0x%x old 0x%x new 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->agino,
+ 		  __entry->old_ptr,
+ 		  __entry->new_ptr)
+ );
+ 
++>>>>>>> f2fc16a3d7c1 (xfs: refactor inode unlinked pointer update functions)
  #endif /* _TRACE_XFS_H */
  
  #undef TRACE_INCLUDE_PATH
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_trace.h
