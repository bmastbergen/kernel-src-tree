NFS/flexfiles: refactor calls to fs4_ff_layout_prepare_ds()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 2444ff277a686d743b5479dd52d8357c21d5ce13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/2444ff27.failed

While we may want to skip attempting to connect to a downed mirror
when we're deciding which mirror to select for a read, we do not
want to do so once we've committed to attempting the I/O in
ff_layout_read/write_pagelist(), or ff_layout_initiate_commit()

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 2444ff277a686d743b5479dd52d8357c21d5ce13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/flexfilelayout/flexfilelayout.c
diff --cc fs/nfs/flexfilelayout/flexfilelayout.c
index 2c7d21aea13b,0134bcac46a7..000000000000
--- a/fs/nfs/flexfilelayout/flexfilelayout.c
+++ b/fs/nfs/flexfilelayout/flexfilelayout.c
@@@ -1718,7 -1732,8 +1726,12 @@@ ff_layout_read_pagelist(struct nfs_pgio
  	struct pnfs_layout_segment *lseg = hdr->lseg;
  	struct nfs4_pnfs_ds *ds;
  	struct rpc_clnt *ds_clnt;
++<<<<<<< HEAD
 +	struct rpc_cred *ds_cred;
++=======
+ 	struct nfs4_ff_layout_mirror *mirror;
+ 	const struct cred *ds_cred;
++>>>>>>> 2444ff277a68 (NFS/flexfiles: refactor calls to fs4_ff_layout_prepare_ds())
  	loff_t offset = hdr->args.offset;
  	u32 idx = hdr->pgio_mirror_idx;
  	int vers;
@@@ -1785,7 -1801,8 +1799,12 @@@ ff_layout_write_pagelist(struct nfs_pgi
  	struct pnfs_layout_segment *lseg = hdr->lseg;
  	struct nfs4_pnfs_ds *ds;
  	struct rpc_clnt *ds_clnt;
++<<<<<<< HEAD
 +	struct rpc_cred *ds_cred;
++=======
+ 	struct nfs4_ff_layout_mirror *mirror;
+ 	const struct cred *ds_cred;
++>>>>>>> 2444ff277a68 (NFS/flexfiles: refactor calls to fs4_ff_layout_prepare_ds())
  	loff_t offset = hdr->args.offset;
  	int vers;
  	struct nfs_fh *fh;
@@@ -1864,7 -1882,8 +1884,12 @@@ static int ff_layout_initiate_commit(st
  	struct pnfs_layout_segment *lseg = data->lseg;
  	struct nfs4_pnfs_ds *ds;
  	struct rpc_clnt *ds_clnt;
++<<<<<<< HEAD
 +	struct rpc_cred *ds_cred;
++=======
+ 	struct nfs4_ff_layout_mirror *mirror;
+ 	const struct cred *ds_cred;
++>>>>>>> 2444ff277a68 (NFS/flexfiles: refactor calls to fs4_ff_layout_prepare_ds())
  	u32 idx;
  	int vers, ret;
  	struct nfs_fh *fh;
* Unmerged path fs/nfs/flexfilelayout/flexfilelayout.c
diff --git a/fs/nfs/flexfilelayout/flexfilelayout.h b/fs/nfs/flexfilelayout/flexfilelayout.h
index da468f35e880..9693f294d98a 100644
--- a/fs/nfs/flexfilelayout/flexfilelayout.h
+++ b/fs/nfs/flexfilelayout/flexfilelayout.h
@@ -228,7 +228,8 @@ nfs4_ff_layout_select_ds_stateid(struct pnfs_layout_segment *lseg,
 				nfs4_stateid *stateid);
 
 struct nfs4_pnfs_ds *
-nfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,
+nfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg,
+			  struct nfs4_ff_layout_mirror *mirror,
 			  bool fail_return);
 
 struct rpc_clnt *
diff --git a/fs/nfs/flexfilelayout/flexfilelayoutdev.c b/fs/nfs/flexfilelayout/flexfilelayoutdev.c
index e54f4fb6813a..e57ed741bd6e 100644
--- a/fs/nfs/flexfilelayout/flexfilelayoutdev.c
+++ b/fs/nfs/flexfilelayout/flexfilelayoutdev.c
@@ -391,7 +391,7 @@ nfs4_ff_layout_select_ds_stateid(struct pnfs_layout_segment *lseg,
 /**
  * nfs4_ff_layout_prepare_ds - prepare a DS connection for an RPC call
  * @lseg: the layout segment we're operating on
- * @ds_idx: index of the DS to use
+ * @mirror: layout mirror describing the DS to use
  * @fail_return: return layout on connect failure?
  *
  * Try to prepare a DS connection to accept an RPC call. This involves
@@ -406,26 +406,18 @@ nfs4_ff_layout_select_ds_stateid(struct pnfs_layout_segment *lseg,
  * Returns a pointer to a connected DS object on success or NULL on failure.
  */
 struct nfs4_pnfs_ds *
-nfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,
+nfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg,
+			  struct nfs4_ff_layout_mirror *mirror,
 			  bool fail_return)
 {
-	struct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);
 	struct nfs4_pnfs_ds *ds = NULL;
-	struct nfs4_deviceid_node *devid;
 	struct inode *ino = lseg->pls_layout->plh_inode;
 	struct nfs_server *s = NFS_SERVER(ino);
 	unsigned int max_payload;
 	int status;
 
-	if (!ff_layout_mirror_valid(lseg, mirror, true)) {
-		pr_err_ratelimited("NFS: %s: No data server for offset index %d\n",
-			__func__, ds_idx);
+	if (!ff_layout_mirror_valid(lseg, mirror, true))
 		goto out;
-	}
-
-	devid = &mirror->mirror_ds->id_node;
-	if (ff_layout_test_devid_unavailable(devid))
-		goto out_fail;
 
 	ds = mirror->mirror_ds->ds;
 	/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */
@@ -436,8 +428,8 @@ nfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,
 	/* FIXME: For now we assume the server sent only one version of NFS
 	 * to use for the DS.
 	 */
-	status = nfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,
-			     dataserver_retrans,
+	status = nfs4_pnfs_ds_connect(s, ds, &mirror->mirror_ds->id_node,
+			     dataserver_timeo, dataserver_retrans,
 			     mirror->mirror_ds->ds_versions[0].version,
 			     mirror->mirror_ds->ds_versions[0].minor_version);
 
@@ -452,7 +444,6 @@ nfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,
 			mirror->mirror_ds->ds_versions[0].wsize = max_payload;
 		goto out;
 	}
-out_fail:
 	ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),
 				 mirror, lseg->pls_range.offset,
 				 lseg->pls_range.length, NFS4ERR_NXIO,
