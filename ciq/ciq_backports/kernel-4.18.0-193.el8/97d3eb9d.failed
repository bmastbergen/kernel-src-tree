cpuidle-haltpoll: vcpu hotplug support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Joao Martins <joao.m.martins@oracle.com>
commit 97d3eb9da84cae0548359b0aecb8619faad003b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/97d3eb9d.failed

When cpus != maxcpus cpuidle-haltpoll will fail to register all vcpus
past the online ones and thus fail to register the idle driver.
This is because cpuidle_add_sysfs() will return with -ENODEV as a
consequence from get_cpu_device() return no device for a non-existing
CPU.

Instead switch to cpuidle_register_driver() and manually register each
of the present cpus through cpuhp_setup_state() callbacks and future
ones that get onlined or offlined. This mimmics similar logic that
intel_idle does.

Fixes: fa86ee90eb11 ("add cpuidle-haltpoll driver")
	Signed-off-by: Joao Martins <joao.m.martins@oracle.com>
	Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Reviewed-by: Marcelo Tosatti <mtosatti@redhat.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 97d3eb9da84cae0548359b0aecb8619faad003b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpuidle_haltpoll.h
#	arch/x86/kernel/kvm.c
#	drivers/cpuidle/cpuidle-haltpoll.c
#	include/linux/cpuidle_haltpoll.h
diff --cc arch/x86/kernel/kvm.c
index 29cbffeb58e9,60bab4a3b36b..000000000000
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@@ -867,3 -875,39 +867,42 @@@ void __init kvm_spinlock_init(void
  }
  
  #endif	/* CONFIG_PARAVIRT_SPINLOCKS */
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_ARCH_CPUIDLE_HALTPOLL
+ 
+ static void kvm_disable_host_haltpoll(void *i)
+ {
+ 	wrmsrl(MSR_KVM_POLL_CONTROL, 0);
+ }
+ 
+ static void kvm_enable_host_haltpoll(void *i)
+ {
+ 	wrmsrl(MSR_KVM_POLL_CONTROL, 1);
+ }
+ 
+ void arch_haltpoll_enable(unsigned int cpu)
+ {
+ 	if (!kvm_para_has_feature(KVM_FEATURE_POLL_CONTROL)) {
+ 		pr_err_once("kvm: host does not support poll control\n");
+ 		pr_err_once("kvm: host upgrade recommended\n");
+ 		return;
+ 	}
+ 
+ 	/* Enable guest halt poll disables host halt poll */
+ 	smp_call_function_single(cpu, kvm_disable_host_haltpoll, NULL, 1);
+ }
+ EXPORT_SYMBOL_GPL(arch_haltpoll_enable);
+ 
+ void arch_haltpoll_disable(unsigned int cpu)
+ {
+ 	if (!kvm_para_has_feature(KVM_FEATURE_POLL_CONTROL))
+ 		return;
+ 
+ 	/* Enable guest halt poll disables host halt poll */
+ 	smp_call_function_single(cpu, kvm_enable_host_haltpoll, NULL, 1);
+ }
+ EXPORT_SYMBOL_GPL(arch_haltpoll_disable);
+ #endif
++>>>>>>> 97d3eb9da84c (cpuidle-haltpoll: vcpu hotplug support)
diff --cc drivers/cpuidle/cpuidle-haltpoll.c
index 0a34979b43b6,56d8ab814466..000000000000
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@@ -15,7 -16,11 +16,10 @@@
  #include <linux/module.h>
  #include <linux/sched/idle.h>
  #include <linux/kvm_para.h>
 -#include <linux/cpuidle_haltpoll.h>
  
+ static struct cpuidle_device __percpu *haltpoll_cpuidle_devices;
+ static enum cpuhp_state haltpoll_hp_state;
+ 
  static int default_enter_idle(struct cpuidle_device *dev,
  			      struct cpuidle_driver *drv, int index)
  {
@@@ -45,21 -50,81 +49,88 @@@ static struct cpuidle_driver haltpoll_d
  	.state_count = 2,
  };
  
+ static int haltpoll_cpu_online(unsigned int cpu)
+ {
+ 	struct cpuidle_device *dev;
+ 
+ 	dev = per_cpu_ptr(haltpoll_cpuidle_devices, cpu);
+ 	if (!dev->registered) {
+ 		dev->cpu = cpu;
+ 		if (cpuidle_register_device(dev)) {
+ 			pr_notice("cpuidle_register_device %d failed!\n", cpu);
+ 			return -EIO;
+ 		}
+ 		arch_haltpoll_enable(cpu);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int haltpoll_cpu_offline(unsigned int cpu)
+ {
+ 	struct cpuidle_device *dev;
+ 
+ 	dev = per_cpu_ptr(haltpoll_cpuidle_devices, cpu);
+ 	if (dev->registered) {
+ 		arch_haltpoll_disable(cpu);
+ 		cpuidle_unregister_device(dev);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void haltpoll_uninit(void)
+ {
+ 	if (haltpoll_hp_state)
+ 		cpuhp_remove_state(haltpoll_hp_state);
+ 	cpuidle_unregister_driver(&haltpoll_driver);
+ 
+ 	free_percpu(haltpoll_cpuidle_devices);
+ 	haltpoll_cpuidle_devices = NULL;
+ }
+ 
  static int __init haltpoll_init(void)
  {
 -	int ret;
  	struct cpuidle_driver *drv = &haltpoll_driver;
  
  	cpuidle_poll_state_init(drv);
  
  	if (!kvm_para_available())
 -		return 0;
 +		return -ENODEV;
  
++<<<<<<< HEAD
 +	return cpuidle_register(&haltpoll_driver, NULL);
++=======
+ 	ret = cpuidle_register_driver(drv);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	haltpoll_cpuidle_devices = alloc_percpu(struct cpuidle_device);
+ 	if (haltpoll_cpuidle_devices == NULL) {
+ 		cpuidle_unregister_driver(drv);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "cpuidle/haltpoll:online",
+ 				haltpoll_cpu_online, haltpoll_cpu_offline);
+ 	if (ret < 0) {
+ 		haltpoll_uninit();
+ 	} else {
+ 		haltpoll_hp_state = ret;
+ 		ret = 0;
+ 	}
+ 
+ 	return ret;
++>>>>>>> 97d3eb9da84c (cpuidle-haltpoll: vcpu hotplug support)
  }
  
  static void __exit haltpoll_exit(void)
  {
++<<<<<<< HEAD
 +	cpuidle_unregister(&haltpoll_driver);
++=======
+ 	haltpoll_uninit();
++>>>>>>> 97d3eb9da84c (cpuidle-haltpoll: vcpu hotplug support)
  }
  
  module_init(haltpoll_init);
* Unmerged path arch/x86/include/asm/cpuidle_haltpoll.h
* Unmerged path include/linux/cpuidle_haltpoll.h
* Unmerged path arch/x86/include/asm/cpuidle_haltpoll.h
* Unmerged path arch/x86/kernel/kvm.c
* Unmerged path drivers/cpuidle/cpuidle-haltpoll.c
* Unmerged path include/linux/cpuidle_haltpoll.h
