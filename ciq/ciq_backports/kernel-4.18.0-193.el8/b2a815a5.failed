powerpc/fadump: improve how crashed kernel's memory is reserved

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Hari Bathini <hbathini@linux.ibm.com>
commit b2a815a554a34f0e6fab4526ae762d5528783600
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b2a815a5.failed

The size parameter to fadump_reserve_crash_area() function is not needed
as all the memory above boot memory size must be preserved anyway. Update
the function by dropping this redundant parameter.

	Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/156821374440.5656.2945512543806951766.stgit@hbathini.in.ibm.com
(cherry picked from commit b2a815a554a34f0e6fab4526ae762d5528783600)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/fadump.c
diff --cc arch/powerpc/kernel/fadump.c
index 56526469b148,6f52a60bc212..000000000000
--- a/arch/powerpc/kernel/fadump.c
+++ b/arch/powerpc/kernel/fadump.c
@@@ -45,17 -32,13 +45,19 @@@
  #include <asm/fadump-internal.h>
  #include <asm/setup.h>
  
 +#include "../platforms/pseries/rtas-fadump.h"
 +
  static struct fw_dump fw_dump;
 +static struct rtas_fadump_mem_struct fdm;
 +static const struct rtas_fadump_mem_struct *fdm_active;
  
+ static void __init fadump_reserve_crash_area(u64 base);
+ 
  static DEFINE_MUTEX(fadump_mutex);
 -struct fadump_mrange_info crash_mrange_info = { "crash", NULL, 0, 0, 0 };
 -struct fadump_mrange_info reserved_mrange_info = { "reserved", NULL, 0, 0, 0 };
 +struct fad_crash_memory_ranges *crash_memory_ranges;
 +int crash_memory_ranges_size;
 +int crash_mem_ranges;
 +int max_crash_mem_ranges;
  
  #ifdef CONFIG_CMA
  static struct cma *fadump_cma;
@@@ -431,29 -316,15 +433,9 @@@ static unsigned long get_fadump_area_si
  	return size;
  }
  
- static void __init fadump_reserve_crash_area(unsigned long base,
- 					     unsigned long size)
- {
- 	struct memblock_region *reg;
- 	unsigned long mstart, mend, msize;
- 
- 	for_each_memblock(memory, reg) {
- 		mstart = max_t(unsigned long, base, reg->base);
- 		mend = reg->base + reg->size;
- 		mend = min(base + size, mend);
- 
- 		if (mstart < mend) {
- 			msize = mend - mstart;
- 			memblock_reserve(mstart, msize);
- 			pr_info("Reserved %ldMB of memory at %#016lx for saving crash dump\n",
- 				(msize >> 20), mstart);
- 		}
- 	}
- }
- 
  int __init fadump_reserve_mem(void)
  {
 -	bool is_memblock_bottom_up = memblock_bottom_up();
 -	u64 base, size, mem_boundary, align = PAGE_SIZE;
 -	int ret = 1;
 +	unsigned long base, size, memory_boundary;
  
  	if (!fw_dump.fadump_enabled)
  		return 0;
@@@ -517,25 -388,15 +499,29 @@@
  #endif
  		/*
  		 * If last boot has crashed then reserve all the memory
- 		 * above boot_memory_size so that we don't touch it until
+ 		 * above boot memory size so that we don't touch it until
  		 * dump is written to disk by userspace tool. This memory
- 		 * will be released for general use once the dump is saved.
+ 		 * can be released for general use by invalidating fadump.
  		 */
++<<<<<<< HEAD
 +		base = fw_dump.boot_memory_size;
 +		size = memory_boundary - base;
 +		fadump_reserve_crash_area(base, size);
++=======
+ 		fadump_reserve_crash_area(base);
++>>>>>>> b2a815a554a3 (powerpc/fadump: improve how crashed kernel's memory is reserved)
  
 -		pr_debug("fadumphdr_addr = %#016lx\n", fw_dump.fadumphdr_addr);
 -		pr_debug("Reserve dump area start address: 0x%lx\n",
 -			 fw_dump.reserve_dump_area_start);
 +		fw_dump.fadumphdr_addr =
 +				be64_to_cpu(fdm_active->rmr_region.destination_address) +
 +				be64_to_cpu(fdm_active->rmr_region.source_len);
 +		pr_debug("fadumphdr_addr = %pa\n", &fw_dump.fadumphdr_addr);
 +
 +		/*
 +		 * Start address of reserve dump area (permanent reservation)
 +		 * for re-registering FADump after dump capture.
 +		 */
 +		fw_dump.reserve_dump_area_start =
 +			be64_to_cpu(fdm_active->cpu_state_data.destination_address);
  	} else {
  		/*
  		 * Reserve memory at an offset closer to bottom of the RAM to
* Unmerged path arch/powerpc/kernel/fadump.c
