net: ipmr: fix unresolved entry dumps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] ipmr: fix unresolved entry dumps (Guillaume Nault) [1765639]
Rebuild_FUZZ: 92.75%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit eddf016b910486d2123675a6b5fd7d64f77cdca8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/eddf016b.failed

If the skb space ends in an unresolved entry while dumping we'll miss
some unresolved entries. The reason is due to zeroing the entry counter
between dumping resolved and unresolved mfc entries. We should just
keep counting until the whole table is dumped and zero when we move to
the next as we have a separate table counter.

	Reported-by: Colin Ian King <colin.king@canonical.com>
Fixes: 8fb472c09b9d ("ipmr: improve hash scalability")
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eddf016b910486d2123675a6b5fd7d64f77cdca8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ipmr_base.c
diff --cc net/ipv4/ipmr_base.c
index 950b0dfaf86f,eab8cd5ec2f5..000000000000
--- a/net/ipv4/ipmr_base.c
+++ b/net/ipv4/ipmr_base.c
@@@ -370,11 -286,33 +370,24 @@@ int mr_rtm_dumproute(struct sk_buff *sk
  	for (mrt = iter(net, NULL); mrt; mrt = iter(net, mrt)) {
  		if (t < s_t)
  			goto next_table;
++<<<<<<< HEAD
++=======
+ 		list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list) {
+ 			if (e < s_e)
+ 				goto next_entry;
+ 			if (fill(mrt, skb, NETLINK_CB(cb->skb).portid,
+ 				 cb->nlh->nlmsg_seq, mfc,
+ 				 RTM_NEWROUTE, NLM_F_MULTI) < 0)
+ 				goto done;
+ next_entry:
+ 			e++;
+ 		}
++>>>>>>> eddf016b9104 (net: ipmr: fix unresolved entry dumps)
  
 -		spin_lock_bh(lock);
 -		list_for_each_entry(mfc, &mrt->mfc_unres_queue, list) {
 -			if (e < s_e)
 -				goto next_entry2;
 -			if (fill(mrt, skb, NETLINK_CB(cb->skb).portid,
 -				 cb->nlh->nlmsg_seq, mfc,
 -				 RTM_NEWROUTE, NLM_F_MULTI) < 0) {
 -				spin_unlock_bh(lock);
 -				goto done;
 -			}
 -next_entry2:
 -			e++;
 -		}
 -		spin_unlock_bh(lock);
 -		e = 0;
 -		s_e = 0;
 +		err = mr_table_dump(mrt, skb, cb, fill, lock, filter);
 +		if (err < 0)
 +			break;
 +		cb->args[1] = 0;
  next_table:
  		t++;
  	}
* Unmerged path net/ipv4/ipmr_base.c
